{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2023\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / text import filter\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n\n\n#include <gpac/filters.h>\n#include <gpac/constants.h>\n#include <gpac/utf.h>\n#include <gpac/xml.h>\n#include <gpac/token.h>\n#include <gpac/color.h>\n#include <gpac/network.h>\n#include <gpac/internal/media_dev.h>\n#include <gpac/internal/isomedia_dev.h>\n\n#ifndef GPAC_DISABLE_SWF_IMPORT\n/* SWF Importer */\n#include <gpac/internal/swf_dev.h>\n#endif\n\n#if !defined(GPAC_DISABLE_ISOM_WRITE)\n\n#define TTML_NAMESPACE \"http://www.w3.org/ns/ttml\"\n\n#define CHECK_STR(__str)\t\\\n\tif (!__str) { \\\n\t\te = gf_import_message(import, GF_BAD_PARAM, \"Invalid XML formatting (line %d)\", parser.line);\t\\\n\t\tgoto exit;\t\\\n\t}\n\n\ntypedef struct __txtin_ctx GF_TXTIn;\n\nenum\n{\n\tSTXT_MODE_STXT=0,\n\tSTXT_MODE_TX3G,\n\tSTXT_MODE_VTT,\n};\n\nstruct __txtin_ctx\n{\n\t//opts\n\tu32 width, height, txtx, txty, fontsize, stxtmod;\n\ts32 zorder;\n\tconst char *fontname, *lang, *ttml_zero;\n\tBool nodefbox, noflush, webvtt, ttml_embed, no_empty;\n\tu32 timescale;\n\tGF_Fraction fps;\n\tBool ttml_split;\n\tGF_Fraction64 ttml_cts;\n\tGF_Fraction ttml_dur, stxtdur;\n\n\n\tGF_FilterPid *ipid, *opid;\n\tchar *file_name;\n\tu32 fmt;\n\tu32 playstate;\n\t//0: not seeking, 1: seek request pending, 2: seek configured, discarding packets up until start_range\n\tu32 seek_state;\n\tDouble start_range;\n\n\tBool is_loaded;\n\tBool is_setup;\n\n\tGF_Err (*text_process)(GF_Filter *filter, GF_TXTIn *ctx, GF_FilterPacket *ipck);\n\n\ts32 unicode_type;\n\n\tFILE *src;\n\n\tGF_BitStream *bs_w;\n\tBool first_samp;\n\tBool hdr_parsed;\n\tBool unframed, simple_text;\n\n\t//state vars for srt\n\tu32 state, default_color;\n\tGF_TextSample *samp;\n\tu64 start, end, prev_end;\n\tu32 curLine;\n\tGF_StyleRecord style;\n\n#ifndef GPAC_DISABLE_VTT\n\t//WebVTT state\n\tGF_WebVTTParser *vttparser;\n#endif\n\n\t//TTXT state\n\tGF_DOMParser *parser;\n\tu32 cur_child_idx, nb_children, last_desc_idx;\n\tGF_List *text_descs;\n\tBool last_sample_empty;\n\tu64 last_sample_duration;\n\t//TTML state is the same as ttxt plus the timescale and start (webvtt) for cts compute\n\tu32 txml_timescale;\n\tu32 current_tt_interval;\n\n\t//TTML state\n\tGF_XMLNode *root_working_copy, *body_node;\n\tGF_DOMParser *parser_working_copy;\n\tBool non_compliant_ttml;\n\tu32 tick_rate, ttml_fps_num, ttml_fps_den, ttml_sfps;\n\tGF_List *ttml_resources;\n\tGF_List *div_nodes_list;\n\tBool has_images;\n\n#ifndef GPAC_DISABLE_SWF_IMPORT\n\t//SWF text\n\tSWFReader *swf_parse;\n\tBool do_suspend;\n#endif\n\n\tBool vtt_to_tx3g;\n\tBool srt_to_tx3g;\n\n\tGF_List *intervals;\n\tu64 cts_first_interval;\n};\n\ntypedef struct\n{\n\tu32 size;\n\tu8 *data;\n\tBool global;\n} TTMLRes;\n\ntypedef struct\n{\n\ts64 begin, end;\n\tGF_List *resources;\n} TTMLInterval;\n\n\nenum\n{\n\tGF_TXTIN_MODE_NONE = 0,\n\tGF_TXTIN_MODE_SRT,\n\tGF_TXTIN_MODE_SUB,\n\tGF_TXTIN_MODE_TTXT,\n\tGF_TXTIN_MODE_TEXML,\n\tGF_TXTIN_MODE_WEBVTT,\n\tGF_TXTIN_MODE_TTML,\n\tGF_TXTIN_MODE_SWF_SVG,\n\tGF_TXTIN_MODE_SSA,\n\tGF_TXTIN_MODE_SIMPLE,\n};\n\n#define REM_TRAIL_MARKS(__str, __sep) while (1) {\t\\\n\t\tu32 _len = (u32) strlen(__str);\t\t\\\n\t\tif (!_len) break;\t\\\n\t\t_len--;\t\t\t\t\\\n\t\tif (strchr(__sep, __str[_len])) __str[_len] = 0;\t\\\n\t\telse break;\t\\\n\t}\t\\\n\n\ns32 gf_text_get_utf_type(GF_TXTIn *ctx, FILE *in_src)\n{\n\tu32 read;\n\tunsigned char BOM[5];\n\tread = (u32) gf_fread(BOM, 5, in_src);\n\tif ((s32) read < 1)\n\t\treturn -1;\n\n\tif ((BOM[0]==0xFF) && (BOM[1]==0xFE)) {\n\t\t/*UTF32 not supported*/\n\t\tif (!BOM[2] && !BOM[3])\n\t\t\treturn -1;\n\t\tgf_fseek(in_src, 2, SEEK_SET);\n\t\treturn 3;\n\t}\n\tif ((BOM[0]==0xFE) && (BOM[1]==0xFF)) {\n\t\t/*UTF32 not supported*/\n\t\tif (!BOM[2] && !BOM[3])\n\t\t\treturn -1;\n\t\tgf_fseek(in_src, 2, SEEK_SET);\n\t\treturn 2;\n\t} else if ((BOM[0]==0xEF) && (BOM[1]==0xBB) && (BOM[2]==0xBF)) {\n\t\tgf_fseek(in_src, 3, SEEK_SET);\n\t\treturn 1;\n\t}\n\tgf_fseek(in_src, 0, SEEK_SET);\n\n\tif (BOM[0]<0x80) {\n\t\treturn 0;\n\t}\n\t//check if ad-hoc charset is set\n\tconst char *opt = gf_opts_get_key(\"core\", \"charset\");\n\tif (ctx->ipid) {\n\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_CHARSET);\n\t\tif (p && p->value.string) opt = p->value.string;\n\t}\n\tif (opt) {\n\t\tif (!stricmp(opt, \"utf8\") || !stricmp(opt, \"utf-8\")) return 1;\n\t\tif (!stricmp(opt, \"utf16\") || !stricmp(opt, \"utf-16\")) return 2;\n\t\tif (!stricmp(opt, \"utf16be\") || !stricmp(opt, \"utf-16be\") || !stricmp(opt, \"utf-16-be\") || !stricmp(opt, \"utf16-be\")) return 3;\n\t\treturn 0;\n\t}\n\t//otherwise if we have legal UTF8, assume utf8\n\tif (gf_utf8_is_legal(BOM, 2) || gf_utf8_is_legal(BOM, 3) || gf_utf8_is_legal(BOM, 4) ) {\n\t\treturn 0;\n\t}\n\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] Unknown text encoding for PID %s, defaulting to passthrough - use `-charset` to override\\n\", gf_filter_pid_get_name(ctx->ipid)));\n\treturn 0;\n}\nstatic void ttxt_dom_progress(void *cbk, u64 cur_samp, u64 count)\n{\n\tGF_TXTIn *ctx = (GF_TXTIn *)cbk;\n\tctx->end = count;\n}\n\nstatic GF_Err gf_text_guess_format(GF_TXTIn *ctx, const char *filename, u32 *fmt)\n{\n\tchar szLine[2048], *line;\n\tu32 val;\n\ts32 uni_type;\n\tFILE *test = gf_fopen(filename, \"rb\");\n\tif (!test) return GF_URL_ERROR;\n\tuni_type = gf_text_get_utf_type(ctx, test);\n\n\tif (uni_type>1) {\n\t\tconst u16 *sptr;\n\t\tchar szUTF[1024];\n\t\tu32 read = (u32) gf_fread(szUTF, 1023, test);\n\t\tif ((s32) read < 0) {\n\t\t\tgf_fclose(test);\n\t\t\treturn GF_IO_ERR;\n\t\t}\n\t\tszUTF[read]=0;\n\t\tsptr = (u16*)szUTF;\n\t\t/*read = (u32) */gf_utf8_wcstombs(szLine, read, &sptr);\n\t} else {\n\t\tval = (u32) gf_fread(szLine, 1024, test);\n\t\tif ((s32) val<0) return GF_IO_ERR;\n\n\t\tszLine[val]=0;\n\t}\n\tREM_TRAIL_MARKS(szLine, \"\\r\\n\\t \")\n\n\t//strip all spaces and \\r\\n\\t\n\tline = szLine;\n\twhile (line[0] && strchr(\"\\n\\r\\t \", (char) line[0]))\n\t\tline ++;\n\n\n\t*fmt = GF_TXTIN_MODE_NONE;\n\tif ((line[0]=='{') && strstr(line, \"}{\")) *fmt = GF_TXTIN_MODE_SUB;\n\telse if (line[0] == '<') {\n\t\tchar *ext = gf_file_ext_start(filename);\n\t\tif (ext && !strnicmp(ext, \".ttxt\", 5)) *fmt = GF_TXTIN_MODE_TTXT;\n\t\telse if (ext && !strnicmp(ext, \".ttml\", 5)) *fmt = GF_TXTIN_MODE_TTML;\n\t\text = strstr(line, \"?>\");\n\t\tif (ext) ext += 2;\n\t\tif (ext && !ext[0]) {\n\t\t\tif (!gf_fgets(szLine, 2048, test))\n\t\t\t\tszLine[0] = '\\0';\n\t\t}\n\t\tif (strstr(szLine, \"x-quicktime-tx3g\") || strstr(szLine, \"text3GTrack\")) *fmt = GF_TXTIN_MODE_TEXML;\n\t\telse if (strstr(szLine, \"TextStream\")) *fmt = GF_TXTIN_MODE_TTXT;\n\t\telse if (strstr(szLine, \"<tt \") || strstr(szLine, \":tt \")) *fmt = GF_TXTIN_MODE_TTML;\n\t}\n\telse if (strstr(line, \"WEBVTT\") )\n\t\t*fmt = GF_TXTIN_MODE_WEBVTT;\n\telse if (strstr(line, \" --> \") )\n\t\t*fmt = GF_TXTIN_MODE_SRT; /* might want to change the default to WebVTT */\n\n\telse if (!strncmp(line, \"FWS\", 3) || !strncmp(line, \"CWS\", 3))\n\t\t*fmt = GF_TXTIN_MODE_SWF_SVG;\n\telse if (!strncmp(line, \"[Script Info]\", 13) )\n\t\t*fmt = GF_TXTIN_MODE_SSA;\n\n\tgf_fclose(test);\n\treturn GF_OK;\n}\n\n\n\nchar *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32 unicode_type)\n{\n\tu32 i, j, len;\n\tchar *sOK;\n\tchar szLineConv[2048];\n\tunsigned short *sptr;\n\n\tmemset(szLine, 0, sizeof(char)*lineSize);\n\tsOK = gf_fgets(szLine, lineSize, txt_in);\n\tif (!sOK) return NULL;\n\tif (unicode_type<=1) {\n\t\tj=0;\n\t\tlen = (u32) strlen(szLine);\n\t\tfor (i=0; i<len; i++) {\n\t\t\tif (!unicode_type && (szLine[i] & 0x80)) {\n\t\t\t\t/*non UTF8 (likely some win-CP)*/\n\t\t\t\tif ((szLine[i+1] & 0xc0) != 0x80) {\n\t\t\t\t\tszLineConv[j] = 0xc0 | ( (szLine[i] >> 6) & 0x3 );\n\t\t\t\t\tj++;\n\t\t\t\t\tszLine[i] &= 0xbf;\n\t\t\t\t}\n\t\t\t\t/*UTF8 2 bytes char*/\n\t\t\t\telse if ( (szLine[i] & 0xe0) == 0xc0) {\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t/*UTF8 3 bytes char*/\n\t\t\t\telse if ( (szLine[i] & 0xf0) == 0xe0) {\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t/*UTF8 4 bytes char*/\n\t\t\t\telse if ( (szLine[i] & 0xf8) == 0xf0) {\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t} else {\n\t\t\t\t\ti+=1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tszLineConv[j] = szLine[i];\n\t\t\tj++;\n\n\t\t\tif (j >= GF_ARRAY_LENGTH(szLineConv) - 1) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[TXTIn] Line too long to convert to utf8 (len: %d)\\n\", len));\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t\tszLineConv[j] = 0;\n\t\tstrcpy(szLine, szLineConv);\n\t\treturn sOK;\n\t}\n\n#ifdef GPAC_BIG_ENDIAN\n\tif (unicode_type==3)\n#else\n\tif (unicode_type==2)\n#endif\n\t{\n\t\ti=0;\n\t\twhile (1) {\n\t\t\tchar c;\n\t\t\tif (!szLine[i] && !szLine[i+1]) break;\n\t\t\tc = szLine[i+1];\n\t\t\tszLine[i+1] = szLine[i];\n\t\t\tszLine[i] = c;\n\t\t\ti+=2;\n\t\t}\n\t}\n\tsptr = (u16 *)szLine;\n\ti = gf_utf8_wcstombs(szLineConv, 2048, (const unsigned short **) &sptr);\n\tif (i == GF_UTF8_FAIL) i = 0;\n\tszLineConv[i] = 0;\n\tstrcpy(szLine, szLineConv);\n\t/*this is ugly indeed: since input is UTF16-LE, there are many chances the gf_fgets never reads the \\0 after a \\n*/\n\tif (unicode_type==3) gf_fgetc(txt_in);\n\treturn sOK;\n}\n\n\nstatic void txtin_probe_duration(GF_TXTIn *ctx)\n{\n\tGF_Fraction64 dur;\n\tdur.num = 0;\n\n\tif (ctx->fmt == GF_TXTIN_MODE_SWF_SVG) {\n#ifndef GPAC_DISABLE_SWF_IMPORT\n\t\tu32 frame_count, frame_rate;\n\t\tgf_swf_get_duration(ctx->swf_parse, &frame_rate, &frame_count);\n\t\tif (frame_count) {\n\t\t\tGF_Fraction64 tdur;\n\t\t\ttdur.num = frame_count;\n\t\t\ttdur.den = frame_rate;\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, &PROP_FRAC64(tdur));\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PLAYBACK_MODE, &PROP_UINT(GF_PLAYBACK_MODE_FASTFORWARD ) );\n\t\t}\n#endif\n\t\treturn;\n\t}\n\tif ((ctx->fmt == GF_TXTIN_MODE_SRT) || (ctx->fmt == GF_TXTIN_MODE_WEBVTT) || (ctx->fmt == GF_TXTIN_MODE_SUB) || (ctx->fmt == GF_TXTIN_MODE_SSA)) {\n\t\tu64 pos = gf_ftell(ctx->src);\n\t\tgf_fseek(ctx->src, 0, SEEK_SET);\n\t\twhile (!gf_feof(ctx->src)) {\n\t\t\tu64 end;\n\t\t\tchar szLine[2048];\n\t\t\tchar *sOK = gf_text_get_utf8_line(szLine, 2048, ctx->src, ctx->unicode_type);\n\t\t\tif (!sOK) break;\n\t\t\tREM_TRAIL_MARKS(szLine, \"\\r\\n\\t \")\n\n\t\t\tif (ctx->fmt == GF_TXTIN_MODE_SUB) {\n\t\t\t\tchar szText[2048];\n\t\t\t\tu32 sframe, eframe;\n\t\t\t\tif (sscanf(szLine, \"{%d}{%d}%2047s\", &sframe, &eframe, szText) == 3) {\n\t\t\t\t\tif (ctx->fps.den)\n\t\t\t\t\t\tend = 1000 * eframe * ctx->fps.num / ctx->fps.den;\n\t\t\t\t\telse\n\t\t\t\t\t\tend = 1000 * eframe / 25;\n\t\t\t\t\tif (end > (u64) dur.num) dur.num = (s64) end;\n\t\t\t\t}\n\t\t\t} else if (ctx->fmt == GF_TXTIN_MODE_SSA) {\n\t\t\t\tif (strncmp(szLine, \"Dialogue: \", 10)) continue;\n\t\t\t\tchar *start_p = strchr(szLine+10, ',');\n\t\t\t\tif (!start_p) continue;\n\t\t\t\tchar *end_p = strchr(start_p+1, ',');\n\t\t\t\tif (!end_p) continue;\n\t\t\t\tend_p[0] = 0;\n\t\t\t\tend_p +=1;\n\t\t\t\tstart_p = strchr(end_p, ',');\n\t\t\t\tif (start_p) start_p[0] = 0;\n\n\t\t\t\tu32 eh, em, es, ems;\n\t\t\t\tif (sscanf(end_p, \"%u:%u:%u.%u\", &eh, &em, &es, &ems) != 4) {\n\t\t\t\t\teh = 0;\n\t\t\t\t\tif (sscanf(end_p, \"%u:%u.%u\", &em, &es, &ems) != 3) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tend = (3600*eh + 60*em + es)*1000 + ems;\n\t\t\t\tif (end > (u64) dur.num) dur.num = (s64) end;\n\t\t\t} else {\n\t\t\t\tu32 eh, em, es, ems;\n\t\t\t\tchar *start = strstr(szLine, \"-->\");\n\t\t\t\tif (!start) continue;\n\t\t\t\tstart+=3;\n\t\t\t\twhile (start[0] && ((start[0] == ' ') || (start[0] == '\\t'))) start++;\n\n\t\t\t\tif (sscanf(start, \"%u:%u:%u,%u\", &eh, &em, &es, &ems) != 4) {\n\t\t\t\t\teh = 0;\n\t\t\t\t\tif (sscanf(szLine, \"%u:%u,%u\", &em, &es, &ems) != 3) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tend = (3600*eh + 60*em + es)*1000 + ems;\n\t\t\t\tif (end > (u64) dur.num) dur.num = (s64) end;\n\t\t\t}\n\t\t}\n\t\tgf_fseek(ctx->src, pos, SEEK_SET);\n\t\tif (dur.num) {\n\t\t\tdur.den = 1000;\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, &PROP_FRAC64(dur));\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PLAYBACK_MODE, &PROP_UINT(GF_PLAYBACK_MODE_FASTFORWARD ) );\n\t\t}\n\t\treturn;\n\t}\n\tif ((ctx->fmt == GF_TXTIN_MODE_TTXT) || (ctx->fmt == GF_TXTIN_MODE_TEXML)) {\n\t\tu32 i=0;\n\t\tGF_XMLNode *node, *root = gf_xml_dom_get_root(ctx->parser);\n\t\twhile ((node = gf_list_enum(root->content, &i))) {\n\t\t\tu32 j;\n\t\t\tu64 duration;\n\t\t\tGF_XMLAttribute *att;\n\t\t\tif (node->type) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*sample text*/\n\t\t\tif ((ctx->fmt == GF_TXTIN_MODE_TTXT) && strcmp(node->name, \"TextSample\")) continue;\n\t\t\telse if ((ctx->fmt == GF_TXTIN_MODE_TEXML) && strcmp(node->name, \"sample\")) continue;\n\n\n\t\t\tj=0;\n\t\t\twhile ( (att=(GF_XMLAttribute*)gf_list_enum(node->attributes, &j))) {\n\t\t\t\tu32 h, m, s, ms;\n\t\t\t\tu64 ts=0;\n\t\t\t\tif (ctx->fmt == GF_TXTIN_MODE_TTXT) {\n\t\t\t\t\tif (strcmp(att->name, \"sampleTime\")) continue;\n\n\t\t\t\t\tif (sscanf(att->value, \"%u:%u:%u.%u\", &h, &m, &s, &ms) == 4) {\n\t\t\t\t\t\tts = (h*3600 + m*60 + s)*1000 + ms;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tts = (u32) (atof(att->value) * 1000);\n\t\t\t\t\t}\n\t\t\t\t\tif (ts > (u64) dur.num) dur.num = (s64) ts;\n\t\t\t\t} else {\n\t\t\t\t\tif (strcmp(att->name, \"duration\")) continue;\n\t\t\t\t\tduration = atoi(att->value);\n\t\t\t\t\tdur.num += (s32) ( (1000 * duration) / ctx->txml_timescale);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dur.num) {\n\t\t\tdur.den = 1000;\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, &PROP_FRAC64(dur));\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PLAYBACK_MODE, &PROP_UINT(GF_PLAYBACK_MODE_FASTFORWARD ) );\n\t\t}\n\t\treturn;\n\t}\n\n\tif (ctx->fmt == GF_TXTIN_MODE_TTML) {\n\t\tu32 i=0, k=0;\n\t\tGF_XMLNode *div_node;\n\n\t\twhile ((div_node = gf_list_enum(ctx->div_nodes_list, &k))) {\n\t\t\tGF_XMLNode *node;\n\t\t\twhile ((node = gf_list_enum(div_node->content, &i))) {\n\t\t\t\tGF_XMLNode *p_node;\n\t\t\t\tGF_XMLAttribute *att;\n\t\t\t\tu32 h, m, s, ms, p_idx=0;\n\t\t\t\tu64 ts_end=0;\n\t\t\t\th = m = s = ms = 0;\n\t\t\t\twhile ( (att = (GF_XMLAttribute*)gf_list_enum(node->attributes, &p_idx))) {\n\t\t\t\t\tif (strcmp(att->name, \"end\")) continue;\n\n\t\t\t\t\tif (sscanf(att->value, \"%u:%u:%u.%u\", &h, &m, &s, &ms) == 4) {\n\t\t\t\t\t\tts_end = (h*3600 + m*60+s)*1000+ms;\n\t\t\t\t\t} else if (sscanf(att->value, \"%u:%u:%u\", &h, &m, &s) == 3) {\n\t\t\t\t\t\tts_end = (h*3600 + m*60+s)*1000;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//or under a <span>\n\t\t\t\tp_idx = 0;\n\t\t\t\twhile ( (p_node = (GF_XMLNode*)gf_list_enum(node->content, &p_idx))) {\n\t\t\t\t\tu32 span_idx = 0;\n\t\t\t\t\twhile ( (att = (GF_XMLAttribute*)gf_list_enum(p_node->attributes, &span_idx))) {\n\t\t\t\t\t\tif (strcmp(att->name, \"end\")) continue;\n\t\t\t\t\t\tif (sscanf(att->value, \"%u:%u:%u.%u\", &h, &m, &s, &ms) == 4) {\n\t\t\t\t\t\t\tts_end = (h*3600 + m*60+s)*1000+ms;\n\t\t\t\t\t\t} else if (sscanf(att->value, \"%u:%u:%u\", &h, &m, &s) == 3) {\n\t\t\t\t\t\t\tts_end = (h*3600 + m*60+s)*1000;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ts_end > (u64) dur.num) dur.num = (s64) ts_end;\n\t\t\t}\n\t\t}\n\t\tif (dur.num) {\n\t\t\tdur.den = 1000;\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, &PROP_FRAC64(dur));\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PLAYBACK_MODE, &PROP_UINT(GF_PLAYBACK_MODE_FASTFORWARD ) );\n\t\t}\n\t\treturn;\n\t}\n\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] Duration probing not supported for format %d\\n\", ctx->fmt));\n}\n\nstatic GF_Err txtin_setup_srt(GF_Filter *filter, GF_TXTIn *ctx, Bool gen_dsi_only)\n{\n\tu32 ID, OCR_ES_ID, dsi_len, file_size=0;\n\tu8 *dsi;\n\tGF_TextSampleDescriptor *sd;\n\n\tif (!gen_dsi_only) {\n\t\tif (!ctx->unframed)\n\t\t\tctx->src = gf_fopen(ctx->file_name, \"rb\");\n\n\t\tif (!ctx->src) return GF_URL_ERROR;\n\n\t\tfile_size = (u32) gf_fsize(ctx->src);\n\n\t\tctx->unicode_type = gf_text_get_utf_type(ctx, ctx->src);\n\t\tif (ctx->unicode_type<0) {\n\t\t\tgf_fclose(ctx->src);\n\t\t\tctx->src = NULL;\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Unsupported SRT UTF encoding\\n\"));\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\t}\n\n\tif (!ctx->timescale) ctx->timescale = 1000;\n\tOCR_ES_ID = ID = 0;\n\n\tif (!ctx->unframed) {\n\t\tif (!ctx->opid) ctx->opid = gf_filter_pid_new(filter);\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_TEXT) );\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, &PROP_UINT(GF_CODECID_TX3G) );\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, &PROP_UINT(ctx->timescale) );\n\t\tif (file_size)\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DOWN_SIZE, &PROP_LONGUINT(file_size) );\n\n\t\tif (!ID) ID = 1;\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ID, &PROP_UINT(ID) );\n\t\tif (OCR_ES_ID) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CLOCK_ID, &PROP_UINT(OCR_ES_ID) );\n\t}\n\n\tif (ctx->width) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_WIDTH, &PROP_UINT(ctx->width) );\n\tif (ctx->height) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_HEIGHT, &PROP_UINT(ctx->height) );\n\tif (ctx->zorder) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ZORDER, &PROP_SINT(ctx->zorder) );\n\tif (ctx->lang) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_LANGUAGE, &PROP_STRING( ctx->lang) );\n\n\tsd = (GF_TextSampleDescriptor*)gf_odf_desc_new(GF_ODF_TX3G_TAG);\n\tsd->fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord));\n\tsd->font_count = 1;\n\tsd->fonts[0].fontID = 1;\n\tsd->fonts[0].fontName = gf_strdup(ctx->fontname ? ctx->fontname : \"Serif\");\n\tsd->back_color = 0x00000000;\t/*transparent*/\n\tsd->default_style.fontID = 1;\n\tsd->default_style.font_size = ctx->fontsize;\n\tsd->default_style.text_color = 0xFFFFFFFF;\t/*white*/\n\tsd->default_style.style_flags = 0;\n\tsd->horiz_justif = 1; /*center of scene*/\n\tsd->vert_justif = (s8) -1;\t/*bottom of scene*/\n\n\tif (ctx->nodefbox) {\n\t\tsd->default_pos.top = sd->default_pos.left = sd->default_pos.right = sd->default_pos.bottom = 0;\n\t} else if ((sd->default_pos.bottom==sd->default_pos.top) || (sd->default_pos.right==sd->default_pos.left)) {\n\t\tsd->default_pos.left = ctx->txtx;\n\t\tsd->default_pos.top = ctx->txty;\n\t\tsd->default_pos.right = ctx->width + sd->default_pos.left;\n\t\tsd->default_pos.bottom = ctx->height + sd->default_pos.top;\n\t}\n\n\t/*store attribs*/\n\tctx->style = sd->default_style;\n\tgf_odf_tx3g_write(sd, &dsi, &dsi_len);\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA_NO_COPY(dsi, dsi_len) );\n\n\tgf_odf_desc_del((GF_Descriptor *)sd);\n\n\tif (gen_dsi_only) return GF_OK;\n\n\tctx->default_color = ctx->style.text_color;\n\tctx->first_samp = GF_TRUE;\n\n\tctx->samp = gf_isom_new_text_sample();\n\tctx->prev_end = 0;\n\tif (!ctx->unframed) {\n\t\tctx->state = 0;\n\t\tctx->end = ctx->start = 0;\n\t\tctx->curLine = 0;\n\n\t\ttxtin_probe_duration(ctx);\n\t}\n\n\treturn GF_OK;\n}\n\nstatic void txtin_process_send_text_sample(GF_TXTIn *ctx, GF_TextSample *txt_samp, u64 ts, u32 duration, Bool is_rap)\n{\n\tGF_FilterPacket *dst_pck;\n\tu8 *pck_data;\n\tu32 size;\n\n\tif (!txt_samp)\n\t\treturn;\n\tif ((!txt_samp->text || !txt_samp->len) && ctx->no_empty)\n\t\treturn;\n\n\tif (ctx->seek_state==2) {\n\t\tDouble end = (Double) (ts+duration);\n\t\tend /= 1000;\n\t\tif (end < ctx->start_range) return;\n\t\tctx->seek_state = 0;\n\t}\n\n\tsize = gf_isom_text_sample_size(txt_samp);\n\n\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, size, &pck_data);\n\tif (!dst_pck) return;\n\n\tgf_bs_reassign_buffer(ctx->bs_w, pck_data, size);\n\tgf_isom_text_sample_write_bs(txt_samp, ctx->bs_w);\n\n\tts = gf_timestamp_rescale(ts, 1000, ctx->timescale);\n\tduration = (u32) gf_timestamp_rescale(duration, 1000, ctx->timescale);\n\n\tgf_filter_pck_set_sap(dst_pck, is_rap ? GF_FILTER_SAP_1 : GF_FILTER_SAP_NONE);\n\tgf_filter_pck_set_cts(dst_pck, ts);\n\tgf_filter_pck_set_duration(dst_pck, duration);\n\n\tgf_filter_pck_send(dst_pck);\n}\n\nstatic GF_Err parse_srt_line(GF_TXTIn *ctx, char *szLine, u32 *char_l, Bool *set_start_c, Bool *set_end_c)\n{\n\tu32 i, char_line, j, rem_styles, len;\n\tBool rem_color;\n\tchar *ptr = szLine;\n\tunsigned short uniLine[5000], uniText[5000], *sptr;\n\tchar szText[2048];\n\n\tlen = gf_utf8_mbstowcs(uniLine, 5000, (const char **) &ptr);\n\tif (len == GF_UTF8_FAIL) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] Invalid UTF data (line %d)\\n\", ctx->curLine));\n\t\tctx->state = 0;\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\ti=j=0;\n\trem_styles = 0;\n\trem_color = 0;\n\twhile (i<len) {\n\t\tu32 font_style = 0;\n\t\tu32 style_nb_chars = 0;\n\t\tu32 style_def_type = 0;\n\n\t\tif ( (uniLine[i]=='<') && (uniLine[i+2]=='>')) {\n\t\t\tstyle_nb_chars = 3;\n\t\t\tstyle_def_type = 1;\n\t\t}\n\t\telse if ( (uniLine[i]=='<') && (uniLine[i+1]=='/') && (uniLine[i+3]=='>')) {\n\t\t\tstyle_def_type = 2;\n\t\t\tstyle_nb_chars = 4;\n\t\t}\n\t\telse if (uniLine[i]=='<')  {\n\t\t\tconst unsigned short* src = uniLine + i;\n\t\t\tu32 alen = gf_utf8_wcstombs(szLine, 2048, (const unsigned short**) & src);\n\t\t\tif (alen == GF_UTF8_FAIL) alen = 0;\n\t\t\tszLine[alen] = 0;\n\t\t\tstrlwr(szLine);\n\t\t\tif (!strncmp(szLine, \"<font \", 6) ) {\n\t\t\t\tchar *a_sep = strstr(szLine, \"color\");\n\t\t\t\tif (a_sep) a_sep = strstr(szLine, \"=\");\n\t\t\t\tif (a_sep) a_sep++;\n\t\t\t\twhile (a_sep && a_sep[0]) {\n\t\t\t\t\tif (a_sep[0]!=' ') break;\n\t\t\t\t\ta_sep++;\n\t\t\t\t}\n\t\t\t\tif (a_sep) {\n\t\t\t\t\tchar *e_sep;\n\t\t\t\t\tif ((a_sep[0]=='\"') || ((a_sep[0]=='\\''))) {\n\t\t\t\t\t\te_sep = strchr(a_sep+1, a_sep[0]);\n\t\t\t\t\t\ta_sep++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\te_sep=a_sep;\n\t\t\t\t\t\twhile (e_sep[0]) {\n\t\t\t\t\t\t\tif (e_sep[0]==' ') break;\n\t\t\t\t\t\t\tif (e_sep[0]=='>') break;\n\t\t\t\t\t\t\te_sep++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (e_sep) {\n\t\t\t\t\t\tchar c_sep = e_sep[0];\n\t\t\t\t\t\te_sep[0] = 0;\n\t\t\t\t\t\tfont_style = gf_color_parse(a_sep);\n\t\t\t\t\t\te_sep[0] = c_sep;\n\t\t\t\t\t\tif (c_sep!='>')\n\t\t\t\t\t\t\te_sep = strchr(e_sep+1, '>');\n\t\t\t\t\t\tif (e_sep) {\n\t\t\t\t\t\t\tstyle_nb_chars = (u32) (1 + e_sep - szLine);\n\t\t\t\t\t\t\tstyle_def_type = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!strncmp(szLine, \"</font>\", 7) ) {\n\t\t\t\tstyle_nb_chars = 7;\n\t\t\t\tstyle_def_type = 2;\n\t\t\t\tfont_style = 0xFFFFFFFF;\n\t\t\t}\n\n\n\t\t\telse if (!strncmp(szLine, \"<strike>\", 8) ) {\n\t\t\t\tstyle_nb_chars = 8;\n\t\t\t\tstyle_def_type = 1;\n\t\t\t}\n\t\t\telse if (!strncmp(szLine, \"</strike>\", 9) ) {\n\t\t\t\tstyle_nb_chars = 9;\n\t\t\t\tstyle_def_type = 2;\n\t\t\t\tfont_style = 0xFFFFFFFF;\n\t\t\t}\n\t\t\t//skip unknown\n\t\t\telse {\n\t\t\t\tchar *a_sep = strstr(szLine, \">\");\n\t\t\t\tif (a_sep) {\n\t\t\t\t\tstyle_nb_chars = (u32) (1 + a_sep - szLine);\n\t\t\t\t\ti += style_nb_chars;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\t/*start of new style*/\n\t\tif (style_def_type==1)  {\n\t\t\t/*store prev style*/\n\t\t\tif (*set_end_c) {\n\t\t\t\tassert(*set_start_c);\n\t\t\t\tgf_isom_text_add_style(ctx->samp, &ctx->style);\n\t\t\t\t*set_end_c = *set_start_c = GF_FALSE;\n\t\t\t\tctx->style.style_flags &= ~rem_styles;\n\t\t\t\trem_styles = 0;\n\t\t\t\tif (rem_color) {\n\t\t\t\t\tctx->style.text_color = ctx->default_color;\n\t\t\t\t\trem_color = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (*set_start_c && (ctx->style.startCharOffset != j)) {\n\t\t\t\tctx->style.endCharOffset = *char_l + j;\n\t\t\t\tif (ctx->style.style_flags) gf_isom_text_add_style(ctx->samp, &ctx->style);\n\t\t\t}\n\t\t\tswitch (uniLine[i+1]) {\n\t\t\tcase 'b':\n\t\t\tcase 'B':\n\t\t\t\tctx->style.style_flags |= GF_TXT_STYLE_BOLD;\n\t\t\t\t*set_start_c = GF_TRUE;\n\t\t\t\tctx->style.startCharOffset = *char_l + j;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\tcase 'I':\n\t\t\t\tctx->style.style_flags |= GF_TXT_STYLE_ITALIC;\n\t\t\t\t*set_start_c = GF_TRUE;\n\t\t\t\tctx->style.startCharOffset = *char_l + j;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\tcase 'U':\n\t\t\t\tctx->style.style_flags |= GF_TXT_STYLE_UNDERLINED;\n\t\t\t\t*set_start_c = GF_TRUE;\n\t\t\t\tctx->style.startCharOffset = *char_l + j;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\tcase 'S':\n\t\t\t\tctx->style.style_flags |= GF_TXT_STYLE_STRIKETHROUGH;\n\t\t\t\t*set_start_c = GF_TRUE;\n\t\t\t\tctx->style.startCharOffset = *char_l + j;\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\tcase 'F':\n\t\t\t\tif (font_style) {\n\t\t\t\t\tctx->style.text_color = font_style;\n\t\t\t\t\t*set_start_c = GF_TRUE;\n\t\t\t\t\tctx->style.startCharOffset = *char_l + j;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti += style_nb_chars;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*end of prev style*/\n\t\tif (style_def_type==2)  {\n\t\t\tswitch (uniLine[i+2]) {\n\t\t\tcase 'b':\n\t\t\tcase 'B':\n\t\t\t\trem_styles |= GF_TXT_STYLE_BOLD;\n\t\t\t\t*set_end_c = GF_TRUE;\n\t\t\t\tctx->style.endCharOffset = *char_l + j;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\tcase 'I':\n\t\t\t\trem_styles |= GF_TXT_STYLE_ITALIC;\n\t\t\t\t*set_end_c = GF_TRUE;\n\t\t\t\tctx->style.endCharOffset = *char_l + j;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\tcase 'U':\n\t\t\t\trem_styles |= GF_TXT_STYLE_UNDERLINED;\n\t\t\t\t*set_end_c = GF_TRUE;\n\t\t\t\tctx->style.endCharOffset = *char_l + j;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\tcase 'S':\n\t\t\t\trem_styles |= GF_TXT_STYLE_STRIKETHROUGH;\n\t\t\t\t*set_end_c = GF_TRUE;\n\t\t\t\tctx->style.endCharOffset = *char_l + j;\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\tcase 'F':\n\t\t\t\tif (font_style) {\n\t\t\t\t\trem_color = 1;\n\t\t\t\t\t*set_end_c = GF_TRUE;\n\t\t\t\t\tctx->style.endCharOffset = *char_l + j;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti+=style_nb_chars;\n\t\t\tcontinue;\n\t\t}\n\t\t/*store style*/\n\t\tif (*set_end_c) {\n\t\t\tgf_isom_text_add_style(ctx->samp, &ctx->style);\n\t\t\t*set_end_c = GF_FALSE;\n\t\t\t*set_start_c = GF_TRUE;\n\t\t\tctx->style.startCharOffset = *char_l + j;\n\t\t\tctx->style.style_flags &= ~rem_styles;\n\t\t\trem_styles = 0;\n\t\t\tctx->style.text_color = ctx->default_color;\n\t\t\trem_color = 0;\n\t\t}\n\n\t\tuniText[j] = uniLine[i];\n\t\tj++;\n\t\ti++;\n\t}\n\t/*store last style*/\n\tif (*set_end_c) {\n\t\tgf_isom_text_add_style(ctx->samp, &ctx->style);\n\t\t*set_end_c = GF_FALSE;\n\t\t*set_start_c = GF_TRUE;\n\t\tctx->style.startCharOffset = *char_l + j;\n\t\tctx->style.style_flags &= ~rem_styles;\n\t}\n\n\tchar_line = j;\n\tuniText[j] = 0;\n\n\tsptr = (u16 *) uniText;\n\tlen = gf_utf8_wcstombs(szText, 5000, (const u16 **) &sptr);\n\tif (len == GF_UTF8_FAIL) len = 0;\n\n\tgf_isom_text_add_text(ctx->samp, szText, len);\n\t*char_l += char_line;\n\treturn GF_OK;\n}\n\nstatic GF_Err txtin_process_srt(GF_Filter *filter, GF_TXTIn *ctx, GF_FilterPacket *ipck)\n{\n\tu32 sh, sm, ss, sms, eh, em, es, ems, txt_line, char_len;\n\tBool set_start_char, set_end_char;\n\tu32 line;\n\tchar szLine[2048];\n\n\tif (!ctx->is_setup) {\n\t\tctx->is_setup = GF_TRUE;\n\t\tGF_Err e = txtin_setup_srt(filter, ctx, GF_FALSE);\n\t\tif (e || !ctx->unframed) return e;\n\t}\n\tif (!ctx->opid) return GF_NOT_SUPPORTED;\n\n\tif (!ctx->unframed) {\n\t\tif (!ctx->playstate) return GF_OK;\n\t\telse if (ctx->playstate==2) return GF_EOS;\n\t}\n\n\ttxt_line = 0;\n\tset_start_char = set_end_char = GF_FALSE;\n\tchar_len = 0;\n\n\tif (ctx->seek_state == 1) {\n\t\tctx->seek_state = 2;\n\t\tgf_fseek(ctx->src, 0, SEEK_SET);\n\t}\n\n\twhile (1) {\n\t\tBool is_empty = GF_FALSE;\n\t\tchar *sOK = gf_text_get_utf8_line(szLine, 2048, ctx->src, ctx->unicode_type);\n\n\t\tif (sOK) {\n\t\t\tREM_TRAIL_MARKS(szLine, \"\\r\\n\\t \")\n\n\t\t\tif (ctx->unicode_type<=1) is_empty = strlen(szLine) ? GF_FALSE : GF_TRUE;\n\t\t\telse is_empty =  (!szLine[0] && !szLine[1]) ? GF_TRUE : GF_FALSE;\n\t\t}\n\n\t\tif (!sOK || is_empty) {\n\t\t\tu32 utf_inc = (ctx->unicode_type<=1) ? 1 : 2;\n\t\t\tu32 nb_empty = utf_inc;\n\t\t\tu32 pos = (u32) gf_ftell(ctx->src);\n\t\t\tif (ctx->state) {\n\t\t\t\twhile (!gf_feof(ctx->src)) {\n\t\t\t\t\tsOK = gf_text_get_utf8_line(szLine+nb_empty, 2048-nb_empty, ctx->src, ctx->unicode_type);\n\t\t\t\t\tif (sOK) REM_TRAIL_MARKS((szLine+nb_empty), \"\\r\\n\\t \")\n\n\t\t\t\t\tif (!sOK) {\n\t\t\t\t\t\tgf_fseek(ctx->src, pos, SEEK_SET);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (!strlen(szLine+nb_empty)) {\n\t\t\t\t\t\tnb_empty+=utf_inc;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if (\tsscanf(szLine+nb_empty, \"%u\", &line) == 1) {\n\t\t\t\t\t\tgf_fseek(ctx->src, pos, SEEK_SET);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tu32 k;\n\t\t\t\t\t\tfor (k=0; k<nb_empty; k++) szLine[k] = '\\n';\n\t\t\t\t\t\tgoto force_line;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tctx->style.style_flags = 0;\n\t\t\tctx->style.text_color = 0xFFFFFFFF;\n\t\t\tctx->style.startCharOffset = ctx->style.endCharOffset = 0;\n\t\t\tif (txt_line) {\n\t\t\t\tif (ctx->prev_end && (ctx->start != ctx->prev_end) && (ctx->state<=2)) {\n\t\t\t\t\tGF_TextSample * empty_samp = gf_isom_new_text_sample();\n\t\t\t\t\ttxtin_process_send_text_sample(ctx, empty_samp, ctx->prev_end, (u32) (ctx->start - ctx->prev_end), GF_TRUE );\n\t\t\t\t\tgf_isom_delete_text_sample(empty_samp);\n\t\t\t\t}\n\n\t\t\t\tif (ctx->state<=2) {\n\t\t\t\t\ttxtin_process_send_text_sample(ctx, ctx->samp,  ctx->start, (u32) (ctx->end -  ctx->start), GF_TRUE);\n\t\t\t\t\tctx->prev_end = ctx->end;\n\t\t\t\t}\n\t\t\t\ttxt_line = 0;\n\t\t\t\tchar_len = 0;\n\t\t\t\tset_start_char = set_end_char = GF_FALSE;\n\t\t\t\tctx->style.startCharOffset = ctx->style.endCharOffset = 0;\n\t\t\t\tgf_isom_text_reset(ctx->samp);\n\n\t\t\t\tif (!ctx->unframed)\n\t\t\t\t\tgf_filter_pid_set_info(ctx->opid, GF_PROP_PID_DOWN_BYTES, &PROP_LONGUINT( gf_ftell(ctx->src )) );\n\t\t\t}\n\t\t\tctx->state = 0;\n\t\t\tif (!sOK) break;\n\t\t\tcontinue;\n\t\t}\n\nforce_line:\n\t\tswitch (ctx->state) {\n\t\tcase 0:\n\t\t\tif (sscanf(szLine, \"%u\", &line) != 1) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Bad SRT formatting - expecting number got \\\"%s\\\"\\n\", szLine));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (line != ctx->curLine + 1) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] Corrupted SRT frame %d after frame %d\\n\", line, ctx->curLine));\n\t\t\t}\n\t\t\tctx->curLine = line;\n\t\t\tctx->state = 1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (sscanf(szLine, \"%u:%u:%u,%u --> %u:%u:%u,%u\", &sh, &sm, &ss, &sms, &eh, &em, &es, &ems) != 8) {\n\t\t\t\tif (sscanf(szLine, \"%u:%u:%u.%u --> %u:%u:%u.%u\", &sh, &sm, &ss, &sms, &eh, &em, &es, &ems) != 8) {\n\t\t\t\t\tsh = eh = 0;\n\t\t\t\t\tif (sscanf(szLine, \"%u:%u,%u --> %u:%u,%u\", &sm, &ss, &sms, &em, &es, &ems) != 6) {\n\t\t\t\t\t\tif (sscanf(szLine, \"%u:%u.%u --> %u:%u.%u\", &sm, &ss, &sms, &em, &es, &ems) != 6) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] Error scanning SRT frame %d timing\\n\", ctx->curLine));\n\t\t\t\t    \t\tctx->state = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tctx->start = (3600*sh + 60*sm + ss)*1000 + sms;\n\t\t\tif (ctx->start < ctx->end) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] Overlapping SRT frame %d - starts \"LLD\" ms is before end of previous one \"LLD\" ms - adjusting time stamps\\n\", ctx->curLine, ctx->start, ctx->end));\n\t\t\t\tctx->start = ctx->end;\n\t\t\t}\n\n\t\t\tctx->end = (3600*eh + 60*em + es)*1000 + ems;\n\t\t\t/*make stream start at 0 by inserting a fake AU*/\n\t\t\tif (ctx->first_samp && (ctx->start > 0)) {\n\t\t\t\ttxtin_process_send_text_sample(ctx, ctx->samp, 0, (u32) ctx->start, GF_TRUE);\n\t\t\t}\n\t\t\tctx->style.style_flags = 0;\n\t\t\tctx->state = 2;\n\t\t\tif (ctx->end <= ctx->prev_end) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] Overlapping SRT frame %d end \"LLD\" is at or before previous end \"LLD\" - removing\\n\", ctx->curLine, ctx->end, ctx->prev_end));\n\t\t\t\tctx->start = ctx->end;\n\t\t\t\tctx->state = 3;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/*reset only when text is present*/\n\t\t\tctx->first_samp = GF_FALSE;\n\n\t\t\t/*go to line*/\n\t\t\tif (txt_line) {\n\t\t\t\tgf_isom_text_add_text(ctx->samp, \"\\n\", 1);\n\t\t\t\tchar_len += 1;\n\t\t\t}\n\n\t\t\tparse_srt_line(ctx, szLine, &char_len, &set_start_char, &set_end_char);\n\t\t\ttxt_line ++;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!ctx->unframed && gf_filter_pid_would_block(ctx->opid))\n\t\t\treturn GF_OK;\n\t}\n\n\t/*final flush*/\n\tif (!ctx->unframed && ctx->end && ! ctx->noflush) {\n\t\tgf_isom_text_reset(ctx->samp);\n\t\ttxtin_process_send_text_sample(ctx, ctx->samp, ctx->end, 0, GF_TRUE);\n\t\tctx->end = 0;\n\t}\n\tgf_isom_text_reset(ctx->samp);\n\n\treturn GF_EOS;\n}\n\n/* Structure used to pass importer and track data to the parsers without exposing the GF_MediaImporter structure\n   used by WebVTT and Flash->SVG */\ntypedef struct {\n\tGF_TXTIn *ctx;\n\tu32 timescale;\n\tu32 track;\n\tu32 descriptionIndex;\n} GF_ISOFlusher;\n\n#ifndef GPAC_DISABLE_VTT\n\nstatic GF_Err gf_webvtt_import_report(void *user, GF_Err e, char *message, const char *line)\n{\n\tGF_LOG(e ? GF_LOG_WARNING : GF_LOG_INFO, GF_LOG_PARSER, (\"[TXTIn] WebVTT line %s: %s\\n\", line, message) );\n\treturn e;\n}\n\nstatic void gf_webvtt_import_header(void *user, const char *config)\n{\n\tGF_TXTIn *ctx = (GF_TXTIn *)user;\n\tif (!ctx->hdr_parsed) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA((char *) config, (u32) (1+strlen(config)) ) );\n\t\tctx->hdr_parsed = GF_TRUE;\n\t\tgf_webvtt_parser_suspend(ctx->vttparser);\n\t}\n}\n\nstatic void gf_webvtt_flush_sample(void *user, GF_WebVTTSample *samp)\n{\n\tu64 start, end;\n\tGF_TXTIn *ctx = (GF_TXTIn *)user;\n\tGF_ISOSample *s;\n\n\tstart = gf_webvtt_sample_get_start(samp);\n\tend = gf_webvtt_sample_get_end(samp);\n\n\tif (ctx->seek_state==2) {\n\t\tDouble tsend = (Double) end;\n\t\ttsend /= 1000;\n\t\tif (tsend<ctx->start_range) return;\n\t\tctx->seek_state = 0;\n\t}\n\n\tif (ctx->no_empty && !gf_isom_webvtt_cues_count(samp))\n\t\ts = NULL;\n\telse\n\t\ts = gf_isom_webvtt_to_sample(samp);\n\n\tif (s) {\n\t\tGF_FilterPacket *pck;\n\t\tu8 *pck_data;\n\n\t\tpck = gf_filter_pck_new_alloc(ctx->opid, s->dataLength, &pck_data);\n\t\tif (pck) {\n\t\t\tmemcpy(pck_data, s->data, s->dataLength);\n\t\t\tgf_filter_pck_set_cts(pck, (u64) (ctx->timescale * start / 1000) );\n\t\t\tgf_filter_pck_set_sap(pck, GF_FILTER_SAP_1);\n\n\n\t\t\tif (end && (end>=start) ) {\n\t\t\t\tgf_filter_pck_set_duration(pck, (u32) (ctx->timescale * (end-start) / 1000) );\n\t\t\t}\n\t\t\tgf_filter_pck_send(pck);\n\t\t}\n\n\t\tgf_isom_sample_del(&s);\n\t}\n\tgf_webvtt_sample_del(samp);\n\n\tgf_filter_pid_set_info(ctx->opid, GF_PROP_PID_DOWN_BYTES, &PROP_LONGUINT( gf_ftell(ctx->src )) );\n\n\tif (gf_filter_pid_would_block(ctx->opid))\n\t\tgf_webvtt_parser_suspend(ctx->vttparser);\n\n}\n\nstatic GF_Err txtin_webvtt_setup(GF_Filter *filter, GF_TXTIn *ctx)\n{\n\tGF_Err e;\n\tu32 ID, OCR_ES_ID, file_size, w, h;\n\tBool is_srt;\n\tchar *ext;\n\n\tif (!ctx->unframed)\n\t\tctx->src = gf_fopen(ctx->file_name, \"rb\");\n\n\tif (ctx->opid && (ctx->playstate==2)) return GF_EOS;\n\tif (!ctx->src) return GF_URL_ERROR;\n\n\tfile_size = (u32) gf_fsize(ctx->src);\n\n\tctx->unicode_type = gf_text_get_utf_type(ctx, ctx->src);\n\tif (ctx->unicode_type<0) {\n\t\tgf_fclose(ctx->src);\n\t\tctx->src = NULL;\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Unsupported SRT UTF encoding\\n\"));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\tif (!ctx->unframed) {\n\t\text = gf_file_ext_start(ctx->file_name);\n\t\tis_srt = (ext && !strnicmp(ext, \".srt\", 4)) ? GF_TRUE : GF_FALSE;\n\t} else {\n\t\tis_srt = GF_TRUE;\n\t}\n\n\tif (!ctx->timescale) ctx->timescale = 1000;\n\tOCR_ES_ID = ID = 0;\n\n\tif (!ctx->opid) ctx->opid = gf_filter_pid_new(filter);\n\tif (!ctx->unframed) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_TEXT) );\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, &PROP_UINT(GF_CODECID_WEBVTT) );\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, &PROP_UINT(ctx->timescale) );\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DOWN_SIZE, &PROP_LONGUINT(file_size) );\n\t}\n\n\tw = ctx->width;\n\th = ctx->height;\n\tif (!ID) ID = 1;\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ID, &PROP_UINT(ID) );\n\tif (OCR_ES_ID) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CLOCK_ID, &PROP_UINT(OCR_ES_ID) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_WIDTH, &PROP_UINT(w) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_HEIGHT, &PROP_UINT(h) );\n\tif (ctx->zorder) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ZORDER, &PROP_SINT(ctx->zorder) );\n\tif (ctx->lang) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_LANGUAGE, &PROP_STRING( ctx->lang) );\n\n\tctx->vttparser = gf_webvtt_parser_new();\n\n\te = gf_webvtt_parser_init(ctx->vttparser, ctx->src, ctx->unicode_type, is_srt, ctx, gf_webvtt_import_report, gf_webvtt_flush_sample, gf_webvtt_import_header);\n\tif (e != GF_OK) {\n\t\tgf_webvtt_parser_del(ctx->vttparser);\n\t\tctx->vttparser = NULL;\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] WebVTT parser init error %s\\n\", gf_error_to_string(e) ));\n\t}\n\t//get the header\n\te = gf_webvtt_parser_parse(ctx->vttparser);\n\n\tif (!ctx->unframed)\n\t\ttxtin_probe_duration(ctx);\n\treturn e;\n}\n\nstatic GF_Err txtin_process_webvtt(GF_Filter *filter, GF_TXTIn *ctx, GF_FilterPacket *ipck)\n{\n\tGF_Err e;\n\n\tif (!ctx->is_setup) {\n\t\tctx->is_setup = GF_TRUE;\n\t\te = txtin_webvtt_setup(filter, ctx);\n\t\tif (e || !ctx->unframed) return e;\n\t}\n\tif (!ctx->vttparser) return (ctx->playstate==2) ? GF_EOS : GF_NOT_SUPPORTED;\n\n\tif (ctx->seek_state==1) {\n\t\tctx->seek_state = 2;\n\t\tgf_webvtt_parser_restart(ctx->vttparser);\n\t}\n\tif (ctx->unframed) {\n\t\tconst GF_PropertyValue *p;\n\t\tconst char *vtt_pre=NULL, *vtt_cueid=NULL, *vtt_settings=NULL;\n\t\tp = gf_filter_pck_get_property_str(ipck, \"vtt_pre\");\n\t\tif (p) vtt_pre = p->value.string;\n\t\tp = gf_filter_pck_get_property_str(ipck, \"vtt_cueid\");\n\t\tif (p) vtt_cueid = p->value.string;\n\t\tp = gf_filter_pck_get_property_str(ipck, \"vtt_settings\");\n\t\tif (p) vtt_settings = p->value.string;\n\n\t\te = gf_webvtt_parser_parse_payload(ctx->vttparser,\n\t\t\tgf_timestamp_rescale(ctx->start, ctx->timescale, 1000),\n\t\t\tgf_timestamp_rescale(ctx->end, ctx->timescale, 1000),\n\t\t\tvtt_pre, vtt_cueid, vtt_settings);\n\t} else {\n\t\te = gf_webvtt_parser_parse(ctx->vttparser);\n\t}\n\n\tif (e < GF_OK) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] WebVTT process error %s\\n\", gf_error_to_string(e) ));\n\t}\n\treturn e;\n}\n\n#endif /*GPAC_DISABLE_VTT*/\n\nstatic char *ttxt_parse_string(char *str, Bool strip_lines)\n{\n\tu32 i=0;\n\tu32 k=0;\n\tu32 len = (u32) strlen(str);\n\tu32 state = 0;\n\n\tif (!strip_lines) {\n\t\tfor (i=0; i<len; i++) {\n\t\t\tif ((str[i] == '\\r') && (str[i+1] == '\\n')) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tstr[k] = str[i];\n\t\t\tk++;\n\t\t}\n\t\tstr[k]=0;\n\t\treturn str;\n\t}\n\n\tif (str[0]!='\\'') return str;\n\tfor (i=0; i<len; i++) {\n\t\tif (str[i] == '\\'') {\n\n\t\t\tif (!state) {\n\t\t\t\tif (k) {\n\t\t\t\t\tstr[k]='\\n';\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t\tstate = 1; //!state;\n\t\t\t} else {\n\t\t\t\tif ( (i+1==len) ||\n\t\t\t\t        ((str[i+1]==' ') || (str[i+1]=='\\n') || (str[i+1]=='\\r') || (str[i+1]=='\\t') || (str[i+1]=='\\''))\n\t\t\t\t   ) {\n\t\t\t\t\tstate = !state;\n\t\t\t\t} else {\n\t\t\t\t\tstr[k] = str[i];\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (state) {\n\t\t\tstr[k] = str[i];\n\t\t\tk++;\n\t\t}\n\t}\n\tstr[k]=0;\n\treturn str;\n}\n\nstatic void ebu_ttd_remove_samples(GF_XMLNode *root, GF_XMLNode **out_body_node)\n{\n\tu32 idx = 0;\n\tGF_XMLNode *node = NULL;\n\t*out_body_node = NULL;\n\twhile ( (node = (GF_XMLNode*)gf_list_enum(root->content, &idx))) {\n\t\tif (!strcmp(node->name, \"body\")) {\n\t\t\tGF_XMLNode *body_node;\n\t\t\tu32 body_idx = 0;\n\t\t\t*out_body_node = node;\n\t\t\twhile ( (body_node = (GF_XMLNode*)gf_list_enum(node->content, &body_idx))) {\n\t\t\t\tif (!strcmp(body_node->name, \"div\")) {\n\t\t\t\t\tu32 body_num;\n\t\t\t\t\tbody_num = gf_list_count(body_node->content);\n\t\t\t\t\twhile (body_num--) {\n\t\t\t\t\t\tGF_XMLNode *content_node = (GF_XMLNode*)gf_list_get(body_node->content, 0);\n\t\t\t\t\t\tassert(gf_list_find(body_node->content, content_node) == 0);\n\t\t\t\t\t\tgf_list_rem(body_node->content, 0);\n\t\t\t\t\t\tgf_xml_dom_node_del(content_node);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nu64 ttml_get_timestamp_ex(char *value, u32 tick_rate, u32 *ttml_fps_num, u32 *ttml_fps_den, u32 *ttml_sfps)\n{\n\tu32 h, m, s, ms, f, sf;\n\tu64 ts = GF_FILTER_NO_TS;\n\tu32 len = (u32) strlen(value);\n\n\t//tick metrick - cannot be fractional\n\tif (len && (value[len-1]=='t')) {\n\t\tvalue[len-1] = 0;\n\t\tts = (s64) (atoi(value) * 1000);\n\t\tvalue[len-1] = 't';\n\t\tif (tick_rate)\n\t\t\tts /= tick_rate;\n\t}\n\t//hours metric, can be fractional\n\telse if (len && (value[len-1]=='h')) {\n\t\tvalue[len-1] = 0;\n\t\tts = (s64) (atof(value) * 1000 * 3600);\n\t\tvalue[len-1] = 'h';\n\t}\n\t//minutes metric, can be fractional\n\telse if (len && (value[len-1]=='m')) {\n\t\tvalue[len-1] = 0;\n\t\tts = (s64) (atof(value) * 1000 * 60);\n\t\tvalue[len-1] = 'm';\n\t}\n\telse if (len && (value[len-1]=='s')) {\n\t\t//milliseconds metric, can be fractional but we work at 1ms clock resolution anyway\n\t\tif ((len > 1) && (value[len-2]=='m')) {\n\t\t\tvalue[len-2] = 0;\n\t\t\tts = (s64) (atof(value));\n\t\t\tvalue[len-2] = 'm';\n\t\t}\n\t\t//seconds metric, can be fractional\n\t\telse {\n\t\t\tvalue[len-1] = 0;\n\t\t\tts = (s64) (atof(value) * 1000);\n\t\t\tvalue[len-1] = 's';\n\t\t}\n\t}\n\t//frames metric, can be fractional\n\telse if (len && (value[len-1]=='f')) {\n\t\tf = sf = 0;\n\t\tvalue[len-1] = 0;\n\t\tif (sscanf(value, \"%u.%u\", &f, &sf) != 2) {\n\t\t\tsscanf(value, \"%u\", &f);\n\t\t\tsf = 0;\n\t\t}\n\t\tvalue[len-1] = 'f';\n\n\t\tif (! *ttml_fps_num) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] time indicates frames but no frame rate set, assuming 25 FPS\\n\"));\n\t\t\t*ttml_fps_num = 25;\n\t\t\t*ttml_fps_den = 1;\n\t\t}\n\t\tif (sf && ! *ttml_sfps) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] time indicates subframes but no subFrameRate set, assuming 1\\n\"));\n\t\t\t*ttml_sfps = 1;\n\t\t}\n\t\tts = ((s64) 1000 * f * *ttml_fps_den) / *ttml_fps_num;\n\t\tif (sf)\n\t\t\tts += ((s64) 1000 * sf * *ttml_fps_den / *ttml_sfps) / *ttml_fps_num;\n\t}\n\telse if (sscanf(value, \"%u:%u:%u.%u\", &h, &m, &s, &ms) == 4) {\n\t\tts = (h*3600 + m*60+s)*1000+ms;\n\t}\n\telse if (sscanf(value, \"%u:%u:%u:%u.%u\", &h, &m, &s, &f, &sf) == 5) {\n\t\tts = (h*3600 + m*60+s)*1000;\n\t\tif (! *ttml_fps_num) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] time indicates frames but no frame rate set, assuming 25 FPS\\n\"));\n\t\t\t*ttml_fps_num = 25;\n\t\t\t*ttml_fps_den = 1;\n\t\t}\n\t\tif (! *ttml_sfps) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] time indicates subframes but no subFrameRate set, assuming 1\\n\"));\n\t\t\t*ttml_sfps = 1;\n\t\t}\n\t\tts += ((s64) 1000 * f * *ttml_fps_den) / *ttml_fps_num;\n\t\tts += ((s64) 1000 * sf * *ttml_fps_den / *ttml_sfps) / *ttml_fps_num;\n\t}\n\telse if (sscanf(value, \"%u:%u:%u:%u\", &h, &m, &s, &f) == 4) {\n\t\tts = (h*3600 + m*60+s)*1000;\n\t\tif (! *ttml_fps_num) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] time indicates frames but no frame rate set, assuming 25 FPS\\n\"));\n\t\t\t*ttml_fps_num = 25;\n\t\t\t*ttml_fps_den = 1;\n\t\t}\n\t\tts += ((s64) 1000 * f * *ttml_fps_den) / *ttml_fps_num;\n\t}\n\telse if (sscanf(value, \"%u:%u:%u\", &h, &m, &s) == 3) {\n\t\tts = (h*3600 + m*60+s)*1000;\n\t}\n\treturn ts;\n}\nstatic u64 ttml_get_timestamp(GF_TXTIn *ctx, char *value)\n{\n\treturn ttml_get_timestamp_ex(value, ctx->tick_rate, &ctx->ttml_fps_num, &ctx->ttml_fps_den, &ctx->ttml_sfps);\n\n}\nstatic GF_Err ttml_push_interval(GF_TXTIn *ctx, s64 begin, s64 end, TTMLInterval **out_interval)\n{\n\tu32 i;\n\tTTMLInterval *interval;\n\tif (begin==-1) return GF_OK;\n\tif (end==-1) return GF_OK;\n\n\tif (end < begin) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TTML EBU-TTD] invalid timings: \\\"begin\\\"=\"LLD\" , \\\"end\\\"=\"LLD\". Abort.\\n\", begin, end));\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\tinterval = NULL;\n\tfor (i=0; i<gf_list_count(ctx->intervals); i++) {\n\t\tinterval = gf_list_get(ctx->intervals, i);\n\n\t\t//generate a single sample for the input, merge interval\n\t\tif (! ctx->ttml_split) {\n\t\t\tif (interval->begin > begin) interval->begin = begin;\n\t\t\tif (interval->end < end) interval->end = end;\n\t\t\t*out_interval = interval;\n\t\t\treturn GF_OK;\n\t\t}\n\t\t//contained, do nothing\n\t\tif ((begin>=interval->begin) && (end<=interval->end)) {\n\t\t\t*out_interval = interval;\n\t\t\treturn GF_OK;\n\t\t}\n\t\t//not overlapping\n\t\tif ((end < interval->begin) || (begin > interval->end))\n\t\t\tcontinue;\n\n\t\t//new interval starts before current and end after, remove current and push extended interval\n\t\tif ((begin < interval->end) && (end > interval->end)) {\n\t\t\tif (begin>interval->begin)\n\t\t\t\tbegin = interval->begin;\n\t\t\tgf_list_rem(ctx->intervals, i);\n\t\t\tgf_free(interval);\n\t\t\treturn ttml_push_interval(ctx, begin, end, out_interval);\n\t\t}\n\t\t//new interval starts before current and end before, remove current and push rewinded\n\t\tif ((begin < interval->end) && (end <= interval->end)) {\n\t\t\tend = interval->end;\n\t\t\tif (begin>interval->begin)\n\t\t\t\tbegin = interval->begin;\n\t\t\tgf_list_rem(ctx->intervals, i);\n\t\t\tgf_free(interval);\n\t\t\treturn ttml_push_interval(ctx, begin, end, out_interval);\n\t\t}\n\t}\n\t//need a new interval\n\tGF_SAFEALLOC(interval, TTMLInterval);\n\tinterval->begin = begin;\n\tinterval->end = end;\n\t*out_interval = interval;\n\n\tfor (i=0; i<gf_list_count(ctx->intervals); i++) {\n\t\tTTMLInterval *an_interval = gf_list_get(ctx->intervals, i);\n\t\tif (an_interval->begin > interval->begin) {\n\t\t\treturn gf_list_insert(ctx->intervals, interval, i);\n\t\t}\n\t}\n\treturn gf_list_add(ctx->intervals, interval);\n}\n\nstatic void ttml_reset_intervals(GF_TXTIn *ctx)\n{\n\twhile (gf_list_count(ctx->intervals)) {\n\t\tTTMLInterval *ival = gf_list_pop_back(ctx->intervals);\n\t\tif (ival->resources) {\n\t\t\twhile (gf_list_count(ival->resources)) {\n\t\t\t\tTTMLRes *ires = gf_list_pop_back(ival->resources);\n\t\t\t\tif (!ires->global) {\n\t\t\t\t\tgf_free(ires->data);\n\t\t\t\t\tgf_free(ires);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_list_del(ival->resources);\n\t\t}\n\t\tgf_free(ival);\n\t}\n}\n\n#include <gpac/base_coding.h>\n\nstatic GF_Err ttml_push_res(GF_TXTIn *ctx, TTMLInterval *interval, u8 *f_data, u32 f_size)\n{\n\tGF_Err e;\n\tTTMLRes *res;\n\tGF_List *res_list;\n\tif (interval) {\n\t\tif (!interval->resources) {\n\t\t\tif (ctx->ttml_resources)\n\t\t\t\tinterval->resources = gf_list_clone(ctx->ttml_resources);\n\t\t\telse\n\t\t\t\tinterval->resources = gf_list_new();\n\t\t}\n\t\tres_list = interval->resources;\n\t} else {\n\t\tif (!ctx->ttml_resources) {\n\t\t\tctx->ttml_resources = gf_list_new();\n\t\t}\n\t\tres_list = ctx->ttml_resources;\n\t}\n\tif (!res_list) {\n\t\tgf_free(f_data);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tGF_SAFEALLOC(res, TTMLRes)\n\tif (!res) {\n\t\tgf_free(f_data);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tres->size = f_size;\n\tres->data = f_data;\n\tif (!interval)\n\t\tres->global = GF_TRUE;\n\n\te = gf_list_add(res_list, res);\n\tif (e) {\n\t\tgf_free(res);\n\t\tgf_free(f_data);\n\t\treturn e;\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err ttml_push_resources(GF_TXTIn *ctx, TTMLInterval *interval, GF_XMLNode *node, GF_XMLNode *parent_source_node)\n{\n\tu32 i;\n\tchar szURN[1024];\n\tu8 *f_data;\n\tu32 f_size;\n\tu32 idx;\n\tGF_Err e;\n\tGF_XMLAttribute *att, *data_type = NULL;\n\tGF_XMLNode *child;\n\tBool is_source = GF_FALSE;\n\tBool is_data = GF_FALSE;\n\tBool check_src = GF_FALSE;\n\n\tif (!ctx->ttml_embed)\n\t\treturn GF_OK;\n\n\tif (!strcmp(node->name, \"source\")) {\n\t\tis_source = GF_TRUE;\n\t\tcheck_src = GF_TRUE;\n\t}\n\telse if (!strcmp(node->name, \"data\")) {\n\t\tis_data = parent_source_node ? GF_TRUE : GF_FALSE;\n\t\tcheck_src = GF_TRUE;\n\t}\n\t//we don't embed chunks\n\telse if (!strcmp(node->name, \"chunk\")) {\n\t\treturn GF_OK;\n\t}\n\telse if (!strcmp(node->name, \"audio\") || !strcmp(node->name, \"font\") || !strcmp(node->name, \"image\")) {\n\t\tcheck_src = GF_TRUE;\n\t}\n\n\tif (check_src) {\n\t\ti = 0;\n\t\twhile ( (att = (GF_XMLAttribute*)gf_list_enum(node->attributes, &i))) {\n\t\t\tchar *url;\n\t\t\tif (!att->value) continue;\n\t\t\tif (is_data && !strcmp(att->name, \"type\")) {\n\t\t\t\tdata_type = att;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strcmp(att->name, \"src\")) continue;\n\t\t\tif (att->value[0]=='#') continue;\n\n\t\t\tif (!strncmp(att->value, \"file://\", 7)) {}\n\t\t\telse if (strstr(att->value, \"://\"))\n\t\t\t\tcontinue;\n\n\t\t\turl = gf_url_concatenate(ctx->file_name, att->value);\n\t\t\t//embed image\n\t\t\te = gf_file_load_data(url, &f_data, &f_size);\n\t\t\tgf_free(url);\n\t\t\tif (e) return e;\n\n\t\t\te = ttml_push_res(ctx, interval, f_data, f_size);\n\t\t\tif (e) return e;\n\n\t\t\tidx = gf_list_count(interval ? interval->resources : ctx->ttml_resources);\n\t\t\tgf_free(att->value);\n\t\t\tsprintf(szURN, \"urn:mpeg:14496-30:%d\", idx);\n\t\t\tatt->value = gf_strdup(szURN);\n\t\t\tif (!att->value) return GF_OUT_OF_MEM;\n\n\t\t\tctx->has_images = GF_TRUE;\n\t\t}\n\t}\n\n\ti = 0;\n\twhile ( (child = (GF_XMLNode*) gf_list_enum(node->content, &i))) {\n\t\tif (child->type) {\n\t\t\tif (!is_data) continue;\n\t\t\tu8 *data = child->name;\n\t\t\tu32 ilen = (u32) strlen(data);\n\t\t\tf_size = 3*ilen/4;\n\t\t\tf_data = gf_malloc(sizeof(u8) * f_size);\n\n\t\t\tf_size = gf_base64_decode(data, ilen, f_data, f_size);\n\n\t\t\te = ttml_push_res(ctx, interval, f_data, f_size);\n\t\t\tif (e) return e;\n\n\t\t\tidx = gf_list_count(interval ? interval->resources : ctx->ttml_resources);\n\t\t\tsprintf(szURN, \"urn:mpeg:14496-30:%d\", idx);\n\n\t\t\tGF_SAFEALLOC(att, GF_XMLAttribute)\n\t\t\tif (att) {\n\t\t\t\tatt->name = gf_strdup(\"src\");\n\t\t\t\tatt->value = gf_strdup(szURN);\n\t\t\t\tgf_list_add(parent_source_node->attributes, att);\n\t\t\t}\n\t\t\tif (!att || !att->value || !att->name) return GF_OUT_OF_MEM;\n\t\t\tif (data_type) {\n\t\t\t\tgf_list_del_item(node->attributes, data_type);\n\t\t\t\tgf_list_add(parent_source_node->attributes, data_type);\n\t\t\t}\n\t\t\tgf_xml_dom_node_reset(parent_source_node, GF_FALSE, GF_TRUE);\n\t\t\tctx->has_images = GF_TRUE;\n\t\t\treturn GF_OK;\n\t\t}\n\n\t\te = ttml_push_resources(ctx, interval, child, is_source ? node : NULL);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err ttml_rewrite_timestamp(GF_TXTIn *ctx, s64 ttml_zero, GF_XMLAttribute *att, s64 *value, Bool *drop)\n{\n\tu64 v;\n\tchar szTS[21];\n\tu32 h, m, s, ms;\n\t*value = ttml_get_timestamp(ctx, att->value);\n\tif (!ttml_zero)\n\t\treturn GF_OK;\n\n\tif (*value < ttml_zero) {\n\t\t*drop = GF_TRUE;\n\t\treturn GF_OK;\n\t}\n\n\t*value -= ttml_zero;\n\tv = (u64) (*value / 1000);\n\th = (u32) (v / 3600);\n\tm = (u32) (v - h*60) / 60;\n\ts = (u32) (v - h*3600 - m*60);\n\tms = (*value) % 1000;\n\n\tsnprintf(szTS, 20, \"%02d:%02d:%02d.%03d\", h, m, s, ms);\n\tszTS[20] = 0;\n\tgf_free(att->value);\n\tatt->value = gf_strdup(szTS);\n\treturn GF_OK;\n}\n\nstatic GF_Err ttml_setup_intervals(GF_TXTIn *ctx)\n{\n\tu32 k, i, nb_divs;\n\ts64 ttml_zero_ms = 0;\n\tGF_Err e;\n\tGF_XMLNode *root;\n\n\tif (!ctx->intervals)\n\t\tctx->intervals = gf_list_new();\n\telse\n\t\tttml_reset_intervals(ctx);\n\n\tctx->has_images = GF_FALSE;\n\troot = ctx->root_working_copy;\n\tfor (k=0; k<gf_list_count(root->content); k++) {\n\t\tGF_XMLNode *head = (GF_XMLNode*)gf_list_get(root->content, k);\n\t\tif (head->type) continue;\n\t\tif (strcmp(head->name, \"head\")) continue;\n\t\tttml_push_resources(ctx, NULL, head, NULL);\n\t\tbreak;\n\t}\n\n\troot = gf_xml_dom_get_root(ctx->parser);\n\tif (ctx->ttml_zero) {\n\t\tif (ctx->ttml_zero[0]=='T')\n\t\t\tttml_zero_ms = ttml_get_timestamp(ctx, (char *) ctx->ttml_zero+1);\n\t\telse\n\t\t\tttml_zero_ms = ttml_get_timestamp(ctx, (char *) ctx->ttml_zero);\n\t}\n\n\tnb_divs = gf_list_count(ctx->div_nodes_list);\n\tfor (i=0; i<nb_divs; i++) {\n\t\tu32 nb_children;\n\t\tGF_XMLNode *div_node = gf_list_get(ctx->div_nodes_list, i);\n\t\tnb_children = gf_list_count(div_node->content);\n\n\t\tfor (k=0; k<nb_children; k++) {\n\t\t\tTTMLInterval *ival=NULL;\n\t\t\tu32 p_idx;\n\t\t\tBool drop = GF_FALSE;\n\t\t\tGF_XMLAttribute *p_att;\n\t\t\tGF_XMLNode *p_node;\n\t\t\ts64 begin=-1, end=-1;\n\t\t\tGF_XMLNode *adiv_child = (GF_XMLNode*)gf_list_get(div_node->content, k);\n\t\t\tif (adiv_child->type) continue;\n\t\t\te = gf_xml_get_element_check_namespace(adiv_child, \"p\", root->ns);\n\t\t\tif (e) continue;\n\n\t\t\tp_idx = 0;\n\t\t\twhile ( (p_att = (GF_XMLAttribute*)gf_list_enum(adiv_child->attributes, &p_idx))) {\n\t\t\t\tif (!strcmp(p_att->name, \"begin\")) {\n\t\t\t\t\te = ttml_rewrite_timestamp(ctx, ttml_zero_ms, p_att, &begin, &drop);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t}\n\t\t\t\tif (!strcmp(p_att->name, \"end\")) {\n\t\t\t\t\te = ttml_rewrite_timestamp(ctx, ttml_zero_ms, p_att, &end, &drop);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (drop) {\n\t\t\t\tgf_xml_dom_node_del(adiv_child);\n\t\t\t\tgf_list_rem(div_node->content, k);\n\t\t\t\tk--;\n\t\t\t\tnb_children--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\te = ttml_push_interval(ctx, begin, end, &ival);\n\t\t\tif (e) return e;\n\n\t\t\te = ttml_push_resources(ctx, ival, adiv_child, NULL);\n\t\t\tif (e) return e;\n\n\t\t\tp_idx = 0;\n\t\t\twhile ( (p_node = (GF_XMLNode*)gf_list_enum(adiv_child->content, &p_idx))) {\n\t\t\t\ts64 s_begin=-1, s_end=-1;\n\t\t\t\te = gf_xml_get_element_check_namespace(p_node, \"span\", root->ns);\n\t\t\t\tif (e) continue;\n\n\t\t\t\tu32 span_idx = 0;\n\t\t\t\tGF_XMLAttribute *span_att;\n\t\t\t\twhile ( (span_att = (GF_XMLAttribute*)gf_list_enum(p_node->attributes, &span_idx))) {\n\t\t\t\t\tif (!strcmp(span_att->name, \"begin\")) {\n\t\t\t\t\t\te = ttml_rewrite_timestamp(ctx, ttml_zero_ms, span_att, &s_begin, &drop);\n\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t} else if (!strcmp(span_att->name, \"end\")) {\n\t\t\t\t\t\te = ttml_rewrite_timestamp(ctx, ttml_zero_ms, span_att, &s_end, &drop);\n\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\te = ttml_push_interval(ctx, s_begin, s_end, &ival);\n\t\t\t\tif (e) return e;\n\n\t\t\t\te = ttml_push_resources(ctx, ival, p_node, NULL);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t}\n\t}\n\n\t//empty doc\n\tif (!gf_list_count(ctx->intervals)) {\n\t\tTTMLInterval *interval;\n\t\tGF_SAFEALLOC(interval, TTMLInterval);\n\t\tinterval->begin = interval->end = 0;\n\t\tgf_list_add(ctx->intervals, interval);\n\t}\n\n#ifndef GPAC_DISABLE_LOG\n\tif (gf_log_tool_level_on(GF_LOG_PARSER, GF_LOG_DEBUG)) {\n\t\tfor (k=0; k<gf_list_count(ctx->intervals); k++) {\n\t\t\tTTMLInterval *ival = gf_list_get(ctx->intervals, k);\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[TTML EBU-TTD] Interval %d: \"LLU\"-\"LLU\"\\n\", k+1, ival->begin, ival->end));\n\t\t}\n\t}\n#endif\n\treturn GF_OK;\n}\n\nGF_Err ttml_parse_root(GF_XMLNode *root, const char **lang, u32 *tick_rate, u32 *ttml_fps_num, u32 *ttml_fps_den, u32 *ttml_sfps)\n{\n\t/*** root (including language) ***/\n\tGF_XMLAttribute *att;\n\tu32 i;\n\tu32 sub_fps_num = 0;\n\tu32 sub_fps_den = 0;\n\ti=0;\n\t*lang = NULL;\n\t*tick_rate = 0;\n\t*ttml_fps_num = 0;\n\t*ttml_fps_den = 0;\n\t*ttml_sfps = 0;\n\n\twhile ( (att = (GF_XMLAttribute *)gf_list_enum(root->attributes, &i))) {\n\t\tconst char *att_name;\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[TTML] Found root attribute name %s, value %s\\n\", att->name, att->value));\n\n\t\tatt_name = strchr(att->name, ':');\n\t\tif (att_name) att_name++;\n\t\telse att_name = att->name;\n\n\t\tif (!strcmp(att->name, \"xmlns\")) {\n\t\t\tif (strcmp(att->value, TTML_NAMESPACE)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TTML] XML Namespace %s not recognized, expecting %s\\n\", att->name, att->value, TTML_NAMESPACE));\n\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t}\n\t\t}\n\t\telse if (!strcmp(att->name, \"xml:lang\") && att->value && strlen(att->value)) {\n\t\t\t*lang = att->value;\n\t\t}\n\t\telse if (!strcmp(att_name, \"tickRate\") && att->value) {\n\t\t\t*tick_rate = atoi(att->value);\n\t\t}\n\t\telse if (!strcmp(att_name, \"frameRate\") && att->value) {\n\t\t\t*ttml_fps_num = atoi(att->value);\n\t\t\t*ttml_fps_den = 1;\n\t\t}\n\t\telse if (!strcmp(att_name, \"frameRateMultiplier\") && att->value) {\n\t\t\tchar *sep = strchr(att->value, ' ');\n\t\t\tif (!sep) sep = strchr(att->value, '\\t');\n\t\t\tif (sep) {\n\t\t\t\tu8 c = sep[0];\n\t\t\t\tsep[0] = 0;\n\t\t\t\tsub_fps_num = atoi(sep);\n\t\t\t\tsep[0] = c;\n\t\t\t\twhile ((sep[0]==' ') || (sep[0]=='\\t'))\n\t\t\t\t\tsep++;\n\t\t\t\tsub_fps_den = atoi(sep);\n\t\t\t}\n\t\t}\n\t\telse if (!strcmp(att_name, \"subFrameRate\") && att->value) {\n\t\t\t*ttml_sfps = atoi(att->value);\n\t\t}\n\t}\n\n\tif (sub_fps_num && sub_fps_den && *ttml_fps_num) {\n\t\t*ttml_fps_num *= sub_fps_num;\n\t\t*ttml_fps_den = sub_fps_den;\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err gf_text_ttml_setup(GF_Filter *filter, GF_TXTIn *ctx)\n{\n\tGF_Err e;\n\tu32 i, ID;\n\tu64 file_size;\n\tGF_XMLNode *root, *node, *body_node;\n\tconst char *lang = ctx->lang;\n\n\n\tctx->is_setup = GF_TRUE;\n\tctx->parser = gf_xml_dom_new();\n\te = gf_xml_dom_parse(ctx->parser, ctx->file_name, ttxt_dom_progress, ctx);\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Error parsing TTML file: Line %d - %s. Abort.\\n\", gf_xml_dom_get_line(ctx->parser), gf_xml_dom_get_error(ctx->parser) ));\n\t\tctx->is_setup = GF_TRUE;\n\t\tctx->non_compliant_ttml = GF_TRUE;\n\t\treturn e;\n\t}\n\troot = gf_xml_dom_get_root(ctx->parser);\n\tif (!root) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Error parsing TTML file: no root XML element found. Abort.\\n\"));\n\t\tctx->non_compliant_ttml = GF_TRUE;\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\t/*look for TTML*/\n\tif (gf_xml_get_element_check_namespace(root, \"tt\", NULL) != GF_OK) {\n\t\tif (root->ns) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"TTML file not recognized: root element is \\\"%s:%s\\\" (check your namespaces)\\n\", root->ns, root->name));\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"TTML file not recognized: root element is \\\"%s\\\"\\n\", root->name));\n\t\t}\n\t\tctx->non_compliant_ttml = GF_TRUE;\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[TXTIn] TTML EBU-TTD detected\\n\"));\n\n\troot = gf_xml_dom_get_root(ctx->parser);\n\n\te = ttml_parse_root(root, &lang, &ctx->tick_rate, &ctx->ttml_fps_num, &ctx->ttml_fps_den, &ctx->ttml_sfps);\n\tif (e) {\n\t\tctx->non_compliant_ttml = GF_TRUE;\n\t\treturn e;\n\t}\n\t//locate body\n\tbody_node = NULL;\n\ti=0;\n\twhile ( (node = (GF_XMLNode*)gf_list_enum(root->content, &i))) {\n\t\tif (node->type) {\n\t\t\tcontinue;\n\t\t}\n\t\te = gf_xml_get_element_check_namespace(node, \"body\", root->ns);\n\t\tif (e == GF_BAD_PARAM) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] ignored \\\"%s\\\" node, check your namespaces\\n\", node->name));\n\t\t} else if (e == GF_OK) {\n\t\t\tif (body_node) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TTML EBU-TTD] duplicated \\\"body\\\" element. Abort.\\n\"));\n\t\t\t\tctx->non_compliant_ttml = GF_TRUE;\n\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t}\n\t\t\tbody_node = node;\n\t\t}\n\t}\n\tif (!body_node) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[TTML EBU-TTD] \\\"body\\\" element not found, assuming empty doc\\n\"));\n\t}\n\n\tif (!ctx->div_nodes_list) {\n\t\tctx->div_nodes_list = gf_list_new();\n\t\tif (!ctx->div_nodes_list) return GF_OUT_OF_MEM;\n\t} else {\n\t\tgf_list_reset(ctx->div_nodes_list);\n\t}\n\n\tif (body_node) {\n\t\ti=0;\n\t\twhile ( (node = (GF_XMLNode*)gf_list_enum(body_node->content, &i))) {\n\t\t\tif (!node->type) {\n\t\t\t\te = gf_xml_get_element_check_namespace(node, \"div\", root->ns);\n\t\t\t\tif (e == GF_BAD_PARAM) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] ignored \\\"%s\\\" node, check your namespaces\\n\", node->name));\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_list_add(ctx->div_nodes_list, node);\n\t\t}\n\t}\n\tfile_size = ctx->end;\n\tif (!ctx->timescale) ctx->timescale = 1000;\n\n\tif (!ctx->opid) ctx->opid = gf_filter_pid_new(filter);\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_TEXT) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, &PROP_UINT(GF_CODECID_SUBS_XML) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, &PROP_UINT(ctx->timescale) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DOWN_SIZE, &PROP_LONGUINT(file_size) );\n\n\tID = 1;\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ID, &PROP_UINT(ID) );\n\tif (ctx->width) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_WIDTH, &PROP_UINT(ctx->width) );\n\tif (ctx->height) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_HEIGHT, &PROP_UINT(ctx->height) );\n\tif (ctx->zorder) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ZORDER, &PROP_SINT(ctx->zorder) );\n\tif (lang) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_LANGUAGE, &PROP_STRING( lang) );\n\tgf_filter_pid_set_property_str(ctx->opid, \"meta:xmlns\", &PROP_STRING(TTML_NAMESPACE) );\n\n\t/*** body ***/\n\tctx->parser_working_copy = gf_xml_dom_new();\n\te = gf_xml_dom_parse(ctx->parser_working_copy, ctx->file_name, NULL, NULL);\n\tassert (e == GF_OK);\n\tctx->root_working_copy = gf_xml_dom_get_root(ctx->parser_working_copy);\n\tassert(ctx->root_working_copy);\n\n\tif (body_node) {\n\t\t/*remove all the sample entries (instances in body) entries from the working copy, we will add each sample in this clone DOM  to create full XML of each sample*/\n\t\tebu_ttd_remove_samples(ctx->root_working_copy, &ctx->body_node);\n\t\tif (!ctx->body_node) {\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t} else {\n\t\tctx->body_node = NULL;\n\t}\n\n\tctx->current_tt_interval = 0;\n\n\tctx->last_sample_duration = 0;\n\tctx->end = 0;\n\tctx->first_samp = GF_TRUE;\n\n\ttxtin_probe_duration(ctx);\n\n\te = ttml_setup_intervals(ctx);\n\tif (e) return e;\n\n\tif (ctx->has_images) {\n\t\tchar *mime_cfg = \"application/ttml+xml;codecs=im1i\";\n\t\tgf_filter_pid_set_property_str(ctx->opid, \"meta:mime\", &PROP_STRING(mime_cfg) );\n\t} else {\n\t\tgf_filter_pid_set_property_str(ctx->opid, \"meta:mime\", NULL);\n\t}\n\treturn GF_OK;\n}\n\nstatic Bool ttml_check_range(TTMLInterval *interval, s64 ts_begin, s64 ts_end)\n{\n\t//if in current interval, push node\n\tif ((ts_begin != -1) && (ts_end != -1) && ((ts_begin>=interval->begin) && (ts_end<=interval->end))\n\t) {\n\t\treturn GF_TRUE;\n\t}\n\t//begin not set, end set: in range if end less than interval end range\n\telse if ((ts_begin==-1) && (ts_end != -1) && (ts_end<=interval->end)) {\n\t\treturn GF_TRUE;\n\t}\n\t//begin set, end not set: in range if begin greater than interval begin range\n\telse if ((ts_begin!=-1) && (ts_end==-1) && (ts_begin>=interval->begin)) {\n\t\treturn GF_TRUE;\n\t}\n\treturn GF_FALSE;\n}\n\nstatic GF_Err ttml_send_empty_sample(GF_TXTIn *ctx, u64 sample_start, u64 sample_end)\n{\n\t//we are not splitting, don't inject empty sample\n\tif (! ctx->ttml_split) return GF_OK;\n\tif (ctx->no_empty) return GF_OK;\n\n\tGF_List *bck = ctx->root_working_copy->content;\n\tctx->root_working_copy->content = gf_list_new();\n\tchar *samp_text = gf_xml_dom_serialize_root((GF_XMLNode*)ctx->root_working_copy, GF_FALSE, GF_FALSE);\n\tgf_list_del(ctx->root_working_copy->content);\n\tctx->root_working_copy->content = bck;\n\tif (!samp_text) return GF_OUT_OF_MEM;\n\n\tchar *txt_str = ttxt_parse_string(samp_text, GF_TRUE);\n\tif (!txt_str) txt_str = \"\";\n\tu32 txt_len = (u32) strlen(txt_str);\n\tu8 *pck_data;\n\tGF_FilterPacket *pck = gf_filter_pck_new_alloc(ctx->opid, txt_len, &pck_data);\n\tif (!pck) {\n\t\tgf_free(samp_text);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tmemcpy(pck_data, txt_str, txt_len);\n\tgf_free(samp_text);\n\n\tgf_filter_pck_set_sap(pck, GF_FILTER_SAP_1);\n\n\tu64 cts = gf_timestamp_rescale(sample_start, 1000, ctx->timescale);\n\tif (ctx->ttml_cts.num>=0) {\n\t\tcts += gf_timestamp_rescale(ctx->ttml_cts.num, ctx->ttml_cts.den, ctx->timescale);\n\t\tcts -= ctx->cts_first_interval;\n\t}\n\tgf_filter_pck_set_cts(pck, cts);\n\n\tif (sample_end >= sample_start) {\n\t\tu64 dur = gf_timestamp_rescale(sample_end - sample_start, 1000, ctx->timescale);\n\t\tgf_filter_pck_set_duration(pck, (u32) dur);\n\t}\n\n\treturn gf_filter_pck_send(pck);\n}\n\nstatic GF_Err gf_text_process_ttml(GF_Filter *filter, GF_TXTIn *ctx, GF_FilterPacket *ipck)\n{\n\tGF_Err e;\n\tGF_XMLNode *root;\n\tu32 i, nb_res_interval=0, k, nb_div_nodes;\n\tchar *samp_text=NULL;\n\tGF_List *emb_resources = NULL;\n\tTTMLInterval *interval;\n\tBool sample_empty = GF_TRUE;\n\n\tif (!ctx->is_setup) return gf_text_ttml_setup(filter, ctx);\n\tif (ctx->non_compliant_ttml || !ctx->opid) return GF_NOT_SUPPORTED;\n\tif (!ctx->playstate) return GF_OK;\n\telse if (ctx->playstate==2) return GF_EOS;\n\n\tif (ctx->seek_state==1) {\n\t\tctx->seek_state = 2;\n\t\tctx->current_tt_interval = 0;\n\t}\n\n\tinterval = gf_list_get(ctx->intervals, ctx->current_tt_interval);\n\tif (!interval) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[TTML EBU-TTD] last_sample_duration=\"LLU\", last_sample_end=\"LLU\"\\n\", ctx->last_sample_duration, ctx->end));\n\n\t\tgf_filter_pid_set_info_str( ctx->opid, \"ttxt:last_dur\", &PROP_UINT((u32) ctx->last_sample_duration) );\n\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\treturn GF_EOS;\n\t}\n\tctx->current_tt_interval++;\n\n\temb_resources = interval->resources ? interval->resources : ctx->ttml_resources;\n\tnb_res_interval = gf_list_count(emb_resources);\n\n\troot = gf_xml_dom_get_root(ctx->parser);\n\n\tnb_div_nodes = gf_list_count(ctx->div_nodes_list);\n\tfor (k=0; k<nb_div_nodes; k++) {\n\t\tBool has_content = GF_FALSE;\n\t\tGF_XMLNode *div_node = gf_list_get(ctx->div_nodes_list, k);\n\t\tu32 nb_children = gf_list_count(div_node->content);\n\n\t\tGF_XMLNode *copy_div_node = gf_list_get(ctx->body_node->content, k);\n\n\t\tfor (i=0; i < nb_children; i++) {\n\t\t\tGF_XMLNode *p_node;\n\t\t\tGF_XMLAttribute *p_att;\n\t\t\tu32 p_idx = 0;\n\t\t\ts64 ts_begin = -1, ts_end = -1;\n\t\t\tBool in_range;\n\t\t\tGF_XMLNode *div_child = (GF_XMLNode*)gf_list_get(div_node->content, i);\n\t\t\tif (div_child->type) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\te = gf_xml_get_element_check_namespace(div_child, \"p\", root->ns);\n\t\t\tif (e == GF_BAD_PARAM) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] ignored \\\"%s\\\" node, check your namespaces\\n\", div_child->name));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\n\t\t\t//sample is either in the <p> ...\n\t\t\tp_idx = 0;\n\t\t\twhile ( (p_att = (GF_XMLAttribute*)gf_list_enum(div_child->attributes, &p_idx))) {\n\t\t\t\tif (!strcmp(p_att->name, \"begin\")) {\n\t\t\t\t\tif (ts_begin != -1) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TTML EBU-TTD] duplicated \\\"begin\\\" attribute. Abort.\\n\"));\n\t\t\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t}\n\t\t\t\t\tts_begin = ttml_get_timestamp(ctx, p_att->value);\n\t\t\t\t} else if (!strcmp(p_att->name, \"end\")) {\n\t\t\t\t\tif (ts_end != -1) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TTML EBU-TTD] duplicated \\\"end\\\" attribute. Abort.\\n\"));\n\t\t\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t}\n\t\t\t\t\tts_end = ttml_get_timestamp(ctx, p_att->value);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tin_range = ttml_check_range(interval, ts_begin, ts_end);\n\t\t\tif (in_range) {\n\t\t\t\tGF_XMLNode *prev_child = i ? (GF_XMLNode*) gf_list_get(div_node->content, i-1) : NULL;\n\t\t\t\tif (prev_child && prev_child->type) {\n\t\t\t\t\tgf_xml_dom_append_child(copy_div_node, prev_child);\n\t\t\t\t}\n\t\t\t\te = gf_xml_dom_append_child(copy_div_node, div_child);\n\t\t\t\tassert(e == GF_OK);\n\t\t\t\thas_content = GF_TRUE;\n\t\t\t}\n\n\t\t\t//or under a <span>\n\t\t\tp_idx = 0;\n\t\t\twhile ( (p_node = (GF_XMLNode*)gf_list_enum(div_child->content, &p_idx))) {\n\t\t\t\tu32 span_idx = 0;\n\t\t\t\tGF_XMLAttribute *span_att;\n\t\t\t\te = gf_xml_get_element_check_namespace(p_node, \"span\", root->ns);\n\t\t\t\tif (e == GF_BAD_PARAM) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] ignored \\\"%s\\\" node, check your namespaces\\n\", p_node->name));\n\t\t\t\t}\n\t\t\t\telse if (e)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tts_begin = ts_end = -1;\n\t\t\t\twhile ( (span_att = (GF_XMLAttribute*)gf_list_enum(p_node->attributes, &span_idx))) {\n\t\t\t\t\tif (!strcmp(span_att->name, \"begin\")) {\n\t\t\t\t\t\tif (ts_begin != -1) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TTML EBU-TTD] duplicated \\\"begin\\\" attribute under <span>. Abort.\\n\"));\n\t\t\t\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tts_begin = ttml_get_timestamp(ctx, span_att->value);\n\t\t\t\t\t} else if (!strcmp(span_att->name, \"end\")) {\n\t\t\t\t\t\tif (ts_end != -1) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TTML EBU-TTD] duplicated \\\"end\\\" attribute under <span>. Abort.\\n\"));\n\t\t\t\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tts_end = ttml_get_timestamp(ctx, span_att->value);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*append the entire <p> and break (we cannot split the text content)*/\n\t\t\t\tin_range = ttml_check_range(interval, ts_begin, ts_end);\n\t\t\t\tif (in_range) {\n\t\t\t\t\tGF_XMLNode *prev_child = i ? (GF_XMLNode*) gf_list_get(div_node->content, i-1) : NULL;\n\t\t\t\t\tif (prev_child && prev_child->type) {\n\t\t\t\t\t\tgf_xml_dom_append_child(copy_div_node, prev_child);\n\t\t\t\t\t}\n\t\t\t\t\te = gf_xml_dom_append_child(copy_div_node, div_child);\n\t\t\t\t\tassert(e == GF_OK);\n\t\t\t\t\thas_content = GF_TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (has_content) {\n\t\t\tGF_XMLNode *last_child = (GF_XMLNode*) gf_list_last(div_node->content);\n\t\t\tif (last_child && last_child->type) {\n\t\t\t\tgf_xml_dom_append_child(copy_div_node, last_child);\n\t\t\t}\n\t\t\tsample_empty = GF_FALSE;\n\t\t}\n\t}\n\n\t//empty doc\n\tif (!ctx->body_node)\n\t\tsample_empty = GF_FALSE;\n\n\tif (! sample_empty) {\n\t\tsamp_text = gf_xml_dom_serialize_root((GF_XMLNode*)ctx->root_working_copy, GF_FALSE, GF_FALSE);\n\n\t\tfor (k=0; k<nb_div_nodes; k++) {\n\t\t\tGF_XMLNode *copy_div_node = gf_list_get(ctx->body_node->content, k);\n\t\t\tif (!copy_div_node->type)\n\t\t\t\tgf_list_reset(copy_div_node->content);\n\t\t}\n\t}\n\n\tif (samp_text) {\n\t\tGF_FilterPacket *pck;\n\t\tu8 *pck_data;\n\t\tBool skip_pck = GF_FALSE;\n\t\tu32 txt_len;\n\t\tu32 res_len = 0;\n\t\tchar *txt_str;\n\n\n\t\tif (interval->begin < (s64) ctx->end) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TTML EBU-TTD] Error computing overlapped intervals! \\\"begin\\\" is \"LLD\" , last \\\"end\\\" was \"LLD\". Abort.\\n\", interval->begin, ctx->end));\n\t\t\te = GF_NOT_SUPPORTED;\n\t\t\tgoto exit;\n\t\t}\n\n\t\ttxt_str = ttxt_parse_string(samp_text, GF_TRUE);\n\t\tif (!txt_str) txt_str = \"\";\n\t\ttxt_len = (u32) strlen(txt_str);\n\n\t\tfor (i=0; i<nb_res_interval; i++) {\n\t\t\tTTMLRes *res = gf_list_get(emb_resources, i);\n\t\t\tres_len += res->size;\n\t\t}\n\n\t\tif (ctx->first_samp) {\n\t\t\tctx->cts_first_interval = 0;\n\t\t\t//start from 0\n\t\t\tif (ctx->ttml_cts.num==-1) {\n\t\t\t\tinterval->begin = 0;\n\t\t\t} else if (ctx->ttml_cts.num>=0) {\n\t\t\t\tctx->cts_first_interval = gf_timestamp_rescale(interval->begin, 1000, ctx->timescale);\n\t\t\t}\n\t\t}\n\n\t\tif (ctx->seek_state==2) {\n\t\t\tDouble end = (Double) interval->end;\n\t\t\tend /= ctx->timescale;\n\t\t\tif (end<ctx->start_range) skip_pck = GF_TRUE;\n\t\t\telse ctx->seek_state = 0;\n\t\t}\n\n\n\t\tif (!ctx->first_samp && ((s64)ctx->end < interval->begin)) {\n\t\t\tttml_send_empty_sample(ctx, ctx->end, interval->begin);\n\t\t}\n\n\t\tctx->first_samp = GF_FALSE;\n\t\tctx->last_sample_duration = interval->end - interval->begin;\n\n\t\tctx->end = interval->end;\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"ts_begin=\"LLD\", ts_end=\"LLD\", last_sample_duration=\"LLU\" (real duration: \"LLU\"), last_sample_end=\"LLU\"\\n\", interval->begin, interval->end, interval->end - ctx->end, ctx->last_sample_duration, ctx->end));\n\n\t\tif (!skip_pck) {\n\t\t\tpck = gf_filter_pck_new_alloc(ctx->opid, txt_len+res_len, &pck_data);\n\t\t\tif (!pck) {\n\t\t\t\tgf_free(samp_text);\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tmemcpy(pck_data, txt_str, txt_len);\n\t\t\tgf_filter_pck_set_sap(pck, GF_FILTER_SAP_1);\n\n\t\t\tu64 cts = gf_timestamp_rescale(interval->begin, 1000, ctx->timescale);\n\t\t\tif (ctx->ttml_cts.num>=0) {\n\t\t\t\tcts += gf_timestamp_rescale(ctx->ttml_cts.num, ctx->ttml_cts.den, ctx->timescale);\n\t\t\t\tcts -= ctx->cts_first_interval;\n\t\t\t}\n\t\t\tgf_filter_pck_set_cts(pck, cts);\n\n\t\t\tif (!ctx->ttml_split && (ctx->ttml_dur.num>0) && ctx->ttml_dur.den) {\n\t\t\t\tctx->last_sample_duration = gf_timestamp_rescale(ctx->ttml_dur.num, ctx->ttml_dur.den, ctx->timescale);\n\t\t\t\tgf_filter_pck_set_duration(pck, (u32) ctx->last_sample_duration);\n\t\t\t} else {\n\t\t\t\tif (interval->end >= interval->begin) {\n\t\t\t\t\tu64 dur = gf_timestamp_rescale(interval->end - interval->begin, 1000, ctx->timescale);\n\t\t\t\t\tgf_filter_pck_set_duration(pck, (u32) dur);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (res_len) {\n\t\t\t\tGF_BitStream *subs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\t\tu8 *subs_data;\n\t\t\t\tu32 subs_size;\n\t\t\t\t//subs 0\n\t\t\t\tgf_bs_write_u32(subs, 0);\n\t\t\t\tgf_bs_write_u32(subs, txt_len);\n\t\t\t\tgf_bs_write_u32(subs, 0);\n\t\t\t\tgf_bs_write_u8(subs, 0);\n\t\t\t\tgf_bs_write_u8(subs, 0);\n\n\t\t\t\tpck_data += txt_len;\n\t\t\t\tfor (i=0; i<nb_res_interval; i++) {\n\t\t\t\t\tTTMLRes *res = gf_list_get(emb_resources, i);\n\t\t\t\t\tmemcpy(pck_data, res->data, res->size);\n\t\t\t\t\tpck_data += res->size;\n\n\t\t\t\t\t//subs >0\n\t\t\t\t\tgf_bs_write_u32(subs, 0);\n\t\t\t\t\tgf_bs_write_u32(subs, res->size);\n\t\t\t\t\tgf_bs_write_u32(subs, 0);\n\t\t\t\t\tgf_bs_write_u8(subs, 0);\n\t\t\t\t\tgf_bs_write_u8(subs, 0);\n\t\t\t\t}\n\t\t\t\tgf_bs_get_content(subs, &subs_data, &subs_size);\n\t\t\t\tgf_bs_del(subs);\n\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_SUBS, &PROP_DATA_NO_COPY(subs_data, subs_size) );\n\t\t\t}\n\t\t\tgf_filter_pck_send(pck);\n\t\t}\n\n\t\tgf_free(samp_text);\n\t\tsamp_text = NULL;\n\t} else {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] empty sample (begin=\"LLD\", end=\"LLD\"). Skip.\\n\", interval->begin, interval->end));\n\t}\n\n\treturn GF_OK;\n\n\nexit:\n\tif (!ctx->non_compliant_ttml) {\n\t\tctx->non_compliant_ttml = GF_TRUE;\n\t\tgf_filter_pid_set_discard(ctx->ipid, GF_TRUE);\n\t}\n\treturn e;\n}\n\n#ifndef GPAC_DISABLE_SWF_IMPORT\n\nstatic GF_Err swf_svg_add_iso_sample(void *user, const u8 *data, u32 length, u64 timestamp, Bool isRap)\n{\n\tGF_FilterPacket *pck;\n\tu8 *pck_data;\n\tGF_TXTIn *ctx = (GF_TXTIn *)user;\n\n\tif (ctx->seek_state==2) {\n\t\tDouble ts = (Double) timestamp;\n\t\tts/=1000;\n\t\tif (ts<ctx->start_range) return GF_OK;\n\t\tctx->seek_state = 0;\n\t}\n\n\tpck = gf_filter_pck_new_alloc(ctx->opid, length, &pck_data);\n\tif (pck) {\n\t\tmemcpy(pck_data, data, length);\n\t\tgf_filter_pck_set_cts(pck, (u64) (ctx->timescale*timestamp/1000) );\n\t\tgf_filter_pck_set_sap(pck, isRap ? GF_FILTER_SAP_1 : GF_FILTER_SAP_NONE);\n\t\tgf_filter_pck_set_framing(pck, GF_TRUE, GF_FALSE);\n\n\t\tgf_filter_pck_send(pck);\n\t}\n\n\tif (gf_filter_pid_would_block(ctx->opid))\n\t\tctx->do_suspend = GF_TRUE;\n\treturn GF_OK;\n}\n\nstatic GF_Err swf_svg_add_iso_header(void *user, const u8 *data, u32 length, Bool isHeader)\n{\n\tGF_TXTIn *ctx = (GF_TXTIn *)user;\n\n\tif (isHeader) {\n\t\tif (!ctx->hdr_parsed) {\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA((char *)data, (u32) ( strlen(data)+1 ) )  );\n\t\t\tctx->hdr_parsed = GF_TRUE;\n\t\t}\n\t} else if (!ctx->seek_state) {\n\t\tGF_FilterPacket *pck;\n\t\tu8 *pck_data;\n\t\tpck = gf_filter_pck_new_alloc(ctx->opid, length, &pck_data);\n\t\tif (pck) {\n\t\t\tmemcpy(pck_data, data, length);\n\t\t\tgf_filter_pck_set_framing(pck, GF_FALSE, GF_TRUE);\n\n\t\t\tgf_filter_pck_send(pck);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err gf_text_swf_setup(GF_Filter *filter, GF_TXTIn *ctx)\n{\n\tGF_Err e;\n\tu32 ID;\n\n\tctx->swf_parse = gf_swf_reader_new(NULL, ctx->file_name);\n\te = gf_swf_read_header(ctx->swf_parse);\n\tif (e) return e;\n\tgf_swf_reader_set_user_mode(ctx->swf_parse, ctx, swf_svg_add_iso_sample, swf_svg_add_iso_header);\n\n\tif (!ctx->timescale) ctx->timescale = 1000;\n\n\tif (!ctx->opid) ctx->opid = gf_filter_pid_new(filter);\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_TEXT) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, &PROP_UINT(GF_CODECID_SIMPLE_TEXT) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, &PROP_UINT(ctx->timescale) );\n//\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DOWN_SIZE, &PROP_UINT(file_size) );\n\n\t//patch for old arch\n\tctx->width = FIX2INT(ctx->swf_parse->width);\n\tctx->height = FIX2INT(ctx->swf_parse->height);\n\tif (!ctx->width && !ctx->height) {\n\t\tctx->width = 400;\n\t\tctx->height = 60;\n\t}\n\tID = 1;\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ID, &PROP_UINT(ID) );\n\tif (ctx->width) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_WIDTH, &PROP_UINT(ctx->width) );\n\tif (ctx->height) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_HEIGHT, &PROP_UINT(ctx->height) );\n\tif (ctx->zorder) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ZORDER, &PROP_SINT(ctx->zorder) );\n\tif (ctx->lang) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_LANGUAGE, &PROP_STRING( ctx->lang) );\n\n\tgf_filter_pid_set_property_str(ctx->opid, \"meta:mime\", &PROP_STRING(\"image/svg+xml\") );\n\n#ifndef GPAC_DISABLE_SVG\n\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] swf -> svg not fully migrated, using SWF flags 0 and no flatten angle. Patch welcome\\n\"));\n\te = swf_to_svg_init(ctx->swf_parse, 0, 0);\n#endif\n\n\t//SWF->BIFS is handled in ctx loader, no need to define it here\n\ttxtin_probe_duration(ctx);\n\n\treturn e;\n}\n\nstatic GF_Err gf_text_process_swf(GF_Filter *filter, GF_TXTIn *ctx, GF_FilterPacket *ipck)\n{\n\tGF_Err e=GF_OK;\n\n\tif (!ctx->is_setup) {\n\t\tctx->is_setup = GF_TRUE;\n\t\treturn gf_text_swf_setup(filter, ctx);\n\t}\n\tif (!ctx->opid) return GF_NOT_SUPPORTED;\n\n\tif (ctx->seek_state==1) {\n\t\tctx->seek_state = 2;\n\t\tgf_swf_reader_del(ctx->swf_parse);\n\t\tctx->swf_parse = gf_swf_reader_new(NULL, ctx->file_name);\n\t\tgf_swf_read_header(ctx->swf_parse);\n\t\tgf_swf_reader_set_user_mode(ctx->swf_parse, ctx, swf_svg_add_iso_sample, swf_svg_add_iso_header);\n\t}\n\n\tctx->do_suspend = GF_FALSE;\n\t/*parse all tags*/\n\twhile (e == GF_OK) {\n\t\te = swf_parse_tag(ctx->swf_parse);\n\t\tif (ctx->do_suspend) return GF_OK;\n\t}\n\tif (e==GF_EOS) {\n\t\tif (ctx->swf_parse->finalize) {\n\t\t\tctx->swf_parse->finalize(ctx->swf_parse);\n\t\t\tctx->swf_parse->finalize = NULL;\n\t\t}\n\t}\n\treturn e;\n}\n/* end of SWF Importer */\n\n#else\n\n#ifndef GPAC_DISABLE_ZLIB\nstatic GF_Err gf_text_process_swf(GF_Filter *filter, GF_TXTIn *ctx)\n{\n\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"Warning: GPAC was compiled without SWF import support, can't import file.\\n\"));\n\treturn GF_NOT_SUPPORTED;\n}\n#endif\n\n\n#endif /*GPAC_DISABLE_SWF_IMPORT*/\n\nstatic GF_Err gf_text_process_sub(GF_Filter *filter, GF_TXTIn *ctx, GF_FilterPacket *ipck)\n{\n\tu32 i, j, len, line;\n\tGF_TextSample *samp;\n\tDouble ts_scale;\n\tchar szLine[2048], szTime[41], szText[2048];\n\n\t//same setup as for srt\n\tif (!ctx->is_setup) {\n\t\tctx->is_setup = GF_TRUE;\n\t\treturn txtin_setup_srt(filter, ctx, GF_FALSE);\n\t}\n\tif (!ctx->opid) return GF_NOT_SUPPORTED;\n\tif (!ctx->playstate) return GF_OK;\n\telse if (ctx->playstate==2) return GF_EOS;\n\n\tif (ctx->seek_state==1) {\n\t\tctx->seek_state = 2;\n\t\tgf_fseek(ctx->src, 0, SEEK_SET);\n\t}\n\n\tif (ctx->fps.den && ctx->fps.num) {\n\t\tts_scale = ((Double) ctx->fps.num) / ctx->fps.den;\n\t} else {\n\t\tts_scale = 25;\n\t}\n\n\tline = 0;\n\n\twhile (1) {\n\t\tchar *sOK = gf_text_get_utf8_line(szLine, 2048, ctx->src, ctx->unicode_type);\n\t\tif (!sOK) break;\n\n\t\tREM_TRAIL_MARKS(szLine, \"\\r\\n\\t \")\n\n\t\tline++;\n\t\tlen = (u32) strlen(szLine);\n\t\tif (!len) continue;\n\n\t\ti=0;\n\t\tif (szLine[i] != '{') {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Bad SUB file (line %d): expecting \\\"{\\\" got \\\"%c\\\"\\n\", line, szLine[i]));\n\t\t\tcontinue;\n\t\t}\n\t\twhile (szLine[i+1] && szLine[i+1]!='}') {\n\t\t\tszTime[i] = szLine[i+1];\n\t\t\ti++;\n\t\t\tif (i>=40) break;\n\t\t}\n\t\tszTime[i] = 0;\n\t\tctx->start = atoi(szTime);\n\t\tif (ctx->start < ctx->end) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] corrupted SUB frame (line %d) - starts (at %d ms) before end of previous one (%d ms) - adjusting time stamps\\n\", line, ctx->start, ctx->end));\n\t\t\tctx->start = ctx->end;\n\t\t}\n\t\tj=i+2;\n\t\ti=0;\n\t\tif (szLine[i+j] != '{') {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] Bad SUB file - expecting \\\"{\\\" got \\\"%c\\\"\\n\", szLine[i]));\n\t\t\tcontinue;\n\t\t}\n\t\twhile (szLine[i+1+j] && szLine[i+1+j]!='}') {\n\t\t\tszTime[i] = szLine[i+1+j];\n\t\t\ti++;\n\t\t\tif (i>=40) break;\n\t\t}\n\t\tszTime[i] = 0;\n\t\tctx->end = atoi(szTime);\n\t\tj+=i+2;\n\n\t\tif (ctx->start > ctx->end) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] corrupted SUB frame (line %d) - ends (at %d ms) before start of current frame (%d ms) - skipping\\n\", line, ctx->end, ctx->start));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ctx->start && ctx->first_samp) {\n\t\t\tsamp = gf_isom_new_text_sample();\n\t\t\ttxtin_process_send_text_sample(ctx, samp, 0, (u32) (ts_scale*ctx->start), GF_TRUE);\n\t\t\tctx->first_samp = GF_FALSE;\n\t\t\tgf_isom_delete_text_sample(samp);\n\t\t}\n\n\t\tfor (i=j; i<len; i++) {\n\t\t\tif (szLine[i]=='|') {\n\t\t\t\tszText[i-j] = '\\n';\n\t\t\t} else {\n\t\t\t\tszText[i-j] = szLine[i];\n\t\t\t}\n\t\t}\n\t\tszText[i-j] = 0;\n\n\t\tif (ctx->prev_end) {\n\t\t\tsamp = gf_isom_new_text_sample();\n\t\t\ttxtin_process_send_text_sample(ctx, samp, (u64) (ts_scale*(s64)ctx->prev_end), (u32) (ts_scale*(ctx->start - ctx->prev_end)), GF_TRUE);\n\t\t\tgf_isom_delete_text_sample(samp);\n\t\t}\n\n\t\tsamp = gf_isom_new_text_sample();\n\t\tgf_isom_text_add_text(samp, szText, (u32) strlen(szText) );\n\t\ttxtin_process_send_text_sample(ctx, samp, (u64) (ts_scale*(s64)ctx->start), (u32) (ts_scale*(ctx->end - ctx->start)), GF_TRUE);\n\t\tgf_isom_delete_text_sample(samp);\n\n\t\tctx->prev_end = ctx->end;\n\n\t\tgf_filter_pid_set_info(ctx->opid, GF_PROP_PID_DOWN_BYTES, &PROP_LONGUINT( gf_ftell(ctx->src )) );\n\n\t\tif (gf_filter_pid_would_block(ctx->opid))\n\t\t\treturn GF_OK;\n\t}\n\t/*final flush*/\n\tif (ctx->end && !ctx->noflush) {\n\t\tsamp = gf_isom_new_text_sample();\n\t\ttxtin_process_send_text_sample(ctx, samp, (u64) (ts_scale*(s64)ctx->end), 0, GF_TRUE);\n\t\tgf_isom_delete_text_sample(samp);\n\t}\n\n\tgf_filter_pid_set_info_str( ctx->opid, \"ttxt:last_dur\", &PROP_UINT(0) );\n\n\treturn GF_EOS;\n}\n\nstatic GF_Err gf_text_process_ssa(GF_Filter *filter, GF_TXTIn *ctx, GF_FilterPacket *ipck)\n{\n\tu32 i, j, len, line;\n\tGF_TextSample *samp;\n\tchar szLine[2048], szText[2048];\n\n\t//same setup as for srt\n\tif (!ctx->is_setup) {\n\t\tctx->is_setup = GF_TRUE;\n\t\tGF_Err e = txtin_setup_srt(filter, ctx, GF_FALSE);\n\t\tif (e || !ctx->unframed) return e;\n\t}\n\tif (!ctx->opid) return GF_NOT_SUPPORTED;\n\tif (!ctx->unframed) {\n\t\tif (!ctx->playstate) return GF_OK;\n\t\telse if (ctx->playstate==2) return GF_EOS;\n\t}\n\n\tif (ctx->seek_state==1) {\n\t\tctx->seek_state = 2;\n\t\tgf_fseek(ctx->src, 0, SEEK_SET);\n\t}\n\n\tline = 0;\n\n\twhile (1) {\n\t\tchar *start_p, *end_p;\n\t\tu32 eh, em, es, ems, nb_c;\n\t\tchar *sOK = gf_text_get_utf8_line(szLine, 2048, ctx->src, ctx->unicode_type);\n\t\tif (!sOK) break;\n\n\t\tREM_TRAIL_MARKS(szLine, \"\\r\\n\\t \")\n\n\t\tline++;\n\t\tlen = (u32) strlen(szLine);\n\t\tif (!len) continue;\n\n\t\tif (!ctx->unframed) {\n\t\t\tif (strncmp(szLine, \"Dialogue: \", 10)) continue;\n\n\t\t\tstart_p = strchr(szLine+10, ',');\n\t\t\tif (!start_p) continue;\n\t\t\tend_p = strchr(start_p+1, ',');\n\t\t\tif (!end_p) continue;\n\t\t\tend_p[0] = 0;\n\t\t\tstart_p++;\n\t\t\tif (sscanf(start_p, \"%u:%u:%u.%u\", &eh, &em, &es, &ems) != 4) {\n\t\t\t\teh = 0;\n\t\t\t\tif (sscanf(start_p, \"%u:%u.%u\", &em, &es, &ems) != 3) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tctx->start = (3600*eh + 60*em + es)*1000 + ems;\n\n\t\t\tstart_p = end_p+1;\n\t\t\tend_p = strchr(start_p, ',');\n\t\t\tif (!end_p) continue;\n\t\t\tend_p[0] = 0;\n\n\t\t\tif (sscanf(start_p, \"%u:%u:%u.%u\", &eh, &em, &es, &ems) != 4) {\n\t\t\t\teh = 0;\n\t\t\t\tif (sscanf(start_p, \"%u:%u.%u\", &em, &es, &ems) != 3) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tctx->end = (3600*eh + 60*em + es)*1000 + ems;\n\t\t\t//skip 6 commas\n\t\t\tstart_p = end_p+1;\n\t\t\tnb_c=6;\n\t\t} else {\n\t\t\tstart_p = szLine;\n\t\t\tnb_c=8;\n\t\t}\n\n\t\twhile (nb_c) {\n\t\t\tend_p = strchr(start_p, ',');\n\t\t\tif (!end_p) break;\n\t\t\tstart_p = end_p+1;\n\t\t\tnb_c--;\n\t\t}\n\t\tif (nb_c) continue;\n\n\t\tif (ctx->start > ctx->end) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] corrupted SSA frame (line %d) - ends (at %u ms) before start of current frame (%u ms) - skipping\\n\", line, ctx->end, ctx->start));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*make stream start at 0 by inserting a fake AU*/\n\t\tif (ctx->first_samp && (ctx->start > 0)) {\n\t\t\ttxtin_process_send_text_sample(ctx, ctx->samp, 0, (u32) ctx->start, GF_TRUE);\n\t\t\tctx->first_samp = GF_FALSE;\n\t\t}\n\t\telse if (ctx->prev_end && (ctx->start != ctx->prev_end) && (ctx->state<=2)) {\n\t\t\tGF_TextSample * empty_samp = gf_isom_new_text_sample();\n\t\t\ttxtin_process_send_text_sample(ctx, empty_samp, ctx->prev_end, (u32) (ctx->start - ctx->prev_end), GF_TRUE );\n\t\t\tgf_isom_delete_text_sample(empty_samp);\n\t\t}\n\n\t\tu32 char_len=0;\n\t\tBool set_start_char=GF_FALSE, set_end_char=GF_FALSE;\n\t\tctx->style.startCharOffset = ctx->style.endCharOffset = 0;\n\t\tgf_isom_text_reset(ctx->samp);\n\n\t\tmemset(szText, 0, 2048);\n\t\ti=j=0;\n\t\twhile (1) {\n\t\t\tchar c = start_p[i];\n\t\t\tif (c == 0) {\n\t\t\t\tszText[j] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (c=='\\\\') {\n\t\t\t\tif ((start_p[i+1] == 'N') || (start_p[i+1] == 'n')) {\n\t\t\t\t\tszText[j] = 0;\n\t\t\t\t\tparse_srt_line(ctx, szText, &char_len, &set_start_char, &set_end_char);\n\n\t\t\t\t\tj=0;\n\t\t\t\t\ti+=2;\n\t\t\t\t\tmemset(szText, 0, 2048);\n\t\t\t\t\tgf_isom_text_add_text(ctx->samp, \"\\n\", 1);\n\t\t\t\t\tchar_len += 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (c=='{') {\n\t\t\t\tif (start_p[i+1] == '\\\\') {\n\t\t\t\t\tu32 style = 0;\n\t\t\t\t\tu32 color=0;\n\t\t\t\t\tBool is_end = 0;\n\t\t\t\t\tif (start_p[i+2] == 'i') style = 1;\n\t\t\t\t\telse if (start_p[i+2] == 'b') style = 2;\n\t\t\t\t\telse if (start_p[i+2] == 'u') style = 3;\n\t\t\t\t\telse if (start_p[i+2] == 'c') {\n\t\t\t\t\t\tif ((start_p[i+3] == '&') && (strlen(start_p+i+4)>8)) {\n\t\t\t\t\t\t\tchar *col_p = start_p + i+5;\n\t\t\t\t\t\t\tstyle = 4;\n\t\t\t\t\t\t\tchar szT[3];\n\t\t\t\t\t\t\tu32 r, g, b;\n\t\t\t\t\t\t\tszT[2]=0;\n\t\t\t\t\t\t\tszT[0]=col_p[0];\n\t\t\t\t\t\t\tszT[1]=col_p[1];\n\t\t\t\t\t\t\tsscanf(szT, \"%x\", &g);\n\t\t\t\t\t\t\tszT[0]=col_p[2];\n\t\t\t\t\t\t\tszT[1]=col_p[3];\n\t\t\t\t\t\t\tsscanf(szT, \"%x\", &b);\n\t\t\t\t\t\t\tszT[0]=col_p[4];\n\t\t\t\t\t\t\tszT[1]=col_p[5];\n\t\t\t\t\t\t\tsscanf(szT, \"%x\", &r);\n\t\t\t\t\t\t\tcolor = GF_COL_ARGB(0xFF, r, g, b);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (start_p[i+3] == '}') {\n\t\t\t\t\t\t\tis_end=GF_TRUE;\n\t\t\t\t\t\t\tstyle = 4;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (start_p[i+2] == 's') style = 5;\n\n\t\t\t\t\tif (start_p[i+3] == '0') is_end=GF_TRUE;\n\t\t\t\t\twhile (start_p[i] && (start_p[i]!='}')) i++;\n\t\t\t\t\ti++;\n\n\t\t\t\t\tif (style==1) {\n\t\t\t\t\t\tif (is_end) {strcat(szText, \"</i>\"); j+=4;}\n\t\t\t\t\t\telse {strcat(szText, \"<i>\"); j+=3;}\n\t\t\t\t\t} else if (style==2) {\n\t\t\t\t\t\tif (is_end) {strcat(szText, \"</b>\"); j+=4;}\n\t\t\t\t\t\telse {strcat(szText, \"<b>\"); j+=3;}\n\t\t\t\t\t} else if (style==3) {\n\t\t\t\t\t\tif (is_end) {strcat(szText, \"</u>\"); j+=4;}\n\t\t\t\t\t\telse {strcat(szText, \"<u>\"); j+=3;}\n\t\t\t\t\t} else if (style==4) {\n\t\t\t\t\t\tif (is_end) {strcat(szText, \"</font>\"); j+=7;}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tchar szFont[100];\n\t\t\t\t\t\t\tsprintf(szFont, \"<font color=\\\"0x%X\\\">\", color);\n\t\t\t\t\t\t\tstrcat(szText, szFont);\n\t\t\t\t\t\t\tj+=(u32) strlen(szFont);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (style==5) {\n\t\t\t\t\t\tif (is_end) {strcat(szText, \"</strike>\"); j+=9;}\n\t\t\t\t\t\telse {strcat(szText, \"<strike>\"); j+=8;}\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tszText[j] = c;\n\t\t\tj++;\n\t\t\ti++;\n\t\t}\n\t\tif (szText[0])\n\t\t\tparse_srt_line(ctx, szText, &char_len, &set_start_char, &set_end_char);\n\n\t\ttxtin_process_send_text_sample(ctx, ctx->samp,  ctx->start, (u32) (ctx->end -  ctx->start), GF_TRUE);\n\t\tctx->prev_end = ctx->end;\n\n\t\tgf_filter_pid_set_info(ctx->opid, GF_PROP_PID_DOWN_BYTES, &PROP_LONGUINT( gf_ftell(ctx->src)) );\n\n\t\tif (gf_filter_pid_would_block(ctx->opid))\n\t\t\treturn GF_OK;\n\t}\n\t/*final flush*/\n\tif (ctx->end && !ctx->noflush) {\n\t\tsamp = gf_isom_new_text_sample();\n\t\ttxtin_process_send_text_sample(ctx, samp, ctx->end, 0, GF_TRUE);\n\t\tgf_isom_delete_text_sample(samp);\n\t}\n\n\tgf_filter_pid_set_info_str( ctx->opid, \"ttxt:last_dur\", &PROP_UINT(0) );\n\n\treturn GF_EOS;\n}\n\n\n\nstatic u32 ttxt_get_color(char *val)\n{\n\tu32 r, g, b, a, res;\n\tr = g = b = a = 0;\n\tif (sscanf(val, \"%x %x %x %x\", &r, &g, &b, &a) != 4) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] Warning: color badly formatted %s\\n\", val));\n\t}\n\tres = (a&0xFF);\n\tres<<=8;\n\tres |= (r&0xFF);\n\tres<<=8;\n\tres |= (g&0xFF);\n\tres<<=8;\n\tres |= (b&0xFF);\n\treturn res;\n}\n\nstatic void ttxt_parse_text_box(GF_XMLNode *n, GF_BoxRecord *box)\n{\n\tu32 i=0;\n\tGF_XMLAttribute *att;\n\tmemset(box, 0, sizeof(GF_BoxRecord));\n\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(n->attributes, &i))) {\n\t\tif (!stricmp(att->name, \"top\")) box->top = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"bottom\")) box->bottom = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"left\")) box->left = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"right\")) box->right = atoi(att->value);\n\t}\n}\n\nstatic void ttxt_parse_text_style(GF_TXTIn *ctx, GF_XMLNode *n, GF_StyleRecord *style)\n{\n\tu32 i=0;\n\tGF_XMLAttribute *att;\n\tmemset(style, 0, sizeof(GF_StyleRecord));\n\tstyle->fontID = 1;\n\tstyle->font_size = ctx->fontsize ;\n\tstyle->text_color = 0xFFFFFFFF;\n\n\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(n->attributes, &i))) {\n\t\tif (!stricmp(att->name, \"fromChar\")) style->startCharOffset = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"toChar\")) style->endCharOffset = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"fontID\")) style->fontID = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"fontSize\")) style->font_size = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"color\")) style->text_color = ttxt_get_color(att->value);\n\t\telse if (!stricmp(att->name, \"styles\")) {\n\t\t\tif (strstr(att->value, \"Bold\")) style->style_flags |= GF_TXT_STYLE_BOLD;\n\t\t\tif (strstr(att->value, \"Italic\")) style->style_flags |= GF_TXT_STYLE_ITALIC;\n\t\t\tif (strstr(att->value, \"Underlined\")) style->style_flags |= GF_TXT_STYLE_UNDERLINED;\n\t\t\tif (strstr(att->value, \"Strikethrough\")) style->style_flags |= GF_TXT_STYLE_STRIKETHROUGH;\n\t\t}\n\t}\n}\n\nstatic GF_Err txtin_setup_ttxt(GF_Filter *filter, GF_TXTIn *ctx)\n{\n\tGF_Err e;\n\tu32 j, k, ID, OCR_ES_ID;\n\tu64 file_size;\n\tGF_XMLNode *root, *ext;\n\tGF_PropertyValue *dcd;\n\n\tctx->parser = gf_xml_dom_new();\n\te = gf_xml_dom_parse(ctx->parser, ctx->file_name, ttxt_dom_progress, ctx);\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Error parsing TTXT file: Line %d - %s\\n\", gf_xml_dom_get_line(ctx->parser), gf_xml_dom_get_error(ctx->parser)));\n\t\treturn e;\n\t}\n\troot = gf_xml_dom_get_root(ctx->parser);\n\tif (!root) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Missing root \\\"TextStream\\\" element\"));\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\tif (strcmp(root->name, \"TextStream\")) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Invalid Timed Text file - expecting \\\"TextStream\\\" got %s\", root->name));\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tfile_size = ctx->end;\n\tctx->end = 0;\n\n\t/*setup track in 3GP format directly (no ES desc)*/\n\tif (!ctx->timescale) ctx->timescale = 1000;\n\tOCR_ES_ID = ID = 0;\n\n\tif (!ctx->opid) ctx->opid = gf_filter_pid_new(filter);\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_TEXT) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, &PROP_UINT(GF_CODECID_TX3G) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, &PROP_UINT(ctx->timescale) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DOWN_SIZE, &PROP_LONGUINT(file_size) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_UNFRAMED, NULL);\n\n\tif (!ID) ID = 1;\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ID, &PROP_UINT(ID) );\n\tif (OCR_ES_ID) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CLOCK_ID, &PROP_UINT(OCR_ES_ID) );\n\n\tctx->nb_children = gf_list_count(root->content);\n\n\tctx->cur_child_idx = 0;\n\tfor (ctx->cur_child_idx=0; ctx->cur_child_idx < ctx->nb_children; ctx->cur_child_idx++) {\n\t\tGF_XMLNode *node = (GF_XMLNode*) gf_list_get(root->content, ctx->cur_child_idx);\n\n\t\tif (node->type) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(node->name, \"TextStreamHeader\")) {\n\t\t\tGF_XMLNode *sdesc;\n\t\t\ts32 w, h, tx, ty, layer;\n\t\t\tu32 tref_id;\n\t\t\tGF_XMLAttribute *att;\n\t\t\tw = ctx->width;\n\t\t\th = ctx->height;\n\t\t\ttx = ctx->txtx;\n\t\t\tty = ctx->txty;\n\t\t\tlayer = ctx->zorder;\n\t\t\ttref_id = 0;\n\n\t\t\tj=0;\n\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(node->attributes, &j))) {\n\t\t\t\tif (!strcmp(att->name, \"width\")) w = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"height\")) h = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"layer\")) layer = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"translation_x\")) tx = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"translation_y\")) ty = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"trefID\")) tref_id = atoi(att->value);\n\t\t\t}\n\n\t\t\tif (tref_id) {\n\t\t\t\tgf_filter_pid_set_property_str(ctx->opid, \"tref:chap\", &PROP_UINT(tref_id) );\n\t\t\t}\n\n\t\t\tif (w) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_WIDTH, &PROP_UINT(w) );\n\t\t\tif (h) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_HEIGHT, &PROP_UINT(h) );\n\t\t\tif (tx) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TRANS_X, &PROP_UINT(tx) );\n\t\t\tif (ty) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TRANS_X, &PROP_UINT(ty) );\n\t\t\tif (layer) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ZORDER, &PROP_SINT(ctx->zorder) );\n\t\t\tif (ctx->lang) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_LANGUAGE, &PROP_STRING( ctx->lang) );\n\n\t\t\tj=0;\n\t\t\twhile ( (sdesc=(GF_XMLNode*)gf_list_enum(node->content, &j))) {\n\t\t\t\tif (sdesc->type) continue;\n\n\t\t\t\tif (!strcmp(sdesc->name, \"TextSampleDescription\")) {\n\t\t\t\t\tGF_TextSampleDescriptor td;\n\t\t\t\t\tmemset(&td, 0, sizeof(GF_TextSampleDescriptor));\n\t\t\t\t\ttd.tag = GF_ODF_TEXT_CFG_TAG;\n\t\t\t\t\ttd.vert_justif = (s8) -1;\n\t\t\t\t\ttd.default_style.fontID = 1;\n\t\t\t\t\ttd.default_style.font_size = ctx->fontsize;\n\n\t\t\t\t\tk=0;\n\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(sdesc->attributes, &k))) {\n\t\t\t\t\t\tif (!strcmp(att->name, \"horizontalJustification\")) {\n\t\t\t\t\t\t\tif (!stricmp(att->value, \"center\")) td.horiz_justif = 1;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"right\")) td.horiz_justif = (s8) -1;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"left\")) td.horiz_justif = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!strcmp(att->name, \"verticalJustification\")) {\n\t\t\t\t\t\t\tif (!stricmp(att->value, \"center\")) td.vert_justif = 1;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"bottom\")) td.vert_justif = (s8) -1;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"top\")) td.vert_justif = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!strcmp(att->name, \"backColor\")) td.back_color = ttxt_get_color(att->value);\n\t\t\t\t\t\telse if (!strcmp(att->name, \"verticalText\") && !stricmp(att->value, \"yes\") ) td.displayFlags |= GF_TXT_VERTICAL;\n\t\t\t\t\t\telse if (!strcmp(att->name, \"fillTextRegion\") && !stricmp(att->value, \"yes\") ) td.displayFlags |= GF_TXT_FILL_REGION;\n\t\t\t\t\t\telse if (!strcmp(att->name, \"continuousKaraoke\") && !stricmp(att->value, \"yes\") ) td.displayFlags |= GF_TXT_KARAOKE;\n\t\t\t\t\t\telse if (!strcmp(att->name, \"scroll\")) {\n\t\t\t\t\t\t\tif (!stricmp(att->value, \"inout\")) td.displayFlags |= GF_TXT_SCROLL_IN | GF_TXT_SCROLL_OUT;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"in\")) td.displayFlags |= GF_TXT_SCROLL_IN;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"out\")) td.displayFlags |= GF_TXT_SCROLL_OUT;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!strcmp(att->name, \"scrollMode\")) {\n\t\t\t\t\t\t\tu32 scroll_mode = GF_TXT_SCROLL_CREDITS;\n\t\t\t\t\t\t\tif (!stricmp(att->value, \"Credits\")) scroll_mode = GF_TXT_SCROLL_CREDITS;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"Marquee\")) scroll_mode = GF_TXT_SCROLL_MARQUEE;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"Right\")) scroll_mode = GF_TXT_SCROLL_RIGHT;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"Down\")) scroll_mode = GF_TXT_SCROLL_DOWN;\n\t\t\t\t\t\t\ttd.displayFlags |= ((scroll_mode<<7) & GF_TXT_SCROLL_DIRECTION);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tk=0;\n\t\t\t\t\twhile ( (ext=(GF_XMLNode*)gf_list_enum(sdesc->content, &k))) {\n\t\t\t\t\t\tif (ext->type) continue;\n\t\t\t\t\t\tif (!strcmp(ext->name, \"TextBox\")) ttxt_parse_text_box(ext, &td.default_pos);\n\t\t\t\t\t\telse if (!strcmp(ext->name, \"Style\")) ttxt_parse_text_style(ctx, ext, &td.default_style);\n\t\t\t\t\t\telse if (!strcmp(ext->name, \"FontTable\")) {\n\t\t\t\t\t\t\tGF_XMLNode *ftable;\n\t\t\t\t\t\t\tu32 z=0;\n\t\t\t\t\t\t\twhile ( (ftable=(GF_XMLNode*)gf_list_enum(ext->content, &z))) {\n\t\t\t\t\t\t\t\tu32 m;\n\t\t\t\t\t\t\t\tif (ftable->type || strcmp(ftable->name, \"FontTableEntry\")) continue;\n\t\t\t\t\t\t\t\ttd.font_count += 1;\n\t\t\t\t\t\t\t\ttd.fonts = (GF_FontRecord*)gf_realloc(td.fonts, sizeof(GF_FontRecord)*td.font_count);\n\t\t\t\t\t\t\t\tm=0;\n\t\t\t\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(ftable->attributes, &m))) {\n\t\t\t\t\t\t\t\t\tif (!stricmp(att->name, \"fontID\")) td.fonts[td.font_count-1].fontID = atoi(att->value);\n\t\t\t\t\t\t\t\t\telse if (!stricmp(att->name, \"fontName\")) td.fonts[td.font_count-1].fontName = gf_strdup(att->value);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ctx->nodefbox) {\n\t\t\t\t\t\ttd.default_pos.top = td.default_pos.left = td.default_pos.right = td.default_pos.bottom = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ((td.default_pos.bottom==td.default_pos.top) || (td.default_pos.right==td.default_pos.left)) {\n\t\t\t\t\t\t\ttd.default_pos.top = td.default_pos.left = 0;\n\t\t\t\t\t\t\ttd.default_pos.right = w;\n\t\t\t\t\t\t\ttd.default_pos.bottom = h;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!td.fonts) {\n\t\t\t\t\t\ttd.font_count = 1;\n\t\t\t\t\t\ttd.fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord));\n\t\t\t\t\t\ttd.fonts[0].fontID = 1;\n\t\t\t\t\t\ttd.fonts[0].fontName = gf_strdup(\"Serif\");\n\t\t\t\t\t}\n\t\t\t\t\tGF_SAFEALLOC(dcd, GF_PropertyValue);\n\t\t\t\t\tif (dcd) {\n\t\t\t\t\t\tdcd->type = GF_PROP_DATA;\n\n\t\t\t\t\t\tgf_odf_tx3g_write(&td, &dcd->value.data.ptr, &dcd->value.data.size);\n\t\t\t\t\t\tif (!ctx->text_descs) ctx->text_descs = gf_list_new();\n\t\t\t\t\t\tgf_list_add(ctx->text_descs, dcd);\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (k=0; k<td.font_count; k++) gf_free(td.fonts[k].fontName);\n\t\t\t\t\tgf_free(td.fonts);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!ctx->text_descs) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Invalid Timed Text file - text stream header not found or empty\\n\"));\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tdcd = gf_list_get(ctx->text_descs, 0);\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, dcd);\n\tctx->last_desc_idx = 1;\n\n\tctx->first_samp = GF_TRUE;\n\tctx->last_sample_empty = GF_FALSE;\n\tctx->last_sample_duration = 0;\n\n\ttxtin_probe_duration(ctx);\n\n\treturn GF_OK;\n}\n\nstatic GF_Err txtin_process_ttxt(GF_Filter *filter, GF_TXTIn *ctx, GF_FilterPacket *ipck)\n{\n\tu32 j, k;\n\tGF_XMLNode *root, *ext;\n\n\tif (!ctx->is_setup) {\n\t\tctx->is_setup = GF_TRUE;\n\t\treturn txtin_setup_ttxt(filter, ctx);\n\t}\n\tif (!ctx->opid) return GF_NON_COMPLIANT_BITSTREAM;\n\tif (!ctx->playstate) return GF_OK;\n\telse if (ctx->playstate==2) return GF_EOS;\n\n\tif (ctx->seek_state==1) {\n\t\tctx->seek_state = 2;\n\t\tctx->cur_child_idx = 0;\n\t}\n\troot = gf_xml_dom_get_root(ctx->parser);\n\n\tfor (; ctx->cur_child_idx < ctx->nb_children; ctx->cur_child_idx++) {\n\t\tGF_TextSample * samp;\n\t\tu32 ts, descIndex;\n\t\tBool has_text = GF_FALSE;\n\t\tGF_XMLAttribute *att;\n\t\tGF_XMLNode *node = (GF_XMLNode*) gf_list_get(root->content, ctx->cur_child_idx);\n\n\t\tif (node->type) {\n\t\t\tcontinue;\n\t\t}\n\t\t/*sample text*/\n\t\telse if (strcmp(node->name, \"TextSample\")) continue;\n\n\t\tsamp = gf_isom_new_text_sample();\n\t\tts = 0;\n\t\tdescIndex = 1;\n\t\tctx->last_sample_empty = GF_TRUE;\n\n\t\tj=0;\n\t\twhile ( (att=(GF_XMLAttribute*)gf_list_enum(node->attributes, &j))) {\n\t\t\tif (!strcmp(att->name, \"sampleTime\")) {\n\t\t\t\tu32 h, m, s, ms;\n\t\t\t\tif (sscanf(att->value, \"%u:%u:%u.%u\", &h, &m, &s, &ms) == 4) {\n\t\t\t\t\tts = (h*3600 + m*60 + s)*1000 + ms;\n\t\t\t\t} else {\n\t\t\t\t\tts = (u32) (atof(att->value) * 1000);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!strcmp(att->name, \"sampleDescriptionIndex\")) descIndex = atoi(att->value);\n\t\t\telse if (!strcmp(att->name, \"text\")) {\n\t\t\t\tu32 len;\n\t\t\t\tchar *str = ttxt_parse_string(att->value, GF_TRUE);\n\t\t\t\tlen = (u32) strlen(str);\n\t\t\t\tgf_isom_text_add_text(samp, str, len);\n\t\t\t\tctx->last_sample_empty = len ? GF_FALSE : GF_TRUE;\n\t\t\t\thas_text = GF_TRUE;\n\t\t\t}\n\t\t\telse if (!strcmp(att->name, \"scrollDelay\")) gf_isom_text_set_scroll_delay(samp, (u32) (1000*atoi(att->value)));\n\t\t\telse if (!strcmp(att->name, \"highlightColor\")) gf_isom_text_set_highlight_color(samp, ttxt_get_color(att->value));\n\t\t\telse if (!strcmp(att->name, \"wrap\") && !strcmp(att->value, \"Automatic\")) gf_isom_text_set_wrap(samp, 0x01);\n\t\t}\n\n\t\t/*get all modifiers*/\n\t\tj=0;\n\t\twhile ( (ext=(GF_XMLNode*)gf_list_enum(node->content, &j))) {\n\t\t\tif (!has_text && (ext->type==GF_XML_TEXT_TYPE)) {\n\t\t\t\tu32 len;\n\t\t\t\tchar *str = ttxt_parse_string(ext->name, GF_FALSE);\n\t\t\t\tlen = (u32) strlen(str);\n\t\t\t\tgf_isom_text_add_text(samp, str, len);\n\t\t\t\tctx->last_sample_empty = len ? GF_FALSE : GF_TRUE;\n\t\t\t\thas_text = GF_TRUE;\n\t\t\t}\n\t\t\tif (ext->type) continue;\n\n\t\t\tif (!stricmp(ext->name, \"Style\")) {\n\t\t\t\tGF_StyleRecord r;\n\t\t\t\tttxt_parse_text_style(ctx, ext, &r);\n\t\t\t\tgf_isom_text_add_style(samp, &r);\n\t\t\t}\n\t\t\telse if (!stricmp(ext->name, \"TextBox\")) {\n\t\t\t\tGF_BoxRecord r;\n\t\t\t\tttxt_parse_text_box(ext, &r);\n\t\t\t\tgf_isom_text_set_box(samp, r.top, r.left, r.bottom, r.right);\n\t\t\t}\n\t\t\telse if (!stricmp(ext->name, \"Highlight\")) {\n\t\t\t\tu16 start, end;\n\t\t\t\tstart = end = 0;\n\t\t\t\tk=0;\n\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(ext->attributes, &k))) {\n\t\t\t\t\tif (!strcmp(att->name, \"fromChar\")) start = atoi(att->value);\n\t\t\t\t\telse if (!strcmp(att->name, \"toChar\")) end = atoi(att->value);\n\t\t\t\t}\n\t\t\t\tgf_isom_text_add_highlight(samp, start, end);\n\t\t\t}\n\t\t\telse if (!stricmp(ext->name, \"Blinking\")) {\n\t\t\t\tu16 start, end;\n\t\t\t\tstart = end = 0;\n\t\t\t\tk=0;\n\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(ext->attributes, &k))) {\n\t\t\t\t\tif (!strcmp(att->name, \"fromChar\")) start = atoi(att->value);\n\t\t\t\t\telse if (!strcmp(att->name, \"toChar\")) end = atoi(att->value);\n\t\t\t\t}\n\t\t\t\tgf_isom_text_add_blink(samp, start, end);\n\t\t\t}\n\t\t\telse if (!stricmp(ext->name, \"HyperLink\")) {\n\t\t\t\tu16 start, end;\n\t\t\t\tchar *url, *url_tt;\n\t\t\t\tstart = end = 0;\n\t\t\t\turl = url_tt = NULL;\n\t\t\t\tk=0;\n\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(ext->attributes, &k))) {\n\t\t\t\t\tif (!strcmp(att->name, \"fromChar\")) start = atoi(att->value);\n\t\t\t\t\telse if (!strcmp(att->name, \"toChar\")) end = atoi(att->value);\n\t\t\t\t\telse if (!strcmp(att->name, \"URL\")) url = gf_strdup(att->value);\n\t\t\t\t\telse if (!strcmp(att->name, \"URLToolTip\")) url_tt = gf_strdup(att->value);\n\t\t\t\t}\n\t\t\t\tgf_isom_text_add_hyperlink(samp, url, url_tt, start, end);\n\t\t\t\tif (url) gf_free(url);\n\t\t\t\tif (url_tt) gf_free(url_tt);\n\t\t\t}\n\t\t\telse if (!stricmp(ext->name, \"Karaoke\")) {\n\t\t\t\tu32 startTime;\n\t\t\t\tGF_XMLNode *krok;\n\t\t\t\tstartTime = 0;\n\t\t\t\tk=0;\n\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(ext->attributes, &k))) {\n\t\t\t\t\tif (!strcmp(att->name, \"startTime\")) startTime = (u32) (1000*atof(att->value));\n\t\t\t\t}\n\t\t\t\tgf_isom_text_add_karaoke(samp, startTime);\n\t\t\t\tk=0;\n\t\t\t\twhile ( (krok=(GF_XMLNode*)gf_list_enum(ext->content, &k))) {\n\t\t\t\t\tu16 start, end;\n\t\t\t\t\tu32 endTime, m;\n\t\t\t\t\tif (krok->type) continue;\n\t\t\t\t\tif (strcmp(krok->name, \"KaraokeRange\")) continue;\n\t\t\t\t\tstart = end = 0;\n\t\t\t\t\tendTime = 0;\n\t\t\t\t\tm=0;\n\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(krok->attributes, &m))) {\n\t\t\t\t\t\tif (!strcmp(att->name, \"fromChar\")) start = atoi(att->value);\n\t\t\t\t\t\telse if (!strcmp(att->name, \"toChar\")) end = atoi(att->value);\n\t\t\t\t\t\telse if (!strcmp(att->name, \"endTime\")) endTime = (u32) (1000*atof(att->value));\n\t\t\t\t\t}\n\t\t\t\t\tgf_isom_text_set_karaoke_segment(samp, endTime, start, end);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!descIndex) descIndex = 1;\n\t\tif (descIndex != ctx->last_desc_idx) {\n\t\t\tGF_PropertyValue *dcd;\n\t\t\tctx->last_desc_idx = descIndex;\n\t\t\tdcd = gf_list_get(ctx->text_descs, descIndex-1);\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, dcd);\n\t\t}\n\n\t\t/*in MP4 we must start at T=0, so add an empty sample*/\n\t\tif (ts && ctx->first_samp) {\n\t\t\tGF_TextSample * firstsamp = gf_isom_new_text_sample();\n\t\t\ttxtin_process_send_text_sample(ctx, firstsamp, 0, 0, GF_TRUE);\n\t\t\tgf_isom_delete_text_sample(firstsamp);\n\t\t}\n\t\tctx->first_samp = GF_FALSE;\n\n\t\tu64 next_sample_start=0;\n\t\tfor (j=ctx->cur_child_idx+1; j < ctx->nb_children; j++) {\n\t\t\tnode = (GF_XMLNode*) gf_list_get(root->content, j);\n\n\t\t\tif (node->type) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*sample text*/\n\t\t\telse if (strcmp(node->name, \"TextSample\")) continue;\n\n\t\t\tj=0;\n\t\t\twhile ( (att=(GF_XMLAttribute*)gf_list_enum(node->attributes, &j))) {\n\t\t\t\tif (!strcmp(att->name, \"sampleTime\")) {\n\t\t\t\t\tu32 h, m, s, ms;\n\t\t\t\t\tif (sscanf(att->value, \"%u:%u:%u.%u\", &h, &m, &s, &ms) == 4) {\n\t\t\t\t\t\tnext_sample_start = (h*3600 + m*60 + s)*1000 + ms;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnext_sample_start = (u32) (atof(att->value) * 1000);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (next_sample_start>=ts) next_sample_start -= ts;\n\n\t\ttxtin_process_send_text_sample(ctx, samp, ts, (u32) next_sample_start, GF_TRUE);\n\n\t\tgf_isom_delete_text_sample(samp);\n\n\t\tif (ctx->last_sample_empty) {\n\t\t\tctx->last_sample_duration = ts - ctx->last_sample_duration;\n\t\t} else {\n\t\t\tctx->last_sample_duration = ts;\n\t\t}\n\n\t\tif (gf_filter_pid_would_block(ctx->opid)) {\n\t\t\tctx->cur_child_idx++;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\tif (ctx->last_sample_empty) {\n\t\t//this is a bit ugly, in regular streaming mode we don't want to remove empty samples\n\t\t//howvere the last one can be removed, adjusting the duration of the previous one.\n\t\t//doing this here is problematic if the loader is sent a new ttxt file, we would have a cue termination sample\n\t\t//we therefore share that info through pid, and let the final user (muxer& co) decide what to do\n\t\tgf_filter_pid_set_info_str( ctx->opid, \"ttxt:rem_last\", &PROP_BOOL(GF_TRUE) );\n\t\tgf_filter_pid_set_info_str( ctx->opid, \"ttxt:last_dur\", &PROP_UINT((u32) ctx->last_sample_duration) );\n\t}\n\n\treturn GF_EOS;\n}\n\n\nstatic u32 tx3g_get_color(char *value)\n{\n\tu32 r, g, b, a;\n\tu32 res, v;\n\tr = g = b = a = 0;\n\tif (sscanf(value, \"%u%%, %u%%, %u%%, %u%%\", &r, &g, &b, &a) != 4) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"Warning: color badly formatted\\n\"));\n\t}\n\tv = (u32) (a*255/100);\n\tres = (v&0xFF);\n\tres<<=8;\n\tv = (u32) (r*255/100);\n\tres |= (v&0xFF);\n\tres<<=8;\n\tv = (u32) (g*255/100);\n\tres |= (v&0xFF);\n\tres<<=8;\n\tv = (u32) (b*255/100);\n\tres |= (v&0xFF);\n\treturn res;\n}\n\nstatic void tx3g_parse_text_box(GF_XMLNode *n, GF_BoxRecord *box)\n{\n\tu32 i=0;\n\tGF_XMLAttribute *att;\n\tmemset(box, 0, sizeof(GF_BoxRecord));\n\twhile ((att=(GF_XMLAttribute *)gf_list_enum(n->attributes, &i))) {\n\t\tif (!stricmp(att->name, \"x\")) box->left = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"y\")) box->top = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"height\")) box->bottom = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"width\")) box->right = atoi(att->value);\n\t}\n}\n\ntypedef struct\n{\n\tu32 id;\n\tu32 pos;\n} Marker;\n\n#define GET_MARKER_POS(_val, __isend) \\\n\t{\t\\\n\t\tu32 i, __m = atoi(att->value);\t\\\n\t\t_val = 0;\t\\\n\t\tfor (i=0; i<nb_marks; i++) { if (__m==marks[i].id) { _val = marks[i].pos; /*if (__isend) _val--; */break; } }\t \\\n\t}\n\n\nstatic GF_Err txtin_texml_setup(GF_Filter *filter, GF_TXTIn *ctx)\n{\n\tGF_Err e;\n\tu32 ID, OCR_ES_ID, i;\n\tu64 file_size;\n\tGF_XMLAttribute *att;\n\tGF_XMLNode *root;\n\n\tctx->parser = gf_xml_dom_new();\n\te = gf_xml_dom_parse(ctx->parser, ctx->file_name, ttxt_dom_progress, ctx);\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Error parsing TeXML file: Line %d - %s\", gf_xml_dom_get_line(ctx->parser), gf_xml_dom_get_error(ctx->parser) ));\n\t\tgf_xml_dom_del(ctx->parser);\n\t\tctx->parser = NULL;\n\t\treturn e;\n\t}\n\n\troot = gf_xml_dom_get_root(ctx->parser);\n\n\tif (strcmp(root->name, \"text3GTrack\")) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Invalid QT TeXML file - expecting root \\\"text3GTrack\\\" got \\\"%s\\\"\", root->name));\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tfile_size = ctx->end;\n\tctx->txml_timescale = 600;\n\n\ti=0;\n\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(root->attributes, &i))) {\n\t\tif (!strcmp(att->name, \"trackWidth\")) ctx->width = atoi(att->value);\n\t\telse if (!strcmp(att->name, \"trackHeight\")) ctx->height = atoi(att->value);\n\t\telse if (!strcmp(att->name, \"layer\")) ctx->zorder = atoi(att->value);\n\t\telse if (!strcmp(att->name, \"timeScale\")) ctx->txml_timescale = atoi(att->value);\n\t\telse if (!strcmp(att->name, \"transform\")) {\n\t\t\tFloat fx, fy;\n\t\t\tsscanf(att->value, \"translate(%f,%f)\", &fx, &fy);\n\t\t\tctx->txtx = (u32) fx;\n\t\t\tctx->txty = (u32) fy;\n\t\t}\n\t}\n\n\t/*setup track in 3GP format directly (no ES desc)*/\n\tOCR_ES_ID = ID = 0;\n\tif (!ctx->timescale) ctx->timescale = 1000;\n\n\tif (!ctx->opid) ctx->opid = gf_filter_pid_new(filter);\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_TEXT) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, &PROP_UINT(GF_ISOM_SUBTYPE_TX3G) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, &PROP_UINT(ctx->timescale) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DOWN_SIZE, &PROP_LONGUINT(file_size) );\n\n\n\tif (!ID) ID = 1;\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ID, &PROP_UINT(ID) );\n\tif (OCR_ES_ID) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CLOCK_ID, &PROP_UINT(OCR_ES_ID) );\n\tif (ctx->width) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_WIDTH, &PROP_UINT(ctx->width) );\n\tif (ctx->height) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_HEIGHT, &PROP_UINT(ctx->height) );\n\tif (ctx->zorder) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ZORDER, &PROP_SINT(ctx->zorder) );\n\tif (ctx->lang) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_LANGUAGE, &PROP_STRING( ctx->lang) );\n\n\n\tctx->nb_children = gf_list_count(root->content);\n\tctx->cur_child_idx = 0;\n\ttxtin_probe_duration(ctx);\n\n\treturn GF_OK;\n}\n\nstatic GF_Err txtin_process_texml(GF_Filter *filter, GF_TXTIn *ctx, GF_FilterPacket *ipck)\n{\n\tu32 j, k;\n\tGF_StyleRecord styles[50];\n\tMarker marks[50];\n\tGF_XMLAttribute *att;\n\tGF_XMLNode *root;\n\tBool probe_first_desc_only = GF_FALSE;\n\n\tif (!ctx->is_setup) {\n\t\tGF_Err e;\n\n\t\tctx->is_setup = GF_TRUE;\n\t\te = txtin_texml_setup(filter, ctx);\n\t\tif (e) return e;\n\t\tprobe_first_desc_only = GF_TRUE;\n\t}\n\tif (!ctx->opid) return GF_NON_COMPLIANT_BITSTREAM;\n\tif (!ctx->playstate && !probe_first_desc_only) return GF_OK;\n\telse if (ctx->playstate==2) return GF_EOS;\n\n\tif (ctx->seek_state==1) {\n\t\tctx->seek_state = 2;\n\t\tctx->cur_child_idx = 0;\n\t\tctx->start = 0;\n\t}\n\n\troot = gf_xml_dom_get_root(ctx->parser);\n\n\tfor (; ctx->cur_child_idx < ctx->nb_children; ctx->cur_child_idx++) {\n\t\tGF_XMLNode *node, *desc;\n\t\tGF_TextSampleDescriptor td;\n\t\tGF_TextSample * samp = NULL;\n\t\tu64 duration;\n\t\tu32 nb_styles, nb_marks;\n\t\tBool isRAP, same_style, same_box;\n\n\t\tif (probe_first_desc_only && ctx->text_descs && gf_list_count(ctx->text_descs))\n\t\t\treturn GF_OK;\n\n\t\tmemset(&td, 0, sizeof(GF_TextSampleDescriptor));\n\t\tnode = (GF_XMLNode*)gf_list_get(root->content, ctx->cur_child_idx);\n\t\tif (node->type) continue;\n\t\tif (strcmp(node->name, \"sample\")) continue;\n\n\t\tisRAP = GF_TRUE;\n\t\tduration = 1000;\n\t\tj=0;\n\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(node->attributes, &j))) {\n\t\t\tif (!strcmp(att->name, \"duration\")) duration = atoi(att->value);\n\t\t\telse if (!strcmp(att->name, \"keyframe\")) isRAP = (!stricmp(att->value, \"true\") ? GF_TRUE : GF_FALSE);\n\t\t}\n\t\tnb_styles = 0;\n\t\tnb_marks = 0;\n\t\tsame_style = same_box = GF_FALSE;\n\t\tj=0;\n\t\twhile ((desc=(GF_XMLNode*)gf_list_enum(node->content, &j))) {\n\t\t\tif (desc->type) continue;\n\n\t\t\tif (!strcmp(desc->name, \"description\")) {\n\t\t\t\tu8 *dsi;\n\t\t\t\tu32 dsi_len, stsd_idx;\n\t\t\t\tGF_XMLNode *sub;\n\t\t\t\tmemset(&td, 0, sizeof(GF_TextSampleDescriptor));\n\t\t\t\ttd.tag = GF_ODF_TEXT_CFG_TAG;\n\t\t\t\ttd.vert_justif = (s8) -1;\n\t\t\t\ttd.default_style.fontID = 1;\n\t\t\t\ttd.default_style.font_size = ctx->fontsize;\n\n\t\t\t\tk=0;\n\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(desc->attributes, &k))) {\n\t\t\t\t\tif (!strcmp(att->name, \"horizontalJustification\")) {\n\t\t\t\t\t\tif (!stricmp(att->value, \"center\")) td.horiz_justif = 1;\n\t\t\t\t\t\telse if (!stricmp(att->value, \"right\")) td.horiz_justif = (s8) -1;\n\t\t\t\t\t\telse if (!stricmp(att->value, \"left\")) td.horiz_justif = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if (!strcmp(att->name, \"verticalJustification\")) {\n\t\t\t\t\t\tif (!stricmp(att->value, \"center\")) td.vert_justif = 1;\n\t\t\t\t\t\telse if (!stricmp(att->value, \"bottom\")) td.vert_justif = (s8) -1;\n\t\t\t\t\t\telse if (!stricmp(att->value, \"top\")) td.vert_justif = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if (!strcmp(att->name, \"backgroundColor\")) td.back_color = tx3g_get_color(att->value);\n\t\t\t\t\telse if (!strcmp(att->name, \"displayFlags\")) {\n\t\t\t\t\t\tBool rev_scroll = GF_FALSE;\n\t\t\t\t\t\tif (strstr(att->value, \"scroll\")) {\n\t\t\t\t\t\t\tu32 scroll_mode = 0;\n\t\t\t\t\t\t\tif (strstr(att->value, \"scrollIn\")) td.displayFlags |= GF_TXT_SCROLL_IN;\n\t\t\t\t\t\t\tif (strstr(att->value, \"scrollOut\")) td.displayFlags |= GF_TXT_SCROLL_OUT;\n\t\t\t\t\t\t\tif (strstr(att->value, \"reverse\")) rev_scroll = GF_TRUE;\n\t\t\t\t\t\t\tif (strstr(att->value, \"horizontal\")) scroll_mode = rev_scroll ? GF_TXT_SCROLL_RIGHT : GF_TXT_SCROLL_MARQUEE;\n\t\t\t\t\t\t\telse scroll_mode = (rev_scroll ? GF_TXT_SCROLL_DOWN : GF_TXT_SCROLL_CREDITS);\n\t\t\t\t\t\t\ttd.displayFlags |= (scroll_mode<<7) & GF_TXT_SCROLL_DIRECTION;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/*TODO FIXME: check in QT doc !!*/\n\t\t\t\t\t\tif (strstr(att->value, \"writeTextVertically\")) td.displayFlags |= GF_TXT_VERTICAL;\n\t\t\t\t\t\tif (!strcmp(att->name, \"continuousKaraoke\")) td.displayFlags |= GF_TXT_KARAOKE;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tk=0;\n\t\t\t\twhile ((sub=(GF_XMLNode*)gf_list_enum(desc->content, &k))) {\n\t\t\t\t\tif (sub->type) continue;\n\t\t\t\t\tif (!strcmp(sub->name, \"defaultTextBox\")) tx3g_parse_text_box(sub, &td.default_pos);\n\t\t\t\t\telse if (!strcmp(sub->name, \"fontTable\")) {\n\t\t\t\t\t\tGF_XMLNode *ftable;\n\t\t\t\t\t\tu32 m=0;\n\t\t\t\t\t\twhile ((ftable=(GF_XMLNode*)gf_list_enum(sub->content, &m))) {\n\t\t\t\t\t\t\tif (ftable->type) continue;\n\t\t\t\t\t\t\tif (!strcmp(ftable->name, \"font\")) {\n\t\t\t\t\t\t\t\tu32 n=0;\n\t\t\t\t\t\t\t\ttd.font_count += 1;\n\t\t\t\t\t\t\t\ttd.fonts = (GF_FontRecord*)gf_realloc(td.fonts, sizeof(GF_FontRecord)*td.font_count);\n\t\t\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(ftable->attributes, &n))) {\n\t\t\t\t\t\t\t\t\tif (!stricmp(att->name, \"id\")) td.fonts[td.font_count-1].fontID = atoi(att->value);\n\t\t\t\t\t\t\t\t\telse if (!stricmp(att->name, \"name\")) td.fonts[td.font_count-1].fontName = gf_strdup(att->value);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (!strcmp(sub->name, \"sharedStyles\")) {\n\t\t\t\t\t\tGF_XMLNode *style, *ftable;\n\t\t\t\t\t\tu32 m=0;\n\t\t\t\t\t\twhile ((style=(GF_XMLNode*)gf_list_enum(sub->content, &m))) {\n\t\t\t\t\t\t\tif (style->type) continue;\n\t\t\t\t\t\t\tif (!strcmp(style->name, \"style\")) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (style) {\n\t\t\t\t\t\t\tchar *cur;\n\t\t\t\t\t\t\ts32 start=0;\n\t\t\t\t\t\t\tchar css_style[1024], css_val[1024];\n\t\t\t\t\t\t\tmemset(&styles[nb_styles], 0, sizeof(GF_StyleRecord));\n\t\t\t\t\t\t\tm=0;\n\t\t\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(style->attributes, &m))) {\n\t\t\t\t\t\t\t\tif (!strcmp(att->name, \"id\")) styles[nb_styles].startCharOffset = atoi(att->value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tm=0;\n\t\t\t\t\t\t\twhile ( (ftable=(GF_XMLNode*)gf_list_enum(style->content, &m))) {\n\t\t\t\t\t\t\t\tif (ftable->type) break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcur = ftable ? ftable->name : NULL;\n\t\t\t\t\t\t\twhile (cur) {\n\t\t\t\t\t\t\t\tstart = gf_token_get_strip(cur, 0, \"{:\", \" \", css_style, 1024);\n\t\t\t\t\t\t\t\tif (start <0) break;\n\t\t\t\t\t\t\t\tstart = gf_token_get_strip(cur, start, \":}\", \" \", css_val, 1024);\n\t\t\t\t\t\t\t\tif (start <0) break;\n\t\t\t\t\t\t\t\tcur = strchr(cur+start, '{');\n\n\t\t\t\t\t\t\t\tif (!strcmp(css_style, \"font-table\")) {\n\t\t\t\t\t\t\t\t\tu32 z;\n\t\t\t\t\t\t\t\t\tstyles[nb_styles].fontID = atoi(css_val);\n\t\t\t\t\t\t\t\t\tfor (z=0; z<td.font_count; z++) {\n\t\t\t\t\t\t\t\t\t\tif (td.fonts[z].fontID == styles[nb_styles].fontID)\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (!strcmp(css_style, \"font-size\")) styles[nb_styles].font_size = atoi(css_val);\n\t\t\t\t\t\t\t\telse if (!strcmp(css_style, \"font-style\") && !strcmp(css_val, \"italic\")) styles[nb_styles].style_flags |= GF_TXT_STYLE_ITALIC;\n\t\t\t\t\t\t\t\telse if (!strcmp(css_style, \"font-weight\") && !strcmp(css_val, \"bold\")) styles[nb_styles].style_flags |= GF_TXT_STYLE_BOLD;\n\t\t\t\t\t\t\t\telse if (!strcmp(css_style, \"text-decoration\") && !strcmp(css_val, \"underline\")) styles[nb_styles].style_flags |= GF_TXT_STYLE_UNDERLINED;\n\t\t\t\t\t\t\t\telse if (!strcmp(css_style, \"text-decoration\") && !strcmp(css_val, \"strikethrough\")) styles[nb_styles].style_flags |= GF_TXT_STYLE_STRIKETHROUGH;\n\t\t\t\t\t\t\t\telse if (!strcmp(css_style, \"color\")) styles[nb_styles].text_color = tx3g_get_color(css_val);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!nb_styles) td.default_style = styles[0];\n\t\t\t\t\t\t\tnb_styles++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tif ((td.default_pos.bottom==td.default_pos.top) || (td.default_pos.right==td.default_pos.left)) {\n\t\t\t\t\ttd.default_pos.top = ctx->txty;\n\t\t\t\t\ttd.default_pos.left = ctx->txtx;\n\t\t\t\t\ttd.default_pos.right = ctx->width;\n\t\t\t\t\ttd.default_pos.bottom = ctx->height;\n\t\t\t\t}\n\t\t\t\tif (!td.fonts) {\n\t\t\t\t\ttd.font_count = 1;\n\t\t\t\t\ttd.fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord));\n\t\t\t\t\ttd.fonts[0].fontID = 1;\n\t\t\t\t\ttd.fonts[0].fontName = gf_strdup( ctx->fontname ? ctx->fontname : \"Serif\");\n\t\t\t\t}\n\n\t\t\t\tgf_odf_tx3g_write(&td, &dsi, &dsi_len);\n\t\t\t\tstsd_idx = 0;\n\t\t\t\tfor (k=0; ctx->text_descs && k<gf_list_count(ctx->text_descs); k++) {\n\t\t\t\t\tGF_PropertyValue *d = gf_list_get(ctx->text_descs, k);\n\t\t\t\t\tif (d->value.data.size != dsi_len) continue;\n\t\t\t\t\tif (! memcmp(d->value.data.ptr, dsi, dsi_len)) {\n\t\t\t\t\t\tstsd_idx = k+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (stsd_idx) {\n\t\t\t\t\tgf_free(dsi);\n\t\t\t\t} else {\n\t\t\t\t\tGF_PropertyValue *d;\n\t\t\t\t\tGF_SAFEALLOC(d, GF_PropertyValue);\n\t\t\t\t\tif (!d) return GF_OUT_OF_MEM;\n\t\t\t\t\td->type = GF_PROP_DATA;\n\t\t\t\t\td->value.data.ptr = dsi;\n\t\t\t\t\td->value.data.size = dsi_len;\n\t\t\t\t\tif (!ctx->text_descs) ctx->text_descs = gf_list_new();\n\t\t\t\t\tgf_list_add(ctx->text_descs, d);\n\t\t\t\t\tstsd_idx = gf_list_count(ctx->text_descs);\n\t\t\t\t}\n\t\t\t\tif (stsd_idx != ctx->last_desc_idx) {\n\t\t\t\t\tctx->last_desc_idx = stsd_idx;\n\t\t\t\t\tGF_PropertyValue *d = gf_list_get(ctx->text_descs, stsd_idx-1);\n\t\t\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, d);\n\t\t\t\t}\n\n\t\t\t\tfor (k=0; k<td.font_count; k++) gf_free(td.fonts[k].fontName);\n\t\t\t\tgf_free(td.fonts);\n\n\t\t\t\tif (probe_first_desc_only)\n\t\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\telse if (!strcmp(desc->name, \"sampleData\")) {\n\t\t\t\tGF_XMLNode *sub;\n\t\t\t\tu16 start, end;\n\t\t\t\tu32 styleID;\n\t\t\t\tu32 nb_chars, txt_len, m;\n\t\t\t\tnb_chars = 0;\n\n\t\t\t\tsamp = gf_isom_new_text_sample();\n\n\t\t\t\tk=0;\n\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(desc->attributes, &k))) {\n\t\t\t\t\tif (!strcmp(att->name, \"targetEncoding\") && !strcmp(att->value, \"utf16\")) ;//is_utf16 = 1;\n\t\t\t\t\telse if (!strcmp(att->name, \"scrollDelay\")) gf_isom_text_set_scroll_delay(samp, atoi(att->value) );\n\t\t\t\t\telse if (!strcmp(att->name, \"highlightColor\")) gf_isom_text_set_highlight_color(samp, tx3g_get_color(att->value));\n\t\t\t\t}\n\t\t\t\tstart = end = 0;\n\t\t\t\tk=0;\n\t\t\t\twhile ((sub=(GF_XMLNode*)gf_list_enum(desc->content, &k))) {\n\t\t\t\t\tif (sub->type) continue;\n\t\t\t\t\tif (!strcmp(sub->name, \"text\")) {\n\t\t\t\t\t\tGF_XMLNode *text;\n\t\t\t\t\t\tstyleID = 0;\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(sub->attributes, &m))) {\n\t\t\t\t\t\t\tif (!strcmp(att->name, \"styleID\")) styleID = atoi(att->value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttxt_len = 0;\n\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((text=(GF_XMLNode*)gf_list_enum(sub->content, &m))) {\n\t\t\t\t\t\t\tif (!text->type) {\n\t\t\t\t\t\t\t\tif (!strcmp(text->name, \"marker\")) {\n\t\t\t\t\t\t\t\t\tu32 z;\n\t\t\t\t\t\t\t\t\tmemset(&marks[nb_marks], 0, sizeof(Marker));\n\t\t\t\t\t\t\t\t\tmarks[nb_marks].pos = nb_chars+txt_len;\n\n\t\t\t\t\t\t\t\t\tz = 0;\n\t\t\t\t\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(text->attributes, &z))) {\n\t\t\t\t\t\t\t\t\t\tif (!strcmp(att->name, \"id\")) marks[nb_marks].id = atoi(att->value);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tnb_marks++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (text->type==GF_XML_TEXT_TYPE) {\n\t\t\t\t\t\t\t\ttxt_len += (u32) strlen(text->name);\n\t\t\t\t\t\t\t\tgf_isom_text_add_text(samp, text->name, (u32) strlen(text->name));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (styleID && (!same_style || (td.default_style.startCharOffset != styleID))) {\n\t\t\t\t\t\t\tGF_StyleRecord st = td.default_style;\n\t\t\t\t\t\t\tfor (m=0; m<nb_styles; m++) {\n\t\t\t\t\t\t\t\tif (styles[m].startCharOffset==styleID) {\n\t\t\t\t\t\t\t\t\tst = styles[m];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tst.startCharOffset = nb_chars;\n\t\t\t\t\t\t\tst.endCharOffset = nb_chars + txt_len;\n\t\t\t\t\t\t\tgf_isom_text_add_style(samp, &st);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnb_chars += txt_len;\n\t\t\t\t\t}\n\t\t\t\t\telse if (!stricmp(sub->name, \"highlight\")) {\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(sub->attributes, &m))) {\n\t\t\t\t\t\t\tif (!strcmp(att->name, \"startMarker\")) GET_MARKER_POS(start, 0)\n\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"endMarker\")) GET_MARKER_POS(end, 1)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_isom_text_add_highlight(samp, start, end);\n\t\t\t\t\t}\n\t\t\t\t\telse if (!stricmp(sub->name, \"blink\")) {\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(sub->attributes, &m))) {\n\t\t\t\t\t\t\tif (!strcmp(att->name, \"startMarker\")) GET_MARKER_POS(start, 0)\n\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"endMarker\")) GET_MARKER_POS(end, 1)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_isom_text_add_blink(samp, start, end);\n\t\t\t\t\t}\n\t\t\t\t\telse if (!stricmp(sub->name, \"link\")) {\n\t\t\t\t\t\tchar *url, *url_tt;\n\t\t\t\t\t\turl = url_tt = NULL;\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(sub->attributes, &m))) {\n\t\t\t\t\t\t\tif (!strcmp(att->name, \"startMarker\")) GET_MARKER_POS(start, 0)\n\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"endMarker\")) GET_MARKER_POS(end, 1)\n\t\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"URL\") || !strcmp(att->name, \"href\")) url = gf_strdup(att->value);\n\t\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"URLToolTip\") || !strcmp(att->name, \"altString\")) url_tt = gf_strdup(att->value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_isom_text_add_hyperlink(samp, url, url_tt, start, end);\n\t\t\t\t\t\tif (url) gf_free(url);\n\t\t\t\t\t\tif (url_tt) gf_free(url_tt);\n\t\t\t\t\t}\n\t\t\t\t\telse if (!stricmp(sub->name, \"karaoke\")) {\n\t\t\t\t\t\tu32 time = 0;\n\t\t\t\t\t\tGF_XMLNode *krok;\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(sub->attributes, &m))) {\n\t\t\t\t\t\t\tif (!strcmp(att->name, \"startTime\")) time = atoi(att->value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_isom_text_add_karaoke(samp, time);\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((krok=(GF_XMLNode*)gf_list_enum(sub->content, &m))) {\n\t\t\t\t\t\t\tu32 u=0;\n\t\t\t\t\t\t\tif (krok->type) continue;\n\t\t\t\t\t\t\tif (strcmp(krok->name, \"run\")) continue;\n\t\t\t\t\t\t\tstart = end = 0;\n\t\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(krok->attributes, &u))) {\n\t\t\t\t\t\t\t\tif (!strcmp(att->name, \"startMarker\")) GET_MARKER_POS(start, 0)\n\t\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"endMarker\")) GET_MARKER_POS(end, 1)\n\t\t\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"duration\")) time += atoi(att->value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgf_isom_text_set_karaoke_segment(samp, time, start, end);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*OK, let's add the sample*/\n\t\tif (samp) {\n\t\t\tif (!same_box) gf_isom_text_set_box(samp, td.default_pos.top, td.default_pos.left, td.default_pos.bottom, td.default_pos.right);\n//\t\t\tif (!same_style) gf_isom_text_add_style(samp, &td.default_style);\n\n\t\t\ttxtin_process_send_text_sample(ctx, samp, (ctx->start*ctx->timescale)/ctx->txml_timescale, (u32) (duration*ctx->timescale)/ctx->txml_timescale, isRAP);\n\t\t\tctx->start += duration;\n\t\t\tgf_isom_delete_text_sample(samp);\n\n\t\t}\n\t\tif (gf_filter_pid_would_block(ctx->opid)) {\n\t\t\tctx->cur_child_idx++;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\treturn GF_EOS;\n}\n\nstatic GF_Err txtin_process_simple(GF_Filter *filter, GF_TXTIn *ctx, GF_FilterPacket *ipck)\n{\n\tGF_FilterPacket *opck=NULL;\n\tif (ctx->playstate==2) return GF_EOS;\n\tif (!ipck) return GF_OK;\n\n\tif (ctx->stxtmod==STXT_MODE_TX3G) {\n\t\tu32 size;\n\t\tu8 *output;\n\t\tconst u8 *data = gf_filter_pck_get_data(ipck, &size);\n\t\topck = gf_filter_pck_new_alloc(ctx->opid, size+2, &output);\n\t\tif (opck) {\n\t\t\tmemcpy(output+2, data, size);\n\t\t\toutput[0] = (size>>8) & 0xFF;\n\t\t\toutput[1] = (size) & 0xFF;\n\t\t}\n\t} else if (ctx->stxtmod==STXT_MODE_VTT) {\n\t\tu32 size;\n\t\tu8 *output;\n\t\tconst u8 *data = gf_filter_pck_get_data(ipck, &size);\n\t\topck = gf_filter_pck_new_alloc(ctx->opid, size+16, &output);\n\t\tif (opck) {\n\t\t\tGF_BitStream *bs = gf_bs_new(output, size+16, GF_BITSTREAM_WRITE);\n\t\t\tgf_bs_write_u32(bs, size+16);\n\t\t\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_VTCC_CUE);\n\t\t\tgf_bs_write_u32(bs, size+8);\n\t\t\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_PAYL);\n\t\t\tgf_bs_write_data(bs, data, size);\n\t\t\tgf_bs_del(bs);\n\t\t}\n\t} else {\n\t\topck = gf_filter_pck_new_ref(ctx->opid, 0, 0, ipck);\n\t}\n\tif (!opck) return GF_OUT_OF_MEM;\n\tgf_filter_pck_set_sap(opck, GF_FILTER_SAP_1);\n\tif (gf_filter_pck_get_cts(ipck)==GF_FILTER_NO_TS) {\n\t\tgf_filter_pck_set_dts(opck, 0);\n\t\tgf_filter_pck_set_cts(opck, 0);\n\n\t\tif (!gf_filter_pck_get_duration(ipck)) {\n\t\t\ts32 dur = (s32) gf_timestamp_rescale_signed(ctx->stxtdur.num, ctx->stxtdur.den, ctx->timescale);\n\t\t\tif (dur<0) dur = -dur;\n\t\t\tgf_filter_pck_set_duration(opck, (u32) dur);\n\t\t} else if (ctx->stxtdur.num>0) {\n\t\t\tu32 dur = (u32) gf_timestamp_rescale(ctx->stxtdur.num, ctx->stxtdur.den, ctx->timescale);\n\t\t\tgf_filter_pck_set_duration(opck, dur);\n\t\t}\n\t}\n\treturn gf_filter_pck_send(opck);\n}\n\nstatic GF_Err txtin_process(GF_Filter *filter)\n{\n\tGF_TXTIn *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck;\n\tGF_Err e;\n\tBool start, end;\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (pck) ctx->is_loaded = GF_FALSE;\n\n\tif (!pck) {\n\t\tif (ctx->unframed) {\n\t\t\tif (gf_filter_pid_is_eos(ctx->ipid)) {\n\t\t\t\tif (ctx->end) {\n#ifndef GPAC_DISABLE_VTT\n\t\t\t\t\tif (ctx->vttparser) {\n\t\t\t\t\t\tgf_webvtt_parser_flush(ctx->vttparser);\n\t\t\t\t\t}\n\t\t\t\t\telse\n#endif\n\t\t\t\t\tif (!ctx->noflush) {\n\t\t\t\t\t\tgf_isom_text_reset(ctx->samp);\n\t\t\t\t\t\ttxtin_process_send_text_sample(ctx, ctx->samp, ctx->end, 0, GF_TRUE);\n\t\t\t\t\t}\n\t\t\t\t\tctx->end = 0;\n\t\t\t\t}\n\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\t\treturn GF_EOS;\n\t\t\t}\n\t\t}\n\t\tif (!ctx->is_loaded)\n\t\t\treturn GF_OK;\n\t}\n\n\tif (ctx->unframed) {\n\t\tif (ctx->simple_text) {\n\t\t\te = ctx->text_process(filter, ctx, pck);\n\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\treturn e;\n\t\t}\n\t\tconst u8 *data;\n\t\tu32 size;\n\t\tdata = gf_filter_pck_get_data(pck, &size);\n\t\te = GF_OK;\n\t\tif (data && size) {\n\t\t\tctx->src = gf_file_temp(NULL);\n\t\t\tif (gf_fwrite(data, size, ctx->src) != size)\n\t\t\t\te = GF_IO_ERR;\n\t\t\tgf_fseek(ctx->src, 0, SEEK_SET);\n\t\t\t//init state as parsing SRT payload\n\t\t\tctx->state = 2;\n\t\t\tctx->start = gf_filter_pck_get_cts(pck);\n\t\t\tctx->end = ctx->start + gf_filter_pck_get_duration(pck);\n\t\t\tctx->curLine = 0;\n\n\t\t\tif (!e)\n\t\t\t\te = ctx->text_process(filter, ctx, pck);\n\n\t\t\tif (ctx->src) {\n\t\t\t\tgf_fclose(ctx->src);\n\t\t\t\tctx->src = NULL;\n\t\t\t}\n\t\t\tif (e==GF_EOS) e = GF_OK;\n\t\t}\n\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\treturn e;\n\t}\n\n\tif (pck) {\n\t\tgf_filter_pck_get_framing(pck, &start, &end);\n\t\tif (!end) {\n\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\treturn GF_OK;\n\t\t}\n\t\t//file is loaded\n\t\tctx->is_loaded = GF_TRUE;\n\t}\n\n\te = ctx->text_process(filter, ctx, NULL);\n\tif (e==GF_EOS) {\n\t\t//keep input alive until end of stream, so that we keep getting called\n\t\tif (pck)\n\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\n\t\tif (gf_filter_pid_is_eos(ctx->ipid))\n\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t}\n\treturn e;\n}\n\nstatic void ttxtin_reset(GF_TXTIn *ctx)\n{\n\tif (ctx->samp) gf_isom_delete_text_sample(ctx->samp);\n\tctx->samp = NULL;\n\tif (ctx->src) gf_fclose(ctx->src);\n\tctx->src = NULL;\n#ifndef GPAC_DISABLE_VTT\n\tif (ctx->vttparser) gf_webvtt_parser_del(ctx->vttparser);\n\tctx->vttparser = NULL;\n#endif\n\tif (ctx->parser) gf_xml_dom_del(ctx->parser);\n\tctx->parser = NULL;\n\tif (ctx->parser_working_copy) gf_xml_dom_del(ctx->parser_working_copy);\n\tctx->parser_working_copy = NULL;\n}\n\nstatic GF_Err txtin_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)\n{\n\tGF_Err e;\n\tu32 codec_id=0;\n\tBool gen_ttxt_dsi=GF_FALSE;\n\tBool gen_webvtt_dsi=GF_FALSE;\n\tconst char *src = NULL;\n\tGF_TXTIn *ctx = gf_filter_get_udta(filter);\n\tconst GF_PropertyValue *prop;\n\n\tif (is_remove) {\n\t\tctx->ipid = NULL;\n\t\treturn GF_OK;\n\t}\n\n\tctx->unframed = GF_FALSE;\n\tctx->simple_text = GF_FALSE;\n\n\tif (! gf_filter_pid_check_caps(pid))\n\t\treturn GF_NOT_SUPPORTED;\n\n\tprop = gf_filter_pid_get_property(pid, GF_PROP_PID_CODECID);\n\tif (ctx->srt_to_tx3g) {\n\t\tctx->unframed = GF_TRUE;\n\t\tprop = gf_filter_pid_get_property(pid, GF_PROP_PID_TIMESCALE);\n\t\tctx->timescale = prop ? prop->value.uint : 1000;\n\t}\n\telse if (ctx->vtt_to_tx3g) {\n\t\tctx->unframed = GF_TRUE;\n\t\tprop = gf_filter_pid_get_property(pid, GF_PROP_PID_TIMESCALE);\n\t\tctx->timescale = prop ? prop->value.uint : 1000;\n\t}\n\telse if (prop && (\n\t\t(prop->value.uint==GF_CODECID_WEBVTT)\n\t\t|| (prop->value.uint==GF_CODECID_SUBS_SSA)\n\t)) {\n\t\tcodec_id = prop->value.uint;\n\t\tctx->unframed = GF_TRUE;\n\t\tprop = gf_filter_pid_get_property(pid, GF_PROP_PID_TIMESCALE);\n\t\tctx->timescale = prop ? prop->value.uint : 1000;\n\t} else if (prop && (\n\t\t(prop->value.uint==GF_CODECID_SIMPLE_TEXT)\n\t\t|| (prop->value.uint==GF_CODECID_SUBS_TEXT)\n\t)) {\n\t\tcodec_id = prop->value.uint;\n\t\tctx->unframed = GF_TRUE;\n\t\tprop = gf_filter_pid_get_property(pid, GF_PROP_PID_TIMESCALE);\n\t\tctx->timescale = prop ? prop->value.uint : 1000;\n\t\tgf_filter_pid_set_framing_mode(pid, GF_TRUE);\n\t\tif (!prop) {\n\t\t\tctx->simple_text = GF_TRUE;\n\t\t\tgf_filter_pid_set_framing_mode(pid, GF_TRUE);\n\t\t}\n\t} else {\n\t\t//otherwise we must have a file path\n\t\tprop = gf_filter_pid_get_property(pid, GF_PROP_PID_FILEPATH);\n\t\tif (prop && prop->value.string) src = prop->value.string;\n\n\t\tif (!src)\n\t\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\tif (!ctx->ipid) {\n\t\tGF_FilterEvent fevt;\n\t\tctx->ipid = pid;\n\n\t\tif (src) {\n\t\t\t//we work with full file only, send a play event on source to indicate that\n\t\t\tGF_FEVT_INIT(fevt, GF_FEVT_PLAY, pid);\n\t\t\tfevt.play.start_range = 0;\n\t\t\tfevt.base.on_pid = ctx->ipid;\n\t\t\tfevt.play.full_file_only = GF_TRUE;\n\t\t\tgf_filter_pid_send_event(ctx->ipid, &fevt);\n\t\t\tctx->file_name = gf_strdup(src);\n\t\t}\n\t} else {\n\t\tif (pid != ctx->ipid) {\n\t\t\treturn GF_REQUIRES_NEW_INSTANCE;\n\t\t}\n\t\tif (src) {\n\t\t\tif (!strcmp(ctx->file_name, src)) return GF_OK;\n\n\t\t\tttxtin_reset(ctx);\n\t\t\tctx->is_setup = GF_FALSE;\n\t\t\tgf_free(ctx->file_name);\n\t\t\tctx->file_name = gf_strdup(src);\n\t\t}\n\t}\n\tif (src) {\n\t\t//guess type\n\t\te = gf_text_guess_format(ctx, ctx->file_name, &ctx->fmt);\n\t\tif (e) return e;\n\t\tif (!ctx->fmt) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTLoad] Unknown text format for %s\\n\", ctx->file_name));\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\t} else {\n\t\tif (ctx->vtt_to_tx3g)\n\t\t\tctx->fmt = GF_TXTIN_MODE_SRT;\n\t\telse if (ctx->srt_to_tx3g)\n\t\t\tctx->fmt = GF_TXTIN_MODE_SRT;\n\t\telse if (codec_id == GF_CODECID_WEBVTT)\n\t\t\tctx->fmt = GF_TXTIN_MODE_WEBVTT;\n\t\telse if (codec_id == GF_CODECID_SUBS_SSA)\n\t\t\tctx->fmt = GF_TXTIN_MODE_SSA;\n\t\telse\n\t\t\tctx->fmt = ctx->simple_text ? GF_TXTIN_MODE_SIMPLE : GF_TXTIN_MODE_SRT;\n\t\tif (!ctx->opid)\n\t\t\tctx->opid = gf_filter_pid_new(filter);\n\t}\n\n\tif (ctx->webvtt && (ctx->fmt == GF_TXTIN_MODE_SRT))\n\t\tctx->fmt = GF_TXTIN_MODE_WEBVTT;\n\n\tif (!src) {\n\t\tgf_filter_pid_copy_properties(ctx->opid, pid);\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_TEXT) );\n\n\t\tif (!ctx->simple_text)\n\t\t\tcodec_id = (ctx->fmt == GF_TXTIN_MODE_WEBVTT) ? GF_CODECID_WEBVTT : GF_CODECID_TX3G;\n\t\telse if (ctx->stxtmod)\n\t\t\tcodec_id = (ctx->stxtmod==STXT_MODE_VTT) ? GF_CODECID_WEBVTT : GF_CODECID_TX3G;\n\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, &PROP_UINT(codec_id) );\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_UNFRAMED, NULL);\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, NULL);\n\t}\n\n\tswitch (ctx->fmt) {\n\tcase GF_TXTIN_MODE_SRT:\n\t\tctx->text_process = txtin_process_srt;\n\t\tif (!ctx->is_setup && ctx->unframed) gen_ttxt_dsi = GF_TRUE;\n\t\tbreak;\n#ifndef GPAC_DISABLE_VTT\n\tcase GF_TXTIN_MODE_WEBVTT:\n\t\tctx->text_process = txtin_process_webvtt;\n\t\tif (!ctx->is_setup && ctx->unframed) gen_webvtt_dsi = GF_TRUE;\n\t\tbreak;\n#endif\n\tcase GF_TXTIN_MODE_TTXT:\n\t\tctx->text_process = txtin_process_ttxt;\n\t\tbreak;\n\tcase GF_TXTIN_MODE_TEXML:\n\t\tctx->text_process = txtin_process_texml;\n\t\tbreak;\n\tcase GF_TXTIN_MODE_SUB:\n\t\tctx->text_process = gf_text_process_sub;\n\t\tif (!ctx->is_setup && ctx->unframed) gen_ttxt_dsi = GF_TRUE;\n\t\tbreak;\n\tcase GF_TXTIN_MODE_TTML:\n\t\tctx->text_process = gf_text_process_ttml;\n\t\tbreak;\n\tcase GF_TXTIN_MODE_SSA:\n\t\tctx->text_process = gf_text_process_ssa;\n\t\tif (!ctx->is_setup && ctx->unframed) gen_ttxt_dsi = GF_TRUE;\n\t\tbreak;\n#ifndef GPAC_DISABLE_SWF_IMPORT\n\tcase GF_TXTIN_MODE_SWF_SVG:\n\t\tctx->text_process = gf_text_process_swf;\n\t\tbreak;\n#endif\n\tcase GF_TXTIN_MODE_SIMPLE:\n\t\tctx->text_process = txtin_process_simple;\n\t\tif (ctx->stxtmod==STXT_MODE_TX3G) gen_ttxt_dsi = 1;\n\t\telse if (ctx->stxtmod==STXT_MODE_VTT) gen_webvtt_dsi = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tif (gen_ttxt_dsi) {\n\t\ttxtin_setup_srt(filter, ctx, GF_TRUE);\n\t}\n\tif (gen_webvtt_dsi) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA((u8 *) \"WEBVTT\", 7 ) );\n\t}\n\n\t//when translating from unframed srt/vtt to framed tx3g/vtt, the number of input samples will be at most doubled by inserting blank samples\n\tif (ctx->unframed && !ctx->no_empty) {\n\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_NB_FRAMES);\n\t\tif (p)\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_NB_FRAMES, &PROP_UINT(p->value.uint*2));\n\t}\n\n\treturn GF_OK;\n}\n\nstatic Bool txtin_process_event(GF_Filter *filter, const GF_FilterEvent *evt)\n{\n\tGF_TXTIn *ctx = gf_filter_get_udta(filter);\n\tif (ctx->unframed) return GF_FALSE;\n\n\tswitch (evt->base.type) {\n\tcase GF_FEVT_PLAY:\n\t\tif (ctx->playstate==1) return ctx->unframed ? GF_FALSE : GF_TRUE;\n\t\tif ((ctx->playstate==2) && !ctx->unframed)\n\t\t\tgf_filter_post_process_task(filter);\n\n\t\tctx->playstate = 1;\n\t\tif ((ctx->start_range < 0.1) && (evt->play.start_range<0.1)) return ctx->unframed ? GF_FALSE : GF_TRUE;\n\t\tctx->start_range = evt->play.start_range;\n\t\tctx->seek_state = 1;\n\t\t//cancel play event if we work with full file\n\t\treturn ctx->unframed ? GF_FALSE : GF_TRUE;\n\n\tcase GF_FEVT_STOP:\n\t\tctx->playstate = 2;\n\n\t\tttxtin_reset(ctx);\n\t\tctx->is_setup = GF_FALSE;\n\t\t//cancel play event if we work with full file\n\t\treturn ctx->unframed ? GF_FALSE : GF_TRUE;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n\treturn GF_FALSE;\n}\n\nGF_Err txtin_initialize(GF_Filter *filter)\n{\n\tchar data[1];\n\tGF_TXTIn *ctx = gf_filter_get_udta(filter);\n\tctx->bs_w = gf_bs_new(data, 1, GF_BITSTREAM_WRITE);\n\n\treturn GF_OK;\n}\n\nvoid txtin_finalize(GF_Filter *filter)\n{\n\tGF_TXTIn *ctx = gf_filter_get_udta(filter);\n\n\tttxtin_reset(ctx);\n\tif (ctx->bs_w) gf_bs_del(ctx->bs_w);\n\n\tif (ctx->text_descs) {\n\t\twhile (gf_list_count(ctx->text_descs)) {\n\t\t\tGF_PropertyValue *p = gf_list_pop_back(ctx->text_descs);\n\t\t\tgf_free(p->value.data.ptr);\n\t\t\tgf_free(p);\n\t\t}\n\t\tgf_list_del(ctx->text_descs);\n\t}\n#ifndef GPAC_DISABLE_SWF_IMPORT\n\tgf_swf_reader_del(ctx->swf_parse);\n#endif\n\n\tif (ctx->intervals) {\n\t\tttml_reset_intervals(ctx);\n\t\tgf_list_del(ctx->intervals);\n\t}\n\tif (ctx->ttml_resources) {\n\t\twhile (gf_list_count(ctx->ttml_resources)) {\n\t\t\tTTMLRes *ires = gf_list_pop_back(ctx->ttml_resources);\n\t\t\tgf_free(ires->data);\n\t\t\tgf_free(ires);\n\t\t}\n\t\tgf_list_del(ctx->ttml_resources);\n\t}\n\tif (ctx->div_nodes_list)\n\t\tgf_list_del(ctx->div_nodes_list);\n\n\tif (ctx->file_name) gf_free(ctx->file_name);\n}\n\n\nstatic const char *txtin_probe_data(const u8 *data, u32 data_size, GF_FilterProbeScore *score)\n{\n\tchar *dst = NULL;\n\tchar *res=NULL;\n\tGF_Err e = gf_utf_get_utf8_string_from_bom((char *)data, data_size, &dst, &res);\n\tif (e) return NULL;\n\n\tdata = res;\n\t//strip all spaces and \\r\\n\\t\n\twhile (data[0] && strchr(\"\\n\\r\\t \", (char) data[0]))\n\t\tdata ++;\n\n#define PROBE_OK(_score, _mime) \\\n\t\t*score = _score;\\\n\t\tif (dst) gf_free(dst);\\\n\t\treturn _mime; \\\n\n\n\tif (!strncmp(data, \"WEBVTT\", 6)) {\n\t\tPROBE_OK(GF_FPROBE_SUPPORTED, \"subtitle/vtt\")\n\t}\n\tif (strstr(data, \" --> \")) {\n\t\tPROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, \"subtitle/srt\")\n\t}\n\tif (!strncmp(data, \"FWS\", 3) || !strncmp(data, \"CWS\", 3)) {\n\t\tPROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, \"application/x-shockwave-flash\")\n\t}\n\tif (!strncmp(data, \"[Script Info\", 12)) {\n\t\tPROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, \"subtitle/ssa\")\n\t}\n\n\tif ((data[0]=='{') && strstr(data, \"}{\")) {\n\t\tPROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, \"subtitle/sub\")\n\n\t}\n\t/*XML formats*/\n\tif (!strstr(data, \"?>\") ) {\n\t\tif (dst) gf_free(dst);\n\t\treturn NULL;\n\t}\n\n\tif (strstr(data, \"<x-quicktime-tx3g\") || strstr(data, \"<text3GTrack\")) {\n\t\tPROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, \"quicktime/text\")\n\t}\n\tif (strstr(data, \"TextStream\")) {\n\t\tPROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, \"subtitle/ttxt\")\n\t}\n\tif (strstr(data, \"<tt \") || strstr(data, \":tt \")) {\n\t\tPROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, \"subtitle/ttml\")\n\t}\n\n\tif (dst) gf_free(dst);\n\treturn NULL;\n}\n\nstatic const GF_FilterCapability TXTInCaps[] =\n{\n\tCAP_UINT(GF_CAPS_INPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_FILE_EXT, \"srt|ttxt|sub|vtt|txml|ttml|swf|ssa|ass\"),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_MIME, \"x-subtitle/srt|subtitle/srt|text/srt|x-subtitle/sub|subtitle/sub|text/sub|x-subtitle/ttxt|subtitle/ttxt|text/ttxt|x-subtitle/vtt|subtitle/vtt|text/vtt|x-quicktime/text|quicktime/text|subtitle/ttml|text/ttml|application/xml+ttml|application/x-shockwave-flash|subtitle/ssa|text/ssa\"),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_TEXT),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_CODECID, GF_CODECID_TX3G),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_CODECID, GF_CODECID_SIMPLE_TEXT),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_CODECID, GF_CODECID_WEBVTT),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_CODECID, GF_CODECID_SUBS_XML),\n\t{0},\n\t//unframed SRT\n\tCAP_UINT(GF_CAPS_INPUT_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_TEXT),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_SUBS_TEXT),\n\tCAP_BOOL(GF_CAPS_INPUT, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_CODECID, GF_CODECID_TX3G),\n\t{0},\n\t//unframed WebVTT\n\tCAP_UINT(GF_CAPS_INPUT_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_TEXT),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_WEBVTT),\n\tCAP_BOOL(GF_CAPS_INPUT, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_CODECID, GF_CODECID_WEBVTT),\n\t{0},\n\t//unframed SSA\n\tCAP_UINT(GF_CAPS_INPUT_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_TEXT),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_SUBS_SSA),\n\tCAP_BOOL(GF_CAPS_INPUT, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_CODECID, GF_CODECID_TX3G),\n\t{0},\n\t//text files\n\tCAP_UINT(GF_CAPS_INPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_UINT(GF_CAPS_INPUT_OUTPUT, GF_PROP_PID_CODECID, GF_CODECID_SUBS_TEXT),\n\tCAP_UINT(GF_CAPS_INPUT_OUTPUT, GF_PROP_PID_CODECID, GF_CODECID_SIMPLE_TEXT),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_TEXT),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_CODECID, GF_CODECID_TX3G),\n};\n\n#define OFFS(_n)\t#_n, offsetof(GF_TXTIn, _n)\n\nstatic const GF_FilterArgs TXTInArgs[] =\n{\n\t{ OFFS(webvtt), \"force WebVTT import of SRT files\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(nodefbox), \"skip default text box\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(noflush), \"skip final sample flush for srt\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(fontname), \"default font\", GF_PROP_STRING, NULL, NULL, 0},\n\t{ OFFS(fontsize), \"default font size\", GF_PROP_UINT, \"18\", NULL, 0},\n\t{ OFFS(lang), \"default language\", GF_PROP_STRING, NULL, NULL, 0},\n\t{ OFFS(width), \"default width of text area\", GF_PROP_UINT, \"0\", NULL, 0},\n\t{ OFFS(height), \"default height of text area\", GF_PROP_UINT, \"0\", NULL, 0},\n\t{ OFFS(txtx), \"default horizontal offset of text area: -1 (left), 0 (center) or 1 (right)\", GF_PROP_UINT, \"0\", NULL, 0},\n\t{ OFFS(txty), \"default vertical offset of text area: -1 (bottom), 0 (center) or 1 (top)\", GF_PROP_UINT, \"0\", NULL, 0},\n\t{ OFFS(zorder), \"default z-order of the PID\", GF_PROP_SINT, \"0\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(timescale), \"default timescale of the PID\", GF_PROP_UINT, \"1000\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(ttml_split), \"split ttml doc in non-overlapping samples\", GF_PROP_BOOL, \"true\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(ttml_cts), \"first sample cts - see filter help\", GF_PROP_FRACTION64, \"-1/1\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(ttml_dur), \"sample duration when not spliting split - see filter help\", GF_PROP_FRACTION, \"0/1\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(ttml_embed), \"force embedding TTML resources\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(ttml_zero), \"set subtitle zero time for TTML\", GF_PROP_STRING, NULL, NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(no_empty), \"do not send empty samples\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(stxtdur), \"duration for simple text\", GF_PROP_FRACTION, \"1\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(stxtmod), \"simple text stream mode\"\n\t\"- none: declares output PID as simple text stream\\n\"\n\t\"- tx3g: declares output PID as TX3G/Apple stream\\n\"\n\t\"- vtt: declares output PID as WebVTT stream\", GF_PROP_UINT, \"none\", \"none|tx3g|vtt\", GF_FS_ARG_HINT_EXPERT},\n\t{0}\n};\n\nGF_FilterRegister TXTInRegister = {\n\t.name = \"txtin\",\n\tGF_FS_SET_DESCRIPTION(\"Subtitle loader\")\n\tGF_FS_SET_HELP(\"This filter reads subtitle data from input PID to produce subtitle frames on a single PID.\\n\"\n\t\"The filter supports the following formats:\\n\"\n\t\"- SRT: https://en.wikipedia.org/wiki/SubRip\\n\"\n\t\"- WebVTT: https://www.w3.org/TR/webvtt1/\\n\"\n\t\"- TTXT: https://wiki.gpac.io/TTXT-Format-Documentation\\n\"\n\t\"- QT 3GPP Text XML (TexML): Apple QT6, likely deprecated\\n\"\n\t\"- TTML: https://www.w3.org/TR/ttml2/\\n\"\n\t\"- SUB: one subtitle per line formatted as `{start_frame}{end_frame}text`\\n\"\n\t\"- SSA (Substation Alpha): basic parsing support for common files\\n\"\n\t\"\\n\"\n\t\"Input files must be in UTF-8 or UTF-16 format, with or without BOM. The internal frame format is: \\n\"\n\t\"- WebVTT (and srt if desired): ISO/IEC 14496-30 VTT cues\\n\"\n\t\"- TTML: ISO/IEC 14496-30 XML subtitles\\n\"\n\t\"- Others: 3GPP/QT Timed Text\\n\"\n\t\"\\n\"\n\t\"# TTML Support\\n\"\n\t\"If [-ttml_split]() option is set, the TTML document is split in independent time segments by inspecting all overlapping subtitles in the body.\\n\"\n\t\"Empty periods in TTML will result in empty TTML documents or will be skipped if [-no_empty]() option is set.\\n\"\n\t\"\\n\"\n\t\"The first sample has a CTS assigned as indicated by [-ttml_cts]():\\n\"\n\t\"- a numerator of -2 indicates the first CTS is 0\\n\"\n\t\"- a numerator of -1 indicates the first CTS is the first active time in document\\n\"\n\t\"- a numerator >= 0 indicates the CTS to use for first sample\\n\"\n\t\"\\n\"\n\t\"When TTML splitting is disabled, the duration of the TTML sample is given by [-ttml_dur]() if not 0, or set to the document duration\\n\"\n\t\"\\n\"\n\t\"By default, media resources are kept as declared in TTML2 documents.\\n\"\n\t\"\\n\"\n\t\"[-ttml_embed]() can be used to embed inside the TTML sample the resources in `<head>` or `<body>`:\\n\"\n\t\"- for `<source>`, `<image>`, `<audio>`, `<font>`, local URIs indicated in `src` will be loaded and `src` rewritten.\\n\"\n\t\"- for `<data>` with base64 coding, the data will be decoded, `<data>` element removed and parent <source> rewritten with `src` attribute inserted.\\n\"\n\t\"\\nThe embedded data is added as a subsample to the TTML frame, and the referring elements will use `src=urn:mpeg:14496-30:N` with `N` the index of the subsample.\\n\"\n\t\"\\n\"\n\t\"A `subtitle zero` may be specified using [-ttml_zero](). This will remove all subtitles before the given time `T0`, and rewrite each subtitle begin/end `T` to `T-T0` using millisecond accuracy.\\n\"\n\t\"Warning: Original time formatting (tick, frames/subframe ...) will be lost when this option is used, converted to `HH:MM:SS.ms`.\\n\"\n\t\"\\n\"\n\t\"The subtitle zero time **must** be prefixed with `T` when the option is not set as a global argument:\\n\"\n\t\"EX gpac -i test.ttml:ttml_zero=T10:00:00 [...]\\n\"\n\t\"EX MP4Box -add test.ttml:sopt:ttml_zero=T10:00:00 [...]\\n\"\n\t\"EX gpac -i test.ttml --ttml_zero=10:00:00 [...]\\n\"\n\t\"EX gpac -i test.ttml --ttml_zero=T10:00:00 [...]\\n\"\n\t\"EX MP4Box -add test.ttml --ttml_zero=10:00:00 [...]\\n\"\n\t\"\\n\"\n\t\"# Simple Text Support\\n\"\n\t\"The text loader can convert input files in simple text streams of a single packet, by forcing the codec type on the input:\"\n\t\"EX gpac -i test.txt:#CodecID=stxt  [...]\\n\"\n\t\"EX gpac fin:pck=\\\"Text Data\\\":#CodecID=stxt  [...]\\n\"\n\t\"\\n\"\n\t\"The content of the source file will be the payload of the text sample. The [-stxtmod]() option allows specifying WebVTT, TX3G or simple text mode for output format.\\n\"\n\t\"In this mode, the [-stxtdur]() option is used to control the duration of the generated subtitle:\\n\"\n\t\"- a positive value always forces the duration\\n\"\n\t\"- a negative value forces the duration if input packet duration is not known\\n\"\n\t)\n\n\t.private_size = sizeof(GF_TXTIn),\n\t.flags = GF_FS_REG_MAIN_THREAD,\n\t.args = TXTInArgs,\n\tSETCAPS(TXTInCaps),\n\t.process = txtin_process,\n\t.configure_pid = txtin_configure_pid,\n\t.process_event = txtin_process_event,\n\t.probe_data = txtin_probe_data,\n\t.initialize = txtin_initialize,\n\t.finalize = txtin_finalize\n};\n\n\nconst GF_FilterRegister *txtin_register(GF_FilterSession *session)\n{\n\treturn &TXTInRegister;\n}\n\nstatic GF_Err vtt2tx3g_initialize(GF_Filter *filter)\n{\n\tGF_TXTIn *ctx = gf_filter_get_udta(filter);\n\ttxtin_initialize(filter);\n\tctx->vtt_to_tx3g = GF_TRUE;\n\treturn GF_OK;\n}\n\nstatic const GF_FilterCapability VTTTX3GCaps[] =\n{\n\t//unframed WebVTT\n\tCAP_UINT(GF_CAPS_INPUT_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_TEXT),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_WEBVTT),\n\tCAP_BOOL(GF_CAPS_INPUT, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_CODECID, GF_CODECID_TX3G),\n\tCAP_BOOL(GF_CAPS_OUTPUT_EXCLUDED, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\t{0},\n};\n\n#define OFFS(_n)\t#_n, offsetof(GF_TXTIn, _n)\n\nstatic const GF_FilterArgs VTTTX3GArgs[] =\n{\n\t{ OFFS(fontname), \"default font\", GF_PROP_STRING, NULL, NULL, 0},\n\t{ OFFS(fontsize), \"default font size\", GF_PROP_UINT, \"18\", NULL, 0},\n\t{0}\n};\n\nGF_FilterRegister VTTTX3GRegister = {\n\t.name = \"vtt2tx3g\",\n\tGF_FS_SET_DESCRIPTION(\"WebVTT to TX3G\")\n\tGF_FS_SET_HELP(\"This filter rewrites unframed WebVTT to TX3G / QT Timed Text (binary format)\\n\"\n\t\"\\n\"\n\t\"Unframed WebVTT packets consist in single cues:\\n\"\n\t\"- cue payload as packet payload\\n\"\n\t\"- prefix as packet string property `vtt_pre`\\n\"\n\t\"- cue ID as packet string property `vtt_cueid`\\n\"\n\t\"- cue settings as packet string property `vtt_settings`\\n\"\n\t\"- packet timing contains the cue timing (start and duration)\\n\"\n\t)\n\n\t.private_size = sizeof(GF_TXTIn),\n\t.flags = GF_FS_REG_MAIN_THREAD,\n\t.args = VTTTX3GArgs,\n\tSETCAPS(VTTTX3GCaps),\n\t.process = txtin_process,\n\t.configure_pid = txtin_configure_pid,\n\t.process_event = txtin_process_event,\n\t.probe_data = txtin_probe_data,\n\t.initialize = vtt2tx3g_initialize,\n\t.finalize = txtin_finalize\n};\n\nconst GF_FilterRegister *vtt2tx3g_register(GF_FilterSession *session)\n{\n\treturn &VTTTX3GRegister;\n}\n\nstatic GF_Err rfsrt_initialize(GF_Filter *filter)\n{\n\tGF_TXTIn *ctx = gf_filter_get_udta(filter);\n\ttxtin_initialize(filter);\n\tctx->srt_to_tx3g = GF_TRUE;\n\treturn GF_OK;\n}\n\nstatic const GF_FilterCapability RFSRTCaps[] =\n{\n\t//unframed WebVTT\n\tCAP_UINT(GF_CAPS_INPUT_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_TEXT),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_SIMPLE_TEXT),\n//\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_SUBS_TEXT),\n\tCAP_BOOL(GF_CAPS_INPUT, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_CODECID, GF_CODECID_TX3G),\n\tCAP_BOOL(GF_CAPS_OUTPUT_EXCLUDED, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\t{0},\n};\n\n#define OFFS(_n)\t#_n, offsetof(GF_TXTIn, _n)\n\nstatic const GF_FilterArgs RFSRTArgs[] =\n{\n\t{ OFFS(fontname), \"default font\", GF_PROP_STRING, NULL, NULL, 0},\n\t{ OFFS(fontsize), \"default font size\", GF_PROP_UINT, \"18\", NULL, 0},\n\t{0}\n};\n\nGF_FilterRegister RFSRTRegister = {\n\t.name = \"rfsrt\",\n\tGF_FS_SET_DESCRIPTION(\"SRT reframer\")\n\tGF_FS_SET_HELP(\"This filter rewrites unframed SRT to TX3G / QT Timed Text (binary format)\\n\"\n\t\"\\n\"\n\t\"An unframed SRT packet consists in a single SRT cue as packet payload and packet timing contains the cue timing (start and duration).\\n\"\n\t)\n\n\t.private_size = sizeof(GF_TXTIn),\n\t.flags = GF_FS_REG_MAIN_THREAD,\n\t.args = RFSRTArgs,\n\tSETCAPS(RFSRTCaps),\n\t.process = txtin_process,\n\t.configure_pid = txtin_configure_pid,\n\t.process_event = txtin_process_event,\n\t.probe_data = txtin_probe_data,\n\t.initialize = rfsrt_initialize,\n\t.finalize = txtin_finalize\n};\n\nconst GF_FilterRegister *rfsrt_register(GF_FilterSession *session)\n{\n\treturn &RFSRTRegister;\n}\n\n#else\nconst GF_FilterRegister *txtin_register(GF_FilterSession *session)\n{\n\treturn NULL;\n}\n\nconst GF_FilterRegister *vtt2tx3g_register(GF_FilterSession *session)\n{\n\treturn NULL;\n}\n\nconst GF_FilterRegister *rfsrt_register(GF_FilterSession *session)\n{\n\treturn NULL;\n}\n\n#endif // GPAC_DISABLE_ISOM_WRITE\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2023\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / text import filter\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n\n\n#include <gpac/filters.h>\n#include <gpac/constants.h>\n#include <gpac/utf.h>\n#include <gpac/xml.h>\n#include <gpac/token.h>\n#include <gpac/color.h>\n#include <gpac/network.h>\n#include <gpac/internal/media_dev.h>\n#include <gpac/internal/isomedia_dev.h>\n\n#ifndef GPAC_DISABLE_SWF_IMPORT\n/* SWF Importer */\n#include <gpac/internal/swf_dev.h>\n#endif\n\n#if !defined(GPAC_DISABLE_ISOM_WRITE)\n\n#define TTML_NAMESPACE \"http://www.w3.org/ns/ttml\"\n\n#define CHECK_STR(__str)\t\\\n\tif (!__str) { \\\n\t\te = gf_import_message(import, GF_BAD_PARAM, \"Invalid XML formatting (line %d)\", parser.line);\t\\\n\t\tgoto exit;\t\\\n\t}\n\n\ntypedef struct __txtin_ctx GF_TXTIn;\n\nenum\n{\n\tSTXT_MODE_STXT=0,\n\tSTXT_MODE_TX3G,\n\tSTXT_MODE_VTT,\n};\n\nstruct __txtin_ctx\n{\n\t//opts\n\tu32 width, height, txtx, txty, fontsize, stxtmod;\n\ts32 zorder;\n\tconst char *fontname, *lang, *ttml_zero;\n\tBool nodefbox, noflush, webvtt, ttml_embed, no_empty;\n\tu32 timescale;\n\tGF_Fraction fps;\n\tBool ttml_split;\n\tGF_Fraction64 ttml_cts;\n\tGF_Fraction ttml_dur, stxtdur;\n\n\n\tGF_FilterPid *ipid, *opid;\n\tchar *file_name;\n\tu32 fmt;\n\tu32 playstate;\n\t//0: not seeking, 1: seek request pending, 2: seek configured, discarding packets up until start_range\n\tu32 seek_state;\n\tDouble start_range;\n\n\tBool is_loaded;\n\tBool is_setup;\n\n\tGF_Err (*text_process)(GF_Filter *filter, GF_TXTIn *ctx, GF_FilterPacket *ipck);\n\n\ts32 unicode_type;\n\n\tFILE *src;\n\n\tGF_BitStream *bs_w;\n\tBool first_samp;\n\tBool hdr_parsed;\n\tBool unframed, simple_text;\n\n\t//state vars for srt\n\tu32 state, default_color;\n\tGF_TextSample *samp;\n\tu64 start, end, prev_end;\n\tu32 curLine;\n\tGF_StyleRecord style;\n\n#ifndef GPAC_DISABLE_VTT\n\t//WebVTT state\n\tGF_WebVTTParser *vttparser;\n#endif\n\n\t//TTXT state\n\tGF_DOMParser *parser;\n\tu32 cur_child_idx, nb_children, last_desc_idx;\n\tGF_List *text_descs;\n\tBool last_sample_empty;\n\tu64 last_sample_duration;\n\t//TTML state is the same as ttxt plus the timescale and start (webvtt) for cts compute\n\tu32 txml_timescale;\n\tu32 current_tt_interval;\n\n\t//TTML state\n\tGF_XMLNode *root_working_copy, *body_node;\n\tGF_DOMParser *parser_working_copy;\n\tBool non_compliant_ttml;\n\tu32 tick_rate, ttml_fps_num, ttml_fps_den, ttml_sfps;\n\tGF_List *ttml_resources;\n\tGF_List *div_nodes_list;\n\tBool has_images;\n\n#ifndef GPAC_DISABLE_SWF_IMPORT\n\t//SWF text\n\tSWFReader *swf_parse;\n\tBool do_suspend;\n#endif\n\n\tBool vtt_to_tx3g;\n\tBool srt_to_tx3g;\n\n\tGF_List *intervals;\n\tu64 cts_first_interval;\n};\n\ntypedef struct\n{\n\tu32 size;\n\tu8 *data;\n\tBool global;\n} TTMLRes;\n\ntypedef struct\n{\n\ts64 begin, end;\n\tGF_List *resources;\n} TTMLInterval;\n\n\nenum\n{\n\tGF_TXTIN_MODE_NONE = 0,\n\tGF_TXTIN_MODE_SRT,\n\tGF_TXTIN_MODE_SUB,\n\tGF_TXTIN_MODE_TTXT,\n\tGF_TXTIN_MODE_TEXML,\n\tGF_TXTIN_MODE_WEBVTT,\n\tGF_TXTIN_MODE_TTML,\n\tGF_TXTIN_MODE_SWF_SVG,\n\tGF_TXTIN_MODE_SSA,\n\tGF_TXTIN_MODE_SIMPLE,\n};\n\n#define REM_TRAIL_MARKS(__str, __sep) while (1) {\t\\\n\t\tu32 _len = (u32) strlen(__str);\t\t\\\n\t\tif (!_len) break;\t\\\n\t\t_len--;\t\t\t\t\\\n\t\tif (strchr(__sep, __str[_len])) __str[_len] = 0;\t\\\n\t\telse break;\t\\\n\t}\t\\\n\n\ns32 gf_text_get_utf_type(GF_TXTIn *ctx, FILE *in_src)\n{\n\tu32 read;\n\tunsigned char BOM[5];\n\tread = (u32) gf_fread(BOM, 5, in_src);\n\tif ((s32) read < 1)\n\t\treturn -1;\n\n\tif ((BOM[0]==0xFF) && (BOM[1]==0xFE)) {\n\t\t/*UTF32 not supported*/\n\t\tif (!BOM[2] && !BOM[3])\n\t\t\treturn -1;\n\t\tgf_fseek(in_src, 2, SEEK_SET);\n\t\treturn 3;\n\t}\n\tif ((BOM[0]==0xFE) && (BOM[1]==0xFF)) {\n\t\t/*UTF32 not supported*/\n\t\tif (!BOM[2] && !BOM[3])\n\t\t\treturn -1;\n\t\tgf_fseek(in_src, 2, SEEK_SET);\n\t\treturn 2;\n\t} else if ((BOM[0]==0xEF) && (BOM[1]==0xBB) && (BOM[2]==0xBF)) {\n\t\tgf_fseek(in_src, 3, SEEK_SET);\n\t\treturn 1;\n\t}\n\tgf_fseek(in_src, 0, SEEK_SET);\n\n\tif (BOM[0]<0x80) {\n\t\treturn 0;\n\t}\n\t//check if ad-hoc charset is set\n\tconst char *opt = gf_opts_get_key(\"core\", \"charset\");\n\tif (ctx->ipid) {\n\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_CHARSET);\n\t\tif (p && p->value.string) opt = p->value.string;\n\t}\n\tif (opt) {\n\t\tif (!stricmp(opt, \"utf8\") || !stricmp(opt, \"utf-8\")) return 1;\n\t\tif (!stricmp(opt, \"utf16\") || !stricmp(opt, \"utf-16\")) return 2;\n\t\tif (!stricmp(opt, \"utf16be\") || !stricmp(opt, \"utf-16be\") || !stricmp(opt, \"utf-16-be\") || !stricmp(opt, \"utf16-be\")) return 3;\n\t\treturn 0;\n\t}\n\t//otherwise if we have legal UTF8, assume utf8\n\tif (gf_utf8_is_legal(BOM, 2) || gf_utf8_is_legal(BOM, 3) || gf_utf8_is_legal(BOM, 4) ) {\n\t\treturn 0;\n\t}\n\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] Unknown text encoding for PID %s, defaulting to passthrough - use `-charset` to override\\n\", gf_filter_pid_get_name(ctx->ipid)));\n\treturn 0;\n}\nstatic void ttxt_dom_progress(void *cbk, u64 cur_samp, u64 count)\n{\n\tGF_TXTIn *ctx = (GF_TXTIn *)cbk;\n\tctx->end = count;\n}\n\nstatic GF_Err gf_text_guess_format(GF_TXTIn *ctx, const char *filename, u32 *fmt)\n{\n\tchar szLine[2048], *line;\n\tu32 val;\n\ts32 uni_type;\n\tFILE *test = gf_fopen(filename, \"rb\");\n\tif (!test) return GF_URL_ERROR;\n\tuni_type = gf_text_get_utf_type(ctx, test);\n\n\tif (uni_type>1) {\n\t\tconst u16 *sptr;\n\t\tchar szUTF[1024];\n\t\tu32 read = (u32) gf_fread(szUTF, 1023, test);\n\t\tif ((s32) read < 0) {\n\t\t\tgf_fclose(test);\n\t\t\treturn GF_IO_ERR;\n\t\t}\n\t\tszUTF[read]=0;\n\t\tsptr = (u16*)szUTF;\n\t\t/*read = (u32) */gf_utf8_wcstombs(szLine, read, &sptr);\n\t} else {\n\t\tval = (u32) gf_fread(szLine, 1024, test);\n\t\tif ((s32) val<0) return GF_IO_ERR;\n\n\t\tszLine[val]=0;\n\t}\n\tREM_TRAIL_MARKS(szLine, \"\\r\\n\\t \")\n\n\t//strip all spaces and \\r\\n\\t\n\tline = szLine;\n\twhile (line[0] && strchr(\"\\n\\r\\t \", (char) line[0]))\n\t\tline ++;\n\n\n\t*fmt = GF_TXTIN_MODE_NONE;\n\tif ((line[0]=='{') && strstr(line, \"}{\")) *fmt = GF_TXTIN_MODE_SUB;\n\telse if (line[0] == '<') {\n\t\tchar *ext = gf_file_ext_start(filename);\n\t\tif (ext && !strnicmp(ext, \".ttxt\", 5)) *fmt = GF_TXTIN_MODE_TTXT;\n\t\telse if (ext && !strnicmp(ext, \".ttml\", 5)) *fmt = GF_TXTIN_MODE_TTML;\n\t\text = strstr(line, \"?>\");\n\t\tif (ext) ext += 2;\n\t\tif (ext && !ext[0]) {\n\t\t\tif (!gf_fgets(szLine, 2048, test))\n\t\t\t\tszLine[0] = '\\0';\n\t\t}\n\t\tif (strstr(szLine, \"x-quicktime-tx3g\") || strstr(szLine, \"text3GTrack\")) *fmt = GF_TXTIN_MODE_TEXML;\n\t\telse if (strstr(szLine, \"TextStream\")) *fmt = GF_TXTIN_MODE_TTXT;\n\t\telse if (strstr(szLine, \"<tt \") || strstr(szLine, \":tt \")) *fmt = GF_TXTIN_MODE_TTML;\n\t}\n\telse if (strstr(line, \"WEBVTT\") )\n\t\t*fmt = GF_TXTIN_MODE_WEBVTT;\n\telse if (strstr(line, \" --> \") )\n\t\t*fmt = GF_TXTIN_MODE_SRT; /* might want to change the default to WebVTT */\n\n\telse if (!strncmp(line, \"FWS\", 3) || !strncmp(line, \"CWS\", 3))\n\t\t*fmt = GF_TXTIN_MODE_SWF_SVG;\n\telse if (!strncmp(line, \"[Script Info]\", 13) )\n\t\t*fmt = GF_TXTIN_MODE_SSA;\n\n\tgf_fclose(test);\n\treturn GF_OK;\n}\n\n\n\nchar *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32 unicode_type)\n{\n\tu32 i, j, len;\n\tchar *sOK;\n\tchar szLineConv[2048];\n\tunsigned short *sptr;\n\n\tmemset(szLine, 0, sizeof(char)*lineSize);\n\tsOK = gf_fgets(szLine, lineSize, txt_in);\n\tif (!sOK) return NULL;\n\tif (unicode_type<=1) {\n\t\tj=0;\n\t\tlen = (u32) strlen(szLine);\n\t\tfor (i=0; i<len; i++) {\n\t\t\tif (!unicode_type && (szLine[i] & 0x80)) {\n\t\t\t\t/*non UTF8 (likely some win-CP)*/\n\t\t\t\tif ((szLine[i+1] & 0xc0) != 0x80) {\n\t\t\t\t\tif (j >= GF_ARRAY_LENGTH(szLineConv))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tszLineConv[j] = 0xc0 | ( (szLine[i] >> 6) & 0x3 );\n\t\t\t\t\tj++;\n\t\t\t\t\tszLine[i] &= 0xbf;\n\t\t\t\t}\n\t\t\t\t/*UTF8 2 bytes char*/\n\t\t\t\telse if ( (szLine[i] & 0xe0) == 0xc0) {\n\t\t\t\t\tif (j >= GF_ARRAY_LENGTH(szLineConv))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t/*UTF8 3 bytes char*/\n\t\t\t\telse if ( (szLine[i] & 0xf0) == 0xe0) {\n\t\t\t\t\tif (j+1 >= GF_ARRAY_LENGTH(szLineConv))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t/*UTF8 4 bytes char*/\n\t\t\t\telse if ( (szLine[i] & 0xf8) == 0xf0) {\n\t\t\t\t\tif (j+2 >= GF_ARRAY_LENGTH(szLineConv))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t} else {\n\t\t\t\t\ti+=1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (j >= GF_ARRAY_LENGTH(szLineConv))\n\t\t\t\tbreak;\n\n\t\t\tszLineConv[j] = szLine[i];\n\t\t\tj++;\n\n\n\t\t}\n\t\tif ( j >= GF_ARRAY_LENGTH(szLineConv) ) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[TXTIn] Line too long to convert to utf8 (len: %d)\\n\", len));\n\t\t\tj = GF_ARRAY_LENGTH(szLineConv) -1 ;\n\t\t}\n\t\tszLineConv[j] = 0;\n\t\tstrcpy(szLine, szLineConv);\n\t\treturn sOK;\n\t}\n\n#ifdef GPAC_BIG_ENDIAN\n\tif (unicode_type==3)\n#else\n\tif (unicode_type==2)\n#endif\n\t{\n\t\ti=0;\n\t\twhile (1) {\n\t\t\tchar c;\n\t\t\tif (!szLine[i] && !szLine[i+1]) break;\n\t\t\tc = szLine[i+1];\n\t\t\tszLine[i+1] = szLine[i];\n\t\t\tszLine[i] = c;\n\t\t\ti+=2;\n\t\t}\n\t}\n\tsptr = (u16 *)szLine;\n\ti = gf_utf8_wcstombs(szLineConv, 2048, (const unsigned short **) &sptr);\n\tif (i == GF_UTF8_FAIL) i = 0;\n\tszLineConv[i] = 0;\n\tstrcpy(szLine, szLineConv);\n\t/*this is ugly indeed: since input is UTF16-LE, there are many chances the gf_fgets never reads the \\0 after a \\n*/\n\tif (unicode_type==3) gf_fgetc(txt_in);\n\treturn sOK;\n}\n\n\nstatic void txtin_probe_duration(GF_TXTIn *ctx)\n{\n\tGF_Fraction64 dur;\n\tdur.num = 0;\n\n\tif (ctx->fmt == GF_TXTIN_MODE_SWF_SVG) {\n#ifndef GPAC_DISABLE_SWF_IMPORT\n\t\tu32 frame_count, frame_rate;\n\t\tgf_swf_get_duration(ctx->swf_parse, &frame_rate, &frame_count);\n\t\tif (frame_count) {\n\t\t\tGF_Fraction64 tdur;\n\t\t\ttdur.num = frame_count;\n\t\t\ttdur.den = frame_rate;\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, &PROP_FRAC64(tdur));\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PLAYBACK_MODE, &PROP_UINT(GF_PLAYBACK_MODE_FASTFORWARD ) );\n\t\t}\n#endif\n\t\treturn;\n\t}\n\tif ((ctx->fmt == GF_TXTIN_MODE_SRT) || (ctx->fmt == GF_TXTIN_MODE_WEBVTT) || (ctx->fmt == GF_TXTIN_MODE_SUB) || (ctx->fmt == GF_TXTIN_MODE_SSA)) {\n\t\tu64 pos = gf_ftell(ctx->src);\n\t\tgf_fseek(ctx->src, 0, SEEK_SET);\n\t\twhile (!gf_feof(ctx->src)) {\n\t\t\tu64 end;\n\t\t\tchar szLine[2048];\n\t\t\tchar *sOK = gf_text_get_utf8_line(szLine, 2048, ctx->src, ctx->unicode_type);\n\t\t\tif (!sOK) break;\n\t\t\tREM_TRAIL_MARKS(szLine, \"\\r\\n\\t \")\n\n\t\t\tif (ctx->fmt == GF_TXTIN_MODE_SUB) {\n\t\t\t\tchar szText[2048];\n\t\t\t\tu32 sframe, eframe;\n\t\t\t\tif (sscanf(szLine, \"{%d}{%d}%2047s\", &sframe, &eframe, szText) == 3) {\n\t\t\t\t\tif (ctx->fps.den)\n\t\t\t\t\t\tend = 1000 * eframe * ctx->fps.num / ctx->fps.den;\n\t\t\t\t\telse\n\t\t\t\t\t\tend = 1000 * eframe / 25;\n\t\t\t\t\tif (end > (u64) dur.num) dur.num = (s64) end;\n\t\t\t\t}\n\t\t\t} else if (ctx->fmt == GF_TXTIN_MODE_SSA) {\n\t\t\t\tif (strncmp(szLine, \"Dialogue: \", 10)) continue;\n\t\t\t\tchar *start_p = strchr(szLine+10, ',');\n\t\t\t\tif (!start_p) continue;\n\t\t\t\tchar *end_p = strchr(start_p+1, ',');\n\t\t\t\tif (!end_p) continue;\n\t\t\t\tend_p[0] = 0;\n\t\t\t\tend_p +=1;\n\t\t\t\tstart_p = strchr(end_p, ',');\n\t\t\t\tif (start_p) start_p[0] = 0;\n\n\t\t\t\tu32 eh, em, es, ems;\n\t\t\t\tif (sscanf(end_p, \"%u:%u:%u.%u\", &eh, &em, &es, &ems) != 4) {\n\t\t\t\t\teh = 0;\n\t\t\t\t\tif (sscanf(end_p, \"%u:%u.%u\", &em, &es, &ems) != 3) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tend = (3600*eh + 60*em + es)*1000 + ems;\n\t\t\t\tif (end > (u64) dur.num) dur.num = (s64) end;\n\t\t\t} else {\n\t\t\t\tu32 eh, em, es, ems;\n\t\t\t\tchar *start = strstr(szLine, \"-->\");\n\t\t\t\tif (!start) continue;\n\t\t\t\tstart+=3;\n\t\t\t\twhile (start[0] && ((start[0] == ' ') || (start[0] == '\\t'))) start++;\n\n\t\t\t\tif (sscanf(start, \"%u:%u:%u,%u\", &eh, &em, &es, &ems) != 4) {\n\t\t\t\t\teh = 0;\n\t\t\t\t\tif (sscanf(szLine, \"%u:%u,%u\", &em, &es, &ems) != 3) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tend = (3600*eh + 60*em + es)*1000 + ems;\n\t\t\t\tif (end > (u64) dur.num) dur.num = (s64) end;\n\t\t\t}\n\t\t}\n\t\tgf_fseek(ctx->src, pos, SEEK_SET);\n\t\tif (dur.num) {\n\t\t\tdur.den = 1000;\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, &PROP_FRAC64(dur));\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PLAYBACK_MODE, &PROP_UINT(GF_PLAYBACK_MODE_FASTFORWARD ) );\n\t\t}\n\t\treturn;\n\t}\n\tif ((ctx->fmt == GF_TXTIN_MODE_TTXT) || (ctx->fmt == GF_TXTIN_MODE_TEXML)) {\n\t\tu32 i=0;\n\t\tGF_XMLNode *node, *root = gf_xml_dom_get_root(ctx->parser);\n\t\twhile ((node = gf_list_enum(root->content, &i))) {\n\t\t\tu32 j;\n\t\t\tu64 duration;\n\t\t\tGF_XMLAttribute *att;\n\t\t\tif (node->type) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*sample text*/\n\t\t\tif ((ctx->fmt == GF_TXTIN_MODE_TTXT) && strcmp(node->name, \"TextSample\")) continue;\n\t\t\telse if ((ctx->fmt == GF_TXTIN_MODE_TEXML) && strcmp(node->name, \"sample\")) continue;\n\n\n\t\t\tj=0;\n\t\t\twhile ( (att=(GF_XMLAttribute*)gf_list_enum(node->attributes, &j))) {\n\t\t\t\tu32 h, m, s, ms;\n\t\t\t\tu64 ts=0;\n\t\t\t\tif (ctx->fmt == GF_TXTIN_MODE_TTXT) {\n\t\t\t\t\tif (strcmp(att->name, \"sampleTime\")) continue;\n\n\t\t\t\t\tif (sscanf(att->value, \"%u:%u:%u.%u\", &h, &m, &s, &ms) == 4) {\n\t\t\t\t\t\tts = (h*3600 + m*60 + s)*1000 + ms;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tts = (u32) (atof(att->value) * 1000);\n\t\t\t\t\t}\n\t\t\t\t\tif (ts > (u64) dur.num) dur.num = (s64) ts;\n\t\t\t\t} else {\n\t\t\t\t\tif (strcmp(att->name, \"duration\")) continue;\n\t\t\t\t\tduration = atoi(att->value);\n\t\t\t\t\tdur.num += (s32) ( (1000 * duration) / ctx->txml_timescale);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dur.num) {\n\t\t\tdur.den = 1000;\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, &PROP_FRAC64(dur));\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PLAYBACK_MODE, &PROP_UINT(GF_PLAYBACK_MODE_FASTFORWARD ) );\n\t\t}\n\t\treturn;\n\t}\n\n\tif (ctx->fmt == GF_TXTIN_MODE_TTML) {\n\t\tu32 i=0, k=0;\n\t\tGF_XMLNode *div_node;\n\n\t\twhile ((div_node = gf_list_enum(ctx->div_nodes_list, &k))) {\n\t\t\tGF_XMLNode *node;\n\t\t\twhile ((node = gf_list_enum(div_node->content, &i))) {\n\t\t\t\tGF_XMLNode *p_node;\n\t\t\t\tGF_XMLAttribute *att;\n\t\t\t\tu32 h, m, s, ms, p_idx=0;\n\t\t\t\tu64 ts_end=0;\n\t\t\t\th = m = s = ms = 0;\n\t\t\t\twhile ( (att = (GF_XMLAttribute*)gf_list_enum(node->attributes, &p_idx))) {\n\t\t\t\t\tif (strcmp(att->name, \"end\")) continue;\n\n\t\t\t\t\tif (sscanf(att->value, \"%u:%u:%u.%u\", &h, &m, &s, &ms) == 4) {\n\t\t\t\t\t\tts_end = (h*3600 + m*60+s)*1000+ms;\n\t\t\t\t\t} else if (sscanf(att->value, \"%u:%u:%u\", &h, &m, &s) == 3) {\n\t\t\t\t\t\tts_end = (h*3600 + m*60+s)*1000;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//or under a <span>\n\t\t\t\tp_idx = 0;\n\t\t\t\twhile ( (p_node = (GF_XMLNode*)gf_list_enum(node->content, &p_idx))) {\n\t\t\t\t\tu32 span_idx = 0;\n\t\t\t\t\twhile ( (att = (GF_XMLAttribute*)gf_list_enum(p_node->attributes, &span_idx))) {\n\t\t\t\t\t\tif (strcmp(att->name, \"end\")) continue;\n\t\t\t\t\t\tif (sscanf(att->value, \"%u:%u:%u.%u\", &h, &m, &s, &ms) == 4) {\n\t\t\t\t\t\t\tts_end = (h*3600 + m*60+s)*1000+ms;\n\t\t\t\t\t\t} else if (sscanf(att->value, \"%u:%u:%u\", &h, &m, &s) == 3) {\n\t\t\t\t\t\t\tts_end = (h*3600 + m*60+s)*1000;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ts_end > (u64) dur.num) dur.num = (s64) ts_end;\n\t\t\t}\n\t\t}\n\t\tif (dur.num) {\n\t\t\tdur.den = 1000;\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, &PROP_FRAC64(dur));\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PLAYBACK_MODE, &PROP_UINT(GF_PLAYBACK_MODE_FASTFORWARD ) );\n\t\t}\n\t\treturn;\n\t}\n\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] Duration probing not supported for format %d\\n\", ctx->fmt));\n}\n\nstatic GF_Err txtin_setup_srt(GF_Filter *filter, GF_TXTIn *ctx, Bool gen_dsi_only)\n{\n\tu32 ID, OCR_ES_ID, dsi_len, file_size=0;\n\tu8 *dsi;\n\tGF_TextSampleDescriptor *sd;\n\n\tif (!gen_dsi_only) {\n\t\tif (!ctx->unframed)\n\t\t\tctx->src = gf_fopen(ctx->file_name, \"rb\");\n\n\t\tif (!ctx->src) return GF_URL_ERROR;\n\n\t\tfile_size = (u32) gf_fsize(ctx->src);\n\n\t\tctx->unicode_type = gf_text_get_utf_type(ctx, ctx->src);\n\t\tif (ctx->unicode_type<0) {\n\t\t\tgf_fclose(ctx->src);\n\t\t\tctx->src = NULL;\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Unsupported SRT UTF encoding\\n\"));\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\t}\n\n\tif (!ctx->timescale) ctx->timescale = 1000;\n\tOCR_ES_ID = ID = 0;\n\n\tif (!ctx->unframed) {\n\t\tif (!ctx->opid) ctx->opid = gf_filter_pid_new(filter);\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_TEXT) );\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, &PROP_UINT(GF_CODECID_TX3G) );\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, &PROP_UINT(ctx->timescale) );\n\t\tif (file_size)\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DOWN_SIZE, &PROP_LONGUINT(file_size) );\n\n\t\tif (!ID) ID = 1;\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ID, &PROP_UINT(ID) );\n\t\tif (OCR_ES_ID) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CLOCK_ID, &PROP_UINT(OCR_ES_ID) );\n\t}\n\n\tif (ctx->width) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_WIDTH, &PROP_UINT(ctx->width) );\n\tif (ctx->height) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_HEIGHT, &PROP_UINT(ctx->height) );\n\tif (ctx->zorder) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ZORDER, &PROP_SINT(ctx->zorder) );\n\tif (ctx->lang) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_LANGUAGE, &PROP_STRING( ctx->lang) );\n\n\tsd = (GF_TextSampleDescriptor*)gf_odf_desc_new(GF_ODF_TX3G_TAG);\n\tsd->fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord));\n\tsd->font_count = 1;\n\tsd->fonts[0].fontID = 1;\n\tsd->fonts[0].fontName = gf_strdup(ctx->fontname ? ctx->fontname : \"Serif\");\n\tsd->back_color = 0x00000000;\t/*transparent*/\n\tsd->default_style.fontID = 1;\n\tsd->default_style.font_size = ctx->fontsize;\n\tsd->default_style.text_color = 0xFFFFFFFF;\t/*white*/\n\tsd->default_style.style_flags = 0;\n\tsd->horiz_justif = 1; /*center of scene*/\n\tsd->vert_justif = (s8) -1;\t/*bottom of scene*/\n\n\tif (ctx->nodefbox) {\n\t\tsd->default_pos.top = sd->default_pos.left = sd->default_pos.right = sd->default_pos.bottom = 0;\n\t} else if ((sd->default_pos.bottom==sd->default_pos.top) || (sd->default_pos.right==sd->default_pos.left)) {\n\t\tsd->default_pos.left = ctx->txtx;\n\t\tsd->default_pos.top = ctx->txty;\n\t\tsd->default_pos.right = ctx->width + sd->default_pos.left;\n\t\tsd->default_pos.bottom = ctx->height + sd->default_pos.top;\n\t}\n\n\t/*store attribs*/\n\tctx->style = sd->default_style;\n\tgf_odf_tx3g_write(sd, &dsi, &dsi_len);\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA_NO_COPY(dsi, dsi_len) );\n\n\tgf_odf_desc_del((GF_Descriptor *)sd);\n\n\tif (gen_dsi_only) return GF_OK;\n\n\tctx->default_color = ctx->style.text_color;\n\tctx->first_samp = GF_TRUE;\n\n\tctx->samp = gf_isom_new_text_sample();\n\tctx->prev_end = 0;\n\tif (!ctx->unframed) {\n\t\tctx->state = 0;\n\t\tctx->end = ctx->start = 0;\n\t\tctx->curLine = 0;\n\n\t\ttxtin_probe_duration(ctx);\n\t}\n\n\treturn GF_OK;\n}\n\nstatic void txtin_process_send_text_sample(GF_TXTIn *ctx, GF_TextSample *txt_samp, u64 ts, u32 duration, Bool is_rap)\n{\n\tGF_FilterPacket *dst_pck;\n\tu8 *pck_data;\n\tu32 size;\n\n\tif (!txt_samp)\n\t\treturn;\n\tif ((!txt_samp->text || !txt_samp->len) && ctx->no_empty)\n\t\treturn;\n\n\tif (ctx->seek_state==2) {\n\t\tDouble end = (Double) (ts+duration);\n\t\tend /= 1000;\n\t\tif (end < ctx->start_range) return;\n\t\tctx->seek_state = 0;\n\t}\n\n\tsize = gf_isom_text_sample_size(txt_samp);\n\n\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, size, &pck_data);\n\tif (!dst_pck) return;\n\n\tgf_bs_reassign_buffer(ctx->bs_w, pck_data, size);\n\tgf_isom_text_sample_write_bs(txt_samp, ctx->bs_w);\n\n\tts = gf_timestamp_rescale(ts, 1000, ctx->timescale);\n\tduration = (u32) gf_timestamp_rescale(duration, 1000, ctx->timescale);\n\n\tgf_filter_pck_set_sap(dst_pck, is_rap ? GF_FILTER_SAP_1 : GF_FILTER_SAP_NONE);\n\tgf_filter_pck_set_cts(dst_pck, ts);\n\tgf_filter_pck_set_duration(dst_pck, duration);\n\n\tgf_filter_pck_send(dst_pck);\n}\n\nstatic GF_Err parse_srt_line(GF_TXTIn *ctx, char *szLine, u32 *char_l, Bool *set_start_c, Bool *set_end_c)\n{\n\tu32 i, char_line, j, rem_styles, len;\n\tBool rem_color;\n\tchar *ptr = szLine;\n\tunsigned short uniLine[5000], uniText[5000], *sptr;\n\tchar szText[2048];\n\n\tlen = gf_utf8_mbstowcs(uniLine, 5000, (const char **) &ptr);\n\tif (len == GF_UTF8_FAIL) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] Invalid UTF data (line %d)\\n\", ctx->curLine));\n\t\tctx->state = 0;\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\ti=j=0;\n\trem_styles = 0;\n\trem_color = 0;\n\twhile (i<len) {\n\t\tu32 font_style = 0;\n\t\tu32 style_nb_chars = 0;\n\t\tu32 style_def_type = 0;\n\n\t\tif ( (uniLine[i]=='<') && (uniLine[i+2]=='>')) {\n\t\t\tstyle_nb_chars = 3;\n\t\t\tstyle_def_type = 1;\n\t\t}\n\t\telse if ( (uniLine[i]=='<') && (uniLine[i+1]=='/') && (uniLine[i+3]=='>')) {\n\t\t\tstyle_def_type = 2;\n\t\t\tstyle_nb_chars = 4;\n\t\t}\n\t\telse if (uniLine[i]=='<')  {\n\t\t\tconst unsigned short* src = uniLine + i;\n\t\t\tu32 alen = gf_utf8_wcstombs(szLine, 2048, (const unsigned short**) & src);\n\t\t\tif (alen == GF_UTF8_FAIL) alen = 0;\n\t\t\tszLine[alen] = 0;\n\t\t\tstrlwr(szLine);\n\t\t\tif (!strncmp(szLine, \"<font \", 6) ) {\n\t\t\t\tchar *a_sep = strstr(szLine, \"color\");\n\t\t\t\tif (a_sep) a_sep = strstr(szLine, \"=\");\n\t\t\t\tif (a_sep) a_sep++;\n\t\t\t\twhile (a_sep && a_sep[0]) {\n\t\t\t\t\tif (a_sep[0]!=' ') break;\n\t\t\t\t\ta_sep++;\n\t\t\t\t}\n\t\t\t\tif (a_sep) {\n\t\t\t\t\tchar *e_sep;\n\t\t\t\t\tif ((a_sep[0]=='\"') || ((a_sep[0]=='\\''))) {\n\t\t\t\t\t\te_sep = strchr(a_sep+1, a_sep[0]);\n\t\t\t\t\t\ta_sep++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\te_sep=a_sep;\n\t\t\t\t\t\twhile (e_sep[0]) {\n\t\t\t\t\t\t\tif (e_sep[0]==' ') break;\n\t\t\t\t\t\t\tif (e_sep[0]=='>') break;\n\t\t\t\t\t\t\te_sep++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (e_sep) {\n\t\t\t\t\t\tchar c_sep = e_sep[0];\n\t\t\t\t\t\te_sep[0] = 0;\n\t\t\t\t\t\tfont_style = gf_color_parse(a_sep);\n\t\t\t\t\t\te_sep[0] = c_sep;\n\t\t\t\t\t\tif (c_sep!='>')\n\t\t\t\t\t\t\te_sep = strchr(e_sep+1, '>');\n\t\t\t\t\t\tif (e_sep) {\n\t\t\t\t\t\t\tstyle_nb_chars = (u32) (1 + e_sep - szLine);\n\t\t\t\t\t\t\tstyle_def_type = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!strncmp(szLine, \"</font>\", 7) ) {\n\t\t\t\tstyle_nb_chars = 7;\n\t\t\t\tstyle_def_type = 2;\n\t\t\t\tfont_style = 0xFFFFFFFF;\n\t\t\t}\n\n\n\t\t\telse if (!strncmp(szLine, \"<strike>\", 8) ) {\n\t\t\t\tstyle_nb_chars = 8;\n\t\t\t\tstyle_def_type = 1;\n\t\t\t}\n\t\t\telse if (!strncmp(szLine, \"</strike>\", 9) ) {\n\t\t\t\tstyle_nb_chars = 9;\n\t\t\t\tstyle_def_type = 2;\n\t\t\t\tfont_style = 0xFFFFFFFF;\n\t\t\t}\n\t\t\t//skip unknown\n\t\t\telse {\n\t\t\t\tchar *a_sep = strstr(szLine, \">\");\n\t\t\t\tif (a_sep) {\n\t\t\t\t\tstyle_nb_chars = (u32) (1 + a_sep - szLine);\n\t\t\t\t\ti += style_nb_chars;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\t/*start of new style*/\n\t\tif (style_def_type==1)  {\n\t\t\t/*store prev style*/\n\t\t\tif (*set_end_c) {\n\t\t\t\tassert(*set_start_c);\n\t\t\t\tgf_isom_text_add_style(ctx->samp, &ctx->style);\n\t\t\t\t*set_end_c = *set_start_c = GF_FALSE;\n\t\t\t\tctx->style.style_flags &= ~rem_styles;\n\t\t\t\trem_styles = 0;\n\t\t\t\tif (rem_color) {\n\t\t\t\t\tctx->style.text_color = ctx->default_color;\n\t\t\t\t\trem_color = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (*set_start_c && (ctx->style.startCharOffset != j)) {\n\t\t\t\tctx->style.endCharOffset = *char_l + j;\n\t\t\t\tif (ctx->style.style_flags) gf_isom_text_add_style(ctx->samp, &ctx->style);\n\t\t\t}\n\t\t\tswitch (uniLine[i+1]) {\n\t\t\tcase 'b':\n\t\t\tcase 'B':\n\t\t\t\tctx->style.style_flags |= GF_TXT_STYLE_BOLD;\n\t\t\t\t*set_start_c = GF_TRUE;\n\t\t\t\tctx->style.startCharOffset = *char_l + j;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\tcase 'I':\n\t\t\t\tctx->style.style_flags |= GF_TXT_STYLE_ITALIC;\n\t\t\t\t*set_start_c = GF_TRUE;\n\t\t\t\tctx->style.startCharOffset = *char_l + j;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\tcase 'U':\n\t\t\t\tctx->style.style_flags |= GF_TXT_STYLE_UNDERLINED;\n\t\t\t\t*set_start_c = GF_TRUE;\n\t\t\t\tctx->style.startCharOffset = *char_l + j;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\tcase 'S':\n\t\t\t\tctx->style.style_flags |= GF_TXT_STYLE_STRIKETHROUGH;\n\t\t\t\t*set_start_c = GF_TRUE;\n\t\t\t\tctx->style.startCharOffset = *char_l + j;\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\tcase 'F':\n\t\t\t\tif (font_style) {\n\t\t\t\t\tctx->style.text_color = font_style;\n\t\t\t\t\t*set_start_c = GF_TRUE;\n\t\t\t\t\tctx->style.startCharOffset = *char_l + j;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti += style_nb_chars;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*end of prev style*/\n\t\tif (style_def_type==2)  {\n\t\t\tswitch (uniLine[i+2]) {\n\t\t\tcase 'b':\n\t\t\tcase 'B':\n\t\t\t\trem_styles |= GF_TXT_STYLE_BOLD;\n\t\t\t\t*set_end_c = GF_TRUE;\n\t\t\t\tctx->style.endCharOffset = *char_l + j;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\tcase 'I':\n\t\t\t\trem_styles |= GF_TXT_STYLE_ITALIC;\n\t\t\t\t*set_end_c = GF_TRUE;\n\t\t\t\tctx->style.endCharOffset = *char_l + j;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\tcase 'U':\n\t\t\t\trem_styles |= GF_TXT_STYLE_UNDERLINED;\n\t\t\t\t*set_end_c = GF_TRUE;\n\t\t\t\tctx->style.endCharOffset = *char_l + j;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\tcase 'S':\n\t\t\t\trem_styles |= GF_TXT_STYLE_STRIKETHROUGH;\n\t\t\t\t*set_end_c = GF_TRUE;\n\t\t\t\tctx->style.endCharOffset = *char_l + j;\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\tcase 'F':\n\t\t\t\tif (font_style) {\n\t\t\t\t\trem_color = 1;\n\t\t\t\t\t*set_end_c = GF_TRUE;\n\t\t\t\t\tctx->style.endCharOffset = *char_l + j;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti+=style_nb_chars;\n\t\t\tcontinue;\n\t\t}\n\t\t/*store style*/\n\t\tif (*set_end_c) {\n\t\t\tgf_isom_text_add_style(ctx->samp, &ctx->style);\n\t\t\t*set_end_c = GF_FALSE;\n\t\t\t*set_start_c = GF_TRUE;\n\t\t\tctx->style.startCharOffset = *char_l + j;\n\t\t\tctx->style.style_flags &= ~rem_styles;\n\t\t\trem_styles = 0;\n\t\t\tctx->style.text_color = ctx->default_color;\n\t\t\trem_color = 0;\n\t\t}\n\n\t\tuniText[j] = uniLine[i];\n\t\tj++;\n\t\ti++;\n\t}\n\t/*store last style*/\n\tif (*set_end_c) {\n\t\tgf_isom_text_add_style(ctx->samp, &ctx->style);\n\t\t*set_end_c = GF_FALSE;\n\t\t*set_start_c = GF_TRUE;\n\t\tctx->style.startCharOffset = *char_l + j;\n\t\tctx->style.style_flags &= ~rem_styles;\n\t}\n\n\tchar_line = j;\n\tuniText[j] = 0;\n\n\tsptr = (u16 *) uniText;\n\tlen = gf_utf8_wcstombs(szText, 5000, (const u16 **) &sptr);\n\tif (len == GF_UTF8_FAIL) len = 0;\n\n\tgf_isom_text_add_text(ctx->samp, szText, len);\n\t*char_l += char_line;\n\treturn GF_OK;\n}\n\nstatic GF_Err txtin_process_srt(GF_Filter *filter, GF_TXTIn *ctx, GF_FilterPacket *ipck)\n{\n\tu32 sh, sm, ss, sms, eh, em, es, ems, txt_line, char_len;\n\tBool set_start_char, set_end_char;\n\tu32 line;\n\tchar szLine[2048];\n\n\tif (!ctx->is_setup) {\n\t\tctx->is_setup = GF_TRUE;\n\t\tGF_Err e = txtin_setup_srt(filter, ctx, GF_FALSE);\n\t\tif (e || !ctx->unframed) return e;\n\t}\n\tif (!ctx->opid) return GF_NOT_SUPPORTED;\n\n\tif (!ctx->unframed) {\n\t\tif (!ctx->playstate) return GF_OK;\n\t\telse if (ctx->playstate==2) return GF_EOS;\n\t}\n\n\ttxt_line = 0;\n\tset_start_char = set_end_char = GF_FALSE;\n\tchar_len = 0;\n\n\tif (ctx->seek_state == 1) {\n\t\tctx->seek_state = 2;\n\t\tgf_fseek(ctx->src, 0, SEEK_SET);\n\t}\n\n\twhile (1) {\n\t\tBool is_empty = GF_FALSE;\n\t\tchar *sOK = gf_text_get_utf8_line(szLine, 2048, ctx->src, ctx->unicode_type);\n\n\t\tif (sOK) {\n\t\t\tREM_TRAIL_MARKS(szLine, \"\\r\\n\\t \")\n\n\t\t\tif (ctx->unicode_type<=1) is_empty = strlen(szLine) ? GF_FALSE : GF_TRUE;\n\t\t\telse is_empty =  (!szLine[0] && !szLine[1]) ? GF_TRUE : GF_FALSE;\n\t\t}\n\n\t\tif (!sOK || is_empty) {\n\t\t\tu32 utf_inc = (ctx->unicode_type<=1) ? 1 : 2;\n\t\t\tu32 nb_empty = utf_inc;\n\t\t\tu32 pos = (u32) gf_ftell(ctx->src);\n\t\t\tif (ctx->state) {\n\t\t\t\twhile (!gf_feof(ctx->src)) {\n\t\t\t\t\tsOK = gf_text_get_utf8_line(szLine+nb_empty, 2048-nb_empty, ctx->src, ctx->unicode_type);\n\t\t\t\t\tif (sOK) REM_TRAIL_MARKS((szLine+nb_empty), \"\\r\\n\\t \")\n\n\t\t\t\t\tif (!sOK) {\n\t\t\t\t\t\tgf_fseek(ctx->src, pos, SEEK_SET);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (!strlen(szLine+nb_empty)) {\n\t\t\t\t\t\tnb_empty+=utf_inc;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if (\tsscanf(szLine+nb_empty, \"%u\", &line) == 1) {\n\t\t\t\t\t\tgf_fseek(ctx->src, pos, SEEK_SET);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tu32 k;\n\t\t\t\t\t\tfor (k=0; k<nb_empty; k++) szLine[k] = '\\n';\n\t\t\t\t\t\tgoto force_line;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tctx->style.style_flags = 0;\n\t\t\tctx->style.text_color = 0xFFFFFFFF;\n\t\t\tctx->style.startCharOffset = ctx->style.endCharOffset = 0;\n\t\t\tif (txt_line) {\n\t\t\t\tif (ctx->prev_end && (ctx->start != ctx->prev_end) && (ctx->state<=2)) {\n\t\t\t\t\tGF_TextSample * empty_samp = gf_isom_new_text_sample();\n\t\t\t\t\ttxtin_process_send_text_sample(ctx, empty_samp, ctx->prev_end, (u32) (ctx->start - ctx->prev_end), GF_TRUE );\n\t\t\t\t\tgf_isom_delete_text_sample(empty_samp);\n\t\t\t\t}\n\n\t\t\t\tif (ctx->state<=2) {\n\t\t\t\t\ttxtin_process_send_text_sample(ctx, ctx->samp,  ctx->start, (u32) (ctx->end -  ctx->start), GF_TRUE);\n\t\t\t\t\tctx->prev_end = ctx->end;\n\t\t\t\t}\n\t\t\t\ttxt_line = 0;\n\t\t\t\tchar_len = 0;\n\t\t\t\tset_start_char = set_end_char = GF_FALSE;\n\t\t\t\tctx->style.startCharOffset = ctx->style.endCharOffset = 0;\n\t\t\t\tgf_isom_text_reset(ctx->samp);\n\n\t\t\t\tif (!ctx->unframed)\n\t\t\t\t\tgf_filter_pid_set_info(ctx->opid, GF_PROP_PID_DOWN_BYTES, &PROP_LONGUINT( gf_ftell(ctx->src )) );\n\t\t\t}\n\t\t\tctx->state = 0;\n\t\t\tif (!sOK) break;\n\t\t\tcontinue;\n\t\t}\n\nforce_line:\n\t\tswitch (ctx->state) {\n\t\tcase 0:\n\t\t\tif (sscanf(szLine, \"%u\", &line) != 1) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Bad SRT formatting - expecting number got \\\"%s\\\"\\n\", szLine));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (line != ctx->curLine + 1) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] Corrupted SRT frame %d after frame %d\\n\", line, ctx->curLine));\n\t\t\t}\n\t\t\tctx->curLine = line;\n\t\t\tctx->state = 1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (sscanf(szLine, \"%u:%u:%u,%u --> %u:%u:%u,%u\", &sh, &sm, &ss, &sms, &eh, &em, &es, &ems) != 8) {\n\t\t\t\tif (sscanf(szLine, \"%u:%u:%u.%u --> %u:%u:%u.%u\", &sh, &sm, &ss, &sms, &eh, &em, &es, &ems) != 8) {\n\t\t\t\t\tsh = eh = 0;\n\t\t\t\t\tif (sscanf(szLine, \"%u:%u,%u --> %u:%u,%u\", &sm, &ss, &sms, &em, &es, &ems) != 6) {\n\t\t\t\t\t\tif (sscanf(szLine, \"%u:%u.%u --> %u:%u.%u\", &sm, &ss, &sms, &em, &es, &ems) != 6) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] Error scanning SRT frame %d timing\\n\", ctx->curLine));\n\t\t\t\t    \t\tctx->state = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tctx->start = (3600*sh + 60*sm + ss)*1000 + sms;\n\t\t\tif (ctx->start < ctx->end) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] Overlapping SRT frame %d - starts \"LLD\" ms is before end of previous one \"LLD\" ms - adjusting time stamps\\n\", ctx->curLine, ctx->start, ctx->end));\n\t\t\t\tctx->start = ctx->end;\n\t\t\t}\n\n\t\t\tctx->end = (3600*eh + 60*em + es)*1000 + ems;\n\t\t\t/*make stream start at 0 by inserting a fake AU*/\n\t\t\tif (ctx->first_samp && (ctx->start > 0)) {\n\t\t\t\ttxtin_process_send_text_sample(ctx, ctx->samp, 0, (u32) ctx->start, GF_TRUE);\n\t\t\t}\n\t\t\tctx->style.style_flags = 0;\n\t\t\tctx->state = 2;\n\t\t\tif (ctx->end <= ctx->prev_end) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] Overlapping SRT frame %d end \"LLD\" is at or before previous end \"LLD\" - removing\\n\", ctx->curLine, ctx->end, ctx->prev_end));\n\t\t\t\tctx->start = ctx->end;\n\t\t\t\tctx->state = 3;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/*reset only when text is present*/\n\t\t\tctx->first_samp = GF_FALSE;\n\n\t\t\t/*go to line*/\n\t\t\tif (txt_line) {\n\t\t\t\tgf_isom_text_add_text(ctx->samp, \"\\n\", 1);\n\t\t\t\tchar_len += 1;\n\t\t\t}\n\n\t\t\tparse_srt_line(ctx, szLine, &char_len, &set_start_char, &set_end_char);\n\t\t\ttxt_line ++;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!ctx->unframed && gf_filter_pid_would_block(ctx->opid))\n\t\t\treturn GF_OK;\n\t}\n\n\t/*final flush*/\n\tif (!ctx->unframed && ctx->end && ! ctx->noflush) {\n\t\tgf_isom_text_reset(ctx->samp);\n\t\ttxtin_process_send_text_sample(ctx, ctx->samp, ctx->end, 0, GF_TRUE);\n\t\tctx->end = 0;\n\t}\n\tgf_isom_text_reset(ctx->samp);\n\n\treturn GF_EOS;\n}\n\n/* Structure used to pass importer and track data to the parsers without exposing the GF_MediaImporter structure\n   used by WebVTT and Flash->SVG */\ntypedef struct {\n\tGF_TXTIn *ctx;\n\tu32 timescale;\n\tu32 track;\n\tu32 descriptionIndex;\n} GF_ISOFlusher;\n\n#ifndef GPAC_DISABLE_VTT\n\nstatic GF_Err gf_webvtt_import_report(void *user, GF_Err e, char *message, const char *line)\n{\n\tGF_LOG(e ? GF_LOG_WARNING : GF_LOG_INFO, GF_LOG_PARSER, (\"[TXTIn] WebVTT line %s: %s\\n\", line, message) );\n\treturn e;\n}\n\nstatic void gf_webvtt_import_header(void *user, const char *config)\n{\n\tGF_TXTIn *ctx = (GF_TXTIn *)user;\n\tif (!ctx->hdr_parsed) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA((char *) config, (u32) (1+strlen(config)) ) );\n\t\tctx->hdr_parsed = GF_TRUE;\n\t\tgf_webvtt_parser_suspend(ctx->vttparser);\n\t}\n}\n\nstatic void gf_webvtt_flush_sample(void *user, GF_WebVTTSample *samp)\n{\n\tu64 start, end;\n\tGF_TXTIn *ctx = (GF_TXTIn *)user;\n\tGF_ISOSample *s;\n\n\tstart = gf_webvtt_sample_get_start(samp);\n\tend = gf_webvtt_sample_get_end(samp);\n\n\tif (ctx->seek_state==2) {\n\t\tDouble tsend = (Double) end;\n\t\ttsend /= 1000;\n\t\tif (tsend<ctx->start_range) return;\n\t\tctx->seek_state = 0;\n\t}\n\n\tif (ctx->no_empty && !gf_isom_webvtt_cues_count(samp))\n\t\ts = NULL;\n\telse\n\t\ts = gf_isom_webvtt_to_sample(samp);\n\n\tif (s) {\n\t\tGF_FilterPacket *pck;\n\t\tu8 *pck_data;\n\n\t\tpck = gf_filter_pck_new_alloc(ctx->opid, s->dataLength, &pck_data);\n\t\tif (pck) {\n\t\t\tmemcpy(pck_data, s->data, s->dataLength);\n\t\t\tgf_filter_pck_set_cts(pck, (u64) (ctx->timescale * start / 1000) );\n\t\t\tgf_filter_pck_set_sap(pck, GF_FILTER_SAP_1);\n\n\n\t\t\tif (end && (end>=start) ) {\n\t\t\t\tgf_filter_pck_set_duration(pck, (u32) (ctx->timescale * (end-start) / 1000) );\n\t\t\t}\n\t\t\tgf_filter_pck_send(pck);\n\t\t}\n\n\t\tgf_isom_sample_del(&s);\n\t}\n\tgf_webvtt_sample_del(samp);\n\n\tgf_filter_pid_set_info(ctx->opid, GF_PROP_PID_DOWN_BYTES, &PROP_LONGUINT( gf_ftell(ctx->src )) );\n\n\tif (gf_filter_pid_would_block(ctx->opid))\n\t\tgf_webvtt_parser_suspend(ctx->vttparser);\n\n}\n\nstatic GF_Err txtin_webvtt_setup(GF_Filter *filter, GF_TXTIn *ctx)\n{\n\tGF_Err e;\n\tu32 ID, OCR_ES_ID, file_size, w, h;\n\tBool is_srt;\n\tchar *ext;\n\n\tif (!ctx->unframed)\n\t\tctx->src = gf_fopen(ctx->file_name, \"rb\");\n\n\tif (ctx->opid && (ctx->playstate==2)) return GF_EOS;\n\tif (!ctx->src) return GF_URL_ERROR;\n\n\tfile_size = (u32) gf_fsize(ctx->src);\n\n\tctx->unicode_type = gf_text_get_utf_type(ctx, ctx->src);\n\tif (ctx->unicode_type<0) {\n\t\tgf_fclose(ctx->src);\n\t\tctx->src = NULL;\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Unsupported SRT UTF encoding\\n\"));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\tif (!ctx->unframed) {\n\t\text = gf_file_ext_start(ctx->file_name);\n\t\tis_srt = (ext && !strnicmp(ext, \".srt\", 4)) ? GF_TRUE : GF_FALSE;\n\t} else {\n\t\tis_srt = GF_TRUE;\n\t}\n\n\tif (!ctx->timescale) ctx->timescale = 1000;\n\tOCR_ES_ID = ID = 0;\n\n\tif (!ctx->opid) ctx->opid = gf_filter_pid_new(filter);\n\tif (!ctx->unframed) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_TEXT) );\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, &PROP_UINT(GF_CODECID_WEBVTT) );\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, &PROP_UINT(ctx->timescale) );\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DOWN_SIZE, &PROP_LONGUINT(file_size) );\n\t}\n\n\tw = ctx->width;\n\th = ctx->height;\n\tif (!ID) ID = 1;\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ID, &PROP_UINT(ID) );\n\tif (OCR_ES_ID) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CLOCK_ID, &PROP_UINT(OCR_ES_ID) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_WIDTH, &PROP_UINT(w) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_HEIGHT, &PROP_UINT(h) );\n\tif (ctx->zorder) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ZORDER, &PROP_SINT(ctx->zorder) );\n\tif (ctx->lang) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_LANGUAGE, &PROP_STRING( ctx->lang) );\n\n\tctx->vttparser = gf_webvtt_parser_new();\n\n\te = gf_webvtt_parser_init(ctx->vttparser, ctx->src, ctx->unicode_type, is_srt, ctx, gf_webvtt_import_report, gf_webvtt_flush_sample, gf_webvtt_import_header);\n\tif (e != GF_OK) {\n\t\tgf_webvtt_parser_del(ctx->vttparser);\n\t\tctx->vttparser = NULL;\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] WebVTT parser init error %s\\n\", gf_error_to_string(e) ));\n\t}\n\t//get the header\n\te = gf_webvtt_parser_parse(ctx->vttparser);\n\n\tif (!ctx->unframed)\n\t\ttxtin_probe_duration(ctx);\n\treturn e;\n}\n\nstatic GF_Err txtin_process_webvtt(GF_Filter *filter, GF_TXTIn *ctx, GF_FilterPacket *ipck)\n{\n\tGF_Err e;\n\n\tif (!ctx->is_setup) {\n\t\tctx->is_setup = GF_TRUE;\n\t\te = txtin_webvtt_setup(filter, ctx);\n\t\tif (e || !ctx->unframed) return e;\n\t}\n\tif (!ctx->vttparser) return (ctx->playstate==2) ? GF_EOS : GF_NOT_SUPPORTED;\n\n\tif (ctx->seek_state==1) {\n\t\tctx->seek_state = 2;\n\t\tgf_webvtt_parser_restart(ctx->vttparser);\n\t}\n\tif (ctx->unframed) {\n\t\tconst GF_PropertyValue *p;\n\t\tconst char *vtt_pre=NULL, *vtt_cueid=NULL, *vtt_settings=NULL;\n\t\tp = gf_filter_pck_get_property_str(ipck, \"vtt_pre\");\n\t\tif (p) vtt_pre = p->value.string;\n\t\tp = gf_filter_pck_get_property_str(ipck, \"vtt_cueid\");\n\t\tif (p) vtt_cueid = p->value.string;\n\t\tp = gf_filter_pck_get_property_str(ipck, \"vtt_settings\");\n\t\tif (p) vtt_settings = p->value.string;\n\n\t\te = gf_webvtt_parser_parse_payload(ctx->vttparser,\n\t\t\tgf_timestamp_rescale(ctx->start, ctx->timescale, 1000),\n\t\t\tgf_timestamp_rescale(ctx->end, ctx->timescale, 1000),\n\t\t\tvtt_pre, vtt_cueid, vtt_settings);\n\t} else {\n\t\te = gf_webvtt_parser_parse(ctx->vttparser);\n\t}\n\n\tif (e < GF_OK) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] WebVTT process error %s\\n\", gf_error_to_string(e) ));\n\t}\n\treturn e;\n}\n\n#endif /*GPAC_DISABLE_VTT*/\n\nstatic char *ttxt_parse_string(char *str, Bool strip_lines)\n{\n\tu32 i=0;\n\tu32 k=0;\n\tu32 len = (u32) strlen(str);\n\tu32 state = 0;\n\n\tif (!strip_lines) {\n\t\tfor (i=0; i<len; i++) {\n\t\t\tif ((str[i] == '\\r') && (str[i+1] == '\\n')) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tstr[k] = str[i];\n\t\t\tk++;\n\t\t}\n\t\tstr[k]=0;\n\t\treturn str;\n\t}\n\n\tif (str[0]!='\\'') return str;\n\tfor (i=0; i<len; i++) {\n\t\tif (str[i] == '\\'') {\n\n\t\t\tif (!state) {\n\t\t\t\tif (k) {\n\t\t\t\t\tstr[k]='\\n';\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t\tstate = 1; //!state;\n\t\t\t} else {\n\t\t\t\tif ( (i+1==len) ||\n\t\t\t\t        ((str[i+1]==' ') || (str[i+1]=='\\n') || (str[i+1]=='\\r') || (str[i+1]=='\\t') || (str[i+1]=='\\''))\n\t\t\t\t   ) {\n\t\t\t\t\tstate = !state;\n\t\t\t\t} else {\n\t\t\t\t\tstr[k] = str[i];\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (state) {\n\t\t\tstr[k] = str[i];\n\t\t\tk++;\n\t\t}\n\t}\n\tstr[k]=0;\n\treturn str;\n}\n\nstatic void ebu_ttd_remove_samples(GF_XMLNode *root, GF_XMLNode **out_body_node)\n{\n\tu32 idx = 0;\n\tGF_XMLNode *node = NULL;\n\t*out_body_node = NULL;\n\twhile ( (node = (GF_XMLNode*)gf_list_enum(root->content, &idx))) {\n\t\tif (!strcmp(node->name, \"body\")) {\n\t\t\tGF_XMLNode *body_node;\n\t\t\tu32 body_idx = 0;\n\t\t\t*out_body_node = node;\n\t\t\twhile ( (body_node = (GF_XMLNode*)gf_list_enum(node->content, &body_idx))) {\n\t\t\t\tif (!strcmp(body_node->name, \"div\")) {\n\t\t\t\t\tu32 body_num;\n\t\t\t\t\tbody_num = gf_list_count(body_node->content);\n\t\t\t\t\twhile (body_num--) {\n\t\t\t\t\t\tGF_XMLNode *content_node = (GF_XMLNode*)gf_list_get(body_node->content, 0);\n\t\t\t\t\t\tassert(gf_list_find(body_node->content, content_node) == 0);\n\t\t\t\t\t\tgf_list_rem(body_node->content, 0);\n\t\t\t\t\t\tgf_xml_dom_node_del(content_node);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nu64 ttml_get_timestamp_ex(char *value, u32 tick_rate, u32 *ttml_fps_num, u32 *ttml_fps_den, u32 *ttml_sfps)\n{\n\tu32 h, m, s, ms, f, sf;\n\tu64 ts = GF_FILTER_NO_TS;\n\tu32 len = (u32) strlen(value);\n\n\t//tick metrick - cannot be fractional\n\tif (len && (value[len-1]=='t')) {\n\t\tvalue[len-1] = 0;\n\t\tts = (s64) (atoi(value) * 1000);\n\t\tvalue[len-1] = 't';\n\t\tif (tick_rate)\n\t\t\tts /= tick_rate;\n\t}\n\t//hours metric, can be fractional\n\telse if (len && (value[len-1]=='h')) {\n\t\tvalue[len-1] = 0;\n\t\tts = (s64) (atof(value) * 1000 * 3600);\n\t\tvalue[len-1] = 'h';\n\t}\n\t//minutes metric, can be fractional\n\telse if (len && (value[len-1]=='m')) {\n\t\tvalue[len-1] = 0;\n\t\tts = (s64) (atof(value) * 1000 * 60);\n\t\tvalue[len-1] = 'm';\n\t}\n\telse if (len && (value[len-1]=='s')) {\n\t\t//milliseconds metric, can be fractional but we work at 1ms clock resolution anyway\n\t\tif ((len > 1) && (value[len-2]=='m')) {\n\t\t\tvalue[len-2] = 0;\n\t\t\tts = (s64) (atof(value));\n\t\t\tvalue[len-2] = 'm';\n\t\t}\n\t\t//seconds metric, can be fractional\n\t\telse {\n\t\t\tvalue[len-1] = 0;\n\t\t\tts = (s64) (atof(value) * 1000);\n\t\t\tvalue[len-1] = 's';\n\t\t}\n\t}\n\t//frames metric, can be fractional\n\telse if (len && (value[len-1]=='f')) {\n\t\tf = sf = 0;\n\t\tvalue[len-1] = 0;\n\t\tif (sscanf(value, \"%u.%u\", &f, &sf) != 2) {\n\t\t\tsscanf(value, \"%u\", &f);\n\t\t\tsf = 0;\n\t\t}\n\t\tvalue[len-1] = 'f';\n\n\t\tif (! *ttml_fps_num) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] time indicates frames but no frame rate set, assuming 25 FPS\\n\"));\n\t\t\t*ttml_fps_num = 25;\n\t\t\t*ttml_fps_den = 1;\n\t\t}\n\t\tif (sf && ! *ttml_sfps) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] time indicates subframes but no subFrameRate set, assuming 1\\n\"));\n\t\t\t*ttml_sfps = 1;\n\t\t}\n\t\tts = ((s64) 1000 * f * *ttml_fps_den) / *ttml_fps_num;\n\t\tif (sf)\n\t\t\tts += ((s64) 1000 * sf * *ttml_fps_den / *ttml_sfps) / *ttml_fps_num;\n\t}\n\telse if (sscanf(value, \"%u:%u:%u.%u\", &h, &m, &s, &ms) == 4) {\n\t\tts = (h*3600 + m*60+s)*1000+ms;\n\t}\n\telse if (sscanf(value, \"%u:%u:%u:%u.%u\", &h, &m, &s, &f, &sf) == 5) {\n\t\tts = (h*3600 + m*60+s)*1000;\n\t\tif (! *ttml_fps_num) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] time indicates frames but no frame rate set, assuming 25 FPS\\n\"));\n\t\t\t*ttml_fps_num = 25;\n\t\t\t*ttml_fps_den = 1;\n\t\t}\n\t\tif (! *ttml_sfps) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] time indicates subframes but no subFrameRate set, assuming 1\\n\"));\n\t\t\t*ttml_sfps = 1;\n\t\t}\n\t\tts += ((s64) 1000 * f * *ttml_fps_den) / *ttml_fps_num;\n\t\tts += ((s64) 1000 * sf * *ttml_fps_den / *ttml_sfps) / *ttml_fps_num;\n\t}\n\telse if (sscanf(value, \"%u:%u:%u:%u\", &h, &m, &s, &f) == 4) {\n\t\tts = (h*3600 + m*60+s)*1000;\n\t\tif (! *ttml_fps_num) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] time indicates frames but no frame rate set, assuming 25 FPS\\n\"));\n\t\t\t*ttml_fps_num = 25;\n\t\t\t*ttml_fps_den = 1;\n\t\t}\n\t\tts += ((s64) 1000 * f * *ttml_fps_den) / *ttml_fps_num;\n\t}\n\telse if (sscanf(value, \"%u:%u:%u\", &h, &m, &s) == 3) {\n\t\tts = (h*3600 + m*60+s)*1000;\n\t}\n\treturn ts;\n}\nstatic u64 ttml_get_timestamp(GF_TXTIn *ctx, char *value)\n{\n\treturn ttml_get_timestamp_ex(value, ctx->tick_rate, &ctx->ttml_fps_num, &ctx->ttml_fps_den, &ctx->ttml_sfps);\n\n}\nstatic GF_Err ttml_push_interval(GF_TXTIn *ctx, s64 begin, s64 end, TTMLInterval **out_interval)\n{\n\tu32 i;\n\tTTMLInterval *interval;\n\tif (begin==-1) return GF_OK;\n\tif (end==-1) return GF_OK;\n\n\tif (end < begin) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TTML EBU-TTD] invalid timings: \\\"begin\\\"=\"LLD\" , \\\"end\\\"=\"LLD\". Abort.\\n\", begin, end));\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\tinterval = NULL;\n\tfor (i=0; i<gf_list_count(ctx->intervals); i++) {\n\t\tinterval = gf_list_get(ctx->intervals, i);\n\n\t\t//generate a single sample for the input, merge interval\n\t\tif (! ctx->ttml_split) {\n\t\t\tif (interval->begin > begin) interval->begin = begin;\n\t\t\tif (interval->end < end) interval->end = end;\n\t\t\t*out_interval = interval;\n\t\t\treturn GF_OK;\n\t\t}\n\t\t//contained, do nothing\n\t\tif ((begin>=interval->begin) && (end<=interval->end)) {\n\t\t\t*out_interval = interval;\n\t\t\treturn GF_OK;\n\t\t}\n\t\t//not overlapping\n\t\tif ((end < interval->begin) || (begin > interval->end))\n\t\t\tcontinue;\n\n\t\t//new interval starts before current and end after, remove current and push extended interval\n\t\tif ((begin < interval->end) && (end > interval->end)) {\n\t\t\tif (begin>interval->begin)\n\t\t\t\tbegin = interval->begin;\n\t\t\tgf_list_rem(ctx->intervals, i);\n\t\t\tgf_free(interval);\n\t\t\treturn ttml_push_interval(ctx, begin, end, out_interval);\n\t\t}\n\t\t//new interval starts before current and end before, remove current and push rewinded\n\t\tif ((begin < interval->end) && (end <= interval->end)) {\n\t\t\tend = interval->end;\n\t\t\tif (begin>interval->begin)\n\t\t\t\tbegin = interval->begin;\n\t\t\tgf_list_rem(ctx->intervals, i);\n\t\t\tgf_free(interval);\n\t\t\treturn ttml_push_interval(ctx, begin, end, out_interval);\n\t\t}\n\t}\n\t//need a new interval\n\tGF_SAFEALLOC(interval, TTMLInterval);\n\tinterval->begin = begin;\n\tinterval->end = end;\n\t*out_interval = interval;\n\n\tfor (i=0; i<gf_list_count(ctx->intervals); i++) {\n\t\tTTMLInterval *an_interval = gf_list_get(ctx->intervals, i);\n\t\tif (an_interval->begin > interval->begin) {\n\t\t\treturn gf_list_insert(ctx->intervals, interval, i);\n\t\t}\n\t}\n\treturn gf_list_add(ctx->intervals, interval);\n}\n\nstatic void ttml_reset_intervals(GF_TXTIn *ctx)\n{\n\twhile (gf_list_count(ctx->intervals)) {\n\t\tTTMLInterval *ival = gf_list_pop_back(ctx->intervals);\n\t\tif (ival->resources) {\n\t\t\twhile (gf_list_count(ival->resources)) {\n\t\t\t\tTTMLRes *ires = gf_list_pop_back(ival->resources);\n\t\t\t\tif (!ires->global) {\n\t\t\t\t\tgf_free(ires->data);\n\t\t\t\t\tgf_free(ires);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_list_del(ival->resources);\n\t\t}\n\t\tgf_free(ival);\n\t}\n}\n\n#include <gpac/base_coding.h>\n\nstatic GF_Err ttml_push_res(GF_TXTIn *ctx, TTMLInterval *interval, u8 *f_data, u32 f_size)\n{\n\tGF_Err e;\n\tTTMLRes *res;\n\tGF_List *res_list;\n\tif (interval) {\n\t\tif (!interval->resources) {\n\t\t\tif (ctx->ttml_resources)\n\t\t\t\tinterval->resources = gf_list_clone(ctx->ttml_resources);\n\t\t\telse\n\t\t\t\tinterval->resources = gf_list_new();\n\t\t}\n\t\tres_list = interval->resources;\n\t} else {\n\t\tif (!ctx->ttml_resources) {\n\t\t\tctx->ttml_resources = gf_list_new();\n\t\t}\n\t\tres_list = ctx->ttml_resources;\n\t}\n\tif (!res_list) {\n\t\tgf_free(f_data);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tGF_SAFEALLOC(res, TTMLRes)\n\tif (!res) {\n\t\tgf_free(f_data);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tres->size = f_size;\n\tres->data = f_data;\n\tif (!interval)\n\t\tres->global = GF_TRUE;\n\n\te = gf_list_add(res_list, res);\n\tif (e) {\n\t\tgf_free(res);\n\t\tgf_free(f_data);\n\t\treturn e;\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err ttml_push_resources(GF_TXTIn *ctx, TTMLInterval *interval, GF_XMLNode *node, GF_XMLNode *parent_source_node)\n{\n\tu32 i;\n\tchar szURN[1024];\n\tu8 *f_data;\n\tu32 f_size;\n\tu32 idx;\n\tGF_Err e;\n\tGF_XMLAttribute *att, *data_type = NULL;\n\tGF_XMLNode *child;\n\tBool is_source = GF_FALSE;\n\tBool is_data = GF_FALSE;\n\tBool check_src = GF_FALSE;\n\n\tif (!ctx->ttml_embed)\n\t\treturn GF_OK;\n\n\tif (!strcmp(node->name, \"source\")) {\n\t\tis_source = GF_TRUE;\n\t\tcheck_src = GF_TRUE;\n\t}\n\telse if (!strcmp(node->name, \"data\")) {\n\t\tis_data = parent_source_node ? GF_TRUE : GF_FALSE;\n\t\tcheck_src = GF_TRUE;\n\t}\n\t//we don't embed chunks\n\telse if (!strcmp(node->name, \"chunk\")) {\n\t\treturn GF_OK;\n\t}\n\telse if (!strcmp(node->name, \"audio\") || !strcmp(node->name, \"font\") || !strcmp(node->name, \"image\")) {\n\t\tcheck_src = GF_TRUE;\n\t}\n\n\tif (check_src) {\n\t\ti = 0;\n\t\twhile ( (att = (GF_XMLAttribute*)gf_list_enum(node->attributes, &i))) {\n\t\t\tchar *url;\n\t\t\tif (!att->value) continue;\n\t\t\tif (is_data && !strcmp(att->name, \"type\")) {\n\t\t\t\tdata_type = att;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strcmp(att->name, \"src\")) continue;\n\t\t\tif (att->value[0]=='#') continue;\n\n\t\t\tif (!strncmp(att->value, \"file://\", 7)) {}\n\t\t\telse if (strstr(att->value, \"://\"))\n\t\t\t\tcontinue;\n\n\t\t\turl = gf_url_concatenate(ctx->file_name, att->value);\n\t\t\t//embed image\n\t\t\te = gf_file_load_data(url, &f_data, &f_size);\n\t\t\tgf_free(url);\n\t\t\tif (e) return e;\n\n\t\t\te = ttml_push_res(ctx, interval, f_data, f_size);\n\t\t\tif (e) return e;\n\n\t\t\tidx = gf_list_count(interval ? interval->resources : ctx->ttml_resources);\n\t\t\tgf_free(att->value);\n\t\t\tsprintf(szURN, \"urn:mpeg:14496-30:%d\", idx);\n\t\t\tatt->value = gf_strdup(szURN);\n\t\t\tif (!att->value) return GF_OUT_OF_MEM;\n\n\t\t\tctx->has_images = GF_TRUE;\n\t\t}\n\t}\n\n\ti = 0;\n\twhile ( (child = (GF_XMLNode*) gf_list_enum(node->content, &i))) {\n\t\tif (child->type) {\n\t\t\tif (!is_data) continue;\n\t\t\tu8 *data = child->name;\n\t\t\tu32 ilen = (u32) strlen(data);\n\t\t\tf_size = 3*ilen/4;\n\t\t\tf_data = gf_malloc(sizeof(u8) * f_size);\n\n\t\t\tf_size = gf_base64_decode(data, ilen, f_data, f_size);\n\n\t\t\te = ttml_push_res(ctx, interval, f_data, f_size);\n\t\t\tif (e) return e;\n\n\t\t\tidx = gf_list_count(interval ? interval->resources : ctx->ttml_resources);\n\t\t\tsprintf(szURN, \"urn:mpeg:14496-30:%d\", idx);\n\n\t\t\tGF_SAFEALLOC(att, GF_XMLAttribute)\n\t\t\tif (att) {\n\t\t\t\tatt->name = gf_strdup(\"src\");\n\t\t\t\tatt->value = gf_strdup(szURN);\n\t\t\t\tgf_list_add(parent_source_node->attributes, att);\n\t\t\t}\n\t\t\tif (!att || !att->value || !att->name) return GF_OUT_OF_MEM;\n\t\t\tif (data_type) {\n\t\t\t\tgf_list_del_item(node->attributes, data_type);\n\t\t\t\tgf_list_add(parent_source_node->attributes, data_type);\n\t\t\t}\n\t\t\tgf_xml_dom_node_reset(parent_source_node, GF_FALSE, GF_TRUE);\n\t\t\tctx->has_images = GF_TRUE;\n\t\t\treturn GF_OK;\n\t\t}\n\n\t\te = ttml_push_resources(ctx, interval, child, is_source ? node : NULL);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err ttml_rewrite_timestamp(GF_TXTIn *ctx, s64 ttml_zero, GF_XMLAttribute *att, s64 *value, Bool *drop)\n{\n\tu64 v;\n\tchar szTS[21];\n\tu32 h, m, s, ms;\n\t*value = ttml_get_timestamp(ctx, att->value);\n\tif (!ttml_zero)\n\t\treturn GF_OK;\n\n\tif (*value < ttml_zero) {\n\t\t*drop = GF_TRUE;\n\t\treturn GF_OK;\n\t}\n\n\t*value -= ttml_zero;\n\tv = (u64) (*value / 1000);\n\th = (u32) (v / 3600);\n\tm = (u32) (v - h*60) / 60;\n\ts = (u32) (v - h*3600 - m*60);\n\tms = (*value) % 1000;\n\n\tsnprintf(szTS, 20, \"%02d:%02d:%02d.%03d\", h, m, s, ms);\n\tszTS[20] = 0;\n\tgf_free(att->value);\n\tatt->value = gf_strdup(szTS);\n\treturn GF_OK;\n}\n\nstatic GF_Err ttml_setup_intervals(GF_TXTIn *ctx)\n{\n\tu32 k, i, nb_divs;\n\ts64 ttml_zero_ms = 0;\n\tGF_Err e;\n\tGF_XMLNode *root;\n\n\tif (!ctx->intervals)\n\t\tctx->intervals = gf_list_new();\n\telse\n\t\tttml_reset_intervals(ctx);\n\n\tctx->has_images = GF_FALSE;\n\troot = ctx->root_working_copy;\n\tfor (k=0; k<gf_list_count(root->content); k++) {\n\t\tGF_XMLNode *head = (GF_XMLNode*)gf_list_get(root->content, k);\n\t\tif (head->type) continue;\n\t\tif (strcmp(head->name, \"head\")) continue;\n\t\tttml_push_resources(ctx, NULL, head, NULL);\n\t\tbreak;\n\t}\n\n\troot = gf_xml_dom_get_root(ctx->parser);\n\tif (ctx->ttml_zero) {\n\t\tif (ctx->ttml_zero[0]=='T')\n\t\t\tttml_zero_ms = ttml_get_timestamp(ctx, (char *) ctx->ttml_zero+1);\n\t\telse\n\t\t\tttml_zero_ms = ttml_get_timestamp(ctx, (char *) ctx->ttml_zero);\n\t}\n\n\tnb_divs = gf_list_count(ctx->div_nodes_list);\n\tfor (i=0; i<nb_divs; i++) {\n\t\tu32 nb_children;\n\t\tGF_XMLNode *div_node = gf_list_get(ctx->div_nodes_list, i);\n\t\tnb_children = gf_list_count(div_node->content);\n\n\t\tfor (k=0; k<nb_children; k++) {\n\t\t\tTTMLInterval *ival=NULL;\n\t\t\tu32 p_idx;\n\t\t\tBool drop = GF_FALSE;\n\t\t\tGF_XMLAttribute *p_att;\n\t\t\tGF_XMLNode *p_node;\n\t\t\ts64 begin=-1, end=-1;\n\t\t\tGF_XMLNode *adiv_child = (GF_XMLNode*)gf_list_get(div_node->content, k);\n\t\t\tif (adiv_child->type) continue;\n\t\t\te = gf_xml_get_element_check_namespace(adiv_child, \"p\", root->ns);\n\t\t\tif (e) continue;\n\n\t\t\tp_idx = 0;\n\t\t\twhile ( (p_att = (GF_XMLAttribute*)gf_list_enum(adiv_child->attributes, &p_idx))) {\n\t\t\t\tif (!strcmp(p_att->name, \"begin\")) {\n\t\t\t\t\te = ttml_rewrite_timestamp(ctx, ttml_zero_ms, p_att, &begin, &drop);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t}\n\t\t\t\tif (!strcmp(p_att->name, \"end\")) {\n\t\t\t\t\te = ttml_rewrite_timestamp(ctx, ttml_zero_ms, p_att, &end, &drop);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (drop) {\n\t\t\t\tgf_xml_dom_node_del(adiv_child);\n\t\t\t\tgf_list_rem(div_node->content, k);\n\t\t\t\tk--;\n\t\t\t\tnb_children--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\te = ttml_push_interval(ctx, begin, end, &ival);\n\t\t\tif (e) return e;\n\n\t\t\te = ttml_push_resources(ctx, ival, adiv_child, NULL);\n\t\t\tif (e) return e;\n\n\t\t\tp_idx = 0;\n\t\t\twhile ( (p_node = (GF_XMLNode*)gf_list_enum(adiv_child->content, &p_idx))) {\n\t\t\t\ts64 s_begin=-1, s_end=-1;\n\t\t\t\te = gf_xml_get_element_check_namespace(p_node, \"span\", root->ns);\n\t\t\t\tif (e) continue;\n\n\t\t\t\tu32 span_idx = 0;\n\t\t\t\tGF_XMLAttribute *span_att;\n\t\t\t\twhile ( (span_att = (GF_XMLAttribute*)gf_list_enum(p_node->attributes, &span_idx))) {\n\t\t\t\t\tif (!strcmp(span_att->name, \"begin\")) {\n\t\t\t\t\t\te = ttml_rewrite_timestamp(ctx, ttml_zero_ms, span_att, &s_begin, &drop);\n\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t} else if (!strcmp(span_att->name, \"end\")) {\n\t\t\t\t\t\te = ttml_rewrite_timestamp(ctx, ttml_zero_ms, span_att, &s_end, &drop);\n\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\te = ttml_push_interval(ctx, s_begin, s_end, &ival);\n\t\t\t\tif (e) return e;\n\n\t\t\t\te = ttml_push_resources(ctx, ival, p_node, NULL);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t}\n\t}\n\n\t//empty doc\n\tif (!gf_list_count(ctx->intervals)) {\n\t\tTTMLInterval *interval;\n\t\tGF_SAFEALLOC(interval, TTMLInterval);\n\t\tinterval->begin = interval->end = 0;\n\t\tgf_list_add(ctx->intervals, interval);\n\t}\n\n#ifndef GPAC_DISABLE_LOG\n\tif (gf_log_tool_level_on(GF_LOG_PARSER, GF_LOG_DEBUG)) {\n\t\tfor (k=0; k<gf_list_count(ctx->intervals); k++) {\n\t\t\tTTMLInterval *ival = gf_list_get(ctx->intervals, k);\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[TTML EBU-TTD] Interval %d: \"LLU\"-\"LLU\"\\n\", k+1, ival->begin, ival->end));\n\t\t}\n\t}\n#endif\n\treturn GF_OK;\n}\n\nGF_Err ttml_parse_root(GF_XMLNode *root, const char **lang, u32 *tick_rate, u32 *ttml_fps_num, u32 *ttml_fps_den, u32 *ttml_sfps)\n{\n\t/*** root (including language) ***/\n\tGF_XMLAttribute *att;\n\tu32 i;\n\tu32 sub_fps_num = 0;\n\tu32 sub_fps_den = 0;\n\ti=0;\n\t*lang = NULL;\n\t*tick_rate = 0;\n\t*ttml_fps_num = 0;\n\t*ttml_fps_den = 0;\n\t*ttml_sfps = 0;\n\n\twhile ( (att = (GF_XMLAttribute *)gf_list_enum(root->attributes, &i))) {\n\t\tconst char *att_name;\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[TTML] Found root attribute name %s, value %s\\n\", att->name, att->value));\n\n\t\tatt_name = strchr(att->name, ':');\n\t\tif (att_name) att_name++;\n\t\telse att_name = att->name;\n\n\t\tif (!strcmp(att->name, \"xmlns\")) {\n\t\t\tif (strcmp(att->value, TTML_NAMESPACE)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TTML] XML Namespace %s not recognized, expecting %s\\n\", att->name, att->value, TTML_NAMESPACE));\n\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t}\n\t\t}\n\t\telse if (!strcmp(att->name, \"xml:lang\") && att->value && strlen(att->value)) {\n\t\t\t*lang = att->value;\n\t\t}\n\t\telse if (!strcmp(att_name, \"tickRate\") && att->value) {\n\t\t\t*tick_rate = atoi(att->value);\n\t\t}\n\t\telse if (!strcmp(att_name, \"frameRate\") && att->value) {\n\t\t\t*ttml_fps_num = atoi(att->value);\n\t\t\t*ttml_fps_den = 1;\n\t\t}\n\t\telse if (!strcmp(att_name, \"frameRateMultiplier\") && att->value) {\n\t\t\tchar *sep = strchr(att->value, ' ');\n\t\t\tif (!sep) sep = strchr(att->value, '\\t');\n\t\t\tif (sep) {\n\t\t\t\tu8 c = sep[0];\n\t\t\t\tsep[0] = 0;\n\t\t\t\tsub_fps_num = atoi(sep);\n\t\t\t\tsep[0] = c;\n\t\t\t\twhile ((sep[0]==' ') || (sep[0]=='\\t'))\n\t\t\t\t\tsep++;\n\t\t\t\tsub_fps_den = atoi(sep);\n\t\t\t}\n\t\t}\n\t\telse if (!strcmp(att_name, \"subFrameRate\") && att->value) {\n\t\t\t*ttml_sfps = atoi(att->value);\n\t\t}\n\t}\n\n\tif (sub_fps_num && sub_fps_den && *ttml_fps_num) {\n\t\t*ttml_fps_num *= sub_fps_num;\n\t\t*ttml_fps_den = sub_fps_den;\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err gf_text_ttml_setup(GF_Filter *filter, GF_TXTIn *ctx)\n{\n\tGF_Err e;\n\tu32 i, ID;\n\tu64 file_size;\n\tGF_XMLNode *root, *node, *body_node;\n\tconst char *lang = ctx->lang;\n\n\n\tctx->is_setup = GF_TRUE;\n\tctx->parser = gf_xml_dom_new();\n\te = gf_xml_dom_parse(ctx->parser, ctx->file_name, ttxt_dom_progress, ctx);\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Error parsing TTML file: Line %d - %s. Abort.\\n\", gf_xml_dom_get_line(ctx->parser), gf_xml_dom_get_error(ctx->parser) ));\n\t\tctx->is_setup = GF_TRUE;\n\t\tctx->non_compliant_ttml = GF_TRUE;\n\t\treturn e;\n\t}\n\troot = gf_xml_dom_get_root(ctx->parser);\n\tif (!root) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Error parsing TTML file: no root XML element found. Abort.\\n\"));\n\t\tctx->non_compliant_ttml = GF_TRUE;\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\t/*look for TTML*/\n\tif (gf_xml_get_element_check_namespace(root, \"tt\", NULL) != GF_OK) {\n\t\tif (root->ns) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"TTML file not recognized: root element is \\\"%s:%s\\\" (check your namespaces)\\n\", root->ns, root->name));\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"TTML file not recognized: root element is \\\"%s\\\"\\n\", root->name));\n\t\t}\n\t\tctx->non_compliant_ttml = GF_TRUE;\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[TXTIn] TTML EBU-TTD detected\\n\"));\n\n\troot = gf_xml_dom_get_root(ctx->parser);\n\n\te = ttml_parse_root(root, &lang, &ctx->tick_rate, &ctx->ttml_fps_num, &ctx->ttml_fps_den, &ctx->ttml_sfps);\n\tif (e) {\n\t\tctx->non_compliant_ttml = GF_TRUE;\n\t\treturn e;\n\t}\n\t//locate body\n\tbody_node = NULL;\n\ti=0;\n\twhile ( (node = (GF_XMLNode*)gf_list_enum(root->content, &i))) {\n\t\tif (node->type) {\n\t\t\tcontinue;\n\t\t}\n\t\te = gf_xml_get_element_check_namespace(node, \"body\", root->ns);\n\t\tif (e == GF_BAD_PARAM) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] ignored \\\"%s\\\" node, check your namespaces\\n\", node->name));\n\t\t} else if (e == GF_OK) {\n\t\t\tif (body_node) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TTML EBU-TTD] duplicated \\\"body\\\" element. Abort.\\n\"));\n\t\t\t\tctx->non_compliant_ttml = GF_TRUE;\n\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t}\n\t\t\tbody_node = node;\n\t\t}\n\t}\n\tif (!body_node) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[TTML EBU-TTD] \\\"body\\\" element not found, assuming empty doc\\n\"));\n\t}\n\n\tif (!ctx->div_nodes_list) {\n\t\tctx->div_nodes_list = gf_list_new();\n\t\tif (!ctx->div_nodes_list) return GF_OUT_OF_MEM;\n\t} else {\n\t\tgf_list_reset(ctx->div_nodes_list);\n\t}\n\n\tif (body_node) {\n\t\ti=0;\n\t\twhile ( (node = (GF_XMLNode*)gf_list_enum(body_node->content, &i))) {\n\t\t\tif (!node->type) {\n\t\t\t\te = gf_xml_get_element_check_namespace(node, \"div\", root->ns);\n\t\t\t\tif (e == GF_BAD_PARAM) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] ignored \\\"%s\\\" node, check your namespaces\\n\", node->name));\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_list_add(ctx->div_nodes_list, node);\n\t\t}\n\t}\n\tfile_size = ctx->end;\n\tif (!ctx->timescale) ctx->timescale = 1000;\n\n\tif (!ctx->opid) ctx->opid = gf_filter_pid_new(filter);\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_TEXT) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, &PROP_UINT(GF_CODECID_SUBS_XML) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, &PROP_UINT(ctx->timescale) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DOWN_SIZE, &PROP_LONGUINT(file_size) );\n\n\tID = 1;\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ID, &PROP_UINT(ID) );\n\tif (ctx->width) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_WIDTH, &PROP_UINT(ctx->width) );\n\tif (ctx->height) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_HEIGHT, &PROP_UINT(ctx->height) );\n\tif (ctx->zorder) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ZORDER, &PROP_SINT(ctx->zorder) );\n\tif (lang) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_LANGUAGE, &PROP_STRING( lang) );\n\tgf_filter_pid_set_property_str(ctx->opid, \"meta:xmlns\", &PROP_STRING(TTML_NAMESPACE) );\n\n\t/*** body ***/\n\tctx->parser_working_copy = gf_xml_dom_new();\n\te = gf_xml_dom_parse(ctx->parser_working_copy, ctx->file_name, NULL, NULL);\n\tassert (e == GF_OK);\n\tctx->root_working_copy = gf_xml_dom_get_root(ctx->parser_working_copy);\n\tassert(ctx->root_working_copy);\n\n\tif (body_node) {\n\t\t/*remove all the sample entries (instances in body) entries from the working copy, we will add each sample in this clone DOM  to create full XML of each sample*/\n\t\tebu_ttd_remove_samples(ctx->root_working_copy, &ctx->body_node);\n\t\tif (!ctx->body_node) {\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t} else {\n\t\tctx->body_node = NULL;\n\t}\n\n\tctx->current_tt_interval = 0;\n\n\tctx->last_sample_duration = 0;\n\tctx->end = 0;\n\tctx->first_samp = GF_TRUE;\n\n\ttxtin_probe_duration(ctx);\n\n\te = ttml_setup_intervals(ctx);\n\tif (e) return e;\n\n\tif (ctx->has_images) {\n\t\tchar *mime_cfg = \"application/ttml+xml;codecs=im1i\";\n\t\tgf_filter_pid_set_property_str(ctx->opid, \"meta:mime\", &PROP_STRING(mime_cfg) );\n\t} else {\n\t\tgf_filter_pid_set_property_str(ctx->opid, \"meta:mime\", NULL);\n\t}\n\treturn GF_OK;\n}\n\nstatic Bool ttml_check_range(TTMLInterval *interval, s64 ts_begin, s64 ts_end)\n{\n\t//if in current interval, push node\n\tif ((ts_begin != -1) && (ts_end != -1) && ((ts_begin>=interval->begin) && (ts_end<=interval->end))\n\t) {\n\t\treturn GF_TRUE;\n\t}\n\t//begin not set, end set: in range if end less than interval end range\n\telse if ((ts_begin==-1) && (ts_end != -1) && (ts_end<=interval->end)) {\n\t\treturn GF_TRUE;\n\t}\n\t//begin set, end not set: in range if begin greater than interval begin range\n\telse if ((ts_begin!=-1) && (ts_end==-1) && (ts_begin>=interval->begin)) {\n\t\treturn GF_TRUE;\n\t}\n\treturn GF_FALSE;\n}\n\nstatic GF_Err ttml_send_empty_sample(GF_TXTIn *ctx, u64 sample_start, u64 sample_end)\n{\n\t//we are not splitting, don't inject empty sample\n\tif (! ctx->ttml_split) return GF_OK;\n\tif (ctx->no_empty) return GF_OK;\n\n\tGF_List *bck = ctx->root_working_copy->content;\n\tctx->root_working_copy->content = gf_list_new();\n\tchar *samp_text = gf_xml_dom_serialize_root((GF_XMLNode*)ctx->root_working_copy, GF_FALSE, GF_FALSE);\n\tgf_list_del(ctx->root_working_copy->content);\n\tctx->root_working_copy->content = bck;\n\tif (!samp_text) return GF_OUT_OF_MEM;\n\n\tchar *txt_str = ttxt_parse_string(samp_text, GF_TRUE);\n\tif (!txt_str) txt_str = \"\";\n\tu32 txt_len = (u32) strlen(txt_str);\n\tu8 *pck_data;\n\tGF_FilterPacket *pck = gf_filter_pck_new_alloc(ctx->opid, txt_len, &pck_data);\n\tif (!pck) {\n\t\tgf_free(samp_text);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tmemcpy(pck_data, txt_str, txt_len);\n\tgf_free(samp_text);\n\n\tgf_filter_pck_set_sap(pck, GF_FILTER_SAP_1);\n\n\tu64 cts = gf_timestamp_rescale(sample_start, 1000, ctx->timescale);\n\tif (ctx->ttml_cts.num>=0) {\n\t\tcts += gf_timestamp_rescale(ctx->ttml_cts.num, ctx->ttml_cts.den, ctx->timescale);\n\t\tcts -= ctx->cts_first_interval;\n\t}\n\tgf_filter_pck_set_cts(pck, cts);\n\n\tif (sample_end >= sample_start) {\n\t\tu64 dur = gf_timestamp_rescale(sample_end - sample_start, 1000, ctx->timescale);\n\t\tgf_filter_pck_set_duration(pck, (u32) dur);\n\t}\n\n\treturn gf_filter_pck_send(pck);\n}\n\nstatic GF_Err gf_text_process_ttml(GF_Filter *filter, GF_TXTIn *ctx, GF_FilterPacket *ipck)\n{\n\tGF_Err e;\n\tGF_XMLNode *root;\n\tu32 i, nb_res_interval=0, k, nb_div_nodes;\n\tchar *samp_text=NULL;\n\tGF_List *emb_resources = NULL;\n\tTTMLInterval *interval;\n\tBool sample_empty = GF_TRUE;\n\n\tif (!ctx->is_setup) return gf_text_ttml_setup(filter, ctx);\n\tif (ctx->non_compliant_ttml || !ctx->opid) return GF_NOT_SUPPORTED;\n\tif (!ctx->playstate) return GF_OK;\n\telse if (ctx->playstate==2) return GF_EOS;\n\n\tif (ctx->seek_state==1) {\n\t\tctx->seek_state = 2;\n\t\tctx->current_tt_interval = 0;\n\t}\n\n\tinterval = gf_list_get(ctx->intervals, ctx->current_tt_interval);\n\tif (!interval) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[TTML EBU-TTD] last_sample_duration=\"LLU\", last_sample_end=\"LLU\"\\n\", ctx->last_sample_duration, ctx->end));\n\n\t\tgf_filter_pid_set_info_str( ctx->opid, \"ttxt:last_dur\", &PROP_UINT((u32) ctx->last_sample_duration) );\n\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\treturn GF_EOS;\n\t}\n\tctx->current_tt_interval++;\n\n\temb_resources = interval->resources ? interval->resources : ctx->ttml_resources;\n\tnb_res_interval = gf_list_count(emb_resources);\n\n\troot = gf_xml_dom_get_root(ctx->parser);\n\n\tnb_div_nodes = gf_list_count(ctx->div_nodes_list);\n\tfor (k=0; k<nb_div_nodes; k++) {\n\t\tBool has_content = GF_FALSE;\n\t\tGF_XMLNode *div_node = gf_list_get(ctx->div_nodes_list, k);\n\t\tu32 nb_children = gf_list_count(div_node->content);\n\n\t\tGF_XMLNode *copy_div_node = gf_list_get(ctx->body_node->content, k);\n\n\t\tfor (i=0; i < nb_children; i++) {\n\t\t\tGF_XMLNode *p_node;\n\t\t\tGF_XMLAttribute *p_att;\n\t\t\tu32 p_idx = 0;\n\t\t\ts64 ts_begin = -1, ts_end = -1;\n\t\t\tBool in_range;\n\t\t\tGF_XMLNode *div_child = (GF_XMLNode*)gf_list_get(div_node->content, i);\n\t\t\tif (div_child->type) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\te = gf_xml_get_element_check_namespace(div_child, \"p\", root->ns);\n\t\t\tif (e == GF_BAD_PARAM) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] ignored \\\"%s\\\" node, check your namespaces\\n\", div_child->name));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\n\t\t\t//sample is either in the <p> ...\n\t\t\tp_idx = 0;\n\t\t\twhile ( (p_att = (GF_XMLAttribute*)gf_list_enum(div_child->attributes, &p_idx))) {\n\t\t\t\tif (!strcmp(p_att->name, \"begin\")) {\n\t\t\t\t\tif (ts_begin != -1) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TTML EBU-TTD] duplicated \\\"begin\\\" attribute. Abort.\\n\"));\n\t\t\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t}\n\t\t\t\t\tts_begin = ttml_get_timestamp(ctx, p_att->value);\n\t\t\t\t} else if (!strcmp(p_att->name, \"end\")) {\n\t\t\t\t\tif (ts_end != -1) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TTML EBU-TTD] duplicated \\\"end\\\" attribute. Abort.\\n\"));\n\t\t\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t}\n\t\t\t\t\tts_end = ttml_get_timestamp(ctx, p_att->value);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tin_range = ttml_check_range(interval, ts_begin, ts_end);\n\t\t\tif (in_range) {\n\t\t\t\tGF_XMLNode *prev_child = i ? (GF_XMLNode*) gf_list_get(div_node->content, i-1) : NULL;\n\t\t\t\tif (prev_child && prev_child->type) {\n\t\t\t\t\tgf_xml_dom_append_child(copy_div_node, prev_child);\n\t\t\t\t}\n\t\t\t\te = gf_xml_dom_append_child(copy_div_node, div_child);\n\t\t\t\tassert(e == GF_OK);\n\t\t\t\thas_content = GF_TRUE;\n\t\t\t}\n\n\t\t\t//or under a <span>\n\t\t\tp_idx = 0;\n\t\t\twhile ( (p_node = (GF_XMLNode*)gf_list_enum(div_child->content, &p_idx))) {\n\t\t\t\tu32 span_idx = 0;\n\t\t\t\tGF_XMLAttribute *span_att;\n\t\t\t\te = gf_xml_get_element_check_namespace(p_node, \"span\", root->ns);\n\t\t\t\tif (e == GF_BAD_PARAM) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] ignored \\\"%s\\\" node, check your namespaces\\n\", p_node->name));\n\t\t\t\t}\n\t\t\t\telse if (e)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tts_begin = ts_end = -1;\n\t\t\t\twhile ( (span_att = (GF_XMLAttribute*)gf_list_enum(p_node->attributes, &span_idx))) {\n\t\t\t\t\tif (!strcmp(span_att->name, \"begin\")) {\n\t\t\t\t\t\tif (ts_begin != -1) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TTML EBU-TTD] duplicated \\\"begin\\\" attribute under <span>. Abort.\\n\"));\n\t\t\t\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tts_begin = ttml_get_timestamp(ctx, span_att->value);\n\t\t\t\t\t} else if (!strcmp(span_att->name, \"end\")) {\n\t\t\t\t\t\tif (ts_end != -1) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TTML EBU-TTD] duplicated \\\"end\\\" attribute under <span>. Abort.\\n\"));\n\t\t\t\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tts_end = ttml_get_timestamp(ctx, span_att->value);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*append the entire <p> and break (we cannot split the text content)*/\n\t\t\t\tin_range = ttml_check_range(interval, ts_begin, ts_end);\n\t\t\t\tif (in_range) {\n\t\t\t\t\tGF_XMLNode *prev_child = i ? (GF_XMLNode*) gf_list_get(div_node->content, i-1) : NULL;\n\t\t\t\t\tif (prev_child && prev_child->type) {\n\t\t\t\t\t\tgf_xml_dom_append_child(copy_div_node, prev_child);\n\t\t\t\t\t}\n\t\t\t\t\te = gf_xml_dom_append_child(copy_div_node, div_child);\n\t\t\t\t\tassert(e == GF_OK);\n\t\t\t\t\thas_content = GF_TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (has_content) {\n\t\t\tGF_XMLNode *last_child = (GF_XMLNode*) gf_list_last(div_node->content);\n\t\t\tif (last_child && last_child->type) {\n\t\t\t\tgf_xml_dom_append_child(copy_div_node, last_child);\n\t\t\t}\n\t\t\tsample_empty = GF_FALSE;\n\t\t}\n\t}\n\n\t//empty doc\n\tif (!ctx->body_node)\n\t\tsample_empty = GF_FALSE;\n\n\tif (! sample_empty) {\n\t\tsamp_text = gf_xml_dom_serialize_root((GF_XMLNode*)ctx->root_working_copy, GF_FALSE, GF_FALSE);\n\n\t\tfor (k=0; k<nb_div_nodes; k++) {\n\t\t\tGF_XMLNode *copy_div_node = gf_list_get(ctx->body_node->content, k);\n\t\t\tif (!copy_div_node->type)\n\t\t\t\tgf_list_reset(copy_div_node->content);\n\t\t}\n\t}\n\n\tif (samp_text) {\n\t\tGF_FilterPacket *pck;\n\t\tu8 *pck_data;\n\t\tBool skip_pck = GF_FALSE;\n\t\tu32 txt_len;\n\t\tu32 res_len = 0;\n\t\tchar *txt_str;\n\n\n\t\tif (interval->begin < (s64) ctx->end) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TTML EBU-TTD] Error computing overlapped intervals! \\\"begin\\\" is \"LLD\" , last \\\"end\\\" was \"LLD\". Abort.\\n\", interval->begin, ctx->end));\n\t\t\te = GF_NOT_SUPPORTED;\n\t\t\tgoto exit;\n\t\t}\n\n\t\ttxt_str = ttxt_parse_string(samp_text, GF_TRUE);\n\t\tif (!txt_str) txt_str = \"\";\n\t\ttxt_len = (u32) strlen(txt_str);\n\n\t\tfor (i=0; i<nb_res_interval; i++) {\n\t\t\tTTMLRes *res = gf_list_get(emb_resources, i);\n\t\t\tres_len += res->size;\n\t\t}\n\n\t\tif (ctx->first_samp) {\n\t\t\tctx->cts_first_interval = 0;\n\t\t\t//start from 0\n\t\t\tif (ctx->ttml_cts.num==-1) {\n\t\t\t\tinterval->begin = 0;\n\t\t\t} else if (ctx->ttml_cts.num>=0) {\n\t\t\t\tctx->cts_first_interval = gf_timestamp_rescale(interval->begin, 1000, ctx->timescale);\n\t\t\t}\n\t\t}\n\n\t\tif (ctx->seek_state==2) {\n\t\t\tDouble end = (Double) interval->end;\n\t\t\tend /= ctx->timescale;\n\t\t\tif (end<ctx->start_range) skip_pck = GF_TRUE;\n\t\t\telse ctx->seek_state = 0;\n\t\t}\n\n\n\t\tif (!ctx->first_samp && ((s64)ctx->end < interval->begin)) {\n\t\t\tttml_send_empty_sample(ctx, ctx->end, interval->begin);\n\t\t}\n\n\t\tctx->first_samp = GF_FALSE;\n\t\tctx->last_sample_duration = interval->end - interval->begin;\n\n\t\tctx->end = interval->end;\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"ts_begin=\"LLD\", ts_end=\"LLD\", last_sample_duration=\"LLU\" (real duration: \"LLU\"), last_sample_end=\"LLU\"\\n\", interval->begin, interval->end, interval->end - ctx->end, ctx->last_sample_duration, ctx->end));\n\n\t\tif (!skip_pck) {\n\t\t\tpck = gf_filter_pck_new_alloc(ctx->opid, txt_len+res_len, &pck_data);\n\t\t\tif (!pck) {\n\t\t\t\tgf_free(samp_text);\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tmemcpy(pck_data, txt_str, txt_len);\n\t\t\tgf_filter_pck_set_sap(pck, GF_FILTER_SAP_1);\n\n\t\t\tu64 cts = gf_timestamp_rescale(interval->begin, 1000, ctx->timescale);\n\t\t\tif (ctx->ttml_cts.num>=0) {\n\t\t\t\tcts += gf_timestamp_rescale(ctx->ttml_cts.num, ctx->ttml_cts.den, ctx->timescale);\n\t\t\t\tcts -= ctx->cts_first_interval;\n\t\t\t}\n\t\t\tgf_filter_pck_set_cts(pck, cts);\n\n\t\t\tif (!ctx->ttml_split && (ctx->ttml_dur.num>0) && ctx->ttml_dur.den) {\n\t\t\t\tctx->last_sample_duration = gf_timestamp_rescale(ctx->ttml_dur.num, ctx->ttml_dur.den, ctx->timescale);\n\t\t\t\tgf_filter_pck_set_duration(pck, (u32) ctx->last_sample_duration);\n\t\t\t} else {\n\t\t\t\tif (interval->end >= interval->begin) {\n\t\t\t\t\tu64 dur = gf_timestamp_rescale(interval->end - interval->begin, 1000, ctx->timescale);\n\t\t\t\t\tgf_filter_pck_set_duration(pck, (u32) dur);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (res_len) {\n\t\t\t\tGF_BitStream *subs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\t\tu8 *subs_data;\n\t\t\t\tu32 subs_size;\n\t\t\t\t//subs 0\n\t\t\t\tgf_bs_write_u32(subs, 0);\n\t\t\t\tgf_bs_write_u32(subs, txt_len);\n\t\t\t\tgf_bs_write_u32(subs, 0);\n\t\t\t\tgf_bs_write_u8(subs, 0);\n\t\t\t\tgf_bs_write_u8(subs, 0);\n\n\t\t\t\tpck_data += txt_len;\n\t\t\t\tfor (i=0; i<nb_res_interval; i++) {\n\t\t\t\t\tTTMLRes *res = gf_list_get(emb_resources, i);\n\t\t\t\t\tmemcpy(pck_data, res->data, res->size);\n\t\t\t\t\tpck_data += res->size;\n\n\t\t\t\t\t//subs >0\n\t\t\t\t\tgf_bs_write_u32(subs, 0);\n\t\t\t\t\tgf_bs_write_u32(subs, res->size);\n\t\t\t\t\tgf_bs_write_u32(subs, 0);\n\t\t\t\t\tgf_bs_write_u8(subs, 0);\n\t\t\t\t\tgf_bs_write_u8(subs, 0);\n\t\t\t\t}\n\t\t\t\tgf_bs_get_content(subs, &subs_data, &subs_size);\n\t\t\t\tgf_bs_del(subs);\n\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_SUBS, &PROP_DATA_NO_COPY(subs_data, subs_size) );\n\t\t\t}\n\t\t\tgf_filter_pck_send(pck);\n\t\t}\n\n\t\tgf_free(samp_text);\n\t\tsamp_text = NULL;\n\t} else {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] empty sample (begin=\"LLD\", end=\"LLD\"). Skip.\\n\", interval->begin, interval->end));\n\t}\n\n\treturn GF_OK;\n\n\nexit:\n\tif (!ctx->non_compliant_ttml) {\n\t\tctx->non_compliant_ttml = GF_TRUE;\n\t\tgf_filter_pid_set_discard(ctx->ipid, GF_TRUE);\n\t}\n\treturn e;\n}\n\n#ifndef GPAC_DISABLE_SWF_IMPORT\n\nstatic GF_Err swf_svg_add_iso_sample(void *user, const u8 *data, u32 length, u64 timestamp, Bool isRap)\n{\n\tGF_FilterPacket *pck;\n\tu8 *pck_data;\n\tGF_TXTIn *ctx = (GF_TXTIn *)user;\n\n\tif (ctx->seek_state==2) {\n\t\tDouble ts = (Double) timestamp;\n\t\tts/=1000;\n\t\tif (ts<ctx->start_range) return GF_OK;\n\t\tctx->seek_state = 0;\n\t}\n\n\tpck = gf_filter_pck_new_alloc(ctx->opid, length, &pck_data);\n\tif (pck) {\n\t\tmemcpy(pck_data, data, length);\n\t\tgf_filter_pck_set_cts(pck, (u64) (ctx->timescale*timestamp/1000) );\n\t\tgf_filter_pck_set_sap(pck, isRap ? GF_FILTER_SAP_1 : GF_FILTER_SAP_NONE);\n\t\tgf_filter_pck_set_framing(pck, GF_TRUE, GF_FALSE);\n\n\t\tgf_filter_pck_send(pck);\n\t}\n\n\tif (gf_filter_pid_would_block(ctx->opid))\n\t\tctx->do_suspend = GF_TRUE;\n\treturn GF_OK;\n}\n\nstatic GF_Err swf_svg_add_iso_header(void *user, const u8 *data, u32 length, Bool isHeader)\n{\n\tGF_TXTIn *ctx = (GF_TXTIn *)user;\n\n\tif (isHeader) {\n\t\tif (!ctx->hdr_parsed) {\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA((char *)data, (u32) ( strlen(data)+1 ) )  );\n\t\t\tctx->hdr_parsed = GF_TRUE;\n\t\t}\n\t} else if (!ctx->seek_state) {\n\t\tGF_FilterPacket *pck;\n\t\tu8 *pck_data;\n\t\tpck = gf_filter_pck_new_alloc(ctx->opid, length, &pck_data);\n\t\tif (pck) {\n\t\t\tmemcpy(pck_data, data, length);\n\t\t\tgf_filter_pck_set_framing(pck, GF_FALSE, GF_TRUE);\n\n\t\t\tgf_filter_pck_send(pck);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err gf_text_swf_setup(GF_Filter *filter, GF_TXTIn *ctx)\n{\n\tGF_Err e;\n\tu32 ID;\n\n\tctx->swf_parse = gf_swf_reader_new(NULL, ctx->file_name);\n\te = gf_swf_read_header(ctx->swf_parse);\n\tif (e) return e;\n\tgf_swf_reader_set_user_mode(ctx->swf_parse, ctx, swf_svg_add_iso_sample, swf_svg_add_iso_header);\n\n\tif (!ctx->timescale) ctx->timescale = 1000;\n\n\tif (!ctx->opid) ctx->opid = gf_filter_pid_new(filter);\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_TEXT) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, &PROP_UINT(GF_CODECID_SIMPLE_TEXT) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, &PROP_UINT(ctx->timescale) );\n//\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DOWN_SIZE, &PROP_UINT(file_size) );\n\n\t//patch for old arch\n\tctx->width = FIX2INT(ctx->swf_parse->width);\n\tctx->height = FIX2INT(ctx->swf_parse->height);\n\tif (!ctx->width && !ctx->height) {\n\t\tctx->width = 400;\n\t\tctx->height = 60;\n\t}\n\tID = 1;\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ID, &PROP_UINT(ID) );\n\tif (ctx->width) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_WIDTH, &PROP_UINT(ctx->width) );\n\tif (ctx->height) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_HEIGHT, &PROP_UINT(ctx->height) );\n\tif (ctx->zorder) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ZORDER, &PROP_SINT(ctx->zorder) );\n\tif (ctx->lang) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_LANGUAGE, &PROP_STRING( ctx->lang) );\n\n\tgf_filter_pid_set_property_str(ctx->opid, \"meta:mime\", &PROP_STRING(\"image/svg+xml\") );\n\n#ifndef GPAC_DISABLE_SVG\n\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] swf -> svg not fully migrated, using SWF flags 0 and no flatten angle. Patch welcome\\n\"));\n\te = swf_to_svg_init(ctx->swf_parse, 0, 0);\n#endif\n\n\t//SWF->BIFS is handled in ctx loader, no need to define it here\n\ttxtin_probe_duration(ctx);\n\n\treturn e;\n}\n\nstatic GF_Err gf_text_process_swf(GF_Filter *filter, GF_TXTIn *ctx, GF_FilterPacket *ipck)\n{\n\tGF_Err e=GF_OK;\n\n\tif (!ctx->is_setup) {\n\t\tctx->is_setup = GF_TRUE;\n\t\treturn gf_text_swf_setup(filter, ctx);\n\t}\n\tif (!ctx->opid) return GF_NOT_SUPPORTED;\n\n\tif (ctx->seek_state==1) {\n\t\tctx->seek_state = 2;\n\t\tgf_swf_reader_del(ctx->swf_parse);\n\t\tctx->swf_parse = gf_swf_reader_new(NULL, ctx->file_name);\n\t\tgf_swf_read_header(ctx->swf_parse);\n\t\tgf_swf_reader_set_user_mode(ctx->swf_parse, ctx, swf_svg_add_iso_sample, swf_svg_add_iso_header);\n\t}\n\n\tctx->do_suspend = GF_FALSE;\n\t/*parse all tags*/\n\twhile (e == GF_OK) {\n\t\te = swf_parse_tag(ctx->swf_parse);\n\t\tif (ctx->do_suspend) return GF_OK;\n\t}\n\tif (e==GF_EOS) {\n\t\tif (ctx->swf_parse->finalize) {\n\t\t\tctx->swf_parse->finalize(ctx->swf_parse);\n\t\t\tctx->swf_parse->finalize = NULL;\n\t\t}\n\t}\n\treturn e;\n}\n/* end of SWF Importer */\n\n#else\n\n#ifndef GPAC_DISABLE_ZLIB\nstatic GF_Err gf_text_process_swf(GF_Filter *filter, GF_TXTIn *ctx)\n{\n\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"Warning: GPAC was compiled without SWF import support, can't import file.\\n\"));\n\treturn GF_NOT_SUPPORTED;\n}\n#endif\n\n\n#endif /*GPAC_DISABLE_SWF_IMPORT*/\n\nstatic GF_Err gf_text_process_sub(GF_Filter *filter, GF_TXTIn *ctx, GF_FilterPacket *ipck)\n{\n\tu32 i, j, len, line;\n\tGF_TextSample *samp;\n\tDouble ts_scale;\n\tchar szLine[2048], szTime[41], szText[2048];\n\n\t//same setup as for srt\n\tif (!ctx->is_setup) {\n\t\tctx->is_setup = GF_TRUE;\n\t\treturn txtin_setup_srt(filter, ctx, GF_FALSE);\n\t}\n\tif (!ctx->opid) return GF_NOT_SUPPORTED;\n\tif (!ctx->playstate) return GF_OK;\n\telse if (ctx->playstate==2) return GF_EOS;\n\n\tif (ctx->seek_state==1) {\n\t\tctx->seek_state = 2;\n\t\tgf_fseek(ctx->src, 0, SEEK_SET);\n\t}\n\n\tif (ctx->fps.den && ctx->fps.num) {\n\t\tts_scale = ((Double) ctx->fps.num) / ctx->fps.den;\n\t} else {\n\t\tts_scale = 25;\n\t}\n\n\tline = 0;\n\n\twhile (1) {\n\t\tchar *sOK = gf_text_get_utf8_line(szLine, 2048, ctx->src, ctx->unicode_type);\n\t\tif (!sOK) break;\n\n\t\tREM_TRAIL_MARKS(szLine, \"\\r\\n\\t \")\n\n\t\tline++;\n\t\tlen = (u32) strlen(szLine);\n\t\tif (!len) continue;\n\n\t\ti=0;\n\t\tif (szLine[i] != '{') {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Bad SUB file (line %d): expecting \\\"{\\\" got \\\"%c\\\"\\n\", line, szLine[i]));\n\t\t\tcontinue;\n\t\t}\n\t\twhile (szLine[i+1] && szLine[i+1]!='}') {\n\t\t\tszTime[i] = szLine[i+1];\n\t\t\ti++;\n\t\t\tif (i>=40) break;\n\t\t}\n\t\tszTime[i] = 0;\n\t\tctx->start = atoi(szTime);\n\t\tif (ctx->start < ctx->end) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] corrupted SUB frame (line %d) - starts (at %d ms) before end of previous one (%d ms) - adjusting time stamps\\n\", line, ctx->start, ctx->end));\n\t\t\tctx->start = ctx->end;\n\t\t}\n\t\tj=i+2;\n\t\ti=0;\n\t\tif (szLine[i+j] != '{') {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] Bad SUB file - expecting \\\"{\\\" got \\\"%c\\\"\\n\", szLine[i]));\n\t\t\tcontinue;\n\t\t}\n\t\twhile (szLine[i+1+j] && szLine[i+1+j]!='}') {\n\t\t\tszTime[i] = szLine[i+1+j];\n\t\t\ti++;\n\t\t\tif (i>=40) break;\n\t\t}\n\t\tszTime[i] = 0;\n\t\tctx->end = atoi(szTime);\n\t\tj+=i+2;\n\n\t\tif (ctx->start > ctx->end) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] corrupted SUB frame (line %d) - ends (at %d ms) before start of current frame (%d ms) - skipping\\n\", line, ctx->end, ctx->start));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ctx->start && ctx->first_samp) {\n\t\t\tsamp = gf_isom_new_text_sample();\n\t\t\ttxtin_process_send_text_sample(ctx, samp, 0, (u32) (ts_scale*ctx->start), GF_TRUE);\n\t\t\tctx->first_samp = GF_FALSE;\n\t\t\tgf_isom_delete_text_sample(samp);\n\t\t}\n\n\t\tfor (i=j; i<len; i++) {\n\t\t\tif (szLine[i]=='|') {\n\t\t\t\tszText[i-j] = '\\n';\n\t\t\t} else {\n\t\t\t\tszText[i-j] = szLine[i];\n\t\t\t}\n\t\t}\n\t\tszText[i-j] = 0;\n\n\t\tif (ctx->prev_end) {\n\t\t\tsamp = gf_isom_new_text_sample();\n\t\t\ttxtin_process_send_text_sample(ctx, samp, (u64) (ts_scale*(s64)ctx->prev_end), (u32) (ts_scale*(ctx->start - ctx->prev_end)), GF_TRUE);\n\t\t\tgf_isom_delete_text_sample(samp);\n\t\t}\n\n\t\tsamp = gf_isom_new_text_sample();\n\t\tgf_isom_text_add_text(samp, szText, (u32) strlen(szText) );\n\t\ttxtin_process_send_text_sample(ctx, samp, (u64) (ts_scale*(s64)ctx->start), (u32) (ts_scale*(ctx->end - ctx->start)), GF_TRUE);\n\t\tgf_isom_delete_text_sample(samp);\n\n\t\tctx->prev_end = ctx->end;\n\n\t\tgf_filter_pid_set_info(ctx->opid, GF_PROP_PID_DOWN_BYTES, &PROP_LONGUINT( gf_ftell(ctx->src )) );\n\n\t\tif (gf_filter_pid_would_block(ctx->opid))\n\t\t\treturn GF_OK;\n\t}\n\t/*final flush*/\n\tif (ctx->end && !ctx->noflush) {\n\t\tsamp = gf_isom_new_text_sample();\n\t\ttxtin_process_send_text_sample(ctx, samp, (u64) (ts_scale*(s64)ctx->end), 0, GF_TRUE);\n\t\tgf_isom_delete_text_sample(samp);\n\t}\n\n\tgf_filter_pid_set_info_str( ctx->opid, \"ttxt:last_dur\", &PROP_UINT(0) );\n\n\treturn GF_EOS;\n}\n\nstatic GF_Err gf_text_process_ssa(GF_Filter *filter, GF_TXTIn *ctx, GF_FilterPacket *ipck)\n{\n\tu32 i, j, len, line;\n\tGF_TextSample *samp;\n\tchar szLine[2048], szText[2048];\n\n\t//same setup as for srt\n\tif (!ctx->is_setup) {\n\t\tctx->is_setup = GF_TRUE;\n\t\tGF_Err e = txtin_setup_srt(filter, ctx, GF_FALSE);\n\t\tif (e || !ctx->unframed) return e;\n\t}\n\tif (!ctx->opid) return GF_NOT_SUPPORTED;\n\tif (!ctx->unframed) {\n\t\tif (!ctx->playstate) return GF_OK;\n\t\telse if (ctx->playstate==2) return GF_EOS;\n\t}\n\n\tif (ctx->seek_state==1) {\n\t\tctx->seek_state = 2;\n\t\tgf_fseek(ctx->src, 0, SEEK_SET);\n\t}\n\n\tline = 0;\n\n\twhile (1) {\n\t\tchar *start_p, *end_p;\n\t\tu32 eh, em, es, ems, nb_c;\n\t\tchar *sOK = gf_text_get_utf8_line(szLine, 2048, ctx->src, ctx->unicode_type);\n\t\tif (!sOK) break;\n\n\t\tREM_TRAIL_MARKS(szLine, \"\\r\\n\\t \")\n\n\t\tline++;\n\t\tlen = (u32) strlen(szLine);\n\t\tif (!len) continue;\n\n\t\tif (!ctx->unframed) {\n\t\t\tif (strncmp(szLine, \"Dialogue: \", 10)) continue;\n\n\t\t\tstart_p = strchr(szLine+10, ',');\n\t\t\tif (!start_p) continue;\n\t\t\tend_p = strchr(start_p+1, ',');\n\t\t\tif (!end_p) continue;\n\t\t\tend_p[0] = 0;\n\t\t\tstart_p++;\n\t\t\tif (sscanf(start_p, \"%u:%u:%u.%u\", &eh, &em, &es, &ems) != 4) {\n\t\t\t\teh = 0;\n\t\t\t\tif (sscanf(start_p, \"%u:%u.%u\", &em, &es, &ems) != 3) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tctx->start = (3600*eh + 60*em + es)*1000 + ems;\n\n\t\t\tstart_p = end_p+1;\n\t\t\tend_p = strchr(start_p, ',');\n\t\t\tif (!end_p) continue;\n\t\t\tend_p[0] = 0;\n\n\t\t\tif (sscanf(start_p, \"%u:%u:%u.%u\", &eh, &em, &es, &ems) != 4) {\n\t\t\t\teh = 0;\n\t\t\t\tif (sscanf(start_p, \"%u:%u.%u\", &em, &es, &ems) != 3) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tctx->end = (3600*eh + 60*em + es)*1000 + ems;\n\t\t\t//skip 6 commas\n\t\t\tstart_p = end_p+1;\n\t\t\tnb_c=6;\n\t\t} else {\n\t\t\tstart_p = szLine;\n\t\t\tnb_c=8;\n\t\t}\n\n\t\twhile (nb_c) {\n\t\t\tend_p = strchr(start_p, ',');\n\t\t\tif (!end_p) break;\n\t\t\tstart_p = end_p+1;\n\t\t\tnb_c--;\n\t\t}\n\t\tif (nb_c) continue;\n\n\t\tif (ctx->start > ctx->end) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] corrupted SSA frame (line %d) - ends (at %u ms) before start of current frame (%u ms) - skipping\\n\", line, ctx->end, ctx->start));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*make stream start at 0 by inserting a fake AU*/\n\t\tif (ctx->first_samp && (ctx->start > 0)) {\n\t\t\ttxtin_process_send_text_sample(ctx, ctx->samp, 0, (u32) ctx->start, GF_TRUE);\n\t\t\tctx->first_samp = GF_FALSE;\n\t\t}\n\t\telse if (ctx->prev_end && (ctx->start != ctx->prev_end) && (ctx->state<=2)) {\n\t\t\tGF_TextSample * empty_samp = gf_isom_new_text_sample();\n\t\t\ttxtin_process_send_text_sample(ctx, empty_samp, ctx->prev_end, (u32) (ctx->start - ctx->prev_end), GF_TRUE );\n\t\t\tgf_isom_delete_text_sample(empty_samp);\n\t\t}\n\n\t\tu32 char_len=0;\n\t\tBool set_start_char=GF_FALSE, set_end_char=GF_FALSE;\n\t\tctx->style.startCharOffset = ctx->style.endCharOffset = 0;\n\t\tgf_isom_text_reset(ctx->samp);\n\n\t\tmemset(szText, 0, 2048);\n\t\ti=j=0;\n\t\twhile (1) {\n\t\t\tchar c = start_p[i];\n\t\t\tif (c == 0) {\n\t\t\t\tszText[j] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (c=='\\\\') {\n\t\t\t\tif ((start_p[i+1] == 'N') || (start_p[i+1] == 'n')) {\n\t\t\t\t\tszText[j] = 0;\n\t\t\t\t\tparse_srt_line(ctx, szText, &char_len, &set_start_char, &set_end_char);\n\n\t\t\t\t\tj=0;\n\t\t\t\t\ti+=2;\n\t\t\t\t\tmemset(szText, 0, 2048);\n\t\t\t\t\tgf_isom_text_add_text(ctx->samp, \"\\n\", 1);\n\t\t\t\t\tchar_len += 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (c=='{') {\n\t\t\t\tif (start_p[i+1] == '\\\\') {\n\t\t\t\t\tu32 style = 0;\n\t\t\t\t\tu32 color=0;\n\t\t\t\t\tBool is_end = 0;\n\t\t\t\t\tif (start_p[i+2] == 'i') style = 1;\n\t\t\t\t\telse if (start_p[i+2] == 'b') style = 2;\n\t\t\t\t\telse if (start_p[i+2] == 'u') style = 3;\n\t\t\t\t\telse if (start_p[i+2] == 'c') {\n\t\t\t\t\t\tif ((start_p[i+3] == '&') && (strlen(start_p+i+4)>8)) {\n\t\t\t\t\t\t\tchar *col_p = start_p + i+5;\n\t\t\t\t\t\t\tstyle = 4;\n\t\t\t\t\t\t\tchar szT[3];\n\t\t\t\t\t\t\tu32 r, g, b;\n\t\t\t\t\t\t\tszT[2]=0;\n\t\t\t\t\t\t\tszT[0]=col_p[0];\n\t\t\t\t\t\t\tszT[1]=col_p[1];\n\t\t\t\t\t\t\tsscanf(szT, \"%x\", &g);\n\t\t\t\t\t\t\tszT[0]=col_p[2];\n\t\t\t\t\t\t\tszT[1]=col_p[3];\n\t\t\t\t\t\t\tsscanf(szT, \"%x\", &b);\n\t\t\t\t\t\t\tszT[0]=col_p[4];\n\t\t\t\t\t\t\tszT[1]=col_p[5];\n\t\t\t\t\t\t\tsscanf(szT, \"%x\", &r);\n\t\t\t\t\t\t\tcolor = GF_COL_ARGB(0xFF, r, g, b);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (start_p[i+3] == '}') {\n\t\t\t\t\t\t\tis_end=GF_TRUE;\n\t\t\t\t\t\t\tstyle = 4;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (start_p[i+2] == 's') style = 5;\n\n\t\t\t\t\tif (start_p[i+3] == '0') is_end=GF_TRUE;\n\t\t\t\t\twhile (start_p[i] && (start_p[i]!='}')) i++;\n\t\t\t\t\ti++;\n\n\t\t\t\t\tif (style==1) {\n\t\t\t\t\t\tif (is_end) {strcat(szText, \"</i>\"); j+=4;}\n\t\t\t\t\t\telse {strcat(szText, \"<i>\"); j+=3;}\n\t\t\t\t\t} else if (style==2) {\n\t\t\t\t\t\tif (is_end) {strcat(szText, \"</b>\"); j+=4;}\n\t\t\t\t\t\telse {strcat(szText, \"<b>\"); j+=3;}\n\t\t\t\t\t} else if (style==3) {\n\t\t\t\t\t\tif (is_end) {strcat(szText, \"</u>\"); j+=4;}\n\t\t\t\t\t\telse {strcat(szText, \"<u>\"); j+=3;}\n\t\t\t\t\t} else if (style==4) {\n\t\t\t\t\t\tif (is_end) {strcat(szText, \"</font>\"); j+=7;}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tchar szFont[100];\n\t\t\t\t\t\t\tsprintf(szFont, \"<font color=\\\"0x%X\\\">\", color);\n\t\t\t\t\t\t\tstrcat(szText, szFont);\n\t\t\t\t\t\t\tj+=(u32) strlen(szFont);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (style==5) {\n\t\t\t\t\t\tif (is_end) {strcat(szText, \"</strike>\"); j+=9;}\n\t\t\t\t\t\telse {strcat(szText, \"<strike>\"); j+=8;}\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tszText[j] = c;\n\t\t\tj++;\n\t\t\ti++;\n\t\t}\n\t\tif (szText[0])\n\t\t\tparse_srt_line(ctx, szText, &char_len, &set_start_char, &set_end_char);\n\n\t\ttxtin_process_send_text_sample(ctx, ctx->samp,  ctx->start, (u32) (ctx->end -  ctx->start), GF_TRUE);\n\t\tctx->prev_end = ctx->end;\n\n\t\tgf_filter_pid_set_info(ctx->opid, GF_PROP_PID_DOWN_BYTES, &PROP_LONGUINT( gf_ftell(ctx->src)) );\n\n\t\tif (gf_filter_pid_would_block(ctx->opid))\n\t\t\treturn GF_OK;\n\t}\n\t/*final flush*/\n\tif (ctx->end && !ctx->noflush) {\n\t\tsamp = gf_isom_new_text_sample();\n\t\ttxtin_process_send_text_sample(ctx, samp, ctx->end, 0, GF_TRUE);\n\t\tgf_isom_delete_text_sample(samp);\n\t}\n\n\tgf_filter_pid_set_info_str( ctx->opid, \"ttxt:last_dur\", &PROP_UINT(0) );\n\n\treturn GF_EOS;\n}\n\n\n\nstatic u32 ttxt_get_color(char *val)\n{\n\tu32 r, g, b, a, res;\n\tr = g = b = a = 0;\n\tif (sscanf(val, \"%x %x %x %x\", &r, &g, &b, &a) != 4) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] Warning: color badly formatted %s\\n\", val));\n\t}\n\tres = (a&0xFF);\n\tres<<=8;\n\tres |= (r&0xFF);\n\tres<<=8;\n\tres |= (g&0xFF);\n\tres<<=8;\n\tres |= (b&0xFF);\n\treturn res;\n}\n\nstatic void ttxt_parse_text_box(GF_XMLNode *n, GF_BoxRecord *box)\n{\n\tu32 i=0;\n\tGF_XMLAttribute *att;\n\tmemset(box, 0, sizeof(GF_BoxRecord));\n\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(n->attributes, &i))) {\n\t\tif (!stricmp(att->name, \"top\")) box->top = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"bottom\")) box->bottom = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"left\")) box->left = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"right\")) box->right = atoi(att->value);\n\t}\n}\n\nstatic void ttxt_parse_text_style(GF_TXTIn *ctx, GF_XMLNode *n, GF_StyleRecord *style)\n{\n\tu32 i=0;\n\tGF_XMLAttribute *att;\n\tmemset(style, 0, sizeof(GF_StyleRecord));\n\tstyle->fontID = 1;\n\tstyle->font_size = ctx->fontsize ;\n\tstyle->text_color = 0xFFFFFFFF;\n\n\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(n->attributes, &i))) {\n\t\tif (!stricmp(att->name, \"fromChar\")) style->startCharOffset = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"toChar\")) style->endCharOffset = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"fontID\")) style->fontID = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"fontSize\")) style->font_size = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"color\")) style->text_color = ttxt_get_color(att->value);\n\t\telse if (!stricmp(att->name, \"styles\")) {\n\t\t\tif (strstr(att->value, \"Bold\")) style->style_flags |= GF_TXT_STYLE_BOLD;\n\t\t\tif (strstr(att->value, \"Italic\")) style->style_flags |= GF_TXT_STYLE_ITALIC;\n\t\t\tif (strstr(att->value, \"Underlined\")) style->style_flags |= GF_TXT_STYLE_UNDERLINED;\n\t\t\tif (strstr(att->value, \"Strikethrough\")) style->style_flags |= GF_TXT_STYLE_STRIKETHROUGH;\n\t\t}\n\t}\n}\n\nstatic GF_Err txtin_setup_ttxt(GF_Filter *filter, GF_TXTIn *ctx)\n{\n\tGF_Err e;\n\tu32 j, k, ID, OCR_ES_ID;\n\tu64 file_size;\n\tGF_XMLNode *root, *ext;\n\tGF_PropertyValue *dcd;\n\n\tctx->parser = gf_xml_dom_new();\n\te = gf_xml_dom_parse(ctx->parser, ctx->file_name, ttxt_dom_progress, ctx);\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Error parsing TTXT file: Line %d - %s\\n\", gf_xml_dom_get_line(ctx->parser), gf_xml_dom_get_error(ctx->parser)));\n\t\treturn e;\n\t}\n\troot = gf_xml_dom_get_root(ctx->parser);\n\tif (!root) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Missing root \\\"TextStream\\\" element\"));\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\tif (strcmp(root->name, \"TextStream\")) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Invalid Timed Text file - expecting \\\"TextStream\\\" got %s\", root->name));\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tfile_size = ctx->end;\n\tctx->end = 0;\n\n\t/*setup track in 3GP format directly (no ES desc)*/\n\tif (!ctx->timescale) ctx->timescale = 1000;\n\tOCR_ES_ID = ID = 0;\n\n\tif (!ctx->opid) ctx->opid = gf_filter_pid_new(filter);\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_TEXT) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, &PROP_UINT(GF_CODECID_TX3G) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, &PROP_UINT(ctx->timescale) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DOWN_SIZE, &PROP_LONGUINT(file_size) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_UNFRAMED, NULL);\n\n\tif (!ID) ID = 1;\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ID, &PROP_UINT(ID) );\n\tif (OCR_ES_ID) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CLOCK_ID, &PROP_UINT(OCR_ES_ID) );\n\n\tctx->nb_children = gf_list_count(root->content);\n\n\tctx->cur_child_idx = 0;\n\tfor (ctx->cur_child_idx=0; ctx->cur_child_idx < ctx->nb_children; ctx->cur_child_idx++) {\n\t\tGF_XMLNode *node = (GF_XMLNode*) gf_list_get(root->content, ctx->cur_child_idx);\n\n\t\tif (node->type) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(node->name, \"TextStreamHeader\")) {\n\t\t\tGF_XMLNode *sdesc;\n\t\t\ts32 w, h, tx, ty, layer;\n\t\t\tu32 tref_id;\n\t\t\tGF_XMLAttribute *att;\n\t\t\tw = ctx->width;\n\t\t\th = ctx->height;\n\t\t\ttx = ctx->txtx;\n\t\t\tty = ctx->txty;\n\t\t\tlayer = ctx->zorder;\n\t\t\ttref_id = 0;\n\n\t\t\tj=0;\n\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(node->attributes, &j))) {\n\t\t\t\tif (!strcmp(att->name, \"width\")) w = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"height\")) h = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"layer\")) layer = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"translation_x\")) tx = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"translation_y\")) ty = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"trefID\")) tref_id = atoi(att->value);\n\t\t\t}\n\n\t\t\tif (tref_id) {\n\t\t\t\tgf_filter_pid_set_property_str(ctx->opid, \"tref:chap\", &PROP_UINT(tref_id) );\n\t\t\t}\n\n\t\t\tif (w) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_WIDTH, &PROP_UINT(w) );\n\t\t\tif (h) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_HEIGHT, &PROP_UINT(h) );\n\t\t\tif (tx) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TRANS_X, &PROP_UINT(tx) );\n\t\t\tif (ty) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TRANS_X, &PROP_UINT(ty) );\n\t\t\tif (layer) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ZORDER, &PROP_SINT(ctx->zorder) );\n\t\t\tif (ctx->lang) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_LANGUAGE, &PROP_STRING( ctx->lang) );\n\n\t\t\tj=0;\n\t\t\twhile ( (sdesc=(GF_XMLNode*)gf_list_enum(node->content, &j))) {\n\t\t\t\tif (sdesc->type) continue;\n\n\t\t\t\tif (!strcmp(sdesc->name, \"TextSampleDescription\")) {\n\t\t\t\t\tGF_TextSampleDescriptor td;\n\t\t\t\t\tmemset(&td, 0, sizeof(GF_TextSampleDescriptor));\n\t\t\t\t\ttd.tag = GF_ODF_TEXT_CFG_TAG;\n\t\t\t\t\ttd.vert_justif = (s8) -1;\n\t\t\t\t\ttd.default_style.fontID = 1;\n\t\t\t\t\ttd.default_style.font_size = ctx->fontsize;\n\n\t\t\t\t\tk=0;\n\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(sdesc->attributes, &k))) {\n\t\t\t\t\t\tif (!strcmp(att->name, \"horizontalJustification\")) {\n\t\t\t\t\t\t\tif (!stricmp(att->value, \"center\")) td.horiz_justif = 1;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"right\")) td.horiz_justif = (s8) -1;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"left\")) td.horiz_justif = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!strcmp(att->name, \"verticalJustification\")) {\n\t\t\t\t\t\t\tif (!stricmp(att->value, \"center\")) td.vert_justif = 1;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"bottom\")) td.vert_justif = (s8) -1;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"top\")) td.vert_justif = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!strcmp(att->name, \"backColor\")) td.back_color = ttxt_get_color(att->value);\n\t\t\t\t\t\telse if (!strcmp(att->name, \"verticalText\") && !stricmp(att->value, \"yes\") ) td.displayFlags |= GF_TXT_VERTICAL;\n\t\t\t\t\t\telse if (!strcmp(att->name, \"fillTextRegion\") && !stricmp(att->value, \"yes\") ) td.displayFlags |= GF_TXT_FILL_REGION;\n\t\t\t\t\t\telse if (!strcmp(att->name, \"continuousKaraoke\") && !stricmp(att->value, \"yes\") ) td.displayFlags |= GF_TXT_KARAOKE;\n\t\t\t\t\t\telse if (!strcmp(att->name, \"scroll\")) {\n\t\t\t\t\t\t\tif (!stricmp(att->value, \"inout\")) td.displayFlags |= GF_TXT_SCROLL_IN | GF_TXT_SCROLL_OUT;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"in\")) td.displayFlags |= GF_TXT_SCROLL_IN;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"out\")) td.displayFlags |= GF_TXT_SCROLL_OUT;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!strcmp(att->name, \"scrollMode\")) {\n\t\t\t\t\t\t\tu32 scroll_mode = GF_TXT_SCROLL_CREDITS;\n\t\t\t\t\t\t\tif (!stricmp(att->value, \"Credits\")) scroll_mode = GF_TXT_SCROLL_CREDITS;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"Marquee\")) scroll_mode = GF_TXT_SCROLL_MARQUEE;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"Right\")) scroll_mode = GF_TXT_SCROLL_RIGHT;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"Down\")) scroll_mode = GF_TXT_SCROLL_DOWN;\n\t\t\t\t\t\t\ttd.displayFlags |= ((scroll_mode<<7) & GF_TXT_SCROLL_DIRECTION);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tk=0;\n\t\t\t\t\twhile ( (ext=(GF_XMLNode*)gf_list_enum(sdesc->content, &k))) {\n\t\t\t\t\t\tif (ext->type) continue;\n\t\t\t\t\t\tif (!strcmp(ext->name, \"TextBox\")) ttxt_parse_text_box(ext, &td.default_pos);\n\t\t\t\t\t\telse if (!strcmp(ext->name, \"Style\")) ttxt_parse_text_style(ctx, ext, &td.default_style);\n\t\t\t\t\t\telse if (!strcmp(ext->name, \"FontTable\")) {\n\t\t\t\t\t\t\tGF_XMLNode *ftable;\n\t\t\t\t\t\t\tu32 z=0;\n\t\t\t\t\t\t\twhile ( (ftable=(GF_XMLNode*)gf_list_enum(ext->content, &z))) {\n\t\t\t\t\t\t\t\tu32 m;\n\t\t\t\t\t\t\t\tif (ftable->type || strcmp(ftable->name, \"FontTableEntry\")) continue;\n\t\t\t\t\t\t\t\ttd.font_count += 1;\n\t\t\t\t\t\t\t\ttd.fonts = (GF_FontRecord*)gf_realloc(td.fonts, sizeof(GF_FontRecord)*td.font_count);\n\t\t\t\t\t\t\t\tm=0;\n\t\t\t\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(ftable->attributes, &m))) {\n\t\t\t\t\t\t\t\t\tif (!stricmp(att->name, \"fontID\")) td.fonts[td.font_count-1].fontID = atoi(att->value);\n\t\t\t\t\t\t\t\t\telse if (!stricmp(att->name, \"fontName\")) td.fonts[td.font_count-1].fontName = gf_strdup(att->value);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ctx->nodefbox) {\n\t\t\t\t\t\ttd.default_pos.top = td.default_pos.left = td.default_pos.right = td.default_pos.bottom = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ((td.default_pos.bottom==td.default_pos.top) || (td.default_pos.right==td.default_pos.left)) {\n\t\t\t\t\t\t\ttd.default_pos.top = td.default_pos.left = 0;\n\t\t\t\t\t\t\ttd.default_pos.right = w;\n\t\t\t\t\t\t\ttd.default_pos.bottom = h;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!td.fonts) {\n\t\t\t\t\t\ttd.font_count = 1;\n\t\t\t\t\t\ttd.fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord));\n\t\t\t\t\t\ttd.fonts[0].fontID = 1;\n\t\t\t\t\t\ttd.fonts[0].fontName = gf_strdup(\"Serif\");\n\t\t\t\t\t}\n\t\t\t\t\tGF_SAFEALLOC(dcd, GF_PropertyValue);\n\t\t\t\t\tif (dcd) {\n\t\t\t\t\t\tdcd->type = GF_PROP_DATA;\n\n\t\t\t\t\t\tgf_odf_tx3g_write(&td, &dcd->value.data.ptr, &dcd->value.data.size);\n\t\t\t\t\t\tif (!ctx->text_descs) ctx->text_descs = gf_list_new();\n\t\t\t\t\t\tgf_list_add(ctx->text_descs, dcd);\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (k=0; k<td.font_count; k++) gf_free(td.fonts[k].fontName);\n\t\t\t\t\tgf_free(td.fonts);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!ctx->text_descs) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Invalid Timed Text file - text stream header not found or empty\\n\"));\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tdcd = gf_list_get(ctx->text_descs, 0);\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, dcd);\n\tctx->last_desc_idx = 1;\n\n\tctx->first_samp = GF_TRUE;\n\tctx->last_sample_empty = GF_FALSE;\n\tctx->last_sample_duration = 0;\n\n\ttxtin_probe_duration(ctx);\n\n\treturn GF_OK;\n}\n\nstatic GF_Err txtin_process_ttxt(GF_Filter *filter, GF_TXTIn *ctx, GF_FilterPacket *ipck)\n{\n\tu32 j, k;\n\tGF_XMLNode *root, *ext;\n\n\tif (!ctx->is_setup) {\n\t\tctx->is_setup = GF_TRUE;\n\t\treturn txtin_setup_ttxt(filter, ctx);\n\t}\n\tif (!ctx->opid) return GF_NON_COMPLIANT_BITSTREAM;\n\tif (!ctx->playstate) return GF_OK;\n\telse if (ctx->playstate==2) return GF_EOS;\n\n\tif (ctx->seek_state==1) {\n\t\tctx->seek_state = 2;\n\t\tctx->cur_child_idx = 0;\n\t}\n\troot = gf_xml_dom_get_root(ctx->parser);\n\n\tfor (; ctx->cur_child_idx < ctx->nb_children; ctx->cur_child_idx++) {\n\t\tGF_TextSample * samp;\n\t\tu32 ts, descIndex;\n\t\tBool has_text = GF_FALSE;\n\t\tGF_XMLAttribute *att;\n\t\tGF_XMLNode *node = (GF_XMLNode*) gf_list_get(root->content, ctx->cur_child_idx);\n\n\t\tif (node->type) {\n\t\t\tcontinue;\n\t\t}\n\t\t/*sample text*/\n\t\telse if (strcmp(node->name, \"TextSample\")) continue;\n\n\t\tsamp = gf_isom_new_text_sample();\n\t\tts = 0;\n\t\tdescIndex = 1;\n\t\tctx->last_sample_empty = GF_TRUE;\n\n\t\tj=0;\n\t\twhile ( (att=(GF_XMLAttribute*)gf_list_enum(node->attributes, &j))) {\n\t\t\tif (!strcmp(att->name, \"sampleTime\")) {\n\t\t\t\tu32 h, m, s, ms;\n\t\t\t\tif (sscanf(att->value, \"%u:%u:%u.%u\", &h, &m, &s, &ms) == 4) {\n\t\t\t\t\tts = (h*3600 + m*60 + s)*1000 + ms;\n\t\t\t\t} else {\n\t\t\t\t\tts = (u32) (atof(att->value) * 1000);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!strcmp(att->name, \"sampleDescriptionIndex\")) descIndex = atoi(att->value);\n\t\t\telse if (!strcmp(att->name, \"text\")) {\n\t\t\t\tu32 len;\n\t\t\t\tchar *str = ttxt_parse_string(att->value, GF_TRUE);\n\t\t\t\tlen = (u32) strlen(str);\n\t\t\t\tgf_isom_text_add_text(samp, str, len);\n\t\t\t\tctx->last_sample_empty = len ? GF_FALSE : GF_TRUE;\n\t\t\t\thas_text = GF_TRUE;\n\t\t\t}\n\t\t\telse if (!strcmp(att->name, \"scrollDelay\")) gf_isom_text_set_scroll_delay(samp, (u32) (1000*atoi(att->value)));\n\t\t\telse if (!strcmp(att->name, \"highlightColor\")) gf_isom_text_set_highlight_color(samp, ttxt_get_color(att->value));\n\t\t\telse if (!strcmp(att->name, \"wrap\") && !strcmp(att->value, \"Automatic\")) gf_isom_text_set_wrap(samp, 0x01);\n\t\t}\n\n\t\t/*get all modifiers*/\n\t\tj=0;\n\t\twhile ( (ext=(GF_XMLNode*)gf_list_enum(node->content, &j))) {\n\t\t\tif (!has_text && (ext->type==GF_XML_TEXT_TYPE)) {\n\t\t\t\tu32 len;\n\t\t\t\tchar *str = ttxt_parse_string(ext->name, GF_FALSE);\n\t\t\t\tlen = (u32) strlen(str);\n\t\t\t\tgf_isom_text_add_text(samp, str, len);\n\t\t\t\tctx->last_sample_empty = len ? GF_FALSE : GF_TRUE;\n\t\t\t\thas_text = GF_TRUE;\n\t\t\t}\n\t\t\tif (ext->type) continue;\n\n\t\t\tif (!stricmp(ext->name, \"Style\")) {\n\t\t\t\tGF_StyleRecord r;\n\t\t\t\tttxt_parse_text_style(ctx, ext, &r);\n\t\t\t\tgf_isom_text_add_style(samp, &r);\n\t\t\t}\n\t\t\telse if (!stricmp(ext->name, \"TextBox\")) {\n\t\t\t\tGF_BoxRecord r;\n\t\t\t\tttxt_parse_text_box(ext, &r);\n\t\t\t\tgf_isom_text_set_box(samp, r.top, r.left, r.bottom, r.right);\n\t\t\t}\n\t\t\telse if (!stricmp(ext->name, \"Highlight\")) {\n\t\t\t\tu16 start, end;\n\t\t\t\tstart = end = 0;\n\t\t\t\tk=0;\n\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(ext->attributes, &k))) {\n\t\t\t\t\tif (!strcmp(att->name, \"fromChar\")) start = atoi(att->value);\n\t\t\t\t\telse if (!strcmp(att->name, \"toChar\")) end = atoi(att->value);\n\t\t\t\t}\n\t\t\t\tgf_isom_text_add_highlight(samp, start, end);\n\t\t\t}\n\t\t\telse if (!stricmp(ext->name, \"Blinking\")) {\n\t\t\t\tu16 start, end;\n\t\t\t\tstart = end = 0;\n\t\t\t\tk=0;\n\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(ext->attributes, &k))) {\n\t\t\t\t\tif (!strcmp(att->name, \"fromChar\")) start = atoi(att->value);\n\t\t\t\t\telse if (!strcmp(att->name, \"toChar\")) end = atoi(att->value);\n\t\t\t\t}\n\t\t\t\tgf_isom_text_add_blink(samp, start, end);\n\t\t\t}\n\t\t\telse if (!stricmp(ext->name, \"HyperLink\")) {\n\t\t\t\tu16 start, end;\n\t\t\t\tchar *url, *url_tt;\n\t\t\t\tstart = end = 0;\n\t\t\t\turl = url_tt = NULL;\n\t\t\t\tk=0;\n\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(ext->attributes, &k))) {\n\t\t\t\t\tif (!strcmp(att->name, \"fromChar\")) start = atoi(att->value);\n\t\t\t\t\telse if (!strcmp(att->name, \"toChar\")) end = atoi(att->value);\n\t\t\t\t\telse if (!strcmp(att->name, \"URL\")) url = gf_strdup(att->value);\n\t\t\t\t\telse if (!strcmp(att->name, \"URLToolTip\")) url_tt = gf_strdup(att->value);\n\t\t\t\t}\n\t\t\t\tgf_isom_text_add_hyperlink(samp, url, url_tt, start, end);\n\t\t\t\tif (url) gf_free(url);\n\t\t\t\tif (url_tt) gf_free(url_tt);\n\t\t\t}\n\t\t\telse if (!stricmp(ext->name, \"Karaoke\")) {\n\t\t\t\tu32 startTime;\n\t\t\t\tGF_XMLNode *krok;\n\t\t\t\tstartTime = 0;\n\t\t\t\tk=0;\n\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(ext->attributes, &k))) {\n\t\t\t\t\tif (!strcmp(att->name, \"startTime\")) startTime = (u32) (1000*atof(att->value));\n\t\t\t\t}\n\t\t\t\tgf_isom_text_add_karaoke(samp, startTime);\n\t\t\t\tk=0;\n\t\t\t\twhile ( (krok=(GF_XMLNode*)gf_list_enum(ext->content, &k))) {\n\t\t\t\t\tu16 start, end;\n\t\t\t\t\tu32 endTime, m;\n\t\t\t\t\tif (krok->type) continue;\n\t\t\t\t\tif (strcmp(krok->name, \"KaraokeRange\")) continue;\n\t\t\t\t\tstart = end = 0;\n\t\t\t\t\tendTime = 0;\n\t\t\t\t\tm=0;\n\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(krok->attributes, &m))) {\n\t\t\t\t\t\tif (!strcmp(att->name, \"fromChar\")) start = atoi(att->value);\n\t\t\t\t\t\telse if (!strcmp(att->name, \"toChar\")) end = atoi(att->value);\n\t\t\t\t\t\telse if (!strcmp(att->name, \"endTime\")) endTime = (u32) (1000*atof(att->value));\n\t\t\t\t\t}\n\t\t\t\t\tgf_isom_text_set_karaoke_segment(samp, endTime, start, end);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!descIndex) descIndex = 1;\n\t\tif (descIndex != ctx->last_desc_idx) {\n\t\t\tGF_PropertyValue *dcd;\n\t\t\tctx->last_desc_idx = descIndex;\n\t\t\tdcd = gf_list_get(ctx->text_descs, descIndex-1);\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, dcd);\n\t\t}\n\n\t\t/*in MP4 we must start at T=0, so add an empty sample*/\n\t\tif (ts && ctx->first_samp) {\n\t\t\tGF_TextSample * firstsamp = gf_isom_new_text_sample();\n\t\t\ttxtin_process_send_text_sample(ctx, firstsamp, 0, 0, GF_TRUE);\n\t\t\tgf_isom_delete_text_sample(firstsamp);\n\t\t}\n\t\tctx->first_samp = GF_FALSE;\n\n\t\tu64 next_sample_start=0;\n\t\tfor (j=ctx->cur_child_idx+1; j < ctx->nb_children; j++) {\n\t\t\tnode = (GF_XMLNode*) gf_list_get(root->content, j);\n\n\t\t\tif (node->type) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*sample text*/\n\t\t\telse if (strcmp(node->name, \"TextSample\")) continue;\n\n\t\t\tj=0;\n\t\t\twhile ( (att=(GF_XMLAttribute*)gf_list_enum(node->attributes, &j))) {\n\t\t\t\tif (!strcmp(att->name, \"sampleTime\")) {\n\t\t\t\t\tu32 h, m, s, ms;\n\t\t\t\t\tif (sscanf(att->value, \"%u:%u:%u.%u\", &h, &m, &s, &ms) == 4) {\n\t\t\t\t\t\tnext_sample_start = (h*3600 + m*60 + s)*1000 + ms;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnext_sample_start = (u32) (atof(att->value) * 1000);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (next_sample_start>=ts) next_sample_start -= ts;\n\n\t\ttxtin_process_send_text_sample(ctx, samp, ts, (u32) next_sample_start, GF_TRUE);\n\n\t\tgf_isom_delete_text_sample(samp);\n\n\t\tif (ctx->last_sample_empty) {\n\t\t\tctx->last_sample_duration = ts - ctx->last_sample_duration;\n\t\t} else {\n\t\t\tctx->last_sample_duration = ts;\n\t\t}\n\n\t\tif (gf_filter_pid_would_block(ctx->opid)) {\n\t\t\tctx->cur_child_idx++;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\tif (ctx->last_sample_empty) {\n\t\t//this is a bit ugly, in regular streaming mode we don't want to remove empty samples\n\t\t//howvere the last one can be removed, adjusting the duration of the previous one.\n\t\t//doing this here is problematic if the loader is sent a new ttxt file, we would have a cue termination sample\n\t\t//we therefore share that info through pid, and let the final user (muxer& co) decide what to do\n\t\tgf_filter_pid_set_info_str( ctx->opid, \"ttxt:rem_last\", &PROP_BOOL(GF_TRUE) );\n\t\tgf_filter_pid_set_info_str( ctx->opid, \"ttxt:last_dur\", &PROP_UINT((u32) ctx->last_sample_duration) );\n\t}\n\n\treturn GF_EOS;\n}\n\n\nstatic u32 tx3g_get_color(char *value)\n{\n\tu32 r, g, b, a;\n\tu32 res, v;\n\tr = g = b = a = 0;\n\tif (sscanf(value, \"%u%%, %u%%, %u%%, %u%%\", &r, &g, &b, &a) != 4) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"Warning: color badly formatted\\n\"));\n\t}\n\tv = (u32) (a*255/100);\n\tres = (v&0xFF);\n\tres<<=8;\n\tv = (u32) (r*255/100);\n\tres |= (v&0xFF);\n\tres<<=8;\n\tv = (u32) (g*255/100);\n\tres |= (v&0xFF);\n\tres<<=8;\n\tv = (u32) (b*255/100);\n\tres |= (v&0xFF);\n\treturn res;\n}\n\nstatic void tx3g_parse_text_box(GF_XMLNode *n, GF_BoxRecord *box)\n{\n\tu32 i=0;\n\tGF_XMLAttribute *att;\n\tmemset(box, 0, sizeof(GF_BoxRecord));\n\twhile ((att=(GF_XMLAttribute *)gf_list_enum(n->attributes, &i))) {\n\t\tif (!stricmp(att->name, \"x\")) box->left = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"y\")) box->top = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"height\")) box->bottom = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"width\")) box->right = atoi(att->value);\n\t}\n}\n\ntypedef struct\n{\n\tu32 id;\n\tu32 pos;\n} Marker;\n\n#define GET_MARKER_POS(_val, __isend) \\\n\t{\t\\\n\t\tu32 i, __m = atoi(att->value);\t\\\n\t\t_val = 0;\t\\\n\t\tfor (i=0; i<nb_marks; i++) { if (__m==marks[i].id) { _val = marks[i].pos; /*if (__isend) _val--; */break; } }\t \\\n\t}\n\n\nstatic GF_Err txtin_texml_setup(GF_Filter *filter, GF_TXTIn *ctx)\n{\n\tGF_Err e;\n\tu32 ID, OCR_ES_ID, i;\n\tu64 file_size;\n\tGF_XMLAttribute *att;\n\tGF_XMLNode *root;\n\n\tctx->parser = gf_xml_dom_new();\n\te = gf_xml_dom_parse(ctx->parser, ctx->file_name, ttxt_dom_progress, ctx);\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Error parsing TeXML file: Line %d - %s\", gf_xml_dom_get_line(ctx->parser), gf_xml_dom_get_error(ctx->parser) ));\n\t\tgf_xml_dom_del(ctx->parser);\n\t\tctx->parser = NULL;\n\t\treturn e;\n\t}\n\n\troot = gf_xml_dom_get_root(ctx->parser);\n\n\tif (strcmp(root->name, \"text3GTrack\")) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Invalid QT TeXML file - expecting root \\\"text3GTrack\\\" got \\\"%s\\\"\", root->name));\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tfile_size = ctx->end;\n\tctx->txml_timescale = 600;\n\n\ti=0;\n\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(root->attributes, &i))) {\n\t\tif (!strcmp(att->name, \"trackWidth\")) ctx->width = atoi(att->value);\n\t\telse if (!strcmp(att->name, \"trackHeight\")) ctx->height = atoi(att->value);\n\t\telse if (!strcmp(att->name, \"layer\")) ctx->zorder = atoi(att->value);\n\t\telse if (!strcmp(att->name, \"timeScale\")) ctx->txml_timescale = atoi(att->value);\n\t\telse if (!strcmp(att->name, \"transform\")) {\n\t\t\tFloat fx, fy;\n\t\t\tsscanf(att->value, \"translate(%f,%f)\", &fx, &fy);\n\t\t\tctx->txtx = (u32) fx;\n\t\t\tctx->txty = (u32) fy;\n\t\t}\n\t}\n\n\t/*setup track in 3GP format directly (no ES desc)*/\n\tOCR_ES_ID = ID = 0;\n\tif (!ctx->timescale) ctx->timescale = 1000;\n\n\tif (!ctx->opid) ctx->opid = gf_filter_pid_new(filter);\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_TEXT) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, &PROP_UINT(GF_ISOM_SUBTYPE_TX3G) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, &PROP_UINT(ctx->timescale) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DOWN_SIZE, &PROP_LONGUINT(file_size) );\n\n\n\tif (!ID) ID = 1;\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ID, &PROP_UINT(ID) );\n\tif (OCR_ES_ID) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CLOCK_ID, &PROP_UINT(OCR_ES_ID) );\n\tif (ctx->width) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_WIDTH, &PROP_UINT(ctx->width) );\n\tif (ctx->height) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_HEIGHT, &PROP_UINT(ctx->height) );\n\tif (ctx->zorder) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ZORDER, &PROP_SINT(ctx->zorder) );\n\tif (ctx->lang) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_LANGUAGE, &PROP_STRING( ctx->lang) );\n\n\n\tctx->nb_children = gf_list_count(root->content);\n\tctx->cur_child_idx = 0;\n\ttxtin_probe_duration(ctx);\n\n\treturn GF_OK;\n}\n\nstatic GF_Err txtin_process_texml(GF_Filter *filter, GF_TXTIn *ctx, GF_FilterPacket *ipck)\n{\n\tu32 j, k;\n\tGF_StyleRecord styles[50];\n\tMarker marks[50];\n\tGF_XMLAttribute *att;\n\tGF_XMLNode *root;\n\tBool probe_first_desc_only = GF_FALSE;\n\n\tif (!ctx->is_setup) {\n\t\tGF_Err e;\n\n\t\tctx->is_setup = GF_TRUE;\n\t\te = txtin_texml_setup(filter, ctx);\n\t\tif (e) return e;\n\t\tprobe_first_desc_only = GF_TRUE;\n\t}\n\tif (!ctx->opid) return GF_NON_COMPLIANT_BITSTREAM;\n\tif (!ctx->playstate && !probe_first_desc_only) return GF_OK;\n\telse if (ctx->playstate==2) return GF_EOS;\n\n\tif (ctx->seek_state==1) {\n\t\tctx->seek_state = 2;\n\t\tctx->cur_child_idx = 0;\n\t\tctx->start = 0;\n\t}\n\n\troot = gf_xml_dom_get_root(ctx->parser);\n\n\tfor (; ctx->cur_child_idx < ctx->nb_children; ctx->cur_child_idx++) {\n\t\tGF_XMLNode *node, *desc;\n\t\tGF_TextSampleDescriptor td;\n\t\tGF_TextSample * samp = NULL;\n\t\tu64 duration;\n\t\tu32 nb_styles, nb_marks;\n\t\tBool isRAP, same_style, same_box;\n\n\t\tif (probe_first_desc_only && ctx->text_descs && gf_list_count(ctx->text_descs))\n\t\t\treturn GF_OK;\n\n\t\tmemset(&td, 0, sizeof(GF_TextSampleDescriptor));\n\t\tnode = (GF_XMLNode*)gf_list_get(root->content, ctx->cur_child_idx);\n\t\tif (node->type) continue;\n\t\tif (strcmp(node->name, \"sample\")) continue;\n\n\t\tisRAP = GF_TRUE;\n\t\tduration = 1000;\n\t\tj=0;\n\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(node->attributes, &j))) {\n\t\t\tif (!strcmp(att->name, \"duration\")) duration = atoi(att->value);\n\t\t\telse if (!strcmp(att->name, \"keyframe\")) isRAP = (!stricmp(att->value, \"true\") ? GF_TRUE : GF_FALSE);\n\t\t}\n\t\tnb_styles = 0;\n\t\tnb_marks = 0;\n\t\tsame_style = same_box = GF_FALSE;\n\t\tj=0;\n\t\twhile ((desc=(GF_XMLNode*)gf_list_enum(node->content, &j))) {\n\t\t\tif (desc->type) continue;\n\n\t\t\tif (!strcmp(desc->name, \"description\")) {\n\t\t\t\tu8 *dsi;\n\t\t\t\tu32 dsi_len, stsd_idx;\n\t\t\t\tGF_XMLNode *sub;\n\t\t\t\tmemset(&td, 0, sizeof(GF_TextSampleDescriptor));\n\t\t\t\ttd.tag = GF_ODF_TEXT_CFG_TAG;\n\t\t\t\ttd.vert_justif = (s8) -1;\n\t\t\t\ttd.default_style.fontID = 1;\n\t\t\t\ttd.default_style.font_size = ctx->fontsize;\n\n\t\t\t\tk=0;\n\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(desc->attributes, &k))) {\n\t\t\t\t\tif (!strcmp(att->name, \"horizontalJustification\")) {\n\t\t\t\t\t\tif (!stricmp(att->value, \"center\")) td.horiz_justif = 1;\n\t\t\t\t\t\telse if (!stricmp(att->value, \"right\")) td.horiz_justif = (s8) -1;\n\t\t\t\t\t\telse if (!stricmp(att->value, \"left\")) td.horiz_justif = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if (!strcmp(att->name, \"verticalJustification\")) {\n\t\t\t\t\t\tif (!stricmp(att->value, \"center\")) td.vert_justif = 1;\n\t\t\t\t\t\telse if (!stricmp(att->value, \"bottom\")) td.vert_justif = (s8) -1;\n\t\t\t\t\t\telse if (!stricmp(att->value, \"top\")) td.vert_justif = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if (!strcmp(att->name, \"backgroundColor\")) td.back_color = tx3g_get_color(att->value);\n\t\t\t\t\telse if (!strcmp(att->name, \"displayFlags\")) {\n\t\t\t\t\t\tBool rev_scroll = GF_FALSE;\n\t\t\t\t\t\tif (strstr(att->value, \"scroll\")) {\n\t\t\t\t\t\t\tu32 scroll_mode = 0;\n\t\t\t\t\t\t\tif (strstr(att->value, \"scrollIn\")) td.displayFlags |= GF_TXT_SCROLL_IN;\n\t\t\t\t\t\t\tif (strstr(att->value, \"scrollOut\")) td.displayFlags |= GF_TXT_SCROLL_OUT;\n\t\t\t\t\t\t\tif (strstr(att->value, \"reverse\")) rev_scroll = GF_TRUE;\n\t\t\t\t\t\t\tif (strstr(att->value, \"horizontal\")) scroll_mode = rev_scroll ? GF_TXT_SCROLL_RIGHT : GF_TXT_SCROLL_MARQUEE;\n\t\t\t\t\t\t\telse scroll_mode = (rev_scroll ? GF_TXT_SCROLL_DOWN : GF_TXT_SCROLL_CREDITS);\n\t\t\t\t\t\t\ttd.displayFlags |= (scroll_mode<<7) & GF_TXT_SCROLL_DIRECTION;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/*TODO FIXME: check in QT doc !!*/\n\t\t\t\t\t\tif (strstr(att->value, \"writeTextVertically\")) td.displayFlags |= GF_TXT_VERTICAL;\n\t\t\t\t\t\tif (!strcmp(att->name, \"continuousKaraoke\")) td.displayFlags |= GF_TXT_KARAOKE;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tk=0;\n\t\t\t\twhile ((sub=(GF_XMLNode*)gf_list_enum(desc->content, &k))) {\n\t\t\t\t\tif (sub->type) continue;\n\t\t\t\t\tif (!strcmp(sub->name, \"defaultTextBox\")) tx3g_parse_text_box(sub, &td.default_pos);\n\t\t\t\t\telse if (!strcmp(sub->name, \"fontTable\")) {\n\t\t\t\t\t\tGF_XMLNode *ftable;\n\t\t\t\t\t\tu32 m=0;\n\t\t\t\t\t\twhile ((ftable=(GF_XMLNode*)gf_list_enum(sub->content, &m))) {\n\t\t\t\t\t\t\tif (ftable->type) continue;\n\t\t\t\t\t\t\tif (!strcmp(ftable->name, \"font\")) {\n\t\t\t\t\t\t\t\tu32 n=0;\n\t\t\t\t\t\t\t\ttd.font_count += 1;\n\t\t\t\t\t\t\t\ttd.fonts = (GF_FontRecord*)gf_realloc(td.fonts, sizeof(GF_FontRecord)*td.font_count);\n\t\t\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(ftable->attributes, &n))) {\n\t\t\t\t\t\t\t\t\tif (!stricmp(att->name, \"id\")) td.fonts[td.font_count-1].fontID = atoi(att->value);\n\t\t\t\t\t\t\t\t\telse if (!stricmp(att->name, \"name\")) td.fonts[td.font_count-1].fontName = gf_strdup(att->value);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (!strcmp(sub->name, \"sharedStyles\")) {\n\t\t\t\t\t\tGF_XMLNode *style, *ftable;\n\t\t\t\t\t\tu32 m=0;\n\t\t\t\t\t\twhile ((style=(GF_XMLNode*)gf_list_enum(sub->content, &m))) {\n\t\t\t\t\t\t\tif (style->type) continue;\n\t\t\t\t\t\t\tif (!strcmp(style->name, \"style\")) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (style) {\n\t\t\t\t\t\t\tchar *cur;\n\t\t\t\t\t\t\ts32 start=0;\n\t\t\t\t\t\t\tchar css_style[1024], css_val[1024];\n\t\t\t\t\t\t\tmemset(&styles[nb_styles], 0, sizeof(GF_StyleRecord));\n\t\t\t\t\t\t\tm=0;\n\t\t\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(style->attributes, &m))) {\n\t\t\t\t\t\t\t\tif (!strcmp(att->name, \"id\")) styles[nb_styles].startCharOffset = atoi(att->value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tm=0;\n\t\t\t\t\t\t\twhile ( (ftable=(GF_XMLNode*)gf_list_enum(style->content, &m))) {\n\t\t\t\t\t\t\t\tif (ftable->type) break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcur = ftable ? ftable->name : NULL;\n\t\t\t\t\t\t\twhile (cur) {\n\t\t\t\t\t\t\t\tstart = gf_token_get_strip(cur, 0, \"{:\", \" \", css_style, 1024);\n\t\t\t\t\t\t\t\tif (start <0) break;\n\t\t\t\t\t\t\t\tstart = gf_token_get_strip(cur, start, \":}\", \" \", css_val, 1024);\n\t\t\t\t\t\t\t\tif (start <0) break;\n\t\t\t\t\t\t\t\tcur = strchr(cur+start, '{');\n\n\t\t\t\t\t\t\t\tif (!strcmp(css_style, \"font-table\")) {\n\t\t\t\t\t\t\t\t\tu32 z;\n\t\t\t\t\t\t\t\t\tstyles[nb_styles].fontID = atoi(css_val);\n\t\t\t\t\t\t\t\t\tfor (z=0; z<td.font_count; z++) {\n\t\t\t\t\t\t\t\t\t\tif (td.fonts[z].fontID == styles[nb_styles].fontID)\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (!strcmp(css_style, \"font-size\")) styles[nb_styles].font_size = atoi(css_val);\n\t\t\t\t\t\t\t\telse if (!strcmp(css_style, \"font-style\") && !strcmp(css_val, \"italic\")) styles[nb_styles].style_flags |= GF_TXT_STYLE_ITALIC;\n\t\t\t\t\t\t\t\telse if (!strcmp(css_style, \"font-weight\") && !strcmp(css_val, \"bold\")) styles[nb_styles].style_flags |= GF_TXT_STYLE_BOLD;\n\t\t\t\t\t\t\t\telse if (!strcmp(css_style, \"text-decoration\") && !strcmp(css_val, \"underline\")) styles[nb_styles].style_flags |= GF_TXT_STYLE_UNDERLINED;\n\t\t\t\t\t\t\t\telse if (!strcmp(css_style, \"text-decoration\") && !strcmp(css_val, \"strikethrough\")) styles[nb_styles].style_flags |= GF_TXT_STYLE_STRIKETHROUGH;\n\t\t\t\t\t\t\t\telse if (!strcmp(css_style, \"color\")) styles[nb_styles].text_color = tx3g_get_color(css_val);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!nb_styles) td.default_style = styles[0];\n\t\t\t\t\t\t\tnb_styles++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tif ((td.default_pos.bottom==td.default_pos.top) || (td.default_pos.right==td.default_pos.left)) {\n\t\t\t\t\ttd.default_pos.top = ctx->txty;\n\t\t\t\t\ttd.default_pos.left = ctx->txtx;\n\t\t\t\t\ttd.default_pos.right = ctx->width;\n\t\t\t\t\ttd.default_pos.bottom = ctx->height;\n\t\t\t\t}\n\t\t\t\tif (!td.fonts) {\n\t\t\t\t\ttd.font_count = 1;\n\t\t\t\t\ttd.fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord));\n\t\t\t\t\ttd.fonts[0].fontID = 1;\n\t\t\t\t\ttd.fonts[0].fontName = gf_strdup( ctx->fontname ? ctx->fontname : \"Serif\");\n\t\t\t\t}\n\n\t\t\t\tgf_odf_tx3g_write(&td, &dsi, &dsi_len);\n\t\t\t\tstsd_idx = 0;\n\t\t\t\tfor (k=0; ctx->text_descs && k<gf_list_count(ctx->text_descs); k++) {\n\t\t\t\t\tGF_PropertyValue *d = gf_list_get(ctx->text_descs, k);\n\t\t\t\t\tif (d->value.data.size != dsi_len) continue;\n\t\t\t\t\tif (! memcmp(d->value.data.ptr, dsi, dsi_len)) {\n\t\t\t\t\t\tstsd_idx = k+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (stsd_idx) {\n\t\t\t\t\tgf_free(dsi);\n\t\t\t\t} else {\n\t\t\t\t\tGF_PropertyValue *d;\n\t\t\t\t\tGF_SAFEALLOC(d, GF_PropertyValue);\n\t\t\t\t\tif (!d) return GF_OUT_OF_MEM;\n\t\t\t\t\td->type = GF_PROP_DATA;\n\t\t\t\t\td->value.data.ptr = dsi;\n\t\t\t\t\td->value.data.size = dsi_len;\n\t\t\t\t\tif (!ctx->text_descs) ctx->text_descs = gf_list_new();\n\t\t\t\t\tgf_list_add(ctx->text_descs, d);\n\t\t\t\t\tstsd_idx = gf_list_count(ctx->text_descs);\n\t\t\t\t}\n\t\t\t\tif (stsd_idx != ctx->last_desc_idx) {\n\t\t\t\t\tctx->last_desc_idx = stsd_idx;\n\t\t\t\t\tGF_PropertyValue *d = gf_list_get(ctx->text_descs, stsd_idx-1);\n\t\t\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, d);\n\t\t\t\t}\n\n\t\t\t\tfor (k=0; k<td.font_count; k++) gf_free(td.fonts[k].fontName);\n\t\t\t\tgf_free(td.fonts);\n\n\t\t\t\tif (probe_first_desc_only)\n\t\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\telse if (!strcmp(desc->name, \"sampleData\")) {\n\t\t\t\tGF_XMLNode *sub;\n\t\t\t\tu16 start, end;\n\t\t\t\tu32 styleID;\n\t\t\t\tu32 nb_chars, txt_len, m;\n\t\t\t\tnb_chars = 0;\n\n\t\t\t\tsamp = gf_isom_new_text_sample();\n\n\t\t\t\tk=0;\n\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(desc->attributes, &k))) {\n\t\t\t\t\tif (!strcmp(att->name, \"targetEncoding\") && !strcmp(att->value, \"utf16\")) ;//is_utf16 = 1;\n\t\t\t\t\telse if (!strcmp(att->name, \"scrollDelay\")) gf_isom_text_set_scroll_delay(samp, atoi(att->value) );\n\t\t\t\t\telse if (!strcmp(att->name, \"highlightColor\")) gf_isom_text_set_highlight_color(samp, tx3g_get_color(att->value));\n\t\t\t\t}\n\t\t\t\tstart = end = 0;\n\t\t\t\tk=0;\n\t\t\t\twhile ((sub=(GF_XMLNode*)gf_list_enum(desc->content, &k))) {\n\t\t\t\t\tif (sub->type) continue;\n\t\t\t\t\tif (!strcmp(sub->name, \"text\")) {\n\t\t\t\t\t\tGF_XMLNode *text;\n\t\t\t\t\t\tstyleID = 0;\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(sub->attributes, &m))) {\n\t\t\t\t\t\t\tif (!strcmp(att->name, \"styleID\")) styleID = atoi(att->value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttxt_len = 0;\n\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((text=(GF_XMLNode*)gf_list_enum(sub->content, &m))) {\n\t\t\t\t\t\t\tif (!text->type) {\n\t\t\t\t\t\t\t\tif (!strcmp(text->name, \"marker\")) {\n\t\t\t\t\t\t\t\t\tu32 z;\n\t\t\t\t\t\t\t\t\tmemset(&marks[nb_marks], 0, sizeof(Marker));\n\t\t\t\t\t\t\t\t\tmarks[nb_marks].pos = nb_chars+txt_len;\n\n\t\t\t\t\t\t\t\t\tz = 0;\n\t\t\t\t\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(text->attributes, &z))) {\n\t\t\t\t\t\t\t\t\t\tif (!strcmp(att->name, \"id\")) marks[nb_marks].id = atoi(att->value);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tnb_marks++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (text->type==GF_XML_TEXT_TYPE) {\n\t\t\t\t\t\t\t\ttxt_len += (u32) strlen(text->name);\n\t\t\t\t\t\t\t\tgf_isom_text_add_text(samp, text->name, (u32) strlen(text->name));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (styleID && (!same_style || (td.default_style.startCharOffset != styleID))) {\n\t\t\t\t\t\t\tGF_StyleRecord st = td.default_style;\n\t\t\t\t\t\t\tfor (m=0; m<nb_styles; m++) {\n\t\t\t\t\t\t\t\tif (styles[m].startCharOffset==styleID) {\n\t\t\t\t\t\t\t\t\tst = styles[m];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tst.startCharOffset = nb_chars;\n\t\t\t\t\t\t\tst.endCharOffset = nb_chars + txt_len;\n\t\t\t\t\t\t\tgf_isom_text_add_style(samp, &st);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnb_chars += txt_len;\n\t\t\t\t\t}\n\t\t\t\t\telse if (!stricmp(sub->name, \"highlight\")) {\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(sub->attributes, &m))) {\n\t\t\t\t\t\t\tif (!strcmp(att->name, \"startMarker\")) GET_MARKER_POS(start, 0)\n\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"endMarker\")) GET_MARKER_POS(end, 1)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_isom_text_add_highlight(samp, start, end);\n\t\t\t\t\t}\n\t\t\t\t\telse if (!stricmp(sub->name, \"blink\")) {\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(sub->attributes, &m))) {\n\t\t\t\t\t\t\tif (!strcmp(att->name, \"startMarker\")) GET_MARKER_POS(start, 0)\n\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"endMarker\")) GET_MARKER_POS(end, 1)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_isom_text_add_blink(samp, start, end);\n\t\t\t\t\t}\n\t\t\t\t\telse if (!stricmp(sub->name, \"link\")) {\n\t\t\t\t\t\tchar *url, *url_tt;\n\t\t\t\t\t\turl = url_tt = NULL;\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(sub->attributes, &m))) {\n\t\t\t\t\t\t\tif (!strcmp(att->name, \"startMarker\")) GET_MARKER_POS(start, 0)\n\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"endMarker\")) GET_MARKER_POS(end, 1)\n\t\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"URL\") || !strcmp(att->name, \"href\")) url = gf_strdup(att->value);\n\t\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"URLToolTip\") || !strcmp(att->name, \"altString\")) url_tt = gf_strdup(att->value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_isom_text_add_hyperlink(samp, url, url_tt, start, end);\n\t\t\t\t\t\tif (url) gf_free(url);\n\t\t\t\t\t\tif (url_tt) gf_free(url_tt);\n\t\t\t\t\t}\n\t\t\t\t\telse if (!stricmp(sub->name, \"karaoke\")) {\n\t\t\t\t\t\tu32 time = 0;\n\t\t\t\t\t\tGF_XMLNode *krok;\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(sub->attributes, &m))) {\n\t\t\t\t\t\t\tif (!strcmp(att->name, \"startTime\")) time = atoi(att->value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_isom_text_add_karaoke(samp, time);\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((krok=(GF_XMLNode*)gf_list_enum(sub->content, &m))) {\n\t\t\t\t\t\t\tu32 u=0;\n\t\t\t\t\t\t\tif (krok->type) continue;\n\t\t\t\t\t\t\tif (strcmp(krok->name, \"run\")) continue;\n\t\t\t\t\t\t\tstart = end = 0;\n\t\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(krok->attributes, &u))) {\n\t\t\t\t\t\t\t\tif (!strcmp(att->name, \"startMarker\")) GET_MARKER_POS(start, 0)\n\t\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"endMarker\")) GET_MARKER_POS(end, 1)\n\t\t\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"duration\")) time += atoi(att->value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgf_isom_text_set_karaoke_segment(samp, time, start, end);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*OK, let's add the sample*/\n\t\tif (samp) {\n\t\t\tif (!same_box) gf_isom_text_set_box(samp, td.default_pos.top, td.default_pos.left, td.default_pos.bottom, td.default_pos.right);\n//\t\t\tif (!same_style) gf_isom_text_add_style(samp, &td.default_style);\n\n\t\t\ttxtin_process_send_text_sample(ctx, samp, (ctx->start*ctx->timescale)/ctx->txml_timescale, (u32) (duration*ctx->timescale)/ctx->txml_timescale, isRAP);\n\t\t\tctx->start += duration;\n\t\t\tgf_isom_delete_text_sample(samp);\n\n\t\t}\n\t\tif (gf_filter_pid_would_block(ctx->opid)) {\n\t\t\tctx->cur_child_idx++;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\treturn GF_EOS;\n}\n\nstatic GF_Err txtin_process_simple(GF_Filter *filter, GF_TXTIn *ctx, GF_FilterPacket *ipck)\n{\n\tGF_FilterPacket *opck=NULL;\n\tif (ctx->playstate==2) return GF_EOS;\n\tif (!ipck) return GF_OK;\n\n\tif (ctx->stxtmod==STXT_MODE_TX3G) {\n\t\tu32 size;\n\t\tu8 *output;\n\t\tconst u8 *data = gf_filter_pck_get_data(ipck, &size);\n\t\topck = gf_filter_pck_new_alloc(ctx->opid, size+2, &output);\n\t\tif (opck) {\n\t\t\tmemcpy(output+2, data, size);\n\t\t\toutput[0] = (size>>8) & 0xFF;\n\t\t\toutput[1] = (size) & 0xFF;\n\t\t}\n\t} else if (ctx->stxtmod==STXT_MODE_VTT) {\n\t\tu32 size;\n\t\tu8 *output;\n\t\tconst u8 *data = gf_filter_pck_get_data(ipck, &size);\n\t\topck = gf_filter_pck_new_alloc(ctx->opid, size+16, &output);\n\t\tif (opck) {\n\t\t\tGF_BitStream *bs = gf_bs_new(output, size+16, GF_BITSTREAM_WRITE);\n\t\t\tgf_bs_write_u32(bs, size+16);\n\t\t\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_VTCC_CUE);\n\t\t\tgf_bs_write_u32(bs, size+8);\n\t\t\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_PAYL);\n\t\t\tgf_bs_write_data(bs, data, size);\n\t\t\tgf_bs_del(bs);\n\t\t}\n\t} else {\n\t\topck = gf_filter_pck_new_ref(ctx->opid, 0, 0, ipck);\n\t}\n\tif (!opck) return GF_OUT_OF_MEM;\n\tgf_filter_pck_set_sap(opck, GF_FILTER_SAP_1);\n\tif (gf_filter_pck_get_cts(ipck)==GF_FILTER_NO_TS) {\n\t\tgf_filter_pck_set_dts(opck, 0);\n\t\tgf_filter_pck_set_cts(opck, 0);\n\n\t\tif (!gf_filter_pck_get_duration(ipck)) {\n\t\t\ts32 dur = (s32) gf_timestamp_rescale_signed(ctx->stxtdur.num, ctx->stxtdur.den, ctx->timescale);\n\t\t\tif (dur<0) dur = -dur;\n\t\t\tgf_filter_pck_set_duration(opck, (u32) dur);\n\t\t} else if (ctx->stxtdur.num>0) {\n\t\t\tu32 dur = (u32) gf_timestamp_rescale(ctx->stxtdur.num, ctx->stxtdur.den, ctx->timescale);\n\t\t\tgf_filter_pck_set_duration(opck, dur);\n\t\t}\n\t}\n\treturn gf_filter_pck_send(opck);\n}\n\nstatic GF_Err txtin_process(GF_Filter *filter)\n{\n\tGF_TXTIn *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck;\n\tGF_Err e;\n\tBool start, end;\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (pck) ctx->is_loaded = GF_FALSE;\n\n\tif (!pck) {\n\t\tif (ctx->unframed) {\n\t\t\tif (gf_filter_pid_is_eos(ctx->ipid)) {\n\t\t\t\tif (ctx->end) {\n#ifndef GPAC_DISABLE_VTT\n\t\t\t\t\tif (ctx->vttparser) {\n\t\t\t\t\t\tgf_webvtt_parser_flush(ctx->vttparser);\n\t\t\t\t\t}\n\t\t\t\t\telse\n#endif\n\t\t\t\t\tif (!ctx->noflush) {\n\t\t\t\t\t\tgf_isom_text_reset(ctx->samp);\n\t\t\t\t\t\ttxtin_process_send_text_sample(ctx, ctx->samp, ctx->end, 0, GF_TRUE);\n\t\t\t\t\t}\n\t\t\t\t\tctx->end = 0;\n\t\t\t\t}\n\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\t\treturn GF_EOS;\n\t\t\t}\n\t\t}\n\t\tif (!ctx->is_loaded)\n\t\t\treturn GF_OK;\n\t}\n\n\tif (ctx->unframed) {\n\t\tif (ctx->simple_text) {\n\t\t\te = ctx->text_process(filter, ctx, pck);\n\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\treturn e;\n\t\t}\n\t\tconst u8 *data;\n\t\tu32 size;\n\t\tdata = gf_filter_pck_get_data(pck, &size);\n\t\te = GF_OK;\n\t\tif (data && size) {\n\t\t\tctx->src = gf_file_temp(NULL);\n\t\t\tif (gf_fwrite(data, size, ctx->src) != size)\n\t\t\t\te = GF_IO_ERR;\n\t\t\tgf_fseek(ctx->src, 0, SEEK_SET);\n\t\t\t//init state as parsing SRT payload\n\t\t\tctx->state = 2;\n\t\t\tctx->start = gf_filter_pck_get_cts(pck);\n\t\t\tctx->end = ctx->start + gf_filter_pck_get_duration(pck);\n\t\t\tctx->curLine = 0;\n\n\t\t\tif (!e)\n\t\t\t\te = ctx->text_process(filter, ctx, pck);\n\n\t\t\tif (ctx->src) {\n\t\t\t\tgf_fclose(ctx->src);\n\t\t\t\tctx->src = NULL;\n\t\t\t}\n\t\t\tif (e==GF_EOS) e = GF_OK;\n\t\t}\n\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\treturn e;\n\t}\n\n\tif (pck) {\n\t\tgf_filter_pck_get_framing(pck, &start, &end);\n\t\tif (!end) {\n\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\treturn GF_OK;\n\t\t}\n\t\t//file is loaded\n\t\tctx->is_loaded = GF_TRUE;\n\t}\n\n\te = ctx->text_process(filter, ctx, NULL);\n\tif (e==GF_EOS) {\n\t\t//keep input alive until end of stream, so that we keep getting called\n\t\tif (pck)\n\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\n\t\tif (gf_filter_pid_is_eos(ctx->ipid))\n\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t}\n\treturn e;\n}\n\nstatic void ttxtin_reset(GF_TXTIn *ctx)\n{\n\tif (ctx->samp) gf_isom_delete_text_sample(ctx->samp);\n\tctx->samp = NULL;\n\tif (ctx->src) gf_fclose(ctx->src);\n\tctx->src = NULL;\n#ifndef GPAC_DISABLE_VTT\n\tif (ctx->vttparser) gf_webvtt_parser_del(ctx->vttparser);\n\tctx->vttparser = NULL;\n#endif\n\tif (ctx->parser) gf_xml_dom_del(ctx->parser);\n\tctx->parser = NULL;\n\tif (ctx->parser_working_copy) gf_xml_dom_del(ctx->parser_working_copy);\n\tctx->parser_working_copy = NULL;\n}\n\nstatic GF_Err txtin_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)\n{\n\tGF_Err e;\n\tu32 codec_id=0;\n\tBool gen_ttxt_dsi=GF_FALSE;\n\tBool gen_webvtt_dsi=GF_FALSE;\n\tconst char *src = NULL;\n\tGF_TXTIn *ctx = gf_filter_get_udta(filter);\n\tconst GF_PropertyValue *prop;\n\n\tif (is_remove) {\n\t\tctx->ipid = NULL;\n\t\treturn GF_OK;\n\t}\n\n\tctx->unframed = GF_FALSE;\n\tctx->simple_text = GF_FALSE;\n\n\tif (! gf_filter_pid_check_caps(pid))\n\t\treturn GF_NOT_SUPPORTED;\n\n\tprop = gf_filter_pid_get_property(pid, GF_PROP_PID_CODECID);\n\tif (ctx->srt_to_tx3g) {\n\t\tctx->unframed = GF_TRUE;\n\t\tprop = gf_filter_pid_get_property(pid, GF_PROP_PID_TIMESCALE);\n\t\tctx->timescale = prop ? prop->value.uint : 1000;\n\t}\n\telse if (ctx->vtt_to_tx3g) {\n\t\tctx->unframed = GF_TRUE;\n\t\tprop = gf_filter_pid_get_property(pid, GF_PROP_PID_TIMESCALE);\n\t\tctx->timescale = prop ? prop->value.uint : 1000;\n\t}\n\telse if (prop && (\n\t\t(prop->value.uint==GF_CODECID_WEBVTT)\n\t\t|| (prop->value.uint==GF_CODECID_SUBS_SSA)\n\t)) {\n\t\tcodec_id = prop->value.uint;\n\t\tctx->unframed = GF_TRUE;\n\t\tprop = gf_filter_pid_get_property(pid, GF_PROP_PID_TIMESCALE);\n\t\tctx->timescale = prop ? prop->value.uint : 1000;\n\t} else if (prop && (\n\t\t(prop->value.uint==GF_CODECID_SIMPLE_TEXT)\n\t\t|| (prop->value.uint==GF_CODECID_SUBS_TEXT)\n\t)) {\n\t\tcodec_id = prop->value.uint;\n\t\tctx->unframed = GF_TRUE;\n\t\tprop = gf_filter_pid_get_property(pid, GF_PROP_PID_TIMESCALE);\n\t\tctx->timescale = prop ? prop->value.uint : 1000;\n\t\tgf_filter_pid_set_framing_mode(pid, GF_TRUE);\n\t\tif (!prop) {\n\t\t\tctx->simple_text = GF_TRUE;\n\t\t\tgf_filter_pid_set_framing_mode(pid, GF_TRUE);\n\t\t}\n\t} else {\n\t\t//otherwise we must have a file path\n\t\tprop = gf_filter_pid_get_property(pid, GF_PROP_PID_FILEPATH);\n\t\tif (prop && prop->value.string) src = prop->value.string;\n\n\t\tif (!src)\n\t\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\tif (!ctx->ipid) {\n\t\tGF_FilterEvent fevt;\n\t\tctx->ipid = pid;\n\n\t\tif (src) {\n\t\t\t//we work with full file only, send a play event on source to indicate that\n\t\t\tGF_FEVT_INIT(fevt, GF_FEVT_PLAY, pid);\n\t\t\tfevt.play.start_range = 0;\n\t\t\tfevt.base.on_pid = ctx->ipid;\n\t\t\tfevt.play.full_file_only = GF_TRUE;\n\t\t\tgf_filter_pid_send_event(ctx->ipid, &fevt);\n\t\t\tctx->file_name = gf_strdup(src);\n\t\t}\n\t} else {\n\t\tif (pid != ctx->ipid) {\n\t\t\treturn GF_REQUIRES_NEW_INSTANCE;\n\t\t}\n\t\tif (src) {\n\t\t\tif (!strcmp(ctx->file_name, src)) return GF_OK;\n\n\t\t\tttxtin_reset(ctx);\n\t\t\tctx->is_setup = GF_FALSE;\n\t\t\tgf_free(ctx->file_name);\n\t\t\tctx->file_name = gf_strdup(src);\n\t\t}\n\t}\n\tif (src) {\n\t\t//guess type\n\t\te = gf_text_guess_format(ctx, ctx->file_name, &ctx->fmt);\n\t\tif (e) return e;\n\t\tif (!ctx->fmt) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTLoad] Unknown text format for %s\\n\", ctx->file_name));\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\t} else {\n\t\tif (ctx->vtt_to_tx3g)\n\t\t\tctx->fmt = GF_TXTIN_MODE_SRT;\n\t\telse if (ctx->srt_to_tx3g)\n\t\t\tctx->fmt = GF_TXTIN_MODE_SRT;\n\t\telse if (codec_id == GF_CODECID_WEBVTT)\n\t\t\tctx->fmt = GF_TXTIN_MODE_WEBVTT;\n\t\telse if (codec_id == GF_CODECID_SUBS_SSA)\n\t\t\tctx->fmt = GF_TXTIN_MODE_SSA;\n\t\telse\n\t\t\tctx->fmt = ctx->simple_text ? GF_TXTIN_MODE_SIMPLE : GF_TXTIN_MODE_SRT;\n\t\tif (!ctx->opid)\n\t\t\tctx->opid = gf_filter_pid_new(filter);\n\t}\n\n\tif (ctx->webvtt && (ctx->fmt == GF_TXTIN_MODE_SRT))\n\t\tctx->fmt = GF_TXTIN_MODE_WEBVTT;\n\n\tif (!src) {\n\t\tgf_filter_pid_copy_properties(ctx->opid, pid);\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_TEXT) );\n\n\t\tif (!ctx->simple_text)\n\t\t\tcodec_id = (ctx->fmt == GF_TXTIN_MODE_WEBVTT) ? GF_CODECID_WEBVTT : GF_CODECID_TX3G;\n\t\telse if (ctx->stxtmod)\n\t\t\tcodec_id = (ctx->stxtmod==STXT_MODE_VTT) ? GF_CODECID_WEBVTT : GF_CODECID_TX3G;\n\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, &PROP_UINT(codec_id) );\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_UNFRAMED, NULL);\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, NULL);\n\t}\n\n\tswitch (ctx->fmt) {\n\tcase GF_TXTIN_MODE_SRT:\n\t\tctx->text_process = txtin_process_srt;\n\t\tif (!ctx->is_setup && ctx->unframed) gen_ttxt_dsi = GF_TRUE;\n\t\tbreak;\n#ifndef GPAC_DISABLE_VTT\n\tcase GF_TXTIN_MODE_WEBVTT:\n\t\tctx->text_process = txtin_process_webvtt;\n\t\tif (!ctx->is_setup && ctx->unframed) gen_webvtt_dsi = GF_TRUE;\n\t\tbreak;\n#endif\n\tcase GF_TXTIN_MODE_TTXT:\n\t\tctx->text_process = txtin_process_ttxt;\n\t\tbreak;\n\tcase GF_TXTIN_MODE_TEXML:\n\t\tctx->text_process = txtin_process_texml;\n\t\tbreak;\n\tcase GF_TXTIN_MODE_SUB:\n\t\tctx->text_process = gf_text_process_sub;\n\t\tif (!ctx->is_setup && ctx->unframed) gen_ttxt_dsi = GF_TRUE;\n\t\tbreak;\n\tcase GF_TXTIN_MODE_TTML:\n\t\tctx->text_process = gf_text_process_ttml;\n\t\tbreak;\n\tcase GF_TXTIN_MODE_SSA:\n\t\tctx->text_process = gf_text_process_ssa;\n\t\tif (!ctx->is_setup && ctx->unframed) gen_ttxt_dsi = GF_TRUE;\n\t\tbreak;\n#ifndef GPAC_DISABLE_SWF_IMPORT\n\tcase GF_TXTIN_MODE_SWF_SVG:\n\t\tctx->text_process = gf_text_process_swf;\n\t\tbreak;\n#endif\n\tcase GF_TXTIN_MODE_SIMPLE:\n\t\tctx->text_process = txtin_process_simple;\n\t\tif (ctx->stxtmod==STXT_MODE_TX3G) gen_ttxt_dsi = 1;\n\t\telse if (ctx->stxtmod==STXT_MODE_VTT) gen_webvtt_dsi = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tif (gen_ttxt_dsi) {\n\t\ttxtin_setup_srt(filter, ctx, GF_TRUE);\n\t}\n\tif (gen_webvtt_dsi) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA((u8 *) \"WEBVTT\", 7 ) );\n\t}\n\n\t//when translating from unframed srt/vtt to framed tx3g/vtt, the number of input samples will be at most doubled by inserting blank samples\n\tif (ctx->unframed && !ctx->no_empty) {\n\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_NB_FRAMES);\n\t\tif (p)\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_NB_FRAMES, &PROP_UINT(p->value.uint*2));\n\t}\n\n\treturn GF_OK;\n}\n\nstatic Bool txtin_process_event(GF_Filter *filter, const GF_FilterEvent *evt)\n{\n\tGF_TXTIn *ctx = gf_filter_get_udta(filter);\n\tif (ctx->unframed) return GF_FALSE;\n\n\tswitch (evt->base.type) {\n\tcase GF_FEVT_PLAY:\n\t\tif (ctx->playstate==1) return ctx->unframed ? GF_FALSE : GF_TRUE;\n\t\tif ((ctx->playstate==2) && !ctx->unframed)\n\t\t\tgf_filter_post_process_task(filter);\n\n\t\tctx->playstate = 1;\n\t\tif ((ctx->start_range < 0.1) && (evt->play.start_range<0.1)) return ctx->unframed ? GF_FALSE : GF_TRUE;\n\t\tctx->start_range = evt->play.start_range;\n\t\tctx->seek_state = 1;\n\t\t//cancel play event if we work with full file\n\t\treturn ctx->unframed ? GF_FALSE : GF_TRUE;\n\n\tcase GF_FEVT_STOP:\n\t\tctx->playstate = 2;\n\n\t\tttxtin_reset(ctx);\n\t\tctx->is_setup = GF_FALSE;\n\t\t//cancel play event if we work with full file\n\t\treturn ctx->unframed ? GF_FALSE : GF_TRUE;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n\treturn GF_FALSE;\n}\n\nGF_Err txtin_initialize(GF_Filter *filter)\n{\n\tchar data[1];\n\tGF_TXTIn *ctx = gf_filter_get_udta(filter);\n\tctx->bs_w = gf_bs_new(data, 1, GF_BITSTREAM_WRITE);\n\n\treturn GF_OK;\n}\n\nvoid txtin_finalize(GF_Filter *filter)\n{\n\tGF_TXTIn *ctx = gf_filter_get_udta(filter);\n\n\tttxtin_reset(ctx);\n\tif (ctx->bs_w) gf_bs_del(ctx->bs_w);\n\n\tif (ctx->text_descs) {\n\t\twhile (gf_list_count(ctx->text_descs)) {\n\t\t\tGF_PropertyValue *p = gf_list_pop_back(ctx->text_descs);\n\t\t\tgf_free(p->value.data.ptr);\n\t\t\tgf_free(p);\n\t\t}\n\t\tgf_list_del(ctx->text_descs);\n\t}\n#ifndef GPAC_DISABLE_SWF_IMPORT\n\tgf_swf_reader_del(ctx->swf_parse);\n#endif\n\n\tif (ctx->intervals) {\n\t\tttml_reset_intervals(ctx);\n\t\tgf_list_del(ctx->intervals);\n\t}\n\tif (ctx->ttml_resources) {\n\t\twhile (gf_list_count(ctx->ttml_resources)) {\n\t\t\tTTMLRes *ires = gf_list_pop_back(ctx->ttml_resources);\n\t\t\tgf_free(ires->data);\n\t\t\tgf_free(ires);\n\t\t}\n\t\tgf_list_del(ctx->ttml_resources);\n\t}\n\tif (ctx->div_nodes_list)\n\t\tgf_list_del(ctx->div_nodes_list);\n\n\tif (ctx->file_name) gf_free(ctx->file_name);\n}\n\n\nstatic const char *txtin_probe_data(const u8 *data, u32 data_size, GF_FilterProbeScore *score)\n{\n\tchar *dst = NULL;\n\tchar *res=NULL;\n\tGF_Err e = gf_utf_get_utf8_string_from_bom((char *)data, data_size, &dst, &res);\n\tif (e) return NULL;\n\n\tdata = res;\n\t//strip all spaces and \\r\\n\\t\n\twhile (data[0] && strchr(\"\\n\\r\\t \", (char) data[0]))\n\t\tdata ++;\n\n#define PROBE_OK(_score, _mime) \\\n\t\t*score = _score;\\\n\t\tif (dst) gf_free(dst);\\\n\t\treturn _mime; \\\n\n\n\tif (!strncmp(data, \"WEBVTT\", 6)) {\n\t\tPROBE_OK(GF_FPROBE_SUPPORTED, \"subtitle/vtt\")\n\t}\n\tif (strstr(data, \" --> \")) {\n\t\tPROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, \"subtitle/srt\")\n\t}\n\tif (!strncmp(data, \"FWS\", 3) || !strncmp(data, \"CWS\", 3)) {\n\t\tPROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, \"application/x-shockwave-flash\")\n\t}\n\tif (!strncmp(data, \"[Script Info\", 12)) {\n\t\tPROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, \"subtitle/ssa\")\n\t}\n\n\tif ((data[0]=='{') && strstr(data, \"}{\")) {\n\t\tPROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, \"subtitle/sub\")\n\n\t}\n\t/*XML formats*/\n\tif (!strstr(data, \"?>\") ) {\n\t\tif (dst) gf_free(dst);\n\t\treturn NULL;\n\t}\n\n\tif (strstr(data, \"<x-quicktime-tx3g\") || strstr(data, \"<text3GTrack\")) {\n\t\tPROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, \"quicktime/text\")\n\t}\n\tif (strstr(data, \"TextStream\")) {\n\t\tPROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, \"subtitle/ttxt\")\n\t}\n\tif (strstr(data, \"<tt \") || strstr(data, \":tt \")) {\n\t\tPROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, \"subtitle/ttml\")\n\t}\n\n\tif (dst) gf_free(dst);\n\treturn NULL;\n}\n\nstatic const GF_FilterCapability TXTInCaps[] =\n{\n\tCAP_UINT(GF_CAPS_INPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_FILE_EXT, \"srt|ttxt|sub|vtt|txml|ttml|swf|ssa|ass\"),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_MIME, \"x-subtitle/srt|subtitle/srt|text/srt|x-subtitle/sub|subtitle/sub|text/sub|x-subtitle/ttxt|subtitle/ttxt|text/ttxt|x-subtitle/vtt|subtitle/vtt|text/vtt|x-quicktime/text|quicktime/text|subtitle/ttml|text/ttml|application/xml+ttml|application/x-shockwave-flash|subtitle/ssa|text/ssa\"),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_TEXT),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_CODECID, GF_CODECID_TX3G),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_CODECID, GF_CODECID_SIMPLE_TEXT),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_CODECID, GF_CODECID_WEBVTT),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_CODECID, GF_CODECID_SUBS_XML),\n\t{0},\n\t//unframed SRT\n\tCAP_UINT(GF_CAPS_INPUT_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_TEXT),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_SUBS_TEXT),\n\tCAP_BOOL(GF_CAPS_INPUT, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_CODECID, GF_CODECID_TX3G),\n\t{0},\n\t//unframed WebVTT\n\tCAP_UINT(GF_CAPS_INPUT_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_TEXT),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_WEBVTT),\n\tCAP_BOOL(GF_CAPS_INPUT, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_CODECID, GF_CODECID_WEBVTT),\n\t{0},\n\t//unframed SSA\n\tCAP_UINT(GF_CAPS_INPUT_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_TEXT),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_SUBS_SSA),\n\tCAP_BOOL(GF_CAPS_INPUT, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_CODECID, GF_CODECID_TX3G),\n\t{0},\n\t//text files\n\tCAP_UINT(GF_CAPS_INPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_UINT(GF_CAPS_INPUT_OUTPUT, GF_PROP_PID_CODECID, GF_CODECID_SUBS_TEXT),\n\tCAP_UINT(GF_CAPS_INPUT_OUTPUT, GF_PROP_PID_CODECID, GF_CODECID_SIMPLE_TEXT),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_TEXT),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_CODECID, GF_CODECID_TX3G),\n};\n\n#define OFFS(_n)\t#_n, offsetof(GF_TXTIn, _n)\n\nstatic const GF_FilterArgs TXTInArgs[] =\n{\n\t{ OFFS(webvtt), \"force WebVTT import of SRT files\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(nodefbox), \"skip default text box\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(noflush), \"skip final sample flush for srt\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(fontname), \"default font\", GF_PROP_STRING, NULL, NULL, 0},\n\t{ OFFS(fontsize), \"default font size\", GF_PROP_UINT, \"18\", NULL, 0},\n\t{ OFFS(lang), \"default language\", GF_PROP_STRING, NULL, NULL, 0},\n\t{ OFFS(width), \"default width of text area\", GF_PROP_UINT, \"0\", NULL, 0},\n\t{ OFFS(height), \"default height of text area\", GF_PROP_UINT, \"0\", NULL, 0},\n\t{ OFFS(txtx), \"default horizontal offset of text area: -1 (left), 0 (center) or 1 (right)\", GF_PROP_UINT, \"0\", NULL, 0},\n\t{ OFFS(txty), \"default vertical offset of text area: -1 (bottom), 0 (center) or 1 (top)\", GF_PROP_UINT, \"0\", NULL, 0},\n\t{ OFFS(zorder), \"default z-order of the PID\", GF_PROP_SINT, \"0\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(timescale), \"default timescale of the PID\", GF_PROP_UINT, \"1000\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(ttml_split), \"split ttml doc in non-overlapping samples\", GF_PROP_BOOL, \"true\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(ttml_cts), \"first sample cts - see filter help\", GF_PROP_FRACTION64, \"-1/1\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(ttml_dur), \"sample duration when not spliting split - see filter help\", GF_PROP_FRACTION, \"0/1\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(ttml_embed), \"force embedding TTML resources\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(ttml_zero), \"set subtitle zero time for TTML\", GF_PROP_STRING, NULL, NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(no_empty), \"do not send empty samples\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(stxtdur), \"duration for simple text\", GF_PROP_FRACTION, \"1\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(stxtmod), \"simple text stream mode\"\n\t\"- none: declares output PID as simple text stream\\n\"\n\t\"- tx3g: declares output PID as TX3G/Apple stream\\n\"\n\t\"- vtt: declares output PID as WebVTT stream\", GF_PROP_UINT, \"none\", \"none|tx3g|vtt\", GF_FS_ARG_HINT_EXPERT},\n\t{0}\n};\n\nGF_FilterRegister TXTInRegister = {\n\t.name = \"txtin\",\n\tGF_FS_SET_DESCRIPTION(\"Subtitle loader\")\n\tGF_FS_SET_HELP(\"This filter reads subtitle data from input PID to produce subtitle frames on a single PID.\\n\"\n\t\"The filter supports the following formats:\\n\"\n\t\"- SRT: https://en.wikipedia.org/wiki/SubRip\\n\"\n\t\"- WebVTT: https://www.w3.org/TR/webvtt1/\\n\"\n\t\"- TTXT: https://wiki.gpac.io/TTXT-Format-Documentation\\n\"\n\t\"- QT 3GPP Text XML (TexML): Apple QT6, likely deprecated\\n\"\n\t\"- TTML: https://www.w3.org/TR/ttml2/\\n\"\n\t\"- SUB: one subtitle per line formatted as `{start_frame}{end_frame}text`\\n\"\n\t\"- SSA (Substation Alpha): basic parsing support for common files\\n\"\n\t\"\\n\"\n\t\"Input files must be in UTF-8 or UTF-16 format, with or without BOM. The internal frame format is: \\n\"\n\t\"- WebVTT (and srt if desired): ISO/IEC 14496-30 VTT cues\\n\"\n\t\"- TTML: ISO/IEC 14496-30 XML subtitles\\n\"\n\t\"- Others: 3GPP/QT Timed Text\\n\"\n\t\"\\n\"\n\t\"# TTML Support\\n\"\n\t\"If [-ttml_split]() option is set, the TTML document is split in independent time segments by inspecting all overlapping subtitles in the body.\\n\"\n\t\"Empty periods in TTML will result in empty TTML documents or will be skipped if [-no_empty]() option is set.\\n\"\n\t\"\\n\"\n\t\"The first sample has a CTS assigned as indicated by [-ttml_cts]():\\n\"\n\t\"- a numerator of -2 indicates the first CTS is 0\\n\"\n\t\"- a numerator of -1 indicates the first CTS is the first active time in document\\n\"\n\t\"- a numerator >= 0 indicates the CTS to use for first sample\\n\"\n\t\"\\n\"\n\t\"When TTML splitting is disabled, the duration of the TTML sample is given by [-ttml_dur]() if not 0, or set to the document duration\\n\"\n\t\"\\n\"\n\t\"By default, media resources are kept as declared in TTML2 documents.\\n\"\n\t\"\\n\"\n\t\"[-ttml_embed]() can be used to embed inside the TTML sample the resources in `<head>` or `<body>`:\\n\"\n\t\"- for `<source>`, `<image>`, `<audio>`, `<font>`, local URIs indicated in `src` will be loaded and `src` rewritten.\\n\"\n\t\"- for `<data>` with base64 coding, the data will be decoded, `<data>` element removed and parent <source> rewritten with `src` attribute inserted.\\n\"\n\t\"\\nThe embedded data is added as a subsample to the TTML frame, and the referring elements will use `src=urn:mpeg:14496-30:N` with `N` the index of the subsample.\\n\"\n\t\"\\n\"\n\t\"A `subtitle zero` may be specified using [-ttml_zero](). This will remove all subtitles before the given time `T0`, and rewrite each subtitle begin/end `T` to `T-T0` using millisecond accuracy.\\n\"\n\t\"Warning: Original time formatting (tick, frames/subframe ...) will be lost when this option is used, converted to `HH:MM:SS.ms`.\\n\"\n\t\"\\n\"\n\t\"The subtitle zero time **must** be prefixed with `T` when the option is not set as a global argument:\\n\"\n\t\"EX gpac -i test.ttml:ttml_zero=T10:00:00 [...]\\n\"\n\t\"EX MP4Box -add test.ttml:sopt:ttml_zero=T10:00:00 [...]\\n\"\n\t\"EX gpac -i test.ttml --ttml_zero=10:00:00 [...]\\n\"\n\t\"EX gpac -i test.ttml --ttml_zero=T10:00:00 [...]\\n\"\n\t\"EX MP4Box -add test.ttml --ttml_zero=10:00:00 [...]\\n\"\n\t\"\\n\"\n\t\"# Simple Text Support\\n\"\n\t\"The text loader can convert input files in simple text streams of a single packet, by forcing the codec type on the input:\"\n\t\"EX gpac -i test.txt:#CodecID=stxt  [...]\\n\"\n\t\"EX gpac fin:pck=\\\"Text Data\\\":#CodecID=stxt  [...]\\n\"\n\t\"\\n\"\n\t\"The content of the source file will be the payload of the text sample. The [-stxtmod]() option allows specifying WebVTT, TX3G or simple text mode for output format.\\n\"\n\t\"In this mode, the [-stxtdur]() option is used to control the duration of the generated subtitle:\\n\"\n\t\"- a positive value always forces the duration\\n\"\n\t\"- a negative value forces the duration if input packet duration is not known\\n\"\n\t)\n\n\t.private_size = sizeof(GF_TXTIn),\n\t.flags = GF_FS_REG_MAIN_THREAD,\n\t.args = TXTInArgs,\n\tSETCAPS(TXTInCaps),\n\t.process = txtin_process,\n\t.configure_pid = txtin_configure_pid,\n\t.process_event = txtin_process_event,\n\t.probe_data = txtin_probe_data,\n\t.initialize = txtin_initialize,\n\t.finalize = txtin_finalize\n};\n\n\nconst GF_FilterRegister *txtin_register(GF_FilterSession *session)\n{\n\treturn &TXTInRegister;\n}\n\nstatic GF_Err vtt2tx3g_initialize(GF_Filter *filter)\n{\n\tGF_TXTIn *ctx = gf_filter_get_udta(filter);\n\ttxtin_initialize(filter);\n\tctx->vtt_to_tx3g = GF_TRUE;\n\treturn GF_OK;\n}\n\nstatic const GF_FilterCapability VTTTX3GCaps[] =\n{\n\t//unframed WebVTT\n\tCAP_UINT(GF_CAPS_INPUT_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_TEXT),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_WEBVTT),\n\tCAP_BOOL(GF_CAPS_INPUT, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_CODECID, GF_CODECID_TX3G),\n\tCAP_BOOL(GF_CAPS_OUTPUT_EXCLUDED, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\t{0},\n};\n\n#define OFFS(_n)\t#_n, offsetof(GF_TXTIn, _n)\n\nstatic const GF_FilterArgs VTTTX3GArgs[] =\n{\n\t{ OFFS(fontname), \"default font\", GF_PROP_STRING, NULL, NULL, 0},\n\t{ OFFS(fontsize), \"default font size\", GF_PROP_UINT, \"18\", NULL, 0},\n\t{0}\n};\n\nGF_FilterRegister VTTTX3GRegister = {\n\t.name = \"vtt2tx3g\",\n\tGF_FS_SET_DESCRIPTION(\"WebVTT to TX3G\")\n\tGF_FS_SET_HELP(\"This filter rewrites unframed WebVTT to TX3G / QT Timed Text (binary format)\\n\"\n\t\"\\n\"\n\t\"Unframed WebVTT packets consist in single cues:\\n\"\n\t\"- cue payload as packet payload\\n\"\n\t\"- prefix as packet string property `vtt_pre`\\n\"\n\t\"- cue ID as packet string property `vtt_cueid`\\n\"\n\t\"- cue settings as packet string property `vtt_settings`\\n\"\n\t\"- packet timing contains the cue timing (start and duration)\\n\"\n\t)\n\n\t.private_size = sizeof(GF_TXTIn),\n\t.flags = GF_FS_REG_MAIN_THREAD,\n\t.args = VTTTX3GArgs,\n\tSETCAPS(VTTTX3GCaps),\n\t.process = txtin_process,\n\t.configure_pid = txtin_configure_pid,\n\t.process_event = txtin_process_event,\n\t.probe_data = txtin_probe_data,\n\t.initialize = vtt2tx3g_initialize,\n\t.finalize = txtin_finalize\n};\n\nconst GF_FilterRegister *vtt2tx3g_register(GF_FilterSession *session)\n{\n\treturn &VTTTX3GRegister;\n}\n\nstatic GF_Err rfsrt_initialize(GF_Filter *filter)\n{\n\tGF_TXTIn *ctx = gf_filter_get_udta(filter);\n\ttxtin_initialize(filter);\n\tctx->srt_to_tx3g = GF_TRUE;\n\treturn GF_OK;\n}\n\nstatic const GF_FilterCapability RFSRTCaps[] =\n{\n\t//unframed WebVTT\n\tCAP_UINT(GF_CAPS_INPUT_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_TEXT),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_SIMPLE_TEXT),\n//\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_SUBS_TEXT),\n\tCAP_BOOL(GF_CAPS_INPUT, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_CODECID, GF_CODECID_TX3G),\n\tCAP_BOOL(GF_CAPS_OUTPUT_EXCLUDED, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\t{0},\n};\n\n#define OFFS(_n)\t#_n, offsetof(GF_TXTIn, _n)\n\nstatic const GF_FilterArgs RFSRTArgs[] =\n{\n\t{ OFFS(fontname), \"default font\", GF_PROP_STRING, NULL, NULL, 0},\n\t{ OFFS(fontsize), \"default font size\", GF_PROP_UINT, \"18\", NULL, 0},\n\t{0}\n};\n\nGF_FilterRegister RFSRTRegister = {\n\t.name = \"rfsrt\",\n\tGF_FS_SET_DESCRIPTION(\"SRT reframer\")\n\tGF_FS_SET_HELP(\"This filter rewrites unframed SRT to TX3G / QT Timed Text (binary format)\\n\"\n\t\"\\n\"\n\t\"An unframed SRT packet consists in a single SRT cue as packet payload and packet timing contains the cue timing (start and duration).\\n\"\n\t)\n\n\t.private_size = sizeof(GF_TXTIn),\n\t.flags = GF_FS_REG_MAIN_THREAD,\n\t.args = RFSRTArgs,\n\tSETCAPS(RFSRTCaps),\n\t.process = txtin_process,\n\t.configure_pid = txtin_configure_pid,\n\t.process_event = txtin_process_event,\n\t.probe_data = txtin_probe_data,\n\t.initialize = rfsrt_initialize,\n\t.finalize = txtin_finalize\n};\n\nconst GF_FilterRegister *rfsrt_register(GF_FilterSession *session)\n{\n\treturn &RFSRTRegister;\n}\n\n#else\nconst GF_FilterRegister *txtin_register(GF_FilterSession *session)\n{\n\treturn NULL;\n}\n\nconst GF_FilterRegister *vtt2tx3g_register(GF_FilterSession *session)\n{\n\treturn NULL;\n}\n\nconst GF_FilterRegister *rfsrt_register(GF_FilterSession *session)\n{\n\treturn NULL;\n}\n\n#endif // GPAC_DISABLE_ISOM_WRITE\n"], "filenames": ["src/filters/load_text.c"], "buggy_code_start_loc": [317], "buggy_code_end_loc": [361], "fixing_code_start_loc": [318], "fixing_code_end_loc": [373], "type": "CWE-193", "message": "Off-by-one Error in GitHub repository gpac/gpac prior to v2.3.0-DEV.", "other": {"cve": {"id": "CVE-2023-0818", "sourceIdentifier": "security@huntr.dev", "published": "2023-02-13T22:15:13.527", "lastModified": "2023-05-27T04:15:23.697", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Off-by-one Error in GitHub repository gpac/gpac prior to v2.3.0-DEV."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.2}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-193"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-193"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.3.0-dev", "matchCriteriaId": "F3A1B96B-3E09-4DB5-B15E-249D5E6EDEDC"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/377ab25f3e502db2934a9cf4b54739e1c89a02ff", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/038e7472-f3e9-46c2-9aea-d6dafb62a18a", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2023/dsa-5411", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/377ab25f3e502db2934a9cf4b54739e1c89a02ff"}}