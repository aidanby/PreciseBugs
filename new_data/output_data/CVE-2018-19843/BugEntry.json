{"buggy_code": ["/* Copyright (C) 2008-2018 - pancake, unlogic, emvivre */\n\n#include <r_flag.h>\n#include <r_core.h>\n#include <r_asm.h>\n#include <r_lib.h>\n#include <r_types.h>\n#include <stdio.h>\n#include <string.h>\n\nstatic ut64 getnum(RAsm *a, const char *s);\n\n#define ENCODING_SHIFT 0\n#define OPTYPE_SHIFT   6\n#define REGMASK_SHIFT  16\n#define OPSIZE_SHIFT   24\n\n// How to encode the operand?\n#define OT_REGMEM      (1 << (ENCODING_SHIFT + 0))\n#define OT_SPECIAL     (1 << (ENCODING_SHIFT + 1))\n#define OT_IMMEDIATE   (1 << (ENCODING_SHIFT + 2))\n#define OT_JMPADDRESS  (1 << (ENCODING_SHIFT + 3))\n\n// Register indices - by default, we allow all registers\n#define OT_REGALL   (0xff << REGMASK_SHIFT)\n\n// Memory or register operands: how is the operand written in assembly code?\n#define OT_MEMORY      (1 << (OPTYPE_SHIFT + 0))\n#define OT_CONSTANT    (1 << (OPTYPE_SHIFT + 1))\n#define OT_GPREG      ((1 << (OPTYPE_SHIFT + 2)) | OT_REGALL)\n#define OT_SEGMENTREG ((1 << (OPTYPE_SHIFT + 3)) | OT_REGALL)\n#define OT_FPUREG     ((1 << (OPTYPE_SHIFT + 4)) | OT_REGALL)\n#define OT_MMXREG     ((1 << (OPTYPE_SHIFT + 5)) | OT_REGALL)\n#define OT_XMMREG     ((1 << (OPTYPE_SHIFT + 6)) | OT_REGALL)\n#define OT_CONTROLREG ((1 << (OPTYPE_SHIFT + 7)) | OT_REGALL)\n#define OT_DEBUGREG   ((1 << (OPTYPE_SHIFT + 8)) | OT_REGALL)\n#define OT_SREG       ((1 << (OPTYPE_SHIFT + 9)) | OT_REGALL)\n// more?\n\n#define OT_REGTYPE    ((OT_GPREG | OT_SEGMENTREG | OT_FPUREG | OT_MMXREG | OT_XMMREG | OT_CONTROLREG | OT_DEBUGREG) & ~OT_REGALL)\n\n// Register mask\n#define OT_REG(num)  ((1 << (REGMASK_SHIFT + (num))) | OT_REGTYPE)\n\n#define OT_UNKNOWN    (0 << OPSIZE_SHIFT)\n#define OT_BYTE       (1 << OPSIZE_SHIFT)\n#define OT_WORD       (2 << OPSIZE_SHIFT)\n#define OT_DWORD      (4 << OPSIZE_SHIFT)\n#define OT_QWORD      (8 << OPSIZE_SHIFT)\n#define OT_OWORD     (16 << OPSIZE_SHIFT)\n#define OT_TBYTE     (32 << OPSIZE_SHIFT)\n\n#define ALL_SIZE     (OT_BYTE | OT_WORD | OT_DWORD | OT_QWORD | OT_OWORD)\n\n// For register operands, we mostl don't care about the size.\n// So let's just set all relevant flags.\n#define OT_FPUSIZE  (OT_DWORD | OT_QWORD | OT_TBYTE)\n#define OT_XMMSIZE  (OT_DWORD | OT_QWORD | OT_OWORD)\n\n// Macros for encoding\n#define OT_REGMEMOP(type)  (OT_##type##REG | OT_MEMORY | OT_REGMEM)\n#define OT_REGONLYOP(type) (OT_##type##REG | OT_REGMEM)\n#define OT_MEMONLYOP       (OT_MEMORY | OT_REGMEM)\n#define OT_MEMIMMOP        (OT_MEMORY | OT_IMMEDIATE)\n#define OT_REGSPECOP(type) (OT_##type##REG | OT_SPECIAL)\n#define OT_IMMOP           (OT_CONSTANT | OT_IMMEDIATE)\n#define OT_MEMADDROP       (OT_MEMORY | OT_IMMEDIATE)\n\n// Some operations are encoded via opcode + spec field\n#define SPECIAL_SPEC 0x00010000\n#define SPECIAL_MASK 0x00000007\n\n#define MAX_OPERANDS 3\n#define MAX_REPOP_LENGTH 20\n\nconst ut8 SEG_REG_PREFIXES[] = {0x26, 0x2e, 0x36, 0x3e, 0x64, 0x65};\n\ntypedef enum tokentype_t {\n\tTT_EOF,\n\tTT_WORD,\n\tTT_NUMBER,\n\tTT_SPECIAL\n} x86newTokenType;\n\ntypedef enum register_t {\n\tX86R_UNDEFINED = -1,\n\tX86R_EAX = 0, X86R_ECX, X86R_EDX, X86R_EBX, X86R_ESP, X86R_EBP, X86R_ESI, X86R_EDI, X86R_EIP,\n\tX86R_AX = 0, X86R_CX, X86R_DX, X86R_BX, X86R_SP, X86R_BP, X86R_SI, X86R_DI,\n\tX86R_AL = 0, X86R_CL, X86R_DL, X86R_BL, X86R_AH, X86R_CH, X86R_DH, X86R_BH,\n\tX86R_RAX = 0, X86R_RCX, X86R_RDX, X86R_RBX, X86R_RSP, X86R_RBP, X86R_RSI, X86R_RDI, X86R_RIP,\n\tX86R_R8 = 0, X86R_R9, X86R_R10, X86R_R11, X86R_R12, X86R_R13, X86R_R14, X86R_R15,\n\tX86R_CS = 0, X86R_SS, X86R_DS, X86R_ES, X86R_FS, X86R_GS\t// Is this the right order?\n} Register;\n\ntypedef struct operand_t {\n\tut32 type;\n\tst8 sign;\n\tstruct {\n\t\tRegister reg;\n\t\tbool extended;\n\t};\n\tunion {\n\t\tstruct {\n\t\t\tlong offset;\n\t\t\tst8 offset_sign;\n\t\t\tRegister regs[2];\n\t\t\tint scale[2];\n\t\t};\n\t\tstruct {\n\t\t\tut64 immediate;\n\t\t\tbool is_good_flag;\n\t\t};\n\t\tstruct {\n\t\t\tchar rep_op[MAX_REPOP_LENGTH];\n\t\t};\n\t};\n\tbool explicit_size;\n\tut32 dest_size;\n\tut32 reg_size;\n} Operand;\n\ntypedef struct Opcode_t {\n\tchar *mnemonic;\n\tut32 op[3];\n\tsize_t op_len;\n\tbool is_short;\n\tut8 opcode[3];\n\tint operands_count;\n\tOperand operands[MAX_OPERANDS];\n\tbool has_bnd;\n} Opcode;\n\nstatic ut8 getsib(const ut8 sib) {\n\tif (!sib) {\n\t\treturn 0;\n\t}\n\treturn (sib & 0x8) ? 3 : getsib ((sib << 1) | 1) - 1;\n}\n\nstatic int is_al_reg(const Operand *op) {\n\tif (op->type & OT_MEMORY) {\n\t\treturn 0;\n\t}\n\tif (op->reg == X86R_AL && op->type & OT_BYTE) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int oprep(RAsm *a, ut8 *data, const Opcode *op);\n\nstatic int process_16bit_group_1(RAsm *a, ut8 *data, const Opcode *op, int op1) {\n\tint l = 0;\n\tint immediate = op->operands[1].immediate * op->operands[1].sign;\n\n\tdata[l++] = 0x66;\n\tif (op->operands[1].immediate < 128) {\n\t\tdata[l++] = 0x83;\n\t\tdata[l++] = op->operands[0].reg | (0xc0 + op1 + op->operands[0].reg);\n\t} else {\n\t\tif (op->operands[0].reg == X86R_AX) {\n\t\t\tdata[l++] = 0x05 + op1;\n\t\t} else {\n\t\t\tdata[l++] = 0x81;\n\t\t\tdata[l++] = (0xc0 + op1) | op->operands[0].reg;\n\t\t}\n\t}\n\tdata[l++] = immediate;\n\tif (op->operands[1].immediate > 127) {\n\t\tdata[l++] = immediate >> 8;\n\t}\n\n\treturn l;\n}\n\nstatic int process_group_1(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tint modrm = 0;\n\tint mod_byte = 0;\n\tint offset = 0;\n\tint mem_ref = 0;\n\tst32 immediate = 0;\n\n\tif (!op->operands[1].is_good_flag) {\n\t\treturn -1;\n\t}\n\tif (a->bits == 64 && op->operands[0].type & OT_QWORD) {\n\t\tdata[l++] = 0x48;\n\t}\n\tif (!strcmp (op->mnemonic, \"adc\")) {\n\t\tmodrm = 2;\n\t} else if (!strcmp (op->mnemonic, \"add\")) {\n\t\tmodrm = 0;\n\t} else if (!strcmp (op->mnemonic, \"or\")) {\n\t\tmodrm = 1;\n\t} else if (!strcmp (op->mnemonic, \"and\")) {\n\t\tmodrm = 4;\n\t} else if (!strcmp (op->mnemonic, \"xor\")) {\n\t\tmodrm = 6;\n\t} else if (!strcmp (op->mnemonic, \"sbb\")) {\n\t\tmodrm = 3;\n\t} else if (!strcmp (op->mnemonic, \"sub\")) {\n\t\tmodrm = 5;\n\t} else if (!strcmp (op->mnemonic, \"cmp\")) {\n\t\tmodrm = 7;\n\t}\n\timmediate = op->operands[1].immediate * op->operands[1].sign;\n\n\tif (op->operands[0].type & OT_DWORD ||\n\t\top->operands[0].type & OT_QWORD) {\n\t\tif (op->operands[1].immediate < 128) {\n\t\t\tdata[l++] = 0x83;\n\t\t} else if (op->operands[0].reg != X86R_EAX ||\n\t\t           op->operands[0].type & OT_MEMORY) {\n\t\t\tdata[l++] = 0x81;\n\t\t}\n\t} else if (op->operands[0].type & OT_BYTE) {\n\t\tif (op->operands[1].immediate > 255) {\n\t\t\teprintf (\"Error: Immediate exceeds bounds\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tdata[l++] = 0x80;\n\t}\n\tif (op->operands[0].type & OT_MEMORY) {\n\t\toffset = op->operands[0].offset * op->operands[0].offset_sign;\n\t\tif (op->operands[0].offset || op->operands[0].regs[0] == X86R_EBP) {\n\t\t\tmod_byte = 1;\n\t\t}\n\t\tif (offset < ST8_MIN || offset > ST8_MAX) {\n\t\t\tmod_byte = 2;\n\t\t}\n\t\tint reg0 = op->operands[0].regs[0];\n\t\tif (reg0 == -1) {\n\t\t\tmem_ref = 1;\n\t\t\treg0 = 5;\n\t\t\tmod_byte = 0;\n\t\t}\n\t\tdata[l++] = mod_byte << 6 | modrm << 3 | reg0;\n\t\tif (op->operands[0].regs[0] == X86R_ESP) {\n\t\t\tdata[l++] = 0x24;\n\t\t}\n\t\tif (mod_byte || mem_ref) {\n\t\t\tdata[l++] = offset;\n\t\t\tif (mod_byte == 2 || mem_ref) {\n\t\t\t\tdata[l++] = offset >> 8;\n\t\t\t\tdata[l++] = offset >> 16;\n\t\t\t\tdata[l++] = offset >> 24;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (op->operands[1].immediate > 127 && op->operands[0].reg == X86R_EAX) {\n\t\t\tdata[l++] = 5 | modrm << 3 | op->operands[0].reg;\n\t\t} else {\n\t\t\tmod_byte = 3;\n\t\t\tdata[l++] = mod_byte << 6 | modrm << 3 | op->operands[0].reg;\n\t\t}\n\n\t}\n\n\tdata[l++] = immediate;\n\tif ((immediate > 127 || immediate < -128) &&\n\t    ((op->operands[0].type & OT_DWORD) || (op->operands[0].type & OT_QWORD))) {\n\t\tdata[l++] = immediate >> 8;\n\t\tdata[l++] = immediate >> 16;\n\t\tdata[l++] = immediate >> 24;\n\t}\n\treturn l;\n}\n\nstatic int process_group_2(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tint modrm = 0;\n\tint mod_byte = 0;\n\tint reg0 = 0;\n\n\tif (a->bits == 64 && op->operands[0].type & OT_QWORD) { data[l++] = 0x48; }\n\n\tif (!strcmp (op->mnemonic, \"rol\")) {\n\t\tmodrm = 0;\n\t} else if (!strcmp (op->mnemonic, \"ror\")) {\n\t\tmodrm = 1;\n\t} else if (!strcmp (op->mnemonic, \"rcl\")) {\n\t\tmodrm = 2;\n\t} else if (!strcmp (op->mnemonic, \"rcr\")) {\n\t\tmodrm = 3;\n\t} else if (!strcmp (op->mnemonic, \"shl\")) {\n\t\tmodrm = 4;\n\t} else if (!strcmp (op->mnemonic, \"shr\")) {\n\t\tmodrm = 5;\n\t} else if (!strcmp (op->mnemonic, \"sal\")) {\n\t\tmodrm = 6;\n\t} else if (!strcmp (op->mnemonic, \"sar\")) {\n\t\tmodrm = 7;\n\t}\n\n\tst32 immediate = op->operands[1].immediate * op->operands[1].sign;\n\tif (immediate > 255 || immediate < -128) {\n\t\teprintf (\"Error: Immediate exceeds bounds\\n\");\n\t\treturn -1;\n\t}\n\n\tif (op->operands[0].type & (OT_DWORD | OT_QWORD)) {\n\t\tif (op->operands[1].type & (OT_GPREG | OT_BYTE)) {\n\t\t\tdata[l++] = 0xd3;\n\t\t} else if (immediate == 1) {\n\t\t\tdata[l++] = 0xd1;\n\t\t} else {\n\t\t\tdata[l++] = 0xc1;\n\t\t}\n\t} else if (op->operands[0].type & OT_BYTE) {\n\t\tconst Operand *o = &op->operands[0];\n\t\tif (o->regs[0] != -1 && o->regs[1] != -1) {\n\t\t\tdata[l++] = 0xc0;\n\t\t\tdata[l++] = 0x44;\n\t\t\tdata[l++] = o->regs[0]| (o->regs[1]<<3);\n\t\t\tdata[l++] = (ut8)((o->offset*o->offset_sign) & 0xff);\n\t\t\tdata[l++] = immediate;\n\t\t\treturn l;\n\t\t} else if (op->operands[1].type & (OT_GPREG | OT_WORD)) {\n\t\t\tdata[l++] = 0xd2;\n\t\t} else if (immediate == 1) {\n\t\t\tdata[l++] = 0xd0;\n\t\t} else {\n\t\t\tdata[l++] = 0xc0;\n\t\t}\n\t}\n\tif (op->operands[0].type & OT_MEMORY) {\n\t\treg0 = op->operands[0].regs[0];\n\t\tmod_byte = 0;\n\t} else {\n\t\treg0 = op->operands[0].reg;\n\t\tmod_byte = 3;\n\t}\n\tdata[l++] = mod_byte << 6 | modrm << 3 | reg0;\n\tif (immediate != 1 && !(op->operands[1].type & OT_GPREG)) {\n\t\tdata[l++] = immediate;\n\t}\n\treturn l;\n}\n\nstatic int process_1byte_op(RAsm *a, ut8 *data, const Opcode *op, int op1) {\n\tint l = 0;\n\tint mod_byte = 0;\n\tint reg = 0;\n\tint rm = 0;\n\tint rex = 0;\n\tint mem_ref = 0;\n\tst32 offset = 0;\n\tint ebp_reg = 0;\n\n\tif (!op->operands[1].is_good_flag) {\n\t\treturn -1;\n\t}\n\n\tif (op->operands[0].reg == X86R_AL && op->operands[1].type & OT_CONSTANT) {\n\t\tdata[l++] = op1 + 4;\n\t\tdata[l++] = op->operands[1].immediate * op->operands[1].sign;\n\t\treturn l;\n\t}\n\n\tif (a->bits == 64) {\n\t\tif (!(op->operands[0].type & op->operands[1].type)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (a->bits == 64 && ((op->operands[0].type & OT_QWORD) | (op->operands[1].type & OT_QWORD))) {\n\t\tif (op->operands[0].extended) {\n\t\t\t\trex = 1;\n\t\t}\n\t\tif (op->operands[1].extended) {\n\t\t\trex += 4;\n\t\t}\n\t\tdata[l++] = 0x48 | rex;\n\t}\n\n\tif (op->operands[0].type & OT_MEMORY && op->operands[1].type & OT_REGALL) {\n\t\tif (a->bits == 64 && (op->operands[0].type & OT_DWORD) &&\n\t\t    (op->operands[1].type & OT_DWORD)) {\n\t\t\tdata[l++] = 0x67;\n\t\t}\n\t\tif (op->operands[0].type & OT_BYTE && op->operands[1].type & OT_BYTE) {\n\t\t\tdata[l++] = op1;\n\t\t} else if (op->operands[0].type & (OT_DWORD | OT_QWORD) &&\n\t\t\t   op->operands[1].type & (OT_DWORD | OT_QWORD)) {\n\t\t\tdata[l++] = op1 + 0x1;\n\t\t} else {\n\t\t\teprintf (\"Error: mismatched operand sizes\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\treg = op->operands[1].reg;\n\t\trm = op->operands[0].regs[0];\n\t\toffset = op->operands[0].offset * op->operands[0].offset_sign;\n\t\tif (rm == -1) {\n\t\t\trm = 5;\n\t\t\tmem_ref = 1;\n\t\t} else {\n\t\t\tif (offset) {\n\t\t\t\tmod_byte = 1;\n\t\t\t\tif (offset < ST8_MIN || offset > ST8_MAX) {\n\t\t\t\t\tmod_byte = 2;\n\t\t\t\t}\n\t\t\t} else if (op->operands[0].regs[1] != X86R_UNDEFINED) {\n\t\t\t\trm = 4;\n\t\t\t\toffset = op->operands[0].regs[1] << 3;\n\t\t\t}\n\t\t}\n\t} else if (op->operands[0].type & OT_REGALL) {\n\t\tif (op->operands[1].type & OT_MEMORY) {\n\t\t\tif (op->operands[0].type & OT_BYTE && op->operands[1].type & OT_BYTE) {\n\t\t\t\tdata[l++] = op1 + 0x2;\n\t\t\t} else if (op->operands[0].type & (OT_DWORD | OT_QWORD) &&\n\t\t\t\t\t   op->operands[1].type & (OT_DWORD | OT_QWORD)) {\n\t\t\t\tdata[l++] = op1 + 0x3;\n\t\t\t} else {\n\t\t\t\teprintf (\"Error: mismatched operand sizes\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treg = op->operands[0].reg;\n\t\t\trm = op->operands[1].regs[0];\n\n\t\t\tif (op->operands[1].scale[0] > 1) {\n\t\t\t\tif (op->operands[1].regs[1] != X86R_UNDEFINED) {\n\t\t\t\t\tdata[l++] = op->operands[0].reg << 3 | 4;\n\t\t\t\t\tdata[l++] = getsib (op->operands[1].scale[0]) << 6 |\n\t\t\t\t\t\t\t\t\t\top->operands[1].regs[0] << 3 |\n\t\t\t\t\t\t\t\t\t\top->operands[1].regs[1];\n\t\t\t\t\treturn l;\n\t\t\t\t}\n\t\t\t\tdata[l++] = op->operands[0].reg << 3 | 4; // 4 = SIB\n\t\t\t\tdata[l++] = getsib (op->operands[1].scale[0]) << 6 | op->operands[1].regs[0] << 3 | 5;\n\t\t\t\tdata[l++] = op->operands[1].offset * op->operands[1].offset_sign;\n\t\t\t\tdata[l++] = 0;\n\t\t\t\tdata[l++] = 0;\n\t\t\t\tdata[l++] = 0;\n\t\t\t\treturn l;\n\t\t\t}\n\t\t\toffset = op->operands[1].offset * op->operands[1].offset_sign;\n\t\t\tif (offset) {\n\t\t\t\tmod_byte = 1;\n\t\t\t\tif (offset < ST8_MIN || offset > ST8_MAX) {\n\t\t\t\t\tmod_byte = 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else if (op->operands[1].type & OT_REGALL) {\n\t\t\tif (op->operands[0].type & OT_BYTE && op->operands[1].type & OT_BYTE) {\n\t\t\t\tdata[l++] = op1;\n\t\t\t} else if (op->operands[0].type & OT_DWORD && op->operands[1].type & OT_DWORD) {\n\t\t\t\tdata[l++] = op1 + 0x1;\n\t\t\t}\n\t\t\tif (a->bits == 64) {\n\t\t\t\tif (op->operands[0].type & OT_QWORD &&\n\t\t\t\t\top->operands[1].type & OT_QWORD) {\n\t\t\t\t\tdata[l++] = op1 + 0x1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmod_byte = 3;\n\t\t\treg = op->operands[1].reg;\n\t\t\trm = op->operands[0].reg;\n\t\t}\n\t}\n\tif (op->operands[0].regs[0] == X86R_EBP ||\n\t    op->operands[1].regs[0] == X86R_EBP) {\n\t\t\t//reg += 8;\n\t\t\tebp_reg = 1;\n\t}\n\tdata[l++] = mod_byte << 6 | reg << 3 | rm;\n\n\tif (op->operands[0].regs[0] == X86R_ESP ||\n\t    op->operands[1].regs[0] == X86R_ESP) {\n\t\t\tdata[l++] = 0x24;\n\t}\n\tif (offset || mem_ref || ebp_reg) {\n\t//if ((mod_byte > 0 && mod_byte < 3) || mem_ref) {\n\t\tdata[l++] = offset;\n\t\tif (mod_byte == 2 || mem_ref) {\n\t\t\tdata[l++] = offset >> 8;\n\t\t\tdata[l++] = offset >> 16;\n\t\t\tdata[l++] = offset >> 24;\n\t\t}\n\t}\n\treturn l;\n}\n\nstatic int opadc(RAsm *a, ut8 *data, const Opcode *op) {\n\tif (op->operands[1].type & OT_CONSTANT) {\n\t\tif (op->operands[0].type & OT_GPREG &&\n\t\t    op->operands[0].type & OT_WORD) {\n\t\t\treturn process_16bit_group_1 (a, data, op, 0x10);\n\t\t}\n\t\tif (!is_al_reg (&op->operands[0])) {\n\t\t\treturn process_group_1 (a, data, op);\n\t\t}\n\t}\n\treturn process_1byte_op (a, data, op, 0x10);\n}\n\nstatic int opadd(RAsm *a, ut8 *data, const Opcode *op) {\n\tif (op->operands[1].type & OT_CONSTANT) {\n\t\tif (op->operands[0].type & OT_GPREG &&\n\t\t    op->operands[0].type & OT_WORD) {\n\t\t\treturn process_16bit_group_1 (a, data, op, 0x00);\n\t\t}\n\t\tif (!is_al_reg (&op->operands[0])) {\n\t\t\treturn process_group_1 (a, data, op);\n\t\t}\n\t}\n\treturn process_1byte_op (a, data, op, 0x00);\n}\n\nstatic int opand(RAsm *a, ut8 *data, const Opcode *op) {\n\tif (op->operands[1].type & OT_CONSTANT) {\n\t\tif (op->operands[0].type & OT_GPREG &&\n\t\t    op->operands[0].type & OT_WORD) {\n\t\t\treturn process_16bit_group_1 (a, data, op, 0x20);\n\t\t}\n\t\tif (!is_al_reg (&op->operands[0])) {\n\t\t\treturn process_group_1 (a, data, op);\n\t\t}\n\t}\n\treturn process_1byte_op (a, data, op, 0x20);\n}\n\nstatic int opcmp(RAsm *a, ut8 *data, const Opcode *op) {\n\tif (op->operands[1].type & OT_CONSTANT) {\n\t\tif (op->operands[0].type & OT_GPREG &&\n\t\t    op->operands[0].type & OT_WORD) {\n\t\t\treturn process_16bit_group_1 (a, data, op, 0x38);\n\t\t}\n\t\tif (!is_al_reg (&op->operands[0])) {\n\t\t\treturn process_group_1 (a, data, op);\n\t\t}\n\t}\n\treturn process_1byte_op (a, data, op, 0x38);\n}\n\nstatic int opsub(RAsm *a, ut8 *data, const Opcode *op) {\n\tif (op->operands[1].type & OT_CONSTANT) {\n\t\tif (op->operands[0].type & OT_GPREG &&\n\t\t    op->operands[0].type & OT_WORD) {\n\t\t\treturn process_16bit_group_1 (a, data, op, 0x28);\n\t\t}\n\t\tif (!is_al_reg (&op->operands[0])) {\n\t\t\treturn process_group_1 (a, data, op);\n\t\t}\n\t}\n\treturn process_1byte_op (a, data, op, 0x28);\n}\n\nstatic int opor(RAsm *a, ut8 * data, const Opcode *op) {\n\tif (op->operands[1].type & OT_CONSTANT) {\n\t\tif (op->operands[0].type & OT_GPREG &&\n\t\t    op->operands[0].type & OT_WORD) {\n\t\t\treturn process_16bit_group_1 (a, data, op, 0x08);\n\t\t}\n\t\tif (!is_al_reg (&op->operands[0])) {\n\t\t\treturn process_group_1 (a, data, op);\n\t\t}\n\t}\n\treturn process_1byte_op (a, data, op, 0x08);\n}\n\nstatic int opxadd(RAsm *a, ut8 *data, const Opcode *op) {\n\tint i = 0;\n\tif (op->operands_count < 2 ) {\n\t\treturn -1;\n\t}\n\tif (a->bits == 64) {\n\t\tdata[i++] = 0x48;\n\t};\n\tdata[i++] = 0x0f;\n\tif (op->operands[0].type & OT_BYTE &&\n\t   op->operands[1].type & OT_BYTE) {\n\t\tdata[i++] = 0xc0;\n\t} else {\n\t\tdata[i++] = 0xc1;\n\t}\n\tif (op->operands[0].type & OT_REGALL &&\n       op->operands[1].type & OT_REGALL) { // TODO memory modes\n\t\tdata[i] |= 0xc0;\n\t\tdata[i] |= (op->operands[1].reg << 3);\n\t\tdata[i++] |= op->operands[0].reg;\n\t}\n\treturn i;\n}\n\nstatic int opxor(RAsm *a, ut8 * data, const Opcode *op) {\n\tif (op->operands_count < 2) {\n\t\treturn -1;\n\t}\n\tif (op->operands[0].type == 0x80 && op->operands[0].reg == X86R_UNDEFINED) {\n\t\treturn -1;\n\t}\n\tif (op->operands[1].type == 0x80 && op->operands[0].reg == X86R_UNDEFINED) {\n\t\treturn -1;\n\t}\n\tif (op->operands[1].type & OT_CONSTANT) {\n\t\tif (op->operands[0].type & OT_GPREG &&\n\t\t    op->operands[0].type & OT_WORD) {\n\t\t\treturn process_16bit_group_1 (a, data, op, 0x30);\n\t\t}\n\t\tif (!is_al_reg (&op->operands[0])) {\n\t\t\treturn process_group_1 (a, data, op);\n\t\t}\n\t}\n\treturn process_1byte_op (a, data, op, 0x30);\n}\n\nstatic int opnot(RAsm *a, ut8 * data, const Opcode *op) {\n\tint l = 0;\n\n\tif (op->operands[0].reg == X86R_UNDEFINED)  {\n\t\treturn -1;\n\t}\n\n\tint size = op->operands[0].type & ALL_SIZE;\n\tif (op->operands[0].explicit_size) {\n\t\tsize = op->operands[0].dest_size;\n\t}\n\t//rex prefix\n\tint rex = 1 << 6;\n\tbool use_rex = false;\n\tif (size & OT_QWORD) {\t\t\t//W field\n\t\tuse_rex = true;\n\t\trex |= 1 << 3;\n\t}\n\tif (op->operands[0].extended) {\t\t//B field\n\t\tuse_rex = true;\n\t\trex |= 1;\n\t}\n\n\tif (use_rex) {\n\t\tdata[l++] = rex;\n\t}\n\tdata[l++] = 0xf7;\n\tdata[l++] = 0xd0 | op->operands[0].reg;\n\n\treturn l;\n}\n\nstatic int opsbb(RAsm *a, ut8 *data, const Opcode *op) {\n\tif (op->operands[1].type & OT_CONSTANT) {\n\t\tif (op->operands[0].type & OT_GPREG &&\n\t\t    op->operands[0].type & OT_WORD) {\n\t\t\treturn process_16bit_group_1 (a, data, op, 0x18);\n\t\t}\n\t\tif (!is_al_reg (&op->operands[0])) {\n\t\t\treturn process_group_1 (a, data, op);\n\t\t}\n\t}\n\treturn process_1byte_op (a, data, op, 0x18);\n}\n\nstatic int opbswap(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tif (op->operands[0].type & OT_REGALL) {\n\t\tif (op->operands[0].reg == X86R_UNDEFINED) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (op->operands[0].type & OT_QWORD) {\n\t\t\tdata[l++] = 0x48;\n\t\t\tdata[l++] = 0x0f;\n\t\t\tdata[l++] = 0xc8 + op->operands[0].reg;\n\t\t} else if (op->operands[0].type & OT_DWORD) {\n\t\t\tdata[l++] = 0x0f;\n\t\t\tdata[l++] = 0xc8 + op->operands[0].reg;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn l;\n}\n\nstatic int opcall(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tint immediate = 0;\n\tint offset = 0;\n\tint mod = 0;\n\n\tif (op->operands[0].type & OT_GPREG) {\n\t\tif (op->operands[0].reg == X86R_UNDEFINED) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (a->bits == 64 && op->operands[0].extended) {\n\t\t\tdata[l++] = 0x41;\n\t\t}\n\t\tdata[l++] = 0xff;\n\t\tmod = 3;\n\t\tdata[l++] = mod << 6 | 2 << 3 | op->operands[0].reg;\n\t} else if (op->operands[0].type & OT_MEMORY) {\n\t\tif (op->operands[0].regs[0] == X86R_UNDEFINED) {\n\t\t\treturn -1;\n\t\t}\n\t\tdata[l++] = 0xff;\n\t\toffset = op->operands[0].offset * op->operands[0].offset_sign;\n\t\tif (offset) {\n\t\t\tmod = 1;\n\t\t\tif (offset > 127 || offset < -128) {\n\t\t\t\tmod = 2;\n\t\t\t}\n\t\t}\n\t\tdata[l++] = mod << 6 | 2 << 3 | op->operands[0].regs[0];\n\t\tif (mod) {\n\t\t\tdata[l++] = offset;\n\t\t\tif (mod == 2) {\n\t\t\t\tdata[l++] = offset >> 8;\n\t\t\t\tdata[l++] = offset >> 16;\n\t\t\t\tdata[l++] = offset >> 24;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tut64 instr_offset = a->pc;\n\t\tdata[l++] = 0xe8;\n\t\timmediate = op->operands[0].immediate * op->operands[0].sign;\n\t\timmediate -= instr_offset + 5;\n\t\tdata[l++] = immediate;\n\t\tdata[l++] = immediate >> 8;\n\t\tdata[l++] = immediate >> 16;\n\t\tdata[l++] = immediate >> 24;\n\t}\n\treturn l;\n}\n\nstatic int opcmov(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tint mod_byte = 0;\n\tint offset = 0;\n\n\tif (op->operands[0].type & OT_MEMORY ||\n\t    op->operands[1].type & OT_CONSTANT) {\n\t\treturn -1;\n\t}\n\n\tdata[l++] = 0x0f;\n\tchar *cmov = op->mnemonic + 4;\n\tif (!strcmp (cmov, \"o\")) {\n\t\tdata[l++] = 0x40;\n\t} else if (!strcmp (cmov, \"no\")) {\n\t\tdata [l++] = 0x41;\n\t} else if (!strcmp (cmov, \"b\") ||\n\t           !strcmp (cmov, \"c\") ||\n\t           !strcmp (cmov, \"nae\")) {\n\t\tdata [l++] = 0x42;\n\t} else if (!strcmp (cmov, \"ae\") ||\n\t           !strcmp (cmov, \"nb\") ||\n\t\t   !strcmp (cmov, \"nc\")) {\n\t\tdata [l++] = 0x43;\n\t} else if (!strcmp (cmov, \"e\") ||\n                   !strcmp (cmov, \"z\")) {\n\t\tdata [l++] = 0x44;\n\t} else if (!strcmp (cmov, \"ne\") ||\n\t           !strcmp (cmov, \"nz\")) {\n\t\tdata [l++] = 0x45;\n        } else if (!strcmp (cmov, \"be\") ||\n\t           !strcmp (cmov, \"na\")) {\n\t\tdata [l++] = 0x46;\n        } else if (!strcmp (cmov, \"a\") ||\n\t           !strcmp (cmov, \"nbe\")) {\n\t\tdata [l++] = 0x47;\n\t} else if (!strcmp (cmov, \"s\")) {\n\t\tdata [l++] = 0x48;\n        } else if (!strcmp (cmov, \"ns\")) {\n\t\tdata [l++] = 0x49;\n        } else if (!strcmp (cmov, \"p\") ||\n\t           !strcmp (cmov, \"pe\")) {\n\t\tdata [l++] = 0x4a;\n        } else if (!strcmp (cmov, \"np\") ||\n\t           !strcmp (cmov, \"po\")) {\n\t\tdata [l++] = 0x4b;\n        } else if (!strcmp (cmov, \"l\") ||\n\t           !strcmp (cmov, \"nge\")) {\n\t\tdata [l++] = 0x4c;\n        } else if (!strcmp (cmov, \"ge\") ||\n\t           !strcmp (cmov, \"nl\")) {\n\t\tdata [l++] = 0x4d;\n        } else if (!strcmp (cmov, \"le\") ||\n\t           !strcmp (cmov, \"ng\")) {\n\t\tdata [l++] = 0x4e;\n        } else if (!strcmp (cmov, \"g\") ||\n\t           !strcmp (cmov, \"nle\")) {\n\t\tdata [l++] = 0x4f;\n        }\n\n\tif (op->operands[0].type & OT_REGALL) {\n\t\tif (op->operands[1].type & OT_MEMORY) {\n\t\t\tif (op->operands[1].scale[0] > 1) {\n\t\t\t\tif (op->operands[1].regs[1] != X86R_UNDEFINED) {\n\t\t\t\t\tdata[l++] = op->operands[0].reg << 3 | 4;\n\t\t\t\t\tdata[l++] = getsib (op->operands[1].scale[0]) << 6 |\n                                                            op->operands[1].regs[0] << 3 |\n                                                            op->operands[1].regs[1];\n\t\t\t\t\treturn l;\n\t\t\t\t}\n\t\t\t\toffset = op->operands[1].offset * op->operands[1].offset_sign;\n\n\t\t\t\tif (op->operands[1].scale[0] == 2 && offset) {\n\t\t\t\t\tdata[l++] = 0x40 | op->operands[0].reg << 3 | 4; // 4 = SIB\n\t\t\t\t} else {\n\t\t\t\t\tdata[l++] = op->operands[0].reg << 3 | 4; // 4 = SIB\n\t\t\t\t}\n\n\n\t\t\t\tif (op->operands[1].scale[0] == 2) {\n\t\t\t\t\tdata[l++] = op->operands[1].regs[0] << 3 | op->operands[1].regs[0];\n\n\t\t\t\t} else {\n\t\t\t\t\tdata[l++] = getsib (op->operands[1].scale[0]) << 6 |\n                                                            op->operands[1].regs[0] << 3 | 5;\n\t\t\t\t}\n\n\t\t\t\tif (offset) {\n\t\t\t\t\tdata[l++] = offset;\n\t\t\t\t\tif (offset < ST8_MIN || offset > ST8_MAX) {\n\t\t\t\t\t\tdata[l++] = offset >> 8;\n\t\t\t\t\t\tdata[l++] = offset >> 16;\n\t\t\t\t\t\tdata[l++] = offset >> 24;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn l;\n\t\t\t}\n\t\t\tif (op->operands[1].regs[1] != X86R_UNDEFINED) {\n\t\t\t\tdata[l++] = op->operands[0].reg << 3 | 4;\n\t\t\t\tdata[l++] = op->operands[1].regs[1] << 3 | op->operands[1].regs[0];\n\t\t\t\treturn l;\n\t\t\t}\n\n\t\t\toffset = op->operands[1].offset * op->operands[1].offset_sign;\n\t\t\tif (op->operands[1].offset || op->operands[1].regs[0] == X86R_EBP) {\n\t\t\t\tmod_byte = 1;\n\t\t\t}\n\t\t\tif (offset < ST8_MIN || offset > ST8_MAX) {\n\t\t\t\tmod_byte = 2;\n\t\t\t}\n\n\t\t\tdata[l++] = mod_byte << 6 | op->operands[0].reg << 3 | op->operands[1].regs[0];\n\n\t\t\tif (mod_byte) {\n\t\t\t\tdata[l++] = offset;\n\t\t\t\tif (mod_byte == 2) {\n\t\t\t\t\tdata[l++] = offset >> 8;\n\t\t\t\t\tdata[l++] = offset >> 16;\n\t\t\t\t\tdata[l++] = offset >> 24;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tdata[l++] = 0xc0 | op->operands[0].reg << 3 | op->operands[1].reg;\n\t\t}\n\t}\n\n\treturn l;\n}\n\nstatic int opmovx(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tint word = 0;\n\tchar *movx = op->mnemonic + 3;\n\n\tif (!(op->operands[0].type & OT_REGTYPE && op->operands[1].type & OT_MEMORY)) {\n\t\treturn -1;\n\t}\n\tif (op->operands[1].type & OT_WORD) {\n\t\tword = 1;\n\t}\n\n\tdata[l++] = 0x0f;\n\tif (!strcmp (movx, \"zx\")) {\n\t\tdata[l++] = 0xb6 + word;\n\t} else if (!strcmp (movx, \"sx\")) {\n\t\tdata[l++] = 0xbe + word;\n\t}\n\tdata[l++] = op->operands[0].reg << 3 | op->operands[1].regs[0];\n\tif (op->operands[1].regs[0] == X86R_ESP) {\n\t\tdata[l++] = 0x24;\n\t}\n\n\treturn l;\n}\n\nstatic int opaam(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tint immediate = op->operands[0].immediate * op->operands[0].sign;\n\tdata[l++] = 0xd4;\n\tif (immediate == 0) {\n\t\tdata[l++] = 0x0a;\n\t} else if (immediate < 256 && immediate > -129) {\n\t\tdata[l++] = immediate;\n\t}\n\treturn l;\n}\n\nstatic int opdec(RAsm *a, ut8 *data, const Opcode *op) {\n\tif (op->operands[1].type) {\n\t\teprintf (\"Error: Invalid operands\\n\");\n\t\treturn -1;\n\t}\n\tint l = 0;\n\tint size = op->operands[0].type & ALL_SIZE;\n\tif (op->operands[0].explicit_size) {\n\t\tsize = op->operands[0].dest_size;\n\t}\n\n\tif (size & OT_WORD) {\n\t\tdata[l++] = 0x66;\n\t}\n\n\t//rex prefix\n\tint rex = 1 << 6;\n\tbool use_rex = false;\n\tif (size & OT_QWORD) {\t\t\t//W field\n\t\tuse_rex = true;\n\t\trex |= 1 << 3;\n\t}\n\tif (op->operands[0].extended) {\t\t//B field\n\t\tuse_rex = true;\n\t\trex |= 1;\n\t}\n\n\t//opcode selection\n\tint opcode;\n\tif (size & OT_BYTE) {\n\t\topcode = 0xfe;\n\t} else {\n\t\topcode = 0xff;\n\t}\n\n\tif (!(op->operands[0].type & OT_MEMORY)) {\n\t\tif (use_rex) {\n\t\t\tdata[l++] = rex;\n\t\t}\n\t\tif (a->bits > 32 || size & OT_BYTE) {\n\t\t\tdata[l++] = opcode;\n\t\t}\n\t\tif (a->bits == 32 && size & (OT_DWORD | OT_WORD)) {\n\t\t\tdata[l++] = 0x48 | op->operands[0].reg;\n\t\t} else {\n\t\t\tdata[l++] = 0xc8 | op->operands[0].reg;\n\t\t}\n\t\treturn l;\n\t}\n\n\t//modrm and SIB selection\n\tbool rip_rel = op->operands[0].regs[0] == X86R_RIP;\n\tint offset = op->operands[0].offset * op->operands[0].offset_sign;\n\tint modrm = 0;\n\tint mod;\n\tint reg = 0;\n\tint rm;\n\tbool use_sib = false;\n\tint sib;\n\t//mod\n\tif (offset == 0) {\n\t\tmod = 0;\n\t} else if (offset < 128 && offset > -129) {\n\t\tmod = 1;\n\t} else {\n\t\tmod = 2;\n\t}\n\n\tif (op->operands[0].regs[0] & OT_WORD) {\n\t\tif (op->operands[0].regs[0] == X86R_BX && op->operands[0].regs[1] == X86R_SI) {\n\t\t\trm = B0000;\n\t\t} else if (op->operands[0].regs[0] == X86R_BX && op->operands[0].regs[1] == X86R_DI) {\n\t\t\trm = B0001;\n\t\t} else if (op->operands[0].regs[0] == X86R_BP && op->operands[0].regs[1] == X86R_SI) {\n\t\t\trm = B0010;\n\t\t} else if (op->operands[0].regs[0] == X86R_BP && op->operands[0].regs[1] == X86R_DI) {\n\t\t\trm = B0011;\n\t\t} else if (op->operands[0].regs[0] == X86R_SI && op->operands[0].regs[1] == -1) {\n\t\t\trm = B0100;\n\t\t} else if (op->operands[0].regs[0] == X86R_DI && op->operands[0].regs[1] == -1) {\n\t\t\trm = B0101;\n\t\t} else if (op->operands[0].regs[0] == X86R_BX && op->operands[0].regs[1] == -1) {\n\t\t\trm = B0111;\n\t\t} else {\n\t\t\t//TODO allow for displacement only when parser is reworked\n\t\t\treturn -1;\n\t\t}\n\t\tmodrm = (mod << 6) | (reg << 3) | rm;\n\t} else {\n\t\t//rm\n\t\tif (op->operands[0].extended) {\n\t\t\trm = op->operands[0].reg;\n\t\t} else {\n\t\t\trm = op->operands[0].regs[0];\n\t\t}\n\t\t//[epb] alone is illegal, so we need to fake a [ebp+0]\n\t\tif (rm == 5 && mod == 0) {\n\t\t\tmod = 1;\n\t\t}\n\n\t\t//sib\n\t\tint index = op->operands[0].regs[1];\n\t\tint scale = getsib(op->operands[0].scale[1]);\n\t\tif (index != -1) {\n\t\t\tuse_sib = true;\n\t\t\tsib = (scale << 6) | (index << 3) | rm;\n\t\t} else if (rm == 4) {\n\t\t\tuse_sib = true;\n\t\t\tsib = 0x24;\n\t\t}\n\t\tif (use_sib) {\n\t\t\trm = B0100;\n\t\t}\n\t\tif (rip_rel) {\n\t\t\tmodrm = (B0000 << 6) | (reg << 3) | B0101;\n\t\t\tsib = (scale << 6) | (B0100 << 3) | B0101;\n\t\t} else {\n\t\t\tmodrm = (mod << 6) | (reg << 3) | rm;\n\t\t}\n\t\tmodrm |= 1<<3;\n\t}\n\n\tif (use_rex) {\n\t\tdata[l++] = rex;\n\t}\n\tdata[l++] = opcode;\n\tdata[l++] = modrm;\n\tif (use_sib) {\n\t\tdata[l++] = sib;\n\t}\n\t//offset\n\tif (mod == 1) {\n\t\tdata[l++] = offset;\n\t} else if (op->operands[0].regs[0] & OT_WORD && mod == 2) {\n\t\tdata[l++] = offset;\n\t\tdata[l++] = offset >> 8;\n\t} else if (mod == 2 || rip_rel) {\n\t\tdata[l++] = offset;\n\t\tdata[l++] = offset >> 8;\n\t\tdata[l++] = offset >> 16;\n\t\tdata[l++] = offset >> 24;\n\t}\n\n\treturn l;\n}\n\nstatic int opidiv(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\n\tif ( op->operands[0].type & OT_QWORD ) {\n\t\tdata[l++] = 0x48;\n\t}\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_WORD ) {\n\t\t\tdata[l++] = 0x66;\n\t\t}\n\t\tif (op->operands[0].type & OT_BYTE) {\n\t\t\tdata[l++] = 0xf6;\n\t\t} else {\n\t\t\tdata[l++] = 0xf7;\n\t\t}\n\t\tif (op->operands[0].type & OT_MEMORY) {\n\t\t\tdata[l++] = 0x38 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\tdata[l++] = 0xf8 | op->operands[0].reg;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opdiv(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\n\tif ( op->operands[0].type & OT_QWORD ) {\n\t\tdata[l++] = 0x48;\n\t}\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_WORD ) {\n\t\t\tdata[l++] = 0x66;\n\t\t}\n\t\tif (op->operands[0].type & OT_BYTE) {\n\t\t\tdata[l++] = 0xf6;\n\t\t} else {\n\t\t\tdata[l++] = 0xf7;\n\t\t}\n\t\tif (op->operands[0].type & OT_MEMORY) {\n\t\t\tdata[l++] = 0x30 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\tdata[l++] = 0xf0 | op->operands[0].reg;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opimul(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tint offset = 0;\n\tst64 immediate = 0;\n\n\tif ( op->operands[0].type & OT_QWORD ) {\n\t\tdata[l++] = 0x48;\n\t}\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_WORD ) {\n\t\t\tdata[l++] = 0x66;\n\t\t}\n\t\tif (op->operands[0].type & OT_BYTE) {\n\t\t\tdata[l++] = 0xf6;\n\t\t} else {\n\t\t\tdata[l++] = 0xf7;\n\t\t}\n\t\tif (op->operands[0].type & OT_MEMORY) {\n\t\t\tdata[l++] = 0x28 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\tdata[l++] = 0xe8 | op->operands[0].reg;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif (op->operands[0].type & OT_GPREG) {\n\t\t\tif (op->operands[1].type & OT_CONSTANT) {\n\t\t\t\tif (op->operands[1].immediate == -1) {\n\t\t\t\t\teprintf (\"Error: Immediate exceeds max\\n\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\timmediate = op->operands[1].immediate * op->operands[1].sign;\n\t\t\t\tif (op->operands[0].type & OT_GPREG) {\n\t\t\t\t\tif (immediate >= 128) {\n\t\t\t\t\t\tdata[l++] = 0x69;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdata[l++] = 0x6b;\n\t\t\t\t\t}\n\t\t\t\t\tdata[l++] = 0xc0 | op->operands[0].reg << 3 | op->operands[0].reg;\n\t\t\t\t\tdata[l++] = immediate;\n\t\t\t\t\tif (immediate >= 128) {\n\t\t\t\t\t\tdata[l++] = immediate >> 8;\n\t\t\t\t\t\tdata[l++] = immediate >> 16;\n\t\t\t\t\t\tdata[l++] = immediate >> 24;\n\t\t\t\t\t}\n\t\t\t\t\tif (a->bits == 64 && immediate > UT32_MAX) {\n\t\t\t\t\t\tdata[l++] = immediate >> 32;\n\t\t\t\t\t\tdata[l++] = immediate >> 40;\n\t\t\t\t\t\tdata[l++] = immediate >> 48;\n\t\t\t\t\t\tdata[l++] = immediate >> 56;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (op->operands[1].type & OT_MEMORY) {\n\t\t\t\tdata[l++] = 0x0f;\n\t\t\t\tdata[l++] = 0xaf;\n\t\t\t\tif (op->operands[1].regs[0] != X86R_UNDEFINED) {\n\t\t\t\t\toffset = op->operands[1].offset * op->operands[1].offset_sign;\n\t\t\t\t\tif (offset != 0) {\n\t\t\t\t\t\tif (offset >= 128 || offset <= -128) {\n\t\t\t\t\t\t\tdata[l] = 0x80;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdata[l] = 0x40;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdata[l++] |= op->operands[0].reg << 3 | op->operands[1].regs[0];\n\t\t\t\t\t\tdata[l++] = offset;\n\t\t\t\t\t\tif (offset >= 128 || offset <= -128) {\n\t\t\t\t\t\t\tdata[l++] = offset >> 8;\n\t\t\t\t\t\t\tdata[l++] = offset >> 16;\n\t\t\t\t\t\t\tdata[l++] = offset >> 24;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (op->operands[1].regs[1] != X86R_UNDEFINED) {\n\t\t\t\t\t\t\tdata[l++] = 0x04 | op->operands[0].reg << 3;\n\t\t\t\t\t\t\tdata[l++] = op->operands[1].regs[1] << 3 | op->operands[1].regs[0];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdata[l++] = op->operands[0].reg << 3 | op->operands[1].regs[0];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\timmediate = op->operands[1].immediate * op->operands[1].sign;\n\t\t\t\t\tdata[l++] = op->operands[0].reg << 3 | 0x5;\n\t\t\t\t\tdata[l++] = immediate;\n\t\t\t\t\tdata[l++] = immediate >> 8;\n\t\t\t\t\tdata[l++] = immediate >> 16;\n\t\t\t\t\tdata[l++] = immediate >> 24;\n\t\t\t\t}\n\t\t\t} else if (op->operands[1].type & OT_GPREG) {\n\t\t\t\tdata[l++] = 0x0f;\n\t\t\t\tdata[l++] = 0xaf;\n\t\t\t\tdata[l++] = 0xc0 | op->operands[0].reg << 3 | op->operands[1].reg;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 3:\n\t\tif (op->operands[0].type & OT_GPREG &&\n\t\t    (op->operands[1].type & OT_GPREG || op->operands[1].type & OT_MEMORY) &&\n\t\t    op->operands[2].type & OT_CONSTANT) {\n\t\t\t\tdata[l++] = 0x6b;\n\t\t\t\tif (op->operands[1].type & OT_MEMORY) {\n\t\t\t\t\tif (op->operands[1].regs[1] != X86R_UNDEFINED) {\n\t\t\t\t\t\tdata[l++] = 0x04 | op->operands[0].reg << 3;\n\t\t\t\t\t\tdata[l++] = op->operands[1].regs[0] |  op->operands[1].regs[1] << 3;\n\t\t\t\t\t} else {\n\t\t\t\t\t\toffset = op->operands[1].offset * op->operands[1].offset_sign;\n\t\t\t\t\t\tif (offset != 0) {\n\t\t\t\t\t\t\tif (offset >= 128 || offset <= -128) {\n\t\t\t\t\t\t\t\tdata[l] = 0x80;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdata[l] = 0x40;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdata[l++] |= op->operands[0].reg << 3;\n\t\t\t\t\t\t\tdata[l++] = offset;\n\t\t\t\t\t\t\tif (offset >= 128 || offset <= -128) {\n\t\t\t\t\t\t\t\tdata[l++] = offset >> 8;\n\t\t\t\t\t\t\t\tdata[l++] = offset >> 16;\n\t\t\t\t\t\t\t\tdata[l++] = offset >> 24;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdata[l++] = 0x00 | op->operands[0].reg << 3 | op->operands[1].regs[0];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdata[l++] = 0xc0 | op->operands[0].reg << 3 | op->operands[1].reg;\n\t\t\t\t}\n\t\t\t\timmediate = op->operands[2].immediate * op->operands[2].sign;\n\t\t\t\tdata[l++] = immediate;\n\t\t\t\tif (immediate >= 128 || immediate <= -128) {\n\t\t\t\t\tdata[l++] = immediate >> 8;\n\t\t\t\t\tdata[l++] = immediate >> 16;\n\t\t\t\t\tdata[l++] = immediate >> 24;\n\t\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opin(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tst32 immediate = 0;\n\tif (op->operands[1].reg == X86R_DX) {\n\t\tif (op->operands[0].reg == X86R_AL &&\n\t\t\top->operands[0].type & OT_BYTE) {\n\t\t\tdata[l++] = 0xec;\n\t\t\treturn l;\n\t\t}\n\t\tif (op->operands[0].reg == X86R_AX &&\n\t\t\top->operands[0].type & OT_WORD) {\n\t\t\tdata[l++] = 0x66;\n\t\t\tdata[l++] = 0xed;\n\t\t\treturn l;\n\t\t}\n\t\tif (op->operands[0].reg == X86R_EAX &&\n\t\t\top->operands[0].type & OT_DWORD) {\n\t\t\tdata[l++] = 0xed;\n\t\t\treturn l;\n\t\t}\n\t} else if (op->operands[1].type & OT_CONSTANT) {\n\t\timmediate = op->operands[1].immediate * op->operands[1].sign;\n\t\tif (immediate > 255 || immediate < -128) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (op->operands[0].reg == X86R_AL &&\n\t\t\top->operands[0].type & OT_BYTE) {\n\t\t\tdata[l++] = 0xe4;\n\t\t} else if (op->operands[0].reg == X86R_AX &&\n\t\t\t\t   op->operands[0].type & OT_BYTE) {\n\t\t\tdata[l++] = 0x66;\n\t\t\tdata[l++] = 0xe5;\n\t\t} else if (op->operands[0].reg == X86R_EAX &&\n\t\t\t\t   op->operands[0].type & OT_DWORD) {\n\t\t\tdata[l++] = 0xe5;\n\t\t}\n\t\tdata[l++] = immediate;\n\t}\n\treturn l;\n}\n\nstatic int opclflush(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tint offset = 0;\n\tint mod_byte = 0;\n\n\tif (op->operands[0].type & OT_MEMORY) {\n\t\tdata[l++] = 0x0f;\n\t\tdata[l++] = 0xae;\n\t\toffset = op->operands[0].offset * op->operands[0].offset_sign;\n\t\tif (offset) {\n\t\t\tif (offset < ST8_MIN || offset > ST8_MAX) {\n\t\t\t\tmod_byte = 2;\n\t\t\t} else {\n\t\t\t\tmod_byte = 1;\n\t\t\t}\n\t\t}\n\t\tdata[l++] = (mod_byte << 6) | (7 << 3) | op->operands[0].regs[0];\n\t\tif (mod_byte) {\n\t\t\tdata[l++] = offset;\n\t\t\tif (mod_byte == 2) {\n\t\t\t\tdata[l++] = offset >> 8;\n\t\t\t\tdata[l++] = offset >> 16;\n\t\t\t\tdata[l++] = offset >> 24;\n\t\t\t}\n\t\t}\n\t}\n\treturn l;\n}\n\nstatic int opinc(RAsm *a, ut8 *data, const Opcode *op) {\n\tif (op->operands[1].type) {\n\t\teprintf (\"Error: Invalid operands\\n\");\n\t\treturn -1;\n\t}\n\tint l = 0;\n\tint size = op->operands[0].type & ALL_SIZE;\n\tif (op->operands[0].explicit_size) {\n\t\tsize = op->operands[0].dest_size;\n\t}\n\n\tif (size & OT_WORD) {\n\t\tdata[l++] = 0x66;\n\t}\n\n\t//rex prefix\n\tint rex = 1 << 6;\n\tbool use_rex = false;\n\tif (size & OT_QWORD) {\t\t\t//W field\n\t\tuse_rex = true;\n\t\trex |= 1 << 3;\n\t}\n\tif (op->operands[0].extended) {\t\t//B field\n\t\tuse_rex = true;\n\t\trex |= 1;\n\t}\n\n\t//opcode selection\n\tint opcode;\n\tif (size & OT_BYTE) {\n\t\topcode = 0xfe;\n\t} else {\n\t\topcode = 0xff;\n\t}\n\n\tif (!(op->operands[0].type & OT_MEMORY)) {\n\t\tif (use_rex) {\n\t\t\tdata[l++] = rex;\n\t\t}\n\t\tif (a->bits > 32 || size & OT_BYTE) {\n\t\t\tdata[l++] = opcode;\n\t\t}\n\t\tif (a->bits == 32 && size & (OT_DWORD | OT_WORD)) {\n\t\t\tdata[l++] = 0x40 | op->operands[0].reg;\n\t\t} else {\n\t\t\tdata[l++] = 0xc0 | op->operands[0].reg;\n\t\t}\n\t\treturn l;\n\t}\n\n\t//modrm and SIB selection\n\tbool rip_rel = op->operands[0].regs[0] == X86R_RIP;\n\tint offset = op->operands[0].offset * op->operands[0].offset_sign;\n\tint modrm = 0;\n\tint mod;\n\tint reg = 0;\n\tint rm;\n\tbool use_sib = false;\n\tint sib;\n\t//mod\n\tif (offset == 0) {\n\t\tmod = 0;\n\t} else if (offset < 128 && offset > -129) {\n\t\tmod = 1;\n\t} else {\n\t\tmod = 2;\n\t}\n\n\tif (op->operands[0].regs[0] & OT_WORD) {\n\t\tif (op->operands[0].regs[0] == X86R_BX && op->operands[0].regs[1] == X86R_SI) {\n\t\t\trm = B0000;\n\t\t} else if (op->operands[0].regs[0] == X86R_BX && op->operands[0].regs[1] == X86R_DI) {\n\t\t\trm = B0001;\n\t\t} else if (op->operands[0].regs[0] == X86R_BP && op->operands[0].regs[1] == X86R_SI) {\n\t\t\trm = B0010;\n\t\t} else if (op->operands[0].regs[0] == X86R_BP && op->operands[0].regs[1] == X86R_DI) {\n\t\t\trm = B0011;\n\t\t} else if (op->operands[0].regs[0] == X86R_SI && op->operands[0].regs[1] == -1) {\n\t\t\trm = B0100;\n\t\t} else if (op->operands[0].regs[0] == X86R_DI && op->operands[0].regs[1] == -1) {\n\t\t\trm = B0101;\n\t\t} else if (op->operands[0].regs[0] == X86R_BX && op->operands[0].regs[1] == -1) {\n\t\t\trm = B0111;\n\t\t} else {\n\t\t\t//TODO allow for displacement only when parser is reworked\n\t\t\treturn -1;\n\t\t}\n\t\tmodrm = (mod << 6) | (reg << 3) | rm;\n\t} else {\n\t\t//rm\n\t\tif (op->operands[0].extended) {\n\t\t\trm = op->operands[0].reg;\n\t\t} else {\n\t\t\trm = op->operands[0].regs[0];\n\t\t}\n\t\t//[epb] alone is illegal, so we need to fake a [ebp+0]\n\t\tif (rm == 5 && mod == 0) {\n\t\t\tmod = 1;\n\t\t}\n\n\t\t//sib\n\t\tint index = op->operands[0].regs[1];\n\t\tint scale = getsib(op->operands[0].scale[1]);\n\t\tif (index != -1) {\n\t\t\tuse_sib = true;\n\t\t\tsib = (scale << 6) | (index << 3) | rm;\n\t\t} else if (rm == 4) {\n\t\t\tuse_sib = true;\n\t\t\tsib = 0x24;\n\t\t}\n\t\tif (use_sib) {\n\t\t\trm = B0100;\n\t\t}\n\t\tif (rip_rel) {\n\t\t\tmodrm = (B0000 << 6) | (reg << 3) | B0101;\n\t\t\tsib = (scale << 6) | (B0100 << 3) | B0101;\n\t\t} else {\n\t\t\tmodrm = (mod << 6) | (reg << 3) | rm;\n\t\t}\n\t}\n\n\tif (use_rex) {\n\t\tdata[l++] = rex;\n\t}\n\tdata[l++] = opcode;\n\tdata[l++] = modrm;\n\tif (use_sib) {\n\t\tdata[l++] = sib;\n\t}\n\t//offset\n\tif (mod == 1) {\n\t\tdata[l++] = offset;\n\t} else if (op->operands[0].regs[0] & OT_WORD && mod == 2) {\n\t\tdata[l++] = offset;\n\t\tdata[l++] = offset >> 8;\n\t} else if (mod == 2 || rip_rel) {\n\t\tdata[l++] = offset;\n\t\tdata[l++] = offset >> 8;\n\t\tdata[l++] = offset >> 16;\n\t\tdata[l++] = offset >> 24;\n\t}\n\n\treturn l;\n}\n\nstatic int opint(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tif (op->operands[0].type & OT_CONSTANT) {\n\t\tst32 immediate = op->operands[0].immediate * op->operands[0].sign;\n\t\tif (immediate <= 255 && immediate >= -128) {\n\t\t\tdata[l++] = 0xcd;\n\t\t\tdata[l++] = immediate;\n\t\t}\n\t}\n\treturn l;\n}\n\nstatic int opjc(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tbool is_short = op->is_short;\n\t// st64 bigimm = op->operands[0].immediate * op->operands[0].sign;\n\tst64 immediate = op->operands[0].immediate * op->operands[0].sign;\n\tif (is_short && (immediate > ST8_MAX || immediate < ST8_MIN)) {\n\t\treturn l;\n\t}\n\timmediate -= a->pc;\n\tif (immediate > ST32_MAX || immediate < -ST32_MAX) {\n\t\treturn -1;\n\t}\n\tif (!strcmp (op->mnemonic, \"jmp\")) {\n\t\tif (op->operands[0].type & OT_GPREG) {\n\t\t\tdata[l++] = 0xff;\n\t\t\tif (op->operands[0].type & OT_MEMORY) {\n\t\t\t\tif (op->operands[0].offset) {\n\t\t\t\t\tint offset = op->operands[0].offset * op->operands[0].offset_sign;\n\t\t\t\t\tif (offset >= 128 || offset <= -129) {\n\t\t\t\t\t\tdata[l] = 0xa0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdata[l] = 0x60;\n\t\t\t\t\t}\n\t\t\t\t\tdata[l++] |= op->operands[0].regs[0];\n\t\t\t\t\tdata[l++] = offset;\n\t\t\t\t\tif (op->operands[0].offset >= 0x80) {\n\t\t\t\t\t\tdata[l++] = offset >> 8;\n\t\t\t\t\t\tdata[l++] = offset >> 16;\n\t\t\t\t\t\tdata[l++] = offset >> 24;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdata[l++] = 0x20 | op->operands[0].regs[0];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdata[l++] = 0xe0 | op->operands[0].reg;\n\t\t\t}\n\t\t} else {\n\t\t\tif (-0x80 <= (immediate - 2) && (immediate - 2) <= 0x7f) {\n\t\t\t\t/* relative byte address */\n\t\t\t\tdata[l++] = 0xeb;\n\t\t\t\tdata[l++] = immediate - 2;\n\t\t\t} else {\n\t\t\t\t/* relative address */\n\t\t\t\timmediate -= 5;\n\t\t\t\tdata[l++] = 0xe9;\n\t\t\t\tdata[l++] = immediate;\n\t\t\t\tdata[l++] = immediate >> 8;\n\t\t\t\tdata[l++] = immediate >> 16;\n\t\t\t\tdata[l++] = immediate >> 24;\n\t\t\t}\n\t\t}\n\t\treturn l;\n\t}\n\tif (immediate <= 0x81 && immediate > -0x7f) {\n\t\tis_short = true;\n\t}\n\tif (a->bits == 16 && (immediate > 0x81 || immediate < -0x7e)) {\n\t\tdata[l++] = 0x66;\n\t\tis_short = false;\n\t\timmediate --;\n\t}\n\n\tif (!is_short) {data[l++] = 0x0f;}\n\tif (!strcmp (op->mnemonic, \"ja\") ||\n            !strcmp (op->mnemonic, \"jnbe\")) {\n\t\tdata[l++] = 0x87;\n\t} else if (!strcmp (op->mnemonic, \"jae\") ||\n                   !strcmp (op->mnemonic, \"jnb\") ||\n                   !strcmp (op->mnemonic, \"jnc\")) {\n\t\tdata[l++] = 0x83;\n\t} else if (!strcmp (op->mnemonic, \"jz\") ||\n                   !strcmp (op->mnemonic, \"je\")) {\n\t\tdata[l++] = 0x84;\n\t} else if (!strcmp (op->mnemonic, \"jb\") ||\n                   !strcmp (op->mnemonic, \"jnae\") ||\n                   !strcmp (op->mnemonic, \"jc\")) {\n\t\tdata[l++] = 0x82;\n\t} else if (!strcmp (op->mnemonic, \"jbe\") ||\n                   !strcmp (op->mnemonic, \"jna\")) {\n\t\tdata[l++] = 0x86;\n\t} else if (!strcmp (op->mnemonic, \"jg\") ||\n                   !strcmp (op->mnemonic, \"jnle\")) {\n\t\tdata[l++] = 0x8f;\n\t} else if (!strcmp (op->mnemonic, \"jge\") ||\n                   !strcmp (op->mnemonic, \"jnl\")) {\n\t\tdata[l++] = 0x8d;\n\t} else if (!strcmp (op->mnemonic, \"jl\") ||\n                   !strcmp (op->mnemonic, \"jnge\")) {\n\t\tdata[l++] = 0x8c;\n\t} else if (!strcmp (op->mnemonic, \"jle\") ||\n\t           !strcmp (op->mnemonic, \"jng\")) {\n\t\tdata[l++] = 0x8e;\n\t} else if (!strcmp (op->mnemonic, \"jne\") ||\n                   !strcmp (op->mnemonic, \"jnz\")) {\n\t\tdata[l++] = 0x85;\n\t} else if (!strcmp (op->mnemonic, \"jno\")) {\n\t\tdata[l++] = 0x81;\n\t} else if (!strcmp (op->mnemonic, \"jnp\") ||\n                   !strcmp (op->mnemonic, \"jpo\")) {\n\t\tdata[l++] = 0x8b;\n\t} else if (!strcmp (op->mnemonic, \"jns\")) {\n\t\tdata[l++] = 0x89;\n\t} else if (!strcmp (op->mnemonic, \"jo\")) {\n\t\tdata[l++] = 0x80;\n\t} else if (!strcmp (op->mnemonic, \"jp\") ||\n                   !strcmp(op->mnemonic, \"jpe\")) {\n\t\tdata[l++] = 0x8a;\n\t} else if (!strcmp (op->mnemonic, \"js\") ||\n                   !strcmp (op->mnemonic, \"jz\")) {\n\t\tdata[l++] = 0x88;\n\t}\n\tif (is_short) {\n\t\tdata[l-1] -= 0x10;\n\t}\n\n\timmediate -= is_short ? 2 : 6;\n\tdata[l++] = immediate;\n\tif (!is_short) {\n\t\tdata[l++] = immediate >> 8;\n\t\tdata[l++] = immediate >> 16;\n\t\tdata[l++] = immediate >> 24;\n\t}\n\treturn l;\n}\n\nstatic int oplea(RAsm *a, ut8 *data, const Opcode *op){\n\tint l = 0;\n\tint mod = 0;\n\tst32 offset = 0;\n\tint reg = 0;\n\tint rm = 0;\n\tif (op->operands[0].type & OT_REGALL &&\n\t    op->operands[1].type & (OT_MEMORY | OT_CONSTANT)) {\n\t\tif (a->bits == 64) {\n\t\t\tdata[l++] = 0x48;\n\t\t}\n\t\tdata[l++] = 0x8d;\n\t\tif (op->operands[1].regs[0] == X86R_UNDEFINED) {\n\t\t\tint high = 0xff00 & op->operands[1].offset;\n\t\t\tdata[l++] = op->operands[0].reg << 3 | 5;\n\t\t\tdata[l++] = op->operands[1].offset;\n\t\t\tdata[l++] = high >> 8;\n\t\t\tdata[l++] = op->operands[1].offset >> 16;\n\t\t\tdata[l++] = op->operands[1].offset >> 24;\n\t\t\treturn l;\n\t\t} else {\n\t\t\treg = op->operands[0].reg;\n\t\t\trm = op->operands[1].regs[0];\n\n\t\t\toffset = op->operands[1].offset * op->operands[1].offset_sign;\n\t\t\tif (offset != 0 || op->operands[1].regs[0] == X86R_EBP) {\n\t\t\t\tmod = 1;\n\t\t\t\tif (offset >= 128 || offset < -128) {\n\t\t\t\t\tmod = 2;\n\t\t\t\t}\n\t\t\t\tdata[l++] = mod << 6 | reg << 3 | rm;\n\t\t\t\tif (op->operands[1].regs[0] == X86R_ESP) {\n\t\t\t\t\tdata[l++] = 0x24;\n\t\t\t\t}\n\t\t\t\tdata[l++] = offset;\n\t\t\t\tif (mod == 2) {\n\t\t\t\t\tdata[l++] = offset >> 8;\n\t\t\t\t\tdata[l++] = offset >> 16;\n\t\t\t\t\tdata[l++] = offset >> 24;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdata[l++] = op->operands[0].reg << 3 | op->operands[1].regs[0];\n\t\t\t\tif (op->operands[1].regs[0] == X86R_ESP) {\n\t\t\t\t\tdata[l++] = 0x24;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\treturn l;\n}\n\nstatic int oples(RAsm *a, ut8* data, const Opcode *op) {\n\tint l = 0;\n\tint offset = 0;\n\tint mod = 0;\n\n\tif (op->operands[1].type & OT_MEMORY) {\n\t\tdata[l++] = 0xc4;\n\t\tif (op->operands[1].type & OT_GPREG) {\n\t\t\toffset = op->operands[1].offset * op->operands[1].offset_sign;\n\t\t\tif (offset) {\n\t\t\t\tmod = 1;\n\t\t\t\tif (offset > 128 || offset < -128) {\n\t\t\t\t\tmod = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdata[l++] = mod << 6 | op->operands[0].reg << 3 | op->operands[1].regs[0];\n\t\t\tif (mod) {\n\t\t\t\tdata[l++] = offset;\n\t\t\t\tif (mod > 1) {\n\t\t\t\t\tdata[l++] = offset >> 8;\n\t\t\t\t\tdata[l++] = offset >> 16;\n\t\t\t\t\tdata[l++] = offset >> 24;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\toffset = op->operands[1].offset * op->operands[1].offset_sign;\n\t\t\tdata[l++] = 0x05;\n\t\t\tdata[l++] = offset;\n\t\t\tdata[l++] = offset >> 8;\n\t\t\tdata[l++] = offset >> 16;\n\t\t\tdata[l++] = offset >> 24;\n\t\t}\n\t}\n\treturn l;\n}\n\nstatic int opmov(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tst64 offset = 0;\n\tint mod = 0;\n\tint base = 0;\n\tint rex = 0;\n\tut64 immediate = 0;\n\tif (op->operands[1].type & OT_CONSTANT) {\n\t\tif (!op->operands[1].is_good_flag) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (op->operands[1].immediate == -1) {\n\t\t\treturn -1;\n\t\t}\n\t\timmediate = op->operands[1].immediate * op->operands[1].sign;\n\t\tif (op->operands[0].type & OT_GPREG && !(op->operands[0].type & OT_MEMORY)) {\n\t\t\tif (a->bits == 64 && ((op->operands[0].type & OT_QWORD) | (op->operands[1].type & OT_QWORD))) {\n\t\t\t\tif (!(op->operands[1].type & OT_CONSTANT) && op->operands[1].extended) {\n\t\t\t\t\tdata[l++] = 0x49;\n\t\t\t\t} else {\n\t\t\t\t\tdata[l++] = 0x48;\n\t\t\t\t}\n\t\t\t} else if (op->operands[0].extended) {\n\t\t\t\tdata[l++] = 0x41;\n\t\t\t}\n\t\t\tif (op->operands[0].type & OT_WORD) {\n\t\t\t\tif (a->bits > 16) {\n\t\t\t\t\tdata[l++] = 0x66;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (op->operands[0].type & OT_BYTE) {\n\t\t\t\tdata[l++] = 0xb0 | op->operands[0].reg;\n\t\t\t\tdata[l++] = immediate;\n\t\t\t} else {\n\t\t\t\tif (a->bits == 64 &&\n\t\t\t\t\t((op->operands[0].type & OT_QWORD) |\n\t\t\t\t\t(op->operands[1].type & OT_QWORD)) &&\n\t\t\t\t\timmediate < UT32_MAX) {\n\t\t\t\t\t\tdata[l++] = 0xc7;\n\t\t\t\t \t\tdata[l++] = 0xc0 | op->operands[0].reg;\n\t\t\t\t} else {\n\t\t\t\t\tdata[l++] = 0xb8 | op->operands[0].reg;\n\t\t\t\t}\n\t\t\t\tdata[l++] = immediate;\n\t\t\t\tdata[l++] = immediate >> 8;\n\t\t\t\tif (!(op->operands[0].type & OT_WORD)) {\n\t\t\t\t\tdata[l++] = immediate >> 16;\n\t\t\t\t\tdata[l++] = immediate >> 24;\n\t\t\t\t}\n\t\t\t\tif (a->bits == 64 && immediate > UT32_MAX) {\n\t\t\t\t\tdata[l++] = immediate >> 32;\n\t\t\t\t\tdata[l++] = immediate >> 40;\n\t\t\t\t\tdata[l++] = immediate >> 48;\n\t\t\t\t\tdata[l++] = immediate >> 56;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (op->operands[0].type & OT_MEMORY) {\n\t\t\tif (!op->operands[0].explicit_size) {\n\t\t\t\tif (op->operands[0].type & OT_GPREG) {\n\t\t\t\t\t((Opcode *)op)->operands[0].dest_size = op->operands[0].reg_size;\n\t\t\t\t} else {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint dest_bits = 8 * ((op->operands[0].dest_size & ALL_SIZE) >> OPSIZE_SHIFT);\n\t\t\tint reg_bits = 8 * ((op->operands[0].reg_size & ALL_SIZE) >> OPSIZE_SHIFT);\n\t\t\tint offset = op->operands[0].offset * op->operands[0].offset_sign;\n\n\t\t\t//addr_size_override prefix\n\t\t\tbool use_aso = false;\n\t\t\tif (reg_bits < a->bits) {\n\t\t\t\tuse_aso = true;\n\t\t\t}\n\n\t\t\t//op_size_override prefix\n\t\t\tbool use_oso = false;\n\t\t\tif (dest_bits == 16) {\n\t\t\t\tuse_oso = true;\n\t\t\t}\n\n\t\t\tbool rip_rel = op->operands[0].regs[0] == X86R_RIP;\n\n\t\t\t//rex prefix\n\t\t\tint rex = 1 << 6;\n\t\t\tbool use_rex = false;\n\t\t\tif (dest_bits == 64) {\t\t\t//W field\n\t\t\t\tuse_rex = true;\n\t\t\t\trex |= 1 << 3;\n\t\t\t}\n\t\t\tif (op->operands[0].extended) {\t\t//B field\n\t\t\t\tuse_rex = true;\n\t\t\t\trex |= 1;\n\t\t\t}\n\n\t\t\t//opcode selection\n\t\t\tint opcode;\n\t\t\tif (dest_bits == 8) {\n\t\t\t\topcode = 0xc6;\n\t\t\t} else {\n\t\t\t\topcode = 0xc7;\n\t\t\t}\n\n\t\t\t//modrm and SIB selection\n\t\t\tint modrm = 0;\n\t\t\tint mod;\n\t\t\tint reg = 0;\n\t\t\tint rm;\n\t\t\tbool use_sib = false;\n\t\t\tint sib;\n\t\t\t//mod\n\t\t\tif (offset == 0) {\n\t\t\t\tmod = 0;\n\t\t\t} else if (offset < 128 && offset > -129) {\n\t\t\t\tmod = 1;\n\t\t\t} else {\n\t\t\t\tmod = 2;\n\t\t\t}\n\n\t\t\tif (reg_bits == 16) {\n\t\t\t\tif (op->operands[0].regs[0] == X86R_BX && op->operands[0].regs[1] == X86R_SI) {\n\t\t\t\t\trm = B0000;\n\t\t\t\t} else if (op->operands[0].regs[0] == X86R_BX && op->operands[0].regs[1] == X86R_DI) {\n\t\t\t\t\trm = B0001;\n\t\t\t\t} else if (op->operands[0].regs[0] == X86R_BP && op->operands[0].regs[1] == X86R_SI) {\n\t\t\t\t\trm = B0010;\n\t\t\t\t} else if (op->operands[0].regs[0] == X86R_BP && op->operands[0].regs[1] == X86R_DI) {\n\t\t\t\t\trm = B0011;\n\t\t\t\t} else if (op->operands[0].regs[0] == X86R_SI && op->operands[0].regs[1] == -1) {\n\t\t\t\t\trm = B0100;\n\t\t\t\t} else if (op->operands[0].regs[0] == X86R_DI && op->operands[0].regs[1] == -1) {\n\t\t\t\t\trm = B0101;\n\t\t\t\t} else if (op->operands[0].regs[0] == X86R_BX && op->operands[0].regs[1] == -1) {\n\t\t\t\t\trm = B0111;\n\t\t\t\t} else {\n\t\t\t\t\t//TODO allow for displacement only when parser is reworked\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tmodrm = (mod << 6) | (reg << 3) | rm;\n\t\t\t} else {\n\t\t\t\t//rm\n\t\t\t\tif (op->operands[0].extended) {\n\t\t\t\t\trm = op->operands[0].reg;\n\t\t\t\t} else {\n\t\t\t\t\trm = op->operands[0].regs[0];\n\t\t\t\t}\n\t\t\t\t//[epb] alone is illegal, so we need to fake a [ebp+0]\n\t\t\t\tif (rm == 5 && mod == 0) {\n\t\t\t\t\tmod = 1;\n\t\t\t\t}\n\n\t\t\t\t//sib\n\t\t\t\tint index = op->operands[0].regs[1];\n\t\t\t\tint scale = getsib(op->operands[0].scale[1]);\n\t\t\t\tif (index != -1) {\n\t\t\t\t\tuse_sib = true;\n\t\t\t\t\tsib = (scale << 6) | (index << 3) | rm;\n\t\t\t\t} else if (rm == 4) {\n\t\t\t\t\tuse_sib = true;\n\t\t\t\t\tsib = 0x24;\n\t\t\t\t}\n\t\t\t\tif (use_sib) {\n\t\t\t\t\trm = B0100;\n\t\t\t\t}\n\t\t\t\tif (rip_rel) {\n\t\t\t\t\tmodrm = (B0000 << 6) | (reg << 3) | B0101;\n\t\t\t\t\tsib = (scale << 6) | (B0100 << 3) | B0101;\n\t\t\t\t} else {\n\t\t\t\t\tmodrm = (mod << 6) | (reg << 3) | rm;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//build the final result\n\t\t\tif (use_aso) {\n\t\t\t\tdata[l++] = 0x67;\n\t\t\t}\n\t\t\tif (use_oso) {\n\t\t\t\tdata[l++] = 0x66;\n\t\t\t}\n\t\t\tif (use_rex) {\n\t\t\t\tdata[l++] = rex;\n\t\t\t}\n\t\t\tdata[l++] = opcode;\n\t\t\tdata[l++] = modrm;\n\t\t\tif (use_sib) {\n\t\t\t\tdata[l++] = sib;\n\t\t\t}\n\t\t\t//offset\n\t\t\tif (mod == 1) {\n\t\t\t\tdata[l++] = offset;\n\t\t\t} else if (reg_bits == 16 && mod == 2) {\n\t\t\t\tdata[l++] = offset;\n\t\t\t\tdata[l++] = offset >> 8;\n\t\t\t} else if (mod == 2 || rip_rel) {\n\t\t\t\tdata[l++] = offset;\n\t\t\t\tdata[l++] = offset >> 8;\n\t\t\t\tdata[l++] = offset >> 16;\n\t\t\t\tdata[l++] = offset >> 24;\n\t\t\t}\n\t\t\t//immediate\n\t\t\tint byte;\n\t\t\tfor (byte = 0; byte < dest_bits && byte < 32; byte += 8) {\n\t\t\t\tdata[l++] = (immediate >> byte);\n\t\t\t}\n\t\t}\n\t} else if (op->operands[1].type & OT_REGALL &&\n\t\t\t !(op->operands[1].type & OT_MEMORY)) {\n\t\tif (op->operands[0].type & OT_CONSTANT) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (op->operands[0].type & OT_REGTYPE & OT_SEGMENTREG &&\n\t\t    op->operands[1].type & OT_REGTYPE & OT_SEGMENTREG) {\n\t\t\t\treturn -1;\n\t\t}\n\t\t// Check reg sizes match\n\t\tif (op->operands[0].type & OT_REGTYPE && op->operands[1].type & OT_REGTYPE) {\n\t\t\tif (!((op->operands[0].type & ALL_SIZE) &\n\t\t\t(op->operands[1].type & ALL_SIZE))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif (a->bits == 64) {\n\t\t\tif (op->operands[0].extended) {\n\t\t\t\trex = 1;\n\t\t\t}\n\t\t\tif (op->operands[1].extended) {\n\t\t\t\trex += 4;\n\t\t\t}\n\t\t\tif (op->operands[1].type & OT_QWORD) {\n\t\t\t\tif (!(op->operands[0].type & OT_QWORD)) {\n\t\t\t\t\tdata[l++] = 0x67;\n\t\t\t\t\tdata[l++] = 0x48;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (op->operands[1].type & OT_QWORD &&\n\t\t\t\top->operands[0].type & OT_QWORD) {\n\t\t\t\tdata[l++] = 0x48 | rex;\n\t\t\t}\n\t\t\tif (op->operands[1].type & OT_DWORD &&\n\t\t\t\top->operands[0].type & OT_DWORD) {\n\t\t\t\tdata[l++] = 0x40 | rex;\n\t\t\t}\n\t\t} else if (op->operands[0].extended && op->operands[1].extended) {\n\t\t\tdata[l++] = 0x45;\n\t\t}\n\t\toffset = op->operands[0].offset * op->operands[0].offset_sign;\n\t\tif (op->operands[1].type & OT_REGTYPE & OT_SEGMENTREG) {\n\t\t\tdata[l++] = 0x8c;\n\t\t} else {\n\t\t\tif (op->operands[0].type & OT_WORD) {\n\t\t\t\tdata[l++] = 0x66;\n\t\t\t}\n\t\t\tdata[l++] = (op->operands[0].type & OT_BYTE) ? 0x88 : 0x89;\n\t\t}\n\n\t\tif (op->operands[0].scale[0] > 1) {\n\t\t\t\tdata[l++] = op->operands[1].reg << 3 | 4;\n\t\t\t\tdata[l++] = getsib (op->operands[0].scale[0]) << 6 |\n\t\t\t\t\t\t    op->operands[0].regs[0] << 3 | 5;\n\n\t\t\t\tdata[l++] = offset;\n\t\t\t\tdata[l++] = offset >> 8;\n\t\t\t\tdata[l++] = offset >> 16;\n\t\t\t\tdata[l++] = offset >> 24;\n\n\t\t\t\treturn l;\n\t\t\t}\n\n\t\tif (!(op->operands[0].type & OT_MEMORY)) {\n\t\t\tif (op->operands[0].reg == X86R_UNDEFINED ||\n\t\t\t\top->operands[1].reg == X86R_UNDEFINED) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmod = 0x3;\n\t\t\tdata[l++] = mod << 6 | op->operands[1].reg << 3 | op->operands[0].reg;\n\t\t} else if (op->operands[0].regs[0] == X86R_UNDEFINED) {\n\t\t\tdata[l++] = op->operands[1].reg << 3 | 0x5;\n\t\t\tdata[l++] = offset;\n\t\t\tdata[l++] = offset >> 8;\n\t\t\tdata[l++] = offset >> 16;\n\t\t\tdata[l++] = offset >> 24;\n\t\t} else {\n\t\t\tif (op->operands[0].type & OT_MEMORY) {\n\t\t\t\tif (op->operands[0].regs[1] != X86R_UNDEFINED) {\n\t\t\t\t\tdata[l++] = op->operands[1].reg << 3 | 0x4;\n\t\t\t\t\tdata[l++] = op->operands[0].regs[1] << 3 | op->operands[0].regs[0];\n\t\t\t\t\treturn l;\n\t\t\t\t}\n\t\t\t\tif (offset) {\n\t\t\t\t\tmod = (offset > 128 || offset < -129) ? 0x2 : 0x1;\n\t\t\t\t}\n\t\t\t\tif (op->operands[0].regs[0] == X86R_EBP) {\n\t\t\t\t\tmod = 0x2;\n\t\t\t\t}\n\t\t\t\tdata[l++] = mod << 6 | op->operands[1].reg << 3 | op->operands[0].regs[0];\n\t\t\t\tif (op->operands[0].regs[0] == X86R_ESP) {\n\t\t\t\t\tdata[l++] = 0x24;\n\t\t\t\t}\n\t\t\t\tif (offset) {\n\t\t\t\t\tdata[l++] = offset;\n\t\t\t\t}\n\t\t\t\tif (mod == 2) {\n\t\t\t\t\t// warning C4293: '>>': shift count negative or too big, undefined behavior\n\t\t\t\t\tdata[l++] = offset >> 8;\n\t\t\t\t\tdata[l++] = offset >> 16;\n\t\t\t\t\tdata[l++] = offset >> 24;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (op->operands[1].type & OT_MEMORY) {\n\t\tif (op->operands[0].type & OT_MEMORY) {\n\t\t\treturn -1;\n\t\t}\n\t\toffset = op->operands[1].offset * op->operands[1].offset_sign;\n\t\tif (op->operands[0].reg == X86R_EAX && op->operands[1].regs[0] == X86R_UNDEFINED) {\n\t\t\tif (a->bits == 64) {\n\t\t\t\tdata[l++] = 0x48;\n\t\t\t}\n\t\t\tif (op->operands[0].type & OT_BYTE) {\n\t\t\t\tdata[l++] = 0xa0;\n\t\t\t} else {\n\t\t\t\tdata[l++] = 0xa1;\n\t\t\t}\n\t\t\tdata[l++] = offset;\n\t\t\tdata[l++] = offset >> 8;\n\t\t\tdata[l++] = offset >> 16;\n\t\t\tdata[l++] = offset >> 24;\n\t\t\tif (a->bits == 64) {\n\t\t\t\tdata[l++] = offset >> 32;\n\t\t\t\tdata[l++] = offset >> 40;\n\t\t\t\tdata[l++] = offset >> 48;\n\t\t\t\tdata[l++] = offset >> 54;\n\t\t\t}\n\t\t\treturn l;\n\t\t}\n\t\tif (op->operands[0].type & OT_BYTE && a->bits == 64 && op->operands[1].regs[0]) {\n\t\t\tif (op->operands[1].regs[0] >= X86R_R8 &&\n\t\t\t    op->operands[0].reg < 4) {\n\t\t\t\tdata[l++] = 0x41;\n\t\t\t\tdata[l++] = 0x8a;\n\t\t\t\tdata[l++] = op->operands[0].reg << 3 | (op->operands[1].regs[0] - 8);\n\t\t\t\treturn l;\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (op->operands[1].type & OT_REGTYPE & OT_SEGMENTREG) {\n\t\t\tif (op->operands[1].scale[0] == 0) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tdata[l++] = SEG_REG_PREFIXES[op->operands[1].regs[0]];\n\t\t\tdata[l++] = 0x8b;\n\t\t\tdata[l++] = op->operands[0].reg << 3 | 0x5;\n\t\t\tdata[l++] = offset;\n\t\t\tdata[l++] = offset >> 8;\n\t\t\tdata[l++] = offset >> 16;\n\t\t\tdata[l++] = offset >> 24;\n\t\t\treturn l;\n\t\t}\n\n\t\tif (a->bits == 64) {\n\t\t\tif (op->operands[0].type & OT_QWORD) {\n\t\t\t\tif (!(op->operands[1].type & OT_QWORD)) {\n\t\t\t\t\tif (op->operands[1].regs[0] != -1) {\n\t\t\t\t\t\tdata[l++] = 0x67;\n\t\t\t\t\t}\n\t\t\t\t\tdata[l++] = 0x48;\n\t\t\t\t}\n\t\t\t} else if (op->operands[1].type & OT_DWORD) {\n\t\t\t\tdata[l++] = 0x44;\n\t\t\t} else if (!(op->operands[1].type & OT_QWORD)) {\n\t\t\t\tdata[l++] = 0x67;\n\t\t\t}\n\t\t\tif (op->operands[1].type & OT_QWORD &&\n\t\t\t\top->operands[0].type & OT_QWORD) {\n\t\t\t\tdata[l++] = 0x48;\n\t\t\t}\n\t\t}\n\n\t\tif (op->operands[0].type & OT_WORD) {\n\t\t\tdata[l++] = 0x66;\n\t\t\tdata[l++] = op->operands[1].type & OT_BYTE ? 0x8a : 0x8b;\n\t\t} else {\n\t\t\tdata[l++] = (op->operands[1].type & OT_BYTE ||\n\t\t\t\top->operands[0].type & OT_BYTE) ?\n\t\t\t\t0x8a : 0x8b;\n\t\t}\n\n\t\tif (op->operands[1].regs[0] == X86R_UNDEFINED) {\n\t\t\tif (a->bits == 64) {\n\t\t\t\tdata[l++] = op->operands[0].reg << 3 | 0x4;\n\t\t\t\tdata[l++] = 0x25;\n\t\t\t} else {\n\t\t\t\tdata[l++] = op->operands[0].reg << 3 | 0x5;\n\t\t\t}\n\t\t\tdata[l++] = offset;\n\t\t\tdata[l++] = offset >> 8;\n\t\t\tdata[l++] = offset >> 16;\n\t\t\tdata[l++] = offset >> 24;\n\t\t} else {\n\t\t\tif (op->operands[1].scale[0] > 1) {\n\t\t\t\tdata[l++] = op->operands[0].reg << 3 | 4;\n\n\t\t\t\tif (op->operands[1].scale[0] >= 2) {\n\t\t\t\t\tbase = 5;\n\t\t\t\t}\n\t\t\t\tif (base) {\n\t\t\t\t\tdata[l++] = getsib (op->operands[1].scale[0]) << 6 | op->operands[1].regs[0] << 3 | base;\n\t\t\t\t} else {\n\t\t\t\t\tdata[l++] = getsib (op->operands[1].scale[0]) << 3 | op->operands[1].regs[0];\n\t\t\t\t}\n\t\t\t\tif (offset || base) {\n\t\t\t\t\tdata[l++] = offset;\n\t\t\t\t\tdata[l++] = offset >> 8;\n\t\t\t\t\tdata[l++] = offset >> 16;\n\t\t\t\t\tdata[l++] = offset >> 24;\n\t\t\t\t}\n\t\t\t\treturn l;\n\t\t\t}\n\t\t\tif (op->operands[1].regs[1] != X86R_UNDEFINED) {\n\t\t\t\tdata[l++] = op->operands[0].reg << 3 | 0x4;\n\t\t\t\tdata[l++] = op->operands[1].regs[1] << 3 | op->operands[1].regs[0];\n\t\t\t\treturn l;\n\t\t\t}\n\n\t\t\tif (offset || op->operands[1].regs[0] == X86R_EBP) {\n\t\t\t\tmod = 0x2;\n\t\t\t\tif (op->operands[1].offset > 127) {\n\t\t\t\t\tmod = 0x4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->bits == 64 && offset && op->operands[0].type & OT_QWORD) {\n\t\t\t\tif (op->operands[1].regs[0] == X86R_RIP) {\n\t\t\t\t\tdata[l++] = 0x5;\n\t\t\t\t} else {\n\t\t\t\t\tif (op->operands[1].offset > 127) {\n\t\t\t\t\t\tdata[l++] = 0x80 | op->operands[0].reg << 3 | op->operands[1].regs[0];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdata[l++] = 0x40 | op->operands[1].regs[0];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (op->operands[1].offset > 127) {\n\t\t\t\t\tmod = 0x1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (op->operands[1].regs[0] == X86R_EIP && (op->operands[0].type & OT_DWORD)) {\n\t\t\t\t\tdata[l++] = 0x0d;\n\t\t\t\t} else if (op->operands[1].regs[0] == X86R_RIP && (op->operands[0].type & OT_QWORD)) {\n\t\t\t\t\tdata[l++] = 0x05;\n\t\t\t\t} else {\n\t\t\t\t\tdata[l++] = mod << 5 | op->operands[0].reg << 3 | op->operands[1].regs[0];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (op->operands[1].regs[0] == X86R_ESP) {\n\t\t\t\tdata[l++] = 0x24;\n\t\t\t}\n\t\t\tif (mod >= 0x2) {\n\t\t\t\tdata[l++] = offset;\n\t\t\t\tif (op->operands[1].offset > 128 || op->operands[1].regs[0] == X86R_EIP) {\n\t\t\t\t\tdata[l++] = offset >> 8;\n\t\t\t\t\tdata[l++] = offset >> 16;\n\t\t\t\t\tdata[l++] = offset >> 24;\n\t\t\t\t}\n\t\t\t} else if (a->bits == 64 && (offset || op->operands[1].regs[0] == X86R_RIP)) {\n\t\t\t\tdata[l++] = offset;\n\t\t\t\tif (op->operands[1].offset > 127 || op->operands[1].regs[0] == X86R_RIP) {\n\t\t\t\t\tdata[l++] = offset >> 8;\n\t\t\t\t\tdata[l++] = offset >> 16;\n\t\t\t\t\tdata[l++] = offset >> 24;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn l;\n}\n\nstatic int opmul(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\n\tif ( op->operands[0].type & OT_QWORD ) {\n\t\tdata[l++] = 0x48;\n\t}\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_WORD ) {\n\t\t\tdata[l++] = 0x66;\n\t\t}\n\t\tif (op->operands[0].type & OT_BYTE) {\n\t\t\tdata[l++] = 0xf6;\n\t\t} else {\n\t\t\tdata[l++] = 0xf7;\n\t\t}\n\t\tif (op->operands[0].type & OT_MEMORY) {\n\t\t\tdata[l++] = 0x20 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\tdata[l++] = 0xe0 | op->operands[0].reg;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int oppop(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tint offset = 0;\n\tint mod = 0;\n\tif (op->operands[0].type & OT_GPREG) {\n\t\tif (op->operands[0].type & OT_MEMORY) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (op->operands[0].type & OT_REGTYPE & OT_SEGMENTREG) {\n\t\t\tut8 base;\n\t\t\tif (op->operands[0].reg & X86R_FS) {\n\t\t\t\tdata[l++] = 0x0f;\n\t\t\t\tbase = 0x81;\n\t\t\t} else {\n\t\t\t\tbase = 0x7;\n\t\t\t}\n\t\t\tdata[l++] = base + (8 * op->operands[0].reg);\n\t\t} else {\n\t\t\tut8 base = 0x58;\n\t\t\tdata[l++] = base + op->operands[0].reg;\n\t\t}\n\t} else if (op->operands[0].type & OT_MEMORY) {\n\t\tdata[l++] = 0x8f;\n\t\toffset = op->operands[0].offset * op->operands[0].offset_sign;\n\t\tif (offset != 0 || op->operands[0].regs[0] == X86R_EBP) {\n\t\t\tmod = 1;\n\t\t\tif (offset >= 128 || offset < -128) {\n\t\t\t\tmod = 2;\n\t\t\t}\n\t\t\tdata[l++] = mod << 6 | op->operands[0].regs[0];\n\t\t\tif (op->operands[0].regs[0] == X86R_ESP) {\n\t\t\t\tdata[l++] = 0x24;\n\t\t\t}\n\t\t\tdata[l++] = offset;\n\t\t\tif (mod == 2) {\n\t\t\t\tdata[l++] = offset >> 8;\n\t\t\t\tdata[l++] = offset >> 16;\n\t\t\t\tdata[l++] = offset >> 24;\n\t\t\t}\n\t\t} else {\n\t\t\tdata[l++] = op->operands[0].regs[0];\n\t\t\tif (op->operands[0].regs[0] == X86R_ESP) {\n\t\t\t\tdata[l++] = 0x24;\n\t\t\t}\n\t\t}\n\n\t}\n\treturn l;\n}\n\nstatic int oppush(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tint mod = 0;\n\tst32 immediate = 0;;\n\tst32 offset = 0;\n\tif (op->operands[0].type & OT_GPREG &&\n\t    !(op->operands[0].type & OT_MEMORY)) {\n\t\tif (op->operands[0].type & OT_REGTYPE & OT_SEGMENTREG) {\n\t\t\tut8 base;\n\t\t\tif (op->operands[0].reg & X86R_FS) {\n\t\t\t\tdata[l++] = 0x0f;\n\t\t\t\tbase = 0x80;\n\t\t\t} else {\n\t\t\t\tbase = 0x6;\n\t\t\t}\n\t\t\tdata[l++] = base + (8 * op->operands[0].reg);\n\t\t} else {\n\t\t\tif (op->operands[0].extended && a->bits == 64) {\n\t\t\t\tdata[l++] = 0x41;\n\t\t\t}\n\t\t\tut8 base = 0x50;\n\t\t\tdata[l++] = base + op->operands[0].reg;\n\t\t}\n\t} else if (op->operands[0].type & OT_MEMORY) {\n\t\tdata[l++] = 0xff;\n\t\toffset = op->operands[0].offset * op->operands[0].offset_sign;\n\t\tmod = 0;\n\t\tif (offset != 0 || op->operands[0].regs[0] == X86R_EBP) {\n\t\t\tmod = 1;\n\t\t\tif (offset >= 128 || offset < -128) {\n\t\t\t\tmod = 2;\n\t\t\t}\n\t\t\tdata[l++] = mod << 6 | 6 << 3 | op->operands[0].regs[0];\n\t\t\tif (op->operands[0].regs[0] == X86R_ESP) {\n\t\t\t\tdata[l++] = 0x24;\n\t\t\t}\n\t\t\tdata[l++] = offset;\n\t\t\tif (mod == 2) {\n\t\t\t\tdata[l++] = offset >> 8;\n\t\t\t\tdata[l++] = offset >> 16;\n\t\t\t\tdata[l++] = offset >> 24;\n\t\t\t}\n\t\t} else {\n\t\t\tmod = 3;\n\t\t\tdata[l++] = mod << 4 | op->operands[0].regs[0];\n\t\t\tif (op->operands[0].regs[0] == X86R_ESP) {\n\t\t\t\tdata[l++] = 0x24;\n\t\t\t}\n\t\t}\n\t} else {\n\t\timmediate = op->operands[0].immediate * op->operands[0].sign;\n\t\tif (immediate >= 128 || immediate < -128) {\n\t\t\tdata[l++] = 0x68;\n\t\t\tdata[l++] = immediate;\n\t\t\tdata[l++] = immediate >> 8;\n\t\t\tdata[l++] = immediate >> 16;\n\t\t\tdata[l++] = immediate >> 24;\n\t\t} else {\n\t\t\tdata[l++] = 0x6a;\n\t\t\tdata[l++] = immediate;\n\t\t}\n\t}\n\treturn l;\n}\n\nstatic int opout(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tst32 immediate = 0;\n\tif (op->operands[0].reg == X86R_DX) {\n\t\tif (op->operands[1].reg == X86R_AL && op->operands[1].type & OT_BYTE) {\n\t\t\tdata[l++] = 0xee;\n\t\t\treturn l;\n\t\t}\n\t\tif (op->operands[1].reg == X86R_AX && op->operands[1].type & OT_WORD) {\n\t\t\tdata[l++] = 0x66;\n\t\t\tdata[l++] = 0xef;\n\t\t\treturn l;\n\t\t}\n\t\tif (op->operands[1].reg == X86R_EAX && op->operands[1].type & OT_DWORD) {\n\t\t\tdata[l++] = 0xef;\n\t\t\treturn l;\n\t\t}\n\t} else if (op->operands[0].type & OT_CONSTANT) {\n\t\timmediate = op->operands[0].immediate * op->operands[0].sign;\n\t\tif (immediate > 255 || immediate < -128) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (op->operands[1].reg == X86R_AL && op->operands[1].type & OT_BYTE) {\n\t\t\tdata[l++] = 0xe6;\n\t\t} else if (op->operands[1].reg == X86R_AX && op->operands[1].type & OT_WORD) {\n\t\t\tdata[l++] = 0x66;\n\t\t\tdata[l++] = 0xe7;\n\t\t} else if (op->operands[1].reg == X86R_EAX && op->operands[1].type & OT_DWORD) {\n\t\t\tdata[l++] = 0xe7;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tdata[l++] = immediate;\n\t} else {\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int oploop(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tdata[l++] = 0xe2;\n\tst8 delta = op->operands[0].immediate - a->pc - 2;\n\tdata[l++] = (ut8)delta;\n\treturn l;\n}\n\nstatic int opret(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tint immediate = 0;\n\tif (a->bits == 16) {\n\t\tdata[l++] = 0xc3;\n\t\treturn l;\n\t}\n\tif (op->operands[0].type == OT_UNKNOWN) {\n\t\tdata[l++] = 0xc3;\n\t} else if (op->operands[0].type & (OT_CONSTANT | OT_WORD)) {\n\t\tdata[l++] = 0xc2;\n\t\timmediate = op->operands[0].immediate * op->operands[0].sign;\n\t\tdata[l++] = immediate;\n\t\tdata[l++] = immediate << 8;\n\t}\n\treturn l;\n}\n\nstatic int opretf(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tst32 immediate = 0;\n\tif (op->operands[0].type & OT_CONSTANT) {\n\t\timmediate = op->operands[0].immediate * op->operands[0].sign;\n\t\tdata[l++] = 0xca;\n\t\tdata[l++] = immediate;\n\t\tdata[l++] = immediate >> 8;\n\t} else if (op->operands[0].type == OT_UNKNOWN) {\n\t\tdata[l++] = 0xcb;\n\t}\n\treturn l;\n}\n\nstatic int opstos(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tif (!strcmp(op->mnemonic, \"stosw\")) {\n\t\tdata[l++] = 0x66;\n\t}\n\tif (!strcmp(op->mnemonic, \"stosb\")) {\n\t\tdata[l++] = 0xaa;\n\t} else if (!strcmp(op->mnemonic, \"stosw\")) {\n\t\tdata[l++] = 0xab;\n\t} else if (!strcmp(op->mnemonic, \"stosd\")) {\n\t\tdata[l++] = 0xab;\n\t}\n\treturn l;\n}\n\nstatic int opset(RAsm *a, ut8 *data, const Opcode *op) {\n\tif (!(op->operands[0].type & (OT_GPREG | OT_BYTE))) {return -1;}\n\tint l = 0;\n\tint mod = 0;\n\tint reg = op->operands[0].regs[0];\n\n\tdata[l++] = 0x0f;\n\tif (!strcmp (op->mnemonic, \"seto\")) {\n\t\tdata[l++] = 0x90;\n\t} else if (!strcmp (op->mnemonic, \"setno\")) {\n\t\tdata[l++] = 0x91;\n\t} else if (!strcmp (op->mnemonic, \"setb\") ||\n\t\t\t  !strcmp (op->mnemonic, \"setnae\") ||\n\t\t\t  !strcmp (op->mnemonic, \"setc\")) {\n\t\tdata[l++] = 0x92;\n\t} else if (!strcmp (op->mnemonic, \"setnb\") ||\n\t\t\t   !strcmp (op->mnemonic, \"setae\") ||\n\t\t\t   !strcmp (op->mnemonic, \"setnc\")) {\n\t\tdata[l++] = 0x93;\n\t} else if (!strcmp (op->mnemonic, \"setz\") ||\n\t\t\t   !strcmp (op->mnemonic, \"sete\")) {\n\t\tdata[l++] = 0x94;\n\t} else if (!strcmp (op->mnemonic, \"setnz\") ||\n\t\t\t   !strcmp (op->mnemonic, \"setne\")) {\n\t\tdata[l++] = 0x95;\n\t} else if (!strcmp (op->mnemonic, \"setbe\") ||\n\t\t\t   !strcmp (op->mnemonic, \"setna\")) {\n\t\tdata[l++] = 0x96;\n\t} else if (!strcmp (op->mnemonic, \"setnbe\") ||\n\t\t\t   !strcmp (op->mnemonic, \"seta\")) {\n\t\tdata[l++] = 0x97;\n\t} else if (!strcmp (op->mnemonic, \"sets\")) {\n\t\tdata[l++] = 0x98;\n\t} else if (!strcmp (op->mnemonic, \"setns\")) {\n\t\tdata[l++] = 0x99;\n\t} else if (!strcmp (op->mnemonic, \"setp\") ||\n\t\t\t   !strcmp (op->mnemonic, \"setpe\")) {\n\t\tdata[l++] = 0x9a;\n\t} else if (!strcmp (op->mnemonic, \"setnp\") ||\n\t\t\t   !strcmp (op->mnemonic, \"setpo\")) {\n\t\tdata[l++] = 0x9b;\n\t} else if (!strcmp (op->mnemonic, \"setl\") ||\n\t\t\t   !strcmp (op->mnemonic, \"setnge\")) {\n\t\tdata[l++] = 0x9c;\n\t} else if (!strcmp (op->mnemonic, \"setnl\") ||\n\t\t\t   !strcmp (op->mnemonic, \"setge\")) {\n\t\tdata[l++] = 0x9d;\n\t} else if (!strcmp (op->mnemonic, \"setle\") ||\n\t\t\t   !strcmp (op->mnemonic, \"setng\")) {\n\t\tdata[l++] = 0x9e;\n\t} else if (!strcmp (op->mnemonic, \"setnle\") ||\n\t\t\t   !strcmp (op->mnemonic, \"setg\")) {\n\t\tdata[l++] = 0x9f;\n\t} else {\n\t\treturn -1;\n\t}\n\tif (!(op->operands[0].type & OT_MEMORY)) {\n\t\tmod = 3;\n\t\treg = op->operands[0].reg;\n\t}\n\tdata[l++] = mod << 6 | reg;\n\treturn l;\n}\n\nstatic int optest(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tif (!op->operands[0].type || !op->operands[1].type) {\n\t\teprintf (\"Error: Invalid operands\\n\");\n\t\treturn -1;\n\t}\n\tif (a->bits == 64) {\n\t\tif (op->operands[0].type & OT_MEMORY ||\n\t\t\top->operands[1].type & OT_MEMORY) {\n\t\t\tdata[l++] = 0x67;\n\t\t}\n\t\tif (op->operands[0].type & OT_QWORD &&\n\t\t\top->operands[1].type & OT_QWORD) {\n\t\t\tif (op->operands[0].extended &&\n\t\t\t    op->operands[1].extended) {\n\t\t\t\t\tdata[l++] = 0x4d;\n\t\t\t\t} else {\n\t\t\t\t\tdata[l++] = 0x48;\n\t\t\t\t}\n\t\t}\n\t}\n\n\tif (op->operands[1].type & OT_CONSTANT) {\n\t\tif (op->operands[0].type & OT_BYTE) {\n\t\t\tdata[l++] = 0xf6;\n\t\t\tdata[l++] = op->operands[0].regs[0];\n\t\t\tdata[l++] = op->operands[1].immediate;\n\t\t\treturn l;\n\t\t}\n\t\tdata[l++] = 0xf7;\n\t\tif (op->operands[0].type & OT_MEMORY) {\n\t\t\tdata[l++] = 0x00 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\tdata[l++] = 0xc0 | op->operands[0].reg;\n\t\t}\n\t\tdata[l++] = op->operands[1].immediate >> 0;\n\t\tdata[l++] = op->operands[1].immediate >> 8;\n\t\tdata[l++] = op->operands[1].immediate >> 16;\n\t\tdata[l++] = op->operands[1].immediate >> 24;\n\t\treturn l;\n\t}\n\tif (op->operands[0].type & OT_BYTE ||\n\t\top->operands[1].type & OT_BYTE) {\n\t\tdata[l++] = 0x84;\n\t} else {\n\t\tdata[l++] = 0x85;\n\t}\n\tif (op->operands[0].type & OT_MEMORY) {\n\t\tdata[l++] = 0x00 | op->operands[1].reg << 3 | op->operands[0].regs[0];\n\t} else {\n\t\tif (op->operands[1].type & OT_MEMORY) {\n\t\t\tdata[l++] = 0x00 | op->operands[0].reg << 3 | op->operands[1].regs[0];\n\t\t} else {\n\t\t\tdata[l++] = 0xc0 | op->operands[1].reg << 3 | op->operands[0].reg;\n\t\t}\n\t}\n\treturn l;\n}\n\nstatic int opxchg(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tint mod_byte = 0;\n\tint reg = 0;\n\tint rm = 0;\n\tst32 offset = 0;\n\n\tif (op->operands[0].type & OT_MEMORY || op->operands[1].type & OT_MEMORY) {\n\t\tdata[l++] = 0x87;\n\t\tif (op->operands[0].type & OT_MEMORY) {\n\t\t\trm = op->operands[0].regs[0];\n\t\t\toffset = op->operands[0].offset * op->operands[0].offset_sign;\n\t\t\treg = op->operands[1].reg;\n\t\t} else if (op->operands[1].type & OT_MEMORY) {\n\t\t\trm = op->operands[1].regs[0];\n\t\t\toffset = op->operands[1].offset * op->operands[1].offset_sign;\n\t\t\treg = op->operands[0].reg;\n\t\t}\n\t\tif (offset) {\n\t\t\tmod_byte = 1;\n\t\t\tif (offset < ST8_MIN || offset > ST8_MAX) {\n\t\t\t\tmod_byte = 2;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (op->operands[0].reg == X86R_EAX &&\n\t\t\top->operands[1].type & OT_GPREG) {\n\t\t\tdata[l++] = 0x90 + op->operands[1].reg;\n\t\t\treturn l;\n\t\t} else if (op->operands[1].reg == X86R_EAX &&\n\t\t\t\t   op->operands[0].type & OT_GPREG) {\n\t\t\tdata[l++] = 0x90 + op->operands[0].reg;\n\t\t\treturn l;\n\t\t} else if (op->operands[0].type & OT_GPREG &&\n\t\t\t\t   op->operands[1].type & OT_GPREG) {\n\t\t\tmod_byte = 3;\n\t\t\tdata[l++] = 0x87;\n\t\t\treg = op->operands[1].reg;\n\t\t\trm = op->operands[0].reg;\n\t\t}\n\t}\n\tdata[l++] = mod_byte << 6 | reg << 3 | rm;\n\tif (mod_byte > 0 && mod_byte < 3) {\n\t\tdata[l++] = offset;\n\t\tif (mod_byte == 2) {\n\t\t\tdata[l++] = offset >> 8;\n\t\t\tdata[l++] = offset >> 16;\n\t\t\tdata[l++] = offset >> 24;\n\t\t}\n\t}\n\treturn l;\n}\n\nstatic int opcdqe(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tif (a->bits == 64) {\n\t\tdata[l++] = 0x48;\n\t}\n\tdata[l++] = 0x98;\n\treturn l;\n}\n\nstatic int opfcmov(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tchar* fcmov = op->mnemonic + strlen(\"fcmov\");\n\tswitch (op->operands_count) {\n\tcase 2:\n\t\tif ( op->operands[0].type & OT_FPUREG & ~OT_REGALL && op->operands[0].reg == 0 &&\n\t\t     op->operands[1].type & OT_FPUREG & ~OT_REGALL ) {\n\t\t\tif ( !strcmp( fcmov, \"b\" ) ) {\n\t\t\t\tdata[l++] = 0xda;\n\t\t\t\tdata[l++] = 0xc0 | op->operands[1].reg;\n\t\t\t} else if ( !strcmp( fcmov, \"e\" ) ) {\n\t\t\t\tdata[l++] = 0xda;\n\t\t\t\tdata[l++] = 0xc8 | op->operands[1].reg;\n\t\t\t} else if ( !strcmp( fcmov, \"be\" ) ) {\n\t\t\t\tdata[l++] = 0xda;\n\t\t\t\tdata[l++] = 0xd0 | op->operands[1].reg;\n\t\t\t} else if ( !strcmp( fcmov, \"u\" ) ) {\n\t\t\t\tdata[l++] = 0xda;\n\t\t\t\tdata[l++] = 0xd8 | op->operands[1].reg;\n\t\t\t} else if ( !strcmp( fcmov, \"nb\" ) ) {\n\t\t\t\tdata[l++] = 0xdb;\n\t\t\t\tdata[l++] = 0xc0 | op->operands[1].reg;\n\t\t\t} else if ( !strcmp( fcmov, \"ne\" ) ) {\n\t\t\t\tdata[l++] = 0xdb;\n\t\t\t\tdata[l++] = 0xc8 | op->operands[1].reg;\n\t\t\t} else if ( !strcmp( fcmov, \"nbe\" ) ) {\n\t\t\t\tdata[l++] = 0xdb;\n\t\t\t\tdata[l++] = 0xd0 | op->operands[1].reg;\n\t\t\t} else if ( !strcmp( fcmov, \"nu\" ) ) {\n\t\t\t\tdata[l++] = 0xdb;\n\t\t\t\tdata[l++] = 0xd8 | op->operands[1].reg;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opffree(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif (op->operands[0].type & OT_FPUREG & ~OT_REGALL)  {\n\t\t\tdata[l++] = 0xdd;\n\t\t\tdata[l++] = 0xc0 | op->operands[0].reg;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfrstor(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif (op->operands[0].type & OT_MEMORY) {\n\t\t\tdata[l++] = 0xdd;\n\t\t\tdata[l++] = 0x20 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfxch(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 0:\n\t\tdata[l++] = 0xd9;\n\t\tdata[l++] = 0xc9;\n\t\tbreak;\n\tcase 1:\n\t\tif (op->operands[0].type & OT_FPUREG & ~OT_REGALL) {\n\t\t\tdata[l++] = 0xd9;\n\t\t\tdata[l++] = 0xc8 | op->operands[0].reg;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfucom(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_FPUREG & ~OT_REGALL ) {\n\t\t\tdata[l++] = 0xdd;\n\t\t\tdata[l++] = 0xe0 | op->operands[0].reg;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase 0:\n\t\tdata[l++] = 0xdd;\n\t\tdata[l++] = 0xe1;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfucomp(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_FPUREG & ~OT_REGALL ) {\n\t\t\tdata[l++] = 0xdd;\n\t\t\tdata[l++] = 0xe8 | op->operands[0].reg;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase 0:\n\t\tdata[l++] = 0xdd;\n\t\tdata[l++] = 0xe9;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfaddp(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 2:\n\t\tif ( op->operands[0].type & OT_FPUREG & ~OT_REGALL &&\n\t\t     op->operands[1].type & OT_FPUREG & ~OT_REGALL && op->operands[1].reg == 0 ) {\n\t\t\tdata[l++] = 0xde;\n\t\t\tdata[l++] = 0xc0 | op->operands[0].reg;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase 0:\n\t\tdata[l++] = 0xde;\n\t\tdata[l++] = 0xc1;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfiadd(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tif ( op->operands[0].type & OT_WORD ) {\n\t\t\t\tdata[l++] = 0xde;\n\t\t\t\tdata[l++] = 0x00 | op->operands[0].regs[0];\n\t\t\t} else if ( op->operands[0].type & OT_DWORD ) {\n\t\t\t\tdata[l++] = 0xda;\n\t\t\t\tdata[l++] = 0x00 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfadd(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tif ( op->operands[0].type & OT_QWORD ) {\n\t\t\t\tdata[l++] = 0xdc;\n\t\t\t\tdata[l++] = 0x00 | op->operands[0].regs[0];\n\t\t\t} else if ( op->operands[0].type & OT_DWORD ) {\n\t\t\t\tdata[l++] = 0xd8;\n\t\t\t\tdata[l++] = 0x00 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif ( op->operands[0].type & OT_FPUREG & ~OT_REGALL && op->operands[0].reg == 0 &&\n\t\t     op->operands[1].type & OT_FPUREG & ~OT_REGALL ) {\n\t\t\tdata[l++] = 0xd8;\n\t\t\tdata[l++] = 0xc0 | op->operands[1].reg;\n\t\t} else if ( op->operands[0].type & OT_FPUREG & ~OT_REGALL &&\n\t\t\t    op->operands[1].type & OT_FPUREG & ~OT_REGALL && op->operands[1].reg == 0 ) {\n\t\t\tdata[l++] = 0xdc;\n\t\t\tdata[l++] = 0xc0 | op->operands[0].reg;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opficom(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tif ( op->operands[0].type & OT_WORD ) {\n\t\t\t\tdata[l++] = 0xde;\n\t\t\t\tdata[l++] = 0x10 | op->operands[0].regs[0];\n\t\t\t} else if ( op->operands[0].type & OT_DWORD ) {\n\t\t\t\tdata[l++] = 0xda;\n\t\t\t\tdata[l++] = 0x10 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opficomp(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tif ( op->operands[0].type & OT_WORD ) {\n\t\t\t\tdata[l++] = 0xde;\n\t\t\t\tdata[l++] = 0x18 | op->operands[0].regs[0];\n\t\t\t} else if ( op->operands[0].type & OT_DWORD ) {\n\t\t\t\tdata[l++] = 0xda;\n\t\t\t\tdata[l++] = 0x18 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfild(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tif ( op->operands[0].type & OT_WORD ) {\n\t\t\t\tdata[l++] = 0xdf;\n\t\t\t\tdata[l++] = 0x00 | op->operands[0].regs[0];\n\t\t\t} else if ( op->operands[0].type & OT_DWORD ) {\n\t\t\t\tdata[l++] = 0xdb;\n\t\t\t\tdata[l++] = 0x00 | op->operands[0].regs[0];\n\t\t\t} else if ( op->operands[0].type & OT_QWORD ) {\n\t\t\t\tdata[l++] = 0xdf;\n\t\t\t\tdata[l++] = 0x28 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfldcw(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY &&\n\t\t     op->operands[0].type & OT_WORD ) {\n\t\t\tdata[l++] = 0xd9;\n\t\t\tdata[l++] = 0x28 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfldenv(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tdata[l++] = 0xd9;\n\t\t\tdata[l++] = 0x20 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfbld(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY &&\n\t\t     op->operands[0].type & OT_TBYTE ) {\n\t\t\tdata[l++] = 0xdf;\n\t\t\tdata[l++] = 0x20 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfbstp(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY &&\n\t\t     op->operands[0].type & OT_TBYTE ) {\n\t\t\tdata[l++] = 0xdf;\n\t\t\tdata[l++] = 0x30 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfxrstor(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tdata[l++] = 0x0f;\n\t\t\tdata[l++] = 0xae;\n\t\t\tdata[l++] = 0x08 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfxsave(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tdata[l++] = 0x0f;\n\t\t\tdata[l++] = 0xae;\n\t\t\tdata[l++] = 0x00 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfist(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tif ( op->operands[0].type & OT_WORD ) {\n\t\t\t\tdata[l++] = 0xdf;\n\t\t\t\tdata[l++] = 0x10 | op->operands[0].regs[0];\n\t\t\t} else if ( op->operands[0].type & OT_DWORD ) {\n\t\t\t\tdata[l++] = 0xdb;\n\t\t\t\tdata[l++] = 0x10 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfistp(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tif ( op->operands[0].type & OT_WORD ) {\n\t\t\t\tdata[l++] = 0xdf;\n\t\t\t\tdata[l++] = 0x18 | op->operands[0].regs[0];\n\t\t\t} else if ( op->operands[0].type & OT_DWORD ) {\n\t\t\t\tdata[l++] = 0xdb;\n\t\t\t\tdata[l++] = 0x18 | op->operands[0].regs[0];\n\t\t\t} else if ( op->operands[0].type & OT_QWORD ) {\n\t\t\t\tdata[l++] = 0xdf;\n\t\t\t\tdata[l++] = 0x38 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfisttp(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tif ( op->operands[0].type & OT_WORD ) {\n\t\t\t\tdata[l++] = 0xdf;\n\t\t\t\tdata[l++] = 0x08 | op->operands[0].regs[0];\n\t\t\t} else if ( op->operands[0].type & OT_DWORD ) {\n\t\t\t\tdata[l++] = 0xdb;\n\t\t\t\tdata[l++] = 0x08 | op->operands[0].regs[0];\n\t\t\t} else if ( op->operands[0].type & OT_QWORD ) {\n\t\t\t\tdata[l++] = 0xdd;\n\t\t\t\tdata[l++] = 0x08 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfstenv(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tdata[l++] = 0x9b;\n\t\t\tdata[l++] = 0xd9;\n\t\t\tdata[l++] = 0x30 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfnstenv(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tdata[l++] = 0xd9;\n\t\t\tdata[l++] = 0x30 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfdiv(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tif ( op->operands[0].type & OT_DWORD ) {\n\t\t\t\tdata[l++] = 0xd8;\n\t\t\t\tdata[l++] = 0x30 | op->operands[0].regs[0];\n\t\t\t} else if ( op->operands[0].type & OT_QWORD ) {\n\t\t\t\tdata[l++] = 0xdc;\n\t\t\t\tdata[l++] = 0x30 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif ( op->operands[0].type & OT_FPUREG & ~OT_REGALL && op->operands[0].reg == 0 &&\n\t\t     op->operands[1].type & OT_FPUREG & ~OT_REGALL ) {\n\t\t\tdata[l++] = 0xd8;\n\t\t\tdata[l++] = 0xf0 | op->operands[1].reg;\n\t\t} else if ( op->operands[0].type & OT_FPUREG & ~OT_REGALL &&\n\t\t\t    op->operands[1].type & OT_FPUREG & ~OT_REGALL && op->operands[1].reg == 0 ) {\n\t\t\tdata[l++] = 0xdc;\n\t\t\tdata[l++] = 0xf8 | op->operands[0].reg;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfdivp(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 0:\n\t\tdata[l++] = 0xde;\n\t\tdata[l++] = 0xf9;\n\t\tbreak;\n\tcase 2:\n\t\tif ( op->operands[0].type & OT_FPUREG & ~OT_REGALL &&\n\t\t     op->operands[1].type & OT_FPUREG & ~OT_REGALL && op->operands[1].reg == 0 ) {\n\t\t\tdata[l++] = 0xde;\n\t\t\tdata[l++] = 0xf8 | op->operands[0].reg;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfidiv(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tif ( op->operands[0].type & OT_DWORD ) {\n\t\t\t\tdata[l++] = 0xda;\n\t\t\t\tdata[l++] = 0x30 | op->operands[0].regs[0];\n\t\t\t} else if ( op->operands[0].type & OT_WORD ) {\n\t\t\t\tdata[l++] = 0xde;\n\t\t\t\tdata[l++] = 0x30 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfdivr(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tif ( op->operands[0].type & OT_DWORD ) {\n\t\t\t\tdata[l++] = 0xd8;\n\t\t\t\tdata[l++] = 0x38 | op->operands[0].regs[0];\n\t\t\t} else if ( op->operands[0].type & OT_QWORD ) {\n\t\t\t\tdata[l++] = 0xdc;\n\t\t\t\tdata[l++] = 0x38 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif ( op->operands[0].type & OT_FPUREG & ~OT_REGALL && op->operands[0].reg == 0 &&\n\t\t     op->operands[1].type & OT_FPUREG & ~OT_REGALL ) {\n\t\t\tdata[l++] = 0xd8;\n\t\t\tdata[l++] = 0xf8 | op->operands[1].reg;\n\t\t} else if ( op->operands[0].type & OT_FPUREG & ~OT_REGALL &&\n\t\t\t    op->operands[1].type & OT_FPUREG & ~OT_REGALL && op->operands[1].reg == 0 ) {\n\t\t\tdata[l++] = 0xdc;\n\t\t\tdata[l++] = 0xf0 | op->operands[0].reg;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfdivrp(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 0:\n\t\tdata[l++] = 0xde;\n\t\tdata[l++] = 0xf1;\n\t\tbreak;\n\tcase 2:\n\t\tif ( op->operands[0].type & OT_FPUREG & ~OT_REGALL &&\n\t\t     op->operands[1].type & OT_FPUREG & ~OT_REGALL && op->operands[1].reg == 0 ) {\n\t\t\tdata[l++] = 0xde;\n\t\t\tdata[l++] = 0xf0 | op->operands[0].reg;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfidivr(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tif ( op->operands[0].type & OT_DWORD ) {\n\t\t\t\tdata[l++] = 0xda;\n\t\t\t\tdata[l++] = 0x38 | op->operands[0].regs[0];\n\t\t\t} else if ( op->operands[0].type & OT_WORD ) {\n\t\t\t\tdata[l++] = 0xde;\n\t\t\t\tdata[l++] = 0x38 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfmul(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tif ( op->operands[0].type & OT_DWORD ) {\n\t\t\t\tdata[l++] = 0xd8;\n\t\t\t\tdata[l++] = 0x08 | op->operands[0].regs[0];\n\t\t\t} else if ( op->operands[0].type & OT_QWORD ) {\n\t\t\t\tdata[l++] = 0xdc;\n\t\t\t\tdata[l++] = 0x08 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif ( op->operands[0].type & OT_FPUREG & ~OT_REGALL && op->operands[0].reg == 0 &&\n\t\t     op->operands[1].type & OT_FPUREG & ~OT_REGALL ) {\n\t\t\tdata[l++] = 0xd8;\n\t\t\tdata[l++] = 0xc8 | op->operands[1].reg;\n\t\t} else if ( op->operands[0].type & OT_FPUREG & ~OT_REGALL &&\n\t\t\t    op->operands[1].type & OT_FPUREG & ~OT_REGALL && op->operands[1].reg == 0 ) {\n\t\t\tdata[l++] = 0xdc;\n\t\t\tdata[l++] = 0xc8 | op->operands[0].reg;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfmulp(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 0:\n\t\tdata[l++] = 0xde;\n\t\tdata[l++] = 0xc9;\n\t\tbreak;\n\tcase 2:\n\t\tif ( op->operands[0].type & OT_FPUREG & ~OT_REGALL &&\n\t\t     op->operands[1].type & OT_FPUREG & ~OT_REGALL && op->operands[1].reg == 0 ) {\n\t\t\tdata[l++] = 0xde;\n\t\t\tdata[l++] = 0xc8 | op->operands[0].reg;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfimul(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tif ( op->operands[0].type & OT_DWORD ) {\n\t\t\t\tdata[l++] = 0xda;\n\t\t\t\tdata[l++] = 0x08 | op->operands[0].regs[0];\n\t\t\t} else if ( op->operands[0].type & OT_WORD ) {\n\t\t\t\tdata[l++] = 0xde;\n\t\t\t\tdata[l++] = 0x08 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfsub(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tif ( op->operands[0].type & OT_DWORD ) {\n\t\t\t\tdata[l++] = 0xd8;\n\t\t\t\tdata[l++] = 0x20 | op->operands[0].regs[0];\n\t\t\t} else if ( op->operands[0].type & OT_QWORD ) {\n\t\t\t\tdata[l++] = 0xdc;\n\t\t\t\tdata[l++] = 0x20 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif ( op->operands[0].type & OT_FPUREG & ~OT_REGALL && op->operands[0].reg == 0 &&\n\t\t     op->operands[1].type & OT_FPUREG & ~OT_REGALL ) {\n\t\t\tdata[l++] = 0xd8;\n\t\t\tdata[l++] = 0xe0 | op->operands[1].reg;\n\t\t} else if ( op->operands[0].type & OT_FPUREG & ~OT_REGALL &&\n\t\t\t    op->operands[1].type & OT_FPUREG & ~OT_REGALL && op->operands[1].reg == 0 ) {\n\t\t\tdata[l++] = 0xdc;\n\t\t\tdata[l++] = 0xe8 | op->operands[0].reg;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfsubp(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 0:\n\t\tdata[l++] = 0xde;\n\t\tdata[l++] = 0xe9;\n\t\tbreak;\n\tcase 2:\n\t\tif ( op->operands[0].type & OT_FPUREG & ~OT_REGALL &&\n\t\t     op->operands[1].type & OT_FPUREG & ~OT_REGALL && op->operands[1].reg == 0 ) {\n\t\t\tdata[l++] = 0xde;\n\t\t\tdata[l++] = 0xe8 | op->operands[0].reg;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfisub(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tif ( op->operands[0].type & OT_DWORD ) {\n\t\t\t\tdata[l++] = 0xda;\n\t\t\t\tdata[l++] = 0x20 | op->operands[0].regs[0];\n\t\t\t} else if ( op->operands[0].type & OT_WORD ) {\n\t\t\t\tdata[l++] = 0xde;\n\t\t\t\tdata[l++] = 0x20 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfsubr(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tif ( op->operands[0].type & OT_DWORD ) {\n\t\t\t\tdata[l++] = 0xd8;\n\t\t\t\tdata[l++] = 0x28 | op->operands[0].regs[0];\n\t\t\t} else if ( op->operands[0].type & OT_QWORD ) {\n\t\t\t\tdata[l++] = 0xdc;\n\t\t\t\tdata[l++] = 0x28 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif ( op->operands[0].type & OT_FPUREG & ~OT_REGALL && op->operands[0].reg == 0 &&\n\t\t     op->operands[1].type & OT_FPUREG & ~OT_REGALL ) {\n\t\t\tdata[l++] = 0xd8;\n\t\t\tdata[l++] = 0xe8 | op->operands[1].reg;\n\t\t} else if ( op->operands[0].type & OT_FPUREG & ~OT_REGALL &&\n\t\t\t    op->operands[1].type & OT_FPUREG & ~OT_REGALL && op->operands[1].reg == 0 ) {\n\t\t\tdata[l++] = 0xdc;\n\t\t\tdata[l++] = 0xe0 | op->operands[0].reg;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfsubrp(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 0:\n\t\tdata[l++] = 0xde;\n\t\tdata[l++] = 0xe1;\n\t\tbreak;\n\tcase 2:\n\t\tif ( op->operands[0].type & OT_FPUREG & ~OT_REGALL &&\n\t\t     op->operands[1].type & OT_FPUREG & ~OT_REGALL && op->operands[1].reg == 0 ) {\n\t\t\tdata[l++] = 0xde;\n\t\t\tdata[l++] = 0xe0 | op->operands[0].reg;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfisubr(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tif ( op->operands[0].type & OT_DWORD ) {\n\t\t\t\tdata[l++] = 0xda;\n\t\t\t\tdata[l++] = 0x28 | op->operands[0].regs[0];\n\t\t\t} else if ( op->operands[0].type & OT_WORD ) {\n\t\t\t\tdata[l++] = 0xde;\n\t\t\t\tdata[l++] = 0x28 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfnstcw(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY &&\n\t\t     op->operands[0].type & OT_WORD ) {\n\t\t\tdata[l++] = 0xd9;\n\t\t\tdata[l++] = 0x38 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfstcw(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY &&\n\t\t     op->operands[0].type & OT_WORD ) {\n\t\t\tdata[l++] = 0x9b;\n\t\t\tdata[l++] = 0xd9;\n\t\t\tdata[l++] = 0x38 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfnstsw(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY &&\n\t\t     op->operands[0].type & OT_WORD ) {\n\t\t\tdata[l++] = 0xdd;\n\t\t\tdata[l++] = 0x38 | op->operands[0].regs[0];\n\t\t} else if ( op->operands[0].type & OT_GPREG &&\n\t\t\t    op->operands[0].type & OT_WORD  &&\n\t\t\t    op->operands[0].reg == X86R_AX ) {\n\t\t\tdata[l++] = 0xdf;\n\t\t\tdata[l++] = 0xe0;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfstsw(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY &&\n\t\t     op->operands[0].type & OT_WORD ) {\n\t\t\tdata[l++] = 0x9b;\n\t\t\tdata[l++] = 0xdd;\n\t\t\tdata[l++] = 0x38 | op->operands[0].regs[0];\n\t\t} else if ( op->operands[0].type & OT_GPREG &&\n\t\t\t    op->operands[0].type & OT_WORD  &&\n\t\t\t    op->operands[0].reg == X86R_AX ) {\n\t\t\tdata[l++] = 0x9b;\n\t\t\tdata[l++] = 0xdf;\n\t\t\tdata[l++] = 0xe0;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfnsave(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY &&\n\t\t     op->operands[0].type & OT_DWORD ) {\n\t\t\tdata[l++] = 0xdd;\n\t\t\tdata[l++] = 0x30 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfsave(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY &&\n\t\t     op->operands[0].type & OT_DWORD ) {\n\t\t\tdata[l++] = 0x9b;\n\t\t\tdata[l++] = 0xdd;\n\t\t\tdata[l++] = 0x30 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int oplldt(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_WORD ) {\n\t\t\tdata[l++] = 0x0f;\n\t\t\tdata[l++] = 0x00;\n\t\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\t\tdata[l++] = 0x10 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\tdata[l++] = 0xd0 | op->operands[0].reg;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int oplmsw(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_WORD ) {\n\t\t\tdata[l++] = 0x0f;\n\t\t\tdata[l++] = 0x01;\n\t\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\t\tdata[l++] = 0x30 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\tdata[l++] = 0xf0 | op->operands[0].reg;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int oplgdt(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tdata[l++] = 0x0f;\n\t\t\tdata[l++] = 0x01;\n\t\t\tdata[l++] = 0x10 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int oplidt(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tdata[l++] = 0x0f;\n\t\t\tdata[l++] = 0x01;\n\t\t\tdata[l++] = 0x18 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opsgdt(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tdata[l++] = 0x0f;\n\t\t\tdata[l++] = 0x01;\n\t\t\tdata[l++] = 0x00 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opstmxcsr(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY &&\n\t\t     op->operands[0].type & OT_DWORD ) {\n\t\t\tdata[l++] = 0x0f;\n\t\t\tdata[l++] = 0xae;\n\t\t\tdata[l++] = 0x18 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opstr(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY &&\n\t\t     op->operands[0].type & OT_WORD ) {\n\t\t\tdata[l++] = 0x0f;\n\t\t\tdata[l++] = 0x00;\n\t\t\tdata[l++] = 0x08 | op->operands[0].regs[0];\n\t\t} else if ( op->operands[0].type & OT_GPREG &&\n\t\t\t    op->operands[0].type & OT_DWORD ) {\n\t\t\tdata[l++] = 0x0f;\n\t\t\tdata[l++] = 0x00;\n\t\t\tdata[l++] = 0xc8 | op->operands[0].reg;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opsidt(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tdata[l++] = 0x0f;\n\t\t\tdata[l++] = 0x01;\n\t\t\tdata[l++] = 0x08 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opsldt(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( a->bits == 64 ) {\n\t\t\tdata[l++] = 0x48;\n\t\t}\n\t\tdata[l++] = 0x0f;\n\t\tdata[l++] = 0x00;\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tdata[l++] = 0x00 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\tdata[l++] = 0xc0 | op->operands[0].reg;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opsmsw(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( a->bits == 64 ) {\n\t\t\tdata[l++] = 0x48;\n\t\t}\n\t\tdata[l++] = 0x0f;\n\t\tdata[l++] = 0x01;\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tdata[l++] = 0x20 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\tdata[l++] = 0xe0 | op->operands[0].reg;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opverr(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_WORD ) {\n\t\t\tdata[l++] = 0x0f;\n\t\t\tdata[l++] = 0x00;\n\t\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\t\tdata[l++] = 0x20 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\tdata[l++] = 0xe0 | op->operands[0].reg;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opverw(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_WORD ) {\n\t\t\tdata[l++] = 0x0f;\n\t\t\tdata[l++] = 0x00;\n\t\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\t\tdata[l++] = 0x28 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\tdata[l++] = 0xe8 | op->operands[0].reg;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opvmclear(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY &&\n\t\t     op->operands[0].type & OT_QWORD\n\t\t     ) {\n\t\t\tdata[l++] = 0x66;\n\t\t\tdata[l++] = 0x0f;\n\t\t\tdata[l++] = 0xc7;\n\t\t\tdata[l++] = 0x30 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opvmon(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY &&\n\t\t     op->operands[0].type & OT_QWORD\n\t\t     ) {\n\t\t\tdata[l++] = 0xf3;\n\t\t\tdata[l++] = 0x0f;\n\t\t\tdata[l++] = 0xc7;\n\t\t\tdata[l++] = 0x30 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opvmptrld(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY &&\n\t\t     op->operands[0].type & OT_QWORD\n\t\t     ) {\n\t\t\tdata[l++] = 0x0f;\n\t\t\tdata[l++] = 0xc7;\n\t\t\tdata[l++] = 0x30 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opvmptrst(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY &&\n\t\t     op->operands[0].type & OT_QWORD\n\t\t     ) {\n\t\t\tdata[l++] = 0x0f;\n\t\t\tdata[l++] = 0xc7;\n\t\t\tdata[l++] = 0x38 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\ntypedef struct lookup_t {\n\tchar mnemonic[12];\n\tint only_x32;\n\tint (*opdo)(RAsm*, ut8*, const Opcode*);\n\tut64 opcode;\n\tint size;\n} LookupTable;\n\nLookupTable oplookup[] = {\n\t{\"aaa\", 0, NULL, 0x37, 1},\n\t{\"aad\", 0, NULL, 0xd50a, 2},\n\t{\"aam\", 0, opaam, 0},\n\t{\"aas\", 0, NULL, 0x3f, 1},\n\t{\"adc\", 0, &opadc, 0},\n\t{\"add\", 0, &opadd, 0},\n\t{\"adx\", 0, NULL, 0xd4, 1},\n\t{\"amx\", 0, NULL, 0xd5, 1},\n\t{\"and\", 0, &opand, 0},\n\t{\"bswap\", 0, &opbswap, 0},\n\t{\"call\", 0, &opcall, 0},\n\t{\"cbw\", 0, NULL, 0x6698, 2},\n\t{\"cdq\", 0, NULL, 0x99, 1},\n\t{\"cdqe\", 0, &opcdqe, 0},\n\t{\"cwde\", 0, &opcdqe, 0},\n\t{\"clc\", 0, NULL, 0xf8, 1},\n\t{\"cld\", 0, NULL, 0xfc, 1},\n\t{\"clflush\", 0, &opclflush, 0},\n\t{\"clgi\", 0, NULL, 0x0f01dd, 3},\n\t{\"cli\", 0, NULL, 0xfa, 1},\n\t{\"clts\", 0, NULL, 0x0f06, 2},\n\t{\"cmc\", 0, NULL, 0xf5, 1},\n\t{\"cmovo\", 0, &opcmov, 0},\n\t{\"cmovno\", 0, &opcmov, 0},\n\t{\"cmovb\", 0, &opcmov, 0},\n\t{\"cmovc\", 0, &opcmov, 0},\n\t{\"cmovnae\", 0, &opcmov, 0},\n\t{\"cmovae\", 0, &opcmov, 0},\n\t{\"cmovnb\", 0, &opcmov, 0},\n\t{\"cmovnc\", 0, &opcmov, 0},\n\t{\"cmove\", 0, &opcmov, 0},\n\t{\"cmovz\", 0, &opcmov, 0},\n\t{\"cmovne\", 0, &opcmov, 0},\n\t{\"cmovnz\", 0, &opcmov, 0},\n\t{\"cmovbe\", 0, &opcmov, 0},\n\t{\"cmovna\", 0, &opcmov, 0},\n\t{\"cmova\", 0, &opcmov, 0},\n\t{\"cmovnbe\", 0, &opcmov, 0},\n\t{\"cmovne\", 0, &opcmov, 0},\n\t{\"cmovnz\", 0, &opcmov, 0},\n\t{\"cmovs\", 0, &opcmov, 0},\n\t{\"cmovns\", 0, &opcmov, 0},\n\t{\"cmovp\", 0, &opcmov, 0},\n\t{\"cmovpe\", 0, &opcmov, 0},\n\t{\"cmovnp\", 0, &opcmov, 0},\n\t{\"cmovpo\", 0, &opcmov, 0},\n\t{\"cmovl\", 0, &opcmov, 0},\n\t{\"cmovnge\", 0, &opcmov, 0},\n\t{\"cmovge\", 0, &opcmov, 0},\n\t{\"cmovnl\", 0, &opcmov, 0},\n\t{\"cmovle\", 0, &opcmov, 0},\n\t{\"cmovng\", 0, &opcmov, 0},\n\t{\"cmovg\", 0, &opcmov, 0},\n\t{\"cmovnle\", 0, &opcmov, 0},\n\t{\"cmp\", 0, &opcmp, 0},\n\t{\"cmpsb\", 0, NULL, 0xa6, 1},\n\t{\"cmpsd\", 0, NULL, 0xa7, 1},\n\t{\"cmpsw\", 0, NULL, 0x66a7, 2},\n\t{\"cpuid\", 0, NULL, 0x0fa2, 2},\n\t{\"cwd\", 0, NULL, 0x6699, 2},\n\t{\"cwde\", 0, NULL, 0x98, 1},\n\t{\"daa\", 0, NULL, 0x27, 1},\n\t{\"das\", 0, NULL, 0x2f, 1},\n\t{\"dec\", 0, &opdec, 0},\n\t{\"div\", 0, &opdiv, 0},\n\t{\"emms\", 0, NULL, 0x0f77, 2},\n\t{\"f2xm1\", 0, NULL, 0xd9f0, 2},\n\t{\"fabs\", 0, NULL, 0xd9e1, 2},\n\t{\"fadd\", 0, &opfadd, 0},\n\t{\"faddp\", 0, &opfaddp, 0},\n\t{\"fbld\", 0, &opfbld, 0},\n\t{\"fbstp\", 0, &opfbstp, 0},\n\t{\"fchs\", 0, NULL, 0xd9e0, 2},\n\t{\"fclex\", 0, NULL, 0x9bdbe2, 3},\n\t{\"fcmovb\", 0, &opfcmov, 0},\n\t{\"fcmove\", 0, &opfcmov, 0},\n\t{\"fcmovbe\", 0, &opfcmov, 0},\n\t{\"fcmovu\", 0, &opfcmov, 0},\n\t{\"fcmovnb\", 0, &opfcmov, 0},\n\t{\"fcmovne\", 0, &opfcmov, 0},\n\t{\"fcmovnbe\", 0, &opfcmov, 0},\n\t{\"fcmovnu\", 0, &opfcmov, 0},\n\t{\"fcos\", 0, NULL, 0xd9ff, 2},\n\t{\"fdecstp\", 0, NULL, 0xd9f6, 2},\n\t{\"fdiv\", 0, &opfdiv, 0},\n\t{\"fdivp\", 0, &opfdivp, 0},\n\t{\"fdivr\", 0, &opfdivr, 0},\n\t{\"fdivrp\", 0, &opfdivrp, 0},\n\t{\"femms\", 0, NULL, 0x0f0e, 2},\n\t{\"ffree\", 0, &opffree, 0},\n\t{\"fiadd\", 0, &opfiadd, 0},\n\t{\"ficom\", 0, &opficom, 0},\n\t{\"ficomp\", 0, &opficomp, 0},\n\t{\"fidiv\", 0, &opfidiv, 0},\n\t{\"fidivr\", 0, &opfidivr, 0},\n\t{\"fild\", 0, &opfild, 0},\n\t{\"fimul\", 0, &opfimul, 0},\n\t{\"fincstp\", 0, NULL, 0xd9f7, 2},\n\t{\"finit\", 0, NULL, 0x9bdbe3, 3},\n        {\"fist\", 0, &opfist, 0},\n\t{\"fistp\", 0, &opfistp, 0},\n        {\"fisttp\", 0, &opfisttp, 0},\n\t{\"fisub\", 0, &opfisub, 0},\n\t{\"fisubr\", 0, &opfisubr, 0},\n\t{\"fld1\", 0, NULL, 0xd9e8, 2},\n\t{\"fldcw\", 0, &opfldcw, 0},\n\t{\"fldenv\", 0, &opfldenv, 0},\n\t{\"fldl2t\", 0, NULL, 0xd9e9, 2},\n\t{\"fldl2e\", 0, NULL, 0xd9ea, 2},\n\t{\"fldlg2\", 0, NULL, 0xd9ec, 2},\n\t{\"fldln2\", 0, NULL, 0xd9ed, 2},\n\t{\"fldpi\", 0, NULL, 0xd9eb, 2},\n\t{\"fldz\", 0, NULL, 0xd9ee, 2},\n\t{\"fmul\", 0, &opfmul, 0},\n\t{\"fmulp\", 0, &opfmulp, 0},\n\t{\"fnclex\", 0, NULL, 0xdbe2, 2},\n\t{\"fninit\", 0, NULL, 0xdbe3, 2},\n\t{\"fnop\", 0, NULL, 0xd9d0, 2},\n        {\"fnsave\", 0, &opfnsave, 0},\n        {\"fnstcw\", 0, &opfnstcw, 0},\n        {\"fnstenv\", 0, &opfnstenv, 0},\n        {\"fnstsw\", 0, &opfnstsw, 0},\n\t{\"fpatan\", 0, NULL, 0xd9f3, 2},\n\t{\"fprem\", 0, NULL, 0xd9f8, 2},\n\t{\"fprem1\", 0, NULL, 0xd9f5, 2},\n\t{\"fptan\", 0, NULL, 0xd9f2, 2},\n\t{\"frndint\", 0, NULL, 0xd9fc, 2},\n\t{\"frstor\", 0, &opfrstor, 0},\n\t{\"fsave\", 0, &opfsave, 0},\n\t{\"fscale\", 0, NULL, 0xd9fd, 2},\n\t{\"fsin\", 0, NULL, 0xd9fe, 2},\n\t{\"fsincos\", 0, NULL, 0xd9fb, 2},\n\t{\"fsqrt\", 0, NULL, 0xd9fa, 2},\n        {\"fstcw\", 0, &opfstcw, 0},\n        {\"fstenv\", 0, &opfstenv, 0},\n        {\"fstsw\", 0, &opfstsw, 0},\n\t{\"fsub\", 0, &opfsub, 0},\n\t{\"fsubp\", 0, &opfsubp, 0},\n\t{\"fsubr\", 0, &opfsubr, 0},\n\t{\"fsubrp\", 0, &opfsubrp, 0},\n\t{\"ftst\", 0, NULL, 0xd9e4, 2},\n\t{\"fucom\", 0, &opfucom, 0},\n\t{\"fucomp\", 0, &opfucomp, 0},\n\t{\"fucompp\", 0, NULL, 0xdae9, 2},\n\t{\"fwait\", 0, NULL, 0x9b, 1},\n\t{\"fxam\", 0, NULL, 0xd9e5, 2},\n\t{\"fxch\", 0, &opfxch, 0},\n\t{\"fxrstor\", 0, &opfxrstor, 0},\n\t{\"fxsave\", 0, &opfxsave, 0},\n\t{\"fxtract\", 0, NULL, 0xd9f4, 2},\n\t{\"fyl2x\", 0, NULL, 0xd9f1, 2},\n\t{\"fyl2xp1\", 0, NULL, 0xd9f9, 2},\n\t{\"getsec\", 0, NULL, 0x0f37, 2},\n\t{\"hlt\", 0, NULL, 0xf4, 1},\n\t{\"idiv\", 0, &opidiv, 0},\n\t{\"imul\", 0, &opimul, 0},\n\t{\"in\", 0, &opin, 0},\n\t{\"inc\", 0, &opinc, 0},\n\t{\"ins\", 0, NULL, 0x6d, 1},\n\t{\"insb\", 0, NULL, 0x6c, 1},\n\t{\"insd\", 0, NULL, 0x6d, 1},\n\t{\"insw\", 0, NULL, 0x666d, 2},\n\t{\"int\", 0, &opint, 0},\n\t{\"int1\", 0, NULL, 0xf1, 1},\n\t{\"int3\", 0, NULL, 0xcc, 1},\n\t{\"into\", 0, NULL, 0xce, 1},\n\t{\"invd\", 0, NULL, 0x0f08, 2},\n\t{\"iret\", 0, NULL, 0x66cf, 2},\n\t{\"iretd\", 0, NULL, 0xcf, 1},\n\t{\"ja\", 0, &opjc, 0},\n\t{\"jae\", 0, &opjc, 0},\n\t{\"jb\", 0, &opjc, 0},\n\t{\"jbe\", 0, &opjc, 0},\n\t{\"jc\", 0, &opjc, 0},\n\t{\"je\", 0, &opjc, 0},\n\t{\"jg\", 0, &opjc, 0},\n\t{\"jge\", 0, &opjc, 0},\n\t{\"jl\", 0, &opjc, 0},\n\t{\"jle\", 0, &opjc, 0},\n\t{\"jmp\", 0, &opjc, 0},\n\t{\"jna\", 0, &opjc, 0},\n\t{\"jnae\", 0, &opjc, 0},\n\t{\"jnb\", 0, &opjc, 0},\n\t{\"jnbe\", 0, &opjc, 0},\n\t{\"jnc\", 0, &opjc, 0},\n\t{\"jne\", 0, &opjc, 0},\n\t{\"jng\", 0, &opjc, 0},\n\t{\"jnge\", 0, &opjc, 0},\n\t{\"jnl\", 0, &opjc, 0},\n\t{\"jnle\", 0, &opjc, 0},\n\t{\"jno\", 0, &opjc, 0},\n\t{\"jnp\", 0, &opjc, 0},\n\t{\"jns\", 0, &opjc, 0},\n\t{\"jnz\", 0, &opjc, 0},\n\t{\"jo\", 0, &opjc, 0},\n\t{\"jp\", 0, &opjc, 0},\n\t{\"jpe\", 0, &opjc, 0},\n\t{\"jpo\", 0, &opjc, 0},\n\t{\"js\", 0, &opjc, 0},\n\t{\"jz\", 0, &opjc, 0},\n\t{\"lahf\", 0, NULL, 0x9f},\n\t{\"lea\", 0, &oplea, 0},\n\t{\"leave\", 0, NULL, 0xc9, 1},\n\t{\"les\", 0, &oples, 0},\n\t{\"lfence\", 0, NULL, 0x0faee8, 3},\n\t{\"lgdt\", 0, &oplgdt, 0},\n\t{\"lidt\", 0, &oplidt, 0},\n\t{\"lldt\", 0, &oplldt, 0},\n\t{\"lmsw\", 0, &oplmsw, 0},\n\t{\"lodsb\", 0, NULL, 0xac, 1},\n\t{\"lodsd\", 0, NULL, 0xad, 1},\n\t{\"lodsw\", 0, NULL, 0x66ad, 2},\n\t{\"loop\", 0, &oploop, 0},\n\t{\"mfence\", 0, NULL, 0x0faef0, 3},\n\t{\"monitor\", 0, NULL, 0x0f01c8, 3},\n\t{\"mov\", 0, &opmov, 0},\n\t{\"movsb\", 0, NULL, 0xa4, 1},\n\t{\"movsd\", 0, NULL, 0xa5, 1},\n\t{\"movsw\", 0, NULL, 0x66a5, 2},\n\t{\"movzx\", 0, &opmovx, 0},\n\t{\"movsx\", 0, &opmovx, 0},\n\t{\"mul\", 0, &opmul, 0},\n\t{\"mwait\", 0, NULL, 0x0f01c9, 3},\n\t{\"nop\", 0, NULL, 0x90, 1},\n\t{\"not\", 0, &opnot, 0},\n\t{\"or\", 0, &opor, 0},\n\t{\"out\", 0, &opout, 0},\n\t{\"outsb\", 0, NULL, 0x6e, 1},\n\t{\"outs\", 0, NULL, 0x6f, 1},\n\t{\"outsd\", 0, NULL, 0x6f, 1},\n\t{\"outsw\", 0, NULL, 0x666f, 2},\n\t{\"pop\", 0, &oppop, 0},\n\t{\"popa\", 1, NULL, 0x61, 1},\n\t{\"popad\", 1, NULL, 0x61, 1},\n\t{\"popal\", 1, NULL, 0x61, 1},\n\t{\"popaw\", 1, NULL, 0x6661, 2},\n\t{\"popfd\", 1, NULL, 0x9d, 1},\n\t{\"prefetch\", 0, NULL, 0x0f0d, 2},\n\t{\"push\", 0, &oppush, 0},\n\t{\"pusha\", 1, NULL, 0x60, 1},\n\t{\"pushad\", 1, NULL, 0x60, 1},\n\t{\"pushal\", 1, NULL, 0x60, 1},\n\t{\"pushfd\", 0, NULL, 0x9c, 1},\n\t{\"rcl\", 0, &process_group_2, 0},\n\t{\"rcr\", 0, &process_group_2, 0},\n\t{\"rep\", 0, &oprep, 0},\n\t{\"repe\", 0, &oprep, 0},\n\t{\"repne\", 0, &oprep, 0},\n\t{\"repz\", 0, &oprep, 0},\n\t{\"repnz\", 0, &oprep, 0},\n\t{\"rdmsr\", 0, NULL, 0x0f32, 2},\n\t{\"rdpmc\", 0, NULL, 0x0f33, 2},\n\t{\"rdtsc\", 0, NULL, 0x0f31, 2},\n\t{\"rdtscp\", 0, NULL, 0x0f01f9, 3},\n\t{\"ret\", 0, &opret, 0},\n\t{\"retf\", 0, &opretf, 0},\n\t{\"retw\", 0, NULL, 0x66c3, 2},\n\t{\"rol\", 0, &process_group_2, 0},\n\t{\"ror\", 0, &process_group_2, 0},\n\t{\"rsm\", 0, NULL, 0x0faa, 2},\n\t{\"sahf\", 0, NULL, 0x9e, 1},\n\t{\"sal\", 0, &process_group_2, 0},\n\t{\"salc\", 0, NULL, 0xd6, 1},\n\t{\"sar\", 0, &process_group_2, 0},\n\t{\"sbb\", 0, &opsbb, 0},\n\t{\"scasb\", 0, NULL, 0xae, 1},\n\t{\"scasd\", 0, NULL, 0xaf, 1},\n\t{\"scasw\", 0, NULL, 0x66af, 2},\n\t{\"seto\", 0, &opset, 0},\n\t{\"setno\", 0, &opset, 0},\n\t{\"setb\", 0, &opset, 0},\n\t{\"setnae\", 0, &opset, 0},\n\t{\"setc\", 0, &opset, 0},\n\t{\"setnb\", 0, &opset, 0},\n\t{\"setae\", 0, &opset, 0},\n\t{\"setnc\", 0, &opset, 0},\n\t{\"setz\", 0, &opset, 0},\n\t{\"sete\", 0, &opset, 0},\n\t{\"setnz\", 0, &opset, 0},\n\t{\"setne\", 0, &opset, 0},\n\t{\"setbe\", 0, &opset, 0},\n\t{\"setna\", 0, &opset, 0},\n\t{\"setnbe\", 0, &opset, 0},\n\t{\"seta\", 0, &opset, 0},\n\t{\"sets\", 0, &opset, 0},\n\t{\"setns\", 0, &opset, 0},\n\t{\"setp\", 0, &opset, 0},\n\t{\"setpe\", 0, &opset, 0},\n\t{\"setnp\", 0, &opset, 0},\n\t{\"setpo\", 0, &opset, 0},\n\t{\"setl\", 0, &opset, 0},\n\t{\"setnge\", 0, &opset, 0},\n\t{\"setnl\", 0, &opset, 0},\n\t{\"setge\", 0, &opset, 0},\n\t{\"setle\", 0, &opset, 0},\n\t{\"setng\", 0, &opset, 0},\n\t{\"setnle\", 0, &opset, 0},\n\t{\"setg\", 0, &opset, 0},\n\t{\"sfence\", 0, NULL, 0x0faef8, 3},\n\t{\"sgdt\", 0, &opsgdt, 0},\n\t{\"shl\", 0, &process_group_2, 0},\n\t{\"shr\", 0, &process_group_2, 0},\n\t{\"sidt\", 0, &opsidt, 0},\n\t{\"sldt\", 0, &opsldt, 0},\n\t{\"smsw\", 0, &opsmsw, 0},\n\t{\"stc\", 0, NULL, 0xf9, 1},\n\t{\"std\", 0, NULL, 0xfd, 1},\n\t{\"stgi\", 0, NULL, 0x0f01dc, 3},\n\t{\"sti\", 0, NULL, 0xfb, 1},\n\t{\"stmxcsr\", 0, &opstmxcsr, 0},\n\t{\"stosb\", 0, &opstos, 0},\n\t{\"stosd\", 0, &opstos, 0},\n\t{\"stosw\", 0, &opstos, 0},\n\t{\"str\", 0, &opstr, 0},\n\t{\"sub\", 0, &opsub, 0},\n\t{\"swapgs\", 0, NULL, 0x0f1ff8, 3},\n\t{\"syscall\", 0, NULL, 0x0f05, 2},\n\t{\"sysenter\", 0, NULL, 0x0f34, 2},\n\t{\"sysexit\", 0, NULL, 0x0f35, 2},\n\t{\"sysret\", 0, NULL, 0x0f07, 2},\n\t{\"ud2\", 0, NULL, 0x0f0b, 2},\n\t{\"verr\", 0, &opverr, 0},\n\t{\"verw\", 0, &opverw, 0},\n\t{\"vmcall\", 0, NULL, 0x0f01c1, 3},\n\t{\"vmclear\", 0, &opvmclear, 0},\n\t{\"vmlaunch\", 0, NULL, 0x0f01c2, 3},\n\t{\"vmload\", 0, NULL, 0x0f01da, 3},\n\t{\"vmmcall\", 0, NULL, 0x0f01d9, 3},\n\t{\"vmptrld\", 0, &opvmptrld, 0},\n\t{\"vmptrst\", 0, &opvmptrst, 0},\n\t{\"vmresume\", 0, NULL, 0x0f01c3, 3},\n\t{\"vmrun\", 0, NULL, 0x0f01d8, 3},\n\t{\"vmsave\", 0, NULL, 0x0f01db, 3},\n\t{\"vmxoff\", 0, NULL, 0x0f01c4, 3},\n\t{\"vmxon\", 0, &opvmon, 0},\n\t{\"vzeroall\", 0, NULL, 0xc5fc77, 3},\n\t{\"vzeroupper\", 0, NULL, 0xc5f877, 3},\n\t{\"wait\", 0, NULL, 0x9b, 1},\n\t{\"wbinvd\", 0, NULL, 0x0f09, 2},\n\t{\"wrmsr\", 0, NULL, 0x0f30, 2},\n\t{\"xadd\", 0, &opxadd, 0},\n\t{\"xchg\", 0, &opxchg, 0},\n\t{\"xgetbv\", 0, NULL, 0x0f01d0, 3},\n\t{\"xlatb\", 0, NULL, 0xd7, 1},\n\t{\"xor\", 0, &opxor, 0},\n\t{\"xsetbv\", 0, NULL, 0x0f01d1, 3},\n\t{\"test\", 0, &optest, 0},\n\t{\"null\", 0, NULL, 0, 0}\n};\n\nstatic x86newTokenType getToken(const char *str, size_t *begin, size_t *end) {\n\tif (*begin > strlen (str)) {\n\t\treturn TT_EOF;\n\t}\n\t// Skip whitespace\n\twhile (begin && str[*begin] && isspace ((ut8)str[*begin])) {\n\t\t++(*begin);\n\t}\n\n\tif (!str[*begin]) {                // null byte\n\t\t*end = *begin;\n\t\treturn TT_EOF;\n\t}\n\tif (isalpha ((ut8)str[*begin])) {   // word token\n\t\t*end = *begin;\n\t\twhile (end && str[*end] && isalnum ((ut8)str[*end])) {\n\t\t\t++(*end);\n\t\t}\n\t\treturn TT_WORD;\n\t}\n\tif (isdigit ((ut8)str[*begin])) {   // number token\n\t\t*end = *begin;\n\t\twhile (end && isalnum ((ut8)str[*end])) {     // accept alphanumeric characters, because hex.\n\t\t\t++(*end);\n\t\t}\n\t\treturn TT_NUMBER;\n\t} else {                             // special character: [, ], +, *, ...\n\t\t*end = *begin + 1;\n\t\treturn TT_SPECIAL;\n\t}\n}\n\n/**\n * Get the register at position pos in str. Increase pos afterwards.\n */\nstatic Register parseReg(RAsm *a, const char *str, size_t *pos, ut32 *type) {\n\tint i;\n\t// Must be the same order as in enum register_t\n\tconst char *regs[] = { \"eax\", \"ecx\", \"edx\", \"ebx\", \"esp\", \"ebp\", \"esi\", \"edi\", \"eip\", NULL };\n\tconst char *regsext[] = { \"r8d\", \"r9d\", \"r10d\", \"r11d\", \"r12d\", \"r13d\", \"r14d\", \"r15d\", NULL };\n\tconst char *regs8[] = { \"al\", \"cl\", \"dl\", \"bl\", \"ah\", \"ch\", \"dh\", \"bh\", NULL };\n\tconst char *regs16[] = { \"ax\", \"cx\", \"dx\", \"bx\", \"sp\", \"bp\", \"si\", \"di\", NULL };\n\tconst char *regs64[] = { \"rax\", \"rcx\", \"rdx\", \"rbx\", \"rsp\", \"rbp\", \"rsi\", \"rdi\", \"rip\", NULL};\n\tconst char *regs64ext[] = { \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\", NULL };\n\tconst char *sregs[] = { \"es\", \"cs\", \"ss\", \"ds\", \"fs\", \"gs\", NULL};\n\n\t// Get token (especially the length)\n\tsize_t nextpos, length;\n\tconst char *token;\n\tgetToken (str, pos, &nextpos);\n\ttoken = str + *pos;\n\tlength = nextpos - *pos;\n\t*pos = nextpos;\n\n\t// General purpose registers\n\tif (length == 3 && token[0] == 'e') {\n\t\tfor (i = 0; regs[i]; i++) {\n\t\t\tif (!r_str_ncasecmp (regs[i], token, length)) {\n\t\t\t\t*type = (OT_GPREG & OT_REG (i)) | OT_DWORD;\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t}\n\tif (length == 2 && (token[1] == 'l' || token[1] == 'h')) {\n\t\tfor (i = 0; regs8[i]; i++) {\n\t\t\tif (!r_str_ncasecmp (regs8[i], token, length)) {\n\t\t\t\t*type = (OT_GPREG & OT_REG (i)) | OT_BYTE;\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t}\n\tif (length == 2) {\n\t\tfor (i = 0; regs16[i]; i++) {\n\t\t\tif (!r_str_ncasecmp (regs16[i], token, length)) {\n\t\t\t\t*type = (OT_GPREG & OT_REG (i)) | OT_WORD;\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\t// This isn't working properly yet\n\t\tfor (i = 0; sregs[i]; i++) {\n\t\t\tif (!r_str_ncasecmp (sregs[i], token, length)) {\n\t\t\t\t*type = (OT_SEGMENTREG & OT_REG (i)) | OT_WORD;\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t}\n\tif (token[0] == 'r') {\n\t\tfor (i = 0; regs64[i]; i++) {\n\t\t\tif (!r_str_ncasecmp (regs64[i], token, length)) {\n\t\t\t\t*type = (OT_GPREG & OT_REG (i)) | OT_QWORD;\n\t\t\t\ta->bits = 64;\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; regs64ext[i]; i++) {\n\t\t\tif (!r_str_ncasecmp (regs64ext[i], token, length)) {\n\t\t\t\t*type = (OT_GPREG & OT_REG (i)) | OT_QWORD;\n\t\t\t\ta->bits = 64;\n\t\t\t\treturn i + 9;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; regsext[i]; i++) {\n\t\t\tif (!r_str_ncasecmp (regsext[i], token, length)) {\n\t\t\t\t*type = (OT_GPREG & OT_REG (i)) | OT_DWORD;\n\t\t\t\tif (a->bits < 32) {\n\t\t\t\t\ta->bits = 32;\n\t\t\t\t}\n\t\t\t\treturn i + 9;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Extended registers\n\tif (!r_str_ncasecmp (\"st\", token, 2)) {\n\t\t*type = (OT_FPUREG & ~OT_REGALL);\n\t\t*pos = 3;\n\t}\n\tif (!r_str_ncasecmp (\"mm\", token, 2)) {\n\t\t*type = (OT_MMXREG & ~OT_REGALL);\n\t\t*pos = 3;\n\t}\n\tif (!r_str_ncasecmp (\"xmm\", token, 3)) {\n\t\t*type = (OT_XMMREG & ~OT_REGALL);\n\t\t*pos = 4;\n\t}\n\n\t// Now read number, possibly with parantheses\n\tif (*type & (OT_FPUREG | OT_MMXREG | OT_XMMREG) & ~OT_REGALL) {\n\t\tRegister reg = X86R_UNDEFINED;\n\n\t\t// pass by '(',if there is one\n\t\tif (getToken (str, pos, &nextpos) == TT_SPECIAL && str[*pos] == '(') {\n\t\t\t*pos = nextpos;\n\t\t}\n\n\t\t// read number\n\t\t// const int maxreg = (a->bits == 64) ? 15 : 7;\n\t\tif (getToken (str, pos, &nextpos) != TT_NUMBER ||\n\t\t\t\t(reg = getnum (a, str + *pos)) > 7) {\n\t\t\tif ((int)reg > 15) {\n\t\t\t\teprintf (\"Too large register index!\\n\");\n\t\t\t\treturn X86R_UNDEFINED;\n\t\t\t} else {\n\t\t\t\treg -= 8;\n\t\t\t}\n\t\t}\n\n\t\t*pos = nextpos;\n\n\t\t// pass by ')'\n\t\tif (getToken (str, pos, &nextpos) == TT_SPECIAL && str[*pos] == ')') {\n\t\t\t*pos = nextpos;\n\t\t}\n\t\t// Safety to prevent a shift bigger than 31. Reg\n\t\t// should never be > 8 anyway\n\t\tif (reg > 7) {\n\t\t\teprintf (\"Too large register index!\\n\");\n\t\t\treturn X86R_UNDEFINED;\n\t\t}\n\t\t*type |= (OT_REG (reg) & ~OT_REGTYPE);\n\t\treturn reg;\n\t}\n\n\treturn X86R_UNDEFINED;\n}\n\nstatic void parse_segment_offset(RAsm *a, const char *str, size_t *pos,\n\t\tOperand *op, int reg_index) {\n\tint nextpos = *pos;\n\tchar *c = strchr (str + nextpos, ':');\n\tif (c) {\n\t\tnextpos ++; // Skip the ':'\n\t\tc = strchr (str + nextpos, '[');\n\t\tif (c) {nextpos ++;} // Skip the '['\n\n\t\t// Assign registers to match behaviour of OT_MEMORY type\n\t\top->regs[reg_index] = op->reg;\n\t\top->type |= OT_MEMORY;\n\t\top->offset_sign = 1;\n\t\tchar *p = strchr (str + nextpos, '-');\n\t\tif (p) {\n\t\t\top->offset_sign = -1;\n\t\t\tnextpos ++;\n\t\t}\n\t\top->scale[reg_index] = getnum (a, str + nextpos);\n\t\top->offset = op->scale[reg_index];\n\t}\n}\n// Parse operand\nstatic int parseOperand(RAsm *a, const char *str, Operand *op, bool isrepop) {\n\tsize_t pos, nextpos = 0;\n\tx86newTokenType last_type;\n\tint size_token = 1;\n\tbool explicit_size = false;\n\tint reg_index = 0;\n\t// Reset type\n\top->type = 0;\n\t// Consume tokens denoting the operand size\n\twhile (size_token) {\n\t\tpos = nextpos;\n\t\tlast_type = getToken (str, &pos, &nextpos);\n\n\t\t// Token may indicate size: then skip\n\t\tif (!r_str_ncasecmp (str + pos, \"ptr\", 3)) {\n\t\t\tcontinue;\n\t\t} else if (!r_str_ncasecmp (str + pos, \"byte\", 4)) {\n\t\t\top->type |= OT_MEMORY | OT_BYTE;\n\t\t\top->dest_size = OT_BYTE;\n\t\t\texplicit_size = true;\n\t\t} else if (!r_str_ncasecmp (str + pos, \"word\", 4)) {\n\t\t\top->type |= OT_MEMORY | OT_WORD;\n\t\t\top->dest_size = OT_WORD;\n\t\t\texplicit_size = true;\n\t\t} else if (!r_str_ncasecmp (str + pos, \"dword\", 5)) {\n\t\t\top->type |= OT_MEMORY | OT_DWORD;\n\t\t\top->dest_size = OT_DWORD;\n\t\t\texplicit_size = true;\n\t\t} else if (!r_str_ncasecmp (str + pos, \"qword\", 5)) {\n\t\t\top->type |= OT_MEMORY | OT_QWORD;\n\t\t\top->dest_size = OT_QWORD;\n\t\t\texplicit_size = true;\n\t\t} else if (!r_str_ncasecmp (str + pos, \"oword\", 5)) {\n\t\t\top->type |= OT_MEMORY | OT_OWORD;\n\t\t\top->dest_size = OT_OWORD;\n\t\t\texplicit_size = true;\n\t\t} else if (!r_str_ncasecmp (str + pos, \"tbyte\", 5)) {\n\t\t\top->type |= OT_MEMORY | OT_TBYTE;\n\t\t\top->dest_size = OT_TBYTE;\n\t\t\texplicit_size = true;\n\t\t} else { // the current token doesn't denote a size\n\t\t\tsize_token = 0;\n\t\t}\n\t}\n\n\t// Next token: register, immediate, or '['\n\tif (str[pos] == '[') {\n\t\t// Don't care about size, if none is given.\n\t\tif (!op->type) {\n\t\t\top->type = OT_MEMORY;\n\t\t}\n\t\t// At the moment, we only accept plain linear combinations:\n\t\t// part := address | [factor *] register\n\t\t// address := part {+ part}*\n\t\top->offset = op->scale[0] = op->scale[1] = 0;\n\n\t\tut64 temp = 1;\n\t\tRegister reg = X86R_UNDEFINED;\n\t\tbool first_reg = true;\n\t\twhile (str[pos] != ']') {\n\t\t\tif (pos > nextpos) {\n\t\t\t//\teprintf (\"Error parsing instruction\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpos = nextpos;\n\t\t\tif (!str[pos]) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlast_type = getToken (str, &pos, &nextpos);\n\n\t\t\tif (last_type == TT_SPECIAL) {\n\t\t\t\tif (str[pos] == '+' || str[pos] == '-' || str[pos] == ']') {\n\t\t\t\t\tif (reg != X86R_UNDEFINED) {\n\t\t\t\t\t\top->regs[reg_index] = reg;\n\t\t\t\t\t\top->scale[reg_index] = temp;\n\t\t\t\t\t\t++reg_index;\n\t\t\t\t\t} else {\n\t\t\t\t\t\top->offset += temp;\n\t\t\t\t\t\top->regs[reg_index] = X86R_UNDEFINED;\n\t\t\t\t\t}\n\n\t\t\t\t\ttemp = 1;\n\t\t\t\t\treg = X86R_UNDEFINED;\n\t\t\t\t} else if (str[pos] == '*') {\n\t\t\t\t\t// go to ], + or - to get scale\n\n\t\t\t\t\t// Something to do here?\n\t\t\t\t\t// Seems we are just ignoring '*' or assuming it implicitly.\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (last_type == TT_WORD) {\n\t\t\t\tut32 reg_type = 0;\n\n\t\t\t\t// We can't multiply registers\n\t\t\t\tif (reg != X86R_UNDEFINED) {\n\t\t\t\t\top->type = 0;\t// Make the result invalid\n\t\t\t\t}\n\n\t\t\t\t// Reset nextpos: parseReg wants to parse from the beginning\n\t\t\t\tnextpos = pos;\n\t\t\t\treg = parseReg (a, str, &nextpos, &reg_type);\n\n\t\t\t\tif (first_reg) {\n\t\t\t\t\top->extended = false;\n\t\t\t\t\tif (reg > 8) {\n\t\t\t\t\t\top->extended = true;\n\t\t\t\t\t\top->reg = reg - 9;\n\t\t\t\t\t}\n\t\t\t\t\tfirst_reg = false;\n\t\t\t\t} else if (reg > 8) {\n\t\t\t\t\top->reg = reg - 9;\n\t\t\t\t}\n\t\t\t\tif (reg_type & OT_REGTYPE & OT_SEGMENTREG) {\n\t\t\t\t\top->reg = reg;\n\t\t\t\t\top->type = reg_type;\n\t\t\t\t\tparse_segment_offset (a, str, &nextpos, op, reg_index);\n\t\t\t\t\treturn nextpos;\n\t\t\t\t}\n\n\t\t\t\t// Still going to need to know the size if not specified\n\t\t\t\tif (!explicit_size) {\n\t\t\t\t\top->type |= reg_type;\n\t\t\t\t}\n\t\t\t\top->reg_size = reg_type;\n\t\t\t\top->explicit_size = explicit_size;\n\n\t\t\t\t// Addressing only via general purpose registers\n\t\t\t\tif (!(reg_type & OT_GPREG)) {\n\t\t\t\t\top->type = 0;\t// Make the result invalid\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tchar *p = strchr (str, '+');\n\t\t\t\top->offset_sign = 1;\n\t\t\t\tif (!p) {\n\t\t\t\t\tp = strchr (str, '-');\n\t\t\t\t\tif (p) {\n\t\t\t\t\t\top->offset_sign = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//with SIB notation, we need to consider the right sign\n\t\t\t\tchar * plus = strchr (str, '+');\n\t\t\t\tchar * minus = strchr (str, '-');\n\t\t\t\tchar * closeB = strchr (str, ']');\n\t\t\t\tif (plus && minus && plus < closeB && minus < closeB) {\n\t\t\t\t\top->offset_sign = -1;\n\t\t\t\t}\n\t\t\t\t// If there's a scale, we don't want to parse out the\n\t\t\t\t// scale with the offset (scale + offset) otherwise the scale\n\t\t\t\t// will be the sum of the two. This splits the numbers\n\t\t\t\tchar *tmp;\n\t\t\t\ttmp = malloc (strlen (str + pos) + 1);\n\t\t\t\tstrcpy (tmp, str + pos);\n\t\t\t\tstrtok (tmp, \"+-\");\n\t\t\t\tst64 read = getnum (a, tmp);\n\t\t\t\tfree (tmp);\n\t\t\t\ttemp *= read;\n\t\t\t}\n\t\t}\n\t} else if (last_type == TT_WORD) {   // register\n\t\tnextpos = pos;\n\t\tRFlagItem *flag;\n\n\t\tif (isrepop) {\n\t\t\top->is_good_flag = false;\n\t\t\tstrncpy (op->rep_op, str, MAX_REPOP_LENGTH - 1);\n\t\t\top->rep_op[MAX_REPOP_LENGTH - 1] = '\\0';\n\t\t\treturn nextpos;\n\t\t}\n\n\t\top->reg = parseReg (a, str, &nextpos, &op->type);\n\n\t\top->extended = false;\n\t\tif (op->reg > 8) {\n\t\t\top->extended = true;\n\t\t\top->reg -= 9;\n\t\t}\n\t\tif (op->type & OT_REGTYPE & OT_SEGMENTREG) {\n\t\t\tparse_segment_offset (a, str, &nextpos, op, reg_index);\n\t\t\treturn nextpos;\n\t\t}\n\t\tif (op->reg == X86R_UNDEFINED) {\n\t\t\top->is_good_flag = false;\n\t\t\tif (a->num && a->num->value == 0) {\n\t\t\t\treturn nextpos;\n\t\t\t}\n\t\t\top->type = OT_CONSTANT;\n\t\t\tRCore *core = a->num? (RCore *)(a->num->userptr): NULL;\n\t\t\tif (core && (flag = r_flag_get (core->flags, str))) {\n\t\t\t\top->is_good_flag = true;\n\t\t\t}\n\n\t\t\tchar *p = strchr (str, '-');\n\t\t\tif (p) {\n\t\t\t\top->sign = -1;\n\t\t\t\tstr = ++p;\n\t\t\t}\n\t\t\top->immediate = getnum (a, str);\n\t\t} else if (op->reg < X86R_UNDEFINED) {\n\t\t\tstrncpy (op->rep_op, str, MAX_REPOP_LENGTH - 1);\n\t\t\top->rep_op[MAX_REPOP_LENGTH - 1] = '\\0';\n\t\t}\n\t} else {                             // immediate\n\t\t// We don't know the size, so let's just set no size flag.\n\t\top->type = OT_CONSTANT;\n\t\top->sign = 1;\n\t\tchar *p = strchr (str, '-');\n\t\tif (p) {\n\t\t\top->sign = -1;\n\t\t\tstr = ++p;\n\t\t}\n\t\top->immediate = getnum (a, str);\n\t}\n\n\treturn nextpos;\n}\n\nstatic int parseOpcode(RAsm *a, const char *op, Opcode *out) {\n\tout->has_bnd = false;\n\tbool isrepop = false;\n\tif (!strncmp (op, \"bnd \", 4)) {\n\t\tout->has_bnd = true;\n\t\top += 4;\n\t}\n\tchar *args = strchr (op, ' ');\n\tout->mnemonic = args ? r_str_ndup (op, args - op) : strdup (op);\n\tout->operands[0].type = out->operands[1].type = 0;\n\tout->operands[0].extended = out->operands[1].extended = false;\n\tout->operands[0].reg = out->operands[0].regs[0] = out->operands[0].regs[1] = X86R_UNDEFINED;\n\tout->operands[1].reg = out->operands[1].regs[0] = out->operands[1].regs[1] = X86R_UNDEFINED;\n\tout->operands[0].immediate = out->operands[1].immediate = 0;\n\tout->operands[0].sign = out->operands[1].sign = 1;\n\tout->operands[0].is_good_flag = out->operands[1].is_good_flag = true;\n\tout->is_short = false;\n\tout->operands_count = 0;\n\tif (args) {\n\t\targs++;\n\t} else {\n\t\treturn 1;\n\t}\n\tif (!r_str_ncasecmp (args, \"short\", 5)) {\n\t\tout->is_short = true;\n\t\targs += 5;\n\t}\n\tif (!strncmp (out->mnemonic, \"rep\", 3)) {\n\t\tisrepop = true;\n\t}\n\tparseOperand (a, args, &(out->operands[0]), isrepop);\n\tout->operands_count = 1;\n\twhile (out->operands_count < MAX_OPERANDS) {\n\t\targs = strchr (args, ',');\n\t\tif (!args) {\n\t\t\tbreak;\n\t\t}\n\t\targs++;\n\t\tparseOperand (a, args, &(out->operands[out->operands_count]), isrepop);\n\t\tout->operands_count++;\n\t}\n\treturn 0;\n}\n\nstatic ut64 getnum(RAsm *a, const char *s) {\n\tif (!s) {\n\t\treturn 0;\n\t}\n\tif (*s == '$') {\n\t\ts++;\n\t}\n\treturn r_num_math (a->num, s);\n}\n\nstatic int oprep(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tLookupTable *lt_ptr;\n\tint retval;\n\tif (!strcmp (op->mnemonic, \"rep\") ||\n\t    !strcmp (op->mnemonic, \"repe\") ||\n\t    !strcmp (op->mnemonic, \"repz\")) {\n\t\tdata[l++] = 0xf3;\n\t} else if (!strcmp (op->mnemonic, \"repne\") ||\n\t           !strcmp (op->mnemonic, \"repnz\")) {\n\t\tdata[l++] = 0xf2;\n\t}\n\tOpcode instr = {0};\n\tparseOpcode (a, op->operands[0].rep_op, &instr);\n\n\tfor (lt_ptr = oplookup; strcmp (lt_ptr->mnemonic, \"null\"); lt_ptr++) {\n\t\tif (!r_str_casecmp (instr.mnemonic, lt_ptr->mnemonic)) {\n\t\t\tif (lt_ptr->opcode > 0) {\n\t\t\t\tif (lt_ptr->only_x32 && a->bits == 64) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tut8 *ptr = (ut8 *)&lt_ptr->opcode;\n\t\t\t\tint i = 0;\n\t\t\t\tfor (; i < lt_ptr->size; i++) {\n\t\t\t\t\tdata[i + l] = ptr[lt_ptr->size - (i + 1)];\n\t\t\t\t}\n\t\t\t\tfree (instr.mnemonic);\n\t\t\t\treturn l + lt_ptr->size;\n\t\t\t} else {\n\t\t\t\tif (lt_ptr->opdo) {\n\t\t\t\t\tdata += l;\n\t\t\t\t\tif (instr.has_bnd) {\n\t\t\t\t\t\tdata[l] = 0xf2;\n\t\t\t\t\t\tdata++;\n\t\t\t\t\t}\n\t\t\t\t\tretval = lt_ptr->opdo (a, data, &instr);\n\t\t\t\t\t// if op supports bnd then the first byte will\n\t\t\t\t\t// be 0xf2.\n\t\t\t\t\tif (instr.has_bnd) {\n\t\t\t\t\t\tretval++;\n\t\t\t\t\t}\n\t\t\t\t\treturn l + retval;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfree (instr.mnemonic);\n\treturn -1;\n}\n\nstatic int assemble(RAsm *a, RAsmOp *ao, const char *str) {\n\tut8 __data[32] = {0};\n\tut8 *data = __data;\n\tchar op[128];\n\tLookupTable *lt_ptr;\n\tint retval = -1;\n\tOpcode instr = {0};\n\n\tstrncpy (op, str, sizeof (op) - 1);\n\top[sizeof (op) - 1] = '\\0';\n\tparseOpcode (a, op, &instr);\n\tfor (lt_ptr = oplookup; strcmp (lt_ptr->mnemonic, \"null\"); lt_ptr++) {\n\t\tif (!r_str_casecmp (instr.mnemonic, lt_ptr->mnemonic)) {\n\t\t\tif (lt_ptr->opcode > 0) {\n\t\t\t\tif (!lt_ptr->only_x32 || a->bits != 64) {\n\t\t\t\t\tut8 *ptr = (ut8 *)&lt_ptr->opcode;\n\t\t\t\t\tint i = 0;\n\t\t\t\t\tfor (; i < lt_ptr->size; i++) {\n\t\t\t\t\t\tdata[i] = ptr[lt_ptr->size - (i + 1)];\n\t\t\t\t\t}\n\t\t\t\t\tretval = lt_ptr->size;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (lt_ptr->opdo) {\n\t\t\t\t\tif (instr.has_bnd) {\n\t\t\t\t\t\tdata[0] = 0xf2;\n\t\t\t\t\t\tdata ++;\n\t\t\t\t\t}\n\t\t\t\t\tretval = lt_ptr->opdo (a, data, &instr);\n\t\t\t\t\t// if op supports bnd then the first byte will\n\t\t\t\t\t// be 0xf2.\n\t\t\t\t\tif (instr.has_bnd) {\n\t\t\t\t\t\tretval++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tr_asm_op_set_buf (ao, __data, retval);\n\tfree (instr.mnemonic);\n\treturn retval;\n}\n\nRAsmPlugin r_asm_plugin_x86_nz = {\n\t.name = \"x86.nz\",\n\t.desc = \"x86 handmade assembler\",\n\t.license = \"LGPL3\",\n\t.arch = \"x86\",\n\t.bits = 16 | 32 | 64,\n\t.endian = R_SYS_ENDIAN_LITTLE,\n\t.assemble = &assemble\n};\n\n#ifndef CORELIB\nR_API RLibStruct radare_plugin = {\n\t.type = R_LIB_TYPE_ASM,\n\t.data = &r_asm_plugin_x86_nz,\n\t.version = R2_VERSION\n};\n#endif\n"], "fixing_code": ["/* Copyright (C) 2008-2018 - pancake, unlogic, emvivre */\n\n#include <r_flag.h>\n#include <r_core.h>\n#include <r_asm.h>\n#include <r_lib.h>\n#include <r_types.h>\n#include <stdio.h>\n#include <string.h>\n\nstatic ut64 getnum(RAsm *a, const char *s);\n\n#define ENCODING_SHIFT 0\n#define OPTYPE_SHIFT   6\n#define REGMASK_SHIFT  16\n#define OPSIZE_SHIFT   24\n\n// How to encode the operand?\n#define OT_REGMEM      (1 << (ENCODING_SHIFT + 0))\n#define OT_SPECIAL     (1 << (ENCODING_SHIFT + 1))\n#define OT_IMMEDIATE   (1 << (ENCODING_SHIFT + 2))\n#define OT_JMPADDRESS  (1 << (ENCODING_SHIFT + 3))\n\n// Register indices - by default, we allow all registers\n#define OT_REGALL   (0xff << REGMASK_SHIFT)\n\n// Memory or register operands: how is the operand written in assembly code?\n#define OT_MEMORY      (1 << (OPTYPE_SHIFT + 0))\n#define OT_CONSTANT    (1 << (OPTYPE_SHIFT + 1))\n#define OT_GPREG      ((1 << (OPTYPE_SHIFT + 2)) | OT_REGALL)\n#define OT_SEGMENTREG ((1 << (OPTYPE_SHIFT + 3)) | OT_REGALL)\n#define OT_FPUREG     ((1 << (OPTYPE_SHIFT + 4)) | OT_REGALL)\n#define OT_MMXREG     ((1 << (OPTYPE_SHIFT + 5)) | OT_REGALL)\n#define OT_XMMREG     ((1 << (OPTYPE_SHIFT + 6)) | OT_REGALL)\n#define OT_CONTROLREG ((1 << (OPTYPE_SHIFT + 7)) | OT_REGALL)\n#define OT_DEBUGREG   ((1 << (OPTYPE_SHIFT + 8)) | OT_REGALL)\n#define OT_SREG       ((1 << (OPTYPE_SHIFT + 9)) | OT_REGALL)\n// more?\n\n#define OT_REGTYPE    ((OT_GPREG | OT_SEGMENTREG | OT_FPUREG | OT_MMXREG | OT_XMMREG | OT_CONTROLREG | OT_DEBUGREG) & ~OT_REGALL)\n\n// Register mask\n#define OT_REG(num)  ((1 << (REGMASK_SHIFT + (num))) | OT_REGTYPE)\n\n#define OT_UNKNOWN    (0 << OPSIZE_SHIFT)\n#define OT_BYTE       (1 << OPSIZE_SHIFT)\n#define OT_WORD       (2 << OPSIZE_SHIFT)\n#define OT_DWORD      (4 << OPSIZE_SHIFT)\n#define OT_QWORD      (8 << OPSIZE_SHIFT)\n#define OT_OWORD     (16 << OPSIZE_SHIFT)\n#define OT_TBYTE     (32 << OPSIZE_SHIFT)\n\n#define ALL_SIZE     (OT_BYTE | OT_WORD | OT_DWORD | OT_QWORD | OT_OWORD)\n\n// For register operands, we mostl don't care about the size.\n// So let's just set all relevant flags.\n#define OT_FPUSIZE  (OT_DWORD | OT_QWORD | OT_TBYTE)\n#define OT_XMMSIZE  (OT_DWORD | OT_QWORD | OT_OWORD)\n\n// Macros for encoding\n#define OT_REGMEMOP(type)  (OT_##type##REG | OT_MEMORY | OT_REGMEM)\n#define OT_REGONLYOP(type) (OT_##type##REG | OT_REGMEM)\n#define OT_MEMONLYOP       (OT_MEMORY | OT_REGMEM)\n#define OT_MEMIMMOP        (OT_MEMORY | OT_IMMEDIATE)\n#define OT_REGSPECOP(type) (OT_##type##REG | OT_SPECIAL)\n#define OT_IMMOP           (OT_CONSTANT | OT_IMMEDIATE)\n#define OT_MEMADDROP       (OT_MEMORY | OT_IMMEDIATE)\n\n// Some operations are encoded via opcode + spec field\n#define SPECIAL_SPEC 0x00010000\n#define SPECIAL_MASK 0x00000007\n\n#define MAX_OPERANDS 3\n#define MAX_REPOP_LENGTH 20\n\nconst ut8 SEG_REG_PREFIXES[] = {0x26, 0x2e, 0x36, 0x3e, 0x64, 0x65};\n\ntypedef enum tokentype_t {\n\tTT_EOF,\n\tTT_WORD,\n\tTT_NUMBER,\n\tTT_SPECIAL\n} x86newTokenType;\n\ntypedef enum register_t {\n\tX86R_UNDEFINED = -1,\n\tX86R_EAX = 0, X86R_ECX, X86R_EDX, X86R_EBX, X86R_ESP, X86R_EBP, X86R_ESI, X86R_EDI, X86R_EIP,\n\tX86R_AX = 0, X86R_CX, X86R_DX, X86R_BX, X86R_SP, X86R_BP, X86R_SI, X86R_DI,\n\tX86R_AL = 0, X86R_CL, X86R_DL, X86R_BL, X86R_AH, X86R_CH, X86R_DH, X86R_BH,\n\tX86R_RAX = 0, X86R_RCX, X86R_RDX, X86R_RBX, X86R_RSP, X86R_RBP, X86R_RSI, X86R_RDI, X86R_RIP,\n\tX86R_R8 = 0, X86R_R9, X86R_R10, X86R_R11, X86R_R12, X86R_R13, X86R_R14, X86R_R15,\n\tX86R_CS = 0, X86R_SS, X86R_DS, X86R_ES, X86R_FS, X86R_GS\t// Is this the right order?\n} Register;\n\ntypedef struct operand_t {\n\tut32 type;\n\tst8 sign;\n\tstruct {\n\t\tRegister reg;\n\t\tbool extended;\n\t};\n\tunion {\n\t\tstruct {\n\t\t\tlong offset;\n\t\t\tst8 offset_sign;\n\t\t\tRegister regs[2];\n\t\t\tint scale[2];\n\t\t};\n\t\tstruct {\n\t\t\tut64 immediate;\n\t\t\tbool is_good_flag;\n\t\t};\n\t\tstruct {\n\t\t\tchar rep_op[MAX_REPOP_LENGTH];\n\t\t};\n\t};\n\tbool explicit_size;\n\tut32 dest_size;\n\tut32 reg_size;\n} Operand;\n\ntypedef struct Opcode_t {\n\tchar *mnemonic;\n\tut32 op[3];\n\tsize_t op_len;\n\tbool is_short;\n\tut8 opcode[3];\n\tint operands_count;\n\tOperand operands[MAX_OPERANDS];\n\tbool has_bnd;\n} Opcode;\n\nstatic ut8 getsib(const ut8 sib) {\n\tif (!sib) {\n\t\treturn 0;\n\t}\n\treturn (sib & 0x8) ? 3 : getsib ((sib << 1) | 1) - 1;\n}\n\nstatic int is_al_reg(const Operand *op) {\n\tif (op->type & OT_MEMORY) {\n\t\treturn 0;\n\t}\n\tif (op->reg == X86R_AL && op->type & OT_BYTE) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int oprep(RAsm *a, ut8 *data, const Opcode *op);\n\nstatic int process_16bit_group_1(RAsm *a, ut8 *data, const Opcode *op, int op1) {\n\tint l = 0;\n\tint immediate = op->operands[1].immediate * op->operands[1].sign;\n\n\tdata[l++] = 0x66;\n\tif (op->operands[1].immediate < 128) {\n\t\tdata[l++] = 0x83;\n\t\tdata[l++] = op->operands[0].reg | (0xc0 + op1 + op->operands[0].reg);\n\t} else {\n\t\tif (op->operands[0].reg == X86R_AX) {\n\t\t\tdata[l++] = 0x05 + op1;\n\t\t} else {\n\t\t\tdata[l++] = 0x81;\n\t\t\tdata[l++] = (0xc0 + op1) | op->operands[0].reg;\n\t\t}\n\t}\n\tdata[l++] = immediate;\n\tif (op->operands[1].immediate > 127) {\n\t\tdata[l++] = immediate >> 8;\n\t}\n\n\treturn l;\n}\n\nstatic int process_group_1(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tint modrm = 0;\n\tint mod_byte = 0;\n\tint offset = 0;\n\tint mem_ref = 0;\n\tst32 immediate = 0;\n\n\tif (!op->operands[1].is_good_flag) {\n\t\treturn -1;\n\t}\n\tif (a->bits == 64 && op->operands[0].type & OT_QWORD) {\n\t\tdata[l++] = 0x48;\n\t}\n\tif (!strcmp (op->mnemonic, \"adc\")) {\n\t\tmodrm = 2;\n\t} else if (!strcmp (op->mnemonic, \"add\")) {\n\t\tmodrm = 0;\n\t} else if (!strcmp (op->mnemonic, \"or\")) {\n\t\tmodrm = 1;\n\t} else if (!strcmp (op->mnemonic, \"and\")) {\n\t\tmodrm = 4;\n\t} else if (!strcmp (op->mnemonic, \"xor\")) {\n\t\tmodrm = 6;\n\t} else if (!strcmp (op->mnemonic, \"sbb\")) {\n\t\tmodrm = 3;\n\t} else if (!strcmp (op->mnemonic, \"sub\")) {\n\t\tmodrm = 5;\n\t} else if (!strcmp (op->mnemonic, \"cmp\")) {\n\t\tmodrm = 7;\n\t}\n\timmediate = op->operands[1].immediate * op->operands[1].sign;\n\n\tif (op->operands[0].type & OT_DWORD ||\n\t\top->operands[0].type & OT_QWORD) {\n\t\tif (op->operands[1].immediate < 128) {\n\t\t\tdata[l++] = 0x83;\n\t\t} else if (op->operands[0].reg != X86R_EAX ||\n\t\t           op->operands[0].type & OT_MEMORY) {\n\t\t\tdata[l++] = 0x81;\n\t\t}\n\t} else if (op->operands[0].type & OT_BYTE) {\n\t\tif (op->operands[1].immediate > 255) {\n\t\t\teprintf (\"Error: Immediate exceeds bounds\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tdata[l++] = 0x80;\n\t}\n\tif (op->operands[0].type & OT_MEMORY) {\n\t\toffset = op->operands[0].offset * op->operands[0].offset_sign;\n\t\tif (op->operands[0].offset || op->operands[0].regs[0] == X86R_EBP) {\n\t\t\tmod_byte = 1;\n\t\t}\n\t\tif (offset < ST8_MIN || offset > ST8_MAX) {\n\t\t\tmod_byte = 2;\n\t\t}\n\t\tint reg0 = op->operands[0].regs[0];\n\t\tif (reg0 == -1) {\n\t\t\tmem_ref = 1;\n\t\t\treg0 = 5;\n\t\t\tmod_byte = 0;\n\t\t}\n\t\tdata[l++] = mod_byte << 6 | modrm << 3 | reg0;\n\t\tif (op->operands[0].regs[0] == X86R_ESP) {\n\t\t\tdata[l++] = 0x24;\n\t\t}\n\t\tif (mod_byte || mem_ref) {\n\t\t\tdata[l++] = offset;\n\t\t\tif (mod_byte == 2 || mem_ref) {\n\t\t\t\tdata[l++] = offset >> 8;\n\t\t\t\tdata[l++] = offset >> 16;\n\t\t\t\tdata[l++] = offset >> 24;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (op->operands[1].immediate > 127 && op->operands[0].reg == X86R_EAX) {\n\t\t\tdata[l++] = 5 | modrm << 3 | op->operands[0].reg;\n\t\t} else {\n\t\t\tmod_byte = 3;\n\t\t\tdata[l++] = mod_byte << 6 | modrm << 3 | op->operands[0].reg;\n\t\t}\n\n\t}\n\n\tdata[l++] = immediate;\n\tif ((immediate > 127 || immediate < -128) &&\n\t    ((op->operands[0].type & OT_DWORD) || (op->operands[0].type & OT_QWORD))) {\n\t\tdata[l++] = immediate >> 8;\n\t\tdata[l++] = immediate >> 16;\n\t\tdata[l++] = immediate >> 24;\n\t}\n\treturn l;\n}\n\nstatic int process_group_2(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tint modrm = 0;\n\tint mod_byte = 0;\n\tint reg0 = 0;\n\n\tif (a->bits == 64 && op->operands[0].type & OT_QWORD) { data[l++] = 0x48; }\n\n\tif (!strcmp (op->mnemonic, \"rol\")) {\n\t\tmodrm = 0;\n\t} else if (!strcmp (op->mnemonic, \"ror\")) {\n\t\tmodrm = 1;\n\t} else if (!strcmp (op->mnemonic, \"rcl\")) {\n\t\tmodrm = 2;\n\t} else if (!strcmp (op->mnemonic, \"rcr\")) {\n\t\tmodrm = 3;\n\t} else if (!strcmp (op->mnemonic, \"shl\")) {\n\t\tmodrm = 4;\n\t} else if (!strcmp (op->mnemonic, \"shr\")) {\n\t\tmodrm = 5;\n\t} else if (!strcmp (op->mnemonic, \"sal\")) {\n\t\tmodrm = 6;\n\t} else if (!strcmp (op->mnemonic, \"sar\")) {\n\t\tmodrm = 7;\n\t}\n\n\tst32 immediate = op->operands[1].immediate * op->operands[1].sign;\n\tif (immediate > 255 || immediate < -128) {\n\t\teprintf (\"Error: Immediate exceeds bounds\\n\");\n\t\treturn -1;\n\t}\n\n\tif (op->operands[0].type & (OT_DWORD | OT_QWORD)) {\n\t\tif (op->operands[1].type & (OT_GPREG | OT_BYTE)) {\n\t\t\tdata[l++] = 0xd3;\n\t\t} else if (immediate == 1) {\n\t\t\tdata[l++] = 0xd1;\n\t\t} else {\n\t\t\tdata[l++] = 0xc1;\n\t\t}\n\t} else if (op->operands[0].type & OT_BYTE) {\n\t\tconst Operand *o = &op->operands[0];\n\t\tif (o->regs[0] != -1 && o->regs[1] != -1) {\n\t\t\tdata[l++] = 0xc0;\n\t\t\tdata[l++] = 0x44;\n\t\t\tdata[l++] = o->regs[0]| (o->regs[1]<<3);\n\t\t\tdata[l++] = (ut8)((o->offset*o->offset_sign) & 0xff);\n\t\t\tdata[l++] = immediate;\n\t\t\treturn l;\n\t\t} else if (op->operands[1].type & (OT_GPREG | OT_WORD)) {\n\t\t\tdata[l++] = 0xd2;\n\t\t} else if (immediate == 1) {\n\t\t\tdata[l++] = 0xd0;\n\t\t} else {\n\t\t\tdata[l++] = 0xc0;\n\t\t}\n\t}\n\tif (op->operands[0].type & OT_MEMORY) {\n\t\treg0 = op->operands[0].regs[0];\n\t\tmod_byte = 0;\n\t} else {\n\t\treg0 = op->operands[0].reg;\n\t\tmod_byte = 3;\n\t}\n\tdata[l++] = mod_byte << 6 | modrm << 3 | reg0;\n\tif (immediate != 1 && !(op->operands[1].type & OT_GPREG)) {\n\t\tdata[l++] = immediate;\n\t}\n\treturn l;\n}\n\nstatic int process_1byte_op(RAsm *a, ut8 *data, const Opcode *op, int op1) {\n\tint l = 0;\n\tint mod_byte = 0;\n\tint reg = 0;\n\tint rm = 0;\n\tint rex = 0;\n\tint mem_ref = 0;\n\tst32 offset = 0;\n\tint ebp_reg = 0;\n\n\tif (!op->operands[1].is_good_flag) {\n\t\treturn -1;\n\t}\n\n\tif (op->operands[0].reg == X86R_AL && op->operands[1].type & OT_CONSTANT) {\n\t\tdata[l++] = op1 + 4;\n\t\tdata[l++] = op->operands[1].immediate * op->operands[1].sign;\n\t\treturn l;\n\t}\n\n\tif (a->bits == 64) {\n\t\tif (!(op->operands[0].type & op->operands[1].type)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (a->bits == 64 && ((op->operands[0].type & OT_QWORD) | (op->operands[1].type & OT_QWORD))) {\n\t\tif (op->operands[0].extended) {\n\t\t\t\trex = 1;\n\t\t}\n\t\tif (op->operands[1].extended) {\n\t\t\trex += 4;\n\t\t}\n\t\tdata[l++] = 0x48 | rex;\n\t}\n\n\tif (op->operands[0].type & OT_MEMORY && op->operands[1].type & OT_REGALL) {\n\t\tif (a->bits == 64 && (op->operands[0].type & OT_DWORD) &&\n\t\t    (op->operands[1].type & OT_DWORD)) {\n\t\t\tdata[l++] = 0x67;\n\t\t}\n\t\tif (op->operands[0].type & OT_BYTE && op->operands[1].type & OT_BYTE) {\n\t\t\tdata[l++] = op1;\n\t\t} else if (op->operands[0].type & (OT_DWORD | OT_QWORD) &&\n\t\t\t   op->operands[1].type & (OT_DWORD | OT_QWORD)) {\n\t\t\tdata[l++] = op1 + 0x1;\n\t\t} else {\n\t\t\teprintf (\"Error: mismatched operand sizes\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\treg = op->operands[1].reg;\n\t\trm = op->operands[0].regs[0];\n\t\toffset = op->operands[0].offset * op->operands[0].offset_sign;\n\t\tif (rm == -1) {\n\t\t\trm = 5;\n\t\t\tmem_ref = 1;\n\t\t} else {\n\t\t\tif (offset) {\n\t\t\t\tmod_byte = 1;\n\t\t\t\tif (offset < ST8_MIN || offset > ST8_MAX) {\n\t\t\t\t\tmod_byte = 2;\n\t\t\t\t}\n\t\t\t} else if (op->operands[0].regs[1] != X86R_UNDEFINED) {\n\t\t\t\trm = 4;\n\t\t\t\toffset = op->operands[0].regs[1] << 3;\n\t\t\t}\n\t\t}\n\t} else if (op->operands[0].type & OT_REGALL) {\n\t\tif (op->operands[1].type & OT_MEMORY) {\n\t\t\tif (op->operands[0].type & OT_BYTE && op->operands[1].type & OT_BYTE) {\n\t\t\t\tdata[l++] = op1 + 0x2;\n\t\t\t} else if (op->operands[0].type & (OT_DWORD | OT_QWORD) &&\n\t\t\t\t\t   op->operands[1].type & (OT_DWORD | OT_QWORD)) {\n\t\t\t\tdata[l++] = op1 + 0x3;\n\t\t\t} else {\n\t\t\t\teprintf (\"Error: mismatched operand sizes\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treg = op->operands[0].reg;\n\t\t\trm = op->operands[1].regs[0];\n\n\t\t\tif (op->operands[1].scale[0] > 1) {\n\t\t\t\tif (op->operands[1].regs[1] != X86R_UNDEFINED) {\n\t\t\t\t\tdata[l++] = op->operands[0].reg << 3 | 4;\n\t\t\t\t\tdata[l++] = getsib (op->operands[1].scale[0]) << 6 |\n\t\t\t\t\t\t\t\t\t\top->operands[1].regs[0] << 3 |\n\t\t\t\t\t\t\t\t\t\top->operands[1].regs[1];\n\t\t\t\t\treturn l;\n\t\t\t\t}\n\t\t\t\tdata[l++] = op->operands[0].reg << 3 | 4; // 4 = SIB\n\t\t\t\tdata[l++] = getsib (op->operands[1].scale[0]) << 6 | op->operands[1].regs[0] << 3 | 5;\n\t\t\t\tdata[l++] = op->operands[1].offset * op->operands[1].offset_sign;\n\t\t\t\tdata[l++] = 0;\n\t\t\t\tdata[l++] = 0;\n\t\t\t\tdata[l++] = 0;\n\t\t\t\treturn l;\n\t\t\t}\n\t\t\toffset = op->operands[1].offset * op->operands[1].offset_sign;\n\t\t\tif (offset) {\n\t\t\t\tmod_byte = 1;\n\t\t\t\tif (offset < ST8_MIN || offset > ST8_MAX) {\n\t\t\t\t\tmod_byte = 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else if (op->operands[1].type & OT_REGALL) {\n\t\t\tif (op->operands[0].type & OT_BYTE && op->operands[1].type & OT_BYTE) {\n\t\t\t\tdata[l++] = op1;\n\t\t\t} else if (op->operands[0].type & OT_DWORD && op->operands[1].type & OT_DWORD) {\n\t\t\t\tdata[l++] = op1 + 0x1;\n\t\t\t}\n\t\t\tif (a->bits == 64) {\n\t\t\t\tif (op->operands[0].type & OT_QWORD &&\n\t\t\t\t\top->operands[1].type & OT_QWORD) {\n\t\t\t\t\tdata[l++] = op1 + 0x1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmod_byte = 3;\n\t\t\treg = op->operands[1].reg;\n\t\t\trm = op->operands[0].reg;\n\t\t}\n\t}\n\tif (op->operands[0].regs[0] == X86R_EBP ||\n\t    op->operands[1].regs[0] == X86R_EBP) {\n\t\t\t//reg += 8;\n\t\t\tebp_reg = 1;\n\t}\n\tdata[l++] = mod_byte << 6 | reg << 3 | rm;\n\n\tif (op->operands[0].regs[0] == X86R_ESP ||\n\t    op->operands[1].regs[0] == X86R_ESP) {\n\t\t\tdata[l++] = 0x24;\n\t}\n\tif (offset || mem_ref || ebp_reg) {\n\t//if ((mod_byte > 0 && mod_byte < 3) || mem_ref) {\n\t\tdata[l++] = offset;\n\t\tif (mod_byte == 2 || mem_ref) {\n\t\t\tdata[l++] = offset >> 8;\n\t\t\tdata[l++] = offset >> 16;\n\t\t\tdata[l++] = offset >> 24;\n\t\t}\n\t}\n\treturn l;\n}\n\nstatic int opadc(RAsm *a, ut8 *data, const Opcode *op) {\n\tif (op->operands[1].type & OT_CONSTANT) {\n\t\tif (op->operands[0].type & OT_GPREG &&\n\t\t    op->operands[0].type & OT_WORD) {\n\t\t\treturn process_16bit_group_1 (a, data, op, 0x10);\n\t\t}\n\t\tif (!is_al_reg (&op->operands[0])) {\n\t\t\treturn process_group_1 (a, data, op);\n\t\t}\n\t}\n\treturn process_1byte_op (a, data, op, 0x10);\n}\n\nstatic int opadd(RAsm *a, ut8 *data, const Opcode *op) {\n\tif (op->operands[1].type & OT_CONSTANT) {\n\t\tif (op->operands[0].type & OT_GPREG &&\n\t\t    op->operands[0].type & OT_WORD) {\n\t\t\treturn process_16bit_group_1 (a, data, op, 0x00);\n\t\t}\n\t\tif (!is_al_reg (&op->operands[0])) {\n\t\t\treturn process_group_1 (a, data, op);\n\t\t}\n\t}\n\treturn process_1byte_op (a, data, op, 0x00);\n}\n\nstatic int opand(RAsm *a, ut8 *data, const Opcode *op) {\n\tif (op->operands[1].type & OT_CONSTANT) {\n\t\tif (op->operands[0].type & OT_GPREG &&\n\t\t    op->operands[0].type & OT_WORD) {\n\t\t\treturn process_16bit_group_1 (a, data, op, 0x20);\n\t\t}\n\t\tif (!is_al_reg (&op->operands[0])) {\n\t\t\treturn process_group_1 (a, data, op);\n\t\t}\n\t}\n\treturn process_1byte_op (a, data, op, 0x20);\n}\n\nstatic int opcmp(RAsm *a, ut8 *data, const Opcode *op) {\n\tif (op->operands[1].type & OT_CONSTANT) {\n\t\tif (op->operands[0].type & OT_GPREG &&\n\t\t    op->operands[0].type & OT_WORD) {\n\t\t\treturn process_16bit_group_1 (a, data, op, 0x38);\n\t\t}\n\t\tif (!is_al_reg (&op->operands[0])) {\n\t\t\treturn process_group_1 (a, data, op);\n\t\t}\n\t}\n\treturn process_1byte_op (a, data, op, 0x38);\n}\n\nstatic int opsub(RAsm *a, ut8 *data, const Opcode *op) {\n\tif (op->operands[1].type & OT_CONSTANT) {\n\t\tif (op->operands[0].type & OT_GPREG &&\n\t\t    op->operands[0].type & OT_WORD) {\n\t\t\treturn process_16bit_group_1 (a, data, op, 0x28);\n\t\t}\n\t\tif (!is_al_reg (&op->operands[0])) {\n\t\t\treturn process_group_1 (a, data, op);\n\t\t}\n\t}\n\treturn process_1byte_op (a, data, op, 0x28);\n}\n\nstatic int opor(RAsm *a, ut8 * data, const Opcode *op) {\n\tif (op->operands[1].type & OT_CONSTANT) {\n\t\tif (op->operands[0].type & OT_GPREG &&\n\t\t    op->operands[0].type & OT_WORD) {\n\t\t\treturn process_16bit_group_1 (a, data, op, 0x08);\n\t\t}\n\t\tif (!is_al_reg (&op->operands[0])) {\n\t\t\treturn process_group_1 (a, data, op);\n\t\t}\n\t}\n\treturn process_1byte_op (a, data, op, 0x08);\n}\n\nstatic int opxadd(RAsm *a, ut8 *data, const Opcode *op) {\n\tint i = 0;\n\tif (op->operands_count < 2 ) {\n\t\treturn -1;\n\t}\n\tif (a->bits == 64) {\n\t\tdata[i++] = 0x48;\n\t};\n\tdata[i++] = 0x0f;\n\tif (op->operands[0].type & OT_BYTE &&\n\t   op->operands[1].type & OT_BYTE) {\n\t\tdata[i++] = 0xc0;\n\t} else {\n\t\tdata[i++] = 0xc1;\n\t}\n\tif (op->operands[0].type & OT_REGALL &&\n       op->operands[1].type & OT_REGALL) { // TODO memory modes\n\t\tdata[i] |= 0xc0;\n\t\tdata[i] |= (op->operands[1].reg << 3);\n\t\tdata[i++] |= op->operands[0].reg;\n\t}\n\treturn i;\n}\n\nstatic int opxor(RAsm *a, ut8 * data, const Opcode *op) {\n\tif (op->operands_count < 2) {\n\t\treturn -1;\n\t}\n\tif (op->operands[0].type == 0x80 && op->operands[0].reg == X86R_UNDEFINED) {\n\t\treturn -1;\n\t}\n\tif (op->operands[1].type == 0x80 && op->operands[0].reg == X86R_UNDEFINED) {\n\t\treturn -1;\n\t}\n\tif (op->operands[1].type & OT_CONSTANT) {\n\t\tif (op->operands[0].type & OT_GPREG &&\n\t\t    op->operands[0].type & OT_WORD) {\n\t\t\treturn process_16bit_group_1 (a, data, op, 0x30);\n\t\t}\n\t\tif (!is_al_reg (&op->operands[0])) {\n\t\t\treturn process_group_1 (a, data, op);\n\t\t}\n\t}\n\treturn process_1byte_op (a, data, op, 0x30);\n}\n\nstatic int opnot(RAsm *a, ut8 * data, const Opcode *op) {\n\tint l = 0;\n\n\tif (op->operands[0].reg == X86R_UNDEFINED)  {\n\t\treturn -1;\n\t}\n\n\tint size = op->operands[0].type & ALL_SIZE;\n\tif (op->operands[0].explicit_size) {\n\t\tsize = op->operands[0].dest_size;\n\t}\n\t//rex prefix\n\tint rex = 1 << 6;\n\tbool use_rex = false;\n\tif (size & OT_QWORD) {\t\t\t//W field\n\t\tuse_rex = true;\n\t\trex |= 1 << 3;\n\t}\n\tif (op->operands[0].extended) {\t\t//B field\n\t\tuse_rex = true;\n\t\trex |= 1;\n\t}\n\n\tif (use_rex) {\n\t\tdata[l++] = rex;\n\t}\n\tdata[l++] = 0xf7;\n\tdata[l++] = 0xd0 | op->operands[0].reg;\n\n\treturn l;\n}\n\nstatic int opsbb(RAsm *a, ut8 *data, const Opcode *op) {\n\tif (op->operands[1].type & OT_CONSTANT) {\n\t\tif (op->operands[0].type & OT_GPREG &&\n\t\t    op->operands[0].type & OT_WORD) {\n\t\t\treturn process_16bit_group_1 (a, data, op, 0x18);\n\t\t}\n\t\tif (!is_al_reg (&op->operands[0])) {\n\t\t\treturn process_group_1 (a, data, op);\n\t\t}\n\t}\n\treturn process_1byte_op (a, data, op, 0x18);\n}\n\nstatic int opbswap(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tif (op->operands[0].type & OT_REGALL) {\n\t\tif (op->operands[0].reg == X86R_UNDEFINED) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (op->operands[0].type & OT_QWORD) {\n\t\t\tdata[l++] = 0x48;\n\t\t\tdata[l++] = 0x0f;\n\t\t\tdata[l++] = 0xc8 + op->operands[0].reg;\n\t\t} else if (op->operands[0].type & OT_DWORD) {\n\t\t\tdata[l++] = 0x0f;\n\t\t\tdata[l++] = 0xc8 + op->operands[0].reg;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn l;\n}\n\nstatic int opcall(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tint immediate = 0;\n\tint offset = 0;\n\tint mod = 0;\n\n\tif (op->operands[0].type & OT_GPREG) {\n\t\tif (op->operands[0].reg == X86R_UNDEFINED) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (a->bits == 64 && op->operands[0].extended) {\n\t\t\tdata[l++] = 0x41;\n\t\t}\n\t\tdata[l++] = 0xff;\n\t\tmod = 3;\n\t\tdata[l++] = mod << 6 | 2 << 3 | op->operands[0].reg;\n\t} else if (op->operands[0].type & OT_MEMORY) {\n\t\tif (op->operands[0].regs[0] == X86R_UNDEFINED) {\n\t\t\treturn -1;\n\t\t}\n\t\tdata[l++] = 0xff;\n\t\toffset = op->operands[0].offset * op->operands[0].offset_sign;\n\t\tif (offset) {\n\t\t\tmod = 1;\n\t\t\tif (offset > 127 || offset < -128) {\n\t\t\t\tmod = 2;\n\t\t\t}\n\t\t}\n\t\tdata[l++] = mod << 6 | 2 << 3 | op->operands[0].regs[0];\n\t\tif (mod) {\n\t\t\tdata[l++] = offset;\n\t\t\tif (mod == 2) {\n\t\t\t\tdata[l++] = offset >> 8;\n\t\t\t\tdata[l++] = offset >> 16;\n\t\t\t\tdata[l++] = offset >> 24;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tut64 instr_offset = a->pc;\n\t\tdata[l++] = 0xe8;\n\t\timmediate = op->operands[0].immediate * op->operands[0].sign;\n\t\timmediate -= instr_offset + 5;\n\t\tdata[l++] = immediate;\n\t\tdata[l++] = immediate >> 8;\n\t\tdata[l++] = immediate >> 16;\n\t\tdata[l++] = immediate >> 24;\n\t}\n\treturn l;\n}\n\nstatic int opcmov(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tint mod_byte = 0;\n\tint offset = 0;\n\n\tif (op->operands[0].type & OT_MEMORY ||\n\t    op->operands[1].type & OT_CONSTANT) {\n\t\treturn -1;\n\t}\n\n\tdata[l++] = 0x0f;\n\tchar *cmov = op->mnemonic + 4;\n\tif (!strcmp (cmov, \"o\")) {\n\t\tdata[l++] = 0x40;\n\t} else if (!strcmp (cmov, \"no\")) {\n\t\tdata [l++] = 0x41;\n\t} else if (!strcmp (cmov, \"b\") ||\n\t           !strcmp (cmov, \"c\") ||\n\t           !strcmp (cmov, \"nae\")) {\n\t\tdata [l++] = 0x42;\n\t} else if (!strcmp (cmov, \"ae\") ||\n\t           !strcmp (cmov, \"nb\") ||\n\t\t   !strcmp (cmov, \"nc\")) {\n\t\tdata [l++] = 0x43;\n\t} else if (!strcmp (cmov, \"e\") ||\n                   !strcmp (cmov, \"z\")) {\n\t\tdata [l++] = 0x44;\n\t} else if (!strcmp (cmov, \"ne\") ||\n\t           !strcmp (cmov, \"nz\")) {\n\t\tdata [l++] = 0x45;\n        } else if (!strcmp (cmov, \"be\") ||\n\t           !strcmp (cmov, \"na\")) {\n\t\tdata [l++] = 0x46;\n        } else if (!strcmp (cmov, \"a\") ||\n\t           !strcmp (cmov, \"nbe\")) {\n\t\tdata [l++] = 0x47;\n\t} else if (!strcmp (cmov, \"s\")) {\n\t\tdata [l++] = 0x48;\n        } else if (!strcmp (cmov, \"ns\")) {\n\t\tdata [l++] = 0x49;\n        } else if (!strcmp (cmov, \"p\") ||\n\t           !strcmp (cmov, \"pe\")) {\n\t\tdata [l++] = 0x4a;\n        } else if (!strcmp (cmov, \"np\") ||\n\t           !strcmp (cmov, \"po\")) {\n\t\tdata [l++] = 0x4b;\n        } else if (!strcmp (cmov, \"l\") ||\n\t           !strcmp (cmov, \"nge\")) {\n\t\tdata [l++] = 0x4c;\n        } else if (!strcmp (cmov, \"ge\") ||\n\t           !strcmp (cmov, \"nl\")) {\n\t\tdata [l++] = 0x4d;\n        } else if (!strcmp (cmov, \"le\") ||\n\t           !strcmp (cmov, \"ng\")) {\n\t\tdata [l++] = 0x4e;\n        } else if (!strcmp (cmov, \"g\") ||\n\t           !strcmp (cmov, \"nle\")) {\n\t\tdata [l++] = 0x4f;\n        }\n\n\tif (op->operands[0].type & OT_REGALL) {\n\t\tif (op->operands[1].type & OT_MEMORY) {\n\t\t\tif (op->operands[1].scale[0] > 1) {\n\t\t\t\tif (op->operands[1].regs[1] != X86R_UNDEFINED) {\n\t\t\t\t\tdata[l++] = op->operands[0].reg << 3 | 4;\n\t\t\t\t\tdata[l++] = getsib (op->operands[1].scale[0]) << 6 |\n                                                            op->operands[1].regs[0] << 3 |\n                                                            op->operands[1].regs[1];\n\t\t\t\t\treturn l;\n\t\t\t\t}\n\t\t\t\toffset = op->operands[1].offset * op->operands[1].offset_sign;\n\n\t\t\t\tif (op->operands[1].scale[0] == 2 && offset) {\n\t\t\t\t\tdata[l++] = 0x40 | op->operands[0].reg << 3 | 4; // 4 = SIB\n\t\t\t\t} else {\n\t\t\t\t\tdata[l++] = op->operands[0].reg << 3 | 4; // 4 = SIB\n\t\t\t\t}\n\n\n\t\t\t\tif (op->operands[1].scale[0] == 2) {\n\t\t\t\t\tdata[l++] = op->operands[1].regs[0] << 3 | op->operands[1].regs[0];\n\n\t\t\t\t} else {\n\t\t\t\t\tdata[l++] = getsib (op->operands[1].scale[0]) << 6 |\n                                                            op->operands[1].regs[0] << 3 | 5;\n\t\t\t\t}\n\n\t\t\t\tif (offset) {\n\t\t\t\t\tdata[l++] = offset;\n\t\t\t\t\tif (offset < ST8_MIN || offset > ST8_MAX) {\n\t\t\t\t\t\tdata[l++] = offset >> 8;\n\t\t\t\t\t\tdata[l++] = offset >> 16;\n\t\t\t\t\t\tdata[l++] = offset >> 24;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn l;\n\t\t\t}\n\t\t\tif (op->operands[1].regs[1] != X86R_UNDEFINED) {\n\t\t\t\tdata[l++] = op->operands[0].reg << 3 | 4;\n\t\t\t\tdata[l++] = op->operands[1].regs[1] << 3 | op->operands[1].regs[0];\n\t\t\t\treturn l;\n\t\t\t}\n\n\t\t\toffset = op->operands[1].offset * op->operands[1].offset_sign;\n\t\t\tif (op->operands[1].offset || op->operands[1].regs[0] == X86R_EBP) {\n\t\t\t\tmod_byte = 1;\n\t\t\t}\n\t\t\tif (offset < ST8_MIN || offset > ST8_MAX) {\n\t\t\t\tmod_byte = 2;\n\t\t\t}\n\n\t\t\tdata[l++] = mod_byte << 6 | op->operands[0].reg << 3 | op->operands[1].regs[0];\n\n\t\t\tif (mod_byte) {\n\t\t\t\tdata[l++] = offset;\n\t\t\t\tif (mod_byte == 2) {\n\t\t\t\t\tdata[l++] = offset >> 8;\n\t\t\t\t\tdata[l++] = offset >> 16;\n\t\t\t\t\tdata[l++] = offset >> 24;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tdata[l++] = 0xc0 | op->operands[0].reg << 3 | op->operands[1].reg;\n\t\t}\n\t}\n\n\treturn l;\n}\n\nstatic int opmovx(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tint word = 0;\n\tchar *movx = op->mnemonic + 3;\n\n\tif (!(op->operands[0].type & OT_REGTYPE && op->operands[1].type & OT_MEMORY)) {\n\t\treturn -1;\n\t}\n\tif (op->operands[1].type & OT_WORD) {\n\t\tword = 1;\n\t}\n\n\tdata[l++] = 0x0f;\n\tif (!strcmp (movx, \"zx\")) {\n\t\tdata[l++] = 0xb6 + word;\n\t} else if (!strcmp (movx, \"sx\")) {\n\t\tdata[l++] = 0xbe + word;\n\t}\n\tdata[l++] = op->operands[0].reg << 3 | op->operands[1].regs[0];\n\tif (op->operands[1].regs[0] == X86R_ESP) {\n\t\tdata[l++] = 0x24;\n\t}\n\n\treturn l;\n}\n\nstatic int opaam(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tint immediate = op->operands[0].immediate * op->operands[0].sign;\n\tdata[l++] = 0xd4;\n\tif (immediate == 0) {\n\t\tdata[l++] = 0x0a;\n\t} else if (immediate < 256 && immediate > -129) {\n\t\tdata[l++] = immediate;\n\t}\n\treturn l;\n}\n\nstatic int opdec(RAsm *a, ut8 *data, const Opcode *op) {\n\tif (op->operands[1].type) {\n\t\teprintf (\"Error: Invalid operands\\n\");\n\t\treturn -1;\n\t}\n\tint l = 0;\n\tint size = op->operands[0].type & ALL_SIZE;\n\tif (op->operands[0].explicit_size) {\n\t\tsize = op->operands[0].dest_size;\n\t}\n\n\tif (size & OT_WORD) {\n\t\tdata[l++] = 0x66;\n\t}\n\n\t//rex prefix\n\tint rex = 1 << 6;\n\tbool use_rex = false;\n\tif (size & OT_QWORD) {\t\t\t//W field\n\t\tuse_rex = true;\n\t\trex |= 1 << 3;\n\t}\n\tif (op->operands[0].extended) {\t\t//B field\n\t\tuse_rex = true;\n\t\trex |= 1;\n\t}\n\n\t//opcode selection\n\tint opcode;\n\tif (size & OT_BYTE) {\n\t\topcode = 0xfe;\n\t} else {\n\t\topcode = 0xff;\n\t}\n\n\tif (!(op->operands[0].type & OT_MEMORY)) {\n\t\tif (use_rex) {\n\t\t\tdata[l++] = rex;\n\t\t}\n\t\tif (a->bits > 32 || size & OT_BYTE) {\n\t\t\tdata[l++] = opcode;\n\t\t}\n\t\tif (a->bits == 32 && size & (OT_DWORD | OT_WORD)) {\n\t\t\tdata[l++] = 0x48 | op->operands[0].reg;\n\t\t} else {\n\t\t\tdata[l++] = 0xc8 | op->operands[0].reg;\n\t\t}\n\t\treturn l;\n\t}\n\n\t//modrm and SIB selection\n\tbool rip_rel = op->operands[0].regs[0] == X86R_RIP;\n\tint offset = op->operands[0].offset * op->operands[0].offset_sign;\n\tint modrm = 0;\n\tint mod;\n\tint reg = 0;\n\tint rm;\n\tbool use_sib = false;\n\tint sib;\n\t//mod\n\tif (offset == 0) {\n\t\tmod = 0;\n\t} else if (offset < 128 && offset > -129) {\n\t\tmod = 1;\n\t} else {\n\t\tmod = 2;\n\t}\n\n\tif (op->operands[0].regs[0] & OT_WORD) {\n\t\tif (op->operands[0].regs[0] == X86R_BX && op->operands[0].regs[1] == X86R_SI) {\n\t\t\trm = B0000;\n\t\t} else if (op->operands[0].regs[0] == X86R_BX && op->operands[0].regs[1] == X86R_DI) {\n\t\t\trm = B0001;\n\t\t} else if (op->operands[0].regs[0] == X86R_BP && op->operands[0].regs[1] == X86R_SI) {\n\t\t\trm = B0010;\n\t\t} else if (op->operands[0].regs[0] == X86R_BP && op->operands[0].regs[1] == X86R_DI) {\n\t\t\trm = B0011;\n\t\t} else if (op->operands[0].regs[0] == X86R_SI && op->operands[0].regs[1] == -1) {\n\t\t\trm = B0100;\n\t\t} else if (op->operands[0].regs[0] == X86R_DI && op->operands[0].regs[1] == -1) {\n\t\t\trm = B0101;\n\t\t} else if (op->operands[0].regs[0] == X86R_BX && op->operands[0].regs[1] == -1) {\n\t\t\trm = B0111;\n\t\t} else {\n\t\t\t//TODO allow for displacement only when parser is reworked\n\t\t\treturn -1;\n\t\t}\n\t\tmodrm = (mod << 6) | (reg << 3) | rm;\n\t} else {\n\t\t//rm\n\t\tif (op->operands[0].extended) {\n\t\t\trm = op->operands[0].reg;\n\t\t} else {\n\t\t\trm = op->operands[0].regs[0];\n\t\t}\n\t\t//[epb] alone is illegal, so we need to fake a [ebp+0]\n\t\tif (rm == 5 && mod == 0) {\n\t\t\tmod = 1;\n\t\t}\n\n\t\t//sib\n\t\tint index = op->operands[0].regs[1];\n\t\tint scale = getsib(op->operands[0].scale[1]);\n\t\tif (index != -1) {\n\t\t\tuse_sib = true;\n\t\t\tsib = (scale << 6) | (index << 3) | rm;\n\t\t} else if (rm == 4) {\n\t\t\tuse_sib = true;\n\t\t\tsib = 0x24;\n\t\t}\n\t\tif (use_sib) {\n\t\t\trm = B0100;\n\t\t}\n\t\tif (rip_rel) {\n\t\t\tmodrm = (B0000 << 6) | (reg << 3) | B0101;\n\t\t\tsib = (scale << 6) | (B0100 << 3) | B0101;\n\t\t} else {\n\t\t\tmodrm = (mod << 6) | (reg << 3) | rm;\n\t\t}\n\t\tmodrm |= 1<<3;\n\t}\n\n\tif (use_rex) {\n\t\tdata[l++] = rex;\n\t}\n\tdata[l++] = opcode;\n\tdata[l++] = modrm;\n\tif (use_sib) {\n\t\tdata[l++] = sib;\n\t}\n\t//offset\n\tif (mod == 1) {\n\t\tdata[l++] = offset;\n\t} else if (op->operands[0].regs[0] & OT_WORD && mod == 2) {\n\t\tdata[l++] = offset;\n\t\tdata[l++] = offset >> 8;\n\t} else if (mod == 2 || rip_rel) {\n\t\tdata[l++] = offset;\n\t\tdata[l++] = offset >> 8;\n\t\tdata[l++] = offset >> 16;\n\t\tdata[l++] = offset >> 24;\n\t}\n\n\treturn l;\n}\n\nstatic int opidiv(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\n\tif ( op->operands[0].type & OT_QWORD ) {\n\t\tdata[l++] = 0x48;\n\t}\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_WORD ) {\n\t\t\tdata[l++] = 0x66;\n\t\t}\n\t\tif (op->operands[0].type & OT_BYTE) {\n\t\t\tdata[l++] = 0xf6;\n\t\t} else {\n\t\t\tdata[l++] = 0xf7;\n\t\t}\n\t\tif (op->operands[0].type & OT_MEMORY) {\n\t\t\tdata[l++] = 0x38 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\tdata[l++] = 0xf8 | op->operands[0].reg;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opdiv(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\n\tif ( op->operands[0].type & OT_QWORD ) {\n\t\tdata[l++] = 0x48;\n\t}\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_WORD ) {\n\t\t\tdata[l++] = 0x66;\n\t\t}\n\t\tif (op->operands[0].type & OT_BYTE) {\n\t\t\tdata[l++] = 0xf6;\n\t\t} else {\n\t\t\tdata[l++] = 0xf7;\n\t\t}\n\t\tif (op->operands[0].type & OT_MEMORY) {\n\t\t\tdata[l++] = 0x30 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\tdata[l++] = 0xf0 | op->operands[0].reg;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opimul(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tint offset = 0;\n\tst64 immediate = 0;\n\n\tif ( op->operands[0].type & OT_QWORD ) {\n\t\tdata[l++] = 0x48;\n\t}\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_WORD ) {\n\t\t\tdata[l++] = 0x66;\n\t\t}\n\t\tif (op->operands[0].type & OT_BYTE) {\n\t\t\tdata[l++] = 0xf6;\n\t\t} else {\n\t\t\tdata[l++] = 0xf7;\n\t\t}\n\t\tif (op->operands[0].type & OT_MEMORY) {\n\t\t\tdata[l++] = 0x28 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\tdata[l++] = 0xe8 | op->operands[0].reg;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif (op->operands[0].type & OT_GPREG) {\n\t\t\tif (op->operands[1].type & OT_CONSTANT) {\n\t\t\t\tif (op->operands[1].immediate == -1) {\n\t\t\t\t\teprintf (\"Error: Immediate exceeds max\\n\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\timmediate = op->operands[1].immediate * op->operands[1].sign;\n\t\t\t\tif (op->operands[0].type & OT_GPREG) {\n\t\t\t\t\tif (immediate >= 128) {\n\t\t\t\t\t\tdata[l++] = 0x69;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdata[l++] = 0x6b;\n\t\t\t\t\t}\n\t\t\t\t\tdata[l++] = 0xc0 | op->operands[0].reg << 3 | op->operands[0].reg;\n\t\t\t\t\tdata[l++] = immediate;\n\t\t\t\t\tif (immediate >= 128) {\n\t\t\t\t\t\tdata[l++] = immediate >> 8;\n\t\t\t\t\t\tdata[l++] = immediate >> 16;\n\t\t\t\t\t\tdata[l++] = immediate >> 24;\n\t\t\t\t\t}\n\t\t\t\t\tif (a->bits == 64 && immediate > UT32_MAX) {\n\t\t\t\t\t\tdata[l++] = immediate >> 32;\n\t\t\t\t\t\tdata[l++] = immediate >> 40;\n\t\t\t\t\t\tdata[l++] = immediate >> 48;\n\t\t\t\t\t\tdata[l++] = immediate >> 56;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (op->operands[1].type & OT_MEMORY) {\n\t\t\t\tdata[l++] = 0x0f;\n\t\t\t\tdata[l++] = 0xaf;\n\t\t\t\tif (op->operands[1].regs[0] != X86R_UNDEFINED) {\n\t\t\t\t\toffset = op->operands[1].offset * op->operands[1].offset_sign;\n\t\t\t\t\tif (offset != 0) {\n\t\t\t\t\t\tif (offset >= 128 || offset <= -128) {\n\t\t\t\t\t\t\tdata[l] = 0x80;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdata[l] = 0x40;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdata[l++] |= op->operands[0].reg << 3 | op->operands[1].regs[0];\n\t\t\t\t\t\tdata[l++] = offset;\n\t\t\t\t\t\tif (offset >= 128 || offset <= -128) {\n\t\t\t\t\t\t\tdata[l++] = offset >> 8;\n\t\t\t\t\t\t\tdata[l++] = offset >> 16;\n\t\t\t\t\t\t\tdata[l++] = offset >> 24;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (op->operands[1].regs[1] != X86R_UNDEFINED) {\n\t\t\t\t\t\t\tdata[l++] = 0x04 | op->operands[0].reg << 3;\n\t\t\t\t\t\t\tdata[l++] = op->operands[1].regs[1] << 3 | op->operands[1].regs[0];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdata[l++] = op->operands[0].reg << 3 | op->operands[1].regs[0];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\timmediate = op->operands[1].immediate * op->operands[1].sign;\n\t\t\t\t\tdata[l++] = op->operands[0].reg << 3 | 0x5;\n\t\t\t\t\tdata[l++] = immediate;\n\t\t\t\t\tdata[l++] = immediate >> 8;\n\t\t\t\t\tdata[l++] = immediate >> 16;\n\t\t\t\t\tdata[l++] = immediate >> 24;\n\t\t\t\t}\n\t\t\t} else if (op->operands[1].type & OT_GPREG) {\n\t\t\t\tdata[l++] = 0x0f;\n\t\t\t\tdata[l++] = 0xaf;\n\t\t\t\tdata[l++] = 0xc0 | op->operands[0].reg << 3 | op->operands[1].reg;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 3:\n\t\tif (op->operands[0].type & OT_GPREG &&\n\t\t    (op->operands[1].type & OT_GPREG || op->operands[1].type & OT_MEMORY) &&\n\t\t    op->operands[2].type & OT_CONSTANT) {\n\t\t\t\tdata[l++] = 0x6b;\n\t\t\t\tif (op->operands[1].type & OT_MEMORY) {\n\t\t\t\t\tif (op->operands[1].regs[1] != X86R_UNDEFINED) {\n\t\t\t\t\t\tdata[l++] = 0x04 | op->operands[0].reg << 3;\n\t\t\t\t\t\tdata[l++] = op->operands[1].regs[0] |  op->operands[1].regs[1] << 3;\n\t\t\t\t\t} else {\n\t\t\t\t\t\toffset = op->operands[1].offset * op->operands[1].offset_sign;\n\t\t\t\t\t\tif (offset != 0) {\n\t\t\t\t\t\t\tif (offset >= 128 || offset <= -128) {\n\t\t\t\t\t\t\t\tdata[l] = 0x80;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdata[l] = 0x40;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdata[l++] |= op->operands[0].reg << 3;\n\t\t\t\t\t\t\tdata[l++] = offset;\n\t\t\t\t\t\t\tif (offset >= 128 || offset <= -128) {\n\t\t\t\t\t\t\t\tdata[l++] = offset >> 8;\n\t\t\t\t\t\t\t\tdata[l++] = offset >> 16;\n\t\t\t\t\t\t\t\tdata[l++] = offset >> 24;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdata[l++] = 0x00 | op->operands[0].reg << 3 | op->operands[1].regs[0];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdata[l++] = 0xc0 | op->operands[0].reg << 3 | op->operands[1].reg;\n\t\t\t\t}\n\t\t\t\timmediate = op->operands[2].immediate * op->operands[2].sign;\n\t\t\t\tdata[l++] = immediate;\n\t\t\t\tif (immediate >= 128 || immediate <= -128) {\n\t\t\t\t\tdata[l++] = immediate >> 8;\n\t\t\t\t\tdata[l++] = immediate >> 16;\n\t\t\t\t\tdata[l++] = immediate >> 24;\n\t\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opin(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tst32 immediate = 0;\n\tif (op->operands[1].reg == X86R_DX) {\n\t\tif (op->operands[0].reg == X86R_AL &&\n\t\t\top->operands[0].type & OT_BYTE) {\n\t\t\tdata[l++] = 0xec;\n\t\t\treturn l;\n\t\t}\n\t\tif (op->operands[0].reg == X86R_AX &&\n\t\t\top->operands[0].type & OT_WORD) {\n\t\t\tdata[l++] = 0x66;\n\t\t\tdata[l++] = 0xed;\n\t\t\treturn l;\n\t\t}\n\t\tif (op->operands[0].reg == X86R_EAX &&\n\t\t\top->operands[0].type & OT_DWORD) {\n\t\t\tdata[l++] = 0xed;\n\t\t\treturn l;\n\t\t}\n\t} else if (op->operands[1].type & OT_CONSTANT) {\n\t\timmediate = op->operands[1].immediate * op->operands[1].sign;\n\t\tif (immediate > 255 || immediate < -128) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (op->operands[0].reg == X86R_AL &&\n\t\t\top->operands[0].type & OT_BYTE) {\n\t\t\tdata[l++] = 0xe4;\n\t\t} else if (op->operands[0].reg == X86R_AX &&\n\t\t\t\t   op->operands[0].type & OT_BYTE) {\n\t\t\tdata[l++] = 0x66;\n\t\t\tdata[l++] = 0xe5;\n\t\t} else if (op->operands[0].reg == X86R_EAX &&\n\t\t\t\t   op->operands[0].type & OT_DWORD) {\n\t\t\tdata[l++] = 0xe5;\n\t\t}\n\t\tdata[l++] = immediate;\n\t}\n\treturn l;\n}\n\nstatic int opclflush(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tint offset = 0;\n\tint mod_byte = 0;\n\n\tif (op->operands[0].type & OT_MEMORY) {\n\t\tdata[l++] = 0x0f;\n\t\tdata[l++] = 0xae;\n\t\toffset = op->operands[0].offset * op->operands[0].offset_sign;\n\t\tif (offset) {\n\t\t\tif (offset < ST8_MIN || offset > ST8_MAX) {\n\t\t\t\tmod_byte = 2;\n\t\t\t} else {\n\t\t\t\tmod_byte = 1;\n\t\t\t}\n\t\t}\n\t\tdata[l++] = (mod_byte << 6) | (7 << 3) | op->operands[0].regs[0];\n\t\tif (mod_byte) {\n\t\t\tdata[l++] = offset;\n\t\t\tif (mod_byte == 2) {\n\t\t\t\tdata[l++] = offset >> 8;\n\t\t\t\tdata[l++] = offset >> 16;\n\t\t\t\tdata[l++] = offset >> 24;\n\t\t\t}\n\t\t}\n\t}\n\treturn l;\n}\n\nstatic int opinc(RAsm *a, ut8 *data, const Opcode *op) {\n\tif (op->operands[1].type) {\n\t\teprintf (\"Error: Invalid operands\\n\");\n\t\treturn -1;\n\t}\n\tint l = 0;\n\tint size = op->operands[0].type & ALL_SIZE;\n\tif (op->operands[0].explicit_size) {\n\t\tsize = op->operands[0].dest_size;\n\t}\n\n\tif (size & OT_WORD) {\n\t\tdata[l++] = 0x66;\n\t}\n\n\t//rex prefix\n\tint rex = 1 << 6;\n\tbool use_rex = false;\n\tif (size & OT_QWORD) {\t\t\t//W field\n\t\tuse_rex = true;\n\t\trex |= 1 << 3;\n\t}\n\tif (op->operands[0].extended) {\t\t//B field\n\t\tuse_rex = true;\n\t\trex |= 1;\n\t}\n\n\t//opcode selection\n\tint opcode;\n\tif (size & OT_BYTE) {\n\t\topcode = 0xfe;\n\t} else {\n\t\topcode = 0xff;\n\t}\n\n\tif (!(op->operands[0].type & OT_MEMORY)) {\n\t\tif (use_rex) {\n\t\t\tdata[l++] = rex;\n\t\t}\n\t\tif (a->bits > 32 || size & OT_BYTE) {\n\t\t\tdata[l++] = opcode;\n\t\t}\n\t\tif (a->bits == 32 && size & (OT_DWORD | OT_WORD)) {\n\t\t\tdata[l++] = 0x40 | op->operands[0].reg;\n\t\t} else {\n\t\t\tdata[l++] = 0xc0 | op->operands[0].reg;\n\t\t}\n\t\treturn l;\n\t}\n\n\t//modrm and SIB selection\n\tbool rip_rel = op->operands[0].regs[0] == X86R_RIP;\n\tint offset = op->operands[0].offset * op->operands[0].offset_sign;\n\tint modrm = 0;\n\tint mod;\n\tint reg = 0;\n\tint rm;\n\tbool use_sib = false;\n\tint sib;\n\t//mod\n\tif (offset == 0) {\n\t\tmod = 0;\n\t} else if (offset < 128 && offset > -129) {\n\t\tmod = 1;\n\t} else {\n\t\tmod = 2;\n\t}\n\n\tif (op->operands[0].regs[0] & OT_WORD) {\n\t\tif (op->operands[0].regs[0] == X86R_BX && op->operands[0].regs[1] == X86R_SI) {\n\t\t\trm = B0000;\n\t\t} else if (op->operands[0].regs[0] == X86R_BX && op->operands[0].regs[1] == X86R_DI) {\n\t\t\trm = B0001;\n\t\t} else if (op->operands[0].regs[0] == X86R_BP && op->operands[0].regs[1] == X86R_SI) {\n\t\t\trm = B0010;\n\t\t} else if (op->operands[0].regs[0] == X86R_BP && op->operands[0].regs[1] == X86R_DI) {\n\t\t\trm = B0011;\n\t\t} else if (op->operands[0].regs[0] == X86R_SI && op->operands[0].regs[1] == -1) {\n\t\t\trm = B0100;\n\t\t} else if (op->operands[0].regs[0] == X86R_DI && op->operands[0].regs[1] == -1) {\n\t\t\trm = B0101;\n\t\t} else if (op->operands[0].regs[0] == X86R_BX && op->operands[0].regs[1] == -1) {\n\t\t\trm = B0111;\n\t\t} else {\n\t\t\t//TODO allow for displacement only when parser is reworked\n\t\t\treturn -1;\n\t\t}\n\t\tmodrm = (mod << 6) | (reg << 3) | rm;\n\t} else {\n\t\t//rm\n\t\tif (op->operands[0].extended) {\n\t\t\trm = op->operands[0].reg;\n\t\t} else {\n\t\t\trm = op->operands[0].regs[0];\n\t\t}\n\t\t//[epb] alone is illegal, so we need to fake a [ebp+0]\n\t\tif (rm == 5 && mod == 0) {\n\t\t\tmod = 1;\n\t\t}\n\n\t\t//sib\n\t\tint index = op->operands[0].regs[1];\n\t\tint scale = getsib(op->operands[0].scale[1]);\n\t\tif (index != -1) {\n\t\t\tuse_sib = true;\n\t\t\tsib = (scale << 6) | (index << 3) | rm;\n\t\t} else if (rm == 4) {\n\t\t\tuse_sib = true;\n\t\t\tsib = 0x24;\n\t\t}\n\t\tif (use_sib) {\n\t\t\trm = B0100;\n\t\t}\n\t\tif (rip_rel) {\n\t\t\tmodrm = (B0000 << 6) | (reg << 3) | B0101;\n\t\t\tsib = (scale << 6) | (B0100 << 3) | B0101;\n\t\t} else {\n\t\t\tmodrm = (mod << 6) | (reg << 3) | rm;\n\t\t}\n\t}\n\n\tif (use_rex) {\n\t\tdata[l++] = rex;\n\t}\n\tdata[l++] = opcode;\n\tdata[l++] = modrm;\n\tif (use_sib) {\n\t\tdata[l++] = sib;\n\t}\n\t//offset\n\tif (mod == 1) {\n\t\tdata[l++] = offset;\n\t} else if (op->operands[0].regs[0] & OT_WORD && mod == 2) {\n\t\tdata[l++] = offset;\n\t\tdata[l++] = offset >> 8;\n\t} else if (mod == 2 || rip_rel) {\n\t\tdata[l++] = offset;\n\t\tdata[l++] = offset >> 8;\n\t\tdata[l++] = offset >> 16;\n\t\tdata[l++] = offset >> 24;\n\t}\n\n\treturn l;\n}\n\nstatic int opint(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tif (op->operands[0].type & OT_CONSTANT) {\n\t\tst32 immediate = op->operands[0].immediate * op->operands[0].sign;\n\t\tif (immediate <= 255 && immediate >= -128) {\n\t\t\tdata[l++] = 0xcd;\n\t\t\tdata[l++] = immediate;\n\t\t}\n\t}\n\treturn l;\n}\n\nstatic int opjc(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tbool is_short = op->is_short;\n\t// st64 bigimm = op->operands[0].immediate * op->operands[0].sign;\n\tst64 immediate = op->operands[0].immediate * op->operands[0].sign;\n\tif (is_short && (immediate > ST8_MAX || immediate < ST8_MIN)) {\n\t\treturn l;\n\t}\n\timmediate -= a->pc;\n\tif (immediate > ST32_MAX || immediate < -ST32_MAX) {\n\t\treturn -1;\n\t}\n\tif (!strcmp (op->mnemonic, \"jmp\")) {\n\t\tif (op->operands[0].type & OT_GPREG) {\n\t\t\tdata[l++] = 0xff;\n\t\t\tif (op->operands[0].type & OT_MEMORY) {\n\t\t\t\tif (op->operands[0].offset) {\n\t\t\t\t\tint offset = op->operands[0].offset * op->operands[0].offset_sign;\n\t\t\t\t\tif (offset >= 128 || offset <= -129) {\n\t\t\t\t\t\tdata[l] = 0xa0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdata[l] = 0x60;\n\t\t\t\t\t}\n\t\t\t\t\tdata[l++] |= op->operands[0].regs[0];\n\t\t\t\t\tdata[l++] = offset;\n\t\t\t\t\tif (op->operands[0].offset >= 0x80) {\n\t\t\t\t\t\tdata[l++] = offset >> 8;\n\t\t\t\t\t\tdata[l++] = offset >> 16;\n\t\t\t\t\t\tdata[l++] = offset >> 24;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdata[l++] = 0x20 | op->operands[0].regs[0];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdata[l++] = 0xe0 | op->operands[0].reg;\n\t\t\t}\n\t\t} else {\n\t\t\tif (-0x80 <= (immediate - 2) && (immediate - 2) <= 0x7f) {\n\t\t\t\t/* relative byte address */\n\t\t\t\tdata[l++] = 0xeb;\n\t\t\t\tdata[l++] = immediate - 2;\n\t\t\t} else {\n\t\t\t\t/* relative address */\n\t\t\t\timmediate -= 5;\n\t\t\t\tdata[l++] = 0xe9;\n\t\t\t\tdata[l++] = immediate;\n\t\t\t\tdata[l++] = immediate >> 8;\n\t\t\t\tdata[l++] = immediate >> 16;\n\t\t\t\tdata[l++] = immediate >> 24;\n\t\t\t}\n\t\t}\n\t\treturn l;\n\t}\n\tif (immediate <= 0x81 && immediate > -0x7f) {\n\t\tis_short = true;\n\t}\n\tif (a->bits == 16 && (immediate > 0x81 || immediate < -0x7e)) {\n\t\tdata[l++] = 0x66;\n\t\tis_short = false;\n\t\timmediate --;\n\t}\n\n\tif (!is_short) {data[l++] = 0x0f;}\n\tif (!strcmp (op->mnemonic, \"ja\") ||\n            !strcmp (op->mnemonic, \"jnbe\")) {\n\t\tdata[l++] = 0x87;\n\t} else if (!strcmp (op->mnemonic, \"jae\") ||\n                   !strcmp (op->mnemonic, \"jnb\") ||\n                   !strcmp (op->mnemonic, \"jnc\")) {\n\t\tdata[l++] = 0x83;\n\t} else if (!strcmp (op->mnemonic, \"jz\") ||\n                   !strcmp (op->mnemonic, \"je\")) {\n\t\tdata[l++] = 0x84;\n\t} else if (!strcmp (op->mnemonic, \"jb\") ||\n                   !strcmp (op->mnemonic, \"jnae\") ||\n                   !strcmp (op->mnemonic, \"jc\")) {\n\t\tdata[l++] = 0x82;\n\t} else if (!strcmp (op->mnemonic, \"jbe\") ||\n                   !strcmp (op->mnemonic, \"jna\")) {\n\t\tdata[l++] = 0x86;\n\t} else if (!strcmp (op->mnemonic, \"jg\") ||\n                   !strcmp (op->mnemonic, \"jnle\")) {\n\t\tdata[l++] = 0x8f;\n\t} else if (!strcmp (op->mnemonic, \"jge\") ||\n                   !strcmp (op->mnemonic, \"jnl\")) {\n\t\tdata[l++] = 0x8d;\n\t} else if (!strcmp (op->mnemonic, \"jl\") ||\n                   !strcmp (op->mnemonic, \"jnge\")) {\n\t\tdata[l++] = 0x8c;\n\t} else if (!strcmp (op->mnemonic, \"jle\") ||\n\t           !strcmp (op->mnemonic, \"jng\")) {\n\t\tdata[l++] = 0x8e;\n\t} else if (!strcmp (op->mnemonic, \"jne\") ||\n                   !strcmp (op->mnemonic, \"jnz\")) {\n\t\tdata[l++] = 0x85;\n\t} else if (!strcmp (op->mnemonic, \"jno\")) {\n\t\tdata[l++] = 0x81;\n\t} else if (!strcmp (op->mnemonic, \"jnp\") ||\n                   !strcmp (op->mnemonic, \"jpo\")) {\n\t\tdata[l++] = 0x8b;\n\t} else if (!strcmp (op->mnemonic, \"jns\")) {\n\t\tdata[l++] = 0x89;\n\t} else if (!strcmp (op->mnemonic, \"jo\")) {\n\t\tdata[l++] = 0x80;\n\t} else if (!strcmp (op->mnemonic, \"jp\") ||\n                   !strcmp(op->mnemonic, \"jpe\")) {\n\t\tdata[l++] = 0x8a;\n\t} else if (!strcmp (op->mnemonic, \"js\") ||\n                   !strcmp (op->mnemonic, \"jz\")) {\n\t\tdata[l++] = 0x88;\n\t}\n\tif (is_short) {\n\t\tdata[l-1] -= 0x10;\n\t}\n\n\timmediate -= is_short ? 2 : 6;\n\tdata[l++] = immediate;\n\tif (!is_short) {\n\t\tdata[l++] = immediate >> 8;\n\t\tdata[l++] = immediate >> 16;\n\t\tdata[l++] = immediate >> 24;\n\t}\n\treturn l;\n}\n\nstatic int oplea(RAsm *a, ut8 *data, const Opcode *op){\n\tint l = 0;\n\tint mod = 0;\n\tst32 offset = 0;\n\tint reg = 0;\n\tint rm = 0;\n\tif (op->operands[0].type & OT_REGALL &&\n\t    op->operands[1].type & (OT_MEMORY | OT_CONSTANT)) {\n\t\tif (a->bits == 64) {\n\t\t\tdata[l++] = 0x48;\n\t\t}\n\t\tdata[l++] = 0x8d;\n\t\tif (op->operands[1].regs[0] == X86R_UNDEFINED) {\n\t\t\tint high = 0xff00 & op->operands[1].offset;\n\t\t\tdata[l++] = op->operands[0].reg << 3 | 5;\n\t\t\tdata[l++] = op->operands[1].offset;\n\t\t\tdata[l++] = high >> 8;\n\t\t\tdata[l++] = op->operands[1].offset >> 16;\n\t\t\tdata[l++] = op->operands[1].offset >> 24;\n\t\t\treturn l;\n\t\t} else {\n\t\t\treg = op->operands[0].reg;\n\t\t\trm = op->operands[1].regs[0];\n\n\t\t\toffset = op->operands[1].offset * op->operands[1].offset_sign;\n\t\t\tif (offset != 0 || op->operands[1].regs[0] == X86R_EBP) {\n\t\t\t\tmod = 1;\n\t\t\t\tif (offset >= 128 || offset < -128) {\n\t\t\t\t\tmod = 2;\n\t\t\t\t}\n\t\t\t\tdata[l++] = mod << 6 | reg << 3 | rm;\n\t\t\t\tif (op->operands[1].regs[0] == X86R_ESP) {\n\t\t\t\t\tdata[l++] = 0x24;\n\t\t\t\t}\n\t\t\t\tdata[l++] = offset;\n\t\t\t\tif (mod == 2) {\n\t\t\t\t\tdata[l++] = offset >> 8;\n\t\t\t\t\tdata[l++] = offset >> 16;\n\t\t\t\t\tdata[l++] = offset >> 24;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdata[l++] = op->operands[0].reg << 3 | op->operands[1].regs[0];\n\t\t\t\tif (op->operands[1].regs[0] == X86R_ESP) {\n\t\t\t\t\tdata[l++] = 0x24;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\treturn l;\n}\n\nstatic int oples(RAsm *a, ut8* data, const Opcode *op) {\n\tint l = 0;\n\tint offset = 0;\n\tint mod = 0;\n\n\tif (op->operands[1].type & OT_MEMORY) {\n\t\tdata[l++] = 0xc4;\n\t\tif (op->operands[1].type & OT_GPREG) {\n\t\t\toffset = op->operands[1].offset * op->operands[1].offset_sign;\n\t\t\tif (offset) {\n\t\t\t\tmod = 1;\n\t\t\t\tif (offset > 128 || offset < -128) {\n\t\t\t\t\tmod = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdata[l++] = mod << 6 | op->operands[0].reg << 3 | op->operands[1].regs[0];\n\t\t\tif (mod) {\n\t\t\t\tdata[l++] = offset;\n\t\t\t\tif (mod > 1) {\n\t\t\t\t\tdata[l++] = offset >> 8;\n\t\t\t\t\tdata[l++] = offset >> 16;\n\t\t\t\t\tdata[l++] = offset >> 24;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\toffset = op->operands[1].offset * op->operands[1].offset_sign;\n\t\t\tdata[l++] = 0x05;\n\t\t\tdata[l++] = offset;\n\t\t\tdata[l++] = offset >> 8;\n\t\t\tdata[l++] = offset >> 16;\n\t\t\tdata[l++] = offset >> 24;\n\t\t}\n\t}\n\treturn l;\n}\n\nstatic int opmov(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tst64 offset = 0;\n\tint mod = 0;\n\tint base = 0;\n\tint rex = 0;\n\tut64 immediate = 0;\n\tif (op->operands[1].type & OT_CONSTANT) {\n\t\tif (!op->operands[1].is_good_flag) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (op->operands[1].immediate == -1) {\n\t\t\treturn -1;\n\t\t}\n\t\timmediate = op->operands[1].immediate * op->operands[1].sign;\n\t\tif (op->operands[0].type & OT_GPREG && !(op->operands[0].type & OT_MEMORY)) {\n\t\t\tif (a->bits == 64 && ((op->operands[0].type & OT_QWORD) | (op->operands[1].type & OT_QWORD))) {\n\t\t\t\tif (!(op->operands[1].type & OT_CONSTANT) && op->operands[1].extended) {\n\t\t\t\t\tdata[l++] = 0x49;\n\t\t\t\t} else {\n\t\t\t\t\tdata[l++] = 0x48;\n\t\t\t\t}\n\t\t\t} else if (op->operands[0].extended) {\n\t\t\t\tdata[l++] = 0x41;\n\t\t\t}\n\t\t\tif (op->operands[0].type & OT_WORD) {\n\t\t\t\tif (a->bits > 16) {\n\t\t\t\t\tdata[l++] = 0x66;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (op->operands[0].type & OT_BYTE) {\n\t\t\t\tdata[l++] = 0xb0 | op->operands[0].reg;\n\t\t\t\tdata[l++] = immediate;\n\t\t\t} else {\n\t\t\t\tif (a->bits == 64 &&\n\t\t\t\t\t((op->operands[0].type & OT_QWORD) |\n\t\t\t\t\t(op->operands[1].type & OT_QWORD)) &&\n\t\t\t\t\timmediate < UT32_MAX) {\n\t\t\t\t\t\tdata[l++] = 0xc7;\n\t\t\t\t \t\tdata[l++] = 0xc0 | op->operands[0].reg;\n\t\t\t\t} else {\n\t\t\t\t\tdata[l++] = 0xb8 | op->operands[0].reg;\n\t\t\t\t}\n\t\t\t\tdata[l++] = immediate;\n\t\t\t\tdata[l++] = immediate >> 8;\n\t\t\t\tif (!(op->operands[0].type & OT_WORD)) {\n\t\t\t\t\tdata[l++] = immediate >> 16;\n\t\t\t\t\tdata[l++] = immediate >> 24;\n\t\t\t\t}\n\t\t\t\tif (a->bits == 64 && immediate > UT32_MAX) {\n\t\t\t\t\tdata[l++] = immediate >> 32;\n\t\t\t\t\tdata[l++] = immediate >> 40;\n\t\t\t\t\tdata[l++] = immediate >> 48;\n\t\t\t\t\tdata[l++] = immediate >> 56;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (op->operands[0].type & OT_MEMORY) {\n\t\t\tif (!op->operands[0].explicit_size) {\n\t\t\t\tif (op->operands[0].type & OT_GPREG) {\n\t\t\t\t\t((Opcode *)op)->operands[0].dest_size = op->operands[0].reg_size;\n\t\t\t\t} else {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint dest_bits = 8 * ((op->operands[0].dest_size & ALL_SIZE) >> OPSIZE_SHIFT);\n\t\t\tint reg_bits = 8 * ((op->operands[0].reg_size & ALL_SIZE) >> OPSIZE_SHIFT);\n\t\t\tint offset = op->operands[0].offset * op->operands[0].offset_sign;\n\n\t\t\t//addr_size_override prefix\n\t\t\tbool use_aso = false;\n\t\t\tif (reg_bits < a->bits) {\n\t\t\t\tuse_aso = true;\n\t\t\t}\n\n\t\t\t//op_size_override prefix\n\t\t\tbool use_oso = false;\n\t\t\tif (dest_bits == 16) {\n\t\t\t\tuse_oso = true;\n\t\t\t}\n\n\t\t\tbool rip_rel = op->operands[0].regs[0] == X86R_RIP;\n\n\t\t\t//rex prefix\n\t\t\tint rex = 1 << 6;\n\t\t\tbool use_rex = false;\n\t\t\tif (dest_bits == 64) {\t\t\t//W field\n\t\t\t\tuse_rex = true;\n\t\t\t\trex |= 1 << 3;\n\t\t\t}\n\t\t\tif (op->operands[0].extended) {\t\t//B field\n\t\t\t\tuse_rex = true;\n\t\t\t\trex |= 1;\n\t\t\t}\n\n\t\t\t//opcode selection\n\t\t\tint opcode;\n\t\t\tif (dest_bits == 8) {\n\t\t\t\topcode = 0xc6;\n\t\t\t} else {\n\t\t\t\topcode = 0xc7;\n\t\t\t}\n\n\t\t\t//modrm and SIB selection\n\t\t\tint modrm = 0;\n\t\t\tint mod;\n\t\t\tint reg = 0;\n\t\t\tint rm;\n\t\t\tbool use_sib = false;\n\t\t\tint sib;\n\t\t\t//mod\n\t\t\tif (offset == 0) {\n\t\t\t\tmod = 0;\n\t\t\t} else if (offset < 128 && offset > -129) {\n\t\t\t\tmod = 1;\n\t\t\t} else {\n\t\t\t\tmod = 2;\n\t\t\t}\n\n\t\t\tif (reg_bits == 16) {\n\t\t\t\tif (op->operands[0].regs[0] == X86R_BX && op->operands[0].regs[1] == X86R_SI) {\n\t\t\t\t\trm = B0000;\n\t\t\t\t} else if (op->operands[0].regs[0] == X86R_BX && op->operands[0].regs[1] == X86R_DI) {\n\t\t\t\t\trm = B0001;\n\t\t\t\t} else if (op->operands[0].regs[0] == X86R_BP && op->operands[0].regs[1] == X86R_SI) {\n\t\t\t\t\trm = B0010;\n\t\t\t\t} else if (op->operands[0].regs[0] == X86R_BP && op->operands[0].regs[1] == X86R_DI) {\n\t\t\t\t\trm = B0011;\n\t\t\t\t} else if (op->operands[0].regs[0] == X86R_SI && op->operands[0].regs[1] == -1) {\n\t\t\t\t\trm = B0100;\n\t\t\t\t} else if (op->operands[0].regs[0] == X86R_DI && op->operands[0].regs[1] == -1) {\n\t\t\t\t\trm = B0101;\n\t\t\t\t} else if (op->operands[0].regs[0] == X86R_BX && op->operands[0].regs[1] == -1) {\n\t\t\t\t\trm = B0111;\n\t\t\t\t} else {\n\t\t\t\t\t//TODO allow for displacement only when parser is reworked\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tmodrm = (mod << 6) | (reg << 3) | rm;\n\t\t\t} else {\n\t\t\t\t//rm\n\t\t\t\tif (op->operands[0].extended) {\n\t\t\t\t\trm = op->operands[0].reg;\n\t\t\t\t} else {\n\t\t\t\t\trm = op->operands[0].regs[0];\n\t\t\t\t}\n\t\t\t\t//[epb] alone is illegal, so we need to fake a [ebp+0]\n\t\t\t\tif (rm == 5 && mod == 0) {\n\t\t\t\t\tmod = 1;\n\t\t\t\t}\n\n\t\t\t\t//sib\n\t\t\t\tint index = op->operands[0].regs[1];\n\t\t\t\tint scale = getsib(op->operands[0].scale[1]);\n\t\t\t\tif (index != -1) {\n\t\t\t\t\tuse_sib = true;\n\t\t\t\t\tsib = (scale << 6) | (index << 3) | rm;\n\t\t\t\t} else if (rm == 4) {\n\t\t\t\t\tuse_sib = true;\n\t\t\t\t\tsib = 0x24;\n\t\t\t\t}\n\t\t\t\tif (use_sib) {\n\t\t\t\t\trm = B0100;\n\t\t\t\t}\n\t\t\t\tif (rip_rel) {\n\t\t\t\t\tmodrm = (B0000 << 6) | (reg << 3) | B0101;\n\t\t\t\t\tsib = (scale << 6) | (B0100 << 3) | B0101;\n\t\t\t\t} else {\n\t\t\t\t\tmodrm = (mod << 6) | (reg << 3) | rm;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//build the final result\n\t\t\tif (use_aso) {\n\t\t\t\tdata[l++] = 0x67;\n\t\t\t}\n\t\t\tif (use_oso) {\n\t\t\t\tdata[l++] = 0x66;\n\t\t\t}\n\t\t\tif (use_rex) {\n\t\t\t\tdata[l++] = rex;\n\t\t\t}\n\t\t\tdata[l++] = opcode;\n\t\t\tdata[l++] = modrm;\n\t\t\tif (use_sib) {\n\t\t\t\tdata[l++] = sib;\n\t\t\t}\n\t\t\t//offset\n\t\t\tif (mod == 1) {\n\t\t\t\tdata[l++] = offset;\n\t\t\t} else if (reg_bits == 16 && mod == 2) {\n\t\t\t\tdata[l++] = offset;\n\t\t\t\tdata[l++] = offset >> 8;\n\t\t\t} else if (mod == 2 || rip_rel) {\n\t\t\t\tdata[l++] = offset;\n\t\t\t\tdata[l++] = offset >> 8;\n\t\t\t\tdata[l++] = offset >> 16;\n\t\t\t\tdata[l++] = offset >> 24;\n\t\t\t}\n\t\t\t//immediate\n\t\t\tint byte;\n\t\t\tfor (byte = 0; byte < dest_bits && byte < 32; byte += 8) {\n\t\t\t\tdata[l++] = (immediate >> byte);\n\t\t\t}\n\t\t}\n\t} else if (op->operands[1].type & OT_REGALL &&\n\t\t\t !(op->operands[1].type & OT_MEMORY)) {\n\t\tif (op->operands[0].type & OT_CONSTANT) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (op->operands[0].type & OT_REGTYPE & OT_SEGMENTREG &&\n\t\t    op->operands[1].type & OT_REGTYPE & OT_SEGMENTREG) {\n\t\t\t\treturn -1;\n\t\t}\n\t\t// Check reg sizes match\n\t\tif (op->operands[0].type & OT_REGTYPE && op->operands[1].type & OT_REGTYPE) {\n\t\t\tif (!((op->operands[0].type & ALL_SIZE) &\n\t\t\t(op->operands[1].type & ALL_SIZE))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif (a->bits == 64) {\n\t\t\tif (op->operands[0].extended) {\n\t\t\t\trex = 1;\n\t\t\t}\n\t\t\tif (op->operands[1].extended) {\n\t\t\t\trex += 4;\n\t\t\t}\n\t\t\tif (op->operands[1].type & OT_QWORD) {\n\t\t\t\tif (!(op->operands[0].type & OT_QWORD)) {\n\t\t\t\t\tdata[l++] = 0x67;\n\t\t\t\t\tdata[l++] = 0x48;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (op->operands[1].type & OT_QWORD &&\n\t\t\t\top->operands[0].type & OT_QWORD) {\n\t\t\t\tdata[l++] = 0x48 | rex;\n\t\t\t}\n\t\t\tif (op->operands[1].type & OT_DWORD &&\n\t\t\t\top->operands[0].type & OT_DWORD) {\n\t\t\t\tdata[l++] = 0x40 | rex;\n\t\t\t}\n\t\t} else if (op->operands[0].extended && op->operands[1].extended) {\n\t\t\tdata[l++] = 0x45;\n\t\t}\n\t\toffset = op->operands[0].offset * op->operands[0].offset_sign;\n\t\tif (op->operands[1].type & OT_REGTYPE & OT_SEGMENTREG) {\n\t\t\tdata[l++] = 0x8c;\n\t\t} else {\n\t\t\tif (op->operands[0].type & OT_WORD) {\n\t\t\t\tdata[l++] = 0x66;\n\t\t\t}\n\t\t\tdata[l++] = (op->operands[0].type & OT_BYTE) ? 0x88 : 0x89;\n\t\t}\n\n\t\tif (op->operands[0].scale[0] > 1) {\n\t\t\t\tdata[l++] = op->operands[1].reg << 3 | 4;\n\t\t\t\tdata[l++] = getsib (op->operands[0].scale[0]) << 6 |\n\t\t\t\t\t\t    op->operands[0].regs[0] << 3 | 5;\n\n\t\t\t\tdata[l++] = offset;\n\t\t\t\tdata[l++] = offset >> 8;\n\t\t\t\tdata[l++] = offset >> 16;\n\t\t\t\tdata[l++] = offset >> 24;\n\n\t\t\t\treturn l;\n\t\t\t}\n\n\t\tif (!(op->operands[0].type & OT_MEMORY)) {\n\t\t\tif (op->operands[0].reg == X86R_UNDEFINED ||\n\t\t\t\top->operands[1].reg == X86R_UNDEFINED) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmod = 0x3;\n\t\t\tdata[l++] = mod << 6 | op->operands[1].reg << 3 | op->operands[0].reg;\n\t\t} else if (op->operands[0].regs[0] == X86R_UNDEFINED) {\n\t\t\tdata[l++] = op->operands[1].reg << 3 | 0x5;\n\t\t\tdata[l++] = offset;\n\t\t\tdata[l++] = offset >> 8;\n\t\t\tdata[l++] = offset >> 16;\n\t\t\tdata[l++] = offset >> 24;\n\t\t} else {\n\t\t\tif (op->operands[0].type & OT_MEMORY) {\n\t\t\t\tif (op->operands[0].regs[1] != X86R_UNDEFINED) {\n\t\t\t\t\tdata[l++] = op->operands[1].reg << 3 | 0x4;\n\t\t\t\t\tdata[l++] = op->operands[0].regs[1] << 3 | op->operands[0].regs[0];\n\t\t\t\t\treturn l;\n\t\t\t\t}\n\t\t\t\tif (offset) {\n\t\t\t\t\tmod = (offset > 128 || offset < -129) ? 0x2 : 0x1;\n\t\t\t\t}\n\t\t\t\tif (op->operands[0].regs[0] == X86R_EBP) {\n\t\t\t\t\tmod = 0x2;\n\t\t\t\t}\n\t\t\t\tdata[l++] = mod << 6 | op->operands[1].reg << 3 | op->operands[0].regs[0];\n\t\t\t\tif (op->operands[0].regs[0] == X86R_ESP) {\n\t\t\t\t\tdata[l++] = 0x24;\n\t\t\t\t}\n\t\t\t\tif (offset) {\n\t\t\t\t\tdata[l++] = offset;\n\t\t\t\t}\n\t\t\t\tif (mod == 2) {\n\t\t\t\t\t// warning C4293: '>>': shift count negative or too big, undefined behavior\n\t\t\t\t\tdata[l++] = offset >> 8;\n\t\t\t\t\tdata[l++] = offset >> 16;\n\t\t\t\t\tdata[l++] = offset >> 24;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (op->operands[1].type & OT_MEMORY) {\n\t\tif (op->operands[0].type & OT_MEMORY) {\n\t\t\treturn -1;\n\t\t}\n\t\toffset = op->operands[1].offset * op->operands[1].offset_sign;\n\t\tif (op->operands[0].reg == X86R_EAX && op->operands[1].regs[0] == X86R_UNDEFINED) {\n\t\t\tif (a->bits == 64) {\n\t\t\t\tdata[l++] = 0x48;\n\t\t\t}\n\t\t\tif (op->operands[0].type & OT_BYTE) {\n\t\t\t\tdata[l++] = 0xa0;\n\t\t\t} else {\n\t\t\t\tdata[l++] = 0xa1;\n\t\t\t}\n\t\t\tdata[l++] = offset;\n\t\t\tdata[l++] = offset >> 8;\n\t\t\tdata[l++] = offset >> 16;\n\t\t\tdata[l++] = offset >> 24;\n\t\t\tif (a->bits == 64) {\n\t\t\t\tdata[l++] = offset >> 32;\n\t\t\t\tdata[l++] = offset >> 40;\n\t\t\t\tdata[l++] = offset >> 48;\n\t\t\t\tdata[l++] = offset >> 54;\n\t\t\t}\n\t\t\treturn l;\n\t\t}\n\t\tif (op->operands[0].type & OT_BYTE && a->bits == 64 && op->operands[1].regs[0]) {\n\t\t\tif (op->operands[1].regs[0] >= X86R_R8 &&\n\t\t\t    op->operands[0].reg < 4) {\n\t\t\t\tdata[l++] = 0x41;\n\t\t\t\tdata[l++] = 0x8a;\n\t\t\t\tdata[l++] = op->operands[0].reg << 3 | (op->operands[1].regs[0] - 8);\n\t\t\t\treturn l;\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (op->operands[1].type & OT_REGTYPE & OT_SEGMENTREG) {\n\t\t\tif (op->operands[1].scale[0] == 0) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tdata[l++] = SEG_REG_PREFIXES[op->operands[1].regs[0] % 6];\n\t\t\tdata[l++] = 0x8b;\n\t\t\tdata[l++] = (((ut32)op->operands[0].reg) << 3) | 0x5;\n\t\t\tdata[l++] = offset;\n\t\t\tdata[l++] = offset >> 8;\n\t\t\tdata[l++] = offset >> 16;\n\t\t\tdata[l++] = offset >> 24;\n\t\t\treturn l;\n\t\t}\n\n\t\tif (a->bits == 64) {\n\t\t\tif (op->operands[0].type & OT_QWORD) {\n\t\t\t\tif (!(op->operands[1].type & OT_QWORD)) {\n\t\t\t\t\tif (op->operands[1].regs[0] != -1) {\n\t\t\t\t\t\tdata[l++] = 0x67;\n\t\t\t\t\t}\n\t\t\t\t\tdata[l++] = 0x48;\n\t\t\t\t}\n\t\t\t} else if (op->operands[1].type & OT_DWORD) {\n\t\t\t\tdata[l++] = 0x44;\n\t\t\t} else if (!(op->operands[1].type & OT_QWORD)) {\n\t\t\t\tdata[l++] = 0x67;\n\t\t\t}\n\t\t\tif (op->operands[1].type & OT_QWORD &&\n\t\t\t\top->operands[0].type & OT_QWORD) {\n\t\t\t\tdata[l++] = 0x48;\n\t\t\t}\n\t\t}\n\n\t\tif (op->operands[0].type & OT_WORD) {\n\t\t\tdata[l++] = 0x66;\n\t\t\tdata[l++] = op->operands[1].type & OT_BYTE ? 0x8a : 0x8b;\n\t\t} else {\n\t\t\tdata[l++] = (op->operands[1].type & OT_BYTE ||\n\t\t\t\top->operands[0].type & OT_BYTE) ?\n\t\t\t\t0x8a : 0x8b;\n\t\t}\n\n\t\tif (op->operands[1].regs[0] == X86R_UNDEFINED) {\n\t\t\tif (a->bits == 64) {\n\t\t\t\tdata[l++] = op->operands[0].reg << 3 | 0x4;\n\t\t\t\tdata[l++] = 0x25;\n\t\t\t} else {\n\t\t\t\tdata[l++] = op->operands[0].reg << 3 | 0x5;\n\t\t\t}\n\t\t\tdata[l++] = offset;\n\t\t\tdata[l++] = offset >> 8;\n\t\t\tdata[l++] = offset >> 16;\n\t\t\tdata[l++] = offset >> 24;\n\t\t} else {\n\t\t\tif (op->operands[1].scale[0] > 1) {\n\t\t\t\tdata[l++] = op->operands[0].reg << 3 | 4;\n\n\t\t\t\tif (op->operands[1].scale[0] >= 2) {\n\t\t\t\t\tbase = 5;\n\t\t\t\t}\n\t\t\t\tif (base) {\n\t\t\t\t\tdata[l++] = getsib (op->operands[1].scale[0]) << 6 | op->operands[1].regs[0] << 3 | base;\n\t\t\t\t} else {\n\t\t\t\t\tdata[l++] = getsib (op->operands[1].scale[0]) << 3 | op->operands[1].regs[0];\n\t\t\t\t}\n\t\t\t\tif (offset || base) {\n\t\t\t\t\tdata[l++] = offset;\n\t\t\t\t\tdata[l++] = offset >> 8;\n\t\t\t\t\tdata[l++] = offset >> 16;\n\t\t\t\t\tdata[l++] = offset >> 24;\n\t\t\t\t}\n\t\t\t\treturn l;\n\t\t\t}\n\t\t\tif (op->operands[1].regs[1] != X86R_UNDEFINED) {\n\t\t\t\tdata[l++] = op->operands[0].reg << 3 | 0x4;\n\t\t\t\tdata[l++] = op->operands[1].regs[1] << 3 | op->operands[1].regs[0];\n\t\t\t\treturn l;\n\t\t\t}\n\n\t\t\tif (offset || op->operands[1].regs[0] == X86R_EBP) {\n\t\t\t\tmod = 0x2;\n\t\t\t\tif (op->operands[1].offset > 127) {\n\t\t\t\t\tmod = 0x4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->bits == 64 && offset && op->operands[0].type & OT_QWORD) {\n\t\t\t\tif (op->operands[1].regs[0] == X86R_RIP) {\n\t\t\t\t\tdata[l++] = 0x5;\n\t\t\t\t} else {\n\t\t\t\t\tif (op->operands[1].offset > 127) {\n\t\t\t\t\t\tdata[l++] = 0x80 | op->operands[0].reg << 3 | op->operands[1].regs[0];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdata[l++] = 0x40 | op->operands[1].regs[0];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (op->operands[1].offset > 127) {\n\t\t\t\t\tmod = 0x1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (op->operands[1].regs[0] == X86R_EIP && (op->operands[0].type & OT_DWORD)) {\n\t\t\t\t\tdata[l++] = 0x0d;\n\t\t\t\t} else if (op->operands[1].regs[0] == X86R_RIP && (op->operands[0].type & OT_QWORD)) {\n\t\t\t\t\tdata[l++] = 0x05;\n\t\t\t\t} else {\n\t\t\t\t\tdata[l++] = mod << 5 | op->operands[0].reg << 3 | op->operands[1].regs[0];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (op->operands[1].regs[0] == X86R_ESP) {\n\t\t\t\tdata[l++] = 0x24;\n\t\t\t}\n\t\t\tif (mod >= 0x2) {\n\t\t\t\tdata[l++] = offset;\n\t\t\t\tif (op->operands[1].offset > 128 || op->operands[1].regs[0] == X86R_EIP) {\n\t\t\t\t\tdata[l++] = offset >> 8;\n\t\t\t\t\tdata[l++] = offset >> 16;\n\t\t\t\t\tdata[l++] = offset >> 24;\n\t\t\t\t}\n\t\t\t} else if (a->bits == 64 && (offset || op->operands[1].regs[0] == X86R_RIP)) {\n\t\t\t\tdata[l++] = offset;\n\t\t\t\tif (op->operands[1].offset > 127 || op->operands[1].regs[0] == X86R_RIP) {\n\t\t\t\t\tdata[l++] = offset >> 8;\n\t\t\t\t\tdata[l++] = offset >> 16;\n\t\t\t\t\tdata[l++] = offset >> 24;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn l;\n}\n\nstatic int opmul(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\n\tif ( op->operands[0].type & OT_QWORD ) {\n\t\tdata[l++] = 0x48;\n\t}\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_WORD ) {\n\t\t\tdata[l++] = 0x66;\n\t\t}\n\t\tif (op->operands[0].type & OT_BYTE) {\n\t\t\tdata[l++] = 0xf6;\n\t\t} else {\n\t\t\tdata[l++] = 0xf7;\n\t\t}\n\t\tif (op->operands[0].type & OT_MEMORY) {\n\t\t\tdata[l++] = 0x20 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\tdata[l++] = 0xe0 | op->operands[0].reg;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int oppop(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tint offset = 0;\n\tint mod = 0;\n\tif (op->operands[0].type & OT_GPREG) {\n\t\tif (op->operands[0].type & OT_MEMORY) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (op->operands[0].type & OT_REGTYPE & OT_SEGMENTREG) {\n\t\t\tut8 base;\n\t\t\tif (op->operands[0].reg & X86R_FS) {\n\t\t\t\tdata[l++] = 0x0f;\n\t\t\t\tbase = 0x81;\n\t\t\t} else {\n\t\t\t\tbase = 0x7;\n\t\t\t}\n\t\t\tdata[l++] = base + (8 * op->operands[0].reg);\n\t\t} else {\n\t\t\tut8 base = 0x58;\n\t\t\tdata[l++] = base + op->operands[0].reg;\n\t\t}\n\t} else if (op->operands[0].type & OT_MEMORY) {\n\t\tdata[l++] = 0x8f;\n\t\toffset = op->operands[0].offset * op->operands[0].offset_sign;\n\t\tif (offset != 0 || op->operands[0].regs[0] == X86R_EBP) {\n\t\t\tmod = 1;\n\t\t\tif (offset >= 128 || offset < -128) {\n\t\t\t\tmod = 2;\n\t\t\t}\n\t\t\tdata[l++] = mod << 6 | op->operands[0].regs[0];\n\t\t\tif (op->operands[0].regs[0] == X86R_ESP) {\n\t\t\t\tdata[l++] = 0x24;\n\t\t\t}\n\t\t\tdata[l++] = offset;\n\t\t\tif (mod == 2) {\n\t\t\t\tdata[l++] = offset >> 8;\n\t\t\t\tdata[l++] = offset >> 16;\n\t\t\t\tdata[l++] = offset >> 24;\n\t\t\t}\n\t\t} else {\n\t\t\tdata[l++] = op->operands[0].regs[0];\n\t\t\tif (op->operands[0].regs[0] == X86R_ESP) {\n\t\t\t\tdata[l++] = 0x24;\n\t\t\t}\n\t\t}\n\n\t}\n\treturn l;\n}\n\nstatic int oppush(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tint mod = 0;\n\tst32 immediate = 0;;\n\tst32 offset = 0;\n\tif (op->operands[0].type & OT_GPREG &&\n\t    !(op->operands[0].type & OT_MEMORY)) {\n\t\tif (op->operands[0].type & OT_REGTYPE & OT_SEGMENTREG) {\n\t\t\tut8 base;\n\t\t\tif (op->operands[0].reg & X86R_FS) {\n\t\t\t\tdata[l++] = 0x0f;\n\t\t\t\tbase = 0x80;\n\t\t\t} else {\n\t\t\t\tbase = 0x6;\n\t\t\t}\n\t\t\tdata[l++] = base + (8 * op->operands[0].reg);\n\t\t} else {\n\t\t\tif (op->operands[0].extended && a->bits == 64) {\n\t\t\t\tdata[l++] = 0x41;\n\t\t\t}\n\t\t\tut8 base = 0x50;\n\t\t\tdata[l++] = base + op->operands[0].reg;\n\t\t}\n\t} else if (op->operands[0].type & OT_MEMORY) {\n\t\tdata[l++] = 0xff;\n\t\toffset = op->operands[0].offset * op->operands[0].offset_sign;\n\t\tmod = 0;\n\t\tif (offset != 0 || op->operands[0].regs[0] == X86R_EBP) {\n\t\t\tmod = 1;\n\t\t\tif (offset >= 128 || offset < -128) {\n\t\t\t\tmod = 2;\n\t\t\t}\n\t\t\tdata[l++] = mod << 6 | 6 << 3 | op->operands[0].regs[0];\n\t\t\tif (op->operands[0].regs[0] == X86R_ESP) {\n\t\t\t\tdata[l++] = 0x24;\n\t\t\t}\n\t\t\tdata[l++] = offset;\n\t\t\tif (mod == 2) {\n\t\t\t\tdata[l++] = offset >> 8;\n\t\t\t\tdata[l++] = offset >> 16;\n\t\t\t\tdata[l++] = offset >> 24;\n\t\t\t}\n\t\t} else {\n\t\t\tmod = 3;\n\t\t\tdata[l++] = mod << 4 | op->operands[0].regs[0];\n\t\t\tif (op->operands[0].regs[0] == X86R_ESP) {\n\t\t\t\tdata[l++] = 0x24;\n\t\t\t}\n\t\t}\n\t} else {\n\t\timmediate = op->operands[0].immediate * op->operands[0].sign;\n\t\tif (immediate >= 128 || immediate < -128) {\n\t\t\tdata[l++] = 0x68;\n\t\t\tdata[l++] = immediate;\n\t\t\tdata[l++] = immediate >> 8;\n\t\t\tdata[l++] = immediate >> 16;\n\t\t\tdata[l++] = immediate >> 24;\n\t\t} else {\n\t\t\tdata[l++] = 0x6a;\n\t\t\tdata[l++] = immediate;\n\t\t}\n\t}\n\treturn l;\n}\n\nstatic int opout(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tst32 immediate = 0;\n\tif (op->operands[0].reg == X86R_DX) {\n\t\tif (op->operands[1].reg == X86R_AL && op->operands[1].type & OT_BYTE) {\n\t\t\tdata[l++] = 0xee;\n\t\t\treturn l;\n\t\t}\n\t\tif (op->operands[1].reg == X86R_AX && op->operands[1].type & OT_WORD) {\n\t\t\tdata[l++] = 0x66;\n\t\t\tdata[l++] = 0xef;\n\t\t\treturn l;\n\t\t}\n\t\tif (op->operands[1].reg == X86R_EAX && op->operands[1].type & OT_DWORD) {\n\t\t\tdata[l++] = 0xef;\n\t\t\treturn l;\n\t\t}\n\t} else if (op->operands[0].type & OT_CONSTANT) {\n\t\timmediate = op->operands[0].immediate * op->operands[0].sign;\n\t\tif (immediate > 255 || immediate < -128) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (op->operands[1].reg == X86R_AL && op->operands[1].type & OT_BYTE) {\n\t\t\tdata[l++] = 0xe6;\n\t\t} else if (op->operands[1].reg == X86R_AX && op->operands[1].type & OT_WORD) {\n\t\t\tdata[l++] = 0x66;\n\t\t\tdata[l++] = 0xe7;\n\t\t} else if (op->operands[1].reg == X86R_EAX && op->operands[1].type & OT_DWORD) {\n\t\t\tdata[l++] = 0xe7;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tdata[l++] = immediate;\n\t} else {\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int oploop(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tdata[l++] = 0xe2;\n\tst8 delta = op->operands[0].immediate - a->pc - 2;\n\tdata[l++] = (ut8)delta;\n\treturn l;\n}\n\nstatic int opret(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tint immediate = 0;\n\tif (a->bits == 16) {\n\t\tdata[l++] = 0xc3;\n\t\treturn l;\n\t}\n\tif (op->operands[0].type == OT_UNKNOWN) {\n\t\tdata[l++] = 0xc3;\n\t} else if (op->operands[0].type & (OT_CONSTANT | OT_WORD)) {\n\t\tdata[l++] = 0xc2;\n\t\timmediate = op->operands[0].immediate * op->operands[0].sign;\n\t\tdata[l++] = immediate;\n\t\tdata[l++] = immediate << 8;\n\t}\n\treturn l;\n}\n\nstatic int opretf(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tst32 immediate = 0;\n\tif (op->operands[0].type & OT_CONSTANT) {\n\t\timmediate = op->operands[0].immediate * op->operands[0].sign;\n\t\tdata[l++] = 0xca;\n\t\tdata[l++] = immediate;\n\t\tdata[l++] = immediate >> 8;\n\t} else if (op->operands[0].type == OT_UNKNOWN) {\n\t\tdata[l++] = 0xcb;\n\t}\n\treturn l;\n}\n\nstatic int opstos(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tif (!strcmp(op->mnemonic, \"stosw\")) {\n\t\tdata[l++] = 0x66;\n\t}\n\tif (!strcmp(op->mnemonic, \"stosb\")) {\n\t\tdata[l++] = 0xaa;\n\t} else if (!strcmp(op->mnemonic, \"stosw\")) {\n\t\tdata[l++] = 0xab;\n\t} else if (!strcmp(op->mnemonic, \"stosd\")) {\n\t\tdata[l++] = 0xab;\n\t}\n\treturn l;\n}\n\nstatic int opset(RAsm *a, ut8 *data, const Opcode *op) {\n\tif (!(op->operands[0].type & (OT_GPREG | OT_BYTE))) {return -1;}\n\tint l = 0;\n\tint mod = 0;\n\tint reg = op->operands[0].regs[0];\n\n\tdata[l++] = 0x0f;\n\tif (!strcmp (op->mnemonic, \"seto\")) {\n\t\tdata[l++] = 0x90;\n\t} else if (!strcmp (op->mnemonic, \"setno\")) {\n\t\tdata[l++] = 0x91;\n\t} else if (!strcmp (op->mnemonic, \"setb\") ||\n\t\t\t  !strcmp (op->mnemonic, \"setnae\") ||\n\t\t\t  !strcmp (op->mnemonic, \"setc\")) {\n\t\tdata[l++] = 0x92;\n\t} else if (!strcmp (op->mnemonic, \"setnb\") ||\n\t\t\t   !strcmp (op->mnemonic, \"setae\") ||\n\t\t\t   !strcmp (op->mnemonic, \"setnc\")) {\n\t\tdata[l++] = 0x93;\n\t} else if (!strcmp (op->mnemonic, \"setz\") ||\n\t\t\t   !strcmp (op->mnemonic, \"sete\")) {\n\t\tdata[l++] = 0x94;\n\t} else if (!strcmp (op->mnemonic, \"setnz\") ||\n\t\t\t   !strcmp (op->mnemonic, \"setne\")) {\n\t\tdata[l++] = 0x95;\n\t} else if (!strcmp (op->mnemonic, \"setbe\") ||\n\t\t\t   !strcmp (op->mnemonic, \"setna\")) {\n\t\tdata[l++] = 0x96;\n\t} else if (!strcmp (op->mnemonic, \"setnbe\") ||\n\t\t\t   !strcmp (op->mnemonic, \"seta\")) {\n\t\tdata[l++] = 0x97;\n\t} else if (!strcmp (op->mnemonic, \"sets\")) {\n\t\tdata[l++] = 0x98;\n\t} else if (!strcmp (op->mnemonic, \"setns\")) {\n\t\tdata[l++] = 0x99;\n\t} else if (!strcmp (op->mnemonic, \"setp\") ||\n\t\t\t   !strcmp (op->mnemonic, \"setpe\")) {\n\t\tdata[l++] = 0x9a;\n\t} else if (!strcmp (op->mnemonic, \"setnp\") ||\n\t\t\t   !strcmp (op->mnemonic, \"setpo\")) {\n\t\tdata[l++] = 0x9b;\n\t} else if (!strcmp (op->mnemonic, \"setl\") ||\n\t\t\t   !strcmp (op->mnemonic, \"setnge\")) {\n\t\tdata[l++] = 0x9c;\n\t} else if (!strcmp (op->mnemonic, \"setnl\") ||\n\t\t\t   !strcmp (op->mnemonic, \"setge\")) {\n\t\tdata[l++] = 0x9d;\n\t} else if (!strcmp (op->mnemonic, \"setle\") ||\n\t\t\t   !strcmp (op->mnemonic, \"setng\")) {\n\t\tdata[l++] = 0x9e;\n\t} else if (!strcmp (op->mnemonic, \"setnle\") ||\n\t\t\t   !strcmp (op->mnemonic, \"setg\")) {\n\t\tdata[l++] = 0x9f;\n\t} else {\n\t\treturn -1;\n\t}\n\tif (!(op->operands[0].type & OT_MEMORY)) {\n\t\tmod = 3;\n\t\treg = op->operands[0].reg;\n\t}\n\tdata[l++] = mod << 6 | reg;\n\treturn l;\n}\n\nstatic int optest(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tif (!op->operands[0].type || !op->operands[1].type) {\n\t\teprintf (\"Error: Invalid operands\\n\");\n\t\treturn -1;\n\t}\n\tif (a->bits == 64) {\n\t\tif (op->operands[0].type & OT_MEMORY ||\n\t\t\top->operands[1].type & OT_MEMORY) {\n\t\t\tdata[l++] = 0x67;\n\t\t}\n\t\tif (op->operands[0].type & OT_QWORD &&\n\t\t\top->operands[1].type & OT_QWORD) {\n\t\t\tif (op->operands[0].extended &&\n\t\t\t    op->operands[1].extended) {\n\t\t\t\t\tdata[l++] = 0x4d;\n\t\t\t\t} else {\n\t\t\t\t\tdata[l++] = 0x48;\n\t\t\t\t}\n\t\t}\n\t}\n\n\tif (op->operands[1].type & OT_CONSTANT) {\n\t\tif (op->operands[0].type & OT_BYTE) {\n\t\t\tdata[l++] = 0xf6;\n\t\t\tdata[l++] = op->operands[0].regs[0];\n\t\t\tdata[l++] = op->operands[1].immediate;\n\t\t\treturn l;\n\t\t}\n\t\tdata[l++] = 0xf7;\n\t\tif (op->operands[0].type & OT_MEMORY) {\n\t\t\tdata[l++] = 0x00 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\tdata[l++] = 0xc0 | op->operands[0].reg;\n\t\t}\n\t\tdata[l++] = op->operands[1].immediate >> 0;\n\t\tdata[l++] = op->operands[1].immediate >> 8;\n\t\tdata[l++] = op->operands[1].immediate >> 16;\n\t\tdata[l++] = op->operands[1].immediate >> 24;\n\t\treturn l;\n\t}\n\tif (op->operands[0].type & OT_BYTE ||\n\t\top->operands[1].type & OT_BYTE) {\n\t\tdata[l++] = 0x84;\n\t} else {\n\t\tdata[l++] = 0x85;\n\t}\n\tif (op->operands[0].type & OT_MEMORY) {\n\t\tdata[l++] = 0x00 | op->operands[1].reg << 3 | op->operands[0].regs[0];\n\t} else {\n\t\tif (op->operands[1].type & OT_MEMORY) {\n\t\t\tdata[l++] = 0x00 | op->operands[0].reg << 3 | op->operands[1].regs[0];\n\t\t} else {\n\t\t\tdata[l++] = 0xc0 | op->operands[1].reg << 3 | op->operands[0].reg;\n\t\t}\n\t}\n\treturn l;\n}\n\nstatic int opxchg(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tint mod_byte = 0;\n\tint reg = 0;\n\tint rm = 0;\n\tst32 offset = 0;\n\n\tif (op->operands[0].type & OT_MEMORY || op->operands[1].type & OT_MEMORY) {\n\t\tdata[l++] = 0x87;\n\t\tif (op->operands[0].type & OT_MEMORY) {\n\t\t\trm = op->operands[0].regs[0];\n\t\t\toffset = op->operands[0].offset * op->operands[0].offset_sign;\n\t\t\treg = op->operands[1].reg;\n\t\t} else if (op->operands[1].type & OT_MEMORY) {\n\t\t\trm = op->operands[1].regs[0];\n\t\t\toffset = op->operands[1].offset * op->operands[1].offset_sign;\n\t\t\treg = op->operands[0].reg;\n\t\t}\n\t\tif (offset) {\n\t\t\tmod_byte = 1;\n\t\t\tif (offset < ST8_MIN || offset > ST8_MAX) {\n\t\t\t\tmod_byte = 2;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (op->operands[0].reg == X86R_EAX &&\n\t\t\top->operands[1].type & OT_GPREG) {\n\t\t\tdata[l++] = 0x90 + op->operands[1].reg;\n\t\t\treturn l;\n\t\t} else if (op->operands[1].reg == X86R_EAX &&\n\t\t\t\t   op->operands[0].type & OT_GPREG) {\n\t\t\tdata[l++] = 0x90 + op->operands[0].reg;\n\t\t\treturn l;\n\t\t} else if (op->operands[0].type & OT_GPREG &&\n\t\t\t\t   op->operands[1].type & OT_GPREG) {\n\t\t\tmod_byte = 3;\n\t\t\tdata[l++] = 0x87;\n\t\t\treg = op->operands[1].reg;\n\t\t\trm = op->operands[0].reg;\n\t\t}\n\t}\n\tdata[l++] = mod_byte << 6 | reg << 3 | rm;\n\tif (mod_byte > 0 && mod_byte < 3) {\n\t\tdata[l++] = offset;\n\t\tif (mod_byte == 2) {\n\t\t\tdata[l++] = offset >> 8;\n\t\t\tdata[l++] = offset >> 16;\n\t\t\tdata[l++] = offset >> 24;\n\t\t}\n\t}\n\treturn l;\n}\n\nstatic int opcdqe(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tif (a->bits == 64) {\n\t\tdata[l++] = 0x48;\n\t}\n\tdata[l++] = 0x98;\n\treturn l;\n}\n\nstatic int opfcmov(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tchar* fcmov = op->mnemonic + strlen(\"fcmov\");\n\tswitch (op->operands_count) {\n\tcase 2:\n\t\tif ( op->operands[0].type & OT_FPUREG & ~OT_REGALL && op->operands[0].reg == 0 &&\n\t\t     op->operands[1].type & OT_FPUREG & ~OT_REGALL ) {\n\t\t\tif ( !strcmp( fcmov, \"b\" ) ) {\n\t\t\t\tdata[l++] = 0xda;\n\t\t\t\tdata[l++] = 0xc0 | op->operands[1].reg;\n\t\t\t} else if ( !strcmp( fcmov, \"e\" ) ) {\n\t\t\t\tdata[l++] = 0xda;\n\t\t\t\tdata[l++] = 0xc8 | op->operands[1].reg;\n\t\t\t} else if ( !strcmp( fcmov, \"be\" ) ) {\n\t\t\t\tdata[l++] = 0xda;\n\t\t\t\tdata[l++] = 0xd0 | op->operands[1].reg;\n\t\t\t} else if ( !strcmp( fcmov, \"u\" ) ) {\n\t\t\t\tdata[l++] = 0xda;\n\t\t\t\tdata[l++] = 0xd8 | op->operands[1].reg;\n\t\t\t} else if ( !strcmp( fcmov, \"nb\" ) ) {\n\t\t\t\tdata[l++] = 0xdb;\n\t\t\t\tdata[l++] = 0xc0 | op->operands[1].reg;\n\t\t\t} else if ( !strcmp( fcmov, \"ne\" ) ) {\n\t\t\t\tdata[l++] = 0xdb;\n\t\t\t\tdata[l++] = 0xc8 | op->operands[1].reg;\n\t\t\t} else if ( !strcmp( fcmov, \"nbe\" ) ) {\n\t\t\t\tdata[l++] = 0xdb;\n\t\t\t\tdata[l++] = 0xd0 | op->operands[1].reg;\n\t\t\t} else if ( !strcmp( fcmov, \"nu\" ) ) {\n\t\t\t\tdata[l++] = 0xdb;\n\t\t\t\tdata[l++] = 0xd8 | op->operands[1].reg;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opffree(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif (op->operands[0].type & OT_FPUREG & ~OT_REGALL)  {\n\t\t\tdata[l++] = 0xdd;\n\t\t\tdata[l++] = 0xc0 | op->operands[0].reg;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfrstor(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif (op->operands[0].type & OT_MEMORY) {\n\t\t\tdata[l++] = 0xdd;\n\t\t\tdata[l++] = 0x20 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfxch(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 0:\n\t\tdata[l++] = 0xd9;\n\t\tdata[l++] = 0xc9;\n\t\tbreak;\n\tcase 1:\n\t\tif (op->operands[0].type & OT_FPUREG & ~OT_REGALL) {\n\t\t\tdata[l++] = 0xd9;\n\t\t\tdata[l++] = 0xc8 | op->operands[0].reg;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfucom(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_FPUREG & ~OT_REGALL ) {\n\t\t\tdata[l++] = 0xdd;\n\t\t\tdata[l++] = 0xe0 | op->operands[0].reg;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase 0:\n\t\tdata[l++] = 0xdd;\n\t\tdata[l++] = 0xe1;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfucomp(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_FPUREG & ~OT_REGALL ) {\n\t\t\tdata[l++] = 0xdd;\n\t\t\tdata[l++] = 0xe8 | op->operands[0].reg;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase 0:\n\t\tdata[l++] = 0xdd;\n\t\tdata[l++] = 0xe9;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfaddp(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 2:\n\t\tif ( op->operands[0].type & OT_FPUREG & ~OT_REGALL &&\n\t\t     op->operands[1].type & OT_FPUREG & ~OT_REGALL && op->operands[1].reg == 0 ) {\n\t\t\tdata[l++] = 0xde;\n\t\t\tdata[l++] = 0xc0 | op->operands[0].reg;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase 0:\n\t\tdata[l++] = 0xde;\n\t\tdata[l++] = 0xc1;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfiadd(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tif ( op->operands[0].type & OT_WORD ) {\n\t\t\t\tdata[l++] = 0xde;\n\t\t\t\tdata[l++] = 0x00 | op->operands[0].regs[0];\n\t\t\t} else if ( op->operands[0].type & OT_DWORD ) {\n\t\t\t\tdata[l++] = 0xda;\n\t\t\t\tdata[l++] = 0x00 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfadd(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tif ( op->operands[0].type & OT_QWORD ) {\n\t\t\t\tdata[l++] = 0xdc;\n\t\t\t\tdata[l++] = 0x00 | op->operands[0].regs[0];\n\t\t\t} else if ( op->operands[0].type & OT_DWORD ) {\n\t\t\t\tdata[l++] = 0xd8;\n\t\t\t\tdata[l++] = 0x00 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif ( op->operands[0].type & OT_FPUREG & ~OT_REGALL && op->operands[0].reg == 0 &&\n\t\t     op->operands[1].type & OT_FPUREG & ~OT_REGALL ) {\n\t\t\tdata[l++] = 0xd8;\n\t\t\tdata[l++] = 0xc0 | op->operands[1].reg;\n\t\t} else if ( op->operands[0].type & OT_FPUREG & ~OT_REGALL &&\n\t\t\t    op->operands[1].type & OT_FPUREG & ~OT_REGALL && op->operands[1].reg == 0 ) {\n\t\t\tdata[l++] = 0xdc;\n\t\t\tdata[l++] = 0xc0 | op->operands[0].reg;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opficom(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tif ( op->operands[0].type & OT_WORD ) {\n\t\t\t\tdata[l++] = 0xde;\n\t\t\t\tdata[l++] = 0x10 | op->operands[0].regs[0];\n\t\t\t} else if ( op->operands[0].type & OT_DWORD ) {\n\t\t\t\tdata[l++] = 0xda;\n\t\t\t\tdata[l++] = 0x10 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opficomp(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tif ( op->operands[0].type & OT_WORD ) {\n\t\t\t\tdata[l++] = 0xde;\n\t\t\t\tdata[l++] = 0x18 | op->operands[0].regs[0];\n\t\t\t} else if ( op->operands[0].type & OT_DWORD ) {\n\t\t\t\tdata[l++] = 0xda;\n\t\t\t\tdata[l++] = 0x18 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfild(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tif ( op->operands[0].type & OT_WORD ) {\n\t\t\t\tdata[l++] = 0xdf;\n\t\t\t\tdata[l++] = 0x00 | op->operands[0].regs[0];\n\t\t\t} else if ( op->operands[0].type & OT_DWORD ) {\n\t\t\t\tdata[l++] = 0xdb;\n\t\t\t\tdata[l++] = 0x00 | op->operands[0].regs[0];\n\t\t\t} else if ( op->operands[0].type & OT_QWORD ) {\n\t\t\t\tdata[l++] = 0xdf;\n\t\t\t\tdata[l++] = 0x28 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfldcw(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY &&\n\t\t     op->operands[0].type & OT_WORD ) {\n\t\t\tdata[l++] = 0xd9;\n\t\t\tdata[l++] = 0x28 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfldenv(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tdata[l++] = 0xd9;\n\t\t\tdata[l++] = 0x20 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfbld(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY &&\n\t\t     op->operands[0].type & OT_TBYTE ) {\n\t\t\tdata[l++] = 0xdf;\n\t\t\tdata[l++] = 0x20 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfbstp(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY &&\n\t\t     op->operands[0].type & OT_TBYTE ) {\n\t\t\tdata[l++] = 0xdf;\n\t\t\tdata[l++] = 0x30 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfxrstor(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tdata[l++] = 0x0f;\n\t\t\tdata[l++] = 0xae;\n\t\t\tdata[l++] = 0x08 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfxsave(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tdata[l++] = 0x0f;\n\t\t\tdata[l++] = 0xae;\n\t\t\tdata[l++] = 0x00 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfist(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tif ( op->operands[0].type & OT_WORD ) {\n\t\t\t\tdata[l++] = 0xdf;\n\t\t\t\tdata[l++] = 0x10 | op->operands[0].regs[0];\n\t\t\t} else if ( op->operands[0].type & OT_DWORD ) {\n\t\t\t\tdata[l++] = 0xdb;\n\t\t\t\tdata[l++] = 0x10 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfistp(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tif ( op->operands[0].type & OT_WORD ) {\n\t\t\t\tdata[l++] = 0xdf;\n\t\t\t\tdata[l++] = 0x18 | op->operands[0].regs[0];\n\t\t\t} else if ( op->operands[0].type & OT_DWORD ) {\n\t\t\t\tdata[l++] = 0xdb;\n\t\t\t\tdata[l++] = 0x18 | op->operands[0].regs[0];\n\t\t\t} else if ( op->operands[0].type & OT_QWORD ) {\n\t\t\t\tdata[l++] = 0xdf;\n\t\t\t\tdata[l++] = 0x38 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfisttp(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tif ( op->operands[0].type & OT_WORD ) {\n\t\t\t\tdata[l++] = 0xdf;\n\t\t\t\tdata[l++] = 0x08 | op->operands[0].regs[0];\n\t\t\t} else if ( op->operands[0].type & OT_DWORD ) {\n\t\t\t\tdata[l++] = 0xdb;\n\t\t\t\tdata[l++] = 0x08 | op->operands[0].regs[0];\n\t\t\t} else if ( op->operands[0].type & OT_QWORD ) {\n\t\t\t\tdata[l++] = 0xdd;\n\t\t\t\tdata[l++] = 0x08 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfstenv(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tdata[l++] = 0x9b;\n\t\t\tdata[l++] = 0xd9;\n\t\t\tdata[l++] = 0x30 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfnstenv(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tdata[l++] = 0xd9;\n\t\t\tdata[l++] = 0x30 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfdiv(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tif ( op->operands[0].type & OT_DWORD ) {\n\t\t\t\tdata[l++] = 0xd8;\n\t\t\t\tdata[l++] = 0x30 | op->operands[0].regs[0];\n\t\t\t} else if ( op->operands[0].type & OT_QWORD ) {\n\t\t\t\tdata[l++] = 0xdc;\n\t\t\t\tdata[l++] = 0x30 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif ( op->operands[0].type & OT_FPUREG & ~OT_REGALL && op->operands[0].reg == 0 &&\n\t\t     op->operands[1].type & OT_FPUREG & ~OT_REGALL ) {\n\t\t\tdata[l++] = 0xd8;\n\t\t\tdata[l++] = 0xf0 | op->operands[1].reg;\n\t\t} else if ( op->operands[0].type & OT_FPUREG & ~OT_REGALL &&\n\t\t\t    op->operands[1].type & OT_FPUREG & ~OT_REGALL && op->operands[1].reg == 0 ) {\n\t\t\tdata[l++] = 0xdc;\n\t\t\tdata[l++] = 0xf8 | op->operands[0].reg;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfdivp(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 0:\n\t\tdata[l++] = 0xde;\n\t\tdata[l++] = 0xf9;\n\t\tbreak;\n\tcase 2:\n\t\tif ( op->operands[0].type & OT_FPUREG & ~OT_REGALL &&\n\t\t     op->operands[1].type & OT_FPUREG & ~OT_REGALL && op->operands[1].reg == 0 ) {\n\t\t\tdata[l++] = 0xde;\n\t\t\tdata[l++] = 0xf8 | op->operands[0].reg;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfidiv(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tif ( op->operands[0].type & OT_DWORD ) {\n\t\t\t\tdata[l++] = 0xda;\n\t\t\t\tdata[l++] = 0x30 | op->operands[0].regs[0];\n\t\t\t} else if ( op->operands[0].type & OT_WORD ) {\n\t\t\t\tdata[l++] = 0xde;\n\t\t\t\tdata[l++] = 0x30 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfdivr(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tif ( op->operands[0].type & OT_DWORD ) {\n\t\t\t\tdata[l++] = 0xd8;\n\t\t\t\tdata[l++] = 0x38 | op->operands[0].regs[0];\n\t\t\t} else if ( op->operands[0].type & OT_QWORD ) {\n\t\t\t\tdata[l++] = 0xdc;\n\t\t\t\tdata[l++] = 0x38 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif ( op->operands[0].type & OT_FPUREG & ~OT_REGALL && op->operands[0].reg == 0 &&\n\t\t     op->operands[1].type & OT_FPUREG & ~OT_REGALL ) {\n\t\t\tdata[l++] = 0xd8;\n\t\t\tdata[l++] = 0xf8 | op->operands[1].reg;\n\t\t} else if ( op->operands[0].type & OT_FPUREG & ~OT_REGALL &&\n\t\t\t    op->operands[1].type & OT_FPUREG & ~OT_REGALL && op->operands[1].reg == 0 ) {\n\t\t\tdata[l++] = 0xdc;\n\t\t\tdata[l++] = 0xf0 | op->operands[0].reg;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfdivrp(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 0:\n\t\tdata[l++] = 0xde;\n\t\tdata[l++] = 0xf1;\n\t\tbreak;\n\tcase 2:\n\t\tif ( op->operands[0].type & OT_FPUREG & ~OT_REGALL &&\n\t\t     op->operands[1].type & OT_FPUREG & ~OT_REGALL && op->operands[1].reg == 0 ) {\n\t\t\tdata[l++] = 0xde;\n\t\t\tdata[l++] = 0xf0 | op->operands[0].reg;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfidivr(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tif ( op->operands[0].type & OT_DWORD ) {\n\t\t\t\tdata[l++] = 0xda;\n\t\t\t\tdata[l++] = 0x38 | op->operands[0].regs[0];\n\t\t\t} else if ( op->operands[0].type & OT_WORD ) {\n\t\t\t\tdata[l++] = 0xde;\n\t\t\t\tdata[l++] = 0x38 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfmul(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tif ( op->operands[0].type & OT_DWORD ) {\n\t\t\t\tdata[l++] = 0xd8;\n\t\t\t\tdata[l++] = 0x08 | op->operands[0].regs[0];\n\t\t\t} else if ( op->operands[0].type & OT_QWORD ) {\n\t\t\t\tdata[l++] = 0xdc;\n\t\t\t\tdata[l++] = 0x08 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif ( op->operands[0].type & OT_FPUREG & ~OT_REGALL && op->operands[0].reg == 0 &&\n\t\t     op->operands[1].type & OT_FPUREG & ~OT_REGALL ) {\n\t\t\tdata[l++] = 0xd8;\n\t\t\tdata[l++] = 0xc8 | op->operands[1].reg;\n\t\t} else if ( op->operands[0].type & OT_FPUREG & ~OT_REGALL &&\n\t\t\t    op->operands[1].type & OT_FPUREG & ~OT_REGALL && op->operands[1].reg == 0 ) {\n\t\t\tdata[l++] = 0xdc;\n\t\t\tdata[l++] = 0xc8 | op->operands[0].reg;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfmulp(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 0:\n\t\tdata[l++] = 0xde;\n\t\tdata[l++] = 0xc9;\n\t\tbreak;\n\tcase 2:\n\t\tif ( op->operands[0].type & OT_FPUREG & ~OT_REGALL &&\n\t\t     op->operands[1].type & OT_FPUREG & ~OT_REGALL && op->operands[1].reg == 0 ) {\n\t\t\tdata[l++] = 0xde;\n\t\t\tdata[l++] = 0xc8 | op->operands[0].reg;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfimul(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tif ( op->operands[0].type & OT_DWORD ) {\n\t\t\t\tdata[l++] = 0xda;\n\t\t\t\tdata[l++] = 0x08 | op->operands[0].regs[0];\n\t\t\t} else if ( op->operands[0].type & OT_WORD ) {\n\t\t\t\tdata[l++] = 0xde;\n\t\t\t\tdata[l++] = 0x08 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfsub(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tif ( op->operands[0].type & OT_DWORD ) {\n\t\t\t\tdata[l++] = 0xd8;\n\t\t\t\tdata[l++] = 0x20 | op->operands[0].regs[0];\n\t\t\t} else if ( op->operands[0].type & OT_QWORD ) {\n\t\t\t\tdata[l++] = 0xdc;\n\t\t\t\tdata[l++] = 0x20 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif ( op->operands[0].type & OT_FPUREG & ~OT_REGALL && op->operands[0].reg == 0 &&\n\t\t     op->operands[1].type & OT_FPUREG & ~OT_REGALL ) {\n\t\t\tdata[l++] = 0xd8;\n\t\t\tdata[l++] = 0xe0 | op->operands[1].reg;\n\t\t} else if ( op->operands[0].type & OT_FPUREG & ~OT_REGALL &&\n\t\t\t    op->operands[1].type & OT_FPUREG & ~OT_REGALL && op->operands[1].reg == 0 ) {\n\t\t\tdata[l++] = 0xdc;\n\t\t\tdata[l++] = 0xe8 | op->operands[0].reg;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfsubp(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 0:\n\t\tdata[l++] = 0xde;\n\t\tdata[l++] = 0xe9;\n\t\tbreak;\n\tcase 2:\n\t\tif ( op->operands[0].type & OT_FPUREG & ~OT_REGALL &&\n\t\t     op->operands[1].type & OT_FPUREG & ~OT_REGALL && op->operands[1].reg == 0 ) {\n\t\t\tdata[l++] = 0xde;\n\t\t\tdata[l++] = 0xe8 | op->operands[0].reg;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfisub(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tif ( op->operands[0].type & OT_DWORD ) {\n\t\t\t\tdata[l++] = 0xda;\n\t\t\t\tdata[l++] = 0x20 | op->operands[0].regs[0];\n\t\t\t} else if ( op->operands[0].type & OT_WORD ) {\n\t\t\t\tdata[l++] = 0xde;\n\t\t\t\tdata[l++] = 0x20 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfsubr(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tif ( op->operands[0].type & OT_DWORD ) {\n\t\t\t\tdata[l++] = 0xd8;\n\t\t\t\tdata[l++] = 0x28 | op->operands[0].regs[0];\n\t\t\t} else if ( op->operands[0].type & OT_QWORD ) {\n\t\t\t\tdata[l++] = 0xdc;\n\t\t\t\tdata[l++] = 0x28 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif ( op->operands[0].type & OT_FPUREG & ~OT_REGALL && op->operands[0].reg == 0 &&\n\t\t     op->operands[1].type & OT_FPUREG & ~OT_REGALL ) {\n\t\t\tdata[l++] = 0xd8;\n\t\t\tdata[l++] = 0xe8 | op->operands[1].reg;\n\t\t} else if ( op->operands[0].type & OT_FPUREG & ~OT_REGALL &&\n\t\t\t    op->operands[1].type & OT_FPUREG & ~OT_REGALL && op->operands[1].reg == 0 ) {\n\t\t\tdata[l++] = 0xdc;\n\t\t\tdata[l++] = 0xe0 | op->operands[0].reg;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfsubrp(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 0:\n\t\tdata[l++] = 0xde;\n\t\tdata[l++] = 0xe1;\n\t\tbreak;\n\tcase 2:\n\t\tif ( op->operands[0].type & OT_FPUREG & ~OT_REGALL &&\n\t\t     op->operands[1].type & OT_FPUREG & ~OT_REGALL && op->operands[1].reg == 0 ) {\n\t\t\tdata[l++] = 0xde;\n\t\t\tdata[l++] = 0xe0 | op->operands[0].reg;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfisubr(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tif ( op->operands[0].type & OT_DWORD ) {\n\t\t\t\tdata[l++] = 0xda;\n\t\t\t\tdata[l++] = 0x28 | op->operands[0].regs[0];\n\t\t\t} else if ( op->operands[0].type & OT_WORD ) {\n\t\t\t\tdata[l++] = 0xde;\n\t\t\t\tdata[l++] = 0x28 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfnstcw(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY &&\n\t\t     op->operands[0].type & OT_WORD ) {\n\t\t\tdata[l++] = 0xd9;\n\t\t\tdata[l++] = 0x38 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfstcw(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY &&\n\t\t     op->operands[0].type & OT_WORD ) {\n\t\t\tdata[l++] = 0x9b;\n\t\t\tdata[l++] = 0xd9;\n\t\t\tdata[l++] = 0x38 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfnstsw(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY &&\n\t\t     op->operands[0].type & OT_WORD ) {\n\t\t\tdata[l++] = 0xdd;\n\t\t\tdata[l++] = 0x38 | op->operands[0].regs[0];\n\t\t} else if ( op->operands[0].type & OT_GPREG &&\n\t\t\t    op->operands[0].type & OT_WORD  &&\n\t\t\t    op->operands[0].reg == X86R_AX ) {\n\t\t\tdata[l++] = 0xdf;\n\t\t\tdata[l++] = 0xe0;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfstsw(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY &&\n\t\t     op->operands[0].type & OT_WORD ) {\n\t\t\tdata[l++] = 0x9b;\n\t\t\tdata[l++] = 0xdd;\n\t\t\tdata[l++] = 0x38 | op->operands[0].regs[0];\n\t\t} else if ( op->operands[0].type & OT_GPREG &&\n\t\t\t    op->operands[0].type & OT_WORD  &&\n\t\t\t    op->operands[0].reg == X86R_AX ) {\n\t\t\tdata[l++] = 0x9b;\n\t\t\tdata[l++] = 0xdf;\n\t\t\tdata[l++] = 0xe0;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfnsave(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY &&\n\t\t     op->operands[0].type & OT_DWORD ) {\n\t\t\tdata[l++] = 0xdd;\n\t\t\tdata[l++] = 0x30 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opfsave(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY &&\n\t\t     op->operands[0].type & OT_DWORD ) {\n\t\t\tdata[l++] = 0x9b;\n\t\t\tdata[l++] = 0xdd;\n\t\t\tdata[l++] = 0x30 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int oplldt(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_WORD ) {\n\t\t\tdata[l++] = 0x0f;\n\t\t\tdata[l++] = 0x00;\n\t\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\t\tdata[l++] = 0x10 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\tdata[l++] = 0xd0 | op->operands[0].reg;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int oplmsw(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_WORD ) {\n\t\t\tdata[l++] = 0x0f;\n\t\t\tdata[l++] = 0x01;\n\t\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\t\tdata[l++] = 0x30 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\tdata[l++] = 0xf0 | op->operands[0].reg;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int oplgdt(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tdata[l++] = 0x0f;\n\t\t\tdata[l++] = 0x01;\n\t\t\tdata[l++] = 0x10 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int oplidt(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tdata[l++] = 0x0f;\n\t\t\tdata[l++] = 0x01;\n\t\t\tdata[l++] = 0x18 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opsgdt(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tdata[l++] = 0x0f;\n\t\t\tdata[l++] = 0x01;\n\t\t\tdata[l++] = 0x00 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opstmxcsr(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY &&\n\t\t     op->operands[0].type & OT_DWORD ) {\n\t\t\tdata[l++] = 0x0f;\n\t\t\tdata[l++] = 0xae;\n\t\t\tdata[l++] = 0x18 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opstr(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY &&\n\t\t     op->operands[0].type & OT_WORD ) {\n\t\t\tdata[l++] = 0x0f;\n\t\t\tdata[l++] = 0x00;\n\t\t\tdata[l++] = 0x08 | op->operands[0].regs[0];\n\t\t} else if ( op->operands[0].type & OT_GPREG &&\n\t\t\t    op->operands[0].type & OT_DWORD ) {\n\t\t\tdata[l++] = 0x0f;\n\t\t\tdata[l++] = 0x00;\n\t\t\tdata[l++] = 0xc8 | op->operands[0].reg;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opsidt(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tdata[l++] = 0x0f;\n\t\t\tdata[l++] = 0x01;\n\t\t\tdata[l++] = 0x08 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opsldt(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( a->bits == 64 ) {\n\t\t\tdata[l++] = 0x48;\n\t\t}\n\t\tdata[l++] = 0x0f;\n\t\tdata[l++] = 0x00;\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tdata[l++] = 0x00 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\tdata[l++] = 0xc0 | op->operands[0].reg;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opsmsw(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( a->bits == 64 ) {\n\t\t\tdata[l++] = 0x48;\n\t\t}\n\t\tdata[l++] = 0x0f;\n\t\tdata[l++] = 0x01;\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tdata[l++] = 0x20 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\tdata[l++] = 0xe0 | op->operands[0].reg;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opverr(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_WORD ) {\n\t\t\tdata[l++] = 0x0f;\n\t\t\tdata[l++] = 0x00;\n\t\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\t\tdata[l++] = 0x20 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\tdata[l++] = 0xe0 | op->operands[0].reg;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opverw(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_WORD ) {\n\t\t\tdata[l++] = 0x0f;\n\t\t\tdata[l++] = 0x00;\n\t\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\t\tdata[l++] = 0x28 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\tdata[l++] = 0xe8 | op->operands[0].reg;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opvmclear(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY &&\n\t\t     op->operands[0].type & OT_QWORD\n\t\t     ) {\n\t\t\tdata[l++] = 0x66;\n\t\t\tdata[l++] = 0x0f;\n\t\t\tdata[l++] = 0xc7;\n\t\t\tdata[l++] = 0x30 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opvmon(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY &&\n\t\t     op->operands[0].type & OT_QWORD\n\t\t     ) {\n\t\t\tdata[l++] = 0xf3;\n\t\t\tdata[l++] = 0x0f;\n\t\t\tdata[l++] = 0xc7;\n\t\t\tdata[l++] = 0x30 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opvmptrld(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY &&\n\t\t     op->operands[0].type & OT_QWORD\n\t\t     ) {\n\t\t\tdata[l++] = 0x0f;\n\t\t\tdata[l++] = 0xc7;\n\t\t\tdata[l++] = 0x30 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\nstatic int opvmptrst(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY &&\n\t\t     op->operands[0].type & OT_QWORD\n\t\t     ) {\n\t\t\tdata[l++] = 0x0f;\n\t\t\tdata[l++] = 0xc7;\n\t\t\tdata[l++] = 0x38 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n\ntypedef struct lookup_t {\n\tchar mnemonic[12];\n\tint only_x32;\n\tint (*opdo)(RAsm*, ut8*, const Opcode*);\n\tut64 opcode;\n\tint size;\n} LookupTable;\n\nLookupTable oplookup[] = {\n\t{\"aaa\", 0, NULL, 0x37, 1},\n\t{\"aad\", 0, NULL, 0xd50a, 2},\n\t{\"aam\", 0, opaam, 0},\n\t{\"aas\", 0, NULL, 0x3f, 1},\n\t{\"adc\", 0, &opadc, 0},\n\t{\"add\", 0, &opadd, 0},\n\t{\"adx\", 0, NULL, 0xd4, 1},\n\t{\"amx\", 0, NULL, 0xd5, 1},\n\t{\"and\", 0, &opand, 0},\n\t{\"bswap\", 0, &opbswap, 0},\n\t{\"call\", 0, &opcall, 0},\n\t{\"cbw\", 0, NULL, 0x6698, 2},\n\t{\"cdq\", 0, NULL, 0x99, 1},\n\t{\"cdqe\", 0, &opcdqe, 0},\n\t{\"cwde\", 0, &opcdqe, 0},\n\t{\"clc\", 0, NULL, 0xf8, 1},\n\t{\"cld\", 0, NULL, 0xfc, 1},\n\t{\"clflush\", 0, &opclflush, 0},\n\t{\"clgi\", 0, NULL, 0x0f01dd, 3},\n\t{\"cli\", 0, NULL, 0xfa, 1},\n\t{\"clts\", 0, NULL, 0x0f06, 2},\n\t{\"cmc\", 0, NULL, 0xf5, 1},\n\t{\"cmovo\", 0, &opcmov, 0},\n\t{\"cmovno\", 0, &opcmov, 0},\n\t{\"cmovb\", 0, &opcmov, 0},\n\t{\"cmovc\", 0, &opcmov, 0},\n\t{\"cmovnae\", 0, &opcmov, 0},\n\t{\"cmovae\", 0, &opcmov, 0},\n\t{\"cmovnb\", 0, &opcmov, 0},\n\t{\"cmovnc\", 0, &opcmov, 0},\n\t{\"cmove\", 0, &opcmov, 0},\n\t{\"cmovz\", 0, &opcmov, 0},\n\t{\"cmovne\", 0, &opcmov, 0},\n\t{\"cmovnz\", 0, &opcmov, 0},\n\t{\"cmovbe\", 0, &opcmov, 0},\n\t{\"cmovna\", 0, &opcmov, 0},\n\t{\"cmova\", 0, &opcmov, 0},\n\t{\"cmovnbe\", 0, &opcmov, 0},\n\t{\"cmovne\", 0, &opcmov, 0},\n\t{\"cmovnz\", 0, &opcmov, 0},\n\t{\"cmovs\", 0, &opcmov, 0},\n\t{\"cmovns\", 0, &opcmov, 0},\n\t{\"cmovp\", 0, &opcmov, 0},\n\t{\"cmovpe\", 0, &opcmov, 0},\n\t{\"cmovnp\", 0, &opcmov, 0},\n\t{\"cmovpo\", 0, &opcmov, 0},\n\t{\"cmovl\", 0, &opcmov, 0},\n\t{\"cmovnge\", 0, &opcmov, 0},\n\t{\"cmovge\", 0, &opcmov, 0},\n\t{\"cmovnl\", 0, &opcmov, 0},\n\t{\"cmovle\", 0, &opcmov, 0},\n\t{\"cmovng\", 0, &opcmov, 0},\n\t{\"cmovg\", 0, &opcmov, 0},\n\t{\"cmovnle\", 0, &opcmov, 0},\n\t{\"cmp\", 0, &opcmp, 0},\n\t{\"cmpsb\", 0, NULL, 0xa6, 1},\n\t{\"cmpsd\", 0, NULL, 0xa7, 1},\n\t{\"cmpsw\", 0, NULL, 0x66a7, 2},\n\t{\"cpuid\", 0, NULL, 0x0fa2, 2},\n\t{\"cwd\", 0, NULL, 0x6699, 2},\n\t{\"cwde\", 0, NULL, 0x98, 1},\n\t{\"daa\", 0, NULL, 0x27, 1},\n\t{\"das\", 0, NULL, 0x2f, 1},\n\t{\"dec\", 0, &opdec, 0},\n\t{\"div\", 0, &opdiv, 0},\n\t{\"emms\", 0, NULL, 0x0f77, 2},\n\t{\"f2xm1\", 0, NULL, 0xd9f0, 2},\n\t{\"fabs\", 0, NULL, 0xd9e1, 2},\n\t{\"fadd\", 0, &opfadd, 0},\n\t{\"faddp\", 0, &opfaddp, 0},\n\t{\"fbld\", 0, &opfbld, 0},\n\t{\"fbstp\", 0, &opfbstp, 0},\n\t{\"fchs\", 0, NULL, 0xd9e0, 2},\n\t{\"fclex\", 0, NULL, 0x9bdbe2, 3},\n\t{\"fcmovb\", 0, &opfcmov, 0},\n\t{\"fcmove\", 0, &opfcmov, 0},\n\t{\"fcmovbe\", 0, &opfcmov, 0},\n\t{\"fcmovu\", 0, &opfcmov, 0},\n\t{\"fcmovnb\", 0, &opfcmov, 0},\n\t{\"fcmovne\", 0, &opfcmov, 0},\n\t{\"fcmovnbe\", 0, &opfcmov, 0},\n\t{\"fcmovnu\", 0, &opfcmov, 0},\n\t{\"fcos\", 0, NULL, 0xd9ff, 2},\n\t{\"fdecstp\", 0, NULL, 0xd9f6, 2},\n\t{\"fdiv\", 0, &opfdiv, 0},\n\t{\"fdivp\", 0, &opfdivp, 0},\n\t{\"fdivr\", 0, &opfdivr, 0},\n\t{\"fdivrp\", 0, &opfdivrp, 0},\n\t{\"femms\", 0, NULL, 0x0f0e, 2},\n\t{\"ffree\", 0, &opffree, 0},\n\t{\"fiadd\", 0, &opfiadd, 0},\n\t{\"ficom\", 0, &opficom, 0},\n\t{\"ficomp\", 0, &opficomp, 0},\n\t{\"fidiv\", 0, &opfidiv, 0},\n\t{\"fidivr\", 0, &opfidivr, 0},\n\t{\"fild\", 0, &opfild, 0},\n\t{\"fimul\", 0, &opfimul, 0},\n\t{\"fincstp\", 0, NULL, 0xd9f7, 2},\n\t{\"finit\", 0, NULL, 0x9bdbe3, 3},\n        {\"fist\", 0, &opfist, 0},\n\t{\"fistp\", 0, &opfistp, 0},\n        {\"fisttp\", 0, &opfisttp, 0},\n\t{\"fisub\", 0, &opfisub, 0},\n\t{\"fisubr\", 0, &opfisubr, 0},\n\t{\"fld1\", 0, NULL, 0xd9e8, 2},\n\t{\"fldcw\", 0, &opfldcw, 0},\n\t{\"fldenv\", 0, &opfldenv, 0},\n\t{\"fldl2t\", 0, NULL, 0xd9e9, 2},\n\t{\"fldl2e\", 0, NULL, 0xd9ea, 2},\n\t{\"fldlg2\", 0, NULL, 0xd9ec, 2},\n\t{\"fldln2\", 0, NULL, 0xd9ed, 2},\n\t{\"fldpi\", 0, NULL, 0xd9eb, 2},\n\t{\"fldz\", 0, NULL, 0xd9ee, 2},\n\t{\"fmul\", 0, &opfmul, 0},\n\t{\"fmulp\", 0, &opfmulp, 0},\n\t{\"fnclex\", 0, NULL, 0xdbe2, 2},\n\t{\"fninit\", 0, NULL, 0xdbe3, 2},\n\t{\"fnop\", 0, NULL, 0xd9d0, 2},\n        {\"fnsave\", 0, &opfnsave, 0},\n        {\"fnstcw\", 0, &opfnstcw, 0},\n        {\"fnstenv\", 0, &opfnstenv, 0},\n        {\"fnstsw\", 0, &opfnstsw, 0},\n\t{\"fpatan\", 0, NULL, 0xd9f3, 2},\n\t{\"fprem\", 0, NULL, 0xd9f8, 2},\n\t{\"fprem1\", 0, NULL, 0xd9f5, 2},\n\t{\"fptan\", 0, NULL, 0xd9f2, 2},\n\t{\"frndint\", 0, NULL, 0xd9fc, 2},\n\t{\"frstor\", 0, &opfrstor, 0},\n\t{\"fsave\", 0, &opfsave, 0},\n\t{\"fscale\", 0, NULL, 0xd9fd, 2},\n\t{\"fsin\", 0, NULL, 0xd9fe, 2},\n\t{\"fsincos\", 0, NULL, 0xd9fb, 2},\n\t{\"fsqrt\", 0, NULL, 0xd9fa, 2},\n        {\"fstcw\", 0, &opfstcw, 0},\n        {\"fstenv\", 0, &opfstenv, 0},\n        {\"fstsw\", 0, &opfstsw, 0},\n\t{\"fsub\", 0, &opfsub, 0},\n\t{\"fsubp\", 0, &opfsubp, 0},\n\t{\"fsubr\", 0, &opfsubr, 0},\n\t{\"fsubrp\", 0, &opfsubrp, 0},\n\t{\"ftst\", 0, NULL, 0xd9e4, 2},\n\t{\"fucom\", 0, &opfucom, 0},\n\t{\"fucomp\", 0, &opfucomp, 0},\n\t{\"fucompp\", 0, NULL, 0xdae9, 2},\n\t{\"fwait\", 0, NULL, 0x9b, 1},\n\t{\"fxam\", 0, NULL, 0xd9e5, 2},\n\t{\"fxch\", 0, &opfxch, 0},\n\t{\"fxrstor\", 0, &opfxrstor, 0},\n\t{\"fxsave\", 0, &opfxsave, 0},\n\t{\"fxtract\", 0, NULL, 0xd9f4, 2},\n\t{\"fyl2x\", 0, NULL, 0xd9f1, 2},\n\t{\"fyl2xp1\", 0, NULL, 0xd9f9, 2},\n\t{\"getsec\", 0, NULL, 0x0f37, 2},\n\t{\"hlt\", 0, NULL, 0xf4, 1},\n\t{\"idiv\", 0, &opidiv, 0},\n\t{\"imul\", 0, &opimul, 0},\n\t{\"in\", 0, &opin, 0},\n\t{\"inc\", 0, &opinc, 0},\n\t{\"ins\", 0, NULL, 0x6d, 1},\n\t{\"insb\", 0, NULL, 0x6c, 1},\n\t{\"insd\", 0, NULL, 0x6d, 1},\n\t{\"insw\", 0, NULL, 0x666d, 2},\n\t{\"int\", 0, &opint, 0},\n\t{\"int1\", 0, NULL, 0xf1, 1},\n\t{\"int3\", 0, NULL, 0xcc, 1},\n\t{\"into\", 0, NULL, 0xce, 1},\n\t{\"invd\", 0, NULL, 0x0f08, 2},\n\t{\"iret\", 0, NULL, 0x66cf, 2},\n\t{\"iretd\", 0, NULL, 0xcf, 1},\n\t{\"ja\", 0, &opjc, 0},\n\t{\"jae\", 0, &opjc, 0},\n\t{\"jb\", 0, &opjc, 0},\n\t{\"jbe\", 0, &opjc, 0},\n\t{\"jc\", 0, &opjc, 0},\n\t{\"je\", 0, &opjc, 0},\n\t{\"jg\", 0, &opjc, 0},\n\t{\"jge\", 0, &opjc, 0},\n\t{\"jl\", 0, &opjc, 0},\n\t{\"jle\", 0, &opjc, 0},\n\t{\"jmp\", 0, &opjc, 0},\n\t{\"jna\", 0, &opjc, 0},\n\t{\"jnae\", 0, &opjc, 0},\n\t{\"jnb\", 0, &opjc, 0},\n\t{\"jnbe\", 0, &opjc, 0},\n\t{\"jnc\", 0, &opjc, 0},\n\t{\"jne\", 0, &opjc, 0},\n\t{\"jng\", 0, &opjc, 0},\n\t{\"jnge\", 0, &opjc, 0},\n\t{\"jnl\", 0, &opjc, 0},\n\t{\"jnle\", 0, &opjc, 0},\n\t{\"jno\", 0, &opjc, 0},\n\t{\"jnp\", 0, &opjc, 0},\n\t{\"jns\", 0, &opjc, 0},\n\t{\"jnz\", 0, &opjc, 0},\n\t{\"jo\", 0, &opjc, 0},\n\t{\"jp\", 0, &opjc, 0},\n\t{\"jpe\", 0, &opjc, 0},\n\t{\"jpo\", 0, &opjc, 0},\n\t{\"js\", 0, &opjc, 0},\n\t{\"jz\", 0, &opjc, 0},\n\t{\"lahf\", 0, NULL, 0x9f},\n\t{\"lea\", 0, &oplea, 0},\n\t{\"leave\", 0, NULL, 0xc9, 1},\n\t{\"les\", 0, &oples, 0},\n\t{\"lfence\", 0, NULL, 0x0faee8, 3},\n\t{\"lgdt\", 0, &oplgdt, 0},\n\t{\"lidt\", 0, &oplidt, 0},\n\t{\"lldt\", 0, &oplldt, 0},\n\t{\"lmsw\", 0, &oplmsw, 0},\n\t{\"lodsb\", 0, NULL, 0xac, 1},\n\t{\"lodsd\", 0, NULL, 0xad, 1},\n\t{\"lodsw\", 0, NULL, 0x66ad, 2},\n\t{\"loop\", 0, &oploop, 0},\n\t{\"mfence\", 0, NULL, 0x0faef0, 3},\n\t{\"monitor\", 0, NULL, 0x0f01c8, 3},\n\t{\"mov\", 0, &opmov, 0},\n\t{\"movsb\", 0, NULL, 0xa4, 1},\n\t{\"movsd\", 0, NULL, 0xa5, 1},\n\t{\"movsw\", 0, NULL, 0x66a5, 2},\n\t{\"movzx\", 0, &opmovx, 0},\n\t{\"movsx\", 0, &opmovx, 0},\n\t{\"mul\", 0, &opmul, 0},\n\t{\"mwait\", 0, NULL, 0x0f01c9, 3},\n\t{\"nop\", 0, NULL, 0x90, 1},\n\t{\"not\", 0, &opnot, 0},\n\t{\"or\", 0, &opor, 0},\n\t{\"out\", 0, &opout, 0},\n\t{\"outsb\", 0, NULL, 0x6e, 1},\n\t{\"outs\", 0, NULL, 0x6f, 1},\n\t{\"outsd\", 0, NULL, 0x6f, 1},\n\t{\"outsw\", 0, NULL, 0x666f, 2},\n\t{\"pop\", 0, &oppop, 0},\n\t{\"popa\", 1, NULL, 0x61, 1},\n\t{\"popad\", 1, NULL, 0x61, 1},\n\t{\"popal\", 1, NULL, 0x61, 1},\n\t{\"popaw\", 1, NULL, 0x6661, 2},\n\t{\"popfd\", 1, NULL, 0x9d, 1},\n\t{\"prefetch\", 0, NULL, 0x0f0d, 2},\n\t{\"push\", 0, &oppush, 0},\n\t{\"pusha\", 1, NULL, 0x60, 1},\n\t{\"pushad\", 1, NULL, 0x60, 1},\n\t{\"pushal\", 1, NULL, 0x60, 1},\n\t{\"pushfd\", 0, NULL, 0x9c, 1},\n\t{\"rcl\", 0, &process_group_2, 0},\n\t{\"rcr\", 0, &process_group_2, 0},\n\t{\"rep\", 0, &oprep, 0},\n\t{\"repe\", 0, &oprep, 0},\n\t{\"repne\", 0, &oprep, 0},\n\t{\"repz\", 0, &oprep, 0},\n\t{\"repnz\", 0, &oprep, 0},\n\t{\"rdmsr\", 0, NULL, 0x0f32, 2},\n\t{\"rdpmc\", 0, NULL, 0x0f33, 2},\n\t{\"rdtsc\", 0, NULL, 0x0f31, 2},\n\t{\"rdtscp\", 0, NULL, 0x0f01f9, 3},\n\t{\"ret\", 0, &opret, 0},\n\t{\"retf\", 0, &opretf, 0},\n\t{\"retw\", 0, NULL, 0x66c3, 2},\n\t{\"rol\", 0, &process_group_2, 0},\n\t{\"ror\", 0, &process_group_2, 0},\n\t{\"rsm\", 0, NULL, 0x0faa, 2},\n\t{\"sahf\", 0, NULL, 0x9e, 1},\n\t{\"sal\", 0, &process_group_2, 0},\n\t{\"salc\", 0, NULL, 0xd6, 1},\n\t{\"sar\", 0, &process_group_2, 0},\n\t{\"sbb\", 0, &opsbb, 0},\n\t{\"scasb\", 0, NULL, 0xae, 1},\n\t{\"scasd\", 0, NULL, 0xaf, 1},\n\t{\"scasw\", 0, NULL, 0x66af, 2},\n\t{\"seto\", 0, &opset, 0},\n\t{\"setno\", 0, &opset, 0},\n\t{\"setb\", 0, &opset, 0},\n\t{\"setnae\", 0, &opset, 0},\n\t{\"setc\", 0, &opset, 0},\n\t{\"setnb\", 0, &opset, 0},\n\t{\"setae\", 0, &opset, 0},\n\t{\"setnc\", 0, &opset, 0},\n\t{\"setz\", 0, &opset, 0},\n\t{\"sete\", 0, &opset, 0},\n\t{\"setnz\", 0, &opset, 0},\n\t{\"setne\", 0, &opset, 0},\n\t{\"setbe\", 0, &opset, 0},\n\t{\"setna\", 0, &opset, 0},\n\t{\"setnbe\", 0, &opset, 0},\n\t{\"seta\", 0, &opset, 0},\n\t{\"sets\", 0, &opset, 0},\n\t{\"setns\", 0, &opset, 0},\n\t{\"setp\", 0, &opset, 0},\n\t{\"setpe\", 0, &opset, 0},\n\t{\"setnp\", 0, &opset, 0},\n\t{\"setpo\", 0, &opset, 0},\n\t{\"setl\", 0, &opset, 0},\n\t{\"setnge\", 0, &opset, 0},\n\t{\"setnl\", 0, &opset, 0},\n\t{\"setge\", 0, &opset, 0},\n\t{\"setle\", 0, &opset, 0},\n\t{\"setng\", 0, &opset, 0},\n\t{\"setnle\", 0, &opset, 0},\n\t{\"setg\", 0, &opset, 0},\n\t{\"sfence\", 0, NULL, 0x0faef8, 3},\n\t{\"sgdt\", 0, &opsgdt, 0},\n\t{\"shl\", 0, &process_group_2, 0},\n\t{\"shr\", 0, &process_group_2, 0},\n\t{\"sidt\", 0, &opsidt, 0},\n\t{\"sldt\", 0, &opsldt, 0},\n\t{\"smsw\", 0, &opsmsw, 0},\n\t{\"stc\", 0, NULL, 0xf9, 1},\n\t{\"std\", 0, NULL, 0xfd, 1},\n\t{\"stgi\", 0, NULL, 0x0f01dc, 3},\n\t{\"sti\", 0, NULL, 0xfb, 1},\n\t{\"stmxcsr\", 0, &opstmxcsr, 0},\n\t{\"stosb\", 0, &opstos, 0},\n\t{\"stosd\", 0, &opstos, 0},\n\t{\"stosw\", 0, &opstos, 0},\n\t{\"str\", 0, &opstr, 0},\n\t{\"sub\", 0, &opsub, 0},\n\t{\"swapgs\", 0, NULL, 0x0f1ff8, 3},\n\t{\"syscall\", 0, NULL, 0x0f05, 2},\n\t{\"sysenter\", 0, NULL, 0x0f34, 2},\n\t{\"sysexit\", 0, NULL, 0x0f35, 2},\n\t{\"sysret\", 0, NULL, 0x0f07, 2},\n\t{\"ud2\", 0, NULL, 0x0f0b, 2},\n\t{\"verr\", 0, &opverr, 0},\n\t{\"verw\", 0, &opverw, 0},\n\t{\"vmcall\", 0, NULL, 0x0f01c1, 3},\n\t{\"vmclear\", 0, &opvmclear, 0},\n\t{\"vmlaunch\", 0, NULL, 0x0f01c2, 3},\n\t{\"vmload\", 0, NULL, 0x0f01da, 3},\n\t{\"vmmcall\", 0, NULL, 0x0f01d9, 3},\n\t{\"vmptrld\", 0, &opvmptrld, 0},\n\t{\"vmptrst\", 0, &opvmptrst, 0},\n\t{\"vmresume\", 0, NULL, 0x0f01c3, 3},\n\t{\"vmrun\", 0, NULL, 0x0f01d8, 3},\n\t{\"vmsave\", 0, NULL, 0x0f01db, 3},\n\t{\"vmxoff\", 0, NULL, 0x0f01c4, 3},\n\t{\"vmxon\", 0, &opvmon, 0},\n\t{\"vzeroall\", 0, NULL, 0xc5fc77, 3},\n\t{\"vzeroupper\", 0, NULL, 0xc5f877, 3},\n\t{\"wait\", 0, NULL, 0x9b, 1},\n\t{\"wbinvd\", 0, NULL, 0x0f09, 2},\n\t{\"wrmsr\", 0, NULL, 0x0f30, 2},\n\t{\"xadd\", 0, &opxadd, 0},\n\t{\"xchg\", 0, &opxchg, 0},\n\t{\"xgetbv\", 0, NULL, 0x0f01d0, 3},\n\t{\"xlatb\", 0, NULL, 0xd7, 1},\n\t{\"xor\", 0, &opxor, 0},\n\t{\"xsetbv\", 0, NULL, 0x0f01d1, 3},\n\t{\"test\", 0, &optest, 0},\n\t{\"null\", 0, NULL, 0, 0}\n};\n\nstatic x86newTokenType getToken(const char *str, size_t *begin, size_t *end) {\n\tif (*begin > strlen (str)) {\n\t\treturn TT_EOF;\n\t}\n\t// Skip whitespace\n\twhile (begin && str[*begin] && isspace ((ut8)str[*begin])) {\n\t\t++(*begin);\n\t}\n\n\tif (!str[*begin]) {                // null byte\n\t\t*end = *begin;\n\t\treturn TT_EOF;\n\t}\n\tif (isalpha ((ut8)str[*begin])) {   // word token\n\t\t*end = *begin;\n\t\twhile (end && str[*end] && isalnum ((ut8)str[*end])) {\n\t\t\t++(*end);\n\t\t}\n\t\treturn TT_WORD;\n\t}\n\tif (isdigit ((ut8)str[*begin])) {   // number token\n\t\t*end = *begin;\n\t\twhile (end && isalnum ((ut8)str[*end])) {     // accept alphanumeric characters, because hex.\n\t\t\t++(*end);\n\t\t}\n\t\treturn TT_NUMBER;\n\t} else {                             // special character: [, ], +, *, ...\n\t\t*end = *begin + 1;\n\t\treturn TT_SPECIAL;\n\t}\n}\n\n/**\n * Get the register at position pos in str. Increase pos afterwards.\n */\nstatic Register parseReg(RAsm *a, const char *str, size_t *pos, ut32 *type) {\n\tint i;\n\t// Must be the same order as in enum register_t\n\tconst char *regs[] = { \"eax\", \"ecx\", \"edx\", \"ebx\", \"esp\", \"ebp\", \"esi\", \"edi\", \"eip\", NULL };\n\tconst char *regsext[] = { \"r8d\", \"r9d\", \"r10d\", \"r11d\", \"r12d\", \"r13d\", \"r14d\", \"r15d\", NULL };\n\tconst char *regs8[] = { \"al\", \"cl\", \"dl\", \"bl\", \"ah\", \"ch\", \"dh\", \"bh\", NULL };\n\tconst char *regs16[] = { \"ax\", \"cx\", \"dx\", \"bx\", \"sp\", \"bp\", \"si\", \"di\", NULL };\n\tconst char *regs64[] = { \"rax\", \"rcx\", \"rdx\", \"rbx\", \"rsp\", \"rbp\", \"rsi\", \"rdi\", \"rip\", NULL};\n\tconst char *regs64ext[] = { \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\", NULL };\n\tconst char *sregs[] = { \"es\", \"cs\", \"ss\", \"ds\", \"fs\", \"gs\", NULL};\n\n\t// Get token (especially the length)\n\tsize_t nextpos, length;\n\tconst char *token;\n\tgetToken (str, pos, &nextpos);\n\ttoken = str + *pos;\n\tlength = nextpos - *pos;\n\t*pos = nextpos;\n\n\t// General purpose registers\n\tif (length == 3 && token[0] == 'e') {\n\t\tfor (i = 0; regs[i]; i++) {\n\t\t\tif (!r_str_ncasecmp (regs[i], token, length)) {\n\t\t\t\t*type = (OT_GPREG & OT_REG (i)) | OT_DWORD;\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t}\n\tif (length == 2 && (token[1] == 'l' || token[1] == 'h')) {\n\t\tfor (i = 0; regs8[i]; i++) {\n\t\t\tif (!r_str_ncasecmp (regs8[i], token, length)) {\n\t\t\t\t*type = (OT_GPREG & OT_REG (i)) | OT_BYTE;\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t}\n\tif (length == 2) {\n\t\tfor (i = 0; regs16[i]; i++) {\n\t\t\tif (!r_str_ncasecmp (regs16[i], token, length)) {\n\t\t\t\t*type = (OT_GPREG & OT_REG (i)) | OT_WORD;\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\t// This isn't working properly yet\n\t\tfor (i = 0; sregs[i]; i++) {\n\t\t\tif (!r_str_ncasecmp (sregs[i], token, length)) {\n\t\t\t\t*type = (OT_SEGMENTREG & OT_REG (i)) | OT_WORD;\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t}\n\tif (token[0] == 'r') {\n\t\tfor (i = 0; regs64[i]; i++) {\n\t\t\tif (!r_str_ncasecmp (regs64[i], token, length)) {\n\t\t\t\t*type = (OT_GPREG & OT_REG (i)) | OT_QWORD;\n\t\t\t\ta->bits = 64;\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; regs64ext[i]; i++) {\n\t\t\tif (!r_str_ncasecmp (regs64ext[i], token, length)) {\n\t\t\t\t*type = (OT_GPREG & OT_REG (i)) | OT_QWORD;\n\t\t\t\ta->bits = 64;\n\t\t\t\treturn i + 9;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; regsext[i]; i++) {\n\t\t\tif (!r_str_ncasecmp (regsext[i], token, length)) {\n\t\t\t\t*type = (OT_GPREG & OT_REG (i)) | OT_DWORD;\n\t\t\t\tif (a->bits < 32) {\n\t\t\t\t\ta->bits = 32;\n\t\t\t\t}\n\t\t\t\treturn i + 9;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Extended registers\n\tif (!r_str_ncasecmp (\"st\", token, 2)) {\n\t\t*type = (OT_FPUREG & ~OT_REGALL);\n\t\t*pos = 3;\n\t}\n\tif (!r_str_ncasecmp (\"mm\", token, 2)) {\n\t\t*type = (OT_MMXREG & ~OT_REGALL);\n\t\t*pos = 3;\n\t}\n\tif (!r_str_ncasecmp (\"xmm\", token, 3)) {\n\t\t*type = (OT_XMMREG & ~OT_REGALL);\n\t\t*pos = 4;\n\t}\n\n\t// Now read number, possibly with parantheses\n\tif (*type & (OT_FPUREG | OT_MMXREG | OT_XMMREG) & ~OT_REGALL) {\n\t\tRegister reg = X86R_UNDEFINED;\n\n\t\t// pass by '(',if there is one\n\t\tif (getToken (str, pos, &nextpos) == TT_SPECIAL && str[*pos] == '(') {\n\t\t\t*pos = nextpos;\n\t\t}\n\n\t\t// read number\n\t\t// const int maxreg = (a->bits == 64) ? 15 : 7;\n\t\tif (getToken (str, pos, &nextpos) != TT_NUMBER ||\n\t\t\t\t(reg = getnum (a, str + *pos)) > 7) {\n\t\t\tif ((int)reg > 15) {\n\t\t\t\teprintf (\"Too large register index!\\n\");\n\t\t\t\treturn X86R_UNDEFINED;\n\t\t\t} else {\n\t\t\t\treg -= 8;\n\t\t\t}\n\t\t}\n\n\t\t*pos = nextpos;\n\n\t\t// pass by ')'\n\t\tif (getToken (str, pos, &nextpos) == TT_SPECIAL && str[*pos] == ')') {\n\t\t\t*pos = nextpos;\n\t\t}\n\t\t// Safety to prevent a shift bigger than 31. Reg\n\t\t// should never be > 8 anyway\n\t\tif (reg > 7) {\n\t\t\teprintf (\"Too large register index!\\n\");\n\t\t\treturn X86R_UNDEFINED;\n\t\t}\n\t\t*type |= (OT_REG (reg) & ~OT_REGTYPE);\n\t\treturn reg;\n\t}\n\n\treturn X86R_UNDEFINED;\n}\n\nstatic void parse_segment_offset(RAsm *a, const char *str, size_t *pos,\n\t\tOperand *op, int reg_index) {\n\tint nextpos = *pos;\n\tchar *c = strchr (str + nextpos, ':');\n\tif (c) {\n\t\tnextpos ++; // Skip the ':'\n\t\tc = strchr (str + nextpos, '[');\n\t\tif (c) {nextpos ++;} // Skip the '['\n\n\t\t// Assign registers to match behaviour of OT_MEMORY type\n\t\top->regs[reg_index] = op->reg;\n\t\top->type |= OT_MEMORY;\n\t\top->offset_sign = 1;\n\t\tchar *p = strchr (str + nextpos, '-');\n\t\tif (p) {\n\t\t\top->offset_sign = -1;\n\t\t\tnextpos ++;\n\t\t}\n\t\top->scale[reg_index] = getnum (a, str + nextpos);\n\t\top->offset = op->scale[reg_index];\n\t}\n}\n// Parse operand\nstatic int parseOperand(RAsm *a, const char *str, Operand *op, bool isrepop) {\n\tsize_t pos, nextpos = 0;\n\tx86newTokenType last_type;\n\tint size_token = 1;\n\tbool explicit_size = false;\n\tint reg_index = 0;\n\t// Reset type\n\top->type = 0;\n\t// Consume tokens denoting the operand size\n\twhile (size_token) {\n\t\tpos = nextpos;\n\t\tlast_type = getToken (str, &pos, &nextpos);\n\n\t\t// Token may indicate size: then skip\n\t\tif (!r_str_ncasecmp (str + pos, \"ptr\", 3)) {\n\t\t\tcontinue;\n\t\t} else if (!r_str_ncasecmp (str + pos, \"byte\", 4)) {\n\t\t\top->type |= OT_MEMORY | OT_BYTE;\n\t\t\top->dest_size = OT_BYTE;\n\t\t\texplicit_size = true;\n\t\t} else if (!r_str_ncasecmp (str + pos, \"word\", 4)) {\n\t\t\top->type |= OT_MEMORY | OT_WORD;\n\t\t\top->dest_size = OT_WORD;\n\t\t\texplicit_size = true;\n\t\t} else if (!r_str_ncasecmp (str + pos, \"dword\", 5)) {\n\t\t\top->type |= OT_MEMORY | OT_DWORD;\n\t\t\top->dest_size = OT_DWORD;\n\t\t\texplicit_size = true;\n\t\t} else if (!r_str_ncasecmp (str + pos, \"qword\", 5)) {\n\t\t\top->type |= OT_MEMORY | OT_QWORD;\n\t\t\top->dest_size = OT_QWORD;\n\t\t\texplicit_size = true;\n\t\t} else if (!r_str_ncasecmp (str + pos, \"oword\", 5)) {\n\t\t\top->type |= OT_MEMORY | OT_OWORD;\n\t\t\top->dest_size = OT_OWORD;\n\t\t\texplicit_size = true;\n\t\t} else if (!r_str_ncasecmp (str + pos, \"tbyte\", 5)) {\n\t\t\top->type |= OT_MEMORY | OT_TBYTE;\n\t\t\top->dest_size = OT_TBYTE;\n\t\t\texplicit_size = true;\n\t\t} else { // the current token doesn't denote a size\n\t\t\tsize_token = 0;\n\t\t}\n\t}\n\n\t// Next token: register, immediate, or '['\n\tif (str[pos] == '[') {\n\t\t// Don't care about size, if none is given.\n\t\tif (!op->type) {\n\t\t\top->type = OT_MEMORY;\n\t\t}\n\t\t// At the moment, we only accept plain linear combinations:\n\t\t// part := address | [factor *] register\n\t\t// address := part {+ part}*\n\t\top->offset = op->scale[0] = op->scale[1] = 0;\n\n\t\tut64 temp = 1;\n\t\tRegister reg = X86R_UNDEFINED;\n\t\tbool first_reg = true;\n\t\twhile (str[pos] != ']') {\n\t\t\tif (pos > nextpos) {\n\t\t\t//\teprintf (\"Error parsing instruction\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpos = nextpos;\n\t\t\tif (!str[pos]) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlast_type = getToken (str, &pos, &nextpos);\n\n\t\t\tif (last_type == TT_SPECIAL) {\n\t\t\t\tif (str[pos] == '+' || str[pos] == '-' || str[pos] == ']') {\n\t\t\t\t\tif (reg != X86R_UNDEFINED) {\n\t\t\t\t\t\top->regs[reg_index] = reg;\n\t\t\t\t\t\top->scale[reg_index] = temp;\n\t\t\t\t\t\t++reg_index;\n\t\t\t\t\t} else {\n\t\t\t\t\t\top->offset += temp;\n\t\t\t\t\t\top->regs[reg_index] = X86R_UNDEFINED;\n\t\t\t\t\t}\n\n\t\t\t\t\ttemp = 1;\n\t\t\t\t\treg = X86R_UNDEFINED;\n\t\t\t\t} else if (str[pos] == '*') {\n\t\t\t\t\t// go to ], + or - to get scale\n\n\t\t\t\t\t// Something to do here?\n\t\t\t\t\t// Seems we are just ignoring '*' or assuming it implicitly.\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (last_type == TT_WORD) {\n\t\t\t\tut32 reg_type = 0;\n\n\t\t\t\t// We can't multiply registers\n\t\t\t\tif (reg != X86R_UNDEFINED) {\n\t\t\t\t\top->type = 0;\t// Make the result invalid\n\t\t\t\t}\n\n\t\t\t\t// Reset nextpos: parseReg wants to parse from the beginning\n\t\t\t\tnextpos = pos;\n\t\t\t\treg = parseReg (a, str, &nextpos, &reg_type);\n\n\t\t\t\tif (first_reg) {\n\t\t\t\t\top->extended = false;\n\t\t\t\t\tif (reg > 8) {\n\t\t\t\t\t\top->extended = true;\n\t\t\t\t\t\top->reg = reg - 9;\n\t\t\t\t\t}\n\t\t\t\t\tfirst_reg = false;\n\t\t\t\t} else if (reg > 8) {\n\t\t\t\t\top->reg = reg - 9;\n\t\t\t\t}\n\t\t\t\tif (reg_type & OT_REGTYPE & OT_SEGMENTREG) {\n\t\t\t\t\top->reg = reg;\n\t\t\t\t\top->type = reg_type;\n\t\t\t\t\tparse_segment_offset (a, str, &nextpos, op, reg_index);\n\t\t\t\t\treturn nextpos;\n\t\t\t\t}\n\n\t\t\t\t// Still going to need to know the size if not specified\n\t\t\t\tif (!explicit_size) {\n\t\t\t\t\top->type |= reg_type;\n\t\t\t\t}\n\t\t\t\top->reg_size = reg_type;\n\t\t\t\top->explicit_size = explicit_size;\n\n\t\t\t\t// Addressing only via general purpose registers\n\t\t\t\tif (!(reg_type & OT_GPREG)) {\n\t\t\t\t\top->type = 0;\t// Make the result invalid\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tchar *p = strchr (str, '+');\n\t\t\t\top->offset_sign = 1;\n\t\t\t\tif (!p) {\n\t\t\t\t\tp = strchr (str, '-');\n\t\t\t\t\tif (p) {\n\t\t\t\t\t\top->offset_sign = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//with SIB notation, we need to consider the right sign\n\t\t\t\tchar * plus = strchr (str, '+');\n\t\t\t\tchar * minus = strchr (str, '-');\n\t\t\t\tchar * closeB = strchr (str, ']');\n\t\t\t\tif (plus && minus && plus < closeB && minus < closeB) {\n\t\t\t\t\top->offset_sign = -1;\n\t\t\t\t}\n\t\t\t\t// If there's a scale, we don't want to parse out the\n\t\t\t\t// scale with the offset (scale + offset) otherwise the scale\n\t\t\t\t// will be the sum of the two. This splits the numbers\n\t\t\t\tchar *tmp;\n\t\t\t\ttmp = malloc (strlen (str + pos) + 1);\n\t\t\t\tstrcpy (tmp, str + pos);\n\t\t\t\tstrtok (tmp, \"+-\");\n\t\t\t\tst64 read = getnum (a, tmp);\n\t\t\t\tfree (tmp);\n\t\t\t\ttemp *= read;\n\t\t\t}\n\t\t}\n\t} else if (last_type == TT_WORD) {   // register\n\t\tnextpos = pos;\n\t\tRFlagItem *flag;\n\n\t\tif (isrepop) {\n\t\t\top->is_good_flag = false;\n\t\t\tstrncpy (op->rep_op, str, MAX_REPOP_LENGTH - 1);\n\t\t\top->rep_op[MAX_REPOP_LENGTH - 1] = '\\0';\n\t\t\treturn nextpos;\n\t\t}\n\n\t\top->reg = parseReg (a, str, &nextpos, &op->type);\n\n\t\top->extended = false;\n\t\tif (op->reg > 8) {\n\t\t\top->extended = true;\n\t\t\top->reg -= 9;\n\t\t}\n\t\tif (op->type & OT_REGTYPE & OT_SEGMENTREG) {\n\t\t\tparse_segment_offset (a, str, &nextpos, op, reg_index);\n\t\t\treturn nextpos;\n\t\t}\n\t\tif (op->reg == X86R_UNDEFINED) {\n\t\t\top->is_good_flag = false;\n\t\t\tif (a->num && a->num->value == 0) {\n\t\t\t\treturn nextpos;\n\t\t\t}\n\t\t\top->type = OT_CONSTANT;\n\t\t\tRCore *core = a->num? (RCore *)(a->num->userptr): NULL;\n\t\t\tif (core && (flag = r_flag_get (core->flags, str))) {\n\t\t\t\top->is_good_flag = true;\n\t\t\t}\n\n\t\t\tchar *p = strchr (str, '-');\n\t\t\tif (p) {\n\t\t\t\top->sign = -1;\n\t\t\t\tstr = ++p;\n\t\t\t}\n\t\t\top->immediate = getnum (a, str);\n\t\t} else if (op->reg < X86R_UNDEFINED) {\n\t\t\tstrncpy (op->rep_op, str, MAX_REPOP_LENGTH - 1);\n\t\t\top->rep_op[MAX_REPOP_LENGTH - 1] = '\\0';\n\t\t}\n\t} else {                             // immediate\n\t\t// We don't know the size, so let's just set no size flag.\n\t\top->type = OT_CONSTANT;\n\t\top->sign = 1;\n\t\tchar *p = strchr (str, '-');\n\t\tif (p) {\n\t\t\top->sign = -1;\n\t\t\tstr = ++p;\n\t\t}\n\t\top->immediate = getnum (a, str);\n\t}\n\n\treturn nextpos;\n}\n\nstatic int parseOpcode(RAsm *a, const char *op, Opcode *out) {\n\tout->has_bnd = false;\n\tbool isrepop = false;\n\tif (!strncmp (op, \"bnd \", 4)) {\n\t\tout->has_bnd = true;\n\t\top += 4;\n\t}\n\tchar *args = strchr (op, ' ');\n\tout->mnemonic = args ? r_str_ndup (op, args - op) : strdup (op);\n\tout->operands[0].type = out->operands[1].type = 0;\n\tout->operands[0].extended = out->operands[1].extended = false;\n\tout->operands[0].reg = out->operands[0].regs[0] = out->operands[0].regs[1] = X86R_UNDEFINED;\n\tout->operands[1].reg = out->operands[1].regs[0] = out->operands[1].regs[1] = X86R_UNDEFINED;\n\tout->operands[0].immediate = out->operands[1].immediate = 0;\n\tout->operands[0].sign = out->operands[1].sign = 1;\n\tout->operands[0].is_good_flag = out->operands[1].is_good_flag = true;\n\tout->is_short = false;\n\tout->operands_count = 0;\n\tif (args) {\n\t\targs++;\n\t} else {\n\t\treturn 1;\n\t}\n\tif (!r_str_ncasecmp (args, \"short\", 5)) {\n\t\tout->is_short = true;\n\t\targs += 5;\n\t}\n\tif (!strncmp (out->mnemonic, \"rep\", 3)) {\n\t\tisrepop = true;\n\t}\n\tparseOperand (a, args, &(out->operands[0]), isrepop);\n\tout->operands_count = 1;\n\twhile (out->operands_count < MAX_OPERANDS) {\n\t\targs = strchr (args, ',');\n\t\tif (!args) {\n\t\t\tbreak;\n\t\t}\n\t\targs++;\n\t\tparseOperand (a, args, &(out->operands[out->operands_count]), isrepop);\n\t\tout->operands_count++;\n\t}\n\treturn 0;\n}\n\nstatic ut64 getnum(RAsm *a, const char *s) {\n\tif (!s) {\n\t\treturn 0;\n\t}\n\tif (*s == '$') {\n\t\ts++;\n\t}\n\treturn r_num_math (a->num, s);\n}\n\nstatic int oprep(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tLookupTable *lt_ptr;\n\tint retval;\n\tif (!strcmp (op->mnemonic, \"rep\") ||\n\t    !strcmp (op->mnemonic, \"repe\") ||\n\t    !strcmp (op->mnemonic, \"repz\")) {\n\t\tdata[l++] = 0xf3;\n\t} else if (!strcmp (op->mnemonic, \"repne\") ||\n\t           !strcmp (op->mnemonic, \"repnz\")) {\n\t\tdata[l++] = 0xf2;\n\t}\n\tOpcode instr = {0};\n\tparseOpcode (a, op->operands[0].rep_op, &instr);\n\n\tfor (lt_ptr = oplookup; strcmp (lt_ptr->mnemonic, \"null\"); lt_ptr++) {\n\t\tif (!r_str_casecmp (instr.mnemonic, lt_ptr->mnemonic)) {\n\t\t\tif (lt_ptr->opcode > 0) {\n\t\t\t\tif (lt_ptr->only_x32 && a->bits == 64) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tut8 *ptr = (ut8 *)&lt_ptr->opcode;\n\t\t\t\tint i = 0;\n\t\t\t\tfor (; i < lt_ptr->size; i++) {\n\t\t\t\t\tdata[i + l] = ptr[lt_ptr->size - (i + 1)];\n\t\t\t\t}\n\t\t\t\tfree (instr.mnemonic);\n\t\t\t\treturn l + lt_ptr->size;\n\t\t\t} else {\n\t\t\t\tif (lt_ptr->opdo) {\n\t\t\t\t\tdata += l;\n\t\t\t\t\tif (instr.has_bnd) {\n\t\t\t\t\t\tdata[l] = 0xf2;\n\t\t\t\t\t\tdata++;\n\t\t\t\t\t}\n\t\t\t\t\tretval = lt_ptr->opdo (a, data, &instr);\n\t\t\t\t\t// if op supports bnd then the first byte will\n\t\t\t\t\t// be 0xf2.\n\t\t\t\t\tif (instr.has_bnd) {\n\t\t\t\t\t\tretval++;\n\t\t\t\t\t}\n\t\t\t\t\treturn l + retval;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfree (instr.mnemonic);\n\treturn -1;\n}\n\nstatic int assemble(RAsm *a, RAsmOp *ao, const char *str) {\n\tut8 __data[32] = {0};\n\tut8 *data = __data;\n\tchar op[128];\n\tLookupTable *lt_ptr;\n\tint retval = -1;\n\tOpcode instr = {0};\n\n\tstrncpy (op, str, sizeof (op) - 1);\n\top[sizeof (op) - 1] = '\\0';\n\tparseOpcode (a, op, &instr);\n\tfor (lt_ptr = oplookup; strcmp (lt_ptr->mnemonic, \"null\"); lt_ptr++) {\n\t\tif (!r_str_casecmp (instr.mnemonic, lt_ptr->mnemonic)) {\n\t\t\tif (lt_ptr->opcode > 0) {\n\t\t\t\tif (!lt_ptr->only_x32 || a->bits != 64) {\n\t\t\t\t\tut8 *ptr = (ut8 *)&lt_ptr->opcode;\n\t\t\t\t\tint i = 0;\n\t\t\t\t\tfor (; i < lt_ptr->size; i++) {\n\t\t\t\t\t\tdata[i] = ptr[lt_ptr->size - (i + 1)];\n\t\t\t\t\t}\n\t\t\t\t\tretval = lt_ptr->size;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (lt_ptr->opdo) {\n\t\t\t\t\tif (instr.has_bnd) {\n\t\t\t\t\t\tdata[0] = 0xf2;\n\t\t\t\t\t\tdata ++;\n\t\t\t\t\t}\n\t\t\t\t\tretval = lt_ptr->opdo (a, data, &instr);\n\t\t\t\t\t// if op supports bnd then the first byte will\n\t\t\t\t\t// be 0xf2.\n\t\t\t\t\tif (instr.has_bnd) {\n\t\t\t\t\t\tretval++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tr_asm_op_set_buf (ao, __data, retval);\n\tfree (instr.mnemonic);\n\treturn retval;\n}\n\nRAsmPlugin r_asm_plugin_x86_nz = {\n\t.name = \"x86.nz\",\n\t.desc = \"x86 handmade assembler\",\n\t.license = \"LGPL3\",\n\t.arch = \"x86\",\n\t.bits = 16 | 32 | 64,\n\t.endian = R_SYS_ENDIAN_LITTLE,\n\t.assemble = &assemble\n};\n\n#ifndef CORELIB\nR_API RLibStruct radare_plugin = {\n\t.type = R_LIB_TYPE_ASM,\n\t.data = &r_asm_plugin_x86_nz,\n\t.version = R2_VERSION\n};\n#endif\n"], "filenames": ["libr/asm/p/asm_x86_nz.c"], "buggy_code_start_loc": [2026], "buggy_code_end_loc": [2029], "fixing_code_start_loc": [2026], "fixing_code_end_loc": [2029], "type": "CWE-125", "message": "opmov in libr/asm/p/asm_x86_nz.c in radare2 before 3.1.0 allows attackers to cause a denial of service (buffer over-read) via crafted x86 assembly data, as demonstrated by rasm2.", "other": {"cve": {"id": "CVE-2018-19843", "sourceIdentifier": "cve@mitre.org", "published": "2018-12-04T09:29:00.773", "lastModified": "2018-12-31T14:21:53.947", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "opmov in libr/asm/p/asm_x86_nz.c in radare2 before 3.1.0 allows attackers to cause a denial of service (buffer over-read) via crafted x86 assembly data, as demonstrated by rasm2."}, {"lang": "es", "value": "opmov en libr/asm/p/asm_x86_nz.c en radare2 en versiones anteriores a la 3.1.0 permite que los atacantes provoquen una denegaci\u00f3n de servicio (sobrelectura de b\u00fafer) mediante datos de ensamblaje x86, tal y como queda demostrado con rasm2."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.1.1", "matchCriteriaId": "92DD0821-889B-4ED8-A24C-1F244A4522A1"}]}]}], "references": [{"url": "https://github.com/radare/radare2/commit/f17bfd9f1da05f30f23a4dd05e9d2363e1406948", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/radare/radare2/issues/12242", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radare/radare2/commit/f17bfd9f1da05f30f23a4dd05e9d2363e1406948"}}