{"buggy_code": ["2022-04-27: Fix wrong boundary checks in inflections parser resulting in stack buffer over-read with corrupt input\n2022-04-26: Fix text formatting\n2022-04-26: Fix array boundary check when parsing inflections which could result in buffer over-read with corrupt input\n2022-04-23: Fix formatting\n2022-04-23: Fix checking boundary of deobfuscation key which could cause buffer over-read with corrupt data\n2022-04-23: Fix issue with corrupt data with empty lookup string which could lead to read beyond buffer\n2022-04-23: Fix faulty checks for array boundary which caused buffer over-read with corrupt input\n2022-04-23: Fix issue with corrupt files with tagvalues_count = 0 that caused null pointer dereference\n2022-04-23: Fix issues when mobi_buffer_getpointer returns null. With corrupt data this could lead to out-of-bounds read\n2022-04-13: Add packaging status [skip ci]\n2022-04-10: Make random generation return proper error codes\n2022-04-10: Rewrite randombytes for libmobi\n2022-04-07: Add libsodium randombytes.c\n2022-04-10: Fix \"fallthrough\" spelling\n2022-04-10: Make declaration match definition\n2022-04-10: Fix different sign comparison warning\n2022-04-10: Update Xcode project\n2022-04-10: Don't run tests if bash is missing\n2022-04-10: Looking for libxml2, first try pkg-config\n2022-04-04: Update MSVC project\n2022-04-02: Add support for GNU/kFreeBSD and GNU/Hurd\n2022-04-02: Check for inline, noreturn support in CMake\n2022-03-27: Fix format truncation warning\n2022-03-21: Version 0.10\n2022-03-21: Update Xcode project [skip ci]\n2022-03-21: Add functions for retrieving orthographic index entries\n2022-02-27: Add basic CMake support\n2022-02-26: GHA: fetch tags with checkout\n2022-02-26: Minor refactoring of file path manipulation function\n2022-02-26: Fix memory handling issues\n2022-02-26: Add coverity scan workflow\n2022-02-25: Remove obsolete changelog\n2022-02-25: Fix md5sum output on Windows\n2022-02-25: Fix inconsistent separators in path on Windows builds\n2022-02-25: GHA: fix log paths\n2022-02-25: GHA: fix workflow syntax\n2022-02-25: GHA: upload test logs on failure\n2022-02-24: Fix printf format specifier\n2022-02-24: Fix sample path in Makefile\n2022-02-24: Missing autotools in mingw workflow\n2022-02-24: Windows doesn't accept asterisk in file names\n2022-02-24: Update workflow, add badge\n2022-02-24: Add mingw workflow\n2022-02-24: Fix tests in out-of-tree build\n2022-02-24: Update man pages\n2022-02-24: Replace non-portable strptime\n2022-02-24: Make sure both validity period dates are set\n2022-02-21: Fix strptime not found on linux build\n2022-02-21: Add build github action\n2022-02-21: Update README\n2022-02-21: Minor code cleanups\n2022-02-21: Unify boolean and static usage in tools\n2022-02-21: mobimeta: fix null pointer dereference when parsing malformed option\n2022-02-18: Add  hybrid spit option to mobitool\n2022-02-18: Update documentation\n2022-02-18: Test both encrypted hybrid parts\n2022-02-18: Fix: fast decryption routine fails for non-huffman compression\n2022-02-18: Fix mobitool serial decryption\n2022-02-18: Add DRM tests\n2022-02-17: Fix build with encryption disabled\n2022-02-17: Update tests samples\n2022-02-16: Add -h option to tools, update man pages\n2022-02-16: Update Xcode settings\n2022-02-16: Restructure, cleanup encryption related code, add mobidrm tool\n2021-11-19: Improve getopt loop, fix config.h to be accessible from all tools\n2021-11-10: Update xcode project\n2021-11-10: Add functions to split hybrid files\n2021-11-10: Avoid modifying existing records, as caller may keep reference to them\n2021-11-05: Fix: tests fail if pid contains asterisk\n2021-11-05: Fix: decryption may fail for some records with standard compression\n2021-11-05: Replace test samples with self-generated smaller ones\n2021-11-05: Skip test in case of missing checksums\n2021-10-20: Version 0.9\n2021-10-24: Fix out-of-tree build\n2021-10-22: Fix mingw build, code formatting\n2021-10-14: Fix gcc format truncation warning\n2021-10-14: Include autogen.sh in distribution bundle\n2021-10-14: Create codeql-analysis.yml\n2021-10-14: Fix autoconf 2.70 warnings, clean up\n2021-10-14: Build fails with autoconf 2.70\n2021-10-11: Version 0.8\n2021-10-11: Update Xcode project\n2021-10-11: Fix warnings about changed signedness\n2021-09-18: Fix potential out-of-buffer read while parsing corrupt file, closes #38\n2021-09-18: Fix potential out-of-buffer read while parsing corrupt file, closes #35, #36\n2021-09-09: Version 0.7\n2021-09-09: fix oob write bug inside libmobi\n2021-06-07: Add reference to brew formula\n2020-09-02: Fix null pointer dereference in case of broken fragment\n2020-08-01: Update changelog\n2020-08-01: Version 0.6\n2020-07-31: Fix typo\n2020-07-31: Add Readme to dist package\n2020-07-31: Remove anchor on truncated link\n2020-07-31: Fix missing option in man page\n2020-07-30: Include test samples in dist package\n2020-07-25: Fix gcc 7+ warnings about implicit fall through and format truncation\n2020-07-24: Unique names for internal functions to avoid confilicts with static linking\n2020-06-24: Close file in error branch\n2020-06-24: Fix static compilation with miniz on gcc\n2020-06-24: Minor documentation fixes\n2020-06-23: Version 0.5\n2020-06-23: mobitool: add dump cover option\n2020-06-23: Minor documentation improvement\n2020-06-23: Fix potential buffer over-read\n2019-03-18: Fix: try also \"name\" attribute when searching for link anchor tags, closes #24\n2019-02-22: Add mobi_is_replica function\n2019-02-22: Fix potential read beyond buffer\n2019-02-22: Travis migration\n2018-08-07: Fix: missing items in recreated ncx file\n2018-06-20: Fix: printf format warning on some gcc versions\n2018-06-20: Fix: make dist broken by nonexistent header files\n2018-06-20: VERSION 0.4\n2018-06-20: Fix: buffer overflow (CVE-2018-11726)\n2018-06-20: Fix: buffer overflow (CVE-2018-11724)\n2018-06-20: Fix: read beyond buffer (CVE-2018-11725)\n2018-06-20: Fix: buffer overflow (mobitool), closes #18\n2018-06-20: Fix: read beyond buffer with corrupted KF8 Boundary record, closes #19\n2018-06-20: Fix: read beyond buffer, closes #16, #17\n2018-06-20: Updated xcode project files\n2018-04-03: Fix: ncx part was not scanned for links, fixes #12\n2018-04-02: Fix regression, potential use after free\n2018-04-02: Skip broken resources, fixes #10\n2018-03-05: Allow processing zero length text records, fixes #9\n2017-12-25: Skip broken first resource offset instead of dying\n2017-12-18: Skip broken links reconstruction instead of dying\n2017-11-27: Disable travis OS X builds, as they usually time out\n2017-11-16: Fix: increase max number of dictionary entries per record\n2017-11-14: Fix for some encrypted documents with palmdoc encoding\n2017-11-06: Fix: potential null pointer dereference\n2017-10-16: Manpage cleanup\n2017-09-27: Update README\n2017-09-26: Increase maximum length of attribute name and value, closes #5\n2017-02-26: Remove obsolete files from VS build (closes #3) [ci skip]\n2016-11-05: Mobitool: use epub extension if extracted source resource is epub\n2016-06-10: Update docs\n2016-06-10: Update test files\n2016-06-10: Fix: out of bounds read in corrupt font resource\n2016-06-10: Prevent memory leak in case of corrupt font resources\n2016-06-10: Calculate deobfuscation buffer limit from key length\n2016-06-10: Fix: USE_LIBXML2 macro was not included from config.h\n2016-06-10: Fix: USE_LIBXML2 macro was not included from config.h\n2016-06-09: Fix: memory leak in tools\n2016-06-09: Fix: potential out of bounds read\n2016-06-09: Fix: memory leak in internal xmlwriter\n2016-06-01: Update README\n2016-05-19: Feature: verify decryption key type\n2016-05-19: Cleanup converting little endian buffer to 32-bit integer\n2016-05-19: Feature: check drm expiration dates\n2016-05-18: Fix: memory leaks in encryption\n2016-05-18: Fix concurrent autotools builds\n2016-05-18: use relative path, as $(top_srcdir) fails to be substituted (?)\n2016-05-18: update vcxproj\n2016-05-18: Include headers in automake sources\n2016-05-18: Fix: automake out-of-tree miniz build\n2016-05-18: Fix: wrongly detected fdst record broke some ancient documents\n2016-05-18: Fix: improve index header parsing, some old dictionaries might not load\n2016-05-18: Fix: convert encoding of opf strings from cp1252 indices\n2016-05-18: Quiet warnings about unused values of wiped variables\n2016-05-18: Fix: potential memory leak\n2016-05-18: Fix: wrongly decoded \"&copy;\" entity\n2016-05-16: Fix: huffdic decompression fails in case of huge documents\n2016-05-14: Simplify buffer_init_null() function\n2016-05-14: Use ARRAYSIZE macro\n2016-05-14: Feature: calculate pid for decryption from device serial number\n2016-04-29: Use endian-independent byte swapping\n2016-04-29: Exclude unused miniz functions from binary\n2016-04-29: Add SHA-1 routines\n2016-04-27: Fix miniz.c formatting\n2016-04-27: Documentation\n2016-04-20: Update changelog\n2016-04-20: Fix potential null pointer dereference\n2016-04-20: Remove useless check\n2016-04-20: Fix text record size calculation\n2016-04-20: Fix buffer checking and freeing\n2016-04-19: Update docs\n2016-04-19: Update ChangeLog\n2016-04-19: Fix comparison between signed and unsigned integer\n2016-04-19: use strdup on linux/glibc\n2016-04-19: Add initial write and metadata editing support. Add mobimeta tool.\n2016-04-19: Always check whether memory allocation succeeded\n2016-04-18: Fix: guarantee array resize step is at least 1\n2016-04-13: Workaround to read some old mobipocket files\n2016-04-13: Improve pdb dates resolving\n2016-04-07: Minor documentation edit\n2016-04-07: Update changelog\n2016-04-06: Fix format warning\n2016-04-06: Update test checksums\n2016-04-06: Fix: <dc:date> \"event\" attribute needs \"opf\" namespace\n2016-04-06: Fix: id attributes in ncx file should be unique\n2016-04-06: Store full name in MOBIMobiHeader structure\n2016-04-05: Fix formatting\n2016-04-05: Fix signedness warning\n2016-04-04: Fix potential buffer overflow, closes #2\n2016-04-04: Fix potential null pointer dereference\n2016-03-23: Fix signedness warnings\n2016-03-22: Fix: _mkdir needs direct.h on MinGW\n2016-03-22: Fix tests on Windows\n2016-03-22: Fix: palmdoc decompression may fail with zero byte in input buffer\n2016-03-21: VERSION 03: internal xmlwriter, metadata handling functions, bug fixes\n2016-03-21: Feature: add helper functions for metadata extraction\n2016-03-21: Load also kf8 data when only kf7 version is requested\n2016-03-21: Fix: wrong exth header length check could discard some valid headers\n2016-03-20: Get rid of extended attributes in release archive on OS X\n2016-03-19: Mobitool: add descriptive error messages based on libmobi return codes\n2016-03-04: Add extra length check for CMET record extraction\n2016-03-04: Always check buffer allocation result\n2016-03-04: Add functions to extract conversion source and log, also add this feature to mobitool\n2016-03-04: Remove some stray printfs\n2016-03-03: Remove not used AC_FUNC_MALLOC/REALLOC macros that break cross-compilation\n2016-03-03: Fix potential illegal memory access in miniz.c\n2016-03-03: Fix potential dereference of null pointer in miniz.c\n2016-03-03: Fix for Android bionic libc bug (SIZE_MAX missing in stdint.h)\n2016-03-03: Fix mobitool compilation on MSVC++\n2016-03-03: Add EPUB creation feature to mobitool\n2016-03-02: Fix potential buffer overflow, null pointer dereference\n2016-03-02: Add travis test for no-external-dependency build\n2016-03-02: Fix missing strdup on linux\n2016-03-02: Add internal xmlwriter (as an alternative to libxml2)\n2016-03-01: Feature: decode html entities in exth header strings\n2016-02-29: Fix: potential buffer overflow\n2016-02-29: Fix: wrong pid calculation (regression introduced in 0.2)\n2016-02-26: VERSION 0.2: increased stability, lots of bugs fixed\n2016-02-26: Add Xcode project file\n2016-02-26: Preliminary support for MSVC++ compiler\n2016-02-26: Do not use variable length arrays\n2016-02-26: Refactor mobi_reconstruct_parts() to use MOBIFragment list\n2016-02-26: Fix compiler warning about sign conversion\n2016-02-26: Fix compiler warning about type conversion\n2016-02-26: Check the result of malloc/calloc\n2016-02-26: Fix inconsistent use of const between some definitions and declarations\n2016-02-24: Fix inconsistence between function declaration and definition\n2016-02-24: Fix various potential crashes in case of corrupt input (afl-fuzz)\n2016-02-24: Fix dead code warnings in miniz\n2015-11-26: Export mobi_get_first_resource_record() function\n2015-11-26: Fix: double free on corrupt cdic\n2015-11-02: Update docs\n2015-11-02: Feature: add helper functions to find resources by flow id\n2015-11-02: Feature: export MOBI_NOTSET macro\n2015-11-02: Feature: give more options to parse rawml function\n2015-10-24: Restore travis.yml\n2015-10-24: Fix OSX travis build\n2015-10-24: Fix OSX travis build\n2015-10-24: Fix multiline inline script\n2015-10-24: Enable multi-OS feature\n2015-10-24: Fix: unique temporary name for parallel tests\n2015-10-24: Fix: decoding video resources falsely reported as failed\n2015-10-24: Fix: tests, some md5sum implementations insert double spaces\n2015-10-24: Fix for automake < 1.13\n2015-10-23: Add simple tests framework\n2015-10-23: Fix: increase max index entries per record count, as some rare samples fail\n2015-10-22: Fix: incorrectly decoded video/audio resources\n2015-10-22: Feature: add option to specify output path\n2015-10-14: Add some internal functions to public API: mobi_get_flow_by_uid, mobi_get_resource_by_uid, mobi_get_part_by_uid, mobi_get_exthrecord_by_tag\n2015-06-13: update changelog\n2015-06-13: fix: various invalid memory access\n2015-06-13: don't quit on invalid input, instead substitute with replacement character\n2015-06-12: fix typo\n2015-06-12: update changelog\n2015-06-12: fix: reconstruction failed when there were gaps between fragments\n2015-06-12: add EXTH tags\n2015-06-12: prevent return of garbage value check return value in case of failed malloc\n2015-06-12: fix invalid memory access\n2015-04-12: Fix reconstruction of \"kindle:embed\" links without mime type (regression)\n2015-04-12: Add sanity checks to link reconstruction functions, allow skipping some malformed patterns\n2015-04-12: Fix infinite loop in guide build while unknown tag was found\n2015-04-12: Increase max recursion level for huffman decompression\n2015-03-28: update docs\n2015-03-28: fix solaris studio compiler warnings\n2015-03-28: fix solaris studio compiler build\n2015-02-18: Fix \"more than one: -compatibility_version specified\" error on powerpc\n2014-11-24: improve docs\n2014-11-24: simplify public header\n2014-11-21: changelog update [ci skip]\n2014-11-21: README\n2014-11-21: fix: add sanity checks\n2014-11-21: Fix: add sanity checks\n2014-11-21: add sanity check to huffcdic indices count\n2014-11-21: fix number of leaks and other minor issues (by coverity scan)\n2014-11-20: missing notification email kills coverity scan\n2014-11-20: update travis.yml\n2014-11-20: upgrade travis.ml with covert scan\n2014-11-20: update README.md\n2014-11-20: add .travis.yml\n2014-11-20: update REAME.md\n2014-11-20: update README.md\n2014-11-20: update docs\n2014-11-20: feature: add decryption support\n2014-11-20: mkdir cleanup\n2014-11-17: documentation\n2014-11-17: strip unneeded <aid/> tags\n2014-11-16: fix: potential leak\n2014-11-16: fix: regression, some image tags were not reconstructed\n2014-11-16: fix: improve ligatures handling\n2014-11-16: override darwin linker default versioning\n2014-11-15: fix: get proper LIGT entries count from index header\n2014-11-15: feature: unpack records into new folder\n2014-11-14: make README readable on github\n2014-11-14: add README for mobitool\n2014-11-14: fix: dictionaries with large inflection rules failed\n2014-11-14: feature: support encoded ligatures in index entry labels\n2014-11-14: readme\n2014-11-14: update changelog\n2014-11-13: feature: support for older inflections scheme\n2014-11-13: bug: files with short tagx header won't open\n2014-11-13: cleanup unneeded include\n2014-11-13: use strdup on linux/glibc\n2014-11-13: debugging cleanup\n2014-11-13: reorganize source files\n2014-11-13: use strdup on linux/glibc\n2014-11-11: update changelog\n2014-11-11: update changeling\n2014-11-11: fix: documents with text record size > 4096 failed to load\n2014-11-11: add: function to decode flat index entries\n2014-11-11: debug: add functions for debugging indices\n2014-11-11: cleanup\n2014-11-11: fix: variable length value wrongly calculated when going backwards\n2014-11-08: update documentation\n2014-11-08: update changelog\n2014-11-08: add support for reconstructing inflections index entries\n2014-11-08: parsing of exth header failed in some cases\n2014-11-08: fix: some links reconstruction in kf7 failed\n2014-11-08: improve debug info\n2014-11-08: failed malloc false reports\n2014-11-03: fix problem with uncompressed documents\n2014-11-03: fix broken locales\n2014-11-03: remove obsolete includes\n2014-11-03: git log > changelog\n2014-11-03: improved buffer handling\n2014-11-03: improved OPF for dictionaries\n2014-11-03: proper rawml->orth initialization and freeing\n2014-11-03: fix subject field in opf\n2014-11-03: handle UTF-16 surrogates, make ORDT lookups locale independent\n2014-11-01: move dict reconstruction to separate function\n2014-11-01: cleanup\n2014-11-01: quiet gcc warning on printf format\n2014-11-01: reconstruction of orth dictionary entries\n2014-09-27: use mobi_list_del_all()\n2014-09-25: postpone conversion to utf8 after all source reconstructions\n2014-09-24: comment\n2014-09-24: comments\n2014-09-12: doxygen comment\n2014-09-12: data size in comment\n2014-09-05: MOBIArray data type fix\n2014-09-05: config.h fixes\n2014-06-29: merge master\n2014-04-11: initial commit", "/** @file opf.c\n *  @brief Functions for handling OPF structures\n *\n * Copyright (c) 2020 Bartek Fabiszewski\n * http://www.fabiszewski.net\n *\n * This file is part of libmobi.\n * Licensed under LGPL, either version 3, or any later.\n * See <http://www.gnu.org/licenses/>\n */\n\n#define _GNU_SOURCE 1\n#ifndef __USE_BSD\n#define __USE_BSD /* for strdup on linux/glibc */\n#endif\n\n#include <stdlib.h>\n#include <string.h>\n#include \"opf.h\"\n#ifdef USE_LIBXML2\n#ifdef __clang__\n#pragma clang diagnostic push\n/* suppress clang documentation warning for libxml headers */\n#pragma clang diagnostic ignored \"-Wdocumentation\"\n#endif\n#include <libxml/encoding.h>\n#include <libxml/xmlwriter.h>\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n#else\n#include \"xmlwriter.h\"\n#endif\n#include \"index.h\"\n#include \"util.h\"\n#include \"parse_rawml.h\"\n#include \"debug.h\"\n\n/**\n @brief Array of valid OPF guide types\n \n http://www.idpf.org/epub/20/spec/OPF_2.0.1_draft.htm#Section2.6\n */\nconst char *mobi_guide_types[] = {\n    \"cover\", /**< the book cover(s), jacket information, etc. */\n    \"title-page\", /**< page with possibly title, author, publisher, and other metadata */\n    \"toc\", /**< table of contents */\n    \"index\", /**< back-of-book style index */\n    \"glossary\", /**< glossary */\n    \"acknowledgements\", /**< acknowledgements */\n    \"bibliography\", /**< bibliography */\n    \"colophon\", /**< colophon */\n    \"copyright-page\", /**< copyright page */\n    \"dedication\", /**< dedication */\n    \"epigraph\", /**< epigraph */\n    \"foreword\", /**< foreword */\n    \"loi\", /**< list of illustrations */\n    \"lot\", /**< list of tables */\n    \"notes\", /**< notes */\n    \"preface\", /**< preface */\n    \"text\", /**< First \"real\" page of content (e.g. \"Chapter 1\") */\n    NULL /**< eof */\n};\n\n/**\n @brief Check if type is valid OPF guide element\n \n Compares types with elements of mobi_guide_types[] array\n \n @param[in] type OPF guide type\n @return True if type is valid guide type, false otherwise\n */\nbool mobi_is_guide_type(const char *type) {\n    size_t i = 0;\n    size_t type_length = strlen(type);\n    while (mobi_guide_types[i]) {\n        if (strncmp(mobi_guide_types[i++], type, type_length) == 0) {\n            return true;\n        }\n    }\n    /* check if \"other\" type */\n    if (strncmp(type, \"other.\", 6) == 0) { return true; }\n    return false;\n}\n\n/**\n @brief Reconstruct guide part of the OPF file\n \n @param[in,out] opf Structure OPF->OPFguide will be filled with parsed data\n @param[in] rawml Structure MOBIRawml will be parsed\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_build_opf_guide(OPF *opf, const MOBIRawml *rawml) {\n    /* parse guide data */\n    if (rawml == NULL || rawml->guide == NULL) {\n        debug_print(\"%s\\n\", \"Initialization failed\");\n        return MOBI_INIT_FAILED;\n    }\n    size_t i = 0;\n    size_t j = 0;\n    MOBI_RET ret;\n    size_t count = rawml->guide->entries_count;\n    if (count == 0) {\n        return MOBI_SUCCESS;\n    }\n    opf->guide = malloc(sizeof(OPFguide));\n    if (opf->guide == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    OPFreference **reference = malloc((count + 1) * sizeof(OPFreference*));\n    if (reference == NULL) {\n        free(opf->guide);\n        opf->guide = NULL;\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    if (rawml->guide->cncx_record == NULL) {\n        free(reference);\n        free(opf->guide);\n        opf->guide = NULL;\n        debug_print(\"%s\\n\", \"Missing cncx record\");\n        return MOBI_DATA_CORRUPT;\n    }\n    while (i < count) {\n        const MOBIIndexEntry *guide_entry = &rawml->guide->entries[i];\n        const char *type = guide_entry->label;\n        uint32_t cncx_offset;\n        ret = mobi_get_indxentry_tagvalue(&cncx_offset, guide_entry, INDX_TAG_GUIDE_TITLE_CNCX);\n        if (ret != MOBI_SUCCESS) {\n            free(reference);\n            free(opf->guide);\n            opf->guide = NULL;\n            return ret;\n        }\n        const MOBIPdbRecord *cncx_record = rawml->guide->cncx_record;\n        char *ref_title = mobi_get_cncx_string_utf8(cncx_record, cncx_offset, rawml->guide->encoding);\n        if (ref_title == NULL) {\n            free(reference);\n            free(opf->guide);\n            opf->guide = NULL;\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        uint32_t frag_number = MOBI_NOTSET;\n        ret = mobi_get_indxentry_tagvalue(&frag_number, guide_entry, INDX_TAG_FRAG_POSITION);\n        if (ret != MOBI_SUCCESS) {\n            debug_print(\"INDX_TAG_FRAG_POSITION not found (%i)\\n\", ret);\n            free(ref_title);\n            i++;\n            continue;\n            /* FIXME: I need some examples which use other tags */\n            //mobi_get_indxentry_tagvalue(&frag_number, guide_entry, INDX_TAG_FRAG_FILE_NR);\n        }\n        if (frag_number >= rawml->frag->entries_count) {\n            debug_print(\"Wrong frag entry index (%i)\\n\", frag_number);\n            free(ref_title);\n            i++;\n            continue;\n        }\n        const MOBIIndexEntry *frag_entry = &rawml->frag->entries[frag_number];\n        uint32_t file_number;\n        ret = mobi_get_indxentry_tagvalue(&file_number, frag_entry, INDX_TAG_FRAG_FILE_NR);\n        if (ret != MOBI_SUCCESS) {\n            free(reference);\n            free(opf->guide);\n            free(ref_title);\n            opf->guide = NULL;\n            return ret;\n        }\n        /* check if valid guide type */\n        char *ref_type;\n        size_t type_size = strlen(type);\n        if (!mobi_is_guide_type(type)) {\n            /* prepend \"other.\" prefix */\n            type_size += 6;\n            ref_type = malloc(type_size + 1);\n            if (ref_type == NULL) {\n                free(reference);\n                free(opf->guide);\n                opf->guide = NULL;\n                free(ref_title);\n                debug_print(\"%s\\n\", \"Memory allocation failed\");\n                return MOBI_MALLOC_FAILED;\n            }\n            snprintf(ref_type, type_size + 1, \"other.%s\", type);\n        } else {\n            ref_type = malloc(type_size + 1);\n            if (ref_type == NULL) {\n                free(reference);\n                free(opf->guide);\n                opf->guide = NULL;\n                free(ref_title);\n                debug_print(\"%s\\n\", \"Memory allocation failed\");\n                return MOBI_MALLOC_FAILED;\n            }\n            memcpy(ref_type, type, type_size);\n            ref_type[type_size] = '\\0';\n        }\n        debug_print(\"<reference type=\\\"%s\\\" title=\\\"%s\\\" href=\\\"part%05u.html\\\" />\", ref_type, ref_title, file_number);\n        char href[FILENAME_MAX + 1];\n        snprintf(href, sizeof(href), \"part%05u.html\", file_number);\n        char *ref_href = strdup(href);\n        reference[j] = calloc(1, sizeof(OPFreference));\n        *reference[j] = (OPFreference) { ref_type, ref_title, ref_href };\n        i++;\n        j++;\n    }\n    /* terminate array with NULL */\n    reference[j] = NULL;\n    opf->guide->reference = reference;\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Write <navPoint/> entries for given ncx level\n \n @param[in,out] writer xmlTextWriterPtr to write to\n @param[in] ncx Array of NCX structures with ncx content\n @param[in] level TOC level\n @param[in] from First entry in NCX array to copy from\n @param[in] to Last entry in NCX array to copy from\n @param[in] seq Sequential number for playOrder attribute\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_write_ncx_level(xmlTextWriterPtr writer, const NCX *ncx, const size_t level, const size_t from, const size_t to, size_t *seq) {\n    for (size_t i = from; i <= to; i++) {\n        if (level != ncx[i].level) {\n            continue;\n        }\n        /* start <navPoint> */\n        char playorder[10 + 1];\n        snprintf(playorder, 11, \"%u\", (uint32_t) (*seq)++);\n\n        /* id string (max 10 digits and dash) for each level + \"toc\" + terminator */\n        size_t id_size = 11 * (level + 1) + 3 + 1;\n        char *id = malloc(id_size);\n        if (id == NULL) {\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        strcpy(id, \"toc\");\n        size_t curr_id = i;\n        while (curr_id != MOBI_NOTSET) {\n            size_t parent_id = ncx[curr_id].parent;\n            if (parent_id == curr_id) {\n                debug_print(\"%s\\n\", \"Skip id of corrupt ncx entry\");\n                break;\n            }\n            size_t curr_from = 0;\n            if (parent_id != MOBI_NOTSET && ncx[parent_id].first_child != MOBI_NOTSET) {\n                curr_from = ncx[parent_id].first_child;\n            }\n            char level_id[10 + 1];\n            snprintf(level_id, 11, \"%u\", (uint32_t) (curr_id - curr_from + 1));\n            char *id_copy = strdup(id + 3);\n            if (id_copy == NULL) {\n                debug_print(\"%s\\n\", \"Memory allocation failed\");\n                free(id);\n                return MOBI_MALLOC_FAILED;\n            }\n            snprintf(id, id_size, \"toc-%s%s\", level_id, id_copy);\n            free(id_copy);\n            curr_id = parent_id;\n        }\n        \n        int xml_ret = xmlTextWriterStartElement(writer, BAD_CAST \"navPoint\");\n        if (xml_ret < 0) {\n            free(id);\n            return MOBI_XML_ERR;\n        }\n        xml_ret = xmlTextWriterWriteAttribute(writer, BAD_CAST \"id\", BAD_CAST id);\n        free(id);\n        if (xml_ret < 0) { return MOBI_XML_ERR; }\n        xml_ret = xmlTextWriterWriteAttribute(writer, BAD_CAST \"playOrder\", BAD_CAST playorder);\n        if (xml_ret < 0) { return MOBI_XML_ERR; }\n        /* write <navLabel> */\n        xml_ret = xmlTextWriterStartElement(writer, BAD_CAST \"navLabel\");\n        if (xml_ret < 0) { return MOBI_XML_ERR; }\n        xml_ret = xmlTextWriterStartElement(writer, BAD_CAST \"text\");\n        if (xml_ret < 0) { return MOBI_XML_ERR; }\n        xml_ret = xmlTextWriterWriteString(writer, BAD_CAST ncx[i].text);\n        if (xml_ret < 0) { return MOBI_XML_ERR; }\n        xml_ret = xmlTextWriterEndElement(writer);\n        if (xml_ret < 0) { return MOBI_XML_ERR; }\n        xml_ret = xmlTextWriterEndElement(writer);\n        if (xml_ret < 0) { return MOBI_XML_ERR; }\n        /* write <content> */\n        xml_ret = xmlTextWriterStartElement(writer, BAD_CAST \"content\");\n        if (xml_ret < 0) { return MOBI_XML_ERR; }\n        xml_ret = xmlTextWriterWriteAttribute(writer, BAD_CAST \"src\", BAD_CAST ncx[i].target);\n        if (xml_ret < 0) { return MOBI_XML_ERR; }\n        xml_ret = xmlTextWriterEndElement(writer);\n        if (xml_ret < 0) { return MOBI_XML_ERR; }\n        debug_print(\"%s - %s\\n\", ncx[i].text, ncx[i].target);\n        if (ncx[i].first_child != MOBI_NOTSET && ncx[i].last_child != MOBI_NOTSET) {\n            MOBI_RET ret = mobi_write_ncx_level(writer, ncx, level + 1, ncx[i].first_child, ncx[i].last_child, seq);\n            if (ret != MOBI_SUCCESS) {\n                return ret;\n            }\n        }\n        /* end <navPoint> */\n        xml_ret = xmlTextWriterEndElement(writer);\n        if (xml_ret < 0) { return MOBI_XML_ERR; }\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Write element <meta name=\"name\" content=\"content\"/> to XML buffer\n \n @param[in,out] writer xmlTextWriterPtr to write to\n @param[in] name Attribute name\n @param[in] content Attribute content\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_xml_write_meta(xmlTextWriterPtr writer, const char *name, const char *content) {\n    int xml_ret = xmlTextWriterStartElement(writer, BAD_CAST \"meta\");\n    if (xml_ret < 0) {\n        debug_print(\"XML error: %i (name: %s, content: %s)\\n\", xml_ret, name, content);\n        return MOBI_XML_ERR;\n    }\n    xml_ret = xmlTextWriterWriteAttribute(writer, BAD_CAST \"name\", BAD_CAST name);\n    if (xml_ret < 0) {\n        debug_print(\"XML error: %i (name: %s, content: %s)\\n\", xml_ret, name, content);\n        return MOBI_XML_ERR;\n    }\n    xml_ret = xmlTextWriterWriteAttribute(writer, BAD_CAST \"content\", BAD_CAST content);\n    if (xml_ret < 0) {\n        debug_print(\"XML error: %i (name: %s, content: %s)\\n\", xml_ret, name, content);\n        return MOBI_XML_ERR;\n    }\n    xml_ret = xmlTextWriterEndElement(writer);\n    if (xml_ret < 0) {\n        debug_print(\"XML error: %i (name: %s, content: %s)\\n\", xml_ret, name, content);\n        return MOBI_XML_ERR;\n    }\n    return MOBI_SUCCESS;\n}\n\n\n/**\n @brief Add reconstruced opf part to rawml\n \n @param[in] opf_xml OPF xml string\n @param[in,out] rawml New data will be added to MOBIRawml rawml->resources structure\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_opf_add_to_rawml(const char *opf_xml, MOBIRawml *rawml) {\n    MOBIPart *opf_part;\n    size_t uid = 0;\n    if (rawml->resources) {\n        MOBIPart *part = rawml->resources;\n        while (part->next) {\n            part = part->next;\n        }\n        uid = part->uid + 1;\n        part->next = calloc(1, sizeof(MOBIPart));\n        opf_part = part->next;\n    }\n    else {\n        rawml->resources = calloc(1, sizeof(MOBIPart));\n        opf_part = rawml->resources;\n    }\n    if (opf_part == NULL) {\n        return MOBI_MALLOC_FAILED;\n    }\n    opf_part->uid = uid;\n    opf_part->next = NULL;\n    opf_part->data = (unsigned char *) strdup(opf_xml);\n    if (opf_part->data == NULL) {\n        free(opf_part);\n        opf_part = NULL;\n        return MOBI_MALLOC_FAILED;\n    }\n    opf_part->size = strlen(opf_xml);\n    opf_part->type = T_OPF;\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Add reconstruced ncx part to rawml\n \n @param[in] ncx_xml OPF xml string\n @param[in,out] rawml New data will be added to MOBIRawml rawml->resources structure\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_ncx_add_to_rawml(const char *ncx_xml, MOBIRawml *rawml) {\n    MOBIPart *ncx_part;\n    size_t uid = 0;\n    if (rawml->resources) {\n        MOBIPart *part = rawml->resources;\n        while (part->next) {\n            part = part->next;\n        }\n        uid = part->uid + 1;\n        part->next = calloc(1, sizeof(MOBIPart));\n        ncx_part = part->next;\n    }\n    else {\n        rawml->resources = calloc(1, sizeof(MOBIPart));\n        ncx_part = rawml->resources;\n    }\n    if (ncx_part == NULL) {\n        return MOBI_MALLOC_FAILED;\n    }\n    ncx_part->uid = uid;\n    ncx_part->next = NULL;\n    ncx_part->data = (unsigned char *) strdup(ncx_xml);\n    if (ncx_part->data == NULL) {\n        free(ncx_part);\n        ncx_part = NULL;\n        return MOBI_MALLOC_FAILED;\n    }\n    ncx_part->size = strlen(ncx_xml);\n    ncx_part->type = T_NCX;\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Write ncx header\n \n @param[in,out] writer xmlTextWriterPtr to write to\n @param[in] opf OPF structure to fetch some data\n @param[in] maxlevel Value of dtb:depth attribute\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_write_ncx_header(xmlTextWriterPtr writer, const OPF *opf, uint32_t maxlevel) {\n    /* write header */\n    char depth[10 + 1];\n    snprintf(depth, 11, \"%d\", maxlevel);\n\n    /* <head> */\n    int xml_ret = xmlTextWriterStartElement(writer, BAD_CAST \"head\");\n    if (xml_ret < 0) { return MOBI_XML_ERR; }\n    /* meta uid */\n    MOBI_RET ret = mobi_xml_write_meta(writer, \"dtb:uid\", opf->metadata->dc_meta->identifier[0]->value);\n    if (ret != MOBI_SUCCESS) { return ret; }\n    /* meta depth */\n    ret = mobi_xml_write_meta(writer, \"dtb:depth\", depth);\n    if (ret != MOBI_SUCCESS) { return ret; }\n    /* meta pagecount */\n    ret = mobi_xml_write_meta(writer, \"dtb:totalPageCount\", \"0\");\n    if (ret != MOBI_SUCCESS) { return ret; }\n    /* meta pagenumber */\n    ret = mobi_xml_write_meta(writer, \"dtb:maxPageNumber\", \"0\");\n    if (ret != MOBI_SUCCESS) { return ret; }\n    xml_ret = xmlTextWriterEndElement(writer);\n    if (xml_ret < 0) { return MOBI_XML_ERR; }\n    // <docTitle>\n    xml_ret = xmlTextWriterStartElement(writer, BAD_CAST \"docTitle\");\n    if (xml_ret < 0) { return MOBI_XML_ERR; }\n    xml_ret = xmlTextWriterStartElement(writer, BAD_CAST \"text\");\n    if (xml_ret < 0) { return MOBI_XML_ERR; }\n    xml_ret = xmlTextWriterWriteString(writer, BAD_CAST opf->metadata->dc_meta->title[0]);\n    if (xml_ret < 0) { return MOBI_XML_ERR; }\n    xml_ret = xmlTextWriterEndElement(writer);\n    if (xml_ret < 0) { return MOBI_XML_ERR; }\n    xml_ret = xmlTextWriterEndElement(writer);\n    if (xml_ret < 0) { return MOBI_XML_ERR; }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Build ncx document using libxml2 and append it to rawml\n \n @param[in,out] rawml MOBIRawml structure\n @param[in] ncx Array of NCX structures with ncx content\n @param[in] opf OPF structure to fetch some data\n @param[in] maxlevel Value of dtb:depth attribute\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_write_ncx(MOBIRawml *rawml, const NCX *ncx, const OPF *opf, uint32_t maxlevel) {\n    const xmlChar * NCXNamespace = BAD_CAST \"http://www.daisy.org/z3986/2005/ncx/\";\n    xmlBufferPtr buf = xmlBufferCreate();\n    if (buf == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    xmlTextWriterPtr writer = xmlNewTextWriterMemory(buf, 0);\n    if (writer == NULL) {\n        xmlBufferFree(buf);\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    xmlTextWriterSetIndent(writer, 1);\n    int xml_ret = xmlTextWriterStartDocument(writer, NULL, NULL, NULL);\n    if (xml_ret < 0) { goto cleanup; }\n    xml_ret = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST \"ncx\", NCXNamespace);\n    if (xml_ret < 0) { goto cleanup; }\n    xml_ret = xmlTextWriterWriteAttribute(writer, BAD_CAST \"version\", BAD_CAST \"2005-1\");\n    if (xml_ret < 0) { goto cleanup; }\n    xml_ret = xmlTextWriterWriteAttribute(writer, BAD_CAST \"xml:lang\", BAD_CAST opf->metadata->dc_meta->language[0]);\n    if (xml_ret < 0) { goto cleanup; }\n    \n    MOBI_RET ret = mobi_write_ncx_header(writer, opf, maxlevel);\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    \n    /* start <navMap> */\n    xml_ret = xmlTextWriterStartElement(writer, BAD_CAST \"navMap\");\n    if (xml_ret < 0) { goto cleanup; }\n    if (ncx && rawml->ncx->entries_count > 0) {\n        const size_t count = rawml->ncx->entries_count;\n        size_t seq = 1;\n        ret = mobi_write_ncx_level(writer, ncx, 0, 0, count - 1, &seq);\n        if (ret != MOBI_SUCCESS) { goto cleanup; }\n    }\n\n    /* end <navMap> */\n    xml_ret = xmlTextWriterEndDocument(writer);\n    if (xml_ret < 0) { goto cleanup; }\n    xmlFreeTextWriter(writer);\n    const char *ncx_xml = (const char *) buf->content;\n    mobi_ncx_add_to_rawml(ncx_xml, rawml);\n    xmlBufferFree(buf);\n    return MOBI_SUCCESS;\n    \ncleanup:\n    xmlFreeTextWriter(writer);\n    xmlBufferFree(buf);\n    debug_print(\"%s\\n\", \"XML writing failed\");\n    return MOBI_XML_ERR;\n}\n\n\n/**\n @brief Free array of ncx entries\n \n @param[in] ncx Array of NCX structures with ncx content\n @param[in] count Size of the array\n */\nvoid mobi_free_ncx(NCX *ncx, size_t count) {\n    if (ncx) {\n        while (count--) {\n            free(ncx[count].target);\n            free(ncx[count].text);\n        }\n        free(ncx);\n    }\n}\n\n/**\n @brief Parse ncx index, recreate ncx document and append it to rawml\n \n @param[in,out] rawml MOBIRawml structure\n @param[in] opf OPF structure to fetch some data\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_build_ncx(MOBIRawml *rawml, const OPF *opf) {\n    /* parse ncx data */\n    if (rawml == NULL) {\n        debug_print(\"%s\\n\", \"Initialization failed\");\n        return MOBI_INIT_FAILED;\n    }\n    if (rawml->ncx && rawml->ncx->cncx_record) {\n        size_t i = 0;\n        uint32_t maxlevel = 0;\n        MOBI_RET ret;\n        const size_t count = rawml->ncx->entries_count;\n        if (count == 0) {\n            return MOBI_SUCCESS;\n        }\n        NCX *ncx = malloc(count * sizeof(NCX));\n        if (ncx == NULL) {\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        MOBIAttrType pref_attr = ATTR_ID;\n        while (i < count) {\n            const MOBIIndexEntry *ncx_entry = &rawml->ncx->entries[i];\n            const char *label = ncx_entry->label;\n            const size_t id = strtoul(label, NULL, 16);\n            uint32_t cncx_offset;\n            ret = mobi_get_indxentry_tagvalue(&cncx_offset, ncx_entry, INDX_TAG_NCX_TEXT_CNCX);\n            if (ret != MOBI_SUCCESS) {\n                mobi_free_ncx(ncx, i);\n                return ret;\n            }\n            const MOBIPdbRecord *cncx_record = rawml->ncx->cncx_record;\n            char *text = mobi_get_cncx_string_utf8(cncx_record, cncx_offset, rawml->ncx->encoding);\n            if (text == NULL) {\n                mobi_free_ncx(ncx, i);\n                debug_print(\"%s\\n\", \"Memory allocation failed\");\n                return MOBI_MALLOC_FAILED;\n            }\n            char *target = malloc(MOBI_ATTRNAME_MAXSIZE + 1);\n            if (target == NULL) {\n                free(text);\n                mobi_free_ncx(ncx, i);\n                debug_print(\"%s\\n\", \"Memory allocation failed\");\n                return MOBI_MALLOC_FAILED;\n            }\n            if (mobi_is_rawml_kf8(rawml)) {\n                uint32_t posfid;\n                ret = mobi_get_indxentry_tagvalue(&posfid, ncx_entry, INDX_TAG_NCX_POSFID);\n                if (ret != MOBI_SUCCESS) {\n                    free(text);\n                    free(target);\n                    mobi_free_ncx(ncx, i);\n                    return ret;\n                }\n                uint32_t posoff;\n                ret = mobi_get_indxentry_tagvalue(&posoff, ncx_entry, INDX_TAG_NCX_POSOFF);\n                if (ret != MOBI_SUCCESS) {\n                    free(text);\n                    free(target);\n                    mobi_free_ncx(ncx, i);\n                    return ret;\n                }\n                uint32_t filenumber;\n                char targetid[MOBI_ATTRNAME_MAXSIZE + 1];\n                ret = mobi_get_id_by_posoff(&filenumber, targetid, rawml, posfid, posoff, &pref_attr);\n                if (ret != MOBI_SUCCESS) {\n                    free(text);\n                    free(target);\n                    mobi_free_ncx(ncx, i);\n                    return ret;\n                }\n                /* FIXME: posoff == 0 means top of file? */\n                if (posoff) {\n                    int n = snprintf(target, MOBI_ATTRNAME_MAXSIZE + 1, \"part%05u.html#%s\", filenumber, targetid);\n                    if (n > MOBI_ATTRVALUE_MAXSIZE + 1) {\n                        debug_print(\"Warning: truncated target: %s\\n\", target);\n                        snprintf(target, MOBI_ATTRNAME_MAXSIZE + 1, \"part%05u.html\", filenumber);\n                    }\n                } else {\n                    snprintf(target, MOBI_ATTRNAME_MAXSIZE + 1, \"part%05u.html\", filenumber);\n                }\n                \n            } else {\n                uint32_t filepos;\n                ret = mobi_get_indxentry_tagvalue(&filepos, ncx_entry, INDX_TAG_NCX_FILEPOS);\n                if (ret != MOBI_SUCCESS) {\n                    free(text);\n                    free(target);\n                    mobi_free_ncx(ncx, i);\n                    return ret;\n                }\n                snprintf(target, MOBI_ATTRNAME_MAXSIZE + 1, \"part00000.html#%010u\", filepos);\n            }\n            uint32_t level;\n            ret = mobi_get_indxentry_tagvalue(&level, ncx_entry, INDX_TAG_NCX_LEVEL);\n            if (ret != MOBI_SUCCESS) {\n                free(text);\n                free(target);\n                mobi_free_ncx(ncx, i);\n                return ret;\n            }\n            if (level > maxlevel) {\n                maxlevel = level;\n            }\n            uint32_t parent = MOBI_NOTSET;\n            ret = mobi_get_indxentry_tagvalue(&parent, ncx_entry, INDX_TAG_NCX_PARENT);\n            if (ret == MOBI_INIT_FAILED) {\n                free(text);\n                free(target);\n                mobi_free_ncx(ncx, i);\n                return ret;\n            }\n            uint32_t first_child = MOBI_NOTSET;\n            ret = mobi_get_indxentry_tagvalue(&first_child, ncx_entry, INDX_TAG_NCX_CHILD_START);\n            if (ret == MOBI_INIT_FAILED) {\n                free(text);\n                free(target);\n                mobi_free_ncx(ncx, i);\n                return ret;\n            }\n            uint32_t last_child = MOBI_NOTSET;\n            ret = mobi_get_indxentry_tagvalue(&last_child, ncx_entry, INDX_TAG_NCX_CHILD_END);\n            if (ret == MOBI_INIT_FAILED) {\n                free(text);\n                free(target);\n                mobi_free_ncx(ncx, i);\n                return ret;\n            }\n            if ((first_child != MOBI_NOTSET && first_child >= rawml->ncx->entries_count) ||\n                (last_child != MOBI_NOTSET && last_child >= rawml->ncx->entries_count) ||\n                (parent != MOBI_NOTSET && parent >= rawml->ncx->entries_count)) {\n                free(text);\n                free(target);\n                mobi_free_ncx(ncx, i);\n                return MOBI_DATA_CORRUPT;\n            }\n            debug_print(\"seq=%zu, id=%zu, text='%s', target='%s', level=%u, parent=%u, fchild=%u, lchild=%u\\n\", i, id, text, target, level, parent, first_child, last_child);\n            ncx[i++] = (NCX) {id, text, target, level, parent, first_child, last_child};\n        }\n        mobi_write_ncx(rawml, ncx, opf, maxlevel);\n        mobi_free_ncx(ncx, count);\n    } else {\n        mobi_write_ncx(rawml, NULL, opf, 1);\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Copy text data from EXTH record to array of strings\n \n It will allocate memory for the array if not already allocated.\n It will find first array index that is not already used\n \n @param[in] m MOBIData structure\n @param[in] exth MOBIExthHeader record\n @param[in,out] array Array into which text string will be inserted\n */\nstatic void mobi_opf_fill_tag(const MOBIData *m, const MOBIExthHeader *exth, char ***array) {\n    if (*array == NULL) {\n        *array = calloc(OPF_META_MAX_TAGS, sizeof(**array));\n        if (*array == NULL) {\n            return;\n        }\n    }\n    size_t i = 0;\n    while (i < OPF_META_MAX_TAGS) {\n        /* find first free slot */\n        if((*array)[i] != NULL) { i++; continue; }\n        MOBIExthMeta exth_tag = mobi_get_exthtagmeta_by_tag(exth->tag);\n        char *value = NULL;\n        if (exth_tag.type == EXTH_NUMERIC) {\n            value = malloc(10 + 1);\n            if (value) {\n                const uint32_t val32 = mobi_decode_exthvalue(exth->data, exth->size);\n                snprintf(value, 10 + 1, \"%d\", val32);\n            }\n        } else if (exth_tag.type == EXTH_STRING) {\n            value = mobi_decode_exthstring(m, exth->data, exth->size);\n        }\n        if (value) {\n            (*array)[i] = value;\n        }\n        return;\n    }\n    /* not enough tags */\n    debug_print(\"OPF_META_MAX_TAGS = %i reached\\n\", OPF_META_MAX_TAGS);\n}\n\n/**\n @brief Set values for attributes of OPF <meta/> tag\n \n It will allocate memory for the OPFmeta members: name and content.\n It will find first array index that is not already used\n \n @param[in,out] meta Array of OPFmeta structures to be filled with data\n @param[in] name Value of the name attribute\n @param[in] content Value of the content attribute\n */\nstatic void mobi_opf_set_meta(OPFmeta **meta, const char *name, const char *content) {\n    size_t i = 0;\n    while (i < OPF_META_MAX_TAGS) {\n        /* find first free slot */\n        if(meta[i] != NULL) { i++; continue; }\n        meta[i] = malloc(sizeof(OPFmeta));\n        if (meta[i] == NULL) {\n            return;\n        }\n        meta[i]->name = strdup(name);\n        meta[i]->content = strdup(content);\n        if (meta[i]->name == NULL || meta[i]->content == NULL) {\n            free(meta[i]);\n            meta[i] = NULL;\n        }\n        return;\n    }\n    /* not enough tags */\n    debug_print(\"OPF_META_MAX_TAGS = %i reached\\n\", OPF_META_MAX_TAGS);\n}\n\n/**\n @brief Set values for attributes of OPF <meta/> tag\n \n It will allocate memory for the OPFmeta members: name and content.\n Content attribute will be copied from EXTH record.\n It will find first array index that is not already used\n \n @param[in] m MOBIData structure\n @param[in] exth MOBIExthHeader structure containing EXTH records\n @param[in,out] meta Array of OPFmeta structures to be filled with data\n @param[in] name Value of the name attribute\n */\nstatic void mobi_opf_copy_meta(const MOBIData *m, const MOBIExthHeader *exth, OPFmeta **meta, const char *name) {\n    MOBIExthMeta exth_tag = mobi_get_exthtagmeta_by_tag(exth->tag);\n    char *content = NULL;\n    if (exth_tag.tag == EXTH_COVEROFFSET) {\n        content = malloc(13 + 1);\n        if (content) {\n            const uint32_t val32 = mobi_decode_exthvalue(exth->data, exth->size);\n            snprintf(content, 14, \"resource%05d\", val32);\n        }\n    } else if (exth_tag.type == EXTH_NUMERIC) {\n        content = malloc(10 + 1);\n        if (content) {\n            const uint32_t val32 = mobi_decode_exthvalue(exth->data, exth->size);\n            snprintf(content, 11, \"%d\", val32);\n        }\n    } else if (exth_tag.type == EXTH_STRING) {\n        char *string = mobi_decode_exthstring(m, exth->data, exth->size);\n        content = string;\n    }\n    if (content) {\n        mobi_opf_set_meta(meta, name, content);\n        free(content);\n    }\n}\n\n/**\n @brief Set values for attributes of OPF manifest <item/> tag\n \n It will allocate memory for the OPFitem members: id, href and media-type.\n It will find first array index that is not already used\n \n @param[in,out] meta Array of OPFmeta structures to be filled with data\n @param[in] name Value of the name attribute\n @param[in] content Value of the content attribute\n */\nvoid mobi_opf_set_item(OPFmeta **meta, const char *name, const char *content) {\n    size_t i = 0;\n    while (i < OPF_META_MAX_TAGS) {\n        /* find first free slot */\n        if(meta[i] != NULL) { i++; continue; }\n        meta[i] = malloc(sizeof(OPFmeta));\n        if (meta[i] == NULL) {\n            return;\n        }\n        meta[i]->name = strdup(name);\n        meta[i]->content = strdup(content);\n        if (meta[i]->name == NULL || meta[i]->content == NULL) {\n            free(meta[i]);\n            meta[i] = NULL;\n        }\n        return;\n    }\n    /* not enough tags */\n    debug_print(\"OPF_META_MAX_TAGS = %i reached\\n\", OPF_META_MAX_TAGS);\n}\n\n/**\n @brief Copy text data from EXTH record to \"member_name\" member of a structure with given type\n \n Data will copied from curr->data.\n It will allocate memory for the array of structures if not already allocated.\n It will find first array index that is not already used\n \n @param[in] mobidata Mobidata structure\n @param[in] struct_type Structure type defined with typedef\n @param[in] struct_element Member member_name of this structure will be set to EXTH data\n @param[in] member_name Structure member name that will be modified\n */\n#define mobi_opf_copy_tagtype(mobidata, struct_type, struct_element, member_name) { \\\n    if (struct_element == NULL) { \\\n        struct_element = calloc(OPF_META_MAX_TAGS, sizeof(*struct_element)); \\\n        if(struct_element == NULL) { \\\n            debug_print(\"%s\\n\", \"Memory allocation failed\"); \\\n            return MOBI_MALLOC_FAILED; \\\n        } \\\n    } \\\n    struct_type **element = struct_element; \\\n    size_t i = 0; \\\n    while (i < OPF_META_MAX_TAGS) { \\\n        /* find first free slot */ \\\n        if(element[i] != NULL) { \\\n            if(element[i]->member_name != NULL) { i++; continue; } \\\n        } else { \\\n            element[i] = calloc(1, sizeof(*element[i])); \\\n            if(element[i] == NULL) { \\\n                debug_print(\"%s\\n\", \"Memory allocation failed\"); \\\n                return MOBI_MALLOC_FAILED; \\\n            } \\\n        } \\\n        MOBIExthMeta exth_tag = mobi_get_exthtagmeta_by_tag(curr->tag); \\\n        char *value = NULL; \\\n        MOBI_RET error_ret = MOBI_DATA_CORRUPT; \\\n        if (exth_tag.type == EXTH_NUMERIC) { \\\n            value = malloc(10 + 1); \\\n            if (value) { \\\n                const uint32_t val32 = mobi_decode_exthvalue(curr->data, curr->size); \\\n                snprintf(value, 10 + 1, \"%d\", val32); \\\n            } else { \\\n                error_ret = MOBI_MALLOC_FAILED; \\\n            } \\\n        } else if (exth_tag.type == EXTH_STRING) { \\\n            value = mobi_decode_exthstring(mobidata, curr->data, curr->size); \\\n        } \\\n        if(value == NULL) { \\\n            free(element[i]); \\\n            element[i] = NULL; \\\n            debug_print(\"%s\\n\", \"Decoding failed\"); \\\n            return error_ret; \\\n        } \\\n        element[i]->member_name = value; \\\n        break; \\\n    } \\\n    if (i == OPF_META_MAX_TAGS) { \\\n    /* not enough tags */ \\\n    debug_print(\"OPF_META_MAX_TAGS = %i reached\\n\", OPF_META_MAX_TAGS); \\\n    } \\\n}\n\n/**\n @brief Set \"member_name\" member of a structure with given type to string value\n \n It will allocate memory for the array of structures if not already allocated.\n It will find first array index that is not already used\n \n @param[in] struct_type Structure type defined with typedef\n @param[in] struct_element Member member_name of this structure will be set to EXTH data\n @param[in] member_name Structure member name that will be modified\n @param[in] string String value that will be assigned to the structure memeber\n */\n#define mobi_opf_set_tagtype(struct_type, struct_element, member_name, string) { \\\n    if (struct_element == NULL) { \\\n        struct_element = calloc(OPF_META_MAX_TAGS, sizeof(*struct_element)); \\\n        if(struct_element == NULL) { \\\n            debug_print(\"%s\\n\", \"Memory allocation failed\"); \\\n            return MOBI_MALLOC_FAILED; \\\n        } \\\n    } \\\n    struct_type **element = struct_element; \\\n    size_t i = 0; \\\n    while (i < OPF_META_MAX_TAGS) { \\\n        /* find first free slot */ \\\n        if(element[i] != NULL) { \\\n            if(element[i]->member_name != NULL) { i++; continue; } \\\n        } else { \\\n            element[i] = calloc(1, sizeof(*element[i])); \\\n            if(element[i] == NULL) { \\\n                debug_print(\"%s\\n\", \"Memory allocation failed\"); \\\n                return MOBI_MALLOC_FAILED; \\\n            } \\\n        } \\\n        element[i]->member_name = strdup(string); \\\n        if(element[i]->member_name == NULL) { \\\n            free(element[i]); \\\n            element[i] = NULL; \\\n            debug_print(\"%s\\n\", \"Memory allocation failed\"); \\\n            return MOBI_MALLOC_FAILED; \\\n        } \\\n        break; \\\n    } \\\n    if (i == OPF_META_MAX_TAGS) { \\\n        /* not enough tags */ \\\n        debug_print(\"OPF_META_MAX_TAGS = %i reached\\n\", OPF_META_MAX_TAGS); \\\n    } \\\n}\n\n/**\n @brief Copy text data from EXTH record to OPFmetadata tags structure\n \n @param[in,out] metadata Structure OPFmetadata will be filled with parsed data\n @param[in] m MOBIData structure with loaded data\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_get_opf_from_exth(OPFmetadata *metadata, const MOBIData *m) {\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    if (m->eh == NULL) {\n        return MOBI_INIT_FAILED;\n    }\n    MOBIExthHeader *curr = m->eh;\n    /* iterate through EXTH records */\n    while (curr != NULL) {\n        switch (curr->tag) {\n                /* <dc-metadata/> */\n            case EXTH_DESCRIPTION:\n                mobi_opf_fill_tag(m, curr, &metadata->dc_meta->description);\n                break;\n            case EXTH_LANGUAGE:\n                mobi_opf_fill_tag(m, curr, &metadata->dc_meta->language);\n                break;\n            case EXTH_PUBLISHER:\n                mobi_opf_fill_tag(m, curr, &metadata->dc_meta->publisher);\n                break;\n            case EXTH_RIGHTS:\n                mobi_opf_fill_tag(m, curr, &metadata->dc_meta->rights);\n                break;\n            case EXTH_SOURCE:\n                mobi_opf_fill_tag(m, curr, &metadata->dc_meta->source);\n                break;\n            case EXTH_TITLE:\n            case EXTH_UPDATEDTITLE:\n                mobi_opf_fill_tag(m, curr, &metadata->dc_meta->title);\n                break;\n            case EXTH_TYPE:\n                mobi_opf_fill_tag(m, curr, &metadata->dc_meta->type);\n                break;\n            case EXTH_AUTHOR:\n                mobi_opf_copy_tagtype(m, OPFcreator, metadata->dc_meta->creator, value);\n                break;\n            case EXTH_CONTRIBUTOR:\n                mobi_opf_copy_tagtype(m, OPFcreator, metadata->dc_meta->contributor, value);\n                break;\n            case EXTH_SUBJECT:\n                mobi_opf_copy_tagtype(m, OPFsubject, metadata->dc_meta->subject, value);\n                break;\n            case EXTH_SUBJECTCODE:\n                mobi_opf_copy_tagtype(m, OPFsubject, metadata->dc_meta->subject, basic_code);\n                break;\n            case EXTH_ISBN:\n                mobi_opf_copy_tagtype(m, OPFidentifier, metadata->dc_meta->identifier, value);\n                mobi_opf_set_tagtype(OPFidentifier, metadata->dc_meta->identifier, scheme, \"ISBN\");\n                break;\n            case EXTH_PUBLISHINGDATE:\n                mobi_opf_copy_tagtype(m, OPFdate, metadata->dc_meta->date, value);\n                mobi_opf_set_tagtype(OPFdate, metadata->dc_meta->date, event, \"publication\");\n                break;\n                /* <x-metadata/> */\n            case EXTH_ADULT:\n                mobi_opf_fill_tag(m, curr, &metadata->x_meta->adult);\n                break;\n            case EXTH_DICTNAME:\n                mobi_opf_fill_tag(m, curr, &metadata->x_meta->dict_short_name);\n                break;\n            case EXTH_DICTLANGIN:\n                mobi_opf_fill_tag(m, curr, &metadata->x_meta->dictionary_in_lang);\n                break;\n            case EXTH_DICTLANGOUT:\n                mobi_opf_fill_tag(m, curr, &metadata->x_meta->dictionary_out_lang);\n                break;\n            case EXTH_IMPRINT:\n                mobi_opf_fill_tag(m, curr, &metadata->x_meta->imprint);\n                break;\n            case EXTH_REVIEW:\n                mobi_opf_fill_tag(m, curr, &metadata->x_meta->review);\n                break;\n            case EXTH_PRICE:\n                mobi_opf_copy_tagtype(m, OPFsrp, metadata->x_meta->srp, value);\n                break;\n            case EXTH_CURRENCY:\n                mobi_opf_copy_tagtype(m, OPFsrp, metadata->x_meta->srp, currency);\n                break;\n                /* <meta/> */\n            case EXTH_FIXEDLAYOUT:\n                mobi_opf_copy_meta(m, curr, metadata->meta, \"fixed-layout\");\n                break;\n            case EXTH_BOOKTYPE:\n                mobi_opf_copy_meta(m, curr, metadata->meta, \"book-type\");\n                break;\n            case EXTH_ORIENTATIONLOCK:\n                mobi_opf_copy_meta(m, curr, metadata->meta, \"orientation-lock\");\n                break;\n            case EXTH_ORIGRESOLUTION:\n                mobi_opf_copy_meta(m, curr, metadata->meta, \"original-resolution\");\n                break;\n            case EXTH_ZEROGUTTER:\n                mobi_opf_copy_meta(m, curr, metadata->meta, \"zero-gutter\");\n                break;\n            case EXTH_ZEROMARGIN:\n                mobi_opf_copy_meta(m, curr, metadata->meta, \"zero-margin\");\n                break;\n            case EXTH_REGIONMAGNI:\n                mobi_opf_copy_meta(m, curr, metadata->meta, \"region-mag\");\n                break;\n            case EXTH_ALIGNMENT:\n                mobi_opf_copy_meta(m, curr, metadata->meta, \"primary-writing-mode\");\n                break;\n            case EXTH_OVERRIDEFONTS:\n                mobi_opf_copy_meta(m, curr, metadata->meta, \"override-kindle-fonts\");\n                break;\n            case EXTH_COVEROFFSET:\n                mobi_opf_copy_meta(m, curr, metadata->meta, \"cover\");\n                break;\n            default:\n                break;\n        }\n        curr = curr->next;\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Recreate OPF structure\n \n @param[in,out] opf Structure OPF->OPFmetadata will be filled with parsed data\n @param[in] m MOBIData structure containing document metadata\n @param[in] rawml MOBIRawml structure containing parsed records\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_build_opf_metadata(OPF *opf,  const MOBIData *m, const MOBIRawml *rawml) {\n    if (m == NULL) {\n        debug_print(\"%s\\n\", \"Initialization failed\");\n        return MOBI_INIT_FAILED;\n    }\n    opf->metadata = calloc(1, sizeof(OPFmetadata));\n    if (opf->metadata == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    /* initialize metadata sub-elements */\n    opf->metadata->meta = calloc(OPF_META_MAX_TAGS, sizeof(OPFmeta*));\n    if (opf->metadata->meta == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    opf->metadata->dc_meta = calloc(1, sizeof(OPFdcmeta));\n    if (opf->metadata->dc_meta == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    opf->metadata->x_meta = calloc(1, sizeof(OPFxmeta));\n    if (opf->metadata->x_meta == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    if (m->eh) {\n        MOBI_RET ret = mobi_get_opf_from_exth(opf->metadata, m);\n        if (ret != MOBI_SUCCESS) {\n            return ret;\n        }\n    }\n    /* check for required elements */\n    if (opf->metadata->dc_meta->identifier == NULL) {\n        /* default id will be \"0\" */\n        char uid_string[11] = \"0\";\n        if (m->mh && m->mh->uid) {\n            snprintf(uid_string, 11, \"%u\", *m->mh->uid);\n        }\n        mobi_opf_set_tagtype(OPFidentifier, opf->metadata->dc_meta->identifier, value, uid_string);\n        mobi_opf_set_tagtype(OPFidentifier, opf->metadata->dc_meta->identifier, id, \"uid\");\n    } else {\n        opf->metadata->dc_meta->identifier[0]->id = strdup(\"uid\");\n    }\n    if (opf->metadata->dc_meta->title == NULL) {\n        opf->metadata->dc_meta->title = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n        if (opf->metadata->dc_meta->title == NULL) {\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        char *title = mobi_meta_get_title(m);\n        if (title == NULL) {\n            title = strdup(\"Unknown\");\n        }\n        opf->metadata->dc_meta->title[0] = title;\n    }\n    if (opf->metadata->dc_meta->language == NULL) {\n        opf->metadata->dc_meta->language = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n        if (opf->metadata->dc_meta->language == NULL) {\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        const char *lang_string = NULL;\n        if (m->mh && m->mh->locale) {\n            uint32_t lang_code = *m->mh->locale;\n            lang_string = mobi_get_locale_string(lang_code);\n        }\n        if (lang_string) {\n            opf->metadata->dc_meta->language[0] = strdup(lang_string);\n        } else {\n            opf->metadata->dc_meta->language[0] = strdup(\"en\");\n        }\n    }\n    /* write optional elements */\n    if (mobi_is_dictionary(m)) {\n        if (opf->metadata->x_meta->dictionary_in_lang == NULL) {\n            if (m->mh && m->mh->dict_input_lang) {\n                opf->metadata->x_meta->dictionary_in_lang = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n                if (opf->metadata->x_meta->dictionary_in_lang == NULL) {\n                    debug_print(\"%s\\n\", \"Memory allocation failed\");\n                    return MOBI_MALLOC_FAILED;\n                }\n                uint32_t dict_lang_in = *m->mh->dict_input_lang;\n                opf->metadata->x_meta->dictionary_in_lang[0] = strdup(mobi_get_locale_string(dict_lang_in));\n            }\n        }\n        if (opf->metadata->x_meta->dictionary_out_lang == NULL) {\n            if (m->mh && m->mh->dict_output_lang) {\n                opf->metadata->x_meta->dictionary_out_lang = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n                if (opf->metadata->x_meta->dictionary_out_lang == NULL) {\n                    debug_print(\"%s\\n\", \"Memory allocation failed\");\n                    return MOBI_MALLOC_FAILED;\n                }\n                uint32_t dict_lang_in = *m->mh->dict_output_lang;\n                opf->metadata->x_meta->dictionary_out_lang[0] = strdup(mobi_get_locale_string(dict_lang_in));\n            }\n        }\n        if (rawml->orth->orth_index_name) {\n            opf->metadata->x_meta->default_lookup_index = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n            if (opf->metadata->x_meta->default_lookup_index == NULL) {\n                debug_print(\"%s\\n\", \"Memory allocation failed\");\n                return MOBI_MALLOC_FAILED;\n            }\n            opf->metadata->x_meta->default_lookup_index[0] = strdup(rawml->orth->orth_index_name);\n        }\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Write array of xml elements of given name to XML buffer\n \n Wrapper for libxml2 xmlTextWriterWriteElementNS() function.\n Writes xml element for each not-null entry in the input array.\n \n @param[in,out] writer xmlTextWriterPtr to write to\n @param[in] name XML element name\n @param[in] content Array of XML element contents\n @param[in] ns XML namespace string or NULL if empty\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_xml_write_element_ns(xmlTextWriterPtr writer, const char *name, const char **content, const char *ns) {\n    if (content) {\n        size_t i = 0;\n        while (i < OPF_META_MAX_TAGS) {\n            if (content[i] == NULL) {\n                break;\n            }\n            xmlChar *namespace = NULL;\n            if (ns) {\n                namespace = BAD_CAST ns;\n            }\n            int xml_ret = xmlTextWriterWriteElementNS(writer, namespace, BAD_CAST name, NULL, BAD_CAST content[i]);\n            if (xml_ret < 0) {\n                debug_print(\"XML error: %i (name: %s, content: %s)\\n\", xml_ret, name, content[i]);\n                return MOBI_XML_ERR;\n            }\n            i++;\n        }\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Write array of Dublin Core elements of given name to XML buffer\n \n Wrapper for libxml2 xmlTextWriterWriteElementNS() function.\n Writes xml element for each not-null entry in the input array.\n \n @param[in,out] writer xmlTextWriterPtr to write to\n @param[in] name XML element name\n @param[in] content Array of XML element contents\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_xml_write_dcmeta(xmlTextWriterPtr writer, const char *name, const char **content) {\n    return mobi_xml_write_element_ns(writer, name, content, \"dc\");\n}\n\n/**\n @brief Write array of custom MOBI elements of given name to XML buffer\n \n Wrapper for libxml2 xmlTextWriterWriteElementNS() function.\n Writes xml element for each not-null entry in the input array.\n \n @param[in,out] writer xmlTextWriterPtr to write to\n @param[in] name XML element name\n @param[in] content Array of XML element contents\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_xml_write_xmeta(xmlTextWriterPtr writer, const char *name, const char **content) {\n    return mobi_xml_write_element_ns(writer, name, content, NULL);\n}\n\n/**\n @brief Write array of <meta/> elements to XML buffer\n \n Wrapper for libxml2 xmlTextWriterWriteElement() function.\n Writes xml element for each not-null entry in the input array.\n \n @param[in,out] writer xmlTextWriterPtr to write to\n @param[in] meta Array of OPFmeta structures\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_xml_write_opfmeta(xmlTextWriterPtr writer, const OPFmeta **meta) {\n    if (meta) {\n        size_t i = 0;\n        while (i < OPF_META_MAX_TAGS) {\n            if (meta[i] == NULL) {\n                break;\n            }\n            MOBI_RET ret = mobi_xml_write_meta(writer, meta[i]->name, meta[i]->content);\n            if (ret != MOBI_SUCCESS) {\n                return ret;\n            }\n            i++;\n        }\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Write array of <referenece/> elements to XML buffer\n \n Wrapper for libxml2 xmlTextWriterWriteElement() function.\n Writes xml element for each not-null entry in the input array.\n \n @param[in,out] writer xmlTextWriterPtr to write to\n @param[in] reference Array of OPFreference structures\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_xml_write_reference(xmlTextWriterPtr writer, const OPFreference **reference) {\n    if (reference) {\n        size_t i = 0;\n        while (i < OPF_META_MAX_TAGS) {\n            if (reference[i] == NULL) {\n                break;\n            }\n            int xml_ret;\n            xml_ret = xmlTextWriterStartElement(writer, BAD_CAST \"reference\");\n            if (xml_ret < 0) {\n                debug_print(\"XML error: %i (reference type: %s)\\n\", xml_ret, reference[i]->type);\n                return MOBI_XML_ERR;\n            }\n            xml_ret = xmlTextWriterWriteAttribute(writer, BAD_CAST \"type\", BAD_CAST reference[i]->type);\n            if (xml_ret < 0) {\n                debug_print(\"XML error: %i (reference type: %s)\\n\", xml_ret, reference[i]->type);\n                return MOBI_XML_ERR;\n            }\n            xml_ret = xmlTextWriterWriteAttribute(writer, BAD_CAST \"title\", BAD_CAST reference[i]->title);\n            if (xml_ret < 0) {\n                debug_print(\"XML error: %i (reference type: %s)\\n\", xml_ret, reference[i]->type);\n                return MOBI_XML_ERR;\n            }\n            xml_ret = xmlTextWriterWriteAttribute(writer, BAD_CAST \"href\", BAD_CAST reference[i]->href);\n            if (xml_ret < 0) {\n                debug_print(\"XML error: %i (reference type: %s)\\n\", xml_ret, reference[i]->type);\n                return MOBI_XML_ERR;\n            }\n            xml_ret = xmlTextWriterEndElement(writer);\n            if (xml_ret < 0) {\n                debug_print(\"XML error: %i (reference type: %s)\\n\", xml_ret, reference[i]->type);\n                return MOBI_XML_ERR;\n            }\n            i++;\n        }\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Write single <item/> element to XML buffer\n \n @param[in,out] writer xmlTextWriterPtr to write to\n @param[in] id Attribute \"id\"\n @param[in] href Attribute \"href\"\n @param[in] media_type Attribute \"media-type\"\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_xml_write_item(xmlTextWriterPtr writer, const char *id, const char *href, const char *media_type) {\n    int xml_ret;\n    xml_ret = xmlTextWriterStartElement(writer, BAD_CAST \"item\");\n    if (xml_ret < 0) {\n        debug_print(\"XML error: %i (item id: %s)\\n\", xml_ret, id);\n        return MOBI_XML_ERR;\n    }\n    xml_ret = xmlTextWriterWriteAttribute(writer, BAD_CAST \"id\", BAD_CAST id);\n    if (xml_ret < 0) {\n        debug_print(\"XML error: %i (item id: %s)\\n\", xml_ret, id);\n        return MOBI_XML_ERR;\n    }\n    xml_ret = xmlTextWriterWriteAttribute(writer, BAD_CAST \"href\", BAD_CAST href);\n    if (xml_ret < 0) {\n        debug_print(\"XML error: %i (item id: %s)\\n\", xml_ret, id);\n        return MOBI_XML_ERR;\n    }\n    xml_ret = xmlTextWriterWriteAttribute(writer, BAD_CAST \"media-type\", BAD_CAST media_type);\n    if (xml_ret < 0) {\n        debug_print(\"XML error: %i (item id: %s)\\n\", xml_ret, id);\n        return MOBI_XML_ERR;\n    }\n    xml_ret = xmlTextWriterEndElement(writer);\n    if (xml_ret < 0) {\n        debug_print(\"XML error: %i (item id: %s)\\n\", xml_ret, id);\n        return MOBI_XML_ERR;\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Write opf <spine/> part to XML buffer\n \n @param[in,out] writer xmlTextWriterPtr to write to\n @param[in] rawml MOBIRawml structure containing parts metadata\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_xml_write_spine(xmlTextWriterPtr writer, const MOBIRawml *rawml) {\n    if (!rawml || !rawml->resources || !rawml->markup || !writer) {\n        return MOBI_INIT_FAILED;\n    }\n    /* get toc id */\n    char ncxid[13 + 1];\n    MOBIPart *curr = rawml->resources;\n    while (curr != NULL && curr->type != T_NCX) {\n        curr = curr->next;\n    }\n    if (curr) {\n        snprintf(ncxid, sizeof(ncxid), \"resource%05zu\", curr->uid);\n    } else {\n        return MOBI_DATA_CORRUPT;\n    }\n    int xml_ret;\n    xml_ret = xmlTextWriterStartElement(writer, BAD_CAST \"spine\");\n    if (xml_ret < 0) {\n        debug_print(\"XML error: %i (spine)\\n\", xml_ret);\n        return MOBI_XML_ERR;\n    }\n    xml_ret = xmlTextWriterWriteAttribute(writer, BAD_CAST \"toc\", BAD_CAST ncxid);\n    if (xml_ret < 0) {\n        debug_print(\"XML error: %i (spine toc: %s)\\n\", xml_ret, ncxid);\n        return MOBI_XML_ERR;\n    }\n    char id[9 + 1];\n    curr = rawml->markup;\n    while (curr != NULL) {\n        snprintf(id, sizeof(id), \"part%05zu\", curr->uid);\n        xml_ret = xmlTextWriterStartElement(writer, BAD_CAST \"itemref\");\n        if (xml_ret < 0) {\n            debug_print(\"XML error: %i (itemref)\\n\", xml_ret);\n            return MOBI_XML_ERR;\n        }\n        xml_ret = xmlTextWriterWriteAttribute(writer, BAD_CAST \"idref\", BAD_CAST id);\n        if (xml_ret < 0) {\n            debug_print(\"XML error: %i (idref: %s)\\n\", xml_ret, id);\n            return MOBI_XML_ERR;\n        }\n        xml_ret = xmlTextWriterEndElement(writer);\n        if (xml_ret < 0) {\n            debug_print(\"XML error: %i (idref: %s)\\n\", xml_ret, id);\n            return MOBI_XML_ERR;\n        }\n        curr = curr->next;\n    }\n    xml_ret = xmlTextWriterEndElement(writer);\n    if (xml_ret < 0) {\n        debug_print(\"XML error: %i (spine)\\n\", xml_ret);\n        return MOBI_XML_ERR;\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Write all manifest <item/> elements to XML buffer\n \n @param[in,out] writer xmlTextWriterPtr to write to\n @param[in] rawml MOBIRawml structure containing parts metadata\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_xml_write_manifest(xmlTextWriterPtr writer, const MOBIRawml *rawml) {\n    char href[256];\n    char id[256];\n    if (rawml->flow != NULL) {\n        MOBIPart *curr = rawml->flow;\n        /* skip first raw html part */\n        curr = curr->next;\n        while (curr != NULL) {\n            MOBIFileMeta file_meta = mobi_get_filemeta_by_type(curr->type);\n            snprintf(href, sizeof(href), \"flow%05zu.%s\", curr->uid, file_meta.extension);\n            snprintf(id, sizeof(id), \"flow%05zu\", curr->uid);\n            MOBI_RET ret = mobi_xml_write_item(writer, id, href, file_meta.mime_type);\n            if (ret != MOBI_SUCCESS) {\n                return ret;\n            }\n            curr = curr->next;\n        }\n    }\n    if (rawml->markup != NULL) {\n        MOBIPart *curr = rawml->markup;\n        while (curr != NULL) {\n            MOBIFileMeta file_meta = mobi_get_filemeta_by_type(curr->type);\n            snprintf(href, sizeof(href), \"part%05zu.%s\", curr->uid, file_meta.extension);\n            snprintf(id, sizeof(id), \"part%05zu\", curr->uid);\n            MOBI_RET ret = mobi_xml_write_item(writer, id, href, file_meta.mime_type);\n            if (ret != MOBI_SUCCESS) {\n                return ret;\n            }\n            curr = curr->next;\n        }\n    }\n    if (rawml->resources != NULL) {\n        MOBIPart *curr = rawml->resources;\n        while (curr != NULL) {\n            MOBIFileMeta file_meta = mobi_get_filemeta_by_type(curr->type);\n            snprintf(href, sizeof(href), \"resource%05zu.%s\", curr->uid, file_meta.extension);\n            snprintf(id, sizeof(id), \"resource%05zu\", curr->uid);\n            MOBI_RET ret = mobi_xml_write_item(writer, id, href, file_meta.mime_type);\n            if (ret != MOBI_SUCCESS) {\n                return ret;\n            }\n            curr = curr->next;\n        }\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Write array of Dublin Core identifier elements to XML buffer\n \n Wrapper for libxml2 xmlTextWriterWriteElementNS() function.\n Writes xml element for each not-null entry in the input array.\n \n @param[in,out] writer xmlTextWriterPtr to write to\n @param[in] identifier OPFidentifier structure representing identifier element\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_xml_write_dcmeta_identifier(xmlTextWriterPtr writer, const OPFidentifier **identifier) {\n    if (identifier) {\n        size_t i = 0;\n        while (i < OPF_META_MAX_TAGS) {\n            if (identifier[i] == NULL || identifier[i]->value == NULL) {\n                break;\n            }\n            int xml_ret;\n            xml_ret = xmlTextWriterStartElementNS(writer, BAD_CAST \"dc\", BAD_CAST \"identifier\", NULL);\n            if (xml_ret < 0) {\n                debug_print(\"XML error: %i (identifier value: %s)\\n\", xml_ret, identifier[i]->value);\n                return MOBI_XML_ERR;\n            }\n            if (identifier[i]->id) {\n                xml_ret = xmlTextWriterWriteAttribute(writer, BAD_CAST \"id\", BAD_CAST identifier[i]->id);\n                if (xml_ret < 0) {\n                    debug_print(\"XML error: %i (identifier id: %s)\\n\", xml_ret, identifier[i]->id);\n                    return MOBI_XML_ERR;\n                }\n            }\n            if (identifier[i]->scheme) {\n                xml_ret = xmlTextWriterWriteAttributeNS(writer, BAD_CAST \"opf\", BAD_CAST \"scheme\", NULL, BAD_CAST identifier[i]->scheme);\n                if (xml_ret < 0) {\n                    debug_print(\"XML error: %i (identifier value: %s)\\n\", xml_ret, identifier[i]->value);\n                    return MOBI_XML_ERR;\n                }\n            }\n            xml_ret = xmlTextWriterWriteString(writer, BAD_CAST identifier[i]->value);\n            if (xml_ret < 0) {\n                debug_print(\"XML error: %i (identifier value: %s)\\n\", xml_ret, identifier[i]->value);\n                return MOBI_XML_ERR;\n            }\n            xml_ret = xmlTextWriterEndElement(writer);\n            if (xml_ret < 0) {\n                debug_print(\"XML error: %i (identifier value: %s)\\n\", xml_ret, identifier[i]->value);\n                return MOBI_XML_ERR;\n            }\n            i++;\n        }\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Write array of Dublin Core creator/contributor elements to XML buffer\n \n Wrapper for libxml2 xmlTextWriterWriteElementNS() function.\n Writes xml element for each not-null entry in the input array.\n \n @param[in,out] writer xmlTextWriterPtr to write to\n @param[in] creator OPFcreator structure representing creator/contributor element\n @param[in] name OPF creator value\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_xml_write_dcmeta_creator(xmlTextWriterPtr writer, const OPFcreator **creator, const char *name) {\n    if (creator) {\n        size_t i = 0;\n        while (i < OPF_META_MAX_TAGS) {\n            if (creator[i] == NULL || creator[i]->value == NULL) {\n                break;\n            }\n            int xml_ret;\n            xml_ret = xmlTextWriterStartElementNS(writer, BAD_CAST \"dc\", BAD_CAST name, NULL);\n            if (xml_ret < 0) {\n                debug_print(\"XML error: %i (creator value: %s)\\n\", xml_ret, creator[i]->value);\n                return MOBI_XML_ERR;\n            }\n            if (creator[i]->role) {\n                xml_ret = xmlTextWriterWriteAttributeNS(writer, BAD_CAST \"opf\", BAD_CAST \"role\", NULL, BAD_CAST creator[i]->role);\n                if (xml_ret < 0) {\n                    debug_print(\"XML error: %i (creator role: %s)\\n\", xml_ret, creator[i]->role);\n                    return MOBI_XML_ERR;\n                }\n            }\n            if (creator[i]->file_as) {\n                xml_ret = xmlTextWriterWriteAttributeNS(writer, BAD_CAST \"opf\", BAD_CAST \"file-as\", NULL, BAD_CAST creator[i]->file_as);\n                if (xml_ret < 0) {\n                    debug_print(\"XML error: %i (creator file-as: %s)\\n\", xml_ret, creator[i]->file_as);\n                    return MOBI_XML_ERR;\n                }\n            }\n            xml_ret = xmlTextWriterWriteString(writer, BAD_CAST creator[i]->value);\n            if (xml_ret < 0) {\n                debug_print(\"XML error: %i (creator value: %s)\\n\", xml_ret, creator[i]->value);\n                return MOBI_XML_ERR;\n            }\n            xml_ret = xmlTextWriterEndElement(writer);\n            if (xml_ret < 0) {\n                debug_print(\"XML error: %i (creator value: %s)\\n\", xml_ret, creator[i]->value);\n                return MOBI_XML_ERR;\n            }\n            i++;\n        }\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Write array of Dublin Core subject elements to XML buffer\n \n Wrapper for libxml2 xmlTextWriterWriteElementNS() function.\n Writes xml element for each not-null entry in the input array.\n \n @param[in,out] writer xmlTextWriterPtr to write to\n @param[in] subject OPFsubject structure representing subject element\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_xml_write_dcmeta_subject(xmlTextWriterPtr writer, const OPFsubject **subject) {\n    if (subject) {\n        size_t i = 0;\n        while (i < OPF_META_MAX_TAGS) {\n            if (subject[i] == NULL || subject[i]->value == NULL) {\n                break;\n            }\n            int xml_ret;\n            xml_ret = xmlTextWriterStartElementNS(writer, BAD_CAST \"dc\", BAD_CAST \"subject\", NULL);\n            if (xml_ret < 0) {\n                debug_print(\"XML error: %i (subject value: %s)\\n\", xml_ret, subject[i]->value);\n                return MOBI_XML_ERR;\n            }\n            if (subject[i]->basic_code) {\n                xml_ret = xmlTextWriterWriteAttribute(writer, BAD_CAST \"BASICCode\", BAD_CAST subject[i]->basic_code);\n                if (xml_ret < 0) {\n                    debug_print(\"XML error: %i (subject BASICCode: %s)\\n\", xml_ret, subject[i]->basic_code);\n                    return MOBI_XML_ERR;\n                }\n            }\n            xml_ret = xmlTextWriterWriteString(writer, BAD_CAST subject[i]->value);\n            if (xml_ret < 0) {\n                debug_print(\"XML error: %i (subject value: %s)\\n\", xml_ret, subject[i]->value);\n                return MOBI_XML_ERR;\n            }\n            xml_ret = xmlTextWriterEndElement(writer);\n            if (xml_ret < 0) {\n                debug_print(\"XML error: %i (subject value: %s)\\n\", xml_ret, subject[i]->value);\n                return MOBI_XML_ERR;\n            }\n            i++;\n        }\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Write array of Dublin Core date elements to XML buffer\n \n Wrapper for libxml2 xmlTextWriterWriteElementNS() function.\n Writes xml element for each not-null entry in the input array.\n \n @param[in,out] writer xmlTextWriterPtr to write to\n @param[in] date OPFdate structure representing date element\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_xml_write_dcmeta_date(xmlTextWriterPtr writer, const OPFdate **date) {\n    if (date) {\n        size_t i = 0;\n        while (i < OPF_META_MAX_TAGS) {\n            if (date[i] == NULL || date[i]->value == NULL) {\n                break;\n            }\n            int xml_ret;\n            xml_ret = xmlTextWriterStartElementNS(writer, BAD_CAST \"dc\", BAD_CAST \"date\", NULL);\n            if (xml_ret < 0) {\n                debug_print(\"XML error: %i (date value: %s)\\n\", xml_ret, date[i]->value);\n                return MOBI_XML_ERR;\n            }\n            if (date[i]->event) {\n                xml_ret = xmlTextWriterWriteAttributeNS(writer, BAD_CAST \"opf\", BAD_CAST \"event\", NULL, BAD_CAST date[i]->event);\n                if (xml_ret < 0) {\n                    debug_print(\"XML error: %i (date event: %s)\\n\", xml_ret, date[i]->event);\n                    return MOBI_XML_ERR;\n                }\n            }\n            xml_ret = xmlTextWriterWriteString(writer, BAD_CAST date[i]->value);\n            if (xml_ret < 0) {\n                debug_print(\"XML error: %i (date value: %s)\\n\", xml_ret, date[i]->value);\n                return MOBI_XML_ERR;\n            }\n            xml_ret = xmlTextWriterEndElement(writer);\n            if (xml_ret < 0) {\n                debug_print(\"XML error: %i (date value: %s)\\n\", xml_ret, date[i]->value);\n                return MOBI_XML_ERR;\n            }\n            i++;\n        }\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Write array of custom srp elements to XML buffer\n \n Wrapper for libxml2 xmlTextWriterWriteElementNS() function.\n Writes xml element for each not-null entry in the input array.\n \n @param[in,out] writer xmlTextWriterPtr to write to\n @param[in] srp OPFsrp structure representing srp element\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_xml_write_xmeta_srp(xmlTextWriterPtr writer, const OPFsrp **srp) {\n    if (srp) {\n        size_t i = 0;\n        while (i < OPF_META_MAX_TAGS) {\n            if (srp[i] == NULL || srp[i]->value == NULL) {\n                break;\n            }\n            int xml_ret;\n            xml_ret = xmlTextWriterStartElement(writer, BAD_CAST \"srp\");\n            if (xml_ret < 0) {\n                debug_print(\"XML error: %i (srp value: %s)\\n\", xml_ret, srp[i]->value);\n                return MOBI_XML_ERR;\n            }\n            if (srp[i]->currency) {\n                xml_ret = xmlTextWriterWriteAttribute(writer, BAD_CAST \"currency\", BAD_CAST srp[i]->currency);\n                if (xml_ret < 0) {\n                    debug_print(\"XML error: %i (srp currency: %s)\\n\", xml_ret, srp[i]->currency);\n                    return MOBI_XML_ERR;\n                }\n            }\n            xml_ret = xmlTextWriterWriteString(writer, BAD_CAST srp[i]->value);\n            if (xml_ret < 0) {\n                debug_print(\"XML error: %i (srp value: %s)\\n\", xml_ret, srp[i]->value);\n                return MOBI_XML_ERR;\n            }\n            xml_ret = xmlTextWriterEndElement(writer);\n            if (xml_ret < 0) {\n                debug_print(\"XML error: %i (srp value: %s)\\n\", xml_ret, srp[i]->value);\n                return MOBI_XML_ERR;\n            }\n            i++;\n        }\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Free array of OPF sturcture members\n \n @param[in] array Array\n */\nvoid mobi_free_opf_array(char **array) {\n    if (array) {\n        size_t i = 0;\n        while (i < OPF_META_MAX_TAGS) {\n            if (array[i] == NULL) {\n                break;\n            }\n            free(array[i]);\n            i++;\n        }\n        free(array);\n    }\n}\n\n/**\n @brief Macro to free generic OPF structure with two members\n \n @param[in] struct_array Structure name\n @param[in] struct_member1 Structure member 1\n @param[in] struct_member2 Structure member 2\n */\n#define mobi_free_opf_struct_2el(struct_array, struct_member1, struct_member2) { \\\n    if (struct_array) { \\\n        size_t i = 0; \\\n        while (i < OPF_META_MAX_TAGS) { \\\n            if (struct_array[i] == NULL) { \\\n                break; \\\n            } \\\n            free(struct_array[i]->struct_member1); \\\n            free(struct_array[i]->struct_member2); \\\n            free(struct_array[i]); \\\n            i++; \\\n        } \\\n        free(struct_array); \\\n    } \\\n}\n\n/**\n @brief Macro to free generic OPF structure with three members\n \n @param[in] struct_array Structure name\n @param[in] struct_member1 Structure member 1\n @param[in] struct_member2 Structure member 2\n @param[in] struct_member3 Structure member 3\n */\n#define mobi_free_opf_struct_3el(struct_array, struct_member1, struct_member2, struct_member3) { \\\n    if (struct_array) { \\\n        size_t i = 0; \\\n        while (i < OPF_META_MAX_TAGS) { \\\n            if (struct_array[i] == NULL) { \\\n                break; \\\n            } \\\n            free(struct_array[i]->struct_member1); \\\n            free(struct_array[i]->struct_member2); \\\n            free(struct_array[i]->struct_member3); \\\n            free(struct_array[i]); \\\n            i++; \\\n        } \\\n        free(struct_array); \\\n    } \\\n}\n\n/**\n @brief Free OPF metadata structure and data\n \n @param[in] metadata OPF opf->metadata structure\n */\nvoid mobi_free_opf_metadata(OPFmetadata *metadata) {\n    if (metadata) {\n        /* <meta/> */\n        mobi_free_opf_struct_2el(metadata->meta, name, content);\n        /* <dc-metadata/> */\n        mobi_free_opf_struct_3el(metadata->dc_meta->contributor, value, file_as, role);\n        mobi_free_opf_struct_3el(metadata->dc_meta->creator, value, file_as, role);\n        mobi_free_opf_struct_3el(metadata->dc_meta->identifier, value, id, scheme);\n        mobi_free_opf_struct_2el(metadata->dc_meta->subject, value, basic_code);\n        mobi_free_opf_struct_2el(metadata->dc_meta->date, value, event);\n        mobi_free_opf_array(metadata->dc_meta->description);\n        mobi_free_opf_array(metadata->dc_meta->language);\n        mobi_free_opf_array(metadata->dc_meta->publisher);\n        mobi_free_opf_array(metadata->dc_meta->rights);\n        mobi_free_opf_array(metadata->dc_meta->source);\n        mobi_free_opf_array(metadata->dc_meta->title);\n        mobi_free_opf_array(metadata->dc_meta->type);\n        free(metadata->dc_meta);\n        /* <x-metadata/> */\n        mobi_free_opf_struct_2el(metadata->x_meta->srp, value, currency);\n        mobi_free_opf_array(metadata->x_meta->adult);\n        mobi_free_opf_array(metadata->x_meta->default_lookup_index);\n        mobi_free_opf_array(metadata->x_meta->dict_short_name);\n        mobi_free_opf_array(metadata->x_meta->dictionary_in_lang);\n        mobi_free_opf_array(metadata->x_meta->dictionary_out_lang);\n        mobi_free_opf_array(metadata->x_meta->embedded_cover);\n        mobi_free_opf_array(metadata->x_meta->imprint);\n        mobi_free_opf_array(metadata->x_meta->review);\n        free(metadata->x_meta);\n        free(metadata);\n    }\n}\n\n/**\n @brief Free OPFmanifest structure and data\n \n @param[in] manifest OPF opf->manifest structure\n */\nvoid mobi_free_opf_manifest(OPFmanifest *manifest) {\n    if (manifest) {\n        mobi_free_opf_struct_3el(manifest->item, id, href, media_type);\n        free(manifest);\n    }\n}\n\n/**\n @brief Free OPFspine structure and data\n \n @param[in] spine OPF opf->spine structure\n */\nvoid mobi_free_opf_spine(OPFspine *spine) {\n    if (spine) {\n        mobi_free_opf_array(spine->itemref);\n        free(spine->toc);\n        free(spine);\n    }\n}\n\n/**\n @brief Free OPFguide structure and data\n \n @param[in] guide OPF opf->guide structure\n */\nvoid mobi_free_opf_guide(OPFguide *guide) {\n    if (guide) {\n        mobi_free_opf_struct_3el(guide->reference, type, title, href);\n        free(guide);\n    }\n}\n\n/**\n @brief Free OPF structure and data\n \n @param[in] opf OPF structure\n */\nvoid mobi_free_opf(OPF *opf) {\n    mobi_free_opf_metadata(opf->metadata);\n    mobi_free_opf_manifest(opf->manifest);\n    mobi_free_opf_spine(opf->spine);\n    mobi_free_opf_guide(opf->guide);\n}\n\n/**\n @brief Recreate OPF structure\n \n This function will fill OPF structure with parsed index data and convert it to xml file. The file will be stored in MOBIRawml structure.\n \n @param[in,out] rawml OPF xml file will be appended to rawml->markup linked list\n @param[in] m MOBIData structure containing document metadata\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_build_opf(MOBIRawml *rawml, const MOBIData *m) {\n    debug_print(\"Reconstructing opf%s\", \"\\n\");\n    /* initialize libXML2 */\n    LIBXML_TEST_VERSION\n    /* initialize OPF structure */\n    OPF opf = {\n        .metadata = NULL,\n        .manifest = NULL,\n        .guide = NULL,\n        .spine = NULL\n    };\n    MOBI_RET ret = mobi_build_opf_metadata(&opf, m, rawml);\n    if (ret != MOBI_SUCCESS) {\n        mobi_free_opf(&opf);\n        return ret;\n    }\n    mobi_build_ncx(rawml, &opf);\n    if (rawml->guide) {\n        ret = mobi_build_opf_guide(&opf, rawml);\n        if (ret != MOBI_SUCCESS) {\n            mobi_free_opf(&opf);\n            return ret;\n        }\n    }\n\n    /* build OPF xml document */\n    int xml_ret;\n    const xmlChar * OPFNamespace = BAD_CAST \"http://www.idpf.org/2007/opf\";\n    const xmlChar * DCNamespace = BAD_CAST \"http://purl.org/dc/elements/1.1/\";\n    xmlBufferPtr buf = xmlBufferCreate();\n    if (buf == NULL) {\n        mobi_free_opf(&opf);\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    xmlTextWriterPtr writer = xmlNewTextWriterMemory(buf, 0);\n    if (writer == NULL) {\n        xmlBufferFree(buf);\n        mobi_free_opf(&opf);\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    xmlTextWriterSetIndent(writer, 1);\n    xml_ret = xmlTextWriterStartDocument(writer, NULL, NULL, NULL);\n    if (xml_ret < 0) { goto cleanup; }\n    /* <package/> */\n    xml_ret = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST \"package\", OPFNamespace);\n    if (xml_ret < 0) { goto cleanup; }\n    xml_ret = xmlTextWriterWriteAttribute(writer, BAD_CAST \"version\", BAD_CAST \"2.0\");\n    if (xml_ret < 0) { goto cleanup; }\n    xml_ret = xmlTextWriterWriteAttribute(writer, BAD_CAST \"unique-identifier\", BAD_CAST \"uid\");\n    if (xml_ret < 0) { goto cleanup; }\n    /* <metadata /> */\n    xml_ret = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST \"metadata\", NULL);\n    if (xml_ret < 0) { goto cleanup; }\n    /* <dc-metadata/> */\n    //xml_ret = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST \"dc-metadata\", NULL);\n    //if (xml_ret < 0) { goto cleanup; }\n    xml_ret = xmlTextWriterWriteAttributeNS(writer, BAD_CAST \"xmlns\", BAD_CAST \"opf\", NULL, OPFNamespace);\n    if (xml_ret < 0) { goto cleanup; }\n    xml_ret = xmlTextWriterWriteAttributeNS(writer, BAD_CAST \"xmlns\", BAD_CAST \"dc\", NULL, DCNamespace);\n    if (xml_ret < 0) { goto cleanup; }\n    /* Dublin Core elements */\n    OPFdcmeta *dc_meta = opf.metadata->dc_meta;\n    ret = mobi_xml_write_dcmeta(writer, \"title\", (const char **) dc_meta->title);\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    ret = mobi_xml_write_dcmeta(writer, \"description\", (const char **) dc_meta->description);\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    ret = mobi_xml_write_dcmeta(writer, \"language\", (const char **) dc_meta->language);\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    ret = mobi_xml_write_dcmeta(writer, \"publisher\", (const char **) dc_meta->publisher);\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    ret = mobi_xml_write_dcmeta(writer, \"rights\", (const char **) dc_meta->rights);\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    ret = mobi_xml_write_dcmeta(writer, \"source\", (const char **) dc_meta->source);\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    ret = mobi_xml_write_dcmeta(writer, \"type\", (const char **) dc_meta->type);\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    ret = mobi_xml_write_dcmeta_identifier(writer, (const OPFidentifier **) dc_meta->identifier);\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    ret = mobi_xml_write_dcmeta_creator(writer, (const OPFcreator **) dc_meta->creator, \"creator\");\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    ret = mobi_xml_write_dcmeta_creator(writer, (const OPFcreator **) dc_meta->contributor, \"contributor\");\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    ret = mobi_xml_write_dcmeta_subject(writer, (const OPFsubject **) dc_meta->subject);\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    ret = mobi_xml_write_dcmeta_date(writer, (const OPFdate **) dc_meta->date);\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    //xml_ret = xmlTextWriterEndElement(writer);\n    //if (xml_ret < 0) { goto cleanup; }\n    /* <x-metadata/> */\n    //xml_ret = xmlTextWriterStartElement(writer, BAD_CAST \"x-metadata\");\n    //if (xml_ret < 0) { goto cleanup; }\n    OPFxmeta *x_meta = opf.metadata->x_meta;\n    /* custom elements */\n    ret = mobi_xml_write_xmeta_srp(writer, (const OPFsrp **) x_meta->srp);\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    ret = mobi_xml_write_xmeta(writer, \"adult\", (const char **) x_meta->adult);\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    ret = mobi_xml_write_xmeta(writer, \"DefaultLookupIndex\", (const char **) x_meta->default_lookup_index);\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    ret = mobi_xml_write_xmeta(writer, \"DictionaryVeryShortName\", (const char **) x_meta->dict_short_name);\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    ret = mobi_xml_write_xmeta(writer, \"DictionaryInLanguage\", (const char **) x_meta->dictionary_in_lang);\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    ret = mobi_xml_write_xmeta(writer, \"DictionaryOutLanguage\", (const char **) x_meta->dictionary_out_lang);\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    ret = mobi_xml_write_xmeta(writer, \"EmbeddedCover\", (const char **) x_meta->embedded_cover);\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    ret = mobi_xml_write_xmeta(writer, \"imprint\", (const char **) x_meta->imprint);\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    ret = mobi_xml_write_xmeta(writer, \"review\", (const char **) x_meta->review);\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    /* <meta/> */\n    ret = mobi_xml_write_opfmeta(writer, (const OPFmeta **) opf.metadata->meta);\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    //xml_ret = xmlTextWriterEndElement(writer);\n    //if (xml_ret < 0) { goto cleanup; }\n    xml_ret = xmlTextWriterEndElement(writer);\n    if (xml_ret < 0) { goto cleanup; }\n    /* <manifest/> */\n    xml_ret = xmlTextWriterStartElement(writer, BAD_CAST \"manifest\");\n    if (xml_ret < 0) { goto cleanup; }\n    ret = mobi_xml_write_manifest(writer, rawml);\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    xml_ret = xmlTextWriterEndElement(writer);\n    if (xml_ret < 0) { goto cleanup; }\n    /* <spine/> */\n    ret = mobi_xml_write_spine(writer, rawml);\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    /* <guide/> */\n    if (opf.guide) {\n        xml_ret = xmlTextWriterStartElement(writer, BAD_CAST \"guide\");\n        if (xml_ret < 0) { goto cleanup; }\n        ret = mobi_xml_write_reference(writer, (const OPFreference **) opf.guide->reference);\n        if (ret != MOBI_SUCCESS) { goto cleanup; }\n        xml_ret = xmlTextWriterEndElement(writer);\n        if (xml_ret < 0) { goto cleanup; }\n    }\n    xml_ret = xmlTextWriterEndDocument(writer);\n    if (xml_ret < 0) { goto cleanup; }\n    \n    xmlFreeTextWriter(writer);\n    const char *opf_xml = (const char *) buf->content;\n    mobi_opf_add_to_rawml(opf_xml, rawml);\n    xmlBufferFree(buf);\n    mobi_free_opf(&opf);\n    /* cleanup function for the XML library */\n    xmlCleanupParser();\n    return MOBI_SUCCESS;\n    \ncleanup:\n    xmlFreeTextWriter(writer);\n    xmlBufferFree(buf);\n    mobi_free_opf(&opf);\n    xmlCleanupParser();\n    debug_print(\"%s\\n\", \"XML writing failed\");\n    return MOBI_XML_ERR;\n}\n", "/** @file util.c\n *  @brief Various helper functions\n *\n * Copyright (c) 2014 Bartek Fabiszewski\n * http://www.fabiszewski.net\n *\n * This file is part of libmobi.\n * Licensed under LGPL, either version 3, or any later.\n * See <http://www.gnu.org/licenses/>\n */\n\n#define _GNU_SOURCE 1\n#ifndef __USE_BSD\n#define __USE_BSD /* for strdup on linux/glibc */\n#endif\n\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include \"util.h\"\n#include \"parse_rawml.h\"\n#include \"index.h\"\n#include \"debug.h\"\n\n#ifdef USE_ENCRYPTION\n#include \"encryption.h\"\n#endif\n\n#ifdef USE_XMLWRITER\n#include \"opf.h\"\n#endif\n\n#define MOBI_FONT_OBFUSCATED_BUFFER_COUNT 52\n\n/** @brief Lookup table for cp1252 to utf8 encoding conversion */\nstatic const unsigned char cp1252_to_utf8[32][3] = {\n    {0xe2,0x82,0xac},\n    {0},\n    {0xe2,0x80,0x9a},\n    {0xc6,0x92,0},\n    {0xe2,0x80,0x9e},\n    {0xe2,0x80,0xa6},\n    {0xe2,0x80,0xa0},\n    {0xe2,0x80,0xa1},\n    {0xcb,0x86,0},\n    {0xe2,0x80,0xb0},\n    {0xc5,0xa0,0},\n    {0xe2,0x80,0xb9},\n    {0xc5,0x92,0},\n    {0},\n    {0xc5,0xbd,0},\n    {0},\n    {0},\n    {0xe2,0x80,0x98},\n    {0xe2,0x80,0x99},\n    {0xe2,0x80,0x9c},\n    {0xe2,0x80,0x9d},\n    {0xe2,0x80,0xa2},\n    {0xe2,0x80,0x93},\n    {0xe2,0x80,0x94},\n    {0xcb,0x9c,0},\n    {0xe2,0x84,0xa2},\n    {0xc5,0xa1,0},\n    {0xe2,0x80,0xba},\n    {0xc5,0x93,0},\n    {0},\n    {0xc5,0xbe,0},\n    {0xc5,0xb8,0},\n};\n\n/**\n @brief Get libmobi version\n\n @return String version\n */\nconst char * mobi_version(void) {\n#ifndef PACKAGE_VERSION\n# define PACKAGE_VERSION \"unknown\"\n#endif\n    return PACKAGE_VERSION;\n}\n\n/**\n @brief Convert unicode codepoint to utf-8 sequence\n \n @param[in,out] output Output string\n @param[in] codepoint Unicode codepoint\n @return Length of utf-8 sequence (maximum 4 bytes), zero on failure\n */\nuint8_t mobi_unicode_to_utf8(char *output, const size_t codepoint) {\n    if (!output) {\n        return 0;\n    }\n    unsigned char *bytes = (unsigned char *) output;\n    \n    if (codepoint < 0x80) {\n        bytes[0] = (unsigned char) codepoint;\n        return 1;\n    }\n    if (codepoint < 0x800) {\n        bytes[1] = (unsigned char) ((2 << 6) | (codepoint & 0x3f));\n        bytes[0] = (unsigned char) ((6 << 5) | (codepoint >> 6));\n        return 2;\n    }\n    if (codepoint < 0x10000) {\n        bytes[2] = (unsigned char) ((2 << 6) | (codepoint & 0x3f));\n        bytes[1] = (unsigned char) ((2 << 6) | ((codepoint >> 6) & 0x3f));\n        bytes[0] = (unsigned char) ((14 << 4) | (codepoint >> 12));\n        return 3;\n    }\n    if (codepoint < 0x11000) {\n        bytes[3] = (unsigned char) ((2 << 6) | (codepoint & 0x3f));\n        bytes[2] = (unsigned char) ((2 << 6) | ((codepoint >> 6) & 0x3f));\n        bytes[1] = (unsigned char) ((2 << 6) | ((codepoint >> 12) & 0x3f));\n        bytes[0] = (unsigned char) ((30 << 3) | (codepoint >> 18));\n        return 4;\n    }\n    return 0;\n}\n\n/**\n @brief Convert cp1252 encoded string to utf-8\n \n Maximum length of output string is 3 * (input string length) + 1\n Output string will be null terminated (even if truncated)\n \n @param[in,out] output Output string\n @param[in,out] input Input string\n @param[in,out] outsize Size of the allocated output buffer, will be set to output string length (without null terminator) on return\n @param[in] insize Length of the input string.\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_cp1252_to_utf8(char *output, const char *input, size_t *outsize, const size_t insize) {\n    if (!output || !input) {\n        return MOBI_PARAM_ERR;\n    }\n    const unsigned char *in = (unsigned char *) input;\n    unsigned char *out = (unsigned char *) output;\n    const unsigned char *outend = out + *outsize - 1; /* leave space for null terminator */\n    const unsigned char *inend = in + insize;\n    while (in < inend && out < outend && *in) {\n        if (*in < 0x80) {\n           *out++ = *in++;\n        }\n        else if (*in < 0xa0) {\n            /* table lookup */\n            size_t i = 0;\n            while (i < 3 && out < outend) {\n                unsigned char c = cp1252_to_utf8[*in - 0x80][i];\n                if (c == 0) {\n                    break;\n                }\n                *out++ = c;\n                i++;\n            }\n            if (i == 0) {\n                /* unmappable character in input */\n                /* substitute with utf-8 replacement character */\n                if (out >= outend - 1) { break; }\n                *out++ = 0xff;\n                *out++ = 0xfd;\n                debug_print(\"Invalid character found: %c\\n\", *in);\n            }\n            in++;\n        }\n        else if (*in < 0xc0) {\n            if (out >= outend - 1) { break; }\n            *out++ = 0xc2;\n            *out++ = *in++;\n        }\n        else {\n            if (out >= outend - 1) { break; }\n            *out++ = 0xc3;\n            *out++ = (*in++ & 0x3f) + 0x80;\n        }\n    }\n    *out = '\\0';\n    *outsize = (size_t) (out - (unsigned char *) output);\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Convert utf-8 encoded string to cp1252\n \n Characters out of range will be replaced with substitute character\n \n @param[in,out] output Output string\n @param[in,out] input Input string\n @param[in,out] outsize Size of the allocated output buffer, will be set to output string length (without null terminator) on return\n @param[in] insize Length of the input string.\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_utf8_to_cp1252(char *output, const char *input, size_t *outsize, const size_t insize) {\n    if (!output || !input) {\n        return MOBI_PARAM_ERR;\n    }\n    const unsigned char *in = (unsigned char *) input;\n    unsigned char *out = (unsigned char *) output;\n    const unsigned char *outend = out + *outsize - 1; /* leave space for null terminator */\n    const unsigned char *inend = in + insize;\n    while (in < inend && out < outend && *in) {\n        /* one byte */\n        if (*in < 0x80) {\n            *out++ = *in++;\n        }\n        /* two bytes */\n        else if ((*in & 0xe0) == 0xc0) {\n            if (in > inend - 2) { break; }\n            if (in[0] == 0xc2 && (in[1] >= 0xa0 && in[1] <= 0xbf)) {\n                *out++ = in[1];\n            } else if (in[0] == 0xc3 && (in[1] >= 0x80 && in[1] <= 0xbf)) {\n                *out++ = in[1] + 0x40;\n            } else if (in[0] == 0xc5) {\n                switch (in[1]) {\n                    case 0xa0:\n                        *out++ = 0x8a;\n                        break;\n                    case 0x92:\n                        *out++ = 0x8c;\n                        break;\n                    case 0xbd:\n                        *out++ = 0x8e;\n                        break;\n                    case 0xa1:\n                        *out++ = 0x9a;\n                        break;\n                    case 0x93:\n                        *out++ = 0x9c;\n                        break;\n                    case 0xbe:\n                        *out++ = 0x9e;\n                        break;\n                    case 0xb8:\n                        *out++ = 0x9f;\n                        break;\n                    default:\n                        *out++ = '?';\n                        break;\n                }\n            } else if (in[0] == 0xc6 && in[1] == 0x92) {\n                *out++ = 0x83;\n            } else if (in[0] == 0xcb && in[1] == 0x86) {\n                *out++ = 0x88;\n            } else {\n                *out++ = '?';\n            }\n            in += 2;\n        }\n        /* three bytes */\n        else if ((*in & 0xf0) == 0xe0) {\n            if (in > inend - 3) { break; }\n            if (in[0] == 0xe2 && in[1] == 0x80) {\n                switch (in[2]) {\n                    case 0x9a:\n                        *out++ = 0x82;\n                        break;\n                    case 0x9e:\n                        *out++ = 0x84;\n                        break;\n                    case 0xa6:\n                        *out++ = 0x85;\n                        break;\n                    case 0xa0:\n                        *out++ = 0x86;\n                        break;\n                    case 0xb0:\n                        *out++ = 0x89;\n                        break;\n                    case 0xb9:\n                        *out++ = 0x8b;\n                        break;\n                    case 0x98:\n                        *out++ = 0x91;\n                        break;\n                    case 0x99:\n                        *out++ = 0x92;\n                        break;\n                    case 0x9c:\n                        *out++ = 0x93;\n                        break;\n                    case 0x9d:\n                        *out++ = 0x94;\n                        break;\n                    case 0xa2:\n                        *out++ = 0x95;\n                        break;\n                    case 0x93:\n                        *out++ = 0x86;\n                        break;\n                    case 0x94:\n                        *out++ = 0x97;\n                        break;\n                    case 0xba:\n                        *out++ = 0x9b;\n                        break;\n                    default:\n                        *out++ = '?';\n                        break;\n                }\n            } else if (in[0] == 0xe2 && in[1] == 0x82 && in[2] == 0xac) {\n                *out++ = 0x80;\n            } else if (in[0] == 0xe2 && in[1] == 0x84 && in[2] == 0xa2) {\n                *out++ = 0x99;\n            } else {\n                *out++ = '?';\n            }\n            in += 3;\n        }\n        /* four bytes */\n        else if ((*in & 0xf8) == 0xf0) {\n            if (in > inend - 4) { break; }\n            *out++ = '?';\n            in += 4;\n        }\n        /* skip error */\n        else {\n            *out++ = '?';\n            in++;\n        }\n    }\n    *out = '\\0';\n    *outsize = (size_t) (out - (unsigned char *) output);\n    return MOBI_SUCCESS;\n}\n\n/** @brief Decode ligature to cp1252\n \n Some latin ligatures are encoded in indices to facilitate search\n They are listed in LIGT header, but it seems every LIGT header contains\n same 5 ligatures (even if not all of them are used).\n So, instead of parsing header, we use static replacements.\n Invalid control characters are skipped\n \n @param[in] byte1 First byte - control character\n @param[in] byte2 Second byte of the ligature\n @return Ligature in cp1252 encoding, zero if not found\n */\nuint8_t mobi_ligature_to_cp1252(const uint8_t byte1, const uint8_t byte2) {\n    uint8_t ligature = 0;\n    const uint8_t lig_OE = 0x8c;\n    const uint8_t lig_oe = 0x9c;\n    const uint8_t lig_AE = 0xc6;\n    const uint8_t lig_ae = 0xe6;\n    const uint8_t lig_ss = 0xdf;\n    switch (byte1) {\n        case 1:\n            if (byte2 == 0x45) { ligature = lig_OE; }\n            break;\n        case 2:\n            if (byte2 == 0x65) { ligature = lig_oe; }\n            break;\n        case 3:\n            if (byte2 == 0x45) { ligature = lig_AE; }\n            break;\n        case 4:\n            if (byte2 == 0x65) { ligature = lig_ae; }\n            break;\n        case 5:\n            if (byte2 == 0x73) { ligature = lig_ss; }\n            break;\n    }\n    return ligature;\n}\n\n/** @brief Decode ligature to utf-16\n \n @param[in] byte1 First byte - control character, should be <= 5\n @param[in] byte2 Second byte of the ligature\n @return Ligature in utf-16 encoding, uni_replacement if not found\n */\nuint16_t mobi_ligature_to_utf16(const uint32_t byte1, const uint32_t byte2) {\n    const uint16_t uni_replacement = 0xfffd;\n    uint16_t ligature = uni_replacement;\n    const uint16_t lig_OE = 0x152;\n    const uint16_t lig_oe = 0x153;\n    const uint16_t lig_AE = 0xc6;\n    const uint16_t lig_ae = 0xe6;\n    const uint16_t lig_ss = 0xdf;\n    switch (byte1) {\n        case 1:\n            if (byte2 == 0x45) { ligature = lig_OE; }\n            break;\n        case 2:\n            if (byte2 == 0x65) { ligature = lig_oe; }\n            break;\n        case 3:\n            if (byte2 == 0x45) { ligature = lig_AE; }\n            break;\n        case 4:\n            if (byte2 == 0x65) { ligature = lig_ae; }\n            break;\n        case 5:\n            if (byte2 == 0x73) { ligature = lig_ss; }\n            break;\n    }\n    return ligature;\n}\n\n/** @brief Get text encoding of mobi document\n \n @param[in] m MOBIData structure holding document data and metadata\n @return MOBIEncoding text encoding (MOBI_UTF8 or MOBI_CP1252)\n */\nMOBIEncoding mobi_get_encoding(const MOBIData *m) {\n    if (m && m->mh) {\n        if (m->mh->text_encoding) {\n            if (*m->mh->text_encoding == MOBI_UTF8) {\n                return MOBI_UTF8;\n            }\n        }\n    }\n    return MOBI_CP1252;\n}\n\n/** @brief Check if document's text is cp1252 encoded\n \n @param[in] m MOBIData structure holding document data and metadata\n @return True or false\n */\nbool mobi_is_cp1252(const MOBIData *m) {\n    return (mobi_get_encoding(m) == MOBI_CP1252);\n}\n\n/**\n @brief strdup replacement\n \n Returned pointer must be freed by caller\n \n @param[in] s Input string\n @return Duplicated string\n */\nchar * mobi_strdup(const char *s) {\n    char *p = malloc(strlen(s) + 1);\n    if (p) { strcpy(p, s); }\n    return p;\n}\n\n#define MOBI_LANG_MAX 99 /**< number of entries in mobi_locale array */\n#define MOBI_REGION_MAX 21 /**< maximum number of entries in each language array */\n\n/**< @brief Table of Mobipocket language-region codes\n \n Based on IANA language-subtag registry with some custom Mobipocket modifications.\n http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry\n */\nstatic const char *mobi_locale[MOBI_LANG_MAX][MOBI_REGION_MAX] = {\n    {\"neutral\"},\n    {\n    \"ar\", /**< Arabic >*/\n    \"ar-sa\", /**< Arabic (Saudi Arabia) >*/\n    \"ar\", /**< Arabic (Unknown) */\n    \"ar-eg\", /**< Arabic (Egypt) >*/\n    \"ar\", /**< Arabic (Unknown) */\n    \"ar-dz\", /**< Arabic (Algeria) >*/\n    \"ar-ma\", /**< Arabic (Morocco) >*/\n    \"ar-tn\", /**< Arabic (Tunisia) >*/\n    \"ar-om\", /**< Arabic (Oman) >*/\n    \"ar-ye\", /**< Arabic (Yemen) >*/\n    \"ar-sy\", /**< Arabic (Syria) >*/\n    \"ar-jo\", /**< Arabic (Jordan) >*/\n    \"ar-lb\", /**< Arabic (Lebanon) >*/\n    \"ar-kw\", /**< Arabic (Kuwait) >*/\n    \"ar-ae\", /**< Arabic (UAE) >*/\n    \"ar-bh\", /**< Arabic (Bahrain) >*/\n    \"ar-qa\", /**< Arabic (Qatar) >*/\n    },\n    {\"bg\"}, /**< Bulgarian >*/\n    {\"ca\"}, /**< Catalan >*/\n    {\n    \"zh\", /**< Chinese >*/\n    \"zh-tw\", /**< Chinese (Taiwan) >*/\n    \"zh-cn\", /**< Chinese (PRC) >*/\n    \"zh-hk\", /**< Chinese (Hong Kong) >*/\n    \"zh-sg\", /**< Chinese (Singapore) >*/\n    },\n    {\"cs\"}, /**< Czech >*/\n    {\"da\"}, /**< Danish >*/\n    {\n    \"de\", /**< German >*/\n    \"de-de\", /**< German (Germany) >*/\n    \"de-ch\", /**< German (Switzerland) >*/\n    \"de-at\", /**< German (Austria) >*/\n    \"de-lu\", /**< German (Luxembourg) >*/\n    \"de-li\", /**< German (Liechtenstein) >*/\n    },\n    {\"el\"}, /**< Greek (modern) >*/\n    {\n    \"en\", /**< English >*/\n    \"en-us\", /**< English (United States) >*/\n    \"en-gb\", /**< English (United Kingdom) >*/\n    \"en-au\", /**< English (Australia) >*/\n    \"en-ca\", /**< English (Canada) >*/\n    \"en-nz\", /**< English (New Zealand) >*/\n    \"en-ie\", /**< English (Ireland) >*/\n    \"en-za\", /**< English (South Africa) >*/\n    \"en-jm\", /**< English (Jamaica) >*/\n    \"en\", /**< English (Unknown) >*/\n    \"en-bz\", /**< English (Belize) >*/\n    \"en-tt\", /**< English (Trinidad) >*/\n    \"en-zw\", /**< English (Zimbabwe) >*/\n    \"en-ph\", /**< English (Philippines) >*/\n    },\n    {\n    \"es\", /**< Spanish >*/\n    \"es-es\", /**< Spanish (Spain) >*/\n    \"es-mx\", /**< Spanish (Mexico) >*/\n    \"es\", /**< Spanish (Unknown) >*/\n    \"es-gt\", /**< Spanish (Guatemala) >*/\n    \"es-cr\", /**< Spanish (Costa Rica) >*/\n    \"es-pa\", /**< Spanish (Panama) >*/\n    \"es-do\", /**< Spanish (Dominican Republic) >*/\n    \"es-ve\", /**< Spanish (Venezuela) >*/\n    \"es-co\", /**< Spanish (Colombia) >*/\n    \"es-pe\", /**< Spanish (Peru) >*/\n    \"es-ar\", /**< Spanish (Argentina) >*/\n    \"es-ec\", /**< Spanish (Ecuador) >*/\n    \"es-cl\", /**< Spanish (Chile) >*/\n    \"es-uy\", /**< Spanish (Uruguay) >*/\n    \"es-py\", /**< Spanish (Paraguay) >*/\n    \"es-bo\", /**< Spanish (Bolivia) >*/\n    \"es-sv\", /**< Spanish (El Salvador) >*/\n    \"es-hn\", /**< Spanish (Honduras) >*/\n    \"es-ni\", /**< Spanish (Nicaragua) >*/\n    \"es-pr\", /**< Spanish (Puerto Rico) >*/\n    },\n    {\"fi\"}, /**< Finnish >*/\n    {\n    \"fr\", /**< French >*/\n    \"fr-fr\", /**< French (France) >*/\n    \"fr-be\", /**< French (Belgium) >*/\n    \"fr-ca\", /**< French (Canada) >*/\n    \"fr-ch\", /**< French (Switzerland) >*/\n    \"fr-lu\", /**< French (Luxembourg) >*/\n    \"fr-mc\", /**< French (Monaco) >*/\n    },\n    {\"he\"}, /**< Hebrew (also code iw) >*/\n    {\"hu\"}, /**< Hungarian >*/\n    {\"is\"}, /**< Icelandic >*/\n    {\n    \"it\", /**< Italian >*/\n    \"it-it\", /**< Italian (Italy) >*/\n    \"it-ch\", /**< Italian (Switzerland) >*/\n    },\n    {\"ja\"}, /**< Japanese >*/\n    {\"ko\"}, /**< Korean >*/\n    {\n    \"nl\", /**< Dutch / Flemish >*/\n    \"nl-nl\", /**< Dutch (Netherlands) >*/\n    \"nl-be\", /**< Dutch (Belgium) >*/\n    },\n    {\"no\"}, /**< Norwegian >*/\n    {\"pl\"}, /**< Polish >*/\n    {\n    \"pt\", /**< Portuguese >*/\n    \"pt-br\", /**< Portuguese (Brazil) >*/\n    \"pt-pt\", /**< Portuguese (Portugal) >*/\n    },\n    {\"rm\"}, /**< Romansh >*/\n    {\"ro\"}, /**< Romanian >*/\n    {\"ru\"}, /**< Russian >*/\n    {\n    \"hr\", /**< Croatian >*/\n    \"sr\", /**< Serbian >*/\n    \"sr\", /**< Serbian (Unknown) >*/\n    \"sr\", /**< Serbian (Unknown) >*/\n    \"sr\", /**< Serbian (Serbia) >*/\n    },\n    {\"sk\"}, /**< Slovak >*/\n    {\"sq\"}, /**< Albanian >*/\n    {\n    \"sv\", /**< Swedish >*/\n    \"sv-se\", /**< Swedish (Sweden) >*/\n    \"sv-fi\", /**< Swedish (Finland) >*/\n    },\n    {\"th\"}, /**< Thai >*/\n    {\"tr\"}, /**< Turkish >*/\n    {\"ur\"}, /**< Urdu >*/\n    {\"id\"}, /**< Indonesian >*/\n    {\"uk\"}, /**< Ukrainian >*/\n    {\"be\"}, /**< Belarusian >*/\n    {\"sl\"}, /**< Slovenian >*/\n    {\"et\"}, /**< Estonian >*/\n    {\"lv\"}, /**< Latvian >*/\n    {\"lt\"}, /**< Lithuanian >*/\n    [41] = {\"fa\"}, /**< Farsi / Persian >*/\n    {\"vi\"}, /**< Vietnamese >*/\n    {\"hy\"}, /**< Armenian >*/\n    {\"az\"}, /**< Azerbaijani >*/\n    {\"eu\"}, /**< Basque >*/\n    {\"sb\"}, /**< \"Sorbian\" >*/\n    {\"mk\"}, /**< Macedonian >*/\n    {\"sx\"}, /**< \"Sutu\" >*/\n    {\"ts\"}, /**< Tsonga >*/\n    {\"tn\"}, /**< Tswana >*/\n    [52] = {\"xh\"}, /**< Xhosa >*/\n    {\"zu\"}, /**< Zulu >*/\n    {\"af\"}, /**< Afrikaans >*/\n    {\"ka\"}, /**< Georgian >*/\n    {\"fo\"}, /**< Faroese >*/\n    {\"hi\"}, /**< Hindi >*/\n    {\"mt\"}, /**< Maltese >*/\n    {\"sz\"}, /**<\"Sami (Lappish)\" >*/\n    {\"ga\"}, /**< Irish */\n    [62] = {\"ms\"}, /**< Malay >*/\n    {\"kk\"}, /**< Kazakh >*/\n    [65] = {\"sw\"}, /**< Swahili >*/\n    [67] = {\n    \"uz\", /**< Uzbek >*/\n    \"uz\", /**< Uzbek (Unknown) >*/\n    \"uz-uz\", /**< Uzbek (Uzbekistan) >*/\n    },\n    {\"tt\"}, /**< Tatar >*/\n    {\"bn\"}, /**< Bengali >*/\n    {\"pa\"}, /**< Punjabi >*/\n    {\"gu\"}, /**< Gujarati >*/\n    {\"or\"}, /**< Oriya >*/\n    {\"ta\"}, /**< Tamil >*/\n    {\"te\"}, /**< Telugu >*/\n    {\"kn\"}, /**< Kannada >*/\n    {\"ml\"}, /**< Malayalam >*/\n    {\"as\"}, /**< Assamese (not accepted in kindlegen >*/\n    {\"mr\"}, /**< Marathi >*/\n    {\"sa\"}, /**< Sanskrit >*/\n    [82] = {\n    \"cy\", /**< Welsh */\n    \"cy-gb\" /**< Welsh (UK) */\n    },\n    {\n    \"gl\", /**< Galician */\n    \"gl-es\" /**< Galician (Spain) */\n    },\n    [87] = {\"x-kok\"}, /**< Konkani (real language code is kok) >*/\n    [97] = {\"ne\"}, /**< Nepali >*/\n    {\"fy\"}, /**< Northern Frysian >*/\n};\n\n/**\n @brief Get pointer to locale tag for a given Mobipocket locale number\n \n Locale strings are based on IANA language-subtag registry with some custom Mobipocket modifications.\n See mobi_locale array.\n \n @param[in] locale_number Mobipocket locale number (as stored in MOBI header)\n @return Pointer to locale string in mobi_locale array\n */\nconst char * mobi_get_locale_string(const uint32_t locale_number) {\n    uint8_t lang_code = locale_number & 0xffU;\n    uint32_t region_code = (locale_number >> 8) / 4;\n    if (lang_code >= MOBI_LANG_MAX || region_code >= MOBI_REGION_MAX) {\n        return NULL;\n    }\n    const char *string = mobi_locale[lang_code][region_code];\n    if (string == NULL || strlen(string) == 0 ) {\n        return NULL;\n    }\n    return string;\n}\n\n/**\n @brief Get Mobipocket locale number for a given string tag\n \n Locale strings are based on IANA language-subtag registry with some custom Mobipocket modifications. \n See mobi_locale array.\n \n @param[in] locale_string Locale string tag\n @return Mobipocket locale number\n */\nsize_t mobi_get_locale_number(const char *locale_string) {\n    if (locale_string == NULL || strlen(locale_string) < 2) {\n        return 0;\n    }\n    size_t lang_code = 0;\n    while (lang_code < MOBI_LANG_MAX) {\n        char *p = (char *) mobi_locale[lang_code][0];\n        if (p == NULL) {\n            lang_code++;\n            continue;\n        }\n        \n        if (tolower(locale_string[0]) != p[0] ||\n            tolower(locale_string[1]) != p[1]) {\n            lang_code++;\n            continue;\n        }\n        size_t region_code = 0;\n        while (region_code < MOBI_REGION_MAX) {\n            p = (char *) mobi_locale[lang_code][region_code];\n            if (p == NULL) { break; }\n            for (int i = 2;; i++) {\n                if (tolower(locale_string[i]) != p[i]) { break; }\n                if (p[i] == 0) {\n                    return (region_code * 4) << 8 | lang_code;\n                }\n            }\n            region_code++;\n        }\n        return lang_code;\n    }\n    return 0;\n}\n\n/**\n @brief Array of known file types, their extensions and mime-types.\n */\nconst MOBIFileMeta mobi_file_meta[] = {\n    {T_HTML, \"html\", \"application/xhtml+xml\"},\n    {T_CSS, \"css\", \"text/css\"},\n    {T_SVG, \"svg\", \"image/svg+xml\"},\n    {T_JPG, \"jpg\", \"image/jpeg\"},\n    {T_GIF, \"gif\", \"image/gif\"},\n    {T_PNG, \"png\", \"image/png\"},\n    {T_BMP, \"bmp\", \"image/bmp\"},\n    {T_OTF, \"otf\", \"application/vnd.ms-opentype\"},\n    {T_TTF, \"ttf\", \"application/x-font-truetype\"},\n    {T_MP3, \"mp3\", \"audio/mpeg\"},\n    {T_MPG, \"mpg\", \"video/mpeg\"},\n    {T_PDF, \"pdf\", \"application/pdf\"},\n    {T_OPF, \"opf\", \"application/oebps-package+xml\"},\n    {T_NCX, \"ncx\", \"application/x-dtbncx+xml\"},\n    /* termination struct */\n    {T_UNKNOWN, \"dat\", \"application/unknown\"}\n};\n\n/**\n @brief Get MOBIFileMeta tag structure by MOBIFiletype type\n \n @param[in] type MOBIFiletype type\n @return MOBIExthMeta structure for given type, .type = T_UNKNOWN on failure\n */\nMOBIFileMeta mobi_get_filemeta_by_type(const MOBIFiletype type) {\n    size_t i = 0;\n    while (mobi_file_meta[i].type != T_UNKNOWN) {\n        if (mobi_file_meta[i].type == type) {\n            return mobi_file_meta[i];\n        }\n        i++;\n    }\n    return mobi_file_meta[i];\n}\n\n/**\n @brief Get ebook full name stored in Record 0 at offset given in MOBI header\n \n @param[in] m MOBIData structure with loaded data\n @param[in,out] fullname Memory area to be filled with zero terminated full name string\n @param[in] len Maximum length of the string without null terminator\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_get_fullname(const MOBIData *m, char *fullname, const size_t len) {\n    if (fullname == NULL || len == 0) {\n        return MOBI_PARAM_ERR;\n    }\n    fullname[0] = '\\0';\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    if (m->mh == NULL || m->mh->full_name == NULL) {\n        return MOBI_INIT_FAILED;\n    }\n    if (mobi_is_cp1252(m)) {\n        size_t out_len = len + 1;\n        mobi_cp1252_to_utf8(fullname, m->mh->full_name, &out_len, strlen(m->mh->full_name));\n    } else {\n        strncpy(fullname, m->mh->full_name, len);\n        fullname[len] = '\\0';\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Set ebook full name stored in Record 0 at offset given in MOBI header\n \n @param[in,out] m MOBIData structure with loaded data\n @param[in] fullname Memory area to be filled with zero terminated full name string\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_set_fullname(MOBIData *m, const char *fullname) {\n    if (mobi_exists_mobiheader(m) && m->mh->full_name) {\n        size_t title_length = min(strlen(fullname), MOBI_TITLE_SIZEMAX);\n        char *new_title = malloc(title_length + 1);\n        if (new_title == NULL) {\n            return MOBI_MALLOC_FAILED;\n        }\n        if (mobi_is_cp1252(m)) {\n            size_t new_size = title_length + 1;\n            MOBI_RET ret = mobi_utf8_to_cp1252(new_title, fullname, &new_size, title_length);\n            if (ret != MOBI_SUCCESS) {\n                free(new_title);\n                return ret;\n            }\n        } else {\n            memcpy(new_title, fullname, title_length);\n            new_title[title_length] = '\\0';\n        }\n        free(m->mh->full_name);\n        m->mh->full_name = new_title;\n        if (mobi_is_hybrid(m) && mobi_exists_mobiheader(m->next) && m->next->mh->full_name) {\n            char *new_title2 = strdup(new_title);\n            if (new_title2 == NULL) {\n                return MOBI_MALLOC_FAILED;\n            }\n            free(m->next->mh->full_name);\n            m->next->mh->full_name = new_title2;\n        }\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Set palm database name\n \n @param[in,out] m MOBIData structure with loaded data\n @param[in] name Name\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_set_pdbname(MOBIData *m, const char *name) {\n    if (m == NULL || m->ph == NULL) {\n        return MOBI_INIT_FAILED;\n    }\n    char dbname[PALMDB_NAME_SIZE_MAX + 1];\n    if (mobi_is_cp1252(m)) {\n        size_t size = PALMDB_NAME_SIZE_MAX + 1;\n        MOBI_RET ret = mobi_utf8_to_cp1252(dbname, name, &size, strlen(name));\n        if (ret != MOBI_SUCCESS) {\n            return ret;\n        }\n    } else {\n        memcpy(dbname, name, PALMDB_NAME_SIZE_MAX);\n        dbname[PALMDB_NAME_SIZE_MAX] = '\\0';\n    }\n    char c;\n    int i = 0;\n    while ((c = dbname[i])) {\n        if (!isalnum(c)) {\n            c = '_';\n        }\n        m->ph->name[i++] = c;\n    }\n    m->ph->name[i] = '\\0';\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Get palm database record with given unique id\n \n @param[in] m MOBIData structure with loaded data\n @param[in] uid Unique id\n @return Pointer to MOBIPdbRecord record structure, NULL on failure\n */\nMOBIPdbRecord * mobi_get_record_by_uid(const MOBIData *m, const size_t uid) {\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return NULL;\n    }\n    if (m->rec == NULL) {\n        return NULL;\n    }\n    MOBIPdbRecord *curr = m->rec;\n    while (curr != NULL) {\n        if (curr->uid == uid) {\n            return curr;\n        }\n        curr = curr->next;\n    }\n    return NULL;\n}\n\n/**\n @brief Get rawml->markup MOBIPart part by uid\n \n @param[in] rawml MOBIRawml structure with loaded data\n @param[in] uid Unique id\n @return Pointer to MOBIPart structure, NULL on failure\n */\nMOBIPart * mobi_get_part_by_uid(const MOBIRawml *rawml, const size_t uid) {\n    if (rawml == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return NULL;\n    }\n    if (rawml->markup == NULL) {\n        return NULL;\n    }\n    MOBIPart *part = rawml->markup;\n    while (part != NULL) {\n        if (part->uid == uid) {\n            return part;\n        }\n        part = part->next;\n    }\n    return NULL;\n}\n\n/**\n @brief Get rawml->flow MOBIPart part by uid\n \n @param[in] rawml MOBIRawml structure with loaded data\n @param[in] uid Unique id\n @return Pointer to MOBIPart structure, NULL on failure\n */\nMOBIPart * mobi_get_flow_by_uid(const MOBIRawml *rawml, const size_t uid) {\n    if (rawml == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return NULL;\n    }\n    if (rawml->flow == NULL) {\n        return NULL;\n    }\n    MOBIPart *part = rawml->flow;\n    while (part != NULL) {\n        if (part->uid == uid) {\n            return part;\n        }\n        part = part->next;\n    }\n    return NULL;\n}\n\n/**\n @brief Find flow part by flow id (fid) from kindle:flow:fid link.\n Flow fid is base32 encoded part uid.\n \n @param[in] rawml Structure MOBIRawml\n @param[in] fid String four character base32 fid\n @return Pointer to MOBIPart structure, NULL on failure\n */\nMOBIPart * mobi_get_flow_by_fid(const MOBIRawml *rawml, const char *fid) {\n    /* get file number */\n    uint32_t part_id;\n    MOBI_RET ret = mobi_base32_decode(&part_id, fid);\n    if (ret != MOBI_SUCCESS) {\n        return NULL;\n    }\n    return mobi_get_flow_by_uid(rawml, part_id);\n}\n\n/**\n @brief Get MOBIPart resource record with given unique id\n \n @param[in] rawml MOBIRawml structure with loaded data\n @param[in] uid Unique id\n @return Pointer to MOBIPart resource structure, NULL on failure\n */\nMOBIPart * mobi_get_resource_by_uid(const MOBIRawml *rawml, const size_t uid) {\n    if (rawml == NULL) {\n        debug_print(\"%s\", \"Rawml structure not initialized\\n\");\n        return NULL;\n    }\n    if (rawml->resources == NULL) {\n        debug_print(\"%s\", \"Rawml structure not initialized\\n\");\n        return NULL;\n    }\n    MOBIPart *curr = rawml->resources;\n    while (curr != NULL) {\n        if (curr->uid == uid) {\n            return curr;\n        }\n        curr = curr->next;\n    }\n    return NULL;\n}\n\n/**\n @brief Find resource by flow id (fid) from kindle:embed:fid link.\n Flow fid is base32 encoded part uid.\n \n @param[in] rawml Structure MOBIRawml\n @param[in] fid String four character base32 fid\n @return Pointer to MOBIPart structure, NULL on failure\n */\nMOBIPart * mobi_get_resource_by_fid(const MOBIRawml *rawml, const char *fid) {\n    /* get file number */\n    uint32_t part_id;\n    MOBI_RET ret = mobi_base32_decode(&part_id, fid);\n    if (ret != MOBI_SUCCESS) {\n        return NULL;\n    }\n    part_id--;\n    return mobi_get_resource_by_uid(rawml, part_id);\n}\n\n/**\n @brief Get MOBIFiletype type of MOBIPart resource record with given unique id\n \n @param[in] rawml MOBIRawml structure with loaded data\n @param[in] uid Unique id\n @return Pointer to MOBIPart resource structure, NULL on failure\n */\nMOBIFiletype mobi_get_resourcetype_by_uid(const MOBIRawml *rawml, const size_t uid) {\n    if (rawml == NULL) {\n        debug_print(\"%s\", \"Rawml structure not initialized\\n\");\n        return T_UNKNOWN;\n    }\n    if (rawml->resources == NULL) {\n        debug_print(\"%s\", \"Rawml structure not initialized\\n\");\n        return T_UNKNOWN;\n    }\n    MOBIPart *curr = rawml->resources;\n    while (curr != NULL) {\n        if (curr->uid == uid) {\n            return curr->type;\n        }\n        curr = curr->next;\n    }\n    return T_UNKNOWN;\n}\n\n/**\n @brief Get palm database record with given sequential number (first record has number 0)\n \n @param[in] m MOBIData structure with loaded data\n @param[in] num Sequential number\n @return Pointer to MOBIPdbRecord record structure, NULL on failure\n */\nMOBIPdbRecord * mobi_get_record_by_seqnumber(const MOBIData *m, const size_t num) {\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return NULL;\n    }\n    if (m->rec == NULL) {\n        return NULL;\n    }\n    MOBIPdbRecord *curr = m->rec;\n    size_t i = 0;\n    while (curr != NULL) {\n        if (i++ == num) {\n            return curr;\n        }\n        curr = curr->next;\n    }\n    return NULL;\n}\n\n/**\n @brief Get palm database record with data header starting with given 4-byte magic string\n \n @param[in] m MOBIData structure with loaded data\n @param[in] magic Magic header\n @return Pointer to MOBIPdbRecord record structure, NULL if not found or on failure\n */\nMOBIPdbRecord * mobi_get_record_by_magic(const MOBIData *m, const unsigned char magic[4]) {\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return NULL;\n    }\n\n    MOBIPdbRecord *curr = m->rec;\n    while (curr != NULL) {\n        if (curr->size >= 4 && memcmp(curr->data, magic, 4) != 0) {\n            return curr;\n        }\n        curr = curr->next;\n    }\n    return NULL;\n}\n\n\n/**\n @brief Extract palm count database records starting with given sequential number from MOBIData structure\n \n Extracted records are removed from palm database.\n Number of extracted records may be less then given count, if there are not enough records in database.\n \n @param[in,out] m MOBIData structure with loaded data\n @param[in] num Sequential number\n @param[in,out] count Records count, updated with number of records effectively extracted\n @return Pointer to MOBIPdbRecord record structure, NULL if not found or on failure\n */\nMOBIPdbRecord * mobi_extract_records_by_seqnumber(MOBIData *m, const size_t num, size_t *count) {\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return NULL;\n    }\n\n    MOBIPdbRecord *root = NULL;\n    MOBIPdbRecord *prev = NULL;\n    MOBIPdbRecord *curr = NULL;\n    if (num > 0) {\n        root = mobi_get_record_by_seqnumber(m, num - 1);\n        if (root) {\n            curr = root->next;\n        }\n    } else {\n        curr = m->rec;\n    }\n        \n    MOBIPdbRecord *extracted = curr;\n\n    size_t i = 0;\n    while (curr != NULL && i < *count) {\n        i++;\n        prev = curr;\n        curr = curr->next;\n    }\n    \n    if (prev == NULL) {\n        return NULL;\n    }\n    \n    if (root == NULL) {\n        m->rec = prev->next;\n    } else {\n        root->next = prev->next;\n    }\n    prev->next = NULL;\n    \n    *count = i;\n    if (m->ph->rec_count >= i) {\n        m->ph->rec_count -= i;\n    } else {\n        debug_print(\"%s\\n\", \"Real record count differs from header value\");\n        m->ph->rec_count = 0;\n    }\n\n    debug_print(\"Extracted %zu records starting with index = %zu\\n\", *count, num);\n\n    return extracted;\n}\n\n\n/**\n @brief Insert palm database records at given sequential number\n \n @param[in,out] m MOBIData structure with loaded data\n @param[in,out] record Linked list of records\n @param[in] num Sequential number\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_insert_records_by_seqnumber(MOBIData *m, MOBIPdbRecord *record, const size_t num) {\n    if (m == NULL || m->rec == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    if (record == NULL) {\n        return MOBI_SUCCESS;\n    }\n    \n    MOBIPdbRecord *curr = record;\n    size_t count = 1;\n    while (curr->next != NULL) {\n        curr = curr->next;\n        count++;\n    }\n    \n    if (m->ph->rec_count + count > UINT16_MAX) {\n        debug_print(\"%s\", \"Number of records beyond database limit\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    \n    MOBIPdbRecord *next = NULL;\n    if (num == 0) {\n        next = m->rec;\n        m->rec = record;\n    } else {\n        MOBIPdbRecord *prev = mobi_get_record_by_seqnumber(m, num - 1);\n        if (prev == NULL) {\n            debug_print(\"%s\", \"Insert point not found\\n\");\n            return MOBI_DATA_CORRUPT;\n        }\n        next = prev->next;\n        prev->next = record;\n    }\n    curr->next = next;\n    m->ph->rec_count += count;\n\n    debug_print(\"Inserted %zu records at index = %zu\\n\", count, num);\n        \n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Delete palm count database records starting with given sequential number from MOBIData structure\n \n Number of deleted records may be less then given count, if there are not enough records in database.\n \n @param[in,out] m MOBIData structure with loaded data\n @param[in] num Sequential number\n @param[in,out] count  Records count, updated wth number of records effectively extracted\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_delete_records_by_seqnumber(MOBIData *m, const size_t num, size_t *count) {\n    \n    // extract records\n    MOBIPdbRecord *curr = mobi_extract_records_by_seqnumber(m, num, count);\n\n    // delete them\n    while (curr != NULL) {\n        MOBIPdbRecord *tmp = curr;\n        curr = curr->next;\n        free(tmp->data);\n        free(tmp);\n        tmp = NULL;\n    }\n    \n    debug_print(\"Deleted %zu records starting with index = %zu\\n\", *count, num);\n\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Delete palm database record with given sequential number from MOBIData structure\n \n @param[in,out] m MOBIData structure with loaded data\n @param[in] num Sequential number\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_delete_record_by_seqnumber(MOBIData *m, const size_t num) {\n    size_t count = 1;\n    return mobi_delete_records_by_seqnumber(m, num, &count);\n}\n\n/**\n @brief Get EXTH record with given MOBIExthTag tag\n \n @param[in] m MOBIData structure with loaded data\n @param[in] tag MOBIExthTag EXTH record tag\n @return Pointer to MOBIExthHeader record structure\n */\nMOBIExthHeader * mobi_get_exthrecord_by_tag(const MOBIData *m, const MOBIExthTag tag) {\n    debug_print(\"Loading EXTH record with tag %i\\n\", tag);\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return NULL;\n    }\n    if (m->eh == NULL) {\n        return NULL;\n    }\n    MOBIExthHeader *curr = m->eh;\n    while (curr != NULL) {\n        if (curr->tag == tag) {\n            return curr;\n        }\n        curr = curr->next;\n    }\n    return NULL;\n}\n\n/**\n @brief Get EXTH record with given MOBIExthTag tag. Start list search at given record.\n \n If start_tag is NULL search will start from the root of the linked list.\n After successfull search start will be set to next record in the list.\n \n @param[in] m MOBIData structure with loaded data\n @param[in] tag MOBIExthTag EXTH record tag\n @param[in,out] start MOBIExthHeader EXTH record to begin search with\n @return Pointer to MOBIExthHeader record structure\n */\nMOBIExthHeader * mobi_next_exthrecord_by_tag(const MOBIData *m, const MOBIExthTag tag, MOBIExthHeader **start) {\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return NULL;\n    }\n    if (m->eh == NULL) {\n        return NULL;\n    }\n    MOBIExthHeader *curr;\n    if (*start) {\n        curr = *start;\n        *start = NULL;\n    } else {\n        curr = m->eh;\n    }\n    while (curr != NULL) {\n        if (curr->tag == tag) {\n            *start = curr->next;\n            return curr;\n        }\n        curr = curr->next;\n    }\n    return NULL;\n}\n\n/**\n @brief Add new EXTH record with given tag and value.\n \n @param[in,out] m MOBIData structure with loaded data\n @param[in] tag MOBIExthTag EXTH record tag\n @param[in] size Value size\n @param[in] value Value\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_add_exthrecord(MOBIData *m, const MOBIExthTag tag, const uint32_t size, const void *value) {\n    if (size == 0) {\n        debug_print(\"%s\\n\", \"Record size is zero\");\n        return MOBI_PARAM_ERR;\n    }\n    size_t count = 2;\n    while (m && count--) {\n        if (m->mh == NULL) {\n            debug_print(\"%s\\n\", \"Mobi header must be initialized\");\n            return MOBI_INIT_FAILED;\n        }\n        MOBIExthMeta meta = mobi_get_exthtagmeta_by_tag(tag);\n        MOBIExthHeader *record = calloc(1, sizeof(MOBIExthHeader));\n        if (record == NULL) {\n            debug_print(\"%s\\n\", \"Memory allocation for EXTH record failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        record->tag = tag;\n        record->size = size;\n        record->data = malloc(size);\n        if (record->data == NULL) {\n            debug_print(\"%s\\n\", \"Memory allocation for EXTH data failed\");\n            free(record);\n            return MOBI_MALLOC_FAILED;\n        }\n        if (meta.type == EXTH_STRING && mobi_is_cp1252(m)) {\n            debug_print(\"%s\\n\", \"Adding CP1252 string data\");\n            char *data = malloc(size + 1);\n            if (data == NULL) {\n                free(record->data);\n                free(record);\n                return MOBI_MALLOC_FAILED;\n            }\n            size_t data_size = size + 1;\n            MOBI_RET ret = mobi_utf8_to_cp1252(data, value, &data_size, size);\n            if (ret != MOBI_SUCCESS) {\n                free(record->data);\n                free(record);\n                free(data);\n                return ret;\n            }\n            memcpy(record->data, data, data_size);\n            record->size = (uint32_t) data_size;\n            free(data);\n        } else if (meta.name && meta.type == EXTH_NUMERIC && size == sizeof(uint32_t)) {\n            debug_print(\"%s\\n\", \"Adding numeric data\");\n            MOBIBuffer *buf = mobi_buffer_init_null(record->data, size);\n            if (buf == NULL) {\n                free(record->data);\n                free(record);\n                return MOBI_MALLOC_FAILED;\n            }\n            mobi_buffer_add32(buf, *(uint32_t *) value);\n            mobi_buffer_free_null(buf);\n        } else {\n            debug_print(\"%s\\n\", \"Adding raw data\");\n            memcpy(record->data, value, size);\n        }\n        debug_print(\"Added record %u (%u bytes)\\n\", meta.tag, size);\n\n        record->next = NULL;\n        if (m->eh == NULL) {\n            if (m->mh->exth_flags == NULL) {\n                m->mh->exth_flags = malloc(sizeof(uint32_t));\n                if (m->mh->exth_flags == NULL) {\n                    debug_print(\"%s\\n\", \"Memory allocation failed\");\n                    free(record->data);\n                    free(record);\n                    return MOBI_MALLOC_FAILED;\n                }\n            }\n            *m->mh->exth_flags = 0x40;\n            m->eh = record;\n        } else {\n            MOBIExthHeader *curr = m->eh;\n            while(curr->next) {\n                curr = curr->next;\n            }\n            curr->next = record;\n        }\n        m = m->next;\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Delete EXTH record.\n \n @param[in,out] m MOBIData structure with loaded data\n @param[in] record Record to be deleted\n @return Pointer to next record in the linked list (NULL if none)\n */\nMOBIExthHeader * mobi_delete_exthrecord(MOBIData *m, MOBIExthHeader *record) {\n    if (record == NULL || m == NULL || m->eh == NULL) {\n        return NULL;\n    }\n    MOBIExthHeader *next = record->next;\n    if (next) {\n        /* not last */\n        MOBIExthHeader *curr = m->eh;\n        if (curr == record) {\n            /* first */\n            m->eh = next;\n        } else {\n            /* not first */\n            while (curr) {\n                if (curr->next == record) {\n                    curr->next = next;\n                    break;\n                }\n                curr = curr->next;\n            }\n        }\n        free(record->data);\n        free(record);\n    } else if (m->eh == record) {\n        /* last && first */\n        free(m->eh->data);\n        free(m->eh);\n        m->eh = NULL;\n    } else {\n        /* last */\n        MOBIExthHeader *curr = m->eh;\n        while (curr) {\n            if (curr->next == record) {\n                curr->next = NULL;\n                break;\n            }\n            curr = curr->next;\n        }\n        free(record->data);\n        free(record);\n    }\n    return next;\n}\n\n/**\n @brief Delete all EXTH records with given MOBIExthTag tag\n \n @param[in,out] m MOBIData structure with loaded data\n @param[in] tag MOBIExthTag EXTH record tag\n @return Pointer to MOBIExthHeader record structure\n */\nMOBI_RET mobi_delete_exthrecord_by_tag(MOBIData *m, const MOBIExthTag tag) {\n    size_t count = 2;\n    while (m && count--) {\n        if (m->eh == NULL) {\n            debug_print(\"%s\", \"No exth records\\n\");\n            return MOBI_SUCCESS;\n        }\n        MOBIExthHeader *curr = m->eh;\n        while (curr) {\n            if (curr->tag == tag) {\n                curr = mobi_delete_exthrecord(m, curr);\n            } else {\n                curr = curr->next;\n            }\n        }\n        m = m->next;\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Array of known EXTH tags.\n Name strings shamelessly copied from KindleUnpack\n */\nconst MOBIExthMeta mobi_exth_tags[] = {\n    /* numeric */\n    {EXTH_SAMPLE, EXTH_NUMERIC, \"Sample\"},\n    {EXTH_STARTREADING, EXTH_NUMERIC, \"Start offset\"},\n    {EXTH_KF8BOUNDARY, EXTH_NUMERIC, \"K8 boundary offset\"},\n    {EXTH_COUNTRESOURCES, EXTH_NUMERIC, \"K8 count of resources, fonts, images\"},\n    {EXTH_RESCOFFSET, EXTH_NUMERIC, \"RESC offset\"},\n    {EXTH_COVEROFFSET, EXTH_NUMERIC, \"Cover offset\"},\n    {EXTH_THUMBOFFSET, EXTH_NUMERIC, \"Thumbnail offset\"},\n    {EXTH_HASFAKECOVER, EXTH_NUMERIC, \"Has fake cover\"},\n    {EXTH_CREATORSOFT, EXTH_NUMERIC, \"Creator software\"},\n    {EXTH_CREATORMAJOR, EXTH_NUMERIC, \"Creator major version\"},\n    {EXTH_CREATORMINOR, EXTH_NUMERIC, \"Creator minor version\"},\n    {EXTH_CREATORBUILD, EXTH_NUMERIC, \"Creator build number\"},\n    {EXTH_CLIPPINGLIMIT, EXTH_NUMERIC, \"Clipping limit\"},\n    {EXTH_PUBLISHERLIMIT, EXTH_NUMERIC, \"Publisher limit\"},\n    {EXTH_TTSDISABLE, EXTH_NUMERIC, \"Text to speech disabled\"},\n    {EXTH_READFORFREE, EXTH_NUMERIC, \"Read for Free\"},\n    /* strings */\n    {EXTH_DRMSERVER, EXTH_STRING, \"Drm server id\"},\n    {EXTH_DRMCOMMERCE, EXTH_STRING, \"Drm commerce id\"},\n    {EXTH_DRMEBOOKBASE, EXTH_STRING, \"Drm Ebookbase book id\"},\n    {EXTH_TITLE, EXTH_STRING, \"Title\"},\n    {EXTH_AUTHOR, EXTH_STRING, \"Creator\"},\n    {EXTH_PUBLISHER, EXTH_STRING, \"Publisher\"},\n    {EXTH_IMPRINT, EXTH_STRING, \"Imprint\"},\n    {EXTH_DESCRIPTION, EXTH_STRING, \"Description\"},\n    {EXTH_ISBN, EXTH_STRING, \"ISBN\"},\n    {EXTH_SUBJECT, EXTH_STRING, \"Subject\"},\n    {EXTH_PUBLISHINGDATE, EXTH_STRING, \"Published\"},\n    {EXTH_REVIEW, EXTH_STRING, \"Review\"},\n    {EXTH_CONTRIBUTOR, EXTH_STRING, \"Contributor\"},\n    {EXTH_RIGHTS, EXTH_STRING, \"Rights\"},\n    {EXTH_SUBJECTCODE, EXTH_STRING, \"Subject code\"},\n    {EXTH_TYPE, EXTH_STRING, \"Type\"},\n    {EXTH_SOURCE, EXTH_STRING, \"Source\"},\n    {EXTH_ASIN, EXTH_STRING, \"ASIN\"},\n    {EXTH_VERSION, EXTH_STRING, \"Version number\"},\n    {EXTH_ADULT, EXTH_STRING, \"Adult\"},\n    {EXTH_PRICE, EXTH_STRING, \"Price\"},\n    {EXTH_CURRENCY, EXTH_STRING, \"Currency\"},\n    {EXTH_FIXEDLAYOUT, EXTH_STRING, \"Fixed layout\"},\n    {EXTH_BOOKTYPE, EXTH_STRING, \"Book type\"},\n    {EXTH_ORIENTATIONLOCK, EXTH_STRING, \"Orientation lock\"},\n    {EXTH_ORIGRESOLUTION, EXTH_STRING, \"Original resolution\"},\n    {EXTH_ZEROGUTTER, EXTH_STRING, \"Zero gutter\"},\n    {EXTH_ZEROMARGIN, EXTH_STRING, \"Zero margin\"},\n    {EXTH_KF8COVERURI, EXTH_STRING, \"K8 masthead/cover image\"},\n    {EXTH_REGIONMAGNI, EXTH_STRING, \"Region magnification\"},\n    {EXTH_DICTNAME, EXTH_STRING, \"Dictionary short name\"},\n    {EXTH_WATERMARK, EXTH_STRING, \"Watermark\"},\n    {EXTH_DOCTYPE, EXTH_STRING, \"Document type\"},\n    {EXTH_LASTUPDATE, EXTH_STRING, \"Last update time\"},\n    {EXTH_UPDATEDTITLE, EXTH_STRING, \"Updated title\"},\n    {EXTH_ASIN504, EXTH_STRING, \"ASIN (504)\"},\n    {EXTH_TITLEFILEAS, EXTH_STRING, \"Title file as\"},\n    {EXTH_CREATORFILEAS, EXTH_STRING, \"Creator file as\"},\n    {EXTH_PUBLISHERFILEAS, EXTH_STRING, \"Publisher file as\"},\n    {EXTH_LANGUAGE, EXTH_STRING, \"Language\"},\n    {EXTH_ALIGNMENT, EXTH_STRING, \"Primary writing mode\"},\n    {EXTH_PAGEDIR, EXTH_STRING, \"Page progression direction\"},\n    {EXTH_OVERRIDEFONTS, EXTH_STRING, \"Override kindle fonts\"},\n    {EXTH_SORCEDESC, EXTH_STRING, \"Original source description\"},\n    {EXTH_DICTLANGIN, EXTH_STRING, \"Dictionary input language\"},\n    {EXTH_DICTLANGOUT, EXTH_STRING, \"Dictionary output language\"},\n    {EXTH_INPUTSOURCE, EXTH_STRING, \"Input source type\"},\n    {EXTH_CREATORBUILDREV, EXTH_STRING, \"Creator build revision\"},\n    {EXTH_CREATORSTRING, EXTH_STRING, \"Creator software string\"},\n    /* binary */\n    {EXTH_TAMPERKEYS, EXTH_BINARY, \"Tamper proof keys\"},\n    {EXTH_FONTSIGNATURE, EXTH_BINARY, \"Font signature\"},\n    {EXTH_RENTAL, EXTH_BINARY, \"Rental indicator\"}, // uint64_t\n    {EXTH_UNK403, EXTH_BINARY, \"Unknown (403)\"},\n    {EXTH_UNK407, EXTH_BINARY, \"Unknown (407)\"},\n    {EXTH_UNK450, EXTH_BINARY, \"Unknown (450)\"},\n    {EXTH_UNK451, EXTH_BINARY, \"Unknown (451)\"},\n    {EXTH_UNK452, EXTH_BINARY, \"Unknown (452)\"},\n    {EXTH_UNK453, EXTH_BINARY, \"Unknown (453)\"},\n /* end */\n    {0, 0, NULL},\n};\n\n/**\n @brief Get MOBIExthMeta tag structure by MOBIExthTag tag id\n \n @param[in] tag Tag id\n @return MOBIExthMeta structure for given tag id, zeroed structure on failure\n */\nMOBIExthMeta mobi_get_exthtagmeta_by_tag(const MOBIExthTag tag) {\n    size_t i = 0;\n    while (mobi_exth_tags[i].tag > 0) {\n        if (mobi_exth_tags[i].tag == tag) {\n            return mobi_exth_tags[i];\n        }\n        i++;\n    }\n    return (MOBIExthMeta) {0, 0, NULL};\n}\n\n/**\n @brief Decode big-endian value stored in EXTH record\n \n Only for EXTH records storing numeric values\n \n @param[in] data Memory area storing EXTH record data\n @param[in] size Size of EXTH record data\n @return 32-bit value\n */\nuint32_t mobi_decode_exthvalue(const unsigned char *data, const size_t size) {\n    /* FIXME: EXTH numeric data is max 32-bit? */\n    uint32_t val = 0;\n    size_t i = min(size, 4);\n    while (i--) {\n        val |= (uint32_t) *data++ << (i * 8);\n    }\n    return val;\n}\n\n#define MOBI_UTF8_MAXBYTES 4\n/**\n @brief Html entity mapping to utf-8 sequence\n */\ntypedef struct {\n    const char *name; /**< Html entity name */\n    const char utf8_bytes[MOBI_UTF8_MAXBYTES + 1]; /**< Utf-8 sequence */\n} HTMLEntity;\n\n/**\n @brief Basic named html entities mapping to utf-8 sequences\n */\nconst HTMLEntity entities[] = {\n    { \"&quot;\", \"\\\"\" },\n    { \"&amp;\", \"&\" },\n    { \"&lt;\", \"<\" },\n    { \"&gt;\", \">\" },\n    { \"&apos;\", \"'\" },\n    { \"&nbsp;\", \"\\xc2\\xa0\" },\n    { \"&copy;\", \"\\xc2\\xa9\" },\n    { \"&reg;\", \"\\xc2\\xae\" },\n    { \"&cent;\", \"\\xc2\\xa2\" },\n    { \"&pound;\", \"\\xc2\\xa3\" },\n    { \"&sect;\", \"\\xc2\\xa7\" },\n    { \"&laquo;\", \"\\xc2\\xab\" },\n    { \"&raquo;\", \"\\xc2\\xbb\" },\n    { \"&deg;\", \"\\xc2\\xb0\" },\n    { \"&plusmn;\", \"\\xc2\\xb1\" },\n    { \"&middot;\", \"\\xc2\\xb7\" },\n    { \"&frac12;\", \"\\xc2\\xbd\" },\n    { \"&ndash;\", \"\\xe2\\x80\\x93\" },\n    { \"&mdash;\", \"\\xe2\\x80\\x94\" },\n    { \"&lsquo;\", \"\\xe2\\x80\\x98\" },\n    { \"&sbquo;\", \"\\xe2\\x80\\x9a\" },\n    { \"&ldquo;\", \"\\xe2\\x80\\x9c\" },\n    { \"&rdquo;\", \"\\xe2\\x80\\x9d\" },\n    { \"&bdquo;\", \"\\xe2\\x80\\x9e\" },\n    { \"&dagger;\", \"\\xe2\\x80\\xa0\" },\n    { \"&Dagger;\", \"\\xe2\\x80\\xa1\" },\n    { \"&bull;\", \"\\xe2\\x80\\xa2\" },\n    { \"&hellip;\", \"\\xe2\\x80\\xa6\" },\n    { \"&prime;\", \"\\xe2\\x80\\xb2\" },\n    { \"&Prime;\", \"\\xe2\\x80\\xb3\" },\n    { \"&euro;\", \"\\xe2\\x82\\xac\" },\n    { \"&trade;\", \"\\xe2\\x84\\xa2\" }\n};\n\n/**\n @brief Convert html entities in string to utf-8 characters\n \n @param[in] input Input string\n @return Converted string\n */\nchar * mobi_decode_htmlentities(const char *input) {\n    if (!input) {\n        return NULL;\n    }\n    const size_t codepoint_max = 0x10ffff;\n    size_t output_length = strlen(input) + 1;\n    char *in = (char *) input;\n    /* output size will be less or equal to input */\n    char *output = malloc(output_length);\n    char *out = output;\n    if (output == NULL) {\n        debug_print(\"Memory allocation failed (%zu bytes)\\n\", output_length);\n        return NULL;\n    }\n    char *offset = in;\n    while ((in = strchr(in, '&'))) {\n        size_t decoded_length = 0;\n        char *end = NULL;\n        char decoded[MOBI_UTF8_MAXBYTES + 1] = { 0 };\n        if (in[1] == '#' && (in[2] == 'x' || in[2] == 'X')) {\n            // hex entity\n            size_t codepoint = strtoul(in + 3, &end, 16);\n            if (*end++ == ';' && codepoint <= codepoint_max) {\n                decoded_length = mobi_unicode_to_utf8(decoded, codepoint);\n            }\n        } else if (in[1] == '#') {\n            // dec entity\n            size_t codepoint = strtoul(in + 2, &end, 10);\n            if (*end++ == ';' && codepoint <= codepoint_max) {\n                decoded_length = mobi_unicode_to_utf8(decoded, codepoint);\n            }\n        } else {\n            // named entity\n            for (size_t i = 0; i < ARRAYSIZE(entities); i++) {\n                if (strncmp(in, entities[i].name, strlen(entities[i].name)) == 0) {\n                    int ret = snprintf(decoded, MOBI_UTF8_MAXBYTES + 1, \"%s\", entities[i].utf8_bytes);\n                    if (ret > 0) {\n                        decoded_length = (size_t) ret;\n                        end = in + strlen(entities[i].name);\n                        break;\n                    }\n                }\n            }\n        }\n        if (decoded_length) {\n            size_t len = (size_t) (in - offset);\n            memcpy(out, offset, len);\n            offset = end;\n            out += len;\n            memcpy(out, decoded, decoded_length);\n            out += decoded_length;\n        }\n        in += decoded_length + 1;\n    }\n    strcpy(out, offset);\n    return output;\n}\n\n/**\n @brief Decode string stored in EXTH record\n \n Only for EXTH records storing string values\n \n @param[in] m MOBIData structure loaded with MOBI data\n @param[in] data Memory area storing EXTH record data\n @param[in] size Size of EXTH record data\n @return String from EXTH record in utf-8 encoding\n */\nchar * mobi_decode_exthstring(const MOBIData *m, const unsigned char *data, const size_t size) {\n    if (!m || !data) {\n        return NULL;\n    }\n    size_t out_length = 3 * size + 1;\n    size_t in_length = size;\n    char *exth_string = malloc(out_length);\n    if (exth_string == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return NULL;\n    }\n    if (mobi_is_cp1252(m)) {\n        MOBI_RET ret = mobi_cp1252_to_utf8(exth_string, (const char *) data, &out_length, in_length);\n        if (ret != MOBI_SUCCESS) {\n            free(exth_string);\n            return NULL;\n        }\n    } else {\n        memcpy(exth_string, data, size);\n        out_length = size;\n    }\n    exth_string[out_length] = '\\0';\n    char *exth_decoded = mobi_decode_htmlentities(exth_string);\n    if (exth_decoded != NULL) {\n        free(exth_string);\n        return exth_decoded;\n    }\n    return exth_string;\n}\n\n/**\n @brief Swap endianness of 32-bit value\n \n @param[in] val 4-byte unsigned integer\n @return Integer with swapped endianness\n */\nuint32_t mobi_swap32(const uint32_t val) {\n    return ((((val) >> 24) & 0x000000ff) |\n            (((val) >>  8) & 0x0000ff00) |\n            (((val) <<  8) & 0x00ff0000) |\n            (((val) << 24) & 0xff000000));\n\n}\n\n/**\n @brief Convert time values from palmdoc header to time tm struct\n \n Older files set time in mac format. Newer ones in unix time.\n \n @param[in] pdb_time Time value from PDB header\n @return Time structure struct tm of time.h\n */\nstruct tm * mobi_pdbtime_to_time(const long pdb_time) {\n    time_t time = pdb_time;\n    const int unix1996 = 820454400;\n    if (time < unix1996 && time > 0) {\n        /* sometimes dates are stored as little endian */\n        time = mobi_swap32((uint32_t) time);\n    }\n    const uint32_t mactime_flag = (uint32_t) (1U << 31);\n    if (time & mactime_flag) {\n        debug_print(\"%s\\n\", \"mac time\");\n        time -= EPOCH_MAC_DIFF;\n    }\n    return localtime(&time);\n}\n\n/**\n @brief Lookup table for number of bits set in a single byte\n */\nstatic const char setbits[256] = {\n    0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,\n    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n    4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8,\n};\n\n/**\n @brief Get number of bits set in a given byte\n \n @param[in] byte A byte\n @return Number of bits set\n */\nint mobi_bitcount(const uint8_t byte) {\n    return setbits[byte];\n}\n\n/**\n @brief Decompress text record (internal).\n \n Internal function for mobi_get_rawml and mobi_dump_rawml. \n Decompressed output is stored either in a file or in a text string\n \n @param[in] m MOBIData structure loaded with MOBI data\n @param[in,out] text Memory area to be filled with decompressed output\n @param[in,out] file If not NULL output is written to the file, otherwise to text string\n @param[in,out] len Length of the memory allocated for the text string, on return set to decompressed text length\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nstatic MOBI_RET mobi_decompress_content(const MOBIData *m, char *text, FILE *file, size_t *len) {\n    int dump = false;\n    if (file != NULL) {\n        dump = true;\n    }\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    if (mobi_is_encrypted(m) && !mobi_has_drmkey(m)) {\n        debug_print(\"%s\", \"Document is encrypted\\n\");\n        return MOBI_FILE_ENCRYPTED;\n    }\n    const size_t offset = mobi_get_kf8offset(m);\n    if (m->rh == NULL || m->rh->text_record_count == 0) {\n        debug_print(\"%s\", \"Text records not found in MOBI header\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    const size_t text_rec_index = 1 + offset;\n    size_t text_rec_count = m->rh->text_record_count;\n    const uint16_t compression_type = m->rh->compression_type;\n    /* check for extra data at the end of text files */\n    uint16_t extra_flags = 0;\n    if (m->mh && m->mh->extra_flags) {\n        extra_flags = *m->mh->extra_flags;\n    }\n    /* get first text record */\n    const MOBIPdbRecord *curr = mobi_get_record_by_seqnumber(m, text_rec_index);\n    MOBIHuffCdic *huffcdic = NULL;\n    if (compression_type == MOBI_COMPRESSION_HUFFCDIC) {\n        /* load huff/cdic tables */\n        huffcdic = mobi_init_huffcdic();\n        if (huffcdic == NULL) {\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        MOBI_RET ret = mobi_parse_huffdic(m, huffcdic);\n        if (ret != MOBI_SUCCESS) {\n            mobi_free_huffcdic(huffcdic);\n            return ret;\n        }\n    }\n    /* get following CDIC records */\n    size_t text_length = 0;\n    while (text_rec_count-- && curr) {\n        size_t extra_size = 0;\n        if (extra_flags) {\n            extra_size = mobi_get_record_extrasize(curr, extra_flags);\n            if (extra_size == MOBI_NOTSET) {\n                mobi_free_huffcdic(huffcdic);\n                return MOBI_DATA_CORRUPT;\n            }\n        }\n        size_t decompressed_size = mobi_get_textrecord_maxsize(m);\n        unsigned char *decompressed = malloc(decompressed_size);\n        if (decompressed == NULL) {\n            mobi_free_huffcdic(huffcdic);\n            debug_print(\"Memory allocation failed%s\", \"\\n\");\n            return MOBI_MALLOC_FAILED;\n        }\n        MOBI_RET ret = MOBI_SUCCESS;\n#ifdef USE_ENCRYPTION\n        if (mobi_is_encrypted(m) && mobi_has_drmkey(m)) {\n            if (compression_type != MOBI_COMPRESSION_HUFFCDIC) {\n                /* decrypt also multibyte extra data */\n                extra_size = mobi_get_record_extrasize(curr, extra_flags & 0xfffe);\n            }\n            if (extra_size == MOBI_NOTSET || extra_size > curr->size) {\n                mobi_free_huffcdic(huffcdic);\n                free(decompressed);\n                return MOBI_DATA_CORRUPT;\n            }\n            const size_t decrypt_size = curr->size - extra_size;\n            if (decrypt_size > decompressed_size) {\n                if (decrypt_size <= curr->size) {\n                    unsigned char *tmp = realloc(decompressed, decrypt_size);\n                    if (tmp == NULL) {\n                        debug_print(\"%s\\n\", \"Memory allocation failed\");\n                        mobi_free_huffcdic(huffcdic);\n                        free(decompressed);\n                        return MOBI_MALLOC_FAILED;\n                    }\n                    decompressed = tmp;\n                } else {\n                    debug_print(\"Record too large: %zu\\n\", decrypt_size);\n                    mobi_free_huffcdic(huffcdic);\n                    free(decompressed);\n                    return MOBI_DATA_CORRUPT;\n                }\n            }\n            if (decrypt_size) {\n                ret = mobi_buffer_decrypt(decompressed, curr->data, decrypt_size, m);\n                if (ret != MOBI_SUCCESS) {\n                    mobi_free_huffcdic(huffcdic);\n                    free(decompressed);\n                    return ret;\n                }\n                memcpy(curr->data, decompressed, decrypt_size);\n            }\n            if (compression_type != MOBI_COMPRESSION_HUFFCDIC && (extra_flags & 1)) {\n                // update multibyte data size after decryption\n                extra_size = mobi_get_record_extrasize(curr, extra_flags);\n                if (extra_size == MOBI_NOTSET) {\n                    free(decompressed);\n                    return MOBI_DATA_CORRUPT;\n                }\n            }\n        }\n#endif\n        if (extra_size > curr->size) {\n            debug_print(\"Wrong record size: -%zu\\n\", extra_size - curr->size);\n            mobi_free_huffcdic(huffcdic);\n            free(decompressed);\n            return MOBI_DATA_CORRUPT;\n        }\n        if (extra_size == curr->size) {\n            debug_print(\"Skipping empty record%s\", \"\\n\");\n            free(decompressed);\n            curr = curr->next;\n            continue;\n        }\n        const size_t record_size = curr->size - extra_size;\n        switch (compression_type) {\n            case MOBI_COMPRESSION_NONE:\n                /* no compression */\n                if (record_size > decompressed_size) {\n                    debug_print(\"Record too large: %zu\\n\", record_size);\n                    free(decompressed);\n                    return MOBI_DATA_CORRUPT;\n                }\n                memcpy(decompressed, curr->data, record_size);\n                decompressed_size = record_size;\n                if (mobi_exists_mobiheader(m) && mobi_get_fileversion(m) <= 3) {\n                    /* workaround for some old files with null characters inside record */\n                    mobi_remove_zeros(decompressed, &decompressed_size);\n                }\n                break;\n            case MOBI_COMPRESSION_PALMDOC:\n                /* palmdoc lz77 compression */\n                ret = mobi_decompress_lz77(decompressed, curr->data, &decompressed_size, record_size);\n                if (ret != MOBI_SUCCESS) {\n                    free(decompressed);\n                    return ret;\n                }\n                break;\n            case MOBI_COMPRESSION_HUFFCDIC:\n                /* mobi huffman compression */\n                ret = mobi_decompress_huffman(decompressed, curr->data, &decompressed_size, record_size, huffcdic);\n                if (ret != MOBI_SUCCESS) {\n                    free(decompressed);\n                    mobi_free_huffcdic(huffcdic);\n                    return ret;\n                }\n                break;\n            default:\n                debug_print(\"%s\", \"Unknown compression type\\n\");\n                mobi_free_huffcdic(huffcdic);\n                free(decompressed);\n                return MOBI_DATA_CORRUPT;\n        }\n        curr = curr->next;\n        if (dump) {\n            fwrite(decompressed, 1, decompressed_size, file);\n        } else {\n            if (text_length + decompressed_size > *len) {\n                debug_print(\"%s\", \"Text buffer too small\\n\");\n                /* free huff/cdic tables */\n                mobi_free_huffcdic(huffcdic);\n                free(decompressed);\n                return MOBI_PARAM_ERR;\n            }\n            memcpy(text + text_length, decompressed, decompressed_size);\n            text_length += decompressed_size;\n            text[text_length] = '\\0';\n        }\n        free(decompressed);\n    }\n    /* free huff/cdic tables */\n    mobi_free_huffcdic(huffcdic);\n    if (len) {\n        *len = text_length;\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Decompress text to a text buffer.\n \n @param[in] m MOBIData structure loaded with MOBI data\n @param[in,out] text Memory area to be filled with decompressed output\n @param[in,out] len Length of the memory allocated for the text string, on return will be set to decompressed text length\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_get_rawml(const MOBIData *m, char *text, size_t *len) {\n    if (text == NULL || len == NULL) {\n        debug_print(\"%s\", \"Parameter error: text or len is NULL\\n\");\n        return MOBI_PARAM_ERR;\n    }\n    if (m->rh->text_length > *len) {\n        debug_print(\"%s\", \"Text buffer smaller then text size declared in record0 header\\n\");\n        return MOBI_PARAM_ERR;\n    }\n    text[0] = '\\0';\n    return mobi_decompress_content(m, text, NULL, len);\n}\n\n/**\n @brief Decompress text record to an open file descriptor.\n \n Internal function for mobi_get_rawml and mobi_dump_rawml.\n Decompressed output is stored either in a file or in a text string\n \n @param[in] m MOBIData structure loaded with MOBI data\n @param[in,out] file File descriptor\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_dump_rawml(const MOBIData *m, FILE *file) {\n    if (file == NULL) {\n        debug_print(\"%s\", \"File descriptor is NULL\\n\");\n        return MOBI_FILE_NOT_FOUND;\n    }\n    return mobi_decompress_content(m, NULL, file, NULL);\n}\n\n/**\n @brief Check if MOBI header is loaded / present in the loaded file\n \n @param[in] m MOBIData structure loaded with MOBI data\n @return true on success, false otherwise\n */\nbool mobi_exists_mobiheader(const MOBIData *m) {\n    if (m == NULL || m->mh == NULL) {\n        return false;\n    }\n    return true;\n}\n\n/**\n @brief Check if skeleton INDX is present in the loaded file\n \n @param[in] m MOBIData structure loaded with MOBI data\n @return true on success, false otherwise\n */\nbool mobi_exists_skel_indx(const MOBIData *m) {\n    if (!mobi_exists_mobiheader(m)) {\n        return false;\n    }\n    if (m->mh->skeleton_index == NULL || *m->mh->skeleton_index == MOBI_NOTSET) {\n        debug_print(\"%s\", \"SKEL INDX record not found\\n\");\n        return false;\n    }\n    return true;\n}\n\n/**\n @brief Check if FDST record is present in the loaded file\n \n @param[in] m MOBIData structure loaded with MOBI data\n @return true on success, false otherwise\n */\nbool mobi_exists_fdst(const MOBIData *m) {\n    if (!mobi_exists_mobiheader(m) || mobi_get_fileversion(m) <= 3) {\n        return false;\n    }\n    if (mobi_get_fileversion(m) >= 8) {\n        if (m->mh->fdst_index && *m->mh->fdst_index != MOBI_NOTSET) {\n            return true;\n        }\n    } else {\n        if ((m->mh->fdst_section_count && *m->mh->fdst_section_count > 1)\n            && (m->mh->last_text_index && *m->mh->last_text_index != (uint16_t) -1)) {\n            return true;\n        }\n    }\n    debug_print(\"%s\", \"FDST record not found\\n\");\n    return false;\n}\n\n/**\n @brief Get sequential number of FDST record\n \n @param[in] m MOBIData structure loaded with MOBI data\n @return Record number on success, MOBI_NOTSET otherwise\n */\nsize_t mobi_get_fdst_record_number(const MOBIData *m) {\n    if (!mobi_exists_mobiheader(m)) {\n        return MOBI_NOTSET;\n    }\n    const size_t offset = mobi_get_kf8offset(m);\n    if (m->mh->fdst_index && *m->mh->fdst_index != MOBI_NOTSET) {\n        if (m->mh->fdst_section_count && *m->mh->fdst_section_count > 1) {\n            return *m->mh->fdst_index + offset;\n        }\n    }\n    if (m->mh->fdst_section_count && *m->mh->fdst_section_count > 1) {\n        /* FIXME: if KF7, is it safe to asume last_text_index has fdst index */\n        if (m->mh->last_text_index) {\n            return *m->mh->last_text_index;\n        }\n    }\n    return MOBI_NOTSET;\n}\n\n/**\n @brief Check if fragments INDX is present in the loaded file\n \n @param[in] m MOBIData structure loaded with MOBI data\n @return true on success, false otherwise\n */\nbool mobi_exists_frag_indx(const MOBIData *m) {\n    if (!mobi_exists_mobiheader(m)) {\n        return false;\n    }\n    if (m->mh->fragment_index == NULL || *m->mh->fragment_index == MOBI_NOTSET) {\n        return false;\n    }\n    debug_print(\"%s\", \"Fragments INDX found\\n\");\n    return true;\n}\n\n/**\n @brief Check if guide INDX is present in the loaded file\n \n @param[in] m MOBIData structure loaded with MOBI data\n @return true on success, false otherwise\n */\nbool mobi_exists_guide_indx(const MOBIData *m) {\n    if (!mobi_exists_mobiheader(m)) {\n        return false;\n    }\n    if (m->mh->guide_index == NULL || *m->mh->guide_index == MOBI_NOTSET) {\n        return false;\n    }\n    debug_print(\"%s\", \"Guide INDX found\\n\");\n    return true;\n}\n\n/**\n @brief Check if ncx INDX is present in the loaded file\n \n @param[in] m MOBIData structure loaded with MOBI data\n @return true on success, false otherwise\n */\nbool mobi_exists_ncx(const MOBIData *m) {\n    if (!mobi_exists_mobiheader(m)) {\n        return false;\n    }\n    if (m->mh->ncx_index == NULL || *m->mh->ncx_index == MOBI_NOTSET) {\n        return false;\n    }\n    debug_print(\"%s\", \"NCX INDX found\\n\");\n    return true;\n}\n\n/**\n @brief Check if orth INDX is present in the loaded file\n \n @param[in] m MOBIData structure loaded with MOBI data\n @return true on success, false otherwise\n */\nbool mobi_exists_orth(const MOBIData *m) {\n    if (!mobi_exists_mobiheader(m)) {\n        return false;\n    }\n    if (m->mh->orth_index == NULL || *m->mh->orth_index == MOBI_NOTSET) {\n        return false;\n    }\n    debug_print(\"%s\", \"ORTH INDX found\\n\");\n    return true;\n}\n\n/**\n @brief Check if infl INDX is present in the loaded file\n \n @param[in] m MOBIData structure loaded with MOBI data\n @return true on success, false otherwise\n */\nbool mobi_exists_infl(const MOBIData *m) {\n    if (!mobi_exists_mobiheader(m)) {\n        return false;\n    }\n    if (m->mh->infl_index == NULL || *m->mh->infl_index == MOBI_NOTSET) {\n        return false;\n    }\n    debug_print(\"%s\", \"INFL INDX found\\n\");\n    return true;\n}\n\n/**\n @brief Get file type of given part with number [part_number]\n \n @param[in] rawml MOBIRawml parsed records structure\n @param[in] part_number Sequential number of the part within rawml structure\n @return MOBIFiletype file type\n */\nMOBIFiletype mobi_determine_flowpart_type(const MOBIRawml *rawml, const size_t part_number) {\n    if (part_number == 0 || mobi_is_rawml_kf8(rawml) == false) {\n        return T_HTML;\n    }\n    if (part_number > 9999) {\n        debug_print(\"Corrupt part number: %zu\\n\", part_number);\n        return T_UNKNOWN;\n    }\n    char target[30];\n    snprintf(target, 30, \"\\\"kindle:flow:%04zu?mime=\", part_number);\n    unsigned char *data_start = rawml->flow->data;\n    unsigned char *data_end = data_start + rawml->flow->size - 1;\n    MOBIResult result;\n    MOBI_RET ret = mobi_find_attrvalue(&result, data_start, data_end, T_HTML, target);\n    if (ret == MOBI_SUCCESS && result.start) {\n        if (strstr(result.value, \"text/css\")) {\n            return T_CSS;\n        }\n        if (strstr(result.value, \"image/svg+xml\")) {\n            return T_SVG;\n        }\n    }\n    return T_UNKNOWN;\n}\n\n/**\n @brief Get font type of given font resource\n \n @param[in] font_data Font resource data\n @param[in] font_size Font resource size\n @return MOBIFiletype file type\n */\nMOBIFiletype mobi_determine_font_type(const unsigned char *font_data, const size_t font_size) {\n    const char otf_magic[] = \"OTTO\";\n    const char ttf_magic[] = \"\\0\\1\\0\\0\";\n    const char ttf2_magic[] = \"true\";\n\n    if (font_size >= 4) {\n        if (memcmp(font_data, otf_magic, 4) == 0) {\n            return T_OTF;\n        }\n        if (memcmp(font_data, ttf_magic, 4) == 0) {\n            return T_TTF;\n        }\n        if (memcmp(font_data, ttf2_magic, 4) == 0) {\n            return T_TTF;\n        }\n    }\n    debug_print(\"Unknown font resource type%s\", \"\\n\");\n    return T_UNKNOWN;\n}\n\n/**\n @brief Replace part data with decoded audio data\n \n @param[in,out] part MOBIPart structure containing font resource, decoded part type will be set in the structure\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_add_audio_resource(MOBIPart *part) {\n    unsigned char *data = NULL;\n    size_t size = 0;\n    MOBI_RET ret = mobi_decode_audio_resource(&data, &size, part);\n    if (ret != MOBI_SUCCESS) {\n        return ret;\n    }\n    part->data = data;\n    part->size = size;\n    /* FIXME: the only possible audio type is mp3 */\n    part->type = T_MP3;\n\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Decode audio resource\n \n @param[in,out] decoded_resource Pointer to data offset in mobipocket record.\n @param[in,out] decoded_size Decoded resource data size\n @param[in,out] part MOBIPart structure containing resource, decoded part type will be set in the structure\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_decode_audio_resource(unsigned char **decoded_resource, size_t *decoded_size, MOBIPart *part) {\n    if (part->size < MEDIA_HEADER_LEN) {\n        debug_print(\"Audio resource record too short (%zu)\\n\", part->size);\n        return MOBI_DATA_CORRUPT;\n    }\n    MOBIBuffer *buf = mobi_buffer_init_null(part->data, part->size);\n    if (buf == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    char magic[5];\n    mobi_buffer_getstring(magic, buf, 4);\n    if (strncmp(magic, AUDI_MAGIC, 4) != 0) {\n        debug_print(\"Wrong magic for audio resource: %s\\n\", magic);\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    uint32_t offset = mobi_buffer_get32(buf);\n    mobi_buffer_setpos(buf, offset);\n    *decoded_size = buf->maxlen - buf->offset;\n    *decoded_resource = mobi_buffer_getpointer(buf, *decoded_size);\n    mobi_buffer_free_null(buf);\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Replace part data with decoded video data\n \n @param[in,out] part MOBIPart structure containing font resource, decoded part type will be set in the structure\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_add_video_resource(MOBIPart *part) {\n    unsigned char *data = NULL;\n    size_t size = 0;\n    MOBI_RET ret = mobi_decode_video_resource(&data, &size, part);\n    if (ret != MOBI_SUCCESS) {\n        return ret;\n    }\n    part->data = data;\n    part->size = size;\n    part->type = T_MPG; /* FIXME: other types? */\n\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Decode video resource\n \n @param[in,out] decoded_resource Pointer to data offset in mobipocket record.\n @param[in,out] decoded_size Decoded resource data size\n @param[in,out] part MOBIPart structure containing resource, decoded part type will be set in the structure\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_decode_video_resource(unsigned char **decoded_resource, size_t *decoded_size, MOBIPart *part) {\n    if (part->size < MEDIA_HEADER_LEN) {\n        debug_print(\"Video resource record too short (%zu)\\n\", part->size);\n        return MOBI_DATA_CORRUPT;\n    }\n    MOBIBuffer *buf = mobi_buffer_init_null(part->data, part->size);\n    if (buf == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    char magic[5];\n    mobi_buffer_getstring(magic, buf, 4);\n    if (strncmp(magic, VIDE_MAGIC, 4) != 0) {\n        debug_print(\"Wrong magic for video resource: %s\\n\", magic);\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    uint32_t offset = mobi_buffer_get32(buf);\n    /* offset is always(?) 12, next four bytes are unknown */\n    mobi_buffer_setpos(buf, offset);\n    *decoded_size = buf->maxlen - buf->offset;\n    *decoded_resource = mobi_buffer_getpointer(buf, *decoded_size);\n    mobi_buffer_free_null(buf);\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Get embedded source archive\n \n Some mobi creator software store original conversion source as a zip archive.\n The function may return MOBI_SUCCESS even if the data was not found,\n so it is neccessary to check whether returned data pointer is not NULL.\n \n @param[in,out] data Pointer to data offset in pdb record.\n @param[in,out] size Pointer to data size\n @param[in] m MOBIData structure\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_get_embedded_source(unsigned char **data, size_t *size, const MOBIData *m) {\n    *data = NULL;\n    *size = 0;\n    if (m == NULL) {\n        return MOBI_INIT_FAILED;\n    }\n    MOBIMobiHeader *header = m->mh;\n    if (mobi_is_hybrid(m) && m->use_kf8 && m->next) {\n        /* SRCS index is in KF7 header */\n        header = m->next->mh;\n    }\n    if (header == NULL || header->srcs_index == NULL || header->srcs_count == NULL ||\n        *header->srcs_index == MOBI_NOTSET || *header->srcs_count == 0) {\n        return MOBI_SUCCESS;\n    }\n    uint32_t index = *header->srcs_index;\n    \n    const MOBIPdbRecord *srcs_record = mobi_get_record_by_seqnumber(m, index);\n    if (srcs_record == NULL) {\n        return MOBI_SUCCESS;\n    }\n    const size_t archive_offset = 16;\n    \n    if (srcs_record->size <= archive_offset) {\n        debug_print(\"Wrong size of SRCS resource: %zu\\n\", srcs_record->size);\n        return MOBI_DATA_CORRUPT;\n    }\n\n    if (memcmp(srcs_record->data, SRCS_MAGIC, 4) != 0) {\n        debug_print(\"Wrong magic for SRCS resource: %c%c%c%c\\n\",\n                    srcs_record->data[0], srcs_record->data[1], srcs_record->data[2], srcs_record->data[3]);\n        return MOBI_DATA_CORRUPT;\n    }\n    \n    *data = srcs_record->data + archive_offset;\n    *size = srcs_record->size - archive_offset;\n\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Get embedded conversion log\n \n Some mobi creator software store original conversion log together with source archive.\n The function may return MOBI_SUCCESS even if the data was not found,\n so it is neccessary to check whether returned data pointer is not NULL.\n \n @param[in,out] data Pointer to data offset in pdb record.\n @param[in,out] size Pointer to data size\n @param[in] m MOBIData structure\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_get_embedded_log(unsigned char **data, size_t *size, const MOBIData *m) {\n    *data = NULL;\n    *size = 0;\n    if (m == NULL) {\n        return MOBI_INIT_FAILED;\n    }\n    MOBIMobiHeader *header = m->mh;\n    if (mobi_is_hybrid(m) && m->use_kf8 && m->next) {\n        /* SRCS index is in KF7 header */\n        header = m->next->mh;\n    }\n    if (header == NULL || header->srcs_index == NULL || header->srcs_count == NULL ||\n        *header->srcs_index == MOBI_NOTSET || *header->srcs_count < 2) {\n        return MOBI_SUCCESS;\n    }\n    uint32_t index = *header->srcs_index + 1;\n    \n    const MOBIPdbRecord *srcs_record = mobi_get_record_by_seqnumber(m, index);\n    if (srcs_record == NULL) {\n        return MOBI_SUCCESS;\n    }\n    const size_t log_offset = 12;\n    if (srcs_record->size <= log_offset) {\n        debug_print(\"Wrong size of CMET resource: %zu\\n\", srcs_record->size);\n        return MOBI_DATA_CORRUPT;\n    }\n    MOBIBuffer *buf = mobi_buffer_init_null(srcs_record->data, srcs_record->size);\n    if (buf == NULL) {\n        return MOBI_MALLOC_FAILED;\n    }\n    if (mobi_buffer_match_magic(buf, CMET_MAGIC) == false) {\n        debug_print(\"%s\\n\", \"Wrong magic for CMET resource\");\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    mobi_buffer_setpos(buf, 8);\n    uint32_t log_length = mobi_buffer_get32(buf);\n    unsigned char *log_data = mobi_buffer_getpointer(buf, log_length);\n    if (buf->error != MOBI_SUCCESS) {\n        debug_print(\"CMET resource too short: %zu (log size: %u)\\n\", srcs_record->size, log_length);\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    \n    *data = log_data;\n    *size = log_length;\n    \n    mobi_buffer_free_null(buf);\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Replace part data with decoded font data\n \n @param[in,out] part MOBIPart structure containing font resource, decoded part type will be set in the structure\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_add_font_resource(MOBIPart *part) {\n    unsigned char *data = NULL;\n    size_t size = 0;\n    MOBI_RET ret = mobi_decode_font_resource(&data, &size, part);\n    if (ret != MOBI_SUCCESS) {\n        return ret;\n    }\n    part->data = data;\n    part->size = size;\n    part->type = mobi_determine_font_type(data, size);\n    /* FIXME: mark unknown font types as ttf (shouldn't happen).\n       This will allow proper font resource deallocation. */\n    if (part->type == T_UNKNOWN) { part->type = T_TTF; }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Deobfuscator and decompressor for font resources\n \n @param[in,out] decoded_font Pointer to memory to write to. Will be allocated. Must be freed by caller\n @param[in,out] decoded_size Decoded font data size\n @param[in,out] part MOBIPart structure containing font resource, decoded part type will be set in the structure\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_decode_font_resource(unsigned char **decoded_font, size_t *decoded_size, MOBIPart *part) {\n    if (part->size < FONT_HEADER_LEN) {\n        debug_print(\"Font resource record too short (%zu)\\n\", part->size);\n        return MOBI_DATA_CORRUPT;\n    }\n    MOBIBuffer *buf = mobi_buffer_init(part->size);\n    if (buf == NULL) {\n        debug_print(\"Memory allocation failed%s\", \"\\n\");\n        return MOBI_MALLOC_FAILED;\n    }\n    memcpy(buf->data, part->data, part->size);\n    struct header {\n        char magic[5];\n        uint32_t decoded_size;\n        uint32_t flags;\n        uint32_t data_offset;\n        uint32_t xor_key_len;\n        uint32_t xor_data_off;\n    };\n    struct header h;\n    mobi_buffer_getstring(h.magic, buf, 4);\n    if (strncmp(h.magic, FONT_MAGIC, 4) != 0) {\n        debug_print(\"Wrong magic for font resource: %s\\n\", h.magic);\n        mobi_buffer_free(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    h.decoded_size = mobi_buffer_get32(buf);\n    if (h.decoded_size == 0 || h.decoded_size > FONT_SIZEMAX) {\n        debug_print(\"Invalid declared font resource size: %u\\n\", h.decoded_size);\n        mobi_buffer_free(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    h.flags = mobi_buffer_get32(buf);\n    h.data_offset = mobi_buffer_get32(buf);\n    h.xor_key_len = mobi_buffer_get32(buf);\n    h.xor_data_off = mobi_buffer_get32(buf);\n    const uint32_t zlib_flag = 1; /* bit 0 */\n    const uint32_t xor_flag = 2; /* bit 1 */\n    if (h.flags & xor_flag && h.xor_key_len > 0) {\n        /* deobfuscate */\n        if (h.data_offset > buf->maxlen || h.xor_data_off + h.xor_key_len > buf->maxlen) {\n            debug_print(\"%s\\n\", \"Invalid obfuscated font data offsets\");\n            mobi_buffer_free(buf);\n            return MOBI_DATA_CORRUPT;\n        }\n        mobi_buffer_setpos(buf, h.data_offset);\n        const unsigned char *xor_key = buf->data + h.xor_data_off;\n        size_t i = 0;\n        const size_t xor_limit = h.xor_key_len * MOBI_FONT_OBFUSCATED_BUFFER_COUNT;\n        while (buf->offset < buf->maxlen && i < xor_limit) {\n            buf->data[buf->offset++] ^= xor_key[i % h.xor_key_len];\n            i++;\n        }\n    }\n    mobi_buffer_setpos(buf, h.data_offset);\n    *decoded_size = h.decoded_size;\n    *decoded_font = malloc(h.decoded_size);\n    if (*decoded_font == NULL) {\n        mobi_buffer_free(buf);\n        debug_print(\"%s\", \"Memory allocation failed\\n\");\n        return MOBI_MALLOC_FAILED;\n    }\n    const unsigned char *encoded_font = buf->data + buf->offset;\n    const unsigned long encoded_size = buf->maxlen - buf->offset;\n    if (h.flags & zlib_flag) {\n        /* unpack */\n        int ret = m_uncompress(*decoded_font, (unsigned long *) decoded_size, encoded_font, encoded_size);\n        if (ret != M_OK) {\n            mobi_buffer_free(buf);\n            free(*decoded_font);\n            debug_print(\"%s\", \"Font resource decompression failed\\n\");\n            return MOBI_DATA_CORRUPT;\n        }\n        if (*decoded_size != h.decoded_size) {\n            mobi_buffer_free(buf);\n            free(*decoded_font);\n            debug_print(\"Decompressed font size (%zu) differs from declared (%i)\\n\", *decoded_size, h.decoded_size);\n            return MOBI_DATA_CORRUPT;\n        }\n    } else {\n        if (*decoded_size < encoded_size) {\n            mobi_buffer_free(buf);\n            free(*decoded_font);\n            debug_print(\"Font size in record (%lu) larger then declared (%zu)\\n\", encoded_size, *decoded_size);\n            return MOBI_DATA_CORRUPT;\n        }\n        memcpy(*decoded_font, encoded_font, encoded_size);\n    }\n\n    mobi_buffer_free(buf);\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Get resource type (image, font) by checking its magic header\n \n @param[in] record MOBIPdbRecord structure containing unknown record type\n @return MOBIFiletype file type, T_UNKNOWN if not determined, T_BREAK if end of records mark found\n */\nMOBIFiletype mobi_determine_resource_type(const MOBIPdbRecord *record) {\n    /* Kindle supports GIF, BMP, JPG, PNG, SVG images. */\n    /* GIF: 47 49 46 38 37 61 (GIF87a), 47 49 46 38 39 61 (GIF89a) */\n    /* BMP: 42 4D (BM) + 4 byte file length le */\n    /* JPG: FF D8 FF (header) + FF D9 (trailer) */\n    /* PNG: 89 50 4E 47 0D 0A 1A 0A */\n    /* SVG is XML-based format, so stored in flow parts */\n    /* FONT: must be decoded */\n    if (record->size < 4) {\n        return T_UNKNOWN;\n    }\n    const unsigned char jpg_magic[] = \"\\xff\\xd8\\xff\";\n    const unsigned char gif_magic[] = \"\\x47\\x49\\x46\\x38\";\n    const unsigned char png_magic[] = \"\\x89\\x50\\x4e\\x47\\x0d\\x0a\\x1a\\x0a\";\n    const unsigned char bmp_magic[] = \"\\x42\\x4d\";\n    const unsigned char font_magic[] = FONT_MAGIC;\n    const unsigned char audio_magic[] = AUDI_MAGIC;\n    const unsigned char video_magic[] = VIDE_MAGIC;\n    const unsigned char boundary_magic[] = BOUNDARY_MAGIC;\n    const unsigned char eof_magic[] = EOF_MAGIC;\n    if (memcmp(record->data, jpg_magic, 3) == 0) {\n        return T_JPG;\n    }\n    if (memcmp(record->data, gif_magic, 4) == 0) {\n        return T_GIF;\n    }\n    if (record->size >= 8 && memcmp(record->data, png_magic, 8) == 0) {\n        return T_PNG;\n    }\n    if (memcmp(record->data, font_magic, 4) == 0) {\n        return T_FONT;\n    }\n    if (record->size >= 8 && memcmp(record->data, boundary_magic, 8) == 0) {\n        return T_BREAK;\n    }\n    if (memcmp(record->data, eof_magic, 4) == 0) {\n        return T_BREAK;\n    }\n    if (record->size >= 6 && memcmp(record->data, bmp_magic, 2) == 0) {\n        const size_t bmp_size = mobi_get32le(&record->data[2]);\n        if (record->size == bmp_size) {\n            return T_BMP;\n        }\n    } else if (memcmp(record->data, audio_magic, 4) == 0) {\n        return T_AUDIO;\n    } else if (memcmp(record->data, video_magic, 4) == 0) {\n        return T_VIDEO;\n    }\n    return T_UNKNOWN;\n}\n\n/**\n @brief Check if loaded MOBI data is KF7/KF8 hybrid file\n \n @param[in] m MOBIData structure with loaded Record(s) 0 headers\n @return true or false\n */\nbool mobi_is_hybrid(const MOBIData *m) {\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return false;\n    }\n    if (m->kf8_boundary_offset != MOBI_NOTSET) {\n        return true;\n    }\n    return false;\n}\n\n/**\n @brief Check if loaded document is MOBI/BOOK Mobipocket format\n \n @param[in] m MOBIData structure with loaded Record(s) 0 headers\n @return true or false\n */\nbool mobi_is_mobipocket(const MOBIData *m) {\n    if (m == NULL || m->ph == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return false;\n    }\n    if (strcmp(m->ph->type, \"BOOK\") == 0 &&\n        strcmp(m->ph->creator, \"MOBI\") == 0) {\n        return true;\n    }\n    return false;\n}\n\n/**\n @brief Check if loaded document is TEXt/REAd format\n \n @param[in] m MOBIData structure with loaded Record(s) 0 headers\n @return true or false\n */\nbool mobi_is_textread(const MOBIData *m) {\n    if (m == NULL || m->ph == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return false;\n    }\n    if (strcmp(m->ph->type, \"TEXt\") == 0 &&\n        strcmp(m->ph->creator, \"REAd\") == 0) {\n        return true;\n    }\n    return false;\n}\n\n/**\n @brief Check if loaded document is dictionary\n \n @param[in] m MOBIData structure with loaded mobi header\n @return true or false\n */\nbool mobi_is_dictionary(const MOBIData *m) {\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return false;\n    }\n    /* FIXME: works only for old non-KF8 formats */\n    if (mobi_get_fileversion(m) < 8 && mobi_exists_orth(m)) {\n        debug_print(\"%s\", \"Dictionary detected\\n\");\n        return true;\n    }\n    return false;\n}\n\n/**\n @brief Check if loaded document is encrypted\n \n @param[in] m MOBIData structure with loaded Record(s) 0 headers\n @return true or false\n */\nbool mobi_is_encrypted(const MOBIData *m) {\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return false;\n    }\n    if ((mobi_is_mobipocket(m) || mobi_is_textread(m)) && m->rh &&\n        (m->rh->encryption_type == MOBI_ENCRYPTION_V1 ||\n         m->rh->encryption_type == MOBI_ENCRYPTION_V2)) {\n        return true;\n    }\n    return false;\n}\n\n/**\n @brief Check if DRM key is set for the document\n \n @param[in] m MOBIData structure with loaded Record(s) 0 headers\n @return true or false\n */\nbool mobi_has_drmkey(const MOBIData *m) {\n#ifdef USE_ENCRYPTION\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return false;\n    }\n    MOBIDrm *drm = m->internals;\n    return drm != NULL && drm->key != NULL;\n#else\n    UNUSED(m);\n    return false;\n#endif\n}\n\n/**\n @brief Check if DRM cookies are set for the document\n \n @param[in] m MOBIData structure with loaded Record(s) 0 headers\n @return true or false\n */\nbool mobi_has_drmcookies(const MOBIData *m) {\n#ifdef USE_ENCRYPTION\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return false;\n    }\n    MOBIDrm *drm = m->internals;\n    return drm != NULL && drm->cookies_count > 0;\n#else\n    UNUSED(m);\n    return false;\n#endif\n}\n\n/**\n @brief Check if loaded document is Print Replica type\n\n @param[in] m MOBIData structure with loaded Record(s) 0 headers\n @return true or false\n */\nbool mobi_is_replica(const MOBIData *m) {\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return false;\n    }\n    if (m->rec && m->rh && m->rh->compression_type == MOBI_COMPRESSION_NONE) {\n        MOBIPdbRecord *rec = m->rec->next;\n        if (rec && rec->size >= sizeof(REPLICA_MAGIC)) {\n            return memcmp(rec->data, REPLICA_MAGIC, sizeof(REPLICA_MAGIC) - 1) == 0;\n        }\n    }\n    return false;\n}\n\n/**\n @brief Get mobi file version\n \n @param[in] m MOBIData structure with loaded Record(s) 0 headers\n @return MOBI document version, 1 if ancient version (no MOBI header) or MOBI_NOTSET if error\n */\nsize_t mobi_get_fileversion(const MOBIData *m) {\n    size_t version = 1;\n    if (m == NULL || m->ph == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return MOBI_NOTSET;\n    }\n    if (strcmp(m->ph->type, \"BOOK\") == 0 && strcmp(m->ph->creator, \"MOBI\") == 0) {\n        if (m->mh && m->mh->header_length) {\n            uint32_t header_length = *m->mh->header_length;\n            if (header_length < MOBI_HEADER_V2_SIZE) {\n                version = 2;\n            } else if (m->mh->version && *m->mh->version > 1) {\n                if ((*m->mh->version > 2 && header_length < MOBI_HEADER_V3_SIZE)\n                    || (*m->mh->version > 3 && header_length < MOBI_HEADER_V4_SIZE)\n                    ||(*m->mh->version > 5 && header_length < MOBI_HEADER_V5_SIZE)) {\n                    return MOBI_NOTSET;\n                }\n                version = *m->mh->version;\n            }\n        }\n    }\n    return version;\n}\n\n/**\n @brief Is file version 8 or above\n \n @param[in] m MOBIData structure with loaded Record(s) 0 headers\n @return True if file version is 8 or greater\n */\nbool mobi_is_kf8(const MOBIData *m) {\n    const size_t version = mobi_get_fileversion(m);\n    if (version != MOBI_NOTSET && version >= 8) {\n        return true;\n    }\n    return false;\n}\n\n/**\n @brief Is file version 8 or above\n \n @param[in] rawml MOBIRawml structure with parsed document\n @return True if file version is 8 or greater\n */\nbool mobi_is_rawml_kf8(const MOBIRawml *rawml) {\n    if (rawml && rawml->version != MOBI_NOTSET && rawml->version >= 8) {\n        return true;\n    }\n    return false;\n}\n\n/**\n @brief Get maximal size of uncompressed text record\n \n @param[in] m MOBIData structure with loaded Record(s) 0 headers\n @return Size of text or MOBI_NOTSET if error\n */\nuint16_t mobi_get_textrecord_maxsize(const MOBIData *m) {\n    uint16_t max_record_size = RECORD0_TEXT_SIZE_MAX;\n    if (m && m->rh) {\n        if (m->rh->text_record_size > RECORD0_TEXT_SIZE_MAX) {\n            max_record_size = m->rh->text_record_size;\n        }\n        if (mobi_exists_mobiheader(m) && mobi_get_fileversion(m) <= 3) {\n            /* workaround for some old files with records larger than declared record size */\n            size_t text_length = (size_t) max_record_size * m->rh->text_record_count;\n            if (text_length <= RAWTEXT_SIZEMAX && m->rh->text_length > text_length) {\n                max_record_size = RECORD0_TEXT_SIZE_MAX * 2;\n            }\n        }\n    }\n    return max_record_size;\n}\n\n/**\n @brief Get maximal size of all uncompressed text records\n \n @param[in] m MOBIData structure with loaded Record(s) 0 headers\n @return Size of text or MOBI_NOTSET if error\n */\nsize_t mobi_get_text_maxsize(const MOBIData *m) {\n    if (m && m->rh) {\n        /* FIXME: is it safe to use data from Record 0 header? */\n        if (m->rh->text_record_count > 0) {\n            uint16_t max_record_size = mobi_get_textrecord_maxsize(m);\n            size_t maxsize = (size_t) m->rh->text_record_count * (size_t) max_record_size;\n            if (mobi_exists_mobiheader(m) && mobi_get_fileversion(m) <= 3) {\n                /* workaround for some old files with records larger than declared record size */\n                if (m->rh->text_length > maxsize) {\n                    maxsize = m->rh->text_length;\n                }\n            }\n            if (maxsize > RAWTEXT_SIZEMAX) {\n                debug_print(\"Raw text too large (%zu)\\n\", maxsize);\n                return MOBI_NOTSET;\n            }\n            return maxsize;\n        }\n    }\n    return MOBI_NOTSET;\n}\n\n/**\n @brief Get sequential number of first resource record (image/font etc)\n \n @param[in] m MOBIData structure with loaded Record(s) 0 headers\n @return Record number or MOBI_NOTSET if not set\n */\nsize_t mobi_get_first_resource_record(const MOBIData *m) {\n    /* is it hybrid file? */\n    if (mobi_is_hybrid(m) && m->use_kf8) {\n        /* get first image index from KF7 mobi header */\n        if (m->next->mh->image_index) {\n            return *m->next->mh->image_index;\n        }\n    }\n    /* try to get it from currently set mobi header */\n    if (m->mh && m->mh->image_index) {\n        return *m->mh->image_index;\n    }\n    return MOBI_NOTSET;\n}\n\n\n/**\n @brief Calculate exponentiation for unsigned base and exponent\n \n @param[in] base Base\n @param[in] exp Exponent\n @return Result of base raised by the exponent exp\n */\nsize_t mobi_pow(unsigned base, unsigned exp) {\n    size_t result = 1;\n    while(exp) {\n        if (exp & 1) {\n            result *= base;\n        }\n        exp >>= 1;\n        base *= base;\n    }\n    return result;\n}\n\n/**\n @brief Decode positive number from base 32 to base 10.\n \n Base 32 characters must be upper case.\n Maximal supported value is VVVVVV.\n \n @param[in,out] decoded Base 10 output number\n @param[in] encoded Base 32 input number\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_base32_decode(uint32_t *decoded, const char *encoded) {\n    if (!encoded || !decoded) {\n        debug_print(\"Error, null parameter (decoded: %p, encoded: %p)\\n\", (void *) decoded, (void *) encoded);\n        return MOBI_PARAM_ERR;\n    }\n    /* strip leading zeroes */\n    while (*encoded == '0') {\n        encoded++;\n    }\n    size_t encoded_length = strlen(encoded);\n    /* Let's limit input to 6 chars. VVVVVV(32) is 0x3FFFFFFF */\n    if (encoded_length > 6) {\n        debug_print(\"Base 32 number too big: %s\\n\", encoded);\n        return MOBI_PARAM_ERR;\n    }\n    const unsigned char *c =  (unsigned char *) encoded;\n    unsigned len = (unsigned) encoded_length;\n    const unsigned base = 32;\n    *decoded = 0;\n    unsigned value;\n    while (*c) {\n        /* FIXME: not portable, should we care? */\n        if (*c >= 'A' && *c <= 'V') {\n            value = *c - 'A' + 10;\n        }\n        else if (*c >= '0' && *c <= '9') {\n            value = *c - '0';\n        }\n        else {\n            debug_print(\"Illegal character: \\\"%c\\\"\\n\", *c);\n            return MOBI_DATA_CORRUPT;\n        }\n        *decoded += value * mobi_pow(base, --len);\n        c++;\n    }\n    return MOBI_SUCCESS;\n}\n\n\n/**\n @brief Get offset of KF8 Boundary for KF7/KF8 hybrid file cached in MOBIData structure\n \n @param[in] m MOBIData structure\n @return KF8 Boundary sequential number or zero if not found\n */\nsize_t mobi_get_kf8offset(const MOBIData *m) {\n    /* check if we want to parse KF8 part of joint file */\n    if (m->use_kf8 && m->kf8_boundary_offset != MOBI_NOTSET) {\n        return m->kf8_boundary_offset + 1;\n    }\n    return 0;\n}\n\n/**\n @brief Get sequential number of KF8 Boundary record for KF7/KF8 hybrid file\n \n This function gets KF8 boundary offset from EXTH header\n \n @param[in] m MOBIData structure\n @return KF8 Boundary record sequential number or MOBI_NOTSET if not found\n */\nsize_t mobi_get_kf8boundary_seqnumber(const MOBIData *m) {\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return MOBI_NOTSET;\n    }\n    const MOBIExthHeader *exth_tag = mobi_get_exthrecord_by_tag(m, EXTH_KF8BOUNDARY);\n    if (exth_tag != NULL) {\n        uint32_t rec_number = mobi_decode_exthvalue(exth_tag->data, exth_tag->size);\n        rec_number--;\n        const MOBIPdbRecord *record = mobi_get_record_by_seqnumber(m, rec_number);\n        if (record && record->size >= sizeof(BOUNDARY_MAGIC) - 1) {\n            if (memcmp(record->data, BOUNDARY_MAGIC, sizeof(BOUNDARY_MAGIC) - 1) == 0) {\n                return rec_number;\n            }\n        }\n    }\n    return MOBI_NOTSET;\n}\n\n/**\n @brief Get size of serialized exth record including padding\n \n @param[in] m MOBIData structure\n @return Size of exth record, zero on failure\n */\nuint32_t mobi_get_exthsize(const MOBIData *m) {\n    if (m == NULL || m->eh == NULL) {\n        return 0;\n    }\n    size_t size = 0;\n    MOBIExthHeader *curr = m->eh;\n    while (curr) {\n        size += curr->size + 8;\n        curr = curr->next;\n    }\n    if (size > 0) {\n        /* add header size */\n        size += 12;\n        /* add padding */\n        size += size % 4;\n    }\n    if (size > UINT32_MAX) {\n        return 0;\n    }\n    return (uint32_t) size;\n}\n\n/**\n @brief Get size of serialized DRM data\n \n @param[in] m MOBIData structure\n @return Size of DRM data, zero on failure\n */\nuint32_t mobi_get_drmsize(const MOBIData *m) {\n    if (m == NULL || !mobi_is_encrypted(m)) {\n        return 0;\n    }\n    size_t size = 0;\n    \n    if (m->rh->encryption_type == MOBI_ENCRYPTION_V1) {\n        size = 51;\n    } else if (m->mh && m->mh->drm_size && *m->mh->drm_size > 0) {\n        size = *m->mh->drm_size;\n    }\n    \n    if (size > UINT32_MAX) {\n        return 0;\n    }\n    return (uint32_t) size;\n}\n\n/**\n @brief Get count of palm database records\n \n @param[in] m MOBIData structure\n @return Count of records, zero on failure\n */\nuint16_t mobi_get_records_count(const MOBIData *m) {\n    size_t count = 0;\n    if (m->rec) {\n        MOBIPdbRecord *curr = m->rec;\n        while (curr) {\n            count++;\n            curr = curr->next;\n        }\n    }\n    if (count > UINT16_MAX) {\n        return 0;\n    }\n    return (uint16_t) count;\n}\n\n/**\n @brief Remove null characters from char buffer\n \n @param[in,out] buffer Character buffer\n @param[in,out] len Size of buffer, will be updated with new length\n */\nvoid mobi_remove_zeros(unsigned char *buffer, size_t *len) {\n    size_t length = *len;\n    unsigned char *end = buffer + length;\n    unsigned char *buf = memchr(buffer, 0, length);\n    if (buf == NULL) {\n        return;\n    }\n    buf++;\n    size_t distance = 1;\n    while (buf < end) {\n        if (*buf) {\n            *(buf - distance) = *buf;\n        } else {\n            distance++;\n        }\n        buf++;\n    }\n    *len -= distance;\n}\n\n/**\n @brief Loader will parse KF7 part of hybrid file\n \n @param[in,out] m MOBIData structure\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_parse_kf7(MOBIData *m) {\n    if (m == NULL) {\n        return MOBI_INIT_FAILED;\n    }\n    m->use_kf8 = false;\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Loader will parse KF8 part of hybrid file\n \n This is the default option.\n \n @param[in,out] m MOBIData structure\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_parse_kf8(MOBIData *m) {\n    if (m == NULL) {\n        return MOBI_INIT_FAILED;\n    }\n    m->use_kf8 = true;\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Remove KF7 version from  hybrid file\n  \n @param[in,out] m MOBIData structure\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_remove_part_kf7(MOBIData *m) {\n    \n    // move resource records to KF8 part\n    \n    size_t start_kf7 = MOBI_NOTSET;\n    size_t start_kf8 = MOBI_NOTSET;\n    size_t count_kf7 = MOBI_NOTSET;\n    size_t count_kf8 = MOBI_NOTSET;\n    \n    // switch to KF7 data\n    if (m->use_kf8) {\n        mobi_swap_mobidata(m);\n        m->use_kf8 = false;\n    }\n    if (m->mh == NULL) {\n        debug_print(\"%s\\n\", \"Mobi header for version 7 missing\");\n        return MOBI_INIT_FAILED;\n    }\n    if (m->mh->image_index) {\n        start_kf7 = *m->mh->image_index;\n    }\n    MOBIExthHeader *exth = mobi_get_exthrecord_by_tag(m, EXTH_COUNTRESOURCES);\n    if (exth) {\n        count_kf7 = mobi_decode_exthvalue(exth->data, exth->size);\n    }\n\n    // switch back to KF8\n    mobi_swap_mobidata(m);\n    m->use_kf8 = true;\n\n    if (m->mh == NULL || m->kf8_boundary_offset == MOBI_NOTSET) {\n        debug_print(\"%s\\n\", \"Mobi header for version 8 missing\");\n        return MOBI_INIT_FAILED;\n    }\n    \n    if (m->mh->image_index) {\n        start_kf8 = *m->mh->image_index;\n    }\n    \n    MOBIExthHeader *exth_resources = mobi_get_exthrecord_by_tag(m, EXTH_COUNTRESOURCES);\n    if (exth_resources) {\n        count_kf8 = mobi_decode_exthvalue(exth_resources->data, exth_resources->size);\n    }\n    \n    if (start_kf7 == MOBI_NOTSET || start_kf8 == MOBI_NOTSET ||\n        count_kf7 == MOBI_NOTSET || count_kf8 == MOBI_NOTSET ||\n        m->kf8_boundary_offset < count_kf7) {\n        return MOBI_DATA_CORRUPT;\n    }\n            \n    // move resources to KF8 part\n    MOBIPdbRecord *extracted = mobi_extract_records_by_seqnumber(m, start_kf7, &count_kf7);\n\n    m->kf8_boundary_offset -= count_kf7;\n    start_kf8 += m->kf8_boundary_offset + 1;\n\n    MOBI_RET ret = mobi_insert_records_by_seqnumber(m, extracted, start_kf8);\n    if (ret != MOBI_SUCCESS) {\n        return ret;\n    }\n    \n    // delete records from beginning to boundary (inclusive)\n    size_t count = m->kf8_boundary_offset + 1;\n\n    ret = mobi_delete_records_by_seqnumber(m, 0, &count);\n    if (ret != MOBI_SUCCESS) {\n        return ret;\n    }\n    m->kf8_boundary_offset = MOBI_NOTSET;\n    mobi_free_next(m);\n    \n    // update EXTH tags\n    \n    // update EXTH Count of Resources tag\n    count_kf8 += count_kf7;\n    if (exth_resources && exth_resources->size == 4 && count_kf8 <= UINT32_MAX) {\n        uint32_t value = (uint32_t) count_kf8;\n        unsigned char *p = exth_resources->data;\n        *p++ = (uint8_t)((uint32_t)(value & 0xff000000U) >> 24);\n        *p++ = (uint8_t)((uint32_t)(value & 0xff0000U) >> 16);\n        *p++ = (uint8_t)((uint32_t)(value & 0xff00U) >> 8);\n        *p = (uint8_t)((uint32_t)(value & 0xffU));\n    }\n    \n    // check that EXTH Start Reading tag points to text, delete otherwise\n    MOBIExthHeader *exth_start = NULL;\n    while ((exth = mobi_next_exthrecord_by_tag(m, EXTH_STARTREADING, &exth_start))) {\n        uint32_t offset = mobi_decode_exthvalue(exth->data, exth->size);\n        if (offset > m->rh->text_record_count) {\n            mobi_delete_exthrecord(m, exth);\n        }\n    }\n    \n    // reset KF8 related EXTH flags\n    if (m->mh->exth_flags) {\n        *m->mh->exth_flags &= 0x7ff;\n        *m->mh->exth_flags |= 0x800;\n    }\n    \n    // adjust record offsets\n    if (m->mh->fdst_index && *m->mh->fdst_index + count_kf7 < UINT32_MAX) {\n        *m->mh->fdst_index += count_kf7;\n    }\n    if (m->mh->fcis_index && *m->mh->fcis_index + count_kf7 < UINT32_MAX) {\n        *m->mh->fcis_index += count_kf7;\n    }\n    if (m->mh->flis_index && *m->mh->flis_index + count_kf7 < UINT32_MAX) {\n        *m->mh->flis_index += count_kf7;\n    }\n    if (m->mh->datp_index && *m->mh->datp_index + count_kf7 < UINT32_MAX) {\n        *m->mh->datp_index += count_kf7;\n    }\n    if (m->mh->datp_rec_index && *m->mh->datp_rec_index + count_kf7 < UINT32_MAX) {\n        *m->mh->datp_rec_index += count_kf7;\n    }\n    \n    return MOBI_SUCCESS;\n}\n\n\n/**\n @brief Remove KF8 version from  hybrid file\n  \n @param[in,out] m MOBIData structure\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_remove_part_kf8(MOBIData *m) {\n        \n    if (m->use_kf8) {\n        mobi_swap_mobidata(m);\n        m->use_kf8 = false;\n    }\n    \n    if (m->mh == NULL) {\n        debug_print(\"%s\\n\", \"Mobi header missing\");\n        return MOBI_INIT_FAILED;\n    }\n\n    // delete records from boundary (inclusive) up to last eof (exclusive)\n    size_t start = m->kf8_boundary_offset;\n    size_t count = mobi_get_records_count(m);\n    if (start == MOBI_NOTSET || count <= start) {\n        debug_print(\"%s\\n\", \"Bad records range data\");\n        return MOBI_DATA_CORRUPT;\n    }\n    count -= start + 1;\n    MOBI_RET ret = mobi_delete_records_by_seqnumber(m, start, &count);\n    if (ret != MOBI_SUCCESS) {\n        return ret;\n    }\n    \n    // delete source and logs records\n    if (m->mh->srcs_index && m->mh->srcs_count) {\n        start = *m->mh->srcs_index;\n        count = *m->mh->srcs_count;\n        if (start != MOBI_NOTSET && count != MOBI_NOTSET) {\n            ret = mobi_delete_records_by_seqnumber(m, start, &count);\n            if (ret != MOBI_SUCCESS) {\n                return ret;\n            }\n            *m->mh->srcs_index = MOBI_NOTSET;\n            *m->mh->srcs_count = 0;\n        }\n    }\n    \n    // truncate obsolete FONT, RESC records\n    if (m->mh->image_index && (start = *m->mh->image_index) != MOBI_NOTSET) {\n        MOBIPdbRecord *curr = mobi_get_record_by_seqnumber(m, start);\n        while (curr != NULL) {\n            if (curr->data && curr->size > 4 &&\n                (memcmp(curr->data, FONT_MAGIC, 4) == 0 ||\n                 memcmp(curr->data, RESC_MAGIC, 4) == 0)) {\n                unsigned char *tmp = realloc(curr->data, 4);\n                if (tmp == NULL) {\n                    debug_print(\"%s\\n\", \"Memory allocation failed\");\n                    return MOBI_MALLOC_FAILED;\n                }\n                curr->data = tmp;\n                curr->size = 4;\n            }\n            curr = curr->next;\n        }\n    }\n    \n    mobi_free_next(m);\n    \n    // update EXTH tags\n    MOBIExthHeader *exth = mobi_get_exthrecord_by_tag(m, EXTH_KF8BOUNDARY);\n    if (exth != NULL && exth->size == sizeof(uint32_t)) {\n        const uint32_t value = MOBI_NOTSET;\n        memcpy(exth->data, &value, exth->size);\n    }\n    \n    ret = mobi_delete_exthrecord_by_tag(m, EXTH_KF8COVERURI);\n    if (ret != MOBI_SUCCESS) {\n        return ret;\n    }\n    \n    // reset KF8 related EXTH flags\n    if (m->mh->exth_flags){\n        *m->mh->exth_flags &= 0x7ff;\n    }\n    \n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Remove one version from  hybrid file\n \n Hybrid file contains two document versions: KF8 version for devices that support new format and a version for older devices.\n \n @param[in,out] m MOBIData structure\n @param[in] remove_kf8 Remove new KF8 part if true, old part if false\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_remove_hybrid_part(MOBIData *m, const bool remove_kf8) {\n    if (m == NULL) {\n        return MOBI_INIT_FAILED;\n    }\n    if (!mobi_is_hybrid(m)) {\n        debug_print(\"%s\\n\", \"Not a hybrid, skip removing part\");\n        return MOBI_SUCCESS;\n    }\n    if (remove_kf8) {\n        return mobi_remove_part_kf8(m);\n    }\n    return mobi_remove_part_kf7(m);\n}\n\n/**\n @brief Swap KF7 and KF8 MOBIData structures in a hybrid file\n \n MOBIData structures form a circular linked list in case of hybrid files.\n By default KF8 structure is first one in the list.\n This function puts KF7 structure on the first place, so that it starts to be used by default.\n \n @param[in,out] m MOBIData structure\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_swap_mobidata(MOBIData *m) {\n    MOBIData *tmp = malloc(sizeof(MOBIData));\n    if (tmp == NULL) {\n        debug_print(\"%s\", \"Memory allocation failed while swaping data\\n\");\n        return MOBI_MALLOC_FAILED;\n    }\n    tmp->rh = m->rh;\n    tmp->mh = m->mh;\n    tmp->eh = m->eh;\n    m->rh = m->next->rh;\n    m->mh = m->next->mh;\n    m->eh = m->next->eh;\n    m->next->rh = tmp->rh;\n    m->next->mh = tmp->mh;\n    m->next->eh = tmp->eh;\n    free(tmp);\n    tmp = NULL;\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Store PID for encryption in MOBIData stucture.\n PID will be calculated from device serial number.\n \n @param[in,out] m MOBIData structure with raw data and metadata\n @param[in] serial Device serial number\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_drm_setkey_serial(MOBIData *m, const char *serial) {\n#ifdef USE_ENCRYPTION\n    return mobi_drmkey_set_serial(m, serial);\n#else\n    UNUSED(m);\n    UNUSED(serial);\n    debug_print(\"Libmobi compiled without encryption support%s\", \"\\n\");\n    return MOBI_DRM_UNSUPPORTED;\n#endif\n}\n\n/**\n @brief Add DRM voucher\n \n DRM vouncher will be used to generate pid key which is used to encrypt main encryption key.\n Pid key is based on device serial number.\n Optionally it is possible to set validity of the key. The key will be valid only within the period.\n Optionally the pid key may be generated not only from serial number but also from contents\n of selected EXTH headers. In such case the headers should be added (@see mobi_add_exthrecord)\n before calling this function and array of header tags passed as function parameter.\n \n @param[in,out] m MOBIData structure with raw data and metadata\n @param[in] serial Device serial number\n @param[in] valid_from DRM validity start time, -1 if not set\n @param[in] valid_to DRM validity end time, -1 if not set\n @param[in] tamperkeys Array of EXTH tags to include in PID generation, NULL if none\n @param[in] tamperkeys_count Count of EXTH tags\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_drm_addvoucher(MOBIData *m, const char *serial, const time_t valid_from, const time_t valid_to,\n                             const MOBIExthTag *tamperkeys, const size_t tamperkeys_count) {\n#ifdef USE_ENCRYPTION\n    return mobi_voucher_add(m, serial, valid_from, valid_to, tamperkeys, tamperkeys_count);\n\n#else\n    UNUSED(m);\n    UNUSED(serial);\n    UNUSED(valid_from);\n    UNUSED(valid_to);\n    UNUSED(tamperkeys);\n    UNUSED(tamperkeys_count);\n    debug_print(\"Libmobi compiled without encryption support%s\", \"\\n\");\n    return MOBI_DRM_UNSUPPORTED;\n#endif\n}\n\n/**\n @brief Store PID for encryption in MOBIData stucture\n \n @param[in,out] m MOBIData structure with raw data and metadata\n @param[in] pid PID\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_drm_setkey(MOBIData *m, const char *pid) {\n#ifdef USE_ENCRYPTION\n    return mobi_drmkey_set(m, pid);\n#else\n    UNUSED(m);\n    UNUSED(pid);\n    debug_print(\"Libmobi compiled without encryption support%s\", \"\\n\");\n    return MOBI_DRM_UNSUPPORTED;\n#endif\n}\n\n/**\n @brief Remove PID stored for encryption from MOBIData structure\n \n @param[in,out] m MOBIData structure with raw data and metadata\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_drm_delkey(MOBIData *m) {\n#ifdef USE_ENCRYPTION\n    return mobi_drmkey_delete(m);\n#else\n    UNUSED(m);\n    debug_print(\"Libmobi compiled without encryption support%s\", \"\\n\");\n    return MOBI_DRM_UNSUPPORTED;\n#endif\n}\n\n/**\n @brief Free internals\n\n @param[in,out] m MOBIData structure with raw data and metadata\n */\nvoid mobi_free_internals(MOBIData *m) {\n#ifdef USE_ENCRYPTION\n    mobi_free_drm(m);\n#else\n    UNUSED(m);\n#endif\n}\n\n/**\n @brief Convert char buffer to 32-bit unsigned integer big endian\n \n @param[in] buf Input buffer\n @return Converted value\n */\nuint32_t mobi_get32be(const unsigned char buf[4]) {\n    uint32_t val = (uint32_t) buf[0] << 24;\n    val |= (uint32_t) buf[1] << 16;\n    val |= (uint32_t) buf[2] << 8;\n    val |= (uint32_t) buf[3];\n    return val;\n}\n\n/**\n @brief Convert char buffer to 32-bit unsigned integer little endian\n \n @param[in] buf Input buffer\n @return Converted value\n */\nuint32_t mobi_get32le(const unsigned char buf[4]) {\n    uint32_t val = (uint32_t) buf[0];\n    val |= (uint32_t) buf[1] << 8;\n    val |= (uint32_t) buf[2] << 16;\n    val |= (uint32_t) buf[3] << 24;\n    return val;\n}\n", "/** @file common.c\n *\n * @brief common tools functions\n *\n * @example common.c\n * Common functions for tools\n *\n * Copyright (c) 2016 Bartek Fabiszewski\n * http://www.fabiszewski.net\n *\n * Licensed under LGPL, either version 3, or any later.\n * See <http://www.gnu.org/licenses/>\n */\n\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <mobi.h>\n#include \"common.h\"\n\n#ifdef _WIN32\n# include <direct.h>\n# define mkdir(path,flags) _mkdir(path)\nconst char separator = '\\\\';\n#else\nconst char separator = '/';\n#endif\nbool outdir_opt = false;\nchar outdir[FILENAME_MAX];\n\n#define UNUSED(x) (void)(x)\n\n#ifndef min\n# define min(a, b) ((a) < (b) ? (a) : (b))\n#endif\n\n/**\n @brief Messages for libmobi return codes\n For reference see enum MOBI_RET in mobi.h\n */\nconst char *libmobi_messages[] = {\n    \"Success\",\n    \"Generic error\",\n    \"Wrong function parameter\",\n    \"Corrupted data\",\n    \"File not found\",\n    \"Document is encrypted\",\n    \"Unsupported document format\",\n    \"Memory allocation error\",\n    \"Initialization error\",\n    \"Buffer error\",\n    \"XML error\",\n    \"Invalid DRM pid\",\n    \"DRM key not found\",\n    \"DRM support not included\",\n    \"Write failed\",\n    \"DRM expired\"\n};\n\n#define LIBMOBI_MSG_COUNT ARRAYSIZE(libmobi_messages)\n\n/**\n @brief Return message for given libmobi return code\n @param[in] ret Libmobi return code\n @return Message string\n */\nconst char * libmobi_msg(const MOBI_RET ret) {\n    size_t index = ret;\n    if (index < LIBMOBI_MSG_COUNT) {\n        return libmobi_messages[index];\n    }\n    return \"Unknown error\";\n}\n\n/**\n @brief Parse file name into file path and base name.\n        Dirname or basename can be skipped by setting to null.\n @param[in] fullpath Full file path\n @param[in,out] dirname Will be set to full dirname\n @param[in,out] basename Will be set to file basename\n @param[in] buf_len Size of each ouput buffer: dirname and basename\n */\nvoid split_fullpath(const char *fullpath, char *dirname, char *basename, const size_t buf_len) {\n    if (buf_len == 0) {\n        return;\n    }\n    char *p = strrchr(fullpath, separator);\n    if (p) {\n        p += 1;\n        if (dirname) {\n            size_t dirlen = min(buf_len - 1, (size_t) (p - fullpath));\n            strncpy(dirname, fullpath, dirlen);\n            dirname[dirlen] = '\\0';\n        }\n        if (basename) {\n            strncpy(basename, p, buf_len - 1);\n            basename[buf_len - 1] = '\\0';\n        }\n    }\n    else {\n        if (dirname) {\n            dirname[0] = '\\0';\n        }\n        if (basename) {\n            strncpy(basename, fullpath, buf_len - 1);\n            basename[buf_len - 1] = '\\0';\n        }\n    }\n    if (basename) {\n        p = strrchr(basename, '.');\n        if (p) {\n            *p = '\\0';\n        }\n    }\n}\n\n/**\n @brief Make directory\n @param[in] path Path\n @return SUCCESS or ERROR\n */\nint make_directory(const char *path) {\n    errno = 0;\n    if (mkdir(path, S_IRWXU) != 0 && errno != EEXIST) {\n        int errsv = errno;\n        printf(\"Creating directory \\\"%s\\\" failed (%s)\\n\", path, strerror(errsv));\n        return ERROR;\n    }\n    return SUCCESS;\n}\n\n/**\n @brief Create subfolder in directory\n @param[in,out] newdir Path to created subfolder\n @param[in] buf_len Buffer size fo created subfolder\n @param[in] parent_dir Directory path\n @param[in] subdir_name Subfolder name\n @return SUCCESS or ERROR\n */\nint create_subdir(char *newdir, const size_t buf_len, const char *parent_dir, const char *subdir_name) {\n    int n = snprintf(newdir, buf_len, \"%s%c%s\", parent_dir, separator, subdir_name);\n    if (n < 0) {\n        printf(\"Creating file name failed\\n\");\n        return ERROR;\n    }\n    if ((size_t) n >= buf_len) {\n        printf(\"File name too long: %s\\n\", newdir);\n        return ERROR;\n    }\n    return make_directory(newdir);\n}\n\n/**\n @brief Open file descriptor and write buffer to it\n @param[in] buffer Buffer\n @param[in] len Buffer length\n @param[in] path File path\n @return SUCCESS or ERROR\n */\nint write_file(const unsigned char *buffer, const size_t len, const char *path) {\n    errno = 0;\n    FILE *file = fopen(path, \"wb\");\n    if (file == NULL) {\n        int errsv = errno;\n        printf(\"Could not open file for writing: %s (%s)\\n\", path, strerror(errsv));\n        return ERROR;\n    }\n    size_t n = fwrite(buffer, 1, len, file);\n    if (n != len) {\n        int errsv = errno;\n        printf(\"Error writing to file: %s (%s)\\n\", path, strerror(errsv));\n        fclose(file);\n        return ERROR;\n    }\n    fclose(file);\n    return SUCCESS;\n}\n\n/**\n @brief Write content to file in directory\n @param[in] dir Directory path\n @param[in] name File name\n @param[in] buffer Buffer\n @param[in] len Buffer length\n @return SUCCESS or ERROR\n */\nint write_to_dir(const char *dir, const char *name, const unsigned char *buffer, const size_t len) {\n    char path[FILENAME_MAX];\n    int n = snprintf(path, sizeof(path), \"%s%c%s\", dir, separator, name);\n    if (n < 0) {\n        printf(\"Creating file name failed\\n\");\n        return ERROR;\n    }\n    if ((size_t) n >= sizeof(path)) {\n        printf(\"File name too long\\n\");\n        return ERROR;\n    }\n    return write_file(buffer, len, path);\n}\n\n/**\n @brief Check whether given path exists and is a directory\n @param[in] path Path to be tested\n @return True if directory exists, false otherwise\n */\nbool dir_exists(const char *path) {\n    struct stat sb;\n    if (stat(path, &sb) != 0) {\n        int errsv = errno;\n        printf(\"Path \\\"%s\\\" is not accessible (%s)\\n\", path, strerror(errsv));\n        return false;\n    }\n    if (!S_ISDIR(sb.st_mode)) {\n        printf(\"Path \\\"%s\\\" is not a directory\\n\", path);\n        return false;\n    }\n    return true;\n}\n\n/**\n @brief Make sure we use consistent separators on Windows builds\n @param[in,out] path Path to be fixed\n */\nvoid normalize_path(char *path) {\n#ifdef _WIN32\n    if (path != NULL) {\n        for (size_t i = 0; i <= strlen(path); i++) {\n            if (path[i] == '/') {\n                path[i] = separator;\n            }\n        }\n    }\n#else\n    UNUSED(path);\n#endif\n}\n\n\n/**\n @brief Print summary meta information\n @param[in] m MOBIData structure\n */\nvoid print_summary(const MOBIData *m) {\n    char *title = mobi_meta_get_title(m);\n    if (title) {\n        printf(\"Title: %s\\n\", title);\n        free(title);\n    }\n    char *author = mobi_meta_get_author(m);\n    if (author) {\n        printf(\"Author: %s\\n\", author);\n        free(author);\n    }\n    char *contributor = mobi_meta_get_contributor(m);\n    uint32_t major = 0, minor = 0, build = 0;\n    bool is_calibre = false;\n    if (contributor) {\n        const char *calibre_contributor = \"calibre (\";\n        if (strncmp(contributor, calibre_contributor, strlen(calibre_contributor)) == 0) {\n            is_calibre = true;\n            sscanf(contributor, \"calibre (%u.%u.%u)\", &major, &minor, &build);\n        } else {\n            printf(\"Contributor: %s\\n\", contributor);\n        }\n        free(contributor);\n    }\n    char *subject = mobi_meta_get_subject(m);\n    if (subject) {\n        printf(\"Subject: %s\\n\", subject);\n        free(subject);\n    }\n    char *publisher = mobi_meta_get_publisher(m);\n    if (publisher) {\n        printf(\"Publisher: %s\\n\", publisher);\n        free(publisher);\n    }\n    char *date = mobi_meta_get_publishdate(m);\n    if (date) {\n        printf(\"Publishing date: %s\\n\", date);\n        free(date);\n    }\n    char *description = mobi_meta_get_description(m);\n    if (description) {\n        printf(\"Description: %s\\n\", description);\n        free(description);\n    }\n    char *review = mobi_meta_get_review(m);\n    if (review) {\n        printf(\"Review: %s\\n\", review);\n        free(review);\n    }\n    char *imprint = mobi_meta_get_imprint(m);\n    if (imprint) {\n        printf(\"Imprint: %s\\n\", imprint);\n        free(imprint);\n    }\n    char *copyright = mobi_meta_get_copyright(m);\n    if (copyright) {\n        printf(\"Copyright: %s\\n\", copyright);\n        free(copyright);\n    }\n    char *isbn = mobi_meta_get_isbn(m);\n    if (isbn) {\n        printf(\"ISBN: %s\\n\", isbn);\n        free(isbn);\n    }\n    char *asin = mobi_meta_get_asin(m);\n    if (asin) {\n        printf(\"ASIN: %s\\n\", asin);\n        free(asin);\n    }\n    char *language = mobi_meta_get_language(m);\n    if (language) {\n        printf(\"Language: %s\", language);\n        free(language);\n        if (m->mh && m->mh->text_encoding) {\n            uint32_t encoding = *m->mh->text_encoding;\n            if (encoding == MOBI_CP1252) {\n                printf(\" (cp1252)\");\n            } else if (encoding == MOBI_UTF8) {\n                printf(\" (utf8)\");\n            }\n        }\n        printf(\"\\n\");\n    }\n    if (mobi_is_dictionary(m)) {\n        printf(\"Dictionary\");\n        if (m->mh && m->mh->dict_input_lang && m->mh->dict_output_lang &&\n            *m->mh->dict_input_lang && *m->mh->dict_output_lang) {\n            const char *locale_in = mobi_get_locale_string(*m->mh->dict_input_lang);\n            const char *locale_out = mobi_get_locale_string(*m->mh->dict_output_lang);\n            printf(\": %s => %s\", locale_in, locale_out);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"__\\n\");\n    if (strcmp(m->ph->type, \"TEXt\") == 0) {\n        if (strcmp(m->ph->creator, \"TlDc\") == 0) {\n            printf(\"TealDoc\\n\");\n        } else {\n            printf(\"PalmDoc\\n\");\n        }\n    } else {\n        printf(\"Mobi version: %zu\", mobi_get_fileversion(m));\n        if (mobi_is_hybrid(m)) {\n            size_t version = mobi_get_fileversion(m->next);\n            if (version != MOBI_NOTSET) {\n                printf(\" (hybrid with version %zu)\", version);\n            }\n        }\n        printf(\"\\n\");\n    }\n    if (mobi_is_replica(m)) {\n        printf(\"Print Replica\\n\");\n    }\n    if (mobi_is_encrypted(m)) {\n        printf(\"Document is encrypted\\n\");\n    }\n    if (is_calibre) {\n        printf(\"Creator software: calibre %u.%u.%u\\n\", major, minor, build);\n    } else {\n        MOBIExthHeader *exth = mobi_get_exthrecord_by_tag(m, EXTH_CREATORSOFT);\n        if (exth) {\n            printf(\"Creator software: \");\n            uint32_t creator = mobi_decode_exthvalue(exth->data, exth->size);\n            exth = mobi_get_exthrecord_by_tag(m, EXTH_CREATORMAJOR);\n            if (exth) {\n                major = mobi_decode_exthvalue(exth->data, exth->size);\n            }\n            exth = mobi_get_exthrecord_by_tag(m, EXTH_CREATORMINOR);\n            if (exth) {\n                minor = mobi_decode_exthvalue(exth->data, exth->size);\n            }\n            exth = mobi_get_exthrecord_by_tag(m, EXTH_CREATORBUILD);\n            if (exth) {\n                build = mobi_decode_exthvalue(exth->data, exth->size);\n            }\n            exth = mobi_get_exthrecord_by_tag(m, EXTH_CREATORBUILDREV);\n            if (major == 2 && minor == 9 && build == 0 && exth) {\n                char *rev = mobi_decode_exthstring(m, exth->data, exth->size);\n                if (rev) {\n                    if (strcmp(rev, \"0730-890adc2\") == 0) {\n                        is_calibre = true;\n                    }\n                    free(rev);\n                }\n            }\n            switch (creator) {\n                case 0:\n                    printf(\"mobipocket reader %u.%u.%u\", major, minor, build);\n                    break;\n                case 1:\n                case 101:\n                    printf(\"mobigen %u.%u.%u\", major, minor, build);\n                    break;\n                case 2:\n                    printf(\"mobipocket creator %u.%u.%u\", major, minor, build);\n                    break;\n                case 200:\n                    printf(\"kindlegen %u.%u.%u (windows)\", major, minor, build);\n                    if (is_calibre) {\n                        printf(\" or calibre\");\n                    }\n                    break;\n                case 201:\n                    printf(\"kindlegen %u.%u.%u (linux)\", major, minor, build);\n                    if ((major == 1 && minor == 2 && build == 33307) ||\n                        (major == 2 && minor == 0 && build == 101) ||\n                        is_calibre) {\n                        printf(\" or calibre\");\n                    }\n                    break;\n                case 202:\n                    printf(\"kindlegen %u.%u.%u (mac)\", major, minor, build);\n                    if (is_calibre) {\n                        printf(\" or calibre\");\n                    }\n                    break;\n                default:\n                    printf(\"unknown\");\n                    break;\n            }\n            printf(\"\\n\");\n        }\n    }\n}\n\n/**\n @brief Print all loaded EXTH record tags\n @param[in] m MOBIData structure\n */\nvoid print_exth(const MOBIData *m) {\n    if (m->eh == NULL) {\n        return;\n    }\n    /* Linked list of MOBIExthHeader structures holds EXTH records */\n    const MOBIExthHeader *curr = m->eh;\n    if (curr != NULL) {\n        printf(\"\\nEXTH records:\\n\");\n    }\n    uint32_t val32;\n    while (curr != NULL) {\n        /* check if it is a known tag and get some more info if it is */\n        MOBIExthMeta tag = mobi_get_exthtagmeta_by_tag(curr->tag);\n        if (tag.tag == 0) {\n            /* unknown tag */\n            /* try to print the record both as string and numeric value */\n            char *str = malloc(curr->size + 1);\n            if (!str) {\n                printf(\"Memory allocation failed\\n\");\n                exit(1);\n            }\n            unsigned i = 0;\n            unsigned char *p = curr->data;\n            while (i < curr->size && isprint(*p)) {\n                str[i] = (char)*p++;\n                i++;\n            }\n            str[i] = '\\0';\n            val32 = mobi_decode_exthvalue(curr->data, curr->size);\n            printf(\"Unknown (%i): %s (%u)\\n\", curr->tag, str, val32);\n            free(str);\n        } else {\n            /* known tag */\n            unsigned i = 0;\n            size_t size = curr->size;\n            unsigned char *data = curr->data;\n            switch (tag.type) {\n                    /* numeric */\n                case EXTH_NUMERIC:\n                    val32 = mobi_decode_exthvalue(data, size);\n                    printf(\"%s (%i): %u\\n\", tag.name, tag.tag, val32);\n                    break;\n                    /* string */\n                case EXTH_STRING:\n                {\n                    char *exth_string = mobi_decode_exthstring(m, data, size);\n                    if (exth_string) {\n                        printf(\"%s (%i): %s\\n\", tag.name, tag.tag, exth_string);\n                        free(exth_string);\n                    }\n                    break;\n                }\n                    /* binary */\n                case EXTH_BINARY:\n                {\n                    char *str = malloc(2 * size + 1);\n                    if (!str) {\n                        printf(\"Memory allocation failed\\n\");\n                        exit(1);\n                    }\n                    str[0] = '\\0';\n                    while (size) {\n                        uint8_t val8 = *data++;\n                        sprintf(&str[i], \"%02x\", val8);\n                        i += 2;\n                        size--;\n                    }\n                    printf(\"%s (%i): 0x%s\\n\", tag.name, tag.tag, str);\n                    free(str);\n                    break;\n                }\n                default:\n                    break;\n            }\n        }\n        curr = curr->next;\n    }\n}\n\n/**\n @brief Set PID for decryption\n @param[in,out] m MOBIData structure\n @param[in] pid Serial number\n @return SUCCESS or error code\n */\nint set_decryption_pid(MOBIData *m, const char *pid) {\n    printf(\"\\nVerifying PID %s...\", pid);\n    MOBI_RET mobi_ret = mobi_drm_setkey(m, pid);\n    if (mobi_ret != MOBI_SUCCESS) {\n        printf(\"failed (%s)\\n\", libmobi_msg(mobi_ret));\n        return (int) mobi_ret;\n    }\n    printf(\"ok\\n\");\n    return SUCCESS;\n}\n\n/**\n @brief Set device serial number for decryption\n @param[in,out] m MOBIData structure\n @param[in] serial Serial number\n @return SUCCESS or error code\n */\nint set_decryption_serial(MOBIData *m, const char *serial) {\n    printf(\"\\nVerifying serial %s... \", serial);\n    MOBI_RET mobi_ret = mobi_drm_setkey_serial(m, serial);\n    if (mobi_ret != MOBI_SUCCESS) {\n        printf(\"failed (%s)\\n\", libmobi_msg(mobi_ret));\n        return (int) mobi_ret;\n    }\n    printf(\"ok\\n\");\n    return SUCCESS;\n}\n\n/**\n @brief Set key for decryption. Use user supplied pid or device serial number\n @param[in,out] m MOBIData structure\n @param[in] serial Serial number\n @param[in] pid Pid\n @return SUCCESS or error code\n */\nint set_decryption_key(MOBIData *m, const char *serial, const char *pid) {\n\n    if (!pid && !serial) {\n        return SUCCESS;\n    }\n    if (!mobi_is_encrypted(m)) {\n        printf(\"\\nDocument is not encrypted, ignoring PID/serial\\n\");\n        return SUCCESS;\n    }\n    if (m->rh && m->rh->encryption_type == MOBI_ENCRYPTION_V1) {\n        printf(\"\\nEncryption type 1, ignoring PID/serial\\n\");\n        return SUCCESS;\n    }\n    int ret = SUCCESS;\n    if (pid && (ret = set_decryption_pid(m, pid)) == SUCCESS) {\n        return SUCCESS;\n    }\n    if (serial) {\n        ret = set_decryption_serial(m, serial);\n    }\n    return ret;\n}\n\n/**\n @brief Save mobi file\n \n @param[in,out] m MOBIData struicture\n @param[in] fullpath Full file path\n @param[in] suffix Suffix appended to file name\n @return SUCCESS or ERROR\n */\nint save_mobi(MOBIData *m, const char *fullpath, const char *suffix) {\n    char outfile[FILENAME_MAX];\n    char basename[FILENAME_MAX];\n    char dirname[FILENAME_MAX];\n    split_fullpath(fullpath, dirname, basename, FILENAME_MAX);\n    const char *ext = (mobi_get_fileversion(m) >= 8) ? \"azw3\" : \"mobi\";\n    int n;\n    if (outdir_opt) {\n        n = snprintf(outfile, sizeof(outfile), \"%s%s-%s.%s\", outdir, basename, suffix, ext);\n    } else {\n        n = snprintf(outfile, sizeof(outfile), \"%s%s-%s.%s\", dirname, basename, suffix, ext);\n    }\n    if (n < 0) {\n        printf(\"Creating file name failed\\n\");\n        return ERROR;\n    }\n    if ((size_t) n >= sizeof(outfile)) {\n        printf(\"File name too long\\n\");\n        return ERROR;\n    }\n    \n    /* write */\n    printf(\"Saving %s...\\n\", outfile);\n    FILE *file_out = fopen(outfile, \"wb\");\n    if (file_out == NULL) {\n        int errsv = errno;\n        printf(\"Error opening file: %s (%s)\\n\", outfile, strerror(errsv));\n        return ERROR;\n    }\n    MOBI_RET mobi_ret = mobi_write_file(file_out, m);\n    fclose(file_out);\n    if (mobi_ret != MOBI_SUCCESS) {\n        printf(\"Error writing file (%s)\\n\", libmobi_msg(mobi_ret));\n        return ERROR;\n    }\n    return SUCCESS;\n}\n"], "fixing_code": ["2022-04-27: Fix undefined behavior when passing null to strdup\n2022-04-27: Fix wrong boundary checks in inflections parser resulting in stack buffer over-read with corrupt input\n2022-04-26: Fix text formatting\n2022-04-26: Fix array boundary check when parsing inflections which could result in buffer over-read with corrupt input\n2022-04-23: Fix formatting\n2022-04-23: Fix checking boundary of deobfuscation key which could cause buffer over-read with corrupt data\n2022-04-23: Fix issue with corrupt data with empty lookup string which could lead to read beyond buffer\n2022-04-23: Fix faulty checks for array boundary which caused buffer over-read with corrupt input\n2022-04-23: Fix issue with corrupt files with tagvalues_count = 0 that caused null pointer dereference\n2022-04-23: Fix issues when mobi_buffer_getpointer returns null. With corrupt data this could lead to out-of-bounds read\n2022-04-13: Add packaging status [skip ci]\n2022-04-10: Make random generation return proper error codes\n2022-04-10: Rewrite randombytes for libmobi\n2022-04-07: Add libsodium randombytes.c\n2022-04-10: Fix \"fallthrough\" spelling\n2022-04-10: Make declaration match definition\n2022-04-10: Fix different sign comparison warning\n2022-04-10: Update Xcode project\n2022-04-10: Don't run tests if bash is missing\n2022-04-10: Looking for libxml2, first try pkg-config\n2022-04-04: Update MSVC project\n2022-04-02: Add support for GNU/kFreeBSD and GNU/Hurd\n2022-04-02: Check for inline, noreturn support in CMake\n2022-03-27: Fix format truncation warning\n2022-03-21: Version 0.10\n2022-03-21: Update Xcode project [skip ci]\n2022-03-21: Add functions for retrieving orthographic index entries\n2022-02-27: Add basic CMake support\n2022-02-26: GHA: fetch tags with checkout\n2022-02-26: Minor refactoring of file path manipulation function\n2022-02-26: Fix memory handling issues\n2022-02-26: Add coverity scan workflow\n2022-02-25: Remove obsolete changelog\n2022-02-25: Fix md5sum output on Windows\n2022-02-25: Fix inconsistent separators in path on Windows builds\n2022-02-25: GHA: fix log paths\n2022-02-25: GHA: fix workflow syntax\n2022-02-25: GHA: upload test logs on failure\n2022-02-24: Fix printf format specifier\n2022-02-24: Fix sample path in Makefile\n2022-02-24: Missing autotools in mingw workflow\n2022-02-24: Windows doesn't accept asterisk in file names\n2022-02-24: Update workflow, add badge\n2022-02-24: Add mingw workflow\n2022-02-24: Fix tests in out-of-tree build\n2022-02-24: Update man pages\n2022-02-24: Replace non-portable strptime\n2022-02-24: Make sure both validity period dates are set\n2022-02-21: Fix strptime not found on linux build\n2022-02-21: Add build github action\n2022-02-21: Update README\n2022-02-21: Minor code cleanups\n2022-02-21: Unify boolean and static usage in tools\n2022-02-21: mobimeta: fix null pointer dereference when parsing malformed option\n2022-02-18: Add  hybrid spit option to mobitool\n2022-02-18: Update documentation\n2022-02-18: Test both encrypted hybrid parts\n2022-02-18: Fix: fast decryption routine fails for non-huffman compression\n2022-02-18: Fix mobitool serial decryption\n2022-02-18: Add DRM tests\n2022-02-17: Fix build with encryption disabled\n2022-02-17: Update tests samples\n2022-02-16: Add -h option to tools, update man pages\n2022-02-16: Update Xcode settings\n2022-02-16: Restructure, cleanup encryption related code, add mobidrm tool\n2021-11-19: Improve getopt loop, fix config.h to be accessible from all tools\n2021-11-10: Update xcode project\n2021-11-10: Add functions to split hybrid files\n2021-11-10: Avoid modifying existing records, as caller may keep reference to them\n2021-11-05: Fix: tests fail if pid contains asterisk\n2021-11-05: Fix: decryption may fail for some records with standard compression\n2021-11-05: Replace test samples with self-generated smaller ones\n2021-11-05: Skip test in case of missing checksums\n2021-10-20: Version 0.9\n2021-10-24: Fix out-of-tree build\n2021-10-22: Fix mingw build, code formatting\n2021-10-14: Fix gcc format truncation warning\n2021-10-14: Include autogen.sh in distribution bundle\n2021-10-14: Create codeql-analysis.yml\n2021-10-14: Fix autoconf 2.70 warnings, clean up\n2021-10-14: Build fails with autoconf 2.70\n2021-10-11: Version 0.8\n2021-10-11: Update Xcode project\n2021-10-11: Fix warnings about changed signedness\n2021-09-18: Fix potential out-of-buffer read while parsing corrupt file, closes #38\n2021-09-18: Fix potential out-of-buffer read while parsing corrupt file, closes #35, #36\n2021-09-09: Version 0.7\n2021-09-09: fix oob write bug inside libmobi\n2021-06-07: Add reference to brew formula\n2020-09-02: Fix null pointer dereference in case of broken fragment\n2020-08-01: Update changelog\n2020-08-01: Version 0.6\n2020-07-31: Fix typo\n2020-07-31: Add Readme to dist package\n2020-07-31: Remove anchor on truncated link\n2020-07-31: Fix missing option in man page\n2020-07-30: Include test samples in dist package\n2020-07-25: Fix gcc 7+ warnings about implicit fall through and format truncation\n2020-07-24: Unique names for internal functions to avoid confilicts with static linking\n2020-06-24: Close file in error branch\n2020-06-24: Fix static compilation with miniz on gcc\n2020-06-24: Minor documentation fixes\n2020-06-23: Version 0.5\n2020-06-23: mobitool: add dump cover option\n2020-06-23: Minor documentation improvement\n2020-06-23: Fix potential buffer over-read\n2019-03-18: Fix: try also \"name\" attribute when searching for link anchor tags, closes #24\n2019-02-22: Add mobi_is_replica function\n2019-02-22: Fix potential read beyond buffer\n2019-02-22: Travis migration\n2018-08-07: Fix: missing items in recreated ncx file\n2018-06-20: Fix: printf format warning on some gcc versions\n2018-06-20: Fix: make dist broken by nonexistent header files\n2018-06-20: VERSION 0.4\n2018-06-20: Fix: buffer overflow (CVE-2018-11726)\n2018-06-20: Fix: buffer overflow (CVE-2018-11724)\n2018-06-20: Fix: read beyond buffer (CVE-2018-11725)\n2018-06-20: Fix: buffer overflow (mobitool), closes #18\n2018-06-20: Fix: read beyond buffer with corrupted KF8 Boundary record, closes #19\n2018-06-20: Fix: read beyond buffer, closes #16, #17\n2018-06-20: Updated xcode project files\n2018-04-03: Fix: ncx part was not scanned for links, fixes #12\n2018-04-02: Fix regression, potential use after free\n2018-04-02: Skip broken resources, fixes #10\n2018-03-05: Allow processing zero length text records, fixes #9\n2017-12-25: Skip broken first resource offset instead of dying\n2017-12-18: Skip broken links reconstruction instead of dying\n2017-11-27: Disable travis OS X builds, as they usually time out\n2017-11-16: Fix: increase max number of dictionary entries per record\n2017-11-14: Fix for some encrypted documents with palmdoc encoding\n2017-11-06: Fix: potential null pointer dereference\n2017-10-16: Manpage cleanup\n2017-09-27: Update README\n2017-09-26: Increase maximum length of attribute name and value, closes #5\n2017-02-26: Remove obsolete files from VS build (closes #3) [ci skip]\n2016-11-05: Mobitool: use epub extension if extracted source resource is epub\n2016-06-10: Update docs\n2016-06-10: Update test files\n2016-06-10: Fix: out of bounds read in corrupt font resource\n2016-06-10: Prevent memory leak in case of corrupt font resources\n2016-06-10: Calculate deobfuscation buffer limit from key length\n2016-06-10: Fix: USE_LIBXML2 macro was not included from config.h\n2016-06-10: Fix: USE_LIBXML2 macro was not included from config.h\n2016-06-09: Fix: memory leak in tools\n2016-06-09: Fix: potential out of bounds read\n2016-06-09: Fix: memory leak in internal xmlwriter\n2016-06-01: Update README\n2016-05-19: Feature: verify decryption key type\n2016-05-19: Cleanup converting little endian buffer to 32-bit integer\n2016-05-19: Feature: check drm expiration dates\n2016-05-18: Fix: memory leaks in encryption\n2016-05-18: Fix concurrent autotools builds\n2016-05-18: use relative path, as $(top_srcdir) fails to be substituted (?)\n2016-05-18: update vcxproj\n2016-05-18: Include headers in automake sources\n2016-05-18: Fix: automake out-of-tree miniz build\n2016-05-18: Fix: wrongly detected fdst record broke some ancient documents\n2016-05-18: Fix: improve index header parsing, some old dictionaries might not load\n2016-05-18: Fix: convert encoding of opf strings from cp1252 indices\n2016-05-18: Quiet warnings about unused values of wiped variables\n2016-05-18: Fix: potential memory leak\n2016-05-18: Fix: wrongly decoded \"&copy;\" entity\n2016-05-16: Fix: huffdic decompression fails in case of huge documents\n2016-05-14: Simplify buffer_init_null() function\n2016-05-14: Use ARRAYSIZE macro\n2016-05-14: Feature: calculate pid for decryption from device serial number\n2016-04-29: Use endian-independent byte swapping\n2016-04-29: Exclude unused miniz functions from binary\n2016-04-29: Add SHA-1 routines\n2016-04-27: Fix miniz.c formatting\n2016-04-27: Documentation\n2016-04-20: Update changelog\n2016-04-20: Fix potential null pointer dereference\n2016-04-20: Remove useless check\n2016-04-20: Fix text record size calculation\n2016-04-20: Fix buffer checking and freeing\n2016-04-19: Update docs\n2016-04-19: Update ChangeLog\n2016-04-19: Fix comparison between signed and unsigned integer\n2016-04-19: use strdup on linux/glibc\n2016-04-19: Add initial write and metadata editing support. Add mobimeta tool.\n2016-04-19: Always check whether memory allocation succeeded\n2016-04-18: Fix: guarantee array resize step is at least 1\n2016-04-13: Workaround to read some old mobipocket files\n2016-04-13: Improve pdb dates resolving\n2016-04-07: Minor documentation edit\n2016-04-07: Update changelog\n2016-04-06: Fix format warning\n2016-04-06: Update test checksums\n2016-04-06: Fix: <dc:date> \"event\" attribute needs \"opf\" namespace\n2016-04-06: Fix: id attributes in ncx file should be unique\n2016-04-06: Store full name in MOBIMobiHeader structure\n2016-04-05: Fix formatting\n2016-04-05: Fix signedness warning\n2016-04-04: Fix potential buffer overflow, closes #2\n2016-04-04: Fix potential null pointer dereference\n2016-03-23: Fix signedness warnings\n2016-03-22: Fix: _mkdir needs direct.h on MinGW\n2016-03-22: Fix tests on Windows\n2016-03-22: Fix: palmdoc decompression may fail with zero byte in input buffer\n2016-03-21: VERSION 03: internal xmlwriter, metadata handling functions, bug fixes\n2016-03-21: Feature: add helper functions for metadata extraction\n2016-03-21: Load also kf8 data when only kf7 version is requested\n2016-03-21: Fix: wrong exth header length check could discard some valid headers\n2016-03-20: Get rid of extended attributes in release archive on OS X\n2016-03-19: Mobitool: add descriptive error messages based on libmobi return codes\n2016-03-04: Add extra length check for CMET record extraction\n2016-03-04: Always check buffer allocation result\n2016-03-04: Add functions to extract conversion source and log, also add this feature to mobitool\n2016-03-04: Remove some stray printfs\n2016-03-03: Remove not used AC_FUNC_MALLOC/REALLOC macros that break cross-compilation\n2016-03-03: Fix potential illegal memory access in miniz.c\n2016-03-03: Fix potential dereference of null pointer in miniz.c\n2016-03-03: Fix for Android bionic libc bug (SIZE_MAX missing in stdint.h)\n2016-03-03: Fix mobitool compilation on MSVC++\n2016-03-03: Add EPUB creation feature to mobitool\n2016-03-02: Fix potential buffer overflow, null pointer dereference\n2016-03-02: Add travis test for no-external-dependency build\n2016-03-02: Fix missing strdup on linux\n2016-03-02: Add internal xmlwriter (as an alternative to libxml2)\n2016-03-01: Feature: decode html entities in exth header strings\n2016-02-29: Fix: potential buffer overflow\n2016-02-29: Fix: wrong pid calculation (regression introduced in 0.2)\n2016-02-26: VERSION 0.2: increased stability, lots of bugs fixed\n2016-02-26: Add Xcode project file\n2016-02-26: Preliminary support for MSVC++ compiler\n2016-02-26: Do not use variable length arrays\n2016-02-26: Refactor mobi_reconstruct_parts() to use MOBIFragment list\n2016-02-26: Fix compiler warning about sign conversion\n2016-02-26: Fix compiler warning about type conversion\n2016-02-26: Check the result of malloc/calloc\n2016-02-26: Fix inconsistent use of const between some definitions and declarations\n2016-02-24: Fix inconsistence between function declaration and definition\n2016-02-24: Fix various potential crashes in case of corrupt input (afl-fuzz)\n2016-02-24: Fix dead code warnings in miniz\n2015-11-26: Export mobi_get_first_resource_record() function\n2015-11-26: Fix: double free on corrupt cdic\n2015-11-02: Update docs\n2015-11-02: Feature: add helper functions to find resources by flow id\n2015-11-02: Feature: export MOBI_NOTSET macro\n2015-11-02: Feature: give more options to parse rawml function\n2015-10-24: Restore travis.yml\n2015-10-24: Fix OSX travis build\n2015-10-24: Fix OSX travis build\n2015-10-24: Fix multiline inline script\n2015-10-24: Enable multi-OS feature\n2015-10-24: Fix: unique temporary name for parallel tests\n2015-10-24: Fix: decoding video resources falsely reported as failed\n2015-10-24: Fix: tests, some md5sum implementations insert double spaces\n2015-10-24: Fix for automake < 1.13\n2015-10-23: Add simple tests framework\n2015-10-23: Fix: increase max index entries per record count, as some rare samples fail\n2015-10-22: Fix: incorrectly decoded video/audio resources\n2015-10-22: Feature: add option to specify output path\n2015-10-14: Add some internal functions to public API: mobi_get_flow_by_uid, mobi_get_resource_by_uid, mobi_get_part_by_uid, mobi_get_exthrecord_by_tag\n2015-06-13: update changelog\n2015-06-13: fix: various invalid memory access\n2015-06-13: don't quit on invalid input, instead substitute with replacement character\n2015-06-12: fix typo\n2015-06-12: update changelog\n2015-06-12: fix: reconstruction failed when there were gaps between fragments\n2015-06-12: add EXTH tags\n2015-06-12: prevent return of garbage value check return value in case of failed malloc\n2015-06-12: fix invalid memory access\n2015-04-12: Fix reconstruction of \"kindle:embed\" links without mime type (regression)\n2015-04-12: Add sanity checks to link reconstruction functions, allow skipping some malformed patterns\n2015-04-12: Fix infinite loop in guide build while unknown tag was found\n2015-04-12: Increase max recursion level for huffman decompression\n2015-03-28: update docs\n2015-03-28: fix solaris studio compiler warnings\n2015-03-28: fix solaris studio compiler build\n2015-02-18: Fix \"more than one: -compatibility_version specified\" error on powerpc\n2014-11-24: improve docs\n2014-11-24: simplify public header\n2014-11-21: changelog update [ci skip]\n2014-11-21: README\n2014-11-21: fix: add sanity checks\n2014-11-21: Fix: add sanity checks\n2014-11-21: add sanity check to huffcdic indices count\n2014-11-21: fix number of leaks and other minor issues (by coverity scan)\n2014-11-20: missing notification email kills coverity scan\n2014-11-20: update travis.yml\n2014-11-20: upgrade travis.ml with covert scan\n2014-11-20: update README.md\n2014-11-20: add .travis.yml\n2014-11-20: update REAME.md\n2014-11-20: update README.md\n2014-11-20: update docs\n2014-11-20: feature: add decryption support\n2014-11-20: mkdir cleanup\n2014-11-17: documentation\n2014-11-17: strip unneeded <aid/> tags\n2014-11-16: fix: potential leak\n2014-11-16: fix: regression, some image tags were not reconstructed\n2014-11-16: fix: improve ligatures handling\n2014-11-16: override darwin linker default versioning\n2014-11-15: fix: get proper LIGT entries count from index header\n2014-11-15: feature: unpack records into new folder\n2014-11-14: make README readable on github\n2014-11-14: add README for mobitool\n2014-11-14: fix: dictionaries with large inflection rules failed\n2014-11-14: feature: support encoded ligatures in index entry labels\n2014-11-14: readme\n2014-11-14: update changelog\n2014-11-13: feature: support for older inflections scheme\n2014-11-13: bug: files with short tagx header won't open\n2014-11-13: cleanup unneeded include\n2014-11-13: use strdup on linux/glibc\n2014-11-13: debugging cleanup\n2014-11-13: reorganize source files\n2014-11-13: use strdup on linux/glibc\n2014-11-11: update changelog\n2014-11-11: update changeling\n2014-11-11: fix: documents with text record size > 4096 failed to load\n2014-11-11: add: function to decode flat index entries\n2014-11-11: debug: add functions for debugging indices\n2014-11-11: cleanup\n2014-11-11: fix: variable length value wrongly calculated when going backwards\n2014-11-08: update documentation\n2014-11-08: update changelog\n2014-11-08: add support for reconstructing inflections index entries\n2014-11-08: parsing of exth header failed in some cases\n2014-11-08: fix: some links reconstruction in kf7 failed\n2014-11-08: improve debug info\n2014-11-08: failed malloc false reports\n2014-11-03: fix problem with uncompressed documents\n2014-11-03: fix broken locales\n2014-11-03: remove obsolete includes\n2014-11-03: git log > changelog\n2014-11-03: improved buffer handling\n2014-11-03: improved OPF for dictionaries\n2014-11-03: proper rawml->orth initialization and freeing\n2014-11-03: fix subject field in opf\n2014-11-03: handle UTF-16 surrogates, make ORDT lookups locale independent\n2014-11-01: move dict reconstruction to separate function\n2014-11-01: cleanup\n2014-11-01: quiet gcc warning on printf format\n2014-11-01: reconstruction of orth dictionary entries\n2014-09-27: use mobi_list_del_all()\n2014-09-25: postpone conversion to utf8 after all source reconstructions\n2014-09-24: comment\n2014-09-24: comments\n2014-09-12: doxygen comment\n2014-09-12: data size in comment\n2014-09-05: MOBIArray data type fix\n2014-09-05: config.h fixes\n2014-06-29: merge master\n2014-04-11: initial commit", "/** @file opf.c\n *  @brief Functions for handling OPF structures\n *\n * Copyright (c) 2020 Bartek Fabiszewski\n * http://www.fabiszewski.net\n *\n * This file is part of libmobi.\n * Licensed under LGPL, either version 3, or any later.\n * See <http://www.gnu.org/licenses/>\n */\n\n#define _GNU_SOURCE 1\n#ifndef __USE_BSD\n#define __USE_BSD /* for strdup on linux/glibc */\n#endif\n\n#include <stdlib.h>\n#include <string.h>\n#include \"opf.h\"\n#ifdef USE_LIBXML2\n#ifdef __clang__\n#pragma clang diagnostic push\n/* suppress clang documentation warning for libxml headers */\n#pragma clang diagnostic ignored \"-Wdocumentation\"\n#endif\n#include <libxml/encoding.h>\n#include <libxml/xmlwriter.h>\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n#else\n#include \"xmlwriter.h\"\n#endif\n#include \"index.h\"\n#include \"util.h\"\n#include \"parse_rawml.h\"\n#include \"debug.h\"\n\n/**\n @brief Array of valid OPF guide types\n \n http://www.idpf.org/epub/20/spec/OPF_2.0.1_draft.htm#Section2.6\n */\nconst char *mobi_guide_types[] = {\n    \"cover\", /**< the book cover(s), jacket information, etc. */\n    \"title-page\", /**< page with possibly title, author, publisher, and other metadata */\n    \"toc\", /**< table of contents */\n    \"index\", /**< back-of-book style index */\n    \"glossary\", /**< glossary */\n    \"acknowledgements\", /**< acknowledgements */\n    \"bibliography\", /**< bibliography */\n    \"colophon\", /**< colophon */\n    \"copyright-page\", /**< copyright page */\n    \"dedication\", /**< dedication */\n    \"epigraph\", /**< epigraph */\n    \"foreword\", /**< foreword */\n    \"loi\", /**< list of illustrations */\n    \"lot\", /**< list of tables */\n    \"notes\", /**< notes */\n    \"preface\", /**< preface */\n    \"text\", /**< First \"real\" page of content (e.g. \"Chapter 1\") */\n    NULL /**< eof */\n};\n\n/**\n @brief Check if type is valid OPF guide element\n \n Compares types with elements of mobi_guide_types[] array\n \n @param[in] type OPF guide type\n @return True if type is valid guide type, false otherwise\n */\nbool mobi_is_guide_type(const char *type) {\n    size_t i = 0;\n    size_t type_length = strlen(type);\n    while (mobi_guide_types[i]) {\n        if (strncmp(mobi_guide_types[i++], type, type_length) == 0) {\n            return true;\n        }\n    }\n    /* check if \"other\" type */\n    if (strncmp(type, \"other.\", 6) == 0) { return true; }\n    return false;\n}\n\n/**\n @brief Reconstruct guide part of the OPF file\n \n @param[in,out] opf Structure OPF->OPFguide will be filled with parsed data\n @param[in] rawml Structure MOBIRawml will be parsed\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_build_opf_guide(OPF *opf, const MOBIRawml *rawml) {\n    /* parse guide data */\n    if (rawml == NULL || rawml->guide == NULL) {\n        debug_print(\"%s\\n\", \"Initialization failed\");\n        return MOBI_INIT_FAILED;\n    }\n    size_t i = 0;\n    size_t j = 0;\n    MOBI_RET ret;\n    size_t count = rawml->guide->entries_count;\n    if (count == 0) {\n        return MOBI_SUCCESS;\n    }\n    opf->guide = malloc(sizeof(OPFguide));\n    if (opf->guide == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    OPFreference **reference = malloc((count + 1) * sizeof(OPFreference*));\n    if (reference == NULL) {\n        free(opf->guide);\n        opf->guide = NULL;\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    if (rawml->guide->cncx_record == NULL) {\n        free(reference);\n        free(opf->guide);\n        opf->guide = NULL;\n        debug_print(\"%s\\n\", \"Missing cncx record\");\n        return MOBI_DATA_CORRUPT;\n    }\n    while (i < count) {\n        const MOBIIndexEntry *guide_entry = &rawml->guide->entries[i];\n        const char *type = guide_entry->label;\n        uint32_t cncx_offset;\n        ret = mobi_get_indxentry_tagvalue(&cncx_offset, guide_entry, INDX_TAG_GUIDE_TITLE_CNCX);\n        if (ret != MOBI_SUCCESS) {\n            free(reference);\n            free(opf->guide);\n            opf->guide = NULL;\n            return ret;\n        }\n        const MOBIPdbRecord *cncx_record = rawml->guide->cncx_record;\n        char *ref_title = mobi_get_cncx_string_utf8(cncx_record, cncx_offset, rawml->guide->encoding);\n        if (ref_title == NULL) {\n            free(reference);\n            free(opf->guide);\n            opf->guide = NULL;\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        uint32_t frag_number = MOBI_NOTSET;\n        ret = mobi_get_indxentry_tagvalue(&frag_number, guide_entry, INDX_TAG_FRAG_POSITION);\n        if (ret != MOBI_SUCCESS) {\n            debug_print(\"INDX_TAG_FRAG_POSITION not found (%i)\\n\", ret);\n            free(ref_title);\n            i++;\n            continue;\n            /* FIXME: I need some examples which use other tags */\n            //mobi_get_indxentry_tagvalue(&frag_number, guide_entry, INDX_TAG_FRAG_FILE_NR);\n        }\n        if (frag_number >= rawml->frag->entries_count) {\n            debug_print(\"Wrong frag entry index (%i)\\n\", frag_number);\n            free(ref_title);\n            i++;\n            continue;\n        }\n        const MOBIIndexEntry *frag_entry = &rawml->frag->entries[frag_number];\n        uint32_t file_number;\n        ret = mobi_get_indxentry_tagvalue(&file_number, frag_entry, INDX_TAG_FRAG_FILE_NR);\n        if (ret != MOBI_SUCCESS) {\n            free(reference);\n            free(opf->guide);\n            free(ref_title);\n            opf->guide = NULL;\n            return ret;\n        }\n        /* check if valid guide type */\n        char *ref_type;\n        size_t type_size = strlen(type);\n        if (!mobi_is_guide_type(type)) {\n            /* prepend \"other.\" prefix */\n            type_size += 6;\n            ref_type = malloc(type_size + 1);\n            if (ref_type == NULL) {\n                free(reference);\n                free(opf->guide);\n                opf->guide = NULL;\n                free(ref_title);\n                debug_print(\"%s\\n\", \"Memory allocation failed\");\n                return MOBI_MALLOC_FAILED;\n            }\n            snprintf(ref_type, type_size + 1, \"other.%s\", type);\n        } else {\n            ref_type = malloc(type_size + 1);\n            if (ref_type == NULL) {\n                free(reference);\n                free(opf->guide);\n                opf->guide = NULL;\n                free(ref_title);\n                debug_print(\"%s\\n\", \"Memory allocation failed\");\n                return MOBI_MALLOC_FAILED;\n            }\n            memcpy(ref_type, type, type_size);\n            ref_type[type_size] = '\\0';\n        }\n        debug_print(\"<reference type=\\\"%s\\\" title=\\\"%s\\\" href=\\\"part%05u.html\\\" />\", ref_type, ref_title, file_number);\n        char href[FILENAME_MAX + 1];\n        snprintf(href, sizeof(href), \"part%05u.html\", file_number);\n        char *ref_href = strdup(href);\n        reference[j] = calloc(1, sizeof(OPFreference));\n        *reference[j] = (OPFreference) { ref_type, ref_title, ref_href };\n        i++;\n        j++;\n    }\n    /* terminate array with NULL */\n    reference[j] = NULL;\n    opf->guide->reference = reference;\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Write <navPoint/> entries for given ncx level\n \n @param[in,out] writer xmlTextWriterPtr to write to\n @param[in] ncx Array of NCX structures with ncx content\n @param[in] level TOC level\n @param[in] from First entry in NCX array to copy from\n @param[in] to Last entry in NCX array to copy from\n @param[in] seq Sequential number for playOrder attribute\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_write_ncx_level(xmlTextWriterPtr writer, const NCX *ncx, const size_t level, const size_t from, const size_t to, size_t *seq) {\n    for (size_t i = from; i <= to; i++) {\n        if (level != ncx[i].level) {\n            continue;\n        }\n        /* start <navPoint> */\n        char playorder[10 + 1];\n        snprintf(playorder, 11, \"%u\", (uint32_t) (*seq)++);\n\n        /* id string (max 10 digits and dash) for each level + \"toc\" + terminator */\n        size_t id_size = 11 * (level + 1) + 3 + 1;\n        char *id = malloc(id_size);\n        if (id == NULL) {\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        strcpy(id, \"toc\");\n        size_t curr_id = i;\n        while (curr_id != MOBI_NOTSET) {\n            size_t parent_id = ncx[curr_id].parent;\n            if (parent_id == curr_id) {\n                debug_print(\"%s\\n\", \"Skip id of corrupt ncx entry\");\n                break;\n            }\n            size_t curr_from = 0;\n            if (parent_id != MOBI_NOTSET && ncx[parent_id].first_child != MOBI_NOTSET) {\n                curr_from = ncx[parent_id].first_child;\n            }\n            char level_id[10 + 1];\n            snprintf(level_id, 11, \"%u\", (uint32_t) (curr_id - curr_from + 1));\n            char *id_copy = strdup(id + 3);\n            if (id_copy == NULL) {\n                debug_print(\"%s\\n\", \"Memory allocation failed\");\n                free(id);\n                return MOBI_MALLOC_FAILED;\n            }\n            snprintf(id, id_size, \"toc-%s%s\", level_id, id_copy);\n            free(id_copy);\n            curr_id = parent_id;\n        }\n        \n        int xml_ret = xmlTextWriterStartElement(writer, BAD_CAST \"navPoint\");\n        if (xml_ret < 0) {\n            free(id);\n            return MOBI_XML_ERR;\n        }\n        xml_ret = xmlTextWriterWriteAttribute(writer, BAD_CAST \"id\", BAD_CAST id);\n        free(id);\n        if (xml_ret < 0) { return MOBI_XML_ERR; }\n        xml_ret = xmlTextWriterWriteAttribute(writer, BAD_CAST \"playOrder\", BAD_CAST playorder);\n        if (xml_ret < 0) { return MOBI_XML_ERR; }\n        /* write <navLabel> */\n        xml_ret = xmlTextWriterStartElement(writer, BAD_CAST \"navLabel\");\n        if (xml_ret < 0) { return MOBI_XML_ERR; }\n        xml_ret = xmlTextWriterStartElement(writer, BAD_CAST \"text\");\n        if (xml_ret < 0) { return MOBI_XML_ERR; }\n        xml_ret = xmlTextWriterWriteString(writer, BAD_CAST ncx[i].text);\n        if (xml_ret < 0) { return MOBI_XML_ERR; }\n        xml_ret = xmlTextWriterEndElement(writer);\n        if (xml_ret < 0) { return MOBI_XML_ERR; }\n        xml_ret = xmlTextWriterEndElement(writer);\n        if (xml_ret < 0) { return MOBI_XML_ERR; }\n        /* write <content> */\n        xml_ret = xmlTextWriterStartElement(writer, BAD_CAST \"content\");\n        if (xml_ret < 0) { return MOBI_XML_ERR; }\n        xml_ret = xmlTextWriterWriteAttribute(writer, BAD_CAST \"src\", BAD_CAST ncx[i].target);\n        if (xml_ret < 0) { return MOBI_XML_ERR; }\n        xml_ret = xmlTextWriterEndElement(writer);\n        if (xml_ret < 0) { return MOBI_XML_ERR; }\n        debug_print(\"%s - %s\\n\", ncx[i].text, ncx[i].target);\n        if (ncx[i].first_child != MOBI_NOTSET && ncx[i].last_child != MOBI_NOTSET) {\n            MOBI_RET ret = mobi_write_ncx_level(writer, ncx, level + 1, ncx[i].first_child, ncx[i].last_child, seq);\n            if (ret != MOBI_SUCCESS) {\n                return ret;\n            }\n        }\n        /* end <navPoint> */\n        xml_ret = xmlTextWriterEndElement(writer);\n        if (xml_ret < 0) { return MOBI_XML_ERR; }\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Write element <meta name=\"name\" content=\"content\"/> to XML buffer\n \n @param[in,out] writer xmlTextWriterPtr to write to\n @param[in] name Attribute name\n @param[in] content Attribute content\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_xml_write_meta(xmlTextWriterPtr writer, const char *name, const char *content) {\n    int xml_ret = xmlTextWriterStartElement(writer, BAD_CAST \"meta\");\n    if (xml_ret < 0) {\n        debug_print(\"XML error: %i (name: %s, content: %s)\\n\", xml_ret, name, content);\n        return MOBI_XML_ERR;\n    }\n    xml_ret = xmlTextWriterWriteAttribute(writer, BAD_CAST \"name\", BAD_CAST name);\n    if (xml_ret < 0) {\n        debug_print(\"XML error: %i (name: %s, content: %s)\\n\", xml_ret, name, content);\n        return MOBI_XML_ERR;\n    }\n    xml_ret = xmlTextWriterWriteAttribute(writer, BAD_CAST \"content\", BAD_CAST content);\n    if (xml_ret < 0) {\n        debug_print(\"XML error: %i (name: %s, content: %s)\\n\", xml_ret, name, content);\n        return MOBI_XML_ERR;\n    }\n    xml_ret = xmlTextWriterEndElement(writer);\n    if (xml_ret < 0) {\n        debug_print(\"XML error: %i (name: %s, content: %s)\\n\", xml_ret, name, content);\n        return MOBI_XML_ERR;\n    }\n    return MOBI_SUCCESS;\n}\n\n\n/**\n @brief Add reconstruced opf part to rawml\n \n @param[in] opf_xml OPF xml string\n @param[in,out] rawml New data will be added to MOBIRawml rawml->resources structure\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_opf_add_to_rawml(const char *opf_xml, MOBIRawml *rawml) {\n    MOBIPart *opf_part;\n    size_t uid = 0;\n    if (rawml->resources) {\n        MOBIPart *part = rawml->resources;\n        while (part->next) {\n            part = part->next;\n        }\n        uid = part->uid + 1;\n        part->next = calloc(1, sizeof(MOBIPart));\n        opf_part = part->next;\n    }\n    else {\n        rawml->resources = calloc(1, sizeof(MOBIPart));\n        opf_part = rawml->resources;\n    }\n    if (opf_part == NULL) {\n        return MOBI_MALLOC_FAILED;\n    }\n    opf_part->uid = uid;\n    opf_part->next = NULL;\n    opf_part->data = (unsigned char *) strdup(opf_xml);\n    if (opf_part->data == NULL) {\n        free(opf_part);\n        opf_part = NULL;\n        return MOBI_MALLOC_FAILED;\n    }\n    opf_part->size = strlen(opf_xml);\n    opf_part->type = T_OPF;\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Add reconstruced ncx part to rawml\n \n @param[in] ncx_xml OPF xml string\n @param[in,out] rawml New data will be added to MOBIRawml rawml->resources structure\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_ncx_add_to_rawml(const char *ncx_xml, MOBIRawml *rawml) {\n    MOBIPart *ncx_part;\n    size_t uid = 0;\n    if (rawml->resources) {\n        MOBIPart *part = rawml->resources;\n        while (part->next) {\n            part = part->next;\n        }\n        uid = part->uid + 1;\n        part->next = calloc(1, sizeof(MOBIPart));\n        ncx_part = part->next;\n    }\n    else {\n        rawml->resources = calloc(1, sizeof(MOBIPart));\n        ncx_part = rawml->resources;\n    }\n    if (ncx_part == NULL) {\n        return MOBI_MALLOC_FAILED;\n    }\n    ncx_part->uid = uid;\n    ncx_part->next = NULL;\n    ncx_part->data = (unsigned char *) strdup(ncx_xml);\n    if (ncx_part->data == NULL) {\n        free(ncx_part);\n        ncx_part = NULL;\n        return MOBI_MALLOC_FAILED;\n    }\n    ncx_part->size = strlen(ncx_xml);\n    ncx_part->type = T_NCX;\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Write ncx header\n \n @param[in,out] writer xmlTextWriterPtr to write to\n @param[in] opf OPF structure to fetch some data\n @param[in] maxlevel Value of dtb:depth attribute\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_write_ncx_header(xmlTextWriterPtr writer, const OPF *opf, uint32_t maxlevel) {\n    /* write header */\n    char depth[10 + 1];\n    snprintf(depth, 11, \"%d\", maxlevel);\n\n    /* <head> */\n    int xml_ret = xmlTextWriterStartElement(writer, BAD_CAST \"head\");\n    if (xml_ret < 0) { return MOBI_XML_ERR; }\n    /* meta uid */\n    MOBI_RET ret = mobi_xml_write_meta(writer, \"dtb:uid\", opf->metadata->dc_meta->identifier[0]->value);\n    if (ret != MOBI_SUCCESS) { return ret; }\n    /* meta depth */\n    ret = mobi_xml_write_meta(writer, \"dtb:depth\", depth);\n    if (ret != MOBI_SUCCESS) { return ret; }\n    /* meta pagecount */\n    ret = mobi_xml_write_meta(writer, \"dtb:totalPageCount\", \"0\");\n    if (ret != MOBI_SUCCESS) { return ret; }\n    /* meta pagenumber */\n    ret = mobi_xml_write_meta(writer, \"dtb:maxPageNumber\", \"0\");\n    if (ret != MOBI_SUCCESS) { return ret; }\n    xml_ret = xmlTextWriterEndElement(writer);\n    if (xml_ret < 0) { return MOBI_XML_ERR; }\n    // <docTitle>\n    xml_ret = xmlTextWriterStartElement(writer, BAD_CAST \"docTitle\");\n    if (xml_ret < 0) { return MOBI_XML_ERR; }\n    xml_ret = xmlTextWriterStartElement(writer, BAD_CAST \"text\");\n    if (xml_ret < 0) { return MOBI_XML_ERR; }\n    xml_ret = xmlTextWriterWriteString(writer, BAD_CAST opf->metadata->dc_meta->title[0]);\n    if (xml_ret < 0) { return MOBI_XML_ERR; }\n    xml_ret = xmlTextWriterEndElement(writer);\n    if (xml_ret < 0) { return MOBI_XML_ERR; }\n    xml_ret = xmlTextWriterEndElement(writer);\n    if (xml_ret < 0) { return MOBI_XML_ERR; }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Build ncx document using libxml2 and append it to rawml\n \n @param[in,out] rawml MOBIRawml structure\n @param[in] ncx Array of NCX structures with ncx content\n @param[in] opf OPF structure to fetch some data\n @param[in] maxlevel Value of dtb:depth attribute\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_write_ncx(MOBIRawml *rawml, const NCX *ncx, const OPF *opf, uint32_t maxlevel) {\n    const xmlChar * NCXNamespace = BAD_CAST \"http://www.daisy.org/z3986/2005/ncx/\";\n    xmlBufferPtr buf = xmlBufferCreate();\n    if (buf == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    xmlTextWriterPtr writer = xmlNewTextWriterMemory(buf, 0);\n    if (writer == NULL) {\n        xmlBufferFree(buf);\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    xmlTextWriterSetIndent(writer, 1);\n    int xml_ret = xmlTextWriterStartDocument(writer, NULL, NULL, NULL);\n    if (xml_ret < 0) { goto cleanup; }\n    xml_ret = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST \"ncx\", NCXNamespace);\n    if (xml_ret < 0) { goto cleanup; }\n    xml_ret = xmlTextWriterWriteAttribute(writer, BAD_CAST \"version\", BAD_CAST \"2005-1\");\n    if (xml_ret < 0) { goto cleanup; }\n    xml_ret = xmlTextWriterWriteAttribute(writer, BAD_CAST \"xml:lang\", BAD_CAST opf->metadata->dc_meta->language[0]);\n    if (xml_ret < 0) { goto cleanup; }\n    \n    MOBI_RET ret = mobi_write_ncx_header(writer, opf, maxlevel);\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    \n    /* start <navMap> */\n    xml_ret = xmlTextWriterStartElement(writer, BAD_CAST \"navMap\");\n    if (xml_ret < 0) { goto cleanup; }\n    if (ncx && rawml->ncx->entries_count > 0) {\n        const size_t count = rawml->ncx->entries_count;\n        size_t seq = 1;\n        ret = mobi_write_ncx_level(writer, ncx, 0, 0, count - 1, &seq);\n        if (ret != MOBI_SUCCESS) { goto cleanup; }\n    }\n\n    /* end <navMap> */\n    xml_ret = xmlTextWriterEndDocument(writer);\n    if (xml_ret < 0) { goto cleanup; }\n    xmlFreeTextWriter(writer);\n    const char *ncx_xml = (const char *) buf->content;\n    mobi_ncx_add_to_rawml(ncx_xml, rawml);\n    xmlBufferFree(buf);\n    return MOBI_SUCCESS;\n    \ncleanup:\n    xmlFreeTextWriter(writer);\n    xmlBufferFree(buf);\n    debug_print(\"%s\\n\", \"XML writing failed\");\n    return MOBI_XML_ERR;\n}\n\n\n/**\n @brief Free array of ncx entries\n \n @param[in] ncx Array of NCX structures with ncx content\n @param[in] count Size of the array\n */\nvoid mobi_free_ncx(NCX *ncx, size_t count) {\n    if (ncx) {\n        while (count--) {\n            free(ncx[count].target);\n            free(ncx[count].text);\n        }\n        free(ncx);\n    }\n}\n\n/**\n @brief Parse ncx index, recreate ncx document and append it to rawml\n \n @param[in,out] rawml MOBIRawml structure\n @param[in] opf OPF structure to fetch some data\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_build_ncx(MOBIRawml *rawml, const OPF *opf) {\n    /* parse ncx data */\n    if (rawml == NULL) {\n        debug_print(\"%s\\n\", \"Initialization failed\");\n        return MOBI_INIT_FAILED;\n    }\n    if (rawml->ncx && rawml->ncx->cncx_record) {\n        size_t i = 0;\n        uint32_t maxlevel = 0;\n        MOBI_RET ret;\n        const size_t count = rawml->ncx->entries_count;\n        if (count == 0) {\n            return MOBI_SUCCESS;\n        }\n        NCX *ncx = malloc(count * sizeof(NCX));\n        if (ncx == NULL) {\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        MOBIAttrType pref_attr = ATTR_ID;\n        while (i < count) {\n            const MOBIIndexEntry *ncx_entry = &rawml->ncx->entries[i];\n            const char *label = ncx_entry->label;\n            const size_t id = strtoul(label, NULL, 16);\n            uint32_t cncx_offset;\n            ret = mobi_get_indxentry_tagvalue(&cncx_offset, ncx_entry, INDX_TAG_NCX_TEXT_CNCX);\n            if (ret != MOBI_SUCCESS) {\n                mobi_free_ncx(ncx, i);\n                return ret;\n            }\n            const MOBIPdbRecord *cncx_record = rawml->ncx->cncx_record;\n            char *text = mobi_get_cncx_string_utf8(cncx_record, cncx_offset, rawml->ncx->encoding);\n            if (text == NULL) {\n                mobi_free_ncx(ncx, i);\n                debug_print(\"%s\\n\", \"Memory allocation failed\");\n                return MOBI_MALLOC_FAILED;\n            }\n            char *target = malloc(MOBI_ATTRNAME_MAXSIZE + 1);\n            if (target == NULL) {\n                free(text);\n                mobi_free_ncx(ncx, i);\n                debug_print(\"%s\\n\", \"Memory allocation failed\");\n                return MOBI_MALLOC_FAILED;\n            }\n            if (mobi_is_rawml_kf8(rawml)) {\n                uint32_t posfid;\n                ret = mobi_get_indxentry_tagvalue(&posfid, ncx_entry, INDX_TAG_NCX_POSFID);\n                if (ret != MOBI_SUCCESS) {\n                    free(text);\n                    free(target);\n                    mobi_free_ncx(ncx, i);\n                    return ret;\n                }\n                uint32_t posoff;\n                ret = mobi_get_indxentry_tagvalue(&posoff, ncx_entry, INDX_TAG_NCX_POSOFF);\n                if (ret != MOBI_SUCCESS) {\n                    free(text);\n                    free(target);\n                    mobi_free_ncx(ncx, i);\n                    return ret;\n                }\n                uint32_t filenumber;\n                char targetid[MOBI_ATTRNAME_MAXSIZE + 1];\n                ret = mobi_get_id_by_posoff(&filenumber, targetid, rawml, posfid, posoff, &pref_attr);\n                if (ret != MOBI_SUCCESS) {\n                    free(text);\n                    free(target);\n                    mobi_free_ncx(ncx, i);\n                    return ret;\n                }\n                /* FIXME: posoff == 0 means top of file? */\n                if (posoff) {\n                    int n = snprintf(target, MOBI_ATTRNAME_MAXSIZE + 1, \"part%05u.html#%s\", filenumber, targetid);\n                    if (n > MOBI_ATTRVALUE_MAXSIZE + 1) {\n                        debug_print(\"Warning: truncated target: %s\\n\", target);\n                        snprintf(target, MOBI_ATTRNAME_MAXSIZE + 1, \"part%05u.html\", filenumber);\n                    }\n                } else {\n                    snprintf(target, MOBI_ATTRNAME_MAXSIZE + 1, \"part%05u.html\", filenumber);\n                }\n                \n            } else {\n                uint32_t filepos;\n                ret = mobi_get_indxentry_tagvalue(&filepos, ncx_entry, INDX_TAG_NCX_FILEPOS);\n                if (ret != MOBI_SUCCESS) {\n                    free(text);\n                    free(target);\n                    mobi_free_ncx(ncx, i);\n                    return ret;\n                }\n                snprintf(target, MOBI_ATTRNAME_MAXSIZE + 1, \"part00000.html#%010u\", filepos);\n            }\n            uint32_t level;\n            ret = mobi_get_indxentry_tagvalue(&level, ncx_entry, INDX_TAG_NCX_LEVEL);\n            if (ret != MOBI_SUCCESS) {\n                free(text);\n                free(target);\n                mobi_free_ncx(ncx, i);\n                return ret;\n            }\n            if (level > maxlevel) {\n                maxlevel = level;\n            }\n            uint32_t parent = MOBI_NOTSET;\n            ret = mobi_get_indxentry_tagvalue(&parent, ncx_entry, INDX_TAG_NCX_PARENT);\n            if (ret == MOBI_INIT_FAILED) {\n                free(text);\n                free(target);\n                mobi_free_ncx(ncx, i);\n                return ret;\n            }\n            uint32_t first_child = MOBI_NOTSET;\n            ret = mobi_get_indxentry_tagvalue(&first_child, ncx_entry, INDX_TAG_NCX_CHILD_START);\n            if (ret == MOBI_INIT_FAILED) {\n                free(text);\n                free(target);\n                mobi_free_ncx(ncx, i);\n                return ret;\n            }\n            uint32_t last_child = MOBI_NOTSET;\n            ret = mobi_get_indxentry_tagvalue(&last_child, ncx_entry, INDX_TAG_NCX_CHILD_END);\n            if (ret == MOBI_INIT_FAILED) {\n                free(text);\n                free(target);\n                mobi_free_ncx(ncx, i);\n                return ret;\n            }\n            if ((first_child != MOBI_NOTSET && first_child >= rawml->ncx->entries_count) ||\n                (last_child != MOBI_NOTSET && last_child >= rawml->ncx->entries_count) ||\n                (parent != MOBI_NOTSET && parent >= rawml->ncx->entries_count)) {\n                free(text);\n                free(target);\n                mobi_free_ncx(ncx, i);\n                return MOBI_DATA_CORRUPT;\n            }\n            debug_print(\"seq=%zu, id=%zu, text='%s', target='%s', level=%u, parent=%u, fchild=%u, lchild=%u\\n\", i, id, text, target, level, parent, first_child, last_child);\n            ncx[i++] = (NCX) {id, text, target, level, parent, first_child, last_child};\n        }\n        mobi_write_ncx(rawml, ncx, opf, maxlevel);\n        mobi_free_ncx(ncx, count);\n    } else {\n        mobi_write_ncx(rawml, NULL, opf, 1);\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Copy text data from EXTH record to array of strings\n \n It will allocate memory for the array if not already allocated.\n It will find first array index that is not already used\n \n @param[in] m MOBIData structure\n @param[in] exth MOBIExthHeader record\n @param[in,out] array Array into which text string will be inserted\n */\nstatic void mobi_opf_fill_tag(const MOBIData *m, const MOBIExthHeader *exth, char ***array) {\n    if (*array == NULL) {\n        *array = calloc(OPF_META_MAX_TAGS, sizeof(**array));\n        if (*array == NULL) {\n            return;\n        }\n    }\n    size_t i = 0;\n    while (i < OPF_META_MAX_TAGS) {\n        /* find first free slot */\n        if((*array)[i] != NULL) { i++; continue; }\n        MOBIExthMeta exth_tag = mobi_get_exthtagmeta_by_tag(exth->tag);\n        char *value = NULL;\n        if (exth_tag.type == EXTH_NUMERIC) {\n            value = malloc(10 + 1);\n            if (value) {\n                const uint32_t val32 = mobi_decode_exthvalue(exth->data, exth->size);\n                snprintf(value, 10 + 1, \"%d\", val32);\n            }\n        } else if (exth_tag.type == EXTH_STRING) {\n            value = mobi_decode_exthstring(m, exth->data, exth->size);\n        }\n        if (value) {\n            (*array)[i] = value;\n        }\n        return;\n    }\n    /* not enough tags */\n    debug_print(\"OPF_META_MAX_TAGS = %i reached\\n\", OPF_META_MAX_TAGS);\n}\n\n/**\n @brief Set values for attributes of OPF <meta/> tag\n \n It will allocate memory for the OPFmeta members: name and content.\n It will find first array index that is not already used\n \n @param[in,out] meta Array of OPFmeta structures to be filled with data\n @param[in] name Value of the name attribute\n @param[in] content Value of the content attribute\n */\nstatic void mobi_opf_set_meta(OPFmeta **meta, const char *name, const char *content) {\n    size_t i = 0;\n    while (i < OPF_META_MAX_TAGS) {\n        /* find first free slot */\n        if(meta[i] != NULL) { i++; continue; }\n        meta[i] = malloc(sizeof(OPFmeta));\n        if (meta[i] == NULL) {\n            return;\n        }\n        meta[i]->name = strdup(name);\n        meta[i]->content = strdup(content);\n        if (meta[i]->name == NULL || meta[i]->content == NULL) {\n            free(meta[i]);\n            meta[i] = NULL;\n        }\n        return;\n    }\n    /* not enough tags */\n    debug_print(\"OPF_META_MAX_TAGS = %i reached\\n\", OPF_META_MAX_TAGS);\n}\n\n/**\n @brief Set values for attributes of OPF <meta/> tag\n \n It will allocate memory for the OPFmeta members: name and content.\n Content attribute will be copied from EXTH record.\n It will find first array index that is not already used\n \n @param[in] m MOBIData structure\n @param[in] exth MOBIExthHeader structure containing EXTH records\n @param[in,out] meta Array of OPFmeta structures to be filled with data\n @param[in] name Value of the name attribute\n */\nstatic void mobi_opf_copy_meta(const MOBIData *m, const MOBIExthHeader *exth, OPFmeta **meta, const char *name) {\n    MOBIExthMeta exth_tag = mobi_get_exthtagmeta_by_tag(exth->tag);\n    char *content = NULL;\n    if (exth_tag.tag == EXTH_COVEROFFSET) {\n        content = malloc(13 + 1);\n        if (content) {\n            const uint32_t val32 = mobi_decode_exthvalue(exth->data, exth->size);\n            snprintf(content, 14, \"resource%05d\", val32);\n        }\n    } else if (exth_tag.type == EXTH_NUMERIC) {\n        content = malloc(10 + 1);\n        if (content) {\n            const uint32_t val32 = mobi_decode_exthvalue(exth->data, exth->size);\n            snprintf(content, 11, \"%d\", val32);\n        }\n    } else if (exth_tag.type == EXTH_STRING) {\n        char *string = mobi_decode_exthstring(m, exth->data, exth->size);\n        content = string;\n    }\n    if (content) {\n        mobi_opf_set_meta(meta, name, content);\n        free(content);\n    }\n}\n\n/**\n @brief Set values for attributes of OPF manifest <item/> tag\n \n It will allocate memory for the OPFitem members: id, href and media-type.\n It will find first array index that is not already used\n \n @param[in,out] meta Array of OPFmeta structures to be filled with data\n @param[in] name Value of the name attribute\n @param[in] content Value of the content attribute\n */\nvoid mobi_opf_set_item(OPFmeta **meta, const char *name, const char *content) {\n    size_t i = 0;\n    while (i < OPF_META_MAX_TAGS) {\n        /* find first free slot */\n        if(meta[i] != NULL) { i++; continue; }\n        meta[i] = malloc(sizeof(OPFmeta));\n        if (meta[i] == NULL) {\n            return;\n        }\n        meta[i]->name = strdup(name);\n        meta[i]->content = strdup(content);\n        if (meta[i]->name == NULL || meta[i]->content == NULL) {\n            free(meta[i]);\n            meta[i] = NULL;\n        }\n        return;\n    }\n    /* not enough tags */\n    debug_print(\"OPF_META_MAX_TAGS = %i reached\\n\", OPF_META_MAX_TAGS);\n}\n\n/**\n @brief Copy text data from EXTH record to \"member_name\" member of a structure with given type\n \n Data will copied from curr->data.\n It will allocate memory for the array of structures if not already allocated.\n It will find first array index that is not already used\n \n @param[in] mobidata Mobidata structure\n @param[in] struct_type Structure type defined with typedef\n @param[in] struct_element Member member_name of this structure will be set to EXTH data\n @param[in] member_name Structure member name that will be modified\n */\n#define mobi_opf_copy_tagtype(mobidata, struct_type, struct_element, member_name) { \\\n    if (struct_element == NULL) { \\\n        struct_element = calloc(OPF_META_MAX_TAGS, sizeof(*struct_element)); \\\n        if(struct_element == NULL) { \\\n            debug_print(\"%s\\n\", \"Memory allocation failed\"); \\\n            return MOBI_MALLOC_FAILED; \\\n        } \\\n    } \\\n    struct_type **element = struct_element; \\\n    size_t i = 0; \\\n    while (i < OPF_META_MAX_TAGS) { \\\n        /* find first free slot */ \\\n        if(element[i] != NULL) { \\\n            if(element[i]->member_name != NULL) { i++; continue; } \\\n        } else { \\\n            element[i] = calloc(1, sizeof(*element[i])); \\\n            if(element[i] == NULL) { \\\n                debug_print(\"%s\\n\", \"Memory allocation failed\"); \\\n                return MOBI_MALLOC_FAILED; \\\n            } \\\n        } \\\n        MOBIExthMeta exth_tag = mobi_get_exthtagmeta_by_tag(curr->tag); \\\n        char *value = NULL; \\\n        MOBI_RET error_ret = MOBI_DATA_CORRUPT; \\\n        if (exth_tag.type == EXTH_NUMERIC) { \\\n            value = malloc(10 + 1); \\\n            if (value) { \\\n                const uint32_t val32 = mobi_decode_exthvalue(curr->data, curr->size); \\\n                snprintf(value, 10 + 1, \"%d\", val32); \\\n            } else { \\\n                error_ret = MOBI_MALLOC_FAILED; \\\n            } \\\n        } else if (exth_tag.type == EXTH_STRING) { \\\n            value = mobi_decode_exthstring(mobidata, curr->data, curr->size); \\\n        } \\\n        if(value == NULL) { \\\n            free(element[i]); \\\n            element[i] = NULL; \\\n            debug_print(\"%s\\n\", \"Decoding failed\"); \\\n            return error_ret; \\\n        } \\\n        element[i]->member_name = value; \\\n        break; \\\n    } \\\n    if (i == OPF_META_MAX_TAGS) { \\\n    /* not enough tags */ \\\n    debug_print(\"OPF_META_MAX_TAGS = %i reached\\n\", OPF_META_MAX_TAGS); \\\n    } \\\n}\n\n/**\n @brief Set \"member_name\" member of a structure with given type to string value\n \n It will allocate memory for the array of structures if not already allocated.\n It will find first array index that is not already used\n \n @param[in] struct_type Structure type defined with typedef\n @param[in] struct_element Member member_name of this structure will be set to EXTH data\n @param[in] member_name Structure member name that will be modified\n @param[in] string String value that will be assigned to the structure memeber\n */\n#define mobi_opf_set_tagtype(struct_type, struct_element, member_name, string) { \\\n    if (struct_element == NULL) { \\\n        struct_element = calloc(OPF_META_MAX_TAGS, sizeof(*struct_element)); \\\n        if(struct_element == NULL) { \\\n            debug_print(\"%s\\n\", \"Memory allocation failed\"); \\\n            return MOBI_MALLOC_FAILED; \\\n        } \\\n    } \\\n    struct_type **element = struct_element; \\\n    size_t i = 0; \\\n    while (i < OPF_META_MAX_TAGS) { \\\n        /* find first free slot */ \\\n        if(element[i] != NULL) { \\\n            if(element[i]->member_name != NULL) { i++; continue; } \\\n        } else { \\\n            element[i] = calloc(1, sizeof(*element[i])); \\\n            if(element[i] == NULL) { \\\n                debug_print(\"%s\\n\", \"Memory allocation failed\"); \\\n                return MOBI_MALLOC_FAILED; \\\n            } \\\n        } \\\n        element[i]->member_name = strdup(string); \\\n        if(element[i]->member_name == NULL) { \\\n            free(element[i]); \\\n            element[i] = NULL; \\\n            debug_print(\"%s\\n\", \"Memory allocation failed\"); \\\n            return MOBI_MALLOC_FAILED; \\\n        } \\\n        break; \\\n    } \\\n    if (i == OPF_META_MAX_TAGS) { \\\n        /* not enough tags */ \\\n        debug_print(\"OPF_META_MAX_TAGS = %i reached\\n\", OPF_META_MAX_TAGS); \\\n    } \\\n}\n\n/**\n @brief Copy text data from EXTH record to OPFmetadata tags structure\n \n @param[in,out] metadata Structure OPFmetadata will be filled with parsed data\n @param[in] m MOBIData structure with loaded data\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_get_opf_from_exth(OPFmetadata *metadata, const MOBIData *m) {\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    if (m->eh == NULL) {\n        return MOBI_INIT_FAILED;\n    }\n    MOBIExthHeader *curr = m->eh;\n    /* iterate through EXTH records */\n    while (curr != NULL) {\n        switch (curr->tag) {\n                /* <dc-metadata/> */\n            case EXTH_DESCRIPTION:\n                mobi_opf_fill_tag(m, curr, &metadata->dc_meta->description);\n                break;\n            case EXTH_LANGUAGE:\n                mobi_opf_fill_tag(m, curr, &metadata->dc_meta->language);\n                break;\n            case EXTH_PUBLISHER:\n                mobi_opf_fill_tag(m, curr, &metadata->dc_meta->publisher);\n                break;\n            case EXTH_RIGHTS:\n                mobi_opf_fill_tag(m, curr, &metadata->dc_meta->rights);\n                break;\n            case EXTH_SOURCE:\n                mobi_opf_fill_tag(m, curr, &metadata->dc_meta->source);\n                break;\n            case EXTH_TITLE:\n            case EXTH_UPDATEDTITLE:\n                mobi_opf_fill_tag(m, curr, &metadata->dc_meta->title);\n                break;\n            case EXTH_TYPE:\n                mobi_opf_fill_tag(m, curr, &metadata->dc_meta->type);\n                break;\n            case EXTH_AUTHOR:\n                mobi_opf_copy_tagtype(m, OPFcreator, metadata->dc_meta->creator, value);\n                break;\n            case EXTH_CONTRIBUTOR:\n                mobi_opf_copy_tagtype(m, OPFcreator, metadata->dc_meta->contributor, value);\n                break;\n            case EXTH_SUBJECT:\n                mobi_opf_copy_tagtype(m, OPFsubject, metadata->dc_meta->subject, value);\n                break;\n            case EXTH_SUBJECTCODE:\n                mobi_opf_copy_tagtype(m, OPFsubject, metadata->dc_meta->subject, basic_code);\n                break;\n            case EXTH_ISBN:\n                mobi_opf_copy_tagtype(m, OPFidentifier, metadata->dc_meta->identifier, value);\n                mobi_opf_set_tagtype(OPFidentifier, metadata->dc_meta->identifier, scheme, \"ISBN\");\n                break;\n            case EXTH_PUBLISHINGDATE:\n                mobi_opf_copy_tagtype(m, OPFdate, metadata->dc_meta->date, value);\n                mobi_opf_set_tagtype(OPFdate, metadata->dc_meta->date, event, \"publication\");\n                break;\n                /* <x-metadata/> */\n            case EXTH_ADULT:\n                mobi_opf_fill_tag(m, curr, &metadata->x_meta->adult);\n                break;\n            case EXTH_DICTNAME:\n                mobi_opf_fill_tag(m, curr, &metadata->x_meta->dict_short_name);\n                break;\n            case EXTH_DICTLANGIN:\n                mobi_opf_fill_tag(m, curr, &metadata->x_meta->dictionary_in_lang);\n                break;\n            case EXTH_DICTLANGOUT:\n                mobi_opf_fill_tag(m, curr, &metadata->x_meta->dictionary_out_lang);\n                break;\n            case EXTH_IMPRINT:\n                mobi_opf_fill_tag(m, curr, &metadata->x_meta->imprint);\n                break;\n            case EXTH_REVIEW:\n                mobi_opf_fill_tag(m, curr, &metadata->x_meta->review);\n                break;\n            case EXTH_PRICE:\n                mobi_opf_copy_tagtype(m, OPFsrp, metadata->x_meta->srp, value);\n                break;\n            case EXTH_CURRENCY:\n                mobi_opf_copy_tagtype(m, OPFsrp, metadata->x_meta->srp, currency);\n                break;\n                /* <meta/> */\n            case EXTH_FIXEDLAYOUT:\n                mobi_opf_copy_meta(m, curr, metadata->meta, \"fixed-layout\");\n                break;\n            case EXTH_BOOKTYPE:\n                mobi_opf_copy_meta(m, curr, metadata->meta, \"book-type\");\n                break;\n            case EXTH_ORIENTATIONLOCK:\n                mobi_opf_copy_meta(m, curr, metadata->meta, \"orientation-lock\");\n                break;\n            case EXTH_ORIGRESOLUTION:\n                mobi_opf_copy_meta(m, curr, metadata->meta, \"original-resolution\");\n                break;\n            case EXTH_ZEROGUTTER:\n                mobi_opf_copy_meta(m, curr, metadata->meta, \"zero-gutter\");\n                break;\n            case EXTH_ZEROMARGIN:\n                mobi_opf_copy_meta(m, curr, metadata->meta, \"zero-margin\");\n                break;\n            case EXTH_REGIONMAGNI:\n                mobi_opf_copy_meta(m, curr, metadata->meta, \"region-mag\");\n                break;\n            case EXTH_ALIGNMENT:\n                mobi_opf_copy_meta(m, curr, metadata->meta, \"primary-writing-mode\");\n                break;\n            case EXTH_OVERRIDEFONTS:\n                mobi_opf_copy_meta(m, curr, metadata->meta, \"override-kindle-fonts\");\n                break;\n            case EXTH_COVEROFFSET:\n                mobi_opf_copy_meta(m, curr, metadata->meta, \"cover\");\n                break;\n            default:\n                break;\n        }\n        curr = curr->next;\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Recreate OPF structure\n \n @param[in,out] opf Structure OPF->OPFmetadata will be filled with parsed data\n @param[in] m MOBIData structure containing document metadata\n @param[in] rawml MOBIRawml structure containing parsed records\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_build_opf_metadata(OPF *opf,  const MOBIData *m, const MOBIRawml *rawml) {\n    if (m == NULL) {\n        debug_print(\"%s\\n\", \"Initialization failed\");\n        return MOBI_INIT_FAILED;\n    }\n    opf->metadata = calloc(1, sizeof(OPFmetadata));\n    if (opf->metadata == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    /* initialize metadata sub-elements */\n    opf->metadata->meta = calloc(OPF_META_MAX_TAGS, sizeof(OPFmeta*));\n    if (opf->metadata->meta == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    opf->metadata->dc_meta = calloc(1, sizeof(OPFdcmeta));\n    if (opf->metadata->dc_meta == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    opf->metadata->x_meta = calloc(1, sizeof(OPFxmeta));\n    if (opf->metadata->x_meta == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    if (m->eh) {\n        MOBI_RET ret = mobi_get_opf_from_exth(opf->metadata, m);\n        if (ret != MOBI_SUCCESS) {\n            return ret;\n        }\n    }\n    /* check for required elements */\n    if (opf->metadata->dc_meta->identifier == NULL) {\n        /* default id will be \"0\" */\n        char uid_string[11] = \"0\";\n        if (m->mh && m->mh->uid) {\n            snprintf(uid_string, 11, \"%u\", *m->mh->uid);\n        }\n        mobi_opf_set_tagtype(OPFidentifier, opf->metadata->dc_meta->identifier, value, uid_string);\n        mobi_opf_set_tagtype(OPFidentifier, opf->metadata->dc_meta->identifier, id, \"uid\");\n    } else {\n        opf->metadata->dc_meta->identifier[0]->id = strdup(\"uid\");\n    }\n    if (opf->metadata->dc_meta->title == NULL) {\n        opf->metadata->dc_meta->title = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n        if (opf->metadata->dc_meta->title == NULL) {\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        char *title = mobi_meta_get_title(m);\n        if (title == NULL) {\n            title = strdup(\"Unknown\");\n        }\n        opf->metadata->dc_meta->title[0] = title;\n    }\n    if (opf->metadata->dc_meta->language == NULL) {\n        opf->metadata->dc_meta->language = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n        if (opf->metadata->dc_meta->language == NULL) {\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        const char *lang_string = NULL;\n        if (m->mh && m->mh->locale) {\n            uint32_t lang_code = *m->mh->locale;\n            lang_string = mobi_get_locale_string(lang_code);\n        }\n        if (lang_string) {\n            opf->metadata->dc_meta->language[0] = strdup(lang_string);\n        } else {\n            opf->metadata->dc_meta->language[0] = strdup(\"en\");\n        }\n    }\n    /* write optional elements */\n    if (mobi_is_dictionary(m)) {\n        if (opf->metadata->x_meta->dictionary_in_lang == NULL) {\n            if (m->mh && m->mh->dict_input_lang) {\n                uint32_t dict_lang_in = *m->mh->dict_input_lang;\n                const char *lang = mobi_get_locale_string(dict_lang_in);\n                if (lang) {\n                    opf->metadata->x_meta->dictionary_in_lang = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n                    if (opf->metadata->x_meta->dictionary_in_lang == NULL) {\n                        debug_print(\"%s\\n\", \"Memory allocation failed\");\n                        return MOBI_MALLOC_FAILED;\n                    }\n                    opf->metadata->x_meta->dictionary_in_lang[0] = strdup(lang);\n                }\n            }\n        }\n        if (opf->metadata->x_meta->dictionary_out_lang == NULL) {\n            if (m->mh && m->mh->dict_output_lang) {\n                uint32_t dict_lang_out = *m->mh->dict_output_lang;\n                const char *lang = mobi_get_locale_string(dict_lang_out);\n                if (lang) {\n                    opf->metadata->x_meta->dictionary_out_lang = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n                    if (opf->metadata->x_meta->dictionary_out_lang == NULL) {\n                        debug_print(\"%s\\n\", \"Memory allocation failed\");\n                        return MOBI_MALLOC_FAILED;\n                    }\n                    opf->metadata->x_meta->dictionary_out_lang[0] = strdup(lang);\n                }\n            }\n        }\n        if (rawml->orth->orth_index_name) {\n            opf->metadata->x_meta->default_lookup_index = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n            if (opf->metadata->x_meta->default_lookup_index == NULL) {\n                debug_print(\"%s\\n\", \"Memory allocation failed\");\n                return MOBI_MALLOC_FAILED;\n            }\n            opf->metadata->x_meta->default_lookup_index[0] = strdup(rawml->orth->orth_index_name);\n        }\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Write array of xml elements of given name to XML buffer\n \n Wrapper for libxml2 xmlTextWriterWriteElementNS() function.\n Writes xml element for each not-null entry in the input array.\n \n @param[in,out] writer xmlTextWriterPtr to write to\n @param[in] name XML element name\n @param[in] content Array of XML element contents\n @param[in] ns XML namespace string or NULL if empty\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_xml_write_element_ns(xmlTextWriterPtr writer, const char *name, const char **content, const char *ns) {\n    if (content) {\n        size_t i = 0;\n        while (i < OPF_META_MAX_TAGS) {\n            if (content[i] == NULL) {\n                break;\n            }\n            xmlChar *namespace = NULL;\n            if (ns) {\n                namespace = BAD_CAST ns;\n            }\n            int xml_ret = xmlTextWriterWriteElementNS(writer, namespace, BAD_CAST name, NULL, BAD_CAST content[i]);\n            if (xml_ret < 0) {\n                debug_print(\"XML error: %i (name: %s, content: %s)\\n\", xml_ret, name, content[i]);\n                return MOBI_XML_ERR;\n            }\n            i++;\n        }\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Write array of Dublin Core elements of given name to XML buffer\n \n Wrapper for libxml2 xmlTextWriterWriteElementNS() function.\n Writes xml element for each not-null entry in the input array.\n \n @param[in,out] writer xmlTextWriterPtr to write to\n @param[in] name XML element name\n @param[in] content Array of XML element contents\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_xml_write_dcmeta(xmlTextWriterPtr writer, const char *name, const char **content) {\n    return mobi_xml_write_element_ns(writer, name, content, \"dc\");\n}\n\n/**\n @brief Write array of custom MOBI elements of given name to XML buffer\n \n Wrapper for libxml2 xmlTextWriterWriteElementNS() function.\n Writes xml element for each not-null entry in the input array.\n \n @param[in,out] writer xmlTextWriterPtr to write to\n @param[in] name XML element name\n @param[in] content Array of XML element contents\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_xml_write_xmeta(xmlTextWriterPtr writer, const char *name, const char **content) {\n    return mobi_xml_write_element_ns(writer, name, content, NULL);\n}\n\n/**\n @brief Write array of <meta/> elements to XML buffer\n \n Wrapper for libxml2 xmlTextWriterWriteElement() function.\n Writes xml element for each not-null entry in the input array.\n \n @param[in,out] writer xmlTextWriterPtr to write to\n @param[in] meta Array of OPFmeta structures\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_xml_write_opfmeta(xmlTextWriterPtr writer, const OPFmeta **meta) {\n    if (meta) {\n        size_t i = 0;\n        while (i < OPF_META_MAX_TAGS) {\n            if (meta[i] == NULL) {\n                break;\n            }\n            MOBI_RET ret = mobi_xml_write_meta(writer, meta[i]->name, meta[i]->content);\n            if (ret != MOBI_SUCCESS) {\n                return ret;\n            }\n            i++;\n        }\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Write array of <referenece/> elements to XML buffer\n \n Wrapper for libxml2 xmlTextWriterWriteElement() function.\n Writes xml element for each not-null entry in the input array.\n \n @param[in,out] writer xmlTextWriterPtr to write to\n @param[in] reference Array of OPFreference structures\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_xml_write_reference(xmlTextWriterPtr writer, const OPFreference **reference) {\n    if (reference) {\n        size_t i = 0;\n        while (i < OPF_META_MAX_TAGS) {\n            if (reference[i] == NULL) {\n                break;\n            }\n            int xml_ret;\n            xml_ret = xmlTextWriterStartElement(writer, BAD_CAST \"reference\");\n            if (xml_ret < 0) {\n                debug_print(\"XML error: %i (reference type: %s)\\n\", xml_ret, reference[i]->type);\n                return MOBI_XML_ERR;\n            }\n            xml_ret = xmlTextWriterWriteAttribute(writer, BAD_CAST \"type\", BAD_CAST reference[i]->type);\n            if (xml_ret < 0) {\n                debug_print(\"XML error: %i (reference type: %s)\\n\", xml_ret, reference[i]->type);\n                return MOBI_XML_ERR;\n            }\n            xml_ret = xmlTextWriterWriteAttribute(writer, BAD_CAST \"title\", BAD_CAST reference[i]->title);\n            if (xml_ret < 0) {\n                debug_print(\"XML error: %i (reference type: %s)\\n\", xml_ret, reference[i]->type);\n                return MOBI_XML_ERR;\n            }\n            xml_ret = xmlTextWriterWriteAttribute(writer, BAD_CAST \"href\", BAD_CAST reference[i]->href);\n            if (xml_ret < 0) {\n                debug_print(\"XML error: %i (reference type: %s)\\n\", xml_ret, reference[i]->type);\n                return MOBI_XML_ERR;\n            }\n            xml_ret = xmlTextWriterEndElement(writer);\n            if (xml_ret < 0) {\n                debug_print(\"XML error: %i (reference type: %s)\\n\", xml_ret, reference[i]->type);\n                return MOBI_XML_ERR;\n            }\n            i++;\n        }\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Write single <item/> element to XML buffer\n \n @param[in,out] writer xmlTextWriterPtr to write to\n @param[in] id Attribute \"id\"\n @param[in] href Attribute \"href\"\n @param[in] media_type Attribute \"media-type\"\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_xml_write_item(xmlTextWriterPtr writer, const char *id, const char *href, const char *media_type) {\n    int xml_ret;\n    xml_ret = xmlTextWriterStartElement(writer, BAD_CAST \"item\");\n    if (xml_ret < 0) {\n        debug_print(\"XML error: %i (item id: %s)\\n\", xml_ret, id);\n        return MOBI_XML_ERR;\n    }\n    xml_ret = xmlTextWriterWriteAttribute(writer, BAD_CAST \"id\", BAD_CAST id);\n    if (xml_ret < 0) {\n        debug_print(\"XML error: %i (item id: %s)\\n\", xml_ret, id);\n        return MOBI_XML_ERR;\n    }\n    xml_ret = xmlTextWriterWriteAttribute(writer, BAD_CAST \"href\", BAD_CAST href);\n    if (xml_ret < 0) {\n        debug_print(\"XML error: %i (item id: %s)\\n\", xml_ret, id);\n        return MOBI_XML_ERR;\n    }\n    xml_ret = xmlTextWriterWriteAttribute(writer, BAD_CAST \"media-type\", BAD_CAST media_type);\n    if (xml_ret < 0) {\n        debug_print(\"XML error: %i (item id: %s)\\n\", xml_ret, id);\n        return MOBI_XML_ERR;\n    }\n    xml_ret = xmlTextWriterEndElement(writer);\n    if (xml_ret < 0) {\n        debug_print(\"XML error: %i (item id: %s)\\n\", xml_ret, id);\n        return MOBI_XML_ERR;\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Write opf <spine/> part to XML buffer\n \n @param[in,out] writer xmlTextWriterPtr to write to\n @param[in] rawml MOBIRawml structure containing parts metadata\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_xml_write_spine(xmlTextWriterPtr writer, const MOBIRawml *rawml) {\n    if (!rawml || !rawml->resources || !rawml->markup || !writer) {\n        return MOBI_INIT_FAILED;\n    }\n    /* get toc id */\n    char ncxid[13 + 1];\n    MOBIPart *curr = rawml->resources;\n    while (curr != NULL && curr->type != T_NCX) {\n        curr = curr->next;\n    }\n    if (curr) {\n        snprintf(ncxid, sizeof(ncxid), \"resource%05zu\", curr->uid);\n    } else {\n        return MOBI_DATA_CORRUPT;\n    }\n    int xml_ret;\n    xml_ret = xmlTextWriterStartElement(writer, BAD_CAST \"spine\");\n    if (xml_ret < 0) {\n        debug_print(\"XML error: %i (spine)\\n\", xml_ret);\n        return MOBI_XML_ERR;\n    }\n    xml_ret = xmlTextWriterWriteAttribute(writer, BAD_CAST \"toc\", BAD_CAST ncxid);\n    if (xml_ret < 0) {\n        debug_print(\"XML error: %i (spine toc: %s)\\n\", xml_ret, ncxid);\n        return MOBI_XML_ERR;\n    }\n    char id[9 + 1];\n    curr = rawml->markup;\n    while (curr != NULL) {\n        snprintf(id, sizeof(id), \"part%05zu\", curr->uid);\n        xml_ret = xmlTextWriterStartElement(writer, BAD_CAST \"itemref\");\n        if (xml_ret < 0) {\n            debug_print(\"XML error: %i (itemref)\\n\", xml_ret);\n            return MOBI_XML_ERR;\n        }\n        xml_ret = xmlTextWriterWriteAttribute(writer, BAD_CAST \"idref\", BAD_CAST id);\n        if (xml_ret < 0) {\n            debug_print(\"XML error: %i (idref: %s)\\n\", xml_ret, id);\n            return MOBI_XML_ERR;\n        }\n        xml_ret = xmlTextWriterEndElement(writer);\n        if (xml_ret < 0) {\n            debug_print(\"XML error: %i (idref: %s)\\n\", xml_ret, id);\n            return MOBI_XML_ERR;\n        }\n        curr = curr->next;\n    }\n    xml_ret = xmlTextWriterEndElement(writer);\n    if (xml_ret < 0) {\n        debug_print(\"XML error: %i (spine)\\n\", xml_ret);\n        return MOBI_XML_ERR;\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Write all manifest <item/> elements to XML buffer\n \n @param[in,out] writer xmlTextWriterPtr to write to\n @param[in] rawml MOBIRawml structure containing parts metadata\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_xml_write_manifest(xmlTextWriterPtr writer, const MOBIRawml *rawml) {\n    char href[256];\n    char id[256];\n    if (rawml->flow != NULL) {\n        MOBIPart *curr = rawml->flow;\n        /* skip first raw html part */\n        curr = curr->next;\n        while (curr != NULL) {\n            MOBIFileMeta file_meta = mobi_get_filemeta_by_type(curr->type);\n            snprintf(href, sizeof(href), \"flow%05zu.%s\", curr->uid, file_meta.extension);\n            snprintf(id, sizeof(id), \"flow%05zu\", curr->uid);\n            MOBI_RET ret = mobi_xml_write_item(writer, id, href, file_meta.mime_type);\n            if (ret != MOBI_SUCCESS) {\n                return ret;\n            }\n            curr = curr->next;\n        }\n    }\n    if (rawml->markup != NULL) {\n        MOBIPart *curr = rawml->markup;\n        while (curr != NULL) {\n            MOBIFileMeta file_meta = mobi_get_filemeta_by_type(curr->type);\n            snprintf(href, sizeof(href), \"part%05zu.%s\", curr->uid, file_meta.extension);\n            snprintf(id, sizeof(id), \"part%05zu\", curr->uid);\n            MOBI_RET ret = mobi_xml_write_item(writer, id, href, file_meta.mime_type);\n            if (ret != MOBI_SUCCESS) {\n                return ret;\n            }\n            curr = curr->next;\n        }\n    }\n    if (rawml->resources != NULL) {\n        MOBIPart *curr = rawml->resources;\n        while (curr != NULL) {\n            MOBIFileMeta file_meta = mobi_get_filemeta_by_type(curr->type);\n            snprintf(href, sizeof(href), \"resource%05zu.%s\", curr->uid, file_meta.extension);\n            snprintf(id, sizeof(id), \"resource%05zu\", curr->uid);\n            MOBI_RET ret = mobi_xml_write_item(writer, id, href, file_meta.mime_type);\n            if (ret != MOBI_SUCCESS) {\n                return ret;\n            }\n            curr = curr->next;\n        }\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Write array of Dublin Core identifier elements to XML buffer\n \n Wrapper for libxml2 xmlTextWriterWriteElementNS() function.\n Writes xml element for each not-null entry in the input array.\n \n @param[in,out] writer xmlTextWriterPtr to write to\n @param[in] identifier OPFidentifier structure representing identifier element\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_xml_write_dcmeta_identifier(xmlTextWriterPtr writer, const OPFidentifier **identifier) {\n    if (identifier) {\n        size_t i = 0;\n        while (i < OPF_META_MAX_TAGS) {\n            if (identifier[i] == NULL || identifier[i]->value == NULL) {\n                break;\n            }\n            int xml_ret;\n            xml_ret = xmlTextWriterStartElementNS(writer, BAD_CAST \"dc\", BAD_CAST \"identifier\", NULL);\n            if (xml_ret < 0) {\n                debug_print(\"XML error: %i (identifier value: %s)\\n\", xml_ret, identifier[i]->value);\n                return MOBI_XML_ERR;\n            }\n            if (identifier[i]->id) {\n                xml_ret = xmlTextWriterWriteAttribute(writer, BAD_CAST \"id\", BAD_CAST identifier[i]->id);\n                if (xml_ret < 0) {\n                    debug_print(\"XML error: %i (identifier id: %s)\\n\", xml_ret, identifier[i]->id);\n                    return MOBI_XML_ERR;\n                }\n            }\n            if (identifier[i]->scheme) {\n                xml_ret = xmlTextWriterWriteAttributeNS(writer, BAD_CAST \"opf\", BAD_CAST \"scheme\", NULL, BAD_CAST identifier[i]->scheme);\n                if (xml_ret < 0) {\n                    debug_print(\"XML error: %i (identifier value: %s)\\n\", xml_ret, identifier[i]->value);\n                    return MOBI_XML_ERR;\n                }\n            }\n            xml_ret = xmlTextWriterWriteString(writer, BAD_CAST identifier[i]->value);\n            if (xml_ret < 0) {\n                debug_print(\"XML error: %i (identifier value: %s)\\n\", xml_ret, identifier[i]->value);\n                return MOBI_XML_ERR;\n            }\n            xml_ret = xmlTextWriterEndElement(writer);\n            if (xml_ret < 0) {\n                debug_print(\"XML error: %i (identifier value: %s)\\n\", xml_ret, identifier[i]->value);\n                return MOBI_XML_ERR;\n            }\n            i++;\n        }\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Write array of Dublin Core creator/contributor elements to XML buffer\n \n Wrapper for libxml2 xmlTextWriterWriteElementNS() function.\n Writes xml element for each not-null entry in the input array.\n \n @param[in,out] writer xmlTextWriterPtr to write to\n @param[in] creator OPFcreator structure representing creator/contributor element\n @param[in] name OPF creator value\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_xml_write_dcmeta_creator(xmlTextWriterPtr writer, const OPFcreator **creator, const char *name) {\n    if (creator) {\n        size_t i = 0;\n        while (i < OPF_META_MAX_TAGS) {\n            if (creator[i] == NULL || creator[i]->value == NULL) {\n                break;\n            }\n            int xml_ret;\n            xml_ret = xmlTextWriterStartElementNS(writer, BAD_CAST \"dc\", BAD_CAST name, NULL);\n            if (xml_ret < 0) {\n                debug_print(\"XML error: %i (creator value: %s)\\n\", xml_ret, creator[i]->value);\n                return MOBI_XML_ERR;\n            }\n            if (creator[i]->role) {\n                xml_ret = xmlTextWriterWriteAttributeNS(writer, BAD_CAST \"opf\", BAD_CAST \"role\", NULL, BAD_CAST creator[i]->role);\n                if (xml_ret < 0) {\n                    debug_print(\"XML error: %i (creator role: %s)\\n\", xml_ret, creator[i]->role);\n                    return MOBI_XML_ERR;\n                }\n            }\n            if (creator[i]->file_as) {\n                xml_ret = xmlTextWriterWriteAttributeNS(writer, BAD_CAST \"opf\", BAD_CAST \"file-as\", NULL, BAD_CAST creator[i]->file_as);\n                if (xml_ret < 0) {\n                    debug_print(\"XML error: %i (creator file-as: %s)\\n\", xml_ret, creator[i]->file_as);\n                    return MOBI_XML_ERR;\n                }\n            }\n            xml_ret = xmlTextWriterWriteString(writer, BAD_CAST creator[i]->value);\n            if (xml_ret < 0) {\n                debug_print(\"XML error: %i (creator value: %s)\\n\", xml_ret, creator[i]->value);\n                return MOBI_XML_ERR;\n            }\n            xml_ret = xmlTextWriterEndElement(writer);\n            if (xml_ret < 0) {\n                debug_print(\"XML error: %i (creator value: %s)\\n\", xml_ret, creator[i]->value);\n                return MOBI_XML_ERR;\n            }\n            i++;\n        }\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Write array of Dublin Core subject elements to XML buffer\n \n Wrapper for libxml2 xmlTextWriterWriteElementNS() function.\n Writes xml element for each not-null entry in the input array.\n \n @param[in,out] writer xmlTextWriterPtr to write to\n @param[in] subject OPFsubject structure representing subject element\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_xml_write_dcmeta_subject(xmlTextWriterPtr writer, const OPFsubject **subject) {\n    if (subject) {\n        size_t i = 0;\n        while (i < OPF_META_MAX_TAGS) {\n            if (subject[i] == NULL || subject[i]->value == NULL) {\n                break;\n            }\n            int xml_ret;\n            xml_ret = xmlTextWriterStartElementNS(writer, BAD_CAST \"dc\", BAD_CAST \"subject\", NULL);\n            if (xml_ret < 0) {\n                debug_print(\"XML error: %i (subject value: %s)\\n\", xml_ret, subject[i]->value);\n                return MOBI_XML_ERR;\n            }\n            if (subject[i]->basic_code) {\n                xml_ret = xmlTextWriterWriteAttribute(writer, BAD_CAST \"BASICCode\", BAD_CAST subject[i]->basic_code);\n                if (xml_ret < 0) {\n                    debug_print(\"XML error: %i (subject BASICCode: %s)\\n\", xml_ret, subject[i]->basic_code);\n                    return MOBI_XML_ERR;\n                }\n            }\n            xml_ret = xmlTextWriterWriteString(writer, BAD_CAST subject[i]->value);\n            if (xml_ret < 0) {\n                debug_print(\"XML error: %i (subject value: %s)\\n\", xml_ret, subject[i]->value);\n                return MOBI_XML_ERR;\n            }\n            xml_ret = xmlTextWriterEndElement(writer);\n            if (xml_ret < 0) {\n                debug_print(\"XML error: %i (subject value: %s)\\n\", xml_ret, subject[i]->value);\n                return MOBI_XML_ERR;\n            }\n            i++;\n        }\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Write array of Dublin Core date elements to XML buffer\n \n Wrapper for libxml2 xmlTextWriterWriteElementNS() function.\n Writes xml element for each not-null entry in the input array.\n \n @param[in,out] writer xmlTextWriterPtr to write to\n @param[in] date OPFdate structure representing date element\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_xml_write_dcmeta_date(xmlTextWriterPtr writer, const OPFdate **date) {\n    if (date) {\n        size_t i = 0;\n        while (i < OPF_META_MAX_TAGS) {\n            if (date[i] == NULL || date[i]->value == NULL) {\n                break;\n            }\n            int xml_ret;\n            xml_ret = xmlTextWriterStartElementNS(writer, BAD_CAST \"dc\", BAD_CAST \"date\", NULL);\n            if (xml_ret < 0) {\n                debug_print(\"XML error: %i (date value: %s)\\n\", xml_ret, date[i]->value);\n                return MOBI_XML_ERR;\n            }\n            if (date[i]->event) {\n                xml_ret = xmlTextWriterWriteAttributeNS(writer, BAD_CAST \"opf\", BAD_CAST \"event\", NULL, BAD_CAST date[i]->event);\n                if (xml_ret < 0) {\n                    debug_print(\"XML error: %i (date event: %s)\\n\", xml_ret, date[i]->event);\n                    return MOBI_XML_ERR;\n                }\n            }\n            xml_ret = xmlTextWriterWriteString(writer, BAD_CAST date[i]->value);\n            if (xml_ret < 0) {\n                debug_print(\"XML error: %i (date value: %s)\\n\", xml_ret, date[i]->value);\n                return MOBI_XML_ERR;\n            }\n            xml_ret = xmlTextWriterEndElement(writer);\n            if (xml_ret < 0) {\n                debug_print(\"XML error: %i (date value: %s)\\n\", xml_ret, date[i]->value);\n                return MOBI_XML_ERR;\n            }\n            i++;\n        }\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Write array of custom srp elements to XML buffer\n \n Wrapper for libxml2 xmlTextWriterWriteElementNS() function.\n Writes xml element for each not-null entry in the input array.\n \n @param[in,out] writer xmlTextWriterPtr to write to\n @param[in] srp OPFsrp structure representing srp element\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_xml_write_xmeta_srp(xmlTextWriterPtr writer, const OPFsrp **srp) {\n    if (srp) {\n        size_t i = 0;\n        while (i < OPF_META_MAX_TAGS) {\n            if (srp[i] == NULL || srp[i]->value == NULL) {\n                break;\n            }\n            int xml_ret;\n            xml_ret = xmlTextWriterStartElement(writer, BAD_CAST \"srp\");\n            if (xml_ret < 0) {\n                debug_print(\"XML error: %i (srp value: %s)\\n\", xml_ret, srp[i]->value);\n                return MOBI_XML_ERR;\n            }\n            if (srp[i]->currency) {\n                xml_ret = xmlTextWriterWriteAttribute(writer, BAD_CAST \"currency\", BAD_CAST srp[i]->currency);\n                if (xml_ret < 0) {\n                    debug_print(\"XML error: %i (srp currency: %s)\\n\", xml_ret, srp[i]->currency);\n                    return MOBI_XML_ERR;\n                }\n            }\n            xml_ret = xmlTextWriterWriteString(writer, BAD_CAST srp[i]->value);\n            if (xml_ret < 0) {\n                debug_print(\"XML error: %i (srp value: %s)\\n\", xml_ret, srp[i]->value);\n                return MOBI_XML_ERR;\n            }\n            xml_ret = xmlTextWriterEndElement(writer);\n            if (xml_ret < 0) {\n                debug_print(\"XML error: %i (srp value: %s)\\n\", xml_ret, srp[i]->value);\n                return MOBI_XML_ERR;\n            }\n            i++;\n        }\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Free array of OPF sturcture members\n \n @param[in] array Array\n */\nvoid mobi_free_opf_array(char **array) {\n    if (array) {\n        size_t i = 0;\n        while (i < OPF_META_MAX_TAGS) {\n            if (array[i] == NULL) {\n                break;\n            }\n            free(array[i]);\n            i++;\n        }\n        free(array);\n    }\n}\n\n/**\n @brief Macro to free generic OPF structure with two members\n \n @param[in] struct_array Structure name\n @param[in] struct_member1 Structure member 1\n @param[in] struct_member2 Structure member 2\n */\n#define mobi_free_opf_struct_2el(struct_array, struct_member1, struct_member2) { \\\n    if (struct_array) { \\\n        size_t i = 0; \\\n        while (i < OPF_META_MAX_TAGS) { \\\n            if (struct_array[i] == NULL) { \\\n                break; \\\n            } \\\n            free(struct_array[i]->struct_member1); \\\n            free(struct_array[i]->struct_member2); \\\n            free(struct_array[i]); \\\n            i++; \\\n        } \\\n        free(struct_array); \\\n    } \\\n}\n\n/**\n @brief Macro to free generic OPF structure with three members\n \n @param[in] struct_array Structure name\n @param[in] struct_member1 Structure member 1\n @param[in] struct_member2 Structure member 2\n @param[in] struct_member3 Structure member 3\n */\n#define mobi_free_opf_struct_3el(struct_array, struct_member1, struct_member2, struct_member3) { \\\n    if (struct_array) { \\\n        size_t i = 0; \\\n        while (i < OPF_META_MAX_TAGS) { \\\n            if (struct_array[i] == NULL) { \\\n                break; \\\n            } \\\n            free(struct_array[i]->struct_member1); \\\n            free(struct_array[i]->struct_member2); \\\n            free(struct_array[i]->struct_member3); \\\n            free(struct_array[i]); \\\n            i++; \\\n        } \\\n        free(struct_array); \\\n    } \\\n}\n\n/**\n @brief Free OPF metadata structure and data\n \n @param[in] metadata OPF opf->metadata structure\n */\nvoid mobi_free_opf_metadata(OPFmetadata *metadata) {\n    if (metadata) {\n        /* <meta/> */\n        mobi_free_opf_struct_2el(metadata->meta, name, content);\n        /* <dc-metadata/> */\n        mobi_free_opf_struct_3el(metadata->dc_meta->contributor, value, file_as, role);\n        mobi_free_opf_struct_3el(metadata->dc_meta->creator, value, file_as, role);\n        mobi_free_opf_struct_3el(metadata->dc_meta->identifier, value, id, scheme);\n        mobi_free_opf_struct_2el(metadata->dc_meta->subject, value, basic_code);\n        mobi_free_opf_struct_2el(metadata->dc_meta->date, value, event);\n        mobi_free_opf_array(metadata->dc_meta->description);\n        mobi_free_opf_array(metadata->dc_meta->language);\n        mobi_free_opf_array(metadata->dc_meta->publisher);\n        mobi_free_opf_array(metadata->dc_meta->rights);\n        mobi_free_opf_array(metadata->dc_meta->source);\n        mobi_free_opf_array(metadata->dc_meta->title);\n        mobi_free_opf_array(metadata->dc_meta->type);\n        free(metadata->dc_meta);\n        /* <x-metadata/> */\n        mobi_free_opf_struct_2el(metadata->x_meta->srp, value, currency);\n        mobi_free_opf_array(metadata->x_meta->adult);\n        mobi_free_opf_array(metadata->x_meta->default_lookup_index);\n        mobi_free_opf_array(metadata->x_meta->dict_short_name);\n        mobi_free_opf_array(metadata->x_meta->dictionary_in_lang);\n        mobi_free_opf_array(metadata->x_meta->dictionary_out_lang);\n        mobi_free_opf_array(metadata->x_meta->embedded_cover);\n        mobi_free_opf_array(metadata->x_meta->imprint);\n        mobi_free_opf_array(metadata->x_meta->review);\n        free(metadata->x_meta);\n        free(metadata);\n    }\n}\n\n/**\n @brief Free OPFmanifest structure and data\n \n @param[in] manifest OPF opf->manifest structure\n */\nvoid mobi_free_opf_manifest(OPFmanifest *manifest) {\n    if (manifest) {\n        mobi_free_opf_struct_3el(manifest->item, id, href, media_type);\n        free(manifest);\n    }\n}\n\n/**\n @brief Free OPFspine structure and data\n \n @param[in] spine OPF opf->spine structure\n */\nvoid mobi_free_opf_spine(OPFspine *spine) {\n    if (spine) {\n        mobi_free_opf_array(spine->itemref);\n        free(spine->toc);\n        free(spine);\n    }\n}\n\n/**\n @brief Free OPFguide structure and data\n \n @param[in] guide OPF opf->guide structure\n */\nvoid mobi_free_opf_guide(OPFguide *guide) {\n    if (guide) {\n        mobi_free_opf_struct_3el(guide->reference, type, title, href);\n        free(guide);\n    }\n}\n\n/**\n @brief Free OPF structure and data\n \n @param[in] opf OPF structure\n */\nvoid mobi_free_opf(OPF *opf) {\n    mobi_free_opf_metadata(opf->metadata);\n    mobi_free_opf_manifest(opf->manifest);\n    mobi_free_opf_spine(opf->spine);\n    mobi_free_opf_guide(opf->guide);\n}\n\n/**\n @brief Recreate OPF structure\n \n This function will fill OPF structure with parsed index data and convert it to xml file. The file will be stored in MOBIRawml structure.\n \n @param[in,out] rawml OPF xml file will be appended to rawml->markup linked list\n @param[in] m MOBIData structure containing document metadata\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_build_opf(MOBIRawml *rawml, const MOBIData *m) {\n    debug_print(\"Reconstructing opf%s\", \"\\n\");\n    /* initialize libXML2 */\n    LIBXML_TEST_VERSION\n    /* initialize OPF structure */\n    OPF opf = {\n        .metadata = NULL,\n        .manifest = NULL,\n        .guide = NULL,\n        .spine = NULL\n    };\n    MOBI_RET ret = mobi_build_opf_metadata(&opf, m, rawml);\n    if (ret != MOBI_SUCCESS) {\n        mobi_free_opf(&opf);\n        return ret;\n    }\n    mobi_build_ncx(rawml, &opf);\n    if (rawml->guide) {\n        ret = mobi_build_opf_guide(&opf, rawml);\n        if (ret != MOBI_SUCCESS) {\n            mobi_free_opf(&opf);\n            return ret;\n        }\n    }\n\n    /* build OPF xml document */\n    int xml_ret;\n    const xmlChar * OPFNamespace = BAD_CAST \"http://www.idpf.org/2007/opf\";\n    const xmlChar * DCNamespace = BAD_CAST \"http://purl.org/dc/elements/1.1/\";\n    xmlBufferPtr buf = xmlBufferCreate();\n    if (buf == NULL) {\n        mobi_free_opf(&opf);\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    xmlTextWriterPtr writer = xmlNewTextWriterMemory(buf, 0);\n    if (writer == NULL) {\n        xmlBufferFree(buf);\n        mobi_free_opf(&opf);\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    xmlTextWriterSetIndent(writer, 1);\n    xml_ret = xmlTextWriterStartDocument(writer, NULL, NULL, NULL);\n    if (xml_ret < 0) { goto cleanup; }\n    /* <package/> */\n    xml_ret = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST \"package\", OPFNamespace);\n    if (xml_ret < 0) { goto cleanup; }\n    xml_ret = xmlTextWriterWriteAttribute(writer, BAD_CAST \"version\", BAD_CAST \"2.0\");\n    if (xml_ret < 0) { goto cleanup; }\n    xml_ret = xmlTextWriterWriteAttribute(writer, BAD_CAST \"unique-identifier\", BAD_CAST \"uid\");\n    if (xml_ret < 0) { goto cleanup; }\n    /* <metadata /> */\n    xml_ret = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST \"metadata\", NULL);\n    if (xml_ret < 0) { goto cleanup; }\n    /* <dc-metadata/> */\n    //xml_ret = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST \"dc-metadata\", NULL);\n    //if (xml_ret < 0) { goto cleanup; }\n    xml_ret = xmlTextWriterWriteAttributeNS(writer, BAD_CAST \"xmlns\", BAD_CAST \"opf\", NULL, OPFNamespace);\n    if (xml_ret < 0) { goto cleanup; }\n    xml_ret = xmlTextWriterWriteAttributeNS(writer, BAD_CAST \"xmlns\", BAD_CAST \"dc\", NULL, DCNamespace);\n    if (xml_ret < 0) { goto cleanup; }\n    /* Dublin Core elements */\n    OPFdcmeta *dc_meta = opf.metadata->dc_meta;\n    ret = mobi_xml_write_dcmeta(writer, \"title\", (const char **) dc_meta->title);\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    ret = mobi_xml_write_dcmeta(writer, \"description\", (const char **) dc_meta->description);\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    ret = mobi_xml_write_dcmeta(writer, \"language\", (const char **) dc_meta->language);\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    ret = mobi_xml_write_dcmeta(writer, \"publisher\", (const char **) dc_meta->publisher);\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    ret = mobi_xml_write_dcmeta(writer, \"rights\", (const char **) dc_meta->rights);\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    ret = mobi_xml_write_dcmeta(writer, \"source\", (const char **) dc_meta->source);\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    ret = mobi_xml_write_dcmeta(writer, \"type\", (const char **) dc_meta->type);\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    ret = mobi_xml_write_dcmeta_identifier(writer, (const OPFidentifier **) dc_meta->identifier);\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    ret = mobi_xml_write_dcmeta_creator(writer, (const OPFcreator **) dc_meta->creator, \"creator\");\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    ret = mobi_xml_write_dcmeta_creator(writer, (const OPFcreator **) dc_meta->contributor, \"contributor\");\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    ret = mobi_xml_write_dcmeta_subject(writer, (const OPFsubject **) dc_meta->subject);\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    ret = mobi_xml_write_dcmeta_date(writer, (const OPFdate **) dc_meta->date);\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    //xml_ret = xmlTextWriterEndElement(writer);\n    //if (xml_ret < 0) { goto cleanup; }\n    /* <x-metadata/> */\n    //xml_ret = xmlTextWriterStartElement(writer, BAD_CAST \"x-metadata\");\n    //if (xml_ret < 0) { goto cleanup; }\n    OPFxmeta *x_meta = opf.metadata->x_meta;\n    /* custom elements */\n    ret = mobi_xml_write_xmeta_srp(writer, (const OPFsrp **) x_meta->srp);\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    ret = mobi_xml_write_xmeta(writer, \"adult\", (const char **) x_meta->adult);\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    ret = mobi_xml_write_xmeta(writer, \"DefaultLookupIndex\", (const char **) x_meta->default_lookup_index);\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    ret = mobi_xml_write_xmeta(writer, \"DictionaryVeryShortName\", (const char **) x_meta->dict_short_name);\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    ret = mobi_xml_write_xmeta(writer, \"DictionaryInLanguage\", (const char **) x_meta->dictionary_in_lang);\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    ret = mobi_xml_write_xmeta(writer, \"DictionaryOutLanguage\", (const char **) x_meta->dictionary_out_lang);\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    ret = mobi_xml_write_xmeta(writer, \"EmbeddedCover\", (const char **) x_meta->embedded_cover);\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    ret = mobi_xml_write_xmeta(writer, \"imprint\", (const char **) x_meta->imprint);\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    ret = mobi_xml_write_xmeta(writer, \"review\", (const char **) x_meta->review);\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    /* <meta/> */\n    ret = mobi_xml_write_opfmeta(writer, (const OPFmeta **) opf.metadata->meta);\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    //xml_ret = xmlTextWriterEndElement(writer);\n    //if (xml_ret < 0) { goto cleanup; }\n    xml_ret = xmlTextWriterEndElement(writer);\n    if (xml_ret < 0) { goto cleanup; }\n    /* <manifest/> */\n    xml_ret = xmlTextWriterStartElement(writer, BAD_CAST \"manifest\");\n    if (xml_ret < 0) { goto cleanup; }\n    ret = mobi_xml_write_manifest(writer, rawml);\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    xml_ret = xmlTextWriterEndElement(writer);\n    if (xml_ret < 0) { goto cleanup; }\n    /* <spine/> */\n    ret = mobi_xml_write_spine(writer, rawml);\n    if (ret != MOBI_SUCCESS) { goto cleanup; }\n    /* <guide/> */\n    if (opf.guide) {\n        xml_ret = xmlTextWriterStartElement(writer, BAD_CAST \"guide\");\n        if (xml_ret < 0) { goto cleanup; }\n        ret = mobi_xml_write_reference(writer, (const OPFreference **) opf.guide->reference);\n        if (ret != MOBI_SUCCESS) { goto cleanup; }\n        xml_ret = xmlTextWriterEndElement(writer);\n        if (xml_ret < 0) { goto cleanup; }\n    }\n    xml_ret = xmlTextWriterEndDocument(writer);\n    if (xml_ret < 0) { goto cleanup; }\n    \n    xmlFreeTextWriter(writer);\n    const char *opf_xml = (const char *) buf->content;\n    mobi_opf_add_to_rawml(opf_xml, rawml);\n    xmlBufferFree(buf);\n    mobi_free_opf(&opf);\n    /* cleanup function for the XML library */\n    xmlCleanupParser();\n    return MOBI_SUCCESS;\n    \ncleanup:\n    xmlFreeTextWriter(writer);\n    xmlBufferFree(buf);\n    mobi_free_opf(&opf);\n    xmlCleanupParser();\n    debug_print(\"%s\\n\", \"XML writing failed\");\n    return MOBI_XML_ERR;\n}\n", "/** @file util.c\n *  @brief Various helper functions\n *\n * Copyright (c) 2014 Bartek Fabiszewski\n * http://www.fabiszewski.net\n *\n * This file is part of libmobi.\n * Licensed under LGPL, either version 3, or any later.\n * See <http://www.gnu.org/licenses/>\n */\n\n#define _GNU_SOURCE 1\n#ifndef __USE_BSD\n#define __USE_BSD /* for strdup on linux/glibc */\n#endif\n\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include \"util.h\"\n#include \"parse_rawml.h\"\n#include \"index.h\"\n#include \"debug.h\"\n\n#ifdef USE_ENCRYPTION\n#include \"encryption.h\"\n#endif\n\n#ifdef USE_XMLWRITER\n#include \"opf.h\"\n#endif\n\n#define MOBI_FONT_OBFUSCATED_BUFFER_COUNT 52\n\n/** @brief Lookup table for cp1252 to utf8 encoding conversion */\nstatic const unsigned char cp1252_to_utf8[32][3] = {\n    {0xe2,0x82,0xac},\n    {0},\n    {0xe2,0x80,0x9a},\n    {0xc6,0x92,0},\n    {0xe2,0x80,0x9e},\n    {0xe2,0x80,0xa6},\n    {0xe2,0x80,0xa0},\n    {0xe2,0x80,0xa1},\n    {0xcb,0x86,0},\n    {0xe2,0x80,0xb0},\n    {0xc5,0xa0,0},\n    {0xe2,0x80,0xb9},\n    {0xc5,0x92,0},\n    {0},\n    {0xc5,0xbd,0},\n    {0},\n    {0},\n    {0xe2,0x80,0x98},\n    {0xe2,0x80,0x99},\n    {0xe2,0x80,0x9c},\n    {0xe2,0x80,0x9d},\n    {0xe2,0x80,0xa2},\n    {0xe2,0x80,0x93},\n    {0xe2,0x80,0x94},\n    {0xcb,0x9c,0},\n    {0xe2,0x84,0xa2},\n    {0xc5,0xa1,0},\n    {0xe2,0x80,0xba},\n    {0xc5,0x93,0},\n    {0},\n    {0xc5,0xbe,0},\n    {0xc5,0xb8,0},\n};\n\n/**\n @brief Get libmobi version\n\n @return String version\n */\nconst char * mobi_version(void) {\n#ifndef PACKAGE_VERSION\n# define PACKAGE_VERSION \"unknown\"\n#endif\n    return PACKAGE_VERSION;\n}\n\n/**\n @brief Convert unicode codepoint to utf-8 sequence\n \n @param[in,out] output Output string\n @param[in] codepoint Unicode codepoint\n @return Length of utf-8 sequence (maximum 4 bytes), zero on failure\n */\nuint8_t mobi_unicode_to_utf8(char *output, const size_t codepoint) {\n    if (!output) {\n        return 0;\n    }\n    unsigned char *bytes = (unsigned char *) output;\n    \n    if (codepoint < 0x80) {\n        bytes[0] = (unsigned char) codepoint;\n        return 1;\n    }\n    if (codepoint < 0x800) {\n        bytes[1] = (unsigned char) ((2 << 6) | (codepoint & 0x3f));\n        bytes[0] = (unsigned char) ((6 << 5) | (codepoint >> 6));\n        return 2;\n    }\n    if (codepoint < 0x10000) {\n        bytes[2] = (unsigned char) ((2 << 6) | (codepoint & 0x3f));\n        bytes[1] = (unsigned char) ((2 << 6) | ((codepoint >> 6) & 0x3f));\n        bytes[0] = (unsigned char) ((14 << 4) | (codepoint >> 12));\n        return 3;\n    }\n    if (codepoint < 0x11000) {\n        bytes[3] = (unsigned char) ((2 << 6) | (codepoint & 0x3f));\n        bytes[2] = (unsigned char) ((2 << 6) | ((codepoint >> 6) & 0x3f));\n        bytes[1] = (unsigned char) ((2 << 6) | ((codepoint >> 12) & 0x3f));\n        bytes[0] = (unsigned char) ((30 << 3) | (codepoint >> 18));\n        return 4;\n    }\n    return 0;\n}\n\n/**\n @brief Convert cp1252 encoded string to utf-8\n \n Maximum length of output string is 3 * (input string length) + 1\n Output string will be null terminated (even if truncated)\n \n @param[in,out] output Output string\n @param[in,out] input Input string\n @param[in,out] outsize Size of the allocated output buffer, will be set to output string length (without null terminator) on return\n @param[in] insize Length of the input string.\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_cp1252_to_utf8(char *output, const char *input, size_t *outsize, const size_t insize) {\n    if (!output || !input) {\n        return MOBI_PARAM_ERR;\n    }\n    const unsigned char *in = (unsigned char *) input;\n    unsigned char *out = (unsigned char *) output;\n    const unsigned char *outend = out + *outsize - 1; /* leave space for null terminator */\n    const unsigned char *inend = in + insize;\n    while (in < inend && out < outend && *in) {\n        if (*in < 0x80) {\n           *out++ = *in++;\n        }\n        else if (*in < 0xa0) {\n            /* table lookup */\n            size_t i = 0;\n            while (i < 3 && out < outend) {\n                unsigned char c = cp1252_to_utf8[*in - 0x80][i];\n                if (c == 0) {\n                    break;\n                }\n                *out++ = c;\n                i++;\n            }\n            if (i == 0) {\n                /* unmappable character in input */\n                /* substitute with utf-8 replacement character */\n                if (out >= outend - 1) { break; }\n                *out++ = 0xff;\n                *out++ = 0xfd;\n                debug_print(\"Invalid character found: %c\\n\", *in);\n            }\n            in++;\n        }\n        else if (*in < 0xc0) {\n            if (out >= outend - 1) { break; }\n            *out++ = 0xc2;\n            *out++ = *in++;\n        }\n        else {\n            if (out >= outend - 1) { break; }\n            *out++ = 0xc3;\n            *out++ = (*in++ & 0x3f) + 0x80;\n        }\n    }\n    *out = '\\0';\n    *outsize = (size_t) (out - (unsigned char *) output);\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Convert utf-8 encoded string to cp1252\n \n Characters out of range will be replaced with substitute character\n \n @param[in,out] output Output string\n @param[in,out] input Input string\n @param[in,out] outsize Size of the allocated output buffer, will be set to output string length (without null terminator) on return\n @param[in] insize Length of the input string.\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_utf8_to_cp1252(char *output, const char *input, size_t *outsize, const size_t insize) {\n    if (!output || !input) {\n        return MOBI_PARAM_ERR;\n    }\n    const unsigned char *in = (unsigned char *) input;\n    unsigned char *out = (unsigned char *) output;\n    const unsigned char *outend = out + *outsize - 1; /* leave space for null terminator */\n    const unsigned char *inend = in + insize;\n    while (in < inend && out < outend && *in) {\n        /* one byte */\n        if (*in < 0x80) {\n            *out++ = *in++;\n        }\n        /* two bytes */\n        else if ((*in & 0xe0) == 0xc0) {\n            if (in > inend - 2) { break; }\n            if (in[0] == 0xc2 && (in[1] >= 0xa0 && in[1] <= 0xbf)) {\n                *out++ = in[1];\n            } else if (in[0] == 0xc3 && (in[1] >= 0x80 && in[1] <= 0xbf)) {\n                *out++ = in[1] + 0x40;\n            } else if (in[0] == 0xc5) {\n                switch (in[1]) {\n                    case 0xa0:\n                        *out++ = 0x8a;\n                        break;\n                    case 0x92:\n                        *out++ = 0x8c;\n                        break;\n                    case 0xbd:\n                        *out++ = 0x8e;\n                        break;\n                    case 0xa1:\n                        *out++ = 0x9a;\n                        break;\n                    case 0x93:\n                        *out++ = 0x9c;\n                        break;\n                    case 0xbe:\n                        *out++ = 0x9e;\n                        break;\n                    case 0xb8:\n                        *out++ = 0x9f;\n                        break;\n                    default:\n                        *out++ = '?';\n                        break;\n                }\n            } else if (in[0] == 0xc6 && in[1] == 0x92) {\n                *out++ = 0x83;\n            } else if (in[0] == 0xcb && in[1] == 0x86) {\n                *out++ = 0x88;\n            } else {\n                *out++ = '?';\n            }\n            in += 2;\n        }\n        /* three bytes */\n        else if ((*in & 0xf0) == 0xe0) {\n            if (in > inend - 3) { break; }\n            if (in[0] == 0xe2 && in[1] == 0x80) {\n                switch (in[2]) {\n                    case 0x9a:\n                        *out++ = 0x82;\n                        break;\n                    case 0x9e:\n                        *out++ = 0x84;\n                        break;\n                    case 0xa6:\n                        *out++ = 0x85;\n                        break;\n                    case 0xa0:\n                        *out++ = 0x86;\n                        break;\n                    case 0xb0:\n                        *out++ = 0x89;\n                        break;\n                    case 0xb9:\n                        *out++ = 0x8b;\n                        break;\n                    case 0x98:\n                        *out++ = 0x91;\n                        break;\n                    case 0x99:\n                        *out++ = 0x92;\n                        break;\n                    case 0x9c:\n                        *out++ = 0x93;\n                        break;\n                    case 0x9d:\n                        *out++ = 0x94;\n                        break;\n                    case 0xa2:\n                        *out++ = 0x95;\n                        break;\n                    case 0x93:\n                        *out++ = 0x86;\n                        break;\n                    case 0x94:\n                        *out++ = 0x97;\n                        break;\n                    case 0xba:\n                        *out++ = 0x9b;\n                        break;\n                    default:\n                        *out++ = '?';\n                        break;\n                }\n            } else if (in[0] == 0xe2 && in[1] == 0x82 && in[2] == 0xac) {\n                *out++ = 0x80;\n            } else if (in[0] == 0xe2 && in[1] == 0x84 && in[2] == 0xa2) {\n                *out++ = 0x99;\n            } else {\n                *out++ = '?';\n            }\n            in += 3;\n        }\n        /* four bytes */\n        else if ((*in & 0xf8) == 0xf0) {\n            if (in > inend - 4) { break; }\n            *out++ = '?';\n            in += 4;\n        }\n        /* skip error */\n        else {\n            *out++ = '?';\n            in++;\n        }\n    }\n    *out = '\\0';\n    *outsize = (size_t) (out - (unsigned char *) output);\n    return MOBI_SUCCESS;\n}\n\n/** @brief Decode ligature to cp1252\n \n Some latin ligatures are encoded in indices to facilitate search\n They are listed in LIGT header, but it seems every LIGT header contains\n same 5 ligatures (even if not all of them are used).\n So, instead of parsing header, we use static replacements.\n Invalid control characters are skipped\n \n @param[in] byte1 First byte - control character\n @param[in] byte2 Second byte of the ligature\n @return Ligature in cp1252 encoding, zero if not found\n */\nuint8_t mobi_ligature_to_cp1252(const uint8_t byte1, const uint8_t byte2) {\n    uint8_t ligature = 0;\n    const uint8_t lig_OE = 0x8c;\n    const uint8_t lig_oe = 0x9c;\n    const uint8_t lig_AE = 0xc6;\n    const uint8_t lig_ae = 0xe6;\n    const uint8_t lig_ss = 0xdf;\n    switch (byte1) {\n        case 1:\n            if (byte2 == 0x45) { ligature = lig_OE; }\n            break;\n        case 2:\n            if (byte2 == 0x65) { ligature = lig_oe; }\n            break;\n        case 3:\n            if (byte2 == 0x45) { ligature = lig_AE; }\n            break;\n        case 4:\n            if (byte2 == 0x65) { ligature = lig_ae; }\n            break;\n        case 5:\n            if (byte2 == 0x73) { ligature = lig_ss; }\n            break;\n    }\n    return ligature;\n}\n\n/** @brief Decode ligature to utf-16\n \n @param[in] byte1 First byte - control character, should be <= 5\n @param[in] byte2 Second byte of the ligature\n @return Ligature in utf-16 encoding, uni_replacement if not found\n */\nuint16_t mobi_ligature_to_utf16(const uint32_t byte1, const uint32_t byte2) {\n    const uint16_t uni_replacement = 0xfffd;\n    uint16_t ligature = uni_replacement;\n    const uint16_t lig_OE = 0x152;\n    const uint16_t lig_oe = 0x153;\n    const uint16_t lig_AE = 0xc6;\n    const uint16_t lig_ae = 0xe6;\n    const uint16_t lig_ss = 0xdf;\n    switch (byte1) {\n        case 1:\n            if (byte2 == 0x45) { ligature = lig_OE; }\n            break;\n        case 2:\n            if (byte2 == 0x65) { ligature = lig_oe; }\n            break;\n        case 3:\n            if (byte2 == 0x45) { ligature = lig_AE; }\n            break;\n        case 4:\n            if (byte2 == 0x65) { ligature = lig_ae; }\n            break;\n        case 5:\n            if (byte2 == 0x73) { ligature = lig_ss; }\n            break;\n    }\n    return ligature;\n}\n\n/** @brief Get text encoding of mobi document\n \n @param[in] m MOBIData structure holding document data and metadata\n @return MOBIEncoding text encoding (MOBI_UTF8 or MOBI_CP1252)\n */\nMOBIEncoding mobi_get_encoding(const MOBIData *m) {\n    if (m && m->mh) {\n        if (m->mh->text_encoding) {\n            if (*m->mh->text_encoding == MOBI_UTF8) {\n                return MOBI_UTF8;\n            }\n        }\n    }\n    return MOBI_CP1252;\n}\n\n/** @brief Check if document's text is cp1252 encoded\n \n @param[in] m MOBIData structure holding document data and metadata\n @return True or false\n */\nbool mobi_is_cp1252(const MOBIData *m) {\n    return (mobi_get_encoding(m) == MOBI_CP1252);\n}\n\n/**\n @brief strdup replacement\n \n Returned pointer must be freed by caller\n \n @param[in] s Input string\n @return Duplicated string\n */\nchar * mobi_strdup(const char *s) {\n    char *p = malloc(strlen(s) + 1);\n    if (p) { strcpy(p, s); }\n    return p;\n}\n\n#define MOBI_LANG_MAX 99 /**< number of entries in mobi_locale array */\n#define MOBI_REGION_MAX 21 /**< maximum number of entries in each language array */\n\n/**< @brief Table of Mobipocket language-region codes\n \n Based on IANA language-subtag registry with some custom Mobipocket modifications.\n http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry\n */\nstatic const char *mobi_locale[MOBI_LANG_MAX][MOBI_REGION_MAX] = {\n    {\"neutral\"},\n    {\n    \"ar\", /**< Arabic >*/\n    \"ar-sa\", /**< Arabic (Saudi Arabia) >*/\n    \"ar\", /**< Arabic (Unknown) */\n    \"ar-eg\", /**< Arabic (Egypt) >*/\n    \"ar\", /**< Arabic (Unknown) */\n    \"ar-dz\", /**< Arabic (Algeria) >*/\n    \"ar-ma\", /**< Arabic (Morocco) >*/\n    \"ar-tn\", /**< Arabic (Tunisia) >*/\n    \"ar-om\", /**< Arabic (Oman) >*/\n    \"ar-ye\", /**< Arabic (Yemen) >*/\n    \"ar-sy\", /**< Arabic (Syria) >*/\n    \"ar-jo\", /**< Arabic (Jordan) >*/\n    \"ar-lb\", /**< Arabic (Lebanon) >*/\n    \"ar-kw\", /**< Arabic (Kuwait) >*/\n    \"ar-ae\", /**< Arabic (UAE) >*/\n    \"ar-bh\", /**< Arabic (Bahrain) >*/\n    \"ar-qa\", /**< Arabic (Qatar) >*/\n    },\n    {\"bg\"}, /**< Bulgarian >*/\n    {\"ca\"}, /**< Catalan >*/\n    {\n    \"zh\", /**< Chinese >*/\n    \"zh-tw\", /**< Chinese (Taiwan) >*/\n    \"zh-cn\", /**< Chinese (PRC) >*/\n    \"zh-hk\", /**< Chinese (Hong Kong) >*/\n    \"zh-sg\", /**< Chinese (Singapore) >*/\n    },\n    {\"cs\"}, /**< Czech >*/\n    {\"da\"}, /**< Danish >*/\n    {\n    \"de\", /**< German >*/\n    \"de-de\", /**< German (Germany) >*/\n    \"de-ch\", /**< German (Switzerland) >*/\n    \"de-at\", /**< German (Austria) >*/\n    \"de-lu\", /**< German (Luxembourg) >*/\n    \"de-li\", /**< German (Liechtenstein) >*/\n    },\n    {\"el\"}, /**< Greek (modern) >*/\n    {\n    \"en\", /**< English >*/\n    \"en-us\", /**< English (United States) >*/\n    \"en-gb\", /**< English (United Kingdom) >*/\n    \"en-au\", /**< English (Australia) >*/\n    \"en-ca\", /**< English (Canada) >*/\n    \"en-nz\", /**< English (New Zealand) >*/\n    \"en-ie\", /**< English (Ireland) >*/\n    \"en-za\", /**< English (South Africa) >*/\n    \"en-jm\", /**< English (Jamaica) >*/\n    \"en\", /**< English (Unknown) >*/\n    \"en-bz\", /**< English (Belize) >*/\n    \"en-tt\", /**< English (Trinidad) >*/\n    \"en-zw\", /**< English (Zimbabwe) >*/\n    \"en-ph\", /**< English (Philippines) >*/\n    },\n    {\n    \"es\", /**< Spanish >*/\n    \"es-es\", /**< Spanish (Spain) >*/\n    \"es-mx\", /**< Spanish (Mexico) >*/\n    \"es\", /**< Spanish (Unknown) >*/\n    \"es-gt\", /**< Spanish (Guatemala) >*/\n    \"es-cr\", /**< Spanish (Costa Rica) >*/\n    \"es-pa\", /**< Spanish (Panama) >*/\n    \"es-do\", /**< Spanish (Dominican Republic) >*/\n    \"es-ve\", /**< Spanish (Venezuela) >*/\n    \"es-co\", /**< Spanish (Colombia) >*/\n    \"es-pe\", /**< Spanish (Peru) >*/\n    \"es-ar\", /**< Spanish (Argentina) >*/\n    \"es-ec\", /**< Spanish (Ecuador) >*/\n    \"es-cl\", /**< Spanish (Chile) >*/\n    \"es-uy\", /**< Spanish (Uruguay) >*/\n    \"es-py\", /**< Spanish (Paraguay) >*/\n    \"es-bo\", /**< Spanish (Bolivia) >*/\n    \"es-sv\", /**< Spanish (El Salvador) >*/\n    \"es-hn\", /**< Spanish (Honduras) >*/\n    \"es-ni\", /**< Spanish (Nicaragua) >*/\n    \"es-pr\", /**< Spanish (Puerto Rico) >*/\n    },\n    {\"fi\"}, /**< Finnish >*/\n    {\n    \"fr\", /**< French >*/\n    \"fr-fr\", /**< French (France) >*/\n    \"fr-be\", /**< French (Belgium) >*/\n    \"fr-ca\", /**< French (Canada) >*/\n    \"fr-ch\", /**< French (Switzerland) >*/\n    \"fr-lu\", /**< French (Luxembourg) >*/\n    \"fr-mc\", /**< French (Monaco) >*/\n    },\n    {\"he\"}, /**< Hebrew (also code iw) >*/\n    {\"hu\"}, /**< Hungarian >*/\n    {\"is\"}, /**< Icelandic >*/\n    {\n    \"it\", /**< Italian >*/\n    \"it-it\", /**< Italian (Italy) >*/\n    \"it-ch\", /**< Italian (Switzerland) >*/\n    },\n    {\"ja\"}, /**< Japanese >*/\n    {\"ko\"}, /**< Korean >*/\n    {\n    \"nl\", /**< Dutch / Flemish >*/\n    \"nl-nl\", /**< Dutch (Netherlands) >*/\n    \"nl-be\", /**< Dutch (Belgium) >*/\n    },\n    {\"no\"}, /**< Norwegian >*/\n    {\"pl\"}, /**< Polish >*/\n    {\n    \"pt\", /**< Portuguese >*/\n    \"pt-br\", /**< Portuguese (Brazil) >*/\n    \"pt-pt\", /**< Portuguese (Portugal) >*/\n    },\n    {\"rm\"}, /**< Romansh >*/\n    {\"ro\"}, /**< Romanian >*/\n    {\"ru\"}, /**< Russian >*/\n    {\n    \"hr\", /**< Croatian >*/\n    \"sr\", /**< Serbian >*/\n    \"sr\", /**< Serbian (Unknown) >*/\n    \"sr\", /**< Serbian (Unknown) >*/\n    \"sr\", /**< Serbian (Serbia) >*/\n    },\n    {\"sk\"}, /**< Slovak >*/\n    {\"sq\"}, /**< Albanian >*/\n    {\n    \"sv\", /**< Swedish >*/\n    \"sv-se\", /**< Swedish (Sweden) >*/\n    \"sv-fi\", /**< Swedish (Finland) >*/\n    },\n    {\"th\"}, /**< Thai >*/\n    {\"tr\"}, /**< Turkish >*/\n    {\"ur\"}, /**< Urdu >*/\n    {\"id\"}, /**< Indonesian >*/\n    {\"uk\"}, /**< Ukrainian >*/\n    {\"be\"}, /**< Belarusian >*/\n    {\"sl\"}, /**< Slovenian >*/\n    {\"et\"}, /**< Estonian >*/\n    {\"lv\"}, /**< Latvian >*/\n    {\"lt\"}, /**< Lithuanian >*/\n    [41] = {\"fa\"}, /**< Farsi / Persian >*/\n    {\"vi\"}, /**< Vietnamese >*/\n    {\"hy\"}, /**< Armenian >*/\n    {\"az\"}, /**< Azerbaijani >*/\n    {\"eu\"}, /**< Basque >*/\n    {\"sb\"}, /**< \"Sorbian\" >*/\n    {\"mk\"}, /**< Macedonian >*/\n    {\"sx\"}, /**< \"Sutu\" >*/\n    {\"ts\"}, /**< Tsonga >*/\n    {\"tn\"}, /**< Tswana >*/\n    [52] = {\"xh\"}, /**< Xhosa >*/\n    {\"zu\"}, /**< Zulu >*/\n    {\"af\"}, /**< Afrikaans >*/\n    {\"ka\"}, /**< Georgian >*/\n    {\"fo\"}, /**< Faroese >*/\n    {\"hi\"}, /**< Hindi >*/\n    {\"mt\"}, /**< Maltese >*/\n    {\"sz\"}, /**<\"Sami (Lappish)\" >*/\n    {\"ga\"}, /**< Irish */\n    [62] = {\"ms\"}, /**< Malay >*/\n    {\"kk\"}, /**< Kazakh >*/\n    [65] = {\"sw\"}, /**< Swahili >*/\n    [67] = {\n    \"uz\", /**< Uzbek >*/\n    \"uz\", /**< Uzbek (Unknown) >*/\n    \"uz-uz\", /**< Uzbek (Uzbekistan) >*/\n    },\n    {\"tt\"}, /**< Tatar >*/\n    {\"bn\"}, /**< Bengali >*/\n    {\"pa\"}, /**< Punjabi >*/\n    {\"gu\"}, /**< Gujarati >*/\n    {\"or\"}, /**< Oriya >*/\n    {\"ta\"}, /**< Tamil >*/\n    {\"te\"}, /**< Telugu >*/\n    {\"kn\"}, /**< Kannada >*/\n    {\"ml\"}, /**< Malayalam >*/\n    {\"as\"}, /**< Assamese (not accepted in kindlegen >*/\n    {\"mr\"}, /**< Marathi >*/\n    {\"sa\"}, /**< Sanskrit >*/\n    [82] = {\n    \"cy\", /**< Welsh */\n    \"cy-gb\" /**< Welsh (UK) */\n    },\n    {\n    \"gl\", /**< Galician */\n    \"gl-es\" /**< Galician (Spain) */\n    },\n    [87] = {\"x-kok\"}, /**< Konkani (real language code is kok) >*/\n    [97] = {\"ne\"}, /**< Nepali >*/\n    {\"fy\"}, /**< Northern Frysian >*/\n};\n\n/**\n @brief Get pointer to locale tag for a given Mobipocket locale number\n \n Locale strings are based on IANA language-subtag registry with some custom Mobipocket modifications.\n See mobi_locale array.\n \n @param[in] locale_number Mobipocket locale number (as stored in MOBI header)\n @return Pointer to locale string in mobi_locale array or NULL on error\n */\nconst char * mobi_get_locale_string(const uint32_t locale_number) {\n    uint8_t lang_code = locale_number & 0xffU;\n    uint32_t region_code = (locale_number >> 8) / 4;\n    if (lang_code >= MOBI_LANG_MAX || region_code >= MOBI_REGION_MAX) {\n        return NULL;\n    }\n    const char *string = mobi_locale[lang_code][region_code];\n    if (string == NULL || strlen(string) == 0 ) {\n        return NULL;\n    }\n    return string;\n}\n\n/**\n @brief Get Mobipocket locale number for a given string tag\n \n Locale strings are based on IANA language-subtag registry with some custom Mobipocket modifications. \n See mobi_locale array.\n \n @param[in] locale_string Locale string tag\n @return Mobipocket locale number\n */\nsize_t mobi_get_locale_number(const char *locale_string) {\n    if (locale_string == NULL || strlen(locale_string) < 2) {\n        return 0;\n    }\n    size_t lang_code = 0;\n    while (lang_code < MOBI_LANG_MAX) {\n        char *p = (char *) mobi_locale[lang_code][0];\n        if (p == NULL) {\n            lang_code++;\n            continue;\n        }\n        \n        if (tolower(locale_string[0]) != p[0] ||\n            tolower(locale_string[1]) != p[1]) {\n            lang_code++;\n            continue;\n        }\n        size_t region_code = 0;\n        while (region_code < MOBI_REGION_MAX) {\n            p = (char *) mobi_locale[lang_code][region_code];\n            if (p == NULL) { break; }\n            for (int i = 2;; i++) {\n                if (tolower(locale_string[i]) != p[i]) { break; }\n                if (p[i] == 0) {\n                    return (region_code * 4) << 8 | lang_code;\n                }\n            }\n            region_code++;\n        }\n        return lang_code;\n    }\n    return 0;\n}\n\n/**\n @brief Array of known file types, their extensions and mime-types.\n */\nconst MOBIFileMeta mobi_file_meta[] = {\n    {T_HTML, \"html\", \"application/xhtml+xml\"},\n    {T_CSS, \"css\", \"text/css\"},\n    {T_SVG, \"svg\", \"image/svg+xml\"},\n    {T_JPG, \"jpg\", \"image/jpeg\"},\n    {T_GIF, \"gif\", \"image/gif\"},\n    {T_PNG, \"png\", \"image/png\"},\n    {T_BMP, \"bmp\", \"image/bmp\"},\n    {T_OTF, \"otf\", \"application/vnd.ms-opentype\"},\n    {T_TTF, \"ttf\", \"application/x-font-truetype\"},\n    {T_MP3, \"mp3\", \"audio/mpeg\"},\n    {T_MPG, \"mpg\", \"video/mpeg\"},\n    {T_PDF, \"pdf\", \"application/pdf\"},\n    {T_OPF, \"opf\", \"application/oebps-package+xml\"},\n    {T_NCX, \"ncx\", \"application/x-dtbncx+xml\"},\n    /* termination struct */\n    {T_UNKNOWN, \"dat\", \"application/unknown\"}\n};\n\n/**\n @brief Get MOBIFileMeta tag structure by MOBIFiletype type\n \n @param[in] type MOBIFiletype type\n @return MOBIExthMeta structure for given type, .type = T_UNKNOWN on failure\n */\nMOBIFileMeta mobi_get_filemeta_by_type(const MOBIFiletype type) {\n    size_t i = 0;\n    while (mobi_file_meta[i].type != T_UNKNOWN) {\n        if (mobi_file_meta[i].type == type) {\n            return mobi_file_meta[i];\n        }\n        i++;\n    }\n    return mobi_file_meta[i];\n}\n\n/**\n @brief Get ebook full name stored in Record 0 at offset given in MOBI header\n \n @param[in] m MOBIData structure with loaded data\n @param[in,out] fullname Memory area to be filled with zero terminated full name string\n @param[in] len Maximum length of the string without null terminator\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_get_fullname(const MOBIData *m, char *fullname, const size_t len) {\n    if (fullname == NULL || len == 0) {\n        return MOBI_PARAM_ERR;\n    }\n    fullname[0] = '\\0';\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    if (m->mh == NULL || m->mh->full_name == NULL) {\n        return MOBI_INIT_FAILED;\n    }\n    if (mobi_is_cp1252(m)) {\n        size_t out_len = len + 1;\n        mobi_cp1252_to_utf8(fullname, m->mh->full_name, &out_len, strlen(m->mh->full_name));\n    } else {\n        strncpy(fullname, m->mh->full_name, len);\n        fullname[len] = '\\0';\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Set ebook full name stored in Record 0 at offset given in MOBI header\n \n @param[in,out] m MOBIData structure with loaded data\n @param[in] fullname Memory area to be filled with zero terminated full name string\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_set_fullname(MOBIData *m, const char *fullname) {\n    if (mobi_exists_mobiheader(m) && m->mh->full_name) {\n        size_t title_length = min(strlen(fullname), MOBI_TITLE_SIZEMAX);\n        char *new_title = malloc(title_length + 1);\n        if (new_title == NULL) {\n            return MOBI_MALLOC_FAILED;\n        }\n        if (mobi_is_cp1252(m)) {\n            size_t new_size = title_length + 1;\n            MOBI_RET ret = mobi_utf8_to_cp1252(new_title, fullname, &new_size, title_length);\n            if (ret != MOBI_SUCCESS) {\n                free(new_title);\n                return ret;\n            }\n        } else {\n            memcpy(new_title, fullname, title_length);\n            new_title[title_length] = '\\0';\n        }\n        free(m->mh->full_name);\n        m->mh->full_name = new_title;\n        if (mobi_is_hybrid(m) && mobi_exists_mobiheader(m->next) && m->next->mh->full_name) {\n            char *new_title2 = strdup(new_title);\n            if (new_title2 == NULL) {\n                return MOBI_MALLOC_FAILED;\n            }\n            free(m->next->mh->full_name);\n            m->next->mh->full_name = new_title2;\n        }\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Set palm database name\n \n @param[in,out] m MOBIData structure with loaded data\n @param[in] name Name\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_set_pdbname(MOBIData *m, const char *name) {\n    if (m == NULL || m->ph == NULL) {\n        return MOBI_INIT_FAILED;\n    }\n    char dbname[PALMDB_NAME_SIZE_MAX + 1];\n    if (mobi_is_cp1252(m)) {\n        size_t size = PALMDB_NAME_SIZE_MAX + 1;\n        MOBI_RET ret = mobi_utf8_to_cp1252(dbname, name, &size, strlen(name));\n        if (ret != MOBI_SUCCESS) {\n            return ret;\n        }\n    } else {\n        memcpy(dbname, name, PALMDB_NAME_SIZE_MAX);\n        dbname[PALMDB_NAME_SIZE_MAX] = '\\0';\n    }\n    char c;\n    int i = 0;\n    while ((c = dbname[i])) {\n        if (!isalnum(c)) {\n            c = '_';\n        }\n        m->ph->name[i++] = c;\n    }\n    m->ph->name[i] = '\\0';\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Get palm database record with given unique id\n \n @param[in] m MOBIData structure with loaded data\n @param[in] uid Unique id\n @return Pointer to MOBIPdbRecord record structure, NULL on failure\n */\nMOBIPdbRecord * mobi_get_record_by_uid(const MOBIData *m, const size_t uid) {\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return NULL;\n    }\n    if (m->rec == NULL) {\n        return NULL;\n    }\n    MOBIPdbRecord *curr = m->rec;\n    while (curr != NULL) {\n        if (curr->uid == uid) {\n            return curr;\n        }\n        curr = curr->next;\n    }\n    return NULL;\n}\n\n/**\n @brief Get rawml->markup MOBIPart part by uid\n \n @param[in] rawml MOBIRawml structure with loaded data\n @param[in] uid Unique id\n @return Pointer to MOBIPart structure, NULL on failure\n */\nMOBIPart * mobi_get_part_by_uid(const MOBIRawml *rawml, const size_t uid) {\n    if (rawml == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return NULL;\n    }\n    if (rawml->markup == NULL) {\n        return NULL;\n    }\n    MOBIPart *part = rawml->markup;\n    while (part != NULL) {\n        if (part->uid == uid) {\n            return part;\n        }\n        part = part->next;\n    }\n    return NULL;\n}\n\n/**\n @brief Get rawml->flow MOBIPart part by uid\n \n @param[in] rawml MOBIRawml structure with loaded data\n @param[in] uid Unique id\n @return Pointer to MOBIPart structure, NULL on failure\n */\nMOBIPart * mobi_get_flow_by_uid(const MOBIRawml *rawml, const size_t uid) {\n    if (rawml == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return NULL;\n    }\n    if (rawml->flow == NULL) {\n        return NULL;\n    }\n    MOBIPart *part = rawml->flow;\n    while (part != NULL) {\n        if (part->uid == uid) {\n            return part;\n        }\n        part = part->next;\n    }\n    return NULL;\n}\n\n/**\n @brief Find flow part by flow id (fid) from kindle:flow:fid link.\n Flow fid is base32 encoded part uid.\n \n @param[in] rawml Structure MOBIRawml\n @param[in] fid String four character base32 fid\n @return Pointer to MOBIPart structure, NULL on failure\n */\nMOBIPart * mobi_get_flow_by_fid(const MOBIRawml *rawml, const char *fid) {\n    /* get file number */\n    uint32_t part_id;\n    MOBI_RET ret = mobi_base32_decode(&part_id, fid);\n    if (ret != MOBI_SUCCESS) {\n        return NULL;\n    }\n    return mobi_get_flow_by_uid(rawml, part_id);\n}\n\n/**\n @brief Get MOBIPart resource record with given unique id\n \n @param[in] rawml MOBIRawml structure with loaded data\n @param[in] uid Unique id\n @return Pointer to MOBIPart resource structure, NULL on failure\n */\nMOBIPart * mobi_get_resource_by_uid(const MOBIRawml *rawml, const size_t uid) {\n    if (rawml == NULL) {\n        debug_print(\"%s\", \"Rawml structure not initialized\\n\");\n        return NULL;\n    }\n    if (rawml->resources == NULL) {\n        debug_print(\"%s\", \"Rawml structure not initialized\\n\");\n        return NULL;\n    }\n    MOBIPart *curr = rawml->resources;\n    while (curr != NULL) {\n        if (curr->uid == uid) {\n            return curr;\n        }\n        curr = curr->next;\n    }\n    return NULL;\n}\n\n/**\n @brief Find resource by flow id (fid) from kindle:embed:fid link.\n Flow fid is base32 encoded part uid.\n \n @param[in] rawml Structure MOBIRawml\n @param[in] fid String four character base32 fid\n @return Pointer to MOBIPart structure, NULL on failure\n */\nMOBIPart * mobi_get_resource_by_fid(const MOBIRawml *rawml, const char *fid) {\n    /* get file number */\n    uint32_t part_id;\n    MOBI_RET ret = mobi_base32_decode(&part_id, fid);\n    if (ret != MOBI_SUCCESS) {\n        return NULL;\n    }\n    part_id--;\n    return mobi_get_resource_by_uid(rawml, part_id);\n}\n\n/**\n @brief Get MOBIFiletype type of MOBIPart resource record with given unique id\n \n @param[in] rawml MOBIRawml structure with loaded data\n @param[in] uid Unique id\n @return Pointer to MOBIPart resource structure, NULL on failure\n */\nMOBIFiletype mobi_get_resourcetype_by_uid(const MOBIRawml *rawml, const size_t uid) {\n    if (rawml == NULL) {\n        debug_print(\"%s\", \"Rawml structure not initialized\\n\");\n        return T_UNKNOWN;\n    }\n    if (rawml->resources == NULL) {\n        debug_print(\"%s\", \"Rawml structure not initialized\\n\");\n        return T_UNKNOWN;\n    }\n    MOBIPart *curr = rawml->resources;\n    while (curr != NULL) {\n        if (curr->uid == uid) {\n            return curr->type;\n        }\n        curr = curr->next;\n    }\n    return T_UNKNOWN;\n}\n\n/**\n @brief Get palm database record with given sequential number (first record has number 0)\n \n @param[in] m MOBIData structure with loaded data\n @param[in] num Sequential number\n @return Pointer to MOBIPdbRecord record structure, NULL on failure\n */\nMOBIPdbRecord * mobi_get_record_by_seqnumber(const MOBIData *m, const size_t num) {\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return NULL;\n    }\n    if (m->rec == NULL) {\n        return NULL;\n    }\n    MOBIPdbRecord *curr = m->rec;\n    size_t i = 0;\n    while (curr != NULL) {\n        if (i++ == num) {\n            return curr;\n        }\n        curr = curr->next;\n    }\n    return NULL;\n}\n\n/**\n @brief Get palm database record with data header starting with given 4-byte magic string\n \n @param[in] m MOBIData structure with loaded data\n @param[in] magic Magic header\n @return Pointer to MOBIPdbRecord record structure, NULL if not found or on failure\n */\nMOBIPdbRecord * mobi_get_record_by_magic(const MOBIData *m, const unsigned char magic[4]) {\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return NULL;\n    }\n\n    MOBIPdbRecord *curr = m->rec;\n    while (curr != NULL) {\n        if (curr->size >= 4 && memcmp(curr->data, magic, 4) != 0) {\n            return curr;\n        }\n        curr = curr->next;\n    }\n    return NULL;\n}\n\n\n/**\n @brief Extract palm count database records starting with given sequential number from MOBIData structure\n \n Extracted records are removed from palm database.\n Number of extracted records may be less then given count, if there are not enough records in database.\n \n @param[in,out] m MOBIData structure with loaded data\n @param[in] num Sequential number\n @param[in,out] count Records count, updated with number of records effectively extracted\n @return Pointer to MOBIPdbRecord record structure, NULL if not found or on failure\n */\nMOBIPdbRecord * mobi_extract_records_by_seqnumber(MOBIData *m, const size_t num, size_t *count) {\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return NULL;\n    }\n\n    MOBIPdbRecord *root = NULL;\n    MOBIPdbRecord *prev = NULL;\n    MOBIPdbRecord *curr = NULL;\n    if (num > 0) {\n        root = mobi_get_record_by_seqnumber(m, num - 1);\n        if (root) {\n            curr = root->next;\n        }\n    } else {\n        curr = m->rec;\n    }\n        \n    MOBIPdbRecord *extracted = curr;\n\n    size_t i = 0;\n    while (curr != NULL && i < *count) {\n        i++;\n        prev = curr;\n        curr = curr->next;\n    }\n    \n    if (prev == NULL) {\n        return NULL;\n    }\n    \n    if (root == NULL) {\n        m->rec = prev->next;\n    } else {\n        root->next = prev->next;\n    }\n    prev->next = NULL;\n    \n    *count = i;\n    if (m->ph->rec_count >= i) {\n        m->ph->rec_count -= i;\n    } else {\n        debug_print(\"%s\\n\", \"Real record count differs from header value\");\n        m->ph->rec_count = 0;\n    }\n\n    debug_print(\"Extracted %zu records starting with index = %zu\\n\", *count, num);\n\n    return extracted;\n}\n\n\n/**\n @brief Insert palm database records at given sequential number\n \n @param[in,out] m MOBIData structure with loaded data\n @param[in,out] record Linked list of records\n @param[in] num Sequential number\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_insert_records_by_seqnumber(MOBIData *m, MOBIPdbRecord *record, const size_t num) {\n    if (m == NULL || m->rec == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    if (record == NULL) {\n        return MOBI_SUCCESS;\n    }\n    \n    MOBIPdbRecord *curr = record;\n    size_t count = 1;\n    while (curr->next != NULL) {\n        curr = curr->next;\n        count++;\n    }\n    \n    if (m->ph->rec_count + count > UINT16_MAX) {\n        debug_print(\"%s\", \"Number of records beyond database limit\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    \n    MOBIPdbRecord *next = NULL;\n    if (num == 0) {\n        next = m->rec;\n        m->rec = record;\n    } else {\n        MOBIPdbRecord *prev = mobi_get_record_by_seqnumber(m, num - 1);\n        if (prev == NULL) {\n            debug_print(\"%s\", \"Insert point not found\\n\");\n            return MOBI_DATA_CORRUPT;\n        }\n        next = prev->next;\n        prev->next = record;\n    }\n    curr->next = next;\n    m->ph->rec_count += count;\n\n    debug_print(\"Inserted %zu records at index = %zu\\n\", count, num);\n        \n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Delete palm count database records starting with given sequential number from MOBIData structure\n \n Number of deleted records may be less then given count, if there are not enough records in database.\n \n @param[in,out] m MOBIData structure with loaded data\n @param[in] num Sequential number\n @param[in,out] count  Records count, updated wth number of records effectively extracted\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_delete_records_by_seqnumber(MOBIData *m, const size_t num, size_t *count) {\n    \n    // extract records\n    MOBIPdbRecord *curr = mobi_extract_records_by_seqnumber(m, num, count);\n\n    // delete them\n    while (curr != NULL) {\n        MOBIPdbRecord *tmp = curr;\n        curr = curr->next;\n        free(tmp->data);\n        free(tmp);\n        tmp = NULL;\n    }\n    \n    debug_print(\"Deleted %zu records starting with index = %zu\\n\", *count, num);\n\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Delete palm database record with given sequential number from MOBIData structure\n \n @param[in,out] m MOBIData structure with loaded data\n @param[in] num Sequential number\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_delete_record_by_seqnumber(MOBIData *m, const size_t num) {\n    size_t count = 1;\n    return mobi_delete_records_by_seqnumber(m, num, &count);\n}\n\n/**\n @brief Get EXTH record with given MOBIExthTag tag\n \n @param[in] m MOBIData structure with loaded data\n @param[in] tag MOBIExthTag EXTH record tag\n @return Pointer to MOBIExthHeader record structure\n */\nMOBIExthHeader * mobi_get_exthrecord_by_tag(const MOBIData *m, const MOBIExthTag tag) {\n    debug_print(\"Loading EXTH record with tag %i\\n\", tag);\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return NULL;\n    }\n    if (m->eh == NULL) {\n        return NULL;\n    }\n    MOBIExthHeader *curr = m->eh;\n    while (curr != NULL) {\n        if (curr->tag == tag) {\n            return curr;\n        }\n        curr = curr->next;\n    }\n    return NULL;\n}\n\n/**\n @brief Get EXTH record with given MOBIExthTag tag. Start list search at given record.\n \n If start_tag is NULL search will start from the root of the linked list.\n After successfull search start will be set to next record in the list.\n \n @param[in] m MOBIData structure with loaded data\n @param[in] tag MOBIExthTag EXTH record tag\n @param[in,out] start MOBIExthHeader EXTH record to begin search with\n @return Pointer to MOBIExthHeader record structure\n */\nMOBIExthHeader * mobi_next_exthrecord_by_tag(const MOBIData *m, const MOBIExthTag tag, MOBIExthHeader **start) {\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return NULL;\n    }\n    if (m->eh == NULL) {\n        return NULL;\n    }\n    MOBIExthHeader *curr;\n    if (*start) {\n        curr = *start;\n        *start = NULL;\n    } else {\n        curr = m->eh;\n    }\n    while (curr != NULL) {\n        if (curr->tag == tag) {\n            *start = curr->next;\n            return curr;\n        }\n        curr = curr->next;\n    }\n    return NULL;\n}\n\n/**\n @brief Add new EXTH record with given tag and value.\n \n @param[in,out] m MOBIData structure with loaded data\n @param[in] tag MOBIExthTag EXTH record tag\n @param[in] size Value size\n @param[in] value Value\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_add_exthrecord(MOBIData *m, const MOBIExthTag tag, const uint32_t size, const void *value) {\n    if (size == 0) {\n        debug_print(\"%s\\n\", \"Record size is zero\");\n        return MOBI_PARAM_ERR;\n    }\n    size_t count = 2;\n    while (m && count--) {\n        if (m->mh == NULL) {\n            debug_print(\"%s\\n\", \"Mobi header must be initialized\");\n            return MOBI_INIT_FAILED;\n        }\n        MOBIExthMeta meta = mobi_get_exthtagmeta_by_tag(tag);\n        MOBIExthHeader *record = calloc(1, sizeof(MOBIExthHeader));\n        if (record == NULL) {\n            debug_print(\"%s\\n\", \"Memory allocation for EXTH record failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        record->tag = tag;\n        record->size = size;\n        record->data = malloc(size);\n        if (record->data == NULL) {\n            debug_print(\"%s\\n\", \"Memory allocation for EXTH data failed\");\n            free(record);\n            return MOBI_MALLOC_FAILED;\n        }\n        if (meta.type == EXTH_STRING && mobi_is_cp1252(m)) {\n            debug_print(\"%s\\n\", \"Adding CP1252 string data\");\n            char *data = malloc(size + 1);\n            if (data == NULL) {\n                free(record->data);\n                free(record);\n                return MOBI_MALLOC_FAILED;\n            }\n            size_t data_size = size + 1;\n            MOBI_RET ret = mobi_utf8_to_cp1252(data, value, &data_size, size);\n            if (ret != MOBI_SUCCESS) {\n                free(record->data);\n                free(record);\n                free(data);\n                return ret;\n            }\n            memcpy(record->data, data, data_size);\n            record->size = (uint32_t) data_size;\n            free(data);\n        } else if (meta.name && meta.type == EXTH_NUMERIC && size == sizeof(uint32_t)) {\n            debug_print(\"%s\\n\", \"Adding numeric data\");\n            MOBIBuffer *buf = mobi_buffer_init_null(record->data, size);\n            if (buf == NULL) {\n                free(record->data);\n                free(record);\n                return MOBI_MALLOC_FAILED;\n            }\n            mobi_buffer_add32(buf, *(uint32_t *) value);\n            mobi_buffer_free_null(buf);\n        } else {\n            debug_print(\"%s\\n\", \"Adding raw data\");\n            memcpy(record->data, value, size);\n        }\n        debug_print(\"Added record %u (%u bytes)\\n\", meta.tag, size);\n\n        record->next = NULL;\n        if (m->eh == NULL) {\n            if (m->mh->exth_flags == NULL) {\n                m->mh->exth_flags = malloc(sizeof(uint32_t));\n                if (m->mh->exth_flags == NULL) {\n                    debug_print(\"%s\\n\", \"Memory allocation failed\");\n                    free(record->data);\n                    free(record);\n                    return MOBI_MALLOC_FAILED;\n                }\n            }\n            *m->mh->exth_flags = 0x40;\n            m->eh = record;\n        } else {\n            MOBIExthHeader *curr = m->eh;\n            while(curr->next) {\n                curr = curr->next;\n            }\n            curr->next = record;\n        }\n        m = m->next;\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Delete EXTH record.\n \n @param[in,out] m MOBIData structure with loaded data\n @param[in] record Record to be deleted\n @return Pointer to next record in the linked list (NULL if none)\n */\nMOBIExthHeader * mobi_delete_exthrecord(MOBIData *m, MOBIExthHeader *record) {\n    if (record == NULL || m == NULL || m->eh == NULL) {\n        return NULL;\n    }\n    MOBIExthHeader *next = record->next;\n    if (next) {\n        /* not last */\n        MOBIExthHeader *curr = m->eh;\n        if (curr == record) {\n            /* first */\n            m->eh = next;\n        } else {\n            /* not first */\n            while (curr) {\n                if (curr->next == record) {\n                    curr->next = next;\n                    break;\n                }\n                curr = curr->next;\n            }\n        }\n        free(record->data);\n        free(record);\n    } else if (m->eh == record) {\n        /* last && first */\n        free(m->eh->data);\n        free(m->eh);\n        m->eh = NULL;\n    } else {\n        /* last */\n        MOBIExthHeader *curr = m->eh;\n        while (curr) {\n            if (curr->next == record) {\n                curr->next = NULL;\n                break;\n            }\n            curr = curr->next;\n        }\n        free(record->data);\n        free(record);\n    }\n    return next;\n}\n\n/**\n @brief Delete all EXTH records with given MOBIExthTag tag\n \n @param[in,out] m MOBIData structure with loaded data\n @param[in] tag MOBIExthTag EXTH record tag\n @return Pointer to MOBIExthHeader record structure\n */\nMOBI_RET mobi_delete_exthrecord_by_tag(MOBIData *m, const MOBIExthTag tag) {\n    size_t count = 2;\n    while (m && count--) {\n        if (m->eh == NULL) {\n            debug_print(\"%s\", \"No exth records\\n\");\n            return MOBI_SUCCESS;\n        }\n        MOBIExthHeader *curr = m->eh;\n        while (curr) {\n            if (curr->tag == tag) {\n                curr = mobi_delete_exthrecord(m, curr);\n            } else {\n                curr = curr->next;\n            }\n        }\n        m = m->next;\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Array of known EXTH tags.\n Name strings shamelessly copied from KindleUnpack\n */\nconst MOBIExthMeta mobi_exth_tags[] = {\n    /* numeric */\n    {EXTH_SAMPLE, EXTH_NUMERIC, \"Sample\"},\n    {EXTH_STARTREADING, EXTH_NUMERIC, \"Start offset\"},\n    {EXTH_KF8BOUNDARY, EXTH_NUMERIC, \"K8 boundary offset\"},\n    {EXTH_COUNTRESOURCES, EXTH_NUMERIC, \"K8 count of resources, fonts, images\"},\n    {EXTH_RESCOFFSET, EXTH_NUMERIC, \"RESC offset\"},\n    {EXTH_COVEROFFSET, EXTH_NUMERIC, \"Cover offset\"},\n    {EXTH_THUMBOFFSET, EXTH_NUMERIC, \"Thumbnail offset\"},\n    {EXTH_HASFAKECOVER, EXTH_NUMERIC, \"Has fake cover\"},\n    {EXTH_CREATORSOFT, EXTH_NUMERIC, \"Creator software\"},\n    {EXTH_CREATORMAJOR, EXTH_NUMERIC, \"Creator major version\"},\n    {EXTH_CREATORMINOR, EXTH_NUMERIC, \"Creator minor version\"},\n    {EXTH_CREATORBUILD, EXTH_NUMERIC, \"Creator build number\"},\n    {EXTH_CLIPPINGLIMIT, EXTH_NUMERIC, \"Clipping limit\"},\n    {EXTH_PUBLISHERLIMIT, EXTH_NUMERIC, \"Publisher limit\"},\n    {EXTH_TTSDISABLE, EXTH_NUMERIC, \"Text to speech disabled\"},\n    {EXTH_READFORFREE, EXTH_NUMERIC, \"Read for Free\"},\n    /* strings */\n    {EXTH_DRMSERVER, EXTH_STRING, \"Drm server id\"},\n    {EXTH_DRMCOMMERCE, EXTH_STRING, \"Drm commerce id\"},\n    {EXTH_DRMEBOOKBASE, EXTH_STRING, \"Drm Ebookbase book id\"},\n    {EXTH_TITLE, EXTH_STRING, \"Title\"},\n    {EXTH_AUTHOR, EXTH_STRING, \"Creator\"},\n    {EXTH_PUBLISHER, EXTH_STRING, \"Publisher\"},\n    {EXTH_IMPRINT, EXTH_STRING, \"Imprint\"},\n    {EXTH_DESCRIPTION, EXTH_STRING, \"Description\"},\n    {EXTH_ISBN, EXTH_STRING, \"ISBN\"},\n    {EXTH_SUBJECT, EXTH_STRING, \"Subject\"},\n    {EXTH_PUBLISHINGDATE, EXTH_STRING, \"Published\"},\n    {EXTH_REVIEW, EXTH_STRING, \"Review\"},\n    {EXTH_CONTRIBUTOR, EXTH_STRING, \"Contributor\"},\n    {EXTH_RIGHTS, EXTH_STRING, \"Rights\"},\n    {EXTH_SUBJECTCODE, EXTH_STRING, \"Subject code\"},\n    {EXTH_TYPE, EXTH_STRING, \"Type\"},\n    {EXTH_SOURCE, EXTH_STRING, \"Source\"},\n    {EXTH_ASIN, EXTH_STRING, \"ASIN\"},\n    {EXTH_VERSION, EXTH_STRING, \"Version number\"},\n    {EXTH_ADULT, EXTH_STRING, \"Adult\"},\n    {EXTH_PRICE, EXTH_STRING, \"Price\"},\n    {EXTH_CURRENCY, EXTH_STRING, \"Currency\"},\n    {EXTH_FIXEDLAYOUT, EXTH_STRING, \"Fixed layout\"},\n    {EXTH_BOOKTYPE, EXTH_STRING, \"Book type\"},\n    {EXTH_ORIENTATIONLOCK, EXTH_STRING, \"Orientation lock\"},\n    {EXTH_ORIGRESOLUTION, EXTH_STRING, \"Original resolution\"},\n    {EXTH_ZEROGUTTER, EXTH_STRING, \"Zero gutter\"},\n    {EXTH_ZEROMARGIN, EXTH_STRING, \"Zero margin\"},\n    {EXTH_KF8COVERURI, EXTH_STRING, \"K8 masthead/cover image\"},\n    {EXTH_REGIONMAGNI, EXTH_STRING, \"Region magnification\"},\n    {EXTH_DICTNAME, EXTH_STRING, \"Dictionary short name\"},\n    {EXTH_WATERMARK, EXTH_STRING, \"Watermark\"},\n    {EXTH_DOCTYPE, EXTH_STRING, \"Document type\"},\n    {EXTH_LASTUPDATE, EXTH_STRING, \"Last update time\"},\n    {EXTH_UPDATEDTITLE, EXTH_STRING, \"Updated title\"},\n    {EXTH_ASIN504, EXTH_STRING, \"ASIN (504)\"},\n    {EXTH_TITLEFILEAS, EXTH_STRING, \"Title file as\"},\n    {EXTH_CREATORFILEAS, EXTH_STRING, \"Creator file as\"},\n    {EXTH_PUBLISHERFILEAS, EXTH_STRING, \"Publisher file as\"},\n    {EXTH_LANGUAGE, EXTH_STRING, \"Language\"},\n    {EXTH_ALIGNMENT, EXTH_STRING, \"Primary writing mode\"},\n    {EXTH_PAGEDIR, EXTH_STRING, \"Page progression direction\"},\n    {EXTH_OVERRIDEFONTS, EXTH_STRING, \"Override kindle fonts\"},\n    {EXTH_SORCEDESC, EXTH_STRING, \"Original source description\"},\n    {EXTH_DICTLANGIN, EXTH_STRING, \"Dictionary input language\"},\n    {EXTH_DICTLANGOUT, EXTH_STRING, \"Dictionary output language\"},\n    {EXTH_INPUTSOURCE, EXTH_STRING, \"Input source type\"},\n    {EXTH_CREATORBUILDREV, EXTH_STRING, \"Creator build revision\"},\n    {EXTH_CREATORSTRING, EXTH_STRING, \"Creator software string\"},\n    /* binary */\n    {EXTH_TAMPERKEYS, EXTH_BINARY, \"Tamper proof keys\"},\n    {EXTH_FONTSIGNATURE, EXTH_BINARY, \"Font signature\"},\n    {EXTH_RENTAL, EXTH_BINARY, \"Rental indicator\"}, // uint64_t\n    {EXTH_UNK403, EXTH_BINARY, \"Unknown (403)\"},\n    {EXTH_UNK407, EXTH_BINARY, \"Unknown (407)\"},\n    {EXTH_UNK450, EXTH_BINARY, \"Unknown (450)\"},\n    {EXTH_UNK451, EXTH_BINARY, \"Unknown (451)\"},\n    {EXTH_UNK452, EXTH_BINARY, \"Unknown (452)\"},\n    {EXTH_UNK453, EXTH_BINARY, \"Unknown (453)\"},\n /* end */\n    {0, 0, NULL},\n};\n\n/**\n @brief Get MOBIExthMeta tag structure by MOBIExthTag tag id\n \n @param[in] tag Tag id\n @return MOBIExthMeta structure for given tag id, zeroed structure on failure\n */\nMOBIExthMeta mobi_get_exthtagmeta_by_tag(const MOBIExthTag tag) {\n    size_t i = 0;\n    while (mobi_exth_tags[i].tag > 0) {\n        if (mobi_exth_tags[i].tag == tag) {\n            return mobi_exth_tags[i];\n        }\n        i++;\n    }\n    return (MOBIExthMeta) {0, 0, NULL};\n}\n\n/**\n @brief Decode big-endian value stored in EXTH record\n \n Only for EXTH records storing numeric values\n \n @param[in] data Memory area storing EXTH record data\n @param[in] size Size of EXTH record data\n @return 32-bit value\n */\nuint32_t mobi_decode_exthvalue(const unsigned char *data, const size_t size) {\n    /* FIXME: EXTH numeric data is max 32-bit? */\n    uint32_t val = 0;\n    size_t i = min(size, 4);\n    while (i--) {\n        val |= (uint32_t) *data++ << (i * 8);\n    }\n    return val;\n}\n\n#define MOBI_UTF8_MAXBYTES 4\n/**\n @brief Html entity mapping to utf-8 sequence\n */\ntypedef struct {\n    const char *name; /**< Html entity name */\n    const char utf8_bytes[MOBI_UTF8_MAXBYTES + 1]; /**< Utf-8 sequence */\n} HTMLEntity;\n\n/**\n @brief Basic named html entities mapping to utf-8 sequences\n */\nconst HTMLEntity entities[] = {\n    { \"&quot;\", \"\\\"\" },\n    { \"&amp;\", \"&\" },\n    { \"&lt;\", \"<\" },\n    { \"&gt;\", \">\" },\n    { \"&apos;\", \"'\" },\n    { \"&nbsp;\", \"\\xc2\\xa0\" },\n    { \"&copy;\", \"\\xc2\\xa9\" },\n    { \"&reg;\", \"\\xc2\\xae\" },\n    { \"&cent;\", \"\\xc2\\xa2\" },\n    { \"&pound;\", \"\\xc2\\xa3\" },\n    { \"&sect;\", \"\\xc2\\xa7\" },\n    { \"&laquo;\", \"\\xc2\\xab\" },\n    { \"&raquo;\", \"\\xc2\\xbb\" },\n    { \"&deg;\", \"\\xc2\\xb0\" },\n    { \"&plusmn;\", \"\\xc2\\xb1\" },\n    { \"&middot;\", \"\\xc2\\xb7\" },\n    { \"&frac12;\", \"\\xc2\\xbd\" },\n    { \"&ndash;\", \"\\xe2\\x80\\x93\" },\n    { \"&mdash;\", \"\\xe2\\x80\\x94\" },\n    { \"&lsquo;\", \"\\xe2\\x80\\x98\" },\n    { \"&sbquo;\", \"\\xe2\\x80\\x9a\" },\n    { \"&ldquo;\", \"\\xe2\\x80\\x9c\" },\n    { \"&rdquo;\", \"\\xe2\\x80\\x9d\" },\n    { \"&bdquo;\", \"\\xe2\\x80\\x9e\" },\n    { \"&dagger;\", \"\\xe2\\x80\\xa0\" },\n    { \"&Dagger;\", \"\\xe2\\x80\\xa1\" },\n    { \"&bull;\", \"\\xe2\\x80\\xa2\" },\n    { \"&hellip;\", \"\\xe2\\x80\\xa6\" },\n    { \"&prime;\", \"\\xe2\\x80\\xb2\" },\n    { \"&Prime;\", \"\\xe2\\x80\\xb3\" },\n    { \"&euro;\", \"\\xe2\\x82\\xac\" },\n    { \"&trade;\", \"\\xe2\\x84\\xa2\" }\n};\n\n/**\n @brief Convert html entities in string to utf-8 characters\n \n @param[in] input Input string\n @return Converted string\n */\nchar * mobi_decode_htmlentities(const char *input) {\n    if (!input) {\n        return NULL;\n    }\n    const size_t codepoint_max = 0x10ffff;\n    size_t output_length = strlen(input) + 1;\n    char *in = (char *) input;\n    /* output size will be less or equal to input */\n    char *output = malloc(output_length);\n    char *out = output;\n    if (output == NULL) {\n        debug_print(\"Memory allocation failed (%zu bytes)\\n\", output_length);\n        return NULL;\n    }\n    char *offset = in;\n    while ((in = strchr(in, '&'))) {\n        size_t decoded_length = 0;\n        char *end = NULL;\n        char decoded[MOBI_UTF8_MAXBYTES + 1] = { 0 };\n        if (in[1] == '#' && (in[2] == 'x' || in[2] == 'X')) {\n            // hex entity\n            size_t codepoint = strtoul(in + 3, &end, 16);\n            if (*end++ == ';' && codepoint <= codepoint_max) {\n                decoded_length = mobi_unicode_to_utf8(decoded, codepoint);\n            }\n        } else if (in[1] == '#') {\n            // dec entity\n            size_t codepoint = strtoul(in + 2, &end, 10);\n            if (*end++ == ';' && codepoint <= codepoint_max) {\n                decoded_length = mobi_unicode_to_utf8(decoded, codepoint);\n            }\n        } else {\n            // named entity\n            for (size_t i = 0; i < ARRAYSIZE(entities); i++) {\n                if (strncmp(in, entities[i].name, strlen(entities[i].name)) == 0) {\n                    int ret = snprintf(decoded, MOBI_UTF8_MAXBYTES + 1, \"%s\", entities[i].utf8_bytes);\n                    if (ret > 0) {\n                        decoded_length = (size_t) ret;\n                        end = in + strlen(entities[i].name);\n                        break;\n                    }\n                }\n            }\n        }\n        if (decoded_length) {\n            size_t len = (size_t) (in - offset);\n            memcpy(out, offset, len);\n            offset = end;\n            out += len;\n            memcpy(out, decoded, decoded_length);\n            out += decoded_length;\n        }\n        in += decoded_length + 1;\n    }\n    strcpy(out, offset);\n    return output;\n}\n\n/**\n @brief Decode string stored in EXTH record\n \n Only for EXTH records storing string values\n \n @param[in] m MOBIData structure loaded with MOBI data\n @param[in] data Memory area storing EXTH record data\n @param[in] size Size of EXTH record data\n @return String from EXTH record in utf-8 encoding\n */\nchar * mobi_decode_exthstring(const MOBIData *m, const unsigned char *data, const size_t size) {\n    if (!m || !data) {\n        return NULL;\n    }\n    size_t out_length = 3 * size + 1;\n    size_t in_length = size;\n    char *exth_string = malloc(out_length);\n    if (exth_string == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return NULL;\n    }\n    if (mobi_is_cp1252(m)) {\n        MOBI_RET ret = mobi_cp1252_to_utf8(exth_string, (const char *) data, &out_length, in_length);\n        if (ret != MOBI_SUCCESS) {\n            free(exth_string);\n            return NULL;\n        }\n    } else {\n        memcpy(exth_string, data, size);\n        out_length = size;\n    }\n    exth_string[out_length] = '\\0';\n    char *exth_decoded = mobi_decode_htmlentities(exth_string);\n    if (exth_decoded != NULL) {\n        free(exth_string);\n        return exth_decoded;\n    }\n    return exth_string;\n}\n\n/**\n @brief Swap endianness of 32-bit value\n \n @param[in] val 4-byte unsigned integer\n @return Integer with swapped endianness\n */\nuint32_t mobi_swap32(const uint32_t val) {\n    return ((((val) >> 24) & 0x000000ff) |\n            (((val) >>  8) & 0x0000ff00) |\n            (((val) <<  8) & 0x00ff0000) |\n            (((val) << 24) & 0xff000000));\n\n}\n\n/**\n @brief Convert time values from palmdoc header to time tm struct\n \n Older files set time in mac format. Newer ones in unix time.\n \n @param[in] pdb_time Time value from PDB header\n @return Time structure struct tm of time.h\n */\nstruct tm * mobi_pdbtime_to_time(const long pdb_time) {\n    time_t time = pdb_time;\n    const int unix1996 = 820454400;\n    if (time < unix1996 && time > 0) {\n        /* sometimes dates are stored as little endian */\n        time = mobi_swap32((uint32_t) time);\n    }\n    const uint32_t mactime_flag = (uint32_t) (1U << 31);\n    if (time & mactime_flag) {\n        debug_print(\"%s\\n\", \"mac time\");\n        time -= EPOCH_MAC_DIFF;\n    }\n    return localtime(&time);\n}\n\n/**\n @brief Lookup table for number of bits set in a single byte\n */\nstatic const char setbits[256] = {\n    0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,\n    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n    4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8,\n};\n\n/**\n @brief Get number of bits set in a given byte\n \n @param[in] byte A byte\n @return Number of bits set\n */\nint mobi_bitcount(const uint8_t byte) {\n    return setbits[byte];\n}\n\n/**\n @brief Decompress text record (internal).\n \n Internal function for mobi_get_rawml and mobi_dump_rawml. \n Decompressed output is stored either in a file or in a text string\n \n @param[in] m MOBIData structure loaded with MOBI data\n @param[in,out] text Memory area to be filled with decompressed output\n @param[in,out] file If not NULL output is written to the file, otherwise to text string\n @param[in,out] len Length of the memory allocated for the text string, on return set to decompressed text length\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nstatic MOBI_RET mobi_decompress_content(const MOBIData *m, char *text, FILE *file, size_t *len) {\n    int dump = false;\n    if (file != NULL) {\n        dump = true;\n    }\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    if (mobi_is_encrypted(m) && !mobi_has_drmkey(m)) {\n        debug_print(\"%s\", \"Document is encrypted\\n\");\n        return MOBI_FILE_ENCRYPTED;\n    }\n    const size_t offset = mobi_get_kf8offset(m);\n    if (m->rh == NULL || m->rh->text_record_count == 0) {\n        debug_print(\"%s\", \"Text records not found in MOBI header\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    const size_t text_rec_index = 1 + offset;\n    size_t text_rec_count = m->rh->text_record_count;\n    const uint16_t compression_type = m->rh->compression_type;\n    /* check for extra data at the end of text files */\n    uint16_t extra_flags = 0;\n    if (m->mh && m->mh->extra_flags) {\n        extra_flags = *m->mh->extra_flags;\n    }\n    /* get first text record */\n    const MOBIPdbRecord *curr = mobi_get_record_by_seqnumber(m, text_rec_index);\n    MOBIHuffCdic *huffcdic = NULL;\n    if (compression_type == MOBI_COMPRESSION_HUFFCDIC) {\n        /* load huff/cdic tables */\n        huffcdic = mobi_init_huffcdic();\n        if (huffcdic == NULL) {\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        MOBI_RET ret = mobi_parse_huffdic(m, huffcdic);\n        if (ret != MOBI_SUCCESS) {\n            mobi_free_huffcdic(huffcdic);\n            return ret;\n        }\n    }\n    /* get following CDIC records */\n    size_t text_length = 0;\n    while (text_rec_count-- && curr) {\n        size_t extra_size = 0;\n        if (extra_flags) {\n            extra_size = mobi_get_record_extrasize(curr, extra_flags);\n            if (extra_size == MOBI_NOTSET) {\n                mobi_free_huffcdic(huffcdic);\n                return MOBI_DATA_CORRUPT;\n            }\n        }\n        size_t decompressed_size = mobi_get_textrecord_maxsize(m);\n        unsigned char *decompressed = malloc(decompressed_size);\n        if (decompressed == NULL) {\n            mobi_free_huffcdic(huffcdic);\n            debug_print(\"Memory allocation failed%s\", \"\\n\");\n            return MOBI_MALLOC_FAILED;\n        }\n        MOBI_RET ret = MOBI_SUCCESS;\n#ifdef USE_ENCRYPTION\n        if (mobi_is_encrypted(m) && mobi_has_drmkey(m)) {\n            if (compression_type != MOBI_COMPRESSION_HUFFCDIC) {\n                /* decrypt also multibyte extra data */\n                extra_size = mobi_get_record_extrasize(curr, extra_flags & 0xfffe);\n            }\n            if (extra_size == MOBI_NOTSET || extra_size > curr->size) {\n                mobi_free_huffcdic(huffcdic);\n                free(decompressed);\n                return MOBI_DATA_CORRUPT;\n            }\n            const size_t decrypt_size = curr->size - extra_size;\n            if (decrypt_size > decompressed_size) {\n                if (decrypt_size <= curr->size) {\n                    unsigned char *tmp = realloc(decompressed, decrypt_size);\n                    if (tmp == NULL) {\n                        debug_print(\"%s\\n\", \"Memory allocation failed\");\n                        mobi_free_huffcdic(huffcdic);\n                        free(decompressed);\n                        return MOBI_MALLOC_FAILED;\n                    }\n                    decompressed = tmp;\n                } else {\n                    debug_print(\"Record too large: %zu\\n\", decrypt_size);\n                    mobi_free_huffcdic(huffcdic);\n                    free(decompressed);\n                    return MOBI_DATA_CORRUPT;\n                }\n            }\n            if (decrypt_size) {\n                ret = mobi_buffer_decrypt(decompressed, curr->data, decrypt_size, m);\n                if (ret != MOBI_SUCCESS) {\n                    mobi_free_huffcdic(huffcdic);\n                    free(decompressed);\n                    return ret;\n                }\n                memcpy(curr->data, decompressed, decrypt_size);\n            }\n            if (compression_type != MOBI_COMPRESSION_HUFFCDIC && (extra_flags & 1)) {\n                // update multibyte data size after decryption\n                extra_size = mobi_get_record_extrasize(curr, extra_flags);\n                if (extra_size == MOBI_NOTSET) {\n                    free(decompressed);\n                    return MOBI_DATA_CORRUPT;\n                }\n            }\n        }\n#endif\n        if (extra_size > curr->size) {\n            debug_print(\"Wrong record size: -%zu\\n\", extra_size - curr->size);\n            mobi_free_huffcdic(huffcdic);\n            free(decompressed);\n            return MOBI_DATA_CORRUPT;\n        }\n        if (extra_size == curr->size) {\n            debug_print(\"Skipping empty record%s\", \"\\n\");\n            free(decompressed);\n            curr = curr->next;\n            continue;\n        }\n        const size_t record_size = curr->size - extra_size;\n        switch (compression_type) {\n            case MOBI_COMPRESSION_NONE:\n                /* no compression */\n                if (record_size > decompressed_size) {\n                    debug_print(\"Record too large: %zu\\n\", record_size);\n                    free(decompressed);\n                    return MOBI_DATA_CORRUPT;\n                }\n                memcpy(decompressed, curr->data, record_size);\n                decompressed_size = record_size;\n                if (mobi_exists_mobiheader(m) && mobi_get_fileversion(m) <= 3) {\n                    /* workaround for some old files with null characters inside record */\n                    mobi_remove_zeros(decompressed, &decompressed_size);\n                }\n                break;\n            case MOBI_COMPRESSION_PALMDOC:\n                /* palmdoc lz77 compression */\n                ret = mobi_decompress_lz77(decompressed, curr->data, &decompressed_size, record_size);\n                if (ret != MOBI_SUCCESS) {\n                    free(decompressed);\n                    return ret;\n                }\n                break;\n            case MOBI_COMPRESSION_HUFFCDIC:\n                /* mobi huffman compression */\n                ret = mobi_decompress_huffman(decompressed, curr->data, &decompressed_size, record_size, huffcdic);\n                if (ret != MOBI_SUCCESS) {\n                    free(decompressed);\n                    mobi_free_huffcdic(huffcdic);\n                    return ret;\n                }\n                break;\n            default:\n                debug_print(\"%s\", \"Unknown compression type\\n\");\n                mobi_free_huffcdic(huffcdic);\n                free(decompressed);\n                return MOBI_DATA_CORRUPT;\n        }\n        curr = curr->next;\n        if (dump) {\n            fwrite(decompressed, 1, decompressed_size, file);\n        } else {\n            if (text_length + decompressed_size > *len) {\n                debug_print(\"%s\", \"Text buffer too small\\n\");\n                /* free huff/cdic tables */\n                mobi_free_huffcdic(huffcdic);\n                free(decompressed);\n                return MOBI_PARAM_ERR;\n            }\n            memcpy(text + text_length, decompressed, decompressed_size);\n            text_length += decompressed_size;\n            text[text_length] = '\\0';\n        }\n        free(decompressed);\n    }\n    /* free huff/cdic tables */\n    mobi_free_huffcdic(huffcdic);\n    if (len) {\n        *len = text_length;\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Decompress text to a text buffer.\n \n @param[in] m MOBIData structure loaded with MOBI data\n @param[in,out] text Memory area to be filled with decompressed output\n @param[in,out] len Length of the memory allocated for the text string, on return will be set to decompressed text length\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_get_rawml(const MOBIData *m, char *text, size_t *len) {\n    if (text == NULL || len == NULL) {\n        debug_print(\"%s\", \"Parameter error: text or len is NULL\\n\");\n        return MOBI_PARAM_ERR;\n    }\n    if (m->rh->text_length > *len) {\n        debug_print(\"%s\", \"Text buffer smaller then text size declared in record0 header\\n\");\n        return MOBI_PARAM_ERR;\n    }\n    text[0] = '\\0';\n    return mobi_decompress_content(m, text, NULL, len);\n}\n\n/**\n @brief Decompress text record to an open file descriptor.\n \n Internal function for mobi_get_rawml and mobi_dump_rawml.\n Decompressed output is stored either in a file or in a text string\n \n @param[in] m MOBIData structure loaded with MOBI data\n @param[in,out] file File descriptor\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_dump_rawml(const MOBIData *m, FILE *file) {\n    if (file == NULL) {\n        debug_print(\"%s\", \"File descriptor is NULL\\n\");\n        return MOBI_FILE_NOT_FOUND;\n    }\n    return mobi_decompress_content(m, NULL, file, NULL);\n}\n\n/**\n @brief Check if MOBI header is loaded / present in the loaded file\n \n @param[in] m MOBIData structure loaded with MOBI data\n @return true on success, false otherwise\n */\nbool mobi_exists_mobiheader(const MOBIData *m) {\n    if (m == NULL || m->mh == NULL) {\n        return false;\n    }\n    return true;\n}\n\n/**\n @brief Check if skeleton INDX is present in the loaded file\n \n @param[in] m MOBIData structure loaded with MOBI data\n @return true on success, false otherwise\n */\nbool mobi_exists_skel_indx(const MOBIData *m) {\n    if (!mobi_exists_mobiheader(m)) {\n        return false;\n    }\n    if (m->mh->skeleton_index == NULL || *m->mh->skeleton_index == MOBI_NOTSET) {\n        debug_print(\"%s\", \"SKEL INDX record not found\\n\");\n        return false;\n    }\n    return true;\n}\n\n/**\n @brief Check if FDST record is present in the loaded file\n \n @param[in] m MOBIData structure loaded with MOBI data\n @return true on success, false otherwise\n */\nbool mobi_exists_fdst(const MOBIData *m) {\n    if (!mobi_exists_mobiheader(m) || mobi_get_fileversion(m) <= 3) {\n        return false;\n    }\n    if (mobi_get_fileversion(m) >= 8) {\n        if (m->mh->fdst_index && *m->mh->fdst_index != MOBI_NOTSET) {\n            return true;\n        }\n    } else {\n        if ((m->mh->fdst_section_count && *m->mh->fdst_section_count > 1)\n            && (m->mh->last_text_index && *m->mh->last_text_index != (uint16_t) -1)) {\n            return true;\n        }\n    }\n    debug_print(\"%s\", \"FDST record not found\\n\");\n    return false;\n}\n\n/**\n @brief Get sequential number of FDST record\n \n @param[in] m MOBIData structure loaded with MOBI data\n @return Record number on success, MOBI_NOTSET otherwise\n */\nsize_t mobi_get_fdst_record_number(const MOBIData *m) {\n    if (!mobi_exists_mobiheader(m)) {\n        return MOBI_NOTSET;\n    }\n    const size_t offset = mobi_get_kf8offset(m);\n    if (m->mh->fdst_index && *m->mh->fdst_index != MOBI_NOTSET) {\n        if (m->mh->fdst_section_count && *m->mh->fdst_section_count > 1) {\n            return *m->mh->fdst_index + offset;\n        }\n    }\n    if (m->mh->fdst_section_count && *m->mh->fdst_section_count > 1) {\n        /* FIXME: if KF7, is it safe to asume last_text_index has fdst index */\n        if (m->mh->last_text_index) {\n            return *m->mh->last_text_index;\n        }\n    }\n    return MOBI_NOTSET;\n}\n\n/**\n @brief Check if fragments INDX is present in the loaded file\n \n @param[in] m MOBIData structure loaded with MOBI data\n @return true on success, false otherwise\n */\nbool mobi_exists_frag_indx(const MOBIData *m) {\n    if (!mobi_exists_mobiheader(m)) {\n        return false;\n    }\n    if (m->mh->fragment_index == NULL || *m->mh->fragment_index == MOBI_NOTSET) {\n        return false;\n    }\n    debug_print(\"%s\", \"Fragments INDX found\\n\");\n    return true;\n}\n\n/**\n @brief Check if guide INDX is present in the loaded file\n \n @param[in] m MOBIData structure loaded with MOBI data\n @return true on success, false otherwise\n */\nbool mobi_exists_guide_indx(const MOBIData *m) {\n    if (!mobi_exists_mobiheader(m)) {\n        return false;\n    }\n    if (m->mh->guide_index == NULL || *m->mh->guide_index == MOBI_NOTSET) {\n        return false;\n    }\n    debug_print(\"%s\", \"Guide INDX found\\n\");\n    return true;\n}\n\n/**\n @brief Check if ncx INDX is present in the loaded file\n \n @param[in] m MOBIData structure loaded with MOBI data\n @return true on success, false otherwise\n */\nbool mobi_exists_ncx(const MOBIData *m) {\n    if (!mobi_exists_mobiheader(m)) {\n        return false;\n    }\n    if (m->mh->ncx_index == NULL || *m->mh->ncx_index == MOBI_NOTSET) {\n        return false;\n    }\n    debug_print(\"%s\", \"NCX INDX found\\n\");\n    return true;\n}\n\n/**\n @brief Check if orth INDX is present in the loaded file\n \n @param[in] m MOBIData structure loaded with MOBI data\n @return true on success, false otherwise\n */\nbool mobi_exists_orth(const MOBIData *m) {\n    if (!mobi_exists_mobiheader(m)) {\n        return false;\n    }\n    if (m->mh->orth_index == NULL || *m->mh->orth_index == MOBI_NOTSET) {\n        return false;\n    }\n    debug_print(\"%s\", \"ORTH INDX found\\n\");\n    return true;\n}\n\n/**\n @brief Check if infl INDX is present in the loaded file\n \n @param[in] m MOBIData structure loaded with MOBI data\n @return true on success, false otherwise\n */\nbool mobi_exists_infl(const MOBIData *m) {\n    if (!mobi_exists_mobiheader(m)) {\n        return false;\n    }\n    if (m->mh->infl_index == NULL || *m->mh->infl_index == MOBI_NOTSET) {\n        return false;\n    }\n    debug_print(\"%s\", \"INFL INDX found\\n\");\n    return true;\n}\n\n/**\n @brief Get file type of given part with number [part_number]\n \n @param[in] rawml MOBIRawml parsed records structure\n @param[in] part_number Sequential number of the part within rawml structure\n @return MOBIFiletype file type\n */\nMOBIFiletype mobi_determine_flowpart_type(const MOBIRawml *rawml, const size_t part_number) {\n    if (part_number == 0 || mobi_is_rawml_kf8(rawml) == false) {\n        return T_HTML;\n    }\n    if (part_number > 9999) {\n        debug_print(\"Corrupt part number: %zu\\n\", part_number);\n        return T_UNKNOWN;\n    }\n    char target[30];\n    snprintf(target, 30, \"\\\"kindle:flow:%04zu?mime=\", part_number);\n    unsigned char *data_start = rawml->flow->data;\n    unsigned char *data_end = data_start + rawml->flow->size - 1;\n    MOBIResult result;\n    MOBI_RET ret = mobi_find_attrvalue(&result, data_start, data_end, T_HTML, target);\n    if (ret == MOBI_SUCCESS && result.start) {\n        if (strstr(result.value, \"text/css\")) {\n            return T_CSS;\n        }\n        if (strstr(result.value, \"image/svg+xml\")) {\n            return T_SVG;\n        }\n    }\n    return T_UNKNOWN;\n}\n\n/**\n @brief Get font type of given font resource\n \n @param[in] font_data Font resource data\n @param[in] font_size Font resource size\n @return MOBIFiletype file type\n */\nMOBIFiletype mobi_determine_font_type(const unsigned char *font_data, const size_t font_size) {\n    const char otf_magic[] = \"OTTO\";\n    const char ttf_magic[] = \"\\0\\1\\0\\0\";\n    const char ttf2_magic[] = \"true\";\n\n    if (font_size >= 4) {\n        if (memcmp(font_data, otf_magic, 4) == 0) {\n            return T_OTF;\n        }\n        if (memcmp(font_data, ttf_magic, 4) == 0) {\n            return T_TTF;\n        }\n        if (memcmp(font_data, ttf2_magic, 4) == 0) {\n            return T_TTF;\n        }\n    }\n    debug_print(\"Unknown font resource type%s\", \"\\n\");\n    return T_UNKNOWN;\n}\n\n/**\n @brief Replace part data with decoded audio data\n \n @param[in,out] part MOBIPart structure containing font resource, decoded part type will be set in the structure\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_add_audio_resource(MOBIPart *part) {\n    unsigned char *data = NULL;\n    size_t size = 0;\n    MOBI_RET ret = mobi_decode_audio_resource(&data, &size, part);\n    if (ret != MOBI_SUCCESS) {\n        return ret;\n    }\n    part->data = data;\n    part->size = size;\n    /* FIXME: the only possible audio type is mp3 */\n    part->type = T_MP3;\n\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Decode audio resource\n \n @param[in,out] decoded_resource Pointer to data offset in mobipocket record.\n @param[in,out] decoded_size Decoded resource data size\n @param[in,out] part MOBIPart structure containing resource, decoded part type will be set in the structure\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_decode_audio_resource(unsigned char **decoded_resource, size_t *decoded_size, MOBIPart *part) {\n    if (part->size < MEDIA_HEADER_LEN) {\n        debug_print(\"Audio resource record too short (%zu)\\n\", part->size);\n        return MOBI_DATA_CORRUPT;\n    }\n    MOBIBuffer *buf = mobi_buffer_init_null(part->data, part->size);\n    if (buf == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    char magic[5];\n    mobi_buffer_getstring(magic, buf, 4);\n    if (strncmp(magic, AUDI_MAGIC, 4) != 0) {\n        debug_print(\"Wrong magic for audio resource: %s\\n\", magic);\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    uint32_t offset = mobi_buffer_get32(buf);\n    mobi_buffer_setpos(buf, offset);\n    *decoded_size = buf->maxlen - buf->offset;\n    *decoded_resource = mobi_buffer_getpointer(buf, *decoded_size);\n    mobi_buffer_free_null(buf);\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Replace part data with decoded video data\n \n @param[in,out] part MOBIPart structure containing font resource, decoded part type will be set in the structure\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_add_video_resource(MOBIPart *part) {\n    unsigned char *data = NULL;\n    size_t size = 0;\n    MOBI_RET ret = mobi_decode_video_resource(&data, &size, part);\n    if (ret != MOBI_SUCCESS) {\n        return ret;\n    }\n    part->data = data;\n    part->size = size;\n    part->type = T_MPG; /* FIXME: other types? */\n\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Decode video resource\n \n @param[in,out] decoded_resource Pointer to data offset in mobipocket record.\n @param[in,out] decoded_size Decoded resource data size\n @param[in,out] part MOBIPart structure containing resource, decoded part type will be set in the structure\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_decode_video_resource(unsigned char **decoded_resource, size_t *decoded_size, MOBIPart *part) {\n    if (part->size < MEDIA_HEADER_LEN) {\n        debug_print(\"Video resource record too short (%zu)\\n\", part->size);\n        return MOBI_DATA_CORRUPT;\n    }\n    MOBIBuffer *buf = mobi_buffer_init_null(part->data, part->size);\n    if (buf == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    char magic[5];\n    mobi_buffer_getstring(magic, buf, 4);\n    if (strncmp(magic, VIDE_MAGIC, 4) != 0) {\n        debug_print(\"Wrong magic for video resource: %s\\n\", magic);\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    uint32_t offset = mobi_buffer_get32(buf);\n    /* offset is always(?) 12, next four bytes are unknown */\n    mobi_buffer_setpos(buf, offset);\n    *decoded_size = buf->maxlen - buf->offset;\n    *decoded_resource = mobi_buffer_getpointer(buf, *decoded_size);\n    mobi_buffer_free_null(buf);\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Get embedded source archive\n \n Some mobi creator software store original conversion source as a zip archive.\n The function may return MOBI_SUCCESS even if the data was not found,\n so it is neccessary to check whether returned data pointer is not NULL.\n \n @param[in,out] data Pointer to data offset in pdb record.\n @param[in,out] size Pointer to data size\n @param[in] m MOBIData structure\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_get_embedded_source(unsigned char **data, size_t *size, const MOBIData *m) {\n    *data = NULL;\n    *size = 0;\n    if (m == NULL) {\n        return MOBI_INIT_FAILED;\n    }\n    MOBIMobiHeader *header = m->mh;\n    if (mobi_is_hybrid(m) && m->use_kf8 && m->next) {\n        /* SRCS index is in KF7 header */\n        header = m->next->mh;\n    }\n    if (header == NULL || header->srcs_index == NULL || header->srcs_count == NULL ||\n        *header->srcs_index == MOBI_NOTSET || *header->srcs_count == 0) {\n        return MOBI_SUCCESS;\n    }\n    uint32_t index = *header->srcs_index;\n    \n    const MOBIPdbRecord *srcs_record = mobi_get_record_by_seqnumber(m, index);\n    if (srcs_record == NULL) {\n        return MOBI_SUCCESS;\n    }\n    const size_t archive_offset = 16;\n    \n    if (srcs_record->size <= archive_offset) {\n        debug_print(\"Wrong size of SRCS resource: %zu\\n\", srcs_record->size);\n        return MOBI_DATA_CORRUPT;\n    }\n\n    if (memcmp(srcs_record->data, SRCS_MAGIC, 4) != 0) {\n        debug_print(\"Wrong magic for SRCS resource: %c%c%c%c\\n\",\n                    srcs_record->data[0], srcs_record->data[1], srcs_record->data[2], srcs_record->data[3]);\n        return MOBI_DATA_CORRUPT;\n    }\n    \n    *data = srcs_record->data + archive_offset;\n    *size = srcs_record->size - archive_offset;\n\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Get embedded conversion log\n \n Some mobi creator software store original conversion log together with source archive.\n The function may return MOBI_SUCCESS even if the data was not found,\n so it is neccessary to check whether returned data pointer is not NULL.\n \n @param[in,out] data Pointer to data offset in pdb record.\n @param[in,out] size Pointer to data size\n @param[in] m MOBIData structure\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_get_embedded_log(unsigned char **data, size_t *size, const MOBIData *m) {\n    *data = NULL;\n    *size = 0;\n    if (m == NULL) {\n        return MOBI_INIT_FAILED;\n    }\n    MOBIMobiHeader *header = m->mh;\n    if (mobi_is_hybrid(m) && m->use_kf8 && m->next) {\n        /* SRCS index is in KF7 header */\n        header = m->next->mh;\n    }\n    if (header == NULL || header->srcs_index == NULL || header->srcs_count == NULL ||\n        *header->srcs_index == MOBI_NOTSET || *header->srcs_count < 2) {\n        return MOBI_SUCCESS;\n    }\n    uint32_t index = *header->srcs_index + 1;\n    \n    const MOBIPdbRecord *srcs_record = mobi_get_record_by_seqnumber(m, index);\n    if (srcs_record == NULL) {\n        return MOBI_SUCCESS;\n    }\n    const size_t log_offset = 12;\n    if (srcs_record->size <= log_offset) {\n        debug_print(\"Wrong size of CMET resource: %zu\\n\", srcs_record->size);\n        return MOBI_DATA_CORRUPT;\n    }\n    MOBIBuffer *buf = mobi_buffer_init_null(srcs_record->data, srcs_record->size);\n    if (buf == NULL) {\n        return MOBI_MALLOC_FAILED;\n    }\n    if (mobi_buffer_match_magic(buf, CMET_MAGIC) == false) {\n        debug_print(\"%s\\n\", \"Wrong magic for CMET resource\");\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    mobi_buffer_setpos(buf, 8);\n    uint32_t log_length = mobi_buffer_get32(buf);\n    unsigned char *log_data = mobi_buffer_getpointer(buf, log_length);\n    if (buf->error != MOBI_SUCCESS) {\n        debug_print(\"CMET resource too short: %zu (log size: %u)\\n\", srcs_record->size, log_length);\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    \n    *data = log_data;\n    *size = log_length;\n    \n    mobi_buffer_free_null(buf);\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Replace part data with decoded font data\n \n @param[in,out] part MOBIPart structure containing font resource, decoded part type will be set in the structure\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_add_font_resource(MOBIPart *part) {\n    unsigned char *data = NULL;\n    size_t size = 0;\n    MOBI_RET ret = mobi_decode_font_resource(&data, &size, part);\n    if (ret != MOBI_SUCCESS) {\n        return ret;\n    }\n    part->data = data;\n    part->size = size;\n    part->type = mobi_determine_font_type(data, size);\n    /* FIXME: mark unknown font types as ttf (shouldn't happen).\n       This will allow proper font resource deallocation. */\n    if (part->type == T_UNKNOWN) { part->type = T_TTF; }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Deobfuscator and decompressor for font resources\n \n @param[in,out] decoded_font Pointer to memory to write to. Will be allocated. Must be freed by caller\n @param[in,out] decoded_size Decoded font data size\n @param[in,out] part MOBIPart structure containing font resource, decoded part type will be set in the structure\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_decode_font_resource(unsigned char **decoded_font, size_t *decoded_size, MOBIPart *part) {\n    if (part->size < FONT_HEADER_LEN) {\n        debug_print(\"Font resource record too short (%zu)\\n\", part->size);\n        return MOBI_DATA_CORRUPT;\n    }\n    MOBIBuffer *buf = mobi_buffer_init(part->size);\n    if (buf == NULL) {\n        debug_print(\"Memory allocation failed%s\", \"\\n\");\n        return MOBI_MALLOC_FAILED;\n    }\n    memcpy(buf->data, part->data, part->size);\n    struct header {\n        char magic[5];\n        uint32_t decoded_size;\n        uint32_t flags;\n        uint32_t data_offset;\n        uint32_t xor_key_len;\n        uint32_t xor_data_off;\n    };\n    struct header h;\n    mobi_buffer_getstring(h.magic, buf, 4);\n    if (strncmp(h.magic, FONT_MAGIC, 4) != 0) {\n        debug_print(\"Wrong magic for font resource: %s\\n\", h.magic);\n        mobi_buffer_free(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    h.decoded_size = mobi_buffer_get32(buf);\n    if (h.decoded_size == 0 || h.decoded_size > FONT_SIZEMAX) {\n        debug_print(\"Invalid declared font resource size: %u\\n\", h.decoded_size);\n        mobi_buffer_free(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    h.flags = mobi_buffer_get32(buf);\n    h.data_offset = mobi_buffer_get32(buf);\n    h.xor_key_len = mobi_buffer_get32(buf);\n    h.xor_data_off = mobi_buffer_get32(buf);\n    const uint32_t zlib_flag = 1; /* bit 0 */\n    const uint32_t xor_flag = 2; /* bit 1 */\n    if (h.flags & xor_flag && h.xor_key_len > 0) {\n        /* deobfuscate */\n        if (h.data_offset > buf->maxlen || h.xor_data_off + h.xor_key_len > buf->maxlen) {\n            debug_print(\"%s\\n\", \"Invalid obfuscated font data offsets\");\n            mobi_buffer_free(buf);\n            return MOBI_DATA_CORRUPT;\n        }\n        mobi_buffer_setpos(buf, h.data_offset);\n        const unsigned char *xor_key = buf->data + h.xor_data_off;\n        size_t i = 0;\n        const size_t xor_limit = h.xor_key_len * MOBI_FONT_OBFUSCATED_BUFFER_COUNT;\n        while (buf->offset < buf->maxlen && i < xor_limit) {\n            buf->data[buf->offset++] ^= xor_key[i % h.xor_key_len];\n            i++;\n        }\n    }\n    mobi_buffer_setpos(buf, h.data_offset);\n    *decoded_size = h.decoded_size;\n    *decoded_font = malloc(h.decoded_size);\n    if (*decoded_font == NULL) {\n        mobi_buffer_free(buf);\n        debug_print(\"%s\", \"Memory allocation failed\\n\");\n        return MOBI_MALLOC_FAILED;\n    }\n    const unsigned char *encoded_font = buf->data + buf->offset;\n    const unsigned long encoded_size = buf->maxlen - buf->offset;\n    if (h.flags & zlib_flag) {\n        /* unpack */\n        int ret = m_uncompress(*decoded_font, (unsigned long *) decoded_size, encoded_font, encoded_size);\n        if (ret != M_OK) {\n            mobi_buffer_free(buf);\n            free(*decoded_font);\n            debug_print(\"%s\", \"Font resource decompression failed\\n\");\n            return MOBI_DATA_CORRUPT;\n        }\n        if (*decoded_size != h.decoded_size) {\n            mobi_buffer_free(buf);\n            free(*decoded_font);\n            debug_print(\"Decompressed font size (%zu) differs from declared (%i)\\n\", *decoded_size, h.decoded_size);\n            return MOBI_DATA_CORRUPT;\n        }\n    } else {\n        if (*decoded_size < encoded_size) {\n            mobi_buffer_free(buf);\n            free(*decoded_font);\n            debug_print(\"Font size in record (%lu) larger then declared (%zu)\\n\", encoded_size, *decoded_size);\n            return MOBI_DATA_CORRUPT;\n        }\n        memcpy(*decoded_font, encoded_font, encoded_size);\n    }\n\n    mobi_buffer_free(buf);\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Get resource type (image, font) by checking its magic header\n \n @param[in] record MOBIPdbRecord structure containing unknown record type\n @return MOBIFiletype file type, T_UNKNOWN if not determined, T_BREAK if end of records mark found\n */\nMOBIFiletype mobi_determine_resource_type(const MOBIPdbRecord *record) {\n    /* Kindle supports GIF, BMP, JPG, PNG, SVG images. */\n    /* GIF: 47 49 46 38 37 61 (GIF87a), 47 49 46 38 39 61 (GIF89a) */\n    /* BMP: 42 4D (BM) + 4 byte file length le */\n    /* JPG: FF D8 FF (header) + FF D9 (trailer) */\n    /* PNG: 89 50 4E 47 0D 0A 1A 0A */\n    /* SVG is XML-based format, so stored in flow parts */\n    /* FONT: must be decoded */\n    if (record->size < 4) {\n        return T_UNKNOWN;\n    }\n    const unsigned char jpg_magic[] = \"\\xff\\xd8\\xff\";\n    const unsigned char gif_magic[] = \"\\x47\\x49\\x46\\x38\";\n    const unsigned char png_magic[] = \"\\x89\\x50\\x4e\\x47\\x0d\\x0a\\x1a\\x0a\";\n    const unsigned char bmp_magic[] = \"\\x42\\x4d\";\n    const unsigned char font_magic[] = FONT_MAGIC;\n    const unsigned char audio_magic[] = AUDI_MAGIC;\n    const unsigned char video_magic[] = VIDE_MAGIC;\n    const unsigned char boundary_magic[] = BOUNDARY_MAGIC;\n    const unsigned char eof_magic[] = EOF_MAGIC;\n    if (memcmp(record->data, jpg_magic, 3) == 0) {\n        return T_JPG;\n    }\n    if (memcmp(record->data, gif_magic, 4) == 0) {\n        return T_GIF;\n    }\n    if (record->size >= 8 && memcmp(record->data, png_magic, 8) == 0) {\n        return T_PNG;\n    }\n    if (memcmp(record->data, font_magic, 4) == 0) {\n        return T_FONT;\n    }\n    if (record->size >= 8 && memcmp(record->data, boundary_magic, 8) == 0) {\n        return T_BREAK;\n    }\n    if (memcmp(record->data, eof_magic, 4) == 0) {\n        return T_BREAK;\n    }\n    if (record->size >= 6 && memcmp(record->data, bmp_magic, 2) == 0) {\n        const size_t bmp_size = mobi_get32le(&record->data[2]);\n        if (record->size == bmp_size) {\n            return T_BMP;\n        }\n    } else if (memcmp(record->data, audio_magic, 4) == 0) {\n        return T_AUDIO;\n    } else if (memcmp(record->data, video_magic, 4) == 0) {\n        return T_VIDEO;\n    }\n    return T_UNKNOWN;\n}\n\n/**\n @brief Check if loaded MOBI data is KF7/KF8 hybrid file\n \n @param[in] m MOBIData structure with loaded Record(s) 0 headers\n @return true or false\n */\nbool mobi_is_hybrid(const MOBIData *m) {\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return false;\n    }\n    if (m->kf8_boundary_offset != MOBI_NOTSET) {\n        return true;\n    }\n    return false;\n}\n\n/**\n @brief Check if loaded document is MOBI/BOOK Mobipocket format\n \n @param[in] m MOBIData structure with loaded Record(s) 0 headers\n @return true or false\n */\nbool mobi_is_mobipocket(const MOBIData *m) {\n    if (m == NULL || m->ph == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return false;\n    }\n    if (strcmp(m->ph->type, \"BOOK\") == 0 &&\n        strcmp(m->ph->creator, \"MOBI\") == 0) {\n        return true;\n    }\n    return false;\n}\n\n/**\n @brief Check if loaded document is TEXt/REAd format\n \n @param[in] m MOBIData structure with loaded Record(s) 0 headers\n @return true or false\n */\nbool mobi_is_textread(const MOBIData *m) {\n    if (m == NULL || m->ph == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return false;\n    }\n    if (strcmp(m->ph->type, \"TEXt\") == 0 &&\n        strcmp(m->ph->creator, \"REAd\") == 0) {\n        return true;\n    }\n    return false;\n}\n\n/**\n @brief Check if loaded document is dictionary\n \n @param[in] m MOBIData structure with loaded mobi header\n @return true or false\n */\nbool mobi_is_dictionary(const MOBIData *m) {\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return false;\n    }\n    /* FIXME: works only for old non-KF8 formats */\n    if (mobi_get_fileversion(m) < 8 && mobi_exists_orth(m)) {\n        debug_print(\"%s\", \"Dictionary detected\\n\");\n        return true;\n    }\n    return false;\n}\n\n/**\n @brief Check if loaded document is encrypted\n \n @param[in] m MOBIData structure with loaded Record(s) 0 headers\n @return true or false\n */\nbool mobi_is_encrypted(const MOBIData *m) {\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return false;\n    }\n    if ((mobi_is_mobipocket(m) || mobi_is_textread(m)) && m->rh &&\n        (m->rh->encryption_type == MOBI_ENCRYPTION_V1 ||\n         m->rh->encryption_type == MOBI_ENCRYPTION_V2)) {\n        return true;\n    }\n    return false;\n}\n\n/**\n @brief Check if DRM key is set for the document\n \n @param[in] m MOBIData structure with loaded Record(s) 0 headers\n @return true or false\n */\nbool mobi_has_drmkey(const MOBIData *m) {\n#ifdef USE_ENCRYPTION\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return false;\n    }\n    MOBIDrm *drm = m->internals;\n    return drm != NULL && drm->key != NULL;\n#else\n    UNUSED(m);\n    return false;\n#endif\n}\n\n/**\n @brief Check if DRM cookies are set for the document\n \n @param[in] m MOBIData structure with loaded Record(s) 0 headers\n @return true or false\n */\nbool mobi_has_drmcookies(const MOBIData *m) {\n#ifdef USE_ENCRYPTION\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return false;\n    }\n    MOBIDrm *drm = m->internals;\n    return drm != NULL && drm->cookies_count > 0;\n#else\n    UNUSED(m);\n    return false;\n#endif\n}\n\n/**\n @brief Check if loaded document is Print Replica type\n\n @param[in] m MOBIData structure with loaded Record(s) 0 headers\n @return true or false\n */\nbool mobi_is_replica(const MOBIData *m) {\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return false;\n    }\n    if (m->rec && m->rh && m->rh->compression_type == MOBI_COMPRESSION_NONE) {\n        MOBIPdbRecord *rec = m->rec->next;\n        if (rec && rec->size >= sizeof(REPLICA_MAGIC)) {\n            return memcmp(rec->data, REPLICA_MAGIC, sizeof(REPLICA_MAGIC) - 1) == 0;\n        }\n    }\n    return false;\n}\n\n/**\n @brief Get mobi file version\n \n @param[in] m MOBIData structure with loaded Record(s) 0 headers\n @return MOBI document version, 1 if ancient version (no MOBI header) or MOBI_NOTSET if error\n */\nsize_t mobi_get_fileversion(const MOBIData *m) {\n    size_t version = 1;\n    if (m == NULL || m->ph == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return MOBI_NOTSET;\n    }\n    if (strcmp(m->ph->type, \"BOOK\") == 0 && strcmp(m->ph->creator, \"MOBI\") == 0) {\n        if (m->mh && m->mh->header_length) {\n            uint32_t header_length = *m->mh->header_length;\n            if (header_length < MOBI_HEADER_V2_SIZE) {\n                version = 2;\n            } else if (m->mh->version && *m->mh->version > 1) {\n                if ((*m->mh->version > 2 && header_length < MOBI_HEADER_V3_SIZE)\n                    || (*m->mh->version > 3 && header_length < MOBI_HEADER_V4_SIZE)\n                    ||(*m->mh->version > 5 && header_length < MOBI_HEADER_V5_SIZE)) {\n                    return MOBI_NOTSET;\n                }\n                version = *m->mh->version;\n            }\n        }\n    }\n    return version;\n}\n\n/**\n @brief Is file version 8 or above\n \n @param[in] m MOBIData structure with loaded Record(s) 0 headers\n @return True if file version is 8 or greater\n */\nbool mobi_is_kf8(const MOBIData *m) {\n    const size_t version = mobi_get_fileversion(m);\n    if (version != MOBI_NOTSET && version >= 8) {\n        return true;\n    }\n    return false;\n}\n\n/**\n @brief Is file version 8 or above\n \n @param[in] rawml MOBIRawml structure with parsed document\n @return True if file version is 8 or greater\n */\nbool mobi_is_rawml_kf8(const MOBIRawml *rawml) {\n    if (rawml && rawml->version != MOBI_NOTSET && rawml->version >= 8) {\n        return true;\n    }\n    return false;\n}\n\n/**\n @brief Get maximal size of uncompressed text record\n \n @param[in] m MOBIData structure with loaded Record(s) 0 headers\n @return Size of text or MOBI_NOTSET if error\n */\nuint16_t mobi_get_textrecord_maxsize(const MOBIData *m) {\n    uint16_t max_record_size = RECORD0_TEXT_SIZE_MAX;\n    if (m && m->rh) {\n        if (m->rh->text_record_size > RECORD0_TEXT_SIZE_MAX) {\n            max_record_size = m->rh->text_record_size;\n        }\n        if (mobi_exists_mobiheader(m) && mobi_get_fileversion(m) <= 3) {\n            /* workaround for some old files with records larger than declared record size */\n            size_t text_length = (size_t) max_record_size * m->rh->text_record_count;\n            if (text_length <= RAWTEXT_SIZEMAX && m->rh->text_length > text_length) {\n                max_record_size = RECORD0_TEXT_SIZE_MAX * 2;\n            }\n        }\n    }\n    return max_record_size;\n}\n\n/**\n @brief Get maximal size of all uncompressed text records\n \n @param[in] m MOBIData structure with loaded Record(s) 0 headers\n @return Size of text or MOBI_NOTSET if error\n */\nsize_t mobi_get_text_maxsize(const MOBIData *m) {\n    if (m && m->rh) {\n        /* FIXME: is it safe to use data from Record 0 header? */\n        if (m->rh->text_record_count > 0) {\n            uint16_t max_record_size = mobi_get_textrecord_maxsize(m);\n            size_t maxsize = (size_t) m->rh->text_record_count * (size_t) max_record_size;\n            if (mobi_exists_mobiheader(m) && mobi_get_fileversion(m) <= 3) {\n                /* workaround for some old files with records larger than declared record size */\n                if (m->rh->text_length > maxsize) {\n                    maxsize = m->rh->text_length;\n                }\n            }\n            if (maxsize > RAWTEXT_SIZEMAX) {\n                debug_print(\"Raw text too large (%zu)\\n\", maxsize);\n                return MOBI_NOTSET;\n            }\n            return maxsize;\n        }\n    }\n    return MOBI_NOTSET;\n}\n\n/**\n @brief Get sequential number of first resource record (image/font etc)\n \n @param[in] m MOBIData structure with loaded Record(s) 0 headers\n @return Record number or MOBI_NOTSET if not set\n */\nsize_t mobi_get_first_resource_record(const MOBIData *m) {\n    /* is it hybrid file? */\n    if (mobi_is_hybrid(m) && m->use_kf8) {\n        /* get first image index from KF7 mobi header */\n        if (m->next->mh->image_index) {\n            return *m->next->mh->image_index;\n        }\n    }\n    /* try to get it from currently set mobi header */\n    if (m->mh && m->mh->image_index) {\n        return *m->mh->image_index;\n    }\n    return MOBI_NOTSET;\n}\n\n\n/**\n @brief Calculate exponentiation for unsigned base and exponent\n \n @param[in] base Base\n @param[in] exp Exponent\n @return Result of base raised by the exponent exp\n */\nsize_t mobi_pow(unsigned base, unsigned exp) {\n    size_t result = 1;\n    while(exp) {\n        if (exp & 1) {\n            result *= base;\n        }\n        exp >>= 1;\n        base *= base;\n    }\n    return result;\n}\n\n/**\n @brief Decode positive number from base 32 to base 10.\n \n Base 32 characters must be upper case.\n Maximal supported value is VVVVVV.\n \n @param[in,out] decoded Base 10 output number\n @param[in] encoded Base 32 input number\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_base32_decode(uint32_t *decoded, const char *encoded) {\n    if (!encoded || !decoded) {\n        debug_print(\"Error, null parameter (decoded: %p, encoded: %p)\\n\", (void *) decoded, (void *) encoded);\n        return MOBI_PARAM_ERR;\n    }\n    /* strip leading zeroes */\n    while (*encoded == '0') {\n        encoded++;\n    }\n    size_t encoded_length = strlen(encoded);\n    /* Let's limit input to 6 chars. VVVVVV(32) is 0x3FFFFFFF */\n    if (encoded_length > 6) {\n        debug_print(\"Base 32 number too big: %s\\n\", encoded);\n        return MOBI_PARAM_ERR;\n    }\n    const unsigned char *c =  (unsigned char *) encoded;\n    unsigned len = (unsigned) encoded_length;\n    const unsigned base = 32;\n    *decoded = 0;\n    unsigned value;\n    while (*c) {\n        /* FIXME: not portable, should we care? */\n        if (*c >= 'A' && *c <= 'V') {\n            value = *c - 'A' + 10;\n        }\n        else if (*c >= '0' && *c <= '9') {\n            value = *c - '0';\n        }\n        else {\n            debug_print(\"Illegal character: \\\"%c\\\"\\n\", *c);\n            return MOBI_DATA_CORRUPT;\n        }\n        *decoded += value * mobi_pow(base, --len);\n        c++;\n    }\n    return MOBI_SUCCESS;\n}\n\n\n/**\n @brief Get offset of KF8 Boundary for KF7/KF8 hybrid file cached in MOBIData structure\n \n @param[in] m MOBIData structure\n @return KF8 Boundary sequential number or zero if not found\n */\nsize_t mobi_get_kf8offset(const MOBIData *m) {\n    /* check if we want to parse KF8 part of joint file */\n    if (m->use_kf8 && m->kf8_boundary_offset != MOBI_NOTSET) {\n        return m->kf8_boundary_offset + 1;\n    }\n    return 0;\n}\n\n/**\n @brief Get sequential number of KF8 Boundary record for KF7/KF8 hybrid file\n \n This function gets KF8 boundary offset from EXTH header\n \n @param[in] m MOBIData structure\n @return KF8 Boundary record sequential number or MOBI_NOTSET if not found\n */\nsize_t mobi_get_kf8boundary_seqnumber(const MOBIData *m) {\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return MOBI_NOTSET;\n    }\n    const MOBIExthHeader *exth_tag = mobi_get_exthrecord_by_tag(m, EXTH_KF8BOUNDARY);\n    if (exth_tag != NULL) {\n        uint32_t rec_number = mobi_decode_exthvalue(exth_tag->data, exth_tag->size);\n        rec_number--;\n        const MOBIPdbRecord *record = mobi_get_record_by_seqnumber(m, rec_number);\n        if (record && record->size >= sizeof(BOUNDARY_MAGIC) - 1) {\n            if (memcmp(record->data, BOUNDARY_MAGIC, sizeof(BOUNDARY_MAGIC) - 1) == 0) {\n                return rec_number;\n            }\n        }\n    }\n    return MOBI_NOTSET;\n}\n\n/**\n @brief Get size of serialized exth record including padding\n \n @param[in] m MOBIData structure\n @return Size of exth record, zero on failure\n */\nuint32_t mobi_get_exthsize(const MOBIData *m) {\n    if (m == NULL || m->eh == NULL) {\n        return 0;\n    }\n    size_t size = 0;\n    MOBIExthHeader *curr = m->eh;\n    while (curr) {\n        size += curr->size + 8;\n        curr = curr->next;\n    }\n    if (size > 0) {\n        /* add header size */\n        size += 12;\n        /* add padding */\n        size += size % 4;\n    }\n    if (size > UINT32_MAX) {\n        return 0;\n    }\n    return (uint32_t) size;\n}\n\n/**\n @brief Get size of serialized DRM data\n \n @param[in] m MOBIData structure\n @return Size of DRM data, zero on failure\n */\nuint32_t mobi_get_drmsize(const MOBIData *m) {\n    if (m == NULL || !mobi_is_encrypted(m)) {\n        return 0;\n    }\n    size_t size = 0;\n    \n    if (m->rh->encryption_type == MOBI_ENCRYPTION_V1) {\n        size = 51;\n    } else if (m->mh && m->mh->drm_size && *m->mh->drm_size > 0) {\n        size = *m->mh->drm_size;\n    }\n    \n    if (size > UINT32_MAX) {\n        return 0;\n    }\n    return (uint32_t) size;\n}\n\n/**\n @brief Get count of palm database records\n \n @param[in] m MOBIData structure\n @return Count of records, zero on failure\n */\nuint16_t mobi_get_records_count(const MOBIData *m) {\n    size_t count = 0;\n    if (m->rec) {\n        MOBIPdbRecord *curr = m->rec;\n        while (curr) {\n            count++;\n            curr = curr->next;\n        }\n    }\n    if (count > UINT16_MAX) {\n        return 0;\n    }\n    return (uint16_t) count;\n}\n\n/**\n @brief Remove null characters from char buffer\n \n @param[in,out] buffer Character buffer\n @param[in,out] len Size of buffer, will be updated with new length\n */\nvoid mobi_remove_zeros(unsigned char *buffer, size_t *len) {\n    size_t length = *len;\n    unsigned char *end = buffer + length;\n    unsigned char *buf = memchr(buffer, 0, length);\n    if (buf == NULL) {\n        return;\n    }\n    buf++;\n    size_t distance = 1;\n    while (buf < end) {\n        if (*buf) {\n            *(buf - distance) = *buf;\n        } else {\n            distance++;\n        }\n        buf++;\n    }\n    *len -= distance;\n}\n\n/**\n @brief Loader will parse KF7 part of hybrid file\n \n @param[in,out] m MOBIData structure\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_parse_kf7(MOBIData *m) {\n    if (m == NULL) {\n        return MOBI_INIT_FAILED;\n    }\n    m->use_kf8 = false;\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Loader will parse KF8 part of hybrid file\n \n This is the default option.\n \n @param[in,out] m MOBIData structure\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_parse_kf8(MOBIData *m) {\n    if (m == NULL) {\n        return MOBI_INIT_FAILED;\n    }\n    m->use_kf8 = true;\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Remove KF7 version from  hybrid file\n  \n @param[in,out] m MOBIData structure\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_remove_part_kf7(MOBIData *m) {\n    \n    // move resource records to KF8 part\n    \n    size_t start_kf7 = MOBI_NOTSET;\n    size_t start_kf8 = MOBI_NOTSET;\n    size_t count_kf7 = MOBI_NOTSET;\n    size_t count_kf8 = MOBI_NOTSET;\n    \n    // switch to KF7 data\n    if (m->use_kf8) {\n        mobi_swap_mobidata(m);\n        m->use_kf8 = false;\n    }\n    if (m->mh == NULL) {\n        debug_print(\"%s\\n\", \"Mobi header for version 7 missing\");\n        return MOBI_INIT_FAILED;\n    }\n    if (m->mh->image_index) {\n        start_kf7 = *m->mh->image_index;\n    }\n    MOBIExthHeader *exth = mobi_get_exthrecord_by_tag(m, EXTH_COUNTRESOURCES);\n    if (exth) {\n        count_kf7 = mobi_decode_exthvalue(exth->data, exth->size);\n    }\n\n    // switch back to KF8\n    mobi_swap_mobidata(m);\n    m->use_kf8 = true;\n\n    if (m->mh == NULL || m->kf8_boundary_offset == MOBI_NOTSET) {\n        debug_print(\"%s\\n\", \"Mobi header for version 8 missing\");\n        return MOBI_INIT_FAILED;\n    }\n    \n    if (m->mh->image_index) {\n        start_kf8 = *m->mh->image_index;\n    }\n    \n    MOBIExthHeader *exth_resources = mobi_get_exthrecord_by_tag(m, EXTH_COUNTRESOURCES);\n    if (exth_resources) {\n        count_kf8 = mobi_decode_exthvalue(exth_resources->data, exth_resources->size);\n    }\n    \n    if (start_kf7 == MOBI_NOTSET || start_kf8 == MOBI_NOTSET ||\n        count_kf7 == MOBI_NOTSET || count_kf8 == MOBI_NOTSET ||\n        m->kf8_boundary_offset < count_kf7) {\n        return MOBI_DATA_CORRUPT;\n    }\n            \n    // move resources to KF8 part\n    MOBIPdbRecord *extracted = mobi_extract_records_by_seqnumber(m, start_kf7, &count_kf7);\n\n    m->kf8_boundary_offset -= count_kf7;\n    start_kf8 += m->kf8_boundary_offset + 1;\n\n    MOBI_RET ret = mobi_insert_records_by_seqnumber(m, extracted, start_kf8);\n    if (ret != MOBI_SUCCESS) {\n        return ret;\n    }\n    \n    // delete records from beginning to boundary (inclusive)\n    size_t count = m->kf8_boundary_offset + 1;\n\n    ret = mobi_delete_records_by_seqnumber(m, 0, &count);\n    if (ret != MOBI_SUCCESS) {\n        return ret;\n    }\n    m->kf8_boundary_offset = MOBI_NOTSET;\n    mobi_free_next(m);\n    \n    // update EXTH tags\n    \n    // update EXTH Count of Resources tag\n    count_kf8 += count_kf7;\n    if (exth_resources && exth_resources->size == 4 && count_kf8 <= UINT32_MAX) {\n        uint32_t value = (uint32_t) count_kf8;\n        unsigned char *p = exth_resources->data;\n        *p++ = (uint8_t)((uint32_t)(value & 0xff000000U) >> 24);\n        *p++ = (uint8_t)((uint32_t)(value & 0xff0000U) >> 16);\n        *p++ = (uint8_t)((uint32_t)(value & 0xff00U) >> 8);\n        *p = (uint8_t)((uint32_t)(value & 0xffU));\n    }\n    \n    // check that EXTH Start Reading tag points to text, delete otherwise\n    MOBIExthHeader *exth_start = NULL;\n    while ((exth = mobi_next_exthrecord_by_tag(m, EXTH_STARTREADING, &exth_start))) {\n        uint32_t offset = mobi_decode_exthvalue(exth->data, exth->size);\n        if (offset > m->rh->text_record_count) {\n            mobi_delete_exthrecord(m, exth);\n        }\n    }\n    \n    // reset KF8 related EXTH flags\n    if (m->mh->exth_flags) {\n        *m->mh->exth_flags &= 0x7ff;\n        *m->mh->exth_flags |= 0x800;\n    }\n    \n    // adjust record offsets\n    if (m->mh->fdst_index && *m->mh->fdst_index + count_kf7 < UINT32_MAX) {\n        *m->mh->fdst_index += count_kf7;\n    }\n    if (m->mh->fcis_index && *m->mh->fcis_index + count_kf7 < UINT32_MAX) {\n        *m->mh->fcis_index += count_kf7;\n    }\n    if (m->mh->flis_index && *m->mh->flis_index + count_kf7 < UINT32_MAX) {\n        *m->mh->flis_index += count_kf7;\n    }\n    if (m->mh->datp_index && *m->mh->datp_index + count_kf7 < UINT32_MAX) {\n        *m->mh->datp_index += count_kf7;\n    }\n    if (m->mh->datp_rec_index && *m->mh->datp_rec_index + count_kf7 < UINT32_MAX) {\n        *m->mh->datp_rec_index += count_kf7;\n    }\n    \n    return MOBI_SUCCESS;\n}\n\n\n/**\n @brief Remove KF8 version from  hybrid file\n  \n @param[in,out] m MOBIData structure\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_remove_part_kf8(MOBIData *m) {\n        \n    if (m->use_kf8) {\n        mobi_swap_mobidata(m);\n        m->use_kf8 = false;\n    }\n    \n    if (m->mh == NULL) {\n        debug_print(\"%s\\n\", \"Mobi header missing\");\n        return MOBI_INIT_FAILED;\n    }\n\n    // delete records from boundary (inclusive) up to last eof (exclusive)\n    size_t start = m->kf8_boundary_offset;\n    size_t count = mobi_get_records_count(m);\n    if (start == MOBI_NOTSET || count <= start) {\n        debug_print(\"%s\\n\", \"Bad records range data\");\n        return MOBI_DATA_CORRUPT;\n    }\n    count -= start + 1;\n    MOBI_RET ret = mobi_delete_records_by_seqnumber(m, start, &count);\n    if (ret != MOBI_SUCCESS) {\n        return ret;\n    }\n    \n    // delete source and logs records\n    if (m->mh->srcs_index && m->mh->srcs_count) {\n        start = *m->mh->srcs_index;\n        count = *m->mh->srcs_count;\n        if (start != MOBI_NOTSET && count != MOBI_NOTSET) {\n            ret = mobi_delete_records_by_seqnumber(m, start, &count);\n            if (ret != MOBI_SUCCESS) {\n                return ret;\n            }\n            *m->mh->srcs_index = MOBI_NOTSET;\n            *m->mh->srcs_count = 0;\n        }\n    }\n    \n    // truncate obsolete FONT, RESC records\n    if (m->mh->image_index && (start = *m->mh->image_index) != MOBI_NOTSET) {\n        MOBIPdbRecord *curr = mobi_get_record_by_seqnumber(m, start);\n        while (curr != NULL) {\n            if (curr->data && curr->size > 4 &&\n                (memcmp(curr->data, FONT_MAGIC, 4) == 0 ||\n                 memcmp(curr->data, RESC_MAGIC, 4) == 0)) {\n                unsigned char *tmp = realloc(curr->data, 4);\n                if (tmp == NULL) {\n                    debug_print(\"%s\\n\", \"Memory allocation failed\");\n                    return MOBI_MALLOC_FAILED;\n                }\n                curr->data = tmp;\n                curr->size = 4;\n            }\n            curr = curr->next;\n        }\n    }\n    \n    mobi_free_next(m);\n    \n    // update EXTH tags\n    MOBIExthHeader *exth = mobi_get_exthrecord_by_tag(m, EXTH_KF8BOUNDARY);\n    if (exth != NULL && exth->size == sizeof(uint32_t)) {\n        const uint32_t value = MOBI_NOTSET;\n        memcpy(exth->data, &value, exth->size);\n    }\n    \n    ret = mobi_delete_exthrecord_by_tag(m, EXTH_KF8COVERURI);\n    if (ret != MOBI_SUCCESS) {\n        return ret;\n    }\n    \n    // reset KF8 related EXTH flags\n    if (m->mh->exth_flags){\n        *m->mh->exth_flags &= 0x7ff;\n    }\n    \n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Remove one version from  hybrid file\n \n Hybrid file contains two document versions: KF8 version for devices that support new format and a version for older devices.\n \n @param[in,out] m MOBIData structure\n @param[in] remove_kf8 Remove new KF8 part if true, old part if false\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_remove_hybrid_part(MOBIData *m, const bool remove_kf8) {\n    if (m == NULL) {\n        return MOBI_INIT_FAILED;\n    }\n    if (!mobi_is_hybrid(m)) {\n        debug_print(\"%s\\n\", \"Not a hybrid, skip removing part\");\n        return MOBI_SUCCESS;\n    }\n    if (remove_kf8) {\n        return mobi_remove_part_kf8(m);\n    }\n    return mobi_remove_part_kf7(m);\n}\n\n/**\n @brief Swap KF7 and KF8 MOBIData structures in a hybrid file\n \n MOBIData structures form a circular linked list in case of hybrid files.\n By default KF8 structure is first one in the list.\n This function puts KF7 structure on the first place, so that it starts to be used by default.\n \n @param[in,out] m MOBIData structure\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_swap_mobidata(MOBIData *m) {\n    MOBIData *tmp = malloc(sizeof(MOBIData));\n    if (tmp == NULL) {\n        debug_print(\"%s\", \"Memory allocation failed while swaping data\\n\");\n        return MOBI_MALLOC_FAILED;\n    }\n    tmp->rh = m->rh;\n    tmp->mh = m->mh;\n    tmp->eh = m->eh;\n    m->rh = m->next->rh;\n    m->mh = m->next->mh;\n    m->eh = m->next->eh;\n    m->next->rh = tmp->rh;\n    m->next->mh = tmp->mh;\n    m->next->eh = tmp->eh;\n    free(tmp);\n    tmp = NULL;\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Store PID for encryption in MOBIData stucture.\n PID will be calculated from device serial number.\n \n @param[in,out] m MOBIData structure with raw data and metadata\n @param[in] serial Device serial number\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_drm_setkey_serial(MOBIData *m, const char *serial) {\n#ifdef USE_ENCRYPTION\n    return mobi_drmkey_set_serial(m, serial);\n#else\n    UNUSED(m);\n    UNUSED(serial);\n    debug_print(\"Libmobi compiled without encryption support%s\", \"\\n\");\n    return MOBI_DRM_UNSUPPORTED;\n#endif\n}\n\n/**\n @brief Add DRM voucher\n \n DRM vouncher will be used to generate pid key which is used to encrypt main encryption key.\n Pid key is based on device serial number.\n Optionally it is possible to set validity of the key. The key will be valid only within the period.\n Optionally the pid key may be generated not only from serial number but also from contents\n of selected EXTH headers. In such case the headers should be added (@see mobi_add_exthrecord)\n before calling this function and array of header tags passed as function parameter.\n \n @param[in,out] m MOBIData structure with raw data and metadata\n @param[in] serial Device serial number\n @param[in] valid_from DRM validity start time, -1 if not set\n @param[in] valid_to DRM validity end time, -1 if not set\n @param[in] tamperkeys Array of EXTH tags to include in PID generation, NULL if none\n @param[in] tamperkeys_count Count of EXTH tags\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_drm_addvoucher(MOBIData *m, const char *serial, const time_t valid_from, const time_t valid_to,\n                             const MOBIExthTag *tamperkeys, const size_t tamperkeys_count) {\n#ifdef USE_ENCRYPTION\n    return mobi_voucher_add(m, serial, valid_from, valid_to, tamperkeys, tamperkeys_count);\n\n#else\n    UNUSED(m);\n    UNUSED(serial);\n    UNUSED(valid_from);\n    UNUSED(valid_to);\n    UNUSED(tamperkeys);\n    UNUSED(tamperkeys_count);\n    debug_print(\"Libmobi compiled without encryption support%s\", \"\\n\");\n    return MOBI_DRM_UNSUPPORTED;\n#endif\n}\n\n/**\n @brief Store PID for encryption in MOBIData stucture\n \n @param[in,out] m MOBIData structure with raw data and metadata\n @param[in] pid PID\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_drm_setkey(MOBIData *m, const char *pid) {\n#ifdef USE_ENCRYPTION\n    return mobi_drmkey_set(m, pid);\n#else\n    UNUSED(m);\n    UNUSED(pid);\n    debug_print(\"Libmobi compiled without encryption support%s\", \"\\n\");\n    return MOBI_DRM_UNSUPPORTED;\n#endif\n}\n\n/**\n @brief Remove PID stored for encryption from MOBIData structure\n \n @param[in,out] m MOBIData structure with raw data and metadata\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_drm_delkey(MOBIData *m) {\n#ifdef USE_ENCRYPTION\n    return mobi_drmkey_delete(m);\n#else\n    UNUSED(m);\n    debug_print(\"Libmobi compiled without encryption support%s\", \"\\n\");\n    return MOBI_DRM_UNSUPPORTED;\n#endif\n}\n\n/**\n @brief Free internals\n\n @param[in,out] m MOBIData structure with raw data and metadata\n */\nvoid mobi_free_internals(MOBIData *m) {\n#ifdef USE_ENCRYPTION\n    mobi_free_drm(m);\n#else\n    UNUSED(m);\n#endif\n}\n\n/**\n @brief Convert char buffer to 32-bit unsigned integer big endian\n \n @param[in] buf Input buffer\n @return Converted value\n */\nuint32_t mobi_get32be(const unsigned char buf[4]) {\n    uint32_t val = (uint32_t) buf[0] << 24;\n    val |= (uint32_t) buf[1] << 16;\n    val |= (uint32_t) buf[2] << 8;\n    val |= (uint32_t) buf[3];\n    return val;\n}\n\n/**\n @brief Convert char buffer to 32-bit unsigned integer little endian\n \n @param[in] buf Input buffer\n @return Converted value\n */\nuint32_t mobi_get32le(const unsigned char buf[4]) {\n    uint32_t val = (uint32_t) buf[0];\n    val |= (uint32_t) buf[1] << 8;\n    val |= (uint32_t) buf[2] << 16;\n    val |= (uint32_t) buf[3] << 24;\n    return val;\n}\n", "/** @file common.c\n *\n * @brief common tools functions\n *\n * @example common.c\n * Common functions for tools\n *\n * Copyright (c) 2016 Bartek Fabiszewski\n * http://www.fabiszewski.net\n *\n * Licensed under LGPL, either version 3, or any later.\n * See <http://www.gnu.org/licenses/>\n */\n\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <mobi.h>\n#include \"common.h\"\n\n#ifdef _WIN32\n# include <direct.h>\n# define mkdir(path,flags) _mkdir(path)\nconst char separator = '\\\\';\n#else\nconst char separator = '/';\n#endif\nbool outdir_opt = false;\nchar outdir[FILENAME_MAX];\n\n#define UNUSED(x) (void)(x)\n\n#ifndef min\n# define min(a, b) ((a) < (b) ? (a) : (b))\n#endif\n\n/**\n @brief Messages for libmobi return codes\n For reference see enum MOBI_RET in mobi.h\n */\nconst char *libmobi_messages[] = {\n    \"Success\",\n    \"Generic error\",\n    \"Wrong function parameter\",\n    \"Corrupted data\",\n    \"File not found\",\n    \"Document is encrypted\",\n    \"Unsupported document format\",\n    \"Memory allocation error\",\n    \"Initialization error\",\n    \"Buffer error\",\n    \"XML error\",\n    \"Invalid DRM pid\",\n    \"DRM key not found\",\n    \"DRM support not included\",\n    \"Write failed\",\n    \"DRM expired\"\n};\n\n#define LIBMOBI_MSG_COUNT ARRAYSIZE(libmobi_messages)\n\n/**\n @brief Return message for given libmobi return code\n @param[in] ret Libmobi return code\n @return Message string\n */\nconst char * libmobi_msg(const MOBI_RET ret) {\n    size_t index = ret;\n    if (index < LIBMOBI_MSG_COUNT) {\n        return libmobi_messages[index];\n    }\n    return \"Unknown error\";\n}\n\n/**\n @brief Parse file name into file path and base name.\n        Dirname or basename can be skipped by setting to null.\n @param[in] fullpath Full file path\n @param[in,out] dirname Will be set to full dirname\n @param[in,out] basename Will be set to file basename\n @param[in] buf_len Size of each ouput buffer: dirname and basename\n */\nvoid split_fullpath(const char *fullpath, char *dirname, char *basename, const size_t buf_len) {\n    if (buf_len == 0) {\n        return;\n    }\n    char *p = strrchr(fullpath, separator);\n    if (p) {\n        p += 1;\n        if (dirname) {\n            size_t dirlen = min(buf_len - 1, (size_t) (p - fullpath));\n            strncpy(dirname, fullpath, dirlen);\n            dirname[dirlen] = '\\0';\n        }\n        if (basename) {\n            strncpy(basename, p, buf_len - 1);\n            basename[buf_len - 1] = '\\0';\n        }\n    }\n    else {\n        if (dirname) {\n            dirname[0] = '\\0';\n        }\n        if (basename) {\n            strncpy(basename, fullpath, buf_len - 1);\n            basename[buf_len - 1] = '\\0';\n        }\n    }\n    if (basename) {\n        p = strrchr(basename, '.');\n        if (p) {\n            *p = '\\0';\n        }\n    }\n}\n\n/**\n @brief Make directory\n @param[in] path Path\n @return SUCCESS or ERROR\n */\nint make_directory(const char *path) {\n    errno = 0;\n    if (mkdir(path, S_IRWXU) != 0 && errno != EEXIST) {\n        int errsv = errno;\n        printf(\"Creating directory \\\"%s\\\" failed (%s)\\n\", path, strerror(errsv));\n        return ERROR;\n    }\n    return SUCCESS;\n}\n\n/**\n @brief Create subfolder in directory\n @param[in,out] newdir Path to created subfolder\n @param[in] buf_len Buffer size fo created subfolder\n @param[in] parent_dir Directory path\n @param[in] subdir_name Subfolder name\n @return SUCCESS or ERROR\n */\nint create_subdir(char *newdir, const size_t buf_len, const char *parent_dir, const char *subdir_name) {\n    int n = snprintf(newdir, buf_len, \"%s%c%s\", parent_dir, separator, subdir_name);\n    if (n < 0) {\n        printf(\"Creating file name failed\\n\");\n        return ERROR;\n    }\n    if ((size_t) n >= buf_len) {\n        printf(\"File name too long: %s\\n\", newdir);\n        return ERROR;\n    }\n    return make_directory(newdir);\n}\n\n/**\n @brief Open file descriptor and write buffer to it\n @param[in] buffer Buffer\n @param[in] len Buffer length\n @param[in] path File path\n @return SUCCESS or ERROR\n */\nint write_file(const unsigned char *buffer, const size_t len, const char *path) {\n    errno = 0;\n    FILE *file = fopen(path, \"wb\");\n    if (file == NULL) {\n        int errsv = errno;\n        printf(\"Could not open file for writing: %s (%s)\\n\", path, strerror(errsv));\n        return ERROR;\n    }\n    size_t n = fwrite(buffer, 1, len, file);\n    if (n != len) {\n        int errsv = errno;\n        printf(\"Error writing to file: %s (%s)\\n\", path, strerror(errsv));\n        fclose(file);\n        return ERROR;\n    }\n    fclose(file);\n    return SUCCESS;\n}\n\n/**\n @brief Write content to file in directory\n @param[in] dir Directory path\n @param[in] name File name\n @param[in] buffer Buffer\n @param[in] len Buffer length\n @return SUCCESS or ERROR\n */\nint write_to_dir(const char *dir, const char *name, const unsigned char *buffer, const size_t len) {\n    char path[FILENAME_MAX];\n    int n = snprintf(path, sizeof(path), \"%s%c%s\", dir, separator, name);\n    if (n < 0) {\n        printf(\"Creating file name failed\\n\");\n        return ERROR;\n    }\n    if ((size_t) n >= sizeof(path)) {\n        printf(\"File name too long\\n\");\n        return ERROR;\n    }\n    return write_file(buffer, len, path);\n}\n\n/**\n @brief Check whether given path exists and is a directory\n @param[in] path Path to be tested\n @return True if directory exists, false otherwise\n */\nbool dir_exists(const char *path) {\n    struct stat sb;\n    if (stat(path, &sb) != 0) {\n        int errsv = errno;\n        printf(\"Path \\\"%s\\\" is not accessible (%s)\\n\", path, strerror(errsv));\n        return false;\n    }\n    if (!S_ISDIR(sb.st_mode)) {\n        printf(\"Path \\\"%s\\\" is not a directory\\n\", path);\n        return false;\n    }\n    return true;\n}\n\n/**\n @brief Make sure we use consistent separators on Windows builds\n @param[in,out] path Path to be fixed\n */\nvoid normalize_path(char *path) {\n#ifdef _WIN32\n    if (path != NULL) {\n        for (size_t i = 0; i <= strlen(path); i++) {\n            if (path[i] == '/') {\n                path[i] = separator;\n            }\n        }\n    }\n#else\n    UNUSED(path);\n#endif\n}\n\n\n/**\n @brief Print summary meta information\n @param[in] m MOBIData structure\n */\nvoid print_summary(const MOBIData *m) {\n    char *title = mobi_meta_get_title(m);\n    if (title) {\n        printf(\"Title: %s\\n\", title);\n        free(title);\n    }\n    char *author = mobi_meta_get_author(m);\n    if (author) {\n        printf(\"Author: %s\\n\", author);\n        free(author);\n    }\n    char *contributor = mobi_meta_get_contributor(m);\n    uint32_t major = 0, minor = 0, build = 0;\n    bool is_calibre = false;\n    if (contributor) {\n        const char *calibre_contributor = \"calibre (\";\n        if (strncmp(contributor, calibre_contributor, strlen(calibre_contributor)) == 0) {\n            is_calibre = true;\n            sscanf(contributor, \"calibre (%u.%u.%u)\", &major, &minor, &build);\n        } else {\n            printf(\"Contributor: %s\\n\", contributor);\n        }\n        free(contributor);\n    }\n    char *subject = mobi_meta_get_subject(m);\n    if (subject) {\n        printf(\"Subject: %s\\n\", subject);\n        free(subject);\n    }\n    char *publisher = mobi_meta_get_publisher(m);\n    if (publisher) {\n        printf(\"Publisher: %s\\n\", publisher);\n        free(publisher);\n    }\n    char *date = mobi_meta_get_publishdate(m);\n    if (date) {\n        printf(\"Publishing date: %s\\n\", date);\n        free(date);\n    }\n    char *description = mobi_meta_get_description(m);\n    if (description) {\n        printf(\"Description: %s\\n\", description);\n        free(description);\n    }\n    char *review = mobi_meta_get_review(m);\n    if (review) {\n        printf(\"Review: %s\\n\", review);\n        free(review);\n    }\n    char *imprint = mobi_meta_get_imprint(m);\n    if (imprint) {\n        printf(\"Imprint: %s\\n\", imprint);\n        free(imprint);\n    }\n    char *copyright = mobi_meta_get_copyright(m);\n    if (copyright) {\n        printf(\"Copyright: %s\\n\", copyright);\n        free(copyright);\n    }\n    char *isbn = mobi_meta_get_isbn(m);\n    if (isbn) {\n        printf(\"ISBN: %s\\n\", isbn);\n        free(isbn);\n    }\n    char *asin = mobi_meta_get_asin(m);\n    if (asin) {\n        printf(\"ASIN: %s\\n\", asin);\n        free(asin);\n    }\n    char *language = mobi_meta_get_language(m);\n    if (language) {\n        printf(\"Language: %s\", language);\n        free(language);\n        if (m->mh && m->mh->text_encoding) {\n            uint32_t encoding = *m->mh->text_encoding;\n            if (encoding == MOBI_CP1252) {\n                printf(\" (cp1252)\");\n            } else if (encoding == MOBI_UTF8) {\n                printf(\" (utf8)\");\n            }\n        }\n        printf(\"\\n\");\n    }\n    if (mobi_is_dictionary(m)) {\n        printf(\"Dictionary\");\n        if (m->mh && m->mh->dict_input_lang && m->mh->dict_output_lang &&\n            *m->mh->dict_input_lang && *m->mh->dict_output_lang) {\n            const char *locale_in = mobi_get_locale_string(*m->mh->dict_input_lang);\n            const char *locale_out = mobi_get_locale_string(*m->mh->dict_output_lang);\n            printf(\": %s => %s\", locale_in ? locale_in : \"unknown\", locale_out ? locale_out : \"unknown\");\n        }\n        printf(\"\\n\");\n    }\n    printf(\"__\\n\");\n    if (strcmp(m->ph->type, \"TEXt\") == 0) {\n        if (strcmp(m->ph->creator, \"TlDc\") == 0) {\n            printf(\"TealDoc\\n\");\n        } else {\n            printf(\"PalmDoc\\n\");\n        }\n    } else {\n        printf(\"Mobi version: %zu\", mobi_get_fileversion(m));\n        if (mobi_is_hybrid(m)) {\n            size_t version = mobi_get_fileversion(m->next);\n            if (version != MOBI_NOTSET) {\n                printf(\" (hybrid with version %zu)\", version);\n            }\n        }\n        printf(\"\\n\");\n    }\n    if (mobi_is_replica(m)) {\n        printf(\"Print Replica\\n\");\n    }\n    if (mobi_is_encrypted(m)) {\n        printf(\"Document is encrypted\\n\");\n    }\n    if (is_calibre) {\n        printf(\"Creator software: calibre %u.%u.%u\\n\", major, minor, build);\n    } else {\n        MOBIExthHeader *exth = mobi_get_exthrecord_by_tag(m, EXTH_CREATORSOFT);\n        if (exth) {\n            printf(\"Creator software: \");\n            uint32_t creator = mobi_decode_exthvalue(exth->data, exth->size);\n            exth = mobi_get_exthrecord_by_tag(m, EXTH_CREATORMAJOR);\n            if (exth) {\n                major = mobi_decode_exthvalue(exth->data, exth->size);\n            }\n            exth = mobi_get_exthrecord_by_tag(m, EXTH_CREATORMINOR);\n            if (exth) {\n                minor = mobi_decode_exthvalue(exth->data, exth->size);\n            }\n            exth = mobi_get_exthrecord_by_tag(m, EXTH_CREATORBUILD);\n            if (exth) {\n                build = mobi_decode_exthvalue(exth->data, exth->size);\n            }\n            exth = mobi_get_exthrecord_by_tag(m, EXTH_CREATORBUILDREV);\n            if (major == 2 && minor == 9 && build == 0 && exth) {\n                char *rev = mobi_decode_exthstring(m, exth->data, exth->size);\n                if (rev) {\n                    if (strcmp(rev, \"0730-890adc2\") == 0) {\n                        is_calibre = true;\n                    }\n                    free(rev);\n                }\n            }\n            switch (creator) {\n                case 0:\n                    printf(\"mobipocket reader %u.%u.%u\", major, minor, build);\n                    break;\n                case 1:\n                case 101:\n                    printf(\"mobigen %u.%u.%u\", major, minor, build);\n                    break;\n                case 2:\n                    printf(\"mobipocket creator %u.%u.%u\", major, minor, build);\n                    break;\n                case 200:\n                    printf(\"kindlegen %u.%u.%u (windows)\", major, minor, build);\n                    if (is_calibre) {\n                        printf(\" or calibre\");\n                    }\n                    break;\n                case 201:\n                    printf(\"kindlegen %u.%u.%u (linux)\", major, minor, build);\n                    if ((major == 1 && minor == 2 && build == 33307) ||\n                        (major == 2 && minor == 0 && build == 101) ||\n                        is_calibre) {\n                        printf(\" or calibre\");\n                    }\n                    break;\n                case 202:\n                    printf(\"kindlegen %u.%u.%u (mac)\", major, minor, build);\n                    if (is_calibre) {\n                        printf(\" or calibre\");\n                    }\n                    break;\n                default:\n                    printf(\"unknown\");\n                    break;\n            }\n            printf(\"\\n\");\n        }\n    }\n}\n\n/**\n @brief Print all loaded EXTH record tags\n @param[in] m MOBIData structure\n */\nvoid print_exth(const MOBIData *m) {\n    if (m->eh == NULL) {\n        return;\n    }\n    /* Linked list of MOBIExthHeader structures holds EXTH records */\n    const MOBIExthHeader *curr = m->eh;\n    if (curr != NULL) {\n        printf(\"\\nEXTH records:\\n\");\n    }\n    uint32_t val32;\n    while (curr != NULL) {\n        /* check if it is a known tag and get some more info if it is */\n        MOBIExthMeta tag = mobi_get_exthtagmeta_by_tag(curr->tag);\n        if (tag.tag == 0) {\n            /* unknown tag */\n            /* try to print the record both as string and numeric value */\n            char *str = malloc(curr->size + 1);\n            if (!str) {\n                printf(\"Memory allocation failed\\n\");\n                exit(1);\n            }\n            unsigned i = 0;\n            unsigned char *p = curr->data;\n            while (i < curr->size && isprint(*p)) {\n                str[i] = (char)*p++;\n                i++;\n            }\n            str[i] = '\\0';\n            val32 = mobi_decode_exthvalue(curr->data, curr->size);\n            printf(\"Unknown (%i): %s (%u)\\n\", curr->tag, str, val32);\n            free(str);\n        } else {\n            /* known tag */\n            unsigned i = 0;\n            size_t size = curr->size;\n            unsigned char *data = curr->data;\n            switch (tag.type) {\n                    /* numeric */\n                case EXTH_NUMERIC:\n                    val32 = mobi_decode_exthvalue(data, size);\n                    printf(\"%s (%i): %u\\n\", tag.name, tag.tag, val32);\n                    break;\n                    /* string */\n                case EXTH_STRING:\n                {\n                    char *exth_string = mobi_decode_exthstring(m, data, size);\n                    if (exth_string) {\n                        printf(\"%s (%i): %s\\n\", tag.name, tag.tag, exth_string);\n                        free(exth_string);\n                    }\n                    break;\n                }\n                    /* binary */\n                case EXTH_BINARY:\n                {\n                    char *str = malloc(2 * size + 1);\n                    if (!str) {\n                        printf(\"Memory allocation failed\\n\");\n                        exit(1);\n                    }\n                    str[0] = '\\0';\n                    while (size) {\n                        uint8_t val8 = *data++;\n                        sprintf(&str[i], \"%02x\", val8);\n                        i += 2;\n                        size--;\n                    }\n                    printf(\"%s (%i): 0x%s\\n\", tag.name, tag.tag, str);\n                    free(str);\n                    break;\n                }\n                default:\n                    break;\n            }\n        }\n        curr = curr->next;\n    }\n}\n\n/**\n @brief Set PID for decryption\n @param[in,out] m MOBIData structure\n @param[in] pid Serial number\n @return SUCCESS or error code\n */\nint set_decryption_pid(MOBIData *m, const char *pid) {\n    printf(\"\\nVerifying PID %s...\", pid);\n    MOBI_RET mobi_ret = mobi_drm_setkey(m, pid);\n    if (mobi_ret != MOBI_SUCCESS) {\n        printf(\"failed (%s)\\n\", libmobi_msg(mobi_ret));\n        return (int) mobi_ret;\n    }\n    printf(\"ok\\n\");\n    return SUCCESS;\n}\n\n/**\n @brief Set device serial number for decryption\n @param[in,out] m MOBIData structure\n @param[in] serial Serial number\n @return SUCCESS or error code\n */\nint set_decryption_serial(MOBIData *m, const char *serial) {\n    printf(\"\\nVerifying serial %s... \", serial);\n    MOBI_RET mobi_ret = mobi_drm_setkey_serial(m, serial);\n    if (mobi_ret != MOBI_SUCCESS) {\n        printf(\"failed (%s)\\n\", libmobi_msg(mobi_ret));\n        return (int) mobi_ret;\n    }\n    printf(\"ok\\n\");\n    return SUCCESS;\n}\n\n/**\n @brief Set key for decryption. Use user supplied pid or device serial number\n @param[in,out] m MOBIData structure\n @param[in] serial Serial number\n @param[in] pid Pid\n @return SUCCESS or error code\n */\nint set_decryption_key(MOBIData *m, const char *serial, const char *pid) {\n\n    if (!pid && !serial) {\n        return SUCCESS;\n    }\n    if (!mobi_is_encrypted(m)) {\n        printf(\"\\nDocument is not encrypted, ignoring PID/serial\\n\");\n        return SUCCESS;\n    }\n    if (m->rh && m->rh->encryption_type == MOBI_ENCRYPTION_V1) {\n        printf(\"\\nEncryption type 1, ignoring PID/serial\\n\");\n        return SUCCESS;\n    }\n    int ret = SUCCESS;\n    if (pid && (ret = set_decryption_pid(m, pid)) == SUCCESS) {\n        return SUCCESS;\n    }\n    if (serial) {\n        ret = set_decryption_serial(m, serial);\n    }\n    return ret;\n}\n\n/**\n @brief Save mobi file\n \n @param[in,out] m MOBIData struicture\n @param[in] fullpath Full file path\n @param[in] suffix Suffix appended to file name\n @return SUCCESS or ERROR\n */\nint save_mobi(MOBIData *m, const char *fullpath, const char *suffix) {\n    char outfile[FILENAME_MAX];\n    char basename[FILENAME_MAX];\n    char dirname[FILENAME_MAX];\n    split_fullpath(fullpath, dirname, basename, FILENAME_MAX);\n    const char *ext = (mobi_get_fileversion(m) >= 8) ? \"azw3\" : \"mobi\";\n    int n;\n    if (outdir_opt) {\n        n = snprintf(outfile, sizeof(outfile), \"%s%s-%s.%s\", outdir, basename, suffix, ext);\n    } else {\n        n = snprintf(outfile, sizeof(outfile), \"%s%s-%s.%s\", dirname, basename, suffix, ext);\n    }\n    if (n < 0) {\n        printf(\"Creating file name failed\\n\");\n        return ERROR;\n    }\n    if ((size_t) n >= sizeof(outfile)) {\n        printf(\"File name too long\\n\");\n        return ERROR;\n    }\n    \n    /* write */\n    printf(\"Saving %s...\\n\", outfile);\n    FILE *file_out = fopen(outfile, \"wb\");\n    if (file_out == NULL) {\n        int errsv = errno;\n        printf(\"Error opening file: %s (%s)\\n\", outfile, strerror(errsv));\n        return ERROR;\n    }\n    MOBI_RET mobi_ret = mobi_write_file(file_out, m);\n    fclose(file_out);\n    if (mobi_ret != MOBI_SUCCESS) {\n        printf(\"Error writing file (%s)\\n\", libmobi_msg(mobi_ret));\n        return ERROR;\n    }\n    return SUCCESS;\n}\n"], "filenames": ["ChangeLog", "src/opf.c", "src/util.c", "tools/common.c"], "buggy_code_start_loc": [0, 1155, 644, 333], "buggy_code_end_loc": [0, 1173, 645, 334], "fixing_code_start_loc": [1, 1155, 644, 333], "fixing_code_end_loc": [2, 1178, 645, 334], "type": "CWE-476", "message": "NULL Pointer Dereference in GitHub repository bfabiszewski/libmobi prior to 0.11.", "other": {"cve": {"id": "CVE-2022-2279", "sourceIdentifier": "security@huntr.dev", "published": "2022-07-01T09:15:09.067", "lastModified": "2022-07-08T15:32:07.590", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "NULL Pointer Dereference in GitHub repository bfabiszewski/libmobi prior to 0.11."}, {"lang": "es", "value": "Una Desreferencia de Puntero NULL en el repositorio de GitHub bfabiszewski/libmobi versiones anteriores a 0.11"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 6.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 4.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libmobi_project:libmobi:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.11", "matchCriteriaId": "6FF60ACA-0257-493F-A0F1-CD257EFDAC33"}]}]}], "references": [{"url": "https://github.com/bfabiszewski/libmobi/commit/c0699c8693c47f14a2e57dec7292e862ac7adf9c", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/68c249e2-779d-4871-b7e3-851f03aca2de", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/bfabiszewski/libmobi/commit/c0699c8693c47f14a2e57dec7292e862ac7adf9c"}}