{"buggy_code": ["/*\n * f2fs extent cache support\n *\n * Copyright (c) 2015 Motorola Mobility\n * Copyright (c) 2015 Samsung Electronics\n * Authors: Jaegeuk Kim <jaegeuk@kernel.org>\n *          Chao Yu <chao2.yu@samsung.com>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation.\n */\n\n#include <linux/fs.h>\n#include <linux/f2fs_fs.h>\n\n#include \"f2fs.h\"\n#include \"node.h\"\n#include <trace/events/f2fs.h>\n\nstatic struct rb_entry *__lookup_rb_tree_fast(struct rb_entry *cached_re,\n\t\t\t\t\t\t\tunsigned int ofs)\n{\n\tif (cached_re) {\n\t\tif (cached_re->ofs <= ofs &&\n\t\t\t\tcached_re->ofs + cached_re->len > ofs) {\n\t\t\treturn cached_re;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic struct rb_entry *__lookup_rb_tree_slow(struct rb_root *root,\n\t\t\t\t\t\t\tunsigned int ofs)\n{\n\tstruct rb_node *node = root->rb_node;\n\tstruct rb_entry *re;\n\n\twhile (node) {\n\t\tre = rb_entry(node, struct rb_entry, rb_node);\n\n\t\tif (ofs < re->ofs)\n\t\t\tnode = node->rb_left;\n\t\telse if (ofs >= re->ofs + re->len)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn re;\n\t}\n\treturn NULL;\n}\n\nstruct rb_entry *__lookup_rb_tree(struct rb_root *root,\n\t\t\t\tstruct rb_entry *cached_re, unsigned int ofs)\n{\n\tstruct rb_entry *re;\n\n\tre = __lookup_rb_tree_fast(cached_re, ofs);\n\tif (!re)\n\t\treturn __lookup_rb_tree_slow(root, ofs);\n\n\treturn re;\n}\n\nstruct rb_node **__lookup_rb_tree_for_insert(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct rb_root *root, struct rb_node **parent,\n\t\t\t\tunsigned int ofs)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_entry *re;\n\n\twhile (*p) {\n\t\t*parent = *p;\n\t\tre = rb_entry(*parent, struct rb_entry, rb_node);\n\n\t\tif (ofs < re->ofs)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (ofs >= re->ofs + re->len)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tf2fs_bug_on(sbi, 1);\n\t}\n\n\treturn p;\n}\n\n/*\n * lookup rb entry in position of @ofs in rb-tree,\n * if hit, return the entry, otherwise, return NULL\n * @prev_ex: extent before ofs\n * @next_ex: extent after ofs\n * @insert_p: insert point for new extent at ofs\n * in order to simpfy the insertion after.\n * tree must stay unchanged between lookup and insertion.\n */\nstruct rb_entry *__lookup_rb_tree_ret(struct rb_root *root,\n\t\t\t\tstruct rb_entry *cached_re,\n\t\t\t\tunsigned int ofs,\n\t\t\t\tstruct rb_entry **prev_entry,\n\t\t\t\tstruct rb_entry **next_entry,\n\t\t\t\tstruct rb_node ***insert_p,\n\t\t\t\tstruct rb_node **insert_parent,\n\t\t\t\tbool force)\n{\n\tstruct rb_node **pnode = &root->rb_node;\n\tstruct rb_node *parent = NULL, *tmp_node;\n\tstruct rb_entry *re = cached_re;\n\n\t*insert_p = NULL;\n\t*insert_parent = NULL;\n\t*prev_entry = NULL;\n\t*next_entry = NULL;\n\n\tif (RB_EMPTY_ROOT(root))\n\t\treturn NULL;\n\n\tif (re) {\n\t\tif (re->ofs <= ofs && re->ofs + re->len > ofs)\n\t\t\tgoto lookup_neighbors;\n\t}\n\n\twhile (*pnode) {\n\t\tparent = *pnode;\n\t\tre = rb_entry(*pnode, struct rb_entry, rb_node);\n\n\t\tif (ofs < re->ofs)\n\t\t\tpnode = &(*pnode)->rb_left;\n\t\telse if (ofs >= re->ofs + re->len)\n\t\t\tpnode = &(*pnode)->rb_right;\n\t\telse\n\t\t\tgoto lookup_neighbors;\n\t}\n\n\t*insert_p = pnode;\n\t*insert_parent = parent;\n\n\tre = rb_entry(parent, struct rb_entry, rb_node);\n\ttmp_node = parent;\n\tif (parent && ofs > re->ofs)\n\t\ttmp_node = rb_next(parent);\n\t*next_entry = rb_entry_safe(tmp_node, struct rb_entry, rb_node);\n\n\ttmp_node = parent;\n\tif (parent && ofs < re->ofs)\n\t\ttmp_node = rb_prev(parent);\n\t*prev_entry = rb_entry_safe(tmp_node, struct rb_entry, rb_node);\n\treturn NULL;\n\nlookup_neighbors:\n\tif (ofs == re->ofs || force) {\n\t\t/* lookup prev node for merging backward later */\n\t\ttmp_node = rb_prev(&re->rb_node);\n\t\t*prev_entry = rb_entry_safe(tmp_node, struct rb_entry, rb_node);\n\t}\n\tif (ofs == re->ofs + re->len - 1 || force) {\n\t\t/* lookup next node for merging frontward later */\n\t\ttmp_node = rb_next(&re->rb_node);\n\t\t*next_entry = rb_entry_safe(tmp_node, struct rb_entry, rb_node);\n\t}\n\treturn re;\n}\n\nbool __check_rb_tree_consistence(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tstruct rb_root *root)\n{\n#ifdef CONFIG_F2FS_CHECK_FS\n\tstruct rb_node *cur = rb_first(root), *next;\n\tstruct rb_entry *cur_re, *next_re;\n\n\tif (!cur)\n\t\treturn true;\n\n\twhile (cur) {\n\t\tnext = rb_next(cur);\n\t\tif (!next)\n\t\t\treturn true;\n\n\t\tcur_re = rb_entry(cur, struct rb_entry, rb_node);\n\t\tnext_re = rb_entry(next, struct rb_entry, rb_node);\n\n\t\tif (cur_re->ofs + cur_re->len > next_re->ofs) {\n\t\t\tf2fs_msg(sbi->sb, KERN_INFO, \"inconsistent rbtree, \"\n\t\t\t\t\"cur(%u, %u) next(%u, %u)\",\n\t\t\t\tcur_re->ofs, cur_re->len,\n\t\t\t\tnext_re->ofs, next_re->len);\n\t\t\treturn false;\n\t\t}\n\n\t\tcur = next;\n\t}\n#endif\n\treturn true;\n}\n\nstatic struct kmem_cache *extent_tree_slab;\nstatic struct kmem_cache *extent_node_slab;\n\nstatic struct extent_node *__attach_extent_node(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct extent_tree *et, struct extent_info *ei,\n\t\t\t\tstruct rb_node *parent, struct rb_node **p)\n{\n\tstruct extent_node *en;\n\n\ten = kmem_cache_alloc(extent_node_slab, GFP_ATOMIC);\n\tif (!en)\n\t\treturn NULL;\n\n\ten->ei = *ei;\n\tINIT_LIST_HEAD(&en->list);\n\ten->et = et;\n\n\trb_link_node(&en->rb_node, parent, p);\n\trb_insert_color(&en->rb_node, &et->root);\n\tatomic_inc(&et->node_cnt);\n\tatomic_inc(&sbi->total_ext_node);\n\treturn en;\n}\n\nstatic void __detach_extent_node(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct extent_tree *et, struct extent_node *en)\n{\n\trb_erase(&en->rb_node, &et->root);\n\tatomic_dec(&et->node_cnt);\n\tatomic_dec(&sbi->total_ext_node);\n\n\tif (et->cached_en == en)\n\t\tet->cached_en = NULL;\n\tkmem_cache_free(extent_node_slab, en);\n}\n\n/*\n * Flow to release an extent_node:\n * 1. list_del_init\n * 2. __detach_extent_node\n * 3. kmem_cache_free.\n */\nstatic void __release_extent_node(struct f2fs_sb_info *sbi,\n\t\t\tstruct extent_tree *et, struct extent_node *en)\n{\n\tspin_lock(&sbi->extent_lock);\n\tf2fs_bug_on(sbi, list_empty(&en->list));\n\tlist_del_init(&en->list);\n\tspin_unlock(&sbi->extent_lock);\n\n\t__detach_extent_node(sbi, et, en);\n}\n\nstatic struct extent_tree *__grab_extent_tree(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct extent_tree *et;\n\tnid_t ino = inode->i_ino;\n\n\tmutex_lock(&sbi->extent_tree_lock);\n\tet = radix_tree_lookup(&sbi->extent_tree_root, ino);\n\tif (!et) {\n\t\tet = f2fs_kmem_cache_alloc(extent_tree_slab, GFP_NOFS);\n\t\tf2fs_radix_tree_insert(&sbi->extent_tree_root, ino, et);\n\t\tmemset(et, 0, sizeof(struct extent_tree));\n\t\tet->ino = ino;\n\t\tet->root = RB_ROOT;\n\t\tet->cached_en = NULL;\n\t\trwlock_init(&et->lock);\n\t\tINIT_LIST_HEAD(&et->list);\n\t\tatomic_set(&et->node_cnt, 0);\n\t\tatomic_inc(&sbi->total_ext_tree);\n\t} else {\n\t\tatomic_dec(&sbi->total_zombie_tree);\n\t\tlist_del_init(&et->list);\n\t}\n\tmutex_unlock(&sbi->extent_tree_lock);\n\n\t/* never died until evict_inode */\n\tF2FS_I(inode)->extent_tree = et;\n\n\treturn et;\n}\n\nstatic struct extent_node *__init_extent_tree(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct extent_tree *et, struct extent_info *ei)\n{\n\tstruct rb_node **p = &et->root.rb_node;\n\tstruct extent_node *en;\n\n\ten = __attach_extent_node(sbi, et, ei, NULL, p);\n\tif (!en)\n\t\treturn NULL;\n\n\tet->largest = en->ei;\n\tet->cached_en = en;\n\treturn en;\n}\n\nstatic unsigned int __free_extent_tree(struct f2fs_sb_info *sbi,\n\t\t\t\t\tstruct extent_tree *et)\n{\n\tstruct rb_node *node, *next;\n\tstruct extent_node *en;\n\tunsigned int count = atomic_read(&et->node_cnt);\n\n\tnode = rb_first(&et->root);\n\twhile (node) {\n\t\tnext = rb_next(node);\n\t\ten = rb_entry(node, struct extent_node, rb_node);\n\t\t__release_extent_node(sbi, et, en);\n\t\tnode = next;\n\t}\n\n\treturn count - atomic_read(&et->node_cnt);\n}\n\nstatic void __drop_largest_extent(struct inode *inode,\n\t\t\t\t\tpgoff_t fofs, unsigned int len)\n{\n\tstruct extent_info *largest = &F2FS_I(inode)->extent_tree->largest;\n\n\tif (fofs < largest->fofs + largest->len && fofs + len > largest->fofs) {\n\t\tlargest->len = 0;\n\t\tf2fs_mark_inode_dirty_sync(inode, true);\n\t}\n}\n\n/* return true, if inode page is changed */\nbool f2fs_init_extent_tree(struct inode *inode, struct f2fs_extent *i_ext)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct extent_tree *et;\n\tstruct extent_node *en;\n\tstruct extent_info ei;\n\n\tif (!f2fs_may_extent_tree(inode)) {\n\t\t/* drop largest extent */\n\t\tif (i_ext && i_ext->len) {\n\t\t\ti_ext->len = 0;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tet = __grab_extent_tree(inode);\n\n\tif (!i_ext || !i_ext->len)\n\t\treturn false;\n\n\tget_extent_info(&ei, i_ext);\n\n\twrite_lock(&et->lock);\n\tif (atomic_read(&et->node_cnt))\n\t\tgoto out;\n\n\ten = __init_extent_tree(sbi, et, &ei);\n\tif (en) {\n\t\tspin_lock(&sbi->extent_lock);\n\t\tlist_add_tail(&en->list, &sbi->extent_list);\n\t\tspin_unlock(&sbi->extent_lock);\n\t}\nout:\n\twrite_unlock(&et->lock);\n\treturn false;\n}\n\nstatic bool f2fs_lookup_extent_tree(struct inode *inode, pgoff_t pgofs,\n\t\t\t\t\t\t\tstruct extent_info *ei)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct extent_tree *et = F2FS_I(inode)->extent_tree;\n\tstruct extent_node *en;\n\tbool ret = false;\n\n\tf2fs_bug_on(sbi, !et);\n\n\ttrace_f2fs_lookup_extent_tree_start(inode, pgofs);\n\n\tread_lock(&et->lock);\n\n\tif (et->largest.fofs <= pgofs &&\n\t\t\tet->largest.fofs + et->largest.len > pgofs) {\n\t\t*ei = et->largest;\n\t\tret = true;\n\t\tstat_inc_largest_node_hit(sbi);\n\t\tgoto out;\n\t}\n\n\ten = (struct extent_node *)__lookup_rb_tree(&et->root,\n\t\t\t\t(struct rb_entry *)et->cached_en, pgofs);\n\tif (!en)\n\t\tgoto out;\n\n\tif (en == et->cached_en)\n\t\tstat_inc_cached_node_hit(sbi);\n\telse\n\t\tstat_inc_rbtree_node_hit(sbi);\n\n\t*ei = en->ei;\n\tspin_lock(&sbi->extent_lock);\n\tif (!list_empty(&en->list)) {\n\t\tlist_move_tail(&en->list, &sbi->extent_list);\n\t\tet->cached_en = en;\n\t}\n\tspin_unlock(&sbi->extent_lock);\n\tret = true;\nout:\n\tstat_inc_total_hit(sbi);\n\tread_unlock(&et->lock);\n\n\ttrace_f2fs_lookup_extent_tree_end(inode, pgofs, ei);\n\treturn ret;\n}\n\nstatic struct extent_node *__try_merge_extent_node(struct inode *inode,\n\t\t\t\tstruct extent_tree *et, struct extent_info *ei,\n\t\t\t\tstruct extent_node *prev_ex,\n\t\t\t\tstruct extent_node *next_ex)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct extent_node *en = NULL;\n\n\tif (prev_ex && __is_back_mergeable(ei, &prev_ex->ei)) {\n\t\tprev_ex->ei.len += ei->len;\n\t\tei = &prev_ex->ei;\n\t\ten = prev_ex;\n\t}\n\n\tif (next_ex && __is_front_mergeable(ei, &next_ex->ei)) {\n\t\tnext_ex->ei.fofs = ei->fofs;\n\t\tnext_ex->ei.blk = ei->blk;\n\t\tnext_ex->ei.len += ei->len;\n\t\tif (en)\n\t\t\t__release_extent_node(sbi, et, prev_ex);\n\n\t\ten = next_ex;\n\t}\n\n\tif (!en)\n\t\treturn NULL;\n\n\t__try_update_largest_extent(inode, et, en);\n\n\tspin_lock(&sbi->extent_lock);\n\tif (!list_empty(&en->list)) {\n\t\tlist_move_tail(&en->list, &sbi->extent_list);\n\t\tet->cached_en = en;\n\t}\n\tspin_unlock(&sbi->extent_lock);\n\treturn en;\n}\n\nstatic struct extent_node *__insert_extent_tree(struct inode *inode,\n\t\t\t\tstruct extent_tree *et, struct extent_info *ei,\n\t\t\t\tstruct rb_node **insert_p,\n\t\t\t\tstruct rb_node *insert_parent)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct rb_node **p = &et->root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct extent_node *en = NULL;\n\n\tif (insert_p && insert_parent) {\n\t\tparent = insert_parent;\n\t\tp = insert_p;\n\t\tgoto do_insert;\n\t}\n\n\tp = __lookup_rb_tree_for_insert(sbi, &et->root, &parent, ei->fofs);\ndo_insert:\n\ten = __attach_extent_node(sbi, et, ei, parent, p);\n\tif (!en)\n\t\treturn NULL;\n\n\t__try_update_largest_extent(inode, et, en);\n\n\t/* update in global extent list */\n\tspin_lock(&sbi->extent_lock);\n\tlist_add_tail(&en->list, &sbi->extent_list);\n\tet->cached_en = en;\n\tspin_unlock(&sbi->extent_lock);\n\treturn en;\n}\n\nstatic void f2fs_update_extent_tree_range(struct inode *inode,\n\t\t\t\tpgoff_t fofs, block_t blkaddr, unsigned int len)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct extent_tree *et = F2FS_I(inode)->extent_tree;\n\tstruct extent_node *en = NULL, *en1 = NULL;\n\tstruct extent_node *prev_en = NULL, *next_en = NULL;\n\tstruct extent_info ei, dei, prev;\n\tstruct rb_node **insert_p = NULL, *insert_parent = NULL;\n\tunsigned int end = fofs + len;\n\tunsigned int pos = (unsigned int)fofs;\n\n\tif (!et)\n\t\treturn;\n\n\ttrace_f2fs_update_extent_tree_range(inode, fofs, blkaddr, len);\n\n\twrite_lock(&et->lock);\n\n\tif (is_inode_flag_set(inode, FI_NO_EXTENT)) {\n\t\twrite_unlock(&et->lock);\n\t\treturn;\n\t}\n\n\tprev = et->largest;\n\tdei.len = 0;\n\n\t/*\n\t * drop largest extent before lookup, in case it's already\n\t * been shrunk from extent tree\n\t */\n\t__drop_largest_extent(inode, fofs, len);\n\n\t/* 1. lookup first extent node in range [fofs, fofs + len - 1] */\n\ten = (struct extent_node *)__lookup_rb_tree_ret(&et->root,\n\t\t\t\t\t(struct rb_entry *)et->cached_en, fofs,\n\t\t\t\t\t(struct rb_entry **)&prev_en,\n\t\t\t\t\t(struct rb_entry **)&next_en,\n\t\t\t\t\t&insert_p, &insert_parent, false);\n\tif (!en)\n\t\ten = next_en;\n\n\t/* 2. invlidate all extent nodes in range [fofs, fofs + len - 1] */\n\twhile (en && en->ei.fofs < end) {\n\t\tunsigned int org_end;\n\t\tint parts = 0;\t/* # of parts current extent split into */\n\n\t\tnext_en = en1 = NULL;\n\n\t\tdei = en->ei;\n\t\torg_end = dei.fofs + dei.len;\n\t\tf2fs_bug_on(sbi, pos >= org_end);\n\n\t\tif (pos > dei.fofs &&\tpos - dei.fofs >= F2FS_MIN_EXTENT_LEN) {\n\t\t\ten->ei.len = pos - en->ei.fofs;\n\t\t\tprev_en = en;\n\t\t\tparts = 1;\n\t\t}\n\n\t\tif (end < org_end && org_end - end >= F2FS_MIN_EXTENT_LEN) {\n\t\t\tif (parts) {\n\t\t\t\tset_extent_info(&ei, end,\n\t\t\t\t\t\tend - dei.fofs + dei.blk,\n\t\t\t\t\t\torg_end - end);\n\t\t\t\ten1 = __insert_extent_tree(inode, et, &ei,\n\t\t\t\t\t\t\tNULL, NULL);\n\t\t\t\tnext_en = en1;\n\t\t\t} else {\n\t\t\t\ten->ei.fofs = end;\n\t\t\t\ten->ei.blk += end - dei.fofs;\n\t\t\t\ten->ei.len -= end - dei.fofs;\n\t\t\t\tnext_en = en;\n\t\t\t}\n\t\t\tparts++;\n\t\t}\n\n\t\tif (!next_en) {\n\t\t\tstruct rb_node *node = rb_next(&en->rb_node);\n\n\t\t\tnext_en = rb_entry_safe(node, struct extent_node,\n\t\t\t\t\t\trb_node);\n\t\t}\n\n\t\tif (parts)\n\t\t\t__try_update_largest_extent(inode, et, en);\n\t\telse\n\t\t\t__release_extent_node(sbi, et, en);\n\n\t\t/*\n\t\t * if original extent is split into zero or two parts, extent\n\t\t * tree has been altered by deletion or insertion, therefore\n\t\t * invalidate pointers regard to tree.\n\t\t */\n\t\tif (parts != 1) {\n\t\t\tinsert_p = NULL;\n\t\t\tinsert_parent = NULL;\n\t\t}\n\t\ten = next_en;\n\t}\n\n\t/* 3. update extent in extent cache */\n\tif (blkaddr) {\n\n\t\tset_extent_info(&ei, fofs, blkaddr, len);\n\t\tif (!__try_merge_extent_node(inode, et, &ei, prev_en, next_en))\n\t\t\t__insert_extent_tree(inode, et, &ei,\n\t\t\t\t\t\tinsert_p, insert_parent);\n\n\t\t/* give up extent_cache, if split and small updates happen */\n\t\tif (dei.len >= 1 &&\n\t\t\t\tprev.len < F2FS_MIN_EXTENT_LEN &&\n\t\t\t\tet->largest.len < F2FS_MIN_EXTENT_LEN) {\n\t\t\t__drop_largest_extent(inode, 0, UINT_MAX);\n\t\t\tset_inode_flag(inode, FI_NO_EXTENT);\n\t\t}\n\t}\n\n\tif (is_inode_flag_set(inode, FI_NO_EXTENT))\n\t\t__free_extent_tree(sbi, et);\n\n\twrite_unlock(&et->lock);\n}\n\nunsigned int f2fs_shrink_extent_tree(struct f2fs_sb_info *sbi, int nr_shrink)\n{\n\tstruct extent_tree *et, *next;\n\tstruct extent_node *en;\n\tunsigned int node_cnt = 0, tree_cnt = 0;\n\tint remained;\n\n\tif (!test_opt(sbi, EXTENT_CACHE))\n\t\treturn 0;\n\n\tif (!atomic_read(&sbi->total_zombie_tree))\n\t\tgoto free_node;\n\n\tif (!mutex_trylock(&sbi->extent_tree_lock))\n\t\tgoto out;\n\n\t/* 1. remove unreferenced extent tree */\n\tlist_for_each_entry_safe(et, next, &sbi->zombie_list, list) {\n\t\tif (atomic_read(&et->node_cnt)) {\n\t\t\twrite_lock(&et->lock);\n\t\t\tnode_cnt += __free_extent_tree(sbi, et);\n\t\t\twrite_unlock(&et->lock);\n\t\t}\n\t\tf2fs_bug_on(sbi, atomic_read(&et->node_cnt));\n\t\tlist_del_init(&et->list);\n\t\tradix_tree_delete(&sbi->extent_tree_root, et->ino);\n\t\tkmem_cache_free(extent_tree_slab, et);\n\t\tatomic_dec(&sbi->total_ext_tree);\n\t\tatomic_dec(&sbi->total_zombie_tree);\n\t\ttree_cnt++;\n\n\t\tif (node_cnt + tree_cnt >= nr_shrink)\n\t\t\tgoto unlock_out;\n\t\tcond_resched();\n\t}\n\tmutex_unlock(&sbi->extent_tree_lock);\n\nfree_node:\n\t/* 2. remove LRU extent entries */\n\tif (!mutex_trylock(&sbi->extent_tree_lock))\n\t\tgoto out;\n\n\tremained = nr_shrink - (node_cnt + tree_cnt);\n\n\tspin_lock(&sbi->extent_lock);\n\tfor (; remained > 0; remained--) {\n\t\tif (list_empty(&sbi->extent_list))\n\t\t\tbreak;\n\t\ten = list_first_entry(&sbi->extent_list,\n\t\t\t\t\tstruct extent_node, list);\n\t\tet = en->et;\n\t\tif (!write_trylock(&et->lock)) {\n\t\t\t/* refresh this extent node's position in extent list */\n\t\t\tlist_move_tail(&en->list, &sbi->extent_list);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_del_init(&en->list);\n\t\tspin_unlock(&sbi->extent_lock);\n\n\t\t__detach_extent_node(sbi, et, en);\n\n\t\twrite_unlock(&et->lock);\n\t\tnode_cnt++;\n\t\tspin_lock(&sbi->extent_lock);\n\t}\n\tspin_unlock(&sbi->extent_lock);\n\nunlock_out:\n\tmutex_unlock(&sbi->extent_tree_lock);\nout:\n\ttrace_f2fs_shrink_extent_tree(sbi, node_cnt, tree_cnt);\n\n\treturn node_cnt + tree_cnt;\n}\n\nunsigned int f2fs_destroy_extent_node(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct extent_tree *et = F2FS_I(inode)->extent_tree;\n\tunsigned int node_cnt = 0;\n\n\tif (!et || !atomic_read(&et->node_cnt))\n\t\treturn 0;\n\n\twrite_lock(&et->lock);\n\tnode_cnt = __free_extent_tree(sbi, et);\n\twrite_unlock(&et->lock);\n\n\treturn node_cnt;\n}\n\nvoid f2fs_drop_extent_tree(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct extent_tree *et = F2FS_I(inode)->extent_tree;\n\n\tset_inode_flag(inode, FI_NO_EXTENT);\n\n\twrite_lock(&et->lock);\n\t__free_extent_tree(sbi, et);\n\t__drop_largest_extent(inode, 0, UINT_MAX);\n\twrite_unlock(&et->lock);\n}\n\nvoid f2fs_destroy_extent_tree(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct extent_tree *et = F2FS_I(inode)->extent_tree;\n\tunsigned int node_cnt = 0;\n\n\tif (!et)\n\t\treturn;\n\n\tif (inode->i_nlink && !is_bad_inode(inode) &&\n\t\t\t\t\tatomic_read(&et->node_cnt)) {\n\t\tmutex_lock(&sbi->extent_tree_lock);\n\t\tlist_add_tail(&et->list, &sbi->zombie_list);\n\t\tatomic_inc(&sbi->total_zombie_tree);\n\t\tmutex_unlock(&sbi->extent_tree_lock);\n\t\treturn;\n\t}\n\n\t/* free all extent info belong to this extent tree */\n\tnode_cnt = f2fs_destroy_extent_node(inode);\n\n\t/* delete extent tree entry in radix tree */\n\tmutex_lock(&sbi->extent_tree_lock);\n\tf2fs_bug_on(sbi, atomic_read(&et->node_cnt));\n\tradix_tree_delete(&sbi->extent_tree_root, inode->i_ino);\n\tkmem_cache_free(extent_tree_slab, et);\n\tatomic_dec(&sbi->total_ext_tree);\n\tmutex_unlock(&sbi->extent_tree_lock);\n\n\tF2FS_I(inode)->extent_tree = NULL;\n\n\ttrace_f2fs_destroy_extent_tree(inode, node_cnt);\n}\n\nbool f2fs_lookup_extent_cache(struct inode *inode, pgoff_t pgofs,\n\t\t\t\t\tstruct extent_info *ei)\n{\n\tif (!f2fs_may_extent_tree(inode))\n\t\treturn false;\n\n\treturn f2fs_lookup_extent_tree(inode, pgofs, ei);\n}\n\nvoid f2fs_update_extent_cache(struct dnode_of_data *dn)\n{\n\tpgoff_t fofs;\n\tblock_t blkaddr;\n\n\tif (!f2fs_may_extent_tree(dn->inode))\n\t\treturn;\n\n\tif (dn->data_blkaddr == NEW_ADDR)\n\t\tblkaddr = NULL_ADDR;\n\telse\n\t\tblkaddr = dn->data_blkaddr;\n\n\tfofs = start_bidx_of_node(ofs_of_node(dn->node_page), dn->inode) +\n\t\t\t\t\t\t\t\tdn->ofs_in_node;\n\tf2fs_update_extent_tree_range(dn->inode, fofs, blkaddr, 1);\n}\n\nvoid f2fs_update_extent_cache_range(struct dnode_of_data *dn,\n\t\t\t\tpgoff_t fofs, block_t blkaddr, unsigned int len)\n\n{\n\tif (!f2fs_may_extent_tree(dn->inode))\n\t\treturn;\n\n\tf2fs_update_extent_tree_range(dn->inode, fofs, blkaddr, len);\n}\n\nvoid init_extent_cache_info(struct f2fs_sb_info *sbi)\n{\n\tINIT_RADIX_TREE(&sbi->extent_tree_root, GFP_NOIO);\n\tmutex_init(&sbi->extent_tree_lock);\n\tINIT_LIST_HEAD(&sbi->extent_list);\n\tspin_lock_init(&sbi->extent_lock);\n\tatomic_set(&sbi->total_ext_tree, 0);\n\tINIT_LIST_HEAD(&sbi->zombie_list);\n\tatomic_set(&sbi->total_zombie_tree, 0);\n\tatomic_set(&sbi->total_ext_node, 0);\n}\n\nint __init create_extent_cache(void)\n{\n\textent_tree_slab = f2fs_kmem_cache_create(\"f2fs_extent_tree\",\n\t\t\tsizeof(struct extent_tree));\n\tif (!extent_tree_slab)\n\t\treturn -ENOMEM;\n\textent_node_slab = f2fs_kmem_cache_create(\"f2fs_extent_node\",\n\t\t\tsizeof(struct extent_node));\n\tif (!extent_node_slab) {\n\t\tkmem_cache_destroy(extent_tree_slab);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nvoid destroy_extent_cache(void)\n{\n\tkmem_cache_destroy(extent_node_slab);\n\tkmem_cache_destroy(extent_tree_slab);\n}\n"], "fixing_code": ["/*\n * f2fs extent cache support\n *\n * Copyright (c) 2015 Motorola Mobility\n * Copyright (c) 2015 Samsung Electronics\n * Authors: Jaegeuk Kim <jaegeuk@kernel.org>\n *          Chao Yu <chao2.yu@samsung.com>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation.\n */\n\n#include <linux/fs.h>\n#include <linux/f2fs_fs.h>\n\n#include \"f2fs.h\"\n#include \"node.h\"\n#include <trace/events/f2fs.h>\n\nstatic struct rb_entry *__lookup_rb_tree_fast(struct rb_entry *cached_re,\n\t\t\t\t\t\t\tunsigned int ofs)\n{\n\tif (cached_re) {\n\t\tif (cached_re->ofs <= ofs &&\n\t\t\t\tcached_re->ofs + cached_re->len > ofs) {\n\t\t\treturn cached_re;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic struct rb_entry *__lookup_rb_tree_slow(struct rb_root *root,\n\t\t\t\t\t\t\tunsigned int ofs)\n{\n\tstruct rb_node *node = root->rb_node;\n\tstruct rb_entry *re;\n\n\twhile (node) {\n\t\tre = rb_entry(node, struct rb_entry, rb_node);\n\n\t\tif (ofs < re->ofs)\n\t\t\tnode = node->rb_left;\n\t\telse if (ofs >= re->ofs + re->len)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn re;\n\t}\n\treturn NULL;\n}\n\nstruct rb_entry *__lookup_rb_tree(struct rb_root *root,\n\t\t\t\tstruct rb_entry *cached_re, unsigned int ofs)\n{\n\tstruct rb_entry *re;\n\n\tre = __lookup_rb_tree_fast(cached_re, ofs);\n\tif (!re)\n\t\treturn __lookup_rb_tree_slow(root, ofs);\n\n\treturn re;\n}\n\nstruct rb_node **__lookup_rb_tree_for_insert(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct rb_root *root, struct rb_node **parent,\n\t\t\t\tunsigned int ofs)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_entry *re;\n\n\twhile (*p) {\n\t\t*parent = *p;\n\t\tre = rb_entry(*parent, struct rb_entry, rb_node);\n\n\t\tif (ofs < re->ofs)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (ofs >= re->ofs + re->len)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tf2fs_bug_on(sbi, 1);\n\t}\n\n\treturn p;\n}\n\n/*\n * lookup rb entry in position of @ofs in rb-tree,\n * if hit, return the entry, otherwise, return NULL\n * @prev_ex: extent before ofs\n * @next_ex: extent after ofs\n * @insert_p: insert point for new extent at ofs\n * in order to simpfy the insertion after.\n * tree must stay unchanged between lookup and insertion.\n */\nstruct rb_entry *__lookup_rb_tree_ret(struct rb_root *root,\n\t\t\t\tstruct rb_entry *cached_re,\n\t\t\t\tunsigned int ofs,\n\t\t\t\tstruct rb_entry **prev_entry,\n\t\t\t\tstruct rb_entry **next_entry,\n\t\t\t\tstruct rb_node ***insert_p,\n\t\t\t\tstruct rb_node **insert_parent,\n\t\t\t\tbool force)\n{\n\tstruct rb_node **pnode = &root->rb_node;\n\tstruct rb_node *parent = NULL, *tmp_node;\n\tstruct rb_entry *re = cached_re;\n\n\t*insert_p = NULL;\n\t*insert_parent = NULL;\n\t*prev_entry = NULL;\n\t*next_entry = NULL;\n\n\tif (RB_EMPTY_ROOT(root))\n\t\treturn NULL;\n\n\tif (re) {\n\t\tif (re->ofs <= ofs && re->ofs + re->len > ofs)\n\t\t\tgoto lookup_neighbors;\n\t}\n\n\twhile (*pnode) {\n\t\tparent = *pnode;\n\t\tre = rb_entry(*pnode, struct rb_entry, rb_node);\n\n\t\tif (ofs < re->ofs)\n\t\t\tpnode = &(*pnode)->rb_left;\n\t\telse if (ofs >= re->ofs + re->len)\n\t\t\tpnode = &(*pnode)->rb_right;\n\t\telse\n\t\t\tgoto lookup_neighbors;\n\t}\n\n\t*insert_p = pnode;\n\t*insert_parent = parent;\n\n\tre = rb_entry(parent, struct rb_entry, rb_node);\n\ttmp_node = parent;\n\tif (parent && ofs > re->ofs)\n\t\ttmp_node = rb_next(parent);\n\t*next_entry = rb_entry_safe(tmp_node, struct rb_entry, rb_node);\n\n\ttmp_node = parent;\n\tif (parent && ofs < re->ofs)\n\t\ttmp_node = rb_prev(parent);\n\t*prev_entry = rb_entry_safe(tmp_node, struct rb_entry, rb_node);\n\treturn NULL;\n\nlookup_neighbors:\n\tif (ofs == re->ofs || force) {\n\t\t/* lookup prev node for merging backward later */\n\t\ttmp_node = rb_prev(&re->rb_node);\n\t\t*prev_entry = rb_entry_safe(tmp_node, struct rb_entry, rb_node);\n\t}\n\tif (ofs == re->ofs + re->len - 1 || force) {\n\t\t/* lookup next node for merging frontward later */\n\t\ttmp_node = rb_next(&re->rb_node);\n\t\t*next_entry = rb_entry_safe(tmp_node, struct rb_entry, rb_node);\n\t}\n\treturn re;\n}\n\nbool __check_rb_tree_consistence(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tstruct rb_root *root)\n{\n#ifdef CONFIG_F2FS_CHECK_FS\n\tstruct rb_node *cur = rb_first(root), *next;\n\tstruct rb_entry *cur_re, *next_re;\n\n\tif (!cur)\n\t\treturn true;\n\n\twhile (cur) {\n\t\tnext = rb_next(cur);\n\t\tif (!next)\n\t\t\treturn true;\n\n\t\tcur_re = rb_entry(cur, struct rb_entry, rb_node);\n\t\tnext_re = rb_entry(next, struct rb_entry, rb_node);\n\n\t\tif (cur_re->ofs + cur_re->len > next_re->ofs) {\n\t\t\tf2fs_msg(sbi->sb, KERN_INFO, \"inconsistent rbtree, \"\n\t\t\t\t\"cur(%u, %u) next(%u, %u)\",\n\t\t\t\tcur_re->ofs, cur_re->len,\n\t\t\t\tnext_re->ofs, next_re->len);\n\t\t\treturn false;\n\t\t}\n\n\t\tcur = next;\n\t}\n#endif\n\treturn true;\n}\n\nstatic struct kmem_cache *extent_tree_slab;\nstatic struct kmem_cache *extent_node_slab;\n\nstatic struct extent_node *__attach_extent_node(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct extent_tree *et, struct extent_info *ei,\n\t\t\t\tstruct rb_node *parent, struct rb_node **p)\n{\n\tstruct extent_node *en;\n\n\ten = kmem_cache_alloc(extent_node_slab, GFP_ATOMIC);\n\tif (!en)\n\t\treturn NULL;\n\n\ten->ei = *ei;\n\tINIT_LIST_HEAD(&en->list);\n\ten->et = et;\n\n\trb_link_node(&en->rb_node, parent, p);\n\trb_insert_color(&en->rb_node, &et->root);\n\tatomic_inc(&et->node_cnt);\n\tatomic_inc(&sbi->total_ext_node);\n\treturn en;\n}\n\nstatic void __detach_extent_node(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct extent_tree *et, struct extent_node *en)\n{\n\trb_erase(&en->rb_node, &et->root);\n\tatomic_dec(&et->node_cnt);\n\tatomic_dec(&sbi->total_ext_node);\n\n\tif (et->cached_en == en)\n\t\tet->cached_en = NULL;\n\tkmem_cache_free(extent_node_slab, en);\n}\n\n/*\n * Flow to release an extent_node:\n * 1. list_del_init\n * 2. __detach_extent_node\n * 3. kmem_cache_free.\n */\nstatic void __release_extent_node(struct f2fs_sb_info *sbi,\n\t\t\tstruct extent_tree *et, struct extent_node *en)\n{\n\tspin_lock(&sbi->extent_lock);\n\tf2fs_bug_on(sbi, list_empty(&en->list));\n\tlist_del_init(&en->list);\n\tspin_unlock(&sbi->extent_lock);\n\n\t__detach_extent_node(sbi, et, en);\n}\n\nstatic struct extent_tree *__grab_extent_tree(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct extent_tree *et;\n\tnid_t ino = inode->i_ino;\n\n\tmutex_lock(&sbi->extent_tree_lock);\n\tet = radix_tree_lookup(&sbi->extent_tree_root, ino);\n\tif (!et) {\n\t\tet = f2fs_kmem_cache_alloc(extent_tree_slab, GFP_NOFS);\n\t\tf2fs_radix_tree_insert(&sbi->extent_tree_root, ino, et);\n\t\tmemset(et, 0, sizeof(struct extent_tree));\n\t\tet->ino = ino;\n\t\tet->root = RB_ROOT;\n\t\tet->cached_en = NULL;\n\t\trwlock_init(&et->lock);\n\t\tINIT_LIST_HEAD(&et->list);\n\t\tatomic_set(&et->node_cnt, 0);\n\t\tatomic_inc(&sbi->total_ext_tree);\n\t} else {\n\t\tatomic_dec(&sbi->total_zombie_tree);\n\t\tlist_del_init(&et->list);\n\t}\n\tmutex_unlock(&sbi->extent_tree_lock);\n\n\t/* never died until evict_inode */\n\tF2FS_I(inode)->extent_tree = et;\n\n\treturn et;\n}\n\nstatic struct extent_node *__init_extent_tree(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct extent_tree *et, struct extent_info *ei)\n{\n\tstruct rb_node **p = &et->root.rb_node;\n\tstruct extent_node *en;\n\n\ten = __attach_extent_node(sbi, et, ei, NULL, p);\n\tif (!en)\n\t\treturn NULL;\n\n\tet->largest = en->ei;\n\tet->cached_en = en;\n\treturn en;\n}\n\nstatic unsigned int __free_extent_tree(struct f2fs_sb_info *sbi,\n\t\t\t\t\tstruct extent_tree *et)\n{\n\tstruct rb_node *node, *next;\n\tstruct extent_node *en;\n\tunsigned int count = atomic_read(&et->node_cnt);\n\n\tnode = rb_first(&et->root);\n\twhile (node) {\n\t\tnext = rb_next(node);\n\t\ten = rb_entry(node, struct extent_node, rb_node);\n\t\t__release_extent_node(sbi, et, en);\n\t\tnode = next;\n\t}\n\n\treturn count - atomic_read(&et->node_cnt);\n}\n\nstatic void __drop_largest_extent(struct inode *inode,\n\t\t\t\t\tpgoff_t fofs, unsigned int len)\n{\n\tstruct extent_info *largest = &F2FS_I(inode)->extent_tree->largest;\n\n\tif (fofs < largest->fofs + largest->len && fofs + len > largest->fofs) {\n\t\tlargest->len = 0;\n\t\tf2fs_mark_inode_dirty_sync(inode, true);\n\t}\n}\n\n/* return true, if inode page is changed */\nstatic bool __f2fs_init_extent_tree(struct inode *inode, struct f2fs_extent *i_ext)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct extent_tree *et;\n\tstruct extent_node *en;\n\tstruct extent_info ei;\n\n\tif (!f2fs_may_extent_tree(inode)) {\n\t\t/* drop largest extent */\n\t\tif (i_ext && i_ext->len) {\n\t\t\ti_ext->len = 0;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tet = __grab_extent_tree(inode);\n\n\tif (!i_ext || !i_ext->len)\n\t\treturn false;\n\n\tget_extent_info(&ei, i_ext);\n\n\twrite_lock(&et->lock);\n\tif (atomic_read(&et->node_cnt))\n\t\tgoto out;\n\n\ten = __init_extent_tree(sbi, et, &ei);\n\tif (en) {\n\t\tspin_lock(&sbi->extent_lock);\n\t\tlist_add_tail(&en->list, &sbi->extent_list);\n\t\tspin_unlock(&sbi->extent_lock);\n\t}\nout:\n\twrite_unlock(&et->lock);\n\treturn false;\n}\n\nbool f2fs_init_extent_tree(struct inode *inode, struct f2fs_extent *i_ext)\n{\n\tbool ret =  __f2fs_init_extent_tree(inode, i_ext);\n\n\tif (!F2FS_I(inode)->extent_tree)\n\t\tset_inode_flag(inode, FI_NO_EXTENT);\n\n\treturn ret;\n}\n\nstatic bool f2fs_lookup_extent_tree(struct inode *inode, pgoff_t pgofs,\n\t\t\t\t\t\t\tstruct extent_info *ei)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct extent_tree *et = F2FS_I(inode)->extent_tree;\n\tstruct extent_node *en;\n\tbool ret = false;\n\n\tf2fs_bug_on(sbi, !et);\n\n\ttrace_f2fs_lookup_extent_tree_start(inode, pgofs);\n\n\tread_lock(&et->lock);\n\n\tif (et->largest.fofs <= pgofs &&\n\t\t\tet->largest.fofs + et->largest.len > pgofs) {\n\t\t*ei = et->largest;\n\t\tret = true;\n\t\tstat_inc_largest_node_hit(sbi);\n\t\tgoto out;\n\t}\n\n\ten = (struct extent_node *)__lookup_rb_tree(&et->root,\n\t\t\t\t(struct rb_entry *)et->cached_en, pgofs);\n\tif (!en)\n\t\tgoto out;\n\n\tif (en == et->cached_en)\n\t\tstat_inc_cached_node_hit(sbi);\n\telse\n\t\tstat_inc_rbtree_node_hit(sbi);\n\n\t*ei = en->ei;\n\tspin_lock(&sbi->extent_lock);\n\tif (!list_empty(&en->list)) {\n\t\tlist_move_tail(&en->list, &sbi->extent_list);\n\t\tet->cached_en = en;\n\t}\n\tspin_unlock(&sbi->extent_lock);\n\tret = true;\nout:\n\tstat_inc_total_hit(sbi);\n\tread_unlock(&et->lock);\n\n\ttrace_f2fs_lookup_extent_tree_end(inode, pgofs, ei);\n\treturn ret;\n}\n\nstatic struct extent_node *__try_merge_extent_node(struct inode *inode,\n\t\t\t\tstruct extent_tree *et, struct extent_info *ei,\n\t\t\t\tstruct extent_node *prev_ex,\n\t\t\t\tstruct extent_node *next_ex)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct extent_node *en = NULL;\n\n\tif (prev_ex && __is_back_mergeable(ei, &prev_ex->ei)) {\n\t\tprev_ex->ei.len += ei->len;\n\t\tei = &prev_ex->ei;\n\t\ten = prev_ex;\n\t}\n\n\tif (next_ex && __is_front_mergeable(ei, &next_ex->ei)) {\n\t\tnext_ex->ei.fofs = ei->fofs;\n\t\tnext_ex->ei.blk = ei->blk;\n\t\tnext_ex->ei.len += ei->len;\n\t\tif (en)\n\t\t\t__release_extent_node(sbi, et, prev_ex);\n\n\t\ten = next_ex;\n\t}\n\n\tif (!en)\n\t\treturn NULL;\n\n\t__try_update_largest_extent(inode, et, en);\n\n\tspin_lock(&sbi->extent_lock);\n\tif (!list_empty(&en->list)) {\n\t\tlist_move_tail(&en->list, &sbi->extent_list);\n\t\tet->cached_en = en;\n\t}\n\tspin_unlock(&sbi->extent_lock);\n\treturn en;\n}\n\nstatic struct extent_node *__insert_extent_tree(struct inode *inode,\n\t\t\t\tstruct extent_tree *et, struct extent_info *ei,\n\t\t\t\tstruct rb_node **insert_p,\n\t\t\t\tstruct rb_node *insert_parent)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct rb_node **p = &et->root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct extent_node *en = NULL;\n\n\tif (insert_p && insert_parent) {\n\t\tparent = insert_parent;\n\t\tp = insert_p;\n\t\tgoto do_insert;\n\t}\n\n\tp = __lookup_rb_tree_for_insert(sbi, &et->root, &parent, ei->fofs);\ndo_insert:\n\ten = __attach_extent_node(sbi, et, ei, parent, p);\n\tif (!en)\n\t\treturn NULL;\n\n\t__try_update_largest_extent(inode, et, en);\n\n\t/* update in global extent list */\n\tspin_lock(&sbi->extent_lock);\n\tlist_add_tail(&en->list, &sbi->extent_list);\n\tet->cached_en = en;\n\tspin_unlock(&sbi->extent_lock);\n\treturn en;\n}\n\nstatic void f2fs_update_extent_tree_range(struct inode *inode,\n\t\t\t\tpgoff_t fofs, block_t blkaddr, unsigned int len)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct extent_tree *et = F2FS_I(inode)->extent_tree;\n\tstruct extent_node *en = NULL, *en1 = NULL;\n\tstruct extent_node *prev_en = NULL, *next_en = NULL;\n\tstruct extent_info ei, dei, prev;\n\tstruct rb_node **insert_p = NULL, *insert_parent = NULL;\n\tunsigned int end = fofs + len;\n\tunsigned int pos = (unsigned int)fofs;\n\n\tif (!et)\n\t\treturn;\n\n\ttrace_f2fs_update_extent_tree_range(inode, fofs, blkaddr, len);\n\n\twrite_lock(&et->lock);\n\n\tif (is_inode_flag_set(inode, FI_NO_EXTENT)) {\n\t\twrite_unlock(&et->lock);\n\t\treturn;\n\t}\n\n\tprev = et->largest;\n\tdei.len = 0;\n\n\t/*\n\t * drop largest extent before lookup, in case it's already\n\t * been shrunk from extent tree\n\t */\n\t__drop_largest_extent(inode, fofs, len);\n\n\t/* 1. lookup first extent node in range [fofs, fofs + len - 1] */\n\ten = (struct extent_node *)__lookup_rb_tree_ret(&et->root,\n\t\t\t\t\t(struct rb_entry *)et->cached_en, fofs,\n\t\t\t\t\t(struct rb_entry **)&prev_en,\n\t\t\t\t\t(struct rb_entry **)&next_en,\n\t\t\t\t\t&insert_p, &insert_parent, false);\n\tif (!en)\n\t\ten = next_en;\n\n\t/* 2. invlidate all extent nodes in range [fofs, fofs + len - 1] */\n\twhile (en && en->ei.fofs < end) {\n\t\tunsigned int org_end;\n\t\tint parts = 0;\t/* # of parts current extent split into */\n\n\t\tnext_en = en1 = NULL;\n\n\t\tdei = en->ei;\n\t\torg_end = dei.fofs + dei.len;\n\t\tf2fs_bug_on(sbi, pos >= org_end);\n\n\t\tif (pos > dei.fofs &&\tpos - dei.fofs >= F2FS_MIN_EXTENT_LEN) {\n\t\t\ten->ei.len = pos - en->ei.fofs;\n\t\t\tprev_en = en;\n\t\t\tparts = 1;\n\t\t}\n\n\t\tif (end < org_end && org_end - end >= F2FS_MIN_EXTENT_LEN) {\n\t\t\tif (parts) {\n\t\t\t\tset_extent_info(&ei, end,\n\t\t\t\t\t\tend - dei.fofs + dei.blk,\n\t\t\t\t\t\torg_end - end);\n\t\t\t\ten1 = __insert_extent_tree(inode, et, &ei,\n\t\t\t\t\t\t\tNULL, NULL);\n\t\t\t\tnext_en = en1;\n\t\t\t} else {\n\t\t\t\ten->ei.fofs = end;\n\t\t\t\ten->ei.blk += end - dei.fofs;\n\t\t\t\ten->ei.len -= end - dei.fofs;\n\t\t\t\tnext_en = en;\n\t\t\t}\n\t\t\tparts++;\n\t\t}\n\n\t\tif (!next_en) {\n\t\t\tstruct rb_node *node = rb_next(&en->rb_node);\n\n\t\t\tnext_en = rb_entry_safe(node, struct extent_node,\n\t\t\t\t\t\trb_node);\n\t\t}\n\n\t\tif (parts)\n\t\t\t__try_update_largest_extent(inode, et, en);\n\t\telse\n\t\t\t__release_extent_node(sbi, et, en);\n\n\t\t/*\n\t\t * if original extent is split into zero or two parts, extent\n\t\t * tree has been altered by deletion or insertion, therefore\n\t\t * invalidate pointers regard to tree.\n\t\t */\n\t\tif (parts != 1) {\n\t\t\tinsert_p = NULL;\n\t\t\tinsert_parent = NULL;\n\t\t}\n\t\ten = next_en;\n\t}\n\n\t/* 3. update extent in extent cache */\n\tif (blkaddr) {\n\n\t\tset_extent_info(&ei, fofs, blkaddr, len);\n\t\tif (!__try_merge_extent_node(inode, et, &ei, prev_en, next_en))\n\t\t\t__insert_extent_tree(inode, et, &ei,\n\t\t\t\t\t\tinsert_p, insert_parent);\n\n\t\t/* give up extent_cache, if split and small updates happen */\n\t\tif (dei.len >= 1 &&\n\t\t\t\tprev.len < F2FS_MIN_EXTENT_LEN &&\n\t\t\t\tet->largest.len < F2FS_MIN_EXTENT_LEN) {\n\t\t\t__drop_largest_extent(inode, 0, UINT_MAX);\n\t\t\tset_inode_flag(inode, FI_NO_EXTENT);\n\t\t}\n\t}\n\n\tif (is_inode_flag_set(inode, FI_NO_EXTENT))\n\t\t__free_extent_tree(sbi, et);\n\n\twrite_unlock(&et->lock);\n}\n\nunsigned int f2fs_shrink_extent_tree(struct f2fs_sb_info *sbi, int nr_shrink)\n{\n\tstruct extent_tree *et, *next;\n\tstruct extent_node *en;\n\tunsigned int node_cnt = 0, tree_cnt = 0;\n\tint remained;\n\n\tif (!test_opt(sbi, EXTENT_CACHE))\n\t\treturn 0;\n\n\tif (!atomic_read(&sbi->total_zombie_tree))\n\t\tgoto free_node;\n\n\tif (!mutex_trylock(&sbi->extent_tree_lock))\n\t\tgoto out;\n\n\t/* 1. remove unreferenced extent tree */\n\tlist_for_each_entry_safe(et, next, &sbi->zombie_list, list) {\n\t\tif (atomic_read(&et->node_cnt)) {\n\t\t\twrite_lock(&et->lock);\n\t\t\tnode_cnt += __free_extent_tree(sbi, et);\n\t\t\twrite_unlock(&et->lock);\n\t\t}\n\t\tf2fs_bug_on(sbi, atomic_read(&et->node_cnt));\n\t\tlist_del_init(&et->list);\n\t\tradix_tree_delete(&sbi->extent_tree_root, et->ino);\n\t\tkmem_cache_free(extent_tree_slab, et);\n\t\tatomic_dec(&sbi->total_ext_tree);\n\t\tatomic_dec(&sbi->total_zombie_tree);\n\t\ttree_cnt++;\n\n\t\tif (node_cnt + tree_cnt >= nr_shrink)\n\t\t\tgoto unlock_out;\n\t\tcond_resched();\n\t}\n\tmutex_unlock(&sbi->extent_tree_lock);\n\nfree_node:\n\t/* 2. remove LRU extent entries */\n\tif (!mutex_trylock(&sbi->extent_tree_lock))\n\t\tgoto out;\n\n\tremained = nr_shrink - (node_cnt + tree_cnt);\n\n\tspin_lock(&sbi->extent_lock);\n\tfor (; remained > 0; remained--) {\n\t\tif (list_empty(&sbi->extent_list))\n\t\t\tbreak;\n\t\ten = list_first_entry(&sbi->extent_list,\n\t\t\t\t\tstruct extent_node, list);\n\t\tet = en->et;\n\t\tif (!write_trylock(&et->lock)) {\n\t\t\t/* refresh this extent node's position in extent list */\n\t\t\tlist_move_tail(&en->list, &sbi->extent_list);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_del_init(&en->list);\n\t\tspin_unlock(&sbi->extent_lock);\n\n\t\t__detach_extent_node(sbi, et, en);\n\n\t\twrite_unlock(&et->lock);\n\t\tnode_cnt++;\n\t\tspin_lock(&sbi->extent_lock);\n\t}\n\tspin_unlock(&sbi->extent_lock);\n\nunlock_out:\n\tmutex_unlock(&sbi->extent_tree_lock);\nout:\n\ttrace_f2fs_shrink_extent_tree(sbi, node_cnt, tree_cnt);\n\n\treturn node_cnt + tree_cnt;\n}\n\nunsigned int f2fs_destroy_extent_node(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct extent_tree *et = F2FS_I(inode)->extent_tree;\n\tunsigned int node_cnt = 0;\n\n\tif (!et || !atomic_read(&et->node_cnt))\n\t\treturn 0;\n\n\twrite_lock(&et->lock);\n\tnode_cnt = __free_extent_tree(sbi, et);\n\twrite_unlock(&et->lock);\n\n\treturn node_cnt;\n}\n\nvoid f2fs_drop_extent_tree(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct extent_tree *et = F2FS_I(inode)->extent_tree;\n\n\tset_inode_flag(inode, FI_NO_EXTENT);\n\n\twrite_lock(&et->lock);\n\t__free_extent_tree(sbi, et);\n\t__drop_largest_extent(inode, 0, UINT_MAX);\n\twrite_unlock(&et->lock);\n}\n\nvoid f2fs_destroy_extent_tree(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct extent_tree *et = F2FS_I(inode)->extent_tree;\n\tunsigned int node_cnt = 0;\n\n\tif (!et)\n\t\treturn;\n\n\tif (inode->i_nlink && !is_bad_inode(inode) &&\n\t\t\t\t\tatomic_read(&et->node_cnt)) {\n\t\tmutex_lock(&sbi->extent_tree_lock);\n\t\tlist_add_tail(&et->list, &sbi->zombie_list);\n\t\tatomic_inc(&sbi->total_zombie_tree);\n\t\tmutex_unlock(&sbi->extent_tree_lock);\n\t\treturn;\n\t}\n\n\t/* free all extent info belong to this extent tree */\n\tnode_cnt = f2fs_destroy_extent_node(inode);\n\n\t/* delete extent tree entry in radix tree */\n\tmutex_lock(&sbi->extent_tree_lock);\n\tf2fs_bug_on(sbi, atomic_read(&et->node_cnt));\n\tradix_tree_delete(&sbi->extent_tree_root, inode->i_ino);\n\tkmem_cache_free(extent_tree_slab, et);\n\tatomic_dec(&sbi->total_ext_tree);\n\tmutex_unlock(&sbi->extent_tree_lock);\n\n\tF2FS_I(inode)->extent_tree = NULL;\n\n\ttrace_f2fs_destroy_extent_tree(inode, node_cnt);\n}\n\nbool f2fs_lookup_extent_cache(struct inode *inode, pgoff_t pgofs,\n\t\t\t\t\tstruct extent_info *ei)\n{\n\tif (!f2fs_may_extent_tree(inode))\n\t\treturn false;\n\n\treturn f2fs_lookup_extent_tree(inode, pgofs, ei);\n}\n\nvoid f2fs_update_extent_cache(struct dnode_of_data *dn)\n{\n\tpgoff_t fofs;\n\tblock_t blkaddr;\n\n\tif (!f2fs_may_extent_tree(dn->inode))\n\t\treturn;\n\n\tif (dn->data_blkaddr == NEW_ADDR)\n\t\tblkaddr = NULL_ADDR;\n\telse\n\t\tblkaddr = dn->data_blkaddr;\n\n\tfofs = start_bidx_of_node(ofs_of_node(dn->node_page), dn->inode) +\n\t\t\t\t\t\t\t\tdn->ofs_in_node;\n\tf2fs_update_extent_tree_range(dn->inode, fofs, blkaddr, 1);\n}\n\nvoid f2fs_update_extent_cache_range(struct dnode_of_data *dn,\n\t\t\t\tpgoff_t fofs, block_t blkaddr, unsigned int len)\n\n{\n\tif (!f2fs_may_extent_tree(dn->inode))\n\t\treturn;\n\n\tf2fs_update_extent_tree_range(dn->inode, fofs, blkaddr, len);\n}\n\nvoid init_extent_cache_info(struct f2fs_sb_info *sbi)\n{\n\tINIT_RADIX_TREE(&sbi->extent_tree_root, GFP_NOIO);\n\tmutex_init(&sbi->extent_tree_lock);\n\tINIT_LIST_HEAD(&sbi->extent_list);\n\tspin_lock_init(&sbi->extent_lock);\n\tatomic_set(&sbi->total_ext_tree, 0);\n\tINIT_LIST_HEAD(&sbi->zombie_list);\n\tatomic_set(&sbi->total_zombie_tree, 0);\n\tatomic_set(&sbi->total_ext_node, 0);\n}\n\nint __init create_extent_cache(void)\n{\n\textent_tree_slab = f2fs_kmem_cache_create(\"f2fs_extent_tree\",\n\t\t\tsizeof(struct extent_tree));\n\tif (!extent_tree_slab)\n\t\treturn -ENOMEM;\n\textent_node_slab = f2fs_kmem_cache_create(\"f2fs_extent_node\",\n\t\t\tsizeof(struct extent_node));\n\tif (!extent_node_slab) {\n\t\tkmem_cache_destroy(extent_tree_slab);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nvoid destroy_extent_cache(void)\n{\n\tkmem_cache_destroy(extent_node_slab);\n\tkmem_cache_destroy(extent_tree_slab);\n}\n"], "filenames": ["fs/f2fs/extent_cache.c"], "buggy_code_start_loc": [323], "buggy_code_end_loc": [358], "fixing_code_start_loc": [323], "fixing_code_end_loc": [369], "type": "CWE-119", "message": "fs/f2fs/extent_cache.c in the Linux kernel before 4.13 mishandles extent trees, which allows local users to cause a denial of service (BUG) via an application with multiple threads.", "other": {"cve": {"id": "CVE-2017-18193", "sourceIdentifier": "cve@mitre.org", "published": "2018-02-22T15:29:00.257", "lastModified": "2018-05-24T01:29:00.787", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "fs/f2fs/extent_cache.c in the Linux kernel before 4.13 mishandles extent trees, which allows local users to cause a denial of service (BUG) via an application with multiple threads."}, {"lang": "es", "value": "fs/f2fs/extent_cache.c en el kernel de Linux, en versiones anteriores a la 4.13, gestiona de forma incorrecta los \u00e1rboles extent, lo que permite que usuarios locales provoquen una denegaci\u00f3n de servicio (error) mediante una aplicaci\u00f3n con m\u00faltiples hilos."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.13", "matchCriteriaId": "D2894F22-5448-4402-AE27-6E43BD08E14E"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=dad48e73127ba10279ea33e6dbc8d3905c4d31c0", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "http://www.securityfocus.com/bid/103147", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/torvalds/linux/commit/dad48e73127ba10279ea33e6dbc8d3905c4d31c0", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://usn.ubuntu.com/3654-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3654-2/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3656-1/", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2018/dsa-4188", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/dad48e73127ba10279ea33e6dbc8d3905c4d31c0"}}