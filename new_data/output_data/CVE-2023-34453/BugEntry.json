{"buggy_code": ["/*--------------------------------------------------------------------------\n *  Copyright 2011 Taro L. Saito\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *--------------------------------------------------------------------------*/\n//--------------------------------------\n// snappy-java Project\n//\n// BitShuffle.java\n// Since: 2016/03/31\n//\n// $URL$\n// $Author$\n//--------------------------------------\npackage org.xerial.snappy;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\n\npublic class BitShuffle\n{\n    static {\n        try {\n            impl = SnappyLoader.loadBitShuffleApi();\n        }\n        catch (Exception e) {\n            throw new ExceptionInInitializerError(e);\n        }\n    }\n\n    /**\n     * An instance of BitShuffleNative\n     */\n    private static BitShuffleNative impl;\n\n    /**\n     * Apply a bit-shuffling filter into the content in the given input buffer. After bit-shuffling,\n     * you can retrieve the shuffled data from the output buffer [pos() ...limit())\n     * (shuffled data size = limit() - pos() = remaining()).\n     *\n     * @param input buffer[pos() ... limit()) containing the input data\n     * @param type element type of the input data\n     * @param shuffled output of the shuffled data. Uses range [pos()..].\n     * @return byte size of the shuffled data.\n     * @throws SnappyError when the input is not a direct buffer\n     * @throws IllegalArgumentException when the input length is not a multiple of the given type size\n     */\n    public static int shuffle(ByteBuffer input, BitShuffleType type, ByteBuffer shuffled) throws IOException {\n        if (!input.isDirect()) {\n            throw new SnappyError(SnappyErrorCode.NOT_A_DIRECT_BUFFER, \"input is not a direct buffer\");\n        }\n        if (!shuffled.isDirect()) {\n            throw new SnappyError(SnappyErrorCode.NOT_A_DIRECT_BUFFER, \"destination is not a direct buffer\");\n        }\n\n        // input: input[pos(), limit())\n        // output: shuffled\n        int uPos = input.position();\n        int uLen = input.remaining();\n        int typeSize = type.getTypeSize();\n        if (uLen % typeSize != 0) {\n            throw new IllegalArgumentException(\"input length must be a multiple of the given type size: \" + typeSize);\n        }\n        if (shuffled.remaining() < uLen) {\n            throw new IllegalArgumentException(\"not enough space for output\");\n        }\n        int numProcessed = impl.shuffleDirectBuffer(input, uPos, typeSize, uLen, shuffled, shuffled.position());\n        assert(numProcessed == uLen);\n\n        //         pos   limit\n        // [ ......BBBBBBB.........]\n        shuffled.limit(shuffled.position() + numProcessed);\n        return numProcessed;\n    }\n\n    /**\n     * Apply a bit-shuffling filter into the input short array.\n     *\n     * @param input\n     * @return bit-shuffled byte array\n     * @throws IOException\n     */\n    public static byte[] shuffle(short[] input) throws IOException {\n        byte[] output = new byte[input.length * 2];\n        int numProcessed = impl.shuffle(input, 0, 2, input.length * 2, output, 0);\n        assert(numProcessed == input.length * 2);\n        return output;\n    }\n\n    /**\n     * Apply a bit-shuffling filter into the input int array.\n     *\n     * @param input\n     * @return bit-shuffled byte array\n     * @throws IOException\n     */\n    public static byte[] shuffle(int[] input) throws IOException {\n        byte[] output = new byte[input.length * 4];\n        int numProcessed = impl.shuffle(input, 0, 4, input.length * 4, output, 0);\n        assert(numProcessed == input.length * 4);\n        return output;\n    }\n\n    /**\n     * Apply a bit-shuffling filter into the input long array.\n     *\n     * @param input\n     * @return bit-shuffled byte array\n     * @throws IOException\n     */\n    public static byte[] shuffle(long[] input) throws IOException {\n        byte[] output = new byte[input.length * 8];\n        int numProcessed = impl.shuffle(input, 0, 8, input.length * 8, output, 0);\n        assert(numProcessed == input.length * 8);\n        return output;\n    }\n\n    /**\n     * Apply a bit-shuffling filter into the input float array.\n     *\n     * @param input\n     * @return bit-shuffled byte array\n     * @throws IOException\n     */\n    public static byte[] shuffle(float[] input) throws IOException {\n        byte[] output = new byte[input.length * 4];\n        int numProcessed = impl.shuffle(input, 0, 4, input.length * 4, output, 0);\n        assert(numProcessed == input.length * 4);\n        return output;\n    }\n\n    /**\n     * Apply a bit-shuffling filter into the input double array.\n     *\n     * @param input\n     * @return bit-shuffled byte array\n     * @throws IOException\n     */\n    public static byte[] shuffle(double[] input) throws IOException {\n        byte[] output = new byte[input.length * 8];\n        int numProcessed = impl.shuffle(input, 0, 8, input.length * 8, output, 0);\n        assert(numProcessed == input.length * 8);\n        return output;\n    }\n\n    /**\n     * Convert the input bit-shuffled byte array into an original array. The result is dumped\n     * to the specified output buffer.\n     *\n     * @param shuffled buffer[pos() ... limit()) containing the input shuffled data\n     * @param type element type of the input data\n     * @param output output of the the original data. It uses buffer[pos()..]\n     * @return byte size of the unshuffled data.\n     * @throws IOException when failed to unshuffle the given input\n     * @throws SnappyError when the input is not a direct buffer\n     * @throws IllegalArgumentException when the length of input shuffled data is not a multiple of the given type size\n     */\n    public static int unshuffle(ByteBuffer shuffled, BitShuffleType type, ByteBuffer output) throws IOException {\n        if (!shuffled.isDirect()) {\n            throw new SnappyError(SnappyErrorCode.NOT_A_DIRECT_BUFFER, \"input is not a direct buffer\");\n        }\n        if (!output.isDirect()) {\n            throw new SnappyError(SnappyErrorCode.NOT_A_DIRECT_BUFFER, \"destination is not a direct buffer\");\n        }\n\n        // input: input[pos(), limit())\n        // output: shuffled\n        int uPos = shuffled.position();\n        int uLen = shuffled.remaining();\n        int typeSize = type.getTypeSize();\n        if (uLen % typeSize != 0) {\n            throw new IllegalArgumentException(\"length of input shuffled data must be a multiple of the given type size: \" + typeSize);\n        }\n        if (output.remaining() < uLen) {\n            throw new IllegalArgumentException(\"not enough space for output\");\n        }\n        int numProcessed = impl.unshuffleDirectBuffer(shuffled, uPos, typeSize, uLen, output, shuffled.position());\n        assert(numProcessed == uLen);\n\n        //         pos   limit\n        // [ ......BBBBBBB.........]\n        shuffled.limit(shuffled.position() + numProcessed);\n        return numProcessed;\n    }\n\n    /**\n     * Convert the input bit-shuffled byte array into an original short array.\n     *\n     * @param input\n     * @return a short array\n     * @throws IOException\n     */\n    public static short[] unshuffleShortArray(byte[] input) throws IOException {\n        short[] output = new short[input.length / 2];\n        int numProcessed = impl.unshuffle(input, 0, 2, input.length, output, 0);\n        assert(numProcessed == input.length);\n        return output;\n    }\n\n    /**\n     * Convert the input bit-shuffled byte array into an original int array.\n     *\n     * @param input\n     * @return an int array\n     * @throws IOException\n     */\n    public static int[] unshuffleIntArray(byte[] input) throws IOException {\n        int[] output = new int[input.length / 4];\n        int numProcessed = impl.unshuffle(input, 0, 4, input.length, output, 0);\n        assert(numProcessed == input.length);\n        return output;\n    }\n\n    /**\n     * Convert the input bit-shuffled byte array into an original long array.\n     *\n     * @param input\n     * @return a long array\n     * @throws IOException\n     */\n    public static long[] unshuffleLongArray(byte[] input) throws IOException {\n        long[] output = new long[input.length / 8];\n        int numProcessed = impl.unshuffle(input, 0, 8, input.length, output, 0);\n        assert(numProcessed == input.length);\n        return output;\n    }\n\n    /**\n     * Convert the input bit-shuffled byte array into an original float array.\n     *\n     * @param input\n     * @return an float array\n     * @throws IOException\n     */\n    public static float[] unshuffleFloatArray(byte[] input) throws IOException {\n        float[] output = new float[input.length / 4];\n        int numProcessed = impl.unshuffle(input, 0, 4, input.length, output, 0);\n        assert(numProcessed == input.length);\n        return output;\n    }\n\n    /**\n     * Convert the input bit-shuffled byte array into an original double array.\n     *\n     * @param input\n     * @return a double array\n     * @throws IOException\n     */\n    public static double[] unshuffleDoubleArray(byte[] input) throws IOException {\n        double[] output = new double[input.length / 8];\n        int numProcessed = impl.unshuffle(input, 0, 8, input.length, output, 0);\n        assert(numProcessed == input.length);\n        return output;\n    }\n}\n", "/*--------------------------------------------------------------------------\n *  Copyright 2011 Taro L. Saito\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *--------------------------------------------------------------------------*/\n//--------------------------------------\n// XerialJ\n//\n// SnappyErrorCode.java\n// Since: 2011/03/30 14:56:50\n//\n// $URL$\n// $Author$\n//--------------------------------------\npackage org.xerial.snappy;\n\n/**\n * Error codes of snappy-java\n *\n * @author leo\n */\npublic enum SnappyErrorCode\n{\n\n    // DO NOT change these error code IDs because these numbers are used inside SnappyNative.cpp\n    UNKNOWN(0),\n    FAILED_TO_LOAD_NATIVE_LIBRARY(1),\n    PARSING_ERROR(2),\n    NOT_A_DIRECT_BUFFER(3),\n    OUT_OF_MEMORY(4),\n    FAILED_TO_UNCOMPRESS(5),\n    EMPTY_INPUT(6),\n    INCOMPATIBLE_VERSION(7),\n    INVALID_CHUNK_SIZE(8),\n    UNSUPPORTED_PLATFORM(9);\n\n    public final int id;\n\n    private SnappyErrorCode(int id)\n    {\n        this.id = id;\n    }\n\n    public static SnappyErrorCode getErrorCode(int id)\n    {\n        for (SnappyErrorCode code : SnappyErrorCode.values()) {\n            if (code.id == id) {\n                return code;\n            }\n        }\n        return UNKNOWN;\n    }\n\n    public static String getErrorMessage(int id)\n    {\n        return getErrorCode(id).name();\n    }\n}\n", "/*--------------------------------------------------------------------------\n *  Copyright 2011 Taro L. Saito\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *--------------------------------------------------------------------------*/\n//--------------------------------------\n// snappy-java Project\n//\n// SnappyTest.java\n// Since: 2011/03/30\n//\n// $URL$ \n// $Author$\n//--------------------------------------\npackage org.xerial.snappy;\n\nimport static org.junit.Assert.*;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\n\nimport org.junit.Assert;\nimport org.junit.Test;\nimport org.xerial.util.log.Logger;\n\npublic class SnappyTest\n{\n    private static Logger _logger = Logger.getLogger(SnappyTest.class);\n\n    @Test\n    public void getVersion()\n            throws Exception\n    {\n        String version = Snappy.getNativeLibraryVersion();\n        _logger.debug(\"version: \" + version);\n    }\n\n    @Test\n    public void directBufferCheck()\n            throws Exception\n    {\n\n        try {\n            ByteBuffer src = ByteBuffer.allocate(1024);\n            src.put(\"hello world\".getBytes());\n            src.flip();\n            ByteBuffer dest = ByteBuffer.allocate(1024);\n            int maxCompressedLen = Snappy.compress(src, dest);\n        }\n        catch (SnappyError e) {\n            Assert.assertTrue(e.errorCode == SnappyErrorCode.NOT_A_DIRECT_BUFFER);\n            return;\n        }\n\n        fail(\"shouldn't reach here\");\n    }\n\n    @Test\n    public void directBuffer()\n            throws Exception\n    {\n\n        StringBuilder s = new StringBuilder();\n        for (int i = 0; i < 20; ++i) {\n            s.append(\"Hello world!\");\n        }\n        String origStr = s.toString();\n        byte[] orig = origStr.getBytes();\n        int BUFFER_SIZE = orig.length;\n        ByteBuffer src = ByteBuffer.allocateDirect(orig.length);\n        src.put(orig);\n        src.flip();\n        _logger.debug(\"input size: \" + src.remaining());\n        int maxCompressedLen = Snappy.maxCompressedLength(src.remaining());\n        _logger.debug(\"max compressed length:\" + maxCompressedLen);\n\n        ByteBuffer compressed = ByteBuffer.allocateDirect(maxCompressedLen);\n        int compressedSize = Snappy.compress(src, compressed);\n        _logger.debug(\"compressed length: \" + compressedSize);\n\n        assertTrue(Snappy.isValidCompressedBuffer(compressed));\n\n        assertEquals(0, src.position());\n        assertEquals(orig.length, src.remaining());\n        assertEquals(orig.length, src.limit());\n\n        assertEquals(0, compressed.position());\n        assertEquals(compressedSize, compressed.limit());\n        assertEquals(compressedSize, compressed.remaining());\n\n        int uncompressedLen = Snappy.uncompressedLength(compressed);\n        _logger.debug(\"uncompressed length: \" + uncompressedLen);\n        ByteBuffer extract = ByteBuffer.allocateDirect(uncompressedLen);\n        int uncompressedLen2 = Snappy.uncompress(compressed, extract);\n        assertEquals(uncompressedLen, uncompressedLen2);\n        assertEquals(uncompressedLen, extract.remaining());\n\n        byte[] b = new byte[uncompressedLen];\n        extract.get(b);\n        String decompressed = new String(b);\n        _logger.debug(decompressed);\n\n        assertEquals(origStr, decompressed);\n    }\n\n    @Test\n    public void bufferOffset()\n            throws Exception\n    {\n\n        String m = \"ACCAGGGGGGGGGGGGGGGGGGGGATAGATATTTCCCGAGATATTTTATATAAAAAAA\";\n        byte[] orig = m.getBytes();\n        final int offset = 100;\n        ByteBuffer input = ByteBuffer.allocateDirect(orig.length + offset);\n        input.position(offset);\n        input.put(orig);\n        input.flip();\n        input.position(offset);\n\n        // compress\n        int maxCompressedLength = Snappy.maxCompressedLength(input.remaining());\n        final int offset2 = 40;\n        ByteBuffer compressed = ByteBuffer.allocateDirect(maxCompressedLength + offset2);\n        compressed.position(offset2);\n        Snappy.compress(input, compressed);\n        assertTrue(Snappy.isValidCompressedBuffer(compressed));\n\n        // uncompress\n        final int offset3 = 80;\n        int uncompressedLength = Snappy.uncompressedLength(compressed);\n        ByteBuffer uncompressed = ByteBuffer.allocateDirect(uncompressedLength + offset3);\n        uncompressed.position(offset3);\n        Snappy.uncompress(compressed, uncompressed);\n        assertEquals(offset3, uncompressed.position());\n        assertEquals(offset3 + uncompressedLength, uncompressed.limit());\n        assertEquals(uncompressedLength, uncompressed.remaining());\n\n        // extract string\n        byte[] recovered = new byte[uncompressedLength];\n        uncompressed.get(recovered);\n        String m2 = new String(recovered);\n\n        assertEquals(m, m2);\n    }\n\n    @Test\n    public void byteArrayCompress()\n            throws Exception\n    {\n\n        String m = \"ACCAGGGGGGGGGGGGGGGGGGGGATAGATATTTCCCGAGATATTTTATATAAAAAAA\";\n        byte[] input = m.getBytes();\n        byte[] output = new byte[Snappy.maxCompressedLength(input.length)];\n        int compressedSize = Snappy.compress(input, 0, input.length, output, 0);\n        byte[] uncompressed = new byte[input.length];\n\n        assertTrue(Snappy.isValidCompressedBuffer(output, 0, compressedSize));\n        int uncompressedSize = Snappy.uncompress(output, 0, compressedSize, uncompressed, 0);\n        String m2 = new String(uncompressed);\n        assertEquals(m, m2);\n    }\n\n    @Test\n    public void rangeCheck()\n            throws Exception\n    {\n        String m = \"ACCAGGGGGGGGGGGGGGGGGGGGATAGATATTTCCCGAGATATTTTATATAAAAAAA\";\n        byte[] input = m.getBytes();\n        byte[] output = new byte[Snappy.maxCompressedLength(input.length)];\n        int compressedSize = Snappy.compress(input, 0, input.length, output, 0);\n\n        assertTrue(Snappy.isValidCompressedBuffer(output, 0, compressedSize));\n        // Intentionally set an invalid range\n        assertFalse(Snappy.isValidCompressedBuffer(output, 0, compressedSize + 1));\n        assertFalse(Snappy.isValidCompressedBuffer(output, 1, compressedSize));\n\n        // Test the ByteBuffer API\n        ByteBuffer bin = ByteBuffer.allocateDirect(input.length);\n        bin.put(input);\n        bin.flip();\n        ByteBuffer bout = ByteBuffer.allocateDirect(Snappy.maxCompressedLength(bin.remaining()));\n        int compressedSize2 = Snappy.compress(bin, bout);\n        assertEquals(compressedSize, compressedSize2);\n\n        assertTrue(Snappy.isValidCompressedBuffer(bout));\n        // Intentionally set an invalid range\n        bout.limit(bout.limit() + 1);\n        assertFalse(Snappy.isValidCompressedBuffer(bout));\n        bout.limit(bout.limit() - 1);\n        bout.position(1);\n        assertFalse(Snappy.isValidCompressedBuffer(bout));\n    }\n\n    @Test\n    public void highLevelAPI()\n            throws Exception\n    {\n\n        String m = \"Hello! 01234 ACGDSFSDFJ World. FDSDF02394234 fdsfda03924\";\n        byte[] input = m.getBytes();\n        byte[] output = Snappy.compress(input);\n\n        byte[] uncompressed = Snappy.uncompress(output);\n        String m2 = new String(uncompressed);\n        assertEquals(m, m2);\n    }\n\n    @Test\n    public void lowLevelAPI()\n            throws Exception\n    {\n\n        String m = \"Hello! 01234 ACGDSFSDFJ World. FDSDF02394234 fdsfda03924\";\n        byte[] input = m.getBytes();\n        byte[] output = Snappy.rawCompress(input, input.length);\n\n        byte[] uncompressed = Snappy.uncompress(output);\n        String m2 = new String(uncompressed);\n        assertEquals(m, m2);\n    }\n\n    @Test\n    public void simpleUsage()\n            throws Exception\n    {\n\n        String input = \"Hello snappy-java! Snappy-java is a JNI-based wrapper\"\n                + \" for using Snappy from Google (written in C++), a fast compresser/decompresser.\";\n        byte[] compressed = Snappy.compress(input.getBytes(\"UTF-8\"));\n        byte[] uncompressed = Snappy.uncompress(compressed);\n        String result = new String(uncompressed, \"UTF-8\");\n        _logger.debug(result);\n    }\n\n    @Test\n    public void floatArray()\n            throws Exception\n    {\n        float[] data = new float[] {1.0f, -0.3f, 1.3f, 234.4f, 34};\n        byte[] compressed = Snappy.compress(data);\n        float[] result = Snappy.uncompressFloatArray(compressed);\n        assertArrayEquals(data, result, 0.0f);\n    }\n\n    @Test\n    public void doubleArray()\n            throws Exception\n    {\n        double[] data = new double[] {1.0, -0.3, 1.3, 234.4, 34};\n        byte[] compressed = Snappy.compress(data);\n        double[] result = Snappy.uncompressDoubleArray(compressed);\n        assertArrayEquals(data, result, 0.0f);\n    }\n\n    @Test\n    public void longArray()\n            throws Exception\n    {\n        long[] data = new long[] {2, 3, 15, 4234, 43251531412342342L, 23423422342L};\n        byte[] compressed = Snappy.compress(data);\n        long[] result = Snappy.uncompressLongArray(compressed);\n        assertArrayEquals(data, result);\n    }\n\n    @Test\n    public void shortArray()\n            throws Exception\n    {\n        short[] data = new short[] {432, -32267, 1, 3, 34, 43, 34, Short.MAX_VALUE, -1};\n        byte[] compressed = Snappy.compress(data);\n        short[] result = Snappy.uncompressShortArray(compressed);\n        assertArrayEquals(data, result);\n    }\n\n    @Test\n    public void intArray()\n            throws Exception\n    {\n        int[] data = new int[] {432, -32267, 1, 3, 34, 43, 34, Short.MAX_VALUE, -1, Integer.MAX_VALUE, 3424, 43};\n        byte[] compressed = Snappy.compress(data);\n        int[] result = Snappy.uncompressIntArray(compressed);\n        assertArrayEquals(data, result);\n    }\n\n    @Test\n    public void charArray()\n            throws Exception\n    {\n        char[] data = new char[] {'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd', '!'};\n        byte[] compressed = Snappy.compress(data);\n        char[] result = Snappy.uncompressCharArray(compressed);\n        assertArrayEquals(data, result);\n    }\n\n    @Test\n    public void string()\n            throws Exception\n    {\n        String s = \"Hello Snappy! Snappy! Snappy!\";\n        byte[] compressed = Snappy.compress(s);\n        String uncompressedString = Snappy.uncompressString(compressed);\n        assertEquals(s, uncompressedString);\n    }\n\n    @Test\n    public void isValidCompressedData()\n            throws Exception\n    {\n\n        byte[] b = new byte[] {(byte) 91, (byte) 34, (byte) 80, (byte) 73, (byte) 34, (byte) 93};\n\n        assertFalse(Snappy.isValidCompressedBuffer(b));\n\n        try {\n            byte[] uncompressed = Snappy.uncompress(b);\n            fail(\"cannot reach here since the input is invalid data\");\n        }\n        catch (IOException e) {\n            _logger.debug(e);\n        }\n    }\n}\n"], "fixing_code": ["/*--------------------------------------------------------------------------\n *  Copyright 2011 Taro L. Saito\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *--------------------------------------------------------------------------*/\n//--------------------------------------\n// snappy-java Project\n//\n// BitShuffle.java\n// Since: 2016/03/31\n//\n// $URL$\n// $Author$\n//--------------------------------------\npackage org.xerial.snappy;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\n\npublic class BitShuffle\n{\n    static {\n        try {\n            impl = SnappyLoader.loadBitShuffleApi();\n        }\n        catch (Exception e) {\n            throw new ExceptionInInitializerError(e);\n        }\n    }\n\n    /**\n     * An instance of BitShuffleNative\n     */\n    private static BitShuffleNative impl;\n\n    /**\n     * Apply a bit-shuffling filter into the content in the given input buffer. After bit-shuffling,\n     * you can retrieve the shuffled data from the output buffer [pos() ...limit())\n     * (shuffled data size = limit() - pos() = remaining()).\n     *\n     * @param input buffer[pos() ... limit()) containing the input data\n     * @param type element type of the input data\n     * @param shuffled output of the shuffled data. Uses range [pos()..].\n     * @return byte size of the shuffled data.\n     * @throws SnappyError when the input is not a direct buffer\n     * @throws IllegalArgumentException when the input length is not a multiple of the given type size\n     */\n    public static int shuffle(ByteBuffer input, BitShuffleType type, ByteBuffer shuffled) throws IOException {\n        if (!input.isDirect()) {\n            throw new SnappyError(SnappyErrorCode.NOT_A_DIRECT_BUFFER, \"input is not a direct buffer\");\n        }\n        if (!shuffled.isDirect()) {\n            throw new SnappyError(SnappyErrorCode.NOT_A_DIRECT_BUFFER, \"destination is not a direct buffer\");\n        }\n\n        // input: input[pos(), limit())\n        // output: shuffled\n        int uPos = input.position();\n        int uLen = input.remaining();\n        int typeSize = type.getTypeSize();\n        if (uLen % typeSize != 0) {\n            throw new IllegalArgumentException(\"input length must be a multiple of the given type size: \" + typeSize);\n        }\n        if (shuffled.remaining() < uLen) {\n            throw new IllegalArgumentException(\"not enough space for output\");\n        }\n        int numProcessed = impl.shuffleDirectBuffer(input, uPos, typeSize, uLen, shuffled, shuffled.position());\n        assert(numProcessed == uLen);\n\n        //         pos   limit\n        // [ ......BBBBBBB.........]\n        shuffled.limit(shuffled.position() + numProcessed);\n        return numProcessed;\n    }\n\n    /**\n     * Apply a bit-shuffling filter into the input short array.\n     *\n     * @param input\n     * @return bit-shuffled byte array\n     * @throws IOException\n     */\n    public static byte[] shuffle(short[] input) throws IOException {\n        if (input.length * 2 < input.length) {\n            throw new SnappyError(SnappyErrorCode.TOO_LARGE_INPUT, \"input array size is too large: \" + input.length);\n        }\n        byte[] output = new byte[input.length * 2];\n        int numProcessed = impl.shuffle(input, 0, 2, input.length * 2, output, 0);\n        assert(numProcessed == input.length * 2);\n        return output;\n    }\n\n    /**\n     * Apply a bit-shuffling filter into the input int array.\n     *\n     * @param input\n     * @return bit-shuffled byte array\n     * @throws IOException\n     */\n    public static byte[] shuffle(int[] input) throws IOException {\n        if (input.length * 4 < input.length) {\n            throw new SnappyError(SnappyErrorCode.TOO_LARGE_INPUT, \"input array size is too large: \" + input.length);\n        }\n        byte[] output = new byte[input.length * 4];\n        int numProcessed = impl.shuffle(input, 0, 4, input.length * 4, output, 0);\n        assert(numProcessed == input.length * 4);\n        return output;\n    }\n\n    /**\n     * Apply a bit-shuffling filter into the input long array.\n     *\n     * @param input\n     * @return bit-shuffled byte array\n     * @throws IOException\n     */\n    public static byte[] shuffle(long[] input) throws IOException {\n        if (input.length * 8 < input.length) {\n            throw new SnappyError(SnappyErrorCode.TOO_LARGE_INPUT, \"input array size is too large: \" + input.length);\n        }\n        byte[] output = new byte[input.length * 8];\n        int numProcessed = impl.shuffle(input, 0, 8, input.length * 8, output, 0);\n        assert(numProcessed == input.length * 8);\n        return output;\n    }\n\n    /**\n     * Apply a bit-shuffling filter into the input float array.\n     *\n     * @param input\n     * @return bit-shuffled byte array\n     * @throws IOException\n     */\n    public static byte[] shuffle(float[] input) throws IOException {\n        if (input.length * 4 < input.length) {\n            throw new SnappyError(SnappyErrorCode.TOO_LARGE_INPUT, \"input array size is too large: \" + input.length);\n        }\n        byte[] output = new byte[input.length * 4];\n        int numProcessed = impl.shuffle(input, 0, 4, input.length * 4, output, 0);\n        assert(numProcessed == input.length * 4);\n        return output;\n    }\n\n    /**\n     * Apply a bit-shuffling filter into the input double array.\n     *\n     * @param input\n     * @return bit-shuffled byte array\n     * @throws IOException\n     */\n    public static byte[] shuffle(double[] input) throws IOException {\n        if (input.length * 8 < input.length) {\n            throw new SnappyError(SnappyErrorCode.TOO_LARGE_INPUT, \"input array size is too large: \" + input.length);\n        }\n        byte[] output = new byte[input.length * 8];\n        int numProcessed = impl.shuffle(input, 0, 8, input.length * 8, output, 0);\n        assert(numProcessed == input.length * 8);\n        return output;\n    }\n\n    /**\n     * Convert the input bit-shuffled byte array into an original array. The result is dumped\n     * to the specified output buffer.\n     *\n     * @param shuffled buffer[pos() ... limit()) containing the input shuffled data\n     * @param type element type of the input data\n     * @param output output of the the original data. It uses buffer[pos()..]\n     * @return byte size of the unshuffled data.\n     * @throws IOException when failed to unshuffle the given input\n     * @throws SnappyError when the input is not a direct buffer\n     * @throws IllegalArgumentException when the length of input shuffled data is not a multiple of the given type size\n     */\n    public static int unshuffle(ByteBuffer shuffled, BitShuffleType type, ByteBuffer output) throws IOException {\n        if (!shuffled.isDirect()) {\n            throw new SnappyError(SnappyErrorCode.NOT_A_DIRECT_BUFFER, \"input is not a direct buffer\");\n        }\n        if (!output.isDirect()) {\n            throw new SnappyError(SnappyErrorCode.NOT_A_DIRECT_BUFFER, \"destination is not a direct buffer\");\n        }\n\n        // input: input[pos(), limit())\n        // output: shuffled\n        int uPos = shuffled.position();\n        int uLen = shuffled.remaining();\n        int typeSize = type.getTypeSize();\n        if (uLen % typeSize != 0) {\n            throw new IllegalArgumentException(\"length of input shuffled data must be a multiple of the given type size: \" + typeSize);\n        }\n        if (output.remaining() < uLen) {\n            throw new IllegalArgumentException(\"not enough space for output\");\n        }\n        int numProcessed = impl.unshuffleDirectBuffer(shuffled, uPos, typeSize, uLen, output, shuffled.position());\n        assert(numProcessed == uLen);\n\n        //         pos   limit\n        // [ ......BBBBBBB.........]\n        shuffled.limit(shuffled.position() + numProcessed);\n        return numProcessed;\n    }\n\n    /**\n     * Convert the input bit-shuffled byte array into an original short array.\n     *\n     * @param input\n     * @return a short array\n     * @throws IOException\n     */\n    public static short[] unshuffleShortArray(byte[] input) throws IOException {\n        short[] output = new short[input.length / 2];\n        int numProcessed = impl.unshuffle(input, 0, 2, input.length, output, 0);\n        assert(numProcessed == input.length);\n        return output;\n    }\n\n    /**\n     * Convert the input bit-shuffled byte array into an original int array.\n     *\n     * @param input\n     * @return an int array\n     * @throws IOException\n     */\n    public static int[] unshuffleIntArray(byte[] input) throws IOException {\n        int[] output = new int[input.length / 4];\n        int numProcessed = impl.unshuffle(input, 0, 4, input.length, output, 0);\n        assert(numProcessed == input.length);\n        return output;\n    }\n\n    /**\n     * Convert the input bit-shuffled byte array into an original long array.\n     *\n     * @param input\n     * @return a long array\n     * @throws IOException\n     */\n    public static long[] unshuffleLongArray(byte[] input) throws IOException {\n        long[] output = new long[input.length / 8];\n        int numProcessed = impl.unshuffle(input, 0, 8, input.length, output, 0);\n        assert(numProcessed == input.length);\n        return output;\n    }\n\n    /**\n     * Convert the input bit-shuffled byte array into an original float array.\n     *\n     * @param input\n     * @return an float array\n     * @throws IOException\n     */\n    public static float[] unshuffleFloatArray(byte[] input) throws IOException {\n        float[] output = new float[input.length / 4];\n        int numProcessed = impl.unshuffle(input, 0, 4, input.length, output, 0);\n        assert(numProcessed == input.length);\n        return output;\n    }\n\n    /**\n     * Convert the input bit-shuffled byte array into an original double array.\n     *\n     * @param input\n     * @return a double array\n     * @throws IOException\n     */\n    public static double[] unshuffleDoubleArray(byte[] input) throws IOException {\n        double[] output = new double[input.length / 8];\n        int numProcessed = impl.unshuffle(input, 0, 8, input.length, output, 0);\n        assert(numProcessed == input.length);\n        return output;\n    }\n}\n", "/*--------------------------------------------------------------------------\n *  Copyright 2011 Taro L. Saito\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *--------------------------------------------------------------------------*/\n//--------------------------------------\n// XerialJ\n//\n// SnappyErrorCode.java\n// Since: 2011/03/30 14:56:50\n//\n// $URL$\n// $Author$\n//--------------------------------------\npackage org.xerial.snappy;\n\n/**\n * Error codes of snappy-java\n *\n * @author leo\n */\npublic enum SnappyErrorCode\n{\n\n    // DO NOT change these error code IDs because these numbers are used inside SnappyNative.cpp\n    UNKNOWN(0),\n    FAILED_TO_LOAD_NATIVE_LIBRARY(1),\n    PARSING_ERROR(2),\n    NOT_A_DIRECT_BUFFER(3),\n    OUT_OF_MEMORY(4),\n    FAILED_TO_UNCOMPRESS(5),\n    EMPTY_INPUT(6),\n    INCOMPATIBLE_VERSION(7),\n    INVALID_CHUNK_SIZE(8),\n    UNSUPPORTED_PLATFORM(9),\n    TOO_LARGE_INPUT(10);\n\n    public final int id;\n\n    private SnappyErrorCode(int id)\n    {\n        this.id = id;\n    }\n\n    public static SnappyErrorCode getErrorCode(int id)\n    {\n        for (SnappyErrorCode code : SnappyErrorCode.values()) {\n            if (code.id == id) {\n                return code;\n            }\n        }\n        return UNKNOWN;\n    }\n\n    public static String getErrorMessage(int id)\n    {\n        return getErrorCode(id).name();\n    }\n}\n", "/*--------------------------------------------------------------------------\n *  Copyright 2011 Taro L. Saito\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *--------------------------------------------------------------------------*/\n//--------------------------------------\n// snappy-java Project\n//\n// SnappyTest.java\n// Since: 2011/03/30\n//\n// $URL$ \n// $Author$\n//--------------------------------------\npackage org.xerial.snappy;\n\nimport static org.junit.Assert.*;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\n\nimport org.junit.Assert;\nimport org.junit.Test;\nimport org.xerial.util.log.Logger;\n\npublic class SnappyTest\n{\n    private static Logger _logger = Logger.getLogger(SnappyTest.class);\n\n    @Test\n    public void getVersion()\n            throws Exception\n    {\n        String version = Snappy.getNativeLibraryVersion();\n        _logger.debug(\"version: \" + version);\n    }\n\n    @Test\n    public void directBufferCheck()\n            throws Exception\n    {\n\n        try {\n            ByteBuffer src = ByteBuffer.allocate(1024);\n            src.put(\"hello world\".getBytes());\n            src.flip();\n            ByteBuffer dest = ByteBuffer.allocate(1024);\n            int maxCompressedLen = Snappy.compress(src, dest);\n        }\n        catch (SnappyError e) {\n            Assert.assertTrue(e.errorCode == SnappyErrorCode.NOT_A_DIRECT_BUFFER);\n            return;\n        }\n\n        fail(\"shouldn't reach here\");\n    }\n\n    @Test\n    public void directBuffer()\n            throws Exception\n    {\n\n        StringBuilder s = new StringBuilder();\n        for (int i = 0; i < 20; ++i) {\n            s.append(\"Hello world!\");\n        }\n        String origStr = s.toString();\n        byte[] orig = origStr.getBytes();\n        int BUFFER_SIZE = orig.length;\n        ByteBuffer src = ByteBuffer.allocateDirect(orig.length);\n        src.put(orig);\n        src.flip();\n        _logger.debug(\"input size: \" + src.remaining());\n        int maxCompressedLen = Snappy.maxCompressedLength(src.remaining());\n        _logger.debug(\"max compressed length:\" + maxCompressedLen);\n\n        ByteBuffer compressed = ByteBuffer.allocateDirect(maxCompressedLen);\n        int compressedSize = Snappy.compress(src, compressed);\n        _logger.debug(\"compressed length: \" + compressedSize);\n\n        assertTrue(Snappy.isValidCompressedBuffer(compressed));\n\n        assertEquals(0, src.position());\n        assertEquals(orig.length, src.remaining());\n        assertEquals(orig.length, src.limit());\n\n        assertEquals(0, compressed.position());\n        assertEquals(compressedSize, compressed.limit());\n        assertEquals(compressedSize, compressed.remaining());\n\n        int uncompressedLen = Snappy.uncompressedLength(compressed);\n        _logger.debug(\"uncompressed length: \" + uncompressedLen);\n        ByteBuffer extract = ByteBuffer.allocateDirect(uncompressedLen);\n        int uncompressedLen2 = Snappy.uncompress(compressed, extract);\n        assertEquals(uncompressedLen, uncompressedLen2);\n        assertEquals(uncompressedLen, extract.remaining());\n\n        byte[] b = new byte[uncompressedLen];\n        extract.get(b);\n        String decompressed = new String(b);\n        _logger.debug(decompressed);\n\n        assertEquals(origStr, decompressed);\n    }\n\n    @Test\n    public void bufferOffset()\n            throws Exception\n    {\n\n        String m = \"ACCAGGGGGGGGGGGGGGGGGGGGATAGATATTTCCCGAGATATTTTATATAAAAAAA\";\n        byte[] orig = m.getBytes();\n        final int offset = 100;\n        ByteBuffer input = ByteBuffer.allocateDirect(orig.length + offset);\n        input.position(offset);\n        input.put(orig);\n        input.flip();\n        input.position(offset);\n\n        // compress\n        int maxCompressedLength = Snappy.maxCompressedLength(input.remaining());\n        final int offset2 = 40;\n        ByteBuffer compressed = ByteBuffer.allocateDirect(maxCompressedLength + offset2);\n        compressed.position(offset2);\n        Snappy.compress(input, compressed);\n        assertTrue(Snappy.isValidCompressedBuffer(compressed));\n\n        // uncompress\n        final int offset3 = 80;\n        int uncompressedLength = Snappy.uncompressedLength(compressed);\n        ByteBuffer uncompressed = ByteBuffer.allocateDirect(uncompressedLength + offset3);\n        uncompressed.position(offset3);\n        Snappy.uncompress(compressed, uncompressed);\n        assertEquals(offset3, uncompressed.position());\n        assertEquals(offset3 + uncompressedLength, uncompressed.limit());\n        assertEquals(uncompressedLength, uncompressed.remaining());\n\n        // extract string\n        byte[] recovered = new byte[uncompressedLength];\n        uncompressed.get(recovered);\n        String m2 = new String(recovered);\n\n        assertEquals(m, m2);\n    }\n\n    @Test\n    public void byteArrayCompress()\n            throws Exception\n    {\n\n        String m = \"ACCAGGGGGGGGGGGGGGGGGGGGATAGATATTTCCCGAGATATTTTATATAAAAAAA\";\n        byte[] input = m.getBytes();\n        byte[] output = new byte[Snappy.maxCompressedLength(input.length)];\n        int compressedSize = Snappy.compress(input, 0, input.length, output, 0);\n        byte[] uncompressed = new byte[input.length];\n\n        assertTrue(Snappy.isValidCompressedBuffer(output, 0, compressedSize));\n        int uncompressedSize = Snappy.uncompress(output, 0, compressedSize, uncompressed, 0);\n        String m2 = new String(uncompressed);\n        assertEquals(m, m2);\n    }\n\n    @Test\n    public void rangeCheck()\n            throws Exception\n    {\n        String m = \"ACCAGGGGGGGGGGGGGGGGGGGGATAGATATTTCCCGAGATATTTTATATAAAAAAA\";\n        byte[] input = m.getBytes();\n        byte[] output = new byte[Snappy.maxCompressedLength(input.length)];\n        int compressedSize = Snappy.compress(input, 0, input.length, output, 0);\n\n        assertTrue(Snappy.isValidCompressedBuffer(output, 0, compressedSize));\n        // Intentionally set an invalid range\n        assertFalse(Snappy.isValidCompressedBuffer(output, 0, compressedSize + 1));\n        assertFalse(Snappy.isValidCompressedBuffer(output, 1, compressedSize));\n\n        // Test the ByteBuffer API\n        ByteBuffer bin = ByteBuffer.allocateDirect(input.length);\n        bin.put(input);\n        bin.flip();\n        ByteBuffer bout = ByteBuffer.allocateDirect(Snappy.maxCompressedLength(bin.remaining()));\n        int compressedSize2 = Snappy.compress(bin, bout);\n        assertEquals(compressedSize, compressedSize2);\n\n        assertTrue(Snappy.isValidCompressedBuffer(bout));\n        // Intentionally set an invalid range\n        bout.limit(bout.limit() + 1);\n        assertFalse(Snappy.isValidCompressedBuffer(bout));\n        bout.limit(bout.limit() - 1);\n        bout.position(1);\n        assertFalse(Snappy.isValidCompressedBuffer(bout));\n    }\n\n    @Test\n    public void highLevelAPI()\n            throws Exception\n    {\n\n        String m = \"Hello! 01234 ACGDSFSDFJ World. FDSDF02394234 fdsfda03924\";\n        byte[] input = m.getBytes();\n        byte[] output = Snappy.compress(input);\n\n        byte[] uncompressed = Snappy.uncompress(output);\n        String m2 = new String(uncompressed);\n        assertEquals(m, m2);\n    }\n\n    @Test\n    public void lowLevelAPI()\n            throws Exception\n    {\n\n        String m = \"Hello! 01234 ACGDSFSDFJ World. FDSDF02394234 fdsfda03924\";\n        byte[] input = m.getBytes();\n        byte[] output = Snappy.rawCompress(input, input.length);\n\n        byte[] uncompressed = Snappy.uncompress(output);\n        String m2 = new String(uncompressed);\n        assertEquals(m, m2);\n    }\n\n    @Test\n    public void simpleUsage()\n            throws Exception\n    {\n\n        String input = \"Hello snappy-java! Snappy-java is a JNI-based wrapper\"\n                + \" for using Snappy from Google (written in C++), a fast compresser/decompresser.\";\n        byte[] compressed = Snappy.compress(input.getBytes(\"UTF-8\"));\n        byte[] uncompressed = Snappy.uncompress(compressed);\n        String result = new String(uncompressed, \"UTF-8\");\n        _logger.debug(result);\n    }\n\n    @Test\n    public void floatArray()\n            throws Exception\n    {\n        float[] data = new float[] {1.0f, -0.3f, 1.3f, 234.4f, 34};\n        byte[] compressed = Snappy.compress(data);\n        float[] result = Snappy.uncompressFloatArray(compressed);\n        assertArrayEquals(data, result, 0.0f);\n    }\n\n    @Test\n    public void doubleArray()\n            throws Exception\n    {\n        double[] data = new double[] {1.0, -0.3, 1.3, 234.4, 34};\n        byte[] compressed = Snappy.compress(data);\n        double[] result = Snappy.uncompressDoubleArray(compressed);\n        assertArrayEquals(data, result, 0.0f);\n    }\n\n    @Test\n    public void longArray()\n            throws Exception\n    {\n        long[] data = new long[] {2, 3, 15, 4234, 43251531412342342L, 23423422342L};\n        byte[] compressed = Snappy.compress(data);\n        long[] result = Snappy.uncompressLongArray(compressed);\n        assertArrayEquals(data, result);\n    }\n\n    @Test\n    public void shortArray()\n            throws Exception\n    {\n        short[] data = new short[] {432, -32267, 1, 3, 34, 43, 34, Short.MAX_VALUE, -1};\n        byte[] compressed = Snappy.compress(data);\n        short[] result = Snappy.uncompressShortArray(compressed);\n        assertArrayEquals(data, result);\n    }\n\n    @Test\n    public void intArray()\n            throws Exception\n    {\n        int[] data = new int[] {432, -32267, 1, 3, 34, 43, 34, Short.MAX_VALUE, -1, Integer.MAX_VALUE, 3424, 43};\n        byte[] compressed = Snappy.compress(data);\n        int[] result = Snappy.uncompressIntArray(compressed);\n        assertArrayEquals(data, result);\n    }\n\n    @Test\n    public void charArray()\n            throws Exception\n    {\n        char[] data = new char[] {'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd', '!'};\n        byte[] compressed = Snappy.compress(data);\n        char[] result = Snappy.uncompressCharArray(compressed);\n        assertArrayEquals(data, result);\n    }\n\n    @Test\n    public void string()\n            throws Exception\n    {\n        String s = \"Hello Snappy! Snappy! Snappy!\";\n        byte[] compressed = Snappy.compress(s);\n        String uncompressedString = Snappy.uncompressString(compressed);\n        assertEquals(s, uncompressedString);\n    }\n\n    @Test\n    public void isValidCompressedData()\n            throws Exception\n    {\n\n        byte[] b = new byte[] {(byte) 91, (byte) 34, (byte) 80, (byte) 73, (byte) 34, (byte) 93};\n\n        assertFalse(Snappy.isValidCompressedBuffer(b));\n\n        try {\n            byte[] uncompressed = Snappy.uncompress(b);\n            fail(\"cannot reach here since the input is invalid data\");\n        }\n        catch (IOException e) {\n            _logger.debug(e);\n        }\n    }\n\n    /*\n    Tests happy cases for BitShuffle.shuffle method\n    - double: 0, 10\n    - float: 0, 10\n    - int: 0, 10\n    - long: 0, 10\n    - short: 0, 10\n     */\n    @Test\n    public void isValidArrayInputLengthForBitShuffleShuffle()\n            throws Exception\n    {\n        byte[] b = BitShuffle.shuffle(new double[0]);\n        byte[] c = BitShuffle.shuffle(new float[0]);\n        byte[] d = BitShuffle.shuffle(new int[0]);\n        byte[] e = BitShuffle.shuffle(new long[0]);\n        byte[] f = BitShuffle.shuffle(new short[0]);\n        byte[] n = BitShuffle.shuffle(new double[10]);\n        byte[] o = BitShuffle.shuffle(new float[10]);\n        byte[] p = BitShuffle.shuffle(new int[10]);\n        byte[] q = BitShuffle.shuffle(new long[10]);\n        byte[] r = BitShuffle.shuffle(new short[10]);\n    }\n\n    /*\n    Tests sad cases for BitShuffle.shuffle method\n    - Allocate a buffer whose byte size will be a bit larger than Integer.MAX_VALUE\n    - double: 8\n    - float: 4\n    - int: 4\n    - long: 8\n    - short: 2\n     */\n    @Test(expected = SnappyError.class)\n    public void isTooLargeDoubleArrayInputLengthForBitShuffleShuffle() throws Exception {\n        BitShuffle.shuffle(new double[Integer.MAX_VALUE / 8 + 1]);\n    }\n\n    @Test(expected = SnappyError.class)\n    public void isTooLargeFloatArrayInputLengthForBitShuffleShuffle() throws Exception {\n        BitShuffle.shuffle(new float[Integer.MAX_VALUE / 4 + 1]);\n    }\n\n    @Test(expected = SnappyError.class)\n    public void isTooLargeIntArrayInputLengthForBitShuffleShuffle() throws Exception {\n        BitShuffle.shuffle(new float[Integer.MAX_VALUE / 4 + 1]);\n    }\n\n    @Test(expected = SnappyError.class)\n    public void isTooLargeLongArrayInputLengthForBitShuffleShuffle() throws Exception {\n        BitShuffle.shuffle(new long[Integer.MAX_VALUE / 8 + 1]);\n    }\n\n    @Test(expected = SnappyError.class)\n    public void isTooLargeShortArrayInputLengthForBitShuffleShuffle() throws Exception {\n        BitShuffle.shuffle(new short[Integer.MAX_VALUE / 2 + 1]);\n    }\n}\n"], "filenames": ["src/main/java/org/xerial/snappy/BitShuffle.java", "src/main/java/org/xerial/snappy/SnappyErrorCode.java", "src/test/java/org/xerial/snappy/SnappyTest.java"], "buggy_code_start_loc": [93, 45, 331], "buggy_code_end_loc": [149, 46, 331], "fixing_code_start_loc": [94, 45, 332], "fixing_code_end_loc": [165, 47, 390], "type": "CWE-190", "message": "snappy-java is a fast compressor/decompressor for Java. Due to unchecked multiplications, an integer overflow may occur in versions prior to 1.1.10.1, causing a fatal error.\n\nThe function `shuffle(int[] input)` in the file `BitShuffle.java` receives an array of integers and applies a bit shuffle on it. It does so by multiplying the length by 4 and passing it to the natively compiled shuffle function. Since the length is not tested, the multiplication by four can cause an integer overflow and become a smaller value than the true size, or even zero or negative. In the case of a negative value, a `java.lang.NegativeArraySizeException` exception will raise, which can crash the program. In a case of a value that is zero or too small, the code that afterwards references the shuffled array will assume a bigger size of the array, which might cause exceptions such as `java.lang.ArrayIndexOutOfBoundsException`.\n\nThe same issue exists also when using the `shuffle` functions that receive a double, float, long and short, each using a different multiplier that may cause the same issue.\n\nVersion 1.1.10.1 contains a patch for this vulnerability.", "other": {"cve": {"id": "CVE-2023-34453", "sourceIdentifier": "security-advisories@github.com", "published": "2023-06-15T17:15:09.790", "lastModified": "2023-06-27T15:59:58.483", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "snappy-java is a fast compressor/decompressor for Java. Due to unchecked multiplications, an integer overflow may occur in versions prior to 1.1.10.1, causing a fatal error.\n\nThe function `shuffle(int[] input)` in the file `BitShuffle.java` receives an array of integers and applies a bit shuffle on it. It does so by multiplying the length by 4 and passing it to the natively compiled shuffle function. Since the length is not tested, the multiplication by four can cause an integer overflow and become a smaller value than the true size, or even zero or negative. In the case of a negative value, a `java.lang.NegativeArraySizeException` exception will raise, which can crash the program. In a case of a value that is zero or too small, the code that afterwards references the shuffled array will assume a bigger size of the array, which might cause exceptions such as `java.lang.ArrayIndexOutOfBoundsException`.\n\nThe same issue exists also when using the `shuffle` functions that receive a double, float, long and short, each using a different multiplier that may cause the same issue.\n\nVersion 1.1.10.1 contains a patch for this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:xerial:snappy-java:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.1.10.1", "matchCriteriaId": "11C2E65C-E284-478A-8D65-351AF645472B"}]}]}], "references": [{"url": "https://github.com/xerial/snappy-java/blob/05c39b2ca9b5b7b39611529cc302d3d796329611/src/main/java/org/xerial/snappy/BitShuffle.java#L107", "source": "security-advisories@github.com", "tags": ["Issue Tracking"]}, {"url": "https://github.com/xerial/snappy-java/blob/master/src/main/java/org/xerial/snappy/BitShuffle.java", "source": "security-advisories@github.com", "tags": ["Issue Tracking"]}, {"url": "https://github.com/xerial/snappy-java/commit/820e2e074c58748b41dbd547f4edba9e108ad905", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/xerial/snappy-java/security/advisories/GHSA-pqr6-cmr2-h8hf", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/xerial/snappy-java/commit/820e2e074c58748b41dbd547f4edba9e108ad905"}}