{"buggy_code": ["// imagew-internals.h\n// Part of ImageWorsener, Copyright (c) 2011 by Jason Summers.\n// For more information, see the readme.txt file.\n\n#define IW_INCLUDE_UTIL_FUNCTIONS\n#include \"imagew.h\"\n\n#define IW_COPYRIGHT_YEAR \"2011\" \"\\xe2\\x80\\x93\" \"2015\"\n\n#ifdef IW_WINDOWS\n#define IW_INLINE __inline\n#else\n#define IW_INLINE inline\n#endif\n\n#define IW_MSG_MAX 200 // The usual max length of error messages, etc.\n\n// Data type used for samples during some internal calculations\ntypedef double iw_tmpsample;\n\n#ifdef IW_64BIT\n#define IW_DEFAULT_MAX_DIMENSION 1000000\n#define IW_DEFAULT_MAX_MALLOC 2000000000000\n#else\n#define IW_DEFAULT_MAX_DIMENSION 40000 // Must be less than sqrt(2^31).\n#define IW_DEFAULT_MAX_MALLOC 2000000000\n#endif\n\n#define IW_BKGD_STRATEGY_EARLY 1 // Apply background before resizing\n#define IW_BKGD_STRATEGY_LATE  2 // Apply background after resizing\n\n#define IW_NUM_CHANNELTYPES 5 // 5, for R,G,B, Alpha, Gray\n#define IW_CI_COUNT 4 // Number of channelinfo structs (=4, for R, G, B, A)\n\nstruct iw_rr_ctx; // \"resize rows\" state; see imagew-resize.c.\n\n// \"Raw\" settings from the application.\nstruct iw_resize_settings {\n\tint family;\n\tint edge_policy;\n\tint use_offset;\n\tint disable_rrctx_cache;\n\tdouble param1; // 'B' in Mitchell-Netravali cubics. \"lobes\" in Lanczos, etc.\n\tdouble param2; // 'C' in Mitchell-Netravali cubics.\n\tdouble blur_factor;\n\tdouble out_true_size; // Size onto which to map the input image.\n\tdouble translate; // Amount to move the image, before applying any channel offsets.\n\tdouble channel_offset[3]; // Indexed by IW_CHANNELTYPE_[Red..Blue]\n\tstruct iw_rr_ctx *rrctx;\n};\n\nstruct iw_channelinfo_in {\n\tint channeltype;\n\tint disable_fast_get_sample;\n\tdouble maxcolorcode_dbl;\n\tint maxcolorcode_int;\n};\n\nstruct iw_channelinfo_intermed {\n\tint channeltype;\n\n\tint cvt_to_grayscale; // (on input)\n\tint corresponding_input_channel; // (or the first of 3 channels if cvt_to_grayscale)\n\n\tint corresponding_output_channel; // Can be -1 if no such channel.\n\n\tdouble bkgd_color_lin; // Used if ctx->apply_bkgd && bkgd_strategy==EARLY\n\n\tint need_unassoc_alpha_processing; // Is this a color channel in an image with transparency?\n};\n\nstruct iw_channelinfo_out {\n\tint ditherfamily;\n\tint dithersubtype;\n\tint channeltype;\n\n\t// If restricting to a number of colors, colors are evenly\n\t// spaced (as evenly spaced as possible) in the target color space.\n\tint color_count; // 0=default\n\n\tdouble maxcolorcode_dbl;\n\tint maxcolorcode_int;\n\n\tint use_nearest_color_table;\n\n\tdouble bkgd1_color_lin; // Used if ctx->apply_bkgd\n\tdouble bkgd2_color_lin; // Used if ctx->apply_bkgd && bkgd_checkerboard\n};\n\nstruct iw_prng; // Defined imagew-util.c\n\n// Tracks the current image properties. May change as we optimize the image.\nstruct iw_opt_ctx {\n\tint height, width;\n\tint imgtype;\n\tint bit_depth;\n\tsize_t bpr;\n\n\t// A pointer to the current pixels. May point to tmp_pixels, or\n\t// to ctx->img2.pixels.\n\tconst iw_byte *pixelsptr;\n\n\t// A place for optimized pixels. If this is non-NULL, it will be\n\t// freed when IW is finished.\n\tiw_byte *tmp_pixels;\n\n\tint has_transparency;\n\tint has_partial_transparency;\n\tint has_16bit_precision;\n\tint has_color;\n\tint palette_is_grayscale;\n\n\tstruct iw_palette *palette;\n\n\tint has_colorkey_trns;\n\tunsigned int colorkey[3]; // Indexed by IW_CHANNELTYPE_[RED..BLUE]\n\n\tint has_bkgdlabel;\n\tunsigned int bkgdlabel[4]; // Indexed by IW_CHANNELTYPE_[RED..ALPHA]\n};\n\nstruct iw_option_struct {\n\tchar *name;\n\tchar *val;\n};\n\n// Used to help separate settings that were requested by the caller,\n// and that might not always be respected, or applicable.\nstruct iw_req_struct {\n\tint output_depth; // Bits/sample requested by the caller.\n\tint output_sample_type; // Reserved for future expansion.\n\tint output_maxcolorcode[IW_NUM_CHANNELTYPES];\n\n\t// Requested color counts; 0 = \"not set\"\n\tint color_count[IW_NUM_CHANNELTYPES]; // Indexed by IW_CHANNELTYPE_[Red..Gray]\n\n\t// Image size requested by user. The actual size to use is stored in .resize_settings.\n\tint out_true_valid;\n\tdouble out_true_width, out_true_height;\n\n\tint output_rendering_intent;\n\n\tint output_cs_valid;\n\tstruct iw_csdescr output_cs;\n\n\tint suppress_output_cslabel;\n\tint negate_target;\n\n\tint bkgd_valid;\n\tint bkgd_checkerboard; // 1=caller requested a checkerboard background\n\tstruct iw_color bkgd; // The requested (primary) background color (linear colorspace).\n\tstruct iw_color bkgd2; // The requested secondary background color.\n\n\tint output_bkgd_label_valid;\n\tstruct iw_color output_bkgd_label; // Uses linear colorspace\n\n\tint use_bkgd_label_from_file; // Prefer the bkgd color from the input file.\n\tint suppress_output_bkgd_label;\n\n\t// These are not used by the core library, but codecs may use them:\n\tint output_format;\n\tint compression; // IW_COMPRESSION_*. Suggested compression algorithm.\n\tint page_to_read;\n\tint include_screen;\n\tint jpeg_samp_factor_h, jpeg_samp_factor_v; // 0 means default\n\tint interlaced;\n\tint bmp_no_fileheader;\n\n\tstruct iw_option_struct *options;\n\tint options_count;\n\tint options_numalloc;\n};\n\nstruct iw_context {\n\tint caller_api_version;\n\tint use_count;\n\tunsigned int output_profile;\n\n\tiw_mallocfn_type mallocfn;\n\tiw_freefn_type freefn;\n\n\tiw_float32 *intermediate32;\n\tiw_float32 *intermediate_alpha32;\n\tiw_float32 *final_alpha32;\n\n\tstruct iw_channelinfo_in img1_ci[IW_CI_COUNT];\n\n\tstruct iw_image img1;\n\tstruct iw_csdescr img1cs;\n\tint img1_imgtype_logical;\n\n\tint img1_numchannels_physical;\n\tint img1_numchannels_logical;\n\tint img1_alpha_channel_index;\n\n\t// The suggested background color read from the input file.\n\tint img1_bkgd_label_set;\n\tstruct iw_color img1_bkgd_label_inputcs;\n\tstruct iw_color img1_bkgd_label_lin; // img1.bkgd_color_*\n\n\tstruct iw_channelinfo_intermed intermed_ci[IW_CI_COUNT];\n\tint intermed_imgtype;\n\tint intermed_numchannels;\n\tint intermed_alpha_channel_index;\n\tint intermed_canvas_width, intermed_canvas_height;\n\n\tstruct iw_image img2;\n\tstruct iw_csdescr img2cs;\n\tstruct iw_channelinfo_out img2_ci[IW_CI_COUNT];\n\tint img2_numchannels;\n\n\tint ditherfamily_by_channeltype[IW_NUM_CHANNELTYPES]; // Indexed by IW_CHANNELTYPE_[Red..Gray]\n\tint dithersubtype_by_channeltype[IW_NUM_CHANNELTYPES]; // Indexed by IW_CHANNELTYPE_[Red..Gray]\n\tint uses_errdiffdither;\n\tstruct iw_prng *prng; // Pseudorandom number generator state\n\n\t// Indexed by IW_DIMENSION_*.\n\tstruct iw_resize_settings resize_settings[2];\n\n\tint to_grayscale;\n\n\tint apply_bkgd; // 1 = We will be applying a background color.\n\tint apply_bkgd_strategy; // IW_BKGD_STRATEGY_*\n\tint bkgd_checkerboard; // valid if apply_bkgd is set. 0=solid, 1=checkerboard\n\tint bkgd_check_size;\n\tint bkgd_check_origin[2]; // Indexed by IW_DIMENSION_*\n\n#define IW_BKGD_COLOR_SOURCE_NONE 0 // Use a default color\n#define IW_BKGD_COLOR_SOURCE_FILE 1 // Use ctx->img1_bkgd_label_lin\n#define IW_BKGD_COLOR_SOURCE_REQ  2 // Use ctx->req.bkgd\n\tint bkgd_color_source; // Valid if .apply_bkgd is set.\n\n\t// Background color alpha samples. (The color samples are stored in\n\t// iw_channelinfo_out.)\n\tdouble bkgd1alpha, bkgd2alpha;\n\n\tvoid *userdata;\n\tiw_translatefn_type translate_fn;\n\tiw_warningfn_type warning_fn;\n\n\tint input_maxcolorcode_int;  // Based on the source image's full bitdepth\n\tdouble input_maxcolorcode;\n\n\tint support_reduced_input_bitdepths;\n\n\tint disable_output_lookup_tables;\n\tint reduced_output_maxcolor_flag;  // Are there any reduced output maxcolorcodes?\n\n\t// Max number of rows for error-diffusion dithering, including current row.\n#define IW_DITHER_MAXROWS 3\n\t// Error accumulators for error-diffusion dithering.\n\tdouble *dither_errors[IW_DITHER_MAXROWS]; // 0 is the current row.\n\n\tint randomize; // 0 to use random_seed, nonzero to use a different seed every time.\n\tint random_seed;\n\n\tsize_t max_malloc;\n\tint max_width, max_height;\n\n\tint error_flag;\n\tchar *error_msg;\n\n\tstruct iw_opt_ctx optctx;\n\n\tint no_gamma; // Disable gamma correction. (IW_VAL_DISABLE_GAMMA)\n\tint intclamp; // Clamp the intermediate samples to the 0.0-1.0 range.\n\tint grayscale_formula; // IW_GSF_*\n\tdouble grayscale_weight[3];\n\tint pref_units; // IW_PREF_UNITS_*\n\n\t// Optimization codes. Can be set to 0 to disallow this optimization\n\tiw_byte opt_grayscale; // RGB-to-grayscale\n\tiw_byte opt_palette;   // Palette images\n\tiw_byte opt_16_to_8;   // Reduce >8 bitdepth to 8\n\tiw_byte opt_strip_alpha; // RGBA->RGB or GA->G\n\tiw_byte opt_binary_trns; // Color-keyed binary transparency\n\n\tint canvas_width, canvas_height;\n\tint input_start_x, input_start_y, input_w, input_h;\n\n\tstruct iw_req_struct req;\n\n\t// Color correction tables, to improve performance.\n\tdouble *input_color_corr_table;\n\t// This is not for converting linear to the output colorspace; it's the\n\t// same as input_color_corr_table except that it might have a different\n\t// number of entries, and might be for a different colorspace.\n\tdouble *output_rev_color_corr_table;\n\n\tdouble *nearest_color_table;\n\n\tstruct iw_zlib_module *zlib_module;\n};\n\n// Defined imagew-util.c\nstruct iw_prng *iwpvt_prng_create(struct iw_context *ctx);\nvoid iwpvt_prng_destroy(struct iw_context *ctx, struct iw_prng *prng);\nvoid iwpvt_prng_set_random_seed(struct iw_prng *prng, int s);\niw_uint32 iwpvt_prng_rand(struct iw_prng *prng); // Returns a pseudorandom number.\nint iwpvt_util_randomize(struct iw_prng *prng); // Returns the random seed that was used.\nvoid* iwpvt_default_malloc(void *userdata, unsigned int flags, size_t n);\nvoid iwpvt_default_free(void *userdata, void *mem);\nchar* iwpvt_strdup_dbl(struct iw_context *ctx, double n);\n\n// Defined in imagew-resize.c\nstruct iw_rr_ctx *iwpvt_resize_rows_init(struct iw_context *ctx,\n  struct iw_resize_settings *rs, int channeltype, int num_in_pix, int num_out_pix);\nvoid iwpvt_resize_rows_done(struct iw_rr_ctx *rrctx);\nvoid iwpvt_resize_row_main(struct iw_rr_ctx *rrctx, iw_tmpsample *in_pix, iw_tmpsample *out_pix);\n\n// Defined in imagew-opt.c\nvoid iwpvt_optimize_image(struct iw_context *ctx);\n"], "fixing_code": ["// imagew-internals.h\n// Part of ImageWorsener, Copyright (c) 2011 by Jason Summers.\n// For more information, see the readme.txt file.\n\n#define IW_INCLUDE_UTIL_FUNCTIONS\n#include \"imagew.h\"\n\n#define IW_COPYRIGHT_YEAR \"2011\" \"\\xe2\\x80\\x93\" \"2015\"\n\n#ifdef IW_WINDOWS\n#define IW_INLINE __inline\n#else\n#define IW_INLINE inline\n#endif\n\n#define IW_MSG_MAX 200 // The usual max length of error messages, etc.\n\n// Data type used for samples during some internal calculations\ntypedef double iw_tmpsample;\n\n#ifdef IW_64BIT\n#define IW_DEFAULT_MAX_DIMENSION 40000\n#define IW_DEFAULT_MAX_MALLOC 2000000000\n#else\n#define IW_DEFAULT_MAX_DIMENSION 40000 // Must be less than sqrt(2^31).\n#define IW_DEFAULT_MAX_MALLOC 2000000000\n#endif\n\n#define IW_BKGD_STRATEGY_EARLY 1 // Apply background before resizing\n#define IW_BKGD_STRATEGY_LATE  2 // Apply background after resizing\n\n#define IW_NUM_CHANNELTYPES 5 // 5, for R,G,B, Alpha, Gray\n#define IW_CI_COUNT 4 // Number of channelinfo structs (=4, for R, G, B, A)\n\nstruct iw_rr_ctx; // \"resize rows\" state; see imagew-resize.c.\n\n// \"Raw\" settings from the application.\nstruct iw_resize_settings {\n\tint family;\n\tint edge_policy;\n\tint use_offset;\n\tint disable_rrctx_cache;\n\tdouble param1; // 'B' in Mitchell-Netravali cubics. \"lobes\" in Lanczos, etc.\n\tdouble param2; // 'C' in Mitchell-Netravali cubics.\n\tdouble blur_factor;\n\tdouble out_true_size; // Size onto which to map the input image.\n\tdouble translate; // Amount to move the image, before applying any channel offsets.\n\tdouble channel_offset[3]; // Indexed by IW_CHANNELTYPE_[Red..Blue]\n\tstruct iw_rr_ctx *rrctx;\n};\n\nstruct iw_channelinfo_in {\n\tint channeltype;\n\tint disable_fast_get_sample;\n\tdouble maxcolorcode_dbl;\n\tint maxcolorcode_int;\n};\n\nstruct iw_channelinfo_intermed {\n\tint channeltype;\n\n\tint cvt_to_grayscale; // (on input)\n\tint corresponding_input_channel; // (or the first of 3 channels if cvt_to_grayscale)\n\n\tint corresponding_output_channel; // Can be -1 if no such channel.\n\n\tdouble bkgd_color_lin; // Used if ctx->apply_bkgd && bkgd_strategy==EARLY\n\n\tint need_unassoc_alpha_processing; // Is this a color channel in an image with transparency?\n};\n\nstruct iw_channelinfo_out {\n\tint ditherfamily;\n\tint dithersubtype;\n\tint channeltype;\n\n\t// If restricting to a number of colors, colors are evenly\n\t// spaced (as evenly spaced as possible) in the target color space.\n\tint color_count; // 0=default\n\n\tdouble maxcolorcode_dbl;\n\tint maxcolorcode_int;\n\n\tint use_nearest_color_table;\n\n\tdouble bkgd1_color_lin; // Used if ctx->apply_bkgd\n\tdouble bkgd2_color_lin; // Used if ctx->apply_bkgd && bkgd_checkerboard\n};\n\nstruct iw_prng; // Defined imagew-util.c\n\n// Tracks the current image properties. May change as we optimize the image.\nstruct iw_opt_ctx {\n\tint height, width;\n\tint imgtype;\n\tint bit_depth;\n\tsize_t bpr;\n\n\t// A pointer to the current pixels. May point to tmp_pixels, or\n\t// to ctx->img2.pixels.\n\tconst iw_byte *pixelsptr;\n\n\t// A place for optimized pixels. If this is non-NULL, it will be\n\t// freed when IW is finished.\n\tiw_byte *tmp_pixels;\n\n\tint has_transparency;\n\tint has_partial_transparency;\n\tint has_16bit_precision;\n\tint has_color;\n\tint palette_is_grayscale;\n\n\tstruct iw_palette *palette;\n\n\tint has_colorkey_trns;\n\tunsigned int colorkey[3]; // Indexed by IW_CHANNELTYPE_[RED..BLUE]\n\n\tint has_bkgdlabel;\n\tunsigned int bkgdlabel[4]; // Indexed by IW_CHANNELTYPE_[RED..ALPHA]\n};\n\nstruct iw_option_struct {\n\tchar *name;\n\tchar *val;\n};\n\n// Used to help separate settings that were requested by the caller,\n// and that might not always be respected, or applicable.\nstruct iw_req_struct {\n\tint output_depth; // Bits/sample requested by the caller.\n\tint output_sample_type; // Reserved for future expansion.\n\tint output_maxcolorcode[IW_NUM_CHANNELTYPES];\n\n\t// Requested color counts; 0 = \"not set\"\n\tint color_count[IW_NUM_CHANNELTYPES]; // Indexed by IW_CHANNELTYPE_[Red..Gray]\n\n\t// Image size requested by user. The actual size to use is stored in .resize_settings.\n\tint out_true_valid;\n\tdouble out_true_width, out_true_height;\n\n\tint output_rendering_intent;\n\n\tint output_cs_valid;\n\tstruct iw_csdescr output_cs;\n\n\tint suppress_output_cslabel;\n\tint negate_target;\n\n\tint bkgd_valid;\n\tint bkgd_checkerboard; // 1=caller requested a checkerboard background\n\tstruct iw_color bkgd; // The requested (primary) background color (linear colorspace).\n\tstruct iw_color bkgd2; // The requested secondary background color.\n\n\tint output_bkgd_label_valid;\n\tstruct iw_color output_bkgd_label; // Uses linear colorspace\n\n\tint use_bkgd_label_from_file; // Prefer the bkgd color from the input file.\n\tint suppress_output_bkgd_label;\n\n\t// These are not used by the core library, but codecs may use them:\n\tint output_format;\n\tint compression; // IW_COMPRESSION_*. Suggested compression algorithm.\n\tint page_to_read;\n\tint include_screen;\n\tint jpeg_samp_factor_h, jpeg_samp_factor_v; // 0 means default\n\tint interlaced;\n\tint bmp_no_fileheader;\n\n\tstruct iw_option_struct *options;\n\tint options_count;\n\tint options_numalloc;\n};\n\nstruct iw_context {\n\tint caller_api_version;\n\tint use_count;\n\tunsigned int output_profile;\n\n\tiw_mallocfn_type mallocfn;\n\tiw_freefn_type freefn;\n\n\tiw_float32 *intermediate32;\n\tiw_float32 *intermediate_alpha32;\n\tiw_float32 *final_alpha32;\n\n\tstruct iw_channelinfo_in img1_ci[IW_CI_COUNT];\n\n\tstruct iw_image img1;\n\tstruct iw_csdescr img1cs;\n\tint img1_imgtype_logical;\n\n\tint img1_numchannels_physical;\n\tint img1_numchannels_logical;\n\tint img1_alpha_channel_index;\n\n\t// The suggested background color read from the input file.\n\tint img1_bkgd_label_set;\n\tstruct iw_color img1_bkgd_label_inputcs;\n\tstruct iw_color img1_bkgd_label_lin; // img1.bkgd_color_*\n\n\tstruct iw_channelinfo_intermed intermed_ci[IW_CI_COUNT];\n\tint intermed_imgtype;\n\tint intermed_numchannels;\n\tint intermed_alpha_channel_index;\n\tint intermed_canvas_width, intermed_canvas_height;\n\n\tstruct iw_image img2;\n\tstruct iw_csdescr img2cs;\n\tstruct iw_channelinfo_out img2_ci[IW_CI_COUNT];\n\tint img2_numchannels;\n\n\tint ditherfamily_by_channeltype[IW_NUM_CHANNELTYPES]; // Indexed by IW_CHANNELTYPE_[Red..Gray]\n\tint dithersubtype_by_channeltype[IW_NUM_CHANNELTYPES]; // Indexed by IW_CHANNELTYPE_[Red..Gray]\n\tint uses_errdiffdither;\n\tstruct iw_prng *prng; // Pseudorandom number generator state\n\n\t// Indexed by IW_DIMENSION_*.\n\tstruct iw_resize_settings resize_settings[2];\n\n\tint to_grayscale;\n\n\tint apply_bkgd; // 1 = We will be applying a background color.\n\tint apply_bkgd_strategy; // IW_BKGD_STRATEGY_*\n\tint bkgd_checkerboard; // valid if apply_bkgd is set. 0=solid, 1=checkerboard\n\tint bkgd_check_size;\n\tint bkgd_check_origin[2]; // Indexed by IW_DIMENSION_*\n\n#define IW_BKGD_COLOR_SOURCE_NONE 0 // Use a default color\n#define IW_BKGD_COLOR_SOURCE_FILE 1 // Use ctx->img1_bkgd_label_lin\n#define IW_BKGD_COLOR_SOURCE_REQ  2 // Use ctx->req.bkgd\n\tint bkgd_color_source; // Valid if .apply_bkgd is set.\n\n\t// Background color alpha samples. (The color samples are stored in\n\t// iw_channelinfo_out.)\n\tdouble bkgd1alpha, bkgd2alpha;\n\n\tvoid *userdata;\n\tiw_translatefn_type translate_fn;\n\tiw_warningfn_type warning_fn;\n\n\tint input_maxcolorcode_int;  // Based on the source image's full bitdepth\n\tdouble input_maxcolorcode;\n\n\tint support_reduced_input_bitdepths;\n\n\tint disable_output_lookup_tables;\n\tint reduced_output_maxcolor_flag;  // Are there any reduced output maxcolorcodes?\n\n\t// Max number of rows for error-diffusion dithering, including current row.\n#define IW_DITHER_MAXROWS 3\n\t// Error accumulators for error-diffusion dithering.\n\tdouble *dither_errors[IW_DITHER_MAXROWS]; // 0 is the current row.\n\n\tint randomize; // 0 to use random_seed, nonzero to use a different seed every time.\n\tint random_seed;\n\n\tsize_t max_malloc;\n\tint max_width, max_height;\n\n\tint error_flag;\n\tchar *error_msg;\n\n\tstruct iw_opt_ctx optctx;\n\n\tint no_gamma; // Disable gamma correction. (IW_VAL_DISABLE_GAMMA)\n\tint intclamp; // Clamp the intermediate samples to the 0.0-1.0 range.\n\tint grayscale_formula; // IW_GSF_*\n\tdouble grayscale_weight[3];\n\tint pref_units; // IW_PREF_UNITS_*\n\n\t// Optimization codes. Can be set to 0 to disallow this optimization\n\tiw_byte opt_grayscale; // RGB-to-grayscale\n\tiw_byte opt_palette;   // Palette images\n\tiw_byte opt_16_to_8;   // Reduce >8 bitdepth to 8\n\tiw_byte opt_strip_alpha; // RGBA->RGB or GA->G\n\tiw_byte opt_binary_trns; // Color-keyed binary transparency\n\n\tint canvas_width, canvas_height;\n\tint input_start_x, input_start_y, input_w, input_h;\n\n\tstruct iw_req_struct req;\n\n\t// Color correction tables, to improve performance.\n\tdouble *input_color_corr_table;\n\t// This is not for converting linear to the output colorspace; it's the\n\t// same as input_color_corr_table except that it might have a different\n\t// number of entries, and might be for a different colorspace.\n\tdouble *output_rev_color_corr_table;\n\n\tdouble *nearest_color_table;\n\n\tstruct iw_zlib_module *zlib_module;\n};\n\n// Defined imagew-util.c\nstruct iw_prng *iwpvt_prng_create(struct iw_context *ctx);\nvoid iwpvt_prng_destroy(struct iw_context *ctx, struct iw_prng *prng);\nvoid iwpvt_prng_set_random_seed(struct iw_prng *prng, int s);\niw_uint32 iwpvt_prng_rand(struct iw_prng *prng); // Returns a pseudorandom number.\nint iwpvt_util_randomize(struct iw_prng *prng); // Returns the random seed that was used.\nvoid* iwpvt_default_malloc(void *userdata, unsigned int flags, size_t n);\nvoid iwpvt_default_free(void *userdata, void *mem);\nchar* iwpvt_strdup_dbl(struct iw_context *ctx, double n);\n\n// Defined in imagew-resize.c\nstruct iw_rr_ctx *iwpvt_resize_rows_init(struct iw_context *ctx,\n  struct iw_resize_settings *rs, int channeltype, int num_in_pix, int num_out_pix);\nvoid iwpvt_resize_rows_done(struct iw_rr_ctx *rrctx);\nvoid iwpvt_resize_row_main(struct iw_rr_ctx *rrctx, iw_tmpsample *in_pix, iw_tmpsample *out_pix);\n\n// Defined in imagew-opt.c\nvoid iwpvt_optimize_image(struct iw_context *ctx);\n"], "filenames": ["src/imagew-internals.h"], "buggy_code_start_loc": [22], "buggy_code_end_loc": [24], "fixing_code_start_loc": [22], "fixing_code_end_loc": [24], "type": "CWE-119", "message": "The iw_process_cols_to_intermediate function in imagew-main.c in libimageworsener.a in ImageWorsener before 1.3.1 allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted image.", "other": {"cve": {"id": "CVE-2017-8325", "sourceIdentifier": "cve@mitre.org", "published": "2017-04-29T20:59:00.167", "lastModified": "2019-09-16T14:33:33.077", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The iw_process_cols_to_intermediate function in imagew-main.c in libimageworsener.a in ImageWorsener before 1.3.1 allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted image."}, {"lang": "es", "value": "La funci\u00f3n iw_process_cols_to_intermediate en imagew-main.c en libimageworsener.a en ImageWorsener anterior a la versi\u00f3n 1.3.1, permite a los atacantes remotos causar una denegaci\u00f3n de servicio (desbordamiento de b\u00fafer en memoria din\u00e1mica y bloqueo de la aplicaci\u00f3n) u otro posible impacto no especificado a trav\u00e9s de una imagen manipulada."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:entropymine:imageworsener:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.3.1", "matchCriteriaId": "B644C2C7-E253-4476-80BE-232705D0A145"}]}]}], "references": [{"url": "https://blogs.gentoo.org/ago/2017/04/27/imageworsener-heap-based-buffer-overflow-in-iw_process_cols_to_intermediate-imagew-main-c/", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/jsummers/imageworsener/commit/86564051db45b466e5f667111ce00b5eeedc8fb6", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201706-06", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/jsummers/imageworsener/commit/86564051db45b466e5f667111ce00b5eeedc8fb6"}}