{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * MAX3421 Host Controller driver for USB.\n *\n * Author: David Mosberger-Tang <davidm@egauge.net>\n *\n * (C) Copyright 2014 David Mosberger-Tang <davidm@egauge.net>\n *\n * MAX3421 is a chip implementing a USB 2.0 Full-/Low-Speed host\n * controller on a SPI bus.\n *\n * Based on:\n *\to MAX3421E datasheet\n *\t\thttps://datasheets.maximintegrated.com/en/ds/MAX3421E.pdf\n *\to MAX3421E Programming Guide\n *\t\thttps://www.hdl.co.jp/ftpdata/utl-001/AN3785.pdf\n *\to gadget/dummy_hcd.c\n *\t\tFor USB HCD implementation.\n *\to Arduino MAX3421 driver\n *\t     https://github.com/felis/USB_Host_Shield_2.0/blob/master/Usb.cpp\n *\n * This file is licenced under the GPL v2.\n *\n * Important note on worst-case (full-speed) packet size constraints\n * (See USB 2.0 Section 5.6.3 and following):\n *\n *\t- control:\t  64 bytes\n *\t- isochronous:\t1023 bytes\n *\t- interrupt:\t  64 bytes\n *\t- bulk:\t\t  64 bytes\n *\n * Since the MAX3421 FIFO size is 64 bytes, we do not have to work about\n * multi-FIFO writes/reads for a single USB packet *except* for isochronous\n * transfers.  We don't support isochronous transfers at this time, so we\n * just assume that a USB packet always fits into a single FIFO buffer.\n *\n * NOTE: The June 2006 version of \"MAX3421E Programming Guide\"\n * (AN3785) has conflicting info for the RCVDAVIRQ bit:\n *\n *\tThe description of RCVDAVIRQ says \"The CPU *must* clear\n *\tthis IRQ bit (by writing a 1 to it) before reading the\n *\tRCVFIFO data.\n *\n * However, the earlier section on \"Programming BULK-IN\n * Transfers\" says * that:\n *\n *\tAfter the CPU retrieves the data, it clears the\n *\tRCVDAVIRQ bit.\n *\n * The December 2006 version has been corrected and it consistently\n * states the second behavior is the correct one.\n *\n * Synchronous SPI transactions sleep so we can't perform any such\n * transactions while holding a spin-lock (and/or while interrupts are\n * masked).  To achieve this, all SPI transactions are issued from a\n * single thread (max3421_spi_thread).\n */\n\n#include <linux/jiffies.h>\n#include <linux/module.h>\n#include <linux/spi/spi.h>\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n#include <linux/of.h>\n\n#include <linux/platform_data/max3421-hcd.h>\n\n#define DRIVER_DESC\t\"MAX3421 USB Host-Controller Driver\"\n#define DRIVER_VERSION\t\"1.0\"\n\n/* 11-bit counter that wraps around (USB 2.0 Section 8.3.3): */\n#define USB_MAX_FRAME_NUMBER\t0x7ff\n#define USB_MAX_RETRIES\t\t3 /* # of retries before error is reported */\n\n/*\n * Max. # of times we're willing to retransmit a request immediately in\n * resposne to a NAK.  Afterwards, we fall back on trying once a frame.\n */\n#define NAK_MAX_FAST_RETRANSMITS\t2\n\n#define POWER_BUDGET\t500\t/* in mA; use 8 for low-power port testing */\n\n/* Port-change mask: */\n#define PORT_C_MASK\t((USB_PORT_STAT_C_CONNECTION |\t\\\n\t\t\t  USB_PORT_STAT_C_ENABLE |\t\\\n\t\t\t  USB_PORT_STAT_C_SUSPEND |\t\\\n\t\t\t  USB_PORT_STAT_C_OVERCURRENT | \\\n\t\t\t  USB_PORT_STAT_C_RESET) << 16)\n\n#define MAX3421_GPOUT_COUNT\t8\n\nenum max3421_rh_state {\n\tMAX3421_RH_RESET,\n\tMAX3421_RH_SUSPENDED,\n\tMAX3421_RH_RUNNING\n};\n\nenum pkt_state {\n\tPKT_STATE_SETUP,\t/* waiting to send setup packet to ctrl pipe */\n\tPKT_STATE_TRANSFER,\t/* waiting to xfer transfer_buffer */\n\tPKT_STATE_TERMINATE\t/* waiting to terminate control transfer */\n};\n\nenum scheduling_pass {\n\tSCHED_PASS_PERIODIC,\n\tSCHED_PASS_NON_PERIODIC,\n\tSCHED_PASS_DONE\n};\n\n/* Bit numbers for max3421_hcd->todo: */\nenum {\n\tENABLE_IRQ = 0,\n\tRESET_HCD,\n\tRESET_PORT,\n\tCHECK_UNLINK,\n\tIOPIN_UPDATE\n};\n\nstruct max3421_dma_buf {\n\tu8 data[2];\n};\n\nstruct max3421_hcd {\n\tspinlock_t lock;\n\n\tstruct task_struct *spi_thread;\n\n\tstruct max3421_hcd *next;\n\n\tenum max3421_rh_state rh_state;\n\t/* lower 16 bits contain port status, upper 16 bits the change mask: */\n\tu32 port_status;\n\n\tunsigned active:1;\n\n\tstruct list_head ep_list;\t/* list of EP's with work */\n\n\t/*\n\t * The following are owned by spi_thread (may be accessed by\n\t * SPI-thread without acquiring the HCD lock:\n\t */\n\tu8 rev;\t\t\t\t/* chip revision */\n\tu16 frame_number;\n\t/*\n\t * kmalloc'd buffers guaranteed to be in separate (DMA)\n\t * cache-lines:\n\t */\n\tstruct max3421_dma_buf *tx;\n\tstruct max3421_dma_buf *rx;\n\t/*\n\t * URB we're currently processing.  Must not be reset to NULL\n\t * unless MAX3421E chip is idle:\n\t */\n\tstruct urb *curr_urb;\n\tenum scheduling_pass sched_pass;\n\tstruct usb_device *loaded_dev;\t/* dev that's loaded into the chip */\n\tint loaded_epnum;\t\t/* epnum whose toggles are loaded */\n\tint urb_done;\t\t\t/* > 0 -> no errors, < 0: errno */\n\tsize_t curr_len;\n\tu8 hien;\n\tu8 mode;\n\tu8 iopins[2];\n\tunsigned long todo;\n#ifdef DEBUG\n\tunsigned long err_stat[16];\n#endif\n};\n\nstruct max3421_ep {\n\tstruct usb_host_endpoint *ep;\n\tstruct list_head ep_list;\n\tu32 naks;\n\tu16 last_active;\t\t/* frame # this ep was last active */\n\tenum pkt_state pkt_state;\n\tu8 retries;\n\tu8 retransmit;\t\t\t/* packet needs retransmission */\n};\n\nstatic struct max3421_hcd *max3421_hcd_list;\n\n#define MAX3421_FIFO_SIZE\t64\n\n#define MAX3421_SPI_DIR_RD\t0\t/* read register from MAX3421 */\n#define MAX3421_SPI_DIR_WR\t1\t/* write register to MAX3421 */\n\n/* SPI commands: */\n#define MAX3421_SPI_DIR_SHIFT\t1\n#define MAX3421_SPI_REG_SHIFT\t3\n\n#define MAX3421_REG_RCVFIFO\t1\n#define MAX3421_REG_SNDFIFO\t2\n#define MAX3421_REG_SUDFIFO\t4\n#define MAX3421_REG_RCVBC\t6\n#define MAX3421_REG_SNDBC\t7\n#define MAX3421_REG_USBIRQ\t13\n#define MAX3421_REG_USBIEN\t14\n#define MAX3421_REG_USBCTL\t15\n#define MAX3421_REG_CPUCTL\t16\n#define MAX3421_REG_PINCTL\t17\n#define MAX3421_REG_REVISION\t18\n#define MAX3421_REG_IOPINS1\t20\n#define MAX3421_REG_IOPINS2\t21\n#define MAX3421_REG_GPINIRQ\t22\n#define MAX3421_REG_GPINIEN\t23\n#define MAX3421_REG_GPINPOL\t24\n#define MAX3421_REG_HIRQ\t25\n#define MAX3421_REG_HIEN\t26\n#define MAX3421_REG_MODE\t27\n#define MAX3421_REG_PERADDR\t28\n#define MAX3421_REG_HCTL\t29\n#define MAX3421_REG_HXFR\t30\n#define MAX3421_REG_HRSL\t31\n\nenum {\n\tMAX3421_USBIRQ_OSCOKIRQ_BIT = 0,\n\tMAX3421_USBIRQ_NOVBUSIRQ_BIT = 5,\n\tMAX3421_USBIRQ_VBUSIRQ_BIT\n};\n\nenum {\n\tMAX3421_CPUCTL_IE_BIT = 0,\n\tMAX3421_CPUCTL_PULSEWID0_BIT = 6,\n\tMAX3421_CPUCTL_PULSEWID1_BIT\n};\n\nenum {\n\tMAX3421_USBCTL_PWRDOWN_BIT = 4,\n\tMAX3421_USBCTL_CHIPRES_BIT\n};\n\nenum {\n\tMAX3421_PINCTL_GPXA_BIT\t= 0,\n\tMAX3421_PINCTL_GPXB_BIT,\n\tMAX3421_PINCTL_POSINT_BIT,\n\tMAX3421_PINCTL_INTLEVEL_BIT,\n\tMAX3421_PINCTL_FDUPSPI_BIT,\n\tMAX3421_PINCTL_EP0INAK_BIT,\n\tMAX3421_PINCTL_EP2INAK_BIT,\n\tMAX3421_PINCTL_EP3INAK_BIT,\n};\n\nenum {\n\tMAX3421_HI_BUSEVENT_BIT = 0,\t/* bus-reset/-resume */\n\tMAX3421_HI_RWU_BIT,\t\t/* remote wakeup */\n\tMAX3421_HI_RCVDAV_BIT,\t\t/* receive FIFO data available */\n\tMAX3421_HI_SNDBAV_BIT,\t\t/* send buffer available */\n\tMAX3421_HI_SUSDN_BIT,\t\t/* suspend operation done */\n\tMAX3421_HI_CONDET_BIT,\t\t/* peripheral connect/disconnect */\n\tMAX3421_HI_FRAME_BIT,\t\t/* frame generator */\n\tMAX3421_HI_HXFRDN_BIT,\t\t/* host transfer done */\n};\n\nenum {\n\tMAX3421_HCTL_BUSRST_BIT = 0,\n\tMAX3421_HCTL_FRMRST_BIT,\n\tMAX3421_HCTL_SAMPLEBUS_BIT,\n\tMAX3421_HCTL_SIGRSM_BIT,\n\tMAX3421_HCTL_RCVTOG0_BIT,\n\tMAX3421_HCTL_RCVTOG1_BIT,\n\tMAX3421_HCTL_SNDTOG0_BIT,\n\tMAX3421_HCTL_SNDTOG1_BIT\n};\n\nenum {\n\tMAX3421_MODE_HOST_BIT = 0,\n\tMAX3421_MODE_LOWSPEED_BIT,\n\tMAX3421_MODE_HUBPRE_BIT,\n\tMAX3421_MODE_SOFKAENAB_BIT,\n\tMAX3421_MODE_SEPIRQ_BIT,\n\tMAX3421_MODE_DELAYISO_BIT,\n\tMAX3421_MODE_DMPULLDN_BIT,\n\tMAX3421_MODE_DPPULLDN_BIT\n};\n\nenum {\n\tMAX3421_HRSL_OK = 0,\n\tMAX3421_HRSL_BUSY,\n\tMAX3421_HRSL_BADREQ,\n\tMAX3421_HRSL_UNDEF,\n\tMAX3421_HRSL_NAK,\n\tMAX3421_HRSL_STALL,\n\tMAX3421_HRSL_TOGERR,\n\tMAX3421_HRSL_WRONGPID,\n\tMAX3421_HRSL_BADBC,\n\tMAX3421_HRSL_PIDERR,\n\tMAX3421_HRSL_PKTERR,\n\tMAX3421_HRSL_CRCERR,\n\tMAX3421_HRSL_KERR,\n\tMAX3421_HRSL_JERR,\n\tMAX3421_HRSL_TIMEOUT,\n\tMAX3421_HRSL_BABBLE,\n\tMAX3421_HRSL_RESULT_MASK = 0xf,\n\tMAX3421_HRSL_RCVTOGRD_BIT = 4,\n\tMAX3421_HRSL_SNDTOGRD_BIT,\n\tMAX3421_HRSL_KSTATUS_BIT,\n\tMAX3421_HRSL_JSTATUS_BIT\n};\n\n/* Return same error-codes as ohci.h:cc_to_error: */\nstatic const int hrsl_to_error[] = {\n\t[MAX3421_HRSL_OK] =\t\t0,\n\t[MAX3421_HRSL_BUSY] =\t\t-EINVAL,\n\t[MAX3421_HRSL_BADREQ] =\t\t-EINVAL,\n\t[MAX3421_HRSL_UNDEF] =\t\t-EINVAL,\n\t[MAX3421_HRSL_NAK] =\t\t-EAGAIN,\n\t[MAX3421_HRSL_STALL] =\t\t-EPIPE,\n\t[MAX3421_HRSL_TOGERR] =\t\t-EILSEQ,\n\t[MAX3421_HRSL_WRONGPID] =\t-EPROTO,\n\t[MAX3421_HRSL_BADBC] =\t\t-EREMOTEIO,\n\t[MAX3421_HRSL_PIDERR] =\t\t-EPROTO,\n\t[MAX3421_HRSL_PKTERR] =\t\t-EPROTO,\n\t[MAX3421_HRSL_CRCERR] =\t\t-EILSEQ,\n\t[MAX3421_HRSL_KERR] =\t\t-EIO,\n\t[MAX3421_HRSL_JERR] =\t\t-EIO,\n\t[MAX3421_HRSL_TIMEOUT] =\t-ETIME,\n\t[MAX3421_HRSL_BABBLE] =\t\t-EOVERFLOW\n};\n\n/*\n * See https://www.beyondlogic.org/usbnutshell/usb4.shtml#Control for a\n * reasonable overview of how control transfers use the the IN/OUT\n * tokens.\n */\n#define MAX3421_HXFR_BULK_IN(ep)\t(0x00 | (ep))\t/* bulk or interrupt */\n#define MAX3421_HXFR_SETUP\t\t 0x10\n#define MAX3421_HXFR_BULK_OUT(ep)\t(0x20 | (ep))\t/* bulk or interrupt */\n#define MAX3421_HXFR_ISO_IN(ep)\t\t(0x40 | (ep))\n#define MAX3421_HXFR_ISO_OUT(ep)\t(0x60 | (ep))\n#define MAX3421_HXFR_HS_IN\t\t 0x80\t\t/* handshake in */\n#define MAX3421_HXFR_HS_OUT\t\t 0xa0\t\t/* handshake out */\n\n#define field(val, bit)\t((val) << (bit))\n\nstatic inline s16\nframe_diff(u16 left, u16 right)\n{\n\treturn ((unsigned) (left - right)) % (USB_MAX_FRAME_NUMBER + 1);\n}\n\nstatic inline struct max3421_hcd *\nhcd_to_max3421(struct usb_hcd *hcd)\n{\n\treturn (struct max3421_hcd *) hcd->hcd_priv;\n}\n\nstatic inline struct usb_hcd *\nmax3421_to_hcd(struct max3421_hcd *max3421_hcd)\n{\n\treturn container_of((void *) max3421_hcd, struct usb_hcd, hcd_priv);\n}\n\nstatic u8\nspi_rd8(struct usb_hcd *hcd, unsigned int reg)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tstruct spi_device *spi = to_spi_device(hcd->self.controller);\n\tstruct spi_transfer transfer;\n\tstruct spi_message msg;\n\n\tmemset(&transfer, 0, sizeof(transfer));\n\n\tspi_message_init(&msg);\n\n\tmax3421_hcd->tx->data[0] =\n\t\t(field(reg, MAX3421_SPI_REG_SHIFT) |\n\t\t field(MAX3421_SPI_DIR_RD, MAX3421_SPI_DIR_SHIFT));\n\n\ttransfer.tx_buf = max3421_hcd->tx->data;\n\ttransfer.rx_buf = max3421_hcd->rx->data;\n\ttransfer.len = 2;\n\n\tspi_message_add_tail(&transfer, &msg);\n\tspi_sync(spi, &msg);\n\n\treturn max3421_hcd->rx->data[1];\n}\n\nstatic void\nspi_wr8(struct usb_hcd *hcd, unsigned int reg, u8 val)\n{\n\tstruct spi_device *spi = to_spi_device(hcd->self.controller);\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tstruct spi_transfer transfer;\n\tstruct spi_message msg;\n\n\tmemset(&transfer, 0, sizeof(transfer));\n\n\tspi_message_init(&msg);\n\n\tmax3421_hcd->tx->data[0] =\n\t\t(field(reg, MAX3421_SPI_REG_SHIFT) |\n\t\t field(MAX3421_SPI_DIR_WR, MAX3421_SPI_DIR_SHIFT));\n\tmax3421_hcd->tx->data[1] = val;\n\n\ttransfer.tx_buf = max3421_hcd->tx->data;\n\ttransfer.len = 2;\n\n\tspi_message_add_tail(&transfer, &msg);\n\tspi_sync(spi, &msg);\n}\n\nstatic void\nspi_rd_buf(struct usb_hcd *hcd, unsigned int reg, void *buf, size_t len)\n{\n\tstruct spi_device *spi = to_spi_device(hcd->self.controller);\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tstruct spi_transfer transfer[2];\n\tstruct spi_message msg;\n\n\tmemset(transfer, 0, sizeof(transfer));\n\n\tspi_message_init(&msg);\n\n\tmax3421_hcd->tx->data[0] =\n\t\t(field(reg, MAX3421_SPI_REG_SHIFT) |\n\t\t field(MAX3421_SPI_DIR_RD, MAX3421_SPI_DIR_SHIFT));\n\ttransfer[0].tx_buf = max3421_hcd->tx->data;\n\ttransfer[0].len = 1;\n\n\ttransfer[1].rx_buf = buf;\n\ttransfer[1].len = len;\n\n\tspi_message_add_tail(&transfer[0], &msg);\n\tspi_message_add_tail(&transfer[1], &msg);\n\tspi_sync(spi, &msg);\n}\n\nstatic void\nspi_wr_buf(struct usb_hcd *hcd, unsigned int reg, void *buf, size_t len)\n{\n\tstruct spi_device *spi = to_spi_device(hcd->self.controller);\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tstruct spi_transfer transfer[2];\n\tstruct spi_message msg;\n\n\tmemset(transfer, 0, sizeof(transfer));\n\n\tspi_message_init(&msg);\n\n\tmax3421_hcd->tx->data[0] =\n\t\t(field(reg, MAX3421_SPI_REG_SHIFT) |\n\t\t field(MAX3421_SPI_DIR_WR, MAX3421_SPI_DIR_SHIFT));\n\n\ttransfer[0].tx_buf = max3421_hcd->tx->data;\n\ttransfer[0].len = 1;\n\n\ttransfer[1].tx_buf = buf;\n\ttransfer[1].len = len;\n\n\tspi_message_add_tail(&transfer[0], &msg);\n\tspi_message_add_tail(&transfer[1], &msg);\n\tspi_sync(spi, &msg);\n}\n\n/*\n * Figure out the correct setting for the LOWSPEED and HUBPRE mode\n * bits.  The HUBPRE bit needs to be set when MAX3421E operates at\n * full speed, but it's talking to a low-speed device (i.e., through a\n * hub).  Setting that bit ensures that every low-speed packet is\n * preceded by a full-speed PRE PID.  Possible configurations:\n *\n * Hub speed:\tDevice speed:\t=>\tLOWSPEED bit:\tHUBPRE bit:\n *\tFULL\tFULL\t\t=>\t0\t\t0\n *\tFULL\tLOW\t\t=>\t1\t\t1\n *\tLOW\tLOW\t\t=>\t1\t\t0\n *\tLOW\tFULL\t\t=>\t1\t\t0\n */\nstatic void\nmax3421_set_speed(struct usb_hcd *hcd, struct usb_device *dev)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tu8 mode_lowspeed, mode_hubpre, mode = max3421_hcd->mode;\n\n\tmode_lowspeed = BIT(MAX3421_MODE_LOWSPEED_BIT);\n\tmode_hubpre   = BIT(MAX3421_MODE_HUBPRE_BIT);\n\tif (max3421_hcd->port_status & USB_PORT_STAT_LOW_SPEED) {\n\t\tmode |=  mode_lowspeed;\n\t\tmode &= ~mode_hubpre;\n\t} else if (dev->speed == USB_SPEED_LOW) {\n\t\tmode |= mode_lowspeed | mode_hubpre;\n\t} else {\n\t\tmode &= ~(mode_lowspeed | mode_hubpre);\n\t}\n\tif (mode != max3421_hcd->mode) {\n\t\tmax3421_hcd->mode = mode;\n\t\tspi_wr8(hcd, MAX3421_REG_MODE, max3421_hcd->mode);\n\t}\n\n}\n\n/*\n * Caller must NOT hold HCD spinlock.\n */\nstatic void\nmax3421_set_address(struct usb_hcd *hcd, struct usb_device *dev, int epnum,\n\t\t    int force_toggles)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tint old_epnum, same_ep, rcvtog, sndtog;\n\tstruct usb_device *old_dev;\n\tu8 hctl;\n\n\told_dev = max3421_hcd->loaded_dev;\n\told_epnum = max3421_hcd->loaded_epnum;\n\n\tsame_ep = (dev == old_dev && epnum == old_epnum);\n\tif (same_ep && !force_toggles)\n\t\treturn;\n\n\tif (old_dev && !same_ep) {\n\t\t/* save the old end-points toggles: */\n\t\tu8 hrsl = spi_rd8(hcd, MAX3421_REG_HRSL);\n\n\t\trcvtog = (hrsl >> MAX3421_HRSL_RCVTOGRD_BIT) & 1;\n\t\tsndtog = (hrsl >> MAX3421_HRSL_SNDTOGRD_BIT) & 1;\n\n\t\t/* no locking: HCD (i.e., we) own toggles, don't we? */\n\t\tusb_settoggle(old_dev, old_epnum, 0, rcvtog);\n\t\tusb_settoggle(old_dev, old_epnum, 1, sndtog);\n\t}\n\t/* setup new endpoint's toggle bits: */\n\trcvtog = usb_gettoggle(dev, epnum, 0);\n\tsndtog = usb_gettoggle(dev, epnum, 1);\n\thctl = (BIT(rcvtog + MAX3421_HCTL_RCVTOG0_BIT) |\n\t\tBIT(sndtog + MAX3421_HCTL_SNDTOG0_BIT));\n\n\tmax3421_hcd->loaded_epnum = epnum;\n\tspi_wr8(hcd, MAX3421_REG_HCTL, hctl);\n\n\t/*\n\t * Note: devnum for one and the same device can change during\n\t * address-assignment so it's best to just always load the\n\t * address whenever the end-point changed/was forced.\n\t */\n\tmax3421_hcd->loaded_dev = dev;\n\tspi_wr8(hcd, MAX3421_REG_PERADDR, dev->devnum);\n}\n\nstatic int\nmax3421_ctrl_setup(struct usb_hcd *hcd, struct urb *urb)\n{\n\tspi_wr_buf(hcd, MAX3421_REG_SUDFIFO, urb->setup_packet, 8);\n\treturn MAX3421_HXFR_SETUP;\n}\n\nstatic int\nmax3421_transfer_in(struct usb_hcd *hcd, struct urb *urb)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tint epnum = usb_pipeendpoint(urb->pipe);\n\n\tmax3421_hcd->curr_len = 0;\n\tmax3421_hcd->hien |= BIT(MAX3421_HI_RCVDAV_BIT);\n\treturn MAX3421_HXFR_BULK_IN(epnum);\n}\n\nstatic int\nmax3421_transfer_out(struct usb_hcd *hcd, struct urb *urb, int fast_retransmit)\n{\n\tstruct spi_device *spi = to_spi_device(hcd->self.controller);\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tint epnum = usb_pipeendpoint(urb->pipe);\n\tu32 max_packet;\n\tvoid *src;\n\n\tsrc = urb->transfer_buffer + urb->actual_length;\n\n\tif (fast_retransmit) {\n\t\tif (max3421_hcd->rev == 0x12) {\n\t\t\t/* work around rev 0x12 bug: */\n\t\t\tspi_wr8(hcd, MAX3421_REG_SNDBC, 0);\n\t\t\tspi_wr8(hcd, MAX3421_REG_SNDFIFO, ((u8 *) src)[0]);\n\t\t\tspi_wr8(hcd, MAX3421_REG_SNDBC, max3421_hcd->curr_len);\n\t\t}\n\t\treturn MAX3421_HXFR_BULK_OUT(epnum);\n\t}\n\n\tmax_packet = usb_maxpacket(urb->dev, urb->pipe, 1);\n\n\tif (max_packet > MAX3421_FIFO_SIZE) {\n\t\t/*\n\t\t * We do not support isochronous transfers at this\n\t\t * time.\n\t\t */\n\t\tdev_err(&spi->dev,\n\t\t\t\"%s: packet-size of %u too big (limit is %u bytes)\",\n\t\t\t__func__, max_packet, MAX3421_FIFO_SIZE);\n\t\tmax3421_hcd->urb_done = -EMSGSIZE;\n\t\treturn -EMSGSIZE;\n\t}\n\tmax3421_hcd->curr_len = min((urb->transfer_buffer_length -\n\t\t\t\t     urb->actual_length), max_packet);\n\n\tspi_wr_buf(hcd, MAX3421_REG_SNDFIFO, src, max3421_hcd->curr_len);\n\tspi_wr8(hcd, MAX3421_REG_SNDBC, max3421_hcd->curr_len);\n\treturn MAX3421_HXFR_BULK_OUT(epnum);\n}\n\n/*\n * Issue the next host-transfer command.\n * Caller must NOT hold HCD spinlock.\n */\nstatic void\nmax3421_next_transfer(struct usb_hcd *hcd, int fast_retransmit)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tstruct urb *urb = max3421_hcd->curr_urb;\n\tstruct max3421_ep *max3421_ep;\n\tint cmd = -EINVAL;\n\n\tif (!urb)\n\t\treturn;\t/* nothing to do */\n\n\tmax3421_ep = urb->ep->hcpriv;\n\n\tswitch (max3421_ep->pkt_state) {\n\tcase PKT_STATE_SETUP:\n\t\tcmd = max3421_ctrl_setup(hcd, urb);\n\t\tbreak;\n\n\tcase PKT_STATE_TRANSFER:\n\t\tif (usb_urb_dir_in(urb))\n\t\t\tcmd = max3421_transfer_in(hcd, urb);\n\t\telse\n\t\t\tcmd = max3421_transfer_out(hcd, urb, fast_retransmit);\n\t\tbreak;\n\n\tcase PKT_STATE_TERMINATE:\n\t\t/*\n\t\t * IN transfers are terminated with HS_OUT token,\n\t\t * OUT transfers with HS_IN:\n\t\t */\n\t\tif (usb_urb_dir_in(urb))\n\t\t\tcmd = MAX3421_HXFR_HS_OUT;\n\t\telse\n\t\t\tcmd = MAX3421_HXFR_HS_IN;\n\t\tbreak;\n\t}\n\n\tif (cmd < 0)\n\t\treturn;\n\n\t/* issue the command and wait for host-xfer-done interrupt: */\n\n\tspi_wr8(hcd, MAX3421_REG_HXFR, cmd);\n\tmax3421_hcd->hien |= BIT(MAX3421_HI_HXFRDN_BIT);\n}\n\n/*\n * Find the next URB to process and start its execution.\n *\n * At this time, we do not anticipate ever connecting a USB hub to the\n * MAX3421 chip, so at most USB device can be connected and we can use\n * a simplistic scheduler: at the start of a frame, schedule all\n * periodic transfers.  Once that is done, use the remainder of the\n * frame to process non-periodic (bulk & control) transfers.\n *\n * Preconditions:\n * o Caller must NOT hold HCD spinlock.\n * o max3421_hcd->curr_urb MUST BE NULL.\n * o MAX3421E chip must be idle.\n */\nstatic int\nmax3421_select_and_start_urb(struct usb_hcd *hcd)\n{\n\tstruct spi_device *spi = to_spi_device(hcd->self.controller);\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tstruct urb *urb, *curr_urb = NULL;\n\tstruct max3421_ep *max3421_ep;\n\tint epnum, force_toggles = 0;\n\tstruct usb_host_endpoint *ep;\n\tstruct list_head *pos;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&max3421_hcd->lock, flags);\n\n\tfor (;\n\t     max3421_hcd->sched_pass < SCHED_PASS_DONE;\n\t     ++max3421_hcd->sched_pass)\n\t\tlist_for_each(pos, &max3421_hcd->ep_list) {\n\t\t\turb = NULL;\n\t\t\tmax3421_ep = container_of(pos, struct max3421_ep,\n\t\t\t\t\t\t  ep_list);\n\t\t\tep = max3421_ep->ep;\n\n\t\t\tswitch (usb_endpoint_type(&ep->desc)) {\n\t\t\tcase USB_ENDPOINT_XFER_ISOC:\n\t\t\tcase USB_ENDPOINT_XFER_INT:\n\t\t\t\tif (max3421_hcd->sched_pass !=\n\t\t\t\t    SCHED_PASS_PERIODIC)\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\n\t\t\tcase USB_ENDPOINT_XFER_CONTROL:\n\t\t\tcase USB_ENDPOINT_XFER_BULK:\n\t\t\t\tif (max3421_hcd->sched_pass !=\n\t\t\t\t    SCHED_PASS_NON_PERIODIC)\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (list_empty(&ep->urb_list))\n\t\t\t\tcontinue;\t/* nothing to do */\n\t\t\turb = list_first_entry(&ep->urb_list, struct urb,\n\t\t\t\t\t       urb_list);\n\t\t\tif (urb->unlinked) {\n\t\t\t\tdev_dbg(&spi->dev, \"%s: URB %p unlinked=%d\",\n\t\t\t\t\t__func__, urb, urb->unlinked);\n\t\t\t\tmax3421_hcd->curr_urb = urb;\n\t\t\t\tmax3421_hcd->urb_done = 1;\n\t\t\t\tspin_unlock_irqrestore(&max3421_hcd->lock,\n\t\t\t\t\t\t       flags);\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tswitch (usb_endpoint_type(&ep->desc)) {\n\t\t\tcase USB_ENDPOINT_XFER_CONTROL:\n\t\t\t\t/*\n\t\t\t\t * Allow one control transaction per\n\t\t\t\t * frame per endpoint:\n\t\t\t\t */\n\t\t\t\tif (frame_diff(max3421_ep->last_active,\n\t\t\t\t\t       max3421_hcd->frame_number) == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\n\t\t\tcase USB_ENDPOINT_XFER_BULK:\n\t\t\t\tif (max3421_ep->retransmit\n\t\t\t\t    && (frame_diff(max3421_ep->last_active,\n\t\t\t\t\t\t   max3421_hcd->frame_number)\n\t\t\t\t\t== 0))\n\t\t\t\t\t/*\n\t\t\t\t\t * We already tried this EP\n\t\t\t\t\t * during this frame and got a\n\t\t\t\t\t * NAK or error; wait for next frame\n\t\t\t\t\t */\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\n\t\t\tcase USB_ENDPOINT_XFER_ISOC:\n\t\t\tcase USB_ENDPOINT_XFER_INT:\n\t\t\t\tif (frame_diff(max3421_hcd->frame_number,\n\t\t\t\t\t       max3421_ep->last_active)\n\t\t\t\t    < urb->interval)\n\t\t\t\t\t/*\n\t\t\t\t\t * We already processed this\n\t\t\t\t\t * end-point in the current\n\t\t\t\t\t * frame\n\t\t\t\t\t */\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* move current ep to tail: */\n\t\t\tlist_move_tail(pos, &max3421_hcd->ep_list);\n\t\t\tcurr_urb = urb;\n\t\t\tgoto done;\n\t\t}\ndone:\n\tif (!curr_urb) {\n\t\tspin_unlock_irqrestore(&max3421_hcd->lock, flags);\n\t\treturn 0;\n\t}\n\n\turb = max3421_hcd->curr_urb = curr_urb;\n\tepnum = usb_endpoint_num(&urb->ep->desc);\n\tif (max3421_ep->retransmit)\n\t\t/* restart (part of) a USB transaction: */\n\t\tmax3421_ep->retransmit = 0;\n\telse {\n\t\t/* start USB transaction: */\n\t\tif (usb_endpoint_xfer_control(&ep->desc)) {\n\t\t\t/*\n\t\t\t * See USB 2.0 spec section 8.6.1\n\t\t\t * Initialization via SETUP Token:\n\t\t\t */\n\t\t\tusb_settoggle(urb->dev, epnum, 0, 1);\n\t\t\tusb_settoggle(urb->dev, epnum, 1, 1);\n\t\t\tmax3421_ep->pkt_state = PKT_STATE_SETUP;\n\t\t\tforce_toggles = 1;\n\t\t} else\n\t\t\tmax3421_ep->pkt_state = PKT_STATE_TRANSFER;\n\t}\n\n\tspin_unlock_irqrestore(&max3421_hcd->lock, flags);\n\n\tmax3421_ep->last_active = max3421_hcd->frame_number;\n\tmax3421_set_address(hcd, urb->dev, epnum, force_toggles);\n\tmax3421_set_speed(hcd, urb->dev);\n\tmax3421_next_transfer(hcd, 0);\n\treturn 1;\n}\n\n/*\n * Check all endpoints for URBs that got unlinked.\n *\n * Caller must NOT hold HCD spinlock.\n */\nstatic int\nmax3421_check_unlink(struct usb_hcd *hcd)\n{\n\tstruct spi_device *spi = to_spi_device(hcd->self.controller);\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tstruct max3421_ep *max3421_ep;\n\tstruct usb_host_endpoint *ep;\n\tstruct urb *urb, *next;\n\tunsigned long flags;\n\tint retval = 0;\n\n\tspin_lock_irqsave(&max3421_hcd->lock, flags);\n\tlist_for_each_entry(max3421_ep, &max3421_hcd->ep_list, ep_list) {\n\t\tep = max3421_ep->ep;\n\t\tlist_for_each_entry_safe(urb, next, &ep->urb_list, urb_list) {\n\t\t\tif (urb->unlinked) {\n\t\t\t\tretval = 1;\n\t\t\t\tdev_dbg(&spi->dev, \"%s: URB %p unlinked=%d\",\n\t\t\t\t\t__func__, urb, urb->unlinked);\n\t\t\t\tusb_hcd_unlink_urb_from_ep(hcd, urb);\n\t\t\t\tspin_unlock_irqrestore(&max3421_hcd->lock,\n\t\t\t\t\t\t       flags);\n\t\t\t\tusb_hcd_giveback_urb(hcd, urb, 0);\n\t\t\t\tspin_lock_irqsave(&max3421_hcd->lock, flags);\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&max3421_hcd->lock, flags);\n\treturn retval;\n}\n\n/*\n * Caller must NOT hold HCD spinlock.\n */\nstatic void\nmax3421_slow_retransmit(struct usb_hcd *hcd)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tstruct urb *urb = max3421_hcd->curr_urb;\n\tstruct max3421_ep *max3421_ep;\n\n\tmax3421_ep = urb->ep->hcpriv;\n\tmax3421_ep->retransmit = 1;\n\tmax3421_hcd->curr_urb = NULL;\n}\n\n/*\n * Caller must NOT hold HCD spinlock.\n */\nstatic void\nmax3421_recv_data_available(struct usb_hcd *hcd)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tstruct urb *urb = max3421_hcd->curr_urb;\n\tsize_t remaining, transfer_size;\n\tu8 rcvbc;\n\n\trcvbc = spi_rd8(hcd, MAX3421_REG_RCVBC);\n\n\tif (rcvbc > MAX3421_FIFO_SIZE)\n\t\trcvbc = MAX3421_FIFO_SIZE;\n\tif (urb->actual_length >= urb->transfer_buffer_length)\n\t\tremaining = 0;\n\telse\n\t\tremaining = urb->transfer_buffer_length - urb->actual_length;\n\ttransfer_size = rcvbc;\n\tif (transfer_size > remaining)\n\t\ttransfer_size = remaining;\n\tif (transfer_size > 0) {\n\t\tvoid *dst = urb->transfer_buffer + urb->actual_length;\n\n\t\tspi_rd_buf(hcd, MAX3421_REG_RCVFIFO, dst, transfer_size);\n\t\turb->actual_length += transfer_size;\n\t\tmax3421_hcd->curr_len = transfer_size;\n\t}\n\n\t/* ack the RCVDAV irq now that the FIFO has been read: */\n\tspi_wr8(hcd, MAX3421_REG_HIRQ, BIT(MAX3421_HI_RCVDAV_BIT));\n}\n\nstatic void\nmax3421_handle_error(struct usb_hcd *hcd, u8 hrsl)\n{\n\tstruct spi_device *spi = to_spi_device(hcd->self.controller);\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tu8 result_code = hrsl & MAX3421_HRSL_RESULT_MASK;\n\tstruct urb *urb = max3421_hcd->curr_urb;\n\tstruct max3421_ep *max3421_ep = urb->ep->hcpriv;\n\tint switch_sndfifo;\n\n\t/*\n\t * If an OUT command results in any response other than OK\n\t * (i.e., error or NAK), we have to perform a dummy-write to\n\t * SNDBC so the FIFO gets switched back to us.  Otherwise, we\n\t * get out of sync with the SNDFIFO double buffer.\n\t */\n\tswitch_sndfifo = (max3421_ep->pkt_state == PKT_STATE_TRANSFER &&\n\t\t\t  usb_urb_dir_out(urb));\n\n\tswitch (result_code) {\n\tcase MAX3421_HRSL_OK:\n\t\treturn;\t\t\t/* this shouldn't happen */\n\n\tcase MAX3421_HRSL_WRONGPID:\t/* received wrong PID */\n\tcase MAX3421_HRSL_BUSY:\t\t/* SIE busy */\n\tcase MAX3421_HRSL_BADREQ:\t/* bad val in HXFR */\n\tcase MAX3421_HRSL_UNDEF:\t/* reserved */\n\tcase MAX3421_HRSL_KERR:\t\t/* K-state instead of response */\n\tcase MAX3421_HRSL_JERR:\t\t/* J-state instead of response */\n\t\t/*\n\t\t * packet experienced an error that we cannot recover\n\t\t * from; report error\n\t\t */\n\t\tmax3421_hcd->urb_done = hrsl_to_error[result_code];\n\t\tdev_dbg(&spi->dev, \"%s: unexpected error HRSL=0x%02x\",\n\t\t\t__func__, hrsl);\n\t\tbreak;\n\n\tcase MAX3421_HRSL_TOGERR:\n\t\tif (usb_urb_dir_in(urb))\n\t\t\t; /* don't do anything (device will switch toggle) */\n\t\telse {\n\t\t\t/* flip the send toggle bit: */\n\t\t\tint sndtog = (hrsl >> MAX3421_HRSL_SNDTOGRD_BIT) & 1;\n\n\t\t\tsndtog ^= 1;\n\t\t\tspi_wr8(hcd, MAX3421_REG_HCTL,\n\t\t\t\tBIT(sndtog + MAX3421_HCTL_SNDTOG0_BIT));\n\t\t}\n\t\tfallthrough;\n\tcase MAX3421_HRSL_BADBC:\t/* bad byte count */\n\tcase MAX3421_HRSL_PIDERR:\t/* received PID is corrupted */\n\tcase MAX3421_HRSL_PKTERR:\t/* packet error (stuff, EOP) */\n\tcase MAX3421_HRSL_CRCERR:\t/* CRC error */\n\tcase MAX3421_HRSL_BABBLE:\t/* device talked too long */\n\tcase MAX3421_HRSL_TIMEOUT:\n\t\tif (max3421_ep->retries++ < USB_MAX_RETRIES)\n\t\t\t/* retry the packet again in the next frame */\n\t\t\tmax3421_slow_retransmit(hcd);\n\t\telse {\n\t\t\t/* Based on ohci.h cc_to_err[]: */\n\t\t\tmax3421_hcd->urb_done = hrsl_to_error[result_code];\n\t\t\tdev_dbg(&spi->dev, \"%s: unexpected error HRSL=0x%02x\",\n\t\t\t\t__func__, hrsl);\n\t\t}\n\t\tbreak;\n\n\tcase MAX3421_HRSL_STALL:\n\t\tdev_dbg(&spi->dev, \"%s: unexpected error HRSL=0x%02x\",\n\t\t\t__func__, hrsl);\n\t\tmax3421_hcd->urb_done = hrsl_to_error[result_code];\n\t\tbreak;\n\n\tcase MAX3421_HRSL_NAK:\n\t\t/*\n\t\t * Device wasn't ready for data or has no data\n\t\t * available: retry the packet again.\n\t\t */\n\t\tif (max3421_ep->naks++ < NAK_MAX_FAST_RETRANSMITS) {\n\t\t\tmax3421_next_transfer(hcd, 1);\n\t\t\tswitch_sndfifo = 0;\n\t\t} else\n\t\t\tmax3421_slow_retransmit(hcd);\n\t\tbreak;\n\t}\n\tif (switch_sndfifo)\n\t\tspi_wr8(hcd, MAX3421_REG_SNDBC, 0);\n}\n\n/*\n * Caller must NOT hold HCD spinlock.\n */\nstatic int\nmax3421_transfer_in_done(struct usb_hcd *hcd, struct urb *urb)\n{\n\tstruct spi_device *spi = to_spi_device(hcd->self.controller);\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tu32 max_packet;\n\n\tif (urb->actual_length >= urb->transfer_buffer_length)\n\t\treturn 1;\t/* read is complete, so we're done */\n\n\t/*\n\t * USB 2.0 Section 5.3.2 Pipes: packets must be full size\n\t * except for last one.\n\t */\n\tmax_packet = usb_maxpacket(urb->dev, urb->pipe, 0);\n\tif (max_packet > MAX3421_FIFO_SIZE) {\n\t\t/*\n\t\t * We do not support isochronous transfers at this\n\t\t * time...\n\t\t */\n\t\tdev_err(&spi->dev,\n\t\t\t\"%s: packet-size of %u too big (limit is %u bytes)\",\n\t\t\t__func__, max_packet, MAX3421_FIFO_SIZE);\n\t\treturn -EINVAL;\n\t}\n\n\tif (max3421_hcd->curr_len < max_packet) {\n\t\tif (urb->transfer_flags & URB_SHORT_NOT_OK) {\n\t\t\t/*\n\t\t\t * remaining > 0 and received an\n\t\t\t * unexpected partial packet ->\n\t\t\t * error\n\t\t\t */\n\t\t\treturn -EREMOTEIO;\n\t\t} else\n\t\t\t/* short read, but it's OK */\n\t\t\treturn 1;\n\t}\n\treturn 0;\t/* not done */\n}\n\n/*\n * Caller must NOT hold HCD spinlock.\n */\nstatic int\nmax3421_transfer_out_done(struct usb_hcd *hcd, struct urb *urb)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\n\turb->actual_length += max3421_hcd->curr_len;\n\tif (urb->actual_length < urb->transfer_buffer_length)\n\t\treturn 0;\n\tif (urb->transfer_flags & URB_ZERO_PACKET) {\n\t\t/*\n\t\t * Some hardware needs a zero-size packet at the end\n\t\t * of a bulk-out transfer if the last transfer was a\n\t\t * full-sized packet (i.e., such hardware use <\n\t\t * max_packet as an indicator that the end of the\n\t\t * packet has been reached).\n\t\t */\n\t\tu32 max_packet = usb_maxpacket(urb->dev, urb->pipe, 1);\n\n\t\tif (max3421_hcd->curr_len == max_packet)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n/*\n * Caller must NOT hold HCD spinlock.\n */\nstatic void\nmax3421_host_transfer_done(struct usb_hcd *hcd)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tstruct urb *urb = max3421_hcd->curr_urb;\n\tstruct max3421_ep *max3421_ep;\n\tu8 result_code, hrsl;\n\tint urb_done = 0;\n\n\tmax3421_hcd->hien &= ~(BIT(MAX3421_HI_HXFRDN_BIT) |\n\t\t\t       BIT(MAX3421_HI_RCVDAV_BIT));\n\n\thrsl = spi_rd8(hcd, MAX3421_REG_HRSL);\n\tresult_code = hrsl & MAX3421_HRSL_RESULT_MASK;\n\n#ifdef DEBUG\n\t++max3421_hcd->err_stat[result_code];\n#endif\n\n\tmax3421_ep = urb->ep->hcpriv;\n\n\tif (unlikely(result_code != MAX3421_HRSL_OK)) {\n\t\tmax3421_handle_error(hcd, hrsl);\n\t\treturn;\n\t}\n\n\tmax3421_ep->naks = 0;\n\tmax3421_ep->retries = 0;\n\tswitch (max3421_ep->pkt_state) {\n\n\tcase PKT_STATE_SETUP:\n\t\tif (urb->transfer_buffer_length > 0)\n\t\t\tmax3421_ep->pkt_state = PKT_STATE_TRANSFER;\n\t\telse\n\t\t\tmax3421_ep->pkt_state = PKT_STATE_TERMINATE;\n\t\tbreak;\n\n\tcase PKT_STATE_TRANSFER:\n\t\tif (usb_urb_dir_in(urb))\n\t\t\turb_done = max3421_transfer_in_done(hcd, urb);\n\t\telse\n\t\t\turb_done = max3421_transfer_out_done(hcd, urb);\n\t\tif (urb_done > 0 && usb_pipetype(urb->pipe) == PIPE_CONTROL) {\n\t\t\t/*\n\t\t\t * We aren't really done - we still need to\n\t\t\t * terminate the control transfer:\n\t\t\t */\n\t\t\tmax3421_hcd->urb_done = urb_done = 0;\n\t\t\tmax3421_ep->pkt_state = PKT_STATE_TERMINATE;\n\t\t}\n\t\tbreak;\n\n\tcase PKT_STATE_TERMINATE:\n\t\turb_done = 1;\n\t\tbreak;\n\t}\n\n\tif (urb_done)\n\t\tmax3421_hcd->urb_done = urb_done;\n\telse\n\t\tmax3421_next_transfer(hcd, 0);\n}\n\n/*\n * Caller must NOT hold HCD spinlock.\n */\nstatic void\nmax3421_detect_conn(struct usb_hcd *hcd)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tunsigned int jk, have_conn = 0;\n\tu32 old_port_status, chg;\n\tunsigned long flags;\n\tu8 hrsl, mode;\n\n\thrsl = spi_rd8(hcd, MAX3421_REG_HRSL);\n\n\tjk = ((((hrsl >> MAX3421_HRSL_JSTATUS_BIT) & 1) << 0) |\n\t      (((hrsl >> MAX3421_HRSL_KSTATUS_BIT) & 1) << 1));\n\n\tmode = max3421_hcd->mode;\n\n\tswitch (jk) {\n\tcase 0x0: /* SE0: disconnect */\n\t\t/*\n\t\t * Turn off SOFKAENAB bit to avoid getting interrupt\n\t\t * every milli-second:\n\t\t */\n\t\tmode &= ~BIT(MAX3421_MODE_SOFKAENAB_BIT);\n\t\tbreak;\n\n\tcase 0x1: /* J=0,K=1: low-speed (in full-speed or vice versa) */\n\tcase 0x2: /* J=1,K=0: full-speed (in full-speed or vice versa) */\n\t\tif (jk == 0x2)\n\t\t\t/* need to switch to the other speed: */\n\t\t\tmode ^= BIT(MAX3421_MODE_LOWSPEED_BIT);\n\t\t/* turn on SOFKAENAB bit: */\n\t\tmode |= BIT(MAX3421_MODE_SOFKAENAB_BIT);\n\t\thave_conn = 1;\n\t\tbreak;\n\n\tcase 0x3: /* illegal */\n\t\tbreak;\n\t}\n\n\tmax3421_hcd->mode = mode;\n\tspi_wr8(hcd, MAX3421_REG_MODE, max3421_hcd->mode);\n\n\tspin_lock_irqsave(&max3421_hcd->lock, flags);\n\told_port_status = max3421_hcd->port_status;\n\tif (have_conn)\n\t\tmax3421_hcd->port_status |=  USB_PORT_STAT_CONNECTION;\n\telse\n\t\tmax3421_hcd->port_status &= ~USB_PORT_STAT_CONNECTION;\n\tif (mode & BIT(MAX3421_MODE_LOWSPEED_BIT))\n\t\tmax3421_hcd->port_status |=  USB_PORT_STAT_LOW_SPEED;\n\telse\n\t\tmax3421_hcd->port_status &= ~USB_PORT_STAT_LOW_SPEED;\n\tchg = (old_port_status ^ max3421_hcd->port_status);\n\tmax3421_hcd->port_status |= chg << 16;\n\tspin_unlock_irqrestore(&max3421_hcd->lock, flags);\n}\n\nstatic irqreturn_t\nmax3421_irq_handler(int irq, void *dev_id)\n{\n\tstruct usb_hcd *hcd = dev_id;\n\tstruct spi_device *spi = to_spi_device(hcd->self.controller);\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\n\tif (max3421_hcd->spi_thread)\n\t\twake_up_process(max3421_hcd->spi_thread);\n\tif (!test_and_set_bit(ENABLE_IRQ, &max3421_hcd->todo))\n\t\tdisable_irq_nosync(spi->irq);\n\treturn IRQ_HANDLED;\n}\n\n#ifdef DEBUG\n\nstatic void\ndump_eps(struct usb_hcd *hcd)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tstruct max3421_ep *max3421_ep;\n\tstruct usb_host_endpoint *ep;\n\tchar ubuf[512], *dp, *end;\n\tunsigned long flags;\n\tstruct urb *urb;\n\tint epnum, ret;\n\n\tspin_lock_irqsave(&max3421_hcd->lock, flags);\n\tlist_for_each_entry(max3421_ep, &max3421_hcd->ep_list, ep_list) {\n\t\tep = max3421_ep->ep;\n\n\t\tdp = ubuf;\n\t\tend = dp + sizeof(ubuf);\n\t\t*dp = '\\0';\n\t\tlist_for_each_entry(urb, &ep->urb_list, urb_list) {\n\t\t\tret = snprintf(dp, end - dp, \" %p(%d.%s %d/%d)\", urb,\n\t\t\t\t       usb_pipetype(urb->pipe),\n\t\t\t\t       usb_urb_dir_in(urb) ? \"IN\" : \"OUT\",\n\t\t\t\t       urb->actual_length,\n\t\t\t\t       urb->transfer_buffer_length);\n\t\t\tif (ret < 0 || ret >= end - dp)\n\t\t\t\tbreak;\t/* error or buffer full */\n\t\t\tdp += ret;\n\t\t}\n\n\t\tepnum = usb_endpoint_num(&ep->desc);\n\t\tpr_info(\"EP%0u %u lst %04u rtr %u nak %6u rxmt %u: %s\\n\",\n\t\t\tepnum, max3421_ep->pkt_state, max3421_ep->last_active,\n\t\t\tmax3421_ep->retries, max3421_ep->naks,\n\t\t\tmax3421_ep->retransmit, ubuf);\n\t}\n\tspin_unlock_irqrestore(&max3421_hcd->lock, flags);\n}\n\n#endif /* DEBUG */\n\n/* Return zero if no work was performed, 1 otherwise.  */\nstatic int\nmax3421_handle_irqs(struct usb_hcd *hcd)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tu32 chg, old_port_status;\n\tunsigned long flags;\n\tu8 hirq;\n\n\t/*\n\t * Read and ack pending interrupts (CPU must never\n\t * clear SNDBAV directly and RCVDAV must be cleared by\n\t * max3421_recv_data_available()!):\n\t */\n\thirq = spi_rd8(hcd, MAX3421_REG_HIRQ);\n\thirq &= max3421_hcd->hien;\n\tif (!hirq)\n\t\treturn 0;\n\n\tspi_wr8(hcd, MAX3421_REG_HIRQ,\n\t\thirq & ~(BIT(MAX3421_HI_SNDBAV_BIT) |\n\t\t\t BIT(MAX3421_HI_RCVDAV_BIT)));\n\n\tif (hirq & BIT(MAX3421_HI_FRAME_BIT)) {\n\t\tmax3421_hcd->frame_number = ((max3421_hcd->frame_number + 1)\n\t\t\t\t\t     & USB_MAX_FRAME_NUMBER);\n\t\tmax3421_hcd->sched_pass = SCHED_PASS_PERIODIC;\n\t}\n\n\tif (hirq & BIT(MAX3421_HI_RCVDAV_BIT))\n\t\tmax3421_recv_data_available(hcd);\n\n\tif (hirq & BIT(MAX3421_HI_HXFRDN_BIT))\n\t\tmax3421_host_transfer_done(hcd);\n\n\tif (hirq & BIT(MAX3421_HI_CONDET_BIT))\n\t\tmax3421_detect_conn(hcd);\n\n\t/*\n\t * Now process interrupts that may affect HCD state\n\t * other than the end-points:\n\t */\n\tspin_lock_irqsave(&max3421_hcd->lock, flags);\n\n\told_port_status = max3421_hcd->port_status;\n\tif (hirq & BIT(MAX3421_HI_BUSEVENT_BIT)) {\n\t\tif (max3421_hcd->port_status & USB_PORT_STAT_RESET) {\n\t\t\t/* BUSEVENT due to completion of Bus Reset */\n\t\t\tmax3421_hcd->port_status &= ~USB_PORT_STAT_RESET;\n\t\t\tmax3421_hcd->port_status |=  USB_PORT_STAT_ENABLE;\n\t\t} else {\n\t\t\t/* BUSEVENT due to completion of Bus Resume */\n\t\t\tpr_info(\"%s: BUSEVENT Bus Resume Done\\n\", __func__);\n\t\t}\n\t}\n\tif (hirq & BIT(MAX3421_HI_RWU_BIT))\n\t\tpr_info(\"%s: RWU\\n\", __func__);\n\tif (hirq & BIT(MAX3421_HI_SUSDN_BIT))\n\t\tpr_info(\"%s: SUSDN\\n\", __func__);\n\n\tchg = (old_port_status ^ max3421_hcd->port_status);\n\tmax3421_hcd->port_status |= chg << 16;\n\n\tspin_unlock_irqrestore(&max3421_hcd->lock, flags);\n\n#ifdef DEBUG\n\t{\n\t\tstatic unsigned long last_time;\n\t\tchar sbuf[16 * 16], *dp, *end;\n\t\tint i;\n\n\t\tif (time_after(jiffies, last_time + 5*HZ)) {\n\t\t\tdp = sbuf;\n\t\t\tend = sbuf + sizeof(sbuf);\n\t\t\t*dp = '\\0';\n\t\t\tfor (i = 0; i < 16; ++i) {\n\t\t\t\tint ret = snprintf(dp, end - dp, \" %lu\",\n\t\t\t\t\t\t   max3421_hcd->err_stat[i]);\n\t\t\t\tif (ret < 0 || ret >= end - dp)\n\t\t\t\t\tbreak;\t/* error or buffer full */\n\t\t\t\tdp += ret;\n\t\t\t}\n\t\t\tpr_info(\"%s: hrsl_stats %s\\n\", __func__, sbuf);\n\t\t\tmemset(max3421_hcd->err_stat, 0,\n\t\t\t       sizeof(max3421_hcd->err_stat));\n\t\t\tlast_time = jiffies;\n\n\t\t\tdump_eps(hcd);\n\t\t}\n\t}\n#endif\n\treturn 1;\n}\n\nstatic int\nmax3421_reset_hcd(struct usb_hcd *hcd)\n{\n\tstruct spi_device *spi = to_spi_device(hcd->self.controller);\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tint timeout;\n\n\t/* perform a chip reset and wait for OSCIRQ signal to appear: */\n\tspi_wr8(hcd, MAX3421_REG_USBCTL, BIT(MAX3421_USBCTL_CHIPRES_BIT));\n\t/* clear reset: */\n\tspi_wr8(hcd, MAX3421_REG_USBCTL, 0);\n\ttimeout = 1000;\n\twhile (1) {\n\t\tif (spi_rd8(hcd, MAX3421_REG_USBIRQ)\n\t\t    & BIT(MAX3421_USBIRQ_OSCOKIRQ_BIT))\n\t\t\tbreak;\n\t\tif (--timeout < 0) {\n\t\t\tdev_err(&spi->dev,\n\t\t\t\t\"timed out waiting for oscillator OK signal\");\n\t\t\treturn 1;\n\t\t}\n\t\tcond_resched();\n\t}\n\n\t/*\n\t * Turn on host mode, automatic generation of SOF packets, and\n\t * enable pull-down registers on DM/DP:\n\t */\n\tmax3421_hcd->mode = (BIT(MAX3421_MODE_HOST_BIT) |\n\t\t\t     BIT(MAX3421_MODE_SOFKAENAB_BIT) |\n\t\t\t     BIT(MAX3421_MODE_DMPULLDN_BIT) |\n\t\t\t     BIT(MAX3421_MODE_DPPULLDN_BIT));\n\tspi_wr8(hcd, MAX3421_REG_MODE, max3421_hcd->mode);\n\n\t/* reset frame-number: */\n\tmax3421_hcd->frame_number = USB_MAX_FRAME_NUMBER;\n\tspi_wr8(hcd, MAX3421_REG_HCTL, BIT(MAX3421_HCTL_FRMRST_BIT));\n\n\t/* sample the state of the D+ and D- lines */\n\tspi_wr8(hcd, MAX3421_REG_HCTL, BIT(MAX3421_HCTL_SAMPLEBUS_BIT));\n\tmax3421_detect_conn(hcd);\n\n\t/* enable frame, connection-detected, and bus-event interrupts: */\n\tmax3421_hcd->hien = (BIT(MAX3421_HI_FRAME_BIT) |\n\t\t\t     BIT(MAX3421_HI_CONDET_BIT) |\n\t\t\t     BIT(MAX3421_HI_BUSEVENT_BIT));\n\tspi_wr8(hcd, MAX3421_REG_HIEN, max3421_hcd->hien);\n\n\t/* enable interrupts: */\n\tspi_wr8(hcd, MAX3421_REG_CPUCTL, BIT(MAX3421_CPUCTL_IE_BIT));\n\treturn 1;\n}\n\nstatic int\nmax3421_urb_done(struct usb_hcd *hcd)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tunsigned long flags;\n\tstruct urb *urb;\n\tint status;\n\n\tstatus = max3421_hcd->urb_done;\n\tmax3421_hcd->urb_done = 0;\n\tif (status > 0)\n\t\tstatus = 0;\n\turb = max3421_hcd->curr_urb;\n\tif (urb) {\n\t\tmax3421_hcd->curr_urb = NULL;\n\t\tspin_lock_irqsave(&max3421_hcd->lock, flags);\n\t\tusb_hcd_unlink_urb_from_ep(hcd, urb);\n\t\tspin_unlock_irqrestore(&max3421_hcd->lock, flags);\n\n\t\t/* must be called without the HCD spinlock: */\n\t\tusb_hcd_giveback_urb(hcd, urb, status);\n\t}\n\treturn 1;\n}\n\nstatic int\nmax3421_spi_thread(void *dev_id)\n{\n\tstruct usb_hcd *hcd = dev_id;\n\tstruct spi_device *spi = to_spi_device(hcd->self.controller);\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tint i, i_worked = 1;\n\n\t/* set full-duplex SPI mode, low-active interrupt pin: */\n\tspi_wr8(hcd, MAX3421_REG_PINCTL,\n\t\t(BIT(MAX3421_PINCTL_FDUPSPI_BIT) |\t/* full-duplex */\n\t\t BIT(MAX3421_PINCTL_INTLEVEL_BIT)));\t/* low-active irq */\n\n\twhile (!kthread_should_stop()) {\n\t\tmax3421_hcd->rev = spi_rd8(hcd, MAX3421_REG_REVISION);\n\t\tif (max3421_hcd->rev == 0x12 || max3421_hcd->rev == 0x13)\n\t\t\tbreak;\n\t\tdev_err(&spi->dev, \"bad rev 0x%02x\", max3421_hcd->rev);\n\t\tmsleep(10000);\n\t}\n\tdev_info(&spi->dev, \"rev 0x%x, SPI clk %dHz, bpw %u, irq %d\\n\",\n\t\t max3421_hcd->rev, spi->max_speed_hz, spi->bits_per_word,\n\t\t spi->irq);\n\n\twhile (!kthread_should_stop()) {\n\t\tif (!i_worked) {\n\t\t\t/*\n\t\t\t * We'll be waiting for wakeups from the hard\n\t\t\t * interrupt handler, so now is a good time to\n\t\t\t * sync our hien with the chip:\n\t\t\t */\n\t\t\tspi_wr8(hcd, MAX3421_REG_HIEN, max3421_hcd->hien);\n\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tif (test_and_clear_bit(ENABLE_IRQ, &max3421_hcd->todo))\n\t\t\t\tenable_irq(spi->irq);\n\t\t\tschedule();\n\t\t\t__set_current_state(TASK_RUNNING);\n\t\t}\n\n\t\ti_worked = 0;\n\n\t\tif (max3421_hcd->urb_done)\n\t\t\ti_worked |= max3421_urb_done(hcd);\n\t\telse if (max3421_handle_irqs(hcd))\n\t\t\ti_worked = 1;\n\t\telse if (!max3421_hcd->curr_urb)\n\t\t\ti_worked |= max3421_select_and_start_urb(hcd);\n\n\t\tif (test_and_clear_bit(RESET_HCD, &max3421_hcd->todo))\n\t\t\t/* reset the HCD: */\n\t\t\ti_worked |= max3421_reset_hcd(hcd);\n\t\tif (test_and_clear_bit(RESET_PORT, &max3421_hcd->todo)) {\n\t\t\t/* perform a USB bus reset: */\n\t\t\tspi_wr8(hcd, MAX3421_REG_HCTL,\n\t\t\t\tBIT(MAX3421_HCTL_BUSRST_BIT));\n\t\t\ti_worked = 1;\n\t\t}\n\t\tif (test_and_clear_bit(CHECK_UNLINK, &max3421_hcd->todo))\n\t\t\ti_worked |= max3421_check_unlink(hcd);\n\t\tif (test_and_clear_bit(IOPIN_UPDATE, &max3421_hcd->todo)) {\n\t\t\t/*\n\t\t\t * IOPINS1/IOPINS2 do not auto-increment, so we can't\n\t\t\t * use spi_wr_buf().\n\t\t\t */\n\t\t\tfor (i = 0; i < ARRAY_SIZE(max3421_hcd->iopins); ++i) {\n\t\t\t\tu8 val = spi_rd8(hcd, MAX3421_REG_IOPINS1);\n\n\t\t\t\tval = ((val & 0xf0) |\n\t\t\t\t       (max3421_hcd->iopins[i] & 0x0f));\n\t\t\t\tspi_wr8(hcd, MAX3421_REG_IOPINS1 + i, val);\n\t\t\t\tmax3421_hcd->iopins[i] = val;\n\t\t\t}\n\t\t\ti_worked = 1;\n\t\t}\n\t}\n\tset_current_state(TASK_RUNNING);\n\tdev_info(&spi->dev, \"SPI thread exiting\");\n\treturn 0;\n}\n\nstatic int\nmax3421_reset_port(struct usb_hcd *hcd)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\n\tmax3421_hcd->port_status &= ~(USB_PORT_STAT_ENABLE |\n\t\t\t\t      USB_PORT_STAT_LOW_SPEED);\n\tmax3421_hcd->port_status |= USB_PORT_STAT_RESET;\n\tset_bit(RESET_PORT, &max3421_hcd->todo);\n\twake_up_process(max3421_hcd->spi_thread);\n\treturn 0;\n}\n\nstatic int\nmax3421_reset(struct usb_hcd *hcd)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\n\thcd->self.sg_tablesize = 0;\n\thcd->speed = HCD_USB2;\n\thcd->self.root_hub->speed = USB_SPEED_FULL;\n\tset_bit(RESET_HCD, &max3421_hcd->todo);\n\twake_up_process(max3421_hcd->spi_thread);\n\treturn 0;\n}\n\nstatic int\nmax3421_start(struct usb_hcd *hcd)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\n\tspin_lock_init(&max3421_hcd->lock);\n\tmax3421_hcd->rh_state = MAX3421_RH_RUNNING;\n\n\tINIT_LIST_HEAD(&max3421_hcd->ep_list);\n\n\thcd->power_budget = POWER_BUDGET;\n\thcd->state = HC_STATE_RUNNING;\n\thcd->uses_new_polling = 1;\n\treturn 0;\n}\n\nstatic void\nmax3421_stop(struct usb_hcd *hcd)\n{\n}\n\nstatic int\nmax3421_urb_enqueue(struct usb_hcd *hcd, struct urb *urb, gfp_t mem_flags)\n{\n\tstruct spi_device *spi = to_spi_device(hcd->self.controller);\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tstruct max3421_ep *max3421_ep;\n\tunsigned long flags;\n\tint retval;\n\n\tswitch (usb_pipetype(urb->pipe)) {\n\tcase PIPE_INTERRUPT:\n\tcase PIPE_ISOCHRONOUS:\n\t\tif (urb->interval < 0) {\n\t\t\tdev_err(&spi->dev,\n\t\t\t  \"%s: interval=%d for intr-/iso-pipe; expected > 0\\n\",\n\t\t\t\t__func__, urb->interval);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tspin_lock_irqsave(&max3421_hcd->lock, flags);\n\n\tmax3421_ep = urb->ep->hcpriv;\n\tif (!max3421_ep) {\n\t\t/* gets freed in max3421_endpoint_disable: */\n\t\tmax3421_ep = kzalloc(sizeof(struct max3421_ep), GFP_ATOMIC);\n\t\tif (!max3421_ep) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tmax3421_ep->ep = urb->ep;\n\t\tmax3421_ep->last_active = max3421_hcd->frame_number;\n\t\turb->ep->hcpriv = max3421_ep;\n\n\t\tlist_add_tail(&max3421_ep->ep_list, &max3421_hcd->ep_list);\n\t}\n\n\tretval = usb_hcd_link_urb_to_ep(hcd, urb);\n\tif (retval == 0) {\n\t\t/* Since we added to the queue, restart scheduling: */\n\t\tmax3421_hcd->sched_pass = SCHED_PASS_PERIODIC;\n\t\twake_up_process(max3421_hcd->spi_thread);\n\t}\n\nout:\n\tspin_unlock_irqrestore(&max3421_hcd->lock, flags);\n\treturn retval;\n}\n\nstatic int\nmax3421_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tunsigned long flags;\n\tint retval;\n\n\tspin_lock_irqsave(&max3421_hcd->lock, flags);\n\n\t/*\n\t * This will set urb->unlinked which in turn causes the entry\n\t * to be dropped at the next opportunity.\n\t */\n\tretval = usb_hcd_check_unlink_urb(hcd, urb, status);\n\tif (retval == 0) {\n\t\tset_bit(CHECK_UNLINK, &max3421_hcd->todo);\n\t\twake_up_process(max3421_hcd->spi_thread);\n\t}\n\tspin_unlock_irqrestore(&max3421_hcd->lock, flags);\n\treturn retval;\n}\n\nstatic void\nmax3421_endpoint_disable(struct usb_hcd *hcd, struct usb_host_endpoint *ep)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&max3421_hcd->lock, flags);\n\n\tif (ep->hcpriv) {\n\t\tstruct max3421_ep *max3421_ep = ep->hcpriv;\n\n\t\t/* remove myself from the ep_list: */\n\t\tif (!list_empty(&max3421_ep->ep_list))\n\t\t\tlist_del(&max3421_ep->ep_list);\n\t\tkfree(max3421_ep);\n\t\tep->hcpriv = NULL;\n\t}\n\n\tspin_unlock_irqrestore(&max3421_hcd->lock, flags);\n}\n\nstatic int\nmax3421_get_frame_number(struct usb_hcd *hcd)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\treturn max3421_hcd->frame_number;\n}\n\n/*\n * Should return a non-zero value when any port is undergoing a resume\n * transition while the root hub is suspended.\n */\nstatic int\nmax3421_hub_status_data(struct usb_hcd *hcd, char *buf)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tunsigned long flags;\n\tint retval = 0;\n\n\tspin_lock_irqsave(&max3421_hcd->lock, flags);\n\tif (!HCD_HW_ACCESSIBLE(hcd))\n\t\tgoto done;\n\n\t*buf = 0;\n\tif ((max3421_hcd->port_status & PORT_C_MASK) != 0) {\n\t\t*buf = (1 << 1); /* a hub over-current condition exists */\n\t\tdev_dbg(hcd->self.controller,\n\t\t\t\"port status 0x%08x has changes\\n\",\n\t\t\tmax3421_hcd->port_status);\n\t\tretval = 1;\n\t\tif (max3421_hcd->rh_state == MAX3421_RH_SUSPENDED)\n\t\t\tusb_hcd_resume_root_hub(hcd);\n\t}\ndone:\n\tspin_unlock_irqrestore(&max3421_hcd->lock, flags);\n\treturn retval;\n}\n\nstatic inline void\nhub_descriptor(struct usb_hub_descriptor *desc)\n{\n\tmemset(desc, 0, sizeof(*desc));\n\t/*\n\t * See Table 11-13: Hub Descriptor in USB 2.0 spec.\n\t */\n\tdesc->bDescriptorType = USB_DT_HUB; /* hub descriptor */\n\tdesc->bDescLength = 9;\n\tdesc->wHubCharacteristics = cpu_to_le16(HUB_CHAR_INDV_PORT_LPSM |\n\t\t\t\t\t\tHUB_CHAR_COMMON_OCPM);\n\tdesc->bNbrPorts = 1;\n}\n\n/*\n * Set the MAX3421E general-purpose output with number PIN_NUMBER to\n * VALUE (0 or 1).  PIN_NUMBER may be in the range from 1-8.  For\n * any other value, this function acts as a no-op.\n */\nstatic void\nmax3421_gpout_set_value(struct usb_hcd *hcd, u8 pin_number, u8 value)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tu8 mask, idx;\n\n\t--pin_number;\n\tif (pin_number >= MAX3421_GPOUT_COUNT)\n\t\treturn;\n\n\tmask = 1u << (pin_number % 4);\n\tidx = pin_number / 4;\n\n\tif (value)\n\t\tmax3421_hcd->iopins[idx] |=  mask;\n\telse\n\t\tmax3421_hcd->iopins[idx] &= ~mask;\n\tset_bit(IOPIN_UPDATE, &max3421_hcd->todo);\n\twake_up_process(max3421_hcd->spi_thread);\n}\n\nstatic int\nmax3421_hub_control(struct usb_hcd *hcd, u16 type_req, u16 value, u16 index,\n\t\t    char *buf, u16 length)\n{\n\tstruct spi_device *spi = to_spi_device(hcd->self.controller);\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tstruct max3421_hcd_platform_data *pdata;\n\tunsigned long flags;\n\tint retval = 0;\n\n\tpdata = spi->dev.platform_data;\n\n\tspin_lock_irqsave(&max3421_hcd->lock, flags);\n\n\tswitch (type_req) {\n\tcase ClearHubFeature:\n\t\tbreak;\n\tcase ClearPortFeature:\n\t\tswitch (value) {\n\t\tcase USB_PORT_FEAT_SUSPEND:\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_POWER:\n\t\t\tdev_dbg(hcd->self.controller, \"power-off\\n\");\n\t\t\tmax3421_gpout_set_value(hcd, pdata->vbus_gpout,\n\t\t\t\t\t\t!pdata->vbus_active_level);\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tmax3421_hcd->port_status &= ~(1 << value);\n\t\t}\n\t\tbreak;\n\tcase GetHubDescriptor:\n\t\thub_descriptor((struct usb_hub_descriptor *) buf);\n\t\tbreak;\n\n\tcase DeviceRequest | USB_REQ_GET_DESCRIPTOR:\n\tcase GetPortErrorCount:\n\tcase SetHubDepth:\n\t\t/* USB3 only */\n\t\tgoto error;\n\n\tcase GetHubStatus:\n\t\t*(__le32 *) buf = cpu_to_le32(0);\n\t\tbreak;\n\n\tcase GetPortStatus:\n\t\tif (index != 1) {\n\t\t\tretval = -EPIPE;\n\t\t\tgoto error;\n\t\t}\n\t\t((__le16 *) buf)[0] = cpu_to_le16(max3421_hcd->port_status);\n\t\t((__le16 *) buf)[1] =\n\t\t\tcpu_to_le16(max3421_hcd->port_status >> 16);\n\t\tbreak;\n\n\tcase SetHubFeature:\n\t\tretval = -EPIPE;\n\t\tbreak;\n\n\tcase SetPortFeature:\n\t\tswitch (value) {\n\t\tcase USB_PORT_FEAT_LINK_STATE:\n\t\tcase USB_PORT_FEAT_U1_TIMEOUT:\n\t\tcase USB_PORT_FEAT_U2_TIMEOUT:\n\t\tcase USB_PORT_FEAT_BH_PORT_RESET:\n\t\t\tgoto error;\n\t\tcase USB_PORT_FEAT_SUSPEND:\n\t\t\tif (max3421_hcd->active)\n\t\t\t\tmax3421_hcd->port_status |=\n\t\t\t\t\tUSB_PORT_STAT_SUSPEND;\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_POWER:\n\t\t\tdev_dbg(hcd->self.controller, \"power-on\\n\");\n\t\t\tmax3421_hcd->port_status |= USB_PORT_STAT_POWER;\n\t\t\tmax3421_gpout_set_value(hcd, pdata->vbus_gpout,\n\t\t\t\t\t\tpdata->vbus_active_level);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_RESET:\n\t\t\tmax3421_reset_port(hcd);\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tif ((max3421_hcd->port_status & USB_PORT_STAT_POWER)\n\t\t\t    != 0)\n\t\t\t\tmax3421_hcd->port_status |= (1 << value);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tdev_dbg(hcd->self.controller,\n\t\t\t\"hub control req%04x v%04x i%04x l%d\\n\",\n\t\t\ttype_req, value, index, length);\nerror:\t\t/* \"protocol stall\" on error */\n\t\tretval = -EPIPE;\n\t}\n\n\tspin_unlock_irqrestore(&max3421_hcd->lock, flags);\n\treturn retval;\n}\n\nstatic int\nmax3421_bus_suspend(struct usb_hcd *hcd)\n{\n\treturn -1;\n}\n\nstatic int\nmax3421_bus_resume(struct usb_hcd *hcd)\n{\n\treturn -1;\n}\n\nstatic const struct hc_driver max3421_hcd_desc = {\n\t.description =\t\t\"max3421\",\n\t.product_desc =\t\tDRIVER_DESC,\n\t.hcd_priv_size =\tsizeof(struct max3421_hcd),\n\t.flags =\t\tHCD_USB11,\n\t.reset =\t\tmax3421_reset,\n\t.start =\t\tmax3421_start,\n\t.stop =\t\t\tmax3421_stop,\n\t.get_frame_number =\tmax3421_get_frame_number,\n\t.urb_enqueue =\t\tmax3421_urb_enqueue,\n\t.urb_dequeue =\t\tmax3421_urb_dequeue,\n\t.endpoint_disable =\tmax3421_endpoint_disable,\n\t.hub_status_data =\tmax3421_hub_status_data,\n\t.hub_control =\t\tmax3421_hub_control,\n\t.bus_suspend =\t\tmax3421_bus_suspend,\n\t.bus_resume =\t\tmax3421_bus_resume,\n};\n\nstatic int\nmax3421_of_vbus_en_pin(struct device *dev, struct max3421_hcd_platform_data *pdata)\n{\n\tint retval;\n\tuint32_t value[2];\n\n\tif (!pdata)\n\t\treturn -EINVAL;\n\n\tretval = of_property_read_u32_array(dev->of_node, \"maxim,vbus-en-pin\", value, 2);\n\tif (retval) {\n\t\tdev_err(dev, \"device tree node property 'maxim,vbus-en-pin' is missing\\n\");\n\t\treturn retval;\n\t}\n\tdev_info(dev, \"property 'maxim,vbus-en-pin' value is <%d %d>\\n\", value[0], value[1]);\n\n\tpdata->vbus_gpout = value[0];\n\tpdata->vbus_active_level = value[1];\n\n\treturn 0;\n}\n\nstatic int\nmax3421_probe(struct spi_device *spi)\n{\n\tstruct device *dev = &spi->dev;\n\tstruct max3421_hcd *max3421_hcd;\n\tstruct usb_hcd *hcd = NULL;\n\tstruct max3421_hcd_platform_data *pdata = NULL;\n\tint retval;\n\n\tif (spi_setup(spi) < 0) {\n\t\tdev_err(&spi->dev, \"Unable to setup SPI bus\");\n\t\treturn -EFAULT;\n\t}\n\n\tif (!spi->irq) {\n\t\tdev_err(dev, \"Failed to get SPI IRQ\");\n\t\treturn -EFAULT;\n\t}\n\n\tif (IS_ENABLED(CONFIG_OF) && dev->of_node) {\n\t\tpdata = devm_kzalloc(&spi->dev, sizeof(*pdata), GFP_KERNEL);\n\t\tif (!pdata) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t\tretval = max3421_of_vbus_en_pin(dev, pdata);\n\t\tif (retval)\n\t\t\tgoto error;\n\n\t\tspi->dev.platform_data = pdata;\n\t}\n\n\tpdata = spi->dev.platform_data;\n\tif (!pdata) {\n\t\tdev_err(&spi->dev, \"driver configuration data is not provided\\n\");\n\t\tretval = -EFAULT;\n\t\tgoto error;\n\t}\n\tif (pdata->vbus_active_level > 1) {\n\t\tdev_err(&spi->dev, \"vbus active level value %d is out of range (0/1)\\n\", pdata->vbus_active_level);\n\t\tretval = -EINVAL;\n\t\tgoto error;\n\t}\n\tif (pdata->vbus_gpout < 1 || pdata->vbus_gpout > MAX3421_GPOUT_COUNT) {\n\t\tdev_err(&spi->dev, \"vbus gpout value %d is out of range (1..8)\\n\", pdata->vbus_gpout);\n\t\tretval = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tretval = -ENOMEM;\n\thcd = usb_create_hcd(&max3421_hcd_desc, &spi->dev,\n\t\t\t     dev_name(&spi->dev));\n\tif (!hcd) {\n\t\tdev_err(&spi->dev, \"failed to create HCD structure\\n\");\n\t\tgoto error;\n\t}\n\tset_bit(HCD_FLAG_POLL_RH, &hcd->flags);\n\tmax3421_hcd = hcd_to_max3421(hcd);\n\tmax3421_hcd->next = max3421_hcd_list;\n\tmax3421_hcd_list = max3421_hcd;\n\tINIT_LIST_HEAD(&max3421_hcd->ep_list);\n\n\tmax3421_hcd->tx = kmalloc(sizeof(*max3421_hcd->tx), GFP_KERNEL);\n\tif (!max3421_hcd->tx)\n\t\tgoto error;\n\tmax3421_hcd->rx = kmalloc(sizeof(*max3421_hcd->rx), GFP_KERNEL);\n\tif (!max3421_hcd->rx)\n\t\tgoto error;\n\n\tmax3421_hcd->spi_thread = kthread_run(max3421_spi_thread, hcd,\n\t\t\t\t\t      \"max3421_spi_thread\");\n\tif (max3421_hcd->spi_thread == ERR_PTR(-ENOMEM)) {\n\t\tdev_err(&spi->dev,\n\t\t\t\"failed to create SPI thread (out of memory)\\n\");\n\t\tgoto error;\n\t}\n\n\tretval = usb_add_hcd(hcd, 0, 0);\n\tif (retval) {\n\t\tdev_err(&spi->dev, \"failed to add HCD\\n\");\n\t\tgoto error;\n\t}\n\n\tretval = request_irq(spi->irq, max3421_irq_handler,\n\t\t\t     IRQF_TRIGGER_LOW, \"max3421\", hcd);\n\tif (retval < 0) {\n\t\tdev_err(&spi->dev, \"failed to request irq %d\\n\", spi->irq);\n\t\tgoto error;\n\t}\n\treturn 0;\n\nerror:\n\tif (IS_ENABLED(CONFIG_OF) && dev->of_node && pdata) {\n\t\tdevm_kfree(&spi->dev, pdata);\n\t\tspi->dev.platform_data = NULL;\n\t}\n\n\tif (hcd) {\n\t\tkfree(max3421_hcd->tx);\n\t\tkfree(max3421_hcd->rx);\n\t\tif (max3421_hcd->spi_thread)\n\t\t\tkthread_stop(max3421_hcd->spi_thread);\n\t\tusb_put_hcd(hcd);\n\t}\n\treturn retval;\n}\n\nstatic int\nmax3421_remove(struct spi_device *spi)\n{\n\tstruct max3421_hcd *max3421_hcd = NULL, **prev;\n\tstruct usb_hcd *hcd = NULL;\n\tunsigned long flags;\n\n\tfor (prev = &max3421_hcd_list; *prev; prev = &(*prev)->next) {\n\t\tmax3421_hcd = *prev;\n\t\thcd = max3421_to_hcd(max3421_hcd);\n\t\tif (hcd->self.controller == &spi->dev)\n\t\t\tbreak;\n\t}\n\tif (!max3421_hcd) {\n\t\tdev_err(&spi->dev, \"no MAX3421 HCD found for SPI device %p\\n\",\n\t\t\tspi);\n\t\treturn -ENODEV;\n\t}\n\n\tusb_remove_hcd(hcd);\n\n\tspin_lock_irqsave(&max3421_hcd->lock, flags);\n\n\tkthread_stop(max3421_hcd->spi_thread);\n\t*prev = max3421_hcd->next;\n\n\tspin_unlock_irqrestore(&max3421_hcd->lock, flags);\n\n\tfree_irq(spi->irq, hcd);\n\n\tusb_put_hcd(hcd);\n\treturn 0;\n}\n\nstatic const struct of_device_id max3421_of_match_table[] = {\n\t{ .compatible = \"maxim,max3421\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, max3421_of_match_table);\n\nstatic struct spi_driver max3421_driver = {\n\t.probe\t\t= max3421_probe,\n\t.remove\t\t= max3421_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"max3421-hcd\",\n\t\t.of_match_table = of_match_ptr(max3421_of_match_table),\n\t},\n};\n\nmodule_spi_driver(max3421_driver);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_AUTHOR(\"David Mosberger <davidm@egauge.net>\");\nMODULE_LICENSE(\"GPL\");\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * MAX3421 Host Controller driver for USB.\n *\n * Author: David Mosberger-Tang <davidm@egauge.net>\n *\n * (C) Copyright 2014 David Mosberger-Tang <davidm@egauge.net>\n *\n * MAX3421 is a chip implementing a USB 2.0 Full-/Low-Speed host\n * controller on a SPI bus.\n *\n * Based on:\n *\to MAX3421E datasheet\n *\t\thttps://datasheets.maximintegrated.com/en/ds/MAX3421E.pdf\n *\to MAX3421E Programming Guide\n *\t\thttps://www.hdl.co.jp/ftpdata/utl-001/AN3785.pdf\n *\to gadget/dummy_hcd.c\n *\t\tFor USB HCD implementation.\n *\to Arduino MAX3421 driver\n *\t     https://github.com/felis/USB_Host_Shield_2.0/blob/master/Usb.cpp\n *\n * This file is licenced under the GPL v2.\n *\n * Important note on worst-case (full-speed) packet size constraints\n * (See USB 2.0 Section 5.6.3 and following):\n *\n *\t- control:\t  64 bytes\n *\t- isochronous:\t1023 bytes\n *\t- interrupt:\t  64 bytes\n *\t- bulk:\t\t  64 bytes\n *\n * Since the MAX3421 FIFO size is 64 bytes, we do not have to work about\n * multi-FIFO writes/reads for a single USB packet *except* for isochronous\n * transfers.  We don't support isochronous transfers at this time, so we\n * just assume that a USB packet always fits into a single FIFO buffer.\n *\n * NOTE: The June 2006 version of \"MAX3421E Programming Guide\"\n * (AN3785) has conflicting info for the RCVDAVIRQ bit:\n *\n *\tThe description of RCVDAVIRQ says \"The CPU *must* clear\n *\tthis IRQ bit (by writing a 1 to it) before reading the\n *\tRCVFIFO data.\n *\n * However, the earlier section on \"Programming BULK-IN\n * Transfers\" says * that:\n *\n *\tAfter the CPU retrieves the data, it clears the\n *\tRCVDAVIRQ bit.\n *\n * The December 2006 version has been corrected and it consistently\n * states the second behavior is the correct one.\n *\n * Synchronous SPI transactions sleep so we can't perform any such\n * transactions while holding a spin-lock (and/or while interrupts are\n * masked).  To achieve this, all SPI transactions are issued from a\n * single thread (max3421_spi_thread).\n */\n\n#include <linux/jiffies.h>\n#include <linux/module.h>\n#include <linux/spi/spi.h>\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n#include <linux/of.h>\n\n#include <linux/platform_data/max3421-hcd.h>\n\n#define DRIVER_DESC\t\"MAX3421 USB Host-Controller Driver\"\n#define DRIVER_VERSION\t\"1.0\"\n\n/* 11-bit counter that wraps around (USB 2.0 Section 8.3.3): */\n#define USB_MAX_FRAME_NUMBER\t0x7ff\n#define USB_MAX_RETRIES\t\t3 /* # of retries before error is reported */\n\n/*\n * Max. # of times we're willing to retransmit a request immediately in\n * resposne to a NAK.  Afterwards, we fall back on trying once a frame.\n */\n#define NAK_MAX_FAST_RETRANSMITS\t2\n\n#define POWER_BUDGET\t500\t/* in mA; use 8 for low-power port testing */\n\n/* Port-change mask: */\n#define PORT_C_MASK\t((USB_PORT_STAT_C_CONNECTION |\t\\\n\t\t\t  USB_PORT_STAT_C_ENABLE |\t\\\n\t\t\t  USB_PORT_STAT_C_SUSPEND |\t\\\n\t\t\t  USB_PORT_STAT_C_OVERCURRENT | \\\n\t\t\t  USB_PORT_STAT_C_RESET) << 16)\n\n#define MAX3421_GPOUT_COUNT\t8\n\nenum max3421_rh_state {\n\tMAX3421_RH_RESET,\n\tMAX3421_RH_SUSPENDED,\n\tMAX3421_RH_RUNNING\n};\n\nenum pkt_state {\n\tPKT_STATE_SETUP,\t/* waiting to send setup packet to ctrl pipe */\n\tPKT_STATE_TRANSFER,\t/* waiting to xfer transfer_buffer */\n\tPKT_STATE_TERMINATE\t/* waiting to terminate control transfer */\n};\n\nenum scheduling_pass {\n\tSCHED_PASS_PERIODIC,\n\tSCHED_PASS_NON_PERIODIC,\n\tSCHED_PASS_DONE\n};\n\n/* Bit numbers for max3421_hcd->todo: */\nenum {\n\tENABLE_IRQ = 0,\n\tRESET_HCD,\n\tRESET_PORT,\n\tCHECK_UNLINK,\n\tIOPIN_UPDATE\n};\n\nstruct max3421_dma_buf {\n\tu8 data[2];\n};\n\nstruct max3421_hcd {\n\tspinlock_t lock;\n\n\tstruct task_struct *spi_thread;\n\n\tstruct max3421_hcd *next;\n\n\tenum max3421_rh_state rh_state;\n\t/* lower 16 bits contain port status, upper 16 bits the change mask: */\n\tu32 port_status;\n\n\tunsigned active:1;\n\n\tstruct list_head ep_list;\t/* list of EP's with work */\n\n\t/*\n\t * The following are owned by spi_thread (may be accessed by\n\t * SPI-thread without acquiring the HCD lock:\n\t */\n\tu8 rev;\t\t\t\t/* chip revision */\n\tu16 frame_number;\n\t/*\n\t * kmalloc'd buffers guaranteed to be in separate (DMA)\n\t * cache-lines:\n\t */\n\tstruct max3421_dma_buf *tx;\n\tstruct max3421_dma_buf *rx;\n\t/*\n\t * URB we're currently processing.  Must not be reset to NULL\n\t * unless MAX3421E chip is idle:\n\t */\n\tstruct urb *curr_urb;\n\tenum scheduling_pass sched_pass;\n\tint urb_done;\t\t\t/* > 0 -> no errors, < 0: errno */\n\tsize_t curr_len;\n\tu8 hien;\n\tu8 mode;\n\tu8 iopins[2];\n\tunsigned long todo;\n#ifdef DEBUG\n\tunsigned long err_stat[16];\n#endif\n};\n\nstruct max3421_ep {\n\tstruct usb_host_endpoint *ep;\n\tstruct list_head ep_list;\n\tu32 naks;\n\tu16 last_active;\t\t/* frame # this ep was last active */\n\tenum pkt_state pkt_state;\n\tu8 retries;\n\tu8 retransmit;\t\t\t/* packet needs retransmission */\n};\n\nstatic struct max3421_hcd *max3421_hcd_list;\n\n#define MAX3421_FIFO_SIZE\t64\n\n#define MAX3421_SPI_DIR_RD\t0\t/* read register from MAX3421 */\n#define MAX3421_SPI_DIR_WR\t1\t/* write register to MAX3421 */\n\n/* SPI commands: */\n#define MAX3421_SPI_DIR_SHIFT\t1\n#define MAX3421_SPI_REG_SHIFT\t3\n\n#define MAX3421_REG_RCVFIFO\t1\n#define MAX3421_REG_SNDFIFO\t2\n#define MAX3421_REG_SUDFIFO\t4\n#define MAX3421_REG_RCVBC\t6\n#define MAX3421_REG_SNDBC\t7\n#define MAX3421_REG_USBIRQ\t13\n#define MAX3421_REG_USBIEN\t14\n#define MAX3421_REG_USBCTL\t15\n#define MAX3421_REG_CPUCTL\t16\n#define MAX3421_REG_PINCTL\t17\n#define MAX3421_REG_REVISION\t18\n#define MAX3421_REG_IOPINS1\t20\n#define MAX3421_REG_IOPINS2\t21\n#define MAX3421_REG_GPINIRQ\t22\n#define MAX3421_REG_GPINIEN\t23\n#define MAX3421_REG_GPINPOL\t24\n#define MAX3421_REG_HIRQ\t25\n#define MAX3421_REG_HIEN\t26\n#define MAX3421_REG_MODE\t27\n#define MAX3421_REG_PERADDR\t28\n#define MAX3421_REG_HCTL\t29\n#define MAX3421_REG_HXFR\t30\n#define MAX3421_REG_HRSL\t31\n\nenum {\n\tMAX3421_USBIRQ_OSCOKIRQ_BIT = 0,\n\tMAX3421_USBIRQ_NOVBUSIRQ_BIT = 5,\n\tMAX3421_USBIRQ_VBUSIRQ_BIT\n};\n\nenum {\n\tMAX3421_CPUCTL_IE_BIT = 0,\n\tMAX3421_CPUCTL_PULSEWID0_BIT = 6,\n\tMAX3421_CPUCTL_PULSEWID1_BIT\n};\n\nenum {\n\tMAX3421_USBCTL_PWRDOWN_BIT = 4,\n\tMAX3421_USBCTL_CHIPRES_BIT\n};\n\nenum {\n\tMAX3421_PINCTL_GPXA_BIT\t= 0,\n\tMAX3421_PINCTL_GPXB_BIT,\n\tMAX3421_PINCTL_POSINT_BIT,\n\tMAX3421_PINCTL_INTLEVEL_BIT,\n\tMAX3421_PINCTL_FDUPSPI_BIT,\n\tMAX3421_PINCTL_EP0INAK_BIT,\n\tMAX3421_PINCTL_EP2INAK_BIT,\n\tMAX3421_PINCTL_EP3INAK_BIT,\n};\n\nenum {\n\tMAX3421_HI_BUSEVENT_BIT = 0,\t/* bus-reset/-resume */\n\tMAX3421_HI_RWU_BIT,\t\t/* remote wakeup */\n\tMAX3421_HI_RCVDAV_BIT,\t\t/* receive FIFO data available */\n\tMAX3421_HI_SNDBAV_BIT,\t\t/* send buffer available */\n\tMAX3421_HI_SUSDN_BIT,\t\t/* suspend operation done */\n\tMAX3421_HI_CONDET_BIT,\t\t/* peripheral connect/disconnect */\n\tMAX3421_HI_FRAME_BIT,\t\t/* frame generator */\n\tMAX3421_HI_HXFRDN_BIT,\t\t/* host transfer done */\n};\n\nenum {\n\tMAX3421_HCTL_BUSRST_BIT = 0,\n\tMAX3421_HCTL_FRMRST_BIT,\n\tMAX3421_HCTL_SAMPLEBUS_BIT,\n\tMAX3421_HCTL_SIGRSM_BIT,\n\tMAX3421_HCTL_RCVTOG0_BIT,\n\tMAX3421_HCTL_RCVTOG1_BIT,\n\tMAX3421_HCTL_SNDTOG0_BIT,\n\tMAX3421_HCTL_SNDTOG1_BIT\n};\n\nenum {\n\tMAX3421_MODE_HOST_BIT = 0,\n\tMAX3421_MODE_LOWSPEED_BIT,\n\tMAX3421_MODE_HUBPRE_BIT,\n\tMAX3421_MODE_SOFKAENAB_BIT,\n\tMAX3421_MODE_SEPIRQ_BIT,\n\tMAX3421_MODE_DELAYISO_BIT,\n\tMAX3421_MODE_DMPULLDN_BIT,\n\tMAX3421_MODE_DPPULLDN_BIT\n};\n\nenum {\n\tMAX3421_HRSL_OK = 0,\n\tMAX3421_HRSL_BUSY,\n\tMAX3421_HRSL_BADREQ,\n\tMAX3421_HRSL_UNDEF,\n\tMAX3421_HRSL_NAK,\n\tMAX3421_HRSL_STALL,\n\tMAX3421_HRSL_TOGERR,\n\tMAX3421_HRSL_WRONGPID,\n\tMAX3421_HRSL_BADBC,\n\tMAX3421_HRSL_PIDERR,\n\tMAX3421_HRSL_PKTERR,\n\tMAX3421_HRSL_CRCERR,\n\tMAX3421_HRSL_KERR,\n\tMAX3421_HRSL_JERR,\n\tMAX3421_HRSL_TIMEOUT,\n\tMAX3421_HRSL_BABBLE,\n\tMAX3421_HRSL_RESULT_MASK = 0xf,\n\tMAX3421_HRSL_RCVTOGRD_BIT = 4,\n\tMAX3421_HRSL_SNDTOGRD_BIT,\n\tMAX3421_HRSL_KSTATUS_BIT,\n\tMAX3421_HRSL_JSTATUS_BIT\n};\n\n/* Return same error-codes as ohci.h:cc_to_error: */\nstatic const int hrsl_to_error[] = {\n\t[MAX3421_HRSL_OK] =\t\t0,\n\t[MAX3421_HRSL_BUSY] =\t\t-EINVAL,\n\t[MAX3421_HRSL_BADREQ] =\t\t-EINVAL,\n\t[MAX3421_HRSL_UNDEF] =\t\t-EINVAL,\n\t[MAX3421_HRSL_NAK] =\t\t-EAGAIN,\n\t[MAX3421_HRSL_STALL] =\t\t-EPIPE,\n\t[MAX3421_HRSL_TOGERR] =\t\t-EILSEQ,\n\t[MAX3421_HRSL_WRONGPID] =\t-EPROTO,\n\t[MAX3421_HRSL_BADBC] =\t\t-EREMOTEIO,\n\t[MAX3421_HRSL_PIDERR] =\t\t-EPROTO,\n\t[MAX3421_HRSL_PKTERR] =\t\t-EPROTO,\n\t[MAX3421_HRSL_CRCERR] =\t\t-EILSEQ,\n\t[MAX3421_HRSL_KERR] =\t\t-EIO,\n\t[MAX3421_HRSL_JERR] =\t\t-EIO,\n\t[MAX3421_HRSL_TIMEOUT] =\t-ETIME,\n\t[MAX3421_HRSL_BABBLE] =\t\t-EOVERFLOW\n};\n\n/*\n * See https://www.beyondlogic.org/usbnutshell/usb4.shtml#Control for a\n * reasonable overview of how control transfers use the the IN/OUT\n * tokens.\n */\n#define MAX3421_HXFR_BULK_IN(ep)\t(0x00 | (ep))\t/* bulk or interrupt */\n#define MAX3421_HXFR_SETUP\t\t 0x10\n#define MAX3421_HXFR_BULK_OUT(ep)\t(0x20 | (ep))\t/* bulk or interrupt */\n#define MAX3421_HXFR_ISO_IN(ep)\t\t(0x40 | (ep))\n#define MAX3421_HXFR_ISO_OUT(ep)\t(0x60 | (ep))\n#define MAX3421_HXFR_HS_IN\t\t 0x80\t\t/* handshake in */\n#define MAX3421_HXFR_HS_OUT\t\t 0xa0\t\t/* handshake out */\n\n#define field(val, bit)\t((val) << (bit))\n\nstatic inline s16\nframe_diff(u16 left, u16 right)\n{\n\treturn ((unsigned) (left - right)) % (USB_MAX_FRAME_NUMBER + 1);\n}\n\nstatic inline struct max3421_hcd *\nhcd_to_max3421(struct usb_hcd *hcd)\n{\n\treturn (struct max3421_hcd *) hcd->hcd_priv;\n}\n\nstatic inline struct usb_hcd *\nmax3421_to_hcd(struct max3421_hcd *max3421_hcd)\n{\n\treturn container_of((void *) max3421_hcd, struct usb_hcd, hcd_priv);\n}\n\nstatic u8\nspi_rd8(struct usb_hcd *hcd, unsigned int reg)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tstruct spi_device *spi = to_spi_device(hcd->self.controller);\n\tstruct spi_transfer transfer;\n\tstruct spi_message msg;\n\n\tmemset(&transfer, 0, sizeof(transfer));\n\n\tspi_message_init(&msg);\n\n\tmax3421_hcd->tx->data[0] =\n\t\t(field(reg, MAX3421_SPI_REG_SHIFT) |\n\t\t field(MAX3421_SPI_DIR_RD, MAX3421_SPI_DIR_SHIFT));\n\n\ttransfer.tx_buf = max3421_hcd->tx->data;\n\ttransfer.rx_buf = max3421_hcd->rx->data;\n\ttransfer.len = 2;\n\n\tspi_message_add_tail(&transfer, &msg);\n\tspi_sync(spi, &msg);\n\n\treturn max3421_hcd->rx->data[1];\n}\n\nstatic void\nspi_wr8(struct usb_hcd *hcd, unsigned int reg, u8 val)\n{\n\tstruct spi_device *spi = to_spi_device(hcd->self.controller);\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tstruct spi_transfer transfer;\n\tstruct spi_message msg;\n\n\tmemset(&transfer, 0, sizeof(transfer));\n\n\tspi_message_init(&msg);\n\n\tmax3421_hcd->tx->data[0] =\n\t\t(field(reg, MAX3421_SPI_REG_SHIFT) |\n\t\t field(MAX3421_SPI_DIR_WR, MAX3421_SPI_DIR_SHIFT));\n\tmax3421_hcd->tx->data[1] = val;\n\n\ttransfer.tx_buf = max3421_hcd->tx->data;\n\ttransfer.len = 2;\n\n\tspi_message_add_tail(&transfer, &msg);\n\tspi_sync(spi, &msg);\n}\n\nstatic void\nspi_rd_buf(struct usb_hcd *hcd, unsigned int reg, void *buf, size_t len)\n{\n\tstruct spi_device *spi = to_spi_device(hcd->self.controller);\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tstruct spi_transfer transfer[2];\n\tstruct spi_message msg;\n\n\tmemset(transfer, 0, sizeof(transfer));\n\n\tspi_message_init(&msg);\n\n\tmax3421_hcd->tx->data[0] =\n\t\t(field(reg, MAX3421_SPI_REG_SHIFT) |\n\t\t field(MAX3421_SPI_DIR_RD, MAX3421_SPI_DIR_SHIFT));\n\ttransfer[0].tx_buf = max3421_hcd->tx->data;\n\ttransfer[0].len = 1;\n\n\ttransfer[1].rx_buf = buf;\n\ttransfer[1].len = len;\n\n\tspi_message_add_tail(&transfer[0], &msg);\n\tspi_message_add_tail(&transfer[1], &msg);\n\tspi_sync(spi, &msg);\n}\n\nstatic void\nspi_wr_buf(struct usb_hcd *hcd, unsigned int reg, void *buf, size_t len)\n{\n\tstruct spi_device *spi = to_spi_device(hcd->self.controller);\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tstruct spi_transfer transfer[2];\n\tstruct spi_message msg;\n\n\tmemset(transfer, 0, sizeof(transfer));\n\n\tspi_message_init(&msg);\n\n\tmax3421_hcd->tx->data[0] =\n\t\t(field(reg, MAX3421_SPI_REG_SHIFT) |\n\t\t field(MAX3421_SPI_DIR_WR, MAX3421_SPI_DIR_SHIFT));\n\n\ttransfer[0].tx_buf = max3421_hcd->tx->data;\n\ttransfer[0].len = 1;\n\n\ttransfer[1].tx_buf = buf;\n\ttransfer[1].len = len;\n\n\tspi_message_add_tail(&transfer[0], &msg);\n\tspi_message_add_tail(&transfer[1], &msg);\n\tspi_sync(spi, &msg);\n}\n\n/*\n * Figure out the correct setting for the LOWSPEED and HUBPRE mode\n * bits.  The HUBPRE bit needs to be set when MAX3421E operates at\n * full speed, but it's talking to a low-speed device (i.e., through a\n * hub).  Setting that bit ensures that every low-speed packet is\n * preceded by a full-speed PRE PID.  Possible configurations:\n *\n * Hub speed:\tDevice speed:\t=>\tLOWSPEED bit:\tHUBPRE bit:\n *\tFULL\tFULL\t\t=>\t0\t\t0\n *\tFULL\tLOW\t\t=>\t1\t\t1\n *\tLOW\tLOW\t\t=>\t1\t\t0\n *\tLOW\tFULL\t\t=>\t1\t\t0\n */\nstatic void\nmax3421_set_speed(struct usb_hcd *hcd, struct usb_device *dev)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tu8 mode_lowspeed, mode_hubpre, mode = max3421_hcd->mode;\n\n\tmode_lowspeed = BIT(MAX3421_MODE_LOWSPEED_BIT);\n\tmode_hubpre   = BIT(MAX3421_MODE_HUBPRE_BIT);\n\tif (max3421_hcd->port_status & USB_PORT_STAT_LOW_SPEED) {\n\t\tmode |=  mode_lowspeed;\n\t\tmode &= ~mode_hubpre;\n\t} else if (dev->speed == USB_SPEED_LOW) {\n\t\tmode |= mode_lowspeed | mode_hubpre;\n\t} else {\n\t\tmode &= ~(mode_lowspeed | mode_hubpre);\n\t}\n\tif (mode != max3421_hcd->mode) {\n\t\tmax3421_hcd->mode = mode;\n\t\tspi_wr8(hcd, MAX3421_REG_MODE, max3421_hcd->mode);\n\t}\n\n}\n\n/*\n * Caller must NOT hold HCD spinlock.\n */\nstatic void\nmax3421_set_address(struct usb_hcd *hcd, struct usb_device *dev, int epnum)\n{\n\tint rcvtog, sndtog;\n\tu8 hctl;\n\n\t/* setup new endpoint's toggle bits: */\n\trcvtog = usb_gettoggle(dev, epnum, 0);\n\tsndtog = usb_gettoggle(dev, epnum, 1);\n\thctl = (BIT(rcvtog + MAX3421_HCTL_RCVTOG0_BIT) |\n\t\tBIT(sndtog + MAX3421_HCTL_SNDTOG0_BIT));\n\n\tspi_wr8(hcd, MAX3421_REG_HCTL, hctl);\n\n\t/*\n\t * Note: devnum for one and the same device can change during\n\t * address-assignment so it's best to just always load the\n\t * address whenever the end-point changed/was forced.\n\t */\n\tspi_wr8(hcd, MAX3421_REG_PERADDR, dev->devnum);\n}\n\nstatic int\nmax3421_ctrl_setup(struct usb_hcd *hcd, struct urb *urb)\n{\n\tspi_wr_buf(hcd, MAX3421_REG_SUDFIFO, urb->setup_packet, 8);\n\treturn MAX3421_HXFR_SETUP;\n}\n\nstatic int\nmax3421_transfer_in(struct usb_hcd *hcd, struct urb *urb)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tint epnum = usb_pipeendpoint(urb->pipe);\n\n\tmax3421_hcd->curr_len = 0;\n\tmax3421_hcd->hien |= BIT(MAX3421_HI_RCVDAV_BIT);\n\treturn MAX3421_HXFR_BULK_IN(epnum);\n}\n\nstatic int\nmax3421_transfer_out(struct usb_hcd *hcd, struct urb *urb, int fast_retransmit)\n{\n\tstruct spi_device *spi = to_spi_device(hcd->self.controller);\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tint epnum = usb_pipeendpoint(urb->pipe);\n\tu32 max_packet;\n\tvoid *src;\n\n\tsrc = urb->transfer_buffer + urb->actual_length;\n\n\tif (fast_retransmit) {\n\t\tif (max3421_hcd->rev == 0x12) {\n\t\t\t/* work around rev 0x12 bug: */\n\t\t\tspi_wr8(hcd, MAX3421_REG_SNDBC, 0);\n\t\t\tspi_wr8(hcd, MAX3421_REG_SNDFIFO, ((u8 *) src)[0]);\n\t\t\tspi_wr8(hcd, MAX3421_REG_SNDBC, max3421_hcd->curr_len);\n\t\t}\n\t\treturn MAX3421_HXFR_BULK_OUT(epnum);\n\t}\n\n\tmax_packet = usb_maxpacket(urb->dev, urb->pipe, 1);\n\n\tif (max_packet > MAX3421_FIFO_SIZE) {\n\t\t/*\n\t\t * We do not support isochronous transfers at this\n\t\t * time.\n\t\t */\n\t\tdev_err(&spi->dev,\n\t\t\t\"%s: packet-size of %u too big (limit is %u bytes)\",\n\t\t\t__func__, max_packet, MAX3421_FIFO_SIZE);\n\t\tmax3421_hcd->urb_done = -EMSGSIZE;\n\t\treturn -EMSGSIZE;\n\t}\n\tmax3421_hcd->curr_len = min((urb->transfer_buffer_length -\n\t\t\t\t     urb->actual_length), max_packet);\n\n\tspi_wr_buf(hcd, MAX3421_REG_SNDFIFO, src, max3421_hcd->curr_len);\n\tspi_wr8(hcd, MAX3421_REG_SNDBC, max3421_hcd->curr_len);\n\treturn MAX3421_HXFR_BULK_OUT(epnum);\n}\n\n/*\n * Issue the next host-transfer command.\n * Caller must NOT hold HCD spinlock.\n */\nstatic void\nmax3421_next_transfer(struct usb_hcd *hcd, int fast_retransmit)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tstruct urb *urb = max3421_hcd->curr_urb;\n\tstruct max3421_ep *max3421_ep;\n\tint cmd = -EINVAL;\n\n\tif (!urb)\n\t\treturn;\t/* nothing to do */\n\n\tmax3421_ep = urb->ep->hcpriv;\n\n\tswitch (max3421_ep->pkt_state) {\n\tcase PKT_STATE_SETUP:\n\t\tcmd = max3421_ctrl_setup(hcd, urb);\n\t\tbreak;\n\n\tcase PKT_STATE_TRANSFER:\n\t\tif (usb_urb_dir_in(urb))\n\t\t\tcmd = max3421_transfer_in(hcd, urb);\n\t\telse\n\t\t\tcmd = max3421_transfer_out(hcd, urb, fast_retransmit);\n\t\tbreak;\n\n\tcase PKT_STATE_TERMINATE:\n\t\t/*\n\t\t * IN transfers are terminated with HS_OUT token,\n\t\t * OUT transfers with HS_IN:\n\t\t */\n\t\tif (usb_urb_dir_in(urb))\n\t\t\tcmd = MAX3421_HXFR_HS_OUT;\n\t\telse\n\t\t\tcmd = MAX3421_HXFR_HS_IN;\n\t\tbreak;\n\t}\n\n\tif (cmd < 0)\n\t\treturn;\n\n\t/* issue the command and wait for host-xfer-done interrupt: */\n\n\tspi_wr8(hcd, MAX3421_REG_HXFR, cmd);\n\tmax3421_hcd->hien |= BIT(MAX3421_HI_HXFRDN_BIT);\n}\n\n/*\n * Find the next URB to process and start its execution.\n *\n * At this time, we do not anticipate ever connecting a USB hub to the\n * MAX3421 chip, so at most USB device can be connected and we can use\n * a simplistic scheduler: at the start of a frame, schedule all\n * periodic transfers.  Once that is done, use the remainder of the\n * frame to process non-periodic (bulk & control) transfers.\n *\n * Preconditions:\n * o Caller must NOT hold HCD spinlock.\n * o max3421_hcd->curr_urb MUST BE NULL.\n * o MAX3421E chip must be idle.\n */\nstatic int\nmax3421_select_and_start_urb(struct usb_hcd *hcd)\n{\n\tstruct spi_device *spi = to_spi_device(hcd->self.controller);\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tstruct urb *urb, *curr_urb = NULL;\n\tstruct max3421_ep *max3421_ep;\n\tint epnum;\n\tstruct usb_host_endpoint *ep;\n\tstruct list_head *pos;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&max3421_hcd->lock, flags);\n\n\tfor (;\n\t     max3421_hcd->sched_pass < SCHED_PASS_DONE;\n\t     ++max3421_hcd->sched_pass)\n\t\tlist_for_each(pos, &max3421_hcd->ep_list) {\n\t\t\turb = NULL;\n\t\t\tmax3421_ep = container_of(pos, struct max3421_ep,\n\t\t\t\t\t\t  ep_list);\n\t\t\tep = max3421_ep->ep;\n\n\t\t\tswitch (usb_endpoint_type(&ep->desc)) {\n\t\t\tcase USB_ENDPOINT_XFER_ISOC:\n\t\t\tcase USB_ENDPOINT_XFER_INT:\n\t\t\t\tif (max3421_hcd->sched_pass !=\n\t\t\t\t    SCHED_PASS_PERIODIC)\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\n\t\t\tcase USB_ENDPOINT_XFER_CONTROL:\n\t\t\tcase USB_ENDPOINT_XFER_BULK:\n\t\t\t\tif (max3421_hcd->sched_pass !=\n\t\t\t\t    SCHED_PASS_NON_PERIODIC)\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (list_empty(&ep->urb_list))\n\t\t\t\tcontinue;\t/* nothing to do */\n\t\t\turb = list_first_entry(&ep->urb_list, struct urb,\n\t\t\t\t\t       urb_list);\n\t\t\tif (urb->unlinked) {\n\t\t\t\tdev_dbg(&spi->dev, \"%s: URB %p unlinked=%d\",\n\t\t\t\t\t__func__, urb, urb->unlinked);\n\t\t\t\tmax3421_hcd->curr_urb = urb;\n\t\t\t\tmax3421_hcd->urb_done = 1;\n\t\t\t\tspin_unlock_irqrestore(&max3421_hcd->lock,\n\t\t\t\t\t\t       flags);\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tswitch (usb_endpoint_type(&ep->desc)) {\n\t\t\tcase USB_ENDPOINT_XFER_CONTROL:\n\t\t\t\t/*\n\t\t\t\t * Allow one control transaction per\n\t\t\t\t * frame per endpoint:\n\t\t\t\t */\n\t\t\t\tif (frame_diff(max3421_ep->last_active,\n\t\t\t\t\t       max3421_hcd->frame_number) == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\n\t\t\tcase USB_ENDPOINT_XFER_BULK:\n\t\t\t\tif (max3421_ep->retransmit\n\t\t\t\t    && (frame_diff(max3421_ep->last_active,\n\t\t\t\t\t\t   max3421_hcd->frame_number)\n\t\t\t\t\t== 0))\n\t\t\t\t\t/*\n\t\t\t\t\t * We already tried this EP\n\t\t\t\t\t * during this frame and got a\n\t\t\t\t\t * NAK or error; wait for next frame\n\t\t\t\t\t */\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\n\t\t\tcase USB_ENDPOINT_XFER_ISOC:\n\t\t\tcase USB_ENDPOINT_XFER_INT:\n\t\t\t\tif (frame_diff(max3421_hcd->frame_number,\n\t\t\t\t\t       max3421_ep->last_active)\n\t\t\t\t    < urb->interval)\n\t\t\t\t\t/*\n\t\t\t\t\t * We already processed this\n\t\t\t\t\t * end-point in the current\n\t\t\t\t\t * frame\n\t\t\t\t\t */\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* move current ep to tail: */\n\t\t\tlist_move_tail(pos, &max3421_hcd->ep_list);\n\t\t\tcurr_urb = urb;\n\t\t\tgoto done;\n\t\t}\ndone:\n\tif (!curr_urb) {\n\t\tspin_unlock_irqrestore(&max3421_hcd->lock, flags);\n\t\treturn 0;\n\t}\n\n\turb = max3421_hcd->curr_urb = curr_urb;\n\tepnum = usb_endpoint_num(&urb->ep->desc);\n\tif (max3421_ep->retransmit)\n\t\t/* restart (part of) a USB transaction: */\n\t\tmax3421_ep->retransmit = 0;\n\telse {\n\t\t/* start USB transaction: */\n\t\tif (usb_endpoint_xfer_control(&ep->desc)) {\n\t\t\t/*\n\t\t\t * See USB 2.0 spec section 8.6.1\n\t\t\t * Initialization via SETUP Token:\n\t\t\t */\n\t\t\tusb_settoggle(urb->dev, epnum, 0, 1);\n\t\t\tusb_settoggle(urb->dev, epnum, 1, 1);\n\t\t\tmax3421_ep->pkt_state = PKT_STATE_SETUP;\n\t\t} else\n\t\t\tmax3421_ep->pkt_state = PKT_STATE_TRANSFER;\n\t}\n\n\tspin_unlock_irqrestore(&max3421_hcd->lock, flags);\n\n\tmax3421_ep->last_active = max3421_hcd->frame_number;\n\tmax3421_set_address(hcd, urb->dev, epnum);\n\tmax3421_set_speed(hcd, urb->dev);\n\tmax3421_next_transfer(hcd, 0);\n\treturn 1;\n}\n\n/*\n * Check all endpoints for URBs that got unlinked.\n *\n * Caller must NOT hold HCD spinlock.\n */\nstatic int\nmax3421_check_unlink(struct usb_hcd *hcd)\n{\n\tstruct spi_device *spi = to_spi_device(hcd->self.controller);\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tstruct max3421_ep *max3421_ep;\n\tstruct usb_host_endpoint *ep;\n\tstruct urb *urb, *next;\n\tunsigned long flags;\n\tint retval = 0;\n\n\tspin_lock_irqsave(&max3421_hcd->lock, flags);\n\tlist_for_each_entry(max3421_ep, &max3421_hcd->ep_list, ep_list) {\n\t\tep = max3421_ep->ep;\n\t\tlist_for_each_entry_safe(urb, next, &ep->urb_list, urb_list) {\n\t\t\tif (urb->unlinked) {\n\t\t\t\tretval = 1;\n\t\t\t\tdev_dbg(&spi->dev, \"%s: URB %p unlinked=%d\",\n\t\t\t\t\t__func__, urb, urb->unlinked);\n\t\t\t\tusb_hcd_unlink_urb_from_ep(hcd, urb);\n\t\t\t\tspin_unlock_irqrestore(&max3421_hcd->lock,\n\t\t\t\t\t\t       flags);\n\t\t\t\tusb_hcd_giveback_urb(hcd, urb, 0);\n\t\t\t\tspin_lock_irqsave(&max3421_hcd->lock, flags);\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&max3421_hcd->lock, flags);\n\treturn retval;\n}\n\n/*\n * Caller must NOT hold HCD spinlock.\n */\nstatic void\nmax3421_slow_retransmit(struct usb_hcd *hcd)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tstruct urb *urb = max3421_hcd->curr_urb;\n\tstruct max3421_ep *max3421_ep;\n\n\tmax3421_ep = urb->ep->hcpriv;\n\tmax3421_ep->retransmit = 1;\n\tmax3421_hcd->curr_urb = NULL;\n}\n\n/*\n * Caller must NOT hold HCD spinlock.\n */\nstatic void\nmax3421_recv_data_available(struct usb_hcd *hcd)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tstruct urb *urb = max3421_hcd->curr_urb;\n\tsize_t remaining, transfer_size;\n\tu8 rcvbc;\n\n\trcvbc = spi_rd8(hcd, MAX3421_REG_RCVBC);\n\n\tif (rcvbc > MAX3421_FIFO_SIZE)\n\t\trcvbc = MAX3421_FIFO_SIZE;\n\tif (urb->actual_length >= urb->transfer_buffer_length)\n\t\tremaining = 0;\n\telse\n\t\tremaining = urb->transfer_buffer_length - urb->actual_length;\n\ttransfer_size = rcvbc;\n\tif (transfer_size > remaining)\n\t\ttransfer_size = remaining;\n\tif (transfer_size > 0) {\n\t\tvoid *dst = urb->transfer_buffer + urb->actual_length;\n\n\t\tspi_rd_buf(hcd, MAX3421_REG_RCVFIFO, dst, transfer_size);\n\t\turb->actual_length += transfer_size;\n\t\tmax3421_hcd->curr_len = transfer_size;\n\t}\n\n\t/* ack the RCVDAV irq now that the FIFO has been read: */\n\tspi_wr8(hcd, MAX3421_REG_HIRQ, BIT(MAX3421_HI_RCVDAV_BIT));\n}\n\nstatic void\nmax3421_handle_error(struct usb_hcd *hcd, u8 hrsl)\n{\n\tstruct spi_device *spi = to_spi_device(hcd->self.controller);\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tu8 result_code = hrsl & MAX3421_HRSL_RESULT_MASK;\n\tstruct urb *urb = max3421_hcd->curr_urb;\n\tstruct max3421_ep *max3421_ep = urb->ep->hcpriv;\n\tint switch_sndfifo;\n\n\t/*\n\t * If an OUT command results in any response other than OK\n\t * (i.e., error or NAK), we have to perform a dummy-write to\n\t * SNDBC so the FIFO gets switched back to us.  Otherwise, we\n\t * get out of sync with the SNDFIFO double buffer.\n\t */\n\tswitch_sndfifo = (max3421_ep->pkt_state == PKT_STATE_TRANSFER &&\n\t\t\t  usb_urb_dir_out(urb));\n\n\tswitch (result_code) {\n\tcase MAX3421_HRSL_OK:\n\t\treturn;\t\t\t/* this shouldn't happen */\n\n\tcase MAX3421_HRSL_WRONGPID:\t/* received wrong PID */\n\tcase MAX3421_HRSL_BUSY:\t\t/* SIE busy */\n\tcase MAX3421_HRSL_BADREQ:\t/* bad val in HXFR */\n\tcase MAX3421_HRSL_UNDEF:\t/* reserved */\n\tcase MAX3421_HRSL_KERR:\t\t/* K-state instead of response */\n\tcase MAX3421_HRSL_JERR:\t\t/* J-state instead of response */\n\t\t/*\n\t\t * packet experienced an error that we cannot recover\n\t\t * from; report error\n\t\t */\n\t\tmax3421_hcd->urb_done = hrsl_to_error[result_code];\n\t\tdev_dbg(&spi->dev, \"%s: unexpected error HRSL=0x%02x\",\n\t\t\t__func__, hrsl);\n\t\tbreak;\n\n\tcase MAX3421_HRSL_TOGERR:\n\t\tif (usb_urb_dir_in(urb))\n\t\t\t; /* don't do anything (device will switch toggle) */\n\t\telse {\n\t\t\t/* flip the send toggle bit: */\n\t\t\tint sndtog = (hrsl >> MAX3421_HRSL_SNDTOGRD_BIT) & 1;\n\n\t\t\tsndtog ^= 1;\n\t\t\tspi_wr8(hcd, MAX3421_REG_HCTL,\n\t\t\t\tBIT(sndtog + MAX3421_HCTL_SNDTOG0_BIT));\n\t\t}\n\t\tfallthrough;\n\tcase MAX3421_HRSL_BADBC:\t/* bad byte count */\n\tcase MAX3421_HRSL_PIDERR:\t/* received PID is corrupted */\n\tcase MAX3421_HRSL_PKTERR:\t/* packet error (stuff, EOP) */\n\tcase MAX3421_HRSL_CRCERR:\t/* CRC error */\n\tcase MAX3421_HRSL_BABBLE:\t/* device talked too long */\n\tcase MAX3421_HRSL_TIMEOUT:\n\t\tif (max3421_ep->retries++ < USB_MAX_RETRIES)\n\t\t\t/* retry the packet again in the next frame */\n\t\t\tmax3421_slow_retransmit(hcd);\n\t\telse {\n\t\t\t/* Based on ohci.h cc_to_err[]: */\n\t\t\tmax3421_hcd->urb_done = hrsl_to_error[result_code];\n\t\t\tdev_dbg(&spi->dev, \"%s: unexpected error HRSL=0x%02x\",\n\t\t\t\t__func__, hrsl);\n\t\t}\n\t\tbreak;\n\n\tcase MAX3421_HRSL_STALL:\n\t\tdev_dbg(&spi->dev, \"%s: unexpected error HRSL=0x%02x\",\n\t\t\t__func__, hrsl);\n\t\tmax3421_hcd->urb_done = hrsl_to_error[result_code];\n\t\tbreak;\n\n\tcase MAX3421_HRSL_NAK:\n\t\t/*\n\t\t * Device wasn't ready for data or has no data\n\t\t * available: retry the packet again.\n\t\t */\n\t\tif (max3421_ep->naks++ < NAK_MAX_FAST_RETRANSMITS) {\n\t\t\tmax3421_next_transfer(hcd, 1);\n\t\t\tswitch_sndfifo = 0;\n\t\t} else\n\t\t\tmax3421_slow_retransmit(hcd);\n\t\tbreak;\n\t}\n\tif (switch_sndfifo)\n\t\tspi_wr8(hcd, MAX3421_REG_SNDBC, 0);\n}\n\n/*\n * Caller must NOT hold HCD spinlock.\n */\nstatic int\nmax3421_transfer_in_done(struct usb_hcd *hcd, struct urb *urb)\n{\n\tstruct spi_device *spi = to_spi_device(hcd->self.controller);\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tu32 max_packet;\n\n\tif (urb->actual_length >= urb->transfer_buffer_length)\n\t\treturn 1;\t/* read is complete, so we're done */\n\n\t/*\n\t * USB 2.0 Section 5.3.2 Pipes: packets must be full size\n\t * except for last one.\n\t */\n\tmax_packet = usb_maxpacket(urb->dev, urb->pipe, 0);\n\tif (max_packet > MAX3421_FIFO_SIZE) {\n\t\t/*\n\t\t * We do not support isochronous transfers at this\n\t\t * time...\n\t\t */\n\t\tdev_err(&spi->dev,\n\t\t\t\"%s: packet-size of %u too big (limit is %u bytes)\",\n\t\t\t__func__, max_packet, MAX3421_FIFO_SIZE);\n\t\treturn -EINVAL;\n\t}\n\n\tif (max3421_hcd->curr_len < max_packet) {\n\t\tif (urb->transfer_flags & URB_SHORT_NOT_OK) {\n\t\t\t/*\n\t\t\t * remaining > 0 and received an\n\t\t\t * unexpected partial packet ->\n\t\t\t * error\n\t\t\t */\n\t\t\treturn -EREMOTEIO;\n\t\t} else\n\t\t\t/* short read, but it's OK */\n\t\t\treturn 1;\n\t}\n\treturn 0;\t/* not done */\n}\n\n/*\n * Caller must NOT hold HCD spinlock.\n */\nstatic int\nmax3421_transfer_out_done(struct usb_hcd *hcd, struct urb *urb)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\n\turb->actual_length += max3421_hcd->curr_len;\n\tif (urb->actual_length < urb->transfer_buffer_length)\n\t\treturn 0;\n\tif (urb->transfer_flags & URB_ZERO_PACKET) {\n\t\t/*\n\t\t * Some hardware needs a zero-size packet at the end\n\t\t * of a bulk-out transfer if the last transfer was a\n\t\t * full-sized packet (i.e., such hardware use <\n\t\t * max_packet as an indicator that the end of the\n\t\t * packet has been reached).\n\t\t */\n\t\tu32 max_packet = usb_maxpacket(urb->dev, urb->pipe, 1);\n\n\t\tif (max3421_hcd->curr_len == max_packet)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n/*\n * Caller must NOT hold HCD spinlock.\n */\nstatic void\nmax3421_host_transfer_done(struct usb_hcd *hcd)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tstruct urb *urb = max3421_hcd->curr_urb;\n\tstruct max3421_ep *max3421_ep;\n\tu8 result_code, hrsl;\n\tint urb_done = 0;\n\n\tmax3421_hcd->hien &= ~(BIT(MAX3421_HI_HXFRDN_BIT) |\n\t\t\t       BIT(MAX3421_HI_RCVDAV_BIT));\n\n\thrsl = spi_rd8(hcd, MAX3421_REG_HRSL);\n\tresult_code = hrsl & MAX3421_HRSL_RESULT_MASK;\n\n#ifdef DEBUG\n\t++max3421_hcd->err_stat[result_code];\n#endif\n\n\tmax3421_ep = urb->ep->hcpriv;\n\n\tif (unlikely(result_code != MAX3421_HRSL_OK)) {\n\t\tmax3421_handle_error(hcd, hrsl);\n\t\treturn;\n\t}\n\n\tmax3421_ep->naks = 0;\n\tmax3421_ep->retries = 0;\n\tswitch (max3421_ep->pkt_state) {\n\n\tcase PKT_STATE_SETUP:\n\t\tif (urb->transfer_buffer_length > 0)\n\t\t\tmax3421_ep->pkt_state = PKT_STATE_TRANSFER;\n\t\telse\n\t\t\tmax3421_ep->pkt_state = PKT_STATE_TERMINATE;\n\t\tbreak;\n\n\tcase PKT_STATE_TRANSFER:\n\t\tif (usb_urb_dir_in(urb))\n\t\t\turb_done = max3421_transfer_in_done(hcd, urb);\n\t\telse\n\t\t\turb_done = max3421_transfer_out_done(hcd, urb);\n\t\tif (urb_done > 0 && usb_pipetype(urb->pipe) == PIPE_CONTROL) {\n\t\t\t/*\n\t\t\t * We aren't really done - we still need to\n\t\t\t * terminate the control transfer:\n\t\t\t */\n\t\t\tmax3421_hcd->urb_done = urb_done = 0;\n\t\t\tmax3421_ep->pkt_state = PKT_STATE_TERMINATE;\n\t\t}\n\t\tbreak;\n\n\tcase PKT_STATE_TERMINATE:\n\t\turb_done = 1;\n\t\tbreak;\n\t}\n\n\tif (urb_done)\n\t\tmax3421_hcd->urb_done = urb_done;\n\telse\n\t\tmax3421_next_transfer(hcd, 0);\n}\n\n/*\n * Caller must NOT hold HCD spinlock.\n */\nstatic void\nmax3421_detect_conn(struct usb_hcd *hcd)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tunsigned int jk, have_conn = 0;\n\tu32 old_port_status, chg;\n\tunsigned long flags;\n\tu8 hrsl, mode;\n\n\thrsl = spi_rd8(hcd, MAX3421_REG_HRSL);\n\n\tjk = ((((hrsl >> MAX3421_HRSL_JSTATUS_BIT) & 1) << 0) |\n\t      (((hrsl >> MAX3421_HRSL_KSTATUS_BIT) & 1) << 1));\n\n\tmode = max3421_hcd->mode;\n\n\tswitch (jk) {\n\tcase 0x0: /* SE0: disconnect */\n\t\t/*\n\t\t * Turn off SOFKAENAB bit to avoid getting interrupt\n\t\t * every milli-second:\n\t\t */\n\t\tmode &= ~BIT(MAX3421_MODE_SOFKAENAB_BIT);\n\t\tbreak;\n\n\tcase 0x1: /* J=0,K=1: low-speed (in full-speed or vice versa) */\n\tcase 0x2: /* J=1,K=0: full-speed (in full-speed or vice versa) */\n\t\tif (jk == 0x2)\n\t\t\t/* need to switch to the other speed: */\n\t\t\tmode ^= BIT(MAX3421_MODE_LOWSPEED_BIT);\n\t\t/* turn on SOFKAENAB bit: */\n\t\tmode |= BIT(MAX3421_MODE_SOFKAENAB_BIT);\n\t\thave_conn = 1;\n\t\tbreak;\n\n\tcase 0x3: /* illegal */\n\t\tbreak;\n\t}\n\n\tmax3421_hcd->mode = mode;\n\tspi_wr8(hcd, MAX3421_REG_MODE, max3421_hcd->mode);\n\n\tspin_lock_irqsave(&max3421_hcd->lock, flags);\n\told_port_status = max3421_hcd->port_status;\n\tif (have_conn)\n\t\tmax3421_hcd->port_status |=  USB_PORT_STAT_CONNECTION;\n\telse\n\t\tmax3421_hcd->port_status &= ~USB_PORT_STAT_CONNECTION;\n\tif (mode & BIT(MAX3421_MODE_LOWSPEED_BIT))\n\t\tmax3421_hcd->port_status |=  USB_PORT_STAT_LOW_SPEED;\n\telse\n\t\tmax3421_hcd->port_status &= ~USB_PORT_STAT_LOW_SPEED;\n\tchg = (old_port_status ^ max3421_hcd->port_status);\n\tmax3421_hcd->port_status |= chg << 16;\n\tspin_unlock_irqrestore(&max3421_hcd->lock, flags);\n}\n\nstatic irqreturn_t\nmax3421_irq_handler(int irq, void *dev_id)\n{\n\tstruct usb_hcd *hcd = dev_id;\n\tstruct spi_device *spi = to_spi_device(hcd->self.controller);\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\n\tif (max3421_hcd->spi_thread)\n\t\twake_up_process(max3421_hcd->spi_thread);\n\tif (!test_and_set_bit(ENABLE_IRQ, &max3421_hcd->todo))\n\t\tdisable_irq_nosync(spi->irq);\n\treturn IRQ_HANDLED;\n}\n\n#ifdef DEBUG\n\nstatic void\ndump_eps(struct usb_hcd *hcd)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tstruct max3421_ep *max3421_ep;\n\tstruct usb_host_endpoint *ep;\n\tchar ubuf[512], *dp, *end;\n\tunsigned long flags;\n\tstruct urb *urb;\n\tint epnum, ret;\n\n\tspin_lock_irqsave(&max3421_hcd->lock, flags);\n\tlist_for_each_entry(max3421_ep, &max3421_hcd->ep_list, ep_list) {\n\t\tep = max3421_ep->ep;\n\n\t\tdp = ubuf;\n\t\tend = dp + sizeof(ubuf);\n\t\t*dp = '\\0';\n\t\tlist_for_each_entry(urb, &ep->urb_list, urb_list) {\n\t\t\tret = snprintf(dp, end - dp, \" %p(%d.%s %d/%d)\", urb,\n\t\t\t\t       usb_pipetype(urb->pipe),\n\t\t\t\t       usb_urb_dir_in(urb) ? \"IN\" : \"OUT\",\n\t\t\t\t       urb->actual_length,\n\t\t\t\t       urb->transfer_buffer_length);\n\t\t\tif (ret < 0 || ret >= end - dp)\n\t\t\t\tbreak;\t/* error or buffer full */\n\t\t\tdp += ret;\n\t\t}\n\n\t\tepnum = usb_endpoint_num(&ep->desc);\n\t\tpr_info(\"EP%0u %u lst %04u rtr %u nak %6u rxmt %u: %s\\n\",\n\t\t\tepnum, max3421_ep->pkt_state, max3421_ep->last_active,\n\t\t\tmax3421_ep->retries, max3421_ep->naks,\n\t\t\tmax3421_ep->retransmit, ubuf);\n\t}\n\tspin_unlock_irqrestore(&max3421_hcd->lock, flags);\n}\n\n#endif /* DEBUG */\n\n/* Return zero if no work was performed, 1 otherwise.  */\nstatic int\nmax3421_handle_irqs(struct usb_hcd *hcd)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tu32 chg, old_port_status;\n\tunsigned long flags;\n\tu8 hirq;\n\n\t/*\n\t * Read and ack pending interrupts (CPU must never\n\t * clear SNDBAV directly and RCVDAV must be cleared by\n\t * max3421_recv_data_available()!):\n\t */\n\thirq = spi_rd8(hcd, MAX3421_REG_HIRQ);\n\thirq &= max3421_hcd->hien;\n\tif (!hirq)\n\t\treturn 0;\n\n\tspi_wr8(hcd, MAX3421_REG_HIRQ,\n\t\thirq & ~(BIT(MAX3421_HI_SNDBAV_BIT) |\n\t\t\t BIT(MAX3421_HI_RCVDAV_BIT)));\n\n\tif (hirq & BIT(MAX3421_HI_FRAME_BIT)) {\n\t\tmax3421_hcd->frame_number = ((max3421_hcd->frame_number + 1)\n\t\t\t\t\t     & USB_MAX_FRAME_NUMBER);\n\t\tmax3421_hcd->sched_pass = SCHED_PASS_PERIODIC;\n\t}\n\n\tif (hirq & BIT(MAX3421_HI_RCVDAV_BIT))\n\t\tmax3421_recv_data_available(hcd);\n\n\tif (hirq & BIT(MAX3421_HI_HXFRDN_BIT))\n\t\tmax3421_host_transfer_done(hcd);\n\n\tif (hirq & BIT(MAX3421_HI_CONDET_BIT))\n\t\tmax3421_detect_conn(hcd);\n\n\t/*\n\t * Now process interrupts that may affect HCD state\n\t * other than the end-points:\n\t */\n\tspin_lock_irqsave(&max3421_hcd->lock, flags);\n\n\told_port_status = max3421_hcd->port_status;\n\tif (hirq & BIT(MAX3421_HI_BUSEVENT_BIT)) {\n\t\tif (max3421_hcd->port_status & USB_PORT_STAT_RESET) {\n\t\t\t/* BUSEVENT due to completion of Bus Reset */\n\t\t\tmax3421_hcd->port_status &= ~USB_PORT_STAT_RESET;\n\t\t\tmax3421_hcd->port_status |=  USB_PORT_STAT_ENABLE;\n\t\t} else {\n\t\t\t/* BUSEVENT due to completion of Bus Resume */\n\t\t\tpr_info(\"%s: BUSEVENT Bus Resume Done\\n\", __func__);\n\t\t}\n\t}\n\tif (hirq & BIT(MAX3421_HI_RWU_BIT))\n\t\tpr_info(\"%s: RWU\\n\", __func__);\n\tif (hirq & BIT(MAX3421_HI_SUSDN_BIT))\n\t\tpr_info(\"%s: SUSDN\\n\", __func__);\n\n\tchg = (old_port_status ^ max3421_hcd->port_status);\n\tmax3421_hcd->port_status |= chg << 16;\n\n\tspin_unlock_irqrestore(&max3421_hcd->lock, flags);\n\n#ifdef DEBUG\n\t{\n\t\tstatic unsigned long last_time;\n\t\tchar sbuf[16 * 16], *dp, *end;\n\t\tint i;\n\n\t\tif (time_after(jiffies, last_time + 5*HZ)) {\n\t\t\tdp = sbuf;\n\t\t\tend = sbuf + sizeof(sbuf);\n\t\t\t*dp = '\\0';\n\t\t\tfor (i = 0; i < 16; ++i) {\n\t\t\t\tint ret = snprintf(dp, end - dp, \" %lu\",\n\t\t\t\t\t\t   max3421_hcd->err_stat[i]);\n\t\t\t\tif (ret < 0 || ret >= end - dp)\n\t\t\t\t\tbreak;\t/* error or buffer full */\n\t\t\t\tdp += ret;\n\t\t\t}\n\t\t\tpr_info(\"%s: hrsl_stats %s\\n\", __func__, sbuf);\n\t\t\tmemset(max3421_hcd->err_stat, 0,\n\t\t\t       sizeof(max3421_hcd->err_stat));\n\t\t\tlast_time = jiffies;\n\n\t\t\tdump_eps(hcd);\n\t\t}\n\t}\n#endif\n\treturn 1;\n}\n\nstatic int\nmax3421_reset_hcd(struct usb_hcd *hcd)\n{\n\tstruct spi_device *spi = to_spi_device(hcd->self.controller);\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tint timeout;\n\n\t/* perform a chip reset and wait for OSCIRQ signal to appear: */\n\tspi_wr8(hcd, MAX3421_REG_USBCTL, BIT(MAX3421_USBCTL_CHIPRES_BIT));\n\t/* clear reset: */\n\tspi_wr8(hcd, MAX3421_REG_USBCTL, 0);\n\ttimeout = 1000;\n\twhile (1) {\n\t\tif (spi_rd8(hcd, MAX3421_REG_USBIRQ)\n\t\t    & BIT(MAX3421_USBIRQ_OSCOKIRQ_BIT))\n\t\t\tbreak;\n\t\tif (--timeout < 0) {\n\t\t\tdev_err(&spi->dev,\n\t\t\t\t\"timed out waiting for oscillator OK signal\");\n\t\t\treturn 1;\n\t\t}\n\t\tcond_resched();\n\t}\n\n\t/*\n\t * Turn on host mode, automatic generation of SOF packets, and\n\t * enable pull-down registers on DM/DP:\n\t */\n\tmax3421_hcd->mode = (BIT(MAX3421_MODE_HOST_BIT) |\n\t\t\t     BIT(MAX3421_MODE_SOFKAENAB_BIT) |\n\t\t\t     BIT(MAX3421_MODE_DMPULLDN_BIT) |\n\t\t\t     BIT(MAX3421_MODE_DPPULLDN_BIT));\n\tspi_wr8(hcd, MAX3421_REG_MODE, max3421_hcd->mode);\n\n\t/* reset frame-number: */\n\tmax3421_hcd->frame_number = USB_MAX_FRAME_NUMBER;\n\tspi_wr8(hcd, MAX3421_REG_HCTL, BIT(MAX3421_HCTL_FRMRST_BIT));\n\n\t/* sample the state of the D+ and D- lines */\n\tspi_wr8(hcd, MAX3421_REG_HCTL, BIT(MAX3421_HCTL_SAMPLEBUS_BIT));\n\tmax3421_detect_conn(hcd);\n\n\t/* enable frame, connection-detected, and bus-event interrupts: */\n\tmax3421_hcd->hien = (BIT(MAX3421_HI_FRAME_BIT) |\n\t\t\t     BIT(MAX3421_HI_CONDET_BIT) |\n\t\t\t     BIT(MAX3421_HI_BUSEVENT_BIT));\n\tspi_wr8(hcd, MAX3421_REG_HIEN, max3421_hcd->hien);\n\n\t/* enable interrupts: */\n\tspi_wr8(hcd, MAX3421_REG_CPUCTL, BIT(MAX3421_CPUCTL_IE_BIT));\n\treturn 1;\n}\n\nstatic int\nmax3421_urb_done(struct usb_hcd *hcd)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tunsigned long flags;\n\tstruct urb *urb;\n\tint status;\n\n\tstatus = max3421_hcd->urb_done;\n\tmax3421_hcd->urb_done = 0;\n\tif (status > 0)\n\t\tstatus = 0;\n\turb = max3421_hcd->curr_urb;\n\tif (urb) {\n\t\t/* save the old end-points toggles: */\n\t\tu8 hrsl = spi_rd8(hcd, MAX3421_REG_HRSL);\n\t\tint rcvtog = (hrsl >> MAX3421_HRSL_RCVTOGRD_BIT) & 1;\n\t\tint sndtog = (hrsl >> MAX3421_HRSL_SNDTOGRD_BIT) & 1;\n\t\tint epnum = usb_endpoint_num(&urb->ep->desc);\n\n\t\t/* no locking: HCD (i.e., we) own toggles, don't we? */\n\t\tusb_settoggle(urb->dev, epnum, 0, rcvtog);\n\t\tusb_settoggle(urb->dev, epnum, 1, sndtog);\n\n\t\tmax3421_hcd->curr_urb = NULL;\n\t\tspin_lock_irqsave(&max3421_hcd->lock, flags);\n\t\tusb_hcd_unlink_urb_from_ep(hcd, urb);\n\t\tspin_unlock_irqrestore(&max3421_hcd->lock, flags);\n\n\t\t/* must be called without the HCD spinlock: */\n\t\tusb_hcd_giveback_urb(hcd, urb, status);\n\t}\n\treturn 1;\n}\n\nstatic int\nmax3421_spi_thread(void *dev_id)\n{\n\tstruct usb_hcd *hcd = dev_id;\n\tstruct spi_device *spi = to_spi_device(hcd->self.controller);\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tint i, i_worked = 1;\n\n\t/* set full-duplex SPI mode, low-active interrupt pin: */\n\tspi_wr8(hcd, MAX3421_REG_PINCTL,\n\t\t(BIT(MAX3421_PINCTL_FDUPSPI_BIT) |\t/* full-duplex */\n\t\t BIT(MAX3421_PINCTL_INTLEVEL_BIT)));\t/* low-active irq */\n\n\twhile (!kthread_should_stop()) {\n\t\tmax3421_hcd->rev = spi_rd8(hcd, MAX3421_REG_REVISION);\n\t\tif (max3421_hcd->rev == 0x12 || max3421_hcd->rev == 0x13)\n\t\t\tbreak;\n\t\tdev_err(&spi->dev, \"bad rev 0x%02x\", max3421_hcd->rev);\n\t\tmsleep(10000);\n\t}\n\tdev_info(&spi->dev, \"rev 0x%x, SPI clk %dHz, bpw %u, irq %d\\n\",\n\t\t max3421_hcd->rev, spi->max_speed_hz, spi->bits_per_word,\n\t\t spi->irq);\n\n\twhile (!kthread_should_stop()) {\n\t\tif (!i_worked) {\n\t\t\t/*\n\t\t\t * We'll be waiting for wakeups from the hard\n\t\t\t * interrupt handler, so now is a good time to\n\t\t\t * sync our hien with the chip:\n\t\t\t */\n\t\t\tspi_wr8(hcd, MAX3421_REG_HIEN, max3421_hcd->hien);\n\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tif (test_and_clear_bit(ENABLE_IRQ, &max3421_hcd->todo))\n\t\t\t\tenable_irq(spi->irq);\n\t\t\tschedule();\n\t\t\t__set_current_state(TASK_RUNNING);\n\t\t}\n\n\t\ti_worked = 0;\n\n\t\tif (max3421_hcd->urb_done)\n\t\t\ti_worked |= max3421_urb_done(hcd);\n\t\telse if (max3421_handle_irqs(hcd))\n\t\t\ti_worked = 1;\n\t\telse if (!max3421_hcd->curr_urb)\n\t\t\ti_worked |= max3421_select_and_start_urb(hcd);\n\n\t\tif (test_and_clear_bit(RESET_HCD, &max3421_hcd->todo))\n\t\t\t/* reset the HCD: */\n\t\t\ti_worked |= max3421_reset_hcd(hcd);\n\t\tif (test_and_clear_bit(RESET_PORT, &max3421_hcd->todo)) {\n\t\t\t/* perform a USB bus reset: */\n\t\t\tspi_wr8(hcd, MAX3421_REG_HCTL,\n\t\t\t\tBIT(MAX3421_HCTL_BUSRST_BIT));\n\t\t\ti_worked = 1;\n\t\t}\n\t\tif (test_and_clear_bit(CHECK_UNLINK, &max3421_hcd->todo))\n\t\t\ti_worked |= max3421_check_unlink(hcd);\n\t\tif (test_and_clear_bit(IOPIN_UPDATE, &max3421_hcd->todo)) {\n\t\t\t/*\n\t\t\t * IOPINS1/IOPINS2 do not auto-increment, so we can't\n\t\t\t * use spi_wr_buf().\n\t\t\t */\n\t\t\tfor (i = 0; i < ARRAY_SIZE(max3421_hcd->iopins); ++i) {\n\t\t\t\tu8 val = spi_rd8(hcd, MAX3421_REG_IOPINS1);\n\n\t\t\t\tval = ((val & 0xf0) |\n\t\t\t\t       (max3421_hcd->iopins[i] & 0x0f));\n\t\t\t\tspi_wr8(hcd, MAX3421_REG_IOPINS1 + i, val);\n\t\t\t\tmax3421_hcd->iopins[i] = val;\n\t\t\t}\n\t\t\ti_worked = 1;\n\t\t}\n\t}\n\tset_current_state(TASK_RUNNING);\n\tdev_info(&spi->dev, \"SPI thread exiting\");\n\treturn 0;\n}\n\nstatic int\nmax3421_reset_port(struct usb_hcd *hcd)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\n\tmax3421_hcd->port_status &= ~(USB_PORT_STAT_ENABLE |\n\t\t\t\t      USB_PORT_STAT_LOW_SPEED);\n\tmax3421_hcd->port_status |= USB_PORT_STAT_RESET;\n\tset_bit(RESET_PORT, &max3421_hcd->todo);\n\twake_up_process(max3421_hcd->spi_thread);\n\treturn 0;\n}\n\nstatic int\nmax3421_reset(struct usb_hcd *hcd)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\n\thcd->self.sg_tablesize = 0;\n\thcd->speed = HCD_USB2;\n\thcd->self.root_hub->speed = USB_SPEED_FULL;\n\tset_bit(RESET_HCD, &max3421_hcd->todo);\n\twake_up_process(max3421_hcd->spi_thread);\n\treturn 0;\n}\n\nstatic int\nmax3421_start(struct usb_hcd *hcd)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\n\tspin_lock_init(&max3421_hcd->lock);\n\tmax3421_hcd->rh_state = MAX3421_RH_RUNNING;\n\n\tINIT_LIST_HEAD(&max3421_hcd->ep_list);\n\n\thcd->power_budget = POWER_BUDGET;\n\thcd->state = HC_STATE_RUNNING;\n\thcd->uses_new_polling = 1;\n\treturn 0;\n}\n\nstatic void\nmax3421_stop(struct usb_hcd *hcd)\n{\n}\n\nstatic int\nmax3421_urb_enqueue(struct usb_hcd *hcd, struct urb *urb, gfp_t mem_flags)\n{\n\tstruct spi_device *spi = to_spi_device(hcd->self.controller);\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tstruct max3421_ep *max3421_ep;\n\tunsigned long flags;\n\tint retval;\n\n\tswitch (usb_pipetype(urb->pipe)) {\n\tcase PIPE_INTERRUPT:\n\tcase PIPE_ISOCHRONOUS:\n\t\tif (urb->interval < 0) {\n\t\t\tdev_err(&spi->dev,\n\t\t\t  \"%s: interval=%d for intr-/iso-pipe; expected > 0\\n\",\n\t\t\t\t__func__, urb->interval);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tspin_lock_irqsave(&max3421_hcd->lock, flags);\n\n\tmax3421_ep = urb->ep->hcpriv;\n\tif (!max3421_ep) {\n\t\t/* gets freed in max3421_endpoint_disable: */\n\t\tmax3421_ep = kzalloc(sizeof(struct max3421_ep), GFP_ATOMIC);\n\t\tif (!max3421_ep) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tmax3421_ep->ep = urb->ep;\n\t\tmax3421_ep->last_active = max3421_hcd->frame_number;\n\t\turb->ep->hcpriv = max3421_ep;\n\n\t\tlist_add_tail(&max3421_ep->ep_list, &max3421_hcd->ep_list);\n\t}\n\n\tretval = usb_hcd_link_urb_to_ep(hcd, urb);\n\tif (retval == 0) {\n\t\t/* Since we added to the queue, restart scheduling: */\n\t\tmax3421_hcd->sched_pass = SCHED_PASS_PERIODIC;\n\t\twake_up_process(max3421_hcd->spi_thread);\n\t}\n\nout:\n\tspin_unlock_irqrestore(&max3421_hcd->lock, flags);\n\treturn retval;\n}\n\nstatic int\nmax3421_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tunsigned long flags;\n\tint retval;\n\n\tspin_lock_irqsave(&max3421_hcd->lock, flags);\n\n\t/*\n\t * This will set urb->unlinked which in turn causes the entry\n\t * to be dropped at the next opportunity.\n\t */\n\tretval = usb_hcd_check_unlink_urb(hcd, urb, status);\n\tif (retval == 0) {\n\t\tset_bit(CHECK_UNLINK, &max3421_hcd->todo);\n\t\twake_up_process(max3421_hcd->spi_thread);\n\t}\n\tspin_unlock_irqrestore(&max3421_hcd->lock, flags);\n\treturn retval;\n}\n\nstatic void\nmax3421_endpoint_disable(struct usb_hcd *hcd, struct usb_host_endpoint *ep)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&max3421_hcd->lock, flags);\n\n\tif (ep->hcpriv) {\n\t\tstruct max3421_ep *max3421_ep = ep->hcpriv;\n\n\t\t/* remove myself from the ep_list: */\n\t\tif (!list_empty(&max3421_ep->ep_list))\n\t\t\tlist_del(&max3421_ep->ep_list);\n\t\tkfree(max3421_ep);\n\t\tep->hcpriv = NULL;\n\t}\n\n\tspin_unlock_irqrestore(&max3421_hcd->lock, flags);\n}\n\nstatic int\nmax3421_get_frame_number(struct usb_hcd *hcd)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\treturn max3421_hcd->frame_number;\n}\n\n/*\n * Should return a non-zero value when any port is undergoing a resume\n * transition while the root hub is suspended.\n */\nstatic int\nmax3421_hub_status_data(struct usb_hcd *hcd, char *buf)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tunsigned long flags;\n\tint retval = 0;\n\n\tspin_lock_irqsave(&max3421_hcd->lock, flags);\n\tif (!HCD_HW_ACCESSIBLE(hcd))\n\t\tgoto done;\n\n\t*buf = 0;\n\tif ((max3421_hcd->port_status & PORT_C_MASK) != 0) {\n\t\t*buf = (1 << 1); /* a hub over-current condition exists */\n\t\tdev_dbg(hcd->self.controller,\n\t\t\t\"port status 0x%08x has changes\\n\",\n\t\t\tmax3421_hcd->port_status);\n\t\tretval = 1;\n\t\tif (max3421_hcd->rh_state == MAX3421_RH_SUSPENDED)\n\t\t\tusb_hcd_resume_root_hub(hcd);\n\t}\ndone:\n\tspin_unlock_irqrestore(&max3421_hcd->lock, flags);\n\treturn retval;\n}\n\nstatic inline void\nhub_descriptor(struct usb_hub_descriptor *desc)\n{\n\tmemset(desc, 0, sizeof(*desc));\n\t/*\n\t * See Table 11-13: Hub Descriptor in USB 2.0 spec.\n\t */\n\tdesc->bDescriptorType = USB_DT_HUB; /* hub descriptor */\n\tdesc->bDescLength = 9;\n\tdesc->wHubCharacteristics = cpu_to_le16(HUB_CHAR_INDV_PORT_LPSM |\n\t\t\t\t\t\tHUB_CHAR_COMMON_OCPM);\n\tdesc->bNbrPorts = 1;\n}\n\n/*\n * Set the MAX3421E general-purpose output with number PIN_NUMBER to\n * VALUE (0 or 1).  PIN_NUMBER may be in the range from 1-8.  For\n * any other value, this function acts as a no-op.\n */\nstatic void\nmax3421_gpout_set_value(struct usb_hcd *hcd, u8 pin_number, u8 value)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tu8 mask, idx;\n\n\t--pin_number;\n\tif (pin_number >= MAX3421_GPOUT_COUNT)\n\t\treturn;\n\n\tmask = 1u << (pin_number % 4);\n\tidx = pin_number / 4;\n\n\tif (value)\n\t\tmax3421_hcd->iopins[idx] |=  mask;\n\telse\n\t\tmax3421_hcd->iopins[idx] &= ~mask;\n\tset_bit(IOPIN_UPDATE, &max3421_hcd->todo);\n\twake_up_process(max3421_hcd->spi_thread);\n}\n\nstatic int\nmax3421_hub_control(struct usb_hcd *hcd, u16 type_req, u16 value, u16 index,\n\t\t    char *buf, u16 length)\n{\n\tstruct spi_device *spi = to_spi_device(hcd->self.controller);\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tstruct max3421_hcd_platform_data *pdata;\n\tunsigned long flags;\n\tint retval = 0;\n\n\tpdata = spi->dev.platform_data;\n\n\tspin_lock_irqsave(&max3421_hcd->lock, flags);\n\n\tswitch (type_req) {\n\tcase ClearHubFeature:\n\t\tbreak;\n\tcase ClearPortFeature:\n\t\tswitch (value) {\n\t\tcase USB_PORT_FEAT_SUSPEND:\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_POWER:\n\t\t\tdev_dbg(hcd->self.controller, \"power-off\\n\");\n\t\t\tmax3421_gpout_set_value(hcd, pdata->vbus_gpout,\n\t\t\t\t\t\t!pdata->vbus_active_level);\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tmax3421_hcd->port_status &= ~(1 << value);\n\t\t}\n\t\tbreak;\n\tcase GetHubDescriptor:\n\t\thub_descriptor((struct usb_hub_descriptor *) buf);\n\t\tbreak;\n\n\tcase DeviceRequest | USB_REQ_GET_DESCRIPTOR:\n\tcase GetPortErrorCount:\n\tcase SetHubDepth:\n\t\t/* USB3 only */\n\t\tgoto error;\n\n\tcase GetHubStatus:\n\t\t*(__le32 *) buf = cpu_to_le32(0);\n\t\tbreak;\n\n\tcase GetPortStatus:\n\t\tif (index != 1) {\n\t\t\tretval = -EPIPE;\n\t\t\tgoto error;\n\t\t}\n\t\t((__le16 *) buf)[0] = cpu_to_le16(max3421_hcd->port_status);\n\t\t((__le16 *) buf)[1] =\n\t\t\tcpu_to_le16(max3421_hcd->port_status >> 16);\n\t\tbreak;\n\n\tcase SetHubFeature:\n\t\tretval = -EPIPE;\n\t\tbreak;\n\n\tcase SetPortFeature:\n\t\tswitch (value) {\n\t\tcase USB_PORT_FEAT_LINK_STATE:\n\t\tcase USB_PORT_FEAT_U1_TIMEOUT:\n\t\tcase USB_PORT_FEAT_U2_TIMEOUT:\n\t\tcase USB_PORT_FEAT_BH_PORT_RESET:\n\t\t\tgoto error;\n\t\tcase USB_PORT_FEAT_SUSPEND:\n\t\t\tif (max3421_hcd->active)\n\t\t\t\tmax3421_hcd->port_status |=\n\t\t\t\t\tUSB_PORT_STAT_SUSPEND;\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_POWER:\n\t\t\tdev_dbg(hcd->self.controller, \"power-on\\n\");\n\t\t\tmax3421_hcd->port_status |= USB_PORT_STAT_POWER;\n\t\t\tmax3421_gpout_set_value(hcd, pdata->vbus_gpout,\n\t\t\t\t\t\tpdata->vbus_active_level);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_RESET:\n\t\t\tmax3421_reset_port(hcd);\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tif ((max3421_hcd->port_status & USB_PORT_STAT_POWER)\n\t\t\t    != 0)\n\t\t\t\tmax3421_hcd->port_status |= (1 << value);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tdev_dbg(hcd->self.controller,\n\t\t\t\"hub control req%04x v%04x i%04x l%d\\n\",\n\t\t\ttype_req, value, index, length);\nerror:\t\t/* \"protocol stall\" on error */\n\t\tretval = -EPIPE;\n\t}\n\n\tspin_unlock_irqrestore(&max3421_hcd->lock, flags);\n\treturn retval;\n}\n\nstatic int\nmax3421_bus_suspend(struct usb_hcd *hcd)\n{\n\treturn -1;\n}\n\nstatic int\nmax3421_bus_resume(struct usb_hcd *hcd)\n{\n\treturn -1;\n}\n\nstatic const struct hc_driver max3421_hcd_desc = {\n\t.description =\t\t\"max3421\",\n\t.product_desc =\t\tDRIVER_DESC,\n\t.hcd_priv_size =\tsizeof(struct max3421_hcd),\n\t.flags =\t\tHCD_USB11,\n\t.reset =\t\tmax3421_reset,\n\t.start =\t\tmax3421_start,\n\t.stop =\t\t\tmax3421_stop,\n\t.get_frame_number =\tmax3421_get_frame_number,\n\t.urb_enqueue =\t\tmax3421_urb_enqueue,\n\t.urb_dequeue =\t\tmax3421_urb_dequeue,\n\t.endpoint_disable =\tmax3421_endpoint_disable,\n\t.hub_status_data =\tmax3421_hub_status_data,\n\t.hub_control =\t\tmax3421_hub_control,\n\t.bus_suspend =\t\tmax3421_bus_suspend,\n\t.bus_resume =\t\tmax3421_bus_resume,\n};\n\nstatic int\nmax3421_of_vbus_en_pin(struct device *dev, struct max3421_hcd_platform_data *pdata)\n{\n\tint retval;\n\tuint32_t value[2];\n\n\tif (!pdata)\n\t\treturn -EINVAL;\n\n\tretval = of_property_read_u32_array(dev->of_node, \"maxim,vbus-en-pin\", value, 2);\n\tif (retval) {\n\t\tdev_err(dev, \"device tree node property 'maxim,vbus-en-pin' is missing\\n\");\n\t\treturn retval;\n\t}\n\tdev_info(dev, \"property 'maxim,vbus-en-pin' value is <%d %d>\\n\", value[0], value[1]);\n\n\tpdata->vbus_gpout = value[0];\n\tpdata->vbus_active_level = value[1];\n\n\treturn 0;\n}\n\nstatic int\nmax3421_probe(struct spi_device *spi)\n{\n\tstruct device *dev = &spi->dev;\n\tstruct max3421_hcd *max3421_hcd;\n\tstruct usb_hcd *hcd = NULL;\n\tstruct max3421_hcd_platform_data *pdata = NULL;\n\tint retval;\n\n\tif (spi_setup(spi) < 0) {\n\t\tdev_err(&spi->dev, \"Unable to setup SPI bus\");\n\t\treturn -EFAULT;\n\t}\n\n\tif (!spi->irq) {\n\t\tdev_err(dev, \"Failed to get SPI IRQ\");\n\t\treturn -EFAULT;\n\t}\n\n\tif (IS_ENABLED(CONFIG_OF) && dev->of_node) {\n\t\tpdata = devm_kzalloc(&spi->dev, sizeof(*pdata), GFP_KERNEL);\n\t\tif (!pdata) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t\tretval = max3421_of_vbus_en_pin(dev, pdata);\n\t\tif (retval)\n\t\t\tgoto error;\n\n\t\tspi->dev.platform_data = pdata;\n\t}\n\n\tpdata = spi->dev.platform_data;\n\tif (!pdata) {\n\t\tdev_err(&spi->dev, \"driver configuration data is not provided\\n\");\n\t\tretval = -EFAULT;\n\t\tgoto error;\n\t}\n\tif (pdata->vbus_active_level > 1) {\n\t\tdev_err(&spi->dev, \"vbus active level value %d is out of range (0/1)\\n\", pdata->vbus_active_level);\n\t\tretval = -EINVAL;\n\t\tgoto error;\n\t}\n\tif (pdata->vbus_gpout < 1 || pdata->vbus_gpout > MAX3421_GPOUT_COUNT) {\n\t\tdev_err(&spi->dev, \"vbus gpout value %d is out of range (1..8)\\n\", pdata->vbus_gpout);\n\t\tretval = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tretval = -ENOMEM;\n\thcd = usb_create_hcd(&max3421_hcd_desc, &spi->dev,\n\t\t\t     dev_name(&spi->dev));\n\tif (!hcd) {\n\t\tdev_err(&spi->dev, \"failed to create HCD structure\\n\");\n\t\tgoto error;\n\t}\n\tset_bit(HCD_FLAG_POLL_RH, &hcd->flags);\n\tmax3421_hcd = hcd_to_max3421(hcd);\n\tmax3421_hcd->next = max3421_hcd_list;\n\tmax3421_hcd_list = max3421_hcd;\n\tINIT_LIST_HEAD(&max3421_hcd->ep_list);\n\n\tmax3421_hcd->tx = kmalloc(sizeof(*max3421_hcd->tx), GFP_KERNEL);\n\tif (!max3421_hcd->tx)\n\t\tgoto error;\n\tmax3421_hcd->rx = kmalloc(sizeof(*max3421_hcd->rx), GFP_KERNEL);\n\tif (!max3421_hcd->rx)\n\t\tgoto error;\n\n\tmax3421_hcd->spi_thread = kthread_run(max3421_spi_thread, hcd,\n\t\t\t\t\t      \"max3421_spi_thread\");\n\tif (max3421_hcd->spi_thread == ERR_PTR(-ENOMEM)) {\n\t\tdev_err(&spi->dev,\n\t\t\t\"failed to create SPI thread (out of memory)\\n\");\n\t\tgoto error;\n\t}\n\n\tretval = usb_add_hcd(hcd, 0, 0);\n\tif (retval) {\n\t\tdev_err(&spi->dev, \"failed to add HCD\\n\");\n\t\tgoto error;\n\t}\n\n\tretval = request_irq(spi->irq, max3421_irq_handler,\n\t\t\t     IRQF_TRIGGER_LOW, \"max3421\", hcd);\n\tif (retval < 0) {\n\t\tdev_err(&spi->dev, \"failed to request irq %d\\n\", spi->irq);\n\t\tgoto error;\n\t}\n\treturn 0;\n\nerror:\n\tif (IS_ENABLED(CONFIG_OF) && dev->of_node && pdata) {\n\t\tdevm_kfree(&spi->dev, pdata);\n\t\tspi->dev.platform_data = NULL;\n\t}\n\n\tif (hcd) {\n\t\tkfree(max3421_hcd->tx);\n\t\tkfree(max3421_hcd->rx);\n\t\tif (max3421_hcd->spi_thread)\n\t\t\tkthread_stop(max3421_hcd->spi_thread);\n\t\tusb_put_hcd(hcd);\n\t}\n\treturn retval;\n}\n\nstatic int\nmax3421_remove(struct spi_device *spi)\n{\n\tstruct max3421_hcd *max3421_hcd = NULL, **prev;\n\tstruct usb_hcd *hcd = NULL;\n\tunsigned long flags;\n\n\tfor (prev = &max3421_hcd_list; *prev; prev = &(*prev)->next) {\n\t\tmax3421_hcd = *prev;\n\t\thcd = max3421_to_hcd(max3421_hcd);\n\t\tif (hcd->self.controller == &spi->dev)\n\t\t\tbreak;\n\t}\n\tif (!max3421_hcd) {\n\t\tdev_err(&spi->dev, \"no MAX3421 HCD found for SPI device %p\\n\",\n\t\t\tspi);\n\t\treturn -ENODEV;\n\t}\n\n\tusb_remove_hcd(hcd);\n\n\tspin_lock_irqsave(&max3421_hcd->lock, flags);\n\n\tkthread_stop(max3421_hcd->spi_thread);\n\t*prev = max3421_hcd->next;\n\n\tspin_unlock_irqrestore(&max3421_hcd->lock, flags);\n\n\tfree_irq(spi->irq, hcd);\n\n\tusb_put_hcd(hcd);\n\treturn 0;\n}\n\nstatic const struct of_device_id max3421_of_match_table[] = {\n\t{ .compatible = \"maxim,max3421\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, max3421_of_match_table);\n\nstatic struct spi_driver max3421_driver = {\n\t.probe\t\t= max3421_probe,\n\t.remove\t\t= max3421_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"max3421-hcd\",\n\t\t.of_match_table = of_match_ptr(max3421_of_match_table),\n\t},\n};\n\nmodule_spi_driver(max3421_driver);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_AUTHOR(\"David Mosberger <davidm@egauge.net>\");\nMODULE_LICENSE(\"GPL\");\n"], "filenames": ["drivers/usb/host/max3421-hcd.c"], "buggy_code_start_loc": [156], "buggy_code_end_loc": [1381], "fixing_code_start_loc": [155], "fixing_code_end_loc": [1366], "type": "CWE-416", "message": "drivers/usb/host/max3421-hcd.c in the Linux kernel before 5.13.6 allows physically proximate attackers to cause a denial of service (use-after-free and panic) by removing a MAX-3421 USB device in certain situations.", "other": {"cve": {"id": "CVE-2021-38204", "sourceIdentifier": "cve@mitre.org", "published": "2021-08-08T20:15:07.250", "lastModified": "2022-01-04T16:37:18.183", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "drivers/usb/host/max3421-hcd.c in the Linux kernel before 5.13.6 allows physically proximate attackers to cause a denial of service (use-after-free and panic) by removing a MAX-3421 USB device in certain situations."}, {"lang": "es", "value": "El archivo drivers/usb/host/max3421-hcd.c en el kernel de Linux versiones anteriores a 5.13.6, permite a atacantes f\u00edsicamente pr\u00f3ximos causar una denegaci\u00f3n de servicio (uso de memoria previamente liberada y p\u00e1nico) al eliminar un dispositivo USB MAX-3421 en determinadas situaciones"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:P/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "PHYSICAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.13.6", "matchCriteriaId": "7F553752-8EB5-48A9-A1AD-1463CE397231"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.13.6", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/b5fdf5c6e6bee35837e160c00ac89327bdad031b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/12/msg00012.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/b5fdf5c6e6bee35837e160c00ac89327bdad031b"}}