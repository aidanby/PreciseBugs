{"buggy_code": ["var jwt = require('jsonwebtoken');\nvar UnauthorizedError = require('./errors/UnauthorizedError');\nvar unless = require('express-unless');\nvar async = require('async');\nvar set = require('lodash.set');\n\nvar DEFAULT_REVOKED_FUNCTION = function(_, __, cb) { return cb(null, false); };\n\nfunction isFunction(object) {\n  return Object.prototype.toString.call(object) === '[object Function]';\n}\n\nfunction wrapStaticSecretInCallback(secret){\n  return function(_, __, cb){\n    return cb(null, secret);\n  };\n}\n\nmodule.exports = function(options) {\n  if (!options || !options.secret) throw new Error('secret should be set');\n\n  var secretCallback = options.secret;\n\n  if (!isFunction(secretCallback)){\n    secretCallback = wrapStaticSecretInCallback(secretCallback);\n  }\n\n  var isRevokedCallback = options.isRevoked || DEFAULT_REVOKED_FUNCTION;\n\n  var _requestProperty = options.userProperty || options.requestProperty || 'user';\n  var _resultProperty = options.resultProperty;\n  var credentialsRequired = typeof options.credentialsRequired === 'undefined' ? true : options.credentialsRequired;\n\n  var middleware = function(req, res, next) {\n    var token;\n\n    if (req.method === 'OPTIONS' && req.headers.hasOwnProperty('access-control-request-headers')) {\n      var hasAuthInAccessControl = !!~req.headers['access-control-request-headers']\n                                    .split(',').map(function (header) {\n                                      return header.trim();\n                                    }).indexOf('authorization');\n\n      if (hasAuthInAccessControl) {\n        return next();\n      }\n    }\n\n    if (options.getToken && typeof options.getToken === 'function') {\n      try {\n        token = options.getToken(req);\n      } catch (e) {\n        return next(e);\n      }\n    } else if (req.headers && req.headers.authorization) {\n      var parts = req.headers.authorization.split(' ');\n      if (parts.length == 2) {\n        var scheme = parts[0];\n        var credentials = parts[1];\n\n        if (/^Bearer$/i.test(scheme)) {\n          token = credentials;\n        } else {\n          if (credentialsRequired) {\n            return next(new UnauthorizedError('credentials_bad_scheme', { message: 'Format is Authorization: Bearer [token]' }));\n          } else {\n            return next();\n          }\n        }\n      } else {\n        return next(new UnauthorizedError('credentials_bad_format', { message: 'Format is Authorization: Bearer [token]' }));\n      }\n    }\n\n    if (!token) {\n      if (credentialsRequired) {\n        return next(new UnauthorizedError('credentials_required', { message: 'No authorization token was found' }));\n      } else {\n        return next();\n      }\n    }\n\n    var dtoken;\n\n    try {\n      dtoken = jwt.decode(token, { complete: true }) || {};\n    } catch (err) {\n      return next(new UnauthorizedError('invalid_token', err));\n    }\n\n    async.waterfall([\n      function getSecret(callback){\n        var arity = secretCallback.length;\n        if (arity == 4) {\n          secretCallback(req, dtoken.header, dtoken.payload, callback);\n        } else { // arity == 3\n          secretCallback(req, dtoken.payload, callback);\n        }\n      },\n      function verifyToken(secret, callback) {\n        jwt.verify(token, secret, options, function(err, decoded) {\n          if (err) {\n            callback(new UnauthorizedError('invalid_token', err));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      },\n      function checkRevoked(decoded, callback) {\n        isRevokedCallback(req, dtoken.payload, function (err, revoked) {\n          if (err) {\n            callback(err);\n          }\n          else if (revoked) {\n            callback(new UnauthorizedError('revoked_token', {message: 'The token has been revoked.'}));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      }\n\n    ], function (err, result){\n      if (err) { return next(err); }\n      if (_resultProperty) {\n        set(res, _resultProperty, result);\n      } else {\n        set(req, _requestProperty, result);\n      }\n      next();\n    });\n  };\n\n  middleware.unless = unless;\n  middleware.UnauthorizedError = UnauthorizedError;\n\n  return middleware;\n};\n\nmodule.exports.UnauthorizedError = UnauthorizedError;\n", "{\n  \"name\": \"express-jwt\",\n  \"version\": \"5.3.3\",\n  \"description\": \"JWT authentication middleware.\",\n  \"keywords\": [\n    \"auth\",\n    \"authn\",\n    \"authentication\",\n    \"authz\",\n    \"authorization\",\n    \"http\",\n    \"jwt\",\n    \"token\",\n    \"oauth\",\n    \"express\"\n  ],\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/auth0/express-jwt.git\"\n  },\n  \"bugs\": {\n    \"url\": \"http://github.com/auth0/express-jwt/issues\"\n  },\n  \"author\": {\n    \"name\": \"Matias Woloski\",\n    \"email\": \"matias@auth0.com\",\n    \"url\": \"https://www.auth0.com/\"\n  },\n  \"license\": \"MIT\",\n  \"main\": \"./lib\",\n  \"dependencies\": {\n    \"async\": \"^1.5.0\",\n    \"express-unless\": \"^0.3.0\",\n    \"jsonwebtoken\": \"^8.1.0\",\n    \"lodash.set\": \"^4.0.0\"\n  },\n  \"devDependencies\": {\n    \"conventional-changelog\": \"~1.1.0\",\n    \"mocha\": \"^7.1.1\"\n  },\n  \"engines\": {\n    \"node\": \">= 0.4.0\"\n  },\n  \"scripts\": {\n    \"test\": \"node_modules/.bin/mocha --reporter spec\"\n  }\n}\n", "var jwt = require('jsonwebtoken');\nvar assert = require('assert');\n\nvar expressjwt = require('../lib');\nvar UnauthorizedError = require('../lib/errors/UnauthorizedError');\n\ndescribe('failure tests', function () {\n  var req = {};\n  var res = {};\n\n  it('should throw if options not sent', function() {\n    try {\n      expressjwt();\n    } catch(e) {\n      assert.ok(e);\n      assert.equal(e.message, 'secret should be set');\n    }\n  });\n\n  it('should throw if no authorization header and credentials are required', function() {\n    expressjwt({secret: 'shhhh', credentialsRequired: true})(req, res, function(err) {\n      assert.ok(err);\n      assert.equal(err.code, 'credentials_required');\n    });\n  });\n\n  it('support unless skip', function() {\n    req.originalUrl = '/index.html';\n    expressjwt({secret: 'shhhh'}).unless({path: '/index.html'})(req, res, function(err) {\n      assert.ok(!err);\n    });\n  });\n\n  it('should skip on CORS preflight', function() {\n    var corsReq = {};\n    corsReq.method = 'OPTIONS';\n    corsReq.headers = {\n      'access-control-request-headers': 'sasa, sras,  authorization'\n    };\n    expressjwt({secret: 'shhhh'})(corsReq, res, function(err) {\n      assert.ok(!err);\n    });\n  });\n\n  it('should throw if authorization header is malformed', function() {\n    req.headers = {};\n    req.headers.authorization = 'wrong';\n    expressjwt({secret: 'shhhh'})(req, res, function(err) {\n      assert.ok(err);\n      assert.equal(err.code, 'credentials_bad_format');\n    });\n  });\n\n  it('should throw if authorization header is not Bearer', function() {\n    req.headers = {};\n    req.headers.authorization = 'Basic foobar';\n    expressjwt({secret: 'shhhh'})(req, res, function(err) {\n      assert.ok(err);\n      assert.equal(err.code, 'credentials_bad_scheme');\n    });\n  });\n\n  it('should next if authorization header is not Bearer and credentialsRequired is false', function() {\n    req.headers = {};\n    req.headers.authorization = 'Basic foobar';\n    expressjwt({secret: 'shhhh', credentialsRequired: false})(req, res, function(err) {\n      assert.ok(typeof err === 'undefined');\n    });\n  });\n\n  it('should throw if authorization header is not well-formatted jwt', function() {\n    req.headers = {};\n    req.headers.authorization = 'Bearer wrongjwt';\n    expressjwt({secret: 'shhhh'})(req, res, function(err) {\n      assert.ok(err);\n      assert.equal(err.code, 'invalid_token');\n    });\n  });\n\n  it('should throw if jwt is an invalid json', function() {\n    req.headers = {};\n    req.headers.authorization = 'Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.yJ1c2VybmFtZSI6InNhZ3VpYXIiLCJpYXQiOjE0NzEwMTg2MzUsImV4cCI6MTQ3MzYxMDYzNX0.foo';\n    expressjwt({secret: 'shhhh'})(req, res, function(err) {\n      assert.ok(err);\n      assert.equal(err.code, 'invalid_token');\n    });\n  });\n\n  it('should throw if authorization header is not valid jwt', function() {\n    var secret = 'shhhhhh';\n    var token = jwt.sign({foo: 'bar'}, secret);\n\n    req.headers = {};\n    req.headers.authorization = 'Bearer ' + token;\n    expressjwt({secret: 'different-shhhh'})(req, res, function(err) {\n      assert.ok(err);\n      assert.equal(err.code, 'invalid_token');\n      assert.equal(err.message, 'invalid signature');\n    });\n  });\n\n  it('should throw if audience is not expected', function() {\n    var secret = 'shhhhhh';\n    var token = jwt.sign({foo: 'bar', aud: 'expected-audience'}, secret);\n\n    req.headers = {};\n    req.headers.authorization = 'Bearer ' + token;\n    expressjwt({secret: 'shhhhhh', audience: 'not-expected-audience'})(req, res, function(err) {\n      assert.ok(err);\n      assert.equal(err.code, 'invalid_token');\n      assert.equal(err.message, 'jwt audience invalid. expected: not-expected-audience');\n    });\n  });\n\n  it('should throw if token is expired', function() {\n    var secret = 'shhhhhh';\n    var token = jwt.sign({foo: 'bar', exp: 1382412921 }, secret);\n\n    req.headers = {};\n    req.headers.authorization = 'Bearer ' + token;\n    expressjwt({secret: 'shhhhhh'})(req, res, function(err) {\n      assert.ok(err);\n      assert.equal(err.code, 'invalid_token');\n      assert.equal(err.inner.name, 'TokenExpiredError');\n      assert.equal(err.message, 'jwt expired');\n    });\n  });\n\n  it('should throw if token issuer is wrong', function() {\n    var secret = 'shhhhhh';\n    var token = jwt.sign({foo: 'bar', iss: 'http://foo' }, secret);\n\n    req.headers = {};\n    req.headers.authorization = 'Bearer ' + token;\n    expressjwt({secret: 'shhhhhh', issuer: 'http://wrong'})(req, res, function(err) {\n      assert.ok(err);\n      assert.equal(err.code, 'invalid_token');\n      assert.equal(err.message, 'jwt issuer invalid. expected: http://wrong');\n    });\n  });\n\n  it('should use errors thrown from custom getToken function', function() {\n    var secret = 'shhhhhh';\n    var token = jwt.sign({foo: 'bar'}, secret);\n\n    function getTokenThatThrowsError() {\n      throw new UnauthorizedError('invalid_token', { message: 'Invalid token!' });\n    }\n\n    expressjwt({\n      secret: 'shhhhhh',\n      getToken: getTokenThatThrowsError\n    })(req, res, function(err) {\n      assert.ok(err);\n      assert.equal(err.code, 'invalid_token');\n      assert.equal(err.message, 'Invalid token!');\n    });\n  });\n\n\n  it('should throw error when signature is wrong', function() {\n      var secret = \"shhh\";\n      var token = jwt.sign({foo: 'bar', iss: 'http://www'}, secret);\n      // manipulate the token\n      var newContent = new Buffer(\"{foo: 'bar', edg: 'ar'}\").toString('base64');\n      var splitetToken = token.split(\".\");\n      splitetToken[1] = newContent;\n      var newToken = splitetToken.join(\".\");\n\n      // build request\n      req.headers = [];\n      req.headers.authorization = 'Bearer ' + newToken;\n      expressjwt({secret: secret})(req,res, function(err) {\n          assert.ok(err);\n          assert.equal(err.code, 'invalid_token');\n          assert.equal(err.message, 'invalid token');\n      });\n  });\n\n  it('should throw error if token is expired even with when credentials are not required', function() {\n      var secret = 'shhhhhh';\n      var token = jwt.sign({foo: 'bar', exp: 1382412921}, secret);\n\n      req.headers = {};\n      req.headers.authorization = 'Bearer ' + token;\n      expressjwt({ secret: secret, credentialsRequired: false })(req, res, function(err) {\n          assert.ok(err);\n          assert.equal(err.code, 'invalid_token');\n          assert.equal(err.message, 'jwt expired');\n      });\n  });\n\n  it('should throw error if token is invalid even with when credentials are not required', function() {\n      var secret = 'shhhhhh';\n      var token = jwt.sign({foo: 'bar', exp: 1382412921}, secret);\n\n      req.headers = {};\n      req.headers.authorization = 'Bearer ' + token;\n      expressjwt({ secret: \"not the secret\", credentialsRequired: false })(req, res, function(err) {\n          assert.ok(err);\n          assert.equal(err.code, 'invalid_token');\n          assert.equal(err.message, 'invalid signature');\n      });\n  });\n\n});\n\ndescribe('work tests', function () {\n  var req = {};\n  var res = {};\n\n  it('should work if authorization header is valid jwt', function() {\n    var secret = 'shhhhhh';\n    var token = jwt.sign({foo: 'bar'}, secret);\n\n    req.headers = {};\n    req.headers.authorization = 'Bearer ' + token;\n    expressjwt({secret: secret})(req, res, function() {\n      assert.equal('bar', req.user.foo);\n    });\n  });\n\n  it('should work with nested properties', function() {\n    var secret = 'shhhhhh';\n    var token = jwt.sign({foo: 'bar'}, secret);\n\n    req.headers = {};\n    req.headers.authorization = 'Bearer ' + token;\n    expressjwt({secret: secret, requestProperty: 'auth.token'})(req, res, function() {\n      assert.equal('bar', req.auth.token.foo);\n    });\n  });\n\n  it('should work if authorization header is valid with a buffer secret', function() {\n    var secret = new Buffer('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA', 'base64');\n    var token = jwt.sign({foo: 'bar'}, secret);\n\n    req.headers = {};\n    req.headers.authorization = 'Bearer ' + token;\n    expressjwt({secret: secret})(req, res, function() {\n      assert.equal('bar', req.user.foo);\n    });\n  });\n\n  it('should set userProperty if option provided', function() {\n    var secret = 'shhhhhh';\n    var token = jwt.sign({foo: 'bar'}, secret);\n\n    req.headers = {};\n    req.headers.authorization = 'Bearer ' + token;\n    expressjwt({secret: secret, userProperty: 'auth'})(req, res, function() {\n      assert.equal('bar', req.auth.foo);\n    });\n  });\n\n  it('should set resultProperty if option provided', function() {\n    var secret = 'shhhhhh';\n    var token = jwt.sign({foo: 'bar'}, secret);\n\n    req = { };\n    res = { };\n    req.headers = {};\n    req.headers.authorization = 'Bearer ' + token;\n    expressjwt({secret: secret, resultProperty: 'locals.user'})(req, res, function() {\n      assert.equal('bar', res.locals.user.foo);\n      assert.ok(typeof req.user === 'undefined');\n    });\n  });\n\n  it('should ignore userProperty if resultProperty option provided', function() {\n    var secret = 'shhhhhh';\n    var token = jwt.sign({foo: 'bar'}, secret);\n\n    req = { };\n    res = { };\n    req.headers = {};\n    req.headers.authorization = 'Bearer ' + token;\n    expressjwt({secret: secret, userProperty: 'auth', resultProperty: 'locals.user'})(req, res, function() {\n      assert.equal('bar', res.locals.user.foo);\n      assert.ok(typeof req.auth === 'undefined');\n    });\n  });\n\n  it('should work if no authorization header and credentials are not required', function() {\n    req = {};\n    expressjwt({ secret: 'shhhh', credentialsRequired: false })(req, res, function(err) {\n      assert(typeof err === 'undefined');\n    });\n  });\n\n  it('should not work if no authorization header', function() {\n    req = {};\n    expressjwt({ secret: 'shhhh' })(req, res, function(err) {\n      assert(typeof err !== 'undefined');\n    });\n  });\n\n  it('should produce a stack trace that includes the failure reason', function() {\n    var req = {};\n    var token = jwt.sign({foo: 'bar'}, 'secretA');\n    req.headers = {};\n    req.headers.authorization = 'Bearer ' + token;\n\n    expressjwt({secret: 'secretB'})(req, res, function(err) {\n      var index = err.stack.indexOf('UnauthorizedError: invalid signature')\n      assert.equal(index, 0, \"Stack trace didn't include 'invalid signature' message.\")\n    });\n\n  });\n\n  it('should work with a custom getToken function', function() {\n    var secret = 'shhhhhh';\n    var token = jwt.sign({foo: 'bar'}, secret);\n\n    req.headers = {};\n    req.query = {};\n    req.query.token = token;\n\n    function getTokenFromQuery(req) {\n      return req.query.token;\n    }\n\n    expressjwt({\n      secret: secret,\n      getToken: getTokenFromQuery\n    })(req, res, function() {\n      assert.equal('bar', req.user.foo);\n    });\n  });\n\n  it('should work with a secretCallback function that accepts header argument', function() {\n    var secret = 'shhhhhh';\n    var secretCallback = function(req, headers, payload, cb) {\n      assert.equal(headers.alg, 'HS256');\n      assert.equal(payload.foo, 'bar');\n      process.nextTick(function(){ return cb(null, secret) });\n    }\n    var token = jwt.sign({foo: 'bar'}, secret);\n\n    req.headers = {};\n    req.headers.authorization = 'Bearer ' + token;\n    expressjwt({secret: secretCallback})(req, res, function() {\n      assert.equal('bar', req.user.foo);\n    });\n  });\n});\n", "var jwt = require('jsonwebtoken');\nvar assert = require('assert');\n\nvar expressjwt = require('../lib');\nvar UnauthorizedError = require('../lib/errors/UnauthorizedError');\n\ndescribe('multitenancy', function(){\n  var req = {};\n  var res = {};\n\n  var tenants = {\n    'a': {\n      secret: 'secret-a'\n    }\n  };\n\n  var secretCallback = function(req, payload, cb){\n    var issuer = payload.iss;\n    if (tenants[issuer]){\n      return cb(null, tenants[issuer].secret);\n    }\n\n    return cb(new UnauthorizedError('missing_secret',\n      { message: 'Could not find secret for issuer.' }));\n  };\n\n  var middleware = expressjwt({\n    secret: secretCallback\n  });\n\n  it ('should retrieve secret using callback', function(){\n    var token = jwt.sign({ iss: 'a', foo: 'bar'}, tenants.a.secret);\n\n    req.headers = {};\n    req.headers.authorization = 'Bearer ' + token;\n\n    middleware(req, res, function() {\n      assert.equal('bar', req.user.foo);\n    });\n  });\n\n  it ('should throw if an error ocurred when retrieving the token', function(){\n    var secret = 'shhhhhh';\n    var token = jwt.sign({ iss: 'inexistent', foo: 'bar'}, secret);\n\n    req.headers = {};\n    req.headers.authorization = 'Bearer ' + token;\n\n    middleware(req, res, function(err) {\n      assert.ok(err);\n      assert.equal(err.code, 'missing_secret');\n      assert.equal(err.message, 'Could not find secret for issuer.');\n    });\n  });\n\n  it ('should fail if token is revoked', function(){\n    var token = jwt.sign({ iss: 'a', foo: 'bar'}, tenants.a.secret);\n\n    req.headers = {};\n    req.headers.authorization = 'Bearer ' + token;\n\n    var middleware = expressjwt({\n      secret: secretCallback,\n      isRevoked: function(req, payload, done){\n        done(null, true);\n      }\n    })(req, res, function(err) {\n      assert.ok(err);\n      assert.equal(err.code, 'revoked_token');\n      assert.equal(err.message, 'The token has been revoked.');\n    });\n  });\n});\n\n", "var jwt = require('jsonwebtoken');\nvar assert = require('assert');\n\nvar expressjwt = require('../lib');\nvar UnauthorizedError = require('../lib/errors/UnauthorizedError');\n\ndescribe('revoked jwts', function(){\n  var secret = 'shhhhhh';\n\n  var revoked_id = '1234'\n\n  var middleware = expressjwt({\n    secret: secret,\n    isRevoked: function(req, payload, done){\n      done(null, payload.jti && payload.jti === revoked_id);\n    }\n  });\n\n  it('should throw if token is revoked', function(){\n    var req = {};\n    var res = {};\n    var token = jwt.sign({ jti: revoked_id, foo: 'bar'}, secret);\n\n    req.headers = {};\n    req.headers.authorization = 'Bearer ' + token;\n\n    middleware(req, res, function(err) {\n      assert.ok(err);\n      assert.equal(err.code, 'revoked_token');\n      assert.equal(err.message, 'The token has been revoked.');\n    });\n  });\n\n  it('should work if token is not revoked', function(){\n    var req = {};\n    var res = {};\n    var token = jwt.sign({ jti: '1233', foo: 'bar'}, secret);\n\n    req.headers = {};\n    req.headers.authorization = 'Bearer ' + token;\n\n    middleware(req, res, function() {\n      assert.equal('bar', req.user.foo);\n    });\n  });\n\n  it('should throw if error occurs checking if token is revoked', function(){\n    var req = {};\n    var res = {};\n    var token = jwt.sign({ jti: revoked_id, foo: 'bar'}, secret);\n\n    req.headers = {};\n    req.headers.authorization = 'Bearer ' + token;\n\n    expressjwt({\n      secret: secret,\n      isRevoked: function(req, payload, done){\n        done(new Error('An error ocurred'));\n      }\n    })(req, res, function(err) {\n      assert.ok(err);\n      assert.equal(err.message, 'An error ocurred');\n    });\n  });\n});", "var jwt = require('jsonwebtoken');\nvar assert = require('assert');\n\nvar expressjwt = require('../lib');\nvar UnauthorizedError = require('../lib/errors/UnauthorizedError');\n\ndescribe('string tokens', function () {\n  var req = {};\n  var res = {};\n\n  it('should work with a valid string token', function() {\n    var secret = 'shhhhhh';\n    var token = jwt.sign('foo', secret);\n\n    req.headers = {};\n    req.headers.authorization = 'Bearer ' + token;\n    expressjwt({secret: secret})(req, res, function() {\n      assert.equal('foo', req.user);\n    });\n  });\n\n});"], "fixing_code": ["var jwt = require('jsonwebtoken');\nvar UnauthorizedError = require('./errors/UnauthorizedError');\nvar unless = require('express-unless');\nvar async = require('async');\nvar set = require('lodash.set');\n\nvar DEFAULT_REVOKED_FUNCTION = function(_, __, cb) { return cb(null, false); };\n\nfunction isFunction(object) {\n  return Object.prototype.toString.call(object) === '[object Function]';\n}\n\nfunction wrapStaticSecretInCallback(secret){\n  return function(_, __, cb){\n    return cb(null, secret);\n  };\n}\n\nmodule.exports = function(options) {\n  if (!options || !options.secret) throw new Error('secret should be set');\n\n  if (!options.algorithms) throw new Error('algorithms should be set');\n  if (!Array.isArray(options.algorithms)) throw new Error('algorithms must be an array');\n\n  var secretCallback = options.secret;\n\n  if (!isFunction(secretCallback)){\n    secretCallback = wrapStaticSecretInCallback(secretCallback);\n  }\n\n  var isRevokedCallback = options.isRevoked || DEFAULT_REVOKED_FUNCTION;\n\n  var _requestProperty = options.userProperty || options.requestProperty || 'user';\n  var _resultProperty = options.resultProperty;\n  var credentialsRequired = typeof options.credentialsRequired === 'undefined' ? true : options.credentialsRequired;\n\n  var middleware = function(req, res, next) {\n    var token;\n\n    if (req.method === 'OPTIONS' && req.headers.hasOwnProperty('access-control-request-headers')) {\n      var hasAuthInAccessControl = !!~req.headers['access-control-request-headers']\n                                    .split(',').map(function (header) {\n                                      return header.trim();\n                                    }).indexOf('authorization');\n\n      if (hasAuthInAccessControl) {\n        return next();\n      }\n    }\n\n    if (options.getToken && typeof options.getToken === 'function') {\n      try {\n        token = options.getToken(req);\n      } catch (e) {\n        return next(e);\n      }\n    } else if (req.headers && req.headers.authorization) {\n      var parts = req.headers.authorization.split(' ');\n      if (parts.length == 2) {\n        var scheme = parts[0];\n        var credentials = parts[1];\n\n        if (/^Bearer$/i.test(scheme)) {\n          token = credentials;\n        } else {\n          if (credentialsRequired) {\n            return next(new UnauthorizedError('credentials_bad_scheme', { message: 'Format is Authorization: Bearer [token]' }));\n          } else {\n            return next();\n          }\n        }\n      } else {\n        return next(new UnauthorizedError('credentials_bad_format', { message: 'Format is Authorization: Bearer [token]' }));\n      }\n    }\n\n    if (!token) {\n      if (credentialsRequired) {\n        return next(new UnauthorizedError('credentials_required', { message: 'No authorization token was found' }));\n      } else {\n        return next();\n      }\n    }\n\n    var dtoken;\n\n    try {\n      dtoken = jwt.decode(token, { complete: true }) || {};\n    } catch (err) {\n      return next(new UnauthorizedError('invalid_token', err));\n    }\n\n    async.waterfall([\n      function getSecret(callback){\n        var arity = secretCallback.length;\n        if (arity == 4) {\n          secretCallback(req, dtoken.header, dtoken.payload, callback);\n        } else { // arity == 3\n          secretCallback(req, dtoken.payload, callback);\n        }\n      },\n      function verifyToken(secret, callback) {\n        jwt.verify(token, secret, options, function(err, decoded) {\n          if (err) {\n            callback(new UnauthorizedError('invalid_token', err));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      },\n      function checkRevoked(decoded, callback) {\n        isRevokedCallback(req, dtoken.payload, function (err, revoked) {\n          if (err) {\n            callback(err);\n          }\n          else if (revoked) {\n            callback(new UnauthorizedError('revoked_token', {message: 'The token has been revoked.'}));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      }\n\n    ], function (err, result){\n      if (err) { return next(err); }\n      if (_resultProperty) {\n        set(res, _resultProperty, result);\n      } else {\n        set(req, _requestProperty, result);\n      }\n      next();\n    });\n  };\n\n  middleware.unless = unless;\n  middleware.UnauthorizedError = UnauthorizedError;\n\n  return middleware;\n};\n\nmodule.exports.UnauthorizedError = UnauthorizedError;\n", "{\n  \"name\": \"express-jwt\",\n  \"version\": \"5.3.3\",\n  \"description\": \"JWT authentication middleware.\",\n  \"keywords\": [\n    \"auth\",\n    \"authn\",\n    \"authentication\",\n    \"authz\",\n    \"authorization\",\n    \"http\",\n    \"jwt\",\n    \"token\",\n    \"oauth\",\n    \"express\"\n  ],\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/auth0/express-jwt.git\"\n  },\n  \"bugs\": {\n    \"url\": \"http://github.com/auth0/express-jwt/issues\"\n  },\n  \"author\": {\n    \"name\": \"Matias Woloski\",\n    \"email\": \"matias@auth0.com\",\n    \"url\": \"https://www.auth0.com/\"\n  },\n  \"license\": \"MIT\",\n  \"main\": \"./lib\",\n  \"dependencies\": {\n    \"async\": \"^1.5.0\",\n    \"express-unless\": \"^0.3.0\",\n    \"jsonwebtoken\": \"^8.1.0\",\n    \"lodash.set\": \"^4.0.0\"\n  },\n  \"devDependencies\": {\n    \"conventional-changelog\": \"~1.1.0\",\n    \"mocha\": \"^7.1.1\"\n  },\n  \"engines\": {\n    \"node\": \">= 8.0.0\"\n  },\n  \"scripts\": {\n    \"test\": \"node_modules/.bin/mocha --reporter spec\"\n  }\n}\n", "var jwt = require('jsonwebtoken');\nvar assert = require('assert');\n\nvar expressjwt = require('../lib');\nvar UnauthorizedError = require('../lib/errors/UnauthorizedError');\n\ndescribe('failure tests', function () {\n  var req = {};\n  var res = {};\n\n  it('should throw if options not sent', function() {\n    try {\n      expressjwt();\n    } catch(e) {\n      assert.ok(e);\n      assert.equal(e.message, 'secret should be set');\n    }\n  });\n\n  it('should throw if algorithms is not sent', function() {\n    try {\n      expressjwt({ secret: 'shhhh' });\n    } catch(e) {\n      assert.ok(e);\n      assert.equal(e.message, 'algorithms should be set');\n    }\n  });\n\n  it('should throw if algorithms is not an array', function() {\n    try {\n      expressjwt({ secret: 'shhhh', algorithms: 'foo' });\n    } catch(e) {\n      assert.ok(e);\n      assert.equal(e.message, 'algorithms must be an array');\n    }\n  });\n\n  it('should throw if no authorization header and credentials are required', function() {\n    expressjwt({secret: 'shhhh', credentialsRequired: true, algorithms: ['HS256']})(req, res, function(err) {\n      assert.ok(err);\n      assert.equal(err.code, 'credentials_required');\n    });\n  });\n\n  it('support unless skip', function() {\n    req.originalUrl = '/index.html';\n    expressjwt({secret: 'shhhh', algorithms: ['HS256'], algorithms: ['HS256']}).unless({path: '/index.html'})(req, res, function(err) {\n      assert.ok(!err);\n    });\n  });\n\n  it('should skip on CORS preflight', function() {\n    var corsReq = {};\n    corsReq.method = 'OPTIONS';\n    corsReq.headers = {\n      'access-control-request-headers': 'sasa, sras,  authorization'\n    };\n    expressjwt({secret: 'shhhh', algorithms: ['HS256']})(corsReq, res, function(err) {\n      assert.ok(!err);\n    });\n  });\n\n  it('should throw if authorization header is malformed', function() {\n    req.headers = {};\n    req.headers.authorization = 'wrong';\n    expressjwt({secret: 'shhhh', algorithms: ['HS256']})(req, res, function(err) {\n      assert.ok(err);\n      assert.equal(err.code, 'credentials_bad_format');\n    });\n  });\n\n  it('should throw if authorization header is not Bearer', function() {\n    req.headers = {};\n    req.headers.authorization = 'Basic foobar';\n    expressjwt({secret: 'shhhh', algorithms: ['HS256']})(req, res, function(err) {\n      assert.ok(err);\n      assert.equal(err.code, 'credentials_bad_scheme');\n    });\n  });\n\n  it('should next if authorization header is not Bearer and credentialsRequired is false', function() {\n    req.headers = {};\n    req.headers.authorization = 'Basic foobar';\n    expressjwt({secret: 'shhhh', algorithms: ['HS256'], credentialsRequired: false})(req, res, function(err) {\n      assert.ok(typeof err === 'undefined');\n    });\n  });\n\n  it('should throw if authorization header is not well-formatted jwt', function() {\n    req.headers = {};\n    req.headers.authorization = 'Bearer wrongjwt';\n    expressjwt({secret: 'shhhh', algorithms: ['HS256']})(req, res, function(err) {\n      assert.ok(err);\n      assert.equal(err.code, 'invalid_token');\n    });\n  });\n\n  it('should throw if jwt is an invalid json', function() {\n    req.headers = {};\n    req.headers.authorization = 'Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.yJ1c2VybmFtZSI6InNhZ3VpYXIiLCJpYXQiOjE0NzEwMTg2MzUsImV4cCI6MTQ3MzYxMDYzNX0.foo';\n    expressjwt({secret: 'shhhh', algorithms: ['HS256']})(req, res, function(err) {\n      assert.ok(err);\n      assert.equal(err.code, 'invalid_token');\n    });\n  });\n\n  it('should throw if authorization header is not valid jwt', function() {\n    var secret = 'shhhhhh';\n    var token = jwt.sign({foo: 'bar'}, secret);\n\n    req.headers = {};\n    req.headers.authorization = 'Bearer ' + token;\n    expressjwt({secret: 'different-shhhh', algorithms: ['HS256'] })(req, res, function(err) {\n      assert.ok(err);\n      assert.equal(err.code, 'invalid_token');\n      assert.equal(err.message, 'invalid signature');\n    });\n  });\n\n  it('should throw if audience is not expected', function() {\n    var secret = 'shhhhhh';\n    var token = jwt.sign({foo: 'bar', aud: 'expected-audience'}, secret, { expiresIn: 500});\n\n    req.headers = {};\n    req.headers.authorization = 'Bearer ' + token;\n    expressjwt({secret: 'shhhhhh', algorithms: ['HS256'], audience: 'not-expected-audience'})(req, res, function(err) {\n      assert.ok(err);\n      assert.equal(err.code, 'invalid_token');\n      assert.equal(err.message, 'jwt audience invalid. expected: not-expected-audience');\n    });\n  });\n\n  it('should throw if token is expired', function() {\n    var secret = 'shhhhhh';\n    var token = jwt.sign({foo: 'bar', exp: 1382412921 }, secret);\n\n    req.headers = {};\n    req.headers.authorization = 'Bearer ' + token;\n    expressjwt({secret: 'shhhhhh', algorithms: ['HS256']})(req, res, function(err) {\n      assert.ok(err);\n      assert.equal(err.code, 'invalid_token');\n      assert.equal(err.inner.name, 'TokenExpiredError');\n      assert.equal(err.message, 'jwt expired');\n    });\n  });\n\n  it('should throw if token issuer is wrong', function() {\n    var secret = 'shhhhhh';\n    var token = jwt.sign({foo: 'bar', iss: 'http://foo' }, secret);\n\n    req.headers = {};\n    req.headers.authorization = 'Bearer ' + token;\n    expressjwt({secret: 'shhhhhh', algorithms: ['HS256'], issuer: 'http://wrong'})(req, res, function(err) {\n      assert.ok(err);\n      assert.equal(err.code, 'invalid_token');\n      assert.equal(err.message, 'jwt issuer invalid. expected: http://wrong');\n    });\n  });\n\n  it('should use errors thrown from custom getToken function', function() {\n    var secret = 'shhhhhh';\n\n    function getTokenThatThrowsError() {\n      throw new UnauthorizedError('invalid_token', { message: 'Invalid token!' });\n    }\n\n    expressjwt({\n      secret: 'shhhhhh', algorithms: ['HS256'],\n      getToken: getTokenThatThrowsError\n    })(req, res, function(err) {\n      assert.ok(err);\n      assert.equal(err.code, 'invalid_token');\n      assert.equal(err.message, 'Invalid token!');\n    });\n  });\n\n  it('should throw error when signature is wrong', function() {\n      var secret = \"shhh\";\n      var token = jwt.sign({foo: 'bar', iss: 'http://www'}, secret);\n      // manipulate the token\n      var newContent = new Buffer(\"{foo: 'bar', edg: 'ar'}\").toString('base64');\n      var splitetToken = token.split(\".\");\n      splitetToken[1] = newContent;\n      var newToken = splitetToken.join(\".\");\n\n      // build request\n      req.headers = [];\n      req.headers.authorization = 'Bearer ' + newToken;\n      expressjwt({secret: secret, algorithms: ['HS256']})(req,res, function(err) {\n          assert.ok(err);\n          assert.equal(err.code, 'invalid_token');\n          assert.equal(err.message, 'invalid token');\n      });\n  });\n\n  it('should throw error if token is expired even with when credentials are not required', function() {\n      var secret = 'shhhhhh';\n      var token = jwt.sign({foo: 'bar', exp: 1382412921}, secret);\n\n      req.headers = {};\n      req.headers.authorization = 'Bearer ' + token;\n      expressjwt({ secret: secret, credentialsRequired: false, algorithms: ['HS256'] })(req, res, function(err) {\n          assert.ok(err);\n          assert.equal(err.code, 'invalid_token');\n          assert.equal(err.message, 'jwt expired');\n      });\n  });\n\n  it('should throw error if token is invalid even with when credentials are not required', function() {\n      var secret = 'shhhhhh';\n      var token = jwt.sign({foo: 'bar', exp: 1382412921}, secret);\n\n      req.headers = {};\n      req.headers.authorization = 'Bearer ' + token;\n      expressjwt({ secret: \"not the secret\", algorithms: ['HS256'], credentialsRequired: false })(req, res, function(err) {\n          assert.ok(err);\n          assert.equal(err.code, 'invalid_token');\n          assert.equal(err.message, 'invalid signature');\n      });\n  });\n\n});\n\ndescribe('work tests', function () {\n  var req = {};\n  var res = {};\n\n  it('should work if authorization header is valid jwt', function() {\n    var secret = 'shhhhhh';\n    var token = jwt.sign({foo: 'bar'}, secret);\n\n    req.headers = {};\n    req.headers.authorization = 'Bearer ' + token;\n    expressjwt({secret: secret, algorithms: ['HS256']})(req, res, function() {\n      assert.equal('bar', req.user.foo);\n    });\n  });\n\n  it('should work with nested properties', function() {\n    var secret = 'shhhhhh';\n    var token = jwt.sign({foo: 'bar'}, secret);\n\n    req.headers = {};\n    req.headers.authorization = 'Bearer ' + token;\n    expressjwt({secret: secret, algorithms: ['HS256'], requestProperty: 'auth.token'})(req, res, function() {\n      assert.equal('bar', req.auth.token.foo);\n    });\n  });\n\n  it('should work if authorization header is valid with a buffer secret', function() {\n    var secret = new Buffer('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA', 'base64');\n    var token = jwt.sign({foo: 'bar'}, secret);\n\n    req.headers = {};\n    req.headers.authorization = 'Bearer ' + token;\n    expressjwt({secret: secret, algorithms: ['HS256']})(req, res, function() {\n      assert.equal('bar', req.user.foo);\n    });\n  });\n\n  it('should set userProperty if option provided', function() {\n    var secret = 'shhhhhh';\n    var token = jwt.sign({foo: 'bar'}, secret);\n\n    req.headers = {};\n    req.headers.authorization = 'Bearer ' + token;\n    expressjwt({secret: secret, algorithms: ['HS256'], userProperty: 'auth'})(req, res, function() {\n      assert.equal('bar', req.auth.foo);\n    });\n  });\n\n  it('should set resultProperty if option provided', function() {\n    var secret = 'shhhhhh';\n    var token = jwt.sign({foo: 'bar'}, secret);\n\n    req = { };\n    res = { };\n    req.headers = {};\n    req.headers.authorization = 'Bearer ' + token;\n    expressjwt({secret: secret, algorithms: ['HS256'], resultProperty: 'locals.user'})(req, res, function() {\n      assert.equal('bar', res.locals.user.foo);\n      assert.ok(typeof req.user === 'undefined');\n    });\n  });\n\n  it('should ignore userProperty if resultProperty option provided', function() {\n    var secret = 'shhhhhh';\n    var token = jwt.sign({foo: 'bar'}, secret);\n\n    req = { };\n    res = { };\n    req.headers = {};\n    req.headers.authorization = 'Bearer ' + token;\n    expressjwt({secret: secret, algorithms: ['HS256'], userProperty: 'auth', resultProperty: 'locals.user'})(req, res, function() {\n      assert.equal('bar', res.locals.user.foo);\n      assert.ok(typeof req.auth === 'undefined');\n    });\n  });\n\n  it('should work if no authorization header and credentials are not required', function() {\n    req = {};\n    expressjwt({ secret: 'shhhh', algorithms: ['HS256'], credentialsRequired: false })(req, res, function(err) {\n      assert(typeof err === 'undefined');\n    });\n  });\n\n  it('should not work if no authorization header', function() {\n    req = {};\n    expressjwt({ secret: 'shhhh', algorithms: ['HS256'] })(req, res, function(err) {\n      assert(typeof err !== 'undefined');\n    });\n  });\n\n  it('should produce a stack trace that includes the failure reason', function() {\n    var req = {};\n    var token = jwt.sign({foo: 'bar'}, 'secretA');\n    req.headers = {};\n    req.headers.authorization = 'Bearer ' + token;\n\n    expressjwt({secret: 'secretB', algorithms: ['HS256']})(req, res, function(err) {\n      var index = err.stack.indexOf('UnauthorizedError: invalid signature')\n      assert.equal(index, 0, \"Stack trace didn't include 'invalid signature' message.\")\n    });\n\n  });\n\n  it('should work with a custom getToken function', function() {\n    var secret = 'shhhhhh';\n    var token = jwt.sign({foo: 'bar'}, secret);\n\n    req.headers = {};\n    req.query = {};\n    req.query.token = token;\n\n    function getTokenFromQuery(req) {\n      return req.query.token;\n    }\n\n    expressjwt({\n      secret: secret,\n      algorithms: ['HS256'],\n      getToken: getTokenFromQuery\n    })(req, res, function() {\n      assert.equal('bar', req.user.foo);\n    });\n  });\n\n  it('should work with a secretCallback function that accepts header argument', function() {\n    var secret = 'shhhhhh';\n    var secretCallback = function(req, headers, payload, cb) {\n      assert.equal(headers.alg, 'HS256');\n      assert.equal(payload.foo, 'bar');\n      process.nextTick(function(){ return cb(null, secret) });\n    }\n    var token = jwt.sign({foo: 'bar'}, secret);\n\n    req.headers = {};\n    req.headers.authorization = 'Bearer ' + token;\n    expressjwt({secret: secretCallback, algorithms: ['HS256']})(req, res, function() {\n      assert.equal('bar', req.user.foo);\n    });\n  });\n});\n", "var jwt = require('jsonwebtoken');\nvar assert = require('assert');\n\nvar expressjwt = require('../lib');\nvar UnauthorizedError = require('../lib/errors/UnauthorizedError');\n\ndescribe('multitenancy', function(){\n  var req = {};\n  var res = {};\n\n  var tenants = {\n    'a': {\n      secret: 'secret-a'\n    }\n  };\n\n  var secretCallback = function(req, payload, cb){\n    var issuer = payload.iss;\n    if (tenants[issuer]){\n      return cb(null, tenants[issuer].secret);\n    }\n\n    return cb(new UnauthorizedError('missing_secret',\n      { message: 'Could not find secret for issuer.' }));\n  };\n\n  var middleware = expressjwt({\n    secret: secretCallback,\n    algorithms: ['HS256']\n  });\n\n  it ('should retrieve secret using callback', function(){\n    var token = jwt.sign({ iss: 'a', foo: 'bar'}, tenants.a.secret);\n\n    req.headers = {};\n    req.headers.authorization = 'Bearer ' + token;\n\n    middleware(req, res, function() {\n      assert.equal('bar', req.user.foo);\n    });\n  });\n\n  it ('should throw if an error ocurred when retrieving the token', function(){\n    var secret = 'shhhhhh';\n    var token = jwt.sign({ iss: 'inexistent', foo: 'bar'}, secret);\n\n    req.headers = {};\n    req.headers.authorization = 'Bearer ' + token;\n\n    middleware(req, res, function(err) {\n      assert.ok(err);\n      assert.equal(err.code, 'missing_secret');\n      assert.equal(err.message, 'Could not find secret for issuer.');\n    });\n  });\n\n  it ('should fail if token is revoked', function(){\n    var token = jwt.sign({ iss: 'a', foo: 'bar'}, tenants.a.secret);\n\n    req.headers = {};\n    req.headers.authorization = 'Bearer ' + token;\n\n    expressjwt({\n      secret: secretCallback,\n      algorithms: ['HS256'],\n      isRevoked: function(req, payload, done){\n        done(null, true);\n      }\n    })(req, res, function(err) {\n      assert.ok(err);\n      assert.equal(err.code, 'revoked_token');\n      assert.equal(err.message, 'The token has been revoked.');\n    });\n  });\n});\n\n", "var jwt = require('jsonwebtoken');\nvar assert = require('assert');\n\nvar expressjwt = require('../lib');\nvar UnauthorizedError = require('../lib/errors/UnauthorizedError');\n\ndescribe('revoked jwts', function(){\n  var secret = 'shhhhhh';\n\n  var revoked_id = '1234'\n\n  var middleware = expressjwt({\n    secret: secret,\n    algorithms: ['HS256'],\n    isRevoked: function(req, payload, done){\n      done(null, payload.jti && payload.jti === revoked_id);\n    }\n  });\n\n  it('should throw if token is revoked', function(){\n    var req = {};\n    var res = {};\n    var token = jwt.sign({ jti: revoked_id, foo: 'bar'}, secret);\n\n    req.headers = {};\n    req.headers.authorization = 'Bearer ' + token;\n\n    middleware(req, res, function(err) {\n      assert.ok(err);\n      assert.equal(err.code, 'revoked_token');\n      assert.equal(err.message, 'The token has been revoked.');\n    });\n  });\n\n  it('should work if token is not revoked', function(){\n    var req = {};\n    var res = {};\n    var token = jwt.sign({ jti: '1233', foo: 'bar'}, secret);\n\n    req.headers = {};\n    req.headers.authorization = 'Bearer ' + token;\n\n    middleware(req, res, function() {\n      assert.equal('bar', req.user.foo);\n    });\n  });\n\n  it('should throw if error occurs checking if token is revoked', function(){\n    var req = {};\n    var res = {};\n    var token = jwt.sign({ jti: revoked_id, foo: 'bar'}, secret);\n\n    req.headers = {};\n    req.headers.authorization = 'Bearer ' + token;\n\n    expressjwt({\n      secret: secret,\n      algorithms: ['HS256'],\n      isRevoked: function(req, payload, done){\n        done(new Error('An error ocurred'));\n      }\n    })(req, res, function(err) {\n      assert.ok(err);\n      assert.equal(err.message, 'An error ocurred');\n    });\n  });\n});", "var jwt = require('jsonwebtoken');\nvar assert = require('assert');\n\nvar expressjwt = require('../lib');\nvar UnauthorizedError = require('../lib/errors/UnauthorizedError');\n\ndescribe('string tokens', function () {\n  var req = {};\n  var res = {};\n\n  it('should work with a valid string token', function() {\n    var secret = 'shhhhhh';\n    var token = jwt.sign('foo', secret);\n\n    req.headers = {};\n    req.headers.authorization = 'Bearer ' + token;\n    expressjwt({secret: secret, algorithms: ['HS256']})(req, res, function() {\n      assert.equal('foo', req.user);\n    });\n  });\n\n});"], "filenames": ["lib/index.js", "package.json", "test/jwt.test.js", "test/multitenancy.test.js", "test/revocation.test.js", "test/string_token.test.js"], "buggy_code_start_loc": [20, 42, 19, 28, 13, 17], "buggy_code_end_loc": [20, 43, 343, 63, 56, 18], "fixing_code_start_loc": [21, 42, 20, 28, 14, 17], "fixing_code_end_loc": [24, 43, 360, 66, 59, 18], "type": "CWE-863", "message": "In express-jwt (NPM package) up and including version 5.3.3, the algorithms entry to be specified in the configuration is not being enforced. When algorithms is not specified in the configuration, with the combination of jwks-rsa, it may lead to authorization bypass. You are affected by this vulnerability if all of the following conditions apply: - You are using express-jwt - You do not have **algorithms** configured in your express-jwt configuration. - You are using libraries such as jwks-rsa as the **secret**. You can fix this by specifying **algorithms** in the express-jwt configuration. See linked GHSA for example. This is also fixed in version 6.0.0.", "other": {"cve": {"id": "CVE-2020-15084", "sourceIdentifier": "security-advisories@github.com", "published": "2020-06-30T16:15:15.220", "lastModified": "2022-10-21T18:00:47.803", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In express-jwt (NPM package) up and including version 5.3.3, the algorithms entry to be specified in the configuration is not being enforced. When algorithms is not specified in the configuration, with the combination of jwks-rsa, it may lead to authorization bypass. You are affected by this vulnerability if all of the following conditions apply: - You are using express-jwt - You do not have **algorithms** configured in your express-jwt configuration. - You are using libraries such as jwks-rsa as the **secret**. You can fix this by specifying **algorithms** in the express-jwt configuration. See linked GHSA for example. This is also fixed in version 6.0.0."}, {"lang": "es", "value": "En express-jwt (paquete NPM), incluyendo la versi\u00f3n 5.3.3, la entrada de algoritmos que es especificada en la configuraci\u00f3n no es aplicada. Cuando los algoritmos no son especificados en la configuraci\u00f3n, con la combinaci\u00f3n de jwks-rsa, esto puede conllevar a una omisi\u00f3n de autorizaci\u00f3n. Pueden estar afectados por esta vulnerabilidad si se aplican todas las condiciones siguientes: - Est\u00e1n usando express-jwt - No tiene **algorithms** configurados en su configuraci\u00f3n express-jwt. - Est\u00e1n usando bibliotecas como jwks-rsa como el **secret**. Pueden corregir esto especificando **algorithms** en la configuraci\u00f3n de express-jwt. Consulte GHSA vinculado por ejemplo. Esto tambi\u00e9n es corregido en la versi\u00f3n 6.0.0"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:C/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.3, "impactScore": 5.8}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-285"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:auth0:express-jwt:*:*:*:*:*:node.js:*:*", "versionEndIncluding": "5.3.3", "matchCriteriaId": "DA2EA9DB-1370-4E0A-B443-77166B3ED3A9"}]}]}], "references": [{"url": "https://github.com/auth0/express-jwt/commit/7ecab5f8f0cab5297c2b863596566eb0c019cdef", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/auth0/express-jwt/security/advisories/GHSA-6g6m-m6h5-w9gf", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/auth0/express-jwt/commit/7ecab5f8f0cab5297c2b863596566eb0c019cdef"}}