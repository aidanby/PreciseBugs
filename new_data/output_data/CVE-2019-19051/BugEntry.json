{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * Intel Wireless WiMAX Connection 2400m\n * Implement backend for the WiMAX stack rfkill support\n *\n * Copyright (C) 2007-2008 Intel Corporation <linux-wimax@intel.com>\n * Inaky Perez-Gonzalez <inaky.perez-gonzalez@intel.com>\n *\n * The WiMAX kernel stack integrates into RF-Kill and keeps the\n * switches's status. We just need to:\n *\n * - report changes in the HW RF Kill switch [with\n *   wimax_rfkill_{sw,hw}_report(), which happens when we detect those\n *   indications coming through hardware reports]. We also do it on\n *   initialization to let the stack know the initial HW state.\n *\n * - implement indications from the stack to change the SW RF Kill\n *   switch (coming from sysfs, the wimax stack or user space).\n */\n#include \"i2400m.h\"\n#include <linux/wimax/i2400m.h>\n#include <linux/slab.h>\n\n\n\n#define D_SUBMODULE rfkill\n#include \"debug-levels.h\"\n\n/*\n * Return true if the i2400m radio is in the requested wimax_rf_state state\n *\n */\nstatic\nint i2400m_radio_is(struct i2400m *i2400m, enum wimax_rf_state state)\n{\n\tif (state == WIMAX_RF_OFF)\n\t\treturn i2400m->state == I2400M_SS_RF_OFF\n\t\t\t|| i2400m->state == I2400M_SS_RF_SHUTDOWN;\n\telse if (state == WIMAX_RF_ON)\n\t\t/* state == WIMAX_RF_ON */\n\t\treturn i2400m->state != I2400M_SS_RF_OFF\n\t\t\t&& i2400m->state != I2400M_SS_RF_SHUTDOWN;\n\telse {\n\t\tBUG();\n\t\treturn -EINVAL;\t/* shut gcc warnings on certain arches */\n\t}\n}\n\n\n/*\n * WiMAX stack operation: implement SW RFKill toggling\n *\n * @wimax_dev: device descriptor\n * @skb: skb where the message has been received; skb->data is\n *       expected to point to the message payload.\n * @genl_info: passed by the generic netlink layer\n *\n * Generic Netlink will call this function when a message is sent from\n * userspace to change the software RF-Kill switch status.\n *\n * This function will set the device's software RF-Kill switch state to\n * match what is requested.\n *\n * NOTE: the i2400m has a strict state machine; we can only set the\n *       RF-Kill switch when it is on, the HW RF-Kill is on and the\n *       device is initialized. So we ignore errors steaming from not\n *       being in the right state (-EILSEQ).\n */\nint i2400m_op_rfkill_sw_toggle(struct wimax_dev *wimax_dev,\n\t\t\t       enum wimax_rf_state state)\n{\n\tint result;\n\tstruct i2400m *i2400m = wimax_dev_to_i2400m(wimax_dev);\n\tstruct device *dev = i2400m_dev(i2400m);\n\tstruct sk_buff *ack_skb;\n\tstruct {\n\t\tstruct i2400m_l3l4_hdr hdr;\n\t\tstruct i2400m_tlv_rf_operation sw_rf;\n\t} __packed *cmd;\n\tchar strerr[32];\n\n\td_fnstart(4, dev, \"(wimax_dev %p state %d)\\n\", wimax_dev, state);\n\n\tresult = -ENOMEM;\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (cmd == NULL)\n\t\tgoto error_alloc;\n\tcmd->hdr.type = cpu_to_le16(I2400M_MT_CMD_RF_CONTROL);\n\tcmd->hdr.length = sizeof(cmd->sw_rf);\n\tcmd->hdr.version = cpu_to_le16(I2400M_L3L4_VERSION);\n\tcmd->sw_rf.hdr.type = cpu_to_le16(I2400M_TLV_RF_OPERATION);\n\tcmd->sw_rf.hdr.length = cpu_to_le16(sizeof(cmd->sw_rf.status));\n\tswitch (state) {\n\tcase WIMAX_RF_OFF:\t/* RFKILL ON, radio OFF */\n\t\tcmd->sw_rf.status = cpu_to_le32(2);\n\t\tbreak;\n\tcase WIMAX_RF_ON:\t/* RFKILL OFF, radio ON */\n\t\tcmd->sw_rf.status = cpu_to_le32(1);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tack_skb = i2400m_msg_to_dev(i2400m, cmd, sizeof(*cmd));\n\tresult = PTR_ERR(ack_skb);\n\tif (IS_ERR(ack_skb)) {\n\t\tdev_err(dev, \"Failed to issue 'RF Control' command: %d\\n\",\n\t\t\tresult);\n\t\tgoto error_msg_to_dev;\n\t}\n\tresult = i2400m_msg_check_status(wimax_msg_data(ack_skb),\n\t\t\t\t\t strerr, sizeof(strerr));\n\tif (result < 0) {\n\t\tdev_err(dev, \"'RF Control' (0x%04x) command failed: %d - %s\\n\",\n\t\t\tI2400M_MT_CMD_RF_CONTROL, result, strerr);\n\t\tgoto error_cmd;\n\t}\n\n\t/* Now we wait for the state to change to RADIO_OFF or RADIO_ON */\n\tresult = wait_event_timeout(\n\t\ti2400m->state_wq, i2400m_radio_is(i2400m, state),\n\t\t5 * HZ);\n\tif (result == 0)\n\t\tresult = -ETIMEDOUT;\n\tif (result < 0)\n\t\tdev_err(dev, \"Error waiting for device to toggle RF state: \"\n\t\t\t\"%d\\n\", result);\n\tresult = 0;\nerror_cmd:\n\tkfree(cmd);\n\tkfree_skb(ack_skb);\nerror_msg_to_dev:\nerror_alloc:\n\td_fnend(4, dev, \"(wimax_dev %p state %d) = %d\\n\",\n\t\twimax_dev, state, result);\n\treturn result;\n}\n\n\n/*\n * Inform the WiMAX stack of changes in the RF Kill switches reported\n * by the device\n *\n * @i2400m: device descriptor\n * @rfss: TLV for RF Switches status; already validated\n *\n * NOTE: the reports on RF switch status cannot be trusted\n *       or used until the device is in a state of RADIO_OFF\n *       or greater.\n */\nvoid i2400m_report_tlv_rf_switches_status(\n\tstruct i2400m *i2400m,\n\tconst struct i2400m_tlv_rf_switches_status *rfss)\n{\n\tstruct device *dev = i2400m_dev(i2400m);\n\tenum i2400m_rf_switch_status hw, sw;\n\tenum wimax_st wimax_state;\n\n\tsw = le32_to_cpu(rfss->sw_rf_switch);\n\thw = le32_to_cpu(rfss->hw_rf_switch);\n\n\td_fnstart(3, dev, \"(i2400m %p rfss %p [hw %u sw %u])\\n\",\n\t\t  i2400m, rfss, hw, sw);\n\t/* We only process rw switch evens when the device has been\n\t * fully initialized */\n\twimax_state = wimax_state_get(&i2400m->wimax_dev);\n\tif (wimax_state < WIMAX_ST_RADIO_OFF) {\n\t\td_printf(3, dev, \"ignoring RF switches report, state %u\\n\",\n\t\t\t wimax_state);\n\t\tgoto out;\n\t}\n\tswitch (sw) {\n\tcase I2400M_RF_SWITCH_ON:\t/* RF Kill disabled (radio on) */\n\t\twimax_report_rfkill_sw(&i2400m->wimax_dev, WIMAX_RF_ON);\n\t\tbreak;\n\tcase I2400M_RF_SWITCH_OFF:\t/* RF Kill enabled (radio off) */\n\t\twimax_report_rfkill_sw(&i2400m->wimax_dev, WIMAX_RF_OFF);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"HW BUG? Unknown RF SW state 0x%x\\n\", sw);\n\t}\n\n\tswitch (hw) {\n\tcase I2400M_RF_SWITCH_ON:\t/* RF Kill disabled (radio on) */\n\t\twimax_report_rfkill_hw(&i2400m->wimax_dev, WIMAX_RF_ON);\n\t\tbreak;\n\tcase I2400M_RF_SWITCH_OFF:\t/* RF Kill enabled (radio off) */\n\t\twimax_report_rfkill_hw(&i2400m->wimax_dev, WIMAX_RF_OFF);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"HW BUG? Unknown RF HW state 0x%x\\n\", hw);\n\t}\nout:\n\td_fnend(3, dev, \"(i2400m %p rfss %p [hw %u sw %u]) = void\\n\",\n\t\ti2400m, rfss, hw, sw);\n}\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * Intel Wireless WiMAX Connection 2400m\n * Implement backend for the WiMAX stack rfkill support\n *\n * Copyright (C) 2007-2008 Intel Corporation <linux-wimax@intel.com>\n * Inaky Perez-Gonzalez <inaky.perez-gonzalez@intel.com>\n *\n * The WiMAX kernel stack integrates into RF-Kill and keeps the\n * switches's status. We just need to:\n *\n * - report changes in the HW RF Kill switch [with\n *   wimax_rfkill_{sw,hw}_report(), which happens when we detect those\n *   indications coming through hardware reports]. We also do it on\n *   initialization to let the stack know the initial HW state.\n *\n * - implement indications from the stack to change the SW RF Kill\n *   switch (coming from sysfs, the wimax stack or user space).\n */\n#include \"i2400m.h\"\n#include <linux/wimax/i2400m.h>\n#include <linux/slab.h>\n\n\n\n#define D_SUBMODULE rfkill\n#include \"debug-levels.h\"\n\n/*\n * Return true if the i2400m radio is in the requested wimax_rf_state state\n *\n */\nstatic\nint i2400m_radio_is(struct i2400m *i2400m, enum wimax_rf_state state)\n{\n\tif (state == WIMAX_RF_OFF)\n\t\treturn i2400m->state == I2400M_SS_RF_OFF\n\t\t\t|| i2400m->state == I2400M_SS_RF_SHUTDOWN;\n\telse if (state == WIMAX_RF_ON)\n\t\t/* state == WIMAX_RF_ON */\n\t\treturn i2400m->state != I2400M_SS_RF_OFF\n\t\t\t&& i2400m->state != I2400M_SS_RF_SHUTDOWN;\n\telse {\n\t\tBUG();\n\t\treturn -EINVAL;\t/* shut gcc warnings on certain arches */\n\t}\n}\n\n\n/*\n * WiMAX stack operation: implement SW RFKill toggling\n *\n * @wimax_dev: device descriptor\n * @skb: skb where the message has been received; skb->data is\n *       expected to point to the message payload.\n * @genl_info: passed by the generic netlink layer\n *\n * Generic Netlink will call this function when a message is sent from\n * userspace to change the software RF-Kill switch status.\n *\n * This function will set the device's software RF-Kill switch state to\n * match what is requested.\n *\n * NOTE: the i2400m has a strict state machine; we can only set the\n *       RF-Kill switch when it is on, the HW RF-Kill is on and the\n *       device is initialized. So we ignore errors steaming from not\n *       being in the right state (-EILSEQ).\n */\nint i2400m_op_rfkill_sw_toggle(struct wimax_dev *wimax_dev,\n\t\t\t       enum wimax_rf_state state)\n{\n\tint result;\n\tstruct i2400m *i2400m = wimax_dev_to_i2400m(wimax_dev);\n\tstruct device *dev = i2400m_dev(i2400m);\n\tstruct sk_buff *ack_skb;\n\tstruct {\n\t\tstruct i2400m_l3l4_hdr hdr;\n\t\tstruct i2400m_tlv_rf_operation sw_rf;\n\t} __packed *cmd;\n\tchar strerr[32];\n\n\td_fnstart(4, dev, \"(wimax_dev %p state %d)\\n\", wimax_dev, state);\n\n\tresult = -ENOMEM;\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (cmd == NULL)\n\t\tgoto error_alloc;\n\tcmd->hdr.type = cpu_to_le16(I2400M_MT_CMD_RF_CONTROL);\n\tcmd->hdr.length = sizeof(cmd->sw_rf);\n\tcmd->hdr.version = cpu_to_le16(I2400M_L3L4_VERSION);\n\tcmd->sw_rf.hdr.type = cpu_to_le16(I2400M_TLV_RF_OPERATION);\n\tcmd->sw_rf.hdr.length = cpu_to_le16(sizeof(cmd->sw_rf.status));\n\tswitch (state) {\n\tcase WIMAX_RF_OFF:\t/* RFKILL ON, radio OFF */\n\t\tcmd->sw_rf.status = cpu_to_le32(2);\n\t\tbreak;\n\tcase WIMAX_RF_ON:\t/* RFKILL OFF, radio ON */\n\t\tcmd->sw_rf.status = cpu_to_le32(1);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tack_skb = i2400m_msg_to_dev(i2400m, cmd, sizeof(*cmd));\n\tresult = PTR_ERR(ack_skb);\n\tif (IS_ERR(ack_skb)) {\n\t\tdev_err(dev, \"Failed to issue 'RF Control' command: %d\\n\",\n\t\t\tresult);\n\t\tgoto error_msg_to_dev;\n\t}\n\tresult = i2400m_msg_check_status(wimax_msg_data(ack_skb),\n\t\t\t\t\t strerr, sizeof(strerr));\n\tif (result < 0) {\n\t\tdev_err(dev, \"'RF Control' (0x%04x) command failed: %d - %s\\n\",\n\t\t\tI2400M_MT_CMD_RF_CONTROL, result, strerr);\n\t\tgoto error_cmd;\n\t}\n\n\t/* Now we wait for the state to change to RADIO_OFF or RADIO_ON */\n\tresult = wait_event_timeout(\n\t\ti2400m->state_wq, i2400m_radio_is(i2400m, state),\n\t\t5 * HZ);\n\tif (result == 0)\n\t\tresult = -ETIMEDOUT;\n\tif (result < 0)\n\t\tdev_err(dev, \"Error waiting for device to toggle RF state: \"\n\t\t\t\"%d\\n\", result);\n\tresult = 0;\nerror_cmd:\n\tkfree_skb(ack_skb);\nerror_msg_to_dev:\nerror_alloc:\n\td_fnend(4, dev, \"(wimax_dev %p state %d) = %d\\n\",\n\t\twimax_dev, state, result);\n\tkfree(cmd);\n\treturn result;\n}\n\n\n/*\n * Inform the WiMAX stack of changes in the RF Kill switches reported\n * by the device\n *\n * @i2400m: device descriptor\n * @rfss: TLV for RF Switches status; already validated\n *\n * NOTE: the reports on RF switch status cannot be trusted\n *       or used until the device is in a state of RADIO_OFF\n *       or greater.\n */\nvoid i2400m_report_tlv_rf_switches_status(\n\tstruct i2400m *i2400m,\n\tconst struct i2400m_tlv_rf_switches_status *rfss)\n{\n\tstruct device *dev = i2400m_dev(i2400m);\n\tenum i2400m_rf_switch_status hw, sw;\n\tenum wimax_st wimax_state;\n\n\tsw = le32_to_cpu(rfss->sw_rf_switch);\n\thw = le32_to_cpu(rfss->hw_rf_switch);\n\n\td_fnstart(3, dev, \"(i2400m %p rfss %p [hw %u sw %u])\\n\",\n\t\t  i2400m, rfss, hw, sw);\n\t/* We only process rw switch evens when the device has been\n\t * fully initialized */\n\twimax_state = wimax_state_get(&i2400m->wimax_dev);\n\tif (wimax_state < WIMAX_ST_RADIO_OFF) {\n\t\td_printf(3, dev, \"ignoring RF switches report, state %u\\n\",\n\t\t\t wimax_state);\n\t\tgoto out;\n\t}\n\tswitch (sw) {\n\tcase I2400M_RF_SWITCH_ON:\t/* RF Kill disabled (radio on) */\n\t\twimax_report_rfkill_sw(&i2400m->wimax_dev, WIMAX_RF_ON);\n\t\tbreak;\n\tcase I2400M_RF_SWITCH_OFF:\t/* RF Kill enabled (radio off) */\n\t\twimax_report_rfkill_sw(&i2400m->wimax_dev, WIMAX_RF_OFF);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"HW BUG? Unknown RF SW state 0x%x\\n\", sw);\n\t}\n\n\tswitch (hw) {\n\tcase I2400M_RF_SWITCH_ON:\t/* RF Kill disabled (radio on) */\n\t\twimax_report_rfkill_hw(&i2400m->wimax_dev, WIMAX_RF_ON);\n\t\tbreak;\n\tcase I2400M_RF_SWITCH_OFF:\t/* RF Kill enabled (radio off) */\n\t\twimax_report_rfkill_hw(&i2400m->wimax_dev, WIMAX_RF_OFF);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"HW BUG? Unknown RF HW state 0x%x\\n\", hw);\n\t}\nout:\n\td_fnend(3, dev, \"(i2400m %p rfss %p [hw %u sw %u]) = void\\n\",\n\t\ti2400m, rfss, hw, sw);\n}\n"], "filenames": ["drivers/net/wimax/i2400m/op-rfkill.c"], "buggy_code_start_loc": [130], "buggy_code_end_loc": [135], "fixing_code_start_loc": [129], "fixing_code_end_loc": [136], "type": "CWE-401", "message": "A memory leak in the i2400m_op_rfkill_sw_toggle() function in drivers/net/wimax/i2400m/op-rfkill.c in the Linux kernel before 5.3.11 allows attackers to cause a denial of service (memory consumption), aka CID-6f3ef5c25cc7.", "other": {"cve": {"id": "CVE-2019-19051", "sourceIdentifier": "cve@mitre.org", "published": "2019-11-18T06:15:11.747", "lastModified": "2022-11-07T14:55:55.527", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A memory leak in the i2400m_op_rfkill_sw_toggle() function in drivers/net/wimax/i2400m/op-rfkill.c in the Linux kernel before 5.3.11 allows attackers to cause a denial of service (memory consumption), aka CID-6f3ef5c25cc7."}, {"lang": "es", "value": "Una p\u00e9rdida de memoria en la funci\u00f3n i2400m_op_rfkill_sw_toggle() en el archivo drivers/net/wimax/i2400m/op-rfkill.c en el kernel de Linux versiones anteriores a la versi\u00f3n 5.3.11, permite a atacantes causar una denegaci\u00f3n de servicio (consumo de memoria), tambi\u00e9n se conoce como CID-6f3ef5c25cc7."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.3.11", "matchCriteriaId": "AFBC7FC6-5284-45A6-AEF0-98EE91D9A0A5"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-03/msg00021.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.3.11", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/6f3ef5c25cc762687a7341c18cbea5af54461407", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/01/msg00013.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/03/msg00001.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20191205-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4225-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4225-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4286-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4286-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4302-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4344-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/6f3ef5c25cc762687a7341c18cbea5af54461407"}}