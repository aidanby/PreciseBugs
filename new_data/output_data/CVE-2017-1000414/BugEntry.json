{"buggy_code": ["// JPEGsnoop - JPEG Image Decoder & Analysis Utility\r\n// Copyright (C) 2015 - Calvin Hass\r\n// http://www.impulseadventure.com/photo/jpeg-snoop.html\r\n//\r\n//    This program is free software: you can redistribute it and/or modify\r\n//    it under the terms of the GNU General Public License as published by\r\n//    the Free Software Foundation, either version 2 of the License, or\r\n//    (at your option) any later version.\r\n//\r\n//    This program is distributed in the hope that it will be useful,\r\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n//    GNU General Public License for more details.\r\n//\r\n//    You should have received a copy of the GNU General Public License\r\n//    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n//\r\n\r\n\r\n\r\n#include \"stdafx.h\"\r\n\r\n#include \"JfifDecode.h\"\r\n#include \"snoop.h\"\r\n#include \"JPEGsnoop.h\" // for m_pAppConfig get\r\n\r\n#include \"WindowBuf.h\"\r\n\r\n#include \"Md5.h\"\r\n\r\n#include \"afxinet.h\"\r\n\r\n#include \"windows.h\"\r\n#include \"UrlString.h\"\r\n#include \"DbSigs.h\"\r\n\r\n#include \"General.h\"\r\n\r\n\r\n\r\n// Maximum number of component values to extract into array for display\r\n#define MAX_anValues\t64\r\n\r\n\r\n// Clear out internal members\r\nvoid CjfifDecode::Reset()\r\n{\r\n\t// File handling\r\n\tm_nPos\t\t\t\t= 0;\r\n\tm_nPosSos\t\t\t= 0;\r\n\tm_nPosEoi\t\t\t= 0;\r\n\tm_nPosEmbedStart\t= 0;\r\n\tm_nPosEmbedEnd\t\t= 0;\r\n\tm_nPosFileEnd\t\t= 0;\r\n\r\n\t// SOS / SOF handling\r\n\tm_nSofNumLines_Y\t\t= 0;\r\n\tm_nSofSampsPerLine_X\t= 0;\r\n\tm_nSofNumComps_Nf\t\t= 0;\r\n\r\n\t// Quantization tables\r\n\tClearDQT();\r\n\r\n\t// Photoshop\r\n\tm_nImgQualPhotoshopSfw\t= 0;\r\n\tm_nImgQualPhotoshopSa\t= 0;\r\n\r\n\tm_nApp14ColTransform = -1;\r\n\r\n\t// Restart marker\r\n\tm_nImgRstEn\t\t\t\t= false;\r\n\tm_nImgRstInterval\t\t= 0;\r\n\r\n\t// Basic metadata\r\n\tm_strImgExifMake\t\t= _T(\"???\");\r\n\tm_nImgExifMakeSubtype\t= 0;\r\n\tm_strImgExifModel\t\t= _T(\"???\");\r\n\tm_bImgExifMakernotes\t= false;\r\n\tm_strImgExtras\t\t\t= _T(\"\");\r\n\tm_strComment\t\t\t= _T(\"\");\r\n\tm_strSoftware\t\t\t= _T(\"\");\r\n\tm_bImgProgressive\t\t= false;\r\n\tm_bImgSofUnsupported\t= false;\r\n\t_tcscpy_s(m_acApp0Identifier,_T(\"\"));\r\n\r\n\t// Derived metadata\r\n\tm_strHash\t\t\t\t= _T(\"NONE\");\r\n\tm_strHashRot\t\t\t= _T(\"NONE\");\r\n\tm_eImgLandscape\t\t\t= ENUM_LANDSCAPE_UNSET;\r\n\tm_strImgQualExif\t\t= _T(\"\");\r\n\tm_bAvi\t\t\t\t\t= false;\r\n\tm_bAviMjpeg\t\t\t\t= false;\r\n\tm_bPsd\t\t\t\t\t= false;\r\n\r\n\t// Misc\r\n\tm_bImgOK\t\t\t\t= false;\t\t// Set during SOF to indicate further proc OK\r\n\tm_bBufFakeDHT\t   \t\t= false;\t\t\t// Start in normal Buf mode\r\n\tm_eImgEdited\t\t\t= EDITED_UNSET;\r\n\tm_eDbReqSuggest\t \t\t= DB_ADD_SUGGEST_UNSET;\r\n\tm_bSigExactInDB\t \t\t= false;\r\n\r\n\t// Embedded thumbnail\r\n\tm_nImgExifThumbComp\t\t= 0;\r\n\tm_nImgExifThumbOffset\t= 0;\r\n\tm_nImgExifThumbLen\t\t= 0;\r\n\tm_strHashThumb\t\t\t= _T(\"NONE\");\t\t// Will go into DB to say NONE!\r\n\tm_strHashThumbRot\t\t= _T(\"NONE\");\t\t// Will go into DB to say NONE!\r\n\tm_nImgThumbNumLines\t\t= 0;\r\n\tm_nImgThumbSampsPerLine\t= 0;\r\n\r\n\t// Now clear out any previously generated bitmaps\r\n\t// or image decoding parameters\r\n\tif (m_pImgDec) {\r\n\t\tif (m_pImgSrcDirty) {\r\n\t\t\tm_pImgDec->Reset();\r\n\t\t}\r\n\t}\r\n\r\n\t// Reset the decoding state checks\r\n\t// These are to help ensure we don't start decoding SOS\r\n\t// if we haven't seen other valid markers yet! Otherwise\r\n\t// we could run into very bad loops (e.g. .PSD files)\r\n\t// just because we saw FFD8FF first then JFIF_SOS\r\n\tm_bStateAbort\t= false;\r\n\tm_bStateSoi\t\t= false;\r\n\tm_bStateDht\t\t= false;\r\n\tm_bStateDhtOk\t= false;\r\n\tm_bStateDhtFake = false;\r\n\tm_bStateDqt\t\t= false;\r\n\tm_bStateDqtOk\t= false;\r\n\tm_bStateSof\t\t= false;\r\n\tm_bStateSofOk\t= false;\r\n\tm_bStateSos\t\t= false;\r\n\tm_bStateSosOk\t= false;\r\n\tm_bStateEoi\t\t= false;\r\n\r\n}\r\n\r\n\r\n// Initialize the JFIF decoder. Several class pointers are provided\r\n// as parameters, so that we can directly access the output log, the\r\n// file buffer and the image scan decoder.\r\n// Loads up the signature database.\r\n//\r\n// INPUT:\r\n// - pLog\t\t\tPtr to log file class\r\n// - pWBuf\t\t\tPtr to Window Buf class\r\n// - pImgDec\t\tPtr to Image Decoder class\r\n//\r\n// PRE:\r\n// - Requires that CDocLog, CwindowBuf and CimgDecode classes\r\n//   are already initialized\r\n//\r\nCjfifDecode::CjfifDecode(CDocLog* pLog,CwindowBuf* pWBuf,CimgDecode* pImgDec)\r\n{\r\n\t// Ideally this would be passed by constructor, but simply access\r\n\t// directly for now.\r\n\tCJPEGsnoopApp*\tpApp;\r\n\tpApp = (CJPEGsnoopApp*)AfxGetApp();\r\n    m_pAppConfig = pApp->m_pAppConfig;\r\n\tASSERT(m_pAppConfig);\r\n\tif (DEBUG_EN) m_pAppConfig->DebugLogAdd(_T(\"CjfifDecode::CjfifDecode() Begin\"));\r\n\r\n\tASSERT(pLog);\r\n\tASSERT(pWBuf);\r\n\tASSERT(pImgDec);\r\n\r\n\t// Need to zero out the private members\r\n\tm_bOutputDB = FALSE;\t\t// mySQL output for web\r\n\r\n\t// Enable verbose reporting\r\n\tm_bVerbose = FALSE;\r\n\r\n\tm_pImgSrcDirty = TRUE;\r\n\r\n\t// Generate lookup tables for Huffman codes\r\n\tGenLookupHuffMask();\r\n\tif (DEBUG_EN) m_pAppConfig->DebugLogAdd(_T(\"CjfifDecode::CjfifDecode() Checkpoint 1\"));\r\n\r\n\t// Window status bar is not ready yet, wait for call to SetStatusBar()\r\n\tm_pStatBar = NULL;\r\n\r\n\t// Save copies of other class pointers\r\n\tm_pLog = pLog;\r\n\tm_pWBuf = pWBuf;\r\n\tm_pImgDec = pImgDec;\r\n\r\n\t// Reset decoding state\r\n\tReset();\r\n\tif (DEBUG_EN) m_pAppConfig->DebugLogAdd(_T(\"CjfifDecode::CjfifDecode() Checkpoint 2\"));\r\n\r\n\t// Load the local database (if it exists)\r\n\ttheApp.m_pDbSigs->DatabaseExtraLoad();\r\n\tif (DEBUG_EN) m_pAppConfig->DebugLogAdd(_T(\"CjfifDecode::CjfifDecode() Checkpoint 3\"));\r\n\r\n\t// Allocate the Photoshop decoder\r\n\tm_pPsDec = new CDecodePs(pWBuf,pLog);\r\n\tif (!m_pPsDec) {\r\n\t\tASSERT(false);\r\n\t\treturn;\r\n\t}\r\n\tif (DEBUG_EN) m_pAppConfig->DebugLogAdd(_T(\"CjfifDecode::CjfifDecode() Checkpoint 4\"));\r\n\r\n#ifdef SUPPORT_DICOM\r\n\t// Allocate the DICOM decoder\r\n\tm_pDecDicom = new CDecodeDicom(pWBuf,pLog);\r\n\tif (!m_pDecDicom) {\r\n\t\tASSERT(false);\r\n\t\treturn;\r\n\t}\r\n\tif (DEBUG_EN) m_pAppConfig->DebugLogAdd(_T(\"CjfifDecode::CjfifDecode() Checkpoint 5\"));\r\n#endif\r\n\r\n\tif (DEBUG_EN) m_pAppConfig->DebugLogAdd(_T(\"CjfifDecode::CjfifDecode() End\"));\r\n}\r\n\r\n// Destructor\r\nCjfifDecode::~CjfifDecode()\r\n{\r\n\t// Free the Photoshop decoder\r\n\tif (m_pPsDec) {\r\n\t\tdelete m_pPsDec;\r\n\t\tm_pPsDec = NULL;\r\n\t}\r\n\r\n#ifdef SUPPORT_DICOM\r\n\t// Free the DICOM decoder\r\n\tif (m_pDecDicom) {\r\n\t\tdelete m_pDecDicom;\r\n\t\tm_pDecDicom = NULL;\r\n\t}\r\n#endif\r\n\r\n}\r\n\r\n// Asynchronously update a local pointer to the status bar once\r\n// it becomes available. Note that the status bar is not ready by\r\n// the time of the CjfifDecode class constructor call.\r\n//\r\n// INPUT:\r\n// - pStatBar\t\t\tPtr to status bar\r\n//\r\n// POST:\r\n// - m_pStatBar\r\n//\r\nvoid CjfifDecode::SetStatusBar(CStatusBar* pStatBar)\r\n{\r\n\tm_pStatBar = pStatBar;\r\n}\r\n\r\n\r\n// Indicate that the source of the image scan data\r\n// has been dirtied. Either the source has changed\r\n// or some of the View2 options have changed.\r\n//\r\n// POST:\r\n// - m_pImgSrcDirty\r\n//\r\nvoid CjfifDecode::ImgSrcChanged()\r\n{\r\n\tm_pImgSrcDirty = true;\r\n}\r\n\r\n\r\n// Set the AVI mode flag for this file\r\n//\r\n// POST:\r\n// - m_bAvi\r\n// - m_bAviMjpeg\r\n//\r\nvoid CjfifDecode::SetAviMode(bool bIsAvi,bool bIsMjpeg)\r\n{\r\n\tm_bAvi = bIsAvi;\r\n\tm_bAviMjpeg = bIsMjpeg;\r\n}\r\n\r\n// Fetch the AVI mode flag for this file\r\n//\r\n// PRE:\r\n// - m_bAvi\r\n// - m_bAviMjpeg\r\n//\r\n// OUTPUT:\r\n// - bIsAvi\r\n// - bIsMjpeg\r\n//\r\nvoid CjfifDecode::GetAviMode(bool &bIsAvi,bool &bIsMjpeg)\r\n{\r\n\tbIsAvi = m_bAvi;\r\n\tbIsMjpeg = m_bAviMjpeg;\r\n}\r\n\r\n// Fetch the starting file position of the embedded thumbnail\r\n//\r\n// PRE:\r\n// - m_nPosEmbedStart\r\n//\r\n// RETURN:\r\n// - File position\r\n//\r\nunsigned long CjfifDecode::GetPosEmbedStart()\r\n{\r\n\treturn m_nPosEmbedStart;\r\n}\r\n\r\n// Fetch the ending file position of the embedded thumbnail\r\n//\r\n// PRE:\r\n// - m_nPosEmbedEnd\r\n//\r\n// RETURN:\r\n// - File position\r\n//\r\nunsigned long CjfifDecode::GetPosEmbedEnd()\r\n{\r\n\treturn m_nPosEmbedEnd;\r\n}\r\n\r\n// Determine if the last analysis revealed a JFIF with known markers\r\n//\r\n// RETURN:\r\n// - TRUE if file (at position during analysis) appeared to decode OK\r\n//\r\nbool CjfifDecode::GetDecodeStatus()\r\n{\r\n\treturn m_bImgOK;\r\n}\r\n\r\n// Fetch a summary of the JFIF decoder results\r\n// These details are used in preparation of signature submission to the DB\r\n//\r\n// PRE:\r\n// - m_strHash\r\n// - m_strHashRot\r\n// - m_strImgExifMake\r\n// - m_strImgExifModel\r\n// - m_strImgQualExif\r\n// - m_strSoftware\r\n// - m_eDbReqSuggest\r\n//\r\n// OUTPUT:\r\n// - strHash\r\n// - strHashRot\r\n// - strImgExifMake\r\n// - strImgExifModel\r\n// - strImgQualExif\r\n// - strSoftware\r\n// - nDbReqSuggest\r\n//\r\nvoid CjfifDecode::GetDecodeSummary(CString &strHash,CString &strHashRot,CString &strImgExifMake,CString &strImgExifModel,\r\n\t\t\t\t\t\t\tCString &strImgQualExif,CString &strSoftware,teDbAdd &eDbReqSuggest)\r\n{\r\n\tstrHash = m_strHash;\r\n\tstrHashRot = m_strHashRot;\r\n\tstrImgExifMake = m_strImgExifMake;\r\n\tstrImgExifModel = m_strImgExifModel;\r\n\tstrImgQualExif = m_strImgQualExif;\r\n\tstrSoftware = m_strSoftware;\r\n\teDbReqSuggest = m_eDbReqSuggest;\r\n}\r\n\r\n// Fetch an element from the \"standard\" luminance quantization table\r\n//\r\n// PRE:\r\n// - glb_anStdQuantLum[]\r\n//\r\n// RETURN:\r\n// - DQT matrix element\r\n//\r\nunsigned CjfifDecode::GetDqtQuantStd(unsigned nInd)\r\n{\r\n\tif (nInd < MAX_DQT_COEFF) {\r\n\t\treturn glb_anStdQuantLum[nInd];\r\n\t} else {\r\n#ifdef DEBUG_LOG\r\n\t\tCString\tstrTmp;\r\n\t\tCString\tstrDebug;\r\n\t\tstrTmp.Format(_T(\"GetDqtQuantStd() with nInd out of range. nInd=[%u]\"),nInd);\r\n\t\tstrDebug.Format(_T(\"## File=[%-100s] Block=[%-10s] Error=[%s]\\n\"),(LPCTSTR)m_pAppConfig->strCurFname,\r\n\t\t\t_T(\"JfifDecode\"),(LPCTSTR)strTmp);\r\n\t\tOutputDebugString(strDebug);\r\n#else\r\n\t\tASSERT(false);\r\n#endif\r\n\t\treturn 0;\r\n\t}\r\n}\r\n\r\n// Fetch the DQT ordering index (with optional zigzag sequence)\r\n//\r\n// INPUT:\r\n// - nInd\t\t\tCoefficient index\r\n// - bZigZag\t\tUse zig-zag ordering\r\n//\r\n// RETURN:\r\n// - Sequence index\r\n//\r\nunsigned CjfifDecode::GetDqtZigZagIndex(unsigned nInd,bool bZigZag)\r\n{\r\n\tif (nInd < MAX_DQT_COEFF) {\r\n\t\tif (bZigZag) {\r\n\t\t\treturn nInd;\r\n\t\t} else {\r\n\t\t\treturn glb_anZigZag[nInd];\r\n\t\t}\r\n\t} else {\r\n#ifdef DEBUG_LOG\r\n\t\tCString\tstrTmp;\r\n\t\tCString\tstrDebug;\r\n\t\tstrTmp.Format(_T(\"GetDqtZigZagIndex() with nInd out of range. nInd=[%u]\"),nInd);\r\n\t\tstrDebug.Format(_T(\"## File=[%-100s] Block=[%-10s] Error=[%s]\\n\"),(LPCTSTR)m_pAppConfig->strCurFname,\r\n\t\t\t_T(\"JfifDecode\"),(LPCTSTR)strTmp);\r\n\t\tOutputDebugString(strDebug);\r\n#else\r\n\t\tASSERT(false);\r\n#endif\r\n\t\treturn 0;\r\n\t}\r\n}\r\n\r\n// Reset the DQT tables\r\n//\r\n// POST:\r\n// - m_anImgDqtTbl[][]\r\n// - m_anImgThumbDqt[][]\r\n// - m_adImgDqtQual[]\r\n// - m_abImgDqtSet[]\r\n// - m_abImgDqtThumbSet[]\r\n//\r\nvoid CjfifDecode::ClearDQT()\r\n{\r\n\tfor (unsigned nTblInd=0;nTblInd<MAX_DQT_DEST_ID;nTblInd++)\r\n\t{\r\n\t\tfor (unsigned nCoeffInd=0;nCoeffInd<MAX_DQT_COEFF;nCoeffInd++)\r\n\t\t{\r\n\t\t\tm_anImgDqtTbl[nTblInd][nCoeffInd] = 0;\r\n\t\t\tm_anImgThumbDqt[nTblInd][nCoeffInd] = 0;\r\n\t\t}\r\n\t\tm_adImgDqtQual[nTblInd] = 0;\r\n\t\tm_abImgDqtSet[nTblInd] = false;\r\n\t\tm_abImgDqtThumbSet[nTblInd] = false;\r\n\t}\r\n}\r\n\r\n// Set the DQT matrix element\r\n//\r\n// INPUT:\r\n// - dqt0[]\t\t\t\tMatrix array for table 0\r\n// - dqt1[]\t\t\t\tMatrix array for table 1\r\n//\r\n// POST:\r\n// - m_anImgDqtTbl[][]\r\n// - m_eImgLandscape\r\n// - m_abImgDqtSet[]\r\n// - m_strImgQuantCss\r\n//\r\nvoid CjfifDecode::SetDQTQuick(unsigned anDqt0[64],unsigned anDqt1[64])\r\n{\r\n\tm_eImgLandscape = ENUM_LANDSCAPE_YES;\r\n\tfor (unsigned ind=0;ind<MAX_DQT_COEFF;ind++)\r\n\t{\r\n\t\tm_anImgDqtTbl[0][ind] = anDqt0[ind];\r\n\t\tm_anImgDqtTbl[1][ind] = anDqt1[ind];\r\n\t}\r\n\tm_abImgDqtSet[0] = true;\r\n\tm_abImgDqtSet[1] = true;\r\n\tm_strImgQuantCss = _T(\"NA\");\r\n}\r\n\r\n// Construct a lookup table for the Huffman code masks\r\n// The result is a simple bit sequence of zeros followed by\r\n// an increasing number of 1 bits.\r\n//   00000000...00000001\r\n//   00000000...00000011\r\n//   00000000...00000111\r\n//   ...\r\n//   01111111...11111111\r\n//   11111111...11111111\r\n//\r\n// POST:\r\n// - m_anMaskLookup[]\r\n//\r\nvoid CjfifDecode::GenLookupHuffMask()\r\n{\r\n\tunsigned int mask;\r\n\tfor (unsigned len=0;len<32;len++)\r\n\t{\r\n\t\tmask = (1 << (len))-1;\r\n\t\tmask <<= 32-len;\r\n\t\tm_anMaskLookup[len] = mask;\r\n\t}\r\n}\r\n\r\n\r\n// Provide a short-hand alias for the m_pWBuf buffer\r\n// Also support redirection to a local table in case we are\r\n// faking out the DHT (eg. for MotionJPEG files).\r\n//\r\n// PRE:\r\n// - m_bBufFakeDHT\t\t\tFlag to include Fake DHT table\r\n// - m_abMJPGDHTSeg[]\t\tDHT table used if m_bBufFakeDHT=true\r\n//\r\n// INPUT:\r\n// - nOffset\t\t\t\tFile offset to read from\r\n// - bClean\t\t\t\t\tForcibly disables any redirection to Fake DHT table\r\n//\r\n// POST:\r\n// - m_pLog\r\n//\r\n// RETURN:\r\n// - Byte from file (or local table)\r\n//\r\nBYTE CjfifDecode::Buf(unsigned long nOffset,bool bClean=false)\r\n{\r\n\t// Buffer can be redirected to internal array for AVI DHT\r\n\t// tables, so check for it here.\r\n\tif (m_bBufFakeDHT) {\r\n\t\treturn m_abMJPGDHTSeg[nOffset];\r\n\t} else {\r\n\t\treturn m_pWBuf->Buf(nOffset,bClean);\r\n\t}\r\n}\r\n\r\n// Write out a line to the log buffer if we are in verbose mode\r\n//\r\n// PRE:\r\n// - m_bVerbose\t\t\t\tVerbose mode\r\n//\r\n// INPUT:\r\n// - strLine\t\t\t\tString to output\r\n//\r\n// OUTPUT:\r\n// - none\r\n//\r\n// POST:\r\n// - m_pLog\r\n//\r\n// RETURN:\r\n// - none\r\n//\r\nvoid CjfifDecode::DbgAddLine(LPCTSTR strLine)\r\n{\r\n\tif (m_bVerbose)\r\n\t{\r\n\t\tm_pLog->AddLine(strLine);\r\n\t}\r\n}\r\n\r\n// Convert a UINT32 and decompose into 4 bytes, but support\r\n// either endian byte-swap mode\r\n//\r\n// PRE:\r\n// - m_nImgExifEndian\t\tByte swap mode (0=little, 1=big)\r\n//\r\n// INPUT:\r\n// - nVal\t\t\t\t\tInput UINT32\r\n//\r\n// OUTPUT:\r\n// - nByte0\t\t\t\t\tByte #1\r\n// - nByte1\t\t\t\t\tByte #2\r\n// - nByte2\t\t\t\t\tByte #3\r\n// - nByte3\t\t\t\t\tByte #4\r\n//\r\n// RETURN:\r\n// - none\r\n//\r\nvoid CjfifDecode::UnByteSwap4(unsigned nVal,unsigned &nByte0,unsigned &nByte1,unsigned &nByte2,unsigned &nByte3)\r\n{\r\n\tif (m_nImgExifEndian == 0) {\r\n\t\t// Little Endian\r\n\t\tnByte3 = (nVal & 0xFF000000) >> 24;\r\n\t\tnByte2 = (nVal & 0x00FF0000) >> 16;\r\n\t\tnByte1 = (nVal & 0x0000FF00) >> 8;\r\n\t\tnByte0 = (nVal & 0x000000FF);\r\n\t} else {\r\n\t\t// Big Endian\r\n\t\tnByte0 = (nVal & 0xFF000000) >> 24;\r\n\t\tnByte1 = (nVal & 0x00FF0000) >> 16;\r\n\t\tnByte2 = (nVal & 0x0000FF00) >> 8;\r\n\t\tnByte3 = (nVal & 0x000000FF);\r\n\t}\r\n}\r\n\r\n// Perform conversion from 4 bytes into UINT32 with\r\n// endian byte-swapping support\r\n//\r\n// PRE:\r\n// - m_nImgExifEndian\t\tByte swap mode (0=little, 1=big)\r\n//\r\n// INPUT:\r\n// - nByte0\t\t\t\t\t\tByte #1\r\n// - nByte1\t\t\t\t\t\tByte #2\r\n// - nByte2\t\t\t\t\t\tByte #3\r\n// - nByte3\t\t\t\t\t\tByte #4\r\n//\r\n// RETURN:\r\n// - UINT32\r\n//\r\nunsigned CjfifDecode::ByteSwap4(unsigned nByte0,unsigned nByte1, unsigned nByte2, unsigned nByte3)\r\n{\r\n\tunsigned nVal;\r\n\r\n\tif (m_nImgExifEndian == 0) {\r\n\t\t// Little endian, byte swap required\r\n\t\tnVal = (nByte3<<24) + (nByte2<<16) + (nByte1<<8) + nByte0;\r\n\t} else {\r\n\t\t// Big endian, no swap required\r\n\t\tnVal = (nByte0<<24) + (nByte1<<16) + (nByte2<<8) + nByte3;\r\n\t}\r\n\treturn nVal;\r\n}\r\n\r\n// Perform conversion from 2 bytes into half-word with\r\n// endian byte-swapping support\r\n//\r\n// PRE:\r\n// - m_nImgExifEndian\t\tByte swap mode (0=little, 1=big)\r\n//\r\n// INPUT:\r\n// - nByte0\t\t\t\t\t\tByte #1\r\n// - nByte1\t\t\t\t\t\tByte #2\r\n//\r\n// RETURN:\r\n// - UINT16\r\n//\r\nunsigned CjfifDecode::ByteSwap2(unsigned nByte0,unsigned nByte1)\r\n{\r\n\tunsigned nVal;\r\n\tif (m_nImgExifEndian == 0) {\r\n\t\t// Little endian, byte swap required\r\n\t\tnVal = (nByte1<<8) + nByte0;\r\n\t} else {\r\n\t\t// Big endian, no swap required\r\n\t\tnVal = (nByte0<<8) + nByte1;\r\n\t}\r\n\treturn nVal;\r\n}\r\n\r\n// Decode Canon Makernotes\r\n// Only the most common makernotes are supported; there are a large\r\n// number of makernotes that have not been documented anywhere.\r\nCStr2 CjfifDecode::LookupMakerCanonTag(unsigned nMainTag,unsigned nSubTag,unsigned nVal)\r\n{\r\n\tCString\t\tstrTmp;\r\n\tCStr2\t\tsRetVal;\r\n\r\n\tsRetVal.strTag = _T(\"???\");\r\n\tsRetVal.bUnknown = false;\t\t\t\t// Set to true in default clauses\r\n\tsRetVal.strVal.Format(_T(\"%u\"),nVal);\t// Provide default value\r\n\r\n\tunsigned nValHi,nValLo;\r\n\tnValHi = (nVal & 0xff00) >> 8;\r\n\tnValLo = (nVal & 0x00ff);\r\n\r\n\tswitch(nMainTag)\r\n\t{\r\n\r\n\tcase 0x0001:\r\n\r\n\t\tswitch(nSubTag)\r\n\t\t{\r\n\t\tcase 0x0001: sRetVal.strTag = _T(\"Canon.Cs1.Macro\");break; // Short Macro mode \r\n\t\tcase 0x0002: sRetVal.strTag = _T(\"Canon.Cs1.Selftimer\");break; // Short Self timer \r\n\t\tcase 0x0003: sRetVal.strTag = _T(\"Canon.Cs1.Quality\");\r\n\t\t\tif (nVal == 2) { sRetVal.strVal = _T(\"norm\"); }\r\n\t\t\telse if (nVal == 3) { sRetVal.strVal = _T(\"fine\"); }\r\n\t\t\telse if (nVal == 5) { sRetVal.strVal = _T(\"superfine\"); }\r\n\t\t\telse {\r\n\t\t\t\tsRetVal.strVal = _T(\"?\");\r\n\t\t\t}\r\n\t\t\t// Save the quality string for later\r\n\t\t\tm_strImgQualExif = sRetVal.strVal;\r\n\t\t\tbreak; // Short Quality \r\n\t\tcase 0x0004: sRetVal.strTag = _T(\"Canon.Cs1.FlashMode\");break; // Short Flash mode setting \r\n\t\tcase 0x0005: sRetVal.strTag = _T(\"Canon.Cs1.DriveMode\");break; // Short Drive mode setting \r\n\t\tcase 0x0007: sRetVal.strTag = _T(\"Canon.Cs1.FocusMode\"); // Short Focus mode setting \r\n\t\t\tswitch(nVal) {\r\n\t\t\t\tcase 0 : sRetVal.strVal = _T(\"One-shot\");break;\r\n\t\t\t\tcase 1 : sRetVal.strVal = _T(\"AI Servo\");break;\r\n\t\t\t\tcase 2 : sRetVal.strVal = _T(\"AI Focus\");break;\r\n\t\t\t\tcase 3 : sRetVal.strVal = _T(\"Manual Focus\");break;\r\n\t\t\t\tcase 4 : sRetVal.strVal = _T(\"Single\");break;\r\n\t\t\t\tcase 5 : sRetVal.strVal = _T(\"Continuous\");break;\r\n\t\t\t\tcase 6 : sRetVal.strVal = _T(\"Manual Focus\");break;\r\n\t\t\t\tdefault : sRetVal.strVal = _T(\"?\");break;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 0x000a: sRetVal.strTag = _T(\"Canon.Cs1.ImageSize\"); // Short Image size \r\n\t\t\tif (nVal == 0) { sRetVal.strVal = _T(\"Large\"); }\r\n\t\t\telse if (nVal == 1) { sRetVal.strVal = _T(\"Medium\"); }\r\n\t\t\telse if (nVal == 2) { sRetVal.strVal = _T(\"Small\"); }\r\n\t\t\telse {\r\n\t\t\t\tsRetVal.strVal = _T(\"?\");\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 0x000b: sRetVal.strTag = _T(\"Canon.Cs1.EasyMode\");break; // Short Easy shooting mode \r\n\t\tcase 0x000c: sRetVal.strTag = _T(\"Canon.Cs1.DigitalZoom\");break; // Short Digital zoom \r\n\t\tcase 0x000d: sRetVal.strTag = _T(\"Canon.Cs1.Contrast\");break; // Short Contrast setting \r\n\t\tcase 0x000e: sRetVal.strTag = _T(\"Canon.Cs1.Saturation\");break; // Short Saturation setting \r\n\t\tcase 0x000f: sRetVal.strTag = _T(\"Canon.Cs1.Sharpness\");break; // Short Sharpness setting \r\n\t\tcase 0x0010: sRetVal.strTag = _T(\"Canon.Cs1.ISOSpeed\");break; // Short ISO speed setting \r\n\t\tcase 0x0011: sRetVal.strTag = _T(\"Canon.Cs1.MeteringMode\");break; // Short Metering mode setting \r\n\t\tcase 0x0012: sRetVal.strTag = _T(\"Canon.Cs1.FocusType\");break; // Short Focus type setting \r\n\t\tcase 0x0013: sRetVal.strTag = _T(\"Canon.Cs1.AFPoint\");break; // Short AF point selected \r\n\t\tcase 0x0014: sRetVal.strTag = _T(\"Canon.Cs1.ExposureProgram\");break; // Short Exposure mode setting \r\n\t\tcase 0x0016: sRetVal.strTag = _T(\"Canon.Cs1.LensType\");break; // \r\n\t\tcase 0x0017: sRetVal.strTag = _T(\"Canon.Cs1.Lens\");break; // Short 'long' and 'short' focal length of lens (in 'focal m_nImgUnits') and 'focal m_nImgUnits' per mm \r\n\t\tcase 0x001a: sRetVal.strTag = _T(\"Canon.Cs1.MaxAperture\");break; // \r\n\t\tcase 0x001b: sRetVal.strTag = _T(\"Canon.Cs1.MinAperture\");break; // \r\n\t\tcase 0x001c: sRetVal.strTag = _T(\"Canon.Cs1.FlashActivity\");break; // Short Flash activity \r\n\t\tcase 0x001d: sRetVal.strTag = _T(\"Canon.Cs1.FlashDetails\");break; // Short Flash details \r\n\t\tcase 0x0020: sRetVal.strTag = _T(\"Canon.Cs1.FocusMode\");break; // Short Focus mode setting \r\n\t\tdefault:\r\n\t\t\tsRetVal.strTag.Format(_T(\"Canon.Cs1.x%04X\"),nSubTag);\r\n\t\t\tsRetVal.bUnknown = true;\r\n\t\t\tbreak;\r\n\t\t} // switch nSubTag\r\n\t\tbreak;\r\n\r\n\tcase 0x0004:\r\n\r\n\t\tswitch(nSubTag)\r\n\t\t{\r\n\t\tcase 0x0002: sRetVal.strTag = _T(\"Canon.Cs2.ISOSpeed\");break; // Short ISO speed used \r\n\t\tcase 0x0004: sRetVal.strTag = _T(\"Canon.Cs2.TargetAperture\");break; // Short Target Aperture \r\n\t\tcase 0x0005: sRetVal.strTag = _T(\"Canon.Cs2.TargetShutterSpeed\");break; // Short Target shutter speed \r\n\t\tcase 0x0007: sRetVal.strTag = _T(\"Canon.Cs2.WhiteBalance\");break; // Short White balance setting \r\n\t\tcase 0x0009: sRetVal.strTag = _T(\"Canon.Cs2.Sequence\");break; // Short Sequence number (if in a continuous burst) \r\n\t\tcase 0x000e: sRetVal.strTag = _T(\"Canon.Cs2.AFPointUsed\");break; // Short AF point used \r\n\t\tcase 0x000f: sRetVal.strTag = _T(\"Canon.Cs2.FlashBias\");break; // Short Flash bias \r\n\t\tcase 0x0013: sRetVal.strTag = _T(\"Canon.Cs2.SubjectDistance\");break; // Short Subject distance (m_nImgUnits are not clear) \r\n\t\tcase 0x0015: sRetVal.strTag = _T(\"Canon.Cs2.ApertureValue\");break; // Short Aperture \r\n\t\tcase 0x0016: sRetVal.strTag = _T(\"Canon.Cs2.ShutterSpeedValue\");break; // Short Shutter speed \r\n\t\tdefault:\r\n\t\t\tsRetVal.strTag.Format(_T(\"Canon.Cs2.x%04X\"),nSubTag);\r\n\t\t\tsRetVal.bUnknown = true;\r\n\t\t\tbreak;\r\n\t\t} // switch nSubTag\r\n\t\tbreak;\r\n\r\n\tcase 0x000F:\r\n\r\n\t\t// CustomFunctions are different! Tag given by high byte, value by low\r\n\t\t// Index order (usually the nSubTag) is not used.\r\n\t\tsRetVal.strVal.Format(_T(\"%u\"),nValLo); // Provide default value\r\n\t\tswitch(nValHi)\r\n\t\t{\r\n\r\n\t\tcase 0x0001: sRetVal.strTag = _T(\"Canon.Cf.NoiseReduction\");break; // Short Long exposure noise reduction \r\n\t\tcase 0x0002: sRetVal.strTag = _T(\"Canon.Cf.ShutterAeLock\");break; // Short Shutter/AE lock buttons \r\n\t\tcase 0x0003: sRetVal.strTag = _T(\"Canon.Cf.MirrorLockup\");break; // Short Mirror lockup \r\n\t\tcase 0x0004: sRetVal.strTag = _T(\"Canon.Cf.ExposureLevelIncrements\");break; // Short Tv/Av and exposure level \r\n\t\tcase 0x0005: sRetVal.strTag = _T(\"Canon.Cf.AFAssist\");break; // Short AF assist light \r\n\t\tcase 0x0006: sRetVal.strTag = _T(\"Canon.Cf.FlashSyncSpeedAv\");break; // Short Shutter speed in Av mode \r\n\t\tcase 0x0007: sRetVal.strTag = _T(\"Canon.Cf.AEBSequence\");break; // Short AEB sequence/auto cancellation \r\n\t\tcase 0x0008: sRetVal.strTag = _T(\"Canon.Cf.ShutterCurtainSync\");break; // Short Shutter curtain sync \r\n\t\tcase 0x0009: sRetVal.strTag = _T(\"Canon.Cf.LensAFStopButton\");break; // Short Lens AF stop button Fn. Switch \r\n\t\tcase 0x000a: sRetVal.strTag = _T(\"Canon.Cf.FillFlashAutoReduction\");break; // Short Auto reduction of fill flash \r\n\t\tcase 0x000b: sRetVal.strTag = _T(\"Canon.Cf.MenuButtonReturn\");break; // Short Menu button return position \r\n\t\tcase 0x000c: sRetVal.strTag = _T(\"Canon.Cf.SetButtonFunction\");break; // Short SET button func. when shooting \r\n\t\tcase 0x000d: sRetVal.strTag = _T(\"Canon.Cf.SensorCleaning\");break; // Short Sensor cleaning \r\n\t\tcase 0x000e: sRetVal.strTag = _T(\"Canon.Cf.SuperimposedDisplay\");break; // Short Superimposed display \r\n\t\tcase 0x000f: sRetVal.strTag = _T(\"Canon.Cf.ShutterReleaseNoCFCard\");break; // Short Shutter Release W/O CF Card \r\n\t\tdefault:\r\n\t\t\tsRetVal.strTag.Format(_T(\"Canon.Cf.x%04X\"),nValHi);\r\n\t\t\tsRetVal.bUnknown = true;\r\n\t\t\tbreak;\r\n\t\t} // switch nSubTag\r\n\t\tbreak;\r\n\r\n/*\r\n\t// Other ones assumed to use high-byte/low-byte method:\r\n\tcase 0x00C0:\r\n\t\tsRetVal.strVal.Format(_T(\"%u\"),nValLo); // Provide default value\r\n\t\tswitch(nValHi)\r\n\t\t{\r\n\t\t\t//case 0x0001: sRetVal.strTag = _T(\"Canon.x00C0.???\");break; //\r\n\t\t\tdefault:\r\n\t\t\t\tsRetVal.strTag.Format(_T(\"Canon.x00C0.x%04X\"),nValHi);\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tcase 0x00C1:\r\n\t\tsRetVal.strVal.Format(_T(\"%u\"),nValLo); // Provide default value\r\n\t\tswitch(nValHi)\r\n\t\t{\r\n\t\t\t//case 0x0001: sRetVal.strTag = _T(\"Canon.x00C1.???\");break; //\r\n\t\t\tdefault:\r\n\t\t\t\tsRetVal.strTag.Format(_T(\"Canon.x00C1.x%04X\"),nValHi);\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\tbreak;\r\n*/\r\n\r\n\tcase 0x0012:\r\n\r\n\t\tswitch(nSubTag)\r\n\t\t{\r\n\t\tcase 0x0002: sRetVal.strTag = _T(\"Canon.Pi.ImageWidth\");break; //\r\n\t\tcase 0x0003: sRetVal.strTag = _T(\"Canon.Pi.ImageHeight\");break; //\r\n\t\tcase 0x0004: sRetVal.strTag = _T(\"Canon.Pi.ImageWidthAsShot\");break; //\r\n\t\tcase 0x0005: sRetVal.strTag = _T(\"Canon.Pi.ImageHeightAsShot\");break; //\r\n\t\tcase 0x0016: sRetVal.strTag = _T(\"Canon.Pi.AFPointsUsed\");break; //\r\n\t\tcase 0x001a: sRetVal.strTag = _T(\"Canon.Pi.AFPointsUsed20D\");break; //\r\n\t\tdefault:\r\n\t\t\tsRetVal.strTag.Format(_T(\"Canon.Pi.x%04X\"),nSubTag);\r\n\t\t\tsRetVal.bUnknown = true;\r\n\t\t\tbreak;\r\n\t\t} // switch nSubTag\r\n\t\tbreak;\r\n\r\n\tdefault:\r\n\t\tsRetVal.strTag.Format(_T(\"Canon.x%04X.x%04X\"),nMainTag,nSubTag);\r\n\t\tsRetVal.bUnknown = true;\r\n\t\tbreak;\r\n\r\n\t} // switch mainTag\r\n\r\n\treturn sRetVal;\r\n}\r\n\r\n\r\n// Perform decode of EXIF IFD tags including MakerNote tags\r\n//\r\n// PRE:\r\n// - m_strImgExifMake\tUsed for MakerNote decode\r\n//\r\n// INPUT:\r\n// - strSect\t\t\tIFD section\r\n// - nTag\t\t\t\tTag code value\r\n//\r\n// OUTPUT:\r\n// - bUnknown\t\t\tWas the tag unknown?\r\n//\r\n// RETURN:\r\n// - Formatted string\r\n//\r\nCString CjfifDecode::LookupExifTag(CString strSect,unsigned nTag,bool &bUnknown)\r\n{\r\n\tCString strTmp;\r\n\tbUnknown = false;\r\n\r\n\tif (strSect == _T(\"IFD0\"))\r\n\t{\r\n\r\n\t\tswitch(nTag)\r\n\t\t{\r\n\r\n\t\tcase 0x010E: return _T(\"ImageDescription\");break; // ascii string Describes image \r\n\t\tcase 0x010F: return _T(\"Make\");break; // ascii string Shows manufacturer of digicam \r\n\t\tcase 0x0110: return _T(\"Model\");break; // ascii string Shows model number of digicam\r\n\t\tcase 0x0112: return _T(\"Orientation\");break; // unsigned short 1  The orientation of the camera relative to the scene, when the image was captured. The start point of stored data is, '1' means upper left, '3' lower right, '6' upper right, '8' lower left, '9' undefined. \r\n\t\tcase 0x011A: return _T(\"XResolution\");break; // unsigned rational 1  Display/Print resolution of image. Large number of digicam uses 1/72inch, but it has no mean because personal computer doesn't use this value to display/print out. \r\n\t\tcase 0x011B: return _T(\"YResolution\");break; // unsigned rational 1  \r\n\t\tcase 0x0128: return _T(\"ResolutionUnit\");break; // unsigned short 1  Unit of XResolution(0x011a)/YResolution(0x011b). '1' means no-unit, '2' means inch, '3' means centimeter. \r\n\t\tcase 0x0131: return _T(\"Software\");break; //  ascii string Shows firmware(internal software of digicam) version number. \r\n\t\tcase 0x0132: return _T(\"DateTime\");break; // ascii string 20  Date/Time of image was last modified. Data format is \"YYYY:MM:DD HH:MM:SS\"+0x00, total 20bytes. In usual, it has the same value of DateTimeOriginal(0x9003) \r\n\t\tcase 0x013B: return _T(\"Artist\");break; // Seems to be here and not only in SubIFD (maybe instead of SubIFD)\r\n\t\tcase 0x013E: return _T(\"WhitePoint\");break; // unsigned rational 2  Defines chromaticity of white point of the image. If the image uses CIE Standard Illumination D65(known as international standard of 'daylight'), the values are '3127/10000,3290/10000'. \r\n\t\tcase 0x013F: return _T(\"PrimChromaticities\");break; // unsigned rational 6  Defines chromaticity of the primaries of the image. If the image uses CCIR Recommendation 709 primearies, values are '640/1000,330/1000,300/1000,600/1000,150/1000,0/1000'. \r\n\t\tcase 0x0211: return _T(\"YCbCrCoefficients\");break; // unsigned rational 3  When image format is YCbCr, this value shows a constant to translate it to RGB format. In usual, values are '0.299/0.587/0.114'. \r\n\t\tcase 0x0213: return _T(\"YCbCrPositioning\");break; // unsigned short 1  When image format is YCbCr and uses 'Subsampling'(cropping of chroma data, all the digicam do that), defines the chroma sample point of subsampling pixel array. '1' means the center of pixel array, '2' means the datum point. \r\n\t\tcase 0x0214: return _T(\"ReferenceBlackWhite\");break; // unsigned rational 6  Shows reference value of black point/white point. In case of YCbCr format, first 2 show black/white of Y, next 2 are Cb, last 2 are Cr. In case of RGB format, first 2 show black/white of R, next 2 are G, last 2 are B.\r\n\t\tcase 0x8298: return _T(\"Copyright\");break; // ascii string Shows copyright information\r\n\t\tcase 0x8769: return _T(\"ExifOffset\");break; //unsigned long 1  Offset to Exif Sub IFD\r\n\t\tcase 0x8825: return _T(\"GPSOffset\");break; //unsigned long 1  Offset to Exif GPS IFD\r\n//NEW:\r\n\t\tcase 0x9C9B: return _T(\"XPTitle\");break;\r\n\t\tcase 0x9C9C: return _T(\"XPComment\");break;\r\n\t\tcase 0x9C9D: return _T(\"XPAuthor\");break;\r\n\t\tcase 0x9C9e: return _T(\"XPKeywords\");break;\r\n\t\tcase 0x9C9f: return _T(\"XPSubject\");break;\r\n//NEW: The following were found in IFD0 even though they should just be SubIFD?\r\n\t\tcase 0xA401: return _T(\"CustomRendered\");break;\r\n\t\tcase 0xA402: return _T(\"ExposureMode\");break;\r\n\t\tcase 0xA403: return _T(\"WhiteBalance\");break;\r\n\t\tcase 0xA406: return _T(\"SceneCaptureType\");break;\r\n\r\n\t\tdefault:\r\n\t\t\tstrTmp.Format(_T(\"IFD0.0x%04X\"),nTag);\r\n\t\t\tbUnknown = true;\r\n\t\t\treturn strTmp;\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t} else if (strSect == _T(\"SubIFD\")) {\r\n\r\n\t\tswitch(nTag)\r\n\t\t{\r\n\t\tcase 0x00fe: return _T(\"NewSubfileType\");break; //  unsigned long 1  \r\n\t\tcase 0x00ff: return _T(\"SubfileType\");break; //  unsigned short 1   \r\n\t\tcase 0x012d: return _T(\"TransferFunction\");break; //  unsigned short 3  \r\n\t\tcase 0x013b: return _T(\"Artist\");break; //  ascii string \r\n\t\tcase 0x013d: return _T(\"Predictor\");break; //  unsigned short 1  \r\n\t\tcase 0x0142: return _T(\"TileWidth\");break; //  unsigned short 1  \r\n\t\tcase 0x0143: return _T(\"TileLength\");break; //  unsigned short 1  \r\n\t\tcase 0x0144: return _T(\"TileOffsets\");break; //  unsigned long \r\n\t\tcase 0x0145: return _T(\"TileByteCounts\");break; //  unsigned short \r\n\t\tcase 0x014a: return _T(\"SubIFDs\");break; //  unsigned long \r\n\t\tcase 0x015b: return _T(\"JPEGTables\");break; //  undefined \r\n\t\tcase 0x828d: return _T(\"CFARepeatPatternDim\");break; //  unsigned short 2  \r\n\t\tcase 0x828e: return _T(\"CFAPattern\");break; //  unsigned byte \r\n\t\tcase 0x828f: return _T(\"BatteryLevel\");break; //  unsigned rational 1  \r\n\t\tcase 0x829A: return _T(\"ExposureTime\");break;\r\n\t\tcase 0x829D: return _T(\"FNumber\");break;\r\n\t\tcase 0x83bb: return _T(\"IPTC/NAA\");break; //  unsigned long \r\n\t\tcase 0x8773: return _T(\"InterColorProfile\");break; //  undefined \r\n\t\tcase 0x8822: return _T(\"ExposureProgram\");break;\r\n\t\tcase 0x8824: return _T(\"SpectralSensitivity\");break; //  ascii string \r\n\t\tcase 0x8825: return _T(\"GPSInfo\");break; //  unsigned long 1  \r\n\t\tcase 0x8827: return _T(\"ISOSpeedRatings\");break;\r\n\t\tcase 0x8828: return _T(\"OECF\");break; //  undefined \r\n\t\tcase 0x8829: return _T(\"Interlace\");break; //  unsigned short 1  \r\n\t\tcase 0x882a: return _T(\"TimeZoneOffset\");break; //  signed short 1  \r\n\t\tcase 0x882b: return _T(\"SelfTimerMode\");break; //  unsigned short 1  \r\n\t\tcase 0x9000: return _T(\"ExifVersion\");break;\r\n\t\tcase 0x9003: return _T(\"DateTimeOriginal\");break;\r\n\t\tcase 0x9004: return _T(\"DateTimeDigitized\");break;\r\n\t\tcase 0x9101: return _T(\"ComponentsConfiguration\");break;\r\n\t\tcase 0x9102: return _T(\"CompressedBitsPerPixel\");break;\r\n\t\tcase 0x9201: return _T(\"ShutterSpeedValue\");break;\r\n\t\tcase 0x9202: return _T(\"ApertureValue\");break;\r\n\t\tcase 0x9203: return _T(\"BrightnessValue\");break;\r\n\t\tcase 0x9204: return _T(\"ExposureBiasValue\");break;\r\n\t\tcase 0x9205: return _T(\"MaxApertureValue\");break;\r\n\t\tcase 0x9206: return _T(\"SubjectDistance\");break;\r\n\t\tcase 0x9207: return _T(\"MeteringMode\");break;\r\n\t\tcase 0x9208: return _T(\"LightSource\");break;\r\n\t\tcase 0x9209: return _T(\"Flash\");break;\r\n\t\tcase 0x920A: return _T(\"FocalLength\");break;\r\n\t\tcase 0x920b: return _T(\"FlashEnergy\");break; //  unsigned rational 1  \r\n\t\tcase 0x920c: return _T(\"SpatialFrequencyResponse\");break; //  undefined \r\n\t\tcase 0x920d: return _T(\"Noise\");break; //  undefined \r\n\t\tcase 0x9211: return _T(\"ImageNumber\");break; //  unsigned long 1  \r\n\t\tcase 0x9212: return _T(\"SecurityClassification\");break; //  ascii string 1  \r\n\t\tcase 0x9213: return _T(\"ImageHistory\");break; //  ascii string \r\n\t\tcase 0x9214: return _T(\"SubjectLocation\");break; //  unsigned short 4  \r\n\t\tcase 0x9215: return _T(\"ExposureIndex\");break; //  unsigned rational 1  \r\n\t\tcase 0x9216: return _T(\"TIFF/EPStandardID\");break; //  unsigned byte 4  \r\n\t\tcase 0x927C: return _T(\"MakerNote\");break;\r\n\t\tcase 0x9286: return _T(\"UserComment\");break;\r\n\t\tcase 0x9290: return _T(\"SubSecTime\");break; //  ascii string \r\n\t\tcase 0x9291: return _T(\"SubSecTimeOriginal\");break; //  ascii string \r\n\t\tcase 0x9292: return _T(\"SubSecTimeDigitized\");break; //  ascii string \r\n\t\tcase 0xA000: return _T(\"FlashPixVersion\");break;\r\n\t\tcase 0xA001: return _T(\"ColorSpace\");break;\r\n\t\tcase 0xA002: return _T(\"ExifImageWidth\");break;\r\n\t\tcase 0xA003: return _T(\"ExifImageHeight\");break;\r\n\t\tcase 0xA004: return _T(\"RelatedSoundFile\");break;\r\n\t\tcase 0xA005: return _T(\"ExifInteroperabilityOffset\");break;\r\n\t\tcase 0xa20b: return _T(\"FlashEnergy  unsigned\");break; // rational 1  \r\n\t\tcase 0xa20c: return _T(\"SpatialFrequencyResponse\");break; //  unsigned short 1  \r\n\t\tcase 0xA20E: return _T(\"FocalPlaneXResolution\");break;\r\n\t\tcase 0xA20F: return _T(\"FocalPlaneYResolution\");break;\r\n\t\tcase 0xA210: return _T(\"FocalPlaneResolutionUnit\");break;\r\n\t\tcase 0xa214: return _T(\"SubjectLocation\");break; //  unsigned short 1  \r\n\t\tcase 0xa215: return _T(\"ExposureIndex\");break; //  unsigned rational 1 \r\n\t\tcase 0xA217: return _T(\"SensingMethod\");break;\r\n\t\tcase 0xA300: return _T(\"FileSource\");break;\r\n\t\tcase 0xA301: return _T(\"SceneType\");break;\r\n\t\tcase 0xa302: return _T(\"CFAPattern\");break; //  undefined 1  \r\n\t\tcase 0xa401: return _T(\"CustomRendered\");break; // Short Custom image processing \r\n\t\tcase 0xa402: return _T(\"ExposureMode\");break; // Short Exposure mode \r\n\t\tcase 0xa403: return _T(\"WhiteBalance\");break; // Short White balance \r\n\t\tcase 0xa404: return _T(\"DigitalZoomRatio\");break; // Rational Digital zoom ratio \r\n\t\tcase 0xa405: return _T(\"FocalLengthIn35mmFilm\");break; // Short Focal length in 35 mm film \r\n\t\tcase 0xa406: return _T(\"SceneCaptureType\");break; // Short Scene capture type \r\n\t\tcase 0xa407: return _T(\"GainControl\");break; // Rational Gain control \r\n\t\tcase 0xa408: return _T(\"Contrast\");break; // Short Contrast \r\n\t\tcase 0xa409: return _T(\"Saturation\");break; // Short Saturation \r\n\t\tcase 0xa40a: return _T(\"Sharpness\");break; // Short Sharpness \r\n\t\tcase 0xa40b: return _T(\"DeviceSettingDescription\");break; // Undefined Device settings description \r\n\t\tcase 0xa40c: return _T(\"SubjectDistanceRange\");break; // Short Subject distance range \r\n\t\tcase 0xa420: return _T(\"ImageUniqueID\");break; // Ascii Unique image ID \r\n\r\n\t\tdefault:\r\n\t\t\tstrTmp.Format(_T(\"SubIFD.0x%04X\"),nTag);\r\n\t\t\tbUnknown = true;\r\n\t\t\treturn strTmp;\r\n\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t} else if (strSect == _T(\"IFD1\")) {\r\n\r\n\t\tswitch(nTag)\r\n\t\t{\r\n\t\tcase 0x0100: return _T(\"ImageWidth\");break; //  unsigned short/long 1  Shows size of thumbnail image. \r\n\t\tcase 0x0101: return _T(\"ImageLength\");break; //  unsigned short/long 1  \r\n\t\tcase 0x0102: return _T(\"BitsPerSample\");break; //  unsigned short 3  When image format is no compression, this value shows the number of bits per component for each pixel. Usually this value is '8,8,8' \r\n\t\tcase 0x0103: return _T(\"Compression\");break; //  unsigned short 1  Shows compression method. '1' means no compression, '6' means JPEG compression. \r\n\t\tcase 0x0106: return _T(\"PhotometricInterpretation\");break; //  unsigned short 1  Shows the color space of the image data components. '1' means monochrome, '2' means RGB, '6' means YCbCr. \r\n\t\tcase 0x0111: return _T(\"StripOffsets\");break; //  unsigned short/long When image format is no compression, this value shows offset to image data. In some case image data is striped and this value is plural. \r\n\t\tcase 0x0115: return _T(\"SamplesPerPixel\");break; //  unsigned short 1  When image format is no compression, this value shows the number of components stored for each pixel. At color image, this value is '3'. \r\n\t\tcase 0x0116: return _T(\"RowsPerStrip\");break; //  unsigned short/long 1  When image format is no compression and image has stored as strip, this value shows how many rows stored to each strip. If image has not striped, this value is the same as ImageLength(0x0101). \r\n\t\tcase 0x0117: return _T(\"StripByteConunts\");break; //  unsigned short/long  When image format is no compression and stored as strip, this value shows how many bytes used for each strip and this value is plural. If image has not stripped, this value is single and means whole data size of image. \r\n\t\tcase 0x011a: return _T(\"XResolution\");break; //  unsigned rational 1  Display/Print resolution of image. Large number of digicam uses 1/72inch, but it has no mean because personal computer doesn't use this value to display/print out. \r\n\t\tcase 0x011b: return _T(\"YResolution\");break; //  unsigned rational 1  \r\n\t\tcase 0x011c: return _T(\"PlanarConfiguration\");break; //  unsigned short 1  When image format is no compression YCbCr, this value shows byte aligns of YCbCr data. If value is '1', Y/Cb/Cr value is chunky format, contiguous for each subsampling pixel. If value is '2', Y/Cb/Cr value is separated and stored to Y plane/Cb plane/Cr plane format. \r\n\t\tcase 0x0128: return _T(\"ResolutionUnit\");break; //  unsigned short 1  Unit of XResolution(0x011a)/YResolution(0x011b). '1' means inch, '2' means centimeter. \r\n\t\tcase 0x0201: return _T(\"JpegIFOffset\");break; //  unsigned long 1  When image format is JPEG, this value show offset to JPEG data stored. \r\n\t\tcase 0x0202: return _T(\"JpegIFByteCount\");break; //  unsigned long 1  When image format is JPEG, this value shows data size of JPEG image. \r\n\t\tcase 0x0211: return _T(\"YCbCrCoefficients\");break; //  unsigned rational 3  When image format is YCbCr, this value shows constants to translate it to RGB format. In usual, '0.299/0.587/0.114' are used. \r\n\t\tcase 0x0212: return _T(\"YCbCrSubSampling\");break; //  unsigned short 2  When image format is YCbCr and uses subsampling(cropping of chroma data, all the digicam do that), this value shows how many chroma data subsampled. First value shows horizontal, next value shows vertical subsample rate. \r\n\t\tcase 0x0213: return _T(\"YCbCrPositioning\");break; //  unsigned short 1  When image format is YCbCr and uses 'Subsampling'(cropping of chroma data, all the digicam do that), this value defines the chroma sample point of subsampled pixel array. '1' means the center of pixel array, '2' means the datum point(0,0). \r\n\t\tcase 0x0214: return _T(\"ReferenceBlackWhite\");break; //  unsigned rational 6  Shows reference value of black point/white point. In case of YCbCr format, first 2 show black/white of Y, next 2 are Cb, last 2 are Cr. In case of RGB format, first 2 show black/white of R, next 2 are G, last 2 are B. \r\n\r\n\t\tdefault:\r\n\t\t\tstrTmp.Format(_T(\"IFD1.0x%04X\"),nTag);\r\n\t\t\tbUnknown = true;\r\n\t\t\treturn strTmp;\r\n\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t} else if (strSect == _T(\"InteropIFD\")) {\r\n\t\tswitch(nTag) {\r\n\t\t\tcase 0x0001: return _T(\"InteroperabilityIndex\");break;\r\n\t\t\tcase 0x0002: return _T(\"InteroperabilityVersion\");break;\r\n\t\t\tcase 0x1000: return _T(\"RelatedImageFileFormat\");break;\r\n\t\t\tcase 0x1001: return _T(\"RelatedImageWidth\");break;\r\n\t\t\tcase 0x1002: return _T(\"RelatedImageLength\");break;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\tstrTmp.Format(_T(\"Interop.0x%04X\"),nTag);\r\n\t\t\t\tbUnknown = true;\r\n\t\t\t\treturn strTmp;\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t} else if (strSect == _T(\"GPSIFD\")) {\r\n\t\tswitch(nTag) {\r\n\t\t\tcase 0x0000: return _T(\"GPSVersionID\");break;\r\n\t\t\tcase 0x0001: return _T(\"GPSLatitudeRef\");break;\r\n\t\t\tcase 0x0002: return _T(\"GPSLatitude\");break;\r\n\t\t\tcase 0x0003: return _T(\"GPSLongitudeRef\");break;\r\n\t\t\tcase 0x0004: return _T(\"GPSLongitude\");break;\r\n\t\t\tcase 0x0005: return _T(\"GPSAltitudeRef\");break;\r\n\t\t\tcase 0x0006: return _T(\"GPSAltitude\");break;\r\n\t\t\tcase 0x0007: return _T(\"GPSTimeStamp\");break;\r\n\t\t\tcase 0x0008: return _T(\"GPSSatellites\");break;\r\n\t\t\tcase 0x0009: return _T(\"GPSStatus\");break;\r\n\t\t\tcase 0x000A: return _T(\"GPSMeasureMode\");break;\r\n\t\t\tcase 0x000B: return _T(\"GPSDOP\");break;\r\n\t\t\tcase 0x000C: return _T(\"GPSSpeedRef\");break;\r\n\t\t\tcase 0x000D: return _T(\"GPSSpeed\");break;\r\n\t\t\tcase 0x000E: return _T(\"GPSTrackRef\");break;\r\n\t\t\tcase 0x000F: return _T(\"GPSTrack\");break;\r\n\t\t\tcase 0x0010: return _T(\"GPSImgDirectionRef\");break;\r\n\t\t\tcase 0x0011: return _T(\"GPSImgDirection\");break;\r\n\t\t\tcase 0x0012: return _T(\"GPSMapDatum\");break;\r\n\t\t\tcase 0x0013: return _T(\"GPSDestLatitudeRef\");break;\r\n\t\t\tcase 0x0014: return _T(\"GPSDestLatitude\");break;\r\n\t\t\tcase 0x0015: return _T(\"GPSDestLongitudeRef\");break;\r\n\t\t\tcase 0x0016: return _T(\"GPSDestLongitude\");break;\r\n\t\t\tcase 0x0017: return _T(\"GPSDestBearingRef\");break;\r\n\t\t\tcase 0x0018: return _T(\"GPSDestBearing\");break;\r\n\t\t\tcase 0x0019: return _T(\"GPSDestDistanceRef\");break;\r\n\t\t\tcase 0x001A: return _T(\"GPSDestDistance\");break;\r\n\t\t\tcase 0x001B: return _T(\"GPSProcessingMethod\");break;\r\n\t\t\tcase 0x001C: return _T(\"GPSAreaInformation\");break;\r\n\t\t\tcase 0x001D: return _T(\"GPSDateStamp\");break;\r\n\t\t\tcase 0x001E: return _T(\"GPSDifferential\");break;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\tstrTmp.Format(_T(\"GPS.0x%04X\"),nTag);\r\n\t\t\t\tbUnknown = true;\r\n\t\t\t\treturn strTmp;\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t} else if (strSect == _T(\"MakerIFD\")) {\r\n\r\n\t\t// Makernotes need special handling\r\n\t\t// We only support a few different manufacturers for makernotes.\r\n\t\t\r\n\t\t// A few Canon tags are supported in this routine, the rest are\r\n\t\t// handled by the LookupMakerCanonTag() call.\r\n\t\tif (m_strImgExifMake == _T(\"Canon\")) {\r\n\r\n\t\t\tswitch(nTag)\r\n\t\t\t{\r\n\t\t\tcase 0x0001: return _T(\"Canon.CameraSettings1\");break;\r\n\t\t\tcase 0x0004: return _T(\"Canon.CameraSettings2\");break;\r\n\t\t\tcase 0x0006: return _T(\"Canon.ImageType\");break;\r\n\t\t\tcase 0x0007: return _T(\"Canon.FirmwareVersion\");break;\r\n\t\t\tcase 0x0008: return _T(\"Canon.ImageNumber\");break;\r\n\t\t\tcase 0x0009: return _T(\"Canon.OwnerName\");break;\r\n\t\t\tcase 0x000C: return _T(\"Canon.SerialNumber\");break;\r\n\t\t\tcase 0x000F: return _T(\"Canon.CustomFunctions\");break;\r\n\t\t\tcase 0x0012: return _T(\"Canon.PictureInfo\");break;\r\n\t\t\tcase 0x00A9: return _T(\"Canon.WhiteBalanceTable\");break;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\tstrTmp.Format(_T(\"Canon.0x%04X\"),nTag);\r\n\t\t\t\tbUnknown = true;\r\n\t\t\t\treturn strTmp;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t} // Canon\r\n\r\n\t\telse if (m_strImgExifMake == _T(\"SIGMA\"))\r\n\t\t{\r\n\t\t\tswitch(nTag)\r\n\t\t\t{\r\n\t\t\tcase 0x0002: return _T(\"Sigma.SerialNumber\");break; // Ascii Camera serial number \r\n\t\t\tcase 0x0003: return _T(\"Sigma.DriveMode\");break; // Ascii Drive Mode \r\n\t\t\tcase 0x0004: return _T(\"Sigma.ResolutionMode\");break; // Ascii Resolution Mode \r\n\t\t\tcase 0x0005: return _T(\"Sigma.AutofocusMode\");break; // Ascii Autofocus mode \r\n\t\t\tcase 0x0006: return _T(\"Sigma.FocusSetting\");break; // Ascii Focus setting \r\n\t\t\tcase 0x0007: return _T(\"Sigma.WhiteBalance\");break; // Ascii White balance \r\n\t\t\tcase 0x0008: return _T(\"Sigma.ExposureMode\");break; // Ascii Exposure mode \r\n\t\t\tcase 0x0009: return _T(\"Sigma.MeteringMode\");break; // Ascii Metering mode \r\n\t\t\tcase 0x000a: return _T(\"Sigma.LensRange\");break; // Ascii Lens focal length range \r\n\t\t\tcase 0x000b: return _T(\"Sigma.ColorSpace\");break; // Ascii Color space \r\n\t\t\tcase 0x000c: return _T(\"Sigma.Exposure\");break; // Ascii Exposure \r\n\t\t\tcase 0x000d: return _T(\"Sigma.Contrast\");break; // Ascii Contrast \r\n\t\t\tcase 0x000e: return _T(\"Sigma.Shadow\");break; // Ascii Shadow \r\n\t\t\tcase 0x000f: return _T(\"Sigma.Highlight\");break; // Ascii Highlight \r\n\t\t\tcase 0x0010: return _T(\"Sigma.Saturation\");break; // Ascii Saturation \r\n\t\t\tcase 0x0011: return _T(\"Sigma.Sharpness\");break; // Ascii Sharpness \r\n\t\t\tcase 0x0012: return _T(\"Sigma.FillLight\");break; // Ascii X3 Fill light \r\n\t\t\tcase 0x0014: return _T(\"Sigma.ColorAdjustment\");break; // Ascii Color adjustment \r\n\t\t\tcase 0x0015: return _T(\"Sigma.AdjustmentMode\");break; // Ascii Adjustment mode \r\n\t\t\tcase 0x0016: return _T(\"Sigma.Quality\");break; // Ascii Quality \r\n\t\t\tcase 0x0017: return _T(\"Sigma.Firmware\");break; // Ascii Firmware \r\n\t\t\tcase 0x0018: return _T(\"Sigma.Software\");break; // Ascii Software \r\n\t\t\tcase 0x0019: return _T(\"Sigma.AutoBracket\");break; // Ascii Auto bracket \r\n\t\t\tdefault:\r\n\t\t\t\tstrTmp.Format(_T(\"Sigma.0x%04X\"),nTag);\r\n\t\t\t\tbUnknown = true;\r\n\t\t\t\treturn strTmp;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t} // SIGMA\r\n\r\n\t\telse if (m_strImgExifMake == _T(\"SONY\"))\r\n\t\t{\r\n\r\n\t\t\tswitch(nTag)\r\n\t\t\t{\r\n\t\t\tcase 0xb021: return _T(\"Sony.ColorTemperature\");break;\r\n\t\t\tcase 0xb023: return _T(\"Sony.SceneMode\");break;\r\n\t\t\tcase 0xb024: return _T(\"Sony.ZoneMatching\");break;\r\n\t\t\tcase 0xb025: return _T(\"Sony.DynamicRangeOptimizer\");break;\r\n\t\t\tcase 0xb026: return _T(\"Sony.ImageStabilization\");break;\r\n\t\t\tcase 0xb027: return _T(\"Sony.LensID\");break;\r\n\t\t\tcase 0xb029: return _T(\"Sony.ColorMode\");break;\r\n\t\t\tcase 0xb040: return _T(\"Sony.Macro\");break;\r\n\t\t\tcase 0xb041: return _T(\"Sony.ExposureMode\");break;\r\n\t\t\tcase 0xb047: return _T(\"Sony.Quality\");break;\r\n\t\t\tcase 0xb04e: return _T(\"Sony.LongExposureNoiseReduction\");break;\r\n\t\t\tdefault:\r\n\t\t\t\t// No real info is known\r\n\t\t\t\tstrTmp.Format(_T(\"Sony.0x%04X\"),nTag);\r\n\t\t\t\tbUnknown = true;\r\n\t\t\t\treturn strTmp;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t} // SONY\r\n\r\n\t\telse if (m_strImgExifMake == _T(\"FUJIFILM\"))\r\n\t\t{\r\n\t\t\tswitch(nTag)\r\n\t\t\t{\r\n\t\t\tcase 0x0000: return _T(\"Fujifilm.Version\");break; // Undefined Fujifilm Makernote version \r\n\t\t\tcase 0x1000: return _T(\"Fujifilm.Quality\");break; // Ascii Image quality setting \r\n\t\t\tcase 0x1001: return _T(\"Fujifilm.Sharpness\");break; // Short Sharpness setting \r\n\t\t\tcase 0x1002: return _T(\"Fujifilm.WhiteBalance\");break; // Short White balance setting \r\n\t\t\tcase 0x1003: return _T(\"Fujifilm.Color\");break; // Short Chroma saturation setting \r\n\t\t\tcase 0x1004: return _T(\"Fujifilm.Tone\");break; // Short Contrast setting \r\n\t\t\tcase 0x1010: return _T(\"Fujifilm.FlashMode\");break; // Short Flash firing mode setting \r\n\t\t\tcase 0x1011: return _T(\"Fujifilm.FlashStrength\");break; // SRational Flash firing strength compensation setting \r\n\t\t\tcase 0x1020: return _T(\"Fujifilm.Macro\");break; // Short Macro mode setting \r\n\t\t\tcase 0x1021: return _T(\"Fujifilm.FocusMode\");break; // Short Focusing mode setting \r\n\t\t\tcase 0x1030: return _T(\"Fujifilm.SlowSync\");break; // Short Slow synchro mode setting \r\n\t\t\tcase 0x1031: return _T(\"Fujifilm.PictureMode\");break; // Short Picture mode setting \r\n\t\t\tcase 0x1100: return _T(\"Fujifilm.Continuous\");break; // Short Continuous shooting or auto bracketing setting \r\n\t\t\tcase 0x1210: return _T(\"Fujifilm.FinePixColor\");break; // Short Fuji FinePix Color setting \r\n\t\t\tcase 0x1300: return _T(\"Fujifilm.BlurWarning\");break; // Short Blur warning status \r\n\t\t\tcase 0x1301: return _T(\"Fujifilm.FocusWarning\");break; // Short Auto Focus warning status \r\n\t\t\tcase 0x1302: return _T(\"Fujifilm.AeWarning\");break; // Short Auto Exposure warning status \r\n\t\t\tdefault:\r\n\t\t\t\tstrTmp.Format(_T(\"Fujifilm.0x%04X\"),nTag);\r\n\t\t\t\tbUnknown = true;\r\n\t\t\t\treturn strTmp;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t} // FUJIFILM\r\n\r\n\t\telse if (m_strImgExifMake == _T(\"NIKON\"))\r\n\t\t{\r\n\t\t\tif (m_nImgExifMakeSubtype == 1) {\r\n\t\t\t\t// Type 1\r\n\t\t\t\tswitch(nTag)\r\n\t\t\t\t{\r\n\t\t\t\tcase 0x0001: return _T(\"Nikon1.Version\");break; // Undefined Nikon Makernote version \r\n\t\t\t\tcase 0x0002: return _T(\"Nikon1.ISOSpeed\");break; // Short ISO speed setting \r\n\t\t\t\tcase 0x0003: return _T(\"Nikon1.ColorMode\");break; // Ascii Color mode \r\n\t\t\t\tcase 0x0004: return _T(\"Nikon1.Quality\");break; // Ascii Image quality setting \r\n\t\t\t\tcase 0x0005: return _T(\"Nikon1.WhiteBalance\");break; // Ascii White balance \r\n\t\t\t\tcase 0x0006: return _T(\"Nikon1.Sharpening\");break; // Ascii Image sharpening setting \r\n\t\t\t\tcase 0x0007: return _T(\"Nikon1.Focus\");break; // Ascii Focus mode \r\n\t\t\t\tcase 0x0008: return _T(\"Nikon1.Flash\");break; // Ascii Flash mode \r\n\t\t\t\tcase 0x000f: return _T(\"Nikon1.ISOSelection\");break; // Ascii ISO selection \r\n\t\t\t\tcase 0x0010: return _T(\"Nikon1.DataDump\");break; // Undefined Data dump \r\n\t\t\t\tcase 0x0080: return _T(\"Nikon1.ImageAdjustment\");break; // Ascii Image adjustment setting \r\n\t\t\t\tcase 0x0082: return _T(\"Nikon1.Adapter\");break; // Ascii Adapter used \r\n\t\t\t\tcase 0x0085: return _T(\"Nikon1.FocusDistance\");break; // Rational Manual focus distance \r\n\t\t\t\tcase 0x0086: return _T(\"Nikon1.DigitalZoom\");break; // Rational Digital zoom setting \r\n\t\t\t\tcase 0x0088: return _T(\"Nikon1.AFFocusPos\");break; // Undefined AF focus position \r\n\t\t\t\tdefault:\r\n\t\t\t\t\tstrTmp.Format(_T(\"Nikon1.0x%04X\"),nTag);\r\n\t\t\t\t\tbUnknown = true;\r\n\t\t\t\t\treturn strTmp;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (m_nImgExifMakeSubtype == 2)\r\n\t\t\t{\r\n\t\t\t\t// Type 2\r\n\t\t\t\tswitch(nTag)\r\n\t\t\t\t{\r\n\t\t\t\tcase 0x0003: return _T(\"Nikon2.Quality\");break; // Short Image quality setting \r\n\t\t\t\tcase 0x0004: return _T(\"Nikon2.ColorMode\");break; // Short Color mode \r\n\t\t\t\tcase 0x0005: return _T(\"Nikon2.ImageAdjustment\");break; // Short Image adjustment setting \r\n\t\t\t\tcase 0x0006: return _T(\"Nikon2.ISOSpeed\");break; // Short ISO speed setting \r\n\t\t\t\tcase 0x0007: return _T(\"Nikon2.WhiteBalance\");break; // Short White balance \r\n\t\t\t\tcase 0x0008: return _T(\"Nikon2.Focus\");break; // Rational Focus mode \r\n\t\t\t\tcase 0x000a: return _T(\"Nikon2.DigitalZoom\");break; // Rational Digital zoom setting \r\n\t\t\t\tcase 0x000b: return _T(\"Nikon2.Adapter\");break; // Short Adapter used \r\n\t\t\t\tdefault:\r\n\t\t\t\t\tstrTmp.Format(_T(\"Nikon2.0x%04X\"),nTag);\r\n\t\t\t\t\tbUnknown = true;\r\n\t\t\t\t\treturn strTmp;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (m_nImgExifMakeSubtype == 3)\r\n\t\t\t{\r\n\t\t\t\t// Type 3\r\n\t\t\t\tswitch(nTag)\r\n\t\t\t\t{\r\n\t\t\t\tcase 0x0001: return _T(\"Nikon3.Version\");break; // Undefined Nikon Makernote version \r\n\t\t\t\tcase 0x0002: return _T(\"Nikon3.ISOSpeed\");break; // Short ISO speed used \r\n\t\t\t\tcase 0x0003: return _T(\"Nikon3.ColorMode\");break; // Ascii Color mode \r\n\t\t\t\tcase 0x0004: return _T(\"Nikon3.Quality\");break; // Ascii Image quality setting \r\n\t\t\t\tcase 0x0005: return _T(\"Nikon3.WhiteBalance\");break; // Ascii White balance \r\n\t\t\t\tcase 0x0006: return _T(\"Nikon3.Sharpening\");break; // Ascii Image sharpening setting \r\n\t\t\t\tcase 0x0007: return _T(\"Nikon3.Focus\");break; // Ascii Focus mode \r\n\t\t\t\tcase 0x0008: return _T(\"Nikon3.FlashSetting\");break; // Ascii Flash setting \r\n\t\t\t\tcase 0x0009: return _T(\"Nikon3.FlashMode\");break; // Ascii Flash mode \r\n\t\t\t\tcase 0x000b: return _T(\"Nikon3.WhiteBalanceBias\");break; // SShort White balance bias \r\n\t\t\t\tcase 0x000e: return _T(\"Nikon3.ExposureDiff\");break; // Undefined Exposure difference \r\n\t\t\t\tcase 0x000f: return _T(\"Nikon3.ISOSelection\");break; // Ascii ISO selection \r\n\t\t\t\tcase 0x0010: return _T(\"Nikon3.DataDump\");break; // Undefined Data dump \r\n\t\t\t\tcase 0x0011: return _T(\"Nikon3.ThumbOffset\");break; // Long Thumbnail IFD offset \r\n\t\t\t\tcase 0x0012: return _T(\"Nikon3.FlashComp\");break; // Undefined Flash compensation setting \r\n\t\t\t\tcase 0x0013: return _T(\"Nikon3.ISOSetting\");break; // Short ISO speed setting \r\n\t\t\t\tcase 0x0016: return _T(\"Nikon3.ImageBoundary\");break; // Short Image boundry \r\n\t\t\t\tcase 0x0018: return _T(\"Nikon3.FlashBracketComp\");break; // Undefined Flash bracket compensation applied \r\n\t\t\t\tcase 0x0019: return _T(\"Nikon3.ExposureBracketComp\");break; // SRational AE bracket compensation applied \r\n\t\t\t\tcase 0x0080: return _T(\"Nikon3.ImageAdjustment\");break; // Ascii Image adjustment setting \r\n\t\t\t\tcase 0x0081: return _T(\"Nikon3.ToneComp\");break; // Ascii Tone compensation setting (contrast) \r\n\t\t\t\tcase 0x0082: return _T(\"Nikon3.AuxiliaryLens\");break; // Ascii Auxiliary lens (adapter) \r\n\t\t\t\tcase 0x0083: return _T(\"Nikon3.LensType\");break; // Byte Lens type \r\n\t\t\t\tcase 0x0084: return _T(\"Nikon3.Lens\");break; // Rational Lens \r\n\t\t\t\tcase 0x0085: return _T(\"Nikon3.FocusDistance\");break; // Rational Manual focus distance \r\n\t\t\t\tcase 0x0086: return _T(\"Nikon3.DigitalZoom\");break; // Rational Digital zoom setting \r\n\t\t\t\tcase 0x0087: return _T(\"Nikon3.FlashType\");break; // Byte Type of flash used \r\n\t\t\t\tcase 0x0088: return _T(\"Nikon3.AFFocusPos\");break; // Undefined AF focus position \r\n\t\t\t\tcase 0x0089: return _T(\"Nikon3.Bracketing\");break; // Short Bracketing \r\n\t\t\t\tcase 0x008b: return _T(\"Nikon3.LensFStops\");break; // Undefined Number of lens stops \r\n\t\t\t\tcase 0x008c: return _T(\"Nikon3.ToneCurve\");break; // Undefined Tone curve \r\n\t\t\t\tcase 0x008d: return _T(\"Nikon3.ColorMode\");break; // Ascii Color mode \r\n\t\t\t\tcase 0x008f: return _T(\"Nikon3.SceneMode\");break; // Ascii Scene mode \r\n\t\t\t\tcase 0x0090: return _T(\"Nikon3.LightingType\");break; // Ascii Lighting type \r\n\t\t\t\tcase 0x0092: return _T(\"Nikon3.HueAdjustment\");break; // SShort Hue adjustment \r\n\t\t\t\tcase 0x0094: return _T(\"Nikon3.Saturation\");break; // SShort Saturation adjustment \r\n\t\t\t\tcase 0x0095: return _T(\"Nikon3.NoiseReduction\");break; // Ascii Noise reduction \r\n\t\t\t\tcase 0x0096: return _T(\"Nikon3.CompressionCurve\");break; // Undefined Compression curve \r\n\t\t\t\tcase 0x0097: return _T(\"Nikon3.ColorBalance2\");break; // Undefined Color balance 2 \r\n\t\t\t\tcase 0x0098: return _T(\"Nikon3.LensData\");break; // Undefined Lens data \r\n\t\t\t\tcase 0x0099: return _T(\"Nikon3.NEFThumbnailSize\");break; // Short NEF thumbnail size \r\n\t\t\t\tcase 0x009a: return _T(\"Nikon3.SensorPixelSize\");break; // Rational Sensor pixel size \r\n\t\t\t\tcase 0x00a0: return _T(\"Nikon3.SerialNumber\");break; // Ascii Camera serial number \r\n\t\t\t\tcase 0x00a7: return _T(\"Nikon3.ShutterCount\");break; // Long Number of shots taken by camera \r\n\t\t\t\tcase 0x00a9: return _T(\"Nikon3.ImageOptimization\");break; // Ascii Image optimization \r\n\t\t\t\tcase 0x00aa: return _T(\"Nikon3.Saturation\");break; // Ascii Saturation \r\n\t\t\t\tcase 0x00ab: return _T(\"Nikon3.VariProgram\");break; // Ascii Vari program \r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tstrTmp.Format(_T(\"Nikon3.0x%04X\"),nTag);\r\n\t\t\t\t\tbUnknown = true;\r\n\t\t\t\t\treturn strTmp;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t} // NIKON\r\n\r\n\t} // if strSect\r\n\r\n\tbUnknown = true;\r\n\treturn _T(\"???\");\r\n}\r\n\r\n\r\n// Interpret the MakerNote header to determine any applicable MakerNote subtype.\r\n//\r\n// PRE:\r\n// - m_strImgExifMake\r\n// - buffer\r\n//\r\n// INPUT:\r\n// - none\r\n//\r\n// RETURN:\r\n// - Decode success\r\n//\r\n// POST:\r\n// - m_nImgExifMakeSubtype\r\n//\r\nbool CjfifDecode::DecodeMakerSubType()\r\n{\r\n\tCString strTmp;\r\n\r\n\tm_nImgExifMakeSubtype = 0;\r\n\r\n\tif (m_strImgExifMake == _T(\"NIKON\"))\r\n\t{\r\n\t\tstrTmp = _T(\"\");\r\n\t\tfor (unsigned nInd=0;nInd<5;nInd++) {\r\n\t\t\tstrTmp += (char)Buf(m_nPos+nInd);\r\n\t\t}\r\n\r\n\t\tif (strTmp == _T(\"Nikon\")) {\r\n\t\t\tif (Buf(m_nPos+6) == 1) {\r\n\t\t\t\t// Type 1\r\n\t\t\t\tm_pLog->AddLine(_T(\"    Nikon Makernote Type 1 detected\"));\r\n\t\t\t\tm_nImgExifMakeSubtype = 1;\r\n\t\t\t\tm_nPos += 8;\r\n\t\t\t} else if (Buf(m_nPos+6) == 2) {\r\n\t\t\t\t// Type 3\r\n\t\t\t\tm_pLog->AddLine(_T(\"    Nikon Makernote Type 3 detected\"));\r\n\t\t\t\tm_nImgExifMakeSubtype = 3;\r\n\t\t\t\tm_nPos += 18;\r\n\t\t\t} else {\r\n\t\t\t\tCString strTmp = _T(\"ERROR: Unknown Nikon Makernote Type\");\r\n\t\t\t\tm_pLog->AddLineErr(strTmp);\r\n\t\t\t\tif (m_pAppConfig->bInteractive)\r\n\t\t\t\t\tAfxMessageBox(strTmp);\r\n\t\t\t\treturn FALSE;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// Type 2\r\n\t\t\tm_pLog->AddLine(_T(\"    Nikon Makernote Type 2 detected\"));\r\n\t\t\t//m_nImgExifMakeSubtype = 2;\r\n\t\t\t// tests on D1 seem to indicate that it uses Type 1 headers\r\n\t\t\tm_nImgExifMakeSubtype = 1;\r\n\t\t\tm_nPos += 0;\r\n\t\t}\r\n\r\n\t}\r\n\telse if (m_strImgExifMake == _T(\"SIGMA\"))\r\n\t{\r\n\t\tstrTmp = _T(\"\");\r\n\t\tfor (unsigned ind=0;ind<8;ind++) {\r\n\t\t\tif (Buf(m_nPos+ind) != 0)\r\n\t\t\t\tstrTmp += (char)Buf(m_nPos+ind);\r\n\t\t}\r\n\t\tif ( (strTmp == _T(\"SIGMA\")) ||\r\n\t\t\t(strTmp == _T(\"FOVEON\"))  )\r\n\t\t{\r\n\t\t\t// Valid marker\r\n\t\t\t// Now skip over the 8-chars and 2 unknown chars\r\n\t\t\tm_nPos += 10;\r\n\t\t} else {\r\n\t\t\tCString strTmp = _T(\"ERROR: Unknown SIGMA Makernote identifier\");\r\n\t\t\tm_pLog->AddLineErr(strTmp);\r\n\t\t\tif (m_pAppConfig->bInteractive)\r\n\t\t\t\tAfxMessageBox(strTmp);\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\r\n\t} // SIGMA\r\n\telse if (m_strImgExifMake == _T(\"FUJIFILM\"))\r\n\t{\r\n\t\tstrTmp = _T(\"\");\r\n\t\tfor (unsigned ind=0;ind<8;ind++) {\r\n\t\t\tif (Buf(m_nPos+ind) != 0)\r\n\t\t\t\tstrTmp += (char)Buf(m_nPos+ind);\r\n\t\t}\r\n\t\tif (strTmp == _T(\"FUJIFILM\"))\r\n\t\t{\r\n\t\t\t// Valid marker\r\n\t\t\t// Now skip over the 8-chars and 4 Pointer chars\r\n\t\t\t// FIXME: Do I need to dereference this pointer?\r\n\t\t\tm_nPos += 12;\r\n\t\t} else {\r\n\t\t\tCString strTmp = _T(\"ERROR: Unknown FUJIFILM Makernote identifier\");\r\n\t\t\tm_pLog->AddLineErr(strTmp);\r\n\t\t\tif (m_pAppConfig->bInteractive)\r\n\t\t\t\tAfxMessageBox(strTmp);\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\r\n\t} // FUJIFILM\r\n\telse if (m_strImgExifMake == _T(\"SONY\"))\r\n\t{\r\n\t\tstrTmp = _T(\"\");\r\n\t\tfor (unsigned ind=0;ind<12;ind++) {\r\n\t\t\tif (Buf(m_nPos+ind) != 0)\r\n\t\t\t\tstrTmp += (char)Buf(m_nPos+ind);\r\n\t\t}\r\n\t\tif (strTmp == _T(\"SONY DSC \"))\r\n\t\t{\r\n\t\t\t// Valid marker\r\n\t\t\t// Now skip over the 9-chars and 3 null chars\r\n\t\t\tm_nPos += 12;\r\n\t\t} else {\r\n\t\t\tCString strTmp = _T(\"ERROR: Unknown SONY Makernote identifier\");\r\n\t\t\tm_pLog->AddLineErr(strTmp);\r\n\t\t\tif (m_pAppConfig->bInteractive)\r\n\t\t\t\tAfxMessageBox(strTmp);\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\r\n\t} // SONY\r\n\r\n\r\n\treturn TRUE;\r\n\r\n}\r\n\r\n// Read two UINT32 from the buffer (8B) and interpret\r\n// as a rational entry. Convert to floating point.\r\n// Byte swap as required\r\n//\r\n// INPUT:\r\n// - pos\t\tBuffer position\r\n// - val\t\tFloating point value\r\n//\r\n// RETURN:\r\n// - Was the conversion successful?\r\n//\r\nbool CjfifDecode::DecodeValRational(unsigned nPos,float &nVal)\r\n{\r\n\tint\tnValNumer;\r\n\tint nValDenom;\r\n\tnVal = 0;\r\n\r\n\tnValNumer = ByteSwap4(Buf(nPos+0),Buf(nPos+1),Buf(nPos+2),Buf(nPos+3));\r\n\tnValDenom = ByteSwap4(Buf(nPos+4),Buf(nPos+5),Buf(nPos+6),Buf(nPos+7));\r\n\r\n\tif (nValDenom == 0) {\r\n\t\t// Divide by zero!\r\n\t\treturn false;\r\n\t} else {\r\n\t\tnVal = (float)nValNumer/(float)nValDenom;\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\n// Read two UINT32 from the buffer (8B) to create a formatted\r\n// fraction string. Byte swap as required\r\n//\r\n// INPUT:\r\n// - pos\t\tBuffer position\r\n//\r\n// RETURN:\r\n// - Formatted string\r\n//\r\nCString CjfifDecode::DecodeValFraction(unsigned nPos)\r\n{\r\n\tCString strTmp;\r\n\tint nValNumer = ReadSwap4(nPos+0);\r\n\tint nValDenom = ReadSwap4(nPos+4);\r\n\tstrTmp.Format(_T(\"%d/%d\"),nValNumer,nValDenom);\r\n\treturn strTmp;\r\n}\r\n\r\n\r\n// Convert multiple coordinates into a formatted GPS string\r\n//\r\n// INPUT:\r\n// - nCount\t\tNumber of coordinates (1,2,3)\r\n// - fCoord1\tCoordinate #1\r\n// - fCoord2\tCoordinate #2\r\n// - fCoord3\tCoordinate #3\r\n//\r\n// OUTPUT:\r\n// - strCoord\tThe formatted GPS string\r\n//\r\n// RETURN:\r\n// - Was the conversion successful?\r\n//\r\nbool CjfifDecode::PrintValGPS(unsigned nCount, float fCoord1, float fCoord2, float fCoord3,CString &strCoord)\r\n{\r\n\tfloat\t\tfTemp;\r\n\tunsigned\tnCoordDeg;\r\n\tunsigned\tnCoordMin;\r\n\tfloat\t\tfCoordSec;\r\n\r\n\t// TODO: Extend to support 1 & 2 coordinate GPS entries\r\n\tif (nCount == 3) {\r\n\t\tnCoordDeg = unsigned(fCoord1);\r\n\t\tnCoordMin = unsigned(fCoord2);\r\n\t\tif (fCoord3 == 0) {\r\n\t\t\tfTemp = fCoord2 - (float)nCoordMin;\r\n\t\t\tfCoordSec = fTemp * (float)60.0;\r\n\t\t} else {\r\n\t\t\tfCoordSec = fCoord3;\r\n\t\t}\r\n\r\n\t\tstrCoord.Format(_T(\"%u deg %u' %.3f\\\"\"),nCoordDeg,nCoordMin,fCoordSec);\r\n\t\treturn true;\r\n\t} else {\r\n\t\tstrCoord.Format(_T(\"ERROR: Can't handle %u-comonent GPS coords\"),nCount);\r\n\t\treturn false;\r\n\t}\r\n\r\n}\r\n\r\n// Read in 3 rational values from the buffer and output as a formatted GPS string\r\n//\r\n// INPUT:\r\n// - pos\t\tBuffer position\r\n//\r\n// OUTPUT:\r\n// - strCoord\tThe formatted GPS string\r\n//\r\n// RETURN:\r\n// - Was the conversion successful?\r\n//\r\nbool CjfifDecode::DecodeValGPS(unsigned nPos,CString &strCoord)\r\n{\r\n\tfloat\t\tfCoord1,fCoord2,fCoord3;\r\n\tbool\t\tbRet;\r\n\r\n\tbRet = true;\r\n\tif (bRet) { bRet = DecodeValRational(nPos,fCoord1); nPos += 8; }\r\n\tif (bRet) { bRet = DecodeValRational(nPos,fCoord2); nPos += 8; }\r\n\tif (bRet) { bRet = DecodeValRational(nPos,fCoord3); nPos += 8; }\r\n\r\n\tif (!bRet) {\r\n\t\tstrCoord.Format(_T(\"???\"));\r\n\t\treturn false;\r\n\t} else {\r\n\t\treturn PrintValGPS(3,fCoord1,fCoord2,fCoord3,strCoord);\r\n\t}\r\n}\r\n\r\n// Read a UINT16 from the buffer, byte swap as required\r\n//\r\n// INPUT:\r\n// - nPos\t\tBuffer position\r\n//\r\n// RETURN:\r\n// - UINT16 from buffer\r\n//\r\nunsigned CjfifDecode::ReadSwap2(unsigned nPos)\r\n{\r\n\treturn ByteSwap2(Buf(nPos+0),Buf(nPos+1));\r\n}\r\n\r\n// Read a UINT32 from the buffer, byte swap as required\r\n//\r\n// INPUT:\r\n// - nPos\t\tBuffer position\r\n//\r\n// RETURN:\r\n// - UINT32 from buffer\r\n//\r\nunsigned CjfifDecode::ReadSwap4(unsigned nPos)\r\n{\r\n\treturn ByteSwap4(Buf(nPos),Buf(nPos+1),Buf(nPos+2),Buf(nPos+3));\r\n}\r\n\r\n// Read a UINT32 from the buffer, force as big endian\r\n//\r\n// INPUT:\r\n// - nPos\t\tBuffer position\r\n//\r\n// RETURN:\r\n// - UINT32 from buffer\r\n//\r\nunsigned CjfifDecode::ReadBe4(unsigned nPos)\r\n{\r\n\t// Big endian, no swap required\r\n\treturn (Buf(nPos)<<24) + (Buf(nPos+1)<<16) + (Buf(nPos+2)<<8) + Buf(nPos+3);\r\n}\r\n\r\n// Print hex from array of unsigned char\r\n//\r\n// INPUT:\r\n// - anBytes\tArray of unsigned chars\r\n// - nCount\t\tIndicates the number of array entries originally specified\r\n//\t\t\t\tbut the printing routine limits it to the maximum array depth\r\n//\t\t\t\tallocated (MAX_anValues) and add an ellipsis \"...\"\r\n// RETURN:\r\n// - A formatted string\r\n//\r\nCString CjfifDecode::PrintAsHexUC(unsigned char* anBytes,unsigned nCount)\r\n{\r\n\tCString strVal;\r\n\tCString strFull;\r\n\tstrFull = _T(\"0x[\");\r\n\tunsigned nMaxDisplay = MAX_anValues;\r\n\tbool bExceedMaxDisplay;\r\n\tbExceedMaxDisplay = (nCount > nMaxDisplay);\r\n\tfor (unsigned nInd=0;nInd<nCount;nInd++)\r\n\t{\r\n\t\tif (nInd < nMaxDisplay) {\r\n\t\t\tif ((nInd % 4) == 0) {\r\n\t\t\t\tif (nInd == 0) {\r\n\t\t\t\t\t// Don't do anything for first value!\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Every 16 add big spacer / break\r\n\t\t\t\t\tstrFull += _T(\" \");\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t//strFull += _T(\" \");\r\n\t\t\t}\r\n\r\n\t\t\tstrVal.Format(_T(\"%02X\"),anBytes[nInd]);\r\n\t\t\tstrFull += strVal;\r\n\t\t}\r\n\r\n\t\tif ((nInd == nMaxDisplay) && (bExceedMaxDisplay)) {\r\n\t\t\tstrFull += _T(\"...\");\r\n\t\t}\r\n\r\n\t}\r\n\tstrFull += _T(\"]\");\r\n\treturn strFull;\r\n}\r\n\r\n\r\n// Print hex from array of unsigned bytes\r\n//\r\n// INPUT:\r\n// - anBytes\tArray is passed as UINT32* even though it only\r\n//\t\t\t\trepresents a byte per entry\r\n// - nCount\t\tIndicates the number of array entries originally specified\r\n//\t\t\t\tbut the printing routine limits it to the maximum array depth\r\n//\t\t\t\tallocated (MAX_anValues) and add an ellipsis \"...\"\r\n//\r\n// RETURN:\r\n// - A formatted string\r\n//\r\nCString CjfifDecode::PrintAsHex8(unsigned* anBytes,unsigned nCount)\r\n{\r\n\tCString\t\tstrVal;\r\n\tCString\t\tstrFull;\r\n\tunsigned\tnMaxDisplay = MAX_anValues;\r\n\tbool\t\tbExceedMaxDisplay;\r\n\r\n\tstrFull = _T(\"0x[\");\r\n\tbExceedMaxDisplay = (nCount > nMaxDisplay);\r\n\tfor (unsigned nInd=0;nInd<nCount;nInd++)\r\n\t{\r\n\t\tif (nInd < nMaxDisplay) {\r\n\t\t\tif ((nInd % 4) == 0) {\r\n\t\t\t\tif (nInd == 0) {\r\n\t\t\t\t\t// Don't do anything for first value!\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Every 16 add big spacer / break\r\n\t\t\t\t\tstrFull += _T(\" \");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tstrVal.Format(_T(\"%02X\"),anBytes[nInd]);\r\n\t\t\tstrFull += strVal;\r\n\t\t}\r\n\r\n\t\tif ((nInd == nMaxDisplay) && (bExceedMaxDisplay)) {\r\n\t\t\tstrFull += _T(\"...\");\r\n\t\t}\r\n\r\n\t}\r\n\tstrFull += _T(\"]\");\r\n\treturn strFull;\r\n}\r\n\r\n// Print hex from array of unsigned words\r\n//\r\n// INPUT:\r\n// - anWords\t\tArray of UINT32 is passed\r\n// - nCount\t\t\tIndicates the number of array entries originally specified\r\n//\t\t\t\t\tbut the printing routine limits it to the maximum array depth\r\n//\t\t\t\t\tallocated (MAX_anValues) and add an ellipsis \"...\"\r\n//\r\n// RETURN:\r\n// - A formatted string\r\n//\r\nCString CjfifDecode::PrintAsHex32(unsigned* anWords,unsigned nCount)\r\n{\r\n\tCString strVal;\r\n\tCString strFull;\r\n\tstrFull = _T(\"0x[\");\r\n\tunsigned nMaxDisplay = MAX_anValues/4;\t// Reduce number of words to display since each is 32b not 8b\r\n\tbool bExceedMaxDisplay;\r\n\tbExceedMaxDisplay = (nCount > nMaxDisplay);\r\n\tfor (unsigned nInd=0;nInd<nCount;nInd++)\r\n\t{\r\n\t\tif (nInd < nMaxDisplay) {\r\n\t\t\tif (nInd == 0) {\r\n\t\t\t\t// Don't do anything for first value!\r\n\t\t\t} else {\r\n\t\t\t\t// Every word add a spacer\r\n\t\t\t\tstrFull += _T(\" \");\r\n\t\t\t}\r\n\r\n\t\t\tstrVal.Format(_T(\"%08X\"),anWords[nInd]);\t// 32-bit words\r\n\t\t\tstrFull += strVal;\r\n\t\t}\r\n\r\n\t\tif ((nInd == nMaxDisplay) && (bExceedMaxDisplay)) {\r\n\t\t\tstrFull += _T(\"...\");\r\n\t\t}\r\n\r\n\t}\r\n\tstrFull += _T(\"]\");\r\n\treturn strFull;\r\n}\r\n\r\n\r\n\r\n// Process all of the entries within an EXIF IFD directory\r\n// This is used for the main EXIF IFDs as well as MakerNotes\r\n//\r\n// INPUT:\r\n// - ifdStr\t\t\t\tThe IFD section that we are processing\r\n// - pos_exif_start\r\n// - start_ifd_ptr\t\t\r\n//\r\n// PRE:\r\n// - m_strImgExifMake\r\n// - m_bImgExifMakeSupported\r\n// - m_nImgExifMakeSubtype\r\n// - m_nImgExifMakerPtr\r\n//\r\n// RETURN:\r\n// - 0\t\t\t\t\tDecoding OK\r\n// - 2\t\t\t\t\tDecoding failure\r\n//\r\n// POST:\r\n// - m_nPos\r\n// - m_strImgExifMake\r\n// - m_strImgExifModel\r\n// - m_strImgQualExif\r\n// - m_strImgExtras\r\n// - m_strImgExifMake\r\n// - m_nImgExifSubIfdPtr\r\n// - m_nImgExifGpsIfdPtr\r\n// - m_nImgExifInteropIfdPtr\r\n// - m_bImgExifMakeSupported\r\n// - m_bImgExifMakernotes\r\n// - m_nImgExifMakerPtr\r\n// - m_nImgExifThumbComp\r\n// - m_nImgExifThumbOffset\r\n// - m_nImgExifThumbLen\r\n// - m_strSoftware\r\n//\r\n// NOTE:\r\n// - IFD1 typically contains the thumbnail\r\n//\r\nunsigned CjfifDecode::DecodeExifIfd(CString strIfd,unsigned nPosExifStart,unsigned nStartIfdPtr)\r\n{\r\n\t// Temp variables\r\n\tbool\t\t\tbRet;\r\n\tCString\t\t\tstrTmp;\r\n\tCStr2\t\t\tstrRetVal;\r\n\tCString\t\t\tstrValTmp;\r\n\tfloat\t\t\tfValReal;\r\n\tCString\t\t\tstrMaker;\r\n\r\n\t// Display output variables\r\n\tCString\t\t\tstrFull;\r\n\tCString\t\t\tstrValOut;\r\n\tBOOL\t\t\tbExtraDecode;\r\n\r\n\t// Primary IFD variables\r\n\tchar\t\tacIfdValOffsetStr[5];\r\n\tunsigned\tnIfdDirLen;\r\n\tunsigned\tnIfdTagVal;\r\n\tunsigned\tnIfdFormat;\r\n\tunsigned\tnIfdNumComps;\r\n\tbool\t\tnIfdTagUnknown;\r\n\r\n\r\n\tunsigned\tnCompsToDisplay;\t\t\t// Maximum number of values to capture for display\r\n\tunsigned\tanValues[MAX_anValues];\t\t// Array of decoded values (Uint32)\r\n\tsigned\t\tanValuesS[MAX_anValues];\t// Array of decoded values (Int32)\r\n\tfloat\t\tafValues[MAX_anValues];\t\t// Array of decoded values (float)\r\n\tunsigned\tnIfdOffset;\t\t\t\t\t// First DWORD decode, usually offset\r\n\r\n\r\n\t// Clear values array\r\n\tfor (unsigned ind=0;ind<MAX_anValues;ind++) {\r\n\t\tanValues[ind] = 0;\r\n\t\tanValuesS[ind] = 0;\r\n\t\tafValues[ind] = 0;\r\n\t}\r\n\r\n\t// ==========================================================================\r\n\t// Process IFD directory header\r\n\t// ==========================================================================\r\n\r\n\t// Move the file pointer to the start of the IFD\r\n\tm_nPos = nPosExifStart+nStartIfdPtr;\r\n\r\n\tstrTmp.Format(_T(\"  EXIF %s @ Absolute 0x%08X\"),(LPCTSTR)strIfd,m_nPos);\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\t////////////\r\n\r\n\t// NOTE: Nikon type 3 starts out with the ASCII string \"Nikon\\0\"\r\n\t//       before the rest of the items.\r\n\t// TODO: need to process type1,type2,type3\r\n\t// see: http://www.gvsoft.homedns.org/exif/makernote-nikon.html\r\n\r\n\tstrTmp.Format(_T(\"strIfd=[%s] m_strImgExifMake=[%s]\"),(LPCTSTR)strIfd,(LPCTSTR)m_strImgExifMake);\r\n\tDbgAddLine(strTmp);\r\n\r\n\r\n\t// If this is the MakerNotes section, then we may want to skip\r\n\t// altogether. Check to see if we are configured to process this\r\n\t// section or if it is a supported manufacturer.\r\n\r\n\tif (strIfd == _T(\"MakerIFD\"))\r\n\t{\r\n\t\t// Mark the image as containing Makernotes\r\n\t\tm_bImgExifMakernotes = true;\r\n\r\n\t\tif (!m_pAppConfig->bDecodeMaker) {\r\n\t\t\tstrTmp.Format(_T(\"    Makernote decode option not enabled.\"));\r\n\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t\t// If user didn't enable makernote decode, don't exit, just\r\n\t\t\t// hide output. We still want to get at some info (such as Quality setting).\r\n\t\t\t// At end, we'll need to re-enable it again.\r\n\t\t\tm_pLog->Disable();\r\n\t\t}\r\n\r\n\t\t// If this Make is not supported, we'll need to exit\r\n\t\tif (!m_bImgExifMakeSupported) {\r\n\t\t\tstrTmp.Format(_T(\"    Makernotes not yet supported for [%s]\"),(LPCTSTR)m_strImgExifMake);\r\n\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t\tm_pLog->Enable();\r\n\t\t\treturn 2;\r\n\t\t}\r\n\r\n\t\t// Determine the sub-type of the Maker field (if applicable)\r\n\t\t// and advance the m_nPos pointer past the custom header.\r\n\t\t// This call uses the class members: Buf(),m_nPos\r\n\t\tif (!DecodeMakerSubType())\r\n\t\t{\r\n\t\t\t// If the subtype decode failed, skip the processing\r\n\t\t\tm_pLog->Enable();\r\n\t\t\treturn 2;\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// ==========================================================================\r\n\t// Process IFD directory entries\r\n\t// ==========================================================================\r\n\r\n\tCString strIfdTag;\r\n\r\n\t// =========== EXIF IFD Header (Start) ===========\r\n\t// - Defined in Exif 2.2 Standard (JEITA CP-3451) section 4.6.2 \r\n\t// - Contents (2 bytes total)\r\n\t//   - Number of fields (2 bytes)\r\n\r\n\tnIfdDirLen = ReadSwap2(m_nPos);\r\n\tm_nPos+=2;\r\n\tstrTmp.Format(_T(\"    Dir Length = 0x%04X\"),nIfdDirLen);\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\t// =========== EXIF IFD Header (End) ===========\r\n\r\n\r\n\t// Start of IFD processing\r\n\t// Step through each IFD entry and determine the type and\r\n\t// decode accordingly.\r\n\tfor (unsigned nIfdEntryInd=0;nIfdEntryInd<nIfdDirLen;nIfdEntryInd++)\r\n\t{\r\n\r\n\t\t// By default, show single-line value summary\r\n\t\t// bExtraDecode is used to indicate that additional special\r\n\t\t// parsing output is available for this entry\r\n\t\tbExtraDecode = FALSE;\r\n\r\n\t\tstrTmp.Format(_T(\"    Entry #%02u:\"),nIfdEntryInd);\r\n\t\tDbgAddLine(strTmp);\r\n\r\n\t\t// =========== EXIF IFD Interoperability entry (Start) ===========\r\n\t\t// - Defined in Exif 2.2 Standard (JEITA CP-3451) section 4.6.2 \r\n\t\t// - Contents (12 bytes total)\r\n\t\t//   - Tag (2 bytes)\r\n\t\t//   - Type (2 bytes)\r\n\t\t//   - Count (4 bytes)\r\n\t\t//   - Value Offset (4 bytes)\r\n\r\n\t\t// Read Tag #\r\n\t\tnIfdTagVal = ReadSwap2(m_nPos);\r\n\t\tm_nPos+=2;\r\n\t\tnIfdTagUnknown = false;\r\n\t\tstrIfdTag = LookupExifTag(strIfd,nIfdTagVal,nIfdTagUnknown);\r\n\t\tstrTmp.Format(_T(\"      Tag # = 0x%04X = [%s]\"),nIfdTagVal,(LPCTSTR)strIfdTag);\r\n\t\tDbgAddLine(strTmp);\r\n\r\n\t\t// Read Format (or Type)\r\n\t\tnIfdFormat = ReadSwap2(m_nPos);\r\n\t\tm_nPos+=2;\r\n\t\tstrTmp.Format(_T(\"      Format # = 0x%04X\"),nIfdFormat);\r\n\t\tDbgAddLine(strTmp);\r\n\r\n\t\t// Read number of Components\r\n\t\tnIfdNumComps = ReadSwap4(m_nPos);\r\n\t\tm_nPos+=4;\r\n\t\tstrTmp.Format(_T(\"      # Comps = 0x%08X\"),nIfdNumComps);\r\n\t\tDbgAddLine(strTmp);\r\n\r\n\t\t// Check to see how many components have been listed.\r\n\t\t// This helps trap errors in corrupted IFD segments, otherwise\r\n\t\t// we will hang trying to decode millions of entries!\r\n\t\t// See issue & testcase #1148\r\n\t\tif (nIfdNumComps > 4000) {\r\n\t\t\t// Warn user that we have clippped the component list.\r\n\t\t\t// Note that this condition is only relevant when we are\r\n\t\t\t// processing the general array fields. Fields such as MakerNote\r\n\t\t\t// will also enter this condition so we shouldn't warn in those cases.\r\n\t\t\t//\r\n\t\t\t// TODO: Defer this warning message until after we are sure that we\r\n\t\t\t// didn't handle the large dataset elsewhere.\r\n\t\t\t// For now, only report this warning if we are not processing MakerNote\r\n\t\t\tif (strIfdTag.Compare(_T(\"MakerNote\"))!=0) {\r\n\t\t\t\tstrTmp.Format(_T(\"      Excessive # components (%u). Limiting to first 4000.\"),nIfdNumComps);\r\n\t\t\t\tm_pLog->AddLineWarn(strTmp);\r\n\t\t\t}\r\n\t\t\tnIfdNumComps = 4000;\r\n\t\t}\r\n\r\n\t\t// Read Component Value / Offset\r\n\t\t// We first treat it as a string and then re-interpret it as an integer\r\n\r\n\t\t// ... first as a string (just in case length <=4)\r\n\t\tfor (unsigned i=0;i<4;i++) {\r\n\t\t\tacIfdValOffsetStr[i] = (char)Buf(m_nPos+i);\r\n\t\t}\r\n\t\tacIfdValOffsetStr[4] = '\\0';\r\n\r\n\t\t// ... now as an unsigned value\r\n\t\t// This assignment is general-purpose, typically used when\r\n\t\t// we know that the IFD Value/Offset is just an offset\r\n\t\tnIfdOffset = ReadSwap4(m_nPos);\r\n\t\tstrTmp.Format(_T(\"      # Val/Offset = 0x%08X\"),nIfdOffset);\r\n\t\tDbgAddLine(strTmp);\r\n\r\n\t\t// =========== EXIF IFD Interoperability entry (End) ===========\r\n\r\n\r\n\t\t// ==========================================================================\r\n\t\t// Extract the IFD component entries\r\n\t\t// ==========================================================================\r\n\r\n\t\t// The EXIF IFD entries can appear in a wide range of\r\n\t\t// formats / data types. The formats that have been\r\n\t\t// publicly documented include:\r\n\t\t//   EXIF_FORMAT_BYTE       =  1,\r\n\t\t//   EXIF_FORMAT_ASCII      =  2,\r\n\t\t//   EXIF_FORMAT_SHORT      =  3,\r\n\t\t//   EXIF_FORMAT_LONG       =  4,\r\n\t\t//   EXIF_FORMAT_RATIONAL   =  5,\r\n\t\t//   EXIF_FORMAT_SBYTE      =  6,\r\n\t\t//   EXIF_FORMAT_UNDEFINED  =  7,\r\n\t\t//   EXIF_FORMAT_SSHORT     =  8,\r\n\t\t//   EXIF_FORMAT_SLONG      =  9,\r\n\t\t//   EXIF_FORMAT_SRATIONAL  = 10,\r\n\t\t//   EXIF_FORMAT_FLOAT      = 11,\r\n\t\t//   EXIF_FORMAT_DOUBLE     = 12\r\n\r\n\t\t// The IFD variable formatter logic operates in two stages:\r\n\t\t// In the first stage, the format type is decoded, which results\r\n\t\t// in a generic decode for the IFD entry. Then, we start a second\r\n\t\t// stage which re-interprets the values for a number of known\r\n\t\t// special types.\r\n\r\n\t\tswitch(nIfdFormat)\r\n\t\t{\r\n\r\n\t\t// ----------------------------------------\r\n\t\t// --- IFD Entry Type: Unsigned Byte\r\n\t\t// ----------------------------------------\r\n\t\tcase 1:\r\n\t\t\tstrFull = _T(\"        Unsigned Byte=[\");\r\n\t\t\tstrValOut = _T(\"\");\r\n\r\n\t\t\t// Limit display output\r\n\t\t\tnCompsToDisplay = min(MAX_anValues,nIfdNumComps);\r\n\r\n\t\t\t// If only a single value, use decimal, else use hex\r\n\t\t\tif (nIfdNumComps == 1) {\r\n\t\t\t\tanValues[0] = Buf(m_nPos+0);\r\n\t\t\t\tstrTmp.Format(_T(\"%u\"),anValues[0]);\r\n\t\t\t\tstrValOut += strTmp;\r\n\t\t\t} else {\r\n\t\t\t\tfor (unsigned nInd=0;nInd<nCompsToDisplay;nInd++)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (nIfdNumComps <= 4) {\r\n\t\t\t\t\t\t// Components fit inside 4B inline region\r\n\t\t\t\t\t\tanValues[nInd] = Buf(m_nPos+nInd);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// Since the components don't fit inside 4B inline region\r\n\t\t\t\t\t\t// we need to dereference\r\n\t\t\t\t\t\tanValues[nInd] = Buf(nPosExifStart+nIfdOffset+nInd);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tstrValOut = PrintAsHex8(anValues,nIfdNumComps);\r\n\t\t\t}\r\n\t\t\tstrFull += strValOut;\r\n\t\t\tstrFull += _T(\"]\");\r\n\t\t\tDbgAddLine(strFull);\r\n\t\t\tbreak;\r\n\r\n\r\n\t\t// ----------------------------------------\r\n\t\t// --- IFD Entry Type: ASCII string\r\n\t\t// ----------------------------------------\r\n\t\tcase 2:\r\n\t\t\tstrFull = _T(\"        String=\");\r\n\t\t\tstrValOut = _T(\"\");\r\n\t\t\tchar cVal;\r\n\t\t\tBYTE nVal;\r\n\r\n\t\t\t// Limit display output\r\n\t\t\t// TODO: Decide what an appropriate string limit would be\r\n\t\t\tnCompsToDisplay = min(250,nIfdNumComps);\r\n\r\n\t\t\tfor (unsigned nInd=0;nInd<nCompsToDisplay;nInd++)\r\n\t\t\t{\r\n\t\t\t\tif (nIfdNumComps<=4) {\r\n\t\t\t\t\tnVal = acIfdValOffsetStr[nInd];\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\t// TODO: See if this can be migrated to the \"custom decode\"\r\n\t\t\t\t\t// section later in the code. Decoding makernotes here is\r\n\t\t\t\t\t// less desirable but unfortunately some Nikon makernotes use\r\n\t\t\t\t\t// a non-standard offset value.\r\n\t\t\t\t\tif ( (strIfd == _T(\"MakerIFD\")) && (m_strImgExifMake == _T(\"NIKON\")) && (m_nImgExifMakeSubtype == 3) )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// It seems that pointers in the Nikon Makernotes are\r\n\t\t\t\t\t\t// done relative to the start of Maker IFD\r\n\t\t\t\t\t\t// But why 10? Is this 10 = 18-8?\r\n\t\t\t\t\t\tnVal = Buf(nPosExifStart+m_nImgExifMakerPtr+nIfdOffset+10+nInd);\r\n\t\t\t\t\t} else if ( (strIfd == _T(\"MakerIFD\")) && (m_strImgExifMake == _T(\"NIKON\")) )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// It seems that pointers in the Nikon Makernotes are\r\n\t\t\t\t\t\t// done relative to the start of Maker IFD\r\n\t\t\t\t\t\tnVal = Buf(nPosExifStart+nIfdOffset+0+nInd);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// Canon Makernotes seem to be relative to the start\r\n\t\t\t\t\t\t// of the EXIF IFD\r\n\t\t\t\t\t\tnVal = Buf(nPosExifStart+nIfdOffset+nInd);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Just in case the string has been null-terminated early\r\n\t\t\t\t// or we have garbage, replace with '.'\r\n\t\t\t\t// TODO: Clean this up\r\n\t\t\t\tif (nVal != 0) {\r\n\t\t\t\t\tcVal = (char)nVal;\r\n\t\t\t\t\tif (!isprint(nVal)) {\r\n\t\t\t\t\t\tcVal = '.';\r\n\t\t\t\t\t}\r\n\t\t\t\t\tstrValOut += cVal;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\tstrFull += strValOut;\r\n\t\t\tDbgAddLine(strFull);\r\n\r\n\t\t\t// TODO: Ideally, we would use a different string for display\r\n\t\t\t// purposes that is wrapped in quotes. Currently \"strValOut\" is used\r\n\t\t\t// in other sections of code (eg. in assignment to EXIF Make/Model/Software, etc.)\r\n\t\t\t// so we don't want to affect that.\r\n\r\n\t\t\tbreak;\r\n\r\n\r\n\t\t// ----------------------------------------\r\n\t\t// --- IFD Entry Type: Unsigned Short (2 bytes)\r\n\t\t// ----------------------------------------\r\n\t\tcase 3:\r\n\t\t\t// Limit display output\r\n\t\t\tnCompsToDisplay = min(MAX_anValues,nIfdNumComps);\r\n\r\n\t\t\t// Unsigned Short (2 bytes)\r\n\t\t\tif (nIfdNumComps == 1) {\r\n\t\t\t\tstrFull = _T(\"        Unsigned Short=[\");\r\n\t\t\t\t// TODO: Confirm endianness is correct here\r\n\t\t\t\t// Refer to Exif2-2 spec, page 14.\r\n\t\t\t\t// Currently selecting 2 byte conversion from [1:0] out of [3:0]\r\n\t\t\t\tanValues[0] = ReadSwap2(m_nPos);\r\n\t\t\t\tstrValOut.Format(_T(\"%u\"),anValues[0]);\r\n\t\t\t\tstrFull += strValOut;\r\n\t\t\t\tstrFull += _T(\"]\");\r\n\t\t\t\tDbgAddLine(strFull);\r\n\t\t\t} else if (nIfdNumComps == 2) {\r\n\t\t\t\tstrFull = _T(\"        Unsigned Short=[\");\r\n\t\t\t\t// 2 unsigned shorts in 1 word\r\n\t\t\t\tanValues[0] = ReadSwap2(m_nPos+0);\r\n\t\t\t\tanValues[1] = ReadSwap2(m_nPos+2);\r\n\t\t\t\tstrValOut.Format(_T(\"%u, %u\"),anValues[0],anValues[1]);\r\n\t\t\t\tstrFull += strValOut;\r\n\t\t\t\tstrFull += _T(\"]\");\r\n\t\t\t\tDbgAddLine(strFull);\r\n\t\t\t} else if (nIfdNumComps > MAX_IFD_COMPS) {\r\n\t\t\t\tstrValTmp.Format(_T(\"    Unsigned Short=[Too many entries (%u) to display]\"),nIfdNumComps);\r\n\t\t\t\tDbgAddLine(strValTmp);\r\n\t\t\t\tstrValOut.Format(_T(\"[Too many entries (%u) to display]\"),nIfdNumComps);\r\n\t\t\t} else {\r\n\t\t\t\t// Try to handle multiple entries... note that this\r\n\t\t\t\t// is used by the Maker notes IFD decode\r\n\r\n\t\t\t\tstrValOut = _T(\"\");\r\n\t\t\t\tstrFull = _T(\"        Unsigned Short=[\");\r\n\t\t\t\tfor (unsigned nInd=0;nInd<nCompsToDisplay;nInd++) {\r\n\t\t\t\t\tif (nInd!=0)\t{ strValOut += _T(\", \"); }\r\n\t\t\t\t\tanValues[nInd] = ReadSwap2(nPosExifStart+nIfdOffset+(2*nInd));\r\n\t\t\t\t\tstrValTmp.Format(_T(\"%u\"),anValues[nInd]);\r\n\t\t\t\t\tstrValOut += strValTmp;\r\n\t\t\t\t}\r\n\t\t\t\tstrFull += strValOut;\r\n\t\t\t\tstrFull += _T(\"]\");\r\n\t\t\t\tDbgAddLine(strFull);\r\n\r\n\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\r\n\r\n\t\t// ----------------------------------------\r\n\t\t// --- IFD Entry Type: Unsigned Long (4 bytes)\r\n\t\t// ----------------------------------------\r\n\t\tcase 4:\r\n\t\t\tstrFull = _T(\"        Unsigned Long=[\");\r\n\t\t\tstrValOut = _T(\"\");\r\n\r\n\t\t\t// Limit display output\r\n\t\t\tnCompsToDisplay = min(MAX_anValues,nIfdNumComps);\r\n\r\n\t\t\tfor (unsigned nInd=0;nInd<nCompsToDisplay;nInd++)\r\n\t\t\t{\r\n\t\t\t\tif (nIfdNumComps == 1) {\r\n\t\t\t\t\t// Components fit inside 4B inline region\r\n\t\t\t\t\tanValues[nInd] = ReadSwap4(m_nPos+(nInd*4));\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Since the components don't fit inside 4B inline region\r\n\t\t\t\t\t// we need to dereference\r\n\t\t\t\t\tanValues[nInd] = ReadSwap4(nPosExifStart+nIfdOffset+(nInd*4));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tstrValOut = PrintAsHex32(anValues,nIfdNumComps);\r\n\t\t\t// If we only have a single component, then display both the hex and decimal\r\n\t\t\tif (nCompsToDisplay==1) {\r\n\t\t\t\tstrTmp.Format(_T(\"%s / %u\"),(LPCTSTR)strValOut,anValues[0]);\r\n\t\t\t\tstrValOut = strTmp;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\r\n\r\n\t\t// ----------------------------------------\r\n\t\t// --- IFD Entry Type: Unsigned Rational (8 bytes)\r\n\t\t// ----------------------------------------\r\n\t\tcase 5:\r\n\t\t\t// Unsigned Rational\r\n\t\t\tstrFull = _T(\"        Unsigned Rational=[\");\r\n\t\t\tstrValOut = _T(\"\");\r\n\r\n\t\t\t// Limit display output\r\n\t\t\tnCompsToDisplay = min(MAX_anValues,nIfdNumComps);\r\n\r\n\t\t\tfor (unsigned nInd=0;nInd<nCompsToDisplay;nInd++)\r\n\t\t\t{\r\n\t\t\t\tif (nInd!=0)\t{ strValOut += _T(\", \"); }\r\n\t\t\t\tstrValTmp = DecodeValFraction(nPosExifStart+nIfdOffset+(nInd*8));\r\n\t\t\t\tbRet = DecodeValRational(nPosExifStart+nIfdOffset+(nInd*8),fValReal);\r\n\t\t\t\tafValues[nInd] = fValReal;\r\n\t\t\t\tstrValOut += strValTmp;\r\n\t\t\t}\r\n\t\t\tstrFull += strValOut;\r\n\t\t\tstrFull += _T(\"]\");\r\n\t\t\tDbgAddLine(strFull);\r\n\t\t\tbreak;\r\n\r\n\t\t// ----------------------------------------\r\n\t\t// --- IFD Entry Type: Undefined (?)\r\n\t\t// ----------------------------------------\r\n\t\tcase 7:\r\n\t\t\t// Undefined -- assume 1 word long\r\n\t\t\t// This is supposed to be a series of 8-bit bytes\r\n\t\t\t// It is usually used for 32-bit pointers (in case of offsets), but could\r\n\t\t\t// also represent ExifVersion, etc.\r\n\t\t\tstrFull = _T(\"        Undefined=[\");\r\n\t\t\tstrValOut = _T(\"\");\r\n\r\n\t\t\t// Limit display output\r\n\t\t\tnCompsToDisplay = min(MAX_anValues,nIfdNumComps);\r\n\t\t\t\r\n\t\t\tif (nIfdNumComps <= 4) {\r\n\t\t\t\t// This format is not defined, so output as hex for now\r\n\t\t\t\tfor (unsigned nInd=0;nInd<nCompsToDisplay;nInd++) {\r\n\t\t\t\t\tanValues[nInd] = Buf(m_nPos+nInd);\r\n\t\t\t\t}\r\n\t\t\t\tstrValOut = PrintAsHex8(anValues,nIfdNumComps);\r\n\t\t\t\tstrFull += strValOut;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// Dereference pointer\r\n\t\t\t\tfor (unsigned nInd=0;nInd<nCompsToDisplay;nInd++) {\r\n\t\t\t\t\tanValues[nInd] = Buf(nPosExifStart+nIfdOffset+nInd);\r\n\t\t\t\t}\r\n\t\t\t\tstrValOut = PrintAsHex8(anValues,nIfdNumComps);\r\n\t\t\t\tstrFull += strValOut;\r\n\t\t\t}\r\n\t\t\tstrFull += _T(\"]\");\r\n\t\t\tDbgAddLine(strFull);\r\n\r\n\t\t\tbreak;\r\n\r\n\r\n\t\t// ----------------------------------------\r\n\t\t// --- IFD Entry Type: Signed Short (2 bytes)\r\n\t\t// ----------------------------------------\r\n\t\tcase 8:\r\n\t\t\t// Limit display output\r\n\t\t\tnCompsToDisplay = min(MAX_anValues,nIfdNumComps);\r\n\r\n\t\t\t// Signed Short (2 bytes)\r\n\t\t\tif (nIfdNumComps == 1) {\r\n\t\t\t\tstrFull = _T(\"        Signed Short=[\");\r\n\t\t\t\t// TODO: Confirm endianness is correct here\r\n\t\t\t\t// Refer to Exif2-2 spec, page 14.\r\n\t\t\t\t// Currently selecting 2 byte conversion from [1:0] out of [3:0]\r\n\r\n\t\t\t\t// TODO: Ensure that ReadSwap2 handles signed notation properly\r\n\t\t\t\tanValuesS[0] = ReadSwap2(m_nPos);\r\n\t\t\t\tstrValOut.Format(_T(\"%d\"),anValuesS[0]);\r\n\t\t\t\tstrFull += strValOut;\r\n\t\t\t\tstrFull += _T(\"]\");\r\n\t\t\t\tDbgAddLine(strFull);\r\n\t\t\t} else if (nIfdNumComps == 2) {\r\n\t\t\t\tstrFull = _T(\"        Signed Short=[\");\r\n\t\t\t\t// 2 signed shorts in 1 word\r\n\r\n\t\t\t\t// TODO: Ensure that ReadSwap2 handles signed notation properly\r\n\t\t\t\tanValuesS[0] = ReadSwap2(m_nPos+0);\r\n\t\t\t\tanValuesS[1] = ReadSwap2(m_nPos+2);\r\n\t\t\t\tstrValOut.Format(_T(\"%d, %d\"),anValuesS[0],anValuesS[0]);\r\n\t\t\t\tstrFull += strValOut;\r\n\t\t\t\tstrFull += _T(\"]\");\r\n\t\t\t\tDbgAddLine(strFull);\r\n\t\t\t} else if (nIfdNumComps > MAX_IFD_COMPS) {\r\n\t\t\t\t// Only print it out if it has less than MAX_IFD_COMPS entries\r\n\t\t\t\tstrValTmp.Format(_T(\"    Signed Short=[Too many entries (%u) to display]\"),nIfdNumComps);\r\n\t\t\t\tDbgAddLine(strValTmp);\r\n\t\t\t\tstrValOut.Format(_T(\"[Too many entries (%u) to display]\"),nIfdNumComps);\r\n\t\t\t} else {\r\n\t\t\t\t// Try to handle multiple entries... note that this\r\n\t\t\t\t// is used by the Maker notes IFD decode\r\n\r\n\t\t\t\t// Note that we don't call LookupMakerCanonTag() here\r\n\t\t\t\t// as that is only needed for the \"unsigned short\", not\r\n\t\t\t\t// \"signed short\".\r\n\t\t\t\tstrValOut = _T(\"\");\r\n\t\t\t\tstrFull = _T(\"        Signed Short=[\");\r\n\t\t\t\tfor (unsigned nInd=0;nInd<nCompsToDisplay;nInd++) {\r\n\t\t\t\t\tif (nInd!=0)\t{ strValOut += _T(\", \"); }\r\n\t\t\t\t\tanValuesS[nInd] = ReadSwap2(nPosExifStart+nIfdOffset+(2*nInd));\r\n\t\t\t\t\tstrValTmp.Format(_T(\"%d\"),anValuesS[nInd]);\r\n\t\t\t\t\tstrValOut += strValTmp;\r\n\t\t\t\t}\r\n\t\t\t\tstrFull += strValOut;\r\n\t\t\t\tstrFull += _T(\"]\");\r\n\t\t\t\tDbgAddLine(strFull);\r\n\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\r\n\r\n\r\n\t\t// ----------------------------------------\r\n\t\t// --- IFD Entry Type: Signed Rational (8 bytes)\r\n\t\t// ----------------------------------------\r\n\t\tcase 10:\r\n\t\t\t// Signed Rational\r\n\t\t\tstrFull = _T(\"        Signed Rational=[\");\r\n\t\t\tstrValOut = _T(\"\");\r\n\r\n\t\t\t// Limit display output\r\n\t\t\tnCompsToDisplay = min(MAX_anValues,nIfdNumComps);\r\n\r\n\t\t\tfor (unsigned nInd=0;nInd<nCompsToDisplay;nInd++)\r\n\t\t\t{\r\n\t\t\t\tif (nInd!=0)\t{ strValOut += _T(\", \"); }\r\n\t\t\t\tstrValTmp = DecodeValFraction(nPosExifStart+nIfdOffset+(nInd*8));\r\n\t\t\t\tbRet = DecodeValRational(nPosExifStart+nIfdOffset+(nInd*8),fValReal);\r\n\t\t\t\tafValues[nInd] = fValReal;\r\n\t\t\t\tstrValOut += strValTmp;\r\n\t\t\t}\r\n\t\t\tstrFull += strValOut;\r\n\t\t\tstrFull += _T(\"]\");\r\n\t\t\tDbgAddLine(strFull);\r\n\t\t\tbreak;\r\n\r\n\t\tdefault:\r\n\t\t\tstrTmp.Format(_T(\"ERROR: Unsupported format [%d]\"),nIfdFormat);\r\n\t\t\tanValues[0] = ReadSwap4(m_nPos);\r\n\t\t\tstrValOut.Format(_T(\"0x%08X???\"),anValues[0]);\r\n\t\t\tm_pLog->Enable();\r\n\t\t\treturn 2;\r\n\t\t\tbreak;\r\n\t\t} // switch nIfdTagVal\r\n\r\n\r\n\r\n\t\t// ==========================================================================\r\n\t\t// Custom Value String decodes\r\n\t\t// ==========================================================================\r\n\r\n\t\t// At this point we might re-format the values, thereby\r\n\t\t// overriding the default strValOut. We have access to the\r\n\t\t//   anValues[]  (array of unsigned int)\r\n\t\t//   anValuesS[] (array of signed int)\r\n\t\t//   afValues[]  (array of float)\r\n\r\n\t\t// Re-format special output items\r\n\t\t//   This will override \"strValOut\" that may have previously been defined\r\n\r\n\t\tif ((strIfdTag == _T(\"GPSLatitude\")) ||\r\n\t\t\t(strIfdTag == _T(\"GPSLongitude\"))) {\r\n\t\t\tbRet = PrintValGPS(nIfdNumComps,afValues[0],afValues[1],afValues[2],strValOut);\r\n\t\t} else if (strIfdTag == _T(\"GPSVersionID\")) {\r\n\t\t\tstrValOut.Format(_T(\"%u.%u.%u.%u\"),anValues[0],anValues[1],anValues[2],anValues[3]);\r\n\t\t} else if (strIfdTag == _T(\"GPSAltitudeRef\")) {\r\n\t\t\tswitch (anValues[0]) {\r\n\t\t\t\tcase 0 : strValOut = _T(\"Above Sea Level\"); break;\r\n\t\t\t\tcase 1 : strValOut = _T(\"Below Sea Level\"); break;\r\n\t\t\t}\r\n\t\t} else if (strIfdTag == _T(\"GPSStatus\")) {\r\n\t\t\tswitch (acIfdValOffsetStr[0]) {\r\n\t\t\t\tcase 'A' : strValOut = _T(\"Measurement in progress\"); break;\r\n\t\t\t\tcase 'V' : strValOut = _T(\"Measurement Interoperability\"); break;\r\n\t\t\t}\r\n\t\t} else if (strIfdTag == _T(\"GPSMeasureMode\")) {\r\n\t\t\tswitch (acIfdValOffsetStr[0]) {\r\n\t\t\t\tcase '2' : strValOut = _T(\"2-dimensional\"); break;\r\n\t\t\t\tcase '3' : strValOut = _T(\"3-dimensional\"); break;\r\n\t\t\t}\r\n\t\t} else if ((strIfdTag == _T(\"GPSSpeedRef\")) ||\r\n\t\t\t\t\t(strIfdTag == _T(\"GPSDestDistanceRef\"))) {\r\n\t\t\tswitch (acIfdValOffsetStr[0]) {\r\n\t\t\t\tcase 'K' : strValOut = _T(\"km/h\"); break;\r\n\t\t\t\tcase 'M' : strValOut = _T(\"mph\"); break;\r\n\t\t\t\tcase 'N' : strValOut = _T(\"knots\"); break;\r\n\t\t\t}\r\n\t\t} else if ((strIfdTag == _T(\"GPSTrackRef\")) ||\r\n\t\t\t\t\t(strIfdTag == _T(\"GPSImgDirectionRef\")) ||\r\n\t\t\t\t\t(strIfdTag == _T(\"GPSDestBearingRef\"))) {\r\n\t\t\tswitch (acIfdValOffsetStr[0]) {\r\n\t\t\t\tcase 'T' : strValOut = _T(\"True direction\"); break;\r\n\t\t\t\tcase 'M' : strValOut = _T(\"Magnetic direction\"); break;\r\n\t\t\t}\r\n\t\t} else if (strIfdTag == _T(\"GPSDifferential\")) {\r\n\t\t\tswitch (anValues[0]) {\r\n\t\t\t\tcase 0 : strValOut = _T(\"Measurement without differential correction\"); break;\r\n\t\t\t\tcase 1 : strValOut = _T(\"Differential correction applied\"); break;\r\n\t\t\t}\r\n\t\t} else if (strIfdTag == _T(\"GPSAltitude\")) {\r\n\t\t\tstrValOut.Format(_T(\"%.3f m\"),afValues[0]);\r\n\t\t} else if (strIfdTag == _T(\"GPSSpeed\")) {\r\n\t\t\tstrValOut.Format(_T(\"%.3f\"),afValues[0]);\r\n\t\t} else if (strIfdTag == _T(\"GPSTimeStamp\")) {\r\n\t\t\tstrValOut.Format(_T(\"%.0f:%.0f:%.2f\"),afValues[0],afValues[1],afValues[2]);\r\n\t\t} else if (strIfdTag == _T(\"GPSTrack\")) {\r\n\t\t\tstrValOut.Format(_T(\"%.2f\"),afValues[0]);\r\n\t\t} else if (strIfdTag == _T(\"GPSDOP\")) {\r\n\t\t\tstrValOut.Format(_T(\"%.4f\"),afValues[0]);\r\n\t\t}\r\n\r\n\r\n\t\tif (strIfdTag == _T(\"Compression\")) {\r\n\t\t\tswitch (anValues[0]) {\r\n\t\t\t\tcase 1 : strValOut = _T(\"None\"); break;\r\n\t\t\t\tcase 6 : strValOut = _T(\"JPEG\"); break;\r\n\t\t\t}\r\n\t\t} else if (strIfdTag == _T(\"ExposureTime\")) {\r\n\t\t\t// Assume only one\r\n\t\t\tstrValTmp = strValOut;\r\n\t\t\tstrValOut.Format(_T(\"%s s\"),(LPCTSTR)strValTmp);\r\n\t\t} else if (strIfdTag == _T(\"FNumber\")) {\r\n\t\t\t// Assume only one\r\n\t\t\tstrValOut.Format(_T(\"F%.1f\"),afValues[0]);\r\n\t\t} else if (strIfdTag == _T(\"FocalLength\")) {\r\n\t\t\t// Assume only one\r\n\t\t\tstrValOut.Format(_T(\"%.0f mm\"),afValues[0]);\r\n\t\t} else if (strIfdTag == _T(\"ExposureBiasValue\")) {\r\n\t\t\t// Assume only one\r\n\t\t\t// TODO: Need to test negative numbers\r\n\t\t\tstrValOut.Format(_T(\"%0.2f eV\"),afValues[0]);\r\n\t\t} else if (strIfdTag == _T(\"ExifVersion\")) {\r\n\t\t\t// Assume only one\r\n\t\t\tstrValOut.Format(_T(\"%c%c.%c%c\"),anValues[0],anValues[1],anValues[2],anValues[3]);\r\n\t\t} else if (strIfdTag == _T(\"FlashPixVersion\")) {\r\n\t\t\t// Assume only one\r\n\t\t\tstrValOut.Format(_T(\"%c%c.%c%c\"),anValues[0],anValues[1],anValues[2],anValues[3]);\r\n\t\t} else if (strIfdTag == _T(\"PhotometricInterpretation\")) {\r\n\t\t\tswitch (anValues[0]) {\r\n\t\t\t\tcase 1 : strValOut = _T(\"Monochrome\"); break;\r\n\t\t\t\tcase 2 : strValOut = _T(\"RGB\"); break;\r\n\t\t\t\tcase 6 : strValOut = _T(\"YCbCr\"); break;\r\n\t\t\t}\r\n\t\t} else if (strIfdTag == _T(\"Orientation\")) {\r\n\t\t\tswitch (anValues[0]) {\r\n\t\t\t\tcase 1 : strValOut = _T(\"1 = Row 0: top, Col 0: left\"); break;\r\n\t\t\t\tcase 2 : strValOut = _T(\"2 = Row 0: top, Col 0: right\"); break;\r\n\t\t\t\tcase 3 : strValOut = _T(\"3 = Row 0: bottom, Col 0: right\"); break;\r\n\t\t\t\tcase 4 : strValOut = _T(\"4 = Row 0: bottom, Col 0: left\"); break;\r\n\t\t\t\tcase 5 : strValOut = _T(\"5 = Row 0: left, Col 0: top\"); break;\r\n\t\t\t\tcase 6 : strValOut = _T(\"6 = Row 0: right, Col 0: top\"); break;\r\n\t\t\t\tcase 7 : strValOut = _T(\"7 = Row 0: right, Col 0: bottom\"); break;\r\n\t\t\t\tcase 8 : strValOut = _T(\"8 = Row 0: left, Col 0: bottom\"); break;\r\n\t\t\t}\r\n\t\t} else if (strIfdTag == _T(\"PlanarConfiguration\")) {\r\n\t\t\tswitch (anValues[0]) {\r\n\t\t\t\tcase 1 : strValOut = _T(\"Chunky format\"); break;\r\n\t\t\t\tcase 2 : strValOut = _T(\"Planar format\"); break;\r\n\t\t\t}\r\n\t\t} else if (strIfdTag == _T(\"YCbCrSubSampling\")) {\r\n\t\t\tswitch (anValues[0]*65536 + anValues[1]) {\r\n\t\t\t\tcase 0x00020001 : strValOut = _T(\"4:2:2\"); break;\r\n\t\t\t\tcase 0x00020002 : strValOut = _T(\"4:2:0\"); break;\r\n\t\t\t}\r\n\t\t} else if (strIfdTag == _T(\"YCbCrPositioning\")) {\r\n\t\t\tswitch (anValues[0]) {\r\n\t\t\t\tcase 1 : strValOut = _T(\"Centered\"); break;\r\n\t\t\t\tcase 2 : strValOut = _T(\"Co-sited\"); break;\r\n\t\t\t}\r\n\t\t} else if (strIfdTag == _T(\"ResolutionUnit\")) {\r\n\t\t\tswitch (anValues[0]) {\r\n\t\t\t\tcase 1 : strValOut = _T(\"None\"); break;\r\n\t\t\t\tcase 2 : strValOut = _T(\"Inch\"); break;\r\n\t\t\t\tcase 3 : strValOut = _T(\"Centimeter\"); break;\r\n\t\t\t}\r\n\t\t} else if (strIfdTag == _T(\"FocalPlaneResolutionUnit\")) {\r\n\t\t\tswitch (anValues[0]) {\r\n\t\t\t\tcase 1 : strValOut = _T(\"None\"); break;\r\n\t\t\t\tcase 2 : strValOut = _T(\"Inch\"); break;\r\n\t\t\t\tcase 3 : strValOut = _T(\"Centimeter\"); break;\r\n\t\t\t}\r\n\t\t} else if (strIfdTag == _T(\"ColorSpace\")) {\r\n\t\t\tswitch (anValues[0]) {\r\n\t\t\t\tcase 1 : strValOut = _T(\"sRGB\"); break;\r\n\t\t\t\tcase 0xFFFF : strValOut = _T(\"Uncalibrated\"); break;\r\n\t\t\t}\r\n\t\t} else if (strIfdTag == _T(\"ComponentsConfiguration\")) {\r\n\t\t\t// Undefined type, assume 4 bytes\r\n\t\t\tstrValOut = _T(\"[\");\r\n\t\t\tfor (unsigned vind=0;vind<4;vind++) {\r\n\t\t\t\tif (vind != 0) { strValOut += _T(\" \"); }\r\n\t\t\t\tswitch (anValues[vind]) {\r\n\t\t\t\t\tcase 0 : strValOut += _T(\".\"); break;\r\n\t\t\t\t\tcase 1 : strValOut += _T(\"Y\"); break;\r\n\t\t\t\t\tcase 2 : strValOut += _T(\"Cb\"); break;\r\n\t\t\t\t\tcase 3 : strValOut += _T(\"Cr\"); break;\r\n\t\t\t\t\tcase 4 : strValOut += _T(\"R\"); break;\r\n\t\t\t\t\tcase 5 : strValOut += _T(\"G\"); break;\r\n\t\t\t\t\tcase 6 : strValOut += _T(\"B\"); break;\r\n\t\t\t\t\tdefault : strValOut += _T(\"?\"); break;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tstrValOut += _T(\"]\");\r\n\r\n\t\t} else if ( (strIfdTag == _T(\"XPTitle\")) ||\r\n\t\t\t\t\t(strIfdTag == _T(\"XPComment\")) ||\r\n\t\t\t\t\t(strIfdTag == _T(\"XPAuthor\")) ||\r\n\t\t\t\t\t(strIfdTag == _T(\"XPKeywords\")) ||\r\n\t\t\t\t\t(strIfdTag == _T(\"XPSubject\")) ) {\r\n\t\t\tstrValOut = _T(\"\\\"\");\r\n\t\t\tCString\t\tstrVal;\r\n\t\t\tstrVal = m_pWBuf->BufReadUniStr2(nPosExifStart+nIfdOffset,nIfdNumComps);\r\n\t\t\tstrValOut += strVal;\r\n\t\t\tstrValOut += _T(\"\\\"\");\r\n\r\n\t\t} else if (strIfdTag == _T(\"UserComment\")) {\r\n\t\t\t// Character code\r\n\t\t\tunsigned anCharCode[8];\r\n\t\t\tfor (unsigned vInd=0;vInd<8;vInd++) {\r\n\t\t\t\tanCharCode[vInd] = Buf(nPosExifStart+nIfdOffset+0+vInd);\r\n\t\t\t}\r\n\t\t\t// Actual string\r\n\t\t\tstrValOut = _T(\"\\\"\");\r\n\t\t\tbool bDone = false;\r\n\t\t\tchar cTmp;\r\n\r\n\t\t\tfor (unsigned vInd=0;(vInd<nIfdNumComps-8)&&(!bDone);vInd++) {\r\n\t\t\t\tcTmp = (char)Buf(nPosExifStart+nIfdOffset+8+vInd);\r\n\t\t\t\tif (cTmp == 0) { bDone = true; } else {\tstrValOut += cTmp;\t}\r\n\t\t\t}\r\n\t\t\tstrValOut += _T(\"\\\"\");\r\n\t\t} else if (strIfdTag == _T(\"MeteringMode\")) {\r\n\t\t\tswitch (anValues[0]) {\r\n\t\t\t\tcase 0 : strValOut = _T(\"Unknown\"); break;\r\n\t\t\t\tcase 1 : strValOut = _T(\"Average\"); break;\r\n\t\t\t\tcase 2 : strValOut = _T(\"CenterWeightedAverage\"); break;\r\n\t\t\t\tcase 3 : strValOut = _T(\"Spot\"); break;\r\n\t\t\t\tcase 4 : strValOut = _T(\"MultiSpot\"); break;\r\n\t\t\t\tcase 5 : strValOut = _T(\"Pattern\"); break;\r\n\t\t\t\tcase 6 : strValOut = _T(\"Partial\"); break;\r\n\t\t\t\tcase 255 : strValOut = _T(\"Other\"); break;\r\n\t\t\t}\r\n\t\t} else if (strIfdTag == _T(\"ExposureProgram\")) {\r\n\t\t\tswitch (anValues[0]) {\r\n\t\t\t\tcase 0 : strValOut = _T(\"Not defined\"); break;\r\n\t\t\t\tcase 1 : strValOut = _T(\"Manual\"); break;\r\n\t\t\t\tcase 2 : strValOut = _T(\"Normal program\"); break;\r\n\t\t\t\tcase 3 : strValOut = _T(\"Aperture priority\"); break;\r\n\t\t\t\tcase 4 : strValOut = _T(\"Shutter priority\"); break;\r\n\t\t\t\tcase 5 : strValOut = _T(\"Creative program (depth of field)\"); break;\r\n\t\t\t\tcase 6 : strValOut = _T(\"Action program (fast shutter speed)\"); break;\r\n\t\t\t\tcase 7 : strValOut = _T(\"Portrait mode\"); break;\r\n\t\t\t\tcase 8 : strValOut = _T(\"Landscape mode\"); break;\r\n\t\t\t}\r\n\t\t} else if (strIfdTag == _T(\"Flash\")) {\r\n\t\t\tswitch (anValues[0] & 1) {\r\n\t\t\t\tcase 0 : strValOut = _T(\"Flash did not fire\"); break;\r\n\t\t\t\tcase 1 : strValOut = _T(\"Flash fired\"); break;\r\n\t\t\t}\r\n\t\t\t// TODO: Add other bitfields?\r\n\t\t} else if (strIfdTag == _T(\"SensingMethod\")) {\r\n\t\t\tswitch (anValues[0]) {\r\n\t\t\t\tcase 1 : strValOut = _T(\"Not defined\"); break;\r\n\t\t\t\tcase 2 : strValOut = _T(\"One-chip color area sensor\"); break;\r\n\t\t\t\tcase 3 : strValOut = _T(\"Two-chip color area sensor\"); break;\r\n\t\t\t\tcase 4 : strValOut = _T(\"Three-chip color area sensor\"); break;\r\n\t\t\t\tcase 5 : strValOut = _T(\"Color sequential area sensor\"); break;\r\n\t\t\t\tcase 7 : strValOut = _T(\"Trilinear sensor\"); break;\r\n\t\t\t\tcase 8 : strValOut = _T(\"Color sequential linear sensor\"); break;\r\n\t\t\t}\r\n\t\t} else if (strIfdTag == _T(\"FileSource\")) {\r\n\t\t\tswitch (anValues[0]) {\r\n\t\t\t\tcase 3 : strValOut = _T(\"DSC\"); break;\r\n\t\t\t}\r\n\t\t} else if (strIfdTag == _T(\"CustomRendered\")) {\r\n\t\t\tswitch (anValues[0]) {\r\n\t\t\t\tcase 0 : strValOut = _T(\"Normal process\"); break;\r\n\t\t\t\tcase 1 : strValOut = _T(\"Custom process\"); break;\r\n\t\t\t}\r\n\t\t} else if (strIfdTag == _T(\"ExposureMode\")) {\r\n\t\t\tswitch (anValues[0]) {\r\n\t\t\t\tcase 0 : strValOut = _T(\"Auto exposure\"); break;\r\n\t\t\t\tcase 1 : strValOut = _T(\"Manual exposure\"); break;\r\n\t\t\t\tcase 2 : strValOut = _T(\"Auto bracket\"); break;\r\n\t\t\t}\r\n\t\t} else if (strIfdTag == _T(\"WhiteBalance\")) {\r\n\t\t\tswitch (anValues[0]) {\r\n\t\t\t\tcase 0 : strValOut = _T(\"Auto white balance\"); break;\r\n\t\t\t\tcase 1 : strValOut = _T(\"Manual white balance\"); break;\r\n\t\t\t}\r\n\t\t} else if (strIfdTag == _T(\"SceneCaptureType\")) {\r\n\t\t\tswitch (anValues[0]) {\r\n\t\t\t\tcase 0 : strValOut = _T(\"Standard\"); break;\r\n\t\t\t\tcase 1 : strValOut = _T(\"Landscape\"); break;\r\n\t\t\t\tcase 2 : strValOut = _T(\"Portrait\"); break;\r\n\t\t\t\tcase 3 : strValOut = _T(\"Night scene\"); break;\r\n\t\t\t}\r\n\t\t} else if (strIfdTag == _T(\"SceneType\")) {\r\n\t\t\tswitch (anValues[0]) {\r\n\t\t\t\tcase 1 : strValOut = _T(\"A directly photographed image\"); break;\r\n\t\t\t}\r\n\t\t} else if (strIfdTag == _T(\"LightSource\")) {\r\n\t\t\tswitch (anValues[0]) {\r\n\t\t\t\tcase 0 : strValOut = _T(\"unknown\"); break;\r\n\t\t\t\tcase 1 : strValOut = _T(\"Daylight\"); break;\r\n\t\t\t\tcase 2 : strValOut = _T(\"Fluorescent\"); break;\r\n\t\t\t\tcase 3 : strValOut = _T(\"Tungsten (incandescent light)\"); break;\r\n\t\t\t\tcase 4 : strValOut = _T(\"Flash\"); break;\r\n\t\t\t\tcase 9 : strValOut = _T(\"Fine weather\"); break;\r\n\t\t\t\tcase 10 : strValOut = _T(\"Cloudy weather\"); break;\r\n\t\t\t\tcase 11 : strValOut = _T(\"Shade\"); break;\r\n\t\t\t\tcase 12 : strValOut = _T(\"Daylight fluorescent (D 5700 \ufffd 7100K)\"); break;\r\n\t\t\t\tcase 13 : strValOut = _T(\"Day white fluorescent (N 4600 \ufffd 5400K)\"); break;\r\n\t\t\t\tcase 14 : strValOut = _T(\"Cool white fluorescent (W 3900 \ufffd 4500K)\"); break;\r\n\t\t\t\tcase 15 : strValOut = _T(\"White fluorescent (WW 3200 \ufffd 3700K)\"); break;\r\n\t\t\t\tcase 17 : strValOut = _T(\"Standard light A\"); break;\r\n\t\t\t\tcase 18 : strValOut = _T(\"Standard light B\"); break;\r\n\t\t\t\tcase 19 : strValOut = _T(\"Standard light C\"); break;\r\n\t\t\t\tcase 20 : strValOut = _T(\"D55\"); break;\r\n\t\t\t\tcase 21 : strValOut = _T(\"D65\"); break;\r\n\t\t\t\tcase 22 : strValOut = _T(\"D75\"); break;\r\n\t\t\t\tcase 23 : strValOut = _T(\"D50\"); break;\r\n\t\t\t\tcase 24 : strValOut = _T(\"ISO studio tungsten\"); break;\r\n\t\t\t\tcase 255 : strValOut = _T(\"other light source\"); break;\r\n\t\t\t}\r\n\t\t} else if (strIfdTag == _T(\"SubjectArea\")) {\r\n\t\t\tswitch (nIfdNumComps) {\r\n\t\t\t\tcase 2 :\r\n\t\t\t\t\t// coords\r\n\t\t\t\t\tstrValOut.Format(_T(\"Coords: Center=[%u,%u]\"),\r\n\t\t\t\t\t\tanValues[0],anValues[1]);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 3 :\r\n\t\t\t\t\t// circle\r\n\t\t\t\t\tstrValOut.Format(_T(\"Coords (Circle): Center=[%u,%u] Diameter=%u\"),\r\n\t\t\t\t\t\tanValues[0],anValues[1],anValues[2]);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 4 :\r\n\t\t\t\t\t// rectangle\r\n\t\t\t\t\tstrValOut.Format(_T(\"Coords (Rect): Center=[%u,%u] Width=%u Height=%u\"),\r\n\t\t\t\t\t\tanValues[0],anValues[1],anValues[2],anValues[3]);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\t// Leave default decode, unexpected value\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (strIfdTag == _T(\"CFAPattern\")) {\r\n\t\t\tunsigned nHorzRepeat,nVertRepeat;\r\n\t\t\tunsigned anCfaVal[16][16];\r\n\t\t\tunsigned nInd=0;\r\n\t\t\tunsigned nVal;\r\n\t\t\tCString\t strLine,strCol;\r\n\t\t\tnHorzRepeat = anValues[nInd+0]*256+anValues[nInd+1];\r\n\t\t\tnVertRepeat = anValues[nInd+2]*256+anValues[nInd+3];\r\n\t\t\tnInd+=4;\r\n\t\t\tif ((nHorzRepeat < 16) && (nVertRepeat < 16)) {\r\n\t\t\t\tbExtraDecode = TRUE;\r\n\t\t\t\tstrTmp.Format(_T(\"    [%-36s] =\"),(LPCTSTR)strIfdTag);\r\n\t\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t\t\tfor (unsigned nY=0;nY<nVertRepeat;nY++) {\r\n\t\t\t\t\tstrLine.Format(_T(\"     %-36s  = [ \"  ),_T(\"\"));\r\n\t\t\t\t\tfor (unsigned nX=0;nX<nHorzRepeat;nX++) {\r\n\t\t\t\t\t\tif (nInd<MAX_anValues) {\r\n\t\t\t\t\t\t\tnVal = anValues[nInd++];\r\n\t\t\t\t\t\t\tanCfaVal[nY][nX] = nVal;\r\n\t\t\t\t\t\t\tswitch(nVal) {\r\n\t\t\t\t\t\t\t\tcase 0: strCol = _T(\"Red\");break;\r\n\t\t\t\t\t\t\t\tcase 1: strCol = _T(\"Grn\");break;\r\n\t\t\t\t\t\t\t\tcase 2: strCol = _T(\"Blu\");break;\r\n\t\t\t\t\t\t\t\tcase 3: strCol = _T(\"Cya\");break;\r\n\t\t\t\t\t\t\t\tcase 4: strCol = _T(\"Mgn\");break;\r\n\t\t\t\t\t\t\t\tcase 5: strCol = _T(\"Yel\");break;\r\n\t\t\t\t\t\t\t\tcase 6: strCol = _T(\"Wht\");break;\r\n\t\t\t\t\t\t\t\tdefault: strCol.Format(_T(\"x%02X\"),nVal);break;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tstrLine.AppendFormat(_T(\"%s \"),(LPCTSTR)strCol);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tstrLine.Append(_T(\"]\"));\r\n\t\t\t\t\tm_pLog->AddLine(strLine);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\r\n\t\tif ((strIfd == _T(\"InteropIFD\")) && (strIfdTag == _T(\"InteroperabilityVersion\"))) {\r\n\t\t\t// Assume only one\r\n\t\t\tstrValOut.Format(_T(\"%c%c.%c%c\"),anValues[0],anValues[1],anValues[2],anValues[3]);\r\n\t\t}\r\n\r\n\r\n\t\t// ==========================================================================\r\n\r\n\t\t// ----------------------------------------\r\n\t\t// Handle certain MakerNotes\r\n\t\t//   For Canon, we have a special parser routine to handle these\r\n\t\t// ----------------------------------------\r\n\t\tif (strIfd == _T(\"MakerIFD\")) {\r\n\r\n\t\t\tif ((m_strImgExifMake == _T(\"Canon\")) && (nIfdFormat == 3) && (nIfdNumComps > 4)) {\r\n\t\t\t\t// Print summary line now, before sub details\r\n\t\t\t\t// Disable later summary line\r\n\t\t\t\tbExtraDecode = TRUE;\r\n\t\t\t\tif ((!m_pAppConfig->bExifHideUnknown) || (!nIfdTagUnknown)) {\r\n\t\t\t\t\tstrTmp.Format(_T(\"    [%-36s]\"),(LPCTSTR)strIfdTag);\r\n\t\t\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t\t\t\t// Assume it is a maker field with subentries!\r\n\r\n\t\t\t\t\tfor (unsigned ind=0;ind<nIfdNumComps;ind++) {\r\n\t\t\t\t\t\t// Limit the number of entries (in case there was a decode error\r\n\t\t\t\t\t\t// or simply too many to report)\r\n\t\t\t\t\t\tif (ind<MAX_anValues) {\r\n\t\t\t\t\t\t\tstrValOut.Format(_T(\"#%u=%u \"),ind,anValues[ind]);\r\n\t\t\t\t\t\t\tstrRetVal = LookupMakerCanonTag(nIfdTagVal,ind,anValues[ind]);\r\n\t\t\t\t\t\t\tstrMaker = strRetVal.strTag;\r\n\t\t\t\t\t\t\tstrValTmp.Format(_T(\"      [%-34s] = %s\"),(LPCTSTR)strMaker,(LPCTSTR)(strRetVal.strVal));\r\n\t\t\t\t\t\t\tif ((!m_pAppConfig->bExifHideUnknown) || (!strRetVal.bUnknown)) {\r\n\t\t\t\t\t\t\t\tm_pLog->AddLine(strValTmp);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else if (ind == MAX_anValues) {\r\n\t\t\t\t\t\t\tm_pLog->AddLine(_T(\"      [... etc ...]\"));\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// Don't print!\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\tstrValOut = _T(\"...\");\r\n\t\t\t}\r\n\r\n\t\t\t// For Nikon & Sigma, we simply support the quality field\r\n\t\t\tif ( (strIfdTag==\"Nikon1.Quality\") || \r\n\t\t\t\t(strIfdTag==\"Nikon2.Quality\") ||\r\n\t\t\t\t(strIfdTag==\"Nikon3.Quality\") ||\r\n\t\t\t\t(strIfdTag==\"Sigma.Quality\") )\r\n\t\t\t{\r\n\t\t\t\tm_strImgQualExif = strValOut;\r\n\r\n\t\t\t\t// Collect extra details (for later DB submission)\r\n\t\t\t\tstrTmp = _T(\"\");\r\n\t\t\t\tstrTmp.Format(_T(\"[%s]:[%s],\"),(LPCTSTR)strIfdTag,(LPCTSTR)strValOut);\r\n\t\t\t\tm_strImgExtras += strTmp;\r\n\t\t\t}\r\n\r\n\t\t\t// Collect extra details (for later DB submission)\r\n\t\t\tif (strIfdTag==_T(\"Canon.ImageType\")) {\r\n\t\t\t\tstrTmp = _T(\"\");\r\n\t\t\t\tstrTmp.Format(_T(\"[%s]:[%s],\"),(LPCTSTR)strIfdTag,(LPCTSTR)strValOut);\r\n\t\t\t\tm_strImgExtras += strTmp;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// ----------------------------------------\r\n\r\n\t\t// Now extract some of the important offsets / pointers\r\n\t\tif ((strIfd == _T(\"IFD0\")) && (strIfdTag == _T(\"ExifOffset\"))) {\r\n\t\t\t// EXIF SubIFD - Pointer\r\n\t\t\tm_nImgExifSubIfdPtr = nIfdOffset;\r\n\t\t\tstrValOut.Format(_T(\"@ 0x%04X\"),nIfdOffset);\r\n\t\t}\r\n\r\n\t\tif ((strIfd == _T(\"IFD0\")) && (strIfdTag == _T(\"GPSOffset\"))) {\r\n\t\t\t// GPS SubIFD - Pointer\r\n\t\t\tm_nImgExifGpsIfdPtr = nIfdOffset;\r\n\t\t\tstrValOut.Format(_T(\"@ 0x%04X\"),nIfdOffset);\r\n\t\t}\r\n\r\n\t\t// TODO: Add Interoperability IFD (0xA005)?\r\n\t\tif ((strIfd == _T(\"SubIFD\")) && (strIfdTag == _T(\"ExifInteroperabilityOffset\"))) {\r\n\t\t\tm_nImgExifInteropIfdPtr = nIfdOffset;\r\n\t\t\tstrValOut.Format(_T(\"@ 0x%04X\"),nIfdOffset);\r\n\t\t}\r\n\r\n\t\t// Extract software field\r\n\t\tif ((strIfd == _T(\"IFD0\")) && (strIfdTag == _T(\"Software\"))) {\r\n\t\t\tm_strSoftware = strValOut;\r\n\t\t}\r\n\r\n\t\t// -------------------------\r\n\t\t// IFD0 - ExifMake\r\n\t\t// -------------------------\r\n\t\tif ((strIfd == _T(\"IFD0\")) && (strIfdTag == _T(\"Make\"))) {\r\n\t\t\tm_strImgExifMake = strValOut;\r\n\t\t\tm_strImgExifMake.Trim(); // Trim whitespace (e.g. Pentax)\r\n\r\n\t\t}\r\n\r\n\t\t// -------------------------\r\n\t\t// IFD0 - ExifModel\r\n\t\t// -------------------------\r\n\t\tif ((strIfd == _T(\"IFD0\")) && (strIfdTag == _T(\"Model\"))) {\r\n\t\t\tm_strImgExifModel= strValOut;\r\n\t\t\tm_strImgExifModel.Trim();\r\n\t\t}\r\n\r\n\r\n\t\tif ((strIfd == _T(\"SubIFD\")) && (strIfdTag == _T(\"MakerNote\"))) {\r\n\t\t\t// Maker IFD - Pointer\r\n\t\t\tm_nImgExifMakerPtr = nIfdOffset;\r\n\t\t\tstrValOut.Format(_T(\"@ 0x%04X\"),nIfdOffset);\r\n\t\t}\r\n\r\n\r\n\t\t// -------------------------\r\n\t\t// IFD1 - Embedded Thumbnail\r\n\t\t// -------------------------\r\n\t\tif ((strIfd == _T(\"IFD1\")) && (strIfdTag == _T(\"Compression\"))) {\r\n\t\t\t// Embedded thumbnail, compression format\r\n\t\t\tm_nImgExifThumbComp = ReadSwap4(m_nPos);\r\n\t\t}\r\n\t\tif ((strIfd == _T(\"IFD1\")) && (strIfdTag == _T(\"JpegIFOffset\"))) {\r\n\t\t\t// Embedded thumbnail, offset\r\n\t\t\tm_nImgExifThumbOffset = nIfdOffset + nPosExifStart;\r\n\t\t\tstrValOut.Format(_T(\"@ +0x%04X = @ 0x%04X\"),nIfdOffset,m_nImgExifThumbOffset);\r\n\t\t}\r\n\t\tif ((strIfd == _T(\"IFD1\")) && (strIfdTag == _T(\"JpegIFByteCount\"))) {\r\n\t\t\t// Embedded thumbnail, length\r\n\t\t\tm_nImgExifThumbLen = ReadSwap4(m_nPos);\r\n\t\t}\r\n\r\n\r\n\t\t// ==========================================================================\r\n\t\t// Determine MakerNote support\r\n\t\t// ==========================================================================\r\n\r\n\t\tif (m_strImgExifMake != _T(\"\")) {\r\n\t\t\t// 1) Identify the supported MakerNotes\r\n\t\t\t// 2) Remap variations of the Maker field (e.g. Nikon)\r\n\t\t\t//    as some manufacturers have been inconsistent in their\r\n\t\t\t//    use of the Make field\r\n\r\n\t\t\tm_bImgExifMakeSupported = FALSE;\r\n\t\t\tif (m_strImgExifMake == _T(\"Canon\")) {\r\n\t\t\t\tm_bImgExifMakeSupported = TRUE;\r\n\t\t\t}\r\n\t\t\telse if (m_strImgExifMake == _T(\"PENTAX Corporation\")) {\r\n\t\t\t\tm_strImgExifMake = _T(\"PENTAX\");\r\n\t\t\t}\r\n\t\t\telse if (m_strImgExifMake == _T(\"NIKON CORPORATION\")) {\r\n\t\t\t\tm_strImgExifMake = _T(\"NIKON\");\r\n\t\t\t\tm_bImgExifMakeSupported = TRUE;\r\n\t\t\t}\r\n\t\t\telse if (m_strImgExifMake == _T(\"NIKON\")) {\r\n\t\t\t\tm_strImgExifMake = _T(\"NIKON\");\r\n\t\t\t\tm_bImgExifMakeSupported = TRUE;\r\n\t\t\t}\r\n\t\t\telse if (m_strImgExifMake == _T(\"SIGMA\")) {\r\n\t\t\t\tm_bImgExifMakeSupported = TRUE;\r\n\t\t\t}\r\n\t\t\telse if (m_strImgExifMake == _T(\"SONY\")) {\r\n\t\t\t\tm_bImgExifMakeSupported = TRUE;\r\n\t\t\t}\r\n\t\t\telse if (m_strImgExifMake == _T(\"FUJIFILM\")) {\r\n\t\t\t\t// TODO:\r\n\t\t\t\t// FUJIFILM Maker notes apparently use\r\n\t\t\t\t// big endian format even though main section uses little.\r\n\t\t\t\t// Need to switch if in maker section for FUJI\r\n\t\t\t\t// For now, disable support\r\n\t\t\t\tm_bImgExifMakeSupported = FALSE;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Now advance the m_nPos ptr as we have finished with valoffset\r\n\t\tm_nPos+=4;\r\n\r\n\r\n\t\t// ==========================================================================\r\n\t\t// SUMMARY REPORT\r\n\t\t// ==========================================================================\r\n\r\n\t\t// If we haven't already output a detailed decode of this field\r\n\t\t// then we can output the generic representation here\r\n\t\tif (!bExtraDecode)\r\n\t\t{\r\n\t\t\t// Provide option to skip unknown fields\r\n\t\t\tif ((!m_pAppConfig->bExifHideUnknown) || (!nIfdTagUnknown)) {\r\n\r\n\t\t\t\t// If the tag is an ASCII string, we want to wrap with quote marks\r\n\t\t\t\tif (nIfdFormat == 2) {\r\n\t\t\t\t\tstrTmp.Format(_T(\"    [%-36s] = \\\"%s\\\"\"),(LPCTSTR)strIfdTag,(LPCTSTR)strValOut);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstrTmp.Format(_T(\"    [%-36s] = %s\"),(LPCTSTR)strIfdTag,(LPCTSTR)strValOut);\r\n\t\t\t\t}\r\n\t\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tDbgAddLine(_T(\"\"));\r\n\r\n\t} // for nIfdEntryInd\r\n\r\n\r\n\t// =========== EXIF IFD (End) ===========\r\n\t// - Defined in Exif 2.2 Standard (JEITA CP-3451) section 4.6.2 \r\n\t// - Is completed by 4-byte offset to next IFD, which is\r\n\t//   read in next iteration.\r\n\r\n\tm_pLog->Enable();\r\n\treturn 0;\r\n}\r\n\r\n\r\n// Handle APP13 marker\r\n// This includes:\r\n// - Photoshop \"Save As\" and \"Save for Web\" quality settings\r\n// - IPTC entries\r\n// PRE:\r\n// - m_nPos\r\n// POST:\r\n// - m_nImgQualPhotoshopSa\r\nunsigned CjfifDecode::DecodeApp13Ps()\r\n{\r\n\t// Photoshop APP13 marker definition doesn't appear to have a \r\n\t// well-defined length, so I will read until I encounter a \r\n\t// non-\"8BIM\" entry, then we reset the position counter\r\n\t// and move on to the next marker.\r\n\t// FIXME: This does not appear to be very robust\r\n\r\n\tCString\t\t\tstrTmp;\r\n\tCString\t\t\tstrBimName;\r\n\tbool\t\t\tbDone = false;\r\n\r\n\tunsigned\t\tnVal = 0x8000;\r\n\tunsigned\t\tnSaveFormat = 0;\r\n\r\n\tCString\t\t\tstrVal;\r\n\tCString\t\t\tstrByte;\r\n\r\n\tCString\t\t\tstrBimSig;\r\n\r\n\t// Reset PsDec decoder state\r\n\tm_pPsDec->Reset();\r\n\r\n\twhile (!bDone)\r\n\t{\r\n\t\t// FIXME: Need to check for actual marker section extent, not\r\n\t\t// just the lack of an 8BIM signature as the terminator!\r\n\r\n\t\t// Check the signature but don't advance the file pointer\r\n\t\tstrBimSig = m_pWBuf->BufReadStrn(m_nPos,4);\r\n\t\t// Check for signature \"8BIM\"\r\n\t\tif (strBimSig == _T(\"8BIM\")) {\r\n\t\t\tm_pPsDec->PhotoshopParseImageResourceBlock(m_nPos,3);\r\n\t\t} else {\r\n\t\t\t// Not 8BIM?\r\n\t\t\tbDone = true;\r\n\t\t}\r\n\t}\r\n\r\n\t// Now that we've finished with the PsDec decoder we can fetch\r\n\t// some of the parser state\r\n\t// TODO: Migrate into accessor\r\n\tm_nImgQualPhotoshopSa = m_pPsDec->m_nQualitySaveAs;\r\n\tm_nImgQualPhotoshopSfw = m_pPsDec->m_nQualitySaveForWeb;\r\n\tm_bPsd = m_pPsDec->m_bPsd;\r\n\r\n\treturn 0;\r\n}\r\n\r\n\r\n// Start decoding a single ICC header segment @ nPos\r\nunsigned CjfifDecode::DecodeIccHeader(unsigned nPos)\r\n{\r\n\tCString strTmp,strTmp1;\r\n\r\n\t// Profile header\r\n\tunsigned nProfSz;\r\n\tunsigned nPrefCmmType;\r\n\tunsigned nProfVer;\r\n\tunsigned nProfDevClass;\r\n\tunsigned nDataColorSpace;\r\n\tunsigned nPcs;\r\n\tunsigned anDateTimeCreated[3];\r\n\tunsigned nProfFileSig;\r\n\tunsigned nPrimPlatSig;\r\n\tunsigned nProfFlags;\r\n\tunsigned nDevManuf;\r\n\tunsigned nDevModel;\r\n\tunsigned anDevAttrib[2];\r\n\tunsigned nRenderIntent;\r\n\tunsigned anIllumPcsXyz[3];\r\n\tunsigned nProfCreatorSig;\r\n\tunsigned anProfId[4];\r\n\tunsigned anRsvd[7];\r\n\r\n\t// Read in all of the ICC header bytes\r\n\tnProfSz = ReadBe4(nPos);nPos+=4;\r\n\tnPrefCmmType = ReadBe4(nPos);nPos+=4;\r\n\tnProfVer = ReadBe4(nPos);nPos+=4;\r\n\tnProfDevClass = ReadBe4(nPos);nPos+=4;\r\n\tnDataColorSpace = ReadBe4(nPos);nPos+=4;\r\n\tnPcs = ReadBe4(nPos);nPos+=4;\r\n\tanDateTimeCreated[2] = ReadBe4(nPos);nPos+=4;\r\n\tanDateTimeCreated[1] = ReadBe4(nPos);nPos+=4;\r\n\tanDateTimeCreated[0] = ReadBe4(nPos);nPos+=4;\r\n\tnProfFileSig = ReadBe4(nPos);nPos+=4;\r\n\tnPrimPlatSig = ReadBe4(nPos);nPos+=4;\r\n\tnProfFlags = ReadBe4(nPos);nPos+=4;\r\n\tnDevManuf = ReadBe4(nPos);nPos+=4;\r\n\tnDevModel = ReadBe4(nPos);nPos+=4;\r\n\tanDevAttrib[1] = ReadBe4(nPos);nPos+=4;\r\n\tanDevAttrib[0] = ReadBe4(nPos);nPos+=4;\r\n\tnRenderIntent = ReadBe4(nPos);nPos+=4;\r\n\tanIllumPcsXyz[2] = ReadBe4(nPos);nPos+=4;\r\n\tanIllumPcsXyz[1] = ReadBe4(nPos);nPos+=4;\r\n\tanIllumPcsXyz[0] = ReadBe4(nPos);nPos+=4;\r\n\tnProfCreatorSig = ReadBe4(nPos);nPos+=4;\r\n\tanProfId[3] = ReadBe4(nPos);nPos+=4;\r\n\tanProfId[2] = ReadBe4(nPos);nPos+=4;\r\n\tanProfId[1] = ReadBe4(nPos);nPos+=4;\r\n\tanProfId[0] = ReadBe4(nPos);nPos+=4;\r\n\tanRsvd[6] = ReadBe4(nPos);nPos+=4;\r\n\tanRsvd[5] = ReadBe4(nPos);nPos+=4;\r\n\tanRsvd[4] = ReadBe4(nPos);nPos+=4;\r\n\tanRsvd[3] = ReadBe4(nPos);nPos+=4;\r\n\tanRsvd[2] = ReadBe4(nPos);nPos+=4;\r\n\tanRsvd[1] = ReadBe4(nPos);nPos+=4;\r\n\tanRsvd[0] = ReadBe4(nPos);nPos+=4;\r\n\r\n\t// Now output the formatted version of the above data structures\r\n\tstrTmp.Format(_T(\"        %-33s : %u bytes\"),_T(\"Profile Size\"),nProfSz);\r\n\tm_pLog->AddLine(strTmp);\r\n\t\r\n\tstrTmp.Format(_T(\"        %-33s : %s\"),_T(\"Preferred CMM Type\"),(LPCTSTR)Uint2Chars(nPrefCmmType));\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\tstrTmp.Format(_T(\"        %-33s : %u.%u.%u.%u (0x%08X)\"),_T(\"Profile Version\"),\r\n\t\t((nProfVer & 0xF0000000)>>28),\r\n\t\t((nProfVer & 0x0F000000)>>24),\r\n\t\t((nProfVer & 0x00F00000)>>20),\r\n\t\t((nProfVer & 0x000F0000)>>16),\r\n\t\tnProfVer);\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\tswitch (nProfDevClass) {\r\n\t\tcase 'scnr':\r\n\t\t\tstrTmp1.Format(_T(\"Input Device profile\"));break;\r\n\t\tcase 'mntr':\r\n\t\t\tstrTmp1.Format(_T(\"Display Device profile\"));break;\r\n\t\tcase 'prtr':\r\n\t\t\tstrTmp1.Format(_T(\"Output Device profile\"));break;\r\n\t\tcase 'link':\r\n\t\t\tstrTmp1.Format(_T(\"DeviceLink Device profile\"));break;\r\n\t\tcase 'spac':\r\n\t\t\tstrTmp1.Format(_T(\"ColorSpace Conversion profile\"));break;\r\n\t\tcase 'abst':\r\n\t\t\tstrTmp1.Format(_T(\"Abstract profile\"));break;\r\n\t\tcase 'nmcl':\r\n\t\t\tstrTmp1.Format(_T(\"Named colour profile\"));break;\r\n\t\tdefault:\r\n\t\t\tstrTmp1.Format(_T(\"? (0x%08X)\"),nProfDevClass);\r\n\t\t\tbreak;\r\n\t}\r\n\tstrTmp.Format(_T(\"        %-33s : %s (%s)\"),_T(\"Profile Device/Class\"),(LPCTSTR)strTmp1,(LPCTSTR)Uint2Chars(nProfDevClass));\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\tswitch (nDataColorSpace) {\r\n\t\tcase 'XYZ ':\r\n\t\t\tstrTmp1.Format(_T(\"XYZData\"));break;\r\n\t\tcase 'Lab ':\r\n\t\t\tstrTmp1.Format(_T(\"labData\"));break;\r\n\t\tcase 'Luv ':\r\n\t\t\tstrTmp1.Format(_T(\"lubData\"));break;\r\n\t\tcase 'YCbr':\r\n\t\t\tstrTmp1.Format(_T(\"YCbCrData\"));break;\r\n\t\tcase 'Yxy ':\r\n\t\t\tstrTmp1.Format(_T(\"YxyData\"));break;\r\n\t\tcase 'RGB ':\r\n\t\t\tstrTmp1.Format(_T(\"rgbData\"));break;\r\n\t\tcase 'GRAY':\r\n\t\t\tstrTmp1.Format(_T(\"grayData\"));break;\r\n\t\tcase 'HSV ':\r\n\t\t\tstrTmp1.Format(_T(\"hsvData\"));break;\r\n\t\tcase 'HLS ':\r\n\t\t\tstrTmp1.Format(_T(\"hlsData\"));break;\r\n\t\tcase 'CMYK':\r\n\t\t\tstrTmp1.Format(_T(\"cmykData\"));break;\r\n\t\tcase 'CMY ':\r\n\t\t\tstrTmp1.Format(_T(\"cmyData\"));break;\r\n\t\tcase '2CLR':\r\n\t\t\tstrTmp1.Format(_T(\"2colourData\"));break;\r\n\t\tcase '3CLR':\r\n\t\t\tstrTmp1.Format(_T(\"3colourData\"));break;\r\n\t\tcase '4CLR':\r\n\t\t\tstrTmp1.Format(_T(\"4colourData\"));break;\r\n\t\tcase '5CLR':\r\n\t\t\tstrTmp1.Format(_T(\"5colourData\"));break;\r\n\t\tcase '6CLR':\r\n\t\t\tstrTmp1.Format(_T(\"6colourData\"));break;\r\n\t\tcase '7CLR':\r\n\t\t\tstrTmp1.Format(_T(\"7colourData\"));break;\r\n\t\tcase '8CLR':\r\n\t\t\tstrTmp1.Format(_T(\"8colourData\"));break;\r\n\t\tcase '9CLR':\r\n\t\t\tstrTmp1.Format(_T(\"9colourData\"));break;\r\n\t\tcase 'ACLR':\r\n\t\t\tstrTmp1.Format(_T(\"10colourData\"));break;\r\n\t\tcase 'BCLR':\r\n\t\t\tstrTmp1.Format(_T(\"11colourData\"));break;\r\n\t\tcase 'CCLR':\r\n\t\t\tstrTmp1.Format(_T(\"12colourData\"));break;\r\n\t\tcase 'DCLR':\r\n\t\t\tstrTmp1.Format(_T(\"13colourData\"));break;\r\n\t\tcase 'ECLR':\r\n\t\t\tstrTmp1.Format(_T(\"14colourData\"));break;\r\n\t\tcase 'FCLR':\r\n\t\t\tstrTmp1.Format(_T(\"15colourData\"));break;\r\n\t\tdefault:\r\n\t\t\tstrTmp1.Format(_T(\"? (0x%08X)\"),nDataColorSpace);\r\n\t\t\tbreak;\r\n\t}\r\n\tstrTmp.Format(_T(\"        %-33s : %s (%s)\"),_T(\"Data Colour Space\"),(LPCTSTR)strTmp1,(LPCTSTR)Uint2Chars(nDataColorSpace));\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\tstrTmp.Format(_T(\"        %-33s : %s\"),_T(\"Profile connection space (PCS)\"),(LPCTSTR)Uint2Chars(nPcs));\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\tstrTmp.Format(_T(\"        %-33s : %s\"),_T(\"Profile creation date\"),(LPCTSTR)DecodeIccDateTime(anDateTimeCreated));\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\tstrTmp.Format(_T(\"        %-33s : %s\"),_T(\"Profile file signature\"),(LPCTSTR)Uint2Chars(nProfFileSig));\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\tswitch (nPrimPlatSig) {\r\n\t\tcase 'APPL':\r\n\t\t\tstrTmp1.Format(_T(\"Apple Computer, Inc.\"));break;\r\n\t\tcase 'MSFT':\r\n\t\t\tstrTmp1.Format(_T(\"Microsoft Corporation\"));break;\r\n\t\tcase 'SGI ':\r\n\t\t\tstrTmp1.Format(_T(\"Silicon Graphics, Inc.\"));break;\r\n\t\tcase 'SUNW':\r\n\t\t\tstrTmp1.Format(_T(\"Sun Microsystems, Inc.\"));break;\r\n\t\tdefault:\r\n\t\t\tstrTmp1.Format(_T(\"? (0x%08X)\"),nPrimPlatSig);\r\n\t\t\tbreak;\r\n\t}\r\n\tstrTmp.Format(_T(\"        %-33s : %s (%s)\"),_T(\"Primary platform\"),(LPCTSTR)strTmp1,(LPCTSTR)Uint2Chars(nPrimPlatSig));\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\tstrTmp.Format(_T(\"        %-33s : 0x%08X\"),_T(\"Profile flags\"),nProfFlags);\r\n\tm_pLog->AddLine(strTmp);\r\n\tstrTmp1 = (TestBit(nProfFlags,0))?\"Embedded profile\":\"Profile not embedded\";\r\n\tstrTmp.Format(_T(\"        %-35s > %s\"),_T(\"Profile flags\"),(LPCTSTR)strTmp1);\r\n\tm_pLog->AddLine(strTmp);\r\n\tstrTmp1 = (TestBit(nProfFlags,1))?\"Profile can be used independently of embedded\":\"Profile can't be used independently of embedded\";\r\n\tstrTmp.Format(_T(\"        %-35s > %s\"),_T(\"Profile flags\"),(LPCTSTR)strTmp1);\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\tstrTmp.Format(_T(\"        %-33s : %s\"),_T(\"Device Manufacturer\"),(LPCTSTR)Uint2Chars(nDevManuf));\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\tstrTmp.Format(_T(\"        %-33s : %s\"),_T(\"Device Model\"),(LPCTSTR)Uint2Chars(nDevModel));\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\tstrTmp.Format(_T(\"        %-33s : 0x%08X_%08X\"),_T(\"Device attributes\"),anDevAttrib[1],anDevAttrib[0]);\r\n\tm_pLog->AddLine(strTmp);\r\n\tstrTmp1 = (TestBit(anDevAttrib[0],0))?\"Transparency\":\"Reflective\";\r\n\tstrTmp.Format(_T(\"        %-35s > %s\"),_T(\"Device attributes\"),(LPCTSTR)strTmp1);\r\n\tm_pLog->AddLine(strTmp);\r\n\tstrTmp1 = (TestBit(anDevAttrib[0],1))?\"Matte\":\"Glossy\";\r\n\tstrTmp.Format(_T(\"        %-35s > %s\"),_T(\"Device attributes\"),(LPCTSTR)strTmp1);\r\n\tm_pLog->AddLine(strTmp);\r\n\tstrTmp1 = (TestBit(anDevAttrib[0],2))?\"Media polarity = positive\":\"Media polarity = negative\";\r\n\tstrTmp.Format(_T(\"        %-35s > %s\"),_T(\"Device attributes\"),(LPCTSTR)strTmp1);\r\n\tm_pLog->AddLine(strTmp);\r\n\tstrTmp1 = (TestBit(anDevAttrib[0],3))?\"Colour media\":\"Black & white media\";\r\n\tstrTmp.Format(_T(\"        %-35s > %s\"),_T(\"Device attributes\"),(LPCTSTR)strTmp1);\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\tswitch(nRenderIntent) {\r\n\t\tcase 0x00000000:\tstrTmp1.Format(_T(\"Perceptual\"));break;\r\n\t\tcase 0x00000001:\tstrTmp1.Format(_T(\"Media-Relative Colorimetric\"));break;\r\n\t\tcase 0x00000002:\tstrTmp1.Format(_T(\"Saturation\"));break;\r\n\t\tcase 0x00000003:\tstrTmp1.Format(_T(\"ICC-Absolute Colorimetric\"));break;\r\n\t\tdefault:\r\n\t\t\tstrTmp1.Format(_T(\"0x%08X\"),nRenderIntent);\r\n\t\t\tbreak;\r\n\t}\r\n\tstrTmp.Format(_T(\"        %-33s : %s\"),_T(\"Rendering intent\"),(LPCTSTR)strTmp1);\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\t// PCS illuminant\r\n\r\n\tstrTmp.Format(_T(\"        %-33s : %s\"),_T(\"Profile creator\"),(LPCTSTR)Uint2Chars(nProfCreatorSig));\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\tstrTmp.Format(_T(\"        %-33s : 0x%08X_%08X_%08X_%08X\"),_T(\"Profile ID\"),\r\n\t\tanProfId[3],anProfId[2],anProfId[1],anProfId[0]);\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\treturn 0;\r\n}\r\n\r\n// Provide special output formatter for ICC Date/Time\r\n// NOTE: It appears that the nParts had to be decoded in the\r\n//       reverse order from what I had expected, so one should\r\n//       confirm that the byte order / endianness is appropriate.\r\nCString CjfifDecode::DecodeIccDateTime(unsigned anVal[3])\r\n{\r\n\tCString\t\t\tstrDate;\r\n\tunsigned short\tanParts[6];\r\n\tanParts[0] = (anVal[2] & 0xFFFF0000) >> 16;\t// Year\r\n\tanParts[1] = (anVal[2] & 0x0000FFFF);\t\t\t// Mon\r\n\tanParts[2] = (anVal[1] & 0xFFFF0000) >> 16;\t// Day\r\n\tanParts[3] = (anVal[1] & 0x0000FFFF);\t\t\t// Hour\r\n\tanParts[4] = (anVal[0] & 0xFFFF0000) >> 16;\t// Min\r\n\tanParts[5] = (anVal[0] & 0x0000FFFF);\t\t\t// Sec\r\n\tstrDate.Format(_T(\"%04u-%02u-%02u %02u:%02u:%02u\"),\r\n\t\tanParts[0],anParts[1],anParts[2],anParts[3],anParts[4],anParts[5]);\r\n\treturn strDate;\r\n}\r\n\r\n\r\n// Parser for APP2 ICC profile marker\r\nunsigned CjfifDecode::DecodeApp2IccProfile(unsigned nLen)\r\n{\r\n\tCString\t\tstrTmp;\r\n\tunsigned\tnMarkerSeqNum;\t// Byte\r\n\tunsigned\tnNumMarkers;\t// Byte\r\n\tunsigned\tnPayloadLen;\t// Len of this ICC marker payload\r\n\r\n\tunsigned\tnMarkerPosStart;\r\n\r\n\tnMarkerSeqNum = Buf(m_nPos++);\r\n\tnNumMarkers = Buf(m_nPos++);\r\n\tnPayloadLen = nLen - 2 - 12 - 2; // TODO: check?\r\n\r\n\tstrTmp.Format(_T(\"      Marker Number = %u of %u\"),nMarkerSeqNum,nNumMarkers);\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\tif (nMarkerSeqNum == 1) {\r\n\t\tnMarkerPosStart = m_nPos;\r\n\t\tDecodeIccHeader(nMarkerPosStart);\r\n\t} else {\r\n\t\tm_pLog->AddLineWarn(_T(\"      Only support decode of 1st ICC Marker\"));\r\n\t}\r\n\r\n\treturn 0;\r\n}\r\n\r\n// Parser for APP2 FlashPix marker\r\nunsigned CjfifDecode::DecodeApp2Flashpix()\r\n{\r\n\r\n\tCString strTmp;\r\n\r\n\tunsigned\tnFpxVer;\r\n\tunsigned\tnFpxSegType;\r\n\tunsigned\tnFpxInteropCnt;\r\n\tunsigned\tnFpxEntitySz;\r\n\tunsigned\tnFpxDefault;\r\n\r\n\tbool\t\tbFpxStorage;\r\n\tCString\t\tstrFpxStorageClsStr;\r\n\tunsigned\tnFpxStIndexCont;\r\n\tunsigned\tnFpxStOffset;\r\n\r\n\tunsigned\tnFpxStWByteOrder;\r\n\tunsigned\tnFpxStWFormat;\r\n\tCString\t\tstrFpxStClsidStr;\r\n\tunsigned\tnFpxStDwOsVer;\r\n\tunsigned\tnFpxStRsvd;\r\n\r\n\tCString\t\tstreamStr;\r\n\r\n\tnFpxVer = Buf(m_nPos++);\r\n\tnFpxSegType = Buf(m_nPos++);\r\n\r\n\t// FlashPix segments: Contents List or Stream Data\r\n\r\n\tif (nFpxSegType == 1) {\r\n\t\t// Contents List\r\n\t\tstrTmp.Format(_T(\"    Segment: CONTENTS LIST\"));\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tnFpxInteropCnt = (Buf(m_nPos++)<<8) + Buf(m_nPos++);\r\n\t\tstrTmp.Format(_T(\"      Interoperability Count = %u\"),nFpxInteropCnt);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tfor (unsigned ind=0;ind<nFpxInteropCnt;ind++) {\r\n\t\t\tstrTmp.Format(_T(\"      Entity Index #%u\"),ind); \r\n\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t\tnFpxEntitySz = (Buf(m_nPos++)<<24) + (Buf(m_nPos++)<<16) + (Buf(m_nPos++)<<8) + Buf(m_nPos++);\r\n\r\n\t\t\t// If the \"entity size\" field is 0xFFFFFFFF, then it should be treated as\r\n\t\t\t// a \"storage\". It looks like we should probably be using this to determine\r\n\t\t\t// that we have a \"storage\"\r\n\t\t\tbFpxStorage = false;\r\n\t\t\tif (nFpxEntitySz == 0xFFFFFFFF) {\r\n\t\t\t\tbFpxStorage = true;\r\n\t\t\t}\r\n\r\n\t\t\tif (!bFpxStorage) {\r\n\t\t\t\tstrTmp.Format(_T(\"        Entity Size = %u\"),nFpxEntitySz);\r\n\t\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t\t} else {\r\n\t\t\t\tstrTmp.Format(_T(\"        Entity is Storage\"));\r\n\t\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t\t}\r\n\r\n\t\t\tnFpxDefault = Buf(m_nPos++);\r\n\r\n\r\n\t\t\t// BUG: #1112\r\n\t\t\t//streamStr = m_pWBuf->BufReadUniStr(m_nPos);\r\n\t\t\tstreamStr = m_pWBuf->BufReadUniStr2(m_nPos,MAX_BUF_READ_STR);\r\n\t\t\tm_nPos += 2*((unsigned)_tcslen(streamStr)+1); // 2x because unicode\r\n\r\n\t\t\tstrTmp.Format(_T(\"        Stream Name = [%s]\"),(LPCTSTR)streamStr);\r\n\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\r\n\t\t\t// In the case of \"storage\", we decode the next 16 bytes as the class\r\n\t\t\tif (bFpxStorage) {\r\n\r\n\t\t\t\t// FIXME:\r\n\t\t\t\t// NOTE: Very strange reordering required here. Doesn't seem consistent\r\n\t\t\t\t//       This means that other fields are probably wrong as well (endian)\r\n\t\t\t\tstrFpxStorageClsStr.Format(_T(\"%02X%02X%02X%02X-%02X%02X-%02X%02X-%02X%02X-%02X%02X%02X%02X%02X%02X\"),\r\n\t\t\t\t\tBuf(m_nPos+3),Buf(m_nPos+2),Buf(m_nPos+1),Buf(m_nPos+0),\r\n\t\t\t\t\tBuf(m_nPos+5),Buf(m_nPos+4),\r\n\t\t\t\t\tBuf(m_nPos+7),Buf(m_nPos+6),\r\n\t\t\t\t\tBuf(m_nPos+8),Buf(m_nPos+9),\r\n\t\t\t\t\tBuf(m_nPos+10),Buf(m_nPos+11),Buf(m_nPos+12),Buf(m_nPos+13),Buf(m_nPos+14),Buf(m_nPos+15) );\r\n\t\t\t\tm_nPos+= 16;\r\n\t\t\t\tstrTmp.Format(_T(\"        Storage Class = [%s]\"),(LPCTSTR)strFpxStorageClsStr);\r\n\t\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn 0;\r\n\r\n\t} else if (nFpxSegType == 2) {\r\n\t\t// Stream Data\r\n\t\tstrTmp.Format(_T(\"    Segment: STREAM DATA\"));\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tnFpxStIndexCont = (Buf(m_nPos++)<<8) + Buf(m_nPos++);\r\n\t\tstrTmp.Format(_T(\"      Index in Contents List = %u\"),nFpxStIndexCont);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tnFpxStOffset = (Buf(m_nPos++)<<24) + (Buf(m_nPos++)<<16) + (Buf(m_nPos++)<<8) + Buf(m_nPos++);\r\n\t\tstrTmp.Format(_T(\"      Offset in stream = %u (0x%08X)\"),nFpxStOffset,nFpxStOffset);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t// Now decode the Property Set Header\r\n\r\n\t\t// NOTE: Should only decode this if we are doing first part of stream\r\n\t\t// TODO: How do we know this? First reference to index #?\r\n\r\n\t\tnFpxStWByteOrder = (Buf(m_nPos++)<<8) + Buf(m_nPos++);\r\n\t\tnFpxStWFormat = (Buf(m_nPos++)<<8) + Buf(m_nPos++);\r\n\t\tnFpxStDwOsVer = (Buf(m_nPos++)<<24) + (Buf(m_nPos++)<<16) + (Buf(m_nPos++)<<8) + Buf(m_nPos++);\r\n\r\n\t\t// FIXME:\r\n\t\t// NOTE: Very strange reordering required here. Doesn't seem consistent!\r\n\t\t//       This means that other fields are probably wrong as well (endian)\r\n\t\tstrFpxStClsidStr.Format(_T(\"%02X%02X%02X%02X-%02X%02X-%02X%02X-%02X%02X-%02X%02X%02X%02X%02X%02X\"),\r\n\t\t\tBuf(m_nPos+3),Buf(m_nPos+2),Buf(m_nPos+1),Buf(m_nPos+0),\r\n\t\t\tBuf(m_nPos+5),Buf(m_nPos+4),\r\n\t\t\tBuf(m_nPos+7),Buf(m_nPos+6),\r\n\t\t\tBuf(m_nPos+8),Buf(m_nPos+9),\r\n\t\t\tBuf(m_nPos+10),Buf(m_nPos+11),Buf(m_nPos+12),Buf(m_nPos+13),Buf(m_nPos+14),Buf(m_nPos+15) );\r\n\t\tm_nPos+= 16;\r\n\t\tnFpxStRsvd = (Buf(m_nPos++)<<8) + Buf(m_nPos++);\r\n\r\n\t\tstrTmp.Format(_T(\"      ByteOrder = 0x%04X\"),nFpxStWByteOrder);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tstrTmp.Format(_T(\"      Format = 0x%04X\"),nFpxStWFormat);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tstrTmp.Format(_T(\"      OSVer = 0x%08X\"),nFpxStDwOsVer);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tstrTmp.Format(_T(\"      clsid = %s\"),(LPCTSTR)strFpxStClsidStr);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tstrTmp.Format(_T(\"      reserved = 0x%08X\"),nFpxStRsvd);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t// ....\r\n\r\n\t\treturn 2;\r\n\r\n\t} else {\r\n\t\tstrTmp.Format(_T(\"      Reserved Segment. Stopping.\"));\r\n\t\tm_pLog->AddLineErr(strTmp);\r\n\t\treturn 1;\r\n\t}\r\n\r\n}\r\n\r\n\r\n// Decode the DHT marker segment (Huffman Tables)\r\n// In some cases (such as for MotionJPEG), we fake out\r\n// the DHT tables (when bInject=true) with a standard table\r\n// as each JPEG frame in the MJPG does not include the DHT.\r\n// In all other cases (bInject=false), we simply read the\r\n// DHT table from the file buffer via Buf()\r\n//\r\n// ITU-T standard indicates that we can expect up to a\r\n// maximum of 16-bit huffman code bitstrings.\r\nvoid CjfifDecode::DecodeDHT(bool bInject)\r\n{\r\n\tunsigned\tnLength;\r\n\tunsigned\tnTmpVal;\r\n\tCString\t\tstrTmp,strFull;\r\n\tunsigned\tnPosEnd;\r\n\tunsigned\tnPosSaved;\r\n\r\n\tbool\t\tbRet;\r\n\r\n\r\n\tif (bInject) {\r\n\t\t// Redirect Buf() to DHT table in MJPGDHTSeg[]\r\n\t\t// ... so change mode that Buf() call uses\r\n\t\tm_bBufFakeDHT = true;\r\n\r\n\t\t// Preserve the \"m_nPos\" pointer, at end we undo it\r\n\t\t// And we also start at 2 which is just after FFC4 in array\r\n\t\tnPosSaved = m_nPos;\r\n\t\tm_nPos = 2;\r\n\t}\r\n\r\n\tnLength = Buf(m_nPos)*256 + Buf(m_nPos+1);\r\n\tnPosEnd = m_nPos+nLength;\r\n\tm_nPos+=2;\r\n\tstrTmp.Format(_T(\"  Huffman table length = %u\"),nLength); \r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\tunsigned\tnDhtClass_Tc;\t\t// Range 0..1\r\n\tunsigned\tnDhtHuffTblId_Th;\t// Range 0..3\r\n\r\n\t// In various places, added m_bStateAbort check to allow us\r\n\t// to escape in case we get in excessive number of DHT entries\r\n\t// See BUG FIX #1003\r\n\r\n\twhile ((!m_bStateAbort)&&(nPosEnd > m_nPos))\r\n\t{\r\n\t\tm_pLog->AddLine(_T(\"  ----\"));\r\n\r\n\t\tnTmpVal = Buf(m_nPos++);\r\n\t\tnDhtClass_Tc = (nTmpVal & 0xF0) >> 4;\t// Tc, range 0..1\r\n\t\tnDhtHuffTblId_Th = nTmpVal & 0x0F;\t\t// Th, range 0..3\r\n\t\tstrTmp.Format(_T(\"  Destination ID = %u\"),nDhtHuffTblId_Th);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\t\tstrTmp.Format(_T(\"  Class = %u (%s)\"),nDhtClass_Tc,(nDhtClass_Tc?_T(\"AC Table\"):_T(\"DC / Lossless Table\")));\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t// Add in some error checking to prevent \r\n\t\tif (nDhtClass_Tc >= MAX_DHT_CLASS) {\r\n\t\t\tstrTmp.Format(_T(\"ERROR: Invalid DHT Class (%u). Aborting DHT Load.\"),nDhtClass_Tc);\r\n\t\t\tm_pLog->AddLineErr(strTmp);\r\n\t\t\tm_nPos = nPosEnd;\r\n\t\t\t//m_bStateAbort = true;\t// Stop decoding\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tif (nDhtHuffTblId_Th >= MAX_DHT_DEST_ID) {\r\n\t\t\tstrTmp.Format(_T(\"ERROR: Invalid DHT Dest ID (%u). Aborting DHT Load.\"),nDhtHuffTblId_Th);\r\n\t\t\tm_pLog->AddLineErr(strTmp);\r\n\t\t\tm_nPos = nPosEnd;\r\n\t\t\t//m_bStateAbort = true;\t// Stop decoding\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t// Read in the array of DHT code lengths\r\n\t\tfor (unsigned int i=1;i<=MAX_DHT_CODELEN;i++)\r\n\t\t{\r\n\t\t\tm_anDhtNumCodesLen_Li[i] = Buf(m_nPos++);\t// Li, range 0..255\r\n\t\t}\r\n\r\n\t\t#define DECODE_DHT_MAX_DHT 256\r\n\r\n\t\tunsigned int\tanDhtCodeVal[DECODE_DHT_MAX_DHT+1]; // Should only need max 162 codes\r\n\t\tunsigned int\tnDhtInd;\r\n\t\tunsigned int\tnDhtCodesTotal;\r\n\r\n\t\t// Clear out the code list\r\n\t\tfor (nDhtInd = 0;nDhtInd <DECODE_DHT_MAX_DHT;nDhtInd++)\r\n\t\t{\r\n\t\t\tanDhtCodeVal[nDhtInd] = 0xFFFF; // Dummy value\r\n\t\t}\r\n\r\n\t\t// Now read in all of the DHT codes according to the lengths\r\n\t\t// read in earlier\r\n\t\tnDhtCodesTotal = 0;\r\n\t\tnDhtInd = 0;\r\n\t\tfor (unsigned int nIndLen=1;((!m_bStateAbort)&&(nIndLen<=MAX_DHT_CODELEN));nIndLen++)\r\n\t\t{\r\n\t\t\t// Keep a total count of the number of DHT codes read\r\n\t\t\tnDhtCodesTotal += m_anDhtNumCodesLen_Li[nIndLen];\r\n\r\n\t\t\tstrFull.Format(_T(\"    Codes of length %02u bits (%03u total): \"),nIndLen,m_anDhtNumCodesLen_Li[nIndLen]);\r\n\t\t\tfor (unsigned int nIndCode=0;((!m_bStateAbort)&&(nIndCode<m_anDhtNumCodesLen_Li[nIndLen]));nIndCode++)\r\n\t\t\t{\r\n\t\t\t\t// Start a new line for every 16 codes\r\n\t\t\t\tif ( (nIndCode != 0) && ((nIndCode % 16) == 0) ) {\r\n\t\t\t\t\tstrFull = _T(\"                                         \");\r\n\t\t\t\t}\r\n\t\t\t\tnTmpVal = Buf(m_nPos++);\r\n\t\t\t\tstrTmp.Format(_T(\"%02X \"),nTmpVal);\r\n\t\t\t\tstrFull += strTmp;\r\n\r\n\t\t\t\t// Only write 16 codes per line\r\n\t\t\t\tif ((nIndCode % 16) == 15) {\r\n\t\t\t\t\tm_pLog->AddLine(strFull);\r\n\t\t\t\t\tstrFull = _T(\"\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Save the huffman code\r\n\t\t\t\t// Just in case we have more DHT codes than we expect, trap\r\n\t\t\t\t// the range check here, otherwise we'll have buffer overrun!\r\n\t\t\t\tif (nDhtInd < DECODE_DHT_MAX_DHT) {\r\n\t\t\t\t\tanDhtCodeVal[nDhtInd++] = nTmpVal;\t// Vij, range 0..255\r\n\t\t\t\t} else {\r\n\t\t\t\t\tnDhtInd++;\r\n\t\t\t\t\tstrTmp.Format(_T(\"Excessive DHT entries (%u)... skipping\"),nDhtInd);\r\n\t\t\t\t\tm_pLog->AddLineErr(strTmp);\r\n\t\t\t\t\tif (!m_bStateAbort) { DecodeErrCheck(true); }\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\tm_pLog->AddLine(strFull);\r\n\t\t}\r\n\t\tstrTmp.Format(_T(\"    Total number of codes: %03u\"),nDhtCodesTotal);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tunsigned int nDhtLookupInd = 0;\r\n\r\n\t\t// Now print out the actual binary strings!\r\n\t\tunsigned long\tnBitVal = 0;\r\n\t\tunsigned int\tnCodeVal = 0;\r\n\t\tnDhtInd = 0;\r\n\t\tif (m_pAppConfig->bOutputDHTexpand) {\r\n\t\t\tm_pLog->AddLine(_T(\"\"));\r\n\t\t\tm_pLog->AddLine(_T(\"  Expanded Form of Codes:\"));\r\n\t\t}\r\n\t\tfor (unsigned int nBitLen=1;((!m_bStateAbort)&&(nBitLen<=16));nBitLen++)\r\n\t\t{\r\n\t\t\tif (m_anDhtNumCodesLen_Li[nBitLen] > 0)\r\n\t\t\t{\r\n\t\t\t\tif (m_pAppConfig->bOutputDHTexpand) {\r\n\t\t\t\t\tstrTmp.Format(_T(\"    Codes of length %02u bits:\"),nBitLen);\r\n\t\t\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t\t\t}\r\n\t\t\t\t// Codes exist for this bit-length\r\n\t\t\t\t// Walk through and generate the bitvalues\r\n\t\t\t\tfor (unsigned int bit_ind=1;((!m_bStateAbort)&&(bit_ind<=m_anDhtNumCodesLen_Li[nBitLen]));bit_ind++)\r\n\t\t\t\t{\r\n\t\t\t\t\tunsigned int\tnDecVal = nCodeVal;\r\n\t\t\t\t\tunsigned int\tnBinBit;\r\n\t\t\t\t\tTCHAR\t\t\tacBinStr[17] = _T(\"\");\r\n\t\t\t\t\tunsigned int\tnBinStrLen = 0;\r\n\r\n\t\t\t\t\t// If the user has enabled output of DHT expanded tables,\r\n\t\t\t\t\t// report the bit-string sequences.\r\n\t\t\t\t\tif (m_pAppConfig->bOutputDHTexpand) {\r\n\t\t\t\t\t\tfor (unsigned int nBinInd=nBitLen;nBinInd>=1;nBinInd--)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tnBinBit = (nDecVal >> (nBinInd-1)) & 1;\r\n\t\t\t\t\t\t\tacBinStr[nBinStrLen++] = (nBinBit)?'1':'0';\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tacBinStr[nBinStrLen] = '\\0';\r\n\t\t\t\t\t\tstrFull.Format(_T(\"      %s = %02X\"),acBinStr,anDhtCodeVal[nDhtInd]);\r\n\r\n\t\t\t\t\t\t// The following are only valid for AC components\r\n\t\t\t\t\t\t// Bug [3442132]\r\n\t\t\t\t\t\tif (nDhtClass_Tc == DHT_CLASS_AC) {\r\n\t\t\t\t\t\t\tif (anDhtCodeVal[nDhtInd] == 0x00) { strFull += _T(\" (EOB)\"); }\r\n\t\t\t\t\t\t\tif (anDhtCodeVal[nDhtInd] == 0xF0) { strFull += _T(\" (ZRL)\"); }\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tstrTmp.Format(_T(\"%-40s (Total Len = %2u)\"),(LPCTSTR)strFull,nBitLen + (anDhtCodeVal[nDhtInd] & 0xF));\r\n\r\n\t\t\t\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Store the lookup value\r\n\t\t\t\t\t// Shift left to MSB of 32-bit\r\n\t\t\t\t\tunsigned nTmpMask = m_anMaskLookup[nBitLen];\r\n\r\n\t\t\t\t\tunsigned nTmpBits = nDecVal << (32-nBitLen);\r\n\t\t\t\t\tunsigned nTmpCode = anDhtCodeVal[nDhtInd];\r\n\t\t\t\t\tbRet = m_pImgDec->SetDhtEntry(nDhtHuffTblId_Th,nDhtClass_Tc,nDhtLookupInd,nBitLen,\r\n\t\t\t\t\t\tnTmpBits,nTmpMask,nTmpCode);\r\n\r\n\t\t\t\t\tDecodeErrCheck(bRet);\r\n\r\n\t\t\t\t\tnDhtLookupInd++;\r\n\r\n\t\t\t\t\t// Move to the next code\r\n\t\t\t\t\tnCodeVal++;\r\n\t\t\t\t\tnDhtInd++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// For each loop iteration (on bit length), we shift the code value\r\n\t\t\tnCodeVal <<= 1;\r\n\t\t}\r\n\r\n\r\n\t\t// Now store the dht_lookup_size\r\n\t\tunsigned nTmpSize = nDhtLookupInd;\r\n\t\tbRet = m_pImgDec->SetDhtSize(nDhtHuffTblId_Th,nDhtClass_Tc,nTmpSize);\r\n\t\tif (!m_bStateAbort) { DecodeErrCheck(bRet); }\r\n\r\n\t\tm_pLog->AddLine(_T(\"\"));\r\n\r\n\t}\r\n\r\n\tif (bInject) {\r\n\t\t// Restore position (as if we didn't move)\r\n\t\tm_nPos = nPosSaved;\r\n\t\tm_bBufFakeDHT = false;\r\n\t}\r\n}\r\n\r\n\r\n// Check return value of previous call. If failed, then ask\r\n// user if they wish to continue decoding. If no, then flag to\r\n// the decoder that we're done (avoids continuous failures)\r\nvoid CjfifDecode::DecodeErrCheck(bool bRet)\r\n{\r\n\tif (!bRet) {\r\n\t\tif (m_pAppConfig->bInteractive) {\r\n\t\t\tif (AfxMessageBox(_T(\"Do you want to continue decoding?\"),MB_YESNO|MB_ICONQUESTION)== IDNO) {\r\n\t\t\t\tm_bStateAbort = true;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// This routine is called after the expected fields of the marker segment\r\n// have been processed. The file position should line up with the offset\r\n// dictated by the marker length. If a mismatch is detected, report an\r\n// error.\r\n//\r\n// RETURN:\r\n// - True if decode error is fatal (configurable)\r\n//\r\nbool CjfifDecode::ExpectMarkerEnd(unsigned long nMarkerStart,unsigned nMarkerLen)\r\n{\r\n\tCString\t\t\tstrTmp;\r\n\tunsigned long\tnMarkerEnd = nMarkerStart + nMarkerLen;\r\n\tunsigned long\tnMarkerExtra = nMarkerEnd - m_nPos;\r\n\tif (m_nPos < nMarkerEnd) {\r\n\t\t// The length indicates that there is more data than we processed\r\n\t\tstrTmp.Format(_T(\"  WARNING: Marker length longer than expected\"));\r\n\t\tm_pLog->AddLineWarn(strTmp);\r\n\t\tif (!m_pAppConfig->bRelaxedParsing) {\r\n\t\t\t// Abort\r\n\t\t\tm_pLog->AddLineErr(_T(\"  Stopping decode\"));\r\n\t\t\tm_pLog->AddLineErr(_T(\"  Use [Img Search Fwd/Rev] to locate other valid embedded JPEGs\"));\r\n\t\t\treturn false;\r\n\t\t} else {\r\n\t\t\t// Warn and skip\r\n\t\t\tstrTmp.Format(_T(\"  Skipping remainder [%u bytes]\"),nMarkerExtra);\r\n\t\t\tm_pLog->AddLineWarn(strTmp);\r\n\t\t\tm_nPos += nMarkerExtra;\r\n\t\t}\r\n\t} else if (m_nPos > nMarkerEnd) {\r\n\t\t// The length indicates that there is less data than we processed\r\n\t\tstrTmp.Format(_T(\"  WARNING: Marker length shorter than expected\"));\r\n\t\tm_pLog->AddLineWarn(strTmp);\r\n\t\tif (!m_pAppConfig->bRelaxedParsing) {\r\n\t\t\t// Abort\r\n\t\t\tm_pLog->AddLineErr(_T(\"  Stopping decode\"));\r\n\t\t\tm_pLog->AddLineErr(_T(\"  Use [Img Search Fwd/Rev] to locate other valid embedded JPEGs\"));\r\n\t\t\treturn false;\r\n\t\t} else {\r\n\t\t\t// Warn but no skip\r\n\t\t\t// Note that we can't skip as the length would imply a rollback\r\n\t\t\t// Most resilient solution is probably to assume length was\r\n\t\t\t// wrong and continue from where the marker should have ended.\r\n\t\t\t// For resiliency, attempt two methods to find point to resume:\r\n\t\t\t// 1) Current position\r\n\t\t\t// 2) Actual length defined in marker\r\n\t\t\tif (Buf(m_nPos) == 0xFF) {\r\n\t\t\t\t// Using actual data expected seems more promising\r\n\t\t\t\tm_pLog->AddLineWarn(_T(\"  Resuming decode\"));\r\n\t\t\t} else if (Buf(nMarkerEnd) == 0xFF) {\r\n\t\t\t\t// Using actual length seems more promising\r\n\t\t\t\tm_nPos = nMarkerEnd;\r\n\t\t\t\tm_pLog->AddLineWarn(_T(\"  Rolling back pointer to end indicated by length\"));\r\n\t\t\t\tm_pLog->AddLineWarn(_T(\"  Resuming decode\"));\r\n\t\t\t} else {\r\n\t\t\t\t// No luck. Expect marker failure now\r\n\t\t\t\tm_pLog->AddLineWarn(_T(\"  Resuming decode\"));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// If we get here, then we haven't seen a fatal issue\r\n\treturn true;\r\n}\r\n\r\n// Validate an unsigned value to ensure it is in allowable range\r\n// - If the value is outside the range, an error is shown and\r\n//   the parsing stops if relaxed parsing is not enabled\r\n// - An optional override value is provided for the resume case\r\n//\r\n// INPUT:\r\n// - nVal\t\t\tInput value (unsigned 32-bit)\r\n// - nMin\t\t\tMinimum allowed value\r\n// - nMax\t\t\tMaximum allowed value\r\n// - strName\t\tName of the field\r\n// - bOverride\t\tShould we override the value upon out-of-range?\r\n// - nOverrideVal\tValue to override if bOverride and out-of-range\r\n//\r\n// PRE:\r\n// - m_pAppConfig\r\n//\r\n// OUTPUT:\r\n// - nVal\t\t\tOutput value (including any override)\r\n//\r\nbool CjfifDecode::ValidateValue(unsigned &nVal,unsigned nMin,unsigned nMax,CString strName,bool bOverride,unsigned nOverrideVal)\r\n{\r\n\tCString\t\tstrErr;\r\n\tif ((nVal >= nMin) && (nVal <= nMax)) {\r\n\t\t// Value is within range\r\n\t\treturn true;\r\n\t} else {\r\n\t\tif (nVal < nMin) {\r\n\t\t\tstrErr.Format(_T(\"  ERROR: %s value too small (Actual = %u, Expected >= %u)\"),\r\n\t\t\t\t(LPCTSTR)strName,nVal,nMin);\r\n\t\t\tm_pLog->AddLineErr(strErr);\r\n\t\t} else if (nVal > nMax) {\r\n\t\t\tstrErr.Format(_T(\"  ERROR: %s value too large (Actual = %u, Expected <= %u)\"),\r\n\t\t\t\t(LPCTSTR)strName,nVal,nMax);\r\n\t\t\tm_pLog->AddLineErr(strErr);\r\n\t\t}\r\n\t\tif (!m_pAppConfig->bRelaxedParsing) {\r\n\t\t\t// Defined as fatal error\r\n\t\t\t// TODO: Replace with glb_strMsgStopDecode?\r\n\t\t\tm_pLog->AddLineErr(_T(\"  Stopping decode\"));\r\n\t\t\tm_pLog->AddLineErr(_T(\"  Use [Relaxed Parsing] to continue\"));\r\n\t\t\treturn false;\r\n\t\t} else {\r\n\t\t\t// Non-fatal\r\n\t\t\tif (bOverride) {\r\n\t\t\t\t// Update value with override\r\n\t\t\t\tnVal = nOverrideVal;\r\n\t\t\t\tstrErr.Format(_T(\"  WARNING: Forcing value to [%u]\"),nOverrideVal);\r\n\t\t\t\tm_pLog->AddLineWarn(strErr);\r\n\t\t\t\tm_pLog->AddLineWarn(_T(\"  Resuming decode\"));\r\n\t\t\t} else {\r\n\t\t\t\t// No override\r\n\t\t\t\tstrErr.Format(_T(\"  Resuming decode\"));\r\n\t\t\t\tm_pLog->AddLineWarn(strErr);\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n}\r\n\r\n// This is the primary JFIF marker parser. It reads the\r\n// marker value at the current file position and launches the\r\n// specific parser routine. This routine exits when \r\n#define DECMARK_OK 0\r\n#define DECMARK_ERR 1\r\n#define DECMARK_EOI 2\r\nunsigned CjfifDecode::DecodeMarker()\r\n{\r\n\tTCHAR\t\t\tacIdentifier[MAX_IDENTIFIER];\r\n\tCString\t\t\tstrTmp;\r\n\tCString\t\t\tstrFull;\t\t\t\t// Used for concatenation\r\n\tunsigned\t\tnLength;\t\t\t\t// General purpose\r\n\tunsigned\t\tnTmpVal;\r\n\tunsigned\t\tnCode;\r\n\tunsigned long\tnPosEnd;\r\n\tunsigned long\tnPosSaved;\t\t\t\t// General-purpose saved position in file\r\n\tunsigned long\tnPosExifStart;\r\n\tunsigned\t\tnRet;\t\t\t\t\t// General purpose return value\r\n\tbool\t\t\tbRet;\r\n\tunsigned long\tnPosMarkerStart;\t\t// Offset for current marker\r\n\r\n\tunsigned\t\tnColTransform = 0;\t\t// Color Transform from APP14 marker\r\n\r\n\t// For DQT\r\n\tCString\tstrDqtPrecision = _T(\"\");\r\n\tCString\tstrDqtZigZagOrder = _T(\"\");\r\n\r\n\r\n\tif (Buf(m_nPos) != 0xFF) {\r\n\t\tif (m_nPos == 0) {\r\n\t\t\t// Don't give error message if we've already alerted them of AVI / PSD\r\n\t\t\tif ((!m_bAvi) && (!m_bPsd)) {\r\n\t\t\t\tstrTmp.Format(_T(\"NOTE: File did not start with JPEG marker. Consider using [Tools->Img Search Fwd] to locate embedded JPEG.\"));\r\n\t\t\t\tm_pLog->AddLineErr(strTmp);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tstrTmp.Format(_T(\"ERROR: Expected marker 0xFF, got 0x%02X @ offset 0x%08X. Consider using [Tools->Img Search Fwd/Rev].\"),Buf(m_nPos),m_nPos);\r\n\t\t\tm_pLog->AddLineErr(strTmp);\r\n\t\t}\r\n\t\tm_nPos++;\r\n\t\treturn DECMARK_ERR;\r\n\t}\r\n\tm_nPos++;\r\n\r\n\r\n\t// Read the current marker code\r\n\tnCode = Buf(m_nPos++);\r\n\r\n\t// Handle Marker Padding\r\n\t//\r\n\t// According to Section B.1.1.2:\r\n\t//   \"Any marker may optionally be preceded by any number of fill bytes, which are bytes assigned code X\ufffdFF\ufffd.\"\r\n\t//\r\n\tunsigned\tnSkipMarkerPad = 0;\r\n\twhile (nCode == 0xFF) {\r\n\t\t// Count the pad\r\n\t\tnSkipMarkerPad++;\r\n\t\t// Read another byte\r\n\t\tnCode = Buf(m_nPos++);\r\n\t}\r\n\r\n\t// Report out any padding\r\n\tif (nSkipMarkerPad>0) {\r\n\t\tstrTmp.Format(_T(\"*** Skipped %u marker pad bytes ***\"),nSkipMarkerPad);\r\n\t\tm_pLog->AddLineHdr(strTmp);\r\n\t}\r\n\r\n\r\n\t// Save the current marker offset\r\n\tnPosMarkerStart = m_nPos;\r\n\r\n\tAddHeader(nCode);\r\n\r\n\tswitch (nCode)\r\n\t{\r\n\tcase JFIF_SOI: // SOI\r\n\t\tm_bStateSoi = true;\r\n\t\tbreak;\r\n\r\n\r\n\tcase JFIF_APP12:\r\n\t\t// Photoshop DUCKY (Save For Web)\r\n\t\tnLength = Buf(m_nPos)*256 + Buf(m_nPos+1);\r\n\t\t//nLength = m_pWBuf->BufX(m_nPos,2,!m_nImgExifEndian);\r\n\t\tstrTmp.Format(_T(\"  Length          = %u\"),nLength);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tnPosSaved = m_nPos;\r\n\r\n\t\tm_nPos += 2; // Move past length now that we've used it\r\n\r\n\t\t_tcscpy_s(acIdentifier,MAX_IDENTIFIER,m_pWBuf->BufReadStrn(m_nPos,MAX_IDENTIFIER-1));\r\n\t\tacIdentifier[MAX_IDENTIFIER-1] = 0; // Null terminate just in case\r\n\t\tstrTmp.Format(_T(\"  Identifier      = [%s]\"),acIdentifier);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\t\tm_nPos += (unsigned)_tcslen(acIdentifier)+1;\r\n\t\tif (_tcscmp(acIdentifier,_T(\"Ducky\")) != 0)\r\n\t\t{\r\n\t\t\tm_pLog->AddLine(_T(\"    Not Photoshop DUCKY. Skipping remainder.\"));\r\n\t\t}\r\n\t\telse // Photoshop\r\n\t\t{\r\n\t\t\t// Please see reference on http://cpan.uwinnipeg.ca/htdocs/Image-ExifTool/Image/ExifTool/APP12.pm.html\r\n\t\t\t// A direct indexed approach should be safe\r\n\t\t\tm_nImgQualPhotoshopSfw = Buf(m_nPos+6);\r\n\t\t\tstrTmp.Format(_T(\"  Photoshop Save For Web Quality = [%d]\"),m_nImgQualPhotoshopSfw);\r\n\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t}\r\n\t\t// Restore original position in file to a point\r\n\t\t// after the section\r\n\t\tm_nPos = nPosSaved+nLength;\r\n\t\tbreak;\r\n\r\n\tcase JFIF_APP14:\r\n\t\t// JPEG Adobe  tag\r\n\r\n\t\tnLength = Buf(m_nPos)*256 + Buf(m_nPos+1);\r\n\t\tstrTmp.Format(_T(\"  Length            = %u\"),nLength);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tnPosSaved = m_nPos;\r\n\t\t// Some files had very short segment (eg. nLength=2)\r\n\t\tif (nLength < 2+12) {\r\n\t\t\tm_pLog->AddLine(_T(\"    Segment too short for Identifier. Skipping remainder.\"));\r\n\t\t\tm_nPos = nPosSaved+nLength;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tm_nPos += 2; // Move past length now that we've used it\r\n\r\n\t\t// TODO: Confirm Adobe flag\r\n\t\tm_nPos += 5;\r\n\r\n\t\tnTmpVal = Buf(m_nPos+0)*256 + Buf(m_nPos+1);\r\n\t\tstrTmp.Format(_T(\"  DCTEncodeVersion  = %u\"),nTmpVal);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tnTmpVal = Buf(m_nPos+2)*256 + Buf(m_nPos+3);\r\n\t\tstrTmp.Format(_T(\"  APP14Flags0       = %u\"),nTmpVal);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tnTmpVal = Buf(m_nPos+4)*256 + Buf(m_nPos+5);\r\n\t\tstrTmp.Format(_T(\"  APP14Flags1       = %u\"),nTmpVal);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tnColTransform = Buf(m_nPos+6);\r\n\t\tswitch (nColTransform) {\r\n\t\tcase APP14_COLXFM_UNK_RGB:\r\n\t\t\tstrTmp.Format(_T(\"  ColorTransform    = %u [Unknown (RGB or CMYK)]\"),nColTransform);\r\n\t\t\tbreak;\r\n\t\tcase APP14_COLXFM_YCC:\r\n\t\t\tstrTmp.Format(_T(\"  ColorTransform    = %u [YCbCr]\"),nColTransform);\r\n\t\t\tbreak;\r\n\t\tcase APP14_COLXFM_YCCK:\r\n\t\t\tstrTmp.Format(_T(\"  ColorTransform    = %u [YCCK]\"),nColTransform);\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tstrTmp.Format(_T(\"  ColorTransform    = %u [???]\"),nColTransform);\r\n\t\t\tbreak;\r\n\r\n\t\t}\r\n\t\tm_pLog->AddLine(strTmp);\r\n\t\tm_nApp14ColTransform = (nColTransform & 0xFF);\r\n\r\n\t\t// Restore original position in file to a point\r\n\t\t// after the section\r\n\t\tm_nPos = nPosSaved+nLength;\r\n\r\n\t\tbreak;\r\n\r\n\tcase JFIF_APP13:\r\n\t\t// Photoshop (Save As)\r\n\t\tnLength = Buf(m_nPos)*256 + Buf(m_nPos+1);\r\n\t\t//nLength = m_pWBuf->BufX(m_nPos,2,!m_nImgExifEndian);\r\n\t\tstrTmp.Format(_T(\"  Length          = %u\"),nLength);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tnPosSaved = m_nPos;\r\n\r\n\t\t// Some files had very short segment (eg. nLength=2)\r\n\t\tif (nLength < 2+20) {\r\n\t\t\tm_pLog->AddLine(_T(\"    Segment too short for Identifier. Skipping remainder.\"));\r\n\t\t\tm_nPos = nPosSaved+nLength;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tm_nPos += 2; // Move past length now that we've used it\r\n\r\n\t\t_tcscpy_s(acIdentifier,MAX_IDENTIFIER,m_pWBuf->BufReadStrn(m_nPos,MAX_IDENTIFIER-1));\r\n\t\tacIdentifier[MAX_IDENTIFIER-1] = 0; // Null terminate just in case\r\n\t\tstrTmp.Format(_T(\"  Identifier      = [%s]\"),acIdentifier);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\t\tm_nPos += (unsigned)_tcslen(acIdentifier)+1;\r\n\t\tif (_tcscmp(acIdentifier,_T(\"Photoshop 3.0\")) != 0)\r\n\t\t{\r\n\t\t\tm_pLog->AddLine(_T(\"    Not Photoshop. Skipping remainder.\"));\r\n\t\t}\r\n\t\telse // Photoshop\r\n\t\t{\r\n\t\t\tDecodeApp13Ps();\r\n\t\t}\r\n\t\t// Restore original position in file to a point\r\n\t\t// after the section\r\n\t\tm_nPos = nPosSaved+nLength;\r\n\t\tbreak;\r\n\r\n\tcase JFIF_APP1:\r\n\t\tnLength = Buf(m_nPos)*256 + Buf(m_nPos+1);\r\n\t\t//nLength = m_pWBuf->BufX(m_nPos,2,!m_nImgExifEndian);\r\n\t\tstrTmp.Format(_T(\"  Length          = %u\"),nLength);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tnPosSaved = m_nPos;\r\n\r\n\t\tm_nPos += 2; // Move past length now that we've used it\r\n\r\n\t\t_tcscpy_s(acIdentifier,MAX_IDENTIFIER,m_pWBuf->BufReadStrn(m_nPos,MAX_IDENTIFIER-1));\r\n\t\tacIdentifier[MAX_IDENTIFIER-1] = 0; // Null terminate just in case\r\n\t\tstrTmp.Format(_T(\"  Identifier      = [%s]\"),acIdentifier);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\t\tm_nPos += (unsigned)_tcslen(acIdentifier);\r\n\r\n\r\n\t\tif (!_tcsnccmp(acIdentifier,_T(\"http://ns.adobe.com/xap/1.0/\\x00\"),29) != 0) {\r\n\t\t\t// XMP\r\n\r\n\t\t\tm_pLog->AddLine(_T(\"    XMP = \"));\r\n\r\n\t\t\tm_nPos++;\r\n\r\n\t\t\tunsigned nPosMarkerEnd = nPosSaved+nLength-1;\r\n\t\t\tunsigned sXmpLen = nPosMarkerEnd-m_nPos;\r\n\t\t\tchar cXmpChar;\r\n\t\t\tbool bNonSpace;\r\n\t\t\tCString strLine;\r\n\r\n\t\t\t// Reset state\r\n\t\t\tstrLine = _T(\"          |\");\r\n\t\t\tbNonSpace = false;\r\n\r\n\t\t\tfor (unsigned nInd=0;nInd<sXmpLen;nInd++) {\r\n\r\n\t\t\t\t// Get the next char\r\n\t\t\t\tcXmpChar = (char)m_pWBuf->Buf(m_nPos+nInd);\r\n\r\n\t\t\t\t// Detect a non-space in line\r\n\t\t\t\tif ((cXmpChar != 0x20) && (cXmpChar != 0x0A)) {\r\n\t\t\t\t\tbNonSpace = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Detect Linefeed, print out line\r\n\t\t\t\tif (cXmpChar == 0x0A) {\r\n\t\t\t\t\t// Only print line if some non-space elements!\r\n\t\t\t\t\tif (bNonSpace) {\r\n\t\t\t\t\t\tm_pLog->AddLine(strLine);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// Reset state\r\n\t\t\t\t\tstrLine = _T(\"          |\");\r\n\t\t\t\t\tbNonSpace = false;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Add the char\r\n\t\t\t\t\tstrLine.AppendChar(cXmpChar);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (!_tcscmp(acIdentifier,_T(\"Exif\")) != 0)\r\n\t\t{\r\n\t\t\t// Only decode it further if it is EXIF format\r\n\r\n\t\t\tm_nPos += 2; // Skip two 00 bytes\r\n\r\n\r\n\t\t\tnPosExifStart = m_nPos; // Save m_nPos @ start of EXIF used for all IFD offsets\r\n\r\n\t\t\t// =========== EXIF TIFF Header (Start) ===========\r\n\t\t\t// - Defined in Exif 2.2 Standard (JEITA CP-3451) section 4.5.2 \r\n\t\t\t// - Contents (8 bytes total)\r\n\t\t\t//   - Byte order (2 bytes)\r\n\t\t\t//   - 0x002A (2 bytes)\r\n\t\t\t//   - Offset of 0th IFD (4 bytes)\r\n\r\n\t\t\tunsigned char acIdentifierTiff[9];\r\n\t\t\tstrFull = _T(\"\");\r\n\t\t\tstrTmp = _T(\"\");\r\n\r\n\t\t\tstrFull = _T(\"  Identifier TIFF = \");\r\n\t\t\tfor (unsigned int i=0;i<8;i++) {\r\n\t\t\t\tacIdentifierTiff[i] = (unsigned char)Buf(m_nPos++);\r\n\t\t\t}\r\n\t\t\tstrTmp = PrintAsHexUC(acIdentifierTiff,8);\r\n\t\t\tstrFull += strTmp;\r\n\t\t\tm_pLog->AddLine(strFull);\r\n\r\n\r\n\t\t\tswitch (acIdentifierTiff[0]*256+acIdentifierTiff[1])\r\n\t\t\t{\r\n\t\t\tcase 0x4949: // \"II\"\r\n\t\t\t\t// Intel alignment\r\n\t\t\t\tm_nImgExifEndian = 0;\r\n\t\t\t\tm_pLog->AddLine(_T(\"  Endian          = Intel (little)\"));\r\n\t\t\t\tbreak;\r\n\t\t\tcase 0x4D4D: // \"MM\"\r\n\t\t\t\t// Motorola alignment\r\n\t\t\t\tm_nImgExifEndian = 1;\r\n\t\t\t\tm_pLog->AddLine(_T(\"  Endian          = Motorola (big)\"));\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\t// We expect the TAG mark of 0x002A (depending on endian mode)\r\n\t\t\tunsigned test_002a;\r\n\t\t\ttest_002a = ByteSwap2(acIdentifierTiff[2],acIdentifierTiff[3]);\r\n\t\t\tstrTmp.Format(_T(\"  TAG Mark x002A  = 0x%04X\"),test_002a);\r\n\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t\tunsigned nIfdCount;     // Current IFD #\r\n\t\t\tunsigned nOffsetIfd1;\r\n\r\n\t\t\t// Mark pointer to EXIF Sub IFD as 0 so that we can\r\n\t\t\t// detect if the tag never showed up.\r\n\t\t\tm_nImgExifSubIfdPtr = 0;\r\n\t\t\tm_nImgExifMakerPtr = 0;\r\n\t\t\tm_nImgExifGpsIfdPtr = 0;\r\n\t\t\tm_nImgExifInteropIfdPtr = 0;\r\n\r\n\t\t\tbool exif_done = FALSE;\r\n\r\n\t\t\tnOffsetIfd1 = ByteSwap4(acIdentifierTiff[4],acIdentifierTiff[5],\r\n\t\t\t\tacIdentifierTiff[6],acIdentifierTiff[7]);\r\n\r\n\t\t\t// =========== EXIF TIFF Header (End) ===========\r\n\r\n\t\t\t// =========== EXIF IFD 0 ===========\r\n\t\t\t// Do we start the 0th IFD for the \"Primary Image Data\"?\r\n\t\t\t// Even though the nOffsetIfd1 pointer should indicate to\r\n\t\t\t// us where the IFD should start (0x0008 if immediately after\r\n\t\t\t// EXIF TIFF Header), I have observed JPEG files that\r\n\t\t\t// do not contain the IFD. Therefore, we must check for this\r\n\t\t\t// condition by comparing against the APP marker length.\r\n\t\t\t// Example file: http://img9.imageshack.us/img9/194/90114543.jpg\r\n\r\n\t\t\tif ((nPosSaved + nLength) <= (nPosExifStart+nOffsetIfd1)) {\r\n\t\t\t\t// We've run out of space for any IFD, so cancel now\r\n\t\t\t\texif_done = true;\r\n\t\t\t\tm_pLog->AddLine(_T(\"  NOTE: No IFD entries\"));\r\n\t\t\t}\r\n\r\n\r\n\t\t\tnIfdCount = 0;\r\n\t\t\twhile (!exif_done) {\r\n\r\n\t\t\t\tm_pLog->AddLine(_T(\"\"));\r\n\r\n\t\t\t\tstrTmp.Format(_T(\"IFD%u\"),nIfdCount);\r\n\r\n\t\t\t\t// Process the IFD\r\n\t\t\t\tnRet = DecodeExifIfd(strTmp,nPosExifStart,nOffsetIfd1);\r\n\r\n\t\t\t\t// Now that we have gone through all entries in the IFD directory,\r\n\t\t\t\t// we read the offset to the next IFD\r\n\t\t\t\tnOffsetIfd1 = ByteSwap4(Buf(m_nPos+0),Buf(m_nPos+1),Buf(m_nPos+2),Buf(m_nPos+3));\r\n\t\t\t\tm_nPos += 4;\r\n\r\n\r\n\t\t\t\tstrTmp.Format(_T(\"    Offset to Next IFD = 0x%08X\"),nOffsetIfd1);\r\n\t\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\r\n\t\t\t\tif (nRet != 0) {\r\n\t\t\t\t\t// Error condition (DecodeExifIfd returned error)\r\n\t\t\t\t\tnOffsetIfd1 = 0x00000000;\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\tif (nOffsetIfd1 == 0x00000000) {\r\n\t\t\t\t\t// Either error condition or truly end of IFDs\r\n\t\t\t\t\texif_done = TRUE;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tnIfdCount++;\r\n\t\t\t\t}\r\n\r\n\t\t\t} // while ! exif_done\r\n\r\n\t\t\t// If EXIF SubIFD was defined, then handle it now\r\n\t\t\tif (m_nImgExifSubIfdPtr != 0)\r\n\t\t\t{\r\n\t\t\t\tm_pLog->AddLine(_T(\"\"));\r\n\t\t\t\tDecodeExifIfd(_T(\"SubIFD\"),nPosExifStart,m_nImgExifSubIfdPtr);\r\n\t\t\t}\r\n\t\t\tif (m_nImgExifMakerPtr != 0)\r\n\t\t\t{\r\n\t\t\t\tm_pLog->AddLine(_T(\"\"));\r\n\t\t\t\tDecodeExifIfd(_T(\"MakerIFD\"),nPosExifStart,m_nImgExifMakerPtr);\r\n\t\t\t}\r\n\t\t\tif (m_nImgExifGpsIfdPtr != 0)\r\n\t\t\t{\r\n\t\t\t\tm_pLog->AddLine(_T(\"\"));\r\n\t\t\t\tDecodeExifIfd(_T(\"GPSIFD\"),nPosExifStart,m_nImgExifGpsIfdPtr);\r\n\t\t\t}\r\n\t\t\tif (m_nImgExifInteropIfdPtr != 0)\r\n\t\t\t{\r\n\t\t\t\tm_pLog->AddLine(_T(\"\"));\r\n\t\t\t\tDecodeExifIfd(_T(\"InteropIFD\"),nPosExifStart,m_nImgExifInteropIfdPtr);\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\t\t\tstrTmp.Format(_T(\"Identifier [%s] not supported. Skipping remainder.\"),(LPCTSTR)acIdentifier);\r\n\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t}\r\n\r\n\t\t//////////\r\n\r\n\r\n\t\t// Dump out Makernote area\r\n\r\n\t\t// TODO: Disabled for now\r\n#if 0\r\n\t\tunsigned ptr_base;\r\n\r\n\t\tif (m_bVerbose)\r\n\t\t{\r\n\t\t\tif (m_nImgExifMakerPtr != 0)\r\n\t\t\t{\r\n\t\t\t\t// FIXME: Seems that nPosExifStart is not initialized in VERBOSE mode\r\n\t\t\t\tptr_base = nPosExifStart+m_nImgExifMakerPtr;\r\n\r\n\t\t\t\tm_pLog->AddLine(_T(\"Exif Maker IFD DUMP\"));\r\n\t\t\t\tstrFull.Format(_T(\"  MarkerOffset @ 0x%08X\"),ptr_base);\r\n\t\t\t\tm_pLog->AddLine(strFull);\r\n\t\t\t}\r\n\t\t}\r\n#endif\r\n\r\n\t\t// End of dump out makernote area\r\n\r\n\r\n\r\n\t\t// Restore file position\r\n\t\tm_nPos = nPosSaved;\r\n\r\n\r\n\t\t// Restore original position in file to a point\r\n\t\t// after the section\r\n\t\tm_nPos = nPosSaved+nLength;\r\n\r\n\t\tbreak;\r\n\r\n\tcase JFIF_APP2:\r\n\t\t// Typically used for Flashpix and possibly ICC profiles\r\n\t\t// Photoshop (Save As)\r\n\t\tnLength = Buf(m_nPos)*256 + Buf(m_nPos+1);\r\n\t\t//nLength = m_pWBuf->BufX(m_nPos,2,!m_nImgExifEndian);\r\n\t\tstrTmp.Format(_T(\"  Length          = %u\"),nLength);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tnPosSaved = m_nPos;\r\n\r\n\t\tm_nPos += 2; // Move past length now that we've used it\r\n\r\n\r\n\t\t_tcscpy_s(acIdentifier,MAX_IDENTIFIER,m_pWBuf->BufReadStrn(m_nPos,MAX_IDENTIFIER-1));\r\n\t\tacIdentifier[MAX_IDENTIFIER-1] = 0; // Null terminate just in case\r\n\t\tstrTmp.Format(_T(\"  Identifier      = [%s]\"),acIdentifier);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\t\tm_nPos += (unsigned)_tcslen(acIdentifier)+1;\r\n\t\tif (_tcscmp(acIdentifier,_T(\"FPXR\")) == 0) {\r\n\t\t\t// Photoshop\r\n\t\t\tm_pLog->AddLine(_T(\"    FlashPix:\"));\r\n\t\t\tDecodeApp2Flashpix();\r\n\t\t} else if (_tcscmp(acIdentifier,_T(\"ICC_PROFILE\")) == 0) {\r\n\t\t\t// ICC Profile\r\n\t\t\tm_pLog->AddLine(_T(\"    ICC Profile:\"));\r\n\t\t\tDecodeApp2IccProfile(nLength);\r\n\t\t} else {\r\n\t\t\tm_pLog->AddLine(_T(\"    Not supported. Skipping remainder.\"));\r\n\t\t}\r\n\t\t// Restore original position in file to a point\r\n\t\t// after the section\r\n\t\tm_nPos = nPosSaved+nLength;\r\n\t\tbreak;\r\n\r\n\r\n\tcase JFIF_APP3:\r\n\tcase JFIF_APP4:\r\n\tcase JFIF_APP5:\r\n\tcase JFIF_APP6:\r\n\tcase JFIF_APP7:\r\n\tcase JFIF_APP8:\r\n\tcase JFIF_APP9:\r\n\tcase JFIF_APP10:\r\n\tcase JFIF_APP11:\r\n\t\t//case JFIF_APP12: // Handled separately\r\n\t\t//case JFIF_APP13: // Handled separately\r\n\t\t//case JFIF_APP14: // Handled separately\r\n\tcase JFIF_APP15:\r\n\t\tnLength = Buf(m_nPos)*256 + Buf(m_nPos+1);\r\n\t\t//nLength = m_pWBuf->BufX(m_nPos,2,!m_nImgExifEndian);\r\n\t\tstrTmp.Format(_T(\"  Length     = %u\"),nLength);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tif (m_bVerbose)\r\n\t\t{\r\n\r\n\t\t\tstrFull = _T(\"\");\r\n\t\t\tfor (unsigned int i=0;i<nLength;i++)\r\n\t\t\t{\r\n\t\t\t\t// Start a new line for every 16 codes\r\n\t\t\t\tif ((i % 16) == 0) {\r\n\t\t\t\t\tstrFull.Format(_T(\"  MarkerOffset [%04X]: \"),i);\r\n\t\t\t\t} else if ((i % 8) == 0) {\r\n\t\t\t\t\tstrFull += _T(\"  \");\r\n\t\t\t\t}\r\n\t\t\t\tnTmpVal = Buf(m_nPos+i);\r\n\t\t\t\tstrTmp.Format(_T(\"%02X \"),nTmpVal);\r\n\t\t\t\tstrFull += strTmp;\r\n\t\t\t\tif ((i%16) == 15) {\r\n\t\t\t\t\tm_pLog->AddLine(strFull);\r\n\t\t\t\t\tstrFull = _T(\"\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tm_pLog->AddLine(strFull);\r\n\r\n\t\t\tstrFull = _T(\"\");\r\n\t\t\tfor (unsigned int i=0;i<nLength;i++)\r\n\t\t\t{\r\n\t\t\t\t// Start a new line for every 16 codes\r\n\t\t\t\tif ((i % 32) == 0) {\r\n\t\t\t\t\tstrFull.Format(_T(\"  MarkerOffset [%04X]: \"),i);\r\n\t\t\t\t} else if ((i % 8) == 0) {\r\n\t\t\t\t\tstrFull += _T(\" \");\r\n\t\t\t\t}\r\n\t\t\t\tnTmpVal = Buf(m_nPos+i);\r\n\t\t\t\tif (_istprint(nTmpVal)) {\r\n\t\t\t\t\tstrTmp.Format(_T(\"%c\"),nTmpVal);\r\n\t\t\t\t\tstrFull += strTmp;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstrFull += _T(\".\");\r\n\t\t\t\t}\r\n\t\t\t\tif ((i%32)==31) {\r\n\t\t\t\t\tm_pLog->AddLine(strFull);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tm_pLog->AddLine(strFull);\r\n\r\n\t\t} // nVerbose\r\n\r\n\t\tm_nPos += nLength;\r\n\t\tbreak;\r\n\r\n\tcase JFIF_APP0: // APP0\r\n\r\n\t\tnLength = Buf(m_nPos)*256 + Buf(m_nPos+1);\r\n\t\t//nLength = m_pWBuf->BufX(m_nPos,2,!m_nImgExifEndian);\r\n\t\tm_nPos+=2;\r\n\t\tstrTmp.Format(_T(\"  Length     = %u\"),nLength);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t_tcscpy_s(m_acApp0Identifier,MAX_IDENTIFIER,m_pWBuf->BufReadStrn(m_nPos,MAX_IDENTIFIER-1));\r\n\t\tm_acApp0Identifier[MAX_IDENTIFIER-1] = 0; // Null terminate just in case\r\n\t\tstrTmp.Format(_T(\"  Identifier = [%s]\"),m_acApp0Identifier);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tif (!_tcscmp(m_acApp0Identifier,_T(\"JFIF\")))\r\n\t\t{\r\n\t\t\t// Only process remainder if it is JFIF. This marker\r\n\t\t\t// is also used for application-specific functions.\r\n\r\n\t\t\tm_nPos += (unsigned)(_tcslen(m_acApp0Identifier)+1);\r\n\r\n\t\t\tm_nImgVersionMajor = Buf(m_nPos++);\r\n\t\t\tm_nImgVersionMinor = Buf(m_nPos++);\r\n\t\t\tstrTmp.Format(_T(\"  version    = [%u.%u]\"),m_nImgVersionMajor,m_nImgVersionMinor);\r\n\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t\tm_nImgUnits = Buf(m_nPos++);\r\n\r\n\t\t\tm_nImgDensityX = Buf(m_nPos)*256 + Buf(m_nPos+1);\r\n\t\t\t//m_nImgDensityX = m_pWBuf->BufX(m_nPos,2,!m_nImgExifEndian);\r\n\t\t\tm_nPos+=2;\r\n\t\t\tm_nImgDensityY = Buf(m_nPos)*256 + Buf(m_nPos+1);\r\n\t\t\t//m_nImgDensityY = m_pWBuf->BufX(m_nPos,2,!m_nImgExifEndian);\r\n\t\t\tm_nPos+=2;\r\n\t\t\tstrTmp.Format(_T(\"  density    = %u x %u \"),m_nImgDensityX,m_nImgDensityY);\r\n\t\t\tstrFull = strTmp;\r\n\r\n\t\t\tswitch (m_nImgUnits)\r\n\t\t\t{\r\n\t\t\tcase 0:\r\n\t\t\t\tstrFull += _T(\"(aspect ratio)\");\r\n\t\t\t\tm_pLog->AddLine(strFull);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 1:\r\n\t\t\t\tstrFull += _T(\"DPI (dots per inch)\");\r\n\t\t\t\tm_pLog->AddLine(strFull);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2:\r\n\t\t\t\tstrFull += _T(\"DPcm (dots per cm)\");\r\n\t\t\t\tm_pLog->AddLine(strFull);\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tstrTmp.Format(_T(\"ERROR: Unknown ImgUnits parameter [%u]\"),m_nImgUnits);\r\n\t\t\t\tstrFull += strTmp;\r\n\t\t\t\tm_pLog->AddLineWarn(strFull);\r\n\t\t\t\t//return DECMARK_ERR;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\r\n\t\t\tm_nImgThumbSizeX = Buf(m_nPos++);\r\n\t\t\tm_nImgThumbSizeY = Buf(m_nPos++);\r\n\t\t\tstrTmp.Format(_T(\"  thumbnail  = %u x %u\"),m_nImgThumbSizeX,m_nImgThumbSizeY);\r\n\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t\t// Unpack the thumbnail:\r\n\t\t\tunsigned thumbnail_r,thumbnail_g,thumbnail_b;\r\n\t\t\tif (m_nImgThumbSizeX && m_nImgThumbSizeY) {\r\n\t\t\t\tfor (unsigned y=0;y<m_nImgThumbSizeY;y++) {\r\n\t\t\t\t\tstrFull.Format(_T(\"   Thumb[%03u] = \"),y);\r\n\t\t\t\t\tfor (unsigned x=0;x<m_nImgThumbSizeX;x++) {\r\n\t\t\t\t\t\tthumbnail_r = Buf(m_nPos++);\r\n\t\t\t\t\t\tthumbnail_g = Buf(m_nPos++);\r\n\t\t\t\t\t\tthumbnail_b = Buf(m_nPos++);\r\n\t\t\t\t\t\tstrTmp.Format(_T(\"(0x%02X,0x%02X,0x%02X) \"),thumbnail_r,thumbnail_g,thumbnail_b);\r\n\t\t\t\t\t\tstrFull += strTmp;\r\n\t\t\t\t\t\tm_pLog->AddLine(strFull);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// TODO:\r\n\t\t\t// - In JPEG-B mode (GeoRaster), we will need to fake out\r\n\t\t\t//   the DHT & DQT tables here. Unfortunately, we'll have to\r\n\t\t\t//   rely on the user to put us into this mode as there is nothing\r\n\t\t\t//   in the file that specifies this mode.\r\n\r\n\t\t\t/*\r\n\t\t\t// TODO: Need to ensure that Faked DHT is correct table\r\n\r\n\t\t\tAddHeader(JFIF_DHT_FAKE);\r\n\t\t\tDecodeDHT(true);\r\n\t\t\t// Need to mark DHT tables as OK\r\n\t\t\tm_bStateDht = true;\r\n\t\t\tm_bStateDhtFake = true;\r\n\t\t\tm_bStateDhtOk = true;\r\n\r\n\t\t\t// ... same for DQT\r\n\t\t\t*/\r\n\r\n\r\n\r\n\t\t} else if (!_tcsnccmp(m_acApp0Identifier,_T(\"AVI1\"),4))\r\n\t\t{\r\n\t\t\t// AVI MJPEG type\r\n\r\n\t\t\t// Need to fill in predefined DHT table from spec:\r\n\t\t\t//   OpenDML file format for AVI, section \"Proposed Data Chunk Format\"\r\n\t\t\t//   Described in MMREG.H\r\n\t\t\tm_pLog->AddLine(_T(\"  Detected MotionJPEG\"));\r\n\t\t\tm_pLog->AddLine(_T(\"  Importing standard Huffman table...\"));\r\n\t\t\tm_pLog->AddLine(_T(\"\"));\r\n\r\n\t\t\tAddHeader(JFIF_DHT_FAKE);\r\n\r\n\t\t\tDecodeDHT(true);\r\n\t\t\t// Need to mark DHT tables as OK\r\n\t\t\tm_bStateDht = true;\r\n\t\t\tm_bStateDhtFake = true;\r\n\t\t\tm_bStateDhtOk = true;\r\n\r\n\t\t\tm_nPos += nLength-2; // Skip over, and undo length short read\r\n\r\n\r\n\t\t} else {\r\n\t\t\t// Not JFIF or AVI1\r\n\t\t\tm_pLog->AddLine(_T(\"    Not known APP0 type. Skipping remainder.\"));\r\n\t\t\tm_nPos += nLength-2;\r\n\t\t}\r\n\r\n\t\tif (!ExpectMarkerEnd(nPosMarkerStart,nLength))\r\n\t\t\treturn DECMARK_ERR;\r\n\r\n\t\tbreak;\r\n\r\n\tcase JFIF_DQT:  // Define quantization tables\r\n\t\tm_bStateDqt = true;\r\n\t\tunsigned nDqtPrecision_Pq;\r\n\t\tunsigned nDqtQuantDestId_Tq;\r\n\t\tnLength = Buf(m_nPos)*256 + Buf(m_nPos+1);\t// Lq\r\n\t\tnPosEnd = m_nPos+nLength;\r\n\t\tm_nPos+=2;\r\n//XXX\t\tstrTmp.Format(_T(\"  Table length <Lq> = %u\"),nLength); \r\n\t\tstrTmp.Format(_T(\"  Table length = %u\"),nLength); \r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\twhile (nPosEnd > m_nPos)\r\n\t\t{\r\n\t\t\tstrTmp.Format(_T(\"  ----\"));\r\n\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t\tnTmpVal = Buf(m_nPos++);\t\t\t\t\t// Pq | Tq\r\n\t\t\tnDqtPrecision_Pq = (nTmpVal & 0xF0) >> 4;\t// Pq, range 0-1\r\n\t\t\tnDqtQuantDestId_Tq = nTmpVal & 0x0F;\t\t// Tq, range 0-3\r\n\r\n\t\t\t// Decode per ITU-T.81 standard\r\n#if 1\r\n\r\n\t\t\tif (nDqtPrecision_Pq == 0) {\r\n\t\t\t\tstrDqtPrecision = _T(\"8 bits\");\r\n\t\t\t} else if (nDqtPrecision_Pq == 1) {\r\n\t\t\t\tstrDqtPrecision = _T(\"16 bits\");\r\n\t\t\t} else {\r\n\t\t\t\tstrTmp.Format(_T(\"    Unsupported precision value [%u]\"),nDqtPrecision_Pq);\r\n\t\t\t\tm_pLog->AddLineWarn(strTmp);\r\n\t\t\t\tstrDqtPrecision = _T(\"???\");\r\n\t\t\t\t// FIXME: Consider terminating marker parsing early\r\n\t\t\t}\r\n\r\n\t\t\tif (!ValidateValue(nDqtPrecision_Pq,0,1,_T(\"DQT Precision <Pq>\"),true,0)) return DECMARK_ERR;\r\n\t\t\tif (!ValidateValue(nDqtQuantDestId_Tq,0,3,_T(\"DQT Destination ID <Tq>\"),true,0)) return DECMARK_ERR;\r\n\r\n\t\t\tstrTmp.Format(_T(\"  Precision=%s\"),(LPCTSTR)strDqtPrecision);\r\n\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n#else\r\n\t\t\t// Decode with additional DQT extension (ITU-T-JPEG-Plus-Proposal_R3.doc)\r\n\r\n\t\t\tif ((nDqtPrecision_Pq & 0xE) == 0) {\r\n\t\t\t\t// Per ITU-T.81 Standard\r\n\t\t\t\tif (nDqtPrecision_Pq == 0) {\r\n\t\t\t\t\tstrDqtPrecision = _T(\"8 bits\");\r\n\t\t\t\t} else if (nDqtPrecision_Pq == 1) {\r\n\t\t\t\t\tstrDqtPrecision = _T(\"16 bits\");\r\n\t\t\t\t}\r\n\t\t\t\tstrTmp.Format(_T(\"  Precision=%s\"),strDqtPrecision);\r\n\t\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t\t} else {\r\n\t\t\t\t// Non-standard\r\n\t\t\t\t// JPEG-Plus-Proposal-R3:\r\n\t\t\t\t// - Alternative sub-block-wise sequence\r\n\t\t\t\tstrTmp.Format(_T(\"  Non-Standard DQT Extension detected\"));\r\n\t\t\t\tm_pLog->AddLineWarn(strTmp);\r\n\r\n\t\t\t\t// FIXME: Should prevent attempt to decode until this is implemented\r\n\r\n\t\t\t\tif (nDqtPrecision_Pq == 0) {\r\n\t\t\t\t\tstrDqtPrecision = _T(\"8 bits\");\r\n\t\t\t\t} else if (nDqtPrecision_Pq == 1) {\r\n\t\t\t\t\tstrDqtPrecision = _T(\"16 bits\");\r\n\t\t\t\t}\r\n\t\t\t\tstrTmp.Format(_T(\"  Precision=%s\"),strDqtPrecision);\r\n\t\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t\t\tif ((nDqtPrecision_Pq & 0x2) == 0) {\r\n\t\t\t\t\tstrDqtZigZagOrder = _T(\"Diagonal zig-zag coeff scan seqeunce\");\r\n\t\t\t\t} else if ((nDqtPrecision_Pq & 0x2) == 1) {\r\n\t\t\t\t\tstrDqtZigZagOrder = _T(\"Alternate coeff scan seqeunce\");\r\n\t\t\t\t}\r\n\t\t\t\tstrTmp.Format(_T(\"  Coeff Scan Sequence=%s\"),strDqtZigZagOrder);\r\n\t\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t\t\tif ((nDqtPrecision_Pq & 0x4) == 1) {\r\n\t\t\t\t\tstrTmp.Format(_T(\"  Custom coeff scan sequence\"));\r\n\t\t\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t\t\t\t// Now expect sequence of 64 coefficient entries\r\n\t\t\t\t\tCString strSequence = _T(\"\");\r\n\t\t\t\t\tfor (unsigned nInd=0;nInd<64;nInd++) {\r\n\t\t\t\t\t\tnTmpVal = Buf(m_nPos++);\r\n\t\t\t\t\t\tstrTmp.Format(_T(\"%u\"),nTmpVal);\r\n\t\t\t\t\t\tstrSequence += strTmp;\r\n\t\t\t\t\t\tif (nInd!=63) {\r\n\t\t\t\t\t\t\tstrSequence += _T(\", \");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tstrTmp.Format(_T(\"  Custom sequence = [ %s ]\"),strSequence);\r\n\t\t\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t\t\t}\r\n\t\t\t}\r\n#endif\r\n\r\n\t\t\tstrTmp.Format(_T(\"  Destination ID=%u\"),nDqtQuantDestId_Tq);\r\n\t\t\tif (nDqtQuantDestId_Tq == 0) {\r\n\t\t\t\tstrTmp += _T(\" (Luminance)\");\r\n\t\t\t}\r\n\t\t\telse if (nDqtQuantDestId_Tq == 1) {\r\n\t\t\t\tstrTmp += _T(\" (Chrominance)\");\r\n\t\t\t}\r\n\t\t\telse if (nDqtQuantDestId_Tq == 2) {\r\n\t\t\t\tstrTmp += _T(\" (Chrominance)\");\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tstrTmp += _T(\" (???)\");\r\n\t\t\t}\r\n\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\r\n\t\t\t// FIXME: The following is somewhat superseded by ValidateValue() above\r\n\t\t\t// with the exception of skipping remainder\r\n\t\t\tif (nDqtQuantDestId_Tq >= MAX_DQT_DEST_ID) {\r\n\t\t\t\tstrTmp.Format(_T(\"ERROR: Destination ID <Tq> = %u, >= %u\"),nDqtQuantDestId_Tq,MAX_DQT_DEST_ID);\r\n\t\t\t\tm_pLog->AddLineErr(strTmp);\r\n\t\t\t\tif (!m_pAppConfig->bRelaxedParsing) {\r\n\t\t\t\t\tm_pLog->AddLineErr(_T(\"  Stopping decode\"));\r\n\t\t\t\t\treturn DECMARK_ERR;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Now skip remainder of DQT\r\n\t\t\t\t\t// FIXME\r\n\t\t\t\t\tstrTmp.Format(_T(\"  Skipping remainder of marker [%u bytes]\"),nPosMarkerStart + nLength - m_nPos);\r\n\t\t\t\t\tm_pLog->AddLineWarn(strTmp);\r\n\t\t\t\t\tm_pLog->AddLine(_T(\"\"));\r\n\t\t\t\t\tm_nPos = nPosMarkerStart + nLength;\r\n\t\t\t\t\treturn DECMARK_OK;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tbool\tbQuantAllOnes = true;\r\n\t\t\tdouble\tdComparePercent;\r\n\t\t\tdouble\tdSumPercent=0;\r\n\t\t\tdouble\tdSumPercentSqr=0;\r\n\r\n\r\n\t\t\tfor (unsigned nCoeffInd=0;nCoeffInd<MAX_DQT_COEFF;nCoeffInd++)\r\n\t\t\t{\r\n\t\t\t\tnTmpVal = Buf(m_nPos++);\r\n\t\t\t\tif (nDqtPrecision_Pq == 1) {\r\n\t\t\t\t\t// 16-bit DQT entries!\r\n\t\t\t\t\tnTmpVal <<= 8;\r\n\t\t\t\t\tnTmpVal += Buf(m_nPos++);\r\n\t\t\t\t}\r\n\t\t\t\tm_anImgDqtTbl[nDqtQuantDestId_Tq][glb_anZigZag[nCoeffInd]] = nTmpVal;\r\n\r\n\r\n\t\t\t\t/* scaling factor in percent */\r\n\r\n\t\t\t\t// Now calculate the comparison with the Annex sample\r\n\r\n\t\t\t\t// FIXME: Should probably use check for landscape orientation and\r\n\t\t\t\t//        rotate comparison matrix accordingly\r\n\r\n\t\t\t\tif (nDqtQuantDestId_Tq == 0) {\r\n\t\t\t\t\tif (m_anImgDqtTbl[nDqtQuantDestId_Tq][glb_anZigZag[nCoeffInd]] != 0) {\r\n\t\t\t\t\t\tm_afStdQuantLumCompare[glb_anZigZag[nCoeffInd]] =\r\n\t\t\t\t\t\t\t(float)(glb_anStdQuantLum[glb_anZigZag[nCoeffInd]]) /\r\n\t\t\t\t\t\t\t(float)(m_anImgDqtTbl[nDqtQuantDestId_Tq][glb_anZigZag[nCoeffInd]]);\r\n\t\t\t\t\t\tdComparePercent = 100.0 *\r\n\t\t\t\t\t\t\t(double)(m_anImgDqtTbl[nDqtQuantDestId_Tq][glb_anZigZag[nCoeffInd]]) /\r\n\t\t\t\t\t\t\t(double)(glb_anStdQuantLum[glb_anZigZag[nCoeffInd]]);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tm_afStdQuantLumCompare[glb_anZigZag[nCoeffInd]] = (float)999.99;\r\n\t\t\t\t\t\tdComparePercent = 999.99;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (m_anImgDqtTbl[nDqtQuantDestId_Tq][glb_anZigZag[nCoeffInd]] != 0) {\r\n\t\t\t\t\t\tm_afStdQuantChrCompare[glb_anZigZag[nCoeffInd]] =\r\n\t\t\t\t\t\t\t(float)(glb_anStdQuantChr[glb_anZigZag[nCoeffInd]]) /\r\n\t\t\t\t\t\t\t(float)(m_anImgDqtTbl[nDqtQuantDestId_Tq][glb_anZigZag[nCoeffInd]]);\r\n\t\t\t\t\t\tdComparePercent = 100.0 *\r\n\t\t\t\t\t\t\t(double)(m_anImgDqtTbl[nDqtQuantDestId_Tq][glb_anZigZag[nCoeffInd]]) /\r\n\t\t\t\t\t\t\t(double)(glb_anStdQuantChr[glb_anZigZag[nCoeffInd]]);\r\n\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tm_afStdQuantChrCompare[glb_anZigZag[nCoeffInd]] = (float)999.99;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdSumPercent += dComparePercent;\r\n\t\t\t\tdSumPercentSqr += dComparePercent * dComparePercent;\r\n\r\n\t\t\t\t// Check just in case entire table are ones (Quality 100)\r\n\t\t\t\tif (m_anImgDqtTbl[nDqtQuantDestId_Tq][glb_anZigZag[nCoeffInd]] != 1) bQuantAllOnes = 0;\r\n\r\n\r\n\t\t\t} // 0..63\r\n\r\n\t\t\t// Note that the DQT table that we are saving is already\r\n\t\t\t// after doing zigzag reordering:\r\n\t\t\t// From high freq -> low freq\r\n\t\t\t// To X,Y, left-to-right, top-to-bottom\r\n\r\n\t\t\t// Flag this DQT table as being set!\r\n\t\t\tm_abImgDqtSet[nDqtQuantDestId_Tq] = true;\r\n\r\n\t\t\tunsigned nCoeffInd;\r\n\r\n\t\t\t// Now display the table\r\n\t\t\tfor (unsigned nDqtY=0;nDqtY<8;nDqtY++) {\r\n\t\t\t\tstrFull.Format(_T(\"    DQT, Row #%u: \"),nDqtY);\r\n\t\t\t\tfor (unsigned nDqtX=0;nDqtX<8;nDqtX++) {\r\n\t\t\t\t\tnCoeffInd = nDqtY*8+nDqtX;\r\n\t\t\t\t\tstrTmp.Format(_T(\"%3u \"),m_anImgDqtTbl[nDqtQuantDestId_Tq][nCoeffInd]);\r\n\t\t\t\t\tstrFull += strTmp;\r\n\r\n\t\t\t\t\t// Store the DQT entry into the Image Decoder\r\n\t\t\t\t\tbRet = m_pImgDec->SetDqtEntry(nDqtQuantDestId_Tq,nCoeffInd,glb_anUnZigZag[nCoeffInd],\r\n\t\t\t\t\t\tm_anImgDqtTbl[nDqtQuantDestId_Tq][nCoeffInd]);\r\n\t\t\t\t\tDecodeErrCheck(bRet);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Now add the compare with Annex K\r\n\t\t\t\t// Decided to disable this as it was confusing users\r\n\t\t\t\t/*\r\n\t\t\t\tstrFull += _T(\"   AnnexRatio: <\");\r\n\t\t\t\tfor (unsigned nDqtX=0;nDqtX<8;nDqtX++) {\r\n\t\t\t\t\tnCoeffInd = nDqtY*8+nDqtX;\r\n\t\t\t\t\tif (nDqtQuantDestId_Tq == 0) {\r\n\t\t\t\t\t\tstrTmp.Format(_T(\"%5.1f \"),m_afStdQuantLumCompare[nCoeffInd]);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tstrTmp.Format(_T(\"%5.1f \"),m_afStdQuantChrCompare[nCoeffInd]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tstrFull += strTmp;\r\n\t\t\t\t}\r\n\t\t\t\tstrFull += _T(\">\");\r\n\t\t\t\t*/\r\n\r\n\t\t\t\tm_pLog->AddLine(strFull);\r\n\r\n\t\t\t}\r\n\r\n\r\n\r\n\t\t\t// Perform some statistical analysis of the quality factor\r\n\t\t\t// to determine the likelihood of the current quantization\r\n\t\t\t// table being a scaled version of the \"standard\" tables.\r\n\t\t\t// If the variance is high, it is unlikely to be the case.\r\n\t\t\tdouble\tdQuality;\r\n\t\t\tdouble\tdVariance;\r\n\t\t\tdSumPercent /= 64.0;\t/* mean scale factor */\r\n\t\t\tdSumPercentSqr /= 64.0;\r\n\t\t\tdVariance = dSumPercentSqr - (dSumPercent * dSumPercent); /* variance */\r\n\r\n\t\t\t// Generate the equivalent IJQ \"quality\" factor\r\n\t\t\tif (bQuantAllOnes)\t\t/* special case for all-ones table */\r\n\t\t\t\tdQuality = 100.0;\r\n\t\t\telse if (dSumPercent <= 100.0)\r\n\t\t\t\tdQuality = (200.0 - dSumPercent) / 2.0;\r\n\t\t\telse\r\n\t\t\t\tdQuality = 5000.0 / dSumPercent;\r\n\r\n\t\t\t// Save the quality rating for later\r\n\t\t\tm_adImgDqtQual[nDqtQuantDestId_Tq] = dQuality;\r\n\r\n\t\t\tstrTmp.Format(_T(\"    Approx quality factor = %.2f (scaling=%.2f variance=%.2f)\"),\r\n\t\t\t\tdQuality,dSumPercent,dVariance);\r\n\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\r\n\t\t}\r\n\t\tm_bStateDqtOk = true;\r\n\r\n\t\tif (!ExpectMarkerEnd(nPosMarkerStart,nLength))\r\n\t\t\treturn DECMARK_ERR;\r\n\r\n\t\tbreak;\r\n\r\n\tcase JFIF_DAC: // DAC (Arithmetic Coding)\r\n\t\tnLength = Buf(m_nPos)*256 + Buf(m_nPos+1);\t// La\r\n\t\tm_nPos+=2;\r\n//XXX\t\tstrTmp.Format(_T(\"  Arithmetic coding header length <La> = %u\"),nLength);\r\n\t\tstrTmp.Format(_T(\"  Arithmetic coding header length = %u\"),nLength);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\t\tunsigned\tnDAC_n;\r\n\t\tunsigned\tnDAC_Tc,nDAC_Tb;\r\n\t\tunsigned\tnDAC_Cs;\r\n\t\tnDAC_n = (nLength>2)?(nLength-2)/2:0;\r\n\t\tfor (unsigned nInd=0;nInd<nDAC_n;nInd++) {\r\n\t\t\tnTmpVal = Buf(m_nPos++);\t// Tc,Tb\r\n\t\t\tnDAC_Tc = (nTmpVal & 0xF0) >> 4;\r\n\t\t\tnDAC_Tb = (nTmpVal & 0x0F);\r\n//XXX\t\t\tstrTmp.Format(_T(\"  #%02u: Table class <Tc>                  = %u\"),nInd+1,nDAC_Tc);\r\n\t\t\tstrTmp.Format(_T(\"  #%02u: Table class                  = %u\"),nInd+1,nDAC_Tc);\r\n\t\t\tm_pLog->AddLine(strTmp);\r\n//XXX\t\t\tstrTmp.Format(_T(\"  #%02u: Table destination identifier <Tb> = %u\"),nInd+1,nDAC_Tb);\r\n\t\t\tstrTmp.Format(_T(\"  #%02u: Table destination identifier = %u\"),nInd+1,nDAC_Tb);\r\n\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t\tnDAC_Cs = Buf(m_nPos++);\t// Cs\r\n//XXX\t\t\tstrTmp.Format(_T(\"  #%02u: Conditioning table value <Cs>     = %u\"),nInd+1,nDAC_Cs);\r\n\t\t\tstrTmp.Format(_T(\"  #%02u: Conditioning table value     = %u\"),nInd+1,nDAC_Cs);\r\n\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t\tif (!ValidateValue(nDAC_Tc,0,1,_T(\"Table class <Tc>\"),true,0)) return DECMARK_ERR;\r\n\t\t\tif (!ValidateValue(nDAC_Tb,0,3,_T(\"Table destination ID <Tb>\"),true,0)) return DECMARK_ERR;\r\n\r\n\t\t\t// Parameter range constraints per Table B.6:\r\n\t\t\t// ------------|-------------------------|-------------------|------------\r\n\t\t\t//             |     Sequential DCT      |  Progressive DCT  | Lossless\r\n\t\t\t//   Parameter |  Baseline    Extended   |                   |\r\n\t\t\t// ------------|-----------|-------------|-------------------|------------\r\n\t\t\t//     Cs      |   Undef   | Tc=0: 0-255 | Tc=0: 0-255       | 0-255\r\n\t\t\t//             |           | Tc=1: 1-63  | Tc=1: 1-63        |\r\n\t\t\t// ------------|-----------|-------------|-------------------|------------\r\n\r\n\t\t\t// However, to keep it simple (and not depend on lossless mode),\r\n\t\t\t// we will only check the maximal range\r\n\t\t\tif (!ValidateValue(nDAC_Cs,0,255,_T(\"Conditioning table value <Cs>\"),true,0)) return DECMARK_ERR;\r\n\t\t}\r\n\t\tif (!ExpectMarkerEnd(nPosMarkerStart,nLength))\r\n\t\t\treturn DECMARK_ERR;\r\n\r\n\t\tbreak;\r\n\r\n\tcase JFIF_DNL: // DNL (Define number of lines)\r\n\t\tnLength = Buf(m_nPos)*256 + Buf(m_nPos+1);\t// Ld\r\n\t\tm_nPos+=2;\r\n//XXX\t\tstrTmp.Format(_T(\"  Header length <Ld> = %u\"),nLength);\r\n\t\tstrTmp.Format(_T(\"  Header length = %u\"),nLength);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tnTmpVal = Buf(m_nPos)*256 + Buf(m_nPos+1);\t// NL\r\n\t\tm_nPos+=2;\r\n//XXX\t\tstrTmp.Format(_T(\"  Number of lines <NL> = %u\"),nTmpVal);\r\n\t\tstrTmp.Format(_T(\"  Number of lines = %u\"),nTmpVal);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tif (!ValidateValue(nTmpVal,1,65535,_T(\"Number of lines <NL>\"),true,1)) return DECMARK_ERR;\r\n\r\n\t\tif (!ExpectMarkerEnd(nPosMarkerStart,nLength))\r\n\t\t\treturn DECMARK_ERR;\r\n\t\tbreak;\r\n\r\n\tcase JFIF_EXP: \r\n\t\tnLength = Buf(m_nPos)*256 + Buf(m_nPos+1);\t// Le\r\n\t\tm_nPos+=2;\r\n//XXX\t\tstrTmp.Format(_T(\"  Header length <Le> = %u\"),nLength);\r\n\t\tstrTmp.Format(_T(\"  Header length = %u\"),nLength);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tunsigned\tnEXP_Eh,nEXP_Ev;\r\n\t\tnTmpVal = Buf(m_nPos)*256 + Buf(m_nPos+1);\t// Eh,Ev\r\n\t\tnEXP_Eh = (nTmpVal & 0xF0) >> 4;\r\n\t\tnEXP_Ev = (nTmpVal & 0x0F);\r\n\t\tm_nPos+=2;\r\n//XXX\t\tstrTmp.Format(_T(\"  Expand horizontally <Eh> = %u\"),nEXP_Eh);\r\n\t\tstrTmp.Format(_T(\"  Expand horizontally = %u\"),nEXP_Eh);\r\n\t\tm_pLog->AddLine(strTmp);\r\n//XXX\t\tstrTmp.Format(_T(\"  Expand vertically <Ev>   = %u\"),nEXP_Ev);\r\n\t\tstrTmp.Format(_T(\"  Expand vertically   = %u\"),nEXP_Ev);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\t\t\r\n\t\tif (!ValidateValue(nEXP_Eh,0,1,_T(\"Expand horizontally <Eh>\"),true,0)) return DECMARK_ERR;\r\n\t\tif (!ValidateValue(nEXP_Ev,0,1,_T(\"Expand vertically <Ev>\"),true,0)) return DECMARK_ERR;\r\n\r\n\t\tif (!ExpectMarkerEnd(nPosMarkerStart,nLength))\r\n\t\t\treturn DECMARK_ERR;\r\n\t\tbreak;\r\n\r\n\r\n\tcase JFIF_SOF0: // SOF0 (Baseline DCT)\r\n\tcase JFIF_SOF1: // SOF1 (Extended sequential)\r\n\tcase JFIF_SOF2: // SOF2 (Progressive)\r\n\tcase JFIF_SOF3:\r\n\tcase JFIF_SOF5:\r\n\tcase JFIF_SOF6:\r\n\tcase JFIF_SOF7:\r\n\tcase JFIF_SOF9:\r\n\tcase JFIF_SOF10:\r\n\tcase JFIF_SOF11:\r\n\tcase JFIF_SOF13:\r\n\tcase JFIF_SOF14:\r\n\tcase JFIF_SOF15:\r\n\r\n\t\t// TODO:\r\n\t\t// - JFIF_DHP should be able to reuse the JFIF_SOF marker parsing\r\n\t\t//   however as we don't support hierarchical image decode, we\r\n\t\t//   would want to skip the update of class members.\r\n\r\n\t\tm_bStateSof = true;\r\n\r\n\t\t// Determine if this is a SOF mode that we support\r\n\t\t// At this time, we only support Baseline DCT & Extended Sequential Baseline DCT\r\n\t\t// (non-differential) with Huffman coding. Progressive, Lossless,\r\n\t\t// Differential and Arithmetic coded modes are not supported.\r\n\t\tm_bImgSofUnsupported = true;\r\n\t\tif (nCode == JFIF_SOF0) { m_bImgSofUnsupported = false; }\r\n\t\tif (nCode == JFIF_SOF1) { m_bImgSofUnsupported = false; }\r\n\r\n\t\t// For reference, note progressive scan files even though\r\n\t\t// we don't currently support their decode\r\n\t\tif (nCode == JFIF_SOF2) { m_bImgProgressive = true; }\r\n\r\n\r\n\t\tnLength = Buf(m_nPos)*256 + Buf(m_nPos+1);\t// Lf\r\n\t\tm_nPos+=2;\r\n//XXX\t\tstrTmp.Format(_T(\"  Frame header length <Lf> = %u\"),nLength);\r\n\t\tstrTmp.Format(_T(\"  Frame header length = %u\"),nLength);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tm_nSofPrecision_P = Buf(m_nPos++);\t// P\r\n//XXX\t\tstrTmp.Format(_T(\"  Precision <P> = %u\"),m_nSofPrecision_P);\r\n\t\tstrTmp.Format(_T(\"  Precision = %u\"),m_nSofPrecision_P);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\t\tif (!ValidateValue(m_nSofPrecision_P,2,16,_T(\"Precision <P>\"),true,8)) return DECMARK_ERR;\r\n\r\n\t\tm_nSofNumLines_Y = Buf(m_nPos)*256 + Buf(m_nPos+1);\t// Y\r\n\t\tm_nPos += 2;\r\n//XXX\t\tstrTmp.Format(_T(\"  Number of Lines <Y> = %u\"),m_nSofNumLines_Y);\r\n\t\tstrTmp.Format(_T(\"  Number of Lines = %u\"),m_nSofNumLines_Y);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\t\tif (!ValidateValue(m_nSofNumLines_Y,0,65535,_T(\"Number of Lines <Y>\"),true,0)) return DECMARK_ERR;\r\n\r\n\t\tm_nSofSampsPerLine_X = Buf(m_nPos)*256 + Buf(m_nPos+1);\t// X\r\n\t\tm_nPos += 2; \r\n//XXX\t\tstrTmp.Format(_T(\"  Samples per Line <X> = %u\"),m_nSofSampsPerLine_X);\r\n\t\tstrTmp.Format(_T(\"  Samples per Line = %u\"),m_nSofSampsPerLine_X);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\t\tif (!ValidateValue(m_nSofSampsPerLine_X,1,65535,_T(\"Samples per Line <X>\"),true,1)) return DECMARK_ERR;\r\n\r\n\t\tstrTmp.Format(_T(\"  Image Size = %u x %u\"),m_nSofSampsPerLine_X,m_nSofNumLines_Y);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t// Determine orientation\r\n\t\t//   m_nSofSampsPerLine_X = X\r\n\t\t//   m_nSofNumLines_Y = Y\r\n\t\tm_eImgLandscape = ENUM_LANDSCAPE_YES;\r\n\t\tif (m_nSofNumLines_Y > m_nSofSampsPerLine_X)\r\n\t\t\tm_eImgLandscape = ENUM_LANDSCAPE_NO;\r\n\t\tstrTmp.Format(_T(\"  Raw Image Orientation = %s\"),(m_eImgLandscape==ENUM_LANDSCAPE_YES)?_T(\"Landscape\"):_T(\"Portrait\"));\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tm_nSofNumComps_Nf = Buf(m_nPos++);\t// Nf, range 1..255\r\n//XXX\t\tstrTmp.Format(_T(\"  Number of Img components <Nf> = %u\"),m_nSofNumComps_Nf);\r\n\t\tstrTmp.Format(_T(\"  Number of Img components = %u\"),m_nSofNumComps_Nf);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\t\tif (!ValidateValue(m_nSofNumComps_Nf,1,255,_T(\"Number of Img components <Nf>\"),true,1)) return DECMARK_ERR;\r\n\r\n\t\tunsigned nCompIdent;\r\n\t\tunsigned anSofSampFact[MAX_SOF_COMP_NF];\r\n\r\n\t\tm_nSofHorzSampFactMax_Hmax = 0;\r\n\t\tm_nSofVertSampFactMax_Vmax = 0;\r\n\r\n\t\t// Now clear the output image content (all components)\r\n\t\t// TODO: Migrate some of the bitmap allocation / clearing from\r\n\t\t// DecodeScanImg() into ResetImageContent() and call here\r\n\t\t//m_pImgDec->ResetImageContent();\r\n\r\n\t\t// Per JFIF v1.02:\r\n\t\t// - Nf = 1 or 3\r\n\t\t// - C1 = Y\r\n\t\t// - C2 = Cb\r\n\t\t// - C3 = Cr\r\n\r\n\t\tfor (unsigned nCompInd=1;((!m_bStateAbort)&&(nCompInd<=m_nSofNumComps_Nf));nCompInd++)\r\n\t\t{\r\n\t\t\tnCompIdent = Buf(m_nPos++);\t\t\t\t\t\t\t\t\t\t\t\t// Ci, range 0..255\r\n\t\t\tm_anSofQuantCompId[nCompInd] = nCompIdent;\r\n\t\t\t//if (!ValidateValue(m_anSofQuantCompId[nCompInd],0,255,_T(\"Component ID <Ci>\"),true,0)) return DECMARK_ERR;\r\n\r\n\t\t\tanSofSampFact[nCompIdent] = Buf(m_nPos++);\r\n\t\t\tm_anSofQuantTblSel_Tqi[nCompIdent] = Buf(m_nPos++);\t\t\t\t\t\t// Tqi, range 0..3\r\n\t\t\t//if (!ValidateValue(m_anSofQuantTblSel_Tqi[nCompIdent],0,3,_T(\"Table Destination ID <Tqi>\"),true,0)) return DECMARK_ERR;\r\n\r\n\t\t\t// NOTE: We protect against bad input here as replication ratios are\r\n\t\t\t// determined later that depend on dividing by sampling factor (hence\r\n\t\t\t// possibility of div by 0).\r\n\t\t\tm_anSofHorzSampFact_Hi[nCompIdent] = (anSofSampFact[nCompIdent] & 0xF0) >> 4;\t// Hi, range 1..4\r\n\t\t\tm_anSofVertSampFact_Vi[nCompIdent] = (anSofSampFact[nCompIdent] & 0x0F);\t\t// Vi, range 1..4\r\n\t\t\t//if (!ValidateValue(m_anSofHorzSampFact_Hi[nCompIdent],1,4,_T(\"Horizontal Sampling Factor <Hi>\"),true,1)) return DECMARK_ERR;\r\n\t\t\t//if (!ValidateValue(m_anSofVertSampFact_Vi[nCompIdent],1,4,_T(\"Vertical Sampling Factor <Vi>\"),true,1)) return DECMARK_ERR;\r\n\r\n\t\t}\r\n\r\n\t\t// Calculate max sampling factors\r\n\t\tfor (unsigned nCompInd=1;((!m_bStateAbort)&&(nCompInd<=m_nSofNumComps_Nf));nCompInd++)\r\n\t\t{\r\n\t\t\tnCompIdent = m_anSofQuantCompId[nCompInd];\r\n\t\t\t// Calculate maximum sampling factor for the SOF. This is only\r\n\t\t\t// used for later generation of m_strImgQuantCss an the SOF\r\n\t\t\t// reporting below. The CimgDecode block is responsible for\r\n\t\t\t// calculating the maximum sampling factor on a per-scan basis.\r\n\t\t\tm_nSofHorzSampFactMax_Hmax = max(m_nSofHorzSampFactMax_Hmax,m_anSofHorzSampFact_Hi[nCompIdent]);\r\n\t\t\tm_nSofVertSampFactMax_Vmax = max(m_nSofVertSampFactMax_Vmax,m_anSofVertSampFact_Vi[nCompIdent]);\r\n\t\t}\r\n\r\n\t\t// Report per-component sampling factors and quantization table selectors\r\n\t\tfor (unsigned nCompInd=1;((!m_bStateAbort)&&(nCompInd<=m_nSofNumComps_Nf));nCompInd++)\r\n\t\t{\r\n\t\t\tnCompIdent = m_anSofQuantCompId[nCompInd];\r\n\r\n\t\t\t// Create subsampling ratio\r\n\t\t\t// - Protect against division-by-zero\r\n\t\t\tCString\t\tstrSubsampH = _T(\"?\");\r\n\t\t\tCString\t\tstrSubsampV = _T(\"?\");\r\n\t\t\tif (m_anSofHorzSampFact_Hi[nCompIdent] > 0) {\r\n\t\t\t\tstrSubsampH.Format(_T(\"%u\"),m_nSofHorzSampFactMax_Hmax/m_anSofHorzSampFact_Hi[nCompIdent]);\r\n\t\t\t}\r\n\t\t\tif (m_anSofVertSampFact_Vi[nCompIdent] > 0) {\r\n\t\t\t\tstrSubsampV.Format(_T(\"%u\"),m_nSofVertSampFactMax_Vmax/m_anSofVertSampFact_Vi[nCompIdent]);\r\n\t\t\t}\r\n\r\n\t\t\tstrFull.Format(_T(\"    Component[%u]: \"),nCompInd);\t// Note i in Ci is 1-based\r\n//XXX\t\t\tstrTmp.Format(_T(\"ID=0x%02X, Samp Fac <Hi,Vi>=0x%02X (Subsamp %u x %u), Quant Tbl Sel <Tqi>=0x%02X\"),\r\n\t\t\tstrTmp.Format(_T(\"ID=0x%02X, Samp Fac=0x%02X (Subsamp %s x %s), Quant Tbl Sel=0x%02X\"),\r\n\t\t\t\tnCompIdent,anSofSampFact[nCompIdent],\r\n\t\t\t\t(LPCTSTR)strSubsampH,(LPCTSTR)strSubsampV,\r\n\t\t\t\tm_anSofQuantTblSel_Tqi[nCompIdent]);\r\n\t\t\tstrFull += strTmp;\r\n\r\n\t\t\t// Mapping from component index (not ID) to colour channel per JFIF\r\n\t\t\tif (m_nSofNumComps_Nf == 1) {\r\n\t\t\t\t// Assume grayscale\r\n\t\t\t\tstrFull += _T(\" (Lum: Y)\");\r\n\t\t\t} else if (m_nSofNumComps_Nf == 3) {\r\n\t\t\t\t// Assume YCC\r\n\t\t\t\tif (nCompInd == SCAN_COMP_Y) {\r\n\t\t\t\t\tstrFull += _T(\" (Lum: Y)\");\r\n\t\t\t\t}\r\n\t\t\t\telse if (nCompInd == SCAN_COMP_CB) {\r\n\t\t\t\t\tstrFull += _T(\" (Chrom: Cb)\");\r\n\t\t\t\t}\r\n\t\t\t\telse if (nCompInd == SCAN_COMP_CR) {\r\n\t\t\t\t\tstrFull += _T(\" (Chrom: Cr)\");\r\n\t\t\t\t}\r\n\t\t\t} else if (m_nSofNumComps_Nf == 4) {\r\n\t\t\t\t// Assume YCCK\r\n\t\t\t\tif (nCompInd == 1) {\r\n\t\t\t\t\tstrFull += _T(\" (Y)\");\r\n\t\t\t\t}\r\n\t\t\t\telse if (nCompInd == 2) {\r\n\t\t\t\t\tstrFull += _T(\" (Cb)\");\r\n\t\t\t\t}\r\n\t\t\t\telse if (nCompInd == 3) {\r\n\t\t\t\t\tstrFull += _T(\" (Cr)\");\r\n\t\t\t\t}\r\n\t\t\t\telse if (nCompInd == 4) {\r\n\t\t\t\t\tstrFull += _T(\" (K)\");\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tstrFull += _T(\" (???)\");\t// Unknown\r\n\t\t\t}\r\n\t\t\tm_pLog->AddLine(strFull);\r\n\r\n\t\t}\r\n\r\n\t\t// Test for bad input, clean up if bad\r\n\t\tfor (unsigned nCompInd=1;((!m_bStateAbort)&&(nCompInd<=m_nSofNumComps_Nf));nCompInd++)\r\n\t\t{\r\n\t\t\tnCompIdent = m_anSofQuantCompId[nCompInd];\r\n\t\t\tif (!ValidateValue(m_anSofQuantCompId[nCompInd],0,255,_T(\"Component ID <Ci>\"),true,0)) return DECMARK_ERR;\r\n\t\t\tif (!ValidateValue(m_anSofQuantTblSel_Tqi[nCompIdent],0,3,_T(\"Table Destination ID <Tqi>\"),true,0)) return DECMARK_ERR;\r\n\t\t\tif (!ValidateValue(m_anSofHorzSampFact_Hi[nCompIdent],1,4,_T(\"Horizontal Sampling Factor <Hi>\"),true,1)) return DECMARK_ERR;\r\n\t\t\tif (!ValidateValue(m_anSofVertSampFact_Vi[nCompIdent],1,4,_T(\"Vertical Sampling Factor <Vi>\"),true,1)) return DECMARK_ERR;\r\n\t\t}\r\n\r\n\r\n\t\t// Finally, assign the cleaned values to the decoder\r\n\t\tfor (unsigned nCompInd=1;((!m_bStateAbort)&&(nCompInd<=m_nSofNumComps_Nf));nCompInd++)\r\n\t\t{\r\n\t\t\tnCompIdent = m_anSofQuantCompId[nCompInd];\r\n\t\t\t// Store the DQT Table selection for the Image Decoder\r\n\t\t\t//   Param values: Nf,Tqi\r\n\t\t\t//   Param ranges: 1..255,0..3\r\n\t\t\t// Note that the Image Decoder doesn't need to see the Component Identifiers\r\n\t\t\tbRet = m_pImgDec->SetDqtTables(nCompInd,m_anSofQuantTblSel_Tqi[nCompIdent]);\r\n\t\t\tDecodeErrCheck(bRet);\r\n\r\n\t\t\t// Store the Precision (to handle 12-bit decode)\r\n\t\t\tm_pImgDec->SetPrecision(m_nSofPrecision_P);\r\n\r\n\t\t}\r\n\r\n\t\tif (!m_bStateAbort) {\r\n\r\n\t\t\t// Set the component sampling factors (chroma subsampling)\r\n\t\t\t// FIXME: check ranging\r\n\t\t\tfor (unsigned nCompInd=1;nCompInd<=m_nSofNumComps_Nf;nCompInd++) {\r\n\t\t\t\t// nCompInd is component index (1...Nf)\r\n\t\t\t\t// nCompIdent is Component Identifier (Ci)\r\n\t\t\t\t// Note that the Image Decoder doesn't need to see the Component Identifiers\r\n\t\t\t\tnCompIdent = m_anSofQuantCompId[nCompInd];\r\n\t\t\t\tm_pImgDec->SetSofSampFactors(nCompInd,m_anSofHorzSampFact_Hi[nCompIdent],m_anSofVertSampFact_Vi[nCompIdent]);\r\n\t\t\t}\r\n\r\n\t\t\t// Now mark the image as been somewhat OK (ie. should\r\n\t\t\t// also be suitable for EmbeddedThumb() and PrepareSignature()\r\n\t\t\tm_bImgOK = true;\r\n\r\n\t\t\tm_bStateSofOk = true;\r\n\r\n\t\t}\r\n\r\n\t\tif (!ExpectMarkerEnd(nPosMarkerStart,nLength))\r\n\t\t\treturn DECMARK_ERR;\r\n\r\n\t\tbreak;\r\n\r\n\r\n\tcase JFIF_COM: // COM\r\n\t\tnLength = Buf(m_nPos)*256 + Buf(m_nPos+1);\r\n\t\tm_nPos+=2;\r\n\t\tstrTmp.Format(_T(\"  Comment length = %u\"),nLength); \r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t// Check for JPEG COM vulnerability\r\n\t\t//   http://marc.info/?l=bugtraq&m=109524346729948\r\n\t\t// Note that the recovery is not very graceful. It will assume that the\r\n\t\t// field is actually zero-length, which will make the next byte trigger the\r\n\t\t// \"Expected marker 0xFF\" error message and probably abort. There is no\r\n\t\t// obvious way to \r\n\r\n\t\tif ( (nLength == 0) || (nLength == 1) ) {\r\n\t\t\tstrTmp.Format(_T(\"    JPEG Comment Field Vulnerability detected!\"));\r\n\t\t\tm_pLog->AddLineErr(strTmp);\r\n\t\t\tstrTmp.Format(_T(\"    Skipping data until next marker...\"));\r\n\t\t\tm_pLog->AddLineErr(strTmp);\r\n\t\t\tnLength = 2;\r\n\r\n\t\t\tbool bDoneSearch = false;\r\n\t\t\tunsigned nSkipStart = m_nPos;\r\n\t\t\twhile (!bDoneSearch) {\r\n                if (Buf(m_nPos) != 0xFF) {\r\n\t\t\t\t\tm_nPos++;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbDoneSearch = true;\r\n\t\t\t\t}\r\n\t\t\t\tif (m_nPos >= m_pWBuf->GetPosEof()) {\r\n\t\t\t\t\tbDoneSearch = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tstrTmp.Format(_T(\"    Skipped %u bytes\"),m_nPos - nSkipStart);\r\n\t\t\tm_pLog->AddLineErr(strTmp);\r\n\r\n\t\t\t// Break out of case statement\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t// Assume COM field valid length (ie. >= 2)\r\n\t\tstrFull = _T(\"    Comment=\");\r\n\t\tm_strComment = _T(\"\");\r\n\t\tfor (unsigned ind=0;ind<nLength-2;ind++)\r\n\t\t{\r\n\t\t\tnTmpVal = Buf(m_nPos++);\r\n\t\t\tif (_istprint(nTmpVal)) {\r\n\t\t\t\tstrTmp.Format(_T(\"%c\"),nTmpVal);\r\n\t\t\t\tm_strComment += strTmp;\r\n\t\t\t} else {\r\n\t\t\t\tm_strComment += _T(\".\");\r\n\t\t\t}\r\n\t\t}\r\n\t\tstrFull += m_strComment;\r\n\t\tm_pLog->AddLine(strFull);\r\n\r\n\t\tbreak;\r\n\r\n\tcase JFIF_DHT: // DHT    \r\n\t\tm_bStateDht = true;\r\n\t\tDecodeDHT(false);\r\n\t\tm_bStateDhtOk = true;\r\n\t\tbreak;\r\n\r\n\tcase JFIF_SOS: // SOS\r\n\t\tunsigned long nPosScanStart;\t// Byte count at start of scan data segment\r\n\r\n\t\tm_bStateSos = true;\r\n\r\n\t\t// NOTE: Only want to capture position of first SOS\r\n\t\t//       This should make other function such as AVI frame extract\r\n\t\t//       more robust in case we get multiple SOS segments.\r\n\t\t// We assume that this value is reset when we start a new decode\r\n\t\tif (m_nPosSos == 0) {\r\n\t\t\tm_nPosSos = m_nPos-2;\t// Used for Extract. Want to include actual marker\r\n\t\t}\r\n\r\n\t\tnLength = Buf(m_nPos)*256 + Buf(m_nPos+1);\r\n\t\tm_nPos+=2;\r\n\r\n\t\t// Ensure that we have seen proper markers before we try this one!\r\n\t\tif (!m_bStateSofOk) {\r\n\t\t\tstrTmp.Format(_T(\"  ERROR: SOS before valid SOF defined\"));\r\n\t\t\tm_pLog->AddLineErr(strTmp);\r\n\t\t\treturn DECMARK_ERR;\r\n\t\t}\r\n\r\n\t\tstrTmp.Format(_T(\"  Scan header length = %u\"),nLength); \r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tm_nSosNumCompScan_Ns = Buf(m_nPos++);\t\t// Ns, range 1..4\r\n//XXX\t\tstrTmp.Format(_T(\"  Number of image components <Ns> = %u\"),m_nSosNumCompScan_Ns);\r\n\t\tstrTmp.Format(_T(\"  Number of img components = %u\"),m_nSosNumCompScan_Ns);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t// Just in case something got corrupted, don't want to get out\r\n\t\t// of range here. Note that this will be a hard abort, and\r\n\t\t// will not resume decoding.\r\n\t\tif (m_nSosNumCompScan_Ns > MAX_SOS_COMP_NS) {\r\n\t\t\tstrTmp.Format(_T(\"  ERROR: Scan decode does not support > %u components\"),MAX_SOS_COMP_NS);\r\n\t\t\tm_pLog->AddLineErr(strTmp);\r\n\t\t\treturn DECMARK_ERR;\r\n\t\t}\r\n\r\n\t\tunsigned nSosCompSel_Cs;\r\n\t\tunsigned nSosHuffTblSel;\r\n\t\tunsigned nSosHuffTblSelDc_Td;\r\n\t\tunsigned nSosHuffTblSelAc_Ta;\r\n\t\t// Max range of components indices is between 1..4\r\n\t\tfor (unsigned int nScanCompInd=1;((nScanCompInd<=m_nSosNumCompScan_Ns) && (!m_bStateAbort));nScanCompInd++)\r\n\t\t{\r\n\t\t\tstrFull.Format(_T(\"    Component[%u]: \"),nScanCompInd);\r\n\t\t\tnSosCompSel_Cs = Buf(m_nPos++);\t// Cs, range 0..255\r\n\t\t\tnSosHuffTblSel = Buf(m_nPos++);\r\n\t\t\tnSosHuffTblSelDc_Td = (nSosHuffTblSel & 0xf0)>>4;\t// Td, range 0..3\r\n\t\t\tnSosHuffTblSelAc_Ta = (nSosHuffTblSel & 0x0f);\t\t// Ta, range 0..3\r\n\t\t\tstrTmp.Format(_T(\"selector=0x%02X, table=%u(DC),%u(AC)\"),nSosCompSel_Cs,nSosHuffTblSelDc_Td,nSosHuffTblSelAc_Ta);\r\n\t\t\tstrFull += strTmp;\r\n\t\t\tm_pLog->AddLine(strFull);\r\n\r\n\t\t\tbRet = m_pImgDec->SetDhtTables(nScanCompInd,nSosHuffTblSelDc_Td,nSosHuffTblSelAc_Ta);\r\n\r\n\t\t\tDecodeErrCheck(bRet);\r\n\t\t}\r\n\r\n\r\n\t\tm_nSosSpectralStart_Ss = Buf(m_nPos++);\r\n\t\tm_nSosSpectralEnd_Se = Buf(m_nPos++);\r\n\t\tm_nSosSuccApprox_A = Buf(m_nPos++);\r\n\r\n\t\tstrTmp.Format(_T(\"  Spectral selection = %u .. %u\"),m_nSosSpectralStart_Ss,m_nSosSpectralEnd_Se);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\t\tstrTmp.Format(_T(\"  Successive approximation = 0x%02X\"),m_nSosSuccApprox_A);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tif (m_pAppConfig->bOutputScanDump) {\r\n\t\t\tm_pLog->AddLine(_T(\"\"));\r\n\t\t\tm_pLog->AddLine(_T(\"  Scan Data: (after bitstuff removed)\"));\r\n\t\t}\r\n\r\n\t\t// Save the scan data segment position\r\n\t\tnPosScanStart = m_nPos;\r\n\r\n\t\t// Skip over the Scan Data segment\r\n\t\t//   Pass 1) Quick, allowing for bOutputScanDump to dump first 640B.\r\n\t\t//   Pass 2) If bDecodeScanImg, we redo the process but in detail decoding.\r\n\r\n\t\t// FIXME: Not sure why, but if I skip over Pass 1 (eg if I leave in the\r\n\t\t// following line uncommented), then I get an error at the end of the\r\n\t\t// pass 2 decode (indicating that EOI marker not seen, and expecting\r\n\t\t// marker).\r\n//\t\tif (m_pAppConfig->bOutputScanDump) {\r\n\r\n\t\t\t// --- PASS 1 ---\r\n\t\t\tbool\t\tbSkipDone;\r\n\t\t\tunsigned\tnSkipCount;\r\n\t\t\tunsigned\tnSkipData;\r\n\t\t\tunsigned\tnSkipPos;\r\n\t\t\tbool\t\tbScanDumpTrunc;\r\n\r\n\t\t\tbSkipDone = false;\r\n\t\t\tnSkipCount = 0;\r\n\t\t\tnSkipPos = 0;\r\n\t\t\tbScanDumpTrunc = FALSE;\r\n\r\n\t\t\tstrFull = _T(\"\");\r\n\t\t\twhile (!bSkipDone)\r\n\t\t\t{\r\n\t\t\t\tnSkipCount++;\r\n\t\t\t\tnSkipPos++;\r\n\t\t\t\tnSkipData = Buf(m_nPos++);\r\n\r\n\t\t\t\tif (nSkipData == 0xFF) {\r\n\t\t\t\t\t// this could either be a marker or a byte stuff\r\n\t\t\t\t\tnSkipData = Buf(m_nPos++);\r\n\t\t\t\t\tnSkipCount++;\r\n\t\t\t\t\tif (nSkipData == 0x00) {\r\n\t\t\t\t\t\t// Byte stuff\r\n\t\t\t\t\t\tnSkipData = 0xFF;\r\n\t\t\t\t\t} else if ((nSkipData >= JFIF_RST0) && (nSkipData <= JFIF_RST7)) {\r\n\t\t\t\t\t\t// Skip over\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// Marker\r\n\t\t\t\t\t\tbSkipDone = true;\r\n\t\t\t\t\t\tm_nPos -= 2;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (m_pAppConfig->bOutputScanDump && (!bSkipDone) ) {\r\n\t\t\t\t\t// Only display 20 lines of scan data\r\n\t\t\t\t\tif (nSkipPos > 640) {\r\n\t\t\t\t\t\tif (!bScanDumpTrunc) {\r\n\t\t\t\t\t\t\tm_pLog->AddLineWarn(_T(\"    WARNING: Dump truncated.\"));\r\n\t\t\t\t\t\t\tbScanDumpTrunc = TRUE;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif ( ((nSkipPos-1) == 0) || (((nSkipPos-1) % 32) == 0) ) {\r\n\t\t\t\t\t\t\tstrFull = _T(\"    \");\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tstrTmp.Format(_T(\"%02x \"),nSkipData);\r\n\t\t\t\t\t\tstrFull += strTmp;\r\n\r\n\t\t\t\t\t\tif (((nSkipPos-1) % 32) == 31) {\r\n\t\t\t\t\t\t\tm_pLog->AddLine(strFull);\r\n\t\t\t\t\t\t\tstrFull = _T(\"\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Did we run out of bytes?\r\n\r\n\t\t\t\t// FIXME:\r\n\t\t\t\t// NOTE: This line here doesn't allow us to attempt to \r\n\t\t\t\t// decode images that are missing EOI. Maybe this is\r\n\t\t\t\t// not the best solution here? Instead, we should be\r\n\t\t\t\t// checking m_nPos against file length? .. and not \r\n\t\t\t\t// return but \"break\".\r\n\t\t\t\tif (!m_pWBuf->GetBufOk()) {\r\n\t\t\t\t\tstrTmp.Format(_T(\"ERROR: Ran out of buffer before EOI during phase 1 of Scan decode @ 0x%08X\"),m_nPos);\r\n\t\t\t\t\tm_pLog->AddLineErr(strTmp);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\tm_pLog->AddLine(strFull);\r\n\r\n//\t\t}\r\n\r\n\t\t// --- PASS 2 ---\r\n\t\t// If the option is set, start parsing!\r\n\t\tif (m_pAppConfig->bDecodeScanImg && m_bImgSofUnsupported) {\r\n\t\t\t// SOF marker was of type we don't support, so skip decoding\r\n\t\t\tm_pLog->AddLineWarn(_T(\"  NOTE: Scan parsing doesn't support this SOF mode.\"));\r\n#ifndef DEBUG_YCCK\r\n\t\t} else if (m_pAppConfig->bDecodeScanImg && (m_nSofNumComps_Nf == 4)) {\r\n\t\t\tm_pLog->AddLineWarn(_T(\"  NOTE: Scan parsing doesn't support CMYK files yet.\"));\r\n#endif\r\n\t\t} else if (m_pAppConfig->bDecodeScanImg && !m_bImgSofUnsupported) {\r\n\t\t\tif (!m_bStateSofOk) {\r\n\t\t\t\tm_pLog->AddLineWarn(_T(\"  NOTE: Scan decode disabled as SOF not decoded.\"));\r\n\t\t\t} else if (!m_bStateDqtOk) {\r\n\t\t\t\tm_pLog->AddLineWarn(_T(\"  NOTE: Scan decode disabled as DQT not decoded.\"));\r\n\t\t\t} else if (!m_bStateDhtOk) {\r\n\t\t\t\tm_pLog->AddLineWarn(_T(\"  NOTE: Scan decode disabled as DHT not decoded.\"));\r\n\r\n\t\t\t} else {\r\n\t\t\t\tm_pLog->AddLine(_T(\"\"));\r\n\r\n\t\t\t\t// Set the primary image details\r\n\t\t\t\tm_pImgDec->SetImageDetails(m_nSofSampsPerLine_X,m_nSofNumLines_Y,\r\n\t\t\t\t\tm_nSofNumComps_Nf,m_nSosNumCompScan_Ns,m_nImgRstEn,m_nImgRstInterval);\r\n\r\n\t\t\t\t// Only recalculate the scan decoding if we need to (i.e. file\r\n\t\t\t\t// changed, offset changed, scan option changed)\r\n\t\t\t\t// TODO: In order to decode multiple scans, we will need to alter the\r\n\t\t\t\t// way that m_pImgSrcDirty is set\r\n\t\t\t\tif (m_pImgSrcDirty) {\r\n\t\t\t\t\tm_pImgDec->DecodeScanImg(nPosScanStart,true,false);\r\n\t\t\t\t\tm_pImgSrcDirty = false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tm_bStateSosOk = true;\r\n\r\n\t\tbreak;\r\n\r\n\tcase JFIF_DRI:\r\n\t\tunsigned\tnVal;\r\n\t\tnLength = Buf(m_nPos)*256 + Buf(m_nPos+1);\r\n\t\tstrTmp.Format(_T(\"  Length     = %u\"),nLength);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\t\tnVal = Buf(m_nPos+2)*256 + Buf(m_nPos+3);\r\n\r\n\t\t// According to ITU-T spec B.2.4.4, we only expect\r\n\t\t// restart markers if DRI value is non-zero!\r\n\t\tm_nImgRstInterval = nVal;\r\n\t\tif (nVal != 0) {\r\n\t\t\tm_nImgRstEn = true;\r\n\t\t} else {\r\n\t\t\tm_nImgRstEn = false;\r\n\t\t}\r\n\t\tstrTmp.Format(_T(\"  interval   = %u\"),m_nImgRstInterval);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\t\tm_nPos += 4;\r\n\t\tif (!ExpectMarkerEnd(nPosMarkerStart,nLength))\r\n\t\t\treturn DECMARK_ERR;\r\n\t\tbreak;\r\n\r\n\tcase JFIF_EOI: // EOI\r\n\t\tm_pLog->AddLine(_T(\"\"));\r\n\r\n\t\t// Save the EOI file position\r\n\t\t// NOTE: If the file is missing the EOI, then this variable will be\r\n\t\t//       set to mark the end of file.\r\n\t\tm_nPosEmbedEnd = m_nPos;\r\n\t\tm_nPosEoi = m_nPos;\r\n\t\tm_bStateEoi = true;\r\n\r\n\t\treturn DECMARK_EOI;\r\n\r\n\t\tbreak;\r\n\r\n\t// Markers that are not yet supported in JPEGsnoop\r\n\tcase JFIF_DHP:\r\n\t// Markers defined for future use / extensions\r\n\tcase JFIF_JPG:\r\n\tcase JFIF_JPG0:\r\n\tcase JFIF_JPG1:\r\n\tcase JFIF_JPG2:\r\n\tcase JFIF_JPG3:\r\n\tcase JFIF_JPG4:\r\n\tcase JFIF_JPG5:\r\n\tcase JFIF_JPG6:\r\n\tcase JFIF_JPG7:\r\n\tcase JFIF_JPG8:\r\n\tcase JFIF_JPG9:\r\n\tcase JFIF_JPG10:\r\n\tcase JFIF_JPG11:\r\n\tcase JFIF_JPG12:\r\n\tcase JFIF_JPG13:\r\n\tcase JFIF_TEM:\r\n\t\t// Unsupported marker\r\n\t\t// - Provide generic decode based on length\r\n\t\tnLength = Buf(m_nPos)*256 + Buf(m_nPos+1);\t// Length\r\n\t\tstrTmp.Format(_T(\"  Header length = %u\"),nLength);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\t\tm_pLog->AddLineWarn(_T(\"  Skipping unsupported marker\"));\r\n\t\tm_nPos += nLength;\r\n\t\tbreak;\r\n\r\n\tcase JFIF_RST0:\r\n\tcase JFIF_RST1:\r\n\tcase JFIF_RST2:\r\n\tcase JFIF_RST3:\r\n\tcase JFIF_RST4:\r\n\tcase JFIF_RST5:\r\n\tcase JFIF_RST6:\r\n\tcase JFIF_RST7:\r\n\t\t// We don't expect to see restart markers outside the entropy coded segment.\r\n\t\t// NOTE: RST# are standalone markers, so no length indicator exists\r\n\t\t// But for the sake of robustness, we can check here to see if treating\r\n\t\t// as a standalone marker will arrive at another marker (ie. OK). If not,\r\n\t\t// proceed to assume there is a length indicator.\r\n\t\tstrTmp.Format(_T(\"  WARNING: Restart marker [0xFF%02X] detected outside scan\"),nCode);\r\n\t\tm_pLog->AddLineWarn(strTmp);\r\n\t\tif (!m_pAppConfig->bRelaxedParsing) {\r\n\t\t\t// Abort\r\n\t\t\tm_pLog->AddLineErr(_T(\"  Stopping decode\"));\r\n\t\t\tm_pLog->AddLine(_T(\"  Use [Img Search Fwd/Rev] to locate other valid embedded JPEGs\"));\r\n\t\t\treturn DECMARK_ERR;\r\n\t\t} else {\r\n\t\t\t// Ignore\r\n\t\t\t// Check to see if standalone marker treatment looks OK\r\n\t\t\tif (Buf(m_nPos+2) == 0xFF) {\r\n\t\t\t\t// Looks like standalone\r\n\t\t\t\tm_pLog->AddLineWarn(_T(\"  Ignoring standalone marker. Proceeding with decode.\"));\r\n\t\t\t\tm_nPos += 2;\r\n\t\t\t} else {\r\n\t\t\t\t// Looks like marker with length\r\n\r\n\t\t\t\tnLength = Buf(m_nPos)*256 + Buf(m_nPos+1);\r\n\t\t\t\tstrTmp.Format(_T(\"  Header length = %u\"),nLength);\r\n\t\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t\t\tm_pLog->AddLineWarn(_T(\"  Skipping marker\"));\r\n\t\t\t\tm_nPos += nLength;\r\n\t\t\t}\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tdefault:\r\n\t\tstrTmp.Format(_T(\"  WARNING: Unknown marker [0xFF%02X]\"),nCode);\r\n\t\tm_pLog->AddLineWarn(strTmp);\r\n\t\tif (!m_pAppConfig->bRelaxedParsing) {\r\n\t\t\t// Abort\r\n\t\t\tm_pLog->AddLineErr(_T(\"  Stopping decode\"));\r\n\t\t\tm_pLog->AddLine(_T(\"  Use [Img Search Fwd/Rev] to locate other valid embedded JPEGs\"));\r\n\t\t\treturn DECMARK_ERR;\r\n\t\t} else {\r\n\t\t\t// Skip\r\n\t\t\tnLength = Buf(m_nPos)*256 + Buf(m_nPos+1);\r\n\t\t\tstrTmp.Format(_T(\"  Header length = %u\"),nLength);\r\n\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t\tm_pLog->AddLineWarn(_T(\"  Skipping marker\"));\r\n\t\t\tm_nPos += nLength;\r\n\t\t}\r\n\t}\r\n\r\n\t// Add white-space between each marker\r\n\tm_pLog->AddLine(_T(\" \"));\r\n\r\n\t// If we decided to abort for any reason, make sure we trap it now.\r\n\t// This will stop the ProcessFile() while loop. We can set m_bStateAbort\r\n\t// if user says that they want to stop.\r\n\tif (m_bStateAbort) {\r\n\t\treturn DECMARK_ERR;\r\n\t}\r\n\r\n\treturn DECMARK_OK;\r\n}\r\n\r\n\r\n// Print out a header for the current JFIF marker code\r\nvoid CjfifDecode::AddHeader(unsigned nCode)\r\n{\r\n\tCString strTmp;\r\n\r\n\tswitch(nCode)\r\n\t{\r\n\tcase JFIF_SOI: m_pLog->AddLineHdr(_T(\"*** Marker: SOI (xFFD8) ***\")); break;\r\n\r\n\tcase JFIF_APP0: m_pLog->AddLineHdr(_T(\"*** Marker: APP0 (xFFE0) ***\")); break;\r\n\tcase JFIF_APP1: m_pLog->AddLineHdr(_T(\"*** Marker: APP1 (xFFE1) ***\")); break;\r\n\tcase JFIF_APP2: m_pLog->AddLineHdr(_T(\"*** Marker: APP2 (xFFE2) ***\")); break;\r\n\tcase JFIF_APP3: m_pLog->AddLineHdr(_T(\"*** Marker: APP3 (xFFE3) ***\")); break;\r\n\tcase JFIF_APP4: m_pLog->AddLineHdr(_T(\"*** Marker: APP4 (xFFE4) ***\")); break;\r\n\tcase JFIF_APP5: m_pLog->AddLineHdr(_T(\"*** Marker: APP5 (xFFE5) ***\")); break;\r\n\tcase JFIF_APP6: m_pLog->AddLineHdr(_T(\"*** Marker: APP6 (xFFE6) ***\")); break;\r\n\tcase JFIF_APP7: m_pLog->AddLineHdr(_T(\"*** Marker: APP7 (xFFE7) ***\")); break;\r\n\tcase JFIF_APP8: m_pLog->AddLineHdr(_T(\"*** Marker: APP8 (xFFE8) ***\")); break;\r\n\tcase JFIF_APP9: m_pLog->AddLineHdr(_T(\"*** Marker: APP9 (xFFE9) ***\")); break;\r\n\tcase JFIF_APP10: m_pLog->AddLineHdr(_T(\"*** Marker: APP10 (xFFEA) ***\")); break;\r\n\tcase JFIF_APP11: m_pLog->AddLineHdr(_T(\"*** Marker: APP11 (xFFEB) ***\")); break;\r\n\tcase JFIF_APP12: m_pLog->AddLineHdr(_T(\"*** Marker: APP12 (xFFEC) ***\")); break;\r\n\tcase JFIF_APP13: m_pLog->AddLineHdr(_T(\"*** Marker: APP13 (xFFED) ***\")); break;\r\n\tcase JFIF_APP14: m_pLog->AddLineHdr(_T(\"*** Marker: APP14 (xFFEE) ***\")); break;\r\n\tcase JFIF_APP15: m_pLog->AddLineHdr(_T(\"*** Marker: APP15 (xFFEF) ***\")); break;\r\n\r\n\tcase JFIF_SOF0:  m_pLog->AddLineHdr(_T(\"*** Marker: SOF0 (Baseline DCT) (xFFC0) ***\")); break;\r\n\tcase JFIF_SOF1:  m_pLog->AddLineHdr(_T(\"*** Marker: SOF1 (Extended Sequential DCT, Huffman) (xFFC1) ***\")); break;\r\n\tcase JFIF_SOF2:  m_pLog->AddLineHdr(_T(\"*** Marker: SOF2 (Progressive DCT, Huffman) (xFFC2) ***\")); break;\r\n\tcase JFIF_SOF3:  m_pLog->AddLineHdr(_T(\"*** Marker: SOF3 (Lossless Process, Huffman) (xFFC3) ***\")); break;\r\n\tcase JFIF_SOF5:  m_pLog->AddLineHdr(_T(\"*** Marker: SOF5 (Differential Sequential DCT, Huffman) (xFFC4) ***\")); break;\r\n\tcase JFIF_SOF6:  m_pLog->AddLineHdr(_T(\"*** Marker: SOF6 (Differential Progressive DCT, Huffman) (xFFC5) ***\")); break;\r\n\tcase JFIF_SOF7:  m_pLog->AddLineHdr(_T(\"*** Marker: SOF7 (Differential Lossless Process, Huffman) (xFFC6) ***\")); break;\r\n\tcase JFIF_SOF9:  m_pLog->AddLineHdr(_T(\"*** Marker: SOF9 (Sequential DCT, Arithmetic) (xFFC9) ***\")); break;\r\n\tcase JFIF_SOF10: m_pLog->AddLineHdr(_T(\"*** Marker: SOF10 (Progressive DCT, Arithmetic) (xFFCA) ***\")); break;\r\n\tcase JFIF_SOF11: m_pLog->AddLineHdr(_T(\"*** Marker: SOF11 (Lossless Process, Arithmetic) (xFFCB) ***\")); break;\r\n\tcase JFIF_SOF13: m_pLog->AddLineHdr(_T(\"*** Marker: SOF13 (Differential Sequential, Arithmetic) (xFFCD) ***\")); break;\r\n\tcase JFIF_SOF14: m_pLog->AddLineHdr(_T(\"*** Marker: SOF14 (Differential Progressive DCT, Arithmetic) (xFFCE) ***\")); break;\r\n\tcase JFIF_SOF15: m_pLog->AddLineHdr(_T(\"*** Marker: SOF15 (Differential Lossless Process, Arithmetic) (xFFCF) ***\")); break;\r\n\r\n\tcase JFIF_JPG:   m_pLog->AddLineHdr(_T(\"*** Marker: JPG (xFFC8) ***\")); break;\r\n\tcase JFIF_DAC:   m_pLog->AddLineHdr(_T(\"*** Marker: DAC (xFFCC) ***\")); break;\r\n\r\n\tcase JFIF_RST0:\r\n\tcase JFIF_RST1:\r\n\tcase JFIF_RST2:\r\n\tcase JFIF_RST3:\r\n\tcase JFIF_RST4:\r\n\tcase JFIF_RST5:\r\n\tcase JFIF_RST6:\r\n\tcase JFIF_RST7:\r\n\t\tm_pLog->AddLineHdr(_T(\"*** Marker: RST# ***\"));\r\n\t\tbreak;\r\n\r\n\tcase JFIF_DQT:  // Define quantization tables\r\n\t\tm_pLog->AddLineHdr(_T(\"*** Marker: DQT (xFFDB) ***\"));\r\n\t\tm_pLog->AddLineHdrDesc(_T(\"  Define a Quantization Table.\"));\r\n\t\tbreak;\r\n\r\n\r\n\tcase JFIF_COM: // COM\r\n\t\tm_pLog->AddLineHdr(_T(\"*** Marker: COM (Comment) (xFFFE) ***\"));\r\n\t\tbreak;\r\n\r\n\tcase JFIF_DHT: // DHT\r\n\t\tm_pLog->AddLineHdr(_T(\"*** Marker: DHT (Define Huffman Table) (xFFC4) ***\"));\r\n\t\tbreak;\r\n\tcase JFIF_DHT_FAKE: // DHT from standard table (MotionJPEG)\r\n\t\tm_pLog->AddLineHdr(_T(\"*** Marker: DHT from MotionJPEG standard (Define Huffman Table) ***\"));\r\n\t\tbreak;\r\n\r\n\tcase JFIF_SOS: // SOS\r\n\t\tm_pLog->AddLineHdr(_T(\"*** Marker: SOS (Start of Scan) (xFFDA) ***\"));\r\n\t\tbreak;\r\n\r\n\tcase JFIF_DRI: // DRI\r\n\t\tm_pLog->AddLineHdr(_T(\"*** Marker: DRI (Restart Interval) (xFFDD) ***\"));\r\n\t\tbreak;\r\n\r\n\tcase JFIF_EOI: // EOI\r\n\t\tm_pLog->AddLineHdr(_T(\"*** Marker: EOI (End of Image) (xFFD9) ***\"));\r\n\t\tbreak;\r\n\r\n\tcase JFIF_DNL:   m_pLog->AddLineHdr(_T(\"*** Marker: DNL (Define Number of Lines) (xFFDC) ***\")); break;\r\n\tcase JFIF_DHP:   m_pLog->AddLineHdr(_T(\"*** Marker: DHP (Define Hierarchical Progression) (xFFDE) ***\")); break;\r\n\tcase JFIF_EXP:   m_pLog->AddLineHdr(_T(\"*** Marker: EXP (Expand Reference Components) (xFFDF) ***\")); break;\r\n\tcase JFIF_JPG0:  m_pLog->AddLineHdr(_T(\"*** Marker: JPG0 (JPEG Extension) (xFFF0) ***\")); break;\r\n\tcase JFIF_JPG1:  m_pLog->AddLineHdr(_T(\"*** Marker: JPG1 (JPEG Extension) (xFFF1) ***\")); break;\r\n\tcase JFIF_JPG2:  m_pLog->AddLineHdr(_T(\"*** Marker: JPG2 (JPEG Extension) (xFFF2) ***\")); break;\r\n\tcase JFIF_JPG3:  m_pLog->AddLineHdr(_T(\"*** Marker: JPG3 (JPEG Extension) (xFFF3) ***\")); break;\r\n\tcase JFIF_JPG4:  m_pLog->AddLineHdr(_T(\"*** Marker: JPG4 (JPEG Extension) (xFFF4) ***\")); break;\r\n\tcase JFIF_JPG5:  m_pLog->AddLineHdr(_T(\"*** Marker: JPG5 (JPEG Extension) (xFFF5) ***\")); break;\r\n\tcase JFIF_JPG6:  m_pLog->AddLineHdr(_T(\"*** Marker: JPG6 (JPEG Extension) (xFFF6) ***\")); break;\r\n\tcase JFIF_JPG7:  m_pLog->AddLineHdr(_T(\"*** Marker: JPG7 (JPEG Extension) (xFFF7) ***\")); break;\r\n\tcase JFIF_JPG8:  m_pLog->AddLineHdr(_T(\"*** Marker: JPG8 (JPEG Extension) (xFFF8) ***\")); break;\r\n\tcase JFIF_JPG9:  m_pLog->AddLineHdr(_T(\"*** Marker: JPG9 (JPEG Extension) (xFFF9) ***\")); break;\r\n\tcase JFIF_JPG10: m_pLog->AddLineHdr(_T(\"*** Marker: JPG10 (JPEG Extension) (xFFFA) ***\")); break;\r\n\tcase JFIF_JPG11: m_pLog->AddLineHdr(_T(\"*** Marker: JPG11 (JPEG Extension) (xFFFB) ***\")); break;\r\n\tcase JFIF_JPG12: m_pLog->AddLineHdr(_T(\"*** Marker: JPG12 (JPEG Extension) (xFFFC) ***\")); break;\r\n\tcase JFIF_JPG13: m_pLog->AddLineHdr(_T(\"*** Marker: JPG13 (JPEG Extension) (xFFFD) ***\")); break;\r\n\tcase JFIF_TEM:   m_pLog->AddLineHdr(_T(\"*** Marker: TEM (Temporary) (xFF01) ***\")); break;\r\n\r\n\r\n\r\n\tdefault:\r\n\t\tstrTmp.Format(_T(\"*** Marker: ??? (Unknown) (xFF%02X) ***\"),nCode);\r\n\t\tm_pLog->AddLineHdr(strTmp);\r\n\t\tbreak;\r\n\t}\r\n\t// Adjust position to account for the word used in decoding the marker!\r\n\tstrTmp.Format(_T(\"  OFFSET: 0x%08X\"),m_nPos-2);\r\n\tm_pLog->AddLine(strTmp);\r\n}\r\n\r\n\r\n// Update the status bar with a message\r\nvoid CjfifDecode::SetStatusText(CString strText)\r\n{\r\n\t// Make sure that we have been connected to the status\r\n\t// bar of the main window first! Note that it is jpegsnoopDoc\r\n\t// that sets this variable.\r\n\tif (m_pStatBar) {\r\n\t\tm_pStatBar->SetPaneText(0,strText);\r\n\t}\r\n}\r\n\r\n// Generate a special output form of the current image's\r\n// compression signature and other characteristics. This is only\r\n// used during development and batch import to build the MySQL repository.\r\nvoid CjfifDecode::OutputSpecial()\r\n{\r\n\tCString strTmp;\r\n\tCString strFull;\r\n\r\n\tASSERT(m_eImgLandscape!=ENUM_LANDSCAPE_UNSET);\r\n\r\n\t// This mode of operation is currently only used\r\n\t// to import the local signature database into a MySQL database\r\n\t// backend. It simply reports the MySQL commands which can be input\r\n\t// into a MySQL client application.\r\n\tif (m_bOutputDB)\r\n\t{\r\n\t\tm_pLog->AddLine(_T(\"*** DB OUTPUT START ***\"));\r\n\t\tm_pLog->AddLine(_T(\"INSERT INTO `quant` (`key`, `make`, `model`, \"));\r\n\t\tm_pLog->AddLine(_T(\"`qual`, `subsamp`, `lum_00`, `lum_01`, `lum_02`, `lum_03`, `lum_04`, \"));\r\n\t\tm_pLog->AddLine(_T(\"`lum_05`, `lum_06`, `lum_07`, `chr_00`, `chr_01`, `chr_02`, \"));\r\n\t\tm_pLog->AddLine(_T(\"`chr_03`, `chr_04`, `chr_05`, `chr_06`, `chr_07`, `qual_lum`, `qual_chr`) VALUES (\"));\r\n\r\n\t\tstrFull = _T(\"'*KEY*', \"); // key -- need to override\r\n\r\n\t\t// Might need to change m_strImgExifMake to be lowercase\r\n\t\tstrTmp.Format(_T(\"'%s', \"),(LPCTSTR)m_strImgExifMake);\r\n\t\tstrFull += strTmp; // make\r\n\r\n\t\tstrTmp.Format(_T(\"'%s', \"),(LPCTSTR)m_strImgExifModel);\r\n\t\tstrFull += strTmp; // model\r\n\r\n\t\tstrTmp.Format(_T(\"'%s', \"),(LPCTSTR)m_strImgQualExif);\r\n\t\tstrFull += strTmp; // quality\r\n\r\n\t\tstrTmp.Format(_T(\"'%s', \"),(LPCTSTR)m_strImgQuantCss);\r\n\t\tstrFull += strTmp; // subsampling\r\n\r\n\t\tm_pLog->AddLine(strFull);\r\n\r\n\t\t// Step through both quantization tables (0=lum,1=chr)\r\n\t\tunsigned nMatrixInd;\r\n\r\n\t\tfor (unsigned nDqtInd=0;nDqtInd<2;nDqtInd++) {\r\n\r\n\t\t\tstrFull = _T(\"\");\r\n\t\t\tfor (unsigned nY=0;nY<8;nY++) {\r\n\t\t\t\tstrFull += _T(\"'\");\r\n\t\t\t\tfor (unsigned nX=0;nX<8;nX++) {\r\n\t\t\t\t\t// Rotate the matrix if necessary!\r\n\t\t\t\t\tnMatrixInd = (m_eImgLandscape!=ENUM_LANDSCAPE_NO)?(nY*8+nX):(nX*8+nY);\r\n\t\t\t\t\tstrTmp.Format(_T(\"%u\"),m_anImgDqtTbl[nDqtInd][nMatrixInd]);\r\n\t\t\t\t\tstrFull += strTmp;\r\n\t\t\t\t\tif (nX!=7) { strFull += _T(\",\"); }\r\n\t\t\t\t}\r\n\t\t\t\tstrFull += _T(\"', \");\r\n\t\t\t\tif (nY==3) {\r\n\t\t\t\t\tm_pLog->AddLine(strFull);\r\n\t\t\t\t\tstrFull = _T(\"\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tm_pLog->AddLine(strFull);\r\n\r\n\t\t}\r\n\r\n\t\tstrFull = _T(\"\");\r\n\t\t// Output quality ratings\r\n\t\tstrTmp.Format(_T(\"'%f', \"),m_adImgDqtQual[0]);\r\n\t\tstrFull += strTmp;\r\n\t\t// Don't put out comma separator on last line!\r\n\t\tstrTmp.Format(_T(\"'%f'\"),m_adImgDqtQual[1]);\r\n\t\tstrFull += strTmp;\r\n\t\tstrFull += _T(\");\");\r\n\t\tm_pLog->AddLine(strFull);\r\n\r\n\t\tm_pLog->AddLine(_T(\"*** DB OUTPUT END ***\"));\r\n\t}\r\n\r\n}\r\n\r\n// Generate the compression signatures (both unrotated and\r\n// rotated) in advance of submitting to the database.\r\nvoid CjfifDecode::PrepareSignature()\r\n{\r\n\t// Set m_strHash\r\n\tPrepareSignatureSingle(false);\r\n\t// Set m_strHashRot\r\n\tPrepareSignatureSingle(true);\r\n}\r\n\r\n// Prepare the image signature for later submission\r\n// NOTE: ASCII vars are used (instead of unicode) to support usage of MD5 library\r\nvoid CjfifDecode::PrepareSignatureSingle(bool bRotate)\r\n{\r\n\tCStringA\t\t\tstrTmp;\r\n\tCStringA\t\t\tstrSet;\r\n\r\n\tCStringA\t\t\tstrHashIn;\r\n\tunsigned char\t\tpHashIn[2000];\r\n\tCStringA\t\t\tstrDqt;\r\n\tMD5_CTX\t\t\t\tsMd5;\r\n\tunsigned\t\t\tnLenHashIn;\r\n\tunsigned\t\t\tnInd;\r\n\r\n\tASSERT(m_eImgLandscape!=ENUM_LANDSCAPE_UNSET);\r\n\r\n\t// -----------------------------------------------------------\r\n\t// Calculate the MD5 hash for online/internal database!\r\n\t// signature \"00\" : DQT0,DQT1,CSS\r\n\t// signature \"01\" : salt,DQT0,DQT1,..DQTx(if defined)\r\n\r\n\r\n\t// Build the source string\r\n\t// NOTE: For the purposes of the hash, we need to rotate the DQT tables\r\n\t// if we detect that the photo is in portrait orientation! This keeps everything\r\n\t// consistent.\r\n\r\n\r\n\t// If no DQT tables have been defined (e.g. could have loaded text file!)\r\n\t// then override the sig generation!\r\n\tbool bDqtDefined = false;\r\n\tfor (unsigned nSet=0;nSet<4;nSet++) {\r\n\t\tif (m_abImgDqtSet[nSet]) {\r\n\t\t\tbDqtDefined = true;\r\n\t\t}\r\n\t}\r\n\tif (!bDqtDefined) {\r\n\t\tm_strHash = _T(\"NONE\");\r\n\t\tm_strHashRot = _T(\"NONE\");\r\n\t\treturn;\r\n\t}\r\n\r\n\t// NOTE:\r\n\t// The following MD5 code depends on an ASCII string for input\r\n\t// We are therefore using CStringA for the hash input instead\r\n\t// of the generic text functions. No special (non-ASCII)\r\n\t// characters are expected in this string.\r\n\r\n\tif (DB_SIG_VER == 0x00) {\r\n\t\tstrHashIn = \"\";\r\n\t} else {\r\n\t\tstrHashIn = \"JPEGsnoop\";\r\n\t}\r\n\r\n\t// Need to duplicate DQT0 if we only have one DQT table\r\n\tfor (unsigned nSet=0;nSet<4;nSet++) {\r\n\t\tif (m_abImgDqtSet[nSet]) {\r\n\t\t\tstrSet = \"\";\r\n\t\t\tstrSet.Format(\"*DQT%u,\",nSet);\r\n\t\t\tstrHashIn += strSet;\r\n\t\t\tfor (unsigned i=0;i<64;i++) {\r\n\t\t\t\tnInd = (!bRotate)?i:glb_anQuantRotate[i];\r\n\t\t\t\tstrTmp.Format(\"%03u,\",m_anImgDqtTbl[nSet][nInd]);\r\n\t\t\t\tstrHashIn += strTmp;\r\n\t\t\t}\r\n\t\t} // if DQTx defined\r\n\t} // loop through sets (DQT0..DQT3)\r\n\r\n\t// Removed CSS from signature after version 0x00\r\n\tif (DB_SIG_VER == 0x00) {\r\n\t\tstrHashIn += \"*CSS,\";\r\n\t\tstrHashIn += m_strImgQuantCss;\r\n\t\tstrHashIn += \",\";\r\n\t}\r\n\tstrHashIn += \"*END\";\r\n\tnLenHashIn = strlen(strHashIn);\r\n\r\n\t// Display hash input\r\n\tfor (unsigned i=0;i<nLenHashIn;i+=80) {\r\n\t\tstrTmp = \"\";\r\n\t\tstrTmp.Format(\"In%u: [\",i/80);\r\n\t\tstrTmp += strHashIn.Mid(i,80);\r\n\t\tstrTmp += \"]\";\r\n#ifdef DEBUG_SIG\r\n\t\tm_pLog->AddLine(strTmp);\r\n#endif\r\n\t}\r\n\r\n\t// Copy into buffer\r\n\tASSERT(nLenHashIn < 2000);\r\n\tfor (unsigned i=0;i<nLenHashIn;i++) {\r\n\t\tpHashIn[i] = strHashIn.GetAt(i);\r\n\t}\r\n\t\r\n\r\n\t// Calculate the hash\r\n\tMD5Init(&sMd5, 0);\r\n\tMD5Update(&sMd5, pHashIn, nLenHashIn);\r\n\tMD5Final(&sMd5);\r\n\r\n\t// Overwrite top 8 bits for signature version number\r\n\tsMd5.digest32[0] = (sMd5.digest32[0] & 0x00FFFFFF) + (DB_SIG_VER << 24);\r\n\r\n\t// Convert hash to string format\r\n\t// The hexadecimal string is converted to Unicode (if that is build directive)\r\n\tif (!bRotate) {\r\n\t\tm_strHash.Format(_T(\"%08X%08X%08X%08X\"),sMd5.digest32[0],sMd5.digest32[1],sMd5.digest32[2],sMd5.digest32[3]);\r\n\t} else {\r\n\t\tm_strHashRot.Format(_T(\"%08X%08X%08X%08X\"),sMd5.digest32[0],sMd5.digest32[1],sMd5.digest32[2],sMd5.digest32[3]);\r\n\t}\r\n\r\n}\r\n\r\n// Generate the compression signatures for the thumbnails\r\nvoid CjfifDecode::PrepareSignatureThumb()\r\n{\r\n\t// Generate m_strHashThumb\r\n\tPrepareSignatureThumbSingle(false);\r\n\t// Generate m_strHashThumbRot\r\n\tPrepareSignatureThumbSingle(true);\r\n}\r\n\r\n// Prepare the image signature for later submission\r\n// NOTE: ASCII vars are used (instead of unicode) to support usage of MD5 library\r\nvoid CjfifDecode::PrepareSignatureThumbSingle(bool bRotate)\r\n{\r\n\tCStringA\t\t\tstrTmp;\r\n\tCStringA\t\t\tstrSet;\r\n\r\n\tCStringA\t\t\tstrHashIn;\r\n\tunsigned char\t\tpHashIn[2000];\r\n\tCStringA\t\t\tstrDqt;\r\n\tMD5_CTX\t\t\t\tsMd5;\r\n\tunsigned\t\t\tnLenHashIn;\r\n\tunsigned\t\t\tnInd;\r\n\r\n\t// -----------------------------------------------------------\r\n\t// Calculate the MD5 hash for online/internal database!\r\n\t// signature \"00\" : DQT0,DQT1,CSS\r\n\t// signature \"01\" : salt,DQT0,DQT1\r\n\r\n\r\n\t// Build the source string\r\n\t// NOTE: For the purposes of the hash, we need to rotate the DQT tables\r\n\t// if we detect that the photo is in portrait orientation! This keeps everything\r\n\t// consistent.\r\n\r\n\t// If no DQT tables have been defined (e.g. could have loaded text file!)\r\n\t// then override the sig generation!\r\n\tbool bDqtDefined = false;\r\n\tfor (unsigned nSet=0;nSet<4;nSet++) {\r\n\t\tif (m_abImgDqtThumbSet[nSet]) {\r\n\t\t\tbDqtDefined = true;\r\n\t\t}\r\n\t}\r\n\tif (!bDqtDefined) {\r\n\t\tm_strHashThumb = _T(\"NONE\");\r\n\t\tm_strHashThumbRot = _T(\"NONE\");\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (DB_SIG_VER == 0x00) {\r\n\t\tstrHashIn = _T(\"\");\r\n\t} else {\r\n\t\tstrHashIn = _T(\"JPEGsnoop\");\r\n\t}\r\n\r\n\t//tblSelY = m_anSofQuantTblSel_Tqi[0]; // Y\r\n\t//tblSelC = m_anSofQuantTblSel_Tqi[1]; // Cb (should be same as for Cr)\r\n\r\n\t// Need to duplicate DQT0 if we only have one DQT table\r\n\r\n\tfor (unsigned nSet=0;nSet<4;nSet++) {\r\n\t\tif (m_abImgDqtThumbSet[nSet]) {\r\n\t\t\tstrSet = \"\";\r\n\t\t\tstrSet.Format(\"*DQT%u,\",nSet);\r\n\t\t\tstrHashIn += strSet;\r\n\t\t\tfor (unsigned i=0;i<64;i++) {\r\n\t\t\t\tnInd = (!bRotate)?i:glb_anQuantRotate[i];\r\n\t\t\t\tstrTmp.Format(\"%03u,\",m_anImgThumbDqt[nSet][nInd]);\r\n\t\t\t\tstrHashIn += strTmp;\r\n\t\t\t}\r\n\t\t} // if DQTx defined\r\n\t} // loop through sets (DQT0..DQT3)\r\n\r\n\t// Removed CSS from signature after version 0x00\r\n\tif (DB_SIG_VER == 0x00) {\r\n\t\tstrHashIn += \"*CSS,\";\r\n\t\tstrHashIn += m_strImgQuantCss;\r\n\t\tstrHashIn += \",\";\r\n\t}\r\n\tstrHashIn += \"*END\";\r\n\tnLenHashIn = strlen(strHashIn);\r\n\r\n\t// Display hash input\r\n\tfor (unsigned i=0;i<nLenHashIn;i+=80) {\r\n\t\tstrTmp = \"\";\r\n\t\tstrTmp.Format(\"In%u: [\",i/80);\r\n\t\tstrTmp += strHashIn.Mid(i,80);\r\n\t\tstrTmp += \"]\";\r\n#ifdef DEBUG_SIG\r\n\t\tm_pLog->AddLine(strTmp);\r\n#endif\r\n\t}\r\n\r\n\t// Copy into buffer\r\n\tASSERT(nLenHashIn < 2000);\r\n\tfor (unsigned i=0;i<nLenHashIn;i++) {\r\n\t\tpHashIn[i] = strHashIn.GetAt(i);\r\n\t}\r\n\r\n\t// Calculate the hash\r\n\tMD5Init(&sMd5, 0);\r\n\tMD5Update(&sMd5, pHashIn, nLenHashIn);\r\n\tMD5Final(&sMd5);\r\n\r\n\t// Overwrite top 8 bits for signature version number\r\n\tsMd5.digest32[0] = (sMd5.digest32[0] & 0x00FFFFFF) + (DB_SIG_VER << 24);\r\n\r\n\t// Convert hash to string format\r\n\tif (!bRotate) {\r\n\t\tm_strHashThumb.Format(_T(\"%08X%08X%08X%08X\"),sMd5.digest32[0],sMd5.digest32[1],sMd5.digest32[2],sMd5.digest32[3]);\r\n\t} else {\r\n\t\tm_strHashThumbRot.Format(_T(\"%08X%08X%08X%08X\"),sMd5.digest32[0],sMd5.digest32[1],sMd5.digest32[2],sMd5.digest32[3]);\r\n\t}\r\n\r\n}\r\n\r\n\r\n// Compare the image compression signature & metadata against the database.\r\n// This is the routine that is also responsible for creating an\r\n// \"Image Assessment\" -- ie. whether the image may have been edited or not.\r\n//\r\n// PRE: m_strHash signature has already been calculated by PrepareSignature()\r\nbool CjfifDecode::CompareSignature(bool bQuiet=false)\r\n{\r\n\tCString strTmp;\r\n\tCString strHashOut;\r\n\tCString locationStr;\r\n\r\n\tunsigned ind;\r\n\r\n\tbool\tbCurXsw = false;\r\n\tbool\tbCurXmm = false;\r\n\tbool\tbCurXmkr = false;\r\n\tbool\tbCurXextrasw = false;\t// EXIF Extra fields match software indicator\r\n\tbool\tbCurXcomsw = false;\t\t// EXIF COM field match software indicator\r\n\tbool\tbCurXps = false;\t\t// EXIF photoshop IRB present\r\n\tbool\tbSrchXsw = false;\r\n\tbool\tbSrchXswUsig = false;\r\n\tbool\tbSrchXmmUsig = false;\r\n\tbool\tbSrchUsig = false;\r\n\tbool\tbMatchIjg = false;\r\n\tCString\tsMatchIjgQual = _T(\"\");\r\n\r\n\tASSERT(m_strHash != _T(\"NONE\"));\r\n\tASSERT(m_strHashRot != _T(\"NONE\"));\r\n\r\n\tif (bQuiet) { m_pLog->Disable(); }\r\n\r\n\r\n\tm_pLog->AddLine(_T(\"\"));\r\n\tm_pLog->AddLineHdr(_T(\"*** Searching Compression Signatures ***\"));\r\n\tm_pLog->AddLine(_T(\"\"));\r\n\r\n\t// Output the hash\r\n\tstrHashOut = _T(\"  Signature:           \");\r\n\tstrHashOut += m_strHash;\r\n\tm_pLog->AddLine(strHashOut);\r\n\tstrHashOut = _T(\"  Signature (Rotated): \");\r\n\tstrHashOut += m_strHashRot;\r\n\tm_pLog->AddLine(strHashOut);\r\n\r\n\tstrTmp.Format(_T(\"  File Offset:         %lu bytes\"),m_pAppConfig->nPosStart);\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\t// Output the CSS\r\n\tstrTmp.Format(_T(\"  Chroma subsampling:  %s\"),(LPCTSTR)m_strImgQuantCss);\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\r\n\t// Calculate the final fields\r\n\t// Add Photoshop IRB entries\r\n\t// Note that we always add an entry to the m_strImgExtras even if\r\n\t// there are no photoshop tags detected. It will appear as \"[PS]:[0/0]\"\r\n\tstrTmp = _T(\"\");\r\n\tstrTmp.Format(_T(\"[PS]:[%u/%u],\"),m_nImgQualPhotoshopSa,m_nImgQualPhotoshopSfw);\r\n\tm_strImgExtras += strTmp;\r\n\r\n\r\n\t// --------------------------------------\r\n\t// Determine current entry fields\r\n\r\n\t// Note that some cameras/phones have an empty Make, but use the Model! (eg. Palm Treo)\r\n\tif ((m_strImgExifMake == _T(\"???\")) && (m_strImgExifModel == _T(\"???\"))) {\r\n\t\tm_pLog->AddLine(_T(\"  EXIF Make/Model:     NONE\"));\r\n\t\tbCurXmm = false;\r\n\t} else {\r\n\t\tstrTmp.Format(_T(\"  EXIF Make/Model:     OK   [%s] [%s]\"),(LPCTSTR)m_strImgExifMake,(LPCTSTR)m_strImgExifModel);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\t\tbCurXmm = true;\r\n\t}\r\n\r\n\tif (m_bImgExifMakernotes) {\r\n\t\tm_pLog->AddLine(_T(\"  EXIF Makernotes:     OK  \"));\r\n\t\tbCurXmkr = true;\r\n\t} else {\r\n\t\tm_pLog->AddLine(_T(\"  EXIF Makernotes:     NONE\"));\r\n\t\tbCurXmkr = false;\r\n\t}\r\n\r\n\tif (_tcslen(m_strSoftware) == 0) {\r\n\t\tm_pLog->AddLine(_T(\"  EXIF Software:       NONE\"));\r\n\t\tbCurXsw = false;\r\n\t} else {\r\n\t\tstrTmp.Format(_T(\"  EXIF Software:       OK   [%s]\"),(LPCTSTR)m_strSoftware);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t// EXIF software field is non-empty\r\n\t\tbCurXsw = true;\r\n\t}\r\n\r\n\tm_pLog->AddLine(_T(\"\"));\r\n\r\n\t// --------------------------------------\r\n\t// Determine search results\r\n\r\n\r\n\t// All of the rest of the search results require searching\r\n\t// through the database entries\r\n\r\n\tbSrchXswUsig = false;\r\n\tbSrchXmmUsig = false;\r\n\tbSrchUsig = false;\r\n\tbMatchIjg = false;\r\n\tsMatchIjgQual = _T(\"\");\r\n\r\n\tunsigned nSigsInternal = theApp.m_pDbSigs->GetNumSigsInternal();\r\n\tunsigned nSigsExtra = theApp.m_pDbSigs->GetNumSigsExtra();\r\n\r\n\tstrTmp.Format(_T(\"  Searching Compression Signatures: (%u built-in, %u user(*) )\"),nSigsInternal,nSigsExtra);\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\r\n\t// Now in SIG version 0x01 and later, we are not including\r\n\t// the CSS in the signature. Therefore, we need to compare it\r\n\t// manually.\r\n\r\n\tbool curMatchMm;\r\n\tbool curMatchSw;\r\n\tbool curMatchSig;\r\n\tbool curMatchSigCss;\r\n\r\n\r\n\t// Check on Extras field\r\n\t// Noted that Canon EOS Viewer Utility (EVU) seems to convert RAWs with\r\n\t// the only identifying information being this:\r\n\t//  e.g. \"[Canon.ImageType]:[CRW:EOS 300D DIGITAL CMOS RAW],_T(\"\r\n\tif (m_strImgExtras.Find(_T(\")[Canon.ImageType]:[CRW:\")) != -1) {\r\n\t\tbCurXextrasw = true;\r\n\t}\r\n\tif (m_strImgExtras.Find(_T(\"[Nikon1.Quality]:[RAW\")) != -1) {\r\n\t\tbCurXextrasw = true;\r\n\t}\r\n\tif (m_strImgExtras.Find(_T(\"[Nikon2.Quality]:[RAW\")) != -1) {\r\n\t\tbCurXextrasw = true;\r\n\t}\r\n\tif (m_strImgExtras.Find(_T(\"[Nikon3.Quality]:[RAW\")) != -1) {\r\n\t\tbCurXextrasw = true;\r\n\t}\r\n\tif ((m_nImgQualPhotoshopSa != 0) || (m_nImgQualPhotoshopSfw != 0)) {\r\n\t\tbCurXps = true;\r\n\t}\r\n\r\n\t// Search for known COMment field indicators\r\n\tif (theApp.m_pDbSigs->SearchCom(m_strComment)) {\r\n\t\tbCurXcomsw = true;\r\n\t}\r\n\r\n\tm_pLog->AddLine(_T(\"\"));\r\n\tm_pLog->AddLine(_T(\"          EXIF.Make / Software        EXIF.Model                            Quality           Subsamp Match?\"));\r\n\tm_pLog->AddLine(_T(\"          -------------------------   -----------------------------------   ----------------  --------------\"));\r\n\r\n\tCompSig pEntry;\r\n\tunsigned ind_max = theApp.m_pDbSigs->GetDBNumEntries();\r\n\tfor (ind=0;ind<ind_max;ind++) {\r\n\t\ttheApp.m_pDbSigs->GetDBEntry(ind,&pEntry);\r\n\r\n\t\t// Reset current entry state\r\n\t\tcurMatchMm = false;\r\n\t\tcurMatchSw = false;\r\n\t\tcurMatchSig = false;\r\n\t\tcurMatchSigCss = false;\r\n\r\n\t\t// Compare make/model (only for digicams)\r\n\t\tif ((pEntry.eEditor == ENUM_EDITOR_CAM) &&\r\n\t\t\t(bCurXmm == true) &&\r\n\t\t\t(pEntry.strXMake  == m_strImgExifMake) &&\r\n\t\t\t(pEntry.strXModel == m_strImgExifModel) )\r\n\t\t{\r\n\t\t\tcurMatchMm = true;\r\n\t\t}\r\n\r\n\t\t// For software entries, do a loose search\r\n\t\tif ((pEntry.eEditor == ENUM_EDITOR_SW) &&\r\n\t\t\t(bCurXsw == true) &&\r\n\t\t\t(pEntry.strMSwTrim != _T(\"\")) &&\r\n\t\t\t(m_strSoftware.Find(pEntry.strMSwTrim) != -1) )\r\n\t\t{\r\n\t\t\t// Software field matches known software string\r\n\t\t\tbSrchXsw = true;\r\n\t\t\tcurMatchSw = true;\r\n\t\t}\r\n\r\n\r\n\t\t// Compare signature (and CSS for digicams)\r\n\t\tif ( (pEntry.strCSig == m_strHash) || (pEntry.strCSigRot == m_strHash) ||\r\n\t\t\t(pEntry.strCSig == m_strHashRot) || (pEntry.strCSigRot == m_strHashRot) )\r\n\t\t{\r\n\t\t\tcurMatchSig = true;\r\n\r\n\t\t\t// If Database entry is for an editor, sig matches irrespective of CSS\r\n\t\t\tif (pEntry.eEditor == ENUM_EDITOR_SW) {\r\n\t\t\t\tbSrchUsig = true;\r\n\t\t\t\tcurMatchSigCss = true; // FIXME: do I need this?\r\n\r\n\t\t\t\t// For special case of IJG\r\n\t\t\t\tif (pEntry.strMSwDisp == _T(\"IJG Library\")) {\r\n\t\t\t\t\tbMatchIjg = true;\r\n\t\t\t\t\tsMatchIjgQual = pEntry.strUmQual;\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\t\t\t\t// Database entry is for a digicam, sig match only if CSS matches too\r\n\t\t\t\tif (pEntry.strXSubsamp == m_strImgQuantCss) {\r\n\t\t\t\t\tbSrchUsig = true;\r\n\t\t\t\t\tcurMatchSigCss = true;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcurMatchSigCss = false;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} // editor\r\n\r\n\t\t} else {\r\n\t\t\t// sig doesn't match\r\n\t\t\tcurMatchSig = false;\r\n\t\t\tcurMatchSigCss = false;\r\n\t\t}\r\n\r\n\r\n\t\t// For digicams:\r\n\t\tif (curMatchMm && curMatchSigCss) {\r\n\t\t\tbSrchXmmUsig = true;\r\n\t\t}\r\n\t\t// For software:\r\n\t\tif (curMatchSw && curMatchSig) {\r\n\t\t\tbSrchXswUsig = true;\r\n\t\t}\r\n\r\n\t\tif (theApp.m_pDbSigs->IsDBEntryUser(ind)) {\r\n\t\t\tlocationStr = _T(\"*\");\r\n\t\t} else {\r\n\t\t\tlocationStr = _T(\" \");\r\n\t\t}\r\n\r\n\t\t// Display entry if it is a good match\r\n\t\tif (curMatchSig) {\r\n\t\t\tif (pEntry.eEditor==ENUM_EDITOR_CAM) {\r\n\t\t\t\tstrTmp.Format(_T(\"    %s%4s[%-25s] [%-35s] [%-16s] %-5s %-5s %-5s\"),(LPCTSTR)locationStr,_T(\"CAM:\"),\r\n\t\t\t\t\t(LPCTSTR)pEntry.strXMake.Left(25),(LPCTSTR)pEntry.strXModel.Left(35),(LPCTSTR)pEntry.strUmQual.Left(16),\r\n\t\t\t\t\t(curMatchSigCss?_T(\"Yes\"):_T(\"No\")),_T(\"\"),_T(\"\"));\r\n\t\t\t} else if (pEntry.eEditor==ENUM_EDITOR_SW) {\r\n\t\t\t\tstrTmp.Format(_T(\"    %s%4s[%-25s]  %-35s  [%-16s] %-5s %-5s %-5s\"),(LPCTSTR)locationStr,_T(\"SW :\"),\r\n\t\t\t\t\t(LPCTSTR)pEntry.strMSwDisp.Left(25),_T(\"\"),(LPCTSTR)pEntry.strUmQual.Left(16),\r\n\t\t\t\t\t_T(\"\"),_T(\"\"),_T(\"\"));\r\n\t\t\t} else {\r\n\t\t\t\tstrTmp.Format(_T(\"    %s%4s[%-25s] [%-35s] [%-16s] %-5s %-5s %-5s\"),(LPCTSTR)locationStr,_T(\"?? :\"),\r\n\t\t\t\t\t(LPCTSTR)pEntry.strXMake.Left(25),(LPCTSTR)pEntry.strXModel.Left(35),(LPCTSTR)pEntry.strUmQual.Left(16),\r\n\t\t\t\t\t_T(\"\"),_T(\"\"),_T(\"\"));\r\n\t\t\t}\r\n\t\t\tif (curMatchMm || curMatchSw) {\r\n\t\t\t\tm_pLog->AddLineGood(strTmp);\r\n\t\t\t} else {\r\n\t\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\r\n\t} // loop through DB\r\n\r\n\tCString strSw;\r\n\t// If it matches an IJG signature, report other possible sources:\r\n\tif (bMatchIjg) {\r\n\t\tm_pLog->AddLine(_T(\"\"));\r\n\t\tm_pLog->AddLine(_T(\"    The following IJG-based editors also match this signature:\"));\r\n\t\tunsigned nIjgNum;\r\n\t\tCString strIjgSw;\r\n\t\tnIjgNum = theApp.m_pDbSigs->GetIjgNum();\r\n\t\tfor (ind=0;ind<nIjgNum;ind++)\r\n\t\t{\r\n\t\t\tstrIjgSw = theApp.m_pDbSigs->GetIjgEntry(ind);\r\n\t\t\tstrTmp.Format(_T(\"     %4s[%-25s]  %-35s  [%-16s] %-5s %-5s %-5s\"),_T(\"SW :\"),\r\n\t\t\t\t(LPCTSTR)strIjgSw.Left(25),_T(\"\"),(LPCTSTR)sMatchIjgQual.Left(16),\r\n\t\t\t\t_T(\"\"),_T(\"\"),_T(\"\"));\r\n\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t}\r\n\t}\r\n\r\n\t//m_pLog->AddLine(_T(\"          --------------------   -----------------------------------   ----------------  --------------\"));\r\n\tm_pLog->AddLine(_T(\"\"));\r\n\r\n\tif (bCurXps) {\r\n\t\tm_pLog->AddLine(_T(\"  NOTE: Photoshop IRB detected\"));\r\n\t}\r\n\tif (bCurXextrasw) {\r\n\t\tm_pLog->AddLine(_T(\"  NOTE: Additional EXIF fields indicate software processing\"));\r\n\t}\r\n\tif (bSrchXsw) {\r\n\t\tm_pLog->AddLine(_T(\"  NOTE: EXIF Software field recognized as from editor\"));\r\n\t}\r\n\tif (bCurXcomsw) {\r\n\t\tm_pLog->AddLine(_T(\"  NOTE: JFIF COMMENT field is known software\"));\r\n\t}\r\n\r\n\r\n\r\n\t// ============================================\r\n\t// Image Assessment Algorithm\r\n\t// ============================================\r\n\r\n\tbool bEditDefinite = false;\r\n\tbool bEditLikely = false;\r\n\tbool bEditNot = false;\r\n\tbool bEditNotUnknownSw = false;\r\n\r\n\tif (bCurXps) {\r\n\t\tbEditDefinite = true;\r\n\t}\r\n\tif (!bCurXmm) {\r\n\t\tbEditDefinite = true;\r\n\t}\r\n\tif (bCurXextrasw) {\r\n\t\tbEditDefinite = true;\r\n\t}\r\n\tif (bCurXcomsw) {\r\n\t\tbEditDefinite = true;\r\n\t}\r\n\tif (bSrchXsw) {\r\n\t\t// Software field matches known software string\r\n\t\tbEditDefinite = true;\r\n\t}\r\n\tif (theApp.m_pDbSigs->LookupExcMmIsEdit(m_strImgExifMake,m_strImgExifModel)) {\r\n\t\t// Make/Model is in exception list of ones that mark known software\r\n\t\tbEditDefinite = true;\r\n\t}\r\n\r\n\tif (!bCurXmkr) {\r\n\t\t// If we are missing maker notes, we are almost always dealing with\r\n\t\t// edited images. There are some known exceptions, so far:\r\n\t\t//  - Very old digicams\r\n\t\t//  - Certain camera phones\r\n\t\t//  - Blackberry \r\n\t\t// Perhaps we can make an exception for particular digicams (based on\r\n\t\t// make/model) that this determination will not apply. This means that\r\n\t\t// we open up the doors for these files being edited and not caught.\r\n\r\n\t\tif (theApp.m_pDbSigs->LookupExcMmNoMkr(m_strImgExifMake,m_strImgExifModel)) {\r\n\t\t\t// This is a known exception!\r\n\t\t} else {\r\n\t\t\tbEditLikely = true;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t// Filter down remaining scenarios\r\n\tif (!bEditDefinite && !bEditLikely) {\r\n\r\n\t\tif (bSrchXmmUsig) {\r\n\t\t\t// DB cam signature matches DQT & make/model\r\n\t\t\tif (!bCurXsw) {\r\n\t\t\t\t// EXIF software field is empty\r\n\t\t\t\t//\r\n\t\t\t\t// We can now be pretty confident that this file has not\r\n\t\t\t\t// been edited by all the means that we are checking\r\n\t\t\t\tbEditNot = true;\r\n\t\t\t} else {\r\n\t\t\t\t// EXIF software field is set\r\n\t\t\t\t//\r\n\t\t\t\t// This field is often used by:\r\n\t\t\t\t//  - Software editors (edited)\r\n\t\t\t\t//  - RAW converter software (edited)\r\n\t\t\t\t//  - Digicams to indicate firmware (original)\r\n\t\t\t\t//  - Phones to indicate firmware (original)\r\n\t\t\t\t//\r\n\t\t\t\t// However, in generating bEditDefinite, we have already\r\n\t\t\t\t// checked for bSrchXsw which looked for known software\r\n\t\t\t\t// strings. Therefore, we will primarily be left with\r\n\t\t\t\t// firmware strings, etc.\r\n\t\t\t\t//\r\n\t\t\t\t// We will mark this as NOT EDITED but with caution of unknown SW field\r\n\t\t\t\tbEditNot = true;\r\n\t\t\t\tbEditNotUnknownSw = true;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// No DB cam signature matches DQT & make/model\r\n\t\t\t// According to EXIF data, this file does not appear to be edited,\r\n\t\t\t// but no compression signatures in the database match this\r\n\t\t\t// particular make/model. Therefore, result is UNSURE.\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\t// Now make final assessment call\r\n\r\n\r\n\r\n\t// Determine if image has been processed/edited\r\n\tm_eImgEdited = EDITED_UNSET;\r\n\tif (bEditDefinite) {\r\n\t\tm_eImgEdited = EDITED_YES;\r\n\t} else if (bEditLikely) {\r\n\t\tm_eImgEdited = EDITED_YESPROB;\r\n\t} else if (bEditNot) {\r\n\t\t// Images that fall into this category will have:\r\n\t\t//  - No Photoshop tags\r\n\t\t//  - Make/Model is present\r\n\t\t//  - Makernotes present\r\n\t\t//  - No extra software tags (eg. IFD)\r\n\t\t//  - No comment field with known software\r\n\t\t//  - No software field or it does not match known software\r\n\t\t//  - Signature matches DB for this make/model\r\n\t\tm_eImgEdited = EDITED_NO;\r\n\t} else {\r\n\t\t// Images that fall into this category will have:\r\n\t\t//  - Same as EDITED_NO but:\r\n\t\t//  - Signature does not match DB for this make/model\r\n\t\t// In all likelihood, this image will in fact be original\r\n\t\tm_eImgEdited = EDITED_UNSURE;\r\n\t}\r\n\r\n\r\n\r\n\r\n\t// If the file offset is non-zero, then don't ask for submit or show assessment\r\n\tif (m_pAppConfig->nPosStart != 0) {\r\n\t\tm_pLog->AddLine(_T(\"  ASSESSMENT not done as file offset non-zero\"));\r\n\t\tif (bQuiet) { m_pLog->Enable(); }\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// ============================================\r\n\t// Display final assessment\r\n\t// ============================================\r\n\r\n\tm_pLog->AddLine(_T(\"  Based on the analysis of compression characteristics and EXIF metadata:\"));\r\n\tm_pLog->AddLine(_T(\"\"));\r\n\tif (m_eImgEdited == EDITED_YES) {\r\n\t\tm_pLog->AddLine(_T(\"  ASSESSMENT: Class 1 - Image is processed/edited\"));\r\n\t} else if (m_eImgEdited == EDITED_YESPROB) {\r\n\t\tm_pLog->AddLine(_T(\"  ASSESSMENT: Class 2 - Image has high probability of being processed/edited\"));\r\n\t} else if (m_eImgEdited == EDITED_NO) {\r\n\t\tm_pLog->AddLine(_T(\"  ASSESSMENT: Class 3 - Image has high probability of being original\"));\r\n\t\t// In case the EXIF Software field was detected, \r\n\t\tif (bEditNotUnknownSw) {\r\n\t\t\tm_pLog->AddLine(_T(\"              Note that EXIF Software field is set (typically contains Firmware version)\"));\r\n\t\t}\r\n\t} else if (m_eImgEdited == EDITED_UNSURE) {\r\n\t\tm_pLog->AddLine(_T(\"  ASSESSMENT: Class 4 - Uncertain if processed or original\"));\r\n\t\tm_pLog->AddLine(_T(\"              While the EXIF fields indicate original, no compression signatures \"));\r\n\t\tm_pLog->AddLine(_T(\"              in the current database were found matching this make/model\"));\r\n\t} else {\r\n\t\tm_pLog->AddLineErr(_T(\"  ASSESSMENT: *** Failed to complete ***\"));\r\n\t}\r\n\tm_pLog->AddLine(_T(\"\"));\r\n\r\n\r\n\r\n\t// Determine if user should add entry to DB\r\n\tbool bDbReqAdd = false;\t\t// Ask user to add\r\n\tbool bDbReqAddAuto = false;\t// Automatically add (in batch operation)\r\n\r\n\r\n\t// TODO: This section should be rewritten to reduce complexity\r\n\r\n\tm_eDbReqSuggest = DB_ADD_SUGGEST_UNSET;\r\n\tif (m_eImgEdited == EDITED_NO) {\r\n\t\tbDbReqAdd = false;\r\n\t\tm_eDbReqSuggest = DB_ADD_SUGGEST_CAM;\r\n\t} else if (m_eImgEdited == EDITED_UNSURE) {\r\n\t\tbDbReqAdd = true;\r\n\t\tbDbReqAddAuto = true;\r\n\t\tm_eDbReqSuggest = DB_ADD_SUGGEST_CAM;\r\n\t\tm_pLog->AddLine(_T(\"  Appears to be new signature for known camera.\"));\r\n\t\tm_pLog->AddLine(_T(\"  If the camera/software doesn't appear in list above,\"));\r\n\t\tm_pLog->AddLineWarn(_T(\"  PLEASE ADD TO DATABASE with [Tools->Add Camera to DB]\"));\r\n\t} else if (bCurXps && bSrchUsig) {\r\n\t\t// Photoshop and we already have sig\r\n\t\tbDbReqAdd = false;\r\n\t\tm_eDbReqSuggest = DB_ADD_SUGGEST_SW;\r\n\t} else if (bCurXps && !bSrchUsig) {\r\n\t\t// Photoshop and we don't already have sig\r\n\t\tbDbReqAdd = true;\r\n\t\tbDbReqAddAuto = true;\r\n\t\tm_eDbReqSuggest = DB_ADD_SUGGEST_SW;\r\n\t\tm_pLog->AddLine(_T(\"  Appears to be new signature for Photoshop.\"));\r\n\t\tm_pLog->AddLine(_T(\"  If it doesn't appear in list above,\"));\r\n\t\tm_pLog->AddLineWarn(_T(\"  PLEASE ADD TO DATABASE with [Tools->Add Camera to DB]\"));\r\n\t} else if (bCurXsw && bSrchXsw && bSrchXswUsig) {\r\n\t\tbDbReqAdd = false;\r\n\t\tm_eDbReqSuggest = DB_ADD_SUGGEST_SW;\r\n\t} else if (bCurXextrasw) {\r\n\t\tbDbReqAdd = false;\r\n\t\tm_eDbReqSuggest = DB_ADD_SUGGEST_SW;\r\n\t} else if (bCurXsw && bSrchXsw && !bSrchXswUsig) {\r\n\t\tbDbReqAdd = true;\r\n\t\t//bDbReqAddAuto = true;\r\n\t\tm_eDbReqSuggest = DB_ADD_SUGGEST_SW;\r\n\t\tm_pLog->AddLine(_T(\"  Appears to be new signature for known software.\"));\r\n\t\tm_pLog->AddLine(_T(\"  If the camera/software doesn't appear in list above,\"));\r\n\t\tm_pLog->AddLineWarn(_T(\"  PLEASE ADD TO DATABASE with [Tools->Add Camera to DB]\"));\r\n\t} else if (bCurXmm && bCurXmkr && !bSrchXsw && !bSrchXmmUsig) {\r\n\t\t// unsure if cam, so ask user\r\n\t\tbDbReqAdd = true;\r\n\t\tbDbReqAddAuto = true; \r\n\t\tm_eDbReqSuggest = DB_ADD_SUGGEST_CAM;\r\n\t\tm_pLog->AddLine(_T(\"  This may be a new camera for the database.\"));\r\n\t\tm_pLog->AddLine(_T(\"  If this file is original, and camera doesn't appear in list above,\"));\r\n\t\tm_pLog->AddLineWarn(_T(\"  PLEASE ADD TO DATABASE with [Tools->Add Camera to DB]\"));\r\n\t} else if (!bCurXmm && !bCurXmkr && !bSrchXsw) {\r\n\t\t// unsure if SW, so ask user\r\n\t\tbDbReqAdd = true;\r\n\t\tm_eDbReqSuggest = DB_ADD_SUGGEST_SW;\r\n\t\tm_pLog->AddLine(_T(\"  This may be a new software editor for the database.\"));\r\n\t\tm_pLog->AddLine(_T(\"  If this file is processed, and editor doesn't appear in list above,\"));\r\n\t\tm_pLog->AddLineWarn(_T(\"  PLEASE ADD TO DATABASE with [Tools->Add Camera to DB]\"));\r\n\t}\r\n\r\n\r\n\tm_pLog->AddLine(_T(\"\"));\r\n\r\n\t// -----------------------------------------------------------\r\n\r\n\tif (bQuiet) { m_pLog->Enable(); }\r\n\r\n#ifdef BATCH_DO_DBSUBMIT_ALL\r\n\tbDbReqAddAuto = true;\r\n#endif\r\n\r\n\t// Return a value that indicates whether or not we should add this\r\n\t// entry to the database\r\n\treturn bDbReqAddAuto;\r\n\r\n}\r\n\r\n\r\n// Build the image data string that will be sent to the database repository\r\n// This data string contains the compression siganture and a few special\r\n// fields such as image dimensions, etc.\r\n//\r\n// If Portrait, Rotates DQT table, Width/Height.\r\n//   m_strImgQuantCss is already rotated by ProcessFile()\r\n// PRE: m_strHash already defined\r\nvoid CjfifDecode::PrepareSendSubmit(CString strQual,teSource eUserSource,CString strUserSoftware,CString strUserNotes)\r\n{\r\n\t// Generate the DQT arrays suitable for posting\r\n\tCString\t\tstrTmp1;\r\n\tCString\t\tasDqt[4];\r\n\tunsigned\tnMatrixInd;\r\n\r\n\tASSERT(m_strHash != _T(\"NONE\"));\r\n\tASSERT(m_eImgLandscape!=ENUM_LANDSCAPE_UNSET);\r\n\r\n\tfor (unsigned nSet=0;nSet<4;nSet++) {\r\n\t\tasDqt[nSet] = _T(\"\");\r\n\r\n\t\tif (m_abImgDqtSet[nSet]) {\r\n\t\t\tfor (unsigned nInd=0;nInd<64;nInd++) {\r\n\t\t\t\t// FIXME: Still consider rotating DQT table even though we\r\n\t\t\t\t// don't know for sure if m_eImgLandscape is accurate\r\n\t\t\t\t// Not a big deal if we get it wrong as we still add\r\n\t\t\t\t// both pre- and post-rotated sigs.\r\n\t\t\t\tnMatrixInd = (m_eImgLandscape!=ENUM_LANDSCAPE_NO)?nInd:glb_anQuantRotate[nInd];\r\n\t\t\t\tif ((nInd%8 == 0) && (nInd != 0)) {\r\n\t\t\t\t\tasDqt[nSet].Append(_T(\"!\"));\r\n\t\t\t\t}\r\n\r\n\t\t\t\tasDqt[nSet].AppendFormat(_T(\"%u\"),m_anImgDqtTbl[nSet][nMatrixInd]);\r\n\t\t\t\tif (nInd%8 != 7) {\r\n\t\t\t\t\tasDqt[nSet].Append(_T(\",\"));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} // set defined?\r\n\t} // up to 4 sets\r\n\r\n\tunsigned nOrigW,nOrigH;\r\n\tnOrigW = (m_eImgLandscape!=ENUM_LANDSCAPE_NO)?m_nSofSampsPerLine_X:m_nSofNumLines_Y;\r\n\tnOrigH = (m_eImgLandscape!=ENUM_LANDSCAPE_NO)?m_nSofNumLines_Y:m_nSofSampsPerLine_X;\r\n\r\n\tunsigned nOrigThumbW,nOrigThumbH;\r\n\tnOrigThumbW = (m_eImgLandscape!=ENUM_LANDSCAPE_NO)?m_nImgThumbSampsPerLine:m_nImgThumbNumLines;\r\n\tnOrigThumbH = (m_eImgLandscape!=ENUM_LANDSCAPE_NO)?m_nImgThumbNumLines:m_nImgThumbSampsPerLine;\r\n\r\n\tteMaker eMaker;\r\n\teMaker = (m_bImgExifMakernotes)?ENUM_MAKER_PRESENT:ENUM_MAKER_NONE;\r\n\r\n\t// Sort sig additions\r\n\t// To create some determinism in the database, arrange the sigs\r\n\t// to be in numerical order\r\n\tCString strSig0,strSig1,strSigThm0,strSigThm1;\r\n\tif (m_strHash <= m_strHashRot) {\r\n\t\tstrSig0 = m_strHash;\r\n\t\tstrSig1 = m_strHashRot;\r\n\t} else {\r\n\t\tstrSig0 = m_strHashRot;\r\n\t\tstrSig1 = m_strHash;\r\n\t}\r\n\tif (m_strHashThumb <= m_strHashThumbRot) {\r\n\t\tstrSigThm0 = m_strHashThumb;\r\n\t\tstrSigThm1 = m_strHashThumbRot;\r\n\t} else {\r\n\t\tstrSigThm0 = m_strHashThumbRot;\r\n\t\tstrSigThm1 = m_strHashThumb;\r\n\t}\r\n\r\n\tSendSubmit(m_strImgExifMake,m_strImgExifModel,strQual,asDqt[0],asDqt[1],asDqt[2],asDqt[3],m_strImgQuantCss,\r\n\t\tstrSig0,strSig1,strSigThm0,strSigThm1,(float)m_adImgDqtQual[0],(float)m_adImgDqtQual[1],nOrigW,nOrigH,\r\n\t\tm_strSoftware,m_strComment,eMaker,eUserSource,strUserSoftware,m_strImgExtras,\r\n\t\tstrUserNotes,m_eImgLandscape,nOrigThumbW,nOrigThumbH);\r\n\r\n}\r\n\r\n\r\n// Send the compression signature string to the local database file\r\n// in addition to the web repository if the user has enabled it.\r\nvoid CjfifDecode::SendSubmit(CString strExifMake, CString strExifModel, CString strQual, \r\n\t\t\t\t\t\t\tCString strDqt0, CString strDqt1, CString strDqt2, CString strDqt3,\r\n\t\t\t\t\t\t\tCString strCss,\r\n\t\t\t\t\t\t\tCString strSig, CString strSigRot, CString strSigThumb, \r\n\t\t\t\t\t\t\tCString strSigThumbRot, float fQFact0, float fQFact1, unsigned nImgW, unsigned nImgH, \r\n\t\t\t\t\t\t\tCString strExifSoftware, CString strComment, teMaker eMaker,\r\n\t\t\t\t\t\t\tteSource eUserSource, CString strUserSoftware, CString strExtra,\r\n\t\t\t\t\t\t\tCString strUserNotes, unsigned nExifLandscape,\r\n\t\t\t\t\t\t\tunsigned nThumbX,unsigned nThumbY)\r\n{\r\n\t// NOTE: This assumes that we've already run PrepareSignature()\r\n\t// which usually happens when we process a file.\r\n\tASSERT(strSig != _T(\"\"));\r\n\tASSERT(strSigRot != _T(\"\"));\r\n\r\n\tCUrlString curls;\r\n\r\n\tCString DB_SUBMIT_WWW_VER = _T(\"02\");\r\n\r\n#ifndef BATCH_DO\r\n\tif (m_bSigExactInDB) {\r\n\t\tif (m_pAppConfig->bInteractive)\r\n\t\t\tAfxMessageBox(_T(\"Compression signature already in database\"));\r\n\t} else {\r\n\r\n\t\t// Now append it to the local database and resave\r\n\t\ttheApp.m_pDbSigs->DatabaseExtraAdd(strExifMake,strExifModel,\r\n\t\t\tstrQual,strSig,strSigRot,strCss,eUserSource,strUserSoftware);\r\n\r\n\t\tif (m_pAppConfig->bInteractive)\r\n\t\t\tAfxMessageBox(_T(\"Added Compression signature to database\"));\r\n\t}\r\n#endif\r\n\r\n\r\n\t// Is automatic internet update enabled?\r\n\tif (!theApp.m_pAppConfig->bDbSubmitNet) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tCString\t\tstrTmp;\r\n\r\n\tCString\t\tstrFormat;\r\n\tCString\t\tstrFormDataPre;\r\n\tCString\t\tstrFormData;\r\n\tunsigned\tnFormDataLen;\r\n\r\n\tunsigned\tnChecksum=32;\r\n\tCString\t\tstrSubmitHost;\r\n\tCString\t\tstrSubmitPage;\r\n\tstrSubmitHost = IA_HOST;\r\n\tstrSubmitPage = IA_DB_SUBMIT_PAGE;\r\n\tfor (unsigned i=0;i<_tcslen(IA_HOST);i++) {\r\n\t\tnChecksum += strSubmitHost.GetAt(i);\r\n\t\tnChecksum += 3*strSubmitPage.GetAt(i);\r\n\t}\r\n\r\n\t//if ( (m_pAppConfig->bIsWindowsNTorLater) && (nChecksum == 9678) ) {\r\n\tif (nChecksum == 9678) {\r\n\r\n\t\t// Submit to online database\r\n\t\tCString strHeaders =\r\n\t\t\t_T(\"Content-Type: application/x-www-form-urlencoded\");\r\n\t\t// URL-encoded form variables -\r\n\t\tstrFormat  = _T(\"ver=%s&x_make=%s&x_model=%s&strUmQual=%s&x_dqt0=%s&x_dqt1=%s&x_dqt2=%s&x_dqt3=%s\");\r\n\t\tstrFormat += _T(\"&strXSubsamp=%s&strCSig=%s&strCSigRot=%s&c_qfact0=%f&c_qfact1=%f&x_img_w=%u&x_img_h=%u\");\r\n\t\tstrFormat += _T(\"&x_sw=%s&x_com=%s&x_maker=%u&u_source=%d&u_sw=%s\");\r\n\t\tstrFormat += _T(\"&x_extra=%s&u_notes=%s&c_sigthumb=%s&c_sigthumbrot=%s&x_landscape=%u\");\r\n\t\tstrFormat += _T(\"&x_thumbx=%u&x_thumby=%u\");\r\n\r\n\r\n\t\tstrFormDataPre.Format(strFormat,\r\n\t\t\tDB_SUBMIT_WWW_VER,strExifMake,strExifModel,\r\n\t\t\tstrQual,strDqt0,strDqt1,strDqt2,strDqt3,strCss,strSig,strSigRot,fQFact0,fQFact1,nImgW,nImgH,\r\n\t\t\tstrExifSoftware,strComment,\r\n\t\t\teMaker,eUserSource,strUserSoftware,\r\n\t\t\tstrExtra,strUserNotes,\r\n\t\t\tstrSigThumb,strSigThumbRot,nExifLandscape,nThumbX,nThumbY);\r\n\r\n\t\t//*** Need to sanitize data for URL submission!\r\n\t\t// Search for \"&\", \"?\", \"=\"\r\n\t\tstrFormData.Format(strFormat,\r\n\t\t\tDB_SUBMIT_WWW_VER,curls.Encode(strExifMake),curls.Encode(strExifModel),\r\n\t\t\tstrQual,strDqt0,strDqt1,strDqt2,strDqt3,strCss,strSig,strSigRot,fQFact0,fQFact1,nImgW,nImgH,\r\n\t\t\tcurls.Encode(strExifSoftware),curls.Encode(strComment),\r\n\t\t\teMaker,eUserSource,curls.Encode(strUserSoftware),\r\n\t\t\tcurls.Encode(strExtra),curls.Encode(strUserNotes),\r\n\t\t\tstrSigThumb,strSigThumbRot,nExifLandscape,nThumbX,nThumbY);\r\n\t\tnFormDataLen = strFormData.GetLength();\r\n\r\n\r\n#ifdef DEBUG_SIG\r\n\t\tif (m_pAppConfig->bInteractive) {\r\n\t\t\tAfxMessageBox(strFormDataPre);\r\n\t\t\tAfxMessageBox(strFormData);\r\n\t\t}\r\n#endif\r\n\r\n#ifdef WWW_WININET\r\n\t\t//static LPSTR astrAcceptTypes[2]={\"*/*\", NULL};\r\n\t\tHINTERNET hINet, hConnection, hData;\r\n\r\n\t\thINet = InternetOpen(_T(\"JPEGsnoop/1.0\"), INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0 );\r\n\t\tif ( !hINet )\r\n\t\t{\r\n\t\t\tif (m_pAppConfig->bInteractive)\r\n\t\t\t\tAfxMessageBox(_T(\"InternetOpen Failed\"));\r\n\t\t\treturn;\r\n\t\t}\r\n\t\ttry\r\n\t\t{\r\n\t\t\thConnection = InternetConnect( hINet, (LPCTSTR)strSubmitHost, 80, NULL,NULL, INTERNET_SERVICE_HTTP, 0, 1 );\r\n\t\t\tif ( !hConnection )\r\n\t\t\t{\r\n\t\t\t\tInternetCloseHandle(hINet);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\thData = HttpOpenRequest( hConnection, _T(\"POST\"), (LPCTSTR)strSubmitPage, NULL, NULL, NULL, 0, 1 );\r\n\t\t\tif ( !hData )\r\n\t\t\t{\r\n\t\t\t\tInternetCloseHandle(hConnection);\r\n\t\t\t\tInternetCloseHandle(hINet);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t// GET HttpSendRequest( hData, NULL, 0, NULL, 0);\r\n\r\n\t\t\tHttpSendRequest( hData, (LPCTSTR)strHeaders, strHeaders.GetLength(), strFormData.GetBuffer(), strFormData.GetLength());\r\n\r\n\t\t}\r\n\t\tcatch( CInternetException* e)\r\n\t\t{\r\n\t\t\te->ReportError();\r\n\t\t\te->Delete();\r\n\t\t\t//AfxMessageBox(_T(\"EXCEPTION!\"));\r\n\t\t}\r\n\t\tInternetCloseHandle(hConnection);\r\n\t\tInternetCloseHandle(hINet);\r\n\t\tInternetCloseHandle(hData);\r\n#endif\r\n\r\n#ifdef WWW_WINHTTP\r\n\r\n\t\tCInternetSession\t\tsSession;\r\n\t\tCHttpConnection*\t\tpConnection;\r\n\t\tCHttpFile*\t\t\t\tpFile;\r\n\t\tBOOL\t\t\t\t\tbResult;\r\n\t\tDWORD\t\t\t\t\tdwRet;\r\n\r\n\t\t// *** NOTE: Will not work on Windows 95/98!\r\n\t\t// This section is avoided in early OSes otherwise we get an Illegal Op\r\n\t\ttry {\t\t\r\n\t\t\tpConnection = sSession.GetHttpConnection(submit_host);\r\n\t\t\tASSERT (pConnection);\r\n\t\t\tpFile = pConnection->OpenRequest(CHttpConnection::HTTP_VERB_POST,_T(submit_page));\r\n\t\t\tASSERT (pFile);\r\n\t\t\tbResult = pFile->SendRequest(\r\n\t\t\t\tstrHeaders,(LPVOID)(LPCTSTR)strFormData, strFormData.GetLength());\r\n\t\t\tASSERT (bResult != 0);\r\n\t\t\tpFile->QueryInfoStatusCode(dwRet);\r\n\t\t\tASSERT (dwRet == HTTP_STATUS_OK);\r\n\r\n\t\t\t// Clean up!\r\n\t\t\tif (pFile) {\r\n\t\t\t\tpFile->Close();\r\n\t\t\t\tdelete pFile;\r\n\t\t\t\tpFile = NULL;\r\n\t\t\t}\r\n\t\t\tif (pConnection) {\r\n\t\t\t\tpConnection->Close();\r\n\t\t\t\tdelete pConnection;\r\n\t\t\t\tpConnection = NULL;\r\n\t\t\t}\r\n\t\t\tsSession.Close();\r\n\r\n\t\t}\r\n\r\n\t\tcatch (CInternetException* pEx) \r\n\t\t{\r\n\t\t// catch any exceptions from WinINet      \r\n\t\t\tTCHAR szErr[MAX_BUF_EX_ERR_MSG];\r\n\t\t\tszErr[0] = '\\0';\r\n\t\t\tif(!pEx->GetErrorMessage(szErr, MAX_BUF_EX_ERR_MSG))\r\n\t\t\t\t_tcscpy(szErr,_T(\"Unknown error\"));\r\n\t\t\tTRACE(\"Submit Failed! - %s\",szErr);   \r\n\t\t\tif (m_pAppConfig->bInteractive)\r\n\t\t\t\tAfxMessageBox(szErr);\r\n\t\t\tpEx->Delete();\r\n\t\t\tif(pFile)\r\n\t\t\t\tdelete pFile;\r\n\t\t\tif(pConnection)\r\n\t\t\t\tdelete pConnection;\r\n\t\t\tsession.Close(); \r\n\t\t\treturn;\r\n\t\t}\r\n#endif\r\n\r\n\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n// Parse the embedded JPEG thumbnail. This routine is a much-reduced\r\n// version of the main JFIF parser, in that it focuses primarily on the\r\n// DQT tables.\r\nvoid CjfifDecode::DecodeEmbeddedThumb()\r\n{\r\n\tCString\t\tstrTmp;\r\n\tCString\t\tstrMarker;\r\n\tunsigned\tnPosSaved;\r\n\tunsigned\tnPosSaved_sof;\r\n\tunsigned\tnPosEnd;\r\n\tbool\t\tbDone;\r\n\tunsigned\tnCode;\r\n\tbool\t\tbRet;\r\n\r\n\tCString\t\tstrFull;\r\n\tunsigned\tnDqtPrecision_Pq;\r\n\tunsigned\tnDqtQuantDestId_Tq;\r\n\tunsigned\tnImgPrecision;\r\n\tunsigned\tnLength;\r\n\tunsigned\tnTmpVal;\r\n\tbool\t\tbScanSkipDone;\r\n\tbool\t\tbErrorAny = false;\r\n\tbool\t\tbErrorThumbLenZero = false;\r\n\tunsigned\tnSkipCount;\r\n\r\n\tnPosSaved = m_nPos;\r\n\r\n\t// Examine the EXIF embedded thumbnail (if it exists)\r\n\tif (m_nImgExifThumbComp == 6) {\r\n\t\tm_pLog->AddLine(_T(\"\"));\r\n\t\tm_pLog->AddLineHdr(_T(\"*** Embedded JPEG Thumbnail ***\"));\r\n\t\tstrTmp.Format(_T(\"  Offset: 0x%08X\"),m_nImgExifThumbOffset);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\t\tstrTmp.Format(_T(\"  Length: 0x%08X (%u)\"),m_nImgExifThumbLen,m_nImgExifThumbLen);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t// Quick scan for DQT tables\r\n\t\tm_nPos = m_nImgExifThumbOffset;\r\n\t\tbDone = false;\r\n\t\twhile (!bDone) {\r\n\r\n\t\t\t// For some reason, I have found files that have a nLength of 0\r\n\t\t\tif (m_nImgExifThumbLen != 0) {\r\n\t\t\t\tif ((m_nPos-m_nImgExifThumbOffset) > m_nImgExifThumbLen) {\r\n\t\t\t\t\tstrTmp.Format(_T(\"ERROR: Read more than specified EXIF thumb nLength (%u bytes) before EOI\"),m_nImgExifThumbLen);\r\n\t\t\t\t\tm_pLog->AddLineErr(strTmp);\r\n\t\t\t\t\tbErrorAny = true;\r\n\t\t\t\t\tbDone = true;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t// Don't try to process if nLength is 0!\r\n\t\t\t\t// Seen this in a Canon 1ds file (processed by photoshop)\r\n\t\t\t\tbDone = true;\r\n\t\t\t\tbErrorAny = true;\r\n\t\t\t\tbErrorThumbLenZero = true;\r\n\t\t\t}\r\n\t\t\tif ((!bDone) && (Buf(m_nPos++) != 0xFF)) {\r\n\t\t\t\tstrTmp.Format(_T(\"ERROR: Expected marker 0xFF, got 0x%02X @ offset 0x%08X\"),Buf(m_nPos-1),(m_nPos-1));\r\n\t\t\t\tm_pLog->AddLineErr(strTmp);\r\n\t\t\t\tbErrorAny = true;\r\n\t\t\t\tbDone = true;\r\n\r\n\t\t\t}\r\n\r\n\r\n\r\n\t\t\tif (!bDone) {\r\n\t\t\t\tnCode = Buf(m_nPos++);\r\n\r\n \t\t\t\tm_pLog->AddLine(_T(\"\"));\r\n\t\t\t\tswitch (nCode) {\r\n\t\t\t\t\tcase JFIF_SOI: // SOI\r\n\t\t\t\t\t\tm_pLog->AddLine(_T(\"  * Embedded Thumb Marker: SOI\")); \r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase JFIF_DQT:  // Define quantization tables\r\n\t\t\t\t\t\tm_pLog->AddLine(_T(\"  * Embedded Thumb Marker: DQT\")); \r\n\r\n\t\t\t\t\t\tnLength = Buf(m_nPos)*256 + Buf(m_nPos+1);\r\n\t\t\t\t\t\tnPosEnd = m_nPos+nLength;\r\n\t\t\t\t\t\tm_nPos+=2;\r\n\t\t\t\t\t\tstrTmp.Format(_T(\"    Length = %u\"),nLength); \r\n\t\t\t\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t\t\t\t\twhile (nPosEnd > m_nPos)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tstrTmp.Format(_T(\"    ----\"));\r\n\t\t\t\t\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t\t\t\t\t\tnTmpVal = Buf(m_nPos++);\r\n\t\t\t\t\t\t\tnDqtPrecision_Pq = (nTmpVal & 0xF0) >> 4;\r\n\t\t\t\t\t\t\tnDqtQuantDestId_Tq = nTmpVal & 0x0F;\r\n\t\t\t\t\t\t\tCString\tstrPrecision = _T(\"\");\r\n\t\t\t\t\t\t\tif (nDqtPrecision_Pq == 0) {\r\n\t\t\t\t\t\t\t\tstrPrecision = _T(\"8 bits\");\r\n\t\t\t\t\t\t\t} else if (nDqtPrecision_Pq == 1) {\r\n\t\t\t\t\t\t\t\tstrPrecision = _T(\"16 bits\");\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tstrPrecision.Format(_T(\"??? unknown [value=%u]\"),nDqtPrecision_Pq);\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tstrTmp.Format(_T(\"    Precision=%s\"),(LPCTSTR)strPrecision);\r\n\t\t\t\t\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t\t\t\t\t\tstrTmp.Format(_T(\"    Destination ID=%u\"),nDqtQuantDestId_Tq);\r\n\t\t\t\t\t\t\t// NOTE: The mapping between destination IDs and the actual\r\n\t\t\t\t\t\t\t// usage is defined in the SOF marker which is often later.\r\n\t\t\t\t\t\t\t// In nearly all images, the following is true. However, I have\r\n\t\t\t\t\t\t\t// seen some test images that set Tbl 3 = Lum, Tbl 0=Chr,\r\n\t\t\t\t\t\t\t// Tbl1=Chr, and Tbl2 undefined\r\n\t\t\t\t\t\t\tif (nDqtQuantDestId_Tq == 0) {\r\n\t\t\t\t\t\t\t\tstrTmp += _T(\" (Luminance, typically)\");\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse if (nDqtQuantDestId_Tq == 1) {\r\n\t\t\t\t\t\t\t\tstrTmp += _T(\" (Chrominance, typically)\");\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse if (nDqtQuantDestId_Tq == 2) {\r\n\t\t\t\t\t\t\t\tstrTmp += _T(\" (Chrominance, typically)\");\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\tstrTmp += _T(\" (???)\");\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\r\n\t\t\t\t\t\t\tif (nDqtQuantDestId_Tq >= 4) {\r\n\t\t\t\t\t\t\t\tstrTmp.Format(_T(\"ERROR: nDqtQuantDestId_Tq = %u, >= 4\"),nDqtQuantDestId_Tq);\r\n\t\t\t\t\t\t\t\tm_pLog->AddLineErr(strTmp);\r\n\t\t\t\t\t\t\t\tbDone = true;\r\n\t\t\t\t\t\t\t\tbErrorAny = true;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tfor (unsigned nInd=0;nInd<=63;nInd++)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tnTmpVal = Buf(m_nPos++);\r\n\t\t\t\t\t\t\t\tm_anImgThumbDqt[nDqtQuantDestId_Tq][glb_anZigZag[nInd]] = nTmpVal;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tm_abImgDqtThumbSet[nDqtQuantDestId_Tq] = true;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// Now display the table\r\n\t\t\t\t\t\t\tfor (unsigned nY=0;nY<8;nY++) {\r\n\t\t\t\t\t\t\t\tstrFull.Format(_T(\"      DQT, Row #%u: \"),nY);\r\n\t\t\t\t\t\t\t\tfor (unsigned nX=0;nX<8;nX++) {\r\n\t\t\t\t\t\t\t\t\tstrTmp.Format(_T(\"%3u \"),m_anImgThumbDqt[nDqtQuantDestId_Tq][nY*8+nX]);\r\n\t\t\t\t\t\t\t\t\tstrFull += strTmp;\r\n\r\n\t\t\t\t\t\t\t\t\t// Store the DQT entry into the Image DenCoder\r\n\t\t\t\t\t\t\t\t\tbRet = m_pImgDec->SetDqtEntry(nDqtQuantDestId_Tq,nY*8+nX,\r\n\t\t\t\t\t\t\t\t\t\tglb_anUnZigZag[nY*8+nX],m_anImgDqtTbl[nDqtQuantDestId_Tq][nY*8+nX]);\r\n\t\t\t\t\t\t\t\t\tDecodeErrCheck(bRet);\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tm_pLog->AddLine(strFull);\r\n\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase JFIF_SOF0:\r\n\t\t\t\t\t\tm_pLog->AddLine(_T(\"  * Embedded Thumb Marker: SOF\"));\r\n\t\t\t\t\t\tnLength = Buf(m_nPos)*256 + Buf(m_nPos+1);\r\n\t\t\t\t\t\tnPosSaved_sof = m_nPos;\r\n\t\t\t\t\t\tm_nPos+=2;\r\n\t\t\t\t\t\tstrTmp.Format(_T(\"    Frame header length = %u\"),nLength); \r\n\t\t\t\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\r\n\t\t\t\t\t\tnImgPrecision = Buf(m_nPos++);\r\n\t\t\t\t\t\tstrTmp.Format(_T(\"    Precision = %u\"),nImgPrecision);\r\n\t\t\t\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t\t\t\t\tm_nImgThumbNumLines = Buf(m_nPos)*256 + Buf(m_nPos+1);\r\n\t\t\t\t\t\tm_nPos += 2;\r\n\t\t\t\t\t\tstrTmp.Format(_T(\"    Number of Lines = %u\"),m_nImgThumbNumLines);\r\n\t\t\t\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t\t\t\t\tm_nImgThumbSampsPerLine = Buf(m_nPos)*256 + Buf(m_nPos+1);\r\n\t\t\t\t\t\tm_nPos += 2; \r\n\t\t\t\t\t\tstrTmp.Format(_T(\"    Samples per Line = %u\"),m_nImgThumbSampsPerLine);\r\n\t\t\t\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t\t\t\t\tstrTmp.Format(_T(\"    Image Size = %u x %u\"),m_nImgThumbSampsPerLine,m_nImgThumbNumLines);\r\n\t\t\t\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t\t\t\t\tm_nPos = nPosSaved_sof+nLength;\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase JFIF_SOS: // SOS\r\n\t\t\t\t\t\tm_pLog->AddLine(_T(\"  * Embedded Thumb Marker: SOS\"));\r\n\t\t\t\t\t\tm_pLog->AddLine(_T(\"    Skipping scan data\"));\r\n\t\t\t\t\t\tbScanSkipDone = false;\r\n\t\t\t\t\t\tnSkipCount = 0;\r\n\t\t\t\t\t\twhile (!bScanSkipDone) {\r\n\t\t\t\t\t\t\tif ((Buf(m_nPos) == 0xFF) && (Buf(m_nPos+1) != 0x00)) {\r\n\t\t\t\t\t\t\t\t// Was it a restart marker?\r\n\t\t\t\t\t\t\t\tif ((Buf(m_nPos+1) >= JFIF_RST0) && (Buf(m_nPos+1) <= JFIF_RST7)) {\r\n\t\t\t\t\t\t\t\t\tm_nPos++;\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t// No... it's a real marker\r\n\t\t\t\t\t\t\t\t\tbScanSkipDone = true;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tm_nPos++;\r\n\t\t\t\t\t\t\t\tnSkipCount++;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tstrTmp.Format(_T(\"    Skipped %u bytes\"),nSkipCount);\r\n\t\t\t\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase JFIF_EOI:\r\n\t\t\t\t\t\tm_pLog->AddLine(_T(\"  * Embedded Thumb Marker: EOI\")); \r\n\t\t\t\t\t\tbDone = true;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\tcase JFIF_RST0:\r\n\t\t\t\t\tcase JFIF_RST1:\r\n\t\t\t\t\tcase JFIF_RST2:\r\n\t\t\t\t\tcase JFIF_RST3:\r\n\t\t\t\t\tcase JFIF_RST4:\r\n\t\t\t\t\tcase JFIF_RST5:\r\n\t\t\t\t\tcase JFIF_RST6:\r\n\t\t\t\t\tcase JFIF_RST7:\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tGetMarkerName(nCode,strMarker);\r\n\t\t\t\t\t\tstrTmp.Format(_T(\"  * Embedded Thumb Marker: %s\"),(LPCTSTR)strMarker); \r\n\t\t\t\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t\t\t\t\tnLength = Buf(m_nPos)*256 + Buf(m_nPos+1);\r\n\t\t\t\t\t\tstrTmp.Format(_T(\"    Length = %u\"),nLength); \r\n\t\t\t\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t\t\t\t\tm_nPos += nLength;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\t\t\t} // if !bDone\r\n\t\t} // while !bDone\r\n\r\n\t\t// Now calculate the signature\r\n\t\tif (!bErrorAny) {\r\n\t\t\tPrepareSignatureThumb();\r\n\t\t\tm_pLog->AddLine(_T(\"\"));\r\n\t\t\tstrTmp.Format(_T(\"  * Embedded Thumb Signature: %s\"),(LPCTSTR)m_strHashThumb);\r\n\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t}\r\n\r\n\t\tif (bErrorThumbLenZero) {\r\n\t\t\tm_strHashThumb = _T(\"ERR: Len=0\");\r\n\t\t\tm_strHashThumbRot = _T(\"ERR: Len=0\");\r\n\t\t}\r\n\r\n\t} // if JPEG compressed\r\n\r\n\tm_nPos = nPosSaved;\r\n}\r\n\r\n\r\n// Lookup the EXIF marker name from the code value\r\nbool CjfifDecode::GetMarkerName(unsigned nCode,CString &markerStr)\r\n{\r\n\tbool\t\tbDone = false;\r\n\tbool\t\tbFound = false;\r\n\tunsigned\tnInd=0;\r\n\r\n\twhile (!bDone)\r\n\t{\r\n\t\tif (m_pMarkerNames[nInd].nCode==0) {\r\n\t\t\tbDone = true;\r\n\t\t} else if (m_pMarkerNames[nInd].nCode==nCode) {\r\n\t\t\tbDone = true;\r\n\t\t\tbFound = true;\r\n\t\t\tmarkerStr = m_pMarkerNames[nInd].strName;\r\n\t\t\treturn true;\r\n\t\t} else {\r\n\t\t\tnInd++;\r\n\t\t}\r\n\t}\r\n\tif (!bFound) {\r\n\t\tmarkerStr = _T(\"\");\r\n\t\tmarkerStr.Format(_T(\"(0xFF%02X)\"),nCode);\r\n\t\treturn false;\r\n\t}\r\n\treturn true;\r\n\r\n}\r\n\r\n\r\n// Determine if the file is an AVI MJPEG.\r\n// If so, parse the headers.\r\n// TODO: Expand this function to use sub-functions for each block type\r\nbool CjfifDecode::DecodeAvi()\r\n{\r\n\tCString\t\tstrTmp;\r\n\tunsigned\tnPosSaved;\r\n\r\n\tm_bAvi = false;\r\n\tm_bAviMjpeg = false;\r\n\r\n\t// Perhaps start from file position 0?\r\n\tnPosSaved = m_nPos;\r\n\r\n\t// Start from file position 0\r\n\tm_nPos = 0;\r\n\r\n\tbool\t\tbSwap = true;\r\n\r\n\tCString\t\tstrRiff;\r\n\tunsigned\tnRiffLen;\r\n\tCString\t\tstrForm;\r\n\r\n\tstrRiff = m_pWBuf->BufReadStrn(m_nPos,4); m_nPos+=4;\r\n\tnRiffLen = m_pWBuf->BufX(m_nPos,4,bSwap); m_nPos+=4;\r\n\tstrForm = m_pWBuf->BufReadStrn(m_nPos,4); m_nPos+=4;\r\n\tif ((strRiff == _T(\"RIFF\")) && (strForm == _T(\"AVI \"))) {\r\n\t\tm_bAvi = true;\r\n\t\tm_pLog->AddLine(_T(\"\"));\r\n\t\tm_pLog->AddLineHdr(_T(\"*** AVI File Decoding ***\"));\r\n\t\tm_pLog->AddLine(_T(\"Decoding RIFF AVI format...\"));\r\n\t\tm_pLog->AddLine(_T(\"\"));\r\n\t} else {\r\n\t\t// Reset file position\r\n\t\tm_nPos = nPosSaved;\r\n\t\treturn false;\r\n\t}\r\n\r\n\tCString\t\tstrHeader;\r\n\tunsigned\tnChunkSize;\r\n\tunsigned\tnChunkDataStart;\r\n\r\n\tbool\tdone = false;\r\n\twhile (!done) {\r\n\t\tif (m_nPos >= m_pWBuf->GetPosEof()) {\r\n\t\t\tdone = true;\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tstrHeader = m_pWBuf->BufReadStrn(m_nPos,4); m_nPos+=4;\r\n        strTmp.Format(_T(\"  %s\"),(LPCTSTR)strHeader);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tnChunkSize = m_pWBuf->BufX(m_nPos,4,bSwap); m_nPos+=4;\r\n\t\tnChunkDataStart = m_nPos;\r\n\r\n\r\n\t\tif (strHeader == _T(\"LIST\")) {\r\n\r\n\t\t\t// --- LIST ---\r\n\r\n\t\t\tCString strListType;\r\n\t\t\tstrListType = m_pWBuf->BufReadStrn(m_nPos,4); m_nPos+=4;\r\n\r\n\t\t\tstrTmp.Format(_T(\"    %s\"),(LPCTSTR)strListType);\r\n\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t\tif (strListType == _T(\"hdrl\")) {\r\n\r\n\t\t\t\t// --- hdrl ---\r\n\r\n\t\t\t\tunsigned nPosHdrlStart;\r\n\t\t\t\tCString strHdrlId;\r\n\t\t\t\tstrHdrlId = m_pWBuf->BufReadStrn(m_nPos,4); m_nPos+=4;\r\n\t\t\t\tunsigned nHdrlLen;\r\n\t\t\t\tnHdrlLen = m_pWBuf->BufX(m_nPos,4,bSwap); m_nPos+=4;\r\n\t\t\t\tnPosHdrlStart = m_nPos;\r\n\r\n\t\t\t\t// nHdrlLen should be 14*4 bytes\r\n\r\n\t\t\t\tm_nPos = nPosHdrlStart + nHdrlLen;\r\n\r\n\t\t\t} else if (strListType == _T(\"strl\")) {\r\n\r\n\t\t\t\t// --- strl ---\r\n\r\n\t\t\t\t// strhHEADER\r\n\t\t\t\tunsigned nPosStrlStart;\r\n\t\t\t\tCString strStrlId;\r\n\t\t\t\tstrStrlId = m_pWBuf->BufReadStrn(m_nPos,4); m_nPos+=4;\r\n\t\t\t\tunsigned nStrhLen;\r\n\t\t\t\tnStrhLen = m_pWBuf->BufX(m_nPos,4,bSwap); m_nPos+=4;\r\n\t\t\t\tnPosStrlStart = m_nPos;\r\n\r\n\t\t\t\tCString fccType;\r\n\t\t\t\tCString fccHandler;\r\n\t\t\t\tunsigned dwFlags,dwReserved1,dwInitialFrames,dwScale,dwRate;\r\n\t\t\t\tunsigned dwStart,dwLength,dwSuggestedBufferSize,dwQuality;\r\n\t\t\t\tunsigned dwSampleSize,xdwQuality,xdwSampleSize;\r\n\t\t\t\tfccType = m_pWBuf->BufReadStrn(m_nPos,4); m_nPos+=4;\r\n\t\t\t\tfccHandler = m_pWBuf->BufReadStrn(m_nPos,4); m_nPos+=4;\r\n\t\t\t\tdwFlags = m_pWBuf->BufX(m_nPos,4,bSwap); m_nPos+=4;\r\n\t\t\t\tdwReserved1 = m_pWBuf->BufX(m_nPos,4,bSwap); m_nPos+=4;\r\n\t\t\t\tdwInitialFrames = m_pWBuf->BufX(m_nPos,4,bSwap); m_nPos+=4;\r\n\t\t\t\tdwScale = m_pWBuf->BufX(m_nPos,4,bSwap); m_nPos+=4;\r\n\t\t\t\tdwRate = m_pWBuf->BufX(m_nPos,4,bSwap); m_nPos+=4;\r\n\t\t\t\tdwStart = m_pWBuf->BufX(m_nPos,4,bSwap); m_nPos+=4;\r\n\t\t\t\tdwLength = m_pWBuf->BufX(m_nPos,4,bSwap); m_nPos+=4;\r\n\t\t\t\tdwSuggestedBufferSize = m_pWBuf->BufX(m_nPos,4,bSwap); m_nPos+=4;\r\n\t\t\t\tdwQuality = m_pWBuf->BufX(m_nPos,4,bSwap); m_nPos+=4;\r\n\t\t\t\tdwSampleSize = m_pWBuf->BufX(m_nPos,4,bSwap); m_nPos+=4;\r\n\t\t\t\txdwQuality = m_pWBuf->BufX(m_nPos,4,bSwap); m_nPos+=4;\r\n\t\t\t\txdwSampleSize = m_pWBuf->BufX(m_nPos,4,bSwap); m_nPos+=4;\r\n\r\n\t\t\t\tCString fccTypeDecode = _T(\"\");\r\n\t\t\t\tif (fccType == _T(\"vids\")) { fccTypeDecode = _T(\"[vids] Video\"); }\r\n\t\t\t\telse if (fccType == _T(\"auds\")) { fccTypeDecode = _T(\"[auds] Audio\"); }\r\n\t\t\t\telse if (fccType == _T(\"txts\")) { fccTypeDecode = _T(\"[txts] Subtitle\"); }\r\n\t\t\t\telse { fccTypeDecode.Format(_T(\"[%s]\"),(LPCTSTR)fccType); } \r\n\t\t\t\tstrTmp.Format(_T(\"      -[FourCC Type]  = %s\"),(LPCTSTR)fccTypeDecode);\r\n\t\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t\t\tstrTmp.Format(_T(\"      -[FourCC Codec] = [%s]\"),(LPCTSTR)fccHandler);\r\n\t\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t\t\tfloat fSampleRate = 0;\r\n\t\t\t\tif (dwScale != 0) {\r\n\t\t\t\t\tfSampleRate = (float)dwRate / (float)dwScale;\r\n\t\t\t\t}\r\n\t\t\t\tstrTmp.Format(_T(\"      -[Sample Rate]  = [%.2f]\"),fSampleRate);\r\n\t\t\t\tif (fccType == _T(\"vids\")) { strTmp.Append(_T(\" frames/sec\")); }\r\n\t\t\t\telse if (fccType == _T(\"auds\")) { strTmp.Append(_T(\" samples/sec\")); }\r\n\t\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t\t\tm_nPos = nPosStrlStart + nStrhLen;\t// Skip\r\n\r\n\t\t\t\tstrTmp.Format(_T(\"      %s\"),(LPCTSTR)fccType);\r\n\t\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t\t\tif (fccType == _T(\"vids\")) {\r\n\t\t\t\t\t// --- vids ---\r\n\r\n\t\t\t\t\t// Is it MJPEG?\r\n\t\t\t\t\t//strTmp.Format(_T(\"      -[Video Stream FourCC]=[%s]\"),fccHandler);\r\n\t\t\t\t\t//m_pLog->AddLine(strTmp);\r\n\t\t\t\t\tif (fccHandler == _T(\"mjpg\")) {\r\n\t\t\t\t\t\tm_bAviMjpeg = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (fccHandler == _T(\"MJPG\")) {\r\n\t\t\t\t\t\tm_bAviMjpeg = true;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// strfHEADER_BIH\r\n\t\t\t\t\tCString strSkipId;\r\n\t\t\t\t\tunsigned nSkipLen;\r\n\t\t\t\t\tunsigned nSkipStart;\r\n\t\t\t\t\tstrSkipId = m_pWBuf->BufReadStrn(m_nPos,4); m_nPos+=4;\r\n\t\t\t\t\tnSkipLen = m_pWBuf->BufX(m_nPos,4,bSwap); m_nPos+=4;\r\n\t\t\t\t\tnSkipStart = m_nPos;\r\n\t\t\t\t\t\r\n\t\t\t\t\tm_nPos = nSkipStart + nSkipLen; // Skip\r\n\r\n\t\t\t\t} else if (fccType == _T(\"auds\")) {\r\n\t\t\t\t\t// --- auds ---\r\n\r\n\t\t\t\t\t// strfHEADER_WAVE\r\n\r\n\t\t\t\t\tCString strSkipId;\r\n\t\t\t\t\tunsigned nSkipLen;\r\n\t\t\t\t\tunsigned nSkipStart;\r\n\t\t\t\t\tstrSkipId = m_pWBuf->BufReadStrn(m_nPos,4); m_nPos+=4;\r\n\t\t\t\t\tnSkipLen = m_pWBuf->BufX(m_nPos,4,bSwap); m_nPos+=4;\r\n\t\t\t\t\tnSkipStart = m_nPos;\r\n\t\t\t\t\t\r\n\t\t\t\t\tm_nPos = nSkipStart + nSkipLen; // Skip\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// strfHEADER\r\n\r\n\t\t\t\t\tCString strSkipId;\r\n\t\t\t\t\tunsigned nSkipLen;\r\n\t\t\t\t\tunsigned nSkipStart;\r\n\t\t\t\t\tstrSkipId = m_pWBuf->BufReadStrn(m_nPos,4); m_nPos+=4;\r\n\t\t\t\t\tnSkipLen = m_pWBuf->BufX(m_nPos,4,bSwap); m_nPos+=4;\r\n\t\t\t\t\tnSkipStart = m_nPos;\r\n\t\t\t\t\t\r\n\t\t\t\t\tm_nPos = nSkipStart + nSkipLen; // Skip\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// strnHEADER\r\n\t\t\t\tunsigned nPosStrnStart;\r\n\t\t\t\tCString strStrnId;\r\n\t\t\t\tstrStrnId = m_pWBuf->BufReadStrn(m_nPos,4); m_nPos+=4;\r\n\t\t\t\tunsigned nStrnLen;\r\n\t\t\t\tnStrnLen = m_pWBuf->BufX(m_nPos,4,bSwap); m_nPos+=4;\r\n\t\t\t\tnPosStrnStart = m_nPos;\r\n\r\n\t\t\t\t// FIXME: Can we rewrite in terms of ChunkSize and ChunkDataStart?\r\n\t\t\t\t//ASSERT ((nPosStrnStart + nStrnLen + (nStrnLen%2)) == (nChunkDataStart + nChunkSize + (nChunkSize%2)));\r\n\t\t\t\t//m_nPos = nChunkDataStart + nChunkSize + (nChunkSize%2);\r\n\t\t\t\tm_nPos = nPosStrnStart + nStrnLen + (nStrnLen%2); // Skip\r\n\r\n\t\t\t} else if (strListType == _T(\"movi\")) {\r\n\t\t\t\t// movi\r\n\r\n\t\t\t\tm_nPos = nChunkDataStart + nChunkSize + (nChunkSize%2);\r\n\t\t\t} else if (strListType == _T(\"INFO\")) {\r\n\t\t\t\t// INFO\r\n\t\t\t\tunsigned nInfoStart;\r\n\t\t\t\tnInfoStart = m_nPos;\r\n\r\n\t\t\t\tCString strInfoId;\r\n\t\t\t\tunsigned nInfoLen;\r\n\t\t\t\tstrInfoId = m_pWBuf->BufReadStrn(m_nPos,4); m_nPos+=4;\r\n\t\t\t\tnInfoLen = m_pWBuf->BufX(m_nPos,4,bSwap); m_nPos+=4;\r\n\r\n\t\t\t\tif (strInfoId == _T(\"ISFT\")) {\r\n\t\t\t\t\tCString strIsft=_T(\"\");\r\n\t\t\t\t\tstrIsft = m_pWBuf->BufReadStrn(m_nPos,nChunkSize);\r\n\t\t\t\t\tstrIsft.TrimRight();\r\n\t\t\t\t\tstrTmp.Format(_T(\"      -[Software] = [%s]\"),(LPCTSTR)strIsft);\r\n\t\t\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tm_nPos = nChunkDataStart + nChunkSize + (nChunkSize%2);\r\n\t\t\t} else {\r\n\t\t\t\t// ?\r\n\t\t\t\tm_nPos = nChunkDataStart + nChunkSize + (nChunkSize%2);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t} else if (strHeader == _T(\"JUNK\")) {\r\n\t\t\t// Junk\r\n\r\n\t\t\tm_nPos = nChunkDataStart + nChunkSize + (nChunkSize%2);\r\n\t\t} else if (strHeader == _T(\"IDIT\")) {\r\n\t\t\t// Timestamp info (Canon, etc.)\r\n\r\n\t\t\tCString strIditTimestamp=_T(\"\");\r\n\t\t\tstrIditTimestamp = m_pWBuf->BufReadStrn(m_nPos,nChunkSize);\r\n\t\t\tstrIditTimestamp.TrimRight();\r\n\t\t\tstrTmp.Format(_T(\"    -[Timestamp] = [%s]\"),(LPCTSTR)strIditTimestamp);\r\n\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t\r\n\t\t\tm_nPos = nChunkDataStart + nChunkSize + (nChunkSize%2);\r\n\r\n\t\t} else if (strHeader == _T(\"indx\")) {\r\n\t\t\t// Index\r\n\r\n\t\t\tm_nPos = nChunkDataStart + nChunkSize + (nChunkSize%2);\r\n\t\t} else if (strHeader == _T(\"idx1\")) {\r\n\t\t\t// Index\r\n\t\t\tunsigned nIdx1Entries = nChunkSize / (4*4);\r\n\r\n\t\t\tm_nPos = nChunkDataStart + nChunkSize + (nChunkSize%2);\r\n\r\n\t\t} else {\r\n\t\t\t// Unsupported\r\n\t\t\tm_nPos = nChunkDataStart + nChunkSize + (nChunkSize%2);\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tm_pLog->AddLine(_T(\"\"));\r\n\tif (m_bAviMjpeg) {\r\n\t\tm_strImgExtras += _T(\"[AVI]:[mjpg],\");\r\n\t\tm_pLog->AddLineGood(_T(\"  AVI is MotionJPEG\"));\r\n\t\tm_pLog->AddLineWarn(_T(\"  Use [Tools->Img Search Fwd] to locate next frame\"));\r\n\t} else {\r\n\t\tm_strImgExtras += _T(\"[AVI]:[????],\");\r\n\t\tm_pLog->AddLineWarn(_T(\"  AVI is not MotionJPEG. [Img Search Fwd/Rev] unlikely to find frames.\"));\r\n\t}\r\n\tm_pLog->AddLine(_T(\"\"));\r\n\r\n\t// Reset file position\r\n\tm_nPos = nPosSaved;\r\n\r\n\treturn m_bAviMjpeg;\r\n}\r\n\r\n\r\n\r\n// This is the primary JFIF parsing routine.\r\n// The main loop steps through all of the JFIF markers and calls\r\n// DecodeMarker() each time until we reach the end of file or an error.\r\n// Finally, we invoke the compression signature search function.\r\n//\r\n// Processing starts at the file offset m_pAppConfig->nPosStart\r\n//\r\n// INPUT:\r\n// - inFile\t\t\t\t\t\t= Input file pointer\r\n//\r\n// PRE:\r\n// - m_pAppConfig->nPosStart\t= Starting file offset for decode\r\n//\r\nvoid CjfifDecode::ProcessFile(CFile* inFile)\r\n{\r\n\r\n\tCString strTmp;\r\n\r\n\t// Reset the JFIF decoder state as we may be redoing another file\r\n\tReset();\r\n\r\n\t// Reset the IMG Decoder state\r\n\tif (m_pImgSrcDirty) {\r\n\t\tm_pImgDec->ResetState();\r\n\t}\r\n\r\n\t// Set the statusbar text to Processing...\r\n\r\n\t// Ensure the status bar has been allocated\r\n\t// NOTE: The stat bar is NULL if we drag & drop a file onto\r\n\t//       the JPEGsnoop app icon.\r\n\tif (m_pStatBar) {\r\n\t\tm_pStatBar->SetPaneText(0,_T(\"Processing...\"));\r\n\t}\r\n\r\n\r\n\t// Note that we don't clear out the logger (with m_pLog->Reset())\r\n\t// as we want top-level caller to do this. This way we can\r\n\t// still insert extra lines from top level.\r\n\r\n\t// GetLength returns ULONGLONG. Abort on large files (>=4GB)\r\n\tULONGLONG\tnPosFileEnd;\r\n\tnPosFileEnd = inFile->GetLength();\r\n\tif (nPosFileEnd > 0xFFFFFFFFUL) {\r\n\t\tCString strTmp = _T(\"File too large. Skipping.\");\r\n\t\tm_pLog->AddLineErr(strTmp);\r\n\t\tif (m_pAppConfig->bInteractive)\r\n\t\t\tAfxMessageBox(strTmp);\r\n\t\treturn;\r\n\t}\r\n\tm_nPosFileEnd = static_cast<unsigned long>(nPosFileEnd);\r\n\r\n\r\n\tunsigned nStartPos;\r\n\tnStartPos = m_pAppConfig->nPosStart;\r\n\tm_nPos = nStartPos;\r\n\tm_nPosEmbedStart = nStartPos;\t// Save the embedded file start position\r\n\r\n\tstrTmp.Format(_T(\"Start Offset: 0x%08X\"),nStartPos);\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\r\n\t// ----------------------------------------------------------------\r\n\r\n\t// Test for AVI file\r\n\t// - Detect header\r\n\t// - start from beginning of file\r\n\tDecodeAvi();\r\n\t// TODO: Should we skip decode of file if not MJPEG?\r\n\r\n\r\n\t// ----------------------------------------------------------------\r\n\r\n\t// Test for PSD file\r\n\t// - Detect header\r\n\t// - FIXME: start from current offset?\r\n\tunsigned\tnWidth=0;\r\n\tunsigned\tnHeight=0;\r\n\r\n#ifdef PS_IMG_DEC_EN\r\n\t// If PSD image decoding is enabled, associate the PSD parsing with\r\n\t// the current DIB. After decoding, flag the DIB as ready for display.\r\n\r\n\t// Attempt decode as PSD\r\n\tbool bDecPsdOk;\r\n\tbDecPsdOk = m_pPsDec->DecodePsd(nStartPos,&m_pImgDec->m_pDibTemp,nWidth,nHeight);\r\n\tif (bDecPsdOk) {\r\n\t\t// FIXME: The following is a bit of a hack\r\n\t\tm_pImgDec->m_bDibTempReady = true;\r\n\t\tm_pImgDec->m_bPreviewIsJpeg = false;\t\t\t// MCU/Block info not available\r\n\t\tm_pImgDec->SetImageDimensions(nWidth,nHeight);\r\n\r\n\t\t// Clear the image information\r\n\t\t// The primary reason for this is to ensure we don't have stale information from a previous\r\n\t\t// JPEG image (eg. real image border inside MCU border which would be overlayed during draw).\r\n\t\tm_pImgDec->SetImageDetails(0,0,0,0,false,0);\r\n\t\t\r\n\t\t// No more processing of file\r\n\t\t// - Otherwise we'd continue to attempt to decode as JPEG\r\n\t\treturn;\r\n\t}\r\n#else\r\n\t// Don't attempt to display Photoshop image data\r\n\tif (m_pPsDec->DecodePsd(nStartPos,NULL,nWidth,nHeight)) {\r\n\t\treturn;\r\n\t}\r\n#endif\r\n\r\n\r\n\t// ----------------------------------------------------------------\r\n\r\n// Disable DICOM for now until fully tested\r\n#ifdef SUPPORT_DICOM\r\n\t// Test for DICOM\r\n\t// - Detect header\r\n\t// - start from beginning of file\r\n\tbool\t\t\tbDicom = false;\r\n\tunsigned long\tnPosJpeg = 0;\t\t// File offset to embedded JPEG in DICOM\r\n\tbDicom = m_pDecDicom->DecodeDicom(0,m_nPosFileEnd,nPosJpeg);\r\n\tif (bDicom) {\r\n\t\t// Adjust start of JPEG decoding if we are currently without an offset\r\n\t\tif (nStartPos == 0) {\r\n\t\t\tm_pAppConfig->nPosStart = nPosJpeg;\r\n\r\n\t\t\tnStartPos = m_pAppConfig->nPosStart;\r\n\t\t\tm_nPos = nStartPos;\r\n\t\t\tm_nPosEmbedStart = nStartPos;\t// Save the embedded file start position\r\n\r\n\t\t\tstrTmp.Format(_T(\"Adjusting Start Offset to: 0x%08X\"),nStartPos);\r\n\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t\tm_pLog->AddLine(_T(\"\"));\r\n\t\t}\r\n\t}\r\n#endif\r\n\r\n\r\n\t// ----------------------------------------------------------------\r\n\r\n\t// Decode as JPEG JFIF file\r\n\r\n\t// If we are in a non-zero offset, add this to extras\r\n\tif (m_pAppConfig->nPosStart!=0) {\r\n\t\tstrTmp.Format(_T(\"[Offset]=[%lu],\"),m_pAppConfig->nPosStart);\r\n        m_strImgExtras += strTmp;\r\n\t}\r\n\r\n\tunsigned nDataAfterEof = 0;\r\n\r\n\tBOOL bDone = FALSE;\r\n\twhile (!bDone)\r\n\t{\r\n\t\t// Allow some other threads to jump in\r\n\r\n\t\t// Return value 0 - OK\r\n\t\t//              1 - Error\r\n\t\t//              2 - EOI\r\n\t\tif (DecodeMarker() != DECMARK_OK) {\r\n\t\t\tbDone = TRUE;\r\n\t\t\tif (m_nPosFileEnd >= m_nPosEoi) {\r\n\t\t\t\tnDataAfterEof = m_nPosFileEnd - m_nPosEoi;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (m_nPos > m_pWBuf->GetPosEof()) {\r\n\t\t\t\tm_pLog->AddLineErr(_T(\"ERROR: Early EOF - file may be missing EOI\"));\r\n\t\t\t\tbDone = TRUE;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// -----------------------------------------------------------\r\n\t// Perform any other informational calculations that require all tables\r\n\t// to be present.\r\n\r\n\t// Determine the CSS Ratio\r\n\t// Save the subsampling string. Assume component 2 is representative of the overall chrominance.\r\n\r\n\t// NOTE: Ensure that we don't execute the following code if we haven't\r\n\t//       completed our read (ie. get bad marker earlier in processing).\r\n\t// TODO: What is the best way to determine all is OK?\r\n\r\n\tm_strImgQuantCss = _T(\"?x?\");\r\n\tm_strHash = _T(\"NONE\");\r\n\tm_strHashRot = _T(\"NONE\");\r\n\r\n\tif (m_bImgOK) {\r\n\t\tASSERT(m_eImgLandscape!=ENUM_LANDSCAPE_UNSET);\r\n\r\n\t\tif (m_nSofNumComps_Nf == NUM_CHAN_YCC) {\r\n\t\t\t// We only try to determine the chroma subsampling ratio if we have 3 components (assume YCC)\r\n\t\t\t// In general, we should be able to use the 2nd or 3rd component\r\n\t\t\r\n\t\t\t// NOTE: The following assumes m_anSofHorzSampFact_Hi and m_anSofVertSampFact_Vi\r\n\t\t\t// are non-zero as otherwise we'll have a divide-by-0 exception.\r\n\t\t\tunsigned\tnCompIdent = m_anSofQuantCompId[SCAN_COMP_CB];\r\n\t\t\tunsigned\tnCssFactH = m_nSofHorzSampFactMax_Hmax/m_anSofHorzSampFact_Hi[nCompIdent];\r\n\t\t\tunsigned\tnCssFactV = m_nSofVertSampFactMax_Vmax/m_anSofVertSampFact_Vi[nCompIdent];\r\n\t\t\tif (m_eImgLandscape!=ENUM_LANDSCAPE_NO) {\r\n\t\t\t\t// Landscape orientation\r\n\t\t\t\tm_strImgQuantCss.Format(_T(\"%ux%u\"),nCssFactH,nCssFactV);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// Portrait orientation (flip subsampling ratio)\r\n\t\t\t\tm_strImgQuantCss.Format(_T(\"%ux%u\"),nCssFactV,nCssFactH);\r\n\t\t\t}\r\n\t\t} else if (m_nSofNumComps_Nf == NUM_CHAN_GRAYSCALE) {\r\n\t\t\tm_strImgQuantCss = _T(\"Gray\");\r\n\t\t}\r\n\r\n\t\tDecodeEmbeddedThumb();\r\n\r\n\t\t// Generate the signature\r\n\t\tPrepareSignature();\r\n\r\n\t\t// Compare compression signature\r\n\t\tif (m_pAppConfig->bSigSearch) {\r\n\t\t\t// In the case of lossless files, there won't be any DQT and\r\n\t\t\t// hence no compression signatures to compare. Therefore, skip this process.\r\n\t\t\tif (m_strHash == _T(\"NONE\")) {\r\n\t\t\t\tm_pLog->AddLineWarn(_T(\"Skipping compression signature search as no DQT\"));\r\n\t\t\t} else {\r\n\t\t\t\tCompareSignature();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (nDataAfterEof > 0) {\r\n\t\t\tm_pLog->AddLine(_T(\"\"));\r\n\t\t\tm_pLog->AddLineHdr(_T(\"*** Additional Info ***\"));\r\n\t\t\tstrTmp.Format(_T(\"NOTE: Data exists after EOF, range: 0x%08X-0x%08X (%u bytes)\"),\r\n\t\t\t\tm_nPosEoi,m_nPosFileEnd,nDataAfterEof);\r\n\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t}\r\n\r\n\t\t// Print out the special-purpose outputs\r\n\t\tOutputSpecial();\r\n\t}\r\n\r\n\r\n\t// Reset the status bar text\r\n\tif (m_pStatBar) {\r\n\t\tm_pStatBar->SetPaneText(0,_T(\"Done\"));\r\n\t}\r\n\r\n\t// Mark the file as closed\r\n\t//m_pWBuf->BufFileUnset();\r\n\r\n}\r\n\r\n\r\n// Determine if the analyzed file is in a state ready for image\r\n// extraction. Confirms that the important JFIF markers have been\r\n// detected in the previous analysis.\r\n//\r\n// PRE:\r\n// - m_nPosEmbedStart\r\n// - m_nPosEmbedEnd\r\n// - m_nPosFileEnd \r\n//\r\n// RETURN:\r\n// - True if image is ready for extraction\r\n//\r\nbool CjfifDecode::ExportJpegPrepare(CString strFileIn,bool bForceSoi,bool bForceEoi,bool bIgnoreEoi)\r\n{\r\n\t// Extract from current file\r\n\t//   [m_nPosEmbedStart ... m_nPosEmbedEnd]\r\n\t// If state is valid (i.e. file opened)\r\n\r\n\tCString\t\tstrTmp = _T(\"\");\r\n\r\n\tm_pLog->AddLine(_T(\"\"));\r\n\tm_pLog->AddLineHdr(_T(\"*** Exporting JPEG ***\"));\r\n\r\n\tstrTmp.Format(_T(\"  Exporting from: [%s]\"),(LPCTSTR)strFileIn);\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\t// Only bother to extract if all main sections are present\r\n\tbool\t\tbExtractWarn = false;\r\n\tCString\t\tstrMissing = _T(\"\");\r\n\r\n\tif (!m_bStateEoi) {\r\n\t\tif (!bForceEoi && !bIgnoreEoi) {\r\n\t\t\tstrTmp.Format(_T(\"  ERROR: Missing marker: %s\"),_T(\"EOI\"));\r\n\t\t\tm_pLog->AddLineErr(strTmp);\r\n\t\t\tm_pLog->AddLineErr(_T(\"         Aborting export. Consider enabling [Force EOI] or [Ignore Missing EOI] option\"));\r\n\t\t\treturn false;\r\n\t\t} else if (bIgnoreEoi) {\r\n\t\t\t// Ignore the EOI, so mark the end of file, but don't\r\n\t\t\t// set the flag where we force one.\r\n\t\t\tm_nPosEmbedEnd = m_nPosFileEnd;\r\n\t\t} else {\r\n\t\t\t// We're missing the EOI but the user has requested\r\n\t\t\t// that we force an EOI, so let's fix things up\r\n\t\t\tm_nPosEmbedEnd = m_nPosFileEnd;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tif ((m_nPosEmbedStart == 0) && (m_nPosEmbedEnd == 0)) {\r\n\t\tstrTmp.Format(_T(\"  No frame found at this position in file. Consider using [Img Search]\"));\r\n\t\tm_pLog->AddLineErr(strTmp);\r\n\t\treturn false;\r\n\t}\r\n\r\n\tif (!m_bStateSoi) {\r\n\t\tif (!bForceSoi) {\r\n\t\t\tstrTmp.Format(_T(\"  ERROR: Missing marker: %s\"),_T(\"SOI\"));\r\n\t\t\tm_pLog->AddLineErr(strTmp);\r\n\t\t\tm_pLog->AddLineErr(_T(\"         Aborting export. Consider enabling [Force SOI] option\"));\r\n\t\t\treturn false;\r\n\t\t} else {\r\n\t\t\t// We're missing the SOI but the user has requested\r\n\t\t\t// that we force an SOI, so let's fix things up\r\n\t\t}\r\n\t\t\r\n\t}\r\n\tif (!m_bStateSos) {\r\n\t\tstrTmp.Format(_T(\"  ERROR: Missing marker: %s\"),_T(\"SOS\"));\r\n\t\tm_pLog->AddLineErr(strTmp);\r\n\t\tm_pLog->AddLineErr(_T(\"         Aborting export\"));\r\n\t\treturn false;\r\n\t}\r\n\r\n\tif (!m_bStateDqt) { bExtractWarn = true; strMissing += _T(\"DQT \"); }\r\n\tif (!m_bStateDht) { bExtractWarn = true; strMissing += _T(\"DHT \"); }\r\n\tif (!m_bStateSof) { bExtractWarn = true; strMissing += _T(\"SOF \"); }\r\n\t\r\n\tif (bExtractWarn) {\r\n\t\tstrTmp.Format(_T(\"  NOTE: Missing marker: %s\"),(LPCTSTR)strMissing);\r\n\t\tm_pLog->AddLineWarn(strTmp);\r\n\t\tm_pLog->AddLineWarn(_T(\"        Exported JPEG may not be valid\"));\r\n\t}\r\n\r\n\tif (m_nPosEmbedEnd < m_nPosEmbedStart) {\r\n\t\tstrTmp.Format(_T(\"ERROR: Invalid SOI-EOI order. Export aborted.\"));\r\n\t\tm_pLog->AddLineErr(strTmp);\r\n\t\tif (m_pAppConfig->bInteractive)\r\n\t\t\tAfxMessageBox(strTmp);\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\n\r\n\r\n#define EXPORT_BUF_SIZE 131072\r\n\r\n// Export the embedded JPEG image at the current position in the file (with overlays)\r\n// (may be the primary image or even an embedded thumbnail).\r\nbool CjfifDecode::ExportJpegDo(CString strFileIn, CString strFileOut, \r\n\t\t\tunsigned long nFileLen, bool bOverlayEn,bool bDhtAviInsert,bool bForceSoi,bool bForceEoi)\r\n{\r\n\tCFile*\t\tpFileOutput;\r\n\tCString\t\tstrTmp = _T(\"\");\r\n\r\n\tstrTmp.Format(_T(\"  Exporting to:   [%s]\"),(LPCTSTR)strFileOut);\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\tif (strFileIn == strFileOut) {\r\n\t\tstrTmp.Format(_T(\"ERROR: Can't overwrite source file. Aborting export.\"));\r\n\t\tm_pLog->AddLineErr(strTmp);\r\n\t\tif (m_pAppConfig->bInteractive)\r\n\t\t\tAfxMessageBox(strTmp);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tASSERT(strFileIn != _T(\"\"));\r\n\tif (strFileIn == _T(\"\")) {\r\n\t\tstrTmp.Format(_T(\"ERROR: Export but source filename empty\"));\r\n\t\tm_pLog->AddLineErr(strTmp);\r\n\t\tif (m_pAppConfig->bInteractive)\r\n\t\t\tAfxMessageBox(strTmp);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\r\n\r\n\ttry\r\n\t{\r\n\t\t// Open specified file\r\n\t\t// Added in shareDenyNone as this apparently helps resolve some people's troubles\r\n\t\t// with an error showing: Couldn't open file \"Sharing Violation\"\r\n\t\tpFileOutput = new CFile(strFileOut, CFile::modeCreate| CFile::modeWrite | CFile::typeBinary | CFile::shareDenyNone);\r\n\t}\r\n\tcatch (CFileException* e)\r\n\t{\r\n\t\tTCHAR msg[MAX_BUF_EX_ERR_MSG];\r\n\t\tCString strError;\r\n\t\te->GetErrorMessage(msg,MAX_BUF_EX_ERR_MSG);\r\n\t\te->Delete();\r\n\t\tstrError.Format(_T(\"ERROR: Couldn't open file for write [%s]: [%s]\"),\r\n\t\t\t(LPCTSTR)strFileOut, (LPCTSTR)msg);\r\n\t\tm_pLog->AddLineErr(strError);\r\n\t\tif (m_pAppConfig->bInteractive)\r\n\t\t\tAfxMessageBox(strError);\r\n\t\tpFileOutput = NULL;\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n\t// Don't attempt to load buffer with zero length file!\r\n\tif (nFileLen==0) {\r\n\t\tstrTmp.Format(_T(\"ERROR: Source file length error. Please Reprocess first.\"));\r\n\t\tm_pLog->AddLineErr(strTmp);\r\n\t\tif (m_pAppConfig->bInteractive)\r\n\t\t\tAfxMessageBox(strTmp);\r\n\r\n\t\tif (pFileOutput) { delete pFileOutput; pFileOutput = NULL; }\r\n\t\treturn false;\r\n\t}\r\n\r\n\r\n\t// Need to insert fake DHT. Assume we have enough buffer allocated.\r\n\t//\r\n\t// Step 1: Copy from SOI -> SOS (not incl)\r\n\t// Step 2: Insert Fake DHT\r\n\t// Step 3: Copy from SOS -> EOI\r\n\tunsigned\t\tnCopyStart;\r\n\tunsigned\t\tnCopyEnd;\r\n\tunsigned\t\tnCopyLeft;\r\n\tunsigned\t\tind;\r\n\r\n\tBYTE*\t\t\tpBuf;\r\n\r\n\tpBuf = new BYTE[EXPORT_BUF_SIZE+10];\r\n\tif (!pBuf) {\r\n\t\tif (pFileOutput) { delete pFileOutput; pFileOutput = NULL; }\r\n\t\treturn false;\r\n\t}\r\n\r\n\r\n\r\n\t// Step 1\r\n\r\n\t// If we need to force an SOI, do it now\r\n\tif (!m_bStateSoi && bForceSoi) {\r\n\t\tm_pLog->AddLine(_T(\"    Forcing SOI Marker\"));\r\n\t\tBYTE\tanBufSoi[2] = {0xFF,JFIF_SOI};\r\n\t\tpFileOutput->Write(&anBufSoi,2);\r\n\t}\r\n\r\n\tnCopyStart = m_nPosEmbedStart;\r\n\tnCopyEnd   = (m_nPosSos-1);\r\n\tind = nCopyStart;\r\n\twhile (ind<nCopyEnd) {\r\n\t\tnCopyLeft = nCopyEnd-ind+1;\r\n\t\tif (nCopyLeft>EXPORT_BUF_SIZE) { nCopyLeft = EXPORT_BUF_SIZE; }\r\n\t\tfor (unsigned ind1=0;ind1<nCopyLeft;ind1++) {\r\n\t\t\tpBuf[ind1] = Buf(ind+ind1,!bOverlayEn);\r\n\t\t}\r\n\t\tpFileOutput->Write(pBuf,nCopyLeft);\r\n\t\tind += nCopyLeft;\r\n\t\t// NOTE: We ensure nFileLen != 0 earlier\r\n\t\tASSERT(nFileLen>0);\r\n\t\tstrTmp.Format(_T(\"Exporting %3u%%...\"),ind*100/nFileLen);\r\n\t\tSetStatusText(strTmp);\r\n\t}\r\n\r\n\r\n\r\n\tif (bDhtAviInsert) {\r\n\t\t// Step 2. The following struct includes the JFIF marker too\r\n\t\tstrTmp.Format(_T(\"  Inserting standard AVI DHT huffman table\"));\r\n\t\tm_pLog->AddLine(strTmp);\r\n\t\tpFileOutput->Write(m_abMJPGDHTSeg,JFIF_DHT_FAKE_SZ);\r\n\t}\r\n\r\n\t// Step 3\r\n\tnCopyStart = m_nPosSos;\r\n\tnCopyEnd   = m_nPosEmbedEnd-1;\r\n\tind = nCopyStart;\r\n\twhile (ind<nCopyEnd) {\r\n\t\tnCopyLeft = nCopyEnd-ind+1;\r\n\t\tif (nCopyLeft>EXPORT_BUF_SIZE) { nCopyLeft = EXPORT_BUF_SIZE; }\r\n\t\tfor (unsigned ind1=0;ind1<nCopyLeft;ind1++) {\r\n\t\t\tpBuf[ind1] = Buf(ind+ind1,!bOverlayEn);\r\n\t\t}\r\n\t\tpFileOutput->Write(pBuf,nCopyLeft);\r\n\t\tind += nCopyLeft;\r\n\t\t// NOTE: We ensure nFileLen != 0 earlier\r\n\t\tASSERT(nFileLen>0);\r\n\t\tstrTmp.Format(_T(\"Exporting %3u%%...\"),ind*100/nFileLen);\r\n\t\tSetStatusText(strTmp);\r\n\t}\r\n\r\n\t// Now optionally insert the EOI Marker\r\n\tif (bForceEoi) {\r\n\t\tm_pLog->AddLine(_T(\"    Forcing EOI Marker\"));\r\n\t\tBYTE\tanBufEoi[2] = {0xFF,JFIF_EOI};\r\n\t\tpFileOutput->Write(&anBufEoi,2);\r\n\t}\r\n\r\n\r\n\t// Free up space\r\n\tpFileOutput->Close();\r\n\r\n\tif (pBuf) {\r\n\t\tdelete [] pBuf;\r\n\t\tpBuf = NULL;\r\n\t}\r\n\r\n\tif (pFileOutput) {\r\n\t\tdelete pFileOutput;\r\n\t\tpFileOutput = NULL;\r\n\t}\r\n\r\n\tSetStatusText(_T(\"\"));\r\n\tstrTmp.Format(_T(\"  Export done\"));\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\treturn true;\r\n}\r\n\r\n\r\n// Export a subset of the file with no overlays or mods\r\nbool CjfifDecode::ExportJpegDoRange(CString strFileIn, CString strFileOut, \r\n\t\t\tunsigned long nStart, unsigned long nEnd)\r\n{\r\n\tCFile*\t\tpFileOutput;\r\n\tCString\t\tstrTmp = _T(\"\");\r\n\r\n\tstrTmp.Format(_T(\"  Exporting range to:   [%s]\"),(LPCTSTR)strFileOut);\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\tif (strFileIn == strFileOut) {\r\n\t\tstrTmp.Format(_T(\"ERROR: Can't overwrite source file. Aborting export.\"));\r\n\t\tm_pLog->AddLineErr(strTmp);\r\n\t\tif (m_pAppConfig->bInteractive)\r\n\t\t\tAfxMessageBox(strTmp);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tASSERT(strFileIn != _T(\"\"));\r\n\tif (strFileIn == _T(\"\")) {\r\n\t\tstrTmp.Format(_T(\"ERROR: Export but source filename empty\"));\r\n\t\tm_pLog->AddLineErr(strTmp);\r\n\t\tif (m_pAppConfig->bInteractive)\r\n\t\t\tAfxMessageBox(strTmp);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\r\n\r\n\ttry\r\n\t{\r\n\t\t// Open specified file\r\n\t\t// Added in shareDenyNone as this apparently helps resolve some people's troubles\r\n\t\t// with an error showing: Couldn't open file \"Sharing Violation\"\r\n\t\tpFileOutput = new CFile(strFileOut, CFile::modeCreate| CFile::modeWrite | CFile::typeBinary | CFile::shareDenyNone);\r\n\t}\r\n\tcatch (CFileException* e)\r\n\t{\r\n\t\tTCHAR msg[MAX_BUF_EX_ERR_MSG];\r\n\t\tCString strError;\r\n\t\te->GetErrorMessage(msg,MAX_BUF_EX_ERR_MSG);\r\n\t\te->Delete();\r\n\t\tstrError.Format(_T(\"ERROR: Couldn't open file for write [%s]: [%s]\"),\r\n\t\t\t(LPCTSTR)strFileOut, (LPCTSTR)msg);\r\n\t\tm_pLog->AddLineErr(strError);\r\n\t\tif (m_pAppConfig->bInteractive)\r\n\t\t\tAfxMessageBox(strError);\r\n\t\tpFileOutput = NULL;\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n\r\n\tunsigned\t\tnCopyStart;\r\n\tunsigned\t\tnCopyEnd;\r\n\tunsigned\t\tnCopyLeft;\r\n\tunsigned\t\tind;\r\n\r\n\tBYTE*\t\t\tpBuf;\r\n\r\n\tpBuf = new BYTE[EXPORT_BUF_SIZE+10];\r\n\tif (!pBuf) {\r\n\t\tif (pFileOutput) { delete pFileOutput; pFileOutput = NULL; }\r\n\t\treturn false;\r\n\t}\r\n\r\n\r\n\r\n\t// Step 1\r\n\tnCopyStart = nStart;\r\n\tnCopyEnd   = nEnd;\r\n\tind = nCopyStart;\r\n\twhile (ind<nCopyEnd) {\r\n\t\tnCopyLeft = nCopyEnd-ind+1;\r\n\t\tif (nCopyLeft>EXPORT_BUF_SIZE) { nCopyLeft = EXPORT_BUF_SIZE; }\r\n\t\tfor (unsigned ind1=0;ind1<nCopyLeft;ind1++) {\r\n\t\t\tpBuf[ind1] = Buf(ind+ind1,false);\r\n\t\t}\r\n\t\tpFileOutput->Write(pBuf,nCopyLeft);\r\n\t\tind += nCopyLeft;\r\n\t\tstrTmp.Format(_T(\"Exporting %3u%%...\"),ind*100/(nCopyEnd-nCopyStart));\r\n\t\tSetStatusText(strTmp);\r\n\t}\r\n\r\n\r\n\t// Free up space\r\n\tpFileOutput->Close();\r\n\r\n\tif (pBuf) {\r\n\t\tdelete [] pBuf;\r\n\t\tpBuf = NULL;\r\n\t}\r\n\r\n\tif (pFileOutput) {\r\n\t\tdelete pFileOutput;\r\n\t\tpFileOutput = NULL;\r\n\t}\r\n\r\n\tSetStatusText(_T(\"\"));\r\n\tstrTmp.Format(_T(\"  Export range done\"));\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\treturn true;\r\n}\r\n\r\n\r\n// ====================================================================================\r\n// JFIF Decoder Constants\r\n// ====================================================================================\r\n\r\n// List of the JFIF markers\r\nconst MarkerNameTable CjfifDecode::m_pMarkerNames[] = {\r\n\t{JFIF_SOF0,_T(\"SOF0\")},\r\n\t{JFIF_SOF1,_T(\"SOF1\")},\r\n\t{JFIF_SOF2,_T(\"SOF2\")},\r\n\t{JFIF_SOF3,_T(\"SOF3\")},\r\n\t{JFIF_SOF5,_T(\"SOF5\")},\r\n\t{JFIF_SOF6,_T(\"SOF6\")},\r\n\t{JFIF_SOF7,_T(\"SOF7\")},\r\n\t{JFIF_JPG,_T(\"JPG\")},\r\n\t{JFIF_SOF9,_T(\"SOF9\")},\r\n\t{JFIF_SOF10,_T(\"SOF10\")},\r\n\t{JFIF_SOF11,_T(\"SOF11\")},\r\n\t{JFIF_SOF13,_T(\"SOF13\")},\r\n\t{JFIF_SOF14,_T(\"SOF14\")},\r\n\t{JFIF_SOF15,_T(\"SOF15\")},\r\n\t{JFIF_DHT,_T(\"DHT\")},\r\n\t{JFIF_DAC,_T(\"DAC\")},\r\n\t{JFIF_RST0,_T(\"RST0\")},\r\n\t{JFIF_RST1,_T(\"RST1\")},\r\n\t{JFIF_RST2,_T(\"RST2\")},\r\n\t{JFIF_RST3,_T(\"RST3\")},\r\n\t{JFIF_RST4,_T(\"RST4\")},\r\n\t{JFIF_RST5,_T(\"RST5\")},\r\n\t{JFIF_RST6,_T(\"RST6\")},\r\n\t{JFIF_RST7,_T(\"RST7\")},\r\n\t{JFIF_SOI,_T(\"SOI\")},\r\n\t{JFIF_EOI,_T(\"EOI\")},\r\n\t{JFIF_SOS,_T(\"SOS\")},\r\n\t{JFIF_DQT,_T(\"DQT\")},\r\n\t{JFIF_DNL,_T(\"DNL\")},\r\n\t{JFIF_DRI,_T(\"DRI\")},\r\n\t{JFIF_DHP,_T(\"DHP\")},\r\n\t{JFIF_EXP,_T(\"EXP\")},\r\n\t{JFIF_APP0,_T(\"APP0\")},\r\n\t{JFIF_APP1,_T(\"APP1\")},\r\n\t{JFIF_APP2,_T(\"APP2\")},\r\n\t{JFIF_APP3,_T(\"APP3\")},\r\n\t{JFIF_APP4,_T(\"APP4\")},\r\n\t{JFIF_APP5,_T(\"APP5\")},\r\n\t{JFIF_APP6,_T(\"APP6\")},\r\n\t{JFIF_APP7,_T(\"APP7\")},\r\n\t{JFIF_APP8,_T(\"APP8\")},\r\n\t{JFIF_APP9,_T(\"APP9\")},\r\n\t{JFIF_APP10,_T(\"APP10\")},\r\n\t{JFIF_APP11,_T(\"APP11\")},\r\n\t{JFIF_APP12,_T(\"APP12\")},\r\n\t{JFIF_APP13,_T(\"APP13\")},\r\n\t{JFIF_APP14,_T(\"APP14\")},\r\n\t{JFIF_APP15,_T(\"APP15\")},\r\n\t{JFIF_JPG0,_T(\"JPG0\")},\r\n\t{JFIF_JPG1,_T(\"JPG1\")},\r\n\t{JFIF_JPG2,_T(\"JPG2\")},\r\n\t{JFIF_JPG3,_T(\"JPG3\")},\r\n\t{JFIF_JPG4,_T(\"JPG4\")},\r\n\t{JFIF_JPG5,_T(\"JPG5\")},\r\n\t{JFIF_JPG6,_T(\"JPG6\")},\r\n\t{JFIF_JPG7,_T(\"JPG7\")},\r\n\t{JFIF_JPG8,_T(\"JPG8\")},\r\n\t{JFIF_JPG9,_T(\"JPG9\")},\r\n\t{JFIF_JPG10,_T(\"JPG10\")},\r\n\t{JFIF_JPG11,_T(\"JPG11\")},\r\n\t{JFIF_JPG12,_T(\"JPG12\")},\r\n\t{JFIF_JPG13,_T(\"JPG13\")},\r\n\t{JFIF_COM,_T(\"COM\")},\r\n\t{JFIF_TEM,_T(\"TEM\")},\r\n\t//{JFIF_RES*,_T(\"RES\")},\r\n\t{0x00,_T(\"*\")},\r\n};\r\n\r\n\r\n// For Motion JPEG, define the DHT tables that we use since they won't exist\r\n// in each frame within the AVI. This table will be read in during\r\n// DecodeDHT()'s call to Buf().\r\nconst BYTE CjfifDecode::m_abMJPGDHTSeg[JFIF_DHT_FAKE_SZ] = {\r\n\t/* JPEG DHT Segment for YCrCb omitted from MJPG data */\r\n\t0xFF,0xC4,0x01,0xA2,\r\n\t\t0x00,0x00,0x01,0x05,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\r\n\t\t0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x01,0x00,0x03,0x01,0x01,0x01,0x01,\r\n\t\t0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,\r\n\t\t0x08,0x09,0x0A,0x0B,0x10,0x00,0x02,0x01,0x03,0x03,0x02,0x04,0x03,0x05,0x05,0x04,0x04,0x00,\r\n\t\t0x00,0x01,0x7D,0x01,0x02,0x03,0x00,0x04,0x11,0x05,0x12,0x21,0x31,0x41,0x06,0x13,0x51,0x61,\r\n\t\t0x07,0x22,0x71,0x14,0x32,0x81,0x91,0xA1,0x08,0x23,0x42,0xB1,0xC1,0x15,0x52,0xD1,0xF0,0x24,\r\n\t\t0x33,0x62,0x72,0x82,0x09,0x0A,0x16,0x17,0x18,0x19,0x1A,0x25,0x26,0x27,0x28,0x29,0x2A,0x34,\r\n\t\t0x35,0x36,0x37,0x38,0x39,0x3A,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4A,0x53,0x54,0x55,0x56,\r\n\t\t0x57,0x58,0x59,0x5A,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x73,0x74,0x75,0x76,0x77,0x78,\r\n\t\t0x79,0x7A,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,\r\n\t\t0x9A,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,\r\n\t\t0xBA,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,\r\n\t\t0xDA,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,\r\n\t\t0xF8,0xF9,0xFA,0x11,0x00,0x02,0x01,0x02,0x04,0x04,0x03,0x04,0x07,0x05,0x04,0x04,0x00,0x01,\r\n\t\t0x02,0x77,0x00,0x01,0x02,0x03,0x11,0x04,0x05,0x21,0x31,0x06,0x12,0x41,0x51,0x07,0x61,0x71,\r\n\t\t0x13,0x22,0x32,0x81,0x08,0x14,0x42,0x91,0xA1,0xB1,0xC1,0x09,0x23,0x33,0x52,0xF0,0x15,0x62,\r\n\t\t0x72,0xD1,0x0A,0x16,0x24,0x34,0xE1,0x25,0xF1,0x17,0x18,0x19,0x1A,0x26,0x27,0x28,0x29,0x2A,\r\n\t\t0x35,0x36,0x37,0x38,0x39,0x3A,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4A,0x53,0x54,0x55,0x56,\r\n\t\t0x57,0x58,0x59,0x5A,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x73,0x74,0x75,0x76,0x77,0x78,\r\n\t\t0x79,0x7A,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x92,0x93,0x94,0x95,0x96,0x97,0x98,\r\n\t\t0x99,0x9A,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,\r\n\t\t0xB9,0xBA,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,\r\n\t\t0xD9,0xDA,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,\r\n\t\t0xF9,0xFA\r\n};\r\n\r\n\r\n\r\n// TODO: Add ITU-T Example DQT & DHT\r\n//       These will be useful for GeoRaster decode (ie. JPEG-B)\r\n\r\nCString\t\tglb_strMsgStopDecode = _T(\"  Stopping decode. Use [Relaxed Parsing] to continue.\");"], "fixing_code": ["// JPEGsnoop - JPEG Image Decoder & Analysis Utility\r\n// Copyright (C) 2017 - Calvin Hass\r\n// http://www.impulseadventure.com/photo/jpeg-snoop.html\r\n//\r\n//    This program is free software: you can redistribute it and/or modify\r\n//    it under the terms of the GNU General Public License as published by\r\n//    the Free Software Foundation, either version 2 of the License, or\r\n//    (at your option) any later version.\r\n//\r\n//    This program is distributed in the hope that it will be useful,\r\n//    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n//    GNU General Public License for more details.\r\n//\r\n//    You should have received a copy of the GNU General Public License\r\n//    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n//\r\n\r\n\r\n\r\n#include \"stdafx.h\"\r\n\r\n#include \"JfifDecode.h\"\r\n#include \"snoop.h\"\r\n#include \"JPEGsnoop.h\" // for m_pAppConfig get\r\n\r\n#include \"WindowBuf.h\"\r\n\r\n#include \"Md5.h\"\r\n\r\n#include \"afxinet.h\"\r\n\r\n#include \"windows.h\"\r\n#include \"UrlString.h\"\r\n#include \"DbSigs.h\"\r\n\r\n#include \"General.h\"\r\n\r\n\r\n\r\n// Maximum number of component values to extract into array for display\r\n#define MAX_anValues\t64\r\n\r\n\r\n// Clear out internal members\r\nvoid CjfifDecode::Reset()\r\n{\r\n\t// File handling\r\n\tm_nPos\t\t\t\t= 0;\r\n\tm_nPosSos\t\t\t= 0;\r\n\tm_nPosEoi\t\t\t= 0;\r\n\tm_nPosEmbedStart\t= 0;\r\n\tm_nPosEmbedEnd\t\t= 0;\r\n\tm_nPosFileEnd\t\t= 0;\r\n\r\n\t// SOS / SOF handling\r\n\tm_nSofNumLines_Y\t\t= 0;\r\n\tm_nSofSampsPerLine_X\t= 0;\r\n\tm_nSofNumComps_Nf\t\t= 0;\r\n\r\n\t// Quantization tables\r\n\tClearDQT();\r\n\r\n\t// Photoshop\r\n\tm_nImgQualPhotoshopSfw\t= 0;\r\n\tm_nImgQualPhotoshopSa\t= 0;\r\n\r\n\tm_nApp14ColTransform = -1;\r\n\r\n\t// Restart marker\r\n\tm_nImgRstEn\t\t\t\t= false;\r\n\tm_nImgRstInterval\t\t= 0;\r\n\r\n\t// Basic metadata\r\n\tm_strImgExifMake\t\t= _T(\"???\");\r\n\tm_nImgExifMakeSubtype\t= 0;\r\n\tm_strImgExifModel\t\t= _T(\"???\");\r\n\tm_bImgExifMakernotes\t= false;\r\n\tm_strImgExtras\t\t\t= _T(\"\");\r\n\tm_strComment\t\t\t= _T(\"\");\r\n\tm_strSoftware\t\t\t= _T(\"\");\r\n\tm_bImgProgressive\t\t= false;\r\n\tm_bImgSofUnsupported\t= false;\r\n\t_tcscpy_s(m_acApp0Identifier,_T(\"\"));\r\n\r\n\t// Derived metadata\r\n\tm_strHash\t\t\t\t= _T(\"NONE\");\r\n\tm_strHashRot\t\t\t= _T(\"NONE\");\r\n\tm_eImgLandscape\t\t\t= ENUM_LANDSCAPE_UNSET;\r\n\tm_strImgQualExif\t\t= _T(\"\");\r\n\tm_bAvi\t\t\t\t\t= false;\r\n\tm_bAviMjpeg\t\t\t\t= false;\r\n\tm_bPsd\t\t\t\t\t= false;\r\n\r\n\t// Misc\r\n\tm_bImgOK\t\t\t\t= false;\t\t// Set during SOF to indicate further proc OK\r\n\tm_bBufFakeDHT\t   \t\t= false;\t\t\t// Start in normal Buf mode\r\n\tm_eImgEdited\t\t\t= EDITED_UNSET;\r\n\tm_eDbReqSuggest\t \t\t= DB_ADD_SUGGEST_UNSET;\r\n\tm_bSigExactInDB\t \t\t= false;\r\n\r\n\t// Embedded thumbnail\r\n\tm_nImgExifThumbComp\t\t= 0;\r\n\tm_nImgExifThumbOffset\t= 0;\r\n\tm_nImgExifThumbLen\t\t= 0;\r\n\tm_strHashThumb\t\t\t= _T(\"NONE\");\t\t// Will go into DB to say NONE!\r\n\tm_strHashThumbRot\t\t= _T(\"NONE\");\t\t// Will go into DB to say NONE!\r\n\tm_nImgThumbNumLines\t\t= 0;\r\n\tm_nImgThumbSampsPerLine\t= 0;\r\n\r\n\t// Now clear out any previously generated bitmaps\r\n\t// or image decoding parameters\r\n\tif (m_pImgDec) {\r\n\t\tif (m_pImgSrcDirty) {\r\n\t\t\tm_pImgDec->Reset();\r\n\t\t}\r\n\t}\r\n\r\n\t// Reset the decoding state checks\r\n\t// These are to help ensure we don't start decoding SOS\r\n\t// if we haven't seen other valid markers yet! Otherwise\r\n\t// we could run into very bad loops (e.g. .PSD files)\r\n\t// just because we saw FFD8FF first then JFIF_SOS\r\n\tm_bStateAbort\t= false;\r\n\tm_bStateSoi\t\t= false;\r\n\tm_bStateDht\t\t= false;\r\n\tm_bStateDhtOk\t= false;\r\n\tm_bStateDhtFake = false;\r\n\tm_bStateDqt\t\t= false;\r\n\tm_bStateDqtOk\t= false;\r\n\tm_bStateSof\t\t= false;\r\n\tm_bStateSofOk\t= false;\r\n\tm_bStateSos\t\t= false;\r\n\tm_bStateSosOk\t= false;\r\n\tm_bStateEoi\t\t= false;\r\n\r\n}\r\n\r\n\r\n// Initialize the JFIF decoder. Several class pointers are provided\r\n// as parameters, so that we can directly access the output log, the\r\n// file buffer and the image scan decoder.\r\n// Loads up the signature database.\r\n//\r\n// INPUT:\r\n// - pLog\t\t\tPtr to log file class\r\n// - pWBuf\t\t\tPtr to Window Buf class\r\n// - pImgDec\t\tPtr to Image Decoder class\r\n//\r\n// PRE:\r\n// - Requires that CDocLog, CwindowBuf and CimgDecode classes\r\n//   are already initialized\r\n//\r\nCjfifDecode::CjfifDecode(CDocLog* pLog,CwindowBuf* pWBuf,CimgDecode* pImgDec)\r\n{\r\n\t// Ideally this would be passed by constructor, but simply access\r\n\t// directly for now.\r\n\tCJPEGsnoopApp*\tpApp;\r\n\tpApp = (CJPEGsnoopApp*)AfxGetApp();\r\n    m_pAppConfig = pApp->m_pAppConfig;\r\n\tASSERT(m_pAppConfig);\r\n\tif (DEBUG_EN) m_pAppConfig->DebugLogAdd(_T(\"CjfifDecode::CjfifDecode() Begin\"));\r\n\r\n\tASSERT(pLog);\r\n\tASSERT(pWBuf);\r\n\tASSERT(pImgDec);\r\n\r\n\t// Need to zero out the private members\r\n\tm_bOutputDB = FALSE;\t\t// mySQL output for web\r\n\r\n\t// Enable verbose reporting\r\n\tm_bVerbose = FALSE;\r\n\r\n\tm_pImgSrcDirty = TRUE;\r\n\r\n\t// Generate lookup tables for Huffman codes\r\n\tGenLookupHuffMask();\r\n\tif (DEBUG_EN) m_pAppConfig->DebugLogAdd(_T(\"CjfifDecode::CjfifDecode() Checkpoint 1\"));\r\n\r\n\t// Window status bar is not ready yet, wait for call to SetStatusBar()\r\n\tm_pStatBar = NULL;\r\n\r\n\t// Save copies of other class pointers\r\n\tm_pLog = pLog;\r\n\tm_pWBuf = pWBuf;\r\n\tm_pImgDec = pImgDec;\r\n\r\n\t// Reset decoding state\r\n\tReset();\r\n\tif (DEBUG_EN) m_pAppConfig->DebugLogAdd(_T(\"CjfifDecode::CjfifDecode() Checkpoint 2\"));\r\n\r\n\t// Load the local database (if it exists)\r\n\ttheApp.m_pDbSigs->DatabaseExtraLoad();\r\n\tif (DEBUG_EN) m_pAppConfig->DebugLogAdd(_T(\"CjfifDecode::CjfifDecode() Checkpoint 3\"));\r\n\r\n\t// Allocate the Photoshop decoder\r\n\tm_pPsDec = new CDecodePs(pWBuf,pLog);\r\n\tif (!m_pPsDec) {\r\n\t\tASSERT(false);\r\n\t\treturn;\r\n\t}\r\n\tif (DEBUG_EN) m_pAppConfig->DebugLogAdd(_T(\"CjfifDecode::CjfifDecode() Checkpoint 4\"));\r\n\r\n#ifdef SUPPORT_DICOM\r\n\t// Allocate the DICOM decoder\r\n\tm_pDecDicom = new CDecodeDicom(pWBuf,pLog);\r\n\tif (!m_pDecDicom) {\r\n\t\tASSERT(false);\r\n\t\treturn;\r\n\t}\r\n\tif (DEBUG_EN) m_pAppConfig->DebugLogAdd(_T(\"CjfifDecode::CjfifDecode() Checkpoint 5\"));\r\n#endif\r\n\r\n\tif (DEBUG_EN) m_pAppConfig->DebugLogAdd(_T(\"CjfifDecode::CjfifDecode() End\"));\r\n}\r\n\r\n// Destructor\r\nCjfifDecode::~CjfifDecode()\r\n{\r\n\t// Free the Photoshop decoder\r\n\tif (m_pPsDec) {\r\n\t\tdelete m_pPsDec;\r\n\t\tm_pPsDec = NULL;\r\n\t}\r\n\r\n#ifdef SUPPORT_DICOM\r\n\t// Free the DICOM decoder\r\n\tif (m_pDecDicom) {\r\n\t\tdelete m_pDecDicom;\r\n\t\tm_pDecDicom = NULL;\r\n\t}\r\n#endif\r\n\r\n}\r\n\r\n// Asynchronously update a local pointer to the status bar once\r\n// it becomes available. Note that the status bar is not ready by\r\n// the time of the CjfifDecode class constructor call.\r\n//\r\n// INPUT:\r\n// - pStatBar\t\t\tPtr to status bar\r\n//\r\n// POST:\r\n// - m_pStatBar\r\n//\r\nvoid CjfifDecode::SetStatusBar(CStatusBar* pStatBar)\r\n{\r\n\tm_pStatBar = pStatBar;\r\n}\r\n\r\n\r\n// Indicate that the source of the image scan data\r\n// has been dirtied. Either the source has changed\r\n// or some of the View2 options have changed.\r\n//\r\n// POST:\r\n// - m_pImgSrcDirty\r\n//\r\nvoid CjfifDecode::ImgSrcChanged()\r\n{\r\n\tm_pImgSrcDirty = true;\r\n}\r\n\r\n\r\n// Set the AVI mode flag for this file\r\n//\r\n// POST:\r\n// - m_bAvi\r\n// - m_bAviMjpeg\r\n//\r\nvoid CjfifDecode::SetAviMode(bool bIsAvi,bool bIsMjpeg)\r\n{\r\n\tm_bAvi = bIsAvi;\r\n\tm_bAviMjpeg = bIsMjpeg;\r\n}\r\n\r\n// Fetch the AVI mode flag for this file\r\n//\r\n// PRE:\r\n// - m_bAvi\r\n// - m_bAviMjpeg\r\n//\r\n// OUTPUT:\r\n// - bIsAvi\r\n// - bIsMjpeg\r\n//\r\nvoid CjfifDecode::GetAviMode(bool &bIsAvi,bool &bIsMjpeg)\r\n{\r\n\tbIsAvi = m_bAvi;\r\n\tbIsMjpeg = m_bAviMjpeg;\r\n}\r\n\r\n// Fetch the starting file position of the embedded thumbnail\r\n//\r\n// PRE:\r\n// - m_nPosEmbedStart\r\n//\r\n// RETURN:\r\n// - File position\r\n//\r\nunsigned long CjfifDecode::GetPosEmbedStart()\r\n{\r\n\treturn m_nPosEmbedStart;\r\n}\r\n\r\n// Fetch the ending file position of the embedded thumbnail\r\n//\r\n// PRE:\r\n// - m_nPosEmbedEnd\r\n//\r\n// RETURN:\r\n// - File position\r\n//\r\nunsigned long CjfifDecode::GetPosEmbedEnd()\r\n{\r\n\treturn m_nPosEmbedEnd;\r\n}\r\n\r\n// Determine if the last analysis revealed a JFIF with known markers\r\n//\r\n// RETURN:\r\n// - TRUE if file (at position during analysis) appeared to decode OK\r\n//\r\nbool CjfifDecode::GetDecodeStatus()\r\n{\r\n\treturn m_bImgOK;\r\n}\r\n\r\n// Fetch a summary of the JFIF decoder results\r\n// These details are used in preparation of signature submission to the DB\r\n//\r\n// PRE:\r\n// - m_strHash\r\n// - m_strHashRot\r\n// - m_strImgExifMake\r\n// - m_strImgExifModel\r\n// - m_strImgQualExif\r\n// - m_strSoftware\r\n// - m_eDbReqSuggest\r\n//\r\n// OUTPUT:\r\n// - strHash\r\n// - strHashRot\r\n// - strImgExifMake\r\n// - strImgExifModel\r\n// - strImgQualExif\r\n// - strSoftware\r\n// - nDbReqSuggest\r\n//\r\nvoid CjfifDecode::GetDecodeSummary(CString &strHash,CString &strHashRot,CString &strImgExifMake,CString &strImgExifModel,\r\n\t\t\t\t\t\t\tCString &strImgQualExif,CString &strSoftware,teDbAdd &eDbReqSuggest)\r\n{\r\n\tstrHash = m_strHash;\r\n\tstrHashRot = m_strHashRot;\r\n\tstrImgExifMake = m_strImgExifMake;\r\n\tstrImgExifModel = m_strImgExifModel;\r\n\tstrImgQualExif = m_strImgQualExif;\r\n\tstrSoftware = m_strSoftware;\r\n\teDbReqSuggest = m_eDbReqSuggest;\r\n}\r\n\r\n// Fetch an element from the \"standard\" luminance quantization table\r\n//\r\n// PRE:\r\n// - glb_anStdQuantLum[]\r\n//\r\n// RETURN:\r\n// - DQT matrix element\r\n//\r\nunsigned CjfifDecode::GetDqtQuantStd(unsigned nInd)\r\n{\r\n\tif (nInd < MAX_DQT_COEFF) {\r\n\t\treturn glb_anStdQuantLum[nInd];\r\n\t} else {\r\n#ifdef DEBUG_LOG\r\n\t\tCString\tstrTmp;\r\n\t\tCString\tstrDebug;\r\n\t\tstrTmp.Format(_T(\"GetDqtQuantStd() with nInd out of range. nInd=[%u]\"),nInd);\r\n\t\tstrDebug.Format(_T(\"## File=[%-100s] Block=[%-10s] Error=[%s]\\n\"),(LPCTSTR)m_pAppConfig->strCurFname,\r\n\t\t\t_T(\"JfifDecode\"),(LPCTSTR)strTmp);\r\n\t\tOutputDebugString(strDebug);\r\n#else\r\n\t\tASSERT(false);\r\n#endif\r\n\t\treturn 0;\r\n\t}\r\n}\r\n\r\n// Fetch the DQT ordering index (with optional zigzag sequence)\r\n//\r\n// INPUT:\r\n// - nInd\t\t\tCoefficient index\r\n// - bZigZag\t\tUse zig-zag ordering\r\n//\r\n// RETURN:\r\n// - Sequence index\r\n//\r\nunsigned CjfifDecode::GetDqtZigZagIndex(unsigned nInd,bool bZigZag)\r\n{\r\n\tif (nInd < MAX_DQT_COEFF) {\r\n\t\tif (bZigZag) {\r\n\t\t\treturn nInd;\r\n\t\t} else {\r\n\t\t\treturn glb_anZigZag[nInd];\r\n\t\t}\r\n\t} else {\r\n#ifdef DEBUG_LOG\r\n\t\tCString\tstrTmp;\r\n\t\tCString\tstrDebug;\r\n\t\tstrTmp.Format(_T(\"GetDqtZigZagIndex() with nInd out of range. nInd=[%u]\"),nInd);\r\n\t\tstrDebug.Format(_T(\"## File=[%-100s] Block=[%-10s] Error=[%s]\\n\"),(LPCTSTR)m_pAppConfig->strCurFname,\r\n\t\t\t_T(\"JfifDecode\"),(LPCTSTR)strTmp);\r\n\t\tOutputDebugString(strDebug);\r\n#else\r\n\t\tASSERT(false);\r\n#endif\r\n\t\treturn 0;\r\n\t}\r\n}\r\n\r\n// Reset the DQT tables\r\n//\r\n// POST:\r\n// - m_anImgDqtTbl[][]\r\n// - m_anImgThumbDqt[][]\r\n// - m_adImgDqtQual[]\r\n// - m_abImgDqtSet[]\r\n// - m_abImgDqtThumbSet[]\r\n//\r\nvoid CjfifDecode::ClearDQT()\r\n{\r\n\tfor (unsigned nTblInd=0;nTblInd<MAX_DQT_DEST_ID;nTblInd++)\r\n\t{\r\n\t\tfor (unsigned nCoeffInd=0;nCoeffInd<MAX_DQT_COEFF;nCoeffInd++)\r\n\t\t{\r\n\t\t\tm_anImgDqtTbl[nTblInd][nCoeffInd] = 0;\r\n\t\t\tm_anImgThumbDqt[nTblInd][nCoeffInd] = 0;\r\n\t\t}\r\n\t\tm_adImgDqtQual[nTblInd] = 0;\r\n\t\tm_abImgDqtSet[nTblInd] = false;\r\n\t\tm_abImgDqtThumbSet[nTblInd] = false;\r\n\t}\r\n}\r\n\r\n// Set the DQT matrix element\r\n//\r\n// INPUT:\r\n// - dqt0[]\t\t\t\tMatrix array for table 0\r\n// - dqt1[]\t\t\t\tMatrix array for table 1\r\n//\r\n// POST:\r\n// - m_anImgDqtTbl[][]\r\n// - m_eImgLandscape\r\n// - m_abImgDqtSet[]\r\n// - m_strImgQuantCss\r\n//\r\nvoid CjfifDecode::SetDQTQuick(unsigned anDqt0[64],unsigned anDqt1[64])\r\n{\r\n\tm_eImgLandscape = ENUM_LANDSCAPE_YES;\r\n\tfor (unsigned ind=0;ind<MAX_DQT_COEFF;ind++)\r\n\t{\r\n\t\tm_anImgDqtTbl[0][ind] = anDqt0[ind];\r\n\t\tm_anImgDqtTbl[1][ind] = anDqt1[ind];\r\n\t}\r\n\tm_abImgDqtSet[0] = true;\r\n\tm_abImgDqtSet[1] = true;\r\n\tm_strImgQuantCss = _T(\"NA\");\r\n}\r\n\r\n// Construct a lookup table for the Huffman code masks\r\n// The result is a simple bit sequence of zeros followed by\r\n// an increasing number of 1 bits.\r\n//   00000000...00000001\r\n//   00000000...00000011\r\n//   00000000...00000111\r\n//   ...\r\n//   01111111...11111111\r\n//   11111111...11111111\r\n//\r\n// POST:\r\n// - m_anMaskLookup[]\r\n//\r\nvoid CjfifDecode::GenLookupHuffMask()\r\n{\r\n\tunsigned int mask;\r\n\tfor (unsigned len=0;len<32;len++)\r\n\t{\r\n\t\tmask = (1 << (len))-1;\r\n\t\tmask <<= 32-len;\r\n\t\tm_anMaskLookup[len] = mask;\r\n\t}\r\n}\r\n\r\n\r\n// Provide a short-hand alias for the m_pWBuf buffer\r\n// Also support redirection to a local table in case we are\r\n// faking out the DHT (eg. for MotionJPEG files).\r\n//\r\n// PRE:\r\n// - m_bBufFakeDHT\t\t\tFlag to include Fake DHT table\r\n// - m_abMJPGDHTSeg[]\t\tDHT table used if m_bBufFakeDHT=true\r\n//\r\n// INPUT:\r\n// - nOffset\t\t\t\tFile offset to read from\r\n// - bClean\t\t\t\t\tForcibly disables any redirection to Fake DHT table\r\n//\r\n// POST:\r\n// - m_pLog\r\n//\r\n// RETURN:\r\n// - Byte from file (or local table)\r\n//\r\nBYTE CjfifDecode::Buf(unsigned long nOffset,bool bClean=false)\r\n{\r\n\t// Buffer can be redirected to internal array for AVI DHT\r\n\t// tables, so check for it here.\r\n\tif (m_bBufFakeDHT) {\r\n\t\treturn m_abMJPGDHTSeg[nOffset];\r\n\t} else {\r\n\t\treturn m_pWBuf->Buf(nOffset,bClean);\r\n\t}\r\n}\r\n\r\n// Write out a line to the log buffer if we are in verbose mode\r\n//\r\n// PRE:\r\n// - m_bVerbose\t\t\t\tVerbose mode\r\n//\r\n// INPUT:\r\n// - strLine\t\t\t\tString to output\r\n//\r\n// OUTPUT:\r\n// - none\r\n//\r\n// POST:\r\n// - m_pLog\r\n//\r\n// RETURN:\r\n// - none\r\n//\r\nvoid CjfifDecode::DbgAddLine(LPCTSTR strLine)\r\n{\r\n\tif (m_bVerbose)\r\n\t{\r\n\t\tm_pLog->AddLine(strLine);\r\n\t}\r\n}\r\n\r\n// Convert a UINT32 and decompose into 4 bytes, but support\r\n// either endian byte-swap mode\r\n//\r\n// PRE:\r\n// - m_nImgExifEndian\t\tByte swap mode (0=little, 1=big)\r\n//\r\n// INPUT:\r\n// - nVal\t\t\t\t\tInput UINT32\r\n//\r\n// OUTPUT:\r\n// - nByte0\t\t\t\t\tByte #1\r\n// - nByte1\t\t\t\t\tByte #2\r\n// - nByte2\t\t\t\t\tByte #3\r\n// - nByte3\t\t\t\t\tByte #4\r\n//\r\n// RETURN:\r\n// - none\r\n//\r\nvoid CjfifDecode::UnByteSwap4(unsigned nVal,unsigned &nByte0,unsigned &nByte1,unsigned &nByte2,unsigned &nByte3)\r\n{\r\n\tif (m_nImgExifEndian == 0) {\r\n\t\t// Little Endian\r\n\t\tnByte3 = (nVal & 0xFF000000) >> 24;\r\n\t\tnByte2 = (nVal & 0x00FF0000) >> 16;\r\n\t\tnByte1 = (nVal & 0x0000FF00) >> 8;\r\n\t\tnByte0 = (nVal & 0x000000FF);\r\n\t} else {\r\n\t\t// Big Endian\r\n\t\tnByte0 = (nVal & 0xFF000000) >> 24;\r\n\t\tnByte1 = (nVal & 0x00FF0000) >> 16;\r\n\t\tnByte2 = (nVal & 0x0000FF00) >> 8;\r\n\t\tnByte3 = (nVal & 0x000000FF);\r\n\t}\r\n}\r\n\r\n// Perform conversion from 4 bytes into UINT32 with\r\n// endian byte-swapping support\r\n//\r\n// PRE:\r\n// - m_nImgExifEndian\t\tByte swap mode (0=little, 1=big)\r\n//\r\n// INPUT:\r\n// - nByte0\t\t\t\t\t\tByte #1\r\n// - nByte1\t\t\t\t\t\tByte #2\r\n// - nByte2\t\t\t\t\t\tByte #3\r\n// - nByte3\t\t\t\t\t\tByte #4\r\n//\r\n// RETURN:\r\n// - UINT32\r\n//\r\nunsigned CjfifDecode::ByteSwap4(unsigned nByte0,unsigned nByte1, unsigned nByte2, unsigned nByte3)\r\n{\r\n\tunsigned nVal;\r\n\r\n\tif (m_nImgExifEndian == 0) {\r\n\t\t// Little endian, byte swap required\r\n\t\tnVal = (nByte3<<24) + (nByte2<<16) + (nByte1<<8) + nByte0;\r\n\t} else {\r\n\t\t// Big endian, no swap required\r\n\t\tnVal = (nByte0<<24) + (nByte1<<16) + (nByte2<<8) + nByte3;\r\n\t}\r\n\treturn nVal;\r\n}\r\n\r\n// Perform conversion from 2 bytes into half-word with\r\n// endian byte-swapping support\r\n//\r\n// PRE:\r\n// - m_nImgExifEndian\t\tByte swap mode (0=little, 1=big)\r\n//\r\n// INPUT:\r\n// - nByte0\t\t\t\t\t\tByte #1\r\n// - nByte1\t\t\t\t\t\tByte #2\r\n//\r\n// RETURN:\r\n// - UINT16\r\n//\r\nunsigned CjfifDecode::ByteSwap2(unsigned nByte0,unsigned nByte1)\r\n{\r\n\tunsigned nVal;\r\n\tif (m_nImgExifEndian == 0) {\r\n\t\t// Little endian, byte swap required\r\n\t\tnVal = (nByte1<<8) + nByte0;\r\n\t} else {\r\n\t\t// Big endian, no swap required\r\n\t\tnVal = (nByte0<<8) + nByte1;\r\n\t}\r\n\treturn nVal;\r\n}\r\n\r\n// Decode Canon Makernotes\r\n// Only the most common makernotes are supported; there are a large\r\n// number of makernotes that have not been documented anywhere.\r\nCStr2 CjfifDecode::LookupMakerCanonTag(unsigned nMainTag,unsigned nSubTag,unsigned nVal)\r\n{\r\n\tCString\t\tstrTmp;\r\n\tCStr2\t\tsRetVal;\r\n\r\n\tsRetVal.strTag = _T(\"???\");\r\n\tsRetVal.bUnknown = false;\t\t\t\t// Set to true in default clauses\r\n\tsRetVal.strVal.Format(_T(\"%u\"),nVal);\t// Provide default value\r\n\r\n\tunsigned nValHi,nValLo;\r\n\tnValHi = (nVal & 0xff00) >> 8;\r\n\tnValLo = (nVal & 0x00ff);\r\n\r\n\tswitch(nMainTag)\r\n\t{\r\n\r\n\tcase 0x0001:\r\n\r\n\t\tswitch(nSubTag)\r\n\t\t{\r\n\t\tcase 0x0001: sRetVal.strTag = _T(\"Canon.Cs1.Macro\");break; // Short Macro mode \r\n\t\tcase 0x0002: sRetVal.strTag = _T(\"Canon.Cs1.Selftimer\");break; // Short Self timer \r\n\t\tcase 0x0003: sRetVal.strTag = _T(\"Canon.Cs1.Quality\");\r\n\t\t\tif (nVal == 2) { sRetVal.strVal = _T(\"norm\"); }\r\n\t\t\telse if (nVal == 3) { sRetVal.strVal = _T(\"fine\"); }\r\n\t\t\telse if (nVal == 5) { sRetVal.strVal = _T(\"superfine\"); }\r\n\t\t\telse {\r\n\t\t\t\tsRetVal.strVal = _T(\"?\");\r\n\t\t\t}\r\n\t\t\t// Save the quality string for later\r\n\t\t\tm_strImgQualExif = sRetVal.strVal;\r\n\t\t\tbreak; // Short Quality \r\n\t\tcase 0x0004: sRetVal.strTag = _T(\"Canon.Cs1.FlashMode\");break; // Short Flash mode setting \r\n\t\tcase 0x0005: sRetVal.strTag = _T(\"Canon.Cs1.DriveMode\");break; // Short Drive mode setting \r\n\t\tcase 0x0007: sRetVal.strTag = _T(\"Canon.Cs1.FocusMode\"); // Short Focus mode setting \r\n\t\t\tswitch(nVal) {\r\n\t\t\t\tcase 0 : sRetVal.strVal = _T(\"One-shot\");break;\r\n\t\t\t\tcase 1 : sRetVal.strVal = _T(\"AI Servo\");break;\r\n\t\t\t\tcase 2 : sRetVal.strVal = _T(\"AI Focus\");break;\r\n\t\t\t\tcase 3 : sRetVal.strVal = _T(\"Manual Focus\");break;\r\n\t\t\t\tcase 4 : sRetVal.strVal = _T(\"Single\");break;\r\n\t\t\t\tcase 5 : sRetVal.strVal = _T(\"Continuous\");break;\r\n\t\t\t\tcase 6 : sRetVal.strVal = _T(\"Manual Focus\");break;\r\n\t\t\t\tdefault : sRetVal.strVal = _T(\"?\");break;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 0x000a: sRetVal.strTag = _T(\"Canon.Cs1.ImageSize\"); // Short Image size \r\n\t\t\tif (nVal == 0) { sRetVal.strVal = _T(\"Large\"); }\r\n\t\t\telse if (nVal == 1) { sRetVal.strVal = _T(\"Medium\"); }\r\n\t\t\telse if (nVal == 2) { sRetVal.strVal = _T(\"Small\"); }\r\n\t\t\telse {\r\n\t\t\t\tsRetVal.strVal = _T(\"?\");\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 0x000b: sRetVal.strTag = _T(\"Canon.Cs1.EasyMode\");break; // Short Easy shooting mode \r\n\t\tcase 0x000c: sRetVal.strTag = _T(\"Canon.Cs1.DigitalZoom\");break; // Short Digital zoom \r\n\t\tcase 0x000d: sRetVal.strTag = _T(\"Canon.Cs1.Contrast\");break; // Short Contrast setting \r\n\t\tcase 0x000e: sRetVal.strTag = _T(\"Canon.Cs1.Saturation\");break; // Short Saturation setting \r\n\t\tcase 0x000f: sRetVal.strTag = _T(\"Canon.Cs1.Sharpness\");break; // Short Sharpness setting \r\n\t\tcase 0x0010: sRetVal.strTag = _T(\"Canon.Cs1.ISOSpeed\");break; // Short ISO speed setting \r\n\t\tcase 0x0011: sRetVal.strTag = _T(\"Canon.Cs1.MeteringMode\");break; // Short Metering mode setting \r\n\t\tcase 0x0012: sRetVal.strTag = _T(\"Canon.Cs1.FocusType\");break; // Short Focus type setting \r\n\t\tcase 0x0013: sRetVal.strTag = _T(\"Canon.Cs1.AFPoint\");break; // Short AF point selected \r\n\t\tcase 0x0014: sRetVal.strTag = _T(\"Canon.Cs1.ExposureProgram\");break; // Short Exposure mode setting \r\n\t\tcase 0x0016: sRetVal.strTag = _T(\"Canon.Cs1.LensType\");break; // \r\n\t\tcase 0x0017: sRetVal.strTag = _T(\"Canon.Cs1.Lens\");break; // Short 'long' and 'short' focal length of lens (in 'focal m_nImgUnits') and 'focal m_nImgUnits' per mm \r\n\t\tcase 0x001a: sRetVal.strTag = _T(\"Canon.Cs1.MaxAperture\");break; // \r\n\t\tcase 0x001b: sRetVal.strTag = _T(\"Canon.Cs1.MinAperture\");break; // \r\n\t\tcase 0x001c: sRetVal.strTag = _T(\"Canon.Cs1.FlashActivity\");break; // Short Flash activity \r\n\t\tcase 0x001d: sRetVal.strTag = _T(\"Canon.Cs1.FlashDetails\");break; // Short Flash details \r\n\t\tcase 0x0020: sRetVal.strTag = _T(\"Canon.Cs1.FocusMode\");break; // Short Focus mode setting \r\n\t\tdefault:\r\n\t\t\tsRetVal.strTag.Format(_T(\"Canon.Cs1.x%04X\"),nSubTag);\r\n\t\t\tsRetVal.bUnknown = true;\r\n\t\t\tbreak;\r\n\t\t} // switch nSubTag\r\n\t\tbreak;\r\n\r\n\tcase 0x0004:\r\n\r\n\t\tswitch(nSubTag)\r\n\t\t{\r\n\t\tcase 0x0002: sRetVal.strTag = _T(\"Canon.Cs2.ISOSpeed\");break; // Short ISO speed used \r\n\t\tcase 0x0004: sRetVal.strTag = _T(\"Canon.Cs2.TargetAperture\");break; // Short Target Aperture \r\n\t\tcase 0x0005: sRetVal.strTag = _T(\"Canon.Cs2.TargetShutterSpeed\");break; // Short Target shutter speed \r\n\t\tcase 0x0007: sRetVal.strTag = _T(\"Canon.Cs2.WhiteBalance\");break; // Short White balance setting \r\n\t\tcase 0x0009: sRetVal.strTag = _T(\"Canon.Cs2.Sequence\");break; // Short Sequence number (if in a continuous burst) \r\n\t\tcase 0x000e: sRetVal.strTag = _T(\"Canon.Cs2.AFPointUsed\");break; // Short AF point used \r\n\t\tcase 0x000f: sRetVal.strTag = _T(\"Canon.Cs2.FlashBias\");break; // Short Flash bias \r\n\t\tcase 0x0013: sRetVal.strTag = _T(\"Canon.Cs2.SubjectDistance\");break; // Short Subject distance (m_nImgUnits are not clear) \r\n\t\tcase 0x0015: sRetVal.strTag = _T(\"Canon.Cs2.ApertureValue\");break; // Short Aperture \r\n\t\tcase 0x0016: sRetVal.strTag = _T(\"Canon.Cs2.ShutterSpeedValue\");break; // Short Shutter speed \r\n\t\tdefault:\r\n\t\t\tsRetVal.strTag.Format(_T(\"Canon.Cs2.x%04X\"),nSubTag);\r\n\t\t\tsRetVal.bUnknown = true;\r\n\t\t\tbreak;\r\n\t\t} // switch nSubTag\r\n\t\tbreak;\r\n\r\n\tcase 0x000F:\r\n\r\n\t\t// CustomFunctions are different! Tag given by high byte, value by low\r\n\t\t// Index order (usually the nSubTag) is not used.\r\n\t\tsRetVal.strVal.Format(_T(\"%u\"),nValLo); // Provide default value\r\n\t\tswitch(nValHi)\r\n\t\t{\r\n\r\n\t\tcase 0x0001: sRetVal.strTag = _T(\"Canon.Cf.NoiseReduction\");break; // Short Long exposure noise reduction \r\n\t\tcase 0x0002: sRetVal.strTag = _T(\"Canon.Cf.ShutterAeLock\");break; // Short Shutter/AE lock buttons \r\n\t\tcase 0x0003: sRetVal.strTag = _T(\"Canon.Cf.MirrorLockup\");break; // Short Mirror lockup \r\n\t\tcase 0x0004: sRetVal.strTag = _T(\"Canon.Cf.ExposureLevelIncrements\");break; // Short Tv/Av and exposure level \r\n\t\tcase 0x0005: sRetVal.strTag = _T(\"Canon.Cf.AFAssist\");break; // Short AF assist light \r\n\t\tcase 0x0006: sRetVal.strTag = _T(\"Canon.Cf.FlashSyncSpeedAv\");break; // Short Shutter speed in Av mode \r\n\t\tcase 0x0007: sRetVal.strTag = _T(\"Canon.Cf.AEBSequence\");break; // Short AEB sequence/auto cancellation \r\n\t\tcase 0x0008: sRetVal.strTag = _T(\"Canon.Cf.ShutterCurtainSync\");break; // Short Shutter curtain sync \r\n\t\tcase 0x0009: sRetVal.strTag = _T(\"Canon.Cf.LensAFStopButton\");break; // Short Lens AF stop button Fn. Switch \r\n\t\tcase 0x000a: sRetVal.strTag = _T(\"Canon.Cf.FillFlashAutoReduction\");break; // Short Auto reduction of fill flash \r\n\t\tcase 0x000b: sRetVal.strTag = _T(\"Canon.Cf.MenuButtonReturn\");break; // Short Menu button return position \r\n\t\tcase 0x000c: sRetVal.strTag = _T(\"Canon.Cf.SetButtonFunction\");break; // Short SET button func. when shooting \r\n\t\tcase 0x000d: sRetVal.strTag = _T(\"Canon.Cf.SensorCleaning\");break; // Short Sensor cleaning \r\n\t\tcase 0x000e: sRetVal.strTag = _T(\"Canon.Cf.SuperimposedDisplay\");break; // Short Superimposed display \r\n\t\tcase 0x000f: sRetVal.strTag = _T(\"Canon.Cf.ShutterReleaseNoCFCard\");break; // Short Shutter Release W/O CF Card \r\n\t\tdefault:\r\n\t\t\tsRetVal.strTag.Format(_T(\"Canon.Cf.x%04X\"),nValHi);\r\n\t\t\tsRetVal.bUnknown = true;\r\n\t\t\tbreak;\r\n\t\t} // switch nSubTag\r\n\t\tbreak;\r\n\r\n/*\r\n\t// Other ones assumed to use high-byte/low-byte method:\r\n\tcase 0x00C0:\r\n\t\tsRetVal.strVal.Format(_T(\"%u\"),nValLo); // Provide default value\r\n\t\tswitch(nValHi)\r\n\t\t{\r\n\t\t\t//case 0x0001: sRetVal.strTag = _T(\"Canon.x00C0.???\");break; //\r\n\t\t\tdefault:\r\n\t\t\t\tsRetVal.strTag.Format(_T(\"Canon.x00C0.x%04X\"),nValHi);\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tcase 0x00C1:\r\n\t\tsRetVal.strVal.Format(_T(\"%u\"),nValLo); // Provide default value\r\n\t\tswitch(nValHi)\r\n\t\t{\r\n\t\t\t//case 0x0001: sRetVal.strTag = _T(\"Canon.x00C1.???\");break; //\r\n\t\t\tdefault:\r\n\t\t\t\tsRetVal.strTag.Format(_T(\"Canon.x00C1.x%04X\"),nValHi);\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\tbreak;\r\n*/\r\n\r\n\tcase 0x0012:\r\n\r\n\t\tswitch(nSubTag)\r\n\t\t{\r\n\t\tcase 0x0002: sRetVal.strTag = _T(\"Canon.Pi.ImageWidth\");break; //\r\n\t\tcase 0x0003: sRetVal.strTag = _T(\"Canon.Pi.ImageHeight\");break; //\r\n\t\tcase 0x0004: sRetVal.strTag = _T(\"Canon.Pi.ImageWidthAsShot\");break; //\r\n\t\tcase 0x0005: sRetVal.strTag = _T(\"Canon.Pi.ImageHeightAsShot\");break; //\r\n\t\tcase 0x0016: sRetVal.strTag = _T(\"Canon.Pi.AFPointsUsed\");break; //\r\n\t\tcase 0x001a: sRetVal.strTag = _T(\"Canon.Pi.AFPointsUsed20D\");break; //\r\n\t\tdefault:\r\n\t\t\tsRetVal.strTag.Format(_T(\"Canon.Pi.x%04X\"),nSubTag);\r\n\t\t\tsRetVal.bUnknown = true;\r\n\t\t\tbreak;\r\n\t\t} // switch nSubTag\r\n\t\tbreak;\r\n\r\n\tdefault:\r\n\t\tsRetVal.strTag.Format(_T(\"Canon.x%04X.x%04X\"),nMainTag,nSubTag);\r\n\t\tsRetVal.bUnknown = true;\r\n\t\tbreak;\r\n\r\n\t} // switch mainTag\r\n\r\n\treturn sRetVal;\r\n}\r\n\r\n\r\n// Perform decode of EXIF IFD tags including MakerNote tags\r\n//\r\n// PRE:\r\n// - m_strImgExifMake\tUsed for MakerNote decode\r\n//\r\n// INPUT:\r\n// - strSect\t\t\tIFD section\r\n// - nTag\t\t\t\tTag code value\r\n//\r\n// OUTPUT:\r\n// - bUnknown\t\t\tWas the tag unknown?\r\n//\r\n// RETURN:\r\n// - Formatted string\r\n//\r\nCString CjfifDecode::LookupExifTag(CString strSect,unsigned nTag,bool &bUnknown)\r\n{\r\n\tCString strTmp;\r\n\tbUnknown = false;\r\n\r\n\tif (strSect == _T(\"IFD0\"))\r\n\t{\r\n\r\n\t\tswitch(nTag)\r\n\t\t{\r\n\r\n\t\tcase 0x010E: return _T(\"ImageDescription\");break; // ascii string Describes image \r\n\t\tcase 0x010F: return _T(\"Make\");break; // ascii string Shows manufacturer of digicam \r\n\t\tcase 0x0110: return _T(\"Model\");break; // ascii string Shows model number of digicam\r\n\t\tcase 0x0112: return _T(\"Orientation\");break; // unsigned short 1  The orientation of the camera relative to the scene, when the image was captured. The start point of stored data is, '1' means upper left, '3' lower right, '6' upper right, '8' lower left, '9' undefined. \r\n\t\tcase 0x011A: return _T(\"XResolution\");break; // unsigned rational 1  Display/Print resolution of image. Large number of digicam uses 1/72inch, but it has no mean because personal computer doesn't use this value to display/print out. \r\n\t\tcase 0x011B: return _T(\"YResolution\");break; // unsigned rational 1  \r\n\t\tcase 0x0128: return _T(\"ResolutionUnit\");break; // unsigned short 1  Unit of XResolution(0x011a)/YResolution(0x011b). '1' means no-unit, '2' means inch, '3' means centimeter. \r\n\t\tcase 0x0131: return _T(\"Software\");break; //  ascii string Shows firmware(internal software of digicam) version number. \r\n\t\tcase 0x0132: return _T(\"DateTime\");break; // ascii string 20  Date/Time of image was last modified. Data format is \"YYYY:MM:DD HH:MM:SS\"+0x00, total 20bytes. In usual, it has the same value of DateTimeOriginal(0x9003) \r\n\t\tcase 0x013B: return _T(\"Artist\");break; // Seems to be here and not only in SubIFD (maybe instead of SubIFD)\r\n\t\tcase 0x013E: return _T(\"WhitePoint\");break; // unsigned rational 2  Defines chromaticity of white point of the image. If the image uses CIE Standard Illumination D65(known as international standard of 'daylight'), the values are '3127/10000,3290/10000'. \r\n\t\tcase 0x013F: return _T(\"PrimChromaticities\");break; // unsigned rational 6  Defines chromaticity of the primaries of the image. If the image uses CCIR Recommendation 709 primearies, values are '640/1000,330/1000,300/1000,600/1000,150/1000,0/1000'. \r\n\t\tcase 0x0211: return _T(\"YCbCrCoefficients\");break; // unsigned rational 3  When image format is YCbCr, this value shows a constant to translate it to RGB format. In usual, values are '0.299/0.587/0.114'. \r\n\t\tcase 0x0213: return _T(\"YCbCrPositioning\");break; // unsigned short 1  When image format is YCbCr and uses 'Subsampling'(cropping of chroma data, all the digicam do that), defines the chroma sample point of subsampling pixel array. '1' means the center of pixel array, '2' means the datum point. \r\n\t\tcase 0x0214: return _T(\"ReferenceBlackWhite\");break; // unsigned rational 6  Shows reference value of black point/white point. In case of YCbCr format, first 2 show black/white of Y, next 2 are Cb, last 2 are Cr. In case of RGB format, first 2 show black/white of R, next 2 are G, last 2 are B.\r\n\t\tcase 0x8298: return _T(\"Copyright\");break; // ascii string Shows copyright information\r\n\t\tcase 0x8769: return _T(\"ExifOffset\");break; //unsigned long 1  Offset to Exif Sub IFD\r\n\t\tcase 0x8825: return _T(\"GPSOffset\");break; //unsigned long 1  Offset to Exif GPS IFD\r\n//NEW:\r\n\t\tcase 0x9C9B: return _T(\"XPTitle\");break;\r\n\t\tcase 0x9C9C: return _T(\"XPComment\");break;\r\n\t\tcase 0x9C9D: return _T(\"XPAuthor\");break;\r\n\t\tcase 0x9C9e: return _T(\"XPKeywords\");break;\r\n\t\tcase 0x9C9f: return _T(\"XPSubject\");break;\r\n//NEW: The following were found in IFD0 even though they should just be SubIFD?\r\n\t\tcase 0xA401: return _T(\"CustomRendered\");break;\r\n\t\tcase 0xA402: return _T(\"ExposureMode\");break;\r\n\t\tcase 0xA403: return _T(\"WhiteBalance\");break;\r\n\t\tcase 0xA406: return _T(\"SceneCaptureType\");break;\r\n\r\n\t\tdefault:\r\n\t\t\tstrTmp.Format(_T(\"IFD0.0x%04X\"),nTag);\r\n\t\t\tbUnknown = true;\r\n\t\t\treturn strTmp;\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t} else if (strSect == _T(\"SubIFD\")) {\r\n\r\n\t\tswitch(nTag)\r\n\t\t{\r\n\t\tcase 0x00fe: return _T(\"NewSubfileType\");break; //  unsigned long 1  \r\n\t\tcase 0x00ff: return _T(\"SubfileType\");break; //  unsigned short 1   \r\n\t\tcase 0x012d: return _T(\"TransferFunction\");break; //  unsigned short 3  \r\n\t\tcase 0x013b: return _T(\"Artist\");break; //  ascii string \r\n\t\tcase 0x013d: return _T(\"Predictor\");break; //  unsigned short 1  \r\n\t\tcase 0x0142: return _T(\"TileWidth\");break; //  unsigned short 1  \r\n\t\tcase 0x0143: return _T(\"TileLength\");break; //  unsigned short 1  \r\n\t\tcase 0x0144: return _T(\"TileOffsets\");break; //  unsigned long \r\n\t\tcase 0x0145: return _T(\"TileByteCounts\");break; //  unsigned short \r\n\t\tcase 0x014a: return _T(\"SubIFDs\");break; //  unsigned long \r\n\t\tcase 0x015b: return _T(\"JPEGTables\");break; //  undefined \r\n\t\tcase 0x828d: return _T(\"CFARepeatPatternDim\");break; //  unsigned short 2  \r\n\t\tcase 0x828e: return _T(\"CFAPattern\");break; //  unsigned byte \r\n\t\tcase 0x828f: return _T(\"BatteryLevel\");break; //  unsigned rational 1  \r\n\t\tcase 0x829A: return _T(\"ExposureTime\");break;\r\n\t\tcase 0x829D: return _T(\"FNumber\");break;\r\n\t\tcase 0x83bb: return _T(\"IPTC/NAA\");break; //  unsigned long \r\n\t\tcase 0x8773: return _T(\"InterColorProfile\");break; //  undefined \r\n\t\tcase 0x8822: return _T(\"ExposureProgram\");break;\r\n\t\tcase 0x8824: return _T(\"SpectralSensitivity\");break; //  ascii string \r\n\t\tcase 0x8825: return _T(\"GPSInfo\");break; //  unsigned long 1  \r\n\t\tcase 0x8827: return _T(\"ISOSpeedRatings\");break;\r\n\t\tcase 0x8828: return _T(\"OECF\");break; //  undefined \r\n\t\tcase 0x8829: return _T(\"Interlace\");break; //  unsigned short 1  \r\n\t\tcase 0x882a: return _T(\"TimeZoneOffset\");break; //  signed short 1  \r\n\t\tcase 0x882b: return _T(\"SelfTimerMode\");break; //  unsigned short 1  \r\n\t\tcase 0x9000: return _T(\"ExifVersion\");break;\r\n\t\tcase 0x9003: return _T(\"DateTimeOriginal\");break;\r\n\t\tcase 0x9004: return _T(\"DateTimeDigitized\");break;\r\n\t\tcase 0x9101: return _T(\"ComponentsConfiguration\");break;\r\n\t\tcase 0x9102: return _T(\"CompressedBitsPerPixel\");break;\r\n\t\tcase 0x9201: return _T(\"ShutterSpeedValue\");break;\r\n\t\tcase 0x9202: return _T(\"ApertureValue\");break;\r\n\t\tcase 0x9203: return _T(\"BrightnessValue\");break;\r\n\t\tcase 0x9204: return _T(\"ExposureBiasValue\");break;\r\n\t\tcase 0x9205: return _T(\"MaxApertureValue\");break;\r\n\t\tcase 0x9206: return _T(\"SubjectDistance\");break;\r\n\t\tcase 0x9207: return _T(\"MeteringMode\");break;\r\n\t\tcase 0x9208: return _T(\"LightSource\");break;\r\n\t\tcase 0x9209: return _T(\"Flash\");break;\r\n\t\tcase 0x920A: return _T(\"FocalLength\");break;\r\n\t\tcase 0x920b: return _T(\"FlashEnergy\");break; //  unsigned rational 1  \r\n\t\tcase 0x920c: return _T(\"SpatialFrequencyResponse\");break; //  undefined \r\n\t\tcase 0x920d: return _T(\"Noise\");break; //  undefined \r\n\t\tcase 0x9211: return _T(\"ImageNumber\");break; //  unsigned long 1  \r\n\t\tcase 0x9212: return _T(\"SecurityClassification\");break; //  ascii string 1  \r\n\t\tcase 0x9213: return _T(\"ImageHistory\");break; //  ascii string \r\n\t\tcase 0x9214: return _T(\"SubjectLocation\");break; //  unsigned short 4  \r\n\t\tcase 0x9215: return _T(\"ExposureIndex\");break; //  unsigned rational 1  \r\n\t\tcase 0x9216: return _T(\"TIFF/EPStandardID\");break; //  unsigned byte 4  \r\n\t\tcase 0x927C: return _T(\"MakerNote\");break;\r\n\t\tcase 0x9286: return _T(\"UserComment\");break;\r\n\t\tcase 0x9290: return _T(\"SubSecTime\");break; //  ascii string \r\n\t\tcase 0x9291: return _T(\"SubSecTimeOriginal\");break; //  ascii string \r\n\t\tcase 0x9292: return _T(\"SubSecTimeDigitized\");break; //  ascii string \r\n\t\tcase 0xA000: return _T(\"FlashPixVersion\");break;\r\n\t\tcase 0xA001: return _T(\"ColorSpace\");break;\r\n\t\tcase 0xA002: return _T(\"ExifImageWidth\");break;\r\n\t\tcase 0xA003: return _T(\"ExifImageHeight\");break;\r\n\t\tcase 0xA004: return _T(\"RelatedSoundFile\");break;\r\n\t\tcase 0xA005: return _T(\"ExifInteroperabilityOffset\");break;\r\n\t\tcase 0xa20b: return _T(\"FlashEnergy  unsigned\");break; // rational 1  \r\n\t\tcase 0xa20c: return _T(\"SpatialFrequencyResponse\");break; //  unsigned short 1  \r\n\t\tcase 0xA20E: return _T(\"FocalPlaneXResolution\");break;\r\n\t\tcase 0xA20F: return _T(\"FocalPlaneYResolution\");break;\r\n\t\tcase 0xA210: return _T(\"FocalPlaneResolutionUnit\");break;\r\n\t\tcase 0xa214: return _T(\"SubjectLocation\");break; //  unsigned short 1  \r\n\t\tcase 0xa215: return _T(\"ExposureIndex\");break; //  unsigned rational 1 \r\n\t\tcase 0xA217: return _T(\"SensingMethod\");break;\r\n\t\tcase 0xA300: return _T(\"FileSource\");break;\r\n\t\tcase 0xA301: return _T(\"SceneType\");break;\r\n\t\tcase 0xa302: return _T(\"CFAPattern\");break; //  undefined 1  \r\n\t\tcase 0xa401: return _T(\"CustomRendered\");break; // Short Custom image processing \r\n\t\tcase 0xa402: return _T(\"ExposureMode\");break; // Short Exposure mode \r\n\t\tcase 0xa403: return _T(\"WhiteBalance\");break; // Short White balance \r\n\t\tcase 0xa404: return _T(\"DigitalZoomRatio\");break; // Rational Digital zoom ratio \r\n\t\tcase 0xa405: return _T(\"FocalLengthIn35mmFilm\");break; // Short Focal length in 35 mm film \r\n\t\tcase 0xa406: return _T(\"SceneCaptureType\");break; // Short Scene capture type \r\n\t\tcase 0xa407: return _T(\"GainControl\");break; // Rational Gain control \r\n\t\tcase 0xa408: return _T(\"Contrast\");break; // Short Contrast \r\n\t\tcase 0xa409: return _T(\"Saturation\");break; // Short Saturation \r\n\t\tcase 0xa40a: return _T(\"Sharpness\");break; // Short Sharpness \r\n\t\tcase 0xa40b: return _T(\"DeviceSettingDescription\");break; // Undefined Device settings description \r\n\t\tcase 0xa40c: return _T(\"SubjectDistanceRange\");break; // Short Subject distance range \r\n\t\tcase 0xa420: return _T(\"ImageUniqueID\");break; // Ascii Unique image ID \r\n\r\n\t\tdefault:\r\n\t\t\tstrTmp.Format(_T(\"SubIFD.0x%04X\"),nTag);\r\n\t\t\tbUnknown = true;\r\n\t\t\treturn strTmp;\r\n\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t} else if (strSect == _T(\"IFD1\")) {\r\n\r\n\t\tswitch(nTag)\r\n\t\t{\r\n\t\tcase 0x0100: return _T(\"ImageWidth\");break; //  unsigned short/long 1  Shows size of thumbnail image. \r\n\t\tcase 0x0101: return _T(\"ImageLength\");break; //  unsigned short/long 1  \r\n\t\tcase 0x0102: return _T(\"BitsPerSample\");break; //  unsigned short 3  When image format is no compression, this value shows the number of bits per component for each pixel. Usually this value is '8,8,8' \r\n\t\tcase 0x0103: return _T(\"Compression\");break; //  unsigned short 1  Shows compression method. '1' means no compression, '6' means JPEG compression. \r\n\t\tcase 0x0106: return _T(\"PhotometricInterpretation\");break; //  unsigned short 1  Shows the color space of the image data components. '1' means monochrome, '2' means RGB, '6' means YCbCr. \r\n\t\tcase 0x0111: return _T(\"StripOffsets\");break; //  unsigned short/long When image format is no compression, this value shows offset to image data. In some case image data is striped and this value is plural. \r\n\t\tcase 0x0115: return _T(\"SamplesPerPixel\");break; //  unsigned short 1  When image format is no compression, this value shows the number of components stored for each pixel. At color image, this value is '3'. \r\n\t\tcase 0x0116: return _T(\"RowsPerStrip\");break; //  unsigned short/long 1  When image format is no compression and image has stored as strip, this value shows how many rows stored to each strip. If image has not striped, this value is the same as ImageLength(0x0101). \r\n\t\tcase 0x0117: return _T(\"StripByteConunts\");break; //  unsigned short/long  When image format is no compression and stored as strip, this value shows how many bytes used for each strip and this value is plural. If image has not stripped, this value is single and means whole data size of image. \r\n\t\tcase 0x011a: return _T(\"XResolution\");break; //  unsigned rational 1  Display/Print resolution of image. Large number of digicam uses 1/72inch, but it has no mean because personal computer doesn't use this value to display/print out. \r\n\t\tcase 0x011b: return _T(\"YResolution\");break; //  unsigned rational 1  \r\n\t\tcase 0x011c: return _T(\"PlanarConfiguration\");break; //  unsigned short 1  When image format is no compression YCbCr, this value shows byte aligns of YCbCr data. If value is '1', Y/Cb/Cr value is chunky format, contiguous for each subsampling pixel. If value is '2', Y/Cb/Cr value is separated and stored to Y plane/Cb plane/Cr plane format. \r\n\t\tcase 0x0128: return _T(\"ResolutionUnit\");break; //  unsigned short 1  Unit of XResolution(0x011a)/YResolution(0x011b). '1' means inch, '2' means centimeter. \r\n\t\tcase 0x0201: return _T(\"JpegIFOffset\");break; //  unsigned long 1  When image format is JPEG, this value show offset to JPEG data stored. \r\n\t\tcase 0x0202: return _T(\"JpegIFByteCount\");break; //  unsigned long 1  When image format is JPEG, this value shows data size of JPEG image. \r\n\t\tcase 0x0211: return _T(\"YCbCrCoefficients\");break; //  unsigned rational 3  When image format is YCbCr, this value shows constants to translate it to RGB format. In usual, '0.299/0.587/0.114' are used. \r\n\t\tcase 0x0212: return _T(\"YCbCrSubSampling\");break; //  unsigned short 2  When image format is YCbCr and uses subsampling(cropping of chroma data, all the digicam do that), this value shows how many chroma data subsampled. First value shows horizontal, next value shows vertical subsample rate. \r\n\t\tcase 0x0213: return _T(\"YCbCrPositioning\");break; //  unsigned short 1  When image format is YCbCr and uses 'Subsampling'(cropping of chroma data, all the digicam do that), this value defines the chroma sample point of subsampled pixel array. '1' means the center of pixel array, '2' means the datum point(0,0). \r\n\t\tcase 0x0214: return _T(\"ReferenceBlackWhite\");break; //  unsigned rational 6  Shows reference value of black point/white point. In case of YCbCr format, first 2 show black/white of Y, next 2 are Cb, last 2 are Cr. In case of RGB format, first 2 show black/white of R, next 2 are G, last 2 are B. \r\n\r\n\t\tdefault:\r\n\t\t\tstrTmp.Format(_T(\"IFD1.0x%04X\"),nTag);\r\n\t\t\tbUnknown = true;\r\n\t\t\treturn strTmp;\r\n\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t} else if (strSect == _T(\"InteropIFD\")) {\r\n\t\tswitch(nTag) {\r\n\t\t\tcase 0x0001: return _T(\"InteroperabilityIndex\");break;\r\n\t\t\tcase 0x0002: return _T(\"InteroperabilityVersion\");break;\r\n\t\t\tcase 0x1000: return _T(\"RelatedImageFileFormat\");break;\r\n\t\t\tcase 0x1001: return _T(\"RelatedImageWidth\");break;\r\n\t\t\tcase 0x1002: return _T(\"RelatedImageLength\");break;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\tstrTmp.Format(_T(\"Interop.0x%04X\"),nTag);\r\n\t\t\t\tbUnknown = true;\r\n\t\t\t\treturn strTmp;\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t} else if (strSect == _T(\"GPSIFD\")) {\r\n\t\tswitch(nTag) {\r\n\t\t\tcase 0x0000: return _T(\"GPSVersionID\");break;\r\n\t\t\tcase 0x0001: return _T(\"GPSLatitudeRef\");break;\r\n\t\t\tcase 0x0002: return _T(\"GPSLatitude\");break;\r\n\t\t\tcase 0x0003: return _T(\"GPSLongitudeRef\");break;\r\n\t\t\tcase 0x0004: return _T(\"GPSLongitude\");break;\r\n\t\t\tcase 0x0005: return _T(\"GPSAltitudeRef\");break;\r\n\t\t\tcase 0x0006: return _T(\"GPSAltitude\");break;\r\n\t\t\tcase 0x0007: return _T(\"GPSTimeStamp\");break;\r\n\t\t\tcase 0x0008: return _T(\"GPSSatellites\");break;\r\n\t\t\tcase 0x0009: return _T(\"GPSStatus\");break;\r\n\t\t\tcase 0x000A: return _T(\"GPSMeasureMode\");break;\r\n\t\t\tcase 0x000B: return _T(\"GPSDOP\");break;\r\n\t\t\tcase 0x000C: return _T(\"GPSSpeedRef\");break;\r\n\t\t\tcase 0x000D: return _T(\"GPSSpeed\");break;\r\n\t\t\tcase 0x000E: return _T(\"GPSTrackRef\");break;\r\n\t\t\tcase 0x000F: return _T(\"GPSTrack\");break;\r\n\t\t\tcase 0x0010: return _T(\"GPSImgDirectionRef\");break;\r\n\t\t\tcase 0x0011: return _T(\"GPSImgDirection\");break;\r\n\t\t\tcase 0x0012: return _T(\"GPSMapDatum\");break;\r\n\t\t\tcase 0x0013: return _T(\"GPSDestLatitudeRef\");break;\r\n\t\t\tcase 0x0014: return _T(\"GPSDestLatitude\");break;\r\n\t\t\tcase 0x0015: return _T(\"GPSDestLongitudeRef\");break;\r\n\t\t\tcase 0x0016: return _T(\"GPSDestLongitude\");break;\r\n\t\t\tcase 0x0017: return _T(\"GPSDestBearingRef\");break;\r\n\t\t\tcase 0x0018: return _T(\"GPSDestBearing\");break;\r\n\t\t\tcase 0x0019: return _T(\"GPSDestDistanceRef\");break;\r\n\t\t\tcase 0x001A: return _T(\"GPSDestDistance\");break;\r\n\t\t\tcase 0x001B: return _T(\"GPSProcessingMethod\");break;\r\n\t\t\tcase 0x001C: return _T(\"GPSAreaInformation\");break;\r\n\t\t\tcase 0x001D: return _T(\"GPSDateStamp\");break;\r\n\t\t\tcase 0x001E: return _T(\"GPSDifferential\");break;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\tstrTmp.Format(_T(\"GPS.0x%04X\"),nTag);\r\n\t\t\t\tbUnknown = true;\r\n\t\t\t\treturn strTmp;\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t} else if (strSect == _T(\"MakerIFD\")) {\r\n\r\n\t\t// Makernotes need special handling\r\n\t\t// We only support a few different manufacturers for makernotes.\r\n\t\t\r\n\t\t// A few Canon tags are supported in this routine, the rest are\r\n\t\t// handled by the LookupMakerCanonTag() call.\r\n\t\tif (m_strImgExifMake == _T(\"Canon\")) {\r\n\r\n\t\t\tswitch(nTag)\r\n\t\t\t{\r\n\t\t\tcase 0x0001: return _T(\"Canon.CameraSettings1\");break;\r\n\t\t\tcase 0x0004: return _T(\"Canon.CameraSettings2\");break;\r\n\t\t\tcase 0x0006: return _T(\"Canon.ImageType\");break;\r\n\t\t\tcase 0x0007: return _T(\"Canon.FirmwareVersion\");break;\r\n\t\t\tcase 0x0008: return _T(\"Canon.ImageNumber\");break;\r\n\t\t\tcase 0x0009: return _T(\"Canon.OwnerName\");break;\r\n\t\t\tcase 0x000C: return _T(\"Canon.SerialNumber\");break;\r\n\t\t\tcase 0x000F: return _T(\"Canon.CustomFunctions\");break;\r\n\t\t\tcase 0x0012: return _T(\"Canon.PictureInfo\");break;\r\n\t\t\tcase 0x00A9: return _T(\"Canon.WhiteBalanceTable\");break;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\tstrTmp.Format(_T(\"Canon.0x%04X\"),nTag);\r\n\t\t\t\tbUnknown = true;\r\n\t\t\t\treturn strTmp;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t} // Canon\r\n\r\n\t\telse if (m_strImgExifMake == _T(\"SIGMA\"))\r\n\t\t{\r\n\t\t\tswitch(nTag)\r\n\t\t\t{\r\n\t\t\tcase 0x0002: return _T(\"Sigma.SerialNumber\");break; // Ascii Camera serial number \r\n\t\t\tcase 0x0003: return _T(\"Sigma.DriveMode\");break; // Ascii Drive Mode \r\n\t\t\tcase 0x0004: return _T(\"Sigma.ResolutionMode\");break; // Ascii Resolution Mode \r\n\t\t\tcase 0x0005: return _T(\"Sigma.AutofocusMode\");break; // Ascii Autofocus mode \r\n\t\t\tcase 0x0006: return _T(\"Sigma.FocusSetting\");break; // Ascii Focus setting \r\n\t\t\tcase 0x0007: return _T(\"Sigma.WhiteBalance\");break; // Ascii White balance \r\n\t\t\tcase 0x0008: return _T(\"Sigma.ExposureMode\");break; // Ascii Exposure mode \r\n\t\t\tcase 0x0009: return _T(\"Sigma.MeteringMode\");break; // Ascii Metering mode \r\n\t\t\tcase 0x000a: return _T(\"Sigma.LensRange\");break; // Ascii Lens focal length range \r\n\t\t\tcase 0x000b: return _T(\"Sigma.ColorSpace\");break; // Ascii Color space \r\n\t\t\tcase 0x000c: return _T(\"Sigma.Exposure\");break; // Ascii Exposure \r\n\t\t\tcase 0x000d: return _T(\"Sigma.Contrast\");break; // Ascii Contrast \r\n\t\t\tcase 0x000e: return _T(\"Sigma.Shadow\");break; // Ascii Shadow \r\n\t\t\tcase 0x000f: return _T(\"Sigma.Highlight\");break; // Ascii Highlight \r\n\t\t\tcase 0x0010: return _T(\"Sigma.Saturation\");break; // Ascii Saturation \r\n\t\t\tcase 0x0011: return _T(\"Sigma.Sharpness\");break; // Ascii Sharpness \r\n\t\t\tcase 0x0012: return _T(\"Sigma.FillLight\");break; // Ascii X3 Fill light \r\n\t\t\tcase 0x0014: return _T(\"Sigma.ColorAdjustment\");break; // Ascii Color adjustment \r\n\t\t\tcase 0x0015: return _T(\"Sigma.AdjustmentMode\");break; // Ascii Adjustment mode \r\n\t\t\tcase 0x0016: return _T(\"Sigma.Quality\");break; // Ascii Quality \r\n\t\t\tcase 0x0017: return _T(\"Sigma.Firmware\");break; // Ascii Firmware \r\n\t\t\tcase 0x0018: return _T(\"Sigma.Software\");break; // Ascii Software \r\n\t\t\tcase 0x0019: return _T(\"Sigma.AutoBracket\");break; // Ascii Auto bracket \r\n\t\t\tdefault:\r\n\t\t\t\tstrTmp.Format(_T(\"Sigma.0x%04X\"),nTag);\r\n\t\t\t\tbUnknown = true;\r\n\t\t\t\treturn strTmp;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t} // SIGMA\r\n\r\n\t\telse if (m_strImgExifMake == _T(\"SONY\"))\r\n\t\t{\r\n\r\n\t\t\tswitch(nTag)\r\n\t\t\t{\r\n\t\t\tcase 0xb021: return _T(\"Sony.ColorTemperature\");break;\r\n\t\t\tcase 0xb023: return _T(\"Sony.SceneMode\");break;\r\n\t\t\tcase 0xb024: return _T(\"Sony.ZoneMatching\");break;\r\n\t\t\tcase 0xb025: return _T(\"Sony.DynamicRangeOptimizer\");break;\r\n\t\t\tcase 0xb026: return _T(\"Sony.ImageStabilization\");break;\r\n\t\t\tcase 0xb027: return _T(\"Sony.LensID\");break;\r\n\t\t\tcase 0xb029: return _T(\"Sony.ColorMode\");break;\r\n\t\t\tcase 0xb040: return _T(\"Sony.Macro\");break;\r\n\t\t\tcase 0xb041: return _T(\"Sony.ExposureMode\");break;\r\n\t\t\tcase 0xb047: return _T(\"Sony.Quality\");break;\r\n\t\t\tcase 0xb04e: return _T(\"Sony.LongExposureNoiseReduction\");break;\r\n\t\t\tdefault:\r\n\t\t\t\t// No real info is known\r\n\t\t\t\tstrTmp.Format(_T(\"Sony.0x%04X\"),nTag);\r\n\t\t\t\tbUnknown = true;\r\n\t\t\t\treturn strTmp;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t} // SONY\r\n\r\n\t\telse if (m_strImgExifMake == _T(\"FUJIFILM\"))\r\n\t\t{\r\n\t\t\tswitch(nTag)\r\n\t\t\t{\r\n\t\t\tcase 0x0000: return _T(\"Fujifilm.Version\");break; // Undefined Fujifilm Makernote version \r\n\t\t\tcase 0x1000: return _T(\"Fujifilm.Quality\");break; // Ascii Image quality setting \r\n\t\t\tcase 0x1001: return _T(\"Fujifilm.Sharpness\");break; // Short Sharpness setting \r\n\t\t\tcase 0x1002: return _T(\"Fujifilm.WhiteBalance\");break; // Short White balance setting \r\n\t\t\tcase 0x1003: return _T(\"Fujifilm.Color\");break; // Short Chroma saturation setting \r\n\t\t\tcase 0x1004: return _T(\"Fujifilm.Tone\");break; // Short Contrast setting \r\n\t\t\tcase 0x1010: return _T(\"Fujifilm.FlashMode\");break; // Short Flash firing mode setting \r\n\t\t\tcase 0x1011: return _T(\"Fujifilm.FlashStrength\");break; // SRational Flash firing strength compensation setting \r\n\t\t\tcase 0x1020: return _T(\"Fujifilm.Macro\");break; // Short Macro mode setting \r\n\t\t\tcase 0x1021: return _T(\"Fujifilm.FocusMode\");break; // Short Focusing mode setting \r\n\t\t\tcase 0x1030: return _T(\"Fujifilm.SlowSync\");break; // Short Slow synchro mode setting \r\n\t\t\tcase 0x1031: return _T(\"Fujifilm.PictureMode\");break; // Short Picture mode setting \r\n\t\t\tcase 0x1100: return _T(\"Fujifilm.Continuous\");break; // Short Continuous shooting or auto bracketing setting \r\n\t\t\tcase 0x1210: return _T(\"Fujifilm.FinePixColor\");break; // Short Fuji FinePix Color setting \r\n\t\t\tcase 0x1300: return _T(\"Fujifilm.BlurWarning\");break; // Short Blur warning status \r\n\t\t\tcase 0x1301: return _T(\"Fujifilm.FocusWarning\");break; // Short Auto Focus warning status \r\n\t\t\tcase 0x1302: return _T(\"Fujifilm.AeWarning\");break; // Short Auto Exposure warning status \r\n\t\t\tdefault:\r\n\t\t\t\tstrTmp.Format(_T(\"Fujifilm.0x%04X\"),nTag);\r\n\t\t\t\tbUnknown = true;\r\n\t\t\t\treturn strTmp;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t} // FUJIFILM\r\n\r\n\t\telse if (m_strImgExifMake == _T(\"NIKON\"))\r\n\t\t{\r\n\t\t\tif (m_nImgExifMakeSubtype == 1) {\r\n\t\t\t\t// Type 1\r\n\t\t\t\tswitch(nTag)\r\n\t\t\t\t{\r\n\t\t\t\tcase 0x0001: return _T(\"Nikon1.Version\");break; // Undefined Nikon Makernote version \r\n\t\t\t\tcase 0x0002: return _T(\"Nikon1.ISOSpeed\");break; // Short ISO speed setting \r\n\t\t\t\tcase 0x0003: return _T(\"Nikon1.ColorMode\");break; // Ascii Color mode \r\n\t\t\t\tcase 0x0004: return _T(\"Nikon1.Quality\");break; // Ascii Image quality setting \r\n\t\t\t\tcase 0x0005: return _T(\"Nikon1.WhiteBalance\");break; // Ascii White balance \r\n\t\t\t\tcase 0x0006: return _T(\"Nikon1.Sharpening\");break; // Ascii Image sharpening setting \r\n\t\t\t\tcase 0x0007: return _T(\"Nikon1.Focus\");break; // Ascii Focus mode \r\n\t\t\t\tcase 0x0008: return _T(\"Nikon1.Flash\");break; // Ascii Flash mode \r\n\t\t\t\tcase 0x000f: return _T(\"Nikon1.ISOSelection\");break; // Ascii ISO selection \r\n\t\t\t\tcase 0x0010: return _T(\"Nikon1.DataDump\");break; // Undefined Data dump \r\n\t\t\t\tcase 0x0080: return _T(\"Nikon1.ImageAdjustment\");break; // Ascii Image adjustment setting \r\n\t\t\t\tcase 0x0082: return _T(\"Nikon1.Adapter\");break; // Ascii Adapter used \r\n\t\t\t\tcase 0x0085: return _T(\"Nikon1.FocusDistance\");break; // Rational Manual focus distance \r\n\t\t\t\tcase 0x0086: return _T(\"Nikon1.DigitalZoom\");break; // Rational Digital zoom setting \r\n\t\t\t\tcase 0x0088: return _T(\"Nikon1.AFFocusPos\");break; // Undefined AF focus position \r\n\t\t\t\tdefault:\r\n\t\t\t\t\tstrTmp.Format(_T(\"Nikon1.0x%04X\"),nTag);\r\n\t\t\t\t\tbUnknown = true;\r\n\t\t\t\t\treturn strTmp;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (m_nImgExifMakeSubtype == 2)\r\n\t\t\t{\r\n\t\t\t\t// Type 2\r\n\t\t\t\tswitch(nTag)\r\n\t\t\t\t{\r\n\t\t\t\tcase 0x0003: return _T(\"Nikon2.Quality\");break; // Short Image quality setting \r\n\t\t\t\tcase 0x0004: return _T(\"Nikon2.ColorMode\");break; // Short Color mode \r\n\t\t\t\tcase 0x0005: return _T(\"Nikon2.ImageAdjustment\");break; // Short Image adjustment setting \r\n\t\t\t\tcase 0x0006: return _T(\"Nikon2.ISOSpeed\");break; // Short ISO speed setting \r\n\t\t\t\tcase 0x0007: return _T(\"Nikon2.WhiteBalance\");break; // Short White balance \r\n\t\t\t\tcase 0x0008: return _T(\"Nikon2.Focus\");break; // Rational Focus mode \r\n\t\t\t\tcase 0x000a: return _T(\"Nikon2.DigitalZoom\");break; // Rational Digital zoom setting \r\n\t\t\t\tcase 0x000b: return _T(\"Nikon2.Adapter\");break; // Short Adapter used \r\n\t\t\t\tdefault:\r\n\t\t\t\t\tstrTmp.Format(_T(\"Nikon2.0x%04X\"),nTag);\r\n\t\t\t\t\tbUnknown = true;\r\n\t\t\t\t\treturn strTmp;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (m_nImgExifMakeSubtype == 3)\r\n\t\t\t{\r\n\t\t\t\t// Type 3\r\n\t\t\t\tswitch(nTag)\r\n\t\t\t\t{\r\n\t\t\t\tcase 0x0001: return _T(\"Nikon3.Version\");break; // Undefined Nikon Makernote version \r\n\t\t\t\tcase 0x0002: return _T(\"Nikon3.ISOSpeed\");break; // Short ISO speed used \r\n\t\t\t\tcase 0x0003: return _T(\"Nikon3.ColorMode\");break; // Ascii Color mode \r\n\t\t\t\tcase 0x0004: return _T(\"Nikon3.Quality\");break; // Ascii Image quality setting \r\n\t\t\t\tcase 0x0005: return _T(\"Nikon3.WhiteBalance\");break; // Ascii White balance \r\n\t\t\t\tcase 0x0006: return _T(\"Nikon3.Sharpening\");break; // Ascii Image sharpening setting \r\n\t\t\t\tcase 0x0007: return _T(\"Nikon3.Focus\");break; // Ascii Focus mode \r\n\t\t\t\tcase 0x0008: return _T(\"Nikon3.FlashSetting\");break; // Ascii Flash setting \r\n\t\t\t\tcase 0x0009: return _T(\"Nikon3.FlashMode\");break; // Ascii Flash mode \r\n\t\t\t\tcase 0x000b: return _T(\"Nikon3.WhiteBalanceBias\");break; // SShort White balance bias \r\n\t\t\t\tcase 0x000e: return _T(\"Nikon3.ExposureDiff\");break; // Undefined Exposure difference \r\n\t\t\t\tcase 0x000f: return _T(\"Nikon3.ISOSelection\");break; // Ascii ISO selection \r\n\t\t\t\tcase 0x0010: return _T(\"Nikon3.DataDump\");break; // Undefined Data dump \r\n\t\t\t\tcase 0x0011: return _T(\"Nikon3.ThumbOffset\");break; // Long Thumbnail IFD offset \r\n\t\t\t\tcase 0x0012: return _T(\"Nikon3.FlashComp\");break; // Undefined Flash compensation setting \r\n\t\t\t\tcase 0x0013: return _T(\"Nikon3.ISOSetting\");break; // Short ISO speed setting \r\n\t\t\t\tcase 0x0016: return _T(\"Nikon3.ImageBoundary\");break; // Short Image boundry \r\n\t\t\t\tcase 0x0018: return _T(\"Nikon3.FlashBracketComp\");break; // Undefined Flash bracket compensation applied \r\n\t\t\t\tcase 0x0019: return _T(\"Nikon3.ExposureBracketComp\");break; // SRational AE bracket compensation applied \r\n\t\t\t\tcase 0x0080: return _T(\"Nikon3.ImageAdjustment\");break; // Ascii Image adjustment setting \r\n\t\t\t\tcase 0x0081: return _T(\"Nikon3.ToneComp\");break; // Ascii Tone compensation setting (contrast) \r\n\t\t\t\tcase 0x0082: return _T(\"Nikon3.AuxiliaryLens\");break; // Ascii Auxiliary lens (adapter) \r\n\t\t\t\tcase 0x0083: return _T(\"Nikon3.LensType\");break; // Byte Lens type \r\n\t\t\t\tcase 0x0084: return _T(\"Nikon3.Lens\");break; // Rational Lens \r\n\t\t\t\tcase 0x0085: return _T(\"Nikon3.FocusDistance\");break; // Rational Manual focus distance \r\n\t\t\t\tcase 0x0086: return _T(\"Nikon3.DigitalZoom\");break; // Rational Digital zoom setting \r\n\t\t\t\tcase 0x0087: return _T(\"Nikon3.FlashType\");break; // Byte Type of flash used \r\n\t\t\t\tcase 0x0088: return _T(\"Nikon3.AFFocusPos\");break; // Undefined AF focus position \r\n\t\t\t\tcase 0x0089: return _T(\"Nikon3.Bracketing\");break; // Short Bracketing \r\n\t\t\t\tcase 0x008b: return _T(\"Nikon3.LensFStops\");break; // Undefined Number of lens stops \r\n\t\t\t\tcase 0x008c: return _T(\"Nikon3.ToneCurve\");break; // Undefined Tone curve \r\n\t\t\t\tcase 0x008d: return _T(\"Nikon3.ColorMode\");break; // Ascii Color mode \r\n\t\t\t\tcase 0x008f: return _T(\"Nikon3.SceneMode\");break; // Ascii Scene mode \r\n\t\t\t\tcase 0x0090: return _T(\"Nikon3.LightingType\");break; // Ascii Lighting type \r\n\t\t\t\tcase 0x0092: return _T(\"Nikon3.HueAdjustment\");break; // SShort Hue adjustment \r\n\t\t\t\tcase 0x0094: return _T(\"Nikon3.Saturation\");break; // SShort Saturation adjustment \r\n\t\t\t\tcase 0x0095: return _T(\"Nikon3.NoiseReduction\");break; // Ascii Noise reduction \r\n\t\t\t\tcase 0x0096: return _T(\"Nikon3.CompressionCurve\");break; // Undefined Compression curve \r\n\t\t\t\tcase 0x0097: return _T(\"Nikon3.ColorBalance2\");break; // Undefined Color balance 2 \r\n\t\t\t\tcase 0x0098: return _T(\"Nikon3.LensData\");break; // Undefined Lens data \r\n\t\t\t\tcase 0x0099: return _T(\"Nikon3.NEFThumbnailSize\");break; // Short NEF thumbnail size \r\n\t\t\t\tcase 0x009a: return _T(\"Nikon3.SensorPixelSize\");break; // Rational Sensor pixel size \r\n\t\t\t\tcase 0x00a0: return _T(\"Nikon3.SerialNumber\");break; // Ascii Camera serial number \r\n\t\t\t\tcase 0x00a7: return _T(\"Nikon3.ShutterCount\");break; // Long Number of shots taken by camera \r\n\t\t\t\tcase 0x00a9: return _T(\"Nikon3.ImageOptimization\");break; // Ascii Image optimization \r\n\t\t\t\tcase 0x00aa: return _T(\"Nikon3.Saturation\");break; // Ascii Saturation \r\n\t\t\t\tcase 0x00ab: return _T(\"Nikon3.VariProgram\");break; // Ascii Vari program \r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tstrTmp.Format(_T(\"Nikon3.0x%04X\"),nTag);\r\n\t\t\t\t\tbUnknown = true;\r\n\t\t\t\t\treturn strTmp;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t} // NIKON\r\n\r\n\t} // if strSect\r\n\r\n\tbUnknown = true;\r\n\treturn _T(\"???\");\r\n}\r\n\r\n\r\n// Interpret the MakerNote header to determine any applicable MakerNote subtype.\r\n//\r\n// PRE:\r\n// - m_strImgExifMake\r\n// - buffer\r\n//\r\n// INPUT:\r\n// - none\r\n//\r\n// RETURN:\r\n// - Decode success\r\n//\r\n// POST:\r\n// - m_nImgExifMakeSubtype\r\n//\r\nbool CjfifDecode::DecodeMakerSubType()\r\n{\r\n\tCString strTmp;\r\n\r\n\tm_nImgExifMakeSubtype = 0;\r\n\r\n\tif (m_strImgExifMake == _T(\"NIKON\"))\r\n\t{\r\n\t\tstrTmp = _T(\"\");\r\n\t\tfor (unsigned nInd=0;nInd<5;nInd++) {\r\n\t\t\tstrTmp += (char)Buf(m_nPos+nInd);\r\n\t\t}\r\n\r\n\t\tif (strTmp == _T(\"Nikon\")) {\r\n\t\t\tif (Buf(m_nPos+6) == 1) {\r\n\t\t\t\t// Type 1\r\n\t\t\t\tm_pLog->AddLine(_T(\"    Nikon Makernote Type 1 detected\"));\r\n\t\t\t\tm_nImgExifMakeSubtype = 1;\r\n\t\t\t\tm_nPos += 8;\r\n\t\t\t} else if (Buf(m_nPos+6) == 2) {\r\n\t\t\t\t// Type 3\r\n\t\t\t\tm_pLog->AddLine(_T(\"    Nikon Makernote Type 3 detected\"));\r\n\t\t\t\tm_nImgExifMakeSubtype = 3;\r\n\t\t\t\tm_nPos += 18;\r\n\t\t\t} else {\r\n\t\t\t\tCString strTmp = _T(\"ERROR: Unknown Nikon Makernote Type\");\r\n\t\t\t\tm_pLog->AddLineErr(strTmp);\r\n\t\t\t\tif (m_pAppConfig->bInteractive)\r\n\t\t\t\t\tAfxMessageBox(strTmp);\r\n\t\t\t\treturn FALSE;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// Type 2\r\n\t\t\tm_pLog->AddLine(_T(\"    Nikon Makernote Type 2 detected\"));\r\n\t\t\t//m_nImgExifMakeSubtype = 2;\r\n\t\t\t// tests on D1 seem to indicate that it uses Type 1 headers\r\n\t\t\tm_nImgExifMakeSubtype = 1;\r\n\t\t\tm_nPos += 0;\r\n\t\t}\r\n\r\n\t}\r\n\telse if (m_strImgExifMake == _T(\"SIGMA\"))\r\n\t{\r\n\t\tstrTmp = _T(\"\");\r\n\t\tfor (unsigned ind=0;ind<8;ind++) {\r\n\t\t\tif (Buf(m_nPos+ind) != 0)\r\n\t\t\t\tstrTmp += (char)Buf(m_nPos+ind);\r\n\t\t}\r\n\t\tif ( (strTmp == _T(\"SIGMA\")) ||\r\n\t\t\t(strTmp == _T(\"FOVEON\"))  )\r\n\t\t{\r\n\t\t\t// Valid marker\r\n\t\t\t// Now skip over the 8-chars and 2 unknown chars\r\n\t\t\tm_nPos += 10;\r\n\t\t} else {\r\n\t\t\tCString strTmp = _T(\"ERROR: Unknown SIGMA Makernote identifier\");\r\n\t\t\tm_pLog->AddLineErr(strTmp);\r\n\t\t\tif (m_pAppConfig->bInteractive)\r\n\t\t\t\tAfxMessageBox(strTmp);\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\r\n\t} // SIGMA\r\n\telse if (m_strImgExifMake == _T(\"FUJIFILM\"))\r\n\t{\r\n\t\tstrTmp = _T(\"\");\r\n\t\tfor (unsigned ind=0;ind<8;ind++) {\r\n\t\t\tif (Buf(m_nPos+ind) != 0)\r\n\t\t\t\tstrTmp += (char)Buf(m_nPos+ind);\r\n\t\t}\r\n\t\tif (strTmp == _T(\"FUJIFILM\"))\r\n\t\t{\r\n\t\t\t// Valid marker\r\n\t\t\t// Now skip over the 8-chars and 4 Pointer chars\r\n\t\t\t// FIXME: Do I need to dereference this pointer?\r\n\t\t\tm_nPos += 12;\r\n\t\t} else {\r\n\t\t\tCString strTmp = _T(\"ERROR: Unknown FUJIFILM Makernote identifier\");\r\n\t\t\tm_pLog->AddLineErr(strTmp);\r\n\t\t\tif (m_pAppConfig->bInteractive)\r\n\t\t\t\tAfxMessageBox(strTmp);\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\r\n\t} // FUJIFILM\r\n\telse if (m_strImgExifMake == _T(\"SONY\"))\r\n\t{\r\n\t\tstrTmp = _T(\"\");\r\n\t\tfor (unsigned ind=0;ind<12;ind++) {\r\n\t\t\tif (Buf(m_nPos+ind) != 0)\r\n\t\t\t\tstrTmp += (char)Buf(m_nPos+ind);\r\n\t\t}\r\n\t\tif (strTmp == _T(\"SONY DSC \"))\r\n\t\t{\r\n\t\t\t// Valid marker\r\n\t\t\t// Now skip over the 9-chars and 3 null chars\r\n\t\t\tm_nPos += 12;\r\n\t\t} else {\r\n\t\t\tCString strTmp = _T(\"ERROR: Unknown SONY Makernote identifier\");\r\n\t\t\tm_pLog->AddLineErr(strTmp);\r\n\t\t\tif (m_pAppConfig->bInteractive)\r\n\t\t\t\tAfxMessageBox(strTmp);\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\r\n\t} // SONY\r\n\r\n\r\n\treturn TRUE;\r\n\r\n}\r\n\r\n// Read two UINT32 from the buffer (8B) and interpret\r\n// as a rational entry. Convert to floating point.\r\n// Byte swap as required\r\n//\r\n// INPUT:\r\n// - pos\t\tBuffer position\r\n// - val\t\tFloating point value\r\n//\r\n// RETURN:\r\n// - Was the conversion successful?\r\n//\r\nbool CjfifDecode::DecodeValRational(unsigned nPos,float &nVal)\r\n{\r\n\tint\tnValNumer;\r\n\tint nValDenom;\r\n\tnVal = 0;\r\n\r\n\tnValNumer = ByteSwap4(Buf(nPos+0),Buf(nPos+1),Buf(nPos+2),Buf(nPos+3));\r\n\tnValDenom = ByteSwap4(Buf(nPos+4),Buf(nPos+5),Buf(nPos+6),Buf(nPos+7));\r\n\r\n\tif (nValDenom == 0) {\r\n\t\t// Divide by zero!\r\n\t\treturn false;\r\n\t} else {\r\n\t\tnVal = (float)nValNumer/(float)nValDenom;\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\n// Read two UINT32 from the buffer (8B) to create a formatted\r\n// fraction string. Byte swap as required\r\n//\r\n// INPUT:\r\n// - pos\t\tBuffer position\r\n//\r\n// RETURN:\r\n// - Formatted string\r\n//\r\nCString CjfifDecode::DecodeValFraction(unsigned nPos)\r\n{\r\n\tCString strTmp;\r\n\tint nValNumer = ReadSwap4(nPos+0);\r\n\tint nValDenom = ReadSwap4(nPos+4);\r\n\tstrTmp.Format(_T(\"%d/%d\"),nValNumer,nValDenom);\r\n\treturn strTmp;\r\n}\r\n\r\n\r\n// Convert multiple coordinates into a formatted GPS string\r\n//\r\n// INPUT:\r\n// - nCount\t\tNumber of coordinates (1,2,3)\r\n// - fCoord1\tCoordinate #1\r\n// - fCoord2\tCoordinate #2\r\n// - fCoord3\tCoordinate #3\r\n//\r\n// OUTPUT:\r\n// - strCoord\tThe formatted GPS string\r\n//\r\n// RETURN:\r\n// - Was the conversion successful?\r\n//\r\nbool CjfifDecode::PrintValGPS(unsigned nCount, float fCoord1, float fCoord2, float fCoord3,CString &strCoord)\r\n{\r\n\tfloat\t\tfTemp;\r\n\tunsigned\tnCoordDeg;\r\n\tunsigned\tnCoordMin;\r\n\tfloat\t\tfCoordSec;\r\n\r\n\t// TODO: Extend to support 1 & 2 coordinate GPS entries\r\n\tif (nCount == 3) {\r\n\t\tnCoordDeg = unsigned(fCoord1);\r\n\t\tnCoordMin = unsigned(fCoord2);\r\n\t\tif (fCoord3 == 0) {\r\n\t\t\tfTemp = fCoord2 - (float)nCoordMin;\r\n\t\t\tfCoordSec = fTemp * (float)60.0;\r\n\t\t} else {\r\n\t\t\tfCoordSec = fCoord3;\r\n\t\t}\r\n\r\n\t\tstrCoord.Format(_T(\"%u deg %u' %.3f\\\"\"),nCoordDeg,nCoordMin,fCoordSec);\r\n\t\treturn true;\r\n\t} else {\r\n\t\tstrCoord.Format(_T(\"ERROR: Can't handle %u-comonent GPS coords\"),nCount);\r\n\t\treturn false;\r\n\t}\r\n\r\n}\r\n\r\n// Read in 3 rational values from the buffer and output as a formatted GPS string\r\n//\r\n// INPUT:\r\n// - pos\t\tBuffer position\r\n//\r\n// OUTPUT:\r\n// - strCoord\tThe formatted GPS string\r\n//\r\n// RETURN:\r\n// - Was the conversion successful?\r\n//\r\nbool CjfifDecode::DecodeValGPS(unsigned nPos,CString &strCoord)\r\n{\r\n\tfloat\t\tfCoord1,fCoord2,fCoord3;\r\n\tbool\t\tbRet;\r\n\r\n\tbRet = true;\r\n\tif (bRet) { bRet = DecodeValRational(nPos,fCoord1); nPos += 8; }\r\n\tif (bRet) { bRet = DecodeValRational(nPos,fCoord2); nPos += 8; }\r\n\tif (bRet) { bRet = DecodeValRational(nPos,fCoord3); nPos += 8; }\r\n\r\n\tif (!bRet) {\r\n\t\tstrCoord.Format(_T(\"???\"));\r\n\t\treturn false;\r\n\t} else {\r\n\t\treturn PrintValGPS(3,fCoord1,fCoord2,fCoord3,strCoord);\r\n\t}\r\n}\r\n\r\n// Read a UINT16 from the buffer, byte swap as required\r\n//\r\n// INPUT:\r\n// - nPos\t\tBuffer position\r\n//\r\n// RETURN:\r\n// - UINT16 from buffer\r\n//\r\nunsigned CjfifDecode::ReadSwap2(unsigned nPos)\r\n{\r\n\treturn ByteSwap2(Buf(nPos+0),Buf(nPos+1));\r\n}\r\n\r\n// Read a UINT32 from the buffer, byte swap as required\r\n//\r\n// INPUT:\r\n// - nPos\t\tBuffer position\r\n//\r\n// RETURN:\r\n// - UINT32 from buffer\r\n//\r\nunsigned CjfifDecode::ReadSwap4(unsigned nPos)\r\n{\r\n\treturn ByteSwap4(Buf(nPos),Buf(nPos+1),Buf(nPos+2),Buf(nPos+3));\r\n}\r\n\r\n// Read a UINT32 from the buffer, force as big endian\r\n//\r\n// INPUT:\r\n// - nPos\t\tBuffer position\r\n//\r\n// RETURN:\r\n// - UINT32 from buffer\r\n//\r\nunsigned CjfifDecode::ReadBe4(unsigned nPos)\r\n{\r\n\t// Big endian, no swap required\r\n\treturn (Buf(nPos)<<24) + (Buf(nPos+1)<<16) + (Buf(nPos+2)<<8) + Buf(nPos+3);\r\n}\r\n\r\n// Print hex from array of unsigned char\r\n//\r\n// INPUT:\r\n// - anBytes\tArray of unsigned chars\r\n// - nCount\t\tIndicates the number of array entries originally specified\r\n//\t\t\t\tbut the printing routine limits it to the maximum array depth\r\n//\t\t\t\tallocated (MAX_anValues) and add an ellipsis \"...\"\r\n// RETURN:\r\n// - A formatted string\r\n//\r\nCString CjfifDecode::PrintAsHexUC(unsigned char* anBytes,unsigned nCount)\r\n{\r\n\tCString strVal;\r\n\tCString strFull;\r\n\tstrFull = _T(\"0x[\");\r\n\tunsigned nMaxDisplay = MAX_anValues;\r\n\tbool bExceedMaxDisplay;\r\n\tbExceedMaxDisplay = (nCount > nMaxDisplay);\r\n\tfor (unsigned nInd=0;nInd<nCount;nInd++)\r\n\t{\r\n\t\tif (nInd < nMaxDisplay) {\r\n\t\t\tif ((nInd % 4) == 0) {\r\n\t\t\t\tif (nInd == 0) {\r\n\t\t\t\t\t// Don't do anything for first value!\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Every 16 add big spacer / break\r\n\t\t\t\t\tstrFull += _T(\" \");\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t//strFull += _T(\" \");\r\n\t\t\t}\r\n\r\n\t\t\tstrVal.Format(_T(\"%02X\"),anBytes[nInd]);\r\n\t\t\tstrFull += strVal;\r\n\t\t}\r\n\r\n\t\tif ((nInd == nMaxDisplay) && (bExceedMaxDisplay)) {\r\n\t\t\tstrFull += _T(\"...\");\r\n\t\t}\r\n\r\n\t}\r\n\tstrFull += _T(\"]\");\r\n\treturn strFull;\r\n}\r\n\r\n\r\n// Print hex from array of unsigned bytes\r\n//\r\n// INPUT:\r\n// - anBytes\tArray is passed as UINT32* even though it only\r\n//\t\t\t\trepresents a byte per entry\r\n// - nCount\t\tIndicates the number of array entries originally specified\r\n//\t\t\t\tbut the printing routine limits it to the maximum array depth\r\n//\t\t\t\tallocated (MAX_anValues) and add an ellipsis \"...\"\r\n//\r\n// RETURN:\r\n// - A formatted string\r\n//\r\nCString CjfifDecode::PrintAsHex8(unsigned* anBytes,unsigned nCount)\r\n{\r\n\tCString\t\tstrVal;\r\n\tCString\t\tstrFull;\r\n\tunsigned\tnMaxDisplay = MAX_anValues;\r\n\tbool\t\tbExceedMaxDisplay;\r\n\r\n\tstrFull = _T(\"0x[\");\r\n\tbExceedMaxDisplay = (nCount > nMaxDisplay);\r\n\tfor (unsigned nInd=0;nInd<nCount;nInd++)\r\n\t{\r\n\t\tif (nInd < nMaxDisplay) {\r\n\t\t\tif ((nInd % 4) == 0) {\r\n\t\t\t\tif (nInd == 0) {\r\n\t\t\t\t\t// Don't do anything for first value!\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Every 16 add big spacer / break\r\n\t\t\t\t\tstrFull += _T(\" \");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tstrVal.Format(_T(\"%02X\"),anBytes[nInd]);\r\n\t\t\tstrFull += strVal;\r\n\t\t}\r\n\r\n\t\tif ((nInd == nMaxDisplay) && (bExceedMaxDisplay)) {\r\n\t\t\tstrFull += _T(\"...\");\r\n\t\t}\r\n\r\n\t}\r\n\tstrFull += _T(\"]\");\r\n\treturn strFull;\r\n}\r\n\r\n// Print hex from array of unsigned words\r\n//\r\n// INPUT:\r\n// - anWords\t\tArray of UINT32 is passed\r\n// - nCount\t\t\tIndicates the number of array entries originally specified\r\n//\t\t\t\t\tbut the printing routine limits it to the maximum array depth\r\n//\t\t\t\t\tallocated (MAX_anValues) and add an ellipsis \"...\"\r\n//\r\n// RETURN:\r\n// - A formatted string\r\n//\r\nCString CjfifDecode::PrintAsHex32(unsigned* anWords,unsigned nCount)\r\n{\r\n\tCString strVal;\r\n\tCString strFull;\r\n\tstrFull = _T(\"0x[\");\r\n\tunsigned nMaxDisplay = MAX_anValues/4;\t// Reduce number of words to display since each is 32b not 8b\r\n\tbool bExceedMaxDisplay;\r\n\tbExceedMaxDisplay = (nCount > nMaxDisplay);\r\n\tfor (unsigned nInd=0;nInd<nCount;nInd++)\r\n\t{\r\n\t\tif (nInd < nMaxDisplay) {\r\n\t\t\tif (nInd == 0) {\r\n\t\t\t\t// Don't do anything for first value!\r\n\t\t\t} else {\r\n\t\t\t\t// Every word add a spacer\r\n\t\t\t\tstrFull += _T(\" \");\r\n\t\t\t}\r\n\r\n\t\t\tstrVal.Format(_T(\"%08X\"),anWords[nInd]);\t// 32-bit words\r\n\t\t\tstrFull += strVal;\r\n\t\t}\r\n\r\n\t\tif ((nInd == nMaxDisplay) && (bExceedMaxDisplay)) {\r\n\t\t\tstrFull += _T(\"...\");\r\n\t\t}\r\n\r\n\t}\r\n\tstrFull += _T(\"]\");\r\n\treturn strFull;\r\n}\r\n\r\n\r\n\r\n// Process all of the entries within an EXIF IFD directory\r\n// This is used for the main EXIF IFDs as well as MakerNotes\r\n//\r\n// INPUT:\r\n// - ifdStr\t\t\t\tThe IFD section that we are processing\r\n// - pos_exif_start\r\n// - start_ifd_ptr\t\t\r\n//\r\n// PRE:\r\n// - m_strImgExifMake\r\n// - m_bImgExifMakeSupported\r\n// - m_nImgExifMakeSubtype\r\n// - m_nImgExifMakerPtr\r\n//\r\n// RETURN:\r\n// - 0\t\t\t\t\tDecoding OK\r\n// - 2\t\t\t\t\tDecoding failure\r\n//\r\n// POST:\r\n// - m_nPos\r\n// - m_strImgExifMake\r\n// - m_strImgExifModel\r\n// - m_strImgQualExif\r\n// - m_strImgExtras\r\n// - m_strImgExifMake\r\n// - m_nImgExifSubIfdPtr\r\n// - m_nImgExifGpsIfdPtr\r\n// - m_nImgExifInteropIfdPtr\r\n// - m_bImgExifMakeSupported\r\n// - m_bImgExifMakernotes\r\n// - m_nImgExifMakerPtr\r\n// - m_nImgExifThumbComp\r\n// - m_nImgExifThumbOffset\r\n// - m_nImgExifThumbLen\r\n// - m_strSoftware\r\n//\r\n// NOTE:\r\n// - IFD1 typically contains the thumbnail\r\n//\r\nunsigned CjfifDecode::DecodeExifIfd(CString strIfd,unsigned nPosExifStart,unsigned nStartIfdPtr)\r\n{\r\n\t// Temp variables\r\n\tbool\t\t\tbRet;\r\n\tCString\t\t\tstrTmp;\r\n\tCStr2\t\t\tstrRetVal;\r\n\tCString\t\t\tstrValTmp;\r\n\tfloat\t\t\tfValReal;\r\n\tCString\t\t\tstrMaker;\r\n\r\n\t// Display output variables\r\n\tCString\t\t\tstrFull;\r\n\tCString\t\t\tstrValOut;\r\n\tBOOL\t\t\tbExtraDecode;\r\n\r\n\t// Primary IFD variables\r\n\tchar\t\tacIfdValOffsetStr[5];\r\n\tunsigned\tnIfdDirLen;\r\n\tunsigned\tnIfdTagVal;\r\n\tunsigned\tnIfdFormat;\r\n\tunsigned\tnIfdNumComps;\r\n\tbool\t\tnIfdTagUnknown;\r\n\r\n\r\n\tunsigned\tnCompsToDisplay;\t\t\t// Maximum number of values to capture for display\r\n\tunsigned\tanValues[MAX_anValues];\t\t// Array of decoded values (Uint32)\r\n\tsigned\t\tanValuesS[MAX_anValues];\t// Array of decoded values (Int32)\r\n\tfloat\t\tafValues[MAX_anValues];\t\t// Array of decoded values (float)\r\n\tunsigned\tnIfdOffset;\t\t\t\t\t// First DWORD decode, usually offset\r\n\r\n\r\n\t// Clear values array\r\n\tfor (unsigned ind=0;ind<MAX_anValues;ind++) {\r\n\t\tanValues[ind] = 0;\r\n\t\tanValuesS[ind] = 0;\r\n\t\tafValues[ind] = 0;\r\n\t}\r\n\r\n\t// ==========================================================================\r\n\t// Process IFD directory header\r\n\t// ==========================================================================\r\n\r\n\t// Move the file pointer to the start of the IFD\r\n\tm_nPos = nPosExifStart+nStartIfdPtr;\r\n\r\n\tstrTmp.Format(_T(\"  EXIF %s @ Absolute 0x%08X\"),(LPCTSTR)strIfd,m_nPos);\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\t////////////\r\n\r\n\t// NOTE: Nikon type 3 starts out with the ASCII string \"Nikon\\0\"\r\n\t//       before the rest of the items.\r\n\t// TODO: need to process type1,type2,type3\r\n\t// see: http://www.gvsoft.homedns.org/exif/makernote-nikon.html\r\n\r\n\tstrTmp.Format(_T(\"strIfd=[%s] m_strImgExifMake=[%s]\"),(LPCTSTR)strIfd,(LPCTSTR)m_strImgExifMake);\r\n\tDbgAddLine(strTmp);\r\n\r\n\r\n\t// If this is the MakerNotes section, then we may want to skip\r\n\t// altogether. Check to see if we are configured to process this\r\n\t// section or if it is a supported manufacturer.\r\n\r\n\tif (strIfd == _T(\"MakerIFD\"))\r\n\t{\r\n\t\t// Mark the image as containing Makernotes\r\n\t\tm_bImgExifMakernotes = true;\r\n\r\n\t\tif (!m_pAppConfig->bDecodeMaker) {\r\n\t\t\tstrTmp.Format(_T(\"    Makernote decode option not enabled.\"));\r\n\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t\t// If user didn't enable makernote decode, don't exit, just\r\n\t\t\t// hide output. We still want to get at some info (such as Quality setting).\r\n\t\t\t// At end, we'll need to re-enable it again.\r\n\t\t\tm_pLog->Disable();\r\n\t\t}\r\n\r\n\t\t// If this Make is not supported, we'll need to exit\r\n\t\tif (!m_bImgExifMakeSupported) {\r\n\t\t\tstrTmp.Format(_T(\"    Makernotes not yet supported for [%s]\"),(LPCTSTR)m_strImgExifMake);\r\n\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t\tm_pLog->Enable();\r\n\t\t\treturn 2;\r\n\t\t}\r\n\r\n\t\t// Determine the sub-type of the Maker field (if applicable)\r\n\t\t// and advance the m_nPos pointer past the custom header.\r\n\t\t// This call uses the class members: Buf(),m_nPos\r\n\t\tif (!DecodeMakerSubType())\r\n\t\t{\r\n\t\t\t// If the subtype decode failed, skip the processing\r\n\t\t\tm_pLog->Enable();\r\n\t\t\treturn 2;\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// ==========================================================================\r\n\t// Process IFD directory entries\r\n\t// ==========================================================================\r\n\r\n\tCString strIfdTag;\r\n\r\n\t// =========== EXIF IFD Header (Start) ===========\r\n\t// - Defined in Exif 2.2 Standard (JEITA CP-3451) section 4.6.2 \r\n\t// - Contents (2 bytes total)\r\n\t//   - Number of fields (2 bytes)\r\n\r\n\tnIfdDirLen = ReadSwap2(m_nPos);\r\n\tm_nPos+=2;\r\n\tstrTmp.Format(_T(\"    Dir Length = 0x%04X\"),nIfdDirLen);\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\t// =========== EXIF IFD Header (End) ===========\r\n\r\n\r\n\t// Start of IFD processing\r\n\t// Step through each IFD entry and determine the type and\r\n\t// decode accordingly.\r\n\tfor (unsigned nIfdEntryInd=0;nIfdEntryInd<nIfdDirLen;nIfdEntryInd++)\r\n\t{\r\n\r\n\t\t// By default, show single-line value summary\r\n\t\t// bExtraDecode is used to indicate that additional special\r\n\t\t// parsing output is available for this entry\r\n\t\tbExtraDecode = FALSE;\r\n\r\n\t\tstrTmp.Format(_T(\"    Entry #%02u:\"),nIfdEntryInd);\r\n\t\tDbgAddLine(strTmp);\r\n\r\n\t\t// =========== EXIF IFD Interoperability entry (Start) ===========\r\n\t\t// - Defined in Exif 2.2 Standard (JEITA CP-3451) section 4.6.2 \r\n\t\t// - Contents (12 bytes total)\r\n\t\t//   - Tag (2 bytes)\r\n\t\t//   - Type (2 bytes)\r\n\t\t//   - Count (4 bytes)\r\n\t\t//   - Value Offset (4 bytes)\r\n\r\n\t\t// Read Tag #\r\n\t\tnIfdTagVal = ReadSwap2(m_nPos);\r\n\t\tm_nPos+=2;\r\n\t\tnIfdTagUnknown = false;\r\n\t\tstrIfdTag = LookupExifTag(strIfd,nIfdTagVal,nIfdTagUnknown);\r\n\t\tstrTmp.Format(_T(\"      Tag # = 0x%04X = [%s]\"),nIfdTagVal,(LPCTSTR)strIfdTag);\r\n\t\tDbgAddLine(strTmp);\r\n\r\n\t\t// Read Format (or Type)\r\n\t\tnIfdFormat = ReadSwap2(m_nPos);\r\n\t\tm_nPos+=2;\r\n\t\tstrTmp.Format(_T(\"      Format # = 0x%04X\"),nIfdFormat);\r\n\t\tDbgAddLine(strTmp);\r\n\r\n\t\t// Read number of Components\r\n\t\tnIfdNumComps = ReadSwap4(m_nPos);\r\n\t\tm_nPos+=4;\r\n\t\tstrTmp.Format(_T(\"      # Comps = 0x%08X\"),nIfdNumComps);\r\n\t\tDbgAddLine(strTmp);\r\n\r\n\t\t// Check to see how many components have been listed.\r\n\t\t// This helps trap errors in corrupted IFD segments, otherwise\r\n\t\t// we will hang trying to decode millions of entries!\r\n\t\t// See issue & testcase #1148\r\n\t\tif (nIfdNumComps > 4000) {\r\n\t\t\t// Warn user that we have clippped the component list.\r\n\t\t\t// Note that this condition is only relevant when we are\r\n\t\t\t// processing the general array fields. Fields such as MakerNote\r\n\t\t\t// will also enter this condition so we shouldn't warn in those cases.\r\n\t\t\t//\r\n\t\t\t// TODO: Defer this warning message until after we are sure that we\r\n\t\t\t// didn't handle the large dataset elsewhere.\r\n\t\t\t// For now, only report this warning if we are not processing MakerNote\r\n\t\t\tif (strIfdTag.Compare(_T(\"MakerNote\"))!=0) {\r\n\t\t\t\tstrTmp.Format(_T(\"      Excessive # components (%u). Limiting to first 4000.\"),nIfdNumComps);\r\n\t\t\t\tm_pLog->AddLineWarn(strTmp);\r\n\t\t\t}\r\n\t\t\tnIfdNumComps = 4000;\r\n\t\t}\r\n\r\n\t\t// Read Component Value / Offset\r\n\t\t// We first treat it as a string and then re-interpret it as an integer\r\n\r\n\t\t// ... first as a string (just in case length <=4)\r\n\t\tfor (unsigned i=0;i<4;i++) {\r\n\t\t\tacIfdValOffsetStr[i] = (char)Buf(m_nPos+i);\r\n\t\t}\r\n\t\tacIfdValOffsetStr[4] = '\\0';\r\n\r\n\t\t// ... now as an unsigned value\r\n\t\t// This assignment is general-purpose, typically used when\r\n\t\t// we know that the IFD Value/Offset is just an offset\r\n\t\tnIfdOffset = ReadSwap4(m_nPos);\r\n\t\tstrTmp.Format(_T(\"      # Val/Offset = 0x%08X\"),nIfdOffset);\r\n\t\tDbgAddLine(strTmp);\r\n\r\n\t\t// =========== EXIF IFD Interoperability entry (End) ===========\r\n\r\n\r\n\t\t// ==========================================================================\r\n\t\t// Extract the IFD component entries\r\n\t\t// ==========================================================================\r\n\r\n\t\t// The EXIF IFD entries can appear in a wide range of\r\n\t\t// formats / data types. The formats that have been\r\n\t\t// publicly documented include:\r\n\t\t//   EXIF_FORMAT_BYTE       =  1,\r\n\t\t//   EXIF_FORMAT_ASCII      =  2,\r\n\t\t//   EXIF_FORMAT_SHORT      =  3,\r\n\t\t//   EXIF_FORMAT_LONG       =  4,\r\n\t\t//   EXIF_FORMAT_RATIONAL   =  5,\r\n\t\t//   EXIF_FORMAT_SBYTE      =  6,\r\n\t\t//   EXIF_FORMAT_UNDEFINED  =  7,\r\n\t\t//   EXIF_FORMAT_SSHORT     =  8,\r\n\t\t//   EXIF_FORMAT_SLONG      =  9,\r\n\t\t//   EXIF_FORMAT_SRATIONAL  = 10,\r\n\t\t//   EXIF_FORMAT_FLOAT      = 11,\r\n\t\t//   EXIF_FORMAT_DOUBLE     = 12\r\n\r\n\t\t// The IFD variable formatter logic operates in two stages:\r\n\t\t// In the first stage, the format type is decoded, which results\r\n\t\t// in a generic decode for the IFD entry. Then, we start a second\r\n\t\t// stage which re-interprets the values for a number of known\r\n\t\t// special types.\r\n\r\n\t\tswitch(nIfdFormat)\r\n\t\t{\r\n\r\n\t\t// ----------------------------------------\r\n\t\t// --- IFD Entry Type: Unsigned Byte\r\n\t\t// ----------------------------------------\r\n\t\tcase 1:\r\n\t\t\tstrFull = _T(\"        Unsigned Byte=[\");\r\n\t\t\tstrValOut = _T(\"\");\r\n\r\n\t\t\t// Limit display output\r\n\t\t\tnCompsToDisplay = min(MAX_anValues,nIfdNumComps);\r\n\r\n\t\t\t// If only a single value, use decimal, else use hex\r\n\t\t\tif (nIfdNumComps == 1) {\r\n\t\t\t\tanValues[0] = Buf(m_nPos+0);\r\n\t\t\t\tstrTmp.Format(_T(\"%u\"),anValues[0]);\r\n\t\t\t\tstrValOut += strTmp;\r\n\t\t\t} else {\r\n\t\t\t\tfor (unsigned nInd=0;nInd<nCompsToDisplay;nInd++)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (nIfdNumComps <= 4) {\r\n\t\t\t\t\t\t// Components fit inside 4B inline region\r\n\t\t\t\t\t\tanValues[nInd] = Buf(m_nPos+nInd);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// Since the components don't fit inside 4B inline region\r\n\t\t\t\t\t\t// we need to dereference\r\n\t\t\t\t\t\tanValues[nInd] = Buf(nPosExifStart+nIfdOffset+nInd);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tstrValOut = PrintAsHex8(anValues,nIfdNumComps);\r\n\t\t\t}\r\n\t\t\tstrFull += strValOut;\r\n\t\t\tstrFull += _T(\"]\");\r\n\t\t\tDbgAddLine(strFull);\r\n\t\t\tbreak;\r\n\r\n\r\n\t\t// ----------------------------------------\r\n\t\t// --- IFD Entry Type: ASCII string\r\n\t\t// ----------------------------------------\r\n\t\tcase 2:\r\n\t\t\tstrFull = _T(\"        String=\");\r\n\t\t\tstrValOut = _T(\"\");\r\n\t\t\tchar cVal;\r\n\t\t\tBYTE nVal;\r\n\r\n\t\t\t// Limit display output\r\n\t\t\t// TODO: Decide what an appropriate string limit would be\r\n\t\t\tnCompsToDisplay = min(250,nIfdNumComps);\r\n\r\n\t\t\tfor (unsigned nInd=0;nInd<nCompsToDisplay;nInd++)\r\n\t\t\t{\r\n\t\t\t\tif (nIfdNumComps<=4) {\r\n\t\t\t\t\tnVal = acIfdValOffsetStr[nInd];\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\t// TODO: See if this can be migrated to the \"custom decode\"\r\n\t\t\t\t\t// section later in the code. Decoding makernotes here is\r\n\t\t\t\t\t// less desirable but unfortunately some Nikon makernotes use\r\n\t\t\t\t\t// a non-standard offset value.\r\n\t\t\t\t\tif ( (strIfd == _T(\"MakerIFD\")) && (m_strImgExifMake == _T(\"NIKON\")) && (m_nImgExifMakeSubtype == 3) )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// It seems that pointers in the Nikon Makernotes are\r\n\t\t\t\t\t\t// done relative to the start of Maker IFD\r\n\t\t\t\t\t\t// But why 10? Is this 10 = 18-8?\r\n\t\t\t\t\t\tnVal = Buf(nPosExifStart+m_nImgExifMakerPtr+nIfdOffset+10+nInd);\r\n\t\t\t\t\t} else if ( (strIfd == _T(\"MakerIFD\")) && (m_strImgExifMake == _T(\"NIKON\")) )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// It seems that pointers in the Nikon Makernotes are\r\n\t\t\t\t\t\t// done relative to the start of Maker IFD\r\n\t\t\t\t\t\tnVal = Buf(nPosExifStart+nIfdOffset+0+nInd);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// Canon Makernotes seem to be relative to the start\r\n\t\t\t\t\t\t// of the EXIF IFD\r\n\t\t\t\t\t\tnVal = Buf(nPosExifStart+nIfdOffset+nInd);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Just in case the string has been null-terminated early\r\n\t\t\t\t// or we have garbage, replace with '.'\r\n\t\t\t\t// TODO: Clean this up\r\n\t\t\t\tif (nVal != 0) {\r\n\t\t\t\t\tcVal = (char)nVal;\r\n\t\t\t\t\tif (!isprint(nVal)) {\r\n\t\t\t\t\t\tcVal = '.';\r\n\t\t\t\t\t}\r\n\t\t\t\t\tstrValOut += cVal;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\tstrFull += strValOut;\r\n\t\t\tDbgAddLine(strFull);\r\n\r\n\t\t\t// TODO: Ideally, we would use a different string for display\r\n\t\t\t// purposes that is wrapped in quotes. Currently \"strValOut\" is used\r\n\t\t\t// in other sections of code (eg. in assignment to EXIF Make/Model/Software, etc.)\r\n\t\t\t// so we don't want to affect that.\r\n\r\n\t\t\tbreak;\r\n\r\n\r\n\t\t// ----------------------------------------\r\n\t\t// --- IFD Entry Type: Unsigned Short (2 bytes)\r\n\t\t// ----------------------------------------\r\n\t\tcase 3:\r\n\t\t\t// Limit display output\r\n\t\t\tnCompsToDisplay = min(MAX_anValues,nIfdNumComps);\r\n\r\n\t\t\t// Unsigned Short (2 bytes)\r\n\t\t\tif (nIfdNumComps == 1) {\r\n\t\t\t\tstrFull = _T(\"        Unsigned Short=[\");\r\n\t\t\t\t// TODO: Confirm endianness is correct here\r\n\t\t\t\t// Refer to Exif2-2 spec, page 14.\r\n\t\t\t\t// Currently selecting 2 byte conversion from [1:0] out of [3:0]\r\n\t\t\t\tanValues[0] = ReadSwap2(m_nPos);\r\n\t\t\t\tstrValOut.Format(_T(\"%u\"),anValues[0]);\r\n\t\t\t\tstrFull += strValOut;\r\n\t\t\t\tstrFull += _T(\"]\");\r\n\t\t\t\tDbgAddLine(strFull);\r\n\t\t\t} else if (nIfdNumComps == 2) {\r\n\t\t\t\tstrFull = _T(\"        Unsigned Short=[\");\r\n\t\t\t\t// 2 unsigned shorts in 1 word\r\n\t\t\t\tanValues[0] = ReadSwap2(m_nPos+0);\r\n\t\t\t\tanValues[1] = ReadSwap2(m_nPos+2);\r\n\t\t\t\tstrValOut.Format(_T(\"%u, %u\"),anValues[0],anValues[1]);\r\n\t\t\t\tstrFull += strValOut;\r\n\t\t\t\tstrFull += _T(\"]\");\r\n\t\t\t\tDbgAddLine(strFull);\r\n\t\t\t} else if (nIfdNumComps > MAX_IFD_COMPS) {\r\n\t\t\t\tstrValTmp.Format(_T(\"    Unsigned Short=[Too many entries (%u) to display]\"),nIfdNumComps);\r\n\t\t\t\tDbgAddLine(strValTmp);\r\n\t\t\t\tstrValOut.Format(_T(\"[Too many entries (%u) to display]\"),nIfdNumComps);\r\n\t\t\t} else {\r\n\t\t\t\t// Try to handle multiple entries... note that this\r\n\t\t\t\t// is used by the Maker notes IFD decode\r\n\r\n\t\t\t\tstrValOut = _T(\"\");\r\n\t\t\t\tstrFull = _T(\"        Unsigned Short=[\");\r\n\t\t\t\tfor (unsigned nInd=0;nInd<nCompsToDisplay;nInd++) {\r\n\t\t\t\t\tif (nInd!=0)\t{ strValOut += _T(\", \"); }\r\n\t\t\t\t\tanValues[nInd] = ReadSwap2(nPosExifStart+nIfdOffset+(2*nInd));\r\n\t\t\t\t\tstrValTmp.Format(_T(\"%u\"),anValues[nInd]);\r\n\t\t\t\t\tstrValOut += strValTmp;\r\n\t\t\t\t}\r\n\t\t\t\tstrFull += strValOut;\r\n\t\t\t\tstrFull += _T(\"]\");\r\n\t\t\t\tDbgAddLine(strFull);\r\n\r\n\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\r\n\r\n\t\t// ----------------------------------------\r\n\t\t// --- IFD Entry Type: Unsigned Long (4 bytes)\r\n\t\t// ----------------------------------------\r\n\t\tcase 4:\r\n\t\t\tstrFull = _T(\"        Unsigned Long=[\");\r\n\t\t\tstrValOut = _T(\"\");\r\n\r\n\t\t\t// Limit display output\r\n\t\t\tnCompsToDisplay = min(MAX_anValues,nIfdNumComps);\r\n\r\n\t\t\tfor (unsigned nInd=0;nInd<nCompsToDisplay;nInd++)\r\n\t\t\t{\r\n\t\t\t\tif (nIfdNumComps == 1) {\r\n\t\t\t\t\t// Components fit inside 4B inline region\r\n\t\t\t\t\tanValues[nInd] = ReadSwap4(m_nPos+(nInd*4));\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Since the components don't fit inside 4B inline region\r\n\t\t\t\t\t// we need to dereference\r\n\t\t\t\t\tanValues[nInd] = ReadSwap4(nPosExifStart+nIfdOffset+(nInd*4));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tstrValOut = PrintAsHex32(anValues,nIfdNumComps);\r\n\t\t\t// If we only have a single component, then display both the hex and decimal\r\n\t\t\tif (nCompsToDisplay==1) {\r\n\t\t\t\tstrTmp.Format(_T(\"%s / %u\"),(LPCTSTR)strValOut,anValues[0]);\r\n\t\t\t\tstrValOut = strTmp;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\r\n\r\n\t\t// ----------------------------------------\r\n\t\t// --- IFD Entry Type: Unsigned Rational (8 bytes)\r\n\t\t// ----------------------------------------\r\n\t\tcase 5:\r\n\t\t\t// Unsigned Rational\r\n\t\t\tstrFull = _T(\"        Unsigned Rational=[\");\r\n\t\t\tstrValOut = _T(\"\");\r\n\r\n\t\t\t// Limit display output\r\n\t\t\tnCompsToDisplay = min(MAX_anValues,nIfdNumComps);\r\n\r\n\t\t\tfor (unsigned nInd=0;nInd<nCompsToDisplay;nInd++)\r\n\t\t\t{\r\n\t\t\t\tif (nInd!=0)\t{ strValOut += _T(\", \"); }\r\n\t\t\t\tstrValTmp = DecodeValFraction(nPosExifStart+nIfdOffset+(nInd*8));\r\n\t\t\t\tbRet = DecodeValRational(nPosExifStart+nIfdOffset+(nInd*8),fValReal);\r\n\t\t\t\tafValues[nInd] = fValReal;\r\n\t\t\t\tstrValOut += strValTmp;\r\n\t\t\t}\r\n\t\t\tstrFull += strValOut;\r\n\t\t\tstrFull += _T(\"]\");\r\n\t\t\tDbgAddLine(strFull);\r\n\t\t\tbreak;\r\n\r\n\t\t// ----------------------------------------\r\n\t\t// --- IFD Entry Type: Undefined (?)\r\n\t\t// ----------------------------------------\r\n\t\tcase 7:\r\n\t\t\t// Undefined -- assume 1 word long\r\n\t\t\t// This is supposed to be a series of 8-bit bytes\r\n\t\t\t// It is usually used for 32-bit pointers (in case of offsets), but could\r\n\t\t\t// also represent ExifVersion, etc.\r\n\t\t\tstrFull = _T(\"        Undefined=[\");\r\n\t\t\tstrValOut = _T(\"\");\r\n\r\n\t\t\t// Limit display output\r\n\t\t\tnCompsToDisplay = min(MAX_anValues,nIfdNumComps);\r\n\t\t\t\r\n\t\t\tif (nIfdNumComps <= 4) {\r\n\t\t\t\t// This format is not defined, so output as hex for now\r\n\t\t\t\tfor (unsigned nInd=0;nInd<nCompsToDisplay;nInd++) {\r\n\t\t\t\t\tanValues[nInd] = Buf(m_nPos+nInd);\r\n\t\t\t\t}\r\n\t\t\t\tstrValOut = PrintAsHex8(anValues,nIfdNumComps);\r\n\t\t\t\tstrFull += strValOut;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// Dereference pointer\r\n\t\t\t\tfor (unsigned nInd=0;nInd<nCompsToDisplay;nInd++) {\r\n\t\t\t\t\tanValues[nInd] = Buf(nPosExifStart+nIfdOffset+nInd);\r\n\t\t\t\t}\r\n\t\t\t\tstrValOut = PrintAsHex8(anValues,nIfdNumComps);\r\n\t\t\t\tstrFull += strValOut;\r\n\t\t\t}\r\n\t\t\tstrFull += _T(\"]\");\r\n\t\t\tDbgAddLine(strFull);\r\n\r\n\t\t\tbreak;\r\n\r\n\r\n\t\t// ----------------------------------------\r\n\t\t// --- IFD Entry Type: Signed Short (2 bytes)\r\n\t\t// ----------------------------------------\r\n\t\tcase 8:\r\n\t\t\t// Limit display output\r\n\t\t\tnCompsToDisplay = min(MAX_anValues,nIfdNumComps);\r\n\r\n\t\t\t// Signed Short (2 bytes)\r\n\t\t\tif (nIfdNumComps == 1) {\r\n\t\t\t\tstrFull = _T(\"        Signed Short=[\");\r\n\t\t\t\t// TODO: Confirm endianness is correct here\r\n\t\t\t\t// Refer to Exif2-2 spec, page 14.\r\n\t\t\t\t// Currently selecting 2 byte conversion from [1:0] out of [3:0]\r\n\r\n\t\t\t\t// TODO: Ensure that ReadSwap2 handles signed notation properly\r\n\t\t\t\tanValuesS[0] = ReadSwap2(m_nPos);\r\n\t\t\t\tstrValOut.Format(_T(\"%d\"),anValuesS[0]);\r\n\t\t\t\tstrFull += strValOut;\r\n\t\t\t\tstrFull += _T(\"]\");\r\n\t\t\t\tDbgAddLine(strFull);\r\n\t\t\t} else if (nIfdNumComps == 2) {\r\n\t\t\t\tstrFull = _T(\"        Signed Short=[\");\r\n\t\t\t\t// 2 signed shorts in 1 word\r\n\r\n\t\t\t\t// TODO: Ensure that ReadSwap2 handles signed notation properly\r\n\t\t\t\tanValuesS[0] = ReadSwap2(m_nPos+0);\r\n\t\t\t\tanValuesS[1] = ReadSwap2(m_nPos+2);\r\n\t\t\t\tstrValOut.Format(_T(\"%d, %d\"),anValuesS[0],anValuesS[0]);\r\n\t\t\t\tstrFull += strValOut;\r\n\t\t\t\tstrFull += _T(\"]\");\r\n\t\t\t\tDbgAddLine(strFull);\r\n\t\t\t} else if (nIfdNumComps > MAX_IFD_COMPS) {\r\n\t\t\t\t// Only print it out if it has less than MAX_IFD_COMPS entries\r\n\t\t\t\tstrValTmp.Format(_T(\"    Signed Short=[Too many entries (%u) to display]\"),nIfdNumComps);\r\n\t\t\t\tDbgAddLine(strValTmp);\r\n\t\t\t\tstrValOut.Format(_T(\"[Too many entries (%u) to display]\"),nIfdNumComps);\r\n\t\t\t} else {\r\n\t\t\t\t// Try to handle multiple entries... note that this\r\n\t\t\t\t// is used by the Maker notes IFD decode\r\n\r\n\t\t\t\t// Note that we don't call LookupMakerCanonTag() here\r\n\t\t\t\t// as that is only needed for the \"unsigned short\", not\r\n\t\t\t\t// \"signed short\".\r\n\t\t\t\tstrValOut = _T(\"\");\r\n\t\t\t\tstrFull = _T(\"        Signed Short=[\");\r\n\t\t\t\tfor (unsigned nInd=0;nInd<nCompsToDisplay;nInd++) {\r\n\t\t\t\t\tif (nInd!=0)\t{ strValOut += _T(\", \"); }\r\n\t\t\t\t\tanValuesS[nInd] = ReadSwap2(nPosExifStart+nIfdOffset+(2*nInd));\r\n\t\t\t\t\tstrValTmp.Format(_T(\"%d\"),anValuesS[nInd]);\r\n\t\t\t\t\tstrValOut += strValTmp;\r\n\t\t\t\t}\r\n\t\t\t\tstrFull += strValOut;\r\n\t\t\t\tstrFull += _T(\"]\");\r\n\t\t\t\tDbgAddLine(strFull);\r\n\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\r\n\r\n\r\n\t\t// ----------------------------------------\r\n\t\t// --- IFD Entry Type: Signed Rational (8 bytes)\r\n\t\t// ----------------------------------------\r\n\t\tcase 10:\r\n\t\t\t// Signed Rational\r\n\t\t\tstrFull = _T(\"        Signed Rational=[\");\r\n\t\t\tstrValOut = _T(\"\");\r\n\r\n\t\t\t// Limit display output\r\n\t\t\tnCompsToDisplay = min(MAX_anValues,nIfdNumComps);\r\n\r\n\t\t\tfor (unsigned nInd=0;nInd<nCompsToDisplay;nInd++)\r\n\t\t\t{\r\n\t\t\t\tif (nInd!=0)\t{ strValOut += _T(\", \"); }\r\n\t\t\t\tstrValTmp = DecodeValFraction(nPosExifStart+nIfdOffset+(nInd*8));\r\n\t\t\t\tbRet = DecodeValRational(nPosExifStart+nIfdOffset+(nInd*8),fValReal);\r\n\t\t\t\tafValues[nInd] = fValReal;\r\n\t\t\t\tstrValOut += strValTmp;\r\n\t\t\t}\r\n\t\t\tstrFull += strValOut;\r\n\t\t\tstrFull += _T(\"]\");\r\n\t\t\tDbgAddLine(strFull);\r\n\t\t\tbreak;\r\n\r\n\t\tdefault:\r\n\t\t\tstrTmp.Format(_T(\"ERROR: Unsupported format [%d]\"),nIfdFormat);\r\n\t\t\tanValues[0] = ReadSwap4(m_nPos);\r\n\t\t\tstrValOut.Format(_T(\"0x%08X???\"),anValues[0]);\r\n\t\t\tm_pLog->Enable();\r\n\t\t\treturn 2;\r\n\t\t\tbreak;\r\n\t\t} // switch nIfdTagVal\r\n\r\n\r\n\r\n\t\t// ==========================================================================\r\n\t\t// Custom Value String decodes\r\n\t\t// ==========================================================================\r\n\r\n\t\t// At this point we might re-format the values, thereby\r\n\t\t// overriding the default strValOut. We have access to the\r\n\t\t//   anValues[]  (array of unsigned int)\r\n\t\t//   anValuesS[] (array of signed int)\r\n\t\t//   afValues[]  (array of float)\r\n\r\n\t\t// Re-format special output items\r\n\t\t//   This will override \"strValOut\" that may have previously been defined\r\n\r\n\t\tif ((strIfdTag == _T(\"GPSLatitude\")) ||\r\n\t\t\t(strIfdTag == _T(\"GPSLongitude\"))) {\r\n\t\t\tbRet = PrintValGPS(nIfdNumComps,afValues[0],afValues[1],afValues[2],strValOut);\r\n\t\t} else if (strIfdTag == _T(\"GPSVersionID\")) {\r\n\t\t\tstrValOut.Format(_T(\"%u.%u.%u.%u\"),anValues[0],anValues[1],anValues[2],anValues[3]);\r\n\t\t} else if (strIfdTag == _T(\"GPSAltitudeRef\")) {\r\n\t\t\tswitch (anValues[0]) {\r\n\t\t\t\tcase 0 : strValOut = _T(\"Above Sea Level\"); break;\r\n\t\t\t\tcase 1 : strValOut = _T(\"Below Sea Level\"); break;\r\n\t\t\t}\r\n\t\t} else if (strIfdTag == _T(\"GPSStatus\")) {\r\n\t\t\tswitch (acIfdValOffsetStr[0]) {\r\n\t\t\t\tcase 'A' : strValOut = _T(\"Measurement in progress\"); break;\r\n\t\t\t\tcase 'V' : strValOut = _T(\"Measurement Interoperability\"); break;\r\n\t\t\t}\r\n\t\t} else if (strIfdTag == _T(\"GPSMeasureMode\")) {\r\n\t\t\tswitch (acIfdValOffsetStr[0]) {\r\n\t\t\t\tcase '2' : strValOut = _T(\"2-dimensional\"); break;\r\n\t\t\t\tcase '3' : strValOut = _T(\"3-dimensional\"); break;\r\n\t\t\t}\r\n\t\t} else if ((strIfdTag == _T(\"GPSSpeedRef\")) ||\r\n\t\t\t\t\t(strIfdTag == _T(\"GPSDestDistanceRef\"))) {\r\n\t\t\tswitch (acIfdValOffsetStr[0]) {\r\n\t\t\t\tcase 'K' : strValOut = _T(\"km/h\"); break;\r\n\t\t\t\tcase 'M' : strValOut = _T(\"mph\"); break;\r\n\t\t\t\tcase 'N' : strValOut = _T(\"knots\"); break;\r\n\t\t\t}\r\n\t\t} else if ((strIfdTag == _T(\"GPSTrackRef\")) ||\r\n\t\t\t\t\t(strIfdTag == _T(\"GPSImgDirectionRef\")) ||\r\n\t\t\t\t\t(strIfdTag == _T(\"GPSDestBearingRef\"))) {\r\n\t\t\tswitch (acIfdValOffsetStr[0]) {\r\n\t\t\t\tcase 'T' : strValOut = _T(\"True direction\"); break;\r\n\t\t\t\tcase 'M' : strValOut = _T(\"Magnetic direction\"); break;\r\n\t\t\t}\r\n\t\t} else if (strIfdTag == _T(\"GPSDifferential\")) {\r\n\t\t\tswitch (anValues[0]) {\r\n\t\t\t\tcase 0 : strValOut = _T(\"Measurement without differential correction\"); break;\r\n\t\t\t\tcase 1 : strValOut = _T(\"Differential correction applied\"); break;\r\n\t\t\t}\r\n\t\t} else if (strIfdTag == _T(\"GPSAltitude\")) {\r\n\t\t\tstrValOut.Format(_T(\"%.3f m\"),afValues[0]);\r\n\t\t} else if (strIfdTag == _T(\"GPSSpeed\")) {\r\n\t\t\tstrValOut.Format(_T(\"%.3f\"),afValues[0]);\r\n\t\t} else if (strIfdTag == _T(\"GPSTimeStamp\")) {\r\n\t\t\tstrValOut.Format(_T(\"%.0f:%.0f:%.2f\"),afValues[0],afValues[1],afValues[2]);\r\n\t\t} else if (strIfdTag == _T(\"GPSTrack\")) {\r\n\t\t\tstrValOut.Format(_T(\"%.2f\"),afValues[0]);\r\n\t\t} else if (strIfdTag == _T(\"GPSDOP\")) {\r\n\t\t\tstrValOut.Format(_T(\"%.4f\"),afValues[0]);\r\n\t\t}\r\n\r\n\r\n\t\tif (strIfdTag == _T(\"Compression\")) {\r\n\t\t\tswitch (anValues[0]) {\r\n\t\t\t\tcase 1 : strValOut = _T(\"None\"); break;\r\n\t\t\t\tcase 6 : strValOut = _T(\"JPEG\"); break;\r\n\t\t\t}\r\n\t\t} else if (strIfdTag == _T(\"ExposureTime\")) {\r\n\t\t\t// Assume only one\r\n\t\t\tstrValTmp = strValOut;\r\n\t\t\tstrValOut.Format(_T(\"%s s\"),(LPCTSTR)strValTmp);\r\n\t\t} else if (strIfdTag == _T(\"FNumber\")) {\r\n\t\t\t// Assume only one\r\n\t\t\tstrValOut.Format(_T(\"F%.1f\"),afValues[0]);\r\n\t\t} else if (strIfdTag == _T(\"FocalLength\")) {\r\n\t\t\t// Assume only one\r\n\t\t\tstrValOut.Format(_T(\"%.0f mm\"),afValues[0]);\r\n\t\t} else if (strIfdTag == _T(\"ExposureBiasValue\")) {\r\n\t\t\t// Assume only one\r\n\t\t\t// TODO: Need to test negative numbers\r\n\t\t\tstrValOut.Format(_T(\"%0.2f eV\"),afValues[0]);\r\n\t\t} else if (strIfdTag == _T(\"ExifVersion\")) {\r\n\t\t\t// Assume only one\r\n\t\t\tstrValOut.Format(_T(\"%c%c.%c%c\"),anValues[0],anValues[1],anValues[2],anValues[3]);\r\n\t\t} else if (strIfdTag == _T(\"FlashPixVersion\")) {\r\n\t\t\t// Assume only one\r\n\t\t\tstrValOut.Format(_T(\"%c%c.%c%c\"),anValues[0],anValues[1],anValues[2],anValues[3]);\r\n\t\t} else if (strIfdTag == _T(\"PhotometricInterpretation\")) {\r\n\t\t\tswitch (anValues[0]) {\r\n\t\t\t\tcase 1 : strValOut = _T(\"Monochrome\"); break;\r\n\t\t\t\tcase 2 : strValOut = _T(\"RGB\"); break;\r\n\t\t\t\tcase 6 : strValOut = _T(\"YCbCr\"); break;\r\n\t\t\t}\r\n\t\t} else if (strIfdTag == _T(\"Orientation\")) {\r\n\t\t\tswitch (anValues[0]) {\r\n\t\t\t\tcase 1 : strValOut = _T(\"1 = Row 0: top, Col 0: left\"); break;\r\n\t\t\t\tcase 2 : strValOut = _T(\"2 = Row 0: top, Col 0: right\"); break;\r\n\t\t\t\tcase 3 : strValOut = _T(\"3 = Row 0: bottom, Col 0: right\"); break;\r\n\t\t\t\tcase 4 : strValOut = _T(\"4 = Row 0: bottom, Col 0: left\"); break;\r\n\t\t\t\tcase 5 : strValOut = _T(\"5 = Row 0: left, Col 0: top\"); break;\r\n\t\t\t\tcase 6 : strValOut = _T(\"6 = Row 0: right, Col 0: top\"); break;\r\n\t\t\t\tcase 7 : strValOut = _T(\"7 = Row 0: right, Col 0: bottom\"); break;\r\n\t\t\t\tcase 8 : strValOut = _T(\"8 = Row 0: left, Col 0: bottom\"); break;\r\n\t\t\t}\r\n\t\t} else if (strIfdTag == _T(\"PlanarConfiguration\")) {\r\n\t\t\tswitch (anValues[0]) {\r\n\t\t\t\tcase 1 : strValOut = _T(\"Chunky format\"); break;\r\n\t\t\t\tcase 2 : strValOut = _T(\"Planar format\"); break;\r\n\t\t\t}\r\n\t\t} else if (strIfdTag == _T(\"YCbCrSubSampling\")) {\r\n\t\t\tswitch (anValues[0]*65536 + anValues[1]) {\r\n\t\t\t\tcase 0x00020001 : strValOut = _T(\"4:2:2\"); break;\r\n\t\t\t\tcase 0x00020002 : strValOut = _T(\"4:2:0\"); break;\r\n\t\t\t}\r\n\t\t} else if (strIfdTag == _T(\"YCbCrPositioning\")) {\r\n\t\t\tswitch (anValues[0]) {\r\n\t\t\t\tcase 1 : strValOut = _T(\"Centered\"); break;\r\n\t\t\t\tcase 2 : strValOut = _T(\"Co-sited\"); break;\r\n\t\t\t}\r\n\t\t} else if (strIfdTag == _T(\"ResolutionUnit\")) {\r\n\t\t\tswitch (anValues[0]) {\r\n\t\t\t\tcase 1 : strValOut = _T(\"None\"); break;\r\n\t\t\t\tcase 2 : strValOut = _T(\"Inch\"); break;\r\n\t\t\t\tcase 3 : strValOut = _T(\"Centimeter\"); break;\r\n\t\t\t}\r\n\t\t} else if (strIfdTag == _T(\"FocalPlaneResolutionUnit\")) {\r\n\t\t\tswitch (anValues[0]) {\r\n\t\t\t\tcase 1 : strValOut = _T(\"None\"); break;\r\n\t\t\t\tcase 2 : strValOut = _T(\"Inch\"); break;\r\n\t\t\t\tcase 3 : strValOut = _T(\"Centimeter\"); break;\r\n\t\t\t}\r\n\t\t} else if (strIfdTag == _T(\"ColorSpace\")) {\r\n\t\t\tswitch (anValues[0]) {\r\n\t\t\t\tcase 1 : strValOut = _T(\"sRGB\"); break;\r\n\t\t\t\tcase 0xFFFF : strValOut = _T(\"Uncalibrated\"); break;\r\n\t\t\t}\r\n\t\t} else if (strIfdTag == _T(\"ComponentsConfiguration\")) {\r\n\t\t\t// Undefined type, assume 4 bytes\r\n\t\t\tstrValOut = _T(\"[\");\r\n\t\t\tfor (unsigned vind=0;vind<4;vind++) {\r\n\t\t\t\tif (vind != 0) { strValOut += _T(\" \"); }\r\n\t\t\t\tswitch (anValues[vind]) {\r\n\t\t\t\t\tcase 0 : strValOut += _T(\".\"); break;\r\n\t\t\t\t\tcase 1 : strValOut += _T(\"Y\"); break;\r\n\t\t\t\t\tcase 2 : strValOut += _T(\"Cb\"); break;\r\n\t\t\t\t\tcase 3 : strValOut += _T(\"Cr\"); break;\r\n\t\t\t\t\tcase 4 : strValOut += _T(\"R\"); break;\r\n\t\t\t\t\tcase 5 : strValOut += _T(\"G\"); break;\r\n\t\t\t\t\tcase 6 : strValOut += _T(\"B\"); break;\r\n\t\t\t\t\tdefault : strValOut += _T(\"?\"); break;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tstrValOut += _T(\"]\");\r\n\r\n\t\t} else if ( (strIfdTag == _T(\"XPTitle\")) ||\r\n\t\t\t\t\t(strIfdTag == _T(\"XPComment\")) ||\r\n\t\t\t\t\t(strIfdTag == _T(\"XPAuthor\")) ||\r\n\t\t\t\t\t(strIfdTag == _T(\"XPKeywords\")) ||\r\n\t\t\t\t\t(strIfdTag == _T(\"XPSubject\")) ) {\r\n\t\t\tstrValOut = _T(\"\\\"\");\r\n\t\t\tCString\t\tstrVal;\r\n\t\t\tstrVal = m_pWBuf->BufReadUniStr2(nPosExifStart+nIfdOffset,nIfdNumComps);\r\n\t\t\tstrValOut += strVal;\r\n\t\t\tstrValOut += _T(\"\\\"\");\r\n\r\n\t\t} else if (strIfdTag == _T(\"UserComment\")) {\r\n\t\t\t// Character code\r\n\t\t\tunsigned anCharCode[8];\r\n\t\t\tfor (unsigned vInd=0;vInd<8;vInd++) {\r\n\t\t\t\tanCharCode[vInd] = Buf(nPosExifStart+nIfdOffset+0+vInd);\r\n\t\t\t}\r\n\t\t\t// Actual string\r\n\t\t\tstrValOut = _T(\"\\\"\");\r\n\t\t\tbool bDone = false;\r\n\t\t\tchar cTmp;\r\n\r\n\t\t\tfor (unsigned vInd=0;(vInd<nIfdNumComps-8)&&(!bDone);vInd++) {\r\n\t\t\t\tcTmp = (char)Buf(nPosExifStart+nIfdOffset+8+vInd);\r\n\t\t\t\tif (cTmp == 0) { bDone = true; } else {\tstrValOut += cTmp;\t}\r\n\t\t\t}\r\n\t\t\tstrValOut += _T(\"\\\"\");\r\n\t\t} else if (strIfdTag == _T(\"MeteringMode\")) {\r\n\t\t\tswitch (anValues[0]) {\r\n\t\t\t\tcase 0 : strValOut = _T(\"Unknown\"); break;\r\n\t\t\t\tcase 1 : strValOut = _T(\"Average\"); break;\r\n\t\t\t\tcase 2 : strValOut = _T(\"CenterWeightedAverage\"); break;\r\n\t\t\t\tcase 3 : strValOut = _T(\"Spot\"); break;\r\n\t\t\t\tcase 4 : strValOut = _T(\"MultiSpot\"); break;\r\n\t\t\t\tcase 5 : strValOut = _T(\"Pattern\"); break;\r\n\t\t\t\tcase 6 : strValOut = _T(\"Partial\"); break;\r\n\t\t\t\tcase 255 : strValOut = _T(\"Other\"); break;\r\n\t\t\t}\r\n\t\t} else if (strIfdTag == _T(\"ExposureProgram\")) {\r\n\t\t\tswitch (anValues[0]) {\r\n\t\t\t\tcase 0 : strValOut = _T(\"Not defined\"); break;\r\n\t\t\t\tcase 1 : strValOut = _T(\"Manual\"); break;\r\n\t\t\t\tcase 2 : strValOut = _T(\"Normal program\"); break;\r\n\t\t\t\tcase 3 : strValOut = _T(\"Aperture priority\"); break;\r\n\t\t\t\tcase 4 : strValOut = _T(\"Shutter priority\"); break;\r\n\t\t\t\tcase 5 : strValOut = _T(\"Creative program (depth of field)\"); break;\r\n\t\t\t\tcase 6 : strValOut = _T(\"Action program (fast shutter speed)\"); break;\r\n\t\t\t\tcase 7 : strValOut = _T(\"Portrait mode\"); break;\r\n\t\t\t\tcase 8 : strValOut = _T(\"Landscape mode\"); break;\r\n\t\t\t}\r\n\t\t} else if (strIfdTag == _T(\"Flash\")) {\r\n\t\t\tswitch (anValues[0] & 1) {\r\n\t\t\t\tcase 0 : strValOut = _T(\"Flash did not fire\"); break;\r\n\t\t\t\tcase 1 : strValOut = _T(\"Flash fired\"); break;\r\n\t\t\t}\r\n\t\t\t// TODO: Add other bitfields?\r\n\t\t} else if (strIfdTag == _T(\"SensingMethod\")) {\r\n\t\t\tswitch (anValues[0]) {\r\n\t\t\t\tcase 1 : strValOut = _T(\"Not defined\"); break;\r\n\t\t\t\tcase 2 : strValOut = _T(\"One-chip color area sensor\"); break;\r\n\t\t\t\tcase 3 : strValOut = _T(\"Two-chip color area sensor\"); break;\r\n\t\t\t\tcase 4 : strValOut = _T(\"Three-chip color area sensor\"); break;\r\n\t\t\t\tcase 5 : strValOut = _T(\"Color sequential area sensor\"); break;\r\n\t\t\t\tcase 7 : strValOut = _T(\"Trilinear sensor\"); break;\r\n\t\t\t\tcase 8 : strValOut = _T(\"Color sequential linear sensor\"); break;\r\n\t\t\t}\r\n\t\t} else if (strIfdTag == _T(\"FileSource\")) {\r\n\t\t\tswitch (anValues[0]) {\r\n\t\t\t\tcase 3 : strValOut = _T(\"DSC\"); break;\r\n\t\t\t}\r\n\t\t} else if (strIfdTag == _T(\"CustomRendered\")) {\r\n\t\t\tswitch (anValues[0]) {\r\n\t\t\t\tcase 0 : strValOut = _T(\"Normal process\"); break;\r\n\t\t\t\tcase 1 : strValOut = _T(\"Custom process\"); break;\r\n\t\t\t}\r\n\t\t} else if (strIfdTag == _T(\"ExposureMode\")) {\r\n\t\t\tswitch (anValues[0]) {\r\n\t\t\t\tcase 0 : strValOut = _T(\"Auto exposure\"); break;\r\n\t\t\t\tcase 1 : strValOut = _T(\"Manual exposure\"); break;\r\n\t\t\t\tcase 2 : strValOut = _T(\"Auto bracket\"); break;\r\n\t\t\t}\r\n\t\t} else if (strIfdTag == _T(\"WhiteBalance\")) {\r\n\t\t\tswitch (anValues[0]) {\r\n\t\t\t\tcase 0 : strValOut = _T(\"Auto white balance\"); break;\r\n\t\t\t\tcase 1 : strValOut = _T(\"Manual white balance\"); break;\r\n\t\t\t}\r\n\t\t} else if (strIfdTag == _T(\"SceneCaptureType\")) {\r\n\t\t\tswitch (anValues[0]) {\r\n\t\t\t\tcase 0 : strValOut = _T(\"Standard\"); break;\r\n\t\t\t\tcase 1 : strValOut = _T(\"Landscape\"); break;\r\n\t\t\t\tcase 2 : strValOut = _T(\"Portrait\"); break;\r\n\t\t\t\tcase 3 : strValOut = _T(\"Night scene\"); break;\r\n\t\t\t}\r\n\t\t} else if (strIfdTag == _T(\"SceneType\")) {\r\n\t\t\tswitch (anValues[0]) {\r\n\t\t\t\tcase 1 : strValOut = _T(\"A directly photographed image\"); break;\r\n\t\t\t}\r\n\t\t} else if (strIfdTag == _T(\"LightSource\")) {\r\n\t\t\tswitch (anValues[0]) {\r\n\t\t\t\tcase 0 : strValOut = _T(\"unknown\"); break;\r\n\t\t\t\tcase 1 : strValOut = _T(\"Daylight\"); break;\r\n\t\t\t\tcase 2 : strValOut = _T(\"Fluorescent\"); break;\r\n\t\t\t\tcase 3 : strValOut = _T(\"Tungsten (incandescent light)\"); break;\r\n\t\t\t\tcase 4 : strValOut = _T(\"Flash\"); break;\r\n\t\t\t\tcase 9 : strValOut = _T(\"Fine weather\"); break;\r\n\t\t\t\tcase 10 : strValOut = _T(\"Cloudy weather\"); break;\r\n\t\t\t\tcase 11 : strValOut = _T(\"Shade\"); break;\r\n\t\t\t\tcase 12 : strValOut = _T(\"Daylight fluorescent (D 5700 \ufffd 7100K)\"); break;\r\n\t\t\t\tcase 13 : strValOut = _T(\"Day white fluorescent (N 4600 \ufffd 5400K)\"); break;\r\n\t\t\t\tcase 14 : strValOut = _T(\"Cool white fluorescent (W 3900 \ufffd 4500K)\"); break;\r\n\t\t\t\tcase 15 : strValOut = _T(\"White fluorescent (WW 3200 \ufffd 3700K)\"); break;\r\n\t\t\t\tcase 17 : strValOut = _T(\"Standard light A\"); break;\r\n\t\t\t\tcase 18 : strValOut = _T(\"Standard light B\"); break;\r\n\t\t\t\tcase 19 : strValOut = _T(\"Standard light C\"); break;\r\n\t\t\t\tcase 20 : strValOut = _T(\"D55\"); break;\r\n\t\t\t\tcase 21 : strValOut = _T(\"D65\"); break;\r\n\t\t\t\tcase 22 : strValOut = _T(\"D75\"); break;\r\n\t\t\t\tcase 23 : strValOut = _T(\"D50\"); break;\r\n\t\t\t\tcase 24 : strValOut = _T(\"ISO studio tungsten\"); break;\r\n\t\t\t\tcase 255 : strValOut = _T(\"other light source\"); break;\r\n\t\t\t}\r\n\t\t} else if (strIfdTag == _T(\"SubjectArea\")) {\r\n\t\t\tswitch (nIfdNumComps) {\r\n\t\t\t\tcase 2 :\r\n\t\t\t\t\t// coords\r\n\t\t\t\t\tstrValOut.Format(_T(\"Coords: Center=[%u,%u]\"),\r\n\t\t\t\t\t\tanValues[0],anValues[1]);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 3 :\r\n\t\t\t\t\t// circle\r\n\t\t\t\t\tstrValOut.Format(_T(\"Coords (Circle): Center=[%u,%u] Diameter=%u\"),\r\n\t\t\t\t\t\tanValues[0],anValues[1],anValues[2]);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 4 :\r\n\t\t\t\t\t// rectangle\r\n\t\t\t\t\tstrValOut.Format(_T(\"Coords (Rect): Center=[%u,%u] Width=%u Height=%u\"),\r\n\t\t\t\t\t\tanValues[0],anValues[1],anValues[2],anValues[3]);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\t// Leave default decode, unexpected value\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (strIfdTag == _T(\"CFAPattern\")) {\r\n\t\t\tunsigned nHorzRepeat,nVertRepeat;\r\n\t\t\tunsigned anCfaVal[16][16];\r\n\t\t\tunsigned nInd=0;\r\n\t\t\tunsigned nVal;\r\n\t\t\tCString\t strLine,strCol;\r\n\t\t\tnHorzRepeat = anValues[nInd+0]*256+anValues[nInd+1];\r\n\t\t\tnVertRepeat = anValues[nInd+2]*256+anValues[nInd+3];\r\n\t\t\tnInd+=4;\r\n\t\t\tif ((nHorzRepeat < 16) && (nVertRepeat < 16)) {\r\n\t\t\t\tbExtraDecode = TRUE;\r\n\t\t\t\tstrTmp.Format(_T(\"    [%-36s] =\"),(LPCTSTR)strIfdTag);\r\n\t\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t\t\tfor (unsigned nY=0;nY<nVertRepeat;nY++) {\r\n\t\t\t\t\tstrLine.Format(_T(\"     %-36s  = [ \"  ),_T(\"\"));\r\n\t\t\t\t\tfor (unsigned nX=0;nX<nHorzRepeat;nX++) {\r\n\t\t\t\t\t\tif (nInd<MAX_anValues) {\r\n\t\t\t\t\t\t\tnVal = anValues[nInd++];\r\n\t\t\t\t\t\t\tanCfaVal[nY][nX] = nVal;\r\n\t\t\t\t\t\t\tswitch(nVal) {\r\n\t\t\t\t\t\t\t\tcase 0: strCol = _T(\"Red\");break;\r\n\t\t\t\t\t\t\t\tcase 1: strCol = _T(\"Grn\");break;\r\n\t\t\t\t\t\t\t\tcase 2: strCol = _T(\"Blu\");break;\r\n\t\t\t\t\t\t\t\tcase 3: strCol = _T(\"Cya\");break;\r\n\t\t\t\t\t\t\t\tcase 4: strCol = _T(\"Mgn\");break;\r\n\t\t\t\t\t\t\t\tcase 5: strCol = _T(\"Yel\");break;\r\n\t\t\t\t\t\t\t\tcase 6: strCol = _T(\"Wht\");break;\r\n\t\t\t\t\t\t\t\tdefault: strCol.Format(_T(\"x%02X\"),nVal);break;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tstrLine.AppendFormat(_T(\"%s \"),(LPCTSTR)strCol);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tstrLine.Append(_T(\"]\"));\r\n\t\t\t\t\tm_pLog->AddLine(strLine);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\r\n\t\tif ((strIfd == _T(\"InteropIFD\")) && (strIfdTag == _T(\"InteroperabilityVersion\"))) {\r\n\t\t\t// Assume only one\r\n\t\t\tstrValOut.Format(_T(\"%c%c.%c%c\"),anValues[0],anValues[1],anValues[2],anValues[3]);\r\n\t\t}\r\n\r\n\r\n\t\t// ==========================================================================\r\n\r\n\t\t// ----------------------------------------\r\n\t\t// Handle certain MakerNotes\r\n\t\t//   For Canon, we have a special parser routine to handle these\r\n\t\t// ----------------------------------------\r\n\t\tif (strIfd == _T(\"MakerIFD\")) {\r\n\r\n\t\t\tif ((m_strImgExifMake == _T(\"Canon\")) && (nIfdFormat == 3) && (nIfdNumComps > 4)) {\r\n\t\t\t\t// Print summary line now, before sub details\r\n\t\t\t\t// Disable later summary line\r\n\t\t\t\tbExtraDecode = TRUE;\r\n\t\t\t\tif ((!m_pAppConfig->bExifHideUnknown) || (!nIfdTagUnknown)) {\r\n\t\t\t\t\tstrTmp.Format(_T(\"    [%-36s]\"),(LPCTSTR)strIfdTag);\r\n\t\t\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t\t\t\t// Assume it is a maker field with subentries!\r\n\r\n\t\t\t\t\tfor (unsigned ind=0;ind<nIfdNumComps;ind++) {\r\n\t\t\t\t\t\t// Limit the number of entries (in case there was a decode error\r\n\t\t\t\t\t\t// or simply too many to report)\r\n\t\t\t\t\t\tif (ind<MAX_anValues) {\r\n\t\t\t\t\t\t\tstrValOut.Format(_T(\"#%u=%u \"),ind,anValues[ind]);\r\n\t\t\t\t\t\t\tstrRetVal = LookupMakerCanonTag(nIfdTagVal,ind,anValues[ind]);\r\n\t\t\t\t\t\t\tstrMaker = strRetVal.strTag;\r\n\t\t\t\t\t\t\tstrValTmp.Format(_T(\"      [%-34s] = %s\"),(LPCTSTR)strMaker,(LPCTSTR)(strRetVal.strVal));\r\n\t\t\t\t\t\t\tif ((!m_pAppConfig->bExifHideUnknown) || (!strRetVal.bUnknown)) {\r\n\t\t\t\t\t\t\t\tm_pLog->AddLine(strValTmp);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else if (ind == MAX_anValues) {\r\n\t\t\t\t\t\t\tm_pLog->AddLine(_T(\"      [... etc ...]\"));\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// Don't print!\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\tstrValOut = _T(\"...\");\r\n\t\t\t}\r\n\r\n\t\t\t// For Nikon & Sigma, we simply support the quality field\r\n\t\t\tif ( (strIfdTag==\"Nikon1.Quality\") || \r\n\t\t\t\t(strIfdTag==\"Nikon2.Quality\") ||\r\n\t\t\t\t(strIfdTag==\"Nikon3.Quality\") ||\r\n\t\t\t\t(strIfdTag==\"Sigma.Quality\") )\r\n\t\t\t{\r\n\t\t\t\tm_strImgQualExif = strValOut;\r\n\r\n\t\t\t\t// Collect extra details (for later DB submission)\r\n\t\t\t\tstrTmp = _T(\"\");\r\n\t\t\t\tstrTmp.Format(_T(\"[%s]:[%s],\"),(LPCTSTR)strIfdTag,(LPCTSTR)strValOut);\r\n\t\t\t\tm_strImgExtras += strTmp;\r\n\t\t\t}\r\n\r\n\t\t\t// Collect extra details (for later DB submission)\r\n\t\t\tif (strIfdTag==_T(\"Canon.ImageType\")) {\r\n\t\t\t\tstrTmp = _T(\"\");\r\n\t\t\t\tstrTmp.Format(_T(\"[%s]:[%s],\"),(LPCTSTR)strIfdTag,(LPCTSTR)strValOut);\r\n\t\t\t\tm_strImgExtras += strTmp;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// ----------------------------------------\r\n\r\n\t\t// Now extract some of the important offsets / pointers\r\n\t\tif ((strIfd == _T(\"IFD0\")) && (strIfdTag == _T(\"ExifOffset\"))) {\r\n\t\t\t// EXIF SubIFD - Pointer\r\n\t\t\tm_nImgExifSubIfdPtr = nIfdOffset;\r\n\t\t\tstrValOut.Format(_T(\"@ 0x%04X\"),nIfdOffset);\r\n\t\t}\r\n\r\n\t\tif ((strIfd == _T(\"IFD0\")) && (strIfdTag == _T(\"GPSOffset\"))) {\r\n\t\t\t// GPS SubIFD - Pointer\r\n\t\t\tm_nImgExifGpsIfdPtr = nIfdOffset;\r\n\t\t\tstrValOut.Format(_T(\"@ 0x%04X\"),nIfdOffset);\r\n\t\t}\r\n\r\n\t\t// TODO: Add Interoperability IFD (0xA005)?\r\n\t\tif ((strIfd == _T(\"SubIFD\")) && (strIfdTag == _T(\"ExifInteroperabilityOffset\"))) {\r\n\t\t\tm_nImgExifInteropIfdPtr = nIfdOffset;\r\n\t\t\tstrValOut.Format(_T(\"@ 0x%04X\"),nIfdOffset);\r\n\t\t}\r\n\r\n\t\t// Extract software field\r\n\t\tif ((strIfd == _T(\"IFD0\")) && (strIfdTag == _T(\"Software\"))) {\r\n\t\t\tm_strSoftware = strValOut;\r\n\t\t}\r\n\r\n\t\t// -------------------------\r\n\t\t// IFD0 - ExifMake\r\n\t\t// -------------------------\r\n\t\tif ((strIfd == _T(\"IFD0\")) && (strIfdTag == _T(\"Make\"))) {\r\n\t\t\tm_strImgExifMake = strValOut;\r\n\t\t\tm_strImgExifMake.Trim(); // Trim whitespace (e.g. Pentax)\r\n\r\n\t\t}\r\n\r\n\t\t// -------------------------\r\n\t\t// IFD0 - ExifModel\r\n\t\t// -------------------------\r\n\t\tif ((strIfd == _T(\"IFD0\")) && (strIfdTag == _T(\"Model\"))) {\r\n\t\t\tm_strImgExifModel= strValOut;\r\n\t\t\tm_strImgExifModel.Trim();\r\n\t\t}\r\n\r\n\r\n\t\tif ((strIfd == _T(\"SubIFD\")) && (strIfdTag == _T(\"MakerNote\"))) {\r\n\t\t\t// Maker IFD - Pointer\r\n\t\t\tm_nImgExifMakerPtr = nIfdOffset;\r\n\t\t\tstrValOut.Format(_T(\"@ 0x%04X\"),nIfdOffset);\r\n\t\t}\r\n\r\n\r\n\t\t// -------------------------\r\n\t\t// IFD1 - Embedded Thumbnail\r\n\t\t// -------------------------\r\n\t\tif ((strIfd == _T(\"IFD1\")) && (strIfdTag == _T(\"Compression\"))) {\r\n\t\t\t// Embedded thumbnail, compression format\r\n\t\t\tm_nImgExifThumbComp = ReadSwap4(m_nPos);\r\n\t\t}\r\n\t\tif ((strIfd == _T(\"IFD1\")) && (strIfdTag == _T(\"JpegIFOffset\"))) {\r\n\t\t\t// Embedded thumbnail, offset\r\n\t\t\tm_nImgExifThumbOffset = nIfdOffset + nPosExifStart;\r\n\t\t\tstrValOut.Format(_T(\"@ +0x%04X = @ 0x%04X\"),nIfdOffset,m_nImgExifThumbOffset);\r\n\t\t}\r\n\t\tif ((strIfd == _T(\"IFD1\")) && (strIfdTag == _T(\"JpegIFByteCount\"))) {\r\n\t\t\t// Embedded thumbnail, length\r\n\t\t\tm_nImgExifThumbLen = ReadSwap4(m_nPos);\r\n\t\t}\r\n\r\n\r\n\t\t// ==========================================================================\r\n\t\t// Determine MakerNote support\r\n\t\t// ==========================================================================\r\n\r\n\t\tif (m_strImgExifMake != _T(\"\")) {\r\n\t\t\t// 1) Identify the supported MakerNotes\r\n\t\t\t// 2) Remap variations of the Maker field (e.g. Nikon)\r\n\t\t\t//    as some manufacturers have been inconsistent in their\r\n\t\t\t//    use of the Make field\r\n\r\n\t\t\tm_bImgExifMakeSupported = FALSE;\r\n\t\t\tif (m_strImgExifMake == _T(\"Canon\")) {\r\n\t\t\t\tm_bImgExifMakeSupported = TRUE;\r\n\t\t\t}\r\n\t\t\telse if (m_strImgExifMake == _T(\"PENTAX Corporation\")) {\r\n\t\t\t\tm_strImgExifMake = _T(\"PENTAX\");\r\n\t\t\t}\r\n\t\t\telse if (m_strImgExifMake == _T(\"NIKON CORPORATION\")) {\r\n\t\t\t\tm_strImgExifMake = _T(\"NIKON\");\r\n\t\t\t\tm_bImgExifMakeSupported = TRUE;\r\n\t\t\t}\r\n\t\t\telse if (m_strImgExifMake == _T(\"NIKON\")) {\r\n\t\t\t\tm_strImgExifMake = _T(\"NIKON\");\r\n\t\t\t\tm_bImgExifMakeSupported = TRUE;\r\n\t\t\t}\r\n\t\t\telse if (m_strImgExifMake == _T(\"SIGMA\")) {\r\n\t\t\t\tm_bImgExifMakeSupported = TRUE;\r\n\t\t\t}\r\n\t\t\telse if (m_strImgExifMake == _T(\"SONY\")) {\r\n\t\t\t\tm_bImgExifMakeSupported = TRUE;\r\n\t\t\t}\r\n\t\t\telse if (m_strImgExifMake == _T(\"FUJIFILM\")) {\r\n\t\t\t\t// TODO:\r\n\t\t\t\t// FUJIFILM Maker notes apparently use\r\n\t\t\t\t// big endian format even though main section uses little.\r\n\t\t\t\t// Need to switch if in maker section for FUJI\r\n\t\t\t\t// For now, disable support\r\n\t\t\t\tm_bImgExifMakeSupported = FALSE;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Now advance the m_nPos ptr as we have finished with valoffset\r\n\t\tm_nPos+=4;\r\n\r\n\r\n\t\t// ==========================================================================\r\n\t\t// SUMMARY REPORT\r\n\t\t// ==========================================================================\r\n\r\n\t\t// If we haven't already output a detailed decode of this field\r\n\t\t// then we can output the generic representation here\r\n\t\tif (!bExtraDecode)\r\n\t\t{\r\n\t\t\t// Provide option to skip unknown fields\r\n\t\t\tif ((!m_pAppConfig->bExifHideUnknown) || (!nIfdTagUnknown)) {\r\n\r\n\t\t\t\t// If the tag is an ASCII string, we want to wrap with quote marks\r\n\t\t\t\tif (nIfdFormat == 2) {\r\n\t\t\t\t\tstrTmp.Format(_T(\"    [%-36s] = \\\"%s\\\"\"),(LPCTSTR)strIfdTag,(LPCTSTR)strValOut);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstrTmp.Format(_T(\"    [%-36s] = %s\"),(LPCTSTR)strIfdTag,(LPCTSTR)strValOut);\r\n\t\t\t\t}\r\n\t\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tDbgAddLine(_T(\"\"));\r\n\r\n\t} // for nIfdEntryInd\r\n\r\n\r\n\t// =========== EXIF IFD (End) ===========\r\n\t// - Defined in Exif 2.2 Standard (JEITA CP-3451) section 4.6.2 \r\n\t// - Is completed by 4-byte offset to next IFD, which is\r\n\t//   read in next iteration.\r\n\r\n\tm_pLog->Enable();\r\n\treturn 0;\r\n}\r\n\r\n\r\n// Handle APP13 marker\r\n// This includes:\r\n// - Photoshop \"Save As\" and \"Save for Web\" quality settings\r\n// - IPTC entries\r\n// PRE:\r\n// - m_nPos\r\n// POST:\r\n// - m_nImgQualPhotoshopSa\r\nunsigned CjfifDecode::DecodeApp13Ps()\r\n{\r\n\t// Photoshop APP13 marker definition doesn't appear to have a \r\n\t// well-defined length, so I will read until I encounter a \r\n\t// non-\"8BIM\" entry, then we reset the position counter\r\n\t// and move on to the next marker.\r\n\t// FIXME: This does not appear to be very robust\r\n\r\n\tCString\t\t\tstrTmp;\r\n\tCString\t\t\tstrBimName;\r\n\tbool\t\t\tbDone = false;\r\n\r\n\tunsigned\t\tnVal = 0x8000;\r\n\tunsigned\t\tnSaveFormat = 0;\r\n\r\n\tCString\t\t\tstrVal;\r\n\tCString\t\t\tstrByte;\r\n\r\n\tCString\t\t\tstrBimSig;\r\n\r\n\t// Reset PsDec decoder state\r\n\tm_pPsDec->Reset();\r\n\r\n\twhile (!bDone)\r\n\t{\r\n\t\t// FIXME: Need to check for actual marker section extent, not\r\n\t\t// just the lack of an 8BIM signature as the terminator!\r\n\r\n\t\t// Check the signature but don't advance the file pointer\r\n\t\tstrBimSig = m_pWBuf->BufReadStrn(m_nPos,4);\r\n\t\t// Check for signature \"8BIM\"\r\n\t\tif (strBimSig == _T(\"8BIM\")) {\r\n\t\t\tm_pPsDec->PhotoshopParseImageResourceBlock(m_nPos,3);\r\n\t\t} else {\r\n\t\t\t// Not 8BIM?\r\n\t\t\tbDone = true;\r\n\t\t}\r\n\t}\r\n\r\n\t// Now that we've finished with the PsDec decoder we can fetch\r\n\t// some of the parser state\r\n\t// TODO: Migrate into accessor\r\n\tm_nImgQualPhotoshopSa = m_pPsDec->m_nQualitySaveAs;\r\n\tm_nImgQualPhotoshopSfw = m_pPsDec->m_nQualitySaveForWeb;\r\n\tm_bPsd = m_pPsDec->m_bPsd;\r\n\r\n\treturn 0;\r\n}\r\n\r\n\r\n// Start decoding a single ICC header segment @ nPos\r\nunsigned CjfifDecode::DecodeIccHeader(unsigned nPos)\r\n{\r\n\tCString strTmp,strTmp1;\r\n\r\n\t// Profile header\r\n\tunsigned nProfSz;\r\n\tunsigned nPrefCmmType;\r\n\tunsigned nProfVer;\r\n\tunsigned nProfDevClass;\r\n\tunsigned nDataColorSpace;\r\n\tunsigned nPcs;\r\n\tunsigned anDateTimeCreated[3];\r\n\tunsigned nProfFileSig;\r\n\tunsigned nPrimPlatSig;\r\n\tunsigned nProfFlags;\r\n\tunsigned nDevManuf;\r\n\tunsigned nDevModel;\r\n\tunsigned anDevAttrib[2];\r\n\tunsigned nRenderIntent;\r\n\tunsigned anIllumPcsXyz[3];\r\n\tunsigned nProfCreatorSig;\r\n\tunsigned anProfId[4];\r\n\tunsigned anRsvd[7];\r\n\r\n\t// Read in all of the ICC header bytes\r\n\tnProfSz = ReadBe4(nPos);nPos+=4;\r\n\tnPrefCmmType = ReadBe4(nPos);nPos+=4;\r\n\tnProfVer = ReadBe4(nPos);nPos+=4;\r\n\tnProfDevClass = ReadBe4(nPos);nPos+=4;\r\n\tnDataColorSpace = ReadBe4(nPos);nPos+=4;\r\n\tnPcs = ReadBe4(nPos);nPos+=4;\r\n\tanDateTimeCreated[2] = ReadBe4(nPos);nPos+=4;\r\n\tanDateTimeCreated[1] = ReadBe4(nPos);nPos+=4;\r\n\tanDateTimeCreated[0] = ReadBe4(nPos);nPos+=4;\r\n\tnProfFileSig = ReadBe4(nPos);nPos+=4;\r\n\tnPrimPlatSig = ReadBe4(nPos);nPos+=4;\r\n\tnProfFlags = ReadBe4(nPos);nPos+=4;\r\n\tnDevManuf = ReadBe4(nPos);nPos+=4;\r\n\tnDevModel = ReadBe4(nPos);nPos+=4;\r\n\tanDevAttrib[1] = ReadBe4(nPos);nPos+=4;\r\n\tanDevAttrib[0] = ReadBe4(nPos);nPos+=4;\r\n\tnRenderIntent = ReadBe4(nPos);nPos+=4;\r\n\tanIllumPcsXyz[2] = ReadBe4(nPos);nPos+=4;\r\n\tanIllumPcsXyz[1] = ReadBe4(nPos);nPos+=4;\r\n\tanIllumPcsXyz[0] = ReadBe4(nPos);nPos+=4;\r\n\tnProfCreatorSig = ReadBe4(nPos);nPos+=4;\r\n\tanProfId[3] = ReadBe4(nPos);nPos+=4;\r\n\tanProfId[2] = ReadBe4(nPos);nPos+=4;\r\n\tanProfId[1] = ReadBe4(nPos);nPos+=4;\r\n\tanProfId[0] = ReadBe4(nPos);nPos+=4;\r\n\tanRsvd[6] = ReadBe4(nPos);nPos+=4;\r\n\tanRsvd[5] = ReadBe4(nPos);nPos+=4;\r\n\tanRsvd[4] = ReadBe4(nPos);nPos+=4;\r\n\tanRsvd[3] = ReadBe4(nPos);nPos+=4;\r\n\tanRsvd[2] = ReadBe4(nPos);nPos+=4;\r\n\tanRsvd[1] = ReadBe4(nPos);nPos+=4;\r\n\tanRsvd[0] = ReadBe4(nPos);nPos+=4;\r\n\r\n\t// Now output the formatted version of the above data structures\r\n\tstrTmp.Format(_T(\"        %-33s : %u bytes\"),_T(\"Profile Size\"),nProfSz);\r\n\tm_pLog->AddLine(strTmp);\r\n\t\r\n\tstrTmp.Format(_T(\"        %-33s : %s\"),_T(\"Preferred CMM Type\"),(LPCTSTR)Uint2Chars(nPrefCmmType));\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\tstrTmp.Format(_T(\"        %-33s : %u.%u.%u.%u (0x%08X)\"),_T(\"Profile Version\"),\r\n\t\t((nProfVer & 0xF0000000)>>28),\r\n\t\t((nProfVer & 0x0F000000)>>24),\r\n\t\t((nProfVer & 0x00F00000)>>20),\r\n\t\t((nProfVer & 0x000F0000)>>16),\r\n\t\tnProfVer);\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\tswitch (nProfDevClass) {\r\n\t\tcase 'scnr':\r\n\t\t\tstrTmp1.Format(_T(\"Input Device profile\"));break;\r\n\t\tcase 'mntr':\r\n\t\t\tstrTmp1.Format(_T(\"Display Device profile\"));break;\r\n\t\tcase 'prtr':\r\n\t\t\tstrTmp1.Format(_T(\"Output Device profile\"));break;\r\n\t\tcase 'link':\r\n\t\t\tstrTmp1.Format(_T(\"DeviceLink Device profile\"));break;\r\n\t\tcase 'spac':\r\n\t\t\tstrTmp1.Format(_T(\"ColorSpace Conversion profile\"));break;\r\n\t\tcase 'abst':\r\n\t\t\tstrTmp1.Format(_T(\"Abstract profile\"));break;\r\n\t\tcase 'nmcl':\r\n\t\t\tstrTmp1.Format(_T(\"Named colour profile\"));break;\r\n\t\tdefault:\r\n\t\t\tstrTmp1.Format(_T(\"? (0x%08X)\"),nProfDevClass);\r\n\t\t\tbreak;\r\n\t}\r\n\tstrTmp.Format(_T(\"        %-33s : %s (%s)\"),_T(\"Profile Device/Class\"),(LPCTSTR)strTmp1,(LPCTSTR)Uint2Chars(nProfDevClass));\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\tswitch (nDataColorSpace) {\r\n\t\tcase 'XYZ ':\r\n\t\t\tstrTmp1.Format(_T(\"XYZData\"));break;\r\n\t\tcase 'Lab ':\r\n\t\t\tstrTmp1.Format(_T(\"labData\"));break;\r\n\t\tcase 'Luv ':\r\n\t\t\tstrTmp1.Format(_T(\"lubData\"));break;\r\n\t\tcase 'YCbr':\r\n\t\t\tstrTmp1.Format(_T(\"YCbCrData\"));break;\r\n\t\tcase 'Yxy ':\r\n\t\t\tstrTmp1.Format(_T(\"YxyData\"));break;\r\n\t\tcase 'RGB ':\r\n\t\t\tstrTmp1.Format(_T(\"rgbData\"));break;\r\n\t\tcase 'GRAY':\r\n\t\t\tstrTmp1.Format(_T(\"grayData\"));break;\r\n\t\tcase 'HSV ':\r\n\t\t\tstrTmp1.Format(_T(\"hsvData\"));break;\r\n\t\tcase 'HLS ':\r\n\t\t\tstrTmp1.Format(_T(\"hlsData\"));break;\r\n\t\tcase 'CMYK':\r\n\t\t\tstrTmp1.Format(_T(\"cmykData\"));break;\r\n\t\tcase 'CMY ':\r\n\t\t\tstrTmp1.Format(_T(\"cmyData\"));break;\r\n\t\tcase '2CLR':\r\n\t\t\tstrTmp1.Format(_T(\"2colourData\"));break;\r\n\t\tcase '3CLR':\r\n\t\t\tstrTmp1.Format(_T(\"3colourData\"));break;\r\n\t\tcase '4CLR':\r\n\t\t\tstrTmp1.Format(_T(\"4colourData\"));break;\r\n\t\tcase '5CLR':\r\n\t\t\tstrTmp1.Format(_T(\"5colourData\"));break;\r\n\t\tcase '6CLR':\r\n\t\t\tstrTmp1.Format(_T(\"6colourData\"));break;\r\n\t\tcase '7CLR':\r\n\t\t\tstrTmp1.Format(_T(\"7colourData\"));break;\r\n\t\tcase '8CLR':\r\n\t\t\tstrTmp1.Format(_T(\"8colourData\"));break;\r\n\t\tcase '9CLR':\r\n\t\t\tstrTmp1.Format(_T(\"9colourData\"));break;\r\n\t\tcase 'ACLR':\r\n\t\t\tstrTmp1.Format(_T(\"10colourData\"));break;\r\n\t\tcase 'BCLR':\r\n\t\t\tstrTmp1.Format(_T(\"11colourData\"));break;\r\n\t\tcase 'CCLR':\r\n\t\t\tstrTmp1.Format(_T(\"12colourData\"));break;\r\n\t\tcase 'DCLR':\r\n\t\t\tstrTmp1.Format(_T(\"13colourData\"));break;\r\n\t\tcase 'ECLR':\r\n\t\t\tstrTmp1.Format(_T(\"14colourData\"));break;\r\n\t\tcase 'FCLR':\r\n\t\t\tstrTmp1.Format(_T(\"15colourData\"));break;\r\n\t\tdefault:\r\n\t\t\tstrTmp1.Format(_T(\"? (0x%08X)\"),nDataColorSpace);\r\n\t\t\tbreak;\r\n\t}\r\n\tstrTmp.Format(_T(\"        %-33s : %s (%s)\"),_T(\"Data Colour Space\"),(LPCTSTR)strTmp1,(LPCTSTR)Uint2Chars(nDataColorSpace));\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\tstrTmp.Format(_T(\"        %-33s : %s\"),_T(\"Profile connection space (PCS)\"),(LPCTSTR)Uint2Chars(nPcs));\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\tstrTmp.Format(_T(\"        %-33s : %s\"),_T(\"Profile creation date\"),(LPCTSTR)DecodeIccDateTime(anDateTimeCreated));\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\tstrTmp.Format(_T(\"        %-33s : %s\"),_T(\"Profile file signature\"),(LPCTSTR)Uint2Chars(nProfFileSig));\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\tswitch (nPrimPlatSig) {\r\n\t\tcase 'APPL':\r\n\t\t\tstrTmp1.Format(_T(\"Apple Computer, Inc.\"));break;\r\n\t\tcase 'MSFT':\r\n\t\t\tstrTmp1.Format(_T(\"Microsoft Corporation\"));break;\r\n\t\tcase 'SGI ':\r\n\t\t\tstrTmp1.Format(_T(\"Silicon Graphics, Inc.\"));break;\r\n\t\tcase 'SUNW':\r\n\t\t\tstrTmp1.Format(_T(\"Sun Microsystems, Inc.\"));break;\r\n\t\tdefault:\r\n\t\t\tstrTmp1.Format(_T(\"? (0x%08X)\"),nPrimPlatSig);\r\n\t\t\tbreak;\r\n\t}\r\n\tstrTmp.Format(_T(\"        %-33s : %s (%s)\"),_T(\"Primary platform\"),(LPCTSTR)strTmp1,(LPCTSTR)Uint2Chars(nPrimPlatSig));\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\tstrTmp.Format(_T(\"        %-33s : 0x%08X\"),_T(\"Profile flags\"),nProfFlags);\r\n\tm_pLog->AddLine(strTmp);\r\n\tstrTmp1 = (TestBit(nProfFlags,0))?\"Embedded profile\":\"Profile not embedded\";\r\n\tstrTmp.Format(_T(\"        %-35s > %s\"),_T(\"Profile flags\"),(LPCTSTR)strTmp1);\r\n\tm_pLog->AddLine(strTmp);\r\n\tstrTmp1 = (TestBit(nProfFlags,1))?\"Profile can be used independently of embedded\":\"Profile can't be used independently of embedded\";\r\n\tstrTmp.Format(_T(\"        %-35s > %s\"),_T(\"Profile flags\"),(LPCTSTR)strTmp1);\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\tstrTmp.Format(_T(\"        %-33s : %s\"),_T(\"Device Manufacturer\"),(LPCTSTR)Uint2Chars(nDevManuf));\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\tstrTmp.Format(_T(\"        %-33s : %s\"),_T(\"Device Model\"),(LPCTSTR)Uint2Chars(nDevModel));\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\tstrTmp.Format(_T(\"        %-33s : 0x%08X_%08X\"),_T(\"Device attributes\"),anDevAttrib[1],anDevAttrib[0]);\r\n\tm_pLog->AddLine(strTmp);\r\n\tstrTmp1 = (TestBit(anDevAttrib[0],0))?\"Transparency\":\"Reflective\";\r\n\tstrTmp.Format(_T(\"        %-35s > %s\"),_T(\"Device attributes\"),(LPCTSTR)strTmp1);\r\n\tm_pLog->AddLine(strTmp);\r\n\tstrTmp1 = (TestBit(anDevAttrib[0],1))?\"Matte\":\"Glossy\";\r\n\tstrTmp.Format(_T(\"        %-35s > %s\"),_T(\"Device attributes\"),(LPCTSTR)strTmp1);\r\n\tm_pLog->AddLine(strTmp);\r\n\tstrTmp1 = (TestBit(anDevAttrib[0],2))?\"Media polarity = positive\":\"Media polarity = negative\";\r\n\tstrTmp.Format(_T(\"        %-35s > %s\"),_T(\"Device attributes\"),(LPCTSTR)strTmp1);\r\n\tm_pLog->AddLine(strTmp);\r\n\tstrTmp1 = (TestBit(anDevAttrib[0],3))?\"Colour media\":\"Black & white media\";\r\n\tstrTmp.Format(_T(\"        %-35s > %s\"),_T(\"Device attributes\"),(LPCTSTR)strTmp1);\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\tswitch(nRenderIntent) {\r\n\t\tcase 0x00000000:\tstrTmp1.Format(_T(\"Perceptual\"));break;\r\n\t\tcase 0x00000001:\tstrTmp1.Format(_T(\"Media-Relative Colorimetric\"));break;\r\n\t\tcase 0x00000002:\tstrTmp1.Format(_T(\"Saturation\"));break;\r\n\t\tcase 0x00000003:\tstrTmp1.Format(_T(\"ICC-Absolute Colorimetric\"));break;\r\n\t\tdefault:\r\n\t\t\tstrTmp1.Format(_T(\"0x%08X\"),nRenderIntent);\r\n\t\t\tbreak;\r\n\t}\r\n\tstrTmp.Format(_T(\"        %-33s : %s\"),_T(\"Rendering intent\"),(LPCTSTR)strTmp1);\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\t// PCS illuminant\r\n\r\n\tstrTmp.Format(_T(\"        %-33s : %s\"),_T(\"Profile creator\"),(LPCTSTR)Uint2Chars(nProfCreatorSig));\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\tstrTmp.Format(_T(\"        %-33s : 0x%08X_%08X_%08X_%08X\"),_T(\"Profile ID\"),\r\n\t\tanProfId[3],anProfId[2],anProfId[1],anProfId[0]);\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\treturn 0;\r\n}\r\n\r\n// Provide special output formatter for ICC Date/Time\r\n// NOTE: It appears that the nParts had to be decoded in the\r\n//       reverse order from what I had expected, so one should\r\n//       confirm that the byte order / endianness is appropriate.\r\nCString CjfifDecode::DecodeIccDateTime(unsigned anVal[3])\r\n{\r\n\tCString\t\t\tstrDate;\r\n\tunsigned short\tanParts[6];\r\n\tanParts[0] = (anVal[2] & 0xFFFF0000) >> 16;\t// Year\r\n\tanParts[1] = (anVal[2] & 0x0000FFFF);\t\t\t// Mon\r\n\tanParts[2] = (anVal[1] & 0xFFFF0000) >> 16;\t// Day\r\n\tanParts[3] = (anVal[1] & 0x0000FFFF);\t\t\t// Hour\r\n\tanParts[4] = (anVal[0] & 0xFFFF0000) >> 16;\t// Min\r\n\tanParts[5] = (anVal[0] & 0x0000FFFF);\t\t\t// Sec\r\n\tstrDate.Format(_T(\"%04u-%02u-%02u %02u:%02u:%02u\"),\r\n\t\tanParts[0],anParts[1],anParts[2],anParts[3],anParts[4],anParts[5]);\r\n\treturn strDate;\r\n}\r\n\r\n\r\n// Parser for APP2 ICC profile marker\r\nunsigned CjfifDecode::DecodeApp2IccProfile(unsigned nLen)\r\n{\r\n\tCString\t\tstrTmp;\r\n\tunsigned\tnMarkerSeqNum;\t// Byte\r\n\tunsigned\tnNumMarkers;\t// Byte\r\n\tunsigned\tnPayloadLen;\t// Len of this ICC marker payload\r\n\r\n\tunsigned\tnMarkerPosStart;\r\n\r\n\tnMarkerSeqNum = Buf(m_nPos++);\r\n\tnNumMarkers = Buf(m_nPos++);\r\n\tnPayloadLen = nLen - 2 - 12 - 2; // TODO: check?\r\n\r\n\tstrTmp.Format(_T(\"      Marker Number = %u of %u\"),nMarkerSeqNum,nNumMarkers);\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\tif (nMarkerSeqNum == 1) {\r\n\t\tnMarkerPosStart = m_nPos;\r\n\t\tDecodeIccHeader(nMarkerPosStart);\r\n\t} else {\r\n\t\tm_pLog->AddLineWarn(_T(\"      Only support decode of 1st ICC Marker\"));\r\n\t}\r\n\r\n\treturn 0;\r\n}\r\n\r\n// Parser for APP2 FlashPix marker\r\nunsigned CjfifDecode::DecodeApp2Flashpix()\r\n{\r\n\r\n\tCString strTmp;\r\n\r\n\tunsigned\tnFpxVer;\r\n\tunsigned\tnFpxSegType;\r\n\tunsigned\tnFpxInteropCnt;\r\n\tunsigned\tnFpxEntitySz;\r\n\tunsigned\tnFpxDefault;\r\n\r\n\tbool\t\tbFpxStorage;\r\n\tCString\t\tstrFpxStorageClsStr;\r\n\tunsigned\tnFpxStIndexCont;\r\n\tunsigned\tnFpxStOffset;\r\n\r\n\tunsigned\tnFpxStWByteOrder;\r\n\tunsigned\tnFpxStWFormat;\r\n\tCString\t\tstrFpxStClsidStr;\r\n\tunsigned\tnFpxStDwOsVer;\r\n\tunsigned\tnFpxStRsvd;\r\n\r\n\tCString\t\tstreamStr;\r\n\r\n\tnFpxVer = Buf(m_nPos++);\r\n\tnFpxSegType = Buf(m_nPos++);\r\n\r\n\t// FlashPix segments: Contents List or Stream Data\r\n\r\n\tif (nFpxSegType == 1) {\r\n\t\t// Contents List\r\n\t\tstrTmp.Format(_T(\"    Segment: CONTENTS LIST\"));\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tnFpxInteropCnt = (Buf(m_nPos++)<<8) + Buf(m_nPos++);\r\n\t\tstrTmp.Format(_T(\"      Interoperability Count = %u\"),nFpxInteropCnt);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tfor (unsigned ind=0;ind<nFpxInteropCnt;ind++) {\r\n\t\t\tstrTmp.Format(_T(\"      Entity Index #%u\"),ind); \r\n\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t\tnFpxEntitySz = (Buf(m_nPos++)<<24) + (Buf(m_nPos++)<<16) + (Buf(m_nPos++)<<8) + Buf(m_nPos++);\r\n\r\n\t\t\t// If the \"entity size\" field is 0xFFFFFFFF, then it should be treated as\r\n\t\t\t// a \"storage\". It looks like we should probably be using this to determine\r\n\t\t\t// that we have a \"storage\"\r\n\t\t\tbFpxStorage = false;\r\n\t\t\tif (nFpxEntitySz == 0xFFFFFFFF) {\r\n\t\t\t\tbFpxStorage = true;\r\n\t\t\t}\r\n\r\n\t\t\tif (!bFpxStorage) {\r\n\t\t\t\tstrTmp.Format(_T(\"        Entity Size = %u\"),nFpxEntitySz);\r\n\t\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t\t} else {\r\n\t\t\t\tstrTmp.Format(_T(\"        Entity is Storage\"));\r\n\t\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t\t}\r\n\r\n\t\t\tnFpxDefault = Buf(m_nPos++);\r\n\r\n\r\n\t\t\t// BUG: #1112\r\n\t\t\t//streamStr = m_pWBuf->BufReadUniStr(m_nPos);\r\n\t\t\tstreamStr = m_pWBuf->BufReadUniStr2(m_nPos,MAX_BUF_READ_STR);\r\n\t\t\tm_nPos += 2*((unsigned)_tcslen(streamStr)+1); // 2x because unicode\r\n\r\n\t\t\tstrTmp.Format(_T(\"        Stream Name = [%s]\"),(LPCTSTR)streamStr);\r\n\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\r\n\t\t\t// In the case of \"storage\", we decode the next 16 bytes as the class\r\n\t\t\tif (bFpxStorage) {\r\n\r\n\t\t\t\t// FIXME:\r\n\t\t\t\t// NOTE: Very strange reordering required here. Doesn't seem consistent\r\n\t\t\t\t//       This means that other fields are probably wrong as well (endian)\r\n\t\t\t\tstrFpxStorageClsStr.Format(_T(\"%02X%02X%02X%02X-%02X%02X-%02X%02X-%02X%02X-%02X%02X%02X%02X%02X%02X\"),\r\n\t\t\t\t\tBuf(m_nPos+3),Buf(m_nPos+2),Buf(m_nPos+1),Buf(m_nPos+0),\r\n\t\t\t\t\tBuf(m_nPos+5),Buf(m_nPos+4),\r\n\t\t\t\t\tBuf(m_nPos+7),Buf(m_nPos+6),\r\n\t\t\t\t\tBuf(m_nPos+8),Buf(m_nPos+9),\r\n\t\t\t\t\tBuf(m_nPos+10),Buf(m_nPos+11),Buf(m_nPos+12),Buf(m_nPos+13),Buf(m_nPos+14),Buf(m_nPos+15) );\r\n\t\t\t\tm_nPos+= 16;\r\n\t\t\t\tstrTmp.Format(_T(\"        Storage Class = [%s]\"),(LPCTSTR)strFpxStorageClsStr);\r\n\t\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn 0;\r\n\r\n\t} else if (nFpxSegType == 2) {\r\n\t\t// Stream Data\r\n\t\tstrTmp.Format(_T(\"    Segment: STREAM DATA\"));\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tnFpxStIndexCont = (Buf(m_nPos++)<<8) + Buf(m_nPos++);\r\n\t\tstrTmp.Format(_T(\"      Index in Contents List = %u\"),nFpxStIndexCont);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tnFpxStOffset = (Buf(m_nPos++)<<24) + (Buf(m_nPos++)<<16) + (Buf(m_nPos++)<<8) + Buf(m_nPos++);\r\n\t\tstrTmp.Format(_T(\"      Offset in stream = %u (0x%08X)\"),nFpxStOffset,nFpxStOffset);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t// Now decode the Property Set Header\r\n\r\n\t\t// NOTE: Should only decode this if we are doing first part of stream\r\n\t\t// TODO: How do we know this? First reference to index #?\r\n\r\n\t\tnFpxStWByteOrder = (Buf(m_nPos++)<<8) + Buf(m_nPos++);\r\n\t\tnFpxStWFormat = (Buf(m_nPos++)<<8) + Buf(m_nPos++);\r\n\t\tnFpxStDwOsVer = (Buf(m_nPos++)<<24) + (Buf(m_nPos++)<<16) + (Buf(m_nPos++)<<8) + Buf(m_nPos++);\r\n\r\n\t\t// FIXME:\r\n\t\t// NOTE: Very strange reordering required here. Doesn't seem consistent!\r\n\t\t//       This means that other fields are probably wrong as well (endian)\r\n\t\tstrFpxStClsidStr.Format(_T(\"%02X%02X%02X%02X-%02X%02X-%02X%02X-%02X%02X-%02X%02X%02X%02X%02X%02X\"),\r\n\t\t\tBuf(m_nPos+3),Buf(m_nPos+2),Buf(m_nPos+1),Buf(m_nPos+0),\r\n\t\t\tBuf(m_nPos+5),Buf(m_nPos+4),\r\n\t\t\tBuf(m_nPos+7),Buf(m_nPos+6),\r\n\t\t\tBuf(m_nPos+8),Buf(m_nPos+9),\r\n\t\t\tBuf(m_nPos+10),Buf(m_nPos+11),Buf(m_nPos+12),Buf(m_nPos+13),Buf(m_nPos+14),Buf(m_nPos+15) );\r\n\t\tm_nPos+= 16;\r\n\t\tnFpxStRsvd = (Buf(m_nPos++)<<8) + Buf(m_nPos++);\r\n\r\n\t\tstrTmp.Format(_T(\"      ByteOrder = 0x%04X\"),nFpxStWByteOrder);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tstrTmp.Format(_T(\"      Format = 0x%04X\"),nFpxStWFormat);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tstrTmp.Format(_T(\"      OSVer = 0x%08X\"),nFpxStDwOsVer);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tstrTmp.Format(_T(\"      clsid = %s\"),(LPCTSTR)strFpxStClsidStr);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tstrTmp.Format(_T(\"      reserved = 0x%08X\"),nFpxStRsvd);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t// ....\r\n\r\n\t\treturn 2;\r\n\r\n\t} else {\r\n\t\tstrTmp.Format(_T(\"      Reserved Segment. Stopping.\"));\r\n\t\tm_pLog->AddLineErr(strTmp);\r\n\t\treturn 1;\r\n\t}\r\n\r\n}\r\n\r\n\r\n// Decode the DHT marker segment (Huffman Tables)\r\n// In some cases (such as for MotionJPEG), we fake out\r\n// the DHT tables (when bInject=true) with a standard table\r\n// as each JPEG frame in the MJPG does not include the DHT.\r\n// In all other cases (bInject=false), we simply read the\r\n// DHT table from the file buffer via Buf()\r\n//\r\n// ITU-T standard indicates that we can expect up to a\r\n// maximum of 16-bit huffman code bitstrings.\r\nvoid CjfifDecode::DecodeDHT(bool bInject)\r\n{\r\n\tunsigned\tnLength;\r\n\tunsigned\tnTmpVal;\r\n\tCString\t\tstrTmp,strFull;\r\n\tunsigned\tnPosEnd;\r\n\tunsigned\tnPosSaved;\r\n\r\n\tbool\t\tbRet;\r\n\r\n\r\n\tif (bInject) {\r\n\t\t// Redirect Buf() to DHT table in MJPGDHTSeg[]\r\n\t\t// ... so change mode that Buf() call uses\r\n\t\tm_bBufFakeDHT = true;\r\n\r\n\t\t// Preserve the \"m_nPos\" pointer, at end we undo it\r\n\t\t// And we also start at 2 which is just after FFC4 in array\r\n\t\tnPosSaved = m_nPos;\r\n\t\tm_nPos = 2;\r\n\t}\r\n\r\n\tnLength = Buf(m_nPos)*256 + Buf(m_nPos+1);\r\n\tnPosEnd = m_nPos+nLength;\r\n\tm_nPos+=2;\r\n\tstrTmp.Format(_T(\"  Huffman table length = %u\"),nLength); \r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\tunsigned\tnDhtClass_Tc;\t\t// Range 0..1\r\n\tunsigned\tnDhtHuffTblId_Th;\t// Range 0..3\r\n\r\n\t// In various places, added m_bStateAbort check to allow us\r\n\t// to escape in case we get in excessive number of DHT entries\r\n\t// See BUG FIX #1003\r\n\r\n\twhile ((!m_bStateAbort)&&(nPosEnd > m_nPos))\r\n\t{\r\n\t\tm_pLog->AddLine(_T(\"  ----\"));\r\n\r\n\t\tnTmpVal = Buf(m_nPos++);\r\n\t\tnDhtClass_Tc = (nTmpVal & 0xF0) >> 4;\t// Tc, range 0..1\r\n\t\tnDhtHuffTblId_Th = nTmpVal & 0x0F;\t\t// Th, range 0..3\r\n\t\tstrTmp.Format(_T(\"  Destination ID = %u\"),nDhtHuffTblId_Th);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\t\tstrTmp.Format(_T(\"  Class = %u (%s)\"),nDhtClass_Tc,(nDhtClass_Tc?_T(\"AC Table\"):_T(\"DC / Lossless Table\")));\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t// Add in some error checking to prevent \r\n\t\tif (nDhtClass_Tc >= MAX_DHT_CLASS) {\r\n\t\t\tstrTmp.Format(_T(\"ERROR: Invalid DHT Class (%u). Aborting DHT Load.\"),nDhtClass_Tc);\r\n\t\t\tm_pLog->AddLineErr(strTmp);\r\n\t\t\tm_nPos = nPosEnd;\r\n\t\t\t//m_bStateAbort = true;\t// Stop decoding\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tif (nDhtHuffTblId_Th >= MAX_DHT_DEST_ID) {\r\n\t\t\tstrTmp.Format(_T(\"ERROR: Invalid DHT Dest ID (%u). Aborting DHT Load.\"),nDhtHuffTblId_Th);\r\n\t\t\tm_pLog->AddLineErr(strTmp);\r\n\t\t\tm_nPos = nPosEnd;\r\n\t\t\t//m_bStateAbort = true;\t// Stop decoding\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t// Read in the array of DHT code lengths\r\n\t\tfor (unsigned int i=1;i<=MAX_DHT_CODELEN;i++)\r\n\t\t{\r\n\t\t\tm_anDhtNumCodesLen_Li[i] = Buf(m_nPos++);\t// Li, range 0..255\r\n\t\t}\r\n\r\n\t\t#define DECODE_DHT_MAX_DHT 256\r\n\r\n\t\tunsigned int\tanDhtCodeVal[DECODE_DHT_MAX_DHT+1]; // Should only need max 162 codes\r\n\t\tunsigned int\tnDhtInd;\r\n\t\tunsigned int\tnDhtCodesTotal;\r\n\r\n\t\t// Clear out the code list\r\n\t\tfor (nDhtInd = 0;nDhtInd <DECODE_DHT_MAX_DHT;nDhtInd++)\r\n\t\t{\r\n\t\t\tanDhtCodeVal[nDhtInd] = 0xFFFF; // Dummy value\r\n\t\t}\r\n\r\n\t\t// Now read in all of the DHT codes according to the lengths\r\n\t\t// read in earlier\r\n\t\tnDhtCodesTotal = 0;\r\n\t\tnDhtInd = 0;\r\n\t\tfor (unsigned int nIndLen=1;((!m_bStateAbort)&&(nIndLen<=MAX_DHT_CODELEN));nIndLen++)\r\n\t\t{\r\n\t\t\t// Keep a total count of the number of DHT codes read\r\n\t\t\tnDhtCodesTotal += m_anDhtNumCodesLen_Li[nIndLen];\r\n\r\n\t\t\tstrFull.Format(_T(\"    Codes of length %02u bits (%03u total): \"),nIndLen,m_anDhtNumCodesLen_Li[nIndLen]);\r\n\t\t\tfor (unsigned int nIndCode=0;((!m_bStateAbort)&&(nIndCode<m_anDhtNumCodesLen_Li[nIndLen]));nIndCode++)\r\n\t\t\t{\r\n\t\t\t\t// Start a new line for every 16 codes\r\n\t\t\t\tif ( (nIndCode != 0) && ((nIndCode % 16) == 0) ) {\r\n\t\t\t\t\tstrFull = _T(\"                                         \");\r\n\t\t\t\t}\r\n\t\t\t\tnTmpVal = Buf(m_nPos++);\r\n\t\t\t\tstrTmp.Format(_T(\"%02X \"),nTmpVal);\r\n\t\t\t\tstrFull += strTmp;\r\n\r\n\t\t\t\t// Only write 16 codes per line\r\n\t\t\t\tif ((nIndCode % 16) == 15) {\r\n\t\t\t\t\tm_pLog->AddLine(strFull);\r\n\t\t\t\t\tstrFull = _T(\"\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Save the huffman code\r\n\t\t\t\t// Just in case we have more DHT codes than we expect, trap\r\n\t\t\t\t// the range check here, otherwise we'll have buffer overrun!\r\n\t\t\t\tif (nDhtInd < DECODE_DHT_MAX_DHT) {\r\n\t\t\t\t\tanDhtCodeVal[nDhtInd++] = nTmpVal;\t// Vij, range 0..255\r\n\t\t\t\t} else {\r\n\t\t\t\t\tnDhtInd++;\r\n\t\t\t\t\tstrTmp.Format(_T(\"Excessive DHT entries (%u)... skipping\"),nDhtInd);\r\n\t\t\t\t\tm_pLog->AddLineErr(strTmp);\r\n\t\t\t\t\tif (!m_bStateAbort) { DecodeErrCheck(true); }\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\tm_pLog->AddLine(strFull);\r\n\t\t}\r\n\t\tstrTmp.Format(_T(\"    Total number of codes: %03u\"),nDhtCodesTotal);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tunsigned int nDhtLookupInd = 0;\r\n\r\n\t\t// Now print out the actual binary strings!\r\n\t\tunsigned long\tnBitVal = 0;\r\n\t\tunsigned int\tnCodeVal = 0;\r\n\t\tnDhtInd = 0;\r\n\t\tif (m_pAppConfig->bOutputDHTexpand) {\r\n\t\t\tm_pLog->AddLine(_T(\"\"));\r\n\t\t\tm_pLog->AddLine(_T(\"  Expanded Form of Codes:\"));\r\n\t\t}\r\n\t\tfor (unsigned int nBitLen=1;((!m_bStateAbort)&&(nBitLen<=16));nBitLen++)\r\n\t\t{\r\n\t\t\tif (m_anDhtNumCodesLen_Li[nBitLen] > 0)\r\n\t\t\t{\r\n\t\t\t\tif (m_pAppConfig->bOutputDHTexpand) {\r\n\t\t\t\t\tstrTmp.Format(_T(\"    Codes of length %02u bits:\"),nBitLen);\r\n\t\t\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t\t\t}\r\n\t\t\t\t// Codes exist for this bit-length\r\n\t\t\t\t// Walk through and generate the bitvalues\r\n\t\t\t\tfor (unsigned int bit_ind=1;((!m_bStateAbort)&&(bit_ind<=m_anDhtNumCodesLen_Li[nBitLen]));bit_ind++)\r\n\t\t\t\t{\r\n\t\t\t\t\tunsigned int\tnDecVal = nCodeVal;\r\n\t\t\t\t\tunsigned int\tnBinBit;\r\n\t\t\t\t\tTCHAR\t\t\tacBinStr[17] = _T(\"\");\r\n\t\t\t\t\tunsigned int\tnBinStrLen = 0;\r\n\r\n\t\t\t\t\t// If the user has enabled output of DHT expanded tables,\r\n\t\t\t\t\t// report the bit-string sequences.\r\n\t\t\t\t\tif (m_pAppConfig->bOutputDHTexpand) {\r\n\t\t\t\t\t\tfor (unsigned int nBinInd=nBitLen;nBinInd>=1;nBinInd--)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tnBinBit = (nDecVal >> (nBinInd-1)) & 1;\r\n\t\t\t\t\t\t\tacBinStr[nBinStrLen++] = (nBinBit)?'1':'0';\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tacBinStr[nBinStrLen] = '\\0';\r\n\t\t\t\t\t\tstrFull.Format(_T(\"      %s = %02X\"),acBinStr,anDhtCodeVal[nDhtInd]);\r\n\r\n\t\t\t\t\t\t// The following are only valid for AC components\r\n\t\t\t\t\t\t// Bug [3442132]\r\n\t\t\t\t\t\tif (nDhtClass_Tc == DHT_CLASS_AC) {\r\n\t\t\t\t\t\t\tif (anDhtCodeVal[nDhtInd] == 0x00) { strFull += _T(\" (EOB)\"); }\r\n\t\t\t\t\t\t\tif (anDhtCodeVal[nDhtInd] == 0xF0) { strFull += _T(\" (ZRL)\"); }\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tstrTmp.Format(_T(\"%-40s (Total Len = %2u)\"),(LPCTSTR)strFull,nBitLen + (anDhtCodeVal[nDhtInd] & 0xF));\r\n\r\n\t\t\t\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Store the lookup value\r\n\t\t\t\t\t// Shift left to MSB of 32-bit\r\n\t\t\t\t\tunsigned nTmpMask = m_anMaskLookup[nBitLen];\r\n\r\n\t\t\t\t\tunsigned nTmpBits = nDecVal << (32-nBitLen);\r\n\t\t\t\t\tunsigned nTmpCode = anDhtCodeVal[nDhtInd];\r\n\t\t\t\t\tbRet = m_pImgDec->SetDhtEntry(nDhtHuffTblId_Th,nDhtClass_Tc,nDhtLookupInd,nBitLen,\r\n\t\t\t\t\t\tnTmpBits,nTmpMask,nTmpCode);\r\n\r\n\t\t\t\t\tDecodeErrCheck(bRet);\r\n\r\n\t\t\t\t\tnDhtLookupInd++;\r\n\r\n\t\t\t\t\t// Move to the next code\r\n\t\t\t\t\tnCodeVal++;\r\n\t\t\t\t\tnDhtInd++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// For each loop iteration (on bit length), we shift the code value\r\n\t\t\tnCodeVal <<= 1;\r\n\t\t}\r\n\r\n\r\n\t\t// Now store the dht_lookup_size\r\n\t\tunsigned nTmpSize = nDhtLookupInd;\r\n\t\tbRet = m_pImgDec->SetDhtSize(nDhtHuffTblId_Th,nDhtClass_Tc,nTmpSize);\r\n\t\tif (!m_bStateAbort) { DecodeErrCheck(bRet); }\r\n\r\n\t\tm_pLog->AddLine(_T(\"\"));\r\n\r\n\t}\r\n\r\n\tif (bInject) {\r\n\t\t// Restore position (as if we didn't move)\r\n\t\tm_nPos = nPosSaved;\r\n\t\tm_bBufFakeDHT = false;\r\n\t}\r\n}\r\n\r\n\r\n// Check return value of previous call. If failed, then ask\r\n// user if they wish to continue decoding. If no, then flag to\r\n// the decoder that we're done (avoids continuous failures)\r\nvoid CjfifDecode::DecodeErrCheck(bool bRet)\r\n{\r\n\tif (!bRet) {\r\n\t\tif (m_pAppConfig->bInteractive) {\r\n\t\t\tif (AfxMessageBox(_T(\"Do you want to continue decoding?\"),MB_YESNO|MB_ICONQUESTION)== IDNO) {\r\n\t\t\t\tm_bStateAbort = true;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// This routine is called after the expected fields of the marker segment\r\n// have been processed. The file position should line up with the offset\r\n// dictated by the marker length. If a mismatch is detected, report an\r\n// error.\r\n//\r\n// RETURN:\r\n// - True if decode error is fatal (configurable)\r\n//\r\nbool CjfifDecode::ExpectMarkerEnd(unsigned long nMarkerStart,unsigned nMarkerLen)\r\n{\r\n\tCString\t\t\tstrTmp;\r\n\tunsigned long\tnMarkerEnd = nMarkerStart + nMarkerLen;\r\n\tunsigned long\tnMarkerExtra = nMarkerEnd - m_nPos;\r\n\tif (m_nPos < nMarkerEnd) {\r\n\t\t// The length indicates that there is more data than we processed\r\n\t\tstrTmp.Format(_T(\"  WARNING: Marker length longer than expected\"));\r\n\t\tm_pLog->AddLineWarn(strTmp);\r\n\t\tif (!m_pAppConfig->bRelaxedParsing) {\r\n\t\t\t// Abort\r\n\t\t\tm_pLog->AddLineErr(_T(\"  Stopping decode\"));\r\n\t\t\tm_pLog->AddLineErr(_T(\"  Use [Img Search Fwd/Rev] to locate other valid embedded JPEGs\"));\r\n\t\t\treturn false;\r\n\t\t} else {\r\n\t\t\t// Warn and skip\r\n\t\t\tstrTmp.Format(_T(\"  Skipping remainder [%u bytes]\"),nMarkerExtra);\r\n\t\t\tm_pLog->AddLineWarn(strTmp);\r\n\t\t\tm_nPos += nMarkerExtra;\r\n\t\t}\r\n\t} else if (m_nPos > nMarkerEnd) {\r\n\t\t// The length indicates that there is less data than we processed\r\n\t\tstrTmp.Format(_T(\"  WARNING: Marker length shorter than expected\"));\r\n\t\tm_pLog->AddLineWarn(strTmp);\r\n\t\tif (!m_pAppConfig->bRelaxedParsing) {\r\n\t\t\t// Abort\r\n\t\t\tm_pLog->AddLineErr(_T(\"  Stopping decode\"));\r\n\t\t\tm_pLog->AddLineErr(_T(\"  Use [Img Search Fwd/Rev] to locate other valid embedded JPEGs\"));\r\n\t\t\treturn false;\r\n\t\t} else {\r\n\t\t\t// Warn but no skip\r\n\t\t\t// Note that we can't skip as the length would imply a rollback\r\n\t\t\t// Most resilient solution is probably to assume length was\r\n\t\t\t// wrong and continue from where the marker should have ended.\r\n\t\t\t// For resiliency, attempt two methods to find point to resume:\r\n\t\t\t// 1) Current position\r\n\t\t\t// 2) Actual length defined in marker\r\n\t\t\tif (Buf(m_nPos) == 0xFF) {\r\n\t\t\t\t// Using actual data expected seems more promising\r\n\t\t\t\tm_pLog->AddLineWarn(_T(\"  Resuming decode\"));\r\n\t\t\t} else if (Buf(nMarkerEnd) == 0xFF) {\r\n\t\t\t\t// Using actual length seems more promising\r\n\t\t\t\tm_nPos = nMarkerEnd;\r\n\t\t\t\tm_pLog->AddLineWarn(_T(\"  Rolling back pointer to end indicated by length\"));\r\n\t\t\t\tm_pLog->AddLineWarn(_T(\"  Resuming decode\"));\r\n\t\t\t} else {\r\n\t\t\t\t// No luck. Expect marker failure now\r\n\t\t\t\tm_pLog->AddLineWarn(_T(\"  Resuming decode\"));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// If we get here, then we haven't seen a fatal issue\r\n\treturn true;\r\n}\r\n\r\n// Validate an unsigned value to ensure it is in allowable range\r\n// - If the value is outside the range, an error is shown and\r\n//   the parsing stops if relaxed parsing is not enabled\r\n// - An optional override value is provided for the resume case\r\n//\r\n// INPUT:\r\n// - nVal\t\t\tInput value (unsigned 32-bit)\r\n// - nMin\t\t\tMinimum allowed value\r\n// - nMax\t\t\tMaximum allowed value\r\n// - strName\t\tName of the field\r\n// - bOverride\t\tShould we override the value upon out-of-range?\r\n// - nOverrideVal\tValue to override if bOverride and out-of-range\r\n//\r\n// PRE:\r\n// - m_pAppConfig\r\n//\r\n// OUTPUT:\r\n// - nVal\t\t\tOutput value (including any override)\r\n//\r\nbool CjfifDecode::ValidateValue(unsigned &nVal,unsigned nMin,unsigned nMax,CString strName,bool bOverride,unsigned nOverrideVal)\r\n{\r\n\tCString\t\tstrErr;\r\n\tif ((nVal >= nMin) && (nVal <= nMax)) {\r\n\t\t// Value is within range\r\n\t\treturn true;\r\n\t} else {\r\n\t\tif (nVal < nMin) {\r\n\t\t\tstrErr.Format(_T(\"  ERROR: %s value too small (Actual = %u, Expected >= %u)\"),\r\n\t\t\t\t(LPCTSTR)strName,nVal,nMin);\r\n\t\t\tm_pLog->AddLineErr(strErr);\r\n\t\t} else if (nVal > nMax) {\r\n\t\t\tstrErr.Format(_T(\"  ERROR: %s value too large (Actual = %u, Expected <= %u)\"),\r\n\t\t\t\t(LPCTSTR)strName,nVal,nMax);\r\n\t\t\tm_pLog->AddLineErr(strErr);\r\n\t\t}\r\n\t\tif (!m_pAppConfig->bRelaxedParsing) {\r\n\t\t\t// Defined as fatal error\r\n\t\t\t// TODO: Replace with glb_strMsgStopDecode?\r\n\t\t\tm_pLog->AddLineErr(_T(\"  Stopping decode\"));\r\n\t\t\tm_pLog->AddLineErr(_T(\"  Use [Relaxed Parsing] to continue\"));\r\n\t\t\treturn false;\r\n\t\t} else {\r\n\t\t\t// Non-fatal\r\n\t\t\tif (bOverride) {\r\n\t\t\t\t// Update value with override\r\n\t\t\t\tnVal = nOverrideVal;\r\n\t\t\t\tstrErr.Format(_T(\"  WARNING: Forcing value to [%u]\"),nOverrideVal);\r\n\t\t\t\tm_pLog->AddLineWarn(strErr);\r\n\t\t\t\tm_pLog->AddLineWarn(_T(\"  Resuming decode\"));\r\n\t\t\t} else {\r\n\t\t\t\t// No override\r\n\t\t\t\tstrErr.Format(_T(\"  Resuming decode\"));\r\n\t\t\t\tm_pLog->AddLineWarn(strErr);\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n}\r\n\r\n// This is the primary JFIF marker parser. It reads the\r\n// marker value at the current file position and launches the\r\n// specific parser routine. This routine exits when \r\n#define DECMARK_OK 0\r\n#define DECMARK_ERR 1\r\n#define DECMARK_EOI 2\r\nunsigned CjfifDecode::DecodeMarker()\r\n{\r\n\tTCHAR\t\t\tacIdentifier[MAX_IDENTIFIER];\r\n\tCString\t\t\tstrTmp;\r\n\tCString\t\t\tstrFull;\t\t\t\t// Used for concatenation\r\n\tunsigned\t\tnLength;\t\t\t\t// General purpose\r\n\tunsigned\t\tnTmpVal;\r\n\tunsigned\t\tnCode;\r\n\tunsigned long\tnPosEnd;\r\n\tunsigned long\tnPosSaved;\t\t\t\t// General-purpose saved position in file\r\n\tunsigned long\tnPosExifStart;\r\n\tunsigned\t\tnRet;\t\t\t\t\t// General purpose return value\r\n\tbool\t\t\tbRet;\r\n\tunsigned long\tnPosMarkerStart;\t\t// Offset for current marker\r\n\r\n\tunsigned\t\tnColTransform = 0;\t\t// Color Transform from APP14 marker\r\n\r\n\t// For DQT\r\n\tCString\tstrDqtPrecision = _T(\"\");\r\n\tCString\tstrDqtZigZagOrder = _T(\"\");\r\n\r\n\r\n\tif (Buf(m_nPos) != 0xFF) {\r\n\t\tif (m_nPos == 0) {\r\n\t\t\t// Don't give error message if we've already alerted them of AVI / PSD\r\n\t\t\tif ((!m_bAvi) && (!m_bPsd)) {\r\n\t\t\t\tstrTmp.Format(_T(\"NOTE: File did not start with JPEG marker. Consider using [Tools->Img Search Fwd] to locate embedded JPEG.\"));\r\n\t\t\t\tm_pLog->AddLineErr(strTmp);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tstrTmp.Format(_T(\"ERROR: Expected marker 0xFF, got 0x%02X @ offset 0x%08X. Consider using [Tools->Img Search Fwd/Rev].\"),Buf(m_nPos),m_nPos);\r\n\t\t\tm_pLog->AddLineErr(strTmp);\r\n\t\t}\r\n\t\tm_nPos++;\r\n\t\treturn DECMARK_ERR;\r\n\t}\r\n\tm_nPos++;\r\n\r\n\r\n\t// Read the current marker code\r\n\tnCode = Buf(m_nPos++);\r\n\r\n\t// Handle Marker Padding\r\n\t//\r\n\t// According to Section B.1.1.2:\r\n\t//   \"Any marker may optionally be preceded by any number of fill bytes, which are bytes assigned code X\ufffdFF\ufffd.\"\r\n\t//\r\n\tunsigned\tnSkipMarkerPad = 0;\r\n\twhile (nCode == 0xFF) {\r\n\t\t// Count the pad\r\n\t\tnSkipMarkerPad++;\r\n\t\t// Read another byte\r\n\t\tnCode = Buf(m_nPos++);\r\n\t}\r\n\r\n\t// Report out any padding\r\n\tif (nSkipMarkerPad>0) {\r\n\t\tstrTmp.Format(_T(\"*** Skipped %u marker pad bytes ***\"),nSkipMarkerPad);\r\n\t\tm_pLog->AddLineHdr(strTmp);\r\n\t}\r\n\r\n\r\n\t// Save the current marker offset\r\n\tnPosMarkerStart = m_nPos;\r\n\r\n\tAddHeader(nCode);\r\n\r\n\tswitch (nCode)\r\n\t{\r\n\tcase JFIF_SOI: // SOI\r\n\t\tm_bStateSoi = true;\r\n\t\tbreak;\r\n\r\n\r\n\tcase JFIF_APP12:\r\n\t\t// Photoshop DUCKY (Save For Web)\r\n\t\tnLength = Buf(m_nPos)*256 + Buf(m_nPos+1);\r\n\t\t//nLength = m_pWBuf->BufX(m_nPos,2,!m_nImgExifEndian);\r\n\t\tstrTmp.Format(_T(\"  Length          = %u\"),nLength);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tnPosSaved = m_nPos;\r\n\r\n\t\tm_nPos += 2; // Move past length now that we've used it\r\n\r\n\t\t_tcscpy_s(acIdentifier,MAX_IDENTIFIER,m_pWBuf->BufReadStrn(m_nPos,MAX_IDENTIFIER-1));\r\n\t\tacIdentifier[MAX_IDENTIFIER-1] = 0; // Null terminate just in case\r\n\t\tstrTmp.Format(_T(\"  Identifier      = [%s]\"),acIdentifier);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\t\tm_nPos += (unsigned)_tcslen(acIdentifier)+1;\r\n\t\tif (_tcscmp(acIdentifier,_T(\"Ducky\")) != 0)\r\n\t\t{\r\n\t\t\tm_pLog->AddLine(_T(\"    Not Photoshop DUCKY. Skipping remainder.\"));\r\n\t\t}\r\n\t\telse // Photoshop\r\n\t\t{\r\n\t\t\t// Please see reference on http://cpan.uwinnipeg.ca/htdocs/Image-ExifTool/Image/ExifTool/APP12.pm.html\r\n\t\t\t// A direct indexed approach should be safe\r\n\t\t\tm_nImgQualPhotoshopSfw = Buf(m_nPos+6);\r\n\t\t\tstrTmp.Format(_T(\"  Photoshop Save For Web Quality = [%d]\"),m_nImgQualPhotoshopSfw);\r\n\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t}\r\n\t\t// Restore original position in file to a point\r\n\t\t// after the section\r\n\t\tm_nPos = nPosSaved+nLength;\r\n\t\tbreak;\r\n\r\n\tcase JFIF_APP14:\r\n\t\t// JPEG Adobe  tag\r\n\r\n\t\tnLength = Buf(m_nPos)*256 + Buf(m_nPos+1);\r\n\t\tstrTmp.Format(_T(\"  Length            = %u\"),nLength);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tnPosSaved = m_nPos;\r\n\t\t// Some files had very short segment (eg. nLength=2)\r\n\t\tif (nLength < 2+12) {\r\n\t\t\tm_pLog->AddLine(_T(\"    Segment too short for Identifier. Skipping remainder.\"));\r\n\t\t\tm_nPos = nPosSaved+nLength;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tm_nPos += 2; // Move past length now that we've used it\r\n\r\n\t\t// TODO: Confirm Adobe flag\r\n\t\tm_nPos += 5;\r\n\r\n\t\tnTmpVal = Buf(m_nPos+0)*256 + Buf(m_nPos+1);\r\n\t\tstrTmp.Format(_T(\"  DCTEncodeVersion  = %u\"),nTmpVal);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tnTmpVal = Buf(m_nPos+2)*256 + Buf(m_nPos+3);\r\n\t\tstrTmp.Format(_T(\"  APP14Flags0       = %u\"),nTmpVal);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tnTmpVal = Buf(m_nPos+4)*256 + Buf(m_nPos+5);\r\n\t\tstrTmp.Format(_T(\"  APP14Flags1       = %u\"),nTmpVal);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tnColTransform = Buf(m_nPos+6);\r\n\t\tswitch (nColTransform) {\r\n\t\tcase APP14_COLXFM_UNK_RGB:\r\n\t\t\tstrTmp.Format(_T(\"  ColorTransform    = %u [Unknown (RGB or CMYK)]\"),nColTransform);\r\n\t\t\tbreak;\r\n\t\tcase APP14_COLXFM_YCC:\r\n\t\t\tstrTmp.Format(_T(\"  ColorTransform    = %u [YCbCr]\"),nColTransform);\r\n\t\t\tbreak;\r\n\t\tcase APP14_COLXFM_YCCK:\r\n\t\t\tstrTmp.Format(_T(\"  ColorTransform    = %u [YCCK]\"),nColTransform);\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tstrTmp.Format(_T(\"  ColorTransform    = %u [???]\"),nColTransform);\r\n\t\t\tbreak;\r\n\r\n\t\t}\r\n\t\tm_pLog->AddLine(strTmp);\r\n\t\tm_nApp14ColTransform = (nColTransform & 0xFF);\r\n\r\n\t\t// Restore original position in file to a point\r\n\t\t// after the section\r\n\t\tm_nPos = nPosSaved+nLength;\r\n\r\n\t\tbreak;\r\n\r\n\tcase JFIF_APP13:\r\n\t\t// Photoshop (Save As)\r\n\t\tnLength = Buf(m_nPos)*256 + Buf(m_nPos+1);\r\n\t\t//nLength = m_pWBuf->BufX(m_nPos,2,!m_nImgExifEndian);\r\n\t\tstrTmp.Format(_T(\"  Length          = %u\"),nLength);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tnPosSaved = m_nPos;\r\n\r\n\t\t// Some files had very short segment (eg. nLength=2)\r\n\t\tif (nLength < 2+20) {\r\n\t\t\tm_pLog->AddLine(_T(\"    Segment too short for Identifier. Skipping remainder.\"));\r\n\t\t\tm_nPos = nPosSaved+nLength;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tm_nPos += 2; // Move past length now that we've used it\r\n\r\n\t\t_tcscpy_s(acIdentifier,MAX_IDENTIFIER,m_pWBuf->BufReadStrn(m_nPos,MAX_IDENTIFIER-1));\r\n\t\tacIdentifier[MAX_IDENTIFIER-1] = 0; // Null terminate just in case\r\n\t\tstrTmp.Format(_T(\"  Identifier      = [%s]\"),acIdentifier);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\t\tm_nPos += (unsigned)_tcslen(acIdentifier)+1;\r\n\t\tif (_tcscmp(acIdentifier,_T(\"Photoshop 3.0\")) != 0)\r\n\t\t{\r\n\t\t\tm_pLog->AddLine(_T(\"    Not Photoshop. Skipping remainder.\"));\r\n\t\t}\r\n\t\telse // Photoshop\r\n\t\t{\r\n\t\t\tDecodeApp13Ps();\r\n\t\t}\r\n\t\t// Restore original position in file to a point\r\n\t\t// after the section\r\n\t\tm_nPos = nPosSaved+nLength;\r\n\t\tbreak;\r\n\r\n\tcase JFIF_APP1:\r\n\t\tnLength = Buf(m_nPos)*256 + Buf(m_nPos+1);\r\n\t\t//nLength = m_pWBuf->BufX(m_nPos,2,!m_nImgExifEndian);\r\n\t\tstrTmp.Format(_T(\"  Length          = %u\"),nLength);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tnPosSaved = m_nPos;\r\n\r\n\t\tm_nPos += 2; // Move past length now that we've used it\r\n\r\n\t\t_tcscpy_s(acIdentifier,MAX_IDENTIFIER,m_pWBuf->BufReadStrn(m_nPos,MAX_IDENTIFIER-1));\r\n\t\tacIdentifier[MAX_IDENTIFIER-1] = 0; // Null terminate just in case\r\n\t\tstrTmp.Format(_T(\"  Identifier      = [%s]\"),acIdentifier);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\t\tm_nPos += (unsigned)_tcslen(acIdentifier);\r\n\r\n\r\n\t\tif (!_tcsnccmp(acIdentifier,_T(\"http://ns.adobe.com/xap/1.0/\\x00\"),29) != 0) {\r\n\t\t\t// XMP\r\n\r\n\t\t\tm_pLog->AddLine(_T(\"    XMP = \"));\r\n\r\n\t\t\tm_nPos++;\r\n\r\n\t\t\tunsigned nPosMarkerEnd = nPosSaved+nLength-1;\r\n\t\t\tunsigned sXmpLen = nPosMarkerEnd-m_nPos;\r\n\t\t\tchar cXmpChar;\r\n\t\t\tbool bNonSpace;\r\n\t\t\tCString strLine;\r\n\r\n\t\t\t// Reset state\r\n\t\t\tstrLine = _T(\"          |\");\r\n\t\t\tbNonSpace = false;\r\n\r\n\t\t\tfor (unsigned nInd=0;nInd<sXmpLen;nInd++) {\r\n\r\n\t\t\t\t// Get the next char\r\n\t\t\t\tcXmpChar = (char)m_pWBuf->Buf(m_nPos+nInd);\r\n\r\n\t\t\t\t// Detect a non-space in line\r\n\t\t\t\tif ((cXmpChar != 0x20) && (cXmpChar != 0x0A)) {\r\n\t\t\t\t\tbNonSpace = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Detect Linefeed, print out line\r\n\t\t\t\tif (cXmpChar == 0x0A) {\r\n\t\t\t\t\t// Only print line if some non-space elements!\r\n\t\t\t\t\tif (bNonSpace) {\r\n\t\t\t\t\t\tm_pLog->AddLine(strLine);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// Reset state\r\n\t\t\t\t\tstrLine = _T(\"          |\");\r\n\t\t\t\t\tbNonSpace = false;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Add the char\r\n\t\t\t\t\tstrLine.AppendChar(cXmpChar);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (!_tcscmp(acIdentifier,_T(\"Exif\")) != 0)\r\n\t\t{\r\n\t\t\t// Only decode it further if it is EXIF format\r\n\r\n\t\t\tm_nPos += 2; // Skip two 00 bytes\r\n\r\n\r\n\t\t\tnPosExifStart = m_nPos; // Save m_nPos @ start of EXIF used for all IFD offsets\r\n\r\n\t\t\t// =========== EXIF TIFF Header (Start) ===========\r\n\t\t\t// - Defined in Exif 2.2 Standard (JEITA CP-3451) section 4.5.2 \r\n\t\t\t// - Contents (8 bytes total)\r\n\t\t\t//   - Byte order (2 bytes)\r\n\t\t\t//   - 0x002A (2 bytes)\r\n\t\t\t//   - Offset of 0th IFD (4 bytes)\r\n\r\n\t\t\tunsigned char acIdentifierTiff[9];\r\n\t\t\tstrFull = _T(\"\");\r\n\t\t\tstrTmp = _T(\"\");\r\n\r\n\t\t\tstrFull = _T(\"  Identifier TIFF = \");\r\n\t\t\tfor (unsigned int i=0;i<8;i++) {\r\n\t\t\t\tacIdentifierTiff[i] = (unsigned char)Buf(m_nPos++);\r\n\t\t\t}\r\n\t\t\tstrTmp = PrintAsHexUC(acIdentifierTiff,8);\r\n\t\t\tstrFull += strTmp;\r\n\t\t\tm_pLog->AddLine(strFull);\r\n\r\n\r\n\t\t\tswitch (acIdentifierTiff[0]*256+acIdentifierTiff[1])\r\n\t\t\t{\r\n\t\t\tcase 0x4949: // \"II\"\r\n\t\t\t\t// Intel alignment\r\n\t\t\t\tm_nImgExifEndian = 0;\r\n\t\t\t\tm_pLog->AddLine(_T(\"  Endian          = Intel (little)\"));\r\n\t\t\t\tbreak;\r\n\t\t\tcase 0x4D4D: // \"MM\"\r\n\t\t\t\t// Motorola alignment\r\n\t\t\t\tm_nImgExifEndian = 1;\r\n\t\t\t\tm_pLog->AddLine(_T(\"  Endian          = Motorola (big)\"));\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\t// We expect the TAG mark of 0x002A (depending on endian mode)\r\n\t\t\tunsigned test_002a;\r\n\t\t\ttest_002a = ByteSwap2(acIdentifierTiff[2],acIdentifierTiff[3]);\r\n\t\t\tstrTmp.Format(_T(\"  TAG Mark x002A  = 0x%04X\"),test_002a);\r\n\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t\tunsigned nIfdCount;     // Current IFD #\r\n\t\t\tunsigned nOffsetIfd1;\r\n\r\n\t\t\t// Mark pointer to EXIF Sub IFD as 0 so that we can\r\n\t\t\t// detect if the tag never showed up.\r\n\t\t\tm_nImgExifSubIfdPtr = 0;\r\n\t\t\tm_nImgExifMakerPtr = 0;\r\n\t\t\tm_nImgExifGpsIfdPtr = 0;\r\n\t\t\tm_nImgExifInteropIfdPtr = 0;\r\n\r\n\t\t\tbool exif_done = FALSE;\r\n\r\n\t\t\tnOffsetIfd1 = ByteSwap4(acIdentifierTiff[4],acIdentifierTiff[5],\r\n\t\t\t\tacIdentifierTiff[6],acIdentifierTiff[7]);\r\n\r\n\t\t\t// =========== EXIF TIFF Header (End) ===========\r\n\r\n\t\t\t// =========== EXIF IFD 0 ===========\r\n\t\t\t// Do we start the 0th IFD for the \"Primary Image Data\"?\r\n\t\t\t// Even though the nOffsetIfd1 pointer should indicate to\r\n\t\t\t// us where the IFD should start (0x0008 if immediately after\r\n\t\t\t// EXIF TIFF Header), I have observed JPEG files that\r\n\t\t\t// do not contain the IFD. Therefore, we must check for this\r\n\t\t\t// condition by comparing against the APP marker length.\r\n\t\t\t// Example file: http://img9.imageshack.us/img9/194/90114543.jpg\r\n\r\n\t\t\tif ((nPosSaved + nLength) <= (nPosExifStart+nOffsetIfd1)) {\r\n\t\t\t\t// We've run out of space for any IFD, so cancel now\r\n\t\t\t\texif_done = true;\r\n\t\t\t\tm_pLog->AddLine(_T(\"  NOTE: No IFD entries\"));\r\n\t\t\t}\r\n\r\n\r\n\t\t\tnIfdCount = 0;\r\n\t\t\twhile (!exif_done) {\r\n\r\n\t\t\t\tm_pLog->AddLine(_T(\"\"));\r\n\r\n\t\t\t\tstrTmp.Format(_T(\"IFD%u\"),nIfdCount);\r\n\r\n\t\t\t\t// Process the IFD\r\n\t\t\t\tnRet = DecodeExifIfd(strTmp,nPosExifStart,nOffsetIfd1);\r\n\r\n\t\t\t\t// Now that we have gone through all entries in the IFD directory,\r\n\t\t\t\t// we read the offset to the next IFD\r\n\t\t\t\tnOffsetIfd1 = ByteSwap4(Buf(m_nPos+0),Buf(m_nPos+1),Buf(m_nPos+2),Buf(m_nPos+3));\r\n\t\t\t\tm_nPos += 4;\r\n\r\n\r\n\t\t\t\tstrTmp.Format(_T(\"    Offset to Next IFD = 0x%08X\"),nOffsetIfd1);\r\n\t\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\r\n\t\t\t\tif (nRet != 0) {\r\n\t\t\t\t\t// Error condition (DecodeExifIfd returned error)\r\n\t\t\t\t\tnOffsetIfd1 = 0x00000000;\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\tif (nOffsetIfd1 == 0x00000000) {\r\n\t\t\t\t\t// Either error condition or truly end of IFDs\r\n\t\t\t\t\texif_done = TRUE;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tnIfdCount++;\r\n\t\t\t\t}\r\n\r\n\t\t\t} // while ! exif_done\r\n\r\n\t\t\t// If EXIF SubIFD was defined, then handle it now\r\n\t\t\tif (m_nImgExifSubIfdPtr != 0)\r\n\t\t\t{\r\n\t\t\t\tm_pLog->AddLine(_T(\"\"));\r\n\t\t\t\tDecodeExifIfd(_T(\"SubIFD\"),nPosExifStart,m_nImgExifSubIfdPtr);\r\n\t\t\t}\r\n\t\t\tif (m_nImgExifMakerPtr != 0)\r\n\t\t\t{\r\n\t\t\t\tm_pLog->AddLine(_T(\"\"));\r\n\t\t\t\tDecodeExifIfd(_T(\"MakerIFD\"),nPosExifStart,m_nImgExifMakerPtr);\r\n\t\t\t}\r\n\t\t\tif (m_nImgExifGpsIfdPtr != 0)\r\n\t\t\t{\r\n\t\t\t\tm_pLog->AddLine(_T(\"\"));\r\n\t\t\t\tDecodeExifIfd(_T(\"GPSIFD\"),nPosExifStart,m_nImgExifGpsIfdPtr);\r\n\t\t\t}\r\n\t\t\tif (m_nImgExifInteropIfdPtr != 0)\r\n\t\t\t{\r\n\t\t\t\tm_pLog->AddLine(_T(\"\"));\r\n\t\t\t\tDecodeExifIfd(_T(\"InteropIFD\"),nPosExifStart,m_nImgExifInteropIfdPtr);\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\t\t\tstrTmp.Format(_T(\"Identifier [%s] not supported. Skipping remainder.\"),(LPCTSTR)acIdentifier);\r\n\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t}\r\n\r\n\t\t//////////\r\n\r\n\r\n\t\t// Dump out Makernote area\r\n\r\n\t\t// TODO: Disabled for now\r\n#if 0\r\n\t\tunsigned ptr_base;\r\n\r\n\t\tif (m_bVerbose)\r\n\t\t{\r\n\t\t\tif (m_nImgExifMakerPtr != 0)\r\n\t\t\t{\r\n\t\t\t\t// FIXME: Seems that nPosExifStart is not initialized in VERBOSE mode\r\n\t\t\t\tptr_base = nPosExifStart+m_nImgExifMakerPtr;\r\n\r\n\t\t\t\tm_pLog->AddLine(_T(\"Exif Maker IFD DUMP\"));\r\n\t\t\t\tstrFull.Format(_T(\"  MarkerOffset @ 0x%08X\"),ptr_base);\r\n\t\t\t\tm_pLog->AddLine(strFull);\r\n\t\t\t}\r\n\t\t}\r\n#endif\r\n\r\n\t\t// End of dump out makernote area\r\n\r\n\r\n\r\n\t\t// Restore file position\r\n\t\tm_nPos = nPosSaved;\r\n\r\n\r\n\t\t// Restore original position in file to a point\r\n\t\t// after the section\r\n\t\tm_nPos = nPosSaved+nLength;\r\n\r\n\t\tbreak;\r\n\r\n\tcase JFIF_APP2:\r\n\t\t// Typically used for Flashpix and possibly ICC profiles\r\n\t\t// Photoshop (Save As)\r\n\t\tnLength = Buf(m_nPos)*256 + Buf(m_nPos+1);\r\n\t\t//nLength = m_pWBuf->BufX(m_nPos,2,!m_nImgExifEndian);\r\n\t\tstrTmp.Format(_T(\"  Length          = %u\"),nLength);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tnPosSaved = m_nPos;\r\n\r\n\t\tm_nPos += 2; // Move past length now that we've used it\r\n\r\n\r\n\t\t_tcscpy_s(acIdentifier,MAX_IDENTIFIER,m_pWBuf->BufReadStrn(m_nPos,MAX_IDENTIFIER-1));\r\n\t\tacIdentifier[MAX_IDENTIFIER-1] = 0; // Null terminate just in case\r\n\t\tstrTmp.Format(_T(\"  Identifier      = [%s]\"),acIdentifier);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\t\tm_nPos += (unsigned)_tcslen(acIdentifier)+1;\r\n\t\tif (_tcscmp(acIdentifier,_T(\"FPXR\")) == 0) {\r\n\t\t\t// Photoshop\r\n\t\t\tm_pLog->AddLine(_T(\"    FlashPix:\"));\r\n\t\t\tDecodeApp2Flashpix();\r\n\t\t} else if (_tcscmp(acIdentifier,_T(\"ICC_PROFILE\")) == 0) {\r\n\t\t\t// ICC Profile\r\n\t\t\tm_pLog->AddLine(_T(\"    ICC Profile:\"));\r\n\t\t\tDecodeApp2IccProfile(nLength);\r\n\t\t} else {\r\n\t\t\tm_pLog->AddLine(_T(\"    Not supported. Skipping remainder.\"));\r\n\t\t}\r\n\t\t// Restore original position in file to a point\r\n\t\t// after the section\r\n\t\tm_nPos = nPosSaved+nLength;\r\n\t\tbreak;\r\n\r\n\r\n\tcase JFIF_APP3:\r\n\tcase JFIF_APP4:\r\n\tcase JFIF_APP5:\r\n\tcase JFIF_APP6:\r\n\tcase JFIF_APP7:\r\n\tcase JFIF_APP8:\r\n\tcase JFIF_APP9:\r\n\tcase JFIF_APP10:\r\n\tcase JFIF_APP11:\r\n\t\t//case JFIF_APP12: // Handled separately\r\n\t\t//case JFIF_APP13: // Handled separately\r\n\t\t//case JFIF_APP14: // Handled separately\r\n\tcase JFIF_APP15:\r\n\t\tnLength = Buf(m_nPos)*256 + Buf(m_nPos+1);\r\n\t\t//nLength = m_pWBuf->BufX(m_nPos,2,!m_nImgExifEndian);\r\n\t\tstrTmp.Format(_T(\"  Length     = %u\"),nLength);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tif (m_bVerbose)\r\n\t\t{\r\n\r\n\t\t\tstrFull = _T(\"\");\r\n\t\t\tfor (unsigned int i=0;i<nLength;i++)\r\n\t\t\t{\r\n\t\t\t\t// Start a new line for every 16 codes\r\n\t\t\t\tif ((i % 16) == 0) {\r\n\t\t\t\t\tstrFull.Format(_T(\"  MarkerOffset [%04X]: \"),i);\r\n\t\t\t\t} else if ((i % 8) == 0) {\r\n\t\t\t\t\tstrFull += _T(\"  \");\r\n\t\t\t\t}\r\n\t\t\t\tnTmpVal = Buf(m_nPos+i);\r\n\t\t\t\tstrTmp.Format(_T(\"%02X \"),nTmpVal);\r\n\t\t\t\tstrFull += strTmp;\r\n\t\t\t\tif ((i%16) == 15) {\r\n\t\t\t\t\tm_pLog->AddLine(strFull);\r\n\t\t\t\t\tstrFull = _T(\"\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tm_pLog->AddLine(strFull);\r\n\r\n\t\t\tstrFull = _T(\"\");\r\n\t\t\tfor (unsigned int i=0;i<nLength;i++)\r\n\t\t\t{\r\n\t\t\t\t// Start a new line for every 16 codes\r\n\t\t\t\tif ((i % 32) == 0) {\r\n\t\t\t\t\tstrFull.Format(_T(\"  MarkerOffset [%04X]: \"),i);\r\n\t\t\t\t} else if ((i % 8) == 0) {\r\n\t\t\t\t\tstrFull += _T(\" \");\r\n\t\t\t\t}\r\n\t\t\t\tnTmpVal = Buf(m_nPos+i);\r\n\t\t\t\tif (_istprint(nTmpVal)) {\r\n\t\t\t\t\tstrTmp.Format(_T(\"%c\"),nTmpVal);\r\n\t\t\t\t\tstrFull += strTmp;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstrFull += _T(\".\");\r\n\t\t\t\t}\r\n\t\t\t\tif ((i%32)==31) {\r\n\t\t\t\t\tm_pLog->AddLine(strFull);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tm_pLog->AddLine(strFull);\r\n\r\n\t\t} // nVerbose\r\n\r\n\t\tm_nPos += nLength;\r\n\t\tbreak;\r\n\r\n\tcase JFIF_APP0: // APP0\r\n\r\n\t\tnLength = Buf(m_nPos)*256 + Buf(m_nPos+1);\r\n\t\t//nLength = m_pWBuf->BufX(m_nPos,2,!m_nImgExifEndian);\r\n\t\tm_nPos+=2;\r\n\t\tstrTmp.Format(_T(\"  Length     = %u\"),nLength);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t_tcscpy_s(m_acApp0Identifier,MAX_IDENTIFIER,m_pWBuf->BufReadStrn(m_nPos,MAX_IDENTIFIER-1));\r\n\t\tm_acApp0Identifier[MAX_IDENTIFIER-1] = 0; // Null terminate just in case\r\n\t\tstrTmp.Format(_T(\"  Identifier = [%s]\"),m_acApp0Identifier);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tif (!_tcscmp(m_acApp0Identifier,_T(\"JFIF\")))\r\n\t\t{\r\n\t\t\t// Only process remainder if it is JFIF. This marker\r\n\t\t\t// is also used for application-specific functions.\r\n\r\n\t\t\tm_nPos += (unsigned)(_tcslen(m_acApp0Identifier)+1);\r\n\r\n\t\t\tm_nImgVersionMajor = Buf(m_nPos++);\r\n\t\t\tm_nImgVersionMinor = Buf(m_nPos++);\r\n\t\t\tstrTmp.Format(_T(\"  version    = [%u.%u]\"),m_nImgVersionMajor,m_nImgVersionMinor);\r\n\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t\tm_nImgUnits = Buf(m_nPos++);\r\n\r\n\t\t\tm_nImgDensityX = Buf(m_nPos)*256 + Buf(m_nPos+1);\r\n\t\t\t//m_nImgDensityX = m_pWBuf->BufX(m_nPos,2,!m_nImgExifEndian);\r\n\t\t\tm_nPos+=2;\r\n\t\t\tm_nImgDensityY = Buf(m_nPos)*256 + Buf(m_nPos+1);\r\n\t\t\t//m_nImgDensityY = m_pWBuf->BufX(m_nPos,2,!m_nImgExifEndian);\r\n\t\t\tm_nPos+=2;\r\n\t\t\tstrTmp.Format(_T(\"  density    = %u x %u \"),m_nImgDensityX,m_nImgDensityY);\r\n\t\t\tstrFull = strTmp;\r\n\r\n\t\t\tswitch (m_nImgUnits)\r\n\t\t\t{\r\n\t\t\tcase 0:\r\n\t\t\t\tstrFull += _T(\"(aspect ratio)\");\r\n\t\t\t\tm_pLog->AddLine(strFull);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 1:\r\n\t\t\t\tstrFull += _T(\"DPI (dots per inch)\");\r\n\t\t\t\tm_pLog->AddLine(strFull);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2:\r\n\t\t\t\tstrFull += _T(\"DPcm (dots per cm)\");\r\n\t\t\t\tm_pLog->AddLine(strFull);\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tstrTmp.Format(_T(\"ERROR: Unknown ImgUnits parameter [%u]\"),m_nImgUnits);\r\n\t\t\t\tstrFull += strTmp;\r\n\t\t\t\tm_pLog->AddLineWarn(strFull);\r\n\t\t\t\t//return DECMARK_ERR;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\r\n\t\t\tm_nImgThumbSizeX = Buf(m_nPos++);\r\n\t\t\tm_nImgThumbSizeY = Buf(m_nPos++);\r\n\t\t\tstrTmp.Format(_T(\"  thumbnail  = %u x %u\"),m_nImgThumbSizeX,m_nImgThumbSizeY);\r\n\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t\t// Unpack the thumbnail:\r\n\t\t\tunsigned thumbnail_r,thumbnail_g,thumbnail_b;\r\n\t\t\tif (m_nImgThumbSizeX && m_nImgThumbSizeY) {\r\n\t\t\t\tfor (unsigned y=0;y<m_nImgThumbSizeY;y++) {\r\n\t\t\t\t\tstrFull.Format(_T(\"   Thumb[%03u] = \"),y);\r\n\t\t\t\t\tfor (unsigned x=0;x<m_nImgThumbSizeX;x++) {\r\n\t\t\t\t\t\tthumbnail_r = Buf(m_nPos++);\r\n\t\t\t\t\t\tthumbnail_g = Buf(m_nPos++);\r\n\t\t\t\t\t\tthumbnail_b = Buf(m_nPos++);\r\n\t\t\t\t\t\tstrTmp.Format(_T(\"(0x%02X,0x%02X,0x%02X) \"),thumbnail_r,thumbnail_g,thumbnail_b);\r\n\t\t\t\t\t\tstrFull += strTmp;\r\n\t\t\t\t\t\tm_pLog->AddLine(strFull);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// TODO:\r\n\t\t\t// - In JPEG-B mode (GeoRaster), we will need to fake out\r\n\t\t\t//   the DHT & DQT tables here. Unfortunately, we'll have to\r\n\t\t\t//   rely on the user to put us into this mode as there is nothing\r\n\t\t\t//   in the file that specifies this mode.\r\n\r\n\t\t\t/*\r\n\t\t\t// TODO: Need to ensure that Faked DHT is correct table\r\n\r\n\t\t\tAddHeader(JFIF_DHT_FAKE);\r\n\t\t\tDecodeDHT(true);\r\n\t\t\t// Need to mark DHT tables as OK\r\n\t\t\tm_bStateDht = true;\r\n\t\t\tm_bStateDhtFake = true;\r\n\t\t\tm_bStateDhtOk = true;\r\n\r\n\t\t\t// ... same for DQT\r\n\t\t\t*/\r\n\r\n\r\n\r\n\t\t} else if (!_tcsnccmp(m_acApp0Identifier,_T(\"AVI1\"),4))\r\n\t\t{\r\n\t\t\t// AVI MJPEG type\r\n\r\n\t\t\t// Need to fill in predefined DHT table from spec:\r\n\t\t\t//   OpenDML file format for AVI, section \"Proposed Data Chunk Format\"\r\n\t\t\t//   Described in MMREG.H\r\n\t\t\tm_pLog->AddLine(_T(\"  Detected MotionJPEG\"));\r\n\t\t\tm_pLog->AddLine(_T(\"  Importing standard Huffman table...\"));\r\n\t\t\tm_pLog->AddLine(_T(\"\"));\r\n\r\n\t\t\tAddHeader(JFIF_DHT_FAKE);\r\n\r\n\t\t\tDecodeDHT(true);\r\n\t\t\t// Need to mark DHT tables as OK\r\n\t\t\tm_bStateDht = true;\r\n\t\t\tm_bStateDhtFake = true;\r\n\t\t\tm_bStateDhtOk = true;\r\n\r\n\t\t\tm_nPos += nLength-2; // Skip over, and undo length short read\r\n\r\n\r\n\t\t} else {\r\n\t\t\t// Not JFIF or AVI1\r\n\t\t\tm_pLog->AddLine(_T(\"    Not known APP0 type. Skipping remainder.\"));\r\n\t\t\tm_nPos += nLength-2;\r\n\t\t}\r\n\r\n\t\tif (!ExpectMarkerEnd(nPosMarkerStart,nLength))\r\n\t\t\treturn DECMARK_ERR;\r\n\r\n\t\tbreak;\r\n\r\n\tcase JFIF_DQT:  // Define quantization tables\r\n\t\tm_bStateDqt = true;\r\n\t\tunsigned nDqtPrecision_Pq;\r\n\t\tunsigned nDqtQuantDestId_Tq;\r\n\t\tnLength = Buf(m_nPos)*256 + Buf(m_nPos+1);\t// Lq\r\n\t\tnPosEnd = m_nPos+nLength;\r\n\t\tm_nPos+=2;\r\n//XXX\t\tstrTmp.Format(_T(\"  Table length <Lq> = %u\"),nLength); \r\n\t\tstrTmp.Format(_T(\"  Table length = %u\"),nLength); \r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\twhile (nPosEnd > m_nPos)\r\n\t\t{\r\n\t\t\tstrTmp.Format(_T(\"  ----\"));\r\n\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t\tnTmpVal = Buf(m_nPos++);\t\t\t\t\t// Pq | Tq\r\n\t\t\tnDqtPrecision_Pq = (nTmpVal & 0xF0) >> 4;\t// Pq, range 0-1\r\n\t\t\tnDqtQuantDestId_Tq = nTmpVal & 0x0F;\t\t// Tq, range 0-3\r\n\r\n\t\t\t// Decode per ITU-T.81 standard\r\n#if 1\r\n\r\n\t\t\tif (nDqtPrecision_Pq == 0) {\r\n\t\t\t\tstrDqtPrecision = _T(\"8 bits\");\r\n\t\t\t} else if (nDqtPrecision_Pq == 1) {\r\n\t\t\t\tstrDqtPrecision = _T(\"16 bits\");\r\n\t\t\t} else {\r\n\t\t\t\tstrTmp.Format(_T(\"    Unsupported precision value [%u]\"),nDqtPrecision_Pq);\r\n\t\t\t\tm_pLog->AddLineWarn(strTmp);\r\n\t\t\t\tstrDqtPrecision = _T(\"???\");\r\n\t\t\t\t// FIXME: Consider terminating marker parsing early\r\n\t\t\t}\r\n\r\n\t\t\tif (!ValidateValue(nDqtPrecision_Pq,0,1,_T(\"DQT Precision <Pq>\"),true,0)) return DECMARK_ERR;\r\n\t\t\tif (!ValidateValue(nDqtQuantDestId_Tq,0,3,_T(\"DQT Destination ID <Tq>\"),true,0)) return DECMARK_ERR;\r\n\r\n\t\t\tstrTmp.Format(_T(\"  Precision=%s\"),(LPCTSTR)strDqtPrecision);\r\n\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n#else\r\n\t\t\t// Decode with additional DQT extension (ITU-T-JPEG-Plus-Proposal_R3.doc)\r\n\r\n\t\t\tif ((nDqtPrecision_Pq & 0xE) == 0) {\r\n\t\t\t\t// Per ITU-T.81 Standard\r\n\t\t\t\tif (nDqtPrecision_Pq == 0) {\r\n\t\t\t\t\tstrDqtPrecision = _T(\"8 bits\");\r\n\t\t\t\t} else if (nDqtPrecision_Pq == 1) {\r\n\t\t\t\t\tstrDqtPrecision = _T(\"16 bits\");\r\n\t\t\t\t}\r\n\t\t\t\tstrTmp.Format(_T(\"  Precision=%s\"),strDqtPrecision);\r\n\t\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t\t} else {\r\n\t\t\t\t// Non-standard\r\n\t\t\t\t// JPEG-Plus-Proposal-R3:\r\n\t\t\t\t// - Alternative sub-block-wise sequence\r\n\t\t\t\tstrTmp.Format(_T(\"  Non-Standard DQT Extension detected\"));\r\n\t\t\t\tm_pLog->AddLineWarn(strTmp);\r\n\r\n\t\t\t\t// FIXME: Should prevent attempt to decode until this is implemented\r\n\r\n\t\t\t\tif (nDqtPrecision_Pq == 0) {\r\n\t\t\t\t\tstrDqtPrecision = _T(\"8 bits\");\r\n\t\t\t\t} else if (nDqtPrecision_Pq == 1) {\r\n\t\t\t\t\tstrDqtPrecision = _T(\"16 bits\");\r\n\t\t\t\t}\r\n\t\t\t\tstrTmp.Format(_T(\"  Precision=%s\"),strDqtPrecision);\r\n\t\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t\t\tif ((nDqtPrecision_Pq & 0x2) == 0) {\r\n\t\t\t\t\tstrDqtZigZagOrder = _T(\"Diagonal zig-zag coeff scan seqeunce\");\r\n\t\t\t\t} else if ((nDqtPrecision_Pq & 0x2) == 1) {\r\n\t\t\t\t\tstrDqtZigZagOrder = _T(\"Alternate coeff scan seqeunce\");\r\n\t\t\t\t}\r\n\t\t\t\tstrTmp.Format(_T(\"  Coeff Scan Sequence=%s\"),strDqtZigZagOrder);\r\n\t\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t\t\tif ((nDqtPrecision_Pq & 0x4) == 1) {\r\n\t\t\t\t\tstrTmp.Format(_T(\"  Custom coeff scan sequence\"));\r\n\t\t\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t\t\t\t// Now expect sequence of 64 coefficient entries\r\n\t\t\t\t\tCString strSequence = _T(\"\");\r\n\t\t\t\t\tfor (unsigned nInd=0;nInd<64;nInd++) {\r\n\t\t\t\t\t\tnTmpVal = Buf(m_nPos++);\r\n\t\t\t\t\t\tstrTmp.Format(_T(\"%u\"),nTmpVal);\r\n\t\t\t\t\t\tstrSequence += strTmp;\r\n\t\t\t\t\t\tif (nInd!=63) {\r\n\t\t\t\t\t\t\tstrSequence += _T(\", \");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tstrTmp.Format(_T(\"  Custom sequence = [ %s ]\"),strSequence);\r\n\t\t\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t\t\t}\r\n\t\t\t}\r\n#endif\r\n\r\n\t\t\tstrTmp.Format(_T(\"  Destination ID=%u\"),nDqtQuantDestId_Tq);\r\n\t\t\tif (nDqtQuantDestId_Tq == 0) {\r\n\t\t\t\tstrTmp += _T(\" (Luminance)\");\r\n\t\t\t}\r\n\t\t\telse if (nDqtQuantDestId_Tq == 1) {\r\n\t\t\t\tstrTmp += _T(\" (Chrominance)\");\r\n\t\t\t}\r\n\t\t\telse if (nDqtQuantDestId_Tq == 2) {\r\n\t\t\t\tstrTmp += _T(\" (Chrominance)\");\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tstrTmp += _T(\" (???)\");\r\n\t\t\t}\r\n\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\r\n\t\t\t// FIXME: The following is somewhat superseded by ValidateValue() above\r\n\t\t\t// with the exception of skipping remainder\r\n\t\t\tif (nDqtQuantDestId_Tq >= MAX_DQT_DEST_ID) {\r\n\t\t\t\tstrTmp.Format(_T(\"ERROR: Destination ID <Tq> = %u, >= %u\"),nDqtQuantDestId_Tq,MAX_DQT_DEST_ID);\r\n\t\t\t\tm_pLog->AddLineErr(strTmp);\r\n\t\t\t\tif (!m_pAppConfig->bRelaxedParsing) {\r\n\t\t\t\t\tm_pLog->AddLineErr(_T(\"  Stopping decode\"));\r\n\t\t\t\t\treturn DECMARK_ERR;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Now skip remainder of DQT\r\n\t\t\t\t\t// FIXME\r\n\t\t\t\t\tstrTmp.Format(_T(\"  Skipping remainder of marker [%u bytes]\"),nPosMarkerStart + nLength - m_nPos);\r\n\t\t\t\t\tm_pLog->AddLineWarn(strTmp);\r\n\t\t\t\t\tm_pLog->AddLine(_T(\"\"));\r\n\t\t\t\t\tm_nPos = nPosMarkerStart + nLength;\r\n\t\t\t\t\treturn DECMARK_OK;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tbool\tbQuantAllOnes = true;\r\n\t\t\tdouble\tdComparePercent;\r\n\t\t\tdouble\tdSumPercent=0;\r\n\t\t\tdouble\tdSumPercentSqr=0;\r\n\r\n\r\n\t\t\tfor (unsigned nCoeffInd=0;nCoeffInd<MAX_DQT_COEFF;nCoeffInd++)\r\n\t\t\t{\r\n\t\t\t\tnTmpVal = Buf(m_nPos++);\r\n\t\t\t\tif (nDqtPrecision_Pq == 1) {\r\n\t\t\t\t\t// 16-bit DQT entries!\r\n\t\t\t\t\tnTmpVal <<= 8;\r\n\t\t\t\t\tnTmpVal += Buf(m_nPos++);\r\n\t\t\t\t}\r\n\t\t\t\tm_anImgDqtTbl[nDqtQuantDestId_Tq][glb_anZigZag[nCoeffInd]] = nTmpVal;\r\n\r\n\r\n\t\t\t\t/* scaling factor in percent */\r\n\r\n\t\t\t\t// Now calculate the comparison with the Annex sample\r\n\r\n\t\t\t\t// FIXME: Should probably use check for landscape orientation and\r\n\t\t\t\t//        rotate comparison matrix accordingly\r\n\r\n\t\t\t\tif (nDqtQuantDestId_Tq == 0) {\r\n\t\t\t\t\tif (m_anImgDqtTbl[nDqtQuantDestId_Tq][glb_anZigZag[nCoeffInd]] != 0) {\r\n\t\t\t\t\t\tm_afStdQuantLumCompare[glb_anZigZag[nCoeffInd]] =\r\n\t\t\t\t\t\t\t(float)(glb_anStdQuantLum[glb_anZigZag[nCoeffInd]]) /\r\n\t\t\t\t\t\t\t(float)(m_anImgDqtTbl[nDqtQuantDestId_Tq][glb_anZigZag[nCoeffInd]]);\r\n\t\t\t\t\t\tdComparePercent = 100.0 *\r\n\t\t\t\t\t\t\t(double)(m_anImgDqtTbl[nDqtQuantDestId_Tq][glb_anZigZag[nCoeffInd]]) /\r\n\t\t\t\t\t\t\t(double)(glb_anStdQuantLum[glb_anZigZag[nCoeffInd]]);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tm_afStdQuantLumCompare[glb_anZigZag[nCoeffInd]] = (float)999.99;\r\n\t\t\t\t\t\tdComparePercent = 999.99;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (m_anImgDqtTbl[nDqtQuantDestId_Tq][glb_anZigZag[nCoeffInd]] != 0) {\r\n\t\t\t\t\t\tm_afStdQuantChrCompare[glb_anZigZag[nCoeffInd]] =\r\n\t\t\t\t\t\t\t(float)(glb_anStdQuantChr[glb_anZigZag[nCoeffInd]]) /\r\n\t\t\t\t\t\t\t(float)(m_anImgDqtTbl[nDqtQuantDestId_Tq][glb_anZigZag[nCoeffInd]]);\r\n\t\t\t\t\t\tdComparePercent = 100.0 *\r\n\t\t\t\t\t\t\t(double)(m_anImgDqtTbl[nDqtQuantDestId_Tq][glb_anZigZag[nCoeffInd]]) /\r\n\t\t\t\t\t\t\t(double)(glb_anStdQuantChr[glb_anZigZag[nCoeffInd]]);\r\n\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tm_afStdQuantChrCompare[glb_anZigZag[nCoeffInd]] = (float)999.99;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdSumPercent += dComparePercent;\r\n\t\t\t\tdSumPercentSqr += dComparePercent * dComparePercent;\r\n\r\n\t\t\t\t// Check just in case entire table are ones (Quality 100)\r\n\t\t\t\tif (m_anImgDqtTbl[nDqtQuantDestId_Tq][glb_anZigZag[nCoeffInd]] != 1) bQuantAllOnes = 0;\r\n\r\n\r\n\t\t\t} // 0..63\r\n\r\n\t\t\t// Note that the DQT table that we are saving is already\r\n\t\t\t// after doing zigzag reordering:\r\n\t\t\t// From high freq -> low freq\r\n\t\t\t// To X,Y, left-to-right, top-to-bottom\r\n\r\n\t\t\t// Flag this DQT table as being set!\r\n\t\t\tm_abImgDqtSet[nDqtQuantDestId_Tq] = true;\r\n\r\n\t\t\tunsigned nCoeffInd;\r\n\r\n\t\t\t// Now display the table\r\n\t\t\tfor (unsigned nDqtY=0;nDqtY<8;nDqtY++) {\r\n\t\t\t\tstrFull.Format(_T(\"    DQT, Row #%u: \"),nDqtY);\r\n\t\t\t\tfor (unsigned nDqtX=0;nDqtX<8;nDqtX++) {\r\n\t\t\t\t\tnCoeffInd = nDqtY*8+nDqtX;\r\n\t\t\t\t\tstrTmp.Format(_T(\"%3u \"),m_anImgDqtTbl[nDqtQuantDestId_Tq][nCoeffInd]);\r\n\t\t\t\t\tstrFull += strTmp;\r\n\r\n\t\t\t\t\t// Store the DQT entry into the Image Decoder\r\n\t\t\t\t\tbRet = m_pImgDec->SetDqtEntry(nDqtQuantDestId_Tq,nCoeffInd,glb_anUnZigZag[nCoeffInd],\r\n\t\t\t\t\t\tm_anImgDqtTbl[nDqtQuantDestId_Tq][nCoeffInd]);\r\n\t\t\t\t\tDecodeErrCheck(bRet);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Now add the compare with Annex K\r\n\t\t\t\t// Decided to disable this as it was confusing users\r\n\t\t\t\t/*\r\n\t\t\t\tstrFull += _T(\"   AnnexRatio: <\");\r\n\t\t\t\tfor (unsigned nDqtX=0;nDqtX<8;nDqtX++) {\r\n\t\t\t\t\tnCoeffInd = nDqtY*8+nDqtX;\r\n\t\t\t\t\tif (nDqtQuantDestId_Tq == 0) {\r\n\t\t\t\t\t\tstrTmp.Format(_T(\"%5.1f \"),m_afStdQuantLumCompare[nCoeffInd]);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tstrTmp.Format(_T(\"%5.1f \"),m_afStdQuantChrCompare[nCoeffInd]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tstrFull += strTmp;\r\n\t\t\t\t}\r\n\t\t\t\tstrFull += _T(\">\");\r\n\t\t\t\t*/\r\n\r\n\t\t\t\tm_pLog->AddLine(strFull);\r\n\r\n\t\t\t}\r\n\r\n\r\n\r\n\t\t\t// Perform some statistical analysis of the quality factor\r\n\t\t\t// to determine the likelihood of the current quantization\r\n\t\t\t// table being a scaled version of the \"standard\" tables.\r\n\t\t\t// If the variance is high, it is unlikely to be the case.\r\n\t\t\tdouble\tdQuality;\r\n\t\t\tdouble\tdVariance;\r\n\t\t\tdSumPercent /= 64.0;\t/* mean scale factor */\r\n\t\t\tdSumPercentSqr /= 64.0;\r\n\t\t\tdVariance = dSumPercentSqr - (dSumPercent * dSumPercent); /* variance */\r\n\r\n\t\t\t// Generate the equivalent IJQ \"quality\" factor\r\n\t\t\tif (bQuantAllOnes)\t\t/* special case for all-ones table */\r\n\t\t\t\tdQuality = 100.0;\r\n\t\t\telse if (dSumPercent <= 100.0)\r\n\t\t\t\tdQuality = (200.0 - dSumPercent) / 2.0;\r\n\t\t\telse\r\n\t\t\t\tdQuality = 5000.0 / dSumPercent;\r\n\r\n\t\t\t// Save the quality rating for later\r\n\t\t\tm_adImgDqtQual[nDqtQuantDestId_Tq] = dQuality;\r\n\r\n\t\t\tstrTmp.Format(_T(\"    Approx quality factor = %.2f (scaling=%.2f variance=%.2f)\"),\r\n\t\t\t\tdQuality,dSumPercent,dVariance);\r\n\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\r\n\t\t}\r\n\t\tm_bStateDqtOk = true;\r\n\r\n\t\tif (!ExpectMarkerEnd(nPosMarkerStart,nLength))\r\n\t\t\treturn DECMARK_ERR;\r\n\r\n\t\tbreak;\r\n\r\n\tcase JFIF_DAC: // DAC (Arithmetic Coding)\r\n\t\tnLength = Buf(m_nPos)*256 + Buf(m_nPos+1);\t// La\r\n\t\tm_nPos+=2;\r\n//XXX\t\tstrTmp.Format(_T(\"  Arithmetic coding header length <La> = %u\"),nLength);\r\n\t\tstrTmp.Format(_T(\"  Arithmetic coding header length = %u\"),nLength);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\t\tunsigned\tnDAC_n;\r\n\t\tunsigned\tnDAC_Tc,nDAC_Tb;\r\n\t\tunsigned\tnDAC_Cs;\r\n\t\tnDAC_n = (nLength>2)?(nLength-2)/2:0;\r\n\t\tfor (unsigned nInd=0;nInd<nDAC_n;nInd++) {\r\n\t\t\tnTmpVal = Buf(m_nPos++);\t// Tc,Tb\r\n\t\t\tnDAC_Tc = (nTmpVal & 0xF0) >> 4;\r\n\t\t\tnDAC_Tb = (nTmpVal & 0x0F);\r\n//XXX\t\t\tstrTmp.Format(_T(\"  #%02u: Table class <Tc>                  = %u\"),nInd+1,nDAC_Tc);\r\n\t\t\tstrTmp.Format(_T(\"  #%02u: Table class                  = %u\"),nInd+1,nDAC_Tc);\r\n\t\t\tm_pLog->AddLine(strTmp);\r\n//XXX\t\t\tstrTmp.Format(_T(\"  #%02u: Table destination identifier <Tb> = %u\"),nInd+1,nDAC_Tb);\r\n\t\t\tstrTmp.Format(_T(\"  #%02u: Table destination identifier = %u\"),nInd+1,nDAC_Tb);\r\n\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t\tnDAC_Cs = Buf(m_nPos++);\t// Cs\r\n//XXX\t\t\tstrTmp.Format(_T(\"  #%02u: Conditioning table value <Cs>     = %u\"),nInd+1,nDAC_Cs);\r\n\t\t\tstrTmp.Format(_T(\"  #%02u: Conditioning table value     = %u\"),nInd+1,nDAC_Cs);\r\n\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t\tif (!ValidateValue(nDAC_Tc,0,1,_T(\"Table class <Tc>\"),true,0)) return DECMARK_ERR;\r\n\t\t\tif (!ValidateValue(nDAC_Tb,0,3,_T(\"Table destination ID <Tb>\"),true,0)) return DECMARK_ERR;\r\n\r\n\t\t\t// Parameter range constraints per Table B.6:\r\n\t\t\t// ------------|-------------------------|-------------------|------------\r\n\t\t\t//             |     Sequential DCT      |  Progressive DCT  | Lossless\r\n\t\t\t//   Parameter |  Baseline    Extended   |                   |\r\n\t\t\t// ------------|-----------|-------------|-------------------|------------\r\n\t\t\t//     Cs      |   Undef   | Tc=0: 0-255 | Tc=0: 0-255       | 0-255\r\n\t\t\t//             |           | Tc=1: 1-63  | Tc=1: 1-63        |\r\n\t\t\t// ------------|-----------|-------------|-------------------|------------\r\n\r\n\t\t\t// However, to keep it simple (and not depend on lossless mode),\r\n\t\t\t// we will only check the maximal range\r\n\t\t\tif (!ValidateValue(nDAC_Cs,0,255,_T(\"Conditioning table value <Cs>\"),true,0)) return DECMARK_ERR;\r\n\t\t}\r\n\t\tif (!ExpectMarkerEnd(nPosMarkerStart,nLength))\r\n\t\t\treturn DECMARK_ERR;\r\n\r\n\t\tbreak;\r\n\r\n\tcase JFIF_DNL: // DNL (Define number of lines)\r\n\t\tnLength = Buf(m_nPos)*256 + Buf(m_nPos+1);\t// Ld\r\n\t\tm_nPos+=2;\r\n//XXX\t\tstrTmp.Format(_T(\"  Header length <Ld> = %u\"),nLength);\r\n\t\tstrTmp.Format(_T(\"  Header length = %u\"),nLength);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tnTmpVal = Buf(m_nPos)*256 + Buf(m_nPos+1);\t// NL\r\n\t\tm_nPos+=2;\r\n//XXX\t\tstrTmp.Format(_T(\"  Number of lines <NL> = %u\"),nTmpVal);\r\n\t\tstrTmp.Format(_T(\"  Number of lines = %u\"),nTmpVal);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tif (!ValidateValue(nTmpVal,1,65535,_T(\"Number of lines <NL>\"),true,1)) return DECMARK_ERR;\r\n\r\n\t\tif (!ExpectMarkerEnd(nPosMarkerStart,nLength))\r\n\t\t\treturn DECMARK_ERR;\r\n\t\tbreak;\r\n\r\n\tcase JFIF_EXP: \r\n\t\tnLength = Buf(m_nPos)*256 + Buf(m_nPos+1);\t// Le\r\n\t\tm_nPos+=2;\r\n//XXX\t\tstrTmp.Format(_T(\"  Header length <Le> = %u\"),nLength);\r\n\t\tstrTmp.Format(_T(\"  Header length = %u\"),nLength);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tunsigned\tnEXP_Eh,nEXP_Ev;\r\n\t\tnTmpVal = Buf(m_nPos)*256 + Buf(m_nPos+1);\t// Eh,Ev\r\n\t\tnEXP_Eh = (nTmpVal & 0xF0) >> 4;\r\n\t\tnEXP_Ev = (nTmpVal & 0x0F);\r\n\t\tm_nPos+=2;\r\n//XXX\t\tstrTmp.Format(_T(\"  Expand horizontally <Eh> = %u\"),nEXP_Eh);\r\n\t\tstrTmp.Format(_T(\"  Expand horizontally = %u\"),nEXP_Eh);\r\n\t\tm_pLog->AddLine(strTmp);\r\n//XXX\t\tstrTmp.Format(_T(\"  Expand vertically <Ev>   = %u\"),nEXP_Ev);\r\n\t\tstrTmp.Format(_T(\"  Expand vertically   = %u\"),nEXP_Ev);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\t\t\r\n\t\tif (!ValidateValue(nEXP_Eh,0,1,_T(\"Expand horizontally <Eh>\"),true,0)) return DECMARK_ERR;\r\n\t\tif (!ValidateValue(nEXP_Ev,0,1,_T(\"Expand vertically <Ev>\"),true,0)) return DECMARK_ERR;\r\n\r\n\t\tif (!ExpectMarkerEnd(nPosMarkerStart,nLength))\r\n\t\t\treturn DECMARK_ERR;\r\n\t\tbreak;\r\n\r\n\r\n\tcase JFIF_SOF0: // SOF0 (Baseline DCT)\r\n\tcase JFIF_SOF1: // SOF1 (Extended sequential)\r\n\tcase JFIF_SOF2: // SOF2 (Progressive)\r\n\tcase JFIF_SOF3:\r\n\tcase JFIF_SOF5:\r\n\tcase JFIF_SOF6:\r\n\tcase JFIF_SOF7:\r\n\tcase JFIF_SOF9:\r\n\tcase JFIF_SOF10:\r\n\tcase JFIF_SOF11:\r\n\tcase JFIF_SOF13:\r\n\tcase JFIF_SOF14:\r\n\tcase JFIF_SOF15:\r\n\r\n\t\t// TODO:\r\n\t\t// - JFIF_DHP should be able to reuse the JFIF_SOF marker parsing\r\n\t\t//   however as we don't support hierarchical image decode, we\r\n\t\t//   would want to skip the update of class members.\r\n\r\n\t\tm_bStateSof = true;\r\n\r\n\t\t// Determine if this is a SOF mode that we support\r\n\t\t// At this time, we only support Baseline DCT & Extended Sequential Baseline DCT\r\n\t\t// (non-differential) with Huffman coding. Progressive, Lossless,\r\n\t\t// Differential and Arithmetic coded modes are not supported.\r\n\t\tm_bImgSofUnsupported = true;\r\n\t\tif (nCode == JFIF_SOF0) { m_bImgSofUnsupported = false; }\r\n\t\tif (nCode == JFIF_SOF1) { m_bImgSofUnsupported = false; }\r\n\r\n\t\t// For reference, note progressive scan files even though\r\n\t\t// we don't currently support their decode\r\n\t\tif (nCode == JFIF_SOF2) { m_bImgProgressive = true; }\r\n\r\n\r\n\t\tnLength = Buf(m_nPos)*256 + Buf(m_nPos+1);\t// Lf\r\n\t\tm_nPos+=2;\r\n//XXX\t\tstrTmp.Format(_T(\"  Frame header length <Lf> = %u\"),nLength);\r\n\t\tstrTmp.Format(_T(\"  Frame header length = %u\"),nLength);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tm_nSofPrecision_P = Buf(m_nPos++);\t// P\r\n//XXX\t\tstrTmp.Format(_T(\"  Precision <P> = %u\"),m_nSofPrecision_P);\r\n\t\tstrTmp.Format(_T(\"  Precision = %u\"),m_nSofPrecision_P);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\t\tif (!ValidateValue(m_nSofPrecision_P,2,16,_T(\"Precision <P>\"),true,8)) return DECMARK_ERR;\r\n\r\n\t\tm_nSofNumLines_Y = Buf(m_nPos)*256 + Buf(m_nPos+1);\t// Y\r\n\t\tm_nPos += 2;\r\n//XXX\t\tstrTmp.Format(_T(\"  Number of Lines <Y> = %u\"),m_nSofNumLines_Y);\r\n\t\tstrTmp.Format(_T(\"  Number of Lines = %u\"),m_nSofNumLines_Y);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\t\tif (!ValidateValue(m_nSofNumLines_Y,0,65535,_T(\"Number of Lines <Y>\"),true,0)) return DECMARK_ERR;\r\n\r\n\t\tm_nSofSampsPerLine_X = Buf(m_nPos)*256 + Buf(m_nPos+1);\t// X\r\n\t\tm_nPos += 2; \r\n//XXX\t\tstrTmp.Format(_T(\"  Samples per Line <X> = %u\"),m_nSofSampsPerLine_X);\r\n\t\tstrTmp.Format(_T(\"  Samples per Line = %u\"),m_nSofSampsPerLine_X);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\t\tif (!ValidateValue(m_nSofSampsPerLine_X,1,65535,_T(\"Samples per Line <X>\"),true,1)) return DECMARK_ERR;\r\n\r\n\t\tstrTmp.Format(_T(\"  Image Size = %u x %u\"),m_nSofSampsPerLine_X,m_nSofNumLines_Y);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t// Determine orientation\r\n\t\t//   m_nSofSampsPerLine_X = X\r\n\t\t//   m_nSofNumLines_Y = Y\r\n\t\tm_eImgLandscape = ENUM_LANDSCAPE_YES;\r\n\t\tif (m_nSofNumLines_Y > m_nSofSampsPerLine_X)\r\n\t\t\tm_eImgLandscape = ENUM_LANDSCAPE_NO;\r\n\t\tstrTmp.Format(_T(\"  Raw Image Orientation = %s\"),(m_eImgLandscape==ENUM_LANDSCAPE_YES)?_T(\"Landscape\"):_T(\"Portrait\"));\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tm_nSofNumComps_Nf = Buf(m_nPos++);\t// Nf, range 1..255\r\n//XXX\t\tstrTmp.Format(_T(\"  Number of Img components <Nf> = %u\"),m_nSofNumComps_Nf);\r\n\t\tstrTmp.Format(_T(\"  Number of Img components = %u\"),m_nSofNumComps_Nf);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\t\tif (!ValidateValue(m_nSofNumComps_Nf,1,255,_T(\"Number of Img components <Nf>\"),true,1)) return DECMARK_ERR;\r\n\r\n\t\tunsigned nCompIdent;\r\n\t\tunsigned anSofSampFact[MAX_SOF_COMP_NF];\r\n\r\n\t\tm_nSofHorzSampFactMax_Hmax = 0;\r\n\t\tm_nSofVertSampFactMax_Vmax = 0;\r\n\r\n\t\t// Now clear the output image content (all components)\r\n\t\t// TODO: Migrate some of the bitmap allocation / clearing from\r\n\t\t// DecodeScanImg() into ResetImageContent() and call here\r\n\t\t//m_pImgDec->ResetImageContent();\r\n\r\n\t\t// Per JFIF v1.02:\r\n\t\t// - Nf = 1 or 3\r\n\t\t// - C1 = Y\r\n\t\t// - C2 = Cb\r\n\t\t// - C3 = Cr\r\n\r\n\t\tfor (unsigned nCompInd=1;((!m_bStateAbort)&&(nCompInd<=m_nSofNumComps_Nf));nCompInd++)\r\n\t\t{\r\n\t\t\tnCompIdent = Buf(m_nPos++);\t\t\t\t\t\t\t\t\t\t\t\t// Ci, range 0..255\r\n\t\t\tm_anSofQuantCompId[nCompInd] = nCompIdent;\r\n\t\t\t//if (!ValidateValue(m_anSofQuantCompId[nCompInd],0,255,_T(\"Component ID <Ci>\"),true,0)) return DECMARK_ERR;\r\n\r\n\t\t\tanSofSampFact[nCompIdent] = Buf(m_nPos++);\r\n\t\t\tm_anSofQuantTblSel_Tqi[nCompIdent] = Buf(m_nPos++);\t\t\t\t\t\t// Tqi, range 0..3\r\n\t\t\t//if (!ValidateValue(m_anSofQuantTblSel_Tqi[nCompIdent],0,3,_T(\"Table Destination ID <Tqi>\"),true,0)) return DECMARK_ERR;\r\n\r\n\t\t\t// NOTE: We protect against bad input here as replication ratios are\r\n\t\t\t// determined later that depend on dividing by sampling factor (hence\r\n\t\t\t// possibility of div by 0).\r\n\t\t\tm_anSofHorzSampFact_Hi[nCompIdent] = (anSofSampFact[nCompIdent] & 0xF0) >> 4;\t// Hi, range 1..4\r\n\t\t\tm_anSofVertSampFact_Vi[nCompIdent] = (anSofSampFact[nCompIdent] & 0x0F);\t\t// Vi, range 1..4\r\n\t\t\tif (!ValidateValue(m_anSofHorzSampFact_Hi[nCompIdent],1,4,_T(\"Horizontal Sampling Factor <Hi>\"),true,1)) return DECMARK_ERR;\r\n\t\t\tif (!ValidateValue(m_anSofVertSampFact_Vi[nCompIdent],1,4,_T(\"Vertical Sampling Factor <Vi>\"),true,1)) return DECMARK_ERR;\r\n\r\n\t\t}\r\n\r\n\t\t// Calculate max sampling factors\r\n\t\tfor (unsigned nCompInd=1;((!m_bStateAbort)&&(nCompInd<=m_nSofNumComps_Nf));nCompInd++)\r\n\t\t{\r\n\t\t\tnCompIdent = m_anSofQuantCompId[nCompInd];\r\n\t\t\t// Calculate maximum sampling factor for the SOF. This is only\r\n\t\t\t// used for later generation of m_strImgQuantCss an the SOF\r\n\t\t\t// reporting below. The CimgDecode block is responsible for\r\n\t\t\t// calculating the maximum sampling factor on a per-scan basis.\r\n\t\t\tm_nSofHorzSampFactMax_Hmax = max(m_nSofHorzSampFactMax_Hmax,m_anSofHorzSampFact_Hi[nCompIdent]);\r\n\t\t\tm_nSofVertSampFactMax_Vmax = max(m_nSofVertSampFactMax_Vmax,m_anSofVertSampFact_Vi[nCompIdent]);\r\n\t\t}\r\n\r\n\t\t// Report per-component sampling factors and quantization table selectors\r\n\t\tfor (unsigned nCompInd=1;((!m_bStateAbort)&&(nCompInd<=m_nSofNumComps_Nf));nCompInd++)\r\n\t\t{\r\n\t\t\tnCompIdent = m_anSofQuantCompId[nCompInd];\r\n\r\n\t\t\t// Create subsampling ratio\r\n\t\t\t// - Protect against division-by-zero\r\n\t\t\tCString\t\tstrSubsampH = _T(\"?\");\r\n\t\t\tCString\t\tstrSubsampV = _T(\"?\");\r\n\t\t\tif (m_anSofHorzSampFact_Hi[nCompIdent] > 0) {\r\n\t\t\t\tstrSubsampH.Format(_T(\"%u\"),m_nSofHorzSampFactMax_Hmax/m_anSofHorzSampFact_Hi[nCompIdent]);\r\n\t\t\t}\r\n\t\t\tif (m_anSofVertSampFact_Vi[nCompIdent] > 0) {\r\n\t\t\t\tstrSubsampV.Format(_T(\"%u\"),m_nSofVertSampFactMax_Vmax/m_anSofVertSampFact_Vi[nCompIdent]);\r\n\t\t\t}\r\n\r\n\t\t\tstrFull.Format(_T(\"    Component[%u]: \"),nCompInd);\t// Note i in Ci is 1-based\r\n//XXX\t\t\tstrTmp.Format(_T(\"ID=0x%02X, Samp Fac <Hi,Vi>=0x%02X (Subsamp %u x %u), Quant Tbl Sel <Tqi>=0x%02X\"),\r\n\t\t\tstrTmp.Format(_T(\"ID=0x%02X, Samp Fac=0x%02X (Subsamp %s x %s), Quant Tbl Sel=0x%02X\"),\r\n\t\t\t\tnCompIdent,anSofSampFact[nCompIdent],\r\n\t\t\t\t(LPCTSTR)strSubsampH,(LPCTSTR)strSubsampV,\r\n\t\t\t\tm_anSofQuantTblSel_Tqi[nCompIdent]);\r\n\t\t\tstrFull += strTmp;\r\n\r\n\t\t\t// Mapping from component index (not ID) to colour channel per JFIF\r\n\t\t\tif (m_nSofNumComps_Nf == 1) {\r\n\t\t\t\t// Assume grayscale\r\n\t\t\t\tstrFull += _T(\" (Lum: Y)\");\r\n\t\t\t} else if (m_nSofNumComps_Nf == 3) {\r\n\t\t\t\t// Assume YCC\r\n\t\t\t\tif (nCompInd == SCAN_COMP_Y) {\r\n\t\t\t\t\tstrFull += _T(\" (Lum: Y)\");\r\n\t\t\t\t}\r\n\t\t\t\telse if (nCompInd == SCAN_COMP_CB) {\r\n\t\t\t\t\tstrFull += _T(\" (Chrom: Cb)\");\r\n\t\t\t\t}\r\n\t\t\t\telse if (nCompInd == SCAN_COMP_CR) {\r\n\t\t\t\t\tstrFull += _T(\" (Chrom: Cr)\");\r\n\t\t\t\t}\r\n\t\t\t} else if (m_nSofNumComps_Nf == 4) {\r\n\t\t\t\t// Assume YCCK\r\n\t\t\t\tif (nCompInd == 1) {\r\n\t\t\t\t\tstrFull += _T(\" (Y)\");\r\n\t\t\t\t}\r\n\t\t\t\telse if (nCompInd == 2) {\r\n\t\t\t\t\tstrFull += _T(\" (Cb)\");\r\n\t\t\t\t}\r\n\t\t\t\telse if (nCompInd == 3) {\r\n\t\t\t\t\tstrFull += _T(\" (Cr)\");\r\n\t\t\t\t}\r\n\t\t\t\telse if (nCompInd == 4) {\r\n\t\t\t\t\tstrFull += _T(\" (K)\");\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tstrFull += _T(\" (???)\");\t// Unknown\r\n\t\t\t}\r\n\t\t\tm_pLog->AddLine(strFull);\r\n\r\n\t\t}\r\n\r\n\t\t// Test for bad input, clean up if bad\r\n\t\tfor (unsigned nCompInd=1;((!m_bStateAbort)&&(nCompInd<=m_nSofNumComps_Nf));nCompInd++)\r\n\t\t{\r\n\t\t\tnCompIdent = m_anSofQuantCompId[nCompInd];\r\n\t\t\tif (!ValidateValue(m_anSofQuantCompId[nCompInd],0,255,_T(\"Component ID <Ci>\"),true,0)) return DECMARK_ERR;\r\n\t\t\tif (!ValidateValue(m_anSofQuantTblSel_Tqi[nCompIdent],0,3,_T(\"Table Destination ID <Tqi>\"),true,0)) return DECMARK_ERR;\r\n\t\t\tif (!ValidateValue(m_anSofHorzSampFact_Hi[nCompIdent],1,4,_T(\"Horizontal Sampling Factor <Hi>\"),true,1)) return DECMARK_ERR;\r\n\t\t\tif (!ValidateValue(m_anSofVertSampFact_Vi[nCompIdent],1,4,_T(\"Vertical Sampling Factor <Vi>\"),true,1)) return DECMARK_ERR;\r\n\t\t}\r\n\r\n\r\n\t\t// Finally, assign the cleaned values to the decoder\r\n\t\tfor (unsigned nCompInd=1;((!m_bStateAbort)&&(nCompInd<=m_nSofNumComps_Nf));nCompInd++)\r\n\t\t{\r\n\t\t\tnCompIdent = m_anSofQuantCompId[nCompInd];\r\n\t\t\t// Store the DQT Table selection for the Image Decoder\r\n\t\t\t//   Param values: Nf,Tqi\r\n\t\t\t//   Param ranges: 1..255,0..3\r\n\t\t\t// Note that the Image Decoder doesn't need to see the Component Identifiers\r\n\t\t\tbRet = m_pImgDec->SetDqtTables(nCompInd,m_anSofQuantTblSel_Tqi[nCompIdent]);\r\n\t\t\tDecodeErrCheck(bRet);\r\n\r\n\t\t\t// Store the Precision (to handle 12-bit decode)\r\n\t\t\tm_pImgDec->SetPrecision(m_nSofPrecision_P);\r\n\r\n\t\t}\r\n\r\n\t\tif (!m_bStateAbort) {\r\n\r\n\t\t\t// Set the component sampling factors (chroma subsampling)\r\n\t\t\t// FIXME: check ranging\r\n\t\t\tfor (unsigned nCompInd=1;nCompInd<=m_nSofNumComps_Nf;nCompInd++) {\r\n\t\t\t\t// nCompInd is component index (1...Nf)\r\n\t\t\t\t// nCompIdent is Component Identifier (Ci)\r\n\t\t\t\t// Note that the Image Decoder doesn't need to see the Component Identifiers\r\n\t\t\t\tnCompIdent = m_anSofQuantCompId[nCompInd];\r\n\t\t\t\tm_pImgDec->SetSofSampFactors(nCompInd,m_anSofHorzSampFact_Hi[nCompIdent],m_anSofVertSampFact_Vi[nCompIdent]);\r\n\t\t\t}\r\n\r\n\t\t\t// Now mark the image as been somewhat OK (ie. should\r\n\t\t\t// also be suitable for EmbeddedThumb() and PrepareSignature()\r\n\t\t\tm_bImgOK = true;\r\n\r\n\t\t\tm_bStateSofOk = true;\r\n\r\n\t\t}\r\n\r\n\t\tif (!ExpectMarkerEnd(nPosMarkerStart,nLength))\r\n\t\t\treturn DECMARK_ERR;\r\n\r\n\t\tbreak;\r\n\r\n\r\n\tcase JFIF_COM: // COM\r\n\t\tnLength = Buf(m_nPos)*256 + Buf(m_nPos+1);\r\n\t\tm_nPos+=2;\r\n\t\tstrTmp.Format(_T(\"  Comment length = %u\"),nLength); \r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t// Check for JPEG COM vulnerability\r\n\t\t//   http://marc.info/?l=bugtraq&m=109524346729948\r\n\t\t// Note that the recovery is not very graceful. It will assume that the\r\n\t\t// field is actually zero-length, which will make the next byte trigger the\r\n\t\t// \"Expected marker 0xFF\" error message and probably abort. There is no\r\n\t\t// obvious way to \r\n\r\n\t\tif ( (nLength == 0) || (nLength == 1) ) {\r\n\t\t\tstrTmp.Format(_T(\"    JPEG Comment Field Vulnerability detected!\"));\r\n\t\t\tm_pLog->AddLineErr(strTmp);\r\n\t\t\tstrTmp.Format(_T(\"    Skipping data until next marker...\"));\r\n\t\t\tm_pLog->AddLineErr(strTmp);\r\n\t\t\tnLength = 2;\r\n\r\n\t\t\tbool bDoneSearch = false;\r\n\t\t\tunsigned nSkipStart = m_nPos;\r\n\t\t\twhile (!bDoneSearch) {\r\n                if (Buf(m_nPos) != 0xFF) {\r\n\t\t\t\t\tm_nPos++;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbDoneSearch = true;\r\n\t\t\t\t}\r\n\t\t\t\tif (m_nPos >= m_pWBuf->GetPosEof()) {\r\n\t\t\t\t\tbDoneSearch = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tstrTmp.Format(_T(\"    Skipped %u bytes\"),m_nPos - nSkipStart);\r\n\t\t\tm_pLog->AddLineErr(strTmp);\r\n\r\n\t\t\t// Break out of case statement\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t// Assume COM field valid length (ie. >= 2)\r\n\t\tstrFull = _T(\"    Comment=\");\r\n\t\tm_strComment = _T(\"\");\r\n\t\tfor (unsigned ind=0;ind<nLength-2;ind++)\r\n\t\t{\r\n\t\t\tnTmpVal = Buf(m_nPos++);\r\n\t\t\tif (_istprint(nTmpVal)) {\r\n\t\t\t\tstrTmp.Format(_T(\"%c\"),nTmpVal);\r\n\t\t\t\tm_strComment += strTmp;\r\n\t\t\t} else {\r\n\t\t\t\tm_strComment += _T(\".\");\r\n\t\t\t}\r\n\t\t}\r\n\t\tstrFull += m_strComment;\r\n\t\tm_pLog->AddLine(strFull);\r\n\r\n\t\tbreak;\r\n\r\n\tcase JFIF_DHT: // DHT    \r\n\t\tm_bStateDht = true;\r\n\t\tDecodeDHT(false);\r\n\t\tm_bStateDhtOk = true;\r\n\t\tbreak;\r\n\r\n\tcase JFIF_SOS: // SOS\r\n\t\tunsigned long nPosScanStart;\t// Byte count at start of scan data segment\r\n\r\n\t\tm_bStateSos = true;\r\n\r\n\t\t// NOTE: Only want to capture position of first SOS\r\n\t\t//       This should make other function such as AVI frame extract\r\n\t\t//       more robust in case we get multiple SOS segments.\r\n\t\t// We assume that this value is reset when we start a new decode\r\n\t\tif (m_nPosSos == 0) {\r\n\t\t\tm_nPosSos = m_nPos-2;\t// Used for Extract. Want to include actual marker\r\n\t\t}\r\n\r\n\t\tnLength = Buf(m_nPos)*256 + Buf(m_nPos+1);\r\n\t\tm_nPos+=2;\r\n\r\n\t\t// Ensure that we have seen proper markers before we try this one!\r\n\t\tif (!m_bStateSofOk) {\r\n\t\t\tstrTmp.Format(_T(\"  ERROR: SOS before valid SOF defined\"));\r\n\t\t\tm_pLog->AddLineErr(strTmp);\r\n\t\t\treturn DECMARK_ERR;\r\n\t\t}\r\n\r\n\t\tstrTmp.Format(_T(\"  Scan header length = %u\"),nLength); \r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tm_nSosNumCompScan_Ns = Buf(m_nPos++);\t\t// Ns, range 1..4\r\n//XXX\t\tstrTmp.Format(_T(\"  Number of image components <Ns> = %u\"),m_nSosNumCompScan_Ns);\r\n\t\tstrTmp.Format(_T(\"  Number of img components = %u\"),m_nSosNumCompScan_Ns);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t// Just in case something got corrupted, don't want to get out\r\n\t\t// of range here. Note that this will be a hard abort, and\r\n\t\t// will not resume decoding.\r\n\t\tif (m_nSosNumCompScan_Ns > MAX_SOS_COMP_NS) {\r\n\t\t\tstrTmp.Format(_T(\"  ERROR: Scan decode does not support > %u components\"),MAX_SOS_COMP_NS);\r\n\t\t\tm_pLog->AddLineErr(strTmp);\r\n\t\t\treturn DECMARK_ERR;\r\n\t\t}\r\n\r\n\t\tunsigned nSosCompSel_Cs;\r\n\t\tunsigned nSosHuffTblSel;\r\n\t\tunsigned nSosHuffTblSelDc_Td;\r\n\t\tunsigned nSosHuffTblSelAc_Ta;\r\n\t\t// Max range of components indices is between 1..4\r\n\t\tfor (unsigned int nScanCompInd=1;((nScanCompInd<=m_nSosNumCompScan_Ns) && (!m_bStateAbort));nScanCompInd++)\r\n\t\t{\r\n\t\t\tstrFull.Format(_T(\"    Component[%u]: \"),nScanCompInd);\r\n\t\t\tnSosCompSel_Cs = Buf(m_nPos++);\t// Cs, range 0..255\r\n\t\t\tnSosHuffTblSel = Buf(m_nPos++);\r\n\t\t\tnSosHuffTblSelDc_Td = (nSosHuffTblSel & 0xf0)>>4;\t// Td, range 0..3\r\n\t\t\tnSosHuffTblSelAc_Ta = (nSosHuffTblSel & 0x0f);\t\t// Ta, range 0..3\r\n\t\t\tstrTmp.Format(_T(\"selector=0x%02X, table=%u(DC),%u(AC)\"),nSosCompSel_Cs,nSosHuffTblSelDc_Td,nSosHuffTblSelAc_Ta);\r\n\t\t\tstrFull += strTmp;\r\n\t\t\tm_pLog->AddLine(strFull);\r\n\r\n\t\t\tbRet = m_pImgDec->SetDhtTables(nScanCompInd,nSosHuffTblSelDc_Td,nSosHuffTblSelAc_Ta);\r\n\r\n\t\t\tDecodeErrCheck(bRet);\r\n\t\t}\r\n\r\n\r\n\t\tm_nSosSpectralStart_Ss = Buf(m_nPos++);\r\n\t\tm_nSosSpectralEnd_Se = Buf(m_nPos++);\r\n\t\tm_nSosSuccApprox_A = Buf(m_nPos++);\r\n\r\n\t\tstrTmp.Format(_T(\"  Spectral selection = %u .. %u\"),m_nSosSpectralStart_Ss,m_nSosSpectralEnd_Se);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\t\tstrTmp.Format(_T(\"  Successive approximation = 0x%02X\"),m_nSosSuccApprox_A);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tif (m_pAppConfig->bOutputScanDump) {\r\n\t\t\tm_pLog->AddLine(_T(\"\"));\r\n\t\t\tm_pLog->AddLine(_T(\"  Scan Data: (after bitstuff removed)\"));\r\n\t\t}\r\n\r\n\t\t// Save the scan data segment position\r\n\t\tnPosScanStart = m_nPos;\r\n\r\n\t\t// Skip over the Scan Data segment\r\n\t\t//   Pass 1) Quick, allowing for bOutputScanDump to dump first 640B.\r\n\t\t//   Pass 2) If bDecodeScanImg, we redo the process but in detail decoding.\r\n\r\n\t\t// FIXME: Not sure why, but if I skip over Pass 1 (eg if I leave in the\r\n\t\t// following line uncommented), then I get an error at the end of the\r\n\t\t// pass 2 decode (indicating that EOI marker not seen, and expecting\r\n\t\t// marker).\r\n//\t\tif (m_pAppConfig->bOutputScanDump) {\r\n\r\n\t\t\t// --- PASS 1 ---\r\n\t\t\tbool\t\tbSkipDone;\r\n\t\t\tunsigned\tnSkipCount;\r\n\t\t\tunsigned\tnSkipData;\r\n\t\t\tunsigned\tnSkipPos;\r\n\t\t\tbool\t\tbScanDumpTrunc;\r\n\r\n\t\t\tbSkipDone = false;\r\n\t\t\tnSkipCount = 0;\r\n\t\t\tnSkipPos = 0;\r\n\t\t\tbScanDumpTrunc = FALSE;\r\n\r\n\t\t\tstrFull = _T(\"\");\r\n\t\t\twhile (!bSkipDone)\r\n\t\t\t{\r\n\t\t\t\tnSkipCount++;\r\n\t\t\t\tnSkipPos++;\r\n\t\t\t\tnSkipData = Buf(m_nPos++);\r\n\r\n\t\t\t\tif (nSkipData == 0xFF) {\r\n\t\t\t\t\t// this could either be a marker or a byte stuff\r\n\t\t\t\t\tnSkipData = Buf(m_nPos++);\r\n\t\t\t\t\tnSkipCount++;\r\n\t\t\t\t\tif (nSkipData == 0x00) {\r\n\t\t\t\t\t\t// Byte stuff\r\n\t\t\t\t\t\tnSkipData = 0xFF;\r\n\t\t\t\t\t} else if ((nSkipData >= JFIF_RST0) && (nSkipData <= JFIF_RST7)) {\r\n\t\t\t\t\t\t// Skip over\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// Marker\r\n\t\t\t\t\t\tbSkipDone = true;\r\n\t\t\t\t\t\tm_nPos -= 2;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (m_pAppConfig->bOutputScanDump && (!bSkipDone) ) {\r\n\t\t\t\t\t// Only display 20 lines of scan data\r\n\t\t\t\t\tif (nSkipPos > 640) {\r\n\t\t\t\t\t\tif (!bScanDumpTrunc) {\r\n\t\t\t\t\t\t\tm_pLog->AddLineWarn(_T(\"    WARNING: Dump truncated.\"));\r\n\t\t\t\t\t\t\tbScanDumpTrunc = TRUE;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif ( ((nSkipPos-1) == 0) || (((nSkipPos-1) % 32) == 0) ) {\r\n\t\t\t\t\t\t\tstrFull = _T(\"    \");\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tstrTmp.Format(_T(\"%02x \"),nSkipData);\r\n\t\t\t\t\t\tstrFull += strTmp;\r\n\r\n\t\t\t\t\t\tif (((nSkipPos-1) % 32) == 31) {\r\n\t\t\t\t\t\t\tm_pLog->AddLine(strFull);\r\n\t\t\t\t\t\t\tstrFull = _T(\"\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Did we run out of bytes?\r\n\r\n\t\t\t\t// FIXME:\r\n\t\t\t\t// NOTE: This line here doesn't allow us to attempt to \r\n\t\t\t\t// decode images that are missing EOI. Maybe this is\r\n\t\t\t\t// not the best solution here? Instead, we should be\r\n\t\t\t\t// checking m_nPos against file length? .. and not \r\n\t\t\t\t// return but \"break\".\r\n\t\t\t\tif (!m_pWBuf->GetBufOk()) {\r\n\t\t\t\t\tstrTmp.Format(_T(\"ERROR: Ran out of buffer before EOI during phase 1 of Scan decode @ 0x%08X\"),m_nPos);\r\n\t\t\t\t\tm_pLog->AddLineErr(strTmp);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\tm_pLog->AddLine(strFull);\r\n\r\n//\t\t}\r\n\r\n\t\t// --- PASS 2 ---\r\n\t\t// If the option is set, start parsing!\r\n\t\tif (m_pAppConfig->bDecodeScanImg && m_bImgSofUnsupported) {\r\n\t\t\t// SOF marker was of type we don't support, so skip decoding\r\n\t\t\tm_pLog->AddLineWarn(_T(\"  NOTE: Scan parsing doesn't support this SOF mode.\"));\r\n#ifndef DEBUG_YCCK\r\n\t\t} else if (m_pAppConfig->bDecodeScanImg && (m_nSofNumComps_Nf == 4)) {\r\n\t\t\tm_pLog->AddLineWarn(_T(\"  NOTE: Scan parsing doesn't support CMYK files yet.\"));\r\n#endif\r\n\t\t} else if (m_pAppConfig->bDecodeScanImg && !m_bImgSofUnsupported) {\r\n\t\t\tif (!m_bStateSofOk) {\r\n\t\t\t\tm_pLog->AddLineWarn(_T(\"  NOTE: Scan decode disabled as SOF not decoded.\"));\r\n\t\t\t} else if (!m_bStateDqtOk) {\r\n\t\t\t\tm_pLog->AddLineWarn(_T(\"  NOTE: Scan decode disabled as DQT not decoded.\"));\r\n\t\t\t} else if (!m_bStateDhtOk) {\r\n\t\t\t\tm_pLog->AddLineWarn(_T(\"  NOTE: Scan decode disabled as DHT not decoded.\"));\r\n\r\n\t\t\t} else {\r\n\t\t\t\tm_pLog->AddLine(_T(\"\"));\r\n\r\n\t\t\t\t// Set the primary image details\r\n\t\t\t\tm_pImgDec->SetImageDetails(m_nSofSampsPerLine_X,m_nSofNumLines_Y,\r\n\t\t\t\t\tm_nSofNumComps_Nf,m_nSosNumCompScan_Ns,m_nImgRstEn,m_nImgRstInterval);\r\n\r\n\t\t\t\t// Only recalculate the scan decoding if we need to (i.e. file\r\n\t\t\t\t// changed, offset changed, scan option changed)\r\n\t\t\t\t// TODO: In order to decode multiple scans, we will need to alter the\r\n\t\t\t\t// way that m_pImgSrcDirty is set\r\n\t\t\t\tif (m_pImgSrcDirty) {\r\n\t\t\t\t\tm_pImgDec->DecodeScanImg(nPosScanStart,true,false);\r\n\t\t\t\t\tm_pImgSrcDirty = false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tm_bStateSosOk = true;\r\n\r\n\t\tbreak;\r\n\r\n\tcase JFIF_DRI:\r\n\t\tunsigned\tnVal;\r\n\t\tnLength = Buf(m_nPos)*256 + Buf(m_nPos+1);\r\n\t\tstrTmp.Format(_T(\"  Length     = %u\"),nLength);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\t\tnVal = Buf(m_nPos+2)*256 + Buf(m_nPos+3);\r\n\r\n\t\t// According to ITU-T spec B.2.4.4, we only expect\r\n\t\t// restart markers if DRI value is non-zero!\r\n\t\tm_nImgRstInterval = nVal;\r\n\t\tif (nVal != 0) {\r\n\t\t\tm_nImgRstEn = true;\r\n\t\t} else {\r\n\t\t\tm_nImgRstEn = false;\r\n\t\t}\r\n\t\tstrTmp.Format(_T(\"  interval   = %u\"),m_nImgRstInterval);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\t\tm_nPos += 4;\r\n\t\tif (!ExpectMarkerEnd(nPosMarkerStart,nLength))\r\n\t\t\treturn DECMARK_ERR;\r\n\t\tbreak;\r\n\r\n\tcase JFIF_EOI: // EOI\r\n\t\tm_pLog->AddLine(_T(\"\"));\r\n\r\n\t\t// Save the EOI file position\r\n\t\t// NOTE: If the file is missing the EOI, then this variable will be\r\n\t\t//       set to mark the end of file.\r\n\t\tm_nPosEmbedEnd = m_nPos;\r\n\t\tm_nPosEoi = m_nPos;\r\n\t\tm_bStateEoi = true;\r\n\r\n\t\treturn DECMARK_EOI;\r\n\r\n\t\tbreak;\r\n\r\n\t// Markers that are not yet supported in JPEGsnoop\r\n\tcase JFIF_DHP:\r\n\t// Markers defined for future use / extensions\r\n\tcase JFIF_JPG:\r\n\tcase JFIF_JPG0:\r\n\tcase JFIF_JPG1:\r\n\tcase JFIF_JPG2:\r\n\tcase JFIF_JPG3:\r\n\tcase JFIF_JPG4:\r\n\tcase JFIF_JPG5:\r\n\tcase JFIF_JPG6:\r\n\tcase JFIF_JPG7:\r\n\tcase JFIF_JPG8:\r\n\tcase JFIF_JPG9:\r\n\tcase JFIF_JPG10:\r\n\tcase JFIF_JPG11:\r\n\tcase JFIF_JPG12:\r\n\tcase JFIF_JPG13:\r\n\tcase JFIF_TEM:\r\n\t\t// Unsupported marker\r\n\t\t// - Provide generic decode based on length\r\n\t\tnLength = Buf(m_nPos)*256 + Buf(m_nPos+1);\t// Length\r\n\t\tstrTmp.Format(_T(\"  Header length = %u\"),nLength);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\t\tm_pLog->AddLineWarn(_T(\"  Skipping unsupported marker\"));\r\n\t\tm_nPos += nLength;\r\n\t\tbreak;\r\n\r\n\tcase JFIF_RST0:\r\n\tcase JFIF_RST1:\r\n\tcase JFIF_RST2:\r\n\tcase JFIF_RST3:\r\n\tcase JFIF_RST4:\r\n\tcase JFIF_RST5:\r\n\tcase JFIF_RST6:\r\n\tcase JFIF_RST7:\r\n\t\t// We don't expect to see restart markers outside the entropy coded segment.\r\n\t\t// NOTE: RST# are standalone markers, so no length indicator exists\r\n\t\t// But for the sake of robustness, we can check here to see if treating\r\n\t\t// as a standalone marker will arrive at another marker (ie. OK). If not,\r\n\t\t// proceed to assume there is a length indicator.\r\n\t\tstrTmp.Format(_T(\"  WARNING: Restart marker [0xFF%02X] detected outside scan\"),nCode);\r\n\t\tm_pLog->AddLineWarn(strTmp);\r\n\t\tif (!m_pAppConfig->bRelaxedParsing) {\r\n\t\t\t// Abort\r\n\t\t\tm_pLog->AddLineErr(_T(\"  Stopping decode\"));\r\n\t\t\tm_pLog->AddLine(_T(\"  Use [Img Search Fwd/Rev] to locate other valid embedded JPEGs\"));\r\n\t\t\treturn DECMARK_ERR;\r\n\t\t} else {\r\n\t\t\t// Ignore\r\n\t\t\t// Check to see if standalone marker treatment looks OK\r\n\t\t\tif (Buf(m_nPos+2) == 0xFF) {\r\n\t\t\t\t// Looks like standalone\r\n\t\t\t\tm_pLog->AddLineWarn(_T(\"  Ignoring standalone marker. Proceeding with decode.\"));\r\n\t\t\t\tm_nPos += 2;\r\n\t\t\t} else {\r\n\t\t\t\t// Looks like marker with length\r\n\r\n\t\t\t\tnLength = Buf(m_nPos)*256 + Buf(m_nPos+1);\r\n\t\t\t\tstrTmp.Format(_T(\"  Header length = %u\"),nLength);\r\n\t\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t\t\tm_pLog->AddLineWarn(_T(\"  Skipping marker\"));\r\n\t\t\t\tm_nPos += nLength;\r\n\t\t\t}\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tdefault:\r\n\t\tstrTmp.Format(_T(\"  WARNING: Unknown marker [0xFF%02X]\"),nCode);\r\n\t\tm_pLog->AddLineWarn(strTmp);\r\n\t\tif (!m_pAppConfig->bRelaxedParsing) {\r\n\t\t\t// Abort\r\n\t\t\tm_pLog->AddLineErr(_T(\"  Stopping decode\"));\r\n\t\t\tm_pLog->AddLine(_T(\"  Use [Img Search Fwd/Rev] to locate other valid embedded JPEGs\"));\r\n\t\t\treturn DECMARK_ERR;\r\n\t\t} else {\r\n\t\t\t// Skip\r\n\t\t\tnLength = Buf(m_nPos)*256 + Buf(m_nPos+1);\r\n\t\t\tstrTmp.Format(_T(\"  Header length = %u\"),nLength);\r\n\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t\tm_pLog->AddLineWarn(_T(\"  Skipping marker\"));\r\n\t\t\tm_nPos += nLength;\r\n\t\t}\r\n\t}\r\n\r\n\t// Add white-space between each marker\r\n\tm_pLog->AddLine(_T(\" \"));\r\n\r\n\t// If we decided to abort for any reason, make sure we trap it now.\r\n\t// This will stop the ProcessFile() while loop. We can set m_bStateAbort\r\n\t// if user says that they want to stop.\r\n\tif (m_bStateAbort) {\r\n\t\treturn DECMARK_ERR;\r\n\t}\r\n\r\n\treturn DECMARK_OK;\r\n}\r\n\r\n\r\n// Print out a header for the current JFIF marker code\r\nvoid CjfifDecode::AddHeader(unsigned nCode)\r\n{\r\n\tCString strTmp;\r\n\r\n\tswitch(nCode)\r\n\t{\r\n\tcase JFIF_SOI: m_pLog->AddLineHdr(_T(\"*** Marker: SOI (xFFD8) ***\")); break;\r\n\r\n\tcase JFIF_APP0: m_pLog->AddLineHdr(_T(\"*** Marker: APP0 (xFFE0) ***\")); break;\r\n\tcase JFIF_APP1: m_pLog->AddLineHdr(_T(\"*** Marker: APP1 (xFFE1) ***\")); break;\r\n\tcase JFIF_APP2: m_pLog->AddLineHdr(_T(\"*** Marker: APP2 (xFFE2) ***\")); break;\r\n\tcase JFIF_APP3: m_pLog->AddLineHdr(_T(\"*** Marker: APP3 (xFFE3) ***\")); break;\r\n\tcase JFIF_APP4: m_pLog->AddLineHdr(_T(\"*** Marker: APP4 (xFFE4) ***\")); break;\r\n\tcase JFIF_APP5: m_pLog->AddLineHdr(_T(\"*** Marker: APP5 (xFFE5) ***\")); break;\r\n\tcase JFIF_APP6: m_pLog->AddLineHdr(_T(\"*** Marker: APP6 (xFFE6) ***\")); break;\r\n\tcase JFIF_APP7: m_pLog->AddLineHdr(_T(\"*** Marker: APP7 (xFFE7) ***\")); break;\r\n\tcase JFIF_APP8: m_pLog->AddLineHdr(_T(\"*** Marker: APP8 (xFFE8) ***\")); break;\r\n\tcase JFIF_APP9: m_pLog->AddLineHdr(_T(\"*** Marker: APP9 (xFFE9) ***\")); break;\r\n\tcase JFIF_APP10: m_pLog->AddLineHdr(_T(\"*** Marker: APP10 (xFFEA) ***\")); break;\r\n\tcase JFIF_APP11: m_pLog->AddLineHdr(_T(\"*** Marker: APP11 (xFFEB) ***\")); break;\r\n\tcase JFIF_APP12: m_pLog->AddLineHdr(_T(\"*** Marker: APP12 (xFFEC) ***\")); break;\r\n\tcase JFIF_APP13: m_pLog->AddLineHdr(_T(\"*** Marker: APP13 (xFFED) ***\")); break;\r\n\tcase JFIF_APP14: m_pLog->AddLineHdr(_T(\"*** Marker: APP14 (xFFEE) ***\")); break;\r\n\tcase JFIF_APP15: m_pLog->AddLineHdr(_T(\"*** Marker: APP15 (xFFEF) ***\")); break;\r\n\r\n\tcase JFIF_SOF0:  m_pLog->AddLineHdr(_T(\"*** Marker: SOF0 (Baseline DCT) (xFFC0) ***\")); break;\r\n\tcase JFIF_SOF1:  m_pLog->AddLineHdr(_T(\"*** Marker: SOF1 (Extended Sequential DCT, Huffman) (xFFC1) ***\")); break;\r\n\tcase JFIF_SOF2:  m_pLog->AddLineHdr(_T(\"*** Marker: SOF2 (Progressive DCT, Huffman) (xFFC2) ***\")); break;\r\n\tcase JFIF_SOF3:  m_pLog->AddLineHdr(_T(\"*** Marker: SOF3 (Lossless Process, Huffman) (xFFC3) ***\")); break;\r\n\tcase JFIF_SOF5:  m_pLog->AddLineHdr(_T(\"*** Marker: SOF5 (Differential Sequential DCT, Huffman) (xFFC4) ***\")); break;\r\n\tcase JFIF_SOF6:  m_pLog->AddLineHdr(_T(\"*** Marker: SOF6 (Differential Progressive DCT, Huffman) (xFFC5) ***\")); break;\r\n\tcase JFIF_SOF7:  m_pLog->AddLineHdr(_T(\"*** Marker: SOF7 (Differential Lossless Process, Huffman) (xFFC6) ***\")); break;\r\n\tcase JFIF_SOF9:  m_pLog->AddLineHdr(_T(\"*** Marker: SOF9 (Sequential DCT, Arithmetic) (xFFC9) ***\")); break;\r\n\tcase JFIF_SOF10: m_pLog->AddLineHdr(_T(\"*** Marker: SOF10 (Progressive DCT, Arithmetic) (xFFCA) ***\")); break;\r\n\tcase JFIF_SOF11: m_pLog->AddLineHdr(_T(\"*** Marker: SOF11 (Lossless Process, Arithmetic) (xFFCB) ***\")); break;\r\n\tcase JFIF_SOF13: m_pLog->AddLineHdr(_T(\"*** Marker: SOF13 (Differential Sequential, Arithmetic) (xFFCD) ***\")); break;\r\n\tcase JFIF_SOF14: m_pLog->AddLineHdr(_T(\"*** Marker: SOF14 (Differential Progressive DCT, Arithmetic) (xFFCE) ***\")); break;\r\n\tcase JFIF_SOF15: m_pLog->AddLineHdr(_T(\"*** Marker: SOF15 (Differential Lossless Process, Arithmetic) (xFFCF) ***\")); break;\r\n\r\n\tcase JFIF_JPG:   m_pLog->AddLineHdr(_T(\"*** Marker: JPG (xFFC8) ***\")); break;\r\n\tcase JFIF_DAC:   m_pLog->AddLineHdr(_T(\"*** Marker: DAC (xFFCC) ***\")); break;\r\n\r\n\tcase JFIF_RST0:\r\n\tcase JFIF_RST1:\r\n\tcase JFIF_RST2:\r\n\tcase JFIF_RST3:\r\n\tcase JFIF_RST4:\r\n\tcase JFIF_RST5:\r\n\tcase JFIF_RST6:\r\n\tcase JFIF_RST7:\r\n\t\tm_pLog->AddLineHdr(_T(\"*** Marker: RST# ***\"));\r\n\t\tbreak;\r\n\r\n\tcase JFIF_DQT:  // Define quantization tables\r\n\t\tm_pLog->AddLineHdr(_T(\"*** Marker: DQT (xFFDB) ***\"));\r\n\t\tm_pLog->AddLineHdrDesc(_T(\"  Define a Quantization Table.\"));\r\n\t\tbreak;\r\n\r\n\r\n\tcase JFIF_COM: // COM\r\n\t\tm_pLog->AddLineHdr(_T(\"*** Marker: COM (Comment) (xFFFE) ***\"));\r\n\t\tbreak;\r\n\r\n\tcase JFIF_DHT: // DHT\r\n\t\tm_pLog->AddLineHdr(_T(\"*** Marker: DHT (Define Huffman Table) (xFFC4) ***\"));\r\n\t\tbreak;\r\n\tcase JFIF_DHT_FAKE: // DHT from standard table (MotionJPEG)\r\n\t\tm_pLog->AddLineHdr(_T(\"*** Marker: DHT from MotionJPEG standard (Define Huffman Table) ***\"));\r\n\t\tbreak;\r\n\r\n\tcase JFIF_SOS: // SOS\r\n\t\tm_pLog->AddLineHdr(_T(\"*** Marker: SOS (Start of Scan) (xFFDA) ***\"));\r\n\t\tbreak;\r\n\r\n\tcase JFIF_DRI: // DRI\r\n\t\tm_pLog->AddLineHdr(_T(\"*** Marker: DRI (Restart Interval) (xFFDD) ***\"));\r\n\t\tbreak;\r\n\r\n\tcase JFIF_EOI: // EOI\r\n\t\tm_pLog->AddLineHdr(_T(\"*** Marker: EOI (End of Image) (xFFD9) ***\"));\r\n\t\tbreak;\r\n\r\n\tcase JFIF_DNL:   m_pLog->AddLineHdr(_T(\"*** Marker: DNL (Define Number of Lines) (xFFDC) ***\")); break;\r\n\tcase JFIF_DHP:   m_pLog->AddLineHdr(_T(\"*** Marker: DHP (Define Hierarchical Progression) (xFFDE) ***\")); break;\r\n\tcase JFIF_EXP:   m_pLog->AddLineHdr(_T(\"*** Marker: EXP (Expand Reference Components) (xFFDF) ***\")); break;\r\n\tcase JFIF_JPG0:  m_pLog->AddLineHdr(_T(\"*** Marker: JPG0 (JPEG Extension) (xFFF0) ***\")); break;\r\n\tcase JFIF_JPG1:  m_pLog->AddLineHdr(_T(\"*** Marker: JPG1 (JPEG Extension) (xFFF1) ***\")); break;\r\n\tcase JFIF_JPG2:  m_pLog->AddLineHdr(_T(\"*** Marker: JPG2 (JPEG Extension) (xFFF2) ***\")); break;\r\n\tcase JFIF_JPG3:  m_pLog->AddLineHdr(_T(\"*** Marker: JPG3 (JPEG Extension) (xFFF3) ***\")); break;\r\n\tcase JFIF_JPG4:  m_pLog->AddLineHdr(_T(\"*** Marker: JPG4 (JPEG Extension) (xFFF4) ***\")); break;\r\n\tcase JFIF_JPG5:  m_pLog->AddLineHdr(_T(\"*** Marker: JPG5 (JPEG Extension) (xFFF5) ***\")); break;\r\n\tcase JFIF_JPG6:  m_pLog->AddLineHdr(_T(\"*** Marker: JPG6 (JPEG Extension) (xFFF6) ***\")); break;\r\n\tcase JFIF_JPG7:  m_pLog->AddLineHdr(_T(\"*** Marker: JPG7 (JPEG Extension) (xFFF7) ***\")); break;\r\n\tcase JFIF_JPG8:  m_pLog->AddLineHdr(_T(\"*** Marker: JPG8 (JPEG Extension) (xFFF8) ***\")); break;\r\n\tcase JFIF_JPG9:  m_pLog->AddLineHdr(_T(\"*** Marker: JPG9 (JPEG Extension) (xFFF9) ***\")); break;\r\n\tcase JFIF_JPG10: m_pLog->AddLineHdr(_T(\"*** Marker: JPG10 (JPEG Extension) (xFFFA) ***\")); break;\r\n\tcase JFIF_JPG11: m_pLog->AddLineHdr(_T(\"*** Marker: JPG11 (JPEG Extension) (xFFFB) ***\")); break;\r\n\tcase JFIF_JPG12: m_pLog->AddLineHdr(_T(\"*** Marker: JPG12 (JPEG Extension) (xFFFC) ***\")); break;\r\n\tcase JFIF_JPG13: m_pLog->AddLineHdr(_T(\"*** Marker: JPG13 (JPEG Extension) (xFFFD) ***\")); break;\r\n\tcase JFIF_TEM:   m_pLog->AddLineHdr(_T(\"*** Marker: TEM (Temporary) (xFF01) ***\")); break;\r\n\r\n\r\n\r\n\tdefault:\r\n\t\tstrTmp.Format(_T(\"*** Marker: ??? (Unknown) (xFF%02X) ***\"),nCode);\r\n\t\tm_pLog->AddLineHdr(strTmp);\r\n\t\tbreak;\r\n\t}\r\n\t// Adjust position to account for the word used in decoding the marker!\r\n\tstrTmp.Format(_T(\"  OFFSET: 0x%08X\"),m_nPos-2);\r\n\tm_pLog->AddLine(strTmp);\r\n}\r\n\r\n\r\n// Update the status bar with a message\r\nvoid CjfifDecode::SetStatusText(CString strText)\r\n{\r\n\t// Make sure that we have been connected to the status\r\n\t// bar of the main window first! Note that it is jpegsnoopDoc\r\n\t// that sets this variable.\r\n\tif (m_pStatBar) {\r\n\t\tm_pStatBar->SetPaneText(0,strText);\r\n\t}\r\n}\r\n\r\n// Generate a special output form of the current image's\r\n// compression signature and other characteristics. This is only\r\n// used during development and batch import to build the MySQL repository.\r\nvoid CjfifDecode::OutputSpecial()\r\n{\r\n\tCString strTmp;\r\n\tCString strFull;\r\n\r\n\tASSERT(m_eImgLandscape!=ENUM_LANDSCAPE_UNSET);\r\n\r\n\t// This mode of operation is currently only used\r\n\t// to import the local signature database into a MySQL database\r\n\t// backend. It simply reports the MySQL commands which can be input\r\n\t// into a MySQL client application.\r\n\tif (m_bOutputDB)\r\n\t{\r\n\t\tm_pLog->AddLine(_T(\"*** DB OUTPUT START ***\"));\r\n\t\tm_pLog->AddLine(_T(\"INSERT INTO `quant` (`key`, `make`, `model`, \"));\r\n\t\tm_pLog->AddLine(_T(\"`qual`, `subsamp`, `lum_00`, `lum_01`, `lum_02`, `lum_03`, `lum_04`, \"));\r\n\t\tm_pLog->AddLine(_T(\"`lum_05`, `lum_06`, `lum_07`, `chr_00`, `chr_01`, `chr_02`, \"));\r\n\t\tm_pLog->AddLine(_T(\"`chr_03`, `chr_04`, `chr_05`, `chr_06`, `chr_07`, `qual_lum`, `qual_chr`) VALUES (\"));\r\n\r\n\t\tstrFull = _T(\"'*KEY*', \"); // key -- need to override\r\n\r\n\t\t// Might need to change m_strImgExifMake to be lowercase\r\n\t\tstrTmp.Format(_T(\"'%s', \"),(LPCTSTR)m_strImgExifMake);\r\n\t\tstrFull += strTmp; // make\r\n\r\n\t\tstrTmp.Format(_T(\"'%s', \"),(LPCTSTR)m_strImgExifModel);\r\n\t\tstrFull += strTmp; // model\r\n\r\n\t\tstrTmp.Format(_T(\"'%s', \"),(LPCTSTR)m_strImgQualExif);\r\n\t\tstrFull += strTmp; // quality\r\n\r\n\t\tstrTmp.Format(_T(\"'%s', \"),(LPCTSTR)m_strImgQuantCss);\r\n\t\tstrFull += strTmp; // subsampling\r\n\r\n\t\tm_pLog->AddLine(strFull);\r\n\r\n\t\t// Step through both quantization tables (0=lum,1=chr)\r\n\t\tunsigned nMatrixInd;\r\n\r\n\t\tfor (unsigned nDqtInd=0;nDqtInd<2;nDqtInd++) {\r\n\r\n\t\t\tstrFull = _T(\"\");\r\n\t\t\tfor (unsigned nY=0;nY<8;nY++) {\r\n\t\t\t\tstrFull += _T(\"'\");\r\n\t\t\t\tfor (unsigned nX=0;nX<8;nX++) {\r\n\t\t\t\t\t// Rotate the matrix if necessary!\r\n\t\t\t\t\tnMatrixInd = (m_eImgLandscape!=ENUM_LANDSCAPE_NO)?(nY*8+nX):(nX*8+nY);\r\n\t\t\t\t\tstrTmp.Format(_T(\"%u\"),m_anImgDqtTbl[nDqtInd][nMatrixInd]);\r\n\t\t\t\t\tstrFull += strTmp;\r\n\t\t\t\t\tif (nX!=7) { strFull += _T(\",\"); }\r\n\t\t\t\t}\r\n\t\t\t\tstrFull += _T(\"', \");\r\n\t\t\t\tif (nY==3) {\r\n\t\t\t\t\tm_pLog->AddLine(strFull);\r\n\t\t\t\t\tstrFull = _T(\"\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tm_pLog->AddLine(strFull);\r\n\r\n\t\t}\r\n\r\n\t\tstrFull = _T(\"\");\r\n\t\t// Output quality ratings\r\n\t\tstrTmp.Format(_T(\"'%f', \"),m_adImgDqtQual[0]);\r\n\t\tstrFull += strTmp;\r\n\t\t// Don't put out comma separator on last line!\r\n\t\tstrTmp.Format(_T(\"'%f'\"),m_adImgDqtQual[1]);\r\n\t\tstrFull += strTmp;\r\n\t\tstrFull += _T(\");\");\r\n\t\tm_pLog->AddLine(strFull);\r\n\r\n\t\tm_pLog->AddLine(_T(\"*** DB OUTPUT END ***\"));\r\n\t}\r\n\r\n}\r\n\r\n// Generate the compression signatures (both unrotated and\r\n// rotated) in advance of submitting to the database.\r\nvoid CjfifDecode::PrepareSignature()\r\n{\r\n\t// Set m_strHash\r\n\tPrepareSignatureSingle(false);\r\n\t// Set m_strHashRot\r\n\tPrepareSignatureSingle(true);\r\n}\r\n\r\n// Prepare the image signature for later submission\r\n// NOTE: ASCII vars are used (instead of unicode) to support usage of MD5 library\r\nvoid CjfifDecode::PrepareSignatureSingle(bool bRotate)\r\n{\r\n\tCStringA\t\t\tstrTmp;\r\n\tCStringA\t\t\tstrSet;\r\n\r\n\tCStringA\t\t\tstrHashIn;\r\n\tunsigned char\t\tpHashIn[2000];\r\n\tCStringA\t\t\tstrDqt;\r\n\tMD5_CTX\t\t\t\tsMd5;\r\n\tunsigned\t\t\tnLenHashIn;\r\n\tunsigned\t\t\tnInd;\r\n\r\n\tASSERT(m_eImgLandscape!=ENUM_LANDSCAPE_UNSET);\r\n\r\n\t// -----------------------------------------------------------\r\n\t// Calculate the MD5 hash for online/internal database!\r\n\t// signature \"00\" : DQT0,DQT1,CSS\r\n\t// signature \"01\" : salt,DQT0,DQT1,..DQTx(if defined)\r\n\r\n\r\n\t// Build the source string\r\n\t// NOTE: For the purposes of the hash, we need to rotate the DQT tables\r\n\t// if we detect that the photo is in portrait orientation! This keeps everything\r\n\t// consistent.\r\n\r\n\r\n\t// If no DQT tables have been defined (e.g. could have loaded text file!)\r\n\t// then override the sig generation!\r\n\tbool bDqtDefined = false;\r\n\tfor (unsigned nSet=0;nSet<4;nSet++) {\r\n\t\tif (m_abImgDqtSet[nSet]) {\r\n\t\t\tbDqtDefined = true;\r\n\t\t}\r\n\t}\r\n\tif (!bDqtDefined) {\r\n\t\tm_strHash = _T(\"NONE\");\r\n\t\tm_strHashRot = _T(\"NONE\");\r\n\t\treturn;\r\n\t}\r\n\r\n\t// NOTE:\r\n\t// The following MD5 code depends on an ASCII string for input\r\n\t// We are therefore using CStringA for the hash input instead\r\n\t// of the generic text functions. No special (non-ASCII)\r\n\t// characters are expected in this string.\r\n\r\n\tif (DB_SIG_VER == 0x00) {\r\n\t\tstrHashIn = \"\";\r\n\t} else {\r\n\t\tstrHashIn = \"JPEGsnoop\";\r\n\t}\r\n\r\n\t// Need to duplicate DQT0 if we only have one DQT table\r\n\tfor (unsigned nSet=0;nSet<4;nSet++) {\r\n\t\tif (m_abImgDqtSet[nSet]) {\r\n\t\t\tstrSet = \"\";\r\n\t\t\tstrSet.Format(\"*DQT%u,\",nSet);\r\n\t\t\tstrHashIn += strSet;\r\n\t\t\tfor (unsigned i=0;i<64;i++) {\r\n\t\t\t\tnInd = (!bRotate)?i:glb_anQuantRotate[i];\r\n\t\t\t\tstrTmp.Format(\"%03u,\",m_anImgDqtTbl[nSet][nInd]);\r\n\t\t\t\tstrHashIn += strTmp;\r\n\t\t\t}\r\n\t\t} // if DQTx defined\r\n\t} // loop through sets (DQT0..DQT3)\r\n\r\n\t// Removed CSS from signature after version 0x00\r\n\tif (DB_SIG_VER == 0x00) {\r\n\t\tstrHashIn += \"*CSS,\";\r\n\t\tstrHashIn += m_strImgQuantCss;\r\n\t\tstrHashIn += \",\";\r\n\t}\r\n\tstrHashIn += \"*END\";\r\n\tnLenHashIn = strlen(strHashIn);\r\n\r\n\t// Display hash input\r\n\tfor (unsigned i=0;i<nLenHashIn;i+=80) {\r\n\t\tstrTmp = \"\";\r\n\t\tstrTmp.Format(\"In%u: [\",i/80);\r\n\t\tstrTmp += strHashIn.Mid(i,80);\r\n\t\tstrTmp += \"]\";\r\n#ifdef DEBUG_SIG\r\n\t\tm_pLog->AddLine(strTmp);\r\n#endif\r\n\t}\r\n\r\n\t// Copy into buffer\r\n\tASSERT(nLenHashIn < 2000);\r\n\tfor (unsigned i=0;i<nLenHashIn;i++) {\r\n\t\tpHashIn[i] = strHashIn.GetAt(i);\r\n\t}\r\n\t\r\n\r\n\t// Calculate the hash\r\n\tMD5Init(&sMd5, 0);\r\n\tMD5Update(&sMd5, pHashIn, nLenHashIn);\r\n\tMD5Final(&sMd5);\r\n\r\n\t// Overwrite top 8 bits for signature version number\r\n\tsMd5.digest32[0] = (sMd5.digest32[0] & 0x00FFFFFF) + (DB_SIG_VER << 24);\r\n\r\n\t// Convert hash to string format\r\n\t// The hexadecimal string is converted to Unicode (if that is build directive)\r\n\tif (!bRotate) {\r\n\t\tm_strHash.Format(_T(\"%08X%08X%08X%08X\"),sMd5.digest32[0],sMd5.digest32[1],sMd5.digest32[2],sMd5.digest32[3]);\r\n\t} else {\r\n\t\tm_strHashRot.Format(_T(\"%08X%08X%08X%08X\"),sMd5.digest32[0],sMd5.digest32[1],sMd5.digest32[2],sMd5.digest32[3]);\r\n\t}\r\n\r\n}\r\n\r\n// Generate the compression signatures for the thumbnails\r\nvoid CjfifDecode::PrepareSignatureThumb()\r\n{\r\n\t// Generate m_strHashThumb\r\n\tPrepareSignatureThumbSingle(false);\r\n\t// Generate m_strHashThumbRot\r\n\tPrepareSignatureThumbSingle(true);\r\n}\r\n\r\n// Prepare the image signature for later submission\r\n// NOTE: ASCII vars are used (instead of unicode) to support usage of MD5 library\r\nvoid CjfifDecode::PrepareSignatureThumbSingle(bool bRotate)\r\n{\r\n\tCStringA\t\t\tstrTmp;\r\n\tCStringA\t\t\tstrSet;\r\n\r\n\tCStringA\t\t\tstrHashIn;\r\n\tunsigned char\t\tpHashIn[2000];\r\n\tCStringA\t\t\tstrDqt;\r\n\tMD5_CTX\t\t\t\tsMd5;\r\n\tunsigned\t\t\tnLenHashIn;\r\n\tunsigned\t\t\tnInd;\r\n\r\n\t// -----------------------------------------------------------\r\n\t// Calculate the MD5 hash for online/internal database!\r\n\t// signature \"00\" : DQT0,DQT1,CSS\r\n\t// signature \"01\" : salt,DQT0,DQT1\r\n\r\n\r\n\t// Build the source string\r\n\t// NOTE: For the purposes of the hash, we need to rotate the DQT tables\r\n\t// if we detect that the photo is in portrait orientation! This keeps everything\r\n\t// consistent.\r\n\r\n\t// If no DQT tables have been defined (e.g. could have loaded text file!)\r\n\t// then override the sig generation!\r\n\tbool bDqtDefined = false;\r\n\tfor (unsigned nSet=0;nSet<4;nSet++) {\r\n\t\tif (m_abImgDqtThumbSet[nSet]) {\r\n\t\t\tbDqtDefined = true;\r\n\t\t}\r\n\t}\r\n\tif (!bDqtDefined) {\r\n\t\tm_strHashThumb = _T(\"NONE\");\r\n\t\tm_strHashThumbRot = _T(\"NONE\");\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (DB_SIG_VER == 0x00) {\r\n\t\tstrHashIn = _T(\"\");\r\n\t} else {\r\n\t\tstrHashIn = _T(\"JPEGsnoop\");\r\n\t}\r\n\r\n\t//tblSelY = m_anSofQuantTblSel_Tqi[0]; // Y\r\n\t//tblSelC = m_anSofQuantTblSel_Tqi[1]; // Cb (should be same as for Cr)\r\n\r\n\t// Need to duplicate DQT0 if we only have one DQT table\r\n\r\n\tfor (unsigned nSet=0;nSet<4;nSet++) {\r\n\t\tif (m_abImgDqtThumbSet[nSet]) {\r\n\t\t\tstrSet = \"\";\r\n\t\t\tstrSet.Format(\"*DQT%u,\",nSet);\r\n\t\t\tstrHashIn += strSet;\r\n\t\t\tfor (unsigned i=0;i<64;i++) {\r\n\t\t\t\tnInd = (!bRotate)?i:glb_anQuantRotate[i];\r\n\t\t\t\tstrTmp.Format(\"%03u,\",m_anImgThumbDqt[nSet][nInd]);\r\n\t\t\t\tstrHashIn += strTmp;\r\n\t\t\t}\r\n\t\t} // if DQTx defined\r\n\t} // loop through sets (DQT0..DQT3)\r\n\r\n\t// Removed CSS from signature after version 0x00\r\n\tif (DB_SIG_VER == 0x00) {\r\n\t\tstrHashIn += \"*CSS,\";\r\n\t\tstrHashIn += m_strImgQuantCss;\r\n\t\tstrHashIn += \",\";\r\n\t}\r\n\tstrHashIn += \"*END\";\r\n\tnLenHashIn = strlen(strHashIn);\r\n\r\n\t// Display hash input\r\n\tfor (unsigned i=0;i<nLenHashIn;i+=80) {\r\n\t\tstrTmp = \"\";\r\n\t\tstrTmp.Format(\"In%u: [\",i/80);\r\n\t\tstrTmp += strHashIn.Mid(i,80);\r\n\t\tstrTmp += \"]\";\r\n#ifdef DEBUG_SIG\r\n\t\tm_pLog->AddLine(strTmp);\r\n#endif\r\n\t}\r\n\r\n\t// Copy into buffer\r\n\tASSERT(nLenHashIn < 2000);\r\n\tfor (unsigned i=0;i<nLenHashIn;i++) {\r\n\t\tpHashIn[i] = strHashIn.GetAt(i);\r\n\t}\r\n\r\n\t// Calculate the hash\r\n\tMD5Init(&sMd5, 0);\r\n\tMD5Update(&sMd5, pHashIn, nLenHashIn);\r\n\tMD5Final(&sMd5);\r\n\r\n\t// Overwrite top 8 bits for signature version number\r\n\tsMd5.digest32[0] = (sMd5.digest32[0] & 0x00FFFFFF) + (DB_SIG_VER << 24);\r\n\r\n\t// Convert hash to string format\r\n\tif (!bRotate) {\r\n\t\tm_strHashThumb.Format(_T(\"%08X%08X%08X%08X\"),sMd5.digest32[0],sMd5.digest32[1],sMd5.digest32[2],sMd5.digest32[3]);\r\n\t} else {\r\n\t\tm_strHashThumbRot.Format(_T(\"%08X%08X%08X%08X\"),sMd5.digest32[0],sMd5.digest32[1],sMd5.digest32[2],sMd5.digest32[3]);\r\n\t}\r\n\r\n}\r\n\r\n\r\n// Compare the image compression signature & metadata against the database.\r\n// This is the routine that is also responsible for creating an\r\n// \"Image Assessment\" -- ie. whether the image may have been edited or not.\r\n//\r\n// PRE: m_strHash signature has already been calculated by PrepareSignature()\r\nbool CjfifDecode::CompareSignature(bool bQuiet=false)\r\n{\r\n\tCString strTmp;\r\n\tCString strHashOut;\r\n\tCString locationStr;\r\n\r\n\tunsigned ind;\r\n\r\n\tbool\tbCurXsw = false;\r\n\tbool\tbCurXmm = false;\r\n\tbool\tbCurXmkr = false;\r\n\tbool\tbCurXextrasw = false;\t// EXIF Extra fields match software indicator\r\n\tbool\tbCurXcomsw = false;\t\t// EXIF COM field match software indicator\r\n\tbool\tbCurXps = false;\t\t// EXIF photoshop IRB present\r\n\tbool\tbSrchXsw = false;\r\n\tbool\tbSrchXswUsig = false;\r\n\tbool\tbSrchXmmUsig = false;\r\n\tbool\tbSrchUsig = false;\r\n\tbool\tbMatchIjg = false;\r\n\tCString\tsMatchIjgQual = _T(\"\");\r\n\r\n\tASSERT(m_strHash != _T(\"NONE\"));\r\n\tASSERT(m_strHashRot != _T(\"NONE\"));\r\n\r\n\tif (bQuiet) { m_pLog->Disable(); }\r\n\r\n\r\n\tm_pLog->AddLine(_T(\"\"));\r\n\tm_pLog->AddLineHdr(_T(\"*** Searching Compression Signatures ***\"));\r\n\tm_pLog->AddLine(_T(\"\"));\r\n\r\n\t// Output the hash\r\n\tstrHashOut = _T(\"  Signature:           \");\r\n\tstrHashOut += m_strHash;\r\n\tm_pLog->AddLine(strHashOut);\r\n\tstrHashOut = _T(\"  Signature (Rotated): \");\r\n\tstrHashOut += m_strHashRot;\r\n\tm_pLog->AddLine(strHashOut);\r\n\r\n\tstrTmp.Format(_T(\"  File Offset:         %lu bytes\"),m_pAppConfig->nPosStart);\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\t// Output the CSS\r\n\tstrTmp.Format(_T(\"  Chroma subsampling:  %s\"),(LPCTSTR)m_strImgQuantCss);\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\r\n\t// Calculate the final fields\r\n\t// Add Photoshop IRB entries\r\n\t// Note that we always add an entry to the m_strImgExtras even if\r\n\t// there are no photoshop tags detected. It will appear as \"[PS]:[0/0]\"\r\n\tstrTmp = _T(\"\");\r\n\tstrTmp.Format(_T(\"[PS]:[%u/%u],\"),m_nImgQualPhotoshopSa,m_nImgQualPhotoshopSfw);\r\n\tm_strImgExtras += strTmp;\r\n\r\n\r\n\t// --------------------------------------\r\n\t// Determine current entry fields\r\n\r\n\t// Note that some cameras/phones have an empty Make, but use the Model! (eg. Palm Treo)\r\n\tif ((m_strImgExifMake == _T(\"???\")) && (m_strImgExifModel == _T(\"???\"))) {\r\n\t\tm_pLog->AddLine(_T(\"  EXIF Make/Model:     NONE\"));\r\n\t\tbCurXmm = false;\r\n\t} else {\r\n\t\tstrTmp.Format(_T(\"  EXIF Make/Model:     OK   [%s] [%s]\"),(LPCTSTR)m_strImgExifMake,(LPCTSTR)m_strImgExifModel);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\t\tbCurXmm = true;\r\n\t}\r\n\r\n\tif (m_bImgExifMakernotes) {\r\n\t\tm_pLog->AddLine(_T(\"  EXIF Makernotes:     OK  \"));\r\n\t\tbCurXmkr = true;\r\n\t} else {\r\n\t\tm_pLog->AddLine(_T(\"  EXIF Makernotes:     NONE\"));\r\n\t\tbCurXmkr = false;\r\n\t}\r\n\r\n\tif (_tcslen(m_strSoftware) == 0) {\r\n\t\tm_pLog->AddLine(_T(\"  EXIF Software:       NONE\"));\r\n\t\tbCurXsw = false;\r\n\t} else {\r\n\t\tstrTmp.Format(_T(\"  EXIF Software:       OK   [%s]\"),(LPCTSTR)m_strSoftware);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t// EXIF software field is non-empty\r\n\t\tbCurXsw = true;\r\n\t}\r\n\r\n\tm_pLog->AddLine(_T(\"\"));\r\n\r\n\t// --------------------------------------\r\n\t// Determine search results\r\n\r\n\r\n\t// All of the rest of the search results require searching\r\n\t// through the database entries\r\n\r\n\tbSrchXswUsig = false;\r\n\tbSrchXmmUsig = false;\r\n\tbSrchUsig = false;\r\n\tbMatchIjg = false;\r\n\tsMatchIjgQual = _T(\"\");\r\n\r\n\tunsigned nSigsInternal = theApp.m_pDbSigs->GetNumSigsInternal();\r\n\tunsigned nSigsExtra = theApp.m_pDbSigs->GetNumSigsExtra();\r\n\r\n\tstrTmp.Format(_T(\"  Searching Compression Signatures: (%u built-in, %u user(*) )\"),nSigsInternal,nSigsExtra);\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\r\n\t// Now in SIG version 0x01 and later, we are not including\r\n\t// the CSS in the signature. Therefore, we need to compare it\r\n\t// manually.\r\n\r\n\tbool curMatchMm;\r\n\tbool curMatchSw;\r\n\tbool curMatchSig;\r\n\tbool curMatchSigCss;\r\n\r\n\r\n\t// Check on Extras field\r\n\t// Noted that Canon EOS Viewer Utility (EVU) seems to convert RAWs with\r\n\t// the only identifying information being this:\r\n\t//  e.g. \"[Canon.ImageType]:[CRW:EOS 300D DIGITAL CMOS RAW],_T(\"\r\n\tif (m_strImgExtras.Find(_T(\")[Canon.ImageType]:[CRW:\")) != -1) {\r\n\t\tbCurXextrasw = true;\r\n\t}\r\n\tif (m_strImgExtras.Find(_T(\"[Nikon1.Quality]:[RAW\")) != -1) {\r\n\t\tbCurXextrasw = true;\r\n\t}\r\n\tif (m_strImgExtras.Find(_T(\"[Nikon2.Quality]:[RAW\")) != -1) {\r\n\t\tbCurXextrasw = true;\r\n\t}\r\n\tif (m_strImgExtras.Find(_T(\"[Nikon3.Quality]:[RAW\")) != -1) {\r\n\t\tbCurXextrasw = true;\r\n\t}\r\n\tif ((m_nImgQualPhotoshopSa != 0) || (m_nImgQualPhotoshopSfw != 0)) {\r\n\t\tbCurXps = true;\r\n\t}\r\n\r\n\t// Search for known COMment field indicators\r\n\tif (theApp.m_pDbSigs->SearchCom(m_strComment)) {\r\n\t\tbCurXcomsw = true;\r\n\t}\r\n\r\n\tm_pLog->AddLine(_T(\"\"));\r\n\tm_pLog->AddLine(_T(\"          EXIF.Make / Software        EXIF.Model                            Quality           Subsamp Match?\"));\r\n\tm_pLog->AddLine(_T(\"          -------------------------   -----------------------------------   ----------------  --------------\"));\r\n\r\n\tCompSig pEntry;\r\n\tunsigned ind_max = theApp.m_pDbSigs->GetDBNumEntries();\r\n\tfor (ind=0;ind<ind_max;ind++) {\r\n\t\ttheApp.m_pDbSigs->GetDBEntry(ind,&pEntry);\r\n\r\n\t\t// Reset current entry state\r\n\t\tcurMatchMm = false;\r\n\t\tcurMatchSw = false;\r\n\t\tcurMatchSig = false;\r\n\t\tcurMatchSigCss = false;\r\n\r\n\t\t// Compare make/model (only for digicams)\r\n\t\tif ((pEntry.eEditor == ENUM_EDITOR_CAM) &&\r\n\t\t\t(bCurXmm == true) &&\r\n\t\t\t(pEntry.strXMake  == m_strImgExifMake) &&\r\n\t\t\t(pEntry.strXModel == m_strImgExifModel) )\r\n\t\t{\r\n\t\t\tcurMatchMm = true;\r\n\t\t}\r\n\r\n\t\t// For software entries, do a loose search\r\n\t\tif ((pEntry.eEditor == ENUM_EDITOR_SW) &&\r\n\t\t\t(bCurXsw == true) &&\r\n\t\t\t(pEntry.strMSwTrim != _T(\"\")) &&\r\n\t\t\t(m_strSoftware.Find(pEntry.strMSwTrim) != -1) )\r\n\t\t{\r\n\t\t\t// Software field matches known software string\r\n\t\t\tbSrchXsw = true;\r\n\t\t\tcurMatchSw = true;\r\n\t\t}\r\n\r\n\r\n\t\t// Compare signature (and CSS for digicams)\r\n\t\tif ( (pEntry.strCSig == m_strHash) || (pEntry.strCSigRot == m_strHash) ||\r\n\t\t\t(pEntry.strCSig == m_strHashRot) || (pEntry.strCSigRot == m_strHashRot) )\r\n\t\t{\r\n\t\t\tcurMatchSig = true;\r\n\r\n\t\t\t// If Database entry is for an editor, sig matches irrespective of CSS\r\n\t\t\tif (pEntry.eEditor == ENUM_EDITOR_SW) {\r\n\t\t\t\tbSrchUsig = true;\r\n\t\t\t\tcurMatchSigCss = true; // FIXME: do I need this?\r\n\r\n\t\t\t\t// For special case of IJG\r\n\t\t\t\tif (pEntry.strMSwDisp == _T(\"IJG Library\")) {\r\n\t\t\t\t\tbMatchIjg = true;\r\n\t\t\t\t\tsMatchIjgQual = pEntry.strUmQual;\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\t\t\t\t// Database entry is for a digicam, sig match only if CSS matches too\r\n\t\t\t\tif (pEntry.strXSubsamp == m_strImgQuantCss) {\r\n\t\t\t\t\tbSrchUsig = true;\r\n\t\t\t\t\tcurMatchSigCss = true;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcurMatchSigCss = false;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} // editor\r\n\r\n\t\t} else {\r\n\t\t\t// sig doesn't match\r\n\t\t\tcurMatchSig = false;\r\n\t\t\tcurMatchSigCss = false;\r\n\t\t}\r\n\r\n\r\n\t\t// For digicams:\r\n\t\tif (curMatchMm && curMatchSigCss) {\r\n\t\t\tbSrchXmmUsig = true;\r\n\t\t}\r\n\t\t// For software:\r\n\t\tif (curMatchSw && curMatchSig) {\r\n\t\t\tbSrchXswUsig = true;\r\n\t\t}\r\n\r\n\t\tif (theApp.m_pDbSigs->IsDBEntryUser(ind)) {\r\n\t\t\tlocationStr = _T(\"*\");\r\n\t\t} else {\r\n\t\t\tlocationStr = _T(\" \");\r\n\t\t}\r\n\r\n\t\t// Display entry if it is a good match\r\n\t\tif (curMatchSig) {\r\n\t\t\tif (pEntry.eEditor==ENUM_EDITOR_CAM) {\r\n\t\t\t\tstrTmp.Format(_T(\"    %s%4s[%-25s] [%-35s] [%-16s] %-5s %-5s %-5s\"),(LPCTSTR)locationStr,_T(\"CAM:\"),\r\n\t\t\t\t\t(LPCTSTR)pEntry.strXMake.Left(25),(LPCTSTR)pEntry.strXModel.Left(35),(LPCTSTR)pEntry.strUmQual.Left(16),\r\n\t\t\t\t\t(curMatchSigCss?_T(\"Yes\"):_T(\"No\")),_T(\"\"),_T(\"\"));\r\n\t\t\t} else if (pEntry.eEditor==ENUM_EDITOR_SW) {\r\n\t\t\t\tstrTmp.Format(_T(\"    %s%4s[%-25s]  %-35s  [%-16s] %-5s %-5s %-5s\"),(LPCTSTR)locationStr,_T(\"SW :\"),\r\n\t\t\t\t\t(LPCTSTR)pEntry.strMSwDisp.Left(25),_T(\"\"),(LPCTSTR)pEntry.strUmQual.Left(16),\r\n\t\t\t\t\t_T(\"\"),_T(\"\"),_T(\"\"));\r\n\t\t\t} else {\r\n\t\t\t\tstrTmp.Format(_T(\"    %s%4s[%-25s] [%-35s] [%-16s] %-5s %-5s %-5s\"),(LPCTSTR)locationStr,_T(\"?? :\"),\r\n\t\t\t\t\t(LPCTSTR)pEntry.strXMake.Left(25),(LPCTSTR)pEntry.strXModel.Left(35),(LPCTSTR)pEntry.strUmQual.Left(16),\r\n\t\t\t\t\t_T(\"\"),_T(\"\"),_T(\"\"));\r\n\t\t\t}\r\n\t\t\tif (curMatchMm || curMatchSw) {\r\n\t\t\t\tm_pLog->AddLineGood(strTmp);\r\n\t\t\t} else {\r\n\t\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\r\n\t} // loop through DB\r\n\r\n\tCString strSw;\r\n\t// If it matches an IJG signature, report other possible sources:\r\n\tif (bMatchIjg) {\r\n\t\tm_pLog->AddLine(_T(\"\"));\r\n\t\tm_pLog->AddLine(_T(\"    The following IJG-based editors also match this signature:\"));\r\n\t\tunsigned nIjgNum;\r\n\t\tCString strIjgSw;\r\n\t\tnIjgNum = theApp.m_pDbSigs->GetIjgNum();\r\n\t\tfor (ind=0;ind<nIjgNum;ind++)\r\n\t\t{\r\n\t\t\tstrIjgSw = theApp.m_pDbSigs->GetIjgEntry(ind);\r\n\t\t\tstrTmp.Format(_T(\"     %4s[%-25s]  %-35s  [%-16s] %-5s %-5s %-5s\"),_T(\"SW :\"),\r\n\t\t\t\t(LPCTSTR)strIjgSw.Left(25),_T(\"\"),(LPCTSTR)sMatchIjgQual.Left(16),\r\n\t\t\t\t_T(\"\"),_T(\"\"),_T(\"\"));\r\n\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t}\r\n\t}\r\n\r\n\t//m_pLog->AddLine(_T(\"          --------------------   -----------------------------------   ----------------  --------------\"));\r\n\tm_pLog->AddLine(_T(\"\"));\r\n\r\n\tif (bCurXps) {\r\n\t\tm_pLog->AddLine(_T(\"  NOTE: Photoshop IRB detected\"));\r\n\t}\r\n\tif (bCurXextrasw) {\r\n\t\tm_pLog->AddLine(_T(\"  NOTE: Additional EXIF fields indicate software processing\"));\r\n\t}\r\n\tif (bSrchXsw) {\r\n\t\tm_pLog->AddLine(_T(\"  NOTE: EXIF Software field recognized as from editor\"));\r\n\t}\r\n\tif (bCurXcomsw) {\r\n\t\tm_pLog->AddLine(_T(\"  NOTE: JFIF COMMENT field is known software\"));\r\n\t}\r\n\r\n\r\n\r\n\t// ============================================\r\n\t// Image Assessment Algorithm\r\n\t// ============================================\r\n\r\n\tbool bEditDefinite = false;\r\n\tbool bEditLikely = false;\r\n\tbool bEditNot = false;\r\n\tbool bEditNotUnknownSw = false;\r\n\r\n\tif (bCurXps) {\r\n\t\tbEditDefinite = true;\r\n\t}\r\n\tif (!bCurXmm) {\r\n\t\tbEditDefinite = true;\r\n\t}\r\n\tif (bCurXextrasw) {\r\n\t\tbEditDefinite = true;\r\n\t}\r\n\tif (bCurXcomsw) {\r\n\t\tbEditDefinite = true;\r\n\t}\r\n\tif (bSrchXsw) {\r\n\t\t// Software field matches known software string\r\n\t\tbEditDefinite = true;\r\n\t}\r\n\tif (theApp.m_pDbSigs->LookupExcMmIsEdit(m_strImgExifMake,m_strImgExifModel)) {\r\n\t\t// Make/Model is in exception list of ones that mark known software\r\n\t\tbEditDefinite = true;\r\n\t}\r\n\r\n\tif (!bCurXmkr) {\r\n\t\t// If we are missing maker notes, we are almost always dealing with\r\n\t\t// edited images. There are some known exceptions, so far:\r\n\t\t//  - Very old digicams\r\n\t\t//  - Certain camera phones\r\n\t\t//  - Blackberry \r\n\t\t// Perhaps we can make an exception for particular digicams (based on\r\n\t\t// make/model) that this determination will not apply. This means that\r\n\t\t// we open up the doors for these files being edited and not caught.\r\n\r\n\t\tif (theApp.m_pDbSigs->LookupExcMmNoMkr(m_strImgExifMake,m_strImgExifModel)) {\r\n\t\t\t// This is a known exception!\r\n\t\t} else {\r\n\t\t\tbEditLikely = true;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t// Filter down remaining scenarios\r\n\tif (!bEditDefinite && !bEditLikely) {\r\n\r\n\t\tif (bSrchXmmUsig) {\r\n\t\t\t// DB cam signature matches DQT & make/model\r\n\t\t\tif (!bCurXsw) {\r\n\t\t\t\t// EXIF software field is empty\r\n\t\t\t\t//\r\n\t\t\t\t// We can now be pretty confident that this file has not\r\n\t\t\t\t// been edited by all the means that we are checking\r\n\t\t\t\tbEditNot = true;\r\n\t\t\t} else {\r\n\t\t\t\t// EXIF software field is set\r\n\t\t\t\t//\r\n\t\t\t\t// This field is often used by:\r\n\t\t\t\t//  - Software editors (edited)\r\n\t\t\t\t//  - RAW converter software (edited)\r\n\t\t\t\t//  - Digicams to indicate firmware (original)\r\n\t\t\t\t//  - Phones to indicate firmware (original)\r\n\t\t\t\t//\r\n\t\t\t\t// However, in generating bEditDefinite, we have already\r\n\t\t\t\t// checked for bSrchXsw which looked for known software\r\n\t\t\t\t// strings. Therefore, we will primarily be left with\r\n\t\t\t\t// firmware strings, etc.\r\n\t\t\t\t//\r\n\t\t\t\t// We will mark this as NOT EDITED but with caution of unknown SW field\r\n\t\t\t\tbEditNot = true;\r\n\t\t\t\tbEditNotUnknownSw = true;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// No DB cam signature matches DQT & make/model\r\n\t\t\t// According to EXIF data, this file does not appear to be edited,\r\n\t\t\t// but no compression signatures in the database match this\r\n\t\t\t// particular make/model. Therefore, result is UNSURE.\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\t// Now make final assessment call\r\n\r\n\r\n\r\n\t// Determine if image has been processed/edited\r\n\tm_eImgEdited = EDITED_UNSET;\r\n\tif (bEditDefinite) {\r\n\t\tm_eImgEdited = EDITED_YES;\r\n\t} else if (bEditLikely) {\r\n\t\tm_eImgEdited = EDITED_YESPROB;\r\n\t} else if (bEditNot) {\r\n\t\t// Images that fall into this category will have:\r\n\t\t//  - No Photoshop tags\r\n\t\t//  - Make/Model is present\r\n\t\t//  - Makernotes present\r\n\t\t//  - No extra software tags (eg. IFD)\r\n\t\t//  - No comment field with known software\r\n\t\t//  - No software field or it does not match known software\r\n\t\t//  - Signature matches DB for this make/model\r\n\t\tm_eImgEdited = EDITED_NO;\r\n\t} else {\r\n\t\t// Images that fall into this category will have:\r\n\t\t//  - Same as EDITED_NO but:\r\n\t\t//  - Signature does not match DB for this make/model\r\n\t\t// In all likelihood, this image will in fact be original\r\n\t\tm_eImgEdited = EDITED_UNSURE;\r\n\t}\r\n\r\n\r\n\r\n\r\n\t// If the file offset is non-zero, then don't ask for submit or show assessment\r\n\tif (m_pAppConfig->nPosStart != 0) {\r\n\t\tm_pLog->AddLine(_T(\"  ASSESSMENT not done as file offset non-zero\"));\r\n\t\tif (bQuiet) { m_pLog->Enable(); }\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// ============================================\r\n\t// Display final assessment\r\n\t// ============================================\r\n\r\n\tm_pLog->AddLine(_T(\"  Based on the analysis of compression characteristics and EXIF metadata:\"));\r\n\tm_pLog->AddLine(_T(\"\"));\r\n\tif (m_eImgEdited == EDITED_YES) {\r\n\t\tm_pLog->AddLine(_T(\"  ASSESSMENT: Class 1 - Image is processed/edited\"));\r\n\t} else if (m_eImgEdited == EDITED_YESPROB) {\r\n\t\tm_pLog->AddLine(_T(\"  ASSESSMENT: Class 2 - Image has high probability of being processed/edited\"));\r\n\t} else if (m_eImgEdited == EDITED_NO) {\r\n\t\tm_pLog->AddLine(_T(\"  ASSESSMENT: Class 3 - Image has high probability of being original\"));\r\n\t\t// In case the EXIF Software field was detected, \r\n\t\tif (bEditNotUnknownSw) {\r\n\t\t\tm_pLog->AddLine(_T(\"              Note that EXIF Software field is set (typically contains Firmware version)\"));\r\n\t\t}\r\n\t} else if (m_eImgEdited == EDITED_UNSURE) {\r\n\t\tm_pLog->AddLine(_T(\"  ASSESSMENT: Class 4 - Uncertain if processed or original\"));\r\n\t\tm_pLog->AddLine(_T(\"              While the EXIF fields indicate original, no compression signatures \"));\r\n\t\tm_pLog->AddLine(_T(\"              in the current database were found matching this make/model\"));\r\n\t} else {\r\n\t\tm_pLog->AddLineErr(_T(\"  ASSESSMENT: *** Failed to complete ***\"));\r\n\t}\r\n\tm_pLog->AddLine(_T(\"\"));\r\n\r\n\r\n\r\n\t// Determine if user should add entry to DB\r\n\tbool bDbReqAdd = false;\t\t// Ask user to add\r\n\tbool bDbReqAddAuto = false;\t// Automatically add (in batch operation)\r\n\r\n\r\n\t// TODO: This section should be rewritten to reduce complexity\r\n\r\n\tm_eDbReqSuggest = DB_ADD_SUGGEST_UNSET;\r\n\tif (m_eImgEdited == EDITED_NO) {\r\n\t\tbDbReqAdd = false;\r\n\t\tm_eDbReqSuggest = DB_ADD_SUGGEST_CAM;\r\n\t} else if (m_eImgEdited == EDITED_UNSURE) {\r\n\t\tbDbReqAdd = true;\r\n\t\tbDbReqAddAuto = true;\r\n\t\tm_eDbReqSuggest = DB_ADD_SUGGEST_CAM;\r\n\t\tm_pLog->AddLine(_T(\"  Appears to be new signature for known camera.\"));\r\n\t\tm_pLog->AddLine(_T(\"  If the camera/software doesn't appear in list above,\"));\r\n\t\tm_pLog->AddLineWarn(_T(\"  PLEASE ADD TO DATABASE with [Tools->Add Camera to DB]\"));\r\n\t} else if (bCurXps && bSrchUsig) {\r\n\t\t// Photoshop and we already have sig\r\n\t\tbDbReqAdd = false;\r\n\t\tm_eDbReqSuggest = DB_ADD_SUGGEST_SW;\r\n\t} else if (bCurXps && !bSrchUsig) {\r\n\t\t// Photoshop and we don't already have sig\r\n\t\tbDbReqAdd = true;\r\n\t\tbDbReqAddAuto = true;\r\n\t\tm_eDbReqSuggest = DB_ADD_SUGGEST_SW;\r\n\t\tm_pLog->AddLine(_T(\"  Appears to be new signature for Photoshop.\"));\r\n\t\tm_pLog->AddLine(_T(\"  If it doesn't appear in list above,\"));\r\n\t\tm_pLog->AddLineWarn(_T(\"  PLEASE ADD TO DATABASE with [Tools->Add Camera to DB]\"));\r\n\t} else if (bCurXsw && bSrchXsw && bSrchXswUsig) {\r\n\t\tbDbReqAdd = false;\r\n\t\tm_eDbReqSuggest = DB_ADD_SUGGEST_SW;\r\n\t} else if (bCurXextrasw) {\r\n\t\tbDbReqAdd = false;\r\n\t\tm_eDbReqSuggest = DB_ADD_SUGGEST_SW;\r\n\t} else if (bCurXsw && bSrchXsw && !bSrchXswUsig) {\r\n\t\tbDbReqAdd = true;\r\n\t\t//bDbReqAddAuto = true;\r\n\t\tm_eDbReqSuggest = DB_ADD_SUGGEST_SW;\r\n\t\tm_pLog->AddLine(_T(\"  Appears to be new signature for known software.\"));\r\n\t\tm_pLog->AddLine(_T(\"  If the camera/software doesn't appear in list above,\"));\r\n\t\tm_pLog->AddLineWarn(_T(\"  PLEASE ADD TO DATABASE with [Tools->Add Camera to DB]\"));\r\n\t} else if (bCurXmm && bCurXmkr && !bSrchXsw && !bSrchXmmUsig) {\r\n\t\t// unsure if cam, so ask user\r\n\t\tbDbReqAdd = true;\r\n\t\tbDbReqAddAuto = true; \r\n\t\tm_eDbReqSuggest = DB_ADD_SUGGEST_CAM;\r\n\t\tm_pLog->AddLine(_T(\"  This may be a new camera for the database.\"));\r\n\t\tm_pLog->AddLine(_T(\"  If this file is original, and camera doesn't appear in list above,\"));\r\n\t\tm_pLog->AddLineWarn(_T(\"  PLEASE ADD TO DATABASE with [Tools->Add Camera to DB]\"));\r\n\t} else if (!bCurXmm && !bCurXmkr && !bSrchXsw) {\r\n\t\t// unsure if SW, so ask user\r\n\t\tbDbReqAdd = true;\r\n\t\tm_eDbReqSuggest = DB_ADD_SUGGEST_SW;\r\n\t\tm_pLog->AddLine(_T(\"  This may be a new software editor for the database.\"));\r\n\t\tm_pLog->AddLine(_T(\"  If this file is processed, and editor doesn't appear in list above,\"));\r\n\t\tm_pLog->AddLineWarn(_T(\"  PLEASE ADD TO DATABASE with [Tools->Add Camera to DB]\"));\r\n\t}\r\n\r\n\r\n\tm_pLog->AddLine(_T(\"\"));\r\n\r\n\t// -----------------------------------------------------------\r\n\r\n\tif (bQuiet) { m_pLog->Enable(); }\r\n\r\n#ifdef BATCH_DO_DBSUBMIT_ALL\r\n\tbDbReqAddAuto = true;\r\n#endif\r\n\r\n\t// Return a value that indicates whether or not we should add this\r\n\t// entry to the database\r\n\treturn bDbReqAddAuto;\r\n\r\n}\r\n\r\n\r\n// Build the image data string that will be sent to the database repository\r\n// This data string contains the compression siganture and a few special\r\n// fields such as image dimensions, etc.\r\n//\r\n// If Portrait, Rotates DQT table, Width/Height.\r\n//   m_strImgQuantCss is already rotated by ProcessFile()\r\n// PRE: m_strHash already defined\r\nvoid CjfifDecode::PrepareSendSubmit(CString strQual,teSource eUserSource,CString strUserSoftware,CString strUserNotes)\r\n{\r\n\t// Generate the DQT arrays suitable for posting\r\n\tCString\t\tstrTmp1;\r\n\tCString\t\tasDqt[4];\r\n\tunsigned\tnMatrixInd;\r\n\r\n\tASSERT(m_strHash != _T(\"NONE\"));\r\n\tASSERT(m_eImgLandscape!=ENUM_LANDSCAPE_UNSET);\r\n\r\n\tfor (unsigned nSet=0;nSet<4;nSet++) {\r\n\t\tasDqt[nSet] = _T(\"\");\r\n\r\n\t\tif (m_abImgDqtSet[nSet]) {\r\n\t\t\tfor (unsigned nInd=0;nInd<64;nInd++) {\r\n\t\t\t\t// FIXME: Still consider rotating DQT table even though we\r\n\t\t\t\t// don't know for sure if m_eImgLandscape is accurate\r\n\t\t\t\t// Not a big deal if we get it wrong as we still add\r\n\t\t\t\t// both pre- and post-rotated sigs.\r\n\t\t\t\tnMatrixInd = (m_eImgLandscape!=ENUM_LANDSCAPE_NO)?nInd:glb_anQuantRotate[nInd];\r\n\t\t\t\tif ((nInd%8 == 0) && (nInd != 0)) {\r\n\t\t\t\t\tasDqt[nSet].Append(_T(\"!\"));\r\n\t\t\t\t}\r\n\r\n\t\t\t\tasDqt[nSet].AppendFormat(_T(\"%u\"),m_anImgDqtTbl[nSet][nMatrixInd]);\r\n\t\t\t\tif (nInd%8 != 7) {\r\n\t\t\t\t\tasDqt[nSet].Append(_T(\",\"));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} // set defined?\r\n\t} // up to 4 sets\r\n\r\n\tunsigned nOrigW,nOrigH;\r\n\tnOrigW = (m_eImgLandscape!=ENUM_LANDSCAPE_NO)?m_nSofSampsPerLine_X:m_nSofNumLines_Y;\r\n\tnOrigH = (m_eImgLandscape!=ENUM_LANDSCAPE_NO)?m_nSofNumLines_Y:m_nSofSampsPerLine_X;\r\n\r\n\tunsigned nOrigThumbW,nOrigThumbH;\r\n\tnOrigThumbW = (m_eImgLandscape!=ENUM_LANDSCAPE_NO)?m_nImgThumbSampsPerLine:m_nImgThumbNumLines;\r\n\tnOrigThumbH = (m_eImgLandscape!=ENUM_LANDSCAPE_NO)?m_nImgThumbNumLines:m_nImgThumbSampsPerLine;\r\n\r\n\tteMaker eMaker;\r\n\teMaker = (m_bImgExifMakernotes)?ENUM_MAKER_PRESENT:ENUM_MAKER_NONE;\r\n\r\n\t// Sort sig additions\r\n\t// To create some determinism in the database, arrange the sigs\r\n\t// to be in numerical order\r\n\tCString strSig0,strSig1,strSigThm0,strSigThm1;\r\n\tif (m_strHash <= m_strHashRot) {\r\n\t\tstrSig0 = m_strHash;\r\n\t\tstrSig1 = m_strHashRot;\r\n\t} else {\r\n\t\tstrSig0 = m_strHashRot;\r\n\t\tstrSig1 = m_strHash;\r\n\t}\r\n\tif (m_strHashThumb <= m_strHashThumbRot) {\r\n\t\tstrSigThm0 = m_strHashThumb;\r\n\t\tstrSigThm1 = m_strHashThumbRot;\r\n\t} else {\r\n\t\tstrSigThm0 = m_strHashThumbRot;\r\n\t\tstrSigThm1 = m_strHashThumb;\r\n\t}\r\n\r\n\tSendSubmit(m_strImgExifMake,m_strImgExifModel,strQual,asDqt[0],asDqt[1],asDqt[2],asDqt[3],m_strImgQuantCss,\r\n\t\tstrSig0,strSig1,strSigThm0,strSigThm1,(float)m_adImgDqtQual[0],(float)m_adImgDqtQual[1],nOrigW,nOrigH,\r\n\t\tm_strSoftware,m_strComment,eMaker,eUserSource,strUserSoftware,m_strImgExtras,\r\n\t\tstrUserNotes,m_eImgLandscape,nOrigThumbW,nOrigThumbH);\r\n\r\n}\r\n\r\n\r\n// Send the compression signature string to the local database file\r\n// in addition to the web repository if the user has enabled it.\r\nvoid CjfifDecode::SendSubmit(CString strExifMake, CString strExifModel, CString strQual, \r\n\t\t\t\t\t\t\tCString strDqt0, CString strDqt1, CString strDqt2, CString strDqt3,\r\n\t\t\t\t\t\t\tCString strCss,\r\n\t\t\t\t\t\t\tCString strSig, CString strSigRot, CString strSigThumb, \r\n\t\t\t\t\t\t\tCString strSigThumbRot, float fQFact0, float fQFact1, unsigned nImgW, unsigned nImgH, \r\n\t\t\t\t\t\t\tCString strExifSoftware, CString strComment, teMaker eMaker,\r\n\t\t\t\t\t\t\tteSource eUserSource, CString strUserSoftware, CString strExtra,\r\n\t\t\t\t\t\t\tCString strUserNotes, unsigned nExifLandscape,\r\n\t\t\t\t\t\t\tunsigned nThumbX,unsigned nThumbY)\r\n{\r\n\t// NOTE: This assumes that we've already run PrepareSignature()\r\n\t// which usually happens when we process a file.\r\n\tASSERT(strSig != _T(\"\"));\r\n\tASSERT(strSigRot != _T(\"\"));\r\n\r\n\tCUrlString curls;\r\n\r\n\tCString DB_SUBMIT_WWW_VER = _T(\"02\");\r\n\r\n#ifndef BATCH_DO\r\n\tif (m_bSigExactInDB) {\r\n\t\tif (m_pAppConfig->bInteractive)\r\n\t\t\tAfxMessageBox(_T(\"Compression signature already in database\"));\r\n\t} else {\r\n\r\n\t\t// Now append it to the local database and resave\r\n\t\ttheApp.m_pDbSigs->DatabaseExtraAdd(strExifMake,strExifModel,\r\n\t\t\tstrQual,strSig,strSigRot,strCss,eUserSource,strUserSoftware);\r\n\r\n\t\tif (m_pAppConfig->bInteractive)\r\n\t\t\tAfxMessageBox(_T(\"Added Compression signature to database\"));\r\n\t}\r\n#endif\r\n\r\n\r\n\t// Is automatic internet update enabled?\r\n\tif (!theApp.m_pAppConfig->bDbSubmitNet) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tCString\t\tstrTmp;\r\n\r\n\tCString\t\tstrFormat;\r\n\tCString\t\tstrFormDataPre;\r\n\tCString\t\tstrFormData;\r\n\tunsigned\tnFormDataLen;\r\n\r\n\tunsigned\tnChecksum=32;\r\n\tCString\t\tstrSubmitHost;\r\n\tCString\t\tstrSubmitPage;\r\n\tstrSubmitHost = IA_HOST;\r\n\tstrSubmitPage = IA_DB_SUBMIT_PAGE;\r\n\tfor (unsigned i=0;i<_tcslen(IA_HOST);i++) {\r\n\t\tnChecksum += strSubmitHost.GetAt(i);\r\n\t\tnChecksum += 3*strSubmitPage.GetAt(i);\r\n\t}\r\n\r\n\t//if ( (m_pAppConfig->bIsWindowsNTorLater) && (nChecksum == 9678) ) {\r\n\tif (nChecksum == 9678) {\r\n\r\n\t\t// Submit to online database\r\n\t\tCString strHeaders =\r\n\t\t\t_T(\"Content-Type: application/x-www-form-urlencoded\");\r\n\t\t// URL-encoded form variables -\r\n\t\tstrFormat  = _T(\"ver=%s&x_make=%s&x_model=%s&strUmQual=%s&x_dqt0=%s&x_dqt1=%s&x_dqt2=%s&x_dqt3=%s\");\r\n\t\tstrFormat += _T(\"&strXSubsamp=%s&strCSig=%s&strCSigRot=%s&c_qfact0=%f&c_qfact1=%f&x_img_w=%u&x_img_h=%u\");\r\n\t\tstrFormat += _T(\"&x_sw=%s&x_com=%s&x_maker=%u&u_source=%d&u_sw=%s\");\r\n\t\tstrFormat += _T(\"&x_extra=%s&u_notes=%s&c_sigthumb=%s&c_sigthumbrot=%s&x_landscape=%u\");\r\n\t\tstrFormat += _T(\"&x_thumbx=%u&x_thumby=%u\");\r\n\r\n\r\n\t\tstrFormDataPre.Format(strFormat,\r\n\t\t\tDB_SUBMIT_WWW_VER,strExifMake,strExifModel,\r\n\t\t\tstrQual,strDqt0,strDqt1,strDqt2,strDqt3,strCss,strSig,strSigRot,fQFact0,fQFact1,nImgW,nImgH,\r\n\t\t\tstrExifSoftware,strComment,\r\n\t\t\teMaker,eUserSource,strUserSoftware,\r\n\t\t\tstrExtra,strUserNotes,\r\n\t\t\tstrSigThumb,strSigThumbRot,nExifLandscape,nThumbX,nThumbY);\r\n\r\n\t\t//*** Need to sanitize data for URL submission!\r\n\t\t// Search for \"&\", \"?\", \"=\"\r\n\t\tstrFormData.Format(strFormat,\r\n\t\t\tDB_SUBMIT_WWW_VER,curls.Encode(strExifMake),curls.Encode(strExifModel),\r\n\t\t\tstrQual,strDqt0,strDqt1,strDqt2,strDqt3,strCss,strSig,strSigRot,fQFact0,fQFact1,nImgW,nImgH,\r\n\t\t\tcurls.Encode(strExifSoftware),curls.Encode(strComment),\r\n\t\t\teMaker,eUserSource,curls.Encode(strUserSoftware),\r\n\t\t\tcurls.Encode(strExtra),curls.Encode(strUserNotes),\r\n\t\t\tstrSigThumb,strSigThumbRot,nExifLandscape,nThumbX,nThumbY);\r\n\t\tnFormDataLen = strFormData.GetLength();\r\n\r\n\r\n#ifdef DEBUG_SIG\r\n\t\tif (m_pAppConfig->bInteractive) {\r\n\t\t\tAfxMessageBox(strFormDataPre);\r\n\t\t\tAfxMessageBox(strFormData);\r\n\t\t}\r\n#endif\r\n\r\n#ifdef WWW_WININET\r\n\t\t//static LPSTR astrAcceptTypes[2]={\"*/*\", NULL};\r\n\t\tHINTERNET hINet, hConnection, hData;\r\n\r\n\t\thINet = InternetOpen(_T(\"JPEGsnoop/1.0\"), INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0 );\r\n\t\tif ( !hINet )\r\n\t\t{\r\n\t\t\tif (m_pAppConfig->bInteractive)\r\n\t\t\t\tAfxMessageBox(_T(\"InternetOpen Failed\"));\r\n\t\t\treturn;\r\n\t\t}\r\n\t\ttry\r\n\t\t{\r\n\t\t\thConnection = InternetConnect( hINet, (LPCTSTR)strSubmitHost, 80, NULL,NULL, INTERNET_SERVICE_HTTP, 0, 1 );\r\n\t\t\tif ( !hConnection )\r\n\t\t\t{\r\n\t\t\t\tInternetCloseHandle(hINet);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\thData = HttpOpenRequest( hConnection, _T(\"POST\"), (LPCTSTR)strSubmitPage, NULL, NULL, NULL, 0, 1 );\r\n\t\t\tif ( !hData )\r\n\t\t\t{\r\n\t\t\t\tInternetCloseHandle(hConnection);\r\n\t\t\t\tInternetCloseHandle(hINet);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t// GET HttpSendRequest( hData, NULL, 0, NULL, 0);\r\n\r\n\t\t\tHttpSendRequest( hData, (LPCTSTR)strHeaders, strHeaders.GetLength(), strFormData.GetBuffer(), strFormData.GetLength());\r\n\r\n\t\t}\r\n\t\tcatch( CInternetException* e)\r\n\t\t{\r\n\t\t\te->ReportError();\r\n\t\t\te->Delete();\r\n\t\t\t//AfxMessageBox(_T(\"EXCEPTION!\"));\r\n\t\t}\r\n\t\tInternetCloseHandle(hConnection);\r\n\t\tInternetCloseHandle(hINet);\r\n\t\tInternetCloseHandle(hData);\r\n#endif\r\n\r\n#ifdef WWW_WINHTTP\r\n\r\n\t\tCInternetSession\t\tsSession;\r\n\t\tCHttpConnection*\t\tpConnection;\r\n\t\tCHttpFile*\t\t\t\tpFile;\r\n\t\tBOOL\t\t\t\t\tbResult;\r\n\t\tDWORD\t\t\t\t\tdwRet;\r\n\r\n\t\t// *** NOTE: Will not work on Windows 95/98!\r\n\t\t// This section is avoided in early OSes otherwise we get an Illegal Op\r\n\t\ttry {\t\t\r\n\t\t\tpConnection = sSession.GetHttpConnection(submit_host);\r\n\t\t\tASSERT (pConnection);\r\n\t\t\tpFile = pConnection->OpenRequest(CHttpConnection::HTTP_VERB_POST,_T(submit_page));\r\n\t\t\tASSERT (pFile);\r\n\t\t\tbResult = pFile->SendRequest(\r\n\t\t\t\tstrHeaders,(LPVOID)(LPCTSTR)strFormData, strFormData.GetLength());\r\n\t\t\tASSERT (bResult != 0);\r\n\t\t\tpFile->QueryInfoStatusCode(dwRet);\r\n\t\t\tASSERT (dwRet == HTTP_STATUS_OK);\r\n\r\n\t\t\t// Clean up!\r\n\t\t\tif (pFile) {\r\n\t\t\t\tpFile->Close();\r\n\t\t\t\tdelete pFile;\r\n\t\t\t\tpFile = NULL;\r\n\t\t\t}\r\n\t\t\tif (pConnection) {\r\n\t\t\t\tpConnection->Close();\r\n\t\t\t\tdelete pConnection;\r\n\t\t\t\tpConnection = NULL;\r\n\t\t\t}\r\n\t\t\tsSession.Close();\r\n\r\n\t\t}\r\n\r\n\t\tcatch (CInternetException* pEx) \r\n\t\t{\r\n\t\t// catch any exceptions from WinINet      \r\n\t\t\tTCHAR szErr[MAX_BUF_EX_ERR_MSG];\r\n\t\t\tszErr[0] = '\\0';\r\n\t\t\tif(!pEx->GetErrorMessage(szErr, MAX_BUF_EX_ERR_MSG))\r\n\t\t\t\t_tcscpy(szErr,_T(\"Unknown error\"));\r\n\t\t\tTRACE(\"Submit Failed! - %s\",szErr);   \r\n\t\t\tif (m_pAppConfig->bInteractive)\r\n\t\t\t\tAfxMessageBox(szErr);\r\n\t\t\tpEx->Delete();\r\n\t\t\tif(pFile)\r\n\t\t\t\tdelete pFile;\r\n\t\t\tif(pConnection)\r\n\t\t\t\tdelete pConnection;\r\n\t\t\tsession.Close(); \r\n\t\t\treturn;\r\n\t\t}\r\n#endif\r\n\r\n\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n// Parse the embedded JPEG thumbnail. This routine is a much-reduced\r\n// version of the main JFIF parser, in that it focuses primarily on the\r\n// DQT tables.\r\nvoid CjfifDecode::DecodeEmbeddedThumb()\r\n{\r\n\tCString\t\tstrTmp;\r\n\tCString\t\tstrMarker;\r\n\tunsigned\tnPosSaved;\r\n\tunsigned\tnPosSaved_sof;\r\n\tunsigned\tnPosEnd;\r\n\tbool\t\tbDone;\r\n\tunsigned\tnCode;\r\n\tbool\t\tbRet;\r\n\r\n\tCString\t\tstrFull;\r\n\tunsigned\tnDqtPrecision_Pq;\r\n\tunsigned\tnDqtQuantDestId_Tq;\r\n\tunsigned\tnImgPrecision;\r\n\tunsigned\tnLength;\r\n\tunsigned\tnTmpVal;\r\n\tbool\t\tbScanSkipDone;\r\n\tbool\t\tbErrorAny = false;\r\n\tbool\t\tbErrorThumbLenZero = false;\r\n\tunsigned\tnSkipCount;\r\n\r\n\tnPosSaved = m_nPos;\r\n\r\n\t// Examine the EXIF embedded thumbnail (if it exists)\r\n\tif (m_nImgExifThumbComp == 6) {\r\n\t\tm_pLog->AddLine(_T(\"\"));\r\n\t\tm_pLog->AddLineHdr(_T(\"*** Embedded JPEG Thumbnail ***\"));\r\n\t\tstrTmp.Format(_T(\"  Offset: 0x%08X\"),m_nImgExifThumbOffset);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\t\tstrTmp.Format(_T(\"  Length: 0x%08X (%u)\"),m_nImgExifThumbLen,m_nImgExifThumbLen);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t// Quick scan for DQT tables\r\n\t\tm_nPos = m_nImgExifThumbOffset;\r\n\t\tbDone = false;\r\n\t\twhile (!bDone) {\r\n\r\n\t\t\t// For some reason, I have found files that have a nLength of 0\r\n\t\t\tif (m_nImgExifThumbLen != 0) {\r\n\t\t\t\tif ((m_nPos-m_nImgExifThumbOffset) > m_nImgExifThumbLen) {\r\n\t\t\t\t\tstrTmp.Format(_T(\"ERROR: Read more than specified EXIF thumb nLength (%u bytes) before EOI\"),m_nImgExifThumbLen);\r\n\t\t\t\t\tm_pLog->AddLineErr(strTmp);\r\n\t\t\t\t\tbErrorAny = true;\r\n\t\t\t\t\tbDone = true;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t// Don't try to process if nLength is 0!\r\n\t\t\t\t// Seen this in a Canon 1ds file (processed by photoshop)\r\n\t\t\t\tbDone = true;\r\n\t\t\t\tbErrorAny = true;\r\n\t\t\t\tbErrorThumbLenZero = true;\r\n\t\t\t}\r\n\t\t\tif ((!bDone) && (Buf(m_nPos++) != 0xFF)) {\r\n\t\t\t\tstrTmp.Format(_T(\"ERROR: Expected marker 0xFF, got 0x%02X @ offset 0x%08X\"),Buf(m_nPos-1),(m_nPos-1));\r\n\t\t\t\tm_pLog->AddLineErr(strTmp);\r\n\t\t\t\tbErrorAny = true;\r\n\t\t\t\tbDone = true;\r\n\r\n\t\t\t}\r\n\r\n\r\n\r\n\t\t\tif (!bDone) {\r\n\t\t\t\tnCode = Buf(m_nPos++);\r\n\r\n \t\t\t\tm_pLog->AddLine(_T(\"\"));\r\n\t\t\t\tswitch (nCode) {\r\n\t\t\t\t\tcase JFIF_SOI: // SOI\r\n\t\t\t\t\t\tm_pLog->AddLine(_T(\"  * Embedded Thumb Marker: SOI\")); \r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase JFIF_DQT:  // Define quantization tables\r\n\t\t\t\t\t\tm_pLog->AddLine(_T(\"  * Embedded Thumb Marker: DQT\")); \r\n\r\n\t\t\t\t\t\tnLength = Buf(m_nPos)*256 + Buf(m_nPos+1);\r\n\t\t\t\t\t\tnPosEnd = m_nPos+nLength;\r\n\t\t\t\t\t\tm_nPos+=2;\r\n\t\t\t\t\t\tstrTmp.Format(_T(\"    Length = %u\"),nLength); \r\n\t\t\t\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t\t\t\t\twhile (nPosEnd > m_nPos)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tstrTmp.Format(_T(\"    ----\"));\r\n\t\t\t\t\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t\t\t\t\t\tnTmpVal = Buf(m_nPos++);\r\n\t\t\t\t\t\t\tnDqtPrecision_Pq = (nTmpVal & 0xF0) >> 4;\r\n\t\t\t\t\t\t\tnDqtQuantDestId_Tq = nTmpVal & 0x0F;\r\n\t\t\t\t\t\t\tCString\tstrPrecision = _T(\"\");\r\n\t\t\t\t\t\t\tif (nDqtPrecision_Pq == 0) {\r\n\t\t\t\t\t\t\t\tstrPrecision = _T(\"8 bits\");\r\n\t\t\t\t\t\t\t} else if (nDqtPrecision_Pq == 1) {\r\n\t\t\t\t\t\t\t\tstrPrecision = _T(\"16 bits\");\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tstrPrecision.Format(_T(\"??? unknown [value=%u]\"),nDqtPrecision_Pq);\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tstrTmp.Format(_T(\"    Precision=%s\"),(LPCTSTR)strPrecision);\r\n\t\t\t\t\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t\t\t\t\t\tstrTmp.Format(_T(\"    Destination ID=%u\"),nDqtQuantDestId_Tq);\r\n\t\t\t\t\t\t\t// NOTE: The mapping between destination IDs and the actual\r\n\t\t\t\t\t\t\t// usage is defined in the SOF marker which is often later.\r\n\t\t\t\t\t\t\t// In nearly all images, the following is true. However, I have\r\n\t\t\t\t\t\t\t// seen some test images that set Tbl 3 = Lum, Tbl 0=Chr,\r\n\t\t\t\t\t\t\t// Tbl1=Chr, and Tbl2 undefined\r\n\t\t\t\t\t\t\tif (nDqtQuantDestId_Tq == 0) {\r\n\t\t\t\t\t\t\t\tstrTmp += _T(\" (Luminance, typically)\");\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse if (nDqtQuantDestId_Tq == 1) {\r\n\t\t\t\t\t\t\t\tstrTmp += _T(\" (Chrominance, typically)\");\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse if (nDqtQuantDestId_Tq == 2) {\r\n\t\t\t\t\t\t\t\tstrTmp += _T(\" (Chrominance, typically)\");\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\tstrTmp += _T(\" (???)\");\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\r\n\t\t\t\t\t\t\tif (nDqtQuantDestId_Tq >= 4) {\r\n\t\t\t\t\t\t\t\tstrTmp.Format(_T(\"ERROR: nDqtQuantDestId_Tq = %u, >= 4\"),nDqtQuantDestId_Tq);\r\n\t\t\t\t\t\t\t\tm_pLog->AddLineErr(strTmp);\r\n\t\t\t\t\t\t\t\tbDone = true;\r\n\t\t\t\t\t\t\t\tbErrorAny = true;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tfor (unsigned nInd=0;nInd<=63;nInd++)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tnTmpVal = Buf(m_nPos++);\r\n\t\t\t\t\t\t\t\tm_anImgThumbDqt[nDqtQuantDestId_Tq][glb_anZigZag[nInd]] = nTmpVal;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tm_abImgDqtThumbSet[nDqtQuantDestId_Tq] = true;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// Now display the table\r\n\t\t\t\t\t\t\tfor (unsigned nY=0;nY<8;nY++) {\r\n\t\t\t\t\t\t\t\tstrFull.Format(_T(\"      DQT, Row #%u: \"),nY);\r\n\t\t\t\t\t\t\t\tfor (unsigned nX=0;nX<8;nX++) {\r\n\t\t\t\t\t\t\t\t\tstrTmp.Format(_T(\"%3u \"),m_anImgThumbDqt[nDqtQuantDestId_Tq][nY*8+nX]);\r\n\t\t\t\t\t\t\t\t\tstrFull += strTmp;\r\n\r\n\t\t\t\t\t\t\t\t\t// Store the DQT entry into the Image DenCoder\r\n\t\t\t\t\t\t\t\t\tbRet = m_pImgDec->SetDqtEntry(nDqtQuantDestId_Tq,nY*8+nX,\r\n\t\t\t\t\t\t\t\t\t\tglb_anUnZigZag[nY*8+nX],m_anImgDqtTbl[nDqtQuantDestId_Tq][nY*8+nX]);\r\n\t\t\t\t\t\t\t\t\tDecodeErrCheck(bRet);\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tm_pLog->AddLine(strFull);\r\n\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase JFIF_SOF0:\r\n\t\t\t\t\t\tm_pLog->AddLine(_T(\"  * Embedded Thumb Marker: SOF\"));\r\n\t\t\t\t\t\tnLength = Buf(m_nPos)*256 + Buf(m_nPos+1);\r\n\t\t\t\t\t\tnPosSaved_sof = m_nPos;\r\n\t\t\t\t\t\tm_nPos+=2;\r\n\t\t\t\t\t\tstrTmp.Format(_T(\"    Frame header length = %u\"),nLength); \r\n\t\t\t\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\r\n\t\t\t\t\t\tnImgPrecision = Buf(m_nPos++);\r\n\t\t\t\t\t\tstrTmp.Format(_T(\"    Precision = %u\"),nImgPrecision);\r\n\t\t\t\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t\t\t\t\tm_nImgThumbNumLines = Buf(m_nPos)*256 + Buf(m_nPos+1);\r\n\t\t\t\t\t\tm_nPos += 2;\r\n\t\t\t\t\t\tstrTmp.Format(_T(\"    Number of Lines = %u\"),m_nImgThumbNumLines);\r\n\t\t\t\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t\t\t\t\tm_nImgThumbSampsPerLine = Buf(m_nPos)*256 + Buf(m_nPos+1);\r\n\t\t\t\t\t\tm_nPos += 2; \r\n\t\t\t\t\t\tstrTmp.Format(_T(\"    Samples per Line = %u\"),m_nImgThumbSampsPerLine);\r\n\t\t\t\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t\t\t\t\tstrTmp.Format(_T(\"    Image Size = %u x %u\"),m_nImgThumbSampsPerLine,m_nImgThumbNumLines);\r\n\t\t\t\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t\t\t\t\tm_nPos = nPosSaved_sof+nLength;\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase JFIF_SOS: // SOS\r\n\t\t\t\t\t\tm_pLog->AddLine(_T(\"  * Embedded Thumb Marker: SOS\"));\r\n\t\t\t\t\t\tm_pLog->AddLine(_T(\"    Skipping scan data\"));\r\n\t\t\t\t\t\tbScanSkipDone = false;\r\n\t\t\t\t\t\tnSkipCount = 0;\r\n\t\t\t\t\t\twhile (!bScanSkipDone) {\r\n\t\t\t\t\t\t\tif ((Buf(m_nPos) == 0xFF) && (Buf(m_nPos+1) != 0x00)) {\r\n\t\t\t\t\t\t\t\t// Was it a restart marker?\r\n\t\t\t\t\t\t\t\tif ((Buf(m_nPos+1) >= JFIF_RST0) && (Buf(m_nPos+1) <= JFIF_RST7)) {\r\n\t\t\t\t\t\t\t\t\tm_nPos++;\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t// No... it's a real marker\r\n\t\t\t\t\t\t\t\t\tbScanSkipDone = true;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tm_nPos++;\r\n\t\t\t\t\t\t\t\tnSkipCount++;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tstrTmp.Format(_T(\"    Skipped %u bytes\"),nSkipCount);\r\n\t\t\t\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase JFIF_EOI:\r\n\t\t\t\t\t\tm_pLog->AddLine(_T(\"  * Embedded Thumb Marker: EOI\")); \r\n\t\t\t\t\t\tbDone = true;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\tcase JFIF_RST0:\r\n\t\t\t\t\tcase JFIF_RST1:\r\n\t\t\t\t\tcase JFIF_RST2:\r\n\t\t\t\t\tcase JFIF_RST3:\r\n\t\t\t\t\tcase JFIF_RST4:\r\n\t\t\t\t\tcase JFIF_RST5:\r\n\t\t\t\t\tcase JFIF_RST6:\r\n\t\t\t\t\tcase JFIF_RST7:\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tGetMarkerName(nCode,strMarker);\r\n\t\t\t\t\t\tstrTmp.Format(_T(\"  * Embedded Thumb Marker: %s\"),(LPCTSTR)strMarker); \r\n\t\t\t\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t\t\t\t\tnLength = Buf(m_nPos)*256 + Buf(m_nPos+1);\r\n\t\t\t\t\t\tstrTmp.Format(_T(\"    Length = %u\"),nLength); \r\n\t\t\t\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t\t\t\t\tm_nPos += nLength;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\t\t\t} // if !bDone\r\n\t\t} // while !bDone\r\n\r\n\t\t// Now calculate the signature\r\n\t\tif (!bErrorAny) {\r\n\t\t\tPrepareSignatureThumb();\r\n\t\t\tm_pLog->AddLine(_T(\"\"));\r\n\t\t\tstrTmp.Format(_T(\"  * Embedded Thumb Signature: %s\"),(LPCTSTR)m_strHashThumb);\r\n\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t}\r\n\r\n\t\tif (bErrorThumbLenZero) {\r\n\t\t\tm_strHashThumb = _T(\"ERR: Len=0\");\r\n\t\t\tm_strHashThumbRot = _T(\"ERR: Len=0\");\r\n\t\t}\r\n\r\n\t} // if JPEG compressed\r\n\r\n\tm_nPos = nPosSaved;\r\n}\r\n\r\n\r\n// Lookup the EXIF marker name from the code value\r\nbool CjfifDecode::GetMarkerName(unsigned nCode,CString &markerStr)\r\n{\r\n\tbool\t\tbDone = false;\r\n\tbool\t\tbFound = false;\r\n\tunsigned\tnInd=0;\r\n\r\n\twhile (!bDone)\r\n\t{\r\n\t\tif (m_pMarkerNames[nInd].nCode==0) {\r\n\t\t\tbDone = true;\r\n\t\t} else if (m_pMarkerNames[nInd].nCode==nCode) {\r\n\t\t\tbDone = true;\r\n\t\t\tbFound = true;\r\n\t\t\tmarkerStr = m_pMarkerNames[nInd].strName;\r\n\t\t\treturn true;\r\n\t\t} else {\r\n\t\t\tnInd++;\r\n\t\t}\r\n\t}\r\n\tif (!bFound) {\r\n\t\tmarkerStr = _T(\"\");\r\n\t\tmarkerStr.Format(_T(\"(0xFF%02X)\"),nCode);\r\n\t\treturn false;\r\n\t}\r\n\treturn true;\r\n\r\n}\r\n\r\n\r\n// Determine if the file is an AVI MJPEG.\r\n// If so, parse the headers.\r\n// TODO: Expand this function to use sub-functions for each block type\r\nbool CjfifDecode::DecodeAvi()\r\n{\r\n\tCString\t\tstrTmp;\r\n\tunsigned\tnPosSaved;\r\n\r\n\tm_bAvi = false;\r\n\tm_bAviMjpeg = false;\r\n\r\n\t// Perhaps start from file position 0?\r\n\tnPosSaved = m_nPos;\r\n\r\n\t// Start from file position 0\r\n\tm_nPos = 0;\r\n\r\n\tbool\t\tbSwap = true;\r\n\r\n\tCString\t\tstrRiff;\r\n\tunsigned\tnRiffLen;\r\n\tCString\t\tstrForm;\r\n\r\n\tstrRiff = m_pWBuf->BufReadStrn(m_nPos,4); m_nPos+=4;\r\n\tnRiffLen = m_pWBuf->BufX(m_nPos,4,bSwap); m_nPos+=4;\r\n\tstrForm = m_pWBuf->BufReadStrn(m_nPos,4); m_nPos+=4;\r\n\tif ((strRiff == _T(\"RIFF\")) && (strForm == _T(\"AVI \"))) {\r\n\t\tm_bAvi = true;\r\n\t\tm_pLog->AddLine(_T(\"\"));\r\n\t\tm_pLog->AddLineHdr(_T(\"*** AVI File Decoding ***\"));\r\n\t\tm_pLog->AddLine(_T(\"Decoding RIFF AVI format...\"));\r\n\t\tm_pLog->AddLine(_T(\"\"));\r\n\t} else {\r\n\t\t// Reset file position\r\n\t\tm_nPos = nPosSaved;\r\n\t\treturn false;\r\n\t}\r\n\r\n\tCString\t\tstrHeader;\r\n\tunsigned\tnChunkSize;\r\n\tunsigned\tnChunkDataStart;\r\n\r\n\tbool\tdone = false;\r\n\twhile (!done) {\r\n\t\tif (m_nPos >= m_pWBuf->GetPosEof()) {\r\n\t\t\tdone = true;\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tstrHeader = m_pWBuf->BufReadStrn(m_nPos,4); m_nPos+=4;\r\n        strTmp.Format(_T(\"  %s\"),(LPCTSTR)strHeader);\r\n\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\tnChunkSize = m_pWBuf->BufX(m_nPos,4,bSwap); m_nPos+=4;\r\n\t\tnChunkDataStart = m_nPos;\r\n\r\n\r\n\t\tif (strHeader == _T(\"LIST\")) {\r\n\r\n\t\t\t// --- LIST ---\r\n\r\n\t\t\tCString strListType;\r\n\t\t\tstrListType = m_pWBuf->BufReadStrn(m_nPos,4); m_nPos+=4;\r\n\r\n\t\t\tstrTmp.Format(_T(\"    %s\"),(LPCTSTR)strListType);\r\n\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t\tif (strListType == _T(\"hdrl\")) {\r\n\r\n\t\t\t\t// --- hdrl ---\r\n\r\n\t\t\t\tunsigned nPosHdrlStart;\r\n\t\t\t\tCString strHdrlId;\r\n\t\t\t\tstrHdrlId = m_pWBuf->BufReadStrn(m_nPos,4); m_nPos+=4;\r\n\t\t\t\tunsigned nHdrlLen;\r\n\t\t\t\tnHdrlLen = m_pWBuf->BufX(m_nPos,4,bSwap); m_nPos+=4;\r\n\t\t\t\tnPosHdrlStart = m_nPos;\r\n\r\n\t\t\t\t// nHdrlLen should be 14*4 bytes\r\n\r\n\t\t\t\tm_nPos = nPosHdrlStart + nHdrlLen;\r\n\r\n\t\t\t} else if (strListType == _T(\"strl\")) {\r\n\r\n\t\t\t\t// --- strl ---\r\n\r\n\t\t\t\t// strhHEADER\r\n\t\t\t\tunsigned nPosStrlStart;\r\n\t\t\t\tCString strStrlId;\r\n\t\t\t\tstrStrlId = m_pWBuf->BufReadStrn(m_nPos,4); m_nPos+=4;\r\n\t\t\t\tunsigned nStrhLen;\r\n\t\t\t\tnStrhLen = m_pWBuf->BufX(m_nPos,4,bSwap); m_nPos+=4;\r\n\t\t\t\tnPosStrlStart = m_nPos;\r\n\r\n\t\t\t\tCString fccType;\r\n\t\t\t\tCString fccHandler;\r\n\t\t\t\tunsigned dwFlags,dwReserved1,dwInitialFrames,dwScale,dwRate;\r\n\t\t\t\tunsigned dwStart,dwLength,dwSuggestedBufferSize,dwQuality;\r\n\t\t\t\tunsigned dwSampleSize,xdwQuality,xdwSampleSize;\r\n\t\t\t\tfccType = m_pWBuf->BufReadStrn(m_nPos,4); m_nPos+=4;\r\n\t\t\t\tfccHandler = m_pWBuf->BufReadStrn(m_nPos,4); m_nPos+=4;\r\n\t\t\t\tdwFlags = m_pWBuf->BufX(m_nPos,4,bSwap); m_nPos+=4;\r\n\t\t\t\tdwReserved1 = m_pWBuf->BufX(m_nPos,4,bSwap); m_nPos+=4;\r\n\t\t\t\tdwInitialFrames = m_pWBuf->BufX(m_nPos,4,bSwap); m_nPos+=4;\r\n\t\t\t\tdwScale = m_pWBuf->BufX(m_nPos,4,bSwap); m_nPos+=4;\r\n\t\t\t\tdwRate = m_pWBuf->BufX(m_nPos,4,bSwap); m_nPos+=4;\r\n\t\t\t\tdwStart = m_pWBuf->BufX(m_nPos,4,bSwap); m_nPos+=4;\r\n\t\t\t\tdwLength = m_pWBuf->BufX(m_nPos,4,bSwap); m_nPos+=4;\r\n\t\t\t\tdwSuggestedBufferSize = m_pWBuf->BufX(m_nPos,4,bSwap); m_nPos+=4;\r\n\t\t\t\tdwQuality = m_pWBuf->BufX(m_nPos,4,bSwap); m_nPos+=4;\r\n\t\t\t\tdwSampleSize = m_pWBuf->BufX(m_nPos,4,bSwap); m_nPos+=4;\r\n\t\t\t\txdwQuality = m_pWBuf->BufX(m_nPos,4,bSwap); m_nPos+=4;\r\n\t\t\t\txdwSampleSize = m_pWBuf->BufX(m_nPos,4,bSwap); m_nPos+=4;\r\n\r\n\t\t\t\tCString fccTypeDecode = _T(\"\");\r\n\t\t\t\tif (fccType == _T(\"vids\")) { fccTypeDecode = _T(\"[vids] Video\"); }\r\n\t\t\t\telse if (fccType == _T(\"auds\")) { fccTypeDecode = _T(\"[auds] Audio\"); }\r\n\t\t\t\telse if (fccType == _T(\"txts\")) { fccTypeDecode = _T(\"[txts] Subtitle\"); }\r\n\t\t\t\telse { fccTypeDecode.Format(_T(\"[%s]\"),(LPCTSTR)fccType); } \r\n\t\t\t\tstrTmp.Format(_T(\"      -[FourCC Type]  = %s\"),(LPCTSTR)fccTypeDecode);\r\n\t\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t\t\tstrTmp.Format(_T(\"      -[FourCC Codec] = [%s]\"),(LPCTSTR)fccHandler);\r\n\t\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t\t\tfloat fSampleRate = 0;\r\n\t\t\t\tif (dwScale != 0) {\r\n\t\t\t\t\tfSampleRate = (float)dwRate / (float)dwScale;\r\n\t\t\t\t}\r\n\t\t\t\tstrTmp.Format(_T(\"      -[Sample Rate]  = [%.2f]\"),fSampleRate);\r\n\t\t\t\tif (fccType == _T(\"vids\")) { strTmp.Append(_T(\" frames/sec\")); }\r\n\t\t\t\telse if (fccType == _T(\"auds\")) { strTmp.Append(_T(\" samples/sec\")); }\r\n\t\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t\t\tm_nPos = nPosStrlStart + nStrhLen;\t// Skip\r\n\r\n\t\t\t\tstrTmp.Format(_T(\"      %s\"),(LPCTSTR)fccType);\r\n\t\t\t\tm_pLog->AddLine(strTmp);\r\n\r\n\t\t\t\tif (fccType == _T(\"vids\")) {\r\n\t\t\t\t\t// --- vids ---\r\n\r\n\t\t\t\t\t// Is it MJPEG?\r\n\t\t\t\t\t//strTmp.Format(_T(\"      -[Video Stream FourCC]=[%s]\"),fccHandler);\r\n\t\t\t\t\t//m_pLog->AddLine(strTmp);\r\n\t\t\t\t\tif (fccHandler == _T(\"mjpg\")) {\r\n\t\t\t\t\t\tm_bAviMjpeg = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (fccHandler == _T(\"MJPG\")) {\r\n\t\t\t\t\t\tm_bAviMjpeg = true;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// strfHEADER_BIH\r\n\t\t\t\t\tCString strSkipId;\r\n\t\t\t\t\tunsigned nSkipLen;\r\n\t\t\t\t\tunsigned nSkipStart;\r\n\t\t\t\t\tstrSkipId = m_pWBuf->BufReadStrn(m_nPos,4); m_nPos+=4;\r\n\t\t\t\t\tnSkipLen = m_pWBuf->BufX(m_nPos,4,bSwap); m_nPos+=4;\r\n\t\t\t\t\tnSkipStart = m_nPos;\r\n\t\t\t\t\t\r\n\t\t\t\t\tm_nPos = nSkipStart + nSkipLen; // Skip\r\n\r\n\t\t\t\t} else if (fccType == _T(\"auds\")) {\r\n\t\t\t\t\t// --- auds ---\r\n\r\n\t\t\t\t\t// strfHEADER_WAVE\r\n\r\n\t\t\t\t\tCString strSkipId;\r\n\t\t\t\t\tunsigned nSkipLen;\r\n\t\t\t\t\tunsigned nSkipStart;\r\n\t\t\t\t\tstrSkipId = m_pWBuf->BufReadStrn(m_nPos,4); m_nPos+=4;\r\n\t\t\t\t\tnSkipLen = m_pWBuf->BufX(m_nPos,4,bSwap); m_nPos+=4;\r\n\t\t\t\t\tnSkipStart = m_nPos;\r\n\t\t\t\t\t\r\n\t\t\t\t\tm_nPos = nSkipStart + nSkipLen; // Skip\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// strfHEADER\r\n\r\n\t\t\t\t\tCString strSkipId;\r\n\t\t\t\t\tunsigned nSkipLen;\r\n\t\t\t\t\tunsigned nSkipStart;\r\n\t\t\t\t\tstrSkipId = m_pWBuf->BufReadStrn(m_nPos,4); m_nPos+=4;\r\n\t\t\t\t\tnSkipLen = m_pWBuf->BufX(m_nPos,4,bSwap); m_nPos+=4;\r\n\t\t\t\t\tnSkipStart = m_nPos;\r\n\t\t\t\t\t\r\n\t\t\t\t\tm_nPos = nSkipStart + nSkipLen; // Skip\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// strnHEADER\r\n\t\t\t\tunsigned nPosStrnStart;\r\n\t\t\t\tCString strStrnId;\r\n\t\t\t\tstrStrnId = m_pWBuf->BufReadStrn(m_nPos,4); m_nPos+=4;\r\n\t\t\t\tunsigned nStrnLen;\r\n\t\t\t\tnStrnLen = m_pWBuf->BufX(m_nPos,4,bSwap); m_nPos+=4;\r\n\t\t\t\tnPosStrnStart = m_nPos;\r\n\r\n\t\t\t\t// FIXME: Can we rewrite in terms of ChunkSize and ChunkDataStart?\r\n\t\t\t\t//ASSERT ((nPosStrnStart + nStrnLen + (nStrnLen%2)) == (nChunkDataStart + nChunkSize + (nChunkSize%2)));\r\n\t\t\t\t//m_nPos = nChunkDataStart + nChunkSize + (nChunkSize%2);\r\n\t\t\t\tm_nPos = nPosStrnStart + nStrnLen + (nStrnLen%2); // Skip\r\n\r\n\t\t\t} else if (strListType == _T(\"movi\")) {\r\n\t\t\t\t// movi\r\n\r\n\t\t\t\tm_nPos = nChunkDataStart + nChunkSize + (nChunkSize%2);\r\n\t\t\t} else if (strListType == _T(\"INFO\")) {\r\n\t\t\t\t// INFO\r\n\t\t\t\tunsigned nInfoStart;\r\n\t\t\t\tnInfoStart = m_nPos;\r\n\r\n\t\t\t\tCString strInfoId;\r\n\t\t\t\tunsigned nInfoLen;\r\n\t\t\t\tstrInfoId = m_pWBuf->BufReadStrn(m_nPos,4); m_nPos+=4;\r\n\t\t\t\tnInfoLen = m_pWBuf->BufX(m_nPos,4,bSwap); m_nPos+=4;\r\n\r\n\t\t\t\tif (strInfoId == _T(\"ISFT\")) {\r\n\t\t\t\t\tCString strIsft=_T(\"\");\r\n\t\t\t\t\tstrIsft = m_pWBuf->BufReadStrn(m_nPos,nChunkSize);\r\n\t\t\t\t\tstrIsft.TrimRight();\r\n\t\t\t\t\tstrTmp.Format(_T(\"      -[Software] = [%s]\"),(LPCTSTR)strIsft);\r\n\t\t\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tm_nPos = nChunkDataStart + nChunkSize + (nChunkSize%2);\r\n\t\t\t} else {\r\n\t\t\t\t// ?\r\n\t\t\t\tm_nPos = nChunkDataStart + nChunkSize + (nChunkSize%2);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t} else if (strHeader == _T(\"JUNK\")) {\r\n\t\t\t// Junk\r\n\r\n\t\t\tm_nPos = nChunkDataStart + nChunkSize + (nChunkSize%2);\r\n\t\t} else if (strHeader == _T(\"IDIT\")) {\r\n\t\t\t// Timestamp info (Canon, etc.)\r\n\r\n\t\t\tCString strIditTimestamp=_T(\"\");\r\n\t\t\tstrIditTimestamp = m_pWBuf->BufReadStrn(m_nPos,nChunkSize);\r\n\t\t\tstrIditTimestamp.TrimRight();\r\n\t\t\tstrTmp.Format(_T(\"    -[Timestamp] = [%s]\"),(LPCTSTR)strIditTimestamp);\r\n\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t\r\n\t\t\tm_nPos = nChunkDataStart + nChunkSize + (nChunkSize%2);\r\n\r\n\t\t} else if (strHeader == _T(\"indx\")) {\r\n\t\t\t// Index\r\n\r\n\t\t\tm_nPos = nChunkDataStart + nChunkSize + (nChunkSize%2);\r\n\t\t} else if (strHeader == _T(\"idx1\")) {\r\n\t\t\t// Index\r\n\t\t\tunsigned nIdx1Entries = nChunkSize / (4*4);\r\n\r\n\t\t\tm_nPos = nChunkDataStart + nChunkSize + (nChunkSize%2);\r\n\r\n\t\t} else {\r\n\t\t\t// Unsupported\r\n\t\t\tm_nPos = nChunkDataStart + nChunkSize + (nChunkSize%2);\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tm_pLog->AddLine(_T(\"\"));\r\n\tif (m_bAviMjpeg) {\r\n\t\tm_strImgExtras += _T(\"[AVI]:[mjpg],\");\r\n\t\tm_pLog->AddLineGood(_T(\"  AVI is MotionJPEG\"));\r\n\t\tm_pLog->AddLineWarn(_T(\"  Use [Tools->Img Search Fwd] to locate next frame\"));\r\n\t} else {\r\n\t\tm_strImgExtras += _T(\"[AVI]:[????],\");\r\n\t\tm_pLog->AddLineWarn(_T(\"  AVI is not MotionJPEG. [Img Search Fwd/Rev] unlikely to find frames.\"));\r\n\t}\r\n\tm_pLog->AddLine(_T(\"\"));\r\n\r\n\t// Reset file position\r\n\tm_nPos = nPosSaved;\r\n\r\n\treturn m_bAviMjpeg;\r\n}\r\n\r\n\r\n\r\n// This is the primary JFIF parsing routine.\r\n// The main loop steps through all of the JFIF markers and calls\r\n// DecodeMarker() each time until we reach the end of file or an error.\r\n// Finally, we invoke the compression signature search function.\r\n//\r\n// Processing starts at the file offset m_pAppConfig->nPosStart\r\n//\r\n// INPUT:\r\n// - inFile\t\t\t\t\t\t= Input file pointer\r\n//\r\n// PRE:\r\n// - m_pAppConfig->nPosStart\t= Starting file offset for decode\r\n//\r\nvoid CjfifDecode::ProcessFile(CFile* inFile)\r\n{\r\n\r\n\tCString strTmp;\r\n\r\n\t// Reset the JFIF decoder state as we may be redoing another file\r\n\tReset();\r\n\r\n\t// Reset the IMG Decoder state\r\n\tif (m_pImgSrcDirty) {\r\n\t\tm_pImgDec->ResetState();\r\n\t}\r\n\r\n\t// Set the statusbar text to Processing...\r\n\r\n\t// Ensure the status bar has been allocated\r\n\t// NOTE: The stat bar is NULL if we drag & drop a file onto\r\n\t//       the JPEGsnoop app icon.\r\n\tif (m_pStatBar) {\r\n\t\tm_pStatBar->SetPaneText(0,_T(\"Processing...\"));\r\n\t}\r\n\r\n\r\n\t// Note that we don't clear out the logger (with m_pLog->Reset())\r\n\t// as we want top-level caller to do this. This way we can\r\n\t// still insert extra lines from top level.\r\n\r\n\t// GetLength returns ULONGLONG. Abort on large files (>=4GB)\r\n\tULONGLONG\tnPosFileEnd;\r\n\tnPosFileEnd = inFile->GetLength();\r\n\tif (nPosFileEnd > 0xFFFFFFFFUL) {\r\n\t\tCString strTmp = _T(\"File too large. Skipping.\");\r\n\t\tm_pLog->AddLineErr(strTmp);\r\n\t\tif (m_pAppConfig->bInteractive)\r\n\t\t\tAfxMessageBox(strTmp);\r\n\t\treturn;\r\n\t}\r\n\tm_nPosFileEnd = static_cast<unsigned long>(nPosFileEnd);\r\n\r\n\r\n\tunsigned nStartPos;\r\n\tnStartPos = m_pAppConfig->nPosStart;\r\n\tm_nPos = nStartPos;\r\n\tm_nPosEmbedStart = nStartPos;\t// Save the embedded file start position\r\n\r\n\tstrTmp.Format(_T(\"Start Offset: 0x%08X\"),nStartPos);\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\r\n\t// ----------------------------------------------------------------\r\n\r\n\t// Test for AVI file\r\n\t// - Detect header\r\n\t// - start from beginning of file\r\n\tDecodeAvi();\r\n\t// TODO: Should we skip decode of file if not MJPEG?\r\n\r\n\r\n\t// ----------------------------------------------------------------\r\n\r\n\t// Test for PSD file\r\n\t// - Detect header\r\n\t// - FIXME: start from current offset?\r\n\tunsigned\tnWidth=0;\r\n\tunsigned\tnHeight=0;\r\n\r\n#ifdef PS_IMG_DEC_EN\r\n\t// If PSD image decoding is enabled, associate the PSD parsing with\r\n\t// the current DIB. After decoding, flag the DIB as ready for display.\r\n\r\n\t// Attempt decode as PSD\r\n\tbool bDecPsdOk;\r\n\tbDecPsdOk = m_pPsDec->DecodePsd(nStartPos,&m_pImgDec->m_pDibTemp,nWidth,nHeight);\r\n\tif (bDecPsdOk) {\r\n\t\t// FIXME: The following is a bit of a hack\r\n\t\tm_pImgDec->m_bDibTempReady = true;\r\n\t\tm_pImgDec->m_bPreviewIsJpeg = false;\t\t\t// MCU/Block info not available\r\n\t\tm_pImgDec->SetImageDimensions(nWidth,nHeight);\r\n\r\n\t\t// Clear the image information\r\n\t\t// The primary reason for this is to ensure we don't have stale information from a previous\r\n\t\t// JPEG image (eg. real image border inside MCU border which would be overlayed during draw).\r\n\t\tm_pImgDec->SetImageDetails(0,0,0,0,false,0);\r\n\t\t\r\n\t\t// No more processing of file\r\n\t\t// - Otherwise we'd continue to attempt to decode as JPEG\r\n\t\treturn;\r\n\t}\r\n#else\r\n\t// Don't attempt to display Photoshop image data\r\n\tif (m_pPsDec->DecodePsd(nStartPos,NULL,nWidth,nHeight)) {\r\n\t\treturn;\r\n\t}\r\n#endif\r\n\r\n\r\n\t// ----------------------------------------------------------------\r\n\r\n// Disable DICOM for now until fully tested\r\n#ifdef SUPPORT_DICOM\r\n\t// Test for DICOM\r\n\t// - Detect header\r\n\t// - start from beginning of file\r\n\tbool\t\t\tbDicom = false;\r\n\tunsigned long\tnPosJpeg = 0;\t\t// File offset to embedded JPEG in DICOM\r\n\tbDicom = m_pDecDicom->DecodeDicom(0,m_nPosFileEnd,nPosJpeg);\r\n\tif (bDicom) {\r\n\t\t// Adjust start of JPEG decoding if we are currently without an offset\r\n\t\tif (nStartPos == 0) {\r\n\t\t\tm_pAppConfig->nPosStart = nPosJpeg;\r\n\r\n\t\t\tnStartPos = m_pAppConfig->nPosStart;\r\n\t\t\tm_nPos = nStartPos;\r\n\t\t\tm_nPosEmbedStart = nStartPos;\t// Save the embedded file start position\r\n\r\n\t\t\tstrTmp.Format(_T(\"Adjusting Start Offset to: 0x%08X\"),nStartPos);\r\n\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t\tm_pLog->AddLine(_T(\"\"));\r\n\t\t}\r\n\t}\r\n#endif\r\n\r\n\r\n\t// ----------------------------------------------------------------\r\n\r\n\t// Decode as JPEG JFIF file\r\n\r\n\t// If we are in a non-zero offset, add this to extras\r\n\tif (m_pAppConfig->nPosStart!=0) {\r\n\t\tstrTmp.Format(_T(\"[Offset]=[%lu],\"),m_pAppConfig->nPosStart);\r\n        m_strImgExtras += strTmp;\r\n\t}\r\n\r\n\tunsigned nDataAfterEof = 0;\r\n\r\n\tBOOL bDone = FALSE;\r\n\twhile (!bDone)\r\n\t{\r\n\t\t// Allow some other threads to jump in\r\n\r\n\t\t// Return value 0 - OK\r\n\t\t//              1 - Error\r\n\t\t//              2 - EOI\r\n\t\tif (DecodeMarker() != DECMARK_OK) {\r\n\t\t\tbDone = TRUE;\r\n\t\t\tif (m_nPosFileEnd >= m_nPosEoi) {\r\n\t\t\t\tnDataAfterEof = m_nPosFileEnd - m_nPosEoi;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (m_nPos > m_pWBuf->GetPosEof()) {\r\n\t\t\t\tm_pLog->AddLineErr(_T(\"ERROR: Early EOF - file may be missing EOI\"));\r\n\t\t\t\tbDone = TRUE;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// -----------------------------------------------------------\r\n\t// Perform any other informational calculations that require all tables\r\n\t// to be present.\r\n\r\n\t// Determine the CSS Ratio\r\n\t// Save the subsampling string. Assume component 2 is representative of the overall chrominance.\r\n\r\n\t// NOTE: Ensure that we don't execute the following code if we haven't\r\n\t//       completed our read (ie. get bad marker earlier in processing).\r\n\t// TODO: What is the best way to determine all is OK?\r\n\r\n\tm_strImgQuantCss = _T(\"?x?\");\r\n\tm_strHash = _T(\"NONE\");\r\n\tm_strHashRot = _T(\"NONE\");\r\n\r\n\tif (m_bImgOK) {\r\n\t\tASSERT(m_eImgLandscape!=ENUM_LANDSCAPE_UNSET);\r\n\r\n\t\tif (m_nSofNumComps_Nf == NUM_CHAN_YCC) {\r\n\t\t\t// We only try to determine the chroma subsampling ratio if we have 3 components (assume YCC)\r\n\t\t\t// In general, we should be able to use the 2nd or 3rd component\r\n\t\t\r\n\t\t\t// NOTE: The following assumes m_anSofHorzSampFact_Hi and m_anSofVertSampFact_Vi\r\n\t\t\t// are non-zero as otherwise we'll have a divide-by-0 exception.\r\n\t\t\tunsigned\tnCompIdent = m_anSofQuantCompId[SCAN_COMP_CB];\r\n\t\t\tunsigned\tnCssFactH = m_nSofHorzSampFactMax_Hmax/m_anSofHorzSampFact_Hi[nCompIdent];\r\n\t\t\tunsigned\tnCssFactV = m_nSofVertSampFactMax_Vmax/m_anSofVertSampFact_Vi[nCompIdent];\r\n\t\t\tif (m_eImgLandscape!=ENUM_LANDSCAPE_NO) {\r\n\t\t\t\t// Landscape orientation\r\n\t\t\t\tm_strImgQuantCss.Format(_T(\"%ux%u\"),nCssFactH,nCssFactV);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// Portrait orientation (flip subsampling ratio)\r\n\t\t\t\tm_strImgQuantCss.Format(_T(\"%ux%u\"),nCssFactV,nCssFactH);\r\n\t\t\t}\r\n\t\t} else if (m_nSofNumComps_Nf == NUM_CHAN_GRAYSCALE) {\r\n\t\t\tm_strImgQuantCss = _T(\"Gray\");\r\n\t\t}\r\n\r\n\t\tDecodeEmbeddedThumb();\r\n\r\n\t\t// Generate the signature\r\n\t\tPrepareSignature();\r\n\r\n\t\t// Compare compression signature\r\n\t\tif (m_pAppConfig->bSigSearch) {\r\n\t\t\t// In the case of lossless files, there won't be any DQT and\r\n\t\t\t// hence no compression signatures to compare. Therefore, skip this process.\r\n\t\t\tif (m_strHash == _T(\"NONE\")) {\r\n\t\t\t\tm_pLog->AddLineWarn(_T(\"Skipping compression signature search as no DQT\"));\r\n\t\t\t} else {\r\n\t\t\t\tCompareSignature();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (nDataAfterEof > 0) {\r\n\t\t\tm_pLog->AddLine(_T(\"\"));\r\n\t\t\tm_pLog->AddLineHdr(_T(\"*** Additional Info ***\"));\r\n\t\t\tstrTmp.Format(_T(\"NOTE: Data exists after EOF, range: 0x%08X-0x%08X (%u bytes)\"),\r\n\t\t\t\tm_nPosEoi,m_nPosFileEnd,nDataAfterEof);\r\n\t\t\tm_pLog->AddLine(strTmp);\r\n\t\t}\r\n\r\n\t\t// Print out the special-purpose outputs\r\n\t\tOutputSpecial();\r\n\t}\r\n\r\n\r\n\t// Reset the status bar text\r\n\tif (m_pStatBar) {\r\n\t\tm_pStatBar->SetPaneText(0,_T(\"Done\"));\r\n\t}\r\n\r\n\t// Mark the file as closed\r\n\t//m_pWBuf->BufFileUnset();\r\n\r\n}\r\n\r\n\r\n// Determine if the analyzed file is in a state ready for image\r\n// extraction. Confirms that the important JFIF markers have been\r\n// detected in the previous analysis.\r\n//\r\n// PRE:\r\n// - m_nPosEmbedStart\r\n// - m_nPosEmbedEnd\r\n// - m_nPosFileEnd \r\n//\r\n// RETURN:\r\n// - True if image is ready for extraction\r\n//\r\nbool CjfifDecode::ExportJpegPrepare(CString strFileIn,bool bForceSoi,bool bForceEoi,bool bIgnoreEoi)\r\n{\r\n\t// Extract from current file\r\n\t//   [m_nPosEmbedStart ... m_nPosEmbedEnd]\r\n\t// If state is valid (i.e. file opened)\r\n\r\n\tCString\t\tstrTmp = _T(\"\");\r\n\r\n\tm_pLog->AddLine(_T(\"\"));\r\n\tm_pLog->AddLineHdr(_T(\"*** Exporting JPEG ***\"));\r\n\r\n\tstrTmp.Format(_T(\"  Exporting from: [%s]\"),(LPCTSTR)strFileIn);\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\t// Only bother to extract if all main sections are present\r\n\tbool\t\tbExtractWarn = false;\r\n\tCString\t\tstrMissing = _T(\"\");\r\n\r\n\tif (!m_bStateEoi) {\r\n\t\tif (!bForceEoi && !bIgnoreEoi) {\r\n\t\t\tstrTmp.Format(_T(\"  ERROR: Missing marker: %s\"),_T(\"EOI\"));\r\n\t\t\tm_pLog->AddLineErr(strTmp);\r\n\t\t\tm_pLog->AddLineErr(_T(\"         Aborting export. Consider enabling [Force EOI] or [Ignore Missing EOI] option\"));\r\n\t\t\treturn false;\r\n\t\t} else if (bIgnoreEoi) {\r\n\t\t\t// Ignore the EOI, so mark the end of file, but don't\r\n\t\t\t// set the flag where we force one.\r\n\t\t\tm_nPosEmbedEnd = m_nPosFileEnd;\r\n\t\t} else {\r\n\t\t\t// We're missing the EOI but the user has requested\r\n\t\t\t// that we force an EOI, so let's fix things up\r\n\t\t\tm_nPosEmbedEnd = m_nPosFileEnd;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tif ((m_nPosEmbedStart == 0) && (m_nPosEmbedEnd == 0)) {\r\n\t\tstrTmp.Format(_T(\"  No frame found at this position in file. Consider using [Img Search]\"));\r\n\t\tm_pLog->AddLineErr(strTmp);\r\n\t\treturn false;\r\n\t}\r\n\r\n\tif (!m_bStateSoi) {\r\n\t\tif (!bForceSoi) {\r\n\t\t\tstrTmp.Format(_T(\"  ERROR: Missing marker: %s\"),_T(\"SOI\"));\r\n\t\t\tm_pLog->AddLineErr(strTmp);\r\n\t\t\tm_pLog->AddLineErr(_T(\"         Aborting export. Consider enabling [Force SOI] option\"));\r\n\t\t\treturn false;\r\n\t\t} else {\r\n\t\t\t// We're missing the SOI but the user has requested\r\n\t\t\t// that we force an SOI, so let's fix things up\r\n\t\t}\r\n\t\t\r\n\t}\r\n\tif (!m_bStateSos) {\r\n\t\tstrTmp.Format(_T(\"  ERROR: Missing marker: %s\"),_T(\"SOS\"));\r\n\t\tm_pLog->AddLineErr(strTmp);\r\n\t\tm_pLog->AddLineErr(_T(\"         Aborting export\"));\r\n\t\treturn false;\r\n\t}\r\n\r\n\tif (!m_bStateDqt) { bExtractWarn = true; strMissing += _T(\"DQT \"); }\r\n\tif (!m_bStateDht) { bExtractWarn = true; strMissing += _T(\"DHT \"); }\r\n\tif (!m_bStateSof) { bExtractWarn = true; strMissing += _T(\"SOF \"); }\r\n\t\r\n\tif (bExtractWarn) {\r\n\t\tstrTmp.Format(_T(\"  NOTE: Missing marker: %s\"),(LPCTSTR)strMissing);\r\n\t\tm_pLog->AddLineWarn(strTmp);\r\n\t\tm_pLog->AddLineWarn(_T(\"        Exported JPEG may not be valid\"));\r\n\t}\r\n\r\n\tif (m_nPosEmbedEnd < m_nPosEmbedStart) {\r\n\t\tstrTmp.Format(_T(\"ERROR: Invalid SOI-EOI order. Export aborted.\"));\r\n\t\tm_pLog->AddLineErr(strTmp);\r\n\t\tif (m_pAppConfig->bInteractive)\r\n\t\t\tAfxMessageBox(strTmp);\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\n\r\n\r\n#define EXPORT_BUF_SIZE 131072\r\n\r\n// Export the embedded JPEG image at the current position in the file (with overlays)\r\n// (may be the primary image or even an embedded thumbnail).\r\nbool CjfifDecode::ExportJpegDo(CString strFileIn, CString strFileOut, \r\n\t\t\tunsigned long nFileLen, bool bOverlayEn,bool bDhtAviInsert,bool bForceSoi,bool bForceEoi)\r\n{\r\n\tCFile*\t\tpFileOutput;\r\n\tCString\t\tstrTmp = _T(\"\");\r\n\r\n\tstrTmp.Format(_T(\"  Exporting to:   [%s]\"),(LPCTSTR)strFileOut);\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\tif (strFileIn == strFileOut) {\r\n\t\tstrTmp.Format(_T(\"ERROR: Can't overwrite source file. Aborting export.\"));\r\n\t\tm_pLog->AddLineErr(strTmp);\r\n\t\tif (m_pAppConfig->bInteractive)\r\n\t\t\tAfxMessageBox(strTmp);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tASSERT(strFileIn != _T(\"\"));\r\n\tif (strFileIn == _T(\"\")) {\r\n\t\tstrTmp.Format(_T(\"ERROR: Export but source filename empty\"));\r\n\t\tm_pLog->AddLineErr(strTmp);\r\n\t\tif (m_pAppConfig->bInteractive)\r\n\t\t\tAfxMessageBox(strTmp);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\r\n\r\n\ttry\r\n\t{\r\n\t\t// Open specified file\r\n\t\t// Added in shareDenyNone as this apparently helps resolve some people's troubles\r\n\t\t// with an error showing: Couldn't open file \"Sharing Violation\"\r\n\t\tpFileOutput = new CFile(strFileOut, CFile::modeCreate| CFile::modeWrite | CFile::typeBinary | CFile::shareDenyNone);\r\n\t}\r\n\tcatch (CFileException* e)\r\n\t{\r\n\t\tTCHAR msg[MAX_BUF_EX_ERR_MSG];\r\n\t\tCString strError;\r\n\t\te->GetErrorMessage(msg,MAX_BUF_EX_ERR_MSG);\r\n\t\te->Delete();\r\n\t\tstrError.Format(_T(\"ERROR: Couldn't open file for write [%s]: [%s]\"),\r\n\t\t\t(LPCTSTR)strFileOut, (LPCTSTR)msg);\r\n\t\tm_pLog->AddLineErr(strError);\r\n\t\tif (m_pAppConfig->bInteractive)\r\n\t\t\tAfxMessageBox(strError);\r\n\t\tpFileOutput = NULL;\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n\t// Don't attempt to load buffer with zero length file!\r\n\tif (nFileLen==0) {\r\n\t\tstrTmp.Format(_T(\"ERROR: Source file length error. Please Reprocess first.\"));\r\n\t\tm_pLog->AddLineErr(strTmp);\r\n\t\tif (m_pAppConfig->bInteractive)\r\n\t\t\tAfxMessageBox(strTmp);\r\n\r\n\t\tif (pFileOutput) { delete pFileOutput; pFileOutput = NULL; }\r\n\t\treturn false;\r\n\t}\r\n\r\n\r\n\t// Need to insert fake DHT. Assume we have enough buffer allocated.\r\n\t//\r\n\t// Step 1: Copy from SOI -> SOS (not incl)\r\n\t// Step 2: Insert Fake DHT\r\n\t// Step 3: Copy from SOS -> EOI\r\n\tunsigned\t\tnCopyStart;\r\n\tunsigned\t\tnCopyEnd;\r\n\tunsigned\t\tnCopyLeft;\r\n\tunsigned\t\tind;\r\n\r\n\tBYTE*\t\t\tpBuf;\r\n\r\n\tpBuf = new BYTE[EXPORT_BUF_SIZE+10];\r\n\tif (!pBuf) {\r\n\t\tif (pFileOutput) { delete pFileOutput; pFileOutput = NULL; }\r\n\t\treturn false;\r\n\t}\r\n\r\n\r\n\r\n\t// Step 1\r\n\r\n\t// If we need to force an SOI, do it now\r\n\tif (!m_bStateSoi && bForceSoi) {\r\n\t\tm_pLog->AddLine(_T(\"    Forcing SOI Marker\"));\r\n\t\tBYTE\tanBufSoi[2] = {0xFF,JFIF_SOI};\r\n\t\tpFileOutput->Write(&anBufSoi,2);\r\n\t}\r\n\r\n\tnCopyStart = m_nPosEmbedStart;\r\n\tnCopyEnd   = (m_nPosSos-1);\r\n\tind = nCopyStart;\r\n\twhile (ind<nCopyEnd) {\r\n\t\tnCopyLeft = nCopyEnd-ind+1;\r\n\t\tif (nCopyLeft>EXPORT_BUF_SIZE) { nCopyLeft = EXPORT_BUF_SIZE; }\r\n\t\tfor (unsigned ind1=0;ind1<nCopyLeft;ind1++) {\r\n\t\t\tpBuf[ind1] = Buf(ind+ind1,!bOverlayEn);\r\n\t\t}\r\n\t\tpFileOutput->Write(pBuf,nCopyLeft);\r\n\t\tind += nCopyLeft;\r\n\t\t// NOTE: We ensure nFileLen != 0 earlier\r\n\t\tASSERT(nFileLen>0);\r\n\t\tstrTmp.Format(_T(\"Exporting %3u%%...\"),ind*100/nFileLen);\r\n\t\tSetStatusText(strTmp);\r\n\t}\r\n\r\n\r\n\r\n\tif (bDhtAviInsert) {\r\n\t\t// Step 2. The following struct includes the JFIF marker too\r\n\t\tstrTmp.Format(_T(\"  Inserting standard AVI DHT huffman table\"));\r\n\t\tm_pLog->AddLine(strTmp);\r\n\t\tpFileOutput->Write(m_abMJPGDHTSeg,JFIF_DHT_FAKE_SZ);\r\n\t}\r\n\r\n\t// Step 3\r\n\tnCopyStart = m_nPosSos;\r\n\tnCopyEnd   = m_nPosEmbedEnd-1;\r\n\tind = nCopyStart;\r\n\twhile (ind<nCopyEnd) {\r\n\t\tnCopyLeft = nCopyEnd-ind+1;\r\n\t\tif (nCopyLeft>EXPORT_BUF_SIZE) { nCopyLeft = EXPORT_BUF_SIZE; }\r\n\t\tfor (unsigned ind1=0;ind1<nCopyLeft;ind1++) {\r\n\t\t\tpBuf[ind1] = Buf(ind+ind1,!bOverlayEn);\r\n\t\t}\r\n\t\tpFileOutput->Write(pBuf,nCopyLeft);\r\n\t\tind += nCopyLeft;\r\n\t\t// NOTE: We ensure nFileLen != 0 earlier\r\n\t\tASSERT(nFileLen>0);\r\n\t\tstrTmp.Format(_T(\"Exporting %3u%%...\"),ind*100/nFileLen);\r\n\t\tSetStatusText(strTmp);\r\n\t}\r\n\r\n\t// Now optionally insert the EOI Marker\r\n\tif (bForceEoi) {\r\n\t\tm_pLog->AddLine(_T(\"    Forcing EOI Marker\"));\r\n\t\tBYTE\tanBufEoi[2] = {0xFF,JFIF_EOI};\r\n\t\tpFileOutput->Write(&anBufEoi,2);\r\n\t}\r\n\r\n\r\n\t// Free up space\r\n\tpFileOutput->Close();\r\n\r\n\tif (pBuf) {\r\n\t\tdelete [] pBuf;\r\n\t\tpBuf = NULL;\r\n\t}\r\n\r\n\tif (pFileOutput) {\r\n\t\tdelete pFileOutput;\r\n\t\tpFileOutput = NULL;\r\n\t}\r\n\r\n\tSetStatusText(_T(\"\"));\r\n\tstrTmp.Format(_T(\"  Export done\"));\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\treturn true;\r\n}\r\n\r\n\r\n// Export a subset of the file with no overlays or mods\r\nbool CjfifDecode::ExportJpegDoRange(CString strFileIn, CString strFileOut, \r\n\t\t\tunsigned long nStart, unsigned long nEnd)\r\n{\r\n\tCFile*\t\tpFileOutput;\r\n\tCString\t\tstrTmp = _T(\"\");\r\n\r\n\tstrTmp.Format(_T(\"  Exporting range to:   [%s]\"),(LPCTSTR)strFileOut);\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\tif (strFileIn == strFileOut) {\r\n\t\tstrTmp.Format(_T(\"ERROR: Can't overwrite source file. Aborting export.\"));\r\n\t\tm_pLog->AddLineErr(strTmp);\r\n\t\tif (m_pAppConfig->bInteractive)\r\n\t\t\tAfxMessageBox(strTmp);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tASSERT(strFileIn != _T(\"\"));\r\n\tif (strFileIn == _T(\"\")) {\r\n\t\tstrTmp.Format(_T(\"ERROR: Export but source filename empty\"));\r\n\t\tm_pLog->AddLineErr(strTmp);\r\n\t\tif (m_pAppConfig->bInteractive)\r\n\t\t\tAfxMessageBox(strTmp);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\r\n\r\n\ttry\r\n\t{\r\n\t\t// Open specified file\r\n\t\t// Added in shareDenyNone as this apparently helps resolve some people's troubles\r\n\t\t// with an error showing: Couldn't open file \"Sharing Violation\"\r\n\t\tpFileOutput = new CFile(strFileOut, CFile::modeCreate| CFile::modeWrite | CFile::typeBinary | CFile::shareDenyNone);\r\n\t}\r\n\tcatch (CFileException* e)\r\n\t{\r\n\t\tTCHAR msg[MAX_BUF_EX_ERR_MSG];\r\n\t\tCString strError;\r\n\t\te->GetErrorMessage(msg,MAX_BUF_EX_ERR_MSG);\r\n\t\te->Delete();\r\n\t\tstrError.Format(_T(\"ERROR: Couldn't open file for write [%s]: [%s]\"),\r\n\t\t\t(LPCTSTR)strFileOut, (LPCTSTR)msg);\r\n\t\tm_pLog->AddLineErr(strError);\r\n\t\tif (m_pAppConfig->bInteractive)\r\n\t\t\tAfxMessageBox(strError);\r\n\t\tpFileOutput = NULL;\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n\r\n\tunsigned\t\tnCopyStart;\r\n\tunsigned\t\tnCopyEnd;\r\n\tunsigned\t\tnCopyLeft;\r\n\tunsigned\t\tind;\r\n\r\n\tBYTE*\t\t\tpBuf;\r\n\r\n\tpBuf = new BYTE[EXPORT_BUF_SIZE+10];\r\n\tif (!pBuf) {\r\n\t\tif (pFileOutput) { delete pFileOutput; pFileOutput = NULL; }\r\n\t\treturn false;\r\n\t}\r\n\r\n\r\n\r\n\t// Step 1\r\n\tnCopyStart = nStart;\r\n\tnCopyEnd   = nEnd;\r\n\tind = nCopyStart;\r\n\twhile (ind<nCopyEnd) {\r\n\t\tnCopyLeft = nCopyEnd-ind+1;\r\n\t\tif (nCopyLeft>EXPORT_BUF_SIZE) { nCopyLeft = EXPORT_BUF_SIZE; }\r\n\t\tfor (unsigned ind1=0;ind1<nCopyLeft;ind1++) {\r\n\t\t\tpBuf[ind1] = Buf(ind+ind1,false);\r\n\t\t}\r\n\t\tpFileOutput->Write(pBuf,nCopyLeft);\r\n\t\tind += nCopyLeft;\r\n\t\tstrTmp.Format(_T(\"Exporting %3u%%...\"),ind*100/(nCopyEnd-nCopyStart));\r\n\t\tSetStatusText(strTmp);\r\n\t}\r\n\r\n\r\n\t// Free up space\r\n\tpFileOutput->Close();\r\n\r\n\tif (pBuf) {\r\n\t\tdelete [] pBuf;\r\n\t\tpBuf = NULL;\r\n\t}\r\n\r\n\tif (pFileOutput) {\r\n\t\tdelete pFileOutput;\r\n\t\tpFileOutput = NULL;\r\n\t}\r\n\r\n\tSetStatusText(_T(\"\"));\r\n\tstrTmp.Format(_T(\"  Export range done\"));\r\n\tm_pLog->AddLine(strTmp);\r\n\r\n\treturn true;\r\n}\r\n\r\n\r\n// ====================================================================================\r\n// JFIF Decoder Constants\r\n// ====================================================================================\r\n\r\n// List of the JFIF markers\r\nconst MarkerNameTable CjfifDecode::m_pMarkerNames[] = {\r\n\t{JFIF_SOF0,_T(\"SOF0\")},\r\n\t{JFIF_SOF1,_T(\"SOF1\")},\r\n\t{JFIF_SOF2,_T(\"SOF2\")},\r\n\t{JFIF_SOF3,_T(\"SOF3\")},\r\n\t{JFIF_SOF5,_T(\"SOF5\")},\r\n\t{JFIF_SOF6,_T(\"SOF6\")},\r\n\t{JFIF_SOF7,_T(\"SOF7\")},\r\n\t{JFIF_JPG,_T(\"JPG\")},\r\n\t{JFIF_SOF9,_T(\"SOF9\")},\r\n\t{JFIF_SOF10,_T(\"SOF10\")},\r\n\t{JFIF_SOF11,_T(\"SOF11\")},\r\n\t{JFIF_SOF13,_T(\"SOF13\")},\r\n\t{JFIF_SOF14,_T(\"SOF14\")},\r\n\t{JFIF_SOF15,_T(\"SOF15\")},\r\n\t{JFIF_DHT,_T(\"DHT\")},\r\n\t{JFIF_DAC,_T(\"DAC\")},\r\n\t{JFIF_RST0,_T(\"RST0\")},\r\n\t{JFIF_RST1,_T(\"RST1\")},\r\n\t{JFIF_RST2,_T(\"RST2\")},\r\n\t{JFIF_RST3,_T(\"RST3\")},\r\n\t{JFIF_RST4,_T(\"RST4\")},\r\n\t{JFIF_RST5,_T(\"RST5\")},\r\n\t{JFIF_RST6,_T(\"RST6\")},\r\n\t{JFIF_RST7,_T(\"RST7\")},\r\n\t{JFIF_SOI,_T(\"SOI\")},\r\n\t{JFIF_EOI,_T(\"EOI\")},\r\n\t{JFIF_SOS,_T(\"SOS\")},\r\n\t{JFIF_DQT,_T(\"DQT\")},\r\n\t{JFIF_DNL,_T(\"DNL\")},\r\n\t{JFIF_DRI,_T(\"DRI\")},\r\n\t{JFIF_DHP,_T(\"DHP\")},\r\n\t{JFIF_EXP,_T(\"EXP\")},\r\n\t{JFIF_APP0,_T(\"APP0\")},\r\n\t{JFIF_APP1,_T(\"APP1\")},\r\n\t{JFIF_APP2,_T(\"APP2\")},\r\n\t{JFIF_APP3,_T(\"APP3\")},\r\n\t{JFIF_APP4,_T(\"APP4\")},\r\n\t{JFIF_APP5,_T(\"APP5\")},\r\n\t{JFIF_APP6,_T(\"APP6\")},\r\n\t{JFIF_APP7,_T(\"APP7\")},\r\n\t{JFIF_APP8,_T(\"APP8\")},\r\n\t{JFIF_APP9,_T(\"APP9\")},\r\n\t{JFIF_APP10,_T(\"APP10\")},\r\n\t{JFIF_APP11,_T(\"APP11\")},\r\n\t{JFIF_APP12,_T(\"APP12\")},\r\n\t{JFIF_APP13,_T(\"APP13\")},\r\n\t{JFIF_APP14,_T(\"APP14\")},\r\n\t{JFIF_APP15,_T(\"APP15\")},\r\n\t{JFIF_JPG0,_T(\"JPG0\")},\r\n\t{JFIF_JPG1,_T(\"JPG1\")},\r\n\t{JFIF_JPG2,_T(\"JPG2\")},\r\n\t{JFIF_JPG3,_T(\"JPG3\")},\r\n\t{JFIF_JPG4,_T(\"JPG4\")},\r\n\t{JFIF_JPG5,_T(\"JPG5\")},\r\n\t{JFIF_JPG6,_T(\"JPG6\")},\r\n\t{JFIF_JPG7,_T(\"JPG7\")},\r\n\t{JFIF_JPG8,_T(\"JPG8\")},\r\n\t{JFIF_JPG9,_T(\"JPG9\")},\r\n\t{JFIF_JPG10,_T(\"JPG10\")},\r\n\t{JFIF_JPG11,_T(\"JPG11\")},\r\n\t{JFIF_JPG12,_T(\"JPG12\")},\r\n\t{JFIF_JPG13,_T(\"JPG13\")},\r\n\t{JFIF_COM,_T(\"COM\")},\r\n\t{JFIF_TEM,_T(\"TEM\")},\r\n\t//{JFIF_RES*,_T(\"RES\")},\r\n\t{0x00,_T(\"*\")},\r\n};\r\n\r\n\r\n// For Motion JPEG, define the DHT tables that we use since they won't exist\r\n// in each frame within the AVI. This table will be read in during\r\n// DecodeDHT()'s call to Buf().\r\nconst BYTE CjfifDecode::m_abMJPGDHTSeg[JFIF_DHT_FAKE_SZ] = {\r\n\t/* JPEG DHT Segment for YCrCb omitted from MJPG data */\r\n\t0xFF,0xC4,0x01,0xA2,\r\n\t\t0x00,0x00,0x01,0x05,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\r\n\t\t0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x01,0x00,0x03,0x01,0x01,0x01,0x01,\r\n\t\t0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,\r\n\t\t0x08,0x09,0x0A,0x0B,0x10,0x00,0x02,0x01,0x03,0x03,0x02,0x04,0x03,0x05,0x05,0x04,0x04,0x00,\r\n\t\t0x00,0x01,0x7D,0x01,0x02,0x03,0x00,0x04,0x11,0x05,0x12,0x21,0x31,0x41,0x06,0x13,0x51,0x61,\r\n\t\t0x07,0x22,0x71,0x14,0x32,0x81,0x91,0xA1,0x08,0x23,0x42,0xB1,0xC1,0x15,0x52,0xD1,0xF0,0x24,\r\n\t\t0x33,0x62,0x72,0x82,0x09,0x0A,0x16,0x17,0x18,0x19,0x1A,0x25,0x26,0x27,0x28,0x29,0x2A,0x34,\r\n\t\t0x35,0x36,0x37,0x38,0x39,0x3A,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4A,0x53,0x54,0x55,0x56,\r\n\t\t0x57,0x58,0x59,0x5A,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x73,0x74,0x75,0x76,0x77,0x78,\r\n\t\t0x79,0x7A,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,\r\n\t\t0x9A,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,\r\n\t\t0xBA,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,\r\n\t\t0xDA,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,\r\n\t\t0xF8,0xF9,0xFA,0x11,0x00,0x02,0x01,0x02,0x04,0x04,0x03,0x04,0x07,0x05,0x04,0x04,0x00,0x01,\r\n\t\t0x02,0x77,0x00,0x01,0x02,0x03,0x11,0x04,0x05,0x21,0x31,0x06,0x12,0x41,0x51,0x07,0x61,0x71,\r\n\t\t0x13,0x22,0x32,0x81,0x08,0x14,0x42,0x91,0xA1,0xB1,0xC1,0x09,0x23,0x33,0x52,0xF0,0x15,0x62,\r\n\t\t0x72,0xD1,0x0A,0x16,0x24,0x34,0xE1,0x25,0xF1,0x17,0x18,0x19,0x1A,0x26,0x27,0x28,0x29,0x2A,\r\n\t\t0x35,0x36,0x37,0x38,0x39,0x3A,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4A,0x53,0x54,0x55,0x56,\r\n\t\t0x57,0x58,0x59,0x5A,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x73,0x74,0x75,0x76,0x77,0x78,\r\n\t\t0x79,0x7A,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x92,0x93,0x94,0x95,0x96,0x97,0x98,\r\n\t\t0x99,0x9A,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,\r\n\t\t0xB9,0xBA,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,\r\n\t\t0xD9,0xDA,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,\r\n\t\t0xF9,0xFA\r\n};\r\n\r\n\r\n\r\n// TODO: Add ITU-T Example DQT & DHT\r\n//       These will be useful for GeoRaster decode (ie. JPEG-B)\r\n\r\nCString\t\tglb_strMsgStopDecode = _T(\"  Stopping decode. Use [Relaxed Parsing] to continue.\");"], "filenames": ["JfifDecode.cpp"], "buggy_code_start_loc": [2], "buggy_code_end_loc": [4908], "fixing_code_start_loc": [2], "fixing_code_end_loc": [4908], "type": "CWE-369", "message": "ImpulseAdventure JPEGsnoop version 1.7.5 is vulnerable to a division by zero in the JFIF decode handling resulting denial of service.", "other": {"cve": {"id": "CVE-2017-1000414", "sourceIdentifier": "cve@mitre.org", "published": "2018-01-25T16:29:00.213", "lastModified": "2018-02-08T16:17:58.727", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ImpulseAdventure JPEGsnoop version 1.7.5 is vulnerable to a division by zero in the JFIF decode handling resulting denial of service."}, {"lang": "es", "value": "ImpulseAdventure JPEGsnoop 1.7.5 es vulnerable a divisi\u00f3n entre cero en la manipulaci\u00f3n de decodificaciones JFIF, resultando en una denegaci\u00f3n de servicio (DoS)."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-369"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:impulseadventure:jpegsnoop:1.7.5:*:*:*:*:*:*:*", "matchCriteriaId": "A393CE22-6177-4114-948A-DE013C447574"}]}]}], "references": [{"url": "https://github.com/ImpulseAdventure/JPEGsnoop/commit/b4e458612d4294e0cfe01dbf1c0b09a07a8133a4#diff-cf9182aecc9d630e8db2e0e35f1eec65", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://www.impulseadventure.com/photo/jpeg-snoop-history.html", "source": "cve@mitre.org", "tags": ["Release Notes"]}]}, "github_commit_url": "https://github.com/ImpulseAdventure/JPEGsnoop/commit/b4e458612d4294e0cfe01dbf1c0b09a07a8133a4#diff-cf9182aecc9d630e8db2e0e35f1eec65"}}