{"buggy_code": ["/*\n * The copyright in this software is being made available under the 2-clauses \n * BSD License, included below. This software may be subject to other third \n * party and contributor rights, including patent rights, and no such rights\n * are granted under this license.\n *\n * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium\n * Copyright (c) 2002-2014, Professor Benoit Macq\n * Copyright (c) 2001-2003, David Janssens\n * Copyright (c) 2002-2003, Yannick Verschueren\n * Copyright (c) 2003-2007, Francois-Olivier Devaux \n * Copyright (c) 2003-2014, Antonin Descampe\n * Copyright (c) 2005, Herve Drolon, FreeImage Team\n * Copyright (c) 2006-2007, Parvatha Elangovan\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"opj_includes.h\"\n\n/** @defgroup PI PI - Implementation of a packet iterator */\n/*@{*/\n\n/** @name Local static functions */\n/*@{*/\n\n/**\nGet next packet in layer-resolution-component-precinct order.\n@param pi packet iterator to modify\n@return returns false if pi pointed to the last packet or else returns true\n*/\nstatic OPJ_BOOL opj_pi_next_lrcp(opj_pi_iterator_t * pi);\n/**\nGet next packet in resolution-layer-component-precinct order.\n@param pi packet iterator to modify\n@return returns false if pi pointed to the last packet or else returns true\n*/\nstatic OPJ_BOOL opj_pi_next_rlcp(opj_pi_iterator_t * pi);\n/**\nGet next packet in resolution-precinct-component-layer order.\n@param pi packet iterator to modify\n@return returns false if pi pointed to the last packet or else returns true\n*/\nstatic OPJ_BOOL opj_pi_next_rpcl(opj_pi_iterator_t * pi);\n/**\nGet next packet in precinct-component-resolution-layer order.\n@param pi packet iterator to modify\n@return returns false if pi pointed to the last packet or else returns true\n*/\nstatic OPJ_BOOL opj_pi_next_pcrl(opj_pi_iterator_t * pi);\n/**\nGet next packet in component-precinct-resolution-layer order.\n@param pi packet iterator to modify\n@return returns false if pi pointed to the last packet or else returns true\n*/\nstatic OPJ_BOOL opj_pi_next_cprl(opj_pi_iterator_t * pi);\n\n/**\n * Updates the coding parameters if the encoding is used with Progression order changes and final (or cinema parameters are used).\n *\n * @param\tp_cp\t\tthe coding parameters to modify\n * @param\tp_tileno\tthe tile index being concerned.\n * @param\tp_tx0\t\tX0 parameter for the tile\n * @param\tp_tx1\t\tX1 parameter for the tile\n * @param\tp_ty0\t\tY0 parameter for the tile\n * @param\tp_ty1\t\tY1 parameter for the tile\n * @param\tp_max_prec\tthe maximum precision for all the bands of the tile\n * @param\tp_max_res\tthe maximum number of resolutions for all the poc inside the tile.\n * @param\tp_dx_min\t\tthe minimum dx of all the components of all the resolutions for the tile.\n * @param\tp_dy_min\t\tthe minimum dy of all the components of all the resolutions for the tile.\n */\nstatic void opj_pi_update_encode_poc_and_final ( opj_cp_t *p_cp,\n                                                 OPJ_UINT32 p_tileno,\n                                                 OPJ_INT32 p_tx0,\n                                                 OPJ_INT32 p_tx1,\n                                                 OPJ_INT32 p_ty0,\n                                                 OPJ_INT32 p_ty1,\n                                                 OPJ_UINT32 p_max_prec,\n                                                 OPJ_UINT32 p_max_res,\n                                                 OPJ_UINT32 p_dx_min,\n                                                 OPJ_UINT32 p_dy_min);\n\n/**\n * Updates the coding parameters if the encoding is not used with Progression order changes and final (and cinema parameters are used).\n *\n * @param\tp_cp\t\tthe coding parameters to modify\n * @param\tp_num_comps\t\tthe number of components\n * @param\tp_tileno\tthe tile index being concerned.\n * @param\tp_tx0\t\tX0 parameter for the tile\n * @param\tp_tx1\t\tX1 parameter for the tile\n * @param\tp_ty0\t\tY0 parameter for the tile\n * @param\tp_ty1\t\tY1 parameter for the tile\n * @param\tp_max_prec\tthe maximum precision for all the bands of the tile\n * @param\tp_max_res\tthe maximum number of resolutions for all the poc inside the tile.\n * @param\tp_dx_min\t\tthe minimum dx of all the components of all the resolutions for the tile.\n * @param\tp_dy_min\t\tthe minimum dy of all the components of all the resolutions for the tile.\n */\nstatic void opj_pi_update_encode_not_poc (  opj_cp_t *p_cp,\n                                            OPJ_UINT32 p_num_comps,\n                                            OPJ_UINT32 p_tileno,\n                                            OPJ_INT32 p_tx0,\n                                            OPJ_INT32 p_tx1,\n                                            OPJ_INT32 p_ty0,\n                                            OPJ_INT32 p_ty1,\n                                            OPJ_UINT32 p_max_prec,\n                                            OPJ_UINT32 p_max_res,\n                                            OPJ_UINT32 p_dx_min,\n                                            OPJ_UINT32 p_dy_min);\n/**\n * Gets the encoding parameters needed to update the coding parameters and all the pocs.\n * \n * @param\tp_image\t\t\tthe image being encoded.\n * @param\tp_cp\t\t\tthe coding parameters.\n * @param\ttileno\t\t\tthe tile index of the tile being encoded.\n * @param\tp_tx0\t\t\tpointer that will hold the X0 parameter for the tile\n * @param\tp_tx1\t\t\tpointer that will hold the X1 parameter for the tile\n * @param\tp_ty0\t\t\tpointer that will hold the Y0 parameter for the tile\n * @param\tp_ty1\t\t\tpointer that will hold the Y1 parameter for the tile\n * @param\tp_max_prec\t\tpointer that will hold the the maximum precision for all the bands of the tile\n * @param\tp_max_res\t\tpointer that will hold the the maximum number of resolutions for all the poc inside the tile.\n * @param\tp_dx_min\t\t\tpointer that will hold the the minimum dx of all the components of all the resolutions for the tile.\n * @param\tp_dy_min\t\t\tpointer that will hold the the minimum dy of all the components of all the resolutions for the tile.\n */\nstatic void opj_get_encoding_parameters(const opj_image_t *p_image,\n                                        const opj_cp_t *p_cp,\n                                        OPJ_UINT32  tileno,\n                                        OPJ_INT32  * p_tx0,\n                                        OPJ_INT32 * p_tx1,\n                                        OPJ_INT32 * p_ty0,\n                                        OPJ_INT32 * p_ty1,\n                                        OPJ_UINT32 * p_dx_min,\n                                        OPJ_UINT32 * p_dy_min,\n                                        OPJ_UINT32 * p_max_prec,\n                                        OPJ_UINT32 * p_max_res );\n\n/**\n * Gets the encoding parameters needed to update the coding parameters and all the pocs.\n * The precinct widths, heights, dx and dy for each component at each resolution will be stored as well.\n * the last parameter of the function should be an array of pointers of size nb components, each pointer leading\n * to an area of size 4 * max_res. The data is stored inside this area with the following pattern :\n * dx_compi_res0 , dy_compi_res0 , w_compi_res0, h_compi_res0 , dx_compi_res1 , dy_compi_res1 , w_compi_res1, h_compi_res1 , ...\n *\n * @param\tp_image\t\t\tthe image being encoded.\n * @param\tp_cp\t\t\tthe coding parameters.\n * @param\ttileno\t\t\tthe tile index of the tile being encoded.\n * @param\tp_tx0\t\t\tpointer that will hold the X0 parameter for the tile\n * @param\tp_tx1\t\t\tpointer that will hold the X1 parameter for the tile\n * @param\tp_ty0\t\t\tpointer that will hold the Y0 parameter for the tile\n * @param\tp_ty1\t\t\tpointer that will hold the Y1 parameter for the tile\n * @param\tp_max_prec\t\tpointer that will hold the the maximum precision for all the bands of the tile\n * @param\tp_max_res\t\tpointer that will hold the the maximum number of resolutions for all the poc inside the tile.\n * @param\tp_dx_min\t\tpointer that will hold the the minimum dx of all the components of all the resolutions for the tile.\n * @param\tp_dy_min\t\tpointer that will hold the the minimum dy of all the components of all the resolutions for the tile.\n * @param\tp_resolutions\tpointer to an area corresponding to the one described above.\n */\nstatic void opj_get_all_encoding_parameters(const opj_image_t *p_image,\n                                            const opj_cp_t *p_cp,\n                                            OPJ_UINT32 tileno,\n                                            OPJ_INT32 * p_tx0,\n                                            OPJ_INT32 * p_tx1,\n                                            OPJ_INT32 * p_ty0,\n                                            OPJ_INT32 * p_ty1,\n                                            OPJ_UINT32 * p_dx_min,\n                                            OPJ_UINT32 * p_dy_min,\n                                            OPJ_UINT32 * p_max_prec,\n                                            OPJ_UINT32 * p_max_res,\n                                            OPJ_UINT32 ** p_resolutions );\n/**\n * Allocates memory for a packet iterator. Data and data sizes are set by this operation.\n * No other data is set. The include section of the packet  iterator is not allocated.\n * \n * @param\tp_image\t\tthe image used to initialize the packet iterator (in fact only the number of components is relevant.\n * @param\tp_cp\t\tthe coding parameters.\n * @param\ttileno\tthe index of the tile from which creating the packet iterator.\n */\nstatic opj_pi_iterator_t * opj_pi_create(\tconst opj_image_t *p_image,\n                                            const opj_cp_t *p_cp,\n                                            OPJ_UINT32 tileno );\n/**\n * FIXME DOC\n */\nstatic void opj_pi_update_decode_not_poc (opj_pi_iterator_t * p_pi,\n                                          opj_tcp_t * p_tcp,\n                                          OPJ_UINT32 p_max_precision,\n                                          OPJ_UINT32 p_max_res);\n/**\n * FIXME DOC\n */\nstatic void opj_pi_update_decode_poc (  opj_pi_iterator_t * p_pi,\n                                        opj_tcp_t * p_tcp,\n                                        OPJ_UINT32 p_max_precision,\n                                        OPJ_UINT32 p_max_res);\n\n/**\n * FIXME DOC\n */\nOPJ_BOOL opj_pi_check_next_level(\tOPJ_INT32 pos,\n\t\t\t\t\t\t\t\topj_cp_t *cp,\n\t\t\t\t\t\t\t\tOPJ_UINT32 tileno,\n\t\t\t\t\t\t\t\tOPJ_UINT32 pino,\n\t\t\t\t\t\t\t\tconst OPJ_CHAR *prog);\n\n/*@}*/\n\n/*@}*/\n\n/*\n==========================================================\n   local functions\n==========================================================\n*/\n\nOPJ_BOOL opj_pi_next_lrcp(opj_pi_iterator_t * pi) {\n\topj_pi_comp_t *comp = NULL;\n\topj_pi_resolution_t *res = NULL;\n\tOPJ_UINT32 index = 0;\n\t\n\tif (!pi->first) {\n\t\tcomp = &pi->comps[pi->compno];\n\t\tres = &comp->resolutions[pi->resno];\n\t\tgoto LABEL_SKIP;\n\t} else {\n\t\tpi->first = 0;\n\t}\n\n\tfor (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n\t\tfor (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1;\n\t\tpi->resno++) {\n\t\t\tfor (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n\t\t\t\tcomp = &pi->comps[pi->compno];\n\t\t\t\tif (pi->resno >= comp->numresolutions) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tres = &comp->resolutions[pi->resno];\n\t\t\t\tif (!pi->tp_on){\n\t\t\t\t\tpi->poc.precno1 = res->pw * res->ph;\n\t\t\t\t}\n\t\t\t\tfor (pi->precno = pi->poc.precno0; pi->precno < pi->poc.precno1; pi->precno++) {\n\t\t\t\t\tindex = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno * pi->step_c + pi->precno * pi->step_p;\n\t\t\t\t\tif (!pi->include[index]) {\n\t\t\t\t\t\tpi->include[index] = 1;\n\t\t\t\t\t\treturn OPJ_TRUE;\n\t\t\t\t\t}\nLABEL_SKIP:;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn OPJ_FALSE;\n}\n\nOPJ_BOOL opj_pi_next_rlcp(opj_pi_iterator_t * pi) {\n\topj_pi_comp_t *comp = NULL;\n\topj_pi_resolution_t *res = NULL;\n\tOPJ_UINT32 index = 0;\n\n\tif (!pi->first) {\n\t\tcomp = &pi->comps[pi->compno];\n\t\tres = &comp->resolutions[pi->resno];\n\t\tgoto LABEL_SKIP;\n\t} else {\n\t\tpi->first = 0;\n\t}\n\n\tfor (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1; pi->resno++) {\n\t\tfor (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n\t\t\tfor (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n\t\t\t\tcomp = &pi->comps[pi->compno];\n\t\t\t\tif (pi->resno >= comp->numresolutions) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tres = &comp->resolutions[pi->resno];\n\t\t\t\tif(!pi->tp_on){\n\t\t\t\t\tpi->poc.precno1 = res->pw * res->ph;\n\t\t\t\t}\n\t\t\t\tfor (pi->precno = pi->poc.precno0; pi->precno < pi->poc.precno1; pi->precno++) {\n\t\t\t\t\tindex = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno * pi->step_c + pi->precno * pi->step_p;\n\t\t\t\t\tif (!pi->include[index]) {\n\t\t\t\t\t\tpi->include[index] = 1;\n\t\t\t\t\t\treturn OPJ_TRUE;\n\t\t\t\t\t}\nLABEL_SKIP:;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn OPJ_FALSE;\n}\n\nOPJ_BOOL opj_pi_next_rpcl(opj_pi_iterator_t * pi) {\n\topj_pi_comp_t *comp = NULL;\n\topj_pi_resolution_t *res = NULL;\n\tOPJ_UINT32 index = 0;\n\n\tif (!pi->first) {\n\t\tgoto LABEL_SKIP;\n\t} else {\n\t\tOPJ_UINT32 compno, resno;\n\t\tpi->first = 0;\n\t\tpi->dx = 0;\n\t\tpi->dy = 0;\n\t\tfor (compno = 0; compno < pi->numcomps; compno++) {\n\t\t\tcomp = &pi->comps[compno];\n\t\t\tfor (resno = 0; resno < comp->numresolutions; resno++) {\n\t\t\t\tOPJ_UINT32 dx, dy;\n\t\t\t\tres = &comp->resolutions[resno];\n\t\t\t\tdx = comp->dx * (1u << (res->pdx + comp->numresolutions - 1 - resno));\n\t\t\t\tdy = comp->dy * (1u << (res->pdy + comp->numresolutions - 1 - resno));\n\t\t\t\tpi->dx = !pi->dx ? dx : opj_uint_min(pi->dx, dx);\n\t\t\t\tpi->dy = !pi->dy ? dy : opj_uint_min(pi->dy, dy);\n\t\t\t}\n\t\t}\n\t}\nif (!pi->tp_on){\n\t\t\tpi->poc.ty0 = pi->ty0;\n\t\t\tpi->poc.tx0 = pi->tx0;\n\t\t\tpi->poc.ty1 = pi->ty1;\n\t\t\tpi->poc.tx1 = pi->tx1;\n\t\t}\n\tfor (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1; pi->resno++) {\n\t\tfor (pi->y = pi->poc.ty0; pi->y < pi->poc.ty1; pi->y += (OPJ_INT32)(pi->dy - (OPJ_UINT32)(pi->y % (OPJ_INT32)pi->dy))) {\n\t\t\tfor (pi->x = pi->poc.tx0; pi->x < pi->poc.tx1; pi->x += (OPJ_INT32)(pi->dx - (OPJ_UINT32)(pi->x % (OPJ_INT32)pi->dx))) {\n\t\t\t\tfor (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n\t\t\t\t\tOPJ_UINT32 levelno;\n\t\t\t\t\tOPJ_INT32 trx0, try0;\n\t\t\t\t\tOPJ_INT32  trx1, try1;\n\t\t\t\t\tOPJ_UINT32  rpx, rpy;\n\t\t\t\t\tOPJ_INT32  prci, prcj;\n\t\t\t\t\tcomp = &pi->comps[pi->compno];\n\t\t\t\t\tif (pi->resno >= comp->numresolutions) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tres = &comp->resolutions[pi->resno];\n\t\t\t\t\tlevelno = comp->numresolutions - 1 - pi->resno;\n\t\t\t\t\ttrx0 = opj_int_ceildiv(pi->tx0, (OPJ_INT32)(comp->dx << levelno));\n\t\t\t\t\ttry0 = opj_int_ceildiv(pi->ty0, (OPJ_INT32)(comp->dy << levelno));\n\t\t\t\t\ttrx1 = opj_int_ceildiv(pi->tx1, (OPJ_INT32)(comp->dx << levelno));\n\t\t\t\t\ttry1 = opj_int_ceildiv(pi->ty1, (OPJ_INT32)(comp->dy << levelno));\n\t\t\t\t\trpx = res->pdx + levelno;\n\t\t\t\t\trpy = res->pdy + levelno;\n\t\t\t\t\tif (!((pi->y % (OPJ_INT32)(comp->dy << rpy) == 0) || ((pi->y == pi->ty0) && ((try0 << levelno) % (1 << rpy))))){\n\t\t\t\t\t\tcontinue;\t\n\t\t\t\t\t}\n\t\t\t\t\tif (!((pi->x % (OPJ_INT32)(comp->dx << rpx) == 0) || ((pi->x == pi->tx0) && ((trx0 << levelno) % (1 << rpx))))){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif ((res->pw==0)||(res->ph==0)) continue;\n\t\t\t\t\t\n\t\t\t\t\tif ((trx0==trx1)||(try0==try1)) continue;\n\t\t\t\t\t\n\t\t\t\t\tprci = opj_int_floordivpow2(opj_int_ceildiv(pi->x, (OPJ_INT32)(comp->dx << levelno)), (OPJ_INT32)res->pdx)\n\t\t\t\t\t\t - opj_int_floordivpow2(trx0, (OPJ_INT32)res->pdx);\n\t\t\t\t\tprcj = opj_int_floordivpow2(opj_int_ceildiv(pi->y, (OPJ_INT32)(comp->dy << levelno)), (OPJ_INT32)res->pdy)\n\t\t\t\t\t\t - opj_int_floordivpow2(try0, (OPJ_INT32)res->pdy);\n\t\t\t\t\tpi->precno = (OPJ_UINT32)(prci + prcj * (OPJ_INT32)res->pw);\n\t\t\t\t\tfor (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n\t\t\t\t\t\tindex = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno * pi->step_c + pi->precno * pi->step_p;\n\t\t\t\t\t\tif (!pi->include[index]) {\n\t\t\t\t\t\t\tpi->include[index] = 1;\n\t\t\t\t\t\t\treturn OPJ_TRUE;\n\t\t\t\t\t\t}\nLABEL_SKIP:;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn OPJ_FALSE;\n}\n\nOPJ_BOOL opj_pi_next_pcrl(opj_pi_iterator_t * pi) {\n\topj_pi_comp_t *comp = NULL;\n\topj_pi_resolution_t *res = NULL;\n\tOPJ_UINT32 index = 0;\n\n\tif (!pi->first) {\n\t\tcomp = &pi->comps[pi->compno];\n\t\tgoto LABEL_SKIP;\n\t} else {\n\t\tOPJ_UINT32 compno, resno;\n\t\tpi->first = 0;\n\t\tpi->dx = 0;\n\t\tpi->dy = 0;\n\t\tfor (compno = 0; compno < pi->numcomps; compno++) {\n\t\t\tcomp = &pi->comps[compno];\n\t\t\tfor (resno = 0; resno < comp->numresolutions; resno++) {\n\t\t\t\tOPJ_UINT32 dx, dy;\n\t\t\t\tres = &comp->resolutions[resno];\n\t\t\t\tdx = comp->dx * (1u << (res->pdx + comp->numresolutions - 1 - resno));\n\t\t\t\tdy = comp->dy * (1u << (res->pdy + comp->numresolutions - 1 - resno));\n\t\t\t\tpi->dx = !pi->dx ? dx : opj_uint_min(pi->dx, dx);\n\t\t\t\tpi->dy = !pi->dy ? dy : opj_uint_min(pi->dy, dy);\n\t\t\t}\n\t\t}\n\t}\n\tif (!pi->tp_on){\n\t\t\tpi->poc.ty0 = pi->ty0;\n\t\t\tpi->poc.tx0 = pi->tx0;\n\t\t\tpi->poc.ty1 = pi->ty1;\n\t\t\tpi->poc.tx1 = pi->tx1;\n\t\t}\n\tfor (pi->y = pi->poc.ty0; pi->y < pi->poc.ty1; pi->y += (OPJ_INT32)(pi->dy - (OPJ_UINT32)(pi->y % (OPJ_INT32)pi->dy))) {\n\t\tfor (pi->x = pi->poc.tx0; pi->x < pi->poc.tx1; pi->x += (OPJ_INT32)(pi->dx - (OPJ_UINT32)(pi->x % (OPJ_INT32)pi->dx))) {\n\t\t\tfor (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n\t\t\t\tcomp = &pi->comps[pi->compno];\n\t\t\t\tfor (pi->resno = pi->poc.resno0; pi->resno < opj_uint_min(pi->poc.resno1, comp->numresolutions); pi->resno++) {\n\t\t\t\t\tOPJ_UINT32 levelno;\n\t\t\t\t\tOPJ_INT32 trx0, try0;\n\t\t\t\t\tOPJ_INT32 trx1, try1;\n\t\t\t\t\tOPJ_UINT32 rpx, rpy;\n\t\t\t\t\tOPJ_INT32 prci, prcj;\n\t\t\t\t\tres = &comp->resolutions[pi->resno];\n\t\t\t\t\tlevelno = comp->numresolutions - 1 - pi->resno;\n\t\t\t\t\ttrx0 = opj_int_ceildiv(pi->tx0, (OPJ_INT32)(comp->dx << levelno));\n\t\t\t\t\ttry0 = opj_int_ceildiv(pi->ty0, (OPJ_INT32)(comp->dy << levelno));\n\t\t\t\t\ttrx1 = opj_int_ceildiv(pi->tx1, (OPJ_INT32)(comp->dx << levelno));\n\t\t\t\t\ttry1 = opj_int_ceildiv(pi->ty1, (OPJ_INT32)(comp->dy << levelno));\n\t\t\t\t\trpx = res->pdx + levelno;\n\t\t\t\t\trpy = res->pdy + levelno;\n\t\t\t\t\tif (!((pi->y % (OPJ_INT32)(comp->dy << rpy) == 0) || ((pi->y == pi->ty0) && ((try0 << levelno) % (1 << rpy))))){\n\t\t\t\t\t\tcontinue;\t\n\t\t\t\t\t}\n\t\t\t\t\tif (!((pi->x % (OPJ_INT32)(comp->dx << rpx) == 0) || ((pi->x == pi->tx0) && ((trx0 << levelno) % (1 << rpx))))){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif ((res->pw==0)||(res->ph==0)) continue;\n\t\t\t\t\t\n\t\t\t\t\tif ((trx0==trx1)||(try0==try1)) continue;\n\t\t\t\t\t\n\t\t\t\t\tprci = opj_int_floordivpow2(opj_int_ceildiv(pi->x, (OPJ_INT32)(comp->dx << levelno)), (OPJ_INT32)res->pdx)\n\t\t\t\t\t\t - opj_int_floordivpow2(trx0, (OPJ_INT32)res->pdx);\n\t\t\t\t\tprcj = opj_int_floordivpow2(opj_int_ceildiv(pi->y, (OPJ_INT32)(comp->dy << levelno)), (OPJ_INT32)res->pdy)\n\t\t\t\t\t\t - opj_int_floordivpow2(try0, (OPJ_INT32)res->pdy);\n\t\t\t\t\tpi->precno = (OPJ_UINT32)(prci + prcj * (OPJ_INT32)res->pw);\n\t\t\t\t\tfor (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n\t\t\t\t\t\tindex = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno * pi->step_c + pi->precno * pi->step_p;\n\t\t\t\t\t\tif (!pi->include[index]) {\n\t\t\t\t\t\t\tpi->include[index] = 1;\n\t\t\t\t\t\t\treturn OPJ_TRUE;\n\t\t\t\t\t\t}\t\nLABEL_SKIP:;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn OPJ_FALSE;\n}\n\nOPJ_BOOL opj_pi_next_cprl(opj_pi_iterator_t * pi) {\n\topj_pi_comp_t *comp = NULL;\n\topj_pi_resolution_t *res = NULL;\n\tOPJ_UINT32 index = 0;\n\n\tif (!pi->first) {\n\t\tcomp = &pi->comps[pi->compno];\n\t\tgoto LABEL_SKIP;\n\t} else {\n\t\tpi->first = 0;\n\t}\n\n\tfor (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n\t\tOPJ_UINT32 resno;\n\t\tcomp = &pi->comps[pi->compno];\n\t\tpi->dx = 0;\n\t\tpi->dy = 0;\n\t\tfor (resno = 0; resno < comp->numresolutions; resno++) {\n\t\t\tOPJ_UINT32 dx, dy;\n\t\t\tres = &comp->resolutions[resno];\n\t\t\tdx = comp->dx * (1u << (res->pdx + comp->numresolutions - 1 - resno));\n\t\t\tdy = comp->dy * (1u << (res->pdy + comp->numresolutions - 1 - resno));\n\t\t\tpi->dx = !pi->dx ? dx : opj_uint_min(pi->dx, dx);\n\t\t\tpi->dy = !pi->dy ? dy : opj_uint_min(pi->dy, dy);\n\t\t}\n\t\tif (!pi->tp_on){\n\t\t\tpi->poc.ty0 = pi->ty0;\n\t\t\tpi->poc.tx0 = pi->tx0;\n\t\t\tpi->poc.ty1 = pi->ty1;\n\t\t\tpi->poc.tx1 = pi->tx1;\n\t\t}\n\t\tfor (pi->y = pi->poc.ty0; pi->y < pi->poc.ty1; pi->y += (OPJ_INT32)(pi->dy - (OPJ_UINT32)(pi->y % (OPJ_INT32)pi->dy))) {\n\t\t\tfor (pi->x = pi->poc.tx0; pi->x < pi->poc.tx1; pi->x += (OPJ_INT32)(pi->dx - (OPJ_UINT32)(pi->x % (OPJ_INT32)pi->dx))) {\n\t\t\t\tfor (pi->resno = pi->poc.resno0; pi->resno < opj_uint_min(pi->poc.resno1, comp->numresolutions); pi->resno++) {\n\t\t\t\t\tOPJ_UINT32 levelno;\n\t\t\t\t\tOPJ_INT32 trx0, try0;\n\t\t\t\t\tOPJ_INT32 trx1, try1;\n\t\t\t\t\tOPJ_UINT32 rpx, rpy;\n\t\t\t\t\tOPJ_INT32 prci, prcj;\n\t\t\t\t\tres = &comp->resolutions[pi->resno];\n\t\t\t\t\tlevelno = comp->numresolutions - 1 - pi->resno;\n\t\t\t\t\ttrx0 = opj_int_ceildiv(pi->tx0, (OPJ_INT32)(comp->dx << levelno));\n\t\t\t\t\ttry0 = opj_int_ceildiv(pi->ty0, (OPJ_INT32)(comp->dy << levelno));\n\t\t\t\t\ttrx1 = opj_int_ceildiv(pi->tx1, (OPJ_INT32)(comp->dx << levelno));\n\t\t\t\t\ttry1 = opj_int_ceildiv(pi->ty1, (OPJ_INT32)(comp->dy << levelno));\n\t\t\t\t\trpx = res->pdx + levelno;\n\t\t\t\t\trpy = res->pdy + levelno;\n\t\t\t\t\tif (!((pi->y % (OPJ_INT32)(comp->dy << rpy) == 0) || ((pi->y == pi->ty0) && ((try0 << levelno) % (1 << rpy))))){\n\t\t\t\t\t\tcontinue;\t\n\t\t\t\t\t}\n\t\t\t\t\tif (!((pi->x % (OPJ_INT32)(comp->dx << rpx) == 0) || ((pi->x == pi->tx0) && ((trx0 << levelno) % (1 << rpx))))){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif ((res->pw==0)||(res->ph==0)) continue;\n\t\t\t\t\t\n\t\t\t\t\tif ((trx0==trx1)||(try0==try1)) continue;\n\t\t\t\t\t\n\t\t\t\t\tprci = opj_int_floordivpow2(opj_int_ceildiv(pi->x, (OPJ_INT32)(comp->dx << levelno)), (OPJ_INT32)res->pdx)\n\t\t\t\t\t\t - opj_int_floordivpow2(trx0, (OPJ_INT32)res->pdx);\n\t\t\t\t\tprcj = opj_int_floordivpow2(opj_int_ceildiv(pi->y, (OPJ_INT32)(comp->dy << levelno)), (OPJ_INT32)res->pdy)\n\t\t\t\t\t\t - opj_int_floordivpow2(try0, (OPJ_INT32)res->pdy);\n\t\t\t\t\tpi->precno = (OPJ_UINT32)(prci + prcj * (OPJ_INT32)res->pw);\n\t\t\t\t\tfor (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n\t\t\t\t\t\tindex = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno * pi->step_c + pi->precno * pi->step_p;\n\t\t\t\t\t\tif (!pi->include[index]) {\n\t\t\t\t\t\t\tpi->include[index] = 1;\n\t\t\t\t\t\t\treturn OPJ_TRUE;\n\t\t\t\t\t\t}\nLABEL_SKIP:;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn OPJ_FALSE;\n}\n\nvoid opj_get_encoding_parameters(\tconst opj_image_t *p_image,\n                                    const opj_cp_t *p_cp,\n                                    OPJ_UINT32 p_tileno,\n                                    OPJ_INT32 * p_tx0,\n                                    OPJ_INT32  * p_tx1,\n                                    OPJ_INT32  * p_ty0,\n                                    OPJ_INT32  * p_ty1,\n                                    OPJ_UINT32 * p_dx_min,\n                                    OPJ_UINT32 * p_dy_min,\n                                    OPJ_UINT32 * p_max_prec,\n                                    OPJ_UINT32 * p_max_res )\n{\n\t/* loop */\n\tOPJ_UINT32  compno, resno;\n\t/* pointers */\n\tconst opj_tcp_t *l_tcp = 00;\n\tconst opj_tccp_t * l_tccp = 00;\n\tconst opj_image_comp_t * l_img_comp = 00;\n\n\t/* position in x and y of tile */\n\tOPJ_UINT32 p, q;\n\n\t/* preconditions */\n\tassert(p_cp != 00);\n\tassert(p_image != 00);\n\tassert(p_tileno < p_cp->tw * p_cp->th);\n\n\t/* initializations */\n\tl_tcp = &p_cp->tcps [p_tileno];\n\tl_img_comp = p_image->comps;\n\tl_tccp = l_tcp->tccps;\n\n\t/* here calculation of tx0, tx1, ty0, ty1, maxprec, dx and dy */\n\tp = p_tileno % p_cp->tw;\n\tq = p_tileno / p_cp->tw;\n\n\t/* find extent of tile */\n\t*p_tx0 = opj_int_max((OPJ_INT32)(p_cp->tx0 + p * p_cp->tdx), (OPJ_INT32)p_image->x0);\n\t*p_tx1 = opj_int_min((OPJ_INT32)(p_cp->tx0 + (p + 1) * p_cp->tdx), (OPJ_INT32)p_image->x1);\n\t*p_ty0 = opj_int_max((OPJ_INT32)(p_cp->ty0 + q * p_cp->tdy), (OPJ_INT32)p_image->y0);\n\t*p_ty1 = opj_int_min((OPJ_INT32)(p_cp->ty0 + (q + 1) * p_cp->tdy), (OPJ_INT32)p_image->y1);\n\n\t/* max precision is 0 (can only grow) */\n\t*p_max_prec = 0;\n\t*p_max_res = 0;\n\n\t/* take the largest value for dx_min and dy_min */\n\t*p_dx_min = 0x7fffffff;\n\t*p_dy_min  = 0x7fffffff;\n\n\tfor (compno = 0; compno < p_image->numcomps; ++compno) {\n\t\t/* arithmetic variables to calculate */\n\t\tOPJ_UINT32 l_level_no;\n\t\tOPJ_INT32 l_rx0, l_ry0, l_rx1, l_ry1;\n\t\tOPJ_INT32 l_px0, l_py0, l_px1, py1;\n\t\tOPJ_UINT32 l_pdx, l_pdy;\n\t\tOPJ_UINT32 l_pw, l_ph;\n\t\tOPJ_UINT32 l_product;\n\t\tOPJ_INT32 l_tcx0, l_tcy0, l_tcx1, l_tcy1;\n\n\t\tl_tcx0 = opj_int_ceildiv(*p_tx0, (OPJ_INT32)l_img_comp->dx);\n\t\tl_tcy0 = opj_int_ceildiv(*p_ty0, (OPJ_INT32)l_img_comp->dy);\n\t\tl_tcx1 = opj_int_ceildiv(*p_tx1, (OPJ_INT32)l_img_comp->dx);\n\t\tl_tcy1 = opj_int_ceildiv(*p_ty1, (OPJ_INT32)l_img_comp->dy);\n\n\t\tif (l_tccp->numresolutions > *p_max_res) {\n\t\t\t*p_max_res = l_tccp->numresolutions;\n\t\t}\n\n\t\t/* use custom size for precincts */\n\t\tfor (resno = 0; resno < l_tccp->numresolutions; ++resno) {\n\t\t\tOPJ_UINT32 l_dx, l_dy;\n\n\t\t\t/* precinct width and height */\n\t\t\tl_pdx = l_tccp->prcw[resno];\n\t\t\tl_pdy = l_tccp->prch[resno];\n\n\t\t\tl_dx = l_img_comp->dx * (1u << (l_pdx + l_tccp->numresolutions - 1 - resno));\n\t\t\tl_dy = l_img_comp->dy * (1u << (l_pdy + l_tccp->numresolutions - 1 - resno));\n\n\t\t\t/* take the minimum size for dx for each comp and resolution */\n\t\t\t*p_dx_min = opj_uint_min(*p_dx_min, l_dx);\n\t\t\t*p_dy_min = opj_uint_min(*p_dy_min, l_dy);\n\n\t\t\t/* various calculations of extents */\n\t\t\tl_level_no = l_tccp->numresolutions - 1 - resno;\n\n\t\t\tl_rx0 = opj_int_ceildivpow2(l_tcx0, (OPJ_INT32)l_level_no);\n\t\t\tl_ry0 = opj_int_ceildivpow2(l_tcy0, (OPJ_INT32)l_level_no);\n\t\t\tl_rx1 = opj_int_ceildivpow2(l_tcx1, (OPJ_INT32)l_level_no);\n\t\t\tl_ry1 = opj_int_ceildivpow2(l_tcy1, (OPJ_INT32)l_level_no);\n\n\t\t\tl_px0 = opj_int_floordivpow2(l_rx0, (OPJ_INT32)l_pdx) << l_pdx;\n\t\t\tl_py0 = opj_int_floordivpow2(l_ry0, (OPJ_INT32)l_pdy) << l_pdy;\n\t\t\tl_px1 = opj_int_ceildivpow2(l_rx1, (OPJ_INT32)l_pdx) << l_pdx;\n\n\t\t\tpy1 = opj_int_ceildivpow2(l_ry1, (OPJ_INT32)l_pdy) << l_pdy;\n\n\t\t\tl_pw = (l_rx0==l_rx1)?0:(OPJ_UINT32)((l_px1 - l_px0) >> l_pdx);\n\t\t\tl_ph = (l_ry0==l_ry1)?0:(OPJ_UINT32)((py1 - l_py0) >> l_pdy);\n\n\t\t\tl_product = l_pw * l_ph;\n\n\t\t\t/* update precision */\n\t\t\tif (l_product > *p_max_prec) {\n\t\t\t\t*p_max_prec = l_product;\n\t\t\t}\n\t\t}\n\t\t++l_img_comp;\n\t\t++l_tccp;\n\t}\n}\n\n\nvoid opj_get_all_encoding_parameters(   const opj_image_t *p_image,\n                                        const opj_cp_t *p_cp,\n                                        OPJ_UINT32 tileno,\n                                        OPJ_INT32 * p_tx0,\n                                        OPJ_INT32 * p_tx1,\n                                        OPJ_INT32 * p_ty0,\n                                        OPJ_INT32 * p_ty1,\n                                        OPJ_UINT32 * p_dx_min,\n                                        OPJ_UINT32 * p_dy_min,\n                                        OPJ_UINT32 * p_max_prec,\n                                        OPJ_UINT32 * p_max_res,\n                                        OPJ_UINT32 ** p_resolutions )\n{\n\t/* loop*/\n\tOPJ_UINT32 compno, resno;\n\n\t/* pointers*/\n\tconst opj_tcp_t *tcp = 00;\n\tconst opj_tccp_t * l_tccp = 00;\n\tconst opj_image_comp_t * l_img_comp = 00;\n\n\t/* to store l_dx, l_dy, w and h for each resolution and component.*/\n\tOPJ_UINT32 * lResolutionPtr;\n\n\t/* position in x and y of tile*/\n\tOPJ_UINT32 p, q;\n\n\t/* preconditions in debug*/\n\tassert(p_cp != 00);\n\tassert(p_image != 00);\n\tassert(tileno < p_cp->tw * p_cp->th);\n\n\t/* initializations*/\n\ttcp = &p_cp->tcps [tileno];\n\tl_tccp = tcp->tccps;\n\tl_img_comp = p_image->comps;\n\n\t/* position in x and y of tile*/\n\tp = tileno % p_cp->tw;\n\tq = tileno / p_cp->tw;\n\n\t/* here calculation of tx0, tx1, ty0, ty1, maxprec, l_dx and l_dy */\n\t*p_tx0 = opj_int_max((OPJ_INT32)(p_cp->tx0 + p * p_cp->tdx), (OPJ_INT32)p_image->x0);\n\t*p_tx1 = opj_int_min((OPJ_INT32)(p_cp->tx0 + (p + 1) * p_cp->tdx), (OPJ_INT32)p_image->x1);\n\t*p_ty0 = opj_int_max((OPJ_INT32)(p_cp->ty0 + q * p_cp->tdy), (OPJ_INT32)p_image->y0);\n\t*p_ty1 = opj_int_min((OPJ_INT32)(p_cp->ty0 + (q + 1) * p_cp->tdy), (OPJ_INT32)p_image->y1);\n\n\t/* max precision and resolution is 0 (can only grow)*/\n\t*p_max_prec = 0;\n\t*p_max_res = 0;\n\n\t/* take the largest value for dx_min and dy_min*/\n\t*p_dx_min = 0x7fffffff;\n\t*p_dy_min = 0x7fffffff;\n\n\tfor (compno = 0; compno < p_image->numcomps; ++compno) {\n\t\t/* aritmetic variables to calculate*/\n\t\tOPJ_UINT32 l_level_no;\n\t\tOPJ_INT32 l_rx0, l_ry0, l_rx1, l_ry1;\n\t\tOPJ_INT32 l_px0, l_py0, l_px1, py1;\n\t\tOPJ_UINT32 l_product;\n\t\tOPJ_INT32 l_tcx0, l_tcy0, l_tcx1, l_tcy1;\n\t\tOPJ_UINT32 l_pdx, l_pdy , l_pw , l_ph;\n\n\t\tlResolutionPtr = p_resolutions[compno];\n\n\t\tl_tcx0 = opj_int_ceildiv(*p_tx0, (OPJ_INT32)l_img_comp->dx);\n\t\tl_tcy0 = opj_int_ceildiv(*p_ty0, (OPJ_INT32)l_img_comp->dy);\n\t\tl_tcx1 = opj_int_ceildiv(*p_tx1, (OPJ_INT32)l_img_comp->dx);\n\t\tl_tcy1 = opj_int_ceildiv(*p_ty1, (OPJ_INT32)l_img_comp->dy);\n\n\t\tif (l_tccp->numresolutions > *p_max_res) {\n\t\t\t*p_max_res = l_tccp->numresolutions;\n\t\t}\n\n\t\t/* use custom size for precincts*/\n\t\tl_level_no = l_tccp->numresolutions - 1;\n\t\tfor (resno = 0; resno < l_tccp->numresolutions; ++resno) {\n\t\t\tOPJ_UINT32 l_dx, l_dy;\n\n\t\t\t/* precinct width and height*/\n\t\t\tl_pdx = l_tccp->prcw[resno];\n\t\t\tl_pdy = l_tccp->prch[resno];\n\t\t\t*lResolutionPtr++ = l_pdx;\n\t\t\t*lResolutionPtr++ = l_pdy;\n\t\t\tl_dx = l_img_comp->dx * (1u << (l_pdx + l_level_no));\n\t\t\tl_dy = l_img_comp->dy * (1u << (l_pdy + l_level_no));\n\t\t\t/* take the minimum size for l_dx for each comp and resolution*/\n\t\t\t*p_dx_min = (OPJ_UINT32)opj_int_min((OPJ_INT32)*p_dx_min, (OPJ_INT32)l_dx);\n\t\t\t*p_dy_min = (OPJ_UINT32)opj_int_min((OPJ_INT32)*p_dy_min, (OPJ_INT32)l_dy);\n\n\t\t\t/* various calculations of extents*/\n\t\t\tl_rx0 = opj_int_ceildivpow2(l_tcx0, (OPJ_INT32)l_level_no);\n\t\t\tl_ry0 = opj_int_ceildivpow2(l_tcy0, (OPJ_INT32)l_level_no);\n\t\t\tl_rx1 = opj_int_ceildivpow2(l_tcx1, (OPJ_INT32)l_level_no);\n\t\t\tl_ry1 = opj_int_ceildivpow2(l_tcy1, (OPJ_INT32)l_level_no);\n\t\t\tl_px0 = opj_int_floordivpow2(l_rx0, (OPJ_INT32)l_pdx) << l_pdx;\n\t\t\tl_py0 = opj_int_floordivpow2(l_ry0, (OPJ_INT32)l_pdy) << l_pdy;\n\t\t\tl_px1 = opj_int_ceildivpow2(l_rx1, (OPJ_INT32)l_pdx) << l_pdx;\n\t\t\tpy1 = opj_int_ceildivpow2(l_ry1, (OPJ_INT32)l_pdy) << l_pdy;\n\t\t\tl_pw = (l_rx0==l_rx1)?0:(OPJ_UINT32)((l_px1 - l_px0) >> l_pdx);\n\t\t\tl_ph = (l_ry0==l_ry1)?0:(OPJ_UINT32)((py1 - l_py0) >> l_pdy);\n\t\t\t*lResolutionPtr++ = l_pw;\n\t\t\t*lResolutionPtr++ = l_ph;\n\t\t\tl_product = l_pw * l_ph;\n\t\t\t\n            /* update precision*/\n\t\t\tif (l_product > *p_max_prec) {\n\t\t\t\t*p_max_prec = l_product;\n\t\t\t}\n\n\t\t\t--l_level_no;\n\t\t}\n\t\t++l_tccp;\n\t\t++l_img_comp;\n\t}\n}\n\nopj_pi_iterator_t * opj_pi_create(\tconst opj_image_t *image,\n                                    const opj_cp_t *cp,\n                                    OPJ_UINT32 tileno )\n{\n\t/* loop*/\n\tOPJ_UINT32 pino, compno;\n\t/* number of poc in the p_pi*/\n\tOPJ_UINT32 l_poc_bound;\n\n\t/* pointers to tile coding parameters and components.*/\n\topj_pi_iterator_t *l_pi = 00;\n\topj_tcp_t *tcp = 00;\n\tconst opj_tccp_t *tccp = 00;\n\n\t/* current packet iterator being allocated*/\n\topj_pi_iterator_t *l_current_pi = 00;\n\n\t/* preconditions in debug*/\n\tassert(cp != 00);\n\tassert(image != 00);\n\tassert(tileno < cp->tw * cp->th);\n\n\t/* initializations*/\n\ttcp = &cp->tcps[tileno];\n\tl_poc_bound = tcp->numpocs+1;\n\n\t/* memory allocations*/\n\tl_pi = (opj_pi_iterator_t*) opj_calloc((l_poc_bound), sizeof(opj_pi_iterator_t));\n\tif (!l_pi) {\n\t\treturn NULL;\n\t}\n\n\tl_current_pi = l_pi;\n\tfor (pino = 0; pino < l_poc_bound ; ++pino) {\n\n\t\tl_current_pi->comps = (opj_pi_comp_t*) opj_calloc(image->numcomps, sizeof(opj_pi_comp_t));\n\t\tif (! l_current_pi->comps) {\n\t\t\topj_pi_destroy(l_pi, l_poc_bound);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tl_current_pi->numcomps = image->numcomps;\n\n\t\tfor (compno = 0; compno < image->numcomps; ++compno) {\n\t\t\topj_pi_comp_t *comp = &l_current_pi->comps[compno];\n\n\t\t\ttccp = &tcp->tccps[compno];\n\n\t\t\tcomp->resolutions = (opj_pi_resolution_t*) opj_calloc(tccp->numresolutions, sizeof(opj_pi_resolution_t));\n\t\t\tif (!comp->resolutions) {\n\t\t\t\topj_pi_destroy(l_pi, l_poc_bound);\n\t\t\t\treturn 00;\n\t\t\t}\n\n\t\t\tcomp->numresolutions = tccp->numresolutions;\n\t\t}\n\t\t++l_current_pi;\n\t}\n\treturn l_pi;\n}\n\nvoid opj_pi_update_encode_poc_and_final (   opj_cp_t *p_cp,\n                                            OPJ_UINT32 p_tileno,\n                                            OPJ_INT32 p_tx0,\n                                            OPJ_INT32 p_tx1,\n                                            OPJ_INT32 p_ty0,\n                                            OPJ_INT32 p_ty1,\n                                            OPJ_UINT32 p_max_prec,\n                                            OPJ_UINT32 p_max_res,\n                                            OPJ_UINT32 p_dx_min,\n                                            OPJ_UINT32 p_dy_min)\n{\n\t/* loop*/\n\tOPJ_UINT32 pino;\n\t/* tile coding parameter*/\n\topj_tcp_t *l_tcp = 00;\n\t/* current poc being updated*/\n\topj_poc_t * l_current_poc = 00;\n\n\t/* number of pocs*/\n\tOPJ_UINT32 l_poc_bound;\n\n    OPJ_ARG_NOT_USED(p_max_res);\n\n\t/* preconditions in debug*/\n\tassert(p_cp != 00);\n\tassert(p_tileno < p_cp->tw * p_cp->th);\n\n\t/* initializations*/\n\tl_tcp = &p_cp->tcps [p_tileno];\n\t/* number of iterations in the loop */\n\tl_poc_bound = l_tcp->numpocs+1;\n\n\t/* start at first element, and to make sure the compiler will not make a calculation each time in the loop\n\t   store a pointer to the current element to modify rather than l_tcp->pocs[i]*/\n\tl_current_poc = l_tcp->pocs;\n\n\tl_current_poc->compS = l_current_poc->compno0;\n\tl_current_poc->compE = l_current_poc->compno1;\n\tl_current_poc->resS = l_current_poc->resno0;\n\tl_current_poc->resE = l_current_poc->resno1;\n\tl_current_poc->layE = l_current_poc->layno1;\n\n\t/* special treatment for the first element*/\n\tl_current_poc->layS = 0;\n\tl_current_poc->prg  = l_current_poc->prg1;\n\tl_current_poc->prcS = 0;\n\n\tl_current_poc->prcE = p_max_prec;\n\tl_current_poc->txS = (OPJ_UINT32)p_tx0;\n\tl_current_poc->txE = (OPJ_UINT32)p_tx1;\n\tl_current_poc->tyS = (OPJ_UINT32)p_ty0;\n\tl_current_poc->tyE = (OPJ_UINT32)p_ty1;\n\tl_current_poc->dx = p_dx_min;\n\tl_current_poc->dy = p_dy_min;\n\n\t++ l_current_poc;\n\tfor (pino = 1;pino < l_poc_bound ; ++pino) {\n\t\tl_current_poc->compS = l_current_poc->compno0;\n\t\tl_current_poc->compE= l_current_poc->compno1;\n\t\tl_current_poc->resS = l_current_poc->resno0;\n\t\tl_current_poc->resE = l_current_poc->resno1;\n\t\tl_current_poc->layE = l_current_poc->layno1;\n\t\tl_current_poc->prg  = l_current_poc->prg1;\n\t\tl_current_poc->prcS = 0;\n\t\t/* special treatment here different from the first element*/\n\t\tl_current_poc->layS = (l_current_poc->layE > (l_current_poc-1)->layE) ? l_current_poc->layE : 0;\n\n\t\tl_current_poc->prcE = p_max_prec;\n\t\tl_current_poc->txS = (OPJ_UINT32)p_tx0;\n\t\tl_current_poc->txE = (OPJ_UINT32)p_tx1;\n\t\tl_current_poc->tyS = (OPJ_UINT32)p_ty0;\n\t\tl_current_poc->tyE = (OPJ_UINT32)p_ty1;\n\t\tl_current_poc->dx = p_dx_min;\n\t\tl_current_poc->dy = p_dy_min;\n\t\t++ l_current_poc;\n\t}\n}\n\nvoid opj_pi_update_encode_not_poc (\topj_cp_t *p_cp,\n                                    OPJ_UINT32 p_num_comps,\n                                    OPJ_UINT32 p_tileno,\n                                    OPJ_INT32 p_tx0,\n                                    OPJ_INT32 p_tx1,\n                                    OPJ_INT32 p_ty0,\n                                    OPJ_INT32 p_ty1,\n                                    OPJ_UINT32 p_max_prec,\n                                    OPJ_UINT32 p_max_res,\n                                    OPJ_UINT32 p_dx_min,\n                                    OPJ_UINT32 p_dy_min)\n{\n\t/* loop*/\n\tOPJ_UINT32 pino;\n\t/* tile coding parameter*/\n\topj_tcp_t *l_tcp = 00;\n\t/* current poc being updated*/\n\topj_poc_t * l_current_poc = 00;\n\t/* number of pocs*/\n\tOPJ_UINT32 l_poc_bound;\n\n\t/* preconditions in debug*/\n\tassert(p_cp != 00);\n\tassert(p_tileno < p_cp->tw * p_cp->th);\n\n\t/* initializations*/\n\tl_tcp = &p_cp->tcps [p_tileno];\n\n\t/* number of iterations in the loop */\n\tl_poc_bound = l_tcp->numpocs+1;\n\n\t/* start at first element, and to make sure the compiler will not make a calculation each time in the loop\n\t   store a pointer to the current element to modify rather than l_tcp->pocs[i]*/\n\tl_current_poc = l_tcp->pocs;\n\n\tfor (pino = 0; pino < l_poc_bound ; ++pino) {\n\t\tl_current_poc->compS = 0;\n\t\tl_current_poc->compE = p_num_comps;/*p_image->numcomps;*/\n\t\tl_current_poc->resS = 0;\n\t\tl_current_poc->resE = p_max_res;\n\t\tl_current_poc->layS = 0;\n\t\tl_current_poc->layE = l_tcp->numlayers;\n\t\tl_current_poc->prg  = l_tcp->prg;\n\t\tl_current_poc->prcS = 0;\n\t\tl_current_poc->prcE = p_max_prec;\n\t\tl_current_poc->txS = (OPJ_UINT32)p_tx0;\n\t\tl_current_poc->txE = (OPJ_UINT32)p_tx1;\n\t\tl_current_poc->tyS = (OPJ_UINT32)p_ty0;\n\t\tl_current_poc->tyE = (OPJ_UINT32)p_ty1;\n\t\tl_current_poc->dx = p_dx_min;\n\t\tl_current_poc->dy = p_dy_min;\n\t\t++ l_current_poc;\n\t}\n}\n\nvoid opj_pi_update_decode_poc (opj_pi_iterator_t * p_pi,\n                               opj_tcp_t * p_tcp,\n                               OPJ_UINT32 p_max_precision,\n                               OPJ_UINT32 p_max_res)\n{\n\t/* loop*/\n\tOPJ_UINT32 pino;\n\n\t/* encoding prameters to set*/\n\tOPJ_UINT32 l_bound;\n\n\topj_pi_iterator_t * l_current_pi = 00;\n\topj_poc_t* l_current_poc = 0;\n\n    OPJ_ARG_NOT_USED(p_max_res);\n\n\t/* preconditions in debug*/\n\tassert(p_pi != 00);\n\tassert(p_tcp != 00);\n\n\t/* initializations*/\n\tl_bound = p_tcp->numpocs+1;\n\tl_current_pi = p_pi;\n\tl_current_poc = p_tcp->pocs;\n\n\tfor\t(pino = 0;pino<l_bound;++pino) {\n\t\tl_current_pi->poc.prg = l_current_poc->prg; /* Progression Order #0 */\n\t\tl_current_pi->first = 1;\n\n\t\tl_current_pi->poc.resno0 = l_current_poc->resno0; /* Resolution Level Index #0 (Start) */\n\t\tl_current_pi->poc.compno0 = l_current_poc->compno0; /* Component Index #0 (Start) */\n\t\tl_current_pi->poc.layno0 = 0;\n\t\tl_current_pi->poc.precno0 = 0;\n\t\tl_current_pi->poc.resno1 = l_current_poc->resno1; /* Resolution Level Index #0 (End) */\n\t\tl_current_pi->poc.compno1 = l_current_poc->compno1; /* Component Index #0 (End) */\n\t\tl_current_pi->poc.layno1 = l_current_poc->layno1; /* Layer Index #0 (End) */\n\t\tl_current_pi->poc.precno1 = p_max_precision;\n\t\t++l_current_pi;\n\t\t++l_current_poc;\n\t}\n}\n\nvoid opj_pi_update_decode_not_poc (opj_pi_iterator_t * p_pi,\n                                   opj_tcp_t * p_tcp,\n                                   OPJ_UINT32 p_max_precision,\n                                   OPJ_UINT32 p_max_res)\n{\n\t/* loop*/\n\tOPJ_UINT32 pino;\n\n\t/* encoding prameters to set*/\n\tOPJ_UINT32 l_bound;\n\n\topj_pi_iterator_t * l_current_pi = 00;\n\t/* preconditions in debug*/\n\tassert(p_tcp != 00);\n\tassert(p_pi != 00);\n\n\t/* initializations*/\n\tl_bound = p_tcp->numpocs+1;\n\tl_current_pi = p_pi;\n\n\tfor (pino = 0;pino<l_bound;++pino) {\n\t\tl_current_pi->poc.prg = p_tcp->prg;\n\t\tl_current_pi->first = 1;\n\t\tl_current_pi->poc.resno0 = 0;\n\t\tl_current_pi->poc.compno0 = 0;\n\t\tl_current_pi->poc.layno0 = 0;\n\t\tl_current_pi->poc.precno0 = 0;\n\t\tl_current_pi->poc.resno1 = p_max_res;\n\t\tl_current_pi->poc.compno1 = l_current_pi->numcomps;\n\t\tl_current_pi->poc.layno1 = p_tcp->numlayers;\n\t\tl_current_pi->poc.precno1 = p_max_precision;\n\t\t++l_current_pi;\n\t}\n}\n\n\n\nOPJ_BOOL opj_pi_check_next_level(\tOPJ_INT32 pos,\n\t\t\t\t\t\t\t\topj_cp_t *cp,\n\t\t\t\t\t\t\t\tOPJ_UINT32 tileno,\n\t\t\t\t\t\t\t\tOPJ_UINT32 pino,\n\t\t\t\t\t\t\t\tconst OPJ_CHAR *prog)\n{\n\tOPJ_INT32 i;\n\topj_tcp_t *tcps =&cp->tcps[tileno];\n\topj_poc_t *tcp = &tcps->pocs[pino];\n\n\tif(pos>=0){\n\t\tfor(i=pos;pos>=0;i--){\n\t\t\tswitch(prog[i]){\n\t\t    case 'R':\n\t\t\t    if(tcp->res_t==tcp->resE){\n\t\t\t\t    if(opj_pi_check_next_level(pos-1,cp,tileno,pino,prog)){\n\t\t\t\t\t    return OPJ_TRUE;\n\t\t\t\t    }else{\n\t\t\t\t\t    return OPJ_FALSE;\n\t\t\t\t    }\n\t\t\t    }else{\n\t\t\t\t    return OPJ_TRUE;\n\t\t\t    }\n\t\t\t    break;\n\t\t    case 'C':\n\t\t\t    if(tcp->comp_t==tcp->compE){\n\t\t\t\t    if(opj_pi_check_next_level(pos-1,cp,tileno,pino,prog)){\n\t\t\t\t\t    return OPJ_TRUE;\n\t\t\t\t    }else{\n\t\t\t\t\t    return OPJ_FALSE;\n\t\t\t\t    }\n\t\t\t    }else{\n\t\t\t\t    return OPJ_TRUE;\n\t\t\t    }\n\t\t\t    break;\n\t\t    case 'L':\n\t\t\t    if(tcp->lay_t==tcp->layE){\n\t\t\t\t    if(opj_pi_check_next_level(pos-1,cp,tileno,pino,prog)){\n\t\t\t\t\t    return OPJ_TRUE;\n\t\t\t\t    }else{\n\t\t\t\t\t    return OPJ_FALSE;\n\t\t\t\t    }\n\t\t\t    }else{\n\t\t\t\t    return OPJ_TRUE;\n\t\t\t    }\n\t\t\t    break;\n\t\t    case 'P':\n\t\t\t    switch(tcp->prg){\n                    case OPJ_LRCP: /* fall through */\n                    case OPJ_RLCP:\n\t\t\t\t\t    if(tcp->prc_t == tcp->prcE){\n\t\t\t\t\t\t    if(opj_pi_check_next_level(i-1,cp,tileno,pino,prog)){\n\t\t\t\t\t\t\t    return OPJ_TRUE;\n\t\t\t\t\t\t    }else{\n\t\t\t\t\t\t\t    return OPJ_FALSE;\n\t\t\t\t\t\t    }\n\t\t\t\t\t    }else{\n\t\t\t\t\t\t    return OPJ_TRUE;\n\t\t\t\t\t    }\n\t\t\t\t\t    break;\n\t\t\t    default:\n\t\t\t\t    if(tcp->tx0_t == tcp->txE){\n\t\t\t\t\t    /*TY*/\n\t\t\t\t\t    if(tcp->ty0_t == tcp->tyE){\n\t\t\t\t\t\t    if(opj_pi_check_next_level(i-1,cp,tileno,pino,prog)){\n\t\t\t\t\t\t\t    return OPJ_TRUE;\n\t\t\t\t\t\t    }else{\n\t\t\t\t\t\t\t    return OPJ_FALSE;\n\t\t\t\t\t\t    }\n\t\t\t\t\t    }else{\n\t\t\t\t\t\t    return OPJ_TRUE;\n\t\t\t\t\t    }/*TY*/\n\t\t\t\t    }else{\n\t\t\t\t\t    return OPJ_TRUE;\n\t\t\t\t    }\n\t\t\t\t    break;\n\t\t\t    }/*end case P*/\n\t\t    }/*end switch*/\n\t\t}/*end for*/\n\t}/*end if*/\n\treturn OPJ_FALSE;\n}\n\n\n/*\n==========================================================\n   Packet iterator interface\n==========================================================\n*/\nopj_pi_iterator_t *opj_pi_create_decode(opj_image_t *p_image,\n\t\t\t\t\t\t\t\t\t\topj_cp_t *p_cp,\n\t\t\t\t\t\t\t\t\t\tOPJ_UINT32 p_tile_no)\n{\n\t/* loop */\n\tOPJ_UINT32 pino;\n\tOPJ_UINT32 compno, resno;\n\n\t/* to store w, h, dx and dy fro all components and resolutions */\n\tOPJ_UINT32 * l_tmp_data;\n\tOPJ_UINT32 ** l_tmp_ptr;\n\n\t/* encoding prameters to set */\n\tOPJ_UINT32 l_max_res;\n\tOPJ_UINT32 l_max_prec;\n\tOPJ_INT32 l_tx0,l_tx1,l_ty0,l_ty1;\n\tOPJ_UINT32 l_dx_min,l_dy_min;\n\tOPJ_UINT32 l_bound;\n\tOPJ_UINT32 l_step_p , l_step_c , l_step_r , l_step_l ;\n\tOPJ_UINT32 l_data_stride;\n\n\t/* pointers */\n\topj_pi_iterator_t *l_pi = 00;\n\topj_tcp_t *l_tcp = 00;\n\tconst opj_tccp_t *l_tccp = 00;\n\topj_pi_comp_t *l_current_comp = 00;\n\topj_image_comp_t * l_img_comp = 00;\n\topj_pi_iterator_t * l_current_pi = 00;\n\tOPJ_UINT32 * l_encoding_value_ptr = 00;\n\n\t/* preconditions in debug */\n\tassert(p_cp != 00);\n\tassert(p_image != 00);\n\tassert(p_tile_no < p_cp->tw * p_cp->th);\n\n\t/* initializations */\n\tl_tcp = &p_cp->tcps[p_tile_no];\n\tl_bound = l_tcp->numpocs+1;\n\n\tl_data_stride = 4 * OPJ_J2K_MAXRLVLS;\n\tl_tmp_data = (OPJ_UINT32*)opj_malloc(\n\t\tl_data_stride * p_image->numcomps * sizeof(OPJ_UINT32));\n\tif\n\t\t(! l_tmp_data)\n\t{\n\t\treturn 00;\n\t}\n\tl_tmp_ptr = (OPJ_UINT32**)opj_malloc(\n\t\tp_image->numcomps * sizeof(OPJ_UINT32 *));\n\tif\n\t\t(! l_tmp_ptr)\n\t{\n\t\topj_free(l_tmp_data);\n\t\treturn 00;\n\t}\n\n\t/* memory allocation for pi */\n\tl_pi = opj_pi_create(p_image, p_cp, p_tile_no);\n\tif (!l_pi) {\n\t\topj_free(l_tmp_data);\n\t\topj_free(l_tmp_ptr);\n\t\treturn 00;\n\t}\n\n\tl_encoding_value_ptr = l_tmp_data;\n\t/* update pointer array */\n\tfor\n\t\t(compno = 0; compno < p_image->numcomps; ++compno)\n\t{\n\t\tl_tmp_ptr[compno] = l_encoding_value_ptr;\n\t\tl_encoding_value_ptr += l_data_stride;\n\t}\n\t/* get encoding parameters */\n\topj_get_all_encoding_parameters(p_image,p_cp,p_tile_no,&l_tx0,&l_tx1,&l_ty0,&l_ty1,&l_dx_min,&l_dy_min,&l_max_prec,&l_max_res,l_tmp_ptr);\n\n\t/* step calculations */\n\tl_step_p = 1;\n\tl_step_c = l_max_prec * l_step_p;\n\tl_step_r = p_image->numcomps * l_step_c;\n\tl_step_l = l_max_res * l_step_r;\n\n\t/* set values for first packet iterator */\n\tl_current_pi = l_pi;\n\n\t/* memory allocation for include */\n\tl_current_pi->include = (OPJ_INT16*) opj_calloc((l_tcp->numlayers +1) * l_step_l, sizeof(OPJ_INT16));\n\tif\n\t\t(!l_current_pi->include)\n\t{\n\t\topj_free(l_tmp_data);\n\t\topj_free(l_tmp_ptr);\n\t\topj_pi_destroy(l_pi, l_bound);\n\t\treturn 00;\n\t}\n\n\t/* special treatment for the first packet iterator */\n\tl_current_comp = l_current_pi->comps;\n\tl_img_comp = p_image->comps;\n\tl_tccp = l_tcp->tccps;\n\n\tl_current_pi->tx0 = l_tx0;\n\tl_current_pi->ty0 = l_ty0;\n\tl_current_pi->tx1 = l_tx1;\n\tl_current_pi->ty1 = l_ty1;\n\n\t/*l_current_pi->dx = l_img_comp->dx;*/\n\t/*l_current_pi->dy = l_img_comp->dy;*/\n\n\tl_current_pi->step_p = l_step_p;\n\tl_current_pi->step_c = l_step_c;\n\tl_current_pi->step_r = l_step_r;\n\tl_current_pi->step_l = l_step_l;\n\n\t/* allocation for components and number of components has already been calculated by opj_pi_create */\n\tfor\n\t\t(compno = 0; compno < l_current_pi->numcomps; ++compno)\n\t{\n\t\topj_pi_resolution_t *l_res = l_current_comp->resolutions;\n\t\tl_encoding_value_ptr = l_tmp_ptr[compno];\n\n\t\tl_current_comp->dx = l_img_comp->dx;\n\t\tl_current_comp->dy = l_img_comp->dy;\n\t\t/* resolutions have already been initialized */\n\t\tfor\n\t\t\t(resno = 0; resno < l_current_comp->numresolutions; resno++)\n\t\t{\n\t\t\tl_res->pdx = *(l_encoding_value_ptr++);\n\t\t\tl_res->pdy = *(l_encoding_value_ptr++);\n\t\t\tl_res->pw =  *(l_encoding_value_ptr++);\n\t\t\tl_res->ph =  *(l_encoding_value_ptr++);\n\t\t\t++l_res;\n\t\t}\n\t\t++l_current_comp;\n\t\t++l_img_comp;\n\t\t++l_tccp;\n\t}\n\t++l_current_pi;\n\n\tfor (pino = 1 ; pino<l_bound ; ++pino )\n\t{\n\t\tl_current_comp = l_current_pi->comps;\n\t\tl_img_comp = p_image->comps;\n\t\tl_tccp = l_tcp->tccps;\n\n\t\tl_current_pi->tx0 = l_tx0;\n\t\tl_current_pi->ty0 = l_ty0;\n\t\tl_current_pi->tx1 = l_tx1;\n\t\tl_current_pi->ty1 = l_ty1;\n\t\t/*l_current_pi->dx = l_dx_min;*/\n\t\t/*l_current_pi->dy = l_dy_min;*/\n\t\tl_current_pi->step_p = l_step_p;\n\t\tl_current_pi->step_c = l_step_c;\n\t\tl_current_pi->step_r = l_step_r;\n\t\tl_current_pi->step_l = l_step_l;\n\n\t\t/* allocation for components and number of components has already been calculated by opj_pi_create */\n\t\tfor\n\t\t\t(compno = 0; compno < l_current_pi->numcomps; ++compno)\n\t\t{\n\t\t\topj_pi_resolution_t *l_res = l_current_comp->resolutions;\n\t\t\tl_encoding_value_ptr = l_tmp_ptr[compno];\n\n\t\t\tl_current_comp->dx = l_img_comp->dx;\n\t\t\tl_current_comp->dy = l_img_comp->dy;\n\t\t\t/* resolutions have already been initialized */\n\t\t\tfor\n\t\t\t\t(resno = 0; resno < l_current_comp->numresolutions; resno++)\n\t\t\t{\n\t\t\t\tl_res->pdx = *(l_encoding_value_ptr++);\n\t\t\t\tl_res->pdy = *(l_encoding_value_ptr++);\n\t\t\t\tl_res->pw =  *(l_encoding_value_ptr++);\n\t\t\t\tl_res->ph =  *(l_encoding_value_ptr++);\n\t\t\t\t++l_res;\n\t\t\t}\n\t\t\t++l_current_comp;\n\t\t\t++l_img_comp;\n\t\t\t++l_tccp;\n\t\t}\n\t\t/* special treatment*/\n\t\tl_current_pi->include = (l_current_pi-1)->include;\n\t\t++l_current_pi;\n\t}\n\topj_free(l_tmp_data);\n\tl_tmp_data = 00;\n\topj_free(l_tmp_ptr);\n\tl_tmp_ptr = 00;\n\tif\n\t\t(l_tcp->POC)\n\t{\n\t\topj_pi_update_decode_poc (l_pi,l_tcp,l_max_prec,l_max_res);\n\t}\n\telse\n\t{\n\t\topj_pi_update_decode_not_poc(l_pi,l_tcp,l_max_prec,l_max_res);\n\t}\n\treturn l_pi;\n}\n\n\n\nopj_pi_iterator_t *opj_pi_initialise_encode(const opj_image_t *p_image,\n                                            opj_cp_t *p_cp,\n                                            OPJ_UINT32 p_tile_no,\n                                            J2K_T2_MODE p_t2_mode )\n{\n\t/* loop*/\n\tOPJ_UINT32 pino;\n\tOPJ_UINT32 compno, resno;\n\n\t/* to store w, h, dx and dy fro all components and resolutions*/\n\tOPJ_UINT32 * l_tmp_data;\n\tOPJ_UINT32 ** l_tmp_ptr;\n\n\t/* encoding prameters to set*/\n\tOPJ_UINT32 l_max_res;\n\tOPJ_UINT32 l_max_prec;\n\tOPJ_INT32 l_tx0,l_tx1,l_ty0,l_ty1;\n\tOPJ_UINT32 l_dx_min,l_dy_min;\n\tOPJ_UINT32 l_bound;\n\tOPJ_UINT32 l_step_p , l_step_c , l_step_r , l_step_l ;\n\tOPJ_UINT32 l_data_stride;\n\n\t/* pointers*/\n\topj_pi_iterator_t *l_pi = 00;\n\topj_tcp_t *l_tcp = 00;\n\tconst opj_tccp_t *l_tccp = 00;\n\topj_pi_comp_t *l_current_comp = 00;\n\topj_image_comp_t * l_img_comp = 00;\n\topj_pi_iterator_t * l_current_pi = 00;\n\tOPJ_UINT32 * l_encoding_value_ptr = 00;\n\n\t/* preconditions in debug*/\n\tassert(p_cp != 00);\n\tassert(p_image != 00);\n\tassert(p_tile_no < p_cp->tw * p_cp->th);\n\n\t/* initializations*/\n\tl_tcp = &p_cp->tcps[p_tile_no];\n\tl_bound = l_tcp->numpocs+1;\n\n\tl_data_stride = 4 * OPJ_J2K_MAXRLVLS;\n\tl_tmp_data = (OPJ_UINT32*)opj_malloc(\n\t\tl_data_stride * p_image->numcomps * sizeof(OPJ_UINT32));\n\tif (! l_tmp_data) {\n\t\treturn 00;\n\t}\n\n\tl_tmp_ptr = (OPJ_UINT32**)opj_malloc(\n\t\tp_image->numcomps * sizeof(OPJ_UINT32 *));\n\tif (! l_tmp_ptr) {\n\t\topj_free(l_tmp_data);\n\t\treturn 00;\n\t}\n\n\t/* memory allocation for pi*/\n\tl_pi = opj_pi_create(p_image,p_cp,p_tile_no);\n\tif (!l_pi) {\n\t\topj_free(l_tmp_data);\n\t\topj_free(l_tmp_ptr);\n\t\treturn 00;\n\t}\n\n\tl_encoding_value_ptr = l_tmp_data;\n\t/* update pointer array*/\n\tfor (compno = 0; compno < p_image->numcomps; ++compno) {\n\t\tl_tmp_ptr[compno] = l_encoding_value_ptr;\n\t\tl_encoding_value_ptr += l_data_stride;\n\t}\n\n\t/* get encoding parameters*/\n\topj_get_all_encoding_parameters(p_image,p_cp,p_tile_no,&l_tx0,&l_tx1,&l_ty0,&l_ty1,&l_dx_min,&l_dy_min,&l_max_prec,&l_max_res,l_tmp_ptr);\n\n\t/* step calculations*/\n\tl_step_p = 1;\n\tl_step_c = l_max_prec * l_step_p;\n\tl_step_r = p_image->numcomps * l_step_c;\n\tl_step_l = l_max_res * l_step_r;\n\n\t/* set values for first packet iterator*/\n\tl_pi->tp_on = p_cp->m_specific_param.m_enc.m_tp_on;\n\tl_current_pi = l_pi;\n\n\t/* memory allocation for include*/\n\tl_current_pi->include = (OPJ_INT16*) opj_calloc(l_tcp->numlayers * l_step_l, sizeof(OPJ_INT16));\n\tif (!l_current_pi->include) {\n\t\topj_free(l_tmp_data);\n\t\topj_free(l_tmp_ptr);\n\t\topj_pi_destroy(l_pi, l_bound);\n\t\treturn 00;\n\t}\n\n\t/* special treatment for the first packet iterator*/\n\tl_current_comp = l_current_pi->comps;\n\tl_img_comp = p_image->comps;\n\tl_tccp = l_tcp->tccps;\n\tl_current_pi->tx0 = l_tx0;\n\tl_current_pi->ty0 = l_ty0;\n\tl_current_pi->tx1 = l_tx1;\n\tl_current_pi->ty1 = l_ty1;\n\tl_current_pi->dx = l_dx_min;\n\tl_current_pi->dy = l_dy_min;\n\tl_current_pi->step_p = l_step_p;\n\tl_current_pi->step_c = l_step_c;\n\tl_current_pi->step_r = l_step_r;\n\tl_current_pi->step_l = l_step_l;\n\n\t/* allocation for components and number of components has already been calculated by opj_pi_create */\n\tfor (compno = 0; compno < l_current_pi->numcomps; ++compno) {\n\t\topj_pi_resolution_t *l_res = l_current_comp->resolutions;\n\t\tl_encoding_value_ptr = l_tmp_ptr[compno];\n\n\t\tl_current_comp->dx = l_img_comp->dx;\n\t\tl_current_comp->dy = l_img_comp->dy;\n\n\t\t/* resolutions have already been initialized */\n\t\tfor (resno = 0; resno < l_current_comp->numresolutions; resno++) {\n\t\t\tl_res->pdx = *(l_encoding_value_ptr++);\n\t\t\tl_res->pdy = *(l_encoding_value_ptr++);\n\t\t\tl_res->pw =  *(l_encoding_value_ptr++);\n\t\t\tl_res->ph =  *(l_encoding_value_ptr++);\n\t\t\t++l_res;\n\t\t}\n\n\t\t++l_current_comp;\n\t\t++l_img_comp;\n\t\t++l_tccp;\n\t}\n\t++l_current_pi;\n\n\tfor (pino = 1 ; pino<l_bound ; ++pino ) {\n\t\tl_current_comp = l_current_pi->comps;\n\t\tl_img_comp = p_image->comps;\n\t\tl_tccp = l_tcp->tccps;\n\n\t\tl_current_pi->tx0 = l_tx0;\n\t\tl_current_pi->ty0 = l_ty0;\n\t\tl_current_pi->tx1 = l_tx1;\n\t\tl_current_pi->ty1 = l_ty1;\n\t\tl_current_pi->dx = l_dx_min;\n\t\tl_current_pi->dy = l_dy_min;\n\t\tl_current_pi->step_p = l_step_p;\n\t\tl_current_pi->step_c = l_step_c;\n\t\tl_current_pi->step_r = l_step_r;\n\t\tl_current_pi->step_l = l_step_l;\n\n\t\t/* allocation for components and number of components has already been calculated by opj_pi_create */\n\t\tfor (compno = 0; compno < l_current_pi->numcomps; ++compno) {\n\t\t\topj_pi_resolution_t *l_res = l_current_comp->resolutions;\n\t\t\tl_encoding_value_ptr = l_tmp_ptr[compno];\n\n\t\t\tl_current_comp->dx = l_img_comp->dx;\n\t\t\tl_current_comp->dy = l_img_comp->dy;\n\t\t\t/* resolutions have already been initialized */\n\t\t\tfor (resno = 0; resno < l_current_comp->numresolutions; resno++) {\n\t\t\t\tl_res->pdx = *(l_encoding_value_ptr++);\n\t\t\t\tl_res->pdy = *(l_encoding_value_ptr++);\n\t\t\t\tl_res->pw =  *(l_encoding_value_ptr++);\n\t\t\t\tl_res->ph =  *(l_encoding_value_ptr++);\n\t\t\t\t++l_res;\n\t\t\t}\n\t\t\t++l_current_comp;\n\t\t\t++l_img_comp;\n\t\t\t++l_tccp;\n\t\t}\n\n\t\t/* special treatment*/\n\t\tl_current_pi->include = (l_current_pi-1)->include;\n\t\t++l_current_pi;\n\t}\n\n\topj_free(l_tmp_data);\n\tl_tmp_data = 00;\n\topj_free(l_tmp_ptr);\n\tl_tmp_ptr = 00;\n\n    if (l_tcp->POC && (OPJ_IS_CINEMA(p_cp->rsiz) || p_t2_mode == FINAL_PASS)) {\n\t\topj_pi_update_encode_poc_and_final(p_cp,p_tile_no,l_tx0,l_tx1,l_ty0,l_ty1,l_max_prec,l_max_res,l_dx_min,l_dy_min);\n\t}\n\telse {\n\t\topj_pi_update_encode_not_poc(p_cp,p_image->numcomps,p_tile_no,l_tx0,l_tx1,l_ty0,l_ty1,l_max_prec,l_max_res,l_dx_min,l_dy_min);\n\t}\n\n\treturn l_pi;\n}\n\nvoid opj_pi_create_encode( \topj_pi_iterator_t *pi,\n\t\t\t\t\t\t\topj_cp_t *cp,\n\t\t\t\t\t\t\tOPJ_UINT32 tileno,\n\t\t\t\t\t\t\tOPJ_UINT32 pino,\n\t\t\t\t\t\t\tOPJ_UINT32 tpnum,\n\t\t\t\t\t\t\tOPJ_INT32 tppos,\n\t\t\t\t\t\t\tJ2K_T2_MODE t2_mode)\n{\n\tconst OPJ_CHAR *prog;\n\tOPJ_INT32 i;\n\tOPJ_UINT32 incr_top=1,resetX=0;\n\topj_tcp_t *tcps =&cp->tcps[tileno];\n\topj_poc_t *tcp= &tcps->pocs[pino];\n\n\tprog = opj_j2k_convert_progression_order(tcp->prg);\n\n\tpi[pino].first = 1;\n\tpi[pino].poc.prg = tcp->prg;\n\n    if(!(cp->m_specific_param.m_enc.m_tp_on && ((!OPJ_IS_CINEMA(cp->rsiz) && (t2_mode == FINAL_PASS)) || OPJ_IS_CINEMA(cp->rsiz)))){\n\t\tpi[pino].poc.resno0 = tcp->resS;\n\t\tpi[pino].poc.resno1 = tcp->resE;\n\t\tpi[pino].poc.compno0 = tcp->compS;\n\t\tpi[pino].poc.compno1 = tcp->compE;\n\t\tpi[pino].poc.layno0 = tcp->layS;\n\t\tpi[pino].poc.layno1 = tcp->layE;\n\t\tpi[pino].poc.precno0 = tcp->prcS;\n\t\tpi[pino].poc.precno1 = tcp->prcE;\n\t\tpi[pino].poc.tx0 = (OPJ_INT32)tcp->txS;\n\t\tpi[pino].poc.ty0 = (OPJ_INT32)tcp->tyS;\n\t\tpi[pino].poc.tx1 = (OPJ_INT32)tcp->txE;\n\t\tpi[pino].poc.ty1 = (OPJ_INT32)tcp->tyE;\n\t}else {\n\t\tfor(i=tppos+1;i<4;i++){\n\t\t\tswitch(prog[i]){\n\t\t\tcase 'R':\n\t\t\t\tpi[pino].poc.resno0 = tcp->resS;\n\t\t\t\tpi[pino].poc.resno1 = tcp->resE;\n\t\t\t\tbreak;\n\t\t\tcase 'C':\n\t\t\t\tpi[pino].poc.compno0 = tcp->compS;\n\t\t\t\tpi[pino].poc.compno1 = tcp->compE;\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\tpi[pino].poc.layno0 = tcp->layS;\n\t\t\t\tpi[pino].poc.layno1 = tcp->layE;\n\t\t\t\tbreak;\n\t\t\tcase 'P':\n\t\t\t\tswitch(tcp->prg){\n\t\t\t\tcase OPJ_LRCP:\n\t\t\t\tcase OPJ_RLCP:\n\t\t\t\t\tpi[pino].poc.precno0 = tcp->prcS;\n\t\t\t\t\tpi[pino].poc.precno1 = tcp->prcE;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tpi[pino].poc.tx0 = (OPJ_INT32)tcp->txS;\n\t\t\t\t\tpi[pino].poc.ty0 = (OPJ_INT32)tcp->tyS;\n\t\t\t\t\tpi[pino].poc.tx1 = (OPJ_INT32)tcp->txE;\n\t\t\t\t\tpi[pino].poc.ty1 = (OPJ_INT32)tcp->tyE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(tpnum==0){\n\t\t\tfor(i=tppos;i>=0;i--){\n\t\t\t\tswitch(prog[i]){\n\t\t\t\tcase 'C':\n\t\t\t\t\ttcp->comp_t = tcp->compS;\n\t\t\t\t\tpi[pino].poc.compno0 = tcp->comp_t;\n\t\t\t\t\tpi[pino].poc.compno1 = tcp->comp_t+1;\n\t\t\t\t\ttcp->comp_t+=1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\ttcp->res_t = tcp->resS;\n\t\t\t\t\tpi[pino].poc.resno0 = tcp->res_t;\n\t\t\t\t\tpi[pino].poc.resno1 = tcp->res_t+1;\n\t\t\t\t\ttcp->res_t+=1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'L':\n\t\t\t\t\ttcp->lay_t = tcp->layS;\n\t\t\t\t\tpi[pino].poc.layno0 = tcp->lay_t;\n\t\t\t\t\tpi[pino].poc.layno1 = tcp->lay_t+1;\n\t\t\t\t\ttcp->lay_t+=1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'P':\n\t\t\t\t\tswitch(tcp->prg){\n\t\t\t\t\tcase OPJ_LRCP:\n\t\t\t\t\tcase OPJ_RLCP:\n\t\t\t\t\t\ttcp->prc_t = tcp->prcS;\n\t\t\t\t\t\tpi[pino].poc.precno0 = tcp->prc_t;\n\t\t\t\t\t\tpi[pino].poc.precno1 = tcp->prc_t+1;\n\t\t\t\t\t\ttcp->prc_t+=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\ttcp->tx0_t = tcp->txS;\n\t\t\t\t\t\ttcp->ty0_t = tcp->tyS;\n\t\t\t\t\t\tpi[pino].poc.tx0 = (OPJ_INT32)tcp->tx0_t;\n\t\t\t\t\t\tpi[pino].poc.tx1 = (OPJ_INT32)(tcp->tx0_t + tcp->dx - (tcp->tx0_t % tcp->dx));\n\t\t\t\t\t\tpi[pino].poc.ty0 = (OPJ_INT32)tcp->ty0_t;\n\t\t\t\t\t\tpi[pino].poc.ty1 = (OPJ_INT32)(tcp->ty0_t + tcp->dy - (tcp->ty0_t % tcp->dy));\n\t\t\t\t\t\ttcp->tx0_t = (OPJ_UINT32)pi[pino].poc.tx1;\n\t\t\t\t\t\ttcp->ty0_t = (OPJ_UINT32)pi[pino].poc.ty1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tincr_top=1;\n\t\t}else{\n\t\t\tfor(i=tppos;i>=0;i--){\n\t\t\t\tswitch(prog[i]){\n\t\t\t\tcase 'C':\n\t\t\t\t\tpi[pino].poc.compno0 = tcp->comp_t-1;\n\t\t\t\t\tpi[pino].poc.compno1 = tcp->comp_t;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tpi[pino].poc.resno0 = tcp->res_t-1;\n\t\t\t\t\tpi[pino].poc.resno1 = tcp->res_t;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'L':\n\t\t\t\t\tpi[pino].poc.layno0 = tcp->lay_t-1;\n\t\t\t\t\tpi[pino].poc.layno1 = tcp->lay_t;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'P':\n\t\t\t\t\tswitch(tcp->prg){\n\t\t\t\t\tcase OPJ_LRCP:\n\t\t\t\t\tcase OPJ_RLCP:\n\t\t\t\t\t\tpi[pino].poc.precno0 = tcp->prc_t-1;\n\t\t\t\t\t\tpi[pino].poc.precno1 = tcp->prc_t;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tpi[pino].poc.tx0 = (OPJ_INT32)(tcp->tx0_t - tcp->dx - (tcp->tx0_t % tcp->dx));\n\t\t\t\t\t\tpi[pino].poc.tx1 = (OPJ_INT32)tcp->tx0_t ;\n\t\t\t\t\t\tpi[pino].poc.ty0 = (OPJ_INT32)(tcp->ty0_t - tcp->dy - (tcp->ty0_t % tcp->dy));\n\t\t\t\t\t\tpi[pino].poc.ty1 = (OPJ_INT32)tcp->ty0_t ;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(incr_top==1){\n\t\t\t\t\tswitch(prog[i]){\n\t\t\t\t\tcase 'R':\n\t\t\t\t\t\tif(tcp->res_t==tcp->resE){\n\t\t\t\t\t\t\tif(opj_pi_check_next_level(i-1,cp,tileno,pino,prog)){\n\t\t\t\t\t\t\t\ttcp->res_t = tcp->resS;\n\t\t\t\t\t\t\t\tpi[pino].poc.resno0 = tcp->res_t;\n\t\t\t\t\t\t\t\tpi[pino].poc.resno1 = tcp->res_t+1;\n\t\t\t\t\t\t\t\ttcp->res_t+=1;\n\t\t\t\t\t\t\t\tincr_top=1;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tincr_top=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tpi[pino].poc.resno0 = tcp->res_t;\n\t\t\t\t\t\t\tpi[pino].poc.resno1 = tcp->res_t+1;\n\t\t\t\t\t\t\ttcp->res_t+=1;\n\t\t\t\t\t\t\tincr_top=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'C':\n\t\t\t\t\t\tif(tcp->comp_t ==tcp->compE){\n\t\t\t\t\t\t\tif(opj_pi_check_next_level(i-1,cp,tileno,pino,prog)){\n\t\t\t\t\t\t\t\ttcp->comp_t = tcp->compS;\n\t\t\t\t\t\t\t\tpi[pino].poc.compno0 = tcp->comp_t;\n\t\t\t\t\t\t\t\tpi[pino].poc.compno1 = tcp->comp_t+1;\n\t\t\t\t\t\t\t\ttcp->comp_t+=1;\n\t\t\t\t\t\t\t\tincr_top=1;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tincr_top=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tpi[pino].poc.compno0 = tcp->comp_t;\n\t\t\t\t\t\t\tpi[pino].poc.compno1 = tcp->comp_t+1;\n\t\t\t\t\t\t\ttcp->comp_t+=1;\n\t\t\t\t\t\t\tincr_top=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'L':\n\t\t\t\t\t\tif(tcp->lay_t == tcp->layE){\n\t\t\t\t\t\t\tif(opj_pi_check_next_level(i-1,cp,tileno,pino,prog)){\n\t\t\t\t\t\t\t\ttcp->lay_t = tcp->layS;\n\t\t\t\t\t\t\t\tpi[pino].poc.layno0 = tcp->lay_t;\n\t\t\t\t\t\t\t\tpi[pino].poc.layno1 = tcp->lay_t+1;\n\t\t\t\t\t\t\t\ttcp->lay_t+=1;\n\t\t\t\t\t\t\t\tincr_top=1;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tincr_top=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tpi[pino].poc.layno0 = tcp->lay_t;\n\t\t\t\t\t\t\tpi[pino].poc.layno1 = tcp->lay_t+1;\n\t\t\t\t\t\t\ttcp->lay_t+=1;\n\t\t\t\t\t\t\tincr_top=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'P':\n\t\t\t\t\t\tswitch(tcp->prg){\n\t\t\t\t\t\tcase OPJ_LRCP:\n\t\t\t\t\t\tcase OPJ_RLCP:\n\t\t\t\t\t\t\tif(tcp->prc_t == tcp->prcE){\n\t\t\t\t\t\t\t\tif(opj_pi_check_next_level(i-1,cp,tileno,pino,prog)){\n\t\t\t\t\t\t\t\t\ttcp->prc_t = tcp->prcS;\n\t\t\t\t\t\t\t\t\tpi[pino].poc.precno0 = tcp->prc_t;\n\t\t\t\t\t\t\t\t\tpi[pino].poc.precno1 = tcp->prc_t+1;\n\t\t\t\t\t\t\t\t\ttcp->prc_t+=1;\n\t\t\t\t\t\t\t\t\tincr_top=1;\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\tincr_top=0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tpi[pino].poc.precno0 = tcp->prc_t;\n\t\t\t\t\t\t\t\tpi[pino].poc.precno1 = tcp->prc_t+1;\n\t\t\t\t\t\t\t\ttcp->prc_t+=1;\n\t\t\t\t\t\t\t\tincr_top=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tif(tcp->tx0_t >= tcp->txE){\n\t\t\t\t\t\t\t\tif(tcp->ty0_t >= tcp->tyE){\n\t\t\t\t\t\t\t\t\tif(opj_pi_check_next_level(i-1,cp,tileno,pino,prog)){\n\t\t\t\t\t\t\t\t\t\ttcp->ty0_t = tcp->tyS;\n\t\t\t\t\t\t\t\t\t\tpi[pino].poc.ty0 = (OPJ_INT32)tcp->ty0_t;\n\t\t\t\t\t\t\t\t\t\tpi[pino].poc.ty1 = (OPJ_INT32)(tcp->ty0_t + tcp->dy - (tcp->ty0_t % tcp->dy));\n\t\t\t\t\t\t\t\t\t\ttcp->ty0_t = (OPJ_UINT32)pi[pino].poc.ty1;\n\t\t\t\t\t\t\t\t\t\tincr_top=1;resetX=1;\n\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\tincr_top=0;resetX=0;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\tpi[pino].poc.ty0 = (OPJ_INT32)tcp->ty0_t;\n\t\t\t\t\t\t\t\t\tpi[pino].poc.ty1 = (OPJ_INT32)(tcp->ty0_t + tcp->dy - (tcp->ty0_t % tcp->dy));\n\t\t\t\t\t\t\t\t\ttcp->ty0_t = (OPJ_UINT32)pi[pino].poc.ty1;\n\t\t\t\t\t\t\t\t\tincr_top=0;resetX=1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(resetX==1){\n\t\t\t\t\t\t\t\t\ttcp->tx0_t = tcp->txS;\n\t\t\t\t\t\t\t\t\tpi[pino].poc.tx0 = (OPJ_INT32)tcp->tx0_t;\n\t\t\t\t\t\t\t\t\tpi[pino].poc.tx1 = (OPJ_INT32)(tcp->tx0_t + tcp->dx- (tcp->tx0_t % tcp->dx));\n\t\t\t\t\t\t\t\t\ttcp->tx0_t = (OPJ_UINT32)pi[pino].poc.tx1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tpi[pino].poc.tx0 = (OPJ_INT32)tcp->tx0_t;\n\t\t\t\t\t\t\t\tpi[pino].poc.tx1 = (OPJ_INT32)(tcp->tx0_t + tcp->dx- (tcp->tx0_t % tcp->dx));\n\t\t\t\t\t\t\t\ttcp->tx0_t = (OPJ_UINT32)pi[pino].poc.tx1;\n\t\t\t\t\t\t\t\tincr_top=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid opj_pi_destroy(opj_pi_iterator_t *p_pi,\n                    OPJ_UINT32 p_nb_elements)\n{\n\tOPJ_UINT32 compno, pino;\n\topj_pi_iterator_t *l_current_pi = p_pi;\n    if (p_pi) {\n\t\tif (p_pi->include) {\n\t\t\topj_free(p_pi->include);\n\t\t\tp_pi->include = 00;\n\t\t}\n\t\tfor (pino = 0; pino < p_nb_elements; ++pino){\n\t\t\tif(l_current_pi->comps) {\n\t\t\t\topj_pi_comp_t *l_current_component = l_current_pi->comps;\n                for (compno = 0; compno < l_current_pi->numcomps; compno++){\n                    if(l_current_component->resolutions) {\n\t\t\t\t\t\topj_free(l_current_component->resolutions);\n\t\t\t\t\t\tl_current_component->resolutions = 00;\n\t\t\t\t\t}\n\n\t\t\t\t\t++l_current_component;\n\t\t\t\t}\n\t\t\t\topj_free(l_current_pi->comps);\n\t\t\t\tl_current_pi->comps = 0;\n\t\t\t}\n\t\t\t++l_current_pi;\n\t\t}\n\t\topj_free(p_pi);\n\t}\n}\n\n\n\nvoid opj_pi_update_encoding_parameters(\tconst opj_image_t *p_image,\n                                        opj_cp_t *p_cp,\n                                        OPJ_UINT32 p_tile_no )\n{\n\t/* encoding parameters to set */\n\tOPJ_UINT32 l_max_res;\n\tOPJ_UINT32 l_max_prec;\n\tOPJ_INT32 l_tx0,l_tx1,l_ty0,l_ty1;\n\tOPJ_UINT32 l_dx_min,l_dy_min;\n\n\t/* pointers */\n\topj_tcp_t *l_tcp = 00;\n\n\t/* preconditions */\n\tassert(p_cp != 00);\n\tassert(p_image != 00);\n\tassert(p_tile_no < p_cp->tw * p_cp->th);\n\n\tl_tcp = &(p_cp->tcps[p_tile_no]);\n\n\t/* get encoding parameters */\n\topj_get_encoding_parameters(p_image,p_cp,p_tile_no,&l_tx0,&l_tx1,&l_ty0,&l_ty1,&l_dx_min,&l_dy_min,&l_max_prec,&l_max_res);\n\n\tif (l_tcp->POC) {\n\t\topj_pi_update_encode_poc_and_final(p_cp,p_tile_no,l_tx0,l_tx1,l_ty0,l_ty1,l_max_prec,l_max_res,l_dx_min,l_dy_min);\n\t}\n\telse {\n\t\topj_pi_update_encode_not_poc(p_cp,p_image->numcomps,p_tile_no,l_tx0,l_tx1,l_ty0,l_ty1,l_max_prec,l_max_res,l_dx_min,l_dy_min);\n\t}\n}\n\nOPJ_BOOL opj_pi_next(opj_pi_iterator_t * pi) {\n\tswitch (pi->poc.prg) {\n\t\tcase OPJ_LRCP:\n\t\t\treturn opj_pi_next_lrcp(pi);\n\t\tcase OPJ_RLCP:\n\t\t\treturn opj_pi_next_rlcp(pi);\n\t\tcase OPJ_RPCL:\n\t\t\treturn opj_pi_next_rpcl(pi);\n\t\tcase OPJ_PCRL:\n\t\t\treturn opj_pi_next_pcrl(pi);\n\t\tcase OPJ_CPRL:\n\t\t\treturn opj_pi_next_cprl(pi);\n\t\tcase OPJ_PROG_UNKNOWN:\n\t\t\treturn OPJ_FALSE;\n\t}\n\t\n\treturn OPJ_FALSE;\n}\n", "/*\n * The copyright in this software is being made available under the 2-clauses \n * BSD License, included below. This software may be subject to other third \n * party and contributor rights, including patent rights, and no such rights\n * are granted under this license.\n *\n * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium\n * Copyright (c) 2002-2014, Professor Benoit Macq\n * Copyright (c) 2001-2003, David Janssens\n * Copyright (c) 2002-2003, Yannick Verschueren\n * Copyright (c) 2003-2007, Francois-Olivier Devaux \n * Copyright (c) 2003-2014, Antonin Descampe\n * Copyright (c) 2005, Herve Drolon, FreeImage Team\n * Copyright (c) 2006-2007, Parvatha Elangovan\n * Copyright (c) 2008, 2011-2012, Centre National d'Etudes Spatiales (CNES), FR \n * Copyright (c) 2012, CS Systemes d'Information, France\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"opj_includes.h\"\n\n/* ----------------------------------------------------------------------- */\n\n/* TODO MSD: */\n#ifdef TODO_MSD \nvoid tcd_dump(FILE *fd, opj_tcd_t *tcd, opj_tcd_image_t * img) {\n        int tileno, compno, resno, bandno, precno;/*, cblkno;*/\n\n        fprintf(fd, \"image {\\n\");\n        fprintf(fd, \"  tw=%d, th=%d x0=%d x1=%d y0=%d y1=%d\\n\", \n                img->tw, img->th, tcd->image->x0, tcd->image->x1, tcd->image->y0, tcd->image->y1);\n\n        for (tileno = 0; tileno < img->th * img->tw; tileno++) {\n                opj_tcd_tile_t *tile = &tcd->tcd_image->tiles[tileno];\n                fprintf(fd, \"  tile {\\n\");\n                fprintf(fd, \"    x0=%d, y0=%d, x1=%d, y1=%d, numcomps=%d\\n\",\n                        tile->x0, tile->y0, tile->x1, tile->y1, tile->numcomps);\n                for (compno = 0; compno < tile->numcomps; compno++) {\n                        opj_tcd_tilecomp_t *tilec = &tile->comps[compno];\n                        fprintf(fd, \"    tilec {\\n\");\n                        fprintf(fd,\n                                \"      x0=%d, y0=%d, x1=%d, y1=%d, numresolutions=%d\\n\",\n                                tilec->x0, tilec->y0, tilec->x1, tilec->y1, tilec->numresolutions);\n                        for (resno = 0; resno < tilec->numresolutions; resno++) {\n                                opj_tcd_resolution_t *res = &tilec->resolutions[resno];\n                                fprintf(fd, \"\\n   res {\\n\");\n                                fprintf(fd,\n                                        \"          x0=%d, y0=%d, x1=%d, y1=%d, pw=%d, ph=%d, numbands=%d\\n\",\n                                        res->x0, res->y0, res->x1, res->y1, res->pw, res->ph, res->numbands);\n                                for (bandno = 0; bandno < res->numbands; bandno++) {\n                                        opj_tcd_band_t *band = &res->bands[bandno];\n                                        fprintf(fd, \"        band {\\n\");\n                                        fprintf(fd,\n                                                \"          x0=%d, y0=%d, x1=%d, y1=%d, stepsize=%f, numbps=%d\\n\",\n                                                band->x0, band->y0, band->x1, band->y1, band->stepsize, band->numbps);\n                                        for (precno = 0; precno < res->pw * res->ph; precno++) {\n                                                opj_tcd_precinct_t *prec = &band->precincts[precno];\n                                                fprintf(fd, \"          prec {\\n\");\n                                                fprintf(fd,\n                                                        \"            x0=%d, y0=%d, x1=%d, y1=%d, cw=%d, ch=%d\\n\",\n                                                        prec->x0, prec->y0, prec->x1, prec->y1, prec->cw, prec->ch);\n                                                /*\n                                                for (cblkno = 0; cblkno < prec->cw * prec->ch; cblkno++) {\n                                                        opj_tcd_cblk_t *cblk = &prec->cblks[cblkno];\n                                                        fprintf(fd, \"            cblk {\\n\");\n                                                        fprintf(fd,\n                                                                \"              x0=%d, y0=%d, x1=%d, y1=%d\\n\",\n                                                                cblk->x0, cblk->y0, cblk->x1, cblk->y1);\n                                                        fprintf(fd, \"            }\\n\");\n                                                }\n                                                */\n                                                fprintf(fd, \"          }\\n\");\n                                        }\n                                        fprintf(fd, \"        }\\n\");\n                                }\n                                fprintf(fd, \"      }\\n\");\n                        }\n                        fprintf(fd, \"    }\\n\");\n                }\n                fprintf(fd, \"  }\\n\");\n        }\n        fprintf(fd, \"}\\n\");\n}\n#endif\n\n/**\n * Initializes tile coding/decoding\n */\nstatic INLINE OPJ_BOOL opj_tcd_init_tile(opj_tcd_t *p_tcd, OPJ_UINT32 p_tile_no, OPJ_BOOL isEncoder, OPJ_FLOAT32 fraction, OPJ_SIZE_T sizeof_block);\n\n/**\n* Allocates memory for a decoding code block.\n*/\nstatic OPJ_BOOL opj_tcd_code_block_dec_allocate (opj_tcd_cblk_dec_t * p_code_block);\n\n/**\n * Deallocates the decoding data of the given precinct.\n */\nstatic void opj_tcd_code_block_dec_deallocate (opj_tcd_precinct_t * p_precinct);\n\n/**\n * Allocates memory for an encoding code block (but not data).\n */\nstatic OPJ_BOOL opj_tcd_code_block_enc_allocate (opj_tcd_cblk_enc_t * p_code_block);\n\n/**\n * Allocates data for an encoding code block\n */\nstatic OPJ_BOOL opj_tcd_code_block_enc_allocate_data (opj_tcd_cblk_enc_t * p_code_block);\n\n/**\n * Deallocates the encoding data of the given precinct.\n */\nstatic void opj_tcd_code_block_enc_deallocate (opj_tcd_precinct_t * p_precinct);\n\n\n/**\nFree the memory allocated for encoding\n@param tcd TCD handle\n*/\nstatic void opj_tcd_free_tile(opj_tcd_t *tcd);\n\n\nstatic OPJ_BOOL opj_tcd_t2_decode ( opj_tcd_t *p_tcd,\n                                    OPJ_BYTE * p_src_data,\n                                    OPJ_UINT32 * p_data_read,\n                                    OPJ_UINT32 p_max_src_size,\n                                    opj_codestream_index_t *p_cstr_index );\n\nstatic OPJ_BOOL opj_tcd_t1_decode (opj_tcd_t *p_tcd);\n\nstatic OPJ_BOOL opj_tcd_dwt_decode (opj_tcd_t *p_tcd);\n\nstatic OPJ_BOOL opj_tcd_mct_decode (opj_tcd_t *p_tcd);\n\nstatic OPJ_BOOL opj_tcd_dc_level_shift_decode (opj_tcd_t *p_tcd);\n\n\nstatic OPJ_BOOL opj_tcd_dc_level_shift_encode ( opj_tcd_t *p_tcd );\n\nstatic OPJ_BOOL opj_tcd_mct_encode ( opj_tcd_t *p_tcd );\n\nstatic OPJ_BOOL opj_tcd_dwt_encode ( opj_tcd_t *p_tcd );\n\nstatic OPJ_BOOL opj_tcd_t1_encode ( opj_tcd_t *p_tcd );\n\nstatic OPJ_BOOL opj_tcd_t2_encode (     opj_tcd_t *p_tcd,\n                                                                    OPJ_BYTE * p_dest_data,\n                                                                    OPJ_UINT32 * p_data_written,\n                                                                    OPJ_UINT32 p_max_dest_size,\n                                                                    opj_codestream_info_t *p_cstr_info );\n\nstatic OPJ_BOOL opj_tcd_rate_allocate_encode(   opj_tcd_t *p_tcd,\n                                                                                        OPJ_BYTE * p_dest_data,\n                                                                                        OPJ_UINT32 p_max_dest_size,\n                                                                                        opj_codestream_info_t *p_cstr_info );\n\n/* ----------------------------------------------------------------------- */\n\n/**\nCreate a new TCD handle\n*/\nopj_tcd_t* opj_tcd_create(OPJ_BOOL p_is_decoder)\n{\n        opj_tcd_t *l_tcd = 00;\n\n        /* create the tcd structure */\n        l_tcd = (opj_tcd_t*) opj_calloc(1,sizeof(opj_tcd_t));\n        if (!l_tcd) {\n                return 00;\n        }\n\n        l_tcd->m_is_decoder = p_is_decoder ? 1 : 0;\n\n        l_tcd->tcd_image = (opj_tcd_image_t*)opj_calloc(1,sizeof(opj_tcd_image_t));\n        if (!l_tcd->tcd_image) {\n                opj_free(l_tcd);\n                return 00;\n        }\n\n        return l_tcd;\n}\n\n\n/* ----------------------------------------------------------------------- */\n\nvoid opj_tcd_rateallocate_fixed(opj_tcd_t *tcd) {\n        OPJ_UINT32 layno;\n\n        for (layno = 0; layno < tcd->tcp->numlayers; layno++) {\n                opj_tcd_makelayer_fixed(tcd, layno, 1);\n        }\n}\n\n\nvoid opj_tcd_makelayer( opj_tcd_t *tcd,\n                                                OPJ_UINT32 layno,\n                                                OPJ_FLOAT64 thresh,\n                                                OPJ_UINT32 final)\n{\n        OPJ_UINT32 compno, resno, bandno, precno, cblkno;\n        OPJ_UINT32 passno;\n\n        opj_tcd_tile_t *tcd_tile = tcd->tcd_image->tiles;\n\n        tcd_tile->distolayer[layno] = 0;        /* fixed_quality */\n\n        for (compno = 0; compno < tcd_tile->numcomps; compno++) {\n                opj_tcd_tilecomp_t *tilec = &tcd_tile->comps[compno];\n\n                for (resno = 0; resno < tilec->numresolutions; resno++) {\n                        opj_tcd_resolution_t *res = &tilec->resolutions[resno];\n\n                        for (bandno = 0; bandno < res->numbands; bandno++) {\n                                opj_tcd_band_t *band = &res->bands[bandno];\n\n                                for (precno = 0; precno < res->pw * res->ph; precno++) {\n                                        opj_tcd_precinct_t *prc = &band->precincts[precno];\n\n                                        for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {\n                                                opj_tcd_cblk_enc_t *cblk = &prc->cblks.enc[cblkno];\n                                                opj_tcd_layer_t *layer = &cblk->layers[layno];\n                                                OPJ_UINT32 n;\n\n                                                if (layno == 0) {\n                                                        cblk->numpassesinlayers = 0;\n                                                }\n\n                                                n = cblk->numpassesinlayers;\n\n                                                for (passno = cblk->numpassesinlayers; passno < cblk->totalpasses; passno++) {\n                                                        OPJ_UINT32 dr;\n                                                        OPJ_FLOAT64 dd;\n                                                        opj_tcd_pass_t *pass = &cblk->passes[passno];\n\n                                                        if (n == 0) {\n                                                                dr = pass->rate;\n                                                                dd = pass->distortiondec;\n                                                        } else {\n                                                                dr = pass->rate - cblk->passes[n - 1].rate;\n                                                                dd = pass->distortiondec - cblk->passes[n - 1].distortiondec;\n                                                        }\n\n                                                        if (!dr) {\n                                                                if (dd != 0)\n                                                                        n = passno + 1;\n                                                                continue;\n                                                        }\n                                                        if (dd / dr >= thresh)\n                                                                n = passno + 1;\n                                                }\n\n                                                layer->numpasses = n - cblk->numpassesinlayers;\n\n                                                if (!layer->numpasses) {\n                                                        layer->disto = 0;\n                                                        continue;\n                                                }\n\n                                                if (cblk->numpassesinlayers == 0) {\n                                                        layer->len = cblk->passes[n - 1].rate;\n                                                        layer->data = cblk->data;\n                                                        layer->disto = cblk->passes[n - 1].distortiondec;\n                                                } else {\n                                                        layer->len = cblk->passes[n - 1].rate - cblk->passes[cblk->numpassesinlayers - 1].rate;\n                                                        layer->data = cblk->data + cblk->passes[cblk->numpassesinlayers - 1].rate;\n                                                        layer->disto = cblk->passes[n - 1].distortiondec - cblk->passes[cblk->numpassesinlayers - 1].distortiondec;\n                                                }\n\n                                                tcd_tile->distolayer[layno] += layer->disto;    /* fixed_quality */\n\n                                                if (final)\n                                                        cblk->numpassesinlayers = n;\n                                        }\n                                }\n                        }\n                }\n        }\n}\n\nvoid opj_tcd_makelayer_fixed(opj_tcd_t *tcd, OPJ_UINT32 layno, OPJ_UINT32 final) {\n        OPJ_UINT32 compno, resno, bandno, precno, cblkno;\n        OPJ_INT32 value;                        /*, matrice[tcd_tcp->numlayers][tcd_tile->comps[0].numresolutions][3]; */\n        OPJ_INT32 matrice[10][10][3];\n        OPJ_UINT32 i, j, k;\n\n        opj_cp_t *cp = tcd->cp;\n        opj_tcd_tile_t *tcd_tile = tcd->tcd_image->tiles;\n        opj_tcp_t *tcd_tcp = tcd->tcp;\n\n        for (compno = 0; compno < tcd_tile->numcomps; compno++) {\n                opj_tcd_tilecomp_t *tilec = &tcd_tile->comps[compno];\n\n                for (i = 0; i < tcd_tcp->numlayers; i++) {\n                        for (j = 0; j < tilec->numresolutions; j++) {\n                                for (k = 0; k < 3; k++) {\n                                        matrice[i][j][k] =\n                                                (OPJ_INT32) ((OPJ_FLOAT32)cp->m_specific_param.m_enc.m_matrice[i * tilec->numresolutions * 3 + j * 3 + k]\n                                                * (OPJ_FLOAT32) (tcd->image->comps[compno].prec / 16.0));\n                                }\n                        }\n                }\n\n                for (resno = 0; resno < tilec->numresolutions; resno++) {\n                        opj_tcd_resolution_t *res = &tilec->resolutions[resno];\n\n                        for (bandno = 0; bandno < res->numbands; bandno++) {\n                                opj_tcd_band_t *band = &res->bands[bandno];\n\n                                for (precno = 0; precno < res->pw * res->ph; precno++) {\n                                        opj_tcd_precinct_t *prc = &band->precincts[precno];\n\n                                        for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {\n                                                opj_tcd_cblk_enc_t *cblk = &prc->cblks.enc[cblkno];\n                                                opj_tcd_layer_t *layer = &cblk->layers[layno];\n                                                OPJ_UINT32 n;\n                                                OPJ_INT32 imsb = (OPJ_INT32)(tcd->image->comps[compno].prec - cblk->numbps); /* number of bit-plan equal to zero */\n\n                                                /* Correction of the matrix of coefficient to include the IMSB information */\n                                                if (layno == 0) {\n                                                        value = matrice[layno][resno][bandno];\n                                                        if (imsb >= value) {\n                                                                value = 0;\n                                                        } else {\n                                                                value -= imsb;\n                                                        }\n                                                } else {\n                                                        value = matrice[layno][resno][bandno] - matrice[layno - 1][resno][bandno];\n                                                        if (imsb >= matrice[layno - 1][resno][bandno]) {\n                                                                value -= (imsb - matrice[layno - 1][resno][bandno]);\n                                                                if (value < 0) {\n                                                                        value = 0;\n                                                                }\n                                                        }\n                                                }\n\n                                                if (layno == 0) {\n                                                        cblk->numpassesinlayers = 0;\n                                                }\n\n                                                n = cblk->numpassesinlayers;\n                                                if (cblk->numpassesinlayers == 0) {\n                                                        if (value != 0) {\n                                                                n = 3 * (OPJ_UINT32)value - 2 + cblk->numpassesinlayers;\n                                                        } else {\n                                                                n = cblk->numpassesinlayers;\n                                                        }\n                                                } else {\n                                                        n = 3 * (OPJ_UINT32)value + cblk->numpassesinlayers;\n                                                }\n\n                                                layer->numpasses = n - cblk->numpassesinlayers;\n\n                                                if (!layer->numpasses)\n                                                        continue;\n\n                                                if (cblk->numpassesinlayers == 0) {\n                                                        layer->len = cblk->passes[n - 1].rate;\n                                                        layer->data = cblk->data;\n                                                } else {\n                                                        layer->len = cblk->passes[n - 1].rate - cblk->passes[cblk->numpassesinlayers - 1].rate;\n                                                        layer->data = cblk->data + cblk->passes[cblk->numpassesinlayers - 1].rate;\n                                                }\n\n                                                if (final)\n                                                        cblk->numpassesinlayers = n;\n                                        }\n                                }\n                        }\n                }\n        }\n}\n\nOPJ_BOOL opj_tcd_rateallocate(  opj_tcd_t *tcd,\n                                                                OPJ_BYTE *dest,\n                                                                OPJ_UINT32 * p_data_written,\n                                                                OPJ_UINT32 len,\n                                                                opj_codestream_info_t *cstr_info)\n{\n        OPJ_UINT32 compno, resno, bandno, precno, cblkno, layno;\n        OPJ_UINT32 passno;\n        OPJ_FLOAT64 min, max;\n        OPJ_FLOAT64 cumdisto[100];      /* fixed_quality */\n        const OPJ_FLOAT64 K = 1;                /* 1.1; fixed_quality */\n        OPJ_FLOAT64 maxSE = 0;\n\n        opj_cp_t *cp = tcd->cp;\n        opj_tcd_tile_t *tcd_tile = tcd->tcd_image->tiles;\n        opj_tcp_t *tcd_tcp = tcd->tcp;\n\n        min = DBL_MAX;\n        max = 0;\n\n        tcd_tile->numpix = 0;           /* fixed_quality */\n\n        for (compno = 0; compno < tcd_tile->numcomps; compno++) {\n                opj_tcd_tilecomp_t *tilec = &tcd_tile->comps[compno];\n                tilec->numpix = 0;\n\n                for (resno = 0; resno < tilec->numresolutions; resno++) {\n                        opj_tcd_resolution_t *res = &tilec->resolutions[resno];\n\n                        for (bandno = 0; bandno < res->numbands; bandno++) {\n                                opj_tcd_band_t *band = &res->bands[bandno];\n\n                                for (precno = 0; precno < res->pw * res->ph; precno++) {\n                                        opj_tcd_precinct_t *prc = &band->precincts[precno];\n\n                                        for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {\n                                                opj_tcd_cblk_enc_t *cblk = &prc->cblks.enc[cblkno];\n\n                                                for (passno = 0; passno < cblk->totalpasses; passno++) {\n                                                        opj_tcd_pass_t *pass = &cblk->passes[passno];\n                                                        OPJ_INT32 dr;\n                                                        OPJ_FLOAT64 dd, rdslope;\n\n                                                        if (passno == 0) {\n                                                                dr = (OPJ_INT32)pass->rate;\n                                                                dd = pass->distortiondec;\n                                                        } else {\n                                                                dr = (OPJ_INT32)(pass->rate - cblk->passes[passno - 1].rate);\n                                                                dd = pass->distortiondec - cblk->passes[passno - 1].distortiondec;\n                                                        }\n\n                                                        if (dr == 0) {\n                                                                continue;\n                                                        }\n\n                                                        rdslope = dd / dr;\n                                                        if (rdslope < min) {\n                                                                min = rdslope;\n                                                        }\n\n                                                        if (rdslope > max) {\n                                                                max = rdslope;\n                                                        }\n                                                } /* passno */\n\n                                                /* fixed_quality */\n                                                tcd_tile->numpix += ((cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0));\n                                                tilec->numpix += ((cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0));\n                                        } /* cbklno */\n                                } /* precno */\n                        } /* bandno */\n                } /* resno */\n\n                maxSE += (((OPJ_FLOAT64)(1 << tcd->image->comps[compno].prec) - 1.0)\n                        * ((OPJ_FLOAT64)(1 << tcd->image->comps[compno].prec) -1.0))\n                        * ((OPJ_FLOAT64)(tilec->numpix));\n        } /* compno */\n\n        /* index file */\n        if(cstr_info) {\n                opj_tile_info_t *tile_info = &cstr_info->tile[tcd->tcd_tileno];\n                tile_info->numpix = tcd_tile->numpix;\n                tile_info->distotile = tcd_tile->distotile;\n                tile_info->thresh = (OPJ_FLOAT64 *) opj_malloc(tcd_tcp->numlayers * sizeof(OPJ_FLOAT64));\n                if (!tile_info->thresh) {\n                        /* FIXME event manager error callback */\n                        return OPJ_FALSE;\n                }\n        }\n\n        for (layno = 0; layno < tcd_tcp->numlayers; layno++) {\n                OPJ_FLOAT64 lo = min;\n                OPJ_FLOAT64 hi = max;\n                OPJ_BOOL success = OPJ_FALSE;\n                OPJ_UINT32 maxlen = tcd_tcp->rates[layno] ? opj_uint_min(((OPJ_UINT32) ceil(tcd_tcp->rates[layno])), len) : len;\n                OPJ_FLOAT64 goodthresh = 0;\n                OPJ_FLOAT64 stable_thresh = 0;\n                OPJ_UINT32 i;\n                OPJ_FLOAT64 distotarget;                /* fixed_quality */\n\n                /* fixed_quality */\n                distotarget = tcd_tile->distotile - ((K * maxSE) / pow((OPJ_FLOAT32)10, tcd_tcp->distoratio[layno] / 10));\n\n                /* Don't try to find an optimal threshold but rather take everything not included yet, if\n                  -r xx,yy,zz,0   (disto_alloc == 1 and rates == 0)\n                  -q xx,yy,zz,0   (fixed_quality == 1 and distoratio == 0)\n                  ==> possible to have some lossy layers and the last layer for sure lossless */\n                if ( ((cp->m_specific_param.m_enc.m_disto_alloc==1) && (tcd_tcp->rates[layno]>0)) || ((cp->m_specific_param.m_enc.m_fixed_quality==1) && (tcd_tcp->distoratio[layno]>0))) {\n                        opj_t2_t*t2 = opj_t2_create(tcd->image, cp);\n                        OPJ_FLOAT64 thresh = 0;\n\n                        if (t2 == 00) {\n                                return OPJ_FALSE;\n                        }\n\n                        for     (i = 0; i < 128; ++i) {\n                                OPJ_FLOAT64 distoachieved = 0;  /* fixed_quality */\n\n                                thresh = (lo + hi) / 2;\n\n                                opj_tcd_makelayer(tcd, layno, thresh, 0);\n\n                                if (cp->m_specific_param.m_enc.m_fixed_quality) {       /* fixed_quality */\n                                        if(OPJ_IS_CINEMA(cp->rsiz)){\n                                                if (! opj_t2_encode_packets(t2,tcd->tcd_tileno, tcd_tile, layno + 1, dest, p_data_written, maxlen, cstr_info,tcd->cur_tp_num,tcd->tp_pos,tcd->cur_pino,THRESH_CALC)) {\n\n                                                        lo = thresh;\n                                                        continue;\n                                                }\n                                                else {\n                                                        distoachieved = layno == 0 ?\n                                                                        tcd_tile->distolayer[0] : cumdisto[layno - 1] + tcd_tile->distolayer[layno];\n\n                                                        if (distoachieved < distotarget) {\n                                                                hi=thresh;\n                                                                stable_thresh = thresh;\n                                                                continue;\n                                                        }else{\n                                                                lo=thresh;\n                                                        }\n                                                }\n                                        }else{\n                                                distoachieved = (layno == 0) ?\n                                                                tcd_tile->distolayer[0] : (cumdisto[layno - 1] + tcd_tile->distolayer[layno]);\n\n                                                if (distoachieved < distotarget) {\n                                                        hi = thresh;\n                                                        stable_thresh = thresh;\n                                                        continue;\n                                                }\n                                                lo = thresh;\n                                        }\n                                } else {\n                                        if (! opj_t2_encode_packets(t2, tcd->tcd_tileno, tcd_tile, layno + 1, dest,p_data_written, maxlen, cstr_info,tcd->cur_tp_num,tcd->tp_pos,tcd->cur_pino,THRESH_CALC))\n                                        {\n                                                /* TODO: what to do with l ??? seek / tell ??? */\n                                                /* opj_event_msg(tcd->cinfo, EVT_INFO, \"rate alloc: len=%d, max=%d\\n\", l, maxlen); */\n                                                lo = thresh;\n                                                continue;\n                                        }\n\n                                        hi = thresh;\n                                        stable_thresh = thresh;\n                                }\n                        }\n\n                        success = OPJ_TRUE;\n                        goodthresh = stable_thresh == 0? thresh : stable_thresh;\n\n                        opj_t2_destroy(t2);\n                } else {\n                        success = OPJ_TRUE;\n                        goodthresh = min;\n                }\n\n                if (!success) {\n                        return OPJ_FALSE;\n                }\n\n                if(cstr_info) { /* Threshold for Marcela Index */\n                        cstr_info->tile[tcd->tcd_tileno].thresh[layno] = goodthresh;\n                }\n\n                opj_tcd_makelayer(tcd, layno, goodthresh, 1);\n\n                /* fixed_quality */\n                cumdisto[layno] = (layno == 0) ? tcd_tile->distolayer[0] : (cumdisto[layno - 1] + tcd_tile->distolayer[layno]);\n        }\n\n        return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_tcd_init( opj_tcd_t *p_tcd,\n                                           opj_image_t * p_image,\n                                           opj_cp_t * p_cp )\n{\n        p_tcd->image = p_image;\n        p_tcd->cp = p_cp;\n\n        p_tcd->tcd_image->tiles = (opj_tcd_tile_t *) opj_calloc(1,sizeof(opj_tcd_tile_t));\n        if (! p_tcd->tcd_image->tiles) {\n                return OPJ_FALSE;\n        }\n\n        p_tcd->tcd_image->tiles->comps = (opj_tcd_tilecomp_t *) opj_calloc(p_image->numcomps,sizeof(opj_tcd_tilecomp_t));\n        if (! p_tcd->tcd_image->tiles->comps ) {\n                return OPJ_FALSE;\n        }\n\n        p_tcd->tcd_image->tiles->numcomps = p_image->numcomps;\n        p_tcd->tp_pos = p_cp->m_specific_param.m_enc.m_tp_pos;\n\n        return OPJ_TRUE;\n}\n\n/**\nDestroy a previously created TCD handle\n*/\nvoid opj_tcd_destroy(opj_tcd_t *tcd) {\n        if (tcd) {\n                opj_tcd_free_tile(tcd);\n\n                if (tcd->tcd_image) {\n                        opj_free(tcd->tcd_image);\n                        tcd->tcd_image = 00;\n                }\n                opj_free(tcd);\n        }\n}\n\nOPJ_BOOL opj_alloc_tile_component_data(opj_tcd_tilecomp_t *l_tilec)\n{\n\tif ((l_tilec->data == 00) || ((l_tilec->data_size_needed > l_tilec->data_size) && (l_tilec->ownsData == OPJ_FALSE))) {\n\t\tl_tilec->data = (OPJ_INT32 *) opj_malloc(l_tilec->data_size_needed);\n\t\tif (! l_tilec->data ) {\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\t/*fprintf(stderr, \"tAllocate data of tilec (int): %d x OPJ_UINT32n\",l_data_size);*/\n\t\tl_tilec->data_size = l_tilec->data_size_needed;\n\t\tl_tilec->ownsData = OPJ_TRUE;\n\t}\n\telse if (l_tilec->data_size_needed > l_tilec->data_size) {\n\t\tOPJ_INT32 * new_data = (OPJ_INT32 *) opj_realloc(l_tilec->data, l_tilec->data_size_needed);\n\t\t/* opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to handle tile datan\"); */\n\t\t/* fprintf(stderr, \"Not enough memory to handle tile data\"); */\n\t\tif (! new_data) {\n\t\t\topj_free(l_tilec->data);\n\t\t\tl_tilec->data = NULL;\n\t\t\tl_tilec->data_size = 0;\n\t\t\tl_tilec->data_size_needed = 0;\n\t\t\tl_tilec->ownsData = OPJ_FALSE;\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\tl_tilec->data = new_data;\n\t\t/*fprintf(stderr, \"tReallocate data of tilec (int): from %d to %d x OPJ_UINT32n\", l_tilec->data_size, l_data_size);*/\n\t\tl_tilec->data_size = l_tilec->data_size_needed;\n\t\tl_tilec->ownsData = OPJ_TRUE;\n\t}\n\treturn OPJ_TRUE;\n}\n\n/* ----------------------------------------------------------------------- */\n\nstatic INLINE OPJ_BOOL opj_tcd_init_tile(opj_tcd_t *p_tcd, OPJ_UINT32 p_tile_no, OPJ_BOOL isEncoder, OPJ_FLOAT32 fraction, OPJ_SIZE_T sizeof_block)\n{\n\tOPJ_UINT32 (*l_gain_ptr)(OPJ_UINT32) = 00;\n\tOPJ_UINT32 compno, resno, bandno, precno, cblkno;\n\topj_tcp_t * l_tcp = 00;\n\topj_cp_t * l_cp = 00;\n\topj_tcd_tile_t * l_tile = 00;\n\topj_tccp_t *l_tccp = 00;\n\topj_tcd_tilecomp_t *l_tilec = 00;\n\topj_image_comp_t * l_image_comp = 00;\n\topj_tcd_resolution_t *l_res = 00;\n\topj_tcd_band_t *l_band = 00;\n\topj_stepsize_t * l_step_size = 00;\n\topj_tcd_precinct_t *l_current_precinct = 00;\n\topj_image_t *l_image = 00;\n\tOPJ_UINT32 p,q;\n\tOPJ_UINT32 l_level_no;\n\tOPJ_UINT32 l_pdx, l_pdy;\n\tOPJ_UINT32 l_gain;\n\tOPJ_INT32 l_x0b, l_y0b;\n\t/* extent of precincts , top left, bottom right**/\n\tOPJ_INT32 l_tl_prc_x_start, l_tl_prc_y_start, l_br_prc_x_end, l_br_prc_y_end;\n\t/* number of precinct for a resolution */\n\tOPJ_UINT32 l_nb_precincts;\n\t/* room needed to store l_nb_precinct precinct for a resolution */\n\tOPJ_UINT32 l_nb_precinct_size;\n\t/* number of code blocks for a precinct*/\n\tOPJ_UINT32 l_nb_code_blocks;\n\t/* room needed to store l_nb_code_blocks code blocks for a precinct*/\n\tOPJ_UINT32 l_nb_code_blocks_size;\n\t/* size of data for a tile */\n\tOPJ_UINT32 l_data_size;\n\t\n\tl_cp = p_tcd->cp;\n\tl_tcp = &(l_cp->tcps[p_tile_no]);\n\tl_tile = p_tcd->tcd_image->tiles;\n\tl_tccp = l_tcp->tccps;\n\tl_tilec = l_tile->comps;\n\tl_image = p_tcd->image;\n\tl_image_comp = p_tcd->image->comps;\n\t\n\tp = p_tile_no % l_cp->tw;       /* tile coordinates */\n\tq = p_tile_no / l_cp->tw;\n\t/*fprintf(stderr, \"Tile coordinate = %d,%d\\n\", p, q);*/\n\t\n\t/* 4 borders of the tile rescale on the image if necessary */\n\tl_tile->x0 = opj_int_max((OPJ_INT32)(l_cp->tx0 + p * l_cp->tdx), (OPJ_INT32)l_image->x0);\n\tl_tile->y0 = opj_int_max((OPJ_INT32)(l_cp->ty0 + q * l_cp->tdy), (OPJ_INT32)l_image->y0);\n\tl_tile->x1 = opj_int_min((OPJ_INT32)(l_cp->tx0 + (p + 1) * l_cp->tdx), (OPJ_INT32)l_image->x1);\n\tl_tile->y1 = opj_int_min((OPJ_INT32)(l_cp->ty0 + (q + 1) * l_cp->tdy), (OPJ_INT32)l_image->y1);\n\t/* testcase 1888.pdf.asan.35.988 */\n\tif (l_tccp->numresolutions == 0) {\n\t\tfprintf(stderr, \"tiles require at least one resolution\\n\");\n\t\treturn OPJ_FALSE;\n\t}\n\t/*fprintf(stderr, \"Tile border = %d,%d,%d,%d\\n\", l_tile->x0, l_tile->y0,l_tile->x1,l_tile->y1);*/\n\t\n\t/*tile->numcomps = image->numcomps; */\n\tfor (compno = 0; compno < l_tile->numcomps; ++compno) {\n\t\t/*fprintf(stderr, \"compno = %d/%d\\n\", compno, l_tile->numcomps);*/\n\t\tl_image_comp->resno_decoded = 0;\n\t\t/* border of each l_tile component (global) */\n\t\tl_tilec->x0 = opj_int_ceildiv(l_tile->x0, (OPJ_INT32)l_image_comp->dx);\n\t\tl_tilec->y0 = opj_int_ceildiv(l_tile->y0, (OPJ_INT32)l_image_comp->dy);\n\t\tl_tilec->x1 = opj_int_ceildiv(l_tile->x1, (OPJ_INT32)l_image_comp->dx);\n\t\tl_tilec->y1 = opj_int_ceildiv(l_tile->y1, (OPJ_INT32)l_image_comp->dy);\n\t\t/*fprintf(stderr, \"\\tTile compo border = %d,%d,%d,%d\\n\", l_tilec->x0, l_tilec->y0,l_tilec->x1,l_tilec->y1);*/\n\t\t\n\t\t/* compute l_data_size with overflow check */\n\t\tl_data_size = (OPJ_UINT32)(l_tilec->x1 - l_tilec->x0);\n\t\tif ((((OPJ_UINT32)-1) / l_data_size) < (OPJ_UINT32)(l_tilec->y1 - l_tilec->y0)) {\n\t\t\t/* TODO event */\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\tl_data_size = l_data_size * (OPJ_UINT32)(l_tilec->y1 - l_tilec->y0);\n\t\t\n\t\tif ((((OPJ_UINT32)-1) / (OPJ_UINT32)sizeof(OPJ_UINT32)) < l_data_size) {\n\t\t\t/* TODO event */\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\tl_data_size = l_data_size * (OPJ_UINT32)sizeof(OPJ_UINT32);\n\t\tl_tilec->numresolutions = l_tccp->numresolutions;\n\t\tif (l_tccp->numresolutions < l_cp->m_specific_param.m_dec.m_reduce) {\n\t\t\tl_tilec->minimum_num_resolutions = 1;\n\t\t}\n\t\telse {\n\t\t\tl_tilec->minimum_num_resolutions = l_tccp->numresolutions - l_cp->m_specific_param.m_dec.m_reduce;\n\t\t}\n\t\t\n\t\tl_tilec->data_size_needed = l_data_size;\n\t\tif (p_tcd->m_is_decoder && !opj_alloc_tile_component_data(l_tilec)) {\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\t\n\t\tl_data_size = l_tilec->numresolutions * (OPJ_UINT32)sizeof(opj_tcd_resolution_t);\n\t\t\n\t\tif (l_tilec->resolutions == 00) {\n\t\t\tl_tilec->resolutions = (opj_tcd_resolution_t *) opj_malloc(l_data_size);\n\t\t\tif (! l_tilec->resolutions ) {\n\t\t\t\treturn OPJ_FALSE;\n\t\t\t}\n\t\t\t/*fprintf(stderr, \"\\tAllocate resolutions of tilec (opj_tcd_resolution_t): %d\\n\",l_data_size);*/\n\t\t\tl_tilec->resolutions_size = l_data_size;\n\t\t\tmemset(l_tilec->resolutions,0,l_data_size);\n\t\t}\n\t\telse if (l_data_size > l_tilec->resolutions_size) {\n\t\t\topj_tcd_resolution_t* new_resolutions = (opj_tcd_resolution_t *) opj_realloc(l_tilec->resolutions, l_data_size);\n\t\t\tif (! new_resolutions) {\n\t\t\t\t/* opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to tile resolutions\\n\");                                                                                         */\n\t\t\t\tfprintf(stderr, \"Not enough memory to tile resolutions\\n\");\n\t\t\t\topj_free(l_tilec->resolutions);\n\t\t\t\tl_tilec->resolutions = NULL;\n\t\t\t\tl_tilec->resolutions_size = 0;\n\t\t\t\treturn OPJ_FALSE;\n\t\t\t}\n\t\t\tl_tilec->resolutions = new_resolutions;\n\t\t\t/*fprintf(stderr, \"\\tReallocate data of tilec (int): from %d to %d x OPJ_UINT32\\n\", l_tilec->resolutions_size, l_data_size);*/\n\t\t\tmemset(((OPJ_BYTE*) l_tilec->resolutions)+l_tilec->resolutions_size,0,l_data_size - l_tilec->resolutions_size);\n\t\t\tl_tilec->resolutions_size = l_data_size;\n\t\t}\n\t\t\n\t\tl_level_no = l_tilec->numresolutions - 1;\n\t\tl_res = l_tilec->resolutions;\n\t\tl_step_size = l_tccp->stepsizes;\n\t\tif (l_tccp->qmfbid == 0) {\n\t\t\tl_gain_ptr = &opj_dwt_getgain_real;\n\t\t}\n\t\telse {\n\t\t\tl_gain_ptr  = &opj_dwt_getgain;\n\t\t}\n\t\t/*fprintf(stderr, \"\\tlevel_no=%d\\n\",l_level_no);*/\n\t\t\n\t\tfor (resno = 0; resno < l_tilec->numresolutions; ++resno) {\n\t\t\t/*fprintf(stderr, \"\\t\\tresno = %d/%d\\n\", resno, l_tilec->numresolutions);*/\n\t\t\tOPJ_INT32 tlcbgxstart, tlcbgystart /*, brcbgxend, brcbgyend*/;\n\t\t\tOPJ_UINT32 cbgwidthexpn, cbgheightexpn;\n\t\t\tOPJ_UINT32 cblkwidthexpn, cblkheightexpn;\n\t\t\t\n\t\t\t/* border for each resolution level (global) */\n\t\t\tl_res->x0 = opj_int_ceildivpow2(l_tilec->x0, (OPJ_INT32)l_level_no);\n\t\t\tl_res->y0 = opj_int_ceildivpow2(l_tilec->y0, (OPJ_INT32)l_level_no);\n\t\t\tl_res->x1 = opj_int_ceildivpow2(l_tilec->x1, (OPJ_INT32)l_level_no);\n\t\t\tl_res->y1 = opj_int_ceildivpow2(l_tilec->y1, (OPJ_INT32)l_level_no);\n\t\t\t/*fprintf(stderr, \"\\t\\t\\tres_x0= %d, res_y0 =%d, res_x1=%d, res_y1=%d\\n\", l_res->x0, l_res->y0, l_res->x1, l_res->y1);*/\n\t\t\t/* p. 35, table A-23, ISO/IEC FDIS154444-1 : 2000 (18 august 2000) */\n\t\t\tl_pdx = l_tccp->prcw[resno];\n\t\t\tl_pdy = l_tccp->prch[resno];\n\t\t\t/*fprintf(stderr, \"\\t\\t\\tpdx=%d, pdy=%d\\n\", l_pdx, l_pdy);*/\n\t\t\t/* p. 64, B.6, ISO/IEC FDIS15444-1 : 2000 (18 august 2000)  */\n\t\t\tl_tl_prc_x_start = opj_int_floordivpow2(l_res->x0, (OPJ_INT32)l_pdx) << l_pdx;\n\t\t\tl_tl_prc_y_start = opj_int_floordivpow2(l_res->y0, (OPJ_INT32)l_pdy) << l_pdy;\n\t\t\tl_br_prc_x_end = opj_int_ceildivpow2(l_res->x1, (OPJ_INT32)l_pdx) << l_pdx;\n\t\t\tl_br_prc_y_end = opj_int_ceildivpow2(l_res->y1, (OPJ_INT32)l_pdy) << l_pdy;\n\t\t\t/*fprintf(stderr, \"\\t\\t\\tprc_x_start=%d, prc_y_start=%d, br_prc_x_end=%d, br_prc_y_end=%d \\n\", l_tl_prc_x_start, l_tl_prc_y_start, l_br_prc_x_end ,l_br_prc_y_end );*/\n\t\t\t\n\t\t\tl_res->pw = (l_res->x0 == l_res->x1) ? 0 : (OPJ_UINT32)((l_br_prc_x_end - l_tl_prc_x_start) >> l_pdx);\n\t\t\tl_res->ph = (l_res->y0 == l_res->y1) ? 0 : (OPJ_UINT32)((l_br_prc_y_end - l_tl_prc_y_start) >> l_pdy);\n\t\t\t/*fprintf(stderr, \"\\t\\t\\tres_pw=%d, res_ph=%d\\n\", l_res->pw, l_res->ph );*/\n\t\t\t\n\t\t\tl_nb_precincts = l_res->pw * l_res->ph;\n\t\t\tl_nb_precinct_size = l_nb_precincts * (OPJ_UINT32)sizeof(opj_tcd_precinct_t);\n\t\t\tif (resno == 0) {\n\t\t\t\ttlcbgxstart = l_tl_prc_x_start;\n\t\t\t\ttlcbgystart = l_tl_prc_y_start;\n\t\t\t\t/*brcbgxend = l_br_prc_x_end;*/\n\t\t\t\t/* brcbgyend = l_br_prc_y_end;*/\n\t\t\t\tcbgwidthexpn = l_pdx;\n\t\t\t\tcbgheightexpn = l_pdy;\n\t\t\t\tl_res->numbands = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttlcbgxstart = opj_int_ceildivpow2(l_tl_prc_x_start, 1);\n\t\t\t\ttlcbgystart = opj_int_ceildivpow2(l_tl_prc_y_start, 1);\n\t\t\t\t/*brcbgxend = opj_int_ceildivpow2(l_br_prc_x_end, 1);*/\n\t\t\t\t/*brcbgyend = opj_int_ceildivpow2(l_br_prc_y_end, 1);*/\n\t\t\t\tcbgwidthexpn = l_pdx - 1;\n\t\t\t\tcbgheightexpn = l_pdy - 1;\n\t\t\t\tl_res->numbands = 3;\n\t\t\t}\n\t\t\t\n\t\t\tcblkwidthexpn = opj_uint_min(l_tccp->cblkw, cbgwidthexpn);\n\t\t\tcblkheightexpn = opj_uint_min(l_tccp->cblkh, cbgheightexpn);\n\t\t\tl_band = l_res->bands;\n\t\t\t\n\t\t\tfor (bandno = 0; bandno < l_res->numbands; ++bandno) {\n\t\t\t\tOPJ_INT32 numbps;\n\t\t\t\t/*fprintf(stderr, \"\\t\\t\\tband_no=%d/%d\\n\", bandno, l_res->numbands );*/\n\t\t\t\t\n\t\t\t\tif (resno == 0) {\n\t\t\t\t\tl_band->bandno = 0 ;\n\t\t\t\t\tl_band->x0 = opj_int_ceildivpow2(l_tilec->x0, (OPJ_INT32)l_level_no);\n\t\t\t\t\tl_band->y0 = opj_int_ceildivpow2(l_tilec->y0, (OPJ_INT32)l_level_no);\n\t\t\t\t\tl_band->x1 = opj_int_ceildivpow2(l_tilec->x1, (OPJ_INT32)l_level_no);\n\t\t\t\t\tl_band->y1 = opj_int_ceildivpow2(l_tilec->y1, (OPJ_INT32)l_level_no);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tl_band->bandno = bandno + 1;\n\t\t\t\t\t/* x0b = 1 if bandno = 1 or 3 */\n\t\t\t\t\tl_x0b = l_band->bandno&1;\n\t\t\t\t\t/* y0b = 1 if bandno = 2 or 3 */\n\t\t\t\t\tl_y0b = (OPJ_INT32)((l_band->bandno)>>1);\n\t\t\t\t\t/* l_band border (global) */\n\t\t\t\t\tl_band->x0 = opj_int_ceildivpow2(l_tilec->x0 - (1 << l_level_no) * l_x0b, (OPJ_INT32)(l_level_no + 1));\n\t\t\t\t\tl_band->y0 = opj_int_ceildivpow2(l_tilec->y0 - (1 << l_level_no) * l_y0b, (OPJ_INT32)(l_level_no + 1));\n\t\t\t\t\tl_band->x1 = opj_int_ceildivpow2(l_tilec->x1 - (1 << l_level_no) * l_x0b, (OPJ_INT32)(l_level_no + 1));\n\t\t\t\t\tl_band->y1 = opj_int_ceildivpow2(l_tilec->y1 - (1 << l_level_no) * l_y0b, (OPJ_INT32)(l_level_no + 1));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/** avoid an if with storing function pointer */\n\t\t\t\tl_gain = (*l_gain_ptr) (l_band->bandno);\n\t\t\t\tnumbps = (OPJ_INT32)(l_image_comp->prec + l_gain);\n\t\t\t\tl_band->stepsize = (OPJ_FLOAT32)(((1.0 + l_step_size->mant / 2048.0) * pow(2.0, (OPJ_INT32) (numbps - l_step_size->expn)))) * fraction;\n\t\t\t\tl_band->numbps = l_step_size->expn + (OPJ_INT32)l_tccp->numgbits - 1;      /* WHY -1 ? */\n\t\t\t\t\n\t\t\t\tif (! l_band->precincts) {\n\t\t\t\t\tl_band->precincts = (opj_tcd_precinct_t *) opj_malloc( /*3 * */ l_nb_precinct_size);\n\t\t\t\t\tif (! l_band->precincts) {\n\t\t\t\t\t\treturn OPJ_FALSE;\n\t\t\t\t\t}\n\t\t\t\t\t/*fprintf(stderr, \"\\t\\t\\t\\tAllocate precincts of a band (opj_tcd_precinct_t): %d\\n\",l_nb_precinct_size);     */\n\t\t\t\t\tmemset(l_band->precincts,0,l_nb_precinct_size);\n\t\t\t\t\tl_band->precincts_data_size = l_nb_precinct_size;\n\t\t\t\t}\n\t\t\t\telse if (l_band->precincts_data_size < l_nb_precinct_size) {\n\t\t\t\t\t\n\t\t\t\t\topj_tcd_precinct_t * new_precincts = (opj_tcd_precinct_t *) opj_realloc(l_band->precincts,/*3 * */ l_nb_precinct_size);\n\t\t\t\t\tif (! new_precincts) {\n\t\t\t\t\t\t/* opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to handle band precints\\n\");                                                                    */\n\t\t\t\t\t\tfprintf(stderr, \"Not enough memory to handle band precints\\n\");\n\t\t\t\t\t\topj_free(l_band->precincts);\n\t\t\t\t\t\tl_band->precincts = NULL;\n\t\t\t\t\t\tl_band->precincts_data_size = 0;\n\t\t\t\t\t\treturn OPJ_FALSE;\n\t\t\t\t\t}\n\t\t\t\t\tl_band->precincts = new_precincts;\n\t\t\t\t\t/*fprintf(stderr, \"\\t\\t\\t\\tReallocate precincts of a band (opj_tcd_precinct_t): from %d to %d\\n\",l_band->precincts_data_size, l_nb_precinct_size);*/\n\t\t\t\t\tmemset(((OPJ_BYTE *) l_band->precincts) + l_band->precincts_data_size,0,l_nb_precinct_size - l_band->precincts_data_size);\n\t\t\t\t\tl_band->precincts_data_size = l_nb_precinct_size;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tl_current_precinct = l_band->precincts;\n\t\t\t\tfor (precno = 0; precno < l_nb_precincts; ++precno) {\n\t\t\t\t\tOPJ_INT32 tlcblkxstart, tlcblkystart, brcblkxend, brcblkyend;\n\t\t\t\t\tOPJ_INT32 cbgxstart = tlcbgxstart + (OPJ_INT32)(precno % l_res->pw) * (1 << cbgwidthexpn);\n\t\t\t\t\tOPJ_INT32 cbgystart = tlcbgystart + (OPJ_INT32)(precno / l_res->pw) * (1 << cbgheightexpn);\n\t\t\t\t\tOPJ_INT32 cbgxend = cbgxstart + (1 << cbgwidthexpn);\n\t\t\t\t\tOPJ_INT32 cbgyend = cbgystart + (1 << cbgheightexpn);\n\t\t\t\t\t/*fprintf(stderr, \"\\t precno=%d; bandno=%d, resno=%d; compno=%d\\n\", precno, bandno , resno, compno);*/\n\t\t\t\t\t/*fprintf(stderr, \"\\t tlcbgxstart(=%d) + (precno(=%d) percent res->pw(=%d)) * (1 << cbgwidthexpn(=%d)) \\n\",tlcbgxstart,precno,l_res->pw,cbgwidthexpn);*/\n\t\t\t\t\t\n\t\t\t\t\t/* precinct size (global) */\n\t\t\t\t\t/*fprintf(stderr, \"\\t cbgxstart=%d, l_band->x0 = %d \\n\",cbgxstart, l_band->x0);*/\n\t\t\t\t\t\n\t\t\t\t\tl_current_precinct->x0 = opj_int_max(cbgxstart, l_band->x0);\n\t\t\t\t\tl_current_precinct->y0 = opj_int_max(cbgystart, l_band->y0);\n\t\t\t\t\tl_current_precinct->x1 = opj_int_min(cbgxend, l_band->x1);\n\t\t\t\t\tl_current_precinct->y1 = opj_int_min(cbgyend, l_band->y1);\n\t\t\t\t\t/*fprintf(stderr, \"\\t prc_x0=%d; prc_y0=%d, prc_x1=%d; prc_y1=%d\\n\",l_current_precinct->x0, l_current_precinct->y0 ,l_current_precinct->x1, l_current_precinct->y1);*/\n\t\t\t\t\t\n\t\t\t\t\ttlcblkxstart = opj_int_floordivpow2(l_current_precinct->x0, (OPJ_INT32)cblkwidthexpn) << cblkwidthexpn;\n\t\t\t\t\t/*fprintf(stderr, \"\\t tlcblkxstart =%d\\n\",tlcblkxstart );*/\n\t\t\t\t\ttlcblkystart = opj_int_floordivpow2(l_current_precinct->y0, (OPJ_INT32)cblkheightexpn) << cblkheightexpn;\n\t\t\t\t\t/*fprintf(stderr, \"\\t tlcblkystart =%d\\n\",tlcblkystart );*/\n\t\t\t\t\tbrcblkxend = opj_int_ceildivpow2(l_current_precinct->x1, (OPJ_INT32)cblkwidthexpn) << cblkwidthexpn;\n\t\t\t\t\t/*fprintf(stderr, \"\\t brcblkxend =%d\\n\",brcblkxend );*/\n\t\t\t\t\tbrcblkyend = opj_int_ceildivpow2(l_current_precinct->y1, (OPJ_INT32)cblkheightexpn) << cblkheightexpn;\n\t\t\t\t\t/*fprintf(stderr, \"\\t brcblkyend =%d\\n\",brcblkyend );*/\n\t\t\t\t\tl_current_precinct->cw = (OPJ_UINT32)((brcblkxend - tlcblkxstart) >> cblkwidthexpn);\n\t\t\t\t\tl_current_precinct->ch = (OPJ_UINT32)((brcblkyend - tlcblkystart) >> cblkheightexpn);\n\t\t\t\t\t\n\t\t\t\t\tl_nb_code_blocks = l_current_precinct->cw * l_current_precinct->ch;\n\t\t\t\t\t/*fprintf(stderr, \"\\t\\t\\t\\t precinct_cw = %d x recinct_ch = %d\\n\",l_current_precinct->cw, l_current_precinct->ch);      */\n\t\t\t\t\tl_nb_code_blocks_size = l_nb_code_blocks * (OPJ_UINT32)sizeof_block;\n\t\t\t\t\t\n\t\t\t\t\tif (! l_current_precinct->cblks.blocks) {\n\t\t\t\t\t\tl_current_precinct->cblks.blocks = opj_malloc(l_nb_code_blocks_size);\n\t\t\t\t\t\tif (! l_current_precinct->cblks.blocks ) {\n\t\t\t\t\t\t\treturn OPJ_FALSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/*fprintf(stderr, \"\\t\\t\\t\\tAllocate cblks of a precinct (opj_tcd_cblk_dec_t): %d\\n\",l_nb_code_blocks_size);*/\n\t\t\t\t\t\t\n\t\t\t\t\t\tmemset(l_current_precinct->cblks.blocks,0,l_nb_code_blocks_size);\n\t\t\t\t\t\t\n\t\t\t\t\t\tl_current_precinct->block_size = l_nb_code_blocks_size;\n\t\t\t\t\t}\n\t\t\t\t\telse if (l_nb_code_blocks_size > l_current_precinct->block_size) {\n\t\t\t\t\t\tvoid *new_blocks = opj_realloc(l_current_precinct->cblks.blocks, l_nb_code_blocks_size);\n\t\t\t\t\t\tif (! new_blocks) {\n\t\t\t\t\t\t\topj_free(l_current_precinct->cblks.blocks);\n\t\t\t\t\t\t\tl_current_precinct->cblks.blocks = NULL;\n\t\t\t\t\t\t\tl_current_precinct->block_size = 0;\n\t\t\t\t\t\t\t/* opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory for current precinct codeblock element\\n\");                                              */\n\t\t\t\t\t\t\tfprintf(stderr, \"Not enough memory for current precinct codeblock element\\n\");\n\t\t\t\t\t\t\treturn OPJ_FALSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tl_current_precinct->cblks.blocks = new_blocks;\n\t\t\t\t\t\t/*fprintf(stderr, \"\\t\\t\\t\\tReallocate cblks of a precinct (opj_tcd_cblk_dec_t): from %d to %d\\n\",l_current_precinct->block_size, l_nb_code_blocks_size);     */\n\t\t\t\t\t\t\n\t\t\t\t\t\tmemset(((OPJ_BYTE *) l_current_precinct->cblks.blocks) + l_current_precinct->block_size\n\t\t\t\t\t\t\t\t\t ,0\n\t\t\t\t\t\t\t\t\t ,l_nb_code_blocks_size - l_current_precinct->block_size);\n\t\t\t\t\t\t\n\t\t\t\t\t\tl_current_precinct->block_size = l_nb_code_blocks_size;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (! l_current_precinct->incltree) {\n\t\t\t\t\t\tl_current_precinct->incltree = opj_tgt_create(l_current_precinct->cw,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tl_current_precinct->ch);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tl_current_precinct->incltree = opj_tgt_init(l_current_precinct->incltree,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tl_current_precinct->cw,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tl_current_precinct->ch);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (! l_current_precinct->incltree)     {\n\t\t\t\t\t\tfprintf(stderr, \"WARNING: No incltree created.\\n\");\n\t\t\t\t\t\t/*return OPJ_FALSE;*/\n\t\t\t\t\t}\n\n\t\t\t\t\tif (! l_current_precinct->imsbtree) {\n\t\t\t\t\t\tl_current_precinct->imsbtree = opj_tgt_create(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tl_current_precinct->cw,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tl_current_precinct->ch);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tl_current_precinct->imsbtree = opj_tgt_init(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tl_current_precinct->imsbtree,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tl_current_precinct->cw,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tl_current_precinct->ch);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (! l_current_precinct->imsbtree) {\n\t\t\t\t\t\tfprintf(stderr, \"WARNING: No imsbtree created.\\n\");\n\t\t\t\t\t\t/*return OPJ_FALSE;*/\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (cblkno = 0; cblkno < l_nb_code_blocks; ++cblkno) {\n\t\t\t\t\t\tOPJ_INT32 cblkxstart = tlcblkxstart + (OPJ_INT32)(cblkno % l_current_precinct->cw) * (1 << cblkwidthexpn);\n\t\t\t\t\t\tOPJ_INT32 cblkystart = tlcblkystart + (OPJ_INT32)(cblkno / l_current_precinct->cw) * (1 << cblkheightexpn);\n\t\t\t\t\t\tOPJ_INT32 cblkxend = cblkxstart + (1 << cblkwidthexpn);\n\t\t\t\t\t\tOPJ_INT32 cblkyend = cblkystart + (1 << cblkheightexpn);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (isEncoder) {\n\t\t\t\t\t\t\topj_tcd_cblk_enc_t* l_code_block = l_current_precinct->cblks.enc + cblkno;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (! opj_tcd_code_block_enc_allocate(l_code_block)) {\n\t\t\t\t\t\t\t\treturn OPJ_FALSE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/* code-block size (global) */\n\t\t\t\t\t\t\tl_code_block->x0 = opj_int_max(cblkxstart, l_current_precinct->x0);\n\t\t\t\t\t\t\tl_code_block->y0 = opj_int_max(cblkystart, l_current_precinct->y0);\n\t\t\t\t\t\t\tl_code_block->x1 = opj_int_min(cblkxend, l_current_precinct->x1);\n\t\t\t\t\t\t\tl_code_block->y1 = opj_int_min(cblkyend, l_current_precinct->y1);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (! opj_tcd_code_block_enc_allocate_data(l_code_block)) {\n\t\t\t\t\t\t\t\treturn OPJ_FALSE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\topj_tcd_cblk_dec_t* l_code_block = l_current_precinct->cblks.dec + cblkno;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (! opj_tcd_code_block_dec_allocate(l_code_block)) {\n\t\t\t\t\t\t\t\treturn OPJ_FALSE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/* code-block size (global) */\n\t\t\t\t\t\t\tl_code_block->x0 = opj_int_max(cblkxstart, l_current_precinct->x0);\n\t\t\t\t\t\t\tl_code_block->y0 = opj_int_max(cblkystart, l_current_precinct->y0);\n\t\t\t\t\t\t\tl_code_block->x1 = opj_int_min(cblkxend, l_current_precinct->x1);\n\t\t\t\t\t\t\tl_code_block->y1 = opj_int_min(cblkyend, l_current_precinct->y1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t++l_current_precinct;\n\t\t\t\t} /* precno */\n\t\t\t\t++l_band;\n\t\t\t\t++l_step_size;\n\t\t\t} /* bandno */\n\t\t\t++l_res;\n\t\t\t--l_level_no;\n\t\t} /* resno */\n\t\t++l_tccp;\n\t\t++l_tilec;\n\t\t++l_image_comp;\n\t} /* compno */\n\treturn OPJ_TRUE;\n}\n\nOPJ_BOOL opj_tcd_init_encode_tile (opj_tcd_t *p_tcd, OPJ_UINT32 p_tile_no)\n{\n\treturn opj_tcd_init_tile(p_tcd, p_tile_no, OPJ_TRUE, 1.0F, sizeof(opj_tcd_cblk_enc_t));\n}\n\nOPJ_BOOL opj_tcd_init_decode_tile (opj_tcd_t *p_tcd, OPJ_UINT32 p_tile_no)\n{\n\treturn opj_tcd_init_tile(p_tcd, p_tile_no, OPJ_FALSE, 0.5F, sizeof(opj_tcd_cblk_dec_t));\n}\n\n/**\n * Allocates memory for an encoding code block (but not data memory).\n */\nstatic OPJ_BOOL opj_tcd_code_block_enc_allocate (opj_tcd_cblk_enc_t * p_code_block)\n{\n\tif (! p_code_block->layers) {\n\t\t/* no memset since data */\n\t\tp_code_block->layers = (opj_tcd_layer_t*) opj_calloc(100, sizeof(opj_tcd_layer_t));\n\t\tif (! p_code_block->layers) {\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t}\n\tif (! p_code_block->passes) {\n\t\tp_code_block->passes = (opj_tcd_pass_t*) opj_calloc(100, sizeof(opj_tcd_pass_t));\n\t\tif (! p_code_block->passes) {\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t}\n\treturn OPJ_TRUE;\n}\n\n/**\n * Allocates data memory for an encoding code block.\n */\nstatic OPJ_BOOL opj_tcd_code_block_enc_allocate_data (opj_tcd_cblk_enc_t * p_code_block)\n{\n\tOPJ_UINT32 l_data_size;\n\t\n\tl_data_size = (OPJ_UINT32)((p_code_block->x1 - p_code_block->x0) * (p_code_block->y1 - p_code_block->y0) * (OPJ_INT32)sizeof(OPJ_UINT32));\n\t\n\tif (l_data_size > p_code_block->data_size) {\n\t\tif (p_code_block->data) {\n\t\t\topj_free(p_code_block->data - 1); /* again, why -1 */\n\t\t}\n\t\tp_code_block->data = (OPJ_BYTE*) opj_malloc(l_data_size);\n\t\tif(! p_code_block->data) {\n\t\t\tp_code_block->data_size = 0U;\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\tp_code_block->data_size = l_data_size;\n\t\t\n\t\tp_code_block->data[0] = 0;\n\t\tp_code_block->data+=1;   /*why +1 ?*/\n\t}\n\treturn OPJ_TRUE;\n}\n\n/**\n * Allocates memory for a decoding code block.\n */\nstatic OPJ_BOOL opj_tcd_code_block_dec_allocate (opj_tcd_cblk_dec_t * p_code_block)\n{\n        if (! p_code_block->data) {\n\n                p_code_block->data = (OPJ_BYTE*) opj_malloc(OPJ_J2K_DEFAULT_CBLK_DATA_SIZE);\n                if (! p_code_block->data) {\n                        return OPJ_FALSE;\n                }\n                p_code_block->data_max_size = OPJ_J2K_DEFAULT_CBLK_DATA_SIZE;\n                /*fprintf(stderr, \"Allocate 8192 elements of code_block->data\\n\");*/\n\n                p_code_block->segs = (opj_tcd_seg_t *) opj_calloc(OPJ_J2K_DEFAULT_NB_SEGS,sizeof(opj_tcd_seg_t));\n                if (! p_code_block->segs) {\n                        return OPJ_FALSE;\n                }\n                /*fprintf(stderr, \"Allocate %d elements of code_block->data\\n\", OPJ_J2K_DEFAULT_NB_SEGS * sizeof(opj_tcd_seg_t));*/\n\n                p_code_block->m_current_max_segs = OPJ_J2K_DEFAULT_NB_SEGS;\n                /*fprintf(stderr, \"m_current_max_segs of code_block->data = %d\\n\", p_code_block->m_current_max_segs);*/\n        } else {\n\t\t\t\t\t/* sanitize */\n\t\t\t\t\tOPJ_BYTE* l_data = p_code_block->data;\n\t\t\t\t\tOPJ_UINT32 l_data_max_size = p_code_block->data_max_size;\n\t\t\t\t\topj_tcd_seg_t * l_segs = p_code_block->segs;\n\t\t\t\t\tOPJ_UINT32 l_current_max_segs = p_code_block->m_current_max_segs;\n\n\t\t\t\t\tmemset(p_code_block, 0, sizeof(opj_tcd_cblk_dec_t));\n\t\t\t\t\tp_code_block->data = l_data;\n\t\t\t\t\tp_code_block->data_max_size = l_data_max_size;\n\t\t\t\t\tp_code_block->segs = l_segs;\n\t\t\t\t\tp_code_block->m_current_max_segs = l_current_max_segs;\n\t\t\t\t}\n\n        return OPJ_TRUE;\n}\n\nOPJ_UINT32 opj_tcd_get_decoded_tile_size ( opj_tcd_t *p_tcd )\n{\n        OPJ_UINT32 i;\n        OPJ_UINT32 l_data_size = 0;\n        opj_image_comp_t * l_img_comp = 00;\n        opj_tcd_tilecomp_t * l_tile_comp = 00;\n        opj_tcd_resolution_t * l_res = 00;\n        OPJ_UINT32 l_size_comp, l_remaining;\n\n        l_tile_comp = p_tcd->tcd_image->tiles->comps;\n        l_img_comp = p_tcd->image->comps;\n\n        for (i=0;i<p_tcd->image->numcomps;++i) {\n                l_size_comp = l_img_comp->prec >> 3; /*(/ 8)*/\n                l_remaining = l_img_comp->prec & 7;  /* (%8) */\n\n                if(l_remaining) {\n                        ++l_size_comp;\n                }\n\n                if (l_size_comp == 3) {\n                        l_size_comp = 4;\n                }\n\n                l_res = l_tile_comp->resolutions + l_tile_comp->minimum_num_resolutions - 1;\n                l_data_size += l_size_comp * (OPJ_UINT32)((l_res->x1 - l_res->x0) * (l_res->y1 - l_res->y0));\n                ++l_img_comp;\n                ++l_tile_comp;\n        }\n\n        return l_data_size;\n}\n\nOPJ_BOOL opj_tcd_encode_tile(   opj_tcd_t *p_tcd,\n                                                        OPJ_UINT32 p_tile_no,\n                                                        OPJ_BYTE *p_dest,\n                                                        OPJ_UINT32 * p_data_written,\n                                                        OPJ_UINT32 p_max_length,\n                                                        opj_codestream_info_t *p_cstr_info)\n{\n\n        if (p_tcd->cur_tp_num == 0) {\n\n                p_tcd->tcd_tileno = p_tile_no;\n                p_tcd->tcp = &p_tcd->cp->tcps[p_tile_no];\n\n                /* INDEX >> \"Precinct_nb_X et Precinct_nb_Y\" */\n                if(p_cstr_info)  {\n                        OPJ_UINT32 l_num_packs = 0;\n                        OPJ_UINT32 i;\n                        opj_tcd_tilecomp_t *l_tilec_idx = &p_tcd->tcd_image->tiles->comps[0];        /* based on component 0 */\n                        opj_tccp_t *l_tccp = p_tcd->tcp->tccps; /* based on component 0 */\n\n                        for (i = 0; i < l_tilec_idx->numresolutions; i++) {\n                                opj_tcd_resolution_t *l_res_idx = &l_tilec_idx->resolutions[i];\n\n                                p_cstr_info->tile[p_tile_no].pw[i] = (int)l_res_idx->pw;\n                                p_cstr_info->tile[p_tile_no].ph[i] = (int)l_res_idx->ph;\n\n                                l_num_packs += l_res_idx->pw * l_res_idx->ph;\n                                p_cstr_info->tile[p_tile_no].pdx[i] = (int)l_tccp->prcw[i];\n                                p_cstr_info->tile[p_tile_no].pdy[i] = (int)l_tccp->prch[i];\n                        }\n                        p_cstr_info->tile[p_tile_no].packet = (opj_packet_info_t*) opj_calloc((size_t)p_cstr_info->numcomps * (size_t)p_cstr_info->numlayers * l_num_packs, sizeof(opj_packet_info_t));\n                        if (!p_cstr_info->tile[p_tile_no].packet) {\n                                /* FIXME event manager error callback */\n                                return OPJ_FALSE;\n                        }\n                }\n                /* << INDEX */\n\n                /* FIXME _ProfStart(PGROUP_DC_SHIFT); */\n                /*---------------TILE-------------------*/\n                if (! opj_tcd_dc_level_shift_encode(p_tcd)) {\n                        return OPJ_FALSE;\n                }\n                /* FIXME _ProfStop(PGROUP_DC_SHIFT); */\n\n                /* FIXME _ProfStart(PGROUP_MCT); */\n                if (! opj_tcd_mct_encode(p_tcd)) {\n                        return OPJ_FALSE;\n                }\n                /* FIXME _ProfStop(PGROUP_MCT); */\n\n                /* FIXME _ProfStart(PGROUP_DWT); */\n                if (! opj_tcd_dwt_encode(p_tcd)) {\n                        return OPJ_FALSE;\n                }\n                /* FIXME  _ProfStop(PGROUP_DWT); */\n\n                /* FIXME  _ProfStart(PGROUP_T1); */\n                if (! opj_tcd_t1_encode(p_tcd)) {\n                        return OPJ_FALSE;\n                }\n                /* FIXME _ProfStop(PGROUP_T1); */\n\n                /* FIXME _ProfStart(PGROUP_RATE); */\n                if (! opj_tcd_rate_allocate_encode(p_tcd,p_dest,p_max_length,p_cstr_info)) {\n                        return OPJ_FALSE;\n                }\n                /* FIXME _ProfStop(PGROUP_RATE); */\n\n        }\n        /*--------------TIER2------------------*/\n\n        /* INDEX */\n        if (p_cstr_info) {\n                p_cstr_info->index_write = 1;\n        }\n        /* FIXME _ProfStart(PGROUP_T2); */\n\n        if (! opj_tcd_t2_encode(p_tcd,p_dest,p_data_written,p_max_length,p_cstr_info)) {\n                return OPJ_FALSE;\n        }\n        /* FIXME _ProfStop(PGROUP_T2); */\n\n        /*---------------CLEAN-------------------*/\n\n        return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_tcd_decode_tile(   opj_tcd_t *p_tcd,\n                                OPJ_BYTE *p_src,\n                                OPJ_UINT32 p_max_length,\n                                OPJ_UINT32 p_tile_no,\n                                opj_codestream_index_t *p_cstr_index\n                                )\n{\n        OPJ_UINT32 l_data_read;\n        p_tcd->tcd_tileno = p_tile_no;\n        p_tcd->tcp = &(p_tcd->cp->tcps[p_tile_no]);\n\n#ifdef TODO_MSD /* FIXME */\n        /* INDEX >>  */\n        if(p_cstr_info) {\n                OPJ_UINT32 resno, compno, numprec = 0;\n                for (compno = 0; compno < (OPJ_UINT32) p_cstr_info->numcomps; compno++) {\n                        opj_tcp_t *tcp = &p_tcd->cp->tcps[0];\n                        opj_tccp_t *tccp = &tcp->tccps[compno];\n                        opj_tcd_tilecomp_t *tilec_idx = &p_tcd->tcd_image->tiles->comps[compno];\n                        for (resno = 0; resno < tilec_idx->numresolutions; resno++) {\n                                opj_tcd_resolution_t *res_idx = &tilec_idx->resolutions[resno];\n                                p_cstr_info->tile[p_tile_no].pw[resno] = res_idx->pw;\n                                p_cstr_info->tile[p_tile_no].ph[resno] = res_idx->ph;\n                                numprec += res_idx->pw * res_idx->ph;\n                                p_cstr_info->tile[p_tile_no].pdx[resno] = tccp->prcw[resno];\n                                p_cstr_info->tile[p_tile_no].pdy[resno] = tccp->prch[resno];\n                        }\n                }\n                p_cstr_info->tile[p_tile_no].packet = (opj_packet_info_t *) opj_malloc(p_cstr_info->numlayers * numprec * sizeof(opj_packet_info_t));\n                p_cstr_info->packno = 0;\n        }\n        /* << INDEX */\n#endif\n\n        /*--------------TIER2------------------*/\n        /* FIXME _ProfStart(PGROUP_T2); */\n        l_data_read = 0;\n        if (! opj_tcd_t2_decode(p_tcd, p_src, &l_data_read, p_max_length, p_cstr_index))\n        {\n                return OPJ_FALSE;\n        }\n        /* FIXME _ProfStop(PGROUP_T2); */\n\n        /*------------------TIER1-----------------*/\n\n        /* FIXME _ProfStart(PGROUP_T1); */\n        if\n                (! opj_tcd_t1_decode(p_tcd))\n        {\n                return OPJ_FALSE;\n        }\n        /* FIXME _ProfStop(PGROUP_T1); */\n\n        /*----------------DWT---------------------*/\n\n        /* FIXME _ProfStart(PGROUP_DWT); */\n        if\n                (! opj_tcd_dwt_decode(p_tcd))\n        {\n                return OPJ_FALSE;\n        }\n        /* FIXME _ProfStop(PGROUP_DWT); */\n\n        /*----------------MCT-------------------*/\n        /* FIXME _ProfStart(PGROUP_MCT); */\n        if\n                (! opj_tcd_mct_decode(p_tcd))\n        {\n                return OPJ_FALSE;\n        }\n        /* FIXME _ProfStop(PGROUP_MCT); */\n\n        /* FIXME _ProfStart(PGROUP_DC_SHIFT); */\n        if\n                (! opj_tcd_dc_level_shift_decode(p_tcd))\n        {\n                return OPJ_FALSE;\n        }\n        /* FIXME _ProfStop(PGROUP_DC_SHIFT); */\n\n\n        /*---------------TILE-------------------*/\n        return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_tcd_update_tile_data ( opj_tcd_t *p_tcd,\n                                    OPJ_BYTE * p_dest,\n                                    OPJ_UINT32 p_dest_length\n                                    )\n{\n        OPJ_UINT32 i,j,k,l_data_size = 0;\n        opj_image_comp_t * l_img_comp = 00;\n        opj_tcd_tilecomp_t * l_tilec = 00;\n        opj_tcd_resolution_t * l_res;\n        OPJ_UINT32 l_size_comp, l_remaining;\n        OPJ_UINT32 l_stride, l_width,l_height;\n\n        l_data_size = opj_tcd_get_decoded_tile_size(p_tcd);\n        if (l_data_size > p_dest_length) {\n                return OPJ_FALSE;\n        }\n\n        l_tilec = p_tcd->tcd_image->tiles->comps;\n        l_img_comp = p_tcd->image->comps;\n\n        for (i=0;i<p_tcd->image->numcomps;++i) {\n                l_size_comp = l_img_comp->prec >> 3; /*(/ 8)*/\n                l_remaining = l_img_comp->prec & 7;  /* (%8) */\n                l_res = l_tilec->resolutions + l_img_comp->resno_decoded;\n                l_width = (OPJ_UINT32)(l_res->x1 - l_res->x0);\n                l_height = (OPJ_UINT32)(l_res->y1 - l_res->y0);\n                l_stride = (OPJ_UINT32)(l_tilec->x1 - l_tilec->x0) - l_width;\n\n                if (l_remaining) {\n                        ++l_size_comp;\n                }\n\n                if (l_size_comp == 3) {\n                        l_size_comp = 4;\n                }\n\n                switch (l_size_comp)\n                        {\n                        case 1:\n                                {\n                                        OPJ_CHAR * l_dest_ptr = (OPJ_CHAR *) p_dest;\n                                        const OPJ_INT32 * l_src_ptr = l_tilec->data;\n\n                                        if (l_img_comp->sgnd) {\n                                                for (j=0;j<l_height;++j) {\n                                                        for (k=0;k<l_width;++k) {\n                                                                *(l_dest_ptr++) = (OPJ_CHAR) (*(l_src_ptr++));\n                                                        }\n                                                        l_src_ptr += l_stride;\n                                                }\n                                        }\n                                        else {\n                                                for (j=0;j<l_height;++j) {\n                                                        for     (k=0;k<l_width;++k) {\n                                                                *(l_dest_ptr++) = (OPJ_CHAR) ((*(l_src_ptr++))&0xff);\n                                                        }\n                                                        l_src_ptr += l_stride;\n                                                }\n                                        }\n\n                                        p_dest = (OPJ_BYTE *)l_dest_ptr;\n                                }\n                                break;\n                        case 2:\n                                {\n                                        const OPJ_INT32 * l_src_ptr = l_tilec->data;\n                                        OPJ_INT16 * l_dest_ptr = (OPJ_INT16 *) p_dest;\n\n                                        if (l_img_comp->sgnd) {\n                                                for (j=0;j<l_height;++j) {\n                                                        for (k=0;k<l_width;++k) {\n                                                                *(l_dest_ptr++) = (OPJ_INT16) (*(l_src_ptr++));\n                                                        }\n                                                        l_src_ptr += l_stride;\n                                                }\n                                        }\n                                        else {\n                                                for (j=0;j<l_height;++j) {\n                                                        for (k=0;k<l_width;++k) {\n                                                                *(l_dest_ptr++) = (OPJ_INT16) ((*(l_src_ptr++))&0xffff);\n                                                        }\n                                                        l_src_ptr += l_stride;\n                                                }\n                                        }\n\n                                        p_dest = (OPJ_BYTE*) l_dest_ptr;\n                                }\n                                break;\n                        case 4:\n                                {\n                                        OPJ_INT32 * l_dest_ptr = (OPJ_INT32 *) p_dest;\n                                        OPJ_INT32 * l_src_ptr = l_tilec->data;\n\n                                        for (j=0;j<l_height;++j) {\n                                                for (k=0;k<l_width;++k) {\n                                                        *(l_dest_ptr++) = (*(l_src_ptr++));\n                                                }\n                                                l_src_ptr += l_stride;\n                                        }\n\n                                        p_dest = (OPJ_BYTE*) l_dest_ptr;\n                                }\n                                break;\n                }\n\n                ++l_img_comp;\n                ++l_tilec;\n        }\n\n        return OPJ_TRUE;\n}\n\n\n\n\nvoid opj_tcd_free_tile(opj_tcd_t *p_tcd)\n{\n        OPJ_UINT32 compno, resno, bandno, precno;\n        opj_tcd_tile_t *l_tile = 00;\n        opj_tcd_tilecomp_t *l_tile_comp = 00;\n        opj_tcd_resolution_t *l_res = 00;\n        opj_tcd_band_t *l_band = 00;\n        opj_tcd_precinct_t *l_precinct = 00;\n        OPJ_UINT32 l_nb_resolutions, l_nb_precincts;\n        void (* l_tcd_code_block_deallocate) (opj_tcd_precinct_t *) = 00;\n\n        if (! p_tcd) {\n                return;\n        }\n\n        if (! p_tcd->tcd_image) {\n                return;\n        }\n\n        if (p_tcd->m_is_decoder) {\n                l_tcd_code_block_deallocate = opj_tcd_code_block_dec_deallocate;\n        }\n        else {\n                l_tcd_code_block_deallocate = opj_tcd_code_block_enc_deallocate;\n        }\n\n        l_tile = p_tcd->tcd_image->tiles;\n        if (! l_tile) {\n                return;\n        }\n\n        l_tile_comp = l_tile->comps;\n\n        for (compno = 0; compno < l_tile->numcomps; ++compno) {\n                l_res = l_tile_comp->resolutions;\n                if (l_res) {\n\n                        l_nb_resolutions = l_tile_comp->resolutions_size / sizeof(opj_tcd_resolution_t);\n                        for (resno = 0; resno < l_nb_resolutions; ++resno) {\n                                l_band = l_res->bands;\n                                for     (bandno = 0; bandno < 3; ++bandno) {\n                                        l_precinct = l_band->precincts;\n                                        if (l_precinct) {\n\n                                                l_nb_precincts = l_band->precincts_data_size / sizeof(opj_tcd_precinct_t);\n                                                for (precno = 0; precno < l_nb_precincts; ++precno) {\n                                                        opj_tgt_destroy(l_precinct->incltree);\n                                                        l_precinct->incltree = 00;\n                                                        opj_tgt_destroy(l_precinct->imsbtree);\n                                                        l_precinct->imsbtree = 00;\n                                                        (*l_tcd_code_block_deallocate) (l_precinct);\n                                                        ++l_precinct;\n                                                }\n\n                                                opj_free(l_band->precincts);\n                                                l_band->precincts = 00;\n                                        }\n                                        ++l_band;\n                                } /* for (resno */\n                                ++l_res;\n                        }\n\n                        opj_free(l_tile_comp->resolutions);\n                        l_tile_comp->resolutions = 00;\n                }\n\n                if (l_tile_comp->ownsData && l_tile_comp->data) {\n                        opj_free(l_tile_comp->data);\n                        l_tile_comp->data = 00;\n                        l_tile_comp->ownsData = 0;\n                        l_tile_comp->data_size = 0;\n                        l_tile_comp->data_size_needed = 0;\n                }\n                ++l_tile_comp;\n        }\n\n        opj_free(l_tile->comps);\n        l_tile->comps = 00;\n        opj_free(p_tcd->tcd_image->tiles);\n        p_tcd->tcd_image->tiles = 00;\n}\n\n\nOPJ_BOOL opj_tcd_t2_decode (opj_tcd_t *p_tcd,\n                            OPJ_BYTE * p_src_data,\n                            OPJ_UINT32 * p_data_read,\n                            OPJ_UINT32 p_max_src_size,\n                            opj_codestream_index_t *p_cstr_index\n                            )\n{\n        opj_t2_t * l_t2;\n\n        l_t2 = opj_t2_create(p_tcd->image, p_tcd->cp);\n        if (l_t2 == 00) {\n                return OPJ_FALSE;\n        }\n\n        if (! opj_t2_decode_packets(\n                                        l_t2,\n                                        p_tcd->tcd_tileno,\n                                        p_tcd->tcd_image->tiles,\n                                        p_src_data,\n                                        p_data_read,\n                                        p_max_src_size,\n                                        p_cstr_index)) {\n                opj_t2_destroy(l_t2);\n                return OPJ_FALSE;\n        }\n\n        opj_t2_destroy(l_t2);\n\n        /*---------------CLEAN-------------------*/\n        return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_tcd_t1_decode ( opj_tcd_t *p_tcd )\n{\n        OPJ_UINT32 compno;\n        opj_t1_t * l_t1;\n        opj_tcd_tile_t * l_tile = p_tcd->tcd_image->tiles;\n        opj_tcd_tilecomp_t* l_tile_comp = l_tile->comps;\n        opj_tccp_t * l_tccp = p_tcd->tcp->tccps;\n\n\n        l_t1 = opj_t1_create(OPJ_FALSE);\n        if (l_t1 == 00) {\n                return OPJ_FALSE;\n        }\n\n        for (compno = 0; compno < l_tile->numcomps; ++compno) {\n                /* The +3 is headroom required by the vectorized DWT */\n                if (OPJ_FALSE == opj_t1_decode_cblks(l_t1, l_tile_comp, l_tccp)) {\n                        opj_t1_destroy(l_t1);\n                        return OPJ_FALSE;\n                }\n                ++l_tile_comp;\n                ++l_tccp;\n        }\n\n        opj_t1_destroy(l_t1);\n\n        return OPJ_TRUE;\n}\n\n\nOPJ_BOOL opj_tcd_dwt_decode ( opj_tcd_t *p_tcd )\n{\n        OPJ_UINT32 compno;\n        opj_tcd_tile_t * l_tile = p_tcd->tcd_image->tiles;\n        opj_tcd_tilecomp_t * l_tile_comp = l_tile->comps;\n        opj_tccp_t * l_tccp = p_tcd->tcp->tccps;\n        opj_image_comp_t * l_img_comp = p_tcd->image->comps;\n\n        for (compno = 0; compno < l_tile->numcomps; compno++) {\n                /*\n                if (tcd->cp->reduce != 0) {\n                        tcd->image->comps[compno].resno_decoded =\n                                tile->comps[compno].numresolutions - tcd->cp->reduce - 1;\n                        if (tcd->image->comps[compno].resno_decoded < 0)\n                        {\n                                return false;\n                        }\n                }\n                numres2decode = tcd->image->comps[compno].resno_decoded + 1;\n                if(numres2decode > 0){\n                */\n\n                if (l_tccp->qmfbid == 1) {\n                        if (! opj_dwt_decode(l_tile_comp, l_img_comp->resno_decoded+1)) {\n                                return OPJ_FALSE;\n                        }\n                }\n                else {\n                        if (! opj_dwt_decode_real(l_tile_comp, l_img_comp->resno_decoded+1)) {\n                                return OPJ_FALSE;\n                        }\n                }\n\n                ++l_tile_comp;\n                ++l_img_comp;\n                ++l_tccp;\n        }\n\n        return OPJ_TRUE;\n}\nOPJ_BOOL opj_tcd_mct_decode ( opj_tcd_t *p_tcd )\n{\n        opj_tcd_tile_t * l_tile = p_tcd->tcd_image->tiles;\n        opj_tcp_t * l_tcp = p_tcd->tcp;\n        opj_tcd_tilecomp_t * l_tile_comp = l_tile->comps;\n        OPJ_UINT32 l_samples,i;\n\n        if (! l_tcp->mct) {\n                return OPJ_TRUE;\n        }\n\n        l_samples = (OPJ_UINT32)((l_tile_comp->x1 - l_tile_comp->x0) * (l_tile_comp->y1 - l_tile_comp->y0));\n\n        if (l_tile->numcomps >= 3 ){\n                /* testcase 1336.pdf.asan.47.376 */\n                if ((l_tile->comps[0].x1 - l_tile->comps[0].x0) * (l_tile->comps[0].y1 - l_tile->comps[0].y0) < (OPJ_INT32)l_samples ||\n                    (l_tile->comps[1].x1 - l_tile->comps[1].x0) * (l_tile->comps[1].y1 - l_tile->comps[1].y0) < (OPJ_INT32)l_samples ||\n                    (l_tile->comps[2].x1 - l_tile->comps[2].x0) * (l_tile->comps[2].y1 - l_tile->comps[2].y0) < (OPJ_INT32)l_samples) {\n                        fprintf(stderr, \"Tiles don't all have the same dimension. Skip the MCT step.\\n\");\n                        return OPJ_FALSE;\n                }\n                else if (l_tcp->mct == 2) {\n                        OPJ_BYTE ** l_data;\n\n                        if (! l_tcp->m_mct_decoding_matrix) {\n                                return OPJ_TRUE;\n                        }\n\n                        l_data = (OPJ_BYTE **) opj_malloc(l_tile->numcomps*sizeof(OPJ_BYTE*));\n                        if (! l_data) {\n                                return OPJ_FALSE;\n                        }\n\n                        for (i=0;i<l_tile->numcomps;++i) {\n                                l_data[i] = (OPJ_BYTE*) l_tile_comp->data;\n                                ++l_tile_comp;\n                        }\n\n                        if (! opj_mct_decode_custom(/* MCT data */\n                                                                        (OPJ_BYTE*) l_tcp->m_mct_decoding_matrix,\n                                                                        /* size of components */\n                                                                        l_samples,\n                                                                        /* components */\n                                                                        l_data,\n                                                                        /* nb of components (i.e. size of pData) */\n                                                                        l_tile->numcomps,\n                                                                        /* tells if the data is signed */\n                                                                        p_tcd->image->comps->sgnd)) {\n                                opj_free(l_data);\n                                return OPJ_FALSE;\n                        }\n\n                        opj_free(l_data);\n                }\n                else {\n                        if (l_tcp->tccps->qmfbid == 1) {\n                                opj_mct_decode(     l_tile->comps[0].data,\n                                                        l_tile->comps[1].data,\n                                                        l_tile->comps[2].data,\n                                                        l_samples);\n                        }\n                        else {\n                            opj_mct_decode_real((OPJ_FLOAT32*)l_tile->comps[0].data,\n                                                (OPJ_FLOAT32*)l_tile->comps[1].data,\n                                                (OPJ_FLOAT32*)l_tile->comps[2].data,\n                                                l_samples);\n                        }\n                }\n        }\n        else {\n                /* FIXME need to use opj_event_msg function */\n                fprintf(stderr,\"Number of components (%d) is inconsistent with a MCT. Skip the MCT step.\\n\",l_tile->numcomps);\n        }\n\n        return OPJ_TRUE;\n}\n\n\nOPJ_BOOL opj_tcd_dc_level_shift_decode ( opj_tcd_t *p_tcd )\n{\n        OPJ_UINT32 compno;\n        opj_tcd_tilecomp_t * l_tile_comp = 00;\n        opj_tccp_t * l_tccp = 00;\n        opj_image_comp_t * l_img_comp = 00;\n        opj_tcd_resolution_t* l_res = 00;\n        opj_tcd_tile_t * l_tile;\n        OPJ_UINT32 l_width,l_height,i,j;\n        OPJ_INT32 * l_current_ptr;\n        OPJ_INT32 l_min, l_max;\n        OPJ_UINT32 l_stride;\n\n        l_tile = p_tcd->tcd_image->tiles;\n        l_tile_comp = l_tile->comps;\n        l_tccp = p_tcd->tcp->tccps;\n        l_img_comp = p_tcd->image->comps;\n\n        for (compno = 0; compno < l_tile->numcomps; compno++) {\n                l_res = l_tile_comp->resolutions + l_img_comp->resno_decoded;\n                l_width = (OPJ_UINT32)(l_res->x1 - l_res->x0);\n                l_height = (OPJ_UINT32)(l_res->y1 - l_res->y0);\n                l_stride = (OPJ_UINT32)(l_tile_comp->x1 - l_tile_comp->x0) - l_width;\n\n                assert(l_height == 0 || l_width + l_stride <= l_tile_comp->data_size / l_height); /*MUPDF*/\n\n                if (l_img_comp->sgnd) {\n                        l_min = -(1 << (l_img_comp->prec - 1));\n                        l_max = (1 << (l_img_comp->prec - 1)) - 1;\n                }\n                else {\n            l_min = 0;\n                        l_max = (1 << l_img_comp->prec) - 1;\n                }\n\n                l_current_ptr = l_tile_comp->data;\n\n                if (l_tccp->qmfbid == 1) {\n                        for (j=0;j<l_height;++j) {\n                                for (i = 0; i < l_width; ++i) {\n                                        *l_current_ptr = opj_int_clamp(*l_current_ptr + l_tccp->m_dc_level_shift, l_min, l_max);\n                                        ++l_current_ptr;\n                                }\n                                l_current_ptr += l_stride;\n                        }\n                }\n                else {\n                        for (j=0;j<l_height;++j) {\n                                for (i = 0; i < l_width; ++i) {\n                                        OPJ_FLOAT32 l_value = *((OPJ_FLOAT32 *) l_current_ptr);\n                                        *l_current_ptr = opj_int_clamp((OPJ_INT32)lrintf(l_value) + l_tccp->m_dc_level_shift, l_min, l_max); ;\n                                        ++l_current_ptr;\n                                }\n                                l_current_ptr += l_stride;\n                        }\n                }\n\n                ++l_img_comp;\n                ++l_tccp;\n                ++l_tile_comp;\n        }\n\n        return OPJ_TRUE;\n}\n\n\n\n/**\n * Deallocates the encoding data of the given precinct.\n */\nvoid opj_tcd_code_block_dec_deallocate (opj_tcd_precinct_t * p_precinct)\n{\n        OPJ_UINT32 cblkno , l_nb_code_blocks;\n\n        opj_tcd_cblk_dec_t * l_code_block = p_precinct->cblks.dec;\n        if (l_code_block) {\n                /*fprintf(stderr,\"deallocate codeblock:{\\n\");*/\n                /*fprintf(stderr,\"\\t x0=%d, y0=%d, x1=%d, y1=%d\\n\",l_code_block->x0, l_code_block->y0, l_code_block->x1, l_code_block->y1);*/\n                /*fprintf(stderr,\"\\t numbps=%d, numlenbits=%d, len=%d, numnewpasses=%d, real_num_segs=%d, m_current_max_segs=%d\\n \",\n                                l_code_block->numbps, l_code_block->numlenbits, l_code_block->len, l_code_block->numnewpasses, l_code_block->real_num_segs, l_code_block->m_current_max_segs );*/\n\n\n                l_nb_code_blocks = p_precinct->block_size / sizeof(opj_tcd_cblk_dec_t);\n                /*fprintf(stderr,\"nb_code_blocks =%d\\t}\\n\", l_nb_code_blocks);*/\n\n                for (cblkno = 0; cblkno < l_nb_code_blocks; ++cblkno) {\n\n                        if (l_code_block->data) {\n                                opj_free(l_code_block->data);\n                                l_code_block->data = 00;\n                        }\n\n                        if (l_code_block->segs) {\n                                opj_free(l_code_block->segs );\n                                l_code_block->segs = 00;\n                        }\n\n                        ++l_code_block;\n                }\n\n                opj_free(p_precinct->cblks.dec);\n                p_precinct->cblks.dec = 00;\n        }\n}\n\n/**\n * Deallocates the encoding data of the given precinct.\n */\nvoid opj_tcd_code_block_enc_deallocate (opj_tcd_precinct_t * p_precinct)\n{       \n        OPJ_UINT32 cblkno , l_nb_code_blocks;\n\n        opj_tcd_cblk_enc_t * l_code_block = p_precinct->cblks.enc;\n        if (l_code_block) {\n                l_nb_code_blocks = p_precinct->block_size / sizeof(opj_tcd_cblk_enc_t);\n                \n                for     (cblkno = 0; cblkno < l_nb_code_blocks; ++cblkno)  {\n                        if (l_code_block->data) {\n                                opj_free(l_code_block->data - 1);\n                                l_code_block->data = 00;\n                        }\n\n                        if (l_code_block->layers) {\n                                opj_free(l_code_block->layers );\n                                l_code_block->layers = 00;\n                        }\n\n                        if (l_code_block->passes) {\n                                opj_free(l_code_block->passes );\n                                l_code_block->passes = 00;\n                        }\n                        ++l_code_block;\n                }\n\n                opj_free(p_precinct->cblks.enc);\n                \n                p_precinct->cblks.enc = 00;\n        }\n}\n\nOPJ_UINT32 opj_tcd_get_encoded_tile_size ( opj_tcd_t *p_tcd )\n{\n        OPJ_UINT32 i,l_data_size = 0;\n        opj_image_comp_t * l_img_comp = 00;\n        opj_tcd_tilecomp_t * l_tilec = 00;\n        OPJ_UINT32 l_size_comp, l_remaining;\n\n        l_tilec = p_tcd->tcd_image->tiles->comps;\n        l_img_comp = p_tcd->image->comps;\n        for (i=0;i<p_tcd->image->numcomps;++i) {\n                l_size_comp = l_img_comp->prec >> 3; /*(/ 8)*/\n                l_remaining = l_img_comp->prec & 7;  /* (%8) */\n\n                if (l_remaining) {\n                        ++l_size_comp;\n                }\n\n                if (l_size_comp == 3) {\n                        l_size_comp = 4;\n                }\n\n                l_data_size += l_size_comp * (OPJ_UINT32)((l_tilec->x1 - l_tilec->x0) * (l_tilec->y1 - l_tilec->y0));\n                ++l_img_comp;\n                ++l_tilec;\n        }\n\n        return l_data_size;\n}\n                \nOPJ_BOOL opj_tcd_dc_level_shift_encode ( opj_tcd_t *p_tcd )\n{\n        OPJ_UINT32 compno;\n        opj_tcd_tilecomp_t * l_tile_comp = 00;\n        opj_tccp_t * l_tccp = 00;\n        opj_image_comp_t * l_img_comp = 00;\n        opj_tcd_tile_t * l_tile;\n        OPJ_UINT32 l_nb_elem,i;\n        OPJ_INT32 * l_current_ptr;\n\n        l_tile = p_tcd->tcd_image->tiles;\n        l_tile_comp = l_tile->comps;\n        l_tccp = p_tcd->tcp->tccps;\n        l_img_comp = p_tcd->image->comps;\n\n        for (compno = 0; compno < l_tile->numcomps; compno++) {\n                l_current_ptr = l_tile_comp->data;\n                l_nb_elem = (OPJ_UINT32)((l_tile_comp->x1 - l_tile_comp->x0) * (l_tile_comp->y1 - l_tile_comp->y0));\n\n                if (l_tccp->qmfbid == 1) {\n                        for     (i = 0; i < l_nb_elem; ++i) {\n                                *l_current_ptr -= l_tccp->m_dc_level_shift ;\n                                ++l_current_ptr;\n                        }\n                }\n                else {\n                        for (i = 0; i < l_nb_elem; ++i) {\n                                *l_current_ptr = (*l_current_ptr - l_tccp->m_dc_level_shift) << 11 ;\n                                ++l_current_ptr;\n                        }\n                }\n\n                ++l_img_comp;\n                ++l_tccp;\n                ++l_tile_comp;\n        }\n\n        return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_tcd_mct_encode ( opj_tcd_t *p_tcd )\n{\n        opj_tcd_tile_t * l_tile = p_tcd->tcd_image->tiles;\n        opj_tcd_tilecomp_t * l_tile_comp = p_tcd->tcd_image->tiles->comps;\n        OPJ_UINT32 samples = (OPJ_UINT32)((l_tile_comp->x1 - l_tile_comp->x0) * (l_tile_comp->y1 - l_tile_comp->y0));\n        OPJ_UINT32 i;\n        OPJ_BYTE ** l_data = 00;\n        opj_tcp_t * l_tcp = p_tcd->tcp;\n\n        if(!p_tcd->tcp->mct) {\n                return OPJ_TRUE;\n        }\n\n        if (p_tcd->tcp->mct == 2) {\n                if (! p_tcd->tcp->m_mct_coding_matrix) {\n                        return OPJ_TRUE;\n                }\n\n        l_data = (OPJ_BYTE **) opj_malloc(l_tile->numcomps*sizeof(OPJ_BYTE*));\n                if (! l_data) {\n                        return OPJ_FALSE;\n                }\n\n                for (i=0;i<l_tile->numcomps;++i) {\n                        l_data[i] = (OPJ_BYTE*) l_tile_comp->data;\n                        ++l_tile_comp;\n                }\n\n                if (! opj_mct_encode_custom(/* MCT data */\n                                        (OPJ_BYTE*) p_tcd->tcp->m_mct_coding_matrix,\n                                        /* size of components */\n                                        samples,\n                                        /* components */\n                                        l_data,\n                                        /* nb of components (i.e. size of pData) */\n                                        l_tile->numcomps,\n                                        /* tells if the data is signed */\n                                        p_tcd->image->comps->sgnd) )\n                {\n            opj_free(l_data);\n                        return OPJ_FALSE;\n                }\n\n                opj_free(l_data);\n        }\n        else if (l_tcp->tccps->qmfbid == 0) {\n                opj_mct_encode_real(l_tile->comps[0].data, l_tile->comps[1].data, l_tile->comps[2].data, samples);\n        }\n        else {\n                opj_mct_encode(l_tile->comps[0].data, l_tile->comps[1].data, l_tile->comps[2].data, samples);\n        }\n\n        return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_tcd_dwt_encode ( opj_tcd_t *p_tcd )\n{\n        opj_tcd_tile_t * l_tile = p_tcd->tcd_image->tiles;\n        opj_tcd_tilecomp_t * l_tile_comp = p_tcd->tcd_image->tiles->comps;\n        opj_tccp_t * l_tccp = p_tcd->tcp->tccps;\n        OPJ_UINT32 compno;\n\n        for (compno = 0; compno < l_tile->numcomps; ++compno) {\n                if (l_tccp->qmfbid == 1) {\n                        if (! opj_dwt_encode(l_tile_comp)) {\n                                return OPJ_FALSE;\n                        }\n                }\n                else if (l_tccp->qmfbid == 0) {\n                        if (! opj_dwt_encode_real(l_tile_comp)) {\n                                return OPJ_FALSE;\n                        }\n                }\n\n                ++l_tile_comp;\n                ++l_tccp;\n        }\n\n        return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_tcd_t1_encode ( opj_tcd_t *p_tcd )\n{\n        opj_t1_t * l_t1;\n        const OPJ_FLOAT64 * l_mct_norms;\n        OPJ_UINT32 l_mct_numcomps = 0U;\n        opj_tcp_t * l_tcp = p_tcd->tcp;\n\n        l_t1 = opj_t1_create(OPJ_TRUE);\n        if (l_t1 == 00) {\n                return OPJ_FALSE;\n        }\n\n        if (l_tcp->mct == 1) {\n                l_mct_numcomps = 3U;\n                /* irreversible encoding */\n                if (l_tcp->tccps->qmfbid == 0) {\n                        l_mct_norms = opj_mct_get_mct_norms_real();\n                }\n                else {\n                        l_mct_norms = opj_mct_get_mct_norms();\n                }\n        }\n        else {\n                l_mct_numcomps = p_tcd->image->numcomps;\n                l_mct_norms = (const OPJ_FLOAT64 *) (l_tcp->mct_norms);\n        }\n\n        if (! opj_t1_encode_cblks(l_t1, p_tcd->tcd_image->tiles , l_tcp, l_mct_norms, l_mct_numcomps)) {\n        opj_t1_destroy(l_t1);\n                return OPJ_FALSE;\n        }\n\n        opj_t1_destroy(l_t1);\n\n        return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_tcd_t2_encode (opj_tcd_t *p_tcd,\n                                                OPJ_BYTE * p_dest_data,\n                                                OPJ_UINT32 * p_data_written,\n                                                OPJ_UINT32 p_max_dest_size,\n                                                opj_codestream_info_t *p_cstr_info )\n{\n        opj_t2_t * l_t2;\n\n        l_t2 = opj_t2_create(p_tcd->image, p_tcd->cp);\n        if (l_t2 == 00) {\n                return OPJ_FALSE;\n        }\n\n        if (! opj_t2_encode_packets(\n                                        l_t2,\n                                        p_tcd->tcd_tileno,\n                                        p_tcd->tcd_image->tiles,\n                                        p_tcd->tcp->numlayers,\n                                        p_dest_data,\n                                        p_data_written,\n                                        p_max_dest_size,\n                                        p_cstr_info,\n                                        p_tcd->tp_num,\n                                        p_tcd->tp_pos,\n                                        p_tcd->cur_pino,\n                                        FINAL_PASS))\n        {\n                opj_t2_destroy(l_t2);\n                return OPJ_FALSE;\n        }\n\n        opj_t2_destroy(l_t2);\n\n        /*---------------CLEAN-------------------*/\n        return OPJ_TRUE;\n}\n\n\nOPJ_BOOL opj_tcd_rate_allocate_encode(  opj_tcd_t *p_tcd,\n                                                                            OPJ_BYTE * p_dest_data,\n                                                                            OPJ_UINT32 p_max_dest_size,\n                                                                            opj_codestream_info_t *p_cstr_info )\n{\n        opj_cp_t * l_cp = p_tcd->cp;\n        OPJ_UINT32 l_nb_written = 0;\n\n        if (p_cstr_info)  {\n                p_cstr_info->index_write = 0;\n        }\n\n        if (l_cp->m_specific_param.m_enc.m_disto_alloc|| l_cp->m_specific_param.m_enc.m_fixed_quality)  {\n                /* fixed_quality */\n                /* Normal Rate/distortion allocation */\n                if (! opj_tcd_rateallocate(p_tcd, p_dest_data,&l_nb_written, p_max_dest_size, p_cstr_info)) {\n                        return OPJ_FALSE;\n                }\n        }\n        else {\n                /* Fixed layer allocation */\n                opj_tcd_rateallocate_fixed(p_tcd);\n        }\n\n        return OPJ_TRUE;\n}\n\n\nOPJ_BOOL opj_tcd_copy_tile_data (       opj_tcd_t *p_tcd,\n                                                                    OPJ_BYTE * p_src,\n                                                                    OPJ_UINT32 p_src_length )\n{\n        OPJ_UINT32 i,j,l_data_size = 0;\n        opj_image_comp_t * l_img_comp = 00;\n        opj_tcd_tilecomp_t * l_tilec = 00;\n        OPJ_UINT32 l_size_comp, l_remaining;\n        OPJ_UINT32 l_nb_elem;\n\n        l_data_size = opj_tcd_get_encoded_tile_size(p_tcd);\n        if (l_data_size != p_src_length) {\n                return OPJ_FALSE;\n        }\n\n        l_tilec = p_tcd->tcd_image->tiles->comps;\n        l_img_comp = p_tcd->image->comps;\n        for (i=0;i<p_tcd->image->numcomps;++i) {\n                l_size_comp = l_img_comp->prec >> 3; /*(/ 8)*/\n                l_remaining = l_img_comp->prec & 7;  /* (%8) */\n                l_nb_elem = (OPJ_UINT32)((l_tilec->x1 - l_tilec->x0) * (l_tilec->y1 - l_tilec->y0));\n\n                if (l_remaining) {\n                        ++l_size_comp;\n                }\n\n                if (l_size_comp == 3) {\n                        l_size_comp = 4;\n                }\n\n                switch (l_size_comp) {\n                        case 1:\n                                {\n                                        OPJ_CHAR * l_src_ptr = (OPJ_CHAR *) p_src;\n                                        OPJ_INT32 * l_dest_ptr = l_tilec->data;\n\n                                        if (l_img_comp->sgnd) {\n                                                for (j=0;j<l_nb_elem;++j) {\n                                                        *(l_dest_ptr++) = (OPJ_INT32) (*(l_src_ptr++));\n                                                }\n                                        }\n                                        else {\n                                                for (j=0;j<l_nb_elem;++j) {\n                                                        *(l_dest_ptr++) = (*(l_src_ptr++))&0xff;\n                                                }\n                                        }\n\n                                        p_src = (OPJ_BYTE*) l_src_ptr;\n                                }\n                                break;\n                        case 2:\n                                {\n                                        OPJ_INT32 * l_dest_ptr = l_tilec->data;\n                                        OPJ_INT16 * l_src_ptr = (OPJ_INT16 *) p_src;\n\n                                        if (l_img_comp->sgnd) {\n                                                for (j=0;j<l_nb_elem;++j) {\n                                                        *(l_dest_ptr++) = (OPJ_INT32) (*(l_src_ptr++));\n                                                }\n                                        }\n                                        else {\n                                                for (j=0;j<l_nb_elem;++j) {\n                                                        *(l_dest_ptr++) = (*(l_src_ptr++))&0xffff;\n                                                }\n                                        }\n\n                                        p_src = (OPJ_BYTE*) l_src_ptr;\n                                }\n                                break;\n                        case 4:\n                                {\n                                        OPJ_INT32 * l_src_ptr = (OPJ_INT32 *) p_src;\n                                        OPJ_INT32 * l_dest_ptr = l_tilec->data;\n\n                                        for (j=0;j<l_nb_elem;++j) {\n                                                *(l_dest_ptr++) = (OPJ_INT32) (*(l_src_ptr++));\n                                        }\n\n                                        p_src = (OPJ_BYTE*) l_src_ptr;\n                                }\n                                break;\n                }\n\n                ++l_img_comp;\n                ++l_tilec;\n        }\n\n        return OPJ_TRUE;\n}\n"], "fixing_code": ["/*\n * The copyright in this software is being made available under the 2-clauses \n * BSD License, included below. This software may be subject to other third \n * party and contributor rights, including patent rights, and no such rights\n * are granted under this license.\n *\n * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium\n * Copyright (c) 2002-2014, Professor Benoit Macq\n * Copyright (c) 2001-2003, David Janssens\n * Copyright (c) 2002-2003, Yannick Verschueren\n * Copyright (c) 2003-2007, Francois-Olivier Devaux \n * Copyright (c) 2003-2014, Antonin Descampe\n * Copyright (c) 2005, Herve Drolon, FreeImage Team\n * Copyright (c) 2006-2007, Parvatha Elangovan\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"opj_includes.h\"\n\n/** @defgroup PI PI - Implementation of a packet iterator */\n/*@{*/\n\n/** @name Local static functions */\n/*@{*/\n\n/**\nGet next packet in layer-resolution-component-precinct order.\n@param pi packet iterator to modify\n@return returns false if pi pointed to the last packet or else returns true\n*/\nstatic OPJ_BOOL opj_pi_next_lrcp(opj_pi_iterator_t * pi);\n/**\nGet next packet in resolution-layer-component-precinct order.\n@param pi packet iterator to modify\n@return returns false if pi pointed to the last packet or else returns true\n*/\nstatic OPJ_BOOL opj_pi_next_rlcp(opj_pi_iterator_t * pi);\n/**\nGet next packet in resolution-precinct-component-layer order.\n@param pi packet iterator to modify\n@return returns false if pi pointed to the last packet or else returns true\n*/\nstatic OPJ_BOOL opj_pi_next_rpcl(opj_pi_iterator_t * pi);\n/**\nGet next packet in precinct-component-resolution-layer order.\n@param pi packet iterator to modify\n@return returns false if pi pointed to the last packet or else returns true\n*/\nstatic OPJ_BOOL opj_pi_next_pcrl(opj_pi_iterator_t * pi);\n/**\nGet next packet in component-precinct-resolution-layer order.\n@param pi packet iterator to modify\n@return returns false if pi pointed to the last packet or else returns true\n*/\nstatic OPJ_BOOL opj_pi_next_cprl(opj_pi_iterator_t * pi);\n\n/**\n * Updates the coding parameters if the encoding is used with Progression order changes and final (or cinema parameters are used).\n *\n * @param\tp_cp\t\tthe coding parameters to modify\n * @param\tp_tileno\tthe tile index being concerned.\n * @param\tp_tx0\t\tX0 parameter for the tile\n * @param\tp_tx1\t\tX1 parameter for the tile\n * @param\tp_ty0\t\tY0 parameter for the tile\n * @param\tp_ty1\t\tY1 parameter for the tile\n * @param\tp_max_prec\tthe maximum precision for all the bands of the tile\n * @param\tp_max_res\tthe maximum number of resolutions for all the poc inside the tile.\n * @param\tp_dx_min\t\tthe minimum dx of all the components of all the resolutions for the tile.\n * @param\tp_dy_min\t\tthe minimum dy of all the components of all the resolutions for the tile.\n */\nstatic void opj_pi_update_encode_poc_and_final ( opj_cp_t *p_cp,\n                                                 OPJ_UINT32 p_tileno,\n                                                 OPJ_INT32 p_tx0,\n                                                 OPJ_INT32 p_tx1,\n                                                 OPJ_INT32 p_ty0,\n                                                 OPJ_INT32 p_ty1,\n                                                 OPJ_UINT32 p_max_prec,\n                                                 OPJ_UINT32 p_max_res,\n                                                 OPJ_UINT32 p_dx_min,\n                                                 OPJ_UINT32 p_dy_min);\n\n/**\n * Updates the coding parameters if the encoding is not used with Progression order changes and final (and cinema parameters are used).\n *\n * @param\tp_cp\t\tthe coding parameters to modify\n * @param\tp_num_comps\t\tthe number of components\n * @param\tp_tileno\tthe tile index being concerned.\n * @param\tp_tx0\t\tX0 parameter for the tile\n * @param\tp_tx1\t\tX1 parameter for the tile\n * @param\tp_ty0\t\tY0 parameter for the tile\n * @param\tp_ty1\t\tY1 parameter for the tile\n * @param\tp_max_prec\tthe maximum precision for all the bands of the tile\n * @param\tp_max_res\tthe maximum number of resolutions for all the poc inside the tile.\n * @param\tp_dx_min\t\tthe minimum dx of all the components of all the resolutions for the tile.\n * @param\tp_dy_min\t\tthe minimum dy of all the components of all the resolutions for the tile.\n */\nstatic void opj_pi_update_encode_not_poc (  opj_cp_t *p_cp,\n                                            OPJ_UINT32 p_num_comps,\n                                            OPJ_UINT32 p_tileno,\n                                            OPJ_INT32 p_tx0,\n                                            OPJ_INT32 p_tx1,\n                                            OPJ_INT32 p_ty0,\n                                            OPJ_INT32 p_ty1,\n                                            OPJ_UINT32 p_max_prec,\n                                            OPJ_UINT32 p_max_res,\n                                            OPJ_UINT32 p_dx_min,\n                                            OPJ_UINT32 p_dy_min);\n/**\n * Gets the encoding parameters needed to update the coding parameters and all the pocs.\n * \n * @param\tp_image\t\t\tthe image being encoded.\n * @param\tp_cp\t\t\tthe coding parameters.\n * @param\ttileno\t\t\tthe tile index of the tile being encoded.\n * @param\tp_tx0\t\t\tpointer that will hold the X0 parameter for the tile\n * @param\tp_tx1\t\t\tpointer that will hold the X1 parameter for the tile\n * @param\tp_ty0\t\t\tpointer that will hold the Y0 parameter for the tile\n * @param\tp_ty1\t\t\tpointer that will hold the Y1 parameter for the tile\n * @param\tp_max_prec\t\tpointer that will hold the the maximum precision for all the bands of the tile\n * @param\tp_max_res\t\tpointer that will hold the the maximum number of resolutions for all the poc inside the tile.\n * @param\tp_dx_min\t\t\tpointer that will hold the the minimum dx of all the components of all the resolutions for the tile.\n * @param\tp_dy_min\t\t\tpointer that will hold the the minimum dy of all the components of all the resolutions for the tile.\n */\nstatic void opj_get_encoding_parameters(const opj_image_t *p_image,\n                                        const opj_cp_t *p_cp,\n                                        OPJ_UINT32  tileno,\n                                        OPJ_INT32  * p_tx0,\n                                        OPJ_INT32 * p_tx1,\n                                        OPJ_INT32 * p_ty0,\n                                        OPJ_INT32 * p_ty1,\n                                        OPJ_UINT32 * p_dx_min,\n                                        OPJ_UINT32 * p_dy_min,\n                                        OPJ_UINT32 * p_max_prec,\n                                        OPJ_UINT32 * p_max_res );\n\n/**\n * Gets the encoding parameters needed to update the coding parameters and all the pocs.\n * The precinct widths, heights, dx and dy for each component at each resolution will be stored as well.\n * the last parameter of the function should be an array of pointers of size nb components, each pointer leading\n * to an area of size 4 * max_res. The data is stored inside this area with the following pattern :\n * dx_compi_res0 , dy_compi_res0 , w_compi_res0, h_compi_res0 , dx_compi_res1 , dy_compi_res1 , w_compi_res1, h_compi_res1 , ...\n *\n * @param\tp_image\t\t\tthe image being encoded.\n * @param\tp_cp\t\t\tthe coding parameters.\n * @param\ttileno\t\t\tthe tile index of the tile being encoded.\n * @param\tp_tx0\t\t\tpointer that will hold the X0 parameter for the tile\n * @param\tp_tx1\t\t\tpointer that will hold the X1 parameter for the tile\n * @param\tp_ty0\t\t\tpointer that will hold the Y0 parameter for the tile\n * @param\tp_ty1\t\t\tpointer that will hold the Y1 parameter for the tile\n * @param\tp_max_prec\t\tpointer that will hold the the maximum precision for all the bands of the tile\n * @param\tp_max_res\t\tpointer that will hold the the maximum number of resolutions for all the poc inside the tile.\n * @param\tp_dx_min\t\tpointer that will hold the the minimum dx of all the components of all the resolutions for the tile.\n * @param\tp_dy_min\t\tpointer that will hold the the minimum dy of all the components of all the resolutions for the tile.\n * @param\tp_resolutions\tpointer to an area corresponding to the one described above.\n */\nstatic void opj_get_all_encoding_parameters(const opj_image_t *p_image,\n                                            const opj_cp_t *p_cp,\n                                            OPJ_UINT32 tileno,\n                                            OPJ_INT32 * p_tx0,\n                                            OPJ_INT32 * p_tx1,\n                                            OPJ_INT32 * p_ty0,\n                                            OPJ_INT32 * p_ty1,\n                                            OPJ_UINT32 * p_dx_min,\n                                            OPJ_UINT32 * p_dy_min,\n                                            OPJ_UINT32 * p_max_prec,\n                                            OPJ_UINT32 * p_max_res,\n                                            OPJ_UINT32 ** p_resolutions );\n/**\n * Allocates memory for a packet iterator. Data and data sizes are set by this operation.\n * No other data is set. The include section of the packet  iterator is not allocated.\n * \n * @param\tp_image\t\tthe image used to initialize the packet iterator (in fact only the number of components is relevant.\n * @param\tp_cp\t\tthe coding parameters.\n * @param\ttileno\tthe index of the tile from which creating the packet iterator.\n */\nstatic opj_pi_iterator_t * opj_pi_create(\tconst opj_image_t *p_image,\n                                            const opj_cp_t *p_cp,\n                                            OPJ_UINT32 tileno );\n/**\n * FIXME DOC\n */\nstatic void opj_pi_update_decode_not_poc (opj_pi_iterator_t * p_pi,\n                                          opj_tcp_t * p_tcp,\n                                          OPJ_UINT32 p_max_precision,\n                                          OPJ_UINT32 p_max_res);\n/**\n * FIXME DOC\n */\nstatic void opj_pi_update_decode_poc (  opj_pi_iterator_t * p_pi,\n                                        opj_tcp_t * p_tcp,\n                                        OPJ_UINT32 p_max_precision,\n                                        OPJ_UINT32 p_max_res);\n\n/**\n * FIXME DOC\n */\nOPJ_BOOL opj_pi_check_next_level(\tOPJ_INT32 pos,\n\t\t\t\t\t\t\t\topj_cp_t *cp,\n\t\t\t\t\t\t\t\tOPJ_UINT32 tileno,\n\t\t\t\t\t\t\t\tOPJ_UINT32 pino,\n\t\t\t\t\t\t\t\tconst OPJ_CHAR *prog);\n\n/*@}*/\n\n/*@}*/\n\n/*\n==========================================================\n   local functions\n==========================================================\n*/\n\nOPJ_BOOL opj_pi_next_lrcp(opj_pi_iterator_t * pi) {\n\topj_pi_comp_t *comp = NULL;\n\topj_pi_resolution_t *res = NULL;\n\tOPJ_UINT32 index = 0;\n\t\n\tif (!pi->first) {\n\t\tcomp = &pi->comps[pi->compno];\n\t\tres = &comp->resolutions[pi->resno];\n\t\tgoto LABEL_SKIP;\n\t} else {\n\t\tpi->first = 0;\n\t}\n\n\tfor (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n\t\tfor (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1;\n\t\tpi->resno++) {\n\t\t\tfor (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n\t\t\t\tcomp = &pi->comps[pi->compno];\n\t\t\t\tif (pi->resno >= comp->numresolutions) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tres = &comp->resolutions[pi->resno];\n\t\t\t\tif (!pi->tp_on){\n\t\t\t\t\tpi->poc.precno1 = res->pw * res->ph;\n\t\t\t\t}\n\t\t\t\tfor (pi->precno = pi->poc.precno0; pi->precno < pi->poc.precno1; pi->precno++) {\n\t\t\t\t\tindex = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno * pi->step_c + pi->precno * pi->step_p;\n\t\t\t\t\tif (!pi->include[index]) {\n\t\t\t\t\t\tpi->include[index] = 1;\n\t\t\t\t\t\treturn OPJ_TRUE;\n\t\t\t\t\t}\nLABEL_SKIP:;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn OPJ_FALSE;\n}\n\nOPJ_BOOL opj_pi_next_rlcp(opj_pi_iterator_t * pi) {\n\topj_pi_comp_t *comp = NULL;\n\topj_pi_resolution_t *res = NULL;\n\tOPJ_UINT32 index = 0;\n\n\tif (!pi->first) {\n\t\tcomp = &pi->comps[pi->compno];\n\t\tres = &comp->resolutions[pi->resno];\n\t\tgoto LABEL_SKIP;\n\t} else {\n\t\tpi->first = 0;\n\t}\n\n\tfor (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1; pi->resno++) {\n\t\tfor (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n\t\t\tfor (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n\t\t\t\tcomp = &pi->comps[pi->compno];\n\t\t\t\tif (pi->resno >= comp->numresolutions) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tres = &comp->resolutions[pi->resno];\n\t\t\t\tif(!pi->tp_on){\n\t\t\t\t\tpi->poc.precno1 = res->pw * res->ph;\n\t\t\t\t}\n\t\t\t\tfor (pi->precno = pi->poc.precno0; pi->precno < pi->poc.precno1; pi->precno++) {\n\t\t\t\t\tindex = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno * pi->step_c + pi->precno * pi->step_p;\n\t\t\t\t\tif (!pi->include[index]) {\n\t\t\t\t\t\tpi->include[index] = 1;\n\t\t\t\t\t\treturn OPJ_TRUE;\n\t\t\t\t\t}\nLABEL_SKIP:;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn OPJ_FALSE;\n}\n\nOPJ_BOOL opj_pi_next_rpcl(opj_pi_iterator_t * pi) {\n\topj_pi_comp_t *comp = NULL;\n\topj_pi_resolution_t *res = NULL;\n\tOPJ_UINT32 index = 0;\n\n\tif (!pi->first) {\n\t\tgoto LABEL_SKIP;\n\t} else {\n\t\tOPJ_UINT32 compno, resno;\n\t\tpi->first = 0;\n\t\tpi->dx = 0;\n\t\tpi->dy = 0;\n\t\tfor (compno = 0; compno < pi->numcomps; compno++) {\n\t\t\tcomp = &pi->comps[compno];\n\t\t\tfor (resno = 0; resno < comp->numresolutions; resno++) {\n\t\t\t\tOPJ_UINT32 dx, dy;\n\t\t\t\tres = &comp->resolutions[resno];\n\t\t\t\tdx = comp->dx * (1u << (res->pdx + comp->numresolutions - 1 - resno));\n\t\t\t\tdy = comp->dy * (1u << (res->pdy + comp->numresolutions - 1 - resno));\n\t\t\t\tpi->dx = !pi->dx ? dx : opj_uint_min(pi->dx, dx);\n\t\t\t\tpi->dy = !pi->dy ? dy : opj_uint_min(pi->dy, dy);\n\t\t\t}\n\t\t}\n\t}\nif (!pi->tp_on){\n\t\t\tpi->poc.ty0 = pi->ty0;\n\t\t\tpi->poc.tx0 = pi->tx0;\n\t\t\tpi->poc.ty1 = pi->ty1;\n\t\t\tpi->poc.tx1 = pi->tx1;\n\t\t}\n\tfor (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1; pi->resno++) {\n\t\tfor (pi->y = pi->poc.ty0; pi->y < pi->poc.ty1; pi->y += (OPJ_INT32)(pi->dy - (OPJ_UINT32)(pi->y % (OPJ_INT32)pi->dy))) {\n\t\t\tfor (pi->x = pi->poc.tx0; pi->x < pi->poc.tx1; pi->x += (OPJ_INT32)(pi->dx - (OPJ_UINT32)(pi->x % (OPJ_INT32)pi->dx))) {\n\t\t\t\tfor (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n\t\t\t\t\tOPJ_UINT32 levelno;\n\t\t\t\t\tOPJ_INT32 trx0, try0;\n\t\t\t\t\tOPJ_INT32  trx1, try1;\n\t\t\t\t\tOPJ_UINT32  rpx, rpy;\n\t\t\t\t\tOPJ_INT32  prci, prcj;\n\t\t\t\t\tcomp = &pi->comps[pi->compno];\n\t\t\t\t\tif (pi->resno >= comp->numresolutions) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tres = &comp->resolutions[pi->resno];\n\t\t\t\t\tlevelno = comp->numresolutions - 1 - pi->resno;\n\t\t\t\t\ttrx0 = opj_int_ceildiv(pi->tx0, (OPJ_INT32)(comp->dx << levelno));\n\t\t\t\t\ttry0 = opj_int_ceildiv(pi->ty0, (OPJ_INT32)(comp->dy << levelno));\n\t\t\t\t\ttrx1 = opj_int_ceildiv(pi->tx1, (OPJ_INT32)(comp->dx << levelno));\n\t\t\t\t\ttry1 = opj_int_ceildiv(pi->ty1, (OPJ_INT32)(comp->dy << levelno));\n\t\t\t\t\trpx = res->pdx + levelno;\n\t\t\t\t\trpy = res->pdy + levelno;\n\t\t\t\t\tif (!((pi->y % (OPJ_INT32)(comp->dy << rpy) == 0) || ((pi->y == pi->ty0) && ((try0 << levelno) % (1 << rpy))))){\n\t\t\t\t\t\tcontinue;\t\n\t\t\t\t\t}\n\t\t\t\t\tif (!((pi->x % (OPJ_INT32)(comp->dx << rpx) == 0) || ((pi->x == pi->tx0) && ((trx0 << levelno) % (1 << rpx))))){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif ((res->pw==0)||(res->ph==0)) continue;\n\t\t\t\t\t\n\t\t\t\t\tif ((trx0==trx1)||(try0==try1)) continue;\n\t\t\t\t\t\n\t\t\t\t\tprci = opj_int_floordivpow2(opj_int_ceildiv(pi->x, (OPJ_INT32)(comp->dx << levelno)), (OPJ_INT32)res->pdx)\n\t\t\t\t\t\t - opj_int_floordivpow2(trx0, (OPJ_INT32)res->pdx);\n\t\t\t\t\tprcj = opj_int_floordivpow2(opj_int_ceildiv(pi->y, (OPJ_INT32)(comp->dy << levelno)), (OPJ_INT32)res->pdy)\n\t\t\t\t\t\t - opj_int_floordivpow2(try0, (OPJ_INT32)res->pdy);\n\t\t\t\t\tpi->precno = (OPJ_UINT32)(prci + prcj * (OPJ_INT32)res->pw);\n\t\t\t\t\tfor (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n\t\t\t\t\t\tindex = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno * pi->step_c + pi->precno * pi->step_p;\n\t\t\t\t\t\tif (!pi->include[index]) {\n\t\t\t\t\t\t\tpi->include[index] = 1;\n\t\t\t\t\t\t\treturn OPJ_TRUE;\n\t\t\t\t\t\t}\nLABEL_SKIP:;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn OPJ_FALSE;\n}\n\nOPJ_BOOL opj_pi_next_pcrl(opj_pi_iterator_t * pi) {\n\topj_pi_comp_t *comp = NULL;\n\topj_pi_resolution_t *res = NULL;\n\tOPJ_UINT32 index = 0;\n\n\tif (!pi->first) {\n\t\tcomp = &pi->comps[pi->compno];\n\t\tgoto LABEL_SKIP;\n\t} else {\n\t\tOPJ_UINT32 compno, resno;\n\t\tpi->first = 0;\n\t\tpi->dx = 0;\n\t\tpi->dy = 0;\n\t\tfor (compno = 0; compno < pi->numcomps; compno++) {\n\t\t\tcomp = &pi->comps[compno];\n\t\t\tfor (resno = 0; resno < comp->numresolutions; resno++) {\n\t\t\t\tOPJ_UINT32 dx, dy;\n\t\t\t\tres = &comp->resolutions[resno];\n\t\t\t\tdx = comp->dx * (1u << (res->pdx + comp->numresolutions - 1 - resno));\n\t\t\t\tdy = comp->dy * (1u << (res->pdy + comp->numresolutions - 1 - resno));\n\t\t\t\tpi->dx = !pi->dx ? dx : opj_uint_min(pi->dx, dx);\n\t\t\t\tpi->dy = !pi->dy ? dy : opj_uint_min(pi->dy, dy);\n\t\t\t}\n\t\t}\n\t}\n\tif (!pi->tp_on){\n\t\t\tpi->poc.ty0 = pi->ty0;\n\t\t\tpi->poc.tx0 = pi->tx0;\n\t\t\tpi->poc.ty1 = pi->ty1;\n\t\t\tpi->poc.tx1 = pi->tx1;\n\t\t}\n\tfor (pi->y = pi->poc.ty0; pi->y < pi->poc.ty1; pi->y += (OPJ_INT32)(pi->dy - (OPJ_UINT32)(pi->y % (OPJ_INT32)pi->dy))) {\n\t\tfor (pi->x = pi->poc.tx0; pi->x < pi->poc.tx1; pi->x += (OPJ_INT32)(pi->dx - (OPJ_UINT32)(pi->x % (OPJ_INT32)pi->dx))) {\n\t\t\tfor (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n\t\t\t\tcomp = &pi->comps[pi->compno];\n\t\t\t\tfor (pi->resno = pi->poc.resno0; pi->resno < opj_uint_min(pi->poc.resno1, comp->numresolutions); pi->resno++) {\n\t\t\t\t\tOPJ_UINT32 levelno;\n\t\t\t\t\tOPJ_INT32 trx0, try0;\n\t\t\t\t\tOPJ_INT32 trx1, try1;\n\t\t\t\t\tOPJ_UINT32 rpx, rpy;\n\t\t\t\t\tOPJ_INT32 prci, prcj;\n\t\t\t\t\tres = &comp->resolutions[pi->resno];\n\t\t\t\t\tlevelno = comp->numresolutions - 1 - pi->resno;\n\t\t\t\t\ttrx0 = opj_int_ceildiv(pi->tx0, (OPJ_INT32)(comp->dx << levelno));\n\t\t\t\t\ttry0 = opj_int_ceildiv(pi->ty0, (OPJ_INT32)(comp->dy << levelno));\n\t\t\t\t\ttrx1 = opj_int_ceildiv(pi->tx1, (OPJ_INT32)(comp->dx << levelno));\n\t\t\t\t\ttry1 = opj_int_ceildiv(pi->ty1, (OPJ_INT32)(comp->dy << levelno));\n\t\t\t\t\trpx = res->pdx + levelno;\n\t\t\t\t\trpy = res->pdy + levelno;\n\t\t\t\t\tif (!((pi->y % (OPJ_INT32)(comp->dy << rpy) == 0) || ((pi->y == pi->ty0) && ((try0 << levelno) % (1 << rpy))))){\n\t\t\t\t\t\tcontinue;\t\n\t\t\t\t\t}\n\t\t\t\t\tif (!((pi->x % (OPJ_INT32)(comp->dx << rpx) == 0) || ((pi->x == pi->tx0) && ((trx0 << levelno) % (1 << rpx))))){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif ((res->pw==0)||(res->ph==0)) continue;\n\t\t\t\t\t\n\t\t\t\t\tif ((trx0==trx1)||(try0==try1)) continue;\n\t\t\t\t\t\n\t\t\t\t\tprci = opj_int_floordivpow2(opj_int_ceildiv(pi->x, (OPJ_INT32)(comp->dx << levelno)), (OPJ_INT32)res->pdx)\n\t\t\t\t\t\t - opj_int_floordivpow2(trx0, (OPJ_INT32)res->pdx);\n\t\t\t\t\tprcj = opj_int_floordivpow2(opj_int_ceildiv(pi->y, (OPJ_INT32)(comp->dy << levelno)), (OPJ_INT32)res->pdy)\n\t\t\t\t\t\t - opj_int_floordivpow2(try0, (OPJ_INT32)res->pdy);\n\t\t\t\t\tpi->precno = (OPJ_UINT32)(prci + prcj * (OPJ_INT32)res->pw);\n\t\t\t\t\tfor (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n\t\t\t\t\t\tindex = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno * pi->step_c + pi->precno * pi->step_p;\n\t\t\t\t\t\tif (!pi->include[index]) {\n\t\t\t\t\t\t\tpi->include[index] = 1;\n\t\t\t\t\t\t\treturn OPJ_TRUE;\n\t\t\t\t\t\t}\t\nLABEL_SKIP:;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn OPJ_FALSE;\n}\n\nOPJ_BOOL opj_pi_next_cprl(opj_pi_iterator_t * pi) {\n\topj_pi_comp_t *comp = NULL;\n\topj_pi_resolution_t *res = NULL;\n\tOPJ_UINT32 index = 0;\n\n\tif (!pi->first) {\n\t\tcomp = &pi->comps[pi->compno];\n\t\tgoto LABEL_SKIP;\n\t} else {\n\t\tpi->first = 0;\n\t}\n\n\tfor (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n\t\tOPJ_UINT32 resno;\n\t\tcomp = &pi->comps[pi->compno];\n\t\tpi->dx = 0;\n\t\tpi->dy = 0;\n\t\tfor (resno = 0; resno < comp->numresolutions; resno++) {\n\t\t\tOPJ_UINT32 dx, dy;\n\t\t\tres = &comp->resolutions[resno];\n\t\t\tdx = comp->dx * (1u << (res->pdx + comp->numresolutions - 1 - resno));\n\t\t\tdy = comp->dy * (1u << (res->pdy + comp->numresolutions - 1 - resno));\n\t\t\tpi->dx = !pi->dx ? dx : opj_uint_min(pi->dx, dx);\n\t\t\tpi->dy = !pi->dy ? dy : opj_uint_min(pi->dy, dy);\n\t\t}\n\t\tif (!pi->tp_on){\n\t\t\tpi->poc.ty0 = pi->ty0;\n\t\t\tpi->poc.tx0 = pi->tx0;\n\t\t\tpi->poc.ty1 = pi->ty1;\n\t\t\tpi->poc.tx1 = pi->tx1;\n\t\t}\n\t\tfor (pi->y = pi->poc.ty0; pi->y < pi->poc.ty1; pi->y += (OPJ_INT32)(pi->dy - (OPJ_UINT32)(pi->y % (OPJ_INT32)pi->dy))) {\n\t\t\tfor (pi->x = pi->poc.tx0; pi->x < pi->poc.tx1; pi->x += (OPJ_INT32)(pi->dx - (OPJ_UINT32)(pi->x % (OPJ_INT32)pi->dx))) {\n\t\t\t\tfor (pi->resno = pi->poc.resno0; pi->resno < opj_uint_min(pi->poc.resno1, comp->numresolutions); pi->resno++) {\n\t\t\t\t\tOPJ_UINT32 levelno;\n\t\t\t\t\tOPJ_INT32 trx0, try0;\n\t\t\t\t\tOPJ_INT32 trx1, try1;\n\t\t\t\t\tOPJ_UINT32 rpx, rpy;\n\t\t\t\t\tOPJ_INT32 prci, prcj;\n\t\t\t\t\tres = &comp->resolutions[pi->resno];\n\t\t\t\t\tlevelno = comp->numresolutions - 1 - pi->resno;\n\t\t\t\t\ttrx0 = opj_int_ceildiv(pi->tx0, (OPJ_INT32)(comp->dx << levelno));\n\t\t\t\t\ttry0 = opj_int_ceildiv(pi->ty0, (OPJ_INT32)(comp->dy << levelno));\n\t\t\t\t\ttrx1 = opj_int_ceildiv(pi->tx1, (OPJ_INT32)(comp->dx << levelno));\n\t\t\t\t\ttry1 = opj_int_ceildiv(pi->ty1, (OPJ_INT32)(comp->dy << levelno));\n\t\t\t\t\trpx = res->pdx + levelno;\n\t\t\t\t\trpy = res->pdy + levelno;\n\t\t\t\t\tif (!((pi->y % (OPJ_INT32)(comp->dy << rpy) == 0) || ((pi->y == pi->ty0) && ((try0 << levelno) % (1 << rpy))))){\n\t\t\t\t\t\tcontinue;\t\n\t\t\t\t\t}\n\t\t\t\t\tif (!((pi->x % (OPJ_INT32)(comp->dx << rpx) == 0) || ((pi->x == pi->tx0) && ((trx0 << levelno) % (1 << rpx))))){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif ((res->pw==0)||(res->ph==0)) continue;\n\t\t\t\t\t\n\t\t\t\t\tif ((trx0==trx1)||(try0==try1)) continue;\n\t\t\t\t\t\n\t\t\t\t\tprci = opj_int_floordivpow2(opj_int_ceildiv(pi->x, (OPJ_INT32)(comp->dx << levelno)), (OPJ_INT32)res->pdx)\n\t\t\t\t\t\t - opj_int_floordivpow2(trx0, (OPJ_INT32)res->pdx);\n\t\t\t\t\tprcj = opj_int_floordivpow2(opj_int_ceildiv(pi->y, (OPJ_INT32)(comp->dy << levelno)), (OPJ_INT32)res->pdy)\n\t\t\t\t\t\t - opj_int_floordivpow2(try0, (OPJ_INT32)res->pdy);\n\t\t\t\t\tpi->precno = (OPJ_UINT32)(prci + prcj * (OPJ_INT32)res->pw);\n\t\t\t\t\tfor (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n\t\t\t\t\t\tindex = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno * pi->step_c + pi->precno * pi->step_p;\n\t\t\t\t\t\tif (!pi->include[index]) {\n\t\t\t\t\t\t\tpi->include[index] = 1;\n\t\t\t\t\t\t\treturn OPJ_TRUE;\n\t\t\t\t\t\t}\nLABEL_SKIP:;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn OPJ_FALSE;\n}\n\nvoid opj_get_encoding_parameters(\tconst opj_image_t *p_image,\n                                    const opj_cp_t *p_cp,\n                                    OPJ_UINT32 p_tileno,\n                                    OPJ_INT32 * p_tx0,\n                                    OPJ_INT32  * p_tx1,\n                                    OPJ_INT32  * p_ty0,\n                                    OPJ_INT32  * p_ty1,\n                                    OPJ_UINT32 * p_dx_min,\n                                    OPJ_UINT32 * p_dy_min,\n                                    OPJ_UINT32 * p_max_prec,\n                                    OPJ_UINT32 * p_max_res )\n{\n\t/* loop */\n\tOPJ_UINT32  compno, resno;\n\t/* pointers */\n\tconst opj_tcp_t *l_tcp = 00;\n\tconst opj_tccp_t * l_tccp = 00;\n\tconst opj_image_comp_t * l_img_comp = 00;\n\n\t/* position in x and y of tile */\n\tOPJ_UINT32 p, q;\n\n\t/* preconditions */\n\tassert(p_cp != 00);\n\tassert(p_image != 00);\n\tassert(p_tileno < p_cp->tw * p_cp->th);\n\n\t/* initializations */\n\tl_tcp = &p_cp->tcps [p_tileno];\n\tl_img_comp = p_image->comps;\n\tl_tccp = l_tcp->tccps;\n\n\t/* here calculation of tx0, tx1, ty0, ty1, maxprec, dx and dy */\n\tp = p_tileno % p_cp->tw;\n\tq = p_tileno / p_cp->tw;\n\n\t/* find extent of tile */\n\t*p_tx0 = opj_int_max((OPJ_INT32)(p_cp->tx0 + p * p_cp->tdx), (OPJ_INT32)p_image->x0);\n\t*p_tx1 = opj_int_min((OPJ_INT32)(p_cp->tx0 + (p + 1) * p_cp->tdx), (OPJ_INT32)p_image->x1);\n\t*p_ty0 = opj_int_max((OPJ_INT32)(p_cp->ty0 + q * p_cp->tdy), (OPJ_INT32)p_image->y0);\n\t*p_ty1 = opj_int_min((OPJ_INT32)(p_cp->ty0 + (q + 1) * p_cp->tdy), (OPJ_INT32)p_image->y1);\n\n\t/* max precision is 0 (can only grow) */\n\t*p_max_prec = 0;\n\t*p_max_res = 0;\n\n\t/* take the largest value for dx_min and dy_min */\n\t*p_dx_min = 0x7fffffff;\n\t*p_dy_min  = 0x7fffffff;\n\n\tfor (compno = 0; compno < p_image->numcomps; ++compno) {\n\t\t/* arithmetic variables to calculate */\n\t\tOPJ_UINT32 l_level_no;\n\t\tOPJ_INT32 l_rx0, l_ry0, l_rx1, l_ry1;\n\t\tOPJ_INT32 l_px0, l_py0, l_px1, py1;\n\t\tOPJ_UINT32 l_pdx, l_pdy;\n\t\tOPJ_UINT32 l_pw, l_ph;\n\t\tOPJ_UINT32 l_product;\n\t\tOPJ_INT32 l_tcx0, l_tcy0, l_tcx1, l_tcy1;\n\n\t\tl_tcx0 = opj_int_ceildiv(*p_tx0, (OPJ_INT32)l_img_comp->dx);\n\t\tl_tcy0 = opj_int_ceildiv(*p_ty0, (OPJ_INT32)l_img_comp->dy);\n\t\tl_tcx1 = opj_int_ceildiv(*p_tx1, (OPJ_INT32)l_img_comp->dx);\n\t\tl_tcy1 = opj_int_ceildiv(*p_ty1, (OPJ_INT32)l_img_comp->dy);\n\n\t\tif (l_tccp->numresolutions > *p_max_res) {\n\t\t\t*p_max_res = l_tccp->numresolutions;\n\t\t}\n\n\t\t/* use custom size for precincts */\n\t\tfor (resno = 0; resno < l_tccp->numresolutions; ++resno) {\n\t\t\tOPJ_UINT32 l_dx, l_dy;\n\n\t\t\t/* precinct width and height */\n\t\t\tl_pdx = l_tccp->prcw[resno];\n\t\t\tl_pdy = l_tccp->prch[resno];\n\n\t\t\tl_dx = l_img_comp->dx * (1u << (l_pdx + l_tccp->numresolutions - 1 - resno));\n\t\t\tl_dy = l_img_comp->dy * (1u << (l_pdy + l_tccp->numresolutions - 1 - resno));\n\n\t\t\t/* take the minimum size for dx for each comp and resolution */\n\t\t\t*p_dx_min = opj_uint_min(*p_dx_min, l_dx);\n\t\t\t*p_dy_min = opj_uint_min(*p_dy_min, l_dy);\n\n\t\t\t/* various calculations of extents */\n\t\t\tl_level_no = l_tccp->numresolutions - 1 - resno;\n\n\t\t\tl_rx0 = opj_int_ceildivpow2(l_tcx0, (OPJ_INT32)l_level_no);\n\t\t\tl_ry0 = opj_int_ceildivpow2(l_tcy0, (OPJ_INT32)l_level_no);\n\t\t\tl_rx1 = opj_int_ceildivpow2(l_tcx1, (OPJ_INT32)l_level_no);\n\t\t\tl_ry1 = opj_int_ceildivpow2(l_tcy1, (OPJ_INT32)l_level_no);\n\n\t\t\tl_px0 = opj_int_floordivpow2(l_rx0, (OPJ_INT32)l_pdx) << l_pdx;\n\t\t\tl_py0 = opj_int_floordivpow2(l_ry0, (OPJ_INT32)l_pdy) << l_pdy;\n\t\t\tl_px1 = opj_int_ceildivpow2(l_rx1, (OPJ_INT32)l_pdx) << l_pdx;\n\n\t\t\tpy1 = opj_int_ceildivpow2(l_ry1, (OPJ_INT32)l_pdy) << l_pdy;\n\n\t\t\tl_pw = (l_rx0==l_rx1)?0:(OPJ_UINT32)((l_px1 - l_px0) >> l_pdx);\n\t\t\tl_ph = (l_ry0==l_ry1)?0:(OPJ_UINT32)((py1 - l_py0) >> l_pdy);\n\n\t\t\tl_product = l_pw * l_ph;\n\n\t\t\t/* update precision */\n\t\t\tif (l_product > *p_max_prec) {\n\t\t\t\t*p_max_prec = l_product;\n\t\t\t}\n\t\t}\n\t\t++l_img_comp;\n\t\t++l_tccp;\n\t}\n}\n\n\nvoid opj_get_all_encoding_parameters(   const opj_image_t *p_image,\n                                        const opj_cp_t *p_cp,\n                                        OPJ_UINT32 tileno,\n                                        OPJ_INT32 * p_tx0,\n                                        OPJ_INT32 * p_tx1,\n                                        OPJ_INT32 * p_ty0,\n                                        OPJ_INT32 * p_ty1,\n                                        OPJ_UINT32 * p_dx_min,\n                                        OPJ_UINT32 * p_dy_min,\n                                        OPJ_UINT32 * p_max_prec,\n                                        OPJ_UINT32 * p_max_res,\n                                        OPJ_UINT32 ** p_resolutions )\n{\n\t/* loop*/\n\tOPJ_UINT32 compno, resno;\n\n\t/* pointers*/\n\tconst opj_tcp_t *tcp = 00;\n\tconst opj_tccp_t * l_tccp = 00;\n\tconst opj_image_comp_t * l_img_comp = 00;\n\n\t/* to store l_dx, l_dy, w and h for each resolution and component.*/\n\tOPJ_UINT32 * lResolutionPtr;\n\n\t/* position in x and y of tile*/\n\tOPJ_UINT32 p, q;\n\n\t/* preconditions in debug*/\n\tassert(p_cp != 00);\n\tassert(p_image != 00);\n\tassert(tileno < p_cp->tw * p_cp->th);\n\n\t/* initializations*/\n\ttcp = &p_cp->tcps [tileno];\n\tl_tccp = tcp->tccps;\n\tl_img_comp = p_image->comps;\n\n\t/* position in x and y of tile*/\n\tp = tileno % p_cp->tw;\n\tq = tileno / p_cp->tw;\n\n\t/* here calculation of tx0, tx1, ty0, ty1, maxprec, l_dx and l_dy */\n\t*p_tx0 = (OPJ_INT32)opj_uint_max(p_cp->tx0 + p * p_cp->tdx, p_image->x0);\n\t*p_tx1 = (OPJ_INT32)opj_uint_min(p_cp->tx0 + (p + 1) * p_cp->tdx, p_image->x1);\n\t*p_ty0 = (OPJ_INT32)opj_uint_max(p_cp->ty0 + q * p_cp->tdy, p_image->y0);\n\t*p_ty1 = (OPJ_INT32)opj_uint_min(p_cp->ty0 + (q + 1) * p_cp->tdy, p_image->y1);\n\n\t/* max precision and resolution is 0 (can only grow)*/\n\t*p_max_prec = 0;\n\t*p_max_res = 0;\n\n\t/* take the largest value for dx_min and dy_min*/\n\t*p_dx_min = 0x7fffffff;\n\t*p_dy_min = 0x7fffffff;\n\n\tfor (compno = 0; compno < p_image->numcomps; ++compno) {\n\t\t/* aritmetic variables to calculate*/\n\t\tOPJ_UINT32 l_level_no;\n\t\tOPJ_INT32 l_rx0, l_ry0, l_rx1, l_ry1;\n\t\tOPJ_INT32 l_px0, l_py0, l_px1, py1;\n\t\tOPJ_UINT32 l_product;\n\t\tOPJ_INT32 l_tcx0, l_tcy0, l_tcx1, l_tcy1;\n\t\tOPJ_UINT32 l_pdx, l_pdy , l_pw , l_ph;\n\n\t\tlResolutionPtr = p_resolutions[compno];\n\n\t\tl_tcx0 = opj_int_ceildiv(*p_tx0, (OPJ_INT32)l_img_comp->dx);\n\t\tl_tcy0 = opj_int_ceildiv(*p_ty0, (OPJ_INT32)l_img_comp->dy);\n\t\tl_tcx1 = opj_int_ceildiv(*p_tx1, (OPJ_INT32)l_img_comp->dx);\n\t\tl_tcy1 = opj_int_ceildiv(*p_ty1, (OPJ_INT32)l_img_comp->dy);\n\n\t\tif (l_tccp->numresolutions > *p_max_res) {\n\t\t\t*p_max_res = l_tccp->numresolutions;\n\t\t}\n\n\t\t/* use custom size for precincts*/\n\t\tl_level_no = l_tccp->numresolutions - 1;\n\t\tfor (resno = 0; resno < l_tccp->numresolutions; ++resno) {\n\t\t\tOPJ_UINT32 l_dx, l_dy;\n\n\t\t\t/* precinct width and height*/\n\t\t\tl_pdx = l_tccp->prcw[resno];\n\t\t\tl_pdy = l_tccp->prch[resno];\n\t\t\t*lResolutionPtr++ = l_pdx;\n\t\t\t*lResolutionPtr++ = l_pdy;\n\t\t\tl_dx = l_img_comp->dx * (1u << (l_pdx + l_level_no));\n\t\t\tl_dy = l_img_comp->dy * (1u << (l_pdy + l_level_no));\n\t\t\t/* take the minimum size for l_dx for each comp and resolution*/\n\t\t\t*p_dx_min = (OPJ_UINT32)opj_int_min((OPJ_INT32)*p_dx_min, (OPJ_INT32)l_dx);\n\t\t\t*p_dy_min = (OPJ_UINT32)opj_int_min((OPJ_INT32)*p_dy_min, (OPJ_INT32)l_dy);\n\n\t\t\t/* various calculations of extents*/\n\t\t\tl_rx0 = opj_int_ceildivpow2(l_tcx0, (OPJ_INT32)l_level_no);\n\t\t\tl_ry0 = opj_int_ceildivpow2(l_tcy0, (OPJ_INT32)l_level_no);\n\t\t\tl_rx1 = opj_int_ceildivpow2(l_tcx1, (OPJ_INT32)l_level_no);\n\t\t\tl_ry1 = opj_int_ceildivpow2(l_tcy1, (OPJ_INT32)l_level_no);\n\t\t\tl_px0 = opj_int_floordivpow2(l_rx0, (OPJ_INT32)l_pdx) << l_pdx;\n\t\t\tl_py0 = opj_int_floordivpow2(l_ry0, (OPJ_INT32)l_pdy) << l_pdy;\n\t\t\tl_px1 = opj_int_ceildivpow2(l_rx1, (OPJ_INT32)l_pdx) << l_pdx;\n\t\t\tpy1 = opj_int_ceildivpow2(l_ry1, (OPJ_INT32)l_pdy) << l_pdy;\n\t\t\tl_pw = (l_rx0==l_rx1)?0:(OPJ_UINT32)((l_px1 - l_px0) >> l_pdx);\n\t\t\tl_ph = (l_ry0==l_ry1)?0:(OPJ_UINT32)((py1 - l_py0) >> l_pdy);\n\t\t\t*lResolutionPtr++ = l_pw;\n\t\t\t*lResolutionPtr++ = l_ph;\n\t\t\tl_product = l_pw * l_ph;\n\t\t\t\n            /* update precision*/\n\t\t\tif (l_product > *p_max_prec) {\n\t\t\t\t*p_max_prec = l_product;\n\t\t\t}\n\n\t\t\t--l_level_no;\n\t\t}\n\t\t++l_tccp;\n\t\t++l_img_comp;\n\t}\n}\n\nopj_pi_iterator_t * opj_pi_create(\tconst opj_image_t *image,\n                                    const opj_cp_t *cp,\n                                    OPJ_UINT32 tileno )\n{\n\t/* loop*/\n\tOPJ_UINT32 pino, compno;\n\t/* number of poc in the p_pi*/\n\tOPJ_UINT32 l_poc_bound;\n\n\t/* pointers to tile coding parameters and components.*/\n\topj_pi_iterator_t *l_pi = 00;\n\topj_tcp_t *tcp = 00;\n\tconst opj_tccp_t *tccp = 00;\n\n\t/* current packet iterator being allocated*/\n\topj_pi_iterator_t *l_current_pi = 00;\n\n\t/* preconditions in debug*/\n\tassert(cp != 00);\n\tassert(image != 00);\n\tassert(tileno < cp->tw * cp->th);\n\n\t/* initializations*/\n\ttcp = &cp->tcps[tileno];\n\tl_poc_bound = tcp->numpocs+1;\n\n\t/* memory allocations*/\n\tl_pi = (opj_pi_iterator_t*) opj_calloc((l_poc_bound), sizeof(opj_pi_iterator_t));\n\tif (!l_pi) {\n\t\treturn NULL;\n\t}\n\n\tl_current_pi = l_pi;\n\tfor (pino = 0; pino < l_poc_bound ; ++pino) {\n\n\t\tl_current_pi->comps = (opj_pi_comp_t*) opj_calloc(image->numcomps, sizeof(opj_pi_comp_t));\n\t\tif (! l_current_pi->comps) {\n\t\t\topj_pi_destroy(l_pi, l_poc_bound);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tl_current_pi->numcomps = image->numcomps;\n\n\t\tfor (compno = 0; compno < image->numcomps; ++compno) {\n\t\t\topj_pi_comp_t *comp = &l_current_pi->comps[compno];\n\n\t\t\ttccp = &tcp->tccps[compno];\n\n\t\t\tcomp->resolutions = (opj_pi_resolution_t*) opj_calloc(tccp->numresolutions, sizeof(opj_pi_resolution_t));\n\t\t\tif (!comp->resolutions) {\n\t\t\t\topj_pi_destroy(l_pi, l_poc_bound);\n\t\t\t\treturn 00;\n\t\t\t}\n\n\t\t\tcomp->numresolutions = tccp->numresolutions;\n\t\t}\n\t\t++l_current_pi;\n\t}\n\treturn l_pi;\n}\n\nvoid opj_pi_update_encode_poc_and_final (   opj_cp_t *p_cp,\n                                            OPJ_UINT32 p_tileno,\n                                            OPJ_INT32 p_tx0,\n                                            OPJ_INT32 p_tx1,\n                                            OPJ_INT32 p_ty0,\n                                            OPJ_INT32 p_ty1,\n                                            OPJ_UINT32 p_max_prec,\n                                            OPJ_UINT32 p_max_res,\n                                            OPJ_UINT32 p_dx_min,\n                                            OPJ_UINT32 p_dy_min)\n{\n\t/* loop*/\n\tOPJ_UINT32 pino;\n\t/* tile coding parameter*/\n\topj_tcp_t *l_tcp = 00;\n\t/* current poc being updated*/\n\topj_poc_t * l_current_poc = 00;\n\n\t/* number of pocs*/\n\tOPJ_UINT32 l_poc_bound;\n\n    OPJ_ARG_NOT_USED(p_max_res);\n\n\t/* preconditions in debug*/\n\tassert(p_cp != 00);\n\tassert(p_tileno < p_cp->tw * p_cp->th);\n\n\t/* initializations*/\n\tl_tcp = &p_cp->tcps [p_tileno];\n\t/* number of iterations in the loop */\n\tl_poc_bound = l_tcp->numpocs+1;\n\n\t/* start at first element, and to make sure the compiler will not make a calculation each time in the loop\n\t   store a pointer to the current element to modify rather than l_tcp->pocs[i]*/\n\tl_current_poc = l_tcp->pocs;\n\n\tl_current_poc->compS = l_current_poc->compno0;\n\tl_current_poc->compE = l_current_poc->compno1;\n\tl_current_poc->resS = l_current_poc->resno0;\n\tl_current_poc->resE = l_current_poc->resno1;\n\tl_current_poc->layE = l_current_poc->layno1;\n\n\t/* special treatment for the first element*/\n\tl_current_poc->layS = 0;\n\tl_current_poc->prg  = l_current_poc->prg1;\n\tl_current_poc->prcS = 0;\n\n\tl_current_poc->prcE = p_max_prec;\n\tl_current_poc->txS = (OPJ_UINT32)p_tx0;\n\tl_current_poc->txE = (OPJ_UINT32)p_tx1;\n\tl_current_poc->tyS = (OPJ_UINT32)p_ty0;\n\tl_current_poc->tyE = (OPJ_UINT32)p_ty1;\n\tl_current_poc->dx = p_dx_min;\n\tl_current_poc->dy = p_dy_min;\n\n\t++ l_current_poc;\n\tfor (pino = 1;pino < l_poc_bound ; ++pino) {\n\t\tl_current_poc->compS = l_current_poc->compno0;\n\t\tl_current_poc->compE= l_current_poc->compno1;\n\t\tl_current_poc->resS = l_current_poc->resno0;\n\t\tl_current_poc->resE = l_current_poc->resno1;\n\t\tl_current_poc->layE = l_current_poc->layno1;\n\t\tl_current_poc->prg  = l_current_poc->prg1;\n\t\tl_current_poc->prcS = 0;\n\t\t/* special treatment here different from the first element*/\n\t\tl_current_poc->layS = (l_current_poc->layE > (l_current_poc-1)->layE) ? l_current_poc->layE : 0;\n\n\t\tl_current_poc->prcE = p_max_prec;\n\t\tl_current_poc->txS = (OPJ_UINT32)p_tx0;\n\t\tl_current_poc->txE = (OPJ_UINT32)p_tx1;\n\t\tl_current_poc->tyS = (OPJ_UINT32)p_ty0;\n\t\tl_current_poc->tyE = (OPJ_UINT32)p_ty1;\n\t\tl_current_poc->dx = p_dx_min;\n\t\tl_current_poc->dy = p_dy_min;\n\t\t++ l_current_poc;\n\t}\n}\n\nvoid opj_pi_update_encode_not_poc (\topj_cp_t *p_cp,\n                                    OPJ_UINT32 p_num_comps,\n                                    OPJ_UINT32 p_tileno,\n                                    OPJ_INT32 p_tx0,\n                                    OPJ_INT32 p_tx1,\n                                    OPJ_INT32 p_ty0,\n                                    OPJ_INT32 p_ty1,\n                                    OPJ_UINT32 p_max_prec,\n                                    OPJ_UINT32 p_max_res,\n                                    OPJ_UINT32 p_dx_min,\n                                    OPJ_UINT32 p_dy_min)\n{\n\t/* loop*/\n\tOPJ_UINT32 pino;\n\t/* tile coding parameter*/\n\topj_tcp_t *l_tcp = 00;\n\t/* current poc being updated*/\n\topj_poc_t * l_current_poc = 00;\n\t/* number of pocs*/\n\tOPJ_UINT32 l_poc_bound;\n\n\t/* preconditions in debug*/\n\tassert(p_cp != 00);\n\tassert(p_tileno < p_cp->tw * p_cp->th);\n\n\t/* initializations*/\n\tl_tcp = &p_cp->tcps [p_tileno];\n\n\t/* number of iterations in the loop */\n\tl_poc_bound = l_tcp->numpocs+1;\n\n\t/* start at first element, and to make sure the compiler will not make a calculation each time in the loop\n\t   store a pointer to the current element to modify rather than l_tcp->pocs[i]*/\n\tl_current_poc = l_tcp->pocs;\n\n\tfor (pino = 0; pino < l_poc_bound ; ++pino) {\n\t\tl_current_poc->compS = 0;\n\t\tl_current_poc->compE = p_num_comps;/*p_image->numcomps;*/\n\t\tl_current_poc->resS = 0;\n\t\tl_current_poc->resE = p_max_res;\n\t\tl_current_poc->layS = 0;\n\t\tl_current_poc->layE = l_tcp->numlayers;\n\t\tl_current_poc->prg  = l_tcp->prg;\n\t\tl_current_poc->prcS = 0;\n\t\tl_current_poc->prcE = p_max_prec;\n\t\tl_current_poc->txS = (OPJ_UINT32)p_tx0;\n\t\tl_current_poc->txE = (OPJ_UINT32)p_tx1;\n\t\tl_current_poc->tyS = (OPJ_UINT32)p_ty0;\n\t\tl_current_poc->tyE = (OPJ_UINT32)p_ty1;\n\t\tl_current_poc->dx = p_dx_min;\n\t\tl_current_poc->dy = p_dy_min;\n\t\t++ l_current_poc;\n\t}\n}\n\nvoid opj_pi_update_decode_poc (opj_pi_iterator_t * p_pi,\n                               opj_tcp_t * p_tcp,\n                               OPJ_UINT32 p_max_precision,\n                               OPJ_UINT32 p_max_res)\n{\n\t/* loop*/\n\tOPJ_UINT32 pino;\n\n\t/* encoding prameters to set*/\n\tOPJ_UINT32 l_bound;\n\n\topj_pi_iterator_t * l_current_pi = 00;\n\topj_poc_t* l_current_poc = 0;\n\n    OPJ_ARG_NOT_USED(p_max_res);\n\n\t/* preconditions in debug*/\n\tassert(p_pi != 00);\n\tassert(p_tcp != 00);\n\n\t/* initializations*/\n\tl_bound = p_tcp->numpocs+1;\n\tl_current_pi = p_pi;\n\tl_current_poc = p_tcp->pocs;\n\n\tfor\t(pino = 0;pino<l_bound;++pino) {\n\t\tl_current_pi->poc.prg = l_current_poc->prg; /* Progression Order #0 */\n\t\tl_current_pi->first = 1;\n\n\t\tl_current_pi->poc.resno0 = l_current_poc->resno0; /* Resolution Level Index #0 (Start) */\n\t\tl_current_pi->poc.compno0 = l_current_poc->compno0; /* Component Index #0 (Start) */\n\t\tl_current_pi->poc.layno0 = 0;\n\t\tl_current_pi->poc.precno0 = 0;\n\t\tl_current_pi->poc.resno1 = l_current_poc->resno1; /* Resolution Level Index #0 (End) */\n\t\tl_current_pi->poc.compno1 = l_current_poc->compno1; /* Component Index #0 (End) */\n\t\tl_current_pi->poc.layno1 = l_current_poc->layno1; /* Layer Index #0 (End) */\n\t\tl_current_pi->poc.precno1 = p_max_precision;\n\t\t++l_current_pi;\n\t\t++l_current_poc;\n\t}\n}\n\nvoid opj_pi_update_decode_not_poc (opj_pi_iterator_t * p_pi,\n                                   opj_tcp_t * p_tcp,\n                                   OPJ_UINT32 p_max_precision,\n                                   OPJ_UINT32 p_max_res)\n{\n\t/* loop*/\n\tOPJ_UINT32 pino;\n\n\t/* encoding prameters to set*/\n\tOPJ_UINT32 l_bound;\n\n\topj_pi_iterator_t * l_current_pi = 00;\n\t/* preconditions in debug*/\n\tassert(p_tcp != 00);\n\tassert(p_pi != 00);\n\n\t/* initializations*/\n\tl_bound = p_tcp->numpocs+1;\n\tl_current_pi = p_pi;\n\n\tfor (pino = 0;pino<l_bound;++pino) {\n\t\tl_current_pi->poc.prg = p_tcp->prg;\n\t\tl_current_pi->first = 1;\n\t\tl_current_pi->poc.resno0 = 0;\n\t\tl_current_pi->poc.compno0 = 0;\n\t\tl_current_pi->poc.layno0 = 0;\n\t\tl_current_pi->poc.precno0 = 0;\n\t\tl_current_pi->poc.resno1 = p_max_res;\n\t\tl_current_pi->poc.compno1 = l_current_pi->numcomps;\n\t\tl_current_pi->poc.layno1 = p_tcp->numlayers;\n\t\tl_current_pi->poc.precno1 = p_max_precision;\n\t\t++l_current_pi;\n\t}\n}\n\n\n\nOPJ_BOOL opj_pi_check_next_level(\tOPJ_INT32 pos,\n\t\t\t\t\t\t\t\topj_cp_t *cp,\n\t\t\t\t\t\t\t\tOPJ_UINT32 tileno,\n\t\t\t\t\t\t\t\tOPJ_UINT32 pino,\n\t\t\t\t\t\t\t\tconst OPJ_CHAR *prog)\n{\n\tOPJ_INT32 i;\n\topj_tcp_t *tcps =&cp->tcps[tileno];\n\topj_poc_t *tcp = &tcps->pocs[pino];\n\n\tif(pos>=0){\n\t\tfor(i=pos;pos>=0;i--){\n\t\t\tswitch(prog[i]){\n\t\t    case 'R':\n\t\t\t    if(tcp->res_t==tcp->resE){\n\t\t\t\t    if(opj_pi_check_next_level(pos-1,cp,tileno,pino,prog)){\n\t\t\t\t\t    return OPJ_TRUE;\n\t\t\t\t    }else{\n\t\t\t\t\t    return OPJ_FALSE;\n\t\t\t\t    }\n\t\t\t    }else{\n\t\t\t\t    return OPJ_TRUE;\n\t\t\t    }\n\t\t\t    break;\n\t\t    case 'C':\n\t\t\t    if(tcp->comp_t==tcp->compE){\n\t\t\t\t    if(opj_pi_check_next_level(pos-1,cp,tileno,pino,prog)){\n\t\t\t\t\t    return OPJ_TRUE;\n\t\t\t\t    }else{\n\t\t\t\t\t    return OPJ_FALSE;\n\t\t\t\t    }\n\t\t\t    }else{\n\t\t\t\t    return OPJ_TRUE;\n\t\t\t    }\n\t\t\t    break;\n\t\t    case 'L':\n\t\t\t    if(tcp->lay_t==tcp->layE){\n\t\t\t\t    if(opj_pi_check_next_level(pos-1,cp,tileno,pino,prog)){\n\t\t\t\t\t    return OPJ_TRUE;\n\t\t\t\t    }else{\n\t\t\t\t\t    return OPJ_FALSE;\n\t\t\t\t    }\n\t\t\t    }else{\n\t\t\t\t    return OPJ_TRUE;\n\t\t\t    }\n\t\t\t    break;\n\t\t    case 'P':\n\t\t\t    switch(tcp->prg){\n                    case OPJ_LRCP: /* fall through */\n                    case OPJ_RLCP:\n\t\t\t\t\t    if(tcp->prc_t == tcp->prcE){\n\t\t\t\t\t\t    if(opj_pi_check_next_level(i-1,cp,tileno,pino,prog)){\n\t\t\t\t\t\t\t    return OPJ_TRUE;\n\t\t\t\t\t\t    }else{\n\t\t\t\t\t\t\t    return OPJ_FALSE;\n\t\t\t\t\t\t    }\n\t\t\t\t\t    }else{\n\t\t\t\t\t\t    return OPJ_TRUE;\n\t\t\t\t\t    }\n\t\t\t\t\t    break;\n\t\t\t    default:\n\t\t\t\t    if(tcp->tx0_t == tcp->txE){\n\t\t\t\t\t    /*TY*/\n\t\t\t\t\t    if(tcp->ty0_t == tcp->tyE){\n\t\t\t\t\t\t    if(opj_pi_check_next_level(i-1,cp,tileno,pino,prog)){\n\t\t\t\t\t\t\t    return OPJ_TRUE;\n\t\t\t\t\t\t    }else{\n\t\t\t\t\t\t\t    return OPJ_FALSE;\n\t\t\t\t\t\t    }\n\t\t\t\t\t    }else{\n\t\t\t\t\t\t    return OPJ_TRUE;\n\t\t\t\t\t    }/*TY*/\n\t\t\t\t    }else{\n\t\t\t\t\t    return OPJ_TRUE;\n\t\t\t\t    }\n\t\t\t\t    break;\n\t\t\t    }/*end case P*/\n\t\t    }/*end switch*/\n\t\t}/*end for*/\n\t}/*end if*/\n\treturn OPJ_FALSE;\n}\n\n\n/*\n==========================================================\n   Packet iterator interface\n==========================================================\n*/\nopj_pi_iterator_t *opj_pi_create_decode(opj_image_t *p_image,\n\t\t\t\t\t\t\t\t\t\topj_cp_t *p_cp,\n\t\t\t\t\t\t\t\t\t\tOPJ_UINT32 p_tile_no)\n{\n\t/* loop */\n\tOPJ_UINT32 pino;\n\tOPJ_UINT32 compno, resno;\n\n\t/* to store w, h, dx and dy fro all components and resolutions */\n\tOPJ_UINT32 * l_tmp_data;\n\tOPJ_UINT32 ** l_tmp_ptr;\n\n\t/* encoding prameters to set */\n\tOPJ_UINT32 l_max_res;\n\tOPJ_UINT32 l_max_prec;\n\tOPJ_INT32 l_tx0,l_tx1,l_ty0,l_ty1;\n\tOPJ_UINT32 l_dx_min,l_dy_min;\n\tOPJ_UINT32 l_bound;\n\tOPJ_UINT32 l_step_p , l_step_c , l_step_r , l_step_l ;\n\tOPJ_UINT32 l_data_stride;\n\n\t/* pointers */\n\topj_pi_iterator_t *l_pi = 00;\n\topj_tcp_t *l_tcp = 00;\n\tconst opj_tccp_t *l_tccp = 00;\n\topj_pi_comp_t *l_current_comp = 00;\n\topj_image_comp_t * l_img_comp = 00;\n\topj_pi_iterator_t * l_current_pi = 00;\n\tOPJ_UINT32 * l_encoding_value_ptr = 00;\n\n\t/* preconditions in debug */\n\tassert(p_cp != 00);\n\tassert(p_image != 00);\n\tassert(p_tile_no < p_cp->tw * p_cp->th);\n\n\t/* initializations */\n\tl_tcp = &p_cp->tcps[p_tile_no];\n\tl_bound = l_tcp->numpocs+1;\n\n\tl_data_stride = 4 * OPJ_J2K_MAXRLVLS;\n\tl_tmp_data = (OPJ_UINT32*)opj_malloc(\n\t\tl_data_stride * p_image->numcomps * sizeof(OPJ_UINT32));\n\tif\n\t\t(! l_tmp_data)\n\t{\n\t\treturn 00;\n\t}\n\tl_tmp_ptr = (OPJ_UINT32**)opj_malloc(\n\t\tp_image->numcomps * sizeof(OPJ_UINT32 *));\n\tif\n\t\t(! l_tmp_ptr)\n\t{\n\t\topj_free(l_tmp_data);\n\t\treturn 00;\n\t}\n\n\t/* memory allocation for pi */\n\tl_pi = opj_pi_create(p_image, p_cp, p_tile_no);\n\tif (!l_pi) {\n\t\topj_free(l_tmp_data);\n\t\topj_free(l_tmp_ptr);\n\t\treturn 00;\n\t}\n\n\tl_encoding_value_ptr = l_tmp_data;\n\t/* update pointer array */\n\tfor\n\t\t(compno = 0; compno < p_image->numcomps; ++compno)\n\t{\n\t\tl_tmp_ptr[compno] = l_encoding_value_ptr;\n\t\tl_encoding_value_ptr += l_data_stride;\n\t}\n\t/* get encoding parameters */\n\topj_get_all_encoding_parameters(p_image,p_cp,p_tile_no,&l_tx0,&l_tx1,&l_ty0,&l_ty1,&l_dx_min,&l_dy_min,&l_max_prec,&l_max_res,l_tmp_ptr);\n\n\t/* step calculations */\n\tl_step_p = 1;\n\tl_step_c = l_max_prec * l_step_p;\n\tl_step_r = p_image->numcomps * l_step_c;\n\tl_step_l = l_max_res * l_step_r;\n\n\t/* set values for first packet iterator */\n\tl_current_pi = l_pi;\n\n\t/* memory allocation for include */\n\tl_current_pi->include = (OPJ_INT16*) opj_calloc((l_tcp->numlayers +1) * l_step_l, sizeof(OPJ_INT16));\n\tif\n\t\t(!l_current_pi->include)\n\t{\n\t\topj_free(l_tmp_data);\n\t\topj_free(l_tmp_ptr);\n\t\topj_pi_destroy(l_pi, l_bound);\n\t\treturn 00;\n\t}\n\n\t/* special treatment for the first packet iterator */\n\tl_current_comp = l_current_pi->comps;\n\tl_img_comp = p_image->comps;\n\tl_tccp = l_tcp->tccps;\n\n\tl_current_pi->tx0 = l_tx0;\n\tl_current_pi->ty0 = l_ty0;\n\tl_current_pi->tx1 = l_tx1;\n\tl_current_pi->ty1 = l_ty1;\n\n\t/*l_current_pi->dx = l_img_comp->dx;*/\n\t/*l_current_pi->dy = l_img_comp->dy;*/\n\n\tl_current_pi->step_p = l_step_p;\n\tl_current_pi->step_c = l_step_c;\n\tl_current_pi->step_r = l_step_r;\n\tl_current_pi->step_l = l_step_l;\n\n\t/* allocation for components and number of components has already been calculated by opj_pi_create */\n\tfor\n\t\t(compno = 0; compno < l_current_pi->numcomps; ++compno)\n\t{\n\t\topj_pi_resolution_t *l_res = l_current_comp->resolutions;\n\t\tl_encoding_value_ptr = l_tmp_ptr[compno];\n\n\t\tl_current_comp->dx = l_img_comp->dx;\n\t\tl_current_comp->dy = l_img_comp->dy;\n\t\t/* resolutions have already been initialized */\n\t\tfor\n\t\t\t(resno = 0; resno < l_current_comp->numresolutions; resno++)\n\t\t{\n\t\t\tl_res->pdx = *(l_encoding_value_ptr++);\n\t\t\tl_res->pdy = *(l_encoding_value_ptr++);\n\t\t\tl_res->pw =  *(l_encoding_value_ptr++);\n\t\t\tl_res->ph =  *(l_encoding_value_ptr++);\n\t\t\t++l_res;\n\t\t}\n\t\t++l_current_comp;\n\t\t++l_img_comp;\n\t\t++l_tccp;\n\t}\n\t++l_current_pi;\n\n\tfor (pino = 1 ; pino<l_bound ; ++pino )\n\t{\n\t\tl_current_comp = l_current_pi->comps;\n\t\tl_img_comp = p_image->comps;\n\t\tl_tccp = l_tcp->tccps;\n\n\t\tl_current_pi->tx0 = l_tx0;\n\t\tl_current_pi->ty0 = l_ty0;\n\t\tl_current_pi->tx1 = l_tx1;\n\t\tl_current_pi->ty1 = l_ty1;\n\t\t/*l_current_pi->dx = l_dx_min;*/\n\t\t/*l_current_pi->dy = l_dy_min;*/\n\t\tl_current_pi->step_p = l_step_p;\n\t\tl_current_pi->step_c = l_step_c;\n\t\tl_current_pi->step_r = l_step_r;\n\t\tl_current_pi->step_l = l_step_l;\n\n\t\t/* allocation for components and number of components has already been calculated by opj_pi_create */\n\t\tfor\n\t\t\t(compno = 0; compno < l_current_pi->numcomps; ++compno)\n\t\t{\n\t\t\topj_pi_resolution_t *l_res = l_current_comp->resolutions;\n\t\t\tl_encoding_value_ptr = l_tmp_ptr[compno];\n\n\t\t\tl_current_comp->dx = l_img_comp->dx;\n\t\t\tl_current_comp->dy = l_img_comp->dy;\n\t\t\t/* resolutions have already been initialized */\n\t\t\tfor\n\t\t\t\t(resno = 0; resno < l_current_comp->numresolutions; resno++)\n\t\t\t{\n\t\t\t\tl_res->pdx = *(l_encoding_value_ptr++);\n\t\t\t\tl_res->pdy = *(l_encoding_value_ptr++);\n\t\t\t\tl_res->pw =  *(l_encoding_value_ptr++);\n\t\t\t\tl_res->ph =  *(l_encoding_value_ptr++);\n\t\t\t\t++l_res;\n\t\t\t}\n\t\t\t++l_current_comp;\n\t\t\t++l_img_comp;\n\t\t\t++l_tccp;\n\t\t}\n\t\t/* special treatment*/\n\t\tl_current_pi->include = (l_current_pi-1)->include;\n\t\t++l_current_pi;\n\t}\n\topj_free(l_tmp_data);\n\tl_tmp_data = 00;\n\topj_free(l_tmp_ptr);\n\tl_tmp_ptr = 00;\n\tif\n\t\t(l_tcp->POC)\n\t{\n\t\topj_pi_update_decode_poc (l_pi,l_tcp,l_max_prec,l_max_res);\n\t}\n\telse\n\t{\n\t\topj_pi_update_decode_not_poc(l_pi,l_tcp,l_max_prec,l_max_res);\n\t}\n\treturn l_pi;\n}\n\n\n\nopj_pi_iterator_t *opj_pi_initialise_encode(const opj_image_t *p_image,\n                                            opj_cp_t *p_cp,\n                                            OPJ_UINT32 p_tile_no,\n                                            J2K_T2_MODE p_t2_mode )\n{\n\t/* loop*/\n\tOPJ_UINT32 pino;\n\tOPJ_UINT32 compno, resno;\n\n\t/* to store w, h, dx and dy fro all components and resolutions*/\n\tOPJ_UINT32 * l_tmp_data;\n\tOPJ_UINT32 ** l_tmp_ptr;\n\n\t/* encoding prameters to set*/\n\tOPJ_UINT32 l_max_res;\n\tOPJ_UINT32 l_max_prec;\n\tOPJ_INT32 l_tx0,l_tx1,l_ty0,l_ty1;\n\tOPJ_UINT32 l_dx_min,l_dy_min;\n\tOPJ_UINT32 l_bound;\n\tOPJ_UINT32 l_step_p , l_step_c , l_step_r , l_step_l ;\n\tOPJ_UINT32 l_data_stride;\n\n\t/* pointers*/\n\topj_pi_iterator_t *l_pi = 00;\n\topj_tcp_t *l_tcp = 00;\n\tconst opj_tccp_t *l_tccp = 00;\n\topj_pi_comp_t *l_current_comp = 00;\n\topj_image_comp_t * l_img_comp = 00;\n\topj_pi_iterator_t * l_current_pi = 00;\n\tOPJ_UINT32 * l_encoding_value_ptr = 00;\n\n\t/* preconditions in debug*/\n\tassert(p_cp != 00);\n\tassert(p_image != 00);\n\tassert(p_tile_no < p_cp->tw * p_cp->th);\n\n\t/* initializations*/\n\tl_tcp = &p_cp->tcps[p_tile_no];\n\tl_bound = l_tcp->numpocs+1;\n\n\tl_data_stride = 4 * OPJ_J2K_MAXRLVLS;\n\tl_tmp_data = (OPJ_UINT32*)opj_malloc(\n\t\tl_data_stride * p_image->numcomps * sizeof(OPJ_UINT32));\n\tif (! l_tmp_data) {\n\t\treturn 00;\n\t}\n\n\tl_tmp_ptr = (OPJ_UINT32**)opj_malloc(\n\t\tp_image->numcomps * sizeof(OPJ_UINT32 *));\n\tif (! l_tmp_ptr) {\n\t\topj_free(l_tmp_data);\n\t\treturn 00;\n\t}\n\n\t/* memory allocation for pi*/\n\tl_pi = opj_pi_create(p_image,p_cp,p_tile_no);\n\tif (!l_pi) {\n\t\topj_free(l_tmp_data);\n\t\topj_free(l_tmp_ptr);\n\t\treturn 00;\n\t}\n\n\tl_encoding_value_ptr = l_tmp_data;\n\t/* update pointer array*/\n\tfor (compno = 0; compno < p_image->numcomps; ++compno) {\n\t\tl_tmp_ptr[compno] = l_encoding_value_ptr;\n\t\tl_encoding_value_ptr += l_data_stride;\n\t}\n\n\t/* get encoding parameters*/\n\topj_get_all_encoding_parameters(p_image,p_cp,p_tile_no,&l_tx0,&l_tx1,&l_ty0,&l_ty1,&l_dx_min,&l_dy_min,&l_max_prec,&l_max_res,l_tmp_ptr);\n\n\t/* step calculations*/\n\tl_step_p = 1;\n\tl_step_c = l_max_prec * l_step_p;\n\tl_step_r = p_image->numcomps * l_step_c;\n\tl_step_l = l_max_res * l_step_r;\n\n\t/* set values for first packet iterator*/\n\tl_pi->tp_on = p_cp->m_specific_param.m_enc.m_tp_on;\n\tl_current_pi = l_pi;\n\n\t/* memory allocation for include*/\n\tl_current_pi->include = (OPJ_INT16*) opj_calloc(l_tcp->numlayers * l_step_l, sizeof(OPJ_INT16));\n\tif (!l_current_pi->include) {\n\t\topj_free(l_tmp_data);\n\t\topj_free(l_tmp_ptr);\n\t\topj_pi_destroy(l_pi, l_bound);\n\t\treturn 00;\n\t}\n\n\t/* special treatment for the first packet iterator*/\n\tl_current_comp = l_current_pi->comps;\n\tl_img_comp = p_image->comps;\n\tl_tccp = l_tcp->tccps;\n\tl_current_pi->tx0 = l_tx0;\n\tl_current_pi->ty0 = l_ty0;\n\tl_current_pi->tx1 = l_tx1;\n\tl_current_pi->ty1 = l_ty1;\n\tl_current_pi->dx = l_dx_min;\n\tl_current_pi->dy = l_dy_min;\n\tl_current_pi->step_p = l_step_p;\n\tl_current_pi->step_c = l_step_c;\n\tl_current_pi->step_r = l_step_r;\n\tl_current_pi->step_l = l_step_l;\n\n\t/* allocation for components and number of components has already been calculated by opj_pi_create */\n\tfor (compno = 0; compno < l_current_pi->numcomps; ++compno) {\n\t\topj_pi_resolution_t *l_res = l_current_comp->resolutions;\n\t\tl_encoding_value_ptr = l_tmp_ptr[compno];\n\n\t\tl_current_comp->dx = l_img_comp->dx;\n\t\tl_current_comp->dy = l_img_comp->dy;\n\n\t\t/* resolutions have already been initialized */\n\t\tfor (resno = 0; resno < l_current_comp->numresolutions; resno++) {\n\t\t\tl_res->pdx = *(l_encoding_value_ptr++);\n\t\t\tl_res->pdy = *(l_encoding_value_ptr++);\n\t\t\tl_res->pw =  *(l_encoding_value_ptr++);\n\t\t\tl_res->ph =  *(l_encoding_value_ptr++);\n\t\t\t++l_res;\n\t\t}\n\n\t\t++l_current_comp;\n\t\t++l_img_comp;\n\t\t++l_tccp;\n\t}\n\t++l_current_pi;\n\n\tfor (pino = 1 ; pino<l_bound ; ++pino ) {\n\t\tl_current_comp = l_current_pi->comps;\n\t\tl_img_comp = p_image->comps;\n\t\tl_tccp = l_tcp->tccps;\n\n\t\tl_current_pi->tx0 = l_tx0;\n\t\tl_current_pi->ty0 = l_ty0;\n\t\tl_current_pi->tx1 = l_tx1;\n\t\tl_current_pi->ty1 = l_ty1;\n\t\tl_current_pi->dx = l_dx_min;\n\t\tl_current_pi->dy = l_dy_min;\n\t\tl_current_pi->step_p = l_step_p;\n\t\tl_current_pi->step_c = l_step_c;\n\t\tl_current_pi->step_r = l_step_r;\n\t\tl_current_pi->step_l = l_step_l;\n\n\t\t/* allocation for components and number of components has already been calculated by opj_pi_create */\n\t\tfor (compno = 0; compno < l_current_pi->numcomps; ++compno) {\n\t\t\topj_pi_resolution_t *l_res = l_current_comp->resolutions;\n\t\t\tl_encoding_value_ptr = l_tmp_ptr[compno];\n\n\t\t\tl_current_comp->dx = l_img_comp->dx;\n\t\t\tl_current_comp->dy = l_img_comp->dy;\n\t\t\t/* resolutions have already been initialized */\n\t\t\tfor (resno = 0; resno < l_current_comp->numresolutions; resno++) {\n\t\t\t\tl_res->pdx = *(l_encoding_value_ptr++);\n\t\t\t\tl_res->pdy = *(l_encoding_value_ptr++);\n\t\t\t\tl_res->pw =  *(l_encoding_value_ptr++);\n\t\t\t\tl_res->ph =  *(l_encoding_value_ptr++);\n\t\t\t\t++l_res;\n\t\t\t}\n\t\t\t++l_current_comp;\n\t\t\t++l_img_comp;\n\t\t\t++l_tccp;\n\t\t}\n\n\t\t/* special treatment*/\n\t\tl_current_pi->include = (l_current_pi-1)->include;\n\t\t++l_current_pi;\n\t}\n\n\topj_free(l_tmp_data);\n\tl_tmp_data = 00;\n\topj_free(l_tmp_ptr);\n\tl_tmp_ptr = 00;\n\n    if (l_tcp->POC && (OPJ_IS_CINEMA(p_cp->rsiz) || p_t2_mode == FINAL_PASS)) {\n\t\topj_pi_update_encode_poc_and_final(p_cp,p_tile_no,l_tx0,l_tx1,l_ty0,l_ty1,l_max_prec,l_max_res,l_dx_min,l_dy_min);\n\t}\n\telse {\n\t\topj_pi_update_encode_not_poc(p_cp,p_image->numcomps,p_tile_no,l_tx0,l_tx1,l_ty0,l_ty1,l_max_prec,l_max_res,l_dx_min,l_dy_min);\n\t}\n\n\treturn l_pi;\n}\n\nvoid opj_pi_create_encode( \topj_pi_iterator_t *pi,\n\t\t\t\t\t\t\topj_cp_t *cp,\n\t\t\t\t\t\t\tOPJ_UINT32 tileno,\n\t\t\t\t\t\t\tOPJ_UINT32 pino,\n\t\t\t\t\t\t\tOPJ_UINT32 tpnum,\n\t\t\t\t\t\t\tOPJ_INT32 tppos,\n\t\t\t\t\t\t\tJ2K_T2_MODE t2_mode)\n{\n\tconst OPJ_CHAR *prog;\n\tOPJ_INT32 i;\n\tOPJ_UINT32 incr_top=1,resetX=0;\n\topj_tcp_t *tcps =&cp->tcps[tileno];\n\topj_poc_t *tcp= &tcps->pocs[pino];\n\n\tprog = opj_j2k_convert_progression_order(tcp->prg);\n\n\tpi[pino].first = 1;\n\tpi[pino].poc.prg = tcp->prg;\n\n    if(!(cp->m_specific_param.m_enc.m_tp_on && ((!OPJ_IS_CINEMA(cp->rsiz) && (t2_mode == FINAL_PASS)) || OPJ_IS_CINEMA(cp->rsiz)))){\n\t\tpi[pino].poc.resno0 = tcp->resS;\n\t\tpi[pino].poc.resno1 = tcp->resE;\n\t\tpi[pino].poc.compno0 = tcp->compS;\n\t\tpi[pino].poc.compno1 = tcp->compE;\n\t\tpi[pino].poc.layno0 = tcp->layS;\n\t\tpi[pino].poc.layno1 = tcp->layE;\n\t\tpi[pino].poc.precno0 = tcp->prcS;\n\t\tpi[pino].poc.precno1 = tcp->prcE;\n\t\tpi[pino].poc.tx0 = (OPJ_INT32)tcp->txS;\n\t\tpi[pino].poc.ty0 = (OPJ_INT32)tcp->tyS;\n\t\tpi[pino].poc.tx1 = (OPJ_INT32)tcp->txE;\n\t\tpi[pino].poc.ty1 = (OPJ_INT32)tcp->tyE;\n\t}else {\n\t\tfor(i=tppos+1;i<4;i++){\n\t\t\tswitch(prog[i]){\n\t\t\tcase 'R':\n\t\t\t\tpi[pino].poc.resno0 = tcp->resS;\n\t\t\t\tpi[pino].poc.resno1 = tcp->resE;\n\t\t\t\tbreak;\n\t\t\tcase 'C':\n\t\t\t\tpi[pino].poc.compno0 = tcp->compS;\n\t\t\t\tpi[pino].poc.compno1 = tcp->compE;\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\tpi[pino].poc.layno0 = tcp->layS;\n\t\t\t\tpi[pino].poc.layno1 = tcp->layE;\n\t\t\t\tbreak;\n\t\t\tcase 'P':\n\t\t\t\tswitch(tcp->prg){\n\t\t\t\tcase OPJ_LRCP:\n\t\t\t\tcase OPJ_RLCP:\n\t\t\t\t\tpi[pino].poc.precno0 = tcp->prcS;\n\t\t\t\t\tpi[pino].poc.precno1 = tcp->prcE;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tpi[pino].poc.tx0 = (OPJ_INT32)tcp->txS;\n\t\t\t\t\tpi[pino].poc.ty0 = (OPJ_INT32)tcp->tyS;\n\t\t\t\t\tpi[pino].poc.tx1 = (OPJ_INT32)tcp->txE;\n\t\t\t\t\tpi[pino].poc.ty1 = (OPJ_INT32)tcp->tyE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(tpnum==0){\n\t\t\tfor(i=tppos;i>=0;i--){\n\t\t\t\tswitch(prog[i]){\n\t\t\t\tcase 'C':\n\t\t\t\t\ttcp->comp_t = tcp->compS;\n\t\t\t\t\tpi[pino].poc.compno0 = tcp->comp_t;\n\t\t\t\t\tpi[pino].poc.compno1 = tcp->comp_t+1;\n\t\t\t\t\ttcp->comp_t+=1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\ttcp->res_t = tcp->resS;\n\t\t\t\t\tpi[pino].poc.resno0 = tcp->res_t;\n\t\t\t\t\tpi[pino].poc.resno1 = tcp->res_t+1;\n\t\t\t\t\ttcp->res_t+=1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'L':\n\t\t\t\t\ttcp->lay_t = tcp->layS;\n\t\t\t\t\tpi[pino].poc.layno0 = tcp->lay_t;\n\t\t\t\t\tpi[pino].poc.layno1 = tcp->lay_t+1;\n\t\t\t\t\ttcp->lay_t+=1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'P':\n\t\t\t\t\tswitch(tcp->prg){\n\t\t\t\t\tcase OPJ_LRCP:\n\t\t\t\t\tcase OPJ_RLCP:\n\t\t\t\t\t\ttcp->prc_t = tcp->prcS;\n\t\t\t\t\t\tpi[pino].poc.precno0 = tcp->prc_t;\n\t\t\t\t\t\tpi[pino].poc.precno1 = tcp->prc_t+1;\n\t\t\t\t\t\ttcp->prc_t+=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\ttcp->tx0_t = tcp->txS;\n\t\t\t\t\t\ttcp->ty0_t = tcp->tyS;\n\t\t\t\t\t\tpi[pino].poc.tx0 = (OPJ_INT32)tcp->tx0_t;\n\t\t\t\t\t\tpi[pino].poc.tx1 = (OPJ_INT32)(tcp->tx0_t + tcp->dx - (tcp->tx0_t % tcp->dx));\n\t\t\t\t\t\tpi[pino].poc.ty0 = (OPJ_INT32)tcp->ty0_t;\n\t\t\t\t\t\tpi[pino].poc.ty1 = (OPJ_INT32)(tcp->ty0_t + tcp->dy - (tcp->ty0_t % tcp->dy));\n\t\t\t\t\t\ttcp->tx0_t = (OPJ_UINT32)pi[pino].poc.tx1;\n\t\t\t\t\t\ttcp->ty0_t = (OPJ_UINT32)pi[pino].poc.ty1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tincr_top=1;\n\t\t}else{\n\t\t\tfor(i=tppos;i>=0;i--){\n\t\t\t\tswitch(prog[i]){\n\t\t\t\tcase 'C':\n\t\t\t\t\tpi[pino].poc.compno0 = tcp->comp_t-1;\n\t\t\t\t\tpi[pino].poc.compno1 = tcp->comp_t;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tpi[pino].poc.resno0 = tcp->res_t-1;\n\t\t\t\t\tpi[pino].poc.resno1 = tcp->res_t;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'L':\n\t\t\t\t\tpi[pino].poc.layno0 = tcp->lay_t-1;\n\t\t\t\t\tpi[pino].poc.layno1 = tcp->lay_t;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'P':\n\t\t\t\t\tswitch(tcp->prg){\n\t\t\t\t\tcase OPJ_LRCP:\n\t\t\t\t\tcase OPJ_RLCP:\n\t\t\t\t\t\tpi[pino].poc.precno0 = tcp->prc_t-1;\n\t\t\t\t\t\tpi[pino].poc.precno1 = tcp->prc_t;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tpi[pino].poc.tx0 = (OPJ_INT32)(tcp->tx0_t - tcp->dx - (tcp->tx0_t % tcp->dx));\n\t\t\t\t\t\tpi[pino].poc.tx1 = (OPJ_INT32)tcp->tx0_t ;\n\t\t\t\t\t\tpi[pino].poc.ty0 = (OPJ_INT32)(tcp->ty0_t - tcp->dy - (tcp->ty0_t % tcp->dy));\n\t\t\t\t\t\tpi[pino].poc.ty1 = (OPJ_INT32)tcp->ty0_t ;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(incr_top==1){\n\t\t\t\t\tswitch(prog[i]){\n\t\t\t\t\tcase 'R':\n\t\t\t\t\t\tif(tcp->res_t==tcp->resE){\n\t\t\t\t\t\t\tif(opj_pi_check_next_level(i-1,cp,tileno,pino,prog)){\n\t\t\t\t\t\t\t\ttcp->res_t = tcp->resS;\n\t\t\t\t\t\t\t\tpi[pino].poc.resno0 = tcp->res_t;\n\t\t\t\t\t\t\t\tpi[pino].poc.resno1 = tcp->res_t+1;\n\t\t\t\t\t\t\t\ttcp->res_t+=1;\n\t\t\t\t\t\t\t\tincr_top=1;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tincr_top=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tpi[pino].poc.resno0 = tcp->res_t;\n\t\t\t\t\t\t\tpi[pino].poc.resno1 = tcp->res_t+1;\n\t\t\t\t\t\t\ttcp->res_t+=1;\n\t\t\t\t\t\t\tincr_top=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'C':\n\t\t\t\t\t\tif(tcp->comp_t ==tcp->compE){\n\t\t\t\t\t\t\tif(opj_pi_check_next_level(i-1,cp,tileno,pino,prog)){\n\t\t\t\t\t\t\t\ttcp->comp_t = tcp->compS;\n\t\t\t\t\t\t\t\tpi[pino].poc.compno0 = tcp->comp_t;\n\t\t\t\t\t\t\t\tpi[pino].poc.compno1 = tcp->comp_t+1;\n\t\t\t\t\t\t\t\ttcp->comp_t+=1;\n\t\t\t\t\t\t\t\tincr_top=1;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tincr_top=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tpi[pino].poc.compno0 = tcp->comp_t;\n\t\t\t\t\t\t\tpi[pino].poc.compno1 = tcp->comp_t+1;\n\t\t\t\t\t\t\ttcp->comp_t+=1;\n\t\t\t\t\t\t\tincr_top=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'L':\n\t\t\t\t\t\tif(tcp->lay_t == tcp->layE){\n\t\t\t\t\t\t\tif(opj_pi_check_next_level(i-1,cp,tileno,pino,prog)){\n\t\t\t\t\t\t\t\ttcp->lay_t = tcp->layS;\n\t\t\t\t\t\t\t\tpi[pino].poc.layno0 = tcp->lay_t;\n\t\t\t\t\t\t\t\tpi[pino].poc.layno1 = tcp->lay_t+1;\n\t\t\t\t\t\t\t\ttcp->lay_t+=1;\n\t\t\t\t\t\t\t\tincr_top=1;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tincr_top=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tpi[pino].poc.layno0 = tcp->lay_t;\n\t\t\t\t\t\t\tpi[pino].poc.layno1 = tcp->lay_t+1;\n\t\t\t\t\t\t\ttcp->lay_t+=1;\n\t\t\t\t\t\t\tincr_top=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'P':\n\t\t\t\t\t\tswitch(tcp->prg){\n\t\t\t\t\t\tcase OPJ_LRCP:\n\t\t\t\t\t\tcase OPJ_RLCP:\n\t\t\t\t\t\t\tif(tcp->prc_t == tcp->prcE){\n\t\t\t\t\t\t\t\tif(opj_pi_check_next_level(i-1,cp,tileno,pino,prog)){\n\t\t\t\t\t\t\t\t\ttcp->prc_t = tcp->prcS;\n\t\t\t\t\t\t\t\t\tpi[pino].poc.precno0 = tcp->prc_t;\n\t\t\t\t\t\t\t\t\tpi[pino].poc.precno1 = tcp->prc_t+1;\n\t\t\t\t\t\t\t\t\ttcp->prc_t+=1;\n\t\t\t\t\t\t\t\t\tincr_top=1;\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\tincr_top=0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tpi[pino].poc.precno0 = tcp->prc_t;\n\t\t\t\t\t\t\t\tpi[pino].poc.precno1 = tcp->prc_t+1;\n\t\t\t\t\t\t\t\ttcp->prc_t+=1;\n\t\t\t\t\t\t\t\tincr_top=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tif(tcp->tx0_t >= tcp->txE){\n\t\t\t\t\t\t\t\tif(tcp->ty0_t >= tcp->tyE){\n\t\t\t\t\t\t\t\t\tif(opj_pi_check_next_level(i-1,cp,tileno,pino,prog)){\n\t\t\t\t\t\t\t\t\t\ttcp->ty0_t = tcp->tyS;\n\t\t\t\t\t\t\t\t\t\tpi[pino].poc.ty0 = (OPJ_INT32)tcp->ty0_t;\n\t\t\t\t\t\t\t\t\t\tpi[pino].poc.ty1 = (OPJ_INT32)(tcp->ty0_t + tcp->dy - (tcp->ty0_t % tcp->dy));\n\t\t\t\t\t\t\t\t\t\ttcp->ty0_t = (OPJ_UINT32)pi[pino].poc.ty1;\n\t\t\t\t\t\t\t\t\t\tincr_top=1;resetX=1;\n\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\tincr_top=0;resetX=0;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\tpi[pino].poc.ty0 = (OPJ_INT32)tcp->ty0_t;\n\t\t\t\t\t\t\t\t\tpi[pino].poc.ty1 = (OPJ_INT32)(tcp->ty0_t + tcp->dy - (tcp->ty0_t % tcp->dy));\n\t\t\t\t\t\t\t\t\ttcp->ty0_t = (OPJ_UINT32)pi[pino].poc.ty1;\n\t\t\t\t\t\t\t\t\tincr_top=0;resetX=1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(resetX==1){\n\t\t\t\t\t\t\t\t\ttcp->tx0_t = tcp->txS;\n\t\t\t\t\t\t\t\t\tpi[pino].poc.tx0 = (OPJ_INT32)tcp->tx0_t;\n\t\t\t\t\t\t\t\t\tpi[pino].poc.tx1 = (OPJ_INT32)(tcp->tx0_t + tcp->dx- (tcp->tx0_t % tcp->dx));\n\t\t\t\t\t\t\t\t\ttcp->tx0_t = (OPJ_UINT32)pi[pino].poc.tx1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tpi[pino].poc.tx0 = (OPJ_INT32)tcp->tx0_t;\n\t\t\t\t\t\t\t\tpi[pino].poc.tx1 = (OPJ_INT32)(tcp->tx0_t + tcp->dx- (tcp->tx0_t % tcp->dx));\n\t\t\t\t\t\t\t\ttcp->tx0_t = (OPJ_UINT32)pi[pino].poc.tx1;\n\t\t\t\t\t\t\t\tincr_top=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid opj_pi_destroy(opj_pi_iterator_t *p_pi,\n                    OPJ_UINT32 p_nb_elements)\n{\n\tOPJ_UINT32 compno, pino;\n\topj_pi_iterator_t *l_current_pi = p_pi;\n    if (p_pi) {\n\t\tif (p_pi->include) {\n\t\t\topj_free(p_pi->include);\n\t\t\tp_pi->include = 00;\n\t\t}\n\t\tfor (pino = 0; pino < p_nb_elements; ++pino){\n\t\t\tif(l_current_pi->comps) {\n\t\t\t\topj_pi_comp_t *l_current_component = l_current_pi->comps;\n                for (compno = 0; compno < l_current_pi->numcomps; compno++){\n                    if(l_current_component->resolutions) {\n\t\t\t\t\t\topj_free(l_current_component->resolutions);\n\t\t\t\t\t\tl_current_component->resolutions = 00;\n\t\t\t\t\t}\n\n\t\t\t\t\t++l_current_component;\n\t\t\t\t}\n\t\t\t\topj_free(l_current_pi->comps);\n\t\t\t\tl_current_pi->comps = 0;\n\t\t\t}\n\t\t\t++l_current_pi;\n\t\t}\n\t\topj_free(p_pi);\n\t}\n}\n\n\n\nvoid opj_pi_update_encoding_parameters(\tconst opj_image_t *p_image,\n                                        opj_cp_t *p_cp,\n                                        OPJ_UINT32 p_tile_no )\n{\n\t/* encoding parameters to set */\n\tOPJ_UINT32 l_max_res;\n\tOPJ_UINT32 l_max_prec;\n\tOPJ_INT32 l_tx0,l_tx1,l_ty0,l_ty1;\n\tOPJ_UINT32 l_dx_min,l_dy_min;\n\n\t/* pointers */\n\topj_tcp_t *l_tcp = 00;\n\n\t/* preconditions */\n\tassert(p_cp != 00);\n\tassert(p_image != 00);\n\tassert(p_tile_no < p_cp->tw * p_cp->th);\n\n\tl_tcp = &(p_cp->tcps[p_tile_no]);\n\n\t/* get encoding parameters */\n\topj_get_encoding_parameters(p_image,p_cp,p_tile_no,&l_tx0,&l_tx1,&l_ty0,&l_ty1,&l_dx_min,&l_dy_min,&l_max_prec,&l_max_res);\n\n\tif (l_tcp->POC) {\n\t\topj_pi_update_encode_poc_and_final(p_cp,p_tile_no,l_tx0,l_tx1,l_ty0,l_ty1,l_max_prec,l_max_res,l_dx_min,l_dy_min);\n\t}\n\telse {\n\t\topj_pi_update_encode_not_poc(p_cp,p_image->numcomps,p_tile_no,l_tx0,l_tx1,l_ty0,l_ty1,l_max_prec,l_max_res,l_dx_min,l_dy_min);\n\t}\n}\n\nOPJ_BOOL opj_pi_next(opj_pi_iterator_t * pi) {\n\tswitch (pi->poc.prg) {\n\t\tcase OPJ_LRCP:\n\t\t\treturn opj_pi_next_lrcp(pi);\n\t\tcase OPJ_RLCP:\n\t\t\treturn opj_pi_next_rlcp(pi);\n\t\tcase OPJ_RPCL:\n\t\t\treturn opj_pi_next_rpcl(pi);\n\t\tcase OPJ_PCRL:\n\t\t\treturn opj_pi_next_pcrl(pi);\n\t\tcase OPJ_CPRL:\n\t\t\treturn opj_pi_next_cprl(pi);\n\t\tcase OPJ_PROG_UNKNOWN:\n\t\t\treturn OPJ_FALSE;\n\t}\n\t\n\treturn OPJ_FALSE;\n}\n", "/*\n * The copyright in this software is being made available under the 2-clauses \n * BSD License, included below. This software may be subject to other third \n * party and contributor rights, including patent rights, and no such rights\n * are granted under this license.\n *\n * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium\n * Copyright (c) 2002-2014, Professor Benoit Macq\n * Copyright (c) 2001-2003, David Janssens\n * Copyright (c) 2002-2003, Yannick Verschueren\n * Copyright (c) 2003-2007, Francois-Olivier Devaux \n * Copyright (c) 2003-2014, Antonin Descampe\n * Copyright (c) 2005, Herve Drolon, FreeImage Team\n * Copyright (c) 2006-2007, Parvatha Elangovan\n * Copyright (c) 2008, 2011-2012, Centre National d'Etudes Spatiales (CNES), FR \n * Copyright (c) 2012, CS Systemes d'Information, France\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"opj_includes.h\"\n\n/* ----------------------------------------------------------------------- */\n\n/* TODO MSD: */\n#ifdef TODO_MSD \nvoid tcd_dump(FILE *fd, opj_tcd_t *tcd, opj_tcd_image_t * img) {\n        int tileno, compno, resno, bandno, precno;/*, cblkno;*/\n\n        fprintf(fd, \"image {\\n\");\n        fprintf(fd, \"  tw=%d, th=%d x0=%d x1=%d y0=%d y1=%d\\n\", \n                img->tw, img->th, tcd->image->x0, tcd->image->x1, tcd->image->y0, tcd->image->y1);\n\n        for (tileno = 0; tileno < img->th * img->tw; tileno++) {\n                opj_tcd_tile_t *tile = &tcd->tcd_image->tiles[tileno];\n                fprintf(fd, \"  tile {\\n\");\n                fprintf(fd, \"    x0=%d, y0=%d, x1=%d, y1=%d, numcomps=%d\\n\",\n                        tile->x0, tile->y0, tile->x1, tile->y1, tile->numcomps);\n                for (compno = 0; compno < tile->numcomps; compno++) {\n                        opj_tcd_tilecomp_t *tilec = &tile->comps[compno];\n                        fprintf(fd, \"    tilec {\\n\");\n                        fprintf(fd,\n                                \"      x0=%d, y0=%d, x1=%d, y1=%d, numresolutions=%d\\n\",\n                                tilec->x0, tilec->y0, tilec->x1, tilec->y1, tilec->numresolutions);\n                        for (resno = 0; resno < tilec->numresolutions; resno++) {\n                                opj_tcd_resolution_t *res = &tilec->resolutions[resno];\n                                fprintf(fd, \"\\n   res {\\n\");\n                                fprintf(fd,\n                                        \"          x0=%d, y0=%d, x1=%d, y1=%d, pw=%d, ph=%d, numbands=%d\\n\",\n                                        res->x0, res->y0, res->x1, res->y1, res->pw, res->ph, res->numbands);\n                                for (bandno = 0; bandno < res->numbands; bandno++) {\n                                        opj_tcd_band_t *band = &res->bands[bandno];\n                                        fprintf(fd, \"        band {\\n\");\n                                        fprintf(fd,\n                                                \"          x0=%d, y0=%d, x1=%d, y1=%d, stepsize=%f, numbps=%d\\n\",\n                                                band->x0, band->y0, band->x1, band->y1, band->stepsize, band->numbps);\n                                        for (precno = 0; precno < res->pw * res->ph; precno++) {\n                                                opj_tcd_precinct_t *prec = &band->precincts[precno];\n                                                fprintf(fd, \"          prec {\\n\");\n                                                fprintf(fd,\n                                                        \"            x0=%d, y0=%d, x1=%d, y1=%d, cw=%d, ch=%d\\n\",\n                                                        prec->x0, prec->y0, prec->x1, prec->y1, prec->cw, prec->ch);\n                                                /*\n                                                for (cblkno = 0; cblkno < prec->cw * prec->ch; cblkno++) {\n                                                        opj_tcd_cblk_t *cblk = &prec->cblks[cblkno];\n                                                        fprintf(fd, \"            cblk {\\n\");\n                                                        fprintf(fd,\n                                                                \"              x0=%d, y0=%d, x1=%d, y1=%d\\n\",\n                                                                cblk->x0, cblk->y0, cblk->x1, cblk->y1);\n                                                        fprintf(fd, \"            }\\n\");\n                                                }\n                                                */\n                                                fprintf(fd, \"          }\\n\");\n                                        }\n                                        fprintf(fd, \"        }\\n\");\n                                }\n                                fprintf(fd, \"      }\\n\");\n                        }\n                        fprintf(fd, \"    }\\n\");\n                }\n                fprintf(fd, \"  }\\n\");\n        }\n        fprintf(fd, \"}\\n\");\n}\n#endif\n\n/**\n * Initializes tile coding/decoding\n */\nstatic INLINE OPJ_BOOL opj_tcd_init_tile(opj_tcd_t *p_tcd, OPJ_UINT32 p_tile_no, OPJ_BOOL isEncoder, OPJ_FLOAT32 fraction, OPJ_SIZE_T sizeof_block);\n\n/**\n* Allocates memory for a decoding code block.\n*/\nstatic OPJ_BOOL opj_tcd_code_block_dec_allocate (opj_tcd_cblk_dec_t * p_code_block);\n\n/**\n * Deallocates the decoding data of the given precinct.\n */\nstatic void opj_tcd_code_block_dec_deallocate (opj_tcd_precinct_t * p_precinct);\n\n/**\n * Allocates memory for an encoding code block (but not data).\n */\nstatic OPJ_BOOL opj_tcd_code_block_enc_allocate (opj_tcd_cblk_enc_t * p_code_block);\n\n/**\n * Allocates data for an encoding code block\n */\nstatic OPJ_BOOL opj_tcd_code_block_enc_allocate_data (opj_tcd_cblk_enc_t * p_code_block);\n\n/**\n * Deallocates the encoding data of the given precinct.\n */\nstatic void opj_tcd_code_block_enc_deallocate (opj_tcd_precinct_t * p_precinct);\n\n\n/**\nFree the memory allocated for encoding\n@param tcd TCD handle\n*/\nstatic void opj_tcd_free_tile(opj_tcd_t *tcd);\n\n\nstatic OPJ_BOOL opj_tcd_t2_decode ( opj_tcd_t *p_tcd,\n                                    OPJ_BYTE * p_src_data,\n                                    OPJ_UINT32 * p_data_read,\n                                    OPJ_UINT32 p_max_src_size,\n                                    opj_codestream_index_t *p_cstr_index );\n\nstatic OPJ_BOOL opj_tcd_t1_decode (opj_tcd_t *p_tcd);\n\nstatic OPJ_BOOL opj_tcd_dwt_decode (opj_tcd_t *p_tcd);\n\nstatic OPJ_BOOL opj_tcd_mct_decode (opj_tcd_t *p_tcd);\n\nstatic OPJ_BOOL opj_tcd_dc_level_shift_decode (opj_tcd_t *p_tcd);\n\n\nstatic OPJ_BOOL opj_tcd_dc_level_shift_encode ( opj_tcd_t *p_tcd );\n\nstatic OPJ_BOOL opj_tcd_mct_encode ( opj_tcd_t *p_tcd );\n\nstatic OPJ_BOOL opj_tcd_dwt_encode ( opj_tcd_t *p_tcd );\n\nstatic OPJ_BOOL opj_tcd_t1_encode ( opj_tcd_t *p_tcd );\n\nstatic OPJ_BOOL opj_tcd_t2_encode (     opj_tcd_t *p_tcd,\n                                                                    OPJ_BYTE * p_dest_data,\n                                                                    OPJ_UINT32 * p_data_written,\n                                                                    OPJ_UINT32 p_max_dest_size,\n                                                                    opj_codestream_info_t *p_cstr_info );\n\nstatic OPJ_BOOL opj_tcd_rate_allocate_encode(   opj_tcd_t *p_tcd,\n                                                                                        OPJ_BYTE * p_dest_data,\n                                                                                        OPJ_UINT32 p_max_dest_size,\n                                                                                        opj_codestream_info_t *p_cstr_info );\n\n/* ----------------------------------------------------------------------- */\n\n/**\nCreate a new TCD handle\n*/\nopj_tcd_t* opj_tcd_create(OPJ_BOOL p_is_decoder)\n{\n        opj_tcd_t *l_tcd = 00;\n\n        /* create the tcd structure */\n        l_tcd = (opj_tcd_t*) opj_calloc(1,sizeof(opj_tcd_t));\n        if (!l_tcd) {\n                return 00;\n        }\n\n        l_tcd->m_is_decoder = p_is_decoder ? 1 : 0;\n\n        l_tcd->tcd_image = (opj_tcd_image_t*)opj_calloc(1,sizeof(opj_tcd_image_t));\n        if (!l_tcd->tcd_image) {\n                opj_free(l_tcd);\n                return 00;\n        }\n\n        return l_tcd;\n}\n\n\n/* ----------------------------------------------------------------------- */\n\nvoid opj_tcd_rateallocate_fixed(opj_tcd_t *tcd) {\n        OPJ_UINT32 layno;\n\n        for (layno = 0; layno < tcd->tcp->numlayers; layno++) {\n                opj_tcd_makelayer_fixed(tcd, layno, 1);\n        }\n}\n\n\nvoid opj_tcd_makelayer( opj_tcd_t *tcd,\n                                                OPJ_UINT32 layno,\n                                                OPJ_FLOAT64 thresh,\n                                                OPJ_UINT32 final)\n{\n        OPJ_UINT32 compno, resno, bandno, precno, cblkno;\n        OPJ_UINT32 passno;\n\n        opj_tcd_tile_t *tcd_tile = tcd->tcd_image->tiles;\n\n        tcd_tile->distolayer[layno] = 0;        /* fixed_quality */\n\n        for (compno = 0; compno < tcd_tile->numcomps; compno++) {\n                opj_tcd_tilecomp_t *tilec = &tcd_tile->comps[compno];\n\n                for (resno = 0; resno < tilec->numresolutions; resno++) {\n                        opj_tcd_resolution_t *res = &tilec->resolutions[resno];\n\n                        for (bandno = 0; bandno < res->numbands; bandno++) {\n                                opj_tcd_band_t *band = &res->bands[bandno];\n\n                                for (precno = 0; precno < res->pw * res->ph; precno++) {\n                                        opj_tcd_precinct_t *prc = &band->precincts[precno];\n\n                                        for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {\n                                                opj_tcd_cblk_enc_t *cblk = &prc->cblks.enc[cblkno];\n                                                opj_tcd_layer_t *layer = &cblk->layers[layno];\n                                                OPJ_UINT32 n;\n\n                                                if (layno == 0) {\n                                                        cblk->numpassesinlayers = 0;\n                                                }\n\n                                                n = cblk->numpassesinlayers;\n\n                                                for (passno = cblk->numpassesinlayers; passno < cblk->totalpasses; passno++) {\n                                                        OPJ_UINT32 dr;\n                                                        OPJ_FLOAT64 dd;\n                                                        opj_tcd_pass_t *pass = &cblk->passes[passno];\n\n                                                        if (n == 0) {\n                                                                dr = pass->rate;\n                                                                dd = pass->distortiondec;\n                                                        } else {\n                                                                dr = pass->rate - cblk->passes[n - 1].rate;\n                                                                dd = pass->distortiondec - cblk->passes[n - 1].distortiondec;\n                                                        }\n\n                                                        if (!dr) {\n                                                                if (dd != 0)\n                                                                        n = passno + 1;\n                                                                continue;\n                                                        }\n                                                        if (dd / dr >= thresh)\n                                                                n = passno + 1;\n                                                }\n\n                                                layer->numpasses = n - cblk->numpassesinlayers;\n\n                                                if (!layer->numpasses) {\n                                                        layer->disto = 0;\n                                                        continue;\n                                                }\n\n                                                if (cblk->numpassesinlayers == 0) {\n                                                        layer->len = cblk->passes[n - 1].rate;\n                                                        layer->data = cblk->data;\n                                                        layer->disto = cblk->passes[n - 1].distortiondec;\n                                                } else {\n                                                        layer->len = cblk->passes[n - 1].rate - cblk->passes[cblk->numpassesinlayers - 1].rate;\n                                                        layer->data = cblk->data + cblk->passes[cblk->numpassesinlayers - 1].rate;\n                                                        layer->disto = cblk->passes[n - 1].distortiondec - cblk->passes[cblk->numpassesinlayers - 1].distortiondec;\n                                                }\n\n                                                tcd_tile->distolayer[layno] += layer->disto;    /* fixed_quality */\n\n                                                if (final)\n                                                        cblk->numpassesinlayers = n;\n                                        }\n                                }\n                        }\n                }\n        }\n}\n\nvoid opj_tcd_makelayer_fixed(opj_tcd_t *tcd, OPJ_UINT32 layno, OPJ_UINT32 final) {\n        OPJ_UINT32 compno, resno, bandno, precno, cblkno;\n        OPJ_INT32 value;                        /*, matrice[tcd_tcp->numlayers][tcd_tile->comps[0].numresolutions][3]; */\n        OPJ_INT32 matrice[10][10][3];\n        OPJ_UINT32 i, j, k;\n\n        opj_cp_t *cp = tcd->cp;\n        opj_tcd_tile_t *tcd_tile = tcd->tcd_image->tiles;\n        opj_tcp_t *tcd_tcp = tcd->tcp;\n\n        for (compno = 0; compno < tcd_tile->numcomps; compno++) {\n                opj_tcd_tilecomp_t *tilec = &tcd_tile->comps[compno];\n\n                for (i = 0; i < tcd_tcp->numlayers; i++) {\n                        for (j = 0; j < tilec->numresolutions; j++) {\n                                for (k = 0; k < 3; k++) {\n                                        matrice[i][j][k] =\n                                                (OPJ_INT32) ((OPJ_FLOAT32)cp->m_specific_param.m_enc.m_matrice[i * tilec->numresolutions * 3 + j * 3 + k]\n                                                * (OPJ_FLOAT32) (tcd->image->comps[compno].prec / 16.0));\n                                }\n                        }\n                }\n\n                for (resno = 0; resno < tilec->numresolutions; resno++) {\n                        opj_tcd_resolution_t *res = &tilec->resolutions[resno];\n\n                        for (bandno = 0; bandno < res->numbands; bandno++) {\n                                opj_tcd_band_t *band = &res->bands[bandno];\n\n                                for (precno = 0; precno < res->pw * res->ph; precno++) {\n                                        opj_tcd_precinct_t *prc = &band->precincts[precno];\n\n                                        for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {\n                                                opj_tcd_cblk_enc_t *cblk = &prc->cblks.enc[cblkno];\n                                                opj_tcd_layer_t *layer = &cblk->layers[layno];\n                                                OPJ_UINT32 n;\n                                                OPJ_INT32 imsb = (OPJ_INT32)(tcd->image->comps[compno].prec - cblk->numbps); /* number of bit-plan equal to zero */\n\n                                                /* Correction of the matrix of coefficient to include the IMSB information */\n                                                if (layno == 0) {\n                                                        value = matrice[layno][resno][bandno];\n                                                        if (imsb >= value) {\n                                                                value = 0;\n                                                        } else {\n                                                                value -= imsb;\n                                                        }\n                                                } else {\n                                                        value = matrice[layno][resno][bandno] - matrice[layno - 1][resno][bandno];\n                                                        if (imsb >= matrice[layno - 1][resno][bandno]) {\n                                                                value -= (imsb - matrice[layno - 1][resno][bandno]);\n                                                                if (value < 0) {\n                                                                        value = 0;\n                                                                }\n                                                        }\n                                                }\n\n                                                if (layno == 0) {\n                                                        cblk->numpassesinlayers = 0;\n                                                }\n\n                                                n = cblk->numpassesinlayers;\n                                                if (cblk->numpassesinlayers == 0) {\n                                                        if (value != 0) {\n                                                                n = 3 * (OPJ_UINT32)value - 2 + cblk->numpassesinlayers;\n                                                        } else {\n                                                                n = cblk->numpassesinlayers;\n                                                        }\n                                                } else {\n                                                        n = 3 * (OPJ_UINT32)value + cblk->numpassesinlayers;\n                                                }\n\n                                                layer->numpasses = n - cblk->numpassesinlayers;\n\n                                                if (!layer->numpasses)\n                                                        continue;\n\n                                                if (cblk->numpassesinlayers == 0) {\n                                                        layer->len = cblk->passes[n - 1].rate;\n                                                        layer->data = cblk->data;\n                                                } else {\n                                                        layer->len = cblk->passes[n - 1].rate - cblk->passes[cblk->numpassesinlayers - 1].rate;\n                                                        layer->data = cblk->data + cblk->passes[cblk->numpassesinlayers - 1].rate;\n                                                }\n\n                                                if (final)\n                                                        cblk->numpassesinlayers = n;\n                                        }\n                                }\n                        }\n                }\n        }\n}\n\nOPJ_BOOL opj_tcd_rateallocate(  opj_tcd_t *tcd,\n                                                                OPJ_BYTE *dest,\n                                                                OPJ_UINT32 * p_data_written,\n                                                                OPJ_UINT32 len,\n                                                                opj_codestream_info_t *cstr_info)\n{\n        OPJ_UINT32 compno, resno, bandno, precno, cblkno, layno;\n        OPJ_UINT32 passno;\n        OPJ_FLOAT64 min, max;\n        OPJ_FLOAT64 cumdisto[100];      /* fixed_quality */\n        const OPJ_FLOAT64 K = 1;                /* 1.1; fixed_quality */\n        OPJ_FLOAT64 maxSE = 0;\n\n        opj_cp_t *cp = tcd->cp;\n        opj_tcd_tile_t *tcd_tile = tcd->tcd_image->tiles;\n        opj_tcp_t *tcd_tcp = tcd->tcp;\n\n        min = DBL_MAX;\n        max = 0;\n\n        tcd_tile->numpix = 0;           /* fixed_quality */\n\n        for (compno = 0; compno < tcd_tile->numcomps; compno++) {\n                opj_tcd_tilecomp_t *tilec = &tcd_tile->comps[compno];\n                tilec->numpix = 0;\n\n                for (resno = 0; resno < tilec->numresolutions; resno++) {\n                        opj_tcd_resolution_t *res = &tilec->resolutions[resno];\n\n                        for (bandno = 0; bandno < res->numbands; bandno++) {\n                                opj_tcd_band_t *band = &res->bands[bandno];\n\n                                for (precno = 0; precno < res->pw * res->ph; precno++) {\n                                        opj_tcd_precinct_t *prc = &band->precincts[precno];\n\n                                        for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {\n                                                opj_tcd_cblk_enc_t *cblk = &prc->cblks.enc[cblkno];\n\n                                                for (passno = 0; passno < cblk->totalpasses; passno++) {\n                                                        opj_tcd_pass_t *pass = &cblk->passes[passno];\n                                                        OPJ_INT32 dr;\n                                                        OPJ_FLOAT64 dd, rdslope;\n\n                                                        if (passno == 0) {\n                                                                dr = (OPJ_INT32)pass->rate;\n                                                                dd = pass->distortiondec;\n                                                        } else {\n                                                                dr = (OPJ_INT32)(pass->rate - cblk->passes[passno - 1].rate);\n                                                                dd = pass->distortiondec - cblk->passes[passno - 1].distortiondec;\n                                                        }\n\n                                                        if (dr == 0) {\n                                                                continue;\n                                                        }\n\n                                                        rdslope = dd / dr;\n                                                        if (rdslope < min) {\n                                                                min = rdslope;\n                                                        }\n\n                                                        if (rdslope > max) {\n                                                                max = rdslope;\n                                                        }\n                                                } /* passno */\n\n                                                /* fixed_quality */\n                                                tcd_tile->numpix += ((cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0));\n                                                tilec->numpix += ((cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0));\n                                        } /* cbklno */\n                                } /* precno */\n                        } /* bandno */\n                } /* resno */\n\n                maxSE += (((OPJ_FLOAT64)(1 << tcd->image->comps[compno].prec) - 1.0)\n                        * ((OPJ_FLOAT64)(1 << tcd->image->comps[compno].prec) -1.0))\n                        * ((OPJ_FLOAT64)(tilec->numpix));\n        } /* compno */\n\n        /* index file */\n        if(cstr_info) {\n                opj_tile_info_t *tile_info = &cstr_info->tile[tcd->tcd_tileno];\n                tile_info->numpix = tcd_tile->numpix;\n                tile_info->distotile = tcd_tile->distotile;\n                tile_info->thresh = (OPJ_FLOAT64 *) opj_malloc(tcd_tcp->numlayers * sizeof(OPJ_FLOAT64));\n                if (!tile_info->thresh) {\n                        /* FIXME event manager error callback */\n                        return OPJ_FALSE;\n                }\n        }\n\n        for (layno = 0; layno < tcd_tcp->numlayers; layno++) {\n                OPJ_FLOAT64 lo = min;\n                OPJ_FLOAT64 hi = max;\n                OPJ_BOOL success = OPJ_FALSE;\n                OPJ_UINT32 maxlen = tcd_tcp->rates[layno] ? opj_uint_min(((OPJ_UINT32) ceil(tcd_tcp->rates[layno])), len) : len;\n                OPJ_FLOAT64 goodthresh = 0;\n                OPJ_FLOAT64 stable_thresh = 0;\n                OPJ_UINT32 i;\n                OPJ_FLOAT64 distotarget;                /* fixed_quality */\n\n                /* fixed_quality */\n                distotarget = tcd_tile->distotile - ((K * maxSE) / pow((OPJ_FLOAT32)10, tcd_tcp->distoratio[layno] / 10));\n\n                /* Don't try to find an optimal threshold but rather take everything not included yet, if\n                  -r xx,yy,zz,0   (disto_alloc == 1 and rates == 0)\n                  -q xx,yy,zz,0   (fixed_quality == 1 and distoratio == 0)\n                  ==> possible to have some lossy layers and the last layer for sure lossless */\n                if ( ((cp->m_specific_param.m_enc.m_disto_alloc==1) && (tcd_tcp->rates[layno]>0)) || ((cp->m_specific_param.m_enc.m_fixed_quality==1) && (tcd_tcp->distoratio[layno]>0))) {\n                        opj_t2_t*t2 = opj_t2_create(tcd->image, cp);\n                        OPJ_FLOAT64 thresh = 0;\n\n                        if (t2 == 00) {\n                                return OPJ_FALSE;\n                        }\n\n                        for     (i = 0; i < 128; ++i) {\n                                OPJ_FLOAT64 distoachieved = 0;  /* fixed_quality */\n\n                                thresh = (lo + hi) / 2;\n\n                                opj_tcd_makelayer(tcd, layno, thresh, 0);\n\n                                if (cp->m_specific_param.m_enc.m_fixed_quality) {       /* fixed_quality */\n                                        if(OPJ_IS_CINEMA(cp->rsiz)){\n                                                if (! opj_t2_encode_packets(t2,tcd->tcd_tileno, tcd_tile, layno + 1, dest, p_data_written, maxlen, cstr_info,tcd->cur_tp_num,tcd->tp_pos,tcd->cur_pino,THRESH_CALC)) {\n\n                                                        lo = thresh;\n                                                        continue;\n                                                }\n                                                else {\n                                                        distoachieved = layno == 0 ?\n                                                                        tcd_tile->distolayer[0] : cumdisto[layno - 1] + tcd_tile->distolayer[layno];\n\n                                                        if (distoachieved < distotarget) {\n                                                                hi=thresh;\n                                                                stable_thresh = thresh;\n                                                                continue;\n                                                        }else{\n                                                                lo=thresh;\n                                                        }\n                                                }\n                                        }else{\n                                                distoachieved = (layno == 0) ?\n                                                                tcd_tile->distolayer[0] : (cumdisto[layno - 1] + tcd_tile->distolayer[layno]);\n\n                                                if (distoachieved < distotarget) {\n                                                        hi = thresh;\n                                                        stable_thresh = thresh;\n                                                        continue;\n                                                }\n                                                lo = thresh;\n                                        }\n                                } else {\n                                        if (! opj_t2_encode_packets(t2, tcd->tcd_tileno, tcd_tile, layno + 1, dest,p_data_written, maxlen, cstr_info,tcd->cur_tp_num,tcd->tp_pos,tcd->cur_pino,THRESH_CALC))\n                                        {\n                                                /* TODO: what to do with l ??? seek / tell ??? */\n                                                /* opj_event_msg(tcd->cinfo, EVT_INFO, \"rate alloc: len=%d, max=%d\\n\", l, maxlen); */\n                                                lo = thresh;\n                                                continue;\n                                        }\n\n                                        hi = thresh;\n                                        stable_thresh = thresh;\n                                }\n                        }\n\n                        success = OPJ_TRUE;\n                        goodthresh = stable_thresh == 0? thresh : stable_thresh;\n\n                        opj_t2_destroy(t2);\n                } else {\n                        success = OPJ_TRUE;\n                        goodthresh = min;\n                }\n\n                if (!success) {\n                        return OPJ_FALSE;\n                }\n\n                if(cstr_info) { /* Threshold for Marcela Index */\n                        cstr_info->tile[tcd->tcd_tileno].thresh[layno] = goodthresh;\n                }\n\n                opj_tcd_makelayer(tcd, layno, goodthresh, 1);\n\n                /* fixed_quality */\n                cumdisto[layno] = (layno == 0) ? tcd_tile->distolayer[0] : (cumdisto[layno - 1] + tcd_tile->distolayer[layno]);\n        }\n\n        return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_tcd_init( opj_tcd_t *p_tcd,\n                                           opj_image_t * p_image,\n                                           opj_cp_t * p_cp )\n{\n        p_tcd->image = p_image;\n        p_tcd->cp = p_cp;\n\n        p_tcd->tcd_image->tiles = (opj_tcd_tile_t *) opj_calloc(1,sizeof(opj_tcd_tile_t));\n        if (! p_tcd->tcd_image->tiles) {\n                return OPJ_FALSE;\n        }\n\n        p_tcd->tcd_image->tiles->comps = (opj_tcd_tilecomp_t *) opj_calloc(p_image->numcomps,sizeof(opj_tcd_tilecomp_t));\n        if (! p_tcd->tcd_image->tiles->comps ) {\n                return OPJ_FALSE;\n        }\n\n        p_tcd->tcd_image->tiles->numcomps = p_image->numcomps;\n        p_tcd->tp_pos = p_cp->m_specific_param.m_enc.m_tp_pos;\n\n        return OPJ_TRUE;\n}\n\n/**\nDestroy a previously created TCD handle\n*/\nvoid opj_tcd_destroy(opj_tcd_t *tcd) {\n        if (tcd) {\n                opj_tcd_free_tile(tcd);\n\n                if (tcd->tcd_image) {\n                        opj_free(tcd->tcd_image);\n                        tcd->tcd_image = 00;\n                }\n                opj_free(tcd);\n        }\n}\n\nOPJ_BOOL opj_alloc_tile_component_data(opj_tcd_tilecomp_t *l_tilec)\n{\n\tif ((l_tilec->data == 00) || ((l_tilec->data_size_needed > l_tilec->data_size) && (l_tilec->ownsData == OPJ_FALSE))) {\n\t\tl_tilec->data = (OPJ_INT32 *) opj_malloc(l_tilec->data_size_needed);\n\t\tif (! l_tilec->data ) {\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\t/*fprintf(stderr, \"tAllocate data of tilec (int): %d x OPJ_UINT32n\",l_data_size);*/\n\t\tl_tilec->data_size = l_tilec->data_size_needed;\n\t\tl_tilec->ownsData = OPJ_TRUE;\n\t}\n\telse if (l_tilec->data_size_needed > l_tilec->data_size) {\n\t\tOPJ_INT32 * new_data = (OPJ_INT32 *) opj_realloc(l_tilec->data, l_tilec->data_size_needed);\n\t\t/* opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to handle tile datan\"); */\n\t\t/* fprintf(stderr, \"Not enough memory to handle tile data\"); */\n\t\tif (! new_data) {\n\t\t\topj_free(l_tilec->data);\n\t\t\tl_tilec->data = NULL;\n\t\t\tl_tilec->data_size = 0;\n\t\t\tl_tilec->data_size_needed = 0;\n\t\t\tl_tilec->ownsData = OPJ_FALSE;\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\tl_tilec->data = new_data;\n\t\t/*fprintf(stderr, \"tReallocate data of tilec (int): from %d to %d x OPJ_UINT32n\", l_tilec->data_size, l_data_size);*/\n\t\tl_tilec->data_size = l_tilec->data_size_needed;\n\t\tl_tilec->ownsData = OPJ_TRUE;\n\t}\n\treturn OPJ_TRUE;\n}\n\n/* ----------------------------------------------------------------------- */\n\nstatic INLINE OPJ_BOOL opj_tcd_init_tile(opj_tcd_t *p_tcd, OPJ_UINT32 p_tile_no, OPJ_BOOL isEncoder, OPJ_FLOAT32 fraction, OPJ_SIZE_T sizeof_block)\n{\n\tOPJ_UINT32 (*l_gain_ptr)(OPJ_UINT32) = 00;\n\tOPJ_UINT32 compno, resno, bandno, precno, cblkno;\n\topj_tcp_t * l_tcp = 00;\n\topj_cp_t * l_cp = 00;\n\topj_tcd_tile_t * l_tile = 00;\n\topj_tccp_t *l_tccp = 00;\n\topj_tcd_tilecomp_t *l_tilec = 00;\n\topj_image_comp_t * l_image_comp = 00;\n\topj_tcd_resolution_t *l_res = 00;\n\topj_tcd_band_t *l_band = 00;\n\topj_stepsize_t * l_step_size = 00;\n\topj_tcd_precinct_t *l_current_precinct = 00;\n\topj_image_t *l_image = 00;\n\tOPJ_UINT32 p,q;\n\tOPJ_UINT32 l_level_no;\n\tOPJ_UINT32 l_pdx, l_pdy;\n\tOPJ_UINT32 l_gain;\n\tOPJ_INT32 l_x0b, l_y0b;\n\t/* extent of precincts , top left, bottom right**/\n\tOPJ_INT32 l_tl_prc_x_start, l_tl_prc_y_start, l_br_prc_x_end, l_br_prc_y_end;\n\t/* number of precinct for a resolution */\n\tOPJ_UINT32 l_nb_precincts;\n\t/* room needed to store l_nb_precinct precinct for a resolution */\n\tOPJ_UINT32 l_nb_precinct_size;\n\t/* number of code blocks for a precinct*/\n\tOPJ_UINT32 l_nb_code_blocks;\n\t/* room needed to store l_nb_code_blocks code blocks for a precinct*/\n\tOPJ_UINT32 l_nb_code_blocks_size;\n\t/* size of data for a tile */\n\tOPJ_UINT32 l_data_size;\n\t\n\tl_cp = p_tcd->cp;\n\tl_tcp = &(l_cp->tcps[p_tile_no]);\n\tl_tile = p_tcd->tcd_image->tiles;\n\tl_tccp = l_tcp->tccps;\n\tl_tilec = l_tile->comps;\n\tl_image = p_tcd->image;\n\tl_image_comp = p_tcd->image->comps;\n\t\n\tp = p_tile_no % l_cp->tw;       /* tile coordinates */\n\tq = p_tile_no / l_cp->tw;\n\t/*fprintf(stderr, \"Tile coordinate = %d,%d\\n\", p, q);*/\n\t\n\t/* 4 borders of the tile rescale on the image if necessary */\n\tl_tile->x0 = (OPJ_INT32)opj_uint_max(l_cp->tx0 + p * l_cp->tdx, l_image->x0);\n\tl_tile->y0 = (OPJ_INT32)opj_uint_max(l_cp->ty0 + q * l_cp->tdy, l_image->y0);\n\tl_tile->x1 = (OPJ_INT32)opj_uint_min(l_cp->tx0 + (p + 1) * l_cp->tdx, l_image->x1);\n\tl_tile->y1 = (OPJ_INT32)opj_uint_min(l_cp->ty0 + (q + 1) * l_cp->tdy, l_image->y1);\n\n\t/* testcase 1888.pdf.asan.35.988 */\n\tif (l_tccp->numresolutions == 0) {\n\t\tfprintf(stderr, \"tiles require at least one resolution\\n\");\n\t\treturn OPJ_FALSE;\n\t}\n\t/*fprintf(stderr, \"Tile border = %d,%d,%d,%d\\n\", l_tile->x0, l_tile->y0,l_tile->x1,l_tile->y1);*/\n\t\n\t/*tile->numcomps = image->numcomps; */\n\tfor (compno = 0; compno < l_tile->numcomps; ++compno) {\n\t\t/*fprintf(stderr, \"compno = %d/%d\\n\", compno, l_tile->numcomps);*/\n\t\tl_image_comp->resno_decoded = 0;\n\t\t/* border of each l_tile component (global) */\n\t\tl_tilec->x0 = opj_int_ceildiv(l_tile->x0, (OPJ_INT32)l_image_comp->dx);\n\t\tl_tilec->y0 = opj_int_ceildiv(l_tile->y0, (OPJ_INT32)l_image_comp->dy);\n\t\tl_tilec->x1 = opj_int_ceildiv(l_tile->x1, (OPJ_INT32)l_image_comp->dx);\n\t\tl_tilec->y1 = opj_int_ceildiv(l_tile->y1, (OPJ_INT32)l_image_comp->dy);\n\t\t/*fprintf(stderr, \"\\tTile compo border = %d,%d,%d,%d\\n\", l_tilec->x0, l_tilec->y0,l_tilec->x1,l_tilec->y1);*/\n\t\t\n\t\t/* compute l_data_size with overflow check */\n\t\tl_data_size = (OPJ_UINT32)(l_tilec->x1 - l_tilec->x0);\n\t\tif ((((OPJ_UINT32)-1) / l_data_size) < (OPJ_UINT32)(l_tilec->y1 - l_tilec->y0)) {\n\t\t\t/* TODO event */\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\tl_data_size = l_data_size * (OPJ_UINT32)(l_tilec->y1 - l_tilec->y0);\n\t\t\n\t\tif ((((OPJ_UINT32)-1) / (OPJ_UINT32)sizeof(OPJ_UINT32)) < l_data_size) {\n\t\t\t/* TODO event */\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\tl_data_size = l_data_size * (OPJ_UINT32)sizeof(OPJ_UINT32);\n\t\tl_tilec->numresolutions = l_tccp->numresolutions;\n\t\tif (l_tccp->numresolutions < l_cp->m_specific_param.m_dec.m_reduce) {\n\t\t\tl_tilec->minimum_num_resolutions = 1;\n\t\t}\n\t\telse {\n\t\t\tl_tilec->minimum_num_resolutions = l_tccp->numresolutions - l_cp->m_specific_param.m_dec.m_reduce;\n\t\t}\n\t\t\n\t\tl_tilec->data_size_needed = l_data_size;\n\t\tif (p_tcd->m_is_decoder && !opj_alloc_tile_component_data(l_tilec)) {\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\t\n\t\tl_data_size = l_tilec->numresolutions * (OPJ_UINT32)sizeof(opj_tcd_resolution_t);\n\t\t\n\t\tif (l_tilec->resolutions == 00) {\n\t\t\tl_tilec->resolutions = (opj_tcd_resolution_t *) opj_malloc(l_data_size);\n\t\t\tif (! l_tilec->resolutions ) {\n\t\t\t\treturn OPJ_FALSE;\n\t\t\t}\n\t\t\t/*fprintf(stderr, \"\\tAllocate resolutions of tilec (opj_tcd_resolution_t): %d\\n\",l_data_size);*/\n\t\t\tl_tilec->resolutions_size = l_data_size;\n\t\t\tmemset(l_tilec->resolutions,0,l_data_size);\n\t\t}\n\t\telse if (l_data_size > l_tilec->resolutions_size) {\n\t\t\topj_tcd_resolution_t* new_resolutions = (opj_tcd_resolution_t *) opj_realloc(l_tilec->resolutions, l_data_size);\n\t\t\tif (! new_resolutions) {\n\t\t\t\t/* opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to tile resolutions\\n\");                                                                                         */\n\t\t\t\tfprintf(stderr, \"Not enough memory to tile resolutions\\n\");\n\t\t\t\topj_free(l_tilec->resolutions);\n\t\t\t\tl_tilec->resolutions = NULL;\n\t\t\t\tl_tilec->resolutions_size = 0;\n\t\t\t\treturn OPJ_FALSE;\n\t\t\t}\n\t\t\tl_tilec->resolutions = new_resolutions;\n\t\t\t/*fprintf(stderr, \"\\tReallocate data of tilec (int): from %d to %d x OPJ_UINT32\\n\", l_tilec->resolutions_size, l_data_size);*/\n\t\t\tmemset(((OPJ_BYTE*) l_tilec->resolutions)+l_tilec->resolutions_size,0,l_data_size - l_tilec->resolutions_size);\n\t\t\tl_tilec->resolutions_size = l_data_size;\n\t\t}\n\t\t\n\t\tl_level_no = l_tilec->numresolutions - 1;\n\t\tl_res = l_tilec->resolutions;\n\t\tl_step_size = l_tccp->stepsizes;\n\t\tif (l_tccp->qmfbid == 0) {\n\t\t\tl_gain_ptr = &opj_dwt_getgain_real;\n\t\t}\n\t\telse {\n\t\t\tl_gain_ptr  = &opj_dwt_getgain;\n\t\t}\n\t\t/*fprintf(stderr, \"\\tlevel_no=%d\\n\",l_level_no);*/\n\t\t\n\t\tfor (resno = 0; resno < l_tilec->numresolutions; ++resno) {\n\t\t\t/*fprintf(stderr, \"\\t\\tresno = %d/%d\\n\", resno, l_tilec->numresolutions);*/\n\t\t\tOPJ_INT32 tlcbgxstart, tlcbgystart /*, brcbgxend, brcbgyend*/;\n\t\t\tOPJ_UINT32 cbgwidthexpn, cbgheightexpn;\n\t\t\tOPJ_UINT32 cblkwidthexpn, cblkheightexpn;\n\t\t\t\n\t\t\t/* border for each resolution level (global) */\n\t\t\tl_res->x0 = opj_int_ceildivpow2(l_tilec->x0, (OPJ_INT32)l_level_no);\n\t\t\tl_res->y0 = opj_int_ceildivpow2(l_tilec->y0, (OPJ_INT32)l_level_no);\n\t\t\tl_res->x1 = opj_int_ceildivpow2(l_tilec->x1, (OPJ_INT32)l_level_no);\n\t\t\tl_res->y1 = opj_int_ceildivpow2(l_tilec->y1, (OPJ_INT32)l_level_no);\n\t\t\t/*fprintf(stderr, \"\\t\\t\\tres_x0= %d, res_y0 =%d, res_x1=%d, res_y1=%d\\n\", l_res->x0, l_res->y0, l_res->x1, l_res->y1);*/\n\t\t\t/* p. 35, table A-23, ISO/IEC FDIS154444-1 : 2000 (18 august 2000) */\n\t\t\tl_pdx = l_tccp->prcw[resno];\n\t\t\tl_pdy = l_tccp->prch[resno];\n\t\t\t/*fprintf(stderr, \"\\t\\t\\tpdx=%d, pdy=%d\\n\", l_pdx, l_pdy);*/\n\t\t\t/* p. 64, B.6, ISO/IEC FDIS15444-1 : 2000 (18 august 2000)  */\n\t\t\tl_tl_prc_x_start = opj_int_floordivpow2(l_res->x0, (OPJ_INT32)l_pdx) << l_pdx;\n\t\t\tl_tl_prc_y_start = opj_int_floordivpow2(l_res->y0, (OPJ_INT32)l_pdy) << l_pdy;\n\t\t\tl_br_prc_x_end = opj_int_ceildivpow2(l_res->x1, (OPJ_INT32)l_pdx) << l_pdx;\n\t\t\tl_br_prc_y_end = opj_int_ceildivpow2(l_res->y1, (OPJ_INT32)l_pdy) << l_pdy;\n\t\t\t/*fprintf(stderr, \"\\t\\t\\tprc_x_start=%d, prc_y_start=%d, br_prc_x_end=%d, br_prc_y_end=%d \\n\", l_tl_prc_x_start, l_tl_prc_y_start, l_br_prc_x_end ,l_br_prc_y_end );*/\n\t\t\t\n\t\t\tl_res->pw = (l_res->x0 == l_res->x1) ? 0 : (OPJ_UINT32)((l_br_prc_x_end - l_tl_prc_x_start) >> l_pdx);\n\t\t\tl_res->ph = (l_res->y0 == l_res->y1) ? 0 : (OPJ_UINT32)((l_br_prc_y_end - l_tl_prc_y_start) >> l_pdy);\n\t\t\t/*fprintf(stderr, \"\\t\\t\\tres_pw=%d, res_ph=%d\\n\", l_res->pw, l_res->ph );*/\n\t\t\t\n\t\t\tl_nb_precincts = l_res->pw * l_res->ph;\n\t\t\tl_nb_precinct_size = l_nb_precincts * (OPJ_UINT32)sizeof(opj_tcd_precinct_t);\n\t\t\tif (resno == 0) {\n\t\t\t\ttlcbgxstart = l_tl_prc_x_start;\n\t\t\t\ttlcbgystart = l_tl_prc_y_start;\n\t\t\t\t/*brcbgxend = l_br_prc_x_end;*/\n\t\t\t\t/* brcbgyend = l_br_prc_y_end;*/\n\t\t\t\tcbgwidthexpn = l_pdx;\n\t\t\t\tcbgheightexpn = l_pdy;\n\t\t\t\tl_res->numbands = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttlcbgxstart = opj_int_ceildivpow2(l_tl_prc_x_start, 1);\n\t\t\t\ttlcbgystart = opj_int_ceildivpow2(l_tl_prc_y_start, 1);\n\t\t\t\t/*brcbgxend = opj_int_ceildivpow2(l_br_prc_x_end, 1);*/\n\t\t\t\t/*brcbgyend = opj_int_ceildivpow2(l_br_prc_y_end, 1);*/\n\t\t\t\tcbgwidthexpn = l_pdx - 1;\n\t\t\t\tcbgheightexpn = l_pdy - 1;\n\t\t\t\tl_res->numbands = 3;\n\t\t\t}\n\t\t\t\n\t\t\tcblkwidthexpn = opj_uint_min(l_tccp->cblkw, cbgwidthexpn);\n\t\t\tcblkheightexpn = opj_uint_min(l_tccp->cblkh, cbgheightexpn);\n\t\t\tl_band = l_res->bands;\n\t\t\t\n\t\t\tfor (bandno = 0; bandno < l_res->numbands; ++bandno) {\n\t\t\t\tOPJ_INT32 numbps;\n\t\t\t\t/*fprintf(stderr, \"\\t\\t\\tband_no=%d/%d\\n\", bandno, l_res->numbands );*/\n\t\t\t\t\n\t\t\t\tif (resno == 0) {\n\t\t\t\t\tl_band->bandno = 0 ;\n\t\t\t\t\tl_band->x0 = opj_int_ceildivpow2(l_tilec->x0, (OPJ_INT32)l_level_no);\n\t\t\t\t\tl_band->y0 = opj_int_ceildivpow2(l_tilec->y0, (OPJ_INT32)l_level_no);\n\t\t\t\t\tl_band->x1 = opj_int_ceildivpow2(l_tilec->x1, (OPJ_INT32)l_level_no);\n\t\t\t\t\tl_band->y1 = opj_int_ceildivpow2(l_tilec->y1, (OPJ_INT32)l_level_no);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tl_band->bandno = bandno + 1;\n\t\t\t\t\t/* x0b = 1 if bandno = 1 or 3 */\n\t\t\t\t\tl_x0b = l_band->bandno&1;\n\t\t\t\t\t/* y0b = 1 if bandno = 2 or 3 */\n\t\t\t\t\tl_y0b = (OPJ_INT32)((l_band->bandno)>>1);\n\t\t\t\t\t/* l_band border (global) */\n\t\t\t\t\tl_band->x0 = opj_int_ceildivpow2(l_tilec->x0 - (1 << l_level_no) * l_x0b, (OPJ_INT32)(l_level_no + 1));\n\t\t\t\t\tl_band->y0 = opj_int_ceildivpow2(l_tilec->y0 - (1 << l_level_no) * l_y0b, (OPJ_INT32)(l_level_no + 1));\n\t\t\t\t\tl_band->x1 = opj_int_ceildivpow2(l_tilec->x1 - (1 << l_level_no) * l_x0b, (OPJ_INT32)(l_level_no + 1));\n\t\t\t\t\tl_band->y1 = opj_int_ceildivpow2(l_tilec->y1 - (1 << l_level_no) * l_y0b, (OPJ_INT32)(l_level_no + 1));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/** avoid an if with storing function pointer */\n\t\t\t\tl_gain = (*l_gain_ptr) (l_band->bandno);\n\t\t\t\tnumbps = (OPJ_INT32)(l_image_comp->prec + l_gain);\n\t\t\t\tl_band->stepsize = (OPJ_FLOAT32)(((1.0 + l_step_size->mant / 2048.0) * pow(2.0, (OPJ_INT32) (numbps - l_step_size->expn)))) * fraction;\n\t\t\t\tl_band->numbps = l_step_size->expn + (OPJ_INT32)l_tccp->numgbits - 1;      /* WHY -1 ? */\n\t\t\t\t\n\t\t\t\tif (! l_band->precincts) {\n\t\t\t\t\tl_band->precincts = (opj_tcd_precinct_t *) opj_malloc( /*3 * */ l_nb_precinct_size);\n\t\t\t\t\tif (! l_band->precincts) {\n\t\t\t\t\t\treturn OPJ_FALSE;\n\t\t\t\t\t}\n\t\t\t\t\t/*fprintf(stderr, \"\\t\\t\\t\\tAllocate precincts of a band (opj_tcd_precinct_t): %d\\n\",l_nb_precinct_size);     */\n\t\t\t\t\tmemset(l_band->precincts,0,l_nb_precinct_size);\n\t\t\t\t\tl_band->precincts_data_size = l_nb_precinct_size;\n\t\t\t\t}\n\t\t\t\telse if (l_band->precincts_data_size < l_nb_precinct_size) {\n\t\t\t\t\t\n\t\t\t\t\topj_tcd_precinct_t * new_precincts = (opj_tcd_precinct_t *) opj_realloc(l_band->precincts,/*3 * */ l_nb_precinct_size);\n\t\t\t\t\tif (! new_precincts) {\n\t\t\t\t\t\t/* opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to handle band precints\\n\");                                                                    */\n\t\t\t\t\t\tfprintf(stderr, \"Not enough memory to handle band precints\\n\");\n\t\t\t\t\t\topj_free(l_band->precincts);\n\t\t\t\t\t\tl_band->precincts = NULL;\n\t\t\t\t\t\tl_band->precincts_data_size = 0;\n\t\t\t\t\t\treturn OPJ_FALSE;\n\t\t\t\t\t}\n\t\t\t\t\tl_band->precincts = new_precincts;\n\t\t\t\t\t/*fprintf(stderr, \"\\t\\t\\t\\tReallocate precincts of a band (opj_tcd_precinct_t): from %d to %d\\n\",l_band->precincts_data_size, l_nb_precinct_size);*/\n\t\t\t\t\tmemset(((OPJ_BYTE *) l_band->precincts) + l_band->precincts_data_size,0,l_nb_precinct_size - l_band->precincts_data_size);\n\t\t\t\t\tl_band->precincts_data_size = l_nb_precinct_size;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tl_current_precinct = l_band->precincts;\n\t\t\t\tfor (precno = 0; precno < l_nb_precincts; ++precno) {\n\t\t\t\t\tOPJ_INT32 tlcblkxstart, tlcblkystart, brcblkxend, brcblkyend;\n\t\t\t\t\tOPJ_INT32 cbgxstart = tlcbgxstart + (OPJ_INT32)(precno % l_res->pw) * (1 << cbgwidthexpn);\n\t\t\t\t\tOPJ_INT32 cbgystart = tlcbgystart + (OPJ_INT32)(precno / l_res->pw) * (1 << cbgheightexpn);\n\t\t\t\t\tOPJ_INT32 cbgxend = cbgxstart + (1 << cbgwidthexpn);\n\t\t\t\t\tOPJ_INT32 cbgyend = cbgystart + (1 << cbgheightexpn);\n\t\t\t\t\t/*fprintf(stderr, \"\\t precno=%d; bandno=%d, resno=%d; compno=%d\\n\", precno, bandno , resno, compno);*/\n\t\t\t\t\t/*fprintf(stderr, \"\\t tlcbgxstart(=%d) + (precno(=%d) percent res->pw(=%d)) * (1 << cbgwidthexpn(=%d)) \\n\",tlcbgxstart,precno,l_res->pw,cbgwidthexpn);*/\n\t\t\t\t\t\n\t\t\t\t\t/* precinct size (global) */\n\t\t\t\t\t/*fprintf(stderr, \"\\t cbgxstart=%d, l_band->x0 = %d \\n\",cbgxstart, l_band->x0);*/\n\t\t\t\t\t\n\t\t\t\t\tl_current_precinct->x0 = opj_int_max(cbgxstart, l_band->x0);\n\t\t\t\t\tl_current_precinct->y0 = opj_int_max(cbgystart, l_band->y0);\n\t\t\t\t\tl_current_precinct->x1 = opj_int_min(cbgxend, l_band->x1);\n\t\t\t\t\tl_current_precinct->y1 = opj_int_min(cbgyend, l_band->y1);\n\t\t\t\t\t/*fprintf(stderr, \"\\t prc_x0=%d; prc_y0=%d, prc_x1=%d; prc_y1=%d\\n\",l_current_precinct->x0, l_current_precinct->y0 ,l_current_precinct->x1, l_current_precinct->y1);*/\n\t\t\t\t\t\n\t\t\t\t\ttlcblkxstart = opj_int_floordivpow2(l_current_precinct->x0, (OPJ_INT32)cblkwidthexpn) << cblkwidthexpn;\n\t\t\t\t\t/*fprintf(stderr, \"\\t tlcblkxstart =%d\\n\",tlcblkxstart );*/\n\t\t\t\t\ttlcblkystart = opj_int_floordivpow2(l_current_precinct->y0, (OPJ_INT32)cblkheightexpn) << cblkheightexpn;\n\t\t\t\t\t/*fprintf(stderr, \"\\t tlcblkystart =%d\\n\",tlcblkystart );*/\n\t\t\t\t\tbrcblkxend = opj_int_ceildivpow2(l_current_precinct->x1, (OPJ_INT32)cblkwidthexpn) << cblkwidthexpn;\n\t\t\t\t\t/*fprintf(stderr, \"\\t brcblkxend =%d\\n\",brcblkxend );*/\n\t\t\t\t\tbrcblkyend = opj_int_ceildivpow2(l_current_precinct->y1, (OPJ_INT32)cblkheightexpn) << cblkheightexpn;\n\t\t\t\t\t/*fprintf(stderr, \"\\t brcblkyend =%d\\n\",brcblkyend );*/\n\t\t\t\t\tl_current_precinct->cw = (OPJ_UINT32)((brcblkxend - tlcblkxstart) >> cblkwidthexpn);\n\t\t\t\t\tl_current_precinct->ch = (OPJ_UINT32)((brcblkyend - tlcblkystart) >> cblkheightexpn);\n\t\t\t\t\t\n\t\t\t\t\tl_nb_code_blocks = l_current_precinct->cw * l_current_precinct->ch;\n\t\t\t\t\t/*fprintf(stderr, \"\\t\\t\\t\\t precinct_cw = %d x recinct_ch = %d\\n\",l_current_precinct->cw, l_current_precinct->ch);      */\n\t\t\t\t\tl_nb_code_blocks_size = l_nb_code_blocks * (OPJ_UINT32)sizeof_block;\n\t\t\t\t\t\n\t\t\t\t\tif (! l_current_precinct->cblks.blocks) {\n\t\t\t\t\t\tl_current_precinct->cblks.blocks = opj_malloc(l_nb_code_blocks_size);\n\t\t\t\t\t\tif (! l_current_precinct->cblks.blocks ) {\n\t\t\t\t\t\t\treturn OPJ_FALSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/*fprintf(stderr, \"\\t\\t\\t\\tAllocate cblks of a precinct (opj_tcd_cblk_dec_t): %d\\n\",l_nb_code_blocks_size);*/\n\t\t\t\t\t\t\n\t\t\t\t\t\tmemset(l_current_precinct->cblks.blocks,0,l_nb_code_blocks_size);\n\t\t\t\t\t\t\n\t\t\t\t\t\tl_current_precinct->block_size = l_nb_code_blocks_size;\n\t\t\t\t\t}\n\t\t\t\t\telse if (l_nb_code_blocks_size > l_current_precinct->block_size) {\n\t\t\t\t\t\tvoid *new_blocks = opj_realloc(l_current_precinct->cblks.blocks, l_nb_code_blocks_size);\n\t\t\t\t\t\tif (! new_blocks) {\n\t\t\t\t\t\t\topj_free(l_current_precinct->cblks.blocks);\n\t\t\t\t\t\t\tl_current_precinct->cblks.blocks = NULL;\n\t\t\t\t\t\t\tl_current_precinct->block_size = 0;\n\t\t\t\t\t\t\t/* opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory for current precinct codeblock element\\n\");                                              */\n\t\t\t\t\t\t\tfprintf(stderr, \"Not enough memory for current precinct codeblock element\\n\");\n\t\t\t\t\t\t\treturn OPJ_FALSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tl_current_precinct->cblks.blocks = new_blocks;\n\t\t\t\t\t\t/*fprintf(stderr, \"\\t\\t\\t\\tReallocate cblks of a precinct (opj_tcd_cblk_dec_t): from %d to %d\\n\",l_current_precinct->block_size, l_nb_code_blocks_size);     */\n\t\t\t\t\t\t\n\t\t\t\t\t\tmemset(((OPJ_BYTE *) l_current_precinct->cblks.blocks) + l_current_precinct->block_size\n\t\t\t\t\t\t\t\t\t ,0\n\t\t\t\t\t\t\t\t\t ,l_nb_code_blocks_size - l_current_precinct->block_size);\n\t\t\t\t\t\t\n\t\t\t\t\t\tl_current_precinct->block_size = l_nb_code_blocks_size;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (! l_current_precinct->incltree) {\n\t\t\t\t\t\tl_current_precinct->incltree = opj_tgt_create(l_current_precinct->cw,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tl_current_precinct->ch);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tl_current_precinct->incltree = opj_tgt_init(l_current_precinct->incltree,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tl_current_precinct->cw,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tl_current_precinct->ch);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (! l_current_precinct->incltree)     {\n\t\t\t\t\t\tfprintf(stderr, \"WARNING: No incltree created.\\n\");\n\t\t\t\t\t\t/*return OPJ_FALSE;*/\n\t\t\t\t\t}\n\n\t\t\t\t\tif (! l_current_precinct->imsbtree) {\n\t\t\t\t\t\tl_current_precinct->imsbtree = opj_tgt_create(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tl_current_precinct->cw,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tl_current_precinct->ch);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tl_current_precinct->imsbtree = opj_tgt_init(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tl_current_precinct->imsbtree,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tl_current_precinct->cw,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tl_current_precinct->ch);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (! l_current_precinct->imsbtree) {\n\t\t\t\t\t\tfprintf(stderr, \"WARNING: No imsbtree created.\\n\");\n\t\t\t\t\t\t/*return OPJ_FALSE;*/\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (cblkno = 0; cblkno < l_nb_code_blocks; ++cblkno) {\n\t\t\t\t\t\tOPJ_INT32 cblkxstart = tlcblkxstart + (OPJ_INT32)(cblkno % l_current_precinct->cw) * (1 << cblkwidthexpn);\n\t\t\t\t\t\tOPJ_INT32 cblkystart = tlcblkystart + (OPJ_INT32)(cblkno / l_current_precinct->cw) * (1 << cblkheightexpn);\n\t\t\t\t\t\tOPJ_INT32 cblkxend = cblkxstart + (1 << cblkwidthexpn);\n\t\t\t\t\t\tOPJ_INT32 cblkyend = cblkystart + (1 << cblkheightexpn);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (isEncoder) {\n\t\t\t\t\t\t\topj_tcd_cblk_enc_t* l_code_block = l_current_precinct->cblks.enc + cblkno;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (! opj_tcd_code_block_enc_allocate(l_code_block)) {\n\t\t\t\t\t\t\t\treturn OPJ_FALSE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/* code-block size (global) */\n\t\t\t\t\t\t\tl_code_block->x0 = opj_int_max(cblkxstart, l_current_precinct->x0);\n\t\t\t\t\t\t\tl_code_block->y0 = opj_int_max(cblkystart, l_current_precinct->y0);\n\t\t\t\t\t\t\tl_code_block->x1 = opj_int_min(cblkxend, l_current_precinct->x1);\n\t\t\t\t\t\t\tl_code_block->y1 = opj_int_min(cblkyend, l_current_precinct->y1);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (! opj_tcd_code_block_enc_allocate_data(l_code_block)) {\n\t\t\t\t\t\t\t\treturn OPJ_FALSE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\topj_tcd_cblk_dec_t* l_code_block = l_current_precinct->cblks.dec + cblkno;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (! opj_tcd_code_block_dec_allocate(l_code_block)) {\n\t\t\t\t\t\t\t\treturn OPJ_FALSE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/* code-block size (global) */\n\t\t\t\t\t\t\tl_code_block->x0 = opj_int_max(cblkxstart, l_current_precinct->x0);\n\t\t\t\t\t\t\tl_code_block->y0 = opj_int_max(cblkystart, l_current_precinct->y0);\n\t\t\t\t\t\t\tl_code_block->x1 = opj_int_min(cblkxend, l_current_precinct->x1);\n\t\t\t\t\t\t\tl_code_block->y1 = opj_int_min(cblkyend, l_current_precinct->y1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t++l_current_precinct;\n\t\t\t\t} /* precno */\n\t\t\t\t++l_band;\n\t\t\t\t++l_step_size;\n\t\t\t} /* bandno */\n\t\t\t++l_res;\n\t\t\t--l_level_no;\n\t\t} /* resno */\n\t\t++l_tccp;\n\t\t++l_tilec;\n\t\t++l_image_comp;\n\t} /* compno */\n\treturn OPJ_TRUE;\n}\n\nOPJ_BOOL opj_tcd_init_encode_tile (opj_tcd_t *p_tcd, OPJ_UINT32 p_tile_no)\n{\n\treturn opj_tcd_init_tile(p_tcd, p_tile_no, OPJ_TRUE, 1.0F, sizeof(opj_tcd_cblk_enc_t));\n}\n\nOPJ_BOOL opj_tcd_init_decode_tile (opj_tcd_t *p_tcd, OPJ_UINT32 p_tile_no)\n{\n\treturn opj_tcd_init_tile(p_tcd, p_tile_no, OPJ_FALSE, 0.5F, sizeof(opj_tcd_cblk_dec_t));\n}\n\n/**\n * Allocates memory for an encoding code block (but not data memory).\n */\nstatic OPJ_BOOL opj_tcd_code_block_enc_allocate (opj_tcd_cblk_enc_t * p_code_block)\n{\n\tif (! p_code_block->layers) {\n\t\t/* no memset since data */\n\t\tp_code_block->layers = (opj_tcd_layer_t*) opj_calloc(100, sizeof(opj_tcd_layer_t));\n\t\tif (! p_code_block->layers) {\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t}\n\tif (! p_code_block->passes) {\n\t\tp_code_block->passes = (opj_tcd_pass_t*) opj_calloc(100, sizeof(opj_tcd_pass_t));\n\t\tif (! p_code_block->passes) {\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t}\n\treturn OPJ_TRUE;\n}\n\n/**\n * Allocates data memory for an encoding code block.\n */\nstatic OPJ_BOOL opj_tcd_code_block_enc_allocate_data (opj_tcd_cblk_enc_t * p_code_block)\n{\n\tOPJ_UINT32 l_data_size;\n\t\n\tl_data_size = (OPJ_UINT32)((p_code_block->x1 - p_code_block->x0) * (p_code_block->y1 - p_code_block->y0) * (OPJ_INT32)sizeof(OPJ_UINT32));\n\t\n\tif (l_data_size > p_code_block->data_size) {\n\t\tif (p_code_block->data) {\n\t\t\topj_free(p_code_block->data - 1); /* again, why -1 */\n\t\t}\n\t\tp_code_block->data = (OPJ_BYTE*) opj_malloc(l_data_size);\n\t\tif(! p_code_block->data) {\n\t\t\tp_code_block->data_size = 0U;\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\tp_code_block->data_size = l_data_size;\n\t\t\n\t\tp_code_block->data[0] = 0;\n\t\tp_code_block->data+=1;   /*why +1 ?*/\n\t}\n\treturn OPJ_TRUE;\n}\n\n/**\n * Allocates memory for a decoding code block.\n */\nstatic OPJ_BOOL opj_tcd_code_block_dec_allocate (opj_tcd_cblk_dec_t * p_code_block)\n{\n        if (! p_code_block->data) {\n\n                p_code_block->data = (OPJ_BYTE*) opj_malloc(OPJ_J2K_DEFAULT_CBLK_DATA_SIZE);\n                if (! p_code_block->data) {\n                        return OPJ_FALSE;\n                }\n                p_code_block->data_max_size = OPJ_J2K_DEFAULT_CBLK_DATA_SIZE;\n                /*fprintf(stderr, \"Allocate 8192 elements of code_block->data\\n\");*/\n\n                p_code_block->segs = (opj_tcd_seg_t *) opj_calloc(OPJ_J2K_DEFAULT_NB_SEGS,sizeof(opj_tcd_seg_t));\n                if (! p_code_block->segs) {\n                        return OPJ_FALSE;\n                }\n                /*fprintf(stderr, \"Allocate %d elements of code_block->data\\n\", OPJ_J2K_DEFAULT_NB_SEGS * sizeof(opj_tcd_seg_t));*/\n\n                p_code_block->m_current_max_segs = OPJ_J2K_DEFAULT_NB_SEGS;\n                /*fprintf(stderr, \"m_current_max_segs of code_block->data = %d\\n\", p_code_block->m_current_max_segs);*/\n        } else {\n\t\t\t\t\t/* sanitize */\n\t\t\t\t\tOPJ_BYTE* l_data = p_code_block->data;\n\t\t\t\t\tOPJ_UINT32 l_data_max_size = p_code_block->data_max_size;\n\t\t\t\t\topj_tcd_seg_t * l_segs = p_code_block->segs;\n\t\t\t\t\tOPJ_UINT32 l_current_max_segs = p_code_block->m_current_max_segs;\n\n\t\t\t\t\tmemset(p_code_block, 0, sizeof(opj_tcd_cblk_dec_t));\n\t\t\t\t\tp_code_block->data = l_data;\n\t\t\t\t\tp_code_block->data_max_size = l_data_max_size;\n\t\t\t\t\tp_code_block->segs = l_segs;\n\t\t\t\t\tp_code_block->m_current_max_segs = l_current_max_segs;\n\t\t\t\t}\n\n        return OPJ_TRUE;\n}\n\nOPJ_UINT32 opj_tcd_get_decoded_tile_size ( opj_tcd_t *p_tcd )\n{\n        OPJ_UINT32 i;\n        OPJ_UINT32 l_data_size = 0;\n        opj_image_comp_t * l_img_comp = 00;\n        opj_tcd_tilecomp_t * l_tile_comp = 00;\n        opj_tcd_resolution_t * l_res = 00;\n        OPJ_UINT32 l_size_comp, l_remaining;\n\n        l_tile_comp = p_tcd->tcd_image->tiles->comps;\n        l_img_comp = p_tcd->image->comps;\n\n        for (i=0;i<p_tcd->image->numcomps;++i) {\n                l_size_comp = l_img_comp->prec >> 3; /*(/ 8)*/\n                l_remaining = l_img_comp->prec & 7;  /* (%8) */\n\n                if(l_remaining) {\n                        ++l_size_comp;\n                }\n\n                if (l_size_comp == 3) {\n                        l_size_comp = 4;\n                }\n\n                l_res = l_tile_comp->resolutions + l_tile_comp->minimum_num_resolutions - 1;\n                l_data_size += l_size_comp * (OPJ_UINT32)((l_res->x1 - l_res->x0) * (l_res->y1 - l_res->y0));\n                ++l_img_comp;\n                ++l_tile_comp;\n        }\n\n        return l_data_size;\n}\n\nOPJ_BOOL opj_tcd_encode_tile(   opj_tcd_t *p_tcd,\n                                                        OPJ_UINT32 p_tile_no,\n                                                        OPJ_BYTE *p_dest,\n                                                        OPJ_UINT32 * p_data_written,\n                                                        OPJ_UINT32 p_max_length,\n                                                        opj_codestream_info_t *p_cstr_info)\n{\n\n        if (p_tcd->cur_tp_num == 0) {\n\n                p_tcd->tcd_tileno = p_tile_no;\n                p_tcd->tcp = &p_tcd->cp->tcps[p_tile_no];\n\n                /* INDEX >> \"Precinct_nb_X et Precinct_nb_Y\" */\n                if(p_cstr_info)  {\n                        OPJ_UINT32 l_num_packs = 0;\n                        OPJ_UINT32 i;\n                        opj_tcd_tilecomp_t *l_tilec_idx = &p_tcd->tcd_image->tiles->comps[0];        /* based on component 0 */\n                        opj_tccp_t *l_tccp = p_tcd->tcp->tccps; /* based on component 0 */\n\n                        for (i = 0; i < l_tilec_idx->numresolutions; i++) {\n                                opj_tcd_resolution_t *l_res_idx = &l_tilec_idx->resolutions[i];\n\n                                p_cstr_info->tile[p_tile_no].pw[i] = (int)l_res_idx->pw;\n                                p_cstr_info->tile[p_tile_no].ph[i] = (int)l_res_idx->ph;\n\n                                l_num_packs += l_res_idx->pw * l_res_idx->ph;\n                                p_cstr_info->tile[p_tile_no].pdx[i] = (int)l_tccp->prcw[i];\n                                p_cstr_info->tile[p_tile_no].pdy[i] = (int)l_tccp->prch[i];\n                        }\n                        p_cstr_info->tile[p_tile_no].packet = (opj_packet_info_t*) opj_calloc((size_t)p_cstr_info->numcomps * (size_t)p_cstr_info->numlayers * l_num_packs, sizeof(opj_packet_info_t));\n                        if (!p_cstr_info->tile[p_tile_no].packet) {\n                                /* FIXME event manager error callback */\n                                return OPJ_FALSE;\n                        }\n                }\n                /* << INDEX */\n\n                /* FIXME _ProfStart(PGROUP_DC_SHIFT); */\n                /*---------------TILE-------------------*/\n                if (! opj_tcd_dc_level_shift_encode(p_tcd)) {\n                        return OPJ_FALSE;\n                }\n                /* FIXME _ProfStop(PGROUP_DC_SHIFT); */\n\n                /* FIXME _ProfStart(PGROUP_MCT); */\n                if (! opj_tcd_mct_encode(p_tcd)) {\n                        return OPJ_FALSE;\n                }\n                /* FIXME _ProfStop(PGROUP_MCT); */\n\n                /* FIXME _ProfStart(PGROUP_DWT); */\n                if (! opj_tcd_dwt_encode(p_tcd)) {\n                        return OPJ_FALSE;\n                }\n                /* FIXME  _ProfStop(PGROUP_DWT); */\n\n                /* FIXME  _ProfStart(PGROUP_T1); */\n                if (! opj_tcd_t1_encode(p_tcd)) {\n                        return OPJ_FALSE;\n                }\n                /* FIXME _ProfStop(PGROUP_T1); */\n\n                /* FIXME _ProfStart(PGROUP_RATE); */\n                if (! opj_tcd_rate_allocate_encode(p_tcd,p_dest,p_max_length,p_cstr_info)) {\n                        return OPJ_FALSE;\n                }\n                /* FIXME _ProfStop(PGROUP_RATE); */\n\n        }\n        /*--------------TIER2------------------*/\n\n        /* INDEX */\n        if (p_cstr_info) {\n                p_cstr_info->index_write = 1;\n        }\n        /* FIXME _ProfStart(PGROUP_T2); */\n\n        if (! opj_tcd_t2_encode(p_tcd,p_dest,p_data_written,p_max_length,p_cstr_info)) {\n                return OPJ_FALSE;\n        }\n        /* FIXME _ProfStop(PGROUP_T2); */\n\n        /*---------------CLEAN-------------------*/\n\n        return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_tcd_decode_tile(   opj_tcd_t *p_tcd,\n                                OPJ_BYTE *p_src,\n                                OPJ_UINT32 p_max_length,\n                                OPJ_UINT32 p_tile_no,\n                                opj_codestream_index_t *p_cstr_index\n                                )\n{\n        OPJ_UINT32 l_data_read;\n        p_tcd->tcd_tileno = p_tile_no;\n        p_tcd->tcp = &(p_tcd->cp->tcps[p_tile_no]);\n\n#ifdef TODO_MSD /* FIXME */\n        /* INDEX >>  */\n        if(p_cstr_info) {\n                OPJ_UINT32 resno, compno, numprec = 0;\n                for (compno = 0; compno < (OPJ_UINT32) p_cstr_info->numcomps; compno++) {\n                        opj_tcp_t *tcp = &p_tcd->cp->tcps[0];\n                        opj_tccp_t *tccp = &tcp->tccps[compno];\n                        opj_tcd_tilecomp_t *tilec_idx = &p_tcd->tcd_image->tiles->comps[compno];\n                        for (resno = 0; resno < tilec_idx->numresolutions; resno++) {\n                                opj_tcd_resolution_t *res_idx = &tilec_idx->resolutions[resno];\n                                p_cstr_info->tile[p_tile_no].pw[resno] = res_idx->pw;\n                                p_cstr_info->tile[p_tile_no].ph[resno] = res_idx->ph;\n                                numprec += res_idx->pw * res_idx->ph;\n                                p_cstr_info->tile[p_tile_no].pdx[resno] = tccp->prcw[resno];\n                                p_cstr_info->tile[p_tile_no].pdy[resno] = tccp->prch[resno];\n                        }\n                }\n                p_cstr_info->tile[p_tile_no].packet = (opj_packet_info_t *) opj_malloc(p_cstr_info->numlayers * numprec * sizeof(opj_packet_info_t));\n                p_cstr_info->packno = 0;\n        }\n        /* << INDEX */\n#endif\n\n        /*--------------TIER2------------------*/\n        /* FIXME _ProfStart(PGROUP_T2); */\n        l_data_read = 0;\n        if (! opj_tcd_t2_decode(p_tcd, p_src, &l_data_read, p_max_length, p_cstr_index))\n        {\n                return OPJ_FALSE;\n        }\n        /* FIXME _ProfStop(PGROUP_T2); */\n\n        /*------------------TIER1-----------------*/\n\n        /* FIXME _ProfStart(PGROUP_T1); */\n        if\n                (! opj_tcd_t1_decode(p_tcd))\n        {\n                return OPJ_FALSE;\n        }\n        /* FIXME _ProfStop(PGROUP_T1); */\n\n        /*----------------DWT---------------------*/\n\n        /* FIXME _ProfStart(PGROUP_DWT); */\n        if\n                (! opj_tcd_dwt_decode(p_tcd))\n        {\n                return OPJ_FALSE;\n        }\n        /* FIXME _ProfStop(PGROUP_DWT); */\n\n        /*----------------MCT-------------------*/\n        /* FIXME _ProfStart(PGROUP_MCT); */\n        if\n                (! opj_tcd_mct_decode(p_tcd))\n        {\n                return OPJ_FALSE;\n        }\n        /* FIXME _ProfStop(PGROUP_MCT); */\n\n        /* FIXME _ProfStart(PGROUP_DC_SHIFT); */\n        if\n                (! opj_tcd_dc_level_shift_decode(p_tcd))\n        {\n                return OPJ_FALSE;\n        }\n        /* FIXME _ProfStop(PGROUP_DC_SHIFT); */\n\n\n        /*---------------TILE-------------------*/\n        return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_tcd_update_tile_data ( opj_tcd_t *p_tcd,\n                                    OPJ_BYTE * p_dest,\n                                    OPJ_UINT32 p_dest_length\n                                    )\n{\n        OPJ_UINT32 i,j,k,l_data_size = 0;\n        opj_image_comp_t * l_img_comp = 00;\n        opj_tcd_tilecomp_t * l_tilec = 00;\n        opj_tcd_resolution_t * l_res;\n        OPJ_UINT32 l_size_comp, l_remaining;\n        OPJ_UINT32 l_stride, l_width,l_height;\n\n        l_data_size = opj_tcd_get_decoded_tile_size(p_tcd);\n        if (l_data_size > p_dest_length) {\n                return OPJ_FALSE;\n        }\n\n        l_tilec = p_tcd->tcd_image->tiles->comps;\n        l_img_comp = p_tcd->image->comps;\n\n        for (i=0;i<p_tcd->image->numcomps;++i) {\n                l_size_comp = l_img_comp->prec >> 3; /*(/ 8)*/\n                l_remaining = l_img_comp->prec & 7;  /* (%8) */\n                l_res = l_tilec->resolutions + l_img_comp->resno_decoded;\n                l_width = (OPJ_UINT32)(l_res->x1 - l_res->x0);\n                l_height = (OPJ_UINT32)(l_res->y1 - l_res->y0);\n                l_stride = (OPJ_UINT32)(l_tilec->x1 - l_tilec->x0) - l_width;\n\n                if (l_remaining) {\n                        ++l_size_comp;\n                }\n\n                if (l_size_comp == 3) {\n                        l_size_comp = 4;\n                }\n\n                switch (l_size_comp)\n                        {\n                        case 1:\n                                {\n                                        OPJ_CHAR * l_dest_ptr = (OPJ_CHAR *) p_dest;\n                                        const OPJ_INT32 * l_src_ptr = l_tilec->data;\n\n                                        if (l_img_comp->sgnd) {\n                                                for (j=0;j<l_height;++j) {\n                                                        for (k=0;k<l_width;++k) {\n                                                                *(l_dest_ptr++) = (OPJ_CHAR) (*(l_src_ptr++));\n                                                        }\n                                                        l_src_ptr += l_stride;\n                                                }\n                                        }\n                                        else {\n                                                for (j=0;j<l_height;++j) {\n                                                        for     (k=0;k<l_width;++k) {\n                                                                *(l_dest_ptr++) = (OPJ_CHAR) ((*(l_src_ptr++))&0xff);\n                                                        }\n                                                        l_src_ptr += l_stride;\n                                                }\n                                        }\n\n                                        p_dest = (OPJ_BYTE *)l_dest_ptr;\n                                }\n                                break;\n                        case 2:\n                                {\n                                        const OPJ_INT32 * l_src_ptr = l_tilec->data;\n                                        OPJ_INT16 * l_dest_ptr = (OPJ_INT16 *) p_dest;\n\n                                        if (l_img_comp->sgnd) {\n                                                for (j=0;j<l_height;++j) {\n                                                        for (k=0;k<l_width;++k) {\n                                                                *(l_dest_ptr++) = (OPJ_INT16) (*(l_src_ptr++));\n                                                        }\n                                                        l_src_ptr += l_stride;\n                                                }\n                                        }\n                                        else {\n                                                for (j=0;j<l_height;++j) {\n                                                        for (k=0;k<l_width;++k) {\n                                                                *(l_dest_ptr++) = (OPJ_INT16) ((*(l_src_ptr++))&0xffff);\n                                                        }\n                                                        l_src_ptr += l_stride;\n                                                }\n                                        }\n\n                                        p_dest = (OPJ_BYTE*) l_dest_ptr;\n                                }\n                                break;\n                        case 4:\n                                {\n                                        OPJ_INT32 * l_dest_ptr = (OPJ_INT32 *) p_dest;\n                                        OPJ_INT32 * l_src_ptr = l_tilec->data;\n\n                                        for (j=0;j<l_height;++j) {\n                                                for (k=0;k<l_width;++k) {\n                                                        *(l_dest_ptr++) = (*(l_src_ptr++));\n                                                }\n                                                l_src_ptr += l_stride;\n                                        }\n\n                                        p_dest = (OPJ_BYTE*) l_dest_ptr;\n                                }\n                                break;\n                }\n\n                ++l_img_comp;\n                ++l_tilec;\n        }\n\n        return OPJ_TRUE;\n}\n\n\n\n\nvoid opj_tcd_free_tile(opj_tcd_t *p_tcd)\n{\n        OPJ_UINT32 compno, resno, bandno, precno;\n        opj_tcd_tile_t *l_tile = 00;\n        opj_tcd_tilecomp_t *l_tile_comp = 00;\n        opj_tcd_resolution_t *l_res = 00;\n        opj_tcd_band_t *l_band = 00;\n        opj_tcd_precinct_t *l_precinct = 00;\n        OPJ_UINT32 l_nb_resolutions, l_nb_precincts;\n        void (* l_tcd_code_block_deallocate) (opj_tcd_precinct_t *) = 00;\n\n        if (! p_tcd) {\n                return;\n        }\n\n        if (! p_tcd->tcd_image) {\n                return;\n        }\n\n        if (p_tcd->m_is_decoder) {\n                l_tcd_code_block_deallocate = opj_tcd_code_block_dec_deallocate;\n        }\n        else {\n                l_tcd_code_block_deallocate = opj_tcd_code_block_enc_deallocate;\n        }\n\n        l_tile = p_tcd->tcd_image->tiles;\n        if (! l_tile) {\n                return;\n        }\n\n        l_tile_comp = l_tile->comps;\n\n        for (compno = 0; compno < l_tile->numcomps; ++compno) {\n                l_res = l_tile_comp->resolutions;\n                if (l_res) {\n\n                        l_nb_resolutions = l_tile_comp->resolutions_size / sizeof(opj_tcd_resolution_t);\n                        for (resno = 0; resno < l_nb_resolutions; ++resno) {\n                                l_band = l_res->bands;\n                                for     (bandno = 0; bandno < 3; ++bandno) {\n                                        l_precinct = l_band->precincts;\n                                        if (l_precinct) {\n\n                                                l_nb_precincts = l_band->precincts_data_size / sizeof(opj_tcd_precinct_t);\n                                                for (precno = 0; precno < l_nb_precincts; ++precno) {\n                                                        opj_tgt_destroy(l_precinct->incltree);\n                                                        l_precinct->incltree = 00;\n                                                        opj_tgt_destroy(l_precinct->imsbtree);\n                                                        l_precinct->imsbtree = 00;\n                                                        (*l_tcd_code_block_deallocate) (l_precinct);\n                                                        ++l_precinct;\n                                                }\n\n                                                opj_free(l_band->precincts);\n                                                l_band->precincts = 00;\n                                        }\n                                        ++l_band;\n                                } /* for (resno */\n                                ++l_res;\n                        }\n\n                        opj_free(l_tile_comp->resolutions);\n                        l_tile_comp->resolutions = 00;\n                }\n\n                if (l_tile_comp->ownsData && l_tile_comp->data) {\n                        opj_free(l_tile_comp->data);\n                        l_tile_comp->data = 00;\n                        l_tile_comp->ownsData = 0;\n                        l_tile_comp->data_size = 0;\n                        l_tile_comp->data_size_needed = 0;\n                }\n                ++l_tile_comp;\n        }\n\n        opj_free(l_tile->comps);\n        l_tile->comps = 00;\n        opj_free(p_tcd->tcd_image->tiles);\n        p_tcd->tcd_image->tiles = 00;\n}\n\n\nOPJ_BOOL opj_tcd_t2_decode (opj_tcd_t *p_tcd,\n                            OPJ_BYTE * p_src_data,\n                            OPJ_UINT32 * p_data_read,\n                            OPJ_UINT32 p_max_src_size,\n                            opj_codestream_index_t *p_cstr_index\n                            )\n{\n        opj_t2_t * l_t2;\n\n        l_t2 = opj_t2_create(p_tcd->image, p_tcd->cp);\n        if (l_t2 == 00) {\n                return OPJ_FALSE;\n        }\n\n        if (! opj_t2_decode_packets(\n                                        l_t2,\n                                        p_tcd->tcd_tileno,\n                                        p_tcd->tcd_image->tiles,\n                                        p_src_data,\n                                        p_data_read,\n                                        p_max_src_size,\n                                        p_cstr_index)) {\n                opj_t2_destroy(l_t2);\n                return OPJ_FALSE;\n        }\n\n        opj_t2_destroy(l_t2);\n\n        /*---------------CLEAN-------------------*/\n        return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_tcd_t1_decode ( opj_tcd_t *p_tcd )\n{\n        OPJ_UINT32 compno;\n        opj_t1_t * l_t1;\n        opj_tcd_tile_t * l_tile = p_tcd->tcd_image->tiles;\n        opj_tcd_tilecomp_t* l_tile_comp = l_tile->comps;\n        opj_tccp_t * l_tccp = p_tcd->tcp->tccps;\n\n\n        l_t1 = opj_t1_create(OPJ_FALSE);\n        if (l_t1 == 00) {\n                return OPJ_FALSE;\n        }\n\n        for (compno = 0; compno < l_tile->numcomps; ++compno) {\n                /* The +3 is headroom required by the vectorized DWT */\n                if (OPJ_FALSE == opj_t1_decode_cblks(l_t1, l_tile_comp, l_tccp)) {\n                        opj_t1_destroy(l_t1);\n                        return OPJ_FALSE;\n                }\n                ++l_tile_comp;\n                ++l_tccp;\n        }\n\n        opj_t1_destroy(l_t1);\n\n        return OPJ_TRUE;\n}\n\n\nOPJ_BOOL opj_tcd_dwt_decode ( opj_tcd_t *p_tcd )\n{\n        OPJ_UINT32 compno;\n        opj_tcd_tile_t * l_tile = p_tcd->tcd_image->tiles;\n        opj_tcd_tilecomp_t * l_tile_comp = l_tile->comps;\n        opj_tccp_t * l_tccp = p_tcd->tcp->tccps;\n        opj_image_comp_t * l_img_comp = p_tcd->image->comps;\n\n        for (compno = 0; compno < l_tile->numcomps; compno++) {\n                /*\n                if (tcd->cp->reduce != 0) {\n                        tcd->image->comps[compno].resno_decoded =\n                                tile->comps[compno].numresolutions - tcd->cp->reduce - 1;\n                        if (tcd->image->comps[compno].resno_decoded < 0)\n                        {\n                                return false;\n                        }\n                }\n                numres2decode = tcd->image->comps[compno].resno_decoded + 1;\n                if(numres2decode > 0){\n                */\n\n                if (l_tccp->qmfbid == 1) {\n                        if (! opj_dwt_decode(l_tile_comp, l_img_comp->resno_decoded+1)) {\n                                return OPJ_FALSE;\n                        }\n                }\n                else {\n                        if (! opj_dwt_decode_real(l_tile_comp, l_img_comp->resno_decoded+1)) {\n                                return OPJ_FALSE;\n                        }\n                }\n\n                ++l_tile_comp;\n                ++l_img_comp;\n                ++l_tccp;\n        }\n\n        return OPJ_TRUE;\n}\nOPJ_BOOL opj_tcd_mct_decode ( opj_tcd_t *p_tcd )\n{\n        opj_tcd_tile_t * l_tile = p_tcd->tcd_image->tiles;\n        opj_tcp_t * l_tcp = p_tcd->tcp;\n        opj_tcd_tilecomp_t * l_tile_comp = l_tile->comps;\n        OPJ_UINT32 l_samples,i;\n\n        if (! l_tcp->mct) {\n                return OPJ_TRUE;\n        }\n\n        l_samples = (OPJ_UINT32)((l_tile_comp->x1 - l_tile_comp->x0) * (l_tile_comp->y1 - l_tile_comp->y0));\n\n        if (l_tile->numcomps >= 3 ){\n                /* testcase 1336.pdf.asan.47.376 */\n                if ((l_tile->comps[0].x1 - l_tile->comps[0].x0) * (l_tile->comps[0].y1 - l_tile->comps[0].y0) < (OPJ_INT32)l_samples ||\n                    (l_tile->comps[1].x1 - l_tile->comps[1].x0) * (l_tile->comps[1].y1 - l_tile->comps[1].y0) < (OPJ_INT32)l_samples ||\n                    (l_tile->comps[2].x1 - l_tile->comps[2].x0) * (l_tile->comps[2].y1 - l_tile->comps[2].y0) < (OPJ_INT32)l_samples) {\n                        fprintf(stderr, \"Tiles don't all have the same dimension. Skip the MCT step.\\n\");\n                        return OPJ_FALSE;\n                }\n                else if (l_tcp->mct == 2) {\n                        OPJ_BYTE ** l_data;\n\n                        if (! l_tcp->m_mct_decoding_matrix) {\n                                return OPJ_TRUE;\n                        }\n\n                        l_data = (OPJ_BYTE **) opj_malloc(l_tile->numcomps*sizeof(OPJ_BYTE*));\n                        if (! l_data) {\n                                return OPJ_FALSE;\n                        }\n\n                        for (i=0;i<l_tile->numcomps;++i) {\n                                l_data[i] = (OPJ_BYTE*) l_tile_comp->data;\n                                ++l_tile_comp;\n                        }\n\n                        if (! opj_mct_decode_custom(/* MCT data */\n                                                                        (OPJ_BYTE*) l_tcp->m_mct_decoding_matrix,\n                                                                        /* size of components */\n                                                                        l_samples,\n                                                                        /* components */\n                                                                        l_data,\n                                                                        /* nb of components (i.e. size of pData) */\n                                                                        l_tile->numcomps,\n                                                                        /* tells if the data is signed */\n                                                                        p_tcd->image->comps->sgnd)) {\n                                opj_free(l_data);\n                                return OPJ_FALSE;\n                        }\n\n                        opj_free(l_data);\n                }\n                else {\n                        if (l_tcp->tccps->qmfbid == 1) {\n                                opj_mct_decode(     l_tile->comps[0].data,\n                                                        l_tile->comps[1].data,\n                                                        l_tile->comps[2].data,\n                                                        l_samples);\n                        }\n                        else {\n                            opj_mct_decode_real((OPJ_FLOAT32*)l_tile->comps[0].data,\n                                                (OPJ_FLOAT32*)l_tile->comps[1].data,\n                                                (OPJ_FLOAT32*)l_tile->comps[2].data,\n                                                l_samples);\n                        }\n                }\n        }\n        else {\n                /* FIXME need to use opj_event_msg function */\n                fprintf(stderr,\"Number of components (%d) is inconsistent with a MCT. Skip the MCT step.\\n\",l_tile->numcomps);\n        }\n\n        return OPJ_TRUE;\n}\n\n\nOPJ_BOOL opj_tcd_dc_level_shift_decode ( opj_tcd_t *p_tcd )\n{\n        OPJ_UINT32 compno;\n        opj_tcd_tilecomp_t * l_tile_comp = 00;\n        opj_tccp_t * l_tccp = 00;\n        opj_image_comp_t * l_img_comp = 00;\n        opj_tcd_resolution_t* l_res = 00;\n        opj_tcd_tile_t * l_tile;\n        OPJ_UINT32 l_width,l_height,i,j;\n        OPJ_INT32 * l_current_ptr;\n        OPJ_INT32 l_min, l_max;\n        OPJ_UINT32 l_stride;\n\n        l_tile = p_tcd->tcd_image->tiles;\n        l_tile_comp = l_tile->comps;\n        l_tccp = p_tcd->tcp->tccps;\n        l_img_comp = p_tcd->image->comps;\n\n        for (compno = 0; compno < l_tile->numcomps; compno++) {\n                l_res = l_tile_comp->resolutions + l_img_comp->resno_decoded;\n                l_width = (OPJ_UINT32)(l_res->x1 - l_res->x0);\n                l_height = (OPJ_UINT32)(l_res->y1 - l_res->y0);\n                l_stride = (OPJ_UINT32)(l_tile_comp->x1 - l_tile_comp->x0) - l_width;\n\n                assert(l_height == 0 || l_width + l_stride <= l_tile_comp->data_size / l_height); /*MUPDF*/\n\n                if (l_img_comp->sgnd) {\n                        l_min = -(1 << (l_img_comp->prec - 1));\n                        l_max = (1 << (l_img_comp->prec - 1)) - 1;\n                }\n                else {\n            l_min = 0;\n                        l_max = (1 << l_img_comp->prec) - 1;\n                }\n\n                l_current_ptr = l_tile_comp->data;\n\n                if (l_tccp->qmfbid == 1) {\n                        for (j=0;j<l_height;++j) {\n                                for (i = 0; i < l_width; ++i) {\n                                        *l_current_ptr = opj_int_clamp(*l_current_ptr + l_tccp->m_dc_level_shift, l_min, l_max);\n                                        ++l_current_ptr;\n                                }\n                                l_current_ptr += l_stride;\n                        }\n                }\n                else {\n                        for (j=0;j<l_height;++j) {\n                                for (i = 0; i < l_width; ++i) {\n                                        OPJ_FLOAT32 l_value = *((OPJ_FLOAT32 *) l_current_ptr);\n                                        *l_current_ptr = opj_int_clamp((OPJ_INT32)lrintf(l_value) + l_tccp->m_dc_level_shift, l_min, l_max); ;\n                                        ++l_current_ptr;\n                                }\n                                l_current_ptr += l_stride;\n                        }\n                }\n\n                ++l_img_comp;\n                ++l_tccp;\n                ++l_tile_comp;\n        }\n\n        return OPJ_TRUE;\n}\n\n\n\n/**\n * Deallocates the encoding data of the given precinct.\n */\nvoid opj_tcd_code_block_dec_deallocate (opj_tcd_precinct_t * p_precinct)\n{\n        OPJ_UINT32 cblkno , l_nb_code_blocks;\n\n        opj_tcd_cblk_dec_t * l_code_block = p_precinct->cblks.dec;\n        if (l_code_block) {\n                /*fprintf(stderr,\"deallocate codeblock:{\\n\");*/\n                /*fprintf(stderr,\"\\t x0=%d, y0=%d, x1=%d, y1=%d\\n\",l_code_block->x0, l_code_block->y0, l_code_block->x1, l_code_block->y1);*/\n                /*fprintf(stderr,\"\\t numbps=%d, numlenbits=%d, len=%d, numnewpasses=%d, real_num_segs=%d, m_current_max_segs=%d\\n \",\n                                l_code_block->numbps, l_code_block->numlenbits, l_code_block->len, l_code_block->numnewpasses, l_code_block->real_num_segs, l_code_block->m_current_max_segs );*/\n\n\n                l_nb_code_blocks = p_precinct->block_size / sizeof(opj_tcd_cblk_dec_t);\n                /*fprintf(stderr,\"nb_code_blocks =%d\\t}\\n\", l_nb_code_blocks);*/\n\n                for (cblkno = 0; cblkno < l_nb_code_blocks; ++cblkno) {\n\n                        if (l_code_block->data) {\n                                opj_free(l_code_block->data);\n                                l_code_block->data = 00;\n                        }\n\n                        if (l_code_block->segs) {\n                                opj_free(l_code_block->segs );\n                                l_code_block->segs = 00;\n                        }\n\n                        ++l_code_block;\n                }\n\n                opj_free(p_precinct->cblks.dec);\n                p_precinct->cblks.dec = 00;\n        }\n}\n\n/**\n * Deallocates the encoding data of the given precinct.\n */\nvoid opj_tcd_code_block_enc_deallocate (opj_tcd_precinct_t * p_precinct)\n{       \n        OPJ_UINT32 cblkno , l_nb_code_blocks;\n\n        opj_tcd_cblk_enc_t * l_code_block = p_precinct->cblks.enc;\n        if (l_code_block) {\n                l_nb_code_blocks = p_precinct->block_size / sizeof(opj_tcd_cblk_enc_t);\n                \n                for     (cblkno = 0; cblkno < l_nb_code_blocks; ++cblkno)  {\n                        if (l_code_block->data) {\n                                opj_free(l_code_block->data - 1);\n                                l_code_block->data = 00;\n                        }\n\n                        if (l_code_block->layers) {\n                                opj_free(l_code_block->layers );\n                                l_code_block->layers = 00;\n                        }\n\n                        if (l_code_block->passes) {\n                                opj_free(l_code_block->passes );\n                                l_code_block->passes = 00;\n                        }\n                        ++l_code_block;\n                }\n\n                opj_free(p_precinct->cblks.enc);\n                \n                p_precinct->cblks.enc = 00;\n        }\n}\n\nOPJ_UINT32 opj_tcd_get_encoded_tile_size ( opj_tcd_t *p_tcd )\n{\n        OPJ_UINT32 i,l_data_size = 0;\n        opj_image_comp_t * l_img_comp = 00;\n        opj_tcd_tilecomp_t * l_tilec = 00;\n        OPJ_UINT32 l_size_comp, l_remaining;\n\n        l_tilec = p_tcd->tcd_image->tiles->comps;\n        l_img_comp = p_tcd->image->comps;\n        for (i=0;i<p_tcd->image->numcomps;++i) {\n                l_size_comp = l_img_comp->prec >> 3; /*(/ 8)*/\n                l_remaining = l_img_comp->prec & 7;  /* (%8) */\n\n                if (l_remaining) {\n                        ++l_size_comp;\n                }\n\n                if (l_size_comp == 3) {\n                        l_size_comp = 4;\n                }\n\n                l_data_size += l_size_comp * (OPJ_UINT32)((l_tilec->x1 - l_tilec->x0) * (l_tilec->y1 - l_tilec->y0));\n                ++l_img_comp;\n                ++l_tilec;\n        }\n\n        return l_data_size;\n}\n                \nOPJ_BOOL opj_tcd_dc_level_shift_encode ( opj_tcd_t *p_tcd )\n{\n        OPJ_UINT32 compno;\n        opj_tcd_tilecomp_t * l_tile_comp = 00;\n        opj_tccp_t * l_tccp = 00;\n        opj_image_comp_t * l_img_comp = 00;\n        opj_tcd_tile_t * l_tile;\n        OPJ_UINT32 l_nb_elem,i;\n        OPJ_INT32 * l_current_ptr;\n\n        l_tile = p_tcd->tcd_image->tiles;\n        l_tile_comp = l_tile->comps;\n        l_tccp = p_tcd->tcp->tccps;\n        l_img_comp = p_tcd->image->comps;\n\n        for (compno = 0; compno < l_tile->numcomps; compno++) {\n                l_current_ptr = l_tile_comp->data;\n                l_nb_elem = (OPJ_UINT32)((l_tile_comp->x1 - l_tile_comp->x0) * (l_tile_comp->y1 - l_tile_comp->y0));\n\n                if (l_tccp->qmfbid == 1) {\n                        for     (i = 0; i < l_nb_elem; ++i) {\n                                *l_current_ptr -= l_tccp->m_dc_level_shift ;\n                                ++l_current_ptr;\n                        }\n                }\n                else {\n                        for (i = 0; i < l_nb_elem; ++i) {\n                                *l_current_ptr = (*l_current_ptr - l_tccp->m_dc_level_shift) << 11 ;\n                                ++l_current_ptr;\n                        }\n                }\n\n                ++l_img_comp;\n                ++l_tccp;\n                ++l_tile_comp;\n        }\n\n        return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_tcd_mct_encode ( opj_tcd_t *p_tcd )\n{\n        opj_tcd_tile_t * l_tile = p_tcd->tcd_image->tiles;\n        opj_tcd_tilecomp_t * l_tile_comp = p_tcd->tcd_image->tiles->comps;\n        OPJ_UINT32 samples = (OPJ_UINT32)((l_tile_comp->x1 - l_tile_comp->x0) * (l_tile_comp->y1 - l_tile_comp->y0));\n        OPJ_UINT32 i;\n        OPJ_BYTE ** l_data = 00;\n        opj_tcp_t * l_tcp = p_tcd->tcp;\n\n        if(!p_tcd->tcp->mct) {\n                return OPJ_TRUE;\n        }\n\n        if (p_tcd->tcp->mct == 2) {\n                if (! p_tcd->tcp->m_mct_coding_matrix) {\n                        return OPJ_TRUE;\n                }\n\n        l_data = (OPJ_BYTE **) opj_malloc(l_tile->numcomps*sizeof(OPJ_BYTE*));\n                if (! l_data) {\n                        return OPJ_FALSE;\n                }\n\n                for (i=0;i<l_tile->numcomps;++i) {\n                        l_data[i] = (OPJ_BYTE*) l_tile_comp->data;\n                        ++l_tile_comp;\n                }\n\n                if (! opj_mct_encode_custom(/* MCT data */\n                                        (OPJ_BYTE*) p_tcd->tcp->m_mct_coding_matrix,\n                                        /* size of components */\n                                        samples,\n                                        /* components */\n                                        l_data,\n                                        /* nb of components (i.e. size of pData) */\n                                        l_tile->numcomps,\n                                        /* tells if the data is signed */\n                                        p_tcd->image->comps->sgnd) )\n                {\n            opj_free(l_data);\n                        return OPJ_FALSE;\n                }\n\n                opj_free(l_data);\n        }\n        else if (l_tcp->tccps->qmfbid == 0) {\n                opj_mct_encode_real(l_tile->comps[0].data, l_tile->comps[1].data, l_tile->comps[2].data, samples);\n        }\n        else {\n                opj_mct_encode(l_tile->comps[0].data, l_tile->comps[1].data, l_tile->comps[2].data, samples);\n        }\n\n        return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_tcd_dwt_encode ( opj_tcd_t *p_tcd )\n{\n        opj_tcd_tile_t * l_tile = p_tcd->tcd_image->tiles;\n        opj_tcd_tilecomp_t * l_tile_comp = p_tcd->tcd_image->tiles->comps;\n        opj_tccp_t * l_tccp = p_tcd->tcp->tccps;\n        OPJ_UINT32 compno;\n\n        for (compno = 0; compno < l_tile->numcomps; ++compno) {\n                if (l_tccp->qmfbid == 1) {\n                        if (! opj_dwt_encode(l_tile_comp)) {\n                                return OPJ_FALSE;\n                        }\n                }\n                else if (l_tccp->qmfbid == 0) {\n                        if (! opj_dwt_encode_real(l_tile_comp)) {\n                                return OPJ_FALSE;\n                        }\n                }\n\n                ++l_tile_comp;\n                ++l_tccp;\n        }\n\n        return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_tcd_t1_encode ( opj_tcd_t *p_tcd )\n{\n        opj_t1_t * l_t1;\n        const OPJ_FLOAT64 * l_mct_norms;\n        OPJ_UINT32 l_mct_numcomps = 0U;\n        opj_tcp_t * l_tcp = p_tcd->tcp;\n\n        l_t1 = opj_t1_create(OPJ_TRUE);\n        if (l_t1 == 00) {\n                return OPJ_FALSE;\n        }\n\n        if (l_tcp->mct == 1) {\n                l_mct_numcomps = 3U;\n                /* irreversible encoding */\n                if (l_tcp->tccps->qmfbid == 0) {\n                        l_mct_norms = opj_mct_get_mct_norms_real();\n                }\n                else {\n                        l_mct_norms = opj_mct_get_mct_norms();\n                }\n        }\n        else {\n                l_mct_numcomps = p_tcd->image->numcomps;\n                l_mct_norms = (const OPJ_FLOAT64 *) (l_tcp->mct_norms);\n        }\n\n        if (! opj_t1_encode_cblks(l_t1, p_tcd->tcd_image->tiles , l_tcp, l_mct_norms, l_mct_numcomps)) {\n        opj_t1_destroy(l_t1);\n                return OPJ_FALSE;\n        }\n\n        opj_t1_destroy(l_t1);\n\n        return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_tcd_t2_encode (opj_tcd_t *p_tcd,\n                                                OPJ_BYTE * p_dest_data,\n                                                OPJ_UINT32 * p_data_written,\n                                                OPJ_UINT32 p_max_dest_size,\n                                                opj_codestream_info_t *p_cstr_info )\n{\n        opj_t2_t * l_t2;\n\n        l_t2 = opj_t2_create(p_tcd->image, p_tcd->cp);\n        if (l_t2 == 00) {\n                return OPJ_FALSE;\n        }\n\n        if (! opj_t2_encode_packets(\n                                        l_t2,\n                                        p_tcd->tcd_tileno,\n                                        p_tcd->tcd_image->tiles,\n                                        p_tcd->tcp->numlayers,\n                                        p_dest_data,\n                                        p_data_written,\n                                        p_max_dest_size,\n                                        p_cstr_info,\n                                        p_tcd->tp_num,\n                                        p_tcd->tp_pos,\n                                        p_tcd->cur_pino,\n                                        FINAL_PASS))\n        {\n                opj_t2_destroy(l_t2);\n                return OPJ_FALSE;\n        }\n\n        opj_t2_destroy(l_t2);\n\n        /*---------------CLEAN-------------------*/\n        return OPJ_TRUE;\n}\n\n\nOPJ_BOOL opj_tcd_rate_allocate_encode(  opj_tcd_t *p_tcd,\n                                                                            OPJ_BYTE * p_dest_data,\n                                                                            OPJ_UINT32 p_max_dest_size,\n                                                                            opj_codestream_info_t *p_cstr_info )\n{\n        opj_cp_t * l_cp = p_tcd->cp;\n        OPJ_UINT32 l_nb_written = 0;\n\n        if (p_cstr_info)  {\n                p_cstr_info->index_write = 0;\n        }\n\n        if (l_cp->m_specific_param.m_enc.m_disto_alloc|| l_cp->m_specific_param.m_enc.m_fixed_quality)  {\n                /* fixed_quality */\n                /* Normal Rate/distortion allocation */\n                if (! opj_tcd_rateallocate(p_tcd, p_dest_data,&l_nb_written, p_max_dest_size, p_cstr_info)) {\n                        return OPJ_FALSE;\n                }\n        }\n        else {\n                /* Fixed layer allocation */\n                opj_tcd_rateallocate_fixed(p_tcd);\n        }\n\n        return OPJ_TRUE;\n}\n\n\nOPJ_BOOL opj_tcd_copy_tile_data (       opj_tcd_t *p_tcd,\n                                                                    OPJ_BYTE * p_src,\n                                                                    OPJ_UINT32 p_src_length )\n{\n        OPJ_UINT32 i,j,l_data_size = 0;\n        opj_image_comp_t * l_img_comp = 00;\n        opj_tcd_tilecomp_t * l_tilec = 00;\n        OPJ_UINT32 l_size_comp, l_remaining;\n        OPJ_UINT32 l_nb_elem;\n\n        l_data_size = opj_tcd_get_encoded_tile_size(p_tcd);\n        if (l_data_size != p_src_length) {\n                return OPJ_FALSE;\n        }\n\n        l_tilec = p_tcd->tcd_image->tiles->comps;\n        l_img_comp = p_tcd->image->comps;\n        for (i=0;i<p_tcd->image->numcomps;++i) {\n                l_size_comp = l_img_comp->prec >> 3; /*(/ 8)*/\n                l_remaining = l_img_comp->prec & 7;  /* (%8) */\n                l_nb_elem = (OPJ_UINT32)((l_tilec->x1 - l_tilec->x0) * (l_tilec->y1 - l_tilec->y0));\n\n                if (l_remaining) {\n                        ++l_size_comp;\n                }\n\n                if (l_size_comp == 3) {\n                        l_size_comp = 4;\n                }\n\n                switch (l_size_comp) {\n                        case 1:\n                                {\n                                        OPJ_CHAR * l_src_ptr = (OPJ_CHAR *) p_src;\n                                        OPJ_INT32 * l_dest_ptr = l_tilec->data;\n\n                                        if (l_img_comp->sgnd) {\n                                                for (j=0;j<l_nb_elem;++j) {\n                                                        *(l_dest_ptr++) = (OPJ_INT32) (*(l_src_ptr++));\n                                                }\n                                        }\n                                        else {\n                                                for (j=0;j<l_nb_elem;++j) {\n                                                        *(l_dest_ptr++) = (*(l_src_ptr++))&0xff;\n                                                }\n                                        }\n\n                                        p_src = (OPJ_BYTE*) l_src_ptr;\n                                }\n                                break;\n                        case 2:\n                                {\n                                        OPJ_INT32 * l_dest_ptr = l_tilec->data;\n                                        OPJ_INT16 * l_src_ptr = (OPJ_INT16 *) p_src;\n\n                                        if (l_img_comp->sgnd) {\n                                                for (j=0;j<l_nb_elem;++j) {\n                                                        *(l_dest_ptr++) = (OPJ_INT32) (*(l_src_ptr++));\n                                                }\n                                        }\n                                        else {\n                                                for (j=0;j<l_nb_elem;++j) {\n                                                        *(l_dest_ptr++) = (*(l_src_ptr++))&0xffff;\n                                                }\n                                        }\n\n                                        p_src = (OPJ_BYTE*) l_src_ptr;\n                                }\n                                break;\n                        case 4:\n                                {\n                                        OPJ_INT32 * l_src_ptr = (OPJ_INT32 *) p_src;\n                                        OPJ_INT32 * l_dest_ptr = l_tilec->data;\n\n                                        for (j=0;j<l_nb_elem;++j) {\n                                                *(l_dest_ptr++) = (OPJ_INT32) (*(l_src_ptr++));\n                                        }\n\n                                        p_src = (OPJ_BYTE*) l_src_ptr;\n                                }\n                                break;\n                }\n\n                ++l_img_comp;\n                ++l_tilec;\n        }\n\n        return OPJ_TRUE;\n}\n"], "filenames": ["src/lib/openjp2/pi.c", "src/lib/openjp2/tcd.c"], "buggy_code_start_loc": [711, 704], "buggy_code_end_loc": [715, 708], "fixing_code_start_loc": [711, 704], "fixing_code_end_loc": [715, 709], "type": "CWE-190", "message": "An improper computation of p_tx0, p_tx1, p_ty0 and p_ty1 in the function opj_get_encoding_parameters in openjp2/pi.c in OpenJPEG through 2.3.0 can lead to an integer overflow.", "other": {"cve": {"id": "CVE-2018-20847", "sourceIdentifier": "cve@mitre.org", "published": "2019-06-26T18:15:10.057", "lastModified": "2023-02-27T16:47:01.707", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An improper computation of p_tx0, p_tx1, p_ty0 and p_ty1 in the function opj_get_encoding_parameters in openjp2/pi.c in OpenJPEG through 2.3.0 can lead to an integer overflow."}, {"lang": "es", "value": "Un c\u00e1lculo incorrecto de p_tx0, p_tx1, p_ty0 y p_ty1 en la funci\u00f3n opj_get_encoding_parameters en openjp2/pi.c en OpenJPEG a versi\u00f3n 2.3.0 puede dar lugar a un desbordamiento de enteros."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:uclouvain:openjpeg:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.3.0", "matchCriteriaId": "2661F1B4-0FA3-4A71-96EC-505B1CD361D4"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/108921", "source": "cve@mitre.org", "tags": ["Broken Link", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/uclouvain/openjpeg/commit/5d00b719f4b93b1445e6fb4c766b9a9883c57949", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/uclouvain/openjpeg/issues/431", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/uclouvain/openjpeg/pull/1168/commits/c58df149900df862806d0e892859b41115875845", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/07/msg00010.html", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/uclouvain/openjpeg/commit/5d00b719f4b93b1445e6fb4c766b9a9883c57949"}}