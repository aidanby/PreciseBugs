{"buggy_code": ["<?php\n\n/**\n * Base class for elFinder volume.\n * Provide 2 layers:\n *  1. Public API (commands)\n *  2. abstract fs API\n * All abstract methods begin with \"_\"\n *\n * @author Dmitry (dio) Levashov\n * @author Troex Nevelin\n * @author Alexey Sukhotin\n * @method netmountPrepare(array $options)\n * @method postNetmount(array $options)\n */\nabstract class elFinderVolumeDriver\n{\n\n    /**\n     * Net mount key\n     *\n     * @var string\n     **/\n    public $netMountKey = '';\n\n    /**\n     * Request args\n     * $_POST or $_GET values\n     *\n     * @var array\n     */\n    protected $ARGS = array();\n\n    /**\n     * Driver id\n     * Must be started from letter and contains [a-z0-9]\n     * Used as part of volume id\n     *\n     * @var string\n     **/\n    protected $driverId = 'a';\n\n    /**\n     * Volume id - used as prefix for files hashes\n     *\n     * @var string\n     **/\n    protected $id = '';\n\n    /**\n     * Flag - volume \"mounted\" and available\n     *\n     * @var bool\n     **/\n    protected $mounted = false;\n\n    /**\n     * Root directory path\n     *\n     * @var string\n     **/\n    protected $root = '';\n\n    /**\n     * Root basename | alias\n     *\n     * @var string\n     **/\n    protected $rootName = '';\n\n    /**\n     * Default directory to open\n     *\n     * @var string\n     **/\n    protected $startPath = '';\n\n    /**\n     * Base URL\n     *\n     * @var string\n     **/\n    protected $URL = '';\n\n    /**\n     * Path to temporary directory\n     *\n     * @var string\n     */\n    protected $tmp;\n\n    /**\n     * A file save destination path when a temporary content URL is required\n     * on a network volume or the like\n     * If not specified, it tries to use \"Connector Path/../files/.tmb\".\n     *\n     * @var string\n     */\n    protected $tmpLinkPath = '';\n\n    /**\n     * A file save destination URL when a temporary content URL is required\n     * on a network volume or the like\n     * If not specified, it tries to use \"Connector URL/../files/.tmb\".\n     *\n     * @var string\n     */\n    protected $tmpLinkUrl = '';\n\n    /**\n     * Thumbnails dir path\n     *\n     * @var string\n     **/\n    protected $tmbPath = '';\n\n    /**\n     * Is thumbnails dir writable\n     *\n     * @var bool\n     **/\n    protected $tmbPathWritable = false;\n\n    /**\n     * Thumbnails base URL\n     *\n     * @var string\n     **/\n    protected $tmbURL = '';\n\n    /**\n     * Thumbnails size in px\n     *\n     * @var int\n     **/\n    protected $tmbSize = 48;\n\n    /**\n     * Image manipulation lib name\n     * auto|imagick|gd|convert\n     *\n     * @var string\n     **/\n    protected $imgLib = 'auto';\n\n    /**\n     * Video to Image converter\n     *\n     * @var array\n     */\n    protected $imgConverter = array();\n\n    /**\n     * Library to crypt files name\n     *\n     * @var string\n     **/\n    protected $cryptLib = '';\n\n    /**\n     * Archivers config\n     *\n     * @var array\n     **/\n    protected $archivers = array(\n        'create' => array(),\n        'extract' => array()\n    );\n\n    /**\n     * Static var of $this->options['maxArcFilesSize']\n     * \n     * @var int|string\n     */\n    protected static $maxArcFilesSize;\n\n    /**\n     * Server character encoding\n     *\n     * @var string or null\n     **/\n    protected $encoding = null;\n\n    /**\n     * How many subdirs levels return for tree\n     *\n     * @var int\n     **/\n    protected $treeDeep = 1;\n\n    /**\n     * Errors from last failed action\n     *\n     * @var array\n     **/\n    protected $error = array();\n\n    /**\n     * Today 24:00 timestamp\n     *\n     * @var int\n     **/\n    protected $today = 0;\n\n    /**\n     * Yesterday 24:00 timestamp\n     *\n     * @var int\n     **/\n    protected $yesterday = 0;\n\n    /**\n     * Force make dirctory on extract\n     *\n     * @var int\n     **/\n    protected $extractToNewdir = 'auto';\n\n    /**\n     * Object configuration\n     *\n     * @var array\n     **/\n    protected $options = array(\n        // Driver ID (Prefix of volume ID), Normally, the value specified for each volume driver is used.\n        'driverId' => '',\n        // Id (Suffix of volume ID), Normally, the number incremented according to the specified number of volumes is used.\n        'id' => '',\n        // revision id of root directory that uses for caching control of root stat\n        'rootRev' => '',\n        // driver type it uses volume root's CSS class name. e.g. 'group' -> Adds 'elfinder-group' to CSS class name.\n        'type' => '',\n        // root directory path\n        'path' => '',\n        // Folder hash value on elFinder to be the parent of this volume\n        'phash' => '',\n        // Folder hash value on elFinder to trash bin of this volume, it require 'copyJoin' to true\n        'trashHash' => '',\n        // open this path on initial request instead of root path\n        'startPath' => '',\n        // how many subdirs levels return per request\n        'treeDeep' => 1,\n        // root url, not set to URL via the connector. If you want to hide the file URL, do not set this value. (replacement for old \"fileURL\" option)\n        'URL' => '',\n        // enable onetime URL to a file - (true, false, 'auto' (true if a temporary directory is available) or callable (A function that return onetime URL))\n        'onetimeUrl' => 'auto',\n        // directory link url to own manager url with folder hash (`true`, `false`, `'hide'`(No show) or default `'auto'`: URL is empty then `true` else `false`)\n        'dirUrlOwn' => 'auto',\n        // directory separator. required by client to show paths correctly\n        'separator' => DIRECTORY_SEPARATOR,\n        // Use '/' as directory separator when the path hash encode/decode on the Windows server too\n        'winHashFix' => false,\n        // Server character encoding (default is '': UTF-8)\n        'encoding' => '',\n        // for convert character encoding (default is '': Not change locale)\n        'locale' => '',\n        // URL of volume icon image\n        'icon' => '',\n        // CSS Class of volume root in tree\n        'rootCssClass' => '',\n        // Items to disable session caching\n        'noSessionCache' => array(),\n        // enable i18n folder name that convert name to elFinderInstance.messages['folder_'+name]\n        'i18nFolderName' => false,\n        // Search timeout (sec)\n        'searchTimeout' => 30,\n        // Search exclusion directory regex pattern (require demiliter e.g. '#/path/to/exclude_directory#i')\n        'searchExDirReg' => '',\n        // library to crypt/uncrypt files names (not implemented)\n        'cryptLib' => '',\n        // how to detect files mimetypes. (auto/internal/finfo/mime_content_type)\n        'mimeDetect' => 'auto',\n        // mime.types file path (for mimeDetect==internal)\n        'mimefile' => '',\n        // Static extension/MIME of general server side scripts to security issues\n        'staticMineMap' => array(\n            'php:*' => 'text/x-php',\n            'pht:*' => 'text/x-php',\n            'php3:*' => 'text/x-php',\n            'php4:*' => 'text/x-php',\n            'php5:*' => 'text/x-php',\n            'php7:*' => 'text/x-php',\n            'phtml:*' => 'text/x-php',\n            'phar:*' => 'text/x-php',\n            'cgi:*' => 'text/x-httpd-cgi',\n            'pl:*' => 'text/x-perl',\n            'asp:*' => 'text/x-asap',\n            'aspx:*' => 'text/x-asap',\n            'py:*' => 'text/x-python',\n            'rb:*' => 'text/x-ruby',\n            'jsp:*' => 'text/x-jsp'\n        ),\n        // mime type normalize map : Array '[ext]:[detected mime type]' => '[normalized mime]'\n        'mimeMap' => array(\n            'md:application/x-genesis-rom' => 'text/x-markdown',\n            'md:text/plain' => 'text/x-markdown',\n            'markdown:text/plain' => 'text/x-markdown',\n            'css:text/x-asm' => 'text/css',\n            'css:text/plain' => 'text/css',\n            'csv:text/plain' => 'text/csv',\n            'java:text/x-c' => 'text/x-java-source',\n            'json:text/plain' => 'application/json',\n            'sql:text/plain' => 'text/x-sql',\n            'rtf:text/rtf' => 'application/rtf',\n            'rtfd:text/rtfd' => 'application/rtfd',\n            'ico:image/vnd.microsoft.icon' => 'image/x-icon',\n            'svg:text/plain' => 'image/svg+xml',\n            'pxd:application/octet-stream' => 'image/x-pixlr-data',\n            'dng:image/tiff' => 'image/x-adobe-dng',\n            'sketch:application/zip' => 'image/x-sketch',\n            'sketch:application/octet-stream' => 'image/x-sketch',\n            'xcf:application/octet-stream' => 'image/x-xcf',\n            'amr:application/octet-stream' => 'audio/amr',\n            'm4a:video/mp4' => 'audio/mp4',\n            'oga:application/ogg' => 'audio/ogg',\n            'ogv:application/ogg' => 'video/ogg',\n            'zip:application/x-zip' => 'application/zip',\n            'm3u8:text/plain' => 'application/x-mpegURL',\n            'mpd:text/plain' => 'application/dash+xml',\n            'mpd:application/xml' => 'application/dash+xml',\n            '*:application/x-dosexec' => 'application/x-executable',\n            'doc:application/vnd.ms-office' => 'application/msword',\n            'xls:application/vnd.ms-office' => 'application/vnd.ms-excel',\n            'ppt:application/vnd.ms-office' => 'application/vnd.ms-powerpoint',\n            'yml:text/plain' => 'text/x-yaml',\n            'ai:application/pdf' => 'application/postscript',\n            'cgm:text/plain' => 'image/cgm',\n            'dxf:text/plain' => 'image/vnd.dxf',\n            'dds:application/octet-stream' => 'image/vnd-ms.dds',\n            'hpgl:text/plain' => 'application/vnd.hp-hpgl',\n            'igs:text/plain' => 'model/iges',\n            'iges:text/plain' => 'model/iges',\n            'plt:application/octet-stream' => 'application/plt',\n            'plt:text/plain' => 'application/plt',\n            'sat:text/plain' => 'application/sat',\n            'step:text/plain' => 'application/step',\n            'stp:text/plain' => 'application/step'\n        ),\n        // An option to add MimeMap to the `mimeMap` option\n        // Array '[ext]:[detected mime type]' => '[normalized mime]'\n        'additionalMimeMap' => array(),\n        // MIME-Type of filetype detected as unknown\n        'mimeTypeUnknown' => 'application/octet-stream',\n        // MIME regex of send HTTP header \"Content-Disposition: inline\" or allow preview in quicklook\n        // '.' is allow inline of all of MIME types\n        // '$^' is not allow inline of all of MIME types\n        'dispInlineRegex' => '^(?:(?:video|audio)|image/(?!.+\\+xml)|application/(?:ogg|x-mpegURL|dash\\+xml)|(?:text/plain|application/pdf)$)',\n        // temporary content URL's base path\n        'tmpLinkPath' => '',\n        // temporary content URL's base URL\n        'tmpLinkUrl' => '',\n        // directory for thumbnails\n        'tmbPath' => '.tmb',\n        // mode to create thumbnails dir\n        'tmbPathMode' => 0777,\n        // thumbnails dir URL. Set it if store thumbnails outside root directory\n        'tmbURL' => '',\n        // thumbnails size (px)\n        'tmbSize' => 48,\n        // thumbnails crop (true - crop, false - scale image to fit thumbnail size)\n        'tmbCrop' => true,\n        // thumbnail URL require custom data as the GET query\n        'tmbReqCustomData' => false,\n        // thumbnails background color (hex #rrggbb or 'transparent')\n        'tmbBgColor' => 'transparent',\n        // image rotate fallback background color (hex #rrggbb)\n        'bgColorFb' => '#ffffff',\n        // image manipulations library (imagick|gd|convert|auto|none, none - Does not check the image library at all.)\n        'imgLib' => 'auto',\n        // Fallback self image to thumbnail (nothing imgLib)\n        'tmbFbSelf' => true,\n        // Video to Image converters ['TYPE or MIME' => ['func' => function($file){ /* Converts $file to Image */ return true; }, 'maxlen' => (int)TransferLength]]\n        'imgConverter' => array(),\n        // Max length of transfer to image converter\n        'tmbVideoConvLen' => 10000000,\n        // Captre point seccond\n        'tmbVideoConvSec' => 6,\n        // Life time (hour) for thumbnail garbage collection (\"0\" means no GC)\n        'tmbGcMaxlifeHour' => 0,\n        // Percentage of garbage collection executed for thumbnail creation command (\"1\" means \"1%\")\n        'tmbGcPercentage' => 1,\n        // Resource path of fallback icon images defailt: php/resouces\n        'resourcePath' => '',\n        // Jpeg image saveing quality\n        'jpgQuality' => 100,\n        // Save as progressive JPEG on image editing\n        'jpgProgressive' => true,\n        // enable to get substitute image with command `dim`\n        'substituteImg' => true,\n        // on paste file -  if true - old file will be replaced with new one, if false new file get name - original_name-number.ext\n        'copyOverwrite' => true,\n        // if true - join new and old directories content on paste\n        'copyJoin' => true,\n        // on upload -  if true - old file will be replaced with new one, if false new file get name - original_name-number.ext\n        'uploadOverwrite' => true,\n        // mimetypes allowed to upload\n        'uploadAllow' => array(),\n        // mimetypes not allowed to upload\n        'uploadDeny' => array(),\n        // order to process uploadAllow and uploadDeny options\n        'uploadOrder' => array('deny', 'allow'),\n        // maximum upload file size. NOTE - this is size for every uploaded files\n        'uploadMaxSize' => 0,\n        // Maximum number of folders that can be created at one time. (0: unlimited)\n        'uploadMaxMkdirs' => 0,\n        // maximum number of chunked upload connection. `-1` to disable chunked upload\n        'uploadMaxConn' => 3,\n        // maximum get file size. NOTE - Maximum value is 50% of PHP memory_limit\n        'getMaxSize' => 0,\n        // files dates format\n        'dateFormat' => 'j M Y H:i',\n        // files time format\n        'timeFormat' => 'H:i',\n        // if true - every folder will be check for children folders, -1 - every folder will be check asynchronously, false -  all folders will be marked as having subfolders\n        'checkSubfolders' => true, // true, false or -1\n        // allow to copy from this volume to other ones?\n        'copyFrom' => true,\n        // allow to copy from other volumes to this one?\n        'copyTo' => true,\n        // cmd duplicate suffix format e.g. '_%s_' to without spaces\n        'duplicateSuffix' => ' %s ',\n        // unique name numbar format e.g. '(%d)' to (1), (2)...\n        'uniqueNumFormat' => '%d',\n        // list of commands disabled on this root\n        'disabled' => array(),\n        // enable file owner, group & mode info, `false` to inactivate \"chmod\" command.\n        'statOwner' => false,\n        // allow exec chmod of read-only files\n        'allowChmodReadOnly' => false,\n        // regexp or function name to validate new file name\n        'acceptedName' => '/^[^\\.].*/', // Notice: overwritten it in some volume drivers contractor\n        // regexp or function name to validate new directory name\n        'acceptedDirname' => '', // used `acceptedName` if empty value\n        // function/class method to control files permissions\n        'accessControl' => null,\n        // some data required by access control\n        'accessControlData' => null,\n        // root stat that return without asking the system when mounted and not the current volume. Query to the system with false. array|false\n        'rapidRootStat' => array(\n            'read' => true,\n            'write' => true,\n            'locked' => false,\n            'hidden' => false,\n            'size' => 0,  // Unknown\n            'ts' => 0,    // Unknown\n            'dirs' => -1, // Check on demand for subdirectories\n            'mime' => 'directory'\n        ),\n        // default permissions.\n        'defaults' => array(\n            'read' => true,\n            'write' => true,\n            'locked' => false,\n            'hidden' => false\n        ),\n        // files attributes\n        'attributes' => array(),\n        // max allowed archive files size (0 - no limit)\n        'maxArcFilesSize' => '2G',\n        // Allowed archive's mimetypes to create. Leave empty for all available types.\n        'archiveMimes' => array(),\n        // Manual config for archivers. See example below. Leave empty for auto detect\n        'archivers' => array(),\n        // Use Archive function for remote volume\n        'useRemoteArchive' => false,\n        // plugin settings\n        'plugin' => array(),\n        // Is support parent directory time stamp update on add|remove|rename item\n        // Default `null` is auto detection that is LocalFileSystem, FTP or Dropbox are `true`\n        'syncChkAsTs' => null,\n        // Long pooling sync checker function for syncChkAsTs is true\n        // Calls with args (TARGET DIRCTORY PATH, STAND-BY(sec), OLD TIMESTAMP, VOLUME DRIVER INSTANCE, ELFINDER INSTANCE)\n        // This function must return the following values. Changed: New Timestamp or Same: Old Timestamp or Error: false\n        // Default `null` is try use elFinderVolumeLocalFileSystem::localFileSystemInotify() on LocalFileSystem driver\n        // another driver use elFinder stat() checker\n        'syncCheckFunc' => null,\n        // Long polling sync stand-by time (sec)\n        'plStandby' => 30,\n        // Sleep time (sec) for elFinder stat() checker (syncChkAsTs is true)\n        'tsPlSleep' => 10,\n        // Sleep time (sec) for elFinder ls() checker (syncChkAsTs is false)\n        'lsPlSleep' => 30,\n        // Client side sync interval minimum (ms)\n        // Default `null` is auto set to ('tsPlSleep' or 'lsPlSleep') * 1000\n        // `0` to disable auto sync\n        'syncMinMs' => null,\n        // required to fix bug on macos\n        // However, we recommend to use the Normalizer plugin instead this option\n        'utf8fix' => false,\n        //                           \u0439                 \u0451              \u0419               \u0401              \u00d8         \u00c5\n        'utf8patterns' => array(\"\\u0438\\u0306\", \"\\u0435\\u0308\", \"\\u0418\\u0306\", \"\\u0415\\u0308\", \"\\u00d8A\", \"\\u030a\"),\n        'utf8replace' => array(\"\\u0439\", \"\\u0451\", \"\\u0419\", \"\\u0401\", \"\\u00d8\", \"\\u00c5\"),\n        // cache control HTTP headers for commands `file` and  `get`\n        'cacheHeaders' => array(\n            'Cache-Control: max-age=3600',\n            'Expires:',\n            'Pragma:'\n        ),\n        // Header to use to accelerate sending local files to clients (e.g. 'X-Sendfile', 'X-Accel-Redirect')\n        'xsendfile' => '',\n        // Root path to xsendfile target. Probably, this is required for 'X-Accel-Redirect' on Nginx.\n        'xsendfilePath' => ''\n    );\n\n    /**\n     * Defaults permissions\n     *\n     * @var array\n     **/\n    protected $defaults = array(\n        'read' => true,\n        'write' => true,\n        'locked' => false,\n        'hidden' => false\n    );\n\n    /**\n     * Access control function/class\n     *\n     * @var mixed\n     **/\n    protected $attributes = array();\n\n    /**\n     * Access control function/class\n     *\n     * @var mixed\n     **/\n    protected $access = null;\n\n    /**\n     * Mime types allowed to upload\n     *\n     * @var array\n     **/\n    protected $uploadAllow = array();\n\n    /**\n     * Mime types denied to upload\n     *\n     * @var array\n     **/\n    protected $uploadDeny = array();\n\n    /**\n     * Order to validate uploadAllow and uploadDeny\n     *\n     * @var array\n     **/\n    protected $uploadOrder = array();\n\n    /**\n     * Maximum allowed upload file size.\n     * Set as number or string with unit - \"10M\", \"500K\", \"1G\"\n     *\n     * @var int|string\n     **/\n    protected $uploadMaxSize = 0;\n\n    /**\n     * Run time setting of overwrite items on upload\n     *\n     * @var string\n     */\n    protected $uploadOverwrite = true;\n\n    /**\n     * Maximum allowed get file size.\n     * Set as number or string with unit - \"10M\", \"500K\", \"1G\"\n     *\n     * @var int|string\n     **/\n    protected $getMaxSize = -1;\n\n    /**\n     * Mimetype detect method\n     *\n     * @var string\n     **/\n    protected $mimeDetect = 'auto';\n\n    /**\n     * Flag - mimetypes from externail file was loaded\n     *\n     * @var bool\n     **/\n    private static $mimetypesLoaded = false;\n\n    /**\n     * Finfo resource for mimeDetect == 'finfo'\n     *\n     * @var resource\n     **/\n    protected $finfo = null;\n\n    /**\n     * List of disabled client's commands\n     *\n     * @var array\n     **/\n    protected $disabled = array();\n\n    /**\n     * overwrite extensions/mimetypes to mime.types\n     *\n     * @var array\n     **/\n    protected static $mimetypes = array(\n        // applications\n        'exe' => 'application/x-executable',\n        'jar' => 'application/x-jar',\n        // archives\n        'gz' => 'application/x-gzip',\n        'tgz' => 'application/x-gzip',\n        'tbz' => 'application/x-bzip2',\n        'rar' => 'application/x-rar',\n        // texts\n        'php' => 'text/x-php',\n        'js' => 'text/javascript',\n        'rtfd' => 'application/rtfd',\n        'py' => 'text/x-python',\n        'rb' => 'text/x-ruby',\n        'sh' => 'text/x-shellscript',\n        'pl' => 'text/x-perl',\n        'xml' => 'text/xml',\n        'c' => 'text/x-csrc',\n        'h' => 'text/x-chdr',\n        'cpp' => 'text/x-c++src',\n        'hh' => 'text/x-c++hdr',\n        'md' => 'text/x-markdown',\n        'markdown' => 'text/x-markdown',\n        'yml' => 'text/x-yaml',\n        // images\n        'bmp' => 'image/x-ms-bmp',\n        'tga' => 'image/x-targa',\n        'xbm' => 'image/xbm',\n        'pxm' => 'image/pxm',\n        //audio\n        'wav' => 'audio/wav',\n        // video\n        'dv' => 'video/x-dv',\n        'wm' => 'video/x-ms-wmv',\n        'ogm' => 'video/ogg',\n        'm2ts' => 'video/MP2T',\n        'mts' => 'video/MP2T',\n        'ts' => 'video/MP2T',\n        'm3u8' => 'application/x-mpegURL',\n        'mpd' => 'application/dash+xml'\n    );\n\n    /**\n     * Directory separator - required by client\n     *\n     * @var string\n     **/\n    protected $separator = DIRECTORY_SEPARATOR;\n\n    /**\n     * Directory separator for decode/encode hash\n     *\n     * @var string\n     **/\n    protected $separatorForHash = '';\n\n    /**\n     * System Root path (Unix like: '/', Windows: '\\', 'C:\\' or 'D:\\'...)\n     *\n     * @var string\n     **/\n    protected $systemRoot = DIRECTORY_SEPARATOR;\n\n    /**\n     * Mimetypes allowed to display\n     *\n     * @var array\n     **/\n    protected $onlyMimes = array();\n\n    /**\n     * Store files moved or overwrited files info\n     *\n     * @var array\n     **/\n    protected $removed = array();\n\n    /**\n     * Store files added files info\n     *\n     * @var array\n     **/\n    protected $added = array();\n\n    /**\n     * Cache storage\n     *\n     * @var array\n     **/\n    protected $cache = array();\n\n    /**\n     * Cache by folders\n     *\n     * @var array\n     **/\n    protected $dirsCache = array();\n\n    /**\n     * You should use `$this->sessionCache['subdirs']` instead\n     *\n     * @var array\n     * @deprecated\n     */\n    protected $subdirsCache = array();\n\n    /**\n     * This volume session cache\n     *\n     * @var array\n     */\n    protected $sessionCache;\n\n    /**\n     * Session caching item list\n     *\n     * @var array\n     */\n    protected $sessionCaching = array('rootstat' => true, 'subdirs' => true);\n\n    /**\n     * elFinder session wrapper object\n     *\n     * @var elFinderSessionInterface\n     */\n    protected $session;\n\n    /**\n     * Search start time\n     *\n     * @var int\n     */\n    protected $searchStart;\n\n    /**\n     * Current query word on doSearch\n     *\n     * @var array\n     **/\n    protected $doSearchCurrentQuery = array();\n\n    /**\n     * Is root modified (for clear root stat cache)\n     *\n     * @var bool\n     */\n    protected $rootModified = false;\n\n    /**\n     * Is disable of command `url`\n     *\n     * @var string\n     */\n    protected $disabledGetUrl = false;\n\n    /**\n     * Accepted filename validator\n     *\n     * @var string | callable\n     */\n    protected $nameValidator;\n\n    /**\n     * Accepted dirname validator\n     *\n     * @var string | callable\n     */\n    protected $dirnameValidator;\n\n    /**\n     * This request require online state\n     *\n     * @var boolean\n     */\n    protected $needOnline;\n\n    /*********************************************************************/\n    /*                            INITIALIZATION                         */\n    /*********************************************************************/\n\n    /**\n     * Sets the need online.\n     *\n     * @param  boolean  $state  The state\n     */\n    public function setNeedOnline($state = null)\n    {\n        if ($state !== null) {\n            $this->needOnline = (bool)$state;\n            return;\n        }\n\n        $need = false;\n        $arg = $this->ARGS;\n        $id = $this->id;\n\n        $target = !empty($arg['target'])? $arg['target'] : (!empty($arg['dst'])? $arg['dst'] : '');\n        $targets = !empty($arg['targets'])? $arg['targets'] : array();\n        if (!is_array($targets)) {\n            $targets = array($targets);\n        }\n\n        if ($target && strpos($target, $id) === 0) {\n            $need = true;\n        } else if ($targets) {\n            foreach($targets as $t) {\n                if ($t && strpos($t, $id) === 0) {\n                    $need = true;\n                    break;\n                }\n            }\n        }\n\n        $this->needOnline = $need;\n    }\n\n    /**\n     * Prepare driver before mount volume.\n     * Return true if volume is ready.\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function init()\n    {\n        return true;\n    }\n\n    /**\n     * Configure after successfull mount.\n     * By default set thumbnails path and image manipulation library.\n     *\n     * @return void\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function configure()\n    {\n        // set thumbnails path\n        $path = $this->options['tmbPath'];\n        if ($path) {\n            if (!file_exists($path)) {\n                if (mkdir($path)) {\n                    chmod($path, $this->options['tmbPathMode']);\n                } else {\n                    $path = '';\n                }\n            }\n\n            if (is_dir($path) && is_readable($path)) {\n                $this->tmbPath = $path;\n                $this->tmbPathWritable = is_writable($path);\n            }\n        }\n        // set resouce path\n        if (!is_dir($this->options['resourcePath'])) {\n            $this->options['resourcePath'] = dirname(__FILE__) . DIRECTORY_SEPARATOR . 'resources';\n        }\n\n        // set image manipulation library\n        $type = preg_match('/^(imagick|gd|convert|auto|none)$/i', $this->options['imgLib'])\n            ? strtolower($this->options['imgLib'])\n            : 'auto';\n\n        if ($type === 'none') {\n            $this->imgLib = '';\n        } else {\n            if (($type === 'imagick' || $type === 'auto') && extension_loaded('imagick')) {\n                $this->imgLib = 'imagick';\n            } else if (($type === 'gd' || $type === 'auto') && function_exists('gd_info')) {\n                $this->imgLib = 'gd';\n            } else {\n                $convertCache = 'imgLibConvert';\n                if (($convertCmd = $this->session->get($convertCache, false)) !== false) {\n                    $this->imgLib = $convertCmd;\n                } else {\n                    $this->imgLib = ($this->procExec(ELFINDER_CONVERT_PATH . ' -version') === 0) ? 'convert' : '';\n                    $this->session->set($convertCache, $this->imgLib);\n                }\n            }\n            if ($type !== 'auto' && $this->imgLib === '') {\n                // fallback\n                $this->imgLib = extension_loaded('imagick') ? 'imagick' : (function_exists('gd_info') ? 'gd' : '');\n            }\n        }\n\n        // check video to img converter\n        if (!empty($this->options['imgConverter']) && is_array($this->options['imgConverter'])) {\n            foreach ($this->options['imgConverter'] as $_type => $_converter) {\n                if (isset($_converter['func'])) {\n                    $this->imgConverter[strtolower($_type)] = $_converter;\n                }\n            }\n        }\n        if (!isset($this->imgConverter['video'])) {\n            $videoLibCache = 'videoLib';\n            if (($videoLibCmd = $this->session->get($videoLibCache, false)) === false) {\n                $videoLibCmd = ($this->procExec(ELFINDER_FFMPEG_PATH . ' -version') === 0) ? 'ffmpeg' : '';\n                $this->session->set($videoLibCache, $videoLibCmd);\n            }\n            if ($videoLibCmd) {\n                $this->imgConverter['video'] = array(\n                    'func' => array($this, $videoLibCmd . 'ToImg'),\n                    'maxlen' => $this->options['tmbVideoConvLen']\n                );\n            }\n        }\n\n        // check onetimeUrl\n        if (strtolower($this->options['onetimeUrl']) === 'auto') {\n            $this->options['onetimeUrl'] = elFinder::getStaticVar('commonTempPath')? true : false;\n        }\n\n        // check archivers\n        if (empty($this->archivers['create'])) {\n            $this->disabled[] = 'archive';\n        }\n        if (empty($this->archivers['extract'])) {\n            $this->disabled[] = 'extract';\n        }\n        $_arc = $this->getArchivers();\n        if (empty($_arc['create'])) {\n            $this->disabled[] = 'zipdl';\n        }\n\n        if ($this->options['maxArcFilesSize']) {\n            $this->options['maxArcFilesSize'] = elFinder::getIniBytes('', $this->options['maxArcFilesSize']);\n        }\n        self::$maxArcFilesSize = $this->options['maxArcFilesSize'];\n\n        // check 'statOwner' for command `chmod`\n        if (empty($this->options['statOwner'])) {\n            $this->disabled[] = 'chmod';\n        }\n\n        // check 'mimeMap'\n        if (!is_array($this->options['mimeMap'])) {\n            $this->options['mimeMap'] = array();\n        }\n        if (is_array($this->options['staticMineMap']) && $this->options['staticMineMap']) {\n            $this->options['mimeMap'] = array_merge($this->options['mimeMap'], $this->options['staticMineMap']);\n        }\n        if (is_array($this->options['additionalMimeMap']) && $this->options['additionalMimeMap']) {\n            $this->options['mimeMap'] = array_merge($this->options['mimeMap'], $this->options['additionalMimeMap']);\n        }\n\n        // check 'url' in disabled commands\n        if (in_array('url', $this->disabled)) {\n            $this->disabledGetUrl = true;\n        }\n\n        // set run time setting uploadOverwrite\n        $this->uploadOverwrite = $this->options['uploadOverwrite'];\n    }\n\n    /**\n     * @deprecated\n     */\n    protected function sessionRestart()\n    {\n        $this->sessionCache = $this->session->start()->get($this->id, array());\n        return true;\n    }\n\n    /*********************************************************************/\n    /*                              PUBLIC API                           */\n    /*********************************************************************/\n\n    /**\n     * Return driver id. Used as a part of volume id.\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    public function driverId()\n    {\n        return $this->driverId;\n    }\n\n    /**\n     * Return volume id\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    public function id()\n    {\n        return $this->id;\n    }\n\n    /**\n     * Assign elFinder session wrapper object\n     *\n     * @param  $session  elFinderSessionInterface\n     */\n    public function setSession($session)\n    {\n        $this->session = $session;\n    }\n\n    /**\n     * Get elFinder sesson wrapper object\n     *\n     * @return object  The session object\n     */\n    public function getSession()\n    {\n        return $this->session;\n    }\n\n    /**\n     * Save session cache data\n     * Calls this function before umount this volume on elFinder::exec()\n     *\n     * @return void\n     */\n    public function saveSessionCache()\n    {\n        $this->session->set($this->id, $this->sessionCache);\n    }\n\n    /**\n     * Return debug info for client\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    public function debug()\n    {\n        return array(\n            'id' => $this->id(),\n            'name' => strtolower(substr(get_class($this), strlen('elfinderdriver'))),\n            'mimeDetect' => $this->mimeDetect,\n            'imgLib' => $this->imgLib\n        );\n    }\n\n    /**\n     * chmod a file or folder\n     *\n     * @param  string $hash file or folder hash to chmod\n     * @param  string $mode octal string representing new permissions\n     *\n     * @return array|false\n     * @author David Bartle\n     **/\n    public function chmod($hash, $mode)\n    {\n        if ($this->commandDisabled('chmod')) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        if (!($file = $this->file($hash))) {\n            return $this->setError(elFinder::ERROR_FILE_NOT_FOUND);\n        }\n\n        if (!$this->options['allowChmodReadOnly']) {\n            if (!$this->attr($this->decode($hash), 'write', null, ($file['mime'] === 'directory'))) {\n                return $this->setError(elFinder::ERROR_PERM_DENIED, $file['name']);\n            }\n        }\n\n        $path = $this->decode($hash);\n        $write = $file['write'];\n\n        if ($this->convEncOut(!$this->_chmod($this->convEncIn($path), $mode))) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED, $file['name']);\n        }\n\n        $this->clearstatcache();\n        if ($path == $this->root) {\n            $this->rootModified = true;\n        }\n\n        if ($file = $this->stat($path)) {\n            $files = array($file);\n            if ($file['mime'] === 'directory' && $write !== $file['write']) {\n                foreach ($this->getScandir($path) as $stat) {\n                    if ($this->mimeAccepted($stat['mime'])) {\n                        $files[] = $stat;\n                    }\n                }\n            }\n            return $files;\n        } else {\n            return $this->setError(elFinder::ERROR_FILE_NOT_FOUND);\n        }\n    }\n\n    /**\n     * stat a file or folder for elFinder cmd exec\n     *\n     * @param  string $hash file or folder hash to chmod\n     *\n     * @return array\n     * @author Naoki Sawada\n     **/\n    public function fstat($hash)\n    {\n        $path = $this->decode($hash);\n        return $this->stat($path);\n    }\n\n    /**\n     * Clear PHP stat cache & all of inner stat caches\n     */\n    public function clearstatcache()\n    {\n        clearstatcache();\n        $this->clearcache();\n    }\n\n    /**\n     * Clear inner stat caches for target hash\n     *\n     * @param string $hash\n     */\n    public function clearcaches($hash = null)\n    {\n        if ($hash === null) {\n            $this->clearcache();\n        } else {\n            $path = $this->decode($hash);\n            unset($this->cache[$path], $this->dirsCache[$path]);\n        }\n    }\n\n    /**\n     * \"Mount\" volume.\n     * Return true if volume available for read or write,\n     * false - otherwise\n     *\n     * @param array $opts\n     *\n     * @return bool\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     * @author Alexey Sukhotin\n     */\n    public function mount(array $opts)\n    {\n        $this->options = array_merge($this->options, $opts);\n\n        if (!isset($this->options['path']) || $this->options['path'] === '') {\n            return $this->setError('Path undefined.');\n        }\n\n        if (!$this->session) {\n            return $this->setError('Session wrapper dose not set. Need to `$volume->setSession(elFinderSessionInterface);` before mount.');\n        }\n        if (!($this->session instanceof elFinderSessionInterface)) {\n            return $this->setError('Session wrapper instance must be \"elFinderSessionInterface\".');\n        }\n\n        // set driverId\n        if (!empty($this->options['driverId'])) {\n            $this->driverId = $this->options['driverId'];\n        }\n\n        $this->id = $this->driverId . (!empty($this->options['id']) ? $this->options['id'] : elFinder::$volumesCnt++) . '_';\n        $this->root = $this->normpathCE($this->options['path']);\n        $this->separator = isset($this->options['separator']) ? $this->options['separator'] : DIRECTORY_SEPARATOR;\n        if (!empty($this->options['winHashFix'])) {\n            $this->separatorForHash = ($this->separator !== '/') ? '/' : '';\n        }\n        $this->systemRoot = isset($this->options['systemRoot']) ? $this->options['systemRoot'] : $this->separator;\n\n        // set ARGS\n        $this->ARGS = $_SERVER['REQUEST_METHOD'] === 'POST' ? $_POST : $_GET;\n\n        $argInit = !empty($this->ARGS['init']);\n\n        // set $this->needOnline\n        if (!is_bool($this->needOnline)) {\n            $this->setNeedOnline();\n        }\n\n        // session cache\n        if ($argInit) {\n            $this->session->set($this->id, array());\n        }\n        $this->sessionCache = $this->session->get($this->id, array());\n\n        // default file attribute\n        $this->defaults = array(\n            'read' => isset($this->options['defaults']['read']) ? !!$this->options['defaults']['read'] : true,\n            'write' => isset($this->options['defaults']['write']) ? !!$this->options['defaults']['write'] : true,\n            'locked' => isset($this->options['defaults']['locked']) ? !!$this->options['defaults']['locked'] : false,\n            'hidden' => isset($this->options['defaults']['hidden']) ? !!$this->options['defaults']['hidden'] : false\n        );\n\n        // root attributes\n        $this->attributes[] = array(\n            'pattern' => '~^' . preg_quote($this->separator) . '$~',\n            'locked' => true,\n            'hidden' => false\n        );\n        // set files attributes\n        if (!empty($this->options['attributes']) && is_array($this->options['attributes'])) {\n\n            foreach ($this->options['attributes'] as $a) {\n                // attributes must contain pattern and at least one rule\n                if (!empty($a['pattern']) || (is_array($a) && count($a) > 1)) {\n                    $this->attributes[] = $a;\n                }\n            }\n        }\n\n        if (!empty($this->options['accessControl']) && is_callable($this->options['accessControl'])) {\n            $this->access = $this->options['accessControl'];\n        }\n\n        $this->today = mktime(0, 0, 0, date('m'), date('d'), date('Y'));\n        $this->yesterday = $this->today - 86400;\n\n        if (!$this->init()) {\n            return false;\n        }\n\n        // set server encoding\n        if (!empty($this->options['encoding']) && strtoupper($this->options['encoding']) !== 'UTF-8') {\n            $this->encoding = $this->options['encoding'];\n        } else {\n            $this->encoding = null;\n        }\n\n        // check some options is arrays\n        $this->uploadAllow = isset($this->options['uploadAllow']) && is_array($this->options['uploadAllow'])\n            ? $this->options['uploadAllow']\n            : array();\n\n        $this->uploadDeny = isset($this->options['uploadDeny']) && is_array($this->options['uploadDeny'])\n            ? $this->options['uploadDeny']\n            : array();\n\n        $this->options['uiCmdMap'] = (isset($this->options['uiCmdMap']) && is_array($this->options['uiCmdMap']))\n            ? $this->options['uiCmdMap']\n            : array();\n\n        if (is_string($this->options['uploadOrder'])) { // telephat_mode on, compatibility with 1.x\n            $parts = explode(',', isset($this->options['uploadOrder']) ? $this->options['uploadOrder'] : 'deny,allow');\n            $this->uploadOrder = array(trim($parts[0]), trim($parts[1]));\n        } else { // telephat_mode off\n            $this->uploadOrder = !empty($this->options['uploadOrder']) ? $this->options['uploadOrder'] : array('deny', 'allow');\n        }\n\n        if (!empty($this->options['uploadMaxSize'])) {\n            $this->uploadMaxSize = elFinder::getIniBytes('', $this->options['uploadMaxSize']);\n        }\n        // Set maximum to PHP_INT_MAX\n        if (!defined('PHP_INT_MAX')) {\n            define('PHP_INT_MAX', 2147483647);\n        }\n        if ($this->uploadMaxSize < 1 || $this->uploadMaxSize > PHP_INT_MAX) {\n            $this->uploadMaxSize = PHP_INT_MAX;\n        }\n\n        // Set to get maximum size to 50% of memory_limit\n        $memLimit = elFinder::getIniBytes('memory_limit') / 2;\n        if ($memLimit > 0) {\n            $this->getMaxSize = empty($this->options['getMaxSize']) ? $memLimit : min($memLimit, elFinder::getIniBytes('', $this->options['getMaxSize']));\n        } else {\n            $this->getMaxSize = -1;\n        }\n\n        $this->disabled = isset($this->options['disabled']) && is_array($this->options['disabled'])\n            ? array_values(array_diff($this->options['disabled'], array('open'))) // 'open' is required\n            : array();\n\n        $this->cryptLib = $this->options['cryptLib'];\n        $this->mimeDetect = $this->options['mimeDetect'];\n\n        // find available mimetype detect method\n        $regexp = '/text\\/x\\-(php|c\\+\\+)/';\n        $auto_types = array();\n\n        if (class_exists('finfo', false)) {\n            $tmpFileInfo = explode(';', finfo_file(finfo_open(FILEINFO_MIME), __FILE__));\n             if ($tmpFileInfo && preg_match($regexp, array_shift($tmpFileInfo))) {\n                $auto_types[] = 'finfo';\n            }\n        }\n        \n        if (function_exists('mime_content_type')) {\n            $_mimetypes = explode(';', mime_content_type(__FILE__));\n            if (preg_match($regexp, array_shift($_mimetypes))) {\n                $auto_types[] = 'mime_content_type';\n            }\n        }\n            \n        $auto_types[] = 'internal';\n\n        $type = strtolower($this->options['mimeDetect']);\n        if (!in_array($type, $auto_types)) {\n            $type = 'auto';\n        }\n\n        if ($type == 'auto') {\n            $type = array_shift($auto_types);\n        }\n\n        $this->mimeDetect = $type;\n\n        if ($this->mimeDetect == 'finfo') {\n            $this->finfo = finfo_open(FILEINFO_MIME);\n        } else if ($this->mimeDetect == 'internal' && !elFinderVolumeDriver::$mimetypesLoaded) {\n            // load mimes from external file for mimeDetect == 'internal'\n            // based on Alexey Sukhotin idea and patch: http://elrte.org/redmine/issues/163\n            // file must be in file directory or in parent one\n            elFinderVolumeDriver::loadMimeTypes(!empty($this->options['mimefile']) ? $this->options['mimefile'] : '');\n        }\n        $this->rootName = empty($this->options['alias']) ? $this->basenameCE($this->root) : $this->options['alias'];\n\n        // This get's triggered if $this->root == '/' and alias is empty.\n        // Maybe modify _basename instead?\n        if ($this->rootName === '') $this->rootName = $this->separator;\n\n        $this->_checkArchivers();\n\n        $root = $this->stat($this->root);\n\n        if (!$root) {\n            return $this->setError('Root folder does not exist.');\n        }\n        if (!$root['read'] && !$root['write']) {\n            return $this->setError('Root folder has not read and write permissions.');\n        }\n\n        if ($root['read']) {\n            if ($argInit) {\n                // check startPath - path to open by default instead of root\n                $startPath = $this->options['startPath'] ? $this->normpathCE($this->options['startPath']) : '';\n                if ($startPath) {\n                    $start = $this->stat($startPath);\n                    if (!empty($start)\n                        && $start['mime'] == 'directory'\n                        && $start['read']\n                        && empty($start['hidden'])\n                        && $this->inpathCE($startPath, $this->root)) {\n                        $this->startPath = $startPath;\n                        if (substr($this->startPath, -1, 1) == $this->options['separator']) {\n                            $this->startPath = substr($this->startPath, 0, -1);\n                        }\n                    }\n                }\n            }\n        } else {\n            $this->options['URL'] = '';\n            $this->options['tmbURL'] = '';\n            $this->options['tmbPath'] = '';\n            // read only volume\n            array_unshift($this->attributes, array(\n                'pattern' => '/.*/',\n                'read' => false\n            ));\n        }\n        $this->treeDeep = $this->options['treeDeep'] > 0 ? (int)$this->options['treeDeep'] : 1;\n        $this->tmbSize = $this->options['tmbSize'] > 0 ? (int)$this->options['tmbSize'] : 48;\n        $this->URL = $this->options['URL'];\n        if ($this->URL && preg_match(\"|[^/?&=]$|\", $this->URL)) {\n            $this->URL .= '/';\n        }\n\n        $dirUrlOwn = strtolower($this->options['dirUrlOwn']);\n        if ($dirUrlOwn === 'auto') {\n            $this->options['dirUrlOwn'] = $this->URL ? false : true;\n        } else if ($dirUrlOwn === 'hide') {\n            $this->options['dirUrlOwn'] = 'hide';\n        } else {\n            $this->options['dirUrlOwn'] = (bool)$this->options['dirUrlOwn'];\n        }\n\n        $this->tmbURL = !empty($this->options['tmbURL']) ? $this->options['tmbURL'] : '';\n        if ($this->tmbURL && $this->tmbURL !== 'self' && preg_match(\"|[^/?&=]$|\", $this->tmbURL)) {\n            $this->tmbURL .= '/';\n        }\n\n        $this->nameValidator = !empty($this->options['acceptedName']) && (is_string($this->options['acceptedName']) || is_callable($this->options['acceptedName']))\n            ? $this->options['acceptedName']\n            : '';\n\n        $this->dirnameValidator = !empty($this->options['acceptedDirname']) && (is_callable($this->options['acceptedDirname']) || (is_string($this->options['acceptedDirname']) && preg_match($this->options['acceptedDirname'], '') !== false))\n            ? $this->options['acceptedDirname']\n            : $this->nameValidator;\n\n        // enabling archivers['create'] with options['useRemoteArchive']\n        if ($this->options['useRemoteArchive'] && empty($this->archivers['create']) && $this->getTempPath()) {\n            $_archivers = $this->getArchivers();\n            $this->archivers['create'] = $_archivers['create'];\n        }\n\n        // manual control archive types to create\n        if (!empty($this->options['archiveMimes']) && is_array($this->options['archiveMimes'])) {\n            foreach ($this->archivers['create'] as $mime => $v) {\n                if (!in_array($mime, $this->options['archiveMimes'])) {\n                    unset($this->archivers['create'][$mime]);\n                }\n            }\n        }\n\n        // manualy add archivers\n        if (!empty($this->options['archivers']['create']) && is_array($this->options['archivers']['create'])) {\n            foreach ($this->options['archivers']['create'] as $mime => $conf) {\n                if (strpos($mime, 'application/') === 0\n                    && !empty($conf['cmd'])\n                    && isset($conf['argc'])\n                    && !empty($conf['ext'])\n                    && !isset($this->archivers['create'][$mime])) {\n                    $this->archivers['create'][$mime] = $conf;\n                }\n            }\n        }\n\n        if (!empty($this->options['archivers']['extract']) && is_array($this->options['archivers']['extract'])) {\n            foreach ($this->options['archivers']['extract'] as $mime => $conf) {\n                if (strpos($mime, 'application/') === 0\n                    && !empty($conf['cmd'])\n                    && isset($conf['argc'])\n                    && !empty($conf['ext'])\n                    && !isset($this->archivers['extract'][$mime])) {\n                    $this->archivers['extract'][$mime] = $conf;\n                }\n            }\n        }\n\n        if (!empty($this->options['noSessionCache']) && is_array($this->options['noSessionCache'])) {\n            foreach ($this->options['noSessionCache'] as $_key) {\n                $this->sessionCaching[$_key] = false;\n                unset($this->sessionCache[$_key]);\n            }\n        }\n        if ($this->sessionCaching['subdirs']) {\n            if (!isset($this->sessionCache['subdirs'])) {\n                $this->sessionCache['subdirs'] = array();\n            }\n        }\n\n\n        $this->configure();\n\n        // Normalize disabled (array_merge`for type array of JSON)\n        $this->disabled = array_values(array_unique($this->disabled));\n\n        // fix sync interval\n        if ($this->options['syncMinMs'] !== 0) {\n            $this->options['syncMinMs'] = max($this->options[$this->options['syncChkAsTs'] ? 'tsPlSleep' : 'lsPlSleep'] * 1000, intval($this->options['syncMinMs']));\n        }\n\n        // ` copyJoin` is required for the trash function\n        if ($this->options['trashHash'] && empty($this->options['copyJoin'])) {\n            $this->options['trashHash'] = '';\n        }\n\n        // set tmpLinkPath\n        if (elFinder::$tmpLinkPath && !$this->options['tmpLinkPath']) {\n            if (is_writeable(elFinder::$tmpLinkPath)) {\n                $this->options['tmpLinkPath'] = elFinder::$tmpLinkPath;\n            } else {\n                elFinder::$tmpLinkPath = '';\n            }\n        }\n        if ($this->options['tmpLinkPath'] && is_writable($this->options['tmpLinkPath'])) {\n            $this->tmpLinkPath = realpath($this->options['tmpLinkPath']);\n        } else if (!$this->tmpLinkPath && $this->tmbURL && $this->tmbPath) {\n            $this->tmpLinkPath = $this->tmbPath;\n            $this->options['tmpLinkUrl'] = $this->tmbURL;\n        } else if (!$this->options['URL'] && is_writable('../files/.tmb')) {\n            $this->tmpLinkPath = realpath('../files/.tmb');\n            $this->options['tmpLinkUrl'] = '';\n            if (!elFinder::$tmpLinkPath) {\n                elFinder::$tmpLinkPath = $this->tmpLinkPath;\n                elFinder::$tmpLinkUrl = '';\n            }\n        }\n\n        // set tmpLinkUrl\n        if (elFinder::$tmpLinkUrl && !$this->options['tmpLinkUrl']) {\n            $this->options['tmpLinkUrl'] = elFinder::$tmpLinkUrl;\n        }\n        if ($this->options['tmpLinkUrl']) {\n            $this->tmpLinkUrl = $this->options['tmpLinkUrl'];\n        }\n        if ($this->tmpLinkPath && !$this->tmpLinkUrl) {\n            $cur = realpath('./');\n            $i = 0;\n            while ($cur !== $this->systemRoot && strpos($this->tmpLinkPath, $cur) !== 0) {\n                $i++;\n                $cur = dirname($cur);\n            }\n            list($req) = explode('?', $_SERVER['REQUEST_URI']);\n            $reqs = explode('/', dirname($req));\n            $uri = join('/', array_slice($reqs, 0, count($reqs) - 1)) . substr($this->tmpLinkPath, strlen($cur));\n            $https = (isset($_SERVER['HTTPS']) && strtolower($_SERVER['HTTPS']) !== 'off');\n            $this->tmpLinkUrl = ($https ? 'https://' : 'http://')\n                . $_SERVER['SERVER_NAME'] // host\n                . (((!$https && $_SERVER['SERVER_PORT'] == 80) || ($https && $_SERVER['SERVER_PORT'] == 443)) ? '' : (':' . $_SERVER['SERVER_PORT']))  // port\n                . $uri;\n            if (!elFinder::$tmpLinkUrl) {\n                elFinder::$tmpLinkUrl = $this->tmpLinkUrl;\n            }\n        }\n\n        // remove last '/'\n        if ($this->tmpLinkPath) {\n            $this->tmpLinkPath = rtrim($this->tmpLinkPath, '/');\n        }\n        if ($this->tmpLinkUrl) {\n            $this->tmpLinkUrl = rtrim($this->tmpLinkUrl, '/');\n        }\n\n        // to update options cache\n        if (isset($this->sessionCache['rootstat'])) {\n            unset($this->sessionCache['rootstat'][$this->getRootstatCachekey()]);\n        }\n        $this->updateCache($this->root, $root);\n\n        return $this->mounted = true;\n    }\n\n    /**\n     * Some \"unmount\" stuffs - may be required by virtual fs\n     *\n     * @return void\n     * @author Dmitry (dio) Levashov\n     **/\n    public function umount()\n    {\n    }\n\n    /**\n     * Remove session cache of this volume\n     */\n    public function clearSessionCache()\n    {\n        $this->sessionCache = array();\n    }\n\n    /**\n     * Return error message from last failed action\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    public function error()\n    {\n        return $this->error;\n    }\n\n    /**\n     * Return is uploadable that given file name\n     *\n     * @param  string $name file name\n     * @param  bool   $allowUnknown\n     *\n     * @return bool\n     * @author Naoki Sawada\n     **/\n    public function isUploadableByName($name, $allowUnknown = false)\n    {\n        $mimeByName = $this->mimetype($name, true);\n        return (($allowUnknown && $mimeByName === 'unknown') || $this->allowPutMime($mimeByName));\n    }\n\n    /**\n     * Return Extention/MIME Table (elFinderVolumeDriver::$mimetypes)\n     *\n     * @return array\n     * @author Naoki Sawada\n     */\n    public function getMimeTable()\n    {\n        // load mime.types\n        if (!elFinderVolumeDriver::$mimetypesLoaded) {\n            elFinderVolumeDriver::loadMimeTypes();\n        }\n        return elFinderVolumeDriver::$mimetypes;\n    }\n\n    /**\n     * Return file extention detected by MIME type\n     *\n     * @param  string $mime   MIME type\n     * @param  string $suffix Additional suffix\n     *\n     * @return string\n     * @author Naoki Sawada\n     */\n    public function getExtentionByMime($mime, $suffix = '')\n    {\n        static $extTable = null;\n\n        if (is_null($extTable)) {\n            $extTable = array_flip(array_unique($this->getMimeTable()));\n            foreach ($this->options['mimeMap'] as $pair => $_mime) {\n                list($ext) = explode(':', $pair);\n                if ($ext !== '*' && !isset($extTable[$_mime])) {\n                    $extTable[$_mime] = $ext;\n                }\n            }\n        }\n\n        if ($mime && isset($extTable[$mime])) {\n            return $suffix ? ($extTable[$mime] . $suffix) : $extTable[$mime];\n        }\n        return '';\n    }\n\n    /**\n     * Set mimetypes allowed to display to client\n     *\n     * @param  array $mimes\n     *\n     * @return void\n     * @author Dmitry (dio) Levashov\n     **/\n    public function setMimesFilter($mimes)\n    {\n        if (is_array($mimes)) {\n            $this->onlyMimes = $mimes;\n        }\n    }\n\n    /**\n     * Return root folder hash\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    public function root()\n    {\n        return $this->encode($this->root);\n    }\n\n    /**\n     * Return root path\n     *\n     * @return string\n     * @author Naoki Sawada\n     **/\n    public function getRootPath()\n    {\n        return $this->root;\n    }\n\n    /**\n     * Return target path hash\n     *\n     * @param  string $path\n     * @param  string $name\n     *\n     * @author Naoki Sawada\n     * @return string\n     */\n    public function getHash($path, $name = '')\n    {\n        if ($name !== '') {\n            $path = $this->joinPathCE($path, $name);\n        }\n        return $this->encode($path);\n    }\n\n    /**\n     * Return decoded path of target hash\n     * This method do not check the stat of target\n     * Use method `realpath()` to do check of the stat of target\n     *\n     * @param  string $hash\n     *\n     * @author Naoki Sawada\n     * @return string\n     */\n    public function getPath($hash)\n    {\n        return $this->decode($hash);\n    }\n\n    /**\n     * Return root or startPath hash\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    public function defaultPath()\n    {\n        return $this->encode($this->startPath ? $this->startPath : $this->root);\n    }\n\n    /**\n     * Return volume options required by client:\n     *\n     * @param $hash\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     */\n    public function options($hash)\n    {\n        $create = $createext = array();\n        if (isset($this->archivers['create']) && is_array($this->archivers['create'])) {\n            foreach ($this->archivers['create'] as $m => $v) {\n                $create[] = $m;\n                $createext[$m] = $v['ext'];\n            }\n        }\n        $opts = array(\n            'path' => $hash ? $this->path($hash) : '',\n            'url' => $this->URL,\n            'tmbUrl' => (!$this->imgLib && $this->options['tmbFbSelf']) ? 'self' : $this->tmbURL,\n            'disabled' => $this->disabled,\n            'separator' => $this->separator,\n            'copyOverwrite' => intval($this->options['copyOverwrite']),\n            'uploadOverwrite' => intval($this->options['uploadOverwrite']),\n            'uploadMaxSize' => intval($this->uploadMaxSize),\n            'uploadMaxConn' => intval($this->options['uploadMaxConn']),\n            'uploadMime' => array(\n                'firstOrder' => isset($this->uploadOrder[0]) ? $this->uploadOrder[0] : 'deny',\n                'allow' => $this->uploadAllow,\n                'deny' => $this->uploadDeny\n            ),\n            'dispInlineRegex' => $this->options['dispInlineRegex'],\n            'jpgQuality' => intval($this->options['jpgQuality']),\n            'archivers' => array(\n                'create' => $create,\n                'extract' => isset($this->archivers['extract']) && is_array($this->archivers['extract']) ? array_keys($this->archivers['extract']) : array(),\n                'createext' => $createext\n            ),\n            'uiCmdMap' => (isset($this->options['uiCmdMap']) && is_array($this->options['uiCmdMap'])) ? $this->options['uiCmdMap'] : array(),\n            'syncChkAsTs' => intval($this->options['syncChkAsTs']),\n            'syncMinMs' => intval($this->options['syncMinMs']),\n            'i18nFolderName' => intval($this->options['i18nFolderName']),\n            'tmbCrop' => intval($this->options['tmbCrop']),\n            'tmbReqCustomData' => (bool)$this->options['tmbReqCustomData'],\n            'substituteImg' => (bool)$this->options['substituteImg'],\n            'onetimeUrl' => (bool)$this->options['onetimeUrl'],\n        );\n        if (!empty($this->options['trashHash'])) {\n            $opts['trashHash'] = $this->options['trashHash'];\n        }\n        if ($hash === null) {\n            // call from getRootStatExtra()\n            if (!empty($this->options['icon'])) {\n                $opts['icon'] = $this->options['icon'];\n            }\n            if (!empty($this->options['rootCssClass'])) {\n                $opts['csscls'] = $this->options['rootCssClass'];\n            }\n            if (isset($this->options['netkey'])) {\n                $opts['netkey'] = $this->options['netkey'];\n            }\n        }\n        return $opts;\n    }\n\n    /**\n     * Get option value of this volume\n     *\n     * @param string $name target option name\n     *\n     * @return NULL|mixed   target option value\n     * @author Naoki Sawada\n     */\n    public function getOption($name)\n    {\n        return isset($this->options[$name]) ? $this->options[$name] : null;\n    }\n\n    /**\n     * Get plugin values of this options\n     *\n     * @param string $name Plugin name\n     *\n     * @return NULL|array   Plugin values\n     * @author Naoki Sawada\n     */\n    public function getOptionsPlugin($name = '')\n    {\n        if ($name) {\n            return isset($this->options['plugin'][$name]) ? $this->options['plugin'][$name] : array();\n        } else {\n            return $this->options['plugin'];\n        }\n    }\n\n    /**\n     * Return true if command disabled in options\n     *\n     * @param  string $cmd command name\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    public function commandDisabled($cmd)\n    {\n        return in_array($cmd, $this->disabled);\n    }\n\n    /**\n     * Return true if mime is required mimes list\n     *\n     * @param  string    $mime  mime type to check\n     * @param  array     $mimes allowed mime types list or not set to use client mimes list\n     * @param  bool|null $empty what to return on empty list\n     *\n     * @return bool|null\n     * @author Dmitry (dio) Levashov\n     * @author Troex Nevelin\n     **/\n    public function mimeAccepted($mime, $mimes = null, $empty = true)\n    {\n        $mimes = is_array($mimes) ? $mimes : $this->onlyMimes;\n        if (empty($mimes)) {\n            return $empty;\n        }\n        return $mime == 'directory'\n            || in_array('all', $mimes)\n            || in_array('All', $mimes)\n            || in_array($mime, $mimes)\n            || in_array(substr($mime, 0, strpos($mime, '/')), $mimes);\n    }\n\n    /**\n     * Return true if voume is readable.\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    public function isReadable()\n    {\n        $stat = $this->stat($this->root);\n        return $stat['read'];\n    }\n\n    /**\n     * Return true if copy from this volume allowed\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    public function copyFromAllowed()\n    {\n        return !!$this->options['copyFrom'];\n    }\n\n    /**\n     * Return file path related to root with convert encoging\n     *\n     * @param  string $hash file hash\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    public function path($hash)\n    {\n        return $this->convEncOut($this->_path($this->convEncIn($this->decode($hash))));\n    }\n\n    /**\n     * Return file real path if file exists\n     *\n     * @param  string $hash file hash\n     *\n     * @return string | false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function realpath($hash)\n    {\n        $path = $this->decode($hash);\n        return $this->stat($path) ? $path : false;\n    }\n\n    /**\n     * Return list of moved/overwrited files\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    public function removed()\n    {\n        if ($this->removed) {\n            $unsetSubdir = isset($this->sessionCache['subdirs']) ? true : false;\n            foreach ($this->removed as $item) {\n                if ($item['mime'] === 'directory') {\n                    $path = $this->decode($item['hash']);\n                    if ($unsetSubdir) {\n                        unset($this->sessionCache['subdirs'][$path]);\n                    }\n                    if ($item['phash'] !== '') {\n                        $parent = $this->decode($item['phash']);\n                        unset($this->cache[$parent]);\n                        if ($this->root === $parent) {\n                            $this->sessionCache['rootstat'] = array();\n                        }\n                        if ($unsetSubdir) {\n                            unset($this->sessionCache['subdirs'][$parent]);\n                        }\n                    }\n                }\n            }\n            $this->removed = array_values($this->removed);\n        }\n        return $this->removed;\n    }\n\n    /**\n     * Return list of added files\n     *\n     * @deprecated\n     * @return array\n     * @author Naoki Sawada\n     **/\n    public function added()\n    {\n        return $this->added;\n    }\n\n    /**\n     * Clean removed files list\n     *\n     * @return void\n     * @author Dmitry (dio) Levashov\n     **/\n    public function resetRemoved()\n    {\n        $this->resetResultStat();\n    }\n\n    /**\n     * Clean added/removed files list\n     *\n     * @return void\n     **/\n    public function resetResultStat()\n    {\n        $this->removed = array();\n        $this->added = array();\n    }\n\n    /**\n     * Return file/dir hash or first founded child hash with required attr == $val\n     *\n     * @param  string $hash file hash\n     * @param  string $attr attribute name\n     * @param  bool   $val  attribute value\n     *\n     * @return string|false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function closest($hash, $attr, $val)\n    {\n        return ($path = $this->closestByAttr($this->decode($hash), $attr, $val)) ? $this->encode($path) : false;\n    }\n\n    /**\n     * Return file info or false on error\n     *\n     * @param  string $hash file hash\n     *\n     * @return array|false\n     * @internal param bool $realpath add realpath field to file info\n     * @author   Dmitry (dio) Levashov\n     */\n    public function file($hash)\n    {\n        $file = $this->stat($this->decode($hash));\n\n        return ($file) ? $file : $this->setError(elFinder::ERROR_FILE_NOT_FOUND);\n    }\n\n    /**\n     * Return folder info\n     *\n     * @param  string $hash folder hash\n     * @param bool    $resolveLink\n     *\n     * @return array|false\n     * @internal param bool $hidden return hidden file info\n     * @author   Dmitry (dio) Levashov\n     */\n    public function dir($hash, $resolveLink = false)\n    {\n        if (($dir = $this->file($hash)) == false) {\n            return $this->setError(elFinder::ERROR_DIR_NOT_FOUND);\n        }\n\n        if ($resolveLink && !empty($dir['thash'])) {\n            $dir = $this->file($dir['thash']);\n        }\n\n        return $dir && $dir['mime'] == 'directory' && empty($dir['hidden'])\n            ? $dir\n            : $this->setError(elFinder::ERROR_NOT_DIR);\n    }\n\n    /**\n     * Return directory content or false on error\n     *\n     * @param  string $hash file hash\n     *\n     * @return array|false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function scandir($hash)\n    {\n        if (($dir = $this->dir($hash)) == false) {\n            return false;\n        }\n\n        $path = $this->decode($hash);\n        if ($res = $dir['read']\n            ? $this->getScandir($path)\n            : $this->setError(elFinder::ERROR_PERM_DENIED)) {\n\n            $dirs = null;\n            if ($this->sessionCaching['subdirs'] && isset($this->sessionCache['subdirs'][$path])) {\n                $dirs = $this->sessionCache['subdirs'][$path];\n            }\n            if ($dirs !== null || (isset($dir['dirs']) && $dir['dirs'] != 1)) {\n                $_dir = $dir;\n                if ($dirs || $this->subdirs($hash)) {\n                    $dir['dirs'] = 1;\n                } else {\n                    unset($dir['dirs']);\n                }\n                if ($dir !== $_dir) {\n                    $this->updateCache($path, $dir);\n                }\n            }\n        }\n\n        return $res;\n    }\n\n    /**\n     * Return dir files names list\n     *\n     * @param  string $hash file hash\n     * @param null    $intersect\n     *\n     * @return array|false\n     * @author Dmitry (dio) Levashov\n     */\n    public function ls($hash, $intersect = null)\n    {\n        if (($dir = $this->dir($hash)) == false || !$dir['read']) {\n            return false;\n        }\n\n        $list = array();\n        $path = $this->decode($hash);\n\n        $check = array();\n        if ($intersect) {\n            $check = array_flip($intersect);\n        }\n\n        foreach ($this->getScandir($path) as $stat) {\n            if (empty($stat['hidden']) && (!$check || isset($check[$stat['name']])) && $this->mimeAccepted($stat['mime'])) {\n                $list[$stat['hash']] = $stat['name'];\n            }\n        }\n\n        return $list;\n    }\n\n    /**\n     * Return subfolders for required folder or false on error\n     *\n     * @param  string $hash    folder hash or empty string to get tree from root folder\n     * @param  int    $deep    subdir deep\n     * @param  string $exclude dir hash which subfolders must be exluded from result, required to not get stat twice on cwd subfolders\n     *\n     * @return array|false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function tree($hash = '', $deep = 0, $exclude = '')\n    {\n        $path = $hash ? $this->decode($hash) : $this->root;\n\n        if (($dir = $this->stat($path)) == false || $dir['mime'] != 'directory') {\n            return false;\n        }\n\n        $dirs = $this->gettree($path, $deep > 0 ? $deep - 1 : $this->treeDeep - 1, $exclude ? $this->decode($exclude) : null);\n        array_unshift($dirs, $dir);\n        return $dirs;\n    }\n\n    /**\n     * Return part of dirs tree from required dir up to root dir\n     *\n     * @param  string    $hash   directory hash\n     * @param  bool|null $lineal only lineal parents\n     *\n     * @return array|false\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    public function parents($hash, $lineal = false)\n    {\n        if (($current = $this->dir($hash)) == false) {\n            return false;\n        }\n\n        $args = func_get_args();\n        // checks 3rd param `$until` (elFinder >= 2.1.24)\n        $until = '';\n        if (isset($args[2])) {\n            $until = $args[2];\n        }\n\n        $path = $this->decode($hash);\n        $tree = array();\n\n        while ($path && $path != $this->root) {\n            elFinder::checkAborted();\n            $path = $this->dirnameCE($path);\n            if (!($stat = $this->stat($path)) || !empty($stat['hidden']) || !$stat['read']) {\n                return false;\n            }\n\n            array_unshift($tree, $stat);\n            if (!$lineal) {\n                foreach ($this->gettree($path, 0) as $dir) {\n                    elFinder::checkAborted();\n                    if (!isset($tree[$dir['hash']])) {\n                        $tree[$dir['hash']] = $dir;\n                    }\n                }\n            }\n\n            if ($until && $until === $this->encode($path)) {\n                break;\n            }\n        }\n\n        return $tree ? array_values($tree) : array($current);\n    }\n\n    /**\n     * Create thumbnail for required file and return its name or false on failed\n     *\n     * @param $hash\n     *\n     * @return false|string\n     * @throws ImagickException\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    public function tmb($hash)\n    {\n        $path = $this->decode($hash);\n        $stat = $this->stat($path);\n\n        if (isset($stat['tmb'])) {\n            $res = $stat['tmb'] == \"1\" ? $this->createTmb($path, $stat) : $stat['tmb'];\n            if (!$res) {\n                list($type) = explode('/', $stat['mime']);\n                $fallback = $this->options['resourcePath'] . DIRECTORY_SEPARATOR . strtolower($type) . '.png';\n                if (is_file($fallback)) {\n                    $res = $this->tmbname($stat);\n                    if (!copy($fallback, $this->tmbPath . DIRECTORY_SEPARATOR . $res)) {\n                        $res = false;\n                    }\n                }\n            }\n            // tmb garbage collection\n            if ($res && $this->options['tmbGcMaxlifeHour'] && $this->options['tmbGcPercentage'] > 0) {\n                $rand = mt_rand(1, 10000);\n                if ($rand <= $this->options['tmbGcPercentage'] * 100) {\n                    register_shutdown_function(array('elFinder', 'GlobGC'), $this->tmbPath . DIRECTORY_SEPARATOR . '*.png', $this->options['tmbGcMaxlifeHour'] * 3600);\n                }\n            }\n            return $res;\n        }\n        return false;\n    }\n\n    /**\n     * Return file size / total directory size\n     *\n     * @param  string   file hash\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    public function size($hash)\n    {\n        return $this->countSize($this->decode($hash));\n    }\n\n    /**\n     * Open file for reading and return file pointer\n     *\n     * @param  string   file hash\n     *\n     * @return Resource|false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function open($hash)\n    {\n        if (($file = $this->file($hash)) == false\n            || $file['mime'] == 'directory') {\n            return false;\n        }\n        // check extra option for network stream pointer\n        if (func_num_args() > 1) {\n            $opts = func_get_arg(1);\n        } else {\n            $opts = array();\n        }\n        return $this->fopenCE($this->decode($hash), 'rb', $opts);\n    }\n\n    /**\n     * Close file pointer\n     *\n     * @param  Resource $fp   file pointer\n     * @param  string   $hash file hash\n     *\n     * @return void\n     * @author Dmitry (dio) Levashov\n     **/\n    public function close($fp, $hash)\n    {\n        $this->fcloseCE($fp, $this->decode($hash));\n    }\n\n    /**\n     * Create directory and return dir info\n     *\n     * @param  string $dsthash destination directory hash\n     * @param  string $name    directory name\n     *\n     * @return array|false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function mkdir($dsthash, $name)\n    {\n        if ($this->commandDisabled('mkdir')) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        if (!$this->nameAccepted($name, true)) {\n            return $this->setError(elFinder::ERROR_INVALID_DIRNAME);\n        }\n\n        if (($dir = $this->dir($dsthash)) == false) {\n            return $this->setError(elFinder::ERROR_TRGDIR_NOT_FOUND, '#' . $dsthash);\n        }\n\n        $path = $this->decode($dsthash);\n\n        if (!$dir['write'] || !$this->allowCreate($path, $name, true)) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        $dst = $this->joinPathCE($path, $name);\n        $stat = $this->isNameExists($dst);\n        if (!empty($stat)) {\n            return $this->setError(elFinder::ERROR_EXISTS, $name);\n        }\n        $this->clearcache();\n\n        $mkpath = $this->convEncOut($this->_mkdir($this->convEncIn($path), $this->convEncIn($name)));\n        if ($mkpath) {\n            $this->clearstatcache();\n            $this->updateSubdirsCache($path, true);\n            $this->updateSubdirsCache($mkpath, false);\n        }\n\n        return $mkpath ? $this->stat($mkpath) : false;\n    }\n\n    /**\n     * Create empty file and return its info\n     *\n     * @param  string $dst  destination directory\n     * @param  string $name file name\n     *\n     * @return array|false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function mkfile($dst, $name)\n    {\n        if ($this->commandDisabled('mkfile')) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        if (!$this->nameAccepted($name, false)) {\n            return $this->setError(elFinder::ERROR_INVALID_NAME);\n        }\n\n        $mimeByName = $this->mimetype($name, true);\n        if ($mimeByName && !$this->allowPutMime($mimeByName)) {\n            return $this->setError(elFinder::ERROR_UPLOAD_FILE_MIME, $name);\n        }\n\n        if (($dir = $this->dir($dst)) == false) {\n            return $this->setError(elFinder::ERROR_TRGDIR_NOT_FOUND, '#' . $dst);\n        }\n\n        $path = $this->decode($dst);\n\n        if (!$dir['write'] || !$this->allowCreate($path, $name, false)) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        if ($this->isNameExists($this->joinPathCE($path, $name))) {\n            return $this->setError(elFinder::ERROR_EXISTS, $name);\n        }\n\n        $this->clearcache();\n        $res = false;\n        if ($path = $this->convEncOut($this->_mkfile($this->convEncIn($path), $this->convEncIn($name)))) {\n            $this->clearstatcache();\n            $res = $this->stat($path);\n        }\n        return $res;\n    }\n\n    /**\n     * Rename file and return file info\n     *\n     * @param  string $hash file hash\n     * @param  string $name new file name\n     *\n     * @return array|false\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    public function rename($hash, $name)\n    {\n        if ($this->commandDisabled('rename')) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        if (!($file = $this->file($hash))) {\n            return $this->setError(elFinder::ERROR_FILE_NOT_FOUND);\n        }\n\n        if ($name === $file['name']) {\n            return $file;\n        }\n\n        if (!empty($this->options['netkey']) && !empty($file['isroot'])) {\n            // change alias of netmount root\n            $rootKey = $this->getRootstatCachekey();\n            // delete old cache data\n            if ($this->sessionCaching['rootstat']) {\n                unset($this->sessionCaching['rootstat'][$rootKey]);\n            }\n            if (elFinder::$instance->updateNetVolumeOption($this->options['netkey'], 'alias', $name)) {\n                $this->clearcache();\n                $this->rootName = $this->options['alias'] = $name;\n                return $this->stat($this->root);\n            } else {\n                return $this->setError(elFinder::ERROR_TRGDIR_NOT_FOUND, $name);\n            }\n        }\n\n        if (!empty($file['locked'])) {\n            return $this->setError(elFinder::ERROR_LOCKED, $file['name']);\n        }\n\n        $isDir = ($file['mime'] === 'directory');\n\n        if (!$this->nameAccepted($name, $isDir)) {\n            return $this->setError($isDir ? elFinder::ERROR_INVALID_DIRNAME : elFinder::ERROR_INVALID_NAME);\n        }\n\n        if (!$isDir) {\n            $mimeByName = $this->mimetype($name, true);\n            if ($mimeByName && !$this->allowPutMime($mimeByName)) {\n                return $this->setError(elFinder::ERROR_UPLOAD_FILE_MIME, $name);\n            }\n        }\n\n        $path = $this->decode($hash);\n        $dir = $this->dirnameCE($path);\n        $stat = $this->isNameExists($this->joinPathCE($dir, $name));\n        if ($stat) {\n            return $this->setError(elFinder::ERROR_EXISTS, $name);\n        }\n\n        if (!$this->allowCreate($dir, $name, ($file['mime'] === 'directory'))) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        $this->rmTmb($file); // remove old name tmbs, we cannot do this after dir move\n\n\n        if ($path = $this->convEncOut($this->_move($this->convEncIn($path), $this->convEncIn($dir), $this->convEncIn($name)))) {\n            $this->clearcache();\n            return $this->stat($path);\n        }\n        return false;\n    }\n\n    /**\n     * Create file copy with suffix \"copy number\" and return its info\n     *\n     * @param  string $hash   file hash\n     * @param  string $suffix suffix to add to file name\n     *\n     * @return array|false\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    public function duplicate($hash, $suffix = 'copy')\n    {\n        if ($this->commandDisabled('duplicate')) {\n            return $this->setError(elFinder::ERROR_COPY, '#' . $hash, elFinder::ERROR_PERM_DENIED);\n        }\n\n        if (($file = $this->file($hash)) == false) {\n            return $this->setError(elFinder::ERROR_COPY, elFinder::ERROR_FILE_NOT_FOUND);\n        }\n\n        $path = $this->decode($hash);\n        $dir = $this->dirnameCE($path);\n        $name = $this->uniqueName($dir, $file['name'], sprintf($this->options['duplicateSuffix'], $suffix));\n\n        if (!$this->allowCreate($dir, $name, ($file['mime'] === 'directory'))) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        return ($path = $this->copy($path, $dir, $name)) == false\n            ? false\n            : $this->stat($path);\n    }\n\n    /**\n     * Save uploaded file.\n     * On success return array with new file stat and with removed file hash (if existed file was replaced)\n     *\n     * @param  Resource $fp      file pointer\n     * @param  string   $dst     destination folder hash\n     * @param           $name\n     * @param  string   $tmpname file tmp name - required to detect mime type\n     * @param  array    $hashes  exists files hash array with filename as key\n     *\n     * @return array|false\n     * @throws elFinderAbortException\n     * @internal param string $src file name\n     * @author   Dmitry (dio) Levashov\n     */\n    public function upload($fp, $dst, $name, $tmpname, $hashes = array())\n    {\n        if ($this->commandDisabled('upload')) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        if (($dir = $this->dir($dst)) == false) {\n            return $this->setError(elFinder::ERROR_TRGDIR_NOT_FOUND, '#' . $dst);\n        }\n\n        if (empty($dir['write'])) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        if (!$this->nameAccepted($name, false)) {\n            return $this->setError(elFinder::ERROR_INVALID_NAME);\n        }\n\n        $mimeByName = '';\n        if ($this->mimeDetect === 'internal') {\n            $mime = $this->mimetype($tmpname, $name);\n        } else {\n            $mime = $this->mimetype($tmpname, $name);\n            $mimeByName = $this->mimetype($name, true);\n            if ($mime === 'unknown') {\n                $mime = $mimeByName;\n            }\n        }\n\n        if (!$this->allowPutMime($mime) || ($mimeByName && !$this->allowPutMime($mimeByName))) {\n            return $this->setError(elFinder::ERROR_UPLOAD_FILE_MIME, '(' . $mime . ')');\n        }\n\n        $tmpsize = (int)sprintf('%u', filesize($tmpname));\n        if ($this->uploadMaxSize > 0 && $tmpsize > $this->uploadMaxSize) {\n            return $this->setError(elFinder::ERROR_UPLOAD_FILE_SIZE);\n        }\n\n        $dstpath = $this->decode($dst);\n        if (isset($hashes[$name])) {\n            $test = $this->decode($hashes[$name]);\n            $file = $this->stat($test);\n        } else {\n            $test = $this->joinPathCE($dstpath, $name);\n            $file = $this->isNameExists($test);\n        }\n\n        $this->clearcache();\n\n        if ($file && $file['name'] === $name) { // file exists and check filename for item ID based filesystem\n            if ($this->uploadOverwrite) {\n                if (!$file['write']) {\n                    return $this->setError(elFinder::ERROR_PERM_DENIED);\n                } elseif ($file['mime'] == 'directory') {\n                    return $this->setError(elFinder::ERROR_NOT_REPLACE, $name);\n                }\n                $this->remove($test);\n            } else {\n                $name = $this->uniqueName($dstpath, $name, '-', false);\n            }\n        }\n\n        $stat = array(\n            'mime' => $mime,\n            'width' => 0,\n            'height' => 0,\n            'size' => $tmpsize);\n\n        // $w = $h = 0;\n        if (strpos($mime, 'image') === 0 && ($s = getimagesize($tmpname))) {\n            $stat['width'] = $s[0];\n            $stat['height'] = $s[1];\n        }\n        // $this->clearcache();\n        if (($path = $this->saveCE($fp, $dstpath, $name, $stat)) == false) {\n            return false;\n        }\n\n        $stat = $this->stat($path);\n        // Try get URL\n        if (empty($stat['url']) && ($url = $this->getContentUrl($stat['hash']))) {\n            $stat['url'] = $url;\n        }\n\n        return $stat;\n    }\n\n    /**\n     * Paste files\n     *\n     * @param  Object $volume source volume\n     * @param         $src\n     * @param  string $dst    destination dir hash\n     * @param  bool   $rmSrc  remove source after copy?\n     * @param array   $hashes\n     *\n     * @return array|false\n     * @throws elFinderAbortException\n     * @internal param string $source file hash\n     * @author   Dmitry (dio) Levashov\n     */\n    public function paste($volume, $src, $dst, $rmSrc = false, $hashes = array())\n    {\n        $err = $rmSrc ? elFinder::ERROR_MOVE : elFinder::ERROR_COPY;\n\n        if ($this->commandDisabled('paste')) {\n            return $this->setError($err, '#' . $src, elFinder::ERROR_PERM_DENIED);\n        }\n\n        if (($file = $volume->file($src, $rmSrc)) == false) {\n            return $this->setError($err, '#' . $src, elFinder::ERROR_FILE_NOT_FOUND);\n        }\n\n        $name = $file['name'];\n        $errpath = $volume->path($file['hash']);\n\n        if (($dir = $this->dir($dst)) == false) {\n            return $this->setError($err, $errpath, elFinder::ERROR_TRGDIR_NOT_FOUND, '#' . $dst);\n        }\n\n        if (!$dir['write'] || !$file['read']) {\n            return $this->setError($err, $errpath, elFinder::ERROR_PERM_DENIED);\n        }\n\n        $destination = $this->decode($dst);\n\n        if (($test = $volume->closest($src, $rmSrc ? 'locked' : 'read', $rmSrc))) {\n            return $rmSrc\n                ? $this->setError($err, $errpath, elFinder::ERROR_LOCKED, $volume->path($test))\n                : $this->setError($err, $errpath, empty($file['thash']) ? elFinder::ERROR_PERM_DENIED : elFinder::ERROR_MKOUTLINK);\n        }\n\n        if (isset($hashes[$name])) {\n            $test = $this->decode($hashes[$name]);\n            $stat = $this->stat($test);\n        } else {\n            $test = $this->joinPathCE($destination, $name);\n            $stat = $this->isNameExists($test);\n        }\n        $this->clearcache();\n        $dstDirExists = false;\n        if ($stat && $stat['name'] === $name) { // file exists and check filename for item ID based filesystem\n            if ($this->options['copyOverwrite']) {\n                // do not replace file with dir or dir with file\n                if (!$this->isSameType($file['mime'], $stat['mime'])) {\n                    return $this->setError(elFinder::ERROR_NOT_REPLACE, $this->path($stat['hash']));\n                }\n                // existed file is not writable\n                if (empty($stat['write'])) {\n                    return $this->setError($err, $errpath, elFinder::ERROR_PERM_DENIED);\n                }\n                if ($this->options['copyJoin']) {\n                    if (!empty($stat['locked'])) {\n                        return $this->setError(elFinder::ERROR_LOCKED, $this->path($stat['hash']));\n                    }\n                } else {\n                    // existed file locked or has locked child\n                    if (($locked = $this->closestByAttr($test, 'locked', true))) {\n                        $stat = $this->stat($locked);\n                        return $this->setError(elFinder::ERROR_LOCKED, $this->path($stat['hash']));\n                    }\n                }\n                // target is entity file of alias\n                if ($volume === $this && ((isset($file['target']) && $test == $file['target']) || $test == $this->decode($src))) {\n                    return $this->setError(elFinder::ERROR_REPLACE, $errpath);\n                }\n                // remove existed file\n                if (!$this->options['copyJoin'] || $stat['mime'] !== 'directory') {\n                    if (!$this->remove($test)) {\n                        return $this->setError(elFinder::ERROR_REPLACE, $this->path($stat['hash']));\n                    }\n                } else if ($stat['mime'] === 'directory') {\n                    $dstDirExists = true;\n                }\n            } else {\n                $name = $this->uniqueName($destination, $name, ' ', false);\n            }\n        }\n\n        // copy/move inside current volume\n        if ($volume === $this) { //  changing == operand to === fixes issue #1285 - Paul Canning 24/03/2016\n            $source = $this->decode($src);\n            // do not copy into itself\n            if ($this->inpathCE($destination, $source)) {\n                return $this->setError(elFinder::ERROR_COPY_ITSELF, $errpath);\n            }\n            $rmDir = false;\n            if ($rmSrc) {\n                if ($dstDirExists) {\n                    $rmDir = true;\n                    $method = 'copy';\n                } else {\n                    $method = 'move';\n                }\n            } else {\n                $method = 'copy';\n            }\n            $this->clearcache();\n            if ($res = ($path = $this->$method($source, $destination, $name)) ? $this->stat($path) : false) {\n                if ($rmDir) {\n                    $this->remove($source);\n                }\n            } else {\n                return false;\n            }\n        } else {\n            // copy/move from another volume\n            if (!$this->options['copyTo'] || !$volume->copyFromAllowed()) {\n                return $this->setError(elFinder::ERROR_COPY, $errpath, elFinder::ERROR_PERM_DENIED);\n            }\n\n            $this->error = array();\n            if (($path = $this->copyFrom($volume, $src, $destination, $name)) == false) {\n                return false;\n            }\n\n            if ($rmSrc && !$this->error()) {\n                if (!$volume->rm($src)) {\n                    if ($volume->file($src)) {\n                        $this->addError(elFinder::ERROR_RM_SRC);\n                    } else {\n                        $this->removed[] = $file;\n                    }\n                }\n            }\n            $res = $this->stat($path);\n        }\n        return $res;\n    }\n\n    /**\n     * Return path info array to archive of target items\n     *\n     * @param  array $hashes\n     *\n     * @return array|false\n     * @throws Exception\n     * @author Naoki Sawada\n     */\n    public function zipdl($hashes)\n    {\n        if ($this->commandDisabled('zipdl')) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        $archivers = $this->getArchivers();\n        $cmd = null;\n        if (!$archivers || empty($archivers['create'])) {\n            return false;\n        }\n        $archivers = $archivers['create'];\n        if (!$archivers) {\n            return false;\n        }\n        $file = $mime = '';\n        foreach (array('zip', 'tgz') as $ext) {\n            $mime = $this->mimetype('file.' . $ext, true);\n            if (isset($archivers[$mime])) {\n                $cmd = $archivers[$mime];\n                break;\n            }\n        }\n        if (!$cmd) {\n            $cmd = array_shift($archivers);\n            if (!empty($ext)) {\n                $mime = $this->mimetype('file.' . $ext, true);\n            }\n        }\n        $ext = $cmd['ext'];\n        $res = false;\n        $mixed = false;\n        $hashes = array_values($hashes);\n        $dirname = dirname(str_replace($this->separator, DIRECTORY_SEPARATOR, $this->path($hashes[0])));\n        $cnt = count($hashes);\n        if ($cnt > 1) {\n            for ($i = 1; $i < $cnt; $i++) {\n                if ($dirname !== dirname(str_replace($this->separator, DIRECTORY_SEPARATOR, $this->path($hashes[$i])))) {\n                    $mixed = true;\n                    break;\n                }\n            }\n        }\n        if ($mixed || $this->root == $this->dirnameCE($this->decode($hashes[0]))) {\n            $prefix = $this->rootName;\n        } else {\n            $prefix = basename($dirname);\n        }\n        if ($dir = $this->getItemsInHand($hashes)) {\n            $tmppre = (substr(PHP_OS, 0, 3) === 'WIN') ? 'zd-' : 'elfzdl-';\n            $pdir = dirname($dir);\n            // garbage collection (expire 2h)\n            register_shutdown_function(array('elFinder', 'GlobGC'), $pdir . DIRECTORY_SEPARATOR . $tmppre . '*', 7200);\n            $files = self::localScandir($dir);\n            if ($files && ($arc = tempnam($dir, $tmppre))) {\n                unlink($arc);\n                $arc = $arc . '.' . $ext;\n                $name = basename($arc);\n                if ($arc = $this->makeArchive($dir, $files, $name, $cmd)) {\n                    $file = tempnam($pdir, $tmppre);\n                    unlink($file);\n                    $res = rename($arc, $file);\n                    $this->rmdirRecursive($dir);\n                }\n            }\n        }\n        return $res ? array('path' => $file, 'ext' => $ext, 'mime' => $mime, 'prefix' => $prefix) : false;\n    }\n\n    /**\n     * Return file contents\n     *\n     * @param  string $hash file hash\n     *\n     * @return string|false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function getContents($hash)\n    {\n        $file = $this->file($hash);\n\n        if (!$file) {\n            return $this->setError(elFinder::ERROR_FILE_NOT_FOUND);\n        }\n\n        if ($file['mime'] == 'directory') {\n            return $this->setError(elFinder::ERROR_NOT_FILE);\n        }\n\n        if (!$file['read']) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        if ($this->getMaxSize > 0 && $file['size'] > $this->getMaxSize) {\n            return $this->setError(elFinder::ERROR_UPLOAD_FILE_SIZE);\n        }\n\n        return $file['size'] ? $this->_getContents($this->convEncIn($this->decode($hash), true)) : '';\n    }\n\n    /**\n     * Put content in text file and return file info.\n     *\n     * @param  string $hash    file hash\n     * @param  string $content new file content\n     *\n     * @return array|false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function putContents($hash, $content)\n    {\n        if ($this->commandDisabled('edit')) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        $path = $this->decode($hash);\n\n        if (!($file = $this->file($hash))) {\n            return $this->setError(elFinder::ERROR_FILE_NOT_FOUND);\n        }\n\n        if (!$file['write']) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        // check data cheme\n        if (preg_match('~^\\0data:(.+?/.+?);base64,~', $content, $m)) {\n            $dMime = $m[1];\n            if ($file['size'] > 0 && $dMime !== $file['mime']) {\n                return $this->setError(elFinder::ERROR_PERM_DENIED);\n            }\n            $content = base64_decode(substr($content, strlen($m[0])));\n        }\n\n        // check MIME\n        $name = $this->basenameCE($path);\n        $mime = '';\n        $mimeByName = $this->mimetype($name, true);\n        if ($this->mimeDetect !== 'internal') {\n            if ($tp = $this->tmpfile()) {\n                fwrite($tp, $content);\n                $info = stream_get_meta_data($tp);\n                $filepath = $info['uri'];\n                $mime = $this->mimetype($filepath, $name);\n                fclose($tp);\n            }\n        }\n        if (!$this->allowPutMime($mimeByName) || ($mime && !$this->allowPutMime($mime))) {\n            return $this->setError(elFinder::ERROR_UPLOAD_FILE_MIME);\n        }\n\n        $this->clearcache();\n        $res = false;\n        if ($this->convEncOut($this->_filePutContents($this->convEncIn($path), $content))) {\n            $this->rmTmb($file);\n            $this->clearstatcache();\n            $res = $this->stat($path);\n        }\n        return $res;\n    }\n\n    /**\n     * Extract files from archive\n     *\n     * @param  string $hash archive hash\n     * @param null    $makedir\n     *\n     * @return array|bool\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     */\n    public function extract($hash, $makedir = null)\n    {\n        if ($this->commandDisabled('extract')) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        if (($file = $this->file($hash)) == false) {\n            return $this->setError(elFinder::ERROR_FILE_NOT_FOUND);\n        }\n\n        $archiver = isset($this->archivers['extract'][$file['mime']])\n            ? $this->archivers['extract'][$file['mime']]\n            : array();\n\n        if (!$archiver) {\n            return $this->setError(elFinder::ERROR_NOT_ARCHIVE);\n        }\n\n        $path = $this->decode($hash);\n        $parent = $this->stat($this->dirnameCE($path));\n\n        if (!$file['read'] || !$parent['write']) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n        $this->clearcache();\n        $this->extractToNewdir = is_null($makedir) ? 'auto' : (bool)$makedir;\n\n        if ($path = $this->convEncOut($this->_extract($this->convEncIn($path), $archiver))) {\n            if (is_array($path)) {\n                foreach ($path as $_k => $_p) {\n                    $path[$_k] = $this->stat($_p);\n                }\n            } else {\n                $path = $this->stat($path);\n            }\n            return $path;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Add files to archive\n     *\n     * @param        $hashes\n     * @param        $mime\n     * @param string $name\n     *\n     * @return array|bool\n     * @throws Exception\n     */\n    public function archive($hashes, $mime, $name = '')\n    {\n        if ($this->commandDisabled('archive')) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        if ($name !== '' && !$this->nameAccepted($name, false)) {\n            return $this->setError(elFinder::ERROR_INVALID_NAME);\n        }\n\n        $archiver = isset($this->archivers['create'][$mime])\n            ? $this->archivers['create'][$mime]\n            : array();\n\n        if (!$archiver) {\n            return $this->setError(elFinder::ERROR_ARCHIVE_TYPE);\n        }\n\n        $files = array();\n        $useRemoteArchive = !empty($this->options['useRemoteArchive']);\n\n        $dir = '';\n        foreach ($hashes as $hash) {\n            if (($file = $this->file($hash)) == false) {\n                return $this->setError(elFinder::ERROR_FILE_NOT_FOUND, '#' . $hash);\n            }\n            if (!$file['read']) {\n                return $this->setError(elFinder::ERROR_PERM_DENIED);\n            }\n            $path = $this->decode($hash);\n            if ($dir === '') {\n                $dir = $this->dirnameCE($path);\n                $stat = $this->stat($dir);\n                if (!$stat['write']) {\n                    return $this->setError(elFinder::ERROR_PERM_DENIED);\n                }\n            }\n\n            $files[] = $useRemoteArchive ? $hash : $this->basenameCE($path);\n        }\n\n        if ($name === '') {\n            $name = count($files) == 1 ? $files[0] : 'Archive';\n        } else {\n            $name = str_replace(array('/', '\\\\'), '_', preg_replace('/\\.' . preg_quote($archiver['ext'], '/') . '$/i', '', $name));\n        }\n        $name .= '.' . $archiver['ext'];\n        $name = $this->uniqueName($dir, $name, '');\n        $this->clearcache();\n        if ($useRemoteArchive) {\n            return ($path = $this->remoteArchive($files, $name, $archiver)) ? $this->stat($path) : false;\n        } else {\n            return ($path = $this->convEncOut($this->_archive($this->convEncIn($dir), $this->convEncIn($files), $this->convEncIn($name), $archiver))) ? $this->stat($path) : false;\n        }\n    }\n\n    /**\n     * Create an archive from remote items\n     *\n     * @param      array  $hashes files hashes list\n     * @param      string $name   archive name\n     * @param      array  $arc    archiver options\n     *\n     * @return     string|boolean  path of created archive\n     * @throws     Exception\n     */\n    protected function remoteArchive($hashes, $name, $arc)\n    {\n        $resPath = false;\n        $file0 = $this->file($hashes[0]);\n        if ($file0 && ($dir = $this->getItemsInHand($hashes))) {\n            $files = self::localScandir($dir);\n            if ($files) {\n                if ($arc = $this->makeArchive($dir, $files, $name, $arc)) {\n                    if ($fp = fopen($arc, 'rb')) {\n                        $fstat = stat($arc);\n                        $stat = array(\n                            'size' => $fstat['size'],\n                            'ts' => $fstat['mtime'],\n                            'mime' => $this->mimetype($arc, $name)\n                        );\n                        $path = $this->decode($file0['phash']);\n                        $resPath = $this->saveCE($fp, $path, $name, $stat);\n                        fclose($fp);\n                    }\n                }\n            }\n            $this->rmdirRecursive($dir);\n        }\n        return $resPath;\n    }\n\n    /**\n     * Resize image\n     *\n     * @param  string $hash       image file\n     * @param  int    $width      new width\n     * @param  int    $height     new height\n     * @param  int    $x          X start poistion for crop\n     * @param  int    $y          Y start poistion for crop\n     * @param  string $mode       action how to mainpulate image\n     * @param  string $bg         background color\n     * @param  int    $degree     rotete degree\n     * @param  int    $jpgQuality JEPG quality (1-100)\n     *\n     * @return array|false\n     * @throws ImagickException\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     * @author Alexey Sukhotin\n     * @author nao-pon\n     * @author Troex Nevelin\n     */\n    public function resize($hash, $width, $height, $x, $y, $mode = 'resize', $bg = '', $degree = 0, $jpgQuality = null)\n    {\n        if ($this->commandDisabled('resize')) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        if ($mode === 'rotate' && $degree == 0) {\n            return array('losslessRotate' => ($this->procExec(ELFINDER_EXIFTRAN_PATH . ' -h') === 0 || $this->procExec(ELFINDER_JPEGTRAN_PATH . ' -version') === 0));\n        }\n\n        if (($file = $this->file($hash)) == false) {\n            return $this->setError(elFinder::ERROR_FILE_NOT_FOUND);\n        }\n\n        if (!$file['write'] || !$file['read']) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        $path = $this->decode($hash);\n\n        $work_path = $this->getWorkFile($this->encoding ? $this->convEncIn($path, true) : $path);\n\n        if (!$work_path || !is_writable($work_path)) {\n            if ($work_path && $path !== $work_path && is_file($work_path)) {\n                unlink($work_path);\n            }\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        if ($this->imgLib !== 'imagick' && $this->imgLib !== 'convert') {\n            if (elFinder::isAnimationGif($work_path)) {\n                return $this->setError(elFinder::ERROR_UNSUPPORT_TYPE);\n            }\n        }\n\n        if (elFinder::isAnimationPng($work_path)) {\n            return $this->setError(elFinder::ERROR_UNSUPPORT_TYPE);\n        }\n\n        switch ($mode) {\n\n            case 'propresize':\n                $result = $this->imgResize($work_path, $width, $height, true, true, null, $jpgQuality);\n                break;\n\n            case 'crop':\n                $result = $this->imgCrop($work_path, $width, $height, $x, $y, null, $jpgQuality);\n                break;\n\n            case 'fitsquare':\n                $result = $this->imgSquareFit($work_path, $width, $height, 'center', 'middle', ($bg ? $bg : $this->options['tmbBgColor']), null, $jpgQuality);\n                break;\n\n            case 'rotate':\n                $result = $this->imgRotate($work_path, $degree, ($bg ? $bg : $this->options['bgColorFb']), null, $jpgQuality);\n                break;\n\n            default:\n                $result = $this->imgResize($work_path, $width, $height, false, true, null, $jpgQuality);\n                break;\n        }\n\n        $ret = false;\n        if ($result) {\n            $this->rmTmb($file);\n            $this->clearstatcache();\n            $fstat = stat($work_path);\n            $imgsize = getimagesize($work_path);\n            if ($path !== $work_path) {\n                $file['size'] = $fstat['size'];\n                $file['ts'] = $fstat['mtime'];\n                if ($imgsize) {\n                    $file['width'] = $imgsize[0];\n                    $file['height'] = $imgsize[1];\n                }\n                if ($fp = fopen($work_path, 'rb')) {\n                    $ret = $this->saveCE($fp, $this->dirnameCE($path), $this->basenameCE($path), $file);\n                    fclose($fp);\n                }\n            } else {\n                $ret = true;\n            }\n            if ($ret) {\n                $this->clearcache();\n                $ret = $this->stat($path);\n                if ($imgsize) {\n                    $ret['width'] = $imgsize[0];\n                    $ret['height'] = $imgsize[1];\n                }\n            }\n        }\n        if ($path !== $work_path) {\n            is_file($work_path) && unlink($work_path);\n        }\n\n        return $ret;\n    }\n\n    /**\n     * Remove file/dir\n     *\n     * @param  string $hash file hash\n     *\n     * @return bool\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    public function rm($hash)\n    {\n        return $this->commandDisabled('rm')\n            ? $this->setError(elFinder::ERROR_PERM_DENIED)\n            : $this->remove($this->decode($hash));\n    }\n\n    /**\n     * Search files\n     *\n     * @param  string $q search string\n     * @param  array  $mimes\n     * @param null    $hash\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    public function search($q, $mimes, $hash = null)\n    {\n        $res = array();\n        $matchMethod = null;\n        $args = func_get_args();\n        if (!empty($args[3])) {\n            $matchMethod = 'searchMatch' . $args[3];\n            if (!is_callable(array($this, $matchMethod))) {\n                return array();\n            }\n        }\n\n        $dir = null;\n        if ($hash) {\n            $dir = $this->decode($hash);\n            $stat = $this->stat($dir);\n            if (!$stat || $stat['mime'] !== 'directory' || !$stat['read']) {\n                $q = '';\n            }\n        }\n        if ($mimes && $this->onlyMimes) {\n            $mimes = array_intersect($mimes, $this->onlyMimes);\n            if (!$mimes) {\n                $q = '';\n            }\n        }\n        $this->searchStart = time();\n\n        $qs = preg_split('/\"([^\"]+)\"| +/', $q, -1, PREG_SPLIT_NO_EMPTY | PREG_SPLIT_DELIM_CAPTURE);\n        $query = $excludes = array();\n        foreach ($qs as $_q) {\n            $_q = trim($_q);\n            if ($_q !== '') {\n                if ($_q[0] === '-') {\n                    if (isset($_q[1])) {\n                        $excludes[] = substr($_q, 1);\n                    }\n                } else {\n                    $query[] = $_q;\n                }\n            }\n        }\n        if (!$query) {\n            $q = '';\n        } else {\n            $q = join(' ', $query);\n            $this->doSearchCurrentQuery = array(\n                'q' => $q,\n                'excludes' => $excludes,\n                'matchMethod' => $matchMethod\n            );\n        }\n\n        if ($q === '' || $this->commandDisabled('search')) {\n            return $res;\n        }\n\n        // valided regex $this->options['searchExDirReg']\n        if ($this->options['searchExDirReg']) {\n            if (false === preg_match($this->options['searchExDirReg'], '')) {\n                $this->options['searchExDirReg'] = '';\n            }\n        }\n\n        // check the leaf root too\n        if (!$mimes && (is_null($dir) || $dir == $this->root)) {\n            $rootStat = $this->stat($this->root);\n            if (!empty($rootStat['phash'])) {\n                if ($this->stripos($rootStat['name'], $q) !== false) {\n                    $res = array($rootStat);\n                }\n            }\n        }\n\n        return array_merge($res, $this->doSearch(is_null($dir) ? $this->root : $dir, $q, $mimes));\n    }\n\n    /**\n     * Return image dimensions\n     *\n     * @param  string $hash file hash\n     *\n     * @return array|string\n     * @author Dmitry (dio) Levashov\n     **/\n    public function dimensions($hash)\n    {\n        if (($file = $this->file($hash)) == false) {\n            return false;\n        }\n        // Throw additional parameters for some drivers\n        if (func_num_args() > 1) {\n            $args = func_get_arg(1);\n        } else {\n            $args = array();\n        }\n        return $this->convEncOut($this->_dimensions($this->convEncIn($this->decode($hash)), $file['mime'], $args));\n    }\n\n    /**\n     * Return has subdirs\n     *\n     * @param  string $hash file hash\n     *\n     * @return bool\n     * @author Naoki Sawada\n     **/\n    public function subdirs($hash)\n    {\n        return (bool)$this->subdirsCE($this->decode($hash));\n    }\n\n    /**\n     * Return content URL (for netmout volume driver)\n     * If file.url == 1 requests from JavaScript client with XHR\n     *\n     * @param string $hash    file hash\n     * @param array  $options options array\n     *\n     * @return boolean|string\n     * @author Naoki Sawada\n     */\n    public function getContentUrl($hash, $options = array())\n    {\n        if (($file = $this->file($hash)) === false) {\n            return false;\n        }\n        if (!empty($options['onetime']) && $this->options['onetimeUrl']) {\n            if (is_callable($this->options['onetimeUrl'])) {\n                return call_user_func_array($this->options['onetimeUrl'], array($file, $options, $this));\n            } else {\n                $ret = false;\n                if ($tmpdir = elFinder::getStaticVar('commonTempPath')) {\n                    if ($source = $this->open($hash)) {\n                        if ($_dat = tempnam($tmpdir, 'ELF')) {\n                            $token = md5($_dat . session_id());\n                            $dat = $tmpdir . DIRECTORY_SEPARATOR . 'ELF' . $token;\n                            if (rename($_dat, $dat)) {\n                                $info = stream_get_meta_data($source);\n                                if (!empty($info['uri'])) {\n                                    $tmp = $info['uri'];\n                                } else {\n                                    $tmp = tempnam($tmpdir, 'ELF');\n                                    if ($dest = fopen($tmp, 'wb')) {\n                                        if (!stream_copy_to_stream($source, $dest)) {\n                                            $tmp = false;\n                                        }\n                                        fclose($dest);\n                                    }\n                                }\n                                $this->close($source, $hash);\n                                if ($tmp) {\n                                    $info = array(\n                                        'file' => base64_encode($tmp),\n                                        'name' => $file['name'],\n                                        'mime' => $file['mime'],\n                                        'ts' => $file['ts']\n                                    );\n                                    if (file_put_contents($dat, json_encode($info))) {\n                                        $conUrl = elFinder::getConnectorUrl();\n                                        $ret = $conUrl . (strpos($conUrl, '?') !== false? '&' : '?') . 'cmd=file&onetime=1&target=' . $token;\n\n                                    }\n                                }\n                                if (!$ret) {\n                                    unlink($dat);\n                                }\n                            } else {\n                                unlink($_dat);\n                            }\n                        }\n                    }\n                }\n                return $ret;\n            }\n        }\n        if (empty($file['url']) && $this->URL) {\n            $path = str_replace($this->separator, '/', substr($this->decode($hash), strlen(rtrim($this->root, '/' . $this->separator)) + 1));\n            if ($this->encoding) {\n                $path = $this->convEncIn($path, true);\n            }\n            $path = str_replace('%2F', '/', rawurlencode($path));\n            return $this->URL . $path;\n        } else {\n            $ret = false;\n            if (!empty($file['url']) && $file['url'] != 1) {\n                return $file['url'];\n            } else if (!empty($options['temporary']) && ($tempInfo = $this->getTempLinkInfo('temp_' . md5($hash . session_id())))) {\n                if (is_readable($tempInfo['path'])) {\n                    touch($tempInfo['path']);\n                    $ret = $tempInfo['url'] . '?' . rawurlencode($file['name']);\n                } else if ($source = $this->open($hash)) {\n                    if ($dest = fopen($tempInfo['path'], 'wb')) {\n                        if (stream_copy_to_stream($source, $dest)) {\n                            $ret = $tempInfo['url'] . '?' . rawurlencode($file['name']);\n                        }\n                        fclose($dest);\n                    }\n                    $this->close($source, $hash);\n                }\n            }\n            return $ret;\n        }\n    }\n\n    /**\n     * Get temporary contents link infomation\n     *\n     * @param string $name\n     *\n     * @return boolean|array\n     * @author Naoki Sawada\n     */\n    public function getTempLinkInfo($name = null)\n    {\n        if ($this->tmpLinkPath) {\n            if (!$name) {\n                $name = 'temp_' . md5($_SERVER['REMOTE_ADDR'] . (string)microtime(true));\n            } else if (substr($name, 0, 5) !== 'temp_') {\n                $name = 'temp_' . $name;\n            }\n            register_shutdown_function(array('elFinder', 'GlobGC'), $this->tmpLinkPath . DIRECTORY_SEPARATOR . 'temp_*', elFinder::$tmpLinkLifeTime);\n            return array(\n                'path' => $path = $this->tmpLinkPath . DIRECTORY_SEPARATOR . $name,\n                'url' => $this->tmpLinkUrl . '/' . rawurlencode($name)\n            );\n        }\n        return false;\n    }\n\n    /**\n     * Get URL of substitute image by request args `substitute` or 4th argument $maxSize\n     *\n     * @param string   $target  Target hash\n     * @param array    $srcSize Size info array [width, height]\n     * @param resource $srcfp   Source file file pointer\n     * @param integer  $maxSize Maximum pixel of substitute image\n     *\n     * @return boolean\n     * @throws ImagickException\n     * @throws elFinderAbortException\n     */\n    public function getSubstituteImgLink($target, $srcSize, $srcfp = null, $maxSize = null)\n    {\n        $url = false;\n        $file = $this->file($target);\n        $force = !in_array($file['mime'], array('image/jpeg', 'image/png', 'image/gif'));\n        if (!$maxSize) {\n            $args = elFinder::$currentArgs;\n            if (!empty($args['substitute'])) {\n                $maxSize = $args['substitute'];\n            }\n        }\n        if ($maxSize && $srcSize[0] && $srcSize[1]) {\n            if ($this->getOption('substituteImg')) {\n                $maxSize = intval($maxSize);\n                $zoom = min(($maxSize / $srcSize[0]), ($maxSize / $srcSize[1]));\n                if ($force || $zoom < 1) {\n                    $width = round($srcSize[0] * $zoom);\n                    $height = round($srcSize[1] * $zoom);\n                    $jpgQuality = 50;\n                    $preserveExif = false;\n                    $unenlarge = true;\n                    $checkAnimated = true;\n                    $destformat = $file['mime'] === 'image/jpeg'? null : 'png';\n                    if (!$srcfp) {\n                        elFinder::checkAborted();\n                        $srcfp = $this->open($target);\n                    }\n                    if ($srcfp && ($tempLink = $this->getTempLinkInfo())) {\n                        elFinder::checkAborted();\n                        $dest = fopen($tempLink['path'], 'wb');\n                        if ($dest && stream_copy_to_stream($srcfp, $dest)) {\n                            fclose($dest);\n                            if ($this->imageUtil('resize', $tempLink['path'], compact('width', 'height', 'jpgQuality', 'preserveExif', 'unenlarge', 'checkAnimated', 'destformat'))) {\n                                $url = $tempLink['url'];\n                                // set expire to 1 min left\n                                touch($tempLink['path'], time() - elFinder::$tmpLinkLifeTime + 60);\n                            } else {\n                                unlink($tempLink['path']);\n                            }\n                        }\n                        $this->close($srcfp, $target);\n                    }\n                }\n            }\n        }\n\n        return $url;\n    }\n\n    /**\n     * Return temp path\n     *\n     * @return string\n     * @author Naoki Sawada\n     */\n    public function getTempPath()\n    {\n        $tempPath = null;\n        if (isset($this->tmpPath) && $this->tmpPath && is_writable($this->tmpPath)) {\n            $tempPath = $this->tmpPath;\n        } else if (isset($this->tmp) && $this->tmp && is_writable($this->tmp)) {\n            $tempPath = $this->tmp;\n        } else if (elFinder::getStaticVar('commonTempPath') && is_writable(elFinder::getStaticVar('commonTempPath'))) {\n            $tempPath = elFinder::getStaticVar('commonTempPath');\n        } else if (function_exists('sys_get_temp_dir')) {\n            $tempPath = sys_get_temp_dir();\n        } else if ($this->tmbPathWritable) {\n            $tempPath = $this->tmbPath;\n        }\n        if ($tempPath && DIRECTORY_SEPARATOR !== '/') {\n            $tempPath = str_replace('/', DIRECTORY_SEPARATOR, $tempPath);\n        }\n        return $tempPath;\n    }\n\n    /**\n     * (Make &) Get upload taget dirctory hash\n     *\n     * @param string $baseTargetHash\n     * @param string $path\n     * @param array  $result\n     *\n     * @return boolean|string\n     * @author Naoki Sawada\n     */\n    public function getUploadTaget($baseTargetHash, $path, & $result)\n    {\n        $base = $this->decode($baseTargetHash);\n        $targetHash = $baseTargetHash;\n        $path = ltrim($path, $this->separator);\n        $dirs = explode($this->separator, $path);\n        array_pop($dirs);\n        foreach ($dirs as $dir) {\n            $targetPath = $this->joinPathCE($base, $dir);\n            if (!$_realpath = $this->realpath($this->encode($targetPath))) {\n                if ($stat = $this->mkdir($targetHash, $dir)) {\n                    $result['added'][] = $stat;\n                    $targetHash = $stat['hash'];\n                    $base = $this->decode($targetHash);\n                } else {\n                    return false;\n                }\n            } else {\n                $targetHash = $this->encode($_realpath);\n                if ($this->dir($targetHash)) {\n                    $base = $this->decode($targetHash);\n                } else {\n                    return false;\n                }\n            }\n        }\n        return $targetHash;\n    }\n\n    /**\n     * Return this uploadMaxSize value\n     *\n     * @return integer\n     * @author Naoki Sawada\n     */\n    public function getUploadMaxSize()\n    {\n        return $this->uploadMaxSize;\n    }\n\n    public function setUploadOverwrite($var)\n    {\n        $this->uploadOverwrite = (bool)$var;\n    }\n\n    /**\n     * Image file utility\n     *\n     * @param string $mode    'resize', 'rotate', 'propresize', 'crop', 'fitsquare'\n     * @param string $src     Image file local path\n     * @param array  $options excute options\n     *\n     * @return bool\n     * @throws ImagickException\n     * @throws elFinderAbortException\n     * @author Naoki Sawada\n     */\n    public function imageUtil($mode, $src, $options = array())\n    {\n        if (!isset($options['jpgQuality'])) {\n            $options['jpgQuality'] = intval($this->options['jpgQuality']);\n        }\n        if (!isset($options['bgcolor'])) {\n            $options['bgcolor'] = '#ffffff';\n        }\n        if (!isset($options['bgColorFb'])) {\n            $options['bgColorFb'] = $this->options['bgColorFb'];\n        }\n        $destformat = !empty($options['destformat'])? $options['destformat'] : null;\n\n        // check 'width' ,'height'\n        if (in_array($mode, array('resize', 'propresize', 'crop', 'fitsquare'))) {\n            if (empty($options['width']) || empty($options['height'])) {\n                return false;\n            }\n        }\n\n        if (!empty($options['checkAnimated'])) {\n            if ($this->imgLib !== 'imagick' && $this->imgLib !== 'convert') {\n                if (elFinder::isAnimationGif($src)) {\n                    return false;\n                }\n            }\n            if (elFinder::isAnimationPng($src)) {\n                return false;\n            }\n        }\n\n        switch ($mode) {\n            case 'rotate':\n                if (empty($options['degree'])) {\n                    return true;\n                }\n                return (bool)$this->imgRotate($src, $options['degree'], $options['bgColorFb'], $destformat, $options['jpgQuality']);\n\n            case 'resize':\n                return (bool)$this->imgResize($src, $options['width'], $options['height'], false, true, $destformat, $options['jpgQuality'], $options);\n\n            case 'propresize':\n                return (bool)$this->imgResize($src, $options['width'], $options['height'], true, true, $destformat, $options['jpgQuality'], $options);\n\n            case 'crop':\n                if (isset($options['x']) && isset($options['y'])) {\n                    return (bool)$this->imgCrop($src, $options['width'], $options['height'], $options['x'], $options['y'], $destformat, $options['jpgQuality']);\n                }\n                break;\n\n            case 'fitsquare':\n                return (bool)$this->imgSquareFit($src, $options['width'], $options['height'], 'center', 'middle', $options['bgcolor'], $destformat, $options['jpgQuality']);\n\n        }\n        return false;\n    }\n\n    /**\n     * Convert Video To Image by ffmpeg\n     *\n     * @param  string $file video source file path\n     * @param  array  $stat file stat array\n     * @param  object $self volume driver object\n     * @param  int    $ss   start seconds\n     *\n     * @return bool\n     * @throws elFinderAbortException\n     * @author Naoki Sawada\n     */\n    public function ffmpegToImg($file, $stat, $self, $ss = null)\n    {\n        $name = basename($file);\n        $path = dirname($file);\n        $tmp = $path . DIRECTORY_SEPARATOR . md5($name);\n        // register auto delete on shutdown\n        $GLOBALS['elFinderTempFiles'][$tmp] = true;\n        if (rename($file, $tmp)) {\n            if ($ss === null) {\n                // specific start time by file name (xxx^[sec].[extention] - video^3.mp4)\n                if (preg_match('/\\^(\\d+(?:\\.\\d+)?)\\.[^.]+$/', $stat['name'], $_m)) {\n                    $ss = $_m[1];\n                } else {\n                    $ss = $this->options['tmbVideoConvSec'];\n                }\n            }\n            $cmd = sprintf(ELFINDER_FFMPEG_PATH . ' -i %s -ss 00:00:%.3f -vframes 1 -f image2 -- %s', escapeshellarg($tmp), $ss, escapeshellarg($file));\n            $r = ($this->procExec($cmd) === 0);\n            clearstatcache();\n            if ($r && $ss > 0 && !file_exists($file)) {\n                // Retry by half of $ss\n                $ss = max(intval($ss / 2), 0);\n                rename($tmp, $file);\n                $r = $this->ffmpegToImg($file, $stat, $self, $ss);\n            } else {\n                unlink($tmp);\n            }\n            return $r;\n        }\n        return false;\n    }\n\n    /**\n     * Creates a temporary file and return file pointer\n     *\n     * @return resource|boolean\n     */\n    public function tmpfile()\n    {\n        if ($tmp = $this->getTempFile()) {\n            return fopen($tmp, 'wb');\n        }\n        return false;\n    }\n\n    /**\n     * Save error message\n     *\n     * @param  array  error\n     *\n     * @return boolean false\n     * @author Naoki Sawada\n     **/\n    protected function setError()\n    {\n        $this->error = array();\n        $this->addError(func_get_args());\n        return false;\n    }\n\n    /**\n     * Add error message\n     *\n     * @param  array  error\n     *\n     * @return false\n     * @author Dmitry(dio) Levashov\n     **/\n    protected function addError()\n    {\n        foreach (func_get_args() as $err) {\n            if (is_array($err)) {\n                foreach($err as $er) {\n                    $this->addError($er);\n                }\n            } else {\n                $this->error[] = (string)$err;\n            }\n        }\n        return false;\n    }\n\n    /*********************************************************************/\n    /*                               FS API                              */\n    /*********************************************************************/\n\n    /***************** server encoding support *******************/\n\n    /**\n     * Return parent directory path (with convert encoding)\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Naoki Sawada\n     **/\n    protected function dirnameCE($path)\n    {\n        $dirname = (!$this->encoding) ? $this->_dirname($path) : $this->convEncOut($this->_dirname($this->convEncIn($path)));\n        // check to infinite loop prevention\n        return ($dirname != $path) ? $dirname : '';\n    }\n\n    /**\n     * Return file name (with convert encoding)\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Naoki Sawada\n     **/\n    protected function basenameCE($path)\n    {\n        return (!$this->encoding) ? $this->_basename($path) : $this->convEncOut($this->_basename($this->convEncIn($path)));\n    }\n\n    /**\n     * Join dir name and file name and return full path. (with convert encoding)\n     * Some drivers (db) use int as path - so we give to concat path to driver itself\n     *\n     * @param  string $dir  dir path\n     * @param  string $name file name\n     *\n     * @return string\n     * @author Naoki Sawada\n     **/\n    protected function joinPathCE($dir, $name)\n    {\n        return (!$this->encoding) ? $this->_joinPath($dir, $name) : $this->convEncOut($this->_joinPath($this->convEncIn($dir), $this->convEncIn($name)));\n    }\n\n    /**\n     * Return normalized path (with convert encoding)\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Naoki Sawada\n     **/\n    protected function normpathCE($path)\n    {\n        return (!$this->encoding) ? $this->_normpath($path) : $this->convEncOut($this->_normpath($this->convEncIn($path)));\n    }\n\n    /**\n     * Return file path related to root dir (with convert encoding)\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Naoki Sawada\n     **/\n    protected function relpathCE($path)\n    {\n        return (!$this->encoding) ? $this->_relpath($path) : $this->convEncOut($this->_relpath($this->convEncIn($path)));\n    }\n\n    /**\n     * Convert path related to root dir into real path (with convert encoding)\n     *\n     * @param  string $path rel file path\n     *\n     * @return string\n     * @author Naoki Sawada\n     **/\n    protected function abspathCE($path)\n    {\n        return (!$this->encoding) ? $this->_abspath($path) : $this->convEncOut($this->_abspath($this->convEncIn($path)));\n    }\n\n    /**\n     * Return true if $path is children of $parent (with convert encoding)\n     *\n     * @param  string $path   path to check\n     * @param  string $parent parent path\n     *\n     * @return bool\n     * @author Naoki Sawada\n     **/\n    protected function inpathCE($path, $parent)\n    {\n        return (!$this->encoding) ? $this->_inpath($path, $parent) : $this->convEncOut($this->_inpath($this->convEncIn($path), $this->convEncIn($parent)));\n    }\n\n    /**\n     * Open file and return file pointer (with convert encoding)\n     *\n     * @param  string $path file path\n     * @param string  $mode\n     *\n     * @return false|resource\n     * @internal param bool $write open file for writing\n     * @author   Naoki Sawada\n     */\n    protected function fopenCE($path, $mode = 'rb')\n    {\n        // check extra option for network stream pointer\n        if (func_num_args() > 2) {\n            $opts = func_get_arg(2);\n        } else {\n            $opts = array();\n        }\n        return (!$this->encoding) ? $this->_fopen($path, $mode, $opts) : $this->convEncOut($this->_fopen($this->convEncIn($path), $mode, $opts));\n    }\n\n    /**\n     * Close opened file (with convert encoding)\n     *\n     * @param  resource $fp   file pointer\n     * @param  string   $path file path\n     *\n     * @return bool\n     * @author Naoki Sawada\n     **/\n    protected function fcloseCE($fp, $path = '')\n    {\n        return (!$this->encoding) ? $this->_fclose($fp, $path) : $this->convEncOut($this->_fclose($fp, $this->convEncIn($path)));\n    }\n\n    /**\n     * Create new file and write into it from file pointer. (with convert encoding)\n     * Return new file path or false on error.\n     *\n     * @param  resource $fp   file pointer\n     * @param  string   $dir  target dir path\n     * @param  string   $name file name\n     * @param  array    $stat file stat (required by some virtual fs)\n     *\n     * @return bool|string\n     * @author Naoki Sawada\n     **/\n    protected function saveCE($fp, $dir, $name, $stat)\n    {\n        $res = (!$this->encoding) ? $this->_save($fp, $dir, $name, $stat) : $this->convEncOut($this->_save($fp, $this->convEncIn($dir), $this->convEncIn($name), $this->convEncIn($stat)));\n        if ($res !== false) {\n            $this->clearstatcache();\n        }\n        return $res;\n    }\n\n    /**\n     * Return true if path is dir and has at least one childs directory (with convert encoding)\n     *\n     * @param  string $path dir path\n     *\n     * @return bool\n     * @author Naoki Sawada\n     **/\n    protected function subdirsCE($path)\n    {\n        if ($this->sessionCaching['subdirs']) {\n            if (isset($this->sessionCache['subdirs'][$path]) && !$this->isMyReload()) {\n                return $this->sessionCache['subdirs'][$path];\n            }\n        }\n        $hasdir = (bool)((!$this->encoding) ? $this->_subdirs($path) : $this->convEncOut($this->_subdirs($this->convEncIn($path))));\n        $this->updateSubdirsCache($path, $hasdir);\n        return $hasdir;\n    }\n\n    /**\n     * Return files list in directory (with convert encoding)\n     *\n     * @param  string $path dir path\n     *\n     * @return array\n     * @author Naoki Sawada\n     **/\n    protected function scandirCE($path)\n    {\n        return (!$this->encoding) ? $this->_scandir($path) : $this->convEncOut($this->_scandir($this->convEncIn($path)));\n    }\n\n    /**\n     * Create symlink (with convert encoding)\n     *\n     * @param  string $source    file to link to\n     * @param  string $targetDir folder to create link in\n     * @param  string $name      symlink name\n     *\n     * @return bool\n     * @author Naoki Sawada\n     **/\n    protected function symlinkCE($source, $targetDir, $name)\n    {\n        return (!$this->encoding) ? $this->_symlink($source, $targetDir, $name) : $this->convEncOut($this->_symlink($this->convEncIn($source), $this->convEncIn($targetDir), $this->convEncIn($name)));\n    }\n\n    /***************** paths *******************/\n\n    /**\n     * Encode path into hash\n     *\n     * @param  string  file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     * @author Troex Nevelin\n     **/\n    protected function encode($path)\n    {\n        if ($path !== '') {\n\n            // cut ROOT from $path for security reason, even if hacker decodes the path he will not know the root\n            $p = $this->relpathCE($path);\n            // if reqesting root dir $path will be empty, then assign '/' as we cannot leave it blank for crypt\n            if ($p === '') {\n                $p = $this->separator;\n            }\n            // change separator\n            if ($this->separatorForHash) {\n                $p = str_replace($this->separator, $this->separatorForHash, $p);\n            }\n            // TODO crypt path and return hash\n            $hash = $this->crypt($p);\n            // hash is used as id in HTML that means it must contain vaild chars\n            // make base64 html safe and append prefix in begining\n            $hash = strtr(base64_encode($hash), '+/=', '-_.');\n            // remove dots '.' at the end, before it was '=' in base64\n            $hash = rtrim($hash, '.');\n            // append volume id to make hash unique\n            return $this->id . $hash;\n        }\n        //TODO: Add return statement here\n    }\n\n    /**\n     * Decode path from hash\n     *\n     * @param  string  file hash\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     * @author Troex Nevelin\n     **/\n    protected function decode($hash)\n    {\n        if (strpos($hash, $this->id) === 0) {\n            // cut volume id after it was prepended in encode\n            $h = substr($hash, strlen($this->id));\n            // replace HTML safe base64 to normal\n            $h = base64_decode(strtr($h, '-_.', '+/='));\n            // TODO uncrypt hash and return path\n            $path = $this->uncrypt($h);\n            // change separator\n            if ($this->separatorForHash) {\n                $path = str_replace($this->separatorForHash, $this->separator, $path);\n            }\n            // append ROOT to path after it was cut in encode\n            return $this->abspathCE($path);//$this->root.($path === $this->separator ? '' : $this->separator.$path);\n        }\n        return '';\n    }\n\n    /**\n     * Return crypted path\n     * Not implemented\n     *\n     * @param  string  path\n     *\n     * @return mixed\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function crypt($path)\n    {\n        return $path;\n    }\n\n    /**\n     * Return uncrypted path\n     * Not implemented\n     *\n     * @param  mixed  hash\n     *\n     * @return mixed\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function uncrypt($hash)\n    {\n        return $hash;\n    }\n\n    /**\n     * Validate file name based on $this->options['acceptedName'] regexp or function\n     *\n     * @param  string $name file name\n     * @param  bool   $isDir\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     */\n    protected function nameAccepted($name, $isDir = false)\n    {\n        if (json_encode($name) === false) {\n            return false;\n        }\n        $nameValidator = $isDir ? $this->dirnameValidator : $this->nameValidator;\n        if ($nameValidator) {\n            if (is_callable($nameValidator)) {\n                $res = call_user_func($nameValidator, $name);\n                return $res;\n            }\n            if (preg_match($nameValidator, '') !== false) {\n                return preg_match($nameValidator, $name);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Return session rootstat cache key\n     *\n     * @return string\n     */\n    protected function getRootstatCachekey()\n    {\n        return md5($this->root . (isset($this->options['alias']) ? $this->options['alias'] : ''));\n    }\n\n    /**\n     * Return new unique name based on file name and suffix\n     *\n     * @param         $dir\n     * @param         $name\n     * @param  string $suffix suffix append to name\n     * @param bool    $checkNum\n     * @param int     $start\n     *\n     * @return string\n     * @internal param string $path file path\n     * @author   Dmitry (dio) Levashov\n     */\n    public function uniqueName($dir, $name, $suffix = ' copy', $checkNum = true, $start = 1)\n    {\n        static $lasts = null;\n\n        if ($lasts === null) {\n            $lasts = array();\n        }\n\n        $ext = '';\n\n        $splits = elFinder::splitFileExtention($name);\n        if ($splits[1]) {\n            $ext = '.' . $splits[1];\n            $name = $splits[0];\n        }\n\n        if ($checkNum && preg_match('/(' . preg_quote($suffix, '/') . ')(\\d*)$/i', $name, $m)) {\n            $i = (int)$m[2];\n            $name = substr($name, 0, strlen($name) - strlen($m[2]));\n        } else {\n            $i = $start;\n            $name .= $suffix;\n        }\n        $max = $i + 100000;\n\n        if (isset($lasts[$name])) {\n            $i = max($i, $lasts[$name]);\n        }\n\n        while ($i <= $max) {\n            $n = $name . ($i > 0 ? sprintf($this->options['uniqueNumFormat'], $i) : '') . $ext;\n\n            if (!$this->isNameExists($this->joinPathCE($dir, $n))) {\n                $this->clearcache();\n                $lasts[$name] = ++$i;\n                return $n;\n            }\n            $i++;\n        }\n        return $name . md5($dir) . $ext;\n    }\n\n    /**\n     * Converts character encoding from UTF-8 to server's one\n     *\n     * @param  mixed  $var           target string or array var\n     * @param  bool   $restoreLocale do retore global locale, default is false\n     * @param  string $unknown       replaces character for unknown\n     *\n     * @return mixed\n     * @author Naoki Sawada\n     */\n    public function convEncIn($var = null, $restoreLocale = false, $unknown = '_')\n    {\n        return (!$this->encoding) ? $var : $this->convEnc($var, 'UTF-8', $this->encoding, $this->options['locale'], $restoreLocale, $unknown);\n    }\n\n    /**\n     * Converts character encoding from server's one to UTF-8\n     *\n     * @param  mixed  $var           target string or array var\n     * @param  bool   $restoreLocale do retore global locale, default is true\n     * @param  string $unknown       replaces character for unknown\n     *\n     * @return mixed\n     * @author Naoki Sawada\n     */\n    public function convEncOut($var = null, $restoreLocale = true, $unknown = '_')\n    {\n        return (!$this->encoding) ? $var : $this->convEnc($var, $this->encoding, 'UTF-8', $this->options['locale'], $restoreLocale, $unknown);\n    }\n\n    /**\n     * Converts character encoding (base function)\n     *\n     * @param  mixed  $var     target string or array var\n     * @param  string $from    from character encoding\n     * @param  string $to      to character encoding\n     * @param  string $locale  local locale\n     * @param         $restoreLocale\n     * @param  string $unknown replaces character for unknown\n     *\n     * @return mixed\n     */\n    protected function convEnc($var, $from, $to, $locale, $restoreLocale, $unknown = '_')\n    {\n        if (strtoupper($from) !== strtoupper($to)) {\n            if ($locale) {\n                setlocale(LC_ALL, $locale);\n            }\n            if (is_array($var)) {\n                $_ret = array();\n                foreach ($var as $_k => $_v) {\n                    $_ret[$_k] = $this->convEnc($_v, $from, $to, '', false, $unknown = '_');\n                }\n                $var = $_ret;\n            } else {\n                $_var = false;\n                if (is_string($var)) {\n                    $_var = $var;\n                    $errlev = error_reporting();\n                    error_reporting($errlev ^ E_NOTICE);\n                    if (false !== ($_var = iconv($from, $to . '//TRANSLIT', $_var))) {\n                        $_var = str_replace('?', $unknown, $_var);\n                    }\n                    error_reporting($errlev);\n                }\n                if ($_var !== false) {\n                    $var = $_var;\n                }\n            }\n            if ($restoreLocale) {\n                setlocale(LC_ALL, elFinder::$locale);\n            }\n        }\n        return $var;\n    }\n\n    /**\n     * Normalize MIME-Type by options['mimeMap']\n     *\n     * @param      string $type MIME-Type\n     * @param      string $name Filename\n     * @param      string $ext  File extention without first dot (optional)\n     *\n     * @return     string  Normalized MIME-Type\n     */\n    public function mimeTypeNormalize($type, $name, $ext = '')\n    {\n        if ($ext === '') {\n            $ext = (false === $pos = strrpos($name, '.')) ? '' : substr($name, $pos + 1);\n        }\n        $_checkKey = strtolower($ext . ':' . $type);\n        if ($type === '') {\n            $_keylen = strlen($_checkKey);\n            foreach ($this->options['mimeMap'] as $_key => $_type) {\n                if (substr($_key, 0, $_keylen) === $_checkKey) {\n                    $type = $_type;\n                    break;\n                }\n            }\n        } else if (isset($this->options['mimeMap'][$_checkKey])) {\n            $type = $this->options['mimeMap'][$_checkKey];\n        } else {\n            $_checkKey = strtolower($ext . ':*');\n            if (isset($this->options['mimeMap'][$_checkKey])) {\n                $type = $this->options['mimeMap'][$_checkKey];\n            } else {\n                $_checkKey = strtolower('*:' . $type);\n                if (isset($this->options['mimeMap'][$_checkKey])) {\n                    $type = $this->options['mimeMap'][$_checkKey];\n                }\n            }\n        }\n        return $type;\n    }\n\n    /*********************** util mainly for inheritance class *********************/\n\n    /**\n     * Get temporary filename. Tempfile will be removed when after script execution finishes or exit() is called.\n     * When needing the unique file to a path, give $path to parameter.\n     *\n     * @param  string $path for get unique file to a path\n     *\n     * @return string|false\n     * @author Naoki Sawada\n     */\n    protected function getTempFile($path = '')\n    {\n        static $cache = array();\n\n        $key = '';\n        if ($path !== '') {\n            $key = $this->id . '#' . $path;\n            if (isset($cache[$key])) {\n                return $cache[$key];\n            }\n        }\n\n        if ($tmpdir = $this->getTempPath()) {\n            $name = tempnam($tmpdir, 'ELF');\n            if ($key) {\n                $cache[$key] = $name;\n            }\n            // register auto delete on shutdown\n            $GLOBALS['elFinderTempFiles'][$name] = true;\n            return $name;\n        }\n\n        return false;\n    }\n\n    /**\n     * File path of local server side work file path\n     *\n     * @param  string $path path need convert encoding to server encoding\n     *\n     * @return string\n     * @author Naoki Sawada\n     */\n    protected function getWorkFile($path)\n    {\n        if ($wfp = $this->tmpfile()) {\n            if ($fp = $this->_fopen($path)) {\n                while (!feof($fp)) {\n                    fwrite($wfp, fread($fp, 8192));\n                }\n                $info = stream_get_meta_data($wfp);\n                fclose($wfp);\n                if ($info && !empty($info['uri'])) {\n                    return $info['uri'];\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Get image size array with `dimensions`\n     *\n     * @param string $path path need convert encoding to server encoding\n     * @param string $mime file mime type\n     *\n     * @return array|false\n     * @throws ImagickException\n     * @throws elFinderAbortException\n     */\n    public function getImageSize($path, $mime = '')\n    {\n        $size = false;\n        if ($mime === '' || strtolower(substr($mime, 0, 5)) === 'image') {\n            if ($work = $this->getWorkFile($path)) {\n                if ($size = getimagesize($work)) {\n                    $size['dimensions'] = $size[0] . 'x' . $size[1];\n                    $srcfp = fopen($work, 'rb');\n                    $cArgs = elFinder::$currentArgs;\n                    if (!empty($cArgs['target']) && $subImgLink = $this->getSubstituteImgLink($cArgs['target'], $size, $srcfp)) {\n                        $size['url'] = $subImgLink;\n                    }\n                }\n            }\n            is_file($work) && unlink($work);\n        }\n        return $size;\n    }\n\n    /**\n     * Delete dirctory trees\n     *\n     * @param string $localpath path need convert encoding to server encoding\n     *\n     * @return boolean\n     * @throws elFinderAbortException\n     * @author Naoki Sawada\n     */\n    protected function delTree($localpath)\n    {\n        foreach ($this->_scandir($localpath) as $p) {\n            elFinder::checkAborted();\n            $stat = $this->stat($this->convEncOut($p));\n            $this->convEncIn();\n            ($stat['mime'] === 'directory') ? $this->delTree($p) : $this->_unlink($p);\n        }\n        $res = $this->_rmdir($localpath);\n        $res && $this->clearstatcache();\n        return $res;\n    }\n\n    /**\n     * Copy items to a new temporary directory on the local server\n     *\n     * @param  array  $hashes  target hashes\n     * @param  string $dir     destination directory (for recurcive)\n     * @param  string $canLink it can use link() (for recurcive)\n     *\n     * @return string|false    saved path name\n     * @throws elFinderAbortException\n     * @author Naoki Sawada\n     */\n    protected function getItemsInHand($hashes, $dir = null, $canLink = null)\n    {\n        static $banChrs = null;\n        static $totalSize = 0;\n\n        if  (is_null($banChrs)) {\n            $banChrs = DIRECTORY_SEPARATOR !== '/'? array('\\\\', '/', ':', '*', '?', '\"', '<', '>', '|') : array('\\\\', '/');\n        }\n\n        if (is_null($dir)) {\n            $totalSize = 0;\n            if (!$tmpDir = $this->getTempPath()) {\n                return false;\n            }\n            $dir = tempnam($tmpDir, 'elf');\n            if (!unlink($dir) || !mkdir($dir, 0700, true)) {\n                return false;\n            }\n            register_shutdown_function(array($this, 'rmdirRecursive'), $dir);\n        }\n        if (is_null($canLink)) {\n            $canLink = ($this instanceof elFinderVolumeLocalFileSystem);\n        }\n        elFinder::checkAborted();\n        $res = true;\n        $files = array();\n        foreach ($hashes as $hash) {\n            if (($file = $this->file($hash)) == false) {\n                continue;\n            }\n            if (!$file['read']) {\n                continue;\n            }\n\n            $name = $file['name'];\n            // remove ctrl characters\n            $name = preg_replace('/[[:cntrl:]]+/', '', $name);\n            // replace ban characters\n            $name = str_replace($banChrs, '_', $name);\n\n            // for call from search results\n            if (isset($files[$name])) {\n                $name = preg_replace('/^(.*?)(\\..*)?$/', '$1_' . $files[$name]++ . '$2', $name);\n            } else {\n                $files[$name] = 1;\n            }\n            $target = $dir . DIRECTORY_SEPARATOR . $name;\n\n            if ($file['mime'] === 'directory') {\n                $chashes = array();\n                $_files = $this->scandir($hash);\n                foreach ($_files as $_file) {\n                    if ($file['read']) {\n                        $chashes[] = $_file['hash'];\n                    }\n                }\n                if (($res = mkdir($target, 0700, true)) && $chashes) {\n                    $res = $this->getItemsInHand($chashes, $target, $canLink);\n                }\n                if (!$res) {\n                    break;\n                }\n                !empty($file['ts']) && touch($target, $file['ts']);\n            } else {\n                $path = $this->decode($hash);\n                if (!$canLink || !($canLink = $this->localFileSystemSymlink($path, $target))) {\n                    if (file_exists($target)) {\n                        unlink($target);\n                    }\n                    if ($fp = $this->fopenCE($path)) {\n                        if ($tfp = fopen($target, 'wb')) {\n                            $totalSize += stream_copy_to_stream($fp, $tfp);\n                            fclose($tfp);\n                        }\n                        !empty($file['ts']) && touch($target, $file['ts']);\n                        $this->fcloseCE($fp, $path);\n                    }\n                } else {\n                    $totalSize += filesize($path);\n                }\n                if ($this->options['maxArcFilesSize'] > 0 && $this->options['maxArcFilesSize'] < $totalSize) {\n                    $res = $this->setError(elFinder::ERROR_ARC_MAXSIZE);\n                }\n            }\n        }\n        return $res ? $dir : false;\n    }\n\n    /*********************** file stat *********************/\n\n    /**\n     * Check file attribute\n     *\n     * @param  string $path  file path\n     * @param  string $name  attribute name (read|write|locked|hidden)\n     * @param  bool   $val   attribute value returned by file system\n     * @param  bool   $isDir path is directory (true: directory, false: file)\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function attr($path, $name, $val = null, $isDir = null)\n    {\n        if (!isset($this->defaults[$name])) {\n            return false;\n        }\n\n        $relpath = $this->relpathCE($path);\n        if ($this->separator !== '/') {\n            $relpath = str_replace($this->separator, '/', $relpath);\n        }\n        $relpath = '/' . $relpath;\n\n        $perm = null;\n\n        if ($this->access) {\n            $perm = call_user_func($this->access, $name, $path, $this->options['accessControlData'], $this, $isDir, $relpath);\n            if ($perm !== null) {\n                return !!$perm;\n            }\n        }\n\n        foreach ($this->attributes as $attrs) {\n            if (isset($attrs[$name]) && isset($attrs['pattern']) && preg_match($attrs['pattern'], $relpath)) {\n                $perm = $attrs[$name];\n                break;\n            }\n        }\n\n        return $perm === null ? (is_null($val) ? $this->defaults[$name] : $val) : !!$perm;\n    }\n\n    /**\n     * Return true if file with given name can be created in given folder.\n     *\n     * @param string $dir  parent dir path\n     * @param string $name new file name\n     * @param null   $isDir\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     */\n    protected function allowCreate($dir, $name, $isDir = null)\n    {\n        return $this->attr($this->joinPathCE($dir, $name), 'write', true, $isDir);\n    }\n\n    /**\n     * Return true if file MIME type can save with check uploadOrder config.\n     *\n     * @param string $mime\n     *\n     * @return boolean\n     */\n    protected function allowPutMime($mime)\n    {\n        // logic based on http://httpd.apache.org/docs/2.2/mod/mod_authz_host.html#order\n        $allow = $this->mimeAccepted($mime, $this->uploadAllow, null);\n        $deny = $this->mimeAccepted($mime, $this->uploadDeny, null);\n        if (strtolower($this->uploadOrder[0]) == 'allow') { // array('allow', 'deny'), default is to 'deny'\n            $res = false; // default is deny\n            if (!$deny && ($allow === true)) { // match only allow\n                $res = true;\n            }// else (both match | no match | match only deny) { deny }\n        } else { // array('deny', 'allow'), default is to 'allow' - this is the default rule\n            $res = true; // default is allow\n            if (($deny === true) && !$allow) { // match only deny\n                $res = false;\n            } // else (both match | no match | match only allow) { allow }\n        }\n        return $res;\n    }\n\n    /**\n     * Return fileinfo\n     *\n     * @param  string $path file cache\n     *\n     * @return array|bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function stat($path)\n    {\n        if ($path === false || is_null($path)) {\n            return false;\n        }\n        $is_root = ($path == $this->root);\n        if ($is_root) {\n            $rootKey = $this->getRootstatCachekey();\n            if ($this->sessionCaching['rootstat'] && !isset($this->sessionCache['rootstat'])) {\n                $this->sessionCache['rootstat'] = array();\n            }\n            if (!isset($this->cache[$path]) && !$this->isMyReload()) {\n                // need $path as key for netmount/netunmount\n                if ($this->sessionCaching['rootstat'] && isset($this->sessionCache['rootstat'][$rootKey])) {\n                    if ($ret = $this->sessionCache['rootstat'][$rootKey]) {\n                        if ($this->options['rootRev'] === $ret['rootRev']) {\n                            if (isset($this->options['phash'])) {\n                                $ret['isroot'] = 1;\n                                $ret['phash'] = $this->options['phash'];\n                            }\n                            return $ret;\n                        }\n                    }\n                }\n            }\n        }\n        $rootSessCache = false;\n        if (isset($this->cache[$path])) {\n            $ret = $this->cache[$path];\n        } else {\n            if ($is_root && !empty($this->options['rapidRootStat']) && is_array($this->options['rapidRootStat']) && !$this->needOnline) {\n                $ret = $this->updateCache($path, $this->options['rapidRootStat'], true);\n            } else {\n                $ret = $this->updateCache($path, $this->convEncOut($this->_stat($this->convEncIn($path))), true);\n                if ($is_root && !empty($rootKey) && $this->sessionCaching['rootstat']) {\n                    $rootSessCache = true;\n                }\n            }\n        } \n        if ($is_root) {\n            if ($ret) {\n                $this->rootModified = false;\n                if ($rootSessCache) {\n                    $this->sessionCache['rootstat'][$rootKey] = $ret;\n                }\n                if (isset($this->options['phash'])) {\n                    $ret['isroot'] = 1;\n                    $ret['phash'] = $this->options['phash'];\n                }\n            } else if (!empty($rootKey) && $this->sessionCaching['rootstat']) {\n                unset($this->sessionCache['rootstat'][$rootKey]);\n            }\n        }\n        return $ret;\n    }\n\n    /**\n     * Get root stat extra key values\n     *\n     * @return array stat extras\n     * @author Naoki Sawada\n     */\n    protected function getRootStatExtra()\n    {\n        $stat = array();\n        if ($this->rootName) {\n            $stat['name'] = $this->rootName;\n        }\n        $stat['rootRev'] = $this->options['rootRev'];\n        $stat['options'] = $this->options(null);\n        return $stat;\n    }\n\n    /**\n     * Return fileinfo based on filename\n     * For item ID based path file system\n     * Please override if needed on each drivers\n     *\n     * @param  string $path file cache\n     *\n     * @return array\n     */\n    protected function isNameExists($path)\n    {\n        return $this->stat($path);\n    }\n\n    /**\n     * Put file stat in cache and return it\n     *\n     * @param  string $path file path\n     * @param  array  $stat file stat\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function updateCache($path, $stat)\n    {\n        if (empty($stat) || !is_array($stat)) {\n            return $this->cache[$path] = array();\n        }\n\n        if (func_num_args() > 2) {\n            $fromStat = func_get_arg(2);\n        } else {\n            $fromStat = false;\n        }\n\n        $stat['hash'] = $this->encode($path);\n\n        $root = $path == $this->root;\n        $parent = '';\n\n        if ($root) {\n            $stat = array_merge($stat, $this->getRootStatExtra());\n        } else {\n            if (!isset($stat['name']) || $stat['name'] === '') {\n                $stat['name'] = $this->basenameCE($path);\n            }\n            if (empty($stat['phash'])) {\n                $parent = $this->dirnameCE($path);\n                $stat['phash'] = $this->encode($parent);\n            } else {\n                $parent = $this->decode($stat['phash']);\n            }\n        }\n\n        // name check\n        if (isset($stat['name']) && !$jeName = json_encode($stat['name'])) {\n            return $this->cache[$path] = array();\n        }\n        // fix name if required\n        if ($this->options['utf8fix'] && $this->options['utf8patterns'] && $this->options['utf8replace']) {\n            $stat['name'] = json_decode(str_replace($this->options['utf8patterns'], $this->options['utf8replace'], $jeName));\n        }\n\n        if (!isset($stat['size'])) {\n            $stat['size'] = 'unknown';\n        }\n\n        $mime = isset($stat['mime']) ? $stat['mime'] : '';\n        if ($isDir = ($mime === 'directory')) {\n            $stat['volumeid'] = $this->id;\n        } else {\n            if (empty($stat['mime']) || $stat['size'] == 0) {\n                $stat['mime'] = $this->mimetype($stat['name'], true, $stat['size'], $mime);\n            } else {\n                $stat['mime'] = $this->mimeTypeNormalize($stat['mime'], $stat['name']);\n            }\n        }\n\n        $stat['read'] = intval($this->attr($path, 'read', isset($stat['read']) ? !!$stat['read'] : null, $isDir));\n        $stat['write'] = intval($this->attr($path, 'write', isset($stat['write']) ? !!$stat['write'] : null, $isDir));\n        if ($root) {\n            $stat['locked'] = 1;\n            if ($this->options['type'] !== '') {\n                $stat['type'] = $this->options['type'];\n            }\n        } else {\n            // lock when parent directory is not writable\n            if (!isset($stat['locked'])) {\n                $pstat = $this->stat($parent);\n                if (isset($pstat['write']) && !$pstat['write']) {\n                    $stat['locked'] = true;\n                }\n            }\n            if ($this->attr($path, 'locked', isset($stat['locked']) ? !!$stat['locked'] : null, $isDir)) {\n                $stat['locked'] = 1;\n            } else {\n                unset($stat['locked']);\n            }\n        }\n\n        if ($root) {\n            unset($stat['hidden']);\n        } elseif ($this->attr($path, 'hidden', isset($stat['hidden']) ? !!$stat['hidden'] : null, $isDir)\n            || !$this->mimeAccepted($stat['mime'])) {\n            $stat['hidden'] = 1;\n        } else {\n            unset($stat['hidden']);\n        }\n\n        if ($stat['read'] && empty($stat['hidden'])) {\n\n            if ($isDir) {\n                // caching parent's subdirs\n                if ($parent) {\n                    $this->updateSubdirsCache($parent, true);\n                }\n                // for dir - check for subdirs\n                if ($this->options['checkSubfolders']) {\n                    if (!isset($stat['dirs']) && intval($this->options['checkSubfolders']) === -1) {\n                        $stat['dirs'] = -1;\n                    }\n                    if (isset($stat['dirs'])) {\n                        if ($stat['dirs']) {\n                            if ($stat['dirs'] == -1) {\n                                $stat['dirs'] = ($this->sessionCaching['subdirs'] && isset($this->sessionCache['subdirs'][$path])) ? (int)$this->sessionCache['subdirs'][$path] : -1;\n                            } else {\n                                $stat['dirs'] = 1;\n                            }\n                        } else {\n                            unset($stat['dirs']);\n                        }\n                    } elseif (!empty($stat['alias']) && !empty($stat['target'])) {\n                        $stat['dirs'] = isset($this->cache[$stat['target']])\n                            ? intval(isset($this->cache[$stat['target']]['dirs']))\n                            : $this->subdirsCE($stat['target']);\n\n                    } elseif ($this->subdirsCE($path)) {\n                        $stat['dirs'] = 1;\n                    }\n                } else {\n                    $stat['dirs'] = 1;\n                }\n                if ($this->options['dirUrlOwn'] === true) {\n                    // Set `null` to use the client option `commandsOptions.info.nullUrlDirLinkSelf = true`\n                    $stat['url'] = null;\n                } else if ($this->options['dirUrlOwn'] === 'hide') {\n                    // to hide link in info dialog of the elFinder client\n                    $stat['url'] = '';\n                }\n            } else {\n                // for files - check for thumbnails\n                $p = isset($stat['target']) ? $stat['target'] : $path;\n                if ($this->tmbURL && !isset($stat['tmb']) && $this->canCreateTmb($p, $stat)) {\n                    $tmb = $this->gettmb($p, $stat);\n                    $stat['tmb'] = $tmb ? $tmb : 1;\n                }\n\n            }\n            if (!isset($stat['url']) && $this->URL && $this->encoding) {\n                $_path = str_replace($this->separator, '/', substr($path, strlen($this->root) + 1));\n                $stat['url'] = rtrim($this->URL, '/') . '/' . str_replace('%2F', '/', rawurlencode((substr(PHP_OS, 0, 3) === 'WIN') ? $_path : $this->convEncIn($_path, true)));\n            }\n        } else {\n            if ($isDir) {\n                unset($stat['dirs']);\n            }\n        }\n\n        if (!empty($stat['alias']) && !empty($stat['target'])) {\n            $stat['thash'] = $this->encode($stat['target']);\n            //$this->cache[$stat['target']] = $stat;\n            unset($stat['target']);\n        }\n\n        $this->cache[$path] = $stat;\n\n        if (!$fromStat && $root && $this->sessionCaching['rootstat']) {\n            // to update session cache\n            $this->stat($path);\n        }\n\n        return $stat;\n    }\n\n    /**\n     * Get stat for folder content and put in cache\n     *\n     * @param  string $path\n     *\n     * @return void\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function cacheDir($path)\n    {\n        $this->dirsCache[$path] = array();\n        $hasDir = false;\n\n        foreach ($this->scandirCE($path) as $p) {\n            if (($stat = $this->stat($p)) && empty($stat['hidden'])) {\n                if (!$hasDir && $stat['mime'] === 'directory') {\n                    $hasDir = true;\n                }\n                $this->dirsCache[$path][] = $p;\n            }\n        }\n\n        $this->updateSubdirsCache($path, $hasDir);\n    }\n\n    /**\n     * Clean cache\n     *\n     * @return void\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function clearcache()\n    {\n        $this->cache = $this->dirsCache = array();\n    }\n\n    /**\n     * Return file mimetype\n     *\n     * @param  string      $path file path\n     * @param  string|bool $name\n     * @param  integer     $size\n     * @param  string      $mime was notified from the volume driver\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     */\n    protected function mimetype($path, $name = '', $size = null, $mime = null)\n    {\n        $type = '';\n        $nameCheck = false;\n\n        if ($name === '') {\n            $name = $path;\n        } else if ($name === true) {\n            $name = $path;\n            $nameCheck = true;\n        }\n        if (!$this instanceof elFinderVolumeLocalFileSystem) {\n            $nameCheck = true;\n        }\n        $ext = (false === $pos = strrpos($name, '.')) ? '' : strtolower(substr($name, $pos + 1));\n        if (!$nameCheck && $size === null) {\n            $size = file_exists($path) ? filesize($path) : -1;\n        }\n        if (!$nameCheck && is_readable($path) && $size > 0) {\n            // detecting by contents\n            if ($this->mimeDetect === 'finfo') {\n                $type = finfo_file($this->finfo, $path);\n            } else if ($this->mimeDetect === 'mime_content_type') {\n                $type = mime_content_type($path);\n            }\n            if ($type) {\n                $type = explode(';', $type);\n                $type = trim($type[0]);\n                if ($ext && preg_match('~^application/(?:octet-stream|(?:x-)?zip|xml)$~', $type)) {\n                    // load default MIME table file \"mime.types\"\n                    if (!elFinderVolumeDriver::$mimetypesLoaded) {\n                        elFinderVolumeDriver::loadMimeTypes();\n                    }\n                    if (isset(elFinderVolumeDriver::$mimetypes[$ext])) {\n                        $type = elFinderVolumeDriver::$mimetypes[$ext];\n                    }\n                } else if ($ext === 'js' && preg_match('~^text/~', $type)) {\n                    $type = 'text/javascript';\n                }\n            }\n        }\n        if (!$type) {\n            // detecting by filename\n            $type = elFinderVolumeDriver::mimetypeInternalDetect($name);\n            if ($type === 'unknown') {\n                if ($mime) {\n                    $type = $mime;\n                } else {\n                    $type = ($size == 0) ? 'text/plain' : $this->options['mimeTypeUnknown'];\n                }\n            }\n        }\n\n        // mime type normalization\n        $type = $this->mimeTypeNormalize($type, $name, $ext);\n\n        return $type;\n    }\n\n    /**\n     * Load file of mime.types\n     *\n     * @param string $mimeTypesFile The mime types file\n     */\n    static protected function loadMimeTypes($mimeTypesFile = '')\n    {\n        if (!elFinderVolumeDriver::$mimetypesLoaded) {\n            elFinderVolumeDriver::$mimetypesLoaded = true;\n            $file = false;\n            if (!empty($mimeTypesFile) && file_exists($mimeTypesFile)) {\n                $file = $mimeTypesFile;\n            } elseif (elFinder::$defaultMimefile && file_exists(elFinder::$defaultMimefile)) {\n                $file = elFinder::$defaultMimefile;\n            } elseif (file_exists(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mime.types')) {\n                $file = dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mime.types';\n            } elseif (file_exists(dirname(dirname(__FILE__)) . DIRECTORY_SEPARATOR . 'mime.types')) {\n                $file = dirname(dirname(__FILE__)) . DIRECTORY_SEPARATOR . 'mime.types';\n            }\n\n            if ($file && file_exists($file)) {\n                $mimecf = file($file);\n\n                foreach ($mimecf as $line_num => $line) {\n                    if (!preg_match('/^\\s*#/', $line)) {\n                        $mime = preg_split('/\\s+/', $line, -1, PREG_SPLIT_NO_EMPTY);\n                        for ($i = 1, $size = count($mime); $i < $size; $i++) {\n                            if (!isset(self::$mimetypes[$mime[$i]])) {\n                                self::$mimetypes[$mime[$i]] = $mime[0];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Detect file mimetype using \"internal\" method or Loading mime.types with $path = ''\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    static protected function mimetypeInternalDetect($path = '')\n    {\n        // load default MIME table file \"mime.types\"\n        if (!elFinderVolumeDriver::$mimetypesLoaded) {\n            elFinderVolumeDriver::loadMimeTypes();\n        }\n        $ext = '';\n        if ($path) {\n            $pinfo = pathinfo($path);\n            $ext = isset($pinfo['extension']) ? strtolower($pinfo['extension']) : '';\n        }\n        return ($ext && isset(elFinderVolumeDriver::$mimetypes[$ext])) ? elFinderVolumeDriver::$mimetypes[$ext] : 'unknown';\n    }\n\n    /**\n     * Return file/total directory size infomation\n     *\n     * @param  string $path file path\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function countSize($path)\n    {\n\n        elFinder::checkAborted();\n\n        $result = array('size' => 0, 'files' => 0, 'dirs' => 0);\n        $stat = $this->stat($path);\n\n        if (empty($stat) || !$stat['read'] || !empty($stat['hidden'])) {\n            $result['size'] = 'unknown';\n            return $result;\n        }\n\n        if ($stat['mime'] !== 'directory') {\n            $result['size'] = intval($stat['size']);\n            $result['files'] = 1;\n            return $result;\n        }\n\n        $result['dirs'] = 1;\n        $subdirs = $this->options['checkSubfolders'];\n        $this->options['checkSubfolders'] = true;\n        foreach ($this->getScandir($path) as $stat) {\n            if ($isDir = ($stat['mime'] === 'directory' && $stat['read'])) {\n                ++$result['dirs'];\n            } else {\n                ++$result['files'];\n            }\n            $res = $isDir\n                ? $this->countSize($this->decode($stat['hash']))\n                : (isset($stat['size']) ? array('size' => intval($stat['size'])) : array());\n            if (!empty($res['size']) && is_numeric($res['size'])) {\n                $result['size'] += $res['size'];\n            }\n            if (!empty($res['files']) && is_numeric($res['files'])) {\n                $result['files'] += $res['files'];\n            }\n            if (!empty($res['dirs']) && is_numeric($res['dirs'])) {\n                $result['dirs'] += $res['dirs'];\n                --$result['dirs'];\n            }\n        }\n        $this->options['checkSubfolders'] = $subdirs;\n        return $result;\n    }\n\n    /**\n     * Return true if all mimes is directory or files\n     *\n     * @param  string $mime1 mimetype\n     * @param  string $mime2 mimetype\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function isSameType($mime1, $mime2)\n    {\n        return ($mime1 == 'directory' && $mime1 == $mime2) || ($mime1 != 'directory' && $mime2 != 'directory');\n    }\n\n    /**\n     * If file has required attr == $val - return file path,\n     * If dir has child with has required attr == $val - return child path\n     *\n     * @param  string $path file path\n     * @param  string $attr attribute name\n     * @param  bool   $val  attribute value\n     *\n     * @return string|false\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function closestByAttr($path, $attr, $val)\n    {\n        $stat = $this->stat($path);\n\n        if (empty($stat)) {\n            return false;\n        }\n\n        $v = isset($stat[$attr]) ? $stat[$attr] : false;\n\n        if ($v == $val) {\n            return $path;\n        }\n\n        return $stat['mime'] == 'directory'\n            ? $this->childsByAttr($path, $attr, $val)\n            : false;\n    }\n\n    /**\n     * Return first found children with required attr == $val\n     *\n     * @param  string $path file path\n     * @param  string $attr attribute name\n     * @param  bool   $val  attribute value\n     *\n     * @return string|false\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function childsByAttr($path, $attr, $val)\n    {\n        foreach ($this->scandirCE($path) as $p) {\n            if (($_p = $this->closestByAttr($p, $attr, $val)) != false) {\n                return $_p;\n            }\n        }\n        return false;\n    }\n\n    protected function isMyReload($target = '', $ARGtarget = '')\n    {\n        if ($this->rootModified || (!empty($this->ARGS['cmd']) && $this->ARGS['cmd'] === 'parents')) {\n            return true;\n        }\n        if (!empty($this->ARGS['reload'])) {\n            if ($ARGtarget === '') {\n                $ARGtarget = isset($this->ARGS['target']) ? $this->ARGS['target']\n                    : ((isset($this->ARGS['targets']) && is_array($this->ARGS['targets']) && count($this->ARGS['targets']) === 1) ?\n                        $this->ARGS['targets'][0] : '');\n            }\n            if ($ARGtarget !== '') {\n                $ARGtarget = strval($ARGtarget);\n                if ($target === '') {\n                    return (strpos($ARGtarget, $this->id) === 0);\n                } else {\n                    $target = strval($target);\n                    return ($target === $ARGtarget);\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Update subdirs cache data\n     *\n     * @param string $path\n     * @param bool   $subdirs\n     *\n     * @return void\n     */\n    protected function updateSubdirsCache($path, $subdirs)\n    {\n        if (isset($this->cache[$path])) {\n            if ($subdirs) {\n                $this->cache[$path]['dirs'] = 1;\n            } else {\n                unset($this->cache[$path]['dirs']);\n            }\n        }\n        if ($this->sessionCaching['subdirs']) {\n            $this->sessionCache['subdirs'][$path] = $subdirs;\n        }\n        if ($this->sessionCaching['rootstat'] && $path == $this->root) {\n            unset($this->sessionCache['rootstat'][$this->getRootstatCachekey()]);\n        }\n    }\n\n    /*****************  get content *******************/\n\n    /**\n     * Return required dir's files info.\n     * If onlyMimes is set - return only dirs and files of required mimes\n     *\n     * @param  string $path dir path\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function getScandir($path)\n    {\n        $files = array();\n\n        !isset($this->dirsCache[$path]) && $this->cacheDir($path);\n\n        foreach ($this->dirsCache[$path] as $p) {\n            if (($stat = $this->stat($p)) && empty($stat['hidden'])) {\n                $files[] = $stat;\n            }\n        }\n\n        return $files;\n    }\n\n\n    /**\n     * Return subdirs tree\n     *\n     * @param  string $path parent dir path\n     * @param  int    $deep tree deep\n     * @param string  $exclude\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     */\n    protected function gettree($path, $deep, $exclude = '')\n    {\n        $dirs = array();\n\n        !isset($this->dirsCache[$path]) && $this->cacheDir($path);\n\n        foreach ($this->dirsCache[$path] as $p) {\n            $stat = $this->stat($p);\n\n            if ($stat && empty($stat['hidden']) && $p != $exclude && $stat['mime'] == 'directory') {\n                $dirs[] = $stat;\n                if ($deep > 0 && !empty($stat['dirs'])) {\n                    $dirs = array_merge($dirs, $this->gettree($p, $deep - 1));\n                }\n            }\n        }\n\n        return $dirs;\n    }\n\n    /**\n     * Recursive files search\n     *\n     * @param  string $path dir path\n     * @param  string $q    search string\n     * @param  array  $mimes\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function doSearch($path, $q, $mimes)\n    {\n        $result = array();\n        $matchMethod = empty($this->doSearchCurrentQuery['matchMethod']) ? 'searchMatchName' : $this->doSearchCurrentQuery['matchMethod'];\n        $timeout = $this->options['searchTimeout'] ? $this->searchStart + $this->options['searchTimeout'] : 0;\n        if ($timeout && $timeout < time()) {\n            $this->setError(elFinder::ERROR_SEARCH_TIMEOUT, $this->path($this->encode($path)));\n            return $result;\n        }\n\n        foreach ($this->scandirCE($path) as $p) {\n            elFinder::extendTimeLimit($this->options['searchTimeout'] + 30);\n\n            if ($timeout && ($this->error || $timeout < time())) {\n                !$this->error && $this->setError(elFinder::ERROR_SEARCH_TIMEOUT, $this->path($this->encode($path)));\n                break;\n            }\n\n\n            $stat = $this->stat($p);\n\n            if (!$stat) { // invalid links\n                continue;\n            }\n\n            if (!empty($stat['hidden']) || !$this->mimeAccepted($stat['mime'], $mimes)) {\n                continue;\n            }\n\n            $name = $stat['name'];\n\n            if ($this->doSearchCurrentQuery['excludes']) {\n                foreach ($this->doSearchCurrentQuery['excludes'] as $exclude) {\n                    if ($this->stripos($name, $exclude) !== false) {\n                        continue 2;\n                    }\n                }\n            }\n\n            if ((!$mimes || $stat['mime'] !== 'directory') && $this->$matchMethod($name, $q, $p) !== false) {\n                $stat['path'] = $this->path($stat['hash']);\n                if ($this->URL && !isset($stat['url'])) {\n                    $path = str_replace($this->separator, '/', substr($p, strlen($this->root) + 1));\n                    if ($this->encoding) {\n                        $path = str_replace('%2F', '/', rawurlencode($this->convEncIn($path, true)));\n                    } else {\n                        $path = str_replace('%2F', '/', rawurlencode($path));\n                    }\n                    $stat['url'] = $this->URL . $path;\n                }\n\n                $result[] = $stat;\n            }\n            if ($stat['mime'] == 'directory' && $stat['read'] && !isset($stat['alias'])) {\n                if (!$this->options['searchExDirReg'] || !preg_match($this->options['searchExDirReg'], $p)) {\n                    $result = array_merge($result, $this->doSearch($p, $q, $mimes));\n                }\n            }\n        }\n\n        return $result;\n    }\n\n    /**********************  manuipulations  ******************/\n\n    /**\n     * Copy file/recursive copy dir only in current volume.\n     * Return new file path or false.\n     *\n     * @param  string $src  source path\n     * @param  string $dst  destination dir path\n     * @param  string $name new file name (optionaly)\n     *\n     * @return string|false\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function copy($src, $dst, $name)\n    {\n\n        elFinder::checkAborted();\n\n        $srcStat = $this->stat($src);\n\n        if (!empty($srcStat['thash'])) {\n            $target = $this->decode($srcStat['thash']);\n            if (!$this->inpathCE($target, $this->root)) {\n                return $this->setError(elFinder::ERROR_COPY, $this->path($srcStat['hash']), elFinder::ERROR_MKOUTLINK);\n            }\n            $stat = $this->stat($target);\n            $this->clearcache();\n            return $stat && $this->symlinkCE($target, $dst, $name)\n                ? $this->joinPathCE($dst, $name)\n                : $this->setError(elFinder::ERROR_COPY, $this->path($srcStat['hash']));\n        }\n\n        if ($srcStat['mime'] === 'directory') {\n            $testStat = $this->isNameExists($this->joinPathCE($dst, $name));\n            $this->clearcache();\n\n            if (($testStat && $testStat['mime'] !== 'directory') || (!$testStat && !$testStat = $this->mkdir($this->encode($dst), $name))) {\n                return $this->setError(elFinder::ERROR_COPY, $this->path($srcStat['hash']));\n            }\n\n            $dst = $this->decode($testStat['hash']);\n\n            // start time\n            $stime = microtime(true);\n            foreach ($this->getScandir($src) as $stat) {\n                if (empty($stat['hidden'])) {\n                    // current time\n                    $ctime = microtime(true);\n                    if (($ctime - $stime) > 2) {\n                        $stime = $ctime;\n                        elFinder::checkAborted();\n                    }\n                    $name = $stat['name'];\n                    $_src = $this->decode($stat['hash']);\n                    if (!$this->copy($_src, $dst, $name)) {\n                        $this->remove($dst, true); // fall back\n                        return $this->setError($this->error, elFinder::ERROR_COPY, $this->_path($src));\n                    }\n                }\n            }\n\n            $this->added[] = $testStat;\n\n            return $dst;\n        }\n\n        if ($this->options['copyJoin']) {\n            $test = $this->joinPathCE($dst, $name);\n            if ($this->isNameExists($test)) {\n                $this->remove($test);\n            }\n        }\n        if ($res = $this->convEncOut($this->_copy($this->convEncIn($src), $this->convEncIn($dst), $this->convEncIn($name)))) {\n            $path = is_string($res) ? $res : $this->joinPathCE($dst, $name);\n            $this->clearstatcache();\n            $this->added[] = $this->stat($path);\n            return $path;\n        }\n\n        return $this->setError(elFinder::ERROR_COPY, $this->path($srcStat['hash']));\n    }\n\n    /**\n     * Move file\n     * Return new file path or false.\n     *\n     * @param  string $src  source path\n     * @param  string $dst  destination dir path\n     * @param  string $name new file name\n     *\n     * @return string|false\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function move($src, $dst, $name)\n    {\n        $stat = $this->stat($src);\n        $stat['realpath'] = $src;\n        $this->rmTmb($stat); // can not do rmTmb() after _move()\n        $this->clearcache();\n\n        if ($res = $this->convEncOut($this->_move($this->convEncIn($src), $this->convEncIn($dst), $this->convEncIn($name)))) {\n            $this->clearstatcache();\n            if ($stat['mime'] === 'directory') {\n                $this->updateSubdirsCache($dst, true);\n            }\n            $path = is_string($res) ? $res : $this->joinPathCE($dst, $name);\n            $this->added[] = $this->stat($path);\n            $this->removed[] = $stat;\n            return $path;\n        }\n\n        return $this->setError(elFinder::ERROR_MOVE, $this->path($stat['hash']));\n    }\n\n    /**\n     * Copy file from another volume.\n     * Return new file path or false.\n     *\n     * @param  Object $volume      source volume\n     * @param  string $src         source file hash\n     * @param  string $destination destination dir path\n     * @param  string $name        file name\n     *\n     * @return string|false\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function copyFrom($volume, $src, $destination, $name)\n    {\n\n        elFinder::checkAborted();\n\n        if (($source = $volume->file($src)) == false) {\n            return $this->addError(elFinder::ERROR_COPY, '#' . $src, $volume->error());\n        }\n\n        $srcIsDir = ($source['mime'] === 'directory');\n\n        $errpath = $volume->path($source['hash']);\n\n        $errors = array();\n        try {\n            $thash = $this->encode($destination);\n            elFinder::$instance->trigger('paste.copyfrom', array(&$thash, &$name, '', elFinder::$instance, $this), $errors);\n        } catch (elFinderTriggerException $e) {\n            return $this->addError(elFinder::ERROR_COPY, $name, $errors);\n        }\n\n        if (!$this->nameAccepted($name, $srcIsDir)) {\n            return $this->addError(elFinder::ERROR_COPY, $name, $srcIsDir ? elFinder::ERROR_INVALID_DIRNAME : elFinder::ERROR_INVALID_NAME);\n        }\n\n        if (!$this->allowCreate($destination, $name, $srcIsDir)) {\n            return $this->addError(elFinder::ERROR_COPY, $name, elFinder::ERROR_PERM_DENIED);\n        }\n\n        if (!$source['read']) {\n            return $this->addError(elFinder::ERROR_COPY, $errpath, elFinder::ERROR_PERM_DENIED);\n        }\n\n        if ($srcIsDir) {\n            $test = $this->isNameExists($this->joinPathCE($destination, $name));\n            $this->clearcache();\n\n            if (($test && $test['mime'] != 'directory') || (!$test && !$test = $this->mkdir($this->encode($destination), $name))) {\n                return $this->addError(elFinder::ERROR_COPY, $errpath);\n            }\n\n            //$path = $this->joinPathCE($destination, $name);\n            $path = $this->decode($test['hash']);\n\n            foreach ($volume->scandir($src) as $entr) {\n                $this->copyFrom($volume, $entr['hash'], $path, $entr['name']);\n            }\n\n            $this->added[] = $test;\n        } else {\n            // size check\n            if (!isset($source['size']) || $source['size'] > $this->uploadMaxSize) {\n                return $this->setError(elFinder::ERROR_UPLOAD_FILE_SIZE);\n            }\n\n            // MIME check\n            $mimeByName = $this->mimetype($source['name'], true);\n            if ($source['mime'] === $mimeByName) {\n                $mimeByName = '';\n            }\n            if (!$this->allowPutMime($source['mime']) || ($mimeByName && !$this->allowPutMime($mimeByName))) {\n                return $this->addError(elFinder::ERROR_UPLOAD_FILE_MIME, $errpath);\n            }\n\n            if (strpos($source['mime'], 'image') === 0 && ($dim = $volume->dimensions($src))) {\n                if (is_array($dim)) {\n                    $dim = isset($dim['dim']) ? $dim['dim'] : null;\n                }\n                if ($dim) {\n                    $s = explode('x', $dim);\n                    $source['width'] = $s[0];\n                    $source['height'] = $s[1];\n                }\n            }\n\n            if (($fp = $volume->open($src)) == false\n                || ($path = $this->saveCE($fp, $destination, $name, $source)) == false) {\n                $fp && $volume->close($fp, $src);\n                return $this->addError(elFinder::ERROR_COPY, $errpath);\n            }\n            $volume->close($fp, $src);\n\n            $this->added[] = $this->stat($path);;\n        }\n\n        return $path;\n    }\n\n    /**\n     * Remove file/ recursive remove dir\n     *\n     * @param  string $path  file path\n     * @param  bool   $force try to remove even if file locked\n     *\n     * @return bool\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function remove($path, $force = false)\n    {\n        $stat = $this->stat($path);\n\n        if (empty($stat)) {\n            return $this->setError(elFinder::ERROR_RM, $this->relpathCE($path), elFinder::ERROR_FILE_NOT_FOUND);\n        }\n\n        $stat['realpath'] = $path;\n        $this->rmTmb($stat);\n        $this->clearcache();\n\n        if (!$force && !empty($stat['locked'])) {\n            return $this->setError(elFinder::ERROR_LOCKED, $this->path($stat['hash']));\n        }\n\n        if ($stat['mime'] == 'directory' && empty($stat['thash'])) {\n            $ret = $this->delTree($this->convEncIn($path));\n            $this->convEncOut();\n            if (!$ret) {\n                return $this->setError(elFinder::ERROR_RM, $this->path($stat['hash']));\n            }\n        } else {\n            if ($this->convEncOut(!$this->_unlink($this->convEncIn($path)))) {\n                return $this->setError(elFinder::ERROR_RM, $this->path($stat['hash']));\n            }\n            $this->clearstatcache();\n        }\n\n        $this->removed[] = $stat;\n        return true;\n    }\n\n\n    /************************* thumbnails **************************/\n\n    /**\n     * Return thumbnail file name for required file\n     *\n     * @param  array $stat file stat\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function tmbname($stat)\n    {\n        $name = $stat['hash'] . (isset($stat['ts']) ? $stat['ts'] : '') . '.png';\n        if (strlen($name) > 255) {\n            $name = $this->id . md5($stat['hash']) . $stat['ts'] . '.png';\n        }\n        return $name;\n    }\n\n    /**\n     * Return thumnbnail name if exists\n     *\n     * @param  string $path file path\n     * @param  array  $stat file stat\n     *\n     * @return string|false\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function gettmb($path, $stat)\n    {\n        if ($this->tmbURL && $this->tmbPath) {\n            // file itself thumnbnail\n            if (strpos($path, $this->tmbPath) === 0) {\n                return basename($path);\n            }\n\n            $name = $this->tmbname($stat);\n            $tmb = $this->tmbPath . DIRECTORY_SEPARATOR . $name;\n            if (file_exists($tmb)) {\n                if ($this->options['tmbGcMaxlifeHour'] && $this->options['tmbGcPercentage'] > 0) {\n                    touch($tmb);\n                }\n                return $name;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return true if thumnbnail for required file can be created\n     *\n     * @param  string $path thumnbnail path\n     * @param  array  $stat file stat\n     * @param  bool   $checkTmbPath\n     *\n     * @return string|bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function canCreateTmb($path, $stat, $checkTmbPath = true)\n    {\n        static $gdMimes = null;\n        static $imgmgPS = null;\n        if ($gdMimes === null) {\n            $_mimes = array('image/jpeg', 'image/png', 'image/gif', 'image/x-ms-bmp');\n            if (function_exists('imagecreatefromwebp')) {\n                $_mimes[] = 'image/webp';\n            }\n            $gdMimes = array_flip($_mimes);\n            $imgmgPS = array_flip(array('application/postscript', 'application/pdf'));\n        }\n        if ((!$checkTmbPath || $this->tmbPathWritable)\n            && (!$this->tmbPath || strpos($path, $this->tmbPath) === false) // do not create thumnbnail for thumnbnail\n        ) {\n            $mime = strtolower($stat['mime']);\n            list($type) = explode('/', $mime);\n            if (!empty($this->imgConverter)) {\n                if (isset($this->imgConverter[$mime])) {\n                    return true;\n                }\n                if (isset($this->imgConverter[$type])) {\n                    return true;\n                }\n            }\n            return $this->imgLib\n                && (\n                    ($type === 'image' && ($this->imgLib === 'gd' ? isset($gdMimes[$stat['mime']]) : true))\n                    ||\n                    (ELFINDER_IMAGEMAGICK_PS && isset($imgmgPS[$stat['mime']]) && $this->imgLib !== 'gd')\n                );\n        }\n        return false;\n    }\n\n    /**\n     * Return true if required file can be resized.\n     * By default - the same as canCreateTmb\n     *\n     * @param  string $path thumnbnail path\n     * @param  array  $stat file stat\n     *\n     * @return string|bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function canResize($path, $stat)\n    {\n        return $this->canCreateTmb($path, $stat, false);\n    }\n\n    /**\n     * Create thumnbnail and return it's URL on success\n     *\n     * @param  string $path file path\n     * @param         $stat\n     *\n     * @return false|string\n     * @internal param string $mime file mime type\n     * @throws elFinderAbortException\n     * @throws ImagickException\n     * @author   Dmitry (dio) Levashov\n     */\n    protected function createTmb($path, $stat)\n    {\n        if (!$stat || !$this->canCreateTmb($path, $stat)) {\n            return false;\n        }\n\n        $name = $this->tmbname($stat);\n        $tmb = $this->tmbPath . DIRECTORY_SEPARATOR . $name;\n\n        $maxlength = -1;\n        $imgConverter = null;\n\n        // check imgConverter\n        $mime = strtolower($stat['mime']);\n        list($type) = explode('/', $mime);\n        if (isset($this->imgConverter[$mime])) {\n            $imgConverter = $this->imgConverter[$mime]['func'];\n            if (!empty($this->imgConverter[$mime]['maxlen'])) {\n                $maxlength = intval($this->imgConverter[$mime]['maxlen']);\n            }\n        } else if (isset($this->imgConverter[$type])) {\n            $imgConverter = $this->imgConverter[$type]['func'];\n            if (!empty($this->imgConverter[$type]['maxlen'])) {\n                $maxlength = intval($this->imgConverter[$type]['maxlen']);\n            }\n        }\n        if ($imgConverter && !is_callable($imgConverter)) {\n            return false;\n        }\n\n        // copy image into tmbPath so some drivers does not store files on local fs\n        if (($src = $this->fopenCE($path, 'rb')) == false) {\n            return false;\n        }\n\n        if (($trg = fopen($tmb, 'wb')) == false) {\n            $this->fcloseCE($src, $path);\n            return false;\n        }\n\n        stream_copy_to_stream($src, $trg, $maxlength);\n\n        $this->fcloseCE($src, $path);\n        fclose($trg);\n\n        // call imgConverter\n        if ($imgConverter) {\n            if (!call_user_func_array($imgConverter, array($tmb, $stat, $this))) {\n                file_exists($tmb) && unlink($tmb);\n                return false;\n            }\n        }\n\n        $result = false;\n\n        $tmbSize = $this->tmbSize;\n\n        if ($this->imgLib === 'imagick') {\n            try {\n                $imagickTest = new imagick($tmb . '[0]');\n                $imagickTest->clear();\n                $imagickTest = true;\n            } catch (Exception $e) {\n                $imagickTest = false;\n            }\n        }\n\n        if (($this->imgLib === 'imagick' && !$imagickTest) || ($s = getimagesize($tmb)) === false) {\n            if ($this->imgLib === 'imagick') {\n                $bgcolor = $this->options['tmbBgColor'];\n                if ($bgcolor === 'transparent') {\n                    $bgcolor = 'rgba(255, 255, 255, 0.0)';\n                }\n                try {\n                    $imagick = new imagick();\n                    $imagick->setBackgroundColor(new ImagickPixel($bgcolor));\n                    $imagick->readImage($this->getExtentionByMime($stat['mime'], ':') . $tmb . '[0]');\n                    try {\n                        $imagick->trimImage(0);\n                    } catch (Exception $e) {\n                    }\n                    $imagick->setImageFormat('png');\n                    $imagick->writeImage($tmb);\n                    $imagick->clear();\n                    if (($s = getimagesize($tmb)) !== false) {\n                        $result = true;\n                    }\n                } catch (Exception $e) {\n                }\n            } else if ($this->imgLib === 'convert') {\n                $convParams = $this->imageMagickConvertPrepare($tmb, 'png', 100, array(), $stat['mime']);\n                $cmd = sprintf('%s -colorspace sRGB -trim -- %s %s', ELFINDER_CONVERT_PATH, $convParams['quotedPath'], $convParams['quotedDstPath']);\n                $result = false;\n                if ($this->procExec($cmd) === 0) {\n                    if (($s = getimagesize($tmb)) !== false) {\n                        $result = true;\n                    }\n                }\n            }\n            if (!$result) {\n                // fallback imgLib to GD\n                if (function_exists('gd_info') && ($s = getimagesize($tmb))) {\n                    $this->imgLib = 'gd';\n                } else {\n                    file_exists($tmb) && unlink($tmb);\n                    return false;\n                }\n            }\n        }\n\n        /* If image smaller or equal thumbnail size - just fitting to thumbnail square */\n        if ($s[0] <= $tmbSize && $s[1] <= $tmbSize) {\n            $result = $this->imgSquareFit($tmb, $tmbSize, $tmbSize, 'center', 'middle', $this->options['tmbBgColor'], 'png');\n        } else {\n\n            if ($this->options['tmbCrop']) {\n\n                $result = $tmb;\n                /* Resize and crop if image bigger than thumbnail */\n                if (!(($s[0] > $tmbSize && $s[1] <= $tmbSize) || ($s[0] <= $tmbSize && $s[1] > $tmbSize)) || ($s[0] > $tmbSize && $s[1] > $tmbSize)) {\n                    $result = $this->imgResize($tmb, $tmbSize, $tmbSize, true, false, 'png');\n                }\n\n                if ($result && ($s = getimagesize($tmb)) != false) {\n                    $x = $s[0] > $tmbSize ? intval(($s[0] - $tmbSize) / 2) : 0;\n                    $y = $s[1] > $tmbSize ? intval(($s[1] - $tmbSize) / 2) : 0;\n                    $result = $this->imgCrop($result, $tmbSize, $tmbSize, $x, $y, 'png');\n                } else {\n                    $result = false;\n                }\n\n            } else {\n                $result = $this->imgResize($tmb, $tmbSize, $tmbSize, true, true, 'png');\n            }\n\n            if ($result) {\n                if ($s = getimagesize($tmb)) {\n                    if ($s[0] !== $tmbSize || $s[1] !== $tmbSize) {\n                        $result = $this->imgSquareFit($result, $tmbSize, $tmbSize, 'center', 'middle', $this->options['tmbBgColor'], 'png');\n                    }\n                }\n            }\n        }\n\n        if (!$result) {\n            unlink($tmb);\n            return false;\n        }\n\n        return $name;\n    }\n\n    /**\n     * Resize image\n     *\n     * @param  string $path               image file\n     * @param  int    $width              new width\n     * @param  int    $height             new height\n     * @param  bool   $keepProportions    crop image\n     * @param  bool   $resizeByBiggerSide resize image based on bigger side if true\n     * @param  string $destformat         image destination format\n     * @param  int    $jpgQuality         JEPG quality (1-100)\n     * @param  array  $options            Other extra options\n     *\n     * @return string|false\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     * @author Alexey Sukhotin\n     */\n    protected function imgResize($path, $width, $height, $keepProportions = false, $resizeByBiggerSide = true, $destformat = null, $jpgQuality = null, $options = array())\n    {\n        if (($s = getimagesize($path)) == false) {\n            return false;\n        }\n\n        if (!$jpgQuality) {\n            $jpgQuality = $this->options['jpgQuality'];\n        }\n\n        list($orig_w, $orig_h) = array($s[0], $s[1]);\n        list($size_w, $size_h) = array($width, $height);\n\n        if (empty($options['unenlarge']) || $orig_w > $size_w || $orig_h > $size_h) {\n            if ($keepProportions == true) {\n                /* Resizing by biggest side */\n                if ($resizeByBiggerSide) {\n                    if ($orig_w > $orig_h) {\n                        $size_h = round($orig_h * $width / $orig_w);\n                        $size_w = $width;\n                    } else {\n                        $size_w = round($orig_w * $height / $orig_h);\n                        $size_h = $height;\n                    }\n                } else {\n                    if ($orig_w > $orig_h) {\n                        $size_w = round($orig_w * $height / $orig_h);\n                        $size_h = $height;\n                    } else {\n                        $size_h = round($orig_h * $width / $orig_w);\n                        $size_w = $width;\n                    }\n                }\n            }\n        } else {\n            $size_w = $orig_w;\n            $size_h = $orig_h;\n        }\n\n        elFinder::extendTimeLimit(300);\n        switch ($this->imgLib) {\n            case 'imagick':\n\n                try {\n                    $img = new imagick($path);\n                } catch (Exception $e) {\n                    return false;\n                }\n\n                // Imagick::FILTER_BOX faster than FILTER_LANCZOS so use for createTmb\n                // resize bench: http://app-mgng.rhcloud.com/9\n                // resize sample: http://www.dylanbeattie.net/magick/filters/result.html\n                $filter = ($destformat === 'png' /* createTmb */) ? Imagick::FILTER_BOX : Imagick::FILTER_LANCZOS;\n\n                $ani = ($img->getNumberImages() > 1);\n                if ($ani && is_null($destformat)) {\n                    $img = $img->coalesceImages();\n                    do {\n                        $img->resizeImage($size_w, $size_h, $filter, 1);\n                    } while ($img->nextImage());\n                    $img->optimizeImageLayers();\n                    $result = $img->writeImages($path, true);\n                } else {\n                    if ($ani) {\n                        $img->setFirstIterator();\n                    }\n                    if (strtoupper($img->getImageFormat()) === 'JPEG') {\n                        $img->setImageCompression(imagick::COMPRESSION_JPEG);\n                        $img->setImageCompressionQuality($jpgQuality);\n                        if (isset($options['preserveExif']) && !$options['preserveExif']) {\n                            try {\n                                $orientation = $img->getImageOrientation();\n                            } catch (ImagickException $e) {\n                                $orientation = 0;\n                            }\n                            $img->stripImage();\n                            if ($orientation) {\n                                $img->setImageOrientation($orientation);\n                            }\n                        }\n                        if ($this->options['jpgProgressive']) {\n                            $img->setInterlaceScheme(Imagick::INTERLACE_PLANE);\n                        }\n                    }\n                    $img->resizeImage($size_w, $size_h, $filter, true);\n                    if ($destformat) {\n                        $result = $this->imagickImage($img, $path, $destformat, $jpgQuality);\n                    } else {\n                        $result = $img->writeImage($path);\n                    }\n                }\n\n                $img->clear();\n\n                return $result ? $path : false;\n\n                break;\n\n            case 'convert':\n                extract($this->imageMagickConvertPrepare($path, $destformat, $jpgQuality, $s));\n                /**\n                 * @var string $ani\n                 * @var string $index\n                 * @var string $coalesce\n                 * @var string $deconstruct\n                 * @var string $jpgQuality\n                 * @var string $quotedPath\n                 * @var string $quotedDstPath\n                 * @var string $interlace\n                 */\n                $filter = ($destformat === 'png' /* createTmb */) ? '-filter Box' : '-filter Lanczos';\n                $strip = (isset($options['preserveExif']) && !$options['preserveExif']) ? ' -strip' : '';\n                $cmd = sprintf('%s %s%s%s%s%s %s -geometry %dx%d! %s %s', ELFINDER_CONVERT_PATH, $quotedPath, $coalesce, $jpgQuality, $strip, $interlace, $filter, $size_w, $size_h, $deconstruct, $quotedDstPath);\n\n                $result = false;\n                if ($this->procExec($cmd) === 0) {\n                    $result = true;\n                }\n                return $result ? $path : false;\n\n                break;\n\n            case 'gd':\n                elFinder::expandMemoryForGD(array($s, array($size_w, $size_h)));\n                $img = $this->gdImageCreate($path, $s['mime']);\n\n                if ($img && false != ($tmp = imagecreatetruecolor($size_w, $size_h))) {\n\n                    $bgNum = false;\n                    if ($s[2] === IMAGETYPE_GIF && (!$destformat || $destformat === 'gif')) {\n                        $bgIdx = imagecolortransparent($img);\n                        if ($bgIdx !== -1) {\n                            $c = imagecolorsforindex($img, $bgIdx);\n                            $bgNum = imagecolorallocate($tmp, $c['red'], $c['green'], $c['blue']);\n                            imagefill($tmp, 0, 0, $bgNum);\n                            imagecolortransparent($tmp, $bgNum);\n                        }\n                    }\n                    if ($bgNum === false) {\n                        $this->gdImageBackground($tmp, 'transparent');\n                    }\n\n                    if (!imagecopyresampled($tmp, $img, 0, 0, 0, 0, $size_w, $size_h, $s[0], $s[1])) {\n                        return false;\n                    }\n\n                    $result = $this->gdImage($tmp, $path, $destformat, $s['mime'], $jpgQuality);\n\n                    imagedestroy($img);\n                    imagedestroy($tmp);\n\n                    return $result ? $path : false;\n\n                }\n                break;\n        }\n\n        return false;\n    }\n\n    /**\n     * Crop image\n     *\n     * @param  string $path       image file\n     * @param  int    $width      crop width\n     * @param  int    $height     crop height\n     * @param  bool   $x          crop left offset\n     * @param  bool   $y          crop top offset\n     * @param  string $destformat image destination format\n     * @param  int    $jpgQuality JEPG quality (1-100)\n     *\n     * @return string|false\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     * @author Alexey Sukhotin\n     */\n    protected function imgCrop($path, $width, $height, $x, $y, $destformat = null, $jpgQuality = null)\n    {\n        if (($s = getimagesize($path)) == false) {\n            return false;\n        }\n\n        if (!$jpgQuality) {\n            $jpgQuality = $this->options['jpgQuality'];\n        }\n\n        elFinder::extendTimeLimit(300);\n        switch ($this->imgLib) {\n            case 'imagick':\n\n                try {\n                    $img = new imagick($path);\n                } catch (Exception $e) {\n                    return false;\n                }\n\n                $ani = ($img->getNumberImages() > 1);\n                if ($ani && is_null($destformat)) {\n                    $img = $img->coalesceImages();\n                    do {\n                        $img->setImagePage($s[0], $s[1], 0, 0);\n                        $img->cropImage($width, $height, $x, $y);\n                        $img->setImagePage($width, $height, 0, 0);\n                    } while ($img->nextImage());\n                    $img->optimizeImageLayers();\n                    $result = $img->writeImages($path, true);\n                } else {\n                    if ($ani) {\n                        $img->setFirstIterator();\n                    }\n                    $img->setImagePage($s[0], $s[1], 0, 0);\n                    $img->cropImage($width, $height, $x, $y);\n                    $img->setImagePage($width, $height, 0, 0);\n                    $result = $this->imagickImage($img, $path, $destformat, $jpgQuality);\n                }\n\n                $img->clear();\n\n                return $result ? $path : false;\n\n                break;\n\n            case 'convert':\n                extract($this->imageMagickConvertPrepare($path, $destformat, $jpgQuality, $s));\n                /**\n                 * @var string $ani\n                 * @var string $index\n                 * @var string $coalesce\n                 * @var string $deconstruct\n                 * @var string $jpgQuality\n                 * @var string $quotedPath\n                 * @var string $quotedDstPath\n                 * @var string $interlace\n                 */\n                $cmd = sprintf('%s %s%s%s%s -crop %dx%d+%d+%d%s %s', ELFINDER_CONVERT_PATH, $quotedPath, $coalesce, $jpgQuality, $interlace, $width, $height, $x, $y, $deconstruct, $quotedDstPath);\n\n                $result = false;\n                if ($this->procExec($cmd) === 0) {\n                    $result = true;\n                }\n                return $result ? $path : false;\n\n                break;\n\n            case 'gd':\n                elFinder::expandMemoryForGD(array($s, array($width, $height)));\n                $img = $this->gdImageCreate($path, $s['mime']);\n\n                if ($img && false != ($tmp = imagecreatetruecolor($width, $height))) {\n\n                    $bgNum = false;\n                    if ($s[2] === IMAGETYPE_GIF && (!$destformat || $destformat === 'gif')) {\n                        $bgIdx = imagecolortransparent($img);\n                        if ($bgIdx !== -1) {\n                            $c = imagecolorsforindex($img, $bgIdx);\n                            $bgNum = imagecolorallocate($tmp, $c['red'], $c['green'], $c['blue']);\n                            imagefill($tmp, 0, 0, $bgNum);\n                            imagecolortransparent($tmp, $bgNum);\n                        }\n                    }\n                    if ($bgNum === false) {\n                        $this->gdImageBackground($tmp, 'transparent');\n                    }\n\n                    $size_w = $width;\n                    $size_h = $height;\n\n                    if ($s[0] < $width || $s[1] < $height) {\n                        $size_w = $s[0];\n                        $size_h = $s[1];\n                    }\n\n                    if (!imagecopy($tmp, $img, 0, 0, $x, $y, $size_w, $size_h)) {\n                        return false;\n                    }\n\n                    $result = $this->gdImage($tmp, $path, $destformat, $s['mime'], $jpgQuality);\n\n                    imagedestroy($img);\n                    imagedestroy($tmp);\n\n                    return $result ? $path : false;\n\n                }\n                break;\n        }\n\n        return false;\n    }\n\n    /**\n     * Put image to square\n     *\n     * @param  string    $path       image file\n     * @param  int       $width      square width\n     * @param  int       $height     square height\n     * @param int|string $align      reserved\n     * @param int|string $valign     reserved\n     * @param  string    $bgcolor    square background color in #rrggbb format\n     * @param  string    $destformat image destination format\n     * @param  int       $jpgQuality JEPG quality (1-100)\n     *\n     * @return false|string\n     * @throws ImagickException\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     * @author Alexey Sukhotin\n     */\n    protected function imgSquareFit($path, $width, $height, $align = 'center', $valign = 'middle', $bgcolor = '#0000ff', $destformat = null, $jpgQuality = null)\n    {\n        if (($s = getimagesize($path)) == false) {\n            return false;\n        }\n\n        $result = false;\n\n        /* Coordinates for image over square aligning */\n        $y = ceil(abs($height - $s[1]) / 2);\n        $x = ceil(abs($width - $s[0]) / 2);\n\n        if (!$jpgQuality) {\n            $jpgQuality = $this->options['jpgQuality'];\n        }\n\n        elFinder::extendTimeLimit(300);\n        switch ($this->imgLib) {\n            case 'imagick':\n                try {\n                    $img = new imagick($path);\n                } catch (Exception $e) {\n                    return false;\n                }\n\n                if ($bgcolor === 'transparent') {\n                    $bgcolor = 'rgba(255, 255, 255, 0.0)';\n                }\n                $ani = ($img->getNumberImages() > 1);\n                if ($ani && is_null($destformat)) {\n                    $img1 = new Imagick();\n                    $img1->setFormat('gif');\n                    $img = $img->coalesceImages();\n                    do {\n                        $gif = new Imagick();\n                        $gif->newImage($width, $height, new ImagickPixel($bgcolor));\n                        $gif->setImageColorspace($img->getImageColorspace());\n                        $gif->setImageFormat('gif');\n                        $gif->compositeImage($img, imagick::COMPOSITE_OVER, $x, $y);\n                        $gif->setImageDelay($img->getImageDelay());\n                        $gif->setImageIterations($img->getImageIterations());\n                        $img1->addImage($gif);\n                        $gif->clear();\n                    } while ($img->nextImage());\n                    $img1->optimizeImageLayers();\n                    $result = $img1->writeImages($path, true);\n                } else {\n                    if ($ani) {\n                        $img->setFirstIterator();\n                    }\n                    $img1 = new Imagick();\n                    $img1->newImage($width, $height, new ImagickPixel($bgcolor));\n                    $img1->setImageColorspace($img->getImageColorspace());\n                    $img1->compositeImage($img, imagick::COMPOSITE_OVER, $x, $y);\n                    $result = $this->imagickImage($img1, $path, $destformat, $jpgQuality);\n                }\n\n                $img1->clear();\n                $img->clear();\n                return $result ? $path : false;\n\n                break;\n\n            case 'convert':\n                extract($this->imageMagickConvertPrepare($path, $destformat, $jpgQuality, $s));\n                /**\n                 * @var string $ani\n                 * @var string $index\n                 * @var string $coalesce\n                 * @var string $deconstruct\n                 * @var string $jpgQuality\n                 * @var string $quotedPath\n                 * @var string $quotedDstPath\n                 * @var string $interlace\n                 */\n                if ($bgcolor === 'transparent') {\n                    $bgcolor = 'rgba(255, 255, 255, 0.0)';\n                }\n                $cmd = sprintf('%s -size %dx%d \"xc:%s\" png:- | convert%s%s%s png:-  %s -geometry +%d+%d -compose over -composite%s %s', ELFINDER_CONVERT_PATH, $width, $height, $bgcolor, $coalesce, $jpgQuality, $interlace, $quotedPath, $x, $y, $deconstruct, $quotedDstPath);\n\n                $result = false;\n                if ($this->procExec($cmd) === 0) {\n                    $result = true;\n                }\n                return $result ? $path : false;\n\n                break;\n\n            case 'gd':\n                elFinder::expandMemoryForGD(array($s, array($width, $height)));\n                $img = $this->gdImageCreate($path, $s['mime']);\n\n                if ($img && false != ($tmp = imagecreatetruecolor($width, $height))) {\n\n                    $this->gdImageBackground($tmp, $bgcolor);\n                    if ($bgcolor === 'transparent' && ($destformat === 'png' || $s[2] === IMAGETYPE_PNG)) {\n                        $bgNum = imagecolorallocatealpha($tmp, 255, 255, 255, 127);\n                        imagefill($tmp, 0, 0, $bgNum);\n                    }\n\n                    if (!imagecopy($tmp, $img, $x, $y, 0, 0, $s[0], $s[1])) {\n                        return false;\n                    }\n\n                    $result = $this->gdImage($tmp, $path, $destformat, $s['mime'], $jpgQuality);\n\n                    imagedestroy($img);\n                    imagedestroy($tmp);\n\n                    return $result ? $path : false;\n                }\n                break;\n        }\n\n        return false;\n    }\n\n    /**\n     * Rotate image\n     *\n     * @param  string $path       image file\n     * @param  int    $degree     rotete degrees\n     * @param  string $bgcolor    square background color in #rrggbb format\n     * @param  string $destformat image destination format\n     * @param  int    $jpgQuality JEPG quality (1-100)\n     *\n     * @return string|false\n     * @throws elFinderAbortException\n     * @author nao-pon\n     * @author Troex Nevelin\n     */\n    protected function imgRotate($path, $degree, $bgcolor = '#ffffff', $destformat = null, $jpgQuality = null)\n    {\n        if (($s = getimagesize($path)) == false || $degree % 360 === 0) {\n            return false;\n        }\n\n        $result = false;\n\n        // try lossless rotate\n        if ($degree % 90 === 0 && in_array($s[2], array(IMAGETYPE_JPEG, IMAGETYPE_JPEG2000))) {\n            $count = ($degree / 90) % 4;\n            $exiftran = array(\n                1 => '-9',\n                2 => '-1',\n                3 => '-2'\n            );\n            $jpegtran = array(\n                1 => '90',\n                2 => '180',\n                3 => '270'\n            );\n            $quotedPath = escapeshellarg($path);\n            $cmds = array();\n            if ($this->procExec(ELFINDER_EXIFTRAN_PATH . ' -h') === 0) {\n                $cmds[] = ELFINDER_EXIFTRAN_PATH . ' -i ' . $exiftran[$count] . ' -- ' . $quotedPath;\n            }\n            if ($this->procExec(ELFINDER_JPEGTRAN_PATH . ' -version') === 0) {\n                $cmds[] = ELFINDER_JPEGTRAN_PATH . ' -rotate ' . $jpegtran[$count] . ' -copy all -outfile ' . $quotedPath . ' -- ' . $quotedPath;\n            }\n            foreach ($cmds as $cmd) {\n                if ($this->procExec($cmd) === 0) {\n                    $result = true;\n                    break;\n                }\n            }\n            if ($result) {\n                return $path;\n            }\n        }\n\n        if (!$jpgQuality) {\n            $jpgQuality = $this->options['jpgQuality'];\n        }\n\n        elFinder::extendTimeLimit(300);\n        switch ($this->imgLib) {\n            case 'imagick':\n                try {\n                    $img = new imagick($path);\n                } catch (Exception $e) {\n                    return false;\n                }\n\n                if ($s[2] === IMAGETYPE_GIF || $s[2] === IMAGETYPE_PNG) {\n                    $bgcolor = 'rgba(255, 255, 255, 0.0)';\n                }\n                if ($img->getNumberImages() > 1) {\n                    $img = $img->coalesceImages();\n                    do {\n                        $img->rotateImage(new ImagickPixel($bgcolor), $degree);\n                    } while ($img->nextImage());\n                    $img->optimizeImageLayers();\n                    $result = $img->writeImages($path, true);\n                } else {\n                    $img->rotateImage(new ImagickPixel($bgcolor), $degree);\n                    $result = $this->imagickImage($img, $path, $destformat, $jpgQuality);\n                }\n                $img->clear();\n                return $result ? $path : false;\n\n                break;\n\n            case 'convert':\n                extract($this->imageMagickConvertPrepare($path, $destformat, $jpgQuality, $s));\n                /**\n                 * @var string $ani\n                 * @var string $index\n                 * @var string $coalesce\n                 * @var string $deconstruct\n                 * @var string $jpgQuality\n                 * @var string $quotedPath\n                 * @var string $quotedDstPath\n                 * @var string $interlace\n                 */\n                if ($s[2] === IMAGETYPE_GIF || $s[2] === IMAGETYPE_PNG) {\n                    $bgcolor = 'rgba(255, 255, 255, 0.0)';\n                }\n                $cmd = sprintf('%s%s%s%s -background \"%s\" -rotate %d%s -- %s %s', ELFINDER_CONVERT_PATH, $coalesce, $jpgQuality, $interlace, $bgcolor, $degree, $deconstruct, $quotedPath, $quotedDstPath);\n\n                $result = false;\n                if ($this->procExec($cmd) === 0) {\n                    $result = true;\n                }\n                return $result ? $path : false;\n\n                break;\n\n            case 'gd':\n                elFinder::expandMemoryForGD(array($s, $s));\n                $img = $this->gdImageCreate($path, $s['mime']);\n\n                $degree = 360 - $degree;\n\n                $bgNum = -1;\n                $bgIdx = false;\n                if ($s[2] === IMAGETYPE_GIF) {\n                    $bgIdx = imagecolortransparent($img);\n                    if ($bgIdx !== -1) {\n                        $c = imagecolorsforindex($img, $bgIdx);\n                        $w = imagesx($img);\n                        $h = imagesy($img);\n                        $newImg = imagecreatetruecolor($w, $h);\n                        imagepalettecopy($newImg, $img);\n                        $bgNum = imagecolorallocate($newImg, $c['red'], $c['green'], $c['blue']);\n                        imagefill($newImg, 0, 0, $bgNum);\n                        imagecolortransparent($newImg, $bgNum);\n                        imagecopy($newImg, $img, 0, 0, 0, 0, $w, $h);\n                        imagedestroy($img);\n                        $img = $newImg;\n                        $newImg = null;\n                    }\n                } else if ($s[2] === IMAGETYPE_PNG) {\n                    $bgNum = imagecolorallocatealpha($img, 255, 255, 255, 127);\n                }\n                if ($bgNum === -1) {\n                    list($r, $g, $b) = sscanf($bgcolor, \"#%02x%02x%02x\");\n                    $bgNum = imagecolorallocate($img, $r, $g, $b);\n                }\n\n                $tmp = imageRotate($img, $degree, $bgNum);\n                if ($bgIdx !== -1) {\n                    imagecolortransparent($tmp, $bgNum);\n                }\n\n                $result = $this->gdImage($tmp, $path, $destformat, $s['mime'], $jpgQuality);\n\n                imageDestroy($img);\n                imageDestroy($tmp);\n\n                return $result ? $path : false;\n\n                break;\n        }\n\n        return false;\n    }\n\n    /**\n     * Execute shell command\n     *\n     * @param  string $command      command line\n     * @param  string $output       stdout strings\n     * @param  int    $return_var   process exit code\n     * @param  string $error_output stderr strings\n     *\n     * @return int exit code\n     * @throws elFinderAbortException\n     * @author Alexey Sukhotin\n     */\n    protected function procExec($command, &$output = '', &$return_var = -1, &$error_output = '', $cwd = null)\n    {\n        return elFinder::procExec($command, $output, $return_var, $error_output);\n    }\n\n    /**\n     * Remove thumbnail, also remove recursively if stat is directory\n     *\n     * @param  array $stat file stat\n     *\n     * @return void\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     * @author Naoki Sawada\n     * @author Troex Nevelin\n     */\n    protected function rmTmb($stat)\n    {\n        if ($this->tmbPathWritable) {\n            if ($stat['mime'] === 'directory') {\n                foreach ($this->scandirCE($this->decode($stat['hash'])) as $p) {\n                    elFinder::extendTimeLimit(30);\n                    $name = $this->basenameCE($p);\n                    $name != '.' && $name != '..' && $this->rmTmb($this->stat($p));\n                }\n            } else if (!empty($stat['tmb']) && $stat['tmb'] != \"1\") {\n                $tmb = $this->tmbPath . DIRECTORY_SEPARATOR . rawurldecode($stat['tmb']);\n                file_exists($tmb) && unlink($tmb);\n                clearstatcache();\n            }\n        }\n    }\n\n    /**\n     * Create an gd image according to the specified mime type\n     *\n     * @param string $path image file\n     * @param string $mime\n     *\n     * @return resource|false GD image resource identifier\n     */\n    protected function gdImageCreate($path, $mime)\n    {\n        switch ($mime) {\n            case 'image/jpeg':\n                return imagecreatefromjpeg($path);\n\n            case 'image/png':\n                return imagecreatefrompng($path);\n\n            case 'image/gif':\n                return imagecreatefromgif($path);\n\n            case 'image/x-ms-bmp':\n                if (!function_exists('imagecreatefrombmp')) {\n                    include_once dirname(__FILE__) . '/libs/GdBmp.php';\n                }\n                return imagecreatefrombmp($path);\n\n            case 'image/xbm':\n                return imagecreatefromxbm($path);\n\n            case 'image/xpm':\n                return imagecreatefromxpm($path);\n\n            case 'image/webp':\n                return imagecreatefromwebp($path);\n        }\n        return false;\n    }\n\n    /**\n     * Output gd image to file\n     *\n     * @param resource $image      gd image resource\n     * @param string   $filename   The path to save the file to.\n     * @param string   $destformat The Image type to use for $filename\n     * @param string   $mime       The original image mime type\n     * @param int      $jpgQuality JEPG quality (1-100)\n     *\n     * @return bool\n     */\n    protected function gdImage($image, $filename, $destformat, $mime, $jpgQuality = null)\n    {\n\n        if (!$jpgQuality) {\n            $jpgQuality = $this->options['jpgQuality'];\n        }\n        if ($destformat) {\n            switch ($destformat) {\n                case 'jpg':\n                    $mime = 'image/jpeg';\n                    break;\n                case 'gif':\n                    $mime = 'image/gif';\n                    break;\n                case 'png':\n                default:\n                    $mime = 'image/png';\n                    break;\n            }\n        }\n        switch ($mime) {\n            case 'image/gif':\n                return imagegif($image, $filename);\n            case 'image/jpeg':\n                if ($this->options['jpgProgressive']) {\n                    imageinterlace($image, true);\n                }\n                return imagejpeg($image, $filename, $jpgQuality);\n            case 'image/wbmp':\n                return imagewbmp($image, $filename);\n            case 'image/png':\n            default:\n                return imagepng($image, $filename);\n        }\n    }\n\n    /**\n     * Output imagick image to file\n     *\n     * @param imagick $img        imagick image resource\n     * @param string  $filename   The path to save the file to.\n     * @param string  $destformat The Image type to use for $filename\n     * @param int     $jpgQuality JEPG quality (1-100)\n     *\n     * @return bool\n     */\n    protected function imagickImage($img, $filename, $destformat, $jpgQuality = null)\n    {\n\n        if (!$jpgQuality) {\n            $jpgQuality = $this->options['jpgQuality'];\n        }\n\n        try {\n            if ($destformat) {\n                if ($destformat === 'gif') {\n                    $img->setImageFormat('gif');\n                } else if ($destformat === 'png') {\n                    $img->setImageFormat('png');\n                } else if ($destformat === 'jpg') {\n                    $img->setImageFormat('jpeg');\n                }\n            }\n            if (strtoupper($img->getImageFormat()) === 'JPEG') {\n                $img->setImageCompression(imagick::COMPRESSION_JPEG);\n                $img->setImageCompressionQuality($jpgQuality);\n                if ($this->options['jpgProgressive']) {\n                    $img->setInterlaceScheme(Imagick::INTERLACE_PLANE);\n                }\n                try {\n                    $orientation = $img->getImageOrientation();\n                } catch (ImagickException $e) {\n                    $orientation = 0;\n                }\n                $img->stripImage();\n                if ($orientation) {\n                    $img->setImageOrientation($orientation);\n                }\n            }\n            $result = $img->writeImage($filename);\n        } catch (Exception $e) {\n            $result = false;\n        }\n\n        return $result;\n    }\n\n    /**\n     * Assign the proper background to a gd image\n     *\n     * @param resource $image   gd image resource\n     * @param string   $bgcolor background color in #rrggbb format\n     */\n    protected function gdImageBackground($image, $bgcolor)\n    {\n\n        if ($bgcolor === 'transparent') {\n            imagealphablending($image, false);\n            imagesavealpha($image, true);\n        } else {\n            list($r, $g, $b) = sscanf($bgcolor, \"#%02x%02x%02x\");\n            $bgcolor1 = imagecolorallocate($image, $r, $g, $b);\n            imagefill($image, 0, 0, $bgcolor1);\n        }\n    }\n\n    /**\n     * Prepare variables for exec convert of ImageMagick\n     *\n     * @param  string $path\n     * @param  string $destformat\n     * @param  int    $jpgQuality\n     * @param  array  $imageSize\n     * @param null    $mime\n     *\n     * @return array\n     * @throws elFinderAbortException\n     */\n    protected function imageMagickConvertPrepare($path, $destformat, $jpgQuality, $imageSize = null, $mime = null)\n    {\n        if (is_null($imageSize)) {\n            $imageSize = getimagesize($path);\n        }\n        if (is_null($mime)) {\n            $mime = $this->mimetype($path);\n        }\n        $srcType = $this->getExtentionByMime($mime, ':');\n        $ani = false;\n        if (preg_match('/^(?:gif|png|ico)/', $srcType)) {\n            $cmd = ELFINDER_IDENTIFY_PATH . ' -- ' . escapeshellarg($srcType . $path);\n            if ($this->procExec($cmd, $o) === 0) {\n                $ani = preg_split('/(?:\\r\\n|\\n|\\r)/', trim($o));\n                if (count($ani) < 2) {\n                    $ani = false;\n                }\n            }\n        }\n        $coalesce = $index = $interlace = '';\n        $deconstruct = ' +repage';\n        if ($ani && $destformat !== 'png'/* not createTmb */) {\n            if (is_null($destformat)) {\n                $coalesce = ' -coalesce -repage 0x0';\n                $deconstruct = ' +repage -deconstruct -layers optimize';\n            } else if ($imageSize) {\n                if ($srcType === 'ico:') {\n                    $index = '[0]';\n                    foreach ($ani as $_i => $_info) {\n                        if (preg_match('/ (\\d+)x(\\d+) /', $_info, $m)) {\n                            if ($m[1] == $imageSize[0] && $m[2] == $imageSize[1]) {\n                                $index = '[' . $_i . ']';\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        } else {\n            $index = '[0]';\n        }\n        if ($imageSize && ($imageSize[2] === IMAGETYPE_JPEG || $imageSize[2] === IMAGETYPE_JPEG2000)) {\n            $jpgQuality = ' -quality ' . $jpgQuality;\n            if ($this->options['jpgProgressive']) {\n                $interlace = ' -interlace Plane';\n            }\n        } else {\n            $jpgQuality = '';\n        }\n        $quotedPath = escapeshellarg($srcType . $path . $index);\n        $quotedDstPath = escapeshellarg(($destformat ? ($destformat . ':') : $srcType) . $path);\n        return compact('ani', 'index', 'coalesce', 'deconstruct', 'jpgQuality', 'quotedPath', 'quotedDstPath', 'interlace');\n    }\n\n    /*********************** misc *************************/\n\n    /**\n     * Find position of first occurrence of string in a string with multibyte support\n     *\n     * @param  string $haystack The string being checked.\n     * @param  string $needle   The string to find in haystack.\n     * @param  int    $offset   The search offset. If it is not specified, 0 is used.\n     *\n     * @return int|bool\n     * @author Alexey Sukhotin\n     **/\n    protected function stripos($haystack, $needle, $offset = 0)\n    {\n        if (function_exists('mb_stripos')) {\n            return mb_stripos($haystack, $needle, $offset, 'UTF-8');\n        } else if (function_exists('mb_strtolower') && function_exists('mb_strpos')) {\n            return mb_strpos(mb_strtolower($haystack, 'UTF-8'), mb_strtolower($needle, 'UTF-8'), $offset);\n        }\n        return stripos($haystack, $needle, $offset);\n    }\n\n    /**\n     * Default serach match method (name match)\n     *\n     * @param  String $name  Item name\n     * @param  String $query Query word\n     * @param  String $path  Item path\n     *\n     * @return bool @return bool\n     */\n    protected function searchMatchName($name, $query, $path)\n    {\n        return $this->stripos($name, $query) !== false;\n    }\n\n    /**\n     * Get server side available archivers\n     *\n     * @param bool $use_cache\n     *\n     * @return array\n     * @throws elFinderAbortException\n     */\n    protected function getArchivers($use_cache = true)\n    {\n        $sessionKey = 'archivers';\n        if ($use_cache) {\n            if (isset($this->options['archivers']) && is_array($this->options['archivers']) && $this->options['archivers']) {\n                $cache = $this->options['archivers'];\n            } else {\n                $cache = elFinder::$archivers;\n            }\n            if ($cache) {\n                return $cache;\n            } else {\n                if ($cache = $this->session->get($sessionKey, array())) {\n                    return elFinder::$archivers = $cache;\n                }\n            }\n        }\n\n        $arcs = array(\n            'create' => array(),\n            'extract' => array()\n        );\n\n        if ($this->procExec('') === 0) {\n\n            $this->procExec(ELFINDER_TAR_PATH . ' --version', $o, $ctar);\n\n            if ($ctar == 0) {\n                $arcs['create']['application/x-tar'] = array('cmd' => ELFINDER_TAR_PATH, 'argc' => '-chf', 'ext' => 'tar');\n                $arcs['extract']['application/x-tar'] = array('cmd' => ELFINDER_TAR_PATH, 'argc' => '-xf', 'ext' => 'tar', 'toSpec' => '-C ', 'getsize' => array('argc' => '-xvf', 'toSpec' => '--to-stdout|wc -c', 'regex' => '/^.+(?:\\r\\n|\\n|\\r)[^\\r\\n0-9]*([0-9]+)[^\\r\\n]*$/s', 'replace' => '$1'));\n                unset($o);\n                $this->procExec(ELFINDER_GZIP_PATH . ' --version', $o, $c);\n                if ($c == 0) {\n                    $arcs['create']['application/x-gzip'] = array('cmd' => ELFINDER_TAR_PATH, 'argc' => '-czhf', 'ext' => 'tgz');\n                    $arcs['extract']['application/x-gzip'] = array('cmd' => ELFINDER_TAR_PATH, 'argc' => '-xzf', 'ext' => 'tgz', 'toSpec' => '-C ', 'getsize' => array('argc' => '-xvf', 'toSpec' => '--to-stdout|wc -c', 'regex' => '/^.+(?:\\r\\n|\\n|\\r)[^\\r\\n0-9]*([0-9]+)[^\\r\\n]*$/s', 'replace' => '$1'));\n                }\n                unset($o);\n                $this->procExec(ELFINDER_BZIP2_PATH . ' --version', $o, $c);\n                if ($c == 0) {\n                    $arcs['create']['application/x-bzip2'] = array('cmd' => ELFINDER_TAR_PATH, 'argc' => '-cjhf', 'ext' => 'tbz');\n                    $arcs['extract']['application/x-bzip2'] = array('cmd' => ELFINDER_TAR_PATH, 'argc' => '-xjf', 'ext' => 'tbz', 'toSpec' => '-C ', 'getsize' => array('argc' => '-xvf', 'toSpec' => '--to-stdout|wc -c', 'regex' => '/^.+(?:\\r\\n|\\n|\\r)[^\\r\\n0-9]*([0-9]+)[^\\r\\n]*$/s', 'replace' => '$1'));\n                }\n                unset($o);\n                $this->procExec(ELFINDER_XZ_PATH . ' --version', $o, $c);\n                if ($c == 0) {\n                    $arcs['create']['application/x-xz'] = array('cmd' => ELFINDER_TAR_PATH, 'argc' => '-cJhf', 'ext' => 'xz');\n                    $arcs['extract']['application/x-xz'] = array('cmd' => ELFINDER_TAR_PATH, 'argc' => '-xJf', 'ext' => 'xz', 'toSpec' => '-C ', 'getsize' => array('argc' => '-xvf', 'toSpec' => '--to-stdout|wc -c', 'regex' => '/^.+(?:\\r\\n|\\n|\\r)[^\\r\\n0-9]*([0-9]+)[^\\r\\n]*$/s', 'replace' => '$1'));\n                }\n            }\n            unset($o);\n            $this->procExec(ELFINDER_ZIP_PATH . ' -h', $o, $c);\n            if ($c == 0) {\n                $arcs['create']['application/zip'] = array('cmd' => ELFINDER_ZIP_PATH, 'argc' => '-r9 -q', 'ext' => 'zip');\n            }\n            unset($o);\n            $this->procExec(ELFINDER_UNZIP_PATH . ' --help', $o, $c);\n            if ($c == 0) {\n                $arcs['extract']['application/zip'] = array('cmd' => ELFINDER_UNZIP_PATH, 'argc' => '-q', 'ext' => 'zip', 'toSpec' => '-d ', 'getsize' => array('argc' => '-Z -t', 'regex' => '/^.+?,\\s?([0-9]+).+$/', 'replace' => '$1'));\n            }\n            unset($o);\n            $this->procExec(ELFINDER_RAR_PATH, $o, $c);\n            if ($c == 0 || $c == 7) {\n                $arcs['create']['application/x-rar'] = array('cmd' => ELFINDER_RAR_PATH, 'argc' => 'a -inul' . (defined('ELFINDER_RAR_MA4') && ELFINDER_RAR_MA4? ' -ma4' : '') . ' --', 'ext' => 'rar');\n            }\n            unset($o);\n            $this->procExec(ELFINDER_UNRAR_PATH, $o, $c);\n            if ($c == 0 || $c == 7) {\n                $arcs['extract']['application/x-rar'] = array('cmd' => ELFINDER_UNRAR_PATH, 'argc' => 'x -y', 'ext' => 'rar', 'toSpec' => '', 'getsize' => array('argc' => 'l', 'regex' => '/^.+(?:\\r\\n|\\n|\\r)(?:(?:[^\\r\\n0-9]+[0-9]+[^\\r\\n0-9]+([0-9]+)[^\\r\\n]+)|(?:[^\\r\\n0-9]+([0-9]+)[^\\r\\n0-9]+[0-9]+[^\\r\\n]*))$/s', 'replace' => '$1'));\n            }\n            unset($o);\n            $this->procExec(ELFINDER_7Z_PATH, $o, $c);\n            if ($c == 0) {\n                $arcs['create']['application/x-7z-compressed'] = array('cmd' => ELFINDER_7Z_PATH, 'argc' => 'a --', 'ext' => '7z');\n                $arcs['extract']['application/x-7z-compressed'] = array('cmd' => ELFINDER_7Z_PATH, 'argc' => 'x -y', 'ext' => '7z', 'toSpec' => '-o', 'getsize' => array('argc' => 'l', 'regex' => '/^.+(?:\\r\\n|\\n|\\r)[^\\r\\n0-9]+([0-9]+)[^\\r\\n]+$/s', 'replace' => '$1'));\n\n                if (empty($arcs['create']['application/zip'])) {\n                    $arcs['create']['application/zip'] = array('cmd' => ELFINDER_7Z_PATH, 'argc' => 'a -tzip --', 'ext' => 'zip');\n                }\n                if (empty($arcs['extract']['application/zip'])) {\n                    $arcs['extract']['application/zip'] = array('cmd' => ELFINDER_7Z_PATH, 'argc' => 'x -tzip -y', 'ext' => 'zip', 'toSpec' => '-o', 'getsize' => array('argc' => 'l', 'regex' => '/^.+(?:\\r\\n|\\n|\\r)[^\\r\\n0-9]+([0-9]+)[^\\r\\n]+$/s', 'replace' => '$1'));\n                }\n                if (empty($arcs['create']['application/x-tar'])) {\n                    $arcs['create']['application/x-tar'] = array('cmd' => ELFINDER_7Z_PATH, 'argc' => 'a -ttar --', 'ext' => 'tar');\n                }\n                if (empty($arcs['extract']['application/x-tar'])) {\n                    $arcs['extract']['application/x-tar'] = array('cmd' => ELFINDER_7Z_PATH, 'argc' => 'x -ttar -y', 'ext' => 'tar', 'toSpec' => '-o', 'getsize' => array('argc' => 'l', 'regex' => '/^.+(?:\\r\\n|\\n|\\r)[^\\r\\n0-9]+([0-9]+)[^\\r\\n]+$/s', 'replace' => '$1'));\n                }\n                if (substr(PHP_OS, 0, 3) === 'WIN' && empty($arcs['extract']['application/x-rar'])) {\n                    $arcs['extract']['application/x-rar'] = array('cmd' => ELFINDER_7Z_PATH, 'argc' => 'x -trar -y', 'ext' => 'rar', 'toSpec' => '-o', 'getsize' => array('argc' => 'l', 'regex' => '/^.+(?:\\r\\n|\\n|\\r)[^\\r\\n0-9]+([0-9]+)[^\\r\\n]+$/s', 'replace' => '$1'));\n                }\n            }\n\n        }\n\n        // Use PHP ZipArchive Class\n        if (class_exists('ZipArchive', false)) {\n            if (empty($arcs['create']['application/zip'])) {\n                $arcs['create']['application/zip'] = array('cmd' => 'phpfunction', 'argc' => array('self', 'zipArchiveZip'), 'ext' => 'zip');\n            }\n            if (empty($arcs['extract']['application/zip'])) {\n                $arcs['extract']['application/zip'] = array('cmd' => 'phpfunction', 'argc' => array('self', 'zipArchiveUnzip'), 'ext' => 'zip');\n            }\n        }\n\n        $this->session->set($sessionKey, $arcs);\n        return elFinder::$archivers = $arcs;\n    }\n\n    /**\n     * Resolve relative / (Unix-like)absolute path\n     *\n     * @param string $path target path\n     * @param string $base base path\n     *\n     * @return string\n     */\n    protected function getFullPath($path, $base)\n    {\n        $separator = $this->separator;\n        $systemroot = $this->systemRoot;\n        $base = (string)$base;\n\n        if ($base[0] === $separator && substr($base, 0, strlen($systemroot)) !== $systemroot) {\n            $base = $systemroot . substr($base, 1);\n        }\n        if ($base !== $systemroot) {\n            $base = rtrim($base, $separator);\n        }\n\n        // 'Here'\n        if ($path === '' || $path === '.' . $separator) return $base;\n\n        $sepquoted = preg_quote($separator, '#');\n\n        if (substr($path, 0, 3) === '..' . $separator) {\n            $path = $base . $separator . $path;\n        }\n        // normalize `/../`\n        $normreg = '#(' . $sepquoted . ')[^' . $sepquoted . ']+' . $sepquoted . '\\.\\.' . $sepquoted . '#'; // '#(/)[^\\/]+/\\.\\./#'\n        while (preg_match($normreg, $path)) {\n            $path = preg_replace($normreg, '$1', $path, 1);\n        }\n        if ($path !== $systemroot) {\n            $path = rtrim($path, $separator);\n        }\n\n        // Absolute path\n        if ($path[0] === $separator || strpos($path, $systemroot) === 0) {\n            return $path;\n        }\n\n        $preg_separator = '#' . $sepquoted . '#';\n\n        // Relative path from 'Here'\n        if (substr($path, 0, 2) === '.' . $separator || $path[0] !== '.') {\n            $arrn = preg_split($preg_separator, $path, -1, PREG_SPLIT_NO_EMPTY);\n            if ($arrn[0] !== '.') {\n                array_unshift($arrn, '.');\n            }\n            $arrn[0] = rtrim($base, $separator);\n            return join($separator, $arrn);\n        }\n\n        return $path;\n    }\n\n    /**\n     * Remove directory recursive on local file system\n     *\n     * @param string $dir Target dirctory path\n     *\n     * @return boolean\n     * @throws elFinderAbortException\n     * @author Naoki Sawada\n     */\n    public function rmdirRecursive($dir)\n    {\n        return self::localRmdirRecursive($dir);\n    }\n\n    /**\n     * Create archive and return its path\n     *\n     * @param  string $dir   target dir\n     * @param  array  $files files names list\n     * @param  string $name  archive name\n     * @param  array  $arc   archiver options\n     *\n     * @return string|bool\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     * @author Naoki Sawada\n     */\n    protected function makeArchive($dir, $files, $name, $arc)\n    {\n        if ($arc['cmd'] === 'phpfunction') {\n            if (is_callable($arc['argc'])) {\n                call_user_func_array($arc['argc'], array($dir, $files, $name));\n            }\n        } else {\n            $cwd = getcwd();\n            if (chdir($dir)) {\n                foreach ($files as $i => $file) {\n                    $files[$i] = '.' . DIRECTORY_SEPARATOR . basename($file);\n                }\n                $files = array_map('escapeshellarg', $files);\n                $prefix = $switch = '';\n                // The zip command accepts the \"-\" at the beginning of the file name as a command switch,\n                // and can't use '--' before archive name, so add \"./\" to name for security reasons.\n                if ($arc['ext'] === 'zip' && strpos($arc['argc'], '-tzip') === false) {\n                    $prefix = './';\n                    $switch = '-- ';\n                }\n                $cmd = $arc['cmd'] . ' ' . $arc['argc'] . ' ' . $prefix . escapeshellarg($name) . ' ' . $switch . implode(' ', $files);\n                $err_out = '';\n                $this->procExec($cmd, $o, $c, $err_out, $dir);\n                chdir($cwd);\n            } else {\n                return false;\n            }\n        }\n        $path = $dir . DIRECTORY_SEPARATOR . $name;\n        return file_exists($path) ? $path : false;\n    }\n\n    /**\n     * Unpack archive\n     *\n     * @param  string      $path archive path\n     * @param  array       $arc  archiver command and arguments (same as in $this->archivers)\n     * @param  bool|string $mode bool: remove archive ( unlink($path) ) | string: extract to directory\n     *\n     * @return void\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     * @author Alexey Sukhotin\n     * @author Naoki Sawada\n     */\n    protected function unpackArchive($path, $arc, $mode = true)\n    {\n        if (is_string($mode)) {\n            $dir = $mode;\n            $chdir = null;\n            $remove = false;\n        } else {\n            $dir = dirname($path);\n            $chdir = $dir;\n            $remove = $mode;\n        }\n        $dir = realpath($dir);\n        $path = realpath($path);\n        if ($arc['cmd'] === 'phpfunction') {\n            if (is_callable($arc['argc'])) {\n                call_user_func_array($arc['argc'], array($path, $dir));\n            }\n        } else {\n            $cwd = getcwd();\n            if (!$chdir || chdir($dir)) {\n                if (!empty($arc['getsize'])) {\n                    // Check total file size after extraction\n                    $getsize = $arc['getsize'];\n                    if (is_array($getsize) && !empty($getsize['regex']) && !empty($getsize['replace'])) {\n                        $cmd = $arc['cmd'] . ' ' . $getsize['argc'] . ' ' . escapeshellarg($path) . (!empty($getsize['toSpec'])? (' ' . $getsize['toSpec']): '');\n                        $this->procExec($cmd, $o, $c);\n                        if ($o) {\n                            $size = preg_replace($getsize['regex'], $getsize['replace'], trim($o));\n                            $comp = function_exists('bccomp')? 'bccomp' : 'strnatcmp';\n                            if (!empty($this->options['maxArcFilesSize'])) {\n                                if ($comp($size, (string)$this->options['maxArcFilesSize']) > 0) {\n                                    throw new Exception(elFinder::ERROR_ARC_MAXSIZE);\n                                }\n                            }\n                        }\n                        unset($o, $c);\n                    }\n                }\n                if ($chdir) {\n                    $cmd = $arc['cmd'] . ' ' . $arc['argc'] . ' ' . escapeshellarg(basename($path));\n                } else {\n                    $cmd = $arc['cmd'] . ' ' . $arc['argc'] . ' ' . escapeshellarg($path) . ' ' . $arc['toSpec'] . escapeshellarg($dir);\n                }\n                $this->procExec($cmd, $o, $c);\n                $chdir && chdir($cwd);\n            }\n        }\n        $remove && unlink($path);\n    }\n\n    /**\n     * Check and filter the extracted items\n     *\n     * @param  string $path   target local path\n     * @param  array  $checks types to check default: ['symlink', 'name', 'writable', 'mime']\n     *\n     * @return array  ['symlinks' => [], 'names' => [], 'writables' => [], 'mimes' => [], 'rmNames' => [], 'totalSize' => 0]\n     * @throws elFinderAbortException\n     * @throws Exception\n     * @author Naoki Sawada\n     */\n    protected function checkExtractItems($path, $checks = null)\n    {\n        if (is_null($checks) || !is_array($checks)) {\n            $checks = array('symlink', 'name', 'writable', 'mime');\n        }\n        $chkSymlink = in_array('symlink', $checks);\n        $chkName = in_array('name', $checks);\n        $chkWritable = in_array('writable', $checks);\n        $chkMime = in_array('mime', $checks);\n\n        $res = array(\n            'symlinks' => array(),\n            'names' => array(),\n            'writables' => array(),\n            'mimes' => array(),\n            'rmNames' => array(),\n            'totalSize' => 0\n        );\n\n        if (is_dir($path)) {\n            $files = self::localScandir($path);\n        } else {\n            $files = array(basename($path));\n            $path = dirname($path);\n        }\n\n        foreach ($files as $name) {\n            $p = $path . DIRECTORY_SEPARATOR . $name;\n            $utf8Name = elFinder::$instance->utf8Encode($name);\n            if ($name !== $utf8Name) {\n                $fsSame = false;\n                if ($this->encoding) {\n                    // test as fs encoding\n                    $_utf8 = @iconv($this->encoding, 'utf-8//IGNORE', $name);\n                    if (@iconv('utf-8', $this->encoding.'//IGNORE', $_utf8) === $name) {\n                        $fsSame = true;\n                        $utf8Name = $_utf8;\n                    } else {\n                        $_name = $this->convEncIn($utf8Name, true);\n                    }\n                } else {\n                    $_name = $utf8Name;\n                }\n                if (!$fsSame && rename($p, $path . DIRECTORY_SEPARATOR . $_name)) {\n                    $name = $_name;\n                    $p = $path . DIRECTORY_SEPARATOR . $name;\n                }\n            }\n            if (!is_readable($p)) {\n                // Perhaps a symbolic link to open_basedir restricted location\n                self::localRmdirRecursive($p);\n                $res['symlinks'][] = $p;\n                $res['rmNames'][] = $utf8Name;\n                continue;\n            }\n            if ($chkSymlink && is_link($p)) {\n                self::localRmdirRecursive($p);\n                $res['symlinks'][] = $p;\n                $res['rmNames'][] = $utf8Name;\n                continue;\n            }\n            $isDir = is_dir($p);\n            if ($chkName && !$this->nameAccepted($name, $isDir)) {\n                self::localRmdirRecursive($p);\n                $res['names'][] = $p;\n                $res['rmNames'][] = $utf8Name;\n                continue;\n            }\n            if ($chkWritable && !$this->attr($p, 'write', null, $isDir)) {\n                self::localRmdirRecursive($p);\n                $res['writables'][] = $p;\n                $res['rmNames'][] = $utf8Name;\n                continue;\n            }\n            if ($isDir) {\n                $cRes = $this->checkExtractItems($p, $checks);\n                foreach ($cRes as $k => $v) {\n                    if (is_array($v)) {\n                        $res[$k] = array_merge($res[$k], $cRes[$k]);\n                    } else {\n                        $res[$k] += $cRes[$k];\n                    }\n                }\n            } else {\n                if ($chkMime && ($mimeByName = elFinderVolumeDriver::mimetypeInternalDetect($name)) && !$this->allowPutMime($mimeByName)) {\n                    self::localRmdirRecursive($p);\n                    $res['mimes'][] = $p;\n                    $res['rmNames'][] = $utf8Name;\n                    continue;\n                }\n                $res['totalSize'] += (int)sprintf('%u', filesize($p));\n            }\n        }\n        $res['rmNames'] = array_unique($res['rmNames']);\n\n        return $res;\n    }\n\n    /**\n     * Return files of target directory that is dotfiles excludes.\n     *\n     * @param  string $dir target directory path\n     *\n     * @return array\n     * @throws Exception\n     * @author Naoki Sawada\n     */\n    protected static function localScandir($dir)\n    {\n        // PHP function scandir() is not work well in specific environment. I dont know why.\n        // ref. https://github.com/Studio-42/elFinder/issues/1248\n        $files = array();\n        if ($dh = opendir($dir)) {\n            while (false !== ($file = readdir($dh))) {\n                if ($file !== '.' && $file !== '..') {\n                    $files[] = $file;\n                }\n            }\n            closedir($dh);\n        } else {\n            throw new Exception('Can not open local directory.');\n        }\n        return $files;\n    }\n\n    /**\n     * Remove directory recursive on local file system\n     *\n     * @param string $dir Target dirctory path\n     *\n     * @return boolean\n     * @throws elFinderAbortException\n     * @author Naoki Sawada\n     */\n    protected static function localRmdirRecursive($dir)\n    {\n        // try system command\n        if (is_callable('exec')) {\n            $o = '';\n            $r = 1;\n            if (substr(PHP_OS, 0, 3) === 'WIN') {\n                if (!is_link($dir) && is_dir($dir)) {\n                    exec('rd /S /Q ' . escapeshellarg($dir), $o, $r);\n                } else {\n                    exec('del /F /Q ' . escapeshellarg($dir), $o, $r);\n                }\n            } else {\n                exec('rm -rf ' . escapeshellarg($dir), $o, $r);\n            }\n            if ($r === 0) {\n                return true;\n            }\n        }\n        if (!is_link($dir) && is_dir($dir)) {\n            chmod($dir, 0777);\n            if ($handle = opendir($dir)) {\n                while (false !== ($file = readdir($handle))) {\n                    if ($file === '.' || $file === '..') {\n                        continue;\n                    }\n                    elFinder::extendTimeLimit(30);\n                    $path = $dir . DIRECTORY_SEPARATOR . $file;\n                    if (!is_link($dir) && is_dir($path)) {\n                        self::localRmdirRecursive($path);\n                    } else {\n                        chmod($path, 0666);\n                        unlink($path);\n                    }\n                }\n                closedir($handle);\n            }\n            return rmdir($dir);\n        } else {\n            chmod($dir, 0666);\n            return unlink($dir);\n        }\n    }\n\n    /**\n     * Move item recursive on local file system\n     *\n     * @param string $src\n     * @param string $target\n     * @param bool   $overWrite\n     * @param bool   $copyJoin\n     *\n     * @return boolean\n     * @throws elFinderAbortException\n     * @throws Exception\n     * @author Naoki Sawada\n     */\n    protected static function localMoveRecursive($src, $target, $overWrite = true, $copyJoin = true)\n    {\n        $res = false;\n        if (!file_exists($target)) {\n            return rename($src, $target);\n        }\n        if (!$copyJoin || !is_dir($target)) {\n            if ($overWrite) {\n                if (is_dir($target)) {\n                    $del = self::localRmdirRecursive($target);\n                } else {\n                    $del = unlink($target);\n                }\n                if ($del) {\n                    return rename($src, $target);\n                }\n            }\n        } else {\n            foreach (self::localScandir($src) as $item) {\n                $res |= self::localMoveRecursive($src . DIRECTORY_SEPARATOR . $item, $target . DIRECTORY_SEPARATOR . $item, $overWrite, $copyJoin);\n            }\n        }\n        return (bool)$res;\n    }\n\n    /**\n     * Create Zip archive using PHP class ZipArchive\n     *\n     * @param  string        $dir     target dir\n     * @param  array         $files   files names list\n     * @param  string|object $zipPath Zip archive name\n     *\n     * @return bool\n     * @author Naoki Sawada\n     */\n    protected static function zipArchiveZip($dir, $files, $zipPath)\n    {\n        try {\n            if ($start = is_string($zipPath)) {\n                $zip = new ZipArchive();\n                if ($zip->open($dir . DIRECTORY_SEPARATOR . $zipPath, ZipArchive::CREATE) !== true) {\n                    $zip = false;\n                }\n            } else {\n                $zip = $zipPath;\n            }\n            if ($zip) {\n                foreach ($files as $file) {\n                    $path = $dir . DIRECTORY_SEPARATOR . $file;\n                    if (is_dir($path)) {\n                        $zip->addEmptyDir($file);\n                        $_files = array();\n                        if ($handle = opendir($path)) {\n                            while (false !== ($entry = readdir($handle))) {\n                                if ($entry !== \".\" && $entry !== \"..\") {\n                                    $_files[] = $file . DIRECTORY_SEPARATOR . $entry;\n                                }\n                            }\n                            closedir($handle);\n                        }\n                        if ($_files) {\n                            self::zipArchiveZip($dir, $_files, $zip);\n                        }\n                    } else {\n                        $zip->addFile($path, $file);\n                    }\n                }\n                $start && $zip->close();\n            }\n        } catch (Exception $e) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Unpack Zip archive using PHP class ZipArchive\n     *\n     * @param  string $zipPath Zip archive name\n     * @param  string $toDir   Extract to path\n     *\n     * @return bool\n     * @author Naoki Sawada\n     */\n    protected static function zipArchiveUnzip($zipPath, $toDir)\n    {\n        try {\n            $zip = new ZipArchive();\n            if ($zip->open($zipPath) === true) {\n                // Check total file size after extraction\n                $num = $zip->numFiles;\n                $size = 0;\n                $maxSize = empty(self::$maxArcFilesSize)? '' : (string)self::$maxArcFilesSize;\n                $comp = function_exists('bccomp')? 'bccomp' : 'strnatcmp';\n                for ($i = 0; $i < $num; $i++) {\n                    $stat = $zip->statIndex($i);\n                    $size += $stat['size'];\n                    if (strpos((string)$size, 'E') !== false) {\n                        // Cannot handle values exceeding PHP_INT_MAX\n                        throw new Exception(elFinder::ERROR_ARC_MAXSIZE);\n                    }\n                    if (!$maxSize) {\n                        if ($comp($size, $maxSize) > 0) {\n                            throw new Exception(elFinder::ERROR_ARC_MAXSIZE);\n                        }\n                    }\n                }\n                // do extract\n                $zip->extractTo($toDir);\n                $zip->close();\n            }\n        } catch (Exception $e) {\n            throw $e;\n        }\n        return true;\n    }\n\n    /**\n     * Recursive symlinks search\n     *\n     * @param  string $path file/dir path\n     *\n     * @return bool\n     * @throws Exception\n     * @author Dmitry (dio) Levashov\n     */\n    protected static function localFindSymlinks($path)\n    {\n        if (is_link($path)) {\n            return true;\n        }\n\n        if (is_dir($path)) {\n            foreach (self::localScandir($path) as $name) {\n                $p = $path . DIRECTORY_SEPARATOR . $name;\n                if (is_link($p)) {\n                    return true;\n                }\n                if (is_dir($p) && self::localFindSymlinks($p)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**==================================* abstract methods *====================================**/\n\n    /*********************** paths/urls *************************/\n\n    /**\n     * Return parent directory path\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _dirname($path);\n\n    /**\n     * Return file name\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _basename($path);\n\n    /**\n     * Join dir name and file name and return full path.\n     * Some drivers (db) use int as path - so we give to concat path to driver itself\n     *\n     * @param  string $dir  dir path\n     * @param  string $name file name\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _joinPath($dir, $name);\n\n    /**\n     * Return normalized path\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _normpath($path);\n\n    /**\n     * Return file path related to root dir\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _relpath($path);\n\n    /**\n     * Convert path related to root dir into real path\n     *\n     * @param  string $path rel file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _abspath($path);\n\n    /**\n     * Return fake path started from root dir.\n     * Required to show path on client side.\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _path($path);\n\n    /**\n     * Return true if $path is children of $parent\n     *\n     * @param  string $path   path to check\n     * @param  string $parent parent path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _inpath($path, $parent);\n\n    /**\n     * Return stat for given path.\n     * Stat contains following fields:\n     * - (int)    size    file size in b. required\n     * - (int)    ts      file modification time in unix time. required\n     * - (string) mime    mimetype. required for folders, others - optionally\n     * - (bool)   read    read permissions. required\n     * - (bool)   write   write permissions. required\n     * - (bool)   locked  is object locked. optionally\n     * - (bool)   hidden  is object hidden. optionally\n     * - (string) alias   for symlinks - link target path relative to root path. optionally\n     * - (string) target  for symlinks - link target path. optionally\n     * If file does not exists - returns empty array or false.\n     *\n     * @param  string $path file path\n     *\n     * @return array|false\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _stat($path);\n\n\n    /***************** file stat ********************/\n\n\n    /**\n     * Return true if path is dir and has at least one childs directory\n     *\n     * @param  string $path dir path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _subdirs($path);\n\n    /**\n     * Return object width and height\n     * Ususaly used for images, but can be realize for video etc...\n     *\n     * @param  string $path file path\n     * @param  string $mime file mime type\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _dimensions($path, $mime);\n\n    /******************** file/dir content *********************/\n\n    /**\n     * Return files list in directory\n     *\n     * @param  string $path dir path\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _scandir($path);\n\n    /**\n     * Open file and return file pointer\n     *\n     * @param  string $path file path\n     * @param  string $mode open mode\n     *\n     * @return resource|false\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _fopen($path, $mode = \"rb\");\n\n    /**\n     * Close opened file\n     *\n     * @param  resource $fp   file pointer\n     * @param  string   $path file path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _fclose($fp, $path = '');\n\n    /********************  file/dir manipulations *************************/\n\n    /**\n     * Create dir and return created dir path or false on failed\n     *\n     * @param  string $path parent dir path\n     * @param string  $name new directory name\n     *\n     * @return string|bool\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _mkdir($path, $name);\n\n    /**\n     * Create file and return it's path or false on failed\n     *\n     * @param  string $path parent dir path\n     * @param string  $name new file name\n     *\n     * @return string|bool\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _mkfile($path, $name);\n\n    /**\n     * Create symlink\n     *\n     * @param  string $source    file to link to\n     * @param  string $targetDir folder to create link in\n     * @param  string $name      symlink name\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _symlink($source, $targetDir, $name);\n\n    /**\n     * Copy file into another file (only inside one volume)\n     *\n     * @param  string $source source file path\n     * @param         $targetDir\n     * @param  string $name   file name\n     *\n     * @return bool|string\n     * @internal param string $target target dir path\n     * @author   Dmitry (dio) Levashov\n     */\n    abstract protected function _copy($source, $targetDir, $name);\n\n    /**\n     * Move file into another parent dir.\n     * Return new file path or false.\n     *\n     * @param  string $source source file path\n     * @param         $targetDir\n     * @param  string $name   file name\n     *\n     * @return bool|string\n     * @internal param string $target target dir path\n     * @author   Dmitry (dio) Levashov\n     */\n    abstract protected function _move($source, $targetDir, $name);\n\n    /**\n     * Remove file\n     *\n     * @param  string $path file path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _unlink($path);\n\n    /**\n     * Remove dir\n     *\n     * @param  string $path dir path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _rmdir($path);\n\n    /**\n     * Create new file and write into it from file pointer.\n     * Return new file path or false on error.\n     *\n     * @param  resource $fp   file pointer\n     * @param  string   $dir  target dir path\n     * @param  string   $name file name\n     * @param  array    $stat file stat (required by some virtual fs)\n     *\n     * @return bool|string\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _save($fp, $dir, $name, $stat);\n\n    /**\n     * Get file contents\n     *\n     * @param  string $path file path\n     *\n     * @return string|false\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _getContents($path);\n\n    /**\n     * Write a string to a file\n     *\n     * @param  string $path    file path\n     * @param  string $content new file content\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _filePutContents($path, $content);\n\n    /**\n     * Extract files from archive\n     *\n     * @param  string $path file path\n     * @param  array  $arc  archiver options\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     **/\n    abstract protected function _extract($path, $arc);\n\n    /**\n     * Create archive and return its path\n     *\n     * @param  string $dir   target dir\n     * @param  array  $files files names list\n     * @param  string $name  archive name\n     * @param  array  $arc   archiver options\n     *\n     * @return string|bool\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     **/\n    abstract protected function _archive($dir, $files, $name, $arc);\n\n    /**\n     * Detect available archivers\n     *\n     * @return void\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     **/\n    abstract protected function _checkArchivers();\n\n    /**\n     * Change file mode (chmod)\n     *\n     * @param  string $path file path\n     * @param  string $mode octal string such as '0755'\n     *\n     * @return bool\n     * @author David Bartle,\n     **/\n    abstract protected function _chmod($path, $mode);\n\n\n} // END class\n", "<?php\n\n// Implement similar functionality in PHP 5.2 or 5.3\n// http://php.net/manual/class.recursivecallbackfilteriterator.php#110974\nif (!class_exists('RecursiveCallbackFilterIterator', false)) {\n    class RecursiveCallbackFilterIterator extends RecursiveFilterIterator\n    {\n        private $callback;\n\n        public function __construct(RecursiveIterator $iterator, $callback)\n        {\n            $this->callback = $callback;\n            parent::__construct($iterator);\n        }\n\n        public function accept()\n        {\n            return call_user_func($this->callback, parent::current(), parent::key(), parent::getInnerIterator());\n        }\n\n        public function getChildren()\n        {\n            return new self($this->getInnerIterator()->getChildren(), $this->callback);\n        }\n    }\n}\n\n/**\n * elFinder driver for local filesystem.\n *\n * @author Dmitry (dio) Levashov\n * @author Troex Nevelin\n **/\nclass elFinderVolumeLocalFileSystem extends elFinderVolumeDriver\n{\n\n    /**\n     * Driver id\n     * Must be started from letter and contains [a-z0-9]\n     * Used as part of volume id\n     *\n     * @var string\n     **/\n    protected $driverId = 'l';\n\n    /**\n     * Required to count total archive files size\n     *\n     * @var int\n     **/\n    protected $archiveSize = 0;\n\n    /**\n     * Is checking stat owner\n     *\n     * @var        boolean\n     */\n    protected $statOwner = false;\n\n    /**\n     * Path to quarantine directory\n     *\n     * @var string\n     */\n    private $quarantine;\n\n    /**\n     * Constructor\n     * Extend options with required fields\n     *\n     * @author Dmitry (dio) Levashov\n     */\n    public function __construct()\n    {\n        $this->options['alias'] = '';              // alias to replace root dir name\n        $this->options['dirMode'] = 0755;            // new dirs mode\n        $this->options['fileMode'] = 0644;            // new files mode\n        $this->options['rootCssClass'] = 'elfinder-navbar-root-local';\n        $this->options['followSymLinks'] = true;\n        $this->options['detectDirIcon'] = '';         // file name that is detected as a folder icon e.g. '.diricon.png'\n        $this->options['keepTimestamp'] = array('copy', 'move'); // keep timestamp at inner filesystem allowed 'copy', 'move' and 'upload'\n        $this->options['substituteImg'] = true;       // support substitute image with dim command\n        $this->options['statCorrector'] = null;       // callable to correct stat data `function(&$stat, $path, $statOwner, $volumeDriveInstance){}`\n        if (DIRECTORY_SEPARATOR === '/') {\n            // Linux\n            $this->options['acceptedName'] = '/^[^\\.\\/\\x00][^\\/\\x00]*$/';\n        } else {\n            // Windows\n            $this->options['acceptedName'] = '/^[^\\.\\/\\x00\\\\\\:*?\"<>|][^\\/\\x00\\\\\\:*?\"<>|]*$/';\n        }\n    }\n\n    /*********************************************************************/\n    /*                        INIT AND CONFIGURE                         */\n    /*********************************************************************/\n\n    /**\n     * Prepare driver before mount volume.\n     * Return true if volume is ready.\n     *\n     * @return bool\n     **/\n    protected function init()\n    {\n        // Normalize directory separator for windows\n        if (DIRECTORY_SEPARATOR !== '/') {\n            foreach (array('path', 'tmbPath', 'tmpPath', 'quarantine') as $key) {\n                if (!empty($this->options[$key])) {\n                    $this->options[$key] = str_replace('/', DIRECTORY_SEPARATOR, $this->options[$key]);\n                }\n            }\n            // PHP >= 7.1 Supports UTF-8 path on Windows\n            if (version_compare(PHP_VERSION, '7.1', '>=')) {\n                $this->options['encoding'] = '';\n                $this->options['locale'] = '';\n            }\n        }\n        if (!$cwd = getcwd()) {\n            return $this->setError('elFinder LocalVolumeDriver requires a result of getcwd().');\n        }\n        // detect systemRoot\n        if (!isset($this->options['systemRoot'])) {\n            if ($cwd[0] === DIRECTORY_SEPARATOR || $this->root[0] === DIRECTORY_SEPARATOR) {\n                $this->systemRoot = DIRECTORY_SEPARATOR;\n            } else if (preg_match('/^([a-zA-Z]:' . preg_quote(DIRECTORY_SEPARATOR, '/') . ')/', $this->root, $m)) {\n                $this->systemRoot = $m[1];\n            } else if (preg_match('/^([a-zA-Z]:' . preg_quote(DIRECTORY_SEPARATOR, '/') . ')/', $cwd, $m)) {\n                $this->systemRoot = $m[1];\n            }\n        }\n        $this->root = $this->getFullPath($this->root, $cwd);\n        if (!empty($this->options['startPath'])) {\n            $this->options['startPath'] = $this->getFullPath($this->options['startPath'], $this->root);\n        }\n\n        if (is_null($this->options['syncChkAsTs'])) {\n            $this->options['syncChkAsTs'] = true;\n        }\n        if (is_null($this->options['syncCheckFunc'])) {\n            $this->options['syncCheckFunc'] = array($this, 'localFileSystemInotify');\n        }\n        // check 'statCorrector'\n        if (empty($this->options['statCorrector']) || !is_callable($this->options['statCorrector'])) {\n            $this->options['statCorrector'] = null;\n        }\n\n        return true;\n    }\n\n    /**\n     * Configure after successfull mount.\n     *\n     * @return void\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function configure()\n    {\n        $hiddens = array();\n        $root = $this->stat($this->root);\n\n        // check thumbnails path\n        if (!empty($this->options['tmbPath'])) {\n            if (strpos($this->options['tmbPath'], DIRECTORY_SEPARATOR) === false) {\n                $hiddens['tmb'] = $this->options['tmbPath'];\n                $this->options['tmbPath'] = $this->_abspath($this->options['tmbPath']);\n            } else {\n                $this->options['tmbPath'] = $this->_normpath($this->options['tmbPath']);\n            }\n        }\n        // check temp path\n        if (!empty($this->options['tmpPath'])) {\n            if (strpos($this->options['tmpPath'], DIRECTORY_SEPARATOR) === false) {\n                $hiddens['temp'] = $this->options['tmpPath'];\n                $this->options['tmpPath'] = $this->_abspath($this->options['tmpPath']);\n            } else {\n                $this->options['tmpPath'] = $this->_normpath($this->options['tmpPath']);\n            }\n        }\n        // check quarantine path\n        $_quarantine = '';\n        if (!empty($this->options['quarantine'])) {\n            if (strpos($this->options['quarantine'], DIRECTORY_SEPARATOR) === false) {\n                //$hiddens['quarantine'] = $this->options['quarantine'];\n                //$this->options['quarantine'] = $this->_abspath($this->options['quarantine']);\n                $_quarantine = $this->_abspath($this->options['quarantine']);\n                $this->options['quarantine'] = '';\n            } else {\n                $this->options['quarantine'] = $this->_normpath($this->options['quarantine']);\n            }\n        } else {\n            $_quarantine = $this->_abspath('.quarantine');\n        }\n        is_dir($_quarantine) && self::localRmdirRecursive($_quarantine);\n\n        parent::configure();\n\n        // check tmbPath\n        if (!$this->tmbPath && isset($hiddens['tmb'])) {\n            unset($hiddens['tmb']);\n        }\n\n        // if no thumbnails url - try detect it\n        if ($root['read'] && !$this->tmbURL && $this->URL) {\n            if (strpos($this->tmbPath, $this->root) === 0) {\n                $this->tmbURL = $this->URL . str_replace(DIRECTORY_SEPARATOR, '/', substr($this->tmbPath, strlen($this->root) + 1));\n                if (preg_match(\"|[^/?&=]$|\", $this->tmbURL)) {\n                    $this->tmbURL .= '/';\n                }\n            }\n        }\n\n        // set $this->tmp by options['tmpPath']\n        $this->tmp = '';\n        if (!empty($this->options['tmpPath'])) {\n            if ((is_dir($this->options['tmpPath']) || mkdir($this->options['tmpPath'], $this->options['dirMode'], true)) && is_writable($this->options['tmpPath'])) {\n                $this->tmp = $this->options['tmpPath'];\n            } else {\n                if (isset($hiddens['temp'])) {\n                    unset($hiddens['temp']);\n                }\n            }\n        }\n        if (!$this->tmp && ($tmp = elFinder::getStaticVar('commonTempPath'))) {\n            $this->tmp = $tmp;\n        }\n\n        // check quarantine dir\n        $this->quarantine = '';\n        if (!empty($this->options['quarantine'])) {\n            if ((is_dir($this->options['quarantine']) || mkdir($this->options['quarantine'], $this->options['dirMode'], true)) && is_writable($this->options['quarantine'])) {\n                $this->quarantine = $this->options['quarantine'];\n            } else {\n                if (isset($hiddens['quarantine'])) {\n                    unset($hiddens['quarantine']);\n                }\n            }\n        } else if ($_path = elFinder::getCommonTempPath()) {\n            $this->quarantine = $_path;\n        }\n\n        if (!$this->quarantine) {\n            if (!$this->tmp) {\n                $this->archivers['extract'] = array();\n                $this->disabled[] = 'extract';\n            } else {\n                $this->quarantine = $this->tmp;\n            }\n        }\n\n        if ($hiddens) {\n            foreach ($hiddens as $hidden) {\n                $this->attributes[] = array(\n                    'pattern' => '~^' . preg_quote(DIRECTORY_SEPARATOR . $hidden, '~') . '$~',\n                    'read' => false,\n                    'write' => false,\n                    'locked' => true,\n                    'hidden' => true\n                );\n            }\n        }\n\n        if (!empty($this->options['keepTimestamp'])) {\n            $this->options['keepTimestamp'] = array_flip($this->options['keepTimestamp']);\n        }\n\n        $this->statOwner = (!empty($this->options['statOwner']));\n\n        // enable WinRemoveTailDots plugin on Windows server\n        if (DIRECTORY_SEPARATOR !== '/') {\n            if (!isset($this->options['plugin'])) {\n                $this->options['plugin'] = array();\n            }\n            $this->options['plugin']['WinRemoveTailDots'] = array('enable' => true);\n        }\n    }\n\n    /**\n     * Long pooling sync checker\n     * This function require server command `inotifywait`\n     * If `inotifywait` need full path, Please add `define('ELFINER_INOTIFYWAIT_PATH', '/PATH_TO/inotifywait');` into connector.php\n     *\n     * @param string $path\n     * @param int    $standby\n     * @param number $compare\n     *\n     * @return number|bool\n     * @throws elFinderAbortException\n     */\n    public function localFileSystemInotify($path, $standby, $compare)\n    {\n        if (isset($this->sessionCache['localFileSystemInotify_disable'])) {\n            return false;\n        }\n        $path = realpath($path);\n        $mtime = filemtime($path);\n        if (!$mtime) {\n            return false;\n        }\n        if ($mtime != $compare) {\n            return $mtime;\n        }\n        $inotifywait = defined('ELFINER_INOTIFYWAIT_PATH') ? ELFINER_INOTIFYWAIT_PATH : 'inotifywait';\n        $standby = max(1, intval($standby));\n        $cmd = $inotifywait . ' ' . escapeshellarg($path) . ' -t ' . $standby . ' -e moved_to,moved_from,move,close_write,delete,delete_self';\n        $this->procExec($cmd, $o, $r);\n        if ($r === 0) {\n            // changed\n            clearstatcache();\n            if (file_exists($path)) {\n                $mtime = filemtime($path); // error on busy?\n                return $mtime ? $mtime : time();\n            } else {\n                // target was removed\n                return 0;\n            }\n        } else if ($r === 2) {\n            // not changed (timeout)\n            return $compare;\n        }\n        // error\n        // cache to $_SESSION\n        $this->sessionCache['localFileSystemInotify_disable'] = true;\n        $this->session->set($this->id, $this->sessionCache);\n        return false;\n    }\n\n    /*********************************************************************/\n    /*                               FS API                              */\n    /*********************************************************************/\n\n    /*********************** paths/urls *************************/\n\n    /**\n     * Return parent directory path\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _dirname($path)\n    {\n        return dirname($path);\n    }\n\n    /**\n     * Return file name\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _basename($path)\n    {\n        return basename($path);\n    }\n\n    /**\n     * Join dir name and file name and retur full path\n     *\n     * @param  string $dir\n     * @param  string $name\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _joinPath($dir, $name)\n    {\n        $dir = rtrim($dir, DIRECTORY_SEPARATOR);\n        $path = realpath($dir . DIRECTORY_SEPARATOR . $name);\n        // realpath() returns FALSE if the file does not exist\n        if ($path === false || strpos($path, $this->root) !== 0) {\n            if (DIRECTORY_SEPARATOR !== '/') {\n                $name = str_replace('/', DIRECTORY_SEPARATOR, $name);\n            }\n            // Directory traversal measures\n            if (strpos($name, '..' . DIRECTORY_SEPARATOR) !== false) {\n                $name = basename($name);\n            }\n            $path = $dir . DIRECTORY_SEPARATOR . $name;\n        }\n        return $path; \n    }\n\n    /**\n     * Return normalized path, this works the same as os.path.normpath() in Python\n     *\n     * @param  string $path path\n     *\n     * @return string\n     * @author Troex Nevelin\n     **/\n    protected function _normpath($path)\n    {\n        if (empty($path)) {\n            return '.';\n        }\n\n        $changeSep = (DIRECTORY_SEPARATOR !== '/');\n        if ($changeSep) {\n            $drive = '';\n            if (preg_match('/^([a-zA-Z]:)(.*)/', $path, $m)) {\n                $drive = $m[1];\n                $path = $m[2] ? $m[2] : '/';\n            }\n            $path = str_replace(DIRECTORY_SEPARATOR, '/', $path);\n        }\n\n        if (strpos($path, '/') === 0) {\n            $initial_slashes = true;\n        } else {\n            $initial_slashes = false;\n        }\n\n        if (($initial_slashes)\n            && (strpos($path, '//') === 0)\n            && (strpos($path, '///') === false)) {\n            $initial_slashes = 2;\n        }\n\n        $initial_slashes = (int)$initial_slashes;\n\n        $comps = explode('/', $path);\n        $new_comps = array();\n        foreach ($comps as $comp) {\n            if (in_array($comp, array('', '.'))) {\n                continue;\n            }\n\n            if (($comp != '..')\n                || (!$initial_slashes && !$new_comps)\n                || ($new_comps && (end($new_comps) == '..'))) {\n                array_push($new_comps, $comp);\n            } elseif ($new_comps) {\n                array_pop($new_comps);\n            }\n        }\n        $comps = $new_comps;\n        $path = implode('/', $comps);\n        if ($initial_slashes) {\n            $path = str_repeat('/', $initial_slashes) . $path;\n        }\n\n        if ($changeSep) {\n            $path = $drive . str_replace('/', DIRECTORY_SEPARATOR, $path);\n        }\n\n        return $path ? $path : '.';\n    }\n\n    /**\n     * Return file path related to root dir\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _relpath($path)\n    {\n        if ($path === $this->root) {\n            return '';\n        } else {\n            if (strpos($path, $this->root) === 0) {\n                return ltrim(substr($path, strlen($this->root)), DIRECTORY_SEPARATOR);\n            } else {\n                // for link\n                return $path;\n            }\n        }\n    }\n\n    /**\n     * Convert path related to root dir into real path\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _abspath($path)\n    {\n        if ($path === DIRECTORY_SEPARATOR) {\n            return $this->root;\n        } else {\n            if (strpos($path, $this->systemRoot) === 0) {\n                return $path;\n            } else if (DIRECTORY_SEPARATOR !== '/' && preg_match('/^[a-zA-Z]:' . preg_quote(DIRECTORY_SEPARATOR, '/') . '/', $path)) {\n                return $path;\n            } else {\n                return $this->_joinPath($this->root, $path);\n            }\n        }\n    }\n\n    /**\n     * Return fake path started from root dir\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _path($path)\n    {\n        return $this->rootName . ($path == $this->root ? '' : $this->separator . $this->_relpath($path));\n    }\n\n    /**\n     * Return true if $path is children of $parent\n     *\n     * @param  string $path   path to check\n     * @param  string $parent parent path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _inpath($path, $parent)\n    {\n        $cwd = getcwd();\n        $real_path = $this->getFullPath($path, $cwd);\n        $real_parent = $this->getFullPath($parent, $cwd);\n        if ($real_path && $real_parent) {\n            return $real_path === $real_parent || strpos($real_path, rtrim($real_parent, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR) === 0;\n        }\n        return false;\n    }\n\n\n\n    /***************** file stat ********************/\n\n    /**\n     * Return stat for given path.\n     * Stat contains following fields:\n     * - (int)    size    file size in b. required\n     * - (int)    ts      file modification time in unix time. required\n     * - (string) mime    mimetype. required for folders, others - optionally\n     * - (bool)   read    read permissions. required\n     * - (bool)   write   write permissions. required\n     * - (bool)   locked  is object locked. optionally\n     * - (bool)   hidden  is object hidden. optionally\n     * - (string) alias   for symlinks - link target path relative to root path. optionally\n     * - (string) target  for symlinks - link target path. optionally\n     * If file does not exists - returns empty array or false.\n     *\n     * @param  string $path file path\n     *\n     * @return array|false\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _stat($path)\n    {\n        $stat = array();\n\n        if (!file_exists($path) && !is_link($path)) {\n            return $stat;\n        }\n\n        //Verifies the given path is the root or is inside the root. Prevents directory traveral.\n        if (!$this->_inpath($path, $this->root)) {\n            return $stat;\n        }\n\n        $stat['isowner'] = false;\n        $linkreadable = false;\n        if ($path != $this->root && is_link($path)) {\n            if (!$this->options['followSymLinks']) {\n                return array();\n            }\n            if (!($target = $this->readlink($path))\n                || $target == $path) {\n                if (is_null($target)) {\n                    $stat = array();\n                    return $stat;\n                } else {\n                    $stat['mime'] = 'symlink-broken';\n                    $target = readlink($path);\n                    $lstat = lstat($path);\n                    $ostat = $this->getOwnerStat($lstat['uid'], $lstat['gid']);\n                    $linkreadable = !empty($ostat['isowner']);\n                }\n            }\n            $stat['alias'] = $this->_path($target);\n            $stat['target'] = $target;\n        }\n\n        $readable = is_readable($path);\n\n        if ($readable) {\n            $size = sprintf('%u', filesize($path));\n            $stat['ts'] = filemtime($path);\n            if ($this->statOwner) {\n                $fstat = stat($path);\n                $uid = $fstat['uid'];\n                $gid = $fstat['gid'];\n                $stat['perm'] = substr((string)decoct($fstat['mode']), -4);\n                $stat = array_merge($stat, $this->getOwnerStat($uid, $gid));\n            }\n        }\n\n        if (($dir = is_dir($path)) && $this->options['detectDirIcon']) {\n            $favicon = $path . DIRECTORY_SEPARATOR . $this->options['detectDirIcon'];\n            if ($this->URL && file_exists($favicon)) {\n                $stat['icon'] = $this->URL . str_replace(DIRECTORY_SEPARATOR, '/', substr($favicon, strlen($this->root) + 1));\n            }\n        }\n\n        if (!isset($stat['mime'])) {\n            $stat['mime'] = $dir ? 'directory' : $this->mimetype($path);\n        }\n        //logical rights first\n        $stat['read'] = ($linkreadable || $readable) ? null : false;\n        $stat['write'] = is_writable($path) ? null : false;\n\n        if (is_null($stat['read'])) {\n            if ($dir) {\n                $stat['size'] = 0;\n            } else if (isset($size)) {\n                $stat['size'] = $size;\n            }\n        }\n\n        if ($this->options['statCorrector']) {\n            call_user_func_array($this->options['statCorrector'], array(&$stat, $path, $this->statOwner, $this));\n        }\n\n        return $stat;\n    }\n\n    /**\n     * Get stat `owner`, `group` and `isowner` by `uid` and `gid`\n     * Sub-fuction of _stat() and _scandir()\n     *\n     * @param integer $uid\n     * @param integer $gid\n     *\n     * @return array  stat\n     */\n    protected function getOwnerStat($uid, $gid)\n    {\n        static $names = null;\n        static $phpuid = null;\n\n        if (is_null($names)) {\n            $names = array('uid' => array(), 'gid' => array());\n        }\n        if (is_null($phpuid)) {\n            if (is_callable('posix_getuid')) {\n                $phpuid = posix_getuid();\n            } else {\n                $phpuid = 0;\n            }\n        }\n\n        $stat = array();\n\n        if ($uid) {\n            $stat['isowner'] = ($phpuid == $uid);\n            if (isset($names['uid'][$uid])) {\n                $stat['owner'] = $names['uid'][$uid];\n            } else if (is_callable('posix_getpwuid')) {\n                $pwuid = posix_getpwuid($uid);\n                $stat['owner'] = $names['uid'][$uid] = $pwuid['name'];\n            } else {\n                $stat['owner'] = $names['uid'][$uid] = $uid;\n            }\n        }\n        if ($gid) {\n            if (isset($names['gid'][$gid])) {\n                $stat['group'] = $names['gid'][$gid];\n            } else if (is_callable('posix_getgrgid')) {\n                $grgid = posix_getgrgid($gid);\n                $stat['group'] = $names['gid'][$gid] = $grgid['name'];\n            } else {\n                $stat['group'] = $names['gid'][$gid] = $gid;\n            }\n        }\n\n        return $stat;\n    }\n\n    /**\n     * Return true if path is dir and has at least one childs directory\n     *\n     * @param  string $path dir path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _subdirs($path)\n    {\n\n        $dirs = false;\n        if (is_dir($path) && is_readable($path)) {\n            if (class_exists('FilesystemIterator', false)) {\n                $dirItr = new ParentIterator(\n                    new RecursiveDirectoryIterator($path,\n                        FilesystemIterator::SKIP_DOTS |\n                        FilesystemIterator::CURRENT_AS_SELF |\n                        (defined('RecursiveDirectoryIterator::FOLLOW_SYMLINKS') ?\n                            RecursiveDirectoryIterator::FOLLOW_SYMLINKS : 0)\n                    )\n                );\n                $dirItr->rewind();\n                if ($dirItr->hasChildren()) {\n                    $dirs = true;\n                    $name = $dirItr->getSubPathName();\n                    while ($dirItr->valid()) {\n                        if (!$this->attr($path . DIRECTORY_SEPARATOR . $name, 'read', null, true)) {\n                            $dirs = false;\n                            $dirItr->next();\n                            $name = $dirItr->getSubPathName();\n                            continue;\n                        }\n                        $dirs = true;\n                        break;\n                    }\n                }\n            } else {\n                $path = strtr($path, array('[' => '\\\\[', ']' => '\\\\]', '*' => '\\\\*', '?' => '\\\\?'));\n                return (bool)glob(rtrim($path, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR . '*', GLOB_ONLYDIR);\n            }\n        }\n        return $dirs;\n    }\n\n    /**\n     * Return object width and height\n     * Usualy used for images, but can be realize for video etc...\n     *\n     * @param  string $path file path\n     * @param  string $mime file mime type\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _dimensions($path, $mime)\n    {\n        clearstatcache();\n        return strpos($mime, 'image') === 0 && is_readable($path) && filesize($path) && ($s = getimagesize($path)) !== false\n            ? $s[0] . 'x' . $s[1]\n            : false;\n    }\n    /******************** file/dir content *********************/\n\n    /**\n     * Return symlink target file\n     *\n     * @param  string $path link path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function readlink($path)\n    {\n        if (!($target = readlink($path))) {\n            return null;\n        }\n\n        if (strpos($target, $this->systemRoot) !== 0) {\n            $target = $this->_joinPath(dirname($path), $target);\n        }\n\n        if (!file_exists($target)) {\n            return false;\n        }\n\n        return $target;\n    }\n\n    /**\n     * Return files list in directory.\n     *\n     * @param  string $path dir path\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function _scandir($path)\n    {\n        elFinder::checkAborted();\n        $files = array();\n        $cache = array();\n        $dirWritable = is_writable($path);\n        $dirItr = array();\n        $followSymLinks = $this->options['followSymLinks'];\n        try {\n            $dirItr = new DirectoryIterator($path);\n        } catch (UnexpectedValueException $e) {\n        }\n\n        foreach ($dirItr as $file) {\n            try {\n                if ($file->isDot()) {\n                    continue;\n                }\n\n                $files[] = $fpath = $file->getPathname();\n\n                $br = false;\n                $stat = array();\n\n                $stat['isowner'] = false;\n                $linkreadable = false;\n                if ($file->isLink()) {\n                    if (!$followSymLinks) {\n                        continue;\n                    }\n                    if (!($target = $this->readlink($fpath))\n                        || $target == $fpath) {\n                        if (is_null($target)) {\n                            $stat = array();\n                            $br = true;\n                        } else {\n                            $_path = $fpath;\n                            $stat['mime'] = 'symlink-broken';\n                            $target = readlink($_path);\n                            $lstat = lstat($_path);\n                            $ostat = $this->getOwnerStat($lstat['uid'], $lstat['gid']);\n                            $linkreadable = !empty($ostat['isowner']);\n                            $dir = false;\n                            $stat['alias'] = $this->_path($target);\n                            $stat['target'] = $target;\n                        }\n                    } else {\n                        $dir = is_dir($target);\n                        $stat['alias'] = $this->_path($target);\n                        $stat['target'] = $target;\n                        $stat['mime'] = $dir ? 'directory' : $this->mimetype($stat['alias']);\n                    }\n                } else {\n                    if (($dir = $file->isDir()) && $this->options['detectDirIcon']) {\n                        $path = $file->getPathname();\n                        $favicon = $path . DIRECTORY_SEPARATOR . $this->options['detectDirIcon'];\n                        if ($this->URL && file_exists($favicon)) {\n                            $stat['icon'] = $this->URL . str_replace(DIRECTORY_SEPARATOR, '/', substr($favicon, strlen($this->root) + 1));\n                        }\n                    }\n                    $stat['mime'] = $dir ? 'directory' : $this->mimetype($fpath);\n                }\n                $size = sprintf('%u', $file->getSize());\n                $stat['ts'] = $file->getMTime();\n                if (!$br) {\n                    if ($this->statOwner && !$linkreadable) {\n                        $uid = $file->getOwner();\n                        $gid = $file->getGroup();\n                        $stat['perm'] = substr((string)decoct($file->getPerms()), -4);\n                        $stat = array_merge($stat, $this->getOwnerStat($uid, $gid));\n                    }\n\n                    //logical rights first\n                    $stat['read'] = ($linkreadable || $file->isReadable()) ? null : false;\n                    $stat['write'] = $file->isWritable() ? null : false;\n                    $stat['locked'] = $dirWritable ? null : true;\n\n                    if (is_null($stat['read'])) {\n                        $stat['size'] = $dir ? 0 : $size;\n                    }\n\n                    if ($this->options['statCorrector']) {\n                        call_user_func_array($this->options['statCorrector'], array(&$stat, $fpath, $this->statOwner, $this));\n                    }\n                }\n\n                $cache[] = array($fpath, $stat);\n            } catch (RuntimeException $e) {\n                continue;\n            }\n        }\n\n        if ($cache) {\n            $cache = $this->convEncOut($cache, false);\n            foreach ($cache as $d) {\n                $this->updateCache($d[0], $d[1]);\n            }\n        }\n\n        return $files;\n    }\n\n    /**\n     * Open file and return file pointer\n     *\n     * @param  string $path file path\n     * @param string  $mode\n     *\n     * @return false|resource\n     * @internal param bool $write open file for writing\n     * @author   Dmitry (dio) Levashov\n     */\n    protected function _fopen($path, $mode = 'rb')\n    {\n        return fopen($path, $mode);\n    }\n\n    /**\n     * Close opened file\n     *\n     * @param  resource $fp file pointer\n     * @param string    $path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     */\n    protected function _fclose($fp, $path = '')\n    {\n        return (is_resource($fp) && fclose($fp));\n    }\n\n    /********************  file/dir manipulations *************************/\n\n    /**\n     * Create dir and return created dir path or false on failed\n     *\n     * @param  string $path parent dir path\n     * @param string  $name new directory name\n     *\n     * @return string|bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _mkdir($path, $name)\n    {\n        $path = $this->_joinPath($path, $name);\n\n        if (mkdir($path)) {\n            chmod($path, $this->options['dirMode']);\n            return $path;\n        }\n\n        return false;\n    }\n\n    /**\n     * Create file and return it's path or false on failed\n     *\n     * @param  string $path parent dir path\n     * @param string  $name new file name\n     *\n     * @return string|bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _mkfile($path, $name)\n    {\n        $path = $this->_joinPath($path, $name);\n\n        if (($fp = fopen($path, 'w'))) {\n            fclose($fp);\n            chmod($path, $this->options['fileMode']);\n            return $path;\n        }\n        return false;\n    }\n\n    /**\n     * Create symlink\n     *\n     * @param  string $source    file to link to\n     * @param  string $targetDir folder to create link in\n     * @param  string $name      symlink name\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _symlink($source, $targetDir, $name)\n    {\n        return symlink($source, $this->_joinPath($targetDir, $name));\n    }\n\n    /**\n     * Copy file into another file\n     *\n     * @param  string $source    source file path\n     * @param  string $targetDir target directory path\n     * @param  string $name      new file name\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _copy($source, $targetDir, $name)\n    {\n        $mtime = filemtime($source);\n        $target = $this->_joinPath($targetDir, $name);\n        if ($ret = copy($source, $target)) {\n            isset($this->options['keepTimestamp']['copy']) && $mtime && touch($target, $mtime);\n        }\n        return $ret;\n    }\n\n    /**\n     * Move file into another parent dir.\n     * Return new file path or false.\n     *\n     * @param  string $source source file path\n     * @param         $targetDir\n     * @param  string $name   file name\n     *\n     * @return bool|string\n     * @internal param string $target target dir path\n     * @author   Dmitry (dio) Levashov\n     */\n    protected function _move($source, $targetDir, $name)\n    {\n        $mtime = filemtime($source);\n        $target = $this->_joinPath($targetDir, $name);\n        if ($ret = rename($source, $target) ? $target : false) {\n            isset($this->options['keepTimestamp']['move']) && $mtime && touch($target, $mtime);\n        }\n        return $ret;\n    }\n\n    /**\n     * Remove file\n     *\n     * @param  string $path file path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _unlink($path)\n    {\n        return is_file($path) && unlink($path);\n    }\n\n    /**\n     * Remove dir\n     *\n     * @param  string $path dir path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _rmdir($path)\n    {\n        return rmdir($path);\n    }\n\n    /**\n     * Create new file and write into it from file pointer.\n     * Return new file path or false on error.\n     *\n     * @param  resource $fp   file pointer\n     * @param  string   $dir  target dir path\n     * @param  string   $name file name\n     * @param  array    $stat file stat (required by some virtual fs)\n     *\n     * @return bool|string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _save($fp, $dir, $name, $stat)\n    {\n        $path = $this->_joinPath($dir, $name);\n\n        $meta = stream_get_meta_data($fp);\n        $uri = isset($meta['uri']) ? $meta['uri'] : '';\n        if ($uri && !preg_match('#^[a-zA-Z0-9]+://#', $uri) && !is_link($uri)) {\n            fclose($fp);\n            $mtime = filemtime($uri);\n            $isCmdPaste = ($this->ARGS['cmd'] === 'paste');\n            $isCmdCopy = ($isCmdPaste && empty($this->ARGS['cut']));\n            if (($isCmdCopy || !rename($uri, $path)) && !copy($uri, $path)) {\n                return false;\n            }\n            // keep timestamp on upload\n            if ($mtime && $this->ARGS['cmd'] === 'upload') {\n                touch($path, isset($this->options['keepTimestamp']['upload']) ? $mtime : time());\n            }\n        } else {\n            if (file_put_contents($path, $fp, LOCK_EX) === false) {\n                return false;\n            }\n        }\n\n        chmod($path, $this->options['fileMode']);\n        return $path;\n    }\n\n    /**\n     * Get file contents\n     *\n     * @param  string $path file path\n     *\n     * @return string|false\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _getContents($path)\n    {\n        return file_get_contents($path);\n    }\n\n    /**\n     * Write a string to a file\n     *\n     * @param  string $path    file path\n     * @param  string $content new file content\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _filePutContents($path, $content)\n    {\n        return (file_put_contents($path, $content, LOCK_EX) !== false);\n    }\n\n    /**\n     * Detect available archivers\n     *\n     * @return void\n     * @throws elFinderAbortException\n     */\n    protected function _checkArchivers()\n    {\n        $this->archivers = $this->getArchivers();\n        return;\n    }\n\n    /**\n     * chmod availability\n     *\n     * @param string $path\n     * @param string $mode\n     *\n     * @return bool\n     */\n    protected function _chmod($path, $mode)\n    {\n        $modeOct = is_string($mode) ? octdec($mode) : octdec(sprintf(\"%04o\", $mode));\n        return chmod($path, $modeOct);\n    }\n\n    /**\n     * Recursive symlinks search\n     *\n     * @param  string $path file/dir path\n     *\n     * @return bool\n     * @throws Exception\n     * @author Dmitry (dio) Levashov\n     */\n    protected function _findSymlinks($path)\n    {\n        return self::localFindSymlinks($path);\n    }\n\n    /**\n     * Extract files from archive\n     *\n     * @param  string $path archive path\n     * @param  array  $arc  archiver command and arguments (same as in $this->archivers)\n     *\n     * @return array|string|boolean\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     */\n    protected function _extract($path, $arc)\n    {\n\n        if ($this->quarantine) {\n\n            $dir = $this->quarantine . DIRECTORY_SEPARATOR . md5(basename($path) . mt_rand());\n            $archive = (isset($arc['toSpec']) || $arc['cmd'] === 'phpfunction') ? '' : $dir . DIRECTORY_SEPARATOR . basename($path);\n\n            if (!mkdir($dir)) {\n                return false;\n            }\n\n            // insurance unexpected shutdown\n            register_shutdown_function(array($this, 'rmdirRecursive'), realpath($dir));\n\n            chmod($dir, 0777);\n\n            // copy in quarantine\n            if (!is_readable($path) || ($archive && !copy($path, $archive))) {\n                return false;\n            }\n\n            // extract in quarantine\n            try {\n                $this->unpackArchive($path, $arc, $archive ? true : $dir);\n            } catch(Exception $e) {\n                return $this->setError($e->getMessage());\n            }\n\n            // get files list\n            try {\n                $ls = self::localScandir($dir);\n            } catch (Exception $e) {\n                return false;\n            }\n\n            // no files - extract error ?\n            if (empty($ls)) {\n                return false;\n            }\n\n            $this->archiveSize = 0;\n\n            // find symlinks and check extracted items\n            $checkRes = $this->checkExtractItems($dir);\n            if ($checkRes['symlinks']) {\n                self::localRmdirRecursive($dir);\n                return $this->setError(array_merge($this->error, array(elFinder::ERROR_ARC_SYMLINKS)));\n            }\n            $this->archiveSize = $checkRes['totalSize'];\n            if ($checkRes['rmNames']) {\n                foreach ($checkRes['rmNames'] as $name) {\n                    $this->addError(elFinder::ERROR_SAVE, $name);\n                }\n            }\n\n            // check max files size\n            if ($this->options['maxArcFilesSize'] > 0 && $this->options['maxArcFilesSize'] < $this->archiveSize) {\n                $this->delTree($dir);\n                return $this->setError(elFinder::ERROR_ARC_MAXSIZE);\n            }\n\n            $extractTo = $this->extractToNewdir; // 'auto', ture or false\n\n            // archive contains one item - extract in archive dir\n            $name = '';\n            $src = $dir . DIRECTORY_SEPARATOR . $ls[0];\n            if (($extractTo === 'auto' || !$extractTo) && count($ls) === 1 && is_file($src)) {\n                $name = $ls[0];\n            } else if ($extractTo === 'auto' || $extractTo) {\n                // for several files - create new directory\n                // create unique name for directory\n                $src = $dir;\n                $splits = elFinder::splitFileExtention(basename($path));\n                $name = $splits[0];\n                $test = dirname($path) . DIRECTORY_SEPARATOR . $name;\n                if (file_exists($test) || is_link($test)) {\n                    $name = $this->uniqueName(dirname($path), $name, '-', false);\n                }\n            }\n\n            if ($name !== '') {\n                $result = dirname($path) . DIRECTORY_SEPARATOR . $name;\n\n                if (!rename($src, $result)) {\n                    $this->delTree($dir);\n                    return false;\n                }\n            } else {\n                $dstDir = dirname($path);\n                $result = array();\n                foreach ($ls as $name) {\n                    $target = $dstDir . DIRECTORY_SEPARATOR . $name;\n                    if (self::localMoveRecursive($dir . DIRECTORY_SEPARATOR . $name, $target, true, $this->options['copyJoin'])) {\n                        $result[] = $target;\n                    }\n                }\n                if (!$result) {\n                    $this->delTree($dir);\n                    return false;\n                }\n            }\n\n            is_dir($dir) && $this->delTree($dir);\n\n            return (is_array($result) || file_exists($result)) ? $result : false;\n        }\n        //TODO: Add return statement here\n        return false;\n    }\n\n    /**\n     * Create archive and return its path\n     *\n     * @param  string $dir   target dir\n     * @param  array  $files files names list\n     * @param  string $name  archive name\n     * @param  array  $arc   archiver options\n     *\n     * @return string|bool\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     */\n    protected function _archive($dir, $files, $name, $arc)\n    {\n        return $this->makeArchive($dir, $files, $name, $arc);\n    }\n\n    /******************** Over write functions *************************/\n\n    /**\n     * File path of local server side work file path\n     *\n     * @param  string $path\n     *\n     * @return string\n     * @author Naoki Sawada\n     */\n    protected function getWorkFile($path)\n    {\n        return $path;\n    }\n\n    /**\n     * Delete dirctory trees\n     *\n     * @param string $localpath path need convert encoding to server encoding\n     *\n     * @return boolean\n     * @throws elFinderAbortException\n     * @author Naoki Sawada\n     */\n    protected function delTree($localpath)\n    {\n        return $this->rmdirRecursive($localpath);\n    }\n\n    /**\n     * Return fileinfo based on filename\n     * For item ID based path file system\n     * Please override if needed on each drivers\n     *\n     * @param  string $path file cache\n     *\n     * @return array|boolean false\n     */\n    protected function isNameExists($path)\n    {\n        $exists = file_exists($this->convEncIn($path));\n        // restore locale\n        $this->convEncOut();\n        return $exists ? $this->stat($path) : false;\n    }\n\n    /******************** Over write (Optimized) functions *************************/\n\n    /**\n     * Recursive files search\n     *\n     * @param  string $path dir path\n     * @param  string $q    search string\n     * @param  array  $mimes\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     * @author Naoki Sawada\n     */\n    protected function doSearch($path, $q, $mimes)\n    {\n        if (!empty($this->doSearchCurrentQuery['matchMethod']) || $this->encoding || !class_exists('FilesystemIterator', false)) {\n            // has custom match method or non UTF-8, use elFinderVolumeDriver::doSearch()\n            return parent::doSearch($path, $q, $mimes);\n        }\n\n        $result = array();\n\n        $timeout = $this->options['searchTimeout'] ? $this->searchStart + $this->options['searchTimeout'] : 0;\n        if ($timeout && $timeout < time()) {\n            $this->setError(elFinder::ERROR_SEARCH_TIMEOUT, $this->path($this->encode($path)));\n            return $result;\n        }\n        elFinder::extendTimeLimit($this->options['searchTimeout'] + 30);\n\n        $match = array();\n        try {\n            $iterator = new RecursiveIteratorIterator(\n                new RecursiveCallbackFilterIterator(\n                    new RecursiveDirectoryIterator($path,\n                        FilesystemIterator::KEY_AS_PATHNAME |\n                        FilesystemIterator::SKIP_DOTS |\n                        ((defined('RecursiveDirectoryIterator::FOLLOW_SYMLINKS') && $this->options['followSymLinks']) ?\n                            RecursiveDirectoryIterator::FOLLOW_SYMLINKS : 0)\n                    ),\n                    array($this, 'localFileSystemSearchIteratorFilter')\n                ),\n                RecursiveIteratorIterator::SELF_FIRST,\n                RecursiveIteratorIterator::CATCH_GET_CHILD\n            );\n            foreach ($iterator as $key => $node) {\n                if ($timeout && ($this->error || $timeout < time())) {\n                    !$this->error && $this->setError(elFinder::ERROR_SEARCH_TIMEOUT, $this->path($this->encode($node->getPath)));\n                    break;\n                }\n                if ($node->isDir()) {\n                    if ($this->stripos($node->getFilename(), $q) !== false) {\n                        $match[] = $key;\n                    }\n                } else {\n                    $match[] = $key;\n                }\n            }\n        } catch (Exception $e) {\n        }\n\n        if ($match) {\n            foreach ($match as $p) {\n                if ($timeout && ($this->error || $timeout < time())) {\n                    !$this->error && $this->setError(elFinder::ERROR_SEARCH_TIMEOUT, $this->path($this->encode(dirname($p))));\n                    break;\n                }\n\n                $stat = $this->stat($p);\n\n                if (!$stat) { // invalid links\n                    continue;\n                }\n\n                if (!empty($stat['hidden']) || !$this->mimeAccepted($stat['mime'], $mimes)) {\n                    continue;\n                }\n\n                if ((!$mimes || $stat['mime'] !== 'directory')) {\n                    $stat['path'] = $this->path($stat['hash']);\n                    if ($this->URL && !isset($stat['url'])) {\n                        $_path = str_replace(DIRECTORY_SEPARATOR, '/', substr($p, strlen($this->root) + 1));\n                        $stat['url'] = $this->URL . str_replace('%2F', '/', rawurlencode($_path));\n                    }\n\n                    $result[] = $stat;\n                }\n            }\n        }\n\n        return $result;\n    }\n\n    /******************** Original local functions ************************\n     *\n     * @param $file\n     * @param $key\n     * @param $iterator\n     *\n     * @return bool\n     */\n\n    public function localFileSystemSearchIteratorFilter($file, $key, $iterator)\n    {\n        /* @var FilesystemIterator $file */\n        /* @var RecursiveDirectoryIterator $iterator */\n        $name = $file->getFilename();\n        if ($this->doSearchCurrentQuery['excludes']) {\n            foreach ($this->doSearchCurrentQuery['excludes'] as $exclude) {\n                if ($this->stripos($name, $exclude) !== false) {\n                    return false;\n                }\n            }\n        }\n        if ($iterator->hasChildren()) {\n            if ($this->options['searchExDirReg'] && preg_match($this->options['searchExDirReg'], $key)) {\n                return false;\n            }\n            return (bool)$this->attr($key, 'read', null, true);\n        }\n        return ($this->stripos($name, $this->doSearchCurrentQuery['q']) === false) ? false : true;\n    }\n\n    /**\n     * Creates a symbolic link\n     *\n     * @param      string   $target  The target\n     * @param      string   $link    The link\n     *\n     * @return     boolean  ( result of symlink() )\n     */\n    protected function localFileSystemSymlink($target, $link)\n    {\n        $res = false;\n        $errlev = error_reporting();\n        error_reporting($errlev ^ E_WARNING);\n        if ($res = symlink(realpath($target), $link)) {\n            $res = is_readable($link);\n        }\n        error_reporting($errlev);\n        return $res;\n    }\n} // END class \n"], "fixing_code": ["<?php\n\n/**\n * Base class for elFinder volume.\n * Provide 2 layers:\n *  1. Public API (commands)\n *  2. abstract fs API\n * All abstract methods begin with \"_\"\n *\n * @author Dmitry (dio) Levashov\n * @author Troex Nevelin\n * @author Alexey Sukhotin\n * @method netmountPrepare(array $options)\n * @method postNetmount(array $options)\n */\nabstract class elFinderVolumeDriver\n{\n\n    /**\n     * Net mount key\n     *\n     * @var string\n     **/\n    public $netMountKey = '';\n\n    /**\n     * Request args\n     * $_POST or $_GET values\n     *\n     * @var array\n     */\n    protected $ARGS = array();\n\n    /**\n     * Driver id\n     * Must be started from letter and contains [a-z0-9]\n     * Used as part of volume id\n     *\n     * @var string\n     **/\n    protected $driverId = 'a';\n\n    /**\n     * Volume id - used as prefix for files hashes\n     *\n     * @var string\n     **/\n    protected $id = '';\n\n    /**\n     * Flag - volume \"mounted\" and available\n     *\n     * @var bool\n     **/\n    protected $mounted = false;\n\n    /**\n     * Root directory path\n     *\n     * @var string\n     **/\n    protected $root = '';\n\n    /**\n     * Root basename | alias\n     *\n     * @var string\n     **/\n    protected $rootName = '';\n\n    /**\n     * Default directory to open\n     *\n     * @var string\n     **/\n    protected $startPath = '';\n\n    /**\n     * Base URL\n     *\n     * @var string\n     **/\n    protected $URL = '';\n\n    /**\n     * Path to temporary directory\n     *\n     * @var string\n     */\n    protected $tmp;\n\n    /**\n     * A file save destination path when a temporary content URL is required\n     * on a network volume or the like\n     * If not specified, it tries to use \"Connector Path/../files/.tmb\".\n     *\n     * @var string\n     */\n    protected $tmpLinkPath = '';\n\n    /**\n     * A file save destination URL when a temporary content URL is required\n     * on a network volume or the like\n     * If not specified, it tries to use \"Connector URL/../files/.tmb\".\n     *\n     * @var string\n     */\n    protected $tmpLinkUrl = '';\n\n    /**\n     * Thumbnails dir path\n     *\n     * @var string\n     **/\n    protected $tmbPath = '';\n\n    /**\n     * Is thumbnails dir writable\n     *\n     * @var bool\n     **/\n    protected $tmbPathWritable = false;\n\n    /**\n     * Thumbnails base URL\n     *\n     * @var string\n     **/\n    protected $tmbURL = '';\n\n    /**\n     * Thumbnails size in px\n     *\n     * @var int\n     **/\n    protected $tmbSize = 48;\n\n    /**\n     * Image manipulation lib name\n     * auto|imagick|gd|convert\n     *\n     * @var string\n     **/\n    protected $imgLib = 'auto';\n\n    /**\n     * Video to Image converter\n     *\n     * @var array\n     */\n    protected $imgConverter = array();\n\n    /**\n     * Library to crypt files name\n     *\n     * @var string\n     **/\n    protected $cryptLib = '';\n\n    /**\n     * Archivers config\n     *\n     * @var array\n     **/\n    protected $archivers = array(\n        'create' => array(),\n        'extract' => array()\n    );\n\n    /**\n     * Static var of $this->options['maxArcFilesSize']\n     * \n     * @var int|string\n     */\n    protected static $maxArcFilesSize;\n\n    /**\n     * Server character encoding\n     *\n     * @var string or null\n     **/\n    protected $encoding = null;\n\n    /**\n     * How many subdirs levels return for tree\n     *\n     * @var int\n     **/\n    protected $treeDeep = 1;\n\n    /**\n     * Errors from last failed action\n     *\n     * @var array\n     **/\n    protected $error = array();\n\n    /**\n     * Today 24:00 timestamp\n     *\n     * @var int\n     **/\n    protected $today = 0;\n\n    /**\n     * Yesterday 24:00 timestamp\n     *\n     * @var int\n     **/\n    protected $yesterday = 0;\n\n    /**\n     * Force make dirctory on extract\n     *\n     * @var int\n     **/\n    protected $extractToNewdir = 'auto';\n\n    /**\n     * Object configuration\n     *\n     * @var array\n     **/\n    protected $options = array(\n        // Driver ID (Prefix of volume ID), Normally, the value specified for each volume driver is used.\n        'driverId' => '',\n        // Id (Suffix of volume ID), Normally, the number incremented according to the specified number of volumes is used.\n        'id' => '',\n        // revision id of root directory that uses for caching control of root stat\n        'rootRev' => '',\n        // driver type it uses volume root's CSS class name. e.g. 'group' -> Adds 'elfinder-group' to CSS class name.\n        'type' => '',\n        // root directory path\n        'path' => '',\n        // Folder hash value on elFinder to be the parent of this volume\n        'phash' => '',\n        // Folder hash value on elFinder to trash bin of this volume, it require 'copyJoin' to true\n        'trashHash' => '',\n        // open this path on initial request instead of root path\n        'startPath' => '',\n        // how many subdirs levels return per request\n        'treeDeep' => 1,\n        // root url, not set to URL via the connector. If you want to hide the file URL, do not set this value. (replacement for old \"fileURL\" option)\n        'URL' => '',\n        // enable onetime URL to a file - (true, false, 'auto' (true if a temporary directory is available) or callable (A function that return onetime URL))\n        'onetimeUrl' => 'auto',\n        // directory link url to own manager url with folder hash (`true`, `false`, `'hide'`(No show) or default `'auto'`: URL is empty then `true` else `false`)\n        'dirUrlOwn' => 'auto',\n        // directory separator. required by client to show paths correctly\n        'separator' => DIRECTORY_SEPARATOR,\n        // Use '/' as directory separator when the path hash encode/decode on the Windows server too\n        'winHashFix' => false,\n        // Server character encoding (default is '': UTF-8)\n        'encoding' => '',\n        // for convert character encoding (default is '': Not change locale)\n        'locale' => '',\n        // URL of volume icon image\n        'icon' => '',\n        // CSS Class of volume root in tree\n        'rootCssClass' => '',\n        // Items to disable session caching\n        'noSessionCache' => array(),\n        // enable i18n folder name that convert name to elFinderInstance.messages['folder_'+name]\n        'i18nFolderName' => false,\n        // Search timeout (sec)\n        'searchTimeout' => 30,\n        // Search exclusion directory regex pattern (require demiliter e.g. '#/path/to/exclude_directory#i')\n        'searchExDirReg' => '',\n        // library to crypt/uncrypt files names (not implemented)\n        'cryptLib' => '',\n        // how to detect files mimetypes. (auto/internal/finfo/mime_content_type)\n        'mimeDetect' => 'auto',\n        // mime.types file path (for mimeDetect==internal)\n        'mimefile' => '',\n        // Static extension/MIME of general server side scripts to security issues\n        'staticMineMap' => array(\n            'php:*' => 'text/x-php',\n            'pht:*' => 'text/x-php',\n            'php3:*' => 'text/x-php',\n            'php4:*' => 'text/x-php',\n            'php5:*' => 'text/x-php',\n            'php7:*' => 'text/x-php',\n            'phtml:*' => 'text/x-php',\n            'phar:*' => 'text/x-php',\n            'cgi:*' => 'text/x-httpd-cgi',\n            'pl:*' => 'text/x-perl',\n            'asp:*' => 'text/x-asap',\n            'aspx:*' => 'text/x-asap',\n            'py:*' => 'text/x-python',\n            'rb:*' => 'text/x-ruby',\n            'jsp:*' => 'text/x-jsp'\n        ),\n        // mime type normalize map : Array '[ext]:[detected mime type]' => '[normalized mime]'\n        'mimeMap' => array(\n            'md:application/x-genesis-rom' => 'text/x-markdown',\n            'md:text/plain' => 'text/x-markdown',\n            'markdown:text/plain' => 'text/x-markdown',\n            'css:text/x-asm' => 'text/css',\n            'css:text/plain' => 'text/css',\n            'csv:text/plain' => 'text/csv',\n            'java:text/x-c' => 'text/x-java-source',\n            'json:text/plain' => 'application/json',\n            'sql:text/plain' => 'text/x-sql',\n            'rtf:text/rtf' => 'application/rtf',\n            'rtfd:text/rtfd' => 'application/rtfd',\n            'ico:image/vnd.microsoft.icon' => 'image/x-icon',\n            'svg:text/plain' => 'image/svg+xml',\n            'pxd:application/octet-stream' => 'image/x-pixlr-data',\n            'dng:image/tiff' => 'image/x-adobe-dng',\n            'sketch:application/zip' => 'image/x-sketch',\n            'sketch:application/octet-stream' => 'image/x-sketch',\n            'xcf:application/octet-stream' => 'image/x-xcf',\n            'amr:application/octet-stream' => 'audio/amr',\n            'm4a:video/mp4' => 'audio/mp4',\n            'oga:application/ogg' => 'audio/ogg',\n            'ogv:application/ogg' => 'video/ogg',\n            'zip:application/x-zip' => 'application/zip',\n            'm3u8:text/plain' => 'application/x-mpegURL',\n            'mpd:text/plain' => 'application/dash+xml',\n            'mpd:application/xml' => 'application/dash+xml',\n            '*:application/x-dosexec' => 'application/x-executable',\n            'doc:application/vnd.ms-office' => 'application/msword',\n            'xls:application/vnd.ms-office' => 'application/vnd.ms-excel',\n            'ppt:application/vnd.ms-office' => 'application/vnd.ms-powerpoint',\n            'yml:text/plain' => 'text/x-yaml',\n            'ai:application/pdf' => 'application/postscript',\n            'cgm:text/plain' => 'image/cgm',\n            'dxf:text/plain' => 'image/vnd.dxf',\n            'dds:application/octet-stream' => 'image/vnd-ms.dds',\n            'hpgl:text/plain' => 'application/vnd.hp-hpgl',\n            'igs:text/plain' => 'model/iges',\n            'iges:text/plain' => 'model/iges',\n            'plt:application/octet-stream' => 'application/plt',\n            'plt:text/plain' => 'application/plt',\n            'sat:text/plain' => 'application/sat',\n            'step:text/plain' => 'application/step',\n            'stp:text/plain' => 'application/step'\n        ),\n        // An option to add MimeMap to the `mimeMap` option\n        // Array '[ext]:[detected mime type]' => '[normalized mime]'\n        'additionalMimeMap' => array(),\n        // MIME-Type of filetype detected as unknown\n        'mimeTypeUnknown' => 'application/octet-stream',\n        // MIME regex of send HTTP header \"Content-Disposition: inline\" or allow preview in quicklook\n        // '.' is allow inline of all of MIME types\n        // '$^' is not allow inline of all of MIME types\n        'dispInlineRegex' => '^(?:(?:video|audio)|image/(?!.+\\+xml)|application/(?:ogg|x-mpegURL|dash\\+xml)|(?:text/plain|application/pdf)$)',\n        // temporary content URL's base path\n        'tmpLinkPath' => '',\n        // temporary content URL's base URL\n        'tmpLinkUrl' => '',\n        // directory for thumbnails\n        'tmbPath' => '.tmb',\n        // mode to create thumbnails dir\n        'tmbPathMode' => 0777,\n        // thumbnails dir URL. Set it if store thumbnails outside root directory\n        'tmbURL' => '',\n        // thumbnails size (px)\n        'tmbSize' => 48,\n        // thumbnails crop (true - crop, false - scale image to fit thumbnail size)\n        'tmbCrop' => true,\n        // thumbnail URL require custom data as the GET query\n        'tmbReqCustomData' => false,\n        // thumbnails background color (hex #rrggbb or 'transparent')\n        'tmbBgColor' => 'transparent',\n        // image rotate fallback background color (hex #rrggbb)\n        'bgColorFb' => '#ffffff',\n        // image manipulations library (imagick|gd|convert|auto|none, none - Does not check the image library at all.)\n        'imgLib' => 'auto',\n        // Fallback self image to thumbnail (nothing imgLib)\n        'tmbFbSelf' => true,\n        // Video to Image converters ['TYPE or MIME' => ['func' => function($file){ /* Converts $file to Image */ return true; }, 'maxlen' => (int)TransferLength]]\n        'imgConverter' => array(),\n        // Max length of transfer to image converter\n        'tmbVideoConvLen' => 10000000,\n        // Captre point seccond\n        'tmbVideoConvSec' => 6,\n        // Life time (hour) for thumbnail garbage collection (\"0\" means no GC)\n        'tmbGcMaxlifeHour' => 0,\n        // Percentage of garbage collection executed for thumbnail creation command (\"1\" means \"1%\")\n        'tmbGcPercentage' => 1,\n        // Resource path of fallback icon images defailt: php/resouces\n        'resourcePath' => '',\n        // Jpeg image saveing quality\n        'jpgQuality' => 100,\n        // Save as progressive JPEG on image editing\n        'jpgProgressive' => true,\n        // enable to get substitute image with command `dim`\n        'substituteImg' => true,\n        // on paste file -  if true - old file will be replaced with new one, if false new file get name - original_name-number.ext\n        'copyOverwrite' => true,\n        // if true - join new and old directories content on paste\n        'copyJoin' => true,\n        // on upload -  if true - old file will be replaced with new one, if false new file get name - original_name-number.ext\n        'uploadOverwrite' => true,\n        // mimetypes allowed to upload\n        'uploadAllow' => array(),\n        // mimetypes not allowed to upload\n        'uploadDeny' => array(),\n        // order to process uploadAllow and uploadDeny options\n        'uploadOrder' => array('deny', 'allow'),\n        // maximum upload file size. NOTE - this is size for every uploaded files\n        'uploadMaxSize' => 0,\n        // Maximum number of folders that can be created at one time. (0: unlimited)\n        'uploadMaxMkdirs' => 0,\n        // maximum number of chunked upload connection. `-1` to disable chunked upload\n        'uploadMaxConn' => 3,\n        // maximum get file size. NOTE - Maximum value is 50% of PHP memory_limit\n        'getMaxSize' => 0,\n        // files dates format\n        'dateFormat' => 'j M Y H:i',\n        // files time format\n        'timeFormat' => 'H:i',\n        // if true - every folder will be check for children folders, -1 - every folder will be check asynchronously, false -  all folders will be marked as having subfolders\n        'checkSubfolders' => true, // true, false or -1\n        // allow to copy from this volume to other ones?\n        'copyFrom' => true,\n        // allow to copy from other volumes to this one?\n        'copyTo' => true,\n        // cmd duplicate suffix format e.g. '_%s_' to without spaces\n        'duplicateSuffix' => ' %s ',\n        // unique name numbar format e.g. '(%d)' to (1), (2)...\n        'uniqueNumFormat' => '%d',\n        // list of commands disabled on this root\n        'disabled' => array(),\n        // enable file owner, group & mode info, `false` to inactivate \"chmod\" command.\n        'statOwner' => false,\n        // allow exec chmod of read-only files\n        'allowChmodReadOnly' => false,\n        // regexp or function name to validate new file name\n        'acceptedName' => '/^[^\\.].*/', // Notice: overwritten it in some volume drivers contractor\n        // regexp or function name to validate new directory name\n        'acceptedDirname' => '', // used `acceptedName` if empty value\n        // function/class method to control files permissions\n        'accessControl' => null,\n        // some data required by access control\n        'accessControlData' => null,\n        // root stat that return without asking the system when mounted and not the current volume. Query to the system with false. array|false\n        'rapidRootStat' => array(\n            'read' => true,\n            'write' => true,\n            'locked' => false,\n            'hidden' => false,\n            'size' => 0,  // Unknown\n            'ts' => 0,    // Unknown\n            'dirs' => -1, // Check on demand for subdirectories\n            'mime' => 'directory'\n        ),\n        // default permissions.\n        'defaults' => array(\n            'read' => true,\n            'write' => true,\n            'locked' => false,\n            'hidden' => false\n        ),\n        // files attributes\n        'attributes' => array(),\n        // max allowed archive files size (0 - no limit)\n        'maxArcFilesSize' => '2G',\n        // Allowed archive's mimetypes to create. Leave empty for all available types.\n        'archiveMimes' => array(),\n        // Manual config for archivers. See example below. Leave empty for auto detect\n        'archivers' => array(),\n        // Use Archive function for remote volume\n        'useRemoteArchive' => false,\n        // plugin settings\n        'plugin' => array(),\n        // Is support parent directory time stamp update on add|remove|rename item\n        // Default `null` is auto detection that is LocalFileSystem, FTP or Dropbox are `true`\n        'syncChkAsTs' => null,\n        // Long pooling sync checker function for syncChkAsTs is true\n        // Calls with args (TARGET DIRCTORY PATH, STAND-BY(sec), OLD TIMESTAMP, VOLUME DRIVER INSTANCE, ELFINDER INSTANCE)\n        // This function must return the following values. Changed: New Timestamp or Same: Old Timestamp or Error: false\n        // Default `null` is try use elFinderVolumeLocalFileSystem::localFileSystemInotify() on LocalFileSystem driver\n        // another driver use elFinder stat() checker\n        'syncCheckFunc' => null,\n        // Long polling sync stand-by time (sec)\n        'plStandby' => 30,\n        // Sleep time (sec) for elFinder stat() checker (syncChkAsTs is true)\n        'tsPlSleep' => 10,\n        // Sleep time (sec) for elFinder ls() checker (syncChkAsTs is false)\n        'lsPlSleep' => 30,\n        // Client side sync interval minimum (ms)\n        // Default `null` is auto set to ('tsPlSleep' or 'lsPlSleep') * 1000\n        // `0` to disable auto sync\n        'syncMinMs' => null,\n        // required to fix bug on macos\n        // However, we recommend to use the Normalizer plugin instead this option\n        'utf8fix' => false,\n        //                           \u0439                 \u0451              \u0419               \u0401              \u00d8         \u00c5\n        'utf8patterns' => array(\"\\u0438\\u0306\", \"\\u0435\\u0308\", \"\\u0418\\u0306\", \"\\u0415\\u0308\", \"\\u00d8A\", \"\\u030a\"),\n        'utf8replace' => array(\"\\u0439\", \"\\u0451\", \"\\u0419\", \"\\u0401\", \"\\u00d8\", \"\\u00c5\"),\n        // cache control HTTP headers for commands `file` and  `get`\n        'cacheHeaders' => array(\n            'Cache-Control: max-age=3600',\n            'Expires:',\n            'Pragma:'\n        ),\n        // Header to use to accelerate sending local files to clients (e.g. 'X-Sendfile', 'X-Accel-Redirect')\n        'xsendfile' => '',\n        // Root path to xsendfile target. Probably, this is required for 'X-Accel-Redirect' on Nginx.\n        'xsendfilePath' => ''\n    );\n\n    /**\n     * Defaults permissions\n     *\n     * @var array\n     **/\n    protected $defaults = array(\n        'read' => true,\n        'write' => true,\n        'locked' => false,\n        'hidden' => false\n    );\n\n    /**\n     * Access control function/class\n     *\n     * @var mixed\n     **/\n    protected $attributes = array();\n\n    /**\n     * Access control function/class\n     *\n     * @var mixed\n     **/\n    protected $access = null;\n\n    /**\n     * Mime types allowed to upload\n     *\n     * @var array\n     **/\n    protected $uploadAllow = array();\n\n    /**\n     * Mime types denied to upload\n     *\n     * @var array\n     **/\n    protected $uploadDeny = array();\n\n    /**\n     * Order to validate uploadAllow and uploadDeny\n     *\n     * @var array\n     **/\n    protected $uploadOrder = array();\n\n    /**\n     * Maximum allowed upload file size.\n     * Set as number or string with unit - \"10M\", \"500K\", \"1G\"\n     *\n     * @var int|string\n     **/\n    protected $uploadMaxSize = 0;\n\n    /**\n     * Run time setting of overwrite items on upload\n     *\n     * @var string\n     */\n    protected $uploadOverwrite = true;\n\n    /**\n     * Maximum allowed get file size.\n     * Set as number or string with unit - \"10M\", \"500K\", \"1G\"\n     *\n     * @var int|string\n     **/\n    protected $getMaxSize = -1;\n\n    /**\n     * Mimetype detect method\n     *\n     * @var string\n     **/\n    protected $mimeDetect = 'auto';\n\n    /**\n     * Flag - mimetypes from externail file was loaded\n     *\n     * @var bool\n     **/\n    private static $mimetypesLoaded = false;\n\n    /**\n     * Finfo resource for mimeDetect == 'finfo'\n     *\n     * @var resource\n     **/\n    protected $finfo = null;\n\n    /**\n     * List of disabled client's commands\n     *\n     * @var array\n     **/\n    protected $disabled = array();\n\n    /**\n     * overwrite extensions/mimetypes to mime.types\n     *\n     * @var array\n     **/\n    protected static $mimetypes = array(\n        // applications\n        'exe' => 'application/x-executable',\n        'jar' => 'application/x-jar',\n        // archives\n        'gz' => 'application/x-gzip',\n        'tgz' => 'application/x-gzip',\n        'tbz' => 'application/x-bzip2',\n        'rar' => 'application/x-rar',\n        // texts\n        'php' => 'text/x-php',\n        'js' => 'text/javascript',\n        'rtfd' => 'application/rtfd',\n        'py' => 'text/x-python',\n        'rb' => 'text/x-ruby',\n        'sh' => 'text/x-shellscript',\n        'pl' => 'text/x-perl',\n        'xml' => 'text/xml',\n        'c' => 'text/x-csrc',\n        'h' => 'text/x-chdr',\n        'cpp' => 'text/x-c++src',\n        'hh' => 'text/x-c++hdr',\n        'md' => 'text/x-markdown',\n        'markdown' => 'text/x-markdown',\n        'yml' => 'text/x-yaml',\n        // images\n        'bmp' => 'image/x-ms-bmp',\n        'tga' => 'image/x-targa',\n        'xbm' => 'image/xbm',\n        'pxm' => 'image/pxm',\n        //audio\n        'wav' => 'audio/wav',\n        // video\n        'dv' => 'video/x-dv',\n        'wm' => 'video/x-ms-wmv',\n        'ogm' => 'video/ogg',\n        'm2ts' => 'video/MP2T',\n        'mts' => 'video/MP2T',\n        'ts' => 'video/MP2T',\n        'm3u8' => 'application/x-mpegURL',\n        'mpd' => 'application/dash+xml'\n    );\n\n    /**\n     * Directory separator - required by client\n     *\n     * @var string\n     **/\n    protected $separator = DIRECTORY_SEPARATOR;\n\n    /**\n     * Directory separator for decode/encode hash\n     *\n     * @var string\n     **/\n    protected $separatorForHash = '';\n\n    /**\n     * System Root path (Unix like: '/', Windows: '\\', 'C:\\' or 'D:\\'...)\n     *\n     * @var string\n     **/\n    protected $systemRoot = DIRECTORY_SEPARATOR;\n\n    /**\n     * Mimetypes allowed to display\n     *\n     * @var array\n     **/\n    protected $onlyMimes = array();\n\n    /**\n     * Store files moved or overwrited files info\n     *\n     * @var array\n     **/\n    protected $removed = array();\n\n    /**\n     * Store files added files info\n     *\n     * @var array\n     **/\n    protected $added = array();\n\n    /**\n     * Cache storage\n     *\n     * @var array\n     **/\n    protected $cache = array();\n\n    /**\n     * Cache by folders\n     *\n     * @var array\n     **/\n    protected $dirsCache = array();\n\n    /**\n     * You should use `$this->sessionCache['subdirs']` instead\n     *\n     * @var array\n     * @deprecated\n     */\n    protected $subdirsCache = array();\n\n    /**\n     * This volume session cache\n     *\n     * @var array\n     */\n    protected $sessionCache;\n\n    /**\n     * Session caching item list\n     *\n     * @var array\n     */\n    protected $sessionCaching = array('rootstat' => true, 'subdirs' => true);\n\n    /**\n     * elFinder session wrapper object\n     *\n     * @var elFinderSessionInterface\n     */\n    protected $session;\n\n    /**\n     * Search start time\n     *\n     * @var int\n     */\n    protected $searchStart;\n\n    /**\n     * Current query word on doSearch\n     *\n     * @var array\n     **/\n    protected $doSearchCurrentQuery = array();\n\n    /**\n     * Is root modified (for clear root stat cache)\n     *\n     * @var bool\n     */\n    protected $rootModified = false;\n\n    /**\n     * Is disable of command `url`\n     *\n     * @var string\n     */\n    protected $disabledGetUrl = false;\n\n    /**\n     * Accepted filename validator\n     *\n     * @var string | callable\n     */\n    protected $nameValidator;\n\n    /**\n     * Accepted dirname validator\n     *\n     * @var string | callable\n     */\n    protected $dirnameValidator;\n\n    /**\n     * This request require online state\n     *\n     * @var boolean\n     */\n    protected $needOnline;\n\n    /*********************************************************************/\n    /*                            INITIALIZATION                         */\n    /*********************************************************************/\n\n    /**\n     * Sets the need online.\n     *\n     * @param  boolean  $state  The state\n     */\n    public function setNeedOnline($state = null)\n    {\n        if ($state !== null) {\n            $this->needOnline = (bool)$state;\n            return;\n        }\n\n        $need = false;\n        $arg = $this->ARGS;\n        $id = $this->id;\n\n        $target = !empty($arg['target'])? $arg['target'] : (!empty($arg['dst'])? $arg['dst'] : '');\n        $targets = !empty($arg['targets'])? $arg['targets'] : array();\n        if (!is_array($targets)) {\n            $targets = array($targets);\n        }\n\n        if ($target && strpos($target, $id) === 0) {\n            $need = true;\n        } else if ($targets) {\n            foreach($targets as $t) {\n                if ($t && strpos($t, $id) === 0) {\n                    $need = true;\n                    break;\n                }\n            }\n        }\n\n        $this->needOnline = $need;\n    }\n\n    /**\n     * Prepare driver before mount volume.\n     * Return true if volume is ready.\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function init()\n    {\n        return true;\n    }\n\n    /**\n     * Configure after successfull mount.\n     * By default set thumbnails path and image manipulation library.\n     *\n     * @return void\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function configure()\n    {\n        // set thumbnails path\n        $path = $this->options['tmbPath'];\n        if ($path) {\n            if (!file_exists($path)) {\n                if (mkdir($path)) {\n                    chmod($path, $this->options['tmbPathMode']);\n                } else {\n                    $path = '';\n                }\n            }\n\n            if (is_dir($path) && is_readable($path)) {\n                $this->tmbPath = $path;\n                $this->tmbPathWritable = is_writable($path);\n            }\n        }\n        // set resouce path\n        if (!is_dir($this->options['resourcePath'])) {\n            $this->options['resourcePath'] = dirname(__FILE__) . DIRECTORY_SEPARATOR . 'resources';\n        }\n\n        // set image manipulation library\n        $type = preg_match('/^(imagick|gd|convert|auto|none)$/i', $this->options['imgLib'])\n            ? strtolower($this->options['imgLib'])\n            : 'auto';\n\n        if ($type === 'none') {\n            $this->imgLib = '';\n        } else {\n            if (($type === 'imagick' || $type === 'auto') && extension_loaded('imagick')) {\n                $this->imgLib = 'imagick';\n            } else if (($type === 'gd' || $type === 'auto') && function_exists('gd_info')) {\n                $this->imgLib = 'gd';\n            } else {\n                $convertCache = 'imgLibConvert';\n                if (($convertCmd = $this->session->get($convertCache, false)) !== false) {\n                    $this->imgLib = $convertCmd;\n                } else {\n                    $this->imgLib = ($this->procExec(ELFINDER_CONVERT_PATH . ' -version') === 0) ? 'convert' : '';\n                    $this->session->set($convertCache, $this->imgLib);\n                }\n            }\n            if ($type !== 'auto' && $this->imgLib === '') {\n                // fallback\n                $this->imgLib = extension_loaded('imagick') ? 'imagick' : (function_exists('gd_info') ? 'gd' : '');\n            }\n        }\n\n        // check video to img converter\n        if (!empty($this->options['imgConverter']) && is_array($this->options['imgConverter'])) {\n            foreach ($this->options['imgConverter'] as $_type => $_converter) {\n                if (isset($_converter['func'])) {\n                    $this->imgConverter[strtolower($_type)] = $_converter;\n                }\n            }\n        }\n        if (!isset($this->imgConverter['video'])) {\n            $videoLibCache = 'videoLib';\n            if (($videoLibCmd = $this->session->get($videoLibCache, false)) === false) {\n                $videoLibCmd = ($this->procExec(ELFINDER_FFMPEG_PATH . ' -version') === 0) ? 'ffmpeg' : '';\n                $this->session->set($videoLibCache, $videoLibCmd);\n            }\n            if ($videoLibCmd) {\n                $this->imgConverter['video'] = array(\n                    'func' => array($this, $videoLibCmd . 'ToImg'),\n                    'maxlen' => $this->options['tmbVideoConvLen']\n                );\n            }\n        }\n\n        // check onetimeUrl\n        if (strtolower($this->options['onetimeUrl']) === 'auto') {\n            $this->options['onetimeUrl'] = elFinder::getStaticVar('commonTempPath')? true : false;\n        }\n\n        // check archivers\n        if (empty($this->archivers['create'])) {\n            $this->disabled[] = 'archive';\n        }\n        if (empty($this->archivers['extract'])) {\n            $this->disabled[] = 'extract';\n        }\n        $_arc = $this->getArchivers();\n        if (empty($_arc['create'])) {\n            $this->disabled[] = 'zipdl';\n        }\n\n        if ($this->options['maxArcFilesSize']) {\n            $this->options['maxArcFilesSize'] = elFinder::getIniBytes('', $this->options['maxArcFilesSize']);\n        }\n        self::$maxArcFilesSize = $this->options['maxArcFilesSize'];\n\n        // check 'statOwner' for command `chmod`\n        if (empty($this->options['statOwner'])) {\n            $this->disabled[] = 'chmod';\n        }\n\n        // check 'mimeMap'\n        if (!is_array($this->options['mimeMap'])) {\n            $this->options['mimeMap'] = array();\n        }\n        if (is_array($this->options['staticMineMap']) && $this->options['staticMineMap']) {\n            $this->options['mimeMap'] = array_merge($this->options['mimeMap'], $this->options['staticMineMap']);\n        }\n        if (is_array($this->options['additionalMimeMap']) && $this->options['additionalMimeMap']) {\n            $this->options['mimeMap'] = array_merge($this->options['mimeMap'], $this->options['additionalMimeMap']);\n        }\n\n        // check 'url' in disabled commands\n        if (in_array('url', $this->disabled)) {\n            $this->disabledGetUrl = true;\n        }\n\n        // set run time setting uploadOverwrite\n        $this->uploadOverwrite = $this->options['uploadOverwrite'];\n    }\n\n    /**\n     * @deprecated\n     */\n    protected function sessionRestart()\n    {\n        $this->sessionCache = $this->session->start()->get($this->id, array());\n        return true;\n    }\n\n    /*********************************************************************/\n    /*                              PUBLIC API                           */\n    /*********************************************************************/\n\n    /**\n     * Return driver id. Used as a part of volume id.\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    public function driverId()\n    {\n        return $this->driverId;\n    }\n\n    /**\n     * Return volume id\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    public function id()\n    {\n        return $this->id;\n    }\n\n    /**\n     * Assign elFinder session wrapper object\n     *\n     * @param  $session  elFinderSessionInterface\n     */\n    public function setSession($session)\n    {\n        $this->session = $session;\n    }\n\n    /**\n     * Get elFinder sesson wrapper object\n     *\n     * @return object  The session object\n     */\n    public function getSession()\n    {\n        return $this->session;\n    }\n\n    /**\n     * Save session cache data\n     * Calls this function before umount this volume on elFinder::exec()\n     *\n     * @return void\n     */\n    public function saveSessionCache()\n    {\n        $this->session->set($this->id, $this->sessionCache);\n    }\n\n    /**\n     * Return debug info for client\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    public function debug()\n    {\n        return array(\n            'id' => $this->id(),\n            'name' => strtolower(substr(get_class($this), strlen('elfinderdriver'))),\n            'mimeDetect' => $this->mimeDetect,\n            'imgLib' => $this->imgLib\n        );\n    }\n\n    /**\n     * chmod a file or folder\n     *\n     * @param  string $hash file or folder hash to chmod\n     * @param  string $mode octal string representing new permissions\n     *\n     * @return array|false\n     * @author David Bartle\n     **/\n    public function chmod($hash, $mode)\n    {\n        if ($this->commandDisabled('chmod')) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        if (!($file = $this->file($hash))) {\n            return $this->setError(elFinder::ERROR_FILE_NOT_FOUND);\n        }\n\n        if (!$this->options['allowChmodReadOnly']) {\n            if (!$this->attr($this->decode($hash), 'write', null, ($file['mime'] === 'directory'))) {\n                return $this->setError(elFinder::ERROR_PERM_DENIED, $file['name']);\n            }\n        }\n\n        $path = $this->decode($hash);\n        $write = $file['write'];\n\n        if ($this->convEncOut(!$this->_chmod($this->convEncIn($path), $mode))) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED, $file['name']);\n        }\n\n        $this->clearstatcache();\n        if ($path == $this->root) {\n            $this->rootModified = true;\n        }\n\n        if ($file = $this->stat($path)) {\n            $files = array($file);\n            if ($file['mime'] === 'directory' && $write !== $file['write']) {\n                foreach ($this->getScandir($path) as $stat) {\n                    if ($this->mimeAccepted($stat['mime'])) {\n                        $files[] = $stat;\n                    }\n                }\n            }\n            return $files;\n        } else {\n            return $this->setError(elFinder::ERROR_FILE_NOT_FOUND);\n        }\n    }\n\n    /**\n     * stat a file or folder for elFinder cmd exec\n     *\n     * @param  string $hash file or folder hash to chmod\n     *\n     * @return array\n     * @author Naoki Sawada\n     **/\n    public function fstat($hash)\n    {\n        $path = $this->decode($hash);\n        return $this->stat($path);\n    }\n\n    /**\n     * Clear PHP stat cache & all of inner stat caches\n     */\n    public function clearstatcache()\n    {\n        clearstatcache();\n        $this->clearcache();\n    }\n\n    /**\n     * Clear inner stat caches for target hash\n     *\n     * @param string $hash\n     */\n    public function clearcaches($hash = null)\n    {\n        if ($hash === null) {\n            $this->clearcache();\n        } else {\n            $path = $this->decode($hash);\n            unset($this->cache[$path], $this->dirsCache[$path]);\n        }\n    }\n\n    /**\n     * \"Mount\" volume.\n     * Return true if volume available for read or write,\n     * false - otherwise\n     *\n     * @param array $opts\n     *\n     * @return bool\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     * @author Alexey Sukhotin\n     */\n    public function mount(array $opts)\n    {\n        $this->options = array_merge($this->options, $opts);\n\n        if (!isset($this->options['path']) || $this->options['path'] === '') {\n            return $this->setError('Path undefined.');\n        }\n\n        if (!$this->session) {\n            return $this->setError('Session wrapper dose not set. Need to `$volume->setSession(elFinderSessionInterface);` before mount.');\n        }\n        if (!($this->session instanceof elFinderSessionInterface)) {\n            return $this->setError('Session wrapper instance must be \"elFinderSessionInterface\".');\n        }\n\n        // set driverId\n        if (!empty($this->options['driverId'])) {\n            $this->driverId = $this->options['driverId'];\n        }\n\n        $this->id = $this->driverId . (!empty($this->options['id']) ? $this->options['id'] : elFinder::$volumesCnt++) . '_';\n        $this->root = $this->normpathCE($this->options['path']);\n        $this->separator = isset($this->options['separator']) ? $this->options['separator'] : DIRECTORY_SEPARATOR;\n        if (!empty($this->options['winHashFix'])) {\n            $this->separatorForHash = ($this->separator !== '/') ? '/' : '';\n        }\n        $this->systemRoot = isset($this->options['systemRoot']) ? $this->options['systemRoot'] : $this->separator;\n\n        // set ARGS\n        $this->ARGS = $_SERVER['REQUEST_METHOD'] === 'POST' ? $_POST : $_GET;\n\n        $argInit = !empty($this->ARGS['init']);\n\n        // set $this->needOnline\n        if (!is_bool($this->needOnline)) {\n            $this->setNeedOnline();\n        }\n\n        // session cache\n        if ($argInit) {\n            $this->session->set($this->id, array());\n        }\n        $this->sessionCache = $this->session->get($this->id, array());\n\n        // default file attribute\n        $this->defaults = array(\n            'read' => isset($this->options['defaults']['read']) ? !!$this->options['defaults']['read'] : true,\n            'write' => isset($this->options['defaults']['write']) ? !!$this->options['defaults']['write'] : true,\n            'locked' => isset($this->options['defaults']['locked']) ? !!$this->options['defaults']['locked'] : false,\n            'hidden' => isset($this->options['defaults']['hidden']) ? !!$this->options['defaults']['hidden'] : false\n        );\n\n        // root attributes\n        $this->attributes[] = array(\n            'pattern' => '~^' . preg_quote($this->separator) . '$~',\n            'locked' => true,\n            'hidden' => false\n        );\n        // set files attributes\n        if (!empty($this->options['attributes']) && is_array($this->options['attributes'])) {\n\n            foreach ($this->options['attributes'] as $a) {\n                // attributes must contain pattern and at least one rule\n                if (!empty($a['pattern']) || (is_array($a) && count($a) > 1)) {\n                    $this->attributes[] = $a;\n                }\n            }\n        }\n\n        if (!empty($this->options['accessControl']) && is_callable($this->options['accessControl'])) {\n            $this->access = $this->options['accessControl'];\n        }\n\n        $this->today = mktime(0, 0, 0, date('m'), date('d'), date('Y'));\n        $this->yesterday = $this->today - 86400;\n\n        if (!$this->init()) {\n            return false;\n        }\n\n        // set server encoding\n        if (!empty($this->options['encoding']) && strtoupper($this->options['encoding']) !== 'UTF-8') {\n            $this->encoding = $this->options['encoding'];\n        } else {\n            $this->encoding = null;\n        }\n\n        // check some options is arrays\n        $this->uploadAllow = isset($this->options['uploadAllow']) && is_array($this->options['uploadAllow'])\n            ? $this->options['uploadAllow']\n            : array();\n\n        $this->uploadDeny = isset($this->options['uploadDeny']) && is_array($this->options['uploadDeny'])\n            ? $this->options['uploadDeny']\n            : array();\n\n        $this->options['uiCmdMap'] = (isset($this->options['uiCmdMap']) && is_array($this->options['uiCmdMap']))\n            ? $this->options['uiCmdMap']\n            : array();\n\n        if (is_string($this->options['uploadOrder'])) { // telephat_mode on, compatibility with 1.x\n            $parts = explode(',', isset($this->options['uploadOrder']) ? $this->options['uploadOrder'] : 'deny,allow');\n            $this->uploadOrder = array(trim($parts[0]), trim($parts[1]));\n        } else { // telephat_mode off\n            $this->uploadOrder = !empty($this->options['uploadOrder']) ? $this->options['uploadOrder'] : array('deny', 'allow');\n        }\n\n        if (!empty($this->options['uploadMaxSize'])) {\n            $this->uploadMaxSize = elFinder::getIniBytes('', $this->options['uploadMaxSize']);\n        }\n        // Set maximum to PHP_INT_MAX\n        if (!defined('PHP_INT_MAX')) {\n            define('PHP_INT_MAX', 2147483647);\n        }\n        if ($this->uploadMaxSize < 1 || $this->uploadMaxSize > PHP_INT_MAX) {\n            $this->uploadMaxSize = PHP_INT_MAX;\n        }\n\n        // Set to get maximum size to 50% of memory_limit\n        $memLimit = elFinder::getIniBytes('memory_limit') / 2;\n        if ($memLimit > 0) {\n            $this->getMaxSize = empty($this->options['getMaxSize']) ? $memLimit : min($memLimit, elFinder::getIniBytes('', $this->options['getMaxSize']));\n        } else {\n            $this->getMaxSize = -1;\n        }\n\n        $this->disabled = isset($this->options['disabled']) && is_array($this->options['disabled'])\n            ? array_values(array_diff($this->options['disabled'], array('open'))) // 'open' is required\n            : array();\n\n        $this->cryptLib = $this->options['cryptLib'];\n        $this->mimeDetect = $this->options['mimeDetect'];\n\n        // find available mimetype detect method\n        $regexp = '/text\\/x\\-(php|c\\+\\+)/';\n        $auto_types = array();\n\n        if (class_exists('finfo', false)) {\n            $tmpFileInfo = explode(';', finfo_file(finfo_open(FILEINFO_MIME), __FILE__));\n             if ($tmpFileInfo && preg_match($regexp, array_shift($tmpFileInfo))) {\n                $auto_types[] = 'finfo';\n            }\n        }\n        \n        if (function_exists('mime_content_type')) {\n            $_mimetypes = explode(';', mime_content_type(__FILE__));\n            if (preg_match($regexp, array_shift($_mimetypes))) {\n                $auto_types[] = 'mime_content_type';\n            }\n        }\n            \n        $auto_types[] = 'internal';\n\n        $type = strtolower($this->options['mimeDetect']);\n        if (!in_array($type, $auto_types)) {\n            $type = 'auto';\n        }\n\n        if ($type == 'auto') {\n            $type = array_shift($auto_types);\n        }\n\n        $this->mimeDetect = $type;\n\n        if ($this->mimeDetect == 'finfo') {\n            $this->finfo = finfo_open(FILEINFO_MIME);\n        } else if ($this->mimeDetect == 'internal' && !elFinderVolumeDriver::$mimetypesLoaded) {\n            // load mimes from external file for mimeDetect == 'internal'\n            // based on Alexey Sukhotin idea and patch: http://elrte.org/redmine/issues/163\n            // file must be in file directory or in parent one\n            elFinderVolumeDriver::loadMimeTypes(!empty($this->options['mimefile']) ? $this->options['mimefile'] : '');\n        }\n        $this->rootName = empty($this->options['alias']) ? $this->basenameCE($this->root) : $this->options['alias'];\n\n        // This get's triggered if $this->root == '/' and alias is empty.\n        // Maybe modify _basename instead?\n        if ($this->rootName === '') $this->rootName = $this->separator;\n\n        $this->_checkArchivers();\n\n        $root = $this->stat($this->root);\n\n        if (!$root) {\n            return $this->setError('Root folder does not exist.');\n        }\n        if (!$root['read'] && !$root['write']) {\n            return $this->setError('Root folder has not read and write permissions.');\n        }\n\n        if ($root['read']) {\n            if ($argInit) {\n                // check startPath - path to open by default instead of root\n                $startPath = $this->options['startPath'] ? $this->normpathCE($this->options['startPath']) : '';\n                if ($startPath) {\n                    $start = $this->stat($startPath);\n                    if (!empty($start)\n                        && $start['mime'] == 'directory'\n                        && $start['read']\n                        && empty($start['hidden'])\n                        && $this->inpathCE($startPath, $this->root)) {\n                        $this->startPath = $startPath;\n                        if (substr($this->startPath, -1, 1) == $this->options['separator']) {\n                            $this->startPath = substr($this->startPath, 0, -1);\n                        }\n                    }\n                }\n            }\n        } else {\n            $this->options['URL'] = '';\n            $this->options['tmbURL'] = '';\n            $this->options['tmbPath'] = '';\n            // read only volume\n            array_unshift($this->attributes, array(\n                'pattern' => '/.*/',\n                'read' => false\n            ));\n        }\n        $this->treeDeep = $this->options['treeDeep'] > 0 ? (int)$this->options['treeDeep'] : 1;\n        $this->tmbSize = $this->options['tmbSize'] > 0 ? (int)$this->options['tmbSize'] : 48;\n        $this->URL = $this->options['URL'];\n        if ($this->URL && preg_match(\"|[^/?&=]$|\", $this->URL)) {\n            $this->URL .= '/';\n        }\n\n        $dirUrlOwn = strtolower($this->options['dirUrlOwn']);\n        if ($dirUrlOwn === 'auto') {\n            $this->options['dirUrlOwn'] = $this->URL ? false : true;\n        } else if ($dirUrlOwn === 'hide') {\n            $this->options['dirUrlOwn'] = 'hide';\n        } else {\n            $this->options['dirUrlOwn'] = (bool)$this->options['dirUrlOwn'];\n        }\n\n        $this->tmbURL = !empty($this->options['tmbURL']) ? $this->options['tmbURL'] : '';\n        if ($this->tmbURL && $this->tmbURL !== 'self' && preg_match(\"|[^/?&=]$|\", $this->tmbURL)) {\n            $this->tmbURL .= '/';\n        }\n\n        $this->nameValidator = !empty($this->options['acceptedName']) && (is_string($this->options['acceptedName']) || is_callable($this->options['acceptedName']))\n            ? $this->options['acceptedName']\n            : '';\n\n        $this->dirnameValidator = !empty($this->options['acceptedDirname']) && (is_callable($this->options['acceptedDirname']) || (is_string($this->options['acceptedDirname']) && preg_match($this->options['acceptedDirname'], '') !== false))\n            ? $this->options['acceptedDirname']\n            : $this->nameValidator;\n\n        // enabling archivers['create'] with options['useRemoteArchive']\n        if ($this->options['useRemoteArchive'] && empty($this->archivers['create']) && $this->getTempPath()) {\n            $_archivers = $this->getArchivers();\n            $this->archivers['create'] = $_archivers['create'];\n        }\n\n        // manual control archive types to create\n        if (!empty($this->options['archiveMimes']) && is_array($this->options['archiveMimes'])) {\n            foreach ($this->archivers['create'] as $mime => $v) {\n                if (!in_array($mime, $this->options['archiveMimes'])) {\n                    unset($this->archivers['create'][$mime]);\n                }\n            }\n        }\n\n        // manualy add archivers\n        if (!empty($this->options['archivers']['create']) && is_array($this->options['archivers']['create'])) {\n            foreach ($this->options['archivers']['create'] as $mime => $conf) {\n                if (strpos($mime, 'application/') === 0\n                    && !empty($conf['cmd'])\n                    && isset($conf['argc'])\n                    && !empty($conf['ext'])\n                    && !isset($this->archivers['create'][$mime])) {\n                    $this->archivers['create'][$mime] = $conf;\n                }\n            }\n        }\n\n        if (!empty($this->options['archivers']['extract']) && is_array($this->options['archivers']['extract'])) {\n            foreach ($this->options['archivers']['extract'] as $mime => $conf) {\n                if (strpos($mime, 'application/') === 0\n                    && !empty($conf['cmd'])\n                    && isset($conf['argc'])\n                    && !empty($conf['ext'])\n                    && !isset($this->archivers['extract'][$mime])) {\n                    $this->archivers['extract'][$mime] = $conf;\n                }\n            }\n        }\n\n        if (!empty($this->options['noSessionCache']) && is_array($this->options['noSessionCache'])) {\n            foreach ($this->options['noSessionCache'] as $_key) {\n                $this->sessionCaching[$_key] = false;\n                unset($this->sessionCache[$_key]);\n            }\n        }\n        if ($this->sessionCaching['subdirs']) {\n            if (!isset($this->sessionCache['subdirs'])) {\n                $this->sessionCache['subdirs'] = array();\n            }\n        }\n\n\n        $this->configure();\n\n        // Normalize disabled (array_merge`for type array of JSON)\n        $this->disabled = array_values(array_unique($this->disabled));\n\n        // fix sync interval\n        if ($this->options['syncMinMs'] !== 0) {\n            $this->options['syncMinMs'] = max($this->options[$this->options['syncChkAsTs'] ? 'tsPlSleep' : 'lsPlSleep'] * 1000, intval($this->options['syncMinMs']));\n        }\n\n        // ` copyJoin` is required for the trash function\n        if ($this->options['trashHash'] && empty($this->options['copyJoin'])) {\n            $this->options['trashHash'] = '';\n        }\n\n        // set tmpLinkPath\n        if (elFinder::$tmpLinkPath && !$this->options['tmpLinkPath']) {\n            if (is_writeable(elFinder::$tmpLinkPath)) {\n                $this->options['tmpLinkPath'] = elFinder::$tmpLinkPath;\n            } else {\n                elFinder::$tmpLinkPath = '';\n            }\n        }\n        if ($this->options['tmpLinkPath'] && is_writable($this->options['tmpLinkPath'])) {\n            $this->tmpLinkPath = realpath($this->options['tmpLinkPath']);\n        } else if (!$this->tmpLinkPath && $this->tmbURL && $this->tmbPath) {\n            $this->tmpLinkPath = $this->tmbPath;\n            $this->options['tmpLinkUrl'] = $this->tmbURL;\n        } else if (!$this->options['URL'] && is_writable('../files/.tmb')) {\n            $this->tmpLinkPath = realpath('../files/.tmb');\n            $this->options['tmpLinkUrl'] = '';\n            if (!elFinder::$tmpLinkPath) {\n                elFinder::$tmpLinkPath = $this->tmpLinkPath;\n                elFinder::$tmpLinkUrl = '';\n            }\n        }\n\n        // set tmpLinkUrl\n        if (elFinder::$tmpLinkUrl && !$this->options['tmpLinkUrl']) {\n            $this->options['tmpLinkUrl'] = elFinder::$tmpLinkUrl;\n        }\n        if ($this->options['tmpLinkUrl']) {\n            $this->tmpLinkUrl = $this->options['tmpLinkUrl'];\n        }\n        if ($this->tmpLinkPath && !$this->tmpLinkUrl) {\n            $cur = realpath('./');\n            $i = 0;\n            while ($cur !== $this->systemRoot && strpos($this->tmpLinkPath, $cur) !== 0) {\n                $i++;\n                $cur = dirname($cur);\n            }\n            list($req) = explode('?', $_SERVER['REQUEST_URI']);\n            $reqs = explode('/', dirname($req));\n            $uri = join('/', array_slice($reqs, 0, count($reqs) - 1)) . substr($this->tmpLinkPath, strlen($cur));\n            $https = (isset($_SERVER['HTTPS']) && strtolower($_SERVER['HTTPS']) !== 'off');\n            $this->tmpLinkUrl = ($https ? 'https://' : 'http://')\n                . $_SERVER['SERVER_NAME'] // host\n                . (((!$https && $_SERVER['SERVER_PORT'] == 80) || ($https && $_SERVER['SERVER_PORT'] == 443)) ? '' : (':' . $_SERVER['SERVER_PORT']))  // port\n                . $uri;\n            if (!elFinder::$tmpLinkUrl) {\n                elFinder::$tmpLinkUrl = $this->tmpLinkUrl;\n            }\n        }\n\n        // remove last '/'\n        if ($this->tmpLinkPath) {\n            $this->tmpLinkPath = rtrim($this->tmpLinkPath, '/');\n        }\n        if ($this->tmpLinkUrl) {\n            $this->tmpLinkUrl = rtrim($this->tmpLinkUrl, '/');\n        }\n\n        // to update options cache\n        if (isset($this->sessionCache['rootstat'])) {\n            unset($this->sessionCache['rootstat'][$this->getRootstatCachekey()]);\n        }\n        $this->updateCache($this->root, $root);\n\n        return $this->mounted = true;\n    }\n\n    /**\n     * Some \"unmount\" stuffs - may be required by virtual fs\n     *\n     * @return void\n     * @author Dmitry (dio) Levashov\n     **/\n    public function umount()\n    {\n    }\n\n    /**\n     * Remove session cache of this volume\n     */\n    public function clearSessionCache()\n    {\n        $this->sessionCache = array();\n    }\n\n    /**\n     * Return error message from last failed action\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    public function error()\n    {\n        return $this->error;\n    }\n\n    /**\n     * Return is uploadable that given file name\n     *\n     * @param  string $name file name\n     * @param  bool   $allowUnknown\n     *\n     * @return bool\n     * @author Naoki Sawada\n     **/\n    public function isUploadableByName($name, $allowUnknown = false)\n    {\n        $mimeByName = $this->mimetype($name, true);\n        return (($allowUnknown && $mimeByName === 'unknown') || $this->allowPutMime($mimeByName));\n    }\n\n    /**\n     * Return Extention/MIME Table (elFinderVolumeDriver::$mimetypes)\n     *\n     * @return array\n     * @author Naoki Sawada\n     */\n    public function getMimeTable()\n    {\n        // load mime.types\n        if (!elFinderVolumeDriver::$mimetypesLoaded) {\n            elFinderVolumeDriver::loadMimeTypes();\n        }\n        return elFinderVolumeDriver::$mimetypes;\n    }\n\n    /**\n     * Return file extention detected by MIME type\n     *\n     * @param  string $mime   MIME type\n     * @param  string $suffix Additional suffix\n     *\n     * @return string\n     * @author Naoki Sawada\n     */\n    public function getExtentionByMime($mime, $suffix = '')\n    {\n        static $extTable = null;\n\n        if (is_null($extTable)) {\n            $extTable = array_flip(array_unique($this->getMimeTable()));\n            foreach ($this->options['mimeMap'] as $pair => $_mime) {\n                list($ext) = explode(':', $pair);\n                if ($ext !== '*' && !isset($extTable[$_mime])) {\n                    $extTable[$_mime] = $ext;\n                }\n            }\n        }\n\n        if ($mime && isset($extTable[$mime])) {\n            return $suffix ? ($extTable[$mime] . $suffix) : $extTable[$mime];\n        }\n        return '';\n    }\n\n    /**\n     * Set mimetypes allowed to display to client\n     *\n     * @param  array $mimes\n     *\n     * @return void\n     * @author Dmitry (dio) Levashov\n     **/\n    public function setMimesFilter($mimes)\n    {\n        if (is_array($mimes)) {\n            $this->onlyMimes = $mimes;\n        }\n    }\n\n    /**\n     * Return root folder hash\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    public function root()\n    {\n        return $this->encode($this->root);\n    }\n\n    /**\n     * Return root path\n     *\n     * @return string\n     * @author Naoki Sawada\n     **/\n    public function getRootPath()\n    {\n        return $this->root;\n    }\n\n    /**\n     * Return target path hash\n     *\n     * @param  string $path\n     * @param  string $name\n     *\n     * @author Naoki Sawada\n     * @return string\n     */\n    public function getHash($path, $name = '')\n    {\n        if ($name !== '') {\n            $path = $this->joinPathCE($path, $name);\n        }\n        return $this->encode($path);\n    }\n\n    /**\n     * Return decoded path of target hash\n     * This method do not check the stat of target\n     * Use method `realpath()` to do check of the stat of target\n     *\n     * @param  string $hash\n     *\n     * @author Naoki Sawada\n     * @return string\n     */\n    public function getPath($hash)\n    {\n        return $this->decode($hash);\n    }\n\n    /**\n     * Return root or startPath hash\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    public function defaultPath()\n    {\n        return $this->encode($this->startPath ? $this->startPath : $this->root);\n    }\n\n    /**\n     * Return volume options required by client:\n     *\n     * @param $hash\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     */\n    public function options($hash)\n    {\n        $create = $createext = array();\n        if (isset($this->archivers['create']) && is_array($this->archivers['create'])) {\n            foreach ($this->archivers['create'] as $m => $v) {\n                $create[] = $m;\n                $createext[$m] = $v['ext'];\n            }\n        }\n        $opts = array(\n            'path' => $hash ? $this->path($hash) : '',\n            'url' => $this->URL,\n            'tmbUrl' => (!$this->imgLib && $this->options['tmbFbSelf']) ? 'self' : $this->tmbURL,\n            'disabled' => $this->disabled,\n            'separator' => $this->separator,\n            'copyOverwrite' => intval($this->options['copyOverwrite']),\n            'uploadOverwrite' => intval($this->options['uploadOverwrite']),\n            'uploadMaxSize' => intval($this->uploadMaxSize),\n            'uploadMaxConn' => intval($this->options['uploadMaxConn']),\n            'uploadMime' => array(\n                'firstOrder' => isset($this->uploadOrder[0]) ? $this->uploadOrder[0] : 'deny',\n                'allow' => $this->uploadAllow,\n                'deny' => $this->uploadDeny\n            ),\n            'dispInlineRegex' => $this->options['dispInlineRegex'],\n            'jpgQuality' => intval($this->options['jpgQuality']),\n            'archivers' => array(\n                'create' => $create,\n                'extract' => isset($this->archivers['extract']) && is_array($this->archivers['extract']) ? array_keys($this->archivers['extract']) : array(),\n                'createext' => $createext\n            ),\n            'uiCmdMap' => (isset($this->options['uiCmdMap']) && is_array($this->options['uiCmdMap'])) ? $this->options['uiCmdMap'] : array(),\n            'syncChkAsTs' => intval($this->options['syncChkAsTs']),\n            'syncMinMs' => intval($this->options['syncMinMs']),\n            'i18nFolderName' => intval($this->options['i18nFolderName']),\n            'tmbCrop' => intval($this->options['tmbCrop']),\n            'tmbReqCustomData' => (bool)$this->options['tmbReqCustomData'],\n            'substituteImg' => (bool)$this->options['substituteImg'],\n            'onetimeUrl' => (bool)$this->options['onetimeUrl'],\n        );\n        if (!empty($this->options['trashHash'])) {\n            $opts['trashHash'] = $this->options['trashHash'];\n        }\n        if ($hash === null) {\n            // call from getRootStatExtra()\n            if (!empty($this->options['icon'])) {\n                $opts['icon'] = $this->options['icon'];\n            }\n            if (!empty($this->options['rootCssClass'])) {\n                $opts['csscls'] = $this->options['rootCssClass'];\n            }\n            if (isset($this->options['netkey'])) {\n                $opts['netkey'] = $this->options['netkey'];\n            }\n        }\n        return $opts;\n    }\n\n    /**\n     * Get option value of this volume\n     *\n     * @param string $name target option name\n     *\n     * @return NULL|mixed   target option value\n     * @author Naoki Sawada\n     */\n    public function getOption($name)\n    {\n        return isset($this->options[$name]) ? $this->options[$name] : null;\n    }\n\n    /**\n     * Get plugin values of this options\n     *\n     * @param string $name Plugin name\n     *\n     * @return NULL|array   Plugin values\n     * @author Naoki Sawada\n     */\n    public function getOptionsPlugin($name = '')\n    {\n        if ($name) {\n            return isset($this->options['plugin'][$name]) ? $this->options['plugin'][$name] : array();\n        } else {\n            return $this->options['plugin'];\n        }\n    }\n\n    /**\n     * Return true if command disabled in options\n     *\n     * @param  string $cmd command name\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    public function commandDisabled($cmd)\n    {\n        return in_array($cmd, $this->disabled);\n    }\n\n    /**\n     * Return true if mime is required mimes list\n     *\n     * @param  string    $mime  mime type to check\n     * @param  array     $mimes allowed mime types list or not set to use client mimes list\n     * @param  bool|null $empty what to return on empty list\n     *\n     * @return bool|null\n     * @author Dmitry (dio) Levashov\n     * @author Troex Nevelin\n     **/\n    public function mimeAccepted($mime, $mimes = null, $empty = true)\n    {\n        $mimes = is_array($mimes) ? $mimes : $this->onlyMimes;\n        if (empty($mimes)) {\n            return $empty;\n        }\n        return $mime == 'directory'\n            || in_array('all', $mimes)\n            || in_array('All', $mimes)\n            || in_array($mime, $mimes)\n            || in_array(substr($mime, 0, strpos($mime, '/')), $mimes);\n    }\n\n    /**\n     * Return true if voume is readable.\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    public function isReadable()\n    {\n        $stat = $this->stat($this->root);\n        return $stat['read'];\n    }\n\n    /**\n     * Return true if copy from this volume allowed\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    public function copyFromAllowed()\n    {\n        return !!$this->options['copyFrom'];\n    }\n\n    /**\n     * Return file path related to root with convert encoging\n     *\n     * @param  string $hash file hash\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    public function path($hash)\n    {\n        return $this->convEncOut($this->_path($this->convEncIn($this->decode($hash))));\n    }\n\n    /**\n     * Return file real path if file exists\n     *\n     * @param  string $hash file hash\n     *\n     * @return string | false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function realpath($hash)\n    {\n        $path = $this->decode($hash);\n        return $this->stat($path) ? $path : false;\n    }\n\n    /**\n     * Return list of moved/overwrited files\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    public function removed()\n    {\n        if ($this->removed) {\n            $unsetSubdir = isset($this->sessionCache['subdirs']) ? true : false;\n            foreach ($this->removed as $item) {\n                if ($item['mime'] === 'directory') {\n                    $path = $this->decode($item['hash']);\n                    if ($unsetSubdir) {\n                        unset($this->sessionCache['subdirs'][$path]);\n                    }\n                    if ($item['phash'] !== '') {\n                        $parent = $this->decode($item['phash']);\n                        unset($this->cache[$parent]);\n                        if ($this->root === $parent) {\n                            $this->sessionCache['rootstat'] = array();\n                        }\n                        if ($unsetSubdir) {\n                            unset($this->sessionCache['subdirs'][$parent]);\n                        }\n                    }\n                }\n            }\n            $this->removed = array_values($this->removed);\n        }\n        return $this->removed;\n    }\n\n    /**\n     * Return list of added files\n     *\n     * @deprecated\n     * @return array\n     * @author Naoki Sawada\n     **/\n    public function added()\n    {\n        return $this->added;\n    }\n\n    /**\n     * Clean removed files list\n     *\n     * @return void\n     * @author Dmitry (dio) Levashov\n     **/\n    public function resetRemoved()\n    {\n        $this->resetResultStat();\n    }\n\n    /**\n     * Clean added/removed files list\n     *\n     * @return void\n     **/\n    public function resetResultStat()\n    {\n        $this->removed = array();\n        $this->added = array();\n    }\n\n    /**\n     * Return file/dir hash or first founded child hash with required attr == $val\n     *\n     * @param  string $hash file hash\n     * @param  string $attr attribute name\n     * @param  bool   $val  attribute value\n     *\n     * @return string|false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function closest($hash, $attr, $val)\n    {\n        return ($path = $this->closestByAttr($this->decode($hash), $attr, $val)) ? $this->encode($path) : false;\n    }\n\n    /**\n     * Return file info or false on error\n     *\n     * @param  string $hash file hash\n     *\n     * @return array|false\n     * @internal param bool $realpath add realpath field to file info\n     * @author   Dmitry (dio) Levashov\n     */\n    public function file($hash)\n    {\n        $file = $this->stat($this->decode($hash));\n\n        return ($file) ? $file : $this->setError(elFinder::ERROR_FILE_NOT_FOUND);\n    }\n\n    /**\n     * Return folder info\n     *\n     * @param  string $hash folder hash\n     * @param bool    $resolveLink\n     *\n     * @return array|false\n     * @internal param bool $hidden return hidden file info\n     * @author   Dmitry (dio) Levashov\n     */\n    public function dir($hash, $resolveLink = false)\n    {\n        if (($dir = $this->file($hash)) == false) {\n            return $this->setError(elFinder::ERROR_DIR_NOT_FOUND);\n        }\n\n        if ($resolveLink && !empty($dir['thash'])) {\n            $dir = $this->file($dir['thash']);\n        }\n\n        return $dir && $dir['mime'] == 'directory' && empty($dir['hidden'])\n            ? $dir\n            : $this->setError(elFinder::ERROR_NOT_DIR);\n    }\n\n    /**\n     * Return directory content or false on error\n     *\n     * @param  string $hash file hash\n     *\n     * @return array|false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function scandir($hash)\n    {\n        if (($dir = $this->dir($hash)) == false) {\n            return false;\n        }\n\n        $path = $this->decode($hash);\n        if ($res = $dir['read']\n            ? $this->getScandir($path)\n            : $this->setError(elFinder::ERROR_PERM_DENIED)) {\n\n            $dirs = null;\n            if ($this->sessionCaching['subdirs'] && isset($this->sessionCache['subdirs'][$path])) {\n                $dirs = $this->sessionCache['subdirs'][$path];\n            }\n            if ($dirs !== null || (isset($dir['dirs']) && $dir['dirs'] != 1)) {\n                $_dir = $dir;\n                if ($dirs || $this->subdirs($hash)) {\n                    $dir['dirs'] = 1;\n                } else {\n                    unset($dir['dirs']);\n                }\n                if ($dir !== $_dir) {\n                    $this->updateCache($path, $dir);\n                }\n            }\n        }\n\n        return $res;\n    }\n\n    /**\n     * Return dir files names list\n     *\n     * @param  string $hash file hash\n     * @param null    $intersect\n     *\n     * @return array|false\n     * @author Dmitry (dio) Levashov\n     */\n    public function ls($hash, $intersect = null)\n    {\n        if (($dir = $this->dir($hash)) == false || !$dir['read']) {\n            return false;\n        }\n\n        $list = array();\n        $path = $this->decode($hash);\n\n        $check = array();\n        if ($intersect) {\n            $check = array_flip($intersect);\n        }\n\n        foreach ($this->getScandir($path) as $stat) {\n            if (empty($stat['hidden']) && (!$check || isset($check[$stat['name']])) && $this->mimeAccepted($stat['mime'])) {\n                $list[$stat['hash']] = $stat['name'];\n            }\n        }\n\n        return $list;\n    }\n\n    /**\n     * Return subfolders for required folder or false on error\n     *\n     * @param  string $hash    folder hash or empty string to get tree from root folder\n     * @param  int    $deep    subdir deep\n     * @param  string $exclude dir hash which subfolders must be exluded from result, required to not get stat twice on cwd subfolders\n     *\n     * @return array|false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function tree($hash = '', $deep = 0, $exclude = '')\n    {\n        $path = $hash ? $this->decode($hash) : $this->root;\n\n        if (($dir = $this->stat($path)) == false || $dir['mime'] != 'directory') {\n            return false;\n        }\n\n        $dirs = $this->gettree($path, $deep > 0 ? $deep - 1 : $this->treeDeep - 1, $exclude ? $this->decode($exclude) : null);\n        array_unshift($dirs, $dir);\n        return $dirs;\n    }\n\n    /**\n     * Return part of dirs tree from required dir up to root dir\n     *\n     * @param  string    $hash   directory hash\n     * @param  bool|null $lineal only lineal parents\n     *\n     * @return array|false\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    public function parents($hash, $lineal = false)\n    {\n        if (($current = $this->dir($hash)) == false) {\n            return false;\n        }\n\n        $args = func_get_args();\n        // checks 3rd param `$until` (elFinder >= 2.1.24)\n        $until = '';\n        if (isset($args[2])) {\n            $until = $args[2];\n        }\n\n        $path = $this->decode($hash);\n        $tree = array();\n\n        while ($path && $path != $this->root) {\n            elFinder::checkAborted();\n            $path = $this->dirnameCE($path);\n            if (!($stat = $this->stat($path)) || !empty($stat['hidden']) || !$stat['read']) {\n                return false;\n            }\n\n            array_unshift($tree, $stat);\n            if (!$lineal) {\n                foreach ($this->gettree($path, 0) as $dir) {\n                    elFinder::checkAborted();\n                    if (!isset($tree[$dir['hash']])) {\n                        $tree[$dir['hash']] = $dir;\n                    }\n                }\n            }\n\n            if ($until && $until === $this->encode($path)) {\n                break;\n            }\n        }\n\n        return $tree ? array_values($tree) : array($current);\n    }\n\n    /**\n     * Create thumbnail for required file and return its name or false on failed\n     *\n     * @param $hash\n     *\n     * @return false|string\n     * @throws ImagickException\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    public function tmb($hash)\n    {\n        $path = $this->decode($hash);\n        $stat = $this->stat($path);\n\n        if (isset($stat['tmb'])) {\n            $res = $stat['tmb'] == \"1\" ? $this->createTmb($path, $stat) : $stat['tmb'];\n            if (!$res) {\n                list($type) = explode('/', $stat['mime']);\n                $fallback = $this->options['resourcePath'] . DIRECTORY_SEPARATOR . strtolower($type) . '.png';\n                if (is_file($fallback)) {\n                    $res = $this->tmbname($stat);\n                    if (!copy($fallback, $this->tmbPath . DIRECTORY_SEPARATOR . $res)) {\n                        $res = false;\n                    }\n                }\n            }\n            // tmb garbage collection\n            if ($res && $this->options['tmbGcMaxlifeHour'] && $this->options['tmbGcPercentage'] > 0) {\n                $rand = mt_rand(1, 10000);\n                if ($rand <= $this->options['tmbGcPercentage'] * 100) {\n                    register_shutdown_function(array('elFinder', 'GlobGC'), $this->tmbPath . DIRECTORY_SEPARATOR . '*.png', $this->options['tmbGcMaxlifeHour'] * 3600);\n                }\n            }\n            return $res;\n        }\n        return false;\n    }\n\n    /**\n     * Return file size / total directory size\n     *\n     * @param  string   file hash\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    public function size($hash)\n    {\n        return $this->countSize($this->decode($hash));\n    }\n\n    /**\n     * Open file for reading and return file pointer\n     *\n     * @param  string   file hash\n     *\n     * @return Resource|false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function open($hash)\n    {\n        if (($file = $this->file($hash)) == false\n            || $file['mime'] == 'directory') {\n            return false;\n        }\n        // check extra option for network stream pointer\n        if (func_num_args() > 1) {\n            $opts = func_get_arg(1);\n        } else {\n            $opts = array();\n        }\n        return $this->fopenCE($this->decode($hash), 'rb', $opts);\n    }\n\n    /**\n     * Close file pointer\n     *\n     * @param  Resource $fp   file pointer\n     * @param  string   $hash file hash\n     *\n     * @return void\n     * @author Dmitry (dio) Levashov\n     **/\n    public function close($fp, $hash)\n    {\n        $this->fcloseCE($fp, $this->decode($hash));\n    }\n\n    /**\n     * Create directory and return dir info\n     *\n     * @param  string $dsthash destination directory hash\n     * @param  string $name    directory name\n     *\n     * @return array|false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function mkdir($dsthash, $name)\n    {\n        if ($this->commandDisabled('mkdir')) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        if (!$this->nameAccepted($name, true)) {\n            return $this->setError(elFinder::ERROR_INVALID_DIRNAME);\n        }\n\n        if (($dir = $this->dir($dsthash)) == false) {\n            return $this->setError(elFinder::ERROR_TRGDIR_NOT_FOUND, '#' . $dsthash);\n        }\n\n        $path = $this->decode($dsthash);\n\n        if (!$dir['write'] || !$this->allowCreate($path, $name, true)) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        $dst = $this->joinPathCE($path, $name);\n        $stat = $this->isNameExists($dst);\n        if (!empty($stat)) {\n            return $this->setError(elFinder::ERROR_EXISTS, $name);\n        }\n        $this->clearcache();\n\n        $mkpath = $this->convEncOut($this->_mkdir($this->convEncIn($path), $this->convEncIn($name)));\n        if ($mkpath) {\n            $this->clearstatcache();\n            $this->updateSubdirsCache($path, true);\n            $this->updateSubdirsCache($mkpath, false);\n        }\n\n        return $mkpath ? $this->stat($mkpath) : false;\n    }\n\n    /**\n     * Create empty file and return its info\n     *\n     * @param  string $dst  destination directory\n     * @param  string $name file name\n     *\n     * @return array|false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function mkfile($dst, $name)\n    {\n        if ($this->commandDisabled('mkfile')) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        if (!$this->nameAccepted($name, false)) {\n            return $this->setError(elFinder::ERROR_INVALID_NAME);\n        }\n\n        $mimeByName = $this->mimetype($name, true);\n        if ($mimeByName && !$this->allowPutMime($mimeByName)) {\n            return $this->setError(elFinder::ERROR_UPLOAD_FILE_MIME, $name);\n        }\n\n        if (($dir = $this->dir($dst)) == false) {\n            return $this->setError(elFinder::ERROR_TRGDIR_NOT_FOUND, '#' . $dst);\n        }\n\n        $path = $this->decode($dst);\n\n        if (!$dir['write'] || !$this->allowCreate($path, $name, false)) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        if ($this->isNameExists($this->joinPathCE($path, $name))) {\n            return $this->setError(elFinder::ERROR_EXISTS, $name);\n        }\n\n        $this->clearcache();\n        $res = false;\n        if ($path = $this->convEncOut($this->_mkfile($this->convEncIn($path), $this->convEncIn($name)))) {\n            $this->clearstatcache();\n            $res = $this->stat($path);\n        }\n        return $res;\n    }\n\n    /**\n     * Rename file and return file info\n     *\n     * @param  string $hash file hash\n     * @param  string $name new file name\n     *\n     * @return array|false\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    public function rename($hash, $name)\n    {\n        if ($this->commandDisabled('rename')) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        if (!($file = $this->file($hash))) {\n            return $this->setError(elFinder::ERROR_FILE_NOT_FOUND);\n        }\n\n        if ($name === $file['name']) {\n            return $file;\n        }\n\n        if (!empty($this->options['netkey']) && !empty($file['isroot'])) {\n            // change alias of netmount root\n            $rootKey = $this->getRootstatCachekey();\n            // delete old cache data\n            if ($this->sessionCaching['rootstat']) {\n                unset($this->sessionCaching['rootstat'][$rootKey]);\n            }\n            if (elFinder::$instance->updateNetVolumeOption($this->options['netkey'], 'alias', $name)) {\n                $this->clearcache();\n                $this->rootName = $this->options['alias'] = $name;\n                return $this->stat($this->root);\n            } else {\n                return $this->setError(elFinder::ERROR_TRGDIR_NOT_FOUND, $name);\n            }\n        }\n\n        if (!empty($file['locked'])) {\n            return $this->setError(elFinder::ERROR_LOCKED, $file['name']);\n        }\n\n        $isDir = ($file['mime'] === 'directory');\n\n        if (!$this->nameAccepted($name, $isDir)) {\n            return $this->setError($isDir ? elFinder::ERROR_INVALID_DIRNAME : elFinder::ERROR_INVALID_NAME);\n        }\n\n        if (!$isDir) {\n            $mimeByName = $this->mimetype($name, true);\n            if ($mimeByName && !$this->allowPutMime($mimeByName)) {\n                return $this->setError(elFinder::ERROR_UPLOAD_FILE_MIME, $name);\n            }\n        }\n\n        $path = $this->decode($hash);\n        $dir = $this->dirnameCE($path);\n        $stat = $this->isNameExists($this->joinPathCE($dir, $name));\n        if ($stat) {\n            return $this->setError(elFinder::ERROR_EXISTS, $name);\n        }\n\n        if (!$this->allowCreate($dir, $name, ($file['mime'] === 'directory'))) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        $this->rmTmb($file); // remove old name tmbs, we cannot do this after dir move\n\n\n        if ($path = $this->convEncOut($this->_move($this->convEncIn($path), $this->convEncIn($dir), $this->convEncIn($name)))) {\n            $this->clearcache();\n            return $this->stat($path);\n        }\n        return false;\n    }\n\n    /**\n     * Create file copy with suffix \"copy number\" and return its info\n     *\n     * @param  string $hash   file hash\n     * @param  string $suffix suffix to add to file name\n     *\n     * @return array|false\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    public function duplicate($hash, $suffix = 'copy')\n    {\n        if ($this->commandDisabled('duplicate')) {\n            return $this->setError(elFinder::ERROR_COPY, '#' . $hash, elFinder::ERROR_PERM_DENIED);\n        }\n\n        if (($file = $this->file($hash)) == false) {\n            return $this->setError(elFinder::ERROR_COPY, elFinder::ERROR_FILE_NOT_FOUND);\n        }\n\n        $path = $this->decode($hash);\n        $dir = $this->dirnameCE($path);\n        $name = $this->uniqueName($dir, $file['name'], sprintf($this->options['duplicateSuffix'], $suffix));\n\n        if (!$this->allowCreate($dir, $name, ($file['mime'] === 'directory'))) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        return ($path = $this->copy($path, $dir, $name)) == false\n            ? false\n            : $this->stat($path);\n    }\n\n    /**\n     * Save uploaded file.\n     * On success return array with new file stat and with removed file hash (if existed file was replaced)\n     *\n     * @param  Resource $fp      file pointer\n     * @param  string   $dst     destination folder hash\n     * @param           $name\n     * @param  string   $tmpname file tmp name - required to detect mime type\n     * @param  array    $hashes  exists files hash array with filename as key\n     *\n     * @return array|false\n     * @throws elFinderAbortException\n     * @internal param string $src file name\n     * @author   Dmitry (dio) Levashov\n     */\n    public function upload($fp, $dst, $name, $tmpname, $hashes = array())\n    {\n        if ($this->commandDisabled('upload')) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        if (($dir = $this->dir($dst)) == false) {\n            return $this->setError(elFinder::ERROR_TRGDIR_NOT_FOUND, '#' . $dst);\n        }\n\n        if (empty($dir['write'])) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        if (!$this->nameAccepted($name, false)) {\n            return $this->setError(elFinder::ERROR_INVALID_NAME);\n        }\n\n        $mimeByName = '';\n        if ($this->mimeDetect === 'internal') {\n            $mime = $this->mimetype($tmpname, $name);\n        } else {\n            $mime = $this->mimetype($tmpname, $name);\n            $mimeByName = $this->mimetype($name, true);\n            if ($mime === 'unknown') {\n                $mime = $mimeByName;\n            }\n        }\n\n        if (!$this->allowPutMime($mime) || ($mimeByName && !$this->allowPutMime($mimeByName))) {\n            return $this->setError(elFinder::ERROR_UPLOAD_FILE_MIME, '(' . $mime . ')');\n        }\n\n        $tmpsize = (int)sprintf('%u', filesize($tmpname));\n        if ($this->uploadMaxSize > 0 && $tmpsize > $this->uploadMaxSize) {\n            return $this->setError(elFinder::ERROR_UPLOAD_FILE_SIZE);\n        }\n\n        $dstpath = $this->decode($dst);\n        if (isset($hashes[$name])) {\n            $test = $this->decode($hashes[$name]);\n            $file = $this->stat($test);\n        } else {\n            $test = $this->joinPathCE($dstpath, $name);\n            $file = $this->isNameExists($test);\n        }\n\n        $this->clearcache();\n\n        if ($file && $file['name'] === $name) { // file exists and check filename for item ID based filesystem\n            if ($this->uploadOverwrite) {\n                if (!$file['write']) {\n                    return $this->setError(elFinder::ERROR_PERM_DENIED);\n                } elseif ($file['mime'] == 'directory') {\n                    return $this->setError(elFinder::ERROR_NOT_REPLACE, $name);\n                }\n                $this->remove($test);\n            } else {\n                $name = $this->uniqueName($dstpath, $name, '-', false);\n            }\n        }\n\n        $stat = array(\n            'mime' => $mime,\n            'width' => 0,\n            'height' => 0,\n            'size' => $tmpsize);\n\n        // $w = $h = 0;\n        if (strpos($mime, 'image') === 0 && ($s = getimagesize($tmpname))) {\n            $stat['width'] = $s[0];\n            $stat['height'] = $s[1];\n        }\n        // $this->clearcache();\n        if (($path = $this->saveCE($fp, $dstpath, $name, $stat)) == false) {\n            return false;\n        }\n\n        $stat = $this->stat($path);\n        // Try get URL\n        if (empty($stat['url']) && ($url = $this->getContentUrl($stat['hash']))) {\n            $stat['url'] = $url;\n        }\n\n        return $stat;\n    }\n\n    /**\n     * Paste files\n     *\n     * @param  Object $volume source volume\n     * @param         $src\n     * @param  string $dst    destination dir hash\n     * @param  bool   $rmSrc  remove source after copy?\n     * @param array   $hashes\n     *\n     * @return array|false\n     * @throws elFinderAbortException\n     * @internal param string $source file hash\n     * @author   Dmitry (dio) Levashov\n     */\n    public function paste($volume, $src, $dst, $rmSrc = false, $hashes = array())\n    {\n        $err = $rmSrc ? elFinder::ERROR_MOVE : elFinder::ERROR_COPY;\n\n        if ($this->commandDisabled('paste')) {\n            return $this->setError($err, '#' . $src, elFinder::ERROR_PERM_DENIED);\n        }\n\n        if (($file = $volume->file($src, $rmSrc)) == false) {\n            return $this->setError($err, '#' . $src, elFinder::ERROR_FILE_NOT_FOUND);\n        }\n\n        $name = $file['name'];\n        $errpath = $volume->path($file['hash']);\n\n        if (($dir = $this->dir($dst)) == false) {\n            return $this->setError($err, $errpath, elFinder::ERROR_TRGDIR_NOT_FOUND, '#' . $dst);\n        }\n\n        if (!$dir['write'] || !$file['read']) {\n            return $this->setError($err, $errpath, elFinder::ERROR_PERM_DENIED);\n        }\n\n        $destination = $this->decode($dst);\n\n        if (($test = $volume->closest($src, $rmSrc ? 'locked' : 'read', $rmSrc))) {\n            return $rmSrc\n                ? $this->setError($err, $errpath, elFinder::ERROR_LOCKED, $volume->path($test))\n                : $this->setError($err, $errpath, empty($file['thash']) ? elFinder::ERROR_PERM_DENIED : elFinder::ERROR_MKOUTLINK);\n        }\n\n        if (isset($hashes[$name])) {\n            $test = $this->decode($hashes[$name]);\n            $stat = $this->stat($test);\n        } else {\n            $test = $this->joinPathCE($destination, $name);\n            $stat = $this->isNameExists($test);\n        }\n        $this->clearcache();\n        $dstDirExists = false;\n        if ($stat && $stat['name'] === $name) { // file exists and check filename for item ID based filesystem\n            if ($this->options['copyOverwrite']) {\n                // do not replace file with dir or dir with file\n                if (!$this->isSameType($file['mime'], $stat['mime'])) {\n                    return $this->setError(elFinder::ERROR_NOT_REPLACE, $this->path($stat['hash']));\n                }\n                // existed file is not writable\n                if (empty($stat['write'])) {\n                    return $this->setError($err, $errpath, elFinder::ERROR_PERM_DENIED);\n                }\n                if ($this->options['copyJoin']) {\n                    if (!empty($stat['locked'])) {\n                        return $this->setError(elFinder::ERROR_LOCKED, $this->path($stat['hash']));\n                    }\n                } else {\n                    // existed file locked or has locked child\n                    if (($locked = $this->closestByAttr($test, 'locked', true))) {\n                        $stat = $this->stat($locked);\n                        return $this->setError(elFinder::ERROR_LOCKED, $this->path($stat['hash']));\n                    }\n                }\n                // target is entity file of alias\n                if ($volume === $this && ((isset($file['target']) && $test == $file['target']) || $test == $this->decode($src))) {\n                    return $this->setError(elFinder::ERROR_REPLACE, $errpath);\n                }\n                // remove existed file\n                if (!$this->options['copyJoin'] || $stat['mime'] !== 'directory') {\n                    if (!$this->remove($test)) {\n                        return $this->setError(elFinder::ERROR_REPLACE, $this->path($stat['hash']));\n                    }\n                } else if ($stat['mime'] === 'directory') {\n                    $dstDirExists = true;\n                }\n            } else {\n                $name = $this->uniqueName($destination, $name, ' ', false);\n            }\n        }\n\n        // copy/move inside current volume\n        if ($volume === $this) { //  changing == operand to === fixes issue #1285 - Paul Canning 24/03/2016\n            $source = $this->decode($src);\n            // do not copy into itself\n            if ($this->inpathCE($destination, $source)) {\n                return $this->setError(elFinder::ERROR_COPY_ITSELF, $errpath);\n            }\n            $rmDir = false;\n            if ($rmSrc) {\n                if ($dstDirExists) {\n                    $rmDir = true;\n                    $method = 'copy';\n                } else {\n                    $method = 'move';\n                }\n            } else {\n                $method = 'copy';\n            }\n            $this->clearcache();\n            if ($res = ($path = $this->$method($source, $destination, $name)) ? $this->stat($path) : false) {\n                if ($rmDir) {\n                    $this->remove($source);\n                }\n            } else {\n                return false;\n            }\n        } else {\n            // copy/move from another volume\n            if (!$this->options['copyTo'] || !$volume->copyFromAllowed()) {\n                return $this->setError(elFinder::ERROR_COPY, $errpath, elFinder::ERROR_PERM_DENIED);\n            }\n\n            $this->error = array();\n            if (($path = $this->copyFrom($volume, $src, $destination, $name)) == false) {\n                return false;\n            }\n\n            if ($rmSrc && !$this->error()) {\n                if (!$volume->rm($src)) {\n                    if ($volume->file($src)) {\n                        $this->addError(elFinder::ERROR_RM_SRC);\n                    } else {\n                        $this->removed[] = $file;\n                    }\n                }\n            }\n            $res = $this->stat($path);\n        }\n        return $res;\n    }\n\n    /**\n     * Return path info array to archive of target items\n     *\n     * @param  array $hashes\n     *\n     * @return array|false\n     * @throws Exception\n     * @author Naoki Sawada\n     */\n    public function zipdl($hashes)\n    {\n        if ($this->commandDisabled('zipdl')) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        $archivers = $this->getArchivers();\n        $cmd = null;\n        if (!$archivers || empty($archivers['create'])) {\n            return false;\n        }\n        $archivers = $archivers['create'];\n        if (!$archivers) {\n            return false;\n        }\n        $file = $mime = '';\n        foreach (array('zip', 'tgz') as $ext) {\n            $mime = $this->mimetype('file.' . $ext, true);\n            if (isset($archivers[$mime])) {\n                $cmd = $archivers[$mime];\n                break;\n            }\n        }\n        if (!$cmd) {\n            $cmd = array_shift($archivers);\n            if (!empty($ext)) {\n                $mime = $this->mimetype('file.' . $ext, true);\n            }\n        }\n        $ext = $cmd['ext'];\n        $res = false;\n        $mixed = false;\n        $hashes = array_values($hashes);\n        $dirname = dirname(str_replace($this->separator, DIRECTORY_SEPARATOR, $this->path($hashes[0])));\n        $cnt = count($hashes);\n        if ($cnt > 1) {\n            for ($i = 1; $i < $cnt; $i++) {\n                if ($dirname !== dirname(str_replace($this->separator, DIRECTORY_SEPARATOR, $this->path($hashes[$i])))) {\n                    $mixed = true;\n                    break;\n                }\n            }\n        }\n        if ($mixed || $this->root == $this->dirnameCE($this->decode($hashes[0]))) {\n            $prefix = $this->rootName;\n        } else {\n            $prefix = basename($dirname);\n        }\n        if ($dir = $this->getItemsInHand($hashes)) {\n            $tmppre = (substr(PHP_OS, 0, 3) === 'WIN') ? 'zd-' : 'elfzdl-';\n            $pdir = dirname($dir);\n            // garbage collection (expire 2h)\n            register_shutdown_function(array('elFinder', 'GlobGC'), $pdir . DIRECTORY_SEPARATOR . $tmppre . '*', 7200);\n            $files = self::localScandir($dir);\n            if ($files && ($arc = tempnam($dir, $tmppre))) {\n                unlink($arc);\n                $arc = $arc . '.' . $ext;\n                $name = basename($arc);\n                if ($arc = $this->makeArchive($dir, $files, $name, $cmd)) {\n                    $file = tempnam($pdir, $tmppre);\n                    unlink($file);\n                    $res = rename($arc, $file);\n                    $this->rmdirRecursive($dir);\n                }\n            }\n        }\n        return $res ? array('path' => $file, 'ext' => $ext, 'mime' => $mime, 'prefix' => $prefix) : false;\n    }\n\n    /**\n     * Return file contents\n     *\n     * @param  string $hash file hash\n     *\n     * @return string|false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function getContents($hash)\n    {\n        $file = $this->file($hash);\n\n        if (!$file) {\n            return $this->setError(elFinder::ERROR_FILE_NOT_FOUND);\n        }\n\n        if ($file['mime'] == 'directory') {\n            return $this->setError(elFinder::ERROR_NOT_FILE);\n        }\n\n        if (!$file['read']) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        if ($this->getMaxSize > 0 && $file['size'] > $this->getMaxSize) {\n            return $this->setError(elFinder::ERROR_UPLOAD_FILE_SIZE);\n        }\n\n        return $file['size'] ? $this->_getContents($this->convEncIn($this->decode($hash), true)) : '';\n    }\n\n    /**\n     * Put content in text file and return file info.\n     *\n     * @param  string $hash    file hash\n     * @param  string $content new file content\n     *\n     * @return array|false\n     * @author Dmitry (dio) Levashov\n     **/\n    public function putContents($hash, $content)\n    {\n        if ($this->commandDisabled('edit')) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        $path = $this->decode($hash);\n\n        if (!($file = $this->file($hash))) {\n            return $this->setError(elFinder::ERROR_FILE_NOT_FOUND);\n        }\n\n        if (!$file['write']) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        // check data cheme\n        if (preg_match('~^\\0data:(.+?/.+?);base64,~', $content, $m)) {\n            $dMime = $m[1];\n            if ($file['size'] > 0 && $dMime !== $file['mime']) {\n                return $this->setError(elFinder::ERROR_PERM_DENIED);\n            }\n            $content = base64_decode(substr($content, strlen($m[0])));\n        }\n\n        // check MIME\n        $name = $this->basenameCE($path);\n        $mime = '';\n        $mimeByName = $this->mimetype($name, true);\n        if ($this->mimeDetect !== 'internal') {\n            if ($tp = $this->tmpfile()) {\n                fwrite($tp, $content);\n                $info = stream_get_meta_data($tp);\n                $filepath = $info['uri'];\n                $mime = $this->mimetype($filepath, $name);\n                fclose($tp);\n            }\n        }\n        if (!$this->allowPutMime($mimeByName) || ($mime && !$this->allowPutMime($mime))) {\n            return $this->setError(elFinder::ERROR_UPLOAD_FILE_MIME);\n        }\n\n        $this->clearcache();\n        $res = false;\n        if ($this->convEncOut($this->_filePutContents($this->convEncIn($path), $content))) {\n            $this->rmTmb($file);\n            $this->clearstatcache();\n            $res = $this->stat($path);\n        }\n        return $res;\n    }\n\n    /**\n     * Extract files from archive\n     *\n     * @param  string $hash archive hash\n     * @param null    $makedir\n     *\n     * @return array|bool\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     */\n    public function extract($hash, $makedir = null)\n    {\n        if ($this->commandDisabled('extract')) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        if (($file = $this->file($hash)) == false) {\n            return $this->setError(elFinder::ERROR_FILE_NOT_FOUND);\n        }\n\n        $archiver = isset($this->archivers['extract'][$file['mime']])\n            ? $this->archivers['extract'][$file['mime']]\n            : array();\n\n        if (!$archiver) {\n            return $this->setError(elFinder::ERROR_NOT_ARCHIVE);\n        }\n\n        $path = $this->decode($hash);\n        $parent = $this->stat($this->dirnameCE($path));\n\n        if (!$file['read'] || !$parent['write']) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n        $this->clearcache();\n        $this->extractToNewdir = is_null($makedir) ? 'auto' : (bool)$makedir;\n\n        if ($path = $this->convEncOut($this->_extract($this->convEncIn($path), $archiver))) {\n            if (is_array($path)) {\n                foreach ($path as $_k => $_p) {\n                    $path[$_k] = $this->stat($_p);\n                }\n            } else {\n                $path = $this->stat($path);\n            }\n            return $path;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Add files to archive\n     *\n     * @param        $hashes\n     * @param        $mime\n     * @param string $name\n     *\n     * @return array|bool\n     * @throws Exception\n     */\n    public function archive($hashes, $mime, $name = '')\n    {\n        if ($this->commandDisabled('archive')) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        if ($name !== '' && !$this->nameAccepted($name, false)) {\n            return $this->setError(elFinder::ERROR_INVALID_NAME);\n        }\n\n        $archiver = isset($this->archivers['create'][$mime])\n            ? $this->archivers['create'][$mime]\n            : array();\n\n        if (!$archiver) {\n            return $this->setError(elFinder::ERROR_ARCHIVE_TYPE);\n        }\n\n        $files = array();\n        $useRemoteArchive = !empty($this->options['useRemoteArchive']);\n\n        $dir = '';\n        foreach ($hashes as $hash) {\n            if (($file = $this->file($hash)) == false) {\n                return $this->setError(elFinder::ERROR_FILE_NOT_FOUND, '#' . $hash);\n            }\n            if (!$file['read']) {\n                return $this->setError(elFinder::ERROR_PERM_DENIED);\n            }\n            $path = $this->decode($hash);\n            if ($dir === '') {\n                $dir = $this->dirnameCE($path);\n                $stat = $this->stat($dir);\n                if (!$stat['write']) {\n                    return $this->setError(elFinder::ERROR_PERM_DENIED);\n                }\n            }\n\n            $files[] = $useRemoteArchive ? $hash : $this->basenameCE($path);\n        }\n\n        if ($name === '') {\n            $name = count($files) == 1 ? $files[0] : 'Archive';\n        } else {\n            $name = str_replace(array('/', '\\\\'), '_', preg_replace('/\\.' . preg_quote($archiver['ext'], '/') . '$/i', '', $name));\n        }\n        $name .= '.' . $archiver['ext'];\n        $name = $this->uniqueName($dir, $name, '');\n        $this->clearcache();\n        if ($useRemoteArchive) {\n            return ($path = $this->remoteArchive($files, $name, $archiver)) ? $this->stat($path) : false;\n        } else {\n            return ($path = $this->convEncOut($this->_archive($this->convEncIn($dir), $this->convEncIn($files), $this->convEncIn($name), $archiver))) ? $this->stat($path) : false;\n        }\n    }\n\n    /**\n     * Create an archive from remote items\n     *\n     * @param      array  $hashes files hashes list\n     * @param      string $name   archive name\n     * @param      array  $arc    archiver options\n     *\n     * @return     string|boolean  path of created archive\n     * @throws     Exception\n     */\n    protected function remoteArchive($hashes, $name, $arc)\n    {\n        $resPath = false;\n        $file0 = $this->file($hashes[0]);\n        if ($file0 && ($dir = $this->getItemsInHand($hashes))) {\n            $files = self::localScandir($dir);\n            if ($files) {\n                if ($arc = $this->makeArchive($dir, $files, $name, $arc)) {\n                    if ($fp = fopen($arc, 'rb')) {\n                        $fstat = stat($arc);\n                        $stat = array(\n                            'size' => $fstat['size'],\n                            'ts' => $fstat['mtime'],\n                            'mime' => $this->mimetype($arc, $name)\n                        );\n                        $path = $this->decode($file0['phash']);\n                        $resPath = $this->saveCE($fp, $path, $name, $stat);\n                        fclose($fp);\n                    }\n                }\n            }\n            $this->rmdirRecursive($dir);\n        }\n        return $resPath;\n    }\n\n    /**\n     * Resize image\n     *\n     * @param  string $hash       image file\n     * @param  int    $width      new width\n     * @param  int    $height     new height\n     * @param  int    $x          X start poistion for crop\n     * @param  int    $y          Y start poistion for crop\n     * @param  string $mode       action how to mainpulate image\n     * @param  string $bg         background color\n     * @param  int    $degree     rotete degree\n     * @param  int    $jpgQuality JEPG quality (1-100)\n     *\n     * @return array|false\n     * @throws ImagickException\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     * @author Alexey Sukhotin\n     * @author nao-pon\n     * @author Troex Nevelin\n     */\n    public function resize($hash, $width, $height, $x, $y, $mode = 'resize', $bg = '', $degree = 0, $jpgQuality = null)\n    {\n        if ($this->commandDisabled('resize')) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        if ($mode === 'rotate' && $degree == 0) {\n            return array('losslessRotate' => ($this->procExec(ELFINDER_EXIFTRAN_PATH . ' -h') === 0 || $this->procExec(ELFINDER_JPEGTRAN_PATH . ' -version') === 0));\n        }\n\n        if (($file = $this->file($hash)) == false) {\n            return $this->setError(elFinder::ERROR_FILE_NOT_FOUND);\n        }\n\n        if (!$file['write'] || !$file['read']) {\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        $path = $this->decode($hash);\n\n        $work_path = $this->getWorkFile($this->encoding ? $this->convEncIn($path, true) : $path);\n\n        if (!$work_path || !is_writable($work_path)) {\n            if ($work_path && $path !== $work_path && is_file($work_path)) {\n                unlink($work_path);\n            }\n            return $this->setError(elFinder::ERROR_PERM_DENIED);\n        }\n\n        if ($this->imgLib !== 'imagick' && $this->imgLib !== 'convert') {\n            if (elFinder::isAnimationGif($work_path)) {\n                return $this->setError(elFinder::ERROR_UNSUPPORT_TYPE);\n            }\n        }\n\n        if (elFinder::isAnimationPng($work_path)) {\n            return $this->setError(elFinder::ERROR_UNSUPPORT_TYPE);\n        }\n\n        switch ($mode) {\n\n            case 'propresize':\n                $result = $this->imgResize($work_path, $width, $height, true, true, null, $jpgQuality);\n                break;\n\n            case 'crop':\n                $result = $this->imgCrop($work_path, $width, $height, $x, $y, null, $jpgQuality);\n                break;\n\n            case 'fitsquare':\n                $result = $this->imgSquareFit($work_path, $width, $height, 'center', 'middle', ($bg ? $bg : $this->options['tmbBgColor']), null, $jpgQuality);\n                break;\n\n            case 'rotate':\n                $result = $this->imgRotate($work_path, $degree, ($bg ? $bg : $this->options['bgColorFb']), null, $jpgQuality);\n                break;\n\n            default:\n                $result = $this->imgResize($work_path, $width, $height, false, true, null, $jpgQuality);\n                break;\n        }\n\n        $ret = false;\n        if ($result) {\n            $this->rmTmb($file);\n            $this->clearstatcache();\n            $fstat = stat($work_path);\n            $imgsize = getimagesize($work_path);\n            if ($path !== $work_path) {\n                $file['size'] = $fstat['size'];\n                $file['ts'] = $fstat['mtime'];\n                if ($imgsize) {\n                    $file['width'] = $imgsize[0];\n                    $file['height'] = $imgsize[1];\n                }\n                if ($fp = fopen($work_path, 'rb')) {\n                    $ret = $this->saveCE($fp, $this->dirnameCE($path), $this->basenameCE($path), $file);\n                    fclose($fp);\n                }\n            } else {\n                $ret = true;\n            }\n            if ($ret) {\n                $this->clearcache();\n                $ret = $this->stat($path);\n                if ($imgsize) {\n                    $ret['width'] = $imgsize[0];\n                    $ret['height'] = $imgsize[1];\n                }\n            }\n        }\n        if ($path !== $work_path) {\n            is_file($work_path) && unlink($work_path);\n        }\n\n        return $ret;\n    }\n\n    /**\n     * Remove file/dir\n     *\n     * @param  string $hash file hash\n     *\n     * @return bool\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    public function rm($hash)\n    {\n        return $this->commandDisabled('rm')\n            ? $this->setError(elFinder::ERROR_PERM_DENIED)\n            : $this->remove($this->decode($hash));\n    }\n\n    /**\n     * Search files\n     *\n     * @param  string $q search string\n     * @param  array  $mimes\n     * @param null    $hash\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    public function search($q, $mimes, $hash = null)\n    {\n        $res = array();\n        $matchMethod = null;\n        $args = func_get_args();\n        if (!empty($args[3])) {\n            $matchMethod = 'searchMatch' . $args[3];\n            if (!is_callable(array($this, $matchMethod))) {\n                return array();\n            }\n        }\n\n        $dir = null;\n        if ($hash) {\n            $dir = $this->decode($hash);\n            $stat = $this->stat($dir);\n            if (!$stat || $stat['mime'] !== 'directory' || !$stat['read']) {\n                $q = '';\n            }\n        }\n        if ($mimes && $this->onlyMimes) {\n            $mimes = array_intersect($mimes, $this->onlyMimes);\n            if (!$mimes) {\n                $q = '';\n            }\n        }\n        $this->searchStart = time();\n\n        $qs = preg_split('/\"([^\"]+)\"| +/', $q, -1, PREG_SPLIT_NO_EMPTY | PREG_SPLIT_DELIM_CAPTURE);\n        $query = $excludes = array();\n        foreach ($qs as $_q) {\n            $_q = trim($_q);\n            if ($_q !== '') {\n                if ($_q[0] === '-') {\n                    if (isset($_q[1])) {\n                        $excludes[] = substr($_q, 1);\n                    }\n                } else {\n                    $query[] = $_q;\n                }\n            }\n        }\n        if (!$query) {\n            $q = '';\n        } else {\n            $q = join(' ', $query);\n            $this->doSearchCurrentQuery = array(\n                'q' => $q,\n                'excludes' => $excludes,\n                'matchMethod' => $matchMethod\n            );\n        }\n\n        if ($q === '' || $this->commandDisabled('search')) {\n            return $res;\n        }\n\n        // valided regex $this->options['searchExDirReg']\n        if ($this->options['searchExDirReg']) {\n            if (false === preg_match($this->options['searchExDirReg'], '')) {\n                $this->options['searchExDirReg'] = '';\n            }\n        }\n\n        // check the leaf root too\n        if (!$mimes && (is_null($dir) || $dir == $this->root)) {\n            $rootStat = $this->stat($this->root);\n            if (!empty($rootStat['phash'])) {\n                if ($this->stripos($rootStat['name'], $q) !== false) {\n                    $res = array($rootStat);\n                }\n            }\n        }\n\n        return array_merge($res, $this->doSearch(is_null($dir) ? $this->root : $dir, $q, $mimes));\n    }\n\n    /**\n     * Return image dimensions\n     *\n     * @param  string $hash file hash\n     *\n     * @return array|string\n     * @author Dmitry (dio) Levashov\n     **/\n    public function dimensions($hash)\n    {\n        if (($file = $this->file($hash)) == false) {\n            return false;\n        }\n        // Throw additional parameters for some drivers\n        if (func_num_args() > 1) {\n            $args = func_get_arg(1);\n        } else {\n            $args = array();\n        }\n        return $this->convEncOut($this->_dimensions($this->convEncIn($this->decode($hash)), $file['mime'], $args));\n    }\n\n    /**\n     * Return has subdirs\n     *\n     * @param  string $hash file hash\n     *\n     * @return bool\n     * @author Naoki Sawada\n     **/\n    public function subdirs($hash)\n    {\n        return (bool)$this->subdirsCE($this->decode($hash));\n    }\n\n    /**\n     * Return content URL (for netmout volume driver)\n     * If file.url == 1 requests from JavaScript client with XHR\n     *\n     * @param string $hash    file hash\n     * @param array  $options options array\n     *\n     * @return boolean|string\n     * @author Naoki Sawada\n     */\n    public function getContentUrl($hash, $options = array())\n    {\n        if (($file = $this->file($hash)) === false) {\n            return false;\n        }\n        if (!empty($options['onetime']) && $this->options['onetimeUrl']) {\n            if (is_callable($this->options['onetimeUrl'])) {\n                return call_user_func_array($this->options['onetimeUrl'], array($file, $options, $this));\n            } else {\n                $ret = false;\n                if ($tmpdir = elFinder::getStaticVar('commonTempPath')) {\n                    if ($source = $this->open($hash)) {\n                        if ($_dat = tempnam($tmpdir, 'ELF')) {\n                            $token = md5($_dat . session_id());\n                            $dat = $tmpdir . DIRECTORY_SEPARATOR . 'ELF' . $token;\n                            if (rename($_dat, $dat)) {\n                                $info = stream_get_meta_data($source);\n                                if (!empty($info['uri'])) {\n                                    $tmp = $info['uri'];\n                                } else {\n                                    $tmp = tempnam($tmpdir, 'ELF');\n                                    if ($dest = fopen($tmp, 'wb')) {\n                                        if (!stream_copy_to_stream($source, $dest)) {\n                                            $tmp = false;\n                                        }\n                                        fclose($dest);\n                                    }\n                                }\n                                $this->close($source, $hash);\n                                if ($tmp) {\n                                    $info = array(\n                                        'file' => base64_encode($tmp),\n                                        'name' => $file['name'],\n                                        'mime' => $file['mime'],\n                                        'ts' => $file['ts']\n                                    );\n                                    if (file_put_contents($dat, json_encode($info))) {\n                                        $conUrl = elFinder::getConnectorUrl();\n                                        $ret = $conUrl . (strpos($conUrl, '?') !== false? '&' : '?') . 'cmd=file&onetime=1&target=' . $token;\n\n                                    }\n                                }\n                                if (!$ret) {\n                                    unlink($dat);\n                                }\n                            } else {\n                                unlink($_dat);\n                            }\n                        }\n                    }\n                }\n                return $ret;\n            }\n        }\n        if (empty($file['url']) && $this->URL) {\n            $path = str_replace($this->separator, '/', substr($this->decode($hash), strlen(rtrim($this->root, '/' . $this->separator)) + 1));\n            if ($this->encoding) {\n                $path = $this->convEncIn($path, true);\n            }\n            $path = str_replace('%2F', '/', rawurlencode($path));\n            return $this->URL . $path;\n        } else {\n            $ret = false;\n            if (!empty($file['url']) && $file['url'] != 1) {\n                return $file['url'];\n            } else if (!empty($options['temporary']) && ($tempInfo = $this->getTempLinkInfo('temp_' . md5($hash . session_id())))) {\n                if (is_readable($tempInfo['path'])) {\n                    touch($tempInfo['path']);\n                    $ret = $tempInfo['url'] . '?' . rawurlencode($file['name']);\n                } else if ($source = $this->open($hash)) {\n                    if ($dest = fopen($tempInfo['path'], 'wb')) {\n                        if (stream_copy_to_stream($source, $dest)) {\n                            $ret = $tempInfo['url'] . '?' . rawurlencode($file['name']);\n                        }\n                        fclose($dest);\n                    }\n                    $this->close($source, $hash);\n                }\n            }\n            return $ret;\n        }\n    }\n\n    /**\n     * Get temporary contents link infomation\n     *\n     * @param string $name\n     *\n     * @return boolean|array\n     * @author Naoki Sawada\n     */\n    public function getTempLinkInfo($name = null)\n    {\n        if ($this->tmpLinkPath) {\n            if (!$name) {\n                $name = 'temp_' . md5($_SERVER['REMOTE_ADDR'] . (string)microtime(true));\n            } else if (substr($name, 0, 5) !== 'temp_') {\n                $name = 'temp_' . $name;\n            }\n            register_shutdown_function(array('elFinder', 'GlobGC'), $this->tmpLinkPath . DIRECTORY_SEPARATOR . 'temp_*', elFinder::$tmpLinkLifeTime);\n            return array(\n                'path' => $path = $this->tmpLinkPath . DIRECTORY_SEPARATOR . $name,\n                'url' => $this->tmpLinkUrl . '/' . rawurlencode($name)\n            );\n        }\n        return false;\n    }\n\n    /**\n     * Get URL of substitute image by request args `substitute` or 4th argument $maxSize\n     *\n     * @param string   $target  Target hash\n     * @param array    $srcSize Size info array [width, height]\n     * @param resource $srcfp   Source file file pointer\n     * @param integer  $maxSize Maximum pixel of substitute image\n     *\n     * @return boolean\n     * @throws ImagickException\n     * @throws elFinderAbortException\n     */\n    public function getSubstituteImgLink($target, $srcSize, $srcfp = null, $maxSize = null)\n    {\n        $url = false;\n        $file = $this->file($target);\n        $force = !in_array($file['mime'], array('image/jpeg', 'image/png', 'image/gif'));\n        if (!$maxSize) {\n            $args = elFinder::$currentArgs;\n            if (!empty($args['substitute'])) {\n                $maxSize = $args['substitute'];\n            }\n        }\n        if ($maxSize && $srcSize[0] && $srcSize[1]) {\n            if ($this->getOption('substituteImg')) {\n                $maxSize = intval($maxSize);\n                $zoom = min(($maxSize / $srcSize[0]), ($maxSize / $srcSize[1]));\n                if ($force || $zoom < 1) {\n                    $width = round($srcSize[0] * $zoom);\n                    $height = round($srcSize[1] * $zoom);\n                    $jpgQuality = 50;\n                    $preserveExif = false;\n                    $unenlarge = true;\n                    $checkAnimated = true;\n                    $destformat = $file['mime'] === 'image/jpeg'? null : 'png';\n                    if (!$srcfp) {\n                        elFinder::checkAborted();\n                        $srcfp = $this->open($target);\n                    }\n                    if ($srcfp && ($tempLink = $this->getTempLinkInfo())) {\n                        elFinder::checkAborted();\n                        $dest = fopen($tempLink['path'], 'wb');\n                        if ($dest && stream_copy_to_stream($srcfp, $dest)) {\n                            fclose($dest);\n                            if ($this->imageUtil('resize', $tempLink['path'], compact('width', 'height', 'jpgQuality', 'preserveExif', 'unenlarge', 'checkAnimated', 'destformat'))) {\n                                $url = $tempLink['url'];\n                                // set expire to 1 min left\n                                touch($tempLink['path'], time() - elFinder::$tmpLinkLifeTime + 60);\n                            } else {\n                                unlink($tempLink['path']);\n                            }\n                        }\n                        $this->close($srcfp, $target);\n                    }\n                }\n            }\n        }\n\n        return $url;\n    }\n\n    /**\n     * Return temp path\n     *\n     * @return string\n     * @author Naoki Sawada\n     */\n    public function getTempPath()\n    {\n        $tempPath = null;\n        if (isset($this->tmpPath) && $this->tmpPath && is_writable($this->tmpPath)) {\n            $tempPath = $this->tmpPath;\n        } else if (isset($this->tmp) && $this->tmp && is_writable($this->tmp)) {\n            $tempPath = $this->tmp;\n        } else if (elFinder::getStaticVar('commonTempPath') && is_writable(elFinder::getStaticVar('commonTempPath'))) {\n            $tempPath = elFinder::getStaticVar('commonTempPath');\n        } else if (function_exists('sys_get_temp_dir')) {\n            $tempPath = sys_get_temp_dir();\n        } else if ($this->tmbPathWritable) {\n            $tempPath = $this->tmbPath;\n        }\n        if ($tempPath && DIRECTORY_SEPARATOR !== '/') {\n            $tempPath = str_replace('/', DIRECTORY_SEPARATOR, $tempPath);\n        }\n        return $tempPath;\n    }\n\n    /**\n     * (Make &) Get upload taget dirctory hash\n     *\n     * @param string $baseTargetHash\n     * @param string $path\n     * @param array  $result\n     *\n     * @return boolean|string\n     * @author Naoki Sawada\n     */\n    public function getUploadTaget($baseTargetHash, $path, & $result)\n    {\n        $base = $this->decode($baseTargetHash);\n        $targetHash = $baseTargetHash;\n        $path = ltrim($path, $this->separator);\n        $dirs = explode($this->separator, $path);\n        array_pop($dirs);\n        foreach ($dirs as $dir) {\n            $targetPath = $this->joinPathCE($base, $dir);\n            if (!$_realpath = $this->realpath($this->encode($targetPath))) {\n                if ($stat = $this->mkdir($targetHash, $dir)) {\n                    $result['added'][] = $stat;\n                    $targetHash = $stat['hash'];\n                    $base = $this->decode($targetHash);\n                } else {\n                    return false;\n                }\n            } else {\n                $targetHash = $this->encode($_realpath);\n                if ($this->dir($targetHash)) {\n                    $base = $this->decode($targetHash);\n                } else {\n                    return false;\n                }\n            }\n        }\n        return $targetHash;\n    }\n\n    /**\n     * Return this uploadMaxSize value\n     *\n     * @return integer\n     * @author Naoki Sawada\n     */\n    public function getUploadMaxSize()\n    {\n        return $this->uploadMaxSize;\n    }\n\n    public function setUploadOverwrite($var)\n    {\n        $this->uploadOverwrite = (bool)$var;\n    }\n\n    /**\n     * Image file utility\n     *\n     * @param string $mode    'resize', 'rotate', 'propresize', 'crop', 'fitsquare'\n     * @param string $src     Image file local path\n     * @param array  $options excute options\n     *\n     * @return bool\n     * @throws ImagickException\n     * @throws elFinderAbortException\n     * @author Naoki Sawada\n     */\n    public function imageUtil($mode, $src, $options = array())\n    {\n        if (!isset($options['jpgQuality'])) {\n            $options['jpgQuality'] = intval($this->options['jpgQuality']);\n        }\n        if (!isset($options['bgcolor'])) {\n            $options['bgcolor'] = '#ffffff';\n        }\n        if (!isset($options['bgColorFb'])) {\n            $options['bgColorFb'] = $this->options['bgColorFb'];\n        }\n        $destformat = !empty($options['destformat'])? $options['destformat'] : null;\n\n        // check 'width' ,'height'\n        if (in_array($mode, array('resize', 'propresize', 'crop', 'fitsquare'))) {\n            if (empty($options['width']) || empty($options['height'])) {\n                return false;\n            }\n        }\n\n        if (!empty($options['checkAnimated'])) {\n            if ($this->imgLib !== 'imagick' && $this->imgLib !== 'convert') {\n                if (elFinder::isAnimationGif($src)) {\n                    return false;\n                }\n            }\n            if (elFinder::isAnimationPng($src)) {\n                return false;\n            }\n        }\n\n        switch ($mode) {\n            case 'rotate':\n                if (empty($options['degree'])) {\n                    return true;\n                }\n                return (bool)$this->imgRotate($src, $options['degree'], $options['bgColorFb'], $destformat, $options['jpgQuality']);\n\n            case 'resize':\n                return (bool)$this->imgResize($src, $options['width'], $options['height'], false, true, $destformat, $options['jpgQuality'], $options);\n\n            case 'propresize':\n                return (bool)$this->imgResize($src, $options['width'], $options['height'], true, true, $destformat, $options['jpgQuality'], $options);\n\n            case 'crop':\n                if (isset($options['x']) && isset($options['y'])) {\n                    return (bool)$this->imgCrop($src, $options['width'], $options['height'], $options['x'], $options['y'], $destformat, $options['jpgQuality']);\n                }\n                break;\n\n            case 'fitsquare':\n                return (bool)$this->imgSquareFit($src, $options['width'], $options['height'], 'center', 'middle', $options['bgcolor'], $destformat, $options['jpgQuality']);\n\n        }\n        return false;\n    }\n\n    /**\n     * Convert Video To Image by ffmpeg\n     *\n     * @param  string $file video source file path\n     * @param  array  $stat file stat array\n     * @param  object $self volume driver object\n     * @param  int    $ss   start seconds\n     *\n     * @return bool\n     * @throws elFinderAbortException\n     * @author Naoki Sawada\n     */\n    public function ffmpegToImg($file, $stat, $self, $ss = null)\n    {\n        $name = basename($file);\n        $path = dirname($file);\n        $tmp = $path . DIRECTORY_SEPARATOR . md5($name);\n        // register auto delete on shutdown\n        $GLOBALS['elFinderTempFiles'][$tmp] = true;\n        if (rename($file, $tmp)) {\n            if ($ss === null) {\n                // specific start time by file name (xxx^[sec].[extention] - video^3.mp4)\n                if (preg_match('/\\^(\\d+(?:\\.\\d+)?)\\.[^.]+$/', $stat['name'], $_m)) {\n                    $ss = $_m[1];\n                } else {\n                    $ss = $this->options['tmbVideoConvSec'];\n                }\n            }\n            $cmd = sprintf(ELFINDER_FFMPEG_PATH . ' -i %s -ss 00:00:%.3f -vframes 1 -f image2 -- %s', escapeshellarg($tmp), $ss, escapeshellarg($file));\n            $r = ($this->procExec($cmd) === 0);\n            clearstatcache();\n            if ($r && $ss > 0 && !file_exists($file)) {\n                // Retry by half of $ss\n                $ss = max(intval($ss / 2), 0);\n                rename($tmp, $file);\n                $r = $this->ffmpegToImg($file, $stat, $self, $ss);\n            } else {\n                unlink($tmp);\n            }\n            return $r;\n        }\n        return false;\n    }\n\n    /**\n     * Creates a temporary file and return file pointer\n     *\n     * @return resource|boolean\n     */\n    public function tmpfile()\n    {\n        if ($tmp = $this->getTempFile()) {\n            return fopen($tmp, 'wb');\n        }\n        return false;\n    }\n\n    /**\n     * Save error message\n     *\n     * @param  array  error\n     *\n     * @return boolean false\n     * @author Naoki Sawada\n     **/\n    protected function setError()\n    {\n        $this->error = array();\n        $this->addError(func_get_args());\n        return false;\n    }\n\n    /**\n     * Add error message\n     *\n     * @param  array  error\n     *\n     * @return false\n     * @author Dmitry(dio) Levashov\n     **/\n    protected function addError()\n    {\n        foreach (func_get_args() as $err) {\n            if (is_array($err)) {\n                foreach($err as $er) {\n                    $this->addError($er);\n                }\n            } else {\n                $this->error[] = (string)$err;\n            }\n        }\n        return false;\n    }\n\n    /*********************************************************************/\n    /*                               FS API                              */\n    /*********************************************************************/\n\n    /***************** server encoding support *******************/\n\n    /**\n     * Return parent directory path (with convert encoding)\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Naoki Sawada\n     **/\n    protected function dirnameCE($path)\n    {\n        $dirname = (!$this->encoding) ? $this->_dirname($path) : $this->convEncOut($this->_dirname($this->convEncIn($path)));\n        // check to infinite loop prevention\n        return ($dirname != $path) ? $dirname : '';\n    }\n\n    /**\n     * Return file name (with convert encoding)\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Naoki Sawada\n     **/\n    protected function basenameCE($path)\n    {\n        return (!$this->encoding) ? $this->_basename($path) : $this->convEncOut($this->_basename($this->convEncIn($path)));\n    }\n\n    /**\n     * Join dir name and file name and return full path. (with convert encoding)\n     * Some drivers (db) use int as path - so we give to concat path to driver itself\n     *\n     * @param  string $dir  dir path\n     * @param  string $name file name\n     *\n     * @return string\n     * @author Naoki Sawada\n     **/\n    protected function joinPathCE($dir, $name)\n    {\n        return (!$this->encoding) ? $this->_joinPath($dir, $name) : $this->convEncOut($this->_joinPath($this->convEncIn($dir), $this->convEncIn($name)));\n    }\n\n    /**\n     * Return normalized path (with convert encoding)\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Naoki Sawada\n     **/\n    protected function normpathCE($path)\n    {\n        return (!$this->encoding) ? $this->_normpath($path) : $this->convEncOut($this->_normpath($this->convEncIn($path)));\n    }\n\n    /**\n     * Return file path related to root dir (with convert encoding)\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Naoki Sawada\n     **/\n    protected function relpathCE($path)\n    {\n        return (!$this->encoding) ? $this->_relpath($path) : $this->convEncOut($this->_relpath($this->convEncIn($path)));\n    }\n\n    /**\n     * Convert path related to root dir into real path (with convert encoding)\n     *\n     * @param  string $path rel file path\n     *\n     * @return string\n     * @author Naoki Sawada\n     **/\n    protected function abspathCE($path)\n    {\n        return (!$this->encoding) ? $this->_abspath($path) : $this->convEncOut($this->_abspath($this->convEncIn($path)));\n    }\n\n    /**\n     * Return true if $path is children of $parent (with convert encoding)\n     *\n     * @param  string $path   path to check\n     * @param  string $parent parent path\n     *\n     * @return bool\n     * @author Naoki Sawada\n     **/\n    protected function inpathCE($path, $parent)\n    {\n        return (!$this->encoding) ? $this->_inpath($path, $parent) : $this->convEncOut($this->_inpath($this->convEncIn($path), $this->convEncIn($parent)));\n    }\n\n    /**\n     * Open file and return file pointer (with convert encoding)\n     *\n     * @param  string $path file path\n     * @param string  $mode\n     *\n     * @return false|resource\n     * @internal param bool $write open file for writing\n     * @author   Naoki Sawada\n     */\n    protected function fopenCE($path, $mode = 'rb')\n    {\n        // check extra option for network stream pointer\n        if (func_num_args() > 2) {\n            $opts = func_get_arg(2);\n        } else {\n            $opts = array();\n        }\n        return (!$this->encoding) ? $this->_fopen($path, $mode, $opts) : $this->convEncOut($this->_fopen($this->convEncIn($path), $mode, $opts));\n    }\n\n    /**\n     * Close opened file (with convert encoding)\n     *\n     * @param  resource $fp   file pointer\n     * @param  string   $path file path\n     *\n     * @return bool\n     * @author Naoki Sawada\n     **/\n    protected function fcloseCE($fp, $path = '')\n    {\n        return (!$this->encoding) ? $this->_fclose($fp, $path) : $this->convEncOut($this->_fclose($fp, $this->convEncIn($path)));\n    }\n\n    /**\n     * Create new file and write into it from file pointer. (with convert encoding)\n     * Return new file path or false on error.\n     *\n     * @param  resource $fp   file pointer\n     * @param  string   $dir  target dir path\n     * @param  string   $name file name\n     * @param  array    $stat file stat (required by some virtual fs)\n     *\n     * @return bool|string\n     * @author Naoki Sawada\n     **/\n    protected function saveCE($fp, $dir, $name, $stat)\n    {\n        $res = (!$this->encoding) ? $this->_save($fp, $dir, $name, $stat) : $this->convEncOut($this->_save($fp, $this->convEncIn($dir), $this->convEncIn($name), $this->convEncIn($stat)));\n        if ($res !== false) {\n            $this->clearstatcache();\n        }\n        return $res;\n    }\n\n    /**\n     * Return true if path is dir and has at least one childs directory (with convert encoding)\n     *\n     * @param  string $path dir path\n     *\n     * @return bool\n     * @author Naoki Sawada\n     **/\n    protected function subdirsCE($path)\n    {\n        if ($this->sessionCaching['subdirs']) {\n            if (isset($this->sessionCache['subdirs'][$path]) && !$this->isMyReload()) {\n                return $this->sessionCache['subdirs'][$path];\n            }\n        }\n        $hasdir = (bool)((!$this->encoding) ? $this->_subdirs($path) : $this->convEncOut($this->_subdirs($this->convEncIn($path))));\n        $this->updateSubdirsCache($path, $hasdir);\n        return $hasdir;\n    }\n\n    /**\n     * Return files list in directory (with convert encoding)\n     *\n     * @param  string $path dir path\n     *\n     * @return array\n     * @author Naoki Sawada\n     **/\n    protected function scandirCE($path)\n    {\n        return (!$this->encoding) ? $this->_scandir($path) : $this->convEncOut($this->_scandir($this->convEncIn($path)));\n    }\n\n    /**\n     * Create symlink (with convert encoding)\n     *\n     * @param  string $source    file to link to\n     * @param  string $targetDir folder to create link in\n     * @param  string $name      symlink name\n     *\n     * @return bool\n     * @author Naoki Sawada\n     **/\n    protected function symlinkCE($source, $targetDir, $name)\n    {\n        return (!$this->encoding) ? $this->_symlink($source, $targetDir, $name) : $this->convEncOut($this->_symlink($this->convEncIn($source), $this->convEncIn($targetDir), $this->convEncIn($name)));\n    }\n\n    /***************** paths *******************/\n\n    /**\n     * Encode path into hash\n     *\n     * @param  string  file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     * @author Troex Nevelin\n     **/\n    protected function encode($path)\n    {\n        if ($path !== '') {\n\n            // cut ROOT from $path for security reason, even if hacker decodes the path he will not know the root\n            $p = $this->relpathCE($path);\n            // if reqesting root dir $path will be empty, then assign '/' as we cannot leave it blank for crypt\n            if ($p === '') {\n                $p = $this->separator;\n            }\n            // change separator\n            if ($this->separatorForHash) {\n                $p = str_replace($this->separator, $this->separatorForHash, $p);\n            }\n            // TODO crypt path and return hash\n            $hash = $this->crypt($p);\n            // hash is used as id in HTML that means it must contain vaild chars\n            // make base64 html safe and append prefix in begining\n            $hash = strtr(base64_encode($hash), '+/=', '-_.');\n            // remove dots '.' at the end, before it was '=' in base64\n            $hash = rtrim($hash, '.');\n            // append volume id to make hash unique\n            return $this->id . $hash;\n        }\n        //TODO: Add return statement here\n    }\n\n    /**\n     * Decode path from hash\n     *\n     * @param  string  file hash\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     * @author Troex Nevelin\n     **/\n    protected function decode($hash)\n    {\n        if (strpos($hash, $this->id) === 0) {\n            // cut volume id after it was prepended in encode\n            $h = substr($hash, strlen($this->id));\n            // replace HTML safe base64 to normal\n            $h = base64_decode(strtr($h, '-_.', '+/='));\n            // TODO uncrypt hash and return path\n            $path = $this->uncrypt($h);\n            // change separator\n            if ($this->separatorForHash) {\n                $path = str_replace($this->separatorForHash, $this->separator, $path);\n            }\n            // append ROOT to path after it was cut in encode\n            return $this->abspathCE($path);//$this->root.($path === $this->separator ? '' : $this->separator.$path);\n        }\n        return '';\n    }\n\n    /**\n     * Return crypted path\n     * Not implemented\n     *\n     * @param  string  path\n     *\n     * @return mixed\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function crypt($path)\n    {\n        return $path;\n    }\n\n    /**\n     * Return uncrypted path\n     * Not implemented\n     *\n     * @param  mixed  hash\n     *\n     * @return mixed\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function uncrypt($hash)\n    {\n        return $hash;\n    }\n\n    /**\n     * Validate file name based on $this->options['acceptedName'] regexp or function\n     *\n     * @param  string $name file name\n     * @param  bool   $isDir\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     */\n    protected function nameAccepted($name, $isDir = false)\n    {\n        if (json_encode($name) === false) {\n            return false;\n        }\n        $nameValidator = $isDir ? $this->dirnameValidator : $this->nameValidator;\n        if ($nameValidator) {\n            if (is_callable($nameValidator)) {\n                $res = call_user_func($nameValidator, $name);\n                return $res;\n            }\n            if (preg_match($nameValidator, '') !== false) {\n                return preg_match($nameValidator, $name);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Return session rootstat cache key\n     *\n     * @return string\n     */\n    protected function getRootstatCachekey()\n    {\n        return md5($this->root . (isset($this->options['alias']) ? $this->options['alias'] : ''));\n    }\n\n    /**\n     * Return new unique name based on file name and suffix\n     *\n     * @param         $dir\n     * @param         $name\n     * @param  string $suffix suffix append to name\n     * @param bool    $checkNum\n     * @param int     $start\n     *\n     * @return string\n     * @internal param string $path file path\n     * @author   Dmitry (dio) Levashov\n     */\n    public function uniqueName($dir, $name, $suffix = ' copy', $checkNum = true, $start = 1)\n    {\n        static $lasts = null;\n\n        if ($lasts === null) {\n            $lasts = array();\n        }\n\n        $ext = '';\n\n        $splits = elFinder::splitFileExtention($name);\n        if ($splits[1]) {\n            $ext = '.' . $splits[1];\n            $name = $splits[0];\n        }\n\n        if ($checkNum && preg_match('/(' . preg_quote($suffix, '/') . ')(\\d*)$/i', $name, $m)) {\n            $i = (int)$m[2];\n            $name = substr($name, 0, strlen($name) - strlen($m[2]));\n        } else {\n            $i = $start;\n            $name .= $suffix;\n        }\n        $max = $i + 100000;\n\n        if (isset($lasts[$name])) {\n            $i = max($i, $lasts[$name]);\n        }\n\n        while ($i <= $max) {\n            $n = $name . ($i > 0 ? sprintf($this->options['uniqueNumFormat'], $i) : '') . $ext;\n\n            if (!$this->isNameExists($this->joinPathCE($dir, $n))) {\n                $this->clearcache();\n                $lasts[$name] = ++$i;\n                return $n;\n            }\n            $i++;\n        }\n        return $name . md5($dir) . $ext;\n    }\n\n    /**\n     * Converts character encoding from UTF-8 to server's one\n     *\n     * @param  mixed  $var           target string or array var\n     * @param  bool   $restoreLocale do retore global locale, default is false\n     * @param  string $unknown       replaces character for unknown\n     *\n     * @return mixed\n     * @author Naoki Sawada\n     */\n    public function convEncIn($var = null, $restoreLocale = false, $unknown = '_')\n    {\n        return (!$this->encoding) ? $var : $this->convEnc($var, 'UTF-8', $this->encoding, $this->options['locale'], $restoreLocale, $unknown);\n    }\n\n    /**\n     * Converts character encoding from server's one to UTF-8\n     *\n     * @param  mixed  $var           target string or array var\n     * @param  bool   $restoreLocale do retore global locale, default is true\n     * @param  string $unknown       replaces character for unknown\n     *\n     * @return mixed\n     * @author Naoki Sawada\n     */\n    public function convEncOut($var = null, $restoreLocale = true, $unknown = '_')\n    {\n        return (!$this->encoding) ? $var : $this->convEnc($var, $this->encoding, 'UTF-8', $this->options['locale'], $restoreLocale, $unknown);\n    }\n\n    /**\n     * Converts character encoding (base function)\n     *\n     * @param  mixed  $var     target string or array var\n     * @param  string $from    from character encoding\n     * @param  string $to      to character encoding\n     * @param  string $locale  local locale\n     * @param         $restoreLocale\n     * @param  string $unknown replaces character for unknown\n     *\n     * @return mixed\n     */\n    protected function convEnc($var, $from, $to, $locale, $restoreLocale, $unknown = '_')\n    {\n        if (strtoupper($from) !== strtoupper($to)) {\n            if ($locale) {\n                setlocale(LC_ALL, $locale);\n            }\n            if (is_array($var)) {\n                $_ret = array();\n                foreach ($var as $_k => $_v) {\n                    $_ret[$_k] = $this->convEnc($_v, $from, $to, '', false, $unknown = '_');\n                }\n                $var = $_ret;\n            } else {\n                $_var = false;\n                if (is_string($var)) {\n                    $_var = $var;\n                    $errlev = error_reporting();\n                    error_reporting($errlev ^ E_NOTICE);\n                    if (false !== ($_var = iconv($from, $to . '//TRANSLIT', $_var))) {\n                        $_var = str_replace('?', $unknown, $_var);\n                    }\n                    error_reporting($errlev);\n                }\n                if ($_var !== false) {\n                    $var = $_var;\n                }\n            }\n            if ($restoreLocale) {\n                setlocale(LC_ALL, elFinder::$locale);\n            }\n        }\n        return $var;\n    }\n\n    /**\n     * Normalize MIME-Type by options['mimeMap']\n     *\n     * @param      string $type MIME-Type\n     * @param      string $name Filename\n     * @param      string $ext  File extention without first dot (optional)\n     *\n     * @return     string  Normalized MIME-Type\n     */\n    public function mimeTypeNormalize($type, $name, $ext = '')\n    {\n        if ($ext === '') {\n            $ext = (false === $pos = strrpos($name, '.')) ? '' : substr($name, $pos + 1);\n        }\n        $_checkKey = strtolower($ext . ':' . $type);\n        if ($type === '') {\n            $_keylen = strlen($_checkKey);\n            foreach ($this->options['mimeMap'] as $_key => $_type) {\n                if (substr($_key, 0, $_keylen) === $_checkKey) {\n                    $type = $_type;\n                    break;\n                }\n            }\n        } else if (isset($this->options['mimeMap'][$_checkKey])) {\n            $type = $this->options['mimeMap'][$_checkKey];\n        } else {\n            $_checkKey = strtolower($ext . ':*');\n            if (isset($this->options['mimeMap'][$_checkKey])) {\n                $type = $this->options['mimeMap'][$_checkKey];\n            } else {\n                $_checkKey = strtolower('*:' . $type);\n                if (isset($this->options['mimeMap'][$_checkKey])) {\n                    $type = $this->options['mimeMap'][$_checkKey];\n                }\n            }\n        }\n        return $type;\n    }\n\n    /*********************** util mainly for inheritance class *********************/\n\n    /**\n     * Get temporary filename. Tempfile will be removed when after script execution finishes or exit() is called.\n     * When needing the unique file to a path, give $path to parameter.\n     *\n     * @param  string $path for get unique file to a path\n     *\n     * @return string|false\n     * @author Naoki Sawada\n     */\n    protected function getTempFile($path = '')\n    {\n        static $cache = array();\n\n        $key = '';\n        if ($path !== '') {\n            $key = $this->id . '#' . $path;\n            if (isset($cache[$key])) {\n                return $cache[$key];\n            }\n        }\n\n        if ($tmpdir = $this->getTempPath()) {\n            $name = tempnam($tmpdir, 'ELF');\n            if ($key) {\n                $cache[$key] = $name;\n            }\n            // register auto delete on shutdown\n            $GLOBALS['elFinderTempFiles'][$name] = true;\n            return $name;\n        }\n\n        return false;\n    }\n\n    /**\n     * File path of local server side work file path\n     *\n     * @param  string $path path need convert encoding to server encoding\n     *\n     * @return string\n     * @author Naoki Sawada\n     */\n    protected function getWorkFile($path)\n    {\n        if ($wfp = $this->tmpfile()) {\n            if ($fp = $this->_fopen($path)) {\n                while (!feof($fp)) {\n                    fwrite($wfp, fread($fp, 8192));\n                }\n                $info = stream_get_meta_data($wfp);\n                fclose($wfp);\n                if ($info && !empty($info['uri'])) {\n                    return $info['uri'];\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Get image size array with `dimensions`\n     *\n     * @param string $path path need convert encoding to server encoding\n     * @param string $mime file mime type\n     *\n     * @return array|false\n     * @throws ImagickException\n     * @throws elFinderAbortException\n     */\n    public function getImageSize($path, $mime = '')\n    {\n        $size = false;\n        if ($mime === '' || strtolower(substr($mime, 0, 5)) === 'image') {\n            if ($work = $this->getWorkFile($path)) {\n                if ($size = getimagesize($work)) {\n                    $size['dimensions'] = $size[0] . 'x' . $size[1];\n                    $srcfp = fopen($work, 'rb');\n                    $cArgs = elFinder::$currentArgs;\n                    if (!empty($cArgs['target']) && $subImgLink = $this->getSubstituteImgLink($cArgs['target'], $size, $srcfp)) {\n                        $size['url'] = $subImgLink;\n                    }\n                }\n            }\n            is_file($work) && unlink($work);\n        }\n        return $size;\n    }\n\n    /**\n     * Delete dirctory trees\n     *\n     * @param string $localpath path need convert encoding to server encoding\n     *\n     * @return boolean\n     * @throws elFinderAbortException\n     * @author Naoki Sawada\n     */\n    protected function delTree($localpath)\n    {\n        foreach ($this->_scandir($localpath) as $p) {\n            elFinder::checkAborted();\n            $stat = $this->stat($this->convEncOut($p));\n            $this->convEncIn();\n            ($stat['mime'] === 'directory') ? $this->delTree($p) : $this->_unlink($p);\n        }\n        $res = $this->_rmdir($localpath);\n        $res && $this->clearstatcache();\n        return $res;\n    }\n\n    /**\n     * Copy items to a new temporary directory on the local server\n     *\n     * @param  array  $hashes  target hashes\n     * @param  string $dir     destination directory (for recurcive)\n     * @param  string $canLink it can use link() (for recurcive)\n     *\n     * @return string|false    saved path name\n     * @throws elFinderAbortException\n     * @author Naoki Sawada\n     */\n    protected function getItemsInHand($hashes, $dir = null, $canLink = null)\n    {\n        static $banChrs = null;\n        static $totalSize = 0;\n\n        if  (is_null($banChrs)) {\n            $banChrs = DIRECTORY_SEPARATOR !== '/'? array('\\\\', '/', ':', '*', '?', '\"', '<', '>', '|') : array('\\\\', '/');\n        }\n\n        if (is_null($dir)) {\n            $totalSize = 0;\n            if (!$tmpDir = $this->getTempPath()) {\n                return false;\n            }\n            $dir = tempnam($tmpDir, 'elf');\n            if (!unlink($dir) || !mkdir($dir, 0700, true)) {\n                return false;\n            }\n            register_shutdown_function(array($this, 'rmdirRecursive'), $dir);\n        }\n        if (is_null($canLink)) {\n            $canLink = ($this instanceof elFinderVolumeLocalFileSystem);\n        }\n        elFinder::checkAborted();\n        $res = true;\n        $files = array();\n        foreach ($hashes as $hash) {\n            if (($file = $this->file($hash)) == false) {\n                continue;\n            }\n            if (!$file['read']) {\n                continue;\n            }\n\n            $name = $file['name'];\n            // remove ctrl characters\n            $name = preg_replace('/[[:cntrl:]]+/', '', $name);\n            // replace ban characters\n            $name = str_replace($banChrs, '_', $name);\n\n            // for call from search results\n            if (isset($files[$name])) {\n                $name = preg_replace('/^(.*?)(\\..*)?$/', '$1_' . $files[$name]++ . '$2', $name);\n            } else {\n                $files[$name] = 1;\n            }\n            $target = $dir . DIRECTORY_SEPARATOR . $name;\n\n            if ($file['mime'] === 'directory') {\n                $chashes = array();\n                $_files = $this->scandir($hash);\n                foreach ($_files as $_file) {\n                    if ($file['read']) {\n                        $chashes[] = $_file['hash'];\n                    }\n                }\n                if (($res = mkdir($target, 0700, true)) && $chashes) {\n                    $res = $this->getItemsInHand($chashes, $target, $canLink);\n                }\n                if (!$res) {\n                    break;\n                }\n                !empty($file['ts']) && touch($target, $file['ts']);\n            } else {\n                $path = $this->decode($hash);\n                if (!$canLink || !($canLink = $this->localFileSystemSymlink($path, $target))) {\n                    if (file_exists($target)) {\n                        unlink($target);\n                    }\n                    if ($fp = $this->fopenCE($path)) {\n                        if ($tfp = fopen($target, 'wb')) {\n                            $totalSize += stream_copy_to_stream($fp, $tfp);\n                            fclose($tfp);\n                        }\n                        !empty($file['ts']) && touch($target, $file['ts']);\n                        $this->fcloseCE($fp, $path);\n                    }\n                } else {\n                    $totalSize += filesize($path);\n                }\n                if ($this->options['maxArcFilesSize'] > 0 && $this->options['maxArcFilesSize'] < $totalSize) {\n                    $res = $this->setError(elFinder::ERROR_ARC_MAXSIZE);\n                }\n            }\n        }\n        return $res ? $dir : false;\n    }\n\n    /*********************** file stat *********************/\n\n    /**\n     * Check file attribute\n     *\n     * @param  string $path  file path\n     * @param  string $name  attribute name (read|write|locked|hidden)\n     * @param  bool   $val   attribute value returned by file system\n     * @param  bool   $isDir path is directory (true: directory, false: file)\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function attr($path, $name, $val = null, $isDir = null)\n    {\n        if (!isset($this->defaults[$name])) {\n            return false;\n        }\n\n        $relpath = $this->relpathCE($path);\n        if ($this->separator !== '/') {\n            $relpath = str_replace($this->separator, '/', $relpath);\n        }\n        $relpath = '/' . $relpath;\n\n        $perm = null;\n\n        if ($this->access) {\n            $perm = call_user_func($this->access, $name, $path, $this->options['accessControlData'], $this, $isDir, $relpath);\n            if ($perm !== null) {\n                return !!$perm;\n            }\n        }\n\n        foreach ($this->attributes as $attrs) {\n            if (isset($attrs[$name]) && isset($attrs['pattern']) && preg_match($attrs['pattern'], $relpath)) {\n                $perm = $attrs[$name];\n                break;\n            }\n        }\n\n        return $perm === null ? (is_null($val) ? $this->defaults[$name] : $val) : !!$perm;\n    }\n\n    /**\n     * Return true if file with given name can be created in given folder.\n     *\n     * @param string $dir  parent dir path\n     * @param string $name new file name\n     * @param null   $isDir\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     */\n    protected function allowCreate($dir, $name, $isDir = null)\n    {\n        return $this->attr($this->joinPathCE($dir, $name), 'write', true, $isDir);\n    }\n\n    /**\n     * Return true if file MIME type can save with check uploadOrder config.\n     *\n     * @param string $mime\n     *\n     * @return boolean\n     */\n    protected function allowPutMime($mime)\n    {\n        // logic based on http://httpd.apache.org/docs/2.2/mod/mod_authz_host.html#order\n        $allow = $this->mimeAccepted($mime, $this->uploadAllow, null);\n        $deny = $this->mimeAccepted($mime, $this->uploadDeny, null);\n        if (strtolower($this->uploadOrder[0]) == 'allow') { // array('allow', 'deny'), default is to 'deny'\n            $res = false; // default is deny\n            if (!$deny && ($allow === true)) { // match only allow\n                $res = true;\n            }// else (both match | no match | match only deny) { deny }\n        } else { // array('deny', 'allow'), default is to 'allow' - this is the default rule\n            $res = true; // default is allow\n            if (($deny === true) && !$allow) { // match only deny\n                $res = false;\n            } // else (both match | no match | match only allow) { allow }\n        }\n        return $res;\n    }\n\n    /**\n     * Return fileinfo\n     *\n     * @param  string $path file cache\n     *\n     * @return array|bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function stat($path)\n    {\n        if ($path === false || is_null($path)) {\n            return false;\n        }\n        $is_root = ($path == $this->root);\n        if ($is_root) {\n            $rootKey = $this->getRootstatCachekey();\n            if ($this->sessionCaching['rootstat'] && !isset($this->sessionCache['rootstat'])) {\n                $this->sessionCache['rootstat'] = array();\n            }\n            if (!isset($this->cache[$path]) && !$this->isMyReload()) {\n                // need $path as key for netmount/netunmount\n                if ($this->sessionCaching['rootstat'] && isset($this->sessionCache['rootstat'][$rootKey])) {\n                    if ($ret = $this->sessionCache['rootstat'][$rootKey]) {\n                        if ($this->options['rootRev'] === $ret['rootRev']) {\n                            if (isset($this->options['phash'])) {\n                                $ret['isroot'] = 1;\n                                $ret['phash'] = $this->options['phash'];\n                            }\n                            return $ret;\n                        }\n                    }\n                }\n            }\n        }\n        $rootSessCache = false;\n        if (isset($this->cache[$path])) {\n            $ret = $this->cache[$path];\n        } else {\n            if ($is_root && !empty($this->options['rapidRootStat']) && is_array($this->options['rapidRootStat']) && !$this->needOnline) {\n                $ret = $this->updateCache($path, $this->options['rapidRootStat'], true);\n            } else {\n                $ret = $this->updateCache($path, $this->convEncOut($this->_stat($this->convEncIn($path))), true);\n                if ($is_root && !empty($rootKey) && $this->sessionCaching['rootstat']) {\n                    $rootSessCache = true;\n                }\n            }\n        } \n        if ($is_root) {\n            if ($ret) {\n                $this->rootModified = false;\n                if ($rootSessCache) {\n                    $this->sessionCache['rootstat'][$rootKey] = $ret;\n                }\n                if (isset($this->options['phash'])) {\n                    $ret['isroot'] = 1;\n                    $ret['phash'] = $this->options['phash'];\n                }\n            } else if (!empty($rootKey) && $this->sessionCaching['rootstat']) {\n                unset($this->sessionCache['rootstat'][$rootKey]);\n            }\n        }\n        return $ret;\n    }\n\n    /**\n     * Get root stat extra key values\n     *\n     * @return array stat extras\n     * @author Naoki Sawada\n     */\n    protected function getRootStatExtra()\n    {\n        $stat = array();\n        if ($this->rootName) {\n            $stat['name'] = $this->rootName;\n        }\n        $stat['rootRev'] = $this->options['rootRev'];\n        $stat['options'] = $this->options(null);\n        return $stat;\n    }\n\n    /**\n     * Return fileinfo based on filename\n     * For item ID based path file system\n     * Please override if needed on each drivers\n     *\n     * @param  string $path file cache\n     *\n     * @return array\n     */\n    protected function isNameExists($path)\n    {\n        return $this->stat($path);\n    }\n\n    /**\n     * Put file stat in cache and return it\n     *\n     * @param  string $path file path\n     * @param  array  $stat file stat\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function updateCache($path, $stat)\n    {\n        if (empty($stat) || !is_array($stat)) {\n            return $this->cache[$path] = array();\n        }\n\n        if (func_num_args() > 2) {\n            $fromStat = func_get_arg(2);\n        } else {\n            $fromStat = false;\n        }\n\n        $stat['hash'] = $this->encode($path);\n\n        $root = $path == $this->root;\n        $parent = '';\n\n        if ($root) {\n            $stat = array_merge($stat, $this->getRootStatExtra());\n        } else {\n            if (!isset($stat['name']) || $stat['name'] === '') {\n                $stat['name'] = $this->basenameCE($path);\n            }\n            if (empty($stat['phash'])) {\n                $parent = $this->dirnameCE($path);\n                $stat['phash'] = $this->encode($parent);\n            } else {\n                $parent = $this->decode($stat['phash']);\n            }\n        }\n\n        // name check\n        if (isset($stat['name']) && !$jeName = json_encode($stat['name'])) {\n            return $this->cache[$path] = array();\n        }\n        // fix name if required\n        if ($this->options['utf8fix'] && $this->options['utf8patterns'] && $this->options['utf8replace']) {\n            $stat['name'] = json_decode(str_replace($this->options['utf8patterns'], $this->options['utf8replace'], $jeName));\n        }\n\n        if (!isset($stat['size'])) {\n            $stat['size'] = 'unknown';\n        }\n\n        $mime = isset($stat['mime']) ? $stat['mime'] : '';\n        if ($isDir = ($mime === 'directory')) {\n            $stat['volumeid'] = $this->id;\n        } else {\n            if (empty($stat['mime']) || $stat['size'] == 0) {\n                $stat['mime'] = $this->mimetype($stat['name'], true, $stat['size'], $mime);\n            } else {\n                $stat['mime'] = $this->mimeTypeNormalize($stat['mime'], $stat['name']);\n            }\n        }\n\n        $stat['read'] = intval($this->attr($path, 'read', isset($stat['read']) ? !!$stat['read'] : null, $isDir));\n        $stat['write'] = intval($this->attr($path, 'write', isset($stat['write']) ? !!$stat['write'] : null, $isDir));\n        if ($root) {\n            $stat['locked'] = 1;\n            if ($this->options['type'] !== '') {\n                $stat['type'] = $this->options['type'];\n            }\n        } else {\n            // lock when parent directory is not writable\n            if (!isset($stat['locked'])) {\n                $pstat = $this->stat($parent);\n                if (isset($pstat['write']) && !$pstat['write']) {\n                    $stat['locked'] = true;\n                }\n            }\n            if ($this->attr($path, 'locked', isset($stat['locked']) ? !!$stat['locked'] : null, $isDir)) {\n                $stat['locked'] = 1;\n            } else {\n                unset($stat['locked']);\n            }\n        }\n\n        if ($root) {\n            unset($stat['hidden']);\n        } elseif ($this->attr($path, 'hidden', isset($stat['hidden']) ? !!$stat['hidden'] : null, $isDir)\n            || !$this->mimeAccepted($stat['mime'])) {\n            $stat['hidden'] = 1;\n        } else {\n            unset($stat['hidden']);\n        }\n\n        if ($stat['read'] && empty($stat['hidden'])) {\n\n            if ($isDir) {\n                // caching parent's subdirs\n                if ($parent) {\n                    $this->updateSubdirsCache($parent, true);\n                }\n                // for dir - check for subdirs\n                if ($this->options['checkSubfolders']) {\n                    if (!isset($stat['dirs']) && intval($this->options['checkSubfolders']) === -1) {\n                        $stat['dirs'] = -1;\n                    }\n                    if (isset($stat['dirs'])) {\n                        if ($stat['dirs']) {\n                            if ($stat['dirs'] == -1) {\n                                $stat['dirs'] = ($this->sessionCaching['subdirs'] && isset($this->sessionCache['subdirs'][$path])) ? (int)$this->sessionCache['subdirs'][$path] : -1;\n                            } else {\n                                $stat['dirs'] = 1;\n                            }\n                        } else {\n                            unset($stat['dirs']);\n                        }\n                    } elseif (!empty($stat['alias']) && !empty($stat['target'])) {\n                        $stat['dirs'] = isset($this->cache[$stat['target']])\n                            ? intval(isset($this->cache[$stat['target']]['dirs']))\n                            : $this->subdirsCE($stat['target']);\n\n                    } elseif ($this->subdirsCE($path)) {\n                        $stat['dirs'] = 1;\n                    }\n                } else {\n                    $stat['dirs'] = 1;\n                }\n                if ($this->options['dirUrlOwn'] === true) {\n                    // Set `null` to use the client option `commandsOptions.info.nullUrlDirLinkSelf = true`\n                    $stat['url'] = null;\n                } else if ($this->options['dirUrlOwn'] === 'hide') {\n                    // to hide link in info dialog of the elFinder client\n                    $stat['url'] = '';\n                }\n            } else {\n                // for files - check for thumbnails\n                $p = isset($stat['target']) ? $stat['target'] : $path;\n                if ($this->tmbURL && !isset($stat['tmb']) && $this->canCreateTmb($p, $stat)) {\n                    $tmb = $this->gettmb($p, $stat);\n                    $stat['tmb'] = $tmb ? $tmb : 1;\n                }\n\n            }\n            if (!isset($stat['url']) && $this->URL && $this->encoding) {\n                $_path = str_replace($this->separator, '/', substr($path, strlen($this->root) + 1));\n                $stat['url'] = rtrim($this->URL, '/') . '/' . str_replace('%2F', '/', rawurlencode((substr(PHP_OS, 0, 3) === 'WIN') ? $_path : $this->convEncIn($_path, true)));\n            }\n        } else {\n            if ($isDir) {\n                unset($stat['dirs']);\n            }\n        }\n\n        if (!empty($stat['alias']) && !empty($stat['target'])) {\n            $stat['thash'] = $this->encode($stat['target']);\n            //$this->cache[$stat['target']] = $stat;\n            unset($stat['target']);\n        }\n\n        $this->cache[$path] = $stat;\n\n        if (!$fromStat && $root && $this->sessionCaching['rootstat']) {\n            // to update session cache\n            $this->stat($path);\n        }\n\n        return $stat;\n    }\n\n    /**\n     * Get stat for folder content and put in cache\n     *\n     * @param  string $path\n     *\n     * @return void\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function cacheDir($path)\n    {\n        $this->dirsCache[$path] = array();\n        $hasDir = false;\n\n        foreach ($this->scandirCE($path) as $p) {\n            if (($stat = $this->stat($p)) && empty($stat['hidden'])) {\n                if (!$hasDir && $stat['mime'] === 'directory') {\n                    $hasDir = true;\n                }\n                $this->dirsCache[$path][] = $p;\n            }\n        }\n\n        $this->updateSubdirsCache($path, $hasDir);\n    }\n\n    /**\n     * Clean cache\n     *\n     * @return void\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function clearcache()\n    {\n        $this->cache = $this->dirsCache = array();\n    }\n\n    /**\n     * Return file mimetype\n     *\n     * @param  string      $path file path\n     * @param  string|bool $name\n     * @param  integer     $size\n     * @param  string      $mime was notified from the volume driver\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     */\n    protected function mimetype($path, $name = '', $size = null, $mime = null)\n    {\n        $type = '';\n        $nameCheck = false;\n\n        if ($name === '') {\n            $name = $path;\n        } else if ($name === true) {\n            $name = $path;\n            $nameCheck = true;\n        }\n        if (!$this instanceof elFinderVolumeLocalFileSystem) {\n            $nameCheck = true;\n        }\n        $ext = (false === $pos = strrpos($name, '.')) ? '' : strtolower(substr($name, $pos + 1));\n        if (!$nameCheck && $size === null) {\n            $size = file_exists($path) ? filesize($path) : -1;\n        }\n        if (!$nameCheck && is_readable($path) && $size > 0) {\n            // detecting by contents\n            if ($this->mimeDetect === 'finfo') {\n                $type = finfo_file($this->finfo, $path);\n            } else if ($this->mimeDetect === 'mime_content_type') {\n                $type = mime_content_type($path);\n            }\n            if ($type) {\n                $type = explode(';', $type);\n                $type = trim($type[0]);\n                if ($ext && preg_match('~^application/(?:octet-stream|(?:x-)?zip|xml)$~', $type)) {\n                    // load default MIME table file \"mime.types\"\n                    if (!elFinderVolumeDriver::$mimetypesLoaded) {\n                        elFinderVolumeDriver::loadMimeTypes();\n                    }\n                    if (isset(elFinderVolumeDriver::$mimetypes[$ext])) {\n                        $type = elFinderVolumeDriver::$mimetypes[$ext];\n                    }\n                } else if ($ext === 'js' && preg_match('~^text/~', $type)) {\n                    $type = 'text/javascript';\n                }\n            }\n        }\n        if (!$type) {\n            // detecting by filename\n            $type = elFinderVolumeDriver::mimetypeInternalDetect($name);\n            if ($type === 'unknown') {\n                if ($mime) {\n                    $type = $mime;\n                } else {\n                    $type = ($size == 0) ? 'text/plain' : $this->options['mimeTypeUnknown'];\n                }\n            }\n        }\n\n        // mime type normalization\n        $type = $this->mimeTypeNormalize($type, $name, $ext);\n\n        return $type;\n    }\n\n    /**\n     * Load file of mime.types\n     *\n     * @param string $mimeTypesFile The mime types file\n     */\n    static protected function loadMimeTypes($mimeTypesFile = '')\n    {\n        if (!elFinderVolumeDriver::$mimetypesLoaded) {\n            elFinderVolumeDriver::$mimetypesLoaded = true;\n            $file = false;\n            if (!empty($mimeTypesFile) && file_exists($mimeTypesFile)) {\n                $file = $mimeTypesFile;\n            } elseif (elFinder::$defaultMimefile && file_exists(elFinder::$defaultMimefile)) {\n                $file = elFinder::$defaultMimefile;\n            } elseif (file_exists(dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mime.types')) {\n                $file = dirname(__FILE__) . DIRECTORY_SEPARATOR . 'mime.types';\n            } elseif (file_exists(dirname(dirname(__FILE__)) . DIRECTORY_SEPARATOR . 'mime.types')) {\n                $file = dirname(dirname(__FILE__)) . DIRECTORY_SEPARATOR . 'mime.types';\n            }\n\n            if ($file && file_exists($file)) {\n                $mimecf = file($file);\n\n                foreach ($mimecf as $line_num => $line) {\n                    if (!preg_match('/^\\s*#/', $line)) {\n                        $mime = preg_split('/\\s+/', $line, -1, PREG_SPLIT_NO_EMPTY);\n                        for ($i = 1, $size = count($mime); $i < $size; $i++) {\n                            if (!isset(self::$mimetypes[$mime[$i]])) {\n                                self::$mimetypes[$mime[$i]] = $mime[0];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Detect file mimetype using \"internal\" method or Loading mime.types with $path = ''\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    static protected function mimetypeInternalDetect($path = '')\n    {\n        // load default MIME table file \"mime.types\"\n        if (!elFinderVolumeDriver::$mimetypesLoaded) {\n            elFinderVolumeDriver::loadMimeTypes();\n        }\n        $ext = '';\n        if ($path) {\n            $pinfo = pathinfo($path);\n            $ext = isset($pinfo['extension']) ? strtolower($pinfo['extension']) : '';\n        }\n        return ($ext && isset(elFinderVolumeDriver::$mimetypes[$ext])) ? elFinderVolumeDriver::$mimetypes[$ext] : 'unknown';\n    }\n\n    /**\n     * Return file/total directory size infomation\n     *\n     * @param  string $path file path\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function countSize($path)\n    {\n\n        elFinder::checkAborted();\n\n        $result = array('size' => 0, 'files' => 0, 'dirs' => 0);\n        $stat = $this->stat($path);\n\n        if (empty($stat) || !$stat['read'] || !empty($stat['hidden'])) {\n            $result['size'] = 'unknown';\n            return $result;\n        }\n\n        if ($stat['mime'] !== 'directory') {\n            $result['size'] = intval($stat['size']);\n            $result['files'] = 1;\n            return $result;\n        }\n\n        $result['dirs'] = 1;\n        $subdirs = $this->options['checkSubfolders'];\n        $this->options['checkSubfolders'] = true;\n        foreach ($this->getScandir($path) as $stat) {\n            if ($isDir = ($stat['mime'] === 'directory' && $stat['read'])) {\n                ++$result['dirs'];\n            } else {\n                ++$result['files'];\n            }\n            $res = $isDir\n                ? $this->countSize($this->decode($stat['hash']))\n                : (isset($stat['size']) ? array('size' => intval($stat['size'])) : array());\n            if (!empty($res['size']) && is_numeric($res['size'])) {\n                $result['size'] += $res['size'];\n            }\n            if (!empty($res['files']) && is_numeric($res['files'])) {\n                $result['files'] += $res['files'];\n            }\n            if (!empty($res['dirs']) && is_numeric($res['dirs'])) {\n                $result['dirs'] += $res['dirs'];\n                --$result['dirs'];\n            }\n        }\n        $this->options['checkSubfolders'] = $subdirs;\n        return $result;\n    }\n\n    /**\n     * Return true if all mimes is directory or files\n     *\n     * @param  string $mime1 mimetype\n     * @param  string $mime2 mimetype\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function isSameType($mime1, $mime2)\n    {\n        return ($mime1 == 'directory' && $mime1 == $mime2) || ($mime1 != 'directory' && $mime2 != 'directory');\n    }\n\n    /**\n     * If file has required attr == $val - return file path,\n     * If dir has child with has required attr == $val - return child path\n     *\n     * @param  string $path file path\n     * @param  string $attr attribute name\n     * @param  bool   $val  attribute value\n     *\n     * @return string|false\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function closestByAttr($path, $attr, $val)\n    {\n        $stat = $this->stat($path);\n\n        if (empty($stat)) {\n            return false;\n        }\n\n        $v = isset($stat[$attr]) ? $stat[$attr] : false;\n\n        if ($v == $val) {\n            return $path;\n        }\n\n        return $stat['mime'] == 'directory'\n            ? $this->childsByAttr($path, $attr, $val)\n            : false;\n    }\n\n    /**\n     * Return first found children with required attr == $val\n     *\n     * @param  string $path file path\n     * @param  string $attr attribute name\n     * @param  bool   $val  attribute value\n     *\n     * @return string|false\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function childsByAttr($path, $attr, $val)\n    {\n        foreach ($this->scandirCE($path) as $p) {\n            if (($_p = $this->closestByAttr($p, $attr, $val)) != false) {\n                return $_p;\n            }\n        }\n        return false;\n    }\n\n    protected function isMyReload($target = '', $ARGtarget = '')\n    {\n        if ($this->rootModified || (!empty($this->ARGS['cmd']) && $this->ARGS['cmd'] === 'parents')) {\n            return true;\n        }\n        if (!empty($this->ARGS['reload'])) {\n            if ($ARGtarget === '') {\n                $ARGtarget = isset($this->ARGS['target']) ? $this->ARGS['target']\n                    : ((isset($this->ARGS['targets']) && is_array($this->ARGS['targets']) && count($this->ARGS['targets']) === 1) ?\n                        $this->ARGS['targets'][0] : '');\n            }\n            if ($ARGtarget !== '') {\n                $ARGtarget = strval($ARGtarget);\n                if ($target === '') {\n                    return (strpos($ARGtarget, $this->id) === 0);\n                } else {\n                    $target = strval($target);\n                    return ($target === $ARGtarget);\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Update subdirs cache data\n     *\n     * @param string $path\n     * @param bool   $subdirs\n     *\n     * @return void\n     */\n    protected function updateSubdirsCache($path, $subdirs)\n    {\n        if (isset($this->cache[$path])) {\n            if ($subdirs) {\n                $this->cache[$path]['dirs'] = 1;\n            } else {\n                unset($this->cache[$path]['dirs']);\n            }\n        }\n        if ($this->sessionCaching['subdirs']) {\n            $this->sessionCache['subdirs'][$path] = $subdirs;\n        }\n        if ($this->sessionCaching['rootstat'] && $path == $this->root) {\n            unset($this->sessionCache['rootstat'][$this->getRootstatCachekey()]);\n        }\n    }\n\n    /*****************  get content *******************/\n\n    /**\n     * Return required dir's files info.\n     * If onlyMimes is set - return only dirs and files of required mimes\n     *\n     * @param  string $path dir path\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function getScandir($path)\n    {\n        $files = array();\n\n        !isset($this->dirsCache[$path]) && $this->cacheDir($path);\n\n        foreach ($this->dirsCache[$path] as $p) {\n            if (($stat = $this->stat($p)) && empty($stat['hidden'])) {\n                $files[] = $stat;\n            }\n        }\n\n        return $files;\n    }\n\n\n    /**\n     * Return subdirs tree\n     *\n     * @param  string $path parent dir path\n     * @param  int    $deep tree deep\n     * @param string  $exclude\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     */\n    protected function gettree($path, $deep, $exclude = '')\n    {\n        $dirs = array();\n\n        !isset($this->dirsCache[$path]) && $this->cacheDir($path);\n\n        foreach ($this->dirsCache[$path] as $p) {\n            $stat = $this->stat($p);\n\n            if ($stat && empty($stat['hidden']) && $p != $exclude && $stat['mime'] == 'directory') {\n                $dirs[] = $stat;\n                if ($deep > 0 && !empty($stat['dirs'])) {\n                    $dirs = array_merge($dirs, $this->gettree($p, $deep - 1));\n                }\n            }\n        }\n\n        return $dirs;\n    }\n\n    /**\n     * Recursive files search\n     *\n     * @param  string $path dir path\n     * @param  string $q    search string\n     * @param  array  $mimes\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function doSearch($path, $q, $mimes)\n    {\n        $result = array();\n        $matchMethod = empty($this->doSearchCurrentQuery['matchMethod']) ? 'searchMatchName' : $this->doSearchCurrentQuery['matchMethod'];\n        $timeout = $this->options['searchTimeout'] ? $this->searchStart + $this->options['searchTimeout'] : 0;\n        if ($timeout && $timeout < time()) {\n            $this->setError(elFinder::ERROR_SEARCH_TIMEOUT, $this->path($this->encode($path)));\n            return $result;\n        }\n\n        foreach ($this->scandirCE($path) as $p) {\n            elFinder::extendTimeLimit($this->options['searchTimeout'] + 30);\n\n            if ($timeout && ($this->error || $timeout < time())) {\n                !$this->error && $this->setError(elFinder::ERROR_SEARCH_TIMEOUT, $this->path($this->encode($path)));\n                break;\n            }\n\n\n            $stat = $this->stat($p);\n\n            if (!$stat) { // invalid links\n                continue;\n            }\n\n            if (!empty($stat['hidden']) || !$this->mimeAccepted($stat['mime'], $mimes)) {\n                continue;\n            }\n\n            $name = $stat['name'];\n\n            if ($this->doSearchCurrentQuery['excludes']) {\n                foreach ($this->doSearchCurrentQuery['excludes'] as $exclude) {\n                    if ($this->stripos($name, $exclude) !== false) {\n                        continue 2;\n                    }\n                }\n            }\n\n            if ((!$mimes || $stat['mime'] !== 'directory') && $this->$matchMethod($name, $q, $p) !== false) {\n                $stat['path'] = $this->path($stat['hash']);\n                if ($this->URL && !isset($stat['url'])) {\n                    $path = str_replace($this->separator, '/', substr($p, strlen($this->root) + 1));\n                    if ($this->encoding) {\n                        $path = str_replace('%2F', '/', rawurlencode($this->convEncIn($path, true)));\n                    } else {\n                        $path = str_replace('%2F', '/', rawurlencode($path));\n                    }\n                    $stat['url'] = $this->URL . $path;\n                }\n\n                $result[] = $stat;\n            }\n            if ($stat['mime'] == 'directory' && $stat['read'] && !isset($stat['alias'])) {\n                if (!$this->options['searchExDirReg'] || !preg_match($this->options['searchExDirReg'], $p)) {\n                    $result = array_merge($result, $this->doSearch($p, $q, $mimes));\n                }\n            }\n        }\n\n        return $result;\n    }\n\n    /**********************  manuipulations  ******************/\n\n    /**\n     * Copy file/recursive copy dir only in current volume.\n     * Return new file path or false.\n     *\n     * @param  string $src  source path\n     * @param  string $dst  destination dir path\n     * @param  string $name new file name (optionaly)\n     *\n     * @return string|false\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function copy($src, $dst, $name)\n    {\n\n        elFinder::checkAborted();\n\n        $srcStat = $this->stat($src);\n\n        if (!empty($srcStat['thash'])) {\n            $target = $this->decode($srcStat['thash']);\n            if (!$this->inpathCE($target, $this->root)) {\n                return $this->setError(elFinder::ERROR_COPY, $this->path($srcStat['hash']), elFinder::ERROR_MKOUTLINK);\n            }\n            $stat = $this->stat($target);\n            $this->clearcache();\n            return $stat && $this->symlinkCE($target, $dst, $name)\n                ? $this->joinPathCE($dst, $name)\n                : $this->setError(elFinder::ERROR_COPY, $this->path($srcStat['hash']));\n        }\n\n        if ($srcStat['mime'] === 'directory') {\n            $testStat = $this->isNameExists($this->joinPathCE($dst, $name));\n            $this->clearcache();\n\n            if (($testStat && $testStat['mime'] !== 'directory') || (!$testStat && !$testStat = $this->mkdir($this->encode($dst), $name))) {\n                return $this->setError(elFinder::ERROR_COPY, $this->path($srcStat['hash']));\n            }\n\n            $dst = $this->decode($testStat['hash']);\n\n            // start time\n            $stime = microtime(true);\n            foreach ($this->getScandir($src) as $stat) {\n                if (empty($stat['hidden'])) {\n                    // current time\n                    $ctime = microtime(true);\n                    if (($ctime - $stime) > 2) {\n                        $stime = $ctime;\n                        elFinder::checkAborted();\n                    }\n                    $name = $stat['name'];\n                    $_src = $this->decode($stat['hash']);\n                    if (!$this->copy($_src, $dst, $name)) {\n                        $this->remove($dst, true); // fall back\n                        return $this->setError($this->error, elFinder::ERROR_COPY, $this->_path($src));\n                    }\n                }\n            }\n\n            $this->added[] = $testStat;\n\n            return $dst;\n        }\n\n        if ($this->options['copyJoin']) {\n            $test = $this->joinPathCE($dst, $name);\n            if ($this->isNameExists($test)) {\n                $this->remove($test);\n            }\n        }\n        if ($res = $this->convEncOut($this->_copy($this->convEncIn($src), $this->convEncIn($dst), $this->convEncIn($name)))) {\n            $path = is_string($res) ? $res : $this->joinPathCE($dst, $name);\n            $this->clearstatcache();\n            $this->added[] = $this->stat($path);\n            return $path;\n        }\n\n        return $this->setError(elFinder::ERROR_COPY, $this->path($srcStat['hash']));\n    }\n\n    /**\n     * Move file\n     * Return new file path or false.\n     *\n     * @param  string $src  source path\n     * @param  string $dst  destination dir path\n     * @param  string $name new file name\n     *\n     * @return string|false\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function move($src, $dst, $name)\n    {\n        $stat = $this->stat($src);\n        $stat['realpath'] = $src;\n        $this->rmTmb($stat); // can not do rmTmb() after _move()\n        $this->clearcache();\n\n        if ($res = $this->convEncOut($this->_move($this->convEncIn($src), $this->convEncIn($dst), $this->convEncIn($name)))) {\n            $this->clearstatcache();\n            if ($stat['mime'] === 'directory') {\n                $this->updateSubdirsCache($dst, true);\n            }\n            $path = is_string($res) ? $res : $this->joinPathCE($dst, $name);\n            $this->added[] = $this->stat($path);\n            $this->removed[] = $stat;\n            return $path;\n        }\n\n        return $this->setError(elFinder::ERROR_MOVE, $this->path($stat['hash']));\n    }\n\n    /**\n     * Copy file from another volume.\n     * Return new file path or false.\n     *\n     * @param  Object $volume      source volume\n     * @param  string $src         source file hash\n     * @param  string $destination destination dir path\n     * @param  string $name        file name\n     *\n     * @return string|false\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function copyFrom($volume, $src, $destination, $name)\n    {\n\n        elFinder::checkAborted();\n\n        if (($source = $volume->file($src)) == false) {\n            return $this->addError(elFinder::ERROR_COPY, '#' . $src, $volume->error());\n        }\n\n        $srcIsDir = ($source['mime'] === 'directory');\n\n        $errpath = $volume->path($source['hash']);\n\n        $errors = array();\n        try {\n            $thash = $this->encode($destination);\n            elFinder::$instance->trigger('paste.copyfrom', array(&$thash, &$name, '', elFinder::$instance, $this), $errors);\n        } catch (elFinderTriggerException $e) {\n            return $this->addError(elFinder::ERROR_COPY, $name, $errors);\n        }\n\n        if (!$this->nameAccepted($name, $srcIsDir)) {\n            return $this->addError(elFinder::ERROR_COPY, $name, $srcIsDir ? elFinder::ERROR_INVALID_DIRNAME : elFinder::ERROR_INVALID_NAME);\n        }\n\n        if (!$this->allowCreate($destination, $name, $srcIsDir)) {\n            return $this->addError(elFinder::ERROR_COPY, $name, elFinder::ERROR_PERM_DENIED);\n        }\n\n        if (!$source['read']) {\n            return $this->addError(elFinder::ERROR_COPY, $errpath, elFinder::ERROR_PERM_DENIED);\n        }\n\n        if ($srcIsDir) {\n            $test = $this->isNameExists($this->joinPathCE($destination, $name));\n            $this->clearcache();\n\n            if (($test && $test['mime'] != 'directory') || (!$test && !$test = $this->mkdir($this->encode($destination), $name))) {\n                return $this->addError(elFinder::ERROR_COPY, $errpath);\n            }\n\n            //$path = $this->joinPathCE($destination, $name);\n            $path = $this->decode($test['hash']);\n\n            foreach ($volume->scandir($src) as $entr) {\n                $this->copyFrom($volume, $entr['hash'], $path, $entr['name']);\n            }\n\n            $this->added[] = $test;\n        } else {\n            // size check\n            if (!isset($source['size']) || $source['size'] > $this->uploadMaxSize) {\n                return $this->setError(elFinder::ERROR_UPLOAD_FILE_SIZE);\n            }\n\n            // MIME check\n            $mimeByName = $this->mimetype($source['name'], true);\n            if ($source['mime'] === $mimeByName) {\n                $mimeByName = '';\n            }\n            if (!$this->allowPutMime($source['mime']) || ($mimeByName && !$this->allowPutMime($mimeByName))) {\n                return $this->addError(elFinder::ERROR_UPLOAD_FILE_MIME, $errpath);\n            }\n\n            if (strpos($source['mime'], 'image') === 0 && ($dim = $volume->dimensions($src))) {\n                if (is_array($dim)) {\n                    $dim = isset($dim['dim']) ? $dim['dim'] : null;\n                }\n                if ($dim) {\n                    $s = explode('x', $dim);\n                    $source['width'] = $s[0];\n                    $source['height'] = $s[1];\n                }\n            }\n\n            if (($fp = $volume->open($src)) == false\n                || ($path = $this->saveCE($fp, $destination, $name, $source)) == false) {\n                $fp && $volume->close($fp, $src);\n                return $this->addError(elFinder::ERROR_COPY, $errpath);\n            }\n            $volume->close($fp, $src);\n\n            $this->added[] = $this->stat($path);;\n        }\n\n        return $path;\n    }\n\n    /**\n     * Remove file/ recursive remove dir\n     *\n     * @param  string $path  file path\n     * @param  bool   $force try to remove even if file locked\n     *\n     * @return bool\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function remove($path, $force = false)\n    {\n        $stat = $this->stat($path);\n\n        if (empty($stat)) {\n            return $this->setError(elFinder::ERROR_RM, $this->relpathCE($path), elFinder::ERROR_FILE_NOT_FOUND);\n        }\n\n        $stat['realpath'] = $path;\n        $this->rmTmb($stat);\n        $this->clearcache();\n\n        if (!$force && !empty($stat['locked'])) {\n            return $this->setError(elFinder::ERROR_LOCKED, $this->path($stat['hash']));\n        }\n\n        if ($stat['mime'] == 'directory' && empty($stat['thash'])) {\n            $ret = $this->delTree($this->convEncIn($path));\n            $this->convEncOut();\n            if (!$ret) {\n                return $this->setError(elFinder::ERROR_RM, $this->path($stat['hash']));\n            }\n        } else {\n            if ($this->convEncOut(!$this->_unlink($this->convEncIn($path)))) {\n                return $this->setError(elFinder::ERROR_RM, $this->path($stat['hash']));\n            }\n            $this->clearstatcache();\n        }\n\n        $this->removed[] = $stat;\n        return true;\n    }\n\n\n    /************************* thumbnails **************************/\n\n    /**\n     * Return thumbnail file name for required file\n     *\n     * @param  array $stat file stat\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function tmbname($stat)\n    {\n        $name = $stat['hash'] . (isset($stat['ts']) ? $stat['ts'] : '') . '.png';\n        if (strlen($name) > 255) {\n            $name = $this->id . md5($stat['hash']) . $stat['ts'] . '.png';\n        }\n        return $name;\n    }\n\n    /**\n     * Return thumnbnail name if exists\n     *\n     * @param  string $path file path\n     * @param  array  $stat file stat\n     *\n     * @return string|false\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function gettmb($path, $stat)\n    {\n        if ($this->tmbURL && $this->tmbPath) {\n            // file itself thumnbnail\n            if (strpos($path, $this->tmbPath) === 0) {\n                return basename($path);\n            }\n\n            $name = $this->tmbname($stat);\n            $tmb = $this->tmbPath . DIRECTORY_SEPARATOR . $name;\n            if (file_exists($tmb)) {\n                if ($this->options['tmbGcMaxlifeHour'] && $this->options['tmbGcPercentage'] > 0) {\n                    touch($tmb);\n                }\n                return $name;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return true if thumnbnail for required file can be created\n     *\n     * @param  string $path thumnbnail path\n     * @param  array  $stat file stat\n     * @param  bool   $checkTmbPath\n     *\n     * @return string|bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function canCreateTmb($path, $stat, $checkTmbPath = true)\n    {\n        static $gdMimes = null;\n        static $imgmgPS = null;\n        if ($gdMimes === null) {\n            $_mimes = array('image/jpeg', 'image/png', 'image/gif', 'image/x-ms-bmp');\n            if (function_exists('imagecreatefromwebp')) {\n                $_mimes[] = 'image/webp';\n            }\n            $gdMimes = array_flip($_mimes);\n            $imgmgPS = array_flip(array('application/postscript', 'application/pdf'));\n        }\n        if ((!$checkTmbPath || $this->tmbPathWritable)\n            && (!$this->tmbPath || strpos($path, $this->tmbPath) === false) // do not create thumnbnail for thumnbnail\n        ) {\n            $mime = strtolower($stat['mime']);\n            list($type) = explode('/', $mime);\n            if (!empty($this->imgConverter)) {\n                if (isset($this->imgConverter[$mime])) {\n                    return true;\n                }\n                if (isset($this->imgConverter[$type])) {\n                    return true;\n                }\n            }\n            return $this->imgLib\n                && (\n                    ($type === 'image' && ($this->imgLib === 'gd' ? isset($gdMimes[$stat['mime']]) : true))\n                    ||\n                    (ELFINDER_IMAGEMAGICK_PS && isset($imgmgPS[$stat['mime']]) && $this->imgLib !== 'gd')\n                );\n        }\n        return false;\n    }\n\n    /**\n     * Return true if required file can be resized.\n     * By default - the same as canCreateTmb\n     *\n     * @param  string $path thumnbnail path\n     * @param  array  $stat file stat\n     *\n     * @return string|bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function canResize($path, $stat)\n    {\n        return $this->canCreateTmb($path, $stat, false);\n    }\n\n    /**\n     * Create thumnbnail and return it's URL on success\n     *\n     * @param  string $path file path\n     * @param         $stat\n     *\n     * @return false|string\n     * @internal param string $mime file mime type\n     * @throws elFinderAbortException\n     * @throws ImagickException\n     * @author   Dmitry (dio) Levashov\n     */\n    protected function createTmb($path, $stat)\n    {\n        if (!$stat || !$this->canCreateTmb($path, $stat)) {\n            return false;\n        }\n\n        $name = $this->tmbname($stat);\n        $tmb = $this->tmbPath . DIRECTORY_SEPARATOR . $name;\n\n        $maxlength = -1;\n        $imgConverter = null;\n\n        // check imgConverter\n        $mime = strtolower($stat['mime']);\n        list($type) = explode('/', $mime);\n        if (isset($this->imgConverter[$mime])) {\n            $imgConverter = $this->imgConverter[$mime]['func'];\n            if (!empty($this->imgConverter[$mime]['maxlen'])) {\n                $maxlength = intval($this->imgConverter[$mime]['maxlen']);\n            }\n        } else if (isset($this->imgConverter[$type])) {\n            $imgConverter = $this->imgConverter[$type]['func'];\n            if (!empty($this->imgConverter[$type]['maxlen'])) {\n                $maxlength = intval($this->imgConverter[$type]['maxlen']);\n            }\n        }\n        if ($imgConverter && !is_callable($imgConverter)) {\n            return false;\n        }\n\n        // copy image into tmbPath so some drivers does not store files on local fs\n        if (($src = $this->fopenCE($path, 'rb')) == false) {\n            return false;\n        }\n\n        if (($trg = fopen($tmb, 'wb')) == false) {\n            $this->fcloseCE($src, $path);\n            return false;\n        }\n\n        stream_copy_to_stream($src, $trg, $maxlength);\n\n        $this->fcloseCE($src, $path);\n        fclose($trg);\n\n        // call imgConverter\n        if ($imgConverter) {\n            if (!call_user_func_array($imgConverter, array($tmb, $stat, $this))) {\n                file_exists($tmb) && unlink($tmb);\n                return false;\n            }\n        }\n\n        $result = false;\n\n        $tmbSize = $this->tmbSize;\n\n        if ($this->imgLib === 'imagick') {\n            try {\n                $imagickTest = new imagick($tmb . '[0]');\n                $imagickTest->clear();\n                $imagickTest = true;\n            } catch (Exception $e) {\n                $imagickTest = false;\n            }\n        }\n\n        if (($this->imgLib === 'imagick' && !$imagickTest) || ($s = getimagesize($tmb)) === false) {\n            if ($this->imgLib === 'imagick') {\n                $bgcolor = $this->options['tmbBgColor'];\n                if ($bgcolor === 'transparent') {\n                    $bgcolor = 'rgba(255, 255, 255, 0.0)';\n                }\n                try {\n                    $imagick = new imagick();\n                    $imagick->setBackgroundColor(new ImagickPixel($bgcolor));\n                    $imagick->readImage($this->getExtentionByMime($stat['mime'], ':') . $tmb . '[0]');\n                    try {\n                        $imagick->trimImage(0);\n                    } catch (Exception $e) {\n                    }\n                    $imagick->setImageFormat('png');\n                    $imagick->writeImage($tmb);\n                    $imagick->clear();\n                    if (($s = getimagesize($tmb)) !== false) {\n                        $result = true;\n                    }\n                } catch (Exception $e) {\n                }\n            } else if ($this->imgLib === 'convert') {\n                $convParams = $this->imageMagickConvertPrepare($tmb, 'png', 100, array(), $stat['mime']);\n                $cmd = sprintf('%s -colorspace sRGB -trim -- %s %s', ELFINDER_CONVERT_PATH, $convParams['quotedPath'], $convParams['quotedDstPath']);\n                $result = false;\n                if ($this->procExec($cmd) === 0) {\n                    if (($s = getimagesize($tmb)) !== false) {\n                        $result = true;\n                    }\n                }\n            }\n            if (!$result) {\n                // fallback imgLib to GD\n                if (function_exists('gd_info') && ($s = getimagesize($tmb))) {\n                    $this->imgLib = 'gd';\n                } else {\n                    file_exists($tmb) && unlink($tmb);\n                    return false;\n                }\n            }\n        }\n\n        /* If image smaller or equal thumbnail size - just fitting to thumbnail square */\n        if ($s[0] <= $tmbSize && $s[1] <= $tmbSize) {\n            $result = $this->imgSquareFit($tmb, $tmbSize, $tmbSize, 'center', 'middle', $this->options['tmbBgColor'], 'png');\n        } else {\n\n            if ($this->options['tmbCrop']) {\n\n                $result = $tmb;\n                /* Resize and crop if image bigger than thumbnail */\n                if (!(($s[0] > $tmbSize && $s[1] <= $tmbSize) || ($s[0] <= $tmbSize && $s[1] > $tmbSize)) || ($s[0] > $tmbSize && $s[1] > $tmbSize)) {\n                    $result = $this->imgResize($tmb, $tmbSize, $tmbSize, true, false, 'png');\n                }\n\n                if ($result && ($s = getimagesize($tmb)) != false) {\n                    $x = $s[0] > $tmbSize ? intval(($s[0] - $tmbSize) / 2) : 0;\n                    $y = $s[1] > $tmbSize ? intval(($s[1] - $tmbSize) / 2) : 0;\n                    $result = $this->imgCrop($result, $tmbSize, $tmbSize, $x, $y, 'png');\n                } else {\n                    $result = false;\n                }\n\n            } else {\n                $result = $this->imgResize($tmb, $tmbSize, $tmbSize, true, true, 'png');\n            }\n\n            if ($result) {\n                if ($s = getimagesize($tmb)) {\n                    if ($s[0] !== $tmbSize || $s[1] !== $tmbSize) {\n                        $result = $this->imgSquareFit($result, $tmbSize, $tmbSize, 'center', 'middle', $this->options['tmbBgColor'], 'png');\n                    }\n                }\n            }\n        }\n\n        if (!$result) {\n            unlink($tmb);\n            return false;\n        }\n\n        return $name;\n    }\n\n    /**\n     * Resize image\n     *\n     * @param  string $path               image file\n     * @param  int    $width              new width\n     * @param  int    $height             new height\n     * @param  bool   $keepProportions    crop image\n     * @param  bool   $resizeByBiggerSide resize image based on bigger side if true\n     * @param  string $destformat         image destination format\n     * @param  int    $jpgQuality         JEPG quality (1-100)\n     * @param  array  $options            Other extra options\n     *\n     * @return string|false\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     * @author Alexey Sukhotin\n     */\n    protected function imgResize($path, $width, $height, $keepProportions = false, $resizeByBiggerSide = true, $destformat = null, $jpgQuality = null, $options = array())\n    {\n        if (($s = getimagesize($path)) == false) {\n            return false;\n        }\n\n        if (!$jpgQuality) {\n            $jpgQuality = $this->options['jpgQuality'];\n        }\n\n        list($orig_w, $orig_h) = array($s[0], $s[1]);\n        list($size_w, $size_h) = array($width, $height);\n\n        if (empty($options['unenlarge']) || $orig_w > $size_w || $orig_h > $size_h) {\n            if ($keepProportions == true) {\n                /* Resizing by biggest side */\n                if ($resizeByBiggerSide) {\n                    if ($orig_w > $orig_h) {\n                        $size_h = round($orig_h * $width / $orig_w);\n                        $size_w = $width;\n                    } else {\n                        $size_w = round($orig_w * $height / $orig_h);\n                        $size_h = $height;\n                    }\n                } else {\n                    if ($orig_w > $orig_h) {\n                        $size_w = round($orig_w * $height / $orig_h);\n                        $size_h = $height;\n                    } else {\n                        $size_h = round($orig_h * $width / $orig_w);\n                        $size_w = $width;\n                    }\n                }\n            }\n        } else {\n            $size_w = $orig_w;\n            $size_h = $orig_h;\n        }\n\n        elFinder::extendTimeLimit(300);\n        switch ($this->imgLib) {\n            case 'imagick':\n\n                try {\n                    $img = new imagick($path);\n                } catch (Exception $e) {\n                    return false;\n                }\n\n                // Imagick::FILTER_BOX faster than FILTER_LANCZOS so use for createTmb\n                // resize bench: http://app-mgng.rhcloud.com/9\n                // resize sample: http://www.dylanbeattie.net/magick/filters/result.html\n                $filter = ($destformat === 'png' /* createTmb */) ? Imagick::FILTER_BOX : Imagick::FILTER_LANCZOS;\n\n                $ani = ($img->getNumberImages() > 1);\n                if ($ani && is_null($destformat)) {\n                    $img = $img->coalesceImages();\n                    do {\n                        $img->resizeImage($size_w, $size_h, $filter, 1);\n                    } while ($img->nextImage());\n                    $img->optimizeImageLayers();\n                    $result = $img->writeImages($path, true);\n                } else {\n                    if ($ani) {\n                        $img->setFirstIterator();\n                    }\n                    if (strtoupper($img->getImageFormat()) === 'JPEG') {\n                        $img->setImageCompression(imagick::COMPRESSION_JPEG);\n                        $img->setImageCompressionQuality($jpgQuality);\n                        if (isset($options['preserveExif']) && !$options['preserveExif']) {\n                            try {\n                                $orientation = $img->getImageOrientation();\n                            } catch (ImagickException $e) {\n                                $orientation = 0;\n                            }\n                            $img->stripImage();\n                            if ($orientation) {\n                                $img->setImageOrientation($orientation);\n                            }\n                        }\n                        if ($this->options['jpgProgressive']) {\n                            $img->setInterlaceScheme(Imagick::INTERLACE_PLANE);\n                        }\n                    }\n                    $img->resizeImage($size_w, $size_h, $filter, true);\n                    if ($destformat) {\n                        $result = $this->imagickImage($img, $path, $destformat, $jpgQuality);\n                    } else {\n                        $result = $img->writeImage($path);\n                    }\n                }\n\n                $img->clear();\n\n                return $result ? $path : false;\n\n                break;\n\n            case 'convert':\n                extract($this->imageMagickConvertPrepare($path, $destformat, $jpgQuality, $s));\n                /**\n                 * @var string $ani\n                 * @var string $index\n                 * @var string $coalesce\n                 * @var string $deconstruct\n                 * @var string $jpgQuality\n                 * @var string $quotedPath\n                 * @var string $quotedDstPath\n                 * @var string $interlace\n                 */\n                $filter = ($destformat === 'png' /* createTmb */) ? '-filter Box' : '-filter Lanczos';\n                $strip = (isset($options['preserveExif']) && !$options['preserveExif']) ? ' -strip' : '';\n                $cmd = sprintf('%s %s%s%s%s%s %s -geometry %dx%d! %s %s', ELFINDER_CONVERT_PATH, $quotedPath, $coalesce, $jpgQuality, $strip, $interlace, $filter, $size_w, $size_h, $deconstruct, $quotedDstPath);\n\n                $result = false;\n                if ($this->procExec($cmd) === 0) {\n                    $result = true;\n                }\n                return $result ? $path : false;\n\n                break;\n\n            case 'gd':\n                elFinder::expandMemoryForGD(array($s, array($size_w, $size_h)));\n                $img = $this->gdImageCreate($path, $s['mime']);\n\n                if ($img && false != ($tmp = imagecreatetruecolor($size_w, $size_h))) {\n\n                    $bgNum = false;\n                    if ($s[2] === IMAGETYPE_GIF && (!$destformat || $destformat === 'gif')) {\n                        $bgIdx = imagecolortransparent($img);\n                        if ($bgIdx !== -1) {\n                            $c = imagecolorsforindex($img, $bgIdx);\n                            $bgNum = imagecolorallocate($tmp, $c['red'], $c['green'], $c['blue']);\n                            imagefill($tmp, 0, 0, $bgNum);\n                            imagecolortransparent($tmp, $bgNum);\n                        }\n                    }\n                    if ($bgNum === false) {\n                        $this->gdImageBackground($tmp, 'transparent');\n                    }\n\n                    if (!imagecopyresampled($tmp, $img, 0, 0, 0, 0, $size_w, $size_h, $s[0], $s[1])) {\n                        return false;\n                    }\n\n                    $result = $this->gdImage($tmp, $path, $destformat, $s['mime'], $jpgQuality);\n\n                    imagedestroy($img);\n                    imagedestroy($tmp);\n\n                    return $result ? $path : false;\n\n                }\n                break;\n        }\n\n        return false;\n    }\n\n    /**\n     * Crop image\n     *\n     * @param  string $path       image file\n     * @param  int    $width      crop width\n     * @param  int    $height     crop height\n     * @param  bool   $x          crop left offset\n     * @param  bool   $y          crop top offset\n     * @param  string $destformat image destination format\n     * @param  int    $jpgQuality JEPG quality (1-100)\n     *\n     * @return string|false\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     * @author Alexey Sukhotin\n     */\n    protected function imgCrop($path, $width, $height, $x, $y, $destformat = null, $jpgQuality = null)\n    {\n        if (($s = getimagesize($path)) == false) {\n            return false;\n        }\n\n        if (!$jpgQuality) {\n            $jpgQuality = $this->options['jpgQuality'];\n        }\n\n        elFinder::extendTimeLimit(300);\n        switch ($this->imgLib) {\n            case 'imagick':\n\n                try {\n                    $img = new imagick($path);\n                } catch (Exception $e) {\n                    return false;\n                }\n\n                $ani = ($img->getNumberImages() > 1);\n                if ($ani && is_null($destformat)) {\n                    $img = $img->coalesceImages();\n                    do {\n                        $img->setImagePage($s[0], $s[1], 0, 0);\n                        $img->cropImage($width, $height, $x, $y);\n                        $img->setImagePage($width, $height, 0, 0);\n                    } while ($img->nextImage());\n                    $img->optimizeImageLayers();\n                    $result = $img->writeImages($path, true);\n                } else {\n                    if ($ani) {\n                        $img->setFirstIterator();\n                    }\n                    $img->setImagePage($s[0], $s[1], 0, 0);\n                    $img->cropImage($width, $height, $x, $y);\n                    $img->setImagePage($width, $height, 0, 0);\n                    $result = $this->imagickImage($img, $path, $destformat, $jpgQuality);\n                }\n\n                $img->clear();\n\n                return $result ? $path : false;\n\n                break;\n\n            case 'convert':\n                extract($this->imageMagickConvertPrepare($path, $destformat, $jpgQuality, $s));\n                /**\n                 * @var string $ani\n                 * @var string $index\n                 * @var string $coalesce\n                 * @var string $deconstruct\n                 * @var string $jpgQuality\n                 * @var string $quotedPath\n                 * @var string $quotedDstPath\n                 * @var string $interlace\n                 */\n                $cmd = sprintf('%s %s%s%s%s -crop %dx%d+%d+%d%s %s', ELFINDER_CONVERT_PATH, $quotedPath, $coalesce, $jpgQuality, $interlace, $width, $height, $x, $y, $deconstruct, $quotedDstPath);\n\n                $result = false;\n                if ($this->procExec($cmd) === 0) {\n                    $result = true;\n                }\n                return $result ? $path : false;\n\n                break;\n\n            case 'gd':\n                elFinder::expandMemoryForGD(array($s, array($width, $height)));\n                $img = $this->gdImageCreate($path, $s['mime']);\n\n                if ($img && false != ($tmp = imagecreatetruecolor($width, $height))) {\n\n                    $bgNum = false;\n                    if ($s[2] === IMAGETYPE_GIF && (!$destformat || $destformat === 'gif')) {\n                        $bgIdx = imagecolortransparent($img);\n                        if ($bgIdx !== -1) {\n                            $c = imagecolorsforindex($img, $bgIdx);\n                            $bgNum = imagecolorallocate($tmp, $c['red'], $c['green'], $c['blue']);\n                            imagefill($tmp, 0, 0, $bgNum);\n                            imagecolortransparent($tmp, $bgNum);\n                        }\n                    }\n                    if ($bgNum === false) {\n                        $this->gdImageBackground($tmp, 'transparent');\n                    }\n\n                    $size_w = $width;\n                    $size_h = $height;\n\n                    if ($s[0] < $width || $s[1] < $height) {\n                        $size_w = $s[0];\n                        $size_h = $s[1];\n                    }\n\n                    if (!imagecopy($tmp, $img, 0, 0, $x, $y, $size_w, $size_h)) {\n                        return false;\n                    }\n\n                    $result = $this->gdImage($tmp, $path, $destformat, $s['mime'], $jpgQuality);\n\n                    imagedestroy($img);\n                    imagedestroy($tmp);\n\n                    return $result ? $path : false;\n\n                }\n                break;\n        }\n\n        return false;\n    }\n\n    /**\n     * Put image to square\n     *\n     * @param  string    $path       image file\n     * @param  int       $width      square width\n     * @param  int       $height     square height\n     * @param int|string $align      reserved\n     * @param int|string $valign     reserved\n     * @param  string    $bgcolor    square background color in #rrggbb format\n     * @param  string    $destformat image destination format\n     * @param  int       $jpgQuality JEPG quality (1-100)\n     *\n     * @return false|string\n     * @throws ImagickException\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     * @author Alexey Sukhotin\n     */\n    protected function imgSquareFit($path, $width, $height, $align = 'center', $valign = 'middle', $bgcolor = '#0000ff', $destformat = null, $jpgQuality = null)\n    {\n        if (($s = getimagesize($path)) == false) {\n            return false;\n        }\n\n        $result = false;\n\n        /* Coordinates for image over square aligning */\n        $y = ceil(abs($height - $s[1]) / 2);\n        $x = ceil(abs($width - $s[0]) / 2);\n\n        if (!$jpgQuality) {\n            $jpgQuality = $this->options['jpgQuality'];\n        }\n\n        elFinder::extendTimeLimit(300);\n        switch ($this->imgLib) {\n            case 'imagick':\n                try {\n                    $img = new imagick($path);\n                } catch (Exception $e) {\n                    return false;\n                }\n\n                if ($bgcolor === 'transparent') {\n                    $bgcolor = 'rgba(255, 255, 255, 0.0)';\n                }\n                $ani = ($img->getNumberImages() > 1);\n                if ($ani && is_null($destformat)) {\n                    $img1 = new Imagick();\n                    $img1->setFormat('gif');\n                    $img = $img->coalesceImages();\n                    do {\n                        $gif = new Imagick();\n                        $gif->newImage($width, $height, new ImagickPixel($bgcolor));\n                        $gif->setImageColorspace($img->getImageColorspace());\n                        $gif->setImageFormat('gif');\n                        $gif->compositeImage($img, imagick::COMPOSITE_OVER, $x, $y);\n                        $gif->setImageDelay($img->getImageDelay());\n                        $gif->setImageIterations($img->getImageIterations());\n                        $img1->addImage($gif);\n                        $gif->clear();\n                    } while ($img->nextImage());\n                    $img1->optimizeImageLayers();\n                    $result = $img1->writeImages($path, true);\n                } else {\n                    if ($ani) {\n                        $img->setFirstIterator();\n                    }\n                    $img1 = new Imagick();\n                    $img1->newImage($width, $height, new ImagickPixel($bgcolor));\n                    $img1->setImageColorspace($img->getImageColorspace());\n                    $img1->compositeImage($img, imagick::COMPOSITE_OVER, $x, $y);\n                    $result = $this->imagickImage($img1, $path, $destformat, $jpgQuality);\n                }\n\n                $img1->clear();\n                $img->clear();\n                return $result ? $path : false;\n\n                break;\n\n            case 'convert':\n                extract($this->imageMagickConvertPrepare($path, $destformat, $jpgQuality, $s));\n                /**\n                 * @var string $ani\n                 * @var string $index\n                 * @var string $coalesce\n                 * @var string $deconstruct\n                 * @var string $jpgQuality\n                 * @var string $quotedPath\n                 * @var string $quotedDstPath\n                 * @var string $interlace\n                 */\n                if ($bgcolor === 'transparent') {\n                    $bgcolor = 'rgba(255, 255, 255, 0.0)';\n                }\n                $cmd = sprintf('%s -size %dx%d \"xc:%s\" png:- | convert%s%s%s png:-  %s -geometry +%d+%d -compose over -composite%s %s', ELFINDER_CONVERT_PATH, $width, $height, $bgcolor, $coalesce, $jpgQuality, $interlace, $quotedPath, $x, $y, $deconstruct, $quotedDstPath);\n\n                $result = false;\n                if ($this->procExec($cmd) === 0) {\n                    $result = true;\n                }\n                return $result ? $path : false;\n\n                break;\n\n            case 'gd':\n                elFinder::expandMemoryForGD(array($s, array($width, $height)));\n                $img = $this->gdImageCreate($path, $s['mime']);\n\n                if ($img && false != ($tmp = imagecreatetruecolor($width, $height))) {\n\n                    $this->gdImageBackground($tmp, $bgcolor);\n                    if ($bgcolor === 'transparent' && ($destformat === 'png' || $s[2] === IMAGETYPE_PNG)) {\n                        $bgNum = imagecolorallocatealpha($tmp, 255, 255, 255, 127);\n                        imagefill($tmp, 0, 0, $bgNum);\n                    }\n\n                    if (!imagecopy($tmp, $img, $x, $y, 0, 0, $s[0], $s[1])) {\n                        return false;\n                    }\n\n                    $result = $this->gdImage($tmp, $path, $destformat, $s['mime'], $jpgQuality);\n\n                    imagedestroy($img);\n                    imagedestroy($tmp);\n\n                    return $result ? $path : false;\n                }\n                break;\n        }\n\n        return false;\n    }\n\n    /**\n     * Rotate image\n     *\n     * @param  string $path       image file\n     * @param  int    $degree     rotete degrees\n     * @param  string $bgcolor    square background color in #rrggbb format\n     * @param  string $destformat image destination format\n     * @param  int    $jpgQuality JEPG quality (1-100)\n     *\n     * @return string|false\n     * @throws elFinderAbortException\n     * @author nao-pon\n     * @author Troex Nevelin\n     */\n    protected function imgRotate($path, $degree, $bgcolor = '#ffffff', $destformat = null, $jpgQuality = null)\n    {\n        if (($s = getimagesize($path)) == false || $degree % 360 === 0) {\n            return false;\n        }\n\n        $result = false;\n\n        // try lossless rotate\n        if ($degree % 90 === 0 && in_array($s[2], array(IMAGETYPE_JPEG, IMAGETYPE_JPEG2000))) {\n            $count = ($degree / 90) % 4;\n            $exiftran = array(\n                1 => '-9',\n                2 => '-1',\n                3 => '-2'\n            );\n            $jpegtran = array(\n                1 => '90',\n                2 => '180',\n                3 => '270'\n            );\n            $quotedPath = escapeshellarg($path);\n            $cmds = array();\n            if ($this->procExec(ELFINDER_EXIFTRAN_PATH . ' -h') === 0) {\n                $cmds[] = ELFINDER_EXIFTRAN_PATH . ' -i ' . $exiftran[$count] . ' -- ' . $quotedPath;\n            }\n            if ($this->procExec(ELFINDER_JPEGTRAN_PATH . ' -version') === 0) {\n                $cmds[] = ELFINDER_JPEGTRAN_PATH . ' -rotate ' . $jpegtran[$count] . ' -copy all -outfile ' . $quotedPath . ' -- ' . $quotedPath;\n            }\n            foreach ($cmds as $cmd) {\n                if ($this->procExec($cmd) === 0) {\n                    $result = true;\n                    break;\n                }\n            }\n            if ($result) {\n                return $path;\n            }\n        }\n\n        if (!$jpgQuality) {\n            $jpgQuality = $this->options['jpgQuality'];\n        }\n\n        elFinder::extendTimeLimit(300);\n        switch ($this->imgLib) {\n            case 'imagick':\n                try {\n                    $img = new imagick($path);\n                } catch (Exception $e) {\n                    return false;\n                }\n\n                if ($s[2] === IMAGETYPE_GIF || $s[2] === IMAGETYPE_PNG) {\n                    $bgcolor = 'rgba(255, 255, 255, 0.0)';\n                }\n                if ($img->getNumberImages() > 1) {\n                    $img = $img->coalesceImages();\n                    do {\n                        $img->rotateImage(new ImagickPixel($bgcolor), $degree);\n                    } while ($img->nextImage());\n                    $img->optimizeImageLayers();\n                    $result = $img->writeImages($path, true);\n                } else {\n                    $img->rotateImage(new ImagickPixel($bgcolor), $degree);\n                    $result = $this->imagickImage($img, $path, $destformat, $jpgQuality);\n                }\n                $img->clear();\n                return $result ? $path : false;\n\n                break;\n\n            case 'convert':\n                extract($this->imageMagickConvertPrepare($path, $destformat, $jpgQuality, $s));\n                /**\n                 * @var string $ani\n                 * @var string $index\n                 * @var string $coalesce\n                 * @var string $deconstruct\n                 * @var string $jpgQuality\n                 * @var string $quotedPath\n                 * @var string $quotedDstPath\n                 * @var string $interlace\n                 */\n                if ($s[2] === IMAGETYPE_GIF || $s[2] === IMAGETYPE_PNG) {\n                    $bgcolor = 'rgba(255, 255, 255, 0.0)';\n                }\n                $cmd = sprintf('%s%s%s%s -background \"%s\" -rotate %d%s -- %s %s', ELFINDER_CONVERT_PATH, $coalesce, $jpgQuality, $interlace, $bgcolor, $degree, $deconstruct, $quotedPath, $quotedDstPath);\n\n                $result = false;\n                if ($this->procExec($cmd) === 0) {\n                    $result = true;\n                }\n                return $result ? $path : false;\n\n                break;\n\n            case 'gd':\n                elFinder::expandMemoryForGD(array($s, $s));\n                $img = $this->gdImageCreate($path, $s['mime']);\n\n                $degree = 360 - $degree;\n\n                $bgNum = -1;\n                $bgIdx = false;\n                if ($s[2] === IMAGETYPE_GIF) {\n                    $bgIdx = imagecolortransparent($img);\n                    if ($bgIdx !== -1) {\n                        $c = imagecolorsforindex($img, $bgIdx);\n                        $w = imagesx($img);\n                        $h = imagesy($img);\n                        $newImg = imagecreatetruecolor($w, $h);\n                        imagepalettecopy($newImg, $img);\n                        $bgNum = imagecolorallocate($newImg, $c['red'], $c['green'], $c['blue']);\n                        imagefill($newImg, 0, 0, $bgNum);\n                        imagecolortransparent($newImg, $bgNum);\n                        imagecopy($newImg, $img, 0, 0, 0, 0, $w, $h);\n                        imagedestroy($img);\n                        $img = $newImg;\n                        $newImg = null;\n                    }\n                } else if ($s[2] === IMAGETYPE_PNG) {\n                    $bgNum = imagecolorallocatealpha($img, 255, 255, 255, 127);\n                }\n                if ($bgNum === -1) {\n                    list($r, $g, $b) = sscanf($bgcolor, \"#%02x%02x%02x\");\n                    $bgNum = imagecolorallocate($img, $r, $g, $b);\n                }\n\n                $tmp = imageRotate($img, $degree, $bgNum);\n                if ($bgIdx !== -1) {\n                    imagecolortransparent($tmp, $bgNum);\n                }\n\n                $result = $this->gdImage($tmp, $path, $destformat, $s['mime'], $jpgQuality);\n\n                imageDestroy($img);\n                imageDestroy($tmp);\n\n                return $result ? $path : false;\n\n                break;\n        }\n\n        return false;\n    }\n\n    /**\n     * Execute shell command\n     *\n     * @param  string $command      command line\n     * @param  string $output       stdout strings\n     * @param  int    $return_var   process exit code\n     * @param  string $error_output stderr strings\n     *\n     * @return int exit code\n     * @throws elFinderAbortException\n     * @author Alexey Sukhotin\n     */\n    protected function procExec($command, &$output = '', &$return_var = -1, &$error_output = '', $cwd = null)\n    {\n        return elFinder::procExec($command, $output, $return_var, $error_output);\n    }\n\n    /**\n     * Remove thumbnail, also remove recursively if stat is directory\n     *\n     * @param  array $stat file stat\n     *\n     * @return void\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     * @author Naoki Sawada\n     * @author Troex Nevelin\n     */\n    protected function rmTmb($stat)\n    {\n        if ($this->tmbPathWritable) {\n            if ($stat['mime'] === 'directory') {\n                foreach ($this->scandirCE($this->decode($stat['hash'])) as $p) {\n                    elFinder::extendTimeLimit(30);\n                    $name = $this->basenameCE($p);\n                    $name != '.' && $name != '..' && $this->rmTmb($this->stat($p));\n                }\n            } else if (!empty($stat['tmb']) && $stat['tmb'] != \"1\") {\n                $tmb = $this->tmbPath . DIRECTORY_SEPARATOR . rawurldecode($stat['tmb']);\n                file_exists($tmb) && unlink($tmb);\n                clearstatcache();\n            }\n        }\n    }\n\n    /**\n     * Create an gd image according to the specified mime type\n     *\n     * @param string $path image file\n     * @param string $mime\n     *\n     * @return resource|false GD image resource identifier\n     */\n    protected function gdImageCreate($path, $mime)\n    {\n        switch ($mime) {\n            case 'image/jpeg':\n                return imagecreatefromjpeg($path);\n\n            case 'image/png':\n                return imagecreatefrompng($path);\n\n            case 'image/gif':\n                return imagecreatefromgif($path);\n\n            case 'image/x-ms-bmp':\n                if (!function_exists('imagecreatefrombmp')) {\n                    include_once dirname(__FILE__) . '/libs/GdBmp.php';\n                }\n                return imagecreatefrombmp($path);\n\n            case 'image/xbm':\n                return imagecreatefromxbm($path);\n\n            case 'image/xpm':\n                return imagecreatefromxpm($path);\n\n            case 'image/webp':\n                return imagecreatefromwebp($path);\n        }\n        return false;\n    }\n\n    /**\n     * Output gd image to file\n     *\n     * @param resource $image      gd image resource\n     * @param string   $filename   The path to save the file to.\n     * @param string   $destformat The Image type to use for $filename\n     * @param string   $mime       The original image mime type\n     * @param int      $jpgQuality JEPG quality (1-100)\n     *\n     * @return bool\n     */\n    protected function gdImage($image, $filename, $destformat, $mime, $jpgQuality = null)\n    {\n\n        if (!$jpgQuality) {\n            $jpgQuality = $this->options['jpgQuality'];\n        }\n        if ($destformat) {\n            switch ($destformat) {\n                case 'jpg':\n                    $mime = 'image/jpeg';\n                    break;\n                case 'gif':\n                    $mime = 'image/gif';\n                    break;\n                case 'png':\n                default:\n                    $mime = 'image/png';\n                    break;\n            }\n        }\n        switch ($mime) {\n            case 'image/gif':\n                return imagegif($image, $filename);\n            case 'image/jpeg':\n                if ($this->options['jpgProgressive']) {\n                    imageinterlace($image, true);\n                }\n                return imagejpeg($image, $filename, $jpgQuality);\n            case 'image/wbmp':\n                return imagewbmp($image, $filename);\n            case 'image/png':\n            default:\n                return imagepng($image, $filename);\n        }\n    }\n\n    /**\n     * Output imagick image to file\n     *\n     * @param imagick $img        imagick image resource\n     * @param string  $filename   The path to save the file to.\n     * @param string  $destformat The Image type to use for $filename\n     * @param int     $jpgQuality JEPG quality (1-100)\n     *\n     * @return bool\n     */\n    protected function imagickImage($img, $filename, $destformat, $jpgQuality = null)\n    {\n\n        if (!$jpgQuality) {\n            $jpgQuality = $this->options['jpgQuality'];\n        }\n\n        try {\n            if ($destformat) {\n                if ($destformat === 'gif') {\n                    $img->setImageFormat('gif');\n                } else if ($destformat === 'png') {\n                    $img->setImageFormat('png');\n                } else if ($destformat === 'jpg') {\n                    $img->setImageFormat('jpeg');\n                }\n            }\n            if (strtoupper($img->getImageFormat()) === 'JPEG') {\n                $img->setImageCompression(imagick::COMPRESSION_JPEG);\n                $img->setImageCompressionQuality($jpgQuality);\n                if ($this->options['jpgProgressive']) {\n                    $img->setInterlaceScheme(Imagick::INTERLACE_PLANE);\n                }\n                try {\n                    $orientation = $img->getImageOrientation();\n                } catch (ImagickException $e) {\n                    $orientation = 0;\n                }\n                $img->stripImage();\n                if ($orientation) {\n                    $img->setImageOrientation($orientation);\n                }\n            }\n            $result = $img->writeImage($filename);\n        } catch (Exception $e) {\n            $result = false;\n        }\n\n        return $result;\n    }\n\n    /**\n     * Assign the proper background to a gd image\n     *\n     * @param resource $image   gd image resource\n     * @param string   $bgcolor background color in #rrggbb format\n     */\n    protected function gdImageBackground($image, $bgcolor)\n    {\n\n        if ($bgcolor === 'transparent') {\n            imagealphablending($image, false);\n            imagesavealpha($image, true);\n        } else {\n            list($r, $g, $b) = sscanf($bgcolor, \"#%02x%02x%02x\");\n            $bgcolor1 = imagecolorallocate($image, $r, $g, $b);\n            imagefill($image, 0, 0, $bgcolor1);\n        }\n    }\n\n    /**\n     * Prepare variables for exec convert of ImageMagick\n     *\n     * @param  string $path\n     * @param  string $destformat\n     * @param  int    $jpgQuality\n     * @param  array  $imageSize\n     * @param null    $mime\n     *\n     * @return array\n     * @throws elFinderAbortException\n     */\n    protected function imageMagickConvertPrepare($path, $destformat, $jpgQuality, $imageSize = null, $mime = null)\n    {\n        if (is_null($imageSize)) {\n            $imageSize = getimagesize($path);\n        }\n        if (is_null($mime)) {\n            $mime = $this->mimetype($path);\n        }\n        $srcType = $this->getExtentionByMime($mime, ':');\n        $ani = false;\n        if (preg_match('/^(?:gif|png|ico)/', $srcType)) {\n            $cmd = ELFINDER_IDENTIFY_PATH . ' -- ' . escapeshellarg($srcType . $path);\n            if ($this->procExec($cmd, $o) === 0) {\n                $ani = preg_split('/(?:\\r\\n|\\n|\\r)/', trim($o));\n                if (count($ani) < 2) {\n                    $ani = false;\n                }\n            }\n        }\n        $coalesce = $index = $interlace = '';\n        $deconstruct = ' +repage';\n        if ($ani && $destformat !== 'png'/* not createTmb */) {\n            if (is_null($destformat)) {\n                $coalesce = ' -coalesce -repage 0x0';\n                $deconstruct = ' +repage -deconstruct -layers optimize';\n            } else if ($imageSize) {\n                if ($srcType === 'ico:') {\n                    $index = '[0]';\n                    foreach ($ani as $_i => $_info) {\n                        if (preg_match('/ (\\d+)x(\\d+) /', $_info, $m)) {\n                            if ($m[1] == $imageSize[0] && $m[2] == $imageSize[1]) {\n                                $index = '[' . $_i . ']';\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        } else {\n            $index = '[0]';\n        }\n        if ($imageSize && ($imageSize[2] === IMAGETYPE_JPEG || $imageSize[2] === IMAGETYPE_JPEG2000)) {\n            $jpgQuality = ' -quality ' . $jpgQuality;\n            if ($this->options['jpgProgressive']) {\n                $interlace = ' -interlace Plane';\n            }\n        } else {\n            $jpgQuality = '';\n        }\n        $quotedPath = escapeshellarg($srcType . $path . $index);\n        $quotedDstPath = escapeshellarg(($destformat ? ($destformat . ':') : $srcType) . $path);\n        return compact('ani', 'index', 'coalesce', 'deconstruct', 'jpgQuality', 'quotedPath', 'quotedDstPath', 'interlace');\n    }\n\n    /*********************** misc *************************/\n\n    /**\n     * Find position of first occurrence of string in a string with multibyte support\n     *\n     * @param  string $haystack The string being checked.\n     * @param  string $needle   The string to find in haystack.\n     * @param  int    $offset   The search offset. If it is not specified, 0 is used.\n     *\n     * @return int|bool\n     * @author Alexey Sukhotin\n     **/\n    protected function stripos($haystack, $needle, $offset = 0)\n    {\n        if (function_exists('mb_stripos')) {\n            return mb_stripos($haystack, $needle, $offset, 'UTF-8');\n        } else if (function_exists('mb_strtolower') && function_exists('mb_strpos')) {\n            return mb_strpos(mb_strtolower($haystack, 'UTF-8'), mb_strtolower($needle, 'UTF-8'), $offset);\n        }\n        return stripos($haystack, $needle, $offset);\n    }\n\n    /**\n     * Default serach match method (name match)\n     *\n     * @param  String $name  Item name\n     * @param  String $query Query word\n     * @param  String $path  Item path\n     *\n     * @return bool @return bool\n     */\n    protected function searchMatchName($name, $query, $path)\n    {\n        return $this->stripos($name, $query) !== false;\n    }\n\n    /**\n     * Get server side available archivers\n     *\n     * @param bool $use_cache\n     *\n     * @return array\n     * @throws elFinderAbortException\n     */\n    protected function getArchivers($use_cache = true)\n    {\n        $sessionKey = 'archivers';\n        if ($use_cache) {\n            if (isset($this->options['archivers']) && is_array($this->options['archivers']) && $this->options['archivers']) {\n                $cache = $this->options['archivers'];\n            } else {\n                $cache = elFinder::$archivers;\n            }\n            if ($cache) {\n                return $cache;\n            } else {\n                if ($cache = $this->session->get($sessionKey, array())) {\n                    return elFinder::$archivers = $cache;\n                }\n            }\n        }\n\n        $arcs = array(\n            'create' => array(),\n            'extract' => array()\n        );\n\n        if ($this->procExec('') === 0) {\n\n            $this->procExec(ELFINDER_TAR_PATH . ' --version', $o, $ctar);\n\n            if ($ctar == 0) {\n                $arcs['create']['application/x-tar'] = array('cmd' => ELFINDER_TAR_PATH, 'argc' => '-chf', 'ext' => 'tar');\n                $arcs['extract']['application/x-tar'] = array('cmd' => ELFINDER_TAR_PATH, 'argc' => '-xf', 'ext' => 'tar', 'toSpec' => '-C ', 'getsize' => array('argc' => '-xvf', 'toSpec' => '--to-stdout|wc -c', 'regex' => '/^.+(?:\\r\\n|\\n|\\r)[^\\r\\n0-9]*([0-9]+)[^\\r\\n]*$/s', 'replace' => '$1'));\n                unset($o);\n                $this->procExec(ELFINDER_GZIP_PATH . ' --version', $o, $c);\n                if ($c == 0) {\n                    $arcs['create']['application/x-gzip'] = array('cmd' => ELFINDER_TAR_PATH, 'argc' => '-czhf', 'ext' => 'tgz');\n                    $arcs['extract']['application/x-gzip'] = array('cmd' => ELFINDER_TAR_PATH, 'argc' => '-xzf', 'ext' => 'tgz', 'toSpec' => '-C ', 'getsize' => array('argc' => '-xvf', 'toSpec' => '--to-stdout|wc -c', 'regex' => '/^.+(?:\\r\\n|\\n|\\r)[^\\r\\n0-9]*([0-9]+)[^\\r\\n]*$/s', 'replace' => '$1'));\n                }\n                unset($o);\n                $this->procExec(ELFINDER_BZIP2_PATH . ' --version', $o, $c);\n                if ($c == 0) {\n                    $arcs['create']['application/x-bzip2'] = array('cmd' => ELFINDER_TAR_PATH, 'argc' => '-cjhf', 'ext' => 'tbz');\n                    $arcs['extract']['application/x-bzip2'] = array('cmd' => ELFINDER_TAR_PATH, 'argc' => '-xjf', 'ext' => 'tbz', 'toSpec' => '-C ', 'getsize' => array('argc' => '-xvf', 'toSpec' => '--to-stdout|wc -c', 'regex' => '/^.+(?:\\r\\n|\\n|\\r)[^\\r\\n0-9]*([0-9]+)[^\\r\\n]*$/s', 'replace' => '$1'));\n                }\n                unset($o);\n                $this->procExec(ELFINDER_XZ_PATH . ' --version', $o, $c);\n                if ($c == 0) {\n                    $arcs['create']['application/x-xz'] = array('cmd' => ELFINDER_TAR_PATH, 'argc' => '-cJhf', 'ext' => 'xz');\n                    $arcs['extract']['application/x-xz'] = array('cmd' => ELFINDER_TAR_PATH, 'argc' => '-xJf', 'ext' => 'xz', 'toSpec' => '-C ', 'getsize' => array('argc' => '-xvf', 'toSpec' => '--to-stdout|wc -c', 'regex' => '/^.+(?:\\r\\n|\\n|\\r)[^\\r\\n0-9]*([0-9]+)[^\\r\\n]*$/s', 'replace' => '$1'));\n                }\n            }\n            unset($o);\n            $this->procExec(ELFINDER_ZIP_PATH . ' -h', $o, $c);\n            if ($c == 0) {\n                $arcs['create']['application/zip'] = array('cmd' => ELFINDER_ZIP_PATH, 'argc' => '-r9 -q', 'ext' => 'zip');\n            }\n            unset($o);\n            $this->procExec(ELFINDER_UNZIP_PATH . ' --help', $o, $c);\n            if ($c == 0) {\n                $arcs['extract']['application/zip'] = array('cmd' => ELFINDER_UNZIP_PATH, 'argc' => '-q', 'ext' => 'zip', 'toSpec' => '-d ', 'getsize' => array('argc' => '-Z -t', 'regex' => '/^.+?,\\s?([0-9]+).+$/', 'replace' => '$1'));\n            }\n            unset($o);\n            $this->procExec(ELFINDER_RAR_PATH, $o, $c);\n            if ($c == 0 || $c == 7) {\n                $arcs['create']['application/x-rar'] = array('cmd' => ELFINDER_RAR_PATH, 'argc' => 'a -inul' . (defined('ELFINDER_RAR_MA4') && ELFINDER_RAR_MA4? ' -ma4' : '') . ' --', 'ext' => 'rar');\n            }\n            unset($o);\n            $this->procExec(ELFINDER_UNRAR_PATH, $o, $c);\n            if ($c == 0 || $c == 7) {\n                $arcs['extract']['application/x-rar'] = array('cmd' => ELFINDER_UNRAR_PATH, 'argc' => 'x -y', 'ext' => 'rar', 'toSpec' => '', 'getsize' => array('argc' => 'l', 'regex' => '/^.+(?:\\r\\n|\\n|\\r)(?:(?:[^\\r\\n0-9]+[0-9]+[^\\r\\n0-9]+([0-9]+)[^\\r\\n]+)|(?:[^\\r\\n0-9]+([0-9]+)[^\\r\\n0-9]+[0-9]+[^\\r\\n]*))$/s', 'replace' => '$1'));\n            }\n            unset($o);\n            $this->procExec(ELFINDER_7Z_PATH, $o, $c);\n            if ($c == 0) {\n                $arcs['create']['application/x-7z-compressed'] = array('cmd' => ELFINDER_7Z_PATH, 'argc' => 'a --', 'ext' => '7z');\n                $arcs['extract']['application/x-7z-compressed'] = array('cmd' => ELFINDER_7Z_PATH, 'argc' => 'x -y', 'ext' => '7z', 'toSpec' => '-o', 'getsize' => array('argc' => 'l', 'regex' => '/^.+(?:\\r\\n|\\n|\\r)[^\\r\\n0-9]+([0-9]+)[^\\r\\n]+$/s', 'replace' => '$1'));\n\n                if (empty($arcs['create']['application/zip'])) {\n                    $arcs['create']['application/zip'] = array('cmd' => ELFINDER_7Z_PATH, 'argc' => 'a -tzip --', 'ext' => 'zip');\n                }\n                if (empty($arcs['extract']['application/zip'])) {\n                    $arcs['extract']['application/zip'] = array('cmd' => ELFINDER_7Z_PATH, 'argc' => 'x -tzip -y', 'ext' => 'zip', 'toSpec' => '-o', 'getsize' => array('argc' => 'l', 'regex' => '/^.+(?:\\r\\n|\\n|\\r)[^\\r\\n0-9]+([0-9]+)[^\\r\\n]+$/s', 'replace' => '$1'));\n                }\n                if (empty($arcs['create']['application/x-tar'])) {\n                    $arcs['create']['application/x-tar'] = array('cmd' => ELFINDER_7Z_PATH, 'argc' => 'a -ttar --', 'ext' => 'tar');\n                }\n                if (empty($arcs['extract']['application/x-tar'])) {\n                    $arcs['extract']['application/x-tar'] = array('cmd' => ELFINDER_7Z_PATH, 'argc' => 'x -ttar -y', 'ext' => 'tar', 'toSpec' => '-o', 'getsize' => array('argc' => 'l', 'regex' => '/^.+(?:\\r\\n|\\n|\\r)[^\\r\\n0-9]+([0-9]+)[^\\r\\n]+$/s', 'replace' => '$1'));\n                }\n                if (substr(PHP_OS, 0, 3) === 'WIN' && empty($arcs['extract']['application/x-rar'])) {\n                    $arcs['extract']['application/x-rar'] = array('cmd' => ELFINDER_7Z_PATH, 'argc' => 'x -trar -y', 'ext' => 'rar', 'toSpec' => '-o', 'getsize' => array('argc' => 'l', 'regex' => '/^.+(?:\\r\\n|\\n|\\r)[^\\r\\n0-9]+([0-9]+)[^\\r\\n]+$/s', 'replace' => '$1'));\n                }\n            }\n\n        }\n\n        // Use PHP ZipArchive Class\n        if (class_exists('ZipArchive', false)) {\n            if (empty($arcs['create']['application/zip'])) {\n                $arcs['create']['application/zip'] = array('cmd' => 'phpfunction', 'argc' => array('self', 'zipArchiveZip'), 'ext' => 'zip');\n            }\n            if (empty($arcs['extract']['application/zip'])) {\n                $arcs['extract']['application/zip'] = array('cmd' => 'phpfunction', 'argc' => array('self', 'zipArchiveUnzip'), 'ext' => 'zip');\n            }\n        }\n\n        $this->session->set($sessionKey, $arcs);\n        return elFinder::$archivers = $arcs;\n    }\n\n    /**\n     * Resolve relative / (Unix-like)absolute path\n     *\n     * @param string $path target path\n     * @param string $base base path\n     *\n     * @return string\n     */\n    protected function getFullPath($path, $base)\n    {\n        $separator = $this->separator;\n        $systemroot = $this->systemRoot;\n        $base = (string)$base;\n\n        if ($base[0] === $separator && substr($base, 0, strlen($systemroot)) !== $systemroot) {\n            $base = $systemroot . substr($base, 1);\n        }\n        if ($base !== $systemroot) {\n            $base = rtrim($base, $separator);\n        }\n\n        $sepquoted = preg_quote($separator, '#');\n\n        // normalize `//` to `/`\n        $path = preg_replace('#' . $sepquoted . '+#', $separator, $path); // '#/+#'\n\n        // remove `./`\n        $path = preg_replace('#(?<=^|' . $sepquoted . ')\\.' . $sepquoted . '#', '', $path); // '#(?<=^|/)\\./#'\n\n        // 'Here'\n        if ($path === '') return $base;\n\n        // join $base to $path if $path start `../`\n        if (substr($path, 0, 3) === '..' . $separator) {\n            $path = $base . $separator . $path;\n        }\n\n        // normalize `/../`\n        $normreg = '#(' . $sepquoted . ')[^' . $sepquoted . ']+' . $sepquoted . '\\.\\.' . $sepquoted . '#'; // '#(/)[^\\/]+/\\.\\./#'\n        while (preg_match($normreg, $path)) {\n            $path = preg_replace($normreg, '$1', $path, 1);\n        }\n        if ($path !== $systemroot) {\n            $path = rtrim($path, $separator);\n        }\n\n        // discard the surplus `../`\n        $path = str_replace('..' . $separator, '', $path);\n\n        // Absolute path\n        if ($path[0] === $separator || strpos($path, $systemroot) === 0) {\n            return $path;\n        }\n\n        $preg_separator = '#' . $sepquoted . '#';\n\n        // Relative path from 'Here'\n        if (substr($path, 0, 2) === '.' . $separator || $path[0] !== '.') {\n            $arrn = preg_split($preg_separator, $path, -1, PREG_SPLIT_NO_EMPTY);\n            if ($arrn[0] !== '.') {\n                array_unshift($arrn, '.');\n            }\n            $arrn[0] = rtrim($base, $separator);\n            return join($separator, $arrn);\n        }\n\n        return $path;\n    }\n\n    /**\n     * Remove directory recursive on local file system\n     *\n     * @param string $dir Target dirctory path\n     *\n     * @return boolean\n     * @throws elFinderAbortException\n     * @author Naoki Sawada\n     */\n    public function rmdirRecursive($dir)\n    {\n        return self::localRmdirRecursive($dir);\n    }\n\n    /**\n     * Create archive and return its path\n     *\n     * @param  string $dir   target dir\n     * @param  array  $files files names list\n     * @param  string $name  archive name\n     * @param  array  $arc   archiver options\n     *\n     * @return string|bool\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     * @author Naoki Sawada\n     */\n    protected function makeArchive($dir, $files, $name, $arc)\n    {\n        if ($arc['cmd'] === 'phpfunction') {\n            if (is_callable($arc['argc'])) {\n                call_user_func_array($arc['argc'], array($dir, $files, $name));\n            }\n        } else {\n            $cwd = getcwd();\n            if (chdir($dir)) {\n                foreach ($files as $i => $file) {\n                    $files[$i] = '.' . DIRECTORY_SEPARATOR . basename($file);\n                }\n                $files = array_map('escapeshellarg', $files);\n                $prefix = $switch = '';\n                // The zip command accepts the \"-\" at the beginning of the file name as a command switch,\n                // and can't use '--' before archive name, so add \"./\" to name for security reasons.\n                if ($arc['ext'] === 'zip' && strpos($arc['argc'], '-tzip') === false) {\n                    $prefix = './';\n                    $switch = '-- ';\n                }\n                $cmd = $arc['cmd'] . ' ' . $arc['argc'] . ' ' . $prefix . escapeshellarg($name) . ' ' . $switch . implode(' ', $files);\n                $err_out = '';\n                $this->procExec($cmd, $o, $c, $err_out, $dir);\n                chdir($cwd);\n            } else {\n                return false;\n            }\n        }\n        $path = $dir . DIRECTORY_SEPARATOR . $name;\n        return file_exists($path) ? $path : false;\n    }\n\n    /**\n     * Unpack archive\n     *\n     * @param  string      $path archive path\n     * @param  array       $arc  archiver command and arguments (same as in $this->archivers)\n     * @param  bool|string $mode bool: remove archive ( unlink($path) ) | string: extract to directory\n     *\n     * @return void\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     * @author Alexey Sukhotin\n     * @author Naoki Sawada\n     */\n    protected function unpackArchive($path, $arc, $mode = true)\n    {\n        if (is_string($mode)) {\n            $dir = $mode;\n            $chdir = null;\n            $remove = false;\n        } else {\n            $dir = dirname($path);\n            $chdir = $dir;\n            $remove = $mode;\n        }\n        $dir = realpath($dir);\n        $path = realpath($path);\n        if ($arc['cmd'] === 'phpfunction') {\n            if (is_callable($arc['argc'])) {\n                call_user_func_array($arc['argc'], array($path, $dir));\n            }\n        } else {\n            $cwd = getcwd();\n            if (!$chdir || chdir($dir)) {\n                if (!empty($arc['getsize'])) {\n                    // Check total file size after extraction\n                    $getsize = $arc['getsize'];\n                    if (is_array($getsize) && !empty($getsize['regex']) && !empty($getsize['replace'])) {\n                        $cmd = $arc['cmd'] . ' ' . $getsize['argc'] . ' ' . escapeshellarg($path) . (!empty($getsize['toSpec'])? (' ' . $getsize['toSpec']): '');\n                        $this->procExec($cmd, $o, $c);\n                        if ($o) {\n                            $size = preg_replace($getsize['regex'], $getsize['replace'], trim($o));\n                            $comp = function_exists('bccomp')? 'bccomp' : 'strnatcmp';\n                            if (!empty($this->options['maxArcFilesSize'])) {\n                                if ($comp($size, (string)$this->options['maxArcFilesSize']) > 0) {\n                                    throw new Exception(elFinder::ERROR_ARC_MAXSIZE);\n                                }\n                            }\n                        }\n                        unset($o, $c);\n                    }\n                }\n                if ($chdir) {\n                    $cmd = $arc['cmd'] . ' ' . $arc['argc'] . ' ' . escapeshellarg(basename($path));\n                } else {\n                    $cmd = $arc['cmd'] . ' ' . $arc['argc'] . ' ' . escapeshellarg($path) . ' ' . $arc['toSpec'] . escapeshellarg($dir);\n                }\n                $this->procExec($cmd, $o, $c);\n                $chdir && chdir($cwd);\n            }\n        }\n        $remove && unlink($path);\n    }\n\n    /**\n     * Check and filter the extracted items\n     *\n     * @param  string $path   target local path\n     * @param  array  $checks types to check default: ['symlink', 'name', 'writable', 'mime']\n     *\n     * @return array  ['symlinks' => [], 'names' => [], 'writables' => [], 'mimes' => [], 'rmNames' => [], 'totalSize' => 0]\n     * @throws elFinderAbortException\n     * @throws Exception\n     * @author Naoki Sawada\n     */\n    protected function checkExtractItems($path, $checks = null)\n    {\n        if (is_null($checks) || !is_array($checks)) {\n            $checks = array('symlink', 'name', 'writable', 'mime');\n        }\n        $chkSymlink = in_array('symlink', $checks);\n        $chkName = in_array('name', $checks);\n        $chkWritable = in_array('writable', $checks);\n        $chkMime = in_array('mime', $checks);\n\n        $res = array(\n            'symlinks' => array(),\n            'names' => array(),\n            'writables' => array(),\n            'mimes' => array(),\n            'rmNames' => array(),\n            'totalSize' => 0\n        );\n\n        if (is_dir($path)) {\n            $files = self::localScandir($path);\n        } else {\n            $files = array(basename($path));\n            $path = dirname($path);\n        }\n\n        foreach ($files as $name) {\n            $p = $path . DIRECTORY_SEPARATOR . $name;\n            $utf8Name = elFinder::$instance->utf8Encode($name);\n            if ($name !== $utf8Name) {\n                $fsSame = false;\n                if ($this->encoding) {\n                    // test as fs encoding\n                    $_utf8 = @iconv($this->encoding, 'utf-8//IGNORE', $name);\n                    if (@iconv('utf-8', $this->encoding.'//IGNORE', $_utf8) === $name) {\n                        $fsSame = true;\n                        $utf8Name = $_utf8;\n                    } else {\n                        $_name = $this->convEncIn($utf8Name, true);\n                    }\n                } else {\n                    $_name = $utf8Name;\n                }\n                if (!$fsSame && rename($p, $path . DIRECTORY_SEPARATOR . $_name)) {\n                    $name = $_name;\n                    $p = $path . DIRECTORY_SEPARATOR . $name;\n                }\n            }\n            if (!is_readable($p)) {\n                // Perhaps a symbolic link to open_basedir restricted location\n                self::localRmdirRecursive($p);\n                $res['symlinks'][] = $p;\n                $res['rmNames'][] = $utf8Name;\n                continue;\n            }\n            if ($chkSymlink && is_link($p)) {\n                self::localRmdirRecursive($p);\n                $res['symlinks'][] = $p;\n                $res['rmNames'][] = $utf8Name;\n                continue;\n            }\n            $isDir = is_dir($p);\n            if ($chkName && !$this->nameAccepted($name, $isDir)) {\n                self::localRmdirRecursive($p);\n                $res['names'][] = $p;\n                $res['rmNames'][] = $utf8Name;\n                continue;\n            }\n            if ($chkWritable && !$this->attr($p, 'write', null, $isDir)) {\n                self::localRmdirRecursive($p);\n                $res['writables'][] = $p;\n                $res['rmNames'][] = $utf8Name;\n                continue;\n            }\n            if ($isDir) {\n                $cRes = $this->checkExtractItems($p, $checks);\n                foreach ($cRes as $k => $v) {\n                    if (is_array($v)) {\n                        $res[$k] = array_merge($res[$k], $cRes[$k]);\n                    } else {\n                        $res[$k] += $cRes[$k];\n                    }\n                }\n            } else {\n                if ($chkMime && ($mimeByName = elFinderVolumeDriver::mimetypeInternalDetect($name)) && !$this->allowPutMime($mimeByName)) {\n                    self::localRmdirRecursive($p);\n                    $res['mimes'][] = $p;\n                    $res['rmNames'][] = $utf8Name;\n                    continue;\n                }\n                $res['totalSize'] += (int)sprintf('%u', filesize($p));\n            }\n        }\n        $res['rmNames'] = array_unique($res['rmNames']);\n\n        return $res;\n    }\n\n    /**\n     * Return files of target directory that is dotfiles excludes.\n     *\n     * @param  string $dir target directory path\n     *\n     * @return array\n     * @throws Exception\n     * @author Naoki Sawada\n     */\n    protected static function localScandir($dir)\n    {\n        // PHP function scandir() is not work well in specific environment. I dont know why.\n        // ref. https://github.com/Studio-42/elFinder/issues/1248\n        $files = array();\n        if ($dh = opendir($dir)) {\n            while (false !== ($file = readdir($dh))) {\n                if ($file !== '.' && $file !== '..') {\n                    $files[] = $file;\n                }\n            }\n            closedir($dh);\n        } else {\n            throw new Exception('Can not open local directory.');\n        }\n        return $files;\n    }\n\n    /**\n     * Remove directory recursive on local file system\n     *\n     * @param string $dir Target dirctory path\n     *\n     * @return boolean\n     * @throws elFinderAbortException\n     * @author Naoki Sawada\n     */\n    protected static function localRmdirRecursive($dir)\n    {\n        // try system command\n        if (is_callable('exec')) {\n            $o = '';\n            $r = 1;\n            if (substr(PHP_OS, 0, 3) === 'WIN') {\n                if (!is_link($dir) && is_dir($dir)) {\n                    exec('rd /S /Q ' . escapeshellarg($dir), $o, $r);\n                } else {\n                    exec('del /F /Q ' . escapeshellarg($dir), $o, $r);\n                }\n            } else {\n                exec('rm -rf ' . escapeshellarg($dir), $o, $r);\n            }\n            if ($r === 0) {\n                return true;\n            }\n        }\n        if (!is_link($dir) && is_dir($dir)) {\n            chmod($dir, 0777);\n            if ($handle = opendir($dir)) {\n                while (false !== ($file = readdir($handle))) {\n                    if ($file === '.' || $file === '..') {\n                        continue;\n                    }\n                    elFinder::extendTimeLimit(30);\n                    $path = $dir . DIRECTORY_SEPARATOR . $file;\n                    if (!is_link($dir) && is_dir($path)) {\n                        self::localRmdirRecursive($path);\n                    } else {\n                        chmod($path, 0666);\n                        unlink($path);\n                    }\n                }\n                closedir($handle);\n            }\n            return rmdir($dir);\n        } else {\n            chmod($dir, 0666);\n            return unlink($dir);\n        }\n    }\n\n    /**\n     * Move item recursive on local file system\n     *\n     * @param string $src\n     * @param string $target\n     * @param bool   $overWrite\n     * @param bool   $copyJoin\n     *\n     * @return boolean\n     * @throws elFinderAbortException\n     * @throws Exception\n     * @author Naoki Sawada\n     */\n    protected static function localMoveRecursive($src, $target, $overWrite = true, $copyJoin = true)\n    {\n        $res = false;\n        if (!file_exists($target)) {\n            return rename($src, $target);\n        }\n        if (!$copyJoin || !is_dir($target)) {\n            if ($overWrite) {\n                if (is_dir($target)) {\n                    $del = self::localRmdirRecursive($target);\n                } else {\n                    $del = unlink($target);\n                }\n                if ($del) {\n                    return rename($src, $target);\n                }\n            }\n        } else {\n            foreach (self::localScandir($src) as $item) {\n                $res |= self::localMoveRecursive($src . DIRECTORY_SEPARATOR . $item, $target . DIRECTORY_SEPARATOR . $item, $overWrite, $copyJoin);\n            }\n        }\n        return (bool)$res;\n    }\n\n    /**\n     * Create Zip archive using PHP class ZipArchive\n     *\n     * @param  string        $dir     target dir\n     * @param  array         $files   files names list\n     * @param  string|object $zipPath Zip archive name\n     *\n     * @return bool\n     * @author Naoki Sawada\n     */\n    protected static function zipArchiveZip($dir, $files, $zipPath)\n    {\n        try {\n            if ($start = is_string($zipPath)) {\n                $zip = new ZipArchive();\n                if ($zip->open($dir . DIRECTORY_SEPARATOR . $zipPath, ZipArchive::CREATE) !== true) {\n                    $zip = false;\n                }\n            } else {\n                $zip = $zipPath;\n            }\n            if ($zip) {\n                foreach ($files as $file) {\n                    $path = $dir . DIRECTORY_SEPARATOR . $file;\n                    if (is_dir($path)) {\n                        $zip->addEmptyDir($file);\n                        $_files = array();\n                        if ($handle = opendir($path)) {\n                            while (false !== ($entry = readdir($handle))) {\n                                if ($entry !== \".\" && $entry !== \"..\") {\n                                    $_files[] = $file . DIRECTORY_SEPARATOR . $entry;\n                                }\n                            }\n                            closedir($handle);\n                        }\n                        if ($_files) {\n                            self::zipArchiveZip($dir, $_files, $zip);\n                        }\n                    } else {\n                        $zip->addFile($path, $file);\n                    }\n                }\n                $start && $zip->close();\n            }\n        } catch (Exception $e) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Unpack Zip archive using PHP class ZipArchive\n     *\n     * @param  string $zipPath Zip archive name\n     * @param  string $toDir   Extract to path\n     *\n     * @return bool\n     * @author Naoki Sawada\n     */\n    protected static function zipArchiveUnzip($zipPath, $toDir)\n    {\n        try {\n            $zip = new ZipArchive();\n            if ($zip->open($zipPath) === true) {\n                // Check total file size after extraction\n                $num = $zip->numFiles;\n                $size = 0;\n                $maxSize = empty(self::$maxArcFilesSize)? '' : (string)self::$maxArcFilesSize;\n                $comp = function_exists('bccomp')? 'bccomp' : 'strnatcmp';\n                for ($i = 0; $i < $num; $i++) {\n                    $stat = $zip->statIndex($i);\n                    $size += $stat['size'];\n                    if (strpos((string)$size, 'E') !== false) {\n                        // Cannot handle values exceeding PHP_INT_MAX\n                        throw new Exception(elFinder::ERROR_ARC_MAXSIZE);\n                    }\n                    if (!$maxSize) {\n                        if ($comp($size, $maxSize) > 0) {\n                            throw new Exception(elFinder::ERROR_ARC_MAXSIZE);\n                        }\n                    }\n                }\n                // do extract\n                $zip->extractTo($toDir);\n                $zip->close();\n            }\n        } catch (Exception $e) {\n            throw $e;\n        }\n        return true;\n    }\n\n    /**\n     * Recursive symlinks search\n     *\n     * @param  string $path file/dir path\n     *\n     * @return bool\n     * @throws Exception\n     * @author Dmitry (dio) Levashov\n     */\n    protected static function localFindSymlinks($path)\n    {\n        if (is_link($path)) {\n            return true;\n        }\n\n        if (is_dir($path)) {\n            foreach (self::localScandir($path) as $name) {\n                $p = $path . DIRECTORY_SEPARATOR . $name;\n                if (is_link($p)) {\n                    return true;\n                }\n                if (is_dir($p) && self::localFindSymlinks($p)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**==================================* abstract methods *====================================**/\n\n    /*********************** paths/urls *************************/\n\n    /**\n     * Return parent directory path\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _dirname($path);\n\n    /**\n     * Return file name\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _basename($path);\n\n    /**\n     * Join dir name and file name and return full path.\n     * Some drivers (db) use int as path - so we give to concat path to driver itself\n     *\n     * @param  string $dir  dir path\n     * @param  string $name file name\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _joinPath($dir, $name);\n\n    /**\n     * Return normalized path\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _normpath($path);\n\n    /**\n     * Return file path related to root dir\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _relpath($path);\n\n    /**\n     * Convert path related to root dir into real path\n     *\n     * @param  string $path rel file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _abspath($path);\n\n    /**\n     * Return fake path started from root dir.\n     * Required to show path on client side.\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _path($path);\n\n    /**\n     * Return true if $path is children of $parent\n     *\n     * @param  string $path   path to check\n     * @param  string $parent parent path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _inpath($path, $parent);\n\n    /**\n     * Return stat for given path.\n     * Stat contains following fields:\n     * - (int)    size    file size in b. required\n     * - (int)    ts      file modification time in unix time. required\n     * - (string) mime    mimetype. required for folders, others - optionally\n     * - (bool)   read    read permissions. required\n     * - (bool)   write   write permissions. required\n     * - (bool)   locked  is object locked. optionally\n     * - (bool)   hidden  is object hidden. optionally\n     * - (string) alias   for symlinks - link target path relative to root path. optionally\n     * - (string) target  for symlinks - link target path. optionally\n     * If file does not exists - returns empty array or false.\n     *\n     * @param  string $path file path\n     *\n     * @return array|false\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _stat($path);\n\n\n    /***************** file stat ********************/\n\n\n    /**\n     * Return true if path is dir and has at least one childs directory\n     *\n     * @param  string $path dir path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _subdirs($path);\n\n    /**\n     * Return object width and height\n     * Ususaly used for images, but can be realize for video etc...\n     *\n     * @param  string $path file path\n     * @param  string $mime file mime type\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _dimensions($path, $mime);\n\n    /******************** file/dir content *********************/\n\n    /**\n     * Return files list in directory\n     *\n     * @param  string $path dir path\n     *\n     * @return array\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _scandir($path);\n\n    /**\n     * Open file and return file pointer\n     *\n     * @param  string $path file path\n     * @param  string $mode open mode\n     *\n     * @return resource|false\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _fopen($path, $mode = \"rb\");\n\n    /**\n     * Close opened file\n     *\n     * @param  resource $fp   file pointer\n     * @param  string   $path file path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _fclose($fp, $path = '');\n\n    /********************  file/dir manipulations *************************/\n\n    /**\n     * Create dir and return created dir path or false on failed\n     *\n     * @param  string $path parent dir path\n     * @param string  $name new directory name\n     *\n     * @return string|bool\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _mkdir($path, $name);\n\n    /**\n     * Create file and return it's path or false on failed\n     *\n     * @param  string $path parent dir path\n     * @param string  $name new file name\n     *\n     * @return string|bool\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _mkfile($path, $name);\n\n    /**\n     * Create symlink\n     *\n     * @param  string $source    file to link to\n     * @param  string $targetDir folder to create link in\n     * @param  string $name      symlink name\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _symlink($source, $targetDir, $name);\n\n    /**\n     * Copy file into another file (only inside one volume)\n     *\n     * @param  string $source source file path\n     * @param         $targetDir\n     * @param  string $name   file name\n     *\n     * @return bool|string\n     * @internal param string $target target dir path\n     * @author   Dmitry (dio) Levashov\n     */\n    abstract protected function _copy($source, $targetDir, $name);\n\n    /**\n     * Move file into another parent dir.\n     * Return new file path or false.\n     *\n     * @param  string $source source file path\n     * @param         $targetDir\n     * @param  string $name   file name\n     *\n     * @return bool|string\n     * @internal param string $target target dir path\n     * @author   Dmitry (dio) Levashov\n     */\n    abstract protected function _move($source, $targetDir, $name);\n\n    /**\n     * Remove file\n     *\n     * @param  string $path file path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _unlink($path);\n\n    /**\n     * Remove dir\n     *\n     * @param  string $path dir path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _rmdir($path);\n\n    /**\n     * Create new file and write into it from file pointer.\n     * Return new file path or false on error.\n     *\n     * @param  resource $fp   file pointer\n     * @param  string   $dir  target dir path\n     * @param  string   $name file name\n     * @param  array    $stat file stat (required by some virtual fs)\n     *\n     * @return bool|string\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _save($fp, $dir, $name, $stat);\n\n    /**\n     * Get file contents\n     *\n     * @param  string $path file path\n     *\n     * @return string|false\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _getContents($path);\n\n    /**\n     * Write a string to a file\n     *\n     * @param  string $path    file path\n     * @param  string $content new file content\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    abstract protected function _filePutContents($path, $content);\n\n    /**\n     * Extract files from archive\n     *\n     * @param  string $path file path\n     * @param  array  $arc  archiver options\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     **/\n    abstract protected function _extract($path, $arc);\n\n    /**\n     * Create archive and return its path\n     *\n     * @param  string $dir   target dir\n     * @param  array  $files files names list\n     * @param  string $name  archive name\n     * @param  array  $arc   archiver options\n     *\n     * @return string|bool\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     **/\n    abstract protected function _archive($dir, $files, $name, $arc);\n\n    /**\n     * Detect available archivers\n     *\n     * @return void\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     **/\n    abstract protected function _checkArchivers();\n\n    /**\n     * Change file mode (chmod)\n     *\n     * @param  string $path file path\n     * @param  string $mode octal string such as '0755'\n     *\n     * @return bool\n     * @author David Bartle,\n     **/\n    abstract protected function _chmod($path, $mode);\n\n\n} // END class\n", "<?php\n\n// Implement similar functionality in PHP 5.2 or 5.3\n// http://php.net/manual/class.recursivecallbackfilteriterator.php#110974\nif (!class_exists('RecursiveCallbackFilterIterator', false)) {\n    class RecursiveCallbackFilterIterator extends RecursiveFilterIterator\n    {\n        private $callback;\n\n        public function __construct(RecursiveIterator $iterator, $callback)\n        {\n            $this->callback = $callback;\n            parent::__construct($iterator);\n        }\n\n        public function accept()\n        {\n            return call_user_func($this->callback, parent::current(), parent::key(), parent::getInnerIterator());\n        }\n\n        public function getChildren()\n        {\n            return new self($this->getInnerIterator()->getChildren(), $this->callback);\n        }\n    }\n}\n\n/**\n * elFinder driver for local filesystem.\n *\n * @author Dmitry (dio) Levashov\n * @author Troex Nevelin\n **/\nclass elFinderVolumeLocalFileSystem extends elFinderVolumeDriver\n{\n\n    /**\n     * Driver id\n     * Must be started from letter and contains [a-z0-9]\n     * Used as part of volume id\n     *\n     * @var string\n     **/\n    protected $driverId = 'l';\n\n    /**\n     * Required to count total archive files size\n     *\n     * @var int\n     **/\n    protected $archiveSize = 0;\n\n    /**\n     * Is checking stat owner\n     *\n     * @var        boolean\n     */\n    protected $statOwner = false;\n\n    /**\n     * Path to quarantine directory\n     *\n     * @var string\n     */\n    private $quarantine;\n\n    /**\n     * Constructor\n     * Extend options with required fields\n     *\n     * @author Dmitry (dio) Levashov\n     */\n    public function __construct()\n    {\n        $this->options['alias'] = '';              // alias to replace root dir name\n        $this->options['dirMode'] = 0755;            // new dirs mode\n        $this->options['fileMode'] = 0644;            // new files mode\n        $this->options['rootCssClass'] = 'elfinder-navbar-root-local';\n        $this->options['followSymLinks'] = true;\n        $this->options['detectDirIcon'] = '';         // file name that is detected as a folder icon e.g. '.diricon.png'\n        $this->options['keepTimestamp'] = array('copy', 'move'); // keep timestamp at inner filesystem allowed 'copy', 'move' and 'upload'\n        $this->options['substituteImg'] = true;       // support substitute image with dim command\n        $this->options['statCorrector'] = null;       // callable to correct stat data `function(&$stat, $path, $statOwner, $volumeDriveInstance){}`\n        if (DIRECTORY_SEPARATOR === '/') {\n            // Linux\n            $this->options['acceptedName'] = '/^[^\\.\\/\\x00][^\\/\\x00]*$/';\n        } else {\n            // Windows\n            $this->options['acceptedName'] = '/^[^\\.\\/\\x00\\\\\\:*?\"<>|][^\\/\\x00\\\\\\:*?\"<>|]*$/';\n        }\n    }\n\n    /*********************************************************************/\n    /*                        INIT AND CONFIGURE                         */\n    /*********************************************************************/\n\n    /**\n     * Prepare driver before mount volume.\n     * Return true if volume is ready.\n     *\n     * @return bool\n     **/\n    protected function init()\n    {\n        // Normalize directory separator for windows\n        if (DIRECTORY_SEPARATOR !== '/') {\n            foreach (array('path', 'tmbPath', 'tmpPath', 'quarantine') as $key) {\n                if (!empty($this->options[$key])) {\n                    $this->options[$key] = str_replace('/', DIRECTORY_SEPARATOR, $this->options[$key]);\n                }\n            }\n            // PHP >= 7.1 Supports UTF-8 path on Windows\n            if (version_compare(PHP_VERSION, '7.1', '>=')) {\n                $this->options['encoding'] = '';\n                $this->options['locale'] = '';\n            }\n        }\n        if (!$cwd = getcwd()) {\n            return $this->setError('elFinder LocalVolumeDriver requires a result of getcwd().');\n        }\n        // detect systemRoot\n        if (!isset($this->options['systemRoot'])) {\n            if ($cwd[0] === DIRECTORY_SEPARATOR || $this->root[0] === DIRECTORY_SEPARATOR) {\n                $this->systemRoot = DIRECTORY_SEPARATOR;\n            } else if (preg_match('/^([a-zA-Z]:' . preg_quote(DIRECTORY_SEPARATOR, '/') . ')/', $this->root, $m)) {\n                $this->systemRoot = $m[1];\n            } else if (preg_match('/^([a-zA-Z]:' . preg_quote(DIRECTORY_SEPARATOR, '/') . ')/', $cwd, $m)) {\n                $this->systemRoot = $m[1];\n            }\n        }\n        $this->root = $this->getFullPath($this->root, $cwd);\n        if (!empty($this->options['startPath'])) {\n            $this->options['startPath'] = $this->getFullPath($this->options['startPath'], $this->root);\n        }\n\n        if (is_null($this->options['syncChkAsTs'])) {\n            $this->options['syncChkAsTs'] = true;\n        }\n        if (is_null($this->options['syncCheckFunc'])) {\n            $this->options['syncCheckFunc'] = array($this, 'localFileSystemInotify');\n        }\n        // check 'statCorrector'\n        if (empty($this->options['statCorrector']) || !is_callable($this->options['statCorrector'])) {\n            $this->options['statCorrector'] = null;\n        }\n\n        return true;\n    }\n\n    /**\n     * Configure after successfull mount.\n     *\n     * @return void\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function configure()\n    {\n        $hiddens = array();\n        $root = $this->stat($this->root);\n\n        // check thumbnails path\n        if (!empty($this->options['tmbPath'])) {\n            if (strpos($this->options['tmbPath'], DIRECTORY_SEPARATOR) === false) {\n                $hiddens['tmb'] = $this->options['tmbPath'];\n                $this->options['tmbPath'] = $this->_abspath($this->options['tmbPath']);\n            } else {\n                $this->options['tmbPath'] = $this->_normpath($this->options['tmbPath']);\n            }\n        }\n        // check temp path\n        if (!empty($this->options['tmpPath'])) {\n            if (strpos($this->options['tmpPath'], DIRECTORY_SEPARATOR) === false) {\n                $hiddens['temp'] = $this->options['tmpPath'];\n                $this->options['tmpPath'] = $this->_abspath($this->options['tmpPath']);\n            } else {\n                $this->options['tmpPath'] = $this->_normpath($this->options['tmpPath']);\n            }\n        }\n        // check quarantine path\n        $_quarantine = '';\n        if (!empty($this->options['quarantine'])) {\n            if (strpos($this->options['quarantine'], DIRECTORY_SEPARATOR) === false) {\n                //$hiddens['quarantine'] = $this->options['quarantine'];\n                //$this->options['quarantine'] = $this->_abspath($this->options['quarantine']);\n                $_quarantine = $this->_abspath($this->options['quarantine']);\n                $this->options['quarantine'] = '';\n            } else {\n                $this->options['quarantine'] = $this->_normpath($this->options['quarantine']);\n            }\n        } else {\n            $_quarantine = $this->_abspath('.quarantine');\n        }\n        is_dir($_quarantine) && self::localRmdirRecursive($_quarantine);\n\n        parent::configure();\n\n        // check tmbPath\n        if (!$this->tmbPath && isset($hiddens['tmb'])) {\n            unset($hiddens['tmb']);\n        }\n\n        // if no thumbnails url - try detect it\n        if ($root['read'] && !$this->tmbURL && $this->URL) {\n            if (strpos($this->tmbPath, $this->root) === 0) {\n                $this->tmbURL = $this->URL . str_replace(DIRECTORY_SEPARATOR, '/', substr($this->tmbPath, strlen($this->root) + 1));\n                if (preg_match(\"|[^/?&=]$|\", $this->tmbURL)) {\n                    $this->tmbURL .= '/';\n                }\n            }\n        }\n\n        // set $this->tmp by options['tmpPath']\n        $this->tmp = '';\n        if (!empty($this->options['tmpPath'])) {\n            if ((is_dir($this->options['tmpPath']) || mkdir($this->options['tmpPath'], $this->options['dirMode'], true)) && is_writable($this->options['tmpPath'])) {\n                $this->tmp = $this->options['tmpPath'];\n            } else {\n                if (isset($hiddens['temp'])) {\n                    unset($hiddens['temp']);\n                }\n            }\n        }\n        if (!$this->tmp && ($tmp = elFinder::getStaticVar('commonTempPath'))) {\n            $this->tmp = $tmp;\n        }\n\n        // check quarantine dir\n        $this->quarantine = '';\n        if (!empty($this->options['quarantine'])) {\n            if ((is_dir($this->options['quarantine']) || mkdir($this->options['quarantine'], $this->options['dirMode'], true)) && is_writable($this->options['quarantine'])) {\n                $this->quarantine = $this->options['quarantine'];\n            } else {\n                if (isset($hiddens['quarantine'])) {\n                    unset($hiddens['quarantine']);\n                }\n            }\n        } else if ($_path = elFinder::getCommonTempPath()) {\n            $this->quarantine = $_path;\n        }\n\n        if (!$this->quarantine) {\n            if (!$this->tmp) {\n                $this->archivers['extract'] = array();\n                $this->disabled[] = 'extract';\n            } else {\n                $this->quarantine = $this->tmp;\n            }\n        }\n\n        if ($hiddens) {\n            foreach ($hiddens as $hidden) {\n                $this->attributes[] = array(\n                    'pattern' => '~^' . preg_quote(DIRECTORY_SEPARATOR . $hidden, '~') . '$~',\n                    'read' => false,\n                    'write' => false,\n                    'locked' => true,\n                    'hidden' => true\n                );\n            }\n        }\n\n        if (!empty($this->options['keepTimestamp'])) {\n            $this->options['keepTimestamp'] = array_flip($this->options['keepTimestamp']);\n        }\n\n        $this->statOwner = (!empty($this->options['statOwner']));\n\n        // enable WinRemoveTailDots plugin on Windows server\n        if (DIRECTORY_SEPARATOR !== '/') {\n            if (!isset($this->options['plugin'])) {\n                $this->options['plugin'] = array();\n            }\n            $this->options['plugin']['WinRemoveTailDots'] = array('enable' => true);\n        }\n    }\n\n    /**\n     * Long pooling sync checker\n     * This function require server command `inotifywait`\n     * If `inotifywait` need full path, Please add `define('ELFINER_INOTIFYWAIT_PATH', '/PATH_TO/inotifywait');` into connector.php\n     *\n     * @param string $path\n     * @param int    $standby\n     * @param number $compare\n     *\n     * @return number|bool\n     * @throws elFinderAbortException\n     */\n    public function localFileSystemInotify($path, $standby, $compare)\n    {\n        if (isset($this->sessionCache['localFileSystemInotify_disable'])) {\n            return false;\n        }\n        $path = realpath($path);\n        $mtime = filemtime($path);\n        if (!$mtime) {\n            return false;\n        }\n        if ($mtime != $compare) {\n            return $mtime;\n        }\n        $inotifywait = defined('ELFINER_INOTIFYWAIT_PATH') ? ELFINER_INOTIFYWAIT_PATH : 'inotifywait';\n        $standby = max(1, intval($standby));\n        $cmd = $inotifywait . ' ' . escapeshellarg($path) . ' -t ' . $standby . ' -e moved_to,moved_from,move,close_write,delete,delete_self';\n        $this->procExec($cmd, $o, $r);\n        if ($r === 0) {\n            // changed\n            clearstatcache();\n            if (file_exists($path)) {\n                $mtime = filemtime($path); // error on busy?\n                return $mtime ? $mtime : time();\n            } else {\n                // target was removed\n                return 0;\n            }\n        } else if ($r === 2) {\n            // not changed (timeout)\n            return $compare;\n        }\n        // error\n        // cache to $_SESSION\n        $this->sessionCache['localFileSystemInotify_disable'] = true;\n        $this->session->set($this->id, $this->sessionCache);\n        return false;\n    }\n\n    /*********************************************************************/\n    /*                               FS API                              */\n    /*********************************************************************/\n\n    /*********************** paths/urls *************************/\n\n    /**\n     * Return parent directory path\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _dirname($path)\n    {\n        return dirname($path);\n    }\n\n    /**\n     * Return file name\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _basename($path)\n    {\n        return basename($path);\n    }\n\n    /**\n     * Join dir name and file name and retur full path\n     *\n     * @param  string $dir\n     * @param  string $name\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _joinPath($dir, $name)\n    {\n        $dir = rtrim($dir, DIRECTORY_SEPARATOR);\n        $path = realpath($dir . DIRECTORY_SEPARATOR . $name);\n        // realpath() returns FALSE if the file does not exist\n        if ($path === false || strpos($path, $this->root) !== 0) {\n            if (DIRECTORY_SEPARATOR !== '/') {\n                $name = str_replace('/', DIRECTORY_SEPARATOR, $name);\n            }\n            // Directory traversal measures\n            if (strpos($name, '..' . DIRECTORY_SEPARATOR) !== false) {\n                $name = basename($name);\n            }\n            $path = $dir . DIRECTORY_SEPARATOR . $name;\n        }\n        return $path; \n    }\n\n    /**\n     * Return normalized path, this works the same as os.path.normpath() in Python\n     *\n     * @param  string $path path\n     *\n     * @return string\n     * @author Troex Nevelin\n     **/\n    protected function _normpath($path)\n    {\n        if (empty($path)) {\n            return '.';\n        }\n\n        $changeSep = (DIRECTORY_SEPARATOR !== '/');\n        if ($changeSep) {\n            $drive = '';\n            if (preg_match('/^([a-zA-Z]:)(.*)/', $path, $m)) {\n                $drive = $m[1];\n                $path = $m[2] ? $m[2] : '/';\n            }\n            $path = str_replace(DIRECTORY_SEPARATOR, '/', $path);\n        }\n\n        if (strpos($path, '/') === 0) {\n            $initial_slashes = true;\n        } else {\n            $initial_slashes = false;\n        }\n\n        if (($initial_slashes)\n            && (strpos($path, '//') === 0)\n            && (strpos($path, '///') === false)) {\n            $initial_slashes = 2;\n        }\n\n        $initial_slashes = (int)$initial_slashes;\n\n        $comps = explode('/', $path);\n        $new_comps = array();\n        foreach ($comps as $comp) {\n            if (in_array($comp, array('', '.'))) {\n                continue;\n            }\n\n            if (($comp != '..')\n                || (!$initial_slashes && !$new_comps)\n                || ($new_comps && (end($new_comps) == '..'))) {\n                array_push($new_comps, $comp);\n            } elseif ($new_comps) {\n                array_pop($new_comps);\n            }\n        }\n        $comps = $new_comps;\n        $path = implode('/', $comps);\n        if ($initial_slashes) {\n            $path = str_repeat('/', $initial_slashes) . $path;\n        }\n\n        if ($changeSep) {\n            $path = $drive . str_replace('/', DIRECTORY_SEPARATOR, $path);\n        }\n\n        return $path ? $path : '.';\n    }\n\n    /**\n     * Return file path related to root dir\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _relpath($path)\n    {\n        if ($path === $this->root) {\n            return '';\n        } else {\n            if (strpos($path, $this->root) === 0) {\n                return ltrim(substr($path, strlen($this->root)), DIRECTORY_SEPARATOR);\n            } else {\n                // for link\n                return $path;\n            }\n        }\n    }\n\n    /**\n     * Convert path related to root dir into real path\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _abspath($path)\n    {\n        if ($path === DIRECTORY_SEPARATOR) {\n            return $this->root;\n        } else {\n            $path = $this->_normpath($path);\n            if (strpos($path, $this->systemRoot) === 0) {\n                return $path;\n            } else if (DIRECTORY_SEPARATOR !== '/' && preg_match('/^[a-zA-Z]:' . preg_quote(DIRECTORY_SEPARATOR, '/') . '/', $path)) {\n                return $path;\n            } else {\n                return $this->_joinPath($this->root, $path);\n            }\n        }\n    }\n\n    /**\n     * Return fake path started from root dir\n     *\n     * @param  string $path file path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _path($path)\n    {\n        return $this->rootName . ($path == $this->root ? '' : $this->separator . $this->_relpath($path));\n    }\n\n    /**\n     * Return true if $path is children of $parent\n     *\n     * @param  string $path   path to check\n     * @param  string $parent parent path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _inpath($path, $parent)\n    {\n        $cwd = getcwd();\n        $real_path = $this->getFullPath($path, $cwd);\n        $real_parent = $this->getFullPath($parent, $cwd);\n        if ($real_path && $real_parent) {\n            return $real_path === $real_parent || strpos($real_path, rtrim($real_parent, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR) === 0;\n        }\n        return false;\n    }\n\n\n\n    /***************** file stat ********************/\n\n    /**\n     * Return stat for given path.\n     * Stat contains following fields:\n     * - (int)    size    file size in b. required\n     * - (int)    ts      file modification time in unix time. required\n     * - (string) mime    mimetype. required for folders, others - optionally\n     * - (bool)   read    read permissions. required\n     * - (bool)   write   write permissions. required\n     * - (bool)   locked  is object locked. optionally\n     * - (bool)   hidden  is object hidden. optionally\n     * - (string) alias   for symlinks - link target path relative to root path. optionally\n     * - (string) target  for symlinks - link target path. optionally\n     * If file does not exists - returns empty array or false.\n     *\n     * @param  string $path file path\n     *\n     * @return array|false\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _stat($path)\n    {\n        $stat = array();\n\n        if (!file_exists($path) && !is_link($path)) {\n            return $stat;\n        }\n\n        //Verifies the given path is the root or is inside the root. Prevents directory traveral.\n        if (!$this->_inpath($path, $this->root)) {\n            return $stat;\n        }\n\n        $stat['isowner'] = false;\n        $linkreadable = false;\n        if ($path != $this->root && is_link($path)) {\n            if (!$this->options['followSymLinks']) {\n                return array();\n            }\n            if (!($target = $this->readlink($path))\n                || $target == $path) {\n                if (is_null($target)) {\n                    $stat = array();\n                    return $stat;\n                } else {\n                    $stat['mime'] = 'symlink-broken';\n                    $target = readlink($path);\n                    $lstat = lstat($path);\n                    $ostat = $this->getOwnerStat($lstat['uid'], $lstat['gid']);\n                    $linkreadable = !empty($ostat['isowner']);\n                }\n            }\n            $stat['alias'] = $this->_path($target);\n            $stat['target'] = $target;\n        }\n\n        $readable = is_readable($path);\n\n        if ($readable) {\n            $size = sprintf('%u', filesize($path));\n            $stat['ts'] = filemtime($path);\n            if ($this->statOwner) {\n                $fstat = stat($path);\n                $uid = $fstat['uid'];\n                $gid = $fstat['gid'];\n                $stat['perm'] = substr((string)decoct($fstat['mode']), -4);\n                $stat = array_merge($stat, $this->getOwnerStat($uid, $gid));\n            }\n        }\n\n        if (($dir = is_dir($path)) && $this->options['detectDirIcon']) {\n            $favicon = $path . DIRECTORY_SEPARATOR . $this->options['detectDirIcon'];\n            if ($this->URL && file_exists($favicon)) {\n                $stat['icon'] = $this->URL . str_replace(DIRECTORY_SEPARATOR, '/', substr($favicon, strlen($this->root) + 1));\n            }\n        }\n\n        if (!isset($stat['mime'])) {\n            $stat['mime'] = $dir ? 'directory' : $this->mimetype($path);\n        }\n        //logical rights first\n        $stat['read'] = ($linkreadable || $readable) ? null : false;\n        $stat['write'] = is_writable($path) ? null : false;\n\n        if (is_null($stat['read'])) {\n            if ($dir) {\n                $stat['size'] = 0;\n            } else if (isset($size)) {\n                $stat['size'] = $size;\n            }\n        }\n\n        if ($this->options['statCorrector']) {\n            call_user_func_array($this->options['statCorrector'], array(&$stat, $path, $this->statOwner, $this));\n        }\n\n        return $stat;\n    }\n\n    /**\n     * Get stat `owner`, `group` and `isowner` by `uid` and `gid`\n     * Sub-fuction of _stat() and _scandir()\n     *\n     * @param integer $uid\n     * @param integer $gid\n     *\n     * @return array  stat\n     */\n    protected function getOwnerStat($uid, $gid)\n    {\n        static $names = null;\n        static $phpuid = null;\n\n        if (is_null($names)) {\n            $names = array('uid' => array(), 'gid' => array());\n        }\n        if (is_null($phpuid)) {\n            if (is_callable('posix_getuid')) {\n                $phpuid = posix_getuid();\n            } else {\n                $phpuid = 0;\n            }\n        }\n\n        $stat = array();\n\n        if ($uid) {\n            $stat['isowner'] = ($phpuid == $uid);\n            if (isset($names['uid'][$uid])) {\n                $stat['owner'] = $names['uid'][$uid];\n            } else if (is_callable('posix_getpwuid')) {\n                $pwuid = posix_getpwuid($uid);\n                $stat['owner'] = $names['uid'][$uid] = $pwuid['name'];\n            } else {\n                $stat['owner'] = $names['uid'][$uid] = $uid;\n            }\n        }\n        if ($gid) {\n            if (isset($names['gid'][$gid])) {\n                $stat['group'] = $names['gid'][$gid];\n            } else if (is_callable('posix_getgrgid')) {\n                $grgid = posix_getgrgid($gid);\n                $stat['group'] = $names['gid'][$gid] = $grgid['name'];\n            } else {\n                $stat['group'] = $names['gid'][$gid] = $gid;\n            }\n        }\n\n        return $stat;\n    }\n\n    /**\n     * Return true if path is dir and has at least one childs directory\n     *\n     * @param  string $path dir path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _subdirs($path)\n    {\n\n        $dirs = false;\n        if (is_dir($path) && is_readable($path)) {\n            if (class_exists('FilesystemIterator', false)) {\n                $dirItr = new ParentIterator(\n                    new RecursiveDirectoryIterator($path,\n                        FilesystemIterator::SKIP_DOTS |\n                        FilesystemIterator::CURRENT_AS_SELF |\n                        (defined('RecursiveDirectoryIterator::FOLLOW_SYMLINKS') ?\n                            RecursiveDirectoryIterator::FOLLOW_SYMLINKS : 0)\n                    )\n                );\n                $dirItr->rewind();\n                if ($dirItr->hasChildren()) {\n                    $dirs = true;\n                    $name = $dirItr->getSubPathName();\n                    while ($dirItr->valid()) {\n                        if (!$this->attr($path . DIRECTORY_SEPARATOR . $name, 'read', null, true)) {\n                            $dirs = false;\n                            $dirItr->next();\n                            $name = $dirItr->getSubPathName();\n                            continue;\n                        }\n                        $dirs = true;\n                        break;\n                    }\n                }\n            } else {\n                $path = strtr($path, array('[' => '\\\\[', ']' => '\\\\]', '*' => '\\\\*', '?' => '\\\\?'));\n                return (bool)glob(rtrim($path, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR . '*', GLOB_ONLYDIR);\n            }\n        }\n        return $dirs;\n    }\n\n    /**\n     * Return object width and height\n     * Usualy used for images, but can be realize for video etc...\n     *\n     * @param  string $path file path\n     * @param  string $mime file mime type\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _dimensions($path, $mime)\n    {\n        clearstatcache();\n        return strpos($mime, 'image') === 0 && is_readable($path) && filesize($path) && ($s = getimagesize($path)) !== false\n            ? $s[0] . 'x' . $s[1]\n            : false;\n    }\n    /******************** file/dir content *********************/\n\n    /**\n     * Return symlink target file\n     *\n     * @param  string $path link path\n     *\n     * @return string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function readlink($path)\n    {\n        if (!($target = readlink($path))) {\n            return null;\n        }\n\n        if (strpos($target, $this->systemRoot) !== 0) {\n            $target = $this->_joinPath(dirname($path), $target);\n        }\n\n        if (!file_exists($target)) {\n            return false;\n        }\n\n        return $target;\n    }\n\n    /**\n     * Return files list in directory.\n     *\n     * @param  string $path dir path\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     */\n    protected function _scandir($path)\n    {\n        elFinder::checkAborted();\n        $files = array();\n        $cache = array();\n        $dirWritable = is_writable($path);\n        $dirItr = array();\n        $followSymLinks = $this->options['followSymLinks'];\n        try {\n            $dirItr = new DirectoryIterator($path);\n        } catch (UnexpectedValueException $e) {\n        }\n\n        foreach ($dirItr as $file) {\n            try {\n                if ($file->isDot()) {\n                    continue;\n                }\n\n                $files[] = $fpath = $file->getPathname();\n\n                $br = false;\n                $stat = array();\n\n                $stat['isowner'] = false;\n                $linkreadable = false;\n                if ($file->isLink()) {\n                    if (!$followSymLinks) {\n                        continue;\n                    }\n                    if (!($target = $this->readlink($fpath))\n                        || $target == $fpath) {\n                        if (is_null($target)) {\n                            $stat = array();\n                            $br = true;\n                        } else {\n                            $_path = $fpath;\n                            $stat['mime'] = 'symlink-broken';\n                            $target = readlink($_path);\n                            $lstat = lstat($_path);\n                            $ostat = $this->getOwnerStat($lstat['uid'], $lstat['gid']);\n                            $linkreadable = !empty($ostat['isowner']);\n                            $dir = false;\n                            $stat['alias'] = $this->_path($target);\n                            $stat['target'] = $target;\n                        }\n                    } else {\n                        $dir = is_dir($target);\n                        $stat['alias'] = $this->_path($target);\n                        $stat['target'] = $target;\n                        $stat['mime'] = $dir ? 'directory' : $this->mimetype($stat['alias']);\n                    }\n                } else {\n                    if (($dir = $file->isDir()) && $this->options['detectDirIcon']) {\n                        $path = $file->getPathname();\n                        $favicon = $path . DIRECTORY_SEPARATOR . $this->options['detectDirIcon'];\n                        if ($this->URL && file_exists($favicon)) {\n                            $stat['icon'] = $this->URL . str_replace(DIRECTORY_SEPARATOR, '/', substr($favicon, strlen($this->root) + 1));\n                        }\n                    }\n                    $stat['mime'] = $dir ? 'directory' : $this->mimetype($fpath);\n                }\n                $size = sprintf('%u', $file->getSize());\n                $stat['ts'] = $file->getMTime();\n                if (!$br) {\n                    if ($this->statOwner && !$linkreadable) {\n                        $uid = $file->getOwner();\n                        $gid = $file->getGroup();\n                        $stat['perm'] = substr((string)decoct($file->getPerms()), -4);\n                        $stat = array_merge($stat, $this->getOwnerStat($uid, $gid));\n                    }\n\n                    //logical rights first\n                    $stat['read'] = ($linkreadable || $file->isReadable()) ? null : false;\n                    $stat['write'] = $file->isWritable() ? null : false;\n                    $stat['locked'] = $dirWritable ? null : true;\n\n                    if (is_null($stat['read'])) {\n                        $stat['size'] = $dir ? 0 : $size;\n                    }\n\n                    if ($this->options['statCorrector']) {\n                        call_user_func_array($this->options['statCorrector'], array(&$stat, $fpath, $this->statOwner, $this));\n                    }\n                }\n\n                $cache[] = array($fpath, $stat);\n            } catch (RuntimeException $e) {\n                continue;\n            }\n        }\n\n        if ($cache) {\n            $cache = $this->convEncOut($cache, false);\n            foreach ($cache as $d) {\n                $this->updateCache($d[0], $d[1]);\n            }\n        }\n\n        return $files;\n    }\n\n    /**\n     * Open file and return file pointer\n     *\n     * @param  string $path file path\n     * @param string  $mode\n     *\n     * @return false|resource\n     * @internal param bool $write open file for writing\n     * @author   Dmitry (dio) Levashov\n     */\n    protected function _fopen($path, $mode = 'rb')\n    {\n        return fopen($path, $mode);\n    }\n\n    /**\n     * Close opened file\n     *\n     * @param  resource $fp file pointer\n     * @param string    $path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     */\n    protected function _fclose($fp, $path = '')\n    {\n        return (is_resource($fp) && fclose($fp));\n    }\n\n    /********************  file/dir manipulations *************************/\n\n    /**\n     * Create dir and return created dir path or false on failed\n     *\n     * @param  string $path parent dir path\n     * @param string  $name new directory name\n     *\n     * @return string|bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _mkdir($path, $name)\n    {\n        $path = $this->_joinPath($path, $name);\n\n        if (mkdir($path)) {\n            chmod($path, $this->options['dirMode']);\n            return $path;\n        }\n\n        return false;\n    }\n\n    /**\n     * Create file and return it's path or false on failed\n     *\n     * @param  string $path parent dir path\n     * @param string  $name new file name\n     *\n     * @return string|bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _mkfile($path, $name)\n    {\n        $path = $this->_joinPath($path, $name);\n\n        if (($fp = fopen($path, 'w'))) {\n            fclose($fp);\n            chmod($path, $this->options['fileMode']);\n            return $path;\n        }\n        return false;\n    }\n\n    /**\n     * Create symlink\n     *\n     * @param  string $source    file to link to\n     * @param  string $targetDir folder to create link in\n     * @param  string $name      symlink name\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _symlink($source, $targetDir, $name)\n    {\n        return symlink($source, $this->_joinPath($targetDir, $name));\n    }\n\n    /**\n     * Copy file into another file\n     *\n     * @param  string $source    source file path\n     * @param  string $targetDir target directory path\n     * @param  string $name      new file name\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _copy($source, $targetDir, $name)\n    {\n        $mtime = filemtime($source);\n        $target = $this->_joinPath($targetDir, $name);\n        if ($ret = copy($source, $target)) {\n            isset($this->options['keepTimestamp']['copy']) && $mtime && touch($target, $mtime);\n        }\n        return $ret;\n    }\n\n    /**\n     * Move file into another parent dir.\n     * Return new file path or false.\n     *\n     * @param  string $source source file path\n     * @param         $targetDir\n     * @param  string $name   file name\n     *\n     * @return bool|string\n     * @internal param string $target target dir path\n     * @author   Dmitry (dio) Levashov\n     */\n    protected function _move($source, $targetDir, $name)\n    {\n        $mtime = filemtime($source);\n        $target = $this->_joinPath($targetDir, $name);\n        if ($ret = rename($source, $target) ? $target : false) {\n            isset($this->options['keepTimestamp']['move']) && $mtime && touch($target, $mtime);\n        }\n        return $ret;\n    }\n\n    /**\n     * Remove file\n     *\n     * @param  string $path file path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _unlink($path)\n    {\n        return is_file($path) && unlink($path);\n    }\n\n    /**\n     * Remove dir\n     *\n     * @param  string $path dir path\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _rmdir($path)\n    {\n        return rmdir($path);\n    }\n\n    /**\n     * Create new file and write into it from file pointer.\n     * Return new file path or false on error.\n     *\n     * @param  resource $fp   file pointer\n     * @param  string   $dir  target dir path\n     * @param  string   $name file name\n     * @param  array    $stat file stat (required by some virtual fs)\n     *\n     * @return bool|string\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _save($fp, $dir, $name, $stat)\n    {\n        $path = $this->_joinPath($dir, $name);\n\n        $meta = stream_get_meta_data($fp);\n        $uri = isset($meta['uri']) ? $meta['uri'] : '';\n        if ($uri && !preg_match('#^[a-zA-Z0-9]+://#', $uri) && !is_link($uri)) {\n            fclose($fp);\n            $mtime = filemtime($uri);\n            $isCmdPaste = ($this->ARGS['cmd'] === 'paste');\n            $isCmdCopy = ($isCmdPaste && empty($this->ARGS['cut']));\n            if (($isCmdCopy || !rename($uri, $path)) && !copy($uri, $path)) {\n                return false;\n            }\n            // keep timestamp on upload\n            if ($mtime && $this->ARGS['cmd'] === 'upload') {\n                touch($path, isset($this->options['keepTimestamp']['upload']) ? $mtime : time());\n            }\n        } else {\n            if (file_put_contents($path, $fp, LOCK_EX) === false) {\n                return false;\n            }\n        }\n\n        chmod($path, $this->options['fileMode']);\n        return $path;\n    }\n\n    /**\n     * Get file contents\n     *\n     * @param  string $path file path\n     *\n     * @return string|false\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _getContents($path)\n    {\n        return file_get_contents($path);\n    }\n\n    /**\n     * Write a string to a file\n     *\n     * @param  string $path    file path\n     * @param  string $content new file content\n     *\n     * @return bool\n     * @author Dmitry (dio) Levashov\n     **/\n    protected function _filePutContents($path, $content)\n    {\n        return (file_put_contents($path, $content, LOCK_EX) !== false);\n    }\n\n    /**\n     * Detect available archivers\n     *\n     * @return void\n     * @throws elFinderAbortException\n     */\n    protected function _checkArchivers()\n    {\n        $this->archivers = $this->getArchivers();\n        return;\n    }\n\n    /**\n     * chmod availability\n     *\n     * @param string $path\n     * @param string $mode\n     *\n     * @return bool\n     */\n    protected function _chmod($path, $mode)\n    {\n        $modeOct = is_string($mode) ? octdec($mode) : octdec(sprintf(\"%04o\", $mode));\n        return chmod($path, $modeOct);\n    }\n\n    /**\n     * Recursive symlinks search\n     *\n     * @param  string $path file/dir path\n     *\n     * @return bool\n     * @throws Exception\n     * @author Dmitry (dio) Levashov\n     */\n    protected function _findSymlinks($path)\n    {\n        return self::localFindSymlinks($path);\n    }\n\n    /**\n     * Extract files from archive\n     *\n     * @param  string $path archive path\n     * @param  array  $arc  archiver command and arguments (same as in $this->archivers)\n     *\n     * @return array|string|boolean\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     */\n    protected function _extract($path, $arc)\n    {\n\n        if ($this->quarantine) {\n\n            $dir = $this->quarantine . DIRECTORY_SEPARATOR . md5(basename($path) . mt_rand());\n            $archive = (isset($arc['toSpec']) || $arc['cmd'] === 'phpfunction') ? '' : $dir . DIRECTORY_SEPARATOR . basename($path);\n\n            if (!mkdir($dir)) {\n                return false;\n            }\n\n            // insurance unexpected shutdown\n            register_shutdown_function(array($this, 'rmdirRecursive'), realpath($dir));\n\n            chmod($dir, 0777);\n\n            // copy in quarantine\n            if (!is_readable($path) || ($archive && !copy($path, $archive))) {\n                return false;\n            }\n\n            // extract in quarantine\n            try {\n                $this->unpackArchive($path, $arc, $archive ? true : $dir);\n            } catch(Exception $e) {\n                return $this->setError($e->getMessage());\n            }\n\n            // get files list\n            try {\n                $ls = self::localScandir($dir);\n            } catch (Exception $e) {\n                return false;\n            }\n\n            // no files - extract error ?\n            if (empty($ls)) {\n                return false;\n            }\n\n            $this->archiveSize = 0;\n\n            // find symlinks and check extracted items\n            $checkRes = $this->checkExtractItems($dir);\n            if ($checkRes['symlinks']) {\n                self::localRmdirRecursive($dir);\n                return $this->setError(array_merge($this->error, array(elFinder::ERROR_ARC_SYMLINKS)));\n            }\n            $this->archiveSize = $checkRes['totalSize'];\n            if ($checkRes['rmNames']) {\n                foreach ($checkRes['rmNames'] as $name) {\n                    $this->addError(elFinder::ERROR_SAVE, $name);\n                }\n            }\n\n            // check max files size\n            if ($this->options['maxArcFilesSize'] > 0 && $this->options['maxArcFilesSize'] < $this->archiveSize) {\n                $this->delTree($dir);\n                return $this->setError(elFinder::ERROR_ARC_MAXSIZE);\n            }\n\n            $extractTo = $this->extractToNewdir; // 'auto', ture or false\n\n            // archive contains one item - extract in archive dir\n            $name = '';\n            $src = $dir . DIRECTORY_SEPARATOR . $ls[0];\n            if (($extractTo === 'auto' || !$extractTo) && count($ls) === 1 && is_file($src)) {\n                $name = $ls[0];\n            } else if ($extractTo === 'auto' || $extractTo) {\n                // for several files - create new directory\n                // create unique name for directory\n                $src = $dir;\n                $splits = elFinder::splitFileExtention(basename($path));\n                $name = $splits[0];\n                $test = dirname($path) . DIRECTORY_SEPARATOR . $name;\n                if (file_exists($test) || is_link($test)) {\n                    $name = $this->uniqueName(dirname($path), $name, '-', false);\n                }\n            }\n\n            if ($name !== '') {\n                $result = dirname($path) . DIRECTORY_SEPARATOR . $name;\n\n                if (!rename($src, $result)) {\n                    $this->delTree($dir);\n                    return false;\n                }\n            } else {\n                $dstDir = dirname($path);\n                $result = array();\n                foreach ($ls as $name) {\n                    $target = $dstDir . DIRECTORY_SEPARATOR . $name;\n                    if (self::localMoveRecursive($dir . DIRECTORY_SEPARATOR . $name, $target, true, $this->options['copyJoin'])) {\n                        $result[] = $target;\n                    }\n                }\n                if (!$result) {\n                    $this->delTree($dir);\n                    return false;\n                }\n            }\n\n            is_dir($dir) && $this->delTree($dir);\n\n            return (is_array($result) || file_exists($result)) ? $result : false;\n        }\n        //TODO: Add return statement here\n        return false;\n    }\n\n    /**\n     * Create archive and return its path\n     *\n     * @param  string $dir   target dir\n     * @param  array  $files files names list\n     * @param  string $name  archive name\n     * @param  array  $arc   archiver options\n     *\n     * @return string|bool\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov,\n     * @author Alexey Sukhotin\n     */\n    protected function _archive($dir, $files, $name, $arc)\n    {\n        return $this->makeArchive($dir, $files, $name, $arc);\n    }\n\n    /******************** Over write functions *************************/\n\n    /**\n     * File path of local server side work file path\n     *\n     * @param  string $path\n     *\n     * @return string\n     * @author Naoki Sawada\n     */\n    protected function getWorkFile($path)\n    {\n        return $path;\n    }\n\n    /**\n     * Delete dirctory trees\n     *\n     * @param string $localpath path need convert encoding to server encoding\n     *\n     * @return boolean\n     * @throws elFinderAbortException\n     * @author Naoki Sawada\n     */\n    protected function delTree($localpath)\n    {\n        return $this->rmdirRecursive($localpath);\n    }\n\n    /**\n     * Return fileinfo based on filename\n     * For item ID based path file system\n     * Please override if needed on each drivers\n     *\n     * @param  string $path file cache\n     *\n     * @return array|boolean false\n     */\n    protected function isNameExists($path)\n    {\n        $exists = file_exists($this->convEncIn($path));\n        // restore locale\n        $this->convEncOut();\n        return $exists ? $this->stat($path) : false;\n    }\n\n    /******************** Over write (Optimized) functions *************************/\n\n    /**\n     * Recursive files search\n     *\n     * @param  string $path dir path\n     * @param  string $q    search string\n     * @param  array  $mimes\n     *\n     * @return array\n     * @throws elFinderAbortException\n     * @author Dmitry (dio) Levashov\n     * @author Naoki Sawada\n     */\n    protected function doSearch($path, $q, $mimes)\n    {\n        if (!empty($this->doSearchCurrentQuery['matchMethod']) || $this->encoding || !class_exists('FilesystemIterator', false)) {\n            // has custom match method or non UTF-8, use elFinderVolumeDriver::doSearch()\n            return parent::doSearch($path, $q, $mimes);\n        }\n\n        $result = array();\n\n        $timeout = $this->options['searchTimeout'] ? $this->searchStart + $this->options['searchTimeout'] : 0;\n        if ($timeout && $timeout < time()) {\n            $this->setError(elFinder::ERROR_SEARCH_TIMEOUT, $this->path($this->encode($path)));\n            return $result;\n        }\n        elFinder::extendTimeLimit($this->options['searchTimeout'] + 30);\n\n        $match = array();\n        try {\n            $iterator = new RecursiveIteratorIterator(\n                new RecursiveCallbackFilterIterator(\n                    new RecursiveDirectoryIterator($path,\n                        FilesystemIterator::KEY_AS_PATHNAME |\n                        FilesystemIterator::SKIP_DOTS |\n                        ((defined('RecursiveDirectoryIterator::FOLLOW_SYMLINKS') && $this->options['followSymLinks']) ?\n                            RecursiveDirectoryIterator::FOLLOW_SYMLINKS : 0)\n                    ),\n                    array($this, 'localFileSystemSearchIteratorFilter')\n                ),\n                RecursiveIteratorIterator::SELF_FIRST,\n                RecursiveIteratorIterator::CATCH_GET_CHILD\n            );\n            foreach ($iterator as $key => $node) {\n                if ($timeout && ($this->error || $timeout < time())) {\n                    !$this->error && $this->setError(elFinder::ERROR_SEARCH_TIMEOUT, $this->path($this->encode($node->getPath)));\n                    break;\n                }\n                if ($node->isDir()) {\n                    if ($this->stripos($node->getFilename(), $q) !== false) {\n                        $match[] = $key;\n                    }\n                } else {\n                    $match[] = $key;\n                }\n            }\n        } catch (Exception $e) {\n        }\n\n        if ($match) {\n            foreach ($match as $p) {\n                if ($timeout && ($this->error || $timeout < time())) {\n                    !$this->error && $this->setError(elFinder::ERROR_SEARCH_TIMEOUT, $this->path($this->encode(dirname($p))));\n                    break;\n                }\n\n                $stat = $this->stat($p);\n\n                if (!$stat) { // invalid links\n                    continue;\n                }\n\n                if (!empty($stat['hidden']) || !$this->mimeAccepted($stat['mime'], $mimes)) {\n                    continue;\n                }\n\n                if ((!$mimes || $stat['mime'] !== 'directory')) {\n                    $stat['path'] = $this->path($stat['hash']);\n                    if ($this->URL && !isset($stat['url'])) {\n                        $_path = str_replace(DIRECTORY_SEPARATOR, '/', substr($p, strlen($this->root) + 1));\n                        $stat['url'] = $this->URL . str_replace('%2F', '/', rawurlencode($_path));\n                    }\n\n                    $result[] = $stat;\n                }\n            }\n        }\n\n        return $result;\n    }\n\n    /******************** Original local functions ************************\n     *\n     * @param $file\n     * @param $key\n     * @param $iterator\n     *\n     * @return bool\n     */\n\n    public function localFileSystemSearchIteratorFilter($file, $key, $iterator)\n    {\n        /* @var FilesystemIterator $file */\n        /* @var RecursiveDirectoryIterator $iterator */\n        $name = $file->getFilename();\n        if ($this->doSearchCurrentQuery['excludes']) {\n            foreach ($this->doSearchCurrentQuery['excludes'] as $exclude) {\n                if ($this->stripos($name, $exclude) !== false) {\n                    return false;\n                }\n            }\n        }\n        if ($iterator->hasChildren()) {\n            if ($this->options['searchExDirReg'] && preg_match($this->options['searchExDirReg'], $key)) {\n                return false;\n            }\n            return (bool)$this->attr($key, 'read', null, true);\n        }\n        return ($this->stripos($name, $this->doSearchCurrentQuery['q']) === false) ? false : true;\n    }\n\n    /**\n     * Creates a symbolic link\n     *\n     * @param      string   $target  The target\n     * @param      string   $link    The link\n     *\n     * @return     boolean  ( result of symlink() )\n     */\n    protected function localFileSystemSymlink($target, $link)\n    {\n        $res = false;\n        $errlev = error_reporting();\n        error_reporting($errlev ^ E_WARNING);\n        if ($res = symlink(realpath($target), $link)) {\n            $res = is_readable($link);\n        }\n        error_reporting($errlev);\n        return $res;\n    }\n} // END class \n"], "filenames": ["php/elFinderVolumeDriver.class.php", "php/elFinderVolumeLocalFileSystem.class.php"], "buggy_code_start_loc": [6796, 487], "buggy_code_end_loc": [6812, 487], "fixing_code_start_loc": [6797, 488], "fixing_code_end_loc": [6824, 489], "type": "CWE-22", "message": "connector.minimal.php in std42 elFinder through 2.1.60 is affected by path traversal. This allows unauthenticated remote attackers to read, write, and browse files outside the configured document root. This is due to improper handling of absolute file paths.", "other": {"cve": {"id": "CVE-2022-26960", "sourceIdentifier": "cve@mitre.org", "published": "2022-03-21T17:15:07.740", "lastModified": "2022-06-30T19:47:16.823", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "connector.minimal.php in std42 elFinder through 2.1.60 is affected by path traversal. This allows unauthenticated remote attackers to read, write, and browse files outside the configured document root. This is due to improper handling of absolute file paths."}, {"lang": "es", "value": "El archivo connector.minimal.php en std42 elFinder versiones hasta 2.1.60, est\u00e1 afectado por un salto de ruta. Esto permite a atacantes remotos no autenticados leer, escribir y navegar por archivos fuera del root del documento configurado. Esto es debido a un manejo inapropiado de las rutas absolutas de los archivos"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:std42:elfinder:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.61", "matchCriteriaId": "4E9D6EA0-1E01-4EEB-BBAF-E50A6344FF20"}]}]}], "references": [{"url": "https://github.com/Studio-42/elFinder/commit/3b758495538a448ac8830ee3559e7fb2c260c6db", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.synacktiv.com/publications.html", "source": "cve@mitre.org", "tags": ["Product"]}, {"url": "https://www.synacktiv.com/publications/elfinder-the-story-of-a-repwning.html", "source": "cve@mitre.org", "tags": ["Exploit", "Technical Description", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Studio-42/elFinder/commit/3b758495538a448ac8830ee3559e7fb2c260c6db"}}