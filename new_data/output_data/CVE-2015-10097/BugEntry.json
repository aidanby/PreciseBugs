{"buggy_code": ["<?php\nrequire_once ('Plans.php');\nnew SessionBroker();\nrequire ('functions-main.php');\nrequire (\"syntax-classes.php\");\n$idcookie = User::id();\n$dbh = db_connect();\n$page = new PlansPage('Plan', 'readplan', PLANSVNAME, 'read.php');\n$searchnum = (isset($_GET['searchnum']) ? $_GET['searchnum'] : false);\n$searchname = (isset($_GET['searchname']) ? $_GET['searchname'] : false);\nif (User::logged_in()) {\n    populate_page($page, $dbh, $idcookie);\n} else\n//begin guest user display\n{\n    populate_guest_page($page);\n}\nif (!$searchnum) //if no search number given\n{\n    if (isvaliduser($dbh, $searchname)) //if valid username, change to num\n    {\n        $searchnum = get_item($mydbh, \"userid\", \"accounts\", \"username\", $searchname);\n    } else\n    //if is not a valid username\n    {\n        if ($searchname) //if a searchname has been given\n        {\n            $searchname = htmlentities($searchname);\n            if ($idcookie) {\n                //if a searchname has been given, but there is no user with that exact name, search the usernames to see which if any users have that string in their username\n                $partial_list = partial_search($dbh, \"userid,username\", \"accounts\", \"username\", $searchname, \"username\");\n                $part_count = count($partial_list);\n                if ($part_count == 0) //if no users have that string in username, tell user\n                {\n                    $nouser = new AlertText(\"User <b>$searchname</b> does not exist and there are no names with the term in them.\", 'No such user');\n                    $page->append($nouser);\n                } else\n                //but if there are usernames with string in them, display them\n                {\n                    $nouser = new AlertText(\"User <b>$searchname</b> does not exist.<br>However there are <b>$part_count</b> names with $searchname in them.<br>These names are:\", 'No such user');;\n                    $page->append($nouser);\n                    $namelist = new WidgetList('partial_name_matches', true);\n                    $page->append($namelist);\n                    $o = 0;\n                    while ($partial_list[$o][0]) //loop through displaying the usernames as links\n                    {\n                        $name = new PlanLink($partial_list[$o][1]);\n                        $namelist->append($name);\n                        $o++;\n                    } //while ($partial_list [$o][0])\n                    \n                } //if partial names\n                $searchlink = new Hyperlink('search_for_term', true, \"search.php?mysearch=$searchname\", \"Search Plans for \\\"$searchname\\\"\");\n                $page->append($searchlink);\n            } else {\n                $err = new AlertText('There is either no plan with that name or it is not viewable to guests.' . ' Please <a href=\"index.php\">Log in</a> or <a href=\"register.php\">Register</a>.', 'Plan not available');\n                $page->append($err);\n            }\n        } else {\n            $err = new AlertText('Must enter a name', 'Input needed');\n            $page->append($err);\n        }\n        interface_disp_page($page);\n        db_disconnect($dbh);\n        exit();\n    } //if not valid username\n    \n} //$if (!$searchnum)\n//begin displaying if there is a user with name or number given\n// Create the new page\nif (User::logged_in()) {\n    //TODO add searchname instead?\n    $page->url = add_param($page->url, 'searchnum', $searchnum);\n    $addtolist = (isset($_POST['addtolist']) ? $_POST['addtolist'] : false);\n    // if person is manipulating which tier this plan is on their autoread list\n    if (isset($_POST['block_user'])) {\n        if ($_POST['block_user'] == 1) {\n            $user = User::get();\n            if ($user->webview == 1) {\n                $warning = new AlertText(\"Warning! Your plan is set to be viewable by guests. This will allow blocked users to read your plan\nsimply by logging out. If you would like to change this setting, please visit\n<a href=\\\"/webview.php\\\">the guest settings page</a>.\");\n                $page->append($warning);\n            }\n            Block::addBlock($idcookie, $searchnum);\n            $msg = new InfoText(\"<p>You have blocked this user. Blocking a user is one-directional. Selecting \\\"Block\\\" renders the contents of your plan unavailable to this user. Neither will see any [planlove] by the other, and any updates either make will not show up on each other\u2019s planwatch.</p>\n\n<p>If this block was made in error, please use the option at the bottom of the page to un-do.</p>\");\n        } else {\n            Block::removeBlock($idcookie, $searchnum);\n            $msg = new InfoText(\"User \" . $planinfo[0][0] . \" has been unblocked.\");\n        }\n        $page->append($msg);\n    } else if ($addtolist == 1) {\n        $privlevel = (isset($_POST['privlevel']) ? $_POST['privlevel'] : 0);\n        if ($privlevel == 0) {\n            mysql_query(\"DELETE FROM autofinger WHERE owner = '$idcookie' and interest = '$searchnum'\");\n            $yay = new InfoText(\"User \" . $planinfo[0][0] . \" removed from your autoread list.\");\n        } else {\n            mysql_query(\"INSERT INTO autofinger (owner, interest, priority) VALUES ('$idcookie', '$searchnum', '$privlevel') ON DUPLICATE KEY UPDATE priority=$privlevel\");\n            $yay = new InfoText(\"User \" . $planinfo[0][0] . \" is now on your autoread list with priority level of \" . $privlevel . \".\");\n        }\n        $page->append($yay);\n    }\n    // Update autofinger as read.\n    $my_result = mysql_query(\"Select priority From autofinger where owner = '$idcookie' and interest = '$searchnum'\");\n    $onlist = mysql_fetch_array($my_result);\n    if ($onlist) {\n        update_read($dbh, $idcookie, $searchnum); //mark as having been read\n        $myonlist = $onlist[0];\n        // Repopulate the page to get updated autoread\n        populate_page($page, $dbh, $idcookie);\n    } else {\n        $myonlist = \"X\"; //if not on autoread list, show is not on priority list\n        \n    }\n}\n//TODO should this go inside if(!$auth) ?\n$guest_auth = false;\nif ($guest_pass = $_GET['guest-pass']) {\n    $real_pass = get_item($dbh, \"guest_password\", \"accounts\", \"userid\", $searchnum);\n    //error_log(\"JLW real pass is $real_pass\");\n    if ($real_pass == '') {\n        $guest_auth = false;\n    } else if ($real_pass == $guest_pass) {\n        $guest_auth = true;\n    } else {\n        $guest_auth = false;\n    }\n}\n// Get the user and plan information\n$q = Doctrine_Query::create()->from('Accounts a')->leftJoin('a.Plan p')->where('a.userid = ?', $searchnum)->orderBy('p.id ASC');\n$user = $q->fetchOne();\nif (!$user) {\n    $page->append(new AlertText(\"Could not retrieve plan.\", 'DB Error', true));\n} else if (!$idcookie && $user->webview != 1 && !$guest_auth) {\n    $page->append(new AlertText(\"There is either no plan with that name or it is not viewable to guests.\", 'Plan not found', false));\n} else {\n    // Perform these queries once for the page\n    $is_blocking_this_user = Block::isBlocking($idcookie, $searchnum);\n    $this_user_is_blocking_you = Block::isBlocking($searchnum, $idcookie);\n\n    if ($this_user_is_blocking_you && !User::is_admin()) {\n        $blocked_msg = new AlertText(\"[$user->username] has enabled the block feature. This plan is not available.\");\n        $page->append($blocked_msg);\n    } else {\n        // If we're redirecting from edit.php, assure the user that their change was applied\n        if ($_GET['edit_submit'] == 1) {\n            $changed_msg = new InfoText('Plan changed successfully.');\n            $page->append($changed_msg);\n        }\n        if ($is_blocking_this_user) {\n            $blocked_msg = new InfoText(\"You have enabled the blocking feature for this user. This means the contents of your plan are unavailable to this user. Searching for your plan, quicklove, and planwatch are also disabled for this user. To unblock, use the button at the bottom of the page.\");\n            $page->append($blocked_msg);\n        }\n        // Get the plan text\n        $plantext = $user->Plan->plan;\n        // Jumble it if requested\n        if ($_GET['jumbled'] == 'yes' || ($_COOKIE['jumbled'] == 'yes' && $_GET['jumbled'] != 'no')) {\n            $plantext = jumble($plantext);\n        }\n        $plantext = new PlanText($plantext, false);\n        $thisplan = new PlanContent($user->username, $user->pseudo, strtotime($user->login), strtotime($user->changed), $plantext);\n        $page->append($thisplan);\n    }\n    $page->title = '[' . $user->username . \"]'s Plan\";\n    if (User::logged_in()) //if is a valid user, give them the option of putting the plan on their autoread list, or taking it off, and also if plan is on their autoread list, mark as read and mark time\n    {\n        if (!($searchnum == $idcookie)) //if person is not looking at their own plan, give them a small form to set the priority of the persons plan on their autoread list\n        {\n            if (!$this_user_is_blocking_you && !$is_blocking_this_user) {\n                $addform = new Form('autoreadadd', 'Set Priority');\n                $thisplan->addform = $addform;\n                $addform->action = \"read.php?searchnum=$searchnum\";\n                $addform->method = 'POST';\n                $item = new HiddenInput('addtolist', 1);\n                $addform->append($item);\n                $levels = new FormItemSet('readadd_levels', true);\n                $addform->append($levels);\n                for ($j = 0;$j < 4;$j++) {\n                    $item = new RadioInput('privlevel', $j);\n                    if ($j == 0) $item->description = 'X';\n                    else $item->description = \"$j\";\n                    $item->checked = ($myonlist == $item->description);\n                    $levels->append($item);\n                }\n                $item = new SubmitInput('Set Priority');\n                $addform->append($item);\n            }\n\n            $blocking = new Form('block', 'User blocking options');\n            $page->append($blocking);\n            if ($is_blocking_this_user) {\n                $item = new HiddenInput('block_user', 0);\n                $blocking->append($item);\n                $item = new SubmitInput('Unblock this user');\n                $blocking->append($item);\n                $explanation = new InfoText(\"You have blocked [$user->username]. Blocking a user is one-directional. Searching for your plan, quicklove, and planwatch are also disabled for this user. <a href=\\\"/blocking-about.php\\\">See the FAQ for more information</a>.\n                    <br /><br />If you wish to remove the block, select \\\"Unblock this user\\\".\");\n                $page->append($explanation);\n            } else {\n                $item = new HiddenInput('block_user', 1);\n                $blocking->append($item);\n                $item = new SubmitInput('Block this user');\n                $blocking->append($item);\n                $explanation = new InfoText('Blocking a user is one-directional. Selecting \"Block this user\" renders the contents of your plan unavailable to this user. Searching for your plan, quicklove, and planwatch will also be disabled for this user. <a href=\"/blocking-about.php\">See the FAQ for more information</a>.');\n                $page->append($explanation);\n            }\n        }\n    }\n}\ninterface_disp_page($page);\ndb_disconnect($dbh);\n?>\n"], "fixing_code": ["<?php\nrequire_once ('Plans.php');\nnew SessionBroker();\nrequire ('functions-main.php');\nrequire (\"syntax-classes.php\");\n$idcookie = User::id();\n$dbh = db_connect();\n$page = new PlansPage('Plan', 'readplan', PLANSVNAME, 'read.php');\n$searchnum = (isset($_GET['searchnum']) ? $_GET['searchnum'] : false);\n$searchname = (isset($_GET['searchname']) ? $_GET['searchname'] : false);\nif (User::logged_in()) {\n    populate_page($page, $dbh, $idcookie);\n} else\n//begin guest user display\n{\n    populate_guest_page($page);\n}\nif (!$searchnum) //if no search number given\n{\n    if (isvaliduser($dbh, $searchname)) //if valid username, change to num\n    {\n        $searchnum = get_item($mydbh, \"userid\", \"accounts\", \"username\", $searchname);\n    } else\n    //if is not a valid username\n    {\n        if ($searchname) //if a searchname has been given\n        {\n            $searchname = htmlentities($searchname);\n            if ($idcookie) {\n                //if a searchname has been given, but there is no user with that exact name, search the usernames to see which if any users have that string in their username\n                $partial_list = partial_search($dbh, \"userid,username\", \"accounts\", \"username\", $searchname, \"username\");\n                $part_count = count($partial_list);\n                if ($part_count == 0) //if no users have that string in username, tell user\n                {\n                    $nouser = new AlertText(\"User <b>$searchname</b> does not exist and there are no names with the term in them.\", 'No such user');\n                    $page->append($nouser);\n                } else\n                //but if there are usernames with string in them, display them\n                {\n                    $nouser = new AlertText(\"User <b>$searchname</b> does not exist.<br>However there are <b>$part_count</b> names with $searchname in them.<br>These names are:\", 'No such user');;\n                    $page->append($nouser);\n                    $namelist = new WidgetList('partial_name_matches', true);\n                    $page->append($namelist);\n                    $o = 0;\n                    while ($partial_list[$o][0]) //loop through displaying the usernames as links\n                    {\n                        $name = new PlanLink($partial_list[$o][1]);\n                        $namelist->append($name);\n                        $o++;\n                    } //while ($partial_list [$o][0])\n                    \n                } //if partial names\n                $searchlink = new Hyperlink('search_for_term', true, \"search.php?mysearch=$searchname\", \"Search Plans for \\\"$searchname\\\"\");\n                $page->append($searchlink);\n            } else {\n                $err = new AlertText('There is either no plan with that name or it is not viewable to guests.' . ' Please <a href=\"index.php\">Log in</a> or <a href=\"register.php\">Register</a>.', 'Plan not available');\n                $page->append($err);\n            }\n        } else {\n            $err = new AlertText('Must enter a name', 'Input needed');\n            $page->append($err);\n        }\n        interface_disp_page($page);\n        db_disconnect($dbh);\n        exit();\n    } //if not valid username\n    \n} //$if (!$searchnum)\n//begin displaying if there is a user with name or number given\n// Create the new page\nif (User::logged_in()) {\n    //TODO add searchname instead?\n    $page->url = add_param($page->url, 'searchnum', $searchnum);\n    $addtolist = (isset($_POST['addtolist']) ? (bool)$_POST['addtolist'] : false);\n    // if person is manipulating which tier this plan is on their autoread list\n    if (isset($_POST['block_user'])) {\n        if ($_POST['block_user'] == 1) {\n            $user = User::get();\n            if ($user->webview == 1) {\n                $warning = new AlertText(\"Warning! Your plan is set to be viewable by guests. This will allow blocked users to read your plan\nsimply by logging out. If you would like to change this setting, please visit\n<a href=\\\"/webview.php\\\">the guest settings page</a>.\");\n                $page->append($warning);\n            }\n            Block::addBlock($idcookie, $searchnum);\n            $msg = new InfoText(\"<p>You have blocked this user. Blocking a user is one-directional. Selecting \\\"Block\\\" renders the contents of your plan unavailable to this user. Neither will see any [planlove] by the other, and any updates either make will not show up on each other\u2019s planwatch.</p>\n\n<p>If this block was made in error, please use the option at the bottom of the page to un-do.</p>\");\n        } else {\n            Block::removeBlock($idcookie, $searchnum);\n            $msg = new InfoText(\"User \" . $planinfo[0][0] . \" has been unblocked.\");\n        }\n        $page->append($msg);\n    } else if ($addtolist) {\n        $privlevel = (isset($_POST['privlevel']) ? (int)$_POST['privlevel'] : 0);\n        if ($privlevel == 0) {\n            mysql_query(\"DELETE FROM autofinger WHERE owner = '$idcookie' and interest = '$searchnum'\");\n            $yay = new InfoText(\"User \" . $planinfo[0][0] . \" removed from your autoread list.\");\n        } else if ($privlevel > 0 && $privlevel <= 3) {\n            mysql_query(\"INSERT INTO autofinger (owner, interest, priority) VALUES ('$idcookie', '$searchnum', '$privlevel') ON DUPLICATE KEY UPDATE priority=$privlevel\");\n            $yay = new InfoText(\"User \" . $planinfo[0][0] . \" is now on your autoread list with priority level of \" . $privlevel . \".\");\n        }\n        $page->append($yay);\n    }\n    // Update autofinger as read.\n    $my_result = mysql_query(\"Select priority From autofinger where owner = '$idcookie' and interest = '$searchnum'\");\n    $onlist = mysql_fetch_array($my_result);\n    if ($onlist) {\n        update_read($dbh, $idcookie, $searchnum); //mark as having been read\n        $myonlist = $onlist[0];\n        // Repopulate the page to get updated autoread\n        populate_page($page, $dbh, $idcookie);\n    } else {\n        $myonlist = \"X\"; //if not on autoread list, show is not on priority list\n        \n    }\n}\n//TODO should this go inside if(!$auth) ?\n$guest_auth = false;\nif ($guest_pass = $_GET['guest-pass']) {\n    $real_pass = get_item($dbh, \"guest_password\", \"accounts\", \"userid\", $searchnum);\n    //error_log(\"JLW real pass is $real_pass\");\n    if ($real_pass == '') {\n        $guest_auth = false;\n    } else if ($real_pass == $guest_pass) {\n        $guest_auth = true;\n    } else {\n        $guest_auth = false;\n    }\n}\n// Get the user and plan information\n$q = Doctrine_Query::create()->from('Accounts a')->leftJoin('a.Plan p')->where('a.userid = ?', $searchnum)->orderBy('p.id ASC');\n$user = $q->fetchOne();\nif (!$user) {\n    $page->append(new AlertText(\"Could not retrieve plan.\", 'DB Error', true));\n} else if (!$idcookie && $user->webview != 1 && !$guest_auth) {\n    $page->append(new AlertText(\"There is either no plan with that name or it is not viewable to guests.\", 'Plan not found', false));\n} else {\n    // Perform these queries once for the page\n    $is_blocking_this_user = Block::isBlocking($idcookie, $searchnum);\n    $this_user_is_blocking_you = Block::isBlocking($searchnum, $idcookie);\n\n    if ($this_user_is_blocking_you && !User::is_admin()) {\n        $blocked_msg = new AlertText(\"[$user->username] has enabled the block feature. This plan is not available.\");\n        $page->append($blocked_msg);\n    } else {\n        // If we're redirecting from edit.php, assure the user that their change was applied\n        if ($_GET['edit_submit'] == 1) {\n            $changed_msg = new InfoText('Plan changed successfully.');\n            $page->append($changed_msg);\n        }\n        if ($is_blocking_this_user) {\n            $blocked_msg = new InfoText(\"You have enabled the blocking feature for this user. This means the contents of your plan are unavailable to this user. Searching for your plan, quicklove, and planwatch are also disabled for this user. To unblock, use the button at the bottom of the page.\");\n            $page->append($blocked_msg);\n        }\n        // Get the plan text\n        $plantext = $user->Plan->plan;\n        // Jumble it if requested\n        if ($_GET['jumbled'] == 'yes' || ($_COOKIE['jumbled'] == 'yes' && $_GET['jumbled'] != 'no')) {\n            $plantext = jumble($plantext);\n        }\n        $plantext = new PlanText($plantext, false);\n        $thisplan = new PlanContent($user->username, $user->pseudo, strtotime($user->login), strtotime($user->changed), $plantext);\n        $page->append($thisplan);\n    }\n    $page->title = '[' . $user->username . \"]'s Plan\";\n    if (User::logged_in()) //if is a valid user, give them the option of putting the plan on their autoread list, or taking it off, and also if plan is on their autoread list, mark as read and mark time\n    {\n        if (!($searchnum == $idcookie)) //if person is not looking at their own plan, give them a small form to set the priority of the persons plan on their autoread list\n        {\n            if (!$this_user_is_blocking_you && !$is_blocking_this_user) {\n                $addform = new Form('autoreadadd', 'Set Priority');\n                $thisplan->addform = $addform;\n                $addform->action = \"read.php?searchnum=$searchnum\";\n                $addform->method = 'POST';\n                $item = new HiddenInput('addtolist', 1);\n                $addform->append($item);\n                $levels = new FormItemSet('readadd_levels', true);\n                $addform->append($levels);\n                for ($j = 0;$j < 4;$j++) {\n                    $item = new RadioInput('privlevel', $j);\n                    if ($j == 0) $item->description = 'X';\n                    else $item->description = \"$j\";\n                    $item->checked = ($myonlist == $item->description);\n                    $levels->append($item);\n                }\n                $item = new SubmitInput('Set Priority');\n                $addform->append($item);\n            }\n\n            $blocking = new Form('block', 'User blocking options');\n            $page->append($blocking);\n            if ($is_blocking_this_user) {\n                $item = new HiddenInput('block_user', 0);\n                $blocking->append($item);\n                $item = new SubmitInput('Unblock this user');\n                $blocking->append($item);\n                $explanation = new InfoText(\"You have blocked [$user->username]. Blocking a user is one-directional. Searching for your plan, quicklove, and planwatch are also disabled for this user. <a href=\\\"/blocking-about.php\\\">See the FAQ for more information</a>.\n                    <br /><br />If you wish to remove the block, select \\\"Unblock this user\\\".\");\n                $page->append($explanation);\n            } else {\n                $item = new HiddenInput('block_user', 1);\n                $blocking->append($item);\n                $item = new SubmitInput('Block this user');\n                $blocking->append($item);\n                $explanation = new InfoText('Blocking a user is one-directional. Selecting \"Block this user\" renders the contents of your plan unavailable to this user. Searching for your plan, quicklove, and planwatch will also be disabled for this user. <a href=\"/blocking-about.php\">See the FAQ for more information</a>.');\n                $page->append($explanation);\n            }\n        }\n    }\n}\ninterface_disp_page($page);\ndb_disconnect($dbh);\n?>\n"], "filenames": ["read.php"], "buggy_code_start_loc": [74], "buggy_code_end_loc": [100], "fixing_code_start_loc": [74], "fixing_code_end_loc": [100], "type": "CWE-89", "message": "A vulnerability was found in grinnellplans-php up to 3.0. It has been declared as critical. Affected by this vulnerability is the function interface_disp_page/interface_disp_page of the file read.php. The manipulation leads to sql injection. The attack can be launched remotely. The name of the patch is 57e4409e19203a94495140ff1b5a697734d17cfb. It is recommended to apply a patch to fix this issue. The identifier VDB-223801 was assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2015-10097", "sourceIdentifier": "cna@vuldb.com", "published": "2023-03-25T18:15:09.387", "lastModified": "2023-03-31T00:49:16.990", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in grinnellplans-php up to 3.0. It has been declared as critical. Affected by this vulnerability is the function interface_disp_page/interface_disp_page of the file read.php. The manipulation leads to sql injection. The attack can be launched remotely. The name of the patch is 57e4409e19203a94495140ff1b5a697734d17cfb. It is recommended to apply a patch to fix this issue. The identifier VDB-223801 was assigned to this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}, {"source": "cna@vuldb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:grinnellplans:grinnellplans:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.0", "matchCriteriaId": "2ECD2BED-021E-4DA7-8DC2-794515E06DC5"}]}]}], "references": [{"url": "https://github.com/grinnellplans/grinnellplans-php/commit/57e4409e19203a94495140ff1b5a697734d17cfb", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.223801", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?id.223801", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/grinnellplans/grinnellplans-php/commit/57e4409e19203a94495140ff1b5a697734d17cfb"}}