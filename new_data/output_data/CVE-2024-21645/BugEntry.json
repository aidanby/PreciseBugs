{"buggy_code": ["# -*- coding: utf-8 -*-\n\nimport traceback\nfrom ast import literal_eval\nfrom itertools import chain\nfrom logging import getLogger\nfrom urllib.parse import unquote\n\nimport flask\nfrom flask.json import jsonify\nfrom pyload import APPID\n\nfrom ..helpers import clear_session, set_session\n\nbp = flask.Blueprint(\"api\", __name__)\nlog = getLogger(APPID)\n\n\n# accepting positional arguments, as well as kwargs via post and get\n# @bottle.route(\n@bp.route(\"/api/<func>\", methods=[\"GET\", \"POST\"], endpoint=\"rpc\")\n@bp.route(\"/api/<func>/<args>\", methods=[\"GET\", \"POST\"], endpoint=\"rpc\")\n# @apiver_check\ndef rpc(func, args=\"\"):\n    api = flask.current_app.config[\"PYLOAD_API\"]\n\n    if flask.request.authorization:\n        user = flask.request.authorization.get(\"username\", \"\")\n        password = flask.request.authorization.get(\"password\", \"\")\n    else:\n        user = flask.request.form.get(\"u\", \"\")\n        password = flask.request.form.get(\"p\", \"\")\n\n    if user:\n        user_info = api.check_auth(user, password)\n        s = set_session(user_info)\n    else:\n        s = flask.session\n\n    if (\n            \"role\" not in s or\n            \"perms\" not in s or\n            not api.is_authorized(func, {\"role\": s[\"role\"], \"permission\": s[\"perms\"]})\n    ):\n        return jsonify({'error': \"Unauthorized\"}), 401\n\n    args = args.split(\",\")\n    if len(args) == 1 and not args[0]:\n        args = []\n\n    kwargs = {}\n\n    for x, y in chain(flask.request.args.items(), flask.request.form.items()):\n        if x not in (\"u\", \"p\"):\n            kwargs[x] = unquote(y)\n\n    try:\n        response = call_api(func, *args, **kwargs)\n    except Exception as exc:\n        response = jsonify(error=str(exc), traceback=traceback.format_exc()), 500\n\n    return response\n\n\ndef call_api(func, *args, **kwargs):\n    api = flask.current_app.config[\"PYLOAD_API\"]\n\n    if func.startswith(\"_\"):\n        flask.flash(f\"Invalid API call '{func}'\")\n        return jsonify({'error': \"Forbidden\"}), 403\n\n    result = getattr(api, func)(\n        *[literal_eval(x) for x in args],\n        **{x: literal_eval(y) for x, y in kwargs.items()},\n    )\n\n    return jsonify(result)\n\n\n@bp.route(\"/api/login\", methods=[\"POST\"], endpoint=\"login\")\n# @apiver_check\ndef login():\n    user = flask.request.form[\"username\"]\n    password = flask.request.form[\"password\"]\n\n    api = flask.current_app.config[\"PYLOAD_API\"]\n    user_info = api.check_auth(user, password)\n\n    if not user_info:\n        log.error(f\"Login failed for user '{user}'\")\n        return jsonify(False)\n\n    s = set_session(user_info)\n    log.info(f\"User '{user}' successfully logged in\")\n    flask.flash(\"Logged in successfully\")\n\n    return jsonify(s)\n\n\n@bp.route(\"/api/logout\", endpoint=\"logout\")\n# @apiver_check\ndef logout():\n    s = flask.session\n    user = s.get(\"name\")\n    clear_session(s)\n    if user:\n        log.info(f\"User '{user}' logged out\")\n    return jsonify(True)\n", "# -*- coding: utf-8 -*-\n\nimport datetime\nimport mimetypes\nimport operator\nimport os\nimport re\nimport sys\nimport time\nfrom logging import getLogger\nfrom urllib.parse import unquote\n\nimport flask\nfrom pyload import APPID, PKGDIR\nfrom pyload.core.utils import format\n\nfrom ..helpers import (\n    clear_session, get_permission, get_redirect_url, is_authenticated, login_required, permlist, render_base,\n    render_template, set_session, static_file_url)\n\n_RE_LOGLINE = re.compile(r\"\\[([\\d\\-]+) ([\\d:]+)\\] +([A-Z]+) +(.+?) (.*)\")\n\nbp = flask.Blueprint(\"app\", __name__)\nlog = getLogger(APPID)\n\n\n@bp.route(\"/favicon.ico\", endpoint=\"favicon\")\ndef favicon():\n    location = static_file_url(\"img/favicon.ico\")\n    return flask.redirect(location)\n\n\n@bp.route(\"/render/<path:filename>\", endpoint=\"render\")\ndef render(filename):\n    mimetype = mimetypes.guess_type(filename)[0] or \"text/html\"\n    data = render_template(filename)\n    return flask.Response(data, mimetype=mimetype)\n\n\n@bp.route(\"/robots.txt\", endpoint=\"robots\")\ndef robots():\n    return \"User-agent: *\\nDisallow: /\"\n\n\n# TODO: Rewrite login route using flask-login\n@bp.route(\"/login\", methods=[\"GET\", \"POST\"], endpoint=\"login\")\ndef login():\n    api = flask.current_app.config[\"PYLOAD_API\"]\n\n    next = get_redirect_url(fallback=flask.url_for(\"app.dashboard\"))\n\n    if flask.request.method == \"POST\":\n        user = flask.request.form[\"username\"]\n        password = flask.request.form[\"password\"]\n        user_info = api.check_auth(user, password)\n\n        if not user_info:\n            log.error(f\"Login failed for user '{user}'\")\n            return render_template(\"login.html\", next=next, errors=True)\n\n        set_session(user_info)\n        log.info(f\"User '{user}' successfully logged in\")\n        flask.flash(\"Logged in successfully\")\n\n    if is_authenticated():\n        return flask.redirect(next)\n\n    if api.get_config_value(\"webui\", \"autologin\"):\n        allusers = api.get_all_userdata()\n        if len(allusers) == 1:  # TODO: check if localhost\n            user_info = list(allusers.values())[0]\n            set_session(user_info)\n            # NOTE: Double-check authentication here because if session[name] is empty,\n            #       next login_required redirects here again and all loop out.\n            if is_authenticated():\n                return flask.redirect(next)\n\n    return render_template(\"login.html\", next=next)\n\n\n@bp.route(\"/logout\", endpoint=\"logout\")\ndef logout():\n    s = flask.session\n    user = s.get(\"name\")\n    clear_session(s)\n    if user:\n        log.info(f\"User '{user}' logged out\")\n    return render_template(\"logout.html\")\n\n\n@bp.route(\"/\", endpoint=\"index\")\n@bp.route(\"/home\", endpoint=\"home\")\n@bp.route(\"/dashboard\", endpoint=\"dashboard\")\n@login_required(\"LIST\")\ndef dashboard():\n    api = flask.current_app.config[\"PYLOAD_API\"]\n    links = api.status_downloads()\n\n    for link in links:\n        if link[\"status\"] == 12:\n            current_size = link[\"size\"] - link[\"bleft\"]\n            formatted_speed = format.speed(link[\"speed\"])\n            link[\"info\"] = f\"{current_size} KiB @ {formatted_speed}\"\n\n    return render_template(\"dashboard.html\", res=links)\n\n\n@bp.route(\"/queue\", endpoint=\"queue\")\n@login_required(\"LIST\")\ndef queue():\n    api = flask.current_app.config[\"PYLOAD_API\"]\n    queue = api.get_queue()\n    queue.sort(key=operator.attrgetter(\"order\"))\n\n    return render_template(\"packages.html\", content=queue, target=1)\n\n\n@bp.route(\"/collector\", endpoint=\"collector\")\n@login_required(\"LIST\")\ndef collector():\n    api = flask.current_app.config[\"PYLOAD_API\"]\n    queue = api.get_collector()\n\n    queue.sort(key=operator.attrgetter(\"order\"))\n\n    return render_template(\"packages.html\", content=queue, target=0)\n\n\n@bp.route(\"/files\", endpoint=\"files\")\n@login_required(\"DOWNLOAD\")\ndef files():\n    api = flask.current_app.config[\"PYLOAD_API\"]\n    root = api.get_config_value(\"general\", \"storage_folder\")\n\n    if not os.path.isdir(root):\n        messages = [\"Download directory not found.\"]\n        return render_base(messages)\n    data = {\"folder\": [], \"files\": []}\n\n    for entry in sorted(os.listdir(root)):\n        if os.path.isdir(os.path.join(root, entry)):\n            folder = {\"name\": entry, \"path\": entry, \"files\": []}\n            files = os.listdir(os.path.join(root, entry))\n            for file in sorted(files):\n                try:\n                    if os.path.isfile(os.path.join(root, entry, file)):\n                        folder[\"files\"].append(file)\n                except Exception:\n                    pass\n\n            data[\"folder\"].append(folder)\n\n        elif os.path.isfile(os.path.join(root, entry)):\n            data[\"files\"].append(entry)\n\n    return render_template(\"files.html\", files=data)\n\n\n@bp.route(\"/files/get/<path:path>\", endpoint=\"get_file\")\n@login_required(\"DOWNLOAD\")\ndef get_file(path):\n    api = flask.current_app.config[\"PYLOAD_API\"]\n    path = unquote(path).replace(\"..\", \"\")\n    directory = api.get_config_value(\"general\", \"storage_folder\")\n    return flask.send_from_directory(directory, path, as_attachment=True)\n\n\n@bp.route(\"/settings\", endpoint=\"settings\")\n@login_required(\"SETTINGS\")\ndef settings():\n    api = flask.current_app.config[\"PYLOAD_API\"]\n    conf = api.get_config()\n    plugin = api.get_plugin_config()\n\n    conf_menu = []\n    plugin_menu = []\n\n    for entry in sorted(conf.keys()):\n        conf_menu.append((entry, conf[entry].description))\n\n    for entry in sorted(plugin.keys()):\n        plugin_menu.append((entry, plugin[entry].description))\n\n    accs = []\n\n    for userdata in api.get_accounts(False):\n        if userdata.trafficleft is None:\n            trafficleft = \"not available\"\n        elif userdata.trafficleft == -1:\n            trafficleft = \"unlimited\"\n        elif userdata.trafficleft == 0:\n            trafficleft = \"drained\"\n        else:\n            trafficleft = format.size(userdata.trafficleft)\n\n        if userdata.validuntil == -1:\n            validuntil = \"unlimited\"\n        elif not userdata.validuntil:\n            validuntil = \"not available\"\n        else:\n            t = time.localtime(userdata.validuntil)\n            validuntil = time.strftime(\"%d.%m.%Y\", t)\n\n        if \"time\" in userdata.options:\n            try:\n                _time = userdata.options[\"time\"][0]\n            except Exception:\n                _time = \"\"\n        else:\n            _time = \"\"\n\n        if \"limit_dl\" in userdata.options:\n            try:\n                limitdl = userdata.options[\"limit_dl\"][0]\n            except Exception:\n                limitdl = \"0\"\n        else:\n            limitdl = \"0\"\n\n        accs.append(\n            {\n                \"type\": userdata.type,\n                \"login\": userdata.login,\n                \"valid\": userdata.valid,\n                \"premium\": userdata.premium,\n                \"trafficleft\": trafficleft,\n                \"validuntil\": validuntil,\n                \"limitdl\": limitdl,\n                \"time\": _time,\n            }\n        )\n\n    all_users = api.get_all_userdata()\n    users = {}\n    for userdata in all_users.values():\n        name = userdata[\"name\"]\n        users[name] = {\"perms\": get_permission(userdata[\"permission\"])}\n        users[name][\"perms\"][\"admin\"] = userdata[\"role\"] == 0\n\n    admin_menu = {\n        \"permlist\": permlist(),\n        \"users\": users\n    }\n\n    context = {\n        \"conf\": {\"plugin\": plugin_menu, \"general\": conf_menu, \"accs\": accs, \"admin\": admin_menu},\n        \"types\": api.get_account_types(),\n    }\n    return render_template(\"settings.html\", **context)\n\n\n@bp.route(\"/pathchooser/\", endpoint=\"pathchooser\")\n@bp.route(\"/filechooser/\", endpoint=\"filechooser\")\n@login_required(\"STATUS\")\ndef pathchooser():\n    browse_for = \"folder\" if flask.request.endpoint == \"app.pathchooser\" else \"file\"\n    path = os.path.normpath(flask.request.args.get('path', \"\"))\n\n    if os.path.isfile(path):\n        oldfile = path\n        path = os.path.dirname(path)\n    else:\n        oldfile = \"\"\n\n    abs = False\n\n    if os.path.isdir(path):\n        if os.path.isabs(path):\n            cwd = os.path.realpath(path)\n            abs = True\n        else:\n            cwd = os.path.relpath(path)\n    else:\n        cwd = os.getcwd()\n\n    cwd = os.path.normpath(os.path.realpath(cwd))\n    parentdir = os.path.dirname(cwd)\n    if not abs:\n        if os.path.realpath(cwd) == os.path.realpath(\"/\"):\n            cwd = os.path.relpath(cwd)\n        else:\n            cwd = os.path.relpath(cwd) + os.path.sep\n        parentdir = os.path.relpath(parentdir) + os.path.sep\n\n    if os.path.realpath(cwd) == os.path.realpath(\"/\"):\n        parentdir = \"\"\n\n    try:\n        folders = os.listdir(cwd)\n    except Exception:\n        folders = []\n\n    files = []\n\n    for f in folders:\n        try:\n            data = {\"name\": f, \"fullpath\": os.path.join(cwd, f)}\n            data[\"sort\"] = data[\"fullpath\"].lower()\n            data[\"modified\"] = datetime.datetime.fromtimestamp(\n                int(os.path.getmtime(os.path.join(cwd, f)))\n            )\n            data[\"ext\"] = os.path.splitext(f)[1]\n        except Exception:\n            continue\n\n        if os.path.isfile(os.path.join(cwd, f)):\n            data[\"type\"] = \"file\"\n            data[\"size\"] = os.path.getsize(os.path.join(cwd, f))\n\n            power = 0\n            while (data[\"size\"] >> 10) > 0.3:\n                power += 1\n                data[\"size\"] >>= 10\n            units = (\"\", \"K\", \"M\", \"G\", \"T\")\n            data[\"unit\"] = units[power] + \"Byte\"\n        else:\n            data[\"type\"] = \"dir\"\n            data[\"size\"] = \"\"\n\n        files.append(data)\n\n    files = sorted(files, key=operator.itemgetter(\"type\", \"sort\"))\n\n    context = {\n        \"cwd\": cwd,\n        \"files\": files,\n        \"parentdir\": parentdir,\n        \"type\": browse_for,\n        \"oldfile\": oldfile,\n        \"absolute\": abs,\n    }\n    return render_template(\"pathchooser.html\", **context)\n\n\n@bp.route(\"/logs\", methods=[\"GET\", \"POST\"], endpoint=\"logs\")\n@bp.route(\"/logs/<int:start_line>\", methods=[\"GET\", \"POST\"], endpoint=\"logs\")\n@login_required(\"LOGS\")\ndef logs(start_line=-1):\n    s = flask.session\n    api = flask.current_app.config[\"PYLOAD_API\"]\n\n    per_page = s.get(\"perpage\", 34)\n    reversed = s.get(\"reversed\", False)\n\n    warning = \"\"\n    conf = api.get_config_value(\"log\", \"filelog\")\n    if not conf:\n        warning = \"Warning: File log is disabled, see settings page.\"\n\n    per_page_selection = ((20, 20), (34, 34), (40, 40), (100, 100), (0, \"all\"))\n    fro = None\n\n    if flask.request.method == \"POST\":\n        try:\n            from_form = flask.request.form[\"from\"]\n            fro = datetime.datetime.strptime(from_form, \"%Y-%m-%d %H:%M:%S\")\n        except Exception:\n            pass\n\n        per_page = int(flask.request.form.get(\"perpage\", 34))\n        s[\"perpage\"] = per_page\n\n        reversed = bool(flask.request.form.get(\"reversed\", False))\n        s[\"reversed\"] = reversed\n\n        # s.modified = True\n\n    log_entries = api.get_log()\n    if not per_page:\n        start_line = 0\n\n    if start_line < 1:\n        start_line = (\n            1 if len(log_entries) - per_page + 1 < 1 or per_page == 0 else len(log_entries) - per_page + 1\n        )\n\n    if isinstance(fro, datetime.datetime):  #: we will search for datetime.datetime\n        start_line = -1\n\n    data = []\n    inpage_counter = 0\n    for counter, logline in enumerate(log_entries, start=1):\n        if counter >= start_line:\n            try:\n                date, time, level, source, message = _RE_LOGLINE.match(logline).groups()\n                dtime = datetime.datetime.strptime(\n                    date + \" \" + time, \"%Y-%m-%d %H:%M:%S\"\n                )\n                message = message.strip()\n            except (AttributeError, IndexError):\n                dtime = None\n                date = \"?\"\n                time = \" \"\n                level = \"?\"\n                source = \"?\"\n                message = logline\n            if start_line == -1 and dtime is not None and fro <= dtime:\n                start_line = counter  #: found our datetime.datetime\n\n            if start_line >= 0:\n                data.append(\n                    {\n                        \"line\": counter,\n                        \"date\": date + \" \" + time,\n                        \"level\": level,\n                        \"source\": source,\n                        \"message\": message.rstrip('\\n'),\n                    }\n                )\n                inpage_counter += 1\n                if (\n                    fro is None and dtime is not None\n                ):  #: if fro not set, set it to first showed line\n                    fro = dtime\n            if inpage_counter >= per_page > 0:\n                break\n\n    if fro is None:  #: still not set, empty log?\n        fro = datetime.datetime.now()\n\n    if reversed:\n        data.reverse()\n\n    context = {\n        \"warning\": warning,\n        \"log\": data,\n        \"from\": fro.strftime(\"%Y-%m-%d %H:%M:%S\"),\n        \"reversed\": reversed,\n        \"perpage\": per_page,\n        \"perpage_p\": sorted(per_page_selection),\n        \"iprev\": max(start_line - per_page, 1),\n        \"inext\": (start_line + per_page) if start_line + per_page <= len(log_entries) else start_line,\n    }\n    return render_template(\"logs.html\", **context)\n\n\n@bp.route(\"/filemanager\", endpoint=\"filemanager\")\n@login_required(\"MODIFY\")\ndef filemanager(path):\n    return render_template(\"filemanager.html\")\n\n\n@bp.route(\"/info\", endpoint=\"info\")\n@login_required(\"STATUS\")\ndef info():\n    api = flask.current_app.config[\"PYLOAD_API\"]\n    conf = api.get_config_dict()\n    extra = os.uname() if hasattr(os, \"uname\") else tuple()\n\n    context = {\n        \"python\": sys.version,\n        \"os\": \" \".join((os.name, sys.platform) + extra),\n        \"version\": api.get_server_version(),\n        \"folder\": PKGDIR,\n        \"config_folder\": api.get_userdir(),\n        \"download\": conf[\"general\"][\"storage_folder\"][\"value\"],\n        \"freespace\": format.size(api.free_space()),\n        \"webif\": conf[\"webui\"][\"port\"][\"value\"],\n        \"language\": conf[\"general\"][\"language\"][\"value\"],\n    }\n    return render_template(\"info.html\", **context)\n"], "fixing_code": ["# -*- coding: utf-8 -*-\n\nimport traceback\nfrom ast import literal_eval\nfrom itertools import chain\nfrom logging import getLogger\nfrom urllib.parse import unquote\n\nimport flask\nfrom flask.json import jsonify\nfrom pyload import APPID\n\nfrom ..helpers import clear_session, set_session\n\nbp = flask.Blueprint(\"api\", __name__)\nlog = getLogger(APPID)\n\n\n# accepting positional arguments, as well as kwargs via post and get\n# @bottle.route(\n@bp.route(\"/api/<func>\", methods=[\"GET\", \"POST\"], endpoint=\"rpc\")\n@bp.route(\"/api/<func>/<args>\", methods=[\"GET\", \"POST\"], endpoint=\"rpc\")\n# @apiver_check\ndef rpc(func, args=\"\"):\n    api = flask.current_app.config[\"PYLOAD_API\"]\n\n    if flask.request.authorization:\n        user = flask.request.authorization.get(\"username\", \"\")\n        password = flask.request.authorization.get(\"password\", \"\")\n    else:\n        user = flask.request.form.get(\"u\", \"\")\n        password = flask.request.form.get(\"p\", \"\")\n\n    if user:\n        user_info = api.check_auth(user, password)\n        s = set_session(user_info)\n    else:\n        s = flask.session\n\n    if (\n            \"role\" not in s or\n            \"perms\" not in s or\n            not api.is_authorized(func, {\"role\": s[\"role\"], \"permission\": s[\"perms\"]})\n    ):\n        return jsonify({'error': \"Unauthorized\"}), 401\n\n    args = args.split(\",\")\n    if len(args) == 1 and not args[0]:\n        args = []\n\n    kwargs = {}\n\n    for x, y in chain(flask.request.args.items(), flask.request.form.items()):\n        if x not in (\"u\", \"p\"):\n            kwargs[x] = unquote(y)\n\n    try:\n        response = call_api(func, *args, **kwargs)\n    except Exception as exc:\n        response = jsonify(error=str(exc), traceback=traceback.format_exc()), 500\n\n    return response\n\n\ndef call_api(func, *args, **kwargs):\n    api = flask.current_app.config[\"PYLOAD_API\"]\n\n    if func.startswith(\"_\"):\n        flask.flash(f\"Invalid API call '{func}'\")\n        return jsonify({'error': \"Forbidden\"}), 403\n\n    result = getattr(api, func)(\n        *[literal_eval(x) for x in args],\n        **{x: literal_eval(y) for x, y in kwargs.items()},\n    )\n\n    return jsonify(result)\n\n\n@bp.route(\"/api/login\", methods=[\"POST\"], endpoint=\"login\")\n# @apiver_check\ndef login():\n    user = flask.request.form[\"username\"]\n    password = flask.request.form[\"password\"]\n\n    api = flask.current_app.config[\"PYLOAD_API\"]\n    user_info = api.check_auth(user, password)\n\n    sanitized_user = user.replace(\"\\n\", \"\\\\n\").replace(\"\\r\", \"\\\\r\")\n    if not user_info:\n        log.error(f\"Login failed for user '{sanitized_user}'\")\n        return jsonify(False)\n\n    s = set_session(user_info)\n    log.info(f\"User '{sanitized_user}' successfully logged in\")\n    flask.flash(\"Logged in successfully\")\n\n    return jsonify(s)\n\n\n@bp.route(\"/api/logout\", endpoint=\"logout\")\n# @apiver_check\ndef logout():\n    s = flask.session\n    user = s.get(\"name\")\n    clear_session(s)\n    if user:\n        log.info(f\"User '{user}' logged out\")\n    return jsonify(True)\n", "# -*- coding: utf-8 -*-\n\nimport datetime\nimport mimetypes\nimport operator\nimport os\nimport re\nimport sys\nimport time\nfrom logging import getLogger\nfrom urllib.parse import unquote\n\nimport flask\nfrom pyload import APPID, PKGDIR\nfrom pyload.core.utils import format\n\nfrom ..helpers import (\n    clear_session, get_permission, get_redirect_url, is_authenticated, login_required, permlist, render_base,\n    render_template, set_session, static_file_url)\n\n_RE_LOGLINE = re.compile(r\"\\[([\\d\\-]+) ([\\d:]+)\\] +([A-Z]+) +(.+?) (.*)\")\n\nbp = flask.Blueprint(\"app\", __name__)\nlog = getLogger(APPID)\n\n\n@bp.route(\"/favicon.ico\", endpoint=\"favicon\")\ndef favicon():\n    location = static_file_url(\"img/favicon.ico\")\n    return flask.redirect(location)\n\n\n@bp.route(\"/render/<path:filename>\", endpoint=\"render\")\ndef render(filename):\n    mimetype = mimetypes.guess_type(filename)[0] or \"text/html\"\n    data = render_template(filename)\n    return flask.Response(data, mimetype=mimetype)\n\n\n@bp.route(\"/robots.txt\", endpoint=\"robots\")\ndef robots():\n    return \"User-agent: *\\nDisallow: /\"\n\n\n# TODO: Rewrite login route using flask-login\n@bp.route(\"/login\", methods=[\"GET\", \"POST\"], endpoint=\"login\")\ndef login():\n    api = flask.current_app.config[\"PYLOAD_API\"]\n\n    next = get_redirect_url(fallback=flask.url_for(\"app.dashboard\"))\n\n    if flask.request.method == \"POST\":\n        user = flask.request.form[\"username\"]\n        password = flask.request.form[\"password\"]\n        user_info = api.check_auth(user, password)\n\n        sanitized_user = user.replace(\"\\n\", \"\\\\n\").replace(\"\\r\", \"\\\\r\")\n        if not user_info:\n            log.error(f\"Login failed for user '{sanitized_user}'\")\n            return render_template(\"login.html\", next=next, errors=True)\n\n        set_session(user_info)\n        log.info(f\"User '{sanitized_user}' successfully logged in\")\n        flask.flash(\"Logged in successfully\")\n\n    if is_authenticated():\n        return flask.redirect(next)\n\n    if api.get_config_value(\"webui\", \"autologin\"):\n        allusers = api.get_all_userdata()\n        if len(allusers) == 1:  # TODO: check if localhost\n            user_info = list(allusers.values())[0]\n            set_session(user_info)\n            # NOTE: Double-check authentication here because if session[name] is empty,\n            #       next login_required redirects here again and all loop out.\n            if is_authenticated():\n                return flask.redirect(next)\n\n    return render_template(\"login.html\", next=next)\n\n\n@bp.route(\"/logout\", endpoint=\"logout\")\ndef logout():\n    s = flask.session\n    user = s.get(\"name\")\n    clear_session(s)\n    if user:\n        log.info(f\"User '{user}' logged out\")\n    return render_template(\"logout.html\")\n\n\n@bp.route(\"/\", endpoint=\"index\")\n@bp.route(\"/home\", endpoint=\"home\")\n@bp.route(\"/dashboard\", endpoint=\"dashboard\")\n@login_required(\"LIST\")\ndef dashboard():\n    api = flask.current_app.config[\"PYLOAD_API\"]\n    links = api.status_downloads()\n\n    for link in links:\n        if link[\"status\"] == 12:\n            current_size = link[\"size\"] - link[\"bleft\"]\n            formatted_speed = format.speed(link[\"speed\"])\n            link[\"info\"] = f\"{current_size} KiB @ {formatted_speed}\"\n\n    return render_template(\"dashboard.html\", res=links)\n\n\n@bp.route(\"/queue\", endpoint=\"queue\")\n@login_required(\"LIST\")\ndef queue():\n    api = flask.current_app.config[\"PYLOAD_API\"]\n    queue = api.get_queue()\n    queue.sort(key=operator.attrgetter(\"order\"))\n\n    return render_template(\"packages.html\", content=queue, target=1)\n\n\n@bp.route(\"/collector\", endpoint=\"collector\")\n@login_required(\"LIST\")\ndef collector():\n    api = flask.current_app.config[\"PYLOAD_API\"]\n    queue = api.get_collector()\n\n    queue.sort(key=operator.attrgetter(\"order\"))\n\n    return render_template(\"packages.html\", content=queue, target=0)\n\n\n@bp.route(\"/files\", endpoint=\"files\")\n@login_required(\"DOWNLOAD\")\ndef files():\n    api = flask.current_app.config[\"PYLOAD_API\"]\n    root = api.get_config_value(\"general\", \"storage_folder\")\n\n    if not os.path.isdir(root):\n        messages = [\"Download directory not found.\"]\n        return render_base(messages)\n    data = {\"folder\": [], \"files\": []}\n\n    for entry in sorted(os.listdir(root)):\n        if os.path.isdir(os.path.join(root, entry)):\n            folder = {\"name\": entry, \"path\": entry, \"files\": []}\n            files = os.listdir(os.path.join(root, entry))\n            for file in sorted(files):\n                try:\n                    if os.path.isfile(os.path.join(root, entry, file)):\n                        folder[\"files\"].append(file)\n                except Exception:\n                    pass\n\n            data[\"folder\"].append(folder)\n\n        elif os.path.isfile(os.path.join(root, entry)):\n            data[\"files\"].append(entry)\n\n    return render_template(\"files.html\", files=data)\n\n\n@bp.route(\"/files/get/<path:path>\", endpoint=\"get_file\")\n@login_required(\"DOWNLOAD\")\ndef get_file(path):\n    api = flask.current_app.config[\"PYLOAD_API\"]\n    path = unquote(path).replace(\"..\", \"\")\n    directory = api.get_config_value(\"general\", \"storage_folder\")\n    return flask.send_from_directory(directory, path, as_attachment=True)\n\n\n@bp.route(\"/settings\", endpoint=\"settings\")\n@login_required(\"SETTINGS\")\ndef settings():\n    api = flask.current_app.config[\"PYLOAD_API\"]\n    conf = api.get_config()\n    plugin = api.get_plugin_config()\n\n    conf_menu = []\n    plugin_menu = []\n\n    for entry in sorted(conf.keys()):\n        conf_menu.append((entry, conf[entry].description))\n\n    for entry in sorted(plugin.keys()):\n        plugin_menu.append((entry, plugin[entry].description))\n\n    accs = []\n\n    for userdata in api.get_accounts(False):\n        if userdata.trafficleft is None:\n            trafficleft = \"not available\"\n        elif userdata.trafficleft == -1:\n            trafficleft = \"unlimited\"\n        elif userdata.trafficleft == 0:\n            trafficleft = \"drained\"\n        else:\n            trafficleft = format.size(userdata.trafficleft)\n\n        if userdata.validuntil == -1:\n            validuntil = \"unlimited\"\n        elif not userdata.validuntil:\n            validuntil = \"not available\"\n        else:\n            t = time.localtime(userdata.validuntil)\n            validuntil = time.strftime(\"%d.%m.%Y\", t)\n\n        if \"time\" in userdata.options:\n            try:\n                _time = userdata.options[\"time\"][0]\n            except Exception:\n                _time = \"\"\n        else:\n            _time = \"\"\n\n        if \"limit_dl\" in userdata.options:\n            try:\n                limitdl = userdata.options[\"limit_dl\"][0]\n            except Exception:\n                limitdl = \"0\"\n        else:\n            limitdl = \"0\"\n\n        accs.append(\n            {\n                \"type\": userdata.type,\n                \"login\": userdata.login,\n                \"valid\": userdata.valid,\n                \"premium\": userdata.premium,\n                \"trafficleft\": trafficleft,\n                \"validuntil\": validuntil,\n                \"limitdl\": limitdl,\n                \"time\": _time,\n            }\n        )\n\n    all_users = api.get_all_userdata()\n    users = {}\n    for userdata in all_users.values():\n        name = userdata[\"name\"]\n        users[name] = {\"perms\": get_permission(userdata[\"permission\"])}\n        users[name][\"perms\"][\"admin\"] = userdata[\"role\"] == 0\n\n    admin_menu = {\n        \"permlist\": permlist(),\n        \"users\": users\n    }\n\n    context = {\n        \"conf\": {\"plugin\": plugin_menu, \"general\": conf_menu, \"accs\": accs, \"admin\": admin_menu},\n        \"types\": api.get_account_types(),\n    }\n    return render_template(\"settings.html\", **context)\n\n\n@bp.route(\"/pathchooser/\", endpoint=\"pathchooser\")\n@bp.route(\"/filechooser/\", endpoint=\"filechooser\")\n@login_required(\"STATUS\")\ndef pathchooser():\n    browse_for = \"folder\" if flask.request.endpoint == \"app.pathchooser\" else \"file\"\n    path = os.path.normpath(flask.request.args.get('path', \"\"))\n\n    if os.path.isfile(path):\n        oldfile = path\n        path = os.path.dirname(path)\n    else:\n        oldfile = \"\"\n\n    abs = False\n\n    if os.path.isdir(path):\n        if os.path.isabs(path):\n            cwd = os.path.realpath(path)\n            abs = True\n        else:\n            cwd = os.path.relpath(path)\n    else:\n        cwd = os.getcwd()\n\n    cwd = os.path.normpath(os.path.realpath(cwd))\n    parentdir = os.path.dirname(cwd)\n    if not abs:\n        if os.path.realpath(cwd) == os.path.realpath(\"/\"):\n            cwd = os.path.relpath(cwd)\n        else:\n            cwd = os.path.relpath(cwd) + os.path.sep\n        parentdir = os.path.relpath(parentdir) + os.path.sep\n\n    if os.path.realpath(cwd) == os.path.realpath(\"/\"):\n        parentdir = \"\"\n\n    try:\n        folders = os.listdir(cwd)\n    except Exception:\n        folders = []\n\n    files = []\n\n    for f in folders:\n        try:\n            data = {\"name\": f, \"fullpath\": os.path.join(cwd, f)}\n            data[\"sort\"] = data[\"fullpath\"].lower()\n            data[\"modified\"] = datetime.datetime.fromtimestamp(\n                int(os.path.getmtime(os.path.join(cwd, f)))\n            )\n            data[\"ext\"] = os.path.splitext(f)[1]\n        except Exception:\n            continue\n\n        if os.path.isfile(os.path.join(cwd, f)):\n            data[\"type\"] = \"file\"\n            data[\"size\"] = os.path.getsize(os.path.join(cwd, f))\n\n            power = 0\n            while (data[\"size\"] >> 10) > 0.3:\n                power += 1\n                data[\"size\"] >>= 10\n            units = (\"\", \"K\", \"M\", \"G\", \"T\")\n            data[\"unit\"] = units[power] + \"Byte\"\n        else:\n            data[\"type\"] = \"dir\"\n            data[\"size\"] = \"\"\n\n        files.append(data)\n\n    files = sorted(files, key=operator.itemgetter(\"type\", \"sort\"))\n\n    context = {\n        \"cwd\": cwd,\n        \"files\": files,\n        \"parentdir\": parentdir,\n        \"type\": browse_for,\n        \"oldfile\": oldfile,\n        \"absolute\": abs,\n    }\n    return render_template(\"pathchooser.html\", **context)\n\n\n@bp.route(\"/logs\", methods=[\"GET\", \"POST\"], endpoint=\"logs\")\n@bp.route(\"/logs/<int:start_line>\", methods=[\"GET\", \"POST\"], endpoint=\"logs\")\n@login_required(\"LOGS\")\ndef logs(start_line=-1):\n    s = flask.session\n    api = flask.current_app.config[\"PYLOAD_API\"]\n\n    per_page = s.get(\"perpage\", 34)\n    reversed = s.get(\"reversed\", False)\n\n    warning = \"\"\n    conf = api.get_config_value(\"log\", \"filelog\")\n    if not conf:\n        warning = \"Warning: File log is disabled, see settings page.\"\n\n    per_page_selection = ((20, 20), (34, 34), (40, 40), (100, 100), (0, \"all\"))\n    fro = None\n\n    if flask.request.method == \"POST\":\n        try:\n            from_form = flask.request.form[\"from\"]\n            fro = datetime.datetime.strptime(from_form, \"%Y-%m-%d %H:%M:%S\")\n        except Exception:\n            pass\n\n        per_page = int(flask.request.form.get(\"perpage\", 34))\n        s[\"perpage\"] = per_page\n\n        reversed = bool(flask.request.form.get(\"reversed\", False))\n        s[\"reversed\"] = reversed\n\n        # s.modified = True\n\n    log_entries = api.get_log()\n    if not per_page:\n        start_line = 0\n\n    if start_line < 1:\n        start_line = (\n            1 if len(log_entries) - per_page + 1 < 1 or per_page == 0 else len(log_entries) - per_page + 1\n        )\n\n    if isinstance(fro, datetime.datetime):  #: we will search for datetime.datetime\n        start_line = -1\n\n    data = []\n    inpage_counter = 0\n    for counter, logline in enumerate(log_entries, start=1):\n        if counter >= start_line:\n            try:\n                date, time, level, source, message = _RE_LOGLINE.match(logline).groups()\n                dtime = datetime.datetime.strptime(\n                    date + \" \" + time, \"%Y-%m-%d %H:%M:%S\"\n                )\n                message = message.strip()\n            except (AttributeError, IndexError):\n                dtime = None\n                date = \"?\"\n                time = \" \"\n                level = \"?\"\n                source = \"?\"\n                message = logline\n            if start_line == -1 and dtime is not None and fro <= dtime:\n                start_line = counter  #: found our datetime.datetime\n\n            if start_line >= 0:\n                data.append(\n                    {\n                        \"line\": counter,\n                        \"date\": date + \" \" + time,\n                        \"level\": level,\n                        \"source\": source,\n                        \"message\": message.rstrip('\\n'),\n                    }\n                )\n                inpage_counter += 1\n                if (\n                    fro is None and dtime is not None\n                ):  #: if fro not set, set it to first showed line\n                    fro = dtime\n            if inpage_counter >= per_page > 0:\n                break\n\n    if fro is None:  #: still not set, empty log?\n        fro = datetime.datetime.now()\n\n    if reversed:\n        data.reverse()\n\n    context = {\n        \"warning\": warning,\n        \"log\": data,\n        \"from\": fro.strftime(\"%Y-%m-%d %H:%M:%S\"),\n        \"reversed\": reversed,\n        \"perpage\": per_page,\n        \"perpage_p\": sorted(per_page_selection),\n        \"iprev\": max(start_line - per_page, 1),\n        \"inext\": (start_line + per_page) if start_line + per_page <= len(log_entries) else start_line,\n    }\n    return render_template(\"logs.html\", **context)\n\n\n@bp.route(\"/filemanager\", endpoint=\"filemanager\")\n@login_required(\"MODIFY\")\ndef filemanager(path):\n    return render_template(\"filemanager.html\")\n\n\n@bp.route(\"/info\", endpoint=\"info\")\n@login_required(\"STATUS\")\ndef info():\n    api = flask.current_app.config[\"PYLOAD_API\"]\n    conf = api.get_config_dict()\n    extra = os.uname() if hasattr(os, \"uname\") else tuple()\n\n    context = {\n        \"python\": sys.version,\n        \"os\": \" \".join((os.name, sys.platform) + extra),\n        \"version\": api.get_server_version(),\n        \"folder\": PKGDIR,\n        \"config_folder\": api.get_userdir(),\n        \"download\": conf[\"general\"][\"storage_folder\"][\"value\"],\n        \"freespace\": format.size(api.free_space()),\n        \"webif\": conf[\"webui\"][\"port\"][\"value\"],\n        \"language\": conf[\"general\"][\"language\"][\"value\"],\n    }\n    return render_template(\"info.html\", **context)\n"], "filenames": ["src/pyload/webui/app/blueprints/api_blueprint.py", "src/pyload/webui/app/blueprints/app_blueprint.py"], "buggy_code_start_loc": [88, 56], "buggy_code_end_loc": [95, 63], "fixing_code_start_loc": [89, 57], "fixing_code_end_loc": [96, 64], "type": "CWE-74", "message": "pyLoad is the free and open-source Download Manager written in pure Python. A log injection vulnerability was identified in `pyload` allowing any unauthenticated actor to inject arbitrary messages into the logs gathered by `pyload`. Forged or otherwise, corrupted log files can be used to cover an attacker\u2019s tracks or even to implicate another party in the commission of a malicious act. This vulnerability has been patched in version 0.5.0b3.dev77.\n", "other": {"cve": {"id": "CVE-2024-21645", "sourceIdentifier": "security-advisories@github.com", "published": "2024-01-08T14:15:47.420", "lastModified": "2024-01-11T17:32:30.503", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "pyLoad is the free and open-source Download Manager written in pure Python. A log injection vulnerability was identified in `pyload` allowing any unauthenticated actor to inject arbitrary messages into the logs gathered by `pyload`. Forged or otherwise, corrupted log files can be used to cover an attacker\u2019s tracks or even to implicate another party in the commission of a malicious act. This vulnerability has been patched in version 0.5.0b3.dev77.\n"}, {"lang": "es", "value": "pyLoad es el administrador de descargas gratuito y de c\u00f3digo abierto escrito en Python puro. Se identific\u00f3 una vulnerabilidad de inyecci\u00f3n de registros en \"pyload\" que permite a cualquier actor no autenticado inyectar mensajes arbitrarios en los registros recopilados por \"pyload\". Los archivos de registro corruptos, falsificados o no, se pueden utilizar para cubrir las huellas de un atacante o incluso para implicar a otra parte en la comisi\u00f3n de un acto malicioso. Esta vulnerabilidad ha sido parcheada en la versi\u00f3n 0.5.0b3.dev77."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-74"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pyload:pyload:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.4.9", "matchCriteriaId": "71C7D7BA-743B-4C43-B77C-E6C1A6ACFE7E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pyload:pyload:0.5.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "3040B5C9-171B-40D9-83CB-CD529DC046ED"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pyload:pyload:0.5.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "78FA70FC-0CFE-4E89-9274-1670E1204B61"}]}]}], "references": [{"url": "https://github.com/pyload/pyload/commit/4159a1191ec4fe6d927e57a9c4bb8f54e16c381d", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/pyload/pyload/security/advisories/GHSA-ghmw-rwh8-6qmr", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/pyload/pyload/commit/4159a1191ec4fe6d927e57a9c4bb8f54e16c381d"}}