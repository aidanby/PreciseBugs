{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                        JJJJJ  PPPP   EEEEE   GGGG                           %\n%                          J    P   P  E      G                               %\n%                          J    PPPP   EEE    G  GG                           %\n%                        J J    P      E      G   G                           %\n%                        JJJ    P      EEEEE   GGG                            %\n%                                                                             %\n%                                                                             %\n%                       Read/Write JPEG Image Format                          %\n%                                                                             %\n%                              Software Design                                %\n%                                John Cristy                                  %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2013 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://www.imagemagick.org/script/license.php                           %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n% This software is based in part on the work of the Independent JPEG Group.\n% See ftp://ftp.uu.net/graphics/jpeg/jpegsrc.v6b.tar.gz for copyright and\n% licensing restrictions.  Blob support contributed by Glenn Randers-Pehrson.\n%\n%\n*/\n\n\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/colormap-private.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/option-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/splay-tree.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/xml-tree.h\"\n#include \"MagickCore/xml-tree-private.h\"\n#include <setjmp.h>\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n#define JPEG_INTERNAL_OPTIONS\n#if defined(__MINGW32__) || defined(__MINGW64__)\n# define XMD_H 1  /* Avoid conflicting typedef for INT32 */\n#endif\n#undef HAVE_STDLIB_H\n#include \"jpeglib.h\"\n#include \"jerror.h\"\n#endif\n\f\n/*\n  Define declarations.\n*/\n#define ICC_MARKER  (JPEG_APP0+2)\n#define ICC_PROFILE  \"ICC_PROFILE\"\n#define IPTC_MARKER  (JPEG_APP0+13)\n#define XML_MARKER  (JPEG_APP0+1)\n#define MaxBufferExtent  16384\n\f\n/*\n  Typedef declarations.\n*/\n#if defined(MAGICKCORE_JPEG_DELEGATE)\ntypedef struct _DestinationManager\n{\n  struct jpeg_destination_mgr\n    manager;\n\n  Image\n    *image;\n\n  JOCTET\n    *buffer;\n} DestinationManager;\n\ntypedef struct _ErrorManager\n{\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    finished;\n\n  StringInfo\n    *profile;\n\n  jmp_buf\n    error_recovery;\n} ErrorManager;\n\ntypedef struct _SourceManager\n{\n  struct jpeg_source_mgr\n    manager;\n\n  Image\n    *image;\n\n  JOCTET\n    *buffer;\n\n  boolean\n    start_of_blob;\n} SourceManager;\n#endif\n\ntypedef struct _QuantizationTable\n{\n  char\n    *slot,\n    *description;\n\n  size_t\n    width,\n    height;\n\n  double\n    divisor;\n\n  unsigned int\n    *levels;\n} QuantizationTable;\n\f\n/*\n  Forward declarations.\n*/\n#if defined(MAGICKCORE_JPEG_DELEGATE)\nstatic MagickBooleanType\n  WriteJPEGImage(const ImageInfo *,Image *,ExceptionInfo *);\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s J P E G                                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsJPEG() returns MagickTrue if the image format type, identified by the\n%  magick string, is JPEG.\n%\n%  The format of the IsJPEG  method is:\n%\n%      MagickBooleanType IsJPEG(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsJPEG(const unsigned char *magick,const size_t length)\n{\n  if (length < 3)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\377\\330\\377\",3) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d J P E G I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadJPEGImage() reads a JPEG image file and returns it.  It allocates\n%  the memory necessary for the new Image structure and returns a pointer to\n%  the new image.\n%\n%  The format of the ReadJPEGImage method is:\n%\n%      Image *ReadJPEGImage(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic boolean FillInputBuffer(j_decompress_ptr cinfo)\n{\n  SourceManager\n    *source;\n\n  source=(SourceManager *) cinfo->src;\n  source->manager.bytes_in_buffer=(size_t) ReadBlob(source->image,\n    MaxBufferExtent,source->buffer);\n  if (source->manager.bytes_in_buffer == 0)\n    {\n      if (source->start_of_blob != FALSE)\n        ERREXIT(cinfo,JERR_INPUT_EMPTY);\n      WARNMS(cinfo,JWRN_JPEG_EOF);\n      source->buffer[0]=(JOCTET) 0xff;\n      source->buffer[1]=(JOCTET) JPEG_EOI;\n      source->manager.bytes_in_buffer=2;\n    }\n  source->manager.next_input_byte=source->buffer;\n  source->start_of_blob=FALSE;\n  return(TRUE);\n}\n\nstatic int GetCharacter(j_decompress_ptr jpeg_info)\n{\n  if (jpeg_info->src->bytes_in_buffer == 0)\n    (void) (*jpeg_info->src->fill_input_buffer)(jpeg_info);\n  jpeg_info->src->bytes_in_buffer--;\n  return((int) GETJOCTET(*jpeg_info->src->next_input_byte++));\n}\n\nstatic void InitializeSource(j_decompress_ptr cinfo)\n{\n  SourceManager\n    *source;\n\n  source=(SourceManager *) cinfo->src;\n  source->start_of_blob=TRUE;\n}\n\nstatic MagickBooleanType IsITUFaxImage(const Image *image)\n{\n  const StringInfo\n    *profile;\n\n  const unsigned char\n    *datum;\n\n  profile=GetImageProfile(image,\"8bim\");\n  if (profile == (const StringInfo *) NULL)\n    return(MagickFalse);\n  if (GetStringInfoLength(profile) < 5)\n    return(MagickFalse);\n  datum=GetStringInfoDatum(profile);\n  if ((datum[0] == 0x47) && (datum[1] == 0x33) && (datum[2] == 0x46) &&\n      (datum[3] == 0x41) && (datum[4] == 0x58))\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\nstatic void JPEGErrorHandler(j_common_ptr jpeg_info)\n{\n  char\n    message[JMSG_LENGTH_MAX];\n\n  ErrorManager\n    *error_manager;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  *message='\\0';\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  image=error_manager->image;\n  exception=error_manager->exception;\n  (jpeg_info->err->format_message)(jpeg_info,message);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"[%s] JPEG Trace: \\\"%s\\\"\",image->filename,message);\n  if (error_manager->finished != MagickFalse)\n    (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageWarning,\n      (char *) message,\"`%s'\",image->filename);\n  else\n    (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n      (char *) message,\"`%s'\",image->filename);\n  longjmp(error_manager->error_recovery,1);\n}\n\nstatic MagickBooleanType JPEGWarningHandler(j_common_ptr jpeg_info,int level)\n{\n#define JPEGExcessiveWarnings  1000\n\n  char\n    message[JMSG_LENGTH_MAX];\n\n  ErrorManager\n    *error_manager;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  *message='\\0';\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  exception=error_manager->exception;\n  image=error_manager->image;\n  if (level < 0)\n    {\n      /*\n        Process warning message.\n      */\n      (jpeg_info->err->format_message)(jpeg_info,message);\n      if (jpeg_info->err->num_warnings++ < JPEGExcessiveWarnings)\n        ThrowBinaryException(CorruptImageWarning,(char *) message,\n          image->filename);\n    }\n  else\n    if ((image->debug != MagickFalse) &&\n        (level >= jpeg_info->err->trace_level))\n      {\n        /*\n          Process trace message.\n        */\n        (jpeg_info->err->format_message)(jpeg_info,message);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"[%s] JPEG Trace: \\\"%s\\\"\",image->filename,message);\n      }\n  return(MagickTrue);\n}\n\nstatic boolean ReadComment(j_decompress_ptr jpeg_info)\n{\n  ErrorManager\n    *error_manager;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  register unsigned char\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    length;\n\n  StringInfo\n    *comment;\n\n  /*\n    Determine length of comment.\n  */\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  exception=error_manager->exception;\n  image=error_manager->image;\n  length=(size_t) ((size_t) GetCharacter(jpeg_info) << 8);\n  length+=GetCharacter(jpeg_info);\n  if (length <= 2)\n    return(TRUE);\n  length-=2;\n  comment=BlobToStringInfo((const void *) NULL,length);\n  if (comment == (StringInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(FALSE);\n    }\n  /*\n    Read comment.\n  */\n  error_manager->profile=comment;\n  p=GetStringInfoDatum(comment);\n  for (i=0; i < (ssize_t) GetStringInfoLength(comment); i++)\n    *p++=(unsigned char) GetCharacter(jpeg_info);\n  *p='\\0';\n  error_manager->profile=NULL;\n  p=GetStringInfoDatum(comment);\n  (void) SetImageProperty(image,\"comment\",(const char *) p,exception);\n  comment=DestroyStringInfo(comment);\n  return(TRUE);\n}\n\nstatic boolean ReadICCProfile(j_decompress_ptr jpeg_info)\n{\n  char\n    magick[12];\n\n  ErrorManager\n    *error_manager;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    length;\n\n  StringInfo\n    *icc_profile,\n    *profile;\n\n  /*\n    Read color profile.\n  */\n  length=(size_t) ((size_t) GetCharacter(jpeg_info) << 8);\n  length+=(size_t) GetCharacter(jpeg_info);\n  length-=2;\n  if (length <= 14)\n    {\n      while (length-- > 0)\n        (void) GetCharacter(jpeg_info);\n      return(TRUE);\n    }\n  for (i=0; i < 12; i++)\n    magick[i]=(char) GetCharacter(jpeg_info);\n  if (LocaleCompare(magick,ICC_PROFILE) != 0)\n    {\n      /*\n        Not a ICC profile, return.\n      */\n      for (i=0; i < (ssize_t) (length-12); i++)\n        (void) GetCharacter(jpeg_info);\n      return(TRUE);\n    }\n  (void) GetCharacter(jpeg_info);  /* id */\n  (void) GetCharacter(jpeg_info);  /* markers */\n  length-=14;\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  exception=error_manager->exception;\n  image=error_manager->image;\n  profile=BlobToStringInfo((const void *) NULL,length);\n  if (profile == (StringInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(FALSE);\n    }\n  error_manager->profile=profile;\n  p=GetStringInfoDatum(profile);\n  for (i=(ssize_t) GetStringInfoLength(profile)-1; i >= 0; i--)\n    *p++=(unsigned char) GetCharacter(jpeg_info);\n  error_manager->profile=NULL;\n  icc_profile=(StringInfo *) GetImageProfile(image,\"icc\");\n  if (icc_profile != (StringInfo *) NULL)\n    {\n      ConcatenateStringInfo(icc_profile,profile);\n      profile=DestroyStringInfo(profile);\n    }\n  else\n    {\n      status=SetImageProfile(image,\"icc\",profile,exception);\n      profile=DestroyStringInfo(profile);\n      if (status == MagickFalse)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n          return(FALSE);\n        }\n    }\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"Profile: ICC, %.20g bytes\",(double) length);\n  return(TRUE);\n}\n\nstatic boolean ReadIPTCProfile(j_decompress_ptr jpeg_info)\n{\n  char\n    magick[MagickPathExtent];\n\n  ErrorManager\n    *error_manager;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    length;\n\n  StringInfo\n    *iptc_profile,\n    *profile;\n\n  /*\n    Determine length of binary data stored here.\n  */\n  length=(size_t) ((size_t) GetCharacter(jpeg_info) << 8);\n  length+=(size_t) GetCharacter(jpeg_info);\n  length-=2;\n  if (length <= 14)\n    {\n      while (length-- > 0)\n        (void) GetCharacter(jpeg_info);\n      return(TRUE);\n    }\n  /*\n    Validate that this was written as a Photoshop resource format slug.\n  */\n  for (i=0; i < 10; i++)\n    magick[i]=(char) GetCharacter(jpeg_info);\n  magick[10]='\\0';\n  length-=10;\n  if (length <= 10)\n    return(TRUE);\n  if (LocaleCompare(magick,\"Photoshop \") != 0)\n    {\n      /*\n        Not a IPTC profile, return.\n      */\n      for (i=0; i < (ssize_t) length; i++)\n        (void) GetCharacter(jpeg_info);\n      return(TRUE);\n    }\n  /*\n    Remove the version number.\n  */\n  for (i=0; i < 4; i++)\n    (void) GetCharacter(jpeg_info);\n  if (length <= 11)\n    return(TRUE);\n  length-=4;\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  exception=error_manager->exception;\n  image=error_manager->image;\n  profile=BlobToStringInfo((const void *) NULL,length);\n  if (profile == (StringInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(FALSE);\n    }\n  error_manager->profile=profile;\n  p=GetStringInfoDatum(profile);\n  for (i=0;  i < (ssize_t) GetStringInfoLength(profile); i++)\n    *p++=(unsigned char) GetCharacter(jpeg_info);\n  error_manager->profile=NULL;\n  iptc_profile=(StringInfo *) GetImageProfile(image,\"8bim\");\n  if (iptc_profile != (StringInfo *) NULL)\n    {\n      ConcatenateStringInfo(iptc_profile,profile);\n      profile=DestroyStringInfo(profile);\n    }\n  else\n    {\n      status=SetImageProfile(image,\"8bim\",profile,exception);\n      profile=DestroyStringInfo(profile);\n      if (status == MagickFalse)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n          return(FALSE);\n        }\n    }\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"Profile: iptc, %.20g bytes\",(double) length);\n  return(TRUE);\n}\n\nstatic boolean ReadProfile(j_decompress_ptr jpeg_info)\n{\n  char\n    name[MagickPathExtent];\n\n  const StringInfo\n    *previous_profile;\n\n  ErrorManager\n    *error_manager;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  int\n    marker;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    length;\n\n  StringInfo\n    *profile;\n\n  /*\n    Read generic profile.\n  */\n  length=(size_t) ((size_t) GetCharacter(jpeg_info) << 8);\n  length+=(size_t) GetCharacter(jpeg_info);\n  if (length <= 2)\n    return(TRUE);\n  length-=2;\n  marker=jpeg_info->unread_marker-JPEG_APP0;\n  (void) FormatLocaleString(name,MagickPathExtent,\"APP%d\",marker);\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  exception=error_manager->exception;\n  image=error_manager->image;\n  profile=BlobToStringInfo((const void *) NULL,length);\n  if (profile == (StringInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(FALSE);\n    }\n  error_manager->profile=profile;\n  p=GetStringInfoDatum(profile);\n  for (i=0; i < (ssize_t) GetStringInfoLength(profile); i++)\n    *p++=(unsigned char) GetCharacter(jpeg_info);\n  error_manager->profile=NULL;\n  if (marker == 1)\n    {\n      p=GetStringInfoDatum(profile);\n      if ((length > 4) && (LocaleNCompare((char *) p,\"exif\",4) == 0))\n        (void) CopyMagickString(name,\"exif\",MagickPathExtent);\n      if ((length > 5) && (LocaleNCompare((char *) p,\"http:\",5) == 0))\n        {\n          ssize_t\n            j;\n\n          /*\n            Extract namespace from XMP profile.\n          */\n          p=GetStringInfoDatum(profile);\n          for (j=0; j < (ssize_t) GetStringInfoLength(profile); j++)\n          {\n            if (*p == '\\0')\n              break;\n            p++;\n          }\n          if (j < (ssize_t) GetStringInfoLength(profile))\n            (void) DestroyStringInfo(SplitStringInfo(profile,(size_t) (j+1)));\n          (void) CopyMagickString(name,\"xmp\",MagickPathExtent);\n        }\n    }\n  previous_profile=GetImageProfile(image,name);\n  if (previous_profile != (const StringInfo *) NULL)\n    {\n      size_t\n        profile_length;\n\n      profile_length=GetStringInfoLength(profile);\n      SetStringInfoLength(profile,GetStringInfoLength(profile)+\n        GetStringInfoLength(previous_profile));\n      (void) memmove(GetStringInfoDatum(profile)+\n        GetStringInfoLength(previous_profile),GetStringInfoDatum(profile),\n        profile_length);\n      (void) memcpy(GetStringInfoDatum(profile),\n        GetStringInfoDatum(previous_profile),\n        GetStringInfoLength(previous_profile));\n    }\n  status=SetImageProfile(image,name,profile,exception);\n  profile=DestroyStringInfo(profile);\n  if (status == MagickFalse)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(FALSE);\n    }\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"Profile: %s, %.20g bytes\",name,(double) length);\n  return(TRUE);\n}\n\nstatic void SkipInputData(j_decompress_ptr cinfo,long number_bytes)\n{\n  SourceManager\n    *source;\n\n  if (number_bytes <= 0)\n    return;\n  source=(SourceManager *) cinfo->src;\n  while (number_bytes > (long) source->manager.bytes_in_buffer)\n  {\n    number_bytes-=(long) source->manager.bytes_in_buffer;\n    (void) FillInputBuffer(cinfo);\n  }\n  source->manager.next_input_byte+=number_bytes;\n  source->manager.bytes_in_buffer-=number_bytes;\n}\n\nstatic void TerminateSource(j_decompress_ptr cinfo)\n{\n  (void) cinfo;\n}\n\nstatic void JPEGSourceManager(j_decompress_ptr cinfo,Image *image)\n{\n  SourceManager\n    *source;\n\n  cinfo->src=(struct jpeg_source_mgr *) (*cinfo->mem->alloc_small)\n    ((j_common_ptr) cinfo,JPOOL_IMAGE,sizeof(SourceManager));\n  source=(SourceManager *) cinfo->src;\n  source->buffer=(JOCTET *) (*cinfo->mem->alloc_small)\n    ((j_common_ptr) cinfo,JPOOL_IMAGE,MaxBufferExtent*sizeof(JOCTET));\n  source=(SourceManager *) cinfo->src;\n  source->manager.init_source=InitializeSource;\n  source->manager.fill_input_buffer=FillInputBuffer;\n  source->manager.skip_input_data=SkipInputData;\n  source->manager.resync_to_restart=jpeg_resync_to_restart;\n  source->manager.term_source=TerminateSource;\n  source->manager.bytes_in_buffer=0;\n  source->manager.next_input_byte=NULL;\n  source->image=image;\n}\n\nstatic void JPEGSetImageQuality(struct jpeg_decompress_struct *jpeg_info,\n  Image *image)\n{\n  image->quality=UndefinedCompressionQuality;\n#if defined(D_PROGRESSIVE_SUPPORTED)\n  if (image->compression == LosslessJPEGCompression)\n    {\n      image->quality=100;\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"Quality: 100 (lossless)\");\n    }\n  else\n#endif\n  {\n    ssize_t\n      j,\n      qvalue,\n      sum;\n\n    register ssize_t\n      i;\n\n    /*\n      Determine the JPEG compression quality from the quantization tables.\n    */\n    sum=0;\n    for (i=0; i < NUM_QUANT_TBLS; i++)\n    {\n      if (jpeg_info->quant_tbl_ptrs[i] != NULL)\n        for (j=0; j < DCTSIZE2; j++)\n          sum+=jpeg_info->quant_tbl_ptrs[i]->quantval[j];\n    }\n    if ((jpeg_info->quant_tbl_ptrs[0] != NULL) &&\n        (jpeg_info->quant_tbl_ptrs[1] != NULL))\n      {\n        ssize_t\n          hash[101] =\n          {\n            1020, 1015,  932,  848,  780,  735,  702,  679,  660,  645,\n             632,  623,  613,  607,  600,  594,  589,  585,  581,  571,\n             555,  542,  529,  514,  494,  474,  457,  439,  424,  410,\n             397,  386,  373,  364,  351,  341,  334,  324,  317,  309,\n             299,  294,  287,  279,  274,  267,  262,  257,  251,  247,\n             243,  237,  232,  227,  222,  217,  213,  207,  202,  198,\n             192,  188,  183,  177,  173,  168,  163,  157,  153,  148,\n             143,  139,  132,  128,  125,  119,  115,  108,  104,   99,\n              94,   90,   84,   79,   74,   70,   64,   59,   55,   49,\n              45,   40,   34,   30,   25,   20,   15,   11,    6,    4,\n               0\n          },\n          sums[101] =\n          {\n            32640, 32635, 32266, 31495, 30665, 29804, 29146, 28599, 28104,\n            27670, 27225, 26725, 26210, 25716, 25240, 24789, 24373, 23946,\n            23572, 22846, 21801, 20842, 19949, 19121, 18386, 17651, 16998,\n            16349, 15800, 15247, 14783, 14321, 13859, 13535, 13081, 12702,\n            12423, 12056, 11779, 11513, 11135, 10955, 10676, 10392, 10208,\n             9928,  9747,  9564,  9369,  9193,  9017,  8822,  8639,  8458,\n             8270,  8084,  7896,  7710,  7527,  7347,  7156,  6977,  6788,\n             6607,  6422,  6236,  6054,  5867,  5684,  5495,  5305,  5128,\n             4945,  4751,  4638,  4442,  4248,  4065,  3888,  3698,  3509,\n             3326,  3139,  2957,  2775,  2586,  2405,  2216,  2037,  1846,\n             1666,  1483,  1297,  1109,   927,   735,   554,   375,   201,\n              128,     0\n          };\n\n        qvalue=(ssize_t) (jpeg_info->quant_tbl_ptrs[0]->quantval[2]+\n          jpeg_info->quant_tbl_ptrs[0]->quantval[53]+\n          jpeg_info->quant_tbl_ptrs[1]->quantval[0]+\n          jpeg_info->quant_tbl_ptrs[1]->quantval[DCTSIZE2-1]);\n        for (i=0; i < 100; i++)\n        {\n          if ((qvalue < hash[i]) && (sum < sums[i]))\n            continue;\n          if (((qvalue <= hash[i]) && (sum <= sums[i])) || (i >= 50))\n            image->quality=(size_t) i+1;\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"Quality: %.20g (%s)\",(double) i+1,(qvalue <= hash[i]) &&\n              (sum <= sums[i]) ? \"exact\" : \"approximate\");\n          break;\n        }\n      }\n    else\n      if (jpeg_info->quant_tbl_ptrs[0] != NULL)\n        {\n          ssize_t\n            hash[101] =\n            {\n              510,  505,  422,  380,  355,  338,  326,  318,  311,  305,\n              300,  297,  293,  291,  288,  286,  284,  283,  281,  280,\n              279,  278,  277,  273,  262,  251,  243,  233,  225,  218,\n              211,  205,  198,  193,  186,  181,  177,  172,  168,  164,\n              158,  156,  152,  148,  145,  142,  139,  136,  133,  131,\n              129,  126,  123,  120,  118,  115,  113,  110,  107,  105,\n              102,  100,   97,   94,   92,   89,   87,   83,   81,   79,\n               76,   74,   70,   68,   66,   63,   61,   57,   55,   52,\n               50,   48,   44,   42,   39,   37,   34,   31,   29,   26,\n               24,   21,   18,   16,   13,   11,    8,    6,    3,    2,\n                0\n            },\n            sums[101] =\n            {\n              16320, 16315, 15946, 15277, 14655, 14073, 13623, 13230, 12859,\n              12560, 12240, 11861, 11456, 11081, 10714, 10360, 10027,  9679,\n               9368,  9056,  8680,  8331,  7995,  7668,  7376,  7084,  6823,\n               6562,  6345,  6125,  5939,  5756,  5571,  5421,  5240,  5086,\n               4976,  4829,  4719,  4616,  4463,  4393,  4280,  4166,  4092,\n               3980,  3909,  3835,  3755,  3688,  3621,  3541,  3467,  3396,\n               3323,  3247,  3170,  3096,  3021,  2952,  2874,  2804,  2727,\n               2657,  2583,  2509,  2437,  2362,  2290,  2211,  2136,  2068,\n               1996,  1915,  1858,  1773,  1692,  1620,  1552,  1477,  1398,\n               1326,  1251,  1179,  1109,  1031,   961,   884,   814,   736,\n                667,   592,   518,   441,   369,   292,   221,   151,    86,\n                 64,     0\n            };\n\n          qvalue=(ssize_t) (jpeg_info->quant_tbl_ptrs[0]->quantval[2]+\n            jpeg_info->quant_tbl_ptrs[0]->quantval[53]);\n          for (i=0; i < 100; i++)\n          {\n            if ((qvalue < hash[i]) && (sum < sums[i]))\n              continue;\n            if (((qvalue <= hash[i]) && (sum <= sums[i])) || (i >= 50))\n              image->quality=(size_t)i+1;\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"Quality: %.20g (%s)\",(double) i+1,(qvalue <= hash[i]) &&\n                (sum <= sums[i]) ? \"exact\" : \"approximate\");\n            break;\n          }\n        }\n  }\n}\n\nstatic void JPEGSetImageSamplingFactor(struct jpeg_decompress_struct *jpeg_info,  Image *image,ExceptionInfo *exception)\n{\n  char\n    sampling_factor[MagickPathExtent];\n\n  switch (jpeg_info->out_color_space)\n  {\n    case JCS_CMYK:\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Colorspace: CMYK\");\n      (void) FormatLocaleString(sampling_factor,MagickPathExtent,\n        \"%dx%d,%dx%d,%dx%d,%dx%d\",jpeg_info->comp_info[0].h_samp_factor,\n        jpeg_info->comp_info[0].v_samp_factor,\n        jpeg_info->comp_info[1].h_samp_factor,\n        jpeg_info->comp_info[1].v_samp_factor,\n        jpeg_info->comp_info[2].h_samp_factor,\n        jpeg_info->comp_info[2].v_samp_factor,\n        jpeg_info->comp_info[3].h_samp_factor,\n        jpeg_info->comp_info[3].v_samp_factor);\n      break;\n    }\n    case JCS_GRAYSCALE:\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"Colorspace: GRAYSCALE\");\n      (void) FormatLocaleString(sampling_factor,MagickPathExtent,\"%dx%d\",\n        jpeg_info->comp_info[0].h_samp_factor,\n        jpeg_info->comp_info[0].v_samp_factor);\n      break;\n    }\n    case JCS_RGB:\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Colorspace: RGB\");\n      (void) FormatLocaleString(sampling_factor,MagickPathExtent,\n        \"%dx%d,%dx%d,%dx%d\",jpeg_info->comp_info[0].h_samp_factor,\n        jpeg_info->comp_info[0].v_samp_factor,\n        jpeg_info->comp_info[1].h_samp_factor,\n        jpeg_info->comp_info[1].v_samp_factor,\n        jpeg_info->comp_info[2].h_samp_factor,\n        jpeg_info->comp_info[2].v_samp_factor);\n      break;\n    }\n    default:\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Colorspace: %d\",\n        jpeg_info->out_color_space);\n      (void) FormatLocaleString(sampling_factor,MagickPathExtent,\n        \"%dx%d,%dx%d,%dx%d,%dx%d\",jpeg_info->comp_info[0].h_samp_factor,\n        jpeg_info->comp_info[0].v_samp_factor,\n        jpeg_info->comp_info[1].h_samp_factor,\n        jpeg_info->comp_info[1].v_samp_factor,\n        jpeg_info->comp_info[2].h_samp_factor,\n        jpeg_info->comp_info[2].v_samp_factor,\n        jpeg_info->comp_info[3].h_samp_factor,\n        jpeg_info->comp_info[3].v_samp_factor);\n      break;\n    }\n  }\n  (void) SetImageProperty(image,\"jpeg:sampling-factor\",sampling_factor,\n    exception);\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Sampling Factors: %s\",\n    sampling_factor);\n}\n\nstatic Image *ReadJPEGImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    value[MagickPathExtent];\n\n  const char\n    *option;\n\n  ErrorManager\n    error_manager;\n\n  Image\n    *image;\n\n  JSAMPLE\n    *volatile jpeg_pixels;\n\n  JSAMPROW\n    scanline[1];\n\n  MagickBooleanType\n    debug,\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  MemoryInfo\n    *memory_info;\n\n  Quantum\n    index;\n\n  register ssize_t\n    i;\n\n  struct jpeg_decompress_struct\n    jpeg_info;\n\n  struct jpeg_error_mgr\n    jpeg_error;\n\n  register JSAMPLE\n    *p;\n\n  size_t\n    units;\n\n  ssize_t\n    y;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  debug=IsEventLogging();\n  (void) debug;\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Verify that file size large enough to contain a JPEG datastream.\n  */\n  if (GetBlobSize(image) < 107)\n    ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n  /*\n    Initialize JPEG parameters.\n  */\n  (void) ResetMagickMemory(&error_manager,0,sizeof(error_manager));\n  (void) ResetMagickMemory(&jpeg_info,0,sizeof(jpeg_info));\n  (void) ResetMagickMemory(&jpeg_error,0,sizeof(jpeg_error));\n  jpeg_info.err=jpeg_std_error(&jpeg_error);\n  jpeg_info.err->emit_message=(void (*)(j_common_ptr,int)) JPEGWarningHandler;\n  jpeg_info.err->error_exit=(void (*)(j_common_ptr)) JPEGErrorHandler;\n  memory_info=(MemoryInfo *) NULL;\n  error_manager.exception=exception;\n  error_manager.image=image;\n  if (setjmp(error_manager.error_recovery) != 0)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      if (error_manager.profile != (StringInfo *) NULL)\n        error_manager.profile=DestroyStringInfo(error_manager.profile);\n      (void) CloseBlob(image);\n      number_pixels=(MagickSizeType) image->columns*image->rows;\n      if (number_pixels != 0)\n        return(GetFirstImageInList(image));\n      return(DestroyImage(image));\n    }\n  jpeg_info.client_data=(void *) &error_manager;\n  jpeg_create_decompress(&jpeg_info);\n  JPEGSourceManager(&jpeg_info,image);\n  jpeg_set_marker_processor(&jpeg_info,JPEG_COM,ReadComment);\n  option=GetImageOption(image_info,\"profile:skip\");\n  if (IsOptionMember(\"ICC\",option) == MagickFalse)\n    jpeg_set_marker_processor(&jpeg_info,ICC_MARKER,ReadICCProfile);\n  if (IsOptionMember(\"IPTC\",option) == MagickFalse)\n    jpeg_set_marker_processor(&jpeg_info,IPTC_MARKER,ReadIPTCProfile);\n  for (i=1; i < 16; i++)\n    if ((i != 2) && (i != 13) && (i != 14))\n      if (IsOptionMember(\"APP\",option) == MagickFalse)\n        jpeg_set_marker_processor(&jpeg_info,(int) (JPEG_APP0+i),ReadProfile);\n  i=(ssize_t) jpeg_read_header(&jpeg_info,TRUE);\n  if ((image_info->colorspace == YCbCrColorspace) ||\n      (image_info->colorspace == Rec601YCbCrColorspace) ||\n      (image_info->colorspace == Rec709YCbCrColorspace))\n    jpeg_info.out_color_space=JCS_YCbCr;\n  /*\n    Set image resolution.\n  */\n  units=0;\n  if ((jpeg_info.saw_JFIF_marker != 0) && (jpeg_info.X_density != 1) &&\n      (jpeg_info.Y_density != 1))\n    {\n      image->resolution.x=(double) jpeg_info.X_density;\n      image->resolution.y=(double) jpeg_info.Y_density;\n      units=(size_t) jpeg_info.density_unit;\n    }\n  if (units == 1)\n    image->units=PixelsPerInchResolution;\n  if (units == 2)\n    image->units=PixelsPerCentimeterResolution;\n  number_pixels=(MagickSizeType) image->columns*image->rows;\n  option=GetImageOption(image_info,\"jpeg:size\");\n  if ((option != (const char *) NULL) &&\n      (jpeg_info.out_color_space != JCS_YCbCr))\n    {\n      double\n        scale_factor;\n\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      /*\n        Scale the image.\n      */\n      flags=ParseGeometry(option,&geometry_info);\n      if ((flags & SigmaValue) == 0)\n        geometry_info.sigma=geometry_info.rho;\n      jpeg_calc_output_dimensions(&jpeg_info);\n      image->magick_columns=jpeg_info.output_width;\n      image->magick_rows=jpeg_info.output_height;\n      scale_factor=1.0;\n      if (geometry_info.rho != 0.0)\n        scale_factor=jpeg_info.output_width/geometry_info.rho;\n      if ((geometry_info.sigma != 0.0) &&\n          (scale_factor > (jpeg_info.output_height/geometry_info.sigma)))\n        scale_factor=jpeg_info.output_height/geometry_info.sigma;\n      jpeg_info.scale_num=1U;\n      jpeg_info.scale_denom=(unsigned int) scale_factor;\n      jpeg_calc_output_dimensions(&jpeg_info);\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Scale factor: %.20g\",(double) scale_factor);\n    }\n#if (JPEG_LIB_VERSION >= 61) && defined(D_PROGRESSIVE_SUPPORTED)\n#if defined(D_LOSSLESS_SUPPORTED)\n  image->interlace=jpeg_info.process == JPROC_PROGRESSIVE ?\n    JPEGInterlace : NoInterlace;\n  image->compression=jpeg_info.process == JPROC_LOSSLESS ?\n    LosslessJPEGCompression : JPEGCompression;\n  if (jpeg_info.data_precision > 8)\n    (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n      \"12-bit JPEG not supported. Reducing pixel data to 8 bits\",\"`%s'\",\n      image->filename);\n  if (jpeg_info.data_precision == 16)\n    jpeg_info.data_precision=12;\n#else\n  image->interlace=jpeg_info.progressive_mode != 0 ? JPEGInterlace :\n    NoInterlace;\n  image->compression=JPEGCompression;\n#endif\n#else\n  image->compression=JPEGCompression;\n  image->interlace=JPEGInterlace;\n#endif\n  option=GetImageOption(image_info,\"jpeg:colors\");\n  if (option != (const char *) NULL)\n    {\n      /*\n        Let the JPEG library quantize the image.\n      */\n      jpeg_info.quantize_colors=TRUE;\n      jpeg_info.desired_number_of_colors=(int) StringToUnsignedLong(option);\n    }\n  option=GetImageOption(image_info,\"jpeg:block-smoothing\");\n  if (option != (const char *) NULL)\n    jpeg_info.do_block_smoothing=IsStringTrue(option) != MagickFalse ? TRUE :\n      FALSE;\n  jpeg_info.dct_method=JDCT_FLOAT;\n  option=GetImageOption(image_info,\"jpeg:dct-method\");\n  if (option != (const char *) NULL)\n    switch (*option)\n    {\n      case 'D':\n      case 'd':\n      {\n        if (LocaleCompare(option,\"default\") == 0)\n          jpeg_info.dct_method=JDCT_DEFAULT;\n        break;\n      }\n      case 'F':\n      case 'f':\n      {\n        if (LocaleCompare(option,\"fastest\") == 0)\n          jpeg_info.dct_method=JDCT_FASTEST;\n        if (LocaleCompare(option,\"float\") == 0)\n          jpeg_info.dct_method=JDCT_FLOAT;\n        break;\n      }\n      case 'I':\n      case 'i':\n      {\n        if (LocaleCompare(option,\"ifast\") == 0)\n          jpeg_info.dct_method=JDCT_IFAST;\n        if (LocaleCompare(option,\"islow\") == 0)\n          jpeg_info.dct_method=JDCT_ISLOW;\n        break;\n      }\n    }\n  option=GetImageOption(image_info,\"jpeg:fancy-upsampling\");\n  if (option != (const char *) NULL)\n    jpeg_info.do_fancy_upsampling=IsStringTrue(option) != MagickFalse ? TRUE :\n      FALSE;\n  (void) jpeg_start_decompress(&jpeg_info);\n  image->columns=jpeg_info.output_width;\n  image->rows=jpeg_info.output_height;\n  image->depth=(size_t) jpeg_info.data_precision;\n  switch (jpeg_info.out_color_space)\n  {\n    case JCS_RGB:\n    default:\n    {\n      (void) SetImageColorspace(image,sRGBColorspace,exception);\n      break;\n    }\n    case JCS_GRAYSCALE:\n    {\n      (void) SetImageColorspace(image,GRAYColorspace,exception);\n      break;\n    }\n    case JCS_YCbCr:\n    {\n      (void) SetImageColorspace(image,YCbCrColorspace,exception);\n      break;\n    }\n    case JCS_CMYK:\n    {\n      (void) SetImageColorspace(image,CMYKColorspace,exception);\n      break;\n    }\n  }\n  if (IsITUFaxImage(image) != MagickFalse)\n    {\n      (void) SetImageColorspace(image,LabColorspace,exception);\n      jpeg_info.out_color_space=JCS_YCbCr;\n    }\n  option=GetImageOption(image_info,\"jpeg:colors\");\n  if (option != (const char *) NULL)\n    if (AcquireImageColormap(image,StringToUnsignedLong(option),exception)\n         == MagickFalse)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  if ((jpeg_info.output_components == 1) && (jpeg_info.quantize_colors == 0))\n    {\n      size_t\n        colors;\n\n      colors=(size_t) GetQuantumRange(image->depth)+1;\n      if (AcquireImageColormap(image,colors,exception) == MagickFalse)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  if (image->debug != MagickFalse)\n    {\n      if (image->interlace != NoInterlace)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Interlace: progressive\");\n      else\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Interlace: nonprogressive\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Data precision: %d\",\n        (int) jpeg_info.data_precision);\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Geometry: %dx%d\",\n        (int) jpeg_info.output_width,(int) jpeg_info.output_height);\n    }\n  JPEGSetImageQuality(&jpeg_info,image);\n  JPEGSetImageSamplingFactor(&jpeg_info,image,exception);\n  (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n    jpeg_info.out_color_space);\n  (void) SetImageProperty(image,\"jpeg:colorspace\",value,exception);\n  if (image_info->ping != MagickFalse)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      return(DestroyImageList(image));\n    }\n  if ((jpeg_info.output_components != 1) &&\n      (jpeg_info.output_components != 3) && (jpeg_info.output_components != 4))\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      ThrowReaderException(CorruptImageError,\"ImageTypeNotSupported\");\n    }\n  memory_info=AcquireVirtualMemory((size_t) image->columns,\n    jpeg_info.output_components*sizeof(*jpeg_pixels));\n  if (memory_info == (MemoryInfo *) NULL)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  jpeg_pixels=(JSAMPLE *) GetVirtualMemoryBlob(memory_info);\n  /*\n    Convert JPEG pixels to pixel packets.\n  */\n  if (setjmp(error_manager.error_recovery) != 0)\n    {\n      if (memory_info != (MemoryInfo *) NULL)\n        memory_info=RelinquishVirtualMemory(memory_info);\n      jpeg_destroy_decompress(&jpeg_info);\n      (void) CloseBlob(image);\n      number_pixels=(MagickSizeType) image->columns*image->rows;\n      if (number_pixels != 0)\n        return(GetFirstImageInList(image));\n      return(DestroyImage(image));\n    }\n  if (jpeg_info.quantize_colors != 0)\n    {\n      image->colors=(size_t) jpeg_info.actual_number_of_colors;\n      if (jpeg_info.out_color_space == JCS_GRAYSCALE)\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].red=(double) ScaleCharToQuantum(\n            jpeg_info.colormap[0][i]);\n          image->colormap[i].green=image->colormap[i].red;\n          image->colormap[i].blue=image->colormap[i].red;\n          image->colormap[i].alpha=(MagickRealType) OpaqueAlpha;\n        }\n      else\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].red=(double) ScaleCharToQuantum(\n            jpeg_info.colormap[0][i]);\n          image->colormap[i].green=(double) ScaleCharToQuantum(\n            jpeg_info.colormap[1][i]);\n          image->colormap[i].blue=(double) ScaleCharToQuantum(\n            jpeg_info.colormap[2][i]);\n          image->colormap[i].alpha=(MagickRealType) OpaqueAlpha;\n        }\n    }\n  scanline[0]=(JSAMPROW) jpeg_pixels;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register ssize_t\n      x;\n\n    register Quantum\n      *magick_restrict q;\n\n    if (jpeg_read_scanlines(&jpeg_info,scanline,1) != 1)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CorruptImageWarning,\"SkipToSyncByte\",\"`%s'\",image->filename);\n        continue;\n      }\n    p=jpeg_pixels;\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    if (jpeg_info.data_precision > 8)\n      {\n        unsigned short\n          scale;\n\n        scale=65535/(unsigned short) GetQuantumRange((size_t)\n          jpeg_info.data_precision);\n        if (jpeg_info.output_components == 1)\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            ssize_t\n              pixel;\n\n            pixel=(ssize_t) (scale*GETJSAMPLE(*p));\n            index=(Quantum) ConstrainColormapIndex(image,pixel,exception);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            p++;\n            q+=GetPixelChannels(image);\n          }\n        else\n          if (image->colorspace != CMYKColorspace)\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelRed(image,ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))),q);\n              SetPixelGreen(image,ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))),q);\n              SetPixelBlue(image,ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))),q);\n              SetPixelAlpha(image,OpaqueAlpha,q);\n              q+=GetPixelChannels(image);\n            }\n          else\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelCyan(image,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))),q);\n              SetPixelMagenta(image,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))),q);\n              SetPixelYellow(image,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))),q);\n              SetPixelBlack(image,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))),q);\n              SetPixelAlpha(image,OpaqueAlpha,q);\n              q+=GetPixelChannels(image);\n            }\n      }\n    else\n      if (jpeg_info.output_components == 1)\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          index=(Quantum) ConstrainColormapIndex(image,(ssize_t) GETJSAMPLE(*p),\n            exception);\n          SetPixelIndex(image,index,q);\n          SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n          p++;\n          q+=GetPixelChannels(image);\n        }\n      else\n        if (image->colorspace != CMYKColorspace)\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)),q);\n            SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)),q);\n            SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)),q);\n            SetPixelAlpha(image,OpaqueAlpha,q);\n            q+=GetPixelChannels(image);\n          }\n        else\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelCyan(image,QuantumRange-ScaleCharToQuantum(\n              (unsigned char) GETJSAMPLE(*p++)),q);\n            SetPixelMagenta(image,QuantumRange-ScaleCharToQuantum(\n              (unsigned char) GETJSAMPLE(*p++)),q);\n            SetPixelYellow(image,QuantumRange-ScaleCharToQuantum(\n              (unsigned char) GETJSAMPLE(*p++)),q);\n            SetPixelBlack(image,QuantumRange-ScaleCharToQuantum(\n              (unsigned char) GETJSAMPLE(*p++)),q);\n            SetPixelAlpha(image,OpaqueAlpha,q);\n            q+=GetPixelChannels(image);\n          }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      {\n        jpeg_abort_decompress(&jpeg_info);\n        break;\n      }\n  }\n  if (status != MagickFalse)\n    {\n      error_manager.finished=MagickTrue;\n      if (setjmp(error_manager.error_recovery) == 0)\n        (void) jpeg_finish_decompress(&jpeg_info);\n    }\n  /*\n    Free jpeg resources.\n  */\n  jpeg_destroy_decompress(&jpeg_info);\n  memory_info=RelinquishVirtualMemory(memory_info);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r J P E G I m a g e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterJPEGImage() adds properties for the JPEG image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterJPEGImage method is:\n%\n%      size_t RegisterJPEGImage(void)\n%\n*/\nModuleExport size_t RegisterJPEGImage(void)\n{\n#define JPEGDescription \"Joint Photographic Experts Group JFIF format\"\n\n  char\n    version[MagickPathExtent];\n\n  MagickInfo\n    *entry;\n\n  *version='\\0';\n#if defined(JPEG_LIB_VERSION)\n  (void) FormatLocaleString(version,MagickPathExtent,\"%d\",JPEG_LIB_VERSION);\n#endif\n  entry=AcquireMagickInfo(\"JPEG\",\"JPE\",JPEGDescription);\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->flags^=CoderDecoderThreadSupportFlag;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n#endif\n  entry->magick=(IsImageFormatHandler *) IsJPEG;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"JPEG\",\"JPEG\",JPEGDescription);\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->flags^=CoderDecoderThreadSupportFlag;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n#endif\n  entry->magick=(IsImageFormatHandler *) IsJPEG;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"JPEG\",\"JPG\",JPEGDescription);\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->flags^=CoderDecoderThreadSupportFlag;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n#endif\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"JPEG\",\"JPS\",JPEGDescription);\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->flags^=CoderDecoderThreadSupportFlag;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n#endif\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"JPEG\",\"PJPEG\",JPEGDescription);\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->flags^=CoderDecoderThreadSupportFlag;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n#endif\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r J P E G I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterJPEGImage() removes format registrations made by the\n%  JPEG module from the list of supported formats.\n%\n%  The format of the UnregisterJPEGImage method is:\n%\n%      UnregisterJPEGImage(void)\n%\n*/\nModuleExport void UnregisterJPEGImage(void)\n{\n  (void) UnregisterMagickInfo(\"PJPG\");\n  (void) UnregisterMagickInfo(\"JPS\");\n  (void) UnregisterMagickInfo(\"JPG\");\n  (void) UnregisterMagickInfo(\"JPEG\");\n  (void) UnregisterMagickInfo(\"JPE\");\n}\n\f\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  W r i t e J P E G I m a g e                                                %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteJPEGImage() writes a JPEG image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the WriteJPEGImage method is:\n%\n%      MagickBooleanType WriteJPEGImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o jpeg_image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic QuantizationTable *DestroyQuantizationTable(QuantizationTable *table)\n{\n  assert(table != (QuantizationTable *) NULL);\n  if (table->slot != (char *) NULL)\n    table->slot=DestroyString(table->slot);\n  if (table->description != (char *) NULL)\n    table->description=DestroyString(table->description);\n  if (table->levels != (unsigned int *) NULL)\n    table->levels=(unsigned int *) RelinquishMagickMemory(table->levels);\n  table=(QuantizationTable *) RelinquishMagickMemory(table);\n  return(table);\n}\n\nstatic boolean EmptyOutputBuffer(j_compress_ptr cinfo)\n{\n  DestinationManager\n    *destination;\n\n  destination=(DestinationManager *) cinfo->dest;\n  destination->manager.free_in_buffer=(size_t) WriteBlob(destination->image,\n    MaxBufferExtent,destination->buffer);\n  if (destination->manager.free_in_buffer != MaxBufferExtent)\n    ERREXIT(cinfo,JERR_FILE_WRITE);\n  destination->manager.next_output_byte=destination->buffer;\n  return(TRUE);\n}\n\nstatic QuantizationTable *GetQuantizationTable(const char *filename,\n  const char *slot,ExceptionInfo *exception)\n{\n  char\n    *p,\n    *xml;\n\n  const char\n    *attribute,\n    *content;\n\n  double\n    value;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    j;\n\n  QuantizationTable\n    *table;\n\n  size_t\n    length;\n\n  XMLTreeInfo\n    *description,\n    *levels,\n    *quantization_tables,\n    *table_iterator;\n\n  (void) LogMagickEvent(ConfigureEvent,GetMagickModule(),\n    \"Loading quantization tables \\\"%s\\\" ...\",filename);\n  table=(QuantizationTable *) NULL;\n  xml=FileToString(filename,~0UL,exception);\n  if (xml == (char *) NULL)\n    return(table);\n  quantization_tables=NewXMLTree(xml,exception);\n  if (quantization_tables == (XMLTreeInfo *) NULL)\n    {\n      xml=DestroyString(xml);\n      return(table);\n    }\n  for (table_iterator=GetXMLTreeChild(quantization_tables,\"table\");\n       table_iterator != (XMLTreeInfo *) NULL;\n       table_iterator=GetNextXMLTreeTag(table_iterator))\n  {\n    attribute=GetXMLTreeAttribute(table_iterator,\"slot\");\n    if ((attribute != (char *) NULL) && (LocaleCompare(slot,attribute) == 0))\n      break;\n    attribute=GetXMLTreeAttribute(table_iterator,\"alias\");\n    if ((attribute != (char *) NULL) && (LocaleCompare(slot,attribute) == 0))\n      break;\n  }\n  if (table_iterator == (XMLTreeInfo *) NULL)\n    {\n      xml=DestroyString(xml);\n      return(table);\n    }\n  description=GetXMLTreeChild(table_iterator,\"description\");\n  if (description == (XMLTreeInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingElement\",\"<description>, slot \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  levels=GetXMLTreeChild(table_iterator,\"levels\");\n  if (levels == (XMLTreeInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingElement\",\"<levels>, slot \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));\n  if (table == (QuantizationTable *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\n      \"UnableToAcquireQuantizationTable\");\n  table->slot=(char *) NULL;\n  table->description=(char *) NULL;\n  table->levels=(unsigned int *) NULL;\n  attribute=GetXMLTreeAttribute(table_iterator,\"slot\");\n  if (attribute != (char *) NULL)\n    table->slot=ConstantString(attribute);\n  content=GetXMLTreeContent(description);\n  if (content != (char *) NULL)\n    table->description=ConstantString(content);\n  attribute=GetXMLTreeAttribute(levels,\"width\");\n  if (attribute == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingAttribute\",\"<levels width>, slot \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  table->width=StringToUnsignedLong(attribute);\n  if (table->width == 0)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n       \"XmlInvalidAttribute\",\"<levels width>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  attribute=GetXMLTreeAttribute(levels,\"height\");\n  if (attribute == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingAttribute\",\"<levels height>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  table->height=StringToUnsignedLong(attribute);\n  if (table->height == 0)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlInvalidAttribute\",\"<levels height>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  attribute=GetXMLTreeAttribute(levels,\"divisor\");\n  if (attribute == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingAttribute\",\"<levels divisor>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  table->divisor=InterpretLocaleValue(attribute,(char **) NULL);\n  if (table->divisor == 0.0)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlInvalidAttribute\",\"<levels divisor>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  content=GetXMLTreeContent(levels);\n  if (content == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingContent\",\"<levels>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  length=(size_t) table->width*table->height;\n  if (length < 64)\n    length=64;\n  table->levels=(unsigned int *) AcquireQuantumMemory(length,\n    sizeof(*table->levels));\n  if (table->levels == (unsigned int *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\n      \"UnableToAcquireQuantizationTable\");\n  for (i=0; i < (ssize_t) (table->width*table->height); i++)\n  {\n    table->levels[i]=(unsigned int) (InterpretLocaleValue(content,&p)/\n      table->divisor+0.5);\n    while (isspace((int) ((unsigned char) *p)) != 0)\n      p++;\n    if (*p == ',')\n      p++;\n    content=p;\n  }\n  value=InterpretLocaleValue(content,&p);\n  (void) value;\n  if (p != content)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlInvalidContent\",\"<level> too many values, table \\\"%s\\\"\",slot);\n     quantization_tables=DestroyXMLTree(quantization_tables);\n     table=DestroyQuantizationTable(table);\n     xml=DestroyString(xml);\n     return(table);\n   }\n  for (j=i; j < 64; j++)\n    table->levels[j]=table->levels[j-1];\n  quantization_tables=DestroyXMLTree(quantization_tables);\n  xml=DestroyString(xml);\n  return(table);\n}\n\nstatic void InitializeDestination(j_compress_ptr cinfo)\n{\n  DestinationManager\n    *destination;\n\n  destination=(DestinationManager *) cinfo->dest;\n  destination->buffer=(JOCTET *) (*cinfo->mem->alloc_small)\n    ((j_common_ptr) cinfo,JPOOL_IMAGE,MaxBufferExtent*sizeof(JOCTET));\n  destination->manager.next_output_byte=destination->buffer;\n  destination->manager.free_in_buffer=MaxBufferExtent;\n}\n\nstatic void TerminateDestination(j_compress_ptr cinfo)\n{\n  DestinationManager\n    *destination;\n\n  destination=(DestinationManager *) cinfo->dest;\n  if ((MaxBufferExtent-(int) destination->manager.free_in_buffer) > 0)\n    {\n      ssize_t\n        count;\n\n      count=WriteBlob(destination->image,MaxBufferExtent-\n        destination->manager.free_in_buffer,destination->buffer);\n      if (count != (ssize_t)\n          (MaxBufferExtent-destination->manager.free_in_buffer))\n        ERREXIT(cinfo,JERR_FILE_WRITE);\n    }\n}\n\nstatic void WriteProfile(j_compress_ptr jpeg_info,Image *image,\n  ExceptionInfo *exception)\n{\n  const char\n    *name;\n\n  const StringInfo\n    *profile;\n\n  MagickBooleanType\n    iptc;\n\n  register ssize_t\n    i;\n\n  size_t\n    length,\n    tag_length;\n\n  StringInfo\n    *custom_profile;\n\n  /*\n    Save image profile as a APP marker.\n  */\n  iptc=MagickFalse;\n  custom_profile=AcquireStringInfo(65535L);\n  ResetImageProfileIterator(image);\n  for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n  {\n    profile=GetImageProfile(image,name);\n    if (LocaleCompare(name,\"EXIF\") == 0)\n      {\n        length=GetStringInfoLength(profile);\n        if (length > 65533L)\n          {\n            (void) ThrowMagickException(exception,GetMagickModule(),\n              CoderWarning,\"ExifProfileSizeExceedsLimit\",\"`%s'\",\n              image->filename);\n            length=65533L;\n          }\n        jpeg_write_marker(jpeg_info,XML_MARKER,GetStringInfoDatum(profile),\n          (unsigned int) length);\n      }\n    if (LocaleCompare(name,\"ICC\") == 0)\n      {\n        register unsigned char\n          *p;\n\n        tag_length=strlen(ICC_PROFILE);\n        p=GetStringInfoDatum(custom_profile);\n        (void) CopyMagickMemory(p,ICC_PROFILE,tag_length);\n        p[tag_length]='\\0';\n        for (i=0; i < (ssize_t) GetStringInfoLength(profile); i+=65519L)\n        {\n          length=MagickMin(GetStringInfoLength(profile)-i,65519L);\n          p[12]=(unsigned char) ((i/65519L)+1);\n          p[13]=(unsigned char) (GetStringInfoLength(profile)/65519L+1);\n          (void) CopyMagickMemory(p+tag_length+3,GetStringInfoDatum(profile)+i,\n            length);\n          jpeg_write_marker(jpeg_info,ICC_MARKER,GetStringInfoDatum(\n            custom_profile),(unsigned int) (length+tag_length+3));\n        }\n      }\n    if (((LocaleCompare(name,\"IPTC\") == 0) ||\n        (LocaleCompare(name,\"8BIM\") == 0)) && (iptc == MagickFalse))\n      {\n        register unsigned char\n          *p;\n\n        size_t\n          roundup;\n\n        iptc=MagickTrue;\n        p=GetStringInfoDatum(custom_profile);\n        for (i=0; i < (ssize_t) GetStringInfoLength(profile); i+=65500L)\n        {\n          length=MagickMin(GetStringInfoLength(profile)-i,65500L);\n          roundup=(size_t) (length & 0x01);\n          if (LocaleNCompare((char *) GetStringInfoDatum(profile),\"8BIM\",4) == 0)\n            {\n              (void) memcpy(p,\"Photoshop 3.0 \",14);\n              tag_length=14;\n            }\n          else\n            {\n              (void) CopyMagickMemory(p,\"Photoshop 3.0 8BIM\\04\\04\\0\\0\\0\\0\",24);\n              tag_length=26;\n              p[24]=(unsigned char) (length >> 8);\n              p[25]=(unsigned char) (length & 0xff);\n            }\n          p[13]=0x00;\n          (void) memcpy(p+tag_length,GetStringInfoDatum(profile)+i,length);\n          if (roundup != 0)\n            p[length+tag_length]='\\0';\n          jpeg_write_marker(jpeg_info,IPTC_MARKER,GetStringInfoDatum(\n            custom_profile),(unsigned int) (length+tag_length+roundup));\n        }\n      }\n    if (LocaleCompare(name,\"XMP\") == 0)\n      {\n        StringInfo\n          *xmp_profile;\n\n        /*\n          Add namespace to XMP profile.\n        */\n        xmp_profile=StringToStringInfo(\"http://ns.adobe.com/xap/1.0/ \");\n        if (xmp_profile != (StringInfo *) NULL)\n          {\n            if (profile != (StringInfo *) NULL)\n              ConcatenateStringInfo(xmp_profile,profile);\n            GetStringInfoDatum(xmp_profile)[28]='\\0';\n            for (i=0; i < (ssize_t) GetStringInfoLength(xmp_profile); i+=65533L)\n            {\n              length=MagickMin(GetStringInfoLength(xmp_profile)-i,65533L);\n              jpeg_write_marker(jpeg_info,XML_MARKER,\n                GetStringInfoDatum(xmp_profile)+i,(unsigned int) length);\n            }\n            xmp_profile=DestroyStringInfo(xmp_profile);\n          }\n      }\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"%s profile: %.20g bytes\",name,(double) GetStringInfoLength(profile));\n    name=GetNextImageProfile(image);\n  }\n  custom_profile=DestroyStringInfo(custom_profile);\n}\n\nstatic void JPEGDestinationManager(j_compress_ptr cinfo,Image * image)\n{\n  DestinationManager\n    *destination;\n\n  cinfo->dest=(struct jpeg_destination_mgr *) (*cinfo->mem->alloc_small)\n    ((j_common_ptr) cinfo,JPOOL_IMAGE,sizeof(DestinationManager));\n  destination=(DestinationManager *) cinfo->dest;\n  destination->manager.init_destination=InitializeDestination;\n  destination->manager.empty_output_buffer=EmptyOutputBuffer;\n  destination->manager.term_destination=TerminateDestination;\n  destination->image=image;\n}\n\nstatic char **SamplingFactorToList(const char *text)\n{\n  char\n    **textlist;\n\n  register char\n    *q;\n\n  register const char\n    *p;\n\n  register ssize_t\n    i;\n\n  if (text == (char *) NULL)\n    return((char **) NULL);\n  /*\n    Convert string to an ASCII list.\n  */\n  textlist=(char **) AcquireQuantumMemory((size_t) MAX_COMPONENTS,\n    sizeof(*textlist));\n  if (textlist == (char **) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"UnableToConvertText\");\n  p=text;\n  for (i=0; i < (ssize_t) MAX_COMPONENTS; i++)\n  {\n    for (q=(char *) p; *q != '\\0'; q++)\n      if (*q == ',')\n        break;\n    textlist[i]=(char *) AcquireQuantumMemory((size_t) (q-p)+MagickPathExtent,\n      sizeof(*textlist[i]));\n    if (textlist[i] == (char *) NULL)\n      ThrowFatalException(ResourceLimitFatalError,\"UnableToConvertText\");\n    (void) CopyMagickString(textlist[i],p,(size_t) (q-p+1));\n    if (*q == '\\r')\n      q++;\n    if (*q == '\\0')\n      break;\n    p=q+1;\n  }\n  for (i++; i < (ssize_t) MAX_COMPONENTS; i++)\n    textlist[i]=ConstantString(\"1x1\");\n  return(textlist);\n}\n\nstatic MagickBooleanType WriteJPEGImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  const char\n    *option,\n    *sampling_factor,\n    *value;\n\n  ErrorManager\n    error_manager;\n\n  Image\n    *volatile volatile_image;\n\n  int\n    colorspace,\n    quality;\n\n  JSAMPLE\n    *volatile jpeg_pixels;\n\n  JSAMPROW\n    scanline[1];\n\n  MagickBooleanType\n    status;\n\n  MemoryInfo\n    *memory_info;\n\n  register JSAMPLE\n    *q;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    y;\n\n  struct jpeg_compress_struct\n    jpeg_info;\n\n  struct jpeg_error_mgr\n    jpeg_error;\n\n  unsigned short\n    scale;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if ((LocaleCompare(image_info->magick,\"JPS\") == 0) &&\n      (image->next != (Image *) NULL))\n    image=AppendImages(image,MagickFalse,exception);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  /*\n    Initialize JPEG parameters.\n  */\n  (void) ResetMagickMemory(&error_manager,0,sizeof(error_manager));\n  (void) ResetMagickMemory(&jpeg_info,0,sizeof(jpeg_info));\n  (void) ResetMagickMemory(&jpeg_error,0,sizeof(jpeg_error));\n  volatile_image=image;\n  jpeg_info.client_data=(void *) volatile_image;\n  jpeg_info.err=jpeg_std_error(&jpeg_error);\n  jpeg_info.err->emit_message=(void (*)(j_common_ptr,int)) JPEGWarningHandler;\n  jpeg_info.err->error_exit=(void (*)(j_common_ptr)) JPEGErrorHandler;\n  error_manager.exception=exception;\n  error_manager.image=volatile_image;\n  memory_info=(MemoryInfo *) NULL;\n  if (setjmp(error_manager.error_recovery) != 0)\n    {\n      jpeg_destroy_compress(&jpeg_info);\n      (void) CloseBlob(volatile_image);\n      return(MagickFalse);\n    }\n  jpeg_info.client_data=(void *) &error_manager;\n  jpeg_create_compress(&jpeg_info);\n  JPEGDestinationManager(&jpeg_info,image);\n  if ((image->columns != (unsigned int) image->columns) ||\n      (image->rows != (unsigned int) image->rows))\n    ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n  jpeg_info.image_width=(unsigned int) image->columns;\n  jpeg_info.image_height=(unsigned int) image->rows;\n  jpeg_info.input_components=3;\n  jpeg_info.data_precision=8;\n  jpeg_info.in_color_space=JCS_RGB;\n  switch (image->colorspace)\n  {\n    case CMYKColorspace:\n    {\n      jpeg_info.input_components=4;\n      jpeg_info.in_color_space=JCS_CMYK;\n      break;\n    }\n    case YCbCrColorspace:\n    case Rec601YCbCrColorspace:\n    case Rec709YCbCrColorspace:\n    {\n      jpeg_info.in_color_space=JCS_YCbCr;\n      break;\n    }\n    case GRAYColorspace:\n    {\n      if (image_info->type == TrueColorType)\n        break;\n      jpeg_info.input_components=1;\n      jpeg_info.in_color_space=JCS_GRAYSCALE;\n      break;\n    }\n    default:\n    {\n      (void) TransformImageColorspace(image,sRGBColorspace,exception);\n      if (image_info->type == TrueColorType)\n        break;\n      if (SetImageGray(image,exception) != MagickFalse)\n        {\n          jpeg_info.input_components=1;\n          jpeg_info.in_color_space=JCS_GRAYSCALE;\n        }\n      break;\n    }\n  }\n  jpeg_set_defaults(&jpeg_info);\n  if (jpeg_info.in_color_space == JCS_CMYK)\n    jpeg_set_colorspace(&jpeg_info,JCS_YCCK);\n  if ((jpeg_info.data_precision != 12) && (image->depth <= 8))\n    jpeg_info.data_precision=8;\n  else\n    jpeg_info.data_precision=BITS_IN_JSAMPLE;\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"Image resolution: %.20g,%.20g\",image->resolution.x,image->resolution.y);\n  if ((image->resolution.x != 0.0) && (image->resolution.y != 0.0))\n    {\n      /*\n        Set image resolution.\n      */\n      jpeg_info.write_JFIF_header=TRUE;\n      jpeg_info.X_density=(UINT16) image->resolution.x;\n      jpeg_info.Y_density=(UINT16) image->resolution.y;\n      /*\n        Set image resolution units.\n      */\n      if (image->units == PixelsPerInchResolution)\n        jpeg_info.density_unit=(UINT8) 1;\n      if (image->units == PixelsPerCentimeterResolution)\n        jpeg_info.density_unit=(UINT8) 2;\n    }\n  jpeg_info.dct_method=JDCT_FLOAT;\n  option=GetImageOption(image_info,\"jpeg:dct-method\");\n  if (option != (const char *) NULL)\n    switch (*option)\n    {\n      case 'D':\n      case 'd':\n      {\n        if (LocaleCompare(option,\"default\") == 0)\n          jpeg_info.dct_method=JDCT_DEFAULT;\n        break;\n      }\n      case 'F':\n      case 'f':\n      {\n        if (LocaleCompare(option,\"fastest\") == 0)\n          jpeg_info.dct_method=JDCT_FASTEST;\n        if (LocaleCompare(option,\"float\") == 0)\n          jpeg_info.dct_method=JDCT_FLOAT;\n        break;\n      }\n      case 'I':\n      case 'i':\n      {\n        if (LocaleCompare(option,\"ifast\") == 0)\n          jpeg_info.dct_method=JDCT_IFAST;\n        if (LocaleCompare(option,\"islow\") == 0)\n          jpeg_info.dct_method=JDCT_ISLOW;\n        break;\n      }\n    }\n  option=GetImageOption(image_info,\"jpeg:optimize-coding\");\n  if (option != (const char *) NULL)\n    jpeg_info.optimize_coding=IsStringTrue(option) != MagickFalse ? TRUE :\n      FALSE;\n  else\n    {\n      MagickSizeType\n        length;\n\n      length=(MagickSizeType) jpeg_info.input_components*image->columns*\n        image->rows*sizeof(JSAMPLE);\n      if (length == (MagickSizeType) ((size_t) length))\n        {\n          /*\n            Perform optimization only if available memory resources permit it.\n          */\n          status=AcquireMagickResource(MemoryResource,length);\n          RelinquishMagickResource(MemoryResource,length);\n          jpeg_info.optimize_coding=status == MagickFalse ? FALSE : TRUE;\n        }\n    }\n#if (JPEG_LIB_VERSION >= 61) && defined(C_PROGRESSIVE_SUPPORTED)\n  if ((LocaleCompare(image_info->magick,\"PJPEG\") == 0) ||\n      (image_info->interlace != NoInterlace))\n    {\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Interlace: progressive\");\n      jpeg_simple_progression(&jpeg_info);\n    }\n  else\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"Interlace: non-progressive\");\n#else\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"Interlace: nonprogressive\");\n#endif\n  quality=92;\n  if ((image_info->compression != LosslessJPEGCompression) &&\n      (image->quality <= 100))\n    {\n      if (image->quality != UndefinedCompressionQuality)\n        quality=(int) image->quality;\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Quality: %.20g\",\n          (double) image->quality);\n    }\n  else\n    {\n#if !defined(C_LOSSLESS_SUPPORTED)\n      quality=100;\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Quality: 100\");\n#else\n      if (image->quality < 100)\n        (void) ThrowMagickException(exception,GetMagickModule(),CoderWarning,\n          \"LosslessToLossyJPEGConversion\",\"`%s'\",image->filename);\n      else\n        {\n          int\n            point_transform,\n            predictor;\n\n          predictor=image->quality/100;  /* range 1-7 */\n          point_transform=image->quality % 20;  /* range 0-15 */\n          jpeg_simple_lossless(&jpeg_info,predictor,point_transform);\n          if (image->debug != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"Compression: lossless\");\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"Predictor: %d\",predictor);\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"Point Transform: %d\",point_transform);\n            }\n        }\n#endif\n    }\n  option=GetImageOption(image_info,\"jpeg:extent\");\n  if (option != (const char *) NULL)\n    {\n      Image\n        *jpeg_image;\n\n      ImageInfo\n        *extent_info;\n\n      extent_info=CloneImageInfo(image_info);\n      extent_info->blob=NULL;\n      jpeg_image=CloneImage(image,0,0,MagickTrue,exception);\n      if (jpeg_image != (Image *) NULL)\n        {\n          MagickSizeType\n            extent;\n\n          size_t\n            maximum,\n            minimum;\n\n          /*\n            Search for compression quality that does not exceed image extent.\n          */\n          extent_info->quality=0;\n          extent=(MagickSizeType) SiPrefixToDoubleInterval(option,100.0);\n          (void) DeleteImageOption(extent_info,\"jpeg:extent\");\n          (void) DeleteImageArtifact(jpeg_image,\"jpeg:extent\");\n          maximum=image_info->quality;\n          if (maximum < 2)\n            maximum=101;\n          for (minimum=2; minimum < maximum; )\n          {\n            (void) AcquireUniqueFilename(jpeg_image->filename);\n            jpeg_image->quality=minimum+(maximum-minimum+1)/2;\n            status=WriteJPEGImage(extent_info,jpeg_image,exception);\n            if (GetBlobSize(jpeg_image) <= extent)\n              minimum=jpeg_image->quality+1;\n            else\n              maximum=jpeg_image->quality-1;\n            (void) RelinquishUniqueFileResource(jpeg_image->filename);\n          }\n          quality=(int) minimum-1;\n          jpeg_image=DestroyImage(jpeg_image);\n        }\n      extent_info=DestroyImageInfo(extent_info);\n    }\n  jpeg_set_quality(&jpeg_info,quality,TRUE);\n#if (JPEG_LIB_VERSION >= 70)\n  option=GetImageOption(image_info,\"quality\");\n  if (option != (const char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      int\n        flags;\n\n      /*\n        Set quality scaling for luminance and chrominance separately.\n      */\n      flags=ParseGeometry(option,&geometry_info);\n      if (((flags & RhoValue) != 0) && ((flags & SigmaValue) != 0))\n        {\n          jpeg_info.q_scale_factor[0]=jpeg_quality_scaling((int)\n            (geometry_info.rho+0.5));\n          jpeg_info.q_scale_factor[1]=jpeg_quality_scaling((int)\n            (geometry_info.sigma+0.5));\n          jpeg_default_qtables(&jpeg_info,TRUE);\n        }\n    }\n#endif\n  colorspace=jpeg_info.in_color_space;\n  value=GetImageOption(image_info,\"jpeg:colorspace\");\n  if (value == (char *) NULL)\n    value=GetImageProperty(image,\"jpeg:colorspace\",exception);\n  if (value != (char *) NULL)\n    colorspace=StringToInteger(value);\n  sampling_factor=(const char *) NULL;\n  if (colorspace == jpeg_info.in_color_space)\n    {\n      value=GetImageOption(image_info,\"jpeg:sampling-factor\");\n      if (value == (char *) NULL)\n        value=GetImageProperty(image,\"jpeg:sampling-factor\",exception);\n      if (value != (char *) NULL)\n        {\n          sampling_factor=value;\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Input sampling-factors=%s\",sampling_factor);\n        }\n    }\n  value=GetImageOption(image_info,\"jpeg:sampling-factor\");\n  if (image_info->sampling_factor != (char *) NULL)\n    sampling_factor=image_info->sampling_factor;\n  if (sampling_factor == (const char *) NULL)\n    {\n      if (quality >= 90)\n        for (i=0; i < MAX_COMPONENTS; i++)\n        {\n          jpeg_info.comp_info[i].h_samp_factor=1;\n          jpeg_info.comp_info[i].v_samp_factor=1;\n        }\n    }\n  else\n    {\n      char\n        **factors;\n\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      /*\n        Set sampling factor.\n      */\n      i=0;\n      factors=SamplingFactorToList(sampling_factor);\n      if (factors != (char **) NULL)\n        {\n          for (i=0; i < MAX_COMPONENTS; i++)\n          {\n            if (factors[i] == (char *) NULL)\n              break;\n            flags=ParseGeometry(factors[i],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=geometry_info.rho;\n            jpeg_info.comp_info[i].h_samp_factor=(int) geometry_info.rho;\n            jpeg_info.comp_info[i].v_samp_factor=(int) geometry_info.sigma;\n            factors[i]=(char *) RelinquishMagickMemory(factors[i]);\n          }\n          factors=(char **) RelinquishMagickMemory(factors);\n        }\n      for ( ; i < MAX_COMPONENTS; i++)\n      {\n        jpeg_info.comp_info[i].h_samp_factor=1;\n        jpeg_info.comp_info[i].v_samp_factor=1;\n      }\n    }\n  option=GetImageOption(image_info,\"jpeg:q-table\");\n  if (option != (const char *) NULL)\n    {\n      QuantizationTable\n        *table;\n\n      /*\n        Custom quantization tables.\n      */\n      table=GetQuantizationTable(option,\"0\",exception);\n      if (table != (QuantizationTable *) NULL)\n        {\n          for (i=0; i < MAX_COMPONENTS; i++)\n            jpeg_info.comp_info[i].quant_tbl_no=0;\n          jpeg_add_quant_table(&jpeg_info,0,table->levels,\n            jpeg_quality_scaling(quality),0);\n          table=DestroyQuantizationTable(table);\n        }\n      table=GetQuantizationTable(option,\"1\",exception);\n      if (table != (QuantizationTable *) NULL)\n        {\n          for (i=1; i < MAX_COMPONENTS; i++)\n            jpeg_info.comp_info[i].quant_tbl_no=1;\n          jpeg_add_quant_table(&jpeg_info,1,table->levels,\n            jpeg_quality_scaling(quality),0);\n          table=DestroyQuantizationTable(table);\n        }\n      table=GetQuantizationTable(option,\"2\",exception);\n      if (table != (QuantizationTable *) NULL)\n        {\n          for (i=2; i < MAX_COMPONENTS; i++)\n            jpeg_info.comp_info[i].quant_tbl_no=2;\n          jpeg_add_quant_table(&jpeg_info,2,table->levels,\n            jpeg_quality_scaling(quality),0);\n          table=DestroyQuantizationTable(table);\n        }\n      table=GetQuantizationTable(option,\"3\",exception);\n      if (table != (QuantizationTable *) NULL)\n        {\n          for (i=3; i < MAX_COMPONENTS; i++)\n            jpeg_info.comp_info[i].quant_tbl_no=3;\n          jpeg_add_quant_table(&jpeg_info,3,table->levels,\n            jpeg_quality_scaling(quality),0);\n          table=DestroyQuantizationTable(table);\n        }\n    }\n  jpeg_start_compress(&jpeg_info,TRUE);\n  if (image->debug != MagickFalse)\n    {\n      if (image->storage_class == PseudoClass)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Storage class: PseudoClass\");\n      else\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Storage class: DirectClass\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Depth: %.20g\",\n        (double) image->depth);\n      if (image->colors != 0)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Number of colors: %.20g\",(double) image->colors);\n      else\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Number of colors: unspecified\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"JPEG data precision: %d\",(int) jpeg_info.data_precision);\n      switch (image->colorspace)\n      {\n        case CMYKColorspace:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Storage class: DirectClass\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Colorspace: CMYK\");\n          break;\n        }\n        case YCbCrColorspace:\n        case Rec601YCbCrColorspace:\n        case Rec709YCbCrColorspace:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Colorspace: YCbCr\");\n          break;\n        }\n        default:\n          break;\n      }\n      switch (image->colorspace)\n      {\n        case CMYKColorspace:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Colorspace: CMYK\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Sampling factors: %dx%d,%dx%d,%dx%d,%dx%d\",\n            jpeg_info.comp_info[0].h_samp_factor,\n            jpeg_info.comp_info[0].v_samp_factor,\n            jpeg_info.comp_info[1].h_samp_factor,\n            jpeg_info.comp_info[1].v_samp_factor,\n            jpeg_info.comp_info[2].h_samp_factor,\n            jpeg_info.comp_info[2].v_samp_factor,\n            jpeg_info.comp_info[3].h_samp_factor,\n            jpeg_info.comp_info[3].v_samp_factor);\n          break;\n        }\n        case GRAYColorspace:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Colorspace: GRAY\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Sampling factors: %dx%d\",jpeg_info.comp_info[0].h_samp_factor,\n            jpeg_info.comp_info[0].v_samp_factor);\n          break;\n        }\n        case sRGBColorspace:\n        case RGBColorspace:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Image colorspace is RGB\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Sampling factors: %dx%d,%dx%d,%dx%d\",\n            jpeg_info.comp_info[0].h_samp_factor,\n            jpeg_info.comp_info[0].v_samp_factor,\n            jpeg_info.comp_info[1].h_samp_factor,\n            jpeg_info.comp_info[1].v_samp_factor,\n            jpeg_info.comp_info[2].h_samp_factor,\n            jpeg_info.comp_info[2].v_samp_factor);\n          break;\n        }\n        case YCbCrColorspace:\n        case Rec601YCbCrColorspace:\n        case Rec709YCbCrColorspace:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Colorspace: YCbCr\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Sampling factors: %dx%d,%dx%d,%dx%d\",\n            jpeg_info.comp_info[0].h_samp_factor,\n            jpeg_info.comp_info[0].v_samp_factor,\n            jpeg_info.comp_info[1].h_samp_factor,\n            jpeg_info.comp_info[1].v_samp_factor,\n            jpeg_info.comp_info[2].h_samp_factor,\n            jpeg_info.comp_info[2].v_samp_factor);\n          break;\n        }\n        default:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Colorspace: %d\",\n            image->colorspace);\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Sampling factors: %dx%d,%dx%d,%dx%d,%dx%d\",\n            jpeg_info.comp_info[0].h_samp_factor,\n            jpeg_info.comp_info[0].v_samp_factor,\n            jpeg_info.comp_info[1].h_samp_factor,\n            jpeg_info.comp_info[1].v_samp_factor,\n            jpeg_info.comp_info[2].h_samp_factor,\n            jpeg_info.comp_info[2].v_samp_factor,\n            jpeg_info.comp_info[3].h_samp_factor,\n            jpeg_info.comp_info[3].v_samp_factor);\n          break;\n        }\n      }\n    }\n  /*\n    Write JPEG profiles.\n  */\n  value=GetImageProperty(image,\"comment\",exception);\n  if (value != (char *) NULL)\n    for (i=0; i < (ssize_t) strlen(value); i+=65533L)\n      jpeg_write_marker(&jpeg_info,JPEG_COM,(unsigned char *) value+i,\n        (unsigned int) MagickMin((size_t) strlen(value+i),65533L));\n  if (image->profiles != (void *) NULL)\n    WriteProfile(&jpeg_info,image,exception);\n  /*\n    Convert MIFF to JPEG raster pixels.\n  */\n  memory_info=AcquireVirtualMemory((size_t) image->columns,\n    jpeg_info.input_components*sizeof(*jpeg_pixels));\n  if (memory_info == (MemoryInfo *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  jpeg_pixels=(JSAMPLE *) GetVirtualMemoryBlob(memory_info);\n  if (setjmp(error_manager.error_recovery) != 0)\n    {\n      jpeg_destroy_compress(&jpeg_info);\n      if (memory_info != (MemoryInfo *) NULL)\n        memory_info=RelinquishVirtualMemory(memory_info);\n      (void) CloseBlob(image);\n      return(MagickFalse);\n    }\n  scanline[0]=(JSAMPROW) jpeg_pixels;\n  scale=65535/(unsigned short) GetQuantumRange((size_t)\n    jpeg_info.data_precision);\n  if (scale == 0)\n    scale=1;\n  if (jpeg_info.data_precision <= 8)\n    {\n      if ((jpeg_info.in_color_space == JCS_RGB) ||\n          (jpeg_info.in_color_space == JCS_YCbCr))\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=jpeg_pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=(JSAMPLE) ScaleQuantumToChar(GetPixelRed(image,p));\n            *q++=(JSAMPLE) ScaleQuantumToChar(GetPixelGreen(image,p));\n            *q++=(JSAMPLE) ScaleQuantumToChar(GetPixelBlue(image,p));\n            p+=GetPixelChannels(image);\n          }\n          (void) jpeg_write_scanlines(&jpeg_info,scanline,1);\n          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n      else\n        if (jpeg_info.in_color_space == JCS_GRAYSCALE)\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            register const Quantum\n              *p;\n\n            register ssize_t\n              x;\n\n            p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n            if (p == (const Quantum *) NULL)\n              break;\n            q=jpeg_pixels;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              *q++=(JSAMPLE) ScaleQuantumToChar(ClampToQuantum(GetPixelLuma(\n                image,p)));\n              p+=GetPixelChannels(image);\n            }\n            (void) jpeg_write_scanlines(&jpeg_info,scanline,1);\n            status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n            }\n        else\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            register const Quantum\n              *p;\n\n            register ssize_t\n              x;\n\n            p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n            if (p == (const Quantum *) NULL)\n              break;\n            q=jpeg_pixels;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              /*\n                Convert DirectClass packets to contiguous CMYK scanlines.\n              */\n              *q++=(JSAMPLE) (ScaleQuantumToChar((Quantum) (QuantumRange-\n                GetPixelCyan(image,p))));\n              *q++=(JSAMPLE) (ScaleQuantumToChar((Quantum) (QuantumRange-\n                GetPixelMagenta(image,p))));\n              *q++=(JSAMPLE) (ScaleQuantumToChar((Quantum) (QuantumRange-\n                GetPixelYellow(image,p))));\n              *q++=(JSAMPLE) (ScaleQuantumToChar((Quantum) (QuantumRange-\n                GetPixelBlack(image,p))));\n              p+=GetPixelChannels(image);\n            }\n            (void) jpeg_write_scanlines(&jpeg_info,scanline,1);\n            status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n    }\n  else\n    if (jpeg_info.in_color_space == JCS_GRAYSCALE)\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        register const Quantum\n          *p;\n\n        register ssize_t\n          x;\n\n        p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n        if (p == (const Quantum *) NULL)\n          break;\n        q=jpeg_pixels;\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          *q++=(JSAMPLE) (ScaleQuantumToShort(ClampToQuantum(GetPixelLuma(image,\n            p)))/scale);\n          p+=GetPixelChannels(image);\n        }\n        (void) jpeg_write_scanlines(&jpeg_info,scanline,1);\n        status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n    else\n      if ((jpeg_info.in_color_space == JCS_RGB) ||\n          (jpeg_info.in_color_space == JCS_YCbCr))\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=jpeg_pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=(JSAMPLE) (ScaleQuantumToShort(GetPixelRed(image,p))/scale);\n            *q++=(JSAMPLE) (ScaleQuantumToShort(GetPixelGreen(image,p))/scale);\n            *q++=(JSAMPLE) (ScaleQuantumToShort(GetPixelBlue(image,p))/scale);\n            p+=GetPixelChannels(image);\n          }\n          (void) jpeg_write_scanlines(&jpeg_info,scanline,1);\n          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n      else\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=jpeg_pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            /*\n              Convert DirectClass packets to contiguous CMYK scanlines.\n            */\n            *q++=(JSAMPLE) (ScaleQuantumToShort(QuantumRange-GetPixelRed(\n              image,p))/scale);\n            *q++=(JSAMPLE) (ScaleQuantumToShort(QuantumRange-GetPixelGreen(\n              image,p))/scale);\n            *q++=(JSAMPLE) (ScaleQuantumToShort(QuantumRange-GetPixelBlue(\n              image,p))/scale);\n            *q++=(JSAMPLE) (ScaleQuantumToShort(QuantumRange-GetPixelBlack(\n              image,p))/scale);\n            p+=GetPixelChannels(image);\n          }\n          (void) jpeg_write_scanlines(&jpeg_info,scanline,1);\n          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n  if (y == (ssize_t) image->rows)\n    jpeg_finish_compress(&jpeg_info);\n  /*\n    Relinquish resources.\n  */\n  jpeg_destroy_compress(&jpeg_info);\n  memory_info=RelinquishVirtualMemory(memory_info);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n#endif\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                        JJJJJ  PPPP   EEEEE   GGGG                           %\n%                          J    P   P  E      G                               %\n%                          J    PPPP   EEE    G  GG                           %\n%                        J J    P      E      G   G                           %\n%                        JJJ    P      EEEEE   GGG                            %\n%                                                                             %\n%                                                                             %\n%                       Read/Write JPEG Image Format                          %\n%                                                                             %\n%                              Software Design                                %\n%                                John Cristy                                  %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2013 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://www.imagemagick.org/script/license.php                           %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n% This software is based in part on the work of the Independent JPEG Group.\n% See ftp://ftp.uu.net/graphics/jpeg/jpegsrc.v6b.tar.gz for copyright and\n% licensing restrictions.  Blob support contributed by Glenn Randers-Pehrson.\n%\n%\n*/\n\n\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/colormap-private.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/option-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/splay-tree.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/xml-tree.h\"\n#include \"MagickCore/xml-tree-private.h\"\n#include <setjmp.h>\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n#define JPEG_INTERNAL_OPTIONS\n#if defined(__MINGW32__) || defined(__MINGW64__)\n# define XMD_H 1  /* Avoid conflicting typedef for INT32 */\n#endif\n#undef HAVE_STDLIB_H\n#include \"jpeglib.h\"\n#include \"jerror.h\"\n#endif\n\f\n/*\n  Define declarations.\n*/\n#define ICC_MARKER  (JPEG_APP0+2)\n#define ICC_PROFILE  \"ICC_PROFILE\"\n#define IPTC_MARKER  (JPEG_APP0+13)\n#define XML_MARKER  (JPEG_APP0+1)\n#define MaxBufferExtent  16384\n\f\n/*\n  Typedef declarations.\n*/\n#if defined(MAGICKCORE_JPEG_DELEGATE)\ntypedef struct _DestinationManager\n{\n  struct jpeg_destination_mgr\n    manager;\n\n  Image\n    *image;\n\n  JOCTET\n    *buffer;\n} DestinationManager;\n\ntypedef struct _ErrorManager\n{\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    finished;\n\n  StringInfo\n    *profile;\n\n  jmp_buf\n    error_recovery;\n} ErrorManager;\n\ntypedef struct _SourceManager\n{\n  struct jpeg_source_mgr\n    manager;\n\n  Image\n    *image;\n\n  JOCTET\n    *buffer;\n\n  boolean\n    start_of_blob;\n} SourceManager;\n#endif\n\ntypedef struct _QuantizationTable\n{\n  char\n    *slot,\n    *description;\n\n  size_t\n    width,\n    height;\n\n  double\n    divisor;\n\n  unsigned int\n    *levels;\n} QuantizationTable;\n\f\n/*\n  Forward declarations.\n*/\n#if defined(MAGICKCORE_JPEG_DELEGATE)\nstatic MagickBooleanType\n  WriteJPEGImage(const ImageInfo *,Image *,ExceptionInfo *);\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s J P E G                                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsJPEG() returns MagickTrue if the image format type, identified by the\n%  magick string, is JPEG.\n%\n%  The format of the IsJPEG  method is:\n%\n%      MagickBooleanType IsJPEG(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsJPEG(const unsigned char *magick,const size_t length)\n{\n  if (length < 3)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\377\\330\\377\",3) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d J P E G I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadJPEGImage() reads a JPEG image file and returns it.  It allocates\n%  the memory necessary for the new Image structure and returns a pointer to\n%  the new image.\n%\n%  The format of the ReadJPEGImage method is:\n%\n%      Image *ReadJPEGImage(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic boolean FillInputBuffer(j_decompress_ptr cinfo)\n{\n  SourceManager\n    *source;\n\n  source=(SourceManager *) cinfo->src;\n  source->manager.bytes_in_buffer=(size_t) ReadBlob(source->image,\n    MaxBufferExtent,source->buffer);\n  if (source->manager.bytes_in_buffer == 0)\n    {\n      if (source->start_of_blob != FALSE)\n        ERREXIT(cinfo,JERR_INPUT_EMPTY);\n      WARNMS(cinfo,JWRN_JPEG_EOF);\n      source->buffer[0]=(JOCTET) 0xff;\n      source->buffer[1]=(JOCTET) JPEG_EOI;\n      source->manager.bytes_in_buffer=2;\n    }\n  source->manager.next_input_byte=source->buffer;\n  source->start_of_blob=FALSE;\n  return(TRUE);\n}\n\nstatic int GetCharacter(j_decompress_ptr jpeg_info)\n{\n  if (jpeg_info->src->bytes_in_buffer == 0)\n    (void) (*jpeg_info->src->fill_input_buffer)(jpeg_info);\n  jpeg_info->src->bytes_in_buffer--;\n  return((int) GETJOCTET(*jpeg_info->src->next_input_byte++));\n}\n\nstatic void InitializeSource(j_decompress_ptr cinfo)\n{\n  SourceManager\n    *source;\n\n  source=(SourceManager *) cinfo->src;\n  source->start_of_blob=TRUE;\n}\n\nstatic MagickBooleanType IsITUFaxImage(const Image *image)\n{\n  const StringInfo\n    *profile;\n\n  const unsigned char\n    *datum;\n\n  profile=GetImageProfile(image,\"8bim\");\n  if (profile == (const StringInfo *) NULL)\n    return(MagickFalse);\n  if (GetStringInfoLength(profile) < 5)\n    return(MagickFalse);\n  datum=GetStringInfoDatum(profile);\n  if ((datum[0] == 0x47) && (datum[1] == 0x33) && (datum[2] == 0x46) &&\n      (datum[3] == 0x41) && (datum[4] == 0x58))\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\nstatic void JPEGErrorHandler(j_common_ptr jpeg_info)\n{\n  char\n    message[JMSG_LENGTH_MAX];\n\n  ErrorManager\n    *error_manager;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  *message='\\0';\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  image=error_manager->image;\n  exception=error_manager->exception;\n  (jpeg_info->err->format_message)(jpeg_info,message);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"[%s] JPEG Trace: \\\"%s\\\"\",image->filename,message);\n  if (error_manager->finished != MagickFalse)\n    (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageWarning,\n      (char *) message,\"`%s'\",image->filename);\n  else\n    (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n      (char *) message,\"`%s'\",image->filename);\n  longjmp(error_manager->error_recovery,1);\n}\n\nstatic MagickBooleanType JPEGWarningHandler(j_common_ptr jpeg_info,int level)\n{\n#define JPEGExcessiveWarnings  1000\n\n  char\n    message[JMSG_LENGTH_MAX];\n\n  ErrorManager\n    *error_manager;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  *message='\\0';\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  exception=error_manager->exception;\n  image=error_manager->image;\n  if (level < 0)\n    {\n      /*\n        Process warning message.\n      */\n      (jpeg_info->err->format_message)(jpeg_info,message);\n      if (jpeg_info->err->num_warnings++ < JPEGExcessiveWarnings)\n        ThrowBinaryException(CorruptImageWarning,(char *) message,\n          image->filename);\n    }\n  else\n    if ((image->debug != MagickFalse) &&\n        (level >= jpeg_info->err->trace_level))\n      {\n        /*\n          Process trace message.\n        */\n        (jpeg_info->err->format_message)(jpeg_info,message);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"[%s] JPEG Trace: \\\"%s\\\"\",image->filename,message);\n      }\n  return(MagickTrue);\n}\n\nstatic boolean ReadComment(j_decompress_ptr jpeg_info)\n{\n  ErrorManager\n    *error_manager;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  register unsigned char\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    length;\n\n  StringInfo\n    *comment;\n\n  /*\n    Determine length of comment.\n  */\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  exception=error_manager->exception;\n  image=error_manager->image;\n  length=(size_t) ((size_t) GetCharacter(jpeg_info) << 8);\n  length+=GetCharacter(jpeg_info);\n  if (length <= 2)\n    return(TRUE);\n  length-=2;\n  comment=BlobToStringInfo((const void *) NULL,length);\n  if (comment == (StringInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(FALSE);\n    }\n  /*\n    Read comment.\n  */\n  error_manager->profile=comment;\n  p=GetStringInfoDatum(comment);\n  for (i=0; i < (ssize_t) GetStringInfoLength(comment); i++)\n    *p++=(unsigned char) GetCharacter(jpeg_info);\n  *p='\\0';\n  error_manager->profile=NULL;\n  p=GetStringInfoDatum(comment);\n  (void) SetImageProperty(image,\"comment\",(const char *) p,exception);\n  comment=DestroyStringInfo(comment);\n  return(TRUE);\n}\n\nstatic boolean ReadICCProfile(j_decompress_ptr jpeg_info)\n{\n  char\n    magick[12];\n\n  ErrorManager\n    *error_manager;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    length;\n\n  StringInfo\n    *icc_profile,\n    *profile;\n\n  /*\n    Read color profile.\n  */\n  length=(size_t) ((size_t) GetCharacter(jpeg_info) << 8);\n  length+=(size_t) GetCharacter(jpeg_info);\n  length-=2;\n  if (length <= 14)\n    {\n      while (length-- > 0)\n        (void) GetCharacter(jpeg_info);\n      return(TRUE);\n    }\n  for (i=0; i < 12; i++)\n    magick[i]=(char) GetCharacter(jpeg_info);\n  if (LocaleCompare(magick,ICC_PROFILE) != 0)\n    {\n      /*\n        Not a ICC profile, return.\n      */\n      for (i=0; i < (ssize_t) (length-12); i++)\n        (void) GetCharacter(jpeg_info);\n      return(TRUE);\n    }\n  (void) GetCharacter(jpeg_info);  /* id */\n  (void) GetCharacter(jpeg_info);  /* markers */\n  length-=14;\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  exception=error_manager->exception;\n  image=error_manager->image;\n  profile=BlobToStringInfo((const void *) NULL,length);\n  if (profile == (StringInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(FALSE);\n    }\n  error_manager->profile=profile;\n  p=GetStringInfoDatum(profile);\n  for (i=(ssize_t) GetStringInfoLength(profile)-1; i >= 0; i--)\n    *p++=(unsigned char) GetCharacter(jpeg_info);\n  error_manager->profile=NULL;\n  icc_profile=(StringInfo *) GetImageProfile(image,\"icc\");\n  if (icc_profile != (StringInfo *) NULL)\n    {\n      ConcatenateStringInfo(icc_profile,profile);\n      profile=DestroyStringInfo(profile);\n    }\n  else\n    {\n      status=SetImageProfile(image,\"icc\",profile,exception);\n      profile=DestroyStringInfo(profile);\n      if (status == MagickFalse)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n          return(FALSE);\n        }\n    }\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"Profile: ICC, %.20g bytes\",(double) length);\n  return(TRUE);\n}\n\nstatic boolean ReadIPTCProfile(j_decompress_ptr jpeg_info)\n{\n  char\n    magick[MagickPathExtent];\n\n  ErrorManager\n    *error_manager;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    length;\n\n  StringInfo\n    *iptc_profile,\n    *profile;\n\n  /*\n    Determine length of binary data stored here.\n  */\n  length=(size_t) ((size_t) GetCharacter(jpeg_info) << 8);\n  length+=(size_t) GetCharacter(jpeg_info);\n  length-=2;\n  if (length <= 14)\n    {\n      while (length-- > 0)\n        (void) GetCharacter(jpeg_info);\n      return(TRUE);\n    }\n  /*\n    Validate that this was written as a Photoshop resource format slug.\n  */\n  for (i=0; i < 10; i++)\n    magick[i]=(char) GetCharacter(jpeg_info);\n  magick[10]='\\0';\n  length-=10;\n  if (length <= 10)\n    return(TRUE);\n  if (LocaleCompare(magick,\"Photoshop \") != 0)\n    {\n      /*\n        Not a IPTC profile, return.\n      */\n      for (i=0; i < (ssize_t) length; i++)\n        (void) GetCharacter(jpeg_info);\n      return(TRUE);\n    }\n  /*\n    Remove the version number.\n  */\n  for (i=0; i < 4; i++)\n    (void) GetCharacter(jpeg_info);\n  if (length <= 11)\n    return(TRUE);\n  length-=4;\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  exception=error_manager->exception;\n  image=error_manager->image;\n  profile=BlobToStringInfo((const void *) NULL,length);\n  if (profile == (StringInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(FALSE);\n    }\n  error_manager->profile=profile;\n  p=GetStringInfoDatum(profile);\n  for (i=0;  i < (ssize_t) GetStringInfoLength(profile); i++)\n    *p++=(unsigned char) GetCharacter(jpeg_info);\n  error_manager->profile=NULL;\n  iptc_profile=(StringInfo *) GetImageProfile(image,\"8bim\");\n  if (iptc_profile != (StringInfo *) NULL)\n    {\n      ConcatenateStringInfo(iptc_profile,profile);\n      profile=DestroyStringInfo(profile);\n    }\n  else\n    {\n      status=SetImageProfile(image,\"8bim\",profile,exception);\n      profile=DestroyStringInfo(profile);\n      if (status == MagickFalse)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n          return(FALSE);\n        }\n    }\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"Profile: iptc, %.20g bytes\",(double) length);\n  return(TRUE);\n}\n\nstatic boolean ReadProfile(j_decompress_ptr jpeg_info)\n{\n  char\n    name[MagickPathExtent];\n\n  const StringInfo\n    *previous_profile;\n\n  ErrorManager\n    *error_manager;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  int\n    marker;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    length;\n\n  StringInfo\n    *profile;\n\n  /*\n    Read generic profile.\n  */\n  length=(size_t) ((size_t) GetCharacter(jpeg_info) << 8);\n  length+=(size_t) GetCharacter(jpeg_info);\n  if (length <= 2)\n    return(TRUE);\n  length-=2;\n  marker=jpeg_info->unread_marker-JPEG_APP0;\n  (void) FormatLocaleString(name,MagickPathExtent,\"APP%d\",marker);\n  error_manager=(ErrorManager *) jpeg_info->client_data;\n  exception=error_manager->exception;\n  image=error_manager->image;\n  profile=BlobToStringInfo((const void *) NULL,length);\n  if (profile == (StringInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(FALSE);\n    }\n  error_manager->profile=profile;\n  p=GetStringInfoDatum(profile);\n  for (i=0; i < (ssize_t) GetStringInfoLength(profile); i++)\n    *p++=(unsigned char) GetCharacter(jpeg_info);\n  error_manager->profile=NULL;\n  if (marker == 1)\n    {\n      p=GetStringInfoDatum(profile);\n      if ((length > 4) && (LocaleNCompare((char *) p,\"exif\",4) == 0))\n        (void) CopyMagickString(name,\"exif\",MagickPathExtent);\n      if ((length > 5) && (LocaleNCompare((char *) p,\"http:\",5) == 0))\n        {\n          ssize_t\n            j;\n\n          /*\n            Extract namespace from XMP profile.\n          */\n          p=GetStringInfoDatum(profile);\n          for (j=0; j < (ssize_t) GetStringInfoLength(profile); j++)\n          {\n            if (*p == '\\0')\n              break;\n            p++;\n          }\n          if (j < (ssize_t) GetStringInfoLength(profile))\n            (void) DestroyStringInfo(SplitStringInfo(profile,(size_t) (j+1)));\n          (void) CopyMagickString(name,\"xmp\",MagickPathExtent);\n        }\n    }\n  previous_profile=GetImageProfile(image,name);\n  if (previous_profile != (const StringInfo *) NULL)\n    {\n      size_t\n        profile_length;\n\n      profile_length=GetStringInfoLength(profile);\n      SetStringInfoLength(profile,GetStringInfoLength(profile)+\n        GetStringInfoLength(previous_profile));\n      (void) memmove(GetStringInfoDatum(profile)+\n        GetStringInfoLength(previous_profile),GetStringInfoDatum(profile),\n        profile_length);\n      (void) memcpy(GetStringInfoDatum(profile),\n        GetStringInfoDatum(previous_profile),\n        GetStringInfoLength(previous_profile));\n    }\n  status=SetImageProfile(image,name,profile,exception);\n  profile=DestroyStringInfo(profile);\n  if (status == MagickFalse)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(FALSE);\n    }\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"Profile: %s, %.20g bytes\",name,(double) length);\n  return(TRUE);\n}\n\nstatic void SkipInputData(j_decompress_ptr cinfo,long number_bytes)\n{\n  SourceManager\n    *source;\n\n  if (number_bytes <= 0)\n    return;\n  source=(SourceManager *) cinfo->src;\n  while (number_bytes > (long) source->manager.bytes_in_buffer)\n  {\n    number_bytes-=(long) source->manager.bytes_in_buffer;\n    (void) FillInputBuffer(cinfo);\n  }\n  source->manager.next_input_byte+=number_bytes;\n  source->manager.bytes_in_buffer-=number_bytes;\n}\n\nstatic void TerminateSource(j_decompress_ptr cinfo)\n{\n  (void) cinfo;\n}\n\nstatic void JPEGSourceManager(j_decompress_ptr cinfo,Image *image)\n{\n  SourceManager\n    *source;\n\n  cinfo->src=(struct jpeg_source_mgr *) (*cinfo->mem->alloc_small)\n    ((j_common_ptr) cinfo,JPOOL_IMAGE,sizeof(SourceManager));\n  source=(SourceManager *) cinfo->src;\n  source->buffer=(JOCTET *) (*cinfo->mem->alloc_small)\n    ((j_common_ptr) cinfo,JPOOL_IMAGE,MaxBufferExtent*sizeof(JOCTET));\n  source=(SourceManager *) cinfo->src;\n  source->manager.init_source=InitializeSource;\n  source->manager.fill_input_buffer=FillInputBuffer;\n  source->manager.skip_input_data=SkipInputData;\n  source->manager.resync_to_restart=jpeg_resync_to_restart;\n  source->manager.term_source=TerminateSource;\n  source->manager.bytes_in_buffer=0;\n  source->manager.next_input_byte=NULL;\n  source->image=image;\n}\n\nstatic void JPEGSetImageQuality(struct jpeg_decompress_struct *jpeg_info,\n  Image *image)\n{\n  image->quality=UndefinedCompressionQuality;\n#if defined(D_PROGRESSIVE_SUPPORTED)\n  if (image->compression == LosslessJPEGCompression)\n    {\n      image->quality=100;\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"Quality: 100 (lossless)\");\n    }\n  else\n#endif\n  {\n    ssize_t\n      j,\n      qvalue,\n      sum;\n\n    register ssize_t\n      i;\n\n    /*\n      Determine the JPEG compression quality from the quantization tables.\n    */\n    sum=0;\n    for (i=0; i < NUM_QUANT_TBLS; i++)\n    {\n      if (jpeg_info->quant_tbl_ptrs[i] != NULL)\n        for (j=0; j < DCTSIZE2; j++)\n          sum+=jpeg_info->quant_tbl_ptrs[i]->quantval[j];\n    }\n    if ((jpeg_info->quant_tbl_ptrs[0] != NULL) &&\n        (jpeg_info->quant_tbl_ptrs[1] != NULL))\n      {\n        ssize_t\n          hash[101] =\n          {\n            1020, 1015,  932,  848,  780,  735,  702,  679,  660,  645,\n             632,  623,  613,  607,  600,  594,  589,  585,  581,  571,\n             555,  542,  529,  514,  494,  474,  457,  439,  424,  410,\n             397,  386,  373,  364,  351,  341,  334,  324,  317,  309,\n             299,  294,  287,  279,  274,  267,  262,  257,  251,  247,\n             243,  237,  232,  227,  222,  217,  213,  207,  202,  198,\n             192,  188,  183,  177,  173,  168,  163,  157,  153,  148,\n             143,  139,  132,  128,  125,  119,  115,  108,  104,   99,\n              94,   90,   84,   79,   74,   70,   64,   59,   55,   49,\n              45,   40,   34,   30,   25,   20,   15,   11,    6,    4,\n               0\n          },\n          sums[101] =\n          {\n            32640, 32635, 32266, 31495, 30665, 29804, 29146, 28599, 28104,\n            27670, 27225, 26725, 26210, 25716, 25240, 24789, 24373, 23946,\n            23572, 22846, 21801, 20842, 19949, 19121, 18386, 17651, 16998,\n            16349, 15800, 15247, 14783, 14321, 13859, 13535, 13081, 12702,\n            12423, 12056, 11779, 11513, 11135, 10955, 10676, 10392, 10208,\n             9928,  9747,  9564,  9369,  9193,  9017,  8822,  8639,  8458,\n             8270,  8084,  7896,  7710,  7527,  7347,  7156,  6977,  6788,\n             6607,  6422,  6236,  6054,  5867,  5684,  5495,  5305,  5128,\n             4945,  4751,  4638,  4442,  4248,  4065,  3888,  3698,  3509,\n             3326,  3139,  2957,  2775,  2586,  2405,  2216,  2037,  1846,\n             1666,  1483,  1297,  1109,   927,   735,   554,   375,   201,\n              128,     0\n          };\n\n        qvalue=(ssize_t) (jpeg_info->quant_tbl_ptrs[0]->quantval[2]+\n          jpeg_info->quant_tbl_ptrs[0]->quantval[53]+\n          jpeg_info->quant_tbl_ptrs[1]->quantval[0]+\n          jpeg_info->quant_tbl_ptrs[1]->quantval[DCTSIZE2-1]);\n        for (i=0; i < 100; i++)\n        {\n          if ((qvalue < hash[i]) && (sum < sums[i]))\n            continue;\n          if (((qvalue <= hash[i]) && (sum <= sums[i])) || (i >= 50))\n            image->quality=(size_t) i+1;\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"Quality: %.20g (%s)\",(double) i+1,(qvalue <= hash[i]) &&\n              (sum <= sums[i]) ? \"exact\" : \"approximate\");\n          break;\n        }\n      }\n    else\n      if (jpeg_info->quant_tbl_ptrs[0] != NULL)\n        {\n          ssize_t\n            hash[101] =\n            {\n              510,  505,  422,  380,  355,  338,  326,  318,  311,  305,\n              300,  297,  293,  291,  288,  286,  284,  283,  281,  280,\n              279,  278,  277,  273,  262,  251,  243,  233,  225,  218,\n              211,  205,  198,  193,  186,  181,  177,  172,  168,  164,\n              158,  156,  152,  148,  145,  142,  139,  136,  133,  131,\n              129,  126,  123,  120,  118,  115,  113,  110,  107,  105,\n              102,  100,   97,   94,   92,   89,   87,   83,   81,   79,\n               76,   74,   70,   68,   66,   63,   61,   57,   55,   52,\n               50,   48,   44,   42,   39,   37,   34,   31,   29,   26,\n               24,   21,   18,   16,   13,   11,    8,    6,    3,    2,\n                0\n            },\n            sums[101] =\n            {\n              16320, 16315, 15946, 15277, 14655, 14073, 13623, 13230, 12859,\n              12560, 12240, 11861, 11456, 11081, 10714, 10360, 10027,  9679,\n               9368,  9056,  8680,  8331,  7995,  7668,  7376,  7084,  6823,\n               6562,  6345,  6125,  5939,  5756,  5571,  5421,  5240,  5086,\n               4976,  4829,  4719,  4616,  4463,  4393,  4280,  4166,  4092,\n               3980,  3909,  3835,  3755,  3688,  3621,  3541,  3467,  3396,\n               3323,  3247,  3170,  3096,  3021,  2952,  2874,  2804,  2727,\n               2657,  2583,  2509,  2437,  2362,  2290,  2211,  2136,  2068,\n               1996,  1915,  1858,  1773,  1692,  1620,  1552,  1477,  1398,\n               1326,  1251,  1179,  1109,  1031,   961,   884,   814,   736,\n                667,   592,   518,   441,   369,   292,   221,   151,    86,\n                 64,     0\n            };\n\n          qvalue=(ssize_t) (jpeg_info->quant_tbl_ptrs[0]->quantval[2]+\n            jpeg_info->quant_tbl_ptrs[0]->quantval[53]);\n          for (i=0; i < 100; i++)\n          {\n            if ((qvalue < hash[i]) && (sum < sums[i]))\n              continue;\n            if (((qvalue <= hash[i]) && (sum <= sums[i])) || (i >= 50))\n              image->quality=(size_t)i+1;\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"Quality: %.20g (%s)\",(double) i+1,(qvalue <= hash[i]) &&\n                (sum <= sums[i]) ? \"exact\" : \"approximate\");\n            break;\n          }\n        }\n  }\n}\n\nstatic void JPEGSetImageSamplingFactor(struct jpeg_decompress_struct *jpeg_info,  Image *image,ExceptionInfo *exception)\n{\n  char\n    sampling_factor[MagickPathExtent];\n\n  switch (jpeg_info->out_color_space)\n  {\n    case JCS_CMYK:\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Colorspace: CMYK\");\n      (void) FormatLocaleString(sampling_factor,MagickPathExtent,\n        \"%dx%d,%dx%d,%dx%d,%dx%d\",jpeg_info->comp_info[0].h_samp_factor,\n        jpeg_info->comp_info[0].v_samp_factor,\n        jpeg_info->comp_info[1].h_samp_factor,\n        jpeg_info->comp_info[1].v_samp_factor,\n        jpeg_info->comp_info[2].h_samp_factor,\n        jpeg_info->comp_info[2].v_samp_factor,\n        jpeg_info->comp_info[3].h_samp_factor,\n        jpeg_info->comp_info[3].v_samp_factor);\n      break;\n    }\n    case JCS_GRAYSCALE:\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"Colorspace: GRAYSCALE\");\n      (void) FormatLocaleString(sampling_factor,MagickPathExtent,\"%dx%d\",\n        jpeg_info->comp_info[0].h_samp_factor,\n        jpeg_info->comp_info[0].v_samp_factor);\n      break;\n    }\n    case JCS_RGB:\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Colorspace: RGB\");\n      (void) FormatLocaleString(sampling_factor,MagickPathExtent,\n        \"%dx%d,%dx%d,%dx%d\",jpeg_info->comp_info[0].h_samp_factor,\n        jpeg_info->comp_info[0].v_samp_factor,\n        jpeg_info->comp_info[1].h_samp_factor,\n        jpeg_info->comp_info[1].v_samp_factor,\n        jpeg_info->comp_info[2].h_samp_factor,\n        jpeg_info->comp_info[2].v_samp_factor);\n      break;\n    }\n    default:\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Colorspace: %d\",\n        jpeg_info->out_color_space);\n      (void) FormatLocaleString(sampling_factor,MagickPathExtent,\n        \"%dx%d,%dx%d,%dx%d,%dx%d\",jpeg_info->comp_info[0].h_samp_factor,\n        jpeg_info->comp_info[0].v_samp_factor,\n        jpeg_info->comp_info[1].h_samp_factor,\n        jpeg_info->comp_info[1].v_samp_factor,\n        jpeg_info->comp_info[2].h_samp_factor,\n        jpeg_info->comp_info[2].v_samp_factor,\n        jpeg_info->comp_info[3].h_samp_factor,\n        jpeg_info->comp_info[3].v_samp_factor);\n      break;\n    }\n  }\n  (void) SetImageProperty(image,\"jpeg:sampling-factor\",sampling_factor,\n    exception);\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Sampling Factors: %s\",\n    sampling_factor);\n}\n\nstatic Image *ReadJPEGImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    value[MagickPathExtent];\n\n  const char\n    *option;\n\n  ErrorManager\n    error_manager;\n\n  Image\n    *image;\n\n  JSAMPLE\n    *volatile jpeg_pixels;\n\n  JSAMPROW\n    scanline[1];\n\n  MagickBooleanType\n    debug,\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  MemoryInfo\n    *memory_info;\n\n  Quantum\n    index;\n\n  register ssize_t\n    i;\n\n  struct jpeg_decompress_struct\n    jpeg_info;\n\n  struct jpeg_error_mgr\n    jpeg_error;\n\n  register JSAMPLE\n    *p;\n\n  size_t\n    units;\n\n  ssize_t\n    y;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  debug=IsEventLogging();\n  (void) debug;\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Verify that file size large enough to contain a JPEG datastream.\n  */\n  if (GetBlobSize(image) < 107)\n    ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n  /*\n    Initialize JPEG parameters.\n  */\n  (void) ResetMagickMemory(&error_manager,0,sizeof(error_manager));\n  (void) ResetMagickMemory(&jpeg_info,0,sizeof(jpeg_info));\n  (void) ResetMagickMemory(&jpeg_error,0,sizeof(jpeg_error));\n  jpeg_info.err=jpeg_std_error(&jpeg_error);\n  jpeg_info.err->emit_message=(void (*)(j_common_ptr,int)) JPEGWarningHandler;\n  jpeg_info.err->error_exit=(void (*)(j_common_ptr)) JPEGErrorHandler;\n  memory_info=(MemoryInfo *) NULL;\n  error_manager.exception=exception;\n  error_manager.image=image;\n  if (setjmp(error_manager.error_recovery) != 0)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      if (error_manager.profile != (StringInfo *) NULL)\n        error_manager.profile=DestroyStringInfo(error_manager.profile);\n      (void) CloseBlob(image);\n      number_pixels=(MagickSizeType) image->columns*image->rows;\n      if (number_pixels != 0)\n        return(GetFirstImageInList(image));\n      return(DestroyImage(image));\n    }\n  jpeg_info.client_data=(void *) &error_manager;\n  jpeg_create_decompress(&jpeg_info);\n  JPEGSourceManager(&jpeg_info,image);\n  jpeg_set_marker_processor(&jpeg_info,JPEG_COM,ReadComment);\n  option=GetImageOption(image_info,\"profile:skip\");\n  if (IsOptionMember(\"ICC\",option) == MagickFalse)\n    jpeg_set_marker_processor(&jpeg_info,ICC_MARKER,ReadICCProfile);\n  if (IsOptionMember(\"IPTC\",option) == MagickFalse)\n    jpeg_set_marker_processor(&jpeg_info,IPTC_MARKER,ReadIPTCProfile);\n  for (i=1; i < 16; i++)\n    if ((i != 2) && (i != 13) && (i != 14))\n      if (IsOptionMember(\"APP\",option) == MagickFalse)\n        jpeg_set_marker_processor(&jpeg_info,(int) (JPEG_APP0+i),ReadProfile);\n  i=(ssize_t) jpeg_read_header(&jpeg_info,TRUE);\n  if ((image_info->colorspace == YCbCrColorspace) ||\n      (image_info->colorspace == Rec601YCbCrColorspace) ||\n      (image_info->colorspace == Rec709YCbCrColorspace))\n    jpeg_info.out_color_space=JCS_YCbCr;\n  /*\n    Set image resolution.\n  */\n  units=0;\n  if ((jpeg_info.saw_JFIF_marker != 0) && (jpeg_info.X_density != 1) &&\n      (jpeg_info.Y_density != 1))\n    {\n      image->resolution.x=(double) jpeg_info.X_density;\n      image->resolution.y=(double) jpeg_info.Y_density;\n      units=(size_t) jpeg_info.density_unit;\n    }\n  if (units == 1)\n    image->units=PixelsPerInchResolution;\n  if (units == 2)\n    image->units=PixelsPerCentimeterResolution;\n  number_pixels=(MagickSizeType) image->columns*image->rows;\n  option=GetImageOption(image_info,\"jpeg:size\");\n  if ((option != (const char *) NULL) &&\n      (jpeg_info.out_color_space != JCS_YCbCr))\n    {\n      double\n        scale_factor;\n\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      /*\n        Scale the image.\n      */\n      flags=ParseGeometry(option,&geometry_info);\n      if ((flags & SigmaValue) == 0)\n        geometry_info.sigma=geometry_info.rho;\n      jpeg_calc_output_dimensions(&jpeg_info);\n      image->magick_columns=jpeg_info.output_width;\n      image->magick_rows=jpeg_info.output_height;\n      scale_factor=1.0;\n      if (geometry_info.rho != 0.0)\n        scale_factor=jpeg_info.output_width/geometry_info.rho;\n      if ((geometry_info.sigma != 0.0) &&\n          (scale_factor > (jpeg_info.output_height/geometry_info.sigma)))\n        scale_factor=jpeg_info.output_height/geometry_info.sigma;\n      jpeg_info.scale_num=1U;\n      jpeg_info.scale_denom=(unsigned int) scale_factor;\n      jpeg_calc_output_dimensions(&jpeg_info);\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Scale factor: %.20g\",(double) scale_factor);\n    }\n#if (JPEG_LIB_VERSION >= 61) && defined(D_PROGRESSIVE_SUPPORTED)\n#if defined(D_LOSSLESS_SUPPORTED)\n  image->interlace=jpeg_info.process == JPROC_PROGRESSIVE ?\n    JPEGInterlace : NoInterlace;\n  image->compression=jpeg_info.process == JPROC_LOSSLESS ?\n    LosslessJPEGCompression : JPEGCompression;\n  if (jpeg_info.data_precision > 8)\n    (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n      \"12-bit JPEG not supported. Reducing pixel data to 8 bits\",\"`%s'\",\n      image->filename);\n  if (jpeg_info.data_precision == 16)\n    jpeg_info.data_precision=12;\n#else\n  image->interlace=jpeg_info.progressive_mode != 0 ? JPEGInterlace :\n    NoInterlace;\n  image->compression=JPEGCompression;\n#endif\n#else\n  image->compression=JPEGCompression;\n  image->interlace=JPEGInterlace;\n#endif\n  option=GetImageOption(image_info,\"jpeg:colors\");\n  if (option != (const char *) NULL)\n    {\n      /*\n        Let the JPEG library quantize the image.\n      */\n      jpeg_info.quantize_colors=TRUE;\n      jpeg_info.desired_number_of_colors=(int) StringToUnsignedLong(option);\n    }\n  option=GetImageOption(image_info,\"jpeg:block-smoothing\");\n  if (option != (const char *) NULL)\n    jpeg_info.do_block_smoothing=IsStringTrue(option) != MagickFalse ? TRUE :\n      FALSE;\n  jpeg_info.dct_method=JDCT_FLOAT;\n  option=GetImageOption(image_info,\"jpeg:dct-method\");\n  if (option != (const char *) NULL)\n    switch (*option)\n    {\n      case 'D':\n      case 'd':\n      {\n        if (LocaleCompare(option,\"default\") == 0)\n          jpeg_info.dct_method=JDCT_DEFAULT;\n        break;\n      }\n      case 'F':\n      case 'f':\n      {\n        if (LocaleCompare(option,\"fastest\") == 0)\n          jpeg_info.dct_method=JDCT_FASTEST;\n        if (LocaleCompare(option,\"float\") == 0)\n          jpeg_info.dct_method=JDCT_FLOAT;\n        break;\n      }\n      case 'I':\n      case 'i':\n      {\n        if (LocaleCompare(option,\"ifast\") == 0)\n          jpeg_info.dct_method=JDCT_IFAST;\n        if (LocaleCompare(option,\"islow\") == 0)\n          jpeg_info.dct_method=JDCT_ISLOW;\n        break;\n      }\n    }\n  option=GetImageOption(image_info,\"jpeg:fancy-upsampling\");\n  if (option != (const char *) NULL)\n    jpeg_info.do_fancy_upsampling=IsStringTrue(option) != MagickFalse ? TRUE :\n      FALSE;\n  (void) jpeg_start_decompress(&jpeg_info);\n  image->columns=jpeg_info.output_width;\n  image->rows=jpeg_info.output_height;\n  image->depth=(size_t) jpeg_info.data_precision;\n  switch (jpeg_info.out_color_space)\n  {\n    case JCS_RGB:\n    default:\n    {\n      (void) SetImageColorspace(image,sRGBColorspace,exception);\n      break;\n    }\n    case JCS_GRAYSCALE:\n    {\n      (void) SetImageColorspace(image,GRAYColorspace,exception);\n      break;\n    }\n    case JCS_YCbCr:\n    {\n      (void) SetImageColorspace(image,YCbCrColorspace,exception);\n      break;\n    }\n    case JCS_CMYK:\n    {\n      (void) SetImageColorspace(image,CMYKColorspace,exception);\n      break;\n    }\n  }\n  if (IsITUFaxImage(image) != MagickFalse)\n    {\n      (void) SetImageColorspace(image,LabColorspace,exception);\n      jpeg_info.out_color_space=JCS_YCbCr;\n    }\n  option=GetImageOption(image_info,\"jpeg:colors\");\n  if (option != (const char *) NULL)\n    if (AcquireImageColormap(image,StringToUnsignedLong(option),exception)\n         == MagickFalse)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  if ((jpeg_info.output_components == 1) && (jpeg_info.quantize_colors == 0))\n    {\n      size_t\n        colors;\n\n      colors=(size_t) GetQuantumRange(image->depth)+1;\n      if (AcquireImageColormap(image,colors,exception) == MagickFalse)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  if (image->debug != MagickFalse)\n    {\n      if (image->interlace != NoInterlace)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Interlace: progressive\");\n      else\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Interlace: nonprogressive\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Data precision: %d\",\n        (int) jpeg_info.data_precision);\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Geometry: %dx%d\",\n        (int) jpeg_info.output_width,(int) jpeg_info.output_height);\n    }\n  JPEGSetImageQuality(&jpeg_info,image);\n  JPEGSetImageSamplingFactor(&jpeg_info,image,exception);\n  (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n    jpeg_info.out_color_space);\n  (void) SetImageProperty(image,\"jpeg:colorspace\",value,exception);\n  if (image_info->ping != MagickFalse)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      return(DestroyImageList(image));\n    }\n  if ((jpeg_info.output_components != 1) &&\n      (jpeg_info.output_components != 3) && (jpeg_info.output_components != 4))\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      ThrowReaderException(CorruptImageError,\"ImageTypeNotSupported\");\n    }\n  memory_info=AcquireVirtualMemory((size_t) image->columns,\n    jpeg_info.output_components*sizeof(*jpeg_pixels));\n  if (memory_info == (MemoryInfo *) NULL)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  jpeg_pixels=(JSAMPLE *) GetVirtualMemoryBlob(memory_info);\n  (void) ResetMagickMemory(jpeg_pixels,0,image->columns*\n    jpeg_info.output_components*sizeof(*jpeg_pixels));\n  /*\n    Convert JPEG pixels to pixel packets.\n  */\n  if (setjmp(error_manager.error_recovery) != 0)\n    {\n      if (memory_info != (MemoryInfo *) NULL)\n        memory_info=RelinquishVirtualMemory(memory_info);\n      jpeg_destroy_decompress(&jpeg_info);\n      (void) CloseBlob(image);\n      number_pixels=(MagickSizeType) image->columns*image->rows;\n      if (number_pixels != 0)\n        return(GetFirstImageInList(image));\n      return(DestroyImage(image));\n    }\n  if (jpeg_info.quantize_colors != 0)\n    {\n      image->colors=(size_t) jpeg_info.actual_number_of_colors;\n      if (jpeg_info.out_color_space == JCS_GRAYSCALE)\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].red=(double) ScaleCharToQuantum(\n            jpeg_info.colormap[0][i]);\n          image->colormap[i].green=image->colormap[i].red;\n          image->colormap[i].blue=image->colormap[i].red;\n          image->colormap[i].alpha=(MagickRealType) OpaqueAlpha;\n        }\n      else\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].red=(double) ScaleCharToQuantum(\n            jpeg_info.colormap[0][i]);\n          image->colormap[i].green=(double) ScaleCharToQuantum(\n            jpeg_info.colormap[1][i]);\n          image->colormap[i].blue=(double) ScaleCharToQuantum(\n            jpeg_info.colormap[2][i]);\n          image->colormap[i].alpha=(MagickRealType) OpaqueAlpha;\n        }\n    }\n  scanline[0]=(JSAMPROW) jpeg_pixels;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register ssize_t\n      x;\n\n    register Quantum\n      *magick_restrict q;\n\n    if (jpeg_read_scanlines(&jpeg_info,scanline,1) != 1)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CorruptImageWarning,\"SkipToSyncByte\",\"`%s'\",image->filename);\n        continue;\n      }\n    p=jpeg_pixels;\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    if (jpeg_info.data_precision > 8)\n      {\n        unsigned short\n          scale;\n\n        scale=65535/(unsigned short) GetQuantumRange((size_t)\n          jpeg_info.data_precision);\n        if (jpeg_info.output_components == 1)\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            ssize_t\n              pixel;\n\n            pixel=(ssize_t) (scale*GETJSAMPLE(*p));\n            index=(Quantum) ConstrainColormapIndex(image,pixel,exception);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            p++;\n            q+=GetPixelChannels(image);\n          }\n        else\n          if (image->colorspace != CMYKColorspace)\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelRed(image,ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))),q);\n              SetPixelGreen(image,ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))),q);\n              SetPixelBlue(image,ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))),q);\n              SetPixelAlpha(image,OpaqueAlpha,q);\n              q+=GetPixelChannels(image);\n            }\n          else\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelCyan(image,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))),q);\n              SetPixelMagenta(image,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))),q);\n              SetPixelYellow(image,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))),q);\n              SetPixelBlack(image,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))),q);\n              SetPixelAlpha(image,OpaqueAlpha,q);\n              q+=GetPixelChannels(image);\n            }\n      }\n    else\n      if (jpeg_info.output_components == 1)\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          index=(Quantum) ConstrainColormapIndex(image,(ssize_t) GETJSAMPLE(*p),\n            exception);\n          SetPixelIndex(image,index,q);\n          SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n          p++;\n          q+=GetPixelChannels(image);\n        }\n      else\n        if (image->colorspace != CMYKColorspace)\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)),q);\n            SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)),q);\n            SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)),q);\n            SetPixelAlpha(image,OpaqueAlpha,q);\n            q+=GetPixelChannels(image);\n          }\n        else\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelCyan(image,QuantumRange-ScaleCharToQuantum(\n              (unsigned char) GETJSAMPLE(*p++)),q);\n            SetPixelMagenta(image,QuantumRange-ScaleCharToQuantum(\n              (unsigned char) GETJSAMPLE(*p++)),q);\n            SetPixelYellow(image,QuantumRange-ScaleCharToQuantum(\n              (unsigned char) GETJSAMPLE(*p++)),q);\n            SetPixelBlack(image,QuantumRange-ScaleCharToQuantum(\n              (unsigned char) GETJSAMPLE(*p++)),q);\n            SetPixelAlpha(image,OpaqueAlpha,q);\n            q+=GetPixelChannels(image);\n          }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      {\n        jpeg_abort_decompress(&jpeg_info);\n        break;\n      }\n  }\n  if (status != MagickFalse)\n    {\n      error_manager.finished=MagickTrue;\n      if (setjmp(error_manager.error_recovery) == 0)\n        (void) jpeg_finish_decompress(&jpeg_info);\n    }\n  /*\n    Free jpeg resources.\n  */\n  jpeg_destroy_decompress(&jpeg_info);\n  memory_info=RelinquishVirtualMemory(memory_info);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r J P E G I m a g e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterJPEGImage() adds properties for the JPEG image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterJPEGImage method is:\n%\n%      size_t RegisterJPEGImage(void)\n%\n*/\nModuleExport size_t RegisterJPEGImage(void)\n{\n#define JPEGDescription \"Joint Photographic Experts Group JFIF format\"\n\n  char\n    version[MagickPathExtent];\n\n  MagickInfo\n    *entry;\n\n  *version='\\0';\n#if defined(JPEG_LIB_VERSION)\n  (void) FormatLocaleString(version,MagickPathExtent,\"%d\",JPEG_LIB_VERSION);\n#endif\n  entry=AcquireMagickInfo(\"JPEG\",\"JPE\",JPEGDescription);\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->flags^=CoderDecoderThreadSupportFlag;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n#endif\n  entry->magick=(IsImageFormatHandler *) IsJPEG;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"JPEG\",\"JPEG\",JPEGDescription);\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->flags^=CoderDecoderThreadSupportFlag;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n#endif\n  entry->magick=(IsImageFormatHandler *) IsJPEG;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"JPEG\",\"JPG\",JPEGDescription);\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->flags^=CoderDecoderThreadSupportFlag;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n#endif\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"JPEG\",\"JPS\",JPEGDescription);\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->flags^=CoderDecoderThreadSupportFlag;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n#endif\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"JPEG\",\"PJPEG\",JPEGDescription);\n#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)\n  entry->flags^=CoderDecoderThreadSupportFlag;\n#endif\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;\n  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n#endif\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderUseExtensionFlag;\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->mime_type=ConstantString(\"image/jpeg\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r J P E G I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterJPEGImage() removes format registrations made by the\n%  JPEG module from the list of supported formats.\n%\n%  The format of the UnregisterJPEGImage method is:\n%\n%      UnregisterJPEGImage(void)\n%\n*/\nModuleExport void UnregisterJPEGImage(void)\n{\n  (void) UnregisterMagickInfo(\"PJPG\");\n  (void) UnregisterMagickInfo(\"JPS\");\n  (void) UnregisterMagickInfo(\"JPG\");\n  (void) UnregisterMagickInfo(\"JPEG\");\n  (void) UnregisterMagickInfo(\"JPE\");\n}\n\f\n#if defined(MAGICKCORE_JPEG_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  W r i t e J P E G I m a g e                                                %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteJPEGImage() writes a JPEG image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the WriteJPEGImage method is:\n%\n%      MagickBooleanType WriteJPEGImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o jpeg_image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic QuantizationTable *DestroyQuantizationTable(QuantizationTable *table)\n{\n  assert(table != (QuantizationTable *) NULL);\n  if (table->slot != (char *) NULL)\n    table->slot=DestroyString(table->slot);\n  if (table->description != (char *) NULL)\n    table->description=DestroyString(table->description);\n  if (table->levels != (unsigned int *) NULL)\n    table->levels=(unsigned int *) RelinquishMagickMemory(table->levels);\n  table=(QuantizationTable *) RelinquishMagickMemory(table);\n  return(table);\n}\n\nstatic boolean EmptyOutputBuffer(j_compress_ptr cinfo)\n{\n  DestinationManager\n    *destination;\n\n  destination=(DestinationManager *) cinfo->dest;\n  destination->manager.free_in_buffer=(size_t) WriteBlob(destination->image,\n    MaxBufferExtent,destination->buffer);\n  if (destination->manager.free_in_buffer != MaxBufferExtent)\n    ERREXIT(cinfo,JERR_FILE_WRITE);\n  destination->manager.next_output_byte=destination->buffer;\n  return(TRUE);\n}\n\nstatic QuantizationTable *GetQuantizationTable(const char *filename,\n  const char *slot,ExceptionInfo *exception)\n{\n  char\n    *p,\n    *xml;\n\n  const char\n    *attribute,\n    *content;\n\n  double\n    value;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    j;\n\n  QuantizationTable\n    *table;\n\n  size_t\n    length;\n\n  XMLTreeInfo\n    *description,\n    *levels,\n    *quantization_tables,\n    *table_iterator;\n\n  (void) LogMagickEvent(ConfigureEvent,GetMagickModule(),\n    \"Loading quantization tables \\\"%s\\\" ...\",filename);\n  table=(QuantizationTable *) NULL;\n  xml=FileToString(filename,~0UL,exception);\n  if (xml == (char *) NULL)\n    return(table);\n  quantization_tables=NewXMLTree(xml,exception);\n  if (quantization_tables == (XMLTreeInfo *) NULL)\n    {\n      xml=DestroyString(xml);\n      return(table);\n    }\n  for (table_iterator=GetXMLTreeChild(quantization_tables,\"table\");\n       table_iterator != (XMLTreeInfo *) NULL;\n       table_iterator=GetNextXMLTreeTag(table_iterator))\n  {\n    attribute=GetXMLTreeAttribute(table_iterator,\"slot\");\n    if ((attribute != (char *) NULL) && (LocaleCompare(slot,attribute) == 0))\n      break;\n    attribute=GetXMLTreeAttribute(table_iterator,\"alias\");\n    if ((attribute != (char *) NULL) && (LocaleCompare(slot,attribute) == 0))\n      break;\n  }\n  if (table_iterator == (XMLTreeInfo *) NULL)\n    {\n      xml=DestroyString(xml);\n      return(table);\n    }\n  description=GetXMLTreeChild(table_iterator,\"description\");\n  if (description == (XMLTreeInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingElement\",\"<description>, slot \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  levels=GetXMLTreeChild(table_iterator,\"levels\");\n  if (levels == (XMLTreeInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingElement\",\"<levels>, slot \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));\n  if (table == (QuantizationTable *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\n      \"UnableToAcquireQuantizationTable\");\n  table->slot=(char *) NULL;\n  table->description=(char *) NULL;\n  table->levels=(unsigned int *) NULL;\n  attribute=GetXMLTreeAttribute(table_iterator,\"slot\");\n  if (attribute != (char *) NULL)\n    table->slot=ConstantString(attribute);\n  content=GetXMLTreeContent(description);\n  if (content != (char *) NULL)\n    table->description=ConstantString(content);\n  attribute=GetXMLTreeAttribute(levels,\"width\");\n  if (attribute == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingAttribute\",\"<levels width>, slot \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  table->width=StringToUnsignedLong(attribute);\n  if (table->width == 0)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n       \"XmlInvalidAttribute\",\"<levels width>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  attribute=GetXMLTreeAttribute(levels,\"height\");\n  if (attribute == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingAttribute\",\"<levels height>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  table->height=StringToUnsignedLong(attribute);\n  if (table->height == 0)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlInvalidAttribute\",\"<levels height>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  attribute=GetXMLTreeAttribute(levels,\"divisor\");\n  if (attribute == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingAttribute\",\"<levels divisor>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  table->divisor=InterpretLocaleValue(attribute,(char **) NULL);\n  if (table->divisor == 0.0)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlInvalidAttribute\",\"<levels divisor>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  content=GetXMLTreeContent(levels);\n  if (content == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingContent\",\"<levels>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  length=(size_t) table->width*table->height;\n  if (length < 64)\n    length=64;\n  table->levels=(unsigned int *) AcquireQuantumMemory(length,\n    sizeof(*table->levels));\n  if (table->levels == (unsigned int *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\n      \"UnableToAcquireQuantizationTable\");\n  for (i=0; i < (ssize_t) (table->width*table->height); i++)\n  {\n    table->levels[i]=(unsigned int) (InterpretLocaleValue(content,&p)/\n      table->divisor+0.5);\n    while (isspace((int) ((unsigned char) *p)) != 0)\n      p++;\n    if (*p == ',')\n      p++;\n    content=p;\n  }\n  value=InterpretLocaleValue(content,&p);\n  (void) value;\n  if (p != content)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlInvalidContent\",\"<level> too many values, table \\\"%s\\\"\",slot);\n     quantization_tables=DestroyXMLTree(quantization_tables);\n     table=DestroyQuantizationTable(table);\n     xml=DestroyString(xml);\n     return(table);\n   }\n  for (j=i; j < 64; j++)\n    table->levels[j]=table->levels[j-1];\n  quantization_tables=DestroyXMLTree(quantization_tables);\n  xml=DestroyString(xml);\n  return(table);\n}\n\nstatic void InitializeDestination(j_compress_ptr cinfo)\n{\n  DestinationManager\n    *destination;\n\n  destination=(DestinationManager *) cinfo->dest;\n  destination->buffer=(JOCTET *) (*cinfo->mem->alloc_small)\n    ((j_common_ptr) cinfo,JPOOL_IMAGE,MaxBufferExtent*sizeof(JOCTET));\n  destination->manager.next_output_byte=destination->buffer;\n  destination->manager.free_in_buffer=MaxBufferExtent;\n}\n\nstatic void TerminateDestination(j_compress_ptr cinfo)\n{\n  DestinationManager\n    *destination;\n\n  destination=(DestinationManager *) cinfo->dest;\n  if ((MaxBufferExtent-(int) destination->manager.free_in_buffer) > 0)\n    {\n      ssize_t\n        count;\n\n      count=WriteBlob(destination->image,MaxBufferExtent-\n        destination->manager.free_in_buffer,destination->buffer);\n      if (count != (ssize_t)\n          (MaxBufferExtent-destination->manager.free_in_buffer))\n        ERREXIT(cinfo,JERR_FILE_WRITE);\n    }\n}\n\nstatic void WriteProfile(j_compress_ptr jpeg_info,Image *image,\n  ExceptionInfo *exception)\n{\n  const char\n    *name;\n\n  const StringInfo\n    *profile;\n\n  MagickBooleanType\n    iptc;\n\n  register ssize_t\n    i;\n\n  size_t\n    length,\n    tag_length;\n\n  StringInfo\n    *custom_profile;\n\n  /*\n    Save image profile as a APP marker.\n  */\n  iptc=MagickFalse;\n  custom_profile=AcquireStringInfo(65535L);\n  ResetImageProfileIterator(image);\n  for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n  {\n    profile=GetImageProfile(image,name);\n    if (LocaleCompare(name,\"EXIF\") == 0)\n      {\n        length=GetStringInfoLength(profile);\n        if (length > 65533L)\n          {\n            (void) ThrowMagickException(exception,GetMagickModule(),\n              CoderWarning,\"ExifProfileSizeExceedsLimit\",\"`%s'\",\n              image->filename);\n            length=65533L;\n          }\n        jpeg_write_marker(jpeg_info,XML_MARKER,GetStringInfoDatum(profile),\n          (unsigned int) length);\n      }\n    if (LocaleCompare(name,\"ICC\") == 0)\n      {\n        register unsigned char\n          *p;\n\n        tag_length=strlen(ICC_PROFILE);\n        p=GetStringInfoDatum(custom_profile);\n        (void) CopyMagickMemory(p,ICC_PROFILE,tag_length);\n        p[tag_length]='\\0';\n        for (i=0; i < (ssize_t) GetStringInfoLength(profile); i+=65519L)\n        {\n          length=MagickMin(GetStringInfoLength(profile)-i,65519L);\n          p[12]=(unsigned char) ((i/65519L)+1);\n          p[13]=(unsigned char) (GetStringInfoLength(profile)/65519L+1);\n          (void) CopyMagickMemory(p+tag_length+3,GetStringInfoDatum(profile)+i,\n            length);\n          jpeg_write_marker(jpeg_info,ICC_MARKER,GetStringInfoDatum(\n            custom_profile),(unsigned int) (length+tag_length+3));\n        }\n      }\n    if (((LocaleCompare(name,\"IPTC\") == 0) ||\n        (LocaleCompare(name,\"8BIM\") == 0)) && (iptc == MagickFalse))\n      {\n        register unsigned char\n          *p;\n\n        size_t\n          roundup;\n\n        iptc=MagickTrue;\n        p=GetStringInfoDatum(custom_profile);\n        for (i=0; i < (ssize_t) GetStringInfoLength(profile); i+=65500L)\n        {\n          length=MagickMin(GetStringInfoLength(profile)-i,65500L);\n          roundup=(size_t) (length & 0x01);\n          if (LocaleNCompare((char *) GetStringInfoDatum(profile),\"8BIM\",4) == 0)\n            {\n              (void) memcpy(p,\"Photoshop 3.0 \",14);\n              tag_length=14;\n            }\n          else\n            {\n              (void) CopyMagickMemory(p,\"Photoshop 3.0 8BIM\\04\\04\\0\\0\\0\\0\",24);\n              tag_length=26;\n              p[24]=(unsigned char) (length >> 8);\n              p[25]=(unsigned char) (length & 0xff);\n            }\n          p[13]=0x00;\n          (void) memcpy(p+tag_length,GetStringInfoDatum(profile)+i,length);\n          if (roundup != 0)\n            p[length+tag_length]='\\0';\n          jpeg_write_marker(jpeg_info,IPTC_MARKER,GetStringInfoDatum(\n            custom_profile),(unsigned int) (length+tag_length+roundup));\n        }\n      }\n    if (LocaleCompare(name,\"XMP\") == 0)\n      {\n        StringInfo\n          *xmp_profile;\n\n        /*\n          Add namespace to XMP profile.\n        */\n        xmp_profile=StringToStringInfo(\"http://ns.adobe.com/xap/1.0/ \");\n        if (xmp_profile != (StringInfo *) NULL)\n          {\n            if (profile != (StringInfo *) NULL)\n              ConcatenateStringInfo(xmp_profile,profile);\n            GetStringInfoDatum(xmp_profile)[28]='\\0';\n            for (i=0; i < (ssize_t) GetStringInfoLength(xmp_profile); i+=65533L)\n            {\n              length=MagickMin(GetStringInfoLength(xmp_profile)-i,65533L);\n              jpeg_write_marker(jpeg_info,XML_MARKER,\n                GetStringInfoDatum(xmp_profile)+i,(unsigned int) length);\n            }\n            xmp_profile=DestroyStringInfo(xmp_profile);\n          }\n      }\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"%s profile: %.20g bytes\",name,(double) GetStringInfoLength(profile));\n    name=GetNextImageProfile(image);\n  }\n  custom_profile=DestroyStringInfo(custom_profile);\n}\n\nstatic void JPEGDestinationManager(j_compress_ptr cinfo,Image * image)\n{\n  DestinationManager\n    *destination;\n\n  cinfo->dest=(struct jpeg_destination_mgr *) (*cinfo->mem->alloc_small)\n    ((j_common_ptr) cinfo,JPOOL_IMAGE,sizeof(DestinationManager));\n  destination=(DestinationManager *) cinfo->dest;\n  destination->manager.init_destination=InitializeDestination;\n  destination->manager.empty_output_buffer=EmptyOutputBuffer;\n  destination->manager.term_destination=TerminateDestination;\n  destination->image=image;\n}\n\nstatic char **SamplingFactorToList(const char *text)\n{\n  char\n    **textlist;\n\n  register char\n    *q;\n\n  register const char\n    *p;\n\n  register ssize_t\n    i;\n\n  if (text == (char *) NULL)\n    return((char **) NULL);\n  /*\n    Convert string to an ASCII list.\n  */\n  textlist=(char **) AcquireQuantumMemory((size_t) MAX_COMPONENTS,\n    sizeof(*textlist));\n  if (textlist == (char **) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"UnableToConvertText\");\n  p=text;\n  for (i=0; i < (ssize_t) MAX_COMPONENTS; i++)\n  {\n    for (q=(char *) p; *q != '\\0'; q++)\n      if (*q == ',')\n        break;\n    textlist[i]=(char *) AcquireQuantumMemory((size_t) (q-p)+MagickPathExtent,\n      sizeof(*textlist[i]));\n    if (textlist[i] == (char *) NULL)\n      ThrowFatalException(ResourceLimitFatalError,\"UnableToConvertText\");\n    (void) CopyMagickString(textlist[i],p,(size_t) (q-p+1));\n    if (*q == '\\r')\n      q++;\n    if (*q == '\\0')\n      break;\n    p=q+1;\n  }\n  for (i++; i < (ssize_t) MAX_COMPONENTS; i++)\n    textlist[i]=ConstantString(\"1x1\");\n  return(textlist);\n}\n\nstatic MagickBooleanType WriteJPEGImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  const char\n    *option,\n    *sampling_factor,\n    *value;\n\n  ErrorManager\n    error_manager;\n\n  Image\n    *volatile volatile_image;\n\n  int\n    colorspace,\n    quality;\n\n  JSAMPLE\n    *volatile jpeg_pixels;\n\n  JSAMPROW\n    scanline[1];\n\n  MagickBooleanType\n    status;\n\n  MemoryInfo\n    *memory_info;\n\n  register JSAMPLE\n    *q;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    y;\n\n  struct jpeg_compress_struct\n    jpeg_info;\n\n  struct jpeg_error_mgr\n    jpeg_error;\n\n  unsigned short\n    scale;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if ((LocaleCompare(image_info->magick,\"JPS\") == 0) &&\n      (image->next != (Image *) NULL))\n    image=AppendImages(image,MagickFalse,exception);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  /*\n    Initialize JPEG parameters.\n  */\n  (void) ResetMagickMemory(&error_manager,0,sizeof(error_manager));\n  (void) ResetMagickMemory(&jpeg_info,0,sizeof(jpeg_info));\n  (void) ResetMagickMemory(&jpeg_error,0,sizeof(jpeg_error));\n  volatile_image=image;\n  jpeg_info.client_data=(void *) volatile_image;\n  jpeg_info.err=jpeg_std_error(&jpeg_error);\n  jpeg_info.err->emit_message=(void (*)(j_common_ptr,int)) JPEGWarningHandler;\n  jpeg_info.err->error_exit=(void (*)(j_common_ptr)) JPEGErrorHandler;\n  error_manager.exception=exception;\n  error_manager.image=volatile_image;\n  memory_info=(MemoryInfo *) NULL;\n  if (setjmp(error_manager.error_recovery) != 0)\n    {\n      jpeg_destroy_compress(&jpeg_info);\n      (void) CloseBlob(volatile_image);\n      return(MagickFalse);\n    }\n  jpeg_info.client_data=(void *) &error_manager;\n  jpeg_create_compress(&jpeg_info);\n  JPEGDestinationManager(&jpeg_info,image);\n  if ((image->columns != (unsigned int) image->columns) ||\n      (image->rows != (unsigned int) image->rows))\n    ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n  jpeg_info.image_width=(unsigned int) image->columns;\n  jpeg_info.image_height=(unsigned int) image->rows;\n  jpeg_info.input_components=3;\n  jpeg_info.data_precision=8;\n  jpeg_info.in_color_space=JCS_RGB;\n  switch (image->colorspace)\n  {\n    case CMYKColorspace:\n    {\n      jpeg_info.input_components=4;\n      jpeg_info.in_color_space=JCS_CMYK;\n      break;\n    }\n    case YCbCrColorspace:\n    case Rec601YCbCrColorspace:\n    case Rec709YCbCrColorspace:\n    {\n      jpeg_info.in_color_space=JCS_YCbCr;\n      break;\n    }\n    case GRAYColorspace:\n    {\n      if (image_info->type == TrueColorType)\n        break;\n      jpeg_info.input_components=1;\n      jpeg_info.in_color_space=JCS_GRAYSCALE;\n      break;\n    }\n    default:\n    {\n      (void) TransformImageColorspace(image,sRGBColorspace,exception);\n      if (image_info->type == TrueColorType)\n        break;\n      if (SetImageGray(image,exception) != MagickFalse)\n        {\n          jpeg_info.input_components=1;\n          jpeg_info.in_color_space=JCS_GRAYSCALE;\n        }\n      break;\n    }\n  }\n  jpeg_set_defaults(&jpeg_info);\n  if (jpeg_info.in_color_space == JCS_CMYK)\n    jpeg_set_colorspace(&jpeg_info,JCS_YCCK);\n  if ((jpeg_info.data_precision != 12) && (image->depth <= 8))\n    jpeg_info.data_precision=8;\n  else\n    jpeg_info.data_precision=BITS_IN_JSAMPLE;\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"Image resolution: %.20g,%.20g\",image->resolution.x,image->resolution.y);\n  if ((image->resolution.x != 0.0) && (image->resolution.y != 0.0))\n    {\n      /*\n        Set image resolution.\n      */\n      jpeg_info.write_JFIF_header=TRUE;\n      jpeg_info.X_density=(UINT16) image->resolution.x;\n      jpeg_info.Y_density=(UINT16) image->resolution.y;\n      /*\n        Set image resolution units.\n      */\n      if (image->units == PixelsPerInchResolution)\n        jpeg_info.density_unit=(UINT8) 1;\n      if (image->units == PixelsPerCentimeterResolution)\n        jpeg_info.density_unit=(UINT8) 2;\n    }\n  jpeg_info.dct_method=JDCT_FLOAT;\n  option=GetImageOption(image_info,\"jpeg:dct-method\");\n  if (option != (const char *) NULL)\n    switch (*option)\n    {\n      case 'D':\n      case 'd':\n      {\n        if (LocaleCompare(option,\"default\") == 0)\n          jpeg_info.dct_method=JDCT_DEFAULT;\n        break;\n      }\n      case 'F':\n      case 'f':\n      {\n        if (LocaleCompare(option,\"fastest\") == 0)\n          jpeg_info.dct_method=JDCT_FASTEST;\n        if (LocaleCompare(option,\"float\") == 0)\n          jpeg_info.dct_method=JDCT_FLOAT;\n        break;\n      }\n      case 'I':\n      case 'i':\n      {\n        if (LocaleCompare(option,\"ifast\") == 0)\n          jpeg_info.dct_method=JDCT_IFAST;\n        if (LocaleCompare(option,\"islow\") == 0)\n          jpeg_info.dct_method=JDCT_ISLOW;\n        break;\n      }\n    }\n  option=GetImageOption(image_info,\"jpeg:optimize-coding\");\n  if (option != (const char *) NULL)\n    jpeg_info.optimize_coding=IsStringTrue(option) != MagickFalse ? TRUE :\n      FALSE;\n  else\n    {\n      MagickSizeType\n        length;\n\n      length=(MagickSizeType) jpeg_info.input_components*image->columns*\n        image->rows*sizeof(JSAMPLE);\n      if (length == (MagickSizeType) ((size_t) length))\n        {\n          /*\n            Perform optimization only if available memory resources permit it.\n          */\n          status=AcquireMagickResource(MemoryResource,length);\n          RelinquishMagickResource(MemoryResource,length);\n          jpeg_info.optimize_coding=status == MagickFalse ? FALSE : TRUE;\n        }\n    }\n#if (JPEG_LIB_VERSION >= 61) && defined(C_PROGRESSIVE_SUPPORTED)\n  if ((LocaleCompare(image_info->magick,\"PJPEG\") == 0) ||\n      (image_info->interlace != NoInterlace))\n    {\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Interlace: progressive\");\n      jpeg_simple_progression(&jpeg_info);\n    }\n  else\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"Interlace: non-progressive\");\n#else\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"Interlace: nonprogressive\");\n#endif\n  quality=92;\n  if ((image_info->compression != LosslessJPEGCompression) &&\n      (image->quality <= 100))\n    {\n      if (image->quality != UndefinedCompressionQuality)\n        quality=(int) image->quality;\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Quality: %.20g\",\n          (double) image->quality);\n    }\n  else\n    {\n#if !defined(C_LOSSLESS_SUPPORTED)\n      quality=100;\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Quality: 100\");\n#else\n      if (image->quality < 100)\n        (void) ThrowMagickException(exception,GetMagickModule(),CoderWarning,\n          \"LosslessToLossyJPEGConversion\",\"`%s'\",image->filename);\n      else\n        {\n          int\n            point_transform,\n            predictor;\n\n          predictor=image->quality/100;  /* range 1-7 */\n          point_transform=image->quality % 20;  /* range 0-15 */\n          jpeg_simple_lossless(&jpeg_info,predictor,point_transform);\n          if (image->debug != MagickFalse)\n            {\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"Compression: lossless\");\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"Predictor: %d\",predictor);\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"Point Transform: %d\",point_transform);\n            }\n        }\n#endif\n    }\n  option=GetImageOption(image_info,\"jpeg:extent\");\n  if (option != (const char *) NULL)\n    {\n      Image\n        *jpeg_image;\n\n      ImageInfo\n        *extent_info;\n\n      extent_info=CloneImageInfo(image_info);\n      extent_info->blob=NULL;\n      jpeg_image=CloneImage(image,0,0,MagickTrue,exception);\n      if (jpeg_image != (Image *) NULL)\n        {\n          MagickSizeType\n            extent;\n\n          size_t\n            maximum,\n            minimum;\n\n          /*\n            Search for compression quality that does not exceed image extent.\n          */\n          extent_info->quality=0;\n          extent=(MagickSizeType) SiPrefixToDoubleInterval(option,100.0);\n          (void) DeleteImageOption(extent_info,\"jpeg:extent\");\n          (void) DeleteImageArtifact(jpeg_image,\"jpeg:extent\");\n          maximum=image_info->quality;\n          if (maximum < 2)\n            maximum=101;\n          for (minimum=2; minimum < maximum; )\n          {\n            (void) AcquireUniqueFilename(jpeg_image->filename);\n            jpeg_image->quality=minimum+(maximum-minimum+1)/2;\n            status=WriteJPEGImage(extent_info,jpeg_image,exception);\n            if (GetBlobSize(jpeg_image) <= extent)\n              minimum=jpeg_image->quality+1;\n            else\n              maximum=jpeg_image->quality-1;\n            (void) RelinquishUniqueFileResource(jpeg_image->filename);\n          }\n          quality=(int) minimum-1;\n          jpeg_image=DestroyImage(jpeg_image);\n        }\n      extent_info=DestroyImageInfo(extent_info);\n    }\n  jpeg_set_quality(&jpeg_info,quality,TRUE);\n#if (JPEG_LIB_VERSION >= 70)\n  option=GetImageOption(image_info,\"quality\");\n  if (option != (const char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      int\n        flags;\n\n      /*\n        Set quality scaling for luminance and chrominance separately.\n      */\n      flags=ParseGeometry(option,&geometry_info);\n      if (((flags & RhoValue) != 0) && ((flags & SigmaValue) != 0))\n        {\n          jpeg_info.q_scale_factor[0]=jpeg_quality_scaling((int)\n            (geometry_info.rho+0.5));\n          jpeg_info.q_scale_factor[1]=jpeg_quality_scaling((int)\n            (geometry_info.sigma+0.5));\n          jpeg_default_qtables(&jpeg_info,TRUE);\n        }\n    }\n#endif\n  colorspace=jpeg_info.in_color_space;\n  value=GetImageOption(image_info,\"jpeg:colorspace\");\n  if (value == (char *) NULL)\n    value=GetImageProperty(image,\"jpeg:colorspace\",exception);\n  if (value != (char *) NULL)\n    colorspace=StringToInteger(value);\n  sampling_factor=(const char *) NULL;\n  if (colorspace == jpeg_info.in_color_space)\n    {\n      value=GetImageOption(image_info,\"jpeg:sampling-factor\");\n      if (value == (char *) NULL)\n        value=GetImageProperty(image,\"jpeg:sampling-factor\",exception);\n      if (value != (char *) NULL)\n        {\n          sampling_factor=value;\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Input sampling-factors=%s\",sampling_factor);\n        }\n    }\n  value=GetImageOption(image_info,\"jpeg:sampling-factor\");\n  if (image_info->sampling_factor != (char *) NULL)\n    sampling_factor=image_info->sampling_factor;\n  if (sampling_factor == (const char *) NULL)\n    {\n      if (quality >= 90)\n        for (i=0; i < MAX_COMPONENTS; i++)\n        {\n          jpeg_info.comp_info[i].h_samp_factor=1;\n          jpeg_info.comp_info[i].v_samp_factor=1;\n        }\n    }\n  else\n    {\n      char\n        **factors;\n\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      /*\n        Set sampling factor.\n      */\n      i=0;\n      factors=SamplingFactorToList(sampling_factor);\n      if (factors != (char **) NULL)\n        {\n          for (i=0; i < MAX_COMPONENTS; i++)\n          {\n            if (factors[i] == (char *) NULL)\n              break;\n            flags=ParseGeometry(factors[i],&geometry_info);\n            if ((flags & SigmaValue) == 0)\n              geometry_info.sigma=geometry_info.rho;\n            jpeg_info.comp_info[i].h_samp_factor=(int) geometry_info.rho;\n            jpeg_info.comp_info[i].v_samp_factor=(int) geometry_info.sigma;\n            factors[i]=(char *) RelinquishMagickMemory(factors[i]);\n          }\n          factors=(char **) RelinquishMagickMemory(factors);\n        }\n      for ( ; i < MAX_COMPONENTS; i++)\n      {\n        jpeg_info.comp_info[i].h_samp_factor=1;\n        jpeg_info.comp_info[i].v_samp_factor=1;\n      }\n    }\n  option=GetImageOption(image_info,\"jpeg:q-table\");\n  if (option != (const char *) NULL)\n    {\n      QuantizationTable\n        *table;\n\n      /*\n        Custom quantization tables.\n      */\n      table=GetQuantizationTable(option,\"0\",exception);\n      if (table != (QuantizationTable *) NULL)\n        {\n          for (i=0; i < MAX_COMPONENTS; i++)\n            jpeg_info.comp_info[i].quant_tbl_no=0;\n          jpeg_add_quant_table(&jpeg_info,0,table->levels,\n            jpeg_quality_scaling(quality),0);\n          table=DestroyQuantizationTable(table);\n        }\n      table=GetQuantizationTable(option,\"1\",exception);\n      if (table != (QuantizationTable *) NULL)\n        {\n          for (i=1; i < MAX_COMPONENTS; i++)\n            jpeg_info.comp_info[i].quant_tbl_no=1;\n          jpeg_add_quant_table(&jpeg_info,1,table->levels,\n            jpeg_quality_scaling(quality),0);\n          table=DestroyQuantizationTable(table);\n        }\n      table=GetQuantizationTable(option,\"2\",exception);\n      if (table != (QuantizationTable *) NULL)\n        {\n          for (i=2; i < MAX_COMPONENTS; i++)\n            jpeg_info.comp_info[i].quant_tbl_no=2;\n          jpeg_add_quant_table(&jpeg_info,2,table->levels,\n            jpeg_quality_scaling(quality),0);\n          table=DestroyQuantizationTable(table);\n        }\n      table=GetQuantizationTable(option,\"3\",exception);\n      if (table != (QuantizationTable *) NULL)\n        {\n          for (i=3; i < MAX_COMPONENTS; i++)\n            jpeg_info.comp_info[i].quant_tbl_no=3;\n          jpeg_add_quant_table(&jpeg_info,3,table->levels,\n            jpeg_quality_scaling(quality),0);\n          table=DestroyQuantizationTable(table);\n        }\n    }\n  jpeg_start_compress(&jpeg_info,TRUE);\n  if (image->debug != MagickFalse)\n    {\n      if (image->storage_class == PseudoClass)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Storage class: PseudoClass\");\n      else\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Storage class: DirectClass\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Depth: %.20g\",\n        (double) image->depth);\n      if (image->colors != 0)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Number of colors: %.20g\",(double) image->colors);\n      else\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Number of colors: unspecified\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"JPEG data precision: %d\",(int) jpeg_info.data_precision);\n      switch (image->colorspace)\n      {\n        case CMYKColorspace:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Storage class: DirectClass\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Colorspace: CMYK\");\n          break;\n        }\n        case YCbCrColorspace:\n        case Rec601YCbCrColorspace:\n        case Rec709YCbCrColorspace:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Colorspace: YCbCr\");\n          break;\n        }\n        default:\n          break;\n      }\n      switch (image->colorspace)\n      {\n        case CMYKColorspace:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Colorspace: CMYK\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Sampling factors: %dx%d,%dx%d,%dx%d,%dx%d\",\n            jpeg_info.comp_info[0].h_samp_factor,\n            jpeg_info.comp_info[0].v_samp_factor,\n            jpeg_info.comp_info[1].h_samp_factor,\n            jpeg_info.comp_info[1].v_samp_factor,\n            jpeg_info.comp_info[2].h_samp_factor,\n            jpeg_info.comp_info[2].v_samp_factor,\n            jpeg_info.comp_info[3].h_samp_factor,\n            jpeg_info.comp_info[3].v_samp_factor);\n          break;\n        }\n        case GRAYColorspace:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Colorspace: GRAY\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Sampling factors: %dx%d\",jpeg_info.comp_info[0].h_samp_factor,\n            jpeg_info.comp_info[0].v_samp_factor);\n          break;\n        }\n        case sRGBColorspace:\n        case RGBColorspace:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Image colorspace is RGB\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Sampling factors: %dx%d,%dx%d,%dx%d\",\n            jpeg_info.comp_info[0].h_samp_factor,\n            jpeg_info.comp_info[0].v_samp_factor,\n            jpeg_info.comp_info[1].h_samp_factor,\n            jpeg_info.comp_info[1].v_samp_factor,\n            jpeg_info.comp_info[2].h_samp_factor,\n            jpeg_info.comp_info[2].v_samp_factor);\n          break;\n        }\n        case YCbCrColorspace:\n        case Rec601YCbCrColorspace:\n        case Rec709YCbCrColorspace:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Colorspace: YCbCr\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Sampling factors: %dx%d,%dx%d,%dx%d\",\n            jpeg_info.comp_info[0].h_samp_factor,\n            jpeg_info.comp_info[0].v_samp_factor,\n            jpeg_info.comp_info[1].h_samp_factor,\n            jpeg_info.comp_info[1].v_samp_factor,\n            jpeg_info.comp_info[2].h_samp_factor,\n            jpeg_info.comp_info[2].v_samp_factor);\n          break;\n        }\n        default:\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Colorspace: %d\",\n            image->colorspace);\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Sampling factors: %dx%d,%dx%d,%dx%d,%dx%d\",\n            jpeg_info.comp_info[0].h_samp_factor,\n            jpeg_info.comp_info[0].v_samp_factor,\n            jpeg_info.comp_info[1].h_samp_factor,\n            jpeg_info.comp_info[1].v_samp_factor,\n            jpeg_info.comp_info[2].h_samp_factor,\n            jpeg_info.comp_info[2].v_samp_factor,\n            jpeg_info.comp_info[3].h_samp_factor,\n            jpeg_info.comp_info[3].v_samp_factor);\n          break;\n        }\n      }\n    }\n  /*\n    Write JPEG profiles.\n  */\n  value=GetImageProperty(image,\"comment\",exception);\n  if (value != (char *) NULL)\n    for (i=0; i < (ssize_t) strlen(value); i+=65533L)\n      jpeg_write_marker(&jpeg_info,JPEG_COM,(unsigned char *) value+i,\n        (unsigned int) MagickMin((size_t) strlen(value+i),65533L));\n  if (image->profiles != (void *) NULL)\n    WriteProfile(&jpeg_info,image,exception);\n  /*\n    Convert MIFF to JPEG raster pixels.\n  */\n  memory_info=AcquireVirtualMemory((size_t) image->columns,\n    jpeg_info.input_components*sizeof(*jpeg_pixels));\n  if (memory_info == (MemoryInfo *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  jpeg_pixels=(JSAMPLE *) GetVirtualMemoryBlob(memory_info);\n  if (setjmp(error_manager.error_recovery) != 0)\n    {\n      jpeg_destroy_compress(&jpeg_info);\n      if (memory_info != (MemoryInfo *) NULL)\n        memory_info=RelinquishVirtualMemory(memory_info);\n      (void) CloseBlob(image);\n      return(MagickFalse);\n    }\n  scanline[0]=(JSAMPROW) jpeg_pixels;\n  scale=65535/(unsigned short) GetQuantumRange((size_t)\n    jpeg_info.data_precision);\n  if (scale == 0)\n    scale=1;\n  if (jpeg_info.data_precision <= 8)\n    {\n      if ((jpeg_info.in_color_space == JCS_RGB) ||\n          (jpeg_info.in_color_space == JCS_YCbCr))\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=jpeg_pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=(JSAMPLE) ScaleQuantumToChar(GetPixelRed(image,p));\n            *q++=(JSAMPLE) ScaleQuantumToChar(GetPixelGreen(image,p));\n            *q++=(JSAMPLE) ScaleQuantumToChar(GetPixelBlue(image,p));\n            p+=GetPixelChannels(image);\n          }\n          (void) jpeg_write_scanlines(&jpeg_info,scanline,1);\n          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n      else\n        if (jpeg_info.in_color_space == JCS_GRAYSCALE)\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            register const Quantum\n              *p;\n\n            register ssize_t\n              x;\n\n            p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n            if (p == (const Quantum *) NULL)\n              break;\n            q=jpeg_pixels;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              *q++=(JSAMPLE) ScaleQuantumToChar(ClampToQuantum(GetPixelLuma(\n                image,p)));\n              p+=GetPixelChannels(image);\n            }\n            (void) jpeg_write_scanlines(&jpeg_info,scanline,1);\n            status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n            }\n        else\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            register const Quantum\n              *p;\n\n            register ssize_t\n              x;\n\n            p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n            if (p == (const Quantum *) NULL)\n              break;\n            q=jpeg_pixels;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              /*\n                Convert DirectClass packets to contiguous CMYK scanlines.\n              */\n              *q++=(JSAMPLE) (ScaleQuantumToChar((Quantum) (QuantumRange-\n                GetPixelCyan(image,p))));\n              *q++=(JSAMPLE) (ScaleQuantumToChar((Quantum) (QuantumRange-\n                GetPixelMagenta(image,p))));\n              *q++=(JSAMPLE) (ScaleQuantumToChar((Quantum) (QuantumRange-\n                GetPixelYellow(image,p))));\n              *q++=(JSAMPLE) (ScaleQuantumToChar((Quantum) (QuantumRange-\n                GetPixelBlack(image,p))));\n              p+=GetPixelChannels(image);\n            }\n            (void) jpeg_write_scanlines(&jpeg_info,scanline,1);\n            status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n    }\n  else\n    if (jpeg_info.in_color_space == JCS_GRAYSCALE)\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        register const Quantum\n          *p;\n\n        register ssize_t\n          x;\n\n        p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n        if (p == (const Quantum *) NULL)\n          break;\n        q=jpeg_pixels;\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          *q++=(JSAMPLE) (ScaleQuantumToShort(ClampToQuantum(GetPixelLuma(image,\n            p)))/scale);\n          p+=GetPixelChannels(image);\n        }\n        (void) jpeg_write_scanlines(&jpeg_info,scanline,1);\n        status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n    else\n      if ((jpeg_info.in_color_space == JCS_RGB) ||\n          (jpeg_info.in_color_space == JCS_YCbCr))\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=jpeg_pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=(JSAMPLE) (ScaleQuantumToShort(GetPixelRed(image,p))/scale);\n            *q++=(JSAMPLE) (ScaleQuantumToShort(GetPixelGreen(image,p))/scale);\n            *q++=(JSAMPLE) (ScaleQuantumToShort(GetPixelBlue(image,p))/scale);\n            p+=GetPixelChannels(image);\n          }\n          (void) jpeg_write_scanlines(&jpeg_info,scanline,1);\n          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n      else\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=jpeg_pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            /*\n              Convert DirectClass packets to contiguous CMYK scanlines.\n            */\n            *q++=(JSAMPLE) (ScaleQuantumToShort(QuantumRange-GetPixelRed(\n              image,p))/scale);\n            *q++=(JSAMPLE) (ScaleQuantumToShort(QuantumRange-GetPixelGreen(\n              image,p))/scale);\n            *q++=(JSAMPLE) (ScaleQuantumToShort(QuantumRange-GetPixelBlue(\n              image,p))/scale);\n            *q++=(JSAMPLE) (ScaleQuantumToShort(QuantumRange-GetPixelBlack(\n              image,p))/scale);\n            p+=GetPixelChannels(image);\n          }\n          (void) jpeg_write_scanlines(&jpeg_info,scanline,1);\n          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n  if (y == (ssize_t) image->rows)\n    jpeg_finish_compress(&jpeg_info);\n  /*\n    Relinquish resources.\n  */\n  jpeg_destroy_compress(&jpeg_info);\n  memory_info=RelinquishVirtualMemory(memory_info);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n#endif\n"], "filenames": ["coders/jpeg.c"], "buggy_code_start_loc": [1325], "buggy_code_end_loc": [1325], "fixing_code_start_loc": [1326], "fixing_code_end_loc": [1328], "type": "CWE-200", "message": "The ReadJPEGImage function in coders/jpeg.c in ImageMagick before 7.0.6-1 allows remote attackers to obtain sensitive information from uninitialized memory locations via a crafted file.", "other": {"cve": {"id": "CVE-2017-11448", "sourceIdentifier": "cve@mitre.org", "published": "2017-07-19T07:29:00.517", "lastModified": "2021-04-28T17:51:11.403", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The ReadJPEGImage function in coders/jpeg.c in ImageMagick before 7.0.6-1 allows remote attackers to obtain sensitive information from uninitialized memory locations via a crafted file."}, {"lang": "es", "value": "La funci\u00f3n ReadJPEGImage en el archivo coders/jpeg.c en ImageMagick anterior a versi\u00f3n 7.0.6-1, permite a los atacantes remotos obtener informaci\u00f3n confidencial de ubicaciones de memoria no inicializadas por medio de un archivo creado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.9.9-0", "matchCriteriaId": "4418E9AC-8B0E-4C0C-9B70-21FF197441FD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.0.0-0", "versionEndExcluding": "7.0.6-1", "matchCriteriaId": "FB5FB6BA-15D2-4169-BF8D-6102E106080B"}]}]}], "references": [{"url": "https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=867893", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/f6463ca9588579633bbaed9460899d892aa3c64a", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/556", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/f6463ca9588579633bbaed9460899d892aa3c64a"}}