{"buggy_code": ["package filesystem\n\nimport (\n\t\"bufio\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"emperror.dev/errors\"\n\t\"github.com/gabriel-vasile/mimetype\"\n\t\"github.com/karrick/godirwalk\"\n\tignore \"github.com/sabhiram/go-gitignore\"\n\n\t\"github.com/pterodactyl/wings/config\"\n\t\"github.com/pterodactyl/wings/system\"\n)\n\ntype Filesystem struct {\n\tmu                sync.RWMutex\n\tlastLookupTime    *usageLookupTime\n\tlookupInProgress  *system.AtomicBool\n\tdiskUsed          int64\n\tdiskCheckInterval time.Duration\n\tdenylist          *ignore.GitIgnore\n\n\t// The maximum amount of disk space (in bytes) that this Filesystem instance can use.\n\tdiskLimit int64\n\n\t// The root data directory path for this Filesystem instance.\n\troot string\n\n\tisTest bool\n}\n\n// New creates a new Filesystem instance for a given server.\nfunc New(root string, size int64, denylist []string) *Filesystem {\n\treturn &Filesystem{\n\t\troot:              root,\n\t\tdiskLimit:         size,\n\t\tdiskCheckInterval: time.Duration(config.Get().System.DiskCheckInterval),\n\t\tlastLookupTime:    &usageLookupTime{},\n\t\tlookupInProgress:  system.NewAtomicBool(false),\n\t\tdenylist:          ignore.CompileIgnoreLines(denylist...),\n\t}\n}\n\n// Path returns the root path for the Filesystem instance.\nfunc (fs *Filesystem) Path() string {\n\treturn fs.root\n}\n\n// File returns a reader for a file instance as well as the stat information.\nfunc (fs *Filesystem) File(p string) (*os.File, Stat, error) {\n\tcleaned, err := fs.SafePath(p)\n\tif err != nil {\n\t\treturn nil, Stat{}, errors.WithStackIf(err)\n\t}\n\tst, err := fs.Stat(cleaned)\n\tif err != nil {\n\t\tif errors.Is(err, os.ErrNotExist) {\n\t\t\treturn nil, Stat{}, newFilesystemError(ErrNotExist, err)\n\t\t}\n\t\treturn nil, Stat{}, errors.WithStackIf(err)\n\t}\n\tif st.IsDir() {\n\t\treturn nil, Stat{}, newFilesystemError(ErrCodeIsDirectory, nil)\n\t}\n\tf, err := os.Open(cleaned)\n\tif err != nil {\n\t\treturn nil, Stat{}, errors.WithStackIf(err)\n\t}\n\treturn f, st, nil\n}\n\n// Touch acts by creating the given file and path on the disk if it is not present\n// already. If  it is present, the file is opened using the defaults which will truncate\n// the contents. The opened file is then returned to the caller.\nfunc (fs *Filesystem) Touch(p string, flag int) (*os.File, error) {\n\tcleaned, err := fs.SafePath(p)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tf, err := os.OpenFile(cleaned, flag, 0o644)\n\tif err == nil {\n\t\treturn f, nil\n\t}\n\tif f != nil {\n\t\t_ = f.Close()\n\t}\n\t// If the error is not because it doesn't exist then we just need to bail at this point.\n\tif !errors.Is(err, os.ErrNotExist) {\n\t\treturn nil, errors.Wrap(err, \"server/filesystem: touch: failed to open file handle\")\n\t}\n\t// Only create and chown the directory if it doesn't exist.\n\tif _, err := os.Stat(filepath.Dir(cleaned)); errors.Is(err, os.ErrNotExist) {\n\t\t// Create the path leading up to the file we're trying to create, setting the final perms\n\t\t// on it as we go.\n\t\tif err := os.MkdirAll(filepath.Dir(cleaned), 0o755); err != nil {\n\t\t\treturn nil, errors.Wrap(err, \"server/filesystem: touch: failed to create directory tree\")\n\t\t}\n\t\tif err := fs.Chown(filepath.Dir(cleaned)); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\to := &fileOpener{}\n\t// Try to open the file now that we have created the pathing necessary for it, and then\n\t// Chown that file so that the permissions don't mess with things.\n\tf, err = o.open(cleaned, flag, 0o644)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"server/filesystem: touch: failed to open file with wait\")\n\t}\n\t_ = fs.Chown(cleaned)\n\treturn f, nil\n}\n\n// Writefile writes a file to the system. If the file does not already exist one\n// will be created. This will also properly recalculate the disk space used by\n// the server when writing new files or modifying existing ones.\nfunc (fs *Filesystem) Writefile(p string, r io.Reader) error {\n\tcleaned, err := fs.SafePath(p)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar currentSize int64\n\t// If the file does not exist on the system already go ahead and create the pathway\n\t// to it and an empty file. We'll then write to it later on after this completes.\n\tstat, err := os.Stat(cleaned)\n\tif err != nil && !os.IsNotExist(err) {\n\t\treturn errors.Wrap(err, \"server/filesystem: writefile: failed to stat file\")\n\t} else if err == nil {\n\t\tif stat.IsDir() {\n\t\t\treturn errors.WithStack(&Error{code: ErrCodeIsDirectory, resolved: cleaned})\n\t\t}\n\t\tcurrentSize = stat.Size()\n\t}\n\n\tbr := bufio.NewReader(r)\n\t// Check that the new size we're writing to the disk can fit. If there is currently\n\t// a file we'll subtract that current file size from the size of the buffer to determine\n\t// the amount of new data we're writing (or amount we're removing if smaller).\n\tif err := fs.HasSpaceFor(int64(br.Size()) - currentSize); err != nil {\n\t\treturn err\n\t}\n\n\t// Touch the file and return the handle to it at this point. This will create the file,\n\t// any necessary directories, and set the proper owner of the file.\n\tfile, err := fs.Touch(cleaned, os.O_RDWR|os.O_CREATE|os.O_TRUNC)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\tbuf := make([]byte, 1024*4)\n\tsz, err := io.CopyBuffer(file, r, buf)\n\n\t// Adjust the disk usage to account for the old size and the new size of the file.\n\tfs.addDisk(sz - currentSize)\n\n\treturn fs.unsafeChown(cleaned)\n}\n\n// Creates a new directory (name) at a specified path (p) for the server.\nfunc (fs *Filesystem) CreateDirectory(name string, p string) error {\n\tcleaned, err := fs.SafePath(path.Join(p, name))\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn os.MkdirAll(cleaned, 0o755)\n}\n\n// Rename moves (or renames) a file or directory.\nfunc (fs *Filesystem) Rename(from string, to string) error {\n\tcleanedFrom, err := fs.SafePath(from)\n\tif err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\n\tcleanedTo, err := fs.SafePath(to)\n\tif err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\n\t// If the target file or directory already exists the rename function will fail, so just\n\t// bail out now.\n\tif _, err := os.Stat(cleanedTo); err == nil {\n\t\treturn os.ErrExist\n\t}\n\n\tif cleanedTo == fs.Path() {\n\t\treturn errors.New(\"attempting to rename into an invalid directory space\")\n\t}\n\n\td := strings.TrimSuffix(cleanedTo, path.Base(cleanedTo))\n\t// Ensure that the directory we're moving into exists correctly on the system. Only do this if\n\t// we're not at the root directory level.\n\tif d != fs.Path() {\n\t\tif mkerr := os.MkdirAll(d, 0o755); mkerr != nil {\n\t\t\treturn errors.WithMessage(mkerr, \"failed to create directory structure for file rename\")\n\t\t}\n\t}\n\n\tif err := os.Rename(cleanedFrom, cleanedTo); err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\treturn nil\n}\n\n// Recursively iterates over a file or directory and sets the permissions on all of the\n// underlying files. Iterate over all of the files and directories. If it is a file just\n// go ahead and perform the chown operation. Otherwise dig deeper into the directory until\n// we've run out of directories to dig into.\nfunc (fs *Filesystem) Chown(path string) error {\n\tcleaned, err := fs.SafePath(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn fs.unsafeChown(cleaned)\n}\n\n// unsafeChown chowns the given path, without checking if the path is safe. This should only be used\n// when the path has already been checked.\nfunc (fs *Filesystem) unsafeChown(path string) error {\n\tif fs.isTest {\n\t\treturn nil\n\t}\n\n\tuid := config.Get().System.User.Uid\n\tgid := config.Get().System.User.Gid\n\n\t// Start by just chowning the initial path that we received.\n\tif err := os.Chown(path, uid, gid); err != nil {\n\t\treturn errors.Wrap(err, \"server/filesystem: chown: failed to chown path\")\n\t}\n\n\t// If this is not a directory we can now return from the function, there is nothing\n\t// left that we need to do.\n\tif st, err := os.Stat(path); err != nil || !st.IsDir() {\n\t\treturn nil\n\t}\n\n\t// If this was a directory, begin walking over its contents recursively and ensure that all\n\t// of the subfiles and directories get their permissions updated as well.\n\terr := godirwalk.Walk(path, &godirwalk.Options{\n\t\tUnsorted: true,\n\t\tCallback: func(p string, e *godirwalk.Dirent) error {\n\t\t\t// Do not attempt to chown a symlink. Go's os.Chown function will affect the symlink\n\t\t\t// so if it points to a location outside the data directory the user would be able to\n\t\t\t// (un)intentionally modify that files permissions.\n\t\t\tif e.IsSymlink() {\n\t\t\t\tif e.IsDir() {\n\t\t\t\t\treturn godirwalk.SkipThis\n\t\t\t\t}\n\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\treturn os.Chown(p, uid, gid)\n\t\t},\n\t})\n\treturn errors.Wrap(err, \"server/filesystem: chown: failed to chown during walk function\")\n}\n\nfunc (fs *Filesystem) Chmod(path string, mode os.FileMode) error {\n\tcleaned, err := fs.SafePath(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif fs.isTest {\n\t\treturn nil\n\t}\n\n\tif err := os.Chmod(cleaned, mode); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Begin looping up to 50 times to try and create a unique copy file name. This will take\n// an input of \"file.txt\" and generate \"file copy.txt\". If that name is already taken, it will\n// then try to write \"file copy 2.txt\" and so on, until reaching 50 loops. At that point we\n// won't waste anymore time, just use the current timestamp and make that copy.\n//\n// Could probably make this more efficient by checking if there are any files matching the copy\n// pattern, and trying to find the highest number and then incrementing it by one rather than\n// looping endlessly.\nfunc (fs *Filesystem) findCopySuffix(dir string, name string, extension string) (string, error) {\n\tvar i int\n\tsuffix := \" copy\"\n\n\tfor i = 0; i < 51; i++ {\n\t\tif i > 0 {\n\t\t\tsuffix = \" copy \" + strconv.Itoa(i)\n\t\t}\n\n\t\tn := name + suffix + extension\n\t\t// If we stat the file and it does not exist that means we're good to create the copy. If it\n\t\t// does exist, we'll just continue to the next loop and try again.\n\t\tif _, err := fs.Stat(path.Join(dir, n)); err != nil {\n\t\t\tif !errors.Is(err, os.ErrNotExist) {\n\t\t\t\treturn \"\", err\n\t\t\t}\n\n\t\t\tbreak\n\t\t}\n\n\t\tif i == 50 {\n\t\t\tsuffix = \"copy.\" + time.Now().Format(time.RFC3339)\n\t\t}\n\t}\n\n\treturn name + suffix + extension, nil\n}\n\n// Copies a given file to the same location and appends a suffix to the file to indicate that\n// it has been copied.\nfunc (fs *Filesystem) Copy(p string) error {\n\tcleaned, err := fs.SafePath(p)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts, err := os.Stat(cleaned)\n\tif err != nil {\n\t\treturn err\n\t} else if s.IsDir() || !s.Mode().IsRegular() {\n\t\t// If this is a directory or not a regular file, just throw a not-exist error\n\t\t// since anything calling this function should understand what that means.\n\t\treturn os.ErrNotExist\n\t}\n\n\t// Check that copying this file wouldn't put the server over its limit.\n\tif err := fs.HasSpaceFor(s.Size()); err != nil {\n\t\treturn err\n\t}\n\n\tbase := filepath.Base(cleaned)\n\trelative := strings.TrimSuffix(strings.TrimPrefix(cleaned, fs.Path()), base)\n\textension := filepath.Ext(base)\n\tname := strings.TrimSuffix(base, extension)\n\n\t// Ensure that \".tar\" is also counted as apart of the file extension.\n\t// There might be a better way to handle this for other double file extensions,\n\t// but this is a good workaround for now.\n\tif strings.HasSuffix(name, \".tar\") {\n\t\textension = \".tar\" + extension\n\t\tname = strings.TrimSuffix(name, \".tar\")\n\t}\n\n\tsource, err := os.Open(cleaned)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer source.Close()\n\n\tn, err := fs.findCopySuffix(relative, name, extension)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn fs.Writefile(path.Join(relative, n), source)\n}\n\n// TruncateRootDirectory removes _all_ files and directories from a server's\n// data directory and resets the used disk space to zero.\nfunc (fs *Filesystem) TruncateRootDirectory() error {\n\tif err := os.RemoveAll(fs.Path()); err != nil {\n\t\treturn err\n\t}\n\tif err := os.Mkdir(fs.Path(), 0o755); err != nil {\n\t\treturn err\n\t}\n\tatomic.StoreInt64(&fs.diskUsed, 0)\n\treturn nil\n}\n\n// Delete removes a file or folder from the system. Prevents the user from\n// accidentally (or maliciously) removing their root server data directory.\nfunc (fs *Filesystem) Delete(p string) error {\n\twg := sync.WaitGroup{}\n\t// This is one of the few (only?) places in the codebase where we're explicitly not using\n\t// the SafePath functionality when working with user provided input. If we did, you would\n\t// not be able to delete a file that is a symlink pointing to a location outside of the data\n\t// directory.\n\t//\n\t// We also want to avoid resolving a symlink that points _within_ the data directory and thus\n\t// deleting the actual source file for the symlink rather than the symlink itself. For these\n\t// purposes just resolve the actual file path using filepath.Join() and confirm that the path\n\t// exists within the data directory.\n\tresolved := fs.unsafeFilePath(p)\n\tif !fs.unsafeIsInDataDirectory(resolved) {\n\t\treturn NewBadPathResolution(p, resolved)\n\t}\n\n\t// Block any whoopsies.\n\tif resolved == fs.Path() {\n\t\treturn errors.New(\"cannot delete root server directory\")\n\t}\n\n\tif st, err := os.Lstat(resolved); err != nil {\n\t\tif !os.IsNotExist(err) {\n\t\t\tfs.error(err).Warn(\"error while attempting to stat file before deletion\")\n\t\t}\n\t} else {\n\t\tif !st.IsDir() {\n\t\t\tfs.addDisk(-st.Size())\n\t\t} else {\n\t\t\twg.Add(1)\n\t\t\tgo func(wg *sync.WaitGroup, st os.FileInfo, resolved string) {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tif s, err := fs.DirectorySize(resolved); err == nil {\n\t\t\t\t\tfs.addDisk(-s)\n\t\t\t\t}\n\t\t\t}(&wg, st, resolved)\n\t\t}\n\t}\n\n\twg.Wait()\n\n\treturn os.RemoveAll(resolved)\n}\n\ntype fileOpener struct {\n\tbusy uint\n}\n\n// Attempts to open a given file up to \"attempts\" number of times, using a backoff. If the file\n// cannot be opened because of a \"text file busy\" error, we will attempt until the number of attempts\n// has been exhaused, at which point we will abort with an error.\nfunc (fo *fileOpener) open(path string, flags int, perm os.FileMode) (*os.File, error) {\n\tfor {\n\t\tf, err := os.OpenFile(path, flags, perm)\n\n\t\t// If there is an error because the text file is busy, go ahead and sleep for a few\n\t\t// hundred milliseconds and then try again up to three times before just returning the\n\t\t// error back to the caller.\n\t\t//\n\t\t// Based on code from: https://github.com/golang/go/issues/22220#issuecomment-336458122\n\t\tif err != nil && fo.busy < 3 && strings.Contains(err.Error(), \"text file busy\") {\n\t\t\ttime.Sleep(100 * time.Millisecond << fo.busy)\n\t\t\tfo.busy++\n\t\t\tcontinue\n\t\t}\n\n\t\treturn f, err\n\t}\n}\n\n// ListDirectory lists the contents of a given directory and returns stat\n// information about each file and folder within it.\nfunc (fs *Filesystem) ListDirectory(p string) ([]Stat, error) {\n\tcleaned, err := fs.SafePath(p)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfiles, err := ioutil.ReadDir(cleaned)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar wg sync.WaitGroup\n\n\t// You must initialize the output of this directory as a non-nil value otherwise\n\t// when it is marshaled into a JSON object you'll just get 'null' back, which will\n\t// break the panel badly.\n\tout := make([]Stat, len(files))\n\n\t// Iterate over all of the files and directories returned and perform an async process\n\t// to get the mime-type for them all.\n\tfor i, file := range files {\n\t\twg.Add(1)\n\n\t\tgo func(idx int, f os.FileInfo) {\n\t\t\tdefer wg.Done()\n\n\t\t\tvar m *mimetype.MIME\n\t\t\td := \"inode/directory\"\n\t\t\tif !f.IsDir() {\n\t\t\t\tcleanedp := filepath.Join(cleaned, f.Name())\n\t\t\t\tif f.Mode()&os.ModeSymlink != 0 {\n\t\t\t\t\tcleanedp, _ = fs.SafePath(filepath.Join(cleaned, f.Name()))\n\t\t\t\t}\n\n\t\t\t\t// Don't try to detect the type on a pipe \u2014 this will just hang the application and\n\t\t\t\t// you'll never get a response back.\n\t\t\t\t//\n\t\t\t\t// @see https://github.com/pterodactyl/panel/issues/4059\n\t\t\t\tif cleanedp != \"\" && f.Mode()&os.ModeNamedPipe == 0 {\n\t\t\t\t\tm, _ = mimetype.DetectFile(filepath.Join(cleaned, f.Name()))\n\t\t\t\t} else {\n\t\t\t\t\t// Just pass this for an unknown type because the file could not safely be resolved within\n\t\t\t\t\t// the server data path.\n\t\t\t\t\td = \"application/octet-stream\"\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tst := Stat{FileInfo: f, Mimetype: d}\n\t\t\tif m != nil {\n\t\t\t\tst.Mimetype = m.String()\n\t\t\t}\n\t\t\tout[idx] = st\n\t\t}(i, file)\n\t}\n\n\twg.Wait()\n\n\t// Sort the output alphabetically to begin with since we've run the output\n\t// through an asynchronous process and the order is gonna be very random.\n\tsort.SliceStable(out, func(i, j int) bool {\n\t\tif out[i].Name() == out[j].Name() || out[i].Name() > out[j].Name() {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t})\n\n\t// Then, sort it so that directories are listed first in the output. Everything\n\t// will continue to be alphabetized at this point.\n\tsort.SliceStable(out, func(i, j int) bool {\n\t\treturn out[i].IsDir()\n\t})\n\n\treturn out, nil\n}\n\nfunc (fs *Filesystem) Chtimes(path string, atime, mtime time.Time) error {\n\tcleaned, err := fs.SafePath(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif fs.isTest {\n\t\treturn nil\n\t}\n\n\tif err := os.Chtimes(cleaned, atime, mtime); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n", "package filesystem\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"errors\"\n\t\"math/rand\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"unicode/utf8\"\n\n\t. \"github.com/franela/goblin\"\n\n\t\"github.com/pterodactyl/wings/config\"\n)\n\nfunc NewFs() (*Filesystem, *rootFs) {\n\tconfig.Set(&config.Configuration{\n\t\tAuthenticationToken: \"abc\",\n\t\tSystem: config.SystemConfiguration{\n\t\t\tRootDirectory:     \"/server\",\n\t\t\tDiskCheckInterval: 150,\n\t\t},\n\t})\n\n\ttmpDir, err := os.MkdirTemp(os.TempDir(), \"pterodactyl\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t// defer os.RemoveAll(tmpDir)\n\n\trfs := rootFs{root: tmpDir}\n\n\trfs.reset()\n\n\tfs := New(filepath.Join(tmpDir, \"/server\"), 0, []string{})\n\tfs.isTest = true\n\n\treturn fs, &rfs\n}\n\ntype rootFs struct {\n\troot string\n}\n\nfunc getFileContent(file *os.File) string {\n\tvar w bytes.Buffer\n\tif _, err := bufio.NewReader(file).WriteTo(&w); err != nil {\n\t\tpanic(err)\n\t}\n\treturn w.String()\n}\n\nfunc (rfs *rootFs) CreateServerFile(p string, c []byte) error {\n\tf, err := os.Create(filepath.Join(rfs.root, \"/server\", p))\n\n\tif err == nil {\n\t\tf.Write(c)\n\t\tf.Close()\n\t}\n\n\treturn err\n}\n\nfunc (rfs *rootFs) CreateServerFileFromString(p string, c string) error {\n\treturn rfs.CreateServerFile(p, []byte(c))\n}\n\nfunc (rfs *rootFs) StatServerFile(p string) (os.FileInfo, error) {\n\treturn os.Stat(filepath.Join(rfs.root, \"/server\", p))\n}\n\nfunc (rfs *rootFs) reset() {\n\tif err := os.RemoveAll(filepath.Join(rfs.root, \"/server\")); err != nil {\n\t\tif !os.IsNotExist(err) {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\n\tif err := os.Mkdir(filepath.Join(rfs.root, \"/server\"), 0o755); err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc TestFilesystem_Openfile(t *testing.T) {\n\tg := Goblin(t)\n\tfs, rfs := NewFs()\n\n\tg.Describe(\"File\", func() {\n\t\tg.It(\"returns custom error when file does not exist\", func() {\n\t\t\t_, _, err := fs.File(\"foo/bar.txt\")\n\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrNotExist)).IsTrue()\n\t\t})\n\n\t\tg.It(\"returns file stat information\", func() {\n\t\t\t_ = rfs.CreateServerFile(\"foo.txt\", []byte(\"hello world\"))\n\n\t\t\tf, st, err := fs.File(\"foo.txt\")\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\tg.Assert(st.Name()).Equal(\"foo.txt\")\n\t\t\tg.Assert(f).IsNotNil()\n\t\t\t_ = f.Close()\n\t\t})\n\n\t\tg.AfterEach(func() {\n\t\t\trfs.reset()\n\t\t})\n\t})\n}\n\nfunc TestFilesystem_Writefile(t *testing.T) {\n\tg := Goblin(t)\n\tfs, rfs := NewFs()\n\n\tg.Describe(\"Open and WriteFile\", func() {\n\t\tbuf := &bytes.Buffer{}\n\n\t\t// Test that a file can be written to the disk and that the disk space used as a result\n\t\t// is updated correctly in the end.\n\t\tg.It(\"can create a new file\", func() {\n\t\t\tr := bytes.NewReader([]byte(\"test file content\"))\n\n\t\t\tg.Assert(atomic.LoadInt64(&fs.diskUsed)).Equal(int64(0))\n\n\t\t\terr := fs.Writefile(\"test.txt\", r)\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\tf, _, err := fs.File(\"test.txt\")\n\t\t\tg.Assert(err).IsNil()\n\t\t\tdefer f.Close()\n\t\t\tg.Assert(getFileContent(f)).Equal(\"test file content\")\n\t\t\tg.Assert(atomic.LoadInt64(&fs.diskUsed)).Equal(r.Size())\n\t\t})\n\n\t\tg.It(\"can create a new file inside a nested directory with leading slash\", func() {\n\t\t\tr := bytes.NewReader([]byte(\"test file content\"))\n\n\t\t\terr := fs.Writefile(\"/some/nested/test.txt\", r)\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\tf, _, err := fs.File(\"/some/nested/test.txt\")\n\t\t\tg.Assert(err).IsNil()\n\t\t\tdefer f.Close()\n\t\t\tg.Assert(getFileContent(f)).Equal(\"test file content\")\n\t\t})\n\n\t\tg.It(\"can create a new file inside a nested directory without a trailing slash\", func() {\n\t\t\tr := bytes.NewReader([]byte(\"test file content\"))\n\n\t\t\terr := fs.Writefile(\"some/../foo/bar/test.txt\", r)\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\tf, _, err := fs.File(\"foo/bar/test.txt\")\n\t\t\tg.Assert(err).IsNil()\n\t\t\tdefer f.Close()\n\t\t\tg.Assert(getFileContent(f)).Equal(\"test file content\")\n\t\t})\n\n\t\tg.It(\"cannot create a file outside the root directory\", func() {\n\t\t\tr := bytes.NewReader([]byte(\"test file content\"))\n\n\t\t\terr := fs.Writefile(\"/some/../foo/../../test.txt\", r)\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\t\t})\n\n\t\tg.It(\"cannot write a file that exceeds the disk limits\", func() {\n\t\t\tatomic.StoreInt64(&fs.diskLimit, 1024)\n\n\t\t\tb := make([]byte, 1025)\n\t\t\t_, err := rand.Read(b)\n\t\t\tg.Assert(err).IsNil()\n\t\t\tg.Assert(len(b)).Equal(1025)\n\n\t\t\tr := bytes.NewReader(b)\n\t\t\terr = fs.Writefile(\"test.txt\", r)\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodeDiskSpace)).IsTrue()\n\t\t})\n\n\t\tg.It(\"truncates the file when writing new contents\", func() {\n\t\t\tr := bytes.NewReader([]byte(\"original data\"))\n\t\t\terr := fs.Writefile(\"test.txt\", r)\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\tr = bytes.NewReader([]byte(\"new data\"))\n\t\t\terr = fs.Writefile(\"test.txt\", r)\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\tf, _, err := fs.File(\"test.txt\")\n\t\t\tg.Assert(err).IsNil()\n\t\t\tdefer f.Close()\n\t\t\tg.Assert(getFileContent(f)).Equal(\"new data\")\n\t\t})\n\n\t\tg.AfterEach(func() {\n\t\t\tbuf.Truncate(0)\n\t\t\trfs.reset()\n\n\t\t\tatomic.StoreInt64(&fs.diskUsed, 0)\n\t\t\tatomic.StoreInt64(&fs.diskLimit, 0)\n\t\t})\n\t})\n}\n\nfunc TestFilesystem_CreateDirectory(t *testing.T) {\n\tg := Goblin(t)\n\tfs, rfs := NewFs()\n\n\tg.Describe(\"CreateDirectory\", func() {\n\t\tg.It(\"should create missing directories automatically\", func() {\n\t\t\terr := fs.CreateDirectory(\"test\", \"foo/bar/baz\")\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\tst, err := rfs.StatServerFile(\"foo/bar/baz/test\")\n\t\t\tg.Assert(err).IsNil()\n\t\t\tg.Assert(st.IsDir()).IsTrue()\n\t\t\tg.Assert(st.Name()).Equal(\"test\")\n\t\t})\n\n\t\tg.It(\"should work with leading and trailing slashes\", func() {\n\t\t\terr := fs.CreateDirectory(\"test\", \"/foozie/barzie/bazzy/\")\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\tst, err := rfs.StatServerFile(\"foozie/barzie/bazzy/test\")\n\t\t\tg.Assert(err).IsNil()\n\t\t\tg.Assert(st.IsDir()).IsTrue()\n\t\t\tg.Assert(st.Name()).Equal(\"test\")\n\t\t})\n\n\t\tg.It(\"should not allow the creation of directories outside the root\", func() {\n\t\t\terr := fs.CreateDirectory(\"test\", \"e/../../something\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\t\t})\n\n\t\tg.It(\"should not increment the disk usage\", func() {\n\t\t\terr := fs.CreateDirectory(\"test\", \"/\")\n\t\t\tg.Assert(err).IsNil()\n\t\t\tg.Assert(atomic.LoadInt64(&fs.diskUsed)).Equal(int64(0))\n\t\t})\n\n\t\tg.AfterEach(func() {\n\t\t\trfs.reset()\n\t\t})\n\t})\n}\n\nfunc TestFilesystem_Rename(t *testing.T) {\n\tg := Goblin(t)\n\tfs, rfs := NewFs()\n\n\tg.Describe(\"Rename\", func() {\n\t\tg.BeforeEach(func() {\n\t\t\tif err := rfs.CreateServerFileFromString(\"source.txt\", \"text content\"); err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t})\n\n\t\tg.It(\"returns an error if the target already exists\", func() {\n\t\t\terr := rfs.CreateServerFileFromString(\"target.txt\", \"taget content\")\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\terr = fs.Rename(\"source.txt\", \"target.txt\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(errors.Is(err, os.ErrExist)).IsTrue()\n\t\t})\n\n\t\tg.It(\"returns an error if the final destination is the root directory\", func() {\n\t\t\terr := fs.Rename(\"source.txt\", \"/\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(errors.Is(err, os.ErrExist)).IsTrue()\n\t\t})\n\n\t\tg.It(\"returns an error if the source destination is the root directory\", func() {\n\t\t\terr := fs.Rename(\"source.txt\", \"/\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(errors.Is(err, os.ErrExist)).IsTrue()\n\t\t})\n\n\t\tg.It(\"does not allow renaming to a location outside the root\", func() {\n\t\t\terr := fs.Rename(\"source.txt\", \"../target.txt\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\t\t})\n\n\t\tg.It(\"does not allow renaming from a location outside the root\", func() {\n\t\t\terr := rfs.CreateServerFileFromString(\"/../ext-source.txt\", \"taget content\")\n\n\t\t\terr = fs.Rename(\"/../ext-source.txt\", \"target.txt\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\t\t})\n\n\t\tg.It(\"allows a file to be renamed\", func() {\n\t\t\terr := fs.Rename(\"source.txt\", \"target.txt\")\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\t_, err = rfs.StatServerFile(\"source.txt\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(errors.Is(err, os.ErrNotExist)).IsTrue()\n\n\t\t\tst, err := rfs.StatServerFile(\"target.txt\")\n\t\t\tg.Assert(err).IsNil()\n\t\t\tg.Assert(st.Name()).Equal(\"target.txt\")\n\t\t\tg.Assert(st.Size()).IsNotZero()\n\t\t})\n\n\t\tg.It(\"allows a folder to be renamed\", func() {\n\t\t\terr := os.Mkdir(filepath.Join(rfs.root, \"/server/source_dir\"), 0o755)\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\terr = fs.Rename(\"source_dir\", \"target_dir\")\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\t_, err = rfs.StatServerFile(\"source_dir\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(errors.Is(err, os.ErrNotExist)).IsTrue()\n\n\t\t\tst, err := rfs.StatServerFile(\"target_dir\")\n\t\t\tg.Assert(err).IsNil()\n\t\t\tg.Assert(st.IsDir()).IsTrue()\n\t\t})\n\n\t\tg.It(\"returns an error if the source does not exist\", func() {\n\t\t\terr := fs.Rename(\"missing.txt\", \"target.txt\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(errors.Is(err, os.ErrNotExist)).IsTrue()\n\t\t})\n\n\t\tg.It(\"creates directories if they are missing\", func() {\n\t\t\terr := fs.Rename(\"source.txt\", \"nested/folder/target.txt\")\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\tst, err := rfs.StatServerFile(\"nested/folder/target.txt\")\n\t\t\tg.Assert(err).IsNil()\n\t\t\tg.Assert(st.Name()).Equal(\"target.txt\")\n\t\t})\n\n\t\tg.AfterEach(func() {\n\t\t\trfs.reset()\n\t\t})\n\t})\n}\n\nfunc TestFilesystem_Copy(t *testing.T) {\n\tg := Goblin(t)\n\tfs, rfs := NewFs()\n\n\tg.Describe(\"Copy\", func() {\n\t\tg.BeforeEach(func() {\n\t\t\tif err := rfs.CreateServerFileFromString(\"source.txt\", \"text content\"); err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\n\t\t\tatomic.StoreInt64(&fs.diskUsed, int64(utf8.RuneCountInString(\"test content\")))\n\t\t})\n\n\t\tg.It(\"should return an error if the source does not exist\", func() {\n\t\t\terr := fs.Copy(\"foo.txt\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(errors.Is(err, os.ErrNotExist)).IsTrue()\n\t\t})\n\n\t\tg.It(\"should return an error if the source is outside the root\", func() {\n\t\t\terr := rfs.CreateServerFileFromString(\"/../ext-source.txt\", \"text content\")\n\n\t\t\terr = fs.Copy(\"../ext-source.txt\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\t\t})\n\n\t\tg.It(\"should return an error if the source directory is outside the root\", func() {\n\t\t\terr := os.MkdirAll(filepath.Join(rfs.root, \"/nested/in/dir\"), 0o755)\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\terr = rfs.CreateServerFileFromString(\"/../nested/in/dir/ext-source.txt\", \"external content\")\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\terr = fs.Copy(\"../nested/in/dir/ext-source.txt\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\n\t\t\terr = fs.Copy(\"nested/in/../../../nested/in/dir/ext-source.txt\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\t\t})\n\n\t\tg.It(\"should return an error if the source is a directory\", func() {\n\t\t\terr := os.Mkdir(filepath.Join(rfs.root, \"/server/dir\"), 0o755)\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\terr = fs.Copy(\"dir\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(errors.Is(err, os.ErrNotExist)).IsTrue()\n\t\t})\n\n\t\tg.It(\"should return an error if there is not space to copy the file\", func() {\n\t\t\tatomic.StoreInt64(&fs.diskLimit, 2)\n\n\t\t\terr := fs.Copy(\"source.txt\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodeDiskSpace)).IsTrue()\n\t\t})\n\n\t\tg.It(\"should create a copy of the file and increment the disk used\", func() {\n\t\t\terr := fs.Copy(\"source.txt\")\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\t_, err = rfs.StatServerFile(\"source.txt\")\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\t_, err = rfs.StatServerFile(\"source copy.txt\")\n\t\t\tg.Assert(err).IsNil()\n\t\t})\n\n\t\tg.It(\"should create a copy of the file with a suffix if a copy already exists\", func() {\n\t\t\terr := fs.Copy(\"source.txt\")\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\terr = fs.Copy(\"source.txt\")\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\tr := []string{\"source.txt\", \"source copy.txt\", \"source copy 1.txt\"}\n\n\t\t\tfor _, name := range r {\n\t\t\t\t_, err = rfs.StatServerFile(name)\n\t\t\t\tg.Assert(err).IsNil()\n\t\t\t}\n\n\t\t\tg.Assert(atomic.LoadInt64(&fs.diskUsed)).Equal(int64(utf8.RuneCountInString(\"test content\")) * 3)\n\t\t})\n\n\t\tg.It(\"should create a copy inside of a directory\", func() {\n\t\t\terr := os.MkdirAll(filepath.Join(rfs.root, \"/server/nested/in/dir\"), 0o755)\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\terr = rfs.CreateServerFileFromString(\"nested/in/dir/source.txt\", \"test content\")\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\terr = fs.Copy(\"nested/in/dir/source.txt\")\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\t_, err = rfs.StatServerFile(\"nested/in/dir/source.txt\")\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\t_, err = rfs.StatServerFile(\"nested/in/dir/source copy.txt\")\n\t\t\tg.Assert(err).IsNil()\n\t\t})\n\n\t\tg.AfterEach(func() {\n\t\t\trfs.reset()\n\n\t\t\tatomic.StoreInt64(&fs.diskUsed, 0)\n\t\t\tatomic.StoreInt64(&fs.diskLimit, 0)\n\t\t})\n\t})\n}\n\nfunc TestFilesystem_Delete(t *testing.T) {\n\tg := Goblin(t)\n\tfs, rfs := NewFs()\n\n\tg.Describe(\"Delete\", func() {\n\t\tg.BeforeEach(func() {\n\t\t\tif err := rfs.CreateServerFileFromString(\"source.txt\", \"test content\"); err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\n\t\t\tatomic.StoreInt64(&fs.diskUsed, int64(utf8.RuneCountInString(\"test content\")))\n\t\t})\n\n\t\tg.It(\"does not delete files outside the root directory\", func() {\n\t\t\terr := rfs.CreateServerFileFromString(\"/../ext-source.txt\", \"external content\")\n\n\t\t\terr = fs.Delete(\"../ext-source.txt\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\t\t})\n\n\t\tg.It(\"does not allow the deletion of the root directory\", func() {\n\t\t\terr := fs.Delete(\"/\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(err.Error()).Equal(\"cannot delete root server directory\")\n\t\t})\n\n\t\tg.It(\"does not return an error if the target does not exist\", func() {\n\t\t\terr := fs.Delete(\"missing.txt\")\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\tst, err := rfs.StatServerFile(\"source.txt\")\n\t\t\tg.Assert(err).IsNil()\n\t\t\tg.Assert(st.Name()).Equal(\"source.txt\")\n\t\t})\n\n\t\tg.It(\"deletes files and subtracts their size from the disk usage\", func() {\n\t\t\terr := fs.Delete(\"source.txt\")\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\t_, err = rfs.StatServerFile(\"source.txt\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(errors.Is(err, os.ErrNotExist)).IsTrue()\n\n\t\t\tg.Assert(atomic.LoadInt64(&fs.diskUsed)).Equal(int64(0))\n\t\t})\n\n\t\tg.It(\"deletes all items inside a directory if the directory is deleted\", func() {\n\t\t\tsources := []string{\n\t\t\t\t\"foo/source.txt\",\n\t\t\t\t\"foo/bar/source.txt\",\n\t\t\t\t\"foo/bar/baz/source.txt\",\n\t\t\t}\n\n\t\t\terr := os.MkdirAll(filepath.Join(rfs.root, \"/server/foo/bar/baz\"), 0o755)\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\tfor _, s := range sources {\n\t\t\t\terr = rfs.CreateServerFileFromString(s, \"test content\")\n\t\t\t\tg.Assert(err).IsNil()\n\t\t\t}\n\n\t\t\tatomic.StoreInt64(&fs.diskUsed, int64(utf8.RuneCountInString(\"test content\")*3))\n\n\t\t\terr = fs.Delete(\"foo\")\n\t\t\tg.Assert(err).IsNil()\n\t\t\tg.Assert(atomic.LoadInt64(&fs.diskUsed)).Equal(int64(0))\n\n\t\t\tfor _, s := range sources {\n\t\t\t\t_, err = rfs.StatServerFile(s)\n\t\t\t\tg.Assert(err).IsNotNil()\n\t\t\t\tg.Assert(errors.Is(err, os.ErrNotExist)).IsTrue()\n\t\t\t}\n\t\t})\n\n\t\tg.AfterEach(func() {\n\t\t\trfs.reset()\n\n\t\t\tatomic.StoreInt64(&fs.diskUsed, 0)\n\t\t\tatomic.StoreInt64(&fs.diskLimit, 0)\n\t\t})\n\t})\n}\n"], "fixing_code": ["package filesystem\n\nimport (\n\t\"bufio\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"emperror.dev/errors\"\n\t\"github.com/gabriel-vasile/mimetype\"\n\t\"github.com/karrick/godirwalk\"\n\tignore \"github.com/sabhiram/go-gitignore\"\n\n\t\"github.com/pterodactyl/wings/config\"\n\t\"github.com/pterodactyl/wings/system\"\n)\n\ntype Filesystem struct {\n\tmu                sync.RWMutex\n\tlastLookupTime    *usageLookupTime\n\tlookupInProgress  *system.AtomicBool\n\tdiskUsed          int64\n\tdiskCheckInterval time.Duration\n\tdenylist          *ignore.GitIgnore\n\n\t// The maximum amount of disk space (in bytes) that this Filesystem instance can use.\n\tdiskLimit int64\n\n\t// The root data directory path for this Filesystem instance.\n\troot string\n\n\tisTest bool\n}\n\n// New creates a new Filesystem instance for a given server.\nfunc New(root string, size int64, denylist []string) *Filesystem {\n\treturn &Filesystem{\n\t\troot:              root,\n\t\tdiskLimit:         size,\n\t\tdiskCheckInterval: time.Duration(config.Get().System.DiskCheckInterval),\n\t\tlastLookupTime:    &usageLookupTime{},\n\t\tlookupInProgress:  system.NewAtomicBool(false),\n\t\tdenylist:          ignore.CompileIgnoreLines(denylist...),\n\t}\n}\n\n// Path returns the root path for the Filesystem instance.\nfunc (fs *Filesystem) Path() string {\n\treturn fs.root\n}\n\n// File returns a reader for a file instance as well as the stat information.\nfunc (fs *Filesystem) File(p string) (*os.File, Stat, error) {\n\tcleaned, err := fs.SafePath(p)\n\tif err != nil {\n\t\treturn nil, Stat{}, errors.WithStackIf(err)\n\t}\n\tst, err := fs.Stat(cleaned)\n\tif err != nil {\n\t\tif errors.Is(err, os.ErrNotExist) {\n\t\t\treturn nil, Stat{}, newFilesystemError(ErrNotExist, err)\n\t\t}\n\t\treturn nil, Stat{}, errors.WithStackIf(err)\n\t}\n\tif st.IsDir() {\n\t\treturn nil, Stat{}, newFilesystemError(ErrCodeIsDirectory, nil)\n\t}\n\tf, err := os.Open(cleaned)\n\tif err != nil {\n\t\treturn nil, Stat{}, errors.WithStackIf(err)\n\t}\n\treturn f, st, nil\n}\n\n// Touch acts by creating the given file and path on the disk if it is not present\n// already. If  it is present, the file is opened using the defaults which will truncate\n// the contents. The opened file is then returned to the caller.\nfunc (fs *Filesystem) Touch(p string, flag int) (*os.File, error) {\n\tcleaned, err := fs.SafePath(p)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tf, err := os.OpenFile(cleaned, flag, 0o644)\n\tif err == nil {\n\t\treturn f, nil\n\t}\n\tif f != nil {\n\t\t_ = f.Close()\n\t}\n\t// If the error is not because it doesn't exist then we just need to bail at this point.\n\tif !errors.Is(err, os.ErrNotExist) {\n\t\treturn nil, errors.Wrap(err, \"server/filesystem: touch: failed to open file handle\")\n\t}\n\t// Only create and chown the directory if it doesn't exist.\n\tif _, err := os.Stat(filepath.Dir(cleaned)); errors.Is(err, os.ErrNotExist) {\n\t\t// Create the path leading up to the file we're trying to create, setting the final perms\n\t\t// on it as we go.\n\t\tif err := os.MkdirAll(filepath.Dir(cleaned), 0o755); err != nil {\n\t\t\treturn nil, errors.Wrap(err, \"server/filesystem: touch: failed to create directory tree\")\n\t\t}\n\t\tif err := fs.Chown(filepath.Dir(cleaned)); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\to := &fileOpener{}\n\t// Try to open the file now that we have created the pathing necessary for it, and then\n\t// Chown that file so that the permissions don't mess with things.\n\tf, err = o.open(cleaned, flag, 0o644)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"server/filesystem: touch: failed to open file with wait\")\n\t}\n\t_ = fs.Chown(cleaned)\n\treturn f, nil\n}\n\n// Writefile writes a file to the system. If the file does not already exist one\n// will be created. This will also properly recalculate the disk space used by\n// the server when writing new files or modifying existing ones.\nfunc (fs *Filesystem) Writefile(p string, r io.Reader) error {\n\tcleaned, err := fs.SafePath(p)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar currentSize int64\n\t// If the file does not exist on the system already go ahead and create the pathway\n\t// to it and an empty file. We'll then write to it later on after this completes.\n\tstat, err := os.Stat(cleaned)\n\tif err != nil && !os.IsNotExist(err) {\n\t\treturn errors.Wrap(err, \"server/filesystem: writefile: failed to stat file\")\n\t} else if err == nil {\n\t\tif stat.IsDir() {\n\t\t\treturn errors.WithStack(&Error{code: ErrCodeIsDirectory, resolved: cleaned})\n\t\t}\n\t\tcurrentSize = stat.Size()\n\t}\n\n\tbr := bufio.NewReader(r)\n\t// Check that the new size we're writing to the disk can fit. If there is currently\n\t// a file we'll subtract that current file size from the size of the buffer to determine\n\t// the amount of new data we're writing (or amount we're removing if smaller).\n\tif err := fs.HasSpaceFor(int64(br.Size()) - currentSize); err != nil {\n\t\treturn err\n\t}\n\n\t// Touch the file and return the handle to it at this point. This will create the file,\n\t// any necessary directories, and set the proper owner of the file.\n\tfile, err := fs.Touch(cleaned, os.O_RDWR|os.O_CREATE|os.O_TRUNC)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\tbuf := make([]byte, 1024*4)\n\tsz, err := io.CopyBuffer(file, r, buf)\n\n\t// Adjust the disk usage to account for the old size and the new size of the file.\n\tfs.addDisk(sz - currentSize)\n\n\treturn fs.unsafeChown(cleaned)\n}\n\n// Creates a new directory (name) at a specified path (p) for the server.\nfunc (fs *Filesystem) CreateDirectory(name string, p string) error {\n\tcleaned, err := fs.SafePath(path.Join(p, name))\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn os.MkdirAll(cleaned, 0o755)\n}\n\n// Rename moves (or renames) a file or directory.\nfunc (fs *Filesystem) Rename(from string, to string) error {\n\tcleanedFrom, err := fs.SafePath(from)\n\tif err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\n\tcleanedTo, err := fs.SafePath(to)\n\tif err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\n\t// If the target file or directory already exists the rename function will fail, so just\n\t// bail out now.\n\tif _, err := os.Stat(cleanedTo); err == nil {\n\t\treturn os.ErrExist\n\t}\n\n\tif cleanedTo == fs.Path() {\n\t\treturn errors.New(\"attempting to rename into an invalid directory space\")\n\t}\n\n\td := strings.TrimSuffix(cleanedTo, path.Base(cleanedTo))\n\t// Ensure that the directory we're moving into exists correctly on the system. Only do this if\n\t// we're not at the root directory level.\n\tif d != fs.Path() {\n\t\tif mkerr := os.MkdirAll(d, 0o755); mkerr != nil {\n\t\t\treturn errors.WithMessage(mkerr, \"failed to create directory structure for file rename\")\n\t\t}\n\t}\n\n\tif err := os.Rename(cleanedFrom, cleanedTo); err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\treturn nil\n}\n\n// Recursively iterates over a file or directory and sets the permissions on all of the\n// underlying files. Iterate over all of the files and directories. If it is a file just\n// go ahead and perform the chown operation. Otherwise dig deeper into the directory until\n// we've run out of directories to dig into.\nfunc (fs *Filesystem) Chown(path string) error {\n\tcleaned, err := fs.SafePath(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn fs.unsafeChown(cleaned)\n}\n\n// unsafeChown chowns the given path, without checking if the path is safe. This should only be used\n// when the path has already been checked.\nfunc (fs *Filesystem) unsafeChown(path string) error {\n\tif fs.isTest {\n\t\treturn nil\n\t}\n\n\tuid := config.Get().System.User.Uid\n\tgid := config.Get().System.User.Gid\n\n\t// Start by just chowning the initial path that we received.\n\tif err := os.Chown(path, uid, gid); err != nil {\n\t\treturn errors.Wrap(err, \"server/filesystem: chown: failed to chown path\")\n\t}\n\n\t// If this is not a directory we can now return from the function, there is nothing\n\t// left that we need to do.\n\tif st, err := os.Stat(path); err != nil || !st.IsDir() {\n\t\treturn nil\n\t}\n\n\t// If this was a directory, begin walking over its contents recursively and ensure that all\n\t// of the subfiles and directories get their permissions updated as well.\n\terr := godirwalk.Walk(path, &godirwalk.Options{\n\t\tUnsorted: true,\n\t\tCallback: func(p string, e *godirwalk.Dirent) error {\n\t\t\t// Do not attempt to chown a symlink. Go's os.Chown function will affect the symlink\n\t\t\t// so if it points to a location outside the data directory the user would be able to\n\t\t\t// (un)intentionally modify that files permissions.\n\t\t\tif e.IsSymlink() {\n\t\t\t\tif e.IsDir() {\n\t\t\t\t\treturn godirwalk.SkipThis\n\t\t\t\t}\n\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\treturn os.Chown(p, uid, gid)\n\t\t},\n\t})\n\treturn errors.Wrap(err, \"server/filesystem: chown: failed to chown during walk function\")\n}\n\nfunc (fs *Filesystem) Chmod(path string, mode os.FileMode) error {\n\tcleaned, err := fs.SafePath(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif fs.isTest {\n\t\treturn nil\n\t}\n\n\tif err := os.Chmod(cleaned, mode); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Begin looping up to 50 times to try and create a unique copy file name. This will take\n// an input of \"file.txt\" and generate \"file copy.txt\". If that name is already taken, it will\n// then try to write \"file copy 2.txt\" and so on, until reaching 50 loops. At that point we\n// won't waste anymore time, just use the current timestamp and make that copy.\n//\n// Could probably make this more efficient by checking if there are any files matching the copy\n// pattern, and trying to find the highest number and then incrementing it by one rather than\n// looping endlessly.\nfunc (fs *Filesystem) findCopySuffix(dir string, name string, extension string) (string, error) {\n\tvar i int\n\tsuffix := \" copy\"\n\n\tfor i = 0; i < 51; i++ {\n\t\tif i > 0 {\n\t\t\tsuffix = \" copy \" + strconv.Itoa(i)\n\t\t}\n\n\t\tn := name + suffix + extension\n\t\t// If we stat the file and it does not exist that means we're good to create the copy. If it\n\t\t// does exist, we'll just continue to the next loop and try again.\n\t\tif _, err := fs.Stat(path.Join(dir, n)); err != nil {\n\t\t\tif !errors.Is(err, os.ErrNotExist) {\n\t\t\t\treturn \"\", err\n\t\t\t}\n\n\t\t\tbreak\n\t\t}\n\n\t\tif i == 50 {\n\t\t\tsuffix = \"copy.\" + time.Now().Format(time.RFC3339)\n\t\t}\n\t}\n\n\treturn name + suffix + extension, nil\n}\n\n// Copies a given file to the same location and appends a suffix to the file to indicate that\n// it has been copied.\nfunc (fs *Filesystem) Copy(p string) error {\n\tcleaned, err := fs.SafePath(p)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts, err := os.Stat(cleaned)\n\tif err != nil {\n\t\treturn err\n\t} else if s.IsDir() || !s.Mode().IsRegular() {\n\t\t// If this is a directory or not a regular file, just throw a not-exist error\n\t\t// since anything calling this function should understand what that means.\n\t\treturn os.ErrNotExist\n\t}\n\n\t// Check that copying this file wouldn't put the server over its limit.\n\tif err := fs.HasSpaceFor(s.Size()); err != nil {\n\t\treturn err\n\t}\n\n\tbase := filepath.Base(cleaned)\n\trelative := strings.TrimSuffix(strings.TrimPrefix(cleaned, fs.Path()), base)\n\textension := filepath.Ext(base)\n\tname := strings.TrimSuffix(base, extension)\n\n\t// Ensure that \".tar\" is also counted as apart of the file extension.\n\t// There might be a better way to handle this for other double file extensions,\n\t// but this is a good workaround for now.\n\tif strings.HasSuffix(name, \".tar\") {\n\t\textension = \".tar\" + extension\n\t\tname = strings.TrimSuffix(name, \".tar\")\n\t}\n\n\tsource, err := os.Open(cleaned)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer source.Close()\n\n\tn, err := fs.findCopySuffix(relative, name, extension)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn fs.Writefile(path.Join(relative, n), source)\n}\n\n// TruncateRootDirectory removes _all_ files and directories from a server's\n// data directory and resets the used disk space to zero.\nfunc (fs *Filesystem) TruncateRootDirectory() error {\n\tif err := os.RemoveAll(fs.Path()); err != nil {\n\t\treturn err\n\t}\n\tif err := os.Mkdir(fs.Path(), 0o755); err != nil {\n\t\treturn err\n\t}\n\tatomic.StoreInt64(&fs.diskUsed, 0)\n\treturn nil\n}\n\n// Delete removes a file or folder from the system. Prevents the user from\n// accidentally (or maliciously) removing their root server data directory.\nfunc (fs *Filesystem) Delete(p string) error {\n\t// This is one of the few (only?) places in the codebase where we're explicitly not using\n\t// the SafePath functionality when working with user provided input. If we did, you would\n\t// not be able to delete a file that is a symlink pointing to a location outside the data\n\t// directory.\n\t//\n\t// We also want to avoid resolving a symlink that points _within_ the data directory and thus\n\t// deleting the actual source file for the symlink rather than the symlink itself. For these\n\t// purposes just resolve the actual file path using filepath.Join() and confirm that the path\n\t// exists within the data directory.\n\tresolved := fs.unsafeFilePath(p)\n\tif !fs.unsafeIsInDataDirectory(resolved) {\n\t\treturn NewBadPathResolution(p, resolved)\n\t}\n\n\t// Block any whoopsies.\n\tif resolved == fs.Path() {\n\t\treturn errors.New(\"cannot delete root server directory\")\n\t}\n\n\tst, err := os.Lstat(resolved)\n\tif err != nil {\n\t\tif !os.IsNotExist(err) {\n\t\t\tfs.error(err).Warn(\"error while attempting to stat file before deletion\")\n\t\t\treturn err\n\t\t}\n\n\t\t// The following logic is used to handle a case where a user attempts to\n\t\t// delete a file that does not exist through a directory symlink.\n\t\t// We don't want to reveal that the file does not exist, so we validate\n\t\t// the path of the symlink and return a bad path error if it is invalid.\n\n\t\t// The requested file or directory doesn't exist, so at this point we\n\t\t// need to iterate up the path chain until we hit a directory that\n\t\t// _does_ exist and can be validated.\n\t\tparts := strings.Split(filepath.Dir(resolved), \"/\")\n\n\t\t// Range over all the path parts and form directory paths from the end\n\t\t// moving up until we have a valid resolution, or we run out of paths to\n\t\t// try.\n\t\tfor k := range parts {\n\t\t\ttry := strings.Join(parts[:(len(parts)-k)], \"/\")\n\t\t\tif !fs.unsafeIsInDataDirectory(try) {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tt, err := filepath.EvalSymlinks(try)\n\t\t\tif err == nil {\n\t\t\t\tif !fs.unsafeIsInDataDirectory(t) {\n\t\t\t\t\treturn NewBadPathResolution(p, t)\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\t// Always return early if the file does not exist.\n\t\treturn nil\n\t}\n\n\t// If the file is not a symlink, we need to check that it is not within a\n\t// symlinked directory that points outside the data directory.\n\tif st.Mode()&os.ModeSymlink == 0 {\n\t\tep, err := filepath.EvalSymlinks(resolved)\n\t\tif err != nil {\n\t\t\tif !os.IsNotExist(err) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else if !fs.unsafeIsInDataDirectory(ep) {\n\t\t\treturn NewBadPathResolution(p, ep)\n\t\t}\n\t}\n\n\tif st.IsDir() {\n\t\tif s, err := fs.DirectorySize(resolved); err == nil {\n\t\t\tfs.addDisk(-s)\n\t\t}\n\t} else {\n\t\tfs.addDisk(-st.Size())\n\t}\n\n\treturn os.RemoveAll(resolved)\n}\n\ntype fileOpener struct {\n\tbusy uint\n}\n\n// Attempts to open a given file up to \"attempts\" number of times, using a backoff. If the file\n// cannot be opened because of a \"text file busy\" error, we will attempt until the number of attempts\n// has been exhaused, at which point we will abort with an error.\nfunc (fo *fileOpener) open(path string, flags int, perm os.FileMode) (*os.File, error) {\n\tfor {\n\t\tf, err := os.OpenFile(path, flags, perm)\n\n\t\t// If there is an error because the text file is busy, go ahead and sleep for a few\n\t\t// hundred milliseconds and then try again up to three times before just returning the\n\t\t// error back to the caller.\n\t\t//\n\t\t// Based on code from: https://github.com/golang/go/issues/22220#issuecomment-336458122\n\t\tif err != nil && fo.busy < 3 && strings.Contains(err.Error(), \"text file busy\") {\n\t\t\ttime.Sleep(100 * time.Millisecond << fo.busy)\n\t\t\tfo.busy++\n\t\t\tcontinue\n\t\t}\n\n\t\treturn f, err\n\t}\n}\n\n// ListDirectory lists the contents of a given directory and returns stat\n// information about each file and folder within it.\nfunc (fs *Filesystem) ListDirectory(p string) ([]Stat, error) {\n\tcleaned, err := fs.SafePath(p)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfiles, err := ioutil.ReadDir(cleaned)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar wg sync.WaitGroup\n\n\t// You must initialize the output of this directory as a non-nil value otherwise\n\t// when it is marshaled into a JSON object you'll just get 'null' back, which will\n\t// break the panel badly.\n\tout := make([]Stat, len(files))\n\n\t// Iterate over all of the files and directories returned and perform an async process\n\t// to get the mime-type for them all.\n\tfor i, file := range files {\n\t\twg.Add(1)\n\n\t\tgo func(idx int, f os.FileInfo) {\n\t\t\tdefer wg.Done()\n\n\t\t\tvar m *mimetype.MIME\n\t\t\td := \"inode/directory\"\n\t\t\tif !f.IsDir() {\n\t\t\t\tcleanedp := filepath.Join(cleaned, f.Name())\n\t\t\t\tif f.Mode()&os.ModeSymlink != 0 {\n\t\t\t\t\tcleanedp, _ = fs.SafePath(filepath.Join(cleaned, f.Name()))\n\t\t\t\t}\n\n\t\t\t\t// Don't try to detect the type on a pipe \u2014 this will just hang the application and\n\t\t\t\t// you'll never get a response back.\n\t\t\t\t//\n\t\t\t\t// @see https://github.com/pterodactyl/panel/issues/4059\n\t\t\t\tif cleanedp != \"\" && f.Mode()&os.ModeNamedPipe == 0 {\n\t\t\t\t\tm, _ = mimetype.DetectFile(filepath.Join(cleaned, f.Name()))\n\t\t\t\t} else {\n\t\t\t\t\t// Just pass this for an unknown type because the file could not safely be resolved within\n\t\t\t\t\t// the server data path.\n\t\t\t\t\td = \"application/octet-stream\"\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tst := Stat{FileInfo: f, Mimetype: d}\n\t\t\tif m != nil {\n\t\t\t\tst.Mimetype = m.String()\n\t\t\t}\n\t\t\tout[idx] = st\n\t\t}(i, file)\n\t}\n\n\twg.Wait()\n\n\t// Sort the output alphabetically to begin with since we've run the output\n\t// through an asynchronous process and the order is gonna be very random.\n\tsort.SliceStable(out, func(i, j int) bool {\n\t\tif out[i].Name() == out[j].Name() || out[i].Name() > out[j].Name() {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t})\n\n\t// Then, sort it so that directories are listed first in the output. Everything\n\t// will continue to be alphabetized at this point.\n\tsort.SliceStable(out, func(i, j int) bool {\n\t\treturn out[i].IsDir()\n\t})\n\n\treturn out, nil\n}\n\nfunc (fs *Filesystem) Chtimes(path string, atime, mtime time.Time) error {\n\tcleaned, err := fs.SafePath(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif fs.isTest {\n\t\treturn nil\n\t}\n\n\tif err := os.Chtimes(cleaned, atime, mtime); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n", "package filesystem\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"errors\"\n\t\"math/rand\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"unicode/utf8\"\n\n\t. \"github.com/franela/goblin\"\n\n\t\"github.com/pterodactyl/wings/config\"\n)\n\nfunc NewFs() (*Filesystem, *rootFs) {\n\tconfig.Set(&config.Configuration{\n\t\tAuthenticationToken: \"abc\",\n\t\tSystem: config.SystemConfiguration{\n\t\t\tRootDirectory:     \"/server\",\n\t\t\tDiskCheckInterval: 150,\n\t\t},\n\t})\n\n\ttmpDir, err := os.MkdirTemp(os.TempDir(), \"pterodactyl\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t// defer os.RemoveAll(tmpDir)\n\n\trfs := rootFs{root: tmpDir}\n\n\trfs.reset()\n\n\tfs := New(filepath.Join(tmpDir, \"/server\"), 0, []string{})\n\tfs.isTest = true\n\n\treturn fs, &rfs\n}\n\ntype rootFs struct {\n\troot string\n}\n\nfunc getFileContent(file *os.File) string {\n\tvar w bytes.Buffer\n\tif _, err := bufio.NewReader(file).WriteTo(&w); err != nil {\n\t\tpanic(err)\n\t}\n\treturn w.String()\n}\n\nfunc (rfs *rootFs) CreateServerFile(p string, c []byte) error {\n\tf, err := os.Create(filepath.Join(rfs.root, \"/server\", p))\n\n\tif err == nil {\n\t\tf.Write(c)\n\t\tf.Close()\n\t}\n\n\treturn err\n}\n\nfunc (rfs *rootFs) CreateServerFileFromString(p string, c string) error {\n\treturn rfs.CreateServerFile(p, []byte(c))\n}\n\nfunc (rfs *rootFs) StatServerFile(p string) (os.FileInfo, error) {\n\treturn os.Stat(filepath.Join(rfs.root, \"/server\", p))\n}\n\nfunc (rfs *rootFs) reset() {\n\tif err := os.RemoveAll(filepath.Join(rfs.root, \"/server\")); err != nil {\n\t\tif !os.IsNotExist(err) {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\n\tif err := os.Mkdir(filepath.Join(rfs.root, \"/server\"), 0o755); err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc TestFilesystem_Openfile(t *testing.T) {\n\tg := Goblin(t)\n\tfs, rfs := NewFs()\n\n\tg.Describe(\"File\", func() {\n\t\tg.It(\"returns custom error when file does not exist\", func() {\n\t\t\t_, _, err := fs.File(\"foo/bar.txt\")\n\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrNotExist)).IsTrue()\n\t\t})\n\n\t\tg.It(\"returns file stat information\", func() {\n\t\t\t_ = rfs.CreateServerFile(\"foo.txt\", []byte(\"hello world\"))\n\n\t\t\tf, st, err := fs.File(\"foo.txt\")\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\tg.Assert(st.Name()).Equal(\"foo.txt\")\n\t\t\tg.Assert(f).IsNotNil()\n\t\t\t_ = f.Close()\n\t\t})\n\n\t\tg.AfterEach(func() {\n\t\t\trfs.reset()\n\t\t})\n\t})\n}\n\nfunc TestFilesystem_Writefile(t *testing.T) {\n\tg := Goblin(t)\n\tfs, rfs := NewFs()\n\n\tg.Describe(\"Open and WriteFile\", func() {\n\t\tbuf := &bytes.Buffer{}\n\n\t\t// Test that a file can be written to the disk and that the disk space used as a result\n\t\t// is updated correctly in the end.\n\t\tg.It(\"can create a new file\", func() {\n\t\t\tr := bytes.NewReader([]byte(\"test file content\"))\n\n\t\t\tg.Assert(atomic.LoadInt64(&fs.diskUsed)).Equal(int64(0))\n\n\t\t\terr := fs.Writefile(\"test.txt\", r)\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\tf, _, err := fs.File(\"test.txt\")\n\t\t\tg.Assert(err).IsNil()\n\t\t\tdefer f.Close()\n\t\t\tg.Assert(getFileContent(f)).Equal(\"test file content\")\n\t\t\tg.Assert(atomic.LoadInt64(&fs.diskUsed)).Equal(r.Size())\n\t\t})\n\n\t\tg.It(\"can create a new file inside a nested directory with leading slash\", func() {\n\t\t\tr := bytes.NewReader([]byte(\"test file content\"))\n\n\t\t\terr := fs.Writefile(\"/some/nested/test.txt\", r)\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\tf, _, err := fs.File(\"/some/nested/test.txt\")\n\t\t\tg.Assert(err).IsNil()\n\t\t\tdefer f.Close()\n\t\t\tg.Assert(getFileContent(f)).Equal(\"test file content\")\n\t\t})\n\n\t\tg.It(\"can create a new file inside a nested directory without a trailing slash\", func() {\n\t\t\tr := bytes.NewReader([]byte(\"test file content\"))\n\n\t\t\terr := fs.Writefile(\"some/../foo/bar/test.txt\", r)\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\tf, _, err := fs.File(\"foo/bar/test.txt\")\n\t\t\tg.Assert(err).IsNil()\n\t\t\tdefer f.Close()\n\t\t\tg.Assert(getFileContent(f)).Equal(\"test file content\")\n\t\t})\n\n\t\tg.It(\"cannot create a file outside the root directory\", func() {\n\t\t\tr := bytes.NewReader([]byte(\"test file content\"))\n\n\t\t\terr := fs.Writefile(\"/some/../foo/../../test.txt\", r)\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\t\t})\n\n\t\tg.It(\"cannot write a file that exceeds the disk limits\", func() {\n\t\t\tatomic.StoreInt64(&fs.diskLimit, 1024)\n\n\t\t\tb := make([]byte, 1025)\n\t\t\t_, err := rand.Read(b)\n\t\t\tg.Assert(err).IsNil()\n\t\t\tg.Assert(len(b)).Equal(1025)\n\n\t\t\tr := bytes.NewReader(b)\n\t\t\terr = fs.Writefile(\"test.txt\", r)\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodeDiskSpace)).IsTrue()\n\t\t})\n\n\t\tg.It(\"truncates the file when writing new contents\", func() {\n\t\t\tr := bytes.NewReader([]byte(\"original data\"))\n\t\t\terr := fs.Writefile(\"test.txt\", r)\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\tr = bytes.NewReader([]byte(\"new data\"))\n\t\t\terr = fs.Writefile(\"test.txt\", r)\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\tf, _, err := fs.File(\"test.txt\")\n\t\t\tg.Assert(err).IsNil()\n\t\t\tdefer f.Close()\n\t\t\tg.Assert(getFileContent(f)).Equal(\"new data\")\n\t\t})\n\n\t\tg.AfterEach(func() {\n\t\t\tbuf.Truncate(0)\n\t\t\trfs.reset()\n\n\t\t\tatomic.StoreInt64(&fs.diskUsed, 0)\n\t\t\tatomic.StoreInt64(&fs.diskLimit, 0)\n\t\t})\n\t})\n}\n\nfunc TestFilesystem_CreateDirectory(t *testing.T) {\n\tg := Goblin(t)\n\tfs, rfs := NewFs()\n\n\tg.Describe(\"CreateDirectory\", func() {\n\t\tg.It(\"should create missing directories automatically\", func() {\n\t\t\terr := fs.CreateDirectory(\"test\", \"foo/bar/baz\")\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\tst, err := rfs.StatServerFile(\"foo/bar/baz/test\")\n\t\t\tg.Assert(err).IsNil()\n\t\t\tg.Assert(st.IsDir()).IsTrue()\n\t\t\tg.Assert(st.Name()).Equal(\"test\")\n\t\t})\n\n\t\tg.It(\"should work with leading and trailing slashes\", func() {\n\t\t\terr := fs.CreateDirectory(\"test\", \"/foozie/barzie/bazzy/\")\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\tst, err := rfs.StatServerFile(\"foozie/barzie/bazzy/test\")\n\t\t\tg.Assert(err).IsNil()\n\t\t\tg.Assert(st.IsDir()).IsTrue()\n\t\t\tg.Assert(st.Name()).Equal(\"test\")\n\t\t})\n\n\t\tg.It(\"should not allow the creation of directories outside the root\", func() {\n\t\t\terr := fs.CreateDirectory(\"test\", \"e/../../something\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\t\t})\n\n\t\tg.It(\"should not increment the disk usage\", func() {\n\t\t\terr := fs.CreateDirectory(\"test\", \"/\")\n\t\t\tg.Assert(err).IsNil()\n\t\t\tg.Assert(atomic.LoadInt64(&fs.diskUsed)).Equal(int64(0))\n\t\t})\n\n\t\tg.AfterEach(func() {\n\t\t\trfs.reset()\n\t\t})\n\t})\n}\n\nfunc TestFilesystem_Rename(t *testing.T) {\n\tg := Goblin(t)\n\tfs, rfs := NewFs()\n\n\tg.Describe(\"Rename\", func() {\n\t\tg.BeforeEach(func() {\n\t\t\tif err := rfs.CreateServerFileFromString(\"source.txt\", \"text content\"); err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t})\n\n\t\tg.It(\"returns an error if the target already exists\", func() {\n\t\t\terr := rfs.CreateServerFileFromString(\"target.txt\", \"taget content\")\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\terr = fs.Rename(\"source.txt\", \"target.txt\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(errors.Is(err, os.ErrExist)).IsTrue()\n\t\t})\n\n\t\tg.It(\"returns an error if the final destination is the root directory\", func() {\n\t\t\terr := fs.Rename(\"source.txt\", \"/\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(errors.Is(err, os.ErrExist)).IsTrue()\n\t\t})\n\n\t\tg.It(\"returns an error if the source destination is the root directory\", func() {\n\t\t\terr := fs.Rename(\"source.txt\", \"/\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(errors.Is(err, os.ErrExist)).IsTrue()\n\t\t})\n\n\t\tg.It(\"does not allow renaming to a location outside the root\", func() {\n\t\t\terr := fs.Rename(\"source.txt\", \"../target.txt\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\t\t})\n\n\t\tg.It(\"does not allow renaming from a location outside the root\", func() {\n\t\t\terr := rfs.CreateServerFileFromString(\"/../ext-source.txt\", \"taget content\")\n\n\t\t\terr = fs.Rename(\"/../ext-source.txt\", \"target.txt\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\t\t})\n\n\t\tg.It(\"allows a file to be renamed\", func() {\n\t\t\terr := fs.Rename(\"source.txt\", \"target.txt\")\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\t_, err = rfs.StatServerFile(\"source.txt\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(errors.Is(err, os.ErrNotExist)).IsTrue()\n\n\t\t\tst, err := rfs.StatServerFile(\"target.txt\")\n\t\t\tg.Assert(err).IsNil()\n\t\t\tg.Assert(st.Name()).Equal(\"target.txt\")\n\t\t\tg.Assert(st.Size()).IsNotZero()\n\t\t})\n\n\t\tg.It(\"allows a folder to be renamed\", func() {\n\t\t\terr := os.Mkdir(filepath.Join(rfs.root, \"/server/source_dir\"), 0o755)\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\terr = fs.Rename(\"source_dir\", \"target_dir\")\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\t_, err = rfs.StatServerFile(\"source_dir\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(errors.Is(err, os.ErrNotExist)).IsTrue()\n\n\t\t\tst, err := rfs.StatServerFile(\"target_dir\")\n\t\t\tg.Assert(err).IsNil()\n\t\t\tg.Assert(st.IsDir()).IsTrue()\n\t\t})\n\n\t\tg.It(\"returns an error if the source does not exist\", func() {\n\t\t\terr := fs.Rename(\"missing.txt\", \"target.txt\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(errors.Is(err, os.ErrNotExist)).IsTrue()\n\t\t})\n\n\t\tg.It(\"creates directories if they are missing\", func() {\n\t\t\terr := fs.Rename(\"source.txt\", \"nested/folder/target.txt\")\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\tst, err := rfs.StatServerFile(\"nested/folder/target.txt\")\n\t\t\tg.Assert(err).IsNil()\n\t\t\tg.Assert(st.Name()).Equal(\"target.txt\")\n\t\t})\n\n\t\tg.AfterEach(func() {\n\t\t\trfs.reset()\n\t\t})\n\t})\n}\n\nfunc TestFilesystem_Copy(t *testing.T) {\n\tg := Goblin(t)\n\tfs, rfs := NewFs()\n\n\tg.Describe(\"Copy\", func() {\n\t\tg.BeforeEach(func() {\n\t\t\tif err := rfs.CreateServerFileFromString(\"source.txt\", \"text content\"); err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\n\t\t\tatomic.StoreInt64(&fs.diskUsed, int64(utf8.RuneCountInString(\"test content\")))\n\t\t})\n\n\t\tg.It(\"should return an error if the source does not exist\", func() {\n\t\t\terr := fs.Copy(\"foo.txt\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(errors.Is(err, os.ErrNotExist)).IsTrue()\n\t\t})\n\n\t\tg.It(\"should return an error if the source is outside the root\", func() {\n\t\t\terr := rfs.CreateServerFileFromString(\"/../ext-source.txt\", \"text content\")\n\n\t\t\terr = fs.Copy(\"../ext-source.txt\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\t\t})\n\n\t\tg.It(\"should return an error if the source directory is outside the root\", func() {\n\t\t\terr := os.MkdirAll(filepath.Join(rfs.root, \"/nested/in/dir\"), 0o755)\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\terr = rfs.CreateServerFileFromString(\"/../nested/in/dir/ext-source.txt\", \"external content\")\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\terr = fs.Copy(\"../nested/in/dir/ext-source.txt\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\n\t\t\terr = fs.Copy(\"nested/in/../../../nested/in/dir/ext-source.txt\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\t\t})\n\n\t\tg.It(\"should return an error if the source is a directory\", func() {\n\t\t\terr := os.Mkdir(filepath.Join(rfs.root, \"/server/dir\"), 0o755)\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\terr = fs.Copy(\"dir\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(errors.Is(err, os.ErrNotExist)).IsTrue()\n\t\t})\n\n\t\tg.It(\"should return an error if there is not space to copy the file\", func() {\n\t\t\tatomic.StoreInt64(&fs.diskLimit, 2)\n\n\t\t\terr := fs.Copy(\"source.txt\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodeDiskSpace)).IsTrue()\n\t\t})\n\n\t\tg.It(\"should create a copy of the file and increment the disk used\", func() {\n\t\t\terr := fs.Copy(\"source.txt\")\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\t_, err = rfs.StatServerFile(\"source.txt\")\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\t_, err = rfs.StatServerFile(\"source copy.txt\")\n\t\t\tg.Assert(err).IsNil()\n\t\t})\n\n\t\tg.It(\"should create a copy of the file with a suffix if a copy already exists\", func() {\n\t\t\terr := fs.Copy(\"source.txt\")\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\terr = fs.Copy(\"source.txt\")\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\tr := []string{\"source.txt\", \"source copy.txt\", \"source copy 1.txt\"}\n\n\t\t\tfor _, name := range r {\n\t\t\t\t_, err = rfs.StatServerFile(name)\n\t\t\t\tg.Assert(err).IsNil()\n\t\t\t}\n\n\t\t\tg.Assert(atomic.LoadInt64(&fs.diskUsed)).Equal(int64(utf8.RuneCountInString(\"test content\")) * 3)\n\t\t})\n\n\t\tg.It(\"should create a copy inside of a directory\", func() {\n\t\t\terr := os.MkdirAll(filepath.Join(rfs.root, \"/server/nested/in/dir\"), 0o755)\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\terr = rfs.CreateServerFileFromString(\"nested/in/dir/source.txt\", \"test content\")\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\terr = fs.Copy(\"nested/in/dir/source.txt\")\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\t_, err = rfs.StatServerFile(\"nested/in/dir/source.txt\")\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\t_, err = rfs.StatServerFile(\"nested/in/dir/source copy.txt\")\n\t\t\tg.Assert(err).IsNil()\n\t\t})\n\n\t\tg.AfterEach(func() {\n\t\t\trfs.reset()\n\n\t\t\tatomic.StoreInt64(&fs.diskUsed, 0)\n\t\t\tatomic.StoreInt64(&fs.diskLimit, 0)\n\t\t})\n\t})\n}\n\nfunc TestFilesystem_Delete(t *testing.T) {\n\tg := Goblin(t)\n\tfs, rfs := NewFs()\n\n\tg.Describe(\"Delete\", func() {\n\t\tg.BeforeEach(func() {\n\t\t\tif err := rfs.CreateServerFileFromString(\"source.txt\", \"test content\"); err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\n\t\t\tatomic.StoreInt64(&fs.diskUsed, int64(utf8.RuneCountInString(\"test content\")))\n\t\t})\n\n\t\tg.It(\"does not delete files outside the root directory\", func() {\n\t\t\terr := rfs.CreateServerFileFromString(\"/../ext-source.txt\", \"external content\")\n\n\t\t\terr = fs.Delete(\"../ext-source.txt\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\t\t})\n\n\t\tg.It(\"does not allow the deletion of the root directory\", func() {\n\t\t\terr := fs.Delete(\"/\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(err.Error()).Equal(\"cannot delete root server directory\")\n\t\t})\n\n\t\tg.It(\"does not return an error if the target does not exist\", func() {\n\t\t\terr := fs.Delete(\"missing.txt\")\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\tst, err := rfs.StatServerFile(\"source.txt\")\n\t\t\tg.Assert(err).IsNil()\n\t\t\tg.Assert(st.Name()).Equal(\"source.txt\")\n\t\t})\n\n\t\tg.It(\"deletes files and subtracts their size from the disk usage\", func() {\n\t\t\terr := fs.Delete(\"source.txt\")\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\t_, err = rfs.StatServerFile(\"source.txt\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(errors.Is(err, os.ErrNotExist)).IsTrue()\n\n\t\t\tg.Assert(atomic.LoadInt64(&fs.diskUsed)).Equal(int64(0))\n\t\t})\n\n\t\tg.It(\"deletes all items inside a directory if the directory is deleted\", func() {\n\t\t\tsources := []string{\n\t\t\t\t\"foo/source.txt\",\n\t\t\t\t\"foo/bar/source.txt\",\n\t\t\t\t\"foo/bar/baz/source.txt\",\n\t\t\t}\n\n\t\t\terr := os.MkdirAll(filepath.Join(rfs.root, \"/server/foo/bar/baz\"), 0o755)\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\tfor _, s := range sources {\n\t\t\t\terr = rfs.CreateServerFileFromString(s, \"test content\")\n\t\t\t\tg.Assert(err).IsNil()\n\t\t\t}\n\n\t\t\tatomic.StoreInt64(&fs.diskUsed, int64(utf8.RuneCountInString(\"test content\")*3))\n\n\t\t\terr = fs.Delete(\"foo\")\n\t\t\tg.Assert(err).IsNil()\n\t\t\tg.Assert(atomic.LoadInt64(&fs.diskUsed)).Equal(int64(0))\n\n\t\t\tfor _, s := range sources {\n\t\t\t\t_, err = rfs.StatServerFile(s)\n\t\t\t\tg.Assert(err).IsNotNil()\n\t\t\t\tg.Assert(errors.Is(err, os.ErrNotExist)).IsTrue()\n\t\t\t}\n\t\t})\n\n\t\tg.It(\"deletes a symlink but not it's target within the root directory\", func() {\n\t\t\t// Symlink to a file inside the root directory.\n\t\t\terr := os.Symlink(filepath.Join(rfs.root, \"server/source.txt\"), filepath.Join(rfs.root, \"server/symlink.txt\"))\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\t// Delete the symlink itself.\n\t\t\terr = fs.Delete(\"symlink.txt\")\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\t// Ensure the symlink was deleted.\n\t\t\t_, err = os.Lstat(filepath.Join(rfs.root, \"server/symlink.txt\"))\n\t\t\tg.Assert(err).IsNotNil()\n\n\t\t\t// Ensure the symlink target still exists.\n\t\t\t_, err = os.Lstat(filepath.Join(rfs.root, \"server/source.txt\"))\n\t\t\tg.Assert(err).IsNil()\n\t\t})\n\n\t\tg.It(\"does not delete files symlinked outside of the root directory\", func() {\n\t\t\t// Create a file outside the root directory.\n\t\t\terr := rfs.CreateServerFileFromString(\"/../source.txt\", \"test content\")\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\t// Create a symlink to the file outside the root directory.\n\t\t\terr = os.Symlink(filepath.Join(rfs.root, \"source.txt\"), filepath.Join(rfs.root, \"/server/symlink.txt\"))\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\t// Delete the symlink. (This should pass as we will delete the symlink itself, not it's target)\n\t\t\terr = fs.Delete(\"symlink.txt\")\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\t// Ensure the file outside the root directory still exists.\n\t\t\t_, err = os.Lstat(filepath.Join(rfs.root, \"source.txt\"))\n\t\t\tg.Assert(err).IsNil()\n\t\t})\n\n\t\tg.It(\"does not delete files symlinked through a directory outside of the root directory\", func() {\n\t\t\t// Create a directory outside the root directory.\n\t\t\terr := os.Mkdir(filepath.Join(rfs.root, \"foo\"), 0o755)\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\t// Create a file inside the directory that is outside the root.\n\t\t\terr = rfs.CreateServerFileFromString(\"/../foo/source.txt\", \"test content\")\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\t// Symlink the directory that is outside the root to a file inside the root.\n\t\t\terr = os.Symlink(filepath.Join(rfs.root, \"foo\"), filepath.Join(rfs.root, \"server/symlink\"))\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\t// Delete a file inside the symlinked directory.\n\t\t\terr = fs.Delete(\"symlink/source.txt\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\n\t\t\t// Ensure the file outside the root directory still exists.\n\t\t\t_, err = os.Lstat(filepath.Join(rfs.root, \"foo/source.txt\"))\n\t\t\tg.Assert(err).IsNil()\n\t\t})\n\n\t\tg.It(\"returns an error when trying to delete a non-existent file symlinked through a directory outside of the root directory\", func() {\n\t\t\t// Create a directory outside the root directory.\n\t\t\terr := os.Mkdir(filepath.Join(rfs.root, \"foo2\"), 0o755)\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\t// Symlink the directory that is outside the root to a file inside the root.\n\t\t\terr = os.Symlink(filepath.Join(rfs.root, \"foo2\"), filepath.Join(rfs.root, \"server/symlink\"))\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\t// Delete a file inside the symlinked directory.\n\t\t\terr = fs.Delete(\"symlink/source.txt\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\t\t})\n\n\t\tg.AfterEach(func() {\n\t\t\trfs.reset()\n\n\t\t\tatomic.StoreInt64(&fs.diskUsed, 0)\n\t\t\tatomic.StoreInt64(&fs.diskLimit, 0)\n\t\t})\n\t})\n}\n"], "filenames": ["server/filesystem/filesystem.go", "server/filesystem/filesystem_test.go"], "buggy_code_start_loc": [390, 539], "buggy_code_end_loc": [429, 539], "fixing_code_start_loc": [389, 540], "fixing_code_end_loc": [468, 614], "type": "CWE-59", "message": "Wings is Pterodactyl's server control plane. This vulnerability can be used to delete files and directories recursively on the host system. This vulnerability can be combined with `GHSA-p8r3-83r8-jwj5` to overwrite files on the host system. In order to use this exploit, an attacker must have an existing \"server\" allocated and controlled by Wings. This vulnerability has been resolved in version `v1.11.4` of Wings, and has been back-ported to the 1.7 release series in `v1.7.4`. Anyone running `v1.11.x` should upgrade to `v1.11.4` and anyone running `v1.7.x` should upgrade to `v1.7.4`. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2023-25168", "sourceIdentifier": "security-advisories@github.com", "published": "2023-02-09T00:16:36.907", "lastModified": "2023-02-16T14:51:28.220", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Wings is Pterodactyl's server control plane. This vulnerability can be used to delete files and directories recursively on the host system. This vulnerability can be combined with `GHSA-p8r3-83r8-jwj5` to overwrite files on the host system. In order to use this exploit, an attacker must have an existing \"server\" allocated and controlled by Wings. This vulnerability has been resolved in version `v1.11.4` of Wings, and has been back-ported to the 1.7 release series in `v1.7.4`. Anyone running `v1.11.x` should upgrade to `v1.11.4` and anyone running `v1.7.x` should upgrade to `v1.7.4`. There are no known workarounds for this issue."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:C/C:N/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.8}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:N/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.6, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.1, "impactScore": 5.8}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-59"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-59"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pterodactyl:wings:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.7.0", "versionEndExcluding": "1.7.4", "matchCriteriaId": "0EE2ACC4-DC54-4A78-AC93-F6CAAA120AB9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pterodactyl:wings:1.11.0:-:*:*:*:*:*:*", "matchCriteriaId": "4C6F3CF4-2AFF-4966-8DD4-D7FE674530C2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pterodactyl:wings:1.11.1:*:*:*:*:*:*:*", "matchCriteriaId": "C72D6216-66D3-49D9-93BA-CCB5B4031569"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pterodactyl:wings:1.11.2:*:*:*:*:*:*:*", "matchCriteriaId": "A7FBA78A-C90F-4800-9AD7-99F3C9CD3125"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pterodactyl:wings:1.11.3:*:*:*:*:*:*:*", "matchCriteriaId": "C2846920-6C69-42F5-A766-61ED4CC923C7"}]}]}], "references": [{"url": "https://github.com/pterodactyl/wings/commit/429ac62dba22997a278bc709df5ac00a5a25d83d", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/pterodactyl/wings/security/advisories/GHSA-66p8-j459-rq63", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/pterodactyl/wings/security/advisories/GHSA-p8r3-83r8-jwj5", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/pterodactyl/wings/commit/429ac62dba22997a278bc709df5ac00a5a25d83d"}}