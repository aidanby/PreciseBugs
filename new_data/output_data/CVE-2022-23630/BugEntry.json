{"buggy_code": ["/*\n * Copyright 2019 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.gradle.api.internal.artifacts.ivyservice.ivyresolve;\n\nimport com.google.common.io.Files;\nimport org.gradle.api.artifacts.ArtifactIdentifier;\nimport org.gradle.api.artifacts.ComponentMetadataSupplierDetails;\nimport org.gradle.api.artifacts.component.ComponentArtifactIdentifier;\nimport org.gradle.api.artifacts.component.ComponentIdentifier;\nimport org.gradle.api.artifacts.component.ModuleComponentIdentifier;\nimport org.gradle.api.internal.artifacts.DefaultArtifactIdentifier;\nimport org.gradle.api.internal.artifacts.ivyservice.ivyresolve.verification.ArtifactVerificationOperation;\nimport org.gradle.api.internal.artifacts.ivyservice.resolveengine.artifact.ResolvableArtifact;\nimport org.gradle.api.internal.artifacts.repositories.metadata.DefaultMetadataFileSource;\nimport org.gradle.api.internal.artifacts.repositories.resolver.MetadataFetchingCost;\nimport org.gradle.api.internal.component.ArtifactType;\nimport org.gradle.api.internal.tasks.DefaultTaskDependency;\nimport org.gradle.api.tasks.TaskDependency;\nimport org.gradle.internal.action.InstantiatingAction;\nimport org.gradle.internal.component.external.model.DefaultModuleComponentArtifactIdentifier;\nimport org.gradle.internal.component.external.model.ModuleComponentArtifactIdentifier;\nimport org.gradle.internal.component.external.model.ModuleComponentArtifactMetadata;\nimport org.gradle.internal.component.external.model.ModuleDependencyMetadata;\nimport org.gradle.internal.component.model.ComponentArtifactMetadata;\nimport org.gradle.internal.component.model.ComponentOverrideMetadata;\nimport org.gradle.internal.component.model.ComponentResolveMetadata;\nimport org.gradle.internal.component.model.ConfigurationMetadata;\nimport org.gradle.internal.component.model.DefaultIvyArtifactName;\nimport org.gradle.internal.component.model.IvyArtifactName;\nimport org.gradle.internal.component.model.ModuleDescriptorArtifactMetadata;\nimport org.gradle.internal.component.model.ModuleSources;\nimport org.gradle.internal.resolve.result.BuildableArtifactResolveResult;\nimport org.gradle.internal.resolve.result.BuildableArtifactSetResolveResult;\nimport org.gradle.internal.resolve.result.BuildableComponentArtifactsResolveResult;\nimport org.gradle.internal.resolve.result.BuildableModuleComponentMetaDataResolveResult;\nimport org.gradle.internal.resolve.result.BuildableModuleVersionListingResolveResult;\nimport org.gradle.internal.resolve.result.DefaultBuildableArtifactResolveResult;\nimport org.gradle.internal.resolve.result.DefaultBuildableModuleComponentMetaDataResolveResult;\n\nimport javax.annotation.Nullable;\nimport java.io.File;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class DependencyVerifyingModuleComponentRepository implements ModuleComponentRepository {\n    private final ModuleComponentRepository delegate;\n    private final ModuleComponentRepositoryAccess localAccess;\n    private final ModuleComponentRepositoryAccess remoteAccess;\n    private final ArtifactVerificationOperation operation;\n\n    public DependencyVerifyingModuleComponentRepository(ModuleComponentRepository delegate, ArtifactVerificationOperation operation, boolean verifySignatures) {\n        this.delegate = delegate;\n        this.localAccess = new VerifyingModuleComponentRepositoryAccess(delegate.getLocalAccess(), verifySignatures);\n        this.remoteAccess = new VerifyingModuleComponentRepositoryAccess(delegate.getRemoteAccess(), verifySignatures);\n        this.operation = operation;\n    }\n\n    @Override\n    public String getId() {\n        return delegate.getId();\n    }\n\n    @Override\n    public String getName() {\n        return delegate.getName();\n    }\n\n    @Override\n    public ModuleComponentRepositoryAccess getLocalAccess() {\n        return localAccess;\n    }\n\n    @Override\n    public ModuleComponentRepositoryAccess getRemoteAccess() {\n        return remoteAccess;\n    }\n\n    @Override\n    public Map<ComponentArtifactIdentifier, ResolvableArtifact> getArtifactCache() {\n        return delegate.getArtifactCache();\n    }\n\n    @Override\n    @Nullable\n    public InstantiatingAction<ComponentMetadataSupplierDetails> getComponentMetadataSupplier() {\n        return delegate.getComponentMetadataSupplier();\n    }\n\n    private class VerifyingModuleComponentRepositoryAccess implements ModuleComponentRepositoryAccess {\n        private final ModuleComponentRepositoryAccess delegate;\n        private final boolean verifySignatures;\n\n        private VerifyingModuleComponentRepositoryAccess(ModuleComponentRepositoryAccess delegate, boolean verifySignatures) {\n            this.delegate = delegate;\n            this.verifySignatures = verifySignatures;\n        }\n\n        @Override\n        public void listModuleVersions(ModuleDependencyMetadata dependency, BuildableModuleVersionListingResolveResult result) {\n            delegate.listModuleVersions(dependency, result);\n        }\n\n        private boolean hasUsableResult(BuildableModuleComponentMetaDataResolveResult result) {\n            return result.hasResult() && result.getState() == BuildableModuleComponentMetaDataResolveResult.State.Resolved;\n        }\n\n        @Override\n        public void resolveComponentMetaData(ModuleComponentIdentifier moduleComponentIdentifier, ComponentOverrideMetadata requestMetaData, BuildableModuleComponentMetaDataResolveResult result) {\n            // For metadata, because the local file can be deleted we have to proceed in two steps\n            // First resolve with a tmp result, and if it's found and that the file is still present\n            // we can perform verification. If it's missing, then we do nothing so that it's downloaded\n            // and verified later.\n            BuildableModuleComponentMetaDataResolveResult tmp = new DefaultBuildableModuleComponentMetaDataResolveResult();\n            delegate.resolveComponentMetaData(moduleComponentIdentifier, requestMetaData, tmp);\n            AtomicBoolean ignore = new AtomicBoolean();\n            if (hasUsableResult(tmp)) {\n                tmp.getMetaData().getSources().withSources(DefaultMetadataFileSource.class, metadataFileSource -> {\n                    ModuleComponentArtifactIdentifier artifact = metadataFileSource.getArtifactId();\n                    if (isExternalArtifactId(artifact)) {\n                        tmp.getMetaData().getSources().withSource(ModuleDescriptorHashModuleSource.class, hashSource -> {\n                            if (hashSource.isPresent()) {\n                                boolean changingModule = requestMetaData.isChanging() || hashSource.get().isChangingModule();\n                                if (!changingModule) {\n                                    File artifactFile = metadataFileSource.getArtifactFile();\n                                    if (artifactFile != null && artifactFile.exists()) {\n                                        // it's possible that the file is null if it has been removed from the cache\n                                        // for example\n                                        operation.onArtifact(ArtifactVerificationOperation.ArtifactKind.METADATA, artifact, artifactFile, () -> maybeFetchSignatureFile(moduleComponentIdentifier, tmp.getMetaData().getSources(), artifact), getName(), getId());\n                                    } else {\n                                        ignore.set(true);\n                                    }\n                                }\n                            }\n                            return null;\n                        });\n                    }\n                });\n            }\n\n            if (!ignore.get()) {\n                delegate.resolveComponentMetaData(moduleComponentIdentifier, requestMetaData, result);\n            }\n        }\n\n        private File maybeFetchSignatureFile(ModuleComponentIdentifier moduleComponentIdentifier, ModuleSources moduleSources, ModuleComponentArtifactIdentifier artifact) {\n            if (!verifySignatures) {\n                return null;\n            }\n            SignatureFileDefaultBuildableArtifactResolveResult signatureResult = new SignatureFileDefaultBuildableArtifactResolveResult();\n            SignatureArtifactMetadata signatureArtifactMetadata = new SignatureArtifactMetadata(moduleComponentIdentifier, artifact);\n            getLocalAccess().resolveArtifact(signatureArtifactMetadata, moduleSources, signatureResult);\n            if (signatureResult.hasResult()) {\n                if (signatureResult.isSuccessful()) {\n                    return signatureResult.getResult();\n                }\n                return null;\n            } else {\n                getRemoteAccess().resolveArtifact(signatureArtifactMetadata, moduleSources, signatureResult);\n            }\n            if (signatureResult.hasResult() && signatureResult.isSuccessful()) {\n                return signatureResult.getResult();\n            }\n            return null;\n        }\n\n        @Override\n        public void resolveArtifacts(ComponentResolveMetadata component, ConfigurationMetadata variant, BuildableComponentArtifactsResolveResult result) {\n            delegate.resolveArtifacts(component, variant, result);\n            if (result.hasResult() && result.isSuccessful()) {\n                for (ComponentArtifactMetadata artifact : variant.getArtifacts()) {\n                    if (isExternalArtifactId(artifact.getId()) && !operation.wasAlreadyProcessed((ModuleComponentArtifactIdentifier) artifact.getId(), getId())) {\n                        resolveArtifact(artifact, component.getSources(), new DefaultBuildableArtifactResolveResult());\n                    }\n                }\n            }\n        }\n\n        @Override\n        public void resolveArtifactsWithType(ComponentResolveMetadata component, ArtifactType artifactType, BuildableArtifactSetResolveResult result) {\n            delegate.resolveArtifactsWithType(component, artifactType, result);\n        }\n\n        @Override\n        public void resolveArtifact(ComponentArtifactMetadata artifact, ModuleSources moduleSources, BuildableArtifactResolveResult result) {\n            delegate.resolveArtifact(artifact, moduleSources, result);\n            if (result.hasResult() && result.isSuccessful()) {\n                ComponentArtifactIdentifier id = artifact.getId();\n                if (isExternalArtifactId(id) && isNotChanging(moduleSources)) {\n                    ModuleComponentArtifactIdentifier mcai = (ModuleComponentArtifactIdentifier) id;\n                    ArtifactVerificationOperation.ArtifactKind artifactKind = determineArtifactKind(artifact);\n                    if (!(result instanceof SignatureFileDefaultBuildableArtifactResolveResult)) {\n                        // signature files are fetched using resolveArtifact, but are checked alongside the main artifact\n                        operation.onArtifact(artifactKind, mcai, result.getResult(), () -> maybeFetchSignatureFile(((ModuleComponentArtifactIdentifier) id).getComponentIdentifier(), moduleSources, mcai), getName(), getId());\n                    }\n                }\n            }\n        }\n\n        private ArtifactVerificationOperation.ArtifactKind determineArtifactKind(ComponentArtifactMetadata artifact) {\n            ArtifactVerificationOperation.ArtifactKind artifactKind = ArtifactVerificationOperation.ArtifactKind.REGULAR;\n            if (artifact instanceof ModuleDescriptorArtifactMetadata) {\n                artifactKind = ArtifactVerificationOperation.ArtifactKind.METADATA;\n            }\n            return artifactKind;\n        }\n\n        private boolean isNotChanging(ModuleSources moduleSources) {\n            return moduleSources.withSource(ModuleDescriptorHashModuleSource.class, source ->\n                source.map(cachingModuleSource -> !cachingModuleSource.isChangingModule()).orElse(true));\n        }\n\n        private boolean isExternalArtifactId(ComponentArtifactIdentifier id) {\n            return id instanceof ModuleComponentArtifactIdentifier;\n        }\n\n        @Override\n        public MetadataFetchingCost estimateMetadataFetchingCost(ModuleComponentIdentifier moduleComponentIdentifier) {\n            return delegate.estimateMetadataFetchingCost(moduleComponentIdentifier);\n        }\n\n        private class SignatureArtifactMetadata implements ModuleComponentArtifactMetadata {\n\n            private final ModuleComponentIdentifier moduleComponentIdentifier;\n            private final ModuleComponentArtifactIdentifier artifactIdentifier;\n\n            public SignatureArtifactMetadata(ModuleComponentIdentifier moduleComponentIdentifier, ModuleComponentArtifactIdentifier artifact) {\n                this.moduleComponentIdentifier = moduleComponentIdentifier;\n                this.artifactIdentifier = artifact.getSignatureArtifactId();\n            }\n\n\n            @Override\n            public ModuleComponentArtifactIdentifier getId() {\n                return artifactIdentifier;\n            }\n\n            @Override\n            public ComponentIdentifier getComponentId() {\n                return moduleComponentIdentifier;\n            }\n\n            @Override\n            public IvyArtifactName getName() {\n                if (artifactIdentifier instanceof DefaultModuleComponentArtifactIdentifier) {\n                    return ((DefaultModuleComponentArtifactIdentifier) artifactIdentifier).getName();\n                }\n                // This is a bit hackish but the mapping from file names to ivy artifact names is completely broken\n                String fileName = artifactIdentifier.getFileName().replace(\"-\" + artifactIdentifier.getComponentIdentifier().getVersion(), \"\");\n                fileName = Files.getNameWithoutExtension(fileName); // removes the .asc\n                DefaultIvyArtifactName base = DefaultIvyArtifactName.forFileName(fileName, null);\n                return new DefaultIvyArtifactName(\n                    base.getName(),\n                    \"asc\",\n                    base.getExtension() + \".asc\"\n                );\n            }\n\n            @Override\n            public TaskDependency getBuildDependencies() {\n                return new DefaultTaskDependency();\n            }\n\n            @Override\n            public ArtifactIdentifier toArtifactIdentifier() {\n                return new DefaultArtifactIdentifier(\n                    new DefaultModuleComponentArtifactIdentifier(\n                        moduleComponentIdentifier, getName()\n                    )\n                );\n            }\n\n        }\n    }\n\n    private static class SignatureFileDefaultBuildableArtifactResolveResult extends DefaultBuildableArtifactResolveResult {\n    }\n}\n", "/*\n * Copyright 2011 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.gradle.api.internal.artifacts.ivyservice.ivyresolve;\n\nimport org.gradle.api.Action;\nimport org.gradle.api.artifacts.component.ComponentIdentifier;\nimport org.gradle.api.artifacts.result.ArtifactResult;\nimport org.gradle.api.attributes.AttributeContainer;\nimport org.gradle.api.attributes.AttributesSchema;\nimport org.gradle.api.internal.artifacts.ComponentMetadataProcessor;\nimport org.gradle.api.internal.artifacts.ComponentMetadataProcessorFactory;\nimport org.gradle.api.internal.artifacts.ImmutableModuleIdentifierFactory;\nimport org.gradle.api.internal.artifacts.MetadataResolutionContext;\nimport org.gradle.api.internal.artifacts.configurations.ResolutionStrategyInternal;\nimport org.gradle.api.internal.artifacts.configurations.dynamicversion.CachePolicy;\nimport org.gradle.api.internal.artifacts.ivyservice.ivyresolve.strategy.VersionComparator;\nimport org.gradle.api.internal.artifacts.ivyservice.ivyresolve.strategy.VersionParser;\nimport org.gradle.api.internal.artifacts.ivyservice.ivyresolve.strategy.VersionSelector;\nimport org.gradle.api.internal.artifacts.ivyservice.ivyresolve.verification.DependencyVerificationOverride;\nimport org.gradle.api.internal.artifacts.ivyservice.modulecache.ModuleRepositoryCacheProvider;\nimport org.gradle.api.internal.artifacts.ivyservice.resolutionstrategy.DefaultComponentSelectionRules;\nimport org.gradle.api.internal.artifacts.repositories.ArtifactResolutionDetails;\nimport org.gradle.api.internal.artifacts.repositories.ContentFilteringRepository;\nimport org.gradle.api.internal.artifacts.repositories.ResolutionAwareRepository;\nimport org.gradle.api.internal.artifacts.result.DefaultResolvedArtifactResult;\nimport org.gradle.api.internal.attributes.ImmutableAttributesFactory;\nimport org.gradle.api.internal.component.ArtifactType;\nimport org.gradle.internal.Actions;\nimport org.gradle.internal.component.model.ComponentArtifactMetadata;\nimport org.gradle.internal.component.model.ComponentOverrideMetadata;\nimport org.gradle.internal.component.model.ComponentResolveMetadata;\nimport org.gradle.internal.component.model.DependencyMetadata;\nimport org.gradle.internal.component.model.ModuleSources;\nimport org.gradle.internal.model.CalculatedValueContainerFactory;\nimport org.gradle.internal.reflect.Instantiator;\nimport org.gradle.internal.resolve.caching.ComponentMetadataSupplierRuleExecutor;\nimport org.gradle.internal.resolve.resolver.ArtifactResolver;\nimport org.gradle.internal.resolve.resolver.ComponentMetaDataResolver;\nimport org.gradle.internal.resolve.resolver.DependencyToComponentIdResolver;\nimport org.gradle.internal.resolve.resolver.OriginArtifactSelector;\nimport org.gradle.internal.resolve.result.BuildableArtifactResolveResult;\nimport org.gradle.internal.resolve.result.BuildableArtifactSetResolveResult;\nimport org.gradle.internal.resolve.result.BuildableComponentIdResolveResult;\nimport org.gradle.internal.resolve.result.BuildableComponentResolveResult;\nimport org.gradle.util.internal.BuildCommencedTimeProvider;\n\nimport javax.annotation.Nullable;\nimport java.util.Collection;\n\npublic class ResolveIvyFactory {\n    private final ModuleRepositoryCacheProvider cacheProvider;\n    private final StartParameterResolutionOverride startParameterResolutionOverride;\n    private final BuildCommencedTimeProvider timeProvider;\n    private final VersionComparator versionComparator;\n    private final ImmutableModuleIdentifierFactory moduleIdentifierFactory;\n    private final RepositoryDisabler repositoryBlacklister;\n    private final VersionParser versionParser;\n    private final CalculatedValueContainerFactory calculatedValueContainerFactory;\n\n    private final DependencyVerificationOverride dependencyVerificationOverride;\n    private final ChangingValueDependencyResolutionListener listener;\n\n    public ResolveIvyFactory(ModuleRepositoryCacheProvider cacheProvider,\n                             StartParameterResolutionOverride startParameterResolutionOverride,\n                             DependencyVerificationOverride dependencyVerificationOverride,\n                             BuildCommencedTimeProvider timeProvider,\n                             VersionComparator versionComparator,\n                             ImmutableModuleIdentifierFactory moduleIdentifierFactory,\n                             RepositoryDisabler repositoryBlacklister,\n                             VersionParser versionParser,\n                             ChangingValueDependencyResolutionListener listener,\n                             CalculatedValueContainerFactory calculatedValueContainerFactory) {\n        this.cacheProvider = cacheProvider;\n        this.startParameterResolutionOverride = startParameterResolutionOverride;\n        this.timeProvider = timeProvider;\n        this.versionComparator = versionComparator;\n        this.moduleIdentifierFactory = moduleIdentifierFactory;\n        this.repositoryBlacklister = repositoryBlacklister;\n        this.versionParser = versionParser;\n        this.dependencyVerificationOverride = dependencyVerificationOverride;\n        this.listener = listener;\n        this.calculatedValueContainerFactory = calculatedValueContainerFactory;\n    }\n\n    public ComponentResolvers create(String resolveContextName,\n                                     ResolutionStrategyInternal resolutionStrategy,\n                                     Collection<? extends ResolutionAwareRepository> repositories,\n                                     ComponentMetadataProcessorFactory metadataProcessor,\n                                     AttributeContainer consumerAttributes,\n                                     AttributesSchema attributesSchema,\n                                     ImmutableAttributesFactory attributesFactory,\n                                     ComponentMetadataSupplierRuleExecutor componentMetadataSupplierRuleExecutor) {\n        if (repositories.isEmpty()) {\n            return new NoRepositoriesResolver();\n        }\n\n        CachePolicy cachePolicy = resolutionStrategy.getCachePolicy();\n        startParameterResolutionOverride.applyToCachePolicy(cachePolicy);\n\n        UserResolverChain moduleResolver = new UserResolverChain(versionComparator, resolutionStrategy.getComponentSelection(), versionParser, consumerAttributes, attributesSchema, attributesFactory, metadataProcessor, componentMetadataSupplierRuleExecutor, cachePolicy, calculatedValueContainerFactory);\n        ParentModuleLookupResolver parentModuleResolver = new ParentModuleLookupResolver(versionComparator, moduleIdentifierFactory, versionParser, consumerAttributes, attributesSchema, attributesFactory, metadataProcessor, componentMetadataSupplierRuleExecutor, cachePolicy, calculatedValueContainerFactory);\n\n        for (ResolutionAwareRepository repository : repositories) {\n            ConfiguredModuleComponentRepository baseRepository = repository.createResolver();\n\n            baseRepository.setComponentResolvers(parentModuleResolver);\n            Instantiator instantiator = baseRepository.getComponentMetadataInstantiator();\n            MetadataResolutionContext metadataResolutionContext = new DefaultMetadataResolutionContext(cachePolicy, instantiator);\n            ComponentMetadataProcessor componentMetadataProcessor = metadataProcessor.createComponentMetadataProcessor(metadataResolutionContext);\n\n            ModuleComponentRepository moduleComponentRepository = baseRepository;\n            if (baseRepository.isLocal()) {\n                moduleComponentRepository = new CachingModuleComponentRepository(moduleComponentRepository, cacheProvider.getInMemoryOnlyCaches(), cachePolicy, timeProvider, componentMetadataProcessor, ChangingValueDependencyResolutionListener.NO_OP);\n                moduleComponentRepository = new LocalModuleComponentRepository(moduleComponentRepository);\n            } else {\n                moduleComponentRepository = startParameterResolutionOverride.overrideModuleVersionRepository(moduleComponentRepository);\n                moduleComponentRepository = new CachingModuleComponentRepository(moduleComponentRepository, cacheProvider.getPersistentCaches(), cachePolicy, timeProvider, componentMetadataProcessor, listener);\n            }\n            moduleComponentRepository = cacheProvider.getResolvedArtifactCaches().provideResolvedArtifactCache(moduleComponentRepository);\n\n            if (baseRepository.isDynamicResolveMode()) {\n                moduleComponentRepository = new IvyDynamicResolveModuleComponentRepository(moduleComponentRepository);\n            }\n            moduleComponentRepository = new ErrorHandlingModuleComponentRepository(moduleComponentRepository, repositoryBlacklister);\n            moduleComponentRepository = filterRepository(repository, moduleComponentRepository, resolveContextName, consumerAttributes);\n            moduleComponentRepository = dependencyVerificationOverride.overrideDependencyVerification(moduleComponentRepository, resolveContextName, resolutionStrategy);\n            moduleResolver.add(moduleComponentRepository);\n            parentModuleResolver.add(moduleComponentRepository);\n        }\n\n        return moduleResolver;\n    }\n\n    private ModuleComponentRepository filterRepository(ResolutionAwareRepository repository, ModuleComponentRepository moduleComponentRepository, String consumerName, AttributeContainer consumerAttributes) {\n        Action<? super ArtifactResolutionDetails> filter = Actions.doNothing();\n        if (repository instanceof ContentFilteringRepository) {\n            filter = ((ContentFilteringRepository) repository).getContentFilter();\n        }\n        moduleComponentRepository = FilteredModuleComponentRepository.of(moduleComponentRepository, filter, consumerName, consumerAttributes);\n        return moduleComponentRepository;\n    }\n\n    public ArtifactResult verifiedArtifact(DefaultResolvedArtifactResult defaultResolvedArtifactResult) {\n        return dependencyVerificationOverride.verifiedArtifact(defaultResolvedArtifactResult);\n    }\n\n    /**\n     * Provides access to the top-level resolver chain for looking up parent modules when parsing module descriptor files.\n     */\n    private static class ParentModuleLookupResolver implements ComponentResolvers, DependencyToComponentIdResolver, ComponentMetaDataResolver, ArtifactResolver {\n        private final UserResolverChain delegate;\n\n        public ParentModuleLookupResolver(VersionComparator versionComparator, ImmutableModuleIdentifierFactory moduleIdentifierFactory, VersionParser versionParser, AttributeContainer consumerAttributes, AttributesSchema attributesSchema, ImmutableAttributesFactory attributesFactory, ComponentMetadataProcessorFactory componentMetadataProcessorFactory, ComponentMetadataSupplierRuleExecutor componentMetadataSupplierRuleExecutor, CachePolicy cachePolicy, CalculatedValueContainerFactory calculatedValueContainerFactory) {\n            this.delegate = new UserResolverChain(versionComparator, new DefaultComponentSelectionRules(moduleIdentifierFactory), versionParser, consumerAttributes, attributesSchema, attributesFactory, componentMetadataProcessorFactory, componentMetadataSupplierRuleExecutor, cachePolicy, calculatedValueContainerFactory);\n        }\n\n        public void add(ModuleComponentRepository moduleComponentRepository) {\n            delegate.add(moduleComponentRepository);\n        }\n\n        @Override\n        public DependencyToComponentIdResolver getComponentIdResolver() {\n            return this;\n        }\n\n        @Override\n        public ComponentMetaDataResolver getComponentResolver() {\n            return this;\n        }\n\n        @Override\n        public ArtifactResolver getArtifactResolver() {\n            return this;\n        }\n\n        @Override\n        public OriginArtifactSelector getArtifactSelector() {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public void resolve(DependencyMetadata dependency, VersionSelector acceptor, @Nullable VersionSelector rejector, BuildableComponentIdResolveResult result) {\n            delegate.getComponentIdResolver().resolve(dependency, acceptor, rejector, result);\n        }\n\n        @Override\n        public void resolve(final ComponentIdentifier identifier, final ComponentOverrideMetadata componentOverrideMetadata, final BuildableComponentResolveResult result) {\n            delegate.getComponentResolver().resolve(identifier, componentOverrideMetadata, result);\n        }\n\n        @Override\n        public boolean isFetchingMetadataCheap(ComponentIdentifier identifier) {\n            return delegate.getComponentResolver().isFetchingMetadataCheap(identifier);\n        }\n\n        @Override\n        public void resolveArtifactsWithType(final ComponentResolveMetadata component, final ArtifactType artifactType, final BuildableArtifactSetResolveResult result) {\n            delegate.getArtifactResolver().resolveArtifactsWithType(component, artifactType, result);\n        }\n\n        @Override\n        public void resolveArtifact(final ComponentArtifactMetadata artifact, final ModuleSources moduleSources, final BuildableArtifactResolveResult result) {\n            delegate.getArtifactResolver().resolveArtifact(artifact, moduleSources, result);\n        }\n    }\n\n    private static class DefaultMetadataResolutionContext implements MetadataResolutionContext {\n\n        private final CachePolicy cachePolicy;\n        private final Instantiator instantiator;\n\n        private DefaultMetadataResolutionContext(CachePolicy cachePolicy, Instantiator instantiator) {\n            this.cachePolicy = cachePolicy;\n            this.instantiator = instantiator;\n        }\n\n        @Override\n        public CachePolicy getCachePolicy() {\n            return cachePolicy;\n        }\n\n        @Override\n        public Instantiator getInjectingInstantiator() {\n            return instantiator;\n        }\n    }\n}\n", "/*\n * Copyright 2019 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.gradle.api.internal.artifacts.ivyservice.ivyresolve.verification;\n\nimport org.gradle.internal.Factory;\nimport org.gradle.internal.component.external.model.ModuleComponentArtifactIdentifier;\n\nimport java.io.File;\n\npublic interface ArtifactVerificationOperation {\n    void onArtifact(ArtifactKind kind, ModuleComponentArtifactIdentifier artifact, File mainFile, Factory<File> signatureFile, String repositoryName, String repositoryId);\n    boolean wasAlreadyProcessed(ModuleComponentArtifactIdentifier artifact, String repositoryId);\n\n    enum ArtifactKind {\n        METADATA,\n        REGULAR\n    }\n}\n", "/*\n * Copyright 2019 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.gradle.api.internal.artifacts.ivyservice.ivyresolve.verification;\n\nimport com.google.common.collect.LinkedHashMultimap;\nimport com.google.common.collect.Multimap;\nimport com.google.common.collect.Queues;\nimport com.google.common.collect.Sets;\nimport org.gradle.api.artifacts.component.ComponentArtifactIdentifier;\nimport org.gradle.api.artifacts.component.ModuleComponentIdentifier;\nimport org.gradle.api.artifacts.result.ResolvedArtifactResult;\nimport org.gradle.api.artifacts.result.ResolvedVariantResult;\nimport org.gradle.api.artifacts.verification.DependencyVerificationMode;\nimport org.gradle.api.component.Artifact;\nimport org.gradle.api.internal.DocumentationRegistry;\nimport org.gradle.api.internal.artifacts.configurations.ResolutionStrategyInternal;\nimport org.gradle.api.internal.artifacts.ivyservice.ivyresolve.DependencyVerifyingModuleComponentRepository;\nimport org.gradle.api.internal.artifacts.ivyservice.ivyresolve.ModuleComponentRepository;\nimport org.gradle.api.internal.artifacts.ivyservice.ivyresolve.verification.report.DependencyVerificationReportWriter;\nimport org.gradle.api.internal.artifacts.ivyservice.ivyresolve.verification.report.VerificationReport;\nimport org.gradle.api.internal.artifacts.verification.DependencyVerificationException;\nimport org.gradle.api.internal.artifacts.verification.serializer.DependencyVerificationsXmlReader;\nimport org.gradle.api.internal.artifacts.verification.signatures.BuildTreeDefinedKeys;\nimport org.gradle.api.internal.artifacts.verification.signatures.SignatureVerificationService;\nimport org.gradle.api.internal.artifacts.verification.signatures.SignatureVerificationServiceFactory;\nimport org.gradle.api.internal.artifacts.verification.verifier.DependencyVerifier;\nimport org.gradle.api.internal.properties.GradleProperties;\nimport org.gradle.api.logging.Logger;\nimport org.gradle.api.logging.Logging;\nimport org.gradle.internal.Factory;\nimport org.gradle.internal.UncheckedException;\nimport org.gradle.internal.component.external.model.ModuleComponentArtifactIdentifier;\nimport org.gradle.internal.concurrent.Stoppable;\nimport org.gradle.internal.hash.ChecksumService;\nimport org.gradle.internal.logging.ConsoleRenderer;\nimport org.gradle.internal.operations.BuildOperationContext;\nimport org.gradle.internal.operations.BuildOperationDescriptor;\nimport org.gradle.internal.operations.BuildOperationExecutor;\nimport org.gradle.internal.operations.RunnableBuildOperation;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.net.URI;\nimport java.util.Collection;\nimport java.util.Deque;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class ChecksumAndSignatureVerificationOverride implements DependencyVerificationOverride, ArtifactVerificationOperation, Stoppable {\n    private final static Logger LOGGER = Logging.getLogger(ChecksumAndSignatureVerificationOverride.class);\n\n    private final DependencyVerifier verifier;\n    private final Multimap<ModuleComponentArtifactIdentifier, RepositoryAwareVerificationFailure> failures = LinkedHashMultimap.create();\n    private final BuildOperationExecutor buildOperationExecutor;\n    private final ChecksumService checksumService;\n    private final SignatureVerificationService signatureVerificationService;\n    private final DependencyVerificationMode verificationMode;\n    private final Set<String> verificationQueries = Sets.newConcurrentHashSet();\n    private final Deque<VerificationEvent> verificationEvents = Queues.newArrayDeque();\n    private final AtomicBoolean closed = new AtomicBoolean();\n    private final AtomicBoolean hasFatalFailure = new AtomicBoolean();\n    private final DependencyVerificationReportWriter reportWriter;\n\n    public ChecksumAndSignatureVerificationOverride(BuildOperationExecutor buildOperationExecutor,\n                                                    File gradleUserHome,\n                                                    File verificationsFile,\n                                                    BuildTreeDefinedKeys keyrings,\n                                                    ChecksumService checksumService,\n                                                    SignatureVerificationServiceFactory signatureVerificationServiceFactory,\n                                                    DependencyVerificationMode verificationMode,\n                                                    DocumentationRegistry documentationRegistry,\n                                                    File reportsDirectory,\n                                                    Factory<GradleProperties> gradlePropertiesFactory) {\n        this.buildOperationExecutor = buildOperationExecutor;\n        this.checksumService = checksumService;\n        this.verificationMode = verificationMode;\n        try {\n            this.verifier = DependencyVerificationsXmlReader.readFromXml(\n                new FileInputStream(verificationsFile)\n            );\n            this.reportWriter = new DependencyVerificationReportWriter(gradleUserHome.toPath(), documentationRegistry, verificationsFile, verifier.getSuggestedWriteFlags(), reportsDirectory, gradlePropertiesFactory);\n        } catch (FileNotFoundException e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        } catch (DependencyVerificationException e) {\n            throw new DependencyVerificationException(\"Unable to read dependency verification metadata from \" + verificationsFile, e.getCause());\n        }\n        this.signatureVerificationService = signatureVerificationServiceFactory.create(keyrings, keyServers(), verifier.getConfiguration().isUseKeyServers());\n    }\n\n    private List<URI> keyServers() {\n        return DefaultKeyServers.getOrDefaults(verifier.getConfiguration().getKeyServers());\n    }\n\n    @Override\n    public void onArtifact(ArtifactKind kind, ModuleComponentArtifactIdentifier artifact, File mainFile, Factory<File> signatureFile, String repositoryName, String repositoryId) {\n        if (verificationQueries.add(getVerificationQuery(artifact, repositoryId))) {\n            VerificationEvent event = new VerificationEvent(kind, artifact, mainFile, signatureFile, repositoryName);\n            synchronized (verificationEvents) {\n                verificationEvents.add(event);\n            }\n        }\n    }\n\n    @Override\n    public boolean wasAlreadyProcessed(ModuleComponentArtifactIdentifier artifact, String repositoryId) {\n        return verificationQueries.contains(getVerificationQuery(artifact, repositoryId));\n    }\n\n    private void verifyConcurrently() {\n        hasFatalFailure.set(false);\n        synchronized (verificationEvents) {\n            if (verificationEvents.isEmpty()) {\n                return;\n            }\n        }\n        if (closed.get()) {\n            LOGGER.debug(\"Cannot perform verification of all dependencies because the verification service has been shutdown. Under normal circumstances this shouldn't happen unless a user buildFinished was added in an unexpected way.\");\n            return;\n        }\n        buildOperationExecutor.runAll(queue -> {\n            VerificationEvent event;\n            synchronized (verificationEvents) {\n                while ((event = verificationEvents.poll()) != null) {\n                    VerificationEvent ve = event;\n                    queue.add(new RunnableBuildOperation() {\n                        @Override\n                        public void run(BuildOperationContext context) {\n                            verifier.verify(checksumService, signatureVerificationService, ve.kind, ve.artifact, ve.mainFile, ve.signatureFile.create(), f -> {\n                                synchronized (failures) {\n                                    failures.put(ve.artifact, new RepositoryAwareVerificationFailure(f, ve.repositoryName));\n                                }\n                                if (f.isFatal()) {\n                                    hasFatalFailure.set(true);\n                                }\n                            });\n                        }\n\n                        @Override\n                        public BuildOperationDescriptor.Builder description() {\n                            return BuildOperationDescriptor.displayName(\"Dependency verification\")\n                                .progressDisplayName(\"Verifying \" + ve.artifact);\n                        }\n                    });\n                }\n            }\n        });\n\n    }\n\n    @Override\n    public ModuleComponentRepository overrideDependencyVerification(ModuleComponentRepository original, String resolveContextName, ResolutionStrategyInternal resolutionStrategy) {\n        return new DependencyVerifyingModuleComponentRepository(original, this, verifier.getConfiguration().isVerifySignatures());\n    }\n\n    @Override\n    public void artifactsAccessed(String displayName) {\n        verifyConcurrently();\n        synchronized (failures) {\n            if (hasFatalFailure.get() && !failures.isEmpty()) {\n                // There are fatal failures, but not necessarily on all artifacts so we first filter out\n                // the artifacts which only have not fatal errors\n                failures.asMap().entrySet().removeIf(entry -> {\n                    Collection<RepositoryAwareVerificationFailure> value = entry.getValue();\n                    return value.stream().noneMatch(wrapper -> wrapper.getFailure().isFatal());\n                });\n                VerificationReport report = reportWriter.generateReport(displayName, failures, verifier.getConfiguration().isUseKeyServers());\n                String errorMessage = buildConsoleErrorMessage(report);\n                if (verificationMode == DependencyVerificationMode.LENIENT) {\n                    LOGGER.error(errorMessage);\n                    failures.clear();\n                    hasFatalFailure.set(false);\n                } else {\n                    throw new DependencyVerificationException(errorMessage);\n                }\n            }\n        }\n    }\n\n    public String buildConsoleErrorMessage(VerificationReport report) {\n        String errorMessage = report.getSummary();\n        String htmlReport = new ConsoleRenderer().asClickableFileUrl(report.getHtmlReport());\n        errorMessage += \"\\n\\nOpen this report for more details: \" + htmlReport;\n        return errorMessage;\n    }\n\n    @Override\n    public ResolvedArtifactResult verifiedArtifact(ResolvedArtifactResult artifact) {\n        return new ResolvedArtifactResult() {\n            @Override\n            public File getFile() {\n                artifactsAccessed(artifact.getVariant().getDisplayName());\n                return artifact.getFile();\n            }\n\n            @Override\n            public ResolvedVariantResult getVariant() {\n                return artifact.getVariant();\n            }\n\n            @Override\n            public ComponentArtifactIdentifier getId() {\n                return artifact.getId();\n            }\n\n            @Override\n            public Class<? extends Artifact> getType() {\n                return artifact.getType();\n            }\n        };\n    }\n\n    @Override\n    public void stop() {\n        closed.set(true);\n        signatureVerificationService.stop();\n    }\n\n    private String getVerificationQuery(ModuleComponentArtifactIdentifier artifactIdentifier, String repositoryId) {\n        ModuleComponentIdentifier componentIdentifier = artifactIdentifier.getComponentIdentifier();\n        return componentIdentifier.getVersion() + \":\" + componentIdentifier.getModule() + \":\" + componentIdentifier.getGroup() + \":\" + artifactIdentifier.getFileName() + \":\" + repositoryId;\n    }\n\n    private static class VerificationEvent {\n        private final ArtifactKind kind;\n        private final ModuleComponentArtifactIdentifier artifact;\n        private final File mainFile;\n        private final Factory<File> signatureFile;\n        private final String repositoryName;\n\n        private VerificationEvent(ArtifactKind kind, ModuleComponentArtifactIdentifier artifact, File mainFile, Factory<File> signatureFile, String repositoryName) {\n            this.kind = kind;\n            this.artifact = artifact;\n            this.mainFile = mainFile;\n            this.signatureFile = signatureFile;\n            this.repositoryName = repositoryName;\n        }\n    }\n}\n", "/*\n * Copyright 2019 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.gradle.api.internal.artifacts.ivyservice.ivyresolve.verification.writer;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Sets;\nimport org.bouncycastle.bcpg.ArmoredOutputStream;\nimport org.bouncycastle.openpgp.PGPPublicKey;\nimport org.bouncycastle.openpgp.PGPPublicKeyRing;\nimport org.gradle.api.Action;\nimport org.gradle.api.Project;\nimport org.gradle.api.UncheckedIOException;\nimport org.gradle.api.artifacts.ArtifactView;\nimport org.gradle.api.artifacts.Configuration;\nimport org.gradle.api.artifacts.component.ModuleComponentIdentifier;\nimport org.gradle.api.internal.artifacts.configurations.ResolutionStrategyInternal;\nimport org.gradle.api.internal.artifacts.ivyservice.ivyresolve.DependencyVerifyingModuleComponentRepository;\nimport org.gradle.api.internal.artifacts.ivyservice.ivyresolve.ModuleComponentRepository;\nimport org.gradle.api.internal.artifacts.ivyservice.ivyresolve.verification.ArtifactVerificationOperation;\nimport org.gradle.api.internal.artifacts.ivyservice.ivyresolve.verification.DefaultKeyServers;\nimport org.gradle.api.internal.artifacts.ivyservice.ivyresolve.verification.DependencyVerificationOverride;\nimport org.gradle.api.internal.artifacts.ivyservice.ivyresolve.verification.utils.PGPUtils;\nimport org.gradle.api.internal.artifacts.verification.DependencyVerificationException;\nimport org.gradle.api.internal.artifacts.verification.model.ChecksumKind;\nimport org.gradle.api.internal.artifacts.verification.model.IgnoredKey;\nimport org.gradle.api.internal.artifacts.verification.serializer.DependencyVerificationsXmlReader;\nimport org.gradle.api.internal.artifacts.verification.serializer.DependencyVerificationsXmlWriter;\nimport org.gradle.api.internal.artifacts.verification.signatures.BuildTreeDefinedKeys;\nimport org.gradle.api.internal.artifacts.verification.signatures.SignatureVerificationResultBuilder;\nimport org.gradle.api.internal.artifacts.verification.signatures.SignatureVerificationService;\nimport org.gradle.api.internal.artifacts.verification.signatures.SignatureVerificationServiceFactory;\nimport org.gradle.api.internal.artifacts.verification.verifier.DependencyVerificationConfiguration;\nimport org.gradle.api.internal.artifacts.verification.verifier.DependencyVerifier;\nimport org.gradle.api.internal.artifacts.verification.verifier.DependencyVerifierBuilder;\nimport org.gradle.api.internal.project.ProjectInternal;\nimport org.gradle.api.invocation.Gradle;\nimport org.gradle.api.logging.Logger;\nimport org.gradle.api.logging.Logging;\nimport org.gradle.internal.Factory;\nimport org.gradle.internal.UncheckedException;\nimport org.gradle.internal.component.external.model.ModuleComponentArtifactIdentifier;\nimport org.gradle.internal.deprecation.DeprecatableConfiguration;\nimport org.gradle.internal.hash.ChecksumService;\nimport org.gradle.internal.operations.BuildOperationContext;\nimport org.gradle.internal.operations.BuildOperationDescriptor;\nimport org.gradle.internal.operations.BuildOperationExecutor;\nimport org.gradle.internal.operations.BuildOperationQueue;\nimport org.gradle.internal.operations.RunnableBuildOperation;\nimport org.gradle.security.internal.Fingerprint;\nimport org.gradle.security.internal.PublicKeyResultBuilder;\nimport org.gradle.security.internal.PublicKeyService;\nimport org.gradle.security.internal.SecuritySupport;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.math.BigInteger;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport static com.google.common.io.Files.getNameWithoutExtension;\n\npublic class WriteDependencyVerificationFile implements DependencyVerificationOverride, ArtifactVerificationOperation {\n    private static final Logger LOGGER = Logging.getLogger(WriteDependencyVerificationFile.class);\n    private static final Action<ArtifactView.ViewConfiguration> MODULE_COMPONENT_FILES = conf -> {\n        conf.componentFilter(id -> id instanceof ModuleComponentIdentifier);\n        conf.setLenient(true);\n    };\n    private static final String PGP = \"pgp\";\n    private static final String MD5 = \"md5\";\n    private static final String SHA1 = \"sha1\";\n    private static final String SHA256 = \"sha256\";\n    private static final String SHA512 = \"sha512\";\n    private static final Set<String> SUPPORTED_CHECKSUMS = ImmutableSet.of(MD5, SHA1, SHA256, SHA512, PGP);\n    private static final Set<String> SECURE_CHECKSUMS = ImmutableSet.of(SHA256, SHA512, PGP);\n    private static final String PGP_VERIFICATION_FAILED = \"PGP verification failed\";\n    private static final String KEY_NOT_DOWNLOADED = \"Key couldn't be downloaded from any key server\";\n\n    private final DependencyVerifierBuilder verificationsBuilder = new DependencyVerifierBuilder();\n    private final BuildOperationExecutor buildOperationExecutor;\n    private final List<String> checksums;\n    private final Set<VerificationEntry> entriesToBeWritten = Sets.newLinkedHashSetWithExpectedSize(512);\n    private final ChecksumService checksumService;\n    private final File verificationFile;\n    private final BuildTreeDefinedKeys keyrings;\n    private final SignatureVerificationServiceFactory signatureVerificationServiceFactory;\n    private final boolean isDryRun;\n    private final boolean generatePgpInfo;\n    private final boolean isExportKeyring;\n\n    private boolean hasMissingSignatures = false;\n    private boolean hasMissingKeys = false;\n    private boolean hasFailedVerification = false;\n\n    public WriteDependencyVerificationFile(\n        File verificationFile,\n        BuildTreeDefinedKeys keyrings,\n        BuildOperationExecutor buildOperationExecutor,\n        List<String> checksums,\n        ChecksumService checksumService,\n        SignatureVerificationServiceFactory signatureVerificationServiceFactory,\n        boolean isDryRun,\n        boolean exportKeyRing\n    ) {\n        this.buildOperationExecutor = buildOperationExecutor;\n        this.checksums = checksums;\n        this.checksumService = checksumService;\n        this.verificationFile = verificationFile;\n        this.keyrings = keyrings;\n        this.signatureVerificationServiceFactory = signatureVerificationServiceFactory;\n        this.isDryRun = isDryRun;\n        this.generatePgpInfo = checksums.contains(PGP);\n        this.isExportKeyring = exportKeyRing;\n    }\n\n    private void validateChecksums() {\n        assertSupportedChecksums();\n        warnAboutInsecureChecksums();\n    }\n\n    private void assertSupportedChecksums() {\n        for (String checksum : checksums) {\n            if (!SUPPORTED_CHECKSUMS.contains(checksum)) {\n                // we cannot throw an exception at this stage because this happens too early\n                // in the build and the user feedback isn't great (\"cannot create service blah!\")\n                LOGGER.warn(\"Invalid checksum type: '\" + checksum + \"'. You must choose one or more in \" + SUPPORTED_CHECKSUMS);\n            }\n        }\n        if (checksums.isEmpty()) {\n            throw new DependencyVerificationException(\"You must specify at least one checksum type to use. You must choose one or more in \" + SUPPORTED_CHECKSUMS);\n        }\n        assertPgpHasChecksumFallback(checksums);\n    }\n\n    private void assertPgpHasChecksumFallback(List<String> kinds) {\n        if (kinds.size() == 1 && PGP.equals(kinds.get(0))) {\n            throw new DependencyVerificationException(\"Generating a file with signature verification requires at least one checksum type (sha256 or sha512) as fallback.\");\n        }\n    }\n\n    private void warnAboutInsecureChecksums() {\n        if (checksums.stream().noneMatch(SECURE_CHECKSUMS::contains)) {\n            LOGGER.warn(\"You chose to generate \" + String.join(\" and \", checksums) + \" checksums but they are all considered insecure. You should consider adding at least one of \" + String.join(\" or \", SECURE_CHECKSUMS) + \".\");\n        }\n    }\n\n    @Override\n    public ModuleComponentRepository overrideDependencyVerification(ModuleComponentRepository original, String resolveContextName, ResolutionStrategyInternal resolutionStrategy) {\n        return new DependencyVerifyingModuleComponentRepository(original, this, generatePgpInfo);\n    }\n\n    @Override\n    public void buildFinished(Gradle gradle) {\n        ensureOutputDirCreated();\n        maybeReadExistingFile();\n        // when we generate the verification file, we intentionally ignore if the \"use key servers\" flag is false\n        // because otherwise it forces the user to remove the option in the XML file, generate, then switch it back.\n        boolean offline = gradle.getStartParameter().isOffline();\n        SignatureVerificationService signatureVerificationService = signatureVerificationServiceFactory.create(\n            keyrings,\n            DefaultKeyServers.getOrDefaults(verificationsBuilder.getKeyServers()),\n            !offline\n        );\n        if (!verificationsBuilder.isUseKeyServers() && !offline) {\n            LOGGER.lifecycle(\"Will use key servers to download missing keys. If you really want to ignore key servers when generating the verification file, you can use the --offline flag in addition\");\n        }\n        try {\n            validateChecksums();\n            resolveAllConfigurationsConcurrently(gradle);\n            computeChecksumsConcurrently(signatureVerificationService);\n            writeEntriesSerially();\n            serializeResult(signatureVerificationService);\n        } catch (IOException e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        } finally {\n            signatureVerificationService.stop();\n        }\n    }\n\n    public boolean ensureOutputDirCreated() {\n        return verificationFile.getParentFile().mkdirs();\n    }\n\n    private void serializeResult(SignatureVerificationService signatureVerificationService) throws IOException {\n        File out = isDryRun\n            ? dryRunVerificationFile()\n            : verificationFile;\n        if (generatePgpInfo) {\n            verificationsBuilder.setVerifySignatures(true);\n        }\n        DependencyVerifier verifier = verificationsBuilder.build();\n        DependencyVerificationsXmlWriter.serialize(\n            verifier,\n            new FileOutputStream(out)\n        );\n        if (isExportKeyring) {\n            exportKeys(signatureVerificationService, verifier);\n        }\n    }\n\n    private File dryRunVerificationFile() {\n        return new File(verificationFile.getParent(), getNameWithoutExtension(verificationFile.getName()) + \".dryrun.xml\");\n    }\n\n    private void exportKeys(SignatureVerificationService signatureVerificationService, DependencyVerifier verifier) throws IOException {\n        BuildTreeDefinedKeys keys = isDryRun ? keyrings.dryRun() : keyrings;\n        Set<String> keysToExport = Sets.newHashSet();\n        verifier.getConfiguration()\n            .getTrustedKeys()\n            .stream()\n            .map(DependencyVerificationConfiguration.TrustedKey::getKeyId)\n            .forEach(keysToExport::add);\n        verifier.getConfiguration()\n            .getIgnoredKeys()\n            .stream()\n            .map(IgnoredKey::getKeyId)\n            .forEach(keysToExport::add);\n        verifier.getVerificationMetadata()\n            .stream()\n            .flatMap(md -> md.getArtifactVerifications().stream())\n            .flatMap(avm -> Stream.concat(avm.getTrustedPgpKeys().stream(), avm.getIgnoredPgpKeys().stream().map(IgnoredKey::getKeyId)))\n            .forEach(keysToExport::add);\n        exportKeyRingCollection(signatureVerificationService.getPublicKeyService(), keys, keysToExport);\n    }\n\n    private void maybeReadExistingFile() {\n        if (verificationFile.exists()) {\n            LOGGER.info(\"Found dependency verification metadata file, updating\");\n            try {\n                DependencyVerificationsXmlReader.readFromXml(new FileInputStream(verificationFile), verificationsBuilder);\n            } catch (FileNotFoundException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n    }\n\n    private void writeEntriesSerially() {\n        AtomicReference<PgpEntry> previousEntry = new AtomicReference<>();\n        entriesToBeWritten.stream()\n            .sorted()\n            .filter(this::shouldWriteEntry)\n            .forEachOrdered(e -> registerEntryToBuilder(e, previousEntry));\n        printWarnings();\n    }\n\n    private void printWarnings() {\n        if (hasMissingKeys || hasFailedVerification) {\n            StringBuilder sb = new StringBuilder(\"A verification file was generated but some problems were discovered:\\n\");\n            if (hasMissingSignatures) {\n                sb.append(\"   - some artifacts aren't signed or the signature couldn't be retrieved.\");\n                sb.append(\"\\n\");\n            }\n            if (hasMissingKeys) {\n                sb.append(\"   - some keys couldn't be downloaded. They were automatically added as ignored keys but you should review if this is acceptable. Look for entries with the following comment: \");\n                sb.append(KEY_NOT_DOWNLOADED);\n                sb.append(\"\\n\");\n            }\n            if (hasFailedVerification) {\n                sb.append(\"   - some signature verification failed. Checksums were generated for those artifacts but you MUST check if there's an actual problem. Look for entries with the following comment: \");\n                sb.append(PGP_VERIFICATION_FAILED);\n                sb.append(\"\\n\");\n            }\n            LOGGER.warn(sb.toString());\n        }\n    }\n\n    private void registerEntryToBuilder(VerificationEntry entry, AtomicReference<PgpEntry> previousEntry) {\n        // checksums are written _after_ PGP, so if the previous entry was PGP and\n        // that it matches the artifact id we don't always need to write the checksum\n        PgpEntry pgpEntry = previousEntry.get();\n        if (pgpEntry != null && !pgpEntry.id.equals(entry.id)) {\n            // previous entry was on unrelated module\n            pgpEntry = null;\n            previousEntry.set(null);\n        }\n        if (entry instanceof ChecksumEntry) {\n            ChecksumEntry checksum = (ChecksumEntry) entry;\n            if (pgpEntry == null || (entry.id.equals(pgpEntry.id) && pgpEntry.isRequiringChecksums())) {\n                String label = \"Generated by Gradle\";\n                if (pgpEntry != null) {\n                    if (pgpEntry.isFailed()) {\n                        hasFailedVerification = true;\n                        label += \" because PGP signature verification failed!\";\n                    } else {\n                        if (pgpEntry.hasSignatureFile()) {\n                            hasMissingKeys = true;\n                            label += \" because a key couldn't be downloaded\";\n                        } else {\n                            hasMissingSignatures = true;\n                            label += \" because artifact wasn't signed\";\n                        }\n                    }\n                }\n                verificationsBuilder.addChecksum(entry.id, checksum.getChecksumKind(), checksum.getChecksum(), label);\n            }\n        } else {\n            PgpEntry pgp = (PgpEntry) entry;\n            previousEntry.set(pgp);\n            Set<String> failedKeys = Sets.newTreeSet(pgp.getFailed());\n            for (String failedKey : failedKeys) {\n                verificationsBuilder.addIgnoredKey(pgp.id, new IgnoredKey(failedKey, PGP_VERIFICATION_FAILED));\n            }\n            if (pgp.hasArtifactLevelKeys()) {\n                for (String key : pgp.getArtifactLevelKeys()) {\n                    if (!failedKeys.contains(key)) {\n                        verificationsBuilder.addTrustedKey(pgp.id, key);\n                    }\n                }\n            }\n        }\n    }\n\n    private boolean shouldWriteEntry(VerificationEntry entry) {\n        if (entry instanceof ChecksumEntry) {\n            return ((ChecksumEntry) entry).getChecksum() != null && !isTrustedArtifact(entry.id);\n        }\n        return !isTrustedArtifact(entry.id);\n    }\n\n    private void resolveAllConfigurationsConcurrently(Gradle gradle) {\n        buildOperationExecutor.runAllWithAccessToProjectState(queue -> {\n            Set<Project> allprojects = gradle.getRootProject().getAllprojects();\n            for (Project project : allprojects) {\n                queue.add(new RunnableBuildOperation() {\n                    @Override\n                    public void run(BuildOperationContext context) {\n                        resolveAllConfigurationsAndForceDownload(project);\n                    }\n\n                    @Override\n                    public BuildOperationDescriptor.Builder description() {\n                        String displayName = \"Resolving configurations of \" + project.getDisplayName();\n                        return BuildOperationDescriptor.displayName(displayName)\n                            .progressDisplayName(displayName);\n                    }\n                });\n            }\n        });\n    }\n\n    private void computeChecksumsConcurrently(SignatureVerificationService signatureVerificationService) {\n        Set<String> collectedIgnoredKeys = generatePgpInfo ? Sets.newConcurrentHashSet() : null;\n        buildOperationExecutor.runAll(queue -> {\n            for (VerificationEntry entry : entriesToBeWritten) {\n                if (shouldSkipVerification(entry.getArtifactKind())) {\n                    continue;\n                }\n                if (!entry.getFile().exists()) {\n                    LOGGER.warn(\"Cannot compute checksum for \" + entry.getFile() + \" because it doesn't exist. It may indicate a corrupt or tampered cache.\");\n                    continue;\n                }\n                if (entry instanceof ChecksumEntry) {\n                    queueChecksumVerification(queue, (ChecksumEntry) entry);\n                } else {\n                    queueSignatureVerification(queue, signatureVerificationService, (PgpEntry) entry, collectedIgnoredKeys);\n                }\n            }\n        });\n        if (generatePgpInfo) {\n            postProcessPgpResults(collectedIgnoredKeys);\n        }\n    }\n\n    private void postProcessPgpResults(Set<String> collectedIgnoredKeys) {\n        for (String ignoredKey : collectedIgnoredKeys) {\n            verificationsBuilder.addIgnoredKey(new IgnoredKey(ignoredKey, KEY_NOT_DOWNLOADED));\n        }\n        PgpKeyGrouper grouper = new PgpKeyGrouper(verificationsBuilder, entriesToBeWritten);\n        grouper.performPgpKeyGrouping();\n    }\n\n    private void queueSignatureVerification(BuildOperationQueue<RunnableBuildOperation> queue, SignatureVerificationService signatureVerificationService, PgpEntry entry, Set<String> ignoredKeys) {\n        queue.add(new RunnableBuildOperation() {\n            @Override\n            public void run(BuildOperationContext context) {\n                File signature = entry.getSignatureFile().create();\n                if (signature != null) {\n                    SignatureVerificationResultBuilder builder = new WriterSignatureVerificationResult(ignoredKeys, entry);\n                    signatureVerificationService.verify(entry.file, signature, Collections.emptySet(), Collections.emptySet(), builder);\n                }\n            }\n\n            @Override\n            public BuildOperationDescriptor.Builder description() {\n                return BuildOperationDescriptor.displayName(\"Verifying dependency signature\")\n                    .progressDisplayName(\"Verifying signature of \" + entry.id);\n            }\n        });\n    }\n\n    private void queueChecksumVerification(BuildOperationQueue<RunnableBuildOperation> queue, ChecksumEntry entry) {\n        queue.add(new RunnableBuildOperation() {\n            @Override\n            public void run(BuildOperationContext context) {\n                entry.setChecksum(createHash(entry.getFile(), entry.getChecksumKind()));\n            }\n\n            @Override\n            public BuildOperationDescriptor.Builder description() {\n                return BuildOperationDescriptor.displayName(\"Computing checksums\")\n                    .progressDisplayName(\"Computing checksum of \" + entry.id);\n            }\n        });\n    }\n\n    @Override\n    public void onArtifact(ArtifactKind kind, ModuleComponentArtifactIdentifier id, File mainFile, Factory<File> signatureFile, String repositoryName, String repositoryId) {\n        for (String checksum : checksums) {\n            if (PGP.equals(checksum)) {\n                addPgp(id, kind, mainFile, signatureFile);\n            } else {\n                addChecksum(id, kind, mainFile, ChecksumKind.valueOf(checksum));\n            }\n        }\n    }\n\n    @Override\n    public boolean wasAlreadyProcessed(ModuleComponentArtifactIdentifier artifact, String repositoryId) {\n        // Since writing to a file is done rarely and this is called only to avoid resolving\n        // artifacts again when already cached, there is not much penalty to not do any check here\n        return false;\n    }\n\n    private void addPgp(ModuleComponentArtifactIdentifier id, ArtifactKind kind, File mainFile, Factory<File> signatureFile) {\n        PgpEntry entry = new PgpEntry(id, kind, mainFile, signatureFile);\n        synchronized (entriesToBeWritten) {\n            entriesToBeWritten.add(entry);\n        }\n    }\n\n    private boolean shouldSkipVerification(ArtifactVerificationOperation.ArtifactKind kind) {\n        return kind == ArtifactKind.METADATA && !verificationsBuilder.isVerifyMetadata();\n    }\n\n    private void addChecksum(ModuleComponentArtifactIdentifier id, ArtifactKind artifactKind, File file, ChecksumKind kind) {\n        ChecksumEntry e = new ChecksumEntry(id, artifactKind, file, kind);\n        synchronized (entriesToBeWritten) {\n            entriesToBeWritten.add(e);\n        }\n    }\n\n    private boolean isTrustedArtifact(ModuleComponentArtifactIdentifier id) {\n        return verificationsBuilder.getTrustedArtifacts().stream().anyMatch(artifact -> artifact.matches(id));\n    }\n\n    private String createHash(File file, ChecksumKind kind) {\n        try {\n            return checksumService.hash(file, kind.getAlgorithm()).toString();\n        } catch (Exception e) {\n            LOGGER.debug(\"Error while snapshotting \" + file, e);\n            return null;\n        }\n    }\n\n    private static void resolveAllConfigurationsAndForceDownload(Project project) {\n        ((ProjectInternal) project).getOwner().applyToMutableState(p ->\n            p.getConfigurations().all(cnf -> {\n                if (((DeprecatableConfiguration) cnf).canSafelyBeResolved()) {\n                    try {\n                        resolveAndDownloadExternalFiles(cnf);\n                    } catch (Exception e) {\n                        LOGGER.debug(\"Cannot resolve configuration {}: {}\", cnf.getName(), e.getMessage());\n                    }\n                }\n            })\n        );\n    }\n\n    private static void resolveAndDownloadExternalFiles(Configuration cnf) {\n        cnf.getIncoming().artifactView(MODULE_COMPONENT_FILES).getFiles().getFiles();\n    }\n\n    private void exportKeyRingCollection(PublicKeyService publicKeyService, BuildTreeDefinedKeys keyrings, Set<String> publicKeys) throws IOException {\n        List<PGPPublicKeyRing> existingRings = loadExistingKeyRing(keyrings);\n        PGPPublicKeyRingListBuilder builder = new PGPPublicKeyRingListBuilder();\n        for (String publicKey : publicKeys) {\n            if (publicKey.length() <= 16) {\n                publicKeyService.findByLongId(new BigInteger(publicKey, 16).longValue(), builder);\n            } else {\n                publicKeyService.findByFingerprint(Fingerprint.fromString(publicKey).getBytes(), builder);\n            }\n        }\n\n        List<PGPPublicKeyRing> keysSeenInVerifier = builder.build()\n            .stream()\n            .filter(WriteDependencyVerificationFile::hasAtLeastOnePublicKey)\n            .filter(e -> existingRings.stream().noneMatch(ring -> keyIds(ring).equals(keyIds(e))))\n            .collect(Collectors.toList());\n        ImmutableList<PGPPublicKeyRing> allKeyRings = ImmutableList.<PGPPublicKeyRing>builder()\n            .addAll(existingRings)\n            .addAll(keysSeenInVerifier)\n            .build();\n        File keyringFile = keyrings.getBinaryKeyringsFile();\n        writeBinaryKeyringFile(keyringFile, allKeyRings);\n        File asciiArmoredFile = keyrings.getAsciiKeyringsFile();\n        writeAsciiArmoredKeyRingFile(asciiArmoredFile, allKeyRings);\n        LOGGER.lifecycle(\"Exported {} keys to {} and {}\", allKeyRings.size(), keyringFile, asciiArmoredFile);\n    }\n\n    private void writeAsciiArmoredKeyRingFile(File ascii, ImmutableList<PGPPublicKeyRing> allKeyRings) throws IOException {\n        if (ascii.exists()) {\n            ascii.delete();\n        }\n        boolean hasKey = false;\n        for (PGPPublicKeyRing keyRing : allKeyRings) {\n            // First let's write some human readable info about the keyring being serialized\n            try (OutputStream out = new FileOutputStream(ascii, true)) {\n                if (hasKey) {\n                    out.write('\\n');\n                }\n                Iterator<PGPPublicKey> pks = keyRing.getPublicKeys();\n                while (pks.hasNext()) {\n                    boolean hasUid = false;\n                    PGPPublicKey pk = pks.next();\n                    String keyType = pk.isMasterKey() ? \"pub\" : \"sub\";\n                    out.write((keyType + \"    \" + SecuritySupport.toLongIdHexString(pk.getKeyID()).toUpperCase() + \"\\n\").getBytes(StandardCharsets.US_ASCII));\n                    List<String> userIDs = PGPUtils.getUserIDs(pk);\n                    for(String uid : userIDs) {\n                        hasUid = true;\n                        out.write((\"uid    \" + uid + \"\\n\").getBytes(StandardCharsets.US_ASCII));\n                    }\n                    if (hasUid) {\n                        out.write('\\n');\n                    }\n                }\n            }\n            // Then write the ascii armored keyring\n            try (FileOutputStream fos = new FileOutputStream(ascii, true);\n                 ArmoredOutputStream out = new ArmoredOutputStream(fos)) {\n                keyRing.encode(out, true);\n            }\n            hasKey = true;\n        }\n    }\n\n    private void writeBinaryKeyringFile(File keyringFile, ImmutableList<PGPPublicKeyRing> allKeyRings) throws IOException {\n        try (OutputStream out = new FileOutputStream(keyringFile)) {\n            for (PGPPublicKeyRing keyRing : allKeyRings) {\n                keyRing.encode(out, true);\n            }\n        }\n    }\n\n    private static class PGPPublicKeyRingListBuilder implements PublicKeyResultBuilder {\n        private final ImmutableList.Builder<PGPPublicKeyRing> builder = ImmutableList.builder();\n\n        public void keyRing(PGPPublicKeyRing keyring) {\n            builder.add(keyring);\n        }\n\n        @Override\n        public void publicKey(PGPPublicKey publicKey) {\n\n        }\n\n        public List<PGPPublicKeyRing> build() {\n            return builder.build();\n        }\n    }\n\n    private static boolean hasAtLeastOnePublicKey(PGPPublicKeyRing ring) {\n        return ring.getPublicKeys().hasNext();\n    }\n\n    private List<PGPPublicKeyRing> loadExistingKeyRing(BuildTreeDefinedKeys keyrings) throws IOException {\n        List<PGPPublicKeyRing> existingRings;\n        if (!isDryRun) {\n            existingRings = keyrings.loadKeys();\n            LOGGER.info(\"Existing keyring file contains {} keyrings\", existingRings.size());\n        } else {\n            existingRings = Collections.emptyList();\n        }\n        return existingRings;\n    }\n\n    private static Set<Long> keyIds(PGPPublicKeyRing ring) {\n        return ImmutableList.copyOf(ring.getPublicKeys()).stream().map(PGPPublicKey::getKeyID).collect(Collectors.toSet());\n    }\n}\n", "/*\n * Copyright 2018 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.gradle.api.internal.artifacts.ivyservice.modulecache;\n\nimport com.google.common.collect.MapMaker;\nimport com.google.common.collect.Maps;\nimport org.gradle.api.artifacts.component.ComponentArtifactIdentifier;\nimport org.gradle.api.internal.artifacts.ivyservice.ivyresolve.BaseModuleComponentRepository;\nimport org.gradle.api.internal.artifacts.ivyservice.ivyresolve.ModuleComponentRepository;\nimport org.gradle.api.internal.artifacts.ivyservice.resolveengine.artifact.ResolvableArtifact;\nimport org.gradle.api.logging.Logger;\nimport org.gradle.api.logging.Logging;\nimport org.gradle.internal.concurrent.Stoppable;\n\nimport java.util.Map;\n\n/**\n * Caches the dependency metadata (descriptors, artifact files) in memory.\n */\npublic class ResolvedArtifactCaches implements Stoppable {\n\n    private final static Logger LOG = Logging.getLogger(ResolvedArtifactCaches.class);\n\n    private final Map<String, Map<ComponentArtifactIdentifier, ResolvableArtifact>> cachePerRepo = new MapMaker().makeMap();\n\n    /**\n     * For a remote repository, the only thing required is a resolved artifact cache.\n     * The rest of the in-memory caching is handled by the CachingModuleComponentRepository.\n     */\n    public ModuleComponentRepository provideResolvedArtifactCache(ModuleComponentRepository input) {\n        Map<ComponentArtifactIdentifier, ResolvableArtifact> caches = getResolvedArtifactCache(input);\n        return new ResolvedArtifactCacheProvidingModuleComponentRepository(caches, input);\n    }\n\n    private Map<ComponentArtifactIdentifier, ResolvableArtifact> getResolvedArtifactCache(ModuleComponentRepository input) {\n        Map<ComponentArtifactIdentifier, ResolvableArtifact> resolvedArtifactCache = cachePerRepo.get(input.getId());\n        if (resolvedArtifactCache == null) {\n            LOG.debug(\"Creating new in-memory cache for repo '{}' [{}].\", input.getName(), input.getId());\n            resolvedArtifactCache = Maps.newConcurrentMap();\n            cachePerRepo.put(input.getId(), resolvedArtifactCache);\n        } else {\n            LOG.debug(\"Reusing in-memory cache for repo '{}' [{}].\", input.getName(), input.getId());\n        }\n        return resolvedArtifactCache;\n    }\n\n    @Override\n    public void stop() {\n        cachePerRepo.clear();\n    }\n\n    private static class ResolvedArtifactCacheProvidingModuleComponentRepository extends BaseModuleComponentRepository {\n\n        private final Map<ComponentArtifactIdentifier, ResolvableArtifact> resolvedArtifactCache;\n\n        public ResolvedArtifactCacheProvidingModuleComponentRepository(Map<ComponentArtifactIdentifier, ResolvableArtifact> resolvedArtifactsCache, ModuleComponentRepository delegate) {\n            super(delegate);\n            this.resolvedArtifactCache = resolvedArtifactsCache;\n        }\n\n        @Override\n        public Map<ComponentArtifactIdentifier, ResolvableArtifact> getArtifactCache() {\n            return resolvedArtifactCache;\n        }\n    }\n}\n"], "fixing_code": ["/*\n * Copyright 2019 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.gradle.api.internal.artifacts.ivyservice.ivyresolve;\n\nimport com.google.common.io.Files;\nimport org.gradle.api.artifacts.ArtifactIdentifier;\nimport org.gradle.api.artifacts.ComponentMetadataSupplierDetails;\nimport org.gradle.api.artifacts.component.ComponentArtifactIdentifier;\nimport org.gradle.api.artifacts.component.ComponentIdentifier;\nimport org.gradle.api.artifacts.component.ModuleComponentIdentifier;\nimport org.gradle.api.internal.artifacts.DefaultArtifactIdentifier;\nimport org.gradle.api.internal.artifacts.ivyservice.ivyresolve.verification.ArtifactVerificationOperation;\nimport org.gradle.api.internal.artifacts.ivyservice.resolveengine.artifact.ResolvableArtifact;\nimport org.gradle.api.internal.artifacts.repositories.metadata.DefaultMetadataFileSource;\nimport org.gradle.api.internal.artifacts.repositories.resolver.MetadataFetchingCost;\nimport org.gradle.api.internal.component.ArtifactType;\nimport org.gradle.api.internal.tasks.DefaultTaskDependency;\nimport org.gradle.api.tasks.TaskDependency;\nimport org.gradle.internal.action.InstantiatingAction;\nimport org.gradle.internal.component.external.model.DefaultModuleComponentArtifactIdentifier;\nimport org.gradle.internal.component.external.model.ModuleComponentArtifactIdentifier;\nimport org.gradle.internal.component.external.model.ModuleComponentArtifactMetadata;\nimport org.gradle.internal.component.external.model.ModuleDependencyMetadata;\nimport org.gradle.internal.component.model.ComponentArtifactMetadata;\nimport org.gradle.internal.component.model.ComponentOverrideMetadata;\nimport org.gradle.internal.component.model.ComponentResolveMetadata;\nimport org.gradle.internal.component.model.ConfigurationMetadata;\nimport org.gradle.internal.component.model.DefaultIvyArtifactName;\nimport org.gradle.internal.component.model.IvyArtifactName;\nimport org.gradle.internal.component.model.ModuleDescriptorArtifactMetadata;\nimport org.gradle.internal.component.model.ModuleSources;\nimport org.gradle.internal.resolve.result.BuildableArtifactResolveResult;\nimport org.gradle.internal.resolve.result.BuildableArtifactSetResolveResult;\nimport org.gradle.internal.resolve.result.BuildableComponentArtifactsResolveResult;\nimport org.gradle.internal.resolve.result.BuildableModuleComponentMetaDataResolveResult;\nimport org.gradle.internal.resolve.result.BuildableModuleVersionListingResolveResult;\nimport org.gradle.internal.resolve.result.DefaultBuildableArtifactResolveResult;\nimport org.gradle.internal.resolve.result.DefaultBuildableModuleComponentMetaDataResolveResult;\n\nimport javax.annotation.Nullable;\nimport java.io.File;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class DependencyVerifyingModuleComponentRepository implements ModuleComponentRepository {\n    private final ModuleComponentRepository delegate;\n    private final ModuleComponentRepositoryAccess localAccess;\n    private final ModuleComponentRepositoryAccess remoteAccess;\n    private final ArtifactVerificationOperation operation;\n\n    public DependencyVerifyingModuleComponentRepository(ModuleComponentRepository delegate, ArtifactVerificationOperation operation, boolean verifySignatures) {\n        this.delegate = delegate;\n        this.localAccess = new VerifyingModuleComponentRepositoryAccess(delegate.getLocalAccess(), verifySignatures);\n        this.remoteAccess = new VerifyingModuleComponentRepositoryAccess(delegate.getRemoteAccess(), verifySignatures);\n        this.operation = operation;\n    }\n\n    @Override\n    public String getId() {\n        return delegate.getId();\n    }\n\n    @Override\n    public String getName() {\n        return delegate.getName();\n    }\n\n    @Override\n    public ModuleComponentRepositoryAccess getLocalAccess() {\n        return localAccess;\n    }\n\n    @Override\n    public ModuleComponentRepositoryAccess getRemoteAccess() {\n        return remoteAccess;\n    }\n\n    @Override\n    public Map<ComponentArtifactIdentifier, ResolvableArtifact> getArtifactCache() {\n        return delegate.getArtifactCache();\n    }\n\n    @Override\n    @Nullable\n    public InstantiatingAction<ComponentMetadataSupplierDetails> getComponentMetadataSupplier() {\n        return delegate.getComponentMetadataSupplier();\n    }\n\n    private class VerifyingModuleComponentRepositoryAccess implements ModuleComponentRepositoryAccess {\n        private final ModuleComponentRepositoryAccess delegate;\n        private final boolean verifySignatures;\n\n        private VerifyingModuleComponentRepositoryAccess(ModuleComponentRepositoryAccess delegate, boolean verifySignatures) {\n            this.delegate = delegate;\n            this.verifySignatures = verifySignatures;\n        }\n\n        @Override\n        public void listModuleVersions(ModuleDependencyMetadata dependency, BuildableModuleVersionListingResolveResult result) {\n            delegate.listModuleVersions(dependency, result);\n        }\n\n        private boolean hasUsableResult(BuildableModuleComponentMetaDataResolveResult result) {\n            return result.hasResult() && result.getState() == BuildableModuleComponentMetaDataResolveResult.State.Resolved;\n        }\n\n        @Override\n        public void resolveComponentMetaData(ModuleComponentIdentifier moduleComponentIdentifier, ComponentOverrideMetadata requestMetaData, BuildableModuleComponentMetaDataResolveResult result) {\n            // For metadata, because the local file can be deleted we have to proceed in two steps\n            // First resolve with a tmp result, and if it's found and that the file is still present\n            // we can perform verification. If it's missing, then we do nothing so that it's downloaded\n            // and verified later.\n            BuildableModuleComponentMetaDataResolveResult tmp = new DefaultBuildableModuleComponentMetaDataResolveResult();\n            delegate.resolveComponentMetaData(moduleComponentIdentifier, requestMetaData, tmp);\n            AtomicBoolean ignore = new AtomicBoolean();\n            if (hasUsableResult(tmp)) {\n                tmp.getMetaData().getSources().withSources(DefaultMetadataFileSource.class, metadataFileSource -> {\n                    ModuleComponentArtifactIdentifier artifact = metadataFileSource.getArtifactId();\n                    if (isExternalArtifactId(artifact)) {\n                        tmp.getMetaData().getSources().withSource(ModuleDescriptorHashModuleSource.class, hashSource -> {\n                            if (hashSource.isPresent()) {\n                                boolean changingModule = requestMetaData.isChanging() || hashSource.get().isChangingModule();\n                                if (!changingModule) {\n                                    File artifactFile = metadataFileSource.getArtifactFile();\n                                    if (artifactFile != null && artifactFile.exists()) {\n                                        // it's possible that the file is null if it has been removed from the cache\n                                        // for example\n                                        operation.onArtifact(ArtifactVerificationOperation.ArtifactKind.METADATA, artifact, artifactFile, () -> maybeFetchSignatureFile(moduleComponentIdentifier, tmp.getMetaData().getSources(), artifact), getName(), getId());\n                                    } else {\n                                        ignore.set(true);\n                                    }\n                                }\n                            }\n                            return null;\n                        });\n                    }\n                });\n            }\n\n            if (!ignore.get()) {\n                delegate.resolveComponentMetaData(moduleComponentIdentifier, requestMetaData, result);\n            }\n        }\n\n        private File maybeFetchSignatureFile(ModuleComponentIdentifier moduleComponentIdentifier, ModuleSources moduleSources, ModuleComponentArtifactIdentifier artifact) {\n            if (!verifySignatures) {\n                return null;\n            }\n            SignatureFileDefaultBuildableArtifactResolveResult signatureResult = new SignatureFileDefaultBuildableArtifactResolveResult();\n            SignatureArtifactMetadata signatureArtifactMetadata = new SignatureArtifactMetadata(moduleComponentIdentifier, artifact);\n            getLocalAccess().resolveArtifact(signatureArtifactMetadata, moduleSources, signatureResult);\n            if (signatureResult.hasResult()) {\n                if (signatureResult.isSuccessful()) {\n                    return signatureResult.getResult();\n                }\n                return null;\n            } else {\n                getRemoteAccess().resolveArtifact(signatureArtifactMetadata, moduleSources, signatureResult);\n            }\n            if (signatureResult.hasResult() && signatureResult.isSuccessful()) {\n                return signatureResult.getResult();\n            }\n            return null;\n        }\n\n        @Override\n        public void resolveArtifacts(ComponentResolveMetadata component, ConfigurationMetadata variant, BuildableComponentArtifactsResolveResult result) {\n            delegate.resolveArtifacts(component, variant, result);\n        }\n\n        @Override\n        public void resolveArtifactsWithType(ComponentResolveMetadata component, ArtifactType artifactType, BuildableArtifactSetResolveResult result) {\n            delegate.resolveArtifactsWithType(component, artifactType, result);\n        }\n\n        @Override\n        public void resolveArtifact(ComponentArtifactMetadata artifact, ModuleSources moduleSources, BuildableArtifactResolveResult result) {\n            delegate.resolveArtifact(artifact, moduleSources, result);\n            if (result.hasResult() && result.isSuccessful()) {\n                ComponentArtifactIdentifier id = artifact.getId();\n                if (isExternalArtifactId(id) && isNotChanging(moduleSources)) {\n                    ModuleComponentArtifactIdentifier mcai = (ModuleComponentArtifactIdentifier) id;\n                    ArtifactVerificationOperation.ArtifactKind artifactKind = determineArtifactKind(artifact);\n                    if (!(result instanceof SignatureFileDefaultBuildableArtifactResolveResult)) {\n                        // signature files are fetched using resolveArtifact, but are checked alongside the main artifact\n                        operation.onArtifact(artifactKind, mcai, result.getResult(), () -> maybeFetchSignatureFile(((ModuleComponentArtifactIdentifier) id).getComponentIdentifier(), moduleSources, mcai), getName(), getId());\n                    }\n                }\n            }\n        }\n\n        private ArtifactVerificationOperation.ArtifactKind determineArtifactKind(ComponentArtifactMetadata artifact) {\n            ArtifactVerificationOperation.ArtifactKind artifactKind = ArtifactVerificationOperation.ArtifactKind.REGULAR;\n            if (artifact instanceof ModuleDescriptorArtifactMetadata) {\n                artifactKind = ArtifactVerificationOperation.ArtifactKind.METADATA;\n            }\n            return artifactKind;\n        }\n\n        private boolean isNotChanging(ModuleSources moduleSources) {\n            return moduleSources.withSource(ModuleDescriptorHashModuleSource.class, source ->\n                source.map(cachingModuleSource -> !cachingModuleSource.isChangingModule()).orElse(true));\n        }\n\n        private boolean isExternalArtifactId(ComponentArtifactIdentifier id) {\n            return id instanceof ModuleComponentArtifactIdentifier;\n        }\n\n        @Override\n        public MetadataFetchingCost estimateMetadataFetchingCost(ModuleComponentIdentifier moduleComponentIdentifier) {\n            return delegate.estimateMetadataFetchingCost(moduleComponentIdentifier);\n        }\n\n        private class SignatureArtifactMetadata implements ModuleComponentArtifactMetadata {\n\n            private final ModuleComponentIdentifier moduleComponentIdentifier;\n            private final ModuleComponentArtifactIdentifier artifactIdentifier;\n\n            public SignatureArtifactMetadata(ModuleComponentIdentifier moduleComponentIdentifier, ModuleComponentArtifactIdentifier artifact) {\n                this.moduleComponentIdentifier = moduleComponentIdentifier;\n                this.artifactIdentifier = artifact.getSignatureArtifactId();\n            }\n\n\n            @Override\n            public ModuleComponentArtifactIdentifier getId() {\n                return artifactIdentifier;\n            }\n\n            @Override\n            public ComponentIdentifier getComponentId() {\n                return moduleComponentIdentifier;\n            }\n\n            @Override\n            public IvyArtifactName getName() {\n                if (artifactIdentifier instanceof DefaultModuleComponentArtifactIdentifier) {\n                    return ((DefaultModuleComponentArtifactIdentifier) artifactIdentifier).getName();\n                }\n                // This is a bit hackish but the mapping from file names to ivy artifact names is completely broken\n                String fileName = artifactIdentifier.getFileName().replace(\"-\" + artifactIdentifier.getComponentIdentifier().getVersion(), \"\");\n                fileName = Files.getNameWithoutExtension(fileName); // removes the .asc\n                DefaultIvyArtifactName base = DefaultIvyArtifactName.forFileName(fileName, null);\n                return new DefaultIvyArtifactName(\n                    base.getName(),\n                    \"asc\",\n                    base.getExtension() + \".asc\"\n                );\n            }\n\n            @Override\n            public TaskDependency getBuildDependencies() {\n                return new DefaultTaskDependency();\n            }\n\n            @Override\n            public ArtifactIdentifier toArtifactIdentifier() {\n                return new DefaultArtifactIdentifier(\n                    new DefaultModuleComponentArtifactIdentifier(\n                        moduleComponentIdentifier, getName()\n                    )\n                );\n            }\n\n        }\n    }\n\n    private static class SignatureFileDefaultBuildableArtifactResolveResult extends DefaultBuildableArtifactResolveResult {\n    }\n}\n", "/*\n * Copyright 2011 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.gradle.api.internal.artifacts.ivyservice.ivyresolve;\n\nimport org.gradle.api.Action;\nimport org.gradle.api.artifacts.component.ComponentIdentifier;\nimport org.gradle.api.artifacts.result.ArtifactResult;\nimport org.gradle.api.attributes.AttributeContainer;\nimport org.gradle.api.attributes.AttributesSchema;\nimport org.gradle.api.internal.artifacts.ComponentMetadataProcessor;\nimport org.gradle.api.internal.artifacts.ComponentMetadataProcessorFactory;\nimport org.gradle.api.internal.artifacts.ImmutableModuleIdentifierFactory;\nimport org.gradle.api.internal.artifacts.MetadataResolutionContext;\nimport org.gradle.api.internal.artifacts.configurations.ResolutionStrategyInternal;\nimport org.gradle.api.internal.artifacts.configurations.dynamicversion.CachePolicy;\nimport org.gradle.api.internal.artifacts.ivyservice.ivyresolve.strategy.VersionComparator;\nimport org.gradle.api.internal.artifacts.ivyservice.ivyresolve.strategy.VersionParser;\nimport org.gradle.api.internal.artifacts.ivyservice.ivyresolve.strategy.VersionSelector;\nimport org.gradle.api.internal.artifacts.ivyservice.ivyresolve.verification.DependencyVerificationOverride;\nimport org.gradle.api.internal.artifacts.ivyservice.modulecache.ModuleRepositoryCacheProvider;\nimport org.gradle.api.internal.artifacts.ivyservice.resolutionstrategy.DefaultComponentSelectionRules;\nimport org.gradle.api.internal.artifacts.repositories.ArtifactResolutionDetails;\nimport org.gradle.api.internal.artifacts.repositories.ContentFilteringRepository;\nimport org.gradle.api.internal.artifacts.repositories.ResolutionAwareRepository;\nimport org.gradle.api.internal.artifacts.result.DefaultResolvedArtifactResult;\nimport org.gradle.api.internal.attributes.ImmutableAttributesFactory;\nimport org.gradle.api.internal.component.ArtifactType;\nimport org.gradle.internal.Actions;\nimport org.gradle.internal.component.model.ComponentArtifactMetadata;\nimport org.gradle.internal.component.model.ComponentOverrideMetadata;\nimport org.gradle.internal.component.model.ComponentResolveMetadata;\nimport org.gradle.internal.component.model.DependencyMetadata;\nimport org.gradle.internal.component.model.ModuleSources;\nimport org.gradle.internal.model.CalculatedValueContainerFactory;\nimport org.gradle.internal.reflect.Instantiator;\nimport org.gradle.internal.resolve.caching.ComponentMetadataSupplierRuleExecutor;\nimport org.gradle.internal.resolve.resolver.ArtifactResolver;\nimport org.gradle.internal.resolve.resolver.ComponentMetaDataResolver;\nimport org.gradle.internal.resolve.resolver.DependencyToComponentIdResolver;\nimport org.gradle.internal.resolve.resolver.OriginArtifactSelector;\nimport org.gradle.internal.resolve.result.BuildableArtifactResolveResult;\nimport org.gradle.internal.resolve.result.BuildableArtifactSetResolveResult;\nimport org.gradle.internal.resolve.result.BuildableComponentIdResolveResult;\nimport org.gradle.internal.resolve.result.BuildableComponentResolveResult;\nimport org.gradle.util.internal.BuildCommencedTimeProvider;\n\nimport javax.annotation.Nullable;\nimport java.util.Collection;\n\npublic class ResolveIvyFactory {\n    private final ModuleRepositoryCacheProvider cacheProvider;\n    private final StartParameterResolutionOverride startParameterResolutionOverride;\n    private final BuildCommencedTimeProvider timeProvider;\n    private final VersionComparator versionComparator;\n    private final ImmutableModuleIdentifierFactory moduleIdentifierFactory;\n    private final RepositoryDisabler repositoryBlacklister;\n    private final VersionParser versionParser;\n    private final CalculatedValueContainerFactory calculatedValueContainerFactory;\n\n    private final DependencyVerificationOverride dependencyVerificationOverride;\n    private final ChangingValueDependencyResolutionListener listener;\n\n    public ResolveIvyFactory(ModuleRepositoryCacheProvider cacheProvider,\n                             StartParameterResolutionOverride startParameterResolutionOverride,\n                             DependencyVerificationOverride dependencyVerificationOverride,\n                             BuildCommencedTimeProvider timeProvider,\n                             VersionComparator versionComparator,\n                             ImmutableModuleIdentifierFactory moduleIdentifierFactory,\n                             RepositoryDisabler repositoryBlacklister,\n                             VersionParser versionParser,\n                             ChangingValueDependencyResolutionListener listener,\n                             CalculatedValueContainerFactory calculatedValueContainerFactory) {\n        this.cacheProvider = cacheProvider;\n        this.startParameterResolutionOverride = startParameterResolutionOverride;\n        this.timeProvider = timeProvider;\n        this.versionComparator = versionComparator;\n        this.moduleIdentifierFactory = moduleIdentifierFactory;\n        this.repositoryBlacklister = repositoryBlacklister;\n        this.versionParser = versionParser;\n        this.dependencyVerificationOverride = dependencyVerificationOverride;\n        this.listener = listener;\n        this.calculatedValueContainerFactory = calculatedValueContainerFactory;\n    }\n\n    public ComponentResolvers create(String resolveContextName,\n                                     ResolutionStrategyInternal resolutionStrategy,\n                                     Collection<? extends ResolutionAwareRepository> repositories,\n                                     ComponentMetadataProcessorFactory metadataProcessor,\n                                     AttributeContainer consumerAttributes,\n                                     AttributesSchema attributesSchema,\n                                     ImmutableAttributesFactory attributesFactory,\n                                     ComponentMetadataSupplierRuleExecutor componentMetadataSupplierRuleExecutor) {\n        if (repositories.isEmpty()) {\n            return new NoRepositoriesResolver();\n        }\n\n        CachePolicy cachePolicy = resolutionStrategy.getCachePolicy();\n        startParameterResolutionOverride.applyToCachePolicy(cachePolicy);\n\n        UserResolverChain moduleResolver = new UserResolverChain(versionComparator, resolutionStrategy.getComponentSelection(), versionParser, consumerAttributes, attributesSchema, attributesFactory, metadataProcessor, componentMetadataSupplierRuleExecutor, cachePolicy, calculatedValueContainerFactory);\n        ParentModuleLookupResolver parentModuleResolver = new ParentModuleLookupResolver(versionComparator, moduleIdentifierFactory, versionParser, consumerAttributes, attributesSchema, attributesFactory, metadataProcessor, componentMetadataSupplierRuleExecutor, cachePolicy, calculatedValueContainerFactory);\n\n        for (ResolutionAwareRepository repository : repositories) {\n            ConfiguredModuleComponentRepository baseRepository = repository.createResolver();\n\n            baseRepository.setComponentResolvers(parentModuleResolver);\n            Instantiator instantiator = baseRepository.getComponentMetadataInstantiator();\n            MetadataResolutionContext metadataResolutionContext = new DefaultMetadataResolutionContext(cachePolicy, instantiator);\n            ComponentMetadataProcessor componentMetadataProcessor = metadataProcessor.createComponentMetadataProcessor(metadataResolutionContext);\n\n            ModuleComponentRepository moduleComponentRepository = baseRepository;\n            if (baseRepository.isLocal()) {\n                moduleComponentRepository = new CachingModuleComponentRepository(moduleComponentRepository, cacheProvider.getInMemoryOnlyCaches(), cachePolicy, timeProvider, componentMetadataProcessor, ChangingValueDependencyResolutionListener.NO_OP);\n                moduleComponentRepository = new LocalModuleComponentRepository(moduleComponentRepository);\n            } else {\n                moduleComponentRepository = startParameterResolutionOverride.overrideModuleVersionRepository(moduleComponentRepository);\n                moduleComponentRepository = new CachingModuleComponentRepository(moduleComponentRepository, cacheProvider.getPersistentCaches(), cachePolicy, timeProvider, componentMetadataProcessor, listener);\n            }\n            moduleComponentRepository = cacheProvider.getResolvedArtifactCaches().provideResolvedArtifactCache(moduleComponentRepository, resolutionStrategy.isDependencyVerificationEnabled());\n\n            if (baseRepository.isDynamicResolveMode()) {\n                moduleComponentRepository = new IvyDynamicResolveModuleComponentRepository(moduleComponentRepository);\n            }\n            moduleComponentRepository = new ErrorHandlingModuleComponentRepository(moduleComponentRepository, repositoryBlacklister);\n            moduleComponentRepository = filterRepository(repository, moduleComponentRepository, resolveContextName, consumerAttributes);\n            moduleComponentRepository = dependencyVerificationOverride.overrideDependencyVerification(moduleComponentRepository, resolveContextName, resolutionStrategy);\n            moduleResolver.add(moduleComponentRepository);\n            parentModuleResolver.add(moduleComponentRepository);\n        }\n\n        return moduleResolver;\n    }\n\n    private ModuleComponentRepository filterRepository(ResolutionAwareRepository repository, ModuleComponentRepository moduleComponentRepository, String consumerName, AttributeContainer consumerAttributes) {\n        Action<? super ArtifactResolutionDetails> filter = Actions.doNothing();\n        if (repository instanceof ContentFilteringRepository) {\n            filter = ((ContentFilteringRepository) repository).getContentFilter();\n        }\n        moduleComponentRepository = FilteredModuleComponentRepository.of(moduleComponentRepository, filter, consumerName, consumerAttributes);\n        return moduleComponentRepository;\n    }\n\n    public ArtifactResult verifiedArtifact(DefaultResolvedArtifactResult defaultResolvedArtifactResult) {\n        return dependencyVerificationOverride.verifiedArtifact(defaultResolvedArtifactResult);\n    }\n\n    /**\n     * Provides access to the top-level resolver chain for looking up parent modules when parsing module descriptor files.\n     */\n    private static class ParentModuleLookupResolver implements ComponentResolvers, DependencyToComponentIdResolver, ComponentMetaDataResolver, ArtifactResolver {\n        private final UserResolverChain delegate;\n\n        public ParentModuleLookupResolver(VersionComparator versionComparator, ImmutableModuleIdentifierFactory moduleIdentifierFactory, VersionParser versionParser, AttributeContainer consumerAttributes, AttributesSchema attributesSchema, ImmutableAttributesFactory attributesFactory, ComponentMetadataProcessorFactory componentMetadataProcessorFactory, ComponentMetadataSupplierRuleExecutor componentMetadataSupplierRuleExecutor, CachePolicy cachePolicy, CalculatedValueContainerFactory calculatedValueContainerFactory) {\n            this.delegate = new UserResolverChain(versionComparator, new DefaultComponentSelectionRules(moduleIdentifierFactory), versionParser, consumerAttributes, attributesSchema, attributesFactory, componentMetadataProcessorFactory, componentMetadataSupplierRuleExecutor, cachePolicy, calculatedValueContainerFactory);\n        }\n\n        public void add(ModuleComponentRepository moduleComponentRepository) {\n            delegate.add(moduleComponentRepository);\n        }\n\n        @Override\n        public DependencyToComponentIdResolver getComponentIdResolver() {\n            return this;\n        }\n\n        @Override\n        public ComponentMetaDataResolver getComponentResolver() {\n            return this;\n        }\n\n        @Override\n        public ArtifactResolver getArtifactResolver() {\n            return this;\n        }\n\n        @Override\n        public OriginArtifactSelector getArtifactSelector() {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public void resolve(DependencyMetadata dependency, VersionSelector acceptor, @Nullable VersionSelector rejector, BuildableComponentIdResolveResult result) {\n            delegate.getComponentIdResolver().resolve(dependency, acceptor, rejector, result);\n        }\n\n        @Override\n        public void resolve(final ComponentIdentifier identifier, final ComponentOverrideMetadata componentOverrideMetadata, final BuildableComponentResolveResult result) {\n            delegate.getComponentResolver().resolve(identifier, componentOverrideMetadata, result);\n        }\n\n        @Override\n        public boolean isFetchingMetadataCheap(ComponentIdentifier identifier) {\n            return delegate.getComponentResolver().isFetchingMetadataCheap(identifier);\n        }\n\n        @Override\n        public void resolveArtifactsWithType(final ComponentResolveMetadata component, final ArtifactType artifactType, final BuildableArtifactSetResolveResult result) {\n            delegate.getArtifactResolver().resolveArtifactsWithType(component, artifactType, result);\n        }\n\n        @Override\n        public void resolveArtifact(final ComponentArtifactMetadata artifact, final ModuleSources moduleSources, final BuildableArtifactResolveResult result) {\n            delegate.getArtifactResolver().resolveArtifact(artifact, moduleSources, result);\n        }\n    }\n\n    private static class DefaultMetadataResolutionContext implements MetadataResolutionContext {\n\n        private final CachePolicy cachePolicy;\n        private final Instantiator instantiator;\n\n        private DefaultMetadataResolutionContext(CachePolicy cachePolicy, Instantiator instantiator) {\n            this.cachePolicy = cachePolicy;\n            this.instantiator = instantiator;\n        }\n\n        @Override\n        public CachePolicy getCachePolicy() {\n            return cachePolicy;\n        }\n\n        @Override\n        public Instantiator getInjectingInstantiator() {\n            return instantiator;\n        }\n    }\n}\n", "/*\n * Copyright 2019 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.gradle.api.internal.artifacts.ivyservice.ivyresolve.verification;\n\nimport org.gradle.internal.Factory;\nimport org.gradle.internal.component.external.model.ModuleComponentArtifactIdentifier;\n\nimport java.io.File;\n\npublic interface ArtifactVerificationOperation {\n    void onArtifact(ArtifactKind kind, ModuleComponentArtifactIdentifier artifact, File mainFile, Factory<File> signatureFile, String repositoryName, String repositoryId);\n\n    enum ArtifactKind {\n        METADATA,\n        REGULAR\n    }\n}\n", "/*\n * Copyright 2019 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.gradle.api.internal.artifacts.ivyservice.ivyresolve.verification;\n\nimport com.google.common.collect.LinkedHashMultimap;\nimport com.google.common.collect.Multimap;\nimport com.google.common.collect.Queues;\nimport com.google.common.collect.Sets;\nimport org.gradle.api.artifacts.component.ComponentArtifactIdentifier;\nimport org.gradle.api.artifacts.result.ResolvedArtifactResult;\nimport org.gradle.api.artifacts.result.ResolvedVariantResult;\nimport org.gradle.api.artifacts.verification.DependencyVerificationMode;\nimport org.gradle.api.component.Artifact;\nimport org.gradle.api.internal.DocumentationRegistry;\nimport org.gradle.api.internal.artifacts.configurations.ResolutionStrategyInternal;\nimport org.gradle.api.internal.artifacts.ivyservice.ivyresolve.DependencyVerifyingModuleComponentRepository;\nimport org.gradle.api.internal.artifacts.ivyservice.ivyresolve.ModuleComponentRepository;\nimport org.gradle.api.internal.artifacts.ivyservice.ivyresolve.verification.report.DependencyVerificationReportWriter;\nimport org.gradle.api.internal.artifacts.ivyservice.ivyresolve.verification.report.VerificationReport;\nimport org.gradle.api.internal.artifacts.verification.DependencyVerificationException;\nimport org.gradle.api.internal.artifacts.verification.serializer.DependencyVerificationsXmlReader;\nimport org.gradle.api.internal.artifacts.verification.signatures.BuildTreeDefinedKeys;\nimport org.gradle.api.internal.artifacts.verification.signatures.SignatureVerificationService;\nimport org.gradle.api.internal.artifacts.verification.signatures.SignatureVerificationServiceFactory;\nimport org.gradle.api.internal.artifacts.verification.verifier.DependencyVerifier;\nimport org.gradle.api.internal.properties.GradleProperties;\nimport org.gradle.api.logging.Logger;\nimport org.gradle.api.logging.Logging;\nimport org.gradle.internal.Factory;\nimport org.gradle.internal.UncheckedException;\nimport org.gradle.internal.component.external.model.ModuleComponentArtifactIdentifier;\nimport org.gradle.internal.concurrent.Stoppable;\nimport org.gradle.internal.hash.ChecksumService;\nimport org.gradle.internal.logging.ConsoleRenderer;\nimport org.gradle.internal.operations.BuildOperationContext;\nimport org.gradle.internal.operations.BuildOperationDescriptor;\nimport org.gradle.internal.operations.BuildOperationExecutor;\nimport org.gradle.internal.operations.RunnableBuildOperation;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.net.URI;\nimport java.util.Collection;\nimport java.util.Deque;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class ChecksumAndSignatureVerificationOverride implements DependencyVerificationOverride, ArtifactVerificationOperation, Stoppable {\n    private final static Logger LOGGER = Logging.getLogger(ChecksumAndSignatureVerificationOverride.class);\n\n    private final DependencyVerifier verifier;\n    private final Multimap<ModuleComponentArtifactIdentifier, RepositoryAwareVerificationFailure> failures = LinkedHashMultimap.create();\n    private final BuildOperationExecutor buildOperationExecutor;\n    private final ChecksumService checksumService;\n    private final SignatureVerificationService signatureVerificationService;\n    private final DependencyVerificationMode verificationMode;\n    private final Set<VerificationQuery> verificationQueries = Sets.newConcurrentHashSet();\n    private final Deque<VerificationEvent> verificationEvents = Queues.newArrayDeque();\n    private final AtomicBoolean closed = new AtomicBoolean();\n    private final AtomicBoolean hasFatalFailure = new AtomicBoolean();\n    private final DependencyVerificationReportWriter reportWriter;\n\n    public ChecksumAndSignatureVerificationOverride(BuildOperationExecutor buildOperationExecutor,\n                                                    File gradleUserHome,\n                                                    File verificationsFile,\n                                                    BuildTreeDefinedKeys keyrings,\n                                                    ChecksumService checksumService,\n                                                    SignatureVerificationServiceFactory signatureVerificationServiceFactory,\n                                                    DependencyVerificationMode verificationMode,\n                                                    DocumentationRegistry documentationRegistry,\n                                                    File reportsDirectory,\n                                                    Factory<GradleProperties> gradlePropertiesFactory) {\n        this.buildOperationExecutor = buildOperationExecutor;\n        this.checksumService = checksumService;\n        this.verificationMode = verificationMode;\n        try {\n            this.verifier = DependencyVerificationsXmlReader.readFromXml(\n                new FileInputStream(verificationsFile)\n            );\n            this.reportWriter = new DependencyVerificationReportWriter(gradleUserHome.toPath(), documentationRegistry, verificationsFile, verifier.getSuggestedWriteFlags(), reportsDirectory, gradlePropertiesFactory);\n        } catch (FileNotFoundException e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        } catch (DependencyVerificationException e) {\n            throw new DependencyVerificationException(\"Unable to read dependency verification metadata from \" + verificationsFile, e.getCause());\n        }\n        this.signatureVerificationService = signatureVerificationServiceFactory.create(keyrings, keyServers(), verifier.getConfiguration().isUseKeyServers());\n    }\n\n    private List<URI> keyServers() {\n        return DefaultKeyServers.getOrDefaults(verifier.getConfiguration().getKeyServers());\n    }\n\n    @Override\n    public void onArtifact(ArtifactKind kind, ModuleComponentArtifactIdentifier artifact, File mainFile, Factory<File> signatureFile, String repositoryName, String repositoryId) {\n        if (verificationQueries.add(new VerificationQuery(artifact, repositoryId))) {\n            VerificationEvent event = new VerificationEvent(kind, artifact, mainFile, signatureFile, repositoryName);\n            synchronized (verificationEvents) {\n                verificationEvents.add(event);\n            }\n        }\n    }\n\n    private void verifyConcurrently() {\n        hasFatalFailure.set(false);\n        synchronized (verificationEvents) {\n            if (verificationEvents.isEmpty()) {\n                return;\n            }\n        }\n        if (closed.get()) {\n            LOGGER.debug(\"Cannot perform verification of all dependencies because the verification service has been shutdown. Under normal circumstances this shouldn't happen unless a user buildFinished was added in an unexpected way.\");\n            return;\n        }\n        buildOperationExecutor.runAll(queue -> {\n            VerificationEvent event;\n            synchronized (verificationEvents) {\n                while ((event = verificationEvents.poll()) != null) {\n                    VerificationEvent ve = event;\n                    queue.add(new RunnableBuildOperation() {\n                        @Override\n                        public void run(BuildOperationContext context) {\n                            verifier.verify(checksumService, signatureVerificationService, ve.kind, ve.artifact, ve.mainFile, ve.signatureFile.create(), f -> {\n                                synchronized (failures) {\n                                    failures.put(ve.artifact, new RepositoryAwareVerificationFailure(f, ve.repositoryName));\n                                }\n                                if (f.isFatal()) {\n                                    hasFatalFailure.set(true);\n                                }\n                            });\n                        }\n\n                        @Override\n                        public BuildOperationDescriptor.Builder description() {\n                            return BuildOperationDescriptor.displayName(\"Dependency verification\")\n                                .progressDisplayName(\"Verifying \" + ve.artifact);\n                        }\n                    });\n                }\n            }\n        });\n\n    }\n\n    @Override\n    public ModuleComponentRepository overrideDependencyVerification(ModuleComponentRepository original, String resolveContextName, ResolutionStrategyInternal resolutionStrategy) {\n        return new DependencyVerifyingModuleComponentRepository(original, this, verifier.getConfiguration().isVerifySignatures());\n    }\n\n    @Override\n    public void artifactsAccessed(String displayName) {\n        verifyConcurrently();\n        synchronized (failures) {\n            if (hasFatalFailure.get() && !failures.isEmpty()) {\n                // There are fatal failures, but not necessarily on all artifacts so we first filter out\n                // the artifacts which only have not fatal errors\n                failures.asMap().entrySet().removeIf(entry -> {\n                    Collection<RepositoryAwareVerificationFailure> value = entry.getValue();\n                    return value.stream().noneMatch(wrapper -> wrapper.getFailure().isFatal());\n                });\n                VerificationReport report = reportWriter.generateReport(displayName, failures, verifier.getConfiguration().isUseKeyServers());\n                String errorMessage = buildConsoleErrorMessage(report);\n                if (verificationMode == DependencyVerificationMode.LENIENT) {\n                    LOGGER.error(errorMessage);\n                    failures.clear();\n                    hasFatalFailure.set(false);\n                } else {\n                    throw new DependencyVerificationException(errorMessage);\n                }\n            }\n        }\n    }\n\n    public String buildConsoleErrorMessage(VerificationReport report) {\n        String errorMessage = report.getSummary();\n        String htmlReport = new ConsoleRenderer().asClickableFileUrl(report.getHtmlReport());\n        errorMessage += \"\\n\\nOpen this report for more details: \" + htmlReport;\n        return errorMessage;\n    }\n\n    @Override\n    public ResolvedArtifactResult verifiedArtifact(ResolvedArtifactResult artifact) {\n        return new ResolvedArtifactResult() {\n            @Override\n            public File getFile() {\n                artifactsAccessed(artifact.getVariant().getDisplayName());\n                return artifact.getFile();\n            }\n\n            @Override\n            public ResolvedVariantResult getVariant() {\n                return artifact.getVariant();\n            }\n\n            @Override\n            public ComponentArtifactIdentifier getId() {\n                return artifact.getId();\n            }\n\n            @Override\n            public Class<? extends Artifact> getType() {\n                return artifact.getType();\n            }\n        };\n    }\n\n    @Override\n    public void stop() {\n        closed.set(true);\n        signatureVerificationService.stop();\n    }\n\n    private static class VerificationQuery {\n        private final ModuleComponentArtifactIdentifier artifact;\n        private final String repositoryId;\n        private final int hashCode;\n\n        public VerificationQuery(ModuleComponentArtifactIdentifier artifact, String repositoryId) {\n            this.artifact = artifact;\n            this.repositoryId = repositoryId;\n            this.hashCode = precomputeHashCode(artifact, repositoryId);\n        }\n\n        private int precomputeHashCode(ModuleComponentArtifactIdentifier artifact, String repositoryId) {\n            int hashCode = artifact.getComponentIdentifier().hashCode();\n            hashCode = 31 * hashCode + artifact.getFileName().hashCode();\n            hashCode = 31 * hashCode + repositoryId.hashCode();\n            return hashCode;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) {\n                return true;\n            }\n            if (o == null || getClass() != o.getClass()) {\n                return false;\n            }\n\n            VerificationQuery that = (VerificationQuery) o;\n            if (hashCode != that.hashCode) {\n                return false;\n            }\n            if (!artifact.getComponentIdentifier().equals(that.artifact.getComponentIdentifier())) {\n                return false;\n            }\n            if (!artifact.getFileName().equals(that.artifact.getFileName())) {\n                return false;\n            }\n            return repositoryId.equals(that.repositoryId);\n        }\n\n        @Override\n        public int hashCode() {\n            return hashCode;\n        }\n    }\n\n    private static class VerificationEvent {\n        private final ArtifactKind kind;\n        private final ModuleComponentArtifactIdentifier artifact;\n        private final File mainFile;\n        private final Factory<File> signatureFile;\n        private final String repositoryName;\n\n        private VerificationEvent(ArtifactKind kind, ModuleComponentArtifactIdentifier artifact, File mainFile, Factory<File> signatureFile, String repositoryName) {\n            this.kind = kind;\n            this.artifact = artifact;\n            this.mainFile = mainFile;\n            this.signatureFile = signatureFile;\n            this.repositoryName = repositoryName;\n        }\n    }\n}\n", "/*\n * Copyright 2019 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.gradle.api.internal.artifacts.ivyservice.ivyresolve.verification.writer;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Sets;\nimport org.bouncycastle.bcpg.ArmoredOutputStream;\nimport org.bouncycastle.openpgp.PGPPublicKey;\nimport org.bouncycastle.openpgp.PGPPublicKeyRing;\nimport org.gradle.api.Action;\nimport org.gradle.api.Project;\nimport org.gradle.api.UncheckedIOException;\nimport org.gradle.api.artifacts.ArtifactView;\nimport org.gradle.api.artifacts.Configuration;\nimport org.gradle.api.artifacts.component.ModuleComponentIdentifier;\nimport org.gradle.api.internal.artifacts.configurations.ResolutionStrategyInternal;\nimport org.gradle.api.internal.artifacts.ivyservice.ivyresolve.DependencyVerifyingModuleComponentRepository;\nimport org.gradle.api.internal.artifacts.ivyservice.ivyresolve.ModuleComponentRepository;\nimport org.gradle.api.internal.artifacts.ivyservice.ivyresolve.verification.ArtifactVerificationOperation;\nimport org.gradle.api.internal.artifacts.ivyservice.ivyresolve.verification.DefaultKeyServers;\nimport org.gradle.api.internal.artifacts.ivyservice.ivyresolve.verification.DependencyVerificationOverride;\nimport org.gradle.api.internal.artifacts.ivyservice.ivyresolve.verification.utils.PGPUtils;\nimport org.gradle.api.internal.artifacts.verification.DependencyVerificationException;\nimport org.gradle.api.internal.artifacts.verification.model.ChecksumKind;\nimport org.gradle.api.internal.artifacts.verification.model.IgnoredKey;\nimport org.gradle.api.internal.artifacts.verification.serializer.DependencyVerificationsXmlReader;\nimport org.gradle.api.internal.artifacts.verification.serializer.DependencyVerificationsXmlWriter;\nimport org.gradle.api.internal.artifacts.verification.signatures.BuildTreeDefinedKeys;\nimport org.gradle.api.internal.artifacts.verification.signatures.SignatureVerificationResultBuilder;\nimport org.gradle.api.internal.artifacts.verification.signatures.SignatureVerificationService;\nimport org.gradle.api.internal.artifacts.verification.signatures.SignatureVerificationServiceFactory;\nimport org.gradle.api.internal.artifacts.verification.verifier.DependencyVerificationConfiguration;\nimport org.gradle.api.internal.artifacts.verification.verifier.DependencyVerifier;\nimport org.gradle.api.internal.artifacts.verification.verifier.DependencyVerifierBuilder;\nimport org.gradle.api.internal.project.ProjectInternal;\nimport org.gradle.api.invocation.Gradle;\nimport org.gradle.api.logging.Logger;\nimport org.gradle.api.logging.Logging;\nimport org.gradle.internal.Factory;\nimport org.gradle.internal.UncheckedException;\nimport org.gradle.internal.component.external.model.ModuleComponentArtifactIdentifier;\nimport org.gradle.internal.deprecation.DeprecatableConfiguration;\nimport org.gradle.internal.hash.ChecksumService;\nimport org.gradle.internal.operations.BuildOperationContext;\nimport org.gradle.internal.operations.BuildOperationDescriptor;\nimport org.gradle.internal.operations.BuildOperationExecutor;\nimport org.gradle.internal.operations.BuildOperationQueue;\nimport org.gradle.internal.operations.RunnableBuildOperation;\nimport org.gradle.security.internal.Fingerprint;\nimport org.gradle.security.internal.PublicKeyResultBuilder;\nimport org.gradle.security.internal.PublicKeyService;\nimport org.gradle.security.internal.SecuritySupport;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.math.BigInteger;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport static com.google.common.io.Files.getNameWithoutExtension;\n\npublic class WriteDependencyVerificationFile implements DependencyVerificationOverride, ArtifactVerificationOperation {\n    private static final Logger LOGGER = Logging.getLogger(WriteDependencyVerificationFile.class);\n    private static final Action<ArtifactView.ViewConfiguration> MODULE_COMPONENT_FILES = conf -> {\n        conf.componentFilter(id -> id instanceof ModuleComponentIdentifier);\n        conf.setLenient(true);\n    };\n    private static final String PGP = \"pgp\";\n    private static final String MD5 = \"md5\";\n    private static final String SHA1 = \"sha1\";\n    private static final String SHA256 = \"sha256\";\n    private static final String SHA512 = \"sha512\";\n    private static final Set<String> SUPPORTED_CHECKSUMS = ImmutableSet.of(MD5, SHA1, SHA256, SHA512, PGP);\n    private static final Set<String> SECURE_CHECKSUMS = ImmutableSet.of(SHA256, SHA512, PGP);\n    private static final String PGP_VERIFICATION_FAILED = \"PGP verification failed\";\n    private static final String KEY_NOT_DOWNLOADED = \"Key couldn't be downloaded from any key server\";\n\n    private final DependencyVerifierBuilder verificationsBuilder = new DependencyVerifierBuilder();\n    private final BuildOperationExecutor buildOperationExecutor;\n    private final List<String> checksums;\n    private final Set<VerificationEntry> entriesToBeWritten = Sets.newLinkedHashSetWithExpectedSize(512);\n    private final ChecksumService checksumService;\n    private final File verificationFile;\n    private final BuildTreeDefinedKeys keyrings;\n    private final SignatureVerificationServiceFactory signatureVerificationServiceFactory;\n    private final boolean isDryRun;\n    private final boolean generatePgpInfo;\n    private final boolean isExportKeyring;\n\n    private boolean hasMissingSignatures = false;\n    private boolean hasMissingKeys = false;\n    private boolean hasFailedVerification = false;\n\n    public WriteDependencyVerificationFile(\n        File verificationFile,\n        BuildTreeDefinedKeys keyrings,\n        BuildOperationExecutor buildOperationExecutor,\n        List<String> checksums,\n        ChecksumService checksumService,\n        SignatureVerificationServiceFactory signatureVerificationServiceFactory,\n        boolean isDryRun,\n        boolean exportKeyRing\n    ) {\n        this.buildOperationExecutor = buildOperationExecutor;\n        this.checksums = checksums;\n        this.checksumService = checksumService;\n        this.verificationFile = verificationFile;\n        this.keyrings = keyrings;\n        this.signatureVerificationServiceFactory = signatureVerificationServiceFactory;\n        this.isDryRun = isDryRun;\n        this.generatePgpInfo = checksums.contains(PGP);\n        this.isExportKeyring = exportKeyRing;\n    }\n\n    private void validateChecksums() {\n        assertSupportedChecksums();\n        warnAboutInsecureChecksums();\n    }\n\n    private void assertSupportedChecksums() {\n        for (String checksum : checksums) {\n            if (!SUPPORTED_CHECKSUMS.contains(checksum)) {\n                // we cannot throw an exception at this stage because this happens too early\n                // in the build and the user feedback isn't great (\"cannot create service blah!\")\n                LOGGER.warn(\"Invalid checksum type: '\" + checksum + \"'. You must choose one or more in \" + SUPPORTED_CHECKSUMS);\n            }\n        }\n        if (checksums.isEmpty()) {\n            throw new DependencyVerificationException(\"You must specify at least one checksum type to use. You must choose one or more in \" + SUPPORTED_CHECKSUMS);\n        }\n        assertPgpHasChecksumFallback(checksums);\n    }\n\n    private void assertPgpHasChecksumFallback(List<String> kinds) {\n        if (kinds.size() == 1 && PGP.equals(kinds.get(0))) {\n            throw new DependencyVerificationException(\"Generating a file with signature verification requires at least one checksum type (sha256 or sha512) as fallback.\");\n        }\n    }\n\n    private void warnAboutInsecureChecksums() {\n        if (checksums.stream().noneMatch(SECURE_CHECKSUMS::contains)) {\n            LOGGER.warn(\"You chose to generate \" + String.join(\" and \", checksums) + \" checksums but they are all considered insecure. You should consider adding at least one of \" + String.join(\" or \", SECURE_CHECKSUMS) + \".\");\n        }\n    }\n\n    @Override\n    public ModuleComponentRepository overrideDependencyVerification(ModuleComponentRepository original, String resolveContextName, ResolutionStrategyInternal resolutionStrategy) {\n        return new DependencyVerifyingModuleComponentRepository(original, this, generatePgpInfo);\n    }\n\n    @Override\n    public void buildFinished(Gradle gradle) {\n        ensureOutputDirCreated();\n        maybeReadExistingFile();\n        // when we generate the verification file, we intentionally ignore if the \"use key servers\" flag is false\n        // because otherwise it forces the user to remove the option in the XML file, generate, then switch it back.\n        boolean offline = gradle.getStartParameter().isOffline();\n        SignatureVerificationService signatureVerificationService = signatureVerificationServiceFactory.create(\n            keyrings,\n            DefaultKeyServers.getOrDefaults(verificationsBuilder.getKeyServers()),\n            !offline\n        );\n        if (!verificationsBuilder.isUseKeyServers() && !offline) {\n            LOGGER.lifecycle(\"Will use key servers to download missing keys. If you really want to ignore key servers when generating the verification file, you can use the --offline flag in addition\");\n        }\n        try {\n            validateChecksums();\n            resolveAllConfigurationsConcurrently(gradle);\n            computeChecksumsConcurrently(signatureVerificationService);\n            writeEntriesSerially();\n            serializeResult(signatureVerificationService);\n        } catch (IOException e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        } finally {\n            signatureVerificationService.stop();\n        }\n    }\n\n    public boolean ensureOutputDirCreated() {\n        return verificationFile.getParentFile().mkdirs();\n    }\n\n    private void serializeResult(SignatureVerificationService signatureVerificationService) throws IOException {\n        File out = isDryRun\n            ? dryRunVerificationFile()\n            : verificationFile;\n        if (generatePgpInfo) {\n            verificationsBuilder.setVerifySignatures(true);\n        }\n        DependencyVerifier verifier = verificationsBuilder.build();\n        DependencyVerificationsXmlWriter.serialize(\n            verifier,\n            new FileOutputStream(out)\n        );\n        if (isExportKeyring) {\n            exportKeys(signatureVerificationService, verifier);\n        }\n    }\n\n    private File dryRunVerificationFile() {\n        return new File(verificationFile.getParent(), getNameWithoutExtension(verificationFile.getName()) + \".dryrun.xml\");\n    }\n\n    private void exportKeys(SignatureVerificationService signatureVerificationService, DependencyVerifier verifier) throws IOException {\n        BuildTreeDefinedKeys keys = isDryRun ? keyrings.dryRun() : keyrings;\n        Set<String> keysToExport = Sets.newHashSet();\n        verifier.getConfiguration()\n            .getTrustedKeys()\n            .stream()\n            .map(DependencyVerificationConfiguration.TrustedKey::getKeyId)\n            .forEach(keysToExport::add);\n        verifier.getConfiguration()\n            .getIgnoredKeys()\n            .stream()\n            .map(IgnoredKey::getKeyId)\n            .forEach(keysToExport::add);\n        verifier.getVerificationMetadata()\n            .stream()\n            .flatMap(md -> md.getArtifactVerifications().stream())\n            .flatMap(avm -> Stream.concat(avm.getTrustedPgpKeys().stream(), avm.getIgnoredPgpKeys().stream().map(IgnoredKey::getKeyId)))\n            .forEach(keysToExport::add);\n        exportKeyRingCollection(signatureVerificationService.getPublicKeyService(), keys, keysToExport);\n    }\n\n    private void maybeReadExistingFile() {\n        if (verificationFile.exists()) {\n            LOGGER.info(\"Found dependency verification metadata file, updating\");\n            try {\n                DependencyVerificationsXmlReader.readFromXml(new FileInputStream(verificationFile), verificationsBuilder);\n            } catch (FileNotFoundException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n    }\n\n    private void writeEntriesSerially() {\n        AtomicReference<PgpEntry> previousEntry = new AtomicReference<>();\n        entriesToBeWritten.stream()\n            .sorted()\n            .filter(this::shouldWriteEntry)\n            .forEachOrdered(e -> registerEntryToBuilder(e, previousEntry));\n        printWarnings();\n    }\n\n    private void printWarnings() {\n        if (hasMissingKeys || hasFailedVerification) {\n            StringBuilder sb = new StringBuilder(\"A verification file was generated but some problems were discovered:\\n\");\n            if (hasMissingSignatures) {\n                sb.append(\"   - some artifacts aren't signed or the signature couldn't be retrieved.\");\n                sb.append(\"\\n\");\n            }\n            if (hasMissingKeys) {\n                sb.append(\"   - some keys couldn't be downloaded. They were automatically added as ignored keys but you should review if this is acceptable. Look for entries with the following comment: \");\n                sb.append(KEY_NOT_DOWNLOADED);\n                sb.append(\"\\n\");\n            }\n            if (hasFailedVerification) {\n                sb.append(\"   - some signature verification failed. Checksums were generated for those artifacts but you MUST check if there's an actual problem. Look for entries with the following comment: \");\n                sb.append(PGP_VERIFICATION_FAILED);\n                sb.append(\"\\n\");\n            }\n            LOGGER.warn(sb.toString());\n        }\n    }\n\n    private void registerEntryToBuilder(VerificationEntry entry, AtomicReference<PgpEntry> previousEntry) {\n        // checksums are written _after_ PGP, so if the previous entry was PGP and\n        // that it matches the artifact id we don't always need to write the checksum\n        PgpEntry pgpEntry = previousEntry.get();\n        if (pgpEntry != null && !pgpEntry.id.equals(entry.id)) {\n            // previous entry was on unrelated module\n            pgpEntry = null;\n            previousEntry.set(null);\n        }\n        if (entry instanceof ChecksumEntry) {\n            ChecksumEntry checksum = (ChecksumEntry) entry;\n            if (pgpEntry == null || (entry.id.equals(pgpEntry.id) && pgpEntry.isRequiringChecksums())) {\n                String label = \"Generated by Gradle\";\n                if (pgpEntry != null) {\n                    if (pgpEntry.isFailed()) {\n                        hasFailedVerification = true;\n                        label += \" because PGP signature verification failed!\";\n                    } else {\n                        if (pgpEntry.hasSignatureFile()) {\n                            hasMissingKeys = true;\n                            label += \" because a key couldn't be downloaded\";\n                        } else {\n                            hasMissingSignatures = true;\n                            label += \" because artifact wasn't signed\";\n                        }\n                    }\n                }\n                verificationsBuilder.addChecksum(entry.id, checksum.getChecksumKind(), checksum.getChecksum(), label);\n            }\n        } else {\n            PgpEntry pgp = (PgpEntry) entry;\n            previousEntry.set(pgp);\n            Set<String> failedKeys = Sets.newTreeSet(pgp.getFailed());\n            for (String failedKey : failedKeys) {\n                verificationsBuilder.addIgnoredKey(pgp.id, new IgnoredKey(failedKey, PGP_VERIFICATION_FAILED));\n            }\n            if (pgp.hasArtifactLevelKeys()) {\n                for (String key : pgp.getArtifactLevelKeys()) {\n                    if (!failedKeys.contains(key)) {\n                        verificationsBuilder.addTrustedKey(pgp.id, key);\n                    }\n                }\n            }\n        }\n    }\n\n    private boolean shouldWriteEntry(VerificationEntry entry) {\n        if (entry instanceof ChecksumEntry) {\n            return ((ChecksumEntry) entry).getChecksum() != null && !isTrustedArtifact(entry.id);\n        }\n        return !isTrustedArtifact(entry.id);\n    }\n\n    private void resolveAllConfigurationsConcurrently(Gradle gradle) {\n        buildOperationExecutor.runAllWithAccessToProjectState(queue -> {\n            Set<Project> allprojects = gradle.getRootProject().getAllprojects();\n            for (Project project : allprojects) {\n                queue.add(new RunnableBuildOperation() {\n                    @Override\n                    public void run(BuildOperationContext context) {\n                        resolveAllConfigurationsAndForceDownload(project);\n                    }\n\n                    @Override\n                    public BuildOperationDescriptor.Builder description() {\n                        String displayName = \"Resolving configurations of \" + project.getDisplayName();\n                        return BuildOperationDescriptor.displayName(displayName)\n                            .progressDisplayName(displayName);\n                    }\n                });\n            }\n        });\n    }\n\n    private void computeChecksumsConcurrently(SignatureVerificationService signatureVerificationService) {\n        Set<String> collectedIgnoredKeys = generatePgpInfo ? Sets.newConcurrentHashSet() : null;\n        buildOperationExecutor.runAll(queue -> {\n            for (VerificationEntry entry : entriesToBeWritten) {\n                if (shouldSkipVerification(entry.getArtifactKind())) {\n                    continue;\n                }\n                if (!entry.getFile().exists()) {\n                    LOGGER.warn(\"Cannot compute checksum for \" + entry.getFile() + \" because it doesn't exist. It may indicate a corrupt or tampered cache.\");\n                    continue;\n                }\n                if (entry instanceof ChecksumEntry) {\n                    queueChecksumVerification(queue, (ChecksumEntry) entry);\n                } else {\n                    queueSignatureVerification(queue, signatureVerificationService, (PgpEntry) entry, collectedIgnoredKeys);\n                }\n            }\n        });\n        if (generatePgpInfo) {\n            postProcessPgpResults(collectedIgnoredKeys);\n        }\n    }\n\n    private void postProcessPgpResults(Set<String> collectedIgnoredKeys) {\n        for (String ignoredKey : collectedIgnoredKeys) {\n            verificationsBuilder.addIgnoredKey(new IgnoredKey(ignoredKey, KEY_NOT_DOWNLOADED));\n        }\n        PgpKeyGrouper grouper = new PgpKeyGrouper(verificationsBuilder, entriesToBeWritten);\n        grouper.performPgpKeyGrouping();\n    }\n\n    private void queueSignatureVerification(BuildOperationQueue<RunnableBuildOperation> queue, SignatureVerificationService signatureVerificationService, PgpEntry entry, Set<String> ignoredKeys) {\n        queue.add(new RunnableBuildOperation() {\n            @Override\n            public void run(BuildOperationContext context) {\n                File signature = entry.getSignatureFile().create();\n                if (signature != null) {\n                    SignatureVerificationResultBuilder builder = new WriterSignatureVerificationResult(ignoredKeys, entry);\n                    signatureVerificationService.verify(entry.file, signature, Collections.emptySet(), Collections.emptySet(), builder);\n                }\n            }\n\n            @Override\n            public BuildOperationDescriptor.Builder description() {\n                return BuildOperationDescriptor.displayName(\"Verifying dependency signature\")\n                    .progressDisplayName(\"Verifying signature of \" + entry.id);\n            }\n        });\n    }\n\n    private void queueChecksumVerification(BuildOperationQueue<RunnableBuildOperation> queue, ChecksumEntry entry) {\n        queue.add(new RunnableBuildOperation() {\n            @Override\n            public void run(BuildOperationContext context) {\n                entry.setChecksum(createHash(entry.getFile(), entry.getChecksumKind()));\n            }\n\n            @Override\n            public BuildOperationDescriptor.Builder description() {\n                return BuildOperationDescriptor.displayName(\"Computing checksums\")\n                    .progressDisplayName(\"Computing checksum of \" + entry.id);\n            }\n        });\n    }\n\n    @Override\n    public void onArtifact(ArtifactKind kind, ModuleComponentArtifactIdentifier id, File mainFile, Factory<File> signatureFile, String repositoryName, String repositoryId) {\n        for (String checksum : checksums) {\n            if (PGP.equals(checksum)) {\n                addPgp(id, kind, mainFile, signatureFile);\n            } else {\n                addChecksum(id, kind, mainFile, ChecksumKind.valueOf(checksum));\n            }\n        }\n    }\n\n    private void addPgp(ModuleComponentArtifactIdentifier id, ArtifactKind kind, File mainFile, Factory<File> signatureFile) {\n        PgpEntry entry = new PgpEntry(id, kind, mainFile, signatureFile);\n        synchronized (entriesToBeWritten) {\n            entriesToBeWritten.add(entry);\n        }\n    }\n\n    private boolean shouldSkipVerification(ArtifactVerificationOperation.ArtifactKind kind) {\n        return kind == ArtifactKind.METADATA && !verificationsBuilder.isVerifyMetadata();\n    }\n\n    private void addChecksum(ModuleComponentArtifactIdentifier id, ArtifactKind artifactKind, File file, ChecksumKind kind) {\n        ChecksumEntry e = new ChecksumEntry(id, artifactKind, file, kind);\n        synchronized (entriesToBeWritten) {\n            entriesToBeWritten.add(e);\n        }\n    }\n\n    private boolean isTrustedArtifact(ModuleComponentArtifactIdentifier id) {\n        return verificationsBuilder.getTrustedArtifacts().stream().anyMatch(artifact -> artifact.matches(id));\n    }\n\n    private String createHash(File file, ChecksumKind kind) {\n        try {\n            return checksumService.hash(file, kind.getAlgorithm()).toString();\n        } catch (Exception e) {\n            LOGGER.debug(\"Error while snapshotting \" + file, e);\n            return null;\n        }\n    }\n\n    private static void resolveAllConfigurationsAndForceDownload(Project project) {\n        ((ProjectInternal) project).getOwner().applyToMutableState(p ->\n            p.getConfigurations().all(cnf -> {\n                if (((DeprecatableConfiguration) cnf).canSafelyBeResolved()) {\n                    try {\n                        resolveAndDownloadExternalFiles(cnf);\n                    } catch (Exception e) {\n                        LOGGER.debug(\"Cannot resolve configuration {}: {}\", cnf.getName(), e.getMessage());\n                    }\n                }\n            })\n        );\n    }\n\n    private static void resolveAndDownloadExternalFiles(Configuration cnf) {\n        cnf.getIncoming().artifactView(MODULE_COMPONENT_FILES).getFiles().getFiles();\n    }\n\n    private void exportKeyRingCollection(PublicKeyService publicKeyService, BuildTreeDefinedKeys keyrings, Set<String> publicKeys) throws IOException {\n        List<PGPPublicKeyRing> existingRings = loadExistingKeyRing(keyrings);\n        PGPPublicKeyRingListBuilder builder = new PGPPublicKeyRingListBuilder();\n        for (String publicKey : publicKeys) {\n            if (publicKey.length() <= 16) {\n                publicKeyService.findByLongId(new BigInteger(publicKey, 16).longValue(), builder);\n            } else {\n                publicKeyService.findByFingerprint(Fingerprint.fromString(publicKey).getBytes(), builder);\n            }\n        }\n\n        List<PGPPublicKeyRing> keysSeenInVerifier = builder.build()\n            .stream()\n            .filter(WriteDependencyVerificationFile::hasAtLeastOnePublicKey)\n            .filter(e -> existingRings.stream().noneMatch(ring -> keyIds(ring).equals(keyIds(e))))\n            .collect(Collectors.toList());\n        ImmutableList<PGPPublicKeyRing> allKeyRings = ImmutableList.<PGPPublicKeyRing>builder()\n            .addAll(existingRings)\n            .addAll(keysSeenInVerifier)\n            .build();\n        File keyringFile = keyrings.getBinaryKeyringsFile();\n        writeBinaryKeyringFile(keyringFile, allKeyRings);\n        File asciiArmoredFile = keyrings.getAsciiKeyringsFile();\n        writeAsciiArmoredKeyRingFile(asciiArmoredFile, allKeyRings);\n        LOGGER.lifecycle(\"Exported {} keys to {} and {}\", allKeyRings.size(), keyringFile, asciiArmoredFile);\n    }\n\n    private void writeAsciiArmoredKeyRingFile(File ascii, ImmutableList<PGPPublicKeyRing> allKeyRings) throws IOException {\n        if (ascii.exists()) {\n            ascii.delete();\n        }\n        boolean hasKey = false;\n        for (PGPPublicKeyRing keyRing : allKeyRings) {\n            // First let's write some human readable info about the keyring being serialized\n            try (OutputStream out = new FileOutputStream(ascii, true)) {\n                if (hasKey) {\n                    out.write('\\n');\n                }\n                Iterator<PGPPublicKey> pks = keyRing.getPublicKeys();\n                while (pks.hasNext()) {\n                    boolean hasUid = false;\n                    PGPPublicKey pk = pks.next();\n                    String keyType = pk.isMasterKey() ? \"pub\" : \"sub\";\n                    out.write((keyType + \"    \" + SecuritySupport.toLongIdHexString(pk.getKeyID()).toUpperCase() + \"\\n\").getBytes(StandardCharsets.US_ASCII));\n                    List<String> userIDs = PGPUtils.getUserIDs(pk);\n                    for(String uid : userIDs) {\n                        hasUid = true;\n                        out.write((\"uid    \" + uid + \"\\n\").getBytes(StandardCharsets.US_ASCII));\n                    }\n                    if (hasUid) {\n                        out.write('\\n');\n                    }\n                }\n            }\n            // Then write the ascii armored keyring\n            try (FileOutputStream fos = new FileOutputStream(ascii, true);\n                 ArmoredOutputStream out = new ArmoredOutputStream(fos)) {\n                keyRing.encode(out, true);\n            }\n            hasKey = true;\n        }\n    }\n\n    private void writeBinaryKeyringFile(File keyringFile, ImmutableList<PGPPublicKeyRing> allKeyRings) throws IOException {\n        try (OutputStream out = new FileOutputStream(keyringFile)) {\n            for (PGPPublicKeyRing keyRing : allKeyRings) {\n                keyRing.encode(out, true);\n            }\n        }\n    }\n\n    private static class PGPPublicKeyRingListBuilder implements PublicKeyResultBuilder {\n        private final ImmutableList.Builder<PGPPublicKeyRing> builder = ImmutableList.builder();\n\n        public void keyRing(PGPPublicKeyRing keyring) {\n            builder.add(keyring);\n        }\n\n        @Override\n        public void publicKey(PGPPublicKey publicKey) {\n\n        }\n\n        public List<PGPPublicKeyRing> build() {\n            return builder.build();\n        }\n    }\n\n    private static boolean hasAtLeastOnePublicKey(PGPPublicKeyRing ring) {\n        return ring.getPublicKeys().hasNext();\n    }\n\n    private List<PGPPublicKeyRing> loadExistingKeyRing(BuildTreeDefinedKeys keyrings) throws IOException {\n        List<PGPPublicKeyRing> existingRings;\n        if (!isDryRun) {\n            existingRings = keyrings.loadKeys();\n            LOGGER.info(\"Existing keyring file contains {} keyrings\", existingRings.size());\n        } else {\n            existingRings = Collections.emptyList();\n        }\n        return existingRings;\n    }\n\n    private static Set<Long> keyIds(PGPPublicKeyRing ring) {\n        return ImmutableList.copyOf(ring.getPublicKeys()).stream().map(PGPPublicKey::getKeyID).collect(Collectors.toSet());\n    }\n}\n", "/*\n * Copyright 2018 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.gradle.api.internal.artifacts.ivyservice.modulecache;\n\nimport com.google.common.collect.MapMaker;\nimport com.google.common.collect.Maps;\nimport org.gradle.api.artifacts.component.ComponentArtifactIdentifier;\nimport org.gradle.api.internal.artifacts.ivyservice.ivyresolve.BaseModuleComponentRepository;\nimport org.gradle.api.internal.artifacts.ivyservice.ivyresolve.ModuleComponentRepository;\nimport org.gradle.api.internal.artifacts.ivyservice.resolveengine.artifact.ResolvableArtifact;\nimport org.gradle.api.logging.Logger;\nimport org.gradle.api.logging.Logging;\nimport org.gradle.internal.concurrent.Stoppable;\n\nimport java.util.Map;\n\n/**\n * Caches the dependency metadata (descriptors, artifact files) in memory.\n */\npublic class ResolvedArtifactCaches implements Stoppable {\n\n    private final static Logger LOG = Logging.getLogger(ResolvedArtifactCaches.class);\n\n    private final Map<String, Map<ComponentArtifactIdentifier, ResolvableArtifact>> cachePerRepo = new MapMaker().makeMap();\n    private final Map<String, Map<ComponentArtifactIdentifier, ResolvableArtifact>> cachePerRepoWithVerification = new MapMaker().makeMap();\n\n    /**\n     * For a remote repository, the only thing required is a resolved artifact cache.\n     * The rest of the in-memory caching is handled by the CachingModuleComponentRepository.\n     */\n    public ModuleComponentRepository provideResolvedArtifactCache(ModuleComponentRepository input, boolean withVerification) {\n        Map<ComponentArtifactIdentifier, ResolvableArtifact> caches = getResolvedArtifactCache(withVerification ? cachePerRepoWithVerification : cachePerRepo, input);\n        return new ResolvedArtifactCacheProvidingModuleComponentRepository(caches, input);\n    }\n\n    private Map<ComponentArtifactIdentifier, ResolvableArtifact> getResolvedArtifactCache(Map<String, Map<ComponentArtifactIdentifier, ResolvableArtifact>> cache, ModuleComponentRepository input) {\n        Map<ComponentArtifactIdentifier, ResolvableArtifact> resolvedArtifactCache = cache.get(input.getId());\n        if (resolvedArtifactCache == null) {\n            LOG.debug(\"Creating new in-memory cache for repo '{}' [{}].\", input.getName(), input.getId());\n            resolvedArtifactCache = Maps.newConcurrentMap();\n            cache.put(input.getId(), resolvedArtifactCache);\n        } else {\n            LOG.debug(\"Reusing in-memory cache for repo '{}' [{}].\", input.getName(), input.getId());\n        }\n        return resolvedArtifactCache;\n    }\n\n    @Override\n    public void stop() {\n        cachePerRepo.clear();\n        cachePerRepoWithVerification.clear();\n    }\n\n    private static class ResolvedArtifactCacheProvidingModuleComponentRepository extends BaseModuleComponentRepository {\n\n        private final Map<ComponentArtifactIdentifier, ResolvableArtifact> resolvedArtifactCache;\n\n        public ResolvedArtifactCacheProvidingModuleComponentRepository(Map<ComponentArtifactIdentifier, ResolvableArtifact> resolvedArtifactsCache, ModuleComponentRepository delegate) {\n            super(delegate);\n            this.resolvedArtifactCache = resolvedArtifactsCache;\n        }\n\n        @Override\n        public Map<ComponentArtifactIdentifier, ResolvableArtifact> getArtifactCache() {\n            return resolvedArtifactCache;\n        }\n    }\n}\n"], "filenames": ["subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/DependencyVerifyingModuleComponentRepository.java", "subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/ResolveIvyFactory.java", "subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/verification/ArtifactVerificationOperation.java", "subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/verification/ChecksumAndSignatureVerificationOverride.java", "subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/verification/writer/WriteDependencyVerificationFile.java", "subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/modulecache/ResolvedArtifactCaches.java"], "buggy_code_start_loc": [182, 132, 25, 23, 440, 38], "buggy_code_end_loc": [189, 133, 26, 236, 447, 63], "fixing_code_start_loc": [181, 132, 24, 22, 439, 39], "fixing_code_end_loc": [181, 133, 24, 271, 439, 66], "type": "CWE-829", "message": "Gradle is a build tool with a focus on build automation and support for multi-language development. In some cases, Gradle may skip that verification and accept a dependency that would otherwise fail the build as an untrusted external artifact. This occurs when dependency verification is disabled on one or more configurations and those configurations have common dependencies with other configurations that have dependency verification enabled. If the configuration that has dependency verification disabled is resolved first, Gradle does not verify the common dependencies for the configuration that has dependency verification enabled. Gradle 7.4 fixes that issue by validating artifacts at least once if they are present in a resolved configuration that has dependency verification active. For users who cannot update either do not use `ResolutionStrategy.disableDependencyVerification()` and do not use plugins that use that method to disable dependency verification for a single configuration or make sure resolution of configuration that disable that feature do not happen in builds that resolve configuration where the feature is enabled.", "other": {"cve": {"id": "CVE-2022-23630", "sourceIdentifier": "security-advisories@github.com", "published": "2022-02-10T20:15:07.317", "lastModified": "2022-02-17T17:41:49.627", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Gradle is a build tool with a focus on build automation and support for multi-language development. In some cases, Gradle may skip that verification and accept a dependency that would otherwise fail the build as an untrusted external artifact. This occurs when dependency verification is disabled on one or more configurations and those configurations have common dependencies with other configurations that have dependency verification enabled. If the configuration that has dependency verification disabled is resolved first, Gradle does not verify the common dependencies for the configuration that has dependency verification enabled. Gradle 7.4 fixes that issue by validating artifacts at least once if they are present in a resolved configuration that has dependency verification active. For users who cannot update either do not use `ResolutionStrategy.disableDependencyVerification()` and do not use plugins that use that method to disable dependency verification for a single configuration or make sure resolution of configuration that disable that feature do not happen in builds that resolve configuration where the feature is enabled."}, {"lang": "es", "value": "Gradle es una herramienta de compilaci\u00f3n con un enfoque en la automatizaci\u00f3n de la compilaci\u00f3n y el soporte para el desarrollo multiling\u00fce. En algunos casos, Gradle puede omitir esa verificaci\u00f3n y aceptar una dependencia que de otra manera fallar\u00eda la construcci\u00f3n como un artefacto externo no confiable. Esto ocurre cuando la verificaci\u00f3n de dependencias est\u00e1 deshabilitada en una o m\u00e1s configuraciones y esas configuraciones presentan dependencias comunes con otras configuraciones que presentan la verificaci\u00f3n de dependencias habilitada. Si la configuraci\u00f3n que presenta deshabilitada la verificaci\u00f3n de dependencias se resuelve primero, Gradle no verifica las dependencias comunes para la configuraci\u00f3n que presenta habilitada la verificaci\u00f3n de dependencias. Gradle versi\u00f3n 7.4 corrige este problema al comprobar los artefactos al menos una vez si est\u00e1n presentes en una configuraci\u00f3n resuelta que presenta activa la verificaci\u00f3n de dependencias. Para usuarios que no puedan actualizar, o bien no usen \"ResolutionStrategy.disableDependencyVerification()\" y no usen plugins que usen ese m\u00e9todo para deshabilitar la verificaci\u00f3n de dependencias para una \u00fanica configuraci\u00f3n, o bien aseg\u00farense de que la resoluci\u00f3n de la configuraci\u00f3n que deshabilita esa caracter\u00edstica no sea producida en las compilaciones que resuelven la configuraci\u00f3n donde la caracter\u00edstica est\u00e1 habilitada"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.6, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.6, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 6.8, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-829"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gradle:gradle:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.2.0", "versionEndIncluding": "7.3.3", "matchCriteriaId": "E131D9F9-B2A5-48D3-93CE-E60D5706824C"}]}]}], "references": [{"url": "https://docs.gradle.org/7.4/release-notes.html", "source": "security-advisories@github.com", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/gradle/gradle/commit/88ab9b652933bc3b2e3161b31ad8b8f4f0516351", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gradle/gradle/security/advisories/GHSA-9pf5-88jw-3qgr", "source": "security-advisories@github.com", "tags": ["Mitigation", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gradle/gradle/commit/88ab9b652933bc3b2e3161b31ad8b8f4f0516351"}}