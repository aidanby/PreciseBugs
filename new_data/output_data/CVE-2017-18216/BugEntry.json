{"buggy_code": ["/* -*- mode: c; c-basic-offset: 8; -*-\n * vim: noexpandtab sw=8 ts=8 sts=0:\n *\n * Copyright (C) 2004, 2005 Oracle.  All rights reserved.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public\n * License along with this program; if not, write to the\n * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 021110-1307, USA.\n */\n\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/configfs.h>\n\n#include \"tcp.h\"\n#include \"nodemanager.h\"\n#include \"heartbeat.h\"\n#include \"masklog.h\"\n#include \"sys.h\"\n\n/* for now we operate under the assertion that there can be only one\n * cluster active at a time.  Changing this will require trickling\n * cluster references throughout where nodes are looked up */\nstruct o2nm_cluster *o2nm_single_cluster = NULL;\n\nchar *o2nm_fence_method_desc[O2NM_FENCE_METHODS] = {\n\t\t\"reset\",\t/* O2NM_FENCE_RESET */\n\t\t\"panic\",\t/* O2NM_FENCE_PANIC */\n};\n\nstruct o2nm_node *o2nm_get_node_by_num(u8 node_num)\n{\n\tstruct o2nm_node *node = NULL;\n\n\tif (node_num >= O2NM_MAX_NODES || o2nm_single_cluster == NULL)\n\t\tgoto out;\n\n\tread_lock(&o2nm_single_cluster->cl_nodes_lock);\n\tnode = o2nm_single_cluster->cl_nodes[node_num];\n\tif (node)\n\t\tconfig_item_get(&node->nd_item);\n\tread_unlock(&o2nm_single_cluster->cl_nodes_lock);\nout:\n\treturn node;\n}\nEXPORT_SYMBOL_GPL(o2nm_get_node_by_num);\n\nint o2nm_configured_node_map(unsigned long *map, unsigned bytes)\n{\n\tstruct o2nm_cluster *cluster = o2nm_single_cluster;\n\n\tBUG_ON(bytes < (sizeof(cluster->cl_nodes_bitmap)));\n\n\tif (cluster == NULL)\n\t\treturn -EINVAL;\n\n\tread_lock(&cluster->cl_nodes_lock);\n\tmemcpy(map, cluster->cl_nodes_bitmap, sizeof(cluster->cl_nodes_bitmap));\n\tread_unlock(&cluster->cl_nodes_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(o2nm_configured_node_map);\n\nstatic struct o2nm_node *o2nm_node_ip_tree_lookup(struct o2nm_cluster *cluster,\n\t\t\t\t\t\t  __be32 ip_needle,\n\t\t\t\t\t\t  struct rb_node ***ret_p,\n\t\t\t\t\t\t  struct rb_node **ret_parent)\n{\n\tstruct rb_node **p = &cluster->cl_node_ip_tree.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct o2nm_node *node, *ret = NULL;\n\n\twhile (*p) {\n\t\tint cmp;\n\n\t\tparent = *p;\n\t\tnode = rb_entry(parent, struct o2nm_node, nd_ip_node);\n\n\t\tcmp = memcmp(&ip_needle, &node->nd_ipv4_address,\n\t\t\t\tsizeof(ip_needle));\n\t\tif (cmp < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (cmp > 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\tret = node;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret_p != NULL)\n\t\t*ret_p = p;\n\tif (ret_parent != NULL)\n\t\t*ret_parent = parent;\n\n\treturn ret;\n}\n\nstruct o2nm_node *o2nm_get_node_by_ip(__be32 addr)\n{\n\tstruct o2nm_node *node = NULL;\n\tstruct o2nm_cluster *cluster = o2nm_single_cluster;\n\n\tif (cluster == NULL)\n\t\tgoto out;\n\n\tread_lock(&cluster->cl_nodes_lock);\n\tnode = o2nm_node_ip_tree_lookup(cluster, addr, NULL, NULL);\n\tif (node)\n\t\tconfig_item_get(&node->nd_item);\n\tread_unlock(&cluster->cl_nodes_lock);\n\nout:\n\treturn node;\n}\nEXPORT_SYMBOL_GPL(o2nm_get_node_by_ip);\n\nvoid o2nm_node_put(struct o2nm_node *node)\n{\n\tconfig_item_put(&node->nd_item);\n}\nEXPORT_SYMBOL_GPL(o2nm_node_put);\n\nvoid o2nm_node_get(struct o2nm_node *node)\n{\n\tconfig_item_get(&node->nd_item);\n}\nEXPORT_SYMBOL_GPL(o2nm_node_get);\n\nu8 o2nm_this_node(void)\n{\n\tu8 node_num = O2NM_MAX_NODES;\n\n\tif (o2nm_single_cluster && o2nm_single_cluster->cl_has_local)\n\t\tnode_num = o2nm_single_cluster->cl_local_node;\n\n\treturn node_num;\n}\nEXPORT_SYMBOL_GPL(o2nm_this_node);\n\n/* node configfs bits */\n\nstatic struct o2nm_cluster *to_o2nm_cluster(struct config_item *item)\n{\n\treturn item ?\n\t\tcontainer_of(to_config_group(item), struct o2nm_cluster,\n\t\t\t     cl_group)\n\t\t: NULL;\n}\n\nstatic struct o2nm_node *to_o2nm_node(struct config_item *item)\n{\n\treturn item ? container_of(item, struct o2nm_node, nd_item) : NULL;\n}\n\nstatic void o2nm_node_release(struct config_item *item)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tkfree(node);\n}\n\nstatic ssize_t o2nm_node_num_show(struct config_item *item, char *page)\n{\n\treturn sprintf(page, \"%d\\n\", to_o2nm_node(item)->nd_num);\n}\n\nstatic struct o2nm_cluster *to_o2nm_cluster_from_node(struct o2nm_node *node)\n{\n\t/* through the first node_set .parent\n\t * mycluster/nodes/mynode == o2nm_cluster->o2nm_node_group->o2nm_node */\n\treturn to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);\n}\n\nenum {\n\tO2NM_NODE_ATTR_NUM = 0,\n\tO2NM_NODE_ATTR_PORT,\n\tO2NM_NODE_ATTR_ADDRESS,\n};\n\nstatic ssize_t o2nm_node_num_store(struct config_item *item, const char *page,\n\t\t\t\t   size_t count)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n\tunsigned long tmp;\n\tchar *p = (char *)page;\n\tint ret = 0;\n\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\n\tif (tmp >= O2NM_MAX_NODES)\n\t\treturn -ERANGE;\n\n\t/* once we're in the cl_nodes tree networking can look us up by\n\t * node number and try to use our address and port attributes\n\t * to connect to this node.. make sure that they've been set\n\t * before writing the node attribute? */\n\tif (!test_bit(O2NM_NODE_ATTR_ADDRESS, &node->nd_set_attributes) ||\n\t    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))\n\t\treturn -EINVAL; /* XXX */\n\n\twrite_lock(&cluster->cl_nodes_lock);\n\tif (cluster->cl_nodes[tmp])\n\t\tret = -EEXIST;\n\telse if (test_and_set_bit(O2NM_NODE_ATTR_NUM,\n\t\t\t&node->nd_set_attributes))\n\t\tret = -EBUSY;\n\telse  {\n\t\tcluster->cl_nodes[tmp] = node;\n\t\tnode->nd_num = tmp;\n\t\tset_bit(tmp, cluster->cl_nodes_bitmap);\n\t}\n\twrite_unlock(&cluster->cl_nodes_lock);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\nstatic ssize_t o2nm_node_ipv4_port_show(struct config_item *item, char *page)\n{\n\treturn sprintf(page, \"%u\\n\", ntohs(to_o2nm_node(item)->nd_ipv4_port));\n}\n\nstatic ssize_t o2nm_node_ipv4_port_store(struct config_item *item,\n\t\t\t\t\t const char *page, size_t count)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tunsigned long tmp;\n\tchar *p = (char *)page;\n\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\n\tif (tmp == 0)\n\t\treturn -EINVAL;\n\tif (tmp >= (u16)-1)\n\t\treturn -ERANGE;\n\n\tif (test_and_set_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))\n\t\treturn -EBUSY;\n\tnode->nd_ipv4_port = htons(tmp);\n\n\treturn count;\n}\n\nstatic ssize_t o2nm_node_ipv4_address_show(struct config_item *item, char *page)\n{\n\treturn sprintf(page, \"%pI4\\n\", &to_o2nm_node(item)->nd_ipv4_address);\n}\n\nstatic ssize_t o2nm_node_ipv4_address_store(struct config_item *item,\n\t\t\t\t\t    const char *page,\n\t\t\t\t\t    size_t count)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n\tint ret, i;\n\tstruct rb_node **p, *parent;\n\tunsigned int octets[4];\n\t__be32 ipv4_addr = 0;\n\n\tret = sscanf(page, \"%3u.%3u.%3u.%3u\", &octets[3], &octets[2],\n\t\t     &octets[1], &octets[0]);\n\tif (ret != 4)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(octets); i++) {\n\t\tif (octets[i] > 255)\n\t\t\treturn -ERANGE;\n\t\tbe32_add_cpu(&ipv4_addr, octets[i] << (i * 8));\n\t}\n\n\tret = 0;\n\twrite_lock(&cluster->cl_nodes_lock);\n\tif (o2nm_node_ip_tree_lookup(cluster, ipv4_addr, &p, &parent))\n\t\tret = -EEXIST;\n\telse if (test_and_set_bit(O2NM_NODE_ATTR_ADDRESS,\n\t\t\t&node->nd_set_attributes))\n\t\tret = -EBUSY;\n\telse {\n\t\trb_link_node(&node->nd_ip_node, parent, p);\n\t\trb_insert_color(&node->nd_ip_node, &cluster->cl_node_ip_tree);\n\t}\n\twrite_unlock(&cluster->cl_nodes_lock);\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(&node->nd_ipv4_address, &ipv4_addr, sizeof(ipv4_addr));\n\n\treturn count;\n}\n\nstatic ssize_t o2nm_node_local_show(struct config_item *item, char *page)\n{\n\treturn sprintf(page, \"%d\\n\", to_o2nm_node(item)->nd_local);\n}\n\nstatic ssize_t o2nm_node_local_store(struct config_item *item, const char *page,\n\t\t\t\t     size_t count)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n\tunsigned long tmp;\n\tchar *p = (char *)page;\n\tssize_t ret;\n\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\n\ttmp = !!tmp; /* boolean of whether this node wants to be local */\n\n\t/* setting local turns on networking rx for now so we require having\n\t * set everything else first */\n\tif (!test_bit(O2NM_NODE_ATTR_ADDRESS, &node->nd_set_attributes) ||\n\t    !test_bit(O2NM_NODE_ATTR_NUM, &node->nd_set_attributes) ||\n\t    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))\n\t\treturn -EINVAL; /* XXX */\n\n\t/* the only failure case is trying to set a new local node\n\t * when a different one is already set */\n\tif (tmp && tmp == cluster->cl_has_local &&\n\t    cluster->cl_local_node != node->nd_num)\n\t\treturn -EBUSY;\n\n\t/* bring up the rx thread if we're setting the new local node. */\n\tif (tmp && !cluster->cl_has_local) {\n\t\tret = o2net_start_listening(node);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (!tmp && cluster->cl_has_local &&\n\t    cluster->cl_local_node == node->nd_num) {\n\t\to2net_stop_listening(node);\n\t\tcluster->cl_local_node = O2NM_INVALID_NODE_NUM;\n\t}\n\n\tnode->nd_local = tmp;\n\tif (node->nd_local) {\n\t\tcluster->cl_has_local = tmp;\n\t\tcluster->cl_local_node = node->nd_num;\n\t}\n\n\treturn count;\n}\n\nCONFIGFS_ATTR(o2nm_node_, num);\nCONFIGFS_ATTR(o2nm_node_, ipv4_port);\nCONFIGFS_ATTR(o2nm_node_, ipv4_address);\nCONFIGFS_ATTR(o2nm_node_, local);\n\nstatic struct configfs_attribute *o2nm_node_attrs[] = {\n\t&o2nm_node_attr_num,\n\t&o2nm_node_attr_ipv4_port,\n\t&o2nm_node_attr_ipv4_address,\n\t&o2nm_node_attr_local,\n\tNULL,\n};\n\nstatic struct configfs_item_operations o2nm_node_item_ops = {\n\t.release\t\t= o2nm_node_release,\n};\n\nstatic const struct config_item_type o2nm_node_type = {\n\t.ct_item_ops\t= &o2nm_node_item_ops,\n\t.ct_attrs\t= o2nm_node_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\n/* node set */\n\nstruct o2nm_node_group {\n\tstruct config_group ns_group;\n\t/* some stuff? */\n};\n\n#if 0\nstatic struct o2nm_node_group *to_o2nm_node_group(struct config_group *group)\n{\n\treturn group ?\n\t\tcontainer_of(group, struct o2nm_node_group, ns_group)\n\t\t: NULL;\n}\n#endif\n\nstatic ssize_t o2nm_cluster_attr_write(const char *page, ssize_t count,\n                                       unsigned int *val)\n{\n\tunsigned long tmp;\n\tchar *p = (char *)page;\n\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\n\tif (tmp == 0)\n\t\treturn -EINVAL;\n\tif (tmp >= (u32)-1)\n\t\treturn -ERANGE;\n\n\t*val = tmp;\n\n\treturn count;\n}\n\nstatic ssize_t o2nm_cluster_idle_timeout_ms_show(struct config_item *item,\n\tchar *page)\n{\n\treturn sprintf(page, \"%u\\n\", to_o2nm_cluster(item)->cl_idle_timeout_ms);\n}\n\nstatic ssize_t o2nm_cluster_idle_timeout_ms_store(struct config_item *item,\n\tconst char *page, size_t count)\n{\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster(item);\n\tssize_t ret;\n\tunsigned int val;\n\n\tret =  o2nm_cluster_attr_write(page, count, &val);\n\n\tif (ret > 0) {\n\t\tif (cluster->cl_idle_timeout_ms != val\n\t\t\t&& o2net_num_connected_peers()) {\n\t\t\tmlog(ML_NOTICE,\n\t\t\t     \"o2net: cannot change idle timeout after \"\n\t\t\t     \"the first peer has agreed to it.\"\n\t\t\t     \"  %d connected peers\\n\",\n\t\t\t     o2net_num_connected_peers());\n\t\t\tret = -EINVAL;\n\t\t} else if (val <= cluster->cl_keepalive_delay_ms) {\n\t\t\tmlog(ML_NOTICE, \"o2net: idle timeout must be larger \"\n\t\t\t     \"than keepalive delay\\n\");\n\t\t\tret = -EINVAL;\n\t\t} else {\n\t\t\tcluster->cl_idle_timeout_ms = val;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic ssize_t o2nm_cluster_keepalive_delay_ms_show(\n\tstruct config_item *item, char *page)\n{\n\treturn sprintf(page, \"%u\\n\",\n\t\t\tto_o2nm_cluster(item)->cl_keepalive_delay_ms);\n}\n\nstatic ssize_t o2nm_cluster_keepalive_delay_ms_store(\n\tstruct config_item *item, const char *page, size_t count)\n{\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster(item);\n\tssize_t ret;\n\tunsigned int val;\n\n\tret =  o2nm_cluster_attr_write(page, count, &val);\n\n\tif (ret > 0) {\n\t\tif (cluster->cl_keepalive_delay_ms != val\n\t\t    && o2net_num_connected_peers()) {\n\t\t\tmlog(ML_NOTICE,\n\t\t\t     \"o2net: cannot change keepalive delay after\"\n\t\t\t     \" the first peer has agreed to it.\"\n\t\t\t     \"  %d connected peers\\n\",\n\t\t\t     o2net_num_connected_peers());\n\t\t\tret = -EINVAL;\n\t\t} else if (val >= cluster->cl_idle_timeout_ms) {\n\t\t\tmlog(ML_NOTICE, \"o2net: keepalive delay must be \"\n\t\t\t     \"smaller than idle timeout\\n\");\n\t\t\tret = -EINVAL;\n\t\t} else {\n\t\t\tcluster->cl_keepalive_delay_ms = val;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic ssize_t o2nm_cluster_reconnect_delay_ms_show(\n\tstruct config_item *item, char *page)\n{\n\treturn sprintf(page, \"%u\\n\",\n\t\t\tto_o2nm_cluster(item)->cl_reconnect_delay_ms);\n}\n\nstatic ssize_t o2nm_cluster_reconnect_delay_ms_store(\n\tstruct config_item *item, const char *page, size_t count)\n{\n\treturn o2nm_cluster_attr_write(page, count,\n                               &to_o2nm_cluster(item)->cl_reconnect_delay_ms);\n}\n\nstatic ssize_t o2nm_cluster_fence_method_show(\n\tstruct config_item *item, char *page)\n{\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster(item);\n\tssize_t ret = 0;\n\n\tif (cluster)\n\t\tret = sprintf(page, \"%s\\n\",\n\t\t\t      o2nm_fence_method_desc[cluster->cl_fence_method]);\n\treturn ret;\n}\n\nstatic ssize_t o2nm_cluster_fence_method_store(\n\tstruct config_item *item, const char *page, size_t count)\n{\n\tunsigned int i;\n\n\tif (page[count - 1] != '\\n')\n\t\tgoto bail;\n\n\tfor (i = 0; i < O2NM_FENCE_METHODS; ++i) {\n\t\tif (count != strlen(o2nm_fence_method_desc[i]) + 1)\n\t\t\tcontinue;\n\t\tif (strncasecmp(page, o2nm_fence_method_desc[i], count - 1))\n\t\t\tcontinue;\n\t\tif (to_o2nm_cluster(item)->cl_fence_method != i) {\n\t\t\tprintk(KERN_INFO \"ocfs2: Changing fence method to %s\\n\",\n\t\t\t       o2nm_fence_method_desc[i]);\n\t\t\tto_o2nm_cluster(item)->cl_fence_method = i;\n\t\t}\n\t\treturn count;\n\t}\n\nbail:\n\treturn -EINVAL;\n}\n\nCONFIGFS_ATTR(o2nm_cluster_, idle_timeout_ms);\nCONFIGFS_ATTR(o2nm_cluster_, keepalive_delay_ms);\nCONFIGFS_ATTR(o2nm_cluster_, reconnect_delay_ms);\nCONFIGFS_ATTR(o2nm_cluster_, fence_method);\n\nstatic struct configfs_attribute *o2nm_cluster_attrs[] = {\n\t&o2nm_cluster_attr_idle_timeout_ms,\n\t&o2nm_cluster_attr_keepalive_delay_ms,\n\t&o2nm_cluster_attr_reconnect_delay_ms,\n\t&o2nm_cluster_attr_fence_method,\n\tNULL,\n};\n\nstatic struct config_item *o2nm_node_group_make_item(struct config_group *group,\n\t\t\t\t\t\t     const char *name)\n{\n\tstruct o2nm_node *node = NULL;\n\n\tif (strlen(name) > O2NM_MAX_NAME_LEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tnode = kzalloc(sizeof(struct o2nm_node), GFP_KERNEL);\n\tif (node == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstrcpy(node->nd_name, name); /* use item.ci_namebuf instead? */\n\tconfig_item_init_type_name(&node->nd_item, name, &o2nm_node_type);\n\tspin_lock_init(&node->nd_lock);\n\n\tmlog(ML_CLUSTER, \"o2nm: Registering node %s\\n\", name);\n\n\treturn &node->nd_item;\n}\n\nstatic void o2nm_node_group_drop_item(struct config_group *group,\n\t\t\t\t      struct config_item *item)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster(group->cg_item.ci_parent);\n\n\to2net_disconnect_node(node);\n\n\tif (cluster->cl_has_local &&\n\t    (cluster->cl_local_node == node->nd_num)) {\n\t\tcluster->cl_has_local = 0;\n\t\tcluster->cl_local_node = O2NM_INVALID_NODE_NUM;\n\t\to2net_stop_listening(node);\n\t}\n\n\t/* XXX call into net to stop this node from trading messages */\n\n\twrite_lock(&cluster->cl_nodes_lock);\n\n\t/* XXX sloppy */\n\tif (node->nd_ipv4_address)\n\t\trb_erase(&node->nd_ip_node, &cluster->cl_node_ip_tree);\n\n\t/* nd_num might be 0 if the node number hasn't been set.. */\n\tif (cluster->cl_nodes[node->nd_num] == node) {\n\t\tcluster->cl_nodes[node->nd_num] = NULL;\n\t\tclear_bit(node->nd_num, cluster->cl_nodes_bitmap);\n\t}\n\twrite_unlock(&cluster->cl_nodes_lock);\n\n\tmlog(ML_CLUSTER, \"o2nm: Unregistered node %s\\n\",\n\t     config_item_name(&node->nd_item));\n\n\tconfig_item_put(item);\n}\n\nstatic struct configfs_group_operations o2nm_node_group_group_ops = {\n\t.make_item\t= o2nm_node_group_make_item,\n\t.drop_item\t= o2nm_node_group_drop_item,\n};\n\nstatic const struct config_item_type o2nm_node_group_type = {\n\t.ct_group_ops\t= &o2nm_node_group_group_ops,\n\t.ct_owner\t= THIS_MODULE,\n};\n\n/* cluster */\n\nstatic void o2nm_cluster_release(struct config_item *item)\n{\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster(item);\n\n\tkfree(cluster);\n}\n\nstatic struct configfs_item_operations o2nm_cluster_item_ops = {\n\t.release\t= o2nm_cluster_release,\n};\n\nstatic const struct config_item_type o2nm_cluster_type = {\n\t.ct_item_ops\t= &o2nm_cluster_item_ops,\n\t.ct_attrs\t= o2nm_cluster_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\n/* cluster set */\n\nstruct o2nm_cluster_group {\n\tstruct configfs_subsystem cs_subsys;\n\t/* some stuff? */\n};\n\n#if 0\nstatic struct o2nm_cluster_group *to_o2nm_cluster_group(struct config_group *group)\n{\n\treturn group ?\n\t\tcontainer_of(to_configfs_subsystem(group), struct o2nm_cluster_group, cs_subsys)\n\t       : NULL;\n}\n#endif\n\nstatic struct config_group *o2nm_cluster_group_make_group(struct config_group *group,\n\t\t\t\t\t\t\t  const char *name)\n{\n\tstruct o2nm_cluster *cluster = NULL;\n\tstruct o2nm_node_group *ns = NULL;\n\tstruct config_group *o2hb_group = NULL, *ret = NULL;\n\n\t/* this runs under the parent dir's i_mutex; there can be only\n\t * one caller in here at a time */\n\tif (o2nm_single_cluster)\n\t\treturn ERR_PTR(-ENOSPC);\n\n\tcluster = kzalloc(sizeof(struct o2nm_cluster), GFP_KERNEL);\n\tns = kzalloc(sizeof(struct o2nm_node_group), GFP_KERNEL);\n\to2hb_group = o2hb_alloc_hb_set();\n\tif (cluster == NULL || ns == NULL || o2hb_group == NULL)\n\t\tgoto out;\n\n\tconfig_group_init_type_name(&cluster->cl_group, name,\n\t\t\t\t    &o2nm_cluster_type);\n\tconfigfs_add_default_group(&ns->ns_group, &cluster->cl_group);\n\n\tconfig_group_init_type_name(&ns->ns_group, \"node\",\n\t\t\t\t    &o2nm_node_group_type);\n\tconfigfs_add_default_group(o2hb_group, &cluster->cl_group);\n\n\trwlock_init(&cluster->cl_nodes_lock);\n\tcluster->cl_node_ip_tree = RB_ROOT;\n\tcluster->cl_reconnect_delay_ms = O2NET_RECONNECT_DELAY_MS_DEFAULT;\n\tcluster->cl_idle_timeout_ms    = O2NET_IDLE_TIMEOUT_MS_DEFAULT;\n\tcluster->cl_keepalive_delay_ms = O2NET_KEEPALIVE_DELAY_MS_DEFAULT;\n\tcluster->cl_fence_method       = O2NM_FENCE_RESET;\n\n\tret = &cluster->cl_group;\n\to2nm_single_cluster = cluster;\n\nout:\n\tif (ret == NULL) {\n\t\tkfree(cluster);\n\t\tkfree(ns);\n\t\to2hb_free_hb_set(o2hb_group);\n\t\tret = ERR_PTR(-ENOMEM);\n\t}\n\n\treturn ret;\n}\n\nstatic void o2nm_cluster_group_drop_item(struct config_group *group, struct config_item *item)\n{\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster(item);\n\n\tBUG_ON(o2nm_single_cluster != cluster);\n\to2nm_single_cluster = NULL;\n\n\tconfigfs_remove_default_groups(&cluster->cl_group);\n\tconfig_item_put(item);\n}\n\nstatic struct configfs_group_operations o2nm_cluster_group_group_ops = {\n\t.make_group\t= o2nm_cluster_group_make_group,\n\t.drop_item\t= o2nm_cluster_group_drop_item,\n};\n\nstatic const struct config_item_type o2nm_cluster_group_type = {\n\t.ct_group_ops\t= &o2nm_cluster_group_group_ops,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic struct o2nm_cluster_group o2nm_cluster_group = {\n\t.cs_subsys = {\n\t\t.su_group = {\n\t\t\t.cg_item = {\n\t\t\t\t.ci_namebuf = \"cluster\",\n\t\t\t\t.ci_type = &o2nm_cluster_group_type,\n\t\t\t},\n\t\t},\n\t},\n};\n\nint o2nm_depend_item(struct config_item *item)\n{\n\treturn configfs_depend_item(&o2nm_cluster_group.cs_subsys, item);\n}\n\nvoid o2nm_undepend_item(struct config_item *item)\n{\n\tconfigfs_undepend_item(item);\n}\n\nint o2nm_depend_this_node(void)\n{\n\tint ret = 0;\n\tstruct o2nm_node *local_node;\n\n\tlocal_node = o2nm_get_node_by_num(o2nm_this_node());\n\tif (!local_node) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = o2nm_depend_item(&local_node->nd_item);\n\to2nm_node_put(local_node);\n\nout:\n\treturn ret;\n}\n\nvoid o2nm_undepend_this_node(void)\n{\n\tstruct o2nm_node *local_node;\n\n\tlocal_node = o2nm_get_node_by_num(o2nm_this_node());\n\tBUG_ON(!local_node);\n\n\to2nm_undepend_item(&local_node->nd_item);\n\to2nm_node_put(local_node);\n}\n\n\nstatic void __exit exit_o2nm(void)\n{\n\t/* XXX sync with hb callbacks and shut down hb? */\n\to2net_unregister_hb_callbacks();\n\tconfigfs_unregister_subsystem(&o2nm_cluster_group.cs_subsys);\n\to2cb_sys_shutdown();\n\n\to2net_exit();\n\to2hb_exit();\n}\n\nstatic int __init init_o2nm(void)\n{\n\tint ret = -1;\n\n\tret = o2hb_init();\n\tif (ret)\n\t\tgoto out;\n\n\tret = o2net_init();\n\tif (ret)\n\t\tgoto out_o2hb;\n\n\tret = o2net_register_hb_callbacks();\n\tif (ret)\n\t\tgoto out_o2net;\n\n\tconfig_group_init(&o2nm_cluster_group.cs_subsys.su_group);\n\tmutex_init(&o2nm_cluster_group.cs_subsys.su_mutex);\n\tret = configfs_register_subsystem(&o2nm_cluster_group.cs_subsys);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"nodemanager: Registration returned %d\\n\", ret);\n\t\tgoto out_callbacks;\n\t}\n\n\tret = o2cb_sys_init();\n\tif (!ret)\n\t\tgoto out;\n\n\tconfigfs_unregister_subsystem(&o2nm_cluster_group.cs_subsys);\nout_callbacks:\n\to2net_unregister_hb_callbacks();\nout_o2net:\n\to2net_exit();\nout_o2hb:\n\to2hb_exit();\nout:\n\treturn ret;\n}\n\nMODULE_AUTHOR(\"Oracle\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"OCFS2 cluster management\");\n\nmodule_init(init_o2nm)\nmodule_exit(exit_o2nm)\n"], "fixing_code": ["/* -*- mode: c; c-basic-offset: 8; -*-\n * vim: noexpandtab sw=8 ts=8 sts=0:\n *\n * Copyright (C) 2004, 2005 Oracle.  All rights reserved.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public\n * License along with this program; if not, write to the\n * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 021110-1307, USA.\n */\n\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/configfs.h>\n\n#include \"tcp.h\"\n#include \"nodemanager.h\"\n#include \"heartbeat.h\"\n#include \"masklog.h\"\n#include \"sys.h\"\n\n/* for now we operate under the assertion that there can be only one\n * cluster active at a time.  Changing this will require trickling\n * cluster references throughout where nodes are looked up */\nstruct o2nm_cluster *o2nm_single_cluster = NULL;\n\nchar *o2nm_fence_method_desc[O2NM_FENCE_METHODS] = {\n\t\t\"reset\",\t/* O2NM_FENCE_RESET */\n\t\t\"panic\",\t/* O2NM_FENCE_PANIC */\n};\n\nstatic inline void o2nm_lock_subsystem(void);\nstatic inline void o2nm_unlock_subsystem(void);\n\nstruct o2nm_node *o2nm_get_node_by_num(u8 node_num)\n{\n\tstruct o2nm_node *node = NULL;\n\n\tif (node_num >= O2NM_MAX_NODES || o2nm_single_cluster == NULL)\n\t\tgoto out;\n\n\tread_lock(&o2nm_single_cluster->cl_nodes_lock);\n\tnode = o2nm_single_cluster->cl_nodes[node_num];\n\tif (node)\n\t\tconfig_item_get(&node->nd_item);\n\tread_unlock(&o2nm_single_cluster->cl_nodes_lock);\nout:\n\treturn node;\n}\nEXPORT_SYMBOL_GPL(o2nm_get_node_by_num);\n\nint o2nm_configured_node_map(unsigned long *map, unsigned bytes)\n{\n\tstruct o2nm_cluster *cluster = o2nm_single_cluster;\n\n\tBUG_ON(bytes < (sizeof(cluster->cl_nodes_bitmap)));\n\n\tif (cluster == NULL)\n\t\treturn -EINVAL;\n\n\tread_lock(&cluster->cl_nodes_lock);\n\tmemcpy(map, cluster->cl_nodes_bitmap, sizeof(cluster->cl_nodes_bitmap));\n\tread_unlock(&cluster->cl_nodes_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(o2nm_configured_node_map);\n\nstatic struct o2nm_node *o2nm_node_ip_tree_lookup(struct o2nm_cluster *cluster,\n\t\t\t\t\t\t  __be32 ip_needle,\n\t\t\t\t\t\t  struct rb_node ***ret_p,\n\t\t\t\t\t\t  struct rb_node **ret_parent)\n{\n\tstruct rb_node **p = &cluster->cl_node_ip_tree.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct o2nm_node *node, *ret = NULL;\n\n\twhile (*p) {\n\t\tint cmp;\n\n\t\tparent = *p;\n\t\tnode = rb_entry(parent, struct o2nm_node, nd_ip_node);\n\n\t\tcmp = memcmp(&ip_needle, &node->nd_ipv4_address,\n\t\t\t\tsizeof(ip_needle));\n\t\tif (cmp < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (cmp > 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\tret = node;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret_p != NULL)\n\t\t*ret_p = p;\n\tif (ret_parent != NULL)\n\t\t*ret_parent = parent;\n\n\treturn ret;\n}\n\nstruct o2nm_node *o2nm_get_node_by_ip(__be32 addr)\n{\n\tstruct o2nm_node *node = NULL;\n\tstruct o2nm_cluster *cluster = o2nm_single_cluster;\n\n\tif (cluster == NULL)\n\t\tgoto out;\n\n\tread_lock(&cluster->cl_nodes_lock);\n\tnode = o2nm_node_ip_tree_lookup(cluster, addr, NULL, NULL);\n\tif (node)\n\t\tconfig_item_get(&node->nd_item);\n\tread_unlock(&cluster->cl_nodes_lock);\n\nout:\n\treturn node;\n}\nEXPORT_SYMBOL_GPL(o2nm_get_node_by_ip);\n\nvoid o2nm_node_put(struct o2nm_node *node)\n{\n\tconfig_item_put(&node->nd_item);\n}\nEXPORT_SYMBOL_GPL(o2nm_node_put);\n\nvoid o2nm_node_get(struct o2nm_node *node)\n{\n\tconfig_item_get(&node->nd_item);\n}\nEXPORT_SYMBOL_GPL(o2nm_node_get);\n\nu8 o2nm_this_node(void)\n{\n\tu8 node_num = O2NM_MAX_NODES;\n\n\tif (o2nm_single_cluster && o2nm_single_cluster->cl_has_local)\n\t\tnode_num = o2nm_single_cluster->cl_local_node;\n\n\treturn node_num;\n}\nEXPORT_SYMBOL_GPL(o2nm_this_node);\n\n/* node configfs bits */\n\nstatic struct o2nm_cluster *to_o2nm_cluster(struct config_item *item)\n{\n\treturn item ?\n\t\tcontainer_of(to_config_group(item), struct o2nm_cluster,\n\t\t\t     cl_group)\n\t\t: NULL;\n}\n\nstatic struct o2nm_node *to_o2nm_node(struct config_item *item)\n{\n\treturn item ? container_of(item, struct o2nm_node, nd_item) : NULL;\n}\n\nstatic void o2nm_node_release(struct config_item *item)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tkfree(node);\n}\n\nstatic ssize_t o2nm_node_num_show(struct config_item *item, char *page)\n{\n\treturn sprintf(page, \"%d\\n\", to_o2nm_node(item)->nd_num);\n}\n\nstatic struct o2nm_cluster *to_o2nm_cluster_from_node(struct o2nm_node *node)\n{\n\t/* through the first node_set .parent\n\t * mycluster/nodes/mynode == o2nm_cluster->o2nm_node_group->o2nm_node */\n\tif (node->nd_item.ci_parent)\n\t\treturn to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);\n\telse\n\t\treturn NULL;\n}\n\nenum {\n\tO2NM_NODE_ATTR_NUM = 0,\n\tO2NM_NODE_ATTR_PORT,\n\tO2NM_NODE_ATTR_ADDRESS,\n};\n\nstatic ssize_t o2nm_node_num_store(struct config_item *item, const char *page,\n\t\t\t\t   size_t count)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tstruct o2nm_cluster *cluster;\n\tunsigned long tmp;\n\tchar *p = (char *)page;\n\tint ret = 0;\n\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\n\tif (tmp >= O2NM_MAX_NODES)\n\t\treturn -ERANGE;\n\n\t/* once we're in the cl_nodes tree networking can look us up by\n\t * node number and try to use our address and port attributes\n\t * to connect to this node.. make sure that they've been set\n\t * before writing the node attribute? */\n\tif (!test_bit(O2NM_NODE_ATTR_ADDRESS, &node->nd_set_attributes) ||\n\t    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))\n\t\treturn -EINVAL; /* XXX */\n\n\to2nm_lock_subsystem();\n\tcluster = to_o2nm_cluster_from_node(node);\n\tif (!cluster) {\n\t\to2nm_unlock_subsystem();\n\t\treturn -EINVAL;\n\t}\n\n\twrite_lock(&cluster->cl_nodes_lock);\n\tif (cluster->cl_nodes[tmp])\n\t\tret = -EEXIST;\n\telse if (test_and_set_bit(O2NM_NODE_ATTR_NUM,\n\t\t\t&node->nd_set_attributes))\n\t\tret = -EBUSY;\n\telse  {\n\t\tcluster->cl_nodes[tmp] = node;\n\t\tnode->nd_num = tmp;\n\t\tset_bit(tmp, cluster->cl_nodes_bitmap);\n\t}\n\twrite_unlock(&cluster->cl_nodes_lock);\n\to2nm_unlock_subsystem();\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\nstatic ssize_t o2nm_node_ipv4_port_show(struct config_item *item, char *page)\n{\n\treturn sprintf(page, \"%u\\n\", ntohs(to_o2nm_node(item)->nd_ipv4_port));\n}\n\nstatic ssize_t o2nm_node_ipv4_port_store(struct config_item *item,\n\t\t\t\t\t const char *page, size_t count)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tunsigned long tmp;\n\tchar *p = (char *)page;\n\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\n\tif (tmp == 0)\n\t\treturn -EINVAL;\n\tif (tmp >= (u16)-1)\n\t\treturn -ERANGE;\n\n\tif (test_and_set_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))\n\t\treturn -EBUSY;\n\tnode->nd_ipv4_port = htons(tmp);\n\n\treturn count;\n}\n\nstatic ssize_t o2nm_node_ipv4_address_show(struct config_item *item, char *page)\n{\n\treturn sprintf(page, \"%pI4\\n\", &to_o2nm_node(item)->nd_ipv4_address);\n}\n\nstatic ssize_t o2nm_node_ipv4_address_store(struct config_item *item,\n\t\t\t\t\t    const char *page,\n\t\t\t\t\t    size_t count)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tstruct o2nm_cluster *cluster;\n\tint ret, i;\n\tstruct rb_node **p, *parent;\n\tunsigned int octets[4];\n\t__be32 ipv4_addr = 0;\n\n\tret = sscanf(page, \"%3u.%3u.%3u.%3u\", &octets[3], &octets[2],\n\t\t     &octets[1], &octets[0]);\n\tif (ret != 4)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(octets); i++) {\n\t\tif (octets[i] > 255)\n\t\t\treturn -ERANGE;\n\t\tbe32_add_cpu(&ipv4_addr, octets[i] << (i * 8));\n\t}\n\n\to2nm_lock_subsystem();\n\tcluster = to_o2nm_cluster_from_node(node);\n\tif (!cluster) {\n\t\to2nm_unlock_subsystem();\n\t\treturn -EINVAL;\n\t}\n\n\tret = 0;\n\twrite_lock(&cluster->cl_nodes_lock);\n\tif (o2nm_node_ip_tree_lookup(cluster, ipv4_addr, &p, &parent))\n\t\tret = -EEXIST;\n\telse if (test_and_set_bit(O2NM_NODE_ATTR_ADDRESS,\n\t\t\t&node->nd_set_attributes))\n\t\tret = -EBUSY;\n\telse {\n\t\trb_link_node(&node->nd_ip_node, parent, p);\n\t\trb_insert_color(&node->nd_ip_node, &cluster->cl_node_ip_tree);\n\t}\n\twrite_unlock(&cluster->cl_nodes_lock);\n\to2nm_unlock_subsystem();\n\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(&node->nd_ipv4_address, &ipv4_addr, sizeof(ipv4_addr));\n\n\treturn count;\n}\n\nstatic ssize_t o2nm_node_local_show(struct config_item *item, char *page)\n{\n\treturn sprintf(page, \"%d\\n\", to_o2nm_node(item)->nd_local);\n}\n\nstatic ssize_t o2nm_node_local_store(struct config_item *item, const char *page,\n\t\t\t\t     size_t count)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tstruct o2nm_cluster *cluster;\n\tunsigned long tmp;\n\tchar *p = (char *)page;\n\tssize_t ret;\n\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\n\ttmp = !!tmp; /* boolean of whether this node wants to be local */\n\n\t/* setting local turns on networking rx for now so we require having\n\t * set everything else first */\n\tif (!test_bit(O2NM_NODE_ATTR_ADDRESS, &node->nd_set_attributes) ||\n\t    !test_bit(O2NM_NODE_ATTR_NUM, &node->nd_set_attributes) ||\n\t    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))\n\t\treturn -EINVAL; /* XXX */\n\n\to2nm_lock_subsystem();\n\tcluster = to_o2nm_cluster_from_node(node);\n\tif (!cluster) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* the only failure case is trying to set a new local node\n\t * when a different one is already set */\n\tif (tmp && tmp == cluster->cl_has_local &&\n\t    cluster->cl_local_node != node->nd_num) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t/* bring up the rx thread if we're setting the new local node. */\n\tif (tmp && !cluster->cl_has_local) {\n\t\tret = o2net_start_listening(node);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (!tmp && cluster->cl_has_local &&\n\t    cluster->cl_local_node == node->nd_num) {\n\t\to2net_stop_listening(node);\n\t\tcluster->cl_local_node = O2NM_INVALID_NODE_NUM;\n\t}\n\n\tnode->nd_local = tmp;\n\tif (node->nd_local) {\n\t\tcluster->cl_has_local = tmp;\n\t\tcluster->cl_local_node = node->nd_num;\n\t}\n\n\tret = count;\n\nout:\n\to2nm_unlock_subsystem();\n\treturn ret;\n}\n\nCONFIGFS_ATTR(o2nm_node_, num);\nCONFIGFS_ATTR(o2nm_node_, ipv4_port);\nCONFIGFS_ATTR(o2nm_node_, ipv4_address);\nCONFIGFS_ATTR(o2nm_node_, local);\n\nstatic struct configfs_attribute *o2nm_node_attrs[] = {\n\t&o2nm_node_attr_num,\n\t&o2nm_node_attr_ipv4_port,\n\t&o2nm_node_attr_ipv4_address,\n\t&o2nm_node_attr_local,\n\tNULL,\n};\n\nstatic struct configfs_item_operations o2nm_node_item_ops = {\n\t.release\t\t= o2nm_node_release,\n};\n\nstatic const struct config_item_type o2nm_node_type = {\n\t.ct_item_ops\t= &o2nm_node_item_ops,\n\t.ct_attrs\t= o2nm_node_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\n/* node set */\n\nstruct o2nm_node_group {\n\tstruct config_group ns_group;\n\t/* some stuff? */\n};\n\n#if 0\nstatic struct o2nm_node_group *to_o2nm_node_group(struct config_group *group)\n{\n\treturn group ?\n\t\tcontainer_of(group, struct o2nm_node_group, ns_group)\n\t\t: NULL;\n}\n#endif\n\nstatic ssize_t o2nm_cluster_attr_write(const char *page, ssize_t count,\n                                       unsigned int *val)\n{\n\tunsigned long tmp;\n\tchar *p = (char *)page;\n\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\n\tif (tmp == 0)\n\t\treturn -EINVAL;\n\tif (tmp >= (u32)-1)\n\t\treturn -ERANGE;\n\n\t*val = tmp;\n\n\treturn count;\n}\n\nstatic ssize_t o2nm_cluster_idle_timeout_ms_show(struct config_item *item,\n\tchar *page)\n{\n\treturn sprintf(page, \"%u\\n\", to_o2nm_cluster(item)->cl_idle_timeout_ms);\n}\n\nstatic ssize_t o2nm_cluster_idle_timeout_ms_store(struct config_item *item,\n\tconst char *page, size_t count)\n{\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster(item);\n\tssize_t ret;\n\tunsigned int val;\n\n\tret =  o2nm_cluster_attr_write(page, count, &val);\n\n\tif (ret > 0) {\n\t\tif (cluster->cl_idle_timeout_ms != val\n\t\t\t&& o2net_num_connected_peers()) {\n\t\t\tmlog(ML_NOTICE,\n\t\t\t     \"o2net: cannot change idle timeout after \"\n\t\t\t     \"the first peer has agreed to it.\"\n\t\t\t     \"  %d connected peers\\n\",\n\t\t\t     o2net_num_connected_peers());\n\t\t\tret = -EINVAL;\n\t\t} else if (val <= cluster->cl_keepalive_delay_ms) {\n\t\t\tmlog(ML_NOTICE, \"o2net: idle timeout must be larger \"\n\t\t\t     \"than keepalive delay\\n\");\n\t\t\tret = -EINVAL;\n\t\t} else {\n\t\t\tcluster->cl_idle_timeout_ms = val;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic ssize_t o2nm_cluster_keepalive_delay_ms_show(\n\tstruct config_item *item, char *page)\n{\n\treturn sprintf(page, \"%u\\n\",\n\t\t\tto_o2nm_cluster(item)->cl_keepalive_delay_ms);\n}\n\nstatic ssize_t o2nm_cluster_keepalive_delay_ms_store(\n\tstruct config_item *item, const char *page, size_t count)\n{\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster(item);\n\tssize_t ret;\n\tunsigned int val;\n\n\tret =  o2nm_cluster_attr_write(page, count, &val);\n\n\tif (ret > 0) {\n\t\tif (cluster->cl_keepalive_delay_ms != val\n\t\t    && o2net_num_connected_peers()) {\n\t\t\tmlog(ML_NOTICE,\n\t\t\t     \"o2net: cannot change keepalive delay after\"\n\t\t\t     \" the first peer has agreed to it.\"\n\t\t\t     \"  %d connected peers\\n\",\n\t\t\t     o2net_num_connected_peers());\n\t\t\tret = -EINVAL;\n\t\t} else if (val >= cluster->cl_idle_timeout_ms) {\n\t\t\tmlog(ML_NOTICE, \"o2net: keepalive delay must be \"\n\t\t\t     \"smaller than idle timeout\\n\");\n\t\t\tret = -EINVAL;\n\t\t} else {\n\t\t\tcluster->cl_keepalive_delay_ms = val;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic ssize_t o2nm_cluster_reconnect_delay_ms_show(\n\tstruct config_item *item, char *page)\n{\n\treturn sprintf(page, \"%u\\n\",\n\t\t\tto_o2nm_cluster(item)->cl_reconnect_delay_ms);\n}\n\nstatic ssize_t o2nm_cluster_reconnect_delay_ms_store(\n\tstruct config_item *item, const char *page, size_t count)\n{\n\treturn o2nm_cluster_attr_write(page, count,\n                               &to_o2nm_cluster(item)->cl_reconnect_delay_ms);\n}\n\nstatic ssize_t o2nm_cluster_fence_method_show(\n\tstruct config_item *item, char *page)\n{\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster(item);\n\tssize_t ret = 0;\n\n\tif (cluster)\n\t\tret = sprintf(page, \"%s\\n\",\n\t\t\t      o2nm_fence_method_desc[cluster->cl_fence_method]);\n\treturn ret;\n}\n\nstatic ssize_t o2nm_cluster_fence_method_store(\n\tstruct config_item *item, const char *page, size_t count)\n{\n\tunsigned int i;\n\n\tif (page[count - 1] != '\\n')\n\t\tgoto bail;\n\n\tfor (i = 0; i < O2NM_FENCE_METHODS; ++i) {\n\t\tif (count != strlen(o2nm_fence_method_desc[i]) + 1)\n\t\t\tcontinue;\n\t\tif (strncasecmp(page, o2nm_fence_method_desc[i], count - 1))\n\t\t\tcontinue;\n\t\tif (to_o2nm_cluster(item)->cl_fence_method != i) {\n\t\t\tprintk(KERN_INFO \"ocfs2: Changing fence method to %s\\n\",\n\t\t\t       o2nm_fence_method_desc[i]);\n\t\t\tto_o2nm_cluster(item)->cl_fence_method = i;\n\t\t}\n\t\treturn count;\n\t}\n\nbail:\n\treturn -EINVAL;\n}\n\nCONFIGFS_ATTR(o2nm_cluster_, idle_timeout_ms);\nCONFIGFS_ATTR(o2nm_cluster_, keepalive_delay_ms);\nCONFIGFS_ATTR(o2nm_cluster_, reconnect_delay_ms);\nCONFIGFS_ATTR(o2nm_cluster_, fence_method);\n\nstatic struct configfs_attribute *o2nm_cluster_attrs[] = {\n\t&o2nm_cluster_attr_idle_timeout_ms,\n\t&o2nm_cluster_attr_keepalive_delay_ms,\n\t&o2nm_cluster_attr_reconnect_delay_ms,\n\t&o2nm_cluster_attr_fence_method,\n\tNULL,\n};\n\nstatic struct config_item *o2nm_node_group_make_item(struct config_group *group,\n\t\t\t\t\t\t     const char *name)\n{\n\tstruct o2nm_node *node = NULL;\n\n\tif (strlen(name) > O2NM_MAX_NAME_LEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tnode = kzalloc(sizeof(struct o2nm_node), GFP_KERNEL);\n\tif (node == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstrcpy(node->nd_name, name); /* use item.ci_namebuf instead? */\n\tconfig_item_init_type_name(&node->nd_item, name, &o2nm_node_type);\n\tspin_lock_init(&node->nd_lock);\n\n\tmlog(ML_CLUSTER, \"o2nm: Registering node %s\\n\", name);\n\n\treturn &node->nd_item;\n}\n\nstatic void o2nm_node_group_drop_item(struct config_group *group,\n\t\t\t\t      struct config_item *item)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster(group->cg_item.ci_parent);\n\n\to2net_disconnect_node(node);\n\n\tif (cluster->cl_has_local &&\n\t    (cluster->cl_local_node == node->nd_num)) {\n\t\tcluster->cl_has_local = 0;\n\t\tcluster->cl_local_node = O2NM_INVALID_NODE_NUM;\n\t\to2net_stop_listening(node);\n\t}\n\n\t/* XXX call into net to stop this node from trading messages */\n\n\twrite_lock(&cluster->cl_nodes_lock);\n\n\t/* XXX sloppy */\n\tif (node->nd_ipv4_address)\n\t\trb_erase(&node->nd_ip_node, &cluster->cl_node_ip_tree);\n\n\t/* nd_num might be 0 if the node number hasn't been set.. */\n\tif (cluster->cl_nodes[node->nd_num] == node) {\n\t\tcluster->cl_nodes[node->nd_num] = NULL;\n\t\tclear_bit(node->nd_num, cluster->cl_nodes_bitmap);\n\t}\n\twrite_unlock(&cluster->cl_nodes_lock);\n\n\tmlog(ML_CLUSTER, \"o2nm: Unregistered node %s\\n\",\n\t     config_item_name(&node->nd_item));\n\n\tconfig_item_put(item);\n}\n\nstatic struct configfs_group_operations o2nm_node_group_group_ops = {\n\t.make_item\t= o2nm_node_group_make_item,\n\t.drop_item\t= o2nm_node_group_drop_item,\n};\n\nstatic const struct config_item_type o2nm_node_group_type = {\n\t.ct_group_ops\t= &o2nm_node_group_group_ops,\n\t.ct_owner\t= THIS_MODULE,\n};\n\n/* cluster */\n\nstatic void o2nm_cluster_release(struct config_item *item)\n{\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster(item);\n\n\tkfree(cluster);\n}\n\nstatic struct configfs_item_operations o2nm_cluster_item_ops = {\n\t.release\t= o2nm_cluster_release,\n};\n\nstatic const struct config_item_type o2nm_cluster_type = {\n\t.ct_item_ops\t= &o2nm_cluster_item_ops,\n\t.ct_attrs\t= o2nm_cluster_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\n/* cluster set */\n\nstruct o2nm_cluster_group {\n\tstruct configfs_subsystem cs_subsys;\n\t/* some stuff? */\n};\n\n#if 0\nstatic struct o2nm_cluster_group *to_o2nm_cluster_group(struct config_group *group)\n{\n\treturn group ?\n\t\tcontainer_of(to_configfs_subsystem(group), struct o2nm_cluster_group, cs_subsys)\n\t       : NULL;\n}\n#endif\n\nstatic struct config_group *o2nm_cluster_group_make_group(struct config_group *group,\n\t\t\t\t\t\t\t  const char *name)\n{\n\tstruct o2nm_cluster *cluster = NULL;\n\tstruct o2nm_node_group *ns = NULL;\n\tstruct config_group *o2hb_group = NULL, *ret = NULL;\n\n\t/* this runs under the parent dir's i_mutex; there can be only\n\t * one caller in here at a time */\n\tif (o2nm_single_cluster)\n\t\treturn ERR_PTR(-ENOSPC);\n\n\tcluster = kzalloc(sizeof(struct o2nm_cluster), GFP_KERNEL);\n\tns = kzalloc(sizeof(struct o2nm_node_group), GFP_KERNEL);\n\to2hb_group = o2hb_alloc_hb_set();\n\tif (cluster == NULL || ns == NULL || o2hb_group == NULL)\n\t\tgoto out;\n\n\tconfig_group_init_type_name(&cluster->cl_group, name,\n\t\t\t\t    &o2nm_cluster_type);\n\tconfigfs_add_default_group(&ns->ns_group, &cluster->cl_group);\n\n\tconfig_group_init_type_name(&ns->ns_group, \"node\",\n\t\t\t\t    &o2nm_node_group_type);\n\tconfigfs_add_default_group(o2hb_group, &cluster->cl_group);\n\n\trwlock_init(&cluster->cl_nodes_lock);\n\tcluster->cl_node_ip_tree = RB_ROOT;\n\tcluster->cl_reconnect_delay_ms = O2NET_RECONNECT_DELAY_MS_DEFAULT;\n\tcluster->cl_idle_timeout_ms    = O2NET_IDLE_TIMEOUT_MS_DEFAULT;\n\tcluster->cl_keepalive_delay_ms = O2NET_KEEPALIVE_DELAY_MS_DEFAULT;\n\tcluster->cl_fence_method       = O2NM_FENCE_RESET;\n\n\tret = &cluster->cl_group;\n\to2nm_single_cluster = cluster;\n\nout:\n\tif (ret == NULL) {\n\t\tkfree(cluster);\n\t\tkfree(ns);\n\t\to2hb_free_hb_set(o2hb_group);\n\t\tret = ERR_PTR(-ENOMEM);\n\t}\n\n\treturn ret;\n}\n\nstatic void o2nm_cluster_group_drop_item(struct config_group *group, struct config_item *item)\n{\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster(item);\n\n\tBUG_ON(o2nm_single_cluster != cluster);\n\to2nm_single_cluster = NULL;\n\n\tconfigfs_remove_default_groups(&cluster->cl_group);\n\tconfig_item_put(item);\n}\n\nstatic struct configfs_group_operations o2nm_cluster_group_group_ops = {\n\t.make_group\t= o2nm_cluster_group_make_group,\n\t.drop_item\t= o2nm_cluster_group_drop_item,\n};\n\nstatic const struct config_item_type o2nm_cluster_group_type = {\n\t.ct_group_ops\t= &o2nm_cluster_group_group_ops,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic struct o2nm_cluster_group o2nm_cluster_group = {\n\t.cs_subsys = {\n\t\t.su_group = {\n\t\t\t.cg_item = {\n\t\t\t\t.ci_namebuf = \"cluster\",\n\t\t\t\t.ci_type = &o2nm_cluster_group_type,\n\t\t\t},\n\t\t},\n\t},\n};\n\nstatic inline void o2nm_lock_subsystem(void)\n{\n\tmutex_lock(&o2nm_cluster_group.cs_subsys.su_mutex);\n}\n\nstatic inline void o2nm_unlock_subsystem(void)\n{\n\tmutex_unlock(&o2nm_cluster_group.cs_subsys.su_mutex);\n}\n\nint o2nm_depend_item(struct config_item *item)\n{\n\treturn configfs_depend_item(&o2nm_cluster_group.cs_subsys, item);\n}\n\nvoid o2nm_undepend_item(struct config_item *item)\n{\n\tconfigfs_undepend_item(item);\n}\n\nint o2nm_depend_this_node(void)\n{\n\tint ret = 0;\n\tstruct o2nm_node *local_node;\n\n\tlocal_node = o2nm_get_node_by_num(o2nm_this_node());\n\tif (!local_node) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = o2nm_depend_item(&local_node->nd_item);\n\to2nm_node_put(local_node);\n\nout:\n\treturn ret;\n}\n\nvoid o2nm_undepend_this_node(void)\n{\n\tstruct o2nm_node *local_node;\n\n\tlocal_node = o2nm_get_node_by_num(o2nm_this_node());\n\tBUG_ON(!local_node);\n\n\to2nm_undepend_item(&local_node->nd_item);\n\to2nm_node_put(local_node);\n}\n\n\nstatic void __exit exit_o2nm(void)\n{\n\t/* XXX sync with hb callbacks and shut down hb? */\n\to2net_unregister_hb_callbacks();\n\tconfigfs_unregister_subsystem(&o2nm_cluster_group.cs_subsys);\n\to2cb_sys_shutdown();\n\n\to2net_exit();\n\to2hb_exit();\n}\n\nstatic int __init init_o2nm(void)\n{\n\tint ret = -1;\n\n\tret = o2hb_init();\n\tif (ret)\n\t\tgoto out;\n\n\tret = o2net_init();\n\tif (ret)\n\t\tgoto out_o2hb;\n\n\tret = o2net_register_hb_callbacks();\n\tif (ret)\n\t\tgoto out_o2net;\n\n\tconfig_group_init(&o2nm_cluster_group.cs_subsys.su_group);\n\tmutex_init(&o2nm_cluster_group.cs_subsys.su_mutex);\n\tret = configfs_register_subsystem(&o2nm_cluster_group.cs_subsys);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"nodemanager: Registration returned %d\\n\", ret);\n\t\tgoto out_callbacks;\n\t}\n\n\tret = o2cb_sys_init();\n\tif (!ret)\n\t\tgoto out;\n\n\tconfigfs_unregister_subsystem(&o2nm_cluster_group.cs_subsys);\nout_callbacks:\n\to2net_unregister_hb_callbacks();\nout_o2net:\n\to2net_exit();\nout_o2hb:\n\to2hb_exit();\nout:\n\treturn ret;\n}\n\nMODULE_AUTHOR(\"Oracle\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"OCFS2 cluster management\");\n\nmodule_init(init_o2nm)\nmodule_exit(exit_o2nm)\n"], "filenames": ["fs/ocfs2/cluster/nodemanager.c"], "buggy_code_start_loc": [42], "buggy_code_end_loc": [740], "fixing_code_start_loc": [43], "fixing_code_end_loc": [788], "type": "CWE-476", "message": "In fs/ocfs2/cluster/nodemanager.c in the Linux kernel before 4.15, local users can cause a denial of service (NULL pointer dereference and BUG) because a required mutex is not used.", "other": {"cve": {"id": "CVE-2017-18216", "sourceIdentifier": "cve@mitre.org", "published": "2018-03-05T18:29:00.360", "lastModified": "2018-10-30T10:29:06.283", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In fs/ocfs2/cluster/nodemanager.c in the Linux kernel before 4.15, local users can cause a denial of service (NULL pointer dereference and BUG) because a required mutex is not used."}, {"lang": "es", "value": "En fs/ocfs2/cluster/nodemanager.c en el kernel de Linux, en versiones anteriores a la 4.15, los usuarios locales pueden provocar una denegaci\u00f3n de servicio (desreferencia de puntero NULL y error) debido a que no se emplea un mutex requerido."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.15", "matchCriteriaId": "A4344060-7D43-4A74-A2EF-DE9A6F8457A6"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=853bc26a7ea39e354b9f8889ae7ad1492ffa28d2", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/103278", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/torvalds/linux/commit/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/05/msg00000.html", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3776-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3776-2/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3798-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3798-2/", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2018/dsa-4187", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2018/dsa-4188", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2"}}