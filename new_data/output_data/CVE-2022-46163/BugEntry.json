{"buggy_code": ["class ApplicationRecord < ActiveRecord::Base\n  self.abstract_class = true\nend\n", "#\n# Reimbursement for a given request\n#\nclass Reimbursement < ApplicationRecord\n  include HasState\n  include HasComments\n\n  # The associated request\n  belongs_to :request, inverse_of: :reimbursement,\n                       class_name: 'ReimbursableRequest',\n                       foreign_key: 'request_id'\n  # Comments used to discuss decisions (private) or communicate with the requester (public)\n  has_many :comments, as: :machine, dependent: :destroy\n  # The expenses of the associated request, total_amount and authorized_amount\n  # will be updated during reimbursement process\n  has_many :expenses, through: :request, autosave: false\n  # Attachments for providing invoices and reports\n  has_many :attachments, class_name: 'ReimbursementAttachment', inverse_of: :reimbursement, dependent: :destroy\n  # Links pointing to reports (ie., blog posts) regarding the requester\n  # participation in the event\n  has_many :links, class_name: 'ReimbursementLink', inverse_of: :reimbursement, dependent: :destroy\n  # Can have several payments, not related to the number of expenses\n  has_many :payments, inverse_of: :reimbursement, dependent: :restrict_with_exception\n  # Bank information goes to another model\n  has_one :bank_account, inverse_of: :reimbursement, dependent: :destroy, autosave: true\n\n  delegate :event, to: :request, prefix: false\n\n  accepts_nested_attributes_for :request, update_only: true,\n                                          allow_destroy: false, reject_if: :reject_request\n\n  accepts_nested_attributes_for :attachments, allow_destroy: true\n\n  accepts_nested_attributes_for :links, allow_destroy: true\n\n  accepts_nested_attributes_for :bank_account, allow_destroy: false\n\n  validates :request, presence: true\n  validates_associated :expenses, :attachments, :links, :bank_account\n  validates :acceptance_file, presence: true, if: 'acceptance_file_required?'\n  validate :user_profile_is_complete, if: 'complete_profile_required?'\n\n  mount_uploader :acceptance_file, AttachmentUploader\n\n  auditable except: [:acceptance_file]\n\n  # Synchronizes user_id and request_id\n  before_validation :set_user_id\n  before_validation :ensure_bank_account\n\n  # @see HasComments.allow_all_comments_to\n  allow_all_comments_to [:tsp, :assistant]\n  # @see HasComments.allow_public_comments_to\n  allow_public_comments_to [:administrative, :requester]\n\n  #\n  state_machine :state, initial: :incomplete do |_machine|\n    event :submit do\n      transition incomplete: :submitted\n    end\n\n    event :approve do\n      transition submitted: :approved\n    end\n\n    event :process do\n      transition approved: :processed\n    end\n\n    event :confirm do\n      transition processed: :payed\n    end\n\n    event :roll_back do\n      transition submitted: :incomplete\n      transition approved: :incomplete\n    end\n\n    # The empty block for this state is needed to prevent yardoc's error\n    # during automatic documentation generation\n    state :canceled do\n    end\n  end\n\n  # @see HasState.assign_state\n  # @see HasState.notify_state\n  assign_state :incomplete, to: :requester\n  notify_state :incomplete, to: [:requester, :tsp, :assistant],\n                            remind_to: :requester,\n                            remind_after: 5.days\n\n  assign_state :submitted, to: :tsp\n  notify_state :submitted, to: [:requester, :tsp, :assistant],\n                           remind_after: 10.days\n\n  assign_state :approved, to: :administrative\n  notify_state :approved, to: [:administrative, :requester, :tsp, :assistant],\n                          remind_to: :administrative,\n                          remind_after: 10.days\n\n  assign_state :processed\n  notify_state :processed, to: [:administrative, :requester, :tsp, :assistant],\n                           remind_to: :administrative,\n                           remind_after: 20.days\n\n  notify_state :payed, to: [:administrative, :requester, :tsp, :assistant]\n\n  notify_state :canceled, to: [:administrative, :requester, :tsp, :assistant]\n\n  # @see HasState.allow_transition\n  allow_transition :submit, :requester\n  allow_transition :approve, :tsp\n  allow_transition :process, :administrative\n  allow_transition :confirm, :administrative\n  allow_transition :roll_back, [:requester, :administrative, :tsp]\n  allow_transition :cancel, [:requester, :tsp, :supervisor]\n\n  # @see Request#expenses_sum\n  def expenses_sum(*args)\n    request.expenses_sum(*args)\n  end\n\n  # @see Request.expenses_sum\n  def self.expenses_sum(attr = :total, reimbursements)\n    r_ids = if reimbursements.is_a?(ActiveRecord::Relation)\n              reimbursements.reorder('').pluck('reimbursements.request_id')\n            else\n              reimbursements.map(&:request_id)\n            end\n    ReimbursableRequest.expenses_sum(attr, r_ids)\n  end\n\n  # Checks whether can have a transition to 'canceled' state\n  #\n  # Overrides the HasState.can_cancel?, preventing cancelation of reimbursements\n  # that have already been processed\n  # @see HasState.can_cancel?\n  #\n  # return [Boolean] true if #cancel can be called\n  def can_cancel?\n    !canceled? && !processed? && !payed?\n  end\n\n  # Checks whether the acceptance file is required in order to be a valid\n  # reimbursement\n  #\n  # @return [Boolean] true if signed acceptance is required\n  def acceptance_file_required?\n    !(incomplete? || canceled?)\n  end\n\n  # Checks whether a complete user profile (with the required information\n  # filled) is required in order to be a valid reimbursement. A complete profile\n  # is not required if the reimbursement is being rolled back, only\n  # when trying to go further into the workflow.\n  #\n  # @return [Boolean] true if the profile have to be complete\n  def complete_profile_required?\n    (submitted? && state_was == 'incomplete') ||\n      (approved? && state_was == 'submitted')\n  end\n\n  # Label to identify the reimbursement\n  #\n  # Overrides the default method to use the request id instead of the internal\n  # reimbursement id.\n  #\n  # @return [String] label based in the id of the associated request\n  def label\n    \"##{request_id}\"\n  end\n\n  # Full error messages that would be caused by the next state transition\n  #\n  # It returns the empty set if there are more than one possible transition\n  #\n  # @param [Hash] opts Options to filter the message:\n  #     :except [Array<Symbol>] fields for which the errors will be ignored\n  # @return [Array<String>] list of messages\n  def potential_error_full_messages(opts = {})\n    if state_events.size != 1\n      # The next step is not obvious, so we cannot calculate the messages\n      return []\n    end\n\n    except = Array(opts[:except])\n    original_state = state\n    event = state_events.first\n\n    # Aggregate all the messages\n    send(event)\n    error_msgs = errors.messages\n    error_msgs.delete_if { |key, _v| except.include?(key) }\n    full_messages = []\n    error_msgs.each_pair do |attrib, err|\n      err.each { |msg| full_messages << errors.full_message(attrib, msg) }\n    end\n\n    # Reset state and errors\n    self.state = original_state\n    valid?\n\n    full_messages\n  end\n\n  protected\n\n  # Used internally to synchronize request_id and user_id\n  def set_user_id\n    self.user_id = request.user_id\n  end\n\n  def ensure_bank_account\n    build_bank_account if bank_account.nil?\n  end\n\n  # Validates the existance of a complete profile\n  def user_profile_is_complete\n    fields = user.profile.missing_fields\n    unless fields.empty?\n      errors.add(:user, :incomplete, fields: fields.values.to_sentence)\n    end\n  end\n\n  # Used internally by accepts_nested_attributes to ensure that only\n  # total_amount and authorized_amount are accessible through the reimbursement\n  #\n  # _delete keys are also rejected, so expenses cannot either be deleted\n  #\n  # @return [Boolean] true if the request should be rejected\n  def reject_request(attrs)\n    acceptable_request_attrs = %w[id expenses_attributes]\n    acceptable_expenses_attrs = %w[id total_amount authorized_amount]\n    return true unless (attrs.keys - acceptable_request_attrs).empty?\n    if expenses = attrs['expenses_attributes']\n      expenses.values.each do |expense|\n        return true unless (expense.keys - acceptable_expenses_attrs).empty?\n      end\n    end\n    false\n  end\nend\n"], "fixing_code": ["class ApplicationRecord < ActiveRecord::Base\n  self.abstract_class = true\n\n  def self.ransackable_attributes(_)\n    super & %w[end_date start_date name description event_id state]\n  end\n\n  def self.ransackable_associations(_)\n    []\n  end\nend\n", "#\n# Reimbursement for a given request\n#\nclass Reimbursement < ApplicationRecord\n  include HasState\n  include HasComments\n\n  # The associated request\n  belongs_to :request, inverse_of: :reimbursement,\n                       class_name: 'ReimbursableRequest',\n                       foreign_key: 'request_id'\n  # Comments used to discuss decisions (private) or communicate with the requester (public)\n  has_many :comments, as: :machine, dependent: :destroy\n  # The expenses of the associated request, total_amount and authorized_amount\n  # will be updated during reimbursement process\n  has_many :expenses, through: :request, autosave: false\n  # Attachments for providing invoices and reports\n  has_many :attachments, class_name: 'ReimbursementAttachment', inverse_of: :reimbursement, dependent: :destroy\n  # Links pointing to reports (ie., blog posts) regarding the requester\n  # participation in the event\n  has_many :links, class_name: 'ReimbursementLink', inverse_of: :reimbursement, dependent: :destroy\n  # Can have several payments, not related to the number of expenses\n  has_many :payments, inverse_of: :reimbursement, dependent: :restrict_with_exception\n  # Bank information goes to another model\n  has_one :bank_account, inverse_of: :reimbursement, dependent: :destroy, autosave: true\n\n  delegate :event, to: :request, prefix: false\n\n  accepts_nested_attributes_for :request, update_only: true,\n                                          allow_destroy: false, reject_if: :reject_request\n\n  accepts_nested_attributes_for :attachments, allow_destroy: true\n\n  accepts_nested_attributes_for :links, allow_destroy: true\n\n  accepts_nested_attributes_for :bank_account, allow_destroy: false\n\n  validates :request, presence: true\n  validates_associated :expenses, :attachments, :links, :bank_account\n  validates :acceptance_file, presence: true, if: 'acceptance_file_required?'\n  validate :user_profile_is_complete, if: 'complete_profile_required?'\n\n  mount_uploader :acceptance_file, AttachmentUploader\n\n  auditable except: [:acceptance_file]\n\n  # Synchronizes user_id and request_id\n  before_validation :set_user_id\n  before_validation :ensure_bank_account\n\n  # @see HasComments.allow_all_comments_to\n  allow_all_comments_to [:tsp, :assistant]\n  # @see HasComments.allow_public_comments_to\n  allow_public_comments_to [:administrative, :requester]\n\n  #\n  state_machine :state, initial: :incomplete do |_machine|\n    event :submit do\n      transition incomplete: :submitted\n    end\n\n    event :approve do\n      transition submitted: :approved\n    end\n\n    event :process do\n      transition approved: :processed\n    end\n\n    event :confirm do\n      transition processed: :payed\n    end\n\n    event :roll_back do\n      transition submitted: :incomplete\n      transition approved: :incomplete\n    end\n\n    # The empty block for this state is needed to prevent yardoc's error\n    # during automatic documentation generation\n    state :canceled do\n    end\n  end\n\n  # @see HasState.assign_state\n  # @see HasState.notify_state\n  assign_state :incomplete, to: :requester\n  notify_state :incomplete, to: [:requester, :tsp, :assistant],\n                            remind_to: :requester,\n                            remind_after: 5.days\n\n  assign_state :submitted, to: :tsp\n  notify_state :submitted, to: [:requester, :tsp, :assistant],\n                           remind_after: 10.days\n\n  assign_state :approved, to: :administrative\n  notify_state :approved, to: [:administrative, :requester, :tsp, :assistant],\n                          remind_to: :administrative,\n                          remind_after: 10.days\n\n  assign_state :processed\n  notify_state :processed, to: [:administrative, :requester, :tsp, :assistant],\n                           remind_to: :administrative,\n                           remind_after: 20.days\n\n  notify_state :payed, to: [:administrative, :requester, :tsp, :assistant]\n\n  notify_state :canceled, to: [:administrative, :requester, :tsp, :assistant]\n\n  # @see HasState.allow_transition\n  allow_transition :submit, :requester\n  allow_transition :approve, :tsp\n  allow_transition :process, :administrative\n  allow_transition :confirm, :administrative\n  allow_transition :roll_back, [:requester, :administrative, :tsp]\n  allow_transition :cancel, [:requester, :tsp, :supervisor]\n\n  # @see Request#expenses_sum\n  def expenses_sum(*args)\n    request.expenses_sum(*args)\n  end\n\n  # @see Request.expenses_sum\n  def self.expenses_sum(attr = :total, reimbursements)\n    r_ids = if reimbursements.is_a?(ActiveRecord::Relation)\n              reimbursements.reorder('').pluck('reimbursements.request_id')\n            else\n              reimbursements.map(&:request_id)\n            end\n    ReimbursableRequest.expenses_sum(attr, r_ids)\n  end\n\n  # Checks whether can have a transition to 'canceled' state\n  #\n  # Overrides the HasState.can_cancel?, preventing cancelation of reimbursements\n  # that have already been processed\n  # @see HasState.can_cancel?\n  #\n  # return [Boolean] true if #cancel can be called\n  def can_cancel?\n    !canceled? && !processed? && !payed?\n  end\n\n  # Checks whether the acceptance file is required in order to be a valid\n  # reimbursement\n  #\n  # @return [Boolean] true if signed acceptance is required\n  def acceptance_file_required?\n    !(incomplete? || canceled?)\n  end\n\n  # Checks whether a complete user profile (with the required information\n  # filled) is required in order to be a valid reimbursement. A complete profile\n  # is not required if the reimbursement is being rolled back, only\n  # when trying to go further into the workflow.\n  #\n  # @return [Boolean] true if the profile have to be complete\n  def complete_profile_required?\n    (submitted? && state_was == 'incomplete') ||\n      (approved? && state_was == 'submitted')\n  end\n\n  # Label to identify the reimbursement\n  #\n  # Overrides the default method to use the request id instead of the internal\n  # reimbursement id.\n  #\n  # @return [String] label based in the id of the associated request\n  def label\n    \"##{request_id}\"\n  end\n\n  # Full error messages that would be caused by the next state transition\n  #\n  # It returns the empty set if there are more than one possible transition\n  #\n  # @param [Hash] opts Options to filter the message:\n  #     :except [Array<Symbol>] fields for which the errors will be ignored\n  # @return [Array<String>] list of messages\n  def potential_error_full_messages(opts = {})\n    if state_events.size != 1\n      # The next step is not obvious, so we cannot calculate the messages\n      return []\n    end\n\n    except = Array(opts[:except])\n    original_state = state\n    event = state_events.first\n\n    # Aggregate all the messages\n    send(event)\n    error_msgs = errors.messages\n    error_msgs.delete_if { |key, _v| except.include?(key) }\n    full_messages = []\n    error_msgs.each_pair do |attrib, err|\n      err.each { |msg| full_messages << errors.full_message(attrib, msg) }\n    end\n\n    # Reset state and errors\n    self.state = original_state\n    valid?\n\n    full_messages\n  end\n\n  protected\n\n  # Used internally to synchronize request_id and user_id\n  def set_user_id\n    self.user_id = request.user_id\n  end\n\n  def ensure_bank_account\n    build_bank_account if bank_account.nil?\n  end\n\n  # Validates the existance of a complete profile\n  def user_profile_is_complete\n    fields = user.profile.missing_fields\n    unless fields.empty?\n      errors.add(:user, :incomplete, fields: fields.values.to_sentence)\n    end\n  end\n\n  # Used internally by accepts_nested_attributes to ensure that only\n  # total_amount and authorized_amount are accessible through the reimbursement\n  #\n  # _delete keys are also rejected, so expenses cannot either be deleted\n  #\n  # @return [Boolean] true if the request should be rejected\n  def reject_request(attrs)\n    acceptable_request_attrs = %w[id expenses_attributes]\n    acceptable_expenses_attrs = %w[id total_amount authorized_amount]\n    return true unless (attrs.keys - acceptable_request_attrs).empty?\n    if expenses = attrs['expenses_attributes']\n      expenses.values.each do |expense|\n        return true unless (expense.keys - acceptable_expenses_attrs).empty?\n      end\n    end\n    false\n  end\n\n  def self.ransackable_associations(_)\n    %w[request]\n  end\nend\n"], "filenames": ["app/models/application_record.rb", "app/models/reimbursement.rb"], "buggy_code_start_loc": [2, 241], "buggy_code_end_loc": [2, 241], "fixing_code_start_loc": [3, 242], "fixing_code_end_loc": [11, 246], "type": "CWE-74", "message": "Travel support program is a rails app to support the travel support program of openSUSE (TSP). Sensitive user data (bank account details, password Hash) can be extracted via Ransack query injection. Every deployment of travel-support-program below the patched version is affected. The travel-support-program uses the Ransack library to implement search functionality. In its default configuration, Ransack will allow for query conditions based on properties of associated database objects [1]. The `*_start`, `*_end` or `*_cont` search matchers [2] can then be abused to exfiltrate sensitive string values of associated database objects via character-by-character brute-force (A match is indicated by the returned JSON not being empty). A single bank account number can be extracted with <200 requests, a password hash can be extracted with ~1200 requests, all within a few minutes. The problem has been patched in commit d22916275c51500b4004933ff1b0a69bc807b2b7. In order to work around this issue, you can also cherry pick that patch, however it will not work without the Rails 5.0 migration that was done in #150, which in turn had quite a few pull requests it depended on.", "other": {"cve": {"id": "CVE-2022-46163", "sourceIdentifier": "security-advisories@github.com", "published": "2023-01-10T21:15:12.740", "lastModified": "2023-01-20T17:55:36.943", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Travel support program is a rails app to support the travel support program of openSUSE (TSP). Sensitive user data (bank account details, password Hash) can be extracted via Ransack query injection. Every deployment of travel-support-program below the patched version is affected. The travel-support-program uses the Ransack library to implement search functionality. In its default configuration, Ransack will allow for query conditions based on properties of associated database objects [1]. The `*_start`, `*_end` or `*_cont` search matchers [2] can then be abused to exfiltrate sensitive string values of associated database objects via character-by-character brute-force (A match is indicated by the returned JSON not being empty). A single bank account number can be extracted with <200 requests, a password hash can be extracted with ~1200 requests, all within a few minutes. The problem has been patched in commit d22916275c51500b4004933ff1b0a69bc807b2b7. In order to work around this issue, you can also cherry pick that patch, however it will not work without the Rails 5.0 migration that was done in #150, which in turn had quite a few pull requests it depended on."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-74"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:opensuse:travel_support_program:*:*:*:*:*:*:*:*", "versionEndExcluding": "2022-11-29", "matchCriteriaId": "69AF7833-9415-4F9C-906C-C944FAA50EE7"}]}]}], "references": [{"url": "https://github.com/openSUSE/travel-support-program/commit/d22916275c51500b4004933ff1b0a69bc807b2b7", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/openSUSE/travel-support-program/pull/158", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/openSUSE/travel-support-program/security/advisories/GHSA-2wwv-c6xh-cf68", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/openSUSE/travel-support-program/commit/d22916275c51500b4004933ff1b0a69bc807b2b7"}}