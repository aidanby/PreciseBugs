{"buggy_code": ["/*\n** $Id: lparser.c $\n** Lua Parser\n** See Copyright Notice in lua.h\n*/\n\n#define lparser_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n#include <limits.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"lcode.h\"\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"llex.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lopcodes.h\"\n#include \"lparser.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n\n\n\n/* maximum number of local variables per function (must be smaller\n   than 250, due to the bytecode format) */\n#define MAXVARS\t\t200\n\n\n#define hasmultret(k)\t\t((k) == VCALL || (k) == VVARARG)\n\n\n/* because all strings are unified by the scanner, the parser\n   can use pointer equality for string equality */\n#define eqstr(a,b)\t((a) == (b))\n\n\n/*\n** nodes for block list (list of active blocks)\n*/\ntypedef struct BlockCnt {\n  struct BlockCnt *previous;  /* chain */\n  int firstlabel;  /* index of first label in this block */\n  int firstgoto;  /* index of first pending goto in this block */\n  lu_byte nactvar;  /* # active locals outside the block */\n  lu_byte upval;  /* true if some variable in the block is an upvalue */\n  lu_byte isloop;  /* true if 'block' is a loop */\n  lu_byte insidetbc;  /* true if inside the scope of a to-be-closed var. */\n} BlockCnt;\n\n\n\n/*\n** prototypes for recursive non-terminal functions\n*/\nstatic void statement (LexState *ls);\nstatic void expr (LexState *ls, expdesc *v);\n\n\nstatic l_noret error_expected (LexState *ls, int token) {\n  luaX_syntaxerror(ls,\n      luaO_pushfstring(ls->L, \"%s expected\", luaX_token2str(ls, token)));\n}\n\n\nstatic l_noret errorlimit (FuncState *fs, int limit, const char *what) {\n  lua_State *L = fs->ls->L;\n  const char *msg;\n  int line = fs->f->linedefined;\n  const char *where = (line == 0)\n                      ? \"main function\"\n                      : luaO_pushfstring(L, \"function at line %d\", line);\n  msg = luaO_pushfstring(L, \"too many %s (limit is %d) in %s\",\n                             what, limit, where);\n  luaX_syntaxerror(fs->ls, msg);\n}\n\n\nstatic void checklimit (FuncState *fs, int v, int l, const char *what) {\n  if (v > l) errorlimit(fs, l, what);\n}\n\n\n/*\n** Test whether next token is 'c'; if so, skip it.\n*/\nstatic int testnext (LexState *ls, int c) {\n  if (ls->t.token == c) {\n    luaX_next(ls);\n    return 1;\n  }\n  else return 0;\n}\n\n\n/*\n** Check that next token is 'c'.\n*/\nstatic void check (LexState *ls, int c) {\n  if (ls->t.token != c)\n    error_expected(ls, c);\n}\n\n\n/*\n** Check that next token is 'c' and skip it.\n*/\nstatic void checknext (LexState *ls, int c) {\n  check(ls, c);\n  luaX_next(ls);\n}\n\n\n#define check_condition(ls,c,msg)\t{ if (!(c)) luaX_syntaxerror(ls, msg); }\n\n\n/*\n** Check that next token is 'what' and skip it. In case of error,\n** raise an error that the expected 'what' should match a 'who'\n** in line 'where' (if that is not the current line).\n*/\nstatic void check_match (LexState *ls, int what, int who, int where) {\n  if (l_unlikely(!testnext(ls, what))) {\n    if (where == ls->linenumber)  /* all in the same line? */\n      error_expected(ls, what);  /* do not need a complex message */\n    else {\n      luaX_syntaxerror(ls, luaO_pushfstring(ls->L,\n             \"%s expected (to close %s at line %d)\",\n              luaX_token2str(ls, what), luaX_token2str(ls, who), where));\n    }\n  }\n}\n\n\nstatic TString *str_checkname (LexState *ls) {\n  TString *ts;\n  check(ls, TK_NAME);\n  ts = ls->t.seminfo.ts;\n  luaX_next(ls);\n  return ts;\n}\n\n\nstatic void init_exp (expdesc *e, expkind k, int i) {\n  e->f = e->t = NO_JUMP;\n  e->k = k;\n  e->u.info = i;\n}\n\n\nstatic void codestring (expdesc *e, TString *s) {\n  e->f = e->t = NO_JUMP;\n  e->k = VKSTR;\n  e->u.strval = s;\n}\n\n\nstatic void codename (LexState *ls, expdesc *e) {\n  codestring(e, str_checkname(ls));\n}\n\n\n/*\n** Register a new local variable in the active 'Proto' (for debug\n** information).\n*/\nstatic int registerlocalvar (LexState *ls, FuncState *fs, TString *varname) {\n  Proto *f = fs->f;\n  int oldsize = f->sizelocvars;\n  luaM_growvector(ls->L, f->locvars, fs->ndebugvars, f->sizelocvars,\n                  LocVar, SHRT_MAX, \"local variables\");\n  while (oldsize < f->sizelocvars)\n    f->locvars[oldsize++].varname = NULL;\n  f->locvars[fs->ndebugvars].varname = varname;\n  f->locvars[fs->ndebugvars].startpc = fs->pc;\n  luaC_objbarrier(ls->L, f, varname);\n  return fs->ndebugvars++;\n}\n\n\n/*\n** Create a new local variable with the given 'name'. Return its index\n** in the function.\n*/\nstatic int new_localvar (LexState *ls, TString *name) {\n  lua_State *L = ls->L;\n  FuncState *fs = ls->fs;\n  Dyndata *dyd = ls->dyd;\n  Vardesc *var;\n  checklimit(fs, dyd->actvar.n + 1 - fs->firstlocal,\n                 MAXVARS, \"local variables\");\n  luaM_growvector(L, dyd->actvar.arr, dyd->actvar.n + 1,\n                  dyd->actvar.size, Vardesc, USHRT_MAX, \"local variables\");\n  var = &dyd->actvar.arr[dyd->actvar.n++];\n  var->vd.kind = VDKREG;  /* default */\n  var->vd.name = name;\n  return dyd->actvar.n - 1 - fs->firstlocal;\n}\n\n#define new_localvarliteral(ls,v) \\\n    new_localvar(ls,  \\\n      luaX_newstring(ls, \"\" v, (sizeof(v)/sizeof(char)) - 1));\n\n\n\n/*\n** Return the \"variable description\" (Vardesc) of a given variable.\n** (Unless noted otherwise, all variables are referred to by their\n** compiler indices.)\n*/\nstatic Vardesc *getlocalvardesc (FuncState *fs, int vidx) {\n  return &fs->ls->dyd->actvar.arr[fs->firstlocal + vidx];\n}\n\n\n/*\n** Convert 'nvar', a compiler index level, to its corresponding\n** register. For that, search for the highest variable below that level\n** that is in a register and uses its register index ('ridx') plus one.\n*/\nstatic int reglevel (FuncState *fs, int nvar) {\n  while (nvar-- > 0) {\n    Vardesc *vd = getlocalvardesc(fs, nvar);  /* get previous variable */\n    if (vd->vd.kind != RDKCTC)  /* is in a register? */\n      return vd->vd.ridx + 1;\n  }\n  return 0;  /* no variables in registers */\n}\n\n\n/*\n** Return the number of variables in the register stack for the given\n** function.\n*/\nint luaY_nvarstack (FuncState *fs) {\n  return reglevel(fs, fs->nactvar);\n}\n\n\n/*\n** Get the debug-information entry for current variable 'vidx'.\n*/\nstatic LocVar *localdebuginfo (FuncState *fs, int vidx) {\n  Vardesc *vd = getlocalvardesc(fs,  vidx);\n  if (vd->vd.kind == RDKCTC)\n    return NULL;  /* no debug info. for constants */\n  else {\n    int idx = vd->vd.pidx;\n    lua_assert(idx < fs->ndebugvars);\n    return &fs->f->locvars[idx];\n  }\n}\n\n\n/*\n** Create an expression representing variable 'vidx'\n*/\nstatic void init_var (FuncState *fs, expdesc *e, int vidx) {\n  e->f = e->t = NO_JUMP;\n  e->k = VLOCAL;\n  e->u.var.vidx = vidx;\n  e->u.var.ridx = getlocalvardesc(fs, vidx)->vd.ridx;\n}\n\n\n/*\n** Raises an error if variable described by 'e' is read only\n*/\nstatic void check_readonly (LexState *ls, expdesc *e) {\n  FuncState *fs = ls->fs;\n  TString *varname = NULL;  /* to be set if variable is const */\n  switch (e->k) {\n    case VCONST: {\n      varname = ls->dyd->actvar.arr[e->u.info].vd.name;\n      break;\n    }\n    case VLOCAL: {\n      Vardesc *vardesc = getlocalvardesc(fs, e->u.var.vidx);\n      if (vardesc->vd.kind != VDKREG)  /* not a regular variable? */\n        varname = vardesc->vd.name;\n      break;\n    }\n    case VUPVAL: {\n      Upvaldesc *up = &fs->f->upvalues[e->u.info];\n      if (up->kind != VDKREG)\n        varname = up->name;\n      break;\n    }\n    default:\n      return;  /* other cases cannot be read-only */\n  }\n  if (varname) {\n    const char *msg = luaO_pushfstring(ls->L,\n       \"attempt to assign to const variable '%s'\", getstr(varname));\n    luaK_semerror(ls, msg);  /* error */\n  }\n}\n\n\n/*\n** Start the scope for the last 'nvars' created variables.\n*/\nstatic void adjustlocalvars (LexState *ls, int nvars) {\n  FuncState *fs = ls->fs;\n  int reglevel = luaY_nvarstack(fs);\n  int i;\n  for (i = 0; i < nvars; i++) {\n    int vidx = fs->nactvar++;\n    Vardesc *var = getlocalvardesc(fs, vidx);\n    var->vd.ridx = reglevel++;\n    var->vd.pidx = registerlocalvar(ls, fs, var->vd.name);\n  }\n}\n\n\n/*\n** Close the scope for all variables up to level 'tolevel'.\n** (debug info.)\n*/\nstatic void removevars (FuncState *fs, int tolevel) {\n  fs->ls->dyd->actvar.n -= (fs->nactvar - tolevel);\n  while (fs->nactvar > tolevel) {\n    LocVar *var = localdebuginfo(fs, --fs->nactvar);\n    if (var)  /* does it have debug information? */\n      var->endpc = fs->pc;\n  }\n}\n\n\n/*\n** Search the upvalues of the function 'fs' for one\n** with the given 'name'.\n*/\nstatic int searchupvalue (FuncState *fs, TString *name) {\n  int i;\n  Upvaldesc *up = fs->f->upvalues;\n  for (i = 0; i < fs->nups; i++) {\n    if (eqstr(up[i].name, name)) return i;\n  }\n  return -1;  /* not found */\n}\n\n\nstatic Upvaldesc *allocupvalue (FuncState *fs) {\n  Proto *f = fs->f;\n  int oldsize = f->sizeupvalues;\n  checklimit(fs, fs->nups + 1, MAXUPVAL, \"upvalues\");\n  luaM_growvector(fs->ls->L, f->upvalues, fs->nups, f->sizeupvalues,\n                  Upvaldesc, MAXUPVAL, \"upvalues\");\n  while (oldsize < f->sizeupvalues)\n    f->upvalues[oldsize++].name = NULL;\n  return &f->upvalues[fs->nups++];\n}\n\n\nstatic int newupvalue (FuncState *fs, TString *name, expdesc *v) {\n  Upvaldesc *up = allocupvalue(fs);\n  FuncState *prev = fs->prev;\n  if (v->k == VLOCAL) {\n    up->instack = 1;\n    up->idx = v->u.var.ridx;\n    up->kind = getlocalvardesc(prev, v->u.var.vidx)->vd.kind;\n    lua_assert(eqstr(name, getlocalvardesc(prev, v->u.var.vidx)->vd.name));\n  }\n  else {\n    up->instack = 0;\n    up->idx = cast_byte(v->u.info);\n    up->kind = prev->f->upvalues[v->u.info].kind;\n    lua_assert(eqstr(name, prev->f->upvalues[v->u.info].name));\n  }\n  up->name = name;\n  luaC_objbarrier(fs->ls->L, fs->f, name);\n  return fs->nups - 1;\n}\n\n\n/*\n** Look for an active local variable with the name 'n' in the\n** function 'fs'. If found, initialize 'var' with it and return\n** its expression kind; otherwise return -1.\n*/\nstatic int searchvar (FuncState *fs, TString *n, expdesc *var) {\n  int i;\n  for (i = cast_int(fs->nactvar) - 1; i >= 0; i--) {\n    Vardesc *vd = getlocalvardesc(fs, i);\n    if (eqstr(n, vd->vd.name)) {  /* found? */\n      if (vd->vd.kind == RDKCTC)  /* compile-time constant? */\n        init_exp(var, VCONST, fs->firstlocal + i);\n      else  /* real variable */\n        init_var(fs, var, i);\n      return var->k;\n    }\n  }\n  return -1;  /* not found */\n}\n\n\n/*\n** Mark block where variable at given level was defined\n** (to emit close instructions later).\n*/\nstatic void markupval (FuncState *fs, int level) {\n  BlockCnt *bl = fs->bl;\n  while (bl->nactvar > level)\n    bl = bl->previous;\n  bl->upval = 1;\n  fs->needclose = 1;\n}\n\n\n/*\n** Mark that current block has a to-be-closed variable.\n*/\nstatic void marktobeclosed (FuncState *fs) {\n  BlockCnt *bl = fs->bl;\n  bl->upval = 1;\n  bl->insidetbc = 1;\n  fs->needclose = 1;\n}\n\n\n/*\n** Find a variable with the given name 'n'. If it is an upvalue, add\n** this upvalue into all intermediate functions. If it is a global, set\n** 'var' as 'void' as a flag.\n*/\nstatic void singlevaraux (FuncState *fs, TString *n, expdesc *var, int base) {\n  if (fs == NULL)  /* no more levels? */\n    init_exp(var, VVOID, 0);  /* default is global */\n  else {\n    int v = searchvar(fs, n, var);  /* look up locals at current level */\n    if (v >= 0) {  /* found? */\n      if (v == VLOCAL && !base)\n        markupval(fs, var->u.var.vidx);  /* local will be used as an upval */\n    }\n    else {  /* not found as local at current level; try upvalues */\n      int idx = searchupvalue(fs, n);  /* try existing upvalues */\n      if (idx < 0) {  /* not found? */\n        singlevaraux(fs->prev, n, var, 0);  /* try upper levels */\n        if (var->k == VLOCAL || var->k == VUPVAL)  /* local or upvalue? */\n          idx  = newupvalue(fs, n, var);  /* will be a new upvalue */\n        else  /* it is a global or a constant */\n          return;  /* don't need to do anything at this level */\n      }\n      init_exp(var, VUPVAL, idx);  /* new or old upvalue */\n    }\n  }\n}\n\n\n/*\n** Find a variable with the given name 'n', handling global variables\n** too.\n*/\nstatic void singlevar (LexState *ls, expdesc *var) {\n  TString *varname = str_checkname(ls);\n  FuncState *fs = ls->fs;\n  singlevaraux(fs, varname, var, 1);\n  if (var->k == VVOID) {  /* global name? */\n    expdesc key;\n    singlevaraux(fs, ls->envn, var, 1);  /* get environment variable */\n    lua_assert(var->k != VVOID);  /* this one must exist */\n    codestring(&key, varname);  /* key is variable name */\n    luaK_indexed(fs, var, &key);  /* env[varname] */\n  }\n}\n\n\n/*\n** Adjust the number of results from an expression list 'e' with 'nexps'\n** expressions to 'nvars' values.\n*/\nstatic void adjust_assign (LexState *ls, int nvars, int nexps, expdesc *e) {\n  FuncState *fs = ls->fs;\n  int needed = nvars - nexps;  /* extra values needed */\n  if (hasmultret(e->k)) {  /* last expression has multiple returns? */\n    int extra = needed + 1;  /* discount last expression itself */\n    if (extra < 0)\n      extra = 0;\n    luaK_setreturns(fs, e, extra);  /* last exp. provides the difference */\n  }\n  else {\n    if (e->k != VVOID)  /* at least one expression? */\n      luaK_exp2nextreg(fs, e);  /* close last expression */\n    if (needed > 0)  /* missing values? */\n      luaK_nil(fs, fs->freereg, needed);  /* complete with nils */\n  }\n  if (needed > 0)\n    luaK_reserveregs(fs, needed);  /* registers for extra values */\n  else  /* adding 'needed' is actually a subtraction */\n    fs->freereg += needed;  /* remove extra values */\n}\n\n\n#define enterlevel(ls)\tluaE_incCstack(ls->L)\n\n\n#define leavelevel(ls) ((ls)->L->nCcalls--)\n\n\n/*\n** Generates an error that a goto jumps into the scope of some\n** local variable.\n*/\nstatic l_noret jumpscopeerror (LexState *ls, Labeldesc *gt) {\n  const char *varname = getstr(getlocalvardesc(ls->fs, gt->nactvar)->vd.name);\n  const char *msg = \"<goto %s> at line %d jumps into the scope of local '%s'\";\n  msg = luaO_pushfstring(ls->L, msg, getstr(gt->name), gt->line, varname);\n  luaK_semerror(ls, msg);  /* raise the error */\n}\n\n\n/*\n** Solves the goto at index 'g' to given 'label' and removes it\n** from the list of pending goto's.\n** If it jumps into the scope of some variable, raises an error.\n*/\nstatic void solvegoto (LexState *ls, int g, Labeldesc *label) {\n  int i;\n  Labellist *gl = &ls->dyd->gt;  /* list of goto's */\n  Labeldesc *gt = &gl->arr[g];  /* goto to be resolved */\n  lua_assert(eqstr(gt->name, label->name));\n  if (l_unlikely(gt->nactvar < label->nactvar))  /* enter some scope? */\n    jumpscopeerror(ls, gt);\n  luaK_patchlist(ls->fs, gt->pc, label->pc);\n  for (i = g; i < gl->n - 1; i++)  /* remove goto from pending list */\n    gl->arr[i] = gl->arr[i + 1];\n  gl->n--;\n}\n\n\n/*\n** Search for an active label with the given name.\n*/\nstatic Labeldesc *findlabel (LexState *ls, TString *name) {\n  int i;\n  Dyndata *dyd = ls->dyd;\n  /* check labels in current function for a match */\n  for (i = ls->fs->firstlabel; i < dyd->label.n; i++) {\n    Labeldesc *lb = &dyd->label.arr[i];\n    if (eqstr(lb->name, name))  /* correct label? */\n      return lb;\n  }\n  return NULL;  /* label not found */\n}\n\n\n/*\n** Adds a new label/goto in the corresponding list.\n*/\nstatic int newlabelentry (LexState *ls, Labellist *l, TString *name,\n                          int line, int pc) {\n  int n = l->n;\n  luaM_growvector(ls->L, l->arr, n, l->size,\n                  Labeldesc, SHRT_MAX, \"labels/gotos\");\n  l->arr[n].name = name;\n  l->arr[n].line = line;\n  l->arr[n].nactvar = ls->fs->nactvar;\n  l->arr[n].close = 0;\n  l->arr[n].pc = pc;\n  l->n = n + 1;\n  return n;\n}\n\n\nstatic int newgotoentry (LexState *ls, TString *name, int line, int pc) {\n  return newlabelentry(ls, &ls->dyd->gt, name, line, pc);\n}\n\n\n/*\n** Solves forward jumps. Check whether new label 'lb' matches any\n** pending gotos in current block and solves them. Return true\n** if any of the goto's need to close upvalues.\n*/\nstatic int solvegotos (LexState *ls, Labeldesc *lb) {\n  Labellist *gl = &ls->dyd->gt;\n  int i = ls->fs->bl->firstgoto;\n  int needsclose = 0;\n  while (i < gl->n) {\n    if (eqstr(gl->arr[i].name, lb->name)) {\n      needsclose |= gl->arr[i].close;\n      solvegoto(ls, i, lb);  /* will remove 'i' from the list */\n    }\n    else\n      i++;\n  }\n  return needsclose;\n}\n\n\n/*\n** Create a new label with the given 'name' at the given 'line'.\n** 'last' tells whether label is the last non-op statement in its\n** block. Solves all pending goto's to this new label and adds\n** a close instruction if necessary.\n** Returns true iff it added a close instruction.\n*/\nstatic int createlabel (LexState *ls, TString *name, int line,\n                        int last) {\n  FuncState *fs = ls->fs;\n  Labellist *ll = &ls->dyd->label;\n  int l = newlabelentry(ls, ll, name, line, luaK_getlabel(fs));\n  if (last) {  /* label is last no-op statement in the block? */\n    /* assume that locals are already out of scope */\n    ll->arr[l].nactvar = fs->bl->nactvar;\n  }\n  if (solvegotos(ls, &ll->arr[l])) {  /* need close? */\n    luaK_codeABC(fs, OP_CLOSE, luaY_nvarstack(fs), 0, 0);\n    return 1;\n  }\n  return 0;\n}\n\n\n/*\n** Adjust pending gotos to outer level of a block.\n*/\nstatic void movegotosout (FuncState *fs, BlockCnt *bl) {\n  int i;\n  Labellist *gl = &fs->ls->dyd->gt;\n  /* correct pending gotos to current block */\n  for (i = bl->firstgoto; i < gl->n; i++) {  /* for each pending goto */\n    Labeldesc *gt = &gl->arr[i];\n    /* leaving a variable scope? */\n    if (reglevel(fs, gt->nactvar) > reglevel(fs, bl->nactvar))\n      gt->close |= bl->upval;  /* jump may need a close */\n    gt->nactvar = bl->nactvar;  /* update goto level */\n  }\n}\n\n\nstatic void enterblock (FuncState *fs, BlockCnt *bl, lu_byte isloop) {\n  bl->isloop = isloop;\n  bl->nactvar = fs->nactvar;\n  bl->firstlabel = fs->ls->dyd->label.n;\n  bl->firstgoto = fs->ls->dyd->gt.n;\n  bl->upval = 0;\n  bl->insidetbc = (fs->bl != NULL && fs->bl->insidetbc);\n  bl->previous = fs->bl;\n  fs->bl = bl;\n  lua_assert(fs->freereg == luaY_nvarstack(fs));\n}\n\n\n/*\n** generates an error for an undefined 'goto'.\n*/\nstatic l_noret undefgoto (LexState *ls, Labeldesc *gt) {\n  const char *msg;\n  if (eqstr(gt->name, luaS_newliteral(ls->L, \"break\"))) {\n    msg = \"break outside loop at line %d\";\n    msg = luaO_pushfstring(ls->L, msg, gt->line);\n  }\n  else {\n    msg = \"no visible label '%s' for <goto> at line %d\";\n    msg = luaO_pushfstring(ls->L, msg, getstr(gt->name), gt->line);\n  }\n  luaK_semerror(ls, msg);\n}\n\n\nstatic void leaveblock (FuncState *fs) {\n  BlockCnt *bl = fs->bl;\n  LexState *ls = fs->ls;\n  int hasclose = 0;\n  int stklevel = reglevel(fs, bl->nactvar);  /* level outside the block */\n  if (bl->isloop)  /* fix pending breaks? */\n    hasclose = createlabel(ls, luaS_newliteral(ls->L, \"break\"), 0, 0);\n  if (!hasclose && bl->previous && bl->upval)\n    luaK_codeABC(fs, OP_CLOSE, stklevel, 0, 0);\n  fs->bl = bl->previous;\n  removevars(fs, bl->nactvar);\n  lua_assert(bl->nactvar == fs->nactvar);\n  fs->freereg = stklevel;  /* free registers */\n  ls->dyd->label.n = bl->firstlabel;  /* remove local labels */\n  if (bl->previous)  /* inner block? */\n    movegotosout(fs, bl);  /* update pending gotos to outer block */\n  else {\n    if (bl->firstgoto < ls->dyd->gt.n)  /* pending gotos in outer block? */\n      undefgoto(ls, &ls->dyd->gt.arr[bl->firstgoto]);  /* error */\n  }\n}\n\n\n/*\n** adds a new prototype into list of prototypes\n*/\nstatic Proto *addprototype (LexState *ls) {\n  Proto *clp;\n  lua_State *L = ls->L;\n  FuncState *fs = ls->fs;\n  Proto *f = fs->f;  /* prototype of current function */\n  if (fs->np >= f->sizep) {\n    int oldsize = f->sizep;\n    luaM_growvector(L, f->p, fs->np, f->sizep, Proto *, MAXARG_Bx, \"functions\");\n    while (oldsize < f->sizep)\n      f->p[oldsize++] = NULL;\n  }\n  f->p[fs->np++] = clp = luaF_newproto(L);\n  luaC_objbarrier(L, f, clp);\n  return clp;\n}\n\n\n/*\n** codes instruction to create new closure in parent function.\n** The OP_CLOSURE instruction uses the last available register,\n** so that, if it invokes the GC, the GC knows which registers\n** are in use at that time.\n\n*/\nstatic void codeclosure (LexState *ls, expdesc *v) {\n  FuncState *fs = ls->fs->prev;\n  init_exp(v, VRELOC, luaK_codeABx(fs, OP_CLOSURE, 0, fs->np - 1));\n  luaK_exp2nextreg(fs, v);  /* fix it at the last register */\n}\n\n\nstatic void open_func (LexState *ls, FuncState *fs, BlockCnt *bl) {\n  Proto *f = fs->f;\n  fs->prev = ls->fs;  /* linked list of funcstates */\n  fs->ls = ls;\n  ls->fs = fs;\n  fs->pc = 0;\n  fs->previousline = f->linedefined;\n  fs->iwthabs = 0;\n  fs->lasttarget = 0;\n  fs->freereg = 0;\n  fs->nk = 0;\n  fs->nabslineinfo = 0;\n  fs->np = 0;\n  fs->nups = 0;\n  fs->ndebugvars = 0;\n  fs->nactvar = 0;\n  fs->needclose = 0;\n  fs->firstlocal = ls->dyd->actvar.n;\n  fs->firstlabel = ls->dyd->label.n;\n  fs->bl = NULL;\n  f->source = ls->source;\n  luaC_objbarrier(ls->L, f, f->source);\n  f->maxstacksize = 2;  /* registers 0/1 are always valid */\n  enterblock(fs, bl, 0);\n}\n\n\nstatic void close_func (LexState *ls) {\n  lua_State *L = ls->L;\n  FuncState *fs = ls->fs;\n  Proto *f = fs->f;\n  luaK_ret(fs, luaY_nvarstack(fs), 0);  /* final return */\n  leaveblock(fs);\n  lua_assert(fs->bl == NULL);\n  luaK_finish(fs);\n  luaM_shrinkvector(L, f->code, f->sizecode, fs->pc, Instruction);\n  luaM_shrinkvector(L, f->lineinfo, f->sizelineinfo, fs->pc, ls_byte);\n  luaM_shrinkvector(L, f->abslineinfo, f->sizeabslineinfo,\n                       fs->nabslineinfo, AbsLineInfo);\n  luaM_shrinkvector(L, f->k, f->sizek, fs->nk, TValue);\n  luaM_shrinkvector(L, f->p, f->sizep, fs->np, Proto *);\n  luaM_shrinkvector(L, f->locvars, f->sizelocvars, fs->ndebugvars, LocVar);\n  luaM_shrinkvector(L, f->upvalues, f->sizeupvalues, fs->nups, Upvaldesc);\n  ls->fs = fs->prev;\n  luaC_checkGC(L);\n}\n\n\n\n/*============================================================*/\n/* GRAMMAR RULES */\n/*============================================================*/\n\n\n/*\n** check whether current token is in the follow set of a block.\n** 'until' closes syntactical blocks, but do not close scope,\n** so it is handled in separate.\n*/\nstatic int block_follow (LexState *ls, int withuntil) {\n  switch (ls->t.token) {\n    case TK_ELSE: case TK_ELSEIF:\n    case TK_END: case TK_EOS:\n      return 1;\n    case TK_UNTIL: return withuntil;\n    default: return 0;\n  }\n}\n\n\nstatic void statlist (LexState *ls) {\n  /* statlist -> { stat [';'] } */\n  while (!block_follow(ls, 1)) {\n    if (ls->t.token == TK_RETURN) {\n      statement(ls);\n      return;  /* 'return' must be last statement */\n    }\n    statement(ls);\n  }\n}\n\n\nstatic void fieldsel (LexState *ls, expdesc *v) {\n  /* fieldsel -> ['.' | ':'] NAME */\n  FuncState *fs = ls->fs;\n  expdesc key;\n  luaK_exp2anyregup(fs, v);\n  luaX_next(ls);  /* skip the dot or colon */\n  codename(ls, &key);\n  luaK_indexed(fs, v, &key);\n}\n\n\nstatic void yindex (LexState *ls, expdesc *v) {\n  /* index -> '[' expr ']' */\n  luaX_next(ls);  /* skip the '[' */\n  expr(ls, v);\n  luaK_exp2val(ls->fs, v);\n  checknext(ls, ']');\n}\n\n\n/*\n** {======================================================================\n** Rules for Constructors\n** =======================================================================\n*/\n\n\ntypedef struct ConsControl {\n  expdesc v;  /* last list item read */\n  expdesc *t;  /* table descriptor */\n  int nh;  /* total number of 'record' elements */\n  int na;  /* number of array elements already stored */\n  int tostore;  /* number of array elements pending to be stored */\n} ConsControl;\n\n\nstatic void recfield (LexState *ls, ConsControl *cc) {\n  /* recfield -> (NAME | '['exp']') = exp */\n  FuncState *fs = ls->fs;\n  int reg = ls->fs->freereg;\n  expdesc tab, key, val;\n  if (ls->t.token == TK_NAME) {\n    checklimit(fs, cc->nh, MAX_INT, \"items in a constructor\");\n    codename(ls, &key);\n  }\n  else  /* ls->t.token == '[' */\n    yindex(ls, &key);\n  cc->nh++;\n  checknext(ls, '=');\n  tab = *cc->t;\n  luaK_indexed(fs, &tab, &key);\n  expr(ls, &val);\n  luaK_storevar(fs, &tab, &val);\n  fs->freereg = reg;  /* free registers */\n}\n\n\nstatic void closelistfield (FuncState *fs, ConsControl *cc) {\n  if (cc->v.k == VVOID) return;  /* there is no list item */\n  luaK_exp2nextreg(fs, &cc->v);\n  cc->v.k = VVOID;\n  if (cc->tostore == LFIELDS_PER_FLUSH) {\n    luaK_setlist(fs, cc->t->u.info, cc->na, cc->tostore);  /* flush */\n    cc->na += cc->tostore;\n    cc->tostore = 0;  /* no more items pending */\n  }\n}\n\n\nstatic void lastlistfield (FuncState *fs, ConsControl *cc) {\n  if (cc->tostore == 0) return;\n  if (hasmultret(cc->v.k)) {\n    luaK_setmultret(fs, &cc->v);\n    luaK_setlist(fs, cc->t->u.info, cc->na, LUA_MULTRET);\n    cc->na--;  /* do not count last expression (unknown number of elements) */\n  }\n  else {\n    if (cc->v.k != VVOID)\n      luaK_exp2nextreg(fs, &cc->v);\n    luaK_setlist(fs, cc->t->u.info, cc->na, cc->tostore);\n  }\n  cc->na += cc->tostore;\n}\n\n\nstatic void listfield (LexState *ls, ConsControl *cc) {\n  /* listfield -> exp */\n  expr(ls, &cc->v);\n  cc->tostore++;\n}\n\n\nstatic void field (LexState *ls, ConsControl *cc) {\n  /* field -> listfield | recfield */\n  switch(ls->t.token) {\n    case TK_NAME: {  /* may be 'listfield' or 'recfield' */\n      if (luaX_lookahead(ls) != '=')  /* expression? */\n        listfield(ls, cc);\n      else\n        recfield(ls, cc);\n      break;\n    }\n    case '[': {\n      recfield(ls, cc);\n      break;\n    }\n    default: {\n      listfield(ls, cc);\n      break;\n    }\n  }\n}\n\n\nstatic void constructor (LexState *ls, expdesc *t) {\n  /* constructor -> '{' [ field { sep field } [sep] ] '}'\n     sep -> ',' | ';' */\n  FuncState *fs = ls->fs;\n  int line = ls->linenumber;\n  int pc = luaK_codeABC(fs, OP_NEWTABLE, 0, 0, 0);\n  ConsControl cc;\n  luaK_code(fs, 0);  /* space for extra arg. */\n  cc.na = cc.nh = cc.tostore = 0;\n  cc.t = t;\n  init_exp(t, VNONRELOC, fs->freereg);  /* table will be at stack top */\n  luaK_reserveregs(fs, 1);\n  init_exp(&cc.v, VVOID, 0);  /* no value (yet) */\n  checknext(ls, '{');\n  do {\n    lua_assert(cc.v.k == VVOID || cc.tostore > 0);\n    if (ls->t.token == '}') break;\n    closelistfield(fs, &cc);\n    field(ls, &cc);\n  } while (testnext(ls, ',') || testnext(ls, ';'));\n  check_match(ls, '}', '{', line);\n  lastlistfield(fs, &cc);\n  luaK_settablesize(fs, pc, t->u.info, cc.na, cc.nh);\n}\n\n/* }====================================================================== */\n\n\nstatic void setvararg (FuncState *fs, int nparams) {\n  fs->f->is_vararg = 1;\n  luaK_codeABC(fs, OP_VARARGPREP, nparams, 0, 0);\n}\n\n\nstatic void parlist (LexState *ls) {\n  /* parlist -> [ {NAME ','} (NAME | '...') ] */\n  FuncState *fs = ls->fs;\n  Proto *f = fs->f;\n  int nparams = 0;\n  int isvararg = 0;\n  if (ls->t.token != ')') {  /* is 'parlist' not empty? */\n    do {\n      switch (ls->t.token) {\n        case TK_NAME: {\n          new_localvar(ls, str_checkname(ls));\n          nparams++;\n          break;\n        }\n        case TK_DOTS: {\n          luaX_next(ls);\n          isvararg = 1;\n          break;\n        }\n        default: luaX_syntaxerror(ls, \"<name> or '...' expected\");\n      }\n    } while (!isvararg && testnext(ls, ','));\n  }\n  adjustlocalvars(ls, nparams);\n  f->numparams = cast_byte(fs->nactvar);\n  if (isvararg)\n    setvararg(fs, f->numparams);  /* declared vararg */\n  luaK_reserveregs(fs, fs->nactvar);  /* reserve registers for parameters */\n}\n\n\nstatic void body (LexState *ls, expdesc *e, int ismethod, int line) {\n  /* body ->  '(' parlist ')' block END */\n  FuncState new_fs;\n  BlockCnt bl;\n  new_fs.f = addprototype(ls);\n  new_fs.f->linedefined = line;\n  open_func(ls, &new_fs, &bl);\n  checknext(ls, '(');\n  if (ismethod) {\n    new_localvarliteral(ls, \"self\");  /* create 'self' parameter */\n    adjustlocalvars(ls, 1);\n  }\n  parlist(ls);\n  checknext(ls, ')');\n  statlist(ls);\n  new_fs.f->lastlinedefined = ls->linenumber;\n  check_match(ls, TK_END, TK_FUNCTION, line);\n  codeclosure(ls, e);\n  close_func(ls);\n}\n\n\nstatic int explist (LexState *ls, expdesc *v) {\n  /* explist -> expr { ',' expr } */\n  int n = 1;  /* at least one expression */\n  expr(ls, v);\n  while (testnext(ls, ',')) {\n    luaK_exp2nextreg(ls->fs, v);\n    expr(ls, v);\n    n++;\n  }\n  return n;\n}\n\n\nstatic void funcargs (LexState *ls, expdesc *f, int line) {\n  FuncState *fs = ls->fs;\n  expdesc args;\n  int base, nparams;\n  switch (ls->t.token) {\n    case '(': {  /* funcargs -> '(' [ explist ] ')' */\n      luaX_next(ls);\n      if (ls->t.token == ')')  /* arg list is empty? */\n        args.k = VVOID;\n      else {\n        explist(ls, &args);\n        if (hasmultret(args.k))\n          luaK_setmultret(fs, &args);\n      }\n      check_match(ls, ')', '(', line);\n      break;\n    }\n    case '{': {  /* funcargs -> constructor */\n      constructor(ls, &args);\n      break;\n    }\n    case TK_STRING: {  /* funcargs -> STRING */\n      codestring(&args, ls->t.seminfo.ts);\n      luaX_next(ls);  /* must use 'seminfo' before 'next' */\n      break;\n    }\n    default: {\n      luaX_syntaxerror(ls, \"function arguments expected\");\n    }\n  }\n  lua_assert(f->k == VNONRELOC);\n  base = f->u.info;  /* base register for call */\n  if (hasmultret(args.k))\n    nparams = LUA_MULTRET;  /* open call */\n  else {\n    if (args.k != VVOID)\n      luaK_exp2nextreg(fs, &args);  /* close last argument */\n    nparams = fs->freereg - (base+1);\n  }\n  init_exp(f, VCALL, luaK_codeABC(fs, OP_CALL, base, nparams+1, 2));\n  luaK_fixline(fs, line);\n  fs->freereg = base+1;  /* call remove function and arguments and leaves\n                            (unless changed) one result */\n}\n\n\n\n\n/*\n** {======================================================================\n** Expression parsing\n** =======================================================================\n*/\n\n\nstatic void primaryexp (LexState *ls, expdesc *v) {\n  /* primaryexp -> NAME | '(' expr ')' */\n  switch (ls->t.token) {\n    case '(': {\n      int line = ls->linenumber;\n      luaX_next(ls);\n      expr(ls, v);\n      check_match(ls, ')', '(', line);\n      luaK_dischargevars(ls->fs, v);\n      return;\n    }\n    case TK_NAME: {\n      singlevar(ls, v);\n      return;\n    }\n    default: {\n      luaX_syntaxerror(ls, \"unexpected symbol\");\n    }\n  }\n}\n\n\nstatic void suffixedexp (LexState *ls, expdesc *v) {\n  /* suffixedexp ->\n       primaryexp { '.' NAME | '[' exp ']' | ':' NAME funcargs | funcargs } */\n  FuncState *fs = ls->fs;\n  int line = ls->linenumber;\n  primaryexp(ls, v);\n  for (;;) {\n    switch (ls->t.token) {\n      case '.': {  /* fieldsel */\n        fieldsel(ls, v);\n        break;\n      }\n      case '[': {  /* '[' exp ']' */\n        expdesc key;\n        luaK_exp2anyregup(fs, v);\n        yindex(ls, &key);\n        luaK_indexed(fs, v, &key);\n        break;\n      }\n      case ':': {  /* ':' NAME funcargs */\n        expdesc key;\n        luaX_next(ls);\n        codename(ls, &key);\n        luaK_self(fs, v, &key);\n        funcargs(ls, v, line);\n        break;\n      }\n      case '(': case TK_STRING: case '{': {  /* funcargs */\n        luaK_exp2nextreg(fs, v);\n        funcargs(ls, v, line);\n        break;\n      }\n      default: return;\n    }\n  }\n}\n\n\nstatic void simpleexp (LexState *ls, expdesc *v) {\n  /* simpleexp -> FLT | INT | STRING | NIL | TRUE | FALSE | ... |\n                  constructor | FUNCTION body | suffixedexp */\n  switch (ls->t.token) {\n    case TK_FLT: {\n      init_exp(v, VKFLT, 0);\n      v->u.nval = ls->t.seminfo.r;\n      break;\n    }\n    case TK_INT: {\n      init_exp(v, VKINT, 0);\n      v->u.ival = ls->t.seminfo.i;\n      break;\n    }\n    case TK_STRING: {\n      codestring(v, ls->t.seminfo.ts);\n      break;\n    }\n    case TK_NIL: {\n      init_exp(v, VNIL, 0);\n      break;\n    }\n    case TK_TRUE: {\n      init_exp(v, VTRUE, 0);\n      break;\n    }\n    case TK_FALSE: {\n      init_exp(v, VFALSE, 0);\n      break;\n    }\n    case TK_DOTS: {  /* vararg */\n      FuncState *fs = ls->fs;\n      check_condition(ls, fs->f->is_vararg,\n                      \"cannot use '...' outside a vararg function\");\n      init_exp(v, VVARARG, luaK_codeABC(fs, OP_VARARG, 0, 0, 1));\n      break;\n    }\n    case '{': {  /* constructor */\n      constructor(ls, v);\n      return;\n    }\n    case TK_FUNCTION: {\n      luaX_next(ls);\n      body(ls, v, 0, ls->linenumber);\n      return;\n    }\n    default: {\n      suffixedexp(ls, v);\n      return;\n    }\n  }\n  luaX_next(ls);\n}\n\n\nstatic UnOpr getunopr (int op) {\n  switch (op) {\n    case TK_NOT: return OPR_NOT;\n    case '-': return OPR_MINUS;\n    case '~': return OPR_BNOT;\n    case '#': return OPR_LEN;\n    default: return OPR_NOUNOPR;\n  }\n}\n\n\nstatic BinOpr getbinopr (int op) {\n  switch (op) {\n    case '+': return OPR_ADD;\n    case '-': return OPR_SUB;\n    case '*': return OPR_MUL;\n    case '%': return OPR_MOD;\n    case '^': return OPR_POW;\n    case '/': return OPR_DIV;\n    case TK_IDIV: return OPR_IDIV;\n    case '&': return OPR_BAND;\n    case '|': return OPR_BOR;\n    case '~': return OPR_BXOR;\n    case TK_SHL: return OPR_SHL;\n    case TK_SHR: return OPR_SHR;\n    case TK_CONCAT: return OPR_CONCAT;\n    case TK_NE: return OPR_NE;\n    case TK_EQ: return OPR_EQ;\n    case '<': return OPR_LT;\n    case TK_LE: return OPR_LE;\n    case '>': return OPR_GT;\n    case TK_GE: return OPR_GE;\n    case TK_AND: return OPR_AND;\n    case TK_OR: return OPR_OR;\n    default: return OPR_NOBINOPR;\n  }\n}\n\n\n/*\n** Priority table for binary operators.\n*/\nstatic const struct {\n  lu_byte left;  /* left priority for each binary operator */\n  lu_byte right; /* right priority */\n} priority[] = {  /* ORDER OPR */\n   {10, 10}, {10, 10},           /* '+' '-' */\n   {11, 11}, {11, 11},           /* '*' '%' */\n   {14, 13},                  /* '^' (right associative) */\n   {11, 11}, {11, 11},           /* '/' '//' */\n   {6, 6}, {4, 4}, {5, 5},   /* '&' '|' '~' */\n   {7, 7}, {7, 7},           /* '<<' '>>' */\n   {9, 8},                   /* '..' (right associative) */\n   {3, 3}, {3, 3}, {3, 3},   /* ==, <, <= */\n   {3, 3}, {3, 3}, {3, 3},   /* ~=, >, >= */\n   {2, 2}, {1, 1}            /* and, or */\n};\n\n#define UNARY_PRIORITY\t12  /* priority for unary operators */\n\n\n/*\n** subexpr -> (simpleexp | unop subexpr) { binop subexpr }\n** where 'binop' is any binary operator with a priority higher than 'limit'\n*/\nstatic BinOpr subexpr (LexState *ls, expdesc *v, int limit) {\n  BinOpr op;\n  UnOpr uop;\n  enterlevel(ls);\n  uop = getunopr(ls->t.token);\n  if (uop != OPR_NOUNOPR) {  /* prefix (unary) operator? */\n    int line = ls->linenumber;\n    luaX_next(ls);  /* skip operator */\n    subexpr(ls, v, UNARY_PRIORITY);\n    luaK_prefix(ls->fs, uop, v, line);\n  }\n  else simpleexp(ls, v);\n  /* expand while operators have priorities higher than 'limit' */\n  op = getbinopr(ls->t.token);\n  while (op != OPR_NOBINOPR && priority[op].left > limit) {\n    expdesc v2;\n    BinOpr nextop;\n    int line = ls->linenumber;\n    luaX_next(ls);  /* skip operator */\n    luaK_infix(ls->fs, op, v);\n    /* read sub-expression with higher priority */\n    nextop = subexpr(ls, &v2, priority[op].right);\n    luaK_posfix(ls->fs, op, v, &v2, line);\n    op = nextop;\n  }\n  leavelevel(ls);\n  return op;  /* return first untreated operator */\n}\n\n\nstatic void expr (LexState *ls, expdesc *v) {\n  subexpr(ls, v, 0);\n}\n\n/* }==================================================================== */\n\n\n\n/*\n** {======================================================================\n** Rules for Statements\n** =======================================================================\n*/\n\n\nstatic void block (LexState *ls) {\n  /* block -> statlist */\n  FuncState *fs = ls->fs;\n  BlockCnt bl;\n  enterblock(fs, &bl, 0);\n  statlist(ls);\n  leaveblock(fs);\n}\n\n\n/*\n** structure to chain all variables in the left-hand side of an\n** assignment\n*/\nstruct LHS_assign {\n  struct LHS_assign *prev;\n  expdesc v;  /* variable (global, local, upvalue, or indexed) */\n};\n\n\n/*\n** check whether, in an assignment to an upvalue/local variable, the\n** upvalue/local variable is begin used in a previous assignment to a\n** table. If so, save original upvalue/local value in a safe place and\n** use this safe copy in the previous assignment.\n*/\nstatic void check_conflict (LexState *ls, struct LHS_assign *lh, expdesc *v) {\n  FuncState *fs = ls->fs;\n  int extra = fs->freereg;  /* eventual position to save local variable */\n  int conflict = 0;\n  for (; lh; lh = lh->prev) {  /* check all previous assignments */\n    if (vkisindexed(lh->v.k)) {  /* assignment to table field? */\n      if (lh->v.k == VINDEXUP) {  /* is table an upvalue? */\n        if (v->k == VUPVAL && lh->v.u.ind.t == v->u.info) {\n          conflict = 1;  /* table is the upvalue being assigned now */\n          lh->v.k = VINDEXSTR;\n          lh->v.u.ind.t = extra;  /* assignment will use safe copy */\n        }\n      }\n      else {  /* table is a register */\n        if (v->k == VLOCAL && lh->v.u.ind.t == v->u.var.ridx) {\n          conflict = 1;  /* table is the local being assigned now */\n          lh->v.u.ind.t = extra;  /* assignment will use safe copy */\n        }\n        /* is index the local being assigned? */\n        if (lh->v.k == VINDEXED && v->k == VLOCAL &&\n            lh->v.u.ind.idx == v->u.var.ridx) {\n          conflict = 1;\n          lh->v.u.ind.idx = extra;  /* previous assignment will use safe copy */\n        }\n      }\n    }\n  }\n  if (conflict) {\n    /* copy upvalue/local value to a temporary (in position 'extra') */\n    if (v->k == VLOCAL)\n      luaK_codeABC(fs, OP_MOVE, extra, v->u.var.ridx, 0);\n    else\n      luaK_codeABC(fs, OP_GETUPVAL, extra, v->u.info, 0);\n    luaK_reserveregs(fs, 1);\n  }\n}\n\n/*\n** Parse and compile a multiple assignment. The first \"variable\"\n** (a 'suffixedexp') was already read by the caller.\n**\n** assignment -> suffixedexp restassign\n** restassign -> ',' suffixedexp restassign | '=' explist\n*/\nstatic void restassign (LexState *ls, struct LHS_assign *lh, int nvars) {\n  expdesc e;\n  check_condition(ls, vkisvar(lh->v.k), \"syntax error\");\n  check_readonly(ls, &lh->v);\n  if (testnext(ls, ',')) {  /* restassign -> ',' suffixedexp restassign */\n    struct LHS_assign nv;\n    nv.prev = lh;\n    suffixedexp(ls, &nv.v);\n    if (!vkisindexed(nv.v.k))\n      check_conflict(ls, lh, &nv.v);\n    enterlevel(ls);  /* control recursion depth */\n    restassign(ls, &nv, nvars+1);\n    leavelevel(ls);\n  }\n  else {  /* restassign -> '=' explist */\n    int nexps;\n    checknext(ls, '=');\n    nexps = explist(ls, &e);\n    if (nexps != nvars)\n      adjust_assign(ls, nvars, nexps, &e);\n    else {\n      luaK_setoneret(ls->fs, &e);  /* close last expression */\n      luaK_storevar(ls->fs, &lh->v, &e);\n      return;  /* avoid default */\n    }\n  }\n  init_exp(&e, VNONRELOC, ls->fs->freereg-1);  /* default assignment */\n  luaK_storevar(ls->fs, &lh->v, &e);\n}\n\n\nstatic int cond (LexState *ls) {\n  /* cond -> exp */\n  expdesc v;\n  expr(ls, &v);  /* read condition */\n  if (v.k == VNIL) v.k = VFALSE;  /* 'falses' are all equal here */\n  luaK_goiftrue(ls->fs, &v);\n  return v.f;\n}\n\n\nstatic void gotostat (LexState *ls) {\n  FuncState *fs = ls->fs;\n  int line = ls->linenumber;\n  TString *name = str_checkname(ls);  /* label's name */\n  Labeldesc *lb = findlabel(ls, name);\n  if (lb == NULL)  /* no label? */\n    /* forward jump; will be resolved when the label is declared */\n    newgotoentry(ls, name, line, luaK_jump(fs));\n  else {  /* found a label */\n    /* backward jump; will be resolved here */\n    int lblevel = reglevel(fs, lb->nactvar);  /* label level */\n    if (luaY_nvarstack(fs) > lblevel)  /* leaving the scope of a variable? */\n      luaK_codeABC(fs, OP_CLOSE, lblevel, 0, 0);\n    /* create jump and link it to the label */\n    luaK_patchlist(fs, luaK_jump(fs), lb->pc);\n  }\n}\n\n\n/*\n** Break statement. Semantically equivalent to \"goto break\".\n*/\nstatic void breakstat (LexState *ls) {\n  int line = ls->linenumber;\n  luaX_next(ls);  /* skip break */\n  newgotoentry(ls, luaS_newliteral(ls->L, \"break\"), line, luaK_jump(ls->fs));\n}\n\n\n/*\n** Check whether there is already a label with the given 'name'.\n*/\nstatic void checkrepeated (LexState *ls, TString *name) {\n  Labeldesc *lb = findlabel(ls, name);\n  if (l_unlikely(lb != NULL)) {  /* already defined? */\n    const char *msg = \"label '%s' already defined on line %d\";\n    msg = luaO_pushfstring(ls->L, msg, getstr(name), lb->line);\n    luaK_semerror(ls, msg);  /* error */\n  }\n}\n\n\nstatic void labelstat (LexState *ls, TString *name, int line) {\n  /* label -> '::' NAME '::' */\n  checknext(ls, TK_DBCOLON);  /* skip double colon */\n  while (ls->t.token == ';' || ls->t.token == TK_DBCOLON)\n    statement(ls);  /* skip other no-op statements */\n  checkrepeated(ls, name);  /* check for repeated labels */\n  createlabel(ls, name, line, block_follow(ls, 0));\n}\n\n\nstatic void whilestat (LexState *ls, int line) {\n  /* whilestat -> WHILE cond DO block END */\n  FuncState *fs = ls->fs;\n  int whileinit;\n  int condexit;\n  BlockCnt bl;\n  luaX_next(ls);  /* skip WHILE */\n  whileinit = luaK_getlabel(fs);\n  condexit = cond(ls);\n  enterblock(fs, &bl, 1);\n  checknext(ls, TK_DO);\n  block(ls);\n  luaK_jumpto(fs, whileinit);\n  check_match(ls, TK_END, TK_WHILE, line);\n  leaveblock(fs);\n  luaK_patchtohere(fs, condexit);  /* false conditions finish the loop */\n}\n\n\nstatic void repeatstat (LexState *ls, int line) {\n  /* repeatstat -> REPEAT block UNTIL cond */\n  int condexit;\n  FuncState *fs = ls->fs;\n  int repeat_init = luaK_getlabel(fs);\n  BlockCnt bl1, bl2;\n  enterblock(fs, &bl1, 1);  /* loop block */\n  enterblock(fs, &bl2, 0);  /* scope block */\n  luaX_next(ls);  /* skip REPEAT */\n  statlist(ls);\n  check_match(ls, TK_UNTIL, TK_REPEAT, line);\n  condexit = cond(ls);  /* read condition (inside scope block) */\n  leaveblock(fs);  /* finish scope */\n  if (bl2.upval) {  /* upvalues? */\n    int exit = luaK_jump(fs);  /* normal exit must jump over fix */\n    luaK_patchtohere(fs, condexit);  /* repetition must close upvalues */\n    luaK_codeABC(fs, OP_CLOSE, reglevel(fs, bl2.nactvar), 0, 0);\n    condexit = luaK_jump(fs);  /* repeat after closing upvalues */\n    luaK_patchtohere(fs, exit);  /* normal exit comes to here */\n  }\n  luaK_patchlist(fs, condexit, repeat_init);  /* close the loop */\n  leaveblock(fs);  /* finish loop */\n}\n\n\n/*\n** Read an expression and generate code to put its results in next\n** stack slot.\n**\n*/\nstatic void exp1 (LexState *ls) {\n  expdesc e;\n  expr(ls, &e);\n  luaK_exp2nextreg(ls->fs, &e);\n  lua_assert(e.k == VNONRELOC);\n}\n\n\n/*\n** Fix for instruction at position 'pc' to jump to 'dest'.\n** (Jump addresses are relative in Lua). 'back' true means\n** a back jump.\n*/\nstatic void fixforjump (FuncState *fs, int pc, int dest, int back) {\n  Instruction *jmp = &fs->f->code[pc];\n  int offset = dest - (pc + 1);\n  if (back)\n    offset = -offset;\n  if (l_unlikely(offset > MAXARG_Bx))\n    luaX_syntaxerror(fs->ls, \"control structure too long\");\n  SETARG_Bx(*jmp, offset);\n}\n\n\n/*\n** Generate code for a 'for' loop.\n*/\nstatic void forbody (LexState *ls, int base, int line, int nvars, int isgen) {\n  /* forbody -> DO block */\n  static const OpCode forprep[2] = {OP_FORPREP, OP_TFORPREP};\n  static const OpCode forloop[2] = {OP_FORLOOP, OP_TFORLOOP};\n  BlockCnt bl;\n  FuncState *fs = ls->fs;\n  int prep, endfor;\n  checknext(ls, TK_DO);\n  prep = luaK_codeABx(fs, forprep[isgen], base, 0);\n  enterblock(fs, &bl, 0);  /* scope for declared variables */\n  adjustlocalvars(ls, nvars);\n  luaK_reserveregs(fs, nvars);\n  block(ls);\n  leaveblock(fs);  /* end of scope for declared variables */\n  fixforjump(fs, prep, luaK_getlabel(fs), 0);\n  if (isgen) {  /* generic for? */\n    luaK_codeABC(fs, OP_TFORCALL, base, 0, nvars);\n    luaK_fixline(fs, line);\n  }\n  endfor = luaK_codeABx(fs, forloop[isgen], base, 0);\n  fixforjump(fs, endfor, prep + 1, 1);\n  luaK_fixline(fs, line);\n}\n\n\nstatic void fornum (LexState *ls, TString *varname, int line) {\n  /* fornum -> NAME = exp,exp[,exp] forbody */\n  FuncState *fs = ls->fs;\n  int base = fs->freereg;\n  new_localvarliteral(ls, \"(for state)\");\n  new_localvarliteral(ls, \"(for state)\");\n  new_localvarliteral(ls, \"(for state)\");\n  new_localvar(ls, varname);\n  checknext(ls, '=');\n  exp1(ls);  /* initial value */\n  checknext(ls, ',');\n  exp1(ls);  /* limit */\n  if (testnext(ls, ','))\n    exp1(ls);  /* optional step */\n  else {  /* default step = 1 */\n    luaK_int(fs, fs->freereg, 1);\n    luaK_reserveregs(fs, 1);\n  }\n  adjustlocalvars(ls, 3);  /* control variables */\n  forbody(ls, base, line, 1, 0);\n}\n\n\nstatic void forlist (LexState *ls, TString *indexname) {\n  /* forlist -> NAME {,NAME} IN explist forbody */\n  FuncState *fs = ls->fs;\n  expdesc e;\n  int nvars = 5;  /* gen, state, control, toclose, 'indexname' */\n  int line;\n  int base = fs->freereg;\n  /* create control variables */\n  new_localvarliteral(ls, \"(for state)\");\n  new_localvarliteral(ls, \"(for state)\");\n  new_localvarliteral(ls, \"(for state)\");\n  new_localvarliteral(ls, \"(for state)\");\n  /* create declared variables */\n  new_localvar(ls, indexname);\n  while (testnext(ls, ',')) {\n    new_localvar(ls, str_checkname(ls));\n    nvars++;\n  }\n  checknext(ls, TK_IN);\n  line = ls->linenumber;\n  adjust_assign(ls, 4, explist(ls, &e), &e);\n  adjustlocalvars(ls, 4);  /* control variables */\n  marktobeclosed(fs);  /* last control var. must be closed */\n  luaK_checkstack(fs, 3);  /* extra space to call generator */\n  forbody(ls, base, line, nvars - 4, 1);\n}\n\n\nstatic void forstat (LexState *ls, int line) {\n  /* forstat -> FOR (fornum | forlist) END */\n  FuncState *fs = ls->fs;\n  TString *varname;\n  BlockCnt bl;\n  enterblock(fs, &bl, 1);  /* scope for loop and control variables */\n  luaX_next(ls);  /* skip 'for' */\n  varname = str_checkname(ls);  /* first variable name */\n  switch (ls->t.token) {\n    case '=': fornum(ls, varname, line); break;\n    case ',': case TK_IN: forlist(ls, varname); break;\n    default: luaX_syntaxerror(ls, \"'=' or 'in' expected\");\n  }\n  check_match(ls, TK_END, TK_FOR, line);\n  leaveblock(fs);  /* loop scope ('break' jumps to this point) */\n}\n\n\nstatic void test_then_block (LexState *ls, int *escapelist) {\n  /* test_then_block -> [IF | ELSEIF] cond THEN block */\n  BlockCnt bl;\n  FuncState *fs = ls->fs;\n  expdesc v;\n  int jf;  /* instruction to skip 'then' code (if condition is false) */\n  luaX_next(ls);  /* skip IF or ELSEIF */\n  expr(ls, &v);  /* read condition */\n  checknext(ls, TK_THEN);\n  if (ls->t.token == TK_BREAK) {  /* 'if x then break' ? */\n    int line = ls->linenumber;\n    luaK_goiffalse(ls->fs, &v);  /* will jump if condition is true */\n    luaX_next(ls);  /* skip 'break' */\n    enterblock(fs, &bl, 0);  /* must enter block before 'goto' */\n    newgotoentry(ls, luaS_newliteral(ls->L, \"break\"), line, v.t);\n    while (testnext(ls, ';')) {}  /* skip semicolons */\n    if (block_follow(ls, 0)) {  /* jump is the entire block? */\n      leaveblock(fs);\n      return;  /* and that is it */\n    }\n    else  /* must skip over 'then' part if condition is false */\n      jf = luaK_jump(fs);\n  }\n  else {  /* regular case (not a break) */\n    luaK_goiftrue(ls->fs, &v);  /* skip over block if condition is false */\n    enterblock(fs, &bl, 0);\n    jf = v.f;\n  }\n  statlist(ls);  /* 'then' part */\n  leaveblock(fs);\n  if (ls->t.token == TK_ELSE ||\n      ls->t.token == TK_ELSEIF)  /* followed by 'else'/'elseif'? */\n    luaK_concat(fs, escapelist, luaK_jump(fs));  /* must jump over it */\n  luaK_patchtohere(fs, jf);\n}\n\n\nstatic void ifstat (LexState *ls, int line) {\n  /* ifstat -> IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END */\n  FuncState *fs = ls->fs;\n  int escapelist = NO_JUMP;  /* exit list for finished parts */\n  test_then_block(ls, &escapelist);  /* IF cond THEN block */\n  while (ls->t.token == TK_ELSEIF)\n    test_then_block(ls, &escapelist);  /* ELSEIF cond THEN block */\n  if (testnext(ls, TK_ELSE))\n    block(ls);  /* 'else' part */\n  check_match(ls, TK_END, TK_IF, line);\n  luaK_patchtohere(fs, escapelist);  /* patch escape list to 'if' end */\n}\n\n\nstatic void localfunc (LexState *ls) {\n  expdesc b;\n  FuncState *fs = ls->fs;\n  int fvar = fs->nactvar;  /* function's variable index */\n  new_localvar(ls, str_checkname(ls));  /* new local variable */\n  adjustlocalvars(ls, 1);  /* enter its scope */\n  body(ls, &b, 0, ls->linenumber);  /* function created in next register */\n  /* debug information will only see the variable after this point! */\n  localdebuginfo(fs, fvar)->startpc = fs->pc;\n}\n\n\nstatic int getlocalattribute (LexState *ls) {\n  /* ATTRIB -> ['<' Name '>'] */\n  if (testnext(ls, '<')) {\n    const char *attr = getstr(str_checkname(ls));\n    checknext(ls, '>');\n    if (strcmp(attr, \"const\") == 0)\n      return RDKCONST;  /* read-only variable */\n    else if (strcmp(attr, \"close\") == 0)\n      return RDKTOCLOSE;  /* to-be-closed variable */\n    else\n      luaK_semerror(ls,\n        luaO_pushfstring(ls->L, \"unknown attribute '%s'\", attr));\n  }\n  return VDKREG;  /* regular variable */\n}\n\n\nstatic void checktoclose (FuncState *fs, int level) {\n  if (level != -1) {  /* is there a to-be-closed variable? */\n    marktobeclosed(fs);\n    luaK_codeABC(fs, OP_TBC, reglevel(fs, level), 0, 0);\n  }\n}\n\n\nstatic void localstat (LexState *ls) {\n  /* stat -> LOCAL NAME ATTRIB { ',' NAME ATTRIB } ['=' explist] */\n  FuncState *fs = ls->fs;\n  int toclose = -1;  /* index of to-be-closed variable (if any) */\n  Vardesc *var;  /* last variable */\n  int vidx, kind;  /* index and kind of last variable */\n  int nvars = 0;\n  int nexps;\n  expdesc e;\n  do {\n    vidx = new_localvar(ls, str_checkname(ls));\n    kind = getlocalattribute(ls);\n    getlocalvardesc(fs, vidx)->vd.kind = kind;\n    if (kind == RDKTOCLOSE) {  /* to-be-closed? */\n      if (toclose != -1)  /* one already present? */\n        luaK_semerror(ls, \"multiple to-be-closed variables in local list\");\n      toclose = fs->nactvar + nvars;\n    }\n    nvars++;\n  } while (testnext(ls, ','));\n  if (testnext(ls, '='))\n    nexps = explist(ls, &e);\n  else {\n    e.k = VVOID;\n    nexps = 0;\n  }\n  var = getlocalvardesc(fs, vidx);  /* get last variable */\n  if (nvars == nexps &&  /* no adjustments? */\n      var->vd.kind == RDKCONST &&  /* last variable is const? */\n      luaK_exp2const(fs, &e, &var->k)) {  /* compile-time constant? */\n    var->vd.kind = RDKCTC;  /* variable is a compile-time constant */\n    adjustlocalvars(ls, nvars - 1);  /* exclude last variable */\n    fs->nactvar++;  /* but count it */\n  }\n  else {\n    adjust_assign(ls, nvars, nexps, &e);\n    adjustlocalvars(ls, nvars);\n  }\n  checktoclose(fs, toclose);\n}\n\n\nstatic int funcname (LexState *ls, expdesc *v) {\n  /* funcname -> NAME {fieldsel} [':' NAME] */\n  int ismethod = 0;\n  singlevar(ls, v);\n  while (ls->t.token == '.')\n    fieldsel(ls, v);\n  if (ls->t.token == ':') {\n    ismethod = 1;\n    fieldsel(ls, v);\n  }\n  return ismethod;\n}\n\n\nstatic void funcstat (LexState *ls, int line) {\n  /* funcstat -> FUNCTION funcname body */\n  int ismethod;\n  expdesc v, b;\n  luaX_next(ls);  /* skip FUNCTION */\n  ismethod = funcname(ls, &v);\n  body(ls, &b, ismethod, line);\n  check_readonly(ls, &v);\n  luaK_storevar(ls->fs, &v, &b);\n  luaK_fixline(ls->fs, line);  /* definition \"happens\" in the first line */\n}\n\n\nstatic void exprstat (LexState *ls) {\n  /* stat -> func | assignment */\n  FuncState *fs = ls->fs;\n  struct LHS_assign v;\n  suffixedexp(ls, &v.v);\n  if (ls->t.token == '=' || ls->t.token == ',') { /* stat -> assignment ? */\n    v.prev = NULL;\n    restassign(ls, &v, 1);\n  }\n  else {  /* stat -> func */\n    Instruction *inst;\n    check_condition(ls, v.v.k == VCALL, \"syntax error\");\n    inst = &getinstruction(fs, &v.v);\n    SETARG_C(*inst, 1);  /* call statement uses no results */\n  }\n}\n\n\nstatic void retstat (LexState *ls) {\n  /* stat -> RETURN [explist] [';'] */\n  FuncState *fs = ls->fs;\n  expdesc e;\n  int nret;  /* number of values being returned */\n  int first = luaY_nvarstack(fs);  /* first slot to be returned */\n  if (block_follow(ls, 1) || ls->t.token == ';')\n    nret = 0;  /* return no values */\n  else {\n    nret = explist(ls, &e);  /* optional return values */\n    if (hasmultret(e.k)) {\n      luaK_setmultret(fs, &e);\n      if (e.k == VCALL && nret == 1 && !fs->bl->insidetbc) {  /* tail call? */\n        SET_OPCODE(getinstruction(fs,&e), OP_TAILCALL);\n        lua_assert(GETARG_A(getinstruction(fs,&e)) == luaY_nvarstack(fs));\n      }\n      nret = LUA_MULTRET;  /* return all values */\n    }\n    else {\n      if (nret == 1)  /* only one single value? */\n        first = luaK_exp2anyreg(fs, &e);  /* can use original slot */\n      else {  /* values must go to the top of the stack */\n        luaK_exp2nextreg(fs, &e);\n        lua_assert(nret == fs->freereg - first);\n      }\n    }\n  }\n  luaK_ret(fs, first, nret);\n  testnext(ls, ';');  /* skip optional semicolon */\n}\n\n\nstatic void statement (LexState *ls) {\n  int line = ls->linenumber;  /* may be needed for error messages */\n  enterlevel(ls);\n  switch (ls->t.token) {\n    case ';': {  /* stat -> ';' (empty statement) */\n      luaX_next(ls);  /* skip ';' */\n      break;\n    }\n    case TK_IF: {  /* stat -> ifstat */\n      ifstat(ls, line);\n      break;\n    }\n    case TK_WHILE: {  /* stat -> whilestat */\n      whilestat(ls, line);\n      break;\n    }\n    case TK_DO: {  /* stat -> DO block END */\n      luaX_next(ls);  /* skip DO */\n      block(ls);\n      check_match(ls, TK_END, TK_DO, line);\n      break;\n    }\n    case TK_FOR: {  /* stat -> forstat */\n      forstat(ls, line);\n      break;\n    }\n    case TK_REPEAT: {  /* stat -> repeatstat */\n      repeatstat(ls, line);\n      break;\n    }\n    case TK_FUNCTION: {  /* stat -> funcstat */\n      funcstat(ls, line);\n      break;\n    }\n    case TK_LOCAL: {  /* stat -> localstat */\n      luaX_next(ls);  /* skip LOCAL */\n      if (testnext(ls, TK_FUNCTION))  /* local function? */\n        localfunc(ls);\n      else\n        localstat(ls);\n      break;\n    }\n    case TK_DBCOLON: {  /* stat -> label */\n      luaX_next(ls);  /* skip double colon */\n      labelstat(ls, str_checkname(ls), line);\n      break;\n    }\n    case TK_RETURN: {  /* stat -> retstat */\n      luaX_next(ls);  /* skip RETURN */\n      retstat(ls);\n      break;\n    }\n    case TK_BREAK: {  /* stat -> breakstat */\n      breakstat(ls);\n      break;\n    }\n    case TK_GOTO: {  /* stat -> 'goto' NAME */\n      luaX_next(ls);  /* skip 'goto' */\n      gotostat(ls);\n      break;\n    }\n    default: {  /* stat -> func | assignment */\n      exprstat(ls);\n      break;\n    }\n  }\n  lua_assert(ls->fs->f->maxstacksize >= ls->fs->freereg &&\n             ls->fs->freereg >= luaY_nvarstack(ls->fs));\n  ls->fs->freereg = luaY_nvarstack(ls->fs);  /* free registers */\n  leavelevel(ls);\n}\n\n/* }====================================================================== */\n\n\n/*\n** compiles the main function, which is a regular vararg function with an\n** upvalue named LUA_ENV\n*/\nstatic void mainfunc (LexState *ls, FuncState *fs) {\n  BlockCnt bl;\n  Upvaldesc *env;\n  open_func(ls, fs, &bl);\n  setvararg(fs, 0);  /* main function is always declared vararg */\n  env = allocupvalue(fs);  /* ...set environment upvalue */\n  env->instack = 1;\n  env->idx = 0;\n  env->kind = VDKREG;\n  env->name = ls->envn;\n  luaC_objbarrier(ls->L, fs->f, env->name);\n  luaX_next(ls);  /* read first token */\n  statlist(ls);  /* parse main body */\n  check(ls, TK_EOS);\n  close_func(ls);\n}\n\n\nLClosure *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff,\n                       Dyndata *dyd, const char *name, int firstchar) {\n  LexState lexstate;\n  FuncState funcstate;\n  LClosure *cl = luaF_newLclosure(L, 1);  /* create main closure */\n  setclLvalue2s(L, L->top, cl);  /* anchor it (to avoid being collected) */\n  luaD_inctop(L);\n  lexstate.h = luaH_new(L);  /* create table for scanner */\n  sethvalue2s(L, L->top, lexstate.h);  /* anchor it */\n  luaD_inctop(L);\n  funcstate.f = cl->p = luaF_newproto(L);\n  luaC_objbarrier(L, cl, cl->p);\n  funcstate.f->source = luaS_new(L, name);  /* create and anchor TString */\n  luaC_objbarrier(L, funcstate.f, funcstate.f->source);\n  lexstate.buff = buff;\n  lexstate.dyd = dyd;\n  dyd->actvar.n = dyd->gt.n = dyd->label.n = 0;\n  luaX_setinput(L, &lexstate, z, funcstate.f->source, firstchar);\n  mainfunc(&lexstate, &funcstate);\n  lua_assert(!funcstate.prev && funcstate.nups == 1 && !lexstate.fs);\n  /* all scopes should be correctly finished */\n  lua_assert(dyd->actvar.n == 0 && dyd->gt.n == 0 && dyd->label.n == 0);\n  L->top--;  /* remove scanner's table */\n  return cl;  /* closure is on the stack, too */\n}\n\n", "-- $Id: testes/attrib.lua $\n-- See Copyright Notice in file all.lua\n\nprint \"testing require\"\n\nassert(require\"string\" == string)\nassert(require\"math\" == math)\nassert(require\"table\" == table)\nassert(require\"io\" == io)\nassert(require\"os\" == os)\nassert(require\"coroutine\" == coroutine)\n\nassert(type(package.path) == \"string\")\nassert(type(package.cpath) == \"string\")\nassert(type(package.loaded) == \"table\")\nassert(type(package.preload) == \"table\")\n\nassert(type(package.config) == \"string\")\nprint(\"package config: \"..string.gsub(package.config, \"\\n\", \"|\"))\n\ndo\n  -- create a path with 'max' templates,\n  -- each with 1-10 repetitions of '?'\n  local max = _soft and 100 or 2000\n  local t = {}\n  for i = 1,max do t[i] = string.rep(\"?\", i%10 + 1) end\n  t[#t + 1] = \";\"    -- empty template\n  local path = table.concat(t, \";\")\n  -- use that path in a search\n  local s, err = package.searchpath(\"xuxu\", path)\n  -- search fails; check that message has an occurrence of\n  -- '??????????' with ? replaced by xuxu and at least 'max' lines\n  assert(not s and\n         string.find(err, string.rep(\"xuxu\", 10)) and\n         #string.gsub(err, \"[^\\n]\", \"\") >= max)\n  -- path with one very long template\n  local path = string.rep(\"?\", max)\n  local s, err = package.searchpath(\"xuxu\", path)\n  assert(not s and string.find(err, string.rep('xuxu', max)))\nend\n\ndo\n  local oldpath = package.path\n  package.path = {}\n  local s, err = pcall(require, \"no-such-file\")\n  assert(not s and string.find(err, \"package.path\"))\n  package.path = oldpath\nend\n\n\ndo  print\"testing 'require' message\"\n  local oldpath = package.path\n  local oldcpath = package.cpath\n\n  package.path = \"?.lua;?/?\"\n  package.cpath = \"?.so;?/init\"\n\n  local st, msg = pcall(require, 'XXX')\n\n  local expected = [[module 'XXX' not found:\n\tno field package.preload['XXX']\n\tno file 'XXX.lua'\n\tno file 'XXX/XXX'\n\tno file 'XXX.so'\n\tno file 'XXX/init']]\n\n  assert(msg == expected)\n\n  package.path = oldpath\n  package.cpath = oldcpath\nend\n\nprint('+')\n\n\n-- The next tests for 'require' assume some specific directories and\n-- libraries.\n\nif not _port then --[\n\nlocal dirsep = string.match(package.config, \"^([^\\n]+)\\n\")\n\n-- auxiliary directory with C modules and temporary files\nlocal DIR = \"libs\" .. dirsep\n\n-- prepend DIR to a name and correct directory separators\nlocal function D (x)\n  x = string.gsub(x, \"/\", dirsep)\n  return DIR .. x\nend\n\n-- prepend DIR and pospend proper C lib. extension to a name\nlocal function DC (x)\n  local ext = (dirsep == '\\\\') and \".dll\" or \".so\"\n  return D(x .. ext)\nend\n\n\nlocal function createfiles (files, preextras, posextras)\n  for n,c in pairs(files) do\n    io.output(D(n))\n    io.write(string.format(preextras, n))\n    io.write(c)\n    io.write(string.format(posextras, n))\n    io.close(io.output())\n  end\nend\n\nfunction removefiles (files)\n  for n in pairs(files) do\n    os.remove(D(n))\n  end\nend\n\nlocal files = {\n  [\"names.lua\"] = \"do return {...} end\\n\",\n  [\"err.lua\"] = \"B = 15; a = a + 1;\",\n  [\"synerr.lua\"] = \"B =\",\n  [\"A.lua\"] = \"\",\n  [\"B.lua\"] = \"assert(...=='B');require 'A'\",\n  [\"A.lc\"] = \"\",\n  [\"A\"] = \"\",\n  [\"L\"] = \"\",\n  [\"XXxX\"] = \"\",\n  [\"C.lua\"] = \"package.loaded[...] = 25; require'C'\",\n}\n\nAA = nil\nlocal extras = [[\nNAME = '%s'\nREQUIRED = ...\nreturn AA]]\n\ncreatefiles(files, \"\", extras)\n\n-- testing explicit \"dir\" separator in 'searchpath'\nassert(package.searchpath(\"C.lua\", D\"?\", \"\", \"\") == D\"C.lua\")\nassert(package.searchpath(\"C.lua\", D\"?\", \".\", \".\") == D\"C.lua\")\nassert(package.searchpath(\"--x-\", D\"?\", \"-\", \"X\") == D\"XXxX\")\nassert(package.searchpath(\"---xX\", D\"?\", \"---\", \"XX\") == D\"XXxX\")\nassert(package.searchpath(D\"C.lua\", \"?\", dirsep) == D\"C.lua\")\nassert(package.searchpath(\".\\\\C.lua\", D\"?\", \"\\\\\") == D\"./C.lua\")\n\nlocal oldpath = package.path\n\npackage.path = string.gsub(\"D/?.lua;D/?.lc;D/?;D/??x?;D/L\", \"D/\", DIR)\n\nlocal try = function (p, n, r, ext)\n  NAME = nil\n  local rr, x = require(p)\n  assert(NAME == n)\n  assert(REQUIRED == p)\n  assert(rr == r)\n  assert(ext == x)\nend\n\na = require\"names\"\nassert(a[1] == \"names\" and a[2] == D\"names.lua\")\n\n_G.a = nil\nlocal st, msg = pcall(require, \"err\")\nassert(not st and string.find(msg, \"arithmetic\") and B == 15)\nst, msg = pcall(require, \"synerr\")\nassert(not st and string.find(msg, \"error loading module\"))\n\nassert(package.searchpath(\"C\", package.path) == D\"C.lua\")\nassert(require\"C\" == 25)\nassert(require\"C\" == 25)\nAA = nil\ntry('B', 'B.lua', true, \"libs/B.lua\")\nassert(package.loaded.B)\nassert(require\"B\" == true)\nassert(package.loaded.A)\nassert(require\"C\" == 25)\npackage.loaded.A = nil\ntry('B', nil, true, nil)   -- should not reload package\ntry('A', 'A.lua', true, \"libs/A.lua\")\npackage.loaded.A = nil\nos.remove(D'A.lua')\nAA = {}\ntry('A', 'A.lc', AA, \"libs/A.lc\")  -- now must find second option\nassert(package.searchpath(\"A\", package.path) == D\"A.lc\")\nassert(require(\"A\") == AA)\nAA = false\ntry('K', 'L', false, \"libs/L\")     -- default option\ntry('K', 'L', false, \"libs/L\")     -- default option (should reload it)\nassert(rawget(_G, \"_REQUIREDNAME\") == nil)\n\nAA = \"x\"\ntry(\"X\", \"XXxX\", AA, \"libs/XXxX\")\n\n\nremovefiles(files)\n\n\n-- testing require of sub-packages\n\nlocal _G = _G\n\npackage.path = string.gsub(\"D/?.lua;D/?/init.lua\", \"D/\", DIR)\n\nfiles = {\n  [\"P1/init.lua\"] = \"AA = 10\",\n  [\"P1/xuxu.lua\"] = \"AA = 20\",\n}\n\ncreatefiles(files, \"_ENV = {}\\n\", \"\\nreturn _ENV\\n\")\nAA = 0\n\nlocal m, ext = assert(require\"P1\")\nassert(ext == \"libs/P1/init.lua\")\nassert(AA == 0 and m.AA == 10)\nassert(require\"P1\" == m)\nassert(require\"P1\" == m)\n\nassert(package.searchpath(\"P1.xuxu\", package.path) == D\"P1/xuxu.lua\")\nm.xuxu, ext = assert(require\"P1.xuxu\")\nassert(AA == 0 and m.xuxu.AA == 20)\nassert(ext == \"libs/P1/xuxu.lua\")\nassert(require\"P1.xuxu\" == m.xuxu)\nassert(require\"P1.xuxu\" == m.xuxu)\nassert(require\"P1\" == m and m.AA == 10)\n\n\nremovefiles(files)\n\n\npackage.path = \"\"\nassert(not pcall(require, \"file_does_not_exist\"))\npackage.path = \"??\\0?\"\nassert(not pcall(require, \"file_does_not_exist1\"))\n\npackage.path = oldpath\n\n-- check 'require' error message\nlocal fname = \"file_does_not_exist2\"\nlocal m, err = pcall(require, fname)\nfor t in string.gmatch(package.path..\";\"..package.cpath, \"[^;]+\") do\n  t = string.gsub(t, \"?\", fname)\n  assert(string.find(err, t, 1, true))\nend\n\ndo  -- testing 'package.searchers' not being a table\n  local searchers = package.searchers\n  package.searchers = 3\n  local st, msg = pcall(require, 'a')\n  assert(not st and string.find(msg, \"must be a table\"))\n  package.searchers = searchers\nend\n\nlocal function import(...)\n  local f = {...}\n  return function (m)\n    for i=1, #f do m[f[i]] = _G[f[i]] end\n  end\nend\n\n-- cannot change environment of a C function\nassert(not pcall(module, 'XUXU'))\n\n\n\n-- testing require of C libraries\n\n\nlocal p = \"\"   -- On Mac OS X, redefine this to \"_\"\n\n-- check whether loadlib works in this system\nlocal st, err, when = package.loadlib(DC\"lib1\", \"*\")\nif not st then\n  local f, err, when = package.loadlib(\"donotexist\", p..\"xuxu\")\n  assert(not f and type(err) == \"string\" and when == \"absent\")\n  ;(Message or print)('\\n >>> cannot load dynamic library <<<\\n')\n  print(err, when)\nelse\n  -- tests for loadlib\n  local f = assert(package.loadlib(DC\"lib1\", p..\"onefunction\"))\n  local a, b = f(15, 25)\n  assert(a == 25 and b == 15)\n\n  f = assert(package.loadlib(DC\"lib1\", p..\"anotherfunc\"))\n  assert(f(10, 20) == \"10%20\\n\")\n\n  -- check error messages\n  local f, err, when = package.loadlib(DC\"lib1\", p..\"xuxu\")\n  assert(not f and type(err) == \"string\" and when == \"init\")\n  f, err, when = package.loadlib(\"donotexist\", p..\"xuxu\")\n  assert(not f and type(err) == \"string\" and when == \"open\")\n\n  -- symbols from 'lib1' must be visible to other libraries\n  f = assert(package.loadlib(DC\"lib11\", p..\"luaopen_lib11\"))\n  assert(f() == \"exported\")\n\n  -- test C modules with prefixes in names\n  package.cpath = DC\"?\"\n  local lib2, ext = require\"lib2-v2\"\n  assert(string.find(ext, \"libs/lib2-v2\", 1, true))\n  -- check correct access to global environment and correct\n  -- parameters\n  assert(_ENV.x == \"lib2-v2\" and _ENV.y == DC\"lib2-v2\")\n  assert(lib2.id(\"x\") == true)   -- a different \"id\" implementation\n\n  -- test C submodules\n  local fs, ext = require\"lib1.sub\"\n  assert(_ENV.x == \"lib1.sub\" and _ENV.y == DC\"lib1\")\n  assert(string.find(ext, \"libs/lib1\", 1, true))\n  assert(fs.id(45) == 45)\nend\n\n_ENV = _G\n\n\n-- testing preload\n\ndo\n  local p = package\n  package = {}\n  p.preload.pl = function (...)\n    local _ENV = {...}\n    function xuxu (x) return x+20 end\n    return _ENV\n  end\n\n  local pl, ext = require\"pl\"\n  assert(require\"pl\" == pl)\n  assert(pl.xuxu(10) == 30)\n  assert(pl[1] == \"pl\" and pl[2] == \":preload:\" and ext == \":preload:\")\n\n  package = p\n  assert(type(package.path) == \"string\")\nend\n\nprint('+')\n\nend  --]\n\nprint(\"testing assignments, logical operators, and constructors\")\n\nlocal res, res2 = 27\n\na, b = 1, 2+3\nassert(a==1 and b==5)\na={}\nfunction f() return 10, 11, 12 end\na.x, b, a[1] = 1, 2, f()\nassert(a.x==1 and b==2 and a[1]==10)\na[f()], b, a[f()+3] = f(), a, 'x'\nassert(a[10] == 10 and b == a and a[13] == 'x')\n\ndo\n  local f = function (n) local x = {}; for i=1,n do x[i]=i end;\n                         return table.unpack(x) end;\n  local a,b,c\n  a,b = 0, f(1)\n  assert(a == 0 and b == 1)\n  A,b = 0, f(1)\n  assert(A == 0 and b == 1)\n  a,b,c = 0,5,f(4)\n  assert(a==0 and b==5 and c==1)\n  a,b,c = 0,5,f(0)\n  assert(a==0 and b==5 and c==nil)\nend\n\na, b, c, d = 1 and nil, 1 or nil, (1 and (nil or 1)), 6\nassert(not a and b and c and d==6)\n\nd = 20\na, b, c, d = f()\nassert(a==10 and b==11 and c==12 and d==nil)\na,b = f(), 1, 2, 3, f()\nassert(a==10 and b==1)\n\nassert(a<b == false and a>b == true)\nassert((10 and 2) == 2)\nassert((10 or 2) == 10)\nassert((10 or assert(nil)) == 10)\nassert(not (nil and assert(nil)))\nassert((nil or \"alo\") == \"alo\")\nassert((nil and 10) == nil)\nassert((false and 10) == false)\nassert((true or 10) == true)\nassert((false or 10) == 10)\nassert(false ~= nil)\nassert(nil ~= false)\nassert(not nil == true)\nassert(not not nil == false)\nassert(not not 1 == true)\nassert(not not a == true)\nassert(not not (6 or nil) == true)\nassert(not not (nil and 56) == false)\nassert(not not (nil and true) == false)\nassert(not 10 == false)\nassert(not {} == false)\nassert(not 0.5 == false)\nassert(not \"x\" == false)\n\nassert({} ~= {})\nprint('+')\n\na = {}\na[true] = 20\na[false] = 10\nassert(a[1<2] == 20 and a[1>2] == 10)\n\nfunction f(a) return a end\n\nlocal a = {}\nfor i=3000,-3000,-1 do a[i + 0.0] = i; end\na[10e30] = \"alo\"; a[true] = 10; a[false] = 20\nassert(a[10e30] == 'alo' and a[not 1] == 20 and a[10<20] == 10)\nfor i=3000,-3000,-1 do assert(a[i] == i); end\na[print] = assert\na[f] = print\na[a] = a\nassert(a[a][a][a][a][print] == assert)\na[print](a[a[f]] == a[print])\nassert(not pcall(function () local a = {}; a[nil] = 10 end))\nassert(not pcall(function () local a = {[nil] = 10} end))\nassert(a[nil] == undef)\na = nil\n\na = {10,9,8,7,6,5,4,3,2; [-3]='a', [f]=print, a='a', b='ab'}\na, a.x, a.y = a, a[-3]\nassert(a[1]==10 and a[-3]==a.a and a[f]==print and a.x=='a' and not a.y)\na[1], f(a)[2], b, c = {['alo']=assert}, 10, a[1], a[f], 6, 10, 23, f(a), 2\na[1].alo(a[2]==10 and b==10 and c==print)\n\na.aVeryLongName012345678901234567890123456789012345678901234567890123456789 = 10\nlocal function foo ()\n  return a.aVeryLongName012345678901234567890123456789012345678901234567890123456789\nend\nassert(foo() == 10 and\na.aVeryLongName012345678901234567890123456789012345678901234567890123456789 ==\n10)\n\n\n\n-- test of large float/integer indices \n\n-- compute maximum integer where all bits fit in a float\nlocal maxint = math.maxinteger\n\n-- trim (if needed) to fit in a float\nwhile maxint ~= (maxint + 0.0) or (maxint - 1) ~= (maxint - 1.0) do\n  maxint = maxint // 2\nend\n\nmaxintF = maxint + 0.0   -- float version\n\nassert(maxintF == maxint and math.type(maxintF) == \"float\" and\n       maxintF >= 2.0^14)\n\n-- floats and integers must index the same places\na[maxintF] = 10; a[maxintF - 1.0] = 11;\na[-maxintF] = 12; a[-maxintF + 1.0] = 13;\n\nassert(a[maxint] == 10 and a[maxint - 1] == 11 and\n       a[-maxint] == 12 and a[-maxint + 1] == 13)\n\na[maxint] = 20\na[-maxint] = 22\n\nassert(a[maxintF] == 20 and a[maxintF - 1.0] == 11 and\n       a[-maxintF] == 22 and a[-maxintF + 1.0] == 13)\n\na = nil\n\n\n-- test conflicts in multiple assignment\ndo\n  local a,i,j,b\n  a = {'a', 'b'}; i=1; j=2; b=a\n  i, a[i], a, j, a[j], a[i+j] = j, i, i, b, j, i\n  assert(i == 2 and b[1] == 1 and a == 1 and j == b and b[2] == 2 and\n         b[3] == 1)\n  a = {}\n  local function foo ()    -- assigining to upvalues\n    b, a.x, a = a, 10, 20\n  end\n  foo()\n  assert(a == 20 and b.x == 10)\nend\n\n-- repeat test with upvalues\ndo\n  local a,i,j,b\n  a = {'a', 'b'}; i=1; j=2; b=a\n  local function foo ()\n    i, a[i], a, j, a[j], a[i+j] = j, i, i, b, j, i\n  end\n  foo()\n  assert(i == 2 and b[1] == 1 and a == 1 and j == b and b[2] == 2 and\n         b[3] == 1)\n  local t = {}\n  (function (a) t[a], a = 10, 20  end)(1);\n  assert(t[1] == 10)\nend\n\n-- bug in 5.2 beta\nlocal function foo ()\n  local a\n  return function ()\n    local b\n    a, b = 3, 14    -- local and upvalue have same index\n    return a, b\n  end\nend\n\nlocal a, b = foo()()\nassert(a == 3 and b == 14)\n\nprint('OK')\n\nreturn res\n\n"], "fixing_code": ["/*\n** $Id: lparser.c $\n** Lua Parser\n** See Copyright Notice in lua.h\n*/\n\n#define lparser_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n#include <limits.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"lcode.h\"\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"llex.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lopcodes.h\"\n#include \"lparser.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n\n\n\n/* maximum number of local variables per function (must be smaller\n   than 250, due to the bytecode format) */\n#define MAXVARS\t\t200\n\n\n#define hasmultret(k)\t\t((k) == VCALL || (k) == VVARARG)\n\n\n/* because all strings are unified by the scanner, the parser\n   can use pointer equality for string equality */\n#define eqstr(a,b)\t((a) == (b))\n\n\n/*\n** nodes for block list (list of active blocks)\n*/\ntypedef struct BlockCnt {\n  struct BlockCnt *previous;  /* chain */\n  int firstlabel;  /* index of first label in this block */\n  int firstgoto;  /* index of first pending goto in this block */\n  lu_byte nactvar;  /* # active locals outside the block */\n  lu_byte upval;  /* true if some variable in the block is an upvalue */\n  lu_byte isloop;  /* true if 'block' is a loop */\n  lu_byte insidetbc;  /* true if inside the scope of a to-be-closed var. */\n} BlockCnt;\n\n\n\n/*\n** prototypes for recursive non-terminal functions\n*/\nstatic void statement (LexState *ls);\nstatic void expr (LexState *ls, expdesc *v);\n\n\nstatic l_noret error_expected (LexState *ls, int token) {\n  luaX_syntaxerror(ls,\n      luaO_pushfstring(ls->L, \"%s expected\", luaX_token2str(ls, token)));\n}\n\n\nstatic l_noret errorlimit (FuncState *fs, int limit, const char *what) {\n  lua_State *L = fs->ls->L;\n  const char *msg;\n  int line = fs->f->linedefined;\n  const char *where = (line == 0)\n                      ? \"main function\"\n                      : luaO_pushfstring(L, \"function at line %d\", line);\n  msg = luaO_pushfstring(L, \"too many %s (limit is %d) in %s\",\n                             what, limit, where);\n  luaX_syntaxerror(fs->ls, msg);\n}\n\n\nstatic void checklimit (FuncState *fs, int v, int l, const char *what) {\n  if (v > l) errorlimit(fs, l, what);\n}\n\n\n/*\n** Test whether next token is 'c'; if so, skip it.\n*/\nstatic int testnext (LexState *ls, int c) {\n  if (ls->t.token == c) {\n    luaX_next(ls);\n    return 1;\n  }\n  else return 0;\n}\n\n\n/*\n** Check that next token is 'c'.\n*/\nstatic void check (LexState *ls, int c) {\n  if (ls->t.token != c)\n    error_expected(ls, c);\n}\n\n\n/*\n** Check that next token is 'c' and skip it.\n*/\nstatic void checknext (LexState *ls, int c) {\n  check(ls, c);\n  luaX_next(ls);\n}\n\n\n#define check_condition(ls,c,msg)\t{ if (!(c)) luaX_syntaxerror(ls, msg); }\n\n\n/*\n** Check that next token is 'what' and skip it. In case of error,\n** raise an error that the expected 'what' should match a 'who'\n** in line 'where' (if that is not the current line).\n*/\nstatic void check_match (LexState *ls, int what, int who, int where) {\n  if (l_unlikely(!testnext(ls, what))) {\n    if (where == ls->linenumber)  /* all in the same line? */\n      error_expected(ls, what);  /* do not need a complex message */\n    else {\n      luaX_syntaxerror(ls, luaO_pushfstring(ls->L,\n             \"%s expected (to close %s at line %d)\",\n              luaX_token2str(ls, what), luaX_token2str(ls, who), where));\n    }\n  }\n}\n\n\nstatic TString *str_checkname (LexState *ls) {\n  TString *ts;\n  check(ls, TK_NAME);\n  ts = ls->t.seminfo.ts;\n  luaX_next(ls);\n  return ts;\n}\n\n\nstatic void init_exp (expdesc *e, expkind k, int i) {\n  e->f = e->t = NO_JUMP;\n  e->k = k;\n  e->u.info = i;\n}\n\n\nstatic void codestring (expdesc *e, TString *s) {\n  e->f = e->t = NO_JUMP;\n  e->k = VKSTR;\n  e->u.strval = s;\n}\n\n\nstatic void codename (LexState *ls, expdesc *e) {\n  codestring(e, str_checkname(ls));\n}\n\n\n/*\n** Register a new local variable in the active 'Proto' (for debug\n** information).\n*/\nstatic int registerlocalvar (LexState *ls, FuncState *fs, TString *varname) {\n  Proto *f = fs->f;\n  int oldsize = f->sizelocvars;\n  luaM_growvector(ls->L, f->locvars, fs->ndebugvars, f->sizelocvars,\n                  LocVar, SHRT_MAX, \"local variables\");\n  while (oldsize < f->sizelocvars)\n    f->locvars[oldsize++].varname = NULL;\n  f->locvars[fs->ndebugvars].varname = varname;\n  f->locvars[fs->ndebugvars].startpc = fs->pc;\n  luaC_objbarrier(ls->L, f, varname);\n  return fs->ndebugvars++;\n}\n\n\n/*\n** Create a new local variable with the given 'name'. Return its index\n** in the function.\n*/\nstatic int new_localvar (LexState *ls, TString *name) {\n  lua_State *L = ls->L;\n  FuncState *fs = ls->fs;\n  Dyndata *dyd = ls->dyd;\n  Vardesc *var;\n  checklimit(fs, dyd->actvar.n + 1 - fs->firstlocal,\n                 MAXVARS, \"local variables\");\n  luaM_growvector(L, dyd->actvar.arr, dyd->actvar.n + 1,\n                  dyd->actvar.size, Vardesc, USHRT_MAX, \"local variables\");\n  var = &dyd->actvar.arr[dyd->actvar.n++];\n  var->vd.kind = VDKREG;  /* default */\n  var->vd.name = name;\n  return dyd->actvar.n - 1 - fs->firstlocal;\n}\n\n#define new_localvarliteral(ls,v) \\\n    new_localvar(ls,  \\\n      luaX_newstring(ls, \"\" v, (sizeof(v)/sizeof(char)) - 1));\n\n\n\n/*\n** Return the \"variable description\" (Vardesc) of a given variable.\n** (Unless noted otherwise, all variables are referred to by their\n** compiler indices.)\n*/\nstatic Vardesc *getlocalvardesc (FuncState *fs, int vidx) {\n  return &fs->ls->dyd->actvar.arr[fs->firstlocal + vidx];\n}\n\n\n/*\n** Convert 'nvar', a compiler index level, to its corresponding\n** register. For that, search for the highest variable below that level\n** that is in a register and uses its register index ('ridx') plus one.\n*/\nstatic int reglevel (FuncState *fs, int nvar) {\n  while (nvar-- > 0) {\n    Vardesc *vd = getlocalvardesc(fs, nvar);  /* get previous variable */\n    if (vd->vd.kind != RDKCTC)  /* is in a register? */\n      return vd->vd.ridx + 1;\n  }\n  return 0;  /* no variables in registers */\n}\n\n\n/*\n** Return the number of variables in the register stack for the given\n** function.\n*/\nint luaY_nvarstack (FuncState *fs) {\n  return reglevel(fs, fs->nactvar);\n}\n\n\n/*\n** Get the debug-information entry for current variable 'vidx'.\n*/\nstatic LocVar *localdebuginfo (FuncState *fs, int vidx) {\n  Vardesc *vd = getlocalvardesc(fs,  vidx);\n  if (vd->vd.kind == RDKCTC)\n    return NULL;  /* no debug info. for constants */\n  else {\n    int idx = vd->vd.pidx;\n    lua_assert(idx < fs->ndebugvars);\n    return &fs->f->locvars[idx];\n  }\n}\n\n\n/*\n** Create an expression representing variable 'vidx'\n*/\nstatic void init_var (FuncState *fs, expdesc *e, int vidx) {\n  e->f = e->t = NO_JUMP;\n  e->k = VLOCAL;\n  e->u.var.vidx = vidx;\n  e->u.var.ridx = getlocalvardesc(fs, vidx)->vd.ridx;\n}\n\n\n/*\n** Raises an error if variable described by 'e' is read only\n*/\nstatic void check_readonly (LexState *ls, expdesc *e) {\n  FuncState *fs = ls->fs;\n  TString *varname = NULL;  /* to be set if variable is const */\n  switch (e->k) {\n    case VCONST: {\n      varname = ls->dyd->actvar.arr[e->u.info].vd.name;\n      break;\n    }\n    case VLOCAL: {\n      Vardesc *vardesc = getlocalvardesc(fs, e->u.var.vidx);\n      if (vardesc->vd.kind != VDKREG)  /* not a regular variable? */\n        varname = vardesc->vd.name;\n      break;\n    }\n    case VUPVAL: {\n      Upvaldesc *up = &fs->f->upvalues[e->u.info];\n      if (up->kind != VDKREG)\n        varname = up->name;\n      break;\n    }\n    default:\n      return;  /* other cases cannot be read-only */\n  }\n  if (varname) {\n    const char *msg = luaO_pushfstring(ls->L,\n       \"attempt to assign to const variable '%s'\", getstr(varname));\n    luaK_semerror(ls, msg);  /* error */\n  }\n}\n\n\n/*\n** Start the scope for the last 'nvars' created variables.\n*/\nstatic void adjustlocalvars (LexState *ls, int nvars) {\n  FuncState *fs = ls->fs;\n  int reglevel = luaY_nvarstack(fs);\n  int i;\n  for (i = 0; i < nvars; i++) {\n    int vidx = fs->nactvar++;\n    Vardesc *var = getlocalvardesc(fs, vidx);\n    var->vd.ridx = reglevel++;\n    var->vd.pidx = registerlocalvar(ls, fs, var->vd.name);\n  }\n}\n\n\n/*\n** Close the scope for all variables up to level 'tolevel'.\n** (debug info.)\n*/\nstatic void removevars (FuncState *fs, int tolevel) {\n  fs->ls->dyd->actvar.n -= (fs->nactvar - tolevel);\n  while (fs->nactvar > tolevel) {\n    LocVar *var = localdebuginfo(fs, --fs->nactvar);\n    if (var)  /* does it have debug information? */\n      var->endpc = fs->pc;\n  }\n}\n\n\n/*\n** Search the upvalues of the function 'fs' for one\n** with the given 'name'.\n*/\nstatic int searchupvalue (FuncState *fs, TString *name) {\n  int i;\n  Upvaldesc *up = fs->f->upvalues;\n  for (i = 0; i < fs->nups; i++) {\n    if (eqstr(up[i].name, name)) return i;\n  }\n  return -1;  /* not found */\n}\n\n\nstatic Upvaldesc *allocupvalue (FuncState *fs) {\n  Proto *f = fs->f;\n  int oldsize = f->sizeupvalues;\n  checklimit(fs, fs->nups + 1, MAXUPVAL, \"upvalues\");\n  luaM_growvector(fs->ls->L, f->upvalues, fs->nups, f->sizeupvalues,\n                  Upvaldesc, MAXUPVAL, \"upvalues\");\n  while (oldsize < f->sizeupvalues)\n    f->upvalues[oldsize++].name = NULL;\n  return &f->upvalues[fs->nups++];\n}\n\n\nstatic int newupvalue (FuncState *fs, TString *name, expdesc *v) {\n  Upvaldesc *up = allocupvalue(fs);\n  FuncState *prev = fs->prev;\n  if (v->k == VLOCAL) {\n    up->instack = 1;\n    up->idx = v->u.var.ridx;\n    up->kind = getlocalvardesc(prev, v->u.var.vidx)->vd.kind;\n    lua_assert(eqstr(name, getlocalvardesc(prev, v->u.var.vidx)->vd.name));\n  }\n  else {\n    up->instack = 0;\n    up->idx = cast_byte(v->u.info);\n    up->kind = prev->f->upvalues[v->u.info].kind;\n    lua_assert(eqstr(name, prev->f->upvalues[v->u.info].name));\n  }\n  up->name = name;\n  luaC_objbarrier(fs->ls->L, fs->f, name);\n  return fs->nups - 1;\n}\n\n\n/*\n** Look for an active local variable with the name 'n' in the\n** function 'fs'. If found, initialize 'var' with it and return\n** its expression kind; otherwise return -1.\n*/\nstatic int searchvar (FuncState *fs, TString *n, expdesc *var) {\n  int i;\n  for (i = cast_int(fs->nactvar) - 1; i >= 0; i--) {\n    Vardesc *vd = getlocalvardesc(fs, i);\n    if (eqstr(n, vd->vd.name)) {  /* found? */\n      if (vd->vd.kind == RDKCTC)  /* compile-time constant? */\n        init_exp(var, VCONST, fs->firstlocal + i);\n      else  /* real variable */\n        init_var(fs, var, i);\n      return var->k;\n    }\n  }\n  return -1;  /* not found */\n}\n\n\n/*\n** Mark block where variable at given level was defined\n** (to emit close instructions later).\n*/\nstatic void markupval (FuncState *fs, int level) {\n  BlockCnt *bl = fs->bl;\n  while (bl->nactvar > level)\n    bl = bl->previous;\n  bl->upval = 1;\n  fs->needclose = 1;\n}\n\n\n/*\n** Mark that current block has a to-be-closed variable.\n*/\nstatic void marktobeclosed (FuncState *fs) {\n  BlockCnt *bl = fs->bl;\n  bl->upval = 1;\n  bl->insidetbc = 1;\n  fs->needclose = 1;\n}\n\n\n/*\n** Find a variable with the given name 'n'. If it is an upvalue, add\n** this upvalue into all intermediate functions. If it is a global, set\n** 'var' as 'void' as a flag.\n*/\nstatic void singlevaraux (FuncState *fs, TString *n, expdesc *var, int base) {\n  if (fs == NULL)  /* no more levels? */\n    init_exp(var, VVOID, 0);  /* default is global */\n  else {\n    int v = searchvar(fs, n, var);  /* look up locals at current level */\n    if (v >= 0) {  /* found? */\n      if (v == VLOCAL && !base)\n        markupval(fs, var->u.var.vidx);  /* local will be used as an upval */\n    }\n    else {  /* not found as local at current level; try upvalues */\n      int idx = searchupvalue(fs, n);  /* try existing upvalues */\n      if (idx < 0) {  /* not found? */\n        singlevaraux(fs->prev, n, var, 0);  /* try upper levels */\n        if (var->k == VLOCAL || var->k == VUPVAL)  /* local or upvalue? */\n          idx  = newupvalue(fs, n, var);  /* will be a new upvalue */\n        else  /* it is a global or a constant */\n          return;  /* don't need to do anything at this level */\n      }\n      init_exp(var, VUPVAL, idx);  /* new or old upvalue */\n    }\n  }\n}\n\n\n/*\n** Find a variable with the given name 'n', handling global variables\n** too.\n*/\nstatic void singlevar (LexState *ls, expdesc *var) {\n  TString *varname = str_checkname(ls);\n  FuncState *fs = ls->fs;\n  singlevaraux(fs, varname, var, 1);\n  if (var->k == VVOID) {  /* global name? */\n    expdesc key;\n    singlevaraux(fs, ls->envn, var, 1);  /* get environment variable */\n    lua_assert(var->k != VVOID);  /* this one must exist */\n    luaK_exp2anyregup(fs, var);  /* but could be a constant */\n    codestring(&key, varname);  /* key is variable name */\n    luaK_indexed(fs, var, &key);  /* env[varname] */\n  }\n}\n\n\n/*\n** Adjust the number of results from an expression list 'e' with 'nexps'\n** expressions to 'nvars' values.\n*/\nstatic void adjust_assign (LexState *ls, int nvars, int nexps, expdesc *e) {\n  FuncState *fs = ls->fs;\n  int needed = nvars - nexps;  /* extra values needed */\n  if (hasmultret(e->k)) {  /* last expression has multiple returns? */\n    int extra = needed + 1;  /* discount last expression itself */\n    if (extra < 0)\n      extra = 0;\n    luaK_setreturns(fs, e, extra);  /* last exp. provides the difference */\n  }\n  else {\n    if (e->k != VVOID)  /* at least one expression? */\n      luaK_exp2nextreg(fs, e);  /* close last expression */\n    if (needed > 0)  /* missing values? */\n      luaK_nil(fs, fs->freereg, needed);  /* complete with nils */\n  }\n  if (needed > 0)\n    luaK_reserveregs(fs, needed);  /* registers for extra values */\n  else  /* adding 'needed' is actually a subtraction */\n    fs->freereg += needed;  /* remove extra values */\n}\n\n\n#define enterlevel(ls)\tluaE_incCstack(ls->L)\n\n\n#define leavelevel(ls) ((ls)->L->nCcalls--)\n\n\n/*\n** Generates an error that a goto jumps into the scope of some\n** local variable.\n*/\nstatic l_noret jumpscopeerror (LexState *ls, Labeldesc *gt) {\n  const char *varname = getstr(getlocalvardesc(ls->fs, gt->nactvar)->vd.name);\n  const char *msg = \"<goto %s> at line %d jumps into the scope of local '%s'\";\n  msg = luaO_pushfstring(ls->L, msg, getstr(gt->name), gt->line, varname);\n  luaK_semerror(ls, msg);  /* raise the error */\n}\n\n\n/*\n** Solves the goto at index 'g' to given 'label' and removes it\n** from the list of pending goto's.\n** If it jumps into the scope of some variable, raises an error.\n*/\nstatic void solvegoto (LexState *ls, int g, Labeldesc *label) {\n  int i;\n  Labellist *gl = &ls->dyd->gt;  /* list of goto's */\n  Labeldesc *gt = &gl->arr[g];  /* goto to be resolved */\n  lua_assert(eqstr(gt->name, label->name));\n  if (l_unlikely(gt->nactvar < label->nactvar))  /* enter some scope? */\n    jumpscopeerror(ls, gt);\n  luaK_patchlist(ls->fs, gt->pc, label->pc);\n  for (i = g; i < gl->n - 1; i++)  /* remove goto from pending list */\n    gl->arr[i] = gl->arr[i + 1];\n  gl->n--;\n}\n\n\n/*\n** Search for an active label with the given name.\n*/\nstatic Labeldesc *findlabel (LexState *ls, TString *name) {\n  int i;\n  Dyndata *dyd = ls->dyd;\n  /* check labels in current function for a match */\n  for (i = ls->fs->firstlabel; i < dyd->label.n; i++) {\n    Labeldesc *lb = &dyd->label.arr[i];\n    if (eqstr(lb->name, name))  /* correct label? */\n      return lb;\n  }\n  return NULL;  /* label not found */\n}\n\n\n/*\n** Adds a new label/goto in the corresponding list.\n*/\nstatic int newlabelentry (LexState *ls, Labellist *l, TString *name,\n                          int line, int pc) {\n  int n = l->n;\n  luaM_growvector(ls->L, l->arr, n, l->size,\n                  Labeldesc, SHRT_MAX, \"labels/gotos\");\n  l->arr[n].name = name;\n  l->arr[n].line = line;\n  l->arr[n].nactvar = ls->fs->nactvar;\n  l->arr[n].close = 0;\n  l->arr[n].pc = pc;\n  l->n = n + 1;\n  return n;\n}\n\n\nstatic int newgotoentry (LexState *ls, TString *name, int line, int pc) {\n  return newlabelentry(ls, &ls->dyd->gt, name, line, pc);\n}\n\n\n/*\n** Solves forward jumps. Check whether new label 'lb' matches any\n** pending gotos in current block and solves them. Return true\n** if any of the goto's need to close upvalues.\n*/\nstatic int solvegotos (LexState *ls, Labeldesc *lb) {\n  Labellist *gl = &ls->dyd->gt;\n  int i = ls->fs->bl->firstgoto;\n  int needsclose = 0;\n  while (i < gl->n) {\n    if (eqstr(gl->arr[i].name, lb->name)) {\n      needsclose |= gl->arr[i].close;\n      solvegoto(ls, i, lb);  /* will remove 'i' from the list */\n    }\n    else\n      i++;\n  }\n  return needsclose;\n}\n\n\n/*\n** Create a new label with the given 'name' at the given 'line'.\n** 'last' tells whether label is the last non-op statement in its\n** block. Solves all pending goto's to this new label and adds\n** a close instruction if necessary.\n** Returns true iff it added a close instruction.\n*/\nstatic int createlabel (LexState *ls, TString *name, int line,\n                        int last) {\n  FuncState *fs = ls->fs;\n  Labellist *ll = &ls->dyd->label;\n  int l = newlabelentry(ls, ll, name, line, luaK_getlabel(fs));\n  if (last) {  /* label is last no-op statement in the block? */\n    /* assume that locals are already out of scope */\n    ll->arr[l].nactvar = fs->bl->nactvar;\n  }\n  if (solvegotos(ls, &ll->arr[l])) {  /* need close? */\n    luaK_codeABC(fs, OP_CLOSE, luaY_nvarstack(fs), 0, 0);\n    return 1;\n  }\n  return 0;\n}\n\n\n/*\n** Adjust pending gotos to outer level of a block.\n*/\nstatic void movegotosout (FuncState *fs, BlockCnt *bl) {\n  int i;\n  Labellist *gl = &fs->ls->dyd->gt;\n  /* correct pending gotos to current block */\n  for (i = bl->firstgoto; i < gl->n; i++) {  /* for each pending goto */\n    Labeldesc *gt = &gl->arr[i];\n    /* leaving a variable scope? */\n    if (reglevel(fs, gt->nactvar) > reglevel(fs, bl->nactvar))\n      gt->close |= bl->upval;  /* jump may need a close */\n    gt->nactvar = bl->nactvar;  /* update goto level */\n  }\n}\n\n\nstatic void enterblock (FuncState *fs, BlockCnt *bl, lu_byte isloop) {\n  bl->isloop = isloop;\n  bl->nactvar = fs->nactvar;\n  bl->firstlabel = fs->ls->dyd->label.n;\n  bl->firstgoto = fs->ls->dyd->gt.n;\n  bl->upval = 0;\n  bl->insidetbc = (fs->bl != NULL && fs->bl->insidetbc);\n  bl->previous = fs->bl;\n  fs->bl = bl;\n  lua_assert(fs->freereg == luaY_nvarstack(fs));\n}\n\n\n/*\n** generates an error for an undefined 'goto'.\n*/\nstatic l_noret undefgoto (LexState *ls, Labeldesc *gt) {\n  const char *msg;\n  if (eqstr(gt->name, luaS_newliteral(ls->L, \"break\"))) {\n    msg = \"break outside loop at line %d\";\n    msg = luaO_pushfstring(ls->L, msg, gt->line);\n  }\n  else {\n    msg = \"no visible label '%s' for <goto> at line %d\";\n    msg = luaO_pushfstring(ls->L, msg, getstr(gt->name), gt->line);\n  }\n  luaK_semerror(ls, msg);\n}\n\n\nstatic void leaveblock (FuncState *fs) {\n  BlockCnt *bl = fs->bl;\n  LexState *ls = fs->ls;\n  int hasclose = 0;\n  int stklevel = reglevel(fs, bl->nactvar);  /* level outside the block */\n  if (bl->isloop)  /* fix pending breaks? */\n    hasclose = createlabel(ls, luaS_newliteral(ls->L, \"break\"), 0, 0);\n  if (!hasclose && bl->previous && bl->upval)\n    luaK_codeABC(fs, OP_CLOSE, stklevel, 0, 0);\n  fs->bl = bl->previous;\n  removevars(fs, bl->nactvar);\n  lua_assert(bl->nactvar == fs->nactvar);\n  fs->freereg = stklevel;  /* free registers */\n  ls->dyd->label.n = bl->firstlabel;  /* remove local labels */\n  if (bl->previous)  /* inner block? */\n    movegotosout(fs, bl);  /* update pending gotos to outer block */\n  else {\n    if (bl->firstgoto < ls->dyd->gt.n)  /* pending gotos in outer block? */\n      undefgoto(ls, &ls->dyd->gt.arr[bl->firstgoto]);  /* error */\n  }\n}\n\n\n/*\n** adds a new prototype into list of prototypes\n*/\nstatic Proto *addprototype (LexState *ls) {\n  Proto *clp;\n  lua_State *L = ls->L;\n  FuncState *fs = ls->fs;\n  Proto *f = fs->f;  /* prototype of current function */\n  if (fs->np >= f->sizep) {\n    int oldsize = f->sizep;\n    luaM_growvector(L, f->p, fs->np, f->sizep, Proto *, MAXARG_Bx, \"functions\");\n    while (oldsize < f->sizep)\n      f->p[oldsize++] = NULL;\n  }\n  f->p[fs->np++] = clp = luaF_newproto(L);\n  luaC_objbarrier(L, f, clp);\n  return clp;\n}\n\n\n/*\n** codes instruction to create new closure in parent function.\n** The OP_CLOSURE instruction uses the last available register,\n** so that, if it invokes the GC, the GC knows which registers\n** are in use at that time.\n\n*/\nstatic void codeclosure (LexState *ls, expdesc *v) {\n  FuncState *fs = ls->fs->prev;\n  init_exp(v, VRELOC, luaK_codeABx(fs, OP_CLOSURE, 0, fs->np - 1));\n  luaK_exp2nextreg(fs, v);  /* fix it at the last register */\n}\n\n\nstatic void open_func (LexState *ls, FuncState *fs, BlockCnt *bl) {\n  Proto *f = fs->f;\n  fs->prev = ls->fs;  /* linked list of funcstates */\n  fs->ls = ls;\n  ls->fs = fs;\n  fs->pc = 0;\n  fs->previousline = f->linedefined;\n  fs->iwthabs = 0;\n  fs->lasttarget = 0;\n  fs->freereg = 0;\n  fs->nk = 0;\n  fs->nabslineinfo = 0;\n  fs->np = 0;\n  fs->nups = 0;\n  fs->ndebugvars = 0;\n  fs->nactvar = 0;\n  fs->needclose = 0;\n  fs->firstlocal = ls->dyd->actvar.n;\n  fs->firstlabel = ls->dyd->label.n;\n  fs->bl = NULL;\n  f->source = ls->source;\n  luaC_objbarrier(ls->L, f, f->source);\n  f->maxstacksize = 2;  /* registers 0/1 are always valid */\n  enterblock(fs, bl, 0);\n}\n\n\nstatic void close_func (LexState *ls) {\n  lua_State *L = ls->L;\n  FuncState *fs = ls->fs;\n  Proto *f = fs->f;\n  luaK_ret(fs, luaY_nvarstack(fs), 0);  /* final return */\n  leaveblock(fs);\n  lua_assert(fs->bl == NULL);\n  luaK_finish(fs);\n  luaM_shrinkvector(L, f->code, f->sizecode, fs->pc, Instruction);\n  luaM_shrinkvector(L, f->lineinfo, f->sizelineinfo, fs->pc, ls_byte);\n  luaM_shrinkvector(L, f->abslineinfo, f->sizeabslineinfo,\n                       fs->nabslineinfo, AbsLineInfo);\n  luaM_shrinkvector(L, f->k, f->sizek, fs->nk, TValue);\n  luaM_shrinkvector(L, f->p, f->sizep, fs->np, Proto *);\n  luaM_shrinkvector(L, f->locvars, f->sizelocvars, fs->ndebugvars, LocVar);\n  luaM_shrinkvector(L, f->upvalues, f->sizeupvalues, fs->nups, Upvaldesc);\n  ls->fs = fs->prev;\n  luaC_checkGC(L);\n}\n\n\n\n/*============================================================*/\n/* GRAMMAR RULES */\n/*============================================================*/\n\n\n/*\n** check whether current token is in the follow set of a block.\n** 'until' closes syntactical blocks, but do not close scope,\n** so it is handled in separate.\n*/\nstatic int block_follow (LexState *ls, int withuntil) {\n  switch (ls->t.token) {\n    case TK_ELSE: case TK_ELSEIF:\n    case TK_END: case TK_EOS:\n      return 1;\n    case TK_UNTIL: return withuntil;\n    default: return 0;\n  }\n}\n\n\nstatic void statlist (LexState *ls) {\n  /* statlist -> { stat [';'] } */\n  while (!block_follow(ls, 1)) {\n    if (ls->t.token == TK_RETURN) {\n      statement(ls);\n      return;  /* 'return' must be last statement */\n    }\n    statement(ls);\n  }\n}\n\n\nstatic void fieldsel (LexState *ls, expdesc *v) {\n  /* fieldsel -> ['.' | ':'] NAME */\n  FuncState *fs = ls->fs;\n  expdesc key;\n  luaK_exp2anyregup(fs, v);\n  luaX_next(ls);  /* skip the dot or colon */\n  codename(ls, &key);\n  luaK_indexed(fs, v, &key);\n}\n\n\nstatic void yindex (LexState *ls, expdesc *v) {\n  /* index -> '[' expr ']' */\n  luaX_next(ls);  /* skip the '[' */\n  expr(ls, v);\n  luaK_exp2val(ls->fs, v);\n  checknext(ls, ']');\n}\n\n\n/*\n** {======================================================================\n** Rules for Constructors\n** =======================================================================\n*/\n\n\ntypedef struct ConsControl {\n  expdesc v;  /* last list item read */\n  expdesc *t;  /* table descriptor */\n  int nh;  /* total number of 'record' elements */\n  int na;  /* number of array elements already stored */\n  int tostore;  /* number of array elements pending to be stored */\n} ConsControl;\n\n\nstatic void recfield (LexState *ls, ConsControl *cc) {\n  /* recfield -> (NAME | '['exp']') = exp */\n  FuncState *fs = ls->fs;\n  int reg = ls->fs->freereg;\n  expdesc tab, key, val;\n  if (ls->t.token == TK_NAME) {\n    checklimit(fs, cc->nh, MAX_INT, \"items in a constructor\");\n    codename(ls, &key);\n  }\n  else  /* ls->t.token == '[' */\n    yindex(ls, &key);\n  cc->nh++;\n  checknext(ls, '=');\n  tab = *cc->t;\n  luaK_indexed(fs, &tab, &key);\n  expr(ls, &val);\n  luaK_storevar(fs, &tab, &val);\n  fs->freereg = reg;  /* free registers */\n}\n\n\nstatic void closelistfield (FuncState *fs, ConsControl *cc) {\n  if (cc->v.k == VVOID) return;  /* there is no list item */\n  luaK_exp2nextreg(fs, &cc->v);\n  cc->v.k = VVOID;\n  if (cc->tostore == LFIELDS_PER_FLUSH) {\n    luaK_setlist(fs, cc->t->u.info, cc->na, cc->tostore);  /* flush */\n    cc->na += cc->tostore;\n    cc->tostore = 0;  /* no more items pending */\n  }\n}\n\n\nstatic void lastlistfield (FuncState *fs, ConsControl *cc) {\n  if (cc->tostore == 0) return;\n  if (hasmultret(cc->v.k)) {\n    luaK_setmultret(fs, &cc->v);\n    luaK_setlist(fs, cc->t->u.info, cc->na, LUA_MULTRET);\n    cc->na--;  /* do not count last expression (unknown number of elements) */\n  }\n  else {\n    if (cc->v.k != VVOID)\n      luaK_exp2nextreg(fs, &cc->v);\n    luaK_setlist(fs, cc->t->u.info, cc->na, cc->tostore);\n  }\n  cc->na += cc->tostore;\n}\n\n\nstatic void listfield (LexState *ls, ConsControl *cc) {\n  /* listfield -> exp */\n  expr(ls, &cc->v);\n  cc->tostore++;\n}\n\n\nstatic void field (LexState *ls, ConsControl *cc) {\n  /* field -> listfield | recfield */\n  switch(ls->t.token) {\n    case TK_NAME: {  /* may be 'listfield' or 'recfield' */\n      if (luaX_lookahead(ls) != '=')  /* expression? */\n        listfield(ls, cc);\n      else\n        recfield(ls, cc);\n      break;\n    }\n    case '[': {\n      recfield(ls, cc);\n      break;\n    }\n    default: {\n      listfield(ls, cc);\n      break;\n    }\n  }\n}\n\n\nstatic void constructor (LexState *ls, expdesc *t) {\n  /* constructor -> '{' [ field { sep field } [sep] ] '}'\n     sep -> ',' | ';' */\n  FuncState *fs = ls->fs;\n  int line = ls->linenumber;\n  int pc = luaK_codeABC(fs, OP_NEWTABLE, 0, 0, 0);\n  ConsControl cc;\n  luaK_code(fs, 0);  /* space for extra arg. */\n  cc.na = cc.nh = cc.tostore = 0;\n  cc.t = t;\n  init_exp(t, VNONRELOC, fs->freereg);  /* table will be at stack top */\n  luaK_reserveregs(fs, 1);\n  init_exp(&cc.v, VVOID, 0);  /* no value (yet) */\n  checknext(ls, '{');\n  do {\n    lua_assert(cc.v.k == VVOID || cc.tostore > 0);\n    if (ls->t.token == '}') break;\n    closelistfield(fs, &cc);\n    field(ls, &cc);\n  } while (testnext(ls, ',') || testnext(ls, ';'));\n  check_match(ls, '}', '{', line);\n  lastlistfield(fs, &cc);\n  luaK_settablesize(fs, pc, t->u.info, cc.na, cc.nh);\n}\n\n/* }====================================================================== */\n\n\nstatic void setvararg (FuncState *fs, int nparams) {\n  fs->f->is_vararg = 1;\n  luaK_codeABC(fs, OP_VARARGPREP, nparams, 0, 0);\n}\n\n\nstatic void parlist (LexState *ls) {\n  /* parlist -> [ {NAME ','} (NAME | '...') ] */\n  FuncState *fs = ls->fs;\n  Proto *f = fs->f;\n  int nparams = 0;\n  int isvararg = 0;\n  if (ls->t.token != ')') {  /* is 'parlist' not empty? */\n    do {\n      switch (ls->t.token) {\n        case TK_NAME: {\n          new_localvar(ls, str_checkname(ls));\n          nparams++;\n          break;\n        }\n        case TK_DOTS: {\n          luaX_next(ls);\n          isvararg = 1;\n          break;\n        }\n        default: luaX_syntaxerror(ls, \"<name> or '...' expected\");\n      }\n    } while (!isvararg && testnext(ls, ','));\n  }\n  adjustlocalvars(ls, nparams);\n  f->numparams = cast_byte(fs->nactvar);\n  if (isvararg)\n    setvararg(fs, f->numparams);  /* declared vararg */\n  luaK_reserveregs(fs, fs->nactvar);  /* reserve registers for parameters */\n}\n\n\nstatic void body (LexState *ls, expdesc *e, int ismethod, int line) {\n  /* body ->  '(' parlist ')' block END */\n  FuncState new_fs;\n  BlockCnt bl;\n  new_fs.f = addprototype(ls);\n  new_fs.f->linedefined = line;\n  open_func(ls, &new_fs, &bl);\n  checknext(ls, '(');\n  if (ismethod) {\n    new_localvarliteral(ls, \"self\");  /* create 'self' parameter */\n    adjustlocalvars(ls, 1);\n  }\n  parlist(ls);\n  checknext(ls, ')');\n  statlist(ls);\n  new_fs.f->lastlinedefined = ls->linenumber;\n  check_match(ls, TK_END, TK_FUNCTION, line);\n  codeclosure(ls, e);\n  close_func(ls);\n}\n\n\nstatic int explist (LexState *ls, expdesc *v) {\n  /* explist -> expr { ',' expr } */\n  int n = 1;  /* at least one expression */\n  expr(ls, v);\n  while (testnext(ls, ',')) {\n    luaK_exp2nextreg(ls->fs, v);\n    expr(ls, v);\n    n++;\n  }\n  return n;\n}\n\n\nstatic void funcargs (LexState *ls, expdesc *f, int line) {\n  FuncState *fs = ls->fs;\n  expdesc args;\n  int base, nparams;\n  switch (ls->t.token) {\n    case '(': {  /* funcargs -> '(' [ explist ] ')' */\n      luaX_next(ls);\n      if (ls->t.token == ')')  /* arg list is empty? */\n        args.k = VVOID;\n      else {\n        explist(ls, &args);\n        if (hasmultret(args.k))\n          luaK_setmultret(fs, &args);\n      }\n      check_match(ls, ')', '(', line);\n      break;\n    }\n    case '{': {  /* funcargs -> constructor */\n      constructor(ls, &args);\n      break;\n    }\n    case TK_STRING: {  /* funcargs -> STRING */\n      codestring(&args, ls->t.seminfo.ts);\n      luaX_next(ls);  /* must use 'seminfo' before 'next' */\n      break;\n    }\n    default: {\n      luaX_syntaxerror(ls, \"function arguments expected\");\n    }\n  }\n  lua_assert(f->k == VNONRELOC);\n  base = f->u.info;  /* base register for call */\n  if (hasmultret(args.k))\n    nparams = LUA_MULTRET;  /* open call */\n  else {\n    if (args.k != VVOID)\n      luaK_exp2nextreg(fs, &args);  /* close last argument */\n    nparams = fs->freereg - (base+1);\n  }\n  init_exp(f, VCALL, luaK_codeABC(fs, OP_CALL, base, nparams+1, 2));\n  luaK_fixline(fs, line);\n  fs->freereg = base+1;  /* call remove function and arguments and leaves\n                            (unless changed) one result */\n}\n\n\n\n\n/*\n** {======================================================================\n** Expression parsing\n** =======================================================================\n*/\n\n\nstatic void primaryexp (LexState *ls, expdesc *v) {\n  /* primaryexp -> NAME | '(' expr ')' */\n  switch (ls->t.token) {\n    case '(': {\n      int line = ls->linenumber;\n      luaX_next(ls);\n      expr(ls, v);\n      check_match(ls, ')', '(', line);\n      luaK_dischargevars(ls->fs, v);\n      return;\n    }\n    case TK_NAME: {\n      singlevar(ls, v);\n      return;\n    }\n    default: {\n      luaX_syntaxerror(ls, \"unexpected symbol\");\n    }\n  }\n}\n\n\nstatic void suffixedexp (LexState *ls, expdesc *v) {\n  /* suffixedexp ->\n       primaryexp { '.' NAME | '[' exp ']' | ':' NAME funcargs | funcargs } */\n  FuncState *fs = ls->fs;\n  int line = ls->linenumber;\n  primaryexp(ls, v);\n  for (;;) {\n    switch (ls->t.token) {\n      case '.': {  /* fieldsel */\n        fieldsel(ls, v);\n        break;\n      }\n      case '[': {  /* '[' exp ']' */\n        expdesc key;\n        luaK_exp2anyregup(fs, v);\n        yindex(ls, &key);\n        luaK_indexed(fs, v, &key);\n        break;\n      }\n      case ':': {  /* ':' NAME funcargs */\n        expdesc key;\n        luaX_next(ls);\n        codename(ls, &key);\n        luaK_self(fs, v, &key);\n        funcargs(ls, v, line);\n        break;\n      }\n      case '(': case TK_STRING: case '{': {  /* funcargs */\n        luaK_exp2nextreg(fs, v);\n        funcargs(ls, v, line);\n        break;\n      }\n      default: return;\n    }\n  }\n}\n\n\nstatic void simpleexp (LexState *ls, expdesc *v) {\n  /* simpleexp -> FLT | INT | STRING | NIL | TRUE | FALSE | ... |\n                  constructor | FUNCTION body | suffixedexp */\n  switch (ls->t.token) {\n    case TK_FLT: {\n      init_exp(v, VKFLT, 0);\n      v->u.nval = ls->t.seminfo.r;\n      break;\n    }\n    case TK_INT: {\n      init_exp(v, VKINT, 0);\n      v->u.ival = ls->t.seminfo.i;\n      break;\n    }\n    case TK_STRING: {\n      codestring(v, ls->t.seminfo.ts);\n      break;\n    }\n    case TK_NIL: {\n      init_exp(v, VNIL, 0);\n      break;\n    }\n    case TK_TRUE: {\n      init_exp(v, VTRUE, 0);\n      break;\n    }\n    case TK_FALSE: {\n      init_exp(v, VFALSE, 0);\n      break;\n    }\n    case TK_DOTS: {  /* vararg */\n      FuncState *fs = ls->fs;\n      check_condition(ls, fs->f->is_vararg,\n                      \"cannot use '...' outside a vararg function\");\n      init_exp(v, VVARARG, luaK_codeABC(fs, OP_VARARG, 0, 0, 1));\n      break;\n    }\n    case '{': {  /* constructor */\n      constructor(ls, v);\n      return;\n    }\n    case TK_FUNCTION: {\n      luaX_next(ls);\n      body(ls, v, 0, ls->linenumber);\n      return;\n    }\n    default: {\n      suffixedexp(ls, v);\n      return;\n    }\n  }\n  luaX_next(ls);\n}\n\n\nstatic UnOpr getunopr (int op) {\n  switch (op) {\n    case TK_NOT: return OPR_NOT;\n    case '-': return OPR_MINUS;\n    case '~': return OPR_BNOT;\n    case '#': return OPR_LEN;\n    default: return OPR_NOUNOPR;\n  }\n}\n\n\nstatic BinOpr getbinopr (int op) {\n  switch (op) {\n    case '+': return OPR_ADD;\n    case '-': return OPR_SUB;\n    case '*': return OPR_MUL;\n    case '%': return OPR_MOD;\n    case '^': return OPR_POW;\n    case '/': return OPR_DIV;\n    case TK_IDIV: return OPR_IDIV;\n    case '&': return OPR_BAND;\n    case '|': return OPR_BOR;\n    case '~': return OPR_BXOR;\n    case TK_SHL: return OPR_SHL;\n    case TK_SHR: return OPR_SHR;\n    case TK_CONCAT: return OPR_CONCAT;\n    case TK_NE: return OPR_NE;\n    case TK_EQ: return OPR_EQ;\n    case '<': return OPR_LT;\n    case TK_LE: return OPR_LE;\n    case '>': return OPR_GT;\n    case TK_GE: return OPR_GE;\n    case TK_AND: return OPR_AND;\n    case TK_OR: return OPR_OR;\n    default: return OPR_NOBINOPR;\n  }\n}\n\n\n/*\n** Priority table for binary operators.\n*/\nstatic const struct {\n  lu_byte left;  /* left priority for each binary operator */\n  lu_byte right; /* right priority */\n} priority[] = {  /* ORDER OPR */\n   {10, 10}, {10, 10},           /* '+' '-' */\n   {11, 11}, {11, 11},           /* '*' '%' */\n   {14, 13},                  /* '^' (right associative) */\n   {11, 11}, {11, 11},           /* '/' '//' */\n   {6, 6}, {4, 4}, {5, 5},   /* '&' '|' '~' */\n   {7, 7}, {7, 7},           /* '<<' '>>' */\n   {9, 8},                   /* '..' (right associative) */\n   {3, 3}, {3, 3}, {3, 3},   /* ==, <, <= */\n   {3, 3}, {3, 3}, {3, 3},   /* ~=, >, >= */\n   {2, 2}, {1, 1}            /* and, or */\n};\n\n#define UNARY_PRIORITY\t12  /* priority for unary operators */\n\n\n/*\n** subexpr -> (simpleexp | unop subexpr) { binop subexpr }\n** where 'binop' is any binary operator with a priority higher than 'limit'\n*/\nstatic BinOpr subexpr (LexState *ls, expdesc *v, int limit) {\n  BinOpr op;\n  UnOpr uop;\n  enterlevel(ls);\n  uop = getunopr(ls->t.token);\n  if (uop != OPR_NOUNOPR) {  /* prefix (unary) operator? */\n    int line = ls->linenumber;\n    luaX_next(ls);  /* skip operator */\n    subexpr(ls, v, UNARY_PRIORITY);\n    luaK_prefix(ls->fs, uop, v, line);\n  }\n  else simpleexp(ls, v);\n  /* expand while operators have priorities higher than 'limit' */\n  op = getbinopr(ls->t.token);\n  while (op != OPR_NOBINOPR && priority[op].left > limit) {\n    expdesc v2;\n    BinOpr nextop;\n    int line = ls->linenumber;\n    luaX_next(ls);  /* skip operator */\n    luaK_infix(ls->fs, op, v);\n    /* read sub-expression with higher priority */\n    nextop = subexpr(ls, &v2, priority[op].right);\n    luaK_posfix(ls->fs, op, v, &v2, line);\n    op = nextop;\n  }\n  leavelevel(ls);\n  return op;  /* return first untreated operator */\n}\n\n\nstatic void expr (LexState *ls, expdesc *v) {\n  subexpr(ls, v, 0);\n}\n\n/* }==================================================================== */\n\n\n\n/*\n** {======================================================================\n** Rules for Statements\n** =======================================================================\n*/\n\n\nstatic void block (LexState *ls) {\n  /* block -> statlist */\n  FuncState *fs = ls->fs;\n  BlockCnt bl;\n  enterblock(fs, &bl, 0);\n  statlist(ls);\n  leaveblock(fs);\n}\n\n\n/*\n** structure to chain all variables in the left-hand side of an\n** assignment\n*/\nstruct LHS_assign {\n  struct LHS_assign *prev;\n  expdesc v;  /* variable (global, local, upvalue, or indexed) */\n};\n\n\n/*\n** check whether, in an assignment to an upvalue/local variable, the\n** upvalue/local variable is begin used in a previous assignment to a\n** table. If so, save original upvalue/local value in a safe place and\n** use this safe copy in the previous assignment.\n*/\nstatic void check_conflict (LexState *ls, struct LHS_assign *lh, expdesc *v) {\n  FuncState *fs = ls->fs;\n  int extra = fs->freereg;  /* eventual position to save local variable */\n  int conflict = 0;\n  for (; lh; lh = lh->prev) {  /* check all previous assignments */\n    if (vkisindexed(lh->v.k)) {  /* assignment to table field? */\n      if (lh->v.k == VINDEXUP) {  /* is table an upvalue? */\n        if (v->k == VUPVAL && lh->v.u.ind.t == v->u.info) {\n          conflict = 1;  /* table is the upvalue being assigned now */\n          lh->v.k = VINDEXSTR;\n          lh->v.u.ind.t = extra;  /* assignment will use safe copy */\n        }\n      }\n      else {  /* table is a register */\n        if (v->k == VLOCAL && lh->v.u.ind.t == v->u.var.ridx) {\n          conflict = 1;  /* table is the local being assigned now */\n          lh->v.u.ind.t = extra;  /* assignment will use safe copy */\n        }\n        /* is index the local being assigned? */\n        if (lh->v.k == VINDEXED && v->k == VLOCAL &&\n            lh->v.u.ind.idx == v->u.var.ridx) {\n          conflict = 1;\n          lh->v.u.ind.idx = extra;  /* previous assignment will use safe copy */\n        }\n      }\n    }\n  }\n  if (conflict) {\n    /* copy upvalue/local value to a temporary (in position 'extra') */\n    if (v->k == VLOCAL)\n      luaK_codeABC(fs, OP_MOVE, extra, v->u.var.ridx, 0);\n    else\n      luaK_codeABC(fs, OP_GETUPVAL, extra, v->u.info, 0);\n    luaK_reserveregs(fs, 1);\n  }\n}\n\n/*\n** Parse and compile a multiple assignment. The first \"variable\"\n** (a 'suffixedexp') was already read by the caller.\n**\n** assignment -> suffixedexp restassign\n** restassign -> ',' suffixedexp restassign | '=' explist\n*/\nstatic void restassign (LexState *ls, struct LHS_assign *lh, int nvars) {\n  expdesc e;\n  check_condition(ls, vkisvar(lh->v.k), \"syntax error\");\n  check_readonly(ls, &lh->v);\n  if (testnext(ls, ',')) {  /* restassign -> ',' suffixedexp restassign */\n    struct LHS_assign nv;\n    nv.prev = lh;\n    suffixedexp(ls, &nv.v);\n    if (!vkisindexed(nv.v.k))\n      check_conflict(ls, lh, &nv.v);\n    enterlevel(ls);  /* control recursion depth */\n    restassign(ls, &nv, nvars+1);\n    leavelevel(ls);\n  }\n  else {  /* restassign -> '=' explist */\n    int nexps;\n    checknext(ls, '=');\n    nexps = explist(ls, &e);\n    if (nexps != nvars)\n      adjust_assign(ls, nvars, nexps, &e);\n    else {\n      luaK_setoneret(ls->fs, &e);  /* close last expression */\n      luaK_storevar(ls->fs, &lh->v, &e);\n      return;  /* avoid default */\n    }\n  }\n  init_exp(&e, VNONRELOC, ls->fs->freereg-1);  /* default assignment */\n  luaK_storevar(ls->fs, &lh->v, &e);\n}\n\n\nstatic int cond (LexState *ls) {\n  /* cond -> exp */\n  expdesc v;\n  expr(ls, &v);  /* read condition */\n  if (v.k == VNIL) v.k = VFALSE;  /* 'falses' are all equal here */\n  luaK_goiftrue(ls->fs, &v);\n  return v.f;\n}\n\n\nstatic void gotostat (LexState *ls) {\n  FuncState *fs = ls->fs;\n  int line = ls->linenumber;\n  TString *name = str_checkname(ls);  /* label's name */\n  Labeldesc *lb = findlabel(ls, name);\n  if (lb == NULL)  /* no label? */\n    /* forward jump; will be resolved when the label is declared */\n    newgotoentry(ls, name, line, luaK_jump(fs));\n  else {  /* found a label */\n    /* backward jump; will be resolved here */\n    int lblevel = reglevel(fs, lb->nactvar);  /* label level */\n    if (luaY_nvarstack(fs) > lblevel)  /* leaving the scope of a variable? */\n      luaK_codeABC(fs, OP_CLOSE, lblevel, 0, 0);\n    /* create jump and link it to the label */\n    luaK_patchlist(fs, luaK_jump(fs), lb->pc);\n  }\n}\n\n\n/*\n** Break statement. Semantically equivalent to \"goto break\".\n*/\nstatic void breakstat (LexState *ls) {\n  int line = ls->linenumber;\n  luaX_next(ls);  /* skip break */\n  newgotoentry(ls, luaS_newliteral(ls->L, \"break\"), line, luaK_jump(ls->fs));\n}\n\n\n/*\n** Check whether there is already a label with the given 'name'.\n*/\nstatic void checkrepeated (LexState *ls, TString *name) {\n  Labeldesc *lb = findlabel(ls, name);\n  if (l_unlikely(lb != NULL)) {  /* already defined? */\n    const char *msg = \"label '%s' already defined on line %d\";\n    msg = luaO_pushfstring(ls->L, msg, getstr(name), lb->line);\n    luaK_semerror(ls, msg);  /* error */\n  }\n}\n\n\nstatic void labelstat (LexState *ls, TString *name, int line) {\n  /* label -> '::' NAME '::' */\n  checknext(ls, TK_DBCOLON);  /* skip double colon */\n  while (ls->t.token == ';' || ls->t.token == TK_DBCOLON)\n    statement(ls);  /* skip other no-op statements */\n  checkrepeated(ls, name);  /* check for repeated labels */\n  createlabel(ls, name, line, block_follow(ls, 0));\n}\n\n\nstatic void whilestat (LexState *ls, int line) {\n  /* whilestat -> WHILE cond DO block END */\n  FuncState *fs = ls->fs;\n  int whileinit;\n  int condexit;\n  BlockCnt bl;\n  luaX_next(ls);  /* skip WHILE */\n  whileinit = luaK_getlabel(fs);\n  condexit = cond(ls);\n  enterblock(fs, &bl, 1);\n  checknext(ls, TK_DO);\n  block(ls);\n  luaK_jumpto(fs, whileinit);\n  check_match(ls, TK_END, TK_WHILE, line);\n  leaveblock(fs);\n  luaK_patchtohere(fs, condexit);  /* false conditions finish the loop */\n}\n\n\nstatic void repeatstat (LexState *ls, int line) {\n  /* repeatstat -> REPEAT block UNTIL cond */\n  int condexit;\n  FuncState *fs = ls->fs;\n  int repeat_init = luaK_getlabel(fs);\n  BlockCnt bl1, bl2;\n  enterblock(fs, &bl1, 1);  /* loop block */\n  enterblock(fs, &bl2, 0);  /* scope block */\n  luaX_next(ls);  /* skip REPEAT */\n  statlist(ls);\n  check_match(ls, TK_UNTIL, TK_REPEAT, line);\n  condexit = cond(ls);  /* read condition (inside scope block) */\n  leaveblock(fs);  /* finish scope */\n  if (bl2.upval) {  /* upvalues? */\n    int exit = luaK_jump(fs);  /* normal exit must jump over fix */\n    luaK_patchtohere(fs, condexit);  /* repetition must close upvalues */\n    luaK_codeABC(fs, OP_CLOSE, reglevel(fs, bl2.nactvar), 0, 0);\n    condexit = luaK_jump(fs);  /* repeat after closing upvalues */\n    luaK_patchtohere(fs, exit);  /* normal exit comes to here */\n  }\n  luaK_patchlist(fs, condexit, repeat_init);  /* close the loop */\n  leaveblock(fs);  /* finish loop */\n}\n\n\n/*\n** Read an expression and generate code to put its results in next\n** stack slot.\n**\n*/\nstatic void exp1 (LexState *ls) {\n  expdesc e;\n  expr(ls, &e);\n  luaK_exp2nextreg(ls->fs, &e);\n  lua_assert(e.k == VNONRELOC);\n}\n\n\n/*\n** Fix for instruction at position 'pc' to jump to 'dest'.\n** (Jump addresses are relative in Lua). 'back' true means\n** a back jump.\n*/\nstatic void fixforjump (FuncState *fs, int pc, int dest, int back) {\n  Instruction *jmp = &fs->f->code[pc];\n  int offset = dest - (pc + 1);\n  if (back)\n    offset = -offset;\n  if (l_unlikely(offset > MAXARG_Bx))\n    luaX_syntaxerror(fs->ls, \"control structure too long\");\n  SETARG_Bx(*jmp, offset);\n}\n\n\n/*\n** Generate code for a 'for' loop.\n*/\nstatic void forbody (LexState *ls, int base, int line, int nvars, int isgen) {\n  /* forbody -> DO block */\n  static const OpCode forprep[2] = {OP_FORPREP, OP_TFORPREP};\n  static const OpCode forloop[2] = {OP_FORLOOP, OP_TFORLOOP};\n  BlockCnt bl;\n  FuncState *fs = ls->fs;\n  int prep, endfor;\n  checknext(ls, TK_DO);\n  prep = luaK_codeABx(fs, forprep[isgen], base, 0);\n  enterblock(fs, &bl, 0);  /* scope for declared variables */\n  adjustlocalvars(ls, nvars);\n  luaK_reserveregs(fs, nvars);\n  block(ls);\n  leaveblock(fs);  /* end of scope for declared variables */\n  fixforjump(fs, prep, luaK_getlabel(fs), 0);\n  if (isgen) {  /* generic for? */\n    luaK_codeABC(fs, OP_TFORCALL, base, 0, nvars);\n    luaK_fixline(fs, line);\n  }\n  endfor = luaK_codeABx(fs, forloop[isgen], base, 0);\n  fixforjump(fs, endfor, prep + 1, 1);\n  luaK_fixline(fs, line);\n}\n\n\nstatic void fornum (LexState *ls, TString *varname, int line) {\n  /* fornum -> NAME = exp,exp[,exp] forbody */\n  FuncState *fs = ls->fs;\n  int base = fs->freereg;\n  new_localvarliteral(ls, \"(for state)\");\n  new_localvarliteral(ls, \"(for state)\");\n  new_localvarliteral(ls, \"(for state)\");\n  new_localvar(ls, varname);\n  checknext(ls, '=');\n  exp1(ls);  /* initial value */\n  checknext(ls, ',');\n  exp1(ls);  /* limit */\n  if (testnext(ls, ','))\n    exp1(ls);  /* optional step */\n  else {  /* default step = 1 */\n    luaK_int(fs, fs->freereg, 1);\n    luaK_reserveregs(fs, 1);\n  }\n  adjustlocalvars(ls, 3);  /* control variables */\n  forbody(ls, base, line, 1, 0);\n}\n\n\nstatic void forlist (LexState *ls, TString *indexname) {\n  /* forlist -> NAME {,NAME} IN explist forbody */\n  FuncState *fs = ls->fs;\n  expdesc e;\n  int nvars = 5;  /* gen, state, control, toclose, 'indexname' */\n  int line;\n  int base = fs->freereg;\n  /* create control variables */\n  new_localvarliteral(ls, \"(for state)\");\n  new_localvarliteral(ls, \"(for state)\");\n  new_localvarliteral(ls, \"(for state)\");\n  new_localvarliteral(ls, \"(for state)\");\n  /* create declared variables */\n  new_localvar(ls, indexname);\n  while (testnext(ls, ',')) {\n    new_localvar(ls, str_checkname(ls));\n    nvars++;\n  }\n  checknext(ls, TK_IN);\n  line = ls->linenumber;\n  adjust_assign(ls, 4, explist(ls, &e), &e);\n  adjustlocalvars(ls, 4);  /* control variables */\n  marktobeclosed(fs);  /* last control var. must be closed */\n  luaK_checkstack(fs, 3);  /* extra space to call generator */\n  forbody(ls, base, line, nvars - 4, 1);\n}\n\n\nstatic void forstat (LexState *ls, int line) {\n  /* forstat -> FOR (fornum | forlist) END */\n  FuncState *fs = ls->fs;\n  TString *varname;\n  BlockCnt bl;\n  enterblock(fs, &bl, 1);  /* scope for loop and control variables */\n  luaX_next(ls);  /* skip 'for' */\n  varname = str_checkname(ls);  /* first variable name */\n  switch (ls->t.token) {\n    case '=': fornum(ls, varname, line); break;\n    case ',': case TK_IN: forlist(ls, varname); break;\n    default: luaX_syntaxerror(ls, \"'=' or 'in' expected\");\n  }\n  check_match(ls, TK_END, TK_FOR, line);\n  leaveblock(fs);  /* loop scope ('break' jumps to this point) */\n}\n\n\nstatic void test_then_block (LexState *ls, int *escapelist) {\n  /* test_then_block -> [IF | ELSEIF] cond THEN block */\n  BlockCnt bl;\n  FuncState *fs = ls->fs;\n  expdesc v;\n  int jf;  /* instruction to skip 'then' code (if condition is false) */\n  luaX_next(ls);  /* skip IF or ELSEIF */\n  expr(ls, &v);  /* read condition */\n  checknext(ls, TK_THEN);\n  if (ls->t.token == TK_BREAK) {  /* 'if x then break' ? */\n    int line = ls->linenumber;\n    luaK_goiffalse(ls->fs, &v);  /* will jump if condition is true */\n    luaX_next(ls);  /* skip 'break' */\n    enterblock(fs, &bl, 0);  /* must enter block before 'goto' */\n    newgotoentry(ls, luaS_newliteral(ls->L, \"break\"), line, v.t);\n    while (testnext(ls, ';')) {}  /* skip semicolons */\n    if (block_follow(ls, 0)) {  /* jump is the entire block? */\n      leaveblock(fs);\n      return;  /* and that is it */\n    }\n    else  /* must skip over 'then' part if condition is false */\n      jf = luaK_jump(fs);\n  }\n  else {  /* regular case (not a break) */\n    luaK_goiftrue(ls->fs, &v);  /* skip over block if condition is false */\n    enterblock(fs, &bl, 0);\n    jf = v.f;\n  }\n  statlist(ls);  /* 'then' part */\n  leaveblock(fs);\n  if (ls->t.token == TK_ELSE ||\n      ls->t.token == TK_ELSEIF)  /* followed by 'else'/'elseif'? */\n    luaK_concat(fs, escapelist, luaK_jump(fs));  /* must jump over it */\n  luaK_patchtohere(fs, jf);\n}\n\n\nstatic void ifstat (LexState *ls, int line) {\n  /* ifstat -> IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END */\n  FuncState *fs = ls->fs;\n  int escapelist = NO_JUMP;  /* exit list for finished parts */\n  test_then_block(ls, &escapelist);  /* IF cond THEN block */\n  while (ls->t.token == TK_ELSEIF)\n    test_then_block(ls, &escapelist);  /* ELSEIF cond THEN block */\n  if (testnext(ls, TK_ELSE))\n    block(ls);  /* 'else' part */\n  check_match(ls, TK_END, TK_IF, line);\n  luaK_patchtohere(fs, escapelist);  /* patch escape list to 'if' end */\n}\n\n\nstatic void localfunc (LexState *ls) {\n  expdesc b;\n  FuncState *fs = ls->fs;\n  int fvar = fs->nactvar;  /* function's variable index */\n  new_localvar(ls, str_checkname(ls));  /* new local variable */\n  adjustlocalvars(ls, 1);  /* enter its scope */\n  body(ls, &b, 0, ls->linenumber);  /* function created in next register */\n  /* debug information will only see the variable after this point! */\n  localdebuginfo(fs, fvar)->startpc = fs->pc;\n}\n\n\nstatic int getlocalattribute (LexState *ls) {\n  /* ATTRIB -> ['<' Name '>'] */\n  if (testnext(ls, '<')) {\n    const char *attr = getstr(str_checkname(ls));\n    checknext(ls, '>');\n    if (strcmp(attr, \"const\") == 0)\n      return RDKCONST;  /* read-only variable */\n    else if (strcmp(attr, \"close\") == 0)\n      return RDKTOCLOSE;  /* to-be-closed variable */\n    else\n      luaK_semerror(ls,\n        luaO_pushfstring(ls->L, \"unknown attribute '%s'\", attr));\n  }\n  return VDKREG;  /* regular variable */\n}\n\n\nstatic void checktoclose (FuncState *fs, int level) {\n  if (level != -1) {  /* is there a to-be-closed variable? */\n    marktobeclosed(fs);\n    luaK_codeABC(fs, OP_TBC, reglevel(fs, level), 0, 0);\n  }\n}\n\n\nstatic void localstat (LexState *ls) {\n  /* stat -> LOCAL NAME ATTRIB { ',' NAME ATTRIB } ['=' explist] */\n  FuncState *fs = ls->fs;\n  int toclose = -1;  /* index of to-be-closed variable (if any) */\n  Vardesc *var;  /* last variable */\n  int vidx, kind;  /* index and kind of last variable */\n  int nvars = 0;\n  int nexps;\n  expdesc e;\n  do {\n    vidx = new_localvar(ls, str_checkname(ls));\n    kind = getlocalattribute(ls);\n    getlocalvardesc(fs, vidx)->vd.kind = kind;\n    if (kind == RDKTOCLOSE) {  /* to-be-closed? */\n      if (toclose != -1)  /* one already present? */\n        luaK_semerror(ls, \"multiple to-be-closed variables in local list\");\n      toclose = fs->nactvar + nvars;\n    }\n    nvars++;\n  } while (testnext(ls, ','));\n  if (testnext(ls, '='))\n    nexps = explist(ls, &e);\n  else {\n    e.k = VVOID;\n    nexps = 0;\n  }\n  var = getlocalvardesc(fs, vidx);  /* get last variable */\n  if (nvars == nexps &&  /* no adjustments? */\n      var->vd.kind == RDKCONST &&  /* last variable is const? */\n      luaK_exp2const(fs, &e, &var->k)) {  /* compile-time constant? */\n    var->vd.kind = RDKCTC;  /* variable is a compile-time constant */\n    adjustlocalvars(ls, nvars - 1);  /* exclude last variable */\n    fs->nactvar++;  /* but count it */\n  }\n  else {\n    adjust_assign(ls, nvars, nexps, &e);\n    adjustlocalvars(ls, nvars);\n  }\n  checktoclose(fs, toclose);\n}\n\n\nstatic int funcname (LexState *ls, expdesc *v) {\n  /* funcname -> NAME {fieldsel} [':' NAME] */\n  int ismethod = 0;\n  singlevar(ls, v);\n  while (ls->t.token == '.')\n    fieldsel(ls, v);\n  if (ls->t.token == ':') {\n    ismethod = 1;\n    fieldsel(ls, v);\n  }\n  return ismethod;\n}\n\n\nstatic void funcstat (LexState *ls, int line) {\n  /* funcstat -> FUNCTION funcname body */\n  int ismethod;\n  expdesc v, b;\n  luaX_next(ls);  /* skip FUNCTION */\n  ismethod = funcname(ls, &v);\n  body(ls, &b, ismethod, line);\n  check_readonly(ls, &v);\n  luaK_storevar(ls->fs, &v, &b);\n  luaK_fixline(ls->fs, line);  /* definition \"happens\" in the first line */\n}\n\n\nstatic void exprstat (LexState *ls) {\n  /* stat -> func | assignment */\n  FuncState *fs = ls->fs;\n  struct LHS_assign v;\n  suffixedexp(ls, &v.v);\n  if (ls->t.token == '=' || ls->t.token == ',') { /* stat -> assignment ? */\n    v.prev = NULL;\n    restassign(ls, &v, 1);\n  }\n  else {  /* stat -> func */\n    Instruction *inst;\n    check_condition(ls, v.v.k == VCALL, \"syntax error\");\n    inst = &getinstruction(fs, &v.v);\n    SETARG_C(*inst, 1);  /* call statement uses no results */\n  }\n}\n\n\nstatic void retstat (LexState *ls) {\n  /* stat -> RETURN [explist] [';'] */\n  FuncState *fs = ls->fs;\n  expdesc e;\n  int nret;  /* number of values being returned */\n  int first = luaY_nvarstack(fs);  /* first slot to be returned */\n  if (block_follow(ls, 1) || ls->t.token == ';')\n    nret = 0;  /* return no values */\n  else {\n    nret = explist(ls, &e);  /* optional return values */\n    if (hasmultret(e.k)) {\n      luaK_setmultret(fs, &e);\n      if (e.k == VCALL && nret == 1 && !fs->bl->insidetbc) {  /* tail call? */\n        SET_OPCODE(getinstruction(fs,&e), OP_TAILCALL);\n        lua_assert(GETARG_A(getinstruction(fs,&e)) == luaY_nvarstack(fs));\n      }\n      nret = LUA_MULTRET;  /* return all values */\n    }\n    else {\n      if (nret == 1)  /* only one single value? */\n        first = luaK_exp2anyreg(fs, &e);  /* can use original slot */\n      else {  /* values must go to the top of the stack */\n        luaK_exp2nextreg(fs, &e);\n        lua_assert(nret == fs->freereg - first);\n      }\n    }\n  }\n  luaK_ret(fs, first, nret);\n  testnext(ls, ';');  /* skip optional semicolon */\n}\n\n\nstatic void statement (LexState *ls) {\n  int line = ls->linenumber;  /* may be needed for error messages */\n  enterlevel(ls);\n  switch (ls->t.token) {\n    case ';': {  /* stat -> ';' (empty statement) */\n      luaX_next(ls);  /* skip ';' */\n      break;\n    }\n    case TK_IF: {  /* stat -> ifstat */\n      ifstat(ls, line);\n      break;\n    }\n    case TK_WHILE: {  /* stat -> whilestat */\n      whilestat(ls, line);\n      break;\n    }\n    case TK_DO: {  /* stat -> DO block END */\n      luaX_next(ls);  /* skip DO */\n      block(ls);\n      check_match(ls, TK_END, TK_DO, line);\n      break;\n    }\n    case TK_FOR: {  /* stat -> forstat */\n      forstat(ls, line);\n      break;\n    }\n    case TK_REPEAT: {  /* stat -> repeatstat */\n      repeatstat(ls, line);\n      break;\n    }\n    case TK_FUNCTION: {  /* stat -> funcstat */\n      funcstat(ls, line);\n      break;\n    }\n    case TK_LOCAL: {  /* stat -> localstat */\n      luaX_next(ls);  /* skip LOCAL */\n      if (testnext(ls, TK_FUNCTION))  /* local function? */\n        localfunc(ls);\n      else\n        localstat(ls);\n      break;\n    }\n    case TK_DBCOLON: {  /* stat -> label */\n      luaX_next(ls);  /* skip double colon */\n      labelstat(ls, str_checkname(ls), line);\n      break;\n    }\n    case TK_RETURN: {  /* stat -> retstat */\n      luaX_next(ls);  /* skip RETURN */\n      retstat(ls);\n      break;\n    }\n    case TK_BREAK: {  /* stat -> breakstat */\n      breakstat(ls);\n      break;\n    }\n    case TK_GOTO: {  /* stat -> 'goto' NAME */\n      luaX_next(ls);  /* skip 'goto' */\n      gotostat(ls);\n      break;\n    }\n    default: {  /* stat -> func | assignment */\n      exprstat(ls);\n      break;\n    }\n  }\n  lua_assert(ls->fs->f->maxstacksize >= ls->fs->freereg &&\n             ls->fs->freereg >= luaY_nvarstack(ls->fs));\n  ls->fs->freereg = luaY_nvarstack(ls->fs);  /* free registers */\n  leavelevel(ls);\n}\n\n/* }====================================================================== */\n\n\n/*\n** compiles the main function, which is a regular vararg function with an\n** upvalue named LUA_ENV\n*/\nstatic void mainfunc (LexState *ls, FuncState *fs) {\n  BlockCnt bl;\n  Upvaldesc *env;\n  open_func(ls, fs, &bl);\n  setvararg(fs, 0);  /* main function is always declared vararg */\n  env = allocupvalue(fs);  /* ...set environment upvalue */\n  env->instack = 1;\n  env->idx = 0;\n  env->kind = VDKREG;\n  env->name = ls->envn;\n  luaC_objbarrier(ls->L, fs->f, env->name);\n  luaX_next(ls);  /* read first token */\n  statlist(ls);  /* parse main body */\n  check(ls, TK_EOS);\n  close_func(ls);\n}\n\n\nLClosure *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff,\n                       Dyndata *dyd, const char *name, int firstchar) {\n  LexState lexstate;\n  FuncState funcstate;\n  LClosure *cl = luaF_newLclosure(L, 1);  /* create main closure */\n  setclLvalue2s(L, L->top, cl);  /* anchor it (to avoid being collected) */\n  luaD_inctop(L);\n  lexstate.h = luaH_new(L);  /* create table for scanner */\n  sethvalue2s(L, L->top, lexstate.h);  /* anchor it */\n  luaD_inctop(L);\n  funcstate.f = cl->p = luaF_newproto(L);\n  luaC_objbarrier(L, cl, cl->p);\n  funcstate.f->source = luaS_new(L, name);  /* create and anchor TString */\n  luaC_objbarrier(L, funcstate.f, funcstate.f->source);\n  lexstate.buff = buff;\n  lexstate.dyd = dyd;\n  dyd->actvar.n = dyd->gt.n = dyd->label.n = 0;\n  luaX_setinput(L, &lexstate, z, funcstate.f->source, firstchar);\n  mainfunc(&lexstate, &funcstate);\n  lua_assert(!funcstate.prev && funcstate.nups == 1 && !lexstate.fs);\n  /* all scopes should be correctly finished */\n  lua_assert(dyd->actvar.n == 0 && dyd->gt.n == 0 && dyd->label.n == 0);\n  L->top--;  /* remove scanner's table */\n  return cl;  /* closure is on the stack, too */\n}\n\n", "-- $Id: testes/attrib.lua $\n-- See Copyright Notice in file all.lua\n\nprint \"testing require\"\n\nassert(require\"string\" == string)\nassert(require\"math\" == math)\nassert(require\"table\" == table)\nassert(require\"io\" == io)\nassert(require\"os\" == os)\nassert(require\"coroutine\" == coroutine)\n\nassert(type(package.path) == \"string\")\nassert(type(package.cpath) == \"string\")\nassert(type(package.loaded) == \"table\")\nassert(type(package.preload) == \"table\")\n\nassert(type(package.config) == \"string\")\nprint(\"package config: \"..string.gsub(package.config, \"\\n\", \"|\"))\n\ndo\n  -- create a path with 'max' templates,\n  -- each with 1-10 repetitions of '?'\n  local max = _soft and 100 or 2000\n  local t = {}\n  for i = 1,max do t[i] = string.rep(\"?\", i%10 + 1) end\n  t[#t + 1] = \";\"    -- empty template\n  local path = table.concat(t, \";\")\n  -- use that path in a search\n  local s, err = package.searchpath(\"xuxu\", path)\n  -- search fails; check that message has an occurrence of\n  -- '??????????' with ? replaced by xuxu and at least 'max' lines\n  assert(not s and\n         string.find(err, string.rep(\"xuxu\", 10)) and\n         #string.gsub(err, \"[^\\n]\", \"\") >= max)\n  -- path with one very long template\n  local path = string.rep(\"?\", max)\n  local s, err = package.searchpath(\"xuxu\", path)\n  assert(not s and string.find(err, string.rep('xuxu', max)))\nend\n\ndo\n  local oldpath = package.path\n  package.path = {}\n  local s, err = pcall(require, \"no-such-file\")\n  assert(not s and string.find(err, \"package.path\"))\n  package.path = oldpath\nend\n\n\ndo  print\"testing 'require' message\"\n  local oldpath = package.path\n  local oldcpath = package.cpath\n\n  package.path = \"?.lua;?/?\"\n  package.cpath = \"?.so;?/init\"\n\n  local st, msg = pcall(require, 'XXX')\n\n  local expected = [[module 'XXX' not found:\n\tno field package.preload['XXX']\n\tno file 'XXX.lua'\n\tno file 'XXX/XXX'\n\tno file 'XXX.so'\n\tno file 'XXX/init']]\n\n  assert(msg == expected)\n\n  package.path = oldpath\n  package.cpath = oldcpath\nend\n\nprint('+')\n\n\n-- The next tests for 'require' assume some specific directories and\n-- libraries.\n\nif not _port then --[\n\nlocal dirsep = string.match(package.config, \"^([^\\n]+)\\n\")\n\n-- auxiliary directory with C modules and temporary files\nlocal DIR = \"libs\" .. dirsep\n\n-- prepend DIR to a name and correct directory separators\nlocal function D (x)\n  x = string.gsub(x, \"/\", dirsep)\n  return DIR .. x\nend\n\n-- prepend DIR and pospend proper C lib. extension to a name\nlocal function DC (x)\n  local ext = (dirsep == '\\\\') and \".dll\" or \".so\"\n  return D(x .. ext)\nend\n\n\nlocal function createfiles (files, preextras, posextras)\n  for n,c in pairs(files) do\n    io.output(D(n))\n    io.write(string.format(preextras, n))\n    io.write(c)\n    io.write(string.format(posextras, n))\n    io.close(io.output())\n  end\nend\n\nfunction removefiles (files)\n  for n in pairs(files) do\n    os.remove(D(n))\n  end\nend\n\nlocal files = {\n  [\"names.lua\"] = \"do return {...} end\\n\",\n  [\"err.lua\"] = \"B = 15; a = a + 1;\",\n  [\"synerr.lua\"] = \"B =\",\n  [\"A.lua\"] = \"\",\n  [\"B.lua\"] = \"assert(...=='B');require 'A'\",\n  [\"A.lc\"] = \"\",\n  [\"A\"] = \"\",\n  [\"L\"] = \"\",\n  [\"XXxX\"] = \"\",\n  [\"C.lua\"] = \"package.loaded[...] = 25; require'C'\",\n}\n\nAA = nil\nlocal extras = [[\nNAME = '%s'\nREQUIRED = ...\nreturn AA]]\n\ncreatefiles(files, \"\", extras)\n\n-- testing explicit \"dir\" separator in 'searchpath'\nassert(package.searchpath(\"C.lua\", D\"?\", \"\", \"\") == D\"C.lua\")\nassert(package.searchpath(\"C.lua\", D\"?\", \".\", \".\") == D\"C.lua\")\nassert(package.searchpath(\"--x-\", D\"?\", \"-\", \"X\") == D\"XXxX\")\nassert(package.searchpath(\"---xX\", D\"?\", \"---\", \"XX\") == D\"XXxX\")\nassert(package.searchpath(D\"C.lua\", \"?\", dirsep) == D\"C.lua\")\nassert(package.searchpath(\".\\\\C.lua\", D\"?\", \"\\\\\") == D\"./C.lua\")\n\nlocal oldpath = package.path\n\npackage.path = string.gsub(\"D/?.lua;D/?.lc;D/?;D/??x?;D/L\", \"D/\", DIR)\n\nlocal try = function (p, n, r, ext)\n  NAME = nil\n  local rr, x = require(p)\n  assert(NAME == n)\n  assert(REQUIRED == p)\n  assert(rr == r)\n  assert(ext == x)\nend\n\na = require\"names\"\nassert(a[1] == \"names\" and a[2] == D\"names.lua\")\n\n_G.a = nil\nlocal st, msg = pcall(require, \"err\")\nassert(not st and string.find(msg, \"arithmetic\") and B == 15)\nst, msg = pcall(require, \"synerr\")\nassert(not st and string.find(msg, \"error loading module\"))\n\nassert(package.searchpath(\"C\", package.path) == D\"C.lua\")\nassert(require\"C\" == 25)\nassert(require\"C\" == 25)\nAA = nil\ntry('B', 'B.lua', true, \"libs/B.lua\")\nassert(package.loaded.B)\nassert(require\"B\" == true)\nassert(package.loaded.A)\nassert(require\"C\" == 25)\npackage.loaded.A = nil\ntry('B', nil, true, nil)   -- should not reload package\ntry('A', 'A.lua', true, \"libs/A.lua\")\npackage.loaded.A = nil\nos.remove(D'A.lua')\nAA = {}\ntry('A', 'A.lc', AA, \"libs/A.lc\")  -- now must find second option\nassert(package.searchpath(\"A\", package.path) == D\"A.lc\")\nassert(require(\"A\") == AA)\nAA = false\ntry('K', 'L', false, \"libs/L\")     -- default option\ntry('K', 'L', false, \"libs/L\")     -- default option (should reload it)\nassert(rawget(_G, \"_REQUIREDNAME\") == nil)\n\nAA = \"x\"\ntry(\"X\", \"XXxX\", AA, \"libs/XXxX\")\n\n\nremovefiles(files)\n\n\n-- testing require of sub-packages\n\nlocal _G = _G\n\npackage.path = string.gsub(\"D/?.lua;D/?/init.lua\", \"D/\", DIR)\n\nfiles = {\n  [\"P1/init.lua\"] = \"AA = 10\",\n  [\"P1/xuxu.lua\"] = \"AA = 20\",\n}\n\ncreatefiles(files, \"_ENV = {}\\n\", \"\\nreturn _ENV\\n\")\nAA = 0\n\nlocal m, ext = assert(require\"P1\")\nassert(ext == \"libs/P1/init.lua\")\nassert(AA == 0 and m.AA == 10)\nassert(require\"P1\" == m)\nassert(require\"P1\" == m)\n\nassert(package.searchpath(\"P1.xuxu\", package.path) == D\"P1/xuxu.lua\")\nm.xuxu, ext = assert(require\"P1.xuxu\")\nassert(AA == 0 and m.xuxu.AA == 20)\nassert(ext == \"libs/P1/xuxu.lua\")\nassert(require\"P1.xuxu\" == m.xuxu)\nassert(require\"P1.xuxu\" == m.xuxu)\nassert(require\"P1\" == m and m.AA == 10)\n\n\nremovefiles(files)\n\n\npackage.path = \"\"\nassert(not pcall(require, \"file_does_not_exist\"))\npackage.path = \"??\\0?\"\nassert(not pcall(require, \"file_does_not_exist1\"))\n\npackage.path = oldpath\n\n-- check 'require' error message\nlocal fname = \"file_does_not_exist2\"\nlocal m, err = pcall(require, fname)\nfor t in string.gmatch(package.path..\";\"..package.cpath, \"[^;]+\") do\n  t = string.gsub(t, \"?\", fname)\n  assert(string.find(err, t, 1, true))\nend\n\ndo  -- testing 'package.searchers' not being a table\n  local searchers = package.searchers\n  package.searchers = 3\n  local st, msg = pcall(require, 'a')\n  assert(not st and string.find(msg, \"must be a table\"))\n  package.searchers = searchers\nend\n\nlocal function import(...)\n  local f = {...}\n  return function (m)\n    for i=1, #f do m[f[i]] = _G[f[i]] end\n  end\nend\n\n-- cannot change environment of a C function\nassert(not pcall(module, 'XUXU'))\n\n\n\n-- testing require of C libraries\n\n\nlocal p = \"\"   -- On Mac OS X, redefine this to \"_\"\n\n-- check whether loadlib works in this system\nlocal st, err, when = package.loadlib(DC\"lib1\", \"*\")\nif not st then\n  local f, err, when = package.loadlib(\"donotexist\", p..\"xuxu\")\n  assert(not f and type(err) == \"string\" and when == \"absent\")\n  ;(Message or print)('\\n >>> cannot load dynamic library <<<\\n')\n  print(err, when)\nelse\n  -- tests for loadlib\n  local f = assert(package.loadlib(DC\"lib1\", p..\"onefunction\"))\n  local a, b = f(15, 25)\n  assert(a == 25 and b == 15)\n\n  f = assert(package.loadlib(DC\"lib1\", p..\"anotherfunc\"))\n  assert(f(10, 20) == \"10%20\\n\")\n\n  -- check error messages\n  local f, err, when = package.loadlib(DC\"lib1\", p..\"xuxu\")\n  assert(not f and type(err) == \"string\" and when == \"init\")\n  f, err, when = package.loadlib(\"donotexist\", p..\"xuxu\")\n  assert(not f and type(err) == \"string\" and when == \"open\")\n\n  -- symbols from 'lib1' must be visible to other libraries\n  f = assert(package.loadlib(DC\"lib11\", p..\"luaopen_lib11\"))\n  assert(f() == \"exported\")\n\n  -- test C modules with prefixes in names\n  package.cpath = DC\"?\"\n  local lib2, ext = require\"lib2-v2\"\n  assert(string.find(ext, \"libs/lib2-v2\", 1, true))\n  -- check correct access to global environment and correct\n  -- parameters\n  assert(_ENV.x == \"lib2-v2\" and _ENV.y == DC\"lib2-v2\")\n  assert(lib2.id(\"x\") == true)   -- a different \"id\" implementation\n\n  -- test C submodules\n  local fs, ext = require\"lib1.sub\"\n  assert(_ENV.x == \"lib1.sub\" and _ENV.y == DC\"lib1\")\n  assert(string.find(ext, \"libs/lib1\", 1, true))\n  assert(fs.id(45) == 45)\nend\n\n_ENV = _G\n\n\n-- testing preload\n\ndo\n  local p = package\n  package = {}\n  p.preload.pl = function (...)\n    local _ENV = {...}\n    function xuxu (x) return x+20 end\n    return _ENV\n  end\n\n  local pl, ext = require\"pl\"\n  assert(require\"pl\" == pl)\n  assert(pl.xuxu(10) == 30)\n  assert(pl[1] == \"pl\" and pl[2] == \":preload:\" and ext == \":preload:\")\n\n  package = p\n  assert(type(package.path) == \"string\")\nend\n\nprint('+')\n\nend  --]\n\nprint(\"testing assignments, logical operators, and constructors\")\n\nlocal res, res2 = 27\n\na, b = 1, 2+3\nassert(a==1 and b==5)\na={}\nfunction f() return 10, 11, 12 end\na.x, b, a[1] = 1, 2, f()\nassert(a.x==1 and b==2 and a[1]==10)\na[f()], b, a[f()+3] = f(), a, 'x'\nassert(a[10] == 10 and b == a and a[13] == 'x')\n\ndo\n  local f = function (n) local x = {}; for i=1,n do x[i]=i end;\n                         return table.unpack(x) end;\n  local a,b,c\n  a,b = 0, f(1)\n  assert(a == 0 and b == 1)\n  A,b = 0, f(1)\n  assert(A == 0 and b == 1)\n  a,b,c = 0,5,f(4)\n  assert(a==0 and b==5 and c==1)\n  a,b,c = 0,5,f(0)\n  assert(a==0 and b==5 and c==nil)\nend\n\na, b, c, d = 1 and nil, 1 or nil, (1 and (nil or 1)), 6\nassert(not a and b and c and d==6)\n\nd = 20\na, b, c, d = f()\nassert(a==10 and b==11 and c==12 and d==nil)\na,b = f(), 1, 2, 3, f()\nassert(a==10 and b==1)\n\nassert(a<b == false and a>b == true)\nassert((10 and 2) == 2)\nassert((10 or 2) == 10)\nassert((10 or assert(nil)) == 10)\nassert(not (nil and assert(nil)))\nassert((nil or \"alo\") == \"alo\")\nassert((nil and 10) == nil)\nassert((false and 10) == false)\nassert((true or 10) == true)\nassert((false or 10) == 10)\nassert(false ~= nil)\nassert(nil ~= false)\nassert(not nil == true)\nassert(not not nil == false)\nassert(not not 1 == true)\nassert(not not a == true)\nassert(not not (6 or nil) == true)\nassert(not not (nil and 56) == false)\nassert(not not (nil and true) == false)\nassert(not 10 == false)\nassert(not {} == false)\nassert(not 0.5 == false)\nassert(not \"x\" == false)\n\nassert({} ~= {})\nprint('+')\n\na = {}\na[true] = 20\na[false] = 10\nassert(a[1<2] == 20 and a[1>2] == 10)\n\nfunction f(a) return a end\n\nlocal a = {}\nfor i=3000,-3000,-1 do a[i + 0.0] = i; end\na[10e30] = \"alo\"; a[true] = 10; a[false] = 20\nassert(a[10e30] == 'alo' and a[not 1] == 20 and a[10<20] == 10)\nfor i=3000,-3000,-1 do assert(a[i] == i); end\na[print] = assert\na[f] = print\na[a] = a\nassert(a[a][a][a][a][print] == assert)\na[print](a[a[f]] == a[print])\nassert(not pcall(function () local a = {}; a[nil] = 10 end))\nassert(not pcall(function () local a = {[nil] = 10} end))\nassert(a[nil] == undef)\na = nil\n\na = {10,9,8,7,6,5,4,3,2; [-3]='a', [f]=print, a='a', b='ab'}\na, a.x, a.y = a, a[-3]\nassert(a[1]==10 and a[-3]==a.a and a[f]==print and a.x=='a' and not a.y)\na[1], f(a)[2], b, c = {['alo']=assert}, 10, a[1], a[f], 6, 10, 23, f(a), 2\na[1].alo(a[2]==10 and b==10 and c==print)\n\na.aVeryLongName012345678901234567890123456789012345678901234567890123456789 = 10\nlocal function foo ()\n  return a.aVeryLongName012345678901234567890123456789012345678901234567890123456789\nend\nassert(foo() == 10 and\na.aVeryLongName012345678901234567890123456789012345678901234567890123456789 ==\n10)\n\n\ndo\n  -- _ENV constant\n  local function foo ()\n    local _ENV <const> = 11\n    X = \"hi\"\n  end\n  local st, msg = pcall(foo)\n  assert(not st and string.find(msg, \"number\"))\nend\n\n\n-- test of large float/integer indices \n\n-- compute maximum integer where all bits fit in a float\nlocal maxint = math.maxinteger\n\n-- trim (if needed) to fit in a float\nwhile maxint ~= (maxint + 0.0) or (maxint - 1) ~= (maxint - 1.0) do\n  maxint = maxint // 2\nend\n\nmaxintF = maxint + 0.0   -- float version\n\nassert(maxintF == maxint and math.type(maxintF) == \"float\" and\n       maxintF >= 2.0^14)\n\n-- floats and integers must index the same places\na[maxintF] = 10; a[maxintF - 1.0] = 11;\na[-maxintF] = 12; a[-maxintF + 1.0] = 13;\n\nassert(a[maxint] == 10 and a[maxint - 1] == 11 and\n       a[-maxint] == 12 and a[-maxint + 1] == 13)\n\na[maxint] = 20\na[-maxint] = 22\n\nassert(a[maxintF] == 20 and a[maxintF - 1.0] == 11 and\n       a[-maxintF] == 22 and a[-maxintF + 1.0] == 13)\n\na = nil\n\n\n-- test conflicts in multiple assignment\ndo\n  local a,i,j,b\n  a = {'a', 'b'}; i=1; j=2; b=a\n  i, a[i], a, j, a[j], a[i+j] = j, i, i, b, j, i\n  assert(i == 2 and b[1] == 1 and a == 1 and j == b and b[2] == 2 and\n         b[3] == 1)\n  a = {}\n  local function foo ()    -- assigining to upvalues\n    b, a.x, a = a, 10, 20\n  end\n  foo()\n  assert(a == 20 and b.x == 10)\nend\n\n-- repeat test with upvalues\ndo\n  local a,i,j,b\n  a = {'a', 'b'}; i=1; j=2; b=a\n  local function foo ()\n    i, a[i], a, j, a[j], a[i+j] = j, i, i, b, j, i\n  end\n  foo()\n  assert(i == 2 and b[1] == 1 and a == 1 and j == b and b[2] == 2 and\n         b[3] == 1)\n  local t = {}\n  (function (a) t[a], a = 10, 20  end)(1);\n  assert(t[1] == 10)\nend\n\n-- bug in 5.2 beta\nlocal function foo ()\n  local a\n  return function ()\n    local b\n    a, b = 3, 14    -- local and upvalue have same index\n    return a, b\n  end\nend\n\nlocal a, b = foo()()\nassert(a == 3 and b == 14)\n\nprint('OK')\n\nreturn res\n\n"], "filenames": ["lparser.c", "testes/attrib.lua"], "buggy_code_start_loc": [470, 436], "buggy_code_end_loc": [470, 436], "fixing_code_start_loc": [471, 437], "fixing_code_end_loc": [472, 447], "type": "CWE-125", "message": "singlevar in lparser.c in Lua from (including) 5.4.0 up to (excluding) 5.4.4 lacks a certain luaK_exp2anyregup call, leading to a heap-based buffer over-read that might affect a system that compiles untrusted Lua code.", "other": {"cve": {"id": "CVE-2022-28805", "sourceIdentifier": "cve@mitre.org", "published": "2022-04-08T06:15:07.243", "lastModified": "2023-05-03T12:15:40.180", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "singlevar in lparser.c in Lua from (including) 5.4.0 up to (excluding) 5.4.4 lacks a certain luaK_exp2anyregup call, leading to a heap-based buffer over-read that might affect a system that compiles untrusted Lua code."}, {"lang": "es", "value": "singlevar en lparser.c en Lua desde (incluyendo) 5.4.0 hasta (excluyendo) 5.4.4 carece de una determinada llamada a luaK_exp2anyregup, lo que lleva a una sobrelectura del b\u00fafer basada en la pila que podr\u00eda afectar a un sistema que compila c\u00f3digo Lua no fiable"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:lua:lua:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.4.0", "versionEndIncluding": "5.4.4", "matchCriteriaId": "76830514-E848-4FD7-9FBD-2C29C5336981"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}], "references": [{"url": "https://github.com/lua/lua/commit/1f3c6f4534c6411313361697d98d1145a1f030fa", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/RJNJ66IFDUKWJJZXHGOLRGIA3HWWC36R/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/UHYZOEFDVLVAD6EEP4CDW6DNONIVVHPA/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lua-users.org/lists/lua-l/2022-02/msg00001.html", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}, {"url": "https://lua-users.org/lists/lua-l/2022-02/msg00070.html", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}, {"url": "https://lua-users.org/lists/lua-l/2022-04/msg00009.html", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202305-23", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/lua/lua/commit/1f3c6f4534c6411313361697d98d1145a1f030fa"}}