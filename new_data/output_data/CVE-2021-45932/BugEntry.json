{"buggy_code": ["/* mqtt_client.c\n *\n * Copyright (C) 2006-2021 wolfSSL Inc.\n *\n * This file is part of wolfMQTT.\n *\n * wolfMQTT is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * wolfMQTT is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335, USA\n */\n\n/* Include the autoconf generated config.h */\n#ifdef HAVE_CONFIG_H\n    #include <config.h>\n#endif\n\n#include \"wolfmqtt/mqtt_client.h\"\n\n/* Options */\n#ifdef WOLFMQTT_NO_STDIO\n    #undef WOLFMQTT_DEBUG_CLIENT\n#endif\n\n/* Private functions */\n\n/* forward declarations */\nstatic int MqttClient_Publish_ReadPayload(MqttClient* client,\n    MqttPublish* publish, int timeout_ms);\n\n#ifdef WOLFMQTT_MULTITHREAD\n\n#ifdef __MACH__\n    /* Apple style dispatch semaphore */\n    int wm_SemInit(wm_Sem *s){\n        /* dispatch_release() fails hard, with Trace/BPT trap signal, if the\n         * sem's internal count is less than the value passed in with\n         * dispatch_semaphore_create().  work around this by initing\n         * with 0, then incrementing it afterwards.\n         */\n        *s = dispatch_semaphore_create(0);\n        if (*s == NULL)\n            return MQTT_CODE_ERROR_MEMORY;\n        if (dispatch_semaphore_signal(*s) < 0) {\n            dispatch_release(*s);\n            return MQTT_CODE_ERROR_SYSTEM;\n        }\n\n        return 0;\n    }\n    int wm_SemFree(wm_Sem *s){\n        if ((s == NULL) ||\n            (*s == NULL))\n            return MQTT_CODE_ERROR_BAD_ARG;\n        dispatch_release(*s);\n        *s = NULL;\n        return 0;\n    }\n    int wm_SemLock(wm_Sem *s){\n        dispatch_semaphore_wait(*s, DISPATCH_TIME_FOREVER);\n        return 0;\n    }\n    int wm_SemUnlock(wm_Sem *s){\n        dispatch_semaphore_signal(*s);\n        return 0;\n    }\n#elif defined(WOLFMQTT_POSIX_SEMAPHORES)\n    /* Posix style semaphore */\n    int wm_SemInit(wm_Sem *s){\n        s->lockCount = 0;\n        pthread_mutex_init(&s->mutex, NULL);\n        pthread_cond_init(&s->cond, NULL);\n        return 0;\n    }\n    int wm_SemFree(wm_Sem *s){\n        pthread_mutex_destroy(&s->mutex);\n        pthread_cond_destroy(&s->cond);\n        return 0;\n    }\n    int wm_SemLock(wm_Sem *s){\n        pthread_mutex_lock(&s->mutex);\n        while (s->lockCount > 0)\n            pthread_cond_wait(&s->cond, &s->mutex);\n        s->lockCount++;\n        pthread_mutex_unlock(&s->mutex);\n        return 0;\n    }\n    int wm_SemUnlock(wm_Sem *s){\n        pthread_mutex_lock(&s->mutex);\n        s->lockCount--;\n        pthread_cond_signal(&s->cond);\n        pthread_mutex_unlock(&s->mutex);\n        return 0;\n    }\n#elif defined(FREERTOS)\n    /* FreeRTOS binary semaphore */\n    int wm_SemInit(wm_Sem *s) {\n        *s = xSemaphoreCreateBinary();\n        xSemaphoreGive(*s);\n        return 0;\n    }\n    int wm_SemFree(wm_Sem *s) {\n        vSemaphoreDelete(*s);\n        *s = NULL;\n        return 0;\n    }\n    int wm_SemLock(wm_Sem *s) {\n        xSemaphoreTake(*s, portMAX_DELAY);\n        return 0;\n    }\n    int wm_SemUnlock(wm_Sem *s) {\n        xSemaphoreGive(*s);\n        return 0;\n    }\n#elif defined(USE_WINDOWS_API)\n    /* Windows semaphore object */\n    int wm_SemInit(wm_Sem *s) {\n        *s = CreateSemaphore( NULL, 0, 1, NULL);\n        return 0;\n    }\n    int wm_SemFree(wm_Sem *s) {\n        CloseHandle(*s);\n        *s = NULL;\n        return 0;\n    }\n    int wm_SemLock(wm_Sem *s) {\n        WaitForSingleObject(*s, 0);\n        return 0;\n    }\n    int wm_SemUnlock(wm_Sem *s) {\n        ReleaseSemaphore(*s, 1, NULL);\n        return 0;\n    }\n\n#endif\n\n/* These RespList functions assume caller has locked client->lockClient mutex */\nstatic int MqttClient_RespList_Add(MqttClient *client,\n    MqttPacketType packet_type, word16 packet_id, MqttPendResp *newResp,\n    void *packet_obj)\n{\n    MqttPendResp *tmpResp;\n\n    if (client == NULL)\n        return MQTT_CODE_ERROR_BAD_ARG;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"PendResp Add: %p, Type %s (%d), ID %d\",\n        newResp, MqttPacket_TypeDesc(packet_type), packet_type, packet_id);\n#endif\n\n    /* verify newResp is not already in the list */\n    for (tmpResp = client->firstPendResp;\n         tmpResp != NULL;\n         tmpResp = tmpResp->next)\n    {\n        if (tmpResp == newResp) {\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"Pending Response already in list!\");\n        #endif\n            return MQTT_CODE_ERROR_BAD_ARG;\n        }\n    }\n\n    /* Initialize new response */\n    XMEMSET(newResp, 0, sizeof(MqttPendResp));\n    newResp->packet_id = packet_id;\n    newResp->packet_type = packet_type;\n    /* opaque pointer to struct based on type */\n    newResp->packet_obj = packet_obj;\n\n    if (client->lastPendResp == NULL) {\n        /* This is the only list item */\n        client->firstPendResp = newResp;\n        client->lastPendResp = newResp;\n    }\n    else {\n        /* Append to end of list */\n        newResp->prev = client->lastPendResp;\n        client->lastPendResp->next = newResp;\n        client->lastPendResp = newResp;\n    }\n    return 0;\n}\n\nstatic void MqttClient_RespList_Remove(MqttClient *client, MqttPendResp *rmResp)\n{\n    MqttPendResp *tmpResp;\n\n    if (client == NULL)\n        return;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"PendResp Remove: %p\", rmResp);\n#endif\n\n    /* Find the response entry */\n    for (tmpResp = client->firstPendResp;\n         tmpResp != NULL;\n         tmpResp = tmpResp->next)\n    {\n        if (tmpResp == rmResp) {\n            break;\n        }\n    }\n    if (tmpResp) {\n        /* Fix up the first and last pointers */\n        if (client->firstPendResp == tmpResp) {\n            client->firstPendResp = tmpResp->next;\n        }\n        if (client->lastPendResp == tmpResp) {\n            client->lastPendResp = tmpResp->prev;\n        }\n\n        /* Remove the entry from the list */\n        if (tmpResp->next != NULL) {\n            tmpResp->next->prev = tmpResp->prev;\n        }\n        if (tmpResp->prev != NULL) {\n            tmpResp->prev->next = tmpResp->next;\n        }\n    }\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    else {\n        PRINTF(\"\\tPendResp Remove Failed\");\n    }\n#endif\n}\n\nstatic int MqttClient_RespList_Find(MqttClient *client,\n    MqttPacketType packet_type, word16 packet_id, MqttPendResp **retResp)\n{\n    int rc = 0;\n    MqttPendResp *tmpResp;\n\n    if (client == NULL)\n        return MQTT_CODE_ERROR_BAD_ARG;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"PendResp Find: Type %s (%d), ID %d\",\n        MqttPacket_TypeDesc(packet_type), packet_type, packet_id);\n#endif\n\n    if (retResp)\n        *retResp = NULL; /* clear */\n\n    /* Find pending response entry */\n    for (tmpResp = client->firstPendResp;\n         tmpResp != NULL;\n         tmpResp = tmpResp->next)\n    {\n        if (packet_type == tmpResp->packet_type &&\n           (packet_id == tmpResp->packet_id))\n        {\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"PendResp Found: %p, Type %s (%d), ID %d\",\n                tmpResp, MqttPacket_TypeDesc(tmpResp->packet_type),\n                tmpResp->packet_type, tmpResp->packet_id);\n        #endif\n\n            if (retResp)\n                *retResp = tmpResp;\n            rc = 1;\n            break;\n        }\n    }\n    return rc;\n}\n#endif /* WOLFMQTT_MULTITHREAD */\n\n/* Returns length decoded or error (as negative) */\n/*! \\brief      Take a received MQTT packet and try and decode it\n *  \\param      client       MQTT client context\n *  \\param      rx_buf       Incoming buffer data\n *  \\param      rx_len       Incoming buffer length\n *  \\param      p_decode     Opaque pointer to packet structure based on type\n *  \\param      ppacket_type Decoded packet type\n *  \\param      ppacket_qos  Decoded QoS level\n *  \\param      ppacket_id   Decoded packet id\n\n *  \\return     Returns length decoded or error (as negative) MQTT_CODE_ERROR_*\n                (see enum MqttPacketResponseCodes)\n */\nstatic int MqttClient_DecodePacket(MqttClient* client, byte* rx_buf,\n    word32 rx_len, void *packet_obj, MqttPacketType* ppacket_type,\n    MqttQoS* ppacket_qos, word16* ppacket_id)\n{\n    int rc = MQTT_CODE_SUCCESS;\n    MqttPacket* header;\n    MqttPacketType packet_type;\n    MqttQoS packet_qos;\n    word16 packet_id = 0;\n#ifdef WOLFMQTT_V5\n    MqttProp* props = NULL;\n#endif\n\n    /* must have rx buffer with at least 2 byes for header */\n    if (rx_buf == NULL || rx_len < MQTT_PACKET_HEADER_MIN_SIZE) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* Decode header */\n    header = (MqttPacket*)rx_buf;\n    packet_type = (MqttPacketType)MQTT_PACKET_TYPE_GET(header->type_flags);\n    if (ppacket_type) {\n        *ppacket_type = packet_type;\n    }\n    packet_qos = (MqttQoS)MQTT_PACKET_FLAGS_GET_QOS(header->type_flags);\n    if (ppacket_qos) {\n        *ppacket_qos = packet_qos;\n    }\n\n    /* Decode packet specific data (if requested) */\n    if (ppacket_id || packet_obj) {\n        switch (packet_type) {\n        case MQTT_PACKET_TYPE_CONNECT_ACK:\n        {\n            MqttConnectAck connect_ack, *p_connect_ack = &connect_ack;\n            if (packet_obj) {\n                p_connect_ack = (MqttConnectAck*)packet_obj;\n            }\n            else {\n                XMEMSET(p_connect_ack, 0, sizeof(MqttConnectAck));\n            }\n        #ifdef WOLFMQTT_V5\n            p_connect_ack->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_ConnectAck(rx_buf, rx_len, p_connect_ack);\n        #ifdef WOLFMQTT_V5\n            if (rc >= 0) {\n                props = p_connect_ack->props;\n            }\n        #endif\n            break;\n        }\n        case MQTT_PACKET_TYPE_PUBLISH:\n        {\n            MqttPublish publish, *p_publish = &publish;\n            if (packet_obj) {\n                p_publish = (MqttPublish*)packet_obj;\n            }\n            else {\n                XMEMSET(p_publish, 0, sizeof(MqttPublish));\n            }\n        #ifdef WOLFMQTT_V5\n            p_publish->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_Publish(rx_buf, rx_len, p_publish);\n            if (rc >= 0) {\n                packet_id = p_publish->packet_id;\n            #ifdef WOLFMQTT_V5\n                props = p_publish->props;\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_PUBLISH_ACK:\n        case MQTT_PACKET_TYPE_PUBLISH_REC:\n        case MQTT_PACKET_TYPE_PUBLISH_REL:\n        case MQTT_PACKET_TYPE_PUBLISH_COMP:\n        {\n            MqttPublishResp publish_resp, *p_publish_resp = &publish_resp;\n            if (packet_obj) {\n                p_publish_resp = (MqttPublishResp*)packet_obj;\n            }\n            else {\n                XMEMSET(p_publish_resp, 0, sizeof(MqttPublishResp));\n            }\n        #ifdef WOLFMQTT_V5\n                p_publish_resp->protocol_level = client->protocol_level;\n        #endif\n                rc = MqttDecode_PublishResp(rx_buf, rx_len, packet_type,\n                p_publish_resp);\n            if (rc >= 0) {\n                packet_id = p_publish_resp->packet_id;\n            #ifdef WOLFMQTT_V5\n                props = p_publish_resp->props;\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_SUBSCRIBE_ACK:\n        {\n            MqttSubscribeAck subscribe_ack, *p_subscribe_ack = &subscribe_ack;\n            if (packet_obj) {\n                p_subscribe_ack = (MqttSubscribeAck*)packet_obj;\n            }\n            else {\n                XMEMSET(p_subscribe_ack, 0, sizeof(MqttSubscribeAck));\n            }\n        #ifdef WOLFMQTT_V5\n            p_subscribe_ack->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_SubscribeAck(rx_buf, rx_len, p_subscribe_ack);\n            if (rc >= 0) {\n                packet_id = p_subscribe_ack->packet_id;\n            #ifdef WOLFMQTT_V5\n                props = p_subscribe_ack->props;\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_UNSUBSCRIBE_ACK:\n        {\n            MqttUnsubscribeAck unsubscribe_ack,\n                               *p_unsubscribe_ack = &unsubscribe_ack;\n            if (packet_obj) {\n                p_unsubscribe_ack = (MqttUnsubscribeAck*)packet_obj;\n            }\n            else {\n                XMEMSET(p_unsubscribe_ack, 0, sizeof(MqttUnsubscribeAck));\n            }\n        #ifdef WOLFMQTT_V5\n            p_unsubscribe_ack->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_UnsubscribeAck(rx_buf, rx_len, p_unsubscribe_ack);\n            if (rc >= 0) {\n                packet_id = p_unsubscribe_ack->packet_id;\n            #ifdef WOLFMQTT_V5\n                props = p_unsubscribe_ack->props;\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_PING_RESP:\n        {\n            MqttPing ping, *p_ping = &ping;\n            if (packet_obj) {\n                p_ping = (MqttPing*)packet_obj;\n            }\n            else {\n                XMEMSET(p_ping, 0, sizeof(MqttPing));\n            }\n            rc = MqttDecode_Ping(rx_buf, rx_len, p_ping);\n            break;\n        }\n        case MQTT_PACKET_TYPE_AUTH:\n        {\n        #ifdef WOLFMQTT_V5\n            MqttAuth auth, *p_auth = &auth;\n            if (packet_obj) {\n                p_auth = (MqttAuth*)packet_obj;\n            }\n            else {\n                XMEMSET(p_auth, 0, sizeof(MqttAuth));\n            }\n            rc = MqttDecode_Auth(rx_buf, rx_len, p_auth);\n            if (rc >= 0) {\n                props = p_auth->props;\n            }\n        #else\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n        #endif /* WOLFMQTT_V5 */\n            break;\n        }\n        case MQTT_PACKET_TYPE_DISCONNECT:\n        {\n        #ifdef WOLFMQTT_V5\n            MqttDisconnect disc, *p_disc = &disc;\n            if (packet_obj) {\n                p_disc = (MqttDisconnect*)packet_obj;\n            }\n            else {\n                XMEMSET(p_disc, 0, sizeof(MqttDisconnect));\n            }\n            rc = MqttDecode_Disconnect(rx_buf, rx_len, p_disc);\n            if (rc >= 0) {\n                props = p_disc->props;\n            }\n        #else\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n        #endif /* WOLFMQTT_V5 */\n            break;\n        }\n        case MQTT_PACKET_TYPE_CONNECT:\n        case MQTT_PACKET_TYPE_SUBSCRIBE:\n        case MQTT_PACKET_TYPE_UNSUBSCRIBE:\n        case MQTT_PACKET_TYPE_PING_REQ:\n        case MQTT_PACKET_TYPE_ANY:\n        case MQTT_PACKET_TYPE_RESERVED:\n        default:\n            /* these type are only encoded by client */\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n            break;\n        } /* switch (packet_type) */\n    }\n\n    if (ppacket_id) {\n        *ppacket_id = packet_id;\n    }\n\n#ifdef WOLFMQTT_V5\n    if (props) {\n    #ifdef WOLFMQTT_PROPERTY_CB\n        /* Check for properties set by the server */\n        if (packet_obj && client->property_cb) {\n            /* capture error if returned */\n            int rc_err = client->property_cb(client, props,\n                    client->property_ctx);\n            if (rc_err < 0) {\n                rc = rc_err;\n            }\n        }\n    #endif\n        /* Free the properties */\n        MqttProps_Free(props);\n    }\n#endif\n\n    (void)client;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_DecodePacket: Rc %d, Len %d, Type %s (%d), ID %d,\"\n            \" QoS %d\",\n        rc, rx_len, MqttPacket_TypeDesc(packet_type), packet_type, packet_id,\n        packet_qos);\n#endif\n\n    return rc;\n}\n\nstatic int MqttClient_HandlePacket(MqttClient* client,\n    MqttPacketType packet_type, void *packet_obj, int timeout_ms)\n{\n    int rc = MQTT_CODE_SUCCESS;\n    MqttQoS packet_qos = MQTT_QOS_0;\n    word16 packet_id = 0;\n\n    if (client == NULL || packet_obj == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    switch (packet_type)\n    {\n        case MQTT_PACKET_TYPE_CONNECT_ACK:\n        {\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, packet_obj, &packet_type, &packet_qos,\n                &packet_id);\n            break;\n        }\n        case MQTT_PACKET_TYPE_PUBLISH:\n        {\n            MqttPublish *publish = (MqttPublish*)packet_obj;\n            MqttPacketType resp_type;\n\n            if (publish->stat == MQTT_MSG_BEGIN ||\n                publish->stat == MQTT_MSG_READ) {\n                rc = MqttClient_DecodePacket(client, client->rx_buf,\n                    client->packet.buf_len, packet_obj, &packet_type,\n                    &packet_qos, &packet_id);\n                if (rc <= 0) {\n                    return rc;\n                }\n            }\n            else {\n                /* packet ID and QoS were already established */\n                packet_id = client->msg.publish.packet_id;\n                packet_qos = client->msg.publish.qos;\n            }\n\n            rc = MqttClient_Publish_ReadPayload(client, publish, timeout_ms);\n            if (rc < 0) {\n                break;\n            }\n\n            /* Handle QoS */\n            if (packet_qos == MQTT_QOS_0) {\n                /* we are done, no QoS response */\n                break;\n            }\n\n            /* Determine packet type to write */\n            resp_type = (packet_qos == MQTT_QOS_1) ?\n                MQTT_PACKET_TYPE_PUBLISH_ACK :\n                MQTT_PACKET_TYPE_PUBLISH_REC;\n            publish->resp.packet_id = packet_id;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock send socket mutex */\n            rc = wm_SemLock(&client->lockSend);\n            if (rc != 0) {\n                return rc;\n            }\n        #endif\n\n            /* Encode publish response */\n            rc = MqttEncode_PublishResp(client->tx_buf, client->tx_buf_len,\n                resp_type, &publish->resp);\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d), ID %d,\"\n                    \" QoS %d\",\n                rc, MqttPacket_TypeDesc(resp_type), resp_type, packet_id,\n                packet_qos);\n        #endif\n            if (rc <= 0) {\n            #ifdef WOLFMQTT_MULTITHREAD\n                wm_SemUnlock(&client->lockSend);\n            #endif\n                return rc;\n            }\n            client->packet.buf_len = rc;\n\n            /* Send publish response packet */\n            rc = MqttPacket_Write(client, client->tx_buf,\n                client->packet.buf_len);\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            wm_SemUnlock(&client->lockSend);\n        #endif\n            break;\n        }\n        case MQTT_PACKET_TYPE_PUBLISH_ACK:\n        case MQTT_PACKET_TYPE_PUBLISH_REC:\n        case MQTT_PACKET_TYPE_PUBLISH_REL:\n        case MQTT_PACKET_TYPE_PUBLISH_COMP:\n        {\n            MqttPublishResp pubRespObj, *publish_resp = &pubRespObj;\n            XMEMSET(publish_resp, 0, sizeof(MqttPublishResp));\n\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, publish_resp, &packet_type,\n                &packet_qos, &packet_id);\n            if (rc <= 0) {\n                return rc;\n            }\n\n            /* If publish Received or Release QoS then proceed */\n            if (packet_type != MQTT_PACKET_TYPE_PUBLISH_REC &&\n                packet_type != MQTT_PACKET_TYPE_PUBLISH_REL) {\n                break;\n            }\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock send socket mutex */\n            rc = wm_SemLock(&client->lockSend);\n            if (rc != 0) {\n                return rc;\n            }\n        #endif\n\n            /* Encode publish response */\n            publish_resp->packet_id = packet_id;\n            packet_type = (MqttPacketType)((int)packet_type+1); /* next ack */\n        #ifdef WOLFMQTT_V5\n            #ifdef WOLFMQTT_DEBUG_CLIENT\n                PRINTF(\"\\tPublish response: reason code %d, Type %s (%d),\"\n                        \" ID %d, QoS %d\",\n                        publish_resp->reason_code,\n                        MqttPacket_TypeDesc(packet_type),\n                        packet_type, packet_id, packet_qos);\n            #endif\n\n            /* return reason code to caller */\n            if (packet_obj != NULL) {\n                MqttPublishResp* caller_rsp = (MqttPublishResp*)packet_obj;\n                caller_rsp->reason_code = publish_resp->reason_code;\n            }\n\n            /* Publish QoS response needs success reason code,\n             * otherwise will cause disconnect at broker */\n            publish_resp->reason_code = MQTT_REASON_SUCCESS;\n        #endif\n\n            rc = MqttEncode_PublishResp(client->tx_buf, client->tx_buf_len,\n                packet_type, publish_resp);\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d), ID %d,\"\n                    \" QoS %d\",\n                rc, MqttPacket_TypeDesc(packet_type), packet_type, packet_id,\n                packet_qos);\n        #endif\n            if (rc <= 0) {\n            #ifdef WOLFMQTT_MULTITHREAD\n                wm_SemUnlock(&client->lockSend);\n            #endif\n                return rc;\n            }\n            client->packet.buf_len = rc;\n\n            /* Send publish response packet */\n            rc = MqttPacket_Write(client, client->tx_buf,\n                client->packet.buf_len);\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            wm_SemUnlock(&client->lockSend);\n        #endif\n            break;\n        }\n        case MQTT_PACKET_TYPE_SUBSCRIBE_ACK:\n        {\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, packet_obj, &packet_type, &packet_qos,\n                &packet_id);\n            break;\n        }\n        case MQTT_PACKET_TYPE_UNSUBSCRIBE_ACK:\n        {\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, packet_obj, &packet_type, &packet_qos,\n                &packet_id);\n            break;\n        }\n        case MQTT_PACKET_TYPE_PING_RESP:\n        {\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, packet_obj, &packet_type, &packet_qos,\n                &packet_id);\n            break;\n        }\n        case MQTT_PACKET_TYPE_AUTH:\n        {\n        #ifdef WOLFMQTT_V5\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, packet_obj, &packet_type, &packet_qos,\n                &packet_id);\n        #else\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n        #endif\n            break;\n        }\n\n        case MQTT_PACKET_TYPE_DISCONNECT:\n        {\n        #ifdef WOLFMQTT_V5\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, packet_obj, &packet_type, &packet_qos,\n                &packet_id);\n        #else\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n        #endif\n            break;\n        }\n        case MQTT_PACKET_TYPE_CONNECT:\n        case MQTT_PACKET_TYPE_SUBSCRIBE:\n        case MQTT_PACKET_TYPE_UNSUBSCRIBE:\n        case MQTT_PACKET_TYPE_PING_REQ:\n        case MQTT_PACKET_TYPE_ANY:\n        case MQTT_PACKET_TYPE_RESERVED:\n        default:\n            /* these types are only sent from client and should not be sent\n             * by broker */\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n            break;\n    } /* switch (packet_type) */\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    if (rc < 0) {\n        PRINTF(\"MqttClient_HandlePacket: Rc %d, Type %s (%d), QoS %d, ID %d\",\n            rc, MqttPacket_TypeDesc(packet_type), packet_type, packet_qos,\n            packet_id);\n    }\n#endif\n\n    return rc;\n}\n\nstatic inline int MqttIsPubRespPacket(int packet_type)\n{\n    return (packet_type == MQTT_PACKET_TYPE_PUBLISH_ACK /* Acknowledgment */ ||\n            packet_type == MQTT_PACKET_TYPE_PUBLISH_REC /* Received */ ||\n            packet_type == MQTT_PACKET_TYPE_PUBLISH_REL /* Release */ ||\n            packet_type == MQTT_PACKET_TYPE_PUBLISH_COMP /* Complete */);\n}\n\nstatic int MqttClient_WaitType(MqttClient *client, void *packet_obj,\n    byte wait_type, word16 wait_packet_id, int timeout_ms)\n{\n    int rc;\n    word16 packet_id;\n    MqttPacketType packet_type;\n#ifdef WOLFMQTT_MULTITHREAD\n    MqttPendResp *pendResp;\n    int readLocked;\n#endif\n    MqttMsgStat* mms_stat;\n    int waitMatchFound;\n\n    if (client == NULL || packet_obj == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* all packet type structures must have MqttMsgStat at top */\n    mms_stat = (MqttMsgStat*)packet_obj;\n\nwait_again:\n\n    /* initialize variables */\n    packet_id = 0;\n    packet_type = MQTT_PACKET_TYPE_RESERVED;\n#ifdef WOLFMQTT_MULTITHREAD\n    pendResp = NULL;\n    readLocked = 0;\n#endif\n    waitMatchFound = 0;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_WaitType: Type %s (%d), ID %d\",\n        MqttPacket_TypeDesc((MqttPacketType)wait_type),\n            wait_type, wait_packet_id);\n#endif\n\n    switch ((int)*mms_stat)\n    {\n        case MQTT_MSG_BEGIN:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock recv socket mutex */\n            rc = wm_SemLock(&client->lockRecv);\n            if (rc != 0) {\n                PRINTF(\"MqttClient_WaitType: recv lock error!\");\n                return rc;\n            }\n            readLocked = 1;\n        #endif\n\n            /* reset the packet state */\n            client->packet.stat = MQTT_PK_BEGIN;\n        }\n        FALL_THROUGH;\n\n    #ifdef WOLFMQTT_V5\n        case MQTT_MSG_AUTH:\n    #endif\n        case MQTT_MSG_WAIT:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if packet type and id have already completed */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, (MqttPacketType)wait_type, \n                    wait_packet_id, &pendResp)) {\n                    if (pendResp->packetDone) {\n                        /* pending response is already done, so return */\n                        rc = pendResp->packet_ret;\n                    #ifdef WOLFMQTT_DEBUG_CLIENT\n                        PRINTF(\"PendResp already Done %p: Rc %d\", pendResp, rc);\n                    #endif\n                        MqttClient_RespList_Remove(client, pendResp);\n                        wm_SemUnlock(&client->lockClient);\n                        wm_SemUnlock(&client->lockRecv);\n                        return rc;\n                    }\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            *mms_stat = MQTT_MSG_WAIT;\n\n            /* Wait for packet */\n            rc = MqttPacket_Read(client, client->rx_buf, client->rx_buf_len,\n                    timeout_ms);\n            /* handle failure */\n            if (rc <= 0) {\n                break;\n            }\n\n            /* capture length read */\n            client->packet.buf_len = rc;\n\n            /* Decode Packet - get type and id */\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, NULL, &packet_type, NULL, &packet_id);\n            if (rc < 0) {\n                break;\n            }\n\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"Read Packet: Len %d, Type %d, ID %d\",\n                client->packet.buf_len, packet_type, packet_id);\n        #endif\n\n            *mms_stat = MQTT_MSG_READ;\n        }\n        FALL_THROUGH;\n\n        case MQTT_MSG_READ:\n        case MQTT_MSG_READ_PAYLOAD:\n        {\n            MqttPacketType use_packet_type;\n            void* use_packet_obj;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            readLocked = 1; /* if in this state read is locked */\n        #endif\n\n            /* read payload state only happens for publish messages */\n            if (*mms_stat == MQTT_MSG_READ_PAYLOAD) {\n                packet_type = MQTT_PACKET_TYPE_PUBLISH;\n            }\n\n            /* Determine if we received data for this request */\n            if ((wait_type == MQTT_PACKET_TYPE_ANY ||\n                 wait_type == packet_type ||\n                 MqttIsPubRespPacket(packet_type) == MqttIsPubRespPacket(wait_type)) &&\n               (wait_packet_id == 0 || wait_packet_id == packet_id))\n            {\n                use_packet_obj = packet_obj;\n                waitMatchFound = 1;\n            }\n            else {\n                /* use generic packet object */\n                use_packet_obj = &client->msg;\n            }\n            use_packet_type = packet_type;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if we have a pending response for this packet */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, packet_type, packet_id,\n                                                               &pendResp)) {\n                    /* we found packet match this incoming read packet */\n                    pendResp->packetProcessing = 1;\n                    use_packet_obj = pendResp->packet_obj;\n                    use_packet_type = pendResp->packet_type;\n                    /* req from another thread... not a match */\n                    waitMatchFound = 0;\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            /* Perform packet handling for publish callback and QoS */\n            rc = MqttClient_HandlePacket(client, use_packet_type,\n                use_packet_obj, timeout_ms);\n\n        #ifdef WOLFMQTT_NONBLOCK\n            if (rc == MQTT_CODE_CONTINUE) {\n                /* we have received some data, so keep the recv\n                    mutex lock active and return */\n                return rc;\n            }\n        #endif\n\n            /* handle success case */\n            if (rc >= 0) {\n                rc = MQTT_CODE_SUCCESS;\n            }\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (pendResp) {\n                /* Mark pending response entry done */\n                if (wm_SemLock(&client->lockClient) == 0) {\n                    pendResp->packetDone = 1;\n                    pendResp->packet_ret = rc;\n                #ifdef WOLFMQTT_DEBUG_CLIENT\n                    PRINTF(\"PendResp Done %p\", pendResp);\n                #endif\n                    pendResp = NULL;\n                    wm_SemUnlock(&client->lockClient);\n                }\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n            break;\n        }\n\n        case MQTT_MSG_WRITE:\n        case MQTT_MSG_WRITE_PAYLOAD:\n        default:\n        {\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_WaitType: Invalid state %d!\", *mms_stat);\n        #endif\n            rc = MQTT_CODE_ERROR_STAT;\n            break;\n        }\n    } /* switch (*mms_stat) */\n\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc != MQTT_CODE_CONTINUE)\n#endif\n    {\n        /* reset state */\n        *mms_stat = MQTT_MSG_BEGIN;\n    }\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (readLocked) {\n        wm_SemUnlock(&client->lockRecv);\n    }\n#endif\n    if (rc < 0) {\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_WaitType: Failure: %s (%d)\",\n            MqttClient_ReturnCodeToString(rc), rc);\n    #endif\n        return rc;\n    }\n\n    if (!waitMatchFound) {\n        /* if we get here, then the we are still waiting for a packet */\n        goto wait_again;\n    }\n\n    return rc;\n}\n\n\n/* Public Functions */\nint MqttClient_Init(MqttClient *client, MqttNet* net,\n    MqttMsgCb msg_cb,\n    byte* tx_buf, int tx_buf_len,\n    byte* rx_buf, int rx_buf_len,\n    int cmd_timeout_ms)\n{\n    int rc = MQTT_CODE_SUCCESS;\n\n    /* Check arguments */\n    if (client == NULL ||\n        tx_buf == NULL || tx_buf_len <= 0 ||\n        rx_buf == NULL || rx_buf_len <= 0) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* Initialize the client structure to zero */\n    XMEMSET(client, 0, sizeof(MqttClient));\n\n    /* Setup client structure */\n    client->msg_cb = msg_cb;\n    client->tx_buf = tx_buf;\n    client->tx_buf_len = tx_buf_len;\n    client->rx_buf = rx_buf;\n    client->rx_buf_len = rx_buf_len;\n    client->cmd_timeout_ms = cmd_timeout_ms;\n#ifdef WOLFMQTT_V5\n    client->max_qos = MQTT_QOS_2;\n    client->retain_avail = 1;\n    client->protocol_level = MQTT_CONNECT_PROTOCOL_LEVEL;\n    rc = MqttProps_Init();\n#endif\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (rc == 0) {\n        rc = wm_SemInit(&client->lockSend);\n    }\n    if (rc == 0) {\n        rc = wm_SemInit(&client->lockRecv);\n    }\n    if (rc == 0) {\n        rc = wm_SemInit(&client->lockClient);\n    }\n#endif\n\n    if (rc == 0) {\n        /* Init socket */\n        rc = MqttSocket_Init(client, net);\n    }\n\n    if (rc != 0) {\n        /* Cleanup if init failed */\n        MqttClient_DeInit(client);\n    }\n\n    return rc;\n}\n\nvoid MqttClient_DeInit(MqttClient *client)\n{\n    if (client != NULL) {\n#ifdef WOLFMQTT_MULTITHREAD\n        (void)wm_SemFree(&client->lockSend);\n        (void)wm_SemFree(&client->lockRecv);\n        (void)wm_SemFree(&client->lockClient);\n#endif\n    }\n#ifdef WOLFMQTT_V5\n    (void)MqttProps_ShutDown();\n#endif\n}\n\n#ifdef WOLFMQTT_DISCONNECT_CB\nint MqttClient_SetDisconnectCallback(MqttClient *client,\n        MqttDisconnectCb discCb, void* ctx)\n{\n    if (client == NULL)\n        return MQTT_CODE_ERROR_BAD_ARG;\n\n    client->disconnect_cb = discCb;\n    client->disconnect_ctx = ctx;\n\n    return MQTT_CODE_SUCCESS;\n}\n#endif\n\n#ifdef WOLFMQTT_PROPERTY_CB\nint MqttClient_SetPropertyCallback(MqttClient *client, MqttPropertyCb propCb,\n    void* ctx)\n{\n    if (client == NULL)\n        return MQTT_CODE_ERROR_BAD_ARG;\n\n    client->property_cb = propCb;\n    client->property_ctx = ctx;\n\n    return MQTT_CODE_SUCCESS;\n}\n#endif\n\nint MqttClient_Connect(MqttClient *client, MqttConnect *mc_connect)\n{\n    int rc, len = 0;\n\n    /* Validate required arguments */\n    if (client == NULL || mc_connect == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    if (mc_connect->stat == MQTT_MSG_BEGIN) {\n    #ifdef WOLFMQTT_MULTITHREAD\n        /* Lock send socket mutex */\n        rc = wm_SemLock(&client->lockSend);\n        if (rc != 0) {\n            return rc;\n        }\n    #endif\n\n    #ifdef WOLFMQTT_V5\n        /* Use specified protocol version if set */\n        mc_connect->protocol_level = client->protocol_level;\n    #endif\n\n        /* Encode the connect packet */\n        rc = MqttEncode_Connect(client->tx_buf, client->tx_buf_len, mc_connect);\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d), ID %d, QoS %d\",\n            rc, MqttPacket_TypeDesc(MQTT_PACKET_TYPE_CONNECT),\n            MQTT_PACKET_TYPE_CONNECT, 0, 0);\n    #endif\n        if (rc <= 0) {\n            #ifdef WOLFMQTT_MULTITHREAD\n                wm_SemUnlock(&client->lockSend);\n            #endif\n            return rc;\n        }\n        len = rc;\n\n    #ifdef WOLFMQTT_MULTITHREAD\n        rc = wm_SemLock(&client->lockClient);\n        if (rc == 0) {\n            /* inform other threads of expected response */\n            rc = MqttClient_RespList_Add(client, MQTT_PACKET_TYPE_CONNECT_ACK,\n                    0, &mc_connect->pendResp, &mc_connect->ack);\n            wm_SemUnlock(&client->lockClient);\n        }\n        if (rc != 0) {\n            wm_SemUnlock(&client->lockSend);\n            return rc; /* Error locking client */\n        }\n    #endif\n\n        /* Send connect packet */\n        rc = MqttPacket_Write(client, client->tx_buf, len);\n    #ifdef WOLFMQTT_MULTITHREAD\n        wm_SemUnlock(&client->lockSend);\n    #endif\n        if (rc != len) {\n    #ifdef WOLFMQTT_MULTITHREAD\n            if ((rc != MQTT_CODE_CONTINUE) &&\n                (wm_SemLock(&client->lockClient)) == 0) {\n                MqttClient_RespList_Remove(client, &mc_connect->pendResp);\n                wm_SemUnlock(&client->lockClient);\n            }\n    #endif\n            return rc;\n        }\n    #ifdef WOLFMQTT_V5\n        /* Enhanced authentication */\n        if (client->enable_eauth == 1) {\n            mc_connect->stat = MQTT_MSG_AUTH;\n        }\n        else\n    #endif\n        {\n            mc_connect->stat = MQTT_MSG_WAIT;\n        }\n    }\n\n#ifdef WOLFMQTT_V5\n    /* Enhanced authentication */\n    if (mc_connect->protocol_level > MQTT_CONNECT_PROTOCOL_LEVEL_4 && \n            mc_connect->stat == MQTT_MSG_AUTH)\n    {\n        MqttAuth auth, *p_auth = &auth;\n        MqttProp* prop, *conn_prop;\n\n        /* Find the AUTH property in the connect structure */\n        for (conn_prop = mc_connect->props;\n             (conn_prop != NULL) && (conn_prop->type != MQTT_PROP_AUTH_METHOD);\n             conn_prop = conn_prop->next) {\n        }\n        if (conn_prop == NULL) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (wm_SemLock(&client->lockClient) == 0) {\n                MqttClient_RespList_Remove(client, &mc_connect->pendResp);\n                wm_SemUnlock(&client->lockClient);\n            }\n        #endif\n            /* AUTH property was not set in connect structure */\n            return MQTT_CODE_ERROR_BAD_ARG;\n        }\n\n        XMEMSET((void*)p_auth, 0, sizeof(MqttAuth));\n\n        /* Set the authentication reason */\n        p_auth->reason_code = MQTT_REASON_CONT_AUTH;\n\n        /* Use the same authentication method property from connect */\n        prop = MqttProps_Add(&p_auth->props);\n        prop->type = MQTT_PROP_AUTH_METHOD;\n        prop->data_str.str = conn_prop->data_str.str;\n        prop->data_str.len = conn_prop->data_str.len;\n\n        /* Send the AUTH packet */\n        rc = MqttClient_Auth(client, p_auth);\n        MqttClient_PropsFree(p_auth->props);\n    #ifdef WOLFMQTT_NONBLOCK\n        if (rc == MQTT_CODE_CONTINUE)\n            return rc;\n    #endif\n        if (rc != len) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (wm_SemLock(&client->lockClient) == 0) {\n                MqttClient_RespList_Remove(client, &mc_connect->pendResp);\n                wm_SemUnlock(&client->lockClient);\n            }\n        #endif\n            return rc;\n        }\n    }\n#endif /* WOLFMQTT_V5 */\n\n    /* Wait for connect ack packet */\n    rc = MqttClient_WaitType(client, &mc_connect->ack,\n        MQTT_PACKET_TYPE_CONNECT_ACK, 0, client->cmd_timeout_ms);\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc == MQTT_CODE_CONTINUE)\n        return rc;\n#endif\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (wm_SemLock(&client->lockClient) == 0) {\n        MqttClient_RespList_Remove(client, &mc_connect->pendResp);\n        wm_SemUnlock(&client->lockClient);\n    }\n#endif\n\n    /* reset state */\n    mc_connect->stat = MQTT_MSG_BEGIN;\n\n    return rc;\n}\n\n#ifdef WOLFMQTT_TEST_NONBLOCK\nstatic int testNbAlt = 0;\n#endif\n\nstatic int MqttClient_Publish_ReadPayload(MqttClient* client,\n    MqttPublish* publish, int timeout_ms)\n{\n    int rc = MQTT_CODE_SUCCESS;\n    byte msg_done;\n\n    /* Handle packet callback and read remaining payload */\n    do {\n        /* Determine if message is done */\n        msg_done = ((publish->buffer_pos + publish->buffer_len) >=\n                    publish->total_len) ? 1 : 0;\n\n        if (publish->buffer_new) {\n            /* Issue callback for new message (first time only) */\n            if (client->msg_cb) {\n                /* if using the temp publish message buffer,\n                   then populate message context with client context */\n                if (publish->ctx == NULL && &client->msg.publish == publish) {\n                    publish->ctx = client->ctx;\n                }\n                rc = client->msg_cb(client, publish, publish->buffer_new,\n                                    msg_done);\n                if (rc != MQTT_CODE_SUCCESS) {\n                    return rc;\n                };\n            }\n\n            /* Reset topic name since valid on new message only */\n            publish->topic_name = NULL;\n            publish->topic_name_len = 0;\n\n            publish->buffer_new = 0;\n        }\n\n        /* Read payload */\n        if (!msg_done) {\n            int msg_len;\n\n            /* add last length to position and reset len */\n            publish->buffer_pos += publish->buffer_len;\n            publish->buffer_len = 0;\n\n            /* set state to reading payload */\n            publish->stat = MQTT_MSG_READ_PAYLOAD;\n\n            msg_len = (publish->total_len - publish->buffer_pos);\n            if (msg_len > client->rx_buf_len) {\n                msg_len = client->rx_buf_len;\n            }\n\n            /* make sure there is something to read */\n            if (msg_len > 0) {\n                #ifdef WOLFMQTT_TEST_NONBLOCK\n                    if (!testNbAlt) {\n                        testNbAlt = 1;\n                        return MQTT_CODE_CONTINUE;\n                    }\n                    testNbAlt = 0;\n                #endif\n\n                rc = MqttSocket_Read(client, client->rx_buf, msg_len,\n                        timeout_ms);\n                if (rc < 0) {\n                    break;\n                }\n\n                /* Update message */\n                publish->buffer = client->rx_buf;\n                publish->buffer_len = rc;\n                rc = MQTT_CODE_SUCCESS; /* mark success */\n\n                msg_done = ((publish->buffer_pos + publish->buffer_len) >=\n                    publish->total_len) ? 1 : 0;\n\n                /* Issue callback for additional publish payload */\n                if (client->msg_cb) {\n                    rc = client->msg_cb(client, publish, publish->buffer_new,\n                                        msg_done);\n                    if (rc != MQTT_CODE_SUCCESS) {\n                        return rc;\n                    };\n                }\n            }\n        }\n    } while (!msg_done);\n\n    return rc;\n}\n\nstatic int MqttClient_Publish_WritePayload(MqttClient *client,\n    MqttPublish *publish, MqttPublishCb pubCb)\n{\n    int rc = MQTT_CODE_SUCCESS;\n\n    if (client == NULL || publish == NULL)\n        return MQTT_CODE_ERROR_BAD_ARG;\n\n    if (pubCb) {\n        word32 tmp_len = publish->buffer_len;\n\n        do {\n            /* Use the callback to get payload */\n            if ((client->write.len = pubCb(publish)) < 0) {\n                return MQTT_CODE_ERROR_CALLBACK;\n            }\n\n            if ((word32)client->write.len < publish->buffer_len) {\n                /* Last read */\n                tmp_len = (word32)client->write.len;\n            }\n\n            /* Send payload */\n            do {\n                if (client->write.len > client->tx_buf_len) {\n                    client->write.len = client->tx_buf_len;\n                }\n                publish->intBuf_len = client->write.len;\n                XMEMCPY(client->tx_buf, &publish->buffer[publish->intBuf_pos],\n                    client->write.len);\n\n                rc = MqttPacket_Write(client, client->tx_buf,\n                        client->write.len);\n                if (rc < 0) {\n                    return rc;\n                }\n\n                publish->intBuf_pos += publish->intBuf_len;\n                publish->intBuf_len = 0;\n\n            } while (publish->intBuf_pos < tmp_len);\n\n            publish->buffer_pos += publish->intBuf_pos;\n            publish->intBuf_pos = 0;\n\n        } while (publish->buffer_pos < publish->total_len);\n    }\n    else if (publish->buffer_pos < publish->total_len) {\n        if (publish->buffer_pos > 0) {\n            client->write.len = (publish->total_len - publish->buffer_pos);\n            if (client->write.len > client->tx_buf_len) {\n                client->write.len = client->tx_buf_len;\n            }\n\n            XMEMCPY(client->tx_buf, &publish->buffer[publish->buffer_pos],\n                client->write.len);\n\n        #ifndef WOLFMQTT_NONBLOCK\n            publish->intBuf_pos += client->write.len;\n        #endif\n        }\n\n        /* Send packet and payload */\n    #ifdef WOLFMQTT_NONBLOCK\n            rc = MqttPacket_Write(client, client->tx_buf,\n                    client->write.len);\n            if (rc < 0) {\n                return rc;\n            }\n\n            /* ONLY if send was successful, update buffer position.\n             * Otherwise, MqttPacket_Write() will resume where it left off. */\n            publish->buffer_pos += client->write.len;\n\n            /* Check if we are done sending publish message */\n            if (publish->buffer_pos < publish->buffer_len) {\n                return MQTT_CODE_PUB_CONTINUE;\n            }\n    #else\n        do {\n            rc = MqttPacket_Write(client, client->tx_buf,\n                    client->write.len);\n            if (rc < 0) {\n                return rc;\n            }\n\n            publish->intBuf_pos += publish->intBuf_len;\n            publish->intBuf_len = 0;\n\n            /* Check if we are done sending publish message */\n            if (publish->intBuf_pos >= publish->buffer_len) {\n                rc = MQTT_CODE_SUCCESS;\n                break;\n            }\n\n            /* Build packet payload to send */\n            client->write.len = (publish->buffer_len - publish->intBuf_pos);\n            if (client->write.len > client->tx_buf_len) {\n                client->write.len = client->tx_buf_len;\n            }\n            publish->intBuf_len = client->write.len;\n            XMEMCPY(client->tx_buf, &publish->buffer[publish->intBuf_pos],\n                client->write.len);\n        } while (publish->intBuf_pos < publish->buffer_len);\n    #endif\n\n        if (rc >= 0) {\n            /* If transferring more chunks */\n            publish->buffer_pos += publish->intBuf_pos;\n            if (publish->buffer_pos < publish->total_len) {\n                /* Build next payload to send */\n                client->write.len = (publish->total_len - publish->buffer_pos);\n                if (client->write.len > client->tx_buf_len) {\n                    client->write.len = client->tx_buf_len;\n                }\n                rc = MQTT_CODE_PUB_CONTINUE;\n            }\n        }\n    }\n    return rc;\n}\n\nint MqttClient_Publish(MqttClient *client, MqttPublish *publish)\n{\n    return MqttClient_Publish_ex(client, publish, NULL);\n}\n\nint MqttClient_Publish_ex(MqttClient *client, MqttPublish *publish,\n                            MqttPublishCb pubCb)\n{\n    int rc = MQTT_CODE_SUCCESS;\n    MqttPacketType resp_type;\n\n    /* Validate required arguments */\n    if (client == NULL || publish == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n#ifdef WOLFMQTT_V5\n    /* Use specified protocol version if set */\n    publish->protocol_level = client->protocol_level;\n\n    /* Validate publish request against server properties */\n    if ((publish->qos > client->max_qos) ||\n        ((publish->retain == 1) && (client->retain_avail == 0)))\n    {\n        return MQTT_CODE_ERROR_SERVER_PROP;\n    }\n#endif\n\n    switch (publish->stat)\n    {\n        case MQTT_MSG_BEGIN:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock send socket mutex */\n            rc = wm_SemLock(&client->lockSend);\n            if (rc != 0) {\n                return rc;\n            }\n        #endif\n\n            /* Encode the publish packet */\n            rc = MqttEncode_Publish(client->tx_buf, client->tx_buf_len,\n                    publish, pubCb ? 1 : 0);\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d), ID %d,\"\n                    \" QoS %d\",\n                rc, MqttPacket_TypeDesc(MQTT_PACKET_TYPE_PUBLISH),\n                MQTT_PACKET_TYPE_PUBLISH, publish->packet_id,\n                publish->qos);\n        #endif\n            if (rc <= 0) {\n            #ifdef WOLFMQTT_MULTITHREAD\n                wm_SemUnlock(&client->lockSend);\n            #endif\n                return rc;\n            }\n            client->write.len = rc;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (publish->qos > MQTT_QOS_0) {\n                resp_type = (publish->qos == MQTT_QOS_1) ?\n                        MQTT_PACKET_TYPE_PUBLISH_ACK :\n                        MQTT_PACKET_TYPE_PUBLISH_COMP;\n\n                rc = wm_SemLock(&client->lockClient);\n                if (rc == 0) {\n                    /* inform other threads of expected response */\n                    rc = MqttClient_RespList_Add(client, resp_type,\n                        publish->packet_id, &publish->pendResp, &publish->resp);\n                    wm_SemUnlock(&client->lockClient);\n                }\n                if (rc != 0) {\n                    wm_SemUnlock(&client->lockSend);\n                    return rc; /* Error locking client */\n                }\n            }\n        #endif\n\n            publish->stat = MQTT_MSG_WRITE;\n        }\n        FALL_THROUGH;\n\n        case MQTT_MSG_WRITE:\n        {\n            /* Send packet */\n            rc = MqttPacket_Write(client, client->tx_buf, client->write.len);\n        #ifdef WOLFMQTT_NONBLOCK\n            if (rc == MQTT_CODE_CONTINUE)\n                return rc;\n        #endif\n            if (rc < 0) {\n            #ifdef WOLFMQTT_MULTITHREAD\n                wm_SemUnlock(&client->lockSend);\n            #endif\n            #ifdef WOLFMQTT_MULTITHREAD\n                if (wm_SemLock(&client->lockClient) == 0) {\n                    MqttClient_RespList_Remove(client, &publish->pendResp);\n                    wm_SemUnlock(&client->lockClient);\n                }\n            #endif\n                return rc;\n            }\n\n            /* advance state */\n            publish->stat = MQTT_MSG_WRITE_PAYLOAD;\n        }\n        FALL_THROUGH;\n\n        case MQTT_MSG_WRITE_PAYLOAD:\n        {\n            rc = MqttClient_Publish_WritePayload(client, publish, pubCb);\n        #ifdef WOLFMQTT_NONBLOCK\n            if (rc == MQTT_CODE_CONTINUE)\n                return rc;\n        #endif\n        #ifdef WOLFMQTT_MULTITHREAD\n            wm_SemUnlock(&client->lockSend);\n        #endif\n\n            if (rc < 0) {\n            #ifdef WOLFMQTT_MULTITHREAD\n                if (wm_SemLock(&client->lockClient) == 0) {\n                    MqttClient_RespList_Remove(client, &publish->pendResp);\n                    wm_SemUnlock(&client->lockClient);\n                }\n            #endif\n                break;\n            }\n\n            /* if not expecting a reply then we are done */\n            if (publish->qos == MQTT_QOS_0) {\n                break;\n            }\n            publish->stat = MQTT_MSG_WAIT;\n        }\n        FALL_THROUGH;\n\n        case MQTT_MSG_WAIT:\n        {\n            /* Handle QoS */\n            if (publish->qos > MQTT_QOS_0) {\n                /* Determine packet type to wait for */\n                resp_type = (publish->qos == MQTT_QOS_1) ?\n                    MQTT_PACKET_TYPE_PUBLISH_ACK :\n                    MQTT_PACKET_TYPE_PUBLISH_COMP;\n\n                /* Wait for publish response packet */\n                rc = MqttClient_WaitType(client, &publish->resp, resp_type,\n                    publish->packet_id, client->cmd_timeout_ms);\n            #ifdef WOLFMQTT_NONBLOCK\n                if (rc == MQTT_CODE_CONTINUE)\n                    break;\n            #endif\n            #ifdef WOLFMQTT_MULTITHREAD\n                if (wm_SemLock(&client->lockClient) == 0) {\n                    MqttClient_RespList_Remove(client, &publish->pendResp);\n                    wm_SemUnlock(&client->lockClient);\n                }\n            #endif\n            }\n            break;\n        }\n\n    #ifdef WOLFMQTT_V5\n        case MQTT_MSG_AUTH:\n    #endif\n        case MQTT_MSG_READ:\n        case MQTT_MSG_READ_PAYLOAD:\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_Publish: Invalid state %d!\",\n                publish->stat);\n        #endif\n            rc = MQTT_CODE_ERROR_STAT;\n            break;\n    } /* switch (publish->stat) */\n\n    /* reset state */\n    if ((rc != MQTT_CODE_PUB_CONTINUE)\n#ifdef WOLFMQTT_NONBLOCK\n         && (rc != MQTT_CODE_CONTINUE)\n#endif\n        )\n    {\n        publish->stat = MQTT_MSG_BEGIN;\n    }\n    if (rc > 0) {\n        rc = MQTT_CODE_SUCCESS;\n    }\n\n    return rc;\n}\n\nint MqttClient_Subscribe(MqttClient *client, MqttSubscribe *subscribe)\n{\n    int rc, len, i;\n    MqttTopic* topic;\n\n    /* Validate required arguments */\n    if (client == NULL || subscribe == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n#ifdef WOLFMQTT_V5\n    /* Use specified protocol version if set */\n    subscribe->protocol_level = client->protocol_level;\n#endif\n\n    if (subscribe->stat == MQTT_MSG_BEGIN) {\n    #ifdef WOLFMQTT_MULTITHREAD\n        /* Lock send socket mutex */\n        rc = wm_SemLock(&client->lockSend);\n        if (rc != 0) {\n            return rc;\n        }\n    #endif\n\n        /* Encode the subscribe packet */\n        rc = MqttEncode_Subscribe(client->tx_buf, client->tx_buf_len,\n                subscribe);\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d), ID %d\",\n            rc, MqttPacket_TypeDesc(MQTT_PACKET_TYPE_SUBSCRIBE),\n            MQTT_PACKET_TYPE_SUBSCRIBE, subscribe->packet_id);\n    #endif\n        if (rc <= 0) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            wm_SemUnlock(&client->lockSend);\n        #endif\n            return rc;\n        }\n        len = rc;\n\n    #ifdef WOLFMQTT_MULTITHREAD\n        rc = wm_SemLock(&client->lockClient);\n        if (rc == 0) {\n            /* inform other threads of expected response */\n            rc = MqttClient_RespList_Add(client, MQTT_PACKET_TYPE_SUBSCRIBE_ACK,\n                subscribe->packet_id, &subscribe->pendResp, &subscribe->ack);\n            wm_SemUnlock(&client->lockClient);\n        }\n        if (rc != 0) {\n            wm_SemUnlock(&client->lockSend);\n            return rc; /* Error locking client */\n        }\n    #endif\n\n        /* Send subscribe packet */\n        rc = MqttPacket_Write(client, client->tx_buf, len);\n    #ifdef WOLFMQTT_MULTITHREAD\n        wm_SemUnlock(&client->lockSend);\n    #endif\n        if (rc != len) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (wm_SemLock(&client->lockClient) == 0) {\n                MqttClient_RespList_Remove(client, &subscribe->pendResp);\n                wm_SemUnlock(&client->lockClient);\n            }\n        #endif\n            return rc;\n        }\n\n        subscribe->stat = MQTT_MSG_WAIT;\n    }\n\n    /* Wait for subscribe ack packet */\n    rc = MqttClient_WaitType(client, &subscribe->ack,\n        MQTT_PACKET_TYPE_SUBSCRIBE_ACK, subscribe->packet_id,\n        client->cmd_timeout_ms);\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc == MQTT_CODE_CONTINUE)\n        return rc;\n#endif\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (wm_SemLock(&client->lockClient) == 0) {\n        MqttClient_RespList_Remove(client, &subscribe->pendResp);\n        wm_SemUnlock(&client->lockClient);\n    }\n#endif\n\n    /* Populate return codes */\n    if (rc == MQTT_CODE_SUCCESS) {\n        for (i = 0; i < subscribe->topic_count && i < MAX_MQTT_TOPICS; i++) {\n            topic = &subscribe->topics[i];\n            topic->return_code = subscribe->ack.return_codes[i];\n        }\n    }\n\n    /* reset state */\n    subscribe->stat = MQTT_MSG_BEGIN;\n\n    return rc;\n}\n\nint MqttClient_Unsubscribe(MqttClient *client, MqttUnsubscribe *unsubscribe)\n{\n    int rc, len;\n\n    /* Validate required arguments */\n    if (client == NULL || unsubscribe == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n#ifdef WOLFMQTT_V5\n    /* Use specified protocol version if set */\n    unsubscribe->protocol_level = client->protocol_level;\n#endif\n\n    if (unsubscribe->stat == MQTT_MSG_BEGIN) {\n    #ifdef WOLFMQTT_MULTITHREAD\n        /* Lock send socket mutex */\n        rc = wm_SemLock(&client->lockSend);\n        if (rc != 0) {\n            return rc;\n        }\n    #endif\n\n        /* Encode the subscribe packet */\n        rc = MqttEncode_Unsubscribe(client->tx_buf, client->tx_buf_len,\n            unsubscribe);\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d), ID %d, QoS %d\",\n            rc, MqttPacket_TypeDesc(MQTT_PACKET_TYPE_UNSUBSCRIBE),\n            MQTT_PACKET_TYPE_UNSUBSCRIBE, unsubscribe->packet_id, 0);\n    #endif\n        if (rc <= 0) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            wm_SemUnlock(&client->lockSend);\n        #endif\n            return rc;\n        }\n        len = rc;\n\n    #ifdef WOLFMQTT_MULTITHREAD\n        rc = wm_SemLock(&client->lockClient);\n        if (rc == 0) {\n            /* inform other threads of expected response */\n            rc = MqttClient_RespList_Add(client,\n                MQTT_PACKET_TYPE_UNSUBSCRIBE_ACK, unsubscribe->packet_id,\n                &unsubscribe->pendResp, &unsubscribe->ack);\n            wm_SemUnlock(&client->lockClient);\n        }\n        if (rc != 0) {\n            wm_SemUnlock(&client->lockSend); /* Error locking client */\n            return rc;\n        }\n    #endif\n\n        /* Send unsubscribe packet */\n        rc = MqttPacket_Write(client, client->tx_buf, len);\n    #ifdef WOLFMQTT_MULTITHREAD\n        wm_SemUnlock(&client->lockSend);\n    #endif\n        if (rc != len) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (wm_SemLock(&client->lockClient) == 0) {\n                MqttClient_RespList_Remove(client, &unsubscribe->pendResp);\n                wm_SemUnlock(&client->lockClient);\n            }\n        #endif\n            return rc;\n        }\n\n        unsubscribe->stat = MQTT_MSG_WAIT;\n    }\n\n    /* Wait for unsubscribe ack packet */\n    rc = MqttClient_WaitType(client, &unsubscribe->ack,\n        MQTT_PACKET_TYPE_UNSUBSCRIBE_ACK, unsubscribe->packet_id,\n        client->cmd_timeout_ms);\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc == MQTT_CODE_CONTINUE)\n        return rc;\n#endif\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (wm_SemLock(&client->lockClient) == 0) {\n        MqttClient_RespList_Remove(client, &unsubscribe->pendResp);\n        wm_SemUnlock(&client->lockClient);\n    }\n#endif\n\n#ifdef WOLFMQTT_V5\n    if (unsubscribe->ack.props != NULL) {\n        /* Release the allocated properties */\n        MqttClient_PropsFree(unsubscribe->ack.props);\n    }\n#endif\n\n    /* reset state */\n    unsubscribe->stat = MQTT_MSG_BEGIN;\n\n    return rc;\n}\n\nint MqttClient_Ping_ex(MqttClient *client, MqttPing* ping)\n{\n    int rc, len;\n\n    /* Validate required arguments */\n    if (client == NULL || ping == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    if (ping->stat == MQTT_MSG_BEGIN) {\n    #ifdef WOLFMQTT_MULTITHREAD\n        /* Lock send socket mutex */\n        rc = wm_SemLock(&client->lockSend);\n        if (rc != 0) {\n            return rc;\n        }\n    #endif\n\n        /* Encode the subscribe packet */\n        rc = MqttEncode_Ping(client->tx_buf, client->tx_buf_len, ping);\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d), ID %d, QoS %d\",\n            rc, MqttPacket_TypeDesc(MQTT_PACKET_TYPE_PING_REQ),\n            MQTT_PACKET_TYPE_PING_REQ, 0, 0);\n    #endif\n        if (rc <= 0) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            wm_SemUnlock(&client->lockSend);\n        #endif\n            return rc;\n        }\n        len = rc;\n\n    #ifdef WOLFMQTT_MULTITHREAD\n        rc = wm_SemLock(&client->lockClient);\n        if (rc == 0) {\n            /* inform other threads of expected response */\n            rc = MqttClient_RespList_Add(client, MQTT_PACKET_TYPE_PING_RESP, 0,\n                &ping->pendResp, ping);\n            wm_SemUnlock(&client->lockClient);\n        }\n        if (rc != 0) {\n            wm_SemUnlock(&client->lockSend);\n            return rc; /* Error locking client */\n        }\n    #endif\n\n        /* Send ping req packet */\n        rc = MqttPacket_Write(client, client->tx_buf, len);\n    #ifdef WOLFMQTT_MULTITHREAD\n        wm_SemUnlock(&client->lockSend);\n    #endif\n        if (rc != len) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (wm_SemLock(&client->lockClient) == 0) {\n                MqttClient_RespList_Remove(client, &ping->pendResp);\n                wm_SemUnlock(&client->lockClient);\n            }\n        #endif\n            return rc;\n        }\n\n        ping->stat = MQTT_MSG_WAIT;\n    }\n\n    /* Wait for ping resp packet */\n    rc = MqttClient_WaitType(client, ping, MQTT_PACKET_TYPE_PING_RESP, 0,\n        client->cmd_timeout_ms);\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc == MQTT_CODE_CONTINUE)\n        return rc;\n#endif\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (wm_SemLock(&client->lockClient) == 0) {\n        MqttClient_RespList_Remove(client, &ping->pendResp);\n        wm_SemUnlock(&client->lockClient);\n    }\n#endif\n\n    /* reset state */\n    ping->stat = MQTT_MSG_BEGIN;\n\n    return rc;\n}\n\nint MqttClient_Ping(MqttClient *client)\n{\n    MqttPing ping;\n    XMEMSET(&ping, 0, sizeof(ping));\n    return MqttClient_Ping_ex(client, &ping);\n}\n\nint MqttClient_Disconnect(MqttClient *client)\n{\n    return MqttClient_Disconnect_ex(client, NULL);\n}\n\nint MqttClient_Disconnect_ex(MqttClient *client, MqttDisconnect *disconnect)\n{\n    int rc, len;\n\n    /* Validate required arguments */\n    if (client == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n#ifdef WOLFMQTT_V5\n    if (disconnect != NULL) {\n        /* Use specified protocol version if set */\n        disconnect->protocol_level = client->protocol_level;\n    }\n#endif\n\n#ifdef WOLFMQTT_MULTITHREAD\n    /* Lock send socket mutex */\n    rc = wm_SemLock(&client->lockSend);\n    if (rc != 0) {\n        return rc;\n    }\n#endif\n\n    /* Encode the disconnect packet */\n    rc = MqttEncode_Disconnect(client->tx_buf, client->tx_buf_len, disconnect);\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d), ID %d, QoS %d\",\n        rc, MqttPacket_TypeDesc(MQTT_PACKET_TYPE_DISCONNECT),\n        MQTT_PACKET_TYPE_DISCONNECT, 0, 0);\n#endif\n    if (rc <= 0) {\n    #ifdef WOLFMQTT_MULTITHREAD\n        wm_SemUnlock(&client->lockSend);\n    #endif\n        return rc;\n    }\n    len = rc;\n\n    /* Send disconnect packet */\n    rc = MqttPacket_Write(client, client->tx_buf, len);\n#ifdef WOLFMQTT_MULTITHREAD\n    wm_SemUnlock(&client->lockSend);\n#endif\n    if (rc != len) {\n        return rc;\n    }\n\n    /* No response for MQTT disconnect packet */\n\n    return MQTT_CODE_SUCCESS;\n}\n\n#ifdef WOLFMQTT_V5\nint MqttClient_Auth(MqttClient *client, MqttAuth* auth)\n{\n    int rc, len;\n\n    /* Validate required arguments */\n    if (client == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    if (auth->stat == MQTT_MSG_BEGIN) {\n    #ifdef WOLFMQTT_MULTITHREAD\n        /* Lock send socket mutex */\n        rc = wm_SemLock(&client->lockSend);\n        if (rc != 0) {\n            return rc;\n        }\n    #endif\n\n        /* Encode the authentication packet */\n        rc = MqttEncode_Auth(client->tx_buf, client->tx_buf_len, auth);\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d), ID %d, QoS %d\",\n            rc, MqttPacket_TypeDesc(MQTT_PACKET_TYPE_AUTH),\n            MQTT_PACKET_TYPE_AUTH, 0, 0);\n    #endif\n        if (rc <= 0) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            wm_SemUnlock(&client->lockSend);\n        #endif\n            return rc;\n        }\n        len = rc;\n\n    #ifdef WOLFMQTT_MULTITHREAD\n        rc = wm_SemLock(&client->lockClient);\n        if (rc == 0) {\n            /* inform other threads of expected response */\n            rc = MqttClient_RespList_Add(client, MQTT_PACKET_TYPE_AUTH, 0,\n                &auth->pendResp, auth);\n            wm_SemUnlock(&client->lockClient);\n        }\n        if (rc != 0) {\n            wm_SemUnlock(&client->lockSend);\n            return rc; /* Error locking client */\n        }\n    #endif\n\n        /* Send authentication packet */\n        rc = MqttPacket_Write(client, client->tx_buf, len);\n    #ifdef WOLFMQTT_MULTITHREAD\n        wm_SemUnlock(&client->lockSend);\n    #endif\n        if (rc != len) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (wm_SemLock(&client->lockClient) == 0) {\n                MqttClient_RespList_Remove(client, &auth->pendResp);\n                wm_SemUnlock(&client->lockClient);\n            }\n        #endif\n            return rc;\n        }\n\n        auth->stat = MQTT_MSG_WAIT;\n    }\n\n    /* Wait for auth packet */\n    rc = MqttClient_WaitType(client, auth, MQTT_PACKET_TYPE_AUTH, 0,\n        client->cmd_timeout_ms);\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc == MQTT_CODE_CONTINUE)\n        return rc;\n#endif\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (wm_SemLock(&client->lockClient) == 0) {\n        MqttClient_RespList_Remove(client, &auth->pendResp);\n        wm_SemUnlock(&client->lockClient);\n    }\n#endif\n\n    /* reset state */\n    auth->stat = MQTT_MSG_BEGIN;\n\n    return rc;\n}\n\nMqttProp* MqttClient_PropsAdd(MqttProp **head)\n{\n    return MqttProps_Add(head);\n}\n\nint MqttClient_PropsFree(MqttProp *head)\n{\n    return MqttProps_Free(head);\n}\n\n#endif /* WOLFMQTT_V5 */\n\nint MqttClient_WaitMessage_ex(MqttClient *client, MqttObject* msg,\n        int timeout_ms)\n{\n    return MqttClient_WaitType(client, msg, MQTT_PACKET_TYPE_ANY, 0,\n        timeout_ms);\n}\nint MqttClient_WaitMessage(MqttClient *client, int timeout_ms)\n{\n    if (client == NULL)\n        return MQTT_CODE_ERROR_BAD_ARG;\n    return MqttClient_WaitMessage_ex(client, &client->msg, timeout_ms);\n}\n\nint MqttClient_NetConnect(MqttClient *client, const char* host,\n    word16 port, int timeout_ms, int use_tls, MqttTlsCb cb)\n{\n    return MqttSocket_Connect(client, host, port, timeout_ms, use_tls, cb);\n}\n\nint MqttClient_NetDisconnect(MqttClient *client)\n{\n    return MqttSocket_Disconnect(client);\n}\n\nint MqttClient_GetProtocolVersion(MqttClient *client)\n{\n#ifdef WOLFMQTT_V5\n    if (client && client->protocol_level == MQTT_CONNECT_PROTOCOL_LEVEL_5)\n        return MQTT_CONNECT_PROTOCOL_LEVEL_5;\n#else\n    (void)client;\n#endif\n    return MQTT_CONNECT_PROTOCOL_LEVEL_4;\n}\nconst char* MqttClient_GetProtocolVersionString(MqttClient *client)\n{\n    const char* str = NULL;\n    int ver = MqttClient_GetProtocolVersion(client);\n    switch (ver) {\n        case MQTT_CONNECT_PROTOCOL_LEVEL_4:\n            return \"v3.1.1\";\n    #ifdef WOLFMQTT_V5\n        case MQTT_CONNECT_PROTOCOL_LEVEL_5:\n            return \"v5\";\n    #endif\n        default:\n            break;\n    }\n    return str;\n}\n\n#ifndef WOLFMQTT_NO_ERROR_STRINGS\nconst char* MqttClient_ReturnCodeToString(int return_code)\n{\n    switch(return_code) {\n        case MQTT_CODE_SUCCESS:\n            return \"Success\";\n        case MQTT_CODE_CONTINUE:\n            return \"Continue\"; /* would block */\n        case MQTT_CODE_STDIN_WAKE:\n            return \"STDIN Wake\";\n        case MQTT_CODE_PUB_CONTINUE:\n            return \"Continue calling publish\"; /* Chunked publish */\n        case MQTT_CODE_ERROR_BAD_ARG:\n            return \"Error (Bad argument)\";\n        case MQTT_CODE_ERROR_OUT_OF_BUFFER:\n            return \"Error (Out of buffer)\";\n        case MQTT_CODE_ERROR_MALFORMED_DATA:\n            return \"Error (Malformed Remaining Length)\";\n        case MQTT_CODE_ERROR_PACKET_TYPE:\n            return \"Error (Packet Type Mismatch)\";\n        case MQTT_CODE_ERROR_PACKET_ID:\n            return \"Error (Packet Id Mismatch)\";\n        case MQTT_CODE_ERROR_TLS_CONNECT:\n            return \"Error (TLS Connect)\";\n        case MQTT_CODE_ERROR_TIMEOUT:\n            return \"Error (Timeout)\";\n        case MQTT_CODE_ERROR_NETWORK:\n            return \"Error (Network)\";\n        case MQTT_CODE_ERROR_MEMORY:\n            return \"Error (Memory)\";\n        case MQTT_CODE_ERROR_STAT:\n            return \"Error (State)\";\n        case MQTT_CODE_ERROR_PROPERTY:\n            return \"Error (Property)\";\n        case MQTT_CODE_ERROR_SERVER_PROP:\n            return \"Error (Server Property)\";\n        case MQTT_CODE_ERROR_CALLBACK:\n            return \"Error (Error in Callback)\";\n        case MQTT_CODE_ERROR_SYSTEM:\n            return \"Error (System resource failed)\";\n    }\n    return \"Unknown\";\n}\n#endif /* !WOLFMQTT_NO_ERROR_STRINGS */\n\n#ifdef WOLFMQTT_SN\n\n/* Private functions */\nstatic int SN_Client_HandlePacket(MqttClient* client, SN_MsgType packet_type,\n    void* packet_obj, int timeout)\n{\n    int rc = MQTT_CODE_SUCCESS;\n    word16 packet_id = 0;\n\n    (void)timeout;\n\n    switch ((int)packet_type)\n    {\n        case SN_MSG_TYPE_GWINFO:\n        {\n            SN_GwInfo info, *p_info = &info;\n            if (packet_obj) {\n                p_info = (SN_GwInfo*)packet_obj;\n            }\n            else {\n                XMEMSET(p_info, 0, sizeof(SN_GwInfo));\n            }\n\n            rc = SN_Decode_GWInfo(client->rx_buf, client->packet.buf_len,\n                    p_info);\n            if (rc <= 0) {\n                return rc;\n            }\n            break;\n        }\n        case SN_MSG_TYPE_CONNACK:\n        {\n            /* Decode connect ack */\n            SN_ConnectAck connect_ack, *p_connect_ack = &connect_ack;\n            if (packet_obj) {\n                p_connect_ack = (SN_ConnectAck*)packet_obj;\n            }\n            else {\n                XMEMSET(p_connect_ack, 0, sizeof(SN_ConnectAck));\n            }\n            p_connect_ack->return_code =\n                    client->rx_buf[client->packet.buf_len-1];\n\n            break;\n        }\n        case SN_MSG_TYPE_WILLTOPICREQ:\n        {\n            rc = SN_Decode_WillTopicReq(client->rx_buf, client->packet.buf_len);\n            break;\n        }\n        case SN_MSG_TYPE_WILLMSGREQ:\n        {\n            rc = SN_Decode_WillMsgReq(client->rx_buf, client->packet.buf_len);\n            break;\n        }\n        case SN_MSG_TYPE_REGISTER:\n        {\n            /* Decode register */\n            SN_Register reg_s;\n            int len;\n\n            XMEMSET(&reg_s, 0, sizeof(SN_Register));\n\n            rc = SN_Decode_Register(client->rx_buf, client->packet.buf_len,\n                    &reg_s);\n\n            if (rc > 0) {\n                /* Initialize the regack */\n                reg_s.regack.packet_id = reg_s.packet_id;\n                reg_s.regack.topicId = reg_s.topicId;\n                reg_s.regack.return_code = SN_RC_NOTSUPPORTED;\n\n                /* Call the register callback to allow app to\n                   handle new topic ID assignment. */\n                if (client->reg_cb != NULL) {\n                     rc = client->reg_cb(reg_s.topicId,\n                            reg_s.topicName, client->reg_ctx);\n                     /* Set the regack return code */\n                     reg_s.regack.return_code = (rc >= 0) ? SN_RC_ACCEPTED :\n                             SN_RC_INVTOPICNAME;\n                }\n\n            #ifdef WOLFMQTT_MULTITHREAD\n                /* Lock send socket mutex */\n                rc = wm_SemLock(&client->lockSend);\n                if (rc != 0) {\n                    return rc;\n                }\n            #endif\n\n                /* Encode the register acknowledgment */\n                rc = SN_Encode_RegAck(client->tx_buf, client->tx_buf_len,\n                        &reg_s.regack);\n            #ifdef WOLFMQTT_DEBUG_CLIENT\n                PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d), ID %d\",\n                    rc, SN_Packet_TypeDesc(SN_MSG_TYPE_REGACK),\n                    SN_MSG_TYPE_REGACK, reg_s.packet_id);\n            #endif\n                if (rc <= 0) {\n                #ifdef WOLFMQTT_MULTITHREAD\n                    wm_SemUnlock(&client->lockSend);\n                #endif\n                    return rc;\n                }\n                len = rc;\n\n                /* Send regack packet */\n                rc = MqttPacket_Write(client, client->tx_buf, len);\n            #ifdef WOLFMQTT_MULTITHREAD\n                wm_SemUnlock(&client->lockSend);\n            #endif\n                if (rc != len) { return rc; }\n            }\n\n            break;\n        }\n        case SN_MSG_TYPE_REGACK:\n        {\n            /* Decode register ack */\n            SN_RegAck regack_s, *p_regack = &regack_s;\n            if (packet_obj) {\n                p_regack = (SN_RegAck*)packet_obj;\n            }\n            else {\n                XMEMSET(p_regack, 0, sizeof(SN_RegAck));\n            }\n\n            rc = SN_Decode_RegAck(client->rx_buf, client->packet.buf_len,\n                    p_regack);\n            if (rc > 0) {\n                packet_id = p_regack->packet_id;\n            }\n\n            break;\n        }\n        case SN_MSG_TYPE_PUBLISH:\n        {\n            SN_Publish pub, *p_pub = &pub;\n            if (packet_obj) {\n                p_pub = (SN_Publish*)packet_obj;\n            }\n            else {\n                XMEMSET(p_pub, 0, sizeof(SN_Publish));\n            }\n\n            /* Decode publish message */\n            rc = SN_Decode_Publish(client->rx_buf, client->packet.buf_len,\n                   p_pub);\n            if (rc <= 0) {\n                return rc;\n            }\n\n            /* Issue callback for new message */\n            if (client->msg_cb) {\n                /* if using the temp publish message buffer,\n                   then populate message context with client context */\n                if (&client->msgSN.publish == p_pub)\n                    p_pub->ctx = client->ctx;\n                rc = client->msg_cb(client, (MqttMessage*)p_pub, 1, 1);\n                if (rc != MQTT_CODE_SUCCESS) {\n                    return rc;\n                };\n            }\n\n            /* Handle Qos */\n            if (p_pub->qos > MQTT_QOS_0) {\n                SN_MsgType type;\n\n                packet_id = p_pub->packet_id;\n\n                /* Determine packet type to write */\n                type = (p_pub->qos == MQTT_QOS_1) ?\n                        SN_MSG_TYPE_PUBACK :\n                        SN_MSG_TYPE_PUBREC;\n                p_pub->resp.packet_id = packet_id;\n\n            #ifdef WOLFMQTT_MULTITHREAD\n                /* Lock send socket mutex */\n                rc = wm_SemLock(&client->lockSend);\n                if (rc != 0) {\n                    return rc;\n                }\n            #endif\n\n                /* Encode publish response */\n                rc = SN_Encode_PublishResp(client->tx_buf,\n                                    client->tx_buf_len, type, &p_pub->resp);\n            #ifdef WOLFMQTT_DEBUG_CLIENT\n                PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d), ID %d,\"\n                        \" QoS %d\",\n                    rc, SN_Packet_TypeDesc(type), type, packet_id,\n                    p_pub->qos);\n            #endif\n                if (rc <= 0) {\n                #ifdef WOLFMQTT_MULTITHREAD\n                    wm_SemUnlock(&client->lockSend);\n                #endif\n                    return rc;\n                }\n                client->packet.buf_len = rc;\n\n                /* Send packet */\n                rc = MqttPacket_Write(client, client->tx_buf,\n                                                    client->packet.buf_len);\n            #ifdef WOLFMQTT_MULTITHREAD\n                wm_SemUnlock(&client->lockSend);\n            #endif\n            }\n            break;\n        }\n        case SN_MSG_TYPE_PUBACK:\n        case SN_MSG_TYPE_PUBCOMP:\n        case SN_MSG_TYPE_PUBREC:\n        case SN_MSG_TYPE_PUBREL:\n        {\n            SN_PublishResp publish_resp;\n            XMEMSET(&publish_resp, 0, sizeof(SN_PublishResp));\n\n            /* Decode publish response message */\n            rc = SN_Decode_PublishResp(client->rx_buf, client->packet.buf_len,\n                packet_type, &publish_resp);\n            if (rc <= 0) {\n                return rc;\n            }\n            packet_id = publish_resp.packet_id;\n\n            /* If Qos then send response */\n            if (packet_type == SN_MSG_TYPE_PUBREC ||\n                packet_type == SN_MSG_TYPE_PUBREL) {\n\n                byte resp_type = (packet_type == SN_MSG_TYPE_PUBREC) ?\n                        SN_MSG_TYPE_PUBREL : SN_MSG_TYPE_PUBCOMP;\n\n            #ifdef WOLFMQTT_MULTITHREAD\n                /* Lock send socket mutex */\n                rc = wm_SemLock(&client->lockSend);\n                if (rc != 0) {\n                    return rc;\n                }\n            #endif\n\n                /* Encode publish response */\n                publish_resp.packet_id = packet_id;\n                rc = SN_Encode_PublishResp(client->tx_buf,\n                    client->tx_buf_len, resp_type, &publish_resp);\n            #ifdef WOLFMQTT_DEBUG_CLIENT\n                PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d), ID %d\",\n                    rc, MqttPacket_TypeDesc(resp_type), resp_type, packet_id);\n            #endif\n                if (rc <= 0) {\n                #ifdef WOLFMQTT_MULTITHREAD\n                    wm_SemUnlock(&client->lockSend);\n                #endif\n                    return rc;\n                }\n                client->packet.buf_len = rc;\n\n                /* Send packet */\n                rc = MqttPacket_Write(client, client->tx_buf,\n                        client->packet.buf_len);\n            #ifdef WOLFMQTT_MULTITHREAD\n                wm_SemUnlock(&client->lockSend);\n            #endif\n            }\n            break;\n        }\n        case SN_MSG_TYPE_SUBACK:\n        {\n            /* Decode subscribe ack */\n            SN_SubAck subscribe_ack, *p_subscribe_ack = &subscribe_ack;\n            if (packet_obj) {\n                p_subscribe_ack = (SN_SubAck*)packet_obj;\n            }\n            else {\n                XMEMSET(p_subscribe_ack, 0, sizeof(SN_SubAck));\n            }\n\n            rc = SN_Decode_SubscribeAck(client->rx_buf, client->packet.buf_len,\n                    p_subscribe_ack);\n            if (rc <= 0) {\n                return rc;\n            }\n            packet_id = p_subscribe_ack->packet_id;\n\n            break;\n        }\n        case SN_MSG_TYPE_UNSUBACK:\n        {\n            /* Decode unsubscribe ack */\n            SN_UnsubscribeAck unsubscribe_ack,\n                              *p_unsubscribe_ack = &unsubscribe_ack;\n            if (packet_obj) {\n                p_unsubscribe_ack = (SN_UnsubscribeAck*)packet_obj;\n            }\n            else {\n                XMEMSET(p_unsubscribe_ack, 0, sizeof(SN_UnsubscribeAck));\n            }\n            rc = SN_Decode_UnsubscribeAck(client->rx_buf,\n                    client->packet.buf_len, p_unsubscribe_ack);\n            if (rc <= 0) {\n                return rc;\n            }\n            packet_id = p_unsubscribe_ack->packet_id;\n\n            break;\n        }\n        case SN_MSG_TYPE_PING_RESP:\n        {\n            /* Decode ping */\n            rc = SN_Decode_Ping(client->rx_buf, client->packet.buf_len);\n            break;\n        }\n        case SN_MSG_TYPE_PING_REQ:\n        {\n            int len;\n\n            /* Decode ping */\n            rc = SN_Decode_Ping(client->rx_buf, client->packet.buf_len);\n            if (rc <= 0) { return rc; }\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock send socket mutex */\n            rc = wm_SemLock(&client->lockSend);\n            if (rc != 0) {\n                return rc;\n            }\n        #endif\n\n            /* Encode the ping packet as a response */\n            rc = SN_Encode_Ping(client->tx_buf, client->tx_buf_len, NULL,\n                    SN_MSG_TYPE_PING_RESP);\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d)\",\n                rc, SN_Packet_TypeDesc(SN_MSG_TYPE_PING_RESP),\n                SN_MSG_TYPE_PING_RESP);\n        #endif\n            if (rc <= 0) {\n            #ifdef WOLFMQTT_MULTITHREAD\n                wm_SemUnlock(&client->lockSend);\n            #endif\n                return rc;\n            }\n            len = rc;\n\n            /* Send ping resp packet */\n            rc = MqttPacket_Write(client, client->tx_buf, len);\n        #ifdef WOLFMQTT_MULTITHREAD\n            wm_SemUnlock(&client->lockSend);\n        #endif\n            if (rc != len) { return rc; }\n\n            break;\n        }\n        case SN_MSG_TYPE_WILLTOPICRESP:\n        {\n            /* Decode Will Topic Response */\n            SN_WillTopicResp resp_s, *resp = &resp_s;\n            if (packet_obj) {\n                resp = (SN_WillTopicResp*)packet_obj;\n            }\n            else {\n                XMEMSET(resp, 0, sizeof(SN_WillTopicResp));\n            }\n            rc = SN_Decode_WillTopicResponse(client->rx_buf,\n                    client->packet.buf_len, &resp->return_code);\n            break;\n        }\n        case SN_MSG_TYPE_WILLMSGRESP:\n        {\n            /* Decode Will Message Response */\n            SN_WillMsgResp resp_s, *resp = &resp_s;\n            if (packet_obj) {\n                resp = (SN_WillMsgResp*)packet_obj;\n            }\n            else {\n                XMEMSET(resp, 0, sizeof(SN_WillMsgResp));\n            }\n            rc = SN_Decode_WillMsgResponse(client->rx_buf,\n                    client->packet.buf_len, &resp->return_code);\n            break;\n        }\n        case SN_MSG_TYPE_DISCONNECT:\n        {\n            /* Decode Disconnect */\n            rc = SN_Decode_Disconnect(client->rx_buf, client->packet.buf_len);\n            break;\n        }\n\n        default:\n        {\n            /* Other types are server side only, ignore */\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"SN_Client_HandlePacket: Invalid client packet type %u!\",\n                packet_type);\n        #endif\n            break;\n        }\n    } /* switch (packet_type) */\n\n    (void)packet_id;\n\n    return rc;\n}\n\nstatic int SN_Client_WaitType(MqttClient *client, void* packet_obj,\n    byte wait_type, word16 wait_packet_id, int timeout_ms)\n{\n    int rc;\n    word16 packet_id;\n    SN_MsgType packet_type;\n#ifdef WOLFMQTT_MULTITHREAD\n    MqttPendResp *pendResp;\n    int readLocked;\n#endif\n    MqttMsgStat* mms_stat;\n    int waitMatchFound;\n\n    if (client == NULL || packet_obj == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* all packet type structures must have MqttMsgStat at top */\n    mms_stat = (MqttMsgStat*)packet_obj;\n\nwait_again:\n\n    /* initialize variables */\n    packet_id = 0;\n    packet_type = SN_MSG_TYPE_RESERVED;\n#ifdef WOLFMQTT_MULTITHREAD\n    pendResp = NULL;\n    readLocked = 0;\n#endif\n    waitMatchFound = 0;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"SN_Client_WaitType: Type %s (%d), ID %d\",\n            SN_Packet_TypeDesc((SN_MsgType)wait_type),\n                wait_type, wait_packet_id);\n#endif\n\n    switch ((int)*mms_stat)\n    {\n        case MQTT_MSG_BEGIN:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock recv socket mutex */\n            rc = wm_SemLock(&client->lockRecv);\n            if (rc != 0) {\n                PRINTF(\"SN_Client_WaitType recv lock error\");\n                return rc;\n            }\n            readLocked = 1;\n        #endif\n\n            /* reset the packet state */\n            client->packet.stat = MQTT_PK_BEGIN;\n        }\n        FALL_THROUGH;\n\n        case MQTT_MSG_WAIT:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if packet type and id have already completed */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, (MqttPacketType)wait_type,\n                        wait_packet_id, &pendResp)) {\n                    if (pendResp->packetDone) {\n                        /* pending response is already done, so return */\n                        rc = pendResp->packet_ret;\n                    #ifdef WOLFMQTT_DEBUG_CLIENT\n                        PRINTF(\"PendResp already Done %p: Rc %d\", pendResp, rc);\n                    #endif\n                        MqttClient_RespList_Remove(client, pendResp);\n                        wm_SemUnlock(&client->lockClient);\n                        wm_SemUnlock(&client->lockRecv);\n                        return rc;\n                    }\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                wm_SemUnlock(&client->lockRecv);\n                return rc;\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            *mms_stat = MQTT_MSG_WAIT;\n\n            /* Wait for packet */\n            rc = SN_Packet_Read(client, client->rx_buf, client->rx_buf_len,\n                    timeout_ms);\n            if (rc <= 0) {\n                break;\n            }\n\n            client->packet.buf_len = rc;\n\n            /* Decode header */\n            rc = SN_Decode_Header(client->rx_buf, client->packet.buf_len,\n                    &packet_type, &packet_id);\n            if (rc < 0) {\n                break;\n            }\n\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"Read Packet: Len %d, Type %d, ID %d\",\n                client->packet.buf_len, packet_type, packet_id);\n        #endif\n\n            *mms_stat = MQTT_MSG_READ;\n        }\n        FALL_THROUGH;\n\n        case MQTT_MSG_READ:\n        case MQTT_MSG_READ_PAYLOAD:\n        {\n            SN_MsgType use_packet_type;\n            void* use_packet_obj;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            readLocked = 1; /* if in this state read is locked */\n        #endif\n\n            if (*mms_stat == MQTT_MSG_READ_PAYLOAD) {\n                packet_type = SN_MSG_TYPE_PUBLISH;\n            }\n\n            /* Determine if we received data for this request */\n            if ((wait_type == SN_MSG_TYPE_ANY || wait_type == packet_type) &&\n                (wait_packet_id == 0 || wait_packet_id == packet_id))\n            {\n                use_packet_obj = packet_obj;\n                waitMatchFound = 1;\n            }\n            else {\n                /* use generic packet object */\n                use_packet_obj = &client->msgSN;\n            }\n            use_packet_type = packet_type;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if we have a pending response for this packet */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client,\n                        (MqttPacketType)packet_type, packet_id, &pendResp)) {\n                    /* we found packet match this incoming read packet */\n                    pendResp->packetProcessing = 1;\n                    use_packet_obj = pendResp->packet_obj;\n                    use_packet_type = (SN_MsgType)pendResp->packet_type;\n                    /* req from another thread... not a match */\n                    waitMatchFound = 0;\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            rc = SN_Client_HandlePacket(client, use_packet_type, use_packet_obj,\n                    timeout_ms);\n\n        #ifdef WOLFMQTT_NONBLOCK\n            if (rc == MQTT_CODE_CONTINUE) {\n                /* we have received some data, so keep the recv\n                    mutex lock active and return */\n                return rc;\n            }\n        #endif\n\n            /* handle success case */\n            if (rc >= 0) {\n                rc = MQTT_CODE_SUCCESS;\n            }\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (pendResp) {\n                /* Mark pending response entry done */\n                if (wm_SemLock(&client->lockClient) == 0) {\n                    pendResp->packetDone = 1;\n                    pendResp->packet_ret = rc;\n                #ifdef WOLFMQTT_DEBUG_CLIENT\n                    PRINTF(\"PendResp Marked Done %p\", pendResp);\n                #endif\n                    pendResp = NULL;\n                    wm_SemUnlock(&client->lockClient);\n                }\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n            break;\n        }\n\n        case MQTT_MSG_WRITE:\n        default:\n        {\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"SN_Client_WaitType: Invalid state %d!\", *mms_stat);\n        #endif\n            rc = MQTT_CODE_ERROR_STAT;\n            break;\n        }\n    } /* switch (msg->stat) */\n\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc != MQTT_CODE_CONTINUE)\n#endif\n    {\n        /* reset state */\n        *mms_stat = MQTT_MSG_BEGIN;\n    }\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (readLocked) {\n        wm_SemUnlock(&client->lockRecv);\n    }\n#endif\n\n    if (rc < 0) {\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"SN_Client_WaitType: Failure: %s (%d)\",\n            MqttClient_ReturnCodeToString(rc), rc);\n    #endif\n        return rc;\n    }\n\n    if (!waitMatchFound) {\n        /* if we get here, then the we are still waiting for a packet */\n        goto wait_again;\n    }\n\n    return rc;\n}\n\n/* Public Functions */\n\nint SN_Client_SetRegisterCallback(MqttClient *client,\n        SN_ClientRegisterCb regCb,\n        void* ctx)\n{\n    int rc = MQTT_CODE_SUCCESS;\n\n    if (client == NULL)\n        return MQTT_CODE_ERROR_BAD_ARG;\n\n#ifdef WOLFMQTT_MULTITHREAD\n    rc = wm_SemLock(&client->lockClient);\n    if (rc == 0) {\n#endif\n\n        client->reg_cb = regCb;\n        client->reg_ctx = ctx;\n\n#ifdef WOLFMQTT_MULTITHREAD\n        wm_SemUnlock(&client->lockClient);\n    }\n#endif\n\n    return rc;\n}\n\nint SN_Client_SearchGW(MqttClient *client, SN_SearchGw *search)\n{\n    int rc, len = 0;\n\n    /* Validate required arguments */\n    if (client == NULL || search == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    if (search->stat == MQTT_MSG_BEGIN) {\n    #ifdef WOLFMQTT_MULTITHREAD\n        /* Lock send socket mutex */\n        rc = wm_SemLock(&client->lockSend);\n        if (rc != 0) {\n            return rc;\n        }\n    #endif\n\n        /* Encode the search packet */\n        rc = SN_Encode_SearchGW(client->tx_buf, client->tx_buf_len,\n                search->radius);\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d)\",\n            rc, SN_Packet_TypeDesc(SN_MSG_TYPE_SEARCHGW),\n            SN_MSG_TYPE_SEARCHGW);\n    #endif\n        if (rc <= 0) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            wm_SemUnlock(&client->lockSend);\n        #endif\n            return rc;\n        }\n        len = rc;\n\n    #ifdef WOLFMQTT_MULTITHREAD\n        rc = wm_SemLock(&client->lockClient);\n        if (rc == 0) {\n            /* inform other threads of expected response */\n            rc = MqttClient_RespList_Add(client,\n                    (MqttPacketType)SN_MSG_TYPE_GWINFO, 0,\n                    &search->pendResp, &search->gwInfo);\n            wm_SemUnlock(&client->lockClient);\n        }\n        if (rc != 0) {\n            wm_SemUnlock(&client->lockSend);\n            return rc; /* Error locking client */\n        }\n    #endif\n\n        /* Send search for gateway packet */\n        rc = MqttPacket_Write(client, client->tx_buf, len);\n    #ifdef WOLFMQTT_MULTITHREAD\n        wm_SemUnlock(&client->lockSend);\n    #endif\n        if (rc != len) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (wm_SemLock(&client->lockClient) == 0) {\n                MqttClient_RespList_Remove(client, &search->pendResp);\n                wm_SemUnlock(&client->lockClient);\n            }\n        #endif\n            return rc;\n        }\n        search->stat = MQTT_MSG_WAIT;\n    }\n\n    /* Wait for gateway info packet */\n    rc = SN_Client_WaitType(client, &search->gwInfo, SN_MSG_TYPE_GWINFO, 0,\n        client->cmd_timeout_ms);\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc == MQTT_CODE_CONTINUE)\n        return rc;\n#endif\n#ifdef WOLFMQTT_MULTITHREAD\n    if (wm_SemLock(&client->lockClient) == 0) {\n        MqttClient_RespList_Remove(client, &search->pendResp);\n        wm_SemUnlock(&client->lockClient);\n    }\n#endif\n\n    /* reset state */\n    search->stat = MQTT_MSG_BEGIN;\n\n    return rc;\n}\n\nstatic int SN_WillTopic(MqttClient *client, SN_Will *will)\n{\n    int rc, len;\n\n    /* Validate required arguments */\n    if (client == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n#ifdef WOLFMQTT_MULTITHREAD\n    rc = wm_SemLock(&client->lockClient);\n    if (rc == 0) {\n        /* inform other threads of expected response */\n        rc = MqttClient_RespList_Add(client,\n                (MqttPacketType)SN_MSG_TYPE_WILLTOPICREQ, 0,\n                &will->pendResp, &will->resp.topicResp);\n        wm_SemUnlock(&client->lockClient);\n    }\n    if (rc != 0) {\n        return rc; /* Error locking client */\n    }\n#endif\n\n    /* Wait for Will Topic Request packet */\n    rc = SN_Client_WaitType(client, will,\n            SN_MSG_TYPE_WILLTOPICREQ, 0, client->cmd_timeout_ms);\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc == MQTT_CODE_CONTINUE)\n        return rc;\n#endif\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (wm_SemLock(&client->lockClient) == 0) {\n        MqttClient_RespList_Remove(client, &will->pendResp);\n        wm_SemUnlock(&client->lockClient);\n    }\n#endif\n    if (rc == 0) {\n    #ifdef WOLFMQTT_MULTITHREAD\n        /* Lock send socket mutex */\n        rc = wm_SemLock(&client->lockSend);\n        if (rc != 0) {\n            return rc;\n        }\n    #endif\n\n        /* Encode Will Topic */\n        len = rc = SN_Encode_WillTopic(client->tx_buf, client->tx_buf_len,\n                will);\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"EncodePacket: Len %d, Type %s (%d)\",\n            rc, SN_Packet_TypeDesc(SN_MSG_TYPE_WILLTOPIC),\n            SN_MSG_TYPE_WILLTOPIC);\n    #endif\n        if (rc > 0) {\n            /* Send Will Topic packet */\n            rc = MqttPacket_Write(client, client->tx_buf, len);\n            if (rc == len) {\n                rc = 0;\n            }\n        }\n    #ifdef WOLFMQTT_MULTITHREAD\n        wm_SemUnlock(&client->lockSend);\n    #endif\n    }\n\n    return rc;\n}\n\nstatic int SN_WillMessage(MqttClient *client, SN_Will *will)\n{\n    int rc, len;\n\n    /* Validate required arguments */\n    if (client == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n#ifdef WOLFMQTT_MULTITHREAD\n    rc = wm_SemLock(&client->lockClient);\n    if (rc == 0) {\n        /* inform other threads of expected response */\n        rc = MqttClient_RespList_Add(client,\n                (MqttPacketType)SN_MSG_TYPE_WILLMSGREQ, 0,\n                &will->pendResp, &will->resp.msgResp);\n        wm_SemUnlock(&client->lockClient);\n    }\n    if (rc != 0) {\n        return rc; /* Error locking client */\n    }\n#endif\n\n    /* Wait for Will Message Request */\n    rc = SN_Client_WaitType(client, &will->resp.msgResp,\n            SN_MSG_TYPE_WILLMSGREQ, 0, client->cmd_timeout_ms);\n\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc == MQTT_CODE_CONTINUE)\n        return rc;\n#endif\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (wm_SemLock(&client->lockClient) == 0) {\n        MqttClient_RespList_Remove(client, &will->pendResp);\n        wm_SemUnlock(&client->lockClient);\n    }\n#endif\n\n    if (rc == 0) {\n    #ifdef WOLFMQTT_MULTITHREAD\n        /* Lock send socket mutex */\n        rc = wm_SemLock(&client->lockSend);\n        if (rc != 0) {\n            return rc;\n        }\n    #endif\n        /* Encode Will Message */\n        len = rc = SN_Encode_WillMsg(client->tx_buf,\n            client->tx_buf_len, will);\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"EncodePacket: Len %d, Type %s (%d)\",\n            rc, SN_Packet_TypeDesc(SN_MSG_TYPE_WILLMSG),\n            SN_MSG_TYPE_WILLMSG);\n    #endif\n        if (rc > 0) {\n            /* Send Will Topic packet */\n            rc = MqttPacket_Write(client, client->tx_buf, len);\n            if (rc == len) {\n                rc = 0;\n            }\n        }\n    #ifdef WOLFMQTT_MULTITHREAD\n        wm_SemUnlock(&client->lockSend);\n    #endif\n    }\n\n    return rc;\n}\n\nint SN_Client_Connect(MqttClient *client, SN_Connect *mc_connect)\n{\n    int rc = 0, len = 0;\n    static byte will_done;\n\n    /* Validate required arguments */\n    if ((client == NULL) || (mc_connect == NULL)) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    if (mc_connect->stat == MQTT_MSG_BEGIN) {\n\n        will_done = 0;\n\n    #ifdef WOLFMQTT_MULTITHREAD\n        /* Lock send socket mutex */\n        rc = wm_SemLock(&client->lockSend);\n        if (rc != 0) {\n            return rc;\n        }\n    #endif\n\n    /* Encode the connect packet */\n        rc = SN_Encode_Connect(client->tx_buf, client->tx_buf_len, mc_connect);\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d), ID %d, QoS %d\",\n        rc, SN_Packet_TypeDesc(SN_MSG_TYPE_CONNECT),\n        SN_MSG_TYPE_CONNECT, 0, 0);\n#endif\n        if (rc <= 0) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            wm_SemUnlock(&client->lockSend);\n        #endif\n            return rc;\n        }\n        len = rc;\n\n    #ifdef WOLFMQTT_MULTITHREAD\n        rc = wm_SemLock(&client->lockClient);\n        if (rc == 0) {\n            /* inform other threads of expected response */\n            rc = MqttClient_RespList_Add(client,\n                    (MqttPacketType)SN_MSG_TYPE_CONNACK, 0,\n                    &mc_connect->pendResp, &mc_connect->ack);\n            wm_SemUnlock(&client->lockClient);\n        }\n        if (rc != 0) {\n            wm_SemUnlock(&client->lockSend);\n            return rc; /* Error locking client */\n        }\n    #endif\n\n        /* Send connect packet */\n        rc = MqttPacket_Write(client, client->tx_buf, len);\n    #ifdef WOLFMQTT_MULTITHREAD\n        wm_SemUnlock(&client->lockSend);\n    #endif\n        if (rc != len) {\n            return rc;\n        }\n\n        mc_connect->stat = MQTT_MSG_WAIT;\n    }\n\n    if ((mc_connect->enable_lwt == 1) && (will_done != 1)) {\n        /* If the will is enabled, then the gateway requests the topic and\n           message in separate packets. */\n        rc = SN_WillTopic(client, &mc_connect->will);\n        if (rc != 0) {\n            return rc;\n        }\n\n        rc = SN_WillMessage(client, &mc_connect->will);\n        if (rc != 0) {\n            return rc;\n        }\n        will_done = 1;\n    }\n\n    /* Wait for connect ack packet */\n    rc = SN_Client_WaitType(client, &mc_connect->ack,\n            SN_MSG_TYPE_CONNACK, 0, client->cmd_timeout_ms);\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc == MQTT_CODE_CONTINUE)\n        return rc;\n#endif\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (wm_SemLock(&client->lockClient) == 0) {\n        MqttClient_RespList_Remove(client, &mc_connect->pendResp);\n        wm_SemUnlock(&client->lockClient);\n    }\n#endif\n\n    /* reset state */\n    mc_connect->stat = MQTT_MSG_BEGIN;\n\n    return rc;\n}\n\nint SN_Client_WillTopicUpdate(MqttClient *client, SN_Will *will)\n{\n    int rc = 0, len = 0;\n\n    /* Validate required arguments */\n    if (client == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    if (will->stat == MQTT_MSG_BEGIN) {\n    #ifdef WOLFMQTT_MULTITHREAD\n        /* Lock send socket mutex */\n        rc = wm_SemLock(&client->lockSend);\n        if (rc != 0) {\n            return rc;\n        }\n    #endif\n\n        /* Encode Will Topic Update */\n        len = rc = SN_Encode_WillTopicUpdate(client->tx_buf,\n                client->tx_buf_len, will);\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d)\",\n            rc, SN_Packet_TypeDesc(SN_MSG_TYPE_WILLTOPICUPD),\n            SN_MSG_TYPE_WILLTOPICUPD);\n    #endif\n        if (rc <= 0) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            wm_SemUnlock(&client->lockSend);\n        #endif\n            return rc;\n        }\n\n    #ifdef WOLFMQTT_MULTITHREAD\n        rc = wm_SemLock(&client->lockClient);\n        if (rc == 0) {\n            /* inform other threads of expected response */\n            rc = MqttClient_RespList_Add(client,\n                    (MqttPacketType)SN_MSG_TYPE_WILLTOPICRESP,\n                    0, &will->pendResp, &will->resp.topicResp);\n            wm_SemUnlock(&client->lockClient);\n        }\n        if (rc != 0) {\n            wm_SemUnlock(&client->lockSend);\n            return rc; /* Error locking client */\n        }\n    #endif\n\n        /* Send Will Topic Update packet */\n        rc = MqttPacket_Write(client, client->tx_buf, len);\n    #ifdef WOLFMQTT_MULTITHREAD\n        wm_SemUnlock(&client->lockSend);\n    #endif\n        if (rc != len) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (wm_SemLock(&client->lockClient) == 0) {\n                MqttClient_RespList_Remove(client, &will->pendResp);\n                wm_SemUnlock(&client->lockClient);\n            }\n        #endif\n        }\n        will->stat = MQTT_MSG_WAIT;\n    }\n\n    /* Wait for Will Topic Update Response packet */\n    rc = SN_Client_WaitType(client, &will->resp.topicResp,\n            SN_MSG_TYPE_WILLTOPICRESP, 0, client->cmd_timeout_ms);\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc == MQTT_CODE_CONTINUE)\n        return rc;\n#endif\n#ifdef WOLFMQTT_MULTITHREAD\n    if (wm_SemLock(&client->lockClient) == 0) {\n        MqttClient_RespList_Remove(client, &will->pendResp);\n        wm_SemUnlock(&client->lockClient);\n    }\n#endif\n\n    /* reset state */\n    will->stat = MQTT_MSG_BEGIN;\n\n    return rc;\n}\n\nint SN_Client_WillMsgUpdate(MqttClient *client, SN_Will *will)\n{\n    int rc = 0, len = 0;\n\n    /* Validate required arguments */\n    if ((client == NULL) || (will == NULL)) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    if (will->stat == MQTT_MSG_BEGIN) {\n    #ifdef WOLFMQTT_MULTITHREAD\n        /* Lock send socket mutex */\n        rc = wm_SemLock(&client->lockSend);\n        if (rc != 0) {\n            return rc;\n        }\n    #endif\n        /* Encode Will Message Update */\n        len = rc = SN_Encode_WillMsgUpdate(client->tx_buf,\n                client->tx_buf_len, will);\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d)\",\n            rc, SN_Packet_TypeDesc(SN_MSG_TYPE_WILLTOPICUPD),\n            SN_MSG_TYPE_WILLTOPICUPD);\n    #endif\n        if (rc <= 0) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            wm_SemUnlock(&client->lockSend);\n        #endif\n            return rc;\n        }\n\n    #ifdef WOLFMQTT_MULTITHREAD\n        rc = wm_SemLock(&client->lockClient);\n        if (rc == 0) {\n            /* inform other threads of expected response */\n            rc = MqttClient_RespList_Add(client,\n                    (MqttPacketType)SN_MSG_TYPE_WILLMSGRESP,\n                    0, &will->pendResp, &will->resp.msgResp);\n            wm_SemUnlock(&client->lockClient);\n        }\n        if (rc != 0) {\n            wm_SemUnlock(&client->lockSend);\n            return rc; /* Error locking client */\n        }\n    #endif\n\n        /* Send Will Message Update packet */\n        rc = MqttPacket_Write(client, client->tx_buf, len);\n    #ifdef WOLFMQTT_MULTITHREAD\n        wm_SemUnlock(&client->lockSend);\n    #endif\n        if (rc != len) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (wm_SemLock(&client->lockClient) == 0) {\n                MqttClient_RespList_Remove(client, &will->pendResp);\n                wm_SemUnlock(&client->lockClient);\n            }\n        #endif\n        }\n        will->stat = MQTT_MSG_WAIT;\n    }\n\n    /* Wait for Will Message Update Response packet */\n    rc = SN_Client_WaitType(client, &will->resp.msgResp,\n            SN_MSG_TYPE_WILLMSGRESP, 0, client->cmd_timeout_ms);\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc == MQTT_CODE_CONTINUE)\n        return rc;\n#endif\n#ifdef WOLFMQTT_MULTITHREAD\n    if (wm_SemLock(&client->lockClient) == 0) {\n        MqttClient_RespList_Remove(client, &will->pendResp);\n        wm_SemUnlock(&client->lockClient);\n    }\n#endif\n\n    /* reset state */\n    will->stat = MQTT_MSG_BEGIN;\n\n    return rc;\n\n}\n\nint SN_Client_Subscribe(MqttClient *client, SN_Subscribe *subscribe)\n{\n    int rc = -1, len;\n\n    /* Validate required arguments */\n    if (client == NULL || subscribe == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    if (subscribe->stat == MQTT_MSG_BEGIN) {\n    #ifdef WOLFMQTT_MULTITHREAD\n        /* Lock send socket mutex */\n        rc = wm_SemLock(&client->lockSend);\n        if (rc != 0) {\n            return rc;\n        }\n    #endif\n\n        /* Encode the subscribe packet */\n        rc = SN_Encode_Subscribe(client->tx_buf, client->tx_buf_len,\n                subscribe);\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d), QoS %d\",\n            rc, SN_Packet_TypeDesc(SN_MSG_TYPE_SUBSCRIBE),\n            SN_MSG_TYPE_SUBSCRIBE, subscribe->qos);\n    #endif\n        if (rc <= 0) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            wm_SemUnlock(&client->lockSend);\n        #endif\n            return rc;\n        }\n        len = rc;\n\n    #ifdef WOLFMQTT_MULTITHREAD\n        rc = wm_SemLock(&client->lockClient);\n        if (rc == 0) {\n            /* inform other threads of expected response */\n            rc = MqttClient_RespList_Add(client,\n                    (MqttPacketType)SN_MSG_TYPE_SUBACK, subscribe->packet_id,\n                    &subscribe->pendResp, &subscribe->subAck);\n            wm_SemUnlock(&client->lockClient);\n        }\n        if (rc != 0) {\n            wm_SemUnlock(&client->lockSend);\n            return rc; /* Error locking client */\n        }\n    #endif\n\n        /* Send subscribe packet */\n        rc = MqttPacket_Write(client, client->tx_buf, len);\n    #ifdef WOLFMQTT_MULTITHREAD\n        wm_SemUnlock(&client->lockSend);\n    #endif\n        if (rc != len) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (wm_SemLock(&client->lockClient) == 0) {\n                MqttClient_RespList_Remove(client, &subscribe->pendResp);\n                wm_SemUnlock(&client->lockClient);\n            }\n        #endif\n            return rc;\n        }\n\n        subscribe->stat = MQTT_MSG_WAIT;\n    }\n\n    /* Wait for subscribe ack packet */\n    rc = SN_Client_WaitType(client, &subscribe->subAck,\n            SN_MSG_TYPE_SUBACK, subscribe->packet_id, client->cmd_timeout_ms);\n\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc == MQTT_CODE_CONTINUE)\n        return rc;\n#endif\n#ifdef WOLFMQTT_MULTITHREAD\n    if (wm_SemLock(&client->lockClient) == 0) {\n        MqttClient_RespList_Remove(client, &subscribe->pendResp);\n        wm_SemUnlock(&client->lockClient);\n    }\n#endif\n\n    /* reset state */\n    subscribe->stat = MQTT_MSG_BEGIN;\n\n    return rc;\n}\n\nint SN_Client_Publish(MqttClient *client, SN_Publish *publish)\n{\n    int rc = MQTT_CODE_SUCCESS;\n    SN_MsgType resp_type;\n\n    /* Validate required arguments */\n    if (client == NULL || publish == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    switch ((int)publish->stat)\n    {\n        case MQTT_MSG_BEGIN:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock send socket mutex */\n            rc = wm_SemLock(&client->lockSend);\n            if (rc != 0) {\n                return rc;\n            }\n        #endif\n\n            /* Encode the publish packet */\n            rc = SN_Encode_Publish(client->tx_buf, client->tx_buf_len,\n                    publish);\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d), ID %d,\"\n                    \" QoS %d\",\n                rc, SN_Packet_TypeDesc(SN_MSG_TYPE_PUBLISH),\n                SN_MSG_TYPE_PUBLISH, publish->packet_id,\n                publish->qos);\n        #endif\n            if (rc <= 0) {\n            #ifdef WOLFMQTT_MULTITHREAD\n                wm_SemUnlock(&client->lockSend);\n            #endif\n                return rc;\n            }\n\n            client->write.len = rc;\n            publish->buffer_pos = 0;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            if ((publish->qos == MQTT_QOS_1) ||\n                (publish->qos == MQTT_QOS_2)) {\n                resp_type = (publish->qos == MQTT_QOS_1) ?\n                        SN_MSG_TYPE_PUBACK :\n                        SN_MSG_TYPE_PUBCOMP;\n\n                rc = wm_SemLock(&client->lockClient);\n                if (rc == 0) {\n                    /* inform other threads of expected response */\n                    rc = MqttClient_RespList_Add(client,\n                            (MqttPacketType)resp_type, publish->packet_id,\n                            &publish->pendResp, &publish->resp);\n                    wm_SemUnlock(&client->lockClient);\n                }\n                if (rc != 0) {\n                    wm_SemUnlock(&client->lockSend);\n                    return rc; /* Error locking client */\n                }\n            }\n        #endif\n\n            publish->stat = MQTT_MSG_WRITE;\n        }\n        FALL_THROUGH;\n\n        case MQTT_MSG_WRITE:\n        {\n            /* Send packet and payload */\n            rc = MqttPacket_Write(client, client->tx_buf,\n                    client->write.len);\n        #ifdef WOLFMQTT_NONBLOCK\n            if (rc == MQTT_CODE_CONTINUE)\n                return rc;\n        #endif\n        #ifdef WOLFMQTT_MULTITHREAD\n            wm_SemUnlock(&client->lockSend);\n        #endif\n\n            if (rc < 0) {\n            #ifdef WOLFMQTT_MULTITHREAD\n                if (wm_SemLock(&client->lockClient) == 0) {\n                    MqttClient_RespList_Remove(client, &publish->pendResp);\n                    wm_SemUnlock(&client->lockClient);\n                }\n            #endif\n                return rc;\n            }\n\n            if (rc == client->write.len) {\n                rc = MQTT_CODE_SUCCESS;\n            }\n            else {\n                rc = -1;\n            }\n\n            /* if not expecting a reply, the reset state and exit */\n            if ((publish->qos == MQTT_QOS_0) ||\n                (publish->qos == MQTT_QOS_3)) {\n                break;\n            }\n\n            publish->stat = MQTT_MSG_WAIT;\n        }\n        FALL_THROUGH;\n\n        case MQTT_MSG_WAIT:\n        {\n            /* Handle QoS */\n            if ((publish->qos == MQTT_QOS_1) ||\n                (publish->qos == MQTT_QOS_2)) {\n\n                /* Determine packet type to wait for */\n                resp_type = (publish->qos == MQTT_QOS_1) ?\n                        SN_MSG_TYPE_PUBACK :\n                        SN_MSG_TYPE_PUBCOMP;\n\n                /* Wait for publish response packet */\n                rc = SN_Client_WaitType(client, &publish->resp,\n                    resp_type, publish->packet_id, client->cmd_timeout_ms);\n            #ifdef WOLFMQTT_NONBLOCK\n                if (rc == MQTT_CODE_CONTINUE)\n                    break;\n            #endif\n            #ifdef WOLFMQTT_MULTITHREAD\n                if (wm_SemLock(&client->lockClient) == 0) {\n                    MqttClient_RespList_Remove(client, &publish->pendResp);\n                    wm_SemUnlock(&client->lockClient);\n                }\n            #endif\n\n                publish->return_code = publish->resp.return_code;\n            }\n\n            break;\n        }\n\n        case MQTT_MSG_READ:\n        case MQTT_MSG_READ_PAYLOAD:\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"SN_Client_Publish: Invalid state %d!\",\n                publish->stat);\n        #endif\n            rc = MQTT_CODE_ERROR_STAT;\n            break;\n    } /* switch (publish->stat) */\n\n    /* reset state */\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc != MQTT_CODE_CONTINUE)\n#endif\n    {\n        publish->stat = MQTT_MSG_BEGIN;\n    }\n    if (rc > 0) {\n        rc = MQTT_CODE_SUCCESS;\n    }\n\n    return rc;\n}\n\nint SN_Client_Unsubscribe(MqttClient *client, SN_Unsubscribe *unsubscribe)\n{\n    int rc, len;\n\n    /* Validate required arguments */\n    if (client == NULL || unsubscribe == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    if (unsubscribe->stat == MQTT_MSG_BEGIN) {\n    #ifdef WOLFMQTT_MULTITHREAD\n        /* Lock send socket mutex */\n        rc = wm_SemLock(&client->lockSend);\n        if (rc != 0) {\n            return rc;\n        }\n    #endif\n\n        /* Encode the subscribe packet */\n        rc = SN_Encode_Unsubscribe(client->tx_buf, client->tx_buf_len,\n            unsubscribe);\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d)\",\n            rc, SN_Packet_TypeDesc(SN_MSG_TYPE_UNSUBSCRIBE),\n            SN_MSG_TYPE_UNSUBSCRIBE);\n    #endif\n        if (rc <= 0) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            wm_SemUnlock(&client->lockSend);\n        #endif\n            return rc;\n        }\n        len = rc;\n\n    #ifdef WOLFMQTT_MULTITHREAD\n        rc = wm_SemLock(&client->lockClient);\n        if (rc == 0) {\n            /* inform other threads of expected response */\n            rc = MqttClient_RespList_Add(client,\n                    (MqttPacketType)SN_MSG_TYPE_UNSUBACK,\n                    0, &unsubscribe->pendResp, &unsubscribe->ack);\n            wm_SemUnlock(&client->lockClient);\n        }\n        if (rc != 0) {\n            wm_SemUnlock(&client->lockSend);\n            return rc; /* Error locking client */\n        }\n    #endif\n\n        /* Send unsubscribe packet */\n        rc = MqttPacket_Write(client, client->tx_buf, len);\n    #ifdef WOLFMQTT_MULTITHREAD\n        wm_SemUnlock(&client->lockSend);\n    #endif\n        if (rc != len) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (wm_SemLock(&client->lockClient) == 0) {\n                MqttClient_RespList_Remove(client, &unsubscribe->pendResp);\n                wm_SemUnlock(&client->lockClient);\n            }\n        #endif\n        }\n        unsubscribe->stat = MQTT_MSG_WAIT;\n    }\n\n    /* Wait for unsubscribe ack packet */\n    rc = SN_Client_WaitType(client, &unsubscribe->ack,\n            SN_MSG_TYPE_UNSUBACK, unsubscribe->packet_id,\n            client->cmd_timeout_ms);\n    #ifdef WOLFMQTT_NONBLOCK\n        if (rc == MQTT_CODE_CONTINUE)\n            return rc;\n    #endif\n    #ifdef WOLFMQTT_MULTITHREAD\n        if (wm_SemLock(&client->lockClient) == 0) {\n            MqttClient_RespList_Remove(client, &unsubscribe->pendResp);\n            wm_SemUnlock(&client->lockClient);\n        }\n    #endif\n\n    /* reset state */\n    unsubscribe->stat = MQTT_MSG_BEGIN;\n\n    return rc;\n}\n\nint SN_Client_Register(MqttClient *client, SN_Register *regist)\n{\n    int rc, len;\n\n    /* Validate required arguments */\n    if (client == NULL || regist == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    if (regist->stat == MQTT_MSG_BEGIN) {\n    #ifdef WOLFMQTT_MULTITHREAD\n        /* Lock send socket mutex */\n        rc = wm_SemLock(&client->lockSend);\n        if (rc != 0) {\n            return rc;\n        }\n    #endif\n\n        /* Encode the register packet */\n        rc = SN_Encode_Register(client->tx_buf, client->tx_buf_len, regist);\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d)\",\n            rc, SN_Packet_TypeDesc(SN_MSG_TYPE_REGISTER),\n            SN_MSG_TYPE_REGISTER);\n    #endif\n        if (rc <= 0) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            wm_SemUnlock(&client->lockSend);\n        #endif\n            return rc;\n        }\n        len = rc;\n\n    #ifdef WOLFMQTT_MULTITHREAD\n        rc = wm_SemLock(&client->lockClient);\n        if (rc == 0) {\n            /* inform other threads of expected response */\n            rc = MqttClient_RespList_Add(client,\n                    (MqttPacketType)SN_MSG_TYPE_REGACK,\n                    regist->packet_id, &regist->pendResp, &regist->regack);\n            wm_SemUnlock(&client->lockClient);\n        }\n        if (rc != 0) {\n            wm_SemUnlock(&client->lockSend);\n            return rc; /* Error locking client */\n        }\n    #endif\n\n        /* Send register packet */\n        rc = MqttPacket_Write(client, client->tx_buf, len);\n    #ifdef WOLFMQTT_MULTITHREAD\n        wm_SemUnlock(&client->lockSend);\n    #endif\n        if (rc != len) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (wm_SemLock(&client->lockClient) == 0) {\n                MqttClient_RespList_Remove(client, &regist->pendResp);\n                wm_SemUnlock(&client->lockClient);\n            }\n        #endif\n            return rc;\n        }\n\n        regist->stat = MQTT_MSG_WAIT;\n    }\n\n    /* Wait for register acknowledge packet */\n    rc = SN_Client_WaitType(client, &regist->regack,\n            SN_MSG_TYPE_REGACK, regist->packet_id, client->cmd_timeout_ms);\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc == MQTT_CODE_CONTINUE)\n        return rc;\n#endif\n#ifdef WOLFMQTT_MULTITHREAD\n    if (wm_SemLock(&client->lockClient) == 0) {\n        MqttClient_RespList_Remove(client, &regist->pendResp);\n        wm_SemUnlock(&client->lockClient);\n    }\n#endif\n\n    /* reset state */\n    regist->stat = MQTT_MSG_BEGIN;\n\n    return rc;\n}\n\nint SN_Client_Ping(MqttClient *client, SN_PingReq *ping)\n{\n    int rc, len;\n    SN_PingReq loc_ping;\n\n    /* Validate required arguments */\n    if (client == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    if (ping == NULL) {\n        XMEMSET(&loc_ping, 0, sizeof(SN_PingReq));\n        ping = &loc_ping;\n    }\n\n    if (ping->stat == MQTT_MSG_BEGIN) {\n    #ifdef WOLFMQTT_MULTITHREAD\n        /* Lock send socket mutex */\n        rc = wm_SemLock(&client->lockSend);\n        if (rc != 0) {\n            return rc;\n        }\n    #endif\n\n        /* Encode the ping packet as a request */\n        rc = SN_Encode_Ping(client->tx_buf, client->tx_buf_len, ping,\n                SN_MSG_TYPE_PING_REQ);\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d)\",\n            rc, SN_Packet_TypeDesc(SN_MSG_TYPE_PING_REQ),\n            SN_MSG_TYPE_PING_REQ);\n    #endif\n        if (rc <= 0) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            wm_SemUnlock(&client->lockSend);\n        #endif\n            return rc;\n        }\n        len = rc;\n\n    #ifdef WOLFMQTT_MULTITHREAD\n        rc = wm_SemLock(&client->lockClient);\n        if (rc == 0) {\n            /* inform other threads of expected response */\n            rc = MqttClient_RespList_Add(client,\n                    (MqttPacketType)SN_MSG_TYPE_PING_RESP, 0,\n                    &ping->pendResp, NULL);\n            wm_SemUnlock(&client->lockClient);\n        }\n        if (rc != 0) {\n            wm_SemUnlock(&client->lockSend);\n            return rc; /* Error locking client */\n        }\n    #endif\n\n        /* Send ping req packet */\n        rc = MqttPacket_Write(client, client->tx_buf, len);\n    #ifdef WOLFMQTT_MULTITHREAD\n        wm_SemUnlock(&client->lockSend);\n    #endif\n        if (rc != len) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (wm_SemLock(&client->lockClient) == 0) {\n                MqttClient_RespList_Remove(client, &ping->pendResp);\n                wm_SemUnlock(&client->lockClient);\n            }\n        #endif\n            return rc;\n        }\n\n        ping->stat = MQTT_MSG_WAIT;\n    }\n\n    /* Wait for ping resp packet */\n    rc = SN_Client_WaitType(client, ping,\n            SN_MSG_TYPE_PING_RESP, 0, client->cmd_timeout_ms);\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc == MQTT_CODE_CONTINUE)\n        return rc;\n#endif\n#ifdef WOLFMQTT_MULTITHREAD\n    if (wm_SemLock(&client->lockClient) == 0) {\n        MqttClient_RespList_Remove(client, &ping->pendResp);\n        wm_SemUnlock(&client->lockClient);\n    }\n#endif\n\n    /* reset state */\n    ping->stat = MQTT_MSG_BEGIN;\n\n    return rc;\n}\n\nint SN_Client_Disconnect(MqttClient *client)\n{\n    return SN_Client_Disconnect_ex(client, NULL);\n}\n\nint SN_Client_Disconnect_ex(MqttClient *client, SN_Disconnect *disconnect)\n{\n    int rc, len;\n\n    /* Validate required arguments */\n    if (client == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n#ifdef WOLFMQTT_MULTITHREAD\n    /* Lock send socket mutex */\n    rc = wm_SemLock(&client->lockSend);\n    if (rc != 0) {\n        return rc;\n    }\n#endif\n\n    /* Encode the disconnect packet */\n    rc = SN_Encode_Disconnect(client->tx_buf, client->tx_buf_len, disconnect);\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d)\",\n        rc, SN_Packet_TypeDesc(SN_MSG_TYPE_DISCONNECT),\n        SN_MSG_TYPE_DISCONNECT);\n#endif\n    if (rc <= 0) {\n    #ifdef WOLFMQTT_MULTITHREAD\n        wm_SemUnlock(&client->lockSend);\n    #endif\n        return rc;\n    }\n    len = rc;\n\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if ((disconnect != NULL) && (disconnect->sleepTmr != 0)) {\n        rc = wm_SemLock(&client->lockClient);\n        if (rc == 0) {\n            /* inform other threads of expected response */\n            rc = MqttClient_RespList_Add(client,\n                    (MqttPacketType)SN_MSG_TYPE_DISCONNECT, 0,\n                    &disconnect->pendResp, NULL);\n            wm_SemUnlock(&client->lockClient);\n        }\n        if (rc != 0) {\n            wm_SemUnlock(&client->lockSend);\n            return rc; /* Error locking client */\n        }\n    }\n#endif\n\n    /* Send disconnect packet */\n    rc = MqttPacket_Write(client, client->tx_buf, len);\n#ifdef WOLFMQTT_MULTITHREAD\n    wm_SemUnlock(&client->lockSend);\n#endif\n    if (rc != len) {\n    #ifdef WOLFMQTT_MULTITHREAD\n        if (wm_SemLock(&client->lockClient) == 0) {\n            MqttClient_RespList_Remove(client, &disconnect->pendResp);\n            wm_SemUnlock(&client->lockClient);\n        }\n    #endif\n        return rc;\n    }\n    else {\n        rc = MQTT_CODE_SUCCESS;\n    }\n\n    /* If sleep was set, wait for response disconnect packet */\n    if ((disconnect != NULL) && (disconnect->sleepTmr != 0)) {\n        rc = SN_Client_WaitType(client, disconnect,\n                SN_MSG_TYPE_DISCONNECT, 0, client->cmd_timeout_ms);\n    #ifdef WOLFMQTT_NONBLOCK\n        if (rc == MQTT_CODE_CONTINUE)\n            return rc;\n    #endif\n    #ifdef WOLFMQTT_MULTITHREAD\n        if (wm_SemLock(&client->lockClient) == 0) {\n            MqttClient_RespList_Remove(client, &disconnect->pendResp);\n            wm_SemUnlock(&client->lockClient);\n        }\n    #endif\n    }\n\n    return rc;\n}\n\nint SN_Client_WaitMessage_ex(MqttClient *client, SN_Object* packet_obj,\n        int timeout_ms)\n{\n    return SN_Client_WaitType(client, packet_obj,\n        SN_MSG_TYPE_ANY, 0, timeout_ms);\n}\n\nint SN_Client_WaitMessage(MqttClient *client, int timeout_ms)\n{\n    if (client == NULL)\n        return MQTT_CODE_ERROR_BAD_ARG;\n    return SN_Client_WaitMessage_ex(client, &client->msgSN, timeout_ms);\n}\n\n#endif /* defined WOLFMQTT_SN */\n"], "fixing_code": ["/* mqtt_client.c\n *\n * Copyright (C) 2006-2021 wolfSSL Inc.\n *\n * This file is part of wolfMQTT.\n *\n * wolfMQTT is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * wolfMQTT is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335, USA\n */\n\n/* Include the autoconf generated config.h */\n#ifdef HAVE_CONFIG_H\n    #include <config.h>\n#endif\n\n#include \"wolfmqtt/mqtt_client.h\"\n\n/* Options */\n#ifdef WOLFMQTT_NO_STDIO\n    #undef WOLFMQTT_DEBUG_CLIENT\n#endif\n\n/* Private functions */\n\n/* forward declarations */\nstatic int MqttClient_Publish_ReadPayload(MqttClient* client,\n    MqttPublish* publish, int timeout_ms);\n\n#ifdef WOLFMQTT_MULTITHREAD\n\n#ifdef __MACH__\n    /* Apple style dispatch semaphore */\n    int wm_SemInit(wm_Sem *s){\n        /* dispatch_release() fails hard, with Trace/BPT trap signal, if the\n         * sem's internal count is less than the value passed in with\n         * dispatch_semaphore_create().  work around this by initing\n         * with 0, then incrementing it afterwards.\n         */\n        *s = dispatch_semaphore_create(0);\n        if (*s == NULL)\n            return MQTT_CODE_ERROR_MEMORY;\n        if (dispatch_semaphore_signal(*s) < 0) {\n            dispatch_release(*s);\n            return MQTT_CODE_ERROR_SYSTEM;\n        }\n\n        return 0;\n    }\n    int wm_SemFree(wm_Sem *s){\n        if ((s == NULL) ||\n            (*s == NULL))\n            return MQTT_CODE_ERROR_BAD_ARG;\n        dispatch_release(*s);\n        *s = NULL;\n        return 0;\n    }\n    int wm_SemLock(wm_Sem *s){\n        dispatch_semaphore_wait(*s, DISPATCH_TIME_FOREVER);\n        return 0;\n    }\n    int wm_SemUnlock(wm_Sem *s){\n        dispatch_semaphore_signal(*s);\n        return 0;\n    }\n#elif defined(WOLFMQTT_POSIX_SEMAPHORES)\n    /* Posix style semaphore */\n    int wm_SemInit(wm_Sem *s){\n        s->lockCount = 0;\n        pthread_mutex_init(&s->mutex, NULL);\n        pthread_cond_init(&s->cond, NULL);\n        return 0;\n    }\n    int wm_SemFree(wm_Sem *s){\n        pthread_mutex_destroy(&s->mutex);\n        pthread_cond_destroy(&s->cond);\n        return 0;\n    }\n    int wm_SemLock(wm_Sem *s){\n        pthread_mutex_lock(&s->mutex);\n        while (s->lockCount > 0)\n            pthread_cond_wait(&s->cond, &s->mutex);\n        s->lockCount++;\n        pthread_mutex_unlock(&s->mutex);\n        return 0;\n    }\n    int wm_SemUnlock(wm_Sem *s){\n        pthread_mutex_lock(&s->mutex);\n        s->lockCount--;\n        pthread_cond_signal(&s->cond);\n        pthread_mutex_unlock(&s->mutex);\n        return 0;\n    }\n#elif defined(FREERTOS)\n    /* FreeRTOS binary semaphore */\n    int wm_SemInit(wm_Sem *s) {\n        *s = xSemaphoreCreateBinary();\n        xSemaphoreGive(*s);\n        return 0;\n    }\n    int wm_SemFree(wm_Sem *s) {\n        vSemaphoreDelete(*s);\n        *s = NULL;\n        return 0;\n    }\n    int wm_SemLock(wm_Sem *s) {\n        xSemaphoreTake(*s, portMAX_DELAY);\n        return 0;\n    }\n    int wm_SemUnlock(wm_Sem *s) {\n        xSemaphoreGive(*s);\n        return 0;\n    }\n#elif defined(USE_WINDOWS_API)\n    /* Windows semaphore object */\n    int wm_SemInit(wm_Sem *s) {\n        *s = CreateSemaphore( NULL, 0, 1, NULL);\n        return 0;\n    }\n    int wm_SemFree(wm_Sem *s) {\n        CloseHandle(*s);\n        *s = NULL;\n        return 0;\n    }\n    int wm_SemLock(wm_Sem *s) {\n        WaitForSingleObject(*s, 0);\n        return 0;\n    }\n    int wm_SemUnlock(wm_Sem *s) {\n        ReleaseSemaphore(*s, 1, NULL);\n        return 0;\n    }\n\n#endif\n\n/* These RespList functions assume caller has locked client->lockClient mutex */\nstatic int MqttClient_RespList_Add(MqttClient *client,\n    MqttPacketType packet_type, word16 packet_id, MqttPendResp *newResp,\n    void *packet_obj)\n{\n    MqttPendResp *tmpResp;\n\n    if (client == NULL)\n        return MQTT_CODE_ERROR_BAD_ARG;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"PendResp Add: %p, Type %s (%d), ID %d\",\n        newResp, MqttPacket_TypeDesc(packet_type), packet_type, packet_id);\n#endif\n\n    /* verify newResp is not already in the list */\n    for (tmpResp = client->firstPendResp;\n         tmpResp != NULL;\n         tmpResp = tmpResp->next)\n    {\n        if (tmpResp == newResp) {\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"Pending Response already in list!\");\n        #endif\n            return MQTT_CODE_ERROR_BAD_ARG;\n        }\n    }\n\n    /* Initialize new response */\n    XMEMSET(newResp, 0, sizeof(MqttPendResp));\n    newResp->packet_id = packet_id;\n    newResp->packet_type = packet_type;\n    /* opaque pointer to struct based on type */\n    newResp->packet_obj = packet_obj;\n\n    if (client->lastPendResp == NULL) {\n        /* This is the only list item */\n        client->firstPendResp = newResp;\n        client->lastPendResp = newResp;\n    }\n    else {\n        /* Append to end of list */\n        newResp->prev = client->lastPendResp;\n        client->lastPendResp->next = newResp;\n        client->lastPendResp = newResp;\n    }\n    return 0;\n}\n\nstatic void MqttClient_RespList_Remove(MqttClient *client, MqttPendResp *rmResp)\n{\n    MqttPendResp *tmpResp;\n\n    if (client == NULL)\n        return;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"PendResp Remove: %p\", rmResp);\n#endif\n\n    /* Find the response entry */\n    for (tmpResp = client->firstPendResp;\n         tmpResp != NULL;\n         tmpResp = tmpResp->next)\n    {\n        if (tmpResp == rmResp) {\n            break;\n        }\n    }\n    if (tmpResp) {\n        /* Fix up the first and last pointers */\n        if (client->firstPendResp == tmpResp) {\n            client->firstPendResp = tmpResp->next;\n        }\n        if (client->lastPendResp == tmpResp) {\n            client->lastPendResp = tmpResp->prev;\n        }\n\n        /* Remove the entry from the list */\n        if (tmpResp->next != NULL) {\n            tmpResp->next->prev = tmpResp->prev;\n        }\n        if (tmpResp->prev != NULL) {\n            tmpResp->prev->next = tmpResp->next;\n        }\n    }\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    else {\n        PRINTF(\"\\tPendResp Remove Failed\");\n    }\n#endif\n}\n\nstatic int MqttClient_RespList_Find(MqttClient *client,\n    MqttPacketType packet_type, word16 packet_id, MqttPendResp **retResp)\n{\n    int rc = 0;\n    MqttPendResp *tmpResp;\n\n    if (client == NULL)\n        return MQTT_CODE_ERROR_BAD_ARG;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"PendResp Find: Type %s (%d), ID %d\",\n        MqttPacket_TypeDesc(packet_type), packet_type, packet_id);\n#endif\n\n    if (retResp)\n        *retResp = NULL; /* clear */\n\n    /* Find pending response entry */\n    for (tmpResp = client->firstPendResp;\n         tmpResp != NULL;\n         tmpResp = tmpResp->next)\n    {\n        if (packet_type == tmpResp->packet_type &&\n           (packet_id == tmpResp->packet_id))\n        {\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"PendResp Found: %p, Type %s (%d), ID %d\",\n                tmpResp, MqttPacket_TypeDesc(tmpResp->packet_type),\n                tmpResp->packet_type, tmpResp->packet_id);\n        #endif\n\n            if (retResp)\n                *retResp = tmpResp;\n            rc = 1;\n            break;\n        }\n    }\n    return rc;\n}\n#endif /* WOLFMQTT_MULTITHREAD */\n\n/* Returns length decoded or error (as negative) */\n/*! \\brief      Take a received MQTT packet and try and decode it\n *  \\param      client       MQTT client context\n *  \\param      rx_buf       Incoming buffer data\n *  \\param      rx_len       Incoming buffer length\n *  \\param      p_decode     Opaque pointer to packet structure based on type\n *  \\param      ppacket_type Decoded packet type\n *  \\param      ppacket_qos  Decoded QoS level\n *  \\param      ppacket_id   Decoded packet id\n\n *  \\return     Returns length decoded or error (as negative) MQTT_CODE_ERROR_*\n                (see enum MqttPacketResponseCodes)\n */\nstatic int MqttClient_DecodePacket(MqttClient* client, byte* rx_buf,\n    word32 rx_len, void *packet_obj, MqttPacketType* ppacket_type,\n    MqttQoS* ppacket_qos, word16* ppacket_id)\n{\n    int rc = MQTT_CODE_SUCCESS;\n    MqttPacket* header;\n    MqttPacketType packet_type;\n    MqttQoS packet_qos;\n    word16 packet_id = 0;\n#ifdef WOLFMQTT_V5\n    MqttProp* props = NULL;\n#endif\n\n    /* must have rx buffer with at least 2 byes for header */\n    if (rx_buf == NULL || rx_len < MQTT_PACKET_HEADER_MIN_SIZE) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* Decode header */\n    header = (MqttPacket*)rx_buf;\n    packet_type = (MqttPacketType)MQTT_PACKET_TYPE_GET(header->type_flags);\n    if (ppacket_type) {\n        *ppacket_type = packet_type;\n    }\n    packet_qos = (MqttQoS)MQTT_PACKET_FLAGS_GET_QOS(header->type_flags);\n    if (ppacket_qos) {\n        *ppacket_qos = packet_qos;\n    }\n\n    /* Decode packet specific data (if requested) */\n    if (ppacket_id || packet_obj) {\n        switch (packet_type) {\n        case MQTT_PACKET_TYPE_CONNECT_ACK:\n        {\n            MqttConnectAck connect_ack, *p_connect_ack = &connect_ack;\n            if (packet_obj) {\n                p_connect_ack = (MqttConnectAck*)packet_obj;\n            }\n            else {\n                XMEMSET(p_connect_ack, 0, sizeof(MqttConnectAck));\n            }\n        #ifdef WOLFMQTT_V5\n            p_connect_ack->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_ConnectAck(rx_buf, rx_len, p_connect_ack);\n        #ifdef WOLFMQTT_V5\n            if (rc >= 0) {\n                props = p_connect_ack->props;\n            }\n        #endif\n            break;\n        }\n        case MQTT_PACKET_TYPE_PUBLISH:\n        {\n            MqttPublish publish, *p_publish = &publish;\n            if (packet_obj) {\n                p_publish = (MqttPublish*)packet_obj;\n            }\n            else {\n                XMEMSET(p_publish, 0, sizeof(MqttPublish));\n            }\n        #ifdef WOLFMQTT_V5\n            p_publish->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_Publish(rx_buf, rx_len, p_publish);\n            if (rc >= 0) {\n                packet_id = p_publish->packet_id;\n            #ifdef WOLFMQTT_V5\n                props = p_publish->props;\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_PUBLISH_ACK:\n        case MQTT_PACKET_TYPE_PUBLISH_REC:\n        case MQTT_PACKET_TYPE_PUBLISH_REL:\n        case MQTT_PACKET_TYPE_PUBLISH_COMP:\n        {\n            MqttPublishResp publish_resp, *p_publish_resp = &publish_resp;\n            if (packet_obj) {\n                p_publish_resp = (MqttPublishResp*)packet_obj;\n            }\n            else {\n                XMEMSET(p_publish_resp, 0, sizeof(MqttPublishResp));\n            }\n        #ifdef WOLFMQTT_V5\n                p_publish_resp->protocol_level = client->protocol_level;\n        #endif\n                rc = MqttDecode_PublishResp(rx_buf, rx_len, packet_type,\n                p_publish_resp);\n            if (rc >= 0) {\n                packet_id = p_publish_resp->packet_id;\n            #ifdef WOLFMQTT_V5\n                props = p_publish_resp->props;\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_SUBSCRIBE_ACK:\n        {\n            MqttSubscribeAck subscribe_ack, *p_subscribe_ack = &subscribe_ack;\n            if (packet_obj) {\n                p_subscribe_ack = (MqttSubscribeAck*)packet_obj;\n            }\n            else {\n                XMEMSET(p_subscribe_ack, 0, sizeof(MqttSubscribeAck));\n            }\n        #ifdef WOLFMQTT_V5\n            p_subscribe_ack->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_SubscribeAck(rx_buf, rx_len, p_subscribe_ack);\n            if (rc >= 0) {\n                packet_id = p_subscribe_ack->packet_id;\n            #ifdef WOLFMQTT_V5\n                props = p_subscribe_ack->props;\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_UNSUBSCRIBE_ACK:\n        {\n            MqttUnsubscribeAck unsubscribe_ack,\n                               *p_unsubscribe_ack = &unsubscribe_ack;\n            if (packet_obj) {\n                p_unsubscribe_ack = (MqttUnsubscribeAck*)packet_obj;\n            }\n            else {\n                XMEMSET(p_unsubscribe_ack, 0, sizeof(MqttUnsubscribeAck));\n            }\n        #ifdef WOLFMQTT_V5\n            p_unsubscribe_ack->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_UnsubscribeAck(rx_buf, rx_len, p_unsubscribe_ack);\n            if (rc >= 0) {\n                packet_id = p_unsubscribe_ack->packet_id;\n            #ifdef WOLFMQTT_V5\n                props = p_unsubscribe_ack->props;\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_PING_RESP:\n        {\n            MqttPing ping, *p_ping = &ping;\n            if (packet_obj) {\n                p_ping = (MqttPing*)packet_obj;\n            }\n            else {\n                XMEMSET(p_ping, 0, sizeof(MqttPing));\n            }\n            rc = MqttDecode_Ping(rx_buf, rx_len, p_ping);\n            break;\n        }\n        case MQTT_PACKET_TYPE_AUTH:\n        {\n        #ifdef WOLFMQTT_V5\n            MqttAuth auth, *p_auth = &auth;\n            if (packet_obj) {\n                p_auth = (MqttAuth*)packet_obj;\n            }\n            else {\n                XMEMSET(p_auth, 0, sizeof(MqttAuth));\n            }\n            rc = MqttDecode_Auth(rx_buf, rx_len, p_auth);\n            if (rc >= 0) {\n                props = p_auth->props;\n            }\n        #else\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n        #endif /* WOLFMQTT_V5 */\n            break;\n        }\n        case MQTT_PACKET_TYPE_DISCONNECT:\n        {\n        #ifdef WOLFMQTT_V5\n            MqttDisconnect disc, *p_disc = &disc;\n            if (packet_obj) {\n                p_disc = (MqttDisconnect*)packet_obj;\n            }\n            else {\n                XMEMSET(p_disc, 0, sizeof(MqttDisconnect));\n            }\n            rc = MqttDecode_Disconnect(rx_buf, rx_len, p_disc);\n            if (rc >= 0) {\n                props = p_disc->props;\n            }\n        #else\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n        #endif /* WOLFMQTT_V5 */\n            break;\n        }\n        case MQTT_PACKET_TYPE_CONNECT:\n        case MQTT_PACKET_TYPE_SUBSCRIBE:\n        case MQTT_PACKET_TYPE_UNSUBSCRIBE:\n        case MQTT_PACKET_TYPE_PING_REQ:\n        case MQTT_PACKET_TYPE_ANY:\n        case MQTT_PACKET_TYPE_RESERVED:\n        default:\n            /* these type are only encoded by client */\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n            break;\n        } /* switch (packet_type) */\n    }\n\n    if (ppacket_id) {\n        *ppacket_id = packet_id;\n    }\n\n#ifdef WOLFMQTT_V5\n    if (props) {\n    #ifdef WOLFMQTT_PROPERTY_CB\n        /* Check for properties set by the server */\n        if (packet_obj && client->property_cb) {\n            /* capture error if returned */\n            int rc_err = client->property_cb(client, props,\n                    client->property_ctx);\n            if (rc_err < 0) {\n                rc = rc_err;\n            }\n        }\n    #endif\n        /* Free the properties */\n        MqttProps_Free(props);\n    }\n#endif\n\n    (void)client;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_DecodePacket: Rc %d, Len %d, Type %s (%d), ID %d,\"\n            \" QoS %d\",\n        rc, rx_len, MqttPacket_TypeDesc(packet_type), packet_type, packet_id,\n        packet_qos);\n#endif\n\n    return rc;\n}\n\nstatic int MqttClient_HandlePacket(MqttClient* client,\n    MqttPacketType packet_type, void *packet_obj, int timeout_ms)\n{\n    int rc = MQTT_CODE_SUCCESS;\n    MqttQoS packet_qos = MQTT_QOS_0;\n    word16 packet_id = 0;\n\n    if (client == NULL || packet_obj == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    switch (packet_type)\n    {\n        case MQTT_PACKET_TYPE_CONNECT_ACK:\n        {\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, packet_obj, &packet_type, &packet_qos,\n                &packet_id);\n            break;\n        }\n        case MQTT_PACKET_TYPE_PUBLISH:\n        {\n            MqttPublish *publish = (MqttPublish*)packet_obj;\n            MqttPacketType resp_type;\n\n            if (publish->stat == MQTT_MSG_BEGIN ||\n                publish->stat == MQTT_MSG_READ) {\n                rc = MqttClient_DecodePacket(client, client->rx_buf,\n                    client->packet.buf_len, packet_obj, &packet_type,\n                    &packet_qos, &packet_id);\n                if (rc <= 0) {\n                    return rc;\n                }\n            }\n            else {\n                /* packet ID and QoS were already established */\n                packet_id = client->msg.publish.packet_id;\n                packet_qos = client->msg.publish.qos;\n            }\n\n            rc = MqttClient_Publish_ReadPayload(client, publish, timeout_ms);\n            if (rc < 0) {\n                break;\n            }\n\n            /* Handle QoS */\n            if (packet_qos == MQTT_QOS_0) {\n                /* we are done, no QoS response */\n                break;\n            }\n\n            /* Determine packet type to write */\n            resp_type = (packet_qos == MQTT_QOS_1) ?\n                MQTT_PACKET_TYPE_PUBLISH_ACK :\n                MQTT_PACKET_TYPE_PUBLISH_REC;\n            publish->resp.packet_id = packet_id;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock send socket mutex */\n            rc = wm_SemLock(&client->lockSend);\n            if (rc != 0) {\n                return rc;\n            }\n        #endif\n\n            /* Encode publish response */\n            rc = MqttEncode_PublishResp(client->tx_buf, client->tx_buf_len,\n                resp_type, &publish->resp);\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d), ID %d,\"\n                    \" QoS %d\",\n                rc, MqttPacket_TypeDesc(resp_type), resp_type, packet_id,\n                packet_qos);\n        #endif\n            if (rc <= 0) {\n            #ifdef WOLFMQTT_MULTITHREAD\n                wm_SemUnlock(&client->lockSend);\n            #endif\n                return rc;\n            }\n            client->packet.buf_len = rc;\n\n            /* Send publish response packet */\n            rc = MqttPacket_Write(client, client->tx_buf,\n                client->packet.buf_len);\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            wm_SemUnlock(&client->lockSend);\n        #endif\n            break;\n        }\n        case MQTT_PACKET_TYPE_PUBLISH_ACK:\n        case MQTT_PACKET_TYPE_PUBLISH_REC:\n        case MQTT_PACKET_TYPE_PUBLISH_REL:\n        case MQTT_PACKET_TYPE_PUBLISH_COMP:\n        {\n            MqttPublishResp pubRespObj, *publish_resp = &pubRespObj;\n            XMEMSET(publish_resp, 0, sizeof(MqttPublishResp));\n\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, publish_resp, &packet_type,\n                &packet_qos, &packet_id);\n            if (rc <= 0) {\n                return rc;\n            }\n\n            /* If publish Received or Release QoS then proceed */\n            if (packet_type != MQTT_PACKET_TYPE_PUBLISH_REC &&\n                packet_type != MQTT_PACKET_TYPE_PUBLISH_REL) {\n                break;\n            }\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock send socket mutex */\n            rc = wm_SemLock(&client->lockSend);\n            if (rc != 0) {\n                return rc;\n            }\n        #endif\n\n            /* Encode publish response */\n            publish_resp->packet_id = packet_id;\n            packet_type = (MqttPacketType)((int)packet_type+1); /* next ack */\n        #ifdef WOLFMQTT_V5\n            #ifdef WOLFMQTT_DEBUG_CLIENT\n                PRINTF(\"\\tPublish response: reason code %d, Type %s (%d),\"\n                        \" ID %d, QoS %d\",\n                        publish_resp->reason_code,\n                        MqttPacket_TypeDesc(packet_type),\n                        packet_type, packet_id, packet_qos);\n            #endif\n\n            /* return reason code to caller */\n            if (packet_obj != NULL) {\n                MqttPublishResp* caller_rsp = (MqttPublishResp*)packet_obj;\n                caller_rsp->reason_code = publish_resp->reason_code;\n            }\n\n            /* Publish QoS response needs success reason code,\n             * otherwise will cause disconnect at broker */\n            publish_resp->reason_code = MQTT_REASON_SUCCESS;\n        #endif\n\n            rc = MqttEncode_PublishResp(client->tx_buf, client->tx_buf_len,\n                packet_type, publish_resp);\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d), ID %d,\"\n                    \" QoS %d\",\n                rc, MqttPacket_TypeDesc(packet_type), packet_type, packet_id,\n                packet_qos);\n        #endif\n            if (rc <= 0) {\n            #ifdef WOLFMQTT_MULTITHREAD\n                wm_SemUnlock(&client->lockSend);\n            #endif\n                return rc;\n            }\n            client->packet.buf_len = rc;\n\n            /* Send publish response packet */\n            rc = MqttPacket_Write(client, client->tx_buf,\n                client->packet.buf_len);\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            wm_SemUnlock(&client->lockSend);\n        #endif\n            break;\n        }\n        case MQTT_PACKET_TYPE_SUBSCRIBE_ACK:\n        {\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, packet_obj, &packet_type, &packet_qos,\n                &packet_id);\n            break;\n        }\n        case MQTT_PACKET_TYPE_UNSUBSCRIBE_ACK:\n        {\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, packet_obj, &packet_type, &packet_qos,\n                &packet_id);\n            break;\n        }\n        case MQTT_PACKET_TYPE_PING_RESP:\n        {\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, packet_obj, &packet_type, &packet_qos,\n                &packet_id);\n            break;\n        }\n        case MQTT_PACKET_TYPE_AUTH:\n        {\n        #ifdef WOLFMQTT_V5\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, packet_obj, &packet_type, &packet_qos,\n                &packet_id);\n        #else\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n        #endif\n            break;\n        }\n\n        case MQTT_PACKET_TYPE_DISCONNECT:\n        {\n        #ifdef WOLFMQTT_V5\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, packet_obj, &packet_type, &packet_qos,\n                &packet_id);\n        #else\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n        #endif\n            break;\n        }\n        case MQTT_PACKET_TYPE_CONNECT:\n        case MQTT_PACKET_TYPE_SUBSCRIBE:\n        case MQTT_PACKET_TYPE_UNSUBSCRIBE:\n        case MQTT_PACKET_TYPE_PING_REQ:\n        case MQTT_PACKET_TYPE_ANY:\n        case MQTT_PACKET_TYPE_RESERVED:\n        default:\n            /* these types are only sent from client and should not be sent\n             * by broker */\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n            break;\n    } /* switch (packet_type) */\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    if (rc < 0) {\n        PRINTF(\"MqttClient_HandlePacket: Rc %d, Type %s (%d), QoS %d, ID %d\",\n            rc, MqttPacket_TypeDesc(packet_type), packet_type, packet_qos,\n            packet_id);\n    }\n#endif\n\n    return rc;\n}\n\nstatic inline int MqttIsPubRespPacket(int packet_type)\n{\n    return (packet_type == MQTT_PACKET_TYPE_PUBLISH_ACK /* Acknowledgment */ ||\n            packet_type == MQTT_PACKET_TYPE_PUBLISH_REC /* Received */ ||\n            packet_type == MQTT_PACKET_TYPE_PUBLISH_REL /* Release */ ||\n            packet_type == MQTT_PACKET_TYPE_PUBLISH_COMP /* Complete */);\n}\n\nstatic int MqttClient_WaitType(MqttClient *client, void *packet_obj,\n    byte wait_type, word16 wait_packet_id, int timeout_ms)\n{\n    int rc;\n    word16 packet_id;\n    MqttPacketType packet_type;\n#ifdef WOLFMQTT_MULTITHREAD\n    MqttPendResp *pendResp;\n    int readLocked;\n#endif\n    MqttMsgStat* mms_stat;\n    int waitMatchFound;\n\n    if (client == NULL || packet_obj == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* all packet type structures must have MqttMsgStat at top */\n    mms_stat = (MqttMsgStat*)packet_obj;\n\nwait_again:\n\n    /* initialize variables */\n    packet_id = 0;\n    packet_type = MQTT_PACKET_TYPE_RESERVED;\n#ifdef WOLFMQTT_MULTITHREAD\n    pendResp = NULL;\n    readLocked = 0;\n#endif\n    waitMatchFound = 0;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_WaitType: Type %s (%d), ID %d\",\n        MqttPacket_TypeDesc((MqttPacketType)wait_type),\n            wait_type, wait_packet_id);\n#endif\n\n    switch ((int)*mms_stat)\n    {\n        case MQTT_MSG_BEGIN:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock recv socket mutex */\n            rc = wm_SemLock(&client->lockRecv);\n            if (rc != 0) {\n                PRINTF(\"MqttClient_WaitType: recv lock error!\");\n                return rc;\n            }\n            readLocked = 1;\n        #endif\n\n            /* reset the packet state */\n            client->packet.stat = MQTT_PK_BEGIN;\n        }\n        FALL_THROUGH;\n\n    #ifdef WOLFMQTT_V5\n        case MQTT_MSG_AUTH:\n    #endif\n        case MQTT_MSG_WAIT:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if packet type and id have already completed */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, (MqttPacketType)wait_type, \n                    wait_packet_id, &pendResp)) {\n                    if (pendResp->packetDone) {\n                        /* pending response is already done, so return */\n                        rc = pendResp->packet_ret;\n                    #ifdef WOLFMQTT_DEBUG_CLIENT\n                        PRINTF(\"PendResp already Done %p: Rc %d\", pendResp, rc);\n                    #endif\n                        MqttClient_RespList_Remove(client, pendResp);\n                        wm_SemUnlock(&client->lockClient);\n                        wm_SemUnlock(&client->lockRecv);\n                        return rc;\n                    }\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            *mms_stat = MQTT_MSG_WAIT;\n\n            /* Wait for packet */\n            rc = MqttPacket_Read(client, client->rx_buf, client->rx_buf_len,\n                    timeout_ms);\n            /* handle failure */\n            if (rc <= 0) {\n                break;\n            }\n\n            /* capture length read */\n            client->packet.buf_len = rc;\n\n            /* Decode Packet - get type and id */\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, NULL, &packet_type, NULL, &packet_id);\n            if (rc < 0) {\n                break;\n            }\n\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"Read Packet: Len %d, Type %d, ID %d\",\n                client->packet.buf_len, packet_type, packet_id);\n        #endif\n\n            *mms_stat = MQTT_MSG_READ;\n        }\n        FALL_THROUGH;\n\n        case MQTT_MSG_READ:\n        case MQTT_MSG_READ_PAYLOAD:\n        {\n            MqttPacketType use_packet_type;\n            void* use_packet_obj;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            readLocked = 1; /* if in this state read is locked */\n        #endif\n\n            /* read payload state only happens for publish messages */\n            if (*mms_stat == MQTT_MSG_READ_PAYLOAD) {\n                packet_type = MQTT_PACKET_TYPE_PUBLISH;\n            }\n\n            /* Determine if we received data for this request */\n            if ((wait_type == MQTT_PACKET_TYPE_ANY ||\n                 wait_type == packet_type ||\n                 (MqttIsPubRespPacket(packet_type) &&\n                  MqttIsPubRespPacket(wait_type))) &&\n                (wait_packet_id == 0 || wait_packet_id == packet_id))\n            {\n                use_packet_obj = packet_obj;\n                waitMatchFound = 1;\n            }\n            else {\n                /* use generic packet object */\n                use_packet_obj = &client->msg;\n            }\n            use_packet_type = packet_type;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if we have a pending response for this packet */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, packet_type, packet_id,\n                                                               &pendResp)) {\n                    /* we found packet match this incoming read packet */\n                    pendResp->packetProcessing = 1;\n                    use_packet_obj = pendResp->packet_obj;\n                    use_packet_type = pendResp->packet_type;\n                    /* req from another thread... not a match */\n                    waitMatchFound = 0;\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            /* Perform packet handling for publish callback and QoS */\n            rc = MqttClient_HandlePacket(client, use_packet_type,\n                use_packet_obj, timeout_ms);\n\n        #ifdef WOLFMQTT_NONBLOCK\n            if (rc == MQTT_CODE_CONTINUE) {\n                /* we have received some data, so keep the recv\n                    mutex lock active and return */\n                return rc;\n            }\n        #endif\n\n            /* handle success case */\n            if (rc >= 0) {\n                rc = MQTT_CODE_SUCCESS;\n            }\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (pendResp) {\n                /* Mark pending response entry done */\n                if (wm_SemLock(&client->lockClient) == 0) {\n                    pendResp->packetDone = 1;\n                    pendResp->packet_ret = rc;\n                #ifdef WOLFMQTT_DEBUG_CLIENT\n                    PRINTF(\"PendResp Done %p\", pendResp);\n                #endif\n                    pendResp = NULL;\n                    wm_SemUnlock(&client->lockClient);\n                }\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n            break;\n        }\n\n        case MQTT_MSG_WRITE:\n        case MQTT_MSG_WRITE_PAYLOAD:\n        default:\n        {\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_WaitType: Invalid state %d!\", *mms_stat);\n        #endif\n            rc = MQTT_CODE_ERROR_STAT;\n            break;\n        }\n    } /* switch (*mms_stat) */\n\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc != MQTT_CODE_CONTINUE)\n#endif\n    {\n        /* reset state */\n        *mms_stat = MQTT_MSG_BEGIN;\n    }\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (readLocked) {\n        wm_SemUnlock(&client->lockRecv);\n    }\n#endif\n    if (rc < 0) {\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_WaitType: Failure: %s (%d)\",\n            MqttClient_ReturnCodeToString(rc), rc);\n    #endif\n        return rc;\n    }\n\n    if (!waitMatchFound) {\n        /* if we get here, then the we are still waiting for a packet */\n        goto wait_again;\n    }\n\n    return rc;\n}\n\n\n/* Public Functions */\nint MqttClient_Init(MqttClient *client, MqttNet* net,\n    MqttMsgCb msg_cb,\n    byte* tx_buf, int tx_buf_len,\n    byte* rx_buf, int rx_buf_len,\n    int cmd_timeout_ms)\n{\n    int rc = MQTT_CODE_SUCCESS;\n\n    /* Check arguments */\n    if (client == NULL ||\n        tx_buf == NULL || tx_buf_len <= 0 ||\n        rx_buf == NULL || rx_buf_len <= 0) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* Initialize the client structure to zero */\n    XMEMSET(client, 0, sizeof(MqttClient));\n\n    /* Setup client structure */\n    client->msg_cb = msg_cb;\n    client->tx_buf = tx_buf;\n    client->tx_buf_len = tx_buf_len;\n    client->rx_buf = rx_buf;\n    client->rx_buf_len = rx_buf_len;\n    client->cmd_timeout_ms = cmd_timeout_ms;\n#ifdef WOLFMQTT_V5\n    client->max_qos = MQTT_QOS_2;\n    client->retain_avail = 1;\n    client->protocol_level = MQTT_CONNECT_PROTOCOL_LEVEL;\n    rc = MqttProps_Init();\n#endif\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (rc == 0) {\n        rc = wm_SemInit(&client->lockSend);\n    }\n    if (rc == 0) {\n        rc = wm_SemInit(&client->lockRecv);\n    }\n    if (rc == 0) {\n        rc = wm_SemInit(&client->lockClient);\n    }\n#endif\n\n    if (rc == 0) {\n        /* Init socket */\n        rc = MqttSocket_Init(client, net);\n    }\n\n    if (rc != 0) {\n        /* Cleanup if init failed */\n        MqttClient_DeInit(client);\n    }\n\n    return rc;\n}\n\nvoid MqttClient_DeInit(MqttClient *client)\n{\n    if (client != NULL) {\n#ifdef WOLFMQTT_MULTITHREAD\n        (void)wm_SemFree(&client->lockSend);\n        (void)wm_SemFree(&client->lockRecv);\n        (void)wm_SemFree(&client->lockClient);\n#endif\n    }\n#ifdef WOLFMQTT_V5\n    (void)MqttProps_ShutDown();\n#endif\n}\n\n#ifdef WOLFMQTT_DISCONNECT_CB\nint MqttClient_SetDisconnectCallback(MqttClient *client,\n        MqttDisconnectCb discCb, void* ctx)\n{\n    if (client == NULL)\n        return MQTT_CODE_ERROR_BAD_ARG;\n\n    client->disconnect_cb = discCb;\n    client->disconnect_ctx = ctx;\n\n    return MQTT_CODE_SUCCESS;\n}\n#endif\n\n#ifdef WOLFMQTT_PROPERTY_CB\nint MqttClient_SetPropertyCallback(MqttClient *client, MqttPropertyCb propCb,\n    void* ctx)\n{\n    if (client == NULL)\n        return MQTT_CODE_ERROR_BAD_ARG;\n\n    client->property_cb = propCb;\n    client->property_ctx = ctx;\n\n    return MQTT_CODE_SUCCESS;\n}\n#endif\n\nint MqttClient_Connect(MqttClient *client, MqttConnect *mc_connect)\n{\n    int rc, len = 0;\n\n    /* Validate required arguments */\n    if (client == NULL || mc_connect == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    if (mc_connect->stat == MQTT_MSG_BEGIN) {\n    #ifdef WOLFMQTT_MULTITHREAD\n        /* Lock send socket mutex */\n        rc = wm_SemLock(&client->lockSend);\n        if (rc != 0) {\n            return rc;\n        }\n    #endif\n\n    #ifdef WOLFMQTT_V5\n        /* Use specified protocol version if set */\n        mc_connect->protocol_level = client->protocol_level;\n    #endif\n\n        /* Encode the connect packet */\n        rc = MqttEncode_Connect(client->tx_buf, client->tx_buf_len, mc_connect);\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d), ID %d, QoS %d\",\n            rc, MqttPacket_TypeDesc(MQTT_PACKET_TYPE_CONNECT),\n            MQTT_PACKET_TYPE_CONNECT, 0, 0);\n    #endif\n        if (rc <= 0) {\n            #ifdef WOLFMQTT_MULTITHREAD\n                wm_SemUnlock(&client->lockSend);\n            #endif\n            return rc;\n        }\n        len = rc;\n\n    #ifdef WOLFMQTT_MULTITHREAD\n        rc = wm_SemLock(&client->lockClient);\n        if (rc == 0) {\n            /* inform other threads of expected response */\n            rc = MqttClient_RespList_Add(client, MQTT_PACKET_TYPE_CONNECT_ACK,\n                    0, &mc_connect->pendResp, &mc_connect->ack);\n            wm_SemUnlock(&client->lockClient);\n        }\n        if (rc != 0) {\n            wm_SemUnlock(&client->lockSend);\n            return rc; /* Error locking client */\n        }\n    #endif\n\n        /* Send connect packet */\n        rc = MqttPacket_Write(client, client->tx_buf, len);\n    #ifdef WOLFMQTT_MULTITHREAD\n        wm_SemUnlock(&client->lockSend);\n    #endif\n        if (rc != len) {\n    #ifdef WOLFMQTT_MULTITHREAD\n            if ((rc != MQTT_CODE_CONTINUE) &&\n                (wm_SemLock(&client->lockClient)) == 0) {\n                MqttClient_RespList_Remove(client, &mc_connect->pendResp);\n                wm_SemUnlock(&client->lockClient);\n            }\n    #endif\n            return rc;\n        }\n    #ifdef WOLFMQTT_V5\n        /* Enhanced authentication */\n        if (client->enable_eauth == 1) {\n            mc_connect->stat = MQTT_MSG_AUTH;\n        }\n        else\n    #endif\n        {\n            mc_connect->stat = MQTT_MSG_WAIT;\n        }\n    }\n\n#ifdef WOLFMQTT_V5\n    /* Enhanced authentication */\n    if (mc_connect->protocol_level > MQTT_CONNECT_PROTOCOL_LEVEL_4 && \n            mc_connect->stat == MQTT_MSG_AUTH)\n    {\n        MqttAuth auth, *p_auth = &auth;\n        MqttProp* prop, *conn_prop;\n\n        /* Find the AUTH property in the connect structure */\n        for (conn_prop = mc_connect->props;\n             (conn_prop != NULL) && (conn_prop->type != MQTT_PROP_AUTH_METHOD);\n             conn_prop = conn_prop->next) {\n        }\n        if (conn_prop == NULL) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (wm_SemLock(&client->lockClient) == 0) {\n                MqttClient_RespList_Remove(client, &mc_connect->pendResp);\n                wm_SemUnlock(&client->lockClient);\n            }\n        #endif\n            /* AUTH property was not set in connect structure */\n            return MQTT_CODE_ERROR_BAD_ARG;\n        }\n\n        XMEMSET((void*)p_auth, 0, sizeof(MqttAuth));\n\n        /* Set the authentication reason */\n        p_auth->reason_code = MQTT_REASON_CONT_AUTH;\n\n        /* Use the same authentication method property from connect */\n        prop = MqttProps_Add(&p_auth->props);\n        prop->type = MQTT_PROP_AUTH_METHOD;\n        prop->data_str.str = conn_prop->data_str.str;\n        prop->data_str.len = conn_prop->data_str.len;\n\n        /* Send the AUTH packet */\n        rc = MqttClient_Auth(client, p_auth);\n        MqttClient_PropsFree(p_auth->props);\n    #ifdef WOLFMQTT_NONBLOCK\n        if (rc == MQTT_CODE_CONTINUE)\n            return rc;\n    #endif\n        if (rc != len) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (wm_SemLock(&client->lockClient) == 0) {\n                MqttClient_RespList_Remove(client, &mc_connect->pendResp);\n                wm_SemUnlock(&client->lockClient);\n            }\n        #endif\n            return rc;\n        }\n    }\n#endif /* WOLFMQTT_V5 */\n\n    /* Wait for connect ack packet */\n    rc = MqttClient_WaitType(client, &mc_connect->ack,\n        MQTT_PACKET_TYPE_CONNECT_ACK, 0, client->cmd_timeout_ms);\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc == MQTT_CODE_CONTINUE)\n        return rc;\n#endif\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (wm_SemLock(&client->lockClient) == 0) {\n        MqttClient_RespList_Remove(client, &mc_connect->pendResp);\n        wm_SemUnlock(&client->lockClient);\n    }\n#endif\n\n    /* reset state */\n    mc_connect->stat = MQTT_MSG_BEGIN;\n\n    return rc;\n}\n\n#ifdef WOLFMQTT_TEST_NONBLOCK\nstatic int testNbAlt = 0;\n#endif\n\nstatic int MqttClient_Publish_ReadPayload(MqttClient* client,\n    MqttPublish* publish, int timeout_ms)\n{\n    int rc = MQTT_CODE_SUCCESS;\n    byte msg_done;\n\n    /* Handle packet callback and read remaining payload */\n    do {\n        /* Determine if message is done */\n        msg_done = ((publish->buffer_pos + publish->buffer_len) >=\n                    publish->total_len) ? 1 : 0;\n\n        if (publish->buffer_new) {\n            /* Issue callback for new message (first time only) */\n            if (client->msg_cb) {\n                /* if using the temp publish message buffer,\n                   then populate message context with client context */\n                if (publish->ctx == NULL && &client->msg.publish == publish) {\n                    publish->ctx = client->ctx;\n                }\n                rc = client->msg_cb(client, publish, publish->buffer_new,\n                                    msg_done);\n                if (rc != MQTT_CODE_SUCCESS) {\n                    return rc;\n                };\n            }\n\n            /* Reset topic name since valid on new message only */\n            publish->topic_name = NULL;\n            publish->topic_name_len = 0;\n\n            publish->buffer_new = 0;\n        }\n\n        /* Read payload */\n        if (!msg_done) {\n            int msg_len;\n\n            /* add last length to position and reset len */\n            publish->buffer_pos += publish->buffer_len;\n            publish->buffer_len = 0;\n\n            /* set state to reading payload */\n            publish->stat = MQTT_MSG_READ_PAYLOAD;\n\n            msg_len = (publish->total_len - publish->buffer_pos);\n            if (msg_len > client->rx_buf_len) {\n                msg_len = client->rx_buf_len;\n            }\n\n            /* make sure there is something to read */\n            if (msg_len > 0) {\n                #ifdef WOLFMQTT_TEST_NONBLOCK\n                    if (!testNbAlt) {\n                        testNbAlt = 1;\n                        return MQTT_CODE_CONTINUE;\n                    }\n                    testNbAlt = 0;\n                #endif\n\n                rc = MqttSocket_Read(client, client->rx_buf, msg_len,\n                        timeout_ms);\n                if (rc < 0) {\n                    break;\n                }\n\n                /* Update message */\n                publish->buffer = client->rx_buf;\n                publish->buffer_len = rc;\n                rc = MQTT_CODE_SUCCESS; /* mark success */\n\n                msg_done = ((publish->buffer_pos + publish->buffer_len) >=\n                    publish->total_len) ? 1 : 0;\n\n                /* Issue callback for additional publish payload */\n                if (client->msg_cb) {\n                    rc = client->msg_cb(client, publish, publish->buffer_new,\n                                        msg_done);\n                    if (rc != MQTT_CODE_SUCCESS) {\n                        return rc;\n                    };\n                }\n            }\n        }\n    } while (!msg_done);\n\n    return rc;\n}\n\nstatic int MqttClient_Publish_WritePayload(MqttClient *client,\n    MqttPublish *publish, MqttPublishCb pubCb)\n{\n    int rc = MQTT_CODE_SUCCESS;\n\n    if (client == NULL || publish == NULL)\n        return MQTT_CODE_ERROR_BAD_ARG;\n\n    if (pubCb) {\n        word32 tmp_len = publish->buffer_len;\n\n        do {\n            /* Use the callback to get payload */\n            if ((client->write.len = pubCb(publish)) < 0) {\n                return MQTT_CODE_ERROR_CALLBACK;\n            }\n\n            if ((word32)client->write.len < publish->buffer_len) {\n                /* Last read */\n                tmp_len = (word32)client->write.len;\n            }\n\n            /* Send payload */\n            do {\n                if (client->write.len > client->tx_buf_len) {\n                    client->write.len = client->tx_buf_len;\n                }\n                publish->intBuf_len = client->write.len;\n                XMEMCPY(client->tx_buf, &publish->buffer[publish->intBuf_pos],\n                    client->write.len);\n\n                rc = MqttPacket_Write(client, client->tx_buf,\n                        client->write.len);\n                if (rc < 0) {\n                    return rc;\n                }\n\n                publish->intBuf_pos += publish->intBuf_len;\n                publish->intBuf_len = 0;\n\n            } while (publish->intBuf_pos < tmp_len);\n\n            publish->buffer_pos += publish->intBuf_pos;\n            publish->intBuf_pos = 0;\n\n        } while (publish->buffer_pos < publish->total_len);\n    }\n    else if (publish->buffer_pos < publish->total_len) {\n        if (publish->buffer_pos > 0) {\n            client->write.len = (publish->total_len - publish->buffer_pos);\n            if (client->write.len > client->tx_buf_len) {\n                client->write.len = client->tx_buf_len;\n            }\n\n            XMEMCPY(client->tx_buf, &publish->buffer[publish->buffer_pos],\n                client->write.len);\n\n        #ifndef WOLFMQTT_NONBLOCK\n            publish->intBuf_pos += client->write.len;\n        #endif\n        }\n\n        /* Send packet and payload */\n    #ifdef WOLFMQTT_NONBLOCK\n            rc = MqttPacket_Write(client, client->tx_buf,\n                    client->write.len);\n            if (rc < 0) {\n                return rc;\n            }\n\n            /* ONLY if send was successful, update buffer position.\n             * Otherwise, MqttPacket_Write() will resume where it left off. */\n            publish->buffer_pos += client->write.len;\n\n            /* Check if we are done sending publish message */\n            if (publish->buffer_pos < publish->buffer_len) {\n                return MQTT_CODE_PUB_CONTINUE;\n            }\n    #else\n        do {\n            rc = MqttPacket_Write(client, client->tx_buf,\n                    client->write.len);\n            if (rc < 0) {\n                return rc;\n            }\n\n            publish->intBuf_pos += publish->intBuf_len;\n            publish->intBuf_len = 0;\n\n            /* Check if we are done sending publish message */\n            if (publish->intBuf_pos >= publish->buffer_len) {\n                rc = MQTT_CODE_SUCCESS;\n                break;\n            }\n\n            /* Build packet payload to send */\n            client->write.len = (publish->buffer_len - publish->intBuf_pos);\n            if (client->write.len > client->tx_buf_len) {\n                client->write.len = client->tx_buf_len;\n            }\n            publish->intBuf_len = client->write.len;\n            XMEMCPY(client->tx_buf, &publish->buffer[publish->intBuf_pos],\n                client->write.len);\n        } while (publish->intBuf_pos < publish->buffer_len);\n    #endif\n\n        if (rc >= 0) {\n            /* If transferring more chunks */\n            publish->buffer_pos += publish->intBuf_pos;\n            if (publish->buffer_pos < publish->total_len) {\n                /* Build next payload to send */\n                client->write.len = (publish->total_len - publish->buffer_pos);\n                if (client->write.len > client->tx_buf_len) {\n                    client->write.len = client->tx_buf_len;\n                }\n                rc = MQTT_CODE_PUB_CONTINUE;\n            }\n        }\n    }\n    return rc;\n}\n\nint MqttClient_Publish(MqttClient *client, MqttPublish *publish)\n{\n    return MqttClient_Publish_ex(client, publish, NULL);\n}\n\nint MqttClient_Publish_ex(MqttClient *client, MqttPublish *publish,\n                            MqttPublishCb pubCb)\n{\n    int rc = MQTT_CODE_SUCCESS;\n    MqttPacketType resp_type;\n\n    /* Validate required arguments */\n    if (client == NULL || publish == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n#ifdef WOLFMQTT_V5\n    /* Use specified protocol version if set */\n    publish->protocol_level = client->protocol_level;\n\n    /* Validate publish request against server properties */\n    if ((publish->qos > client->max_qos) ||\n        ((publish->retain == 1) && (client->retain_avail == 0)))\n    {\n        return MQTT_CODE_ERROR_SERVER_PROP;\n    }\n#endif\n\n    switch (publish->stat)\n    {\n        case MQTT_MSG_BEGIN:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock send socket mutex */\n            rc = wm_SemLock(&client->lockSend);\n            if (rc != 0) {\n                return rc;\n            }\n        #endif\n\n            /* Encode the publish packet */\n            rc = MqttEncode_Publish(client->tx_buf, client->tx_buf_len,\n                    publish, pubCb ? 1 : 0);\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d), ID %d,\"\n                    \" QoS %d\",\n                rc, MqttPacket_TypeDesc(MQTT_PACKET_TYPE_PUBLISH),\n                MQTT_PACKET_TYPE_PUBLISH, publish->packet_id,\n                publish->qos);\n        #endif\n            if (rc <= 0) {\n            #ifdef WOLFMQTT_MULTITHREAD\n                wm_SemUnlock(&client->lockSend);\n            #endif\n                return rc;\n            }\n            client->write.len = rc;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (publish->qos > MQTT_QOS_0) {\n                resp_type = (publish->qos == MQTT_QOS_1) ?\n                        MQTT_PACKET_TYPE_PUBLISH_ACK :\n                        MQTT_PACKET_TYPE_PUBLISH_COMP;\n\n                rc = wm_SemLock(&client->lockClient);\n                if (rc == 0) {\n                    /* inform other threads of expected response */\n                    rc = MqttClient_RespList_Add(client, resp_type,\n                        publish->packet_id, &publish->pendResp, &publish->resp);\n                    wm_SemUnlock(&client->lockClient);\n                }\n                if (rc != 0) {\n                    wm_SemUnlock(&client->lockSend);\n                    return rc; /* Error locking client */\n                }\n            }\n        #endif\n\n            publish->stat = MQTT_MSG_WRITE;\n        }\n        FALL_THROUGH;\n\n        case MQTT_MSG_WRITE:\n        {\n            /* Send packet */\n            rc = MqttPacket_Write(client, client->tx_buf, client->write.len);\n        #ifdef WOLFMQTT_NONBLOCK\n            if (rc == MQTT_CODE_CONTINUE)\n                return rc;\n        #endif\n            if (rc < 0) {\n            #ifdef WOLFMQTT_MULTITHREAD\n                wm_SemUnlock(&client->lockSend);\n            #endif\n            #ifdef WOLFMQTT_MULTITHREAD\n                if (wm_SemLock(&client->lockClient) == 0) {\n                    MqttClient_RespList_Remove(client, &publish->pendResp);\n                    wm_SemUnlock(&client->lockClient);\n                }\n            #endif\n                return rc;\n            }\n\n            /* advance state */\n            publish->stat = MQTT_MSG_WRITE_PAYLOAD;\n        }\n        FALL_THROUGH;\n\n        case MQTT_MSG_WRITE_PAYLOAD:\n        {\n            rc = MqttClient_Publish_WritePayload(client, publish, pubCb);\n        #ifdef WOLFMQTT_NONBLOCK\n            if (rc == MQTT_CODE_CONTINUE)\n                return rc;\n        #endif\n        #ifdef WOLFMQTT_MULTITHREAD\n            wm_SemUnlock(&client->lockSend);\n        #endif\n\n            if (rc < 0) {\n            #ifdef WOLFMQTT_MULTITHREAD\n                if (wm_SemLock(&client->lockClient) == 0) {\n                    MqttClient_RespList_Remove(client, &publish->pendResp);\n                    wm_SemUnlock(&client->lockClient);\n                }\n            #endif\n                break;\n            }\n\n            /* if not expecting a reply then we are done */\n            if (publish->qos == MQTT_QOS_0) {\n                break;\n            }\n            publish->stat = MQTT_MSG_WAIT;\n        }\n        FALL_THROUGH;\n\n        case MQTT_MSG_WAIT:\n        {\n            /* Handle QoS */\n            if (publish->qos > MQTT_QOS_0) {\n                /* Determine packet type to wait for */\n                resp_type = (publish->qos == MQTT_QOS_1) ?\n                    MQTT_PACKET_TYPE_PUBLISH_ACK :\n                    MQTT_PACKET_TYPE_PUBLISH_COMP;\n\n                /* Wait for publish response packet */\n                rc = MqttClient_WaitType(client, &publish->resp, resp_type,\n                    publish->packet_id, client->cmd_timeout_ms);\n            #ifdef WOLFMQTT_NONBLOCK\n                if (rc == MQTT_CODE_CONTINUE)\n                    break;\n            #endif\n            #ifdef WOLFMQTT_MULTITHREAD\n                if (wm_SemLock(&client->lockClient) == 0) {\n                    MqttClient_RespList_Remove(client, &publish->pendResp);\n                    wm_SemUnlock(&client->lockClient);\n                }\n            #endif\n            }\n            break;\n        }\n\n    #ifdef WOLFMQTT_V5\n        case MQTT_MSG_AUTH:\n    #endif\n        case MQTT_MSG_READ:\n        case MQTT_MSG_READ_PAYLOAD:\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_Publish: Invalid state %d!\",\n                publish->stat);\n        #endif\n            rc = MQTT_CODE_ERROR_STAT;\n            break;\n    } /* switch (publish->stat) */\n\n    /* reset state */\n    if ((rc != MQTT_CODE_PUB_CONTINUE)\n#ifdef WOLFMQTT_NONBLOCK\n         && (rc != MQTT_CODE_CONTINUE)\n#endif\n        )\n    {\n        publish->stat = MQTT_MSG_BEGIN;\n    }\n    if (rc > 0) {\n        rc = MQTT_CODE_SUCCESS;\n    }\n\n    return rc;\n}\n\nint MqttClient_Subscribe(MqttClient *client, MqttSubscribe *subscribe)\n{\n    int rc, len, i;\n    MqttTopic* topic;\n\n    /* Validate required arguments */\n    if (client == NULL || subscribe == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n#ifdef WOLFMQTT_V5\n    /* Use specified protocol version if set */\n    subscribe->protocol_level = client->protocol_level;\n#endif\n\n    if (subscribe->stat == MQTT_MSG_BEGIN) {\n    #ifdef WOLFMQTT_MULTITHREAD\n        /* Lock send socket mutex */\n        rc = wm_SemLock(&client->lockSend);\n        if (rc != 0) {\n            return rc;\n        }\n    #endif\n\n        /* Encode the subscribe packet */\n        rc = MqttEncode_Subscribe(client->tx_buf, client->tx_buf_len,\n                subscribe);\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d), ID %d\",\n            rc, MqttPacket_TypeDesc(MQTT_PACKET_TYPE_SUBSCRIBE),\n            MQTT_PACKET_TYPE_SUBSCRIBE, subscribe->packet_id);\n    #endif\n        if (rc <= 0) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            wm_SemUnlock(&client->lockSend);\n        #endif\n            return rc;\n        }\n        len = rc;\n\n    #ifdef WOLFMQTT_MULTITHREAD\n        rc = wm_SemLock(&client->lockClient);\n        if (rc == 0) {\n            /* inform other threads of expected response */\n            rc = MqttClient_RespList_Add(client, MQTT_PACKET_TYPE_SUBSCRIBE_ACK,\n                subscribe->packet_id, &subscribe->pendResp, &subscribe->ack);\n            wm_SemUnlock(&client->lockClient);\n        }\n        if (rc != 0) {\n            wm_SemUnlock(&client->lockSend);\n            return rc; /* Error locking client */\n        }\n    #endif\n\n        /* Send subscribe packet */\n        rc = MqttPacket_Write(client, client->tx_buf, len);\n    #ifdef WOLFMQTT_MULTITHREAD\n        wm_SemUnlock(&client->lockSend);\n    #endif\n        if (rc != len) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (wm_SemLock(&client->lockClient) == 0) {\n                MqttClient_RespList_Remove(client, &subscribe->pendResp);\n                wm_SemUnlock(&client->lockClient);\n            }\n        #endif\n            return rc;\n        }\n\n        subscribe->stat = MQTT_MSG_WAIT;\n    }\n\n    /* Wait for subscribe ack packet */\n    rc = MqttClient_WaitType(client, &subscribe->ack,\n        MQTT_PACKET_TYPE_SUBSCRIBE_ACK, subscribe->packet_id,\n        client->cmd_timeout_ms);\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc == MQTT_CODE_CONTINUE)\n        return rc;\n#endif\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (wm_SemLock(&client->lockClient) == 0) {\n        MqttClient_RespList_Remove(client, &subscribe->pendResp);\n        wm_SemUnlock(&client->lockClient);\n    }\n#endif\n\n    /* Populate return codes */\n    if (rc == MQTT_CODE_SUCCESS) {\n        for (i = 0; i < subscribe->topic_count && i < MAX_MQTT_TOPICS; i++) {\n            topic = &subscribe->topics[i];\n            topic->return_code = subscribe->ack.return_codes[i];\n        }\n    }\n\n    /* reset state */\n    subscribe->stat = MQTT_MSG_BEGIN;\n\n    return rc;\n}\n\nint MqttClient_Unsubscribe(MqttClient *client, MqttUnsubscribe *unsubscribe)\n{\n    int rc, len;\n\n    /* Validate required arguments */\n    if (client == NULL || unsubscribe == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n#ifdef WOLFMQTT_V5\n    /* Use specified protocol version if set */\n    unsubscribe->protocol_level = client->protocol_level;\n#endif\n\n    if (unsubscribe->stat == MQTT_MSG_BEGIN) {\n    #ifdef WOLFMQTT_MULTITHREAD\n        /* Lock send socket mutex */\n        rc = wm_SemLock(&client->lockSend);\n        if (rc != 0) {\n            return rc;\n        }\n    #endif\n\n        /* Encode the subscribe packet */\n        rc = MqttEncode_Unsubscribe(client->tx_buf, client->tx_buf_len,\n            unsubscribe);\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d), ID %d, QoS %d\",\n            rc, MqttPacket_TypeDesc(MQTT_PACKET_TYPE_UNSUBSCRIBE),\n            MQTT_PACKET_TYPE_UNSUBSCRIBE, unsubscribe->packet_id, 0);\n    #endif\n        if (rc <= 0) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            wm_SemUnlock(&client->lockSend);\n        #endif\n            return rc;\n        }\n        len = rc;\n\n    #ifdef WOLFMQTT_MULTITHREAD\n        rc = wm_SemLock(&client->lockClient);\n        if (rc == 0) {\n            /* inform other threads of expected response */\n            rc = MqttClient_RespList_Add(client,\n                MQTT_PACKET_TYPE_UNSUBSCRIBE_ACK, unsubscribe->packet_id,\n                &unsubscribe->pendResp, &unsubscribe->ack);\n            wm_SemUnlock(&client->lockClient);\n        }\n        if (rc != 0) {\n            wm_SemUnlock(&client->lockSend); /* Error locking client */\n            return rc;\n        }\n    #endif\n\n        /* Send unsubscribe packet */\n        rc = MqttPacket_Write(client, client->tx_buf, len);\n    #ifdef WOLFMQTT_MULTITHREAD\n        wm_SemUnlock(&client->lockSend);\n    #endif\n        if (rc != len) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (wm_SemLock(&client->lockClient) == 0) {\n                MqttClient_RespList_Remove(client, &unsubscribe->pendResp);\n                wm_SemUnlock(&client->lockClient);\n            }\n        #endif\n            return rc;\n        }\n\n        unsubscribe->stat = MQTT_MSG_WAIT;\n    }\n\n    /* Wait for unsubscribe ack packet */\n    rc = MqttClient_WaitType(client, &unsubscribe->ack,\n        MQTT_PACKET_TYPE_UNSUBSCRIBE_ACK, unsubscribe->packet_id,\n        client->cmd_timeout_ms);\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc == MQTT_CODE_CONTINUE)\n        return rc;\n#endif\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (wm_SemLock(&client->lockClient) == 0) {\n        MqttClient_RespList_Remove(client, &unsubscribe->pendResp);\n        wm_SemUnlock(&client->lockClient);\n    }\n#endif\n\n#ifdef WOLFMQTT_V5\n    if (unsubscribe->ack.props != NULL) {\n        /* Release the allocated properties */\n        MqttClient_PropsFree(unsubscribe->ack.props);\n    }\n#endif\n\n    /* reset state */\n    unsubscribe->stat = MQTT_MSG_BEGIN;\n\n    return rc;\n}\n\nint MqttClient_Ping_ex(MqttClient *client, MqttPing* ping)\n{\n    int rc, len;\n\n    /* Validate required arguments */\n    if (client == NULL || ping == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    if (ping->stat == MQTT_MSG_BEGIN) {\n    #ifdef WOLFMQTT_MULTITHREAD\n        /* Lock send socket mutex */\n        rc = wm_SemLock(&client->lockSend);\n        if (rc != 0) {\n            return rc;\n        }\n    #endif\n\n        /* Encode the subscribe packet */\n        rc = MqttEncode_Ping(client->tx_buf, client->tx_buf_len, ping);\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d), ID %d, QoS %d\",\n            rc, MqttPacket_TypeDesc(MQTT_PACKET_TYPE_PING_REQ),\n            MQTT_PACKET_TYPE_PING_REQ, 0, 0);\n    #endif\n        if (rc <= 0) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            wm_SemUnlock(&client->lockSend);\n        #endif\n            return rc;\n        }\n        len = rc;\n\n    #ifdef WOLFMQTT_MULTITHREAD\n        rc = wm_SemLock(&client->lockClient);\n        if (rc == 0) {\n            /* inform other threads of expected response */\n            rc = MqttClient_RespList_Add(client, MQTT_PACKET_TYPE_PING_RESP, 0,\n                &ping->pendResp, ping);\n            wm_SemUnlock(&client->lockClient);\n        }\n        if (rc != 0) {\n            wm_SemUnlock(&client->lockSend);\n            return rc; /* Error locking client */\n        }\n    #endif\n\n        /* Send ping req packet */\n        rc = MqttPacket_Write(client, client->tx_buf, len);\n    #ifdef WOLFMQTT_MULTITHREAD\n        wm_SemUnlock(&client->lockSend);\n    #endif\n        if (rc != len) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (wm_SemLock(&client->lockClient) == 0) {\n                MqttClient_RespList_Remove(client, &ping->pendResp);\n                wm_SemUnlock(&client->lockClient);\n            }\n        #endif\n            return rc;\n        }\n\n        ping->stat = MQTT_MSG_WAIT;\n    }\n\n    /* Wait for ping resp packet */\n    rc = MqttClient_WaitType(client, ping, MQTT_PACKET_TYPE_PING_RESP, 0,\n        client->cmd_timeout_ms);\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc == MQTT_CODE_CONTINUE)\n        return rc;\n#endif\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (wm_SemLock(&client->lockClient) == 0) {\n        MqttClient_RespList_Remove(client, &ping->pendResp);\n        wm_SemUnlock(&client->lockClient);\n    }\n#endif\n\n    /* reset state */\n    ping->stat = MQTT_MSG_BEGIN;\n\n    return rc;\n}\n\nint MqttClient_Ping(MqttClient *client)\n{\n    MqttPing ping;\n    XMEMSET(&ping, 0, sizeof(ping));\n    return MqttClient_Ping_ex(client, &ping);\n}\n\nint MqttClient_Disconnect(MqttClient *client)\n{\n    return MqttClient_Disconnect_ex(client, NULL);\n}\n\nint MqttClient_Disconnect_ex(MqttClient *client, MqttDisconnect *disconnect)\n{\n    int rc, len;\n\n    /* Validate required arguments */\n    if (client == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n#ifdef WOLFMQTT_V5\n    if (disconnect != NULL) {\n        /* Use specified protocol version if set */\n        disconnect->protocol_level = client->protocol_level;\n    }\n#endif\n\n#ifdef WOLFMQTT_MULTITHREAD\n    /* Lock send socket mutex */\n    rc = wm_SemLock(&client->lockSend);\n    if (rc != 0) {\n        return rc;\n    }\n#endif\n\n    /* Encode the disconnect packet */\n    rc = MqttEncode_Disconnect(client->tx_buf, client->tx_buf_len, disconnect);\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d), ID %d, QoS %d\",\n        rc, MqttPacket_TypeDesc(MQTT_PACKET_TYPE_DISCONNECT),\n        MQTT_PACKET_TYPE_DISCONNECT, 0, 0);\n#endif\n    if (rc <= 0) {\n    #ifdef WOLFMQTT_MULTITHREAD\n        wm_SemUnlock(&client->lockSend);\n    #endif\n        return rc;\n    }\n    len = rc;\n\n    /* Send disconnect packet */\n    rc = MqttPacket_Write(client, client->tx_buf, len);\n#ifdef WOLFMQTT_MULTITHREAD\n    wm_SemUnlock(&client->lockSend);\n#endif\n    if (rc != len) {\n        return rc;\n    }\n\n    /* No response for MQTT disconnect packet */\n\n    return MQTT_CODE_SUCCESS;\n}\n\n#ifdef WOLFMQTT_V5\nint MqttClient_Auth(MqttClient *client, MqttAuth* auth)\n{\n    int rc, len;\n\n    /* Validate required arguments */\n    if (client == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    if (auth->stat == MQTT_MSG_BEGIN) {\n    #ifdef WOLFMQTT_MULTITHREAD\n        /* Lock send socket mutex */\n        rc = wm_SemLock(&client->lockSend);\n        if (rc != 0) {\n            return rc;\n        }\n    #endif\n\n        /* Encode the authentication packet */\n        rc = MqttEncode_Auth(client->tx_buf, client->tx_buf_len, auth);\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d), ID %d, QoS %d\",\n            rc, MqttPacket_TypeDesc(MQTT_PACKET_TYPE_AUTH),\n            MQTT_PACKET_TYPE_AUTH, 0, 0);\n    #endif\n        if (rc <= 0) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            wm_SemUnlock(&client->lockSend);\n        #endif\n            return rc;\n        }\n        len = rc;\n\n    #ifdef WOLFMQTT_MULTITHREAD\n        rc = wm_SemLock(&client->lockClient);\n        if (rc == 0) {\n            /* inform other threads of expected response */\n            rc = MqttClient_RespList_Add(client, MQTT_PACKET_TYPE_AUTH, 0,\n                &auth->pendResp, auth);\n            wm_SemUnlock(&client->lockClient);\n        }\n        if (rc != 0) {\n            wm_SemUnlock(&client->lockSend);\n            return rc; /* Error locking client */\n        }\n    #endif\n\n        /* Send authentication packet */\n        rc = MqttPacket_Write(client, client->tx_buf, len);\n    #ifdef WOLFMQTT_MULTITHREAD\n        wm_SemUnlock(&client->lockSend);\n    #endif\n        if (rc != len) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (wm_SemLock(&client->lockClient) == 0) {\n                MqttClient_RespList_Remove(client, &auth->pendResp);\n                wm_SemUnlock(&client->lockClient);\n            }\n        #endif\n            return rc;\n        }\n\n        auth->stat = MQTT_MSG_WAIT;\n    }\n\n    /* Wait for auth packet */\n    rc = MqttClient_WaitType(client, auth, MQTT_PACKET_TYPE_AUTH, 0,\n        client->cmd_timeout_ms);\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc == MQTT_CODE_CONTINUE)\n        return rc;\n#endif\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (wm_SemLock(&client->lockClient) == 0) {\n        MqttClient_RespList_Remove(client, &auth->pendResp);\n        wm_SemUnlock(&client->lockClient);\n    }\n#endif\n\n    /* reset state */\n    auth->stat = MQTT_MSG_BEGIN;\n\n    return rc;\n}\n\nMqttProp* MqttClient_PropsAdd(MqttProp **head)\n{\n    return MqttProps_Add(head);\n}\n\nint MqttClient_PropsFree(MqttProp *head)\n{\n    return MqttProps_Free(head);\n}\n\n#endif /* WOLFMQTT_V5 */\n\nint MqttClient_WaitMessage_ex(MqttClient *client, MqttObject* msg,\n        int timeout_ms)\n{\n    return MqttClient_WaitType(client, msg, MQTT_PACKET_TYPE_ANY, 0,\n        timeout_ms);\n}\nint MqttClient_WaitMessage(MqttClient *client, int timeout_ms)\n{\n    if (client == NULL)\n        return MQTT_CODE_ERROR_BAD_ARG;\n    return MqttClient_WaitMessage_ex(client, &client->msg, timeout_ms);\n}\n\nint MqttClient_NetConnect(MqttClient *client, const char* host,\n    word16 port, int timeout_ms, int use_tls, MqttTlsCb cb)\n{\n    return MqttSocket_Connect(client, host, port, timeout_ms, use_tls, cb);\n}\n\nint MqttClient_NetDisconnect(MqttClient *client)\n{\n    return MqttSocket_Disconnect(client);\n}\n\nint MqttClient_GetProtocolVersion(MqttClient *client)\n{\n#ifdef WOLFMQTT_V5\n    if (client && client->protocol_level == MQTT_CONNECT_PROTOCOL_LEVEL_5)\n        return MQTT_CONNECT_PROTOCOL_LEVEL_5;\n#else\n    (void)client;\n#endif\n    return MQTT_CONNECT_PROTOCOL_LEVEL_4;\n}\nconst char* MqttClient_GetProtocolVersionString(MqttClient *client)\n{\n    const char* str = NULL;\n    int ver = MqttClient_GetProtocolVersion(client);\n    switch (ver) {\n        case MQTT_CONNECT_PROTOCOL_LEVEL_4:\n            return \"v3.1.1\";\n    #ifdef WOLFMQTT_V5\n        case MQTT_CONNECT_PROTOCOL_LEVEL_5:\n            return \"v5\";\n    #endif\n        default:\n            break;\n    }\n    return str;\n}\n\n#ifndef WOLFMQTT_NO_ERROR_STRINGS\nconst char* MqttClient_ReturnCodeToString(int return_code)\n{\n    switch(return_code) {\n        case MQTT_CODE_SUCCESS:\n            return \"Success\";\n        case MQTT_CODE_CONTINUE:\n            return \"Continue\"; /* would block */\n        case MQTT_CODE_STDIN_WAKE:\n            return \"STDIN Wake\";\n        case MQTT_CODE_PUB_CONTINUE:\n            return \"Continue calling publish\"; /* Chunked publish */\n        case MQTT_CODE_ERROR_BAD_ARG:\n            return \"Error (Bad argument)\";\n        case MQTT_CODE_ERROR_OUT_OF_BUFFER:\n            return \"Error (Out of buffer)\";\n        case MQTT_CODE_ERROR_MALFORMED_DATA:\n            return \"Error (Malformed Remaining Length)\";\n        case MQTT_CODE_ERROR_PACKET_TYPE:\n            return \"Error (Packet Type Mismatch)\";\n        case MQTT_CODE_ERROR_PACKET_ID:\n            return \"Error (Packet Id Mismatch)\";\n        case MQTT_CODE_ERROR_TLS_CONNECT:\n            return \"Error (TLS Connect)\";\n        case MQTT_CODE_ERROR_TIMEOUT:\n            return \"Error (Timeout)\";\n        case MQTT_CODE_ERROR_NETWORK:\n            return \"Error (Network)\";\n        case MQTT_CODE_ERROR_MEMORY:\n            return \"Error (Memory)\";\n        case MQTT_CODE_ERROR_STAT:\n            return \"Error (State)\";\n        case MQTT_CODE_ERROR_PROPERTY:\n            return \"Error (Property)\";\n        case MQTT_CODE_ERROR_SERVER_PROP:\n            return \"Error (Server Property)\";\n        case MQTT_CODE_ERROR_CALLBACK:\n            return \"Error (Error in Callback)\";\n        case MQTT_CODE_ERROR_SYSTEM:\n            return \"Error (System resource failed)\";\n    }\n    return \"Unknown\";\n}\n#endif /* !WOLFMQTT_NO_ERROR_STRINGS */\n\n#ifdef WOLFMQTT_SN\n\n/* Private functions */\nstatic int SN_Client_HandlePacket(MqttClient* client, SN_MsgType packet_type,\n    void* packet_obj, int timeout)\n{\n    int rc = MQTT_CODE_SUCCESS;\n    word16 packet_id = 0;\n\n    (void)timeout;\n\n    switch ((int)packet_type)\n    {\n        case SN_MSG_TYPE_GWINFO:\n        {\n            SN_GwInfo info, *p_info = &info;\n            if (packet_obj) {\n                p_info = (SN_GwInfo*)packet_obj;\n            }\n            else {\n                XMEMSET(p_info, 0, sizeof(SN_GwInfo));\n            }\n\n            rc = SN_Decode_GWInfo(client->rx_buf, client->packet.buf_len,\n                    p_info);\n            if (rc <= 0) {\n                return rc;\n            }\n            break;\n        }\n        case SN_MSG_TYPE_CONNACK:\n        {\n            /* Decode connect ack */\n            SN_ConnectAck connect_ack, *p_connect_ack = &connect_ack;\n            if (packet_obj) {\n                p_connect_ack = (SN_ConnectAck*)packet_obj;\n            }\n            else {\n                XMEMSET(p_connect_ack, 0, sizeof(SN_ConnectAck));\n            }\n            p_connect_ack->return_code =\n                    client->rx_buf[client->packet.buf_len-1];\n\n            break;\n        }\n        case SN_MSG_TYPE_WILLTOPICREQ:\n        {\n            rc = SN_Decode_WillTopicReq(client->rx_buf, client->packet.buf_len);\n            break;\n        }\n        case SN_MSG_TYPE_WILLMSGREQ:\n        {\n            rc = SN_Decode_WillMsgReq(client->rx_buf, client->packet.buf_len);\n            break;\n        }\n        case SN_MSG_TYPE_REGISTER:\n        {\n            /* Decode register */\n            SN_Register reg_s;\n            int len;\n\n            XMEMSET(&reg_s, 0, sizeof(SN_Register));\n\n            rc = SN_Decode_Register(client->rx_buf, client->packet.buf_len,\n                    &reg_s);\n\n            if (rc > 0) {\n                /* Initialize the regack */\n                reg_s.regack.packet_id = reg_s.packet_id;\n                reg_s.regack.topicId = reg_s.topicId;\n                reg_s.regack.return_code = SN_RC_NOTSUPPORTED;\n\n                /* Call the register callback to allow app to\n                   handle new topic ID assignment. */\n                if (client->reg_cb != NULL) {\n                     rc = client->reg_cb(reg_s.topicId,\n                            reg_s.topicName, client->reg_ctx);\n                     /* Set the regack return code */\n                     reg_s.regack.return_code = (rc >= 0) ? SN_RC_ACCEPTED :\n                             SN_RC_INVTOPICNAME;\n                }\n\n            #ifdef WOLFMQTT_MULTITHREAD\n                /* Lock send socket mutex */\n                rc = wm_SemLock(&client->lockSend);\n                if (rc != 0) {\n                    return rc;\n                }\n            #endif\n\n                /* Encode the register acknowledgment */\n                rc = SN_Encode_RegAck(client->tx_buf, client->tx_buf_len,\n                        &reg_s.regack);\n            #ifdef WOLFMQTT_DEBUG_CLIENT\n                PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d), ID %d\",\n                    rc, SN_Packet_TypeDesc(SN_MSG_TYPE_REGACK),\n                    SN_MSG_TYPE_REGACK, reg_s.packet_id);\n            #endif\n                if (rc <= 0) {\n                #ifdef WOLFMQTT_MULTITHREAD\n                    wm_SemUnlock(&client->lockSend);\n                #endif\n                    return rc;\n                }\n                len = rc;\n\n                /* Send regack packet */\n                rc = MqttPacket_Write(client, client->tx_buf, len);\n            #ifdef WOLFMQTT_MULTITHREAD\n                wm_SemUnlock(&client->lockSend);\n            #endif\n                if (rc != len) { return rc; }\n            }\n\n            break;\n        }\n        case SN_MSG_TYPE_REGACK:\n        {\n            /* Decode register ack */\n            SN_RegAck regack_s, *p_regack = &regack_s;\n            if (packet_obj) {\n                p_regack = (SN_RegAck*)packet_obj;\n            }\n            else {\n                XMEMSET(p_regack, 0, sizeof(SN_RegAck));\n            }\n\n            rc = SN_Decode_RegAck(client->rx_buf, client->packet.buf_len,\n                    p_regack);\n            if (rc > 0) {\n                packet_id = p_regack->packet_id;\n            }\n\n            break;\n        }\n        case SN_MSG_TYPE_PUBLISH:\n        {\n            SN_Publish pub, *p_pub = &pub;\n            if (packet_obj) {\n                p_pub = (SN_Publish*)packet_obj;\n            }\n            else {\n                XMEMSET(p_pub, 0, sizeof(SN_Publish));\n            }\n\n            /* Decode publish message */\n            rc = SN_Decode_Publish(client->rx_buf, client->packet.buf_len,\n                   p_pub);\n            if (rc <= 0) {\n                return rc;\n            }\n\n            /* Issue callback for new message */\n            if (client->msg_cb) {\n                /* if using the temp publish message buffer,\n                   then populate message context with client context */\n                if (&client->msgSN.publish == p_pub)\n                    p_pub->ctx = client->ctx;\n                rc = client->msg_cb(client, (MqttMessage*)p_pub, 1, 1);\n                if (rc != MQTT_CODE_SUCCESS) {\n                    return rc;\n                };\n            }\n\n            /* Handle Qos */\n            if (p_pub->qos > MQTT_QOS_0) {\n                SN_MsgType type;\n\n                packet_id = p_pub->packet_id;\n\n                /* Determine packet type to write */\n                type = (p_pub->qos == MQTT_QOS_1) ?\n                        SN_MSG_TYPE_PUBACK :\n                        SN_MSG_TYPE_PUBREC;\n                p_pub->resp.packet_id = packet_id;\n\n            #ifdef WOLFMQTT_MULTITHREAD\n                /* Lock send socket mutex */\n                rc = wm_SemLock(&client->lockSend);\n                if (rc != 0) {\n                    return rc;\n                }\n            #endif\n\n                /* Encode publish response */\n                rc = SN_Encode_PublishResp(client->tx_buf,\n                                    client->tx_buf_len, type, &p_pub->resp);\n            #ifdef WOLFMQTT_DEBUG_CLIENT\n                PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d), ID %d,\"\n                        \" QoS %d\",\n                    rc, SN_Packet_TypeDesc(type), type, packet_id,\n                    p_pub->qos);\n            #endif\n                if (rc <= 0) {\n                #ifdef WOLFMQTT_MULTITHREAD\n                    wm_SemUnlock(&client->lockSend);\n                #endif\n                    return rc;\n                }\n                client->packet.buf_len = rc;\n\n                /* Send packet */\n                rc = MqttPacket_Write(client, client->tx_buf,\n                                                    client->packet.buf_len);\n            #ifdef WOLFMQTT_MULTITHREAD\n                wm_SemUnlock(&client->lockSend);\n            #endif\n            }\n            break;\n        }\n        case SN_MSG_TYPE_PUBACK:\n        case SN_MSG_TYPE_PUBCOMP:\n        case SN_MSG_TYPE_PUBREC:\n        case SN_MSG_TYPE_PUBREL:\n        {\n            SN_PublishResp publish_resp;\n            XMEMSET(&publish_resp, 0, sizeof(SN_PublishResp));\n\n            /* Decode publish response message */\n            rc = SN_Decode_PublishResp(client->rx_buf, client->packet.buf_len,\n                packet_type, &publish_resp);\n            if (rc <= 0) {\n                return rc;\n            }\n            packet_id = publish_resp.packet_id;\n\n            /* If Qos then send response */\n            if (packet_type == SN_MSG_TYPE_PUBREC ||\n                packet_type == SN_MSG_TYPE_PUBREL) {\n\n                byte resp_type = (packet_type == SN_MSG_TYPE_PUBREC) ?\n                        SN_MSG_TYPE_PUBREL : SN_MSG_TYPE_PUBCOMP;\n\n            #ifdef WOLFMQTT_MULTITHREAD\n                /* Lock send socket mutex */\n                rc = wm_SemLock(&client->lockSend);\n                if (rc != 0) {\n                    return rc;\n                }\n            #endif\n\n                /* Encode publish response */\n                publish_resp.packet_id = packet_id;\n                rc = SN_Encode_PublishResp(client->tx_buf,\n                    client->tx_buf_len, resp_type, &publish_resp);\n            #ifdef WOLFMQTT_DEBUG_CLIENT\n                PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d), ID %d\",\n                    rc, MqttPacket_TypeDesc(resp_type), resp_type, packet_id);\n            #endif\n                if (rc <= 0) {\n                #ifdef WOLFMQTT_MULTITHREAD\n                    wm_SemUnlock(&client->lockSend);\n                #endif\n                    return rc;\n                }\n                client->packet.buf_len = rc;\n\n                /* Send packet */\n                rc = MqttPacket_Write(client, client->tx_buf,\n                        client->packet.buf_len);\n            #ifdef WOLFMQTT_MULTITHREAD\n                wm_SemUnlock(&client->lockSend);\n            #endif\n            }\n            break;\n        }\n        case SN_MSG_TYPE_SUBACK:\n        {\n            /* Decode subscribe ack */\n            SN_SubAck subscribe_ack, *p_subscribe_ack = &subscribe_ack;\n            if (packet_obj) {\n                p_subscribe_ack = (SN_SubAck*)packet_obj;\n            }\n            else {\n                XMEMSET(p_subscribe_ack, 0, sizeof(SN_SubAck));\n            }\n\n            rc = SN_Decode_SubscribeAck(client->rx_buf, client->packet.buf_len,\n                    p_subscribe_ack);\n            if (rc <= 0) {\n                return rc;\n            }\n            packet_id = p_subscribe_ack->packet_id;\n\n            break;\n        }\n        case SN_MSG_TYPE_UNSUBACK:\n        {\n            /* Decode unsubscribe ack */\n            SN_UnsubscribeAck unsubscribe_ack,\n                              *p_unsubscribe_ack = &unsubscribe_ack;\n            if (packet_obj) {\n                p_unsubscribe_ack = (SN_UnsubscribeAck*)packet_obj;\n            }\n            else {\n                XMEMSET(p_unsubscribe_ack, 0, sizeof(SN_UnsubscribeAck));\n            }\n            rc = SN_Decode_UnsubscribeAck(client->rx_buf,\n                    client->packet.buf_len, p_unsubscribe_ack);\n            if (rc <= 0) {\n                return rc;\n            }\n            packet_id = p_unsubscribe_ack->packet_id;\n\n            break;\n        }\n        case SN_MSG_TYPE_PING_RESP:\n        {\n            /* Decode ping */\n            rc = SN_Decode_Ping(client->rx_buf, client->packet.buf_len);\n            break;\n        }\n        case SN_MSG_TYPE_PING_REQ:\n        {\n            int len;\n\n            /* Decode ping */\n            rc = SN_Decode_Ping(client->rx_buf, client->packet.buf_len);\n            if (rc <= 0) { return rc; }\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock send socket mutex */\n            rc = wm_SemLock(&client->lockSend);\n            if (rc != 0) {\n                return rc;\n            }\n        #endif\n\n            /* Encode the ping packet as a response */\n            rc = SN_Encode_Ping(client->tx_buf, client->tx_buf_len, NULL,\n                    SN_MSG_TYPE_PING_RESP);\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d)\",\n                rc, SN_Packet_TypeDesc(SN_MSG_TYPE_PING_RESP),\n                SN_MSG_TYPE_PING_RESP);\n        #endif\n            if (rc <= 0) {\n            #ifdef WOLFMQTT_MULTITHREAD\n                wm_SemUnlock(&client->lockSend);\n            #endif\n                return rc;\n            }\n            len = rc;\n\n            /* Send ping resp packet */\n            rc = MqttPacket_Write(client, client->tx_buf, len);\n        #ifdef WOLFMQTT_MULTITHREAD\n            wm_SemUnlock(&client->lockSend);\n        #endif\n            if (rc != len) { return rc; }\n\n            break;\n        }\n        case SN_MSG_TYPE_WILLTOPICRESP:\n        {\n            /* Decode Will Topic Response */\n            SN_WillTopicResp resp_s, *resp = &resp_s;\n            if (packet_obj) {\n                resp = (SN_WillTopicResp*)packet_obj;\n            }\n            else {\n                XMEMSET(resp, 0, sizeof(SN_WillTopicResp));\n            }\n            rc = SN_Decode_WillTopicResponse(client->rx_buf,\n                    client->packet.buf_len, &resp->return_code);\n            break;\n        }\n        case SN_MSG_TYPE_WILLMSGRESP:\n        {\n            /* Decode Will Message Response */\n            SN_WillMsgResp resp_s, *resp = &resp_s;\n            if (packet_obj) {\n                resp = (SN_WillMsgResp*)packet_obj;\n            }\n            else {\n                XMEMSET(resp, 0, sizeof(SN_WillMsgResp));\n            }\n            rc = SN_Decode_WillMsgResponse(client->rx_buf,\n                    client->packet.buf_len, &resp->return_code);\n            break;\n        }\n        case SN_MSG_TYPE_DISCONNECT:\n        {\n            /* Decode Disconnect */\n            rc = SN_Decode_Disconnect(client->rx_buf, client->packet.buf_len);\n            break;\n        }\n\n        default:\n        {\n            /* Other types are server side only, ignore */\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"SN_Client_HandlePacket: Invalid client packet type %u!\",\n                packet_type);\n        #endif\n            break;\n        }\n    } /* switch (packet_type) */\n\n    (void)packet_id;\n\n    return rc;\n}\n\nstatic int SN_Client_WaitType(MqttClient *client, void* packet_obj,\n    byte wait_type, word16 wait_packet_id, int timeout_ms)\n{\n    int rc;\n    word16 packet_id;\n    SN_MsgType packet_type;\n#ifdef WOLFMQTT_MULTITHREAD\n    MqttPendResp *pendResp;\n    int readLocked;\n#endif\n    MqttMsgStat* mms_stat;\n    int waitMatchFound;\n\n    if (client == NULL || packet_obj == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* all packet type structures must have MqttMsgStat at top */\n    mms_stat = (MqttMsgStat*)packet_obj;\n\nwait_again:\n\n    /* initialize variables */\n    packet_id = 0;\n    packet_type = SN_MSG_TYPE_RESERVED;\n#ifdef WOLFMQTT_MULTITHREAD\n    pendResp = NULL;\n    readLocked = 0;\n#endif\n    waitMatchFound = 0;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"SN_Client_WaitType: Type %s (%d), ID %d\",\n            SN_Packet_TypeDesc((SN_MsgType)wait_type),\n                wait_type, wait_packet_id);\n#endif\n\n    switch ((int)*mms_stat)\n    {\n        case MQTT_MSG_BEGIN:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock recv socket mutex */\n            rc = wm_SemLock(&client->lockRecv);\n            if (rc != 0) {\n                PRINTF(\"SN_Client_WaitType recv lock error\");\n                return rc;\n            }\n            readLocked = 1;\n        #endif\n\n            /* reset the packet state */\n            client->packet.stat = MQTT_PK_BEGIN;\n        }\n        FALL_THROUGH;\n\n        case MQTT_MSG_WAIT:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if packet type and id have already completed */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, (MqttPacketType)wait_type,\n                        wait_packet_id, &pendResp)) {\n                    if (pendResp->packetDone) {\n                        /* pending response is already done, so return */\n                        rc = pendResp->packet_ret;\n                    #ifdef WOLFMQTT_DEBUG_CLIENT\n                        PRINTF(\"PendResp already Done %p: Rc %d\", pendResp, rc);\n                    #endif\n                        MqttClient_RespList_Remove(client, pendResp);\n                        wm_SemUnlock(&client->lockClient);\n                        wm_SemUnlock(&client->lockRecv);\n                        return rc;\n                    }\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                wm_SemUnlock(&client->lockRecv);\n                return rc;\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            *mms_stat = MQTT_MSG_WAIT;\n\n            /* Wait for packet */\n            rc = SN_Packet_Read(client, client->rx_buf, client->rx_buf_len,\n                    timeout_ms);\n            if (rc <= 0) {\n                break;\n            }\n\n            client->packet.buf_len = rc;\n\n            /* Decode header */\n            rc = SN_Decode_Header(client->rx_buf, client->packet.buf_len,\n                    &packet_type, &packet_id);\n            if (rc < 0) {\n                break;\n            }\n\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"Read Packet: Len %d, Type %d, ID %d\",\n                client->packet.buf_len, packet_type, packet_id);\n        #endif\n\n            *mms_stat = MQTT_MSG_READ;\n        }\n        FALL_THROUGH;\n\n        case MQTT_MSG_READ:\n        case MQTT_MSG_READ_PAYLOAD:\n        {\n            SN_MsgType use_packet_type;\n            void* use_packet_obj;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            readLocked = 1; /* if in this state read is locked */\n        #endif\n\n            if (*mms_stat == MQTT_MSG_READ_PAYLOAD) {\n                packet_type = SN_MSG_TYPE_PUBLISH;\n            }\n\n            /* Determine if we received data for this request */\n            if ((wait_type == SN_MSG_TYPE_ANY || wait_type == packet_type) &&\n                (wait_packet_id == 0 || wait_packet_id == packet_id))\n            {\n                use_packet_obj = packet_obj;\n                waitMatchFound = 1;\n            }\n            else {\n                /* use generic packet object */\n                use_packet_obj = &client->msgSN;\n            }\n            use_packet_type = packet_type;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if we have a pending response for this packet */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client,\n                        (MqttPacketType)packet_type, packet_id, &pendResp)) {\n                    /* we found packet match this incoming read packet */\n                    pendResp->packetProcessing = 1;\n                    use_packet_obj = pendResp->packet_obj;\n                    use_packet_type = (SN_MsgType)pendResp->packet_type;\n                    /* req from another thread... not a match */\n                    waitMatchFound = 0;\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            rc = SN_Client_HandlePacket(client, use_packet_type, use_packet_obj,\n                    timeout_ms);\n\n        #ifdef WOLFMQTT_NONBLOCK\n            if (rc == MQTT_CODE_CONTINUE) {\n                /* we have received some data, so keep the recv\n                    mutex lock active and return */\n                return rc;\n            }\n        #endif\n\n            /* handle success case */\n            if (rc >= 0) {\n                rc = MQTT_CODE_SUCCESS;\n            }\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (pendResp) {\n                /* Mark pending response entry done */\n                if (wm_SemLock(&client->lockClient) == 0) {\n                    pendResp->packetDone = 1;\n                    pendResp->packet_ret = rc;\n                #ifdef WOLFMQTT_DEBUG_CLIENT\n                    PRINTF(\"PendResp Marked Done %p\", pendResp);\n                #endif\n                    pendResp = NULL;\n                    wm_SemUnlock(&client->lockClient);\n                }\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n            break;\n        }\n\n        case MQTT_MSG_WRITE:\n        default:\n        {\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"SN_Client_WaitType: Invalid state %d!\", *mms_stat);\n        #endif\n            rc = MQTT_CODE_ERROR_STAT;\n            break;\n        }\n    } /* switch (msg->stat) */\n\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc != MQTT_CODE_CONTINUE)\n#endif\n    {\n        /* reset state */\n        *mms_stat = MQTT_MSG_BEGIN;\n    }\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (readLocked) {\n        wm_SemUnlock(&client->lockRecv);\n    }\n#endif\n\n    if (rc < 0) {\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"SN_Client_WaitType: Failure: %s (%d)\",\n            MqttClient_ReturnCodeToString(rc), rc);\n    #endif\n        return rc;\n    }\n\n    if (!waitMatchFound) {\n        /* if we get here, then the we are still waiting for a packet */\n        goto wait_again;\n    }\n\n    return rc;\n}\n\n/* Public Functions */\n\nint SN_Client_SetRegisterCallback(MqttClient *client,\n        SN_ClientRegisterCb regCb,\n        void* ctx)\n{\n    int rc = MQTT_CODE_SUCCESS;\n\n    if (client == NULL)\n        return MQTT_CODE_ERROR_BAD_ARG;\n\n#ifdef WOLFMQTT_MULTITHREAD\n    rc = wm_SemLock(&client->lockClient);\n    if (rc == 0) {\n#endif\n\n        client->reg_cb = regCb;\n        client->reg_ctx = ctx;\n\n#ifdef WOLFMQTT_MULTITHREAD\n        wm_SemUnlock(&client->lockClient);\n    }\n#endif\n\n    return rc;\n}\n\nint SN_Client_SearchGW(MqttClient *client, SN_SearchGw *search)\n{\n    int rc, len = 0;\n\n    /* Validate required arguments */\n    if (client == NULL || search == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    if (search->stat == MQTT_MSG_BEGIN) {\n    #ifdef WOLFMQTT_MULTITHREAD\n        /* Lock send socket mutex */\n        rc = wm_SemLock(&client->lockSend);\n        if (rc != 0) {\n            return rc;\n        }\n    #endif\n\n        /* Encode the search packet */\n        rc = SN_Encode_SearchGW(client->tx_buf, client->tx_buf_len,\n                search->radius);\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d)\",\n            rc, SN_Packet_TypeDesc(SN_MSG_TYPE_SEARCHGW),\n            SN_MSG_TYPE_SEARCHGW);\n    #endif\n        if (rc <= 0) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            wm_SemUnlock(&client->lockSend);\n        #endif\n            return rc;\n        }\n        len = rc;\n\n    #ifdef WOLFMQTT_MULTITHREAD\n        rc = wm_SemLock(&client->lockClient);\n        if (rc == 0) {\n            /* inform other threads of expected response */\n            rc = MqttClient_RespList_Add(client,\n                    (MqttPacketType)SN_MSG_TYPE_GWINFO, 0,\n                    &search->pendResp, &search->gwInfo);\n            wm_SemUnlock(&client->lockClient);\n        }\n        if (rc != 0) {\n            wm_SemUnlock(&client->lockSend);\n            return rc; /* Error locking client */\n        }\n    #endif\n\n        /* Send search for gateway packet */\n        rc = MqttPacket_Write(client, client->tx_buf, len);\n    #ifdef WOLFMQTT_MULTITHREAD\n        wm_SemUnlock(&client->lockSend);\n    #endif\n        if (rc != len) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (wm_SemLock(&client->lockClient) == 0) {\n                MqttClient_RespList_Remove(client, &search->pendResp);\n                wm_SemUnlock(&client->lockClient);\n            }\n        #endif\n            return rc;\n        }\n        search->stat = MQTT_MSG_WAIT;\n    }\n\n    /* Wait for gateway info packet */\n    rc = SN_Client_WaitType(client, &search->gwInfo, SN_MSG_TYPE_GWINFO, 0,\n        client->cmd_timeout_ms);\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc == MQTT_CODE_CONTINUE)\n        return rc;\n#endif\n#ifdef WOLFMQTT_MULTITHREAD\n    if (wm_SemLock(&client->lockClient) == 0) {\n        MqttClient_RespList_Remove(client, &search->pendResp);\n        wm_SemUnlock(&client->lockClient);\n    }\n#endif\n\n    /* reset state */\n    search->stat = MQTT_MSG_BEGIN;\n\n    return rc;\n}\n\nstatic int SN_WillTopic(MqttClient *client, SN_Will *will)\n{\n    int rc, len;\n\n    /* Validate required arguments */\n    if (client == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n#ifdef WOLFMQTT_MULTITHREAD\n    rc = wm_SemLock(&client->lockClient);\n    if (rc == 0) {\n        /* inform other threads of expected response */\n        rc = MqttClient_RespList_Add(client,\n                (MqttPacketType)SN_MSG_TYPE_WILLTOPICREQ, 0,\n                &will->pendResp, &will->resp.topicResp);\n        wm_SemUnlock(&client->lockClient);\n    }\n    if (rc != 0) {\n        return rc; /* Error locking client */\n    }\n#endif\n\n    /* Wait for Will Topic Request packet */\n    rc = SN_Client_WaitType(client, will,\n            SN_MSG_TYPE_WILLTOPICREQ, 0, client->cmd_timeout_ms);\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc == MQTT_CODE_CONTINUE)\n        return rc;\n#endif\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (wm_SemLock(&client->lockClient) == 0) {\n        MqttClient_RespList_Remove(client, &will->pendResp);\n        wm_SemUnlock(&client->lockClient);\n    }\n#endif\n    if (rc == 0) {\n    #ifdef WOLFMQTT_MULTITHREAD\n        /* Lock send socket mutex */\n        rc = wm_SemLock(&client->lockSend);\n        if (rc != 0) {\n            return rc;\n        }\n    #endif\n\n        /* Encode Will Topic */\n        len = rc = SN_Encode_WillTopic(client->tx_buf, client->tx_buf_len,\n                will);\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"EncodePacket: Len %d, Type %s (%d)\",\n            rc, SN_Packet_TypeDesc(SN_MSG_TYPE_WILLTOPIC),\n            SN_MSG_TYPE_WILLTOPIC);\n    #endif\n        if (rc > 0) {\n            /* Send Will Topic packet */\n            rc = MqttPacket_Write(client, client->tx_buf, len);\n            if (rc == len) {\n                rc = 0;\n            }\n        }\n    #ifdef WOLFMQTT_MULTITHREAD\n        wm_SemUnlock(&client->lockSend);\n    #endif\n    }\n\n    return rc;\n}\n\nstatic int SN_WillMessage(MqttClient *client, SN_Will *will)\n{\n    int rc, len;\n\n    /* Validate required arguments */\n    if (client == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n#ifdef WOLFMQTT_MULTITHREAD\n    rc = wm_SemLock(&client->lockClient);\n    if (rc == 0) {\n        /* inform other threads of expected response */\n        rc = MqttClient_RespList_Add(client,\n                (MqttPacketType)SN_MSG_TYPE_WILLMSGREQ, 0,\n                &will->pendResp, &will->resp.msgResp);\n        wm_SemUnlock(&client->lockClient);\n    }\n    if (rc != 0) {\n        return rc; /* Error locking client */\n    }\n#endif\n\n    /* Wait for Will Message Request */\n    rc = SN_Client_WaitType(client, &will->resp.msgResp,\n            SN_MSG_TYPE_WILLMSGREQ, 0, client->cmd_timeout_ms);\n\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc == MQTT_CODE_CONTINUE)\n        return rc;\n#endif\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (wm_SemLock(&client->lockClient) == 0) {\n        MqttClient_RespList_Remove(client, &will->pendResp);\n        wm_SemUnlock(&client->lockClient);\n    }\n#endif\n\n    if (rc == 0) {\n    #ifdef WOLFMQTT_MULTITHREAD\n        /* Lock send socket mutex */\n        rc = wm_SemLock(&client->lockSend);\n        if (rc != 0) {\n            return rc;\n        }\n    #endif\n        /* Encode Will Message */\n        len = rc = SN_Encode_WillMsg(client->tx_buf,\n            client->tx_buf_len, will);\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"EncodePacket: Len %d, Type %s (%d)\",\n            rc, SN_Packet_TypeDesc(SN_MSG_TYPE_WILLMSG),\n            SN_MSG_TYPE_WILLMSG);\n    #endif\n        if (rc > 0) {\n            /* Send Will Topic packet */\n            rc = MqttPacket_Write(client, client->tx_buf, len);\n            if (rc == len) {\n                rc = 0;\n            }\n        }\n    #ifdef WOLFMQTT_MULTITHREAD\n        wm_SemUnlock(&client->lockSend);\n    #endif\n    }\n\n    return rc;\n}\n\nint SN_Client_Connect(MqttClient *client, SN_Connect *mc_connect)\n{\n    int rc = 0, len = 0;\n    static byte will_done;\n\n    /* Validate required arguments */\n    if ((client == NULL) || (mc_connect == NULL)) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    if (mc_connect->stat == MQTT_MSG_BEGIN) {\n\n        will_done = 0;\n\n    #ifdef WOLFMQTT_MULTITHREAD\n        /* Lock send socket mutex */\n        rc = wm_SemLock(&client->lockSend);\n        if (rc != 0) {\n            return rc;\n        }\n    #endif\n\n    /* Encode the connect packet */\n        rc = SN_Encode_Connect(client->tx_buf, client->tx_buf_len, mc_connect);\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d), ID %d, QoS %d\",\n        rc, SN_Packet_TypeDesc(SN_MSG_TYPE_CONNECT),\n        SN_MSG_TYPE_CONNECT, 0, 0);\n#endif\n        if (rc <= 0) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            wm_SemUnlock(&client->lockSend);\n        #endif\n            return rc;\n        }\n        len = rc;\n\n    #ifdef WOLFMQTT_MULTITHREAD\n        rc = wm_SemLock(&client->lockClient);\n        if (rc == 0) {\n            /* inform other threads of expected response */\n            rc = MqttClient_RespList_Add(client,\n                    (MqttPacketType)SN_MSG_TYPE_CONNACK, 0,\n                    &mc_connect->pendResp, &mc_connect->ack);\n            wm_SemUnlock(&client->lockClient);\n        }\n        if (rc != 0) {\n            wm_SemUnlock(&client->lockSend);\n            return rc; /* Error locking client */\n        }\n    #endif\n\n        /* Send connect packet */\n        rc = MqttPacket_Write(client, client->tx_buf, len);\n    #ifdef WOLFMQTT_MULTITHREAD\n        wm_SemUnlock(&client->lockSend);\n    #endif\n        if (rc != len) {\n            return rc;\n        }\n\n        mc_connect->stat = MQTT_MSG_WAIT;\n    }\n\n    if ((mc_connect->enable_lwt == 1) && (will_done != 1)) {\n        /* If the will is enabled, then the gateway requests the topic and\n           message in separate packets. */\n        rc = SN_WillTopic(client, &mc_connect->will);\n        if (rc != 0) {\n            return rc;\n        }\n\n        rc = SN_WillMessage(client, &mc_connect->will);\n        if (rc != 0) {\n            return rc;\n        }\n        will_done = 1;\n    }\n\n    /* Wait for connect ack packet */\n    rc = SN_Client_WaitType(client, &mc_connect->ack,\n            SN_MSG_TYPE_CONNACK, 0, client->cmd_timeout_ms);\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc == MQTT_CODE_CONTINUE)\n        return rc;\n#endif\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (wm_SemLock(&client->lockClient) == 0) {\n        MqttClient_RespList_Remove(client, &mc_connect->pendResp);\n        wm_SemUnlock(&client->lockClient);\n    }\n#endif\n\n    /* reset state */\n    mc_connect->stat = MQTT_MSG_BEGIN;\n\n    return rc;\n}\n\nint SN_Client_WillTopicUpdate(MqttClient *client, SN_Will *will)\n{\n    int rc = 0, len = 0;\n\n    /* Validate required arguments */\n    if (client == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    if (will->stat == MQTT_MSG_BEGIN) {\n    #ifdef WOLFMQTT_MULTITHREAD\n        /* Lock send socket mutex */\n        rc = wm_SemLock(&client->lockSend);\n        if (rc != 0) {\n            return rc;\n        }\n    #endif\n\n        /* Encode Will Topic Update */\n        len = rc = SN_Encode_WillTopicUpdate(client->tx_buf,\n                client->tx_buf_len, will);\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d)\",\n            rc, SN_Packet_TypeDesc(SN_MSG_TYPE_WILLTOPICUPD),\n            SN_MSG_TYPE_WILLTOPICUPD);\n    #endif\n        if (rc <= 0) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            wm_SemUnlock(&client->lockSend);\n        #endif\n            return rc;\n        }\n\n    #ifdef WOLFMQTT_MULTITHREAD\n        rc = wm_SemLock(&client->lockClient);\n        if (rc == 0) {\n            /* inform other threads of expected response */\n            rc = MqttClient_RespList_Add(client,\n                    (MqttPacketType)SN_MSG_TYPE_WILLTOPICRESP,\n                    0, &will->pendResp, &will->resp.topicResp);\n            wm_SemUnlock(&client->lockClient);\n        }\n        if (rc != 0) {\n            wm_SemUnlock(&client->lockSend);\n            return rc; /* Error locking client */\n        }\n    #endif\n\n        /* Send Will Topic Update packet */\n        rc = MqttPacket_Write(client, client->tx_buf, len);\n    #ifdef WOLFMQTT_MULTITHREAD\n        wm_SemUnlock(&client->lockSend);\n    #endif\n        if (rc != len) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (wm_SemLock(&client->lockClient) == 0) {\n                MqttClient_RespList_Remove(client, &will->pendResp);\n                wm_SemUnlock(&client->lockClient);\n            }\n        #endif\n        }\n        will->stat = MQTT_MSG_WAIT;\n    }\n\n    /* Wait for Will Topic Update Response packet */\n    rc = SN_Client_WaitType(client, &will->resp.topicResp,\n            SN_MSG_TYPE_WILLTOPICRESP, 0, client->cmd_timeout_ms);\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc == MQTT_CODE_CONTINUE)\n        return rc;\n#endif\n#ifdef WOLFMQTT_MULTITHREAD\n    if (wm_SemLock(&client->lockClient) == 0) {\n        MqttClient_RespList_Remove(client, &will->pendResp);\n        wm_SemUnlock(&client->lockClient);\n    }\n#endif\n\n    /* reset state */\n    will->stat = MQTT_MSG_BEGIN;\n\n    return rc;\n}\n\nint SN_Client_WillMsgUpdate(MqttClient *client, SN_Will *will)\n{\n    int rc = 0, len = 0;\n\n    /* Validate required arguments */\n    if ((client == NULL) || (will == NULL)) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    if (will->stat == MQTT_MSG_BEGIN) {\n    #ifdef WOLFMQTT_MULTITHREAD\n        /* Lock send socket mutex */\n        rc = wm_SemLock(&client->lockSend);\n        if (rc != 0) {\n            return rc;\n        }\n    #endif\n        /* Encode Will Message Update */\n        len = rc = SN_Encode_WillMsgUpdate(client->tx_buf,\n                client->tx_buf_len, will);\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d)\",\n            rc, SN_Packet_TypeDesc(SN_MSG_TYPE_WILLTOPICUPD),\n            SN_MSG_TYPE_WILLTOPICUPD);\n    #endif\n        if (rc <= 0) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            wm_SemUnlock(&client->lockSend);\n        #endif\n            return rc;\n        }\n\n    #ifdef WOLFMQTT_MULTITHREAD\n        rc = wm_SemLock(&client->lockClient);\n        if (rc == 0) {\n            /* inform other threads of expected response */\n            rc = MqttClient_RespList_Add(client,\n                    (MqttPacketType)SN_MSG_TYPE_WILLMSGRESP,\n                    0, &will->pendResp, &will->resp.msgResp);\n            wm_SemUnlock(&client->lockClient);\n        }\n        if (rc != 0) {\n            wm_SemUnlock(&client->lockSend);\n            return rc; /* Error locking client */\n        }\n    #endif\n\n        /* Send Will Message Update packet */\n        rc = MqttPacket_Write(client, client->tx_buf, len);\n    #ifdef WOLFMQTT_MULTITHREAD\n        wm_SemUnlock(&client->lockSend);\n    #endif\n        if (rc != len) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (wm_SemLock(&client->lockClient) == 0) {\n                MqttClient_RespList_Remove(client, &will->pendResp);\n                wm_SemUnlock(&client->lockClient);\n            }\n        #endif\n        }\n        will->stat = MQTT_MSG_WAIT;\n    }\n\n    /* Wait for Will Message Update Response packet */\n    rc = SN_Client_WaitType(client, &will->resp.msgResp,\n            SN_MSG_TYPE_WILLMSGRESP, 0, client->cmd_timeout_ms);\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc == MQTT_CODE_CONTINUE)\n        return rc;\n#endif\n#ifdef WOLFMQTT_MULTITHREAD\n    if (wm_SemLock(&client->lockClient) == 0) {\n        MqttClient_RespList_Remove(client, &will->pendResp);\n        wm_SemUnlock(&client->lockClient);\n    }\n#endif\n\n    /* reset state */\n    will->stat = MQTT_MSG_BEGIN;\n\n    return rc;\n\n}\n\nint SN_Client_Subscribe(MqttClient *client, SN_Subscribe *subscribe)\n{\n    int rc = -1, len;\n\n    /* Validate required arguments */\n    if (client == NULL || subscribe == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    if (subscribe->stat == MQTT_MSG_BEGIN) {\n    #ifdef WOLFMQTT_MULTITHREAD\n        /* Lock send socket mutex */\n        rc = wm_SemLock(&client->lockSend);\n        if (rc != 0) {\n            return rc;\n        }\n    #endif\n\n        /* Encode the subscribe packet */\n        rc = SN_Encode_Subscribe(client->tx_buf, client->tx_buf_len,\n                subscribe);\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d), QoS %d\",\n            rc, SN_Packet_TypeDesc(SN_MSG_TYPE_SUBSCRIBE),\n            SN_MSG_TYPE_SUBSCRIBE, subscribe->qos);\n    #endif\n        if (rc <= 0) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            wm_SemUnlock(&client->lockSend);\n        #endif\n            return rc;\n        }\n        len = rc;\n\n    #ifdef WOLFMQTT_MULTITHREAD\n        rc = wm_SemLock(&client->lockClient);\n        if (rc == 0) {\n            /* inform other threads of expected response */\n            rc = MqttClient_RespList_Add(client,\n                    (MqttPacketType)SN_MSG_TYPE_SUBACK, subscribe->packet_id,\n                    &subscribe->pendResp, &subscribe->subAck);\n            wm_SemUnlock(&client->lockClient);\n        }\n        if (rc != 0) {\n            wm_SemUnlock(&client->lockSend);\n            return rc; /* Error locking client */\n        }\n    #endif\n\n        /* Send subscribe packet */\n        rc = MqttPacket_Write(client, client->tx_buf, len);\n    #ifdef WOLFMQTT_MULTITHREAD\n        wm_SemUnlock(&client->lockSend);\n    #endif\n        if (rc != len) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (wm_SemLock(&client->lockClient) == 0) {\n                MqttClient_RespList_Remove(client, &subscribe->pendResp);\n                wm_SemUnlock(&client->lockClient);\n            }\n        #endif\n            return rc;\n        }\n\n        subscribe->stat = MQTT_MSG_WAIT;\n    }\n\n    /* Wait for subscribe ack packet */\n    rc = SN_Client_WaitType(client, &subscribe->subAck,\n            SN_MSG_TYPE_SUBACK, subscribe->packet_id, client->cmd_timeout_ms);\n\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc == MQTT_CODE_CONTINUE)\n        return rc;\n#endif\n#ifdef WOLFMQTT_MULTITHREAD\n    if (wm_SemLock(&client->lockClient) == 0) {\n        MqttClient_RespList_Remove(client, &subscribe->pendResp);\n        wm_SemUnlock(&client->lockClient);\n    }\n#endif\n\n    /* reset state */\n    subscribe->stat = MQTT_MSG_BEGIN;\n\n    return rc;\n}\n\nint SN_Client_Publish(MqttClient *client, SN_Publish *publish)\n{\n    int rc = MQTT_CODE_SUCCESS;\n    SN_MsgType resp_type;\n\n    /* Validate required arguments */\n    if (client == NULL || publish == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    switch ((int)publish->stat)\n    {\n        case MQTT_MSG_BEGIN:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock send socket mutex */\n            rc = wm_SemLock(&client->lockSend);\n            if (rc != 0) {\n                return rc;\n            }\n        #endif\n\n            /* Encode the publish packet */\n            rc = SN_Encode_Publish(client->tx_buf, client->tx_buf_len,\n                    publish);\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d), ID %d,\"\n                    \" QoS %d\",\n                rc, SN_Packet_TypeDesc(SN_MSG_TYPE_PUBLISH),\n                SN_MSG_TYPE_PUBLISH, publish->packet_id,\n                publish->qos);\n        #endif\n            if (rc <= 0) {\n            #ifdef WOLFMQTT_MULTITHREAD\n                wm_SemUnlock(&client->lockSend);\n            #endif\n                return rc;\n            }\n\n            client->write.len = rc;\n            publish->buffer_pos = 0;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            if ((publish->qos == MQTT_QOS_1) ||\n                (publish->qos == MQTT_QOS_2)) {\n                resp_type = (publish->qos == MQTT_QOS_1) ?\n                        SN_MSG_TYPE_PUBACK :\n                        SN_MSG_TYPE_PUBCOMP;\n\n                rc = wm_SemLock(&client->lockClient);\n                if (rc == 0) {\n                    /* inform other threads of expected response */\n                    rc = MqttClient_RespList_Add(client,\n                            (MqttPacketType)resp_type, publish->packet_id,\n                            &publish->pendResp, &publish->resp);\n                    wm_SemUnlock(&client->lockClient);\n                }\n                if (rc != 0) {\n                    wm_SemUnlock(&client->lockSend);\n                    return rc; /* Error locking client */\n                }\n            }\n        #endif\n\n            publish->stat = MQTT_MSG_WRITE;\n        }\n        FALL_THROUGH;\n\n        case MQTT_MSG_WRITE:\n        {\n            /* Send packet and payload */\n            rc = MqttPacket_Write(client, client->tx_buf,\n                    client->write.len);\n        #ifdef WOLFMQTT_NONBLOCK\n            if (rc == MQTT_CODE_CONTINUE)\n                return rc;\n        #endif\n        #ifdef WOLFMQTT_MULTITHREAD\n            wm_SemUnlock(&client->lockSend);\n        #endif\n\n            if (rc < 0) {\n            #ifdef WOLFMQTT_MULTITHREAD\n                if (wm_SemLock(&client->lockClient) == 0) {\n                    MqttClient_RespList_Remove(client, &publish->pendResp);\n                    wm_SemUnlock(&client->lockClient);\n                }\n            #endif\n                return rc;\n            }\n\n            if (rc == client->write.len) {\n                rc = MQTT_CODE_SUCCESS;\n            }\n            else {\n                rc = -1;\n            }\n\n            /* if not expecting a reply, the reset state and exit */\n            if ((publish->qos == MQTT_QOS_0) ||\n                (publish->qos == MQTT_QOS_3)) {\n                break;\n            }\n\n            publish->stat = MQTT_MSG_WAIT;\n        }\n        FALL_THROUGH;\n\n        case MQTT_MSG_WAIT:\n        {\n            /* Handle QoS */\n            if ((publish->qos == MQTT_QOS_1) ||\n                (publish->qos == MQTT_QOS_2)) {\n\n                /* Determine packet type to wait for */\n                resp_type = (publish->qos == MQTT_QOS_1) ?\n                        SN_MSG_TYPE_PUBACK :\n                        SN_MSG_TYPE_PUBCOMP;\n\n                /* Wait for publish response packet */\n                rc = SN_Client_WaitType(client, &publish->resp,\n                    resp_type, publish->packet_id, client->cmd_timeout_ms);\n            #ifdef WOLFMQTT_NONBLOCK\n                if (rc == MQTT_CODE_CONTINUE)\n                    break;\n            #endif\n            #ifdef WOLFMQTT_MULTITHREAD\n                if (wm_SemLock(&client->lockClient) == 0) {\n                    MqttClient_RespList_Remove(client, &publish->pendResp);\n                    wm_SemUnlock(&client->lockClient);\n                }\n            #endif\n\n                publish->return_code = publish->resp.return_code;\n            }\n\n            break;\n        }\n\n        case MQTT_MSG_READ:\n        case MQTT_MSG_READ_PAYLOAD:\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"SN_Client_Publish: Invalid state %d!\",\n                publish->stat);\n        #endif\n            rc = MQTT_CODE_ERROR_STAT;\n            break;\n    } /* switch (publish->stat) */\n\n    /* reset state */\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc != MQTT_CODE_CONTINUE)\n#endif\n    {\n        publish->stat = MQTT_MSG_BEGIN;\n    }\n    if (rc > 0) {\n        rc = MQTT_CODE_SUCCESS;\n    }\n\n    return rc;\n}\n\nint SN_Client_Unsubscribe(MqttClient *client, SN_Unsubscribe *unsubscribe)\n{\n    int rc, len;\n\n    /* Validate required arguments */\n    if (client == NULL || unsubscribe == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    if (unsubscribe->stat == MQTT_MSG_BEGIN) {\n    #ifdef WOLFMQTT_MULTITHREAD\n        /* Lock send socket mutex */\n        rc = wm_SemLock(&client->lockSend);\n        if (rc != 0) {\n            return rc;\n        }\n    #endif\n\n        /* Encode the subscribe packet */\n        rc = SN_Encode_Unsubscribe(client->tx_buf, client->tx_buf_len,\n            unsubscribe);\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d)\",\n            rc, SN_Packet_TypeDesc(SN_MSG_TYPE_UNSUBSCRIBE),\n            SN_MSG_TYPE_UNSUBSCRIBE);\n    #endif\n        if (rc <= 0) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            wm_SemUnlock(&client->lockSend);\n        #endif\n            return rc;\n        }\n        len = rc;\n\n    #ifdef WOLFMQTT_MULTITHREAD\n        rc = wm_SemLock(&client->lockClient);\n        if (rc == 0) {\n            /* inform other threads of expected response */\n            rc = MqttClient_RespList_Add(client,\n                    (MqttPacketType)SN_MSG_TYPE_UNSUBACK,\n                    0, &unsubscribe->pendResp, &unsubscribe->ack);\n            wm_SemUnlock(&client->lockClient);\n        }\n        if (rc != 0) {\n            wm_SemUnlock(&client->lockSend);\n            return rc; /* Error locking client */\n        }\n    #endif\n\n        /* Send unsubscribe packet */\n        rc = MqttPacket_Write(client, client->tx_buf, len);\n    #ifdef WOLFMQTT_MULTITHREAD\n        wm_SemUnlock(&client->lockSend);\n    #endif\n        if (rc != len) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (wm_SemLock(&client->lockClient) == 0) {\n                MqttClient_RespList_Remove(client, &unsubscribe->pendResp);\n                wm_SemUnlock(&client->lockClient);\n            }\n        #endif\n        }\n        unsubscribe->stat = MQTT_MSG_WAIT;\n    }\n\n    /* Wait for unsubscribe ack packet */\n    rc = SN_Client_WaitType(client, &unsubscribe->ack,\n            SN_MSG_TYPE_UNSUBACK, unsubscribe->packet_id,\n            client->cmd_timeout_ms);\n    #ifdef WOLFMQTT_NONBLOCK\n        if (rc == MQTT_CODE_CONTINUE)\n            return rc;\n    #endif\n    #ifdef WOLFMQTT_MULTITHREAD\n        if (wm_SemLock(&client->lockClient) == 0) {\n            MqttClient_RespList_Remove(client, &unsubscribe->pendResp);\n            wm_SemUnlock(&client->lockClient);\n        }\n    #endif\n\n    /* reset state */\n    unsubscribe->stat = MQTT_MSG_BEGIN;\n\n    return rc;\n}\n\nint SN_Client_Register(MqttClient *client, SN_Register *regist)\n{\n    int rc, len;\n\n    /* Validate required arguments */\n    if (client == NULL || regist == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    if (regist->stat == MQTT_MSG_BEGIN) {\n    #ifdef WOLFMQTT_MULTITHREAD\n        /* Lock send socket mutex */\n        rc = wm_SemLock(&client->lockSend);\n        if (rc != 0) {\n            return rc;\n        }\n    #endif\n\n        /* Encode the register packet */\n        rc = SN_Encode_Register(client->tx_buf, client->tx_buf_len, regist);\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d)\",\n            rc, SN_Packet_TypeDesc(SN_MSG_TYPE_REGISTER),\n            SN_MSG_TYPE_REGISTER);\n    #endif\n        if (rc <= 0) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            wm_SemUnlock(&client->lockSend);\n        #endif\n            return rc;\n        }\n        len = rc;\n\n    #ifdef WOLFMQTT_MULTITHREAD\n        rc = wm_SemLock(&client->lockClient);\n        if (rc == 0) {\n            /* inform other threads of expected response */\n            rc = MqttClient_RespList_Add(client,\n                    (MqttPacketType)SN_MSG_TYPE_REGACK,\n                    regist->packet_id, &regist->pendResp, &regist->regack);\n            wm_SemUnlock(&client->lockClient);\n        }\n        if (rc != 0) {\n            wm_SemUnlock(&client->lockSend);\n            return rc; /* Error locking client */\n        }\n    #endif\n\n        /* Send register packet */\n        rc = MqttPacket_Write(client, client->tx_buf, len);\n    #ifdef WOLFMQTT_MULTITHREAD\n        wm_SemUnlock(&client->lockSend);\n    #endif\n        if (rc != len) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (wm_SemLock(&client->lockClient) == 0) {\n                MqttClient_RespList_Remove(client, &regist->pendResp);\n                wm_SemUnlock(&client->lockClient);\n            }\n        #endif\n            return rc;\n        }\n\n        regist->stat = MQTT_MSG_WAIT;\n    }\n\n    /* Wait for register acknowledge packet */\n    rc = SN_Client_WaitType(client, &regist->regack,\n            SN_MSG_TYPE_REGACK, regist->packet_id, client->cmd_timeout_ms);\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc == MQTT_CODE_CONTINUE)\n        return rc;\n#endif\n#ifdef WOLFMQTT_MULTITHREAD\n    if (wm_SemLock(&client->lockClient) == 0) {\n        MqttClient_RespList_Remove(client, &regist->pendResp);\n        wm_SemUnlock(&client->lockClient);\n    }\n#endif\n\n    /* reset state */\n    regist->stat = MQTT_MSG_BEGIN;\n\n    return rc;\n}\n\nint SN_Client_Ping(MqttClient *client, SN_PingReq *ping)\n{\n    int rc, len;\n    SN_PingReq loc_ping;\n\n    /* Validate required arguments */\n    if (client == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    if (ping == NULL) {\n        XMEMSET(&loc_ping, 0, sizeof(SN_PingReq));\n        ping = &loc_ping;\n    }\n\n    if (ping->stat == MQTT_MSG_BEGIN) {\n    #ifdef WOLFMQTT_MULTITHREAD\n        /* Lock send socket mutex */\n        rc = wm_SemLock(&client->lockSend);\n        if (rc != 0) {\n            return rc;\n        }\n    #endif\n\n        /* Encode the ping packet as a request */\n        rc = SN_Encode_Ping(client->tx_buf, client->tx_buf_len, ping,\n                SN_MSG_TYPE_PING_REQ);\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d)\",\n            rc, SN_Packet_TypeDesc(SN_MSG_TYPE_PING_REQ),\n            SN_MSG_TYPE_PING_REQ);\n    #endif\n        if (rc <= 0) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            wm_SemUnlock(&client->lockSend);\n        #endif\n            return rc;\n        }\n        len = rc;\n\n    #ifdef WOLFMQTT_MULTITHREAD\n        rc = wm_SemLock(&client->lockClient);\n        if (rc == 0) {\n            /* inform other threads of expected response */\n            rc = MqttClient_RespList_Add(client,\n                    (MqttPacketType)SN_MSG_TYPE_PING_RESP, 0,\n                    &ping->pendResp, NULL);\n            wm_SemUnlock(&client->lockClient);\n        }\n        if (rc != 0) {\n            wm_SemUnlock(&client->lockSend);\n            return rc; /* Error locking client */\n        }\n    #endif\n\n        /* Send ping req packet */\n        rc = MqttPacket_Write(client, client->tx_buf, len);\n    #ifdef WOLFMQTT_MULTITHREAD\n        wm_SemUnlock(&client->lockSend);\n    #endif\n        if (rc != len) {\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (wm_SemLock(&client->lockClient) == 0) {\n                MqttClient_RespList_Remove(client, &ping->pendResp);\n                wm_SemUnlock(&client->lockClient);\n            }\n        #endif\n            return rc;\n        }\n\n        ping->stat = MQTT_MSG_WAIT;\n    }\n\n    /* Wait for ping resp packet */\n    rc = SN_Client_WaitType(client, ping,\n            SN_MSG_TYPE_PING_RESP, 0, client->cmd_timeout_ms);\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc == MQTT_CODE_CONTINUE)\n        return rc;\n#endif\n#ifdef WOLFMQTT_MULTITHREAD\n    if (wm_SemLock(&client->lockClient) == 0) {\n        MqttClient_RespList_Remove(client, &ping->pendResp);\n        wm_SemUnlock(&client->lockClient);\n    }\n#endif\n\n    /* reset state */\n    ping->stat = MQTT_MSG_BEGIN;\n\n    return rc;\n}\n\nint SN_Client_Disconnect(MqttClient *client)\n{\n    return SN_Client_Disconnect_ex(client, NULL);\n}\n\nint SN_Client_Disconnect_ex(MqttClient *client, SN_Disconnect *disconnect)\n{\n    int rc, len;\n\n    /* Validate required arguments */\n    if (client == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n#ifdef WOLFMQTT_MULTITHREAD\n    /* Lock send socket mutex */\n    rc = wm_SemLock(&client->lockSend);\n    if (rc != 0) {\n        return rc;\n    }\n#endif\n\n    /* Encode the disconnect packet */\n    rc = SN_Encode_Disconnect(client->tx_buf, client->tx_buf_len, disconnect);\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d)\",\n        rc, SN_Packet_TypeDesc(SN_MSG_TYPE_DISCONNECT),\n        SN_MSG_TYPE_DISCONNECT);\n#endif\n    if (rc <= 0) {\n    #ifdef WOLFMQTT_MULTITHREAD\n        wm_SemUnlock(&client->lockSend);\n    #endif\n        return rc;\n    }\n    len = rc;\n\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if ((disconnect != NULL) && (disconnect->sleepTmr != 0)) {\n        rc = wm_SemLock(&client->lockClient);\n        if (rc == 0) {\n            /* inform other threads of expected response */\n            rc = MqttClient_RespList_Add(client,\n                    (MqttPacketType)SN_MSG_TYPE_DISCONNECT, 0,\n                    &disconnect->pendResp, NULL);\n            wm_SemUnlock(&client->lockClient);\n        }\n        if (rc != 0) {\n            wm_SemUnlock(&client->lockSend);\n            return rc; /* Error locking client */\n        }\n    }\n#endif\n\n    /* Send disconnect packet */\n    rc = MqttPacket_Write(client, client->tx_buf, len);\n#ifdef WOLFMQTT_MULTITHREAD\n    wm_SemUnlock(&client->lockSend);\n#endif\n    if (rc != len) {\n    #ifdef WOLFMQTT_MULTITHREAD\n        if (wm_SemLock(&client->lockClient) == 0) {\n            MqttClient_RespList_Remove(client, &disconnect->pendResp);\n            wm_SemUnlock(&client->lockClient);\n        }\n    #endif\n        return rc;\n    }\n    else {\n        rc = MQTT_CODE_SUCCESS;\n    }\n\n    /* If sleep was set, wait for response disconnect packet */\n    if ((disconnect != NULL) && (disconnect->sleepTmr != 0)) {\n        rc = SN_Client_WaitType(client, disconnect,\n                SN_MSG_TYPE_DISCONNECT, 0, client->cmd_timeout_ms);\n    #ifdef WOLFMQTT_NONBLOCK\n        if (rc == MQTT_CODE_CONTINUE)\n            return rc;\n    #endif\n    #ifdef WOLFMQTT_MULTITHREAD\n        if (wm_SemLock(&client->lockClient) == 0) {\n            MqttClient_RespList_Remove(client, &disconnect->pendResp);\n            wm_SemUnlock(&client->lockClient);\n        }\n    #endif\n    }\n\n    return rc;\n}\n\nint SN_Client_WaitMessage_ex(MqttClient *client, SN_Object* packet_obj,\n        int timeout_ms)\n{\n    return SN_Client_WaitType(client, packet_obj,\n        SN_MSG_TYPE_ANY, 0, timeout_ms);\n}\n\nint SN_Client_WaitMessage(MqttClient *client, int timeout_ms)\n{\n    if (client == NULL)\n        return MQTT_CODE_ERROR_BAD_ARG;\n    return SN_Client_WaitMessage_ex(client, &client->msgSN, timeout_ms);\n}\n\n#endif /* defined WOLFMQTT_SN */\n"], "filenames": ["src/mqtt_client.c"], "buggy_code_start_loc": [909], "buggy_code_end_loc": [911], "fixing_code_start_loc": [909], "fixing_code_end_loc": [912], "type": "CWE-787", "message": "wolfSSL wolfMQTT 1.9 has a heap-based buffer overflow (4 bytes) in MqttDecode_Publish (called from MqttClient_DecodePacket and MqttClient_HandlePacket).", "other": {"cve": {"id": "CVE-2021-45932", "sourceIdentifier": "cve@mitre.org", "published": "2022-01-01T01:15:08.527", "lastModified": "2022-01-11T21:11:53.800", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "wolfSSL wolfMQTT 1.9 has a heap-based buffer overflow (4 bytes) in MqttDecode_Publish (called from MqttClient_DecodePacket and MqttClient_HandlePacket)."}, {"lang": "es", "value": "wolfSSL wolfMQTT versi\u00f3n 1.9, presenta un desbordamiento de b\u00fafer en la regi\u00f3n heap de la memoria (4 bytes) en la funci\u00f3n MqttDecode_Publish (llamado desde MqttClient_DecodePacket y MqttClient_HandlePacket).\n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:wolfssl:wolfmqtt:1.9:*:*:*:*:*:*:*", "matchCriteriaId": "9C97B577-1823-49CD-84CE-9B7D7B04AE4F"}]}]}], "references": [{"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=37866", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/google/oss-fuzz-vulns/blob/main/vulns/wolfmqtt/OSV-2021-1188.yaml", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/wolfSSL/wolfMQTT/commit/84d4b53122e0fa0280c7872350b89d5777dabbb2", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/wolfSSL/wolfMQTT/commit/84d4b53122e0fa0280c7872350b89d5777dabbb2"}}