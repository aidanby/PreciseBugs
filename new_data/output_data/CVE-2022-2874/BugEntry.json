{"buggy_code": ["\" Test various aspects of the Vim9 script language.\n\nsource check.vim\nsource term_util.vim\nimport './vim9.vim' as v9\nsource screendump.vim\nsource shared.vim\n\ndef Test_vim9script_feature()\n  # example from the help, here the feature is always present\n  var lines =<< trim END\n      \" old style comment\n      if !has('vim9script')\n        \" legacy commands would go here\n        finish\n      endif\n      vim9script\n      # Vim9 script commands go here\n      g:didit = true\n  END\n  v9.CheckScriptSuccess(lines)\n  assert_equal(true, g:didit)\n  unlet g:didit\nenddef\n\ndef Test_range_only()\n  new\n  setline(1, ['blah', 'Blah'])\n  :/Blah/\n  assert_equal(2, getcurpos()[1])\n  bwipe!\n\n  # without range commands use current line\n  new\n  setline(1, ['one', 'two', 'three'])\n  :2\n  print\n  assert_equal('two', g:Screenline(&lines))\n  :3\n  list\n  assert_equal('three$', g:Screenline(&lines))\n\n  # missing command does not print the line\n  var lines =<< trim END\n    vim9script\n    :1|\n    assert_equal('three$', g:Screenline(&lines))\n    :|\n    assert_equal('three$', g:Screenline(&lines))\n  END\n  v9.CheckScriptSuccess(lines)\n\n  bwipe!\n\n  lines =<< trim END\n      set cpo+=-\n      :1,999\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E16:', 2)\n  set cpo&vim\n\n  v9.CheckDefExecAndScriptFailure([\":'x\"], 'E20:', 1)\n\n  # won't generate anything\n  if false\n    :123\n  endif\nenddef\n\ndef Test_invalid_range()\n  var lines =<< trim END\n      :123 eval 1 + 2\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E481:', 1)\n\n  lines =<< trim END\n      :123 if true\n      endif\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E481:', 1)\n\n  lines =<< trim END\n      :123 echo 'yes'\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E481:', 1)\n\n  lines =<< trim END\n      :123 cd there\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E481:', 1)\nenddef\n\nlet g:alist = [7]\nlet g:astring = 'text'\nlet g:anumber = 123\n\ndef Test_delfunction()\n  # Check function is defined in script namespace\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'func CheckMe()',\n      '  return 123',\n      'endfunc',\n      'func DoTest()',\n      '  call assert_equal(123, s:CheckMe())',\n      'endfunc',\n      'DoTest()',\n      ])\n\n  # Check function in script namespace cannot be deleted\n  v9.CheckScriptFailure([\n      'vim9script',\n      'func DeleteMe1()',\n      'endfunc',\n      'delfunction DeleteMe1',\n      ], 'E1084:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'func DeleteMe2()',\n      'endfunc',\n      'def DoThat()',\n      '  delfunction DeleteMe2',\n      'enddef',\n      'DoThat()',\n      ], 'E1084:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'def DeleteMe3()',\n      'enddef',\n      'delfunction DeleteMe3',\n      ], 'E1084:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'def DeleteMe4()',\n      'enddef',\n      'def DoThat()',\n      '  delfunction DeleteMe4',\n      'enddef',\n      'DoThat()',\n      ], 'E1084:')\n\n  # Check that global :def function can be replaced and deleted\n  var lines =<< trim END\n      vim9script\n      def g:Global(): string\n        return \"yes\"\n      enddef\n      assert_equal(\"yes\", g:Global())\n      def! g:Global(): string\n        return \"no\"\n      enddef\n      assert_equal(\"no\", g:Global())\n      delfunc g:Global\n      assert_false(exists('*g:Global'))\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # Check that global function can be replaced by a :def function and deleted\n  lines =<< trim END\n      vim9script\n      func g:Global()\n        return \"yes\"\n      endfunc\n      assert_equal(\"yes\", g:Global())\n      def! g:Global(): string\n        return \"no\"\n      enddef\n      assert_equal(\"no\", g:Global())\n      delfunc g:Global\n      assert_false(exists('*g:Global'))\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # Check that global :def function can be replaced by a function and deleted\n  lines =<< trim END\n      vim9script\n      def g:Global(): string\n        return \"yes\"\n      enddef\n      assert_equal(\"yes\", g:Global())\n      func! g:Global()\n        return \"no\"\n      endfunc\n      assert_equal(\"no\", g:Global())\n      delfunc g:Global\n      assert_false(exists('*g:Global'))\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_wrong_type()\n  v9.CheckDefFailure(['var name: list<nothing>'], 'E1010:')\n  v9.CheckDefFailure(['var name: list<list<nothing>>'], 'E1010:')\n  v9.CheckDefFailure(['var name: dict<nothing>'], 'E1010:')\n  v9.CheckDefFailure(['var name: dict<dict<nothing>>'], 'E1010:')\n\n  v9.CheckDefFailure(['var name: dict<number'], 'E1009:')\n  v9.CheckDefFailure(['var name: dict<list<number>'], 'E1009:')\n\n  v9.CheckDefFailure(['var name: ally'], 'E1010:')\n  v9.CheckDefFailure(['var name: bram'], 'E1010:')\n  v9.CheckDefFailure(['var name: cathy'], 'E1010:')\n  v9.CheckDefFailure(['var name: dom'], 'E1010:')\n  v9.CheckDefFailure(['var name: freddy'], 'E1010:')\n  v9.CheckDefFailure(['var name: john'], 'E1010:')\n  v9.CheckDefFailure(['var name: larry'], 'E1010:')\n  v9.CheckDefFailure(['var name: ned'], 'E1010:')\n  v9.CheckDefFailure(['var name: pam'], 'E1010:')\n  v9.CheckDefFailure(['var name: sam'], 'E1010:')\n  v9.CheckDefFailure(['var name: vim'], 'E1010:')\n\n  v9.CheckDefFailure(['var Ref: number', 'Ref()'], 'E1085:')\n  v9.CheckDefFailure(['var Ref: string', 'var res = Ref()'], 'E1085:')\nenddef\n\ndef Test_script_namespace()\n  # defining a function or variable with s: is not allowed\n  var lines =<< trim END\n      vim9script\n      def s:Function()\n      enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1268:')\n\n  for decl in ['var', 'const', 'final']\n    lines =<< trim END\n        vim9script\n        var s:var = 'var'\n    END\n    v9.CheckScriptFailure([\n        'vim9script',\n        decl .. ' s:var = \"var\"',\n        ], 'E1268:')\n  endfor\n\n  # Calling a function or using a variable with s: is not allowed at script\n  # level\n  lines =<< trim END\n      vim9script\n      def Function()\n      enddef\n      s:Function()\n  END\n  v9.CheckScriptFailure(lines, 'E1268:')\n  lines =<< trim END\n      vim9script\n      def Function()\n      enddef\n      call s:Function()\n  END\n  v9.CheckScriptFailure(lines, 'E1268:')\n  lines =<< trim END\n      vim9script\n      var var = 'var'\n      echo s:var\n  END\n  v9.CheckScriptFailure(lines, 'E1268:')\nenddef\n\ndef Test_script_wrong_type()\n  var lines =<< trim END\n      vim9script\n      var dict: dict<string>\n      dict['a'] = ['x']\n  END\n  v9.CheckScriptFailure(lines, 'E1012: Type mismatch; expected string but got list<string>', 3)\nenddef\n\ndef Test_const()\n  v9.CheckDefFailure(['final name = 234', 'name = 99'], 'E1018:')\n  v9.CheckDefFailure(['final one = 234', 'var one = 99'], 'E1017:')\n  v9.CheckDefFailure(['final list = [1, 2]', 'var list = [3, 4]'], 'E1017:')\n  v9.CheckDefFailure(['final two'], 'E1125:')\n  v9.CheckDefFailure(['final &option'], 'E996:')\n\n  var lines =<< trim END\n    final list = [1, 2, 3]\n    list[0] = 4\n    list->assert_equal([4, 2, 3])\n    const other = [5, 6, 7]\n    other->assert_equal([5, 6, 7])\n\n    var varlist = [7, 8]\n    const constlist = [1, varlist, 3]\n    varlist[0] = 77\n    constlist[1][1] = 88\n    var cl = constlist[1]\n    cl[1] = 88\n    constlist->assert_equal([1, [77, 88], 3])\n\n    var vardict = {five: 5, six: 6}\n    const constdict = {one: 1, two: vardict, three: 3}\n    vardict['five'] = 55\n    constdict['two']['six'] = 66\n    var cd = constdict['two']\n    cd['six'] = 66\n    constdict->assert_equal({one: 1, two: {five: 55, six: 66}, three: 3})\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_const_bang()\n  var lines =<< trim END\n      const var = 234\n      var = 99\n  END\n  v9.CheckDefExecFailure(lines, 'E1018:', 2)\n  v9.CheckScriptFailure(['vim9script'] + lines, 'E46:', 3)\n\n  lines =<< trim END\n      const ll = [2, 3, 4]\n      ll[0] = 99\n  END\n  v9.CheckDefExecFailure(lines, 'E1119:', 2)\n  v9.CheckScriptFailure(['vim9script'] + lines, 'E741:', 3)\n\n  lines =<< trim END\n      const ll = [2, 3, 4]\n      ll[3] = 99\n  END\n  v9.CheckDefExecFailure(lines, 'E1118:', 2)\n  v9.CheckScriptFailure(['vim9script'] + lines, 'E684:', 3)\n\n  lines =<< trim END\n      const dd = {one: 1, two: 2}\n      dd[\"one\"] = 99\n  END\n  v9.CheckDefExecFailure(lines, 'E1121:', 2)\n  v9.CheckScriptFailure(['vim9script'] + lines, 'E741:', 3)\n\n  lines =<< trim END\n      const dd = {one: 1, two: 2}\n      dd[\"three\"] = 99\n  END\n  v9.CheckDefExecFailure(lines, 'E1120:')\n  v9.CheckScriptFailure(['vim9script'] + lines, 'E741:', 3)\nenddef\n\ndef Test_range_no_colon()\n  v9.CheckDefFailure(['%s/a/b/'], 'E1050:')\n  v9.CheckDefFailure(['+ s/a/b/'], 'E1050:')\n  v9.CheckDefFailure(['- s/a/b/'], 'E1050:')\n  v9.CheckDefFailure(['. s/a/b/'], 'E1050:')\nenddef\n\n\ndef Test_block()\n  var outer = 1\n  {\n    var inner = 2\n    assert_equal(1, outer)\n    assert_equal(2, inner)\n  }\n  assert_equal(1, outer)\n\n  {|echo 'yes'|}\nenddef\n\ndef Test_block_failure()\n  v9.CheckDefFailure(['{', 'var inner = 1', '}', 'echo inner'], 'E1001:')\n  v9.CheckDefFailure(['}'], 'E1025:')\n  v9.CheckDefFailure(['{', 'echo 1'], 'E1026:')\nenddef\n\ndef Test_block_local_vars()\n  var lines =<< trim END\n      vim9script\n      v:testing = 1\n      if true\n        var text = ['hello']\n        def SayHello(): list<string>\n          return text\n        enddef\n        def SetText(v: string)\n          text = [v]\n        enddef\n      endif\n\n      if true\n        var text = ['again']\n        def SayAgain(): list<string>\n          return text\n        enddef\n      endif\n\n      # test that the \"text\" variables are not cleaned up\n      test_garbagecollect_now()\n\n      defcompile\n\n      assert_equal(['hello'], SayHello())\n      assert_equal(['again'], SayAgain())\n\n      SetText('foobar')\n      assert_equal(['foobar'], SayHello())\n\n      call writefile(['ok'], 'Xdidit')\n      qall!\n  END\n\n  # need to execute this with a separate Vim instance to avoid the current\n  # context gets garbage collected.\n  writefile(lines, 'Xscript')\n  g:RunVim([], [], '-S Xscript')\n  assert_equal(['ok'], readfile('Xdidit'))\n\n  delete('Xscript')\n  delete('Xdidit')\nenddef\n\ndef Test_block_local_vars_with_func()\n  var lines =<< trim END\n      vim9script\n      if true\n        var foo = 'foo'\n        if true\n          var bar = 'bar'\n          def Func(): list<string>\n            return [foo, bar]\n          enddef\n        endif\n      endif\n      # function is compiled here, after blocks have finished, can still access\n      # \"foo\" and \"bar\"\n      assert_equal(['foo', 'bar'], Func())\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\n\" legacy func for command that's defined later\nfunc s:InvokeSomeCommand()\n  SomeCommand\nendfunc\n\ndef Test_autocommand_block()\n  com SomeCommand {\n      g:someVar = 'some'\n    }\n  InvokeSomeCommand()\n  assert_equal('some', g:someVar)\n\n  delcommand SomeCommand\n  unlet g:someVar\nenddef\n\ndef Test_command_block()\n  au BufNew *.xml {\n      g:otherVar = 'other'\n    }\n  split other.xml\n  assert_equal('other', g:otherVar)\n\n  bwipe!\n  au! BufNew *.xml\n  unlet g:otherVar\nenddef\n\nfunc g:NoSuchFunc()\n  echo 'none'\nendfunc\n\ndef Test_try_catch_throw()\n  var l = []\n  try # comment\n    add(l, '1')\n    throw 'wrong'\n    add(l, '2')\n  catch # comment\n    add(l, v:exception)\n  finally # comment\n    add(l, '3')\n  endtry # comment\n  assert_equal(['1', 'wrong', '3'], l)\n\n  l = []\n  try\n    try\n      add(l, '1')\n      throw 'wrong'\n      add(l, '2')\n    catch /right/\n      add(l, v:exception)\n    endtry\n  catch /wrong/\n    add(l, 'caught')\n  finally\n    add(l, 'finally')\n  endtry\n  assert_equal(['1', 'caught', 'finally'], l)\n\n  var n: number\n  try\n    n = l[3]\n  catch /E684:/\n    n = 99\n  endtry\n  assert_equal(99, n)\n\n  var done = 'no'\n  if 0\n    try | catch | endtry\n  else\n    done = 'yes'\n  endif\n  assert_equal('yes', done)\n\n  done = 'no'\n  if 1\n    done = 'yes'\n  else\n    try | catch | endtry\n    done = 'never'\n  endif\n  assert_equal('yes', done)\n\n  if 1\n  else\n    try | catch /pat/ | endtry\n    try | catch /pat/ \n    endtry\n    try \n    catch /pat/ | endtry\n    try \n    catch /pat/ \n    endtry\n  endif\n\n  try\n    # string slice returns a string, not a number\n    n = g:astring[3]\n  catch /E1012:/\n    n = 77\n  endtry\n  assert_equal(77, n)\n\n  try\n    n = l[g:astring]\n  catch /E1012:/\n    n = 88\n  endtry\n  assert_equal(88, n)\n\n  try\n    n = s:does_not_exist\n  catch /E121:/\n    n = 111\n  endtry\n  assert_equal(111, n)\n\n  try\n    n = g:does_not_exist\n  catch /E121:/\n    n = 121\n  endtry\n  assert_equal(121, n)\n\n  var d = {one: 1}\n  try\n    n = d[g:astring]\n  catch /E716:/\n    n = 222\n  endtry\n  assert_equal(222, n)\n\n  try\n    n = -g:astring\n  catch /E1012:/\n    n = 233\n  endtry\n  assert_equal(233, n)\n\n  try\n    n = +g:astring\n  catch /E1012:/\n    n = 244\n  endtry\n  assert_equal(244, n)\n\n  try\n    n = +g:alist\n  catch /E1012:/\n    n = 255\n  endtry\n  assert_equal(255, n)\n\n  var nd: dict<any>\n  try\n    nd = {[g:alist]: 1}\n  catch /E1105:/\n    n = 266\n  endtry\n  assert_equal(266, n)\n\n  l = [1, 2, 3] \n  try\n    [n] = l\n  catch /E1093:/\n    n = 277\n  endtry\n  assert_equal(277, n)\n\n  try\n    &ts = g:astring\n  catch /E1012:/\n    n = 288\n  endtry\n  assert_equal(288, n)\n\n  try\n    &backspace = 'asdf'\n  catch /E474:/\n    n = 299\n  endtry\n  assert_equal(299, n)\n\n  l = [1]\n  try\n    l[3] = 3\n  catch /E684:/\n    n = 300\n  endtry\n  assert_equal(300, n)\n\n  try\n    unlet g:does_not_exist\n  catch /E108:/\n    n = 322\n  endtry\n  assert_equal(322, n)\n\n  try\n    d = {text: 1, [g:astring]: 2}\n  catch /E721:/\n    n = 333\n  endtry\n  assert_equal(333, n)\n\n  try\n    l = g:DeletedFunc()\n  catch /E933:/\n    n = 344\n  endtry\n  assert_equal(344, n)\n\n  try\n    echo range(1, 2, 0)\n  catch /E726:/\n    n = 355\n  endtry\n  assert_equal(355, n)\n\n  var P = function('g:NoSuchFunc')\n  delfunc g:NoSuchFunc\n  try\n    echo P()\n  catch /E117:/\n    n = 366\n  endtry\n  assert_equal(366, n)\n\n  try\n    echo g:NoSuchFunc()\n  catch /E117:/\n    n = 377\n  endtry\n  assert_equal(377, n)\n\n  try\n    echo g:alist + 4\n  catch /E745:/\n    n = 388\n  endtry\n  assert_equal(388, n)\n\n  try\n    echo 4 + g:alist\n  catch /E745:/\n    n = 399\n  endtry\n  assert_equal(399, n)\n\n  try\n    echo g:alist.member\n  catch /E715:/\n    n = 400\n  endtry\n  assert_equal(400, n)\n\n  try\n    echo d.member\n  catch /E716:/\n    n = 411\n  endtry\n  assert_equal(411, n)\n\n  var counter = 0\n  for i in range(4)\n    try\n      eval [][0]\n    catch\n    endtry\n    counter += 1\n  endfor\n  assert_equal(4, counter)\n\n  # no requirement for spaces before |\n  try|echo 0|catch|endtry\n\n  # return in try with finally\n  def ReturnInTry(): number\n    var ret = 4\n    try\n      return ret\n    catch /this/\n      return -1\n    catch /that/\n      return -1\n    finally\n      # changing ret has no effect\n      ret = 7\n    endtry\n    return -2\n  enddef\n  assert_equal(4, ReturnInTry())\n\n  # return in catch with finally\n  def ReturnInCatch(): number\n    var ret = 5\n    try\n      throw 'getout'\n      return -1\n    catch /getout/\n      # ret is evaluated here\n      return ret\n    finally\n      # changing ret later has no effect\n      ret = -3\n    endtry\n    return -2\n  enddef\n  assert_equal(5, ReturnInCatch())\n\n  # return in finally after empty catch\n  def ReturnInFinally(): number\n    try\n    finally\n      return 6\n    endtry\n  enddef\n  assert_equal(6, ReturnInFinally())\n\n  var lines =<< trim END\n      vim9script\n      try\n        acos('0.5')\n          ->setline(1)\n      catch\n        g:caught = v:exception\n      endtry\n  END\n  v9.CheckScriptSuccess(lines)\n  assert_match('E1219: Float or Number required for argument 1', g:caught)\n  unlet g:caught\n\n  # missing catch and/or finally\n  lines =<< trim END\n      vim9script\n      try\n        echo 'something'\n      endtry\n  END\n  v9.CheckScriptFailure(lines, 'E1032:')\n\n  # skipping try-finally-endtry when try-finally-endtry is used in another block\n  lines =<< trim END\n      if v:true\n        try\n        finally\n        endtry\n      else\n        try\n        finally\n        endtry\n      endif\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_try_var_decl()\n  var lines =<< trim END\n      vim9script\n      try\n        var in_try = 1\n        assert_equal(1, get(s:, 'in_try', -1))\n        throw \"getout\"\n      catch\n        var in_catch = 2\n        assert_equal(-1, get(s:, 'in_try', -1))\n        assert_equal(2, get(s:, 'in_catch', -1))\n      finally\n        var in_finally = 3\n        assert_equal(-1, get(s:, 'in_try', -1))\n        assert_equal(-1, get(s:, 'in_catch', -1))\n        assert_equal(3, get(s:, 'in_finally', -1))\n      endtry\n      assert_equal(-1, get(s:, 'in_try', -1))\n      assert_equal(-1, get(s:, 'in_catch', -1))\n      assert_equal(-1, get(s:, 'in_finally', -1))\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_try_ends_in_return()\n  var lines =<< trim END\n      vim9script\n      def Foo(): string\n        try\n          return 'foo'\n        catch\n          return 'caught'\n        endtry\n      enddef\n      assert_equal('foo', Foo())\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Foo(): string\n        try\n          return 'foo'\n        catch\n          return 'caught'\n        endtry\n        echo 'notreached'\n      enddef\n      assert_equal('foo', Foo())\n  END\n  v9.CheckScriptFailure(lines, 'E1095:')\n\n  lines =<< trim END\n      vim9script\n      def Foo(): string\n        try\n          return 'foo'\n        catch /x/\n          return 'caught'\n        endtry\n      enddef\n      assert_equal('foo', Foo())\n  END\n  v9.CheckScriptFailure(lines, 'E1027:')\n\n  lines =<< trim END\n      vim9script\n      def Foo(): string\n        try\n          echo 'foo'\n        catch\n          echo 'caught'\n        finally\n          return 'done'\n        endtry\n      enddef\n      assert_equal('done', Foo())\n  END\n  v9.CheckScriptSuccess(lines)\n\nenddef\n\ndef Test_try_in_catch()\n  var lines =<< trim END\n      vim9script\n      var seq = []\n      def DoIt()\n        try\n          seq->add('throw 1')\n          eval [][0]\n          seq->add('notreached')\n        catch\n          seq->add('catch')\n          try\n            seq->add('throw 2')\n            eval [][0]\n            seq->add('notreached')\n          catch /nothing/\n            seq->add('notreached')\n          endtry\n          seq->add('done')\n        endtry\n      enddef\n      DoIt()\n      assert_equal(['throw 1', 'catch', 'throw 2', 'done'], seq)\n  END\nenddef\n\ndef Test_error_in_catch()\n  var lines =<< trim END\n      try\n        eval [][0]\n      catch /E684:/\n        eval [][0]\n      endtry\n  END\n  v9.CheckDefExecFailure(lines, 'E684:', 4)\nenddef\n\n\" :while at the very start of a function that :continue jumps to\ndef s:TryContinueFunc()\n while g:Count < 2\n   g:sequence ..= 't'\n    try\n      echoerr 'Test'\n    catch\n      g:Count += 1\n      g:sequence ..= 'c'\n      continue\n    endtry\n    g:sequence ..= 'e'\n    g:Count += 1\n  endwhile\nenddef\n\ndef Test_continue_in_try_in_while()\n  g:Count = 0\n  g:sequence = ''\n  TryContinueFunc()\n  assert_equal('tctc', g:sequence)\n  unlet g:Count\n  unlet g:sequence\nenddef\n\ndef Test_break_in_try_in_for()\n  var lines =<< trim END\n      vim9script\n      def Ls(): list<string>\n        var ls: list<string>\n        for s in ['abc', 'def']\n          for _ in [123, 456]\n            try\n              eval [][0]\n            catch\n              break\n            endtry\n          endfor\n          ls += [s]\n        endfor\n        return ls\n      enddef\n      assert_equal(['abc', 'def'], Ls())\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_nocatch_return_in_try()\n  # return in try block returns normally\n  def ReturnInTry(): string\n    try\n      return '\"some message\"'\n    catch\n    endtry\n    return 'not reached'\n  enddef\n  exe 'echoerr ' .. ReturnInTry()\nenddef\n\ndef Test_cnext_works_in_catch()\n  var lines =<< trim END\n      vim9script\n      au BufEnter * eval 1 + 2\n      writefile(['text'], 'Xfile1')\n      writefile(['text'], 'Xfile2')\n      var items = [\n          {lnum: 1, filename: 'Xfile1', valid: true},\n          {lnum: 1, filename: 'Xfile2', valid: true}\n        ]\n      setqflist([], ' ', {items: items})\n      cwindow\n\n      def CnextOrCfirst()\n        # if cnext fails, cfirst is used\n        try\n          cnext\n        catch\n          cfirst\n        endtry\n      enddef\n\n      CnextOrCfirst()\n      CnextOrCfirst()\n      writefile([getqflist({idx: 0}).idx], 'Xresult')\n      qall\n  END\n  writefile(lines, 'XCatchCnext')\n  g:RunVim([], [], '--clean -S XCatchCnext')\n  assert_equal(['1'], readfile('Xresult'))\n\n  delete('Xfile1')\n  delete('Xfile2')\n  delete('XCatchCnext')\n  delete('Xresult')\nenddef\n\ndef Test_throw_skipped()\n  if 0\n    throw dontgethere\n  endif\nenddef\n\ndef Test_nocatch_throw_silenced()\n  var lines =<< trim END\n    vim9script\n    def Func()\n      throw 'error'\n    enddef\n    silent! Func()\n  END\n  writefile(lines, 'XthrowSilenced')\n  source XthrowSilenced\n  delete('XthrowSilenced')\nenddef\n\ndef DeletedFunc(): list<any>\n  return ['delete me']\nenddef\ndefcompile\ndelfunc DeletedFunc\n\ndef s:ThrowFromDef()\n  throw \"getout\" # comment\nenddef\n\nfunc s:CatchInFunc()\n  try\n    call s:ThrowFromDef()\n  catch\n    let g:thrown_func = v:exception\n  endtry\nendfunc\n\ndef s:CatchInDef()\n  try\n    ThrowFromDef()\n  catch\n    g:thrown_def = v:exception\n  endtry\nenddef\n\ndef s:ReturnFinally(): string\n  try\n    return 'intry'\n  finally\n    g:in_finally = 'finally'\n  endtry\n  return 'end'\nenddef\n\ndef Test_try_catch_nested()\n  CatchInFunc()\n  assert_equal('getout', g:thrown_func)\n\n  CatchInDef()\n  assert_equal('getout', g:thrown_def)\n\n  assert_equal('intry', ReturnFinally())\n  assert_equal('finally', g:in_finally)\n\n  var l = []\n  try\n    l->add('1')\n    throw 'bad'\n    l->add('x')\n  catch /bad/\n    l->add('2')\n    try\n      l->add('3')\n      throw 'one'\n      l->add('x')\n    catch /one/\n      l->add('4')\n      try\n        l->add('5')\n        throw 'more'\n        l->add('x')\n      catch /more/\n        l->add('6')\n      endtry\n    endtry\n  endtry\n  assert_equal(['1', '2', '3', '4', '5', '6'], l)\n\n  l = []\n  try\n    try\n      l->add('1')\n      throw 'foo'\n      l->add('x')\n    catch\n      l->add('2')\n      throw 'bar'\n      l->add('x')\n    finally\n      l->add('3')\n    endtry\n    l->add('x')\n  catch /bar/\n    l->add('4')\n  endtry\n  assert_equal(['1', '2', '3', '4'], l)\nenddef\n\ndef s:TryOne(): number\n  try\n    return 0\n  catch\n  endtry\n  return 0\nenddef\n\ndef s:TryTwo(n: number): string\n  try\n    var x = {}\n  catch\n  endtry\n  return 'text'\nenddef\n\ndef Test_try_catch_twice()\n  assert_equal('text', TryOne()->TryTwo())\nenddef\n\ndef Test_try_catch_match()\n  var seq = 'a'\n  try\n    throw 'something'\n  catch /nothing/\n    seq ..= 'x'\n  catch /some/\n    seq ..= 'b'\n  catch /asdf/\n    seq ..= 'x'\n  catch ?a\\?sdf?\n    seq ..= 'y'\n  finally\n    seq ..= 'c'\n  endtry\n  assert_equal('abc', seq)\nenddef\n\ndef Test_try_catch_fails()\n  v9.CheckDefFailure(['catch'], 'E603:')\n  v9.CheckDefFailure(['try', 'echo 0', 'catch', 'catch'], 'E1033:')\n  v9.CheckDefFailure(['try', 'echo 0', 'catch /pat'], 'E1067:')\n  v9.CheckDefFailure(['finally'], 'E606:')\n  v9.CheckDefFailure(['try', 'echo 0', 'finally', 'echo 1', 'finally'], 'E607:')\n  v9.CheckDefFailure(['endtry'], 'E602:')\n  v9.CheckDefFailure(['while 1', 'endtry'], 'E170:')\n  v9.CheckDefFailure(['for i in range(5)', 'endtry'], 'E170:')\n  v9.CheckDefFailure(['if 1', 'endtry'], 'E171:')\n  v9.CheckDefFailure(['try', 'echo 1', 'endtry'], 'E1032:')\n\n  v9.CheckDefFailure(['throw'], 'E1143:')\n  v9.CheckDefFailure(['throw xxx'], 'E1001:')\nenddef\n\ndef Try_catch_skipped()\n  var l = []\n  try\n  finally\n  endtry\n\n  if 1\n  else\n    try\n    endtry\n  endif\nenddef\n\n\" The skipped try/endtry was updating the wrong instruction.\ndef Test_try_catch_skipped()\n  var instr = execute('disassemble Try_catch_skipped')\n  assert_match(\"NEWLIST size 0\\n\", instr)\nenddef\n\ndef Test_throw_line_number()\n  def Func()\n    eval 1 + 1\n    eval 2 + 2\n    throw 'exception'\n  enddef\n  try\n    Func()\n  catch /exception/\n    assert_match('line 3', v:throwpoint)\n  endtry\nenddef\n\n\ndef Test_throw_vimscript()\n  # only checks line continuation\n  var lines =<< trim END\n      vim9script\n      try\n        throw 'one'\n              .. 'two'\n      catch\n        assert_equal('onetwo', v:exception)\n      endtry\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    @r = ''\n    def Func()\n      throw @r\n    enddef\n    var result = ''\n    try\n      Func()\n    catch /E1129:/\n      result = 'caught'\n    endtry\n    assert_equal('caught', result)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_error_in_nested_function()\n  # an error in a nested :function aborts executing in the calling :def function\n  var lines =<< trim END\n      vim9script\n      def Func()\n        Error()\n        g:test_var = 1\n      enddef\n      func Error() abort\n        eval [][0]\n      endfunc\n      Func()\n  END\n  g:test_var = 0\n  v9.CheckScriptFailure(lines, 'E684:')\n  assert_equal(0, g:test_var)\nenddef\n\ndef Test_abort_after_error()\n  var lines =<< trim END\n      vim9script\n      while true\n        echo notfound\n      endwhile\n      g:gotthere = true\n  END\n  g:gotthere = false\n  v9.CheckScriptFailure(lines, 'E121:')\n  assert_false(g:gotthere)\n  unlet g:gotthere\nenddef\n\ndef Test_cexpr_vimscript()\n  # only checks line continuation\n  set errorformat=File\\ %f\\ line\\ %l\n  var lines =<< trim END\n      vim9script\n      cexpr 'File'\n                .. ' someFile' ..\n                   ' line 19'\n      assert_equal(19, getqflist()[0].lnum)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def CexprFail()\n        au QuickfixCmdPre * echo g:doesnotexist\n        cexpr 'File otherFile line 99'\n        g:didContinue = 'yes'\n      enddef\n      CexprFail()\n      g:didContinue = 'also'\n  END\n  g:didContinue = 'no'\n  v9.CheckScriptFailure(lines, 'E121: Undefined variable: g:doesnotexist')\n  assert_equal('no', g:didContinue)\n  au! QuickfixCmdPre\n\n  lines =<< trim END\n      vim9script\n      def CexprFail()\n        cexpr g:aNumber\n        g:didContinue = 'yes'\n      enddef\n      CexprFail()\n      g:didContinue = 'also'\n  END\n  g:aNumber = 123\n  g:didContinue = 'no'\n  v9.CheckScriptFailure(lines, 'E777: String or List expected')\n  assert_equal('no', g:didContinue)\n  unlet g:didContinue\n\n  set errorformat&\nenddef\n\ndef Test_statusline_syntax()\n  # legacy syntax is used for 'statusline'\n  var lines =<< trim END\n      vim9script\n      func g:Status()\n        return '%{\"x\" is# \"x\"}'\n      endfunc\n      set laststatus=2 statusline=%!Status()\n      redrawstatus\n      set laststatus statusline= \n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_list_vimscript()\n  # checks line continuation and comments\n  var lines =<< trim END\n      vim9script\n      var mylist = [\n            'one',\n            # comment\n            'two', # empty line follows\n\n            'three',\n            ]\n      assert_equal(['one', 'two', 'three'], mylist)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # check all lines from heredoc are kept\n  lines =<< trim END\n      # comment 1\n      two\n      # comment 3\n\n      five\n      # comment 6\n  END\n  assert_equal(['# comment 1', 'two', '# comment 3', '', 'five', '# comment 6'], lines)\n\n  lines =<< trim END\n    [{\n      a: 0}]->string()->assert_equal(\"[{'a': 0}]\")\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\nif has('channel')\n  let someJob = test_null_job()\n\n  def FuncWithError()\n    echomsg g:someJob\n  enddef\n\n  func Test_convert_emsg_to_exception()\n    try\n      call FuncWithError()\n    catch\n      call assert_match('Vim:E908:', v:exception)\n    endtry\n  endfunc\nendif\n\ndef Test_vim9script_mix()\n  var lines =<< trim END\n    if has(g:feature)\n      \" legacy script\n      let g:legacy = 1\n      finish\n    endif\n    vim9script\n    g:legacy = 0\n  END\n  g:feature = 'eval'\n  g:legacy = -1\n  v9.CheckScriptSuccess(lines)\n  assert_equal(1, g:legacy)\n\n  g:feature = 'noteval'\n  g:legacy = -1\n  v9.CheckScriptSuccess(lines)\n  assert_equal(0, g:legacy)\nenddef\n\ndef Test_vim9script_fails()\n  v9.CheckScriptFailure(['scriptversion 2', 'vim9script'], 'E1039:')\n  v9.CheckScriptFailure(['vim9script', 'scriptversion 2'], 'E1040:')\n\n  v9.CheckScriptFailure(['vim9script', 'var str: string', 'str = 1234'], 'E1012:')\n  v9.CheckScriptFailure(['vim9script', 'const str = \"asdf\"', 'str = \"xxx\"'], 'E46:')\n\n  assert_fails('vim9script', 'E1038:')\n  v9.CheckDefFailure(['vim9script'], 'E1038:')\n\n  # no error when skipping\n  if has('nothing')\n    vim9script\n  endif\nenddef\n\ndef Test_script_var_shadows_function()\n  var lines =<< trim END\n      vim9script\n      def Func(): number\n        return 123\n      enddef\n      var Func = 1\n  END\n  v9.CheckScriptFailure(lines, 'E1041:', 5)\nenddef\n\ndef Test_function_shadows_script_var()\n  var lines =<< trim END\n      vim9script\n      var Func = 1\n      def Func(): number\n        return 123\n      enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1041:', 3)\nenddef\n\ndef Test_script_var_shadows_command()\n  var lines =<< trim END\n      var undo = 1\n      undo = 2\n      assert_equal(2, undo)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var undo = 1\n      undo\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1207:', 2)\nenddef\n\ndef Test_vim9script_call_wrong_type()\n  var lines =<< trim END\n      vim9script\n      var Time = 'localtime'\n      Time()\n  END\n  v9.CheckScriptFailure(lines, 'E1085:')\nenddef\n\ndef Test_vim9script_reload_delfunc()\n  var first_lines =<< trim END\n    vim9script\n    def FuncYes(): string\n      return 'yes'\n    enddef\n  END\n  var withno_lines =<< trim END\n    def FuncNo(): string\n      return 'no'\n    enddef\n    def g:DoCheck(no_exists: bool)\n      assert_equal('yes', FuncYes())\n      assert_equal('no', FuncNo())\n    enddef\n  END\n  var nono_lines =<< trim END\n    def g:DoCheck(no_exists: bool)\n      assert_equal('yes', FuncYes())\n      assert_fails('FuncNo()', 'E117:', '', 2, 'DoCheck')\n    enddef\n  END\n\n  # FuncNo() is defined\n  writefile(first_lines + withno_lines, 'Xreloaded.vim')\n  source Xreloaded.vim\n  g:DoCheck(true)\n\n  # FuncNo() is not redefined\n  writefile(first_lines + nono_lines, 'Xreloaded.vim')\n  source Xreloaded.vim\n  g:DoCheck(false)\n\n  # FuncNo() is back\n  writefile(first_lines + withno_lines, 'Xreloaded.vim')\n  source Xreloaded.vim\n  g:DoCheck(false)\n\n  delete('Xreloaded.vim')\nenddef\n\ndef Test_vim9script_reload_delvar()\n  # write the script with a script-local variable\n  var lines =<< trim END\n    vim9script\n    var name = 'string'\n  END\n  writefile(lines, 'XreloadVar.vim')\n  source XreloadVar.vim\n\n  # now write the script using the same variable locally - works\n  lines =<< trim END\n    vim9script\n    def Func()\n      var name = 'string'\n    enddef\n  END\n  writefile(lines, 'XreloadVar.vim')\n  source XreloadVar.vim\n\n  delete('XreloadVar.vim')\nenddef\n\ndef Test_func_redefine_error()\n  var lines = [\n        'vim9script',\n        'def Func()',\n        '  eval [][0]',\n        'enddef',\n        'Func()',\n        ]\n  writefile(lines, 'Xtestscript.vim')\n\n  for count in range(3)\n    try\n      source Xtestscript.vim\n    catch /E684/\n      # function name should contain <SNR> every time\n      assert_match('E684: List index out of range', v:exception)\n      assert_match('function <SNR>\\d\\+_Func, line 1', v:throwpoint)\n    endtry\n  endfor\n\n  delete('Xtestscript.vim')\nenddef\n\ndef Test_func_redefine_fails()\n  var lines =<< trim END\n    vim9script\n    def Func()\n      echo 'one'\n    enddef\n    def Func()\n      echo 'two'\n    enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1073:')\n\n  lines =<< trim END\n    vim9script\n    def Foo(): string\n      return 'foo'\n    enddef\n    def Func()\n      var  Foo = {-> 'lambda'}\n    enddef\n    defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1073:')\nenddef\n\ndef Test_fixed_size_list()\n  # will be allocated as one piece of memory, check that changes work\n  var l = [1, 2, 3, 4]\n  l->remove(0)\n  l->add(5)\n  l->insert(99, 1)\n  assert_equal([2, 99, 3, 4, 5], l)\nenddef\n\ndef Test_no_insert_xit()\n  v9.CheckDefExecFailure(['a = 1'], 'E1100:')\n  v9.CheckDefExecFailure(['c = 1'], 'E1100:')\n  v9.CheckDefExecFailure(['i = 1'], 'E1100:')\n  v9.CheckDefExecFailure(['t = 1'], 'E1100:')\n  v9.CheckDefExecFailure(['x = 1'], 'E1100:')\n\n  v9.CheckScriptFailure(['vim9script', 'a = 1'], 'E488:')\n  v9.CheckScriptFailure(['vim9script', 'a'], 'E1100:')\n  v9.CheckScriptFailure(['vim9script', 'c = 1'], 'E488:')\n  v9.CheckScriptFailure(['vim9script', 'c'], 'E1100:')\n  v9.CheckScriptFailure(['vim9script', 'i = 1'], 'E488:')\n  v9.CheckScriptFailure(['vim9script', 'i'], 'E1100:')\n  v9.CheckScriptFailure(['vim9script', 'o = 1'], 'E1100:')\n  v9.CheckScriptFailure(['vim9script', 'o'], 'E1100:')\n  v9.CheckScriptFailure(['vim9script', 't'], 'E1100:')\n  v9.CheckScriptFailure(['vim9script', 't = 1'], 'E1100:')\n  v9.CheckScriptFailure(['vim9script', 'x = 1'], 'E1100:')\nenddef\n\ndef s:IfElse(what: number): string\n  var res = ''\n  if what == 1\n    res = \"one\"\n  elseif what == 2\n    res = \"two\"\n  else\n    res = \"three\"\n  endif\n  return res\nenddef\n\ndef Test_if_elseif_else()\n  assert_equal('one', IfElse(1))\n  assert_equal('two', IfElse(2))\n  assert_equal('three', IfElse(3))\nenddef\n\ndef Test_if_elseif_else_fails()\n  v9.CheckDefFailure(['elseif true'], 'E582:')\n  v9.CheckDefFailure(['else'], 'E581:')\n  v9.CheckDefFailure(['endif'], 'E580:')\n  v9.CheckDefFailure(['if g:abool', 'elseif xxx'], 'E1001:')\n  v9.CheckDefFailure(['if true', 'echo 1'], 'E171:')\n\n  var lines =<< trim END\n      var s = ''\n      if s = ''\n      endif\n  END\n  v9.CheckDefFailure(lines, 'E488:')\n\n  lines =<< trim END\n      var s = ''\n      if s == ''\n      elseif s = ''\n      endif\n  END\n  v9.CheckDefFailure(lines, 'E488:')\n\n  lines =<< trim END\n      var cond = true\n      if cond\n        echo 'true'\n      elseif\n        echo 'false'\n      endif\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E1143:', 'E15:'], 4)\nenddef\n\ndef Test_if_else_func_using_var()\n  var lines =<< trim END\n      vim9script\n\n      const debug = true\n      if debug\n        var mode_chars = 'something'\n        def Bits2Ascii()\n          var x = mode_chars\n          g:where = 'in true'\n        enddef\n      else\n        def Bits2Ascii()\n          g:where = 'in false'\n        enddef\n      endif\n\n      Bits2Ascii()\n  END\n  v9.CheckScriptSuccess(lines)\n  assert_equal('in true', g:where)\n  unlet g:where\n\n  lines =<< trim END\n      vim9script\n\n      const debug = false\n      if debug\n        var mode_chars = 'something'\n        def Bits2Ascii()\n          g:where = 'in true'\n        enddef\n      else\n        def Bits2Ascii()\n          var x = mode_chars\n          g:where = 'in false'\n        enddef\n      endif\n\n      Bits2Ascii()\n  END\n  v9.CheckScriptFailure(lines, 'E1001: Variable not found: mode_chars')\nenddef\n\nlet g:bool_true = v:true\nlet g:bool_false = v:false\n\ndef Test_if_const_expr()\n  var res = false\n  if true ? true : false\n    res = true\n  endif\n  assert_equal(true, res)\n\n  g:glob = 2\n  if false\n    execute('g:glob = 3')\n  endif\n  assert_equal(2, g:glob)\n  if true\n    execute('g:glob = 3')\n  endif\n  assert_equal(3, g:glob)\n\n  res = false\n  if g:bool_true ? true : false\n    res = true\n  endif\n  assert_equal(true, res)\n\n  res = false\n  if true ? g:bool_true : false\n    res = true\n  endif\n  assert_equal(true, res)\n\n  res = false\n  if true ? true : g:bool_false\n    res = true\n  endif\n  assert_equal(true, res)\n\n  res = false\n  if true ? false : true\n    res = true\n  endif\n  assert_equal(false, res)\n\n  res = false\n  if false ? false : true\n    res = true\n  endif\n  assert_equal(true, res)\n\n  res = false\n  if false ? true : false\n    res = true\n  endif\n  assert_equal(false, res)\n\n  res = false\n  if has('xyz') ? true : false\n    res = true\n  endif\n  assert_equal(false, res)\n\n  res = false\n  if true && true\n    res = true\n  endif\n  assert_equal(true, res)\n\n  res = false\n  if true && false\n    res = true\n  endif\n  assert_equal(false, res)\n\n  res = false\n  if g:bool_true && false\n    res = true\n  endif\n  assert_equal(false, res)\n\n  res = false\n  if true && g:bool_false\n    res = true\n  endif\n  assert_equal(false, res)\n\n  res = false\n  if false && false\n    res = true\n  endif\n  assert_equal(false, res)\n\n  res = false\n  if true || false\n    res = true\n  endif\n  assert_equal(true, res)\n\n  res = false\n  if g:bool_true || false\n    res = true\n  endif\n  assert_equal(true, res)\n\n  res = false\n  if true || g:bool_false\n    res = true\n  endif\n  assert_equal(true, res)\n\n  res = false\n  if false || false\n    res = true\n  endif\n  assert_equal(false, res)\n\n  # with constant \"false\" expression may be invalid so long as the syntax is OK\n  if false | eval 1 + 2 | endif\n  if false | eval burp + 234 | endif\n  if false | echo burp 234 'asd' | endif\n  if false\n    burp\n  endif\n\n  if 0\n    if 1\n      echo nothing\n    elseif 1\n      echo still nothing\n    endif\n  endif\n\n  # expression with line breaks skipped\n  if false\n      ('aaa'\n      .. 'bbb'\n      .. 'ccc'\n      )->setline(1)\n  endif\nenddef\n\ndef Test_if_const_expr_fails()\n  v9.CheckDefFailure(['if \"aaa\" == \"bbb'], 'E114:')\n  v9.CheckDefFailure([\"if 'aaa' == 'bbb\"], 'E115:')\n  v9.CheckDefFailure([\"if has('aaa'\"], 'E110:')\n  v9.CheckDefFailure([\"if has('aaa') ? true false\"], 'E109:')\nenddef\n\ndef s:RunNested(i: number): number\n  var x: number = 0\n  if i % 2\n    if 1\n      # comment\n    else\n      # comment\n    endif\n    x += 1\n  else\n    x += 1000\n  endif\n  return x\nenddef\n\ndef Test_nested_if()\n  assert_equal(1, RunNested(1))\n  assert_equal(1000, RunNested(2))\nenddef\n\ndef Test_execute_cmd()\n  # missing argument is ignored\n  execute\n  execute # comment\n\n  new\n  setline(1, 'default')\n  execute 'setline(1, \"execute-string\")'\n  assert_equal('execute-string', getline(1))\n\n  execute \"setline(1, 'execute-string')\"\n  assert_equal('execute-string', getline(1))\n\n  var cmd1 = 'setline(1,'\n  var cmd2 = '\"execute-var\")'\n  execute cmd1 cmd2 # comment\n  assert_equal('execute-var', getline(1))\n\n  execute cmd1 cmd2 '|setline(1, \"execute-var-string\")'\n  assert_equal('execute-var-string', getline(1))\n\n  var cmd_first = 'call '\n  var cmd_last = 'setline(1, \"execute-var-var\")'\n  execute cmd_first .. cmd_last\n  assert_equal('execute-var-var', getline(1))\n  bwipe!\n\n  var n = true\n  execute 'echomsg' (n ? '\"true\"' : '\"no\"')\n  assert_match('^true$', g:Screenline(&lines))\n\n  echomsg [1, 2, 3] {a: 1, b: 2}\n  assert_match('^\\[1, 2, 3\\] {''a'': 1, ''b'': 2}$', g:Screenline(&lines))\n\n  v9.CheckDefFailure(['execute xxx'], 'E1001:', 1)\n  v9.CheckDefExecFailure(['execute \"tabnext \" .. 8'], 'E475:', 1)\n  v9.CheckDefFailure(['execute \"cmd\"# comment'], 'E488:', 1)\n  if has('channel')\n    v9.CheckDefExecFailure(['execute test_null_channel()'], 'E908:', 1)\n  endif\nenddef\n\ndef Test_execute_cmd_vimscript()\n  # only checks line continuation\n  var lines =<< trim END\n      vim9script\n      execute 'g:someVar'\n                .. ' = ' ..\n                   '28'\n      assert_equal(28, g:someVar)\n      unlet g:someVar\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_execute_finish()\n  # the empty lines are relevant here\n  var lines =<< trim END\n      vim9script\n\n      var vname = \"g:hello\"\n\n      if exists(vname) | finish | endif | execute vname '= \"world\"'\n\n      assert_equal('world', g:hello)\n\n      if exists(vname) | finish | endif | execute vname '= \"world\"'\n\n      assert_report('should not be reached')\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_echo_cmd()\n  echo 'some' # comment\n  echon 'thing'\n  assert_match('^something$', g:Screenline(&lines))\n\n  echo \"some\" # comment\n  echon \"thing\"\n  assert_match('^something$', g:Screenline(&lines))\n\n  var str1 = 'some'\n  var str2 = 'more'\n  echo str1 str2\n  assert_match('^some more$', g:Screenline(&lines))\n\n  echo \"one\\ntwo\"\n  assert_match('^one$', g:Screenline(&lines - 1))\n  assert_match('^two$', g:Screenline(&lines))\n\n  v9.CheckDefFailure(['echo \"xxx\"# comment'], 'E488:')\nenddef\n\ndef Test_echomsg_cmd()\n  echomsg 'some' 'more' # comment\n  assert_match('^some more$', g:Screenline(&lines))\n  echo 'clear'\n  :1messages\n  assert_match('^some more$', g:Screenline(&lines))\n\n  v9.CheckDefFailure(['echomsg \"xxx\"# comment'], 'E488:')\nenddef\n\ndef Test_echomsg_cmd_vimscript()\n  # only checks line continuation\n  var lines =<< trim END\n      vim9script\n      echomsg 'here'\n                .. ' is ' ..\n                   'a message'\n      assert_match('^here is a message$', g:Screenline(&lines))\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_echoerr_cmd()\n  var local = 'local'\n  try\n    echoerr 'something' local 'wrong' # comment\n  catch\n    assert_match('something local wrong', v:exception)\n  endtry\nenddef\n\ndef Test_echoerr_cmd_vimscript()\n  # only checks line continuation\n  var lines =<< trim END\n      vim9script\n      try\n        echoerr 'this'\n                .. ' is ' ..\n                   'wrong'\n      catch\n        assert_match('this is wrong', v:exception)\n      endtry\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_echoconsole_cmd()\n  var local = 'local'\n  echoconsole 'something' local # comment\n  # output goes anywhere\nenddef\n\ndef Test_for_outside_of_function()\n  var lines =<< trim END\n    vim9script\n    new\n    for var in range(0, 3)\n      append(line('$'), var)\n    endfor\n    assert_equal(['', '0', '1', '2', '3'], getline(1, '$'))\n    bwipe!\n\n    var result = ''\n    for i in [1, 2, 3]\n      var loop = ' loop ' .. i\n      result ..= loop\n    endfor\n    assert_equal(' loop 1 loop 2 loop 3', result)\n  END\n  writefile(lines, 'Xvim9for.vim')\n  source Xvim9for.vim\n  delete('Xvim9for.vim')\nenddef\n\ndef Test_for_skipped_block()\n  # test skipped blocks at outside of function\n  var lines =<< trim END\n    var result = []\n    if true\n      for n in [1, 2]\n        result += [n]\n      endfor\n    else\n      for n in [3, 4]\n        result += [n]\n      endfor\n    endif\n    assert_equal([1, 2], result)\n\n    result = []\n    if false\n      for n in [1, 2]\n        result += [n]\n      endfor\n    else\n      for n in [3, 4]\n        result += [n]\n      endfor\n    endif\n    assert_equal([3, 4], result)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  # test skipped blocks at inside of function\n  lines =<< trim END\n    def DefTrue()\n      var result = []\n      if true\n        for n in [1, 2]\n          result += [n]\n        endfor\n      else\n        for n in [3, 4]\n          result += [n]\n        endfor\n      endif\n      assert_equal([1, 2], result)\n    enddef\n    DefTrue()\n\n    def DefFalse()\n      var result = []\n      if false\n        for n in [1, 2]\n          result += [n]\n        endfor\n      else\n        for n in [3, 4]\n          result += [n]\n        endfor\n      endif\n      assert_equal([3, 4], result)\n    enddef\n    DefFalse()\n\n    def BuildDiagrams()\n      var diagrams: list<any>\n      if false\n        var max = 0\n        for v in diagrams\n          var l = 3\n          if max < l | max = l | endif\n          v->add(l)\n        endfor\n      endif\n    enddef\n    BuildDiagrams()\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_for_loop()\n  var lines =<< trim END\n      var result = ''\n      for cnt in range(7)\n        if cnt == 4\n          break\n        endif\n        if cnt == 2\n          continue\n        endif\n        result ..= cnt .. '_'\n      endfor\n      assert_equal('0_1_3_', result)\n\n      var concat = ''\n      for str in eval('[\"one\", \"two\"]')\n        concat ..= str\n      endfor\n      assert_equal('onetwo', concat)\n\n      var total = 0\n      for nr in\n          [1, 2, 3]\n        total += nr\n      endfor\n      assert_equal(6, total)\n\n      total = 0\n      for nr\n        in [1, 2, 3]\n        total += nr\n      endfor\n      assert_equal(6, total)\n\n      total = 0\n      for nr\n        in\n        [1, 2, 3]\n        total += nr\n      endfor\n      assert_equal(6, total)\n\n      # with type\n      total = 0\n      for n: number in [1, 2, 3]\n        total += n\n      endfor\n      assert_equal(6, total)\n\n      total = 0\n      for b in 0z010203\n        total += b\n      endfor\n      assert_equal(6, total)\n\n      var chars = ''\n      for s: string in 'foobar'\n        chars ..= s\n      endfor\n      assert_equal('foobar', chars)\n\n      chars = ''\n      for x: string in {a: 'a', b: 'b'}->values()\n        chars ..= x\n      endfor\n      assert_equal('ab', chars)\n\n      # unpack with type\n      var res = ''\n      for [n: number, s: string] in [[1, 'a'], [2, 'b']]\n        res ..= n .. s\n      endfor\n      assert_equal('1a2b', res)\n\n      # unpack with one var\n      var reslist = []\n      for [x] in [['aaa'], ['bbb']]\n        reslist->add(x)\n      endfor\n      assert_equal(['aaa', 'bbb'], reslist)\n\n      # loop over string\n      res = ''\n      for c in 'a\u00e9c\u0300d'\n        res ..= c .. '-'\n      endfor\n      assert_equal('a-\u00e9-c\u0300-d-', res)\n\n      res = ''\n      for c in ''\n        res ..= c .. '-'\n      endfor\n      assert_equal('', res)\n\n      res = ''\n      for c in test_null_string()\n        res ..= c .. '-'\n      endfor\n      assert_equal('', res)\n\n      total = 0\n      for c in null_list\n        total += 1\n      endfor\n      assert_equal(0, total)\n\n      for c in null_blob\n        total += 1\n      endfor\n      assert_equal(0, total)\n\n      var foo: list<dict<any>> = [\n              {a: 'Cat'}\n            ]\n      for dd in foo\n        dd.counter = 12\n      endfor\n      assert_equal([{a: 'Cat', counter: 12}], foo)\n\n      reslist = []\n      for _ in range(3)\n        reslist->add('x')\n      endfor\n      assert_equal(['x', 'x', 'x'], reslist)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_for_loop_with_closure()\n  var lines =<< trim END\n      var flist: list<func>\n      for i in range(5)\n        var inloop = i\n        flist[i] = () => inloop\n      endfor\n      for i in range(5)\n        assert_equal(4, flist[i]())\n      endfor\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var flist: list<func>\n      for i in range(5)\n        var inloop = i\n        flist[i] = () => {\n              return inloop\n            }\n      endfor\n      for i in range(5)\n        assert_equal(4, flist[i]())\n      endfor\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_for_loop_fails()\n  v9.CheckDefAndScriptFailure(['for '], ['E1097:', 'E690:'])\n  v9.CheckDefAndScriptFailure(['for x'], ['E1097:', 'E690:'])\n  v9.CheckDefAndScriptFailure(['for x in'], ['E1097:', 'E15:'])\n  v9.CheckDefAndScriptFailure(['for # in range(5)'], 'E690:')\n  v9.CheckDefAndScriptFailure(['for i In range(5)'], 'E690:')\n  v9.CheckDefAndScriptFailure(['var x = 5', 'for x in range(5)', 'endfor'], ['E1017:', 'E1041:'])\n  v9.CheckScriptFailure(['vim9script', 'var x = 5', 'for x in range(5)', '# comment', 'endfor'], 'E1041:', 3)\n  v9.CheckScriptFailure(['def Func(arg: any)', 'for arg in range(5)', 'enddef', 'defcompile'], 'E1006:')\n  delfunc! g:Func\n  v9.CheckDefFailure(['for i in xxx'], 'E1001:')\n  v9.CheckDefFailure(['endfor'], 'E588:')\n  v9.CheckDefFailure(['for i in range(3)', 'echo 3'], 'E170:')\n\n  # wrong type detected at compile time\n  v9.CheckDefFailure(['for i in {a: 1}', 'echo 3', 'endfor'], 'E1177: For loop on dict not supported')\n\n  # wrong type detected at runtime\n  g:adict = {a: 1}\n  v9.CheckDefExecFailure(['for i in g:adict', 'echo 3', 'endfor'], 'E1177: For loop on dict not supported')\n  unlet g:adict\n\n  var lines =<< trim END\n      var d: list<dict<any>> = [{a: 0}]\n      for e in d\n        e = {a: 0, b: ''}\n      endfor\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E1018:', 'E46:'], 3)\n\n  lines =<< trim END\n      for nr: number in ['foo']\n      endfor\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1012: Type mismatch; expected number but got string', 1)\n\n  lines =<< trim END\n      for n : number in [1, 2]\n        echo n\n      endfor\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1059:', 1)\n\n  lines =<< trim END\n      var d: dict<number> = {a: 1, b: 2}\n      for [k: job, v: job] in d->items()\n        echo k v\n      endfor\n  END\n  v9.CheckDefExecAndScriptFailure(lines, ['E1163: Variable 1: type mismatch, expected job but got string', 'E1012: Type mismatch; expected job but got string'], 2)\n\n  lines =<< trim END\n      var i = 0\n      for i in [1, 2, 3]\n        echo i\n      endfor\n  END\n  v9.CheckDefExecAndScriptFailure(lines, ['E1017:', 'E1041:'])\n\n  lines =<< trim END\n      var l = [0]\n      for l[0] in [1, 2, 3]\n        echo l[0]\n      endfor\n  END\n  v9.CheckDefExecAndScriptFailure(lines, ['E461:', 'E1017:'])\n\n  lines =<< trim END\n      var d = {x: 0}\n      for d.x in [1, 2, 3]\n        echo d.x\n      endfor\n  END\n  v9.CheckDefExecAndScriptFailure(lines, ['E461:', 'E1017:'])\n\n  lines =<< trim END\n      var l: list<dict<any>> = [{a: 1, b: 'x'}]\n      for item: dict<number> in l\n        echo item\n      endfor\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1012: Type mismatch; expected dict<number> but got dict<any>')\n\n  lines =<< trim END\n      var l: list<dict<any>> = [{n: 1}]\n      for item: dict<number> in l\n        item->extend({s: ''})\n      endfor\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1013: Argument 2: type mismatch, expected dict<number> but got dict<string>')\nenddef\n\ndef Test_for_loop_script_var()\n  # cannot use s:var in a :def function\n  v9.CheckDefFailure(['for s:var in range(3)', 'echo 3'], 'E1254:')\n\n  # can use s:var in Vim9 script, with or without s:\n  var lines =<< trim END\n    vim9script\n    var total = 0\n    for s:var in [1, 2, 3]\n      total += s:var\n    endfor\n    assert_equal(6, total)\n\n    total = 0\n    for var in [1, 2, 3]\n      total += var\n    endfor\n    assert_equal(6, total)\n  END\nenddef\n\ndef Test_for_loop_unpack()\n  var lines =<< trim END\n      var result = []\n      for [v1, v2] in [[1, 2], [3, 4]]\n        result->add(v1)\n        result->add(v2)\n      endfor\n      assert_equal([1, 2, 3, 4], result)\n\n      result = []\n      for [v1, v2; v3] in [[1, 2], [3, 4, 5, 6]]\n        result->add(v1)\n        result->add(v2)\n        result->add(v3)\n      endfor\n      assert_equal([1, 2, [], 3, 4, [5, 6]], result)\n\n      result = []\n      for [&ts, &sw] in [[1, 2], [3, 4]]\n        result->add(&ts)\n        result->add(&sw)\n      endfor\n      assert_equal([1, 2, 3, 4], result)\n\n      var slist: list<string>\n      for [$LOOPVAR, @r, v:errmsg] in [['a', 'b', 'c'], ['d', 'e', 'f']]\n        slist->add($LOOPVAR)\n        slist->add(@r)\n        slist->add(v:errmsg)\n      endfor\n      assert_equal(['a', 'b', 'c', 'd', 'e', 'f'], slist)\n\n      slist = []\n      for [g:globalvar, b:bufvar, w:winvar, t:tabvar] in [['global', 'buf', 'win', 'tab'], ['1', '2', '3', '4']]\n        slist->add(g:globalvar)\n        slist->add(b:bufvar)\n        slist->add(w:winvar)\n        slist->add(t:tabvar)\n      endfor\n      assert_equal(['global', 'buf', 'win', 'tab', '1', '2', '3', '4'], slist)\n      unlet! g:globalvar b:bufvar w:winvar t:tabvar\n\n      var res = []\n      for [_, n, _] in [[1, 2, 3], [4, 5, 6]]\n        res->add(n)\n      endfor\n      assert_equal([2, 5], res)\n\n      var text: list<string> = [\"hello there\", \"goodbye now\"]\n      var splitted = ''\n      for [first; next] in mapnew(text, (i, v) => split(v))\n          splitted ..= string(first) .. string(next) .. '/'\n      endfor\n      assert_equal(\"'hello'['there']/'goodbye'['now']/\", splitted)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      for [v1, v2] in [[1, 2, 3], [3, 4]]\n        echo v1 v2\n      endfor\n  END\n  v9.CheckDefExecFailure(lines, 'E710:', 1)\n\n  lines =<< trim END\n      for [v1, v2] in [[1], [3, 4]]\n        echo v1 v2\n      endfor\n  END\n  v9.CheckDefExecFailure(lines, 'E711:', 1)\n\n  lines =<< trim END\n      for [v1, v1] in [[1, 2], [3, 4]]\n        echo v1\n      endfor\n  END\n  v9.CheckDefExecFailure(lines, 'E1017:', 1)\n\n  lines =<< trim END\n      for [a, b] in g:listlist\n        echo a\n      endfor\n  END\n  g:listlist = [1, 2, 3]\n  v9.CheckDefExecFailure(lines, 'E1140:', 1)\nenddef\n\ndef Test_for_loop_with_try_continue()\n  var lines =<< trim END\n      var looped = 0\n      var cleanup = 0\n      for i in range(3)\n        looped += 1\n        try\n          eval [][0]\n        catch\n          continue\n        finally\n          cleanup += 1\n        endtry\n      endfor\n      assert_equal(3, looped)\n      assert_equal(3, cleanup)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_while_skipped_block()\n  # test skipped blocks at outside of function\n  var lines =<< trim END\n    var result = []\n    var n = 0\n    if true\n      n = 1\n      while n < 3\n        result += [n]\n        n += 1\n      endwhile\n    else\n      n = 3\n      while n < 5\n        result += [n]\n        n += 1\n      endwhile\n    endif\n    assert_equal([1, 2], result)\n\n    result = []\n    if false\n      n = 1\n      while n < 3\n        result += [n]\n        n += 1\n      endwhile\n    else\n      n = 3\n      while n < 5\n        result += [n]\n        n += 1\n      endwhile\n    endif\n    assert_equal([3, 4], result)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  # test skipped blocks at inside of function\n  lines =<< trim END\n    def DefTrue()\n      var result = []\n      var n = 0\n      if true\n        n = 1\n        while n < 3\n          result += [n]\n          n += 1\n        endwhile\n      else\n        n = 3\n        while n < 5\n          result += [n]\n          n += 1\n        endwhile\n      endif\n      assert_equal([1, 2], result)\n    enddef\n    DefTrue()\n\n    def DefFalse()\n      var result = []\n      var n = 0\n      if false\n        n = 1\n        while n < 3\n          result += [n]\n          n += 1\n        endwhile\n      else\n        n = 3\n        while n < 5\n          result += [n]\n          n += 1\n        endwhile\n      endif\n      assert_equal([3, 4], result)\n    enddef\n    DefFalse()\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_while_loop()\n  var result = ''\n  var cnt = 0\n  while cnt < 555\n    if cnt == 3\n      break\n    endif\n    cnt += 1\n    if cnt == 2\n      continue\n    endif\n    result ..= cnt .. '_'\n  endwhile\n  assert_equal('1_3_', result)\n\n  var s = ''\n  while s == 'x' # {comment}\n  endwhile\nenddef\n\ndef Test_while_loop_in_script()\n  var lines =<< trim END\n      vim9script\n      var result = ''\n      var cnt = 0\n      while cnt < 3\n        var s = 'v' .. cnt\n        result ..= s\n        cnt += 1\n      endwhile\n      assert_equal('v0v1v2', result)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_while_loop_fails()\n  v9.CheckDefFailure(['while xxx'], 'E1001:')\n  v9.CheckDefFailure(['endwhile'], 'E588:')\n  v9.CheckDefFailure(['continue'], 'E586:')\n  v9.CheckDefFailure(['if true', 'continue'], 'E586:')\n  v9.CheckDefFailure(['break'], 'E587:')\n  v9.CheckDefFailure(['if true', 'break'], 'E587:')\n  v9.CheckDefFailure(['while 1', 'echo 3'], 'E170:')\n\n  var lines =<< trim END\n      var s = ''\n      while s = ''\n      endwhile\n  END\n  v9.CheckDefFailure(lines, 'E488:')\nenddef\n\ndef Test_interrupt_loop()\n  var caught = false\n  var x = 0\n  try\n    while 1\n      x += 1\n      if x == 100\n        feedkeys(\"\\<C-C>\", 'Lt')\n      endif\n    endwhile\n  catch\n    caught = true\n    assert_equal(100, x)\n  endtry\n  assert_true(caught, 'should have caught an exception')\n  # consume the CTRL-C\n  getchar(0)\nenddef\n\ndef Test_automatic_line_continuation()\n  var mylist = [\n      'one',\n      'two',\n      'three',\n      ] # comment\n  assert_equal(['one', 'two', 'three'], mylist)\n\n  var mydict = {\n      ['one']: 1,\n      ['two']: 2,\n      ['three']:\n          3,\n      } # comment\n  assert_equal({one: 1, two: 2, three: 3}, mydict)\n  mydict = {\n      one: 1,  # comment\n      two:     # comment\n           2,  # comment\n      three: 3 # comment\n      }\n  assert_equal({one: 1, two: 2, three: 3}, mydict)\n  mydict = {\n      one: 1, \n      two: \n           2, \n      three: 3 \n      }\n  assert_equal({one: 1, two: 2, three: 3}, mydict)\n\n  assert_equal(\n        ['one', 'two', 'three'],\n        split('one two three')\n        )\nenddef\n\ndef Test_vim9_comment()\n  v9.CheckScriptSuccess([\n      'vim9script',\n      '# something',\n      '#something',\n      '#{{something',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      '#{something',\n      ], 'E1170:')\n\n  split Xfile\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'edit #something',\n      ])\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'edit #{something',\n      ])\n  close\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      ':# something',\n      ], 'E488:')\n  v9.CheckScriptFailure([\n      '# something',\n      ], 'E488:')\n  v9.CheckScriptFailure([\n      ':# something',\n      ], 'E488:')\n\n  { # block start\n  } # block end\n  v9.CheckDefFailure([\n      '{# comment',\n      ], 'E488:')\n  v9.CheckDefFailure([\n      '{',\n      '}# comment',\n      ], 'E488:')\n\n  echo \"yes\" # comment\n  v9.CheckDefFailure([\n      'echo \"yes\"# comment',\n      ], 'E488:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'echo \"yes\" # something',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'echo \"yes\"# something',\n      ], 'E121:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'echo# something',\n      ], 'E1144:')\n  v9.CheckScriptFailure([\n      'echo \"yes\" # something',\n      ], 'E121:')\n\n  exe \"echo\" # comment\n  v9.CheckDefFailure([\n      'exe \"echo\"# comment',\n      ], 'E488:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'exe \"echo\" # something',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'exe \"echo\"# something',\n      ], 'E121:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'exe# something',\n      ], 'E1144:')\n  v9.CheckScriptFailure([\n      'exe \"echo\" # something',\n      ], 'E121:')\n\n  v9.CheckDefFailure([\n      'try# comment',\n      '  echo \"yes\"',\n      'catch',\n      'endtry',\n      ], 'E1144:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'try# comment',\n      'echo \"yes\"',\n      ], 'E1144:')\n  v9.CheckDefFailure([\n      'try',\n      '  throw#comment',\n      'catch',\n      'endtry',\n      ], 'E1144:')\n  v9.CheckDefFailure([\n      'try',\n      '  throw \"yes\"#comment',\n      'catch',\n      'endtry',\n      ], 'E488:')\n  v9.CheckDefFailure([\n      'try',\n      '  echo \"yes\"',\n      'catch# comment',\n      'endtry',\n      ], 'E1144:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'try',\n      '  echo \"yes\"',\n      'catch# comment',\n      'endtry',\n      ], 'E1144:')\n  v9.CheckDefFailure([\n      'try',\n      '  echo \"yes\"',\n      'catch /pat/# comment',\n      'endtry',\n      ], 'E488:')\n  v9.CheckDefFailure([\n      'try',\n      'echo \"yes\"',\n      'catch',\n      'endtry# comment',\n      ], 'E1144:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'try',\n      '  echo \"yes\"',\n      'catch',\n      'endtry# comment',\n      ], 'E1144:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'hi # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'hi# comment',\n      ], 'E1144:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'hi Search # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'hi Search# comment',\n      ], 'E416:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'hi link This Search # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'hi link This That# comment',\n      ], 'E413:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'hi clear This # comment',\n      'hi clear # comment',\n      ])\n  # not tested, because it doesn't give an error but a warning:\n  # hi clear This# comment',\n  v9.CheckScriptFailure([\n      'vim9script',\n      'hi clear# comment',\n      ], 'E416:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'hi Group term=bold',\n      'match Group /todo/ # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'hi Group term=bold',\n      'match Group /todo/# comment',\n      ], 'E488:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'match # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'match# comment',\n      ], 'E1144:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'match none # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'match none# comment',\n      ], 'E475:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'menutrans clear # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'menutrans clear# comment text',\n      ], 'E474:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax clear # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax clear# comment text',\n      ], 'E28:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax keyword Word some',\n      'syntax clear Word # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax keyword Word some',\n      'syntax clear Word# comment text',\n      ], 'E28:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax list # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax list# comment text',\n      ], 'E28:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax match Word /pat/ oneline # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax match Word /pat/ oneline# comment',\n      ], 'E475:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax keyword Word word # comm[ent',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax keyword Word word# comm[ent',\n      ], 'E789:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax match Word /pat/ # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax match Word /pat/# comment',\n      ], 'E402:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax match Word /pat/ contains=Something # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax match Word /pat/ contains=Something# comment',\n      ], 'E475:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax match Word /pat/ contains= # comment',\n      ], 'E406:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax match Word /pat/ contains=# comment',\n      ], 'E475:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax region Word start=/pat/ end=/pat/ # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax region Word start=/pat/ end=/pat/# comment',\n      ], 'E402:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax sync # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax sync# comment',\n      ], 'E404:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax sync ccomment # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax sync ccomment# comment',\n      ], 'E404:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax cluster Some contains=Word # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax cluster Some contains=Word# comment',\n      ], 'E475:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'command Echo echo # comment',\n      'command Echo # comment',\n      'delcommand Echo',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'command Echo echo# comment',\n      'Echo',\n      ], 'E1144:')\n  delcommand Echo\n\n  var curdir = getcwd()\n  v9.CheckScriptSuccess([\n      'command Echo cd \" comment',\n      'Echo',\n      'delcommand Echo',\n      ])\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'command Echo cd # comment',\n      'Echo',\n      'delcommand Echo',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'command Echo cd \" comment',\n      'Echo',\n      ], 'E344:')\n  delcommand Echo\n  chdir(curdir)\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'command Echo# comment',\n      ], 'E182:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'command Echo echo',\n      'command Echo# comment',\n      ], 'E182:')\n  delcommand Echo\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'function # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'function \" comment',\n      ], 'E129:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'function# comment',\n      ], 'E1144:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'import \"./vim9.vim\" as v9',\n      'function v9.CheckScriptSuccess # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'import \"./vim9.vim\" as v9',\n      'function v9.CheckScriptSuccess# comment',\n      ], 'E1048: Item not found in script: CheckScriptSuccess#')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'func g:DeleteMeA()',\n      'endfunc',\n      'delfunction g:DeleteMeA # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'func g:DeleteMeB()',\n      'endfunc',\n      'delfunction g:DeleteMeB# comment',\n      ], 'E488:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'call execute(\"ls\") # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'call execute(\"ls\")# comment',\n      ], 'E488:')\n\n  v9.CheckScriptFailure([\n      'def Test() \" comment',\n      'enddef',\n      ], 'E488:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'def Test() \" comment',\n      'enddef',\n      ], 'E488:')\n\n  v9.CheckScriptSuccess([\n      'func Test() \" comment',\n      'endfunc',\n      'delfunc Test',\n      ])\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'func Test() \" comment',\n      'endfunc',\n      ])\n\n  v9.CheckScriptSuccess([\n      'def Test() # comment',\n      'enddef',\n      ])\n  v9.CheckScriptFailure([\n      'func Test() # comment',\n      'endfunc',\n      ], 'E488:')\n\n  var lines =<< trim END\n      vim9script\n      syn region Text\n      \\ start='foo'\n      #\\ comment\n      \\ end='bar'\n      syn region Text start='foo'\n      #\\ comment\n      \\ end='bar'\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      syn region Text\n      \\ start='foo'\n      \"\\ comment\n      \\ end='bar'\n  END\n  v9.CheckScriptFailure(lines, 'E399:')\nenddef\n\ndef Test_vim9_comment_gui()\n  CheckCanRunGui\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'gui#comment'\n      ], 'E1144:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'gui -f#comment'\n      ], 'E194:')\nenddef\n\ndef Test_vim9_comment_not_compiled()\n  au TabEnter *.vim g:entered = 1\n  au TabEnter *.x g:entered = 2\n\n  edit test.vim\n  doautocmd TabEnter #comment\n  assert_equal(1, g:entered)\n\n  doautocmd TabEnter f.x\n  assert_equal(2, g:entered)\n\n  g:entered = 0\n  doautocmd TabEnter f.x #comment\n  assert_equal(2, g:entered)\n\n  assert_fails('doautocmd Syntax#comment', 'E216:')\n\n  au! TabEnter\n  unlet g:entered\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'g:var = 123',\n      'b:var = 456',\n      'w:var = 777',\n      't:var = 888',\n      'unlet g:var w:var # something',\n      ])\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'let var = 123',\n      ], 'E1126: Cannot use :let in Vim9 script')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'var g:var = 123',\n      ], 'E1016: Cannot declare a global variable:')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'var b:var = 123',\n      ], 'E1016: Cannot declare a buffer variable:')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'var w:var = 123',\n      ], 'E1016: Cannot declare a window variable:')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'var t:var = 123',\n      ], 'E1016: Cannot declare a tab variable:')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'var v:version = 123',\n      ], 'E1016: Cannot declare a v: variable:')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'var $VARIABLE = \"text\"',\n      ], 'E1016: Cannot declare an environment variable:')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'g:var = 123',\n      'unlet g:var# comment1',\n      ], 'E108:')\n\n  v9.CheckScriptFailure([\n      'let g:var = 123',\n      'unlet g:var # something',\n      ], 'E488:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'if 1 # comment2',\n      '  echo \"yes\"',\n      'elseif 2 #comment',\n      '  echo \"no\"',\n      'endif',\n      ])\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'if 1# comment3',\n      '  echo \"yes\"',\n      'endif',\n      ], 'E488:')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'if 0 # comment4',\n      '  echo \"yes\"',\n      'elseif 2#comment',\n      '  echo \"no\"',\n      'endif',\n      ], 'E488:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'var v = 1 # comment5',\n      ])\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'var v = 1# comment6',\n      ], 'E488:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'new'\n      'setline(1, [\"# define pat\", \"last\"])',\n      ':$',\n      'dsearch /pat/ #comment',\n      'bwipe!',\n      ])\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'new'\n      'setline(1, [\"# define pat\", \"last\"])',\n      ':$',\n      'dsearch /pat/#comment',\n      'bwipe!',\n      ], 'E488:')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'func! SomeFunc()',\n      ], 'E477:')\nenddef\n\ndef Test_finish()\n  var lines =<< trim END\n    vim9script\n    g:res = 'one'\n    if v:false | finish | endif\n    g:res = 'two'\n    finish\n    g:res = 'three'\n  END\n  writefile(lines, 'Xfinished')\n  source Xfinished\n  assert_equal('two', g:res)\n\n  unlet g:res\n  delete('Xfinished')\nenddef\n\ndef Test_forward_declaration()\n  var lines =<< trim END\n    vim9script\n    def GetValue(): string\n      return theVal\n    enddef\n    var theVal = 'something'\n    g:initVal = GetValue()\n    theVal = 'else'\n    g:laterVal = GetValue()\n  END\n  writefile(lines, 'Xforward')\n  source Xforward\n  assert_equal('something', g:initVal)\n  assert_equal('else', g:laterVal)\n\n  unlet g:initVal\n  unlet g:laterVal\n  delete('Xforward')\nenddef\n\ndef Test_declare_script_var_in_func()\n  var lines =<< trim END\n      vim9script\n      func Declare()\n        let s:local = 123\n      endfunc\n      Declare()\n  END\n  v9.CheckScriptFailure(lines, 'E1269:')\nenddef\n        \ndef Test_lock_script_var()\n  var lines =<< trim END\n      vim9script\n      var local = 123\n      assert_equal(123, local)\n\n      var error: string\n      try\n        local = 'asdf'\n      catch\n        error = v:exception\n      endtry\n      assert_match('E1012: Type mismatch; expected number but got string', error)\n\n      lockvar local\n      try\n        local = 999\n      catch\n        error = v:exception\n      endtry\n      assert_match('E741: Value is locked: local', error)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n        \n\nfunc Test_vim9script_not_global()\n  \" check that items defined in Vim9 script are script-local, not global\n  let vim9lines =<< trim END\n    vim9script\n    var name = 'local'\n    func TheFunc()\n      echo 'local'\n    endfunc\n    def DefFunc()\n      echo 'local'\n    enddef\n  END\n  call writefile(vim9lines, 'Xvim9script.vim')\n  source Xvim9script.vim\n  try\n    echo g:var\n    assert_report('did not fail')\n  catch /E121:/\n    \" caught\n  endtry\n  try\n    call TheFunc()\n    assert_report('did not fail')\n  catch /E117:/\n    \" caught\n  endtry\n  try\n    call DefFunc()\n    assert_report('did not fail')\n  catch /E117:/\n    \" caught\n  endtry\n\n  call delete('Xvim9script.vim')\nendfunc\n\ndef Test_vim9_copen()\n  # this was giving an error for setting w:quickfix_title\n  copen\n  quit\nenddef\n\ndef Test_script_var_in_autocmd()\n  # using a script variable from an autocommand, defined in a :def function in a\n  # legacy Vim script, cannot check the variable type.\n  var lines =<< trim END\n    let s:counter = 1\n    def s:Func()\n      au! CursorHold\n      au CursorHold * s:counter += 1\n    enddef\n    call s:Func()\n    doau CursorHold\n    call assert_equal(2, s:counter)\n    au! CursorHold\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_error_in_autoload_script()\n  var save_rtp = &rtp\n  var dir = getcwd() .. '/Xruntime'\n  &rtp = dir\n  mkdir(dir .. '/autoload', 'p')\n\n  var lines =<< trim END\n      vim9script noclear\n      export def Autoloaded()\n      enddef\n      def Broken()\n        var x: any = ''\n        eval x != 0\n      enddef\n      Broken()\n  END\n  writefile(lines, dir .. '/autoload/script.vim')\n\n  lines =<< trim END\n      vim9script\n      def CallAutoloaded()\n        script#Autoloaded()\n      enddef\n\n      function Legacy()\n        try\n          call s:CallAutoloaded()\n        catch\n          call assert_match('E1030: Using a String as a Number', v:exception)\n        endtry\n      endfunction\n\n      Legacy()\n  END\n  v9.CheckScriptSuccess(lines)\n\n  &rtp = save_rtp\n  delete(dir, 'rf')\nenddef\n\ndef Test_error_in_autoload_script_foldexpr()\n  var save_rtp = &rtp\n  mkdir('Xvim/autoload', 'p')\n  &runtimepath = 'Xvim'\n\n  var lines =<< trim END\n      vim9script\n      eval [][0]\n      echomsg 'no error'\n  END\n  lines->writefile('Xvim/autoload/script.vim')\n\n  lines =<< trim END\n      vim9script\n      import autoload 'script.vim'\n      &foldmethod = 'expr'\n      &foldexpr = 'script.Func()'\n      redraw\n  END\n  v9.CheckScriptFailure(lines, 'E684: List index out of range: 0')\n\n  delete('Xvim', 'rf')\nenddef\n\ndef Test_invalid_sid()\n  assert_fails('func <SNR>1234_func', 'E123:')\n\n  if g:RunVim([], ['wq! Xdidit'], '+\"func <SNR>1_func\"')\n    assert_equal([], readfile('Xdidit'))\n  endif\n  delete('Xdidit')\nenddef\n\ndef Test_restoring_cpo()\n  writefile(['vim9script', 'set nocp'], 'Xsourced')\n  writefile(['call writefile([\"done\"], \"Xdone\")', 'quit!'], 'Xclose')\n  if g:RunVim([], [], '-u NONE +\"set cpo+=a\" -S Xsourced -S Xclose')\n    assert_equal(['done'], readfile('Xdone'))\n  endif\n  delete('Xsourced')\n  delete('Xclose')\n  delete('Xdone')\n\n  writefile(['vim9script', 'g:cpoval = &cpo'], 'XanotherScript')\n  set cpo=aABceFsMny>\n  edit XanotherScript\n  so %\n  assert_equal('aABceFsMny>', &cpo)\n  assert_equal('aABceFs', g:cpoval)\n  :1del\n  setline(1, 'let g:cpoval = &cpo')\n  w\n  so %\n  assert_equal('aABceFsMny>', &cpo)\n  assert_equal('aABceFsMny>', g:cpoval)\n\n  delete('XanotherScript')\n  set cpo&vim\n  unlet g:cpoval\n\n  if has('unix')\n    # 'cpo' is not restored in main vimrc\n    var save_HOME = $HOME\n    $HOME = getcwd() .. '/Xhome'\n    mkdir('Xhome')\n    var lines =<< trim END\n        vim9script\n        writefile(['before: ' .. &cpo], 'Xresult')\n        set cpo+=M\n        writefile(['after: ' .. &cpo], 'Xresult', 'a')\n    END\n    writefile(lines, 'Xhome/.vimrc')\n\n    lines =<< trim END\n        call writefile(['later: ' .. &cpo], 'Xresult', 'a')\n    END\n    writefile(lines, 'Xlegacy')\n\n    lines =<< trim END\n        vim9script\n        call writefile(['vim9: ' .. &cpo], 'Xresult', 'a')\n        qa\n    END\n    writefile(lines, 'Xvim9')\n\n    var cmd = g:GetVimCommand() .. \" -S Xlegacy -S Xvim9\"\n    cmd = substitute(cmd, '-u NONE', '', '')\n    exe \"silent !\" .. cmd\n\n    assert_equal([\n        'before: aABceFs',\n        'after: aABceFsM',\n        'later: aABceFsM',\n        'vim9: aABceFs'], readfile('Xresult'))\n\n    $HOME = save_HOME\n    delete('Xhome', 'rf')\n    delete('Xlegacy')\n    delete('Xvim9')\n    delete('Xresult')\n  endif\nenddef\n\n\" Use :function so we can use Check commands\nfunc Test_no_redraw_when_restoring_cpo()\n  CheckScreendump\n  CheckFeature timers\n  call Run_test_no_redraw_when_restoring_cpo()\nendfunc\n\ndef Run_test_no_redraw_when_restoring_cpo()\n  var lines =<< trim END\n    vim9script\n    export def Func()\n    enddef\n  END\n  mkdir('Xdir/autoload', 'p')\n  writefile(lines, 'Xdir/autoload/script.vim')\n\n  lines =<< trim END\n      vim9script\n      set cpo+=M\n      exe 'set rtp^=' .. getcwd() .. '/Xdir'\n      au CmdlineEnter : ++once timer_start(0, (_) => script#Func())\n      setline(1, 'some text')\n  END\n  writefile(lines, 'XTest_redraw_cpo')\n  var buf = g:RunVimInTerminal('-S XTest_redraw_cpo', {'rows': 6})\n  term_sendkeys(buf, \"V:\")\n  g:VerifyScreenDump(buf, 'Test_vim9_no_redraw', {})\n\n  # clean up\n  term_sendkeys(buf, \"\\<Esc>u\")\n  g:StopVimInTerminal(buf)\n  delete('XTest_redraw_cpo')\n  delete('Xdir', 'rf')\nenddef\n\nfunc Test_reject_declaration()\n  CheckScreendump\n  call Run_test_reject_declaration()\nendfunc\n\ndef Run_test_reject_declaration()\n  var buf = g:RunVimInTerminal('', {'rows': 6})\n  term_sendkeys(buf, \":vim9cmd var x: number\\<CR>\")\n  g:VerifyScreenDump(buf, 'Test_vim9_reject_declaration_1', {})\n  term_sendkeys(buf, \":\\<CR>\")\n  term_sendkeys(buf, \":vim9cmd g:foo = 123 | echo g:foo\\<CR>\")\n  g:VerifyScreenDump(buf, 'Test_vim9_reject_declaration_2', {})\n\n  # clean up\n  g:StopVimInTerminal(buf)\nenddef\n\ndef Test_minimal_command_name_length()\n  var names = [\n       'cons',\n       'brea',\n       'cat',\n       'catc',\n       'con',\n       'cont',\n       'conti',\n       'contin',\n       'continu',\n       'el',\n       'els',\n       'elsei',\n       'endfo',\n       'en',\n       'end',\n       'endi',\n       'endw',\n       'endt',\n       'endtr',\n       'exp',\n       'expo',\n       'expor',\n       'fina',\n       'finall',\n       'fini',\n       'finis',\n       'imp',\n       'impo',\n       'impor',\n       'retu',\n       'retur',\n       'th',\n       'thr',\n       'thro',\n       'wh',\n       'whi',\n       'whil',\n      ]\n  for name in names\n    v9.CheckDefAndScriptFailure([name .. ' '], 'E1065:')\n  endfor\n\n  var lines =<< trim END\n      vim9script\n      def SomeFunc()\n      endd\n  END\n  v9.CheckScriptFailure(lines, 'E1065:')\n  lines =<< trim END\n      vim9script\n      def SomeFunc()\n      endde\n  END\n  v9.CheckScriptFailure(lines, 'E1065:')\nenddef\n\ndef Test_unset_any_variable()\n  var lines =<< trim END\n    var name: any\n    assert_equal(0, name)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\nfunc Test_define_func_at_command_line()\n  CheckRunVimInTerminal\n\n  \" call indirectly to avoid compilation error for missing functions\n  call Run_Test_define_func_at_command_line()\nendfunc\n\ndef Run_Test_define_func_at_command_line()\n  # run in a separate Vim instance to avoid the script context\n  var lines =<< trim END\n    func CheckAndQuit()\n      call assert_fails('call Afunc()', 'E117: Unknown function: Bfunc')\n      call writefile(['errors: ' .. string(v:errors)], 'Xdidcmd')\n    endfunc\n  END\n  writefile([''], 'Xdidcmd')\n  writefile(lines, 'XcallFunc')\n  var buf = g:RunVimInTerminal('-S XcallFunc', {rows: 6})\n  # define Afunc() on the command line\n  term_sendkeys(buf, \":def Afunc()\\<CR>Bfunc()\\<CR>enddef\\<CR>\")\n  term_sendkeys(buf, \":call CheckAndQuit()\\<CR>\")\n  g:WaitForAssert(() => assert_equal(['errors: []'], readfile('Xdidcmd')))\n\n  call g:StopVimInTerminal(buf)\n  delete('XcallFunc')\n  delete('Xdidcmd')\nenddef\n\ndef Test_script_var_scope()\n  var lines =<< trim END\n      vim9script\n      if true\n        if true\n          var one = 'one'\n          echo one\n        endif\n        echo one\n      endif\n  END\n  v9.CheckScriptFailure(lines, 'E121:', 7)\n\n  lines =<< trim END\n      vim9script\n      if true\n        if false\n          var one = 'one'\n          echo one\n        else\n          var one = 'one'\n          echo one\n        endif\n        echo one\n      endif\n  END\n  v9.CheckScriptFailure(lines, 'E121:', 10)\n\n  lines =<< trim END\n      vim9script\n      while true\n        var one = 'one'\n        echo one\n        break\n      endwhile\n      echo one\n  END\n  v9.CheckScriptFailure(lines, 'E121:', 7)\n\n  lines =<< trim END\n      vim9script\n      for i in range(1)\n        var one = 'one'\n        echo one\n      endfor\n      echo one\n  END\n  v9.CheckScriptFailure(lines, 'E121:', 6)\n\n  lines =<< trim END\n      vim9script\n      {\n        var one = 'one'\n        assert_equal('one', one)\n      }\n      assert_false(exists('one'))\n      assert_false(exists('s:one'))\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      {\n        var one = 'one'\n        echo one\n      }\n      echo one\n  END\n  v9.CheckScriptFailure(lines, 'E121:', 6)\nenddef\n\ndef Test_catch_exception_in_callback()\n  var lines =<< trim END\n    vim9script\n    def Callback(...l: list<any>)\n      try\n        var x: string\n        var y: string\n        # this error should be caught with CHECKLEN\n        var sl = ['']\n        [x, y] = sl\n      catch\n        g:caught = 'yes'\n      endtry\n    enddef\n    popup_menu('popup', {callback: Callback})\n    feedkeys(\"\\r\", 'xt')\n  END\n  v9.CheckScriptSuccess(lines)\n\n  unlet g:caught\nenddef\n\ndef Test_no_unknown_error_after_error()\n  if !has('unix') || !has('job')\n    throw 'Skipped: not unix of missing +job feature'\n  endif\n  # FIXME: this check should not be needed\n  if has('win32')\n    throw 'Skipped: does not work on MS-Windows'\n  endif\n  var lines =<< trim END\n      vim9script\n      var source: list<number>\n      def Out_cb(...l: list<any>)\n          eval [][0]\n      enddef\n      def Exit_cb(...l: list<any>)\n          sleep 1m\n          g:did_call_exit_cb = true\n          source += l\n      enddef\n      var myjob = job_start('echo burp', {out_cb: Out_cb, exit_cb: Exit_cb, mode: 'raw'})\n      while job_status(myjob) == 'run'\n        sleep 10m\n      endwhile\n      # wait for Exit_cb() to be called\n      for x in range(100)\n        if exists('g:did_call_exit_cb')\n          unlet g:did_call_exit_cb\n          break\n        endif\n        sleep 10m\n      endfor\n  END\n  writefile(lines, 'Xdef')\n  assert_fails('so Xdef', ['E684:', 'E1012:'])\n  delete('Xdef')\nenddef\n\ndef InvokeNormal()\n  exe \"norm! :m+1\\r\"\nenddef\n\ndef Test_invoke_normal_in_visual_mode()\n  xnoremap <F3> <Cmd>call <SID>InvokeNormal()<CR>\n  new\n  setline(1, ['aaa', 'bbb'])\n  feedkeys(\"V\\<F3>\", 'xt')\n  assert_equal(['bbb', 'aaa'], getline(1, 2))\n  xunmap <F3>\nenddef\n\ndef Test_white_space_after_command()\n  var lines =<< trim END\n    exit_cb: Func})\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1144:', 1)\n\n  lines =<< trim END\n    e#\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1144:', 1)\nenddef\n\ndef Test_script_var_gone_when_sourced_twice()\n  var lines =<< trim END\n      vim9script\n      if exists('g:guard')\n        finish\n      endif\n      g:guard = 1\n      var name = 'thename'\n      def g:GetName(): string\n        return name\n      enddef\n      def g:SetName(arg: string)\n        name = arg\n      enddef\n  END\n  writefile(lines, 'XscriptTwice.vim')\n  so XscriptTwice.vim\n  assert_equal('thename', g:GetName())\n  g:SetName('newname')\n  assert_equal('newname', g:GetName())\n  so XscriptTwice.vim\n  assert_fails('call g:GetName()', 'E1149:')\n  assert_fails('call g:SetName(\"x\")', 'E1149:')\n\n  delfunc g:GetName\n  delfunc g:SetName\n  delete('XscriptTwice.vim')\n  unlet g:guard\nenddef\n\ndef Test_unsupported_commands()\n  var lines =<< trim END\n      ka\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E476:', 'E492:'])\n\n  lines =<< trim END\n      :1ka\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E476:', 'E492:'])\n\n  lines =<< trim END\n      :k a\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1100:')\n\n  lines =<< trim END\n      :1k a\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E481:')\n\n  lines =<< trim END\n    t\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1100:')\n\n  lines =<< trim END\n    x\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1100:')\n\n  lines =<< trim END\n    xit\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1100:')\n\n  lines =<< trim END\n    Print\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E476: Invalid command: Print', 'E492: Not an editor command: Print'])\n\n  lines =<< trim END\n    mode 4\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E476: Invalid command: mode 4', 'E492: Not an editor command: mode 4'])\nenddef\n\ndef Test_mapping_line_number()\n  var lines =<< trim END\n      vim9script\n      def g:FuncA()\n          # Some comment\n          FuncB(0)\n      enddef\n          # Some comment\n      def FuncB(\n          # Some comment\n          n: number\n      )\n          exe 'nno '\n              # Some comment\n              .. '<F3> a'\n              .. 'b'\n              .. 'c'\n      enddef\n  END\n  v9.CheckScriptSuccess(lines)\n  var res = execute('verbose nmap <F3>')\n  assert_match('No mapping found', res)\n\n  g:FuncA()\n  res = execute('verbose nmap <F3>')\n  assert_match(' <F3> .* abc.*Last set from .*XScriptSuccess\\d\\+ line 11', res)\n\n  nunmap <F3>\n  delfunc g:FuncA\nenddef\n\ndef Test_option_set()\n  # legacy script allows for white space\n  var lines =<< trim END\n      set foldlevel  =11\n      call assert_equal(11, &foldlevel)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  set foldlevel\n  set foldlevel=12\n  assert_equal(12, &foldlevel)\n  set foldlevel+=2\n  assert_equal(14, &foldlevel)\n  set foldlevel-=3\n  assert_equal(11, &foldlevel)\n\n  lines =<< trim END\n      set foldlevel =1\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1205: No white space allowed between option and: =1')\n\n  lines =<< trim END\n      set foldlevel +=1\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1205: No white space allowed between option and: +=1')\n\n  lines =<< trim END\n      set foldlevel ^=1\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1205: No white space allowed between option and: ^=1')\n\n  lines =<< trim END\n      set foldlevel -=1\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1205: No white space allowed between option and: -=1')\n\n  set foldlevel&\nenddef\n\ndef Test_option_modifier()\n  # legacy script allows for white space\n  var lines =<< trim END\n      set hlsearch &  hlsearch  !\n      call assert_equal(1, &hlsearch)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  set hlsearch\n  set hlsearch!\n  assert_equal(false, &hlsearch)\n\n  set hlsearch\n  set hlsearch&\n  assert_equal(false, &hlsearch)\n\n  lines =<< trim END\n      set hlsearch &\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1205: No white space allowed between option and: &')\n\n  lines =<< trim END\n      set hlsearch   !\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1205: No white space allowed between option and: !')\n\n  set hlsearch&\nenddef\n\n\" This must be called last, it may cause following :def functions to fail\ndef Test_xxx_echoerr_line_number()\n  var lines =<< trim END\n      echoerr 'some'\n         .. ' error'\n         .. ' continued'\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'some error continued', 1)\nenddef\n\nfunc Test_debug_with_lambda()\n  CheckRunVimInTerminal\n\n  \" call indirectly to avoid compilation error for missing functions\n  call Run_Test_debug_with_lambda()\nendfunc\n\ndef Run_Test_debug_with_lambda()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        var n = 0\n        echo [0]->filter((_, v) => v == n)\n      enddef\n      breakadd func Func\n      Func()\n  END\n  writefile(lines, 'XdebugFunc')\n  var buf = g:RunVimInTerminal('-S XdebugFunc', {rows: 6, wait_for_ruler: 0})\n  g:WaitForAssert(() => assert_match('^>', term_getline(buf, 6)))\n\n  term_sendkeys(buf, \"cont\\<CR>\")\n  g:WaitForAssert(() => assert_match('\\[0\\]', term_getline(buf, 5)))\n\n  g:StopVimInTerminal(buf)\n  delete('XdebugFunc')\nenddef\n\nfunc Test_debug_running_out_of_lines()\n  CheckRunVimInTerminal\n\n  \" call indirectly to avoid compilation error for missing functions\n  call Run_Test_debug_running_out_of_lines()\nendfunc\n\ndef Run_Test_debug_running_out_of_lines()\n  var lines =<< trim END\n      vim9script\n      def Crash()\n          #\n          #\n          #\n          #\n          #\n          #\n          #\n          if true\n              #\n          endif\n      enddef\n      breakadd func Crash\n      Crash()\n  END\n  writefile(lines, 'XdebugFunc')\n  var buf = g:RunVimInTerminal('-S XdebugFunc', {rows: 6, wait_for_ruler: 0})\n  g:WaitForAssert(() => assert_match('^>', term_getline(buf, 6)))\n\n  term_sendkeys(buf, \"next\\<CR>\")\n  g:TermWait(buf)\n  g:WaitForAssert(() => assert_match('^>', term_getline(buf, 6)))\n\n  term_sendkeys(buf, \"cont\\<CR>\")\n  g:TermWait(buf)\n\n  g:StopVimInTerminal(buf)\n  delete('XdebugFunc')\nenddef\n\ndef Test_ambigous_command_error()\n  var lines =<< trim END\n      vim9script\n      command CmdA echomsg 'CmdA'\n      command CmdB echomsg 'CmdB'\n      Cmd\n  END\n  v9.CheckScriptFailure(lines, 'E464: Ambiguous use of user-defined command: Cmd', 4)\n\n  lines =<< trim END\n      vim9script\n      def Func()\n        Cmd\n      enddef\n      Func()\n  END\n  v9.CheckScriptFailure(lines, 'E464: Ambiguous use of user-defined command: Cmd', 1)\n\n  lines =<< trim END\n      vim9script\n      nnoremap <F3> <ScriptCmd>Cmd<CR>\n      feedkeys(\"\\<F3>\", 'xt')\n  END\n  v9.CheckScriptFailure(lines, 'E464: Ambiguous use of user-defined command: Cmd', 3)\n\n  delcommand CmdA\n  delcommand CmdB\n  nunmap <F3>\nenddef\n\n\" Execute this near the end, profiling doesn't stop until Vim exits.\n\" This only tests that it works, not the profiling output.\ndef Test_profile_with_lambda()\n  CheckFeature profile\n\n  var lines =<< trim END\n      vim9script\n\n      def ProfiledWithLambda()\n        var n = 3\n        echo [[1, 2], [3, 4]]->filter((_, l) => l[0] == n)\n      enddef\n\n      def ProfiledNested()\n        var x = 0\n        def Nested(): any\n            return x\n        enddef\n        Nested()\n      enddef\n\n      def g:ProfiledNestedProfiled()\n        var x = 0\n        def Nested(): any\n            return x\n        enddef\n        Nested()\n      enddef\n\n      def Profile()\n        ProfiledWithLambda()\n        ProfiledNested()\n\n        # Also profile the nested function.  Use a different function, although\n        # the contents is the same, to make sure it was not already compiled.\n        profile func *\n        g:ProfiledNestedProfiled()\n\n        profdel func *\n        profile pause\n      enddef\n\n      var result = 'done'\n      try\n        # mark functions for profiling now to avoid E1271\n        profile start Xprofile.log\n        profile func ProfiledWithLambda\n        profile func ProfiledNested\n\n        Profile()\n      catch\n        result = 'failed: ' .. v:exception\n      finally\n        writefile([result], 'Xdidprofile')\n      endtry\n  END\n  writefile(lines, 'Xprofile.vim')\n  call system(g:GetVimCommand()\n        .. ' --clean'\n        .. ' -c \"so Xprofile.vim\"'\n        .. ' -c \"qall!\"')\n  call assert_equal(0, v:shell_error)\n\n  assert_equal(['done'], readfile('Xdidprofile'))\n  assert_true(filereadable('Xprofile.log'))\n  delete('Xdidprofile')\n  delete('Xprofile.log')\n  delete('Xprofile.vim')\nenddef\n\nfunc Test_misplaced_type()\n  CheckRunVimInTerminal\n  call Run_Test_misplaced_type()\nendfunc\n\ndef Run_Test_misplaced_type()\n  writefile(['let g:somevar = \"asdf\"'], 'XTest_misplaced_type')\n  var buf = g:RunVimInTerminal('-S XTest_misplaced_type', {'rows': 6})\n  term_sendkeys(buf, \":vim9cmd echo islocked('g:somevar: string')\\<CR>\")\n  g:VerifyScreenDump(buf, 'Test_misplaced_type', {})\n\n  g:StopVimInTerminal(buf)\n  delete('XTest_misplaced_type')\nenddef\n\n\" Ensure echo doesn't crash when stringifying empty variables.\ndef Test_echo_uninit_variables()\n  var res: string\n\n  var var_bool: bool\n  var var_num: number\n  var var_float: float\n  var Var_func: func\n  var var_string: string\n  var var_blob: blob\n  var var_list: list<any>\n  var var_dict: dict<any>\n\n  redir => res\n  echo var_bool\n  echo var_num\n  echo var_float\n  echo Var_func\n  echo var_string\n  echo var_blob\n  echo var_list\n  echo var_dict\n  redir END\n\n  assert_equal(['false', '0', '0.0', 'function()', '', '0z', '[]', '{}'], res->split('\\n'))\n\n  if has('job')\n    var var_job: job\n    var var_channel: channel\n\n    redir => res\n    echo var_job\n    echo var_channel\n    redir END\n\n    assert_equal(['no process', 'channel fail'], res->split('\\n'))\n  endif\nenddef\n\n\" Keep this last, it messes up highlighting.\ndef Test_substitute_cmd()\n  new\n  setline(1, 'something')\n  :substitute(some(other(\n  assert_equal('otherthing', getline(1))\n  bwipe!\n\n  # also when the context is Vim9 script\n  var lines =<< trim END\n    vim9script\n    new\n    setline(1, 'something')\n    :substitute(some(other(\n    assert_equal('otherthing', getline(1))\n    bwipe!\n  END\n  writefile(lines, 'Xvim9lines')\n  source Xvim9lines\n\n  delete('Xvim9lines')\nenddef\n\n\" vim: ts=8 sw=2 sts=2 expandtab tw=80 fdm=marker\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * vim9compile.c: compiling a :def function\n */\n\n#define USING_FLOAT_STUFF\n#include \"vim.h\"\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\n// When not generating protos this is included in proto.h\n#ifdef PROTO\n# include \"vim9.h\"\n#endif\n\n// Functions defined with :def are stored in this growarray.\n// They are never removed, so that they can be found by index.\n// Deleted functions have the df_deleted flag set.\ngarray_T def_functions = {0, 0, sizeof(dfunc_T), 50, NULL};\n\nstatic void delete_def_function_contents(dfunc_T *dfunc, int mark_deleted);\n\n/*\n * Lookup variable \"name\" in the local scope and return it in \"lvar\".\n * \"lvar->lv_from_outer\" is incremented accordingly.\n * If \"lvar\" is NULL only check if the variable can be found.\n * Return FAIL if not found.\n */\n    int\nlookup_local(char_u *name, size_t len, lvar_T *lvar, cctx_T *cctx)\n{\n    int\t    idx;\n    lvar_T  *lvp;\n\n    if (len == 0)\n\treturn FAIL;\n\n    // Find local in current function scope.\n    for (idx = 0; idx < cctx->ctx_locals.ga_len; ++idx)\n    {\n\tlvp = ((lvar_T *)cctx->ctx_locals.ga_data) + idx;\n\tif (STRNCMP(name, lvp->lv_name, len) == 0\n\t\t\t\t\t       && STRLEN(lvp->lv_name) == len)\n\t{\n\t    if (lvar != NULL)\n\t    {\n\t\t*lvar = *lvp;\n\t\tlvar->lv_from_outer = 0;\n\t    }\n\t    return OK;\n\t}\n    }\n\n    // Find local in outer function scope.\n    if (cctx->ctx_outer != NULL)\n    {\n\tif (lookup_local(name, len, lvar, cctx->ctx_outer) == OK)\n\t{\n\t    if (lvar != NULL)\n\t    {\n\t\tcctx->ctx_outer_used = TRUE;\n\t\t++lvar->lv_from_outer;\n\t    }\n\t    return OK;\n\t}\n    }\n\n    return FAIL;\n}\n\n/*\n * Lookup an argument in the current function and an enclosing function.\n * Returns the argument index in \"idxp\"\n * Returns the argument type in \"type\"\n * Sets \"gen_load_outer\" to TRUE if found in outer scope.\n * Returns OK when found, FAIL otherwise.\n */\n    int\narg_exists(\n\tchar_u\t*name,\n\tsize_t\tlen,\n\tint\t*idxp,\n\ttype_T\t**type,\n\tint\t*gen_load_outer,\n\tcctx_T\t*cctx)\n{\n    int\t    idx;\n    char_u  *va_name;\n\n    if (len == 0)\n\treturn FAIL;\n    for (idx = 0; idx < cctx->ctx_ufunc->uf_args_visible; ++idx)\n    {\n\tchar_u *arg = FUNCARG(cctx->ctx_ufunc, idx);\n\n\tif (STRNCMP(name, arg, len) == 0 && arg[len] == NUL)\n\t{\n\t    if (idxp != NULL)\n\t    {\n\t\t// Arguments are located above the frame pointer.  One further\n\t\t// if there is a vararg argument\n\t\t*idxp = idx - (cctx->ctx_ufunc->uf_args.ga_len\n\t\t\t\t\t\t\t    + STACK_FRAME_SIZE)\n\t\t\t      + (cctx->ctx_ufunc->uf_va_name != NULL ? -1 : 0);\n\n\t\tif (cctx->ctx_ufunc->uf_arg_types != NULL)\n\t\t    *type = cctx->ctx_ufunc->uf_arg_types[idx];\n\t\telse\n\t\t    *type = &t_any;\n\t    }\n\t    return OK;\n\t}\n    }\n\n    va_name = cctx->ctx_ufunc->uf_va_name;\n    if (va_name != NULL\n\t\t    && STRNCMP(name, va_name, len) == 0 && va_name[len] == NUL)\n    {\n\tif (idxp != NULL)\n\t{\n\t    // varargs is always the last argument\n\t    *idxp = -STACK_FRAME_SIZE - 1;\n\t    *type = cctx->ctx_ufunc->uf_va_type;\n\t}\n\treturn OK;\n    }\n\n    if (cctx->ctx_outer != NULL)\n    {\n\t// Lookup the name for an argument of the outer function.\n\tif (arg_exists(name, len, idxp, type, gen_load_outer, cctx->ctx_outer)\n\t\t\t\t\t\t\t\t\t == OK)\n\t{\n\t    if (gen_load_outer != NULL)\n\t\t++*gen_load_outer;\n\t    return OK;\n\t}\n    }\n\n    return FAIL;\n}\n\n/*\n * Lookup a script-local variable in the current script, possibly defined in a\n * block that contains the function \"cctx->ctx_ufunc\".\n * \"cctx\" is NULL at the script level, \"cstack\" is NULL in a function.\n * If \"len\" is <= 0 \"name\" must be NUL terminated.\n * Return NULL when not found.\n */\n    static sallvar_T *\nfind_script_var(char_u *name, size_t len, cctx_T *cctx, cstack_T *cstack)\n{\n    scriptitem_T    *si = SCRIPT_ITEM(current_sctx.sc_sid);\n    hashitem_T\t    *hi;\n    int\t\t    cc;\n    sallvar_T\t    *sav;\n    ufunc_T\t    *ufunc;\n\n    // Find the list of all script variables with the right name.\n    if (len > 0)\n    {\n\tcc = name[len];\n\tname[len] = NUL;\n    }\n    hi = hash_find(&si->sn_all_vars.dv_hashtab, name);\n    if (len > 0)\n\tname[len] = cc;\n    if (HASHITEM_EMPTY(hi))\n\treturn NULL;\n\n    sav = HI2SAV(hi);\n    if (sav->sav_block_id == 0)\n\t// variable defined in the top script scope is always visible\n\treturn sav;\n\n    if (cctx == NULL)\n    {\n\t// Not in a function scope, find variable with block ID equal to or\n\t// smaller than the current block id.  Use \"cstack\" to go up the block\n\t// scopes.\n\twhile (sav != NULL)\n\t{\n\t    int idx;\n\n\t    for (idx = cstack->cs_idx; idx >= 0; --idx)\n\t\tif (cstack->cs_block_id[idx] == sav->sav_block_id)\n\t\t    break;\n\t    if (idx >= 0)\n\t\tbreak;\n\t    sav = sav->sav_next;\n\t}\n\treturn sav;\n    }\n\n    // Go over the variables with this name and find one that was visible\n    // from the function.\n    ufunc = cctx->ctx_ufunc;\n    while (sav != NULL)\n    {\n\tint idx;\n\n\t// Go over the blocks that this function was defined in.  If the\n\t// variable block ID matches it was visible to the function.\n\tfor (idx = 0; idx < ufunc->uf_block_depth; ++idx)\n\t    if (ufunc->uf_block_ids[idx] == sav->sav_block_id)\n\t\treturn sav;\n\tsav = sav->sav_next;\n    }\n\n    // Not found, variable was not visible.\n    return NULL;\n}\n\n/*\n * Return TRUE if the script context is Vim9 script.\n */\n    int\nscript_is_vim9()\n{\n    return SCRIPT_ITEM(current_sctx.sc_sid)->sn_version == SCRIPT_VERSION_VIM9;\n}\n\n/*\n * Lookup a variable (without s: prefix) in the current script.\n * \"cctx\" is NULL at the script level, \"cstack\" is NULL in a function.\n * Returns OK or FAIL.\n */\n    int\nscript_var_exists(char_u *name, size_t len, cctx_T *cctx, cstack_T *cstack)\n{\n    if (current_sctx.sc_sid <= 0)\n\treturn FAIL;\n    if (script_is_vim9())\n    {\n\t// Check script variables that were visible where the function was\n\t// defined.\n\tif (find_script_var(name, len, cctx, cstack) != NULL)\n\t    return OK;\n    }\n    else\n    {\n\thashtab_T\t*ht = &SCRIPT_VARS(current_sctx.sc_sid);\n\tdictitem_T\t*di;\n\tint\t\tcc;\n\n\t// Check script variables that are currently visible\n\tcc = name[len];\n\tname[len] = NUL;\n\tdi = find_var_in_ht(ht, 0, name, TRUE);\n\tname[len] = cc;\n\tif (di != NULL)\n\t    return OK;\n    }\n\n    return FAIL;\n}\n\n/*\n * Return TRUE if \"name\" is a local variable, argument, script variable or\n * imported.\n */\n    static int\nvariable_exists(char_u *name, size_t len, cctx_T *cctx)\n{\n    return (cctx != NULL\n\t\t&& (lookup_local(name, len, NULL, cctx) == OK\n\t\t    || arg_exists(name, len, NULL, NULL, NULL, cctx) == OK))\n\t    || script_var_exists(name, len, cctx, NULL) == OK\n\t    || find_imported(name, len, FALSE) != NULL;\n}\n\n/*\n * Return TRUE if \"name\" is a local variable, argument, script variable,\n * imported or function.  Or commands are being skipped, a declaration may have\n * been skipped then.\n */\n    static int\nitem_exists(char_u *name, size_t len, int cmd UNUSED, cctx_T *cctx)\n{\n    return variable_exists(name, len, cctx);\n}\n\n/*\n * Check if \"p[len]\" is already defined, either in script \"import_sid\" or in\n * compilation context \"cctx\".\n * \"cctx\" is NULL at the script level, \"cstack\" is NULL in a function.\n * Does not check the global namespace.\n * If \"is_arg\" is TRUE the error message is for an argument name.\n * Return FAIL and give an error if it defined.\n */\n    int\ncheck_defined(\n\tchar_u\t    *p,\n\tsize_t\t    len,\n\tcctx_T\t    *cctx,\n\tcstack_T    *cstack,\n\tint\t    is_arg)\n{\n    int\t\tc = p[len];\n    ufunc_T\t*ufunc = NULL;\n\n    // underscore argument is OK\n    if (len == 1 && *p == '_')\n\treturn OK;\n\n    if (script_var_exists(p, len, cctx, cstack) == OK)\n    {\n\tif (is_arg)\n\t    semsg(_(e_argument_already_declared_in_script_str), p);\n\telse\n\t    semsg(_(e_variable_already_declared_in_script_str), p);\n\treturn FAIL;\n    }\n\n    p[len] = NUL;\n    if ((cctx != NULL\n\t\t&& (lookup_local(p, len, NULL, cctx) == OK\n\t\t    || arg_exists(p, len, NULL, NULL, NULL, cctx) == OK))\n\t    || find_imported(p, len, FALSE) != NULL\n\t    || (ufunc = find_func_even_dead(p, 0)) != NULL)\n    {\n\t// A local or script-local function can shadow a global function.\n\tif (ufunc == NULL || ((ufunc->uf_flags & FC_DEAD) == 0\n\t\t    && (!func_is_global(ufunc)\n\t\t\t\t\t     || (p[0] == 'g' && p[1] == ':'))))\n\t{\n\t    if (is_arg)\n\t\tsemsg(_(e_argument_name_shadows_existing_variable_str), p);\n\t    else\n\t\tsemsg(_(e_name_already_defined_str), p);\n\t    p[len] = c;\n\t    return FAIL;\n\t}\n    }\n    p[len] = c;\n    return OK;\n}\n\n\n/*\n * Return TRUE if \"actual\" could be \"expected\" and a runtime typecheck is to be\n * used.  Return FALSE if the types will never match.\n */\n    static int\nuse_typecheck(type_T *actual, type_T *expected)\n{\n    if (actual->tt_type == VAR_ANY\n\t    || actual->tt_type == VAR_UNKNOWN\n\t    || (actual->tt_type == VAR_FUNC\n\t\t&& (expected->tt_type == VAR_FUNC\n\t\t\t\t\t   || expected->tt_type == VAR_PARTIAL)\n\t\t&& (actual->tt_member == &t_any\n\t\t    || actual->tt_member == &t_unknown\n\t\t    || actual->tt_argcount < 0)\n\t\t&& (actual->tt_member == &t_unknown ||\n\t\t    (actual->tt_member == &t_void)\n\t\t\t\t\t == (expected->tt_member == &t_void))))\n\treturn TRUE;\n    if ((actual->tt_type == VAR_LIST || actual->tt_type == VAR_DICT)\n\t\t\t\t       && actual->tt_type == expected->tt_type)\n\t// This takes care of a nested list or dict.\n\treturn use_typecheck(actual->tt_member, expected->tt_member);\n    return FALSE;\n}\n\n/*\n * Check that\n * - \"actual\" matches \"expected\" type or\n * - \"actual\" is a type that can be \"expected\" type: add a runtime check; or\n * - return FAIL.\n * If \"actual_is_const\" is TRUE then the type won't change at runtime, do not\n * generate a TYPECHECK.\n */\n    int\nneed_type_where(\n\ttype_T\t*actual,\n\ttype_T\t*expected,\n\tint\toffset,\n\twhere_T\twhere,\n\tcctx_T\t*cctx,\n\tint\tsilent,\n\tint\tactual_is_const)\n{\n    int ret;\n\n    if (expected == &t_bool && actual != &t_bool\n\t\t\t\t\t&& (actual->tt_flags & TTFLAG_BOOL_OK))\n    {\n\t// Using \"0\", \"1\" or the result of an expression with \"&&\" or \"||\" as a\n\t// boolean is OK but requires a conversion.\n\tgenerate_2BOOL(cctx, FALSE, offset);\n\treturn OK;\n    }\n\n    ret = check_type_maybe(expected, actual, FALSE, where);\n    if (ret == OK)\n\treturn OK;\n\n    // If actual a constant a runtime check makes no sense.  If it's\n    // null_function it is OK.\n    if (actual_is_const && ret == MAYBE && actual == &t_func_unknown)\n\treturn OK;\n\n    // If the actual type can be the expected type add a runtime check.\n    if (!actual_is_const && ret == MAYBE && use_typecheck(actual, expected))\n    {\n\tgenerate_TYPECHECK(cctx, expected, offset,\n\t\t\t\t\t    where.wt_variable, where.wt_index);\n\treturn OK;\n    }\n\n    if (!silent)\n\ttype_mismatch_where(expected, actual, where);\n    return FAIL;\n}\n\n    int\nneed_type(\n\ttype_T\t*actual,\n\ttype_T\t*expected,\n\tint\toffset,\n\tint\targ_idx,\n\tcctx_T\t*cctx,\n\tint\tsilent,\n\tint\tactual_is_const)\n{\n    where_T where = WHERE_INIT;\n\n    where.wt_index = arg_idx;\n    return need_type_where(actual, expected, offset, where,\n\t\t\t\t\t\tcctx, silent, actual_is_const);\n}\n\n/*\n * Reserve space for a local variable.\n * Return the variable or NULL if it failed.\n */\n    lvar_T *\nreserve_local(\n\tcctx_T\t*cctx,\n\tchar_u\t*name,\n\tsize_t\tlen,\n\tint\tisConst,\n\ttype_T\t*type)\n{\n    lvar_T  *lvar;\n    dfunc_T *dfunc;\n\n    if (arg_exists(name, len, NULL, NULL, NULL, cctx) == OK)\n    {\n\temsg_namelen(_(e_str_is_used_as_argument), name, (int)len);\n\treturn NULL;\n    }\n\n    if (GA_GROW_FAILS(&cctx->ctx_locals, 1))\n\treturn NULL;\n    lvar = ((lvar_T *)cctx->ctx_locals.ga_data) + cctx->ctx_locals.ga_len++;\n    CLEAR_POINTER(lvar);\n\n    // Every local variable uses the next entry on the stack.  We could re-use\n    // the last ones when leaving a scope, but then variables used in a closure\n    // might get overwritten.  To keep things simple do not re-use stack\n    // entries.  This is less efficient, but memory is cheap these days.\n    dfunc = ((dfunc_T *)def_functions.ga_data) + cctx->ctx_ufunc->uf_dfunc_idx;\n    lvar->lv_idx = dfunc->df_var_names.ga_len;\n\n    lvar->lv_name = vim_strnsave(name, len == 0 ? STRLEN(name) : len);\n    lvar->lv_const = isConst;\n    lvar->lv_type = type;\n\n    // Remember the name for debugging.\n    if (GA_GROW_FAILS(&dfunc->df_var_names, 1))\n\treturn NULL;\n    ((char_u **)dfunc->df_var_names.ga_data)[lvar->lv_idx] =\n\t\t\t\t\t\t    vim_strsave(lvar->lv_name);\n    ++dfunc->df_var_names.ga_len;\n\n    return lvar;\n}\n\n/*\n * If \"check_writable\" is ASSIGN_CONST give an error if the variable was\n * defined with :final or :const, if \"check_writable\" is ASSIGN_FINAL give an\n * error if the variable was defined with :const.\n */\n    static int\ncheck_item_writable(svar_T *sv, int check_writable, char_u *name)\n{\n    if ((check_writable == ASSIGN_CONST && sv->sv_const != 0)\n\t    || (check_writable == ASSIGN_FINAL\n\t\t\t\t\t      && sv->sv_const == ASSIGN_CONST))\n    {\n\tsemsg(_(e_cannot_change_readonly_variable_str), name);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Find \"name\" in script-local items of script \"sid\".\n * Pass \"check_writable\" to check_item_writable().\n * \"cctx\" is NULL at the script level, \"cstack\" is NULL in a function.\n * Returns the index in \"sn_var_vals\" if found.\n * If found but not in \"sn_var_vals\" returns -1.\n * If not found or the variable is not writable returns -2.\n */\n    int\nget_script_item_idx(\n\tint\t    sid,\n\tchar_u\t    *name,\n\tint\t    check_writable,\n\tcctx_T\t    *cctx,\n\tcstack_T    *cstack)\n{\n    hashtab_T\t    *ht;\n    dictitem_T\t    *di;\n    scriptitem_T    *si = SCRIPT_ITEM(sid);\n    svar_T\t    *sv;\n    int\t\t    idx;\n\n    if (!SCRIPT_ID_VALID(sid))\n\treturn -1;\n    if (sid == current_sctx.sc_sid)\n    {\n\tsallvar_T *sav = find_script_var(name, 0, cctx, cstack);\n\n\tif (sav == NULL)\n\t    return -2;\n\tidx = sav->sav_var_vals_idx;\n\tsv = ((svar_T *)si->sn_var_vals.ga_data) + idx;\n\tif (check_item_writable(sv, check_writable, name) == FAIL)\n\t    return -2;\n\treturn idx;\n    }\n\n    // First look the name up in the hashtable.\n    ht = &SCRIPT_VARS(sid);\n    di = find_var_in_ht(ht, 0, name, TRUE);\n    if (di == NULL)\n    {\n\tif (si->sn_autoload_prefix != NULL)\n\t{\n\t    hashitem_T *hi;\n\n\t    // A variable exported from an autoload script is in the global\n\t    // variables, we can find it in the all_vars table.\n\t    hi = hash_find(&si->sn_all_vars.dv_hashtab, name);\n\t    if (!HASHITEM_EMPTY(hi))\n\t\treturn HI2SAV(hi)->sav_var_vals_idx;\n\t}\n\treturn -2;\n    }\n\n    // Now find the svar_T index in sn_var_vals.\n    for (idx = 0; idx < si->sn_var_vals.ga_len; ++idx)\n    {\n\tsv = ((svar_T *)si->sn_var_vals.ga_data) + idx;\n\tif (sv->sv_tv == &di->di_tv)\n\t{\n\t    if (check_item_writable(sv, check_writable, name) == FAIL)\n\t\treturn -2;\n\t    return idx;\n\t}\n    }\n    return -1;\n}\n\n    static imported_T *\nfind_imported_in_script(char_u *name, size_t len, int sid)\n{\n    scriptitem_T    *si;\n    int\t\t    idx;\n\n    if (!SCRIPT_ID_VALID(sid))\n\treturn NULL;\n    si = SCRIPT_ITEM(sid);\n    for (idx = 0; idx < si->sn_imports.ga_len; ++idx)\n    {\n\timported_T *import = ((imported_T *)si->sn_imports.ga_data) + idx;\n\n\tif (len == 0 ? STRCMP(name, import->imp_name) == 0\n\t\t     : STRLEN(import->imp_name) == len\n\t\t\t\t  && STRNCMP(name, import->imp_name, len) == 0)\n\t    return import;\n    }\n    return NULL;\n}\n\n/*\n * Find \"name\" in imported items of the current script.\n * If \"len\" is 0 use any length that works.\n * If \"load\" is TRUE and the script was not loaded yet, load it now.\n */\n    imported_T *\nfind_imported(char_u *name, size_t len, int load)\n{\n    imported_T\t    *ret;\n\n    if (!SCRIPT_ID_VALID(current_sctx.sc_sid))\n\treturn NULL;\n\n    ret = find_imported_in_script(name, len, current_sctx.sc_sid);\n    if (ret != NULL && load && (ret->imp_flags & IMP_FLAGS_AUTOLOAD))\n    {\n\tscid_T\tdummy;\n\tint\tsave_emsg_off = emsg_off;\n\n\t// \"emsg_off\" will be set when evaluating an expression silently, but\n\t// we do want to know about errors in a script.  Also because it then\n\t// aborts when an error is encountered.\n\temsg_off = FALSE;\n\n\t// script found before but not loaded yet\n\tret->imp_flags &= ~IMP_FLAGS_AUTOLOAD;\n\t(void)do_source(SCRIPT_ITEM(ret->imp_sid)->sn_name, FALSE,\n\t\t\t\t\t\t\t    DOSO_NONE, &dummy);\n\n\temsg_off = save_emsg_off;\n    }\n    return ret;\n}\n\n/*\n * Called when checking for a following operator at \"arg\".  When the rest of\n * the line is empty or only a comment, peek the next line.  If there is a next\n * line return a pointer to it and set \"nextp\".\n * Otherwise skip over white space.\n */\n    char_u *\nmay_peek_next_line(cctx_T *cctx, char_u *arg, char_u **nextp)\n{\n    char_u *p = skipwhite(arg);\n\n    *nextp = NULL;\n    if (*p == NUL || (VIM_ISWHITE(*arg) && vim9_comment_start(p)))\n    {\n\t*nextp = peek_next_line_from_context(cctx);\n\tif (*nextp != NULL)\n\t    return *nextp;\n    }\n    return p;\n}\n\n/*\n * Return a pointer to the next line that isn't empty or only contains a\n * comment. Skips over white space.\n * Returns NULL if there is none.\n */\n    char_u *\npeek_next_line_from_context(cctx_T *cctx)\n{\n    int lnum = cctx->ctx_lnum;\n\n    while (++lnum < cctx->ctx_ufunc->uf_lines.ga_len)\n    {\n\tchar_u *line = ((char_u **)cctx->ctx_ufunc->uf_lines.ga_data)[lnum];\n\tchar_u *p;\n\n\t// ignore NULLs inserted for continuation lines\n\tif (line != NULL)\n\t{\n\t    p = skipwhite(line);\n\t    if (vim9_bad_comment(p))\n\t\treturn NULL;\n\t    if (*p != NUL && !vim9_comment_start(p))\n\t\treturn p;\n\t}\n    }\n    return NULL;\n}\n\n/*\n * Get the next line of the function from \"cctx\".\n * Skips over empty lines.  Skips over comment lines if \"skip_comment\" is TRUE.\n * Returns NULL when at the end.\n */\n    char_u *\nnext_line_from_context(cctx_T *cctx, int skip_comment)\n{\n    char_u\t*line;\n\n    do\n    {\n\t++cctx->ctx_lnum;\n\tif (cctx->ctx_lnum >= cctx->ctx_ufunc->uf_lines.ga_len)\n\t{\n\t    line = NULL;\n\t    break;\n\t}\n\tline = ((char_u **)cctx->ctx_ufunc->uf_lines.ga_data)[cctx->ctx_lnum];\n\tcctx->ctx_line_start = line;\n\tSOURCING_LNUM = cctx->ctx_lnum + 1;\n    } while (line == NULL || *skipwhite(line) == NUL\n\t\t     || (skip_comment && vim9_comment_start(skipwhite(line))));\n    return line;\n}\n\n/*\n * Skip over white space at \"whitep\" and assign to \"*arg\".\n * If \"*arg\" is at the end of the line, advance to the next line.\n * Also when \"whitep\" points to white space and \"*arg\" is on a \"#\".\n * Return FAIL if beyond the last line, \"*arg\" is unmodified then.\n */\n    int\nmay_get_next_line(char_u *whitep, char_u **arg, cctx_T *cctx)\n{\n    *arg = skipwhite(whitep);\n    if (vim9_bad_comment(*arg))\n\treturn FAIL;\n    if (**arg == NUL || (VIM_ISWHITE(*whitep) && vim9_comment_start(*arg)))\n    {\n\tchar_u *next = next_line_from_context(cctx, TRUE);\n\n\tif (next == NULL)\n\t    return FAIL;\n\t*arg = skipwhite(next);\n    }\n    return OK;\n}\n\n/*\n * Idem, and give an error when failed.\n */\n    int\nmay_get_next_line_error(char_u *whitep, char_u **arg, cctx_T *cctx)\n{\n    if (may_get_next_line(whitep, arg, cctx) == FAIL)\n    {\n\tSOURCING_LNUM = cctx->ctx_lnum + 1;\n\temsg(_(e_line_incomplete));\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Get a line from the compilation context, compatible with exarg_T getline().\n * Return a pointer to the line in allocated memory.\n * Return NULL for end-of-file or some error.\n */\n    static char_u *\nexarg_getline(\n\tint c UNUSED,\n\tvoid *cookie,\n\tint indent UNUSED,\n\tgetline_opt_T options UNUSED)\n{\n    cctx_T  *cctx = (cctx_T *)cookie;\n    char_u  *p;\n\n    for (;;)\n    {\n\tif (cctx->ctx_lnum >= cctx->ctx_ufunc->uf_lines.ga_len - 1)\n\t    return NULL;\n\t++cctx->ctx_lnum;\n\tp = ((char_u **)cctx->ctx_ufunc->uf_lines.ga_data)[cctx->ctx_lnum];\n\t// Comment lines result in NULL pointers, skip them.\n\tif (p != NULL)\n\t    return vim_strsave(p);\n    }\n}\n\n    void\nfill_exarg_from_cctx(exarg_T *eap, cctx_T *cctx)\n{\n    eap->getline = exarg_getline;\n    eap->cookie = cctx;\n    eap->skip = cctx->ctx_skip == SKIP_YES;\n}\n\n/*\n * Return TRUE if \"ufunc\" should be compiled, taking into account whether\n * \"profile\" indicates profiling is to be done.\n */\n    int\nfunc_needs_compiling(ufunc_T *ufunc, compiletype_T compile_type)\n{\n    switch (ufunc->uf_def_status)\n    {\n\tcase UF_TO_BE_COMPILED:\n\t    return TRUE;\n\n\tcase UF_COMPILED:\n\t{\n\t    dfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\n\t    switch (compile_type)\n\t    {\n\t\tcase CT_PROFILE:\n#ifdef FEAT_PROFILE\n\t\t    return dfunc->df_instr_prof == NULL;\n#endif\n\t\tcase CT_NONE:\n\t\t    return dfunc->df_instr == NULL;\n\t\tcase CT_DEBUG:\n\t\t    return dfunc->df_instr_debug == NULL;\n\t    }\n\t}\n\n\tcase UF_NOT_COMPILED:\n\tcase UF_COMPILE_ERROR:\n\tcase UF_COMPILING:\n\t    break;\n    }\n    return FALSE;\n}\n\n/*\n * Compile a nested :def command.\n */\n    static char_u *\ncompile_nested_function(exarg_T *eap, cctx_T *cctx, garray_T *lines_to_free)\n{\n    int\t\tis_global = *eap->arg == 'g' && eap->arg[1] == ':';\n    char_u\t*name_start = eap->arg;\n    char_u\t*name_end = to_name_end(eap->arg, TRUE);\n    int\t\toff;\n    char_u\t*func_name;\n    char_u\t*lambda_name;\n    ufunc_T\t*ufunc;\n    int\t\tr = FAIL;\n    compiletype_T   compile_type;\n    isn_T\t*funcref_isn = NULL;\n    lvar_T\t*lvar = NULL;\n\n    if (eap->forceit)\n    {\n\temsg(_(e_cannot_use_bang_with_nested_def));\n\treturn NULL;\n    }\n\n    if (*name_start == '/')\n    {\n\tname_end = skip_regexp(name_start + 1, '/', TRUE);\n\tif (*name_end == '/')\n\t    ++name_end;\n\tset_nextcmd(eap, name_end);\n    }\n    if (name_end == name_start || *skipwhite(name_end) != '(')\n    {\n\tif (!ends_excmd2(name_start, name_end))\n\t{\n\t    if (*skipwhite(name_end) == '.')\n\t\tsemsg(_(e_cannot_define_dict_func_in_vim9_script_str),\n\t\t\t\t\t\t\t\t     eap->cmd);\n\t    else\n\t\tsemsg(_(e_invalid_command_str), eap->cmd);\n\t    return NULL;\n\t}\n\n\t// \"def\" or \"def Name\": list functions\n\tif (generate_DEF(cctx, name_start, name_end - name_start) == FAIL)\n\t    return NULL;\n\treturn eap->nextcmd == NULL ? (char_u *)\"\" : eap->nextcmd;\n    }\n\n    // Only g:Func() can use a namespace.\n    if (name_start[1] == ':' && !is_global)\n    {\n\tsemsg(_(e_namespace_not_supported_str), name_start);\n\treturn NULL;\n    }\n    if (cctx->ctx_skip != SKIP_YES\n\t    && check_defined(name_start, name_end - name_start, cctx,\n\t\t\t\t\t\t\t  NULL, FALSE) == FAIL)\n\treturn NULL;\n    if (!ASCII_ISUPPER(is_global ? name_start[2] : name_start[0]))\n    {\n\tsemsg(_(e_function_name_must_start_with_capital_str), name_start);\n\treturn NULL;\n    }\n\n    eap->arg = name_end;\n    fill_exarg_from_cctx(eap, cctx);\n\n    eap->forceit = FALSE;\n    // We use the special <Lamba>99 name, but it's not really a lambda.\n    lambda_name = vim_strsave(get_lambda_name());\n    if (lambda_name == NULL)\n\treturn NULL;\n\n    // This may free the current line, make a copy of the name.\n    off = is_global ? 2 : 0;\n    func_name = vim_strnsave(name_start + off, name_end - name_start - off);\n    if (func_name == NULL)\n    {\n\tr = FAIL;\n\tgoto theend;\n    }\n\n    ufunc = define_function(eap, lambda_name, lines_to_free);\n    if (ufunc == NULL)\n    {\n\tr = eap->skip ? OK : FAIL;\n\tgoto theend;\n    }\n    if (eap->nextcmd != NULL)\n    {\n\tsemsg(_(e_text_found_after_str_str),\n\t      eap->cmdidx == CMD_def ? \"enddef\" : \"endfunction\", eap->nextcmd);\n\tr = FAIL;\n\tfunc_ptr_unref(ufunc);\n\tgoto theend;\n    }\n\n    // copy over the block scope IDs before compiling\n    if (!is_global && cctx->ctx_ufunc->uf_block_depth > 0)\n    {\n\tint block_depth = cctx->ctx_ufunc->uf_block_depth;\n\n\tufunc->uf_block_ids = ALLOC_MULT(int, block_depth);\n\tif (ufunc->uf_block_ids != NULL)\n\t{\n\t    mch_memmove(ufunc->uf_block_ids, cctx->ctx_ufunc->uf_block_ids,\n\t\t\t\t\t\t    sizeof(int) * block_depth);\n\t    ufunc->uf_block_depth = block_depth;\n\t}\n    }\n\n    // Define the funcref before compiling, so that it is found by any\n    // recursive call.\n    if (is_global)\n    {\n\tr = generate_NEWFUNC(cctx, lambda_name, func_name);\n\tfunc_name = NULL;\n\tlambda_name = NULL;\n    }\n    else\n    {\n\t// Define a local variable for the function reference.\n\tlvar = reserve_local(cctx, func_name, name_end - name_start,\n\t\t\t\t\t\t    TRUE, ufunc->uf_func_type);\n\tif (lvar == NULL)\n\t    goto theend;\n\tif (generate_FUNCREF(cctx, ufunc, &funcref_isn) == FAIL)\n\t    goto theend;\n\tr = generate_STORE(cctx, ISN_STORE, lvar->lv_idx, NULL);\n    }\n\n    compile_type = get_compile_type(ufunc);\n#ifdef FEAT_PROFILE\n    // If the outer function is profiled, also compile the nested function for\n    // profiling.\n    if (cctx->ctx_compile_type == CT_PROFILE)\n\tcompile_type = CT_PROFILE;\n#endif\n    if (func_needs_compiling(ufunc, compile_type)\n\t    && compile_def_function(ufunc, TRUE, compile_type, cctx) == FAIL)\n    {\n\tfunc_ptr_unref(ufunc);\n\tif (lvar != NULL)\n\t    // Now the local variable can't be used.\n\t    *lvar->lv_name = '/';  // impossible value\n\tgoto theend;\n    }\n\n#ifdef FEAT_PROFILE\n    // When the outer function is compiled for profiling, the nested function\n    // may be called without profiling.  Compile it here in the right context.\n    if (compile_type == CT_PROFILE && func_needs_compiling(ufunc, CT_NONE))\n\tcompile_def_function(ufunc, FALSE, CT_NONE, cctx);\n#endif\n\n    // If a FUNCREF instruction was generated, set the index after compiling.\n    if (funcref_isn != NULL && ufunc->uf_def_status == UF_COMPILED)\n\tfuncref_isn->isn_arg.funcref.fr_dfunc_idx = ufunc->uf_dfunc_idx;\n\ntheend:\n    vim_free(lambda_name);\n    vim_free(func_name);\n    return r == FAIL ? NULL : (char_u *)\"\";\n}\n\n/*\n * Compile one Vim expression {expr} in string \"p\".\n * \"p\" points to the opening \"{\".\n * Return a pointer to the character after \"}\", NULL for an error.\n */\n    char_u *\ncompile_one_expr_in_str(char_u *p, cctx_T *cctx)\n{\n    char_u\t*block_start;\n    char_u\t*block_end;\n\n    // Skip the opening {.\n    block_start = skipwhite(p + 1);\n    block_end = block_start;\n    if (*block_start != NUL && skip_expr(&block_end, NULL) == FAIL)\n\treturn NULL;\n    block_end = skipwhite(block_end);\n    // The block must be closed by a }.\n    if (*block_end != '}')\n    {\n\tsemsg(_(e_missing_close_curly_str), p);\n\treturn NULL;\n    }\n    if (compile_expr0(&block_start, cctx) == FAIL)\n\treturn NULL;\n    may_generate_2STRING(-1, TRUE, cctx);\n\n    return block_end + 1;\n}\n\n/*\n * Compile a string \"str\" (either containing a literal string or a mix of\n * literal strings and Vim expressions of the form `{expr}`).  This is used\n * when compiling a heredoc assignment to a variable or an interpolated string\n * in a Vim9 def function.  Vim9 instructions are generated to push strings,\n * evaluate expressions, concatenate them and create a list of lines.  When\n * \"evalstr\" is TRUE, Vim expressions in \"str\" are evaluated.\n */\n    int\ncompile_all_expr_in_str(char_u *str, int evalstr, cctx_T *cctx)\n{\n    char_u\t*p = str;\n    char_u\t*val;\n    int\t\tcount = 0;\n\n    if (cctx->ctx_skip == SKIP_YES)\n\treturn OK;\n\n    if (!evalstr || *str == NUL)\n    {\n\t// Literal string, possibly empty.\n\tval = *str != NUL ? vim_strsave(str) : NULL;\n\treturn generate_PUSHS(cctx, &val);\n    }\n\n    // Push all the string pieces to the stack, followed by a ISN_CONCAT.\n    while (*p != NUL)\n    {\n\tchar_u\t*lit_start;\n\tint\tescaped_brace = FALSE;\n\n\t// Look for a block start.\n\tlit_start = p;\n\twhile (*p != '{' && *p != '}' && *p != NUL)\n\t    ++p;\n\n\tif (*p != NUL && *p == p[1])\n\t{\n\t    // Escaped brace, unescape and continue.\n\t    // Include the brace in the literal string.\n\t    ++p;\n\t    escaped_brace = TRUE;\n\t}\n\telse if (*p == '}')\n\t{\n\t    semsg(_(e_stray_closing_curly_str), str);\n\t    return FAIL;\n\t}\n\n\t// Append the literal part.\n\tif (p != lit_start)\n\t{\n\t    val = vim_strnsave(lit_start, (size_t)(p - lit_start));\n\t    if (generate_PUSHS(cctx, &val) == FAIL)\n\t\treturn FAIL;\n\t    ++count;\n\t}\n\n\tif (*p == NUL)\n\t    break;\n\n\tif (escaped_brace)\n\t{\n\t    // Skip the second brace.\n\t    ++p;\n\t    continue;\n\t}\n\n\tp = compile_one_expr_in_str(p, cctx);\n\tif (p == NULL)\n\t    return FAIL;\n\t++count;\n    }\n\n    // Small optimization, if there's only a single piece skip the ISN_CONCAT.\n    if (count > 1)\n\treturn generate_CONCAT(cctx, count);\n\n    return OK;\n}\n\n/*\n * Return the length of an assignment operator, or zero if there isn't one.\n */\n    int\nassignment_len(char_u *p, int *heredoc)\n{\n    if (*p == '=')\n    {\n\tif (p[1] == '<' && p[2] == '<')\n\t{\n\t    *heredoc = TRUE;\n\t    return 3;\n\t}\n\treturn 1;\n    }\n    if (vim_strchr((char_u *)\"+-*/%\", *p) != NULL && p[1] == '=')\n\treturn 2;\n    if (STRNCMP(p, \"..=\", 3) == 0)\n\treturn 3;\n    return 0;\n}\n\n/*\n * Generate the load instruction for \"name\".\n */\n    static void\ngenerate_loadvar(\n\tcctx_T\t\t*cctx,\n\tassign_dest_T\tdest,\n\tchar_u\t\t*name,\n\tlvar_T\t\t*lvar,\n\ttype_T\t\t*type)\n{\n    switch (dest)\n    {\n\tcase dest_option:\n\tcase dest_func_option:\n\t    generate_LOAD(cctx, ISN_LOADOPT, 0, name, type);\n\t    break;\n\tcase dest_global:\n\t    if (vim_strchr(name, AUTOLOAD_CHAR) == NULL)\n\t    {\n\t\tif (name[2] == NUL)\n\t\t    generate_instr_type(cctx, ISN_LOADGDICT, &t_dict_any);\n\t\telse\n\t\t    generate_LOAD(cctx, ISN_LOADG, 0, name + 2, type);\n\t    }\n\t    else\n\t\tgenerate_LOAD(cctx, ISN_LOADAUTO, 0, name, type);\n\t    break;\n\tcase dest_buffer:\n\t    generate_LOAD(cctx, ISN_LOADB, 0, name + 2, type);\n\t    break;\n\tcase dest_window:\n\t    generate_LOAD(cctx, ISN_LOADW, 0, name + 2, type);\n\t    break;\n\tcase dest_tab:\n\t    generate_LOAD(cctx, ISN_LOADT, 0, name + 2, type);\n\t    break;\n\tcase dest_script:\n\t    compile_load_scriptvar(cctx,\n\t\t\t\t  name + (name[1] == ':' ? 2 : 0), NULL, NULL);\n\t    break;\n\tcase dest_env:\n\t    // Include $ in the name here\n\t    generate_LOAD(cctx, ISN_LOADENV, 0, name, type);\n\t    break;\n\tcase dest_reg:\n\t    generate_LOAD(cctx, ISN_LOADREG, name[1], NULL, &t_string);\n\t    break;\n\tcase dest_vimvar:\n\t    generate_LOADV(cctx, name + 2);\n\t    break;\n\tcase dest_local:\n\t    if (lvar->lv_from_outer > 0)\n\t\tgenerate_LOADOUTER(cctx, lvar->lv_idx, lvar->lv_from_outer,\n\t\t\t\t\t\t\t\t\t type);\n\t    else\n\t\tgenerate_LOAD(cctx, ISN_LOAD, lvar->lv_idx, NULL, type);\n\t    break;\n\tcase dest_expr:\n\t    // list or dict value should already be on the stack.\n\t    break;\n    }\n}\n\n/*\n * Skip over \"[expr]\" or \".member\".\n * Does not check for any errors.\n */\n    static char_u *\nskip_index(char_u *start)\n{\n    char_u *p = start;\n\n    if (*p == '[')\n    {\n\tp = skipwhite(p + 1);\n\t(void)skip_expr(&p, NULL);\n\tp = skipwhite(p);\n\tif (*p == ']')\n\t    return p + 1;\n\treturn p;\n    }\n    // if (*p == '.')\n    return to_name_end(p + 1, TRUE);\n}\n\n    void\nvim9_declare_error(char_u *name)\n{\n    char *scope = \"\";\n\n    switch (*name)\n    {\n\tcase 'g': scope = _(\"global\"); break;\n\tcase 'b': scope = _(\"buffer\"); break;\n\tcase 'w': scope = _(\"window\"); break;\n\tcase 't': scope = _(\"tab\"); break;\n\tcase 'v': scope = \"v:\"; break;\n\tcase '$': semsg(_(e_cannot_declare_an_environment_variable), name);\n\t\t  return;\n\tcase '&': semsg(_(e_cannot_declare_an_option), name);\n\t\t  return;\n\tcase '@': semsg(_(e_cannot_declare_a_register_str), name);\n\t\t  return;\n\tdefault: return;\n    }\n    semsg(_(e_cannot_declare_a_scope_variable), scope, name);\n}\n\n/*\n * For one assignment figure out the type of destination.  Return it in \"dest\".\n * When not recognized \"dest\" is not set.\n * For an option \"option_scope\" is set.\n * For a v:var \"vimvaridx\" is set.\n * \"type\" is set to the destination type if known, unchanted otherwise.\n * Return FAIL if an error message was given.\n */\n    int\nget_var_dest(\n\tchar_u\t\t*name,\n\tassign_dest_T\t*dest,\n\tcmdidx_T\tcmdidx,\n\tint\t\t*option_scope,\n\tint\t\t*vimvaridx,\n\ttype_T\t\t**type,\n\tcctx_T\t\t*cctx)\n{\n    char_u *p;\n\n    if (*name == '&')\n    {\n\tint\t\tcc;\n\tlong\t\tnumval;\n\tgetoption_T\topt_type;\n\tint\t\topt_p_flags;\n\n\t*dest = dest_option;\n\tif (cmdidx == CMD_final || cmdidx == CMD_const)\n\t{\n\t    emsg(_(e_cannot_lock_option));\n\t    return FAIL;\n\t}\n\tp = name;\n\tp = find_option_end(&p, option_scope);\n\tif (p == NULL)\n\t{\n\t    // cannot happen?\n\t    emsg(_(e_unexpected_characters_in_assignment));\n\t    return FAIL;\n\t}\n\tcc = *p;\n\t*p = NUL;\n\topt_type = get_option_value(skip_option_env_lead(name),\n\t\t\t\t   &numval, NULL, &opt_p_flags, *option_scope);\n\t*p = cc;\n\tswitch (opt_type)\n\t{\n\t    case gov_unknown:\n\t\t    semsg(_(e_unknown_option_str), name);\n\t\t    return FAIL;\n\t    case gov_string:\n\t    case gov_hidden_string:\n\t\t    if (opt_p_flags & P_FUNC)\n\t\t    {\n\t\t\t// might be a Funcref, check the type later\n\t\t\t*type = &t_any;\n\t\t\t*dest = dest_func_option;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t*type = &t_string;\n\t\t    }\n\t\t    break;\n\t    case gov_bool:\n\t    case gov_hidden_bool:\n\t\t    *type = &t_bool;\n\t\t    break;\n\t    case gov_number:\n\t    case gov_hidden_number:\n\t\t    *type = &t_number;\n\t\t    break;\n\t}\n    }\n    else if (*name == '$')\n    {\n\t*dest = dest_env;\n\t*type = &t_string;\n    }\n    else if (*name == '@')\n    {\n\tif (name[1] != '@'\n\t\t\t&& (!valid_yank_reg(name[1], FALSE) || name[1] == '.'))\n\t{\n\t    emsg_invreg(name[1]);\n\t    return FAIL;\n\t}\n\t*dest = dest_reg;\n\t*type = name[1] == '#' ? &t_number_or_string : &t_string;\n    }\n    else if (STRNCMP(name, \"g:\", 2) == 0)\n    {\n\t*dest = dest_global;\n    }\n    else if (STRNCMP(name, \"b:\", 2) == 0)\n    {\n\t*dest = dest_buffer;\n    }\n    else if (STRNCMP(name, \"w:\", 2) == 0)\n    {\n\t*dest = dest_window;\n    }\n    else if (STRNCMP(name, \"t:\", 2) == 0)\n    {\n\t*dest = dest_tab;\n    }\n    else if (STRNCMP(name, \"v:\", 2) == 0)\n    {\n\ttypval_T\t*vtv;\n\tint\t\tdi_flags;\n\n\t*vimvaridx = find_vim_var(name + 2, &di_flags);\n\tif (*vimvaridx < 0)\n\t{\n\t    semsg(_(e_variable_not_found_str), name);\n\t    return FAIL;\n\t}\n\t// We use the current value of \"sandbox\" here, is that OK?\n\tif (var_check_ro(di_flags, name, FALSE))\n\t    return FAIL;\n\t*dest = dest_vimvar;\n\tvtv = get_vim_var_tv(*vimvaridx);\n\t*type = typval2type_vimvar(vtv, cctx->ctx_type_list);\n    }\n    return OK;\n}\n\n    static int\nis_decl_command(cmdidx_T cmdidx)\n{\n    return cmdidx == CMD_let || cmdidx == CMD_var\n\t\t\t\t || cmdidx == CMD_final || cmdidx == CMD_const;\n}\n\n/*\n * Figure out the LHS type and other properties for an assignment or one item\n * of \":unlet\" with an index.\n * Returns OK or FAIL.\n */\n    int\ncompile_lhs(\n\tchar_u\t    *var_start,\n\tlhs_T\t    *lhs,\n\tcmdidx_T    cmdidx,\n\tint\t    heredoc,\n\tint\t    has_cmd,\t    // \"var\" before \"var_start\"\n\tint\t    oplen,\n\tcctx_T\t    *cctx)\n{\n    char_u\t*var_end;\n    int\t\tis_decl = is_decl_command(cmdidx);\n\n    CLEAR_POINTER(lhs);\n    lhs->lhs_dest = dest_local;\n    lhs->lhs_vimvaridx = -1;\n    lhs->lhs_scriptvar_idx = -1;\n\n    // \"dest_end\" is the end of the destination, including \"[expr]\" or\n    // \".name\".\n    // \"var_end\" is the end of the variable/option/etc. name.\n    lhs->lhs_dest_end = skip_var_one(var_start, FALSE);\n    if (*var_start == '@')\n\tvar_end = var_start + 2;\n    else\n    {\n\t// skip over the leading \"&\", \"&l:\", \"&g:\" and \"$\"\n\tvar_end = skip_option_env_lead(var_start);\n\tvar_end = to_name_end(var_end, TRUE);\n    }\n\n    // \"a: type\" is declaring variable \"a\" with a type, not dict \"a:\".\n    if (is_decl && lhs->lhs_dest_end == var_start + 2\n\t\t\t\t\t       && lhs->lhs_dest_end[-1] == ':')\n\t--lhs->lhs_dest_end;\n    if (is_decl && var_end == var_start + 2 && var_end[-1] == ':')\n\t--var_end;\n    lhs->lhs_end = lhs->lhs_dest_end;\n\n    // compute the length of the destination without \"[expr]\" or \".name\"\n    lhs->lhs_varlen = var_end - var_start;\n    lhs->lhs_varlen_total = lhs->lhs_varlen;\n    lhs->lhs_name = vim_strnsave(var_start, lhs->lhs_varlen);\n    if (lhs->lhs_name == NULL)\n\treturn FAIL;\n\n    if (lhs->lhs_dest_end > var_start + lhs->lhs_varlen)\n\t// Something follows after the variable: \"var[idx]\" or \"var.key\".\n\tlhs->lhs_has_index = TRUE;\n\n    if (heredoc)\n\tlhs->lhs_type = &t_list_string;\n    else\n\tlhs->lhs_type = &t_any;\n\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n\tint\t    declare_error = FALSE;\n\n\tif (get_var_dest(lhs->lhs_name, &lhs->lhs_dest, cmdidx,\n\t\t\t\t      &lhs->lhs_opt_flags, &lhs->lhs_vimvaridx,\n\t\t\t\t\t\t &lhs->lhs_type, cctx) == FAIL)\n\t    return FAIL;\n\tif (lhs->lhs_dest != dest_local\n\t\t\t\t && cmdidx != CMD_const && cmdidx != CMD_final)\n\t{\n\t    // Specific kind of variable recognized.\n\t    declare_error = is_decl;\n\t}\n\telse\n\t{\n\t    // No specific kind of variable recognized, just a name.\n\t    if (check_reserved_name(lhs->lhs_name) == FAIL)\n\t\treturn FAIL;\n\n\t    if (lookup_local(var_start, lhs->lhs_varlen,\n\t\t\t\t\t     &lhs->lhs_local_lvar, cctx) == OK)\n\t\tlhs->lhs_lvar = &lhs->lhs_local_lvar;\n\t    else\n\t    {\n\t\tCLEAR_FIELD(lhs->lhs_arg_lvar);\n\t\tif (arg_exists(var_start, lhs->lhs_varlen,\n\t\t\t &lhs->lhs_arg_lvar.lv_idx, &lhs->lhs_arg_lvar.lv_type,\n\t\t\t    &lhs->lhs_arg_lvar.lv_from_outer, cctx) == OK)\n\t\t{\n\t\t    if (is_decl)\n\t\t    {\n\t\t\tsemsg(_(e_str_is_used_as_argument), lhs->lhs_name);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    lhs->lhs_lvar = &lhs->lhs_arg_lvar;\n\t\t}\n\t    }\n\t    if (lhs->lhs_lvar != NULL)\n\t    {\n\t\tif (is_decl)\n\t\t{\n\t\t    semsg(_(e_variable_already_declared), lhs->lhs_name);\n\t\t    return FAIL;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tint script_namespace = lhs->lhs_varlen > 1\n\t\t\t\t       && STRNCMP(var_start, \"s:\", 2) == 0;\n\t\tint script_var = (script_namespace\n\t\t\t? script_var_exists(var_start + 2, lhs->lhs_varlen - 2,\n\t\t\t\t\t\t\t\t    cctx, NULL)\n\t\t\t  : script_var_exists(var_start, lhs->lhs_varlen,\n\t\t\t\t\t\t\t    cctx, NULL)) == OK;\n\t\timported_T  *import =\n\t\t\t      find_imported(var_start, lhs->lhs_varlen, FALSE);\n\n\t\tif (script_namespace || script_var || import != NULL)\n\t\t{\n\t\t    char_u\t*rawname = lhs->lhs_name\n\t\t\t\t\t   + (lhs->lhs_name[1] == ':' ? 2 : 0);\n\n\t\t    if (script_namespace && current_script_is_vim9())\n\t\t    {\n\t\t\tsemsg(_(e_cannot_use_s_colon_in_vim9_script_str),\n\t\t\t\t\t\t\t\t    var_start);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    if (is_decl)\n\t\t    {\n\t\t\tif (script_namespace)\n\t\t\t    semsg(_(e_cannot_declare_script_variable_in_function_str),\n\t\t\t\t\t\t\t\tlhs->lhs_name);\n\t\t\telse\n\t\t\t    semsg(_(e_variable_already_declared_in_script_str),\n\t\t\t\t\t\t\t\tlhs->lhs_name);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    else if (cctx->ctx_ufunc->uf_script_ctx_version\n\t\t\t\t\t\t\t == SCRIPT_VERSION_VIM9\n\t\t\t\t    && script_namespace\n\t\t\t\t    && !script_var && import == NULL)\n\t\t    {\n\t\t\tsemsg(_(e_unknown_variable_str), lhs->lhs_name);\n\t\t\treturn FAIL;\n\t\t    }\n\n\t\t    lhs->lhs_dest = dest_script;\n\n\t\t    // existing script-local variables should have a type\n\t\t    lhs->lhs_scriptvar_sid = current_sctx.sc_sid;\n\t\t    if (import != NULL)\n\t\t    {\n\t\t\tchar_u\t*dot = vim_strchr(var_start, '.');\n\t\t\tchar_u\t*p;\n\n\t\t\t// for an import the name is what comes after the dot\n\t\t\tif (dot == NULL)\n\t\t\t{\n\t\t\t    semsg(_(e_no_dot_after_imported_name_str),\n\t\t\t\t\t\t\t\t    var_start);\n\t\t\t    return FAIL;\n\t\t\t}\n\t\t\tp = skipwhite(dot + 1);\n\t\t\tvar_end = to_name_end(p, TRUE);\n\t\t\tif (var_end == p)\n\t\t\t{\n\t\t\t    semsg(_(e_missing_name_after_imported_name_str),\n\t\t\t\t\t\t\t\t    var_start);\n\t\t\t    return FAIL;\n\t\t\t}\n\t\t\tvim_free(lhs->lhs_name);\n\t\t\tlhs->lhs_varlen = var_end - p;\n\t\t\tlhs->lhs_name = vim_strnsave(p, lhs->lhs_varlen);\n\t\t\tif (lhs->lhs_name == NULL)\n\t\t\t    return FAIL;\n\t\t\trawname = lhs->lhs_name;\n\t\t\tlhs->lhs_scriptvar_sid = import->imp_sid;\n\t\t\t// TODO: where do we check this name is exported?\n\n\t\t\t// Check if something follows: \"exp.var[idx]\" or\n\t\t\t// \"exp.var.key\".\n\t\t\tlhs->lhs_has_index = lhs->lhs_dest_end\n\t\t\t\t\t\t\t  > skipwhite(var_end);\n\t\t    }\n\t\t    if (SCRIPT_ID_VALID(lhs->lhs_scriptvar_sid))\n\t\t    {\n\t\t\t// Check writable only when no index follows.\n\t\t\tlhs->lhs_scriptvar_idx = get_script_item_idx(\n\t\t\t\t\t       lhs->lhs_scriptvar_sid, rawname,\n\t\t\t      lhs->lhs_has_index ? ASSIGN_FINAL : ASSIGN_CONST,\n\t\t\t\t\t\t\t\t   cctx, NULL);\n\t\t\tif (lhs->lhs_scriptvar_idx >= 0)\n\t\t\t{\n\t\t\t    scriptitem_T *si = SCRIPT_ITEM(\n\t\t\t\t\t\t       lhs->lhs_scriptvar_sid);\n\t\t\t    svar_T\t *sv =\n\t\t\t\t\t    ((svar_T *)si->sn_var_vals.ga_data)\n\t\t\t\t\t\t      + lhs->lhs_scriptvar_idx;\n\t\t\t    lhs->lhs_type = sv->sv_type;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse if (check_defined(var_start, lhs->lhs_varlen, cctx,\n\t\t\t\t\t\t\t  NULL, FALSE) == FAIL)\n\t\t    return FAIL;\n\t    }\n\t}\n\n\tif (declare_error)\n\t{\n\t    vim9_declare_error(lhs->lhs_name);\n\t    return FAIL;\n\t}\n    }\n\n    // handle \"a:name\" as a name, not index \"name\" in \"a\"\n    if (lhs->lhs_varlen > 1 || var_start[lhs->lhs_varlen] != ':')\n\tvar_end = lhs->lhs_dest_end;\n\n    if (lhs->lhs_dest != dest_option && lhs->lhs_dest != dest_func_option)\n    {\n\tif (is_decl && *var_end == ':')\n\t{\n\t    char_u *p;\n\n\t    // parse optional type: \"let var: type = expr\"\n\t    if (!VIM_ISWHITE(var_end[1]))\n\t    {\n\t\tsemsg(_(e_white_space_required_after_str_str), \":\", var_end);\n\t\treturn FAIL;\n\t    }\n\t    p = skipwhite(var_end + 1);\n\t    lhs->lhs_type = parse_type(&p, cctx->ctx_type_list, TRUE);\n\t    if (lhs->lhs_type == NULL)\n\t\treturn FAIL;\n\t    lhs->lhs_has_type = TRUE;\n\t    lhs->lhs_end = p;\n\t}\n\telse if (lhs->lhs_lvar != NULL)\n\t    lhs->lhs_type = lhs->lhs_lvar->lv_type;\n    }\n\n    if (oplen == 3 && !heredoc\n\t\t   && lhs->lhs_dest != dest_global\n\t\t   && !lhs->lhs_has_index\n\t\t   && lhs->lhs_type->tt_type != VAR_STRING\n\t\t   && lhs->lhs_type->tt_type != VAR_ANY)\n    {\n\temsg(_(e_can_only_concatenate_to_string));\n\treturn FAIL;\n    }\n\n    if (lhs->lhs_lvar == NULL && lhs->lhs_dest == dest_local\n\t\t\t\t\t\t && cctx->ctx_skip != SKIP_YES)\n    {\n\tif (oplen > 1 && !heredoc)\n\t{\n\t    // +=, /=, etc. require an existing variable\n\t    semsg(_(e_cannot_use_operator_on_new_variable), lhs->lhs_name);\n\t    return FAIL;\n\t}\n\tif (!is_decl || (lhs->lhs_has_index && !has_cmd\n\t\t\t\t\t\t&& cctx->ctx_skip != SKIP_YES))\n\t{\n\t    semsg(_(e_unknown_variable_str), lhs->lhs_name);\n\t    return FAIL;\n\t}\n\n\t// Check the name is valid for a funcref.\n\tif ((lhs->lhs_type->tt_type == VAR_FUNC\n\t\t\t\t      || lhs->lhs_type->tt_type == VAR_PARTIAL)\n\t\t&& var_wrong_func_name(lhs->lhs_name, TRUE))\n\t    return FAIL;\n\n\t// New local variable.\n\tlhs->lhs_lvar = reserve_local(cctx, var_start, lhs->lhs_varlen,\n\t\t    cmdidx == CMD_final || cmdidx == CMD_const, lhs->lhs_type);\n\tif (lhs->lhs_lvar == NULL)\n\t    return FAIL;\n\tlhs->lhs_new_local = TRUE;\n    }\n\n    lhs->lhs_member_type = lhs->lhs_type;\n    if (lhs->lhs_has_index)\n    {\n\tchar_u\t*after = var_start + lhs->lhs_varlen;\n\tchar_u\t*p;\n\n\t// Something follows after the variable: \"var[idx]\" or \"var.key\".\n\tif (is_decl && cctx->ctx_skip != SKIP_YES)\n\t{\n\t    if (has_cmd)\n\t\temsg(_(e_cannot_use_index_when_declaring_variable));\n\t    else\n\t\tsemsg(_(e_unknown_variable_str), lhs->lhs_name);\n\t    return FAIL;\n\t}\n\n\t// Now: var_start[lhs->lhs_varlen] is '[' or '.'\n\t// Only the last index is used below, if there are others\n\t// before it generate code for the expression.  Thus for\n\t// \"ll[1][2]\" the expression is \"ll[1]\" and \"[2]\" is the index.\n\tfor (;;)\n\t{\n\t    p = skip_index(after);\n\t    if (*p != '[' && *p != '.')\n\t    {\n\t\tlhs->lhs_varlen_total = p - var_start;\n\t\tbreak;\n\t    }\n\t    after = p;\n\t}\n\tif (after > var_start + lhs->lhs_varlen)\n\t{\n\t    lhs->lhs_varlen = after - var_start;\n\t    lhs->lhs_dest = dest_expr;\n\t    // We don't know the type before evaluating the expression,\n\t    // use \"any\" until then.\n\t    lhs->lhs_type = &t_any;\n\t}\n\n\tif (lhs->lhs_type->tt_member == NULL)\n\t    lhs->lhs_member_type = &t_any;\n\telse\n\t    lhs->lhs_member_type = lhs->lhs_type->tt_member;\n    }\n    return OK;\n}\n\n/*\n * Figure out the LHS and check a few errors.\n */\n    int\ncompile_assign_lhs(\n\tchar_u\t    *var_start,\n\tlhs_T\t    *lhs,\n\tcmdidx_T    cmdidx,\n\tint\t    is_decl,\n\tint\t    heredoc,\n\tint\t    has_cmd,\t    // \"var\" before \"var_start\"\n\tint\t    oplen,\n\tcctx_T\t    *cctx)\n{\n    if (compile_lhs(var_start, lhs, cmdidx, heredoc, has_cmd, oplen, cctx)\n\t\t\t\t\t\t\t\t       == FAIL)\n\treturn FAIL;\n\n    if (!lhs->lhs_has_index && lhs->lhs_lvar == &lhs->lhs_arg_lvar)\n    {\n\tsemsg(_(e_cannot_assign_to_argument), lhs->lhs_name);\n\treturn FAIL;\n    }\n    if (!is_decl && lhs->lhs_lvar != NULL\n\t\t\t   && lhs->lhs_lvar->lv_const && !lhs->lhs_has_index)\n    {\n\tsemsg(_(e_cannot_assign_to_constant), lhs->lhs_name);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Return TRUE if \"lhs\" has a range index: \"[expr : expr]\".\n */\n    static int\nhas_list_index(char_u *idx_start, cctx_T *cctx)\n{\n    char_u  *p = idx_start;\n    int\t    save_skip;\n\n    if (*p != '[')\n\treturn FALSE;\n\n    p = skipwhite(p + 1);\n    if (*p == ':')\n\treturn TRUE;\n\n    save_skip = cctx->ctx_skip;\n    cctx->ctx_skip = SKIP_YES;\n    (void)compile_expr0(&p, cctx);\n    cctx->ctx_skip = save_skip;\n    return *skipwhite(p) == ':';\n}\n\n/*\n * For an assignment with an index, compile the \"idx\" in \"var[idx]\" or \"key\" in\n * \"var.key\".\n */\n    static int\ncompile_assign_index(\n\tchar_u\t*var_start,\n\tlhs_T\t*lhs,\n\tint\t*range,\n\tcctx_T\t*cctx)\n{\n    size_t\tvarlen = lhs->lhs_varlen;\n    char_u\t*p;\n    int\t\tr = OK;\n    int\t\tneed_white_before = TRUE;\n    int\t\tempty_second;\n\n    p = var_start + varlen;\n    if (*p == '[')\n    {\n\tp = skipwhite(p + 1);\n\tif (*p == ':')\n\t{\n\t    // empty first index, push zero\n\t    r = generate_PUSHNR(cctx, 0);\n\t    need_white_before = FALSE;\n\t}\n\telse\n\t    r = compile_expr0(&p, cctx);\n\n\tif (r == OK && *skipwhite(p) == ':')\n\t{\n\t    // unlet var[idx : idx]\n\t    // blob[idx : idx] = value\n\t    *range = TRUE;\n\t    p = skipwhite(p);\n\t    empty_second = *skipwhite(p + 1) == ']';\n\t    if ((need_white_before && !IS_WHITE_OR_NUL(p[-1]))\n\t\t    || (!empty_second && !IS_WHITE_OR_NUL(p[1])))\n\t    {\n\t\tsemsg(_(e_white_space_required_before_and_after_str_at_str),\n\t\t\t\t\t\t\t\t      \":\", p);\n\t\treturn FAIL;\n\t    }\n\t    p = skipwhite(p + 1);\n\t    if (*p == ']')\n\t\t// empty second index, push \"none\"\n\t\tr = generate_PUSHSPEC(cctx, VVAL_NONE);\n\t    else\n\t\tr = compile_expr0(&p, cctx);\n\t}\n\n\tif (r == OK && *skipwhite(p) != ']')\n\t{\n\t    // this should not happen\n\t    emsg(_(e_missing_closing_square_brace));\n\t    r = FAIL;\n\t}\n    }\n    else // if (*p == '.')\n    {\n\tchar_u *key_end = to_name_end(p + 1, TRUE);\n\tchar_u *key = vim_strnsave(p + 1, key_end - p - 1);\n\n\tr = generate_PUSHS(cctx, &key);\n    }\n    return r;\n}\n\n/*\n * For a LHS with an index, load the variable to be indexed.\n */\n    static int\ncompile_load_lhs(\n\tlhs_T\t*lhs,\n\tchar_u\t*var_start,\n\ttype_T\t*rhs_type,\n\tcctx_T\t*cctx)\n{\n    if (lhs->lhs_dest == dest_expr)\n    {\n\tsize_t\t    varlen = lhs->lhs_varlen;\n\tint\t    c = var_start[varlen];\n\tint\t    lines_len = cctx->ctx_ufunc->uf_lines.ga_len;\n\tchar_u\t    *p = var_start;\n\tint\t    res;\n\n\t// Evaluate \"ll[expr]\" of \"ll[expr][idx]\".  End the line with a NUL and\n\t// limit the lines array length to avoid skipping to a following line.\n\tvar_start[varlen] = NUL;\n\tcctx->ctx_ufunc->uf_lines.ga_len = cctx->ctx_lnum + 1;\n\tres = compile_expr0(&p, cctx);\n\tvar_start[varlen] = c;\n\tcctx->ctx_ufunc->uf_lines.ga_len = lines_len;\n\tif (res == FAIL || p != var_start + varlen)\n\t{\n\t    // this should not happen\n\t    if (res != FAIL)\n\t\temsg(_(e_missing_closing_square_brace));\n\t    return FAIL;\n\t}\n\n\tlhs->lhs_type = cctx->ctx_type_stack.ga_len == 0 ? &t_void\n\t\t\t\t\t\t  : get_type_on_stack(cctx, 0);\n\t// now we can properly check the type\n\tif (rhs_type != NULL && lhs->lhs_type->tt_member != NULL\n\t\t&& rhs_type != &t_void\n\t\t&& need_type(rhs_type, lhs->lhs_type->tt_member, -2, 0, cctx,\n\t\t\t\t\t\t\t FALSE, FALSE) == FAIL)\n\t    return FAIL;\n    }\n    else\n\tgenerate_loadvar(cctx, lhs->lhs_dest, lhs->lhs_name,\n\t\t\t\t\t\t lhs->lhs_lvar, lhs->lhs_type);\n    return OK;\n}\n\n/*\n * Produce code for loading \"lhs\" and also take care of an index.\n * Return OK/FAIL.\n */\n    int\ncompile_load_lhs_with_index(lhs_T *lhs, char_u *var_start, cctx_T *cctx)\n{\n    compile_load_lhs(lhs, var_start, NULL, cctx);\n\n    if (lhs->lhs_has_index)\n    {\n\tint range = FALSE;\n\n\t// Get member from list or dict.  First compile the\n\t// index value.\n\tif (compile_assign_index(var_start, lhs, &range, cctx) == FAIL)\n\t    return FAIL;\n\tif (range)\n\t{\n\t    semsg(_(e_cannot_use_range_with_assignment_operator_str),\n\t\t\t\t\t\t\t\t    var_start);\n\t    return FAIL;\n\t}\n\n\t// Get the member.\n\tif (compile_member(FALSE, NULL, cctx) == FAIL)\n\t    return FAIL;\n    }\n    return OK;\n}\n\n/*\n * Assignment to a list or dict member, or \":unlet\" for the item, using the\n * information in \"lhs\".\n * Returns OK or FAIL.\n */\n    int\ncompile_assign_unlet(\n\tchar_u\t*var_start,\n\tlhs_T\t*lhs,\n\tint\tis_assign,\n\ttype_T\t*rhs_type,\n\tcctx_T\t*cctx)\n{\n    vartype_T\tdest_type;\n    int\t\trange = FALSE;\n\n    if (compile_assign_index(var_start, lhs, &range, cctx) == FAIL)\n\treturn FAIL;\n    if (is_assign && range\n\t    && lhs->lhs_type->tt_type != VAR_LIST\n\t    && lhs->lhs_type != &t_blob\n\t    && lhs->lhs_type != &t_any)\n    {\n\tsemsg(_(e_cannot_use_range_with_assignment_str), var_start);\n\treturn FAIL;\n    }\n\n    if (lhs->lhs_type == &t_any)\n    {\n\t// Index on variable of unknown type: check at runtime.\n\tdest_type = VAR_ANY;\n    }\n    else\n    {\n\tdest_type = lhs->lhs_type->tt_type;\n\tif (dest_type == VAR_DICT && range)\n\t{\n\t    emsg(e_cannot_use_range_with_dictionary);\n\t    return FAIL;\n\t}\n\tif (dest_type == VAR_DICT\n\t\t\t      && may_generate_2STRING(-1, FALSE, cctx) == FAIL)\n\t    return FAIL;\n\tif (dest_type == VAR_LIST || dest_type == VAR_BLOB)\n\t{\n\t    type_T *type;\n\n\t    if (range)\n\t    {\n\t\ttype = get_type_on_stack(cctx, 1);\n\t\tif (need_type(type, &t_number,\n\t\t\t\t\t    -2, 0, cctx, FALSE, FALSE) == FAIL)\n\t\treturn FAIL;\n\t    }\n\t    type = get_type_on_stack(cctx, 0);\n\t    if ((dest_type != VAR_BLOB && type->tt_type != VAR_SPECIAL)\n\t\t    && need_type(type, &t_number,\n\t\t\t\t\t    -1, 0, cctx, FALSE, FALSE) == FAIL)\n\t\treturn FAIL;\n\t}\n    }\n\n    // Load the dict or list.  On the stack we then have:\n    // - value (for assignment, not for :unlet)\n    // - index\n    // - for [a : b] second index\n    // - variable\n    if (compile_load_lhs(lhs, var_start, rhs_type, cctx) == FAIL)\n\treturn FAIL;\n\n    if (dest_type == VAR_LIST || dest_type == VAR_DICT\n\t\t\t      || dest_type == VAR_BLOB || dest_type == VAR_ANY)\n    {\n\tif (is_assign)\n\t{\n\t    if (range)\n\t    {\n\t\tif (generate_instr_drop(cctx, ISN_STORERANGE, 4) == NULL)\n\t\t    return FAIL;\n\t    }\n\t    else\n\t    {\n\t\tisn_T\t*isn = generate_instr_drop(cctx, ISN_STOREINDEX, 3);\n\n\t\tif (isn == NULL)\n\t\t    return FAIL;\n\t\tisn->isn_arg.vartype = dest_type;\n\t    }\n\t}\n\telse if (range)\n\t{\n\t    if (generate_instr_drop(cctx, ISN_UNLETRANGE, 3) == NULL)\n\t\treturn FAIL;\n\t}\n\telse\n\t{\n\t    if (generate_instr_drop(cctx, ISN_UNLETINDEX, 2) == NULL)\n\t\treturn FAIL;\n\t}\n    }\n    else\n    {\n\temsg(_(e_indexable_type_required));\n\treturn FAIL;\n    }\n\n    return OK;\n}\n\n/*\n * Compile declaration and assignment:\n * \"let name\"\n * \"var name = expr\"\n * \"final name = expr\"\n * \"const name = expr\"\n * \"name = expr\"\n * \"arg\" points to \"name\".\n * \"++arg\" and \"--arg\"\n * Return NULL for an error.\n * Return \"arg\" if it does not look like a variable list.\n */\n    static char_u *\ncompile_assignment(char_u *arg, exarg_T *eap, cmdidx_T cmdidx, cctx_T *cctx)\n{\n    char_u\t*var_start;\n    char_u\t*p;\n    char_u\t*end = arg;\n    char_u\t*ret = NULL;\n    int\t\tvar_count = 0;\n    int\t\tvar_idx;\n    int\t\tsemicolon = 0;\n    int\t\tdid_generate_slice = FALSE;\n    garray_T\t*instr = &cctx->ctx_instr;\n    char_u\t*op;\n    int\t\toplen = 0;\n    int\t\theredoc = FALSE;\n    int\t\tincdec = FALSE;\n    type_T\t*rhs_type = &t_any;\n    char_u\t*sp;\n    int\t\tis_decl = is_decl_command(cmdidx);\n    lhs_T\tlhs;\n    long\tstart_lnum = SOURCING_LNUM;\n\n    // Skip over the \"varname\" or \"[varname, varname]\" to get to any \"=\".\n    p = skip_var_list(arg, TRUE, &var_count, &semicolon, TRUE);\n    if (p == NULL)\n\treturn *arg == '[' ? arg : NULL;\n\n    lhs.lhs_name = NULL;\n\n    if (eap->cmdidx == CMD_increment || eap->cmdidx == CMD_decrement)\n    {\n\tif (VIM_ISWHITE(eap->cmd[2]))\n\t{\n\t    semsg(_(e_no_white_space_allowed_after_str_str),\n\t\t\t eap->cmdidx == CMD_increment ? \"++\" : \"--\", eap->cmd);\n\t    return NULL;\n\t}\n\top = (char_u *)(eap->cmdidx == CMD_increment ? \"+=\" : \"-=\");\n\toplen = 2;\n\tincdec = TRUE;\n    }\n    else\n    {\n\tsp = p;\n\tp = skipwhite(p);\n\top = p;\n\toplen = assignment_len(p, &heredoc);\n\n\tif (var_count > 0 && oplen == 0)\n\t    // can be something like \"[1, 2]->func()\"\n\t    return arg;\n\n\tif (oplen > 0 && (!VIM_ISWHITE(*sp) || !IS_WHITE_OR_NUL(op[oplen])))\n\t{\n\t    error_white_both(op, oplen);\n\t    return NULL;\n\t}\n    }\n\n    if (heredoc)\n    {\n\tlist_T\t   *l;\n\n\t// [let] varname =<< [trim] {end}\n\teap->getline = exarg_getline;\n\teap->cookie = cctx;\n\tl = heredoc_get(eap, op + 3, FALSE, TRUE);\n\tif (l == NULL)\n\t    return NULL;\n\n\tlist_free(l);\n\tp += STRLEN(p);\n\tend = p;\n    }\n    else if (var_count > 0)\n    {\n\tchar_u *wp;\n\n\t// for \"[var, var] = expr\" evaluate the expression here, loop over the\n\t// list of variables below.\n\t// A line break may follow the \"=\".\n\n\twp = op + oplen;\n\tif (may_get_next_line_error(wp, &p, cctx) == FAIL)\n\t    return FAIL;\n\tif (compile_expr0(&p, cctx) == FAIL)\n\t    return NULL;\n\tend = p;\n\n\tif (cctx->ctx_skip != SKIP_YES)\n\t{\n\t    type_T\t*stacktype;\n\t    int\t\tneeded_list_len;\n\t    int\t\tdid_check = FALSE;\n\n\t    stacktype = cctx->ctx_type_stack.ga_len == 0 ? &t_void\n\t\t\t\t\t\t  : get_type_on_stack(cctx, 0);\n\t    if (stacktype->tt_type == VAR_VOID)\n\t    {\n\t\temsg(_(e_cannot_use_void_value));\n\t\tgoto theend;\n\t    }\n\t    if (need_type(stacktype, &t_list_any, -1, 0, cctx,\n\t\t\t\t\t\t\t FALSE, FALSE) == FAIL)\n\t\tgoto theend;\n\t    // If a constant list was used we can check the length right here.\n\t    needed_list_len = semicolon ? var_count - 1 : var_count;\n\t    if (instr->ga_len > 0)\n\t    {\n\t\tisn_T\t*isn = ((isn_T *)instr->ga_data) + instr->ga_len - 1;\n\n\t\tif (isn->isn_type == ISN_NEWLIST)\n\t\t{\n\t\t    did_check = TRUE;\n\t\t    if (semicolon ? isn->isn_arg.number < needed_list_len\n\t\t\t    : isn->isn_arg.number != needed_list_len)\n\t\t    {\n\t\t\tsemsg(_(e_expected_nr_items_but_got_nr),\n\t\t\t\t    needed_list_len, (int)isn->isn_arg.number);\n\t\t\tgoto theend;\n\t\t    }\n\t\t}\n\t    }\n\t    if (!did_check)\n\t\tgenerate_CHECKLEN(cctx, needed_list_len, semicolon);\n\t    if (stacktype->tt_member != NULL)\n\t\trhs_type = stacktype->tt_member;\n\t}\n    }\n\n    /*\n     * Loop over variables in \"[var, var] = expr\".\n     * For \"var = expr\" and \"let var: type\" this is done only once.\n     */\n    if (var_count > 0)\n\tvar_start = skipwhite(arg + 1);  // skip over the \"[\"\n    else\n\tvar_start = arg;\n    for (var_idx = 0; var_idx == 0 || var_idx < var_count; var_idx++)\n    {\n\tint\tinstr_count = -1;\n\tint\tsave_lnum;\n\tint\tskip_store = FALSE;\n\ttype_T\t*inferred_type = NULL;\n\n\tif (var_start[0] == '_' && !eval_isnamec(var_start[1]))\n\t{\n\t    // Ignore underscore in \"[a, _, b] = list\".\n\t    if (var_count > 0)\n\t    {\n\t\tvar_start = skipwhite(var_start + 2);\n\t\tcontinue;\n\t    }\n\t    emsg(_(e_cannot_use_underscore_here));\n\t    goto theend;\n\t}\n\tvim_free(lhs.lhs_name);\n\n\t/*\n\t * Figure out the LHS type and other properties.\n\t */\n\tif (compile_assign_lhs(var_start, &lhs, cmdidx,\n\t\t\t\tis_decl, heredoc, var_start > eap->cmd,\n\t\t\t\toplen, cctx) == FAIL)\n\t    goto theend;\n\tif (heredoc)\n\t{\n\t    SOURCING_LNUM = start_lnum;\n\t    if (lhs.lhs_has_type\n\t\t    && need_type(&t_list_string, lhs.lhs_type,\n\t\t\t\t\t    -1, 0, cctx, FALSE, FALSE) == FAIL)\n\t\tgoto theend;\n\t}\n\telse\n\t{\n\t    if (cctx->ctx_skip == SKIP_YES)\n\t    {\n\t\tif (oplen > 0 && var_count == 0)\n\t\t{\n\t\t    // skip over the \"=\" and the expression\n\t\t    p = skipwhite(op + oplen);\n\t\t    (void)compile_expr0(&p, cctx);\n\t\t}\n\t    }\n\t    else if (oplen > 0)\n\t    {\n\t\tint\tis_const = FALSE;\n\t\tchar_u\t*wp;\n\n\t\t// for \"+=\", \"*=\", \"..=\" etc. first load the current value\n\t\tif (*op != '='\n\t\t\t&& compile_load_lhs_with_index(&lhs, var_start,\n\t\t\t\t\t\t\t\t cctx) == FAIL)\n\t\t    goto theend;\n\n\t\t// For \"var = expr\" evaluate the expression.\n\t\tif (var_count == 0)\n\t\t{\n\t\t    int\tr;\n\n\t\t    // Compile the expression.\n\t\t    instr_count = instr->ga_len;\n\t\t    if (incdec)\n\t\t    {\n\t\t\tr = generate_PUSHNR(cctx, 1);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Temporarily hide the new local variable here, it is\n\t\t\t// not available to this expression.\n\t\t\tif (lhs.lhs_new_local)\n\t\t\t    --cctx->ctx_locals.ga_len;\n\t\t\twp = op + oplen;\n\t\t\tif (may_get_next_line_error(wp, &p, cctx) == FAIL)\n\t\t\t{\n\t\t\t    if (lhs.lhs_new_local)\n\t\t\t\t++cctx->ctx_locals.ga_len;\n\t\t\t    goto theend;\n\t\t\t}\n\t\t\tr = compile_expr0_ext(&p, cctx, &is_const);\n\t\t\tif (lhs.lhs_new_local)\n\t\t\t    ++cctx->ctx_locals.ga_len;\n\t\t\tif (r == FAIL)\n\t\t\t    goto theend;\n\t\t    }\n\t\t}\n\t\telse if (semicolon && var_idx == var_count - 1)\n\t\t{\n\t\t    // For \"[var; var] = expr\" get the rest of the list\n\t\t    did_generate_slice = TRUE;\n\t\t    if (generate_SLICE(cctx, var_count - 1) == FAIL)\n\t\t\tgoto theend;\n\t\t}\n\t\telse\n\t\t{\n\t\t    // For \"[var, var] = expr\" get the \"var_idx\" item from the\n\t\t    // list.\n\t\t    if (generate_GETITEM(cctx, var_idx, *op != '=') == FAIL)\n\t\t\tgoto theend;\n\t\t}\n\n\t\trhs_type = cctx->ctx_type_stack.ga_len == 0 ? &t_void\n\t\t\t\t\t\t  : get_type_on_stack(cctx, 0);\n\t\tif (lhs.lhs_lvar != NULL && (is_decl || !lhs.lhs_has_type))\n\t\t{\n\t\t    if ((rhs_type->tt_type == VAR_FUNC\n\t\t\t\t|| rhs_type->tt_type == VAR_PARTIAL)\n\t\t\t    && !lhs.lhs_has_index\n\t\t\t    && var_wrong_func_name(lhs.lhs_name, TRUE))\n\t\t\tgoto theend;\n\n\t\t    if (lhs.lhs_new_local && !lhs.lhs_has_type)\n\t\t    {\n\t\t\tif (rhs_type->tt_type == VAR_VOID)\n\t\t\t{\n\t\t\t    emsg(_(e_cannot_use_void_value));\n\t\t\t    goto theend;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // An empty list or dict has a &t_unknown member,\n\t\t\t    // for a variable that implies &t_any.\n\t\t\t    if (rhs_type == &t_list_empty)\n\t\t\t\tlhs.lhs_lvar->lv_type = &t_list_any;\n\t\t\t    else if (rhs_type == &t_dict_empty)\n\t\t\t\tlhs.lhs_lvar->lv_type = &t_dict_any;\n\t\t\t    else if (rhs_type == &t_unknown)\n\t\t\t\tlhs.lhs_lvar->lv_type = &t_any;\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tlhs.lhs_lvar->lv_type = rhs_type;\n\t\t\t\tinferred_type = rhs_type;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    else if (*op == '=')\n\t\t    {\n\t\t\ttype_T *use_type = lhs.lhs_lvar->lv_type;\n\t\t\twhere_T where = WHERE_INIT;\n\n\t\t\t// Without operator check type here, otherwise below.\n\t\t\t// Use the line number of the assignment.\n\t\t\tSOURCING_LNUM = start_lnum;\n\t\t\twhere.wt_index = var_count > 0 ? var_idx + 1 : 0;\n\t\t\twhere.wt_variable = var_count > 0;\n\t\t\t// If assigning to a list or dict member, use the\n\t\t\t// member type.  Not for \"list[:] =\".\n\t\t\tif (lhs.lhs_has_index\n\t\t\t\t&& !has_list_index(var_start + lhs.lhs_varlen,\n\t\t\t\t\t\t\t\t\t cctx))\n\t\t\t    use_type = lhs.lhs_member_type;\n\t\t\tif (need_type_where(rhs_type, use_type, -1, where,\n\t\t\t\t\t\tcctx, FALSE, is_const) == FAIL)\n\t\t\t    goto theend;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    type_T *lhs_type = lhs.lhs_member_type;\n\n\t\t    // Special case: assigning to @# can use a number or a\n\t\t    // string.\n\t\t    // Also: can assign a number to a float.\n\t\t    if ((lhs_type == &t_number_or_string\n\t\t\t\t|| lhs_type == &t_float)\n\t\t\t    && rhs_type->tt_type == VAR_NUMBER)\n\t\t\tlhs_type = &t_number;\n\t\t    if (*p != '=' && need_type(rhs_type, lhs_type,\n\t\t\t\t\t    -1, 0, cctx, FALSE, FALSE) == FAIL)\n\t\t    goto theend;\n\t\t}\n\t    }\n\t    else if (cmdidx == CMD_final)\n\t    {\n\t\temsg(_(e_final_requires_a_value));\n\t\tgoto theend;\n\t    }\n\t    else if (cmdidx == CMD_const)\n\t    {\n\t\temsg(_(e_const_requires_a_value));\n\t\tgoto theend;\n\t    }\n\t    else if (!lhs.lhs_has_type || lhs.lhs_dest == dest_option\n\t\t\t\t\t   || lhs.lhs_dest == dest_func_option)\n\t    {\n\t\temsg(_(e_type_or_initialization_required));\n\t\tgoto theend;\n\t    }\n\t    else\n\t    {\n\t\tint r = OK;\n\n\t\t// variables are always initialized\n\t\tif (GA_GROW_FAILS(instr, 1))\n\t\t    goto theend;\n\t\tswitch (lhs.lhs_member_type->tt_type)\n\t\t{\n\t\t    case VAR_BOOL:\n\t\t\tr = generate_PUSHBOOL(cctx, VVAL_FALSE);\n\t\t\tbreak;\n\t\t    case VAR_FLOAT:\n#ifdef FEAT_FLOAT\n\t\t\tr = generate_PUSHF(cctx, 0.0);\n#endif\n\t\t\tbreak;\n\t\t    case VAR_STRING:\n\t\t\tr = generate_PUSHS(cctx, NULL);\n\t\t\tbreak;\n\t\t    case VAR_BLOB:\n\t\t\tr = generate_PUSHBLOB(cctx, blob_alloc());\n\t\t\tbreak;\n\t\t    case VAR_FUNC:\n\t\t\tr = generate_PUSHFUNC(cctx, NULL, &t_func_void);\n\t\t\tbreak;\n\t\t    case VAR_LIST:\n\t\t\tr = generate_NEWLIST(cctx, 0, FALSE);\n\t\t\tbreak;\n\t\t    case VAR_DICT:\n\t\t\tr = generate_NEWDICT(cctx, 0, FALSE);\n\t\t\tbreak;\n\t\t    case VAR_JOB:\n\t\t\tr = generate_PUSHJOB(cctx);\n\t\t\tbreak;\n\t\t    case VAR_CHANNEL:\n\t\t\tr = generate_PUSHCHANNEL(cctx);\n\t\t\tbreak;\n\t\t    case VAR_NUMBER:\n\t\t    case VAR_UNKNOWN:\n\t\t    case VAR_ANY:\n\t\t    case VAR_PARTIAL:\n\t\t    case VAR_VOID:\n\t\t    case VAR_INSTR:\n\t\t    case VAR_SPECIAL:  // cannot happen\n\t\t\t// This is skipped for local variables, they are always\n\t\t\t// initialized to zero.  But in a \"for\" or \"while\" loop\n\t\t\t// the value may have been changed.\n\t\t\tif (lhs.lhs_dest == dest_local\n\t\t\t\t\t\t   && !inside_loop_scope(cctx))\n\t\t\t    skip_store = TRUE;\n\t\t\telse\n\t\t\t{\n\t\t\t    instr_count = instr->ga_len;\n\t\t\t    r = generate_PUSHNR(cctx, 0);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (r == FAIL)\n\t\t    goto theend;\n\t    }\n\t    if (var_count == 0)\n\t\tend = p;\n\t}\n\n\t// no need to parse more when skipping\n\tif (cctx->ctx_skip == SKIP_YES)\n\t    break;\n\n\tif (oplen > 0 && *op != '=')\n\t{\n\t    type_T\t    *expected;\n\t    type_T\t    *stacktype = NULL;\n\n\t    if (*op == '.')\n\t    {\n\t\tif (may_generate_2STRING(-1, FALSE, cctx) == FAIL)\n\t\t    goto theend;\n\t    }\n\t    else\n\t    {\n\t\texpected = lhs.lhs_member_type;\n\t\tstacktype = get_type_on_stack(cctx, 0);\n\t\tif (\n#ifdef FEAT_FLOAT\n\t\t    // If variable is float operation with number is OK.\n\t\t    !(expected == &t_float && (stacktype == &t_number\n\t\t\t    || stacktype == &t_number_bool)) &&\n#endif\n\t\t    need_type(stacktype, expected, -1, 0, cctx,\n\t\t\t\t\t\t\t FALSE, FALSE) == FAIL)\n\t\t    goto theend;\n\t    }\n\n\t    if (*op == '.')\n\t    {\n\t\tif (generate_CONCAT(cctx, 2) == FAIL)\n\t\t    goto theend;\n\t    }\n\t    else if (*op == '+')\n\t    {\n\t\tif (generate_add_instr(cctx,\n\t\t\t    operator_type(lhs.lhs_member_type, stacktype),\n\t\t\t\t       lhs.lhs_member_type, stacktype,\n\t\t\t\t\t\t\t  EXPR_APPEND) == FAIL)\n\t\t    goto theend;\n\t    }\n\t    else if (generate_two_op(cctx, op) == FAIL)\n\t\tgoto theend;\n\t}\n\n\t// Use the line number of the assignment for store instruction.\n\tsave_lnum = cctx->ctx_lnum;\n\tcctx->ctx_lnum = start_lnum - 1;\n\n\tif (lhs.lhs_has_index)\n\t{\n\t    // Use the info in \"lhs\" to store the value at the index in the\n\t    // list or dict.\n\t    if (compile_assign_unlet(var_start, &lhs, TRUE, rhs_type, cctx)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t    {\n\t\tcctx->ctx_lnum = save_lnum;\n\t\tgoto theend;\n\t    }\n\t}\n\telse\n\t{\n\t    if (is_decl && cmdidx == CMD_const && (lhs.lhs_dest == dest_script\n\t\t\t\t\t\t|| lhs.lhs_dest == dest_global\n\t\t\t\t\t\t|| lhs.lhs_dest == dest_local))\n\t\t// \":const var\": lock the value, but not referenced variables\n\t\tgenerate_LOCKCONST(cctx);\n\n\t    if ((lhs.lhs_type->tt_type == VAR_DICT\n\t\t\t\t\t  || lhs.lhs_type->tt_type == VAR_LIST)\n\t\t    && lhs.lhs_type->tt_member != NULL\n\t\t    && lhs.lhs_type->tt_member != &t_any\n\t\t    && lhs.lhs_type->tt_member != &t_unknown)\n\t\t// Set the type in the list or dict, so that it can be checked,\n\t\t// also in legacy script.\n\t\tgenerate_SETTYPE(cctx, lhs.lhs_type);\n\t    else if (inferred_type != NULL\n\t\t    && (inferred_type->tt_type == VAR_DICT\n\t\t\t\t\t|| inferred_type->tt_type == VAR_LIST)\n\t\t    && inferred_type->tt_member != NULL\n\t\t    && inferred_type->tt_member != &t_unknown\n\t\t    && inferred_type->tt_member != &t_any)\n\t\t// Set the type in the list or dict, so that it can be checked,\n\t\t// also in legacy script.\n\t\tgenerate_SETTYPE(cctx, inferred_type);\n\n\t    if (!skip_store && generate_store_lhs(cctx, &lhs,\n\t\t\t\t\t\t instr_count, is_decl) == FAIL)\n\t    {\n\t\tcctx->ctx_lnum = save_lnum;\n\t\tgoto theend;\n\t    }\n\t}\n\tcctx->ctx_lnum = save_lnum;\n\n\tif (var_idx + 1 < var_count)\n\t    var_start = skipwhite(lhs.lhs_end + 1);\n    }\n\n    // For \"[var, var] = expr\" drop the \"expr\" value.\n    // Also for \"[var, var; _] = expr\".\n    if (var_count > 0 && (!semicolon || !did_generate_slice))\n    {\n\tif (generate_instr_drop(cctx, ISN_DROP, 1) == NULL)\n\t    goto theend;\n    }\n\n    ret = skipwhite(end);\n\ntheend:\n    vim_free(lhs.lhs_name);\n    return ret;\n}\n\n/*\n * Check for an assignment at \"eap->cmd\", compile it if found.\n * Return NOTDONE if there is none, FAIL for failure, OK if done.\n */\n    static int\nmay_compile_assignment(exarg_T *eap, char_u **line, cctx_T *cctx)\n{\n    char_u  *pskip;\n    char_u  *p;\n\n    // Assuming the command starts with a variable or function name,\n    // find what follows.\n    // Skip over \"var.member\", \"var[idx]\" and the like.\n    // Also \"&opt = val\", \"$ENV = val\" and \"@r = val\".\n    pskip = (*eap->cmd == '&' || *eap->cmd == '$' || *eap->cmd == '@')\n\t\t\t\t\t\t ? eap->cmd + 1 : eap->cmd;\n    p = to_name_end(pskip, TRUE);\n    if (p > eap->cmd && *p != NUL)\n    {\n\tchar_u *var_end;\n\tint\toplen;\n\tint\theredoc;\n\n\tif (eap->cmd[0] == '@')\n\t    var_end = eap->cmd + 2;\n\telse\n\t    var_end = find_name_end(pskip, NULL, NULL,\n\t\t\t\t\tFNE_CHECK_START | FNE_INCL_BR);\n\toplen = assignment_len(skipwhite(var_end), &heredoc);\n\tif (oplen > 0)\n\t{\n\t    size_t len = p - eap->cmd;\n\n\t    // Recognize an assignment if we recognize the variable\n\t    // name:\n\t    // \"&opt = expr\"\n\t    // \"$ENV = expr\"\n\t    // \"@r = expr\"\n\t    // \"g:var = expr\"\n\t    // \"g:[key] = expr\"\n\t    // \"local = expr\"  where \"local\" is a local var.\n\t    // \"script = expr\"  where \"script\" is a script-local var.\n\t    // \"import = expr\"  where \"import\" is an imported var\n\t    if (*eap->cmd == '&'\n\t\t    || *eap->cmd == '$'\n\t\t    || *eap->cmd == '@'\n\t\t    || ((len) > 2 && eap->cmd[1] == ':')\n\t\t    || STRNCMP(eap->cmd, \"g:[\", 3) == 0\n\t\t    || variable_exists(eap->cmd, len, cctx))\n\t    {\n\t\t*line = compile_assignment(eap->cmd, eap, CMD_SIZE, cctx);\n\t\tif (*line == NULL || *line == eap->cmd)\n\t\t    return FAIL;\n\t\treturn OK;\n\t    }\n\t}\n    }\n\n    if (*eap->cmd == '[')\n    {\n\t// might be \"[var, var] = expr\"\n\t*line = compile_assignment(eap->cmd, eap, CMD_SIZE, cctx);\n\tif (*line == NULL)\n\t    return FAIL;\n\tif (*line != eap->cmd)\n\t    return OK;\n    }\n    return NOTDONE;\n}\n\n/*\n * Check if arguments of \"ufunc\" shadow variables in \"cctx\".\n * Return OK or FAIL.\n */\n    static int\ncheck_args_shadowing(ufunc_T *ufunc, cctx_T *cctx)\n{\n    int\t    i;\n    char_u  *arg;\n    int\t    r = OK;\n\n    // Make sure arguments are not found when compiling a second time.\n    ufunc->uf_args_visible = 0;\n\n    // Check for arguments shadowing variables from the context.\n    for (i = 0; i < ufunc->uf_args.ga_len; ++i)\n    {\n\targ = ((char_u **)(ufunc->uf_args.ga_data))[i];\n\tif (check_defined(arg, STRLEN(arg), cctx, NULL, TRUE) == FAIL)\n\t{\n\t    r = FAIL;\n\t    break;\n\t}\n    }\n    ufunc->uf_args_visible = ufunc->uf_args.ga_len;\n    return r;\n}\n\n/*\n * Get the compilation type that should be used for \"ufunc\".\n * Keep in sync with INSTRUCTIONS().\n */\n    compiletype_T\nget_compile_type(ufunc_T *ufunc)\n{\n    // Update uf_has_breakpoint if needed.\n    update_has_breakpoint(ufunc);\n\n    if (debug_break_level > 0 || may_break_in_function(ufunc))\n\treturn CT_DEBUG;\n#ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n    {\n\tif (!ufunc->uf_profiling && has_profiling(FALSE, ufunc->uf_name, NULL))\n\t    func_do_profile(ufunc);\n\tif (ufunc->uf_profiling)\n\t    return CT_PROFILE;\n    }\n#endif\n    return CT_NONE;\n}\n\n\n/*\n * Add a function to the list of :def functions.\n * This sets \"ufunc->uf_dfunc_idx\" but the function isn't compiled yet.\n */\n    static int\nadd_def_function(ufunc_T *ufunc)\n{\n    dfunc_T *dfunc;\n\n    if (def_functions.ga_len == 0)\n    {\n\t// The first position is not used, so that a zero uf_dfunc_idx means it\n\t// wasn't set.\n\tif (GA_GROW_FAILS(&def_functions, 1))\n\t    return FAIL;\n\t++def_functions.ga_len;\n    }\n\n    // Add the function to \"def_functions\".\n    if (GA_GROW_FAILS(&def_functions, 1))\n\treturn FAIL;\n    dfunc = ((dfunc_T *)def_functions.ga_data) + def_functions.ga_len;\n    CLEAR_POINTER(dfunc);\n    dfunc->df_idx = def_functions.ga_len;\n    ufunc->uf_dfunc_idx = dfunc->df_idx;\n    dfunc->df_ufunc = ufunc;\n    dfunc->df_name = vim_strsave(ufunc->uf_name);\n    ga_init2(&dfunc->df_var_names, sizeof(char_u *), 10);\n    ++dfunc->df_refcount;\n    ++def_functions.ga_len;\n    return OK;\n}\n\n/*\n * After ex_function() has collected all the function lines: parse and compile\n * the lines into instructions.\n * Adds the function to \"def_functions\".\n * When \"check_return_type\" is set then set ufunc->uf_ret_type to the type of\n * the return statement (used for lambda).  When uf_ret_type is already set\n * then check that it matches.\n * When \"profiling\" is true add ISN_PROF_START instructions.\n * \"outer_cctx\" is set for a nested function.\n * This can be used recursively through compile_lambda(), which may reallocate\n * \"def_functions\".\n * Returns OK or FAIL.\n */\n    int\ncompile_def_function(\n\tufunc_T\t\t*ufunc,\n\tint\t\tcheck_return_type,\n\tcompiletype_T   compile_type,\n\tcctx_T\t\t*outer_cctx)\n{\n    char_u\t*line = NULL;\n    garray_T\tlines_to_free;\n    char_u\t*p;\n    char\t*errormsg = NULL;\t// error message\n    cctx_T\tcctx;\n    garray_T\t*instr;\n    int\t\tdid_emsg_before = did_emsg;\n    int\t\tdid_emsg_silent_before = did_emsg_silent;\n    int\t\tret = FAIL;\n    sctx_T\tsave_current_sctx = current_sctx;\n    int\t\tsave_estack_compiling = estack_compiling;\n    int\t\tsave_cmod_flags = cmdmod.cmod_flags;\n    int\t\tdo_estack_push;\n    int\t\tnew_def_function = FALSE;\n#ifdef FEAT_PROFILE\n    int\t\tprof_lnum = -1;\n#endif\n    int\t\tdebug_lnum = -1;\n\n    // allocated lines are freed at the end\n    ga_init2(&lines_to_free, sizeof(char_u *), 50);\n\n    // When using a function that was compiled before: Free old instructions.\n    // The index is reused.  Otherwise add a new entry in \"def_functions\".\n    if (ufunc->uf_dfunc_idx > 0)\n    {\n\tdfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\tisn_T\t*instr_dest = NULL;\n\n\tswitch (compile_type)\n\t{\n\t    case CT_PROFILE:\n#ifdef FEAT_PROFILE\n\t\t\t    instr_dest = dfunc->df_instr_prof; break;\n#endif\n\t    case CT_NONE:   instr_dest = dfunc->df_instr; break;\n\t    case CT_DEBUG:  instr_dest = dfunc->df_instr_debug; break;\n\t}\n\tif (instr_dest != NULL)\n\t    // Was compiled in this mode before: Free old instructions.\n\t    delete_def_function_contents(dfunc, FALSE);\n\tga_clear_strings(&dfunc->df_var_names);\n    }\n    else\n    {\n\tif (add_def_function(ufunc) == FAIL)\n\t    return FAIL;\n\tnew_def_function = TRUE;\n    }\n\n    if ((ufunc->uf_flags & FC_CLOSURE) && outer_cctx == NULL)\n    {\n\tsemsg(_(e_compiling_closure_without_context_str),\n\t\t\t\t\t\t   printable_func_name(ufunc));\n\treturn FAIL;\n    }\n\n    ufunc->uf_def_status = UF_COMPILING;\n\n    CLEAR_FIELD(cctx);\n\n    cctx.ctx_compile_type = compile_type;\n    cctx.ctx_ufunc = ufunc;\n    cctx.ctx_lnum = -1;\n    cctx.ctx_outer = outer_cctx;\n    ga_init2(&cctx.ctx_locals, sizeof(lvar_T), 10);\n    // Each entry on the type stack consists of two type pointers.\n    ga_init2(&cctx.ctx_type_stack, sizeof(type2_T), 50);\n    cctx.ctx_type_list = &ufunc->uf_type_list;\n    ga_init2(&cctx.ctx_instr, sizeof(isn_T), 50);\n    instr = &cctx.ctx_instr;\n\n    // Set the context to the function, it may be compiled when called from\n    // another script.  Set the script version to the most modern one.\n    // The line number will be set in next_line_from_context().\n    current_sctx = ufunc->uf_script_ctx;\n    current_sctx.sc_version = SCRIPT_VERSION_VIM9;\n\n    // Don't use the flag from \":legacy\" here.\n    cmdmod.cmod_flags &= ~CMOD_LEGACY;\n\n    // Make sure error messages are OK.\n    do_estack_push = !estack_top_is_ufunc(ufunc, 1);\n    if (do_estack_push)\n\testack_push_ufunc(ufunc, 1);\n    estack_compiling = TRUE;\n\n    if (check_args_shadowing(ufunc, &cctx) == FAIL)\n\tgoto erret;\n\n    if (ufunc->uf_def_args.ga_len > 0)\n    {\n\tint\tcount = ufunc->uf_def_args.ga_len;\n\tint\tfirst_def_arg = ufunc->uf_args.ga_len - count;\n\tint\ti;\n\tchar_u\t*arg;\n\tint\toff = STACK_FRAME_SIZE + (ufunc->uf_va_name != NULL ? 1 : 0);\n\tint\tdid_set_arg_type = FALSE;\n\n\t// Produce instructions for the default values of optional arguments.\n\tSOURCING_LNUM = 0;  // line number unknown\n\tfor (i = 0; i < count; ++i)\n\t{\n\t    type_T\t*val_type;\n\t    int\t\targ_idx = first_def_arg + i;\n\t    where_T\twhere = WHERE_INIT;\n\t    int\t\tr;\n\t    int\t\tjump_instr_idx = instr->ga_len;\n\t    isn_T\t*isn;\n\n\t    // Use a JUMP_IF_ARG_SET instruction to skip if the value was given.\n\t    if (generate_JUMP_IF_ARG_SET(&cctx, i - count - off) == FAIL)\n\t\tgoto erret;\n\n\t    // Make sure later arguments are not found.\n\t    ufunc->uf_args_visible = arg_idx;\n\n\t    arg = ((char_u **)(ufunc->uf_def_args.ga_data))[i];\n\t    r = compile_expr0(&arg, &cctx);\n\n\t    if (r == FAIL)\n\t\tgoto erret;\n\n\t    // If no type specified use the type of the default value.\n\t    // Otherwise check that the default value type matches the\n\t    // specified type.\n\t    val_type = get_type_on_stack(&cctx, 0);\n\t    where.wt_index = arg_idx + 1;\n\t    if (ufunc->uf_arg_types[arg_idx] == &t_unknown)\n\t    {\n\t\tdid_set_arg_type = TRUE;\n\t\tufunc->uf_arg_types[arg_idx] = val_type;\n\t    }\n\t    else if (need_type_where(val_type, ufunc->uf_arg_types[arg_idx],\n\t\t\t\t       -1, where, &cctx, FALSE, FALSE) == FAIL)\n\t\tgoto erret;\n\n\t    if (generate_STORE(&cctx, ISN_STORE, i - count - off, NULL) == FAIL)\n\t\tgoto erret;\n\n\t    // set instruction index in JUMP_IF_ARG_SET to here\n\t    isn = ((isn_T *)instr->ga_data) + jump_instr_idx;\n\t    isn->isn_arg.jumparg.jump_where = instr->ga_len;\n\t}\n\n\tif (did_set_arg_type)\n\t    set_function_type(ufunc);\n    }\n    ufunc->uf_args_visible = ufunc->uf_args.ga_len;\n\n    /*\n     * Loop over all the lines of the function and generate instructions.\n     */\n    for (;;)\n    {\n\texarg_T\t    ea;\n\tint\t    starts_with_colon = FALSE;\n\tchar_u\t    *cmd;\n\tcmdmod_T    local_cmdmod;\n\n\t// Bail out on the first error to avoid a flood of errors and report\n\t// the right line number when inside try/catch.\n\tif (did_emsg_before != did_emsg)\n\t    goto erret;\n\n\tif (line != NULL && *line == '|')\n\t    // the line continues after a '|'\n\t    ++line;\n\telse if (line != NULL && *skipwhite(line) != NUL\n\t\t&& !(*line == '#' && (line == cctx.ctx_line_start\n\t\t\t\t\t\t    || VIM_ISWHITE(line[-1]))))\n\t{\n\t    semsg(_(e_trailing_characters_str), line);\n\t    goto erret;\n\t}\n\telse if (line != NULL && vim9_bad_comment(skipwhite(line)))\n\t    goto erret;\n\telse\n\t{\n\t    line = next_line_from_context(&cctx, FALSE);\n\t    if (cctx.ctx_lnum >= ufunc->uf_lines.ga_len)\n\t    {\n\t\t// beyond the last line\n#ifdef FEAT_PROFILE\n\t\tif (cctx.ctx_skip != SKIP_YES)\n\t\t    may_generate_prof_end(&cctx, prof_lnum);\n#endif\n\t\tbreak;\n\t    }\n\t    // Make a copy, splitting off nextcmd and removing trailing spaces\n\t    // may change it.\n\t    if (line != NULL)\n\t    {\n\t\tline = vim_strsave(line);\n\t\tif (ga_add_string(&lines_to_free, line) == FAIL)\n\t\t    goto erret;\n\t    }\n\t}\n\n\tCLEAR_FIELD(ea);\n\tea.cmdlinep = &line;\n\tea.cmd = skipwhite(line);\n\tea.skip = cctx.ctx_skip == SKIP_YES;\n\n\tif (*ea.cmd == '#')\n\t{\n\t    // \"#\" starts a comment, but \"#{\" is an error\n\t    if (vim9_bad_comment(ea.cmd))\n\t\tgoto erret;\n\t    line = (char_u *)\"\";\n\t    continue;\n\t}\n\n#ifdef FEAT_PROFILE\n\tif (cctx.ctx_compile_type == CT_PROFILE && cctx.ctx_lnum != prof_lnum\n\t\t\t\t\t\t  && cctx.ctx_skip != SKIP_YES)\n\t{\n\t    may_generate_prof_end(&cctx, prof_lnum);\n\n\t    prof_lnum = cctx.ctx_lnum;\n\t    generate_instr(&cctx, ISN_PROF_START);\n\t}\n#endif\n\tif (cctx.ctx_compile_type == CT_DEBUG && cctx.ctx_lnum != debug_lnum\n\t\t\t\t\t\t  && cctx.ctx_skip != SKIP_YES)\n\t{\n\t    debug_lnum = cctx.ctx_lnum;\n\t    generate_instr_debug(&cctx);\n\t}\n\tcctx.ctx_prev_lnum = cctx.ctx_lnum + 1;\n\n\t// Some things can be recognized by the first character.\n\tswitch (*ea.cmd)\n\t{\n\t    case '}':\n\t\t{\n\t\t    // \"}\" ends a block scope\n\t\t    scopetype_T stype = cctx.ctx_scope == NULL\n\t\t\t\t\t  ? NO_SCOPE : cctx.ctx_scope->se_type;\n\n\t\t    if (stype == BLOCK_SCOPE)\n\t\t    {\n\t\t\tcompile_endblock(&cctx);\n\t\t\tline = ea.cmd;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\temsg(_(e_using_rcurly_outside_if_block_scope));\n\t\t\tgoto erret;\n\t\t    }\n\t\t    if (line != NULL)\n\t\t\tline = skipwhite(ea.cmd + 1);\n\t\t    continue;\n\t\t}\n\n\t    case '{':\n\t\t// \"{\" starts a block scope\n\t\t// \"{'a': 1}->func() is something else\n\t\tif (ends_excmd(*skipwhite(ea.cmd + 1)))\n\t\t{\n\t\t    line = compile_block(ea.cmd, &cctx);\n\t\t    continue;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * COMMAND MODIFIERS\n\t */\n\tcctx.ctx_has_cmdmod = FALSE;\n\tif (parse_command_modifiers(&ea, &errormsg, &local_cmdmod, FALSE)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t    goto erret;\n\tgenerate_cmdmods(&cctx, &local_cmdmod);\n\tundo_cmdmod(&local_cmdmod);\n\n\t// Check if there was a colon after the last command modifier or before\n\t// the current position.\n\tfor (p = ea.cmd; p >= line; --p)\n\t{\n\t    if (*p == ':')\n\t\tstarts_with_colon = TRUE;\n\t    if (p < ea.cmd && !VIM_ISWHITE(*p))\n\t\tbreak;\n\t}\n\n\t// Skip \":call\" to get to the function name, unless using :legacy\n\tp = ea.cmd;\n\tif (!(local_cmdmod.cmod_flags & CMOD_LEGACY))\n\t{\n\t    if (checkforcmd(&ea.cmd, \"call\", 3))\n\t    {\n\t\tif (*ea.cmd == '(')\n\t\t    // not for \"call()\"\n\t\t    ea.cmd = p;\n\t\telse\n\t\t    ea.cmd = skipwhite(ea.cmd);\n\t    }\n\n\t    if (!starts_with_colon)\n\t    {\n\t\tint\t    assign;\n\n\t\t// Check for assignment after command modifiers.\n\t\tassign = may_compile_assignment(&ea, &line, &cctx);\n\t\tif (assign == OK)\n\t\t    goto nextline;\n\t\tif (assign == FAIL)\n\t\t    goto erret;\n\t    }\n\t}\n\n\t/*\n\t * COMMAND after range\n\t * 'text'->func() should not be confused with 'a mark\n\t * 0z1234->func() should not be confused with a zero line number\n\t * \"++nr\" and \"--nr\" are eval commands\n\t * in \"$ENV->func()\" the \"$\" is not a range\n\t * \"123->func()\" is a method call\n\t */\n\tcmd = ea.cmd;\n\tif ((*cmd != '$' || starts_with_colon)\n\t\t&& (starts_with_colon\n\t\t    || !(*cmd == '\\''\n\t\t\t|| (cmd[0] == '0' && cmd[1] == 'z')\n\t\t\t|| (cmd[0] != NUL && cmd[0] == cmd[1]\n\t\t\t\t\t    && (*cmd == '+' || *cmd == '-'))\n\t\t\t|| number_method(cmd))))\n\t{\n\t    ea.cmd = skip_range(ea.cmd, TRUE, NULL);\n\t    if (ea.cmd > cmd)\n\t    {\n\t\tif (!starts_with_colon\n\t\t\t\t   && !(local_cmdmod.cmod_flags & CMOD_LEGACY))\n\t\t{\n\t\t    semsg(_(e_colon_required_before_range_str), cmd);\n\t\t    goto erret;\n\t\t}\n\t\tea.addr_count = 1;\n\t\tif (ends_excmd2(line, ea.cmd))\n\t\t{\n\t\t    // A range without a command: jump to the line.\n\t\t    generate_EXEC(&cctx, ISN_EXECRANGE,\n\t\t\t\t\t      vim_strnsave(cmd, ea.cmd - cmd));\n\t\t    line = ea.cmd;\n\t\t    goto nextline;\n\t\t}\n\t    }\n\t}\n\tp = find_ex_command(&ea, NULL,\n\t\tstarts_with_colon || (local_cmdmod.cmod_flags & CMOD_LEGACY)\n\t\t\t\t\t\t  ? NULL : item_exists, &cctx);\n\n\tif (p == NULL)\n\t{\n\t    if (cctx.ctx_skip != SKIP_YES)\n\t\tsemsg(_(e_ambiguous_use_of_user_defined_command_str), ea.cmd);\n\t    goto erret;\n\t}\n\n\t// When using \":legacy cmd\" always use compile_exec().\n\tif (local_cmdmod.cmod_flags & CMOD_LEGACY)\n\t{\n\t    char_u *start = ea.cmd;\n\n\t    switch (ea.cmdidx)\n\t    {\n\t\tcase CMD_if:\n\t\tcase CMD_elseif:\n\t\tcase CMD_else:\n\t\tcase CMD_endif:\n\t\tcase CMD_for:\n\t\tcase CMD_endfor:\n\t\tcase CMD_continue:\n\t\tcase CMD_break:\n\t\tcase CMD_while:\n\t\tcase CMD_endwhile:\n\t\tcase CMD_try:\n\t\tcase CMD_catch:\n\t\tcase CMD_finally:\n\t\tcase CMD_endtry:\n\t\t\tsemsg(_(e_cannot_use_legacy_with_command_str), ea.cmd);\n\t\t\tgoto erret;\n\t\tdefault: break;\n\t    }\n\n\t    // \":legacy return expr\" needs to be handled differently.\n\t    if (checkforcmd(&start, \"return\", 4))\n\t\tea.cmdidx = CMD_return;\n\t    else\n\t\tea.cmdidx = CMD_legacy;\n\t}\n\n\tif (p == ea.cmd && ea.cmdidx != CMD_SIZE)\n\t{\n\t    // \"eval\" is used for \"val->func()\" and \"var\" for \"var = val\", then\n\t    // \"p\" is equal to \"ea.cmd\" for a valid command.\n\t    if (ea.cmdidx == CMD_eval || ea.cmdidx == CMD_var)\n\t\t;\n\t    else if (cctx.ctx_skip == SKIP_YES)\n\t    {\n\t\tline += STRLEN(line);\n\t\tgoto nextline;\n\t    }\n\t    else\n\t    {\n\t\tsemsg(_(e_command_not_recognized_str), ea.cmd);\n\t\tgoto erret;\n\t    }\n\t}\n\n\tif (cctx.ctx_had_return\n\t\t&& ea.cmdidx != CMD_elseif\n\t\t&& ea.cmdidx != CMD_else\n\t\t&& ea.cmdidx != CMD_endif\n\t\t&& ea.cmdidx != CMD_endfor\n\t\t&& ea.cmdidx != CMD_endwhile\n\t\t&& ea.cmdidx != CMD_catch\n\t\t&& ea.cmdidx != CMD_finally\n\t\t&& ea.cmdidx != CMD_endtry)\n\t{\n\t    emsg(_(e_unreachable_code_after_return));\n\t    goto erret;\n\t}\n\n\tp = skipwhite(p);\n\tif (ea.cmdidx != CMD_SIZE\n\t\t\t    && ea.cmdidx != CMD_write && ea.cmdidx != CMD_read)\n\t{\n\t    if (ea.cmdidx >= 0)\n\t\tea.argt = excmd_get_argt(ea.cmdidx);\n\t    if ((ea.argt & EX_BANG) && *p == '!')\n\t    {\n\t\tea.forceit = TRUE;\n\t\tp = skipwhite(p + 1);\n\t    }\n\t    if ((ea.argt & EX_RANGE) == 0 && ea.addr_count > 0)\n\t    {\n\t\temsg(_(e_no_range_allowed));\n\t\tgoto erret;\n\t    }\n\t}\n\n\tswitch (ea.cmdidx)\n\t{\n\t    case CMD_def:\n\t    case CMD_function:\n\t\t    ea.arg = p;\n\t\t    line = compile_nested_function(&ea, &cctx, &lines_to_free);\n\t\t    break;\n\n\t    case CMD_return:\n\t\t    line = compile_return(p, check_return_type,\n\t\t\t\t local_cmdmod.cmod_flags & CMOD_LEGACY, &cctx);\n\t\t    cctx.ctx_had_return = TRUE;\n\t\t    break;\n\n\t    case CMD_let:\n\t\t    emsg(_(e_cannot_use_let_in_vim9_script));\n\t\t    break;\n\t    case CMD_var:\n\t    case CMD_final:\n\t    case CMD_const:\n\t    case CMD_increment:\n\t    case CMD_decrement:\n\t\t    line = compile_assignment(p, &ea, ea.cmdidx, &cctx);\n\t\t    if (line == p)\n\t\t    {\n\t\t\temsg(_(e_invalid_assignment));\n\t\t\tline = NULL;\n\t\t    }\n\t\t    break;\n\n\t    case CMD_unlet:\n\t    case CMD_unlockvar:\n\t    case CMD_lockvar:\n\t\t    line = compile_unletlock(p, &ea, &cctx);\n\t\t    break;\n\n\t    case CMD_import:\n\t\t    emsg(_(e_import_can_only_be_used_in_script));\n\t\t    line = NULL;\n\t\t    break;\n\n\t    case CMD_if:\n\t\t    line = compile_if(p, &cctx);\n\t\t    break;\n\t    case CMD_elseif:\n\t\t    line = compile_elseif(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_else:\n\t\t    line = compile_else(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_endif:\n\t\t    line = compile_endif(p, &cctx);\n\t\t    break;\n\n\t    case CMD_while:\n\t\t    line = compile_while(p, &cctx);\n\t\t    break;\n\t    case CMD_endwhile:\n\t\t    line = compile_endwhile(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\n\t    case CMD_for:\n\t\t    line = compile_for(p, &cctx);\n\t\t    break;\n\t    case CMD_endfor:\n\t\t    line = compile_endfor(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_continue:\n\t\t    line = compile_continue(p, &cctx);\n\t\t    break;\n\t    case CMD_break:\n\t\t    line = compile_break(p, &cctx);\n\t\t    break;\n\n\t    case CMD_try:\n\t\t    line = compile_try(p, &cctx);\n\t\t    break;\n\t    case CMD_catch:\n\t\t    line = compile_catch(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_finally:\n\t\t    line = compile_finally(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_endtry:\n\t\t    line = compile_endtry(p, &cctx);\n\t\t    break;\n\t    case CMD_throw:\n\t\t    line = compile_throw(p, &cctx);\n\t\t    break;\n\n\t    case CMD_eval:\n\t\t    line = compile_eval(p, &cctx);\n\t\t    break;\n\n\t    case CMD_echo:\n\t    case CMD_echon:\n\t    case CMD_execute:\n\t    case CMD_echomsg:\n\t    case CMD_echoerr:\n\t    case CMD_echoconsole:\n\t\t    line = compile_mult_expr(p, ea.cmdidx, &cctx);\n\t\t    break;\n\n\t    case CMD_put:\n\t\t    ea.cmd = cmd;\n\t\t    line = compile_put(p, &ea, &cctx);\n\t\t    break;\n\n\t    case CMD_substitute:\n\t\t    if (check_global_and_subst(ea.cmd, p) == FAIL)\n\t\t\tgoto erret;\n\t\t    if (cctx.ctx_skip == SKIP_YES)\n\t\t\tline = (char_u *)\"\";\n\t\t    else\n\t\t    {\n\t\t\tea.arg = p;\n\t\t\tline = compile_substitute(line, &ea, &cctx);\n\t\t    }\n\t\t    break;\n\n\t    case CMD_redir:\n\t\t    ea.arg = p;\n\t\t    line = compile_redir(line, &ea, &cctx);\n\t\t    break;\n\n\t    case CMD_cexpr:\n\t    case CMD_lexpr:\n\t    case CMD_caddexpr:\n\t    case CMD_laddexpr:\n\t    case CMD_cgetexpr:\n\t    case CMD_lgetexpr:\n#ifdef FEAT_QUICKFIX\n\t\t    ea.arg = p;\n\t\t    line = compile_cexpr(line, &ea, &cctx);\n#else\n\t\t    ex_ni(&ea);\n\t\t    line = NULL;\n#endif\n\t\t    break;\n\n\t    case CMD_append:\n\t    case CMD_change:\n\t    case CMD_insert:\n\t    case CMD_k:\n\t    case CMD_t:\n\t    case CMD_xit:\n\t\t    not_in_vim9(&ea);\n\t\t    goto erret;\n\n\t    case CMD_SIZE:\n\t\t    if (cctx.ctx_skip != SKIP_YES)\n\t\t    {\n\t\t\tsemsg(_(e_invalid_command_str), ea.cmd);\n\t\t\tgoto erret;\n\t\t    }\n\t\t    // We don't check for a next command here.\n\t\t    line = (char_u *)\"\";\n\t\t    break;\n\n\t    case CMD_lua:\n\t    case CMD_mzscheme:\n\t    case CMD_perl:\n\t    case CMD_py3:\n\t    case CMD_python3:\n\t    case CMD_python:\n\t    case CMD_pythonx:\n\t    case CMD_ruby:\n\t    case CMD_tcl:\n\t\t    ea.arg = p;\n\t\t    if (vim_strchr(line, '\\n') == NULL)\n\t\t\tline = compile_exec(line, &ea, &cctx);\n\t\t    else\n\t\t\t// heredoc lines have been concatenated with NL\n\t\t\t// characters in get_function_body()\n\t\t\tline = compile_script(line, &cctx);\n\t\t    break;\n\n\t    case CMD_vim9script:\n\t\t    if (cctx.ctx_skip != SKIP_YES)\n\t\t    {\n\t\t\temsg(_(e_vim9script_can_only_be_used_in_script));\n\t\t\tgoto erret;\n\t\t    }\n\t\t    line = (char_u *)\"\";\n\t\t    break;\n\n\t    case CMD_global:\n\t\t    if (check_global_and_subst(ea.cmd, p) == FAIL)\n\t\t\tgoto erret;\n\t\t    // FALLTHROUGH\n\t    default:\n\t\t    // Not recognized, execute with do_cmdline_cmd().\n\t\t    ea.arg = p;\n\t\t    line = compile_exec(line, &ea, &cctx);\n\t\t    break;\n\t}\nnextline:\n\tif (line == NULL)\n\t    goto erret;\n\tline = skipwhite(line);\n\n\t// Undo any command modifiers.\n\tgenerate_undo_cmdmods(&cctx);\n\n\tif (cctx.ctx_type_stack.ga_len < 0)\n\t{\n\t    iemsg(\"Type stack underflow\");\n\t    goto erret;\n\t}\n    }\n\n    if (cctx.ctx_scope != NULL)\n    {\n\tif (cctx.ctx_scope->se_type == IF_SCOPE)\n\t    emsg(_(e_missing_endif));\n\telse if (cctx.ctx_scope->se_type == WHILE_SCOPE)\n\t    emsg(_(e_missing_endwhile));\n\telse if (cctx.ctx_scope->se_type == FOR_SCOPE)\n\t    emsg(_(e_missing_endfor));\n\telse\n\t    emsg(_(e_missing_rcurly));\n\tgoto erret;\n    }\n\n    if (!cctx.ctx_had_return)\n    {\n\tif (ufunc->uf_ret_type->tt_type == VAR_UNKNOWN)\n\t    ufunc->uf_ret_type = &t_void;\n\telse if (ufunc->uf_ret_type->tt_type != VAR_VOID)\n\t{\n\t    emsg(_(e_missing_return_statement));\n\t    goto erret;\n\t}\n\n\t// Return void if there is no return at the end.\n\tgenerate_instr(&cctx, ISN_RETURN_VOID);\n    }\n\n    // When compiled with \":silent!\" and there was an error don't consider the\n    // function compiled.\n    if (emsg_silent == 0 || did_emsg_silent == did_emsg_silent_before)\n    {\n\tdfunc_T\t*dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\tdfunc->df_deleted = FALSE;\n\tdfunc->df_script_seq = current_sctx.sc_seq;\n#ifdef FEAT_PROFILE\n\tif (cctx.ctx_compile_type == CT_PROFILE)\n\t{\n\t    dfunc->df_instr_prof = instr->ga_data;\n\t    dfunc->df_instr_prof_count = instr->ga_len;\n\t}\n\telse\n#endif\n\tif (cctx.ctx_compile_type == CT_DEBUG)\n\t{\n\t    dfunc->df_instr_debug = instr->ga_data;\n\t    dfunc->df_instr_debug_count = instr->ga_len;\n\t}\n\telse\n\t{\n\t    dfunc->df_instr = instr->ga_data;\n\t    dfunc->df_instr_count = instr->ga_len;\n\t}\n\tdfunc->df_varcount = dfunc->df_var_names.ga_len;\n\tdfunc->df_has_closure = cctx.ctx_has_closure;\n\tif (cctx.ctx_outer_used)\n\t    ufunc->uf_flags |= FC_CLOSURE;\n\tufunc->uf_def_status = UF_COMPILED;\n    }\n\n    ret = OK;\n\nerret:\n    if (ufunc->uf_def_status == UF_COMPILING)\n    {\n\tdfunc_T\t*dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\n\t// Compiling aborted, free the generated instructions.\n\tclear_instr_ga(instr);\n\tVIM_CLEAR(dfunc->df_name);\n\tga_clear_strings(&dfunc->df_var_names);\n\n\t// If using the last entry in the table and it was added above, we\n\t// might as well remove it.\n\tif (!dfunc->df_deleted && new_def_function\n\t\t\t    && ufunc->uf_dfunc_idx == def_functions.ga_len - 1)\n\t{\n\t    --def_functions.ga_len;\n\t    ufunc->uf_dfunc_idx = 0;\n\t}\n\tufunc->uf_def_status = UF_COMPILE_ERROR;\n\n\twhile (cctx.ctx_scope != NULL)\n\t    drop_scope(&cctx);\n\n\tif (errormsg != NULL)\n\t    emsg(errormsg);\n\telse if (did_emsg == did_emsg_before)\n\t    emsg(_(e_compiling_def_function_failed));\n    }\n\n    if (cctx.ctx_redir_lhs.lhs_name != NULL)\n    {\n\tif (ret == OK)\n\t{\n\t    emsg(_(e_missing_redir_end));\n\t    ret = FAIL;\n\t}\n\tvim_free(cctx.ctx_redir_lhs.lhs_name);\n\tvim_free(cctx.ctx_redir_lhs.lhs_whole);\n    }\n\n    current_sctx = save_current_sctx;\n    estack_compiling = save_estack_compiling;\n    cmdmod.cmod_flags =\tsave_cmod_flags;\n    if (do_estack_push)\n\testack_pop();\n\n    ga_clear_strings(&lines_to_free);\n    free_locals(&cctx);\n    ga_clear(&cctx.ctx_type_stack);\n    return ret;\n}\n\n    void\nset_function_type(ufunc_T *ufunc)\n{\n    int varargs = ufunc->uf_va_name != NULL;\n    int argcount = ufunc->uf_args.ga_len;\n\n    // Create a type for the function, with the return type and any\n    // argument types.\n    // A vararg is included in uf_args.ga_len but not in uf_arg_types.\n    // The type is included in \"tt_args\".\n    if (argcount > 0 || varargs)\n    {\n\tif (ufunc->uf_type_list.ga_itemsize == 0)\n\t    ga_init2(&ufunc->uf_type_list, sizeof(type_T *), 10);\n\tufunc->uf_func_type = alloc_func_type(ufunc->uf_ret_type,\n\t\t\t\t\t   argcount, &ufunc->uf_type_list);\n\t// Add argument types to the function type.\n\tif (func_type_add_arg_types(ufunc->uf_func_type,\n\t\t\t\t    argcount + varargs,\n\t\t\t\t    &ufunc->uf_type_list) == FAIL)\n\t    return;\n\tufunc->uf_func_type->tt_argcount = argcount + varargs;\n\tufunc->uf_func_type->tt_min_argcount =\n\t\t\t\t      argcount - ufunc->uf_def_args.ga_len;\n\tif (ufunc->uf_arg_types == NULL)\n\t{\n\t    int i;\n\n\t    // lambda does not have argument types.\n\t    for (i = 0; i < argcount; ++i)\n\t\tufunc->uf_func_type->tt_args[i] = &t_any;\n\t}\n\telse\n\t    mch_memmove(ufunc->uf_func_type->tt_args,\n\t\t\t ufunc->uf_arg_types, sizeof(type_T *) * argcount);\n\tif (varargs)\n\t{\n\t    ufunc->uf_func_type->tt_args[argcount] =\n\t\t   ufunc->uf_va_type == NULL ? &t_list_any : ufunc->uf_va_type;\n\t    ufunc->uf_func_type->tt_flags = TTFLAG_VARARGS;\n\t}\n    }\n    else\n\t// No arguments, can use a predefined type.\n\tufunc->uf_func_type = get_func_type(ufunc->uf_ret_type,\n\t\t\t\t\t   argcount, &ufunc->uf_type_list);\n}\n\n/*\n * Free all instructions for \"dfunc\" except df_name.\n */\n    static void\ndelete_def_function_contents(dfunc_T *dfunc, int mark_deleted)\n{\n    int idx;\n\n    ga_clear(&dfunc->df_def_args_isn);\n    ga_clear_strings(&dfunc->df_var_names);\n\n    if (dfunc->df_instr != NULL)\n    {\n\tfor (idx = 0; idx < dfunc->df_instr_count; ++idx)\n\t    delete_instr(dfunc->df_instr + idx);\n\tVIM_CLEAR(dfunc->df_instr);\n\tdfunc->df_instr = NULL;\n    }\n    if (dfunc->df_instr_debug != NULL)\n    {\n\tfor (idx = 0; idx < dfunc->df_instr_debug_count; ++idx)\n\t    delete_instr(dfunc->df_instr_debug + idx);\n\tVIM_CLEAR(dfunc->df_instr_debug);\n\tdfunc->df_instr_debug = NULL;\n    }\n#ifdef FEAT_PROFILE\n    if (dfunc->df_instr_prof != NULL)\n    {\n\tfor (idx = 0; idx < dfunc->df_instr_prof_count; ++idx)\n\t    delete_instr(dfunc->df_instr_prof + idx);\n\tVIM_CLEAR(dfunc->df_instr_prof);\n\tdfunc->df_instr_prof = NULL;\n    }\n#endif\n\n    if (mark_deleted)\n\tdfunc->df_deleted = TRUE;\n    if (dfunc->df_ufunc != NULL)\n\tdfunc->df_ufunc->uf_def_status = UF_NOT_COMPILED;\n}\n\n/*\n * When a user function is deleted, clear the contents of any associated def\n * function, unless another user function still uses it.\n * The position in def_functions can be re-used.\n */\n    void\nunlink_def_function(ufunc_T *ufunc)\n{\n    if (ufunc->uf_dfunc_idx > 0)\n    {\n\tdfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\n\tif (--dfunc->df_refcount <= 0)\n\t    delete_def_function_contents(dfunc, TRUE);\n\tufunc->uf_def_status = UF_NOT_COMPILED;\n\tufunc->uf_dfunc_idx = 0;\n\tif (dfunc->df_ufunc == ufunc)\n\t    dfunc->df_ufunc = NULL;\n    }\n}\n\n/*\n * Used when a user function refers to an existing dfunc.\n */\n    void\nlink_def_function(ufunc_T *ufunc)\n{\n    if (ufunc->uf_dfunc_idx > 0)\n    {\n\tdfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\n\t++dfunc->df_refcount;\n    }\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n/*\n * Free all functions defined with \":def\".\n */\n    void\nfree_def_functions(void)\n{\n    int idx;\n\n    for (idx = 0; idx < def_functions.ga_len; ++idx)\n    {\n\tdfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data) + idx;\n\n\tdelete_def_function_contents(dfunc, TRUE);\n\tvim_free(dfunc->df_name);\n    }\n\n    ga_clear(&def_functions);\n}\n#endif\n\n\n#endif // FEAT_EVAL\n"], "fixing_code": ["\" Test various aspects of the Vim9 script language.\n\nsource check.vim\nsource term_util.vim\nimport './vim9.vim' as v9\nsource screendump.vim\nsource shared.vim\n\ndef Test_vim9script_feature()\n  # example from the help, here the feature is always present\n  var lines =<< trim END\n      \" old style comment\n      if !has('vim9script')\n        \" legacy commands would go here\n        finish\n      endif\n      vim9script\n      # Vim9 script commands go here\n      g:didit = true\n  END\n  v9.CheckScriptSuccess(lines)\n  assert_equal(true, g:didit)\n  unlet g:didit\nenddef\n\ndef Test_range_only()\n  new\n  setline(1, ['blah', 'Blah'])\n  :/Blah/\n  assert_equal(2, getcurpos()[1])\n  bwipe!\n\n  # without range commands use current line\n  new\n  setline(1, ['one', 'two', 'three'])\n  :2\n  print\n  assert_equal('two', g:Screenline(&lines))\n  :3\n  list\n  assert_equal('three$', g:Screenline(&lines))\n\n  # missing command does not print the line\n  var lines =<< trim END\n    vim9script\n    :1|\n    assert_equal('three$', g:Screenline(&lines))\n    :|\n    assert_equal('three$', g:Screenline(&lines))\n  END\n  v9.CheckScriptSuccess(lines)\n\n  bwipe!\n\n  lines =<< trim END\n      set cpo+=-\n      :1,999\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E16:', 2)\n  set cpo&vim\n\n  v9.CheckDefExecAndScriptFailure([\":'x\"], 'E20:', 1)\n\n  # won't generate anything\n  if false\n    :123\n  endif\nenddef\n\ndef Test_invalid_range()\n  var lines =<< trim END\n      :123 eval 1 + 2\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E481:', 1)\n\n  lines =<< trim END\n      :123 if true\n      endif\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E481:', 1)\n\n  lines =<< trim END\n      :123 echo 'yes'\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E481:', 1)\n\n  lines =<< trim END\n      :123 cd there\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E481:', 1)\nenddef\n\nlet g:alist = [7]\nlet g:astring = 'text'\nlet g:anumber = 123\n\ndef Test_delfunction()\n  # Check function is defined in script namespace\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'func CheckMe()',\n      '  return 123',\n      'endfunc',\n      'func DoTest()',\n      '  call assert_equal(123, s:CheckMe())',\n      'endfunc',\n      'DoTest()',\n      ])\n\n  # Check function in script namespace cannot be deleted\n  v9.CheckScriptFailure([\n      'vim9script',\n      'func DeleteMe1()',\n      'endfunc',\n      'delfunction DeleteMe1',\n      ], 'E1084:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'func DeleteMe2()',\n      'endfunc',\n      'def DoThat()',\n      '  delfunction DeleteMe2',\n      'enddef',\n      'DoThat()',\n      ], 'E1084:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'def DeleteMe3()',\n      'enddef',\n      'delfunction DeleteMe3',\n      ], 'E1084:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'def DeleteMe4()',\n      'enddef',\n      'def DoThat()',\n      '  delfunction DeleteMe4',\n      'enddef',\n      'DoThat()',\n      ], 'E1084:')\n\n  # Check that global :def function can be replaced and deleted\n  var lines =<< trim END\n      vim9script\n      def g:Global(): string\n        return \"yes\"\n      enddef\n      assert_equal(\"yes\", g:Global())\n      def! g:Global(): string\n        return \"no\"\n      enddef\n      assert_equal(\"no\", g:Global())\n      delfunc g:Global\n      assert_false(exists('*g:Global'))\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # Check that global function can be replaced by a :def function and deleted\n  lines =<< trim END\n      vim9script\n      func g:Global()\n        return \"yes\"\n      endfunc\n      assert_equal(\"yes\", g:Global())\n      def! g:Global(): string\n        return \"no\"\n      enddef\n      assert_equal(\"no\", g:Global())\n      delfunc g:Global\n      assert_false(exists('*g:Global'))\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # Check that global :def function can be replaced by a function and deleted\n  lines =<< trim END\n      vim9script\n      def g:Global(): string\n        return \"yes\"\n      enddef\n      assert_equal(\"yes\", g:Global())\n      func! g:Global()\n        return \"no\"\n      endfunc\n      assert_equal(\"no\", g:Global())\n      delfunc g:Global\n      assert_false(exists('*g:Global'))\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_wrong_type()\n  v9.CheckDefFailure(['var name: list<nothing>'], 'E1010:')\n  v9.CheckDefFailure(['var name: list<list<nothing>>'], 'E1010:')\n  v9.CheckDefFailure(['var name: dict<nothing>'], 'E1010:')\n  v9.CheckDefFailure(['var name: dict<dict<nothing>>'], 'E1010:')\n\n  v9.CheckDefFailure(['var name: dict<number'], 'E1009:')\n  v9.CheckDefFailure(['var name: dict<list<number>'], 'E1009:')\n\n  v9.CheckDefFailure(['var name: ally'], 'E1010:')\n  v9.CheckDefFailure(['var name: bram'], 'E1010:')\n  v9.CheckDefFailure(['var name: cathy'], 'E1010:')\n  v9.CheckDefFailure(['var name: dom'], 'E1010:')\n  v9.CheckDefFailure(['var name: freddy'], 'E1010:')\n  v9.CheckDefFailure(['var name: john'], 'E1010:')\n  v9.CheckDefFailure(['var name: larry'], 'E1010:')\n  v9.CheckDefFailure(['var name: ned'], 'E1010:')\n  v9.CheckDefFailure(['var name: pam'], 'E1010:')\n  v9.CheckDefFailure(['var name: sam'], 'E1010:')\n  v9.CheckDefFailure(['var name: vim'], 'E1010:')\n\n  v9.CheckDefFailure(['var Ref: number', 'Ref()'], 'E1085:')\n  v9.CheckDefFailure(['var Ref: string', 'var res = Ref()'], 'E1085:')\nenddef\n\ndef Test_script_namespace()\n  # defining a function or variable with s: is not allowed\n  var lines =<< trim END\n      vim9script\n      def s:Function()\n      enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1268:')\n\n  for decl in ['var', 'const', 'final']\n    lines =<< trim END\n        vim9script\n        var s:var = 'var'\n    END\n    v9.CheckScriptFailure([\n        'vim9script',\n        decl .. ' s:var = \"var\"',\n        ], 'E1268:')\n  endfor\n\n  # Calling a function or using a variable with s: is not allowed at script\n  # level\n  lines =<< trim END\n      vim9script\n      def Function()\n      enddef\n      s:Function()\n  END\n  v9.CheckScriptFailure(lines, 'E1268:')\n  lines =<< trim END\n      vim9script\n      def Function()\n      enddef\n      call s:Function()\n  END\n  v9.CheckScriptFailure(lines, 'E1268:')\n  lines =<< trim END\n      vim9script\n      var var = 'var'\n      echo s:var\n  END\n  v9.CheckScriptFailure(lines, 'E1268:')\nenddef\n\ndef Test_script_wrong_type()\n  var lines =<< trim END\n      vim9script\n      var dict: dict<string>\n      dict['a'] = ['x']\n  END\n  v9.CheckScriptFailure(lines, 'E1012: Type mismatch; expected string but got list<string>', 3)\nenddef\n\ndef Test_const()\n  v9.CheckDefFailure(['final name = 234', 'name = 99'], 'E1018:')\n  v9.CheckDefFailure(['final one = 234', 'var one = 99'], 'E1017:')\n  v9.CheckDefFailure(['final list = [1, 2]', 'var list = [3, 4]'], 'E1017:')\n  v9.CheckDefFailure(['final two'], 'E1125:')\n  v9.CheckDefFailure(['final &option'], 'E996:')\n\n  var lines =<< trim END\n    final list = [1, 2, 3]\n    list[0] = 4\n    list->assert_equal([4, 2, 3])\n    const other = [5, 6, 7]\n    other->assert_equal([5, 6, 7])\n\n    var varlist = [7, 8]\n    const constlist = [1, varlist, 3]\n    varlist[0] = 77\n    constlist[1][1] = 88\n    var cl = constlist[1]\n    cl[1] = 88\n    constlist->assert_equal([1, [77, 88], 3])\n\n    var vardict = {five: 5, six: 6}\n    const constdict = {one: 1, two: vardict, three: 3}\n    vardict['five'] = 55\n    constdict['two']['six'] = 66\n    var cd = constdict['two']\n    cd['six'] = 66\n    constdict->assert_equal({one: 1, two: {five: 55, six: 66}, three: 3})\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_const_bang()\n  var lines =<< trim END\n      const var = 234\n      var = 99\n  END\n  v9.CheckDefExecFailure(lines, 'E1018:', 2)\n  v9.CheckScriptFailure(['vim9script'] + lines, 'E46:', 3)\n\n  lines =<< trim END\n      const ll = [2, 3, 4]\n      ll[0] = 99\n  END\n  v9.CheckDefExecFailure(lines, 'E1119:', 2)\n  v9.CheckScriptFailure(['vim9script'] + lines, 'E741:', 3)\n\n  lines =<< trim END\n      const ll = [2, 3, 4]\n      ll[3] = 99\n  END\n  v9.CheckDefExecFailure(lines, 'E1118:', 2)\n  v9.CheckScriptFailure(['vim9script'] + lines, 'E684:', 3)\n\n  lines =<< trim END\n      const dd = {one: 1, two: 2}\n      dd[\"one\"] = 99\n  END\n  v9.CheckDefExecFailure(lines, 'E1121:', 2)\n  v9.CheckScriptFailure(['vim9script'] + lines, 'E741:', 3)\n\n  lines =<< trim END\n      const dd = {one: 1, two: 2}\n      dd[\"three\"] = 99\n  END\n  v9.CheckDefExecFailure(lines, 'E1120:')\n  v9.CheckScriptFailure(['vim9script'] + lines, 'E741:', 3)\nenddef\n\ndef Test_range_no_colon()\n  v9.CheckDefFailure(['%s/a/b/'], 'E1050:')\n  v9.CheckDefFailure(['+ s/a/b/'], 'E1050:')\n  v9.CheckDefFailure(['- s/a/b/'], 'E1050:')\n  v9.CheckDefFailure(['. s/a/b/'], 'E1050:')\nenddef\n\n\ndef Test_block()\n  var outer = 1\n  {\n    var inner = 2\n    assert_equal(1, outer)\n    assert_equal(2, inner)\n  }\n  assert_equal(1, outer)\n\n  {|echo 'yes'|}\nenddef\n\ndef Test_block_failure()\n  v9.CheckDefFailure(['{', 'var inner = 1', '}', 'echo inner'], 'E1001:')\n  v9.CheckDefFailure(['}'], 'E1025:')\n  v9.CheckDefFailure(['{', 'echo 1'], 'E1026:')\nenddef\n\ndef Test_block_local_vars()\n  var lines =<< trim END\n      vim9script\n      v:testing = 1\n      if true\n        var text = ['hello']\n        def SayHello(): list<string>\n          return text\n        enddef\n        def SetText(v: string)\n          text = [v]\n        enddef\n      endif\n\n      if true\n        var text = ['again']\n        def SayAgain(): list<string>\n          return text\n        enddef\n      endif\n\n      # test that the \"text\" variables are not cleaned up\n      test_garbagecollect_now()\n\n      defcompile\n\n      assert_equal(['hello'], SayHello())\n      assert_equal(['again'], SayAgain())\n\n      SetText('foobar')\n      assert_equal(['foobar'], SayHello())\n\n      call writefile(['ok'], 'Xdidit')\n      qall!\n  END\n\n  # need to execute this with a separate Vim instance to avoid the current\n  # context gets garbage collected.\n  writefile(lines, 'Xscript')\n  g:RunVim([], [], '-S Xscript')\n  assert_equal(['ok'], readfile('Xdidit'))\n\n  delete('Xscript')\n  delete('Xdidit')\nenddef\n\ndef Test_block_local_vars_with_func()\n  var lines =<< trim END\n      vim9script\n      if true\n        var foo = 'foo'\n        if true\n          var bar = 'bar'\n          def Func(): list<string>\n            return [foo, bar]\n          enddef\n        endif\n      endif\n      # function is compiled here, after blocks have finished, can still access\n      # \"foo\" and \"bar\"\n      assert_equal(['foo', 'bar'], Func())\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\n\" legacy func for command that's defined later\nfunc s:InvokeSomeCommand()\n  SomeCommand\nendfunc\n\ndef Test_autocommand_block()\n  com SomeCommand {\n      g:someVar = 'some'\n    }\n  InvokeSomeCommand()\n  assert_equal('some', g:someVar)\n\n  delcommand SomeCommand\n  unlet g:someVar\nenddef\n\ndef Test_command_block()\n  au BufNew *.xml {\n      g:otherVar = 'other'\n    }\n  split other.xml\n  assert_equal('other', g:otherVar)\n\n  bwipe!\n  au! BufNew *.xml\n  unlet g:otherVar\nenddef\n\nfunc g:NoSuchFunc()\n  echo 'none'\nendfunc\n\ndef Test_try_catch_throw()\n  var l = []\n  try # comment\n    add(l, '1')\n    throw 'wrong'\n    add(l, '2')\n  catch # comment\n    add(l, v:exception)\n  finally # comment\n    add(l, '3')\n  endtry # comment\n  assert_equal(['1', 'wrong', '3'], l)\n\n  l = []\n  try\n    try\n      add(l, '1')\n      throw 'wrong'\n      add(l, '2')\n    catch /right/\n      add(l, v:exception)\n    endtry\n  catch /wrong/\n    add(l, 'caught')\n  finally\n    add(l, 'finally')\n  endtry\n  assert_equal(['1', 'caught', 'finally'], l)\n\n  var n: number\n  try\n    n = l[3]\n  catch /E684:/\n    n = 99\n  endtry\n  assert_equal(99, n)\n\n  var done = 'no'\n  if 0\n    try | catch | endtry\n  else\n    done = 'yes'\n  endif\n  assert_equal('yes', done)\n\n  done = 'no'\n  if 1\n    done = 'yes'\n  else\n    try | catch | endtry\n    done = 'never'\n  endif\n  assert_equal('yes', done)\n\n  if 1\n  else\n    try | catch /pat/ | endtry\n    try | catch /pat/ \n    endtry\n    try \n    catch /pat/ | endtry\n    try \n    catch /pat/ \n    endtry\n  endif\n\n  try\n    # string slice returns a string, not a number\n    n = g:astring[3]\n  catch /E1012:/\n    n = 77\n  endtry\n  assert_equal(77, n)\n\n  try\n    n = l[g:astring]\n  catch /E1012:/\n    n = 88\n  endtry\n  assert_equal(88, n)\n\n  try\n    n = s:does_not_exist\n  catch /E121:/\n    n = 111\n  endtry\n  assert_equal(111, n)\n\n  try\n    n = g:does_not_exist\n  catch /E121:/\n    n = 121\n  endtry\n  assert_equal(121, n)\n\n  var d = {one: 1}\n  try\n    n = d[g:astring]\n  catch /E716:/\n    n = 222\n  endtry\n  assert_equal(222, n)\n\n  try\n    n = -g:astring\n  catch /E1012:/\n    n = 233\n  endtry\n  assert_equal(233, n)\n\n  try\n    n = +g:astring\n  catch /E1012:/\n    n = 244\n  endtry\n  assert_equal(244, n)\n\n  try\n    n = +g:alist\n  catch /E1012:/\n    n = 255\n  endtry\n  assert_equal(255, n)\n\n  var nd: dict<any>\n  try\n    nd = {[g:alist]: 1}\n  catch /E1105:/\n    n = 266\n  endtry\n  assert_equal(266, n)\n\n  l = [1, 2, 3] \n  try\n    [n] = l\n  catch /E1093:/\n    n = 277\n  endtry\n  assert_equal(277, n)\n\n  try\n    &ts = g:astring\n  catch /E1012:/\n    n = 288\n  endtry\n  assert_equal(288, n)\n\n  try\n    &backspace = 'asdf'\n  catch /E474:/\n    n = 299\n  endtry\n  assert_equal(299, n)\n\n  l = [1]\n  try\n    l[3] = 3\n  catch /E684:/\n    n = 300\n  endtry\n  assert_equal(300, n)\n\n  try\n    unlet g:does_not_exist\n  catch /E108:/\n    n = 322\n  endtry\n  assert_equal(322, n)\n\n  try\n    d = {text: 1, [g:astring]: 2}\n  catch /E721:/\n    n = 333\n  endtry\n  assert_equal(333, n)\n\n  try\n    l = g:DeletedFunc()\n  catch /E933:/\n    n = 344\n  endtry\n  assert_equal(344, n)\n\n  try\n    echo range(1, 2, 0)\n  catch /E726:/\n    n = 355\n  endtry\n  assert_equal(355, n)\n\n  var P = function('g:NoSuchFunc')\n  delfunc g:NoSuchFunc\n  try\n    echo P()\n  catch /E117:/\n    n = 366\n  endtry\n  assert_equal(366, n)\n\n  try\n    echo g:NoSuchFunc()\n  catch /E117:/\n    n = 377\n  endtry\n  assert_equal(377, n)\n\n  try\n    echo g:alist + 4\n  catch /E745:/\n    n = 388\n  endtry\n  assert_equal(388, n)\n\n  try\n    echo 4 + g:alist\n  catch /E745:/\n    n = 399\n  endtry\n  assert_equal(399, n)\n\n  try\n    echo g:alist.member\n  catch /E715:/\n    n = 400\n  endtry\n  assert_equal(400, n)\n\n  try\n    echo d.member\n  catch /E716:/\n    n = 411\n  endtry\n  assert_equal(411, n)\n\n  var counter = 0\n  for i in range(4)\n    try\n      eval [][0]\n    catch\n    endtry\n    counter += 1\n  endfor\n  assert_equal(4, counter)\n\n  # no requirement for spaces before |\n  try|echo 0|catch|endtry\n\n  # return in try with finally\n  def ReturnInTry(): number\n    var ret = 4\n    try\n      return ret\n    catch /this/\n      return -1\n    catch /that/\n      return -1\n    finally\n      # changing ret has no effect\n      ret = 7\n    endtry\n    return -2\n  enddef\n  assert_equal(4, ReturnInTry())\n\n  # return in catch with finally\n  def ReturnInCatch(): number\n    var ret = 5\n    try\n      throw 'getout'\n      return -1\n    catch /getout/\n      # ret is evaluated here\n      return ret\n    finally\n      # changing ret later has no effect\n      ret = -3\n    endtry\n    return -2\n  enddef\n  assert_equal(5, ReturnInCatch())\n\n  # return in finally after empty catch\n  def ReturnInFinally(): number\n    try\n    finally\n      return 6\n    endtry\n  enddef\n  assert_equal(6, ReturnInFinally())\n\n  var lines =<< trim END\n      vim9script\n      try\n        acos('0.5')\n          ->setline(1)\n      catch\n        g:caught = v:exception\n      endtry\n  END\n  v9.CheckScriptSuccess(lines)\n  assert_match('E1219: Float or Number required for argument 1', g:caught)\n  unlet g:caught\n\n  # missing catch and/or finally\n  lines =<< trim END\n      vim9script\n      try\n        echo 'something'\n      endtry\n  END\n  v9.CheckScriptFailure(lines, 'E1032:')\n\n  # skipping try-finally-endtry when try-finally-endtry is used in another block\n  lines =<< trim END\n      if v:true\n        try\n        finally\n        endtry\n      else\n        try\n        finally\n        endtry\n      endif\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_try_var_decl()\n  var lines =<< trim END\n      vim9script\n      try\n        var in_try = 1\n        assert_equal(1, get(s:, 'in_try', -1))\n        throw \"getout\"\n      catch\n        var in_catch = 2\n        assert_equal(-1, get(s:, 'in_try', -1))\n        assert_equal(2, get(s:, 'in_catch', -1))\n      finally\n        var in_finally = 3\n        assert_equal(-1, get(s:, 'in_try', -1))\n        assert_equal(-1, get(s:, 'in_catch', -1))\n        assert_equal(3, get(s:, 'in_finally', -1))\n      endtry\n      assert_equal(-1, get(s:, 'in_try', -1))\n      assert_equal(-1, get(s:, 'in_catch', -1))\n      assert_equal(-1, get(s:, 'in_finally', -1))\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_try_ends_in_return()\n  var lines =<< trim END\n      vim9script\n      def Foo(): string\n        try\n          return 'foo'\n        catch\n          return 'caught'\n        endtry\n      enddef\n      assert_equal('foo', Foo())\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Foo(): string\n        try\n          return 'foo'\n        catch\n          return 'caught'\n        endtry\n        echo 'notreached'\n      enddef\n      assert_equal('foo', Foo())\n  END\n  v9.CheckScriptFailure(lines, 'E1095:')\n\n  lines =<< trim END\n      vim9script\n      def Foo(): string\n        try\n          return 'foo'\n        catch /x/\n          return 'caught'\n        endtry\n      enddef\n      assert_equal('foo', Foo())\n  END\n  v9.CheckScriptFailure(lines, 'E1027:')\n\n  lines =<< trim END\n      vim9script\n      def Foo(): string\n        try\n          echo 'foo'\n        catch\n          echo 'caught'\n        finally\n          return 'done'\n        endtry\n      enddef\n      assert_equal('done', Foo())\n  END\n  v9.CheckScriptSuccess(lines)\n\nenddef\n\ndef Test_try_in_catch()\n  var lines =<< trim END\n      vim9script\n      var seq = []\n      def DoIt()\n        try\n          seq->add('throw 1')\n          eval [][0]\n          seq->add('notreached')\n        catch\n          seq->add('catch')\n          try\n            seq->add('throw 2')\n            eval [][0]\n            seq->add('notreached')\n          catch /nothing/\n            seq->add('notreached')\n          endtry\n          seq->add('done')\n        endtry\n      enddef\n      DoIt()\n      assert_equal(['throw 1', 'catch', 'throw 2', 'done'], seq)\n  END\nenddef\n\ndef Test_error_in_catch()\n  var lines =<< trim END\n      try\n        eval [][0]\n      catch /E684:/\n        eval [][0]\n      endtry\n  END\n  v9.CheckDefExecFailure(lines, 'E684:', 4)\nenddef\n\n\" :while at the very start of a function that :continue jumps to\ndef s:TryContinueFunc()\n while g:Count < 2\n   g:sequence ..= 't'\n    try\n      echoerr 'Test'\n    catch\n      g:Count += 1\n      g:sequence ..= 'c'\n      continue\n    endtry\n    g:sequence ..= 'e'\n    g:Count += 1\n  endwhile\nenddef\n\ndef Test_continue_in_try_in_while()\n  g:Count = 0\n  g:sequence = ''\n  TryContinueFunc()\n  assert_equal('tctc', g:sequence)\n  unlet g:Count\n  unlet g:sequence\nenddef\n\ndef Test_break_in_try_in_for()\n  var lines =<< trim END\n      vim9script\n      def Ls(): list<string>\n        var ls: list<string>\n        for s in ['abc', 'def']\n          for _ in [123, 456]\n            try\n              eval [][0]\n            catch\n              break\n            endtry\n          endfor\n          ls += [s]\n        endfor\n        return ls\n      enddef\n      assert_equal(['abc', 'def'], Ls())\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_nocatch_return_in_try()\n  # return in try block returns normally\n  def ReturnInTry(): string\n    try\n      return '\"some message\"'\n    catch\n    endtry\n    return 'not reached'\n  enddef\n  exe 'echoerr ' .. ReturnInTry()\nenddef\n\ndef Test_cnext_works_in_catch()\n  var lines =<< trim END\n      vim9script\n      au BufEnter * eval 1 + 2\n      writefile(['text'], 'Xfile1')\n      writefile(['text'], 'Xfile2')\n      var items = [\n          {lnum: 1, filename: 'Xfile1', valid: true},\n          {lnum: 1, filename: 'Xfile2', valid: true}\n        ]\n      setqflist([], ' ', {items: items})\n      cwindow\n\n      def CnextOrCfirst()\n        # if cnext fails, cfirst is used\n        try\n          cnext\n        catch\n          cfirst\n        endtry\n      enddef\n\n      CnextOrCfirst()\n      CnextOrCfirst()\n      writefile([getqflist({idx: 0}).idx], 'Xresult')\n      qall\n  END\n  writefile(lines, 'XCatchCnext')\n  g:RunVim([], [], '--clean -S XCatchCnext')\n  assert_equal(['1'], readfile('Xresult'))\n\n  delete('Xfile1')\n  delete('Xfile2')\n  delete('XCatchCnext')\n  delete('Xresult')\nenddef\n\ndef Test_throw_skipped()\n  if 0\n    throw dontgethere\n  endif\nenddef\n\ndef Test_nocatch_throw_silenced()\n  var lines =<< trim END\n    vim9script\n    def Func()\n      throw 'error'\n    enddef\n    silent! Func()\n  END\n  writefile(lines, 'XthrowSilenced')\n  source XthrowSilenced\n  delete('XthrowSilenced')\nenddef\n\ndef DeletedFunc(): list<any>\n  return ['delete me']\nenddef\ndefcompile\ndelfunc DeletedFunc\n\ndef s:ThrowFromDef()\n  throw \"getout\" # comment\nenddef\n\nfunc s:CatchInFunc()\n  try\n    call s:ThrowFromDef()\n  catch\n    let g:thrown_func = v:exception\n  endtry\nendfunc\n\ndef s:CatchInDef()\n  try\n    ThrowFromDef()\n  catch\n    g:thrown_def = v:exception\n  endtry\nenddef\n\ndef s:ReturnFinally(): string\n  try\n    return 'intry'\n  finally\n    g:in_finally = 'finally'\n  endtry\n  return 'end'\nenddef\n\ndef Test_try_catch_nested()\n  CatchInFunc()\n  assert_equal('getout', g:thrown_func)\n\n  CatchInDef()\n  assert_equal('getout', g:thrown_def)\n\n  assert_equal('intry', ReturnFinally())\n  assert_equal('finally', g:in_finally)\n\n  var l = []\n  try\n    l->add('1')\n    throw 'bad'\n    l->add('x')\n  catch /bad/\n    l->add('2')\n    try\n      l->add('3')\n      throw 'one'\n      l->add('x')\n    catch /one/\n      l->add('4')\n      try\n        l->add('5')\n        throw 'more'\n        l->add('x')\n      catch /more/\n        l->add('6')\n      endtry\n    endtry\n  endtry\n  assert_equal(['1', '2', '3', '4', '5', '6'], l)\n\n  l = []\n  try\n    try\n      l->add('1')\n      throw 'foo'\n      l->add('x')\n    catch\n      l->add('2')\n      throw 'bar'\n      l->add('x')\n    finally\n      l->add('3')\n    endtry\n    l->add('x')\n  catch /bar/\n    l->add('4')\n  endtry\n  assert_equal(['1', '2', '3', '4'], l)\nenddef\n\ndef s:TryOne(): number\n  try\n    return 0\n  catch\n  endtry\n  return 0\nenddef\n\ndef s:TryTwo(n: number): string\n  try\n    var x = {}\n  catch\n  endtry\n  return 'text'\nenddef\n\ndef Test_try_catch_twice()\n  assert_equal('text', TryOne()->TryTwo())\nenddef\n\ndef Test_try_catch_match()\n  var seq = 'a'\n  try\n    throw 'something'\n  catch /nothing/\n    seq ..= 'x'\n  catch /some/\n    seq ..= 'b'\n  catch /asdf/\n    seq ..= 'x'\n  catch ?a\\?sdf?\n    seq ..= 'y'\n  finally\n    seq ..= 'c'\n  endtry\n  assert_equal('abc', seq)\nenddef\n\ndef Test_try_catch_fails()\n  v9.CheckDefFailure(['catch'], 'E603:')\n  v9.CheckDefFailure(['try', 'echo 0', 'catch', 'catch'], 'E1033:')\n  v9.CheckDefFailure(['try', 'echo 0', 'catch /pat'], 'E1067:')\n  v9.CheckDefFailure(['finally'], 'E606:')\n  v9.CheckDefFailure(['try', 'echo 0', 'finally', 'echo 1', 'finally'], 'E607:')\n  v9.CheckDefFailure(['endtry'], 'E602:')\n  v9.CheckDefFailure(['while 1', 'endtry'], 'E170:')\n  v9.CheckDefFailure(['for i in range(5)', 'endtry'], 'E170:')\n  v9.CheckDefFailure(['if 1', 'endtry'], 'E171:')\n  v9.CheckDefFailure(['try', 'echo 1', 'endtry'], 'E1032:')\n\n  v9.CheckDefFailure(['throw'], 'E1143:')\n  v9.CheckDefFailure(['throw xxx'], 'E1001:')\nenddef\n\ndef Try_catch_skipped()\n  var l = []\n  try\n  finally\n  endtry\n\n  if 1\n  else\n    try\n    endtry\n  endif\nenddef\n\n\" The skipped try/endtry was updating the wrong instruction.\ndef Test_try_catch_skipped()\n  var instr = execute('disassemble Try_catch_skipped')\n  assert_match(\"NEWLIST size 0\\n\", instr)\nenddef\n\ndef Test_throw_line_number()\n  def Func()\n    eval 1 + 1\n    eval 2 + 2\n    throw 'exception'\n  enddef\n  try\n    Func()\n  catch /exception/\n    assert_match('line 3', v:throwpoint)\n  endtry\nenddef\n\n\ndef Test_throw_vimscript()\n  # only checks line continuation\n  var lines =<< trim END\n      vim9script\n      try\n        throw 'one'\n              .. 'two'\n      catch\n        assert_equal('onetwo', v:exception)\n      endtry\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    @r = ''\n    def Func()\n      throw @r\n    enddef\n    var result = ''\n    try\n      Func()\n    catch /E1129:/\n      result = 'caught'\n    endtry\n    assert_equal('caught', result)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_error_in_nested_function()\n  # an error in a nested :function aborts executing in the calling :def function\n  var lines =<< trim END\n      vim9script\n      def Func()\n        Error()\n        g:test_var = 1\n      enddef\n      func Error() abort\n        eval [][0]\n      endfunc\n      Func()\n  END\n  g:test_var = 0\n  v9.CheckScriptFailure(lines, 'E684:')\n  assert_equal(0, g:test_var)\nenddef\n\ndef Test_abort_after_error()\n  var lines =<< trim END\n      vim9script\n      while true\n        echo notfound\n      endwhile\n      g:gotthere = true\n  END\n  g:gotthere = false\n  v9.CheckScriptFailure(lines, 'E121:')\n  assert_false(g:gotthere)\n  unlet g:gotthere\nenddef\n\ndef Test_cexpr_vimscript()\n  # only checks line continuation\n  set errorformat=File\\ %f\\ line\\ %l\n  var lines =<< trim END\n      vim9script\n      cexpr 'File'\n                .. ' someFile' ..\n                   ' line 19'\n      assert_equal(19, getqflist()[0].lnum)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def CexprFail()\n        au QuickfixCmdPre * echo g:doesnotexist\n        cexpr 'File otherFile line 99'\n        g:didContinue = 'yes'\n      enddef\n      CexprFail()\n      g:didContinue = 'also'\n  END\n  g:didContinue = 'no'\n  v9.CheckScriptFailure(lines, 'E121: Undefined variable: g:doesnotexist')\n  assert_equal('no', g:didContinue)\n  au! QuickfixCmdPre\n\n  lines =<< trim END\n      vim9script\n      def CexprFail()\n        cexpr g:aNumber\n        g:didContinue = 'yes'\n      enddef\n      CexprFail()\n      g:didContinue = 'also'\n  END\n  g:aNumber = 123\n  g:didContinue = 'no'\n  v9.CheckScriptFailure(lines, 'E777: String or List expected')\n  assert_equal('no', g:didContinue)\n  unlet g:didContinue\n\n  set errorformat&\nenddef\n\ndef Test_statusline_syntax()\n  # legacy syntax is used for 'statusline'\n  var lines =<< trim END\n      vim9script\n      func g:Status()\n        return '%{\"x\" is# \"x\"}'\n      endfunc\n      set laststatus=2 statusline=%!Status()\n      redrawstatus\n      set laststatus statusline= \n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_list_vimscript()\n  # checks line continuation and comments\n  var lines =<< trim END\n      vim9script\n      var mylist = [\n            'one',\n            # comment\n            'two', # empty line follows\n\n            'three',\n            ]\n      assert_equal(['one', 'two', 'three'], mylist)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # check all lines from heredoc are kept\n  lines =<< trim END\n      # comment 1\n      two\n      # comment 3\n\n      five\n      # comment 6\n  END\n  assert_equal(['# comment 1', 'two', '# comment 3', '', 'five', '# comment 6'], lines)\n\n  lines =<< trim END\n    [{\n      a: 0}]->string()->assert_equal(\"[{'a': 0}]\")\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\nif has('channel')\n  let someJob = test_null_job()\n\n  def FuncWithError()\n    echomsg g:someJob\n  enddef\n\n  func Test_convert_emsg_to_exception()\n    try\n      call FuncWithError()\n    catch\n      call assert_match('Vim:E908:', v:exception)\n    endtry\n  endfunc\nendif\n\ndef Test_vim9script_mix()\n  var lines =<< trim END\n    if has(g:feature)\n      \" legacy script\n      let g:legacy = 1\n      finish\n    endif\n    vim9script\n    g:legacy = 0\n  END\n  g:feature = 'eval'\n  g:legacy = -1\n  v9.CheckScriptSuccess(lines)\n  assert_equal(1, g:legacy)\n\n  g:feature = 'noteval'\n  g:legacy = -1\n  v9.CheckScriptSuccess(lines)\n  assert_equal(0, g:legacy)\nenddef\n\ndef Test_vim9script_fails()\n  v9.CheckScriptFailure(['scriptversion 2', 'vim9script'], 'E1039:')\n  v9.CheckScriptFailure(['vim9script', 'scriptversion 2'], 'E1040:')\n\n  v9.CheckScriptFailure(['vim9script', 'var str: string', 'str = 1234'], 'E1012:')\n  v9.CheckScriptFailure(['vim9script', 'const str = \"asdf\"', 'str = \"xxx\"'], 'E46:')\n\n  assert_fails('vim9script', 'E1038:')\n  v9.CheckDefFailure(['vim9script'], 'E1038:')\n\n  # no error when skipping\n  if has('nothing')\n    vim9script\n  endif\nenddef\n\ndef Test_script_var_shadows_function()\n  var lines =<< trim END\n      vim9script\n      def Func(): number\n        return 123\n      enddef\n      var Func = 1\n  END\n  v9.CheckScriptFailure(lines, 'E1041:', 5)\nenddef\n\ndef Test_function_shadows_script_var()\n  var lines =<< trim END\n      vim9script\n      var Func = 1\n      def Func(): number\n        return 123\n      enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1041:', 3)\nenddef\n\ndef Test_script_var_shadows_command()\n  var lines =<< trim END\n      var undo = 1\n      undo = 2\n      assert_equal(2, undo)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var undo = 1\n      undo\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1207:', 2)\nenddef\n\ndef Test_vim9script_call_wrong_type()\n  var lines =<< trim END\n      vim9script\n      var Time = 'localtime'\n      Time()\n  END\n  v9.CheckScriptFailure(lines, 'E1085:')\nenddef\n\ndef Test_vim9script_reload_delfunc()\n  var first_lines =<< trim END\n    vim9script\n    def FuncYes(): string\n      return 'yes'\n    enddef\n  END\n  var withno_lines =<< trim END\n    def FuncNo(): string\n      return 'no'\n    enddef\n    def g:DoCheck(no_exists: bool)\n      assert_equal('yes', FuncYes())\n      assert_equal('no', FuncNo())\n    enddef\n  END\n  var nono_lines =<< trim END\n    def g:DoCheck(no_exists: bool)\n      assert_equal('yes', FuncYes())\n      assert_fails('FuncNo()', 'E117:', '', 2, 'DoCheck')\n    enddef\n  END\n\n  # FuncNo() is defined\n  writefile(first_lines + withno_lines, 'Xreloaded.vim')\n  source Xreloaded.vim\n  g:DoCheck(true)\n\n  # FuncNo() is not redefined\n  writefile(first_lines + nono_lines, 'Xreloaded.vim')\n  source Xreloaded.vim\n  g:DoCheck(false)\n\n  # FuncNo() is back\n  writefile(first_lines + withno_lines, 'Xreloaded.vim')\n  source Xreloaded.vim\n  g:DoCheck(false)\n\n  delete('Xreloaded.vim')\nenddef\n\ndef Test_vim9script_reload_delvar()\n  # write the script with a script-local variable\n  var lines =<< trim END\n    vim9script\n    var name = 'string'\n  END\n  writefile(lines, 'XreloadVar.vim')\n  source XreloadVar.vim\n\n  # now write the script using the same variable locally - works\n  lines =<< trim END\n    vim9script\n    def Func()\n      var name = 'string'\n    enddef\n  END\n  writefile(lines, 'XreloadVar.vim')\n  source XreloadVar.vim\n\n  delete('XreloadVar.vim')\nenddef\n\ndef Test_func_redefine_error()\n  var lines = [\n        'vim9script',\n        'def Func()',\n        '  eval [][0]',\n        'enddef',\n        'Func()',\n        ]\n  writefile(lines, 'Xtestscript.vim')\n\n  for count in range(3)\n    try\n      source Xtestscript.vim\n    catch /E684/\n      # function name should contain <SNR> every time\n      assert_match('E684: List index out of range', v:exception)\n      assert_match('function <SNR>\\d\\+_Func, line 1', v:throwpoint)\n    endtry\n  endfor\n\n  delete('Xtestscript.vim')\nenddef\n\ndef Test_func_redefine_fails()\n  var lines =<< trim END\n    vim9script\n    def Func()\n      echo 'one'\n    enddef\n    def Func()\n      echo 'two'\n    enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1073:')\n\n  lines =<< trim END\n    vim9script\n    def Foo(): string\n      return 'foo'\n    enddef\n    def Func()\n      var  Foo = {-> 'lambda'}\n    enddef\n    defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1073:')\nenddef\n\ndef Test_fixed_size_list()\n  # will be allocated as one piece of memory, check that changes work\n  var l = [1, 2, 3, 4]\n  l->remove(0)\n  l->add(5)\n  l->insert(99, 1)\n  assert_equal([2, 99, 3, 4, 5], l)\nenddef\n\ndef Test_no_insert_xit()\n  v9.CheckDefExecFailure(['a = 1'], 'E1100:')\n  v9.CheckDefExecFailure(['c = 1'], 'E1100:')\n  v9.CheckDefExecFailure(['i = 1'], 'E1100:')\n  v9.CheckDefExecFailure(['t = 1'], 'E1100:')\n  v9.CheckDefExecFailure(['x = 1'], 'E1100:')\n\n  v9.CheckScriptFailure(['vim9script', 'a = 1'], 'E488:')\n  v9.CheckScriptFailure(['vim9script', 'a'], 'E1100:')\n  v9.CheckScriptFailure(['vim9script', 'c = 1'], 'E488:')\n  v9.CheckScriptFailure(['vim9script', 'c'], 'E1100:')\n  v9.CheckScriptFailure(['vim9script', 'i = 1'], 'E488:')\n  v9.CheckScriptFailure(['vim9script', 'i'], 'E1100:')\n  v9.CheckScriptFailure(['vim9script', 'o = 1'], 'E1100:')\n  v9.CheckScriptFailure(['vim9script', 'o'], 'E1100:')\n  v9.CheckScriptFailure(['vim9script', 't'], 'E1100:')\n  v9.CheckScriptFailure(['vim9script', 't = 1'], 'E1100:')\n  v9.CheckScriptFailure(['vim9script', 'x = 1'], 'E1100:')\nenddef\n\ndef s:IfElse(what: number): string\n  var res = ''\n  if what == 1\n    res = \"one\"\n  elseif what == 2\n    res = \"two\"\n  else\n    res = \"three\"\n  endif\n  return res\nenddef\n\ndef Test_if_elseif_else()\n  assert_equal('one', IfElse(1))\n  assert_equal('two', IfElse(2))\n  assert_equal('three', IfElse(3))\nenddef\n\ndef Test_if_elseif_else_fails()\n  v9.CheckDefFailure(['elseif true'], 'E582:')\n  v9.CheckDefFailure(['else'], 'E581:')\n  v9.CheckDefFailure(['endif'], 'E580:')\n  v9.CheckDefFailure(['if g:abool', 'elseif xxx'], 'E1001:')\n  v9.CheckDefFailure(['if true', 'echo 1'], 'E171:')\n\n  var lines =<< trim END\n      var s = ''\n      if s = ''\n      endif\n  END\n  v9.CheckDefFailure(lines, 'E488:')\n\n  lines =<< trim END\n      var s = ''\n      if s == ''\n      elseif s = ''\n      endif\n  END\n  v9.CheckDefFailure(lines, 'E488:')\n\n  lines =<< trim END\n      var cond = true\n      if cond\n        echo 'true'\n      elseif\n        echo 'false'\n      endif\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E1143:', 'E15:'], 4)\nenddef\n\ndef Test_if_else_func_using_var()\n  var lines =<< trim END\n      vim9script\n\n      const debug = true\n      if debug\n        var mode_chars = 'something'\n        def Bits2Ascii()\n          var x = mode_chars\n          g:where = 'in true'\n        enddef\n      else\n        def Bits2Ascii()\n          g:where = 'in false'\n        enddef\n      endif\n\n      Bits2Ascii()\n  END\n  v9.CheckScriptSuccess(lines)\n  assert_equal('in true', g:where)\n  unlet g:where\n\n  lines =<< trim END\n      vim9script\n\n      const debug = false\n      if debug\n        var mode_chars = 'something'\n        def Bits2Ascii()\n          g:where = 'in true'\n        enddef\n      else\n        def Bits2Ascii()\n          var x = mode_chars\n          g:where = 'in false'\n        enddef\n      endif\n\n      Bits2Ascii()\n  END\n  v9.CheckScriptFailure(lines, 'E1001: Variable not found: mode_chars')\nenddef\n\nlet g:bool_true = v:true\nlet g:bool_false = v:false\n\ndef Test_if_const_expr()\n  var res = false\n  if true ? true : false\n    res = true\n  endif\n  assert_equal(true, res)\n\n  g:glob = 2\n  if false\n    execute('g:glob = 3')\n  endif\n  assert_equal(2, g:glob)\n  if true\n    execute('g:glob = 3')\n  endif\n  assert_equal(3, g:glob)\n\n  res = false\n  if g:bool_true ? true : false\n    res = true\n  endif\n  assert_equal(true, res)\n\n  res = false\n  if true ? g:bool_true : false\n    res = true\n  endif\n  assert_equal(true, res)\n\n  res = false\n  if true ? true : g:bool_false\n    res = true\n  endif\n  assert_equal(true, res)\n\n  res = false\n  if true ? false : true\n    res = true\n  endif\n  assert_equal(false, res)\n\n  res = false\n  if false ? false : true\n    res = true\n  endif\n  assert_equal(true, res)\n\n  res = false\n  if false ? true : false\n    res = true\n  endif\n  assert_equal(false, res)\n\n  res = false\n  if has('xyz') ? true : false\n    res = true\n  endif\n  assert_equal(false, res)\n\n  res = false\n  if true && true\n    res = true\n  endif\n  assert_equal(true, res)\n\n  res = false\n  if true && false\n    res = true\n  endif\n  assert_equal(false, res)\n\n  res = false\n  if g:bool_true && false\n    res = true\n  endif\n  assert_equal(false, res)\n\n  res = false\n  if true && g:bool_false\n    res = true\n  endif\n  assert_equal(false, res)\n\n  res = false\n  if false && false\n    res = true\n  endif\n  assert_equal(false, res)\n\n  res = false\n  if true || false\n    res = true\n  endif\n  assert_equal(true, res)\n\n  res = false\n  if g:bool_true || false\n    res = true\n  endif\n  assert_equal(true, res)\n\n  res = false\n  if true || g:bool_false\n    res = true\n  endif\n  assert_equal(true, res)\n\n  res = false\n  if false || false\n    res = true\n  endif\n  assert_equal(false, res)\n\n  # with constant \"false\" expression may be invalid so long as the syntax is OK\n  if false | eval 1 + 2 | endif\n  if false | eval burp + 234 | endif\n  if false | echo burp 234 'asd' | endif\n  if false\n    burp\n  endif\n\n  if 0\n    if 1\n      echo nothing\n    elseif 1\n      echo still nothing\n    endif\n  endif\n\n  # expression with line breaks skipped\n  if false\n      ('aaa'\n      .. 'bbb'\n      .. 'ccc'\n      )->setline(1)\n  endif\nenddef\n\ndef Test_if_const_expr_fails()\n  v9.CheckDefFailure(['if \"aaa\" == \"bbb'], 'E114:')\n  v9.CheckDefFailure([\"if 'aaa' == 'bbb\"], 'E115:')\n  v9.CheckDefFailure([\"if has('aaa'\"], 'E110:')\n  v9.CheckDefFailure([\"if has('aaa') ? true false\"], 'E109:')\nenddef\n\ndef s:RunNested(i: number): number\n  var x: number = 0\n  if i % 2\n    if 1\n      # comment\n    else\n      # comment\n    endif\n    x += 1\n  else\n    x += 1000\n  endif\n  return x\nenddef\n\ndef Test_nested_if()\n  assert_equal(1, RunNested(1))\n  assert_equal(1000, RunNested(2))\nenddef\n\ndef Test_execute_cmd()\n  # missing argument is ignored\n  execute\n  execute # comment\n\n  new\n  setline(1, 'default')\n  execute 'setline(1, \"execute-string\")'\n  assert_equal('execute-string', getline(1))\n\n  execute \"setline(1, 'execute-string')\"\n  assert_equal('execute-string', getline(1))\n\n  var cmd1 = 'setline(1,'\n  var cmd2 = '\"execute-var\")'\n  execute cmd1 cmd2 # comment\n  assert_equal('execute-var', getline(1))\n\n  execute cmd1 cmd2 '|setline(1, \"execute-var-string\")'\n  assert_equal('execute-var-string', getline(1))\n\n  var cmd_first = 'call '\n  var cmd_last = 'setline(1, \"execute-var-var\")'\n  execute cmd_first .. cmd_last\n  assert_equal('execute-var-var', getline(1))\n  bwipe!\n\n  var n = true\n  execute 'echomsg' (n ? '\"true\"' : '\"no\"')\n  assert_match('^true$', g:Screenline(&lines))\n\n  echomsg [1, 2, 3] {a: 1, b: 2}\n  assert_match('^\\[1, 2, 3\\] {''a'': 1, ''b'': 2}$', g:Screenline(&lines))\n\n  v9.CheckDefFailure(['execute xxx'], 'E1001:', 1)\n  v9.CheckDefExecFailure(['execute \"tabnext \" .. 8'], 'E475:', 1)\n  v9.CheckDefFailure(['execute \"cmd\"# comment'], 'E488:', 1)\n  if has('channel')\n    v9.CheckDefExecFailure(['execute test_null_channel()'], 'E908:', 1)\n  endif\nenddef\n\ndef Test_execute_cmd_vimscript()\n  # only checks line continuation\n  var lines =<< trim END\n      vim9script\n      execute 'g:someVar'\n                .. ' = ' ..\n                   '28'\n      assert_equal(28, g:someVar)\n      unlet g:someVar\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_execute_finish()\n  # the empty lines are relevant here\n  var lines =<< trim END\n      vim9script\n\n      var vname = \"g:hello\"\n\n      if exists(vname) | finish | endif | execute vname '= \"world\"'\n\n      assert_equal('world', g:hello)\n\n      if exists(vname) | finish | endif | execute vname '= \"world\"'\n\n      assert_report('should not be reached')\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_echo_cmd()\n  echo 'some' # comment\n  echon 'thing'\n  assert_match('^something$', g:Screenline(&lines))\n\n  echo \"some\" # comment\n  echon \"thing\"\n  assert_match('^something$', g:Screenline(&lines))\n\n  var str1 = 'some'\n  var str2 = 'more'\n  echo str1 str2\n  assert_match('^some more$', g:Screenline(&lines))\n\n  echo \"one\\ntwo\"\n  assert_match('^one$', g:Screenline(&lines - 1))\n  assert_match('^two$', g:Screenline(&lines))\n\n  v9.CheckDefFailure(['echo \"xxx\"# comment'], 'E488:')\nenddef\n\ndef Test_echomsg_cmd()\n  echomsg 'some' 'more' # comment\n  assert_match('^some more$', g:Screenline(&lines))\n  echo 'clear'\n  :1messages\n  assert_match('^some more$', g:Screenline(&lines))\n\n  v9.CheckDefFailure(['echomsg \"xxx\"# comment'], 'E488:')\nenddef\n\ndef Test_echomsg_cmd_vimscript()\n  # only checks line continuation\n  var lines =<< trim END\n      vim9script\n      echomsg 'here'\n                .. ' is ' ..\n                   'a message'\n      assert_match('^here is a message$', g:Screenline(&lines))\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_echoerr_cmd()\n  var local = 'local'\n  try\n    echoerr 'something' local 'wrong' # comment\n  catch\n    assert_match('something local wrong', v:exception)\n  endtry\nenddef\n\ndef Test_echoerr_cmd_vimscript()\n  # only checks line continuation\n  var lines =<< trim END\n      vim9script\n      try\n        echoerr 'this'\n                .. ' is ' ..\n                   'wrong'\n      catch\n        assert_match('this is wrong', v:exception)\n      endtry\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_echoconsole_cmd()\n  var local = 'local'\n  echoconsole 'something' local # comment\n  # output goes anywhere\nenddef\n\ndef Test_for_outside_of_function()\n  var lines =<< trim END\n    vim9script\n    new\n    for var in range(0, 3)\n      append(line('$'), var)\n    endfor\n    assert_equal(['', '0', '1', '2', '3'], getline(1, '$'))\n    bwipe!\n\n    var result = ''\n    for i in [1, 2, 3]\n      var loop = ' loop ' .. i\n      result ..= loop\n    endfor\n    assert_equal(' loop 1 loop 2 loop 3', result)\n  END\n  writefile(lines, 'Xvim9for.vim')\n  source Xvim9for.vim\n  delete('Xvim9for.vim')\nenddef\n\ndef Test_for_skipped_block()\n  # test skipped blocks at outside of function\n  var lines =<< trim END\n    var result = []\n    if true\n      for n in [1, 2]\n        result += [n]\n      endfor\n    else\n      for n in [3, 4]\n        result += [n]\n      endfor\n    endif\n    assert_equal([1, 2], result)\n\n    result = []\n    if false\n      for n in [1, 2]\n        result += [n]\n      endfor\n    else\n      for n in [3, 4]\n        result += [n]\n      endfor\n    endif\n    assert_equal([3, 4], result)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  # test skipped blocks at inside of function\n  lines =<< trim END\n    def DefTrue()\n      var result = []\n      if true\n        for n in [1, 2]\n          result += [n]\n        endfor\n      else\n        for n in [3, 4]\n          result += [n]\n        endfor\n      endif\n      assert_equal([1, 2], result)\n    enddef\n    DefTrue()\n\n    def DefFalse()\n      var result = []\n      if false\n        for n in [1, 2]\n          result += [n]\n        endfor\n      else\n        for n in [3, 4]\n          result += [n]\n        endfor\n      endif\n      assert_equal([3, 4], result)\n    enddef\n    DefFalse()\n\n    def BuildDiagrams()\n      var diagrams: list<any>\n      if false\n        var max = 0\n        for v in diagrams\n          var l = 3\n          if max < l | max = l | endif\n          v->add(l)\n        endfor\n      endif\n    enddef\n    BuildDiagrams()\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_skipped_redir()\n  var lines =<< trim END\n      def T()\n        if 0\n          redir =>l[0]\n          redir END\n        endif\n      enddef\n      defcompile\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_for_loop()\n  var lines =<< trim END\n      var result = ''\n      for cnt in range(7)\n        if cnt == 4\n          break\n        endif\n        if cnt == 2\n          continue\n        endif\n        result ..= cnt .. '_'\n      endfor\n      assert_equal('0_1_3_', result)\n\n      var concat = ''\n      for str in eval('[\"one\", \"two\"]')\n        concat ..= str\n      endfor\n      assert_equal('onetwo', concat)\n\n      var total = 0\n      for nr in\n          [1, 2, 3]\n        total += nr\n      endfor\n      assert_equal(6, total)\n\n      total = 0\n      for nr\n        in [1, 2, 3]\n        total += nr\n      endfor\n      assert_equal(6, total)\n\n      total = 0\n      for nr\n        in\n        [1, 2, 3]\n        total += nr\n      endfor\n      assert_equal(6, total)\n\n      # with type\n      total = 0\n      for n: number in [1, 2, 3]\n        total += n\n      endfor\n      assert_equal(6, total)\n\n      total = 0\n      for b in 0z010203\n        total += b\n      endfor\n      assert_equal(6, total)\n\n      var chars = ''\n      for s: string in 'foobar'\n        chars ..= s\n      endfor\n      assert_equal('foobar', chars)\n\n      chars = ''\n      for x: string in {a: 'a', b: 'b'}->values()\n        chars ..= x\n      endfor\n      assert_equal('ab', chars)\n\n      # unpack with type\n      var res = ''\n      for [n: number, s: string] in [[1, 'a'], [2, 'b']]\n        res ..= n .. s\n      endfor\n      assert_equal('1a2b', res)\n\n      # unpack with one var\n      var reslist = []\n      for [x] in [['aaa'], ['bbb']]\n        reslist->add(x)\n      endfor\n      assert_equal(['aaa', 'bbb'], reslist)\n\n      # loop over string\n      res = ''\n      for c in 'a\u00e9c\u0300d'\n        res ..= c .. '-'\n      endfor\n      assert_equal('a-\u00e9-c\u0300-d-', res)\n\n      res = ''\n      for c in ''\n        res ..= c .. '-'\n      endfor\n      assert_equal('', res)\n\n      res = ''\n      for c in test_null_string()\n        res ..= c .. '-'\n      endfor\n      assert_equal('', res)\n\n      total = 0\n      for c in null_list\n        total += 1\n      endfor\n      assert_equal(0, total)\n\n      for c in null_blob\n        total += 1\n      endfor\n      assert_equal(0, total)\n\n      var foo: list<dict<any>> = [\n              {a: 'Cat'}\n            ]\n      for dd in foo\n        dd.counter = 12\n      endfor\n      assert_equal([{a: 'Cat', counter: 12}], foo)\n\n      reslist = []\n      for _ in range(3)\n        reslist->add('x')\n      endfor\n      assert_equal(['x', 'x', 'x'], reslist)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_for_loop_with_closure()\n  var lines =<< trim END\n      var flist: list<func>\n      for i in range(5)\n        var inloop = i\n        flist[i] = () => inloop\n      endfor\n      for i in range(5)\n        assert_equal(4, flist[i]())\n      endfor\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var flist: list<func>\n      for i in range(5)\n        var inloop = i\n        flist[i] = () => {\n              return inloop\n            }\n      endfor\n      for i in range(5)\n        assert_equal(4, flist[i]())\n      endfor\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_for_loop_fails()\n  v9.CheckDefAndScriptFailure(['for '], ['E1097:', 'E690:'])\n  v9.CheckDefAndScriptFailure(['for x'], ['E1097:', 'E690:'])\n  v9.CheckDefAndScriptFailure(['for x in'], ['E1097:', 'E15:'])\n  v9.CheckDefAndScriptFailure(['for # in range(5)'], 'E690:')\n  v9.CheckDefAndScriptFailure(['for i In range(5)'], 'E690:')\n  v9.CheckDefAndScriptFailure(['var x = 5', 'for x in range(5)', 'endfor'], ['E1017:', 'E1041:'])\n  v9.CheckScriptFailure(['vim9script', 'var x = 5', 'for x in range(5)', '# comment', 'endfor'], 'E1041:', 3)\n  v9.CheckScriptFailure(['def Func(arg: any)', 'for arg in range(5)', 'enddef', 'defcompile'], 'E1006:')\n  delfunc! g:Func\n  v9.CheckDefFailure(['for i in xxx'], 'E1001:')\n  v9.CheckDefFailure(['endfor'], 'E588:')\n  v9.CheckDefFailure(['for i in range(3)', 'echo 3'], 'E170:')\n\n  # wrong type detected at compile time\n  v9.CheckDefFailure(['for i in {a: 1}', 'echo 3', 'endfor'], 'E1177: For loop on dict not supported')\n\n  # wrong type detected at runtime\n  g:adict = {a: 1}\n  v9.CheckDefExecFailure(['for i in g:adict', 'echo 3', 'endfor'], 'E1177: For loop on dict not supported')\n  unlet g:adict\n\n  var lines =<< trim END\n      var d: list<dict<any>> = [{a: 0}]\n      for e in d\n        e = {a: 0, b: ''}\n      endfor\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E1018:', 'E46:'], 3)\n\n  lines =<< trim END\n      for nr: number in ['foo']\n      endfor\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1012: Type mismatch; expected number but got string', 1)\n\n  lines =<< trim END\n      for n : number in [1, 2]\n        echo n\n      endfor\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1059:', 1)\n\n  lines =<< trim END\n      var d: dict<number> = {a: 1, b: 2}\n      for [k: job, v: job] in d->items()\n        echo k v\n      endfor\n  END\n  v9.CheckDefExecAndScriptFailure(lines, ['E1163: Variable 1: type mismatch, expected job but got string', 'E1012: Type mismatch; expected job but got string'], 2)\n\n  lines =<< trim END\n      var i = 0\n      for i in [1, 2, 3]\n        echo i\n      endfor\n  END\n  v9.CheckDefExecAndScriptFailure(lines, ['E1017:', 'E1041:'])\n\n  lines =<< trim END\n      var l = [0]\n      for l[0] in [1, 2, 3]\n        echo l[0]\n      endfor\n  END\n  v9.CheckDefExecAndScriptFailure(lines, ['E461:', 'E1017:'])\n\n  lines =<< trim END\n      var d = {x: 0}\n      for d.x in [1, 2, 3]\n        echo d.x\n      endfor\n  END\n  v9.CheckDefExecAndScriptFailure(lines, ['E461:', 'E1017:'])\n\n  lines =<< trim END\n      var l: list<dict<any>> = [{a: 1, b: 'x'}]\n      for item: dict<number> in l\n        echo item\n      endfor\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1012: Type mismatch; expected dict<number> but got dict<any>')\n\n  lines =<< trim END\n      var l: list<dict<any>> = [{n: 1}]\n      for item: dict<number> in l\n        item->extend({s: ''})\n      endfor\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1013: Argument 2: type mismatch, expected dict<number> but got dict<string>')\nenddef\n\ndef Test_for_loop_script_var()\n  # cannot use s:var in a :def function\n  v9.CheckDefFailure(['for s:var in range(3)', 'echo 3'], 'E1254:')\n\n  # can use s:var in Vim9 script, with or without s:\n  var lines =<< trim END\n    vim9script\n    var total = 0\n    for s:var in [1, 2, 3]\n      total += s:var\n    endfor\n    assert_equal(6, total)\n\n    total = 0\n    for var in [1, 2, 3]\n      total += var\n    endfor\n    assert_equal(6, total)\n  END\nenddef\n\ndef Test_for_loop_unpack()\n  var lines =<< trim END\n      var result = []\n      for [v1, v2] in [[1, 2], [3, 4]]\n        result->add(v1)\n        result->add(v2)\n      endfor\n      assert_equal([1, 2, 3, 4], result)\n\n      result = []\n      for [v1, v2; v3] in [[1, 2], [3, 4, 5, 6]]\n        result->add(v1)\n        result->add(v2)\n        result->add(v3)\n      endfor\n      assert_equal([1, 2, [], 3, 4, [5, 6]], result)\n\n      result = []\n      for [&ts, &sw] in [[1, 2], [3, 4]]\n        result->add(&ts)\n        result->add(&sw)\n      endfor\n      assert_equal([1, 2, 3, 4], result)\n\n      var slist: list<string>\n      for [$LOOPVAR, @r, v:errmsg] in [['a', 'b', 'c'], ['d', 'e', 'f']]\n        slist->add($LOOPVAR)\n        slist->add(@r)\n        slist->add(v:errmsg)\n      endfor\n      assert_equal(['a', 'b', 'c', 'd', 'e', 'f'], slist)\n\n      slist = []\n      for [g:globalvar, b:bufvar, w:winvar, t:tabvar] in [['global', 'buf', 'win', 'tab'], ['1', '2', '3', '4']]\n        slist->add(g:globalvar)\n        slist->add(b:bufvar)\n        slist->add(w:winvar)\n        slist->add(t:tabvar)\n      endfor\n      assert_equal(['global', 'buf', 'win', 'tab', '1', '2', '3', '4'], slist)\n      unlet! g:globalvar b:bufvar w:winvar t:tabvar\n\n      var res = []\n      for [_, n, _] in [[1, 2, 3], [4, 5, 6]]\n        res->add(n)\n      endfor\n      assert_equal([2, 5], res)\n\n      var text: list<string> = [\"hello there\", \"goodbye now\"]\n      var splitted = ''\n      for [first; next] in mapnew(text, (i, v) => split(v))\n          splitted ..= string(first) .. string(next) .. '/'\n      endfor\n      assert_equal(\"'hello'['there']/'goodbye'['now']/\", splitted)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      for [v1, v2] in [[1, 2, 3], [3, 4]]\n        echo v1 v2\n      endfor\n  END\n  v9.CheckDefExecFailure(lines, 'E710:', 1)\n\n  lines =<< trim END\n      for [v1, v2] in [[1], [3, 4]]\n        echo v1 v2\n      endfor\n  END\n  v9.CheckDefExecFailure(lines, 'E711:', 1)\n\n  lines =<< trim END\n      for [v1, v1] in [[1, 2], [3, 4]]\n        echo v1\n      endfor\n  END\n  v9.CheckDefExecFailure(lines, 'E1017:', 1)\n\n  lines =<< trim END\n      for [a, b] in g:listlist\n        echo a\n      endfor\n  END\n  g:listlist = [1, 2, 3]\n  v9.CheckDefExecFailure(lines, 'E1140:', 1)\nenddef\n\ndef Test_for_loop_with_try_continue()\n  var lines =<< trim END\n      var looped = 0\n      var cleanup = 0\n      for i in range(3)\n        looped += 1\n        try\n          eval [][0]\n        catch\n          continue\n        finally\n          cleanup += 1\n        endtry\n      endfor\n      assert_equal(3, looped)\n      assert_equal(3, cleanup)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_while_skipped_block()\n  # test skipped blocks at outside of function\n  var lines =<< trim END\n    var result = []\n    var n = 0\n    if true\n      n = 1\n      while n < 3\n        result += [n]\n        n += 1\n      endwhile\n    else\n      n = 3\n      while n < 5\n        result += [n]\n        n += 1\n      endwhile\n    endif\n    assert_equal([1, 2], result)\n\n    result = []\n    if false\n      n = 1\n      while n < 3\n        result += [n]\n        n += 1\n      endwhile\n    else\n      n = 3\n      while n < 5\n        result += [n]\n        n += 1\n      endwhile\n    endif\n    assert_equal([3, 4], result)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  # test skipped blocks at inside of function\n  lines =<< trim END\n    def DefTrue()\n      var result = []\n      var n = 0\n      if true\n        n = 1\n        while n < 3\n          result += [n]\n          n += 1\n        endwhile\n      else\n        n = 3\n        while n < 5\n          result += [n]\n          n += 1\n        endwhile\n      endif\n      assert_equal([1, 2], result)\n    enddef\n    DefTrue()\n\n    def DefFalse()\n      var result = []\n      var n = 0\n      if false\n        n = 1\n        while n < 3\n          result += [n]\n          n += 1\n        endwhile\n      else\n        n = 3\n        while n < 5\n          result += [n]\n          n += 1\n        endwhile\n      endif\n      assert_equal([3, 4], result)\n    enddef\n    DefFalse()\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_while_loop()\n  var result = ''\n  var cnt = 0\n  while cnt < 555\n    if cnt == 3\n      break\n    endif\n    cnt += 1\n    if cnt == 2\n      continue\n    endif\n    result ..= cnt .. '_'\n  endwhile\n  assert_equal('1_3_', result)\n\n  var s = ''\n  while s == 'x' # {comment}\n  endwhile\nenddef\n\ndef Test_while_loop_in_script()\n  var lines =<< trim END\n      vim9script\n      var result = ''\n      var cnt = 0\n      while cnt < 3\n        var s = 'v' .. cnt\n        result ..= s\n        cnt += 1\n      endwhile\n      assert_equal('v0v1v2', result)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_while_loop_fails()\n  v9.CheckDefFailure(['while xxx'], 'E1001:')\n  v9.CheckDefFailure(['endwhile'], 'E588:')\n  v9.CheckDefFailure(['continue'], 'E586:')\n  v9.CheckDefFailure(['if true', 'continue'], 'E586:')\n  v9.CheckDefFailure(['break'], 'E587:')\n  v9.CheckDefFailure(['if true', 'break'], 'E587:')\n  v9.CheckDefFailure(['while 1', 'echo 3'], 'E170:')\n\n  var lines =<< trim END\n      var s = ''\n      while s = ''\n      endwhile\n  END\n  v9.CheckDefFailure(lines, 'E488:')\nenddef\n\ndef Test_interrupt_loop()\n  var caught = false\n  var x = 0\n  try\n    while 1\n      x += 1\n      if x == 100\n        feedkeys(\"\\<C-C>\", 'Lt')\n      endif\n    endwhile\n  catch\n    caught = true\n    assert_equal(100, x)\n  endtry\n  assert_true(caught, 'should have caught an exception')\n  # consume the CTRL-C\n  getchar(0)\nenddef\n\ndef Test_automatic_line_continuation()\n  var mylist = [\n      'one',\n      'two',\n      'three',\n      ] # comment\n  assert_equal(['one', 'two', 'three'], mylist)\n\n  var mydict = {\n      ['one']: 1,\n      ['two']: 2,\n      ['three']:\n          3,\n      } # comment\n  assert_equal({one: 1, two: 2, three: 3}, mydict)\n  mydict = {\n      one: 1,  # comment\n      two:     # comment\n           2,  # comment\n      three: 3 # comment\n      }\n  assert_equal({one: 1, two: 2, three: 3}, mydict)\n  mydict = {\n      one: 1, \n      two: \n           2, \n      three: 3 \n      }\n  assert_equal({one: 1, two: 2, three: 3}, mydict)\n\n  assert_equal(\n        ['one', 'two', 'three'],\n        split('one two three')\n        )\nenddef\n\ndef Test_vim9_comment()\n  v9.CheckScriptSuccess([\n      'vim9script',\n      '# something',\n      '#something',\n      '#{{something',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      '#{something',\n      ], 'E1170:')\n\n  split Xfile\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'edit #something',\n      ])\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'edit #{something',\n      ])\n  close\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      ':# something',\n      ], 'E488:')\n  v9.CheckScriptFailure([\n      '# something',\n      ], 'E488:')\n  v9.CheckScriptFailure([\n      ':# something',\n      ], 'E488:')\n\n  { # block start\n  } # block end\n  v9.CheckDefFailure([\n      '{# comment',\n      ], 'E488:')\n  v9.CheckDefFailure([\n      '{',\n      '}# comment',\n      ], 'E488:')\n\n  echo \"yes\" # comment\n  v9.CheckDefFailure([\n      'echo \"yes\"# comment',\n      ], 'E488:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'echo \"yes\" # something',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'echo \"yes\"# something',\n      ], 'E121:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'echo# something',\n      ], 'E1144:')\n  v9.CheckScriptFailure([\n      'echo \"yes\" # something',\n      ], 'E121:')\n\n  exe \"echo\" # comment\n  v9.CheckDefFailure([\n      'exe \"echo\"# comment',\n      ], 'E488:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'exe \"echo\" # something',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'exe \"echo\"# something',\n      ], 'E121:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'exe# something',\n      ], 'E1144:')\n  v9.CheckScriptFailure([\n      'exe \"echo\" # something',\n      ], 'E121:')\n\n  v9.CheckDefFailure([\n      'try# comment',\n      '  echo \"yes\"',\n      'catch',\n      'endtry',\n      ], 'E1144:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'try# comment',\n      'echo \"yes\"',\n      ], 'E1144:')\n  v9.CheckDefFailure([\n      'try',\n      '  throw#comment',\n      'catch',\n      'endtry',\n      ], 'E1144:')\n  v9.CheckDefFailure([\n      'try',\n      '  throw \"yes\"#comment',\n      'catch',\n      'endtry',\n      ], 'E488:')\n  v9.CheckDefFailure([\n      'try',\n      '  echo \"yes\"',\n      'catch# comment',\n      'endtry',\n      ], 'E1144:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'try',\n      '  echo \"yes\"',\n      'catch# comment',\n      'endtry',\n      ], 'E1144:')\n  v9.CheckDefFailure([\n      'try',\n      '  echo \"yes\"',\n      'catch /pat/# comment',\n      'endtry',\n      ], 'E488:')\n  v9.CheckDefFailure([\n      'try',\n      'echo \"yes\"',\n      'catch',\n      'endtry# comment',\n      ], 'E1144:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'try',\n      '  echo \"yes\"',\n      'catch',\n      'endtry# comment',\n      ], 'E1144:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'hi # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'hi# comment',\n      ], 'E1144:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'hi Search # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'hi Search# comment',\n      ], 'E416:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'hi link This Search # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'hi link This That# comment',\n      ], 'E413:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'hi clear This # comment',\n      'hi clear # comment',\n      ])\n  # not tested, because it doesn't give an error but a warning:\n  # hi clear This# comment',\n  v9.CheckScriptFailure([\n      'vim9script',\n      'hi clear# comment',\n      ], 'E416:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'hi Group term=bold',\n      'match Group /todo/ # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'hi Group term=bold',\n      'match Group /todo/# comment',\n      ], 'E488:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'match # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'match# comment',\n      ], 'E1144:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'match none # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'match none# comment',\n      ], 'E475:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'menutrans clear # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'menutrans clear# comment text',\n      ], 'E474:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax clear # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax clear# comment text',\n      ], 'E28:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax keyword Word some',\n      'syntax clear Word # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax keyword Word some',\n      'syntax clear Word# comment text',\n      ], 'E28:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax list # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax list# comment text',\n      ], 'E28:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax match Word /pat/ oneline # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax match Word /pat/ oneline# comment',\n      ], 'E475:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax keyword Word word # comm[ent',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax keyword Word word# comm[ent',\n      ], 'E789:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax match Word /pat/ # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax match Word /pat/# comment',\n      ], 'E402:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax match Word /pat/ contains=Something # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax match Word /pat/ contains=Something# comment',\n      ], 'E475:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax match Word /pat/ contains= # comment',\n      ], 'E406:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax match Word /pat/ contains=# comment',\n      ], 'E475:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax region Word start=/pat/ end=/pat/ # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax region Word start=/pat/ end=/pat/# comment',\n      ], 'E402:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax sync # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax sync# comment',\n      ], 'E404:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax sync ccomment # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax sync ccomment# comment',\n      ], 'E404:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax cluster Some contains=Word # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax cluster Some contains=Word# comment',\n      ], 'E475:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'command Echo echo # comment',\n      'command Echo # comment',\n      'delcommand Echo',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'command Echo echo# comment',\n      'Echo',\n      ], 'E1144:')\n  delcommand Echo\n\n  var curdir = getcwd()\n  v9.CheckScriptSuccess([\n      'command Echo cd \" comment',\n      'Echo',\n      'delcommand Echo',\n      ])\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'command Echo cd # comment',\n      'Echo',\n      'delcommand Echo',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'command Echo cd \" comment',\n      'Echo',\n      ], 'E344:')\n  delcommand Echo\n  chdir(curdir)\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'command Echo# comment',\n      ], 'E182:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'command Echo echo',\n      'command Echo# comment',\n      ], 'E182:')\n  delcommand Echo\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'function # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'function \" comment',\n      ], 'E129:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'function# comment',\n      ], 'E1144:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'import \"./vim9.vim\" as v9',\n      'function v9.CheckScriptSuccess # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'import \"./vim9.vim\" as v9',\n      'function v9.CheckScriptSuccess# comment',\n      ], 'E1048: Item not found in script: CheckScriptSuccess#')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'func g:DeleteMeA()',\n      'endfunc',\n      'delfunction g:DeleteMeA # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'func g:DeleteMeB()',\n      'endfunc',\n      'delfunction g:DeleteMeB# comment',\n      ], 'E488:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'call execute(\"ls\") # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'call execute(\"ls\")# comment',\n      ], 'E488:')\n\n  v9.CheckScriptFailure([\n      'def Test() \" comment',\n      'enddef',\n      ], 'E488:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'def Test() \" comment',\n      'enddef',\n      ], 'E488:')\n\n  v9.CheckScriptSuccess([\n      'func Test() \" comment',\n      'endfunc',\n      'delfunc Test',\n      ])\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'func Test() \" comment',\n      'endfunc',\n      ])\n\n  v9.CheckScriptSuccess([\n      'def Test() # comment',\n      'enddef',\n      ])\n  v9.CheckScriptFailure([\n      'func Test() # comment',\n      'endfunc',\n      ], 'E488:')\n\n  var lines =<< trim END\n      vim9script\n      syn region Text\n      \\ start='foo'\n      #\\ comment\n      \\ end='bar'\n      syn region Text start='foo'\n      #\\ comment\n      \\ end='bar'\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      syn region Text\n      \\ start='foo'\n      \"\\ comment\n      \\ end='bar'\n  END\n  v9.CheckScriptFailure(lines, 'E399:')\nenddef\n\ndef Test_vim9_comment_gui()\n  CheckCanRunGui\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'gui#comment'\n      ], 'E1144:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'gui -f#comment'\n      ], 'E194:')\nenddef\n\ndef Test_vim9_comment_not_compiled()\n  au TabEnter *.vim g:entered = 1\n  au TabEnter *.x g:entered = 2\n\n  edit test.vim\n  doautocmd TabEnter #comment\n  assert_equal(1, g:entered)\n\n  doautocmd TabEnter f.x\n  assert_equal(2, g:entered)\n\n  g:entered = 0\n  doautocmd TabEnter f.x #comment\n  assert_equal(2, g:entered)\n\n  assert_fails('doautocmd Syntax#comment', 'E216:')\n\n  au! TabEnter\n  unlet g:entered\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'g:var = 123',\n      'b:var = 456',\n      'w:var = 777',\n      't:var = 888',\n      'unlet g:var w:var # something',\n      ])\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'let var = 123',\n      ], 'E1126: Cannot use :let in Vim9 script')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'var g:var = 123',\n      ], 'E1016: Cannot declare a global variable:')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'var b:var = 123',\n      ], 'E1016: Cannot declare a buffer variable:')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'var w:var = 123',\n      ], 'E1016: Cannot declare a window variable:')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'var t:var = 123',\n      ], 'E1016: Cannot declare a tab variable:')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'var v:version = 123',\n      ], 'E1016: Cannot declare a v: variable:')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'var $VARIABLE = \"text\"',\n      ], 'E1016: Cannot declare an environment variable:')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'g:var = 123',\n      'unlet g:var# comment1',\n      ], 'E108:')\n\n  v9.CheckScriptFailure([\n      'let g:var = 123',\n      'unlet g:var # something',\n      ], 'E488:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'if 1 # comment2',\n      '  echo \"yes\"',\n      'elseif 2 #comment',\n      '  echo \"no\"',\n      'endif',\n      ])\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'if 1# comment3',\n      '  echo \"yes\"',\n      'endif',\n      ], 'E488:')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'if 0 # comment4',\n      '  echo \"yes\"',\n      'elseif 2#comment',\n      '  echo \"no\"',\n      'endif',\n      ], 'E488:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'var v = 1 # comment5',\n      ])\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'var v = 1# comment6',\n      ], 'E488:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'new'\n      'setline(1, [\"# define pat\", \"last\"])',\n      ':$',\n      'dsearch /pat/ #comment',\n      'bwipe!',\n      ])\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'new'\n      'setline(1, [\"# define pat\", \"last\"])',\n      ':$',\n      'dsearch /pat/#comment',\n      'bwipe!',\n      ], 'E488:')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'func! SomeFunc()',\n      ], 'E477:')\nenddef\n\ndef Test_finish()\n  var lines =<< trim END\n    vim9script\n    g:res = 'one'\n    if v:false | finish | endif\n    g:res = 'two'\n    finish\n    g:res = 'three'\n  END\n  writefile(lines, 'Xfinished')\n  source Xfinished\n  assert_equal('two', g:res)\n\n  unlet g:res\n  delete('Xfinished')\nenddef\n\ndef Test_forward_declaration()\n  var lines =<< trim END\n    vim9script\n    def GetValue(): string\n      return theVal\n    enddef\n    var theVal = 'something'\n    g:initVal = GetValue()\n    theVal = 'else'\n    g:laterVal = GetValue()\n  END\n  writefile(lines, 'Xforward')\n  source Xforward\n  assert_equal('something', g:initVal)\n  assert_equal('else', g:laterVal)\n\n  unlet g:initVal\n  unlet g:laterVal\n  delete('Xforward')\nenddef\n\ndef Test_declare_script_var_in_func()\n  var lines =<< trim END\n      vim9script\n      func Declare()\n        let s:local = 123\n      endfunc\n      Declare()\n  END\n  v9.CheckScriptFailure(lines, 'E1269:')\nenddef\n        \ndef Test_lock_script_var()\n  var lines =<< trim END\n      vim9script\n      var local = 123\n      assert_equal(123, local)\n\n      var error: string\n      try\n        local = 'asdf'\n      catch\n        error = v:exception\n      endtry\n      assert_match('E1012: Type mismatch; expected number but got string', error)\n\n      lockvar local\n      try\n        local = 999\n      catch\n        error = v:exception\n      endtry\n      assert_match('E741: Value is locked: local', error)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n        \n\nfunc Test_vim9script_not_global()\n  \" check that items defined in Vim9 script are script-local, not global\n  let vim9lines =<< trim END\n    vim9script\n    var name = 'local'\n    func TheFunc()\n      echo 'local'\n    endfunc\n    def DefFunc()\n      echo 'local'\n    enddef\n  END\n  call writefile(vim9lines, 'Xvim9script.vim')\n  source Xvim9script.vim\n  try\n    echo g:var\n    assert_report('did not fail')\n  catch /E121:/\n    \" caught\n  endtry\n  try\n    call TheFunc()\n    assert_report('did not fail')\n  catch /E117:/\n    \" caught\n  endtry\n  try\n    call DefFunc()\n    assert_report('did not fail')\n  catch /E117:/\n    \" caught\n  endtry\n\n  call delete('Xvim9script.vim')\nendfunc\n\ndef Test_vim9_copen()\n  # this was giving an error for setting w:quickfix_title\n  copen\n  quit\nenddef\n\ndef Test_script_var_in_autocmd()\n  # using a script variable from an autocommand, defined in a :def function in a\n  # legacy Vim script, cannot check the variable type.\n  var lines =<< trim END\n    let s:counter = 1\n    def s:Func()\n      au! CursorHold\n      au CursorHold * s:counter += 1\n    enddef\n    call s:Func()\n    doau CursorHold\n    call assert_equal(2, s:counter)\n    au! CursorHold\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_error_in_autoload_script()\n  var save_rtp = &rtp\n  var dir = getcwd() .. '/Xruntime'\n  &rtp = dir\n  mkdir(dir .. '/autoload', 'p')\n\n  var lines =<< trim END\n      vim9script noclear\n      export def Autoloaded()\n      enddef\n      def Broken()\n        var x: any = ''\n        eval x != 0\n      enddef\n      Broken()\n  END\n  writefile(lines, dir .. '/autoload/script.vim')\n\n  lines =<< trim END\n      vim9script\n      def CallAutoloaded()\n        script#Autoloaded()\n      enddef\n\n      function Legacy()\n        try\n          call s:CallAutoloaded()\n        catch\n          call assert_match('E1030: Using a String as a Number', v:exception)\n        endtry\n      endfunction\n\n      Legacy()\n  END\n  v9.CheckScriptSuccess(lines)\n\n  &rtp = save_rtp\n  delete(dir, 'rf')\nenddef\n\ndef Test_error_in_autoload_script_foldexpr()\n  var save_rtp = &rtp\n  mkdir('Xvim/autoload', 'p')\n  &runtimepath = 'Xvim'\n\n  var lines =<< trim END\n      vim9script\n      eval [][0]\n      echomsg 'no error'\n  END\n  lines->writefile('Xvim/autoload/script.vim')\n\n  lines =<< trim END\n      vim9script\n      import autoload 'script.vim'\n      &foldmethod = 'expr'\n      &foldexpr = 'script.Func()'\n      redraw\n  END\n  v9.CheckScriptFailure(lines, 'E684: List index out of range: 0')\n\n  delete('Xvim', 'rf')\nenddef\n\ndef Test_invalid_sid()\n  assert_fails('func <SNR>1234_func', 'E123:')\n\n  if g:RunVim([], ['wq! Xdidit'], '+\"func <SNR>1_func\"')\n    assert_equal([], readfile('Xdidit'))\n  endif\n  delete('Xdidit')\nenddef\n\ndef Test_restoring_cpo()\n  writefile(['vim9script', 'set nocp'], 'Xsourced')\n  writefile(['call writefile([\"done\"], \"Xdone\")', 'quit!'], 'Xclose')\n  if g:RunVim([], [], '-u NONE +\"set cpo+=a\" -S Xsourced -S Xclose')\n    assert_equal(['done'], readfile('Xdone'))\n  endif\n  delete('Xsourced')\n  delete('Xclose')\n  delete('Xdone')\n\n  writefile(['vim9script', 'g:cpoval = &cpo'], 'XanotherScript')\n  set cpo=aABceFsMny>\n  edit XanotherScript\n  so %\n  assert_equal('aABceFsMny>', &cpo)\n  assert_equal('aABceFs', g:cpoval)\n  :1del\n  setline(1, 'let g:cpoval = &cpo')\n  w\n  so %\n  assert_equal('aABceFsMny>', &cpo)\n  assert_equal('aABceFsMny>', g:cpoval)\n\n  delete('XanotherScript')\n  set cpo&vim\n  unlet g:cpoval\n\n  if has('unix')\n    # 'cpo' is not restored in main vimrc\n    var save_HOME = $HOME\n    $HOME = getcwd() .. '/Xhome'\n    mkdir('Xhome')\n    var lines =<< trim END\n        vim9script\n        writefile(['before: ' .. &cpo], 'Xresult')\n        set cpo+=M\n        writefile(['after: ' .. &cpo], 'Xresult', 'a')\n    END\n    writefile(lines, 'Xhome/.vimrc')\n\n    lines =<< trim END\n        call writefile(['later: ' .. &cpo], 'Xresult', 'a')\n    END\n    writefile(lines, 'Xlegacy')\n\n    lines =<< trim END\n        vim9script\n        call writefile(['vim9: ' .. &cpo], 'Xresult', 'a')\n        qa\n    END\n    writefile(lines, 'Xvim9')\n\n    var cmd = g:GetVimCommand() .. \" -S Xlegacy -S Xvim9\"\n    cmd = substitute(cmd, '-u NONE', '', '')\n    exe \"silent !\" .. cmd\n\n    assert_equal([\n        'before: aABceFs',\n        'after: aABceFsM',\n        'later: aABceFsM',\n        'vim9: aABceFs'], readfile('Xresult'))\n\n    $HOME = save_HOME\n    delete('Xhome', 'rf')\n    delete('Xlegacy')\n    delete('Xvim9')\n    delete('Xresult')\n  endif\nenddef\n\n\" Use :function so we can use Check commands\nfunc Test_no_redraw_when_restoring_cpo()\n  CheckScreendump\n  CheckFeature timers\n  call Run_test_no_redraw_when_restoring_cpo()\nendfunc\n\ndef Run_test_no_redraw_when_restoring_cpo()\n  var lines =<< trim END\n    vim9script\n    export def Func()\n    enddef\n  END\n  mkdir('Xdir/autoload', 'p')\n  writefile(lines, 'Xdir/autoload/script.vim')\n\n  lines =<< trim END\n      vim9script\n      set cpo+=M\n      exe 'set rtp^=' .. getcwd() .. '/Xdir'\n      au CmdlineEnter : ++once timer_start(0, (_) => script#Func())\n      setline(1, 'some text')\n  END\n  writefile(lines, 'XTest_redraw_cpo')\n  var buf = g:RunVimInTerminal('-S XTest_redraw_cpo', {'rows': 6})\n  term_sendkeys(buf, \"V:\")\n  g:VerifyScreenDump(buf, 'Test_vim9_no_redraw', {})\n\n  # clean up\n  term_sendkeys(buf, \"\\<Esc>u\")\n  g:StopVimInTerminal(buf)\n  delete('XTest_redraw_cpo')\n  delete('Xdir', 'rf')\nenddef\n\nfunc Test_reject_declaration()\n  CheckScreendump\n  call Run_test_reject_declaration()\nendfunc\n\ndef Run_test_reject_declaration()\n  var buf = g:RunVimInTerminal('', {'rows': 6})\n  term_sendkeys(buf, \":vim9cmd var x: number\\<CR>\")\n  g:VerifyScreenDump(buf, 'Test_vim9_reject_declaration_1', {})\n  term_sendkeys(buf, \":\\<CR>\")\n  term_sendkeys(buf, \":vim9cmd g:foo = 123 | echo g:foo\\<CR>\")\n  g:VerifyScreenDump(buf, 'Test_vim9_reject_declaration_2', {})\n\n  # clean up\n  g:StopVimInTerminal(buf)\nenddef\n\ndef Test_minimal_command_name_length()\n  var names = [\n       'cons',\n       'brea',\n       'cat',\n       'catc',\n       'con',\n       'cont',\n       'conti',\n       'contin',\n       'continu',\n       'el',\n       'els',\n       'elsei',\n       'endfo',\n       'en',\n       'end',\n       'endi',\n       'endw',\n       'endt',\n       'endtr',\n       'exp',\n       'expo',\n       'expor',\n       'fina',\n       'finall',\n       'fini',\n       'finis',\n       'imp',\n       'impo',\n       'impor',\n       'retu',\n       'retur',\n       'th',\n       'thr',\n       'thro',\n       'wh',\n       'whi',\n       'whil',\n      ]\n  for name in names\n    v9.CheckDefAndScriptFailure([name .. ' '], 'E1065:')\n  endfor\n\n  var lines =<< trim END\n      vim9script\n      def SomeFunc()\n      endd\n  END\n  v9.CheckScriptFailure(lines, 'E1065:')\n  lines =<< trim END\n      vim9script\n      def SomeFunc()\n      endde\n  END\n  v9.CheckScriptFailure(lines, 'E1065:')\nenddef\n\ndef Test_unset_any_variable()\n  var lines =<< trim END\n    var name: any\n    assert_equal(0, name)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\nfunc Test_define_func_at_command_line()\n  CheckRunVimInTerminal\n\n  \" call indirectly to avoid compilation error for missing functions\n  call Run_Test_define_func_at_command_line()\nendfunc\n\ndef Run_Test_define_func_at_command_line()\n  # run in a separate Vim instance to avoid the script context\n  var lines =<< trim END\n    func CheckAndQuit()\n      call assert_fails('call Afunc()', 'E117: Unknown function: Bfunc')\n      call writefile(['errors: ' .. string(v:errors)], 'Xdidcmd')\n    endfunc\n  END\n  writefile([''], 'Xdidcmd')\n  writefile(lines, 'XcallFunc')\n  var buf = g:RunVimInTerminal('-S XcallFunc', {rows: 6})\n  # define Afunc() on the command line\n  term_sendkeys(buf, \":def Afunc()\\<CR>Bfunc()\\<CR>enddef\\<CR>\")\n  term_sendkeys(buf, \":call CheckAndQuit()\\<CR>\")\n  g:WaitForAssert(() => assert_equal(['errors: []'], readfile('Xdidcmd')))\n\n  call g:StopVimInTerminal(buf)\n  delete('XcallFunc')\n  delete('Xdidcmd')\nenddef\n\ndef Test_script_var_scope()\n  var lines =<< trim END\n      vim9script\n      if true\n        if true\n          var one = 'one'\n          echo one\n        endif\n        echo one\n      endif\n  END\n  v9.CheckScriptFailure(lines, 'E121:', 7)\n\n  lines =<< trim END\n      vim9script\n      if true\n        if false\n          var one = 'one'\n          echo one\n        else\n          var one = 'one'\n          echo one\n        endif\n        echo one\n      endif\n  END\n  v9.CheckScriptFailure(lines, 'E121:', 10)\n\n  lines =<< trim END\n      vim9script\n      while true\n        var one = 'one'\n        echo one\n        break\n      endwhile\n      echo one\n  END\n  v9.CheckScriptFailure(lines, 'E121:', 7)\n\n  lines =<< trim END\n      vim9script\n      for i in range(1)\n        var one = 'one'\n        echo one\n      endfor\n      echo one\n  END\n  v9.CheckScriptFailure(lines, 'E121:', 6)\n\n  lines =<< trim END\n      vim9script\n      {\n        var one = 'one'\n        assert_equal('one', one)\n      }\n      assert_false(exists('one'))\n      assert_false(exists('s:one'))\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      {\n        var one = 'one'\n        echo one\n      }\n      echo one\n  END\n  v9.CheckScriptFailure(lines, 'E121:', 6)\nenddef\n\ndef Test_catch_exception_in_callback()\n  var lines =<< trim END\n    vim9script\n    def Callback(...l: list<any>)\n      try\n        var x: string\n        var y: string\n        # this error should be caught with CHECKLEN\n        var sl = ['']\n        [x, y] = sl\n      catch\n        g:caught = 'yes'\n      endtry\n    enddef\n    popup_menu('popup', {callback: Callback})\n    feedkeys(\"\\r\", 'xt')\n  END\n  v9.CheckScriptSuccess(lines)\n\n  unlet g:caught\nenddef\n\ndef Test_no_unknown_error_after_error()\n  if !has('unix') || !has('job')\n    throw 'Skipped: not unix of missing +job feature'\n  endif\n  # FIXME: this check should not be needed\n  if has('win32')\n    throw 'Skipped: does not work on MS-Windows'\n  endif\n  var lines =<< trim END\n      vim9script\n      var source: list<number>\n      def Out_cb(...l: list<any>)\n          eval [][0]\n      enddef\n      def Exit_cb(...l: list<any>)\n          sleep 1m\n          g:did_call_exit_cb = true\n          source += l\n      enddef\n      var myjob = job_start('echo burp', {out_cb: Out_cb, exit_cb: Exit_cb, mode: 'raw'})\n      while job_status(myjob) == 'run'\n        sleep 10m\n      endwhile\n      # wait for Exit_cb() to be called\n      for x in range(100)\n        if exists('g:did_call_exit_cb')\n          unlet g:did_call_exit_cb\n          break\n        endif\n        sleep 10m\n      endfor\n  END\n  writefile(lines, 'Xdef')\n  assert_fails('so Xdef', ['E684:', 'E1012:'])\n  delete('Xdef')\nenddef\n\ndef InvokeNormal()\n  exe \"norm! :m+1\\r\"\nenddef\n\ndef Test_invoke_normal_in_visual_mode()\n  xnoremap <F3> <Cmd>call <SID>InvokeNormal()<CR>\n  new\n  setline(1, ['aaa', 'bbb'])\n  feedkeys(\"V\\<F3>\", 'xt')\n  assert_equal(['bbb', 'aaa'], getline(1, 2))\n  xunmap <F3>\nenddef\n\ndef Test_white_space_after_command()\n  var lines =<< trim END\n    exit_cb: Func})\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1144:', 1)\n\n  lines =<< trim END\n    e#\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1144:', 1)\nenddef\n\ndef Test_script_var_gone_when_sourced_twice()\n  var lines =<< trim END\n      vim9script\n      if exists('g:guard')\n        finish\n      endif\n      g:guard = 1\n      var name = 'thename'\n      def g:GetName(): string\n        return name\n      enddef\n      def g:SetName(arg: string)\n        name = arg\n      enddef\n  END\n  writefile(lines, 'XscriptTwice.vim')\n  so XscriptTwice.vim\n  assert_equal('thename', g:GetName())\n  g:SetName('newname')\n  assert_equal('newname', g:GetName())\n  so XscriptTwice.vim\n  assert_fails('call g:GetName()', 'E1149:')\n  assert_fails('call g:SetName(\"x\")', 'E1149:')\n\n  delfunc g:GetName\n  delfunc g:SetName\n  delete('XscriptTwice.vim')\n  unlet g:guard\nenddef\n\ndef Test_unsupported_commands()\n  var lines =<< trim END\n      ka\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E476:', 'E492:'])\n\n  lines =<< trim END\n      :1ka\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E476:', 'E492:'])\n\n  lines =<< trim END\n      :k a\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1100:')\n\n  lines =<< trim END\n      :1k a\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E481:')\n\n  lines =<< trim END\n    t\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1100:')\n\n  lines =<< trim END\n    x\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1100:')\n\n  lines =<< trim END\n    xit\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1100:')\n\n  lines =<< trim END\n    Print\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E476: Invalid command: Print', 'E492: Not an editor command: Print'])\n\n  lines =<< trim END\n    mode 4\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E476: Invalid command: mode 4', 'E492: Not an editor command: mode 4'])\nenddef\n\ndef Test_mapping_line_number()\n  var lines =<< trim END\n      vim9script\n      def g:FuncA()\n          # Some comment\n          FuncB(0)\n      enddef\n          # Some comment\n      def FuncB(\n          # Some comment\n          n: number\n      )\n          exe 'nno '\n              # Some comment\n              .. '<F3> a'\n              .. 'b'\n              .. 'c'\n      enddef\n  END\n  v9.CheckScriptSuccess(lines)\n  var res = execute('verbose nmap <F3>')\n  assert_match('No mapping found', res)\n\n  g:FuncA()\n  res = execute('verbose nmap <F3>')\n  assert_match(' <F3> .* abc.*Last set from .*XScriptSuccess\\d\\+ line 11', res)\n\n  nunmap <F3>\n  delfunc g:FuncA\nenddef\n\ndef Test_option_set()\n  # legacy script allows for white space\n  var lines =<< trim END\n      set foldlevel  =11\n      call assert_equal(11, &foldlevel)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  set foldlevel\n  set foldlevel=12\n  assert_equal(12, &foldlevel)\n  set foldlevel+=2\n  assert_equal(14, &foldlevel)\n  set foldlevel-=3\n  assert_equal(11, &foldlevel)\n\n  lines =<< trim END\n      set foldlevel =1\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1205: No white space allowed between option and: =1')\n\n  lines =<< trim END\n      set foldlevel +=1\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1205: No white space allowed between option and: +=1')\n\n  lines =<< trim END\n      set foldlevel ^=1\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1205: No white space allowed between option and: ^=1')\n\n  lines =<< trim END\n      set foldlevel -=1\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1205: No white space allowed between option and: -=1')\n\n  set foldlevel&\nenddef\n\ndef Test_option_modifier()\n  # legacy script allows for white space\n  var lines =<< trim END\n      set hlsearch &  hlsearch  !\n      call assert_equal(1, &hlsearch)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  set hlsearch\n  set hlsearch!\n  assert_equal(false, &hlsearch)\n\n  set hlsearch\n  set hlsearch&\n  assert_equal(false, &hlsearch)\n\n  lines =<< trim END\n      set hlsearch &\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1205: No white space allowed between option and: &')\n\n  lines =<< trim END\n      set hlsearch   !\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1205: No white space allowed between option and: !')\n\n  set hlsearch&\nenddef\n\n\" This must be called last, it may cause following :def functions to fail\ndef Test_xxx_echoerr_line_number()\n  var lines =<< trim END\n      echoerr 'some'\n         .. ' error'\n         .. ' continued'\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'some error continued', 1)\nenddef\n\nfunc Test_debug_with_lambda()\n  CheckRunVimInTerminal\n\n  \" call indirectly to avoid compilation error for missing functions\n  call Run_Test_debug_with_lambda()\nendfunc\n\ndef Run_Test_debug_with_lambda()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        var n = 0\n        echo [0]->filter((_, v) => v == n)\n      enddef\n      breakadd func Func\n      Func()\n  END\n  writefile(lines, 'XdebugFunc')\n  var buf = g:RunVimInTerminal('-S XdebugFunc', {rows: 6, wait_for_ruler: 0})\n  g:WaitForAssert(() => assert_match('^>', term_getline(buf, 6)))\n\n  term_sendkeys(buf, \"cont\\<CR>\")\n  g:WaitForAssert(() => assert_match('\\[0\\]', term_getline(buf, 5)))\n\n  g:StopVimInTerminal(buf)\n  delete('XdebugFunc')\nenddef\n\nfunc Test_debug_running_out_of_lines()\n  CheckRunVimInTerminal\n\n  \" call indirectly to avoid compilation error for missing functions\n  call Run_Test_debug_running_out_of_lines()\nendfunc\n\ndef Run_Test_debug_running_out_of_lines()\n  var lines =<< trim END\n      vim9script\n      def Crash()\n          #\n          #\n          #\n          #\n          #\n          #\n          #\n          if true\n              #\n          endif\n      enddef\n      breakadd func Crash\n      Crash()\n  END\n  writefile(lines, 'XdebugFunc')\n  var buf = g:RunVimInTerminal('-S XdebugFunc', {rows: 6, wait_for_ruler: 0})\n  g:WaitForAssert(() => assert_match('^>', term_getline(buf, 6)))\n\n  term_sendkeys(buf, \"next\\<CR>\")\n  g:TermWait(buf)\n  g:WaitForAssert(() => assert_match('^>', term_getline(buf, 6)))\n\n  term_sendkeys(buf, \"cont\\<CR>\")\n  g:TermWait(buf)\n\n  g:StopVimInTerminal(buf)\n  delete('XdebugFunc')\nenddef\n\ndef Test_ambigous_command_error()\n  var lines =<< trim END\n      vim9script\n      command CmdA echomsg 'CmdA'\n      command CmdB echomsg 'CmdB'\n      Cmd\n  END\n  v9.CheckScriptFailure(lines, 'E464: Ambiguous use of user-defined command: Cmd', 4)\n\n  lines =<< trim END\n      vim9script\n      def Func()\n        Cmd\n      enddef\n      Func()\n  END\n  v9.CheckScriptFailure(lines, 'E464: Ambiguous use of user-defined command: Cmd', 1)\n\n  lines =<< trim END\n      vim9script\n      nnoremap <F3> <ScriptCmd>Cmd<CR>\n      feedkeys(\"\\<F3>\", 'xt')\n  END\n  v9.CheckScriptFailure(lines, 'E464: Ambiguous use of user-defined command: Cmd', 3)\n\n  delcommand CmdA\n  delcommand CmdB\n  nunmap <F3>\nenddef\n\n\" Execute this near the end, profiling doesn't stop until Vim exits.\n\" This only tests that it works, not the profiling output.\ndef Test_profile_with_lambda()\n  CheckFeature profile\n\n  var lines =<< trim END\n      vim9script\n\n      def ProfiledWithLambda()\n        var n = 3\n        echo [[1, 2], [3, 4]]->filter((_, l) => l[0] == n)\n      enddef\n\n      def ProfiledNested()\n        var x = 0\n        def Nested(): any\n            return x\n        enddef\n        Nested()\n      enddef\n\n      def g:ProfiledNestedProfiled()\n        var x = 0\n        def Nested(): any\n            return x\n        enddef\n        Nested()\n      enddef\n\n      def Profile()\n        ProfiledWithLambda()\n        ProfiledNested()\n\n        # Also profile the nested function.  Use a different function, although\n        # the contents is the same, to make sure it was not already compiled.\n        profile func *\n        g:ProfiledNestedProfiled()\n\n        profdel func *\n        profile pause\n      enddef\n\n      var result = 'done'\n      try\n        # mark functions for profiling now to avoid E1271\n        profile start Xprofile.log\n        profile func ProfiledWithLambda\n        profile func ProfiledNested\n\n        Profile()\n      catch\n        result = 'failed: ' .. v:exception\n      finally\n        writefile([result], 'Xdidprofile')\n      endtry\n  END\n  writefile(lines, 'Xprofile.vim')\n  call system(g:GetVimCommand()\n        .. ' --clean'\n        .. ' -c \"so Xprofile.vim\"'\n        .. ' -c \"qall!\"')\n  call assert_equal(0, v:shell_error)\n\n  assert_equal(['done'], readfile('Xdidprofile'))\n  assert_true(filereadable('Xprofile.log'))\n  delete('Xdidprofile')\n  delete('Xprofile.log')\n  delete('Xprofile.vim')\nenddef\n\nfunc Test_misplaced_type()\n  CheckRunVimInTerminal\n  call Run_Test_misplaced_type()\nendfunc\n\ndef Run_Test_misplaced_type()\n  writefile(['let g:somevar = \"asdf\"'], 'XTest_misplaced_type')\n  var buf = g:RunVimInTerminal('-S XTest_misplaced_type', {'rows': 6})\n  term_sendkeys(buf, \":vim9cmd echo islocked('g:somevar: string')\\<CR>\")\n  g:VerifyScreenDump(buf, 'Test_misplaced_type', {})\n\n  g:StopVimInTerminal(buf)\n  delete('XTest_misplaced_type')\nenddef\n\n\" Ensure echo doesn't crash when stringifying empty variables.\ndef Test_echo_uninit_variables()\n  var res: string\n\n  var var_bool: bool\n  var var_num: number\n  var var_float: float\n  var Var_func: func\n  var var_string: string\n  var var_blob: blob\n  var var_list: list<any>\n  var var_dict: dict<any>\n\n  redir => res\n  echo var_bool\n  echo var_num\n  echo var_float\n  echo Var_func\n  echo var_string\n  echo var_blob\n  echo var_list\n  echo var_dict\n  redir END\n\n  assert_equal(['false', '0', '0.0', 'function()', '', '0z', '[]', '{}'], res->split('\\n'))\n\n  if has('job')\n    var var_job: job\n    var var_channel: channel\n\n    redir => res\n    echo var_job\n    echo var_channel\n    redir END\n\n    assert_equal(['no process', 'channel fail'], res->split('\\n'))\n  endif\nenddef\n\n\" Keep this last, it messes up highlighting.\ndef Test_substitute_cmd()\n  new\n  setline(1, 'something')\n  :substitute(some(other(\n  assert_equal('otherthing', getline(1))\n  bwipe!\n\n  # also when the context is Vim9 script\n  var lines =<< trim END\n    vim9script\n    new\n    setline(1, 'something')\n    :substitute(some(other(\n    assert_equal('otherthing', getline(1))\n    bwipe!\n  END\n  writefile(lines, 'Xvim9lines')\n  source Xvim9lines\n\n  delete('Xvim9lines')\nenddef\n\n\" vim: ts=8 sw=2 sts=2 expandtab tw=80 fdm=marker\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * vim9compile.c: compiling a :def function\n */\n\n#define USING_FLOAT_STUFF\n#include \"vim.h\"\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\n// When not generating protos this is included in proto.h\n#ifdef PROTO\n# include \"vim9.h\"\n#endif\n\n// Functions defined with :def are stored in this growarray.\n// They are never removed, so that they can be found by index.\n// Deleted functions have the df_deleted flag set.\ngarray_T def_functions = {0, 0, sizeof(dfunc_T), 50, NULL};\n\nstatic void delete_def_function_contents(dfunc_T *dfunc, int mark_deleted);\n\n/*\n * Lookup variable \"name\" in the local scope and return it in \"lvar\".\n * \"lvar->lv_from_outer\" is incremented accordingly.\n * If \"lvar\" is NULL only check if the variable can be found.\n * Return FAIL if not found.\n */\n    int\nlookup_local(char_u *name, size_t len, lvar_T *lvar, cctx_T *cctx)\n{\n    int\t    idx;\n    lvar_T  *lvp;\n\n    if (len == 0)\n\treturn FAIL;\n\n    // Find local in current function scope.\n    for (idx = 0; idx < cctx->ctx_locals.ga_len; ++idx)\n    {\n\tlvp = ((lvar_T *)cctx->ctx_locals.ga_data) + idx;\n\tif (STRNCMP(name, lvp->lv_name, len) == 0\n\t\t\t\t\t       && STRLEN(lvp->lv_name) == len)\n\t{\n\t    if (lvar != NULL)\n\t    {\n\t\t*lvar = *lvp;\n\t\tlvar->lv_from_outer = 0;\n\t    }\n\t    return OK;\n\t}\n    }\n\n    // Find local in outer function scope.\n    if (cctx->ctx_outer != NULL)\n    {\n\tif (lookup_local(name, len, lvar, cctx->ctx_outer) == OK)\n\t{\n\t    if (lvar != NULL)\n\t    {\n\t\tcctx->ctx_outer_used = TRUE;\n\t\t++lvar->lv_from_outer;\n\t    }\n\t    return OK;\n\t}\n    }\n\n    return FAIL;\n}\n\n/*\n * Lookup an argument in the current function and an enclosing function.\n * Returns the argument index in \"idxp\"\n * Returns the argument type in \"type\"\n * Sets \"gen_load_outer\" to TRUE if found in outer scope.\n * Returns OK when found, FAIL otherwise.\n */\n    int\narg_exists(\n\tchar_u\t*name,\n\tsize_t\tlen,\n\tint\t*idxp,\n\ttype_T\t**type,\n\tint\t*gen_load_outer,\n\tcctx_T\t*cctx)\n{\n    int\t    idx;\n    char_u  *va_name;\n\n    if (len == 0)\n\treturn FAIL;\n    for (idx = 0; idx < cctx->ctx_ufunc->uf_args_visible; ++idx)\n    {\n\tchar_u *arg = FUNCARG(cctx->ctx_ufunc, idx);\n\n\tif (STRNCMP(name, arg, len) == 0 && arg[len] == NUL)\n\t{\n\t    if (idxp != NULL)\n\t    {\n\t\t// Arguments are located above the frame pointer.  One further\n\t\t// if there is a vararg argument\n\t\t*idxp = idx - (cctx->ctx_ufunc->uf_args.ga_len\n\t\t\t\t\t\t\t    + STACK_FRAME_SIZE)\n\t\t\t      + (cctx->ctx_ufunc->uf_va_name != NULL ? -1 : 0);\n\n\t\tif (cctx->ctx_ufunc->uf_arg_types != NULL)\n\t\t    *type = cctx->ctx_ufunc->uf_arg_types[idx];\n\t\telse\n\t\t    *type = &t_any;\n\t    }\n\t    return OK;\n\t}\n    }\n\n    va_name = cctx->ctx_ufunc->uf_va_name;\n    if (va_name != NULL\n\t\t    && STRNCMP(name, va_name, len) == 0 && va_name[len] == NUL)\n    {\n\tif (idxp != NULL)\n\t{\n\t    // varargs is always the last argument\n\t    *idxp = -STACK_FRAME_SIZE - 1;\n\t    *type = cctx->ctx_ufunc->uf_va_type;\n\t}\n\treturn OK;\n    }\n\n    if (cctx->ctx_outer != NULL)\n    {\n\t// Lookup the name for an argument of the outer function.\n\tif (arg_exists(name, len, idxp, type, gen_load_outer, cctx->ctx_outer)\n\t\t\t\t\t\t\t\t\t == OK)\n\t{\n\t    if (gen_load_outer != NULL)\n\t\t++*gen_load_outer;\n\t    return OK;\n\t}\n    }\n\n    return FAIL;\n}\n\n/*\n * Lookup a script-local variable in the current script, possibly defined in a\n * block that contains the function \"cctx->ctx_ufunc\".\n * \"cctx\" is NULL at the script level, \"cstack\" is NULL in a function.\n * If \"len\" is <= 0 \"name\" must be NUL terminated.\n * Return NULL when not found.\n */\n    static sallvar_T *\nfind_script_var(char_u *name, size_t len, cctx_T *cctx, cstack_T *cstack)\n{\n    scriptitem_T    *si = SCRIPT_ITEM(current_sctx.sc_sid);\n    hashitem_T\t    *hi;\n    int\t\t    cc;\n    sallvar_T\t    *sav;\n    ufunc_T\t    *ufunc;\n\n    // Find the list of all script variables with the right name.\n    if (len > 0)\n    {\n\tcc = name[len];\n\tname[len] = NUL;\n    }\n    hi = hash_find(&si->sn_all_vars.dv_hashtab, name);\n    if (len > 0)\n\tname[len] = cc;\n    if (HASHITEM_EMPTY(hi))\n\treturn NULL;\n\n    sav = HI2SAV(hi);\n    if (sav->sav_block_id == 0)\n\t// variable defined in the top script scope is always visible\n\treturn sav;\n\n    if (cctx == NULL)\n    {\n\t// Not in a function scope, find variable with block ID equal to or\n\t// smaller than the current block id.  Use \"cstack\" to go up the block\n\t// scopes.\n\twhile (sav != NULL)\n\t{\n\t    int idx;\n\n\t    for (idx = cstack->cs_idx; idx >= 0; --idx)\n\t\tif (cstack->cs_block_id[idx] == sav->sav_block_id)\n\t\t    break;\n\t    if (idx >= 0)\n\t\tbreak;\n\t    sav = sav->sav_next;\n\t}\n\treturn sav;\n    }\n\n    // Go over the variables with this name and find one that was visible\n    // from the function.\n    ufunc = cctx->ctx_ufunc;\n    while (sav != NULL)\n    {\n\tint idx;\n\n\t// Go over the blocks that this function was defined in.  If the\n\t// variable block ID matches it was visible to the function.\n\tfor (idx = 0; idx < ufunc->uf_block_depth; ++idx)\n\t    if (ufunc->uf_block_ids[idx] == sav->sav_block_id)\n\t\treturn sav;\n\tsav = sav->sav_next;\n    }\n\n    // Not found, variable was not visible.\n    return NULL;\n}\n\n/*\n * Return TRUE if the script context is Vim9 script.\n */\n    int\nscript_is_vim9()\n{\n    return SCRIPT_ITEM(current_sctx.sc_sid)->sn_version == SCRIPT_VERSION_VIM9;\n}\n\n/*\n * Lookup a variable (without s: prefix) in the current script.\n * \"cctx\" is NULL at the script level, \"cstack\" is NULL in a function.\n * Returns OK or FAIL.\n */\n    int\nscript_var_exists(char_u *name, size_t len, cctx_T *cctx, cstack_T *cstack)\n{\n    if (current_sctx.sc_sid <= 0)\n\treturn FAIL;\n    if (script_is_vim9())\n    {\n\t// Check script variables that were visible where the function was\n\t// defined.\n\tif (find_script_var(name, len, cctx, cstack) != NULL)\n\t    return OK;\n    }\n    else\n    {\n\thashtab_T\t*ht = &SCRIPT_VARS(current_sctx.sc_sid);\n\tdictitem_T\t*di;\n\tint\t\tcc;\n\n\t// Check script variables that are currently visible\n\tcc = name[len];\n\tname[len] = NUL;\n\tdi = find_var_in_ht(ht, 0, name, TRUE);\n\tname[len] = cc;\n\tif (di != NULL)\n\t    return OK;\n    }\n\n    return FAIL;\n}\n\n/*\n * Return TRUE if \"name\" is a local variable, argument, script variable or\n * imported.\n */\n    static int\nvariable_exists(char_u *name, size_t len, cctx_T *cctx)\n{\n    return (cctx != NULL\n\t\t&& (lookup_local(name, len, NULL, cctx) == OK\n\t\t    || arg_exists(name, len, NULL, NULL, NULL, cctx) == OK))\n\t    || script_var_exists(name, len, cctx, NULL) == OK\n\t    || find_imported(name, len, FALSE) != NULL;\n}\n\n/*\n * Return TRUE if \"name\" is a local variable, argument, script variable,\n * imported or function.  Or commands are being skipped, a declaration may have\n * been skipped then.\n */\n    static int\nitem_exists(char_u *name, size_t len, int cmd UNUSED, cctx_T *cctx)\n{\n    return variable_exists(name, len, cctx);\n}\n\n/*\n * Check if \"p[len]\" is already defined, either in script \"import_sid\" or in\n * compilation context \"cctx\".\n * \"cctx\" is NULL at the script level, \"cstack\" is NULL in a function.\n * Does not check the global namespace.\n * If \"is_arg\" is TRUE the error message is for an argument name.\n * Return FAIL and give an error if it defined.\n */\n    int\ncheck_defined(\n\tchar_u\t    *p,\n\tsize_t\t    len,\n\tcctx_T\t    *cctx,\n\tcstack_T    *cstack,\n\tint\t    is_arg)\n{\n    int\t\tc = p[len];\n    ufunc_T\t*ufunc = NULL;\n\n    // underscore argument is OK\n    if (len == 1 && *p == '_')\n\treturn OK;\n\n    if (script_var_exists(p, len, cctx, cstack) == OK)\n    {\n\tif (is_arg)\n\t    semsg(_(e_argument_already_declared_in_script_str), p);\n\telse\n\t    semsg(_(e_variable_already_declared_in_script_str), p);\n\treturn FAIL;\n    }\n\n    p[len] = NUL;\n    if ((cctx != NULL\n\t\t&& (lookup_local(p, len, NULL, cctx) == OK\n\t\t    || arg_exists(p, len, NULL, NULL, NULL, cctx) == OK))\n\t    || find_imported(p, len, FALSE) != NULL\n\t    || (ufunc = find_func_even_dead(p, 0)) != NULL)\n    {\n\t// A local or script-local function can shadow a global function.\n\tif (ufunc == NULL || ((ufunc->uf_flags & FC_DEAD) == 0\n\t\t    && (!func_is_global(ufunc)\n\t\t\t\t\t     || (p[0] == 'g' && p[1] == ':'))))\n\t{\n\t    if (is_arg)\n\t\tsemsg(_(e_argument_name_shadows_existing_variable_str), p);\n\t    else\n\t\tsemsg(_(e_name_already_defined_str), p);\n\t    p[len] = c;\n\t    return FAIL;\n\t}\n    }\n    p[len] = c;\n    return OK;\n}\n\n\n/*\n * Return TRUE if \"actual\" could be \"expected\" and a runtime typecheck is to be\n * used.  Return FALSE if the types will never match.\n */\n    static int\nuse_typecheck(type_T *actual, type_T *expected)\n{\n    if (actual->tt_type == VAR_ANY\n\t    || actual->tt_type == VAR_UNKNOWN\n\t    || (actual->tt_type == VAR_FUNC\n\t\t&& (expected->tt_type == VAR_FUNC\n\t\t\t\t\t   || expected->tt_type == VAR_PARTIAL)\n\t\t&& (actual->tt_member == &t_any\n\t\t    || actual->tt_member == &t_unknown\n\t\t    || actual->tt_argcount < 0)\n\t\t&& (actual->tt_member == &t_unknown ||\n\t\t    (actual->tt_member == &t_void)\n\t\t\t\t\t == (expected->tt_member == &t_void))))\n\treturn TRUE;\n    if ((actual->tt_type == VAR_LIST || actual->tt_type == VAR_DICT)\n\t\t\t\t       && actual->tt_type == expected->tt_type)\n\t// This takes care of a nested list or dict.\n\treturn use_typecheck(actual->tt_member, expected->tt_member);\n    return FALSE;\n}\n\n/*\n * Check that\n * - \"actual\" matches \"expected\" type or\n * - \"actual\" is a type that can be \"expected\" type: add a runtime check; or\n * - return FAIL.\n * If \"actual_is_const\" is TRUE then the type won't change at runtime, do not\n * generate a TYPECHECK.\n */\n    int\nneed_type_where(\n\ttype_T\t*actual,\n\ttype_T\t*expected,\n\tint\toffset,\n\twhere_T\twhere,\n\tcctx_T\t*cctx,\n\tint\tsilent,\n\tint\tactual_is_const)\n{\n    int ret;\n\n    if (expected == &t_bool && actual != &t_bool\n\t\t\t\t\t&& (actual->tt_flags & TTFLAG_BOOL_OK))\n    {\n\t// Using \"0\", \"1\" or the result of an expression with \"&&\" or \"||\" as a\n\t// boolean is OK but requires a conversion.\n\tgenerate_2BOOL(cctx, FALSE, offset);\n\treturn OK;\n    }\n\n    ret = check_type_maybe(expected, actual, FALSE, where);\n    if (ret == OK)\n\treturn OK;\n\n    // If actual a constant a runtime check makes no sense.  If it's\n    // null_function it is OK.\n    if (actual_is_const && ret == MAYBE && actual == &t_func_unknown)\n\treturn OK;\n\n    // If the actual type can be the expected type add a runtime check.\n    if (!actual_is_const && ret == MAYBE && use_typecheck(actual, expected))\n    {\n\tgenerate_TYPECHECK(cctx, expected, offset,\n\t\t\t\t\t    where.wt_variable, where.wt_index);\n\treturn OK;\n    }\n\n    if (!silent)\n\ttype_mismatch_where(expected, actual, where);\n    return FAIL;\n}\n\n    int\nneed_type(\n\ttype_T\t*actual,\n\ttype_T\t*expected,\n\tint\toffset,\n\tint\targ_idx,\n\tcctx_T\t*cctx,\n\tint\tsilent,\n\tint\tactual_is_const)\n{\n    where_T where = WHERE_INIT;\n\n    where.wt_index = arg_idx;\n    return need_type_where(actual, expected, offset, where,\n\t\t\t\t\t\tcctx, silent, actual_is_const);\n}\n\n/*\n * Reserve space for a local variable.\n * Return the variable or NULL if it failed.\n */\n    lvar_T *\nreserve_local(\n\tcctx_T\t*cctx,\n\tchar_u\t*name,\n\tsize_t\tlen,\n\tint\tisConst,\n\ttype_T\t*type)\n{\n    lvar_T  *lvar;\n    dfunc_T *dfunc;\n\n    if (arg_exists(name, len, NULL, NULL, NULL, cctx) == OK)\n    {\n\temsg_namelen(_(e_str_is_used_as_argument), name, (int)len);\n\treturn NULL;\n    }\n\n    if (GA_GROW_FAILS(&cctx->ctx_locals, 1))\n\treturn NULL;\n    lvar = ((lvar_T *)cctx->ctx_locals.ga_data) + cctx->ctx_locals.ga_len++;\n    CLEAR_POINTER(lvar);\n\n    // Every local variable uses the next entry on the stack.  We could re-use\n    // the last ones when leaving a scope, but then variables used in a closure\n    // might get overwritten.  To keep things simple do not re-use stack\n    // entries.  This is less efficient, but memory is cheap these days.\n    dfunc = ((dfunc_T *)def_functions.ga_data) + cctx->ctx_ufunc->uf_dfunc_idx;\n    lvar->lv_idx = dfunc->df_var_names.ga_len;\n\n    lvar->lv_name = vim_strnsave(name, len == 0 ? STRLEN(name) : len);\n    lvar->lv_const = isConst;\n    lvar->lv_type = type;\n\n    // Remember the name for debugging.\n    if (GA_GROW_FAILS(&dfunc->df_var_names, 1))\n\treturn NULL;\n    ((char_u **)dfunc->df_var_names.ga_data)[lvar->lv_idx] =\n\t\t\t\t\t\t    vim_strsave(lvar->lv_name);\n    ++dfunc->df_var_names.ga_len;\n\n    return lvar;\n}\n\n/*\n * If \"check_writable\" is ASSIGN_CONST give an error if the variable was\n * defined with :final or :const, if \"check_writable\" is ASSIGN_FINAL give an\n * error if the variable was defined with :const.\n */\n    static int\ncheck_item_writable(svar_T *sv, int check_writable, char_u *name)\n{\n    if ((check_writable == ASSIGN_CONST && sv->sv_const != 0)\n\t    || (check_writable == ASSIGN_FINAL\n\t\t\t\t\t      && sv->sv_const == ASSIGN_CONST))\n    {\n\tsemsg(_(e_cannot_change_readonly_variable_str), name);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Find \"name\" in script-local items of script \"sid\".\n * Pass \"check_writable\" to check_item_writable().\n * \"cctx\" is NULL at the script level, \"cstack\" is NULL in a function.\n * Returns the index in \"sn_var_vals\" if found.\n * If found but not in \"sn_var_vals\" returns -1.\n * If not found or the variable is not writable returns -2.\n */\n    int\nget_script_item_idx(\n\tint\t    sid,\n\tchar_u\t    *name,\n\tint\t    check_writable,\n\tcctx_T\t    *cctx,\n\tcstack_T    *cstack)\n{\n    hashtab_T\t    *ht;\n    dictitem_T\t    *di;\n    scriptitem_T    *si = SCRIPT_ITEM(sid);\n    svar_T\t    *sv;\n    int\t\t    idx;\n\n    if (!SCRIPT_ID_VALID(sid))\n\treturn -1;\n    if (sid == current_sctx.sc_sid)\n    {\n\tsallvar_T *sav = find_script_var(name, 0, cctx, cstack);\n\n\tif (sav == NULL)\n\t    return -2;\n\tidx = sav->sav_var_vals_idx;\n\tsv = ((svar_T *)si->sn_var_vals.ga_data) + idx;\n\tif (check_item_writable(sv, check_writable, name) == FAIL)\n\t    return -2;\n\treturn idx;\n    }\n\n    // First look the name up in the hashtable.\n    ht = &SCRIPT_VARS(sid);\n    di = find_var_in_ht(ht, 0, name, TRUE);\n    if (di == NULL)\n    {\n\tif (si->sn_autoload_prefix != NULL)\n\t{\n\t    hashitem_T *hi;\n\n\t    // A variable exported from an autoload script is in the global\n\t    // variables, we can find it in the all_vars table.\n\t    hi = hash_find(&si->sn_all_vars.dv_hashtab, name);\n\t    if (!HASHITEM_EMPTY(hi))\n\t\treturn HI2SAV(hi)->sav_var_vals_idx;\n\t}\n\treturn -2;\n    }\n\n    // Now find the svar_T index in sn_var_vals.\n    for (idx = 0; idx < si->sn_var_vals.ga_len; ++idx)\n    {\n\tsv = ((svar_T *)si->sn_var_vals.ga_data) + idx;\n\tif (sv->sv_tv == &di->di_tv)\n\t{\n\t    if (check_item_writable(sv, check_writable, name) == FAIL)\n\t\treturn -2;\n\t    return idx;\n\t}\n    }\n    return -1;\n}\n\n    static imported_T *\nfind_imported_in_script(char_u *name, size_t len, int sid)\n{\n    scriptitem_T    *si;\n    int\t\t    idx;\n\n    if (!SCRIPT_ID_VALID(sid))\n\treturn NULL;\n    si = SCRIPT_ITEM(sid);\n    for (idx = 0; idx < si->sn_imports.ga_len; ++idx)\n    {\n\timported_T *import = ((imported_T *)si->sn_imports.ga_data) + idx;\n\n\tif (len == 0 ? STRCMP(name, import->imp_name) == 0\n\t\t     : STRLEN(import->imp_name) == len\n\t\t\t\t  && STRNCMP(name, import->imp_name, len) == 0)\n\t    return import;\n    }\n    return NULL;\n}\n\n/*\n * Find \"name\" in imported items of the current script.\n * If \"len\" is 0 use any length that works.\n * If \"load\" is TRUE and the script was not loaded yet, load it now.\n */\n    imported_T *\nfind_imported(char_u *name, size_t len, int load)\n{\n    imported_T\t    *ret;\n\n    if (!SCRIPT_ID_VALID(current_sctx.sc_sid))\n\treturn NULL;\n\n    ret = find_imported_in_script(name, len, current_sctx.sc_sid);\n    if (ret != NULL && load && (ret->imp_flags & IMP_FLAGS_AUTOLOAD))\n    {\n\tscid_T\tdummy;\n\tint\tsave_emsg_off = emsg_off;\n\n\t// \"emsg_off\" will be set when evaluating an expression silently, but\n\t// we do want to know about errors in a script.  Also because it then\n\t// aborts when an error is encountered.\n\temsg_off = FALSE;\n\n\t// script found before but not loaded yet\n\tret->imp_flags &= ~IMP_FLAGS_AUTOLOAD;\n\t(void)do_source(SCRIPT_ITEM(ret->imp_sid)->sn_name, FALSE,\n\t\t\t\t\t\t\t    DOSO_NONE, &dummy);\n\n\temsg_off = save_emsg_off;\n    }\n    return ret;\n}\n\n/*\n * Called when checking for a following operator at \"arg\".  When the rest of\n * the line is empty or only a comment, peek the next line.  If there is a next\n * line return a pointer to it and set \"nextp\".\n * Otherwise skip over white space.\n */\n    char_u *\nmay_peek_next_line(cctx_T *cctx, char_u *arg, char_u **nextp)\n{\n    char_u *p = skipwhite(arg);\n\n    *nextp = NULL;\n    if (*p == NUL || (VIM_ISWHITE(*arg) && vim9_comment_start(p)))\n    {\n\t*nextp = peek_next_line_from_context(cctx);\n\tif (*nextp != NULL)\n\t    return *nextp;\n    }\n    return p;\n}\n\n/*\n * Return a pointer to the next line that isn't empty or only contains a\n * comment. Skips over white space.\n * Returns NULL if there is none.\n */\n    char_u *\npeek_next_line_from_context(cctx_T *cctx)\n{\n    int lnum = cctx->ctx_lnum;\n\n    while (++lnum < cctx->ctx_ufunc->uf_lines.ga_len)\n    {\n\tchar_u *line = ((char_u **)cctx->ctx_ufunc->uf_lines.ga_data)[lnum];\n\tchar_u *p;\n\n\t// ignore NULLs inserted for continuation lines\n\tif (line != NULL)\n\t{\n\t    p = skipwhite(line);\n\t    if (vim9_bad_comment(p))\n\t\treturn NULL;\n\t    if (*p != NUL && !vim9_comment_start(p))\n\t\treturn p;\n\t}\n    }\n    return NULL;\n}\n\n/*\n * Get the next line of the function from \"cctx\".\n * Skips over empty lines.  Skips over comment lines if \"skip_comment\" is TRUE.\n * Returns NULL when at the end.\n */\n    char_u *\nnext_line_from_context(cctx_T *cctx, int skip_comment)\n{\n    char_u\t*line;\n\n    do\n    {\n\t++cctx->ctx_lnum;\n\tif (cctx->ctx_lnum >= cctx->ctx_ufunc->uf_lines.ga_len)\n\t{\n\t    line = NULL;\n\t    break;\n\t}\n\tline = ((char_u **)cctx->ctx_ufunc->uf_lines.ga_data)[cctx->ctx_lnum];\n\tcctx->ctx_line_start = line;\n\tSOURCING_LNUM = cctx->ctx_lnum + 1;\n    } while (line == NULL || *skipwhite(line) == NUL\n\t\t     || (skip_comment && vim9_comment_start(skipwhite(line))));\n    return line;\n}\n\n/*\n * Skip over white space at \"whitep\" and assign to \"*arg\".\n * If \"*arg\" is at the end of the line, advance to the next line.\n * Also when \"whitep\" points to white space and \"*arg\" is on a \"#\".\n * Return FAIL if beyond the last line, \"*arg\" is unmodified then.\n */\n    int\nmay_get_next_line(char_u *whitep, char_u **arg, cctx_T *cctx)\n{\n    *arg = skipwhite(whitep);\n    if (vim9_bad_comment(*arg))\n\treturn FAIL;\n    if (**arg == NUL || (VIM_ISWHITE(*whitep) && vim9_comment_start(*arg)))\n    {\n\tchar_u *next = next_line_from_context(cctx, TRUE);\n\n\tif (next == NULL)\n\t    return FAIL;\n\t*arg = skipwhite(next);\n    }\n    return OK;\n}\n\n/*\n * Idem, and give an error when failed.\n */\n    int\nmay_get_next_line_error(char_u *whitep, char_u **arg, cctx_T *cctx)\n{\n    if (may_get_next_line(whitep, arg, cctx) == FAIL)\n    {\n\tSOURCING_LNUM = cctx->ctx_lnum + 1;\n\temsg(_(e_line_incomplete));\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Get a line from the compilation context, compatible with exarg_T getline().\n * Return a pointer to the line in allocated memory.\n * Return NULL for end-of-file or some error.\n */\n    static char_u *\nexarg_getline(\n\tint c UNUSED,\n\tvoid *cookie,\n\tint indent UNUSED,\n\tgetline_opt_T options UNUSED)\n{\n    cctx_T  *cctx = (cctx_T *)cookie;\n    char_u  *p;\n\n    for (;;)\n    {\n\tif (cctx->ctx_lnum >= cctx->ctx_ufunc->uf_lines.ga_len - 1)\n\t    return NULL;\n\t++cctx->ctx_lnum;\n\tp = ((char_u **)cctx->ctx_ufunc->uf_lines.ga_data)[cctx->ctx_lnum];\n\t// Comment lines result in NULL pointers, skip them.\n\tif (p != NULL)\n\t    return vim_strsave(p);\n    }\n}\n\n    void\nfill_exarg_from_cctx(exarg_T *eap, cctx_T *cctx)\n{\n    eap->getline = exarg_getline;\n    eap->cookie = cctx;\n    eap->skip = cctx->ctx_skip == SKIP_YES;\n}\n\n/*\n * Return TRUE if \"ufunc\" should be compiled, taking into account whether\n * \"profile\" indicates profiling is to be done.\n */\n    int\nfunc_needs_compiling(ufunc_T *ufunc, compiletype_T compile_type)\n{\n    switch (ufunc->uf_def_status)\n    {\n\tcase UF_TO_BE_COMPILED:\n\t    return TRUE;\n\n\tcase UF_COMPILED:\n\t{\n\t    dfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\n\t    switch (compile_type)\n\t    {\n\t\tcase CT_PROFILE:\n#ifdef FEAT_PROFILE\n\t\t    return dfunc->df_instr_prof == NULL;\n#endif\n\t\tcase CT_NONE:\n\t\t    return dfunc->df_instr == NULL;\n\t\tcase CT_DEBUG:\n\t\t    return dfunc->df_instr_debug == NULL;\n\t    }\n\t}\n\n\tcase UF_NOT_COMPILED:\n\tcase UF_COMPILE_ERROR:\n\tcase UF_COMPILING:\n\t    break;\n    }\n    return FALSE;\n}\n\n/*\n * Compile a nested :def command.\n */\n    static char_u *\ncompile_nested_function(exarg_T *eap, cctx_T *cctx, garray_T *lines_to_free)\n{\n    int\t\tis_global = *eap->arg == 'g' && eap->arg[1] == ':';\n    char_u\t*name_start = eap->arg;\n    char_u\t*name_end = to_name_end(eap->arg, TRUE);\n    int\t\toff;\n    char_u\t*func_name;\n    char_u\t*lambda_name;\n    ufunc_T\t*ufunc;\n    int\t\tr = FAIL;\n    compiletype_T   compile_type;\n    isn_T\t*funcref_isn = NULL;\n    lvar_T\t*lvar = NULL;\n\n    if (eap->forceit)\n    {\n\temsg(_(e_cannot_use_bang_with_nested_def));\n\treturn NULL;\n    }\n\n    if (*name_start == '/')\n    {\n\tname_end = skip_regexp(name_start + 1, '/', TRUE);\n\tif (*name_end == '/')\n\t    ++name_end;\n\tset_nextcmd(eap, name_end);\n    }\n    if (name_end == name_start || *skipwhite(name_end) != '(')\n    {\n\tif (!ends_excmd2(name_start, name_end))\n\t{\n\t    if (*skipwhite(name_end) == '.')\n\t\tsemsg(_(e_cannot_define_dict_func_in_vim9_script_str),\n\t\t\t\t\t\t\t\t     eap->cmd);\n\t    else\n\t\tsemsg(_(e_invalid_command_str), eap->cmd);\n\t    return NULL;\n\t}\n\n\t// \"def\" or \"def Name\": list functions\n\tif (generate_DEF(cctx, name_start, name_end - name_start) == FAIL)\n\t    return NULL;\n\treturn eap->nextcmd == NULL ? (char_u *)\"\" : eap->nextcmd;\n    }\n\n    // Only g:Func() can use a namespace.\n    if (name_start[1] == ':' && !is_global)\n    {\n\tsemsg(_(e_namespace_not_supported_str), name_start);\n\treturn NULL;\n    }\n    if (cctx->ctx_skip != SKIP_YES\n\t    && check_defined(name_start, name_end - name_start, cctx,\n\t\t\t\t\t\t\t  NULL, FALSE) == FAIL)\n\treturn NULL;\n    if (!ASCII_ISUPPER(is_global ? name_start[2] : name_start[0]))\n    {\n\tsemsg(_(e_function_name_must_start_with_capital_str), name_start);\n\treturn NULL;\n    }\n\n    eap->arg = name_end;\n    fill_exarg_from_cctx(eap, cctx);\n\n    eap->forceit = FALSE;\n    // We use the special <Lamba>99 name, but it's not really a lambda.\n    lambda_name = vim_strsave(get_lambda_name());\n    if (lambda_name == NULL)\n\treturn NULL;\n\n    // This may free the current line, make a copy of the name.\n    off = is_global ? 2 : 0;\n    func_name = vim_strnsave(name_start + off, name_end - name_start - off);\n    if (func_name == NULL)\n    {\n\tr = FAIL;\n\tgoto theend;\n    }\n\n    ufunc = define_function(eap, lambda_name, lines_to_free);\n    if (ufunc == NULL)\n    {\n\tr = eap->skip ? OK : FAIL;\n\tgoto theend;\n    }\n    if (eap->nextcmd != NULL)\n    {\n\tsemsg(_(e_text_found_after_str_str),\n\t      eap->cmdidx == CMD_def ? \"enddef\" : \"endfunction\", eap->nextcmd);\n\tr = FAIL;\n\tfunc_ptr_unref(ufunc);\n\tgoto theend;\n    }\n\n    // copy over the block scope IDs before compiling\n    if (!is_global && cctx->ctx_ufunc->uf_block_depth > 0)\n    {\n\tint block_depth = cctx->ctx_ufunc->uf_block_depth;\n\n\tufunc->uf_block_ids = ALLOC_MULT(int, block_depth);\n\tif (ufunc->uf_block_ids != NULL)\n\t{\n\t    mch_memmove(ufunc->uf_block_ids, cctx->ctx_ufunc->uf_block_ids,\n\t\t\t\t\t\t    sizeof(int) * block_depth);\n\t    ufunc->uf_block_depth = block_depth;\n\t}\n    }\n\n    // Define the funcref before compiling, so that it is found by any\n    // recursive call.\n    if (is_global)\n    {\n\tr = generate_NEWFUNC(cctx, lambda_name, func_name);\n\tfunc_name = NULL;\n\tlambda_name = NULL;\n    }\n    else\n    {\n\t// Define a local variable for the function reference.\n\tlvar = reserve_local(cctx, func_name, name_end - name_start,\n\t\t\t\t\t\t    TRUE, ufunc->uf_func_type);\n\tif (lvar == NULL)\n\t    goto theend;\n\tif (generate_FUNCREF(cctx, ufunc, &funcref_isn) == FAIL)\n\t    goto theend;\n\tr = generate_STORE(cctx, ISN_STORE, lvar->lv_idx, NULL);\n    }\n\n    compile_type = get_compile_type(ufunc);\n#ifdef FEAT_PROFILE\n    // If the outer function is profiled, also compile the nested function for\n    // profiling.\n    if (cctx->ctx_compile_type == CT_PROFILE)\n\tcompile_type = CT_PROFILE;\n#endif\n    if (func_needs_compiling(ufunc, compile_type)\n\t    && compile_def_function(ufunc, TRUE, compile_type, cctx) == FAIL)\n    {\n\tfunc_ptr_unref(ufunc);\n\tif (lvar != NULL)\n\t    // Now the local variable can't be used.\n\t    *lvar->lv_name = '/';  // impossible value\n\tgoto theend;\n    }\n\n#ifdef FEAT_PROFILE\n    // When the outer function is compiled for profiling, the nested function\n    // may be called without profiling.  Compile it here in the right context.\n    if (compile_type == CT_PROFILE && func_needs_compiling(ufunc, CT_NONE))\n\tcompile_def_function(ufunc, FALSE, CT_NONE, cctx);\n#endif\n\n    // If a FUNCREF instruction was generated, set the index after compiling.\n    if (funcref_isn != NULL && ufunc->uf_def_status == UF_COMPILED)\n\tfuncref_isn->isn_arg.funcref.fr_dfunc_idx = ufunc->uf_dfunc_idx;\n\ntheend:\n    vim_free(lambda_name);\n    vim_free(func_name);\n    return r == FAIL ? NULL : (char_u *)\"\";\n}\n\n/*\n * Compile one Vim expression {expr} in string \"p\".\n * \"p\" points to the opening \"{\".\n * Return a pointer to the character after \"}\", NULL for an error.\n */\n    char_u *\ncompile_one_expr_in_str(char_u *p, cctx_T *cctx)\n{\n    char_u\t*block_start;\n    char_u\t*block_end;\n\n    // Skip the opening {.\n    block_start = skipwhite(p + 1);\n    block_end = block_start;\n    if (*block_start != NUL && skip_expr(&block_end, NULL) == FAIL)\n\treturn NULL;\n    block_end = skipwhite(block_end);\n    // The block must be closed by a }.\n    if (*block_end != '}')\n    {\n\tsemsg(_(e_missing_close_curly_str), p);\n\treturn NULL;\n    }\n    if (compile_expr0(&block_start, cctx) == FAIL)\n\treturn NULL;\n    may_generate_2STRING(-1, TRUE, cctx);\n\n    return block_end + 1;\n}\n\n/*\n * Compile a string \"str\" (either containing a literal string or a mix of\n * literal strings and Vim expressions of the form `{expr}`).  This is used\n * when compiling a heredoc assignment to a variable or an interpolated string\n * in a Vim9 def function.  Vim9 instructions are generated to push strings,\n * evaluate expressions, concatenate them and create a list of lines.  When\n * \"evalstr\" is TRUE, Vim expressions in \"str\" are evaluated.\n */\n    int\ncompile_all_expr_in_str(char_u *str, int evalstr, cctx_T *cctx)\n{\n    char_u\t*p = str;\n    char_u\t*val;\n    int\t\tcount = 0;\n\n    if (cctx->ctx_skip == SKIP_YES)\n\treturn OK;\n\n    if (!evalstr || *str == NUL)\n    {\n\t// Literal string, possibly empty.\n\tval = *str != NUL ? vim_strsave(str) : NULL;\n\treturn generate_PUSHS(cctx, &val);\n    }\n\n    // Push all the string pieces to the stack, followed by a ISN_CONCAT.\n    while (*p != NUL)\n    {\n\tchar_u\t*lit_start;\n\tint\tescaped_brace = FALSE;\n\n\t// Look for a block start.\n\tlit_start = p;\n\twhile (*p != '{' && *p != '}' && *p != NUL)\n\t    ++p;\n\n\tif (*p != NUL && *p == p[1])\n\t{\n\t    // Escaped brace, unescape and continue.\n\t    // Include the brace in the literal string.\n\t    ++p;\n\t    escaped_brace = TRUE;\n\t}\n\telse if (*p == '}')\n\t{\n\t    semsg(_(e_stray_closing_curly_str), str);\n\t    return FAIL;\n\t}\n\n\t// Append the literal part.\n\tif (p != lit_start)\n\t{\n\t    val = vim_strnsave(lit_start, (size_t)(p - lit_start));\n\t    if (generate_PUSHS(cctx, &val) == FAIL)\n\t\treturn FAIL;\n\t    ++count;\n\t}\n\n\tif (*p == NUL)\n\t    break;\n\n\tif (escaped_brace)\n\t{\n\t    // Skip the second brace.\n\t    ++p;\n\t    continue;\n\t}\n\n\tp = compile_one_expr_in_str(p, cctx);\n\tif (p == NULL)\n\t    return FAIL;\n\t++count;\n    }\n\n    // Small optimization, if there's only a single piece skip the ISN_CONCAT.\n    if (count > 1)\n\treturn generate_CONCAT(cctx, count);\n\n    return OK;\n}\n\n/*\n * Return the length of an assignment operator, or zero if there isn't one.\n */\n    int\nassignment_len(char_u *p, int *heredoc)\n{\n    if (*p == '=')\n    {\n\tif (p[1] == '<' && p[2] == '<')\n\t{\n\t    *heredoc = TRUE;\n\t    return 3;\n\t}\n\treturn 1;\n    }\n    if (vim_strchr((char_u *)\"+-*/%\", *p) != NULL && p[1] == '=')\n\treturn 2;\n    if (STRNCMP(p, \"..=\", 3) == 0)\n\treturn 3;\n    return 0;\n}\n\n/*\n * Generate the load instruction for \"name\".\n */\n    static void\ngenerate_loadvar(\n\tcctx_T\t\t*cctx,\n\tassign_dest_T\tdest,\n\tchar_u\t\t*name,\n\tlvar_T\t\t*lvar,\n\ttype_T\t\t*type)\n{\n    switch (dest)\n    {\n\tcase dest_option:\n\tcase dest_func_option:\n\t    generate_LOAD(cctx, ISN_LOADOPT, 0, name, type);\n\t    break;\n\tcase dest_global:\n\t    if (vim_strchr(name, AUTOLOAD_CHAR) == NULL)\n\t    {\n\t\tif (name[2] == NUL)\n\t\t    generate_instr_type(cctx, ISN_LOADGDICT, &t_dict_any);\n\t\telse\n\t\t    generate_LOAD(cctx, ISN_LOADG, 0, name + 2, type);\n\t    }\n\t    else\n\t\tgenerate_LOAD(cctx, ISN_LOADAUTO, 0, name, type);\n\t    break;\n\tcase dest_buffer:\n\t    generate_LOAD(cctx, ISN_LOADB, 0, name + 2, type);\n\t    break;\n\tcase dest_window:\n\t    generate_LOAD(cctx, ISN_LOADW, 0, name + 2, type);\n\t    break;\n\tcase dest_tab:\n\t    generate_LOAD(cctx, ISN_LOADT, 0, name + 2, type);\n\t    break;\n\tcase dest_script:\n\t    compile_load_scriptvar(cctx,\n\t\t\t\t  name + (name[1] == ':' ? 2 : 0), NULL, NULL);\n\t    break;\n\tcase dest_env:\n\t    // Include $ in the name here\n\t    generate_LOAD(cctx, ISN_LOADENV, 0, name, type);\n\t    break;\n\tcase dest_reg:\n\t    generate_LOAD(cctx, ISN_LOADREG, name[1], NULL, &t_string);\n\t    break;\n\tcase dest_vimvar:\n\t    generate_LOADV(cctx, name + 2);\n\t    break;\n\tcase dest_local:\n\t    if (cctx->ctx_skip != SKIP_YES)\n\t    {\n\t\tif (lvar->lv_from_outer > 0)\n\t\t    generate_LOADOUTER(cctx, lvar->lv_idx, lvar->lv_from_outer,\n\t\t\t\t\t\t\t\t\t type);\n\t\telse\n\t\t    generate_LOAD(cctx, ISN_LOAD, lvar->lv_idx, NULL, type);\n\t    }\n\t    break;\n\tcase dest_expr:\n\t    // list or dict value should already be on the stack.\n\t    break;\n    }\n}\n\n/*\n * Skip over \"[expr]\" or \".member\".\n * Does not check for any errors.\n */\n    static char_u *\nskip_index(char_u *start)\n{\n    char_u *p = start;\n\n    if (*p == '[')\n    {\n\tp = skipwhite(p + 1);\n\t(void)skip_expr(&p, NULL);\n\tp = skipwhite(p);\n\tif (*p == ']')\n\t    return p + 1;\n\treturn p;\n    }\n    // if (*p == '.')\n    return to_name_end(p + 1, TRUE);\n}\n\n    void\nvim9_declare_error(char_u *name)\n{\n    char *scope = \"\";\n\n    switch (*name)\n    {\n\tcase 'g': scope = _(\"global\"); break;\n\tcase 'b': scope = _(\"buffer\"); break;\n\tcase 'w': scope = _(\"window\"); break;\n\tcase 't': scope = _(\"tab\"); break;\n\tcase 'v': scope = \"v:\"; break;\n\tcase '$': semsg(_(e_cannot_declare_an_environment_variable), name);\n\t\t  return;\n\tcase '&': semsg(_(e_cannot_declare_an_option), name);\n\t\t  return;\n\tcase '@': semsg(_(e_cannot_declare_a_register_str), name);\n\t\t  return;\n\tdefault: return;\n    }\n    semsg(_(e_cannot_declare_a_scope_variable), scope, name);\n}\n\n/*\n * For one assignment figure out the type of destination.  Return it in \"dest\".\n * When not recognized \"dest\" is not set.\n * For an option \"option_scope\" is set.\n * For a v:var \"vimvaridx\" is set.\n * \"type\" is set to the destination type if known, unchanted otherwise.\n * Return FAIL if an error message was given.\n */\n    int\nget_var_dest(\n\tchar_u\t\t*name,\n\tassign_dest_T\t*dest,\n\tcmdidx_T\tcmdidx,\n\tint\t\t*option_scope,\n\tint\t\t*vimvaridx,\n\ttype_T\t\t**type,\n\tcctx_T\t\t*cctx)\n{\n    char_u *p;\n\n    if (*name == '&')\n    {\n\tint\t\tcc;\n\tlong\t\tnumval;\n\tgetoption_T\topt_type;\n\tint\t\topt_p_flags;\n\n\t*dest = dest_option;\n\tif (cmdidx == CMD_final || cmdidx == CMD_const)\n\t{\n\t    emsg(_(e_cannot_lock_option));\n\t    return FAIL;\n\t}\n\tp = name;\n\tp = find_option_end(&p, option_scope);\n\tif (p == NULL)\n\t{\n\t    // cannot happen?\n\t    emsg(_(e_unexpected_characters_in_assignment));\n\t    return FAIL;\n\t}\n\tcc = *p;\n\t*p = NUL;\n\topt_type = get_option_value(skip_option_env_lead(name),\n\t\t\t\t   &numval, NULL, &opt_p_flags, *option_scope);\n\t*p = cc;\n\tswitch (opt_type)\n\t{\n\t    case gov_unknown:\n\t\t    semsg(_(e_unknown_option_str), name);\n\t\t    return FAIL;\n\t    case gov_string:\n\t    case gov_hidden_string:\n\t\t    if (opt_p_flags & P_FUNC)\n\t\t    {\n\t\t\t// might be a Funcref, check the type later\n\t\t\t*type = &t_any;\n\t\t\t*dest = dest_func_option;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t*type = &t_string;\n\t\t    }\n\t\t    break;\n\t    case gov_bool:\n\t    case gov_hidden_bool:\n\t\t    *type = &t_bool;\n\t\t    break;\n\t    case gov_number:\n\t    case gov_hidden_number:\n\t\t    *type = &t_number;\n\t\t    break;\n\t}\n    }\n    else if (*name == '$')\n    {\n\t*dest = dest_env;\n\t*type = &t_string;\n    }\n    else if (*name == '@')\n    {\n\tif (name[1] != '@'\n\t\t\t&& (!valid_yank_reg(name[1], FALSE) || name[1] == '.'))\n\t{\n\t    emsg_invreg(name[1]);\n\t    return FAIL;\n\t}\n\t*dest = dest_reg;\n\t*type = name[1] == '#' ? &t_number_or_string : &t_string;\n    }\n    else if (STRNCMP(name, \"g:\", 2) == 0)\n    {\n\t*dest = dest_global;\n    }\n    else if (STRNCMP(name, \"b:\", 2) == 0)\n    {\n\t*dest = dest_buffer;\n    }\n    else if (STRNCMP(name, \"w:\", 2) == 0)\n    {\n\t*dest = dest_window;\n    }\n    else if (STRNCMP(name, \"t:\", 2) == 0)\n    {\n\t*dest = dest_tab;\n    }\n    else if (STRNCMP(name, \"v:\", 2) == 0)\n    {\n\ttypval_T\t*vtv;\n\tint\t\tdi_flags;\n\n\t*vimvaridx = find_vim_var(name + 2, &di_flags);\n\tif (*vimvaridx < 0)\n\t{\n\t    semsg(_(e_variable_not_found_str), name);\n\t    return FAIL;\n\t}\n\t// We use the current value of \"sandbox\" here, is that OK?\n\tif (var_check_ro(di_flags, name, FALSE))\n\t    return FAIL;\n\t*dest = dest_vimvar;\n\tvtv = get_vim_var_tv(*vimvaridx);\n\t*type = typval2type_vimvar(vtv, cctx->ctx_type_list);\n    }\n    return OK;\n}\n\n    static int\nis_decl_command(cmdidx_T cmdidx)\n{\n    return cmdidx == CMD_let || cmdidx == CMD_var\n\t\t\t\t || cmdidx == CMD_final || cmdidx == CMD_const;\n}\n\n/*\n * Figure out the LHS type and other properties for an assignment or one item\n * of \":unlet\" with an index.\n * Returns OK or FAIL.\n */\n    int\ncompile_lhs(\n\tchar_u\t    *var_start,\n\tlhs_T\t    *lhs,\n\tcmdidx_T    cmdidx,\n\tint\t    heredoc,\n\tint\t    has_cmd,\t    // \"var\" before \"var_start\"\n\tint\t    oplen,\n\tcctx_T\t    *cctx)\n{\n    char_u\t*var_end;\n    int\t\tis_decl = is_decl_command(cmdidx);\n\n    CLEAR_POINTER(lhs);\n    lhs->lhs_dest = dest_local;\n    lhs->lhs_vimvaridx = -1;\n    lhs->lhs_scriptvar_idx = -1;\n\n    // \"dest_end\" is the end of the destination, including \"[expr]\" or\n    // \".name\".\n    // \"var_end\" is the end of the variable/option/etc. name.\n    lhs->lhs_dest_end = skip_var_one(var_start, FALSE);\n    if (*var_start == '@')\n\tvar_end = var_start + 2;\n    else\n    {\n\t// skip over the leading \"&\", \"&l:\", \"&g:\" and \"$\"\n\tvar_end = skip_option_env_lead(var_start);\n\tvar_end = to_name_end(var_end, TRUE);\n    }\n\n    // \"a: type\" is declaring variable \"a\" with a type, not dict \"a:\".\n    if (is_decl && lhs->lhs_dest_end == var_start + 2\n\t\t\t\t\t       && lhs->lhs_dest_end[-1] == ':')\n\t--lhs->lhs_dest_end;\n    if (is_decl && var_end == var_start + 2 && var_end[-1] == ':')\n\t--var_end;\n    lhs->lhs_end = lhs->lhs_dest_end;\n\n    // compute the length of the destination without \"[expr]\" or \".name\"\n    lhs->lhs_varlen = var_end - var_start;\n    lhs->lhs_varlen_total = lhs->lhs_varlen;\n    lhs->lhs_name = vim_strnsave(var_start, lhs->lhs_varlen);\n    if (lhs->lhs_name == NULL)\n\treturn FAIL;\n\n    if (lhs->lhs_dest_end > var_start + lhs->lhs_varlen)\n\t// Something follows after the variable: \"var[idx]\" or \"var.key\".\n\tlhs->lhs_has_index = TRUE;\n\n    if (heredoc)\n\tlhs->lhs_type = &t_list_string;\n    else\n\tlhs->lhs_type = &t_any;\n\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n\tint\t    declare_error = FALSE;\n\n\tif (get_var_dest(lhs->lhs_name, &lhs->lhs_dest, cmdidx,\n\t\t\t\t      &lhs->lhs_opt_flags, &lhs->lhs_vimvaridx,\n\t\t\t\t\t\t &lhs->lhs_type, cctx) == FAIL)\n\t    return FAIL;\n\tif (lhs->lhs_dest != dest_local\n\t\t\t\t && cmdidx != CMD_const && cmdidx != CMD_final)\n\t{\n\t    // Specific kind of variable recognized.\n\t    declare_error = is_decl;\n\t}\n\telse\n\t{\n\t    // No specific kind of variable recognized, just a name.\n\t    if (check_reserved_name(lhs->lhs_name) == FAIL)\n\t\treturn FAIL;\n\n\t    if (lookup_local(var_start, lhs->lhs_varlen,\n\t\t\t\t\t     &lhs->lhs_local_lvar, cctx) == OK)\n\t\tlhs->lhs_lvar = &lhs->lhs_local_lvar;\n\t    else\n\t    {\n\t\tCLEAR_FIELD(lhs->lhs_arg_lvar);\n\t\tif (arg_exists(var_start, lhs->lhs_varlen,\n\t\t\t &lhs->lhs_arg_lvar.lv_idx, &lhs->lhs_arg_lvar.lv_type,\n\t\t\t    &lhs->lhs_arg_lvar.lv_from_outer, cctx) == OK)\n\t\t{\n\t\t    if (is_decl)\n\t\t    {\n\t\t\tsemsg(_(e_str_is_used_as_argument), lhs->lhs_name);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    lhs->lhs_lvar = &lhs->lhs_arg_lvar;\n\t\t}\n\t    }\n\t    if (lhs->lhs_lvar != NULL)\n\t    {\n\t\tif (is_decl)\n\t\t{\n\t\t    semsg(_(e_variable_already_declared), lhs->lhs_name);\n\t\t    return FAIL;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tint script_namespace = lhs->lhs_varlen > 1\n\t\t\t\t       && STRNCMP(var_start, \"s:\", 2) == 0;\n\t\tint script_var = (script_namespace\n\t\t\t? script_var_exists(var_start + 2, lhs->lhs_varlen - 2,\n\t\t\t\t\t\t\t\t    cctx, NULL)\n\t\t\t  : script_var_exists(var_start, lhs->lhs_varlen,\n\t\t\t\t\t\t\t    cctx, NULL)) == OK;\n\t\timported_T  *import =\n\t\t\t      find_imported(var_start, lhs->lhs_varlen, FALSE);\n\n\t\tif (script_namespace || script_var || import != NULL)\n\t\t{\n\t\t    char_u\t*rawname = lhs->lhs_name\n\t\t\t\t\t   + (lhs->lhs_name[1] == ':' ? 2 : 0);\n\n\t\t    if (script_namespace && current_script_is_vim9())\n\t\t    {\n\t\t\tsemsg(_(e_cannot_use_s_colon_in_vim9_script_str),\n\t\t\t\t\t\t\t\t    var_start);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    if (is_decl)\n\t\t    {\n\t\t\tif (script_namespace)\n\t\t\t    semsg(_(e_cannot_declare_script_variable_in_function_str),\n\t\t\t\t\t\t\t\tlhs->lhs_name);\n\t\t\telse\n\t\t\t    semsg(_(e_variable_already_declared_in_script_str),\n\t\t\t\t\t\t\t\tlhs->lhs_name);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    else if (cctx->ctx_ufunc->uf_script_ctx_version\n\t\t\t\t\t\t\t == SCRIPT_VERSION_VIM9\n\t\t\t\t    && script_namespace\n\t\t\t\t    && !script_var && import == NULL)\n\t\t    {\n\t\t\tsemsg(_(e_unknown_variable_str), lhs->lhs_name);\n\t\t\treturn FAIL;\n\t\t    }\n\n\t\t    lhs->lhs_dest = dest_script;\n\n\t\t    // existing script-local variables should have a type\n\t\t    lhs->lhs_scriptvar_sid = current_sctx.sc_sid;\n\t\t    if (import != NULL)\n\t\t    {\n\t\t\tchar_u\t*dot = vim_strchr(var_start, '.');\n\t\t\tchar_u\t*p;\n\n\t\t\t// for an import the name is what comes after the dot\n\t\t\tif (dot == NULL)\n\t\t\t{\n\t\t\t    semsg(_(e_no_dot_after_imported_name_str),\n\t\t\t\t\t\t\t\t    var_start);\n\t\t\t    return FAIL;\n\t\t\t}\n\t\t\tp = skipwhite(dot + 1);\n\t\t\tvar_end = to_name_end(p, TRUE);\n\t\t\tif (var_end == p)\n\t\t\t{\n\t\t\t    semsg(_(e_missing_name_after_imported_name_str),\n\t\t\t\t\t\t\t\t    var_start);\n\t\t\t    return FAIL;\n\t\t\t}\n\t\t\tvim_free(lhs->lhs_name);\n\t\t\tlhs->lhs_varlen = var_end - p;\n\t\t\tlhs->lhs_name = vim_strnsave(p, lhs->lhs_varlen);\n\t\t\tif (lhs->lhs_name == NULL)\n\t\t\t    return FAIL;\n\t\t\trawname = lhs->lhs_name;\n\t\t\tlhs->lhs_scriptvar_sid = import->imp_sid;\n\t\t\t// TODO: where do we check this name is exported?\n\n\t\t\t// Check if something follows: \"exp.var[idx]\" or\n\t\t\t// \"exp.var.key\".\n\t\t\tlhs->lhs_has_index = lhs->lhs_dest_end\n\t\t\t\t\t\t\t  > skipwhite(var_end);\n\t\t    }\n\t\t    if (SCRIPT_ID_VALID(lhs->lhs_scriptvar_sid))\n\t\t    {\n\t\t\t// Check writable only when no index follows.\n\t\t\tlhs->lhs_scriptvar_idx = get_script_item_idx(\n\t\t\t\t\t       lhs->lhs_scriptvar_sid, rawname,\n\t\t\t      lhs->lhs_has_index ? ASSIGN_FINAL : ASSIGN_CONST,\n\t\t\t\t\t\t\t\t   cctx, NULL);\n\t\t\tif (lhs->lhs_scriptvar_idx >= 0)\n\t\t\t{\n\t\t\t    scriptitem_T *si = SCRIPT_ITEM(\n\t\t\t\t\t\t       lhs->lhs_scriptvar_sid);\n\t\t\t    svar_T\t *sv =\n\t\t\t\t\t    ((svar_T *)si->sn_var_vals.ga_data)\n\t\t\t\t\t\t      + lhs->lhs_scriptvar_idx;\n\t\t\t    lhs->lhs_type = sv->sv_type;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse if (check_defined(var_start, lhs->lhs_varlen, cctx,\n\t\t\t\t\t\t\t  NULL, FALSE) == FAIL)\n\t\t    return FAIL;\n\t    }\n\t}\n\n\tif (declare_error)\n\t{\n\t    vim9_declare_error(lhs->lhs_name);\n\t    return FAIL;\n\t}\n    }\n\n    // handle \"a:name\" as a name, not index \"name\" in \"a\"\n    if (lhs->lhs_varlen > 1 || var_start[lhs->lhs_varlen] != ':')\n\tvar_end = lhs->lhs_dest_end;\n\n    if (lhs->lhs_dest != dest_option && lhs->lhs_dest != dest_func_option)\n    {\n\tif (is_decl && *var_end == ':')\n\t{\n\t    char_u *p;\n\n\t    // parse optional type: \"let var: type = expr\"\n\t    if (!VIM_ISWHITE(var_end[1]))\n\t    {\n\t\tsemsg(_(e_white_space_required_after_str_str), \":\", var_end);\n\t\treturn FAIL;\n\t    }\n\t    p = skipwhite(var_end + 1);\n\t    lhs->lhs_type = parse_type(&p, cctx->ctx_type_list, TRUE);\n\t    if (lhs->lhs_type == NULL)\n\t\treturn FAIL;\n\t    lhs->lhs_has_type = TRUE;\n\t    lhs->lhs_end = p;\n\t}\n\telse if (lhs->lhs_lvar != NULL)\n\t    lhs->lhs_type = lhs->lhs_lvar->lv_type;\n    }\n\n    if (oplen == 3 && !heredoc\n\t\t   && lhs->lhs_dest != dest_global\n\t\t   && !lhs->lhs_has_index\n\t\t   && lhs->lhs_type->tt_type != VAR_STRING\n\t\t   && lhs->lhs_type->tt_type != VAR_ANY)\n    {\n\temsg(_(e_can_only_concatenate_to_string));\n\treturn FAIL;\n    }\n\n    if (lhs->lhs_lvar == NULL && lhs->lhs_dest == dest_local\n\t\t\t\t\t\t && cctx->ctx_skip != SKIP_YES)\n    {\n\tif (oplen > 1 && !heredoc)\n\t{\n\t    // +=, /=, etc. require an existing variable\n\t    semsg(_(e_cannot_use_operator_on_new_variable), lhs->lhs_name);\n\t    return FAIL;\n\t}\n\tif (!is_decl || (lhs->lhs_has_index && !has_cmd\n\t\t\t\t\t\t&& cctx->ctx_skip != SKIP_YES))\n\t{\n\t    semsg(_(e_unknown_variable_str), lhs->lhs_name);\n\t    return FAIL;\n\t}\n\n\t// Check the name is valid for a funcref.\n\tif ((lhs->lhs_type->tt_type == VAR_FUNC\n\t\t\t\t      || lhs->lhs_type->tt_type == VAR_PARTIAL)\n\t\t&& var_wrong_func_name(lhs->lhs_name, TRUE))\n\t    return FAIL;\n\n\t// New local variable.\n\tlhs->lhs_lvar = reserve_local(cctx, var_start, lhs->lhs_varlen,\n\t\t    cmdidx == CMD_final || cmdidx == CMD_const, lhs->lhs_type);\n\tif (lhs->lhs_lvar == NULL)\n\t    return FAIL;\n\tlhs->lhs_new_local = TRUE;\n    }\n\n    lhs->lhs_member_type = lhs->lhs_type;\n    if (lhs->lhs_has_index)\n    {\n\tchar_u\t*after = var_start + lhs->lhs_varlen;\n\tchar_u\t*p;\n\n\t// Something follows after the variable: \"var[idx]\" or \"var.key\".\n\tif (is_decl && cctx->ctx_skip != SKIP_YES)\n\t{\n\t    if (has_cmd)\n\t\temsg(_(e_cannot_use_index_when_declaring_variable));\n\t    else\n\t\tsemsg(_(e_unknown_variable_str), lhs->lhs_name);\n\t    return FAIL;\n\t}\n\n\t// Now: var_start[lhs->lhs_varlen] is '[' or '.'\n\t// Only the last index is used below, if there are others\n\t// before it generate code for the expression.  Thus for\n\t// \"ll[1][2]\" the expression is \"ll[1]\" and \"[2]\" is the index.\n\tfor (;;)\n\t{\n\t    p = skip_index(after);\n\t    if (*p != '[' && *p != '.')\n\t    {\n\t\tlhs->lhs_varlen_total = p - var_start;\n\t\tbreak;\n\t    }\n\t    after = p;\n\t}\n\tif (after > var_start + lhs->lhs_varlen)\n\t{\n\t    lhs->lhs_varlen = after - var_start;\n\t    lhs->lhs_dest = dest_expr;\n\t    // We don't know the type before evaluating the expression,\n\t    // use \"any\" until then.\n\t    lhs->lhs_type = &t_any;\n\t}\n\n\tif (lhs->lhs_type->tt_member == NULL)\n\t    lhs->lhs_member_type = &t_any;\n\telse\n\t    lhs->lhs_member_type = lhs->lhs_type->tt_member;\n    }\n    return OK;\n}\n\n/*\n * Figure out the LHS and check a few errors.\n */\n    int\ncompile_assign_lhs(\n\tchar_u\t    *var_start,\n\tlhs_T\t    *lhs,\n\tcmdidx_T    cmdidx,\n\tint\t    is_decl,\n\tint\t    heredoc,\n\tint\t    has_cmd,\t    // \"var\" before \"var_start\"\n\tint\t    oplen,\n\tcctx_T\t    *cctx)\n{\n    if (compile_lhs(var_start, lhs, cmdidx, heredoc, has_cmd, oplen, cctx)\n\t\t\t\t\t\t\t\t       == FAIL)\n\treturn FAIL;\n\n    if (!lhs->lhs_has_index && lhs->lhs_lvar == &lhs->lhs_arg_lvar)\n    {\n\tsemsg(_(e_cannot_assign_to_argument), lhs->lhs_name);\n\treturn FAIL;\n    }\n    if (!is_decl && lhs->lhs_lvar != NULL\n\t\t\t   && lhs->lhs_lvar->lv_const && !lhs->lhs_has_index)\n    {\n\tsemsg(_(e_cannot_assign_to_constant), lhs->lhs_name);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Return TRUE if \"lhs\" has a range index: \"[expr : expr]\".\n */\n    static int\nhas_list_index(char_u *idx_start, cctx_T *cctx)\n{\n    char_u  *p = idx_start;\n    int\t    save_skip;\n\n    if (*p != '[')\n\treturn FALSE;\n\n    p = skipwhite(p + 1);\n    if (*p == ':')\n\treturn TRUE;\n\n    save_skip = cctx->ctx_skip;\n    cctx->ctx_skip = SKIP_YES;\n    (void)compile_expr0(&p, cctx);\n    cctx->ctx_skip = save_skip;\n    return *skipwhite(p) == ':';\n}\n\n/*\n * For an assignment with an index, compile the \"idx\" in \"var[idx]\" or \"key\" in\n * \"var.key\".\n */\n    static int\ncompile_assign_index(\n\tchar_u\t*var_start,\n\tlhs_T\t*lhs,\n\tint\t*range,\n\tcctx_T\t*cctx)\n{\n    size_t\tvarlen = lhs->lhs_varlen;\n    char_u\t*p;\n    int\t\tr = OK;\n    int\t\tneed_white_before = TRUE;\n    int\t\tempty_second;\n\n    p = var_start + varlen;\n    if (*p == '[')\n    {\n\tp = skipwhite(p + 1);\n\tif (*p == ':')\n\t{\n\t    // empty first index, push zero\n\t    r = generate_PUSHNR(cctx, 0);\n\t    need_white_before = FALSE;\n\t}\n\telse\n\t    r = compile_expr0(&p, cctx);\n\n\tif (r == OK && *skipwhite(p) == ':')\n\t{\n\t    // unlet var[idx : idx]\n\t    // blob[idx : idx] = value\n\t    *range = TRUE;\n\t    p = skipwhite(p);\n\t    empty_second = *skipwhite(p + 1) == ']';\n\t    if ((need_white_before && !IS_WHITE_OR_NUL(p[-1]))\n\t\t    || (!empty_second && !IS_WHITE_OR_NUL(p[1])))\n\t    {\n\t\tsemsg(_(e_white_space_required_before_and_after_str_at_str),\n\t\t\t\t\t\t\t\t      \":\", p);\n\t\treturn FAIL;\n\t    }\n\t    p = skipwhite(p + 1);\n\t    if (*p == ']')\n\t\t// empty second index, push \"none\"\n\t\tr = generate_PUSHSPEC(cctx, VVAL_NONE);\n\t    else\n\t\tr = compile_expr0(&p, cctx);\n\t}\n\n\tif (r == OK && *skipwhite(p) != ']')\n\t{\n\t    // this should not happen\n\t    emsg(_(e_missing_closing_square_brace));\n\t    r = FAIL;\n\t}\n    }\n    else // if (*p == '.')\n    {\n\tchar_u *key_end = to_name_end(p + 1, TRUE);\n\tchar_u *key = vim_strnsave(p + 1, key_end - p - 1);\n\n\tr = generate_PUSHS(cctx, &key);\n    }\n    return r;\n}\n\n/*\n * For a LHS with an index, load the variable to be indexed.\n */\n    static int\ncompile_load_lhs(\n\tlhs_T\t*lhs,\n\tchar_u\t*var_start,\n\ttype_T\t*rhs_type,\n\tcctx_T\t*cctx)\n{\n    if (lhs->lhs_dest == dest_expr)\n    {\n\tsize_t\t    varlen = lhs->lhs_varlen;\n\tint\t    c = var_start[varlen];\n\tint\t    lines_len = cctx->ctx_ufunc->uf_lines.ga_len;\n\tchar_u\t    *p = var_start;\n\tint\t    res;\n\n\t// Evaluate \"ll[expr]\" of \"ll[expr][idx]\".  End the line with a NUL and\n\t// limit the lines array length to avoid skipping to a following line.\n\tvar_start[varlen] = NUL;\n\tcctx->ctx_ufunc->uf_lines.ga_len = cctx->ctx_lnum + 1;\n\tres = compile_expr0(&p, cctx);\n\tvar_start[varlen] = c;\n\tcctx->ctx_ufunc->uf_lines.ga_len = lines_len;\n\tif (res == FAIL || p != var_start + varlen)\n\t{\n\t    // this should not happen\n\t    if (res != FAIL)\n\t\temsg(_(e_missing_closing_square_brace));\n\t    return FAIL;\n\t}\n\n\tlhs->lhs_type = cctx->ctx_type_stack.ga_len == 0 ? &t_void\n\t\t\t\t\t\t  : get_type_on_stack(cctx, 0);\n\t// now we can properly check the type\n\tif (rhs_type != NULL && lhs->lhs_type->tt_member != NULL\n\t\t&& rhs_type != &t_void\n\t\t&& need_type(rhs_type, lhs->lhs_type->tt_member, -2, 0, cctx,\n\t\t\t\t\t\t\t FALSE, FALSE) == FAIL)\n\t    return FAIL;\n    }\n    else\n\tgenerate_loadvar(cctx, lhs->lhs_dest, lhs->lhs_name,\n\t\t\t\t\t\t lhs->lhs_lvar, lhs->lhs_type);\n    return OK;\n}\n\n/*\n * Produce code for loading \"lhs\" and also take care of an index.\n * Return OK/FAIL.\n */\n    int\ncompile_load_lhs_with_index(lhs_T *lhs, char_u *var_start, cctx_T *cctx)\n{\n    compile_load_lhs(lhs, var_start, NULL, cctx);\n\n    if (lhs->lhs_has_index)\n    {\n\tint range = FALSE;\n\n\t// Get member from list or dict.  First compile the\n\t// index value.\n\tif (compile_assign_index(var_start, lhs, &range, cctx) == FAIL)\n\t    return FAIL;\n\tif (range)\n\t{\n\t    semsg(_(e_cannot_use_range_with_assignment_operator_str),\n\t\t\t\t\t\t\t\t    var_start);\n\t    return FAIL;\n\t}\n\n\t// Get the member.\n\tif (compile_member(FALSE, NULL, cctx) == FAIL)\n\t    return FAIL;\n    }\n    return OK;\n}\n\n/*\n * Assignment to a list or dict member, or \":unlet\" for the item, using the\n * information in \"lhs\".\n * Returns OK or FAIL.\n */\n    int\ncompile_assign_unlet(\n\tchar_u\t*var_start,\n\tlhs_T\t*lhs,\n\tint\tis_assign,\n\ttype_T\t*rhs_type,\n\tcctx_T\t*cctx)\n{\n    vartype_T\tdest_type;\n    int\t\trange = FALSE;\n\n    if (compile_assign_index(var_start, lhs, &range, cctx) == FAIL)\n\treturn FAIL;\n    if (is_assign && range\n\t    && lhs->lhs_type->tt_type != VAR_LIST\n\t    && lhs->lhs_type != &t_blob\n\t    && lhs->lhs_type != &t_any)\n    {\n\tsemsg(_(e_cannot_use_range_with_assignment_str), var_start);\n\treturn FAIL;\n    }\n\n    if (lhs->lhs_type == &t_any)\n    {\n\t// Index on variable of unknown type: check at runtime.\n\tdest_type = VAR_ANY;\n    }\n    else\n    {\n\tdest_type = lhs->lhs_type->tt_type;\n\tif (dest_type == VAR_DICT && range)\n\t{\n\t    emsg(e_cannot_use_range_with_dictionary);\n\t    return FAIL;\n\t}\n\tif (dest_type == VAR_DICT\n\t\t\t      && may_generate_2STRING(-1, FALSE, cctx) == FAIL)\n\t    return FAIL;\n\tif (dest_type == VAR_LIST || dest_type == VAR_BLOB)\n\t{\n\t    type_T *type;\n\n\t    if (range)\n\t    {\n\t\ttype = get_type_on_stack(cctx, 1);\n\t\tif (need_type(type, &t_number,\n\t\t\t\t\t    -2, 0, cctx, FALSE, FALSE) == FAIL)\n\t\treturn FAIL;\n\t    }\n\t    type = get_type_on_stack(cctx, 0);\n\t    if ((dest_type != VAR_BLOB && type->tt_type != VAR_SPECIAL)\n\t\t    && need_type(type, &t_number,\n\t\t\t\t\t    -1, 0, cctx, FALSE, FALSE) == FAIL)\n\t\treturn FAIL;\n\t}\n    }\n\n    if (cctx->ctx_skip == SKIP_YES)\n\treturn OK;\n\n    // Load the dict or list.  On the stack we then have:\n    // - value (for assignment, not for :unlet)\n    // - index\n    // - for [a : b] second index\n    // - variable\n    if (compile_load_lhs(lhs, var_start, rhs_type, cctx) == FAIL)\n\treturn FAIL;\n\n    if (dest_type == VAR_LIST || dest_type == VAR_DICT\n\t\t\t      || dest_type == VAR_BLOB || dest_type == VAR_ANY)\n    {\n\tif (is_assign)\n\t{\n\t    if (range)\n\t    {\n\t\tif (generate_instr_drop(cctx, ISN_STORERANGE, 4) == NULL)\n\t\t    return FAIL;\n\t    }\n\t    else\n\t    {\n\t\tisn_T\t*isn = generate_instr_drop(cctx, ISN_STOREINDEX, 3);\n\n\t\tif (isn == NULL)\n\t\t    return FAIL;\n\t\tisn->isn_arg.vartype = dest_type;\n\t    }\n\t}\n\telse if (range)\n\t{\n\t    if (generate_instr_drop(cctx, ISN_UNLETRANGE, 3) == NULL)\n\t\treturn FAIL;\n\t}\n\telse\n\t{\n\t    if (generate_instr_drop(cctx, ISN_UNLETINDEX, 2) == NULL)\n\t\treturn FAIL;\n\t}\n    }\n    else\n    {\n\temsg(_(e_indexable_type_required));\n\treturn FAIL;\n    }\n\n    return OK;\n}\n\n/*\n * Compile declaration and assignment:\n * \"let name\"\n * \"var name = expr\"\n * \"final name = expr\"\n * \"const name = expr\"\n * \"name = expr\"\n * \"arg\" points to \"name\".\n * \"++arg\" and \"--arg\"\n * Return NULL for an error.\n * Return \"arg\" if it does not look like a variable list.\n */\n    static char_u *\ncompile_assignment(char_u *arg, exarg_T *eap, cmdidx_T cmdidx, cctx_T *cctx)\n{\n    char_u\t*var_start;\n    char_u\t*p;\n    char_u\t*end = arg;\n    char_u\t*ret = NULL;\n    int\t\tvar_count = 0;\n    int\t\tvar_idx;\n    int\t\tsemicolon = 0;\n    int\t\tdid_generate_slice = FALSE;\n    garray_T\t*instr = &cctx->ctx_instr;\n    char_u\t*op;\n    int\t\toplen = 0;\n    int\t\theredoc = FALSE;\n    int\t\tincdec = FALSE;\n    type_T\t*rhs_type = &t_any;\n    char_u\t*sp;\n    int\t\tis_decl = is_decl_command(cmdidx);\n    lhs_T\tlhs;\n    long\tstart_lnum = SOURCING_LNUM;\n\n    // Skip over the \"varname\" or \"[varname, varname]\" to get to any \"=\".\n    p = skip_var_list(arg, TRUE, &var_count, &semicolon, TRUE);\n    if (p == NULL)\n\treturn *arg == '[' ? arg : NULL;\n\n    lhs.lhs_name = NULL;\n\n    if (eap->cmdidx == CMD_increment || eap->cmdidx == CMD_decrement)\n    {\n\tif (VIM_ISWHITE(eap->cmd[2]))\n\t{\n\t    semsg(_(e_no_white_space_allowed_after_str_str),\n\t\t\t eap->cmdidx == CMD_increment ? \"++\" : \"--\", eap->cmd);\n\t    return NULL;\n\t}\n\top = (char_u *)(eap->cmdidx == CMD_increment ? \"+=\" : \"-=\");\n\toplen = 2;\n\tincdec = TRUE;\n    }\n    else\n    {\n\tsp = p;\n\tp = skipwhite(p);\n\top = p;\n\toplen = assignment_len(p, &heredoc);\n\n\tif (var_count > 0 && oplen == 0)\n\t    // can be something like \"[1, 2]->func()\"\n\t    return arg;\n\n\tif (oplen > 0 && (!VIM_ISWHITE(*sp) || !IS_WHITE_OR_NUL(op[oplen])))\n\t{\n\t    error_white_both(op, oplen);\n\t    return NULL;\n\t}\n    }\n\n    if (heredoc)\n    {\n\tlist_T\t   *l;\n\n\t// [let] varname =<< [trim] {end}\n\teap->getline = exarg_getline;\n\teap->cookie = cctx;\n\tl = heredoc_get(eap, op + 3, FALSE, TRUE);\n\tif (l == NULL)\n\t    return NULL;\n\n\tlist_free(l);\n\tp += STRLEN(p);\n\tend = p;\n    }\n    else if (var_count > 0)\n    {\n\tchar_u *wp;\n\n\t// for \"[var, var] = expr\" evaluate the expression here, loop over the\n\t// list of variables below.\n\t// A line break may follow the \"=\".\n\n\twp = op + oplen;\n\tif (may_get_next_line_error(wp, &p, cctx) == FAIL)\n\t    return FAIL;\n\tif (compile_expr0(&p, cctx) == FAIL)\n\t    return NULL;\n\tend = p;\n\n\tif (cctx->ctx_skip != SKIP_YES)\n\t{\n\t    type_T\t*stacktype;\n\t    int\t\tneeded_list_len;\n\t    int\t\tdid_check = FALSE;\n\n\t    stacktype = cctx->ctx_type_stack.ga_len == 0 ? &t_void\n\t\t\t\t\t\t  : get_type_on_stack(cctx, 0);\n\t    if (stacktype->tt_type == VAR_VOID)\n\t    {\n\t\temsg(_(e_cannot_use_void_value));\n\t\tgoto theend;\n\t    }\n\t    if (need_type(stacktype, &t_list_any, -1, 0, cctx,\n\t\t\t\t\t\t\t FALSE, FALSE) == FAIL)\n\t\tgoto theend;\n\t    // If a constant list was used we can check the length right here.\n\t    needed_list_len = semicolon ? var_count - 1 : var_count;\n\t    if (instr->ga_len > 0)\n\t    {\n\t\tisn_T\t*isn = ((isn_T *)instr->ga_data) + instr->ga_len - 1;\n\n\t\tif (isn->isn_type == ISN_NEWLIST)\n\t\t{\n\t\t    did_check = TRUE;\n\t\t    if (semicolon ? isn->isn_arg.number < needed_list_len\n\t\t\t    : isn->isn_arg.number != needed_list_len)\n\t\t    {\n\t\t\tsemsg(_(e_expected_nr_items_but_got_nr),\n\t\t\t\t    needed_list_len, (int)isn->isn_arg.number);\n\t\t\tgoto theend;\n\t\t    }\n\t\t}\n\t    }\n\t    if (!did_check)\n\t\tgenerate_CHECKLEN(cctx, needed_list_len, semicolon);\n\t    if (stacktype->tt_member != NULL)\n\t\trhs_type = stacktype->tt_member;\n\t}\n    }\n\n    /*\n     * Loop over variables in \"[var, var] = expr\".\n     * For \"var = expr\" and \"let var: type\" this is done only once.\n     */\n    if (var_count > 0)\n\tvar_start = skipwhite(arg + 1);  // skip over the \"[\"\n    else\n\tvar_start = arg;\n    for (var_idx = 0; var_idx == 0 || var_idx < var_count; var_idx++)\n    {\n\tint\tinstr_count = -1;\n\tint\tsave_lnum;\n\tint\tskip_store = FALSE;\n\ttype_T\t*inferred_type = NULL;\n\n\tif (var_start[0] == '_' && !eval_isnamec(var_start[1]))\n\t{\n\t    // Ignore underscore in \"[a, _, b] = list\".\n\t    if (var_count > 0)\n\t    {\n\t\tvar_start = skipwhite(var_start + 2);\n\t\tcontinue;\n\t    }\n\t    emsg(_(e_cannot_use_underscore_here));\n\t    goto theend;\n\t}\n\tvim_free(lhs.lhs_name);\n\n\t/*\n\t * Figure out the LHS type and other properties.\n\t */\n\tif (compile_assign_lhs(var_start, &lhs, cmdidx,\n\t\t\t\tis_decl, heredoc, var_start > eap->cmd,\n\t\t\t\toplen, cctx) == FAIL)\n\t    goto theend;\n\tif (heredoc)\n\t{\n\t    SOURCING_LNUM = start_lnum;\n\t    if (lhs.lhs_has_type\n\t\t    && need_type(&t_list_string, lhs.lhs_type,\n\t\t\t\t\t    -1, 0, cctx, FALSE, FALSE) == FAIL)\n\t\tgoto theend;\n\t}\n\telse\n\t{\n\t    if (cctx->ctx_skip == SKIP_YES)\n\t    {\n\t\tif (oplen > 0 && var_count == 0)\n\t\t{\n\t\t    // skip over the \"=\" and the expression\n\t\t    p = skipwhite(op + oplen);\n\t\t    (void)compile_expr0(&p, cctx);\n\t\t}\n\t    }\n\t    else if (oplen > 0)\n\t    {\n\t\tint\tis_const = FALSE;\n\t\tchar_u\t*wp;\n\n\t\t// for \"+=\", \"*=\", \"..=\" etc. first load the current value\n\t\tif (*op != '='\n\t\t\t&& compile_load_lhs_with_index(&lhs, var_start,\n\t\t\t\t\t\t\t\t cctx) == FAIL)\n\t\t    goto theend;\n\n\t\t// For \"var = expr\" evaluate the expression.\n\t\tif (var_count == 0)\n\t\t{\n\t\t    int\tr;\n\n\t\t    // Compile the expression.\n\t\t    instr_count = instr->ga_len;\n\t\t    if (incdec)\n\t\t    {\n\t\t\tr = generate_PUSHNR(cctx, 1);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Temporarily hide the new local variable here, it is\n\t\t\t// not available to this expression.\n\t\t\tif (lhs.lhs_new_local)\n\t\t\t    --cctx->ctx_locals.ga_len;\n\t\t\twp = op + oplen;\n\t\t\tif (may_get_next_line_error(wp, &p, cctx) == FAIL)\n\t\t\t{\n\t\t\t    if (lhs.lhs_new_local)\n\t\t\t\t++cctx->ctx_locals.ga_len;\n\t\t\t    goto theend;\n\t\t\t}\n\t\t\tr = compile_expr0_ext(&p, cctx, &is_const);\n\t\t\tif (lhs.lhs_new_local)\n\t\t\t    ++cctx->ctx_locals.ga_len;\n\t\t\tif (r == FAIL)\n\t\t\t    goto theend;\n\t\t    }\n\t\t}\n\t\telse if (semicolon && var_idx == var_count - 1)\n\t\t{\n\t\t    // For \"[var; var] = expr\" get the rest of the list\n\t\t    did_generate_slice = TRUE;\n\t\t    if (generate_SLICE(cctx, var_count - 1) == FAIL)\n\t\t\tgoto theend;\n\t\t}\n\t\telse\n\t\t{\n\t\t    // For \"[var, var] = expr\" get the \"var_idx\" item from the\n\t\t    // list.\n\t\t    if (generate_GETITEM(cctx, var_idx, *op != '=') == FAIL)\n\t\t\tgoto theend;\n\t\t}\n\n\t\trhs_type = cctx->ctx_type_stack.ga_len == 0 ? &t_void\n\t\t\t\t\t\t  : get_type_on_stack(cctx, 0);\n\t\tif (lhs.lhs_lvar != NULL && (is_decl || !lhs.lhs_has_type))\n\t\t{\n\t\t    if ((rhs_type->tt_type == VAR_FUNC\n\t\t\t\t|| rhs_type->tt_type == VAR_PARTIAL)\n\t\t\t    && !lhs.lhs_has_index\n\t\t\t    && var_wrong_func_name(lhs.lhs_name, TRUE))\n\t\t\tgoto theend;\n\n\t\t    if (lhs.lhs_new_local && !lhs.lhs_has_type)\n\t\t    {\n\t\t\tif (rhs_type->tt_type == VAR_VOID)\n\t\t\t{\n\t\t\t    emsg(_(e_cannot_use_void_value));\n\t\t\t    goto theend;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // An empty list or dict has a &t_unknown member,\n\t\t\t    // for a variable that implies &t_any.\n\t\t\t    if (rhs_type == &t_list_empty)\n\t\t\t\tlhs.lhs_lvar->lv_type = &t_list_any;\n\t\t\t    else if (rhs_type == &t_dict_empty)\n\t\t\t\tlhs.lhs_lvar->lv_type = &t_dict_any;\n\t\t\t    else if (rhs_type == &t_unknown)\n\t\t\t\tlhs.lhs_lvar->lv_type = &t_any;\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tlhs.lhs_lvar->lv_type = rhs_type;\n\t\t\t\tinferred_type = rhs_type;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    else if (*op == '=')\n\t\t    {\n\t\t\ttype_T *use_type = lhs.lhs_lvar->lv_type;\n\t\t\twhere_T where = WHERE_INIT;\n\n\t\t\t// Without operator check type here, otherwise below.\n\t\t\t// Use the line number of the assignment.\n\t\t\tSOURCING_LNUM = start_lnum;\n\t\t\twhere.wt_index = var_count > 0 ? var_idx + 1 : 0;\n\t\t\twhere.wt_variable = var_count > 0;\n\t\t\t// If assigning to a list or dict member, use the\n\t\t\t// member type.  Not for \"list[:] =\".\n\t\t\tif (lhs.lhs_has_index\n\t\t\t\t&& !has_list_index(var_start + lhs.lhs_varlen,\n\t\t\t\t\t\t\t\t\t cctx))\n\t\t\t    use_type = lhs.lhs_member_type;\n\t\t\tif (need_type_where(rhs_type, use_type, -1, where,\n\t\t\t\t\t\tcctx, FALSE, is_const) == FAIL)\n\t\t\t    goto theend;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    type_T *lhs_type = lhs.lhs_member_type;\n\n\t\t    // Special case: assigning to @# can use a number or a\n\t\t    // string.\n\t\t    // Also: can assign a number to a float.\n\t\t    if ((lhs_type == &t_number_or_string\n\t\t\t\t|| lhs_type == &t_float)\n\t\t\t    && rhs_type->tt_type == VAR_NUMBER)\n\t\t\tlhs_type = &t_number;\n\t\t    if (*p != '=' && need_type(rhs_type, lhs_type,\n\t\t\t\t\t    -1, 0, cctx, FALSE, FALSE) == FAIL)\n\t\t    goto theend;\n\t\t}\n\t    }\n\t    else if (cmdidx == CMD_final)\n\t    {\n\t\temsg(_(e_final_requires_a_value));\n\t\tgoto theend;\n\t    }\n\t    else if (cmdidx == CMD_const)\n\t    {\n\t\temsg(_(e_const_requires_a_value));\n\t\tgoto theend;\n\t    }\n\t    else if (!lhs.lhs_has_type || lhs.lhs_dest == dest_option\n\t\t\t\t\t   || lhs.lhs_dest == dest_func_option)\n\t    {\n\t\temsg(_(e_type_or_initialization_required));\n\t\tgoto theend;\n\t    }\n\t    else\n\t    {\n\t\tint r = OK;\n\n\t\t// variables are always initialized\n\t\tif (GA_GROW_FAILS(instr, 1))\n\t\t    goto theend;\n\t\tswitch (lhs.lhs_member_type->tt_type)\n\t\t{\n\t\t    case VAR_BOOL:\n\t\t\tr = generate_PUSHBOOL(cctx, VVAL_FALSE);\n\t\t\tbreak;\n\t\t    case VAR_FLOAT:\n#ifdef FEAT_FLOAT\n\t\t\tr = generate_PUSHF(cctx, 0.0);\n#endif\n\t\t\tbreak;\n\t\t    case VAR_STRING:\n\t\t\tr = generate_PUSHS(cctx, NULL);\n\t\t\tbreak;\n\t\t    case VAR_BLOB:\n\t\t\tr = generate_PUSHBLOB(cctx, blob_alloc());\n\t\t\tbreak;\n\t\t    case VAR_FUNC:\n\t\t\tr = generate_PUSHFUNC(cctx, NULL, &t_func_void);\n\t\t\tbreak;\n\t\t    case VAR_LIST:\n\t\t\tr = generate_NEWLIST(cctx, 0, FALSE);\n\t\t\tbreak;\n\t\t    case VAR_DICT:\n\t\t\tr = generate_NEWDICT(cctx, 0, FALSE);\n\t\t\tbreak;\n\t\t    case VAR_JOB:\n\t\t\tr = generate_PUSHJOB(cctx);\n\t\t\tbreak;\n\t\t    case VAR_CHANNEL:\n\t\t\tr = generate_PUSHCHANNEL(cctx);\n\t\t\tbreak;\n\t\t    case VAR_NUMBER:\n\t\t    case VAR_UNKNOWN:\n\t\t    case VAR_ANY:\n\t\t    case VAR_PARTIAL:\n\t\t    case VAR_VOID:\n\t\t    case VAR_INSTR:\n\t\t    case VAR_SPECIAL:  // cannot happen\n\t\t\t// This is skipped for local variables, they are always\n\t\t\t// initialized to zero.  But in a \"for\" or \"while\" loop\n\t\t\t// the value may have been changed.\n\t\t\tif (lhs.lhs_dest == dest_local\n\t\t\t\t\t\t   && !inside_loop_scope(cctx))\n\t\t\t    skip_store = TRUE;\n\t\t\telse\n\t\t\t{\n\t\t\t    instr_count = instr->ga_len;\n\t\t\t    r = generate_PUSHNR(cctx, 0);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (r == FAIL)\n\t\t    goto theend;\n\t    }\n\t    if (var_count == 0)\n\t\tend = p;\n\t}\n\n\t// no need to parse more when skipping\n\tif (cctx->ctx_skip == SKIP_YES)\n\t    break;\n\n\tif (oplen > 0 && *op != '=')\n\t{\n\t    type_T\t    *expected;\n\t    type_T\t    *stacktype = NULL;\n\n\t    if (*op == '.')\n\t    {\n\t\tif (may_generate_2STRING(-1, FALSE, cctx) == FAIL)\n\t\t    goto theend;\n\t    }\n\t    else\n\t    {\n\t\texpected = lhs.lhs_member_type;\n\t\tstacktype = get_type_on_stack(cctx, 0);\n\t\tif (\n#ifdef FEAT_FLOAT\n\t\t    // If variable is float operation with number is OK.\n\t\t    !(expected == &t_float && (stacktype == &t_number\n\t\t\t    || stacktype == &t_number_bool)) &&\n#endif\n\t\t    need_type(stacktype, expected, -1, 0, cctx,\n\t\t\t\t\t\t\t FALSE, FALSE) == FAIL)\n\t\t    goto theend;\n\t    }\n\n\t    if (*op == '.')\n\t    {\n\t\tif (generate_CONCAT(cctx, 2) == FAIL)\n\t\t    goto theend;\n\t    }\n\t    else if (*op == '+')\n\t    {\n\t\tif (generate_add_instr(cctx,\n\t\t\t    operator_type(lhs.lhs_member_type, stacktype),\n\t\t\t\t       lhs.lhs_member_type, stacktype,\n\t\t\t\t\t\t\t  EXPR_APPEND) == FAIL)\n\t\t    goto theend;\n\t    }\n\t    else if (generate_two_op(cctx, op) == FAIL)\n\t\tgoto theend;\n\t}\n\n\t// Use the line number of the assignment for store instruction.\n\tsave_lnum = cctx->ctx_lnum;\n\tcctx->ctx_lnum = start_lnum - 1;\n\n\tif (lhs.lhs_has_index)\n\t{\n\t    // Use the info in \"lhs\" to store the value at the index in the\n\t    // list or dict.\n\t    if (compile_assign_unlet(var_start, &lhs, TRUE, rhs_type, cctx)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t    {\n\t\tcctx->ctx_lnum = save_lnum;\n\t\tgoto theend;\n\t    }\n\t}\n\telse\n\t{\n\t    if (is_decl && cmdidx == CMD_const && (lhs.lhs_dest == dest_script\n\t\t\t\t\t\t|| lhs.lhs_dest == dest_global\n\t\t\t\t\t\t|| lhs.lhs_dest == dest_local))\n\t\t// \":const var\": lock the value, but not referenced variables\n\t\tgenerate_LOCKCONST(cctx);\n\n\t    if ((lhs.lhs_type->tt_type == VAR_DICT\n\t\t\t\t\t  || lhs.lhs_type->tt_type == VAR_LIST)\n\t\t    && lhs.lhs_type->tt_member != NULL\n\t\t    && lhs.lhs_type->tt_member != &t_any\n\t\t    && lhs.lhs_type->tt_member != &t_unknown)\n\t\t// Set the type in the list or dict, so that it can be checked,\n\t\t// also in legacy script.\n\t\tgenerate_SETTYPE(cctx, lhs.lhs_type);\n\t    else if (inferred_type != NULL\n\t\t    && (inferred_type->tt_type == VAR_DICT\n\t\t\t\t\t|| inferred_type->tt_type == VAR_LIST)\n\t\t    && inferred_type->tt_member != NULL\n\t\t    && inferred_type->tt_member != &t_unknown\n\t\t    && inferred_type->tt_member != &t_any)\n\t\t// Set the type in the list or dict, so that it can be checked,\n\t\t// also in legacy script.\n\t\tgenerate_SETTYPE(cctx, inferred_type);\n\n\t    if (!skip_store && generate_store_lhs(cctx, &lhs,\n\t\t\t\t\t\t instr_count, is_decl) == FAIL)\n\t    {\n\t\tcctx->ctx_lnum = save_lnum;\n\t\tgoto theend;\n\t    }\n\t}\n\tcctx->ctx_lnum = save_lnum;\n\n\tif (var_idx + 1 < var_count)\n\t    var_start = skipwhite(lhs.lhs_end + 1);\n    }\n\n    // For \"[var, var] = expr\" drop the \"expr\" value.\n    // Also for \"[var, var; _] = expr\".\n    if (var_count > 0 && (!semicolon || !did_generate_slice))\n    {\n\tif (generate_instr_drop(cctx, ISN_DROP, 1) == NULL)\n\t    goto theend;\n    }\n\n    ret = skipwhite(end);\n\ntheend:\n    vim_free(lhs.lhs_name);\n    return ret;\n}\n\n/*\n * Check for an assignment at \"eap->cmd\", compile it if found.\n * Return NOTDONE if there is none, FAIL for failure, OK if done.\n */\n    static int\nmay_compile_assignment(exarg_T *eap, char_u **line, cctx_T *cctx)\n{\n    char_u  *pskip;\n    char_u  *p;\n\n    // Assuming the command starts with a variable or function name,\n    // find what follows.\n    // Skip over \"var.member\", \"var[idx]\" and the like.\n    // Also \"&opt = val\", \"$ENV = val\" and \"@r = val\".\n    pskip = (*eap->cmd == '&' || *eap->cmd == '$' || *eap->cmd == '@')\n\t\t\t\t\t\t ? eap->cmd + 1 : eap->cmd;\n    p = to_name_end(pskip, TRUE);\n    if (p > eap->cmd && *p != NUL)\n    {\n\tchar_u *var_end;\n\tint\toplen;\n\tint\theredoc;\n\n\tif (eap->cmd[0] == '@')\n\t    var_end = eap->cmd + 2;\n\telse\n\t    var_end = find_name_end(pskip, NULL, NULL,\n\t\t\t\t\tFNE_CHECK_START | FNE_INCL_BR);\n\toplen = assignment_len(skipwhite(var_end), &heredoc);\n\tif (oplen > 0)\n\t{\n\t    size_t len = p - eap->cmd;\n\n\t    // Recognize an assignment if we recognize the variable\n\t    // name:\n\t    // \"&opt = expr\"\n\t    // \"$ENV = expr\"\n\t    // \"@r = expr\"\n\t    // \"g:var = expr\"\n\t    // \"g:[key] = expr\"\n\t    // \"local = expr\"  where \"local\" is a local var.\n\t    // \"script = expr\"  where \"script\" is a script-local var.\n\t    // \"import = expr\"  where \"import\" is an imported var\n\t    if (*eap->cmd == '&'\n\t\t    || *eap->cmd == '$'\n\t\t    || *eap->cmd == '@'\n\t\t    || ((len) > 2 && eap->cmd[1] == ':')\n\t\t    || STRNCMP(eap->cmd, \"g:[\", 3) == 0\n\t\t    || variable_exists(eap->cmd, len, cctx))\n\t    {\n\t\t*line = compile_assignment(eap->cmd, eap, CMD_SIZE, cctx);\n\t\tif (*line == NULL || *line == eap->cmd)\n\t\t    return FAIL;\n\t\treturn OK;\n\t    }\n\t}\n    }\n\n    if (*eap->cmd == '[')\n    {\n\t// might be \"[var, var] = expr\"\n\t*line = compile_assignment(eap->cmd, eap, CMD_SIZE, cctx);\n\tif (*line == NULL)\n\t    return FAIL;\n\tif (*line != eap->cmd)\n\t    return OK;\n    }\n    return NOTDONE;\n}\n\n/*\n * Check if arguments of \"ufunc\" shadow variables in \"cctx\".\n * Return OK or FAIL.\n */\n    static int\ncheck_args_shadowing(ufunc_T *ufunc, cctx_T *cctx)\n{\n    int\t    i;\n    char_u  *arg;\n    int\t    r = OK;\n\n    // Make sure arguments are not found when compiling a second time.\n    ufunc->uf_args_visible = 0;\n\n    // Check for arguments shadowing variables from the context.\n    for (i = 0; i < ufunc->uf_args.ga_len; ++i)\n    {\n\targ = ((char_u **)(ufunc->uf_args.ga_data))[i];\n\tif (check_defined(arg, STRLEN(arg), cctx, NULL, TRUE) == FAIL)\n\t{\n\t    r = FAIL;\n\t    break;\n\t}\n    }\n    ufunc->uf_args_visible = ufunc->uf_args.ga_len;\n    return r;\n}\n\n/*\n * Get the compilation type that should be used for \"ufunc\".\n * Keep in sync with INSTRUCTIONS().\n */\n    compiletype_T\nget_compile_type(ufunc_T *ufunc)\n{\n    // Update uf_has_breakpoint if needed.\n    update_has_breakpoint(ufunc);\n\n    if (debug_break_level > 0 || may_break_in_function(ufunc))\n\treturn CT_DEBUG;\n#ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n    {\n\tif (!ufunc->uf_profiling && has_profiling(FALSE, ufunc->uf_name, NULL))\n\t    func_do_profile(ufunc);\n\tif (ufunc->uf_profiling)\n\t    return CT_PROFILE;\n    }\n#endif\n    return CT_NONE;\n}\n\n\n/*\n * Add a function to the list of :def functions.\n * This sets \"ufunc->uf_dfunc_idx\" but the function isn't compiled yet.\n */\n    static int\nadd_def_function(ufunc_T *ufunc)\n{\n    dfunc_T *dfunc;\n\n    if (def_functions.ga_len == 0)\n    {\n\t// The first position is not used, so that a zero uf_dfunc_idx means it\n\t// wasn't set.\n\tif (GA_GROW_FAILS(&def_functions, 1))\n\t    return FAIL;\n\t++def_functions.ga_len;\n    }\n\n    // Add the function to \"def_functions\".\n    if (GA_GROW_FAILS(&def_functions, 1))\n\treturn FAIL;\n    dfunc = ((dfunc_T *)def_functions.ga_data) + def_functions.ga_len;\n    CLEAR_POINTER(dfunc);\n    dfunc->df_idx = def_functions.ga_len;\n    ufunc->uf_dfunc_idx = dfunc->df_idx;\n    dfunc->df_ufunc = ufunc;\n    dfunc->df_name = vim_strsave(ufunc->uf_name);\n    ga_init2(&dfunc->df_var_names, sizeof(char_u *), 10);\n    ++dfunc->df_refcount;\n    ++def_functions.ga_len;\n    return OK;\n}\n\n/*\n * After ex_function() has collected all the function lines: parse and compile\n * the lines into instructions.\n * Adds the function to \"def_functions\".\n * When \"check_return_type\" is set then set ufunc->uf_ret_type to the type of\n * the return statement (used for lambda).  When uf_ret_type is already set\n * then check that it matches.\n * When \"profiling\" is true add ISN_PROF_START instructions.\n * \"outer_cctx\" is set for a nested function.\n * This can be used recursively through compile_lambda(), which may reallocate\n * \"def_functions\".\n * Returns OK or FAIL.\n */\n    int\ncompile_def_function(\n\tufunc_T\t\t*ufunc,\n\tint\t\tcheck_return_type,\n\tcompiletype_T   compile_type,\n\tcctx_T\t\t*outer_cctx)\n{\n    char_u\t*line = NULL;\n    garray_T\tlines_to_free;\n    char_u\t*p;\n    char\t*errormsg = NULL;\t// error message\n    cctx_T\tcctx;\n    garray_T\t*instr;\n    int\t\tdid_emsg_before = did_emsg;\n    int\t\tdid_emsg_silent_before = did_emsg_silent;\n    int\t\tret = FAIL;\n    sctx_T\tsave_current_sctx = current_sctx;\n    int\t\tsave_estack_compiling = estack_compiling;\n    int\t\tsave_cmod_flags = cmdmod.cmod_flags;\n    int\t\tdo_estack_push;\n    int\t\tnew_def_function = FALSE;\n#ifdef FEAT_PROFILE\n    int\t\tprof_lnum = -1;\n#endif\n    int\t\tdebug_lnum = -1;\n\n    // allocated lines are freed at the end\n    ga_init2(&lines_to_free, sizeof(char_u *), 50);\n\n    // When using a function that was compiled before: Free old instructions.\n    // The index is reused.  Otherwise add a new entry in \"def_functions\".\n    if (ufunc->uf_dfunc_idx > 0)\n    {\n\tdfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\tisn_T\t*instr_dest = NULL;\n\n\tswitch (compile_type)\n\t{\n\t    case CT_PROFILE:\n#ifdef FEAT_PROFILE\n\t\t\t    instr_dest = dfunc->df_instr_prof; break;\n#endif\n\t    case CT_NONE:   instr_dest = dfunc->df_instr; break;\n\t    case CT_DEBUG:  instr_dest = dfunc->df_instr_debug; break;\n\t}\n\tif (instr_dest != NULL)\n\t    // Was compiled in this mode before: Free old instructions.\n\t    delete_def_function_contents(dfunc, FALSE);\n\tga_clear_strings(&dfunc->df_var_names);\n    }\n    else\n    {\n\tif (add_def_function(ufunc) == FAIL)\n\t    return FAIL;\n\tnew_def_function = TRUE;\n    }\n\n    if ((ufunc->uf_flags & FC_CLOSURE) && outer_cctx == NULL)\n    {\n\tsemsg(_(e_compiling_closure_without_context_str),\n\t\t\t\t\t\t   printable_func_name(ufunc));\n\treturn FAIL;\n    }\n\n    ufunc->uf_def_status = UF_COMPILING;\n\n    CLEAR_FIELD(cctx);\n\n    cctx.ctx_compile_type = compile_type;\n    cctx.ctx_ufunc = ufunc;\n    cctx.ctx_lnum = -1;\n    cctx.ctx_outer = outer_cctx;\n    ga_init2(&cctx.ctx_locals, sizeof(lvar_T), 10);\n    // Each entry on the type stack consists of two type pointers.\n    ga_init2(&cctx.ctx_type_stack, sizeof(type2_T), 50);\n    cctx.ctx_type_list = &ufunc->uf_type_list;\n    ga_init2(&cctx.ctx_instr, sizeof(isn_T), 50);\n    instr = &cctx.ctx_instr;\n\n    // Set the context to the function, it may be compiled when called from\n    // another script.  Set the script version to the most modern one.\n    // The line number will be set in next_line_from_context().\n    current_sctx = ufunc->uf_script_ctx;\n    current_sctx.sc_version = SCRIPT_VERSION_VIM9;\n\n    // Don't use the flag from \":legacy\" here.\n    cmdmod.cmod_flags &= ~CMOD_LEGACY;\n\n    // Make sure error messages are OK.\n    do_estack_push = !estack_top_is_ufunc(ufunc, 1);\n    if (do_estack_push)\n\testack_push_ufunc(ufunc, 1);\n    estack_compiling = TRUE;\n\n    if (check_args_shadowing(ufunc, &cctx) == FAIL)\n\tgoto erret;\n\n    if (ufunc->uf_def_args.ga_len > 0)\n    {\n\tint\tcount = ufunc->uf_def_args.ga_len;\n\tint\tfirst_def_arg = ufunc->uf_args.ga_len - count;\n\tint\ti;\n\tchar_u\t*arg;\n\tint\toff = STACK_FRAME_SIZE + (ufunc->uf_va_name != NULL ? 1 : 0);\n\tint\tdid_set_arg_type = FALSE;\n\n\t// Produce instructions for the default values of optional arguments.\n\tSOURCING_LNUM = 0;  // line number unknown\n\tfor (i = 0; i < count; ++i)\n\t{\n\t    type_T\t*val_type;\n\t    int\t\targ_idx = first_def_arg + i;\n\t    where_T\twhere = WHERE_INIT;\n\t    int\t\tr;\n\t    int\t\tjump_instr_idx = instr->ga_len;\n\t    isn_T\t*isn;\n\n\t    // Use a JUMP_IF_ARG_SET instruction to skip if the value was given.\n\t    if (generate_JUMP_IF_ARG_SET(&cctx, i - count - off) == FAIL)\n\t\tgoto erret;\n\n\t    // Make sure later arguments are not found.\n\t    ufunc->uf_args_visible = arg_idx;\n\n\t    arg = ((char_u **)(ufunc->uf_def_args.ga_data))[i];\n\t    r = compile_expr0(&arg, &cctx);\n\n\t    if (r == FAIL)\n\t\tgoto erret;\n\n\t    // If no type specified use the type of the default value.\n\t    // Otherwise check that the default value type matches the\n\t    // specified type.\n\t    val_type = get_type_on_stack(&cctx, 0);\n\t    where.wt_index = arg_idx + 1;\n\t    if (ufunc->uf_arg_types[arg_idx] == &t_unknown)\n\t    {\n\t\tdid_set_arg_type = TRUE;\n\t\tufunc->uf_arg_types[arg_idx] = val_type;\n\t    }\n\t    else if (need_type_where(val_type, ufunc->uf_arg_types[arg_idx],\n\t\t\t\t       -1, where, &cctx, FALSE, FALSE) == FAIL)\n\t\tgoto erret;\n\n\t    if (generate_STORE(&cctx, ISN_STORE, i - count - off, NULL) == FAIL)\n\t\tgoto erret;\n\n\t    // set instruction index in JUMP_IF_ARG_SET to here\n\t    isn = ((isn_T *)instr->ga_data) + jump_instr_idx;\n\t    isn->isn_arg.jumparg.jump_where = instr->ga_len;\n\t}\n\n\tif (did_set_arg_type)\n\t    set_function_type(ufunc);\n    }\n    ufunc->uf_args_visible = ufunc->uf_args.ga_len;\n\n    /*\n     * Loop over all the lines of the function and generate instructions.\n     */\n    for (;;)\n    {\n\texarg_T\t    ea;\n\tint\t    starts_with_colon = FALSE;\n\tchar_u\t    *cmd;\n\tcmdmod_T    local_cmdmod;\n\n\t// Bail out on the first error to avoid a flood of errors and report\n\t// the right line number when inside try/catch.\n\tif (did_emsg_before != did_emsg)\n\t    goto erret;\n\n\tif (line != NULL && *line == '|')\n\t    // the line continues after a '|'\n\t    ++line;\n\telse if (line != NULL && *skipwhite(line) != NUL\n\t\t&& !(*line == '#' && (line == cctx.ctx_line_start\n\t\t\t\t\t\t    || VIM_ISWHITE(line[-1]))))\n\t{\n\t    semsg(_(e_trailing_characters_str), line);\n\t    goto erret;\n\t}\n\telse if (line != NULL && vim9_bad_comment(skipwhite(line)))\n\t    goto erret;\n\telse\n\t{\n\t    line = next_line_from_context(&cctx, FALSE);\n\t    if (cctx.ctx_lnum >= ufunc->uf_lines.ga_len)\n\t    {\n\t\t// beyond the last line\n#ifdef FEAT_PROFILE\n\t\tif (cctx.ctx_skip != SKIP_YES)\n\t\t    may_generate_prof_end(&cctx, prof_lnum);\n#endif\n\t\tbreak;\n\t    }\n\t    // Make a copy, splitting off nextcmd and removing trailing spaces\n\t    // may change it.\n\t    if (line != NULL)\n\t    {\n\t\tline = vim_strsave(line);\n\t\tif (ga_add_string(&lines_to_free, line) == FAIL)\n\t\t    goto erret;\n\t    }\n\t}\n\n\tCLEAR_FIELD(ea);\n\tea.cmdlinep = &line;\n\tea.cmd = skipwhite(line);\n\tea.skip = cctx.ctx_skip == SKIP_YES;\n\n\tif (*ea.cmd == '#')\n\t{\n\t    // \"#\" starts a comment, but \"#{\" is an error\n\t    if (vim9_bad_comment(ea.cmd))\n\t\tgoto erret;\n\t    line = (char_u *)\"\";\n\t    continue;\n\t}\n\n#ifdef FEAT_PROFILE\n\tif (cctx.ctx_compile_type == CT_PROFILE && cctx.ctx_lnum != prof_lnum\n\t\t\t\t\t\t  && cctx.ctx_skip != SKIP_YES)\n\t{\n\t    may_generate_prof_end(&cctx, prof_lnum);\n\n\t    prof_lnum = cctx.ctx_lnum;\n\t    generate_instr(&cctx, ISN_PROF_START);\n\t}\n#endif\n\tif (cctx.ctx_compile_type == CT_DEBUG && cctx.ctx_lnum != debug_lnum\n\t\t\t\t\t\t  && cctx.ctx_skip != SKIP_YES)\n\t{\n\t    debug_lnum = cctx.ctx_lnum;\n\t    generate_instr_debug(&cctx);\n\t}\n\tcctx.ctx_prev_lnum = cctx.ctx_lnum + 1;\n\n\t// Some things can be recognized by the first character.\n\tswitch (*ea.cmd)\n\t{\n\t    case '}':\n\t\t{\n\t\t    // \"}\" ends a block scope\n\t\t    scopetype_T stype = cctx.ctx_scope == NULL\n\t\t\t\t\t  ? NO_SCOPE : cctx.ctx_scope->se_type;\n\n\t\t    if (stype == BLOCK_SCOPE)\n\t\t    {\n\t\t\tcompile_endblock(&cctx);\n\t\t\tline = ea.cmd;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\temsg(_(e_using_rcurly_outside_if_block_scope));\n\t\t\tgoto erret;\n\t\t    }\n\t\t    if (line != NULL)\n\t\t\tline = skipwhite(ea.cmd + 1);\n\t\t    continue;\n\t\t}\n\n\t    case '{':\n\t\t// \"{\" starts a block scope\n\t\t// \"{'a': 1}->func() is something else\n\t\tif (ends_excmd(*skipwhite(ea.cmd + 1)))\n\t\t{\n\t\t    line = compile_block(ea.cmd, &cctx);\n\t\t    continue;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * COMMAND MODIFIERS\n\t */\n\tcctx.ctx_has_cmdmod = FALSE;\n\tif (parse_command_modifiers(&ea, &errormsg, &local_cmdmod, FALSE)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t    goto erret;\n\tgenerate_cmdmods(&cctx, &local_cmdmod);\n\tundo_cmdmod(&local_cmdmod);\n\n\t// Check if there was a colon after the last command modifier or before\n\t// the current position.\n\tfor (p = ea.cmd; p >= line; --p)\n\t{\n\t    if (*p == ':')\n\t\tstarts_with_colon = TRUE;\n\t    if (p < ea.cmd && !VIM_ISWHITE(*p))\n\t\tbreak;\n\t}\n\n\t// Skip \":call\" to get to the function name, unless using :legacy\n\tp = ea.cmd;\n\tif (!(local_cmdmod.cmod_flags & CMOD_LEGACY))\n\t{\n\t    if (checkforcmd(&ea.cmd, \"call\", 3))\n\t    {\n\t\tif (*ea.cmd == '(')\n\t\t    // not for \"call()\"\n\t\t    ea.cmd = p;\n\t\telse\n\t\t    ea.cmd = skipwhite(ea.cmd);\n\t    }\n\n\t    if (!starts_with_colon)\n\t    {\n\t\tint\t    assign;\n\n\t\t// Check for assignment after command modifiers.\n\t\tassign = may_compile_assignment(&ea, &line, &cctx);\n\t\tif (assign == OK)\n\t\t    goto nextline;\n\t\tif (assign == FAIL)\n\t\t    goto erret;\n\t    }\n\t}\n\n\t/*\n\t * COMMAND after range\n\t * 'text'->func() should not be confused with 'a mark\n\t * 0z1234->func() should not be confused with a zero line number\n\t * \"++nr\" and \"--nr\" are eval commands\n\t * in \"$ENV->func()\" the \"$\" is not a range\n\t * \"123->func()\" is a method call\n\t */\n\tcmd = ea.cmd;\n\tif ((*cmd != '$' || starts_with_colon)\n\t\t&& (starts_with_colon\n\t\t    || !(*cmd == '\\''\n\t\t\t|| (cmd[0] == '0' && cmd[1] == 'z')\n\t\t\t|| (cmd[0] != NUL && cmd[0] == cmd[1]\n\t\t\t\t\t    && (*cmd == '+' || *cmd == '-'))\n\t\t\t|| number_method(cmd))))\n\t{\n\t    ea.cmd = skip_range(ea.cmd, TRUE, NULL);\n\t    if (ea.cmd > cmd)\n\t    {\n\t\tif (!starts_with_colon\n\t\t\t\t   && !(local_cmdmod.cmod_flags & CMOD_LEGACY))\n\t\t{\n\t\t    semsg(_(e_colon_required_before_range_str), cmd);\n\t\t    goto erret;\n\t\t}\n\t\tea.addr_count = 1;\n\t\tif (ends_excmd2(line, ea.cmd))\n\t\t{\n\t\t    // A range without a command: jump to the line.\n\t\t    generate_EXEC(&cctx, ISN_EXECRANGE,\n\t\t\t\t\t      vim_strnsave(cmd, ea.cmd - cmd));\n\t\t    line = ea.cmd;\n\t\t    goto nextline;\n\t\t}\n\t    }\n\t}\n\tp = find_ex_command(&ea, NULL,\n\t\tstarts_with_colon || (local_cmdmod.cmod_flags & CMOD_LEGACY)\n\t\t\t\t\t\t  ? NULL : item_exists, &cctx);\n\n\tif (p == NULL)\n\t{\n\t    if (cctx.ctx_skip != SKIP_YES)\n\t\tsemsg(_(e_ambiguous_use_of_user_defined_command_str), ea.cmd);\n\t    goto erret;\n\t}\n\n\t// When using \":legacy cmd\" always use compile_exec().\n\tif (local_cmdmod.cmod_flags & CMOD_LEGACY)\n\t{\n\t    char_u *start = ea.cmd;\n\n\t    switch (ea.cmdidx)\n\t    {\n\t\tcase CMD_if:\n\t\tcase CMD_elseif:\n\t\tcase CMD_else:\n\t\tcase CMD_endif:\n\t\tcase CMD_for:\n\t\tcase CMD_endfor:\n\t\tcase CMD_continue:\n\t\tcase CMD_break:\n\t\tcase CMD_while:\n\t\tcase CMD_endwhile:\n\t\tcase CMD_try:\n\t\tcase CMD_catch:\n\t\tcase CMD_finally:\n\t\tcase CMD_endtry:\n\t\t\tsemsg(_(e_cannot_use_legacy_with_command_str), ea.cmd);\n\t\t\tgoto erret;\n\t\tdefault: break;\n\t    }\n\n\t    // \":legacy return expr\" needs to be handled differently.\n\t    if (checkforcmd(&start, \"return\", 4))\n\t\tea.cmdidx = CMD_return;\n\t    else\n\t\tea.cmdidx = CMD_legacy;\n\t}\n\n\tif (p == ea.cmd && ea.cmdidx != CMD_SIZE)\n\t{\n\t    // \"eval\" is used for \"val->func()\" and \"var\" for \"var = val\", then\n\t    // \"p\" is equal to \"ea.cmd\" for a valid command.\n\t    if (ea.cmdidx == CMD_eval || ea.cmdidx == CMD_var)\n\t\t;\n\t    else if (cctx.ctx_skip == SKIP_YES)\n\t    {\n\t\tline += STRLEN(line);\n\t\tgoto nextline;\n\t    }\n\t    else\n\t    {\n\t\tsemsg(_(e_command_not_recognized_str), ea.cmd);\n\t\tgoto erret;\n\t    }\n\t}\n\n\tif (cctx.ctx_had_return\n\t\t&& ea.cmdidx != CMD_elseif\n\t\t&& ea.cmdidx != CMD_else\n\t\t&& ea.cmdidx != CMD_endif\n\t\t&& ea.cmdidx != CMD_endfor\n\t\t&& ea.cmdidx != CMD_endwhile\n\t\t&& ea.cmdidx != CMD_catch\n\t\t&& ea.cmdidx != CMD_finally\n\t\t&& ea.cmdidx != CMD_endtry)\n\t{\n\t    emsg(_(e_unreachable_code_after_return));\n\t    goto erret;\n\t}\n\n\tp = skipwhite(p);\n\tif (ea.cmdidx != CMD_SIZE\n\t\t\t    && ea.cmdidx != CMD_write && ea.cmdidx != CMD_read)\n\t{\n\t    if (ea.cmdidx >= 0)\n\t\tea.argt = excmd_get_argt(ea.cmdidx);\n\t    if ((ea.argt & EX_BANG) && *p == '!')\n\t    {\n\t\tea.forceit = TRUE;\n\t\tp = skipwhite(p + 1);\n\t    }\n\t    if ((ea.argt & EX_RANGE) == 0 && ea.addr_count > 0)\n\t    {\n\t\temsg(_(e_no_range_allowed));\n\t\tgoto erret;\n\t    }\n\t}\n\n\tswitch (ea.cmdidx)\n\t{\n\t    case CMD_def:\n\t    case CMD_function:\n\t\t    ea.arg = p;\n\t\t    line = compile_nested_function(&ea, &cctx, &lines_to_free);\n\t\t    break;\n\n\t    case CMD_return:\n\t\t    line = compile_return(p, check_return_type,\n\t\t\t\t local_cmdmod.cmod_flags & CMOD_LEGACY, &cctx);\n\t\t    cctx.ctx_had_return = TRUE;\n\t\t    break;\n\n\t    case CMD_let:\n\t\t    emsg(_(e_cannot_use_let_in_vim9_script));\n\t\t    break;\n\t    case CMD_var:\n\t    case CMD_final:\n\t    case CMD_const:\n\t    case CMD_increment:\n\t    case CMD_decrement:\n\t\t    line = compile_assignment(p, &ea, ea.cmdidx, &cctx);\n\t\t    if (line == p)\n\t\t    {\n\t\t\temsg(_(e_invalid_assignment));\n\t\t\tline = NULL;\n\t\t    }\n\t\t    break;\n\n\t    case CMD_unlet:\n\t    case CMD_unlockvar:\n\t    case CMD_lockvar:\n\t\t    line = compile_unletlock(p, &ea, &cctx);\n\t\t    break;\n\n\t    case CMD_import:\n\t\t    emsg(_(e_import_can_only_be_used_in_script));\n\t\t    line = NULL;\n\t\t    break;\n\n\t    case CMD_if:\n\t\t    line = compile_if(p, &cctx);\n\t\t    break;\n\t    case CMD_elseif:\n\t\t    line = compile_elseif(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_else:\n\t\t    line = compile_else(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_endif:\n\t\t    line = compile_endif(p, &cctx);\n\t\t    break;\n\n\t    case CMD_while:\n\t\t    line = compile_while(p, &cctx);\n\t\t    break;\n\t    case CMD_endwhile:\n\t\t    line = compile_endwhile(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\n\t    case CMD_for:\n\t\t    line = compile_for(p, &cctx);\n\t\t    break;\n\t    case CMD_endfor:\n\t\t    line = compile_endfor(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_continue:\n\t\t    line = compile_continue(p, &cctx);\n\t\t    break;\n\t    case CMD_break:\n\t\t    line = compile_break(p, &cctx);\n\t\t    break;\n\n\t    case CMD_try:\n\t\t    line = compile_try(p, &cctx);\n\t\t    break;\n\t    case CMD_catch:\n\t\t    line = compile_catch(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_finally:\n\t\t    line = compile_finally(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_endtry:\n\t\t    line = compile_endtry(p, &cctx);\n\t\t    break;\n\t    case CMD_throw:\n\t\t    line = compile_throw(p, &cctx);\n\t\t    break;\n\n\t    case CMD_eval:\n\t\t    line = compile_eval(p, &cctx);\n\t\t    break;\n\n\t    case CMD_echo:\n\t    case CMD_echon:\n\t    case CMD_execute:\n\t    case CMD_echomsg:\n\t    case CMD_echoerr:\n\t    case CMD_echoconsole:\n\t\t    line = compile_mult_expr(p, ea.cmdidx, &cctx);\n\t\t    break;\n\n\t    case CMD_put:\n\t\t    ea.cmd = cmd;\n\t\t    line = compile_put(p, &ea, &cctx);\n\t\t    break;\n\n\t    case CMD_substitute:\n\t\t    if (check_global_and_subst(ea.cmd, p) == FAIL)\n\t\t\tgoto erret;\n\t\t    if (cctx.ctx_skip == SKIP_YES)\n\t\t\tline = (char_u *)\"\";\n\t\t    else\n\t\t    {\n\t\t\tea.arg = p;\n\t\t\tline = compile_substitute(line, &ea, &cctx);\n\t\t    }\n\t\t    break;\n\n\t    case CMD_redir:\n\t\t    ea.arg = p;\n\t\t    line = compile_redir(line, &ea, &cctx);\n\t\t    break;\n\n\t    case CMD_cexpr:\n\t    case CMD_lexpr:\n\t    case CMD_caddexpr:\n\t    case CMD_laddexpr:\n\t    case CMD_cgetexpr:\n\t    case CMD_lgetexpr:\n#ifdef FEAT_QUICKFIX\n\t\t    ea.arg = p;\n\t\t    line = compile_cexpr(line, &ea, &cctx);\n#else\n\t\t    ex_ni(&ea);\n\t\t    line = NULL;\n#endif\n\t\t    break;\n\n\t    case CMD_append:\n\t    case CMD_change:\n\t    case CMD_insert:\n\t    case CMD_k:\n\t    case CMD_t:\n\t    case CMD_xit:\n\t\t    not_in_vim9(&ea);\n\t\t    goto erret;\n\n\t    case CMD_SIZE:\n\t\t    if (cctx.ctx_skip != SKIP_YES)\n\t\t    {\n\t\t\tsemsg(_(e_invalid_command_str), ea.cmd);\n\t\t\tgoto erret;\n\t\t    }\n\t\t    // We don't check for a next command here.\n\t\t    line = (char_u *)\"\";\n\t\t    break;\n\n\t    case CMD_lua:\n\t    case CMD_mzscheme:\n\t    case CMD_perl:\n\t    case CMD_py3:\n\t    case CMD_python3:\n\t    case CMD_python:\n\t    case CMD_pythonx:\n\t    case CMD_ruby:\n\t    case CMD_tcl:\n\t\t    ea.arg = p;\n\t\t    if (vim_strchr(line, '\\n') == NULL)\n\t\t\tline = compile_exec(line, &ea, &cctx);\n\t\t    else\n\t\t\t// heredoc lines have been concatenated with NL\n\t\t\t// characters in get_function_body()\n\t\t\tline = compile_script(line, &cctx);\n\t\t    break;\n\n\t    case CMD_vim9script:\n\t\t    if (cctx.ctx_skip != SKIP_YES)\n\t\t    {\n\t\t\temsg(_(e_vim9script_can_only_be_used_in_script));\n\t\t\tgoto erret;\n\t\t    }\n\t\t    line = (char_u *)\"\";\n\t\t    break;\n\n\t    case CMD_global:\n\t\t    if (check_global_and_subst(ea.cmd, p) == FAIL)\n\t\t\tgoto erret;\n\t\t    // FALLTHROUGH\n\t    default:\n\t\t    // Not recognized, execute with do_cmdline_cmd().\n\t\t    ea.arg = p;\n\t\t    line = compile_exec(line, &ea, &cctx);\n\t\t    break;\n\t}\nnextline:\n\tif (line == NULL)\n\t    goto erret;\n\tline = skipwhite(line);\n\n\t// Undo any command modifiers.\n\tgenerate_undo_cmdmods(&cctx);\n\n\tif (cctx.ctx_type_stack.ga_len < 0)\n\t{\n\t    iemsg(\"Type stack underflow\");\n\t    goto erret;\n\t}\n    }\n\n    if (cctx.ctx_scope != NULL)\n    {\n\tif (cctx.ctx_scope->se_type == IF_SCOPE)\n\t    emsg(_(e_missing_endif));\n\telse if (cctx.ctx_scope->se_type == WHILE_SCOPE)\n\t    emsg(_(e_missing_endwhile));\n\telse if (cctx.ctx_scope->se_type == FOR_SCOPE)\n\t    emsg(_(e_missing_endfor));\n\telse\n\t    emsg(_(e_missing_rcurly));\n\tgoto erret;\n    }\n\n    if (!cctx.ctx_had_return)\n    {\n\tif (ufunc->uf_ret_type->tt_type == VAR_UNKNOWN)\n\t    ufunc->uf_ret_type = &t_void;\n\telse if (ufunc->uf_ret_type->tt_type != VAR_VOID)\n\t{\n\t    emsg(_(e_missing_return_statement));\n\t    goto erret;\n\t}\n\n\t// Return void if there is no return at the end.\n\tgenerate_instr(&cctx, ISN_RETURN_VOID);\n    }\n\n    // When compiled with \":silent!\" and there was an error don't consider the\n    // function compiled.\n    if (emsg_silent == 0 || did_emsg_silent == did_emsg_silent_before)\n    {\n\tdfunc_T\t*dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\tdfunc->df_deleted = FALSE;\n\tdfunc->df_script_seq = current_sctx.sc_seq;\n#ifdef FEAT_PROFILE\n\tif (cctx.ctx_compile_type == CT_PROFILE)\n\t{\n\t    dfunc->df_instr_prof = instr->ga_data;\n\t    dfunc->df_instr_prof_count = instr->ga_len;\n\t}\n\telse\n#endif\n\tif (cctx.ctx_compile_type == CT_DEBUG)\n\t{\n\t    dfunc->df_instr_debug = instr->ga_data;\n\t    dfunc->df_instr_debug_count = instr->ga_len;\n\t}\n\telse\n\t{\n\t    dfunc->df_instr = instr->ga_data;\n\t    dfunc->df_instr_count = instr->ga_len;\n\t}\n\tdfunc->df_varcount = dfunc->df_var_names.ga_len;\n\tdfunc->df_has_closure = cctx.ctx_has_closure;\n\tif (cctx.ctx_outer_used)\n\t    ufunc->uf_flags |= FC_CLOSURE;\n\tufunc->uf_def_status = UF_COMPILED;\n    }\n\n    ret = OK;\n\nerret:\n    if (ufunc->uf_def_status == UF_COMPILING)\n    {\n\tdfunc_T\t*dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\n\t// Compiling aborted, free the generated instructions.\n\tclear_instr_ga(instr);\n\tVIM_CLEAR(dfunc->df_name);\n\tga_clear_strings(&dfunc->df_var_names);\n\n\t// If using the last entry in the table and it was added above, we\n\t// might as well remove it.\n\tif (!dfunc->df_deleted && new_def_function\n\t\t\t    && ufunc->uf_dfunc_idx == def_functions.ga_len - 1)\n\t{\n\t    --def_functions.ga_len;\n\t    ufunc->uf_dfunc_idx = 0;\n\t}\n\tufunc->uf_def_status = UF_COMPILE_ERROR;\n\n\twhile (cctx.ctx_scope != NULL)\n\t    drop_scope(&cctx);\n\n\tif (errormsg != NULL)\n\t    emsg(errormsg);\n\telse if (did_emsg == did_emsg_before)\n\t    emsg(_(e_compiling_def_function_failed));\n    }\n\n    if (cctx.ctx_redir_lhs.lhs_name != NULL)\n    {\n\tif (ret == OK)\n\t{\n\t    emsg(_(e_missing_redir_end));\n\t    ret = FAIL;\n\t}\n\tvim_free(cctx.ctx_redir_lhs.lhs_name);\n\tvim_free(cctx.ctx_redir_lhs.lhs_whole);\n    }\n\n    current_sctx = save_current_sctx;\n    estack_compiling = save_estack_compiling;\n    cmdmod.cmod_flags =\tsave_cmod_flags;\n    if (do_estack_push)\n\testack_pop();\n\n    ga_clear_strings(&lines_to_free);\n    free_locals(&cctx);\n    ga_clear(&cctx.ctx_type_stack);\n    return ret;\n}\n\n    void\nset_function_type(ufunc_T *ufunc)\n{\n    int varargs = ufunc->uf_va_name != NULL;\n    int argcount = ufunc->uf_args.ga_len;\n\n    // Create a type for the function, with the return type and any\n    // argument types.\n    // A vararg is included in uf_args.ga_len but not in uf_arg_types.\n    // The type is included in \"tt_args\".\n    if (argcount > 0 || varargs)\n    {\n\tif (ufunc->uf_type_list.ga_itemsize == 0)\n\t    ga_init2(&ufunc->uf_type_list, sizeof(type_T *), 10);\n\tufunc->uf_func_type = alloc_func_type(ufunc->uf_ret_type,\n\t\t\t\t\t   argcount, &ufunc->uf_type_list);\n\t// Add argument types to the function type.\n\tif (func_type_add_arg_types(ufunc->uf_func_type,\n\t\t\t\t    argcount + varargs,\n\t\t\t\t    &ufunc->uf_type_list) == FAIL)\n\t    return;\n\tufunc->uf_func_type->tt_argcount = argcount + varargs;\n\tufunc->uf_func_type->tt_min_argcount =\n\t\t\t\t      argcount - ufunc->uf_def_args.ga_len;\n\tif (ufunc->uf_arg_types == NULL)\n\t{\n\t    int i;\n\n\t    // lambda does not have argument types.\n\t    for (i = 0; i < argcount; ++i)\n\t\tufunc->uf_func_type->tt_args[i] = &t_any;\n\t}\n\telse\n\t    mch_memmove(ufunc->uf_func_type->tt_args,\n\t\t\t ufunc->uf_arg_types, sizeof(type_T *) * argcount);\n\tif (varargs)\n\t{\n\t    ufunc->uf_func_type->tt_args[argcount] =\n\t\t   ufunc->uf_va_type == NULL ? &t_list_any : ufunc->uf_va_type;\n\t    ufunc->uf_func_type->tt_flags = TTFLAG_VARARGS;\n\t}\n    }\n    else\n\t// No arguments, can use a predefined type.\n\tufunc->uf_func_type = get_func_type(ufunc->uf_ret_type,\n\t\t\t\t\t   argcount, &ufunc->uf_type_list);\n}\n\n/*\n * Free all instructions for \"dfunc\" except df_name.\n */\n    static void\ndelete_def_function_contents(dfunc_T *dfunc, int mark_deleted)\n{\n    int idx;\n\n    ga_clear(&dfunc->df_def_args_isn);\n    ga_clear_strings(&dfunc->df_var_names);\n\n    if (dfunc->df_instr != NULL)\n    {\n\tfor (idx = 0; idx < dfunc->df_instr_count; ++idx)\n\t    delete_instr(dfunc->df_instr + idx);\n\tVIM_CLEAR(dfunc->df_instr);\n\tdfunc->df_instr = NULL;\n    }\n    if (dfunc->df_instr_debug != NULL)\n    {\n\tfor (idx = 0; idx < dfunc->df_instr_debug_count; ++idx)\n\t    delete_instr(dfunc->df_instr_debug + idx);\n\tVIM_CLEAR(dfunc->df_instr_debug);\n\tdfunc->df_instr_debug = NULL;\n    }\n#ifdef FEAT_PROFILE\n    if (dfunc->df_instr_prof != NULL)\n    {\n\tfor (idx = 0; idx < dfunc->df_instr_prof_count; ++idx)\n\t    delete_instr(dfunc->df_instr_prof + idx);\n\tVIM_CLEAR(dfunc->df_instr_prof);\n\tdfunc->df_instr_prof = NULL;\n    }\n#endif\n\n    if (mark_deleted)\n\tdfunc->df_deleted = TRUE;\n    if (dfunc->df_ufunc != NULL)\n\tdfunc->df_ufunc->uf_def_status = UF_NOT_COMPILED;\n}\n\n/*\n * When a user function is deleted, clear the contents of any associated def\n * function, unless another user function still uses it.\n * The position in def_functions can be re-used.\n */\n    void\nunlink_def_function(ufunc_T *ufunc)\n{\n    if (ufunc->uf_dfunc_idx > 0)\n    {\n\tdfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\n\tif (--dfunc->df_refcount <= 0)\n\t    delete_def_function_contents(dfunc, TRUE);\n\tufunc->uf_def_status = UF_NOT_COMPILED;\n\tufunc->uf_dfunc_idx = 0;\n\tif (dfunc->df_ufunc == ufunc)\n\t    dfunc->df_ufunc = NULL;\n    }\n}\n\n/*\n * Used when a user function refers to an existing dfunc.\n */\n    void\nlink_def_function(ufunc_T *ufunc)\n{\n    if (ufunc->uf_dfunc_idx > 0)\n    {\n\tdfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\n\t++dfunc->df_refcount;\n    }\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n/*\n * Free all functions defined with \":def\".\n */\n    void\nfree_def_functions(void)\n{\n    int idx;\n\n    for (idx = 0; idx < def_functions.ga_len; ++idx)\n    {\n\tdfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data) + idx;\n\n\tdelete_def_function_contents(dfunc, TRUE);\n\tvim_free(dfunc->df_name);\n    }\n\n    ga_clear(&def_functions);\n}\n#endif\n\n\n#endif // FEAT_EVAL\n"], "filenames": ["src/testdir/test_vim9_script.vim", "src/version.c", "src/vim9compile.c"], "buggy_code_start_loc": [2097, 733, 1168], "buggy_code_end_loc": [2097, 733, 1953], "fixing_code_start_loc": [2098, 734, 1168], "fixing_code_end_loc": [2111, 736, 1960], "type": "CWE-476", "message": "NULL Pointer Dereference in GitHub repository vim/vim prior to 9.0.0224.", "other": {"cve": {"id": "CVE-2022-2874", "sourceIdentifier": "security@huntr.dev", "published": "2022-08-18T16:15:08.037", "lastModified": "2023-05-03T12:16:06.233", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "NULL Pointer Dereference in GitHub repository vim/vim prior to 9.0.0224."}, {"lang": "es", "value": "Una Desreferencia de puntero NULL en el repositorio de GitHub vim/vim versiones anteriores a 9.0.0224."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 6.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 4.7}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.0.0224", "matchCriteriaId": "BD3568CF-1081-4ECC-AA61-8ABEC5CE282E"}]}]}], "references": [{"url": "https://github.com/vim/vim/commit/4875d6ab068f09df88d24d81de40dcd8d56e243d", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/95f97dfe-247d-475d-9740-b7adc71f4c79", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202305-16", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/vim/vim/commit/4875d6ab068f09df88d24d81de40dcd8d56e243d"}}