{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * NETLINK      Netlink attributes\n *\n * \t\tAuthors:\tThomas Graf <tgraf@suug.ch>\n * \t\t\t\tAlexey Kuznetsov <kuznet@ms2.inr.ac.ru>\n */\n\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/jiffies.h>\n#include <linux/skbuff.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <net/netlink.h>\n\n/* For these data types, attribute length should be exactly the given\n * size. However, to maintain compatibility with broken commands, if the\n * attribute length does not match the expected size a warning is emitted\n * to the user that the command is sending invalid data and needs to be fixed.\n */\nstatic const u8 nla_attr_len[NLA_TYPE_MAX+1] = {\n\t[NLA_U8]\t= sizeof(u8),\n\t[NLA_U16]\t= sizeof(u16),\n\t[NLA_U32]\t= sizeof(u32),\n\t[NLA_U64]\t= sizeof(u64),\n\t[NLA_S8]\t= sizeof(s8),\n\t[NLA_S16]\t= sizeof(s16),\n\t[NLA_S32]\t= sizeof(s32),\n\t[NLA_S64]\t= sizeof(s64),\n};\n\nstatic const u8 nla_attr_minlen[NLA_TYPE_MAX+1] = {\n\t[NLA_U8]\t= sizeof(u8),\n\t[NLA_U16]\t= sizeof(u16),\n\t[NLA_U32]\t= sizeof(u32),\n\t[NLA_U64]\t= sizeof(u64),\n\t[NLA_MSECS]\t= sizeof(u64),\n\t[NLA_NESTED]\t= NLA_HDRLEN,\n\t[NLA_S8]\t= sizeof(s8),\n\t[NLA_S16]\t= sizeof(s16),\n\t[NLA_S32]\t= sizeof(s32),\n\t[NLA_S64]\t= sizeof(s64),\n};\n\nstatic int validate_nla_bitfield32(const struct nlattr *nla,\n\t\t\t\t   const u32 valid_flags_mask)\n{\n\tconst struct nla_bitfield32 *bf = nla_data(nla);\n\n\tif (!valid_flags_mask)\n\t\treturn -EINVAL;\n\n\t/*disallow invalid bit selector */\n\tif (bf->selector & ~valid_flags_mask)\n\t\treturn -EINVAL;\n\n\t/*disallow invalid bit values */\n\tif (bf->value & ~valid_flags_mask)\n\t\treturn -EINVAL;\n\n\t/*disallow valid bit values that are not selected*/\n\tif (bf->value & ~bf->selector)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int nla_validate_array(const struct nlattr *head, int len, int maxtype,\n\t\t\t      const struct nla_policy *policy,\n\t\t\t      struct netlink_ext_ack *extack,\n\t\t\t      unsigned int validate)\n{\n\tconst struct nlattr *entry;\n\tint rem;\n\n\tnla_for_each_attr(entry, head, len, rem) {\n\t\tint ret;\n\n\t\tif (nla_len(entry) == 0)\n\t\t\tcontinue;\n\n\t\tif (nla_len(entry) < NLA_HDRLEN) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, entry,\n\t\t\t\t\t    \"Array element too short\");\n\t\t\treturn -ERANGE;\n\t\t}\n\n\t\tret = __nla_validate(nla_data(entry), nla_len(entry),\n\t\t\t\t     maxtype, policy, validate, extack);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int nla_validate_int_range(const struct nla_policy *pt,\n\t\t\t\t  const struct nlattr *nla,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tbool validate_min, validate_max;\n\ts64 value;\n\n\tvalidate_min = pt->validation_type == NLA_VALIDATE_RANGE ||\n\t\t       pt->validation_type == NLA_VALIDATE_MIN;\n\tvalidate_max = pt->validation_type == NLA_VALIDATE_RANGE ||\n\t\t       pt->validation_type == NLA_VALIDATE_MAX;\n\n\tswitch (pt->type) {\n\tcase NLA_U8:\n\t\tvalue = nla_get_u8(nla);\n\t\tbreak;\n\tcase NLA_U16:\n\t\tvalue = nla_get_u16(nla);\n\t\tbreak;\n\tcase NLA_U32:\n\t\tvalue = nla_get_u32(nla);\n\t\tbreak;\n\tcase NLA_S8:\n\t\tvalue = nla_get_s8(nla);\n\t\tbreak;\n\tcase NLA_S16:\n\t\tvalue = nla_get_s16(nla);\n\t\tbreak;\n\tcase NLA_S32:\n\t\tvalue = nla_get_s32(nla);\n\t\tbreak;\n\tcase NLA_S64:\n\t\tvalue = nla_get_s64(nla);\n\t\tbreak;\n\tcase NLA_U64:\n\t\t/* treat this one specially, since it may not fit into s64 */\n\t\tif ((validate_min && nla_get_u64(nla) < pt->min) ||\n\t\t    (validate_max && nla_get_u64(nla) > pt->max)) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, nla,\n\t\t\t\t\t    \"integer out of range\");\n\t\t\treturn -ERANGE;\n\t\t}\n\t\treturn 0;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((validate_min && value < pt->min) ||\n\t    (validate_max && value > pt->max)) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, nla,\n\t\t\t\t    \"integer out of range\");\n\t\treturn -ERANGE;\n\t}\n\n\treturn 0;\n}\n\nstatic int validate_nla(const struct nlattr *nla, int maxtype,\n\t\t\tconst struct nla_policy *policy, unsigned int validate,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tu16 strict_start_type = policy[0].strict_start_type;\n\tconst struct nla_policy *pt;\n\tint minlen = 0, attrlen = nla_len(nla), type = nla_type(nla);\n\tint err = -ERANGE;\n\n\tif (strict_start_type && type >= strict_start_type)\n\t\tvalidate |= NL_VALIDATE_STRICT;\n\n\tif (type <= 0 || type > maxtype)\n\t\treturn 0;\n\n\tpt = &policy[type];\n\n\tBUG_ON(pt->type > NLA_TYPE_MAX);\n\n\tif ((nla_attr_len[pt->type] && attrlen != nla_attr_len[pt->type]) ||\n\t    (pt->type == NLA_EXACT_LEN_WARN && attrlen != pt->len)) {\n\t\tpr_warn_ratelimited(\"netlink: '%s': attribute type %d has an invalid length.\\n\",\n\t\t\t\t    current->comm, type);\n\t\tif (validate & NL_VALIDATE_STRICT_ATTRS) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, nla,\n\t\t\t\t\t    \"invalid attribute length\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (validate & NL_VALIDATE_NESTED) {\n\t\tif ((pt->type == NLA_NESTED || pt->type == NLA_NESTED_ARRAY) &&\n\t\t    !(nla->nla_type & NLA_F_NESTED)) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, nla,\n\t\t\t\t\t    \"NLA_F_NESTED is missing\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (pt->type != NLA_NESTED && pt->type != NLA_NESTED_ARRAY &&\n\t\t    pt->type != NLA_UNSPEC && (nla->nla_type & NLA_F_NESTED)) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, nla,\n\t\t\t\t\t    \"NLA_F_NESTED not expected\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tswitch (pt->type) {\n\tcase NLA_EXACT_LEN:\n\t\tif (attrlen != pt->len)\n\t\t\tgoto out_err;\n\t\tbreak;\n\n\tcase NLA_REJECT:\n\t\tif (extack && pt->reject_message) {\n\t\t\tNL_SET_BAD_ATTR(extack, nla);\n\t\t\textack->_msg = pt->reject_message;\n\t\t\treturn -EINVAL;\n\t\t}\n\t\terr = -EINVAL;\n\t\tgoto out_err;\n\n\tcase NLA_FLAG:\n\t\tif (attrlen > 0)\n\t\t\tgoto out_err;\n\t\tbreak;\n\n\tcase NLA_BITFIELD32:\n\t\tif (attrlen != sizeof(struct nla_bitfield32))\n\t\t\tgoto out_err;\n\n\t\terr = validate_nla_bitfield32(nla, pt->bitfield32_valid);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t\tbreak;\n\n\tcase NLA_NUL_STRING:\n\t\tif (pt->len)\n\t\t\tminlen = min_t(int, attrlen, pt->len + 1);\n\t\telse\n\t\t\tminlen = attrlen;\n\n\t\tif (!minlen || memchr(nla_data(nla), '\\0', minlen) == NULL) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_err;\n\t\t}\n\t\t/* fall through */\n\n\tcase NLA_STRING:\n\t\tif (attrlen < 1)\n\t\t\tgoto out_err;\n\n\t\tif (pt->len) {\n\t\t\tchar *buf = nla_data(nla);\n\n\t\t\tif (buf[attrlen - 1] == '\\0')\n\t\t\t\tattrlen--;\n\n\t\t\tif (attrlen > pt->len)\n\t\t\t\tgoto out_err;\n\t\t}\n\t\tbreak;\n\n\tcase NLA_BINARY:\n\t\tif (pt->len && attrlen > pt->len)\n\t\t\tgoto out_err;\n\t\tbreak;\n\n\tcase NLA_NESTED:\n\t\t/* a nested attributes is allowed to be empty; if its not,\n\t\t * it must have a size of at least NLA_HDRLEN.\n\t\t */\n\t\tif (attrlen == 0)\n\t\t\tbreak;\n\t\tif (attrlen < NLA_HDRLEN)\n\t\t\tgoto out_err;\n\t\tif (pt->nested_policy) {\n\t\t\terr = __nla_validate(nla_data(nla), nla_len(nla), pt->len,\n\t\t\t\t\t     pt->nested_policy, validate,\n\t\t\t\t\t     extack);\n\t\t\tif (err < 0) {\n\t\t\t\t/*\n\t\t\t\t * return directly to preserve the inner\n\t\t\t\t * error message/attribute pointer\n\t\t\t\t */\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase NLA_NESTED_ARRAY:\n\t\t/* a nested array attribute is allowed to be empty; if its not,\n\t\t * it must have a size of at least NLA_HDRLEN.\n\t\t */\n\t\tif (attrlen == 0)\n\t\t\tbreak;\n\t\tif (attrlen < NLA_HDRLEN)\n\t\t\tgoto out_err;\n\t\tif (pt->nested_policy) {\n\t\t\tint err;\n\n\t\t\terr = nla_validate_array(nla_data(nla), nla_len(nla),\n\t\t\t\t\t\t pt->len, pt->nested_policy,\n\t\t\t\t\t\t extack, validate);\n\t\t\tif (err < 0) {\n\t\t\t\t/*\n\t\t\t\t * return directly to preserve the inner\n\t\t\t\t * error message/attribute pointer\n\t\t\t\t */\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase NLA_UNSPEC:\n\t\tif (validate & NL_VALIDATE_UNSPEC) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, nla,\n\t\t\t\t\t    \"Unsupported attribute\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/* fall through */\n\tcase NLA_MIN_LEN:\n\t\tif (attrlen < pt->len)\n\t\t\tgoto out_err;\n\t\tbreak;\n\n\tdefault:\n\t\tif (pt->len)\n\t\t\tminlen = pt->len;\n\t\telse\n\t\t\tminlen = nla_attr_minlen[pt->type];\n\n\t\tif (attrlen < minlen)\n\t\t\tgoto out_err;\n\t}\n\n\t/* further validation */\n\tswitch (pt->validation_type) {\n\tcase NLA_VALIDATE_NONE:\n\t\t/* nothing to do */\n\t\tbreak;\n\tcase NLA_VALIDATE_RANGE:\n\tcase NLA_VALIDATE_MIN:\n\tcase NLA_VALIDATE_MAX:\n\t\terr = nla_validate_int_range(pt, nla, extack);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tcase NLA_VALIDATE_FUNCTION:\n\t\tif (pt->validate) {\n\t\t\terr = pt->validate(nla, extack);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn 0;\nout_err:\n\tNL_SET_ERR_MSG_ATTR(extack, nla, \"Attribute failed policy validation\");\n\treturn err;\n}\n\nstatic int __nla_validate_parse(const struct nlattr *head, int len, int maxtype,\n\t\t\t\tconst struct nla_policy *policy,\n\t\t\t\tunsigned int validate,\n\t\t\t\tstruct netlink_ext_ack *extack,\n\t\t\t\tstruct nlattr **tb)\n{\n\tconst struct nlattr *nla;\n\tint rem;\n\n\tif (tb)\n\t\tmemset(tb, 0, sizeof(struct nlattr *) * (maxtype + 1));\n\n\tnla_for_each_attr(nla, head, len, rem) {\n\t\tu16 type = nla_type(nla);\n\n\t\tif (type == 0 || type > maxtype) {\n\t\t\tif (validate & NL_VALIDATE_MAXTYPE) {\n\t\t\t\tNL_SET_ERR_MSG_ATTR(extack, nla,\n\t\t\t\t\t\t    \"Unknown attribute type\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (policy) {\n\t\t\tint err = validate_nla(nla, maxtype, policy,\n\t\t\t\t\t       validate, extack);\n\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tif (tb)\n\t\t\ttb[type] = (struct nlattr *)nla;\n\t}\n\n\tif (unlikely(rem > 0)) {\n\t\tpr_warn_ratelimited(\"netlink: %d bytes leftover after parsing attributes in process `%s'.\\n\",\n\t\t\t\t    rem, current->comm);\n\t\tNL_SET_ERR_MSG(extack, \"bytes leftover after parsing attributes\");\n\t\tif (validate & NL_VALIDATE_TRAILING)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/**\n * __nla_validate - Validate a stream of attributes\n * @head: head of attribute stream\n * @len: length of attribute stream\n * @maxtype: maximum attribute type to be expected\n * @policy: validation policy\n * @validate: validation strictness\n * @extack: extended ACK report struct\n *\n * Validates all attributes in the specified attribute stream against the\n * specified policy. Validation depends on the validate flags passed, see\n * &enum netlink_validation for more details on that.\n * See documenation of struct nla_policy for more details.\n *\n * Returns 0 on success or a negative error code.\n */\nint __nla_validate(const struct nlattr *head, int len, int maxtype,\n\t\t   const struct nla_policy *policy, unsigned int validate,\n\t\t   struct netlink_ext_ack *extack)\n{\n\treturn __nla_validate_parse(head, len, maxtype, policy, validate,\n\t\t\t\t    extack, NULL);\n}\nEXPORT_SYMBOL(__nla_validate);\n\n/**\n * nla_policy_len - Determin the max. length of a policy\n * @policy: policy to use\n * @n: number of policies\n *\n * Determines the max. length of the policy.  It is currently used\n * to allocated Netlink buffers roughly the size of the actual\n * message.\n *\n * Returns 0 on success or a negative error code.\n */\nint\nnla_policy_len(const struct nla_policy *p, int n)\n{\n\tint i, len = 0;\n\n\tfor (i = 0; i < n; i++, p++) {\n\t\tif (p->len)\n\t\t\tlen += nla_total_size(p->len);\n\t\telse if (nla_attr_len[p->type])\n\t\t\tlen += nla_total_size(nla_attr_len[p->type]);\n\t\telse if (nla_attr_minlen[p->type])\n\t\t\tlen += nla_total_size(nla_attr_minlen[p->type]);\n\t}\n\n\treturn len;\n}\nEXPORT_SYMBOL(nla_policy_len);\n\n/**\n * __nla_parse - Parse a stream of attributes into a tb buffer\n * @tb: destination array with maxtype+1 elements\n * @maxtype: maximum attribute type to be expected\n * @head: head of attribute stream\n * @len: length of attribute stream\n * @policy: validation policy\n * @validate: validation strictness\n * @extack: extended ACK pointer\n *\n * Parses a stream of attributes and stores a pointer to each attribute in\n * the tb array accessible via the attribute type.\n * Validation is controlled by the @validate parameter.\n *\n * Returns 0 on success or a negative error code.\n */\nint __nla_parse(struct nlattr **tb, int maxtype,\n\t\tconst struct nlattr *head, int len,\n\t\tconst struct nla_policy *policy, unsigned int validate,\n\t\tstruct netlink_ext_ack *extack)\n{\n\treturn __nla_validate_parse(head, len, maxtype, policy, validate,\n\t\t\t\t    extack, tb);\n}\nEXPORT_SYMBOL(__nla_parse);\n\n/**\n * nla_find - Find a specific attribute in a stream of attributes\n * @head: head of attribute stream\n * @len: length of attribute stream\n * @attrtype: type of attribute to look for\n *\n * Returns the first attribute in the stream matching the specified type.\n */\nstruct nlattr *nla_find(const struct nlattr *head, int len, int attrtype)\n{\n\tconst struct nlattr *nla;\n\tint rem;\n\n\tnla_for_each_attr(nla, head, len, rem)\n\t\tif (nla_type(nla) == attrtype)\n\t\t\treturn (struct nlattr *)nla;\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(nla_find);\n\n/**\n * nla_strlcpy - Copy string attribute payload into a sized buffer\n * @dst: where to copy the string to\n * @nla: attribute to copy the string from\n * @dstsize: size of destination buffer\n *\n * Copies at most dstsize - 1 bytes into the destination buffer.\n * The result is always a valid NUL-terminated string. Unlike\n * strlcpy the destination buffer is always padded out.\n *\n * Returns the length of the source buffer.\n */\nsize_t nla_strlcpy(char *dst, const struct nlattr *nla, size_t dstsize)\n{\n\tsize_t srclen = nla_len(nla);\n\tchar *src = nla_data(nla);\n\n\tif (srclen > 0 && src[srclen - 1] == '\\0')\n\t\tsrclen--;\n\n\tif (dstsize > 0) {\n\t\tsize_t len = (srclen >= dstsize) ? dstsize - 1 : srclen;\n\n\t\tmemset(dst, 0, dstsize);\n\t\tmemcpy(dst, src, len);\n\t}\n\n\treturn srclen;\n}\nEXPORT_SYMBOL(nla_strlcpy);\n\n/**\n * nla_strdup - Copy string attribute payload into a newly allocated buffer\n * @nla: attribute to copy the string from\n * @flags: the type of memory to allocate (see kmalloc).\n *\n * Returns a pointer to the allocated buffer or NULL on error.\n */\nchar *nla_strdup(const struct nlattr *nla, gfp_t flags)\n{\n\tsize_t srclen = nla_len(nla);\n\tchar *src = nla_data(nla), *dst;\n\n\tif (srclen > 0 && src[srclen - 1] == '\\0')\n\t\tsrclen--;\n\n\tdst = kmalloc(srclen + 1, flags);\n\tif (dst != NULL) {\n\t\tmemcpy(dst, src, srclen);\n\t\tdst[srclen] = '\\0';\n\t}\n\treturn dst;\n}\nEXPORT_SYMBOL(nla_strdup);\n\n/**\n * nla_memcpy - Copy a netlink attribute into another memory area\n * @dest: where to copy to memcpy\n * @src: netlink attribute to copy from\n * @count: size of the destination area\n *\n * Note: The number of bytes copied is limited by the length of\n *       attribute's payload. memcpy\n *\n * Returns the number of bytes copied.\n */\nint nla_memcpy(void *dest, const struct nlattr *src, int count)\n{\n\tint minlen = min_t(int, count, nla_len(src));\n\n\tmemcpy(dest, nla_data(src), minlen);\n\tif (count > minlen)\n\t\tmemset(dest + minlen, 0, count - minlen);\n\n\treturn minlen;\n}\nEXPORT_SYMBOL(nla_memcpy);\n\n/**\n * nla_memcmp - Compare an attribute with sized memory area\n * @nla: netlink attribute\n * @data: memory area\n * @size: size of memory area\n */\nint nla_memcmp(const struct nlattr *nla, const void *data,\n\t\t\t     size_t size)\n{\n\tint d = nla_len(nla) - size;\n\n\tif (d == 0)\n\t\td = memcmp(nla_data(nla), data, size);\n\n\treturn d;\n}\nEXPORT_SYMBOL(nla_memcmp);\n\n/**\n * nla_strcmp - Compare a string attribute against a string\n * @nla: netlink string attribute\n * @str: another string\n */\nint nla_strcmp(const struct nlattr *nla, const char *str)\n{\n\tint len = strlen(str);\n\tchar *buf = nla_data(nla);\n\tint attrlen = nla_len(nla);\n\tint d;\n\n\tif (attrlen > 0 && buf[attrlen - 1] == '\\0')\n\t\tattrlen--;\n\n\td = attrlen - len;\n\tif (d == 0)\n\t\td = memcmp(nla_data(nla), str, len);\n\n\treturn d;\n}\nEXPORT_SYMBOL(nla_strcmp);\n\n#ifdef CONFIG_NET\n/**\n * __nla_reserve - reserve room for attribute on the skb\n * @skb: socket buffer to reserve room on\n * @attrtype: attribute type\n * @attrlen: length of attribute payload\n *\n * Adds a netlink attribute header to a socket buffer and reserves\n * room for the payload but does not copy it.\n *\n * The caller is responsible to ensure that the skb provides enough\n * tailroom for the attribute header and payload.\n */\nstruct nlattr *__nla_reserve(struct sk_buff *skb, int attrtype, int attrlen)\n{\n\tstruct nlattr *nla;\n\n\tnla = skb_put(skb, nla_total_size(attrlen));\n\tnla->nla_type = attrtype;\n\tnla->nla_len = nla_attr_size(attrlen);\n\n\tmemset((unsigned char *) nla + nla->nla_len, 0, nla_padlen(attrlen));\n\n\treturn nla;\n}\nEXPORT_SYMBOL(__nla_reserve);\n\n/**\n * __nla_reserve_64bit - reserve room for attribute on the skb and align it\n * @skb: socket buffer to reserve room on\n * @attrtype: attribute type\n * @attrlen: length of attribute payload\n * @padattr: attribute type for the padding\n *\n * Adds a netlink attribute header to a socket buffer and reserves\n * room for the payload but does not copy it. It also ensure that this\n * attribute will have a 64-bit aligned nla_data() area.\n *\n * The caller is responsible to ensure that the skb provides enough\n * tailroom for the attribute header and payload.\n */\nstruct nlattr *__nla_reserve_64bit(struct sk_buff *skb, int attrtype,\n\t\t\t\t   int attrlen, int padattr)\n{\n\tif (nla_need_padding_for_64bit(skb))\n\t\tnla_align_64bit(skb, padattr);\n\n\treturn __nla_reserve(skb, attrtype, attrlen);\n}\nEXPORT_SYMBOL(__nla_reserve_64bit);\n\n/**\n * __nla_reserve_nohdr - reserve room for attribute without header\n * @skb: socket buffer to reserve room on\n * @attrlen: length of attribute payload\n *\n * Reserves room for attribute payload without a header.\n *\n * The caller is responsible to ensure that the skb provides enough\n * tailroom for the payload.\n */\nvoid *__nla_reserve_nohdr(struct sk_buff *skb, int attrlen)\n{\n\treturn skb_put_zero(skb, NLA_ALIGN(attrlen));\n}\nEXPORT_SYMBOL(__nla_reserve_nohdr);\n\n/**\n * nla_reserve - reserve room for attribute on the skb\n * @skb: socket buffer to reserve room on\n * @attrtype: attribute type\n * @attrlen: length of attribute payload\n *\n * Adds a netlink attribute header to a socket buffer and reserves\n * room for the payload but does not copy it.\n *\n * Returns NULL if the tailroom of the skb is insufficient to store\n * the attribute header and payload.\n */\nstruct nlattr *nla_reserve(struct sk_buff *skb, int attrtype, int attrlen)\n{\n\tif (unlikely(skb_tailroom(skb) < nla_total_size(attrlen)))\n\t\treturn NULL;\n\n\treturn __nla_reserve(skb, attrtype, attrlen);\n}\nEXPORT_SYMBOL(nla_reserve);\n\n/**\n * nla_reserve_64bit - reserve room for attribute on the skb and align it\n * @skb: socket buffer to reserve room on\n * @attrtype: attribute type\n * @attrlen: length of attribute payload\n * @padattr: attribute type for the padding\n *\n * Adds a netlink attribute header to a socket buffer and reserves\n * room for the payload but does not copy it. It also ensure that this\n * attribute will have a 64-bit aligned nla_data() area.\n *\n * Returns NULL if the tailroom of the skb is insufficient to store\n * the attribute header and payload.\n */\nstruct nlattr *nla_reserve_64bit(struct sk_buff *skb, int attrtype, int attrlen,\n\t\t\t\t int padattr)\n{\n\tsize_t len;\n\n\tif (nla_need_padding_for_64bit(skb))\n\t\tlen = nla_total_size_64bit(attrlen);\n\telse\n\t\tlen = nla_total_size(attrlen);\n\tif (unlikely(skb_tailroom(skb) < len))\n\t\treturn NULL;\n\n\treturn __nla_reserve_64bit(skb, attrtype, attrlen, padattr);\n}\nEXPORT_SYMBOL(nla_reserve_64bit);\n\n/**\n * nla_reserve_nohdr - reserve room for attribute without header\n * @skb: socket buffer to reserve room on\n * @attrlen: length of attribute payload\n *\n * Reserves room for attribute payload without a header.\n *\n * Returns NULL if the tailroom of the skb is insufficient to store\n * the attribute payload.\n */\nvoid *nla_reserve_nohdr(struct sk_buff *skb, int attrlen)\n{\n\tif (unlikely(skb_tailroom(skb) < NLA_ALIGN(attrlen)))\n\t\treturn NULL;\n\n\treturn __nla_reserve_nohdr(skb, attrlen);\n}\nEXPORT_SYMBOL(nla_reserve_nohdr);\n\n/**\n * __nla_put - Add a netlink attribute to a socket buffer\n * @skb: socket buffer to add attribute to\n * @attrtype: attribute type\n * @attrlen: length of attribute payload\n * @data: head of attribute payload\n *\n * The caller is responsible to ensure that the skb provides enough\n * tailroom for the attribute header and payload.\n */\nvoid __nla_put(struct sk_buff *skb, int attrtype, int attrlen,\n\t\t\t     const void *data)\n{\n\tstruct nlattr *nla;\n\n\tnla = __nla_reserve(skb, attrtype, attrlen);\n\tmemcpy(nla_data(nla), data, attrlen);\n}\nEXPORT_SYMBOL(__nla_put);\n\n/**\n * __nla_put_64bit - Add a netlink attribute to a socket buffer and align it\n * @skb: socket buffer to add attribute to\n * @attrtype: attribute type\n * @attrlen: length of attribute payload\n * @data: head of attribute payload\n * @padattr: attribute type for the padding\n *\n * The caller is responsible to ensure that the skb provides enough\n * tailroom for the attribute header and payload.\n */\nvoid __nla_put_64bit(struct sk_buff *skb, int attrtype, int attrlen,\n\t\t     const void *data, int padattr)\n{\n\tstruct nlattr *nla;\n\n\tnla = __nla_reserve_64bit(skb, attrtype, attrlen, padattr);\n\tmemcpy(nla_data(nla), data, attrlen);\n}\nEXPORT_SYMBOL(__nla_put_64bit);\n\n/**\n * __nla_put_nohdr - Add a netlink attribute without header\n * @skb: socket buffer to add attribute to\n * @attrlen: length of attribute payload\n * @data: head of attribute payload\n *\n * The caller is responsible to ensure that the skb provides enough\n * tailroom for the attribute payload.\n */\nvoid __nla_put_nohdr(struct sk_buff *skb, int attrlen, const void *data)\n{\n\tvoid *start;\n\n\tstart = __nla_reserve_nohdr(skb, attrlen);\n\tmemcpy(start, data, attrlen);\n}\nEXPORT_SYMBOL(__nla_put_nohdr);\n\n/**\n * nla_put - Add a netlink attribute to a socket buffer\n * @skb: socket buffer to add attribute to\n * @attrtype: attribute type\n * @attrlen: length of attribute payload\n * @data: head of attribute payload\n *\n * Returns -EMSGSIZE if the tailroom of the skb is insufficient to store\n * the attribute header and payload.\n */\nint nla_put(struct sk_buff *skb, int attrtype, int attrlen, const void *data)\n{\n\tif (unlikely(skb_tailroom(skb) < nla_total_size(attrlen)))\n\t\treturn -EMSGSIZE;\n\n\t__nla_put(skb, attrtype, attrlen, data);\n\treturn 0;\n}\nEXPORT_SYMBOL(nla_put);\n\n/**\n * nla_put_64bit - Add a netlink attribute to a socket buffer and align it\n * @skb: socket buffer to add attribute to\n * @attrtype: attribute type\n * @attrlen: length of attribute payload\n * @data: head of attribute payload\n * @padattr: attribute type for the padding\n *\n * Returns -EMSGSIZE if the tailroom of the skb is insufficient to store\n * the attribute header and payload.\n */\nint nla_put_64bit(struct sk_buff *skb, int attrtype, int attrlen,\n\t\t  const void *data, int padattr)\n{\n\tsize_t len;\n\n\tif (nla_need_padding_for_64bit(skb))\n\t\tlen = nla_total_size_64bit(attrlen);\n\telse\n\t\tlen = nla_total_size(attrlen);\n\tif (unlikely(skb_tailroom(skb) < len))\n\t\treturn -EMSGSIZE;\n\n\t__nla_put_64bit(skb, attrtype, attrlen, data, padattr);\n\treturn 0;\n}\nEXPORT_SYMBOL(nla_put_64bit);\n\n/**\n * nla_put_nohdr - Add a netlink attribute without header\n * @skb: socket buffer to add attribute to\n * @attrlen: length of attribute payload\n * @data: head of attribute payload\n *\n * Returns -EMSGSIZE if the tailroom of the skb is insufficient to store\n * the attribute payload.\n */\nint nla_put_nohdr(struct sk_buff *skb, int attrlen, const void *data)\n{\n\tif (unlikely(skb_tailroom(skb) < NLA_ALIGN(attrlen)))\n\t\treturn -EMSGSIZE;\n\n\t__nla_put_nohdr(skb, attrlen, data);\n\treturn 0;\n}\nEXPORT_SYMBOL(nla_put_nohdr);\n\n/**\n * nla_append - Add a netlink attribute without header or padding\n * @skb: socket buffer to add attribute to\n * @attrlen: length of attribute payload\n * @data: head of attribute payload\n *\n * Returns -EMSGSIZE if the tailroom of the skb is insufficient to store\n * the attribute payload.\n */\nint nla_append(struct sk_buff *skb, int attrlen, const void *data)\n{\n\tif (unlikely(skb_tailroom(skb) < NLA_ALIGN(attrlen)))\n\t\treturn -EMSGSIZE;\n\n\tskb_put_data(skb, data, attrlen);\n\treturn 0;\n}\nEXPORT_SYMBOL(nla_append);\n#endif\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * NETLINK      Netlink attributes\n *\n * \t\tAuthors:\tThomas Graf <tgraf@suug.ch>\n * \t\t\t\tAlexey Kuznetsov <kuznet@ms2.inr.ac.ru>\n */\n\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/jiffies.h>\n#include <linux/skbuff.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <net/netlink.h>\n\n/* For these data types, attribute length should be exactly the given\n * size. However, to maintain compatibility with broken commands, if the\n * attribute length does not match the expected size a warning is emitted\n * to the user that the command is sending invalid data and needs to be fixed.\n */\nstatic const u8 nla_attr_len[NLA_TYPE_MAX+1] = {\n\t[NLA_U8]\t= sizeof(u8),\n\t[NLA_U16]\t= sizeof(u16),\n\t[NLA_U32]\t= sizeof(u32),\n\t[NLA_U64]\t= sizeof(u64),\n\t[NLA_S8]\t= sizeof(s8),\n\t[NLA_S16]\t= sizeof(s16),\n\t[NLA_S32]\t= sizeof(s32),\n\t[NLA_S64]\t= sizeof(s64),\n};\n\nstatic const u8 nla_attr_minlen[NLA_TYPE_MAX+1] = {\n\t[NLA_U8]\t= sizeof(u8),\n\t[NLA_U16]\t= sizeof(u16),\n\t[NLA_U32]\t= sizeof(u32),\n\t[NLA_U64]\t= sizeof(u64),\n\t[NLA_MSECS]\t= sizeof(u64),\n\t[NLA_NESTED]\t= NLA_HDRLEN,\n\t[NLA_S8]\t= sizeof(s8),\n\t[NLA_S16]\t= sizeof(s16),\n\t[NLA_S32]\t= sizeof(s32),\n\t[NLA_S64]\t= sizeof(s64),\n};\n\n/*\n * Nested policies might refer back to the original\n * policy in some cases, and userspace could try to\n * abuse that and recurse by nesting in the right\n * ways. Limit recursion to avoid this problem.\n */\n#define MAX_POLICY_RECURSION_DEPTH\t10\n\nstatic int __nla_validate_parse(const struct nlattr *head, int len, int maxtype,\n\t\t\t\tconst struct nla_policy *policy,\n\t\t\t\tunsigned int validate,\n\t\t\t\tstruct netlink_ext_ack *extack,\n\t\t\t\tstruct nlattr **tb, unsigned int depth);\n\nstatic int validate_nla_bitfield32(const struct nlattr *nla,\n\t\t\t\t   const u32 valid_flags_mask)\n{\n\tconst struct nla_bitfield32 *bf = nla_data(nla);\n\n\tif (!valid_flags_mask)\n\t\treturn -EINVAL;\n\n\t/*disallow invalid bit selector */\n\tif (bf->selector & ~valid_flags_mask)\n\t\treturn -EINVAL;\n\n\t/*disallow invalid bit values */\n\tif (bf->value & ~valid_flags_mask)\n\t\treturn -EINVAL;\n\n\t/*disallow valid bit values that are not selected*/\n\tif (bf->value & ~bf->selector)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int nla_validate_array(const struct nlattr *head, int len, int maxtype,\n\t\t\t      const struct nla_policy *policy,\n\t\t\t      struct netlink_ext_ack *extack,\n\t\t\t      unsigned int validate, unsigned int depth)\n{\n\tconst struct nlattr *entry;\n\tint rem;\n\n\tnla_for_each_attr(entry, head, len, rem) {\n\t\tint ret;\n\n\t\tif (nla_len(entry) == 0)\n\t\t\tcontinue;\n\n\t\tif (nla_len(entry) < NLA_HDRLEN) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, entry,\n\t\t\t\t\t    \"Array element too short\");\n\t\t\treturn -ERANGE;\n\t\t}\n\n\t\tret = __nla_validate_parse(nla_data(entry), nla_len(entry),\n\t\t\t\t\t   maxtype, policy, validate, extack,\n\t\t\t\t\t   NULL, depth + 1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int nla_validate_int_range(const struct nla_policy *pt,\n\t\t\t\t  const struct nlattr *nla,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tbool validate_min, validate_max;\n\ts64 value;\n\n\tvalidate_min = pt->validation_type == NLA_VALIDATE_RANGE ||\n\t\t       pt->validation_type == NLA_VALIDATE_MIN;\n\tvalidate_max = pt->validation_type == NLA_VALIDATE_RANGE ||\n\t\t       pt->validation_type == NLA_VALIDATE_MAX;\n\n\tswitch (pt->type) {\n\tcase NLA_U8:\n\t\tvalue = nla_get_u8(nla);\n\t\tbreak;\n\tcase NLA_U16:\n\t\tvalue = nla_get_u16(nla);\n\t\tbreak;\n\tcase NLA_U32:\n\t\tvalue = nla_get_u32(nla);\n\t\tbreak;\n\tcase NLA_S8:\n\t\tvalue = nla_get_s8(nla);\n\t\tbreak;\n\tcase NLA_S16:\n\t\tvalue = nla_get_s16(nla);\n\t\tbreak;\n\tcase NLA_S32:\n\t\tvalue = nla_get_s32(nla);\n\t\tbreak;\n\tcase NLA_S64:\n\t\tvalue = nla_get_s64(nla);\n\t\tbreak;\n\tcase NLA_U64:\n\t\t/* treat this one specially, since it may not fit into s64 */\n\t\tif ((validate_min && nla_get_u64(nla) < pt->min) ||\n\t\t    (validate_max && nla_get_u64(nla) > pt->max)) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, nla,\n\t\t\t\t\t    \"integer out of range\");\n\t\t\treturn -ERANGE;\n\t\t}\n\t\treturn 0;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((validate_min && value < pt->min) ||\n\t    (validate_max && value > pt->max)) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, nla,\n\t\t\t\t    \"integer out of range\");\n\t\treturn -ERANGE;\n\t}\n\n\treturn 0;\n}\n\nstatic int validate_nla(const struct nlattr *nla, int maxtype,\n\t\t\tconst struct nla_policy *policy, unsigned int validate,\n\t\t\tstruct netlink_ext_ack *extack, unsigned int depth)\n{\n\tu16 strict_start_type = policy[0].strict_start_type;\n\tconst struct nla_policy *pt;\n\tint minlen = 0, attrlen = nla_len(nla), type = nla_type(nla);\n\tint err = -ERANGE;\n\n\tif (strict_start_type && type >= strict_start_type)\n\t\tvalidate |= NL_VALIDATE_STRICT;\n\n\tif (type <= 0 || type > maxtype)\n\t\treturn 0;\n\n\tpt = &policy[type];\n\n\tBUG_ON(pt->type > NLA_TYPE_MAX);\n\n\tif ((nla_attr_len[pt->type] && attrlen != nla_attr_len[pt->type]) ||\n\t    (pt->type == NLA_EXACT_LEN_WARN && attrlen != pt->len)) {\n\t\tpr_warn_ratelimited(\"netlink: '%s': attribute type %d has an invalid length.\\n\",\n\t\t\t\t    current->comm, type);\n\t\tif (validate & NL_VALIDATE_STRICT_ATTRS) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, nla,\n\t\t\t\t\t    \"invalid attribute length\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (validate & NL_VALIDATE_NESTED) {\n\t\tif ((pt->type == NLA_NESTED || pt->type == NLA_NESTED_ARRAY) &&\n\t\t    !(nla->nla_type & NLA_F_NESTED)) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, nla,\n\t\t\t\t\t    \"NLA_F_NESTED is missing\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (pt->type != NLA_NESTED && pt->type != NLA_NESTED_ARRAY &&\n\t\t    pt->type != NLA_UNSPEC && (nla->nla_type & NLA_F_NESTED)) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, nla,\n\t\t\t\t\t    \"NLA_F_NESTED not expected\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tswitch (pt->type) {\n\tcase NLA_EXACT_LEN:\n\t\tif (attrlen != pt->len)\n\t\t\tgoto out_err;\n\t\tbreak;\n\n\tcase NLA_REJECT:\n\t\tif (extack && pt->reject_message) {\n\t\t\tNL_SET_BAD_ATTR(extack, nla);\n\t\t\textack->_msg = pt->reject_message;\n\t\t\treturn -EINVAL;\n\t\t}\n\t\terr = -EINVAL;\n\t\tgoto out_err;\n\n\tcase NLA_FLAG:\n\t\tif (attrlen > 0)\n\t\t\tgoto out_err;\n\t\tbreak;\n\n\tcase NLA_BITFIELD32:\n\t\tif (attrlen != sizeof(struct nla_bitfield32))\n\t\t\tgoto out_err;\n\n\t\terr = validate_nla_bitfield32(nla, pt->bitfield32_valid);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t\tbreak;\n\n\tcase NLA_NUL_STRING:\n\t\tif (pt->len)\n\t\t\tminlen = min_t(int, attrlen, pt->len + 1);\n\t\telse\n\t\t\tminlen = attrlen;\n\n\t\tif (!minlen || memchr(nla_data(nla), '\\0', minlen) == NULL) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_err;\n\t\t}\n\t\t/* fall through */\n\n\tcase NLA_STRING:\n\t\tif (attrlen < 1)\n\t\t\tgoto out_err;\n\n\t\tif (pt->len) {\n\t\t\tchar *buf = nla_data(nla);\n\n\t\t\tif (buf[attrlen - 1] == '\\0')\n\t\t\t\tattrlen--;\n\n\t\t\tif (attrlen > pt->len)\n\t\t\t\tgoto out_err;\n\t\t}\n\t\tbreak;\n\n\tcase NLA_BINARY:\n\t\tif (pt->len && attrlen > pt->len)\n\t\t\tgoto out_err;\n\t\tbreak;\n\n\tcase NLA_NESTED:\n\t\t/* a nested attributes is allowed to be empty; if its not,\n\t\t * it must have a size of at least NLA_HDRLEN.\n\t\t */\n\t\tif (attrlen == 0)\n\t\t\tbreak;\n\t\tif (attrlen < NLA_HDRLEN)\n\t\t\tgoto out_err;\n\t\tif (pt->nested_policy) {\n\t\t\terr = __nla_validate_parse(nla_data(nla), nla_len(nla),\n\t\t\t\t\t\t   pt->len, pt->nested_policy,\n\t\t\t\t\t\t   validate, extack, NULL,\n\t\t\t\t\t\t   depth + 1);\n\t\t\tif (err < 0) {\n\t\t\t\t/*\n\t\t\t\t * return directly to preserve the inner\n\t\t\t\t * error message/attribute pointer\n\t\t\t\t */\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase NLA_NESTED_ARRAY:\n\t\t/* a nested array attribute is allowed to be empty; if its not,\n\t\t * it must have a size of at least NLA_HDRLEN.\n\t\t */\n\t\tif (attrlen == 0)\n\t\t\tbreak;\n\t\tif (attrlen < NLA_HDRLEN)\n\t\t\tgoto out_err;\n\t\tif (pt->nested_policy) {\n\t\t\tint err;\n\n\t\t\terr = nla_validate_array(nla_data(nla), nla_len(nla),\n\t\t\t\t\t\t pt->len, pt->nested_policy,\n\t\t\t\t\t\t extack, validate, depth);\n\t\t\tif (err < 0) {\n\t\t\t\t/*\n\t\t\t\t * return directly to preserve the inner\n\t\t\t\t * error message/attribute pointer\n\t\t\t\t */\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase NLA_UNSPEC:\n\t\tif (validate & NL_VALIDATE_UNSPEC) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, nla,\n\t\t\t\t\t    \"Unsupported attribute\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/* fall through */\n\tcase NLA_MIN_LEN:\n\t\tif (attrlen < pt->len)\n\t\t\tgoto out_err;\n\t\tbreak;\n\n\tdefault:\n\t\tif (pt->len)\n\t\t\tminlen = pt->len;\n\t\telse\n\t\t\tminlen = nla_attr_minlen[pt->type];\n\n\t\tif (attrlen < minlen)\n\t\t\tgoto out_err;\n\t}\n\n\t/* further validation */\n\tswitch (pt->validation_type) {\n\tcase NLA_VALIDATE_NONE:\n\t\t/* nothing to do */\n\t\tbreak;\n\tcase NLA_VALIDATE_RANGE:\n\tcase NLA_VALIDATE_MIN:\n\tcase NLA_VALIDATE_MAX:\n\t\terr = nla_validate_int_range(pt, nla, extack);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tcase NLA_VALIDATE_FUNCTION:\n\t\tif (pt->validate) {\n\t\t\terr = pt->validate(nla, extack);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn 0;\nout_err:\n\tNL_SET_ERR_MSG_ATTR(extack, nla, \"Attribute failed policy validation\");\n\treturn err;\n}\n\nstatic int __nla_validate_parse(const struct nlattr *head, int len, int maxtype,\n\t\t\t\tconst struct nla_policy *policy,\n\t\t\t\tunsigned int validate,\n\t\t\t\tstruct netlink_ext_ack *extack,\n\t\t\t\tstruct nlattr **tb, unsigned int depth)\n{\n\tconst struct nlattr *nla;\n\tint rem;\n\n\tif (depth >= MAX_POLICY_RECURSION_DEPTH) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"allowed policy recursion depth exceeded\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (tb)\n\t\tmemset(tb, 0, sizeof(struct nlattr *) * (maxtype + 1));\n\n\tnla_for_each_attr(nla, head, len, rem) {\n\t\tu16 type = nla_type(nla);\n\n\t\tif (type == 0 || type > maxtype) {\n\t\t\tif (validate & NL_VALIDATE_MAXTYPE) {\n\t\t\t\tNL_SET_ERR_MSG_ATTR(extack, nla,\n\t\t\t\t\t\t    \"Unknown attribute type\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (policy) {\n\t\t\tint err = validate_nla(nla, maxtype, policy,\n\t\t\t\t\t       validate, extack, depth);\n\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tif (tb)\n\t\t\ttb[type] = (struct nlattr *)nla;\n\t}\n\n\tif (unlikely(rem > 0)) {\n\t\tpr_warn_ratelimited(\"netlink: %d bytes leftover after parsing attributes in process `%s'.\\n\",\n\t\t\t\t    rem, current->comm);\n\t\tNL_SET_ERR_MSG(extack, \"bytes leftover after parsing attributes\");\n\t\tif (validate & NL_VALIDATE_TRAILING)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/**\n * __nla_validate - Validate a stream of attributes\n * @head: head of attribute stream\n * @len: length of attribute stream\n * @maxtype: maximum attribute type to be expected\n * @policy: validation policy\n * @validate: validation strictness\n * @extack: extended ACK report struct\n *\n * Validates all attributes in the specified attribute stream against the\n * specified policy. Validation depends on the validate flags passed, see\n * &enum netlink_validation for more details on that.\n * See documenation of struct nla_policy for more details.\n *\n * Returns 0 on success or a negative error code.\n */\nint __nla_validate(const struct nlattr *head, int len, int maxtype,\n\t\t   const struct nla_policy *policy, unsigned int validate,\n\t\t   struct netlink_ext_ack *extack)\n{\n\treturn __nla_validate_parse(head, len, maxtype, policy, validate,\n\t\t\t\t    extack, NULL, 0);\n}\nEXPORT_SYMBOL(__nla_validate);\n\n/**\n * nla_policy_len - Determin the max. length of a policy\n * @policy: policy to use\n * @n: number of policies\n *\n * Determines the max. length of the policy.  It is currently used\n * to allocated Netlink buffers roughly the size of the actual\n * message.\n *\n * Returns 0 on success or a negative error code.\n */\nint\nnla_policy_len(const struct nla_policy *p, int n)\n{\n\tint i, len = 0;\n\n\tfor (i = 0; i < n; i++, p++) {\n\t\tif (p->len)\n\t\t\tlen += nla_total_size(p->len);\n\t\telse if (nla_attr_len[p->type])\n\t\t\tlen += nla_total_size(nla_attr_len[p->type]);\n\t\telse if (nla_attr_minlen[p->type])\n\t\t\tlen += nla_total_size(nla_attr_minlen[p->type]);\n\t}\n\n\treturn len;\n}\nEXPORT_SYMBOL(nla_policy_len);\n\n/**\n * __nla_parse - Parse a stream of attributes into a tb buffer\n * @tb: destination array with maxtype+1 elements\n * @maxtype: maximum attribute type to be expected\n * @head: head of attribute stream\n * @len: length of attribute stream\n * @policy: validation policy\n * @validate: validation strictness\n * @extack: extended ACK pointer\n *\n * Parses a stream of attributes and stores a pointer to each attribute in\n * the tb array accessible via the attribute type.\n * Validation is controlled by the @validate parameter.\n *\n * Returns 0 on success or a negative error code.\n */\nint __nla_parse(struct nlattr **tb, int maxtype,\n\t\tconst struct nlattr *head, int len,\n\t\tconst struct nla_policy *policy, unsigned int validate,\n\t\tstruct netlink_ext_ack *extack)\n{\n\treturn __nla_validate_parse(head, len, maxtype, policy, validate,\n\t\t\t\t    extack, tb, 0);\n}\nEXPORT_SYMBOL(__nla_parse);\n\n/**\n * nla_find - Find a specific attribute in a stream of attributes\n * @head: head of attribute stream\n * @len: length of attribute stream\n * @attrtype: type of attribute to look for\n *\n * Returns the first attribute in the stream matching the specified type.\n */\nstruct nlattr *nla_find(const struct nlattr *head, int len, int attrtype)\n{\n\tconst struct nlattr *nla;\n\tint rem;\n\n\tnla_for_each_attr(nla, head, len, rem)\n\t\tif (nla_type(nla) == attrtype)\n\t\t\treturn (struct nlattr *)nla;\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(nla_find);\n\n/**\n * nla_strlcpy - Copy string attribute payload into a sized buffer\n * @dst: where to copy the string to\n * @nla: attribute to copy the string from\n * @dstsize: size of destination buffer\n *\n * Copies at most dstsize - 1 bytes into the destination buffer.\n * The result is always a valid NUL-terminated string. Unlike\n * strlcpy the destination buffer is always padded out.\n *\n * Returns the length of the source buffer.\n */\nsize_t nla_strlcpy(char *dst, const struct nlattr *nla, size_t dstsize)\n{\n\tsize_t srclen = nla_len(nla);\n\tchar *src = nla_data(nla);\n\n\tif (srclen > 0 && src[srclen - 1] == '\\0')\n\t\tsrclen--;\n\n\tif (dstsize > 0) {\n\t\tsize_t len = (srclen >= dstsize) ? dstsize - 1 : srclen;\n\n\t\tmemset(dst, 0, dstsize);\n\t\tmemcpy(dst, src, len);\n\t}\n\n\treturn srclen;\n}\nEXPORT_SYMBOL(nla_strlcpy);\n\n/**\n * nla_strdup - Copy string attribute payload into a newly allocated buffer\n * @nla: attribute to copy the string from\n * @flags: the type of memory to allocate (see kmalloc).\n *\n * Returns a pointer to the allocated buffer or NULL on error.\n */\nchar *nla_strdup(const struct nlattr *nla, gfp_t flags)\n{\n\tsize_t srclen = nla_len(nla);\n\tchar *src = nla_data(nla), *dst;\n\n\tif (srclen > 0 && src[srclen - 1] == '\\0')\n\t\tsrclen--;\n\n\tdst = kmalloc(srclen + 1, flags);\n\tif (dst != NULL) {\n\t\tmemcpy(dst, src, srclen);\n\t\tdst[srclen] = '\\0';\n\t}\n\treturn dst;\n}\nEXPORT_SYMBOL(nla_strdup);\n\n/**\n * nla_memcpy - Copy a netlink attribute into another memory area\n * @dest: where to copy to memcpy\n * @src: netlink attribute to copy from\n * @count: size of the destination area\n *\n * Note: The number of bytes copied is limited by the length of\n *       attribute's payload. memcpy\n *\n * Returns the number of bytes copied.\n */\nint nla_memcpy(void *dest, const struct nlattr *src, int count)\n{\n\tint minlen = min_t(int, count, nla_len(src));\n\n\tmemcpy(dest, nla_data(src), minlen);\n\tif (count > minlen)\n\t\tmemset(dest + minlen, 0, count - minlen);\n\n\treturn minlen;\n}\nEXPORT_SYMBOL(nla_memcpy);\n\n/**\n * nla_memcmp - Compare an attribute with sized memory area\n * @nla: netlink attribute\n * @data: memory area\n * @size: size of memory area\n */\nint nla_memcmp(const struct nlattr *nla, const void *data,\n\t\t\t     size_t size)\n{\n\tint d = nla_len(nla) - size;\n\n\tif (d == 0)\n\t\td = memcmp(nla_data(nla), data, size);\n\n\treturn d;\n}\nEXPORT_SYMBOL(nla_memcmp);\n\n/**\n * nla_strcmp - Compare a string attribute against a string\n * @nla: netlink string attribute\n * @str: another string\n */\nint nla_strcmp(const struct nlattr *nla, const char *str)\n{\n\tint len = strlen(str);\n\tchar *buf = nla_data(nla);\n\tint attrlen = nla_len(nla);\n\tint d;\n\n\tif (attrlen > 0 && buf[attrlen - 1] == '\\0')\n\t\tattrlen--;\n\n\td = attrlen - len;\n\tif (d == 0)\n\t\td = memcmp(nla_data(nla), str, len);\n\n\treturn d;\n}\nEXPORT_SYMBOL(nla_strcmp);\n\n#ifdef CONFIG_NET\n/**\n * __nla_reserve - reserve room for attribute on the skb\n * @skb: socket buffer to reserve room on\n * @attrtype: attribute type\n * @attrlen: length of attribute payload\n *\n * Adds a netlink attribute header to a socket buffer and reserves\n * room for the payload but does not copy it.\n *\n * The caller is responsible to ensure that the skb provides enough\n * tailroom for the attribute header and payload.\n */\nstruct nlattr *__nla_reserve(struct sk_buff *skb, int attrtype, int attrlen)\n{\n\tstruct nlattr *nla;\n\n\tnla = skb_put(skb, nla_total_size(attrlen));\n\tnla->nla_type = attrtype;\n\tnla->nla_len = nla_attr_size(attrlen);\n\n\tmemset((unsigned char *) nla + nla->nla_len, 0, nla_padlen(attrlen));\n\n\treturn nla;\n}\nEXPORT_SYMBOL(__nla_reserve);\n\n/**\n * __nla_reserve_64bit - reserve room for attribute on the skb and align it\n * @skb: socket buffer to reserve room on\n * @attrtype: attribute type\n * @attrlen: length of attribute payload\n * @padattr: attribute type for the padding\n *\n * Adds a netlink attribute header to a socket buffer and reserves\n * room for the payload but does not copy it. It also ensure that this\n * attribute will have a 64-bit aligned nla_data() area.\n *\n * The caller is responsible to ensure that the skb provides enough\n * tailroom for the attribute header and payload.\n */\nstruct nlattr *__nla_reserve_64bit(struct sk_buff *skb, int attrtype,\n\t\t\t\t   int attrlen, int padattr)\n{\n\tif (nla_need_padding_for_64bit(skb))\n\t\tnla_align_64bit(skb, padattr);\n\n\treturn __nla_reserve(skb, attrtype, attrlen);\n}\nEXPORT_SYMBOL(__nla_reserve_64bit);\n\n/**\n * __nla_reserve_nohdr - reserve room for attribute without header\n * @skb: socket buffer to reserve room on\n * @attrlen: length of attribute payload\n *\n * Reserves room for attribute payload without a header.\n *\n * The caller is responsible to ensure that the skb provides enough\n * tailroom for the payload.\n */\nvoid *__nla_reserve_nohdr(struct sk_buff *skb, int attrlen)\n{\n\treturn skb_put_zero(skb, NLA_ALIGN(attrlen));\n}\nEXPORT_SYMBOL(__nla_reserve_nohdr);\n\n/**\n * nla_reserve - reserve room for attribute on the skb\n * @skb: socket buffer to reserve room on\n * @attrtype: attribute type\n * @attrlen: length of attribute payload\n *\n * Adds a netlink attribute header to a socket buffer and reserves\n * room for the payload but does not copy it.\n *\n * Returns NULL if the tailroom of the skb is insufficient to store\n * the attribute header and payload.\n */\nstruct nlattr *nla_reserve(struct sk_buff *skb, int attrtype, int attrlen)\n{\n\tif (unlikely(skb_tailroom(skb) < nla_total_size(attrlen)))\n\t\treturn NULL;\n\n\treturn __nla_reserve(skb, attrtype, attrlen);\n}\nEXPORT_SYMBOL(nla_reserve);\n\n/**\n * nla_reserve_64bit - reserve room for attribute on the skb and align it\n * @skb: socket buffer to reserve room on\n * @attrtype: attribute type\n * @attrlen: length of attribute payload\n * @padattr: attribute type for the padding\n *\n * Adds a netlink attribute header to a socket buffer and reserves\n * room for the payload but does not copy it. It also ensure that this\n * attribute will have a 64-bit aligned nla_data() area.\n *\n * Returns NULL if the tailroom of the skb is insufficient to store\n * the attribute header and payload.\n */\nstruct nlattr *nla_reserve_64bit(struct sk_buff *skb, int attrtype, int attrlen,\n\t\t\t\t int padattr)\n{\n\tsize_t len;\n\n\tif (nla_need_padding_for_64bit(skb))\n\t\tlen = nla_total_size_64bit(attrlen);\n\telse\n\t\tlen = nla_total_size(attrlen);\n\tif (unlikely(skb_tailroom(skb) < len))\n\t\treturn NULL;\n\n\treturn __nla_reserve_64bit(skb, attrtype, attrlen, padattr);\n}\nEXPORT_SYMBOL(nla_reserve_64bit);\n\n/**\n * nla_reserve_nohdr - reserve room for attribute without header\n * @skb: socket buffer to reserve room on\n * @attrlen: length of attribute payload\n *\n * Reserves room for attribute payload without a header.\n *\n * Returns NULL if the tailroom of the skb is insufficient to store\n * the attribute payload.\n */\nvoid *nla_reserve_nohdr(struct sk_buff *skb, int attrlen)\n{\n\tif (unlikely(skb_tailroom(skb) < NLA_ALIGN(attrlen)))\n\t\treturn NULL;\n\n\treturn __nla_reserve_nohdr(skb, attrlen);\n}\nEXPORT_SYMBOL(nla_reserve_nohdr);\n\n/**\n * __nla_put - Add a netlink attribute to a socket buffer\n * @skb: socket buffer to add attribute to\n * @attrtype: attribute type\n * @attrlen: length of attribute payload\n * @data: head of attribute payload\n *\n * The caller is responsible to ensure that the skb provides enough\n * tailroom for the attribute header and payload.\n */\nvoid __nla_put(struct sk_buff *skb, int attrtype, int attrlen,\n\t\t\t     const void *data)\n{\n\tstruct nlattr *nla;\n\n\tnla = __nla_reserve(skb, attrtype, attrlen);\n\tmemcpy(nla_data(nla), data, attrlen);\n}\nEXPORT_SYMBOL(__nla_put);\n\n/**\n * __nla_put_64bit - Add a netlink attribute to a socket buffer and align it\n * @skb: socket buffer to add attribute to\n * @attrtype: attribute type\n * @attrlen: length of attribute payload\n * @data: head of attribute payload\n * @padattr: attribute type for the padding\n *\n * The caller is responsible to ensure that the skb provides enough\n * tailroom for the attribute header and payload.\n */\nvoid __nla_put_64bit(struct sk_buff *skb, int attrtype, int attrlen,\n\t\t     const void *data, int padattr)\n{\n\tstruct nlattr *nla;\n\n\tnla = __nla_reserve_64bit(skb, attrtype, attrlen, padattr);\n\tmemcpy(nla_data(nla), data, attrlen);\n}\nEXPORT_SYMBOL(__nla_put_64bit);\n\n/**\n * __nla_put_nohdr - Add a netlink attribute without header\n * @skb: socket buffer to add attribute to\n * @attrlen: length of attribute payload\n * @data: head of attribute payload\n *\n * The caller is responsible to ensure that the skb provides enough\n * tailroom for the attribute payload.\n */\nvoid __nla_put_nohdr(struct sk_buff *skb, int attrlen, const void *data)\n{\n\tvoid *start;\n\n\tstart = __nla_reserve_nohdr(skb, attrlen);\n\tmemcpy(start, data, attrlen);\n}\nEXPORT_SYMBOL(__nla_put_nohdr);\n\n/**\n * nla_put - Add a netlink attribute to a socket buffer\n * @skb: socket buffer to add attribute to\n * @attrtype: attribute type\n * @attrlen: length of attribute payload\n * @data: head of attribute payload\n *\n * Returns -EMSGSIZE if the tailroom of the skb is insufficient to store\n * the attribute header and payload.\n */\nint nla_put(struct sk_buff *skb, int attrtype, int attrlen, const void *data)\n{\n\tif (unlikely(skb_tailroom(skb) < nla_total_size(attrlen)))\n\t\treturn -EMSGSIZE;\n\n\t__nla_put(skb, attrtype, attrlen, data);\n\treturn 0;\n}\nEXPORT_SYMBOL(nla_put);\n\n/**\n * nla_put_64bit - Add a netlink attribute to a socket buffer and align it\n * @skb: socket buffer to add attribute to\n * @attrtype: attribute type\n * @attrlen: length of attribute payload\n * @data: head of attribute payload\n * @padattr: attribute type for the padding\n *\n * Returns -EMSGSIZE if the tailroom of the skb is insufficient to store\n * the attribute header and payload.\n */\nint nla_put_64bit(struct sk_buff *skb, int attrtype, int attrlen,\n\t\t  const void *data, int padattr)\n{\n\tsize_t len;\n\n\tif (nla_need_padding_for_64bit(skb))\n\t\tlen = nla_total_size_64bit(attrlen);\n\telse\n\t\tlen = nla_total_size(attrlen);\n\tif (unlikely(skb_tailroom(skb) < len))\n\t\treturn -EMSGSIZE;\n\n\t__nla_put_64bit(skb, attrtype, attrlen, data, padattr);\n\treturn 0;\n}\nEXPORT_SYMBOL(nla_put_64bit);\n\n/**\n * nla_put_nohdr - Add a netlink attribute without header\n * @skb: socket buffer to add attribute to\n * @attrlen: length of attribute payload\n * @data: head of attribute payload\n *\n * Returns -EMSGSIZE if the tailroom of the skb is insufficient to store\n * the attribute payload.\n */\nint nla_put_nohdr(struct sk_buff *skb, int attrlen, const void *data)\n{\n\tif (unlikely(skb_tailroom(skb) < NLA_ALIGN(attrlen)))\n\t\treturn -EMSGSIZE;\n\n\t__nla_put_nohdr(skb, attrlen, data);\n\treturn 0;\n}\nEXPORT_SYMBOL(nla_put_nohdr);\n\n/**\n * nla_append - Add a netlink attribute without header or padding\n * @skb: socket buffer to add attribute to\n * @attrlen: length of attribute payload\n * @data: head of attribute payload\n *\n * Returns -EMSGSIZE if the tailroom of the skb is insufficient to store\n * the attribute payload.\n */\nint nla_append(struct sk_buff *skb, int attrlen, const void *data)\n{\n\tif (unlikely(skb_tailroom(skb) < NLA_ALIGN(attrlen)))\n\t\treturn -EMSGSIZE;\n\n\tskb_put_data(skb, data, attrlen);\n\treturn 0;\n}\nEXPORT_SYMBOL(nla_append);\n#endif\n"], "filenames": ["lib/nlattr.c"], "buggy_code_start_loc": [46], "buggy_code_end_loc": [480], "fixing_code_start_loc": [47], "fixing_code_end_loc": [502], "type": "CWE-674", "message": "An issue was discovered in the Linux kernel before 5.8. lib/nlattr.c allows attackers to cause a denial of service (unbounded recursion) via a nested Netlink policy with a back reference.", "other": {"cve": {"id": "CVE-2020-36691", "sourceIdentifier": "cve@mitre.org", "published": "2023-03-24T17:15:07.313", "lastModified": "2023-03-29T12:58:58.473", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in the Linux kernel before 5.8. lib/nlattr.c allows attackers to cause a denial of service (unbounded recursion) via a nested Netlink policy with a back reference."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-674"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.8", "matchCriteriaId": "6A9F82A0-987A-4B8F-A2BB-3BC03ECCCF01"}]}]}], "references": [{"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.8", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://github.com/torvalds/linux/commit/7690aa1cdf7c4565ad6b013b324c28b685505e24", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/7690aa1cdf7c4565ad6b013b324c28b685505e24"}}