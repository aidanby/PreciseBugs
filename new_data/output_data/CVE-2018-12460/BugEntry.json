{"buggy_code": ["/*\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"config.h\"\n#include \"libavutil/attributes.h\"\n#include \"libavutil/common.h\"\n#include \"avcodec.h\"\n#include \"dct.h\"\n#include \"faanidct.h\"\n#include \"idctdsp.h\"\n#include \"simple_idct.h\"\n#include \"xvididct.h\"\n\nav_cold void ff_init_scantable(uint8_t *permutation, ScanTable *st,\n                               const uint8_t *src_scantable)\n{\n    int i, end;\n\n    st->scantable = src_scantable;\n\n    for (i = 0; i < 64; i++) {\n        int j = src_scantable[i];\n        st->permutated[i] = permutation[j];\n    }\n\n    end = -1;\n    for (i = 0; i < 64; i++) {\n        int j = st->permutated[i];\n        if (j > end)\n            end = j;\n        st->raster_end[i] = end;\n    }\n}\n\nav_cold void ff_init_scantable_permutation(uint8_t *idct_permutation,\n                                           enum idct_permutation_type perm_type)\n{\n    int i;\n\n    if (ARCH_X86)\n        if (ff_init_scantable_permutation_x86(idct_permutation,\n                                              perm_type))\n            return;\n\n    switch (perm_type) {\n    case FF_IDCT_PERM_NONE:\n        for (i = 0; i < 64; i++)\n            idct_permutation[i] = i;\n        break;\n    case FF_IDCT_PERM_LIBMPEG2:\n        for (i = 0; i < 64; i++)\n            idct_permutation[i] = (i & 0x38) | ((i & 6) >> 1) | ((i & 1) << 2);\n        break;\n    case FF_IDCT_PERM_TRANSPOSE:\n        for (i = 0; i < 64; i++)\n            idct_permutation[i] = ((i & 7) << 3) | (i >> 3);\n        break;\n    case FF_IDCT_PERM_PARTTRANS:\n        for (i = 0; i < 64; i++)\n            idct_permutation[i] = (i & 0x24) | ((i & 3) << 3) | ((i >> 3) & 3);\n        break;\n    default:\n        av_log(NULL, AV_LOG_ERROR,\n               \"Internal error, IDCT permutation not set\\n\");\n    }\n}\n\nvoid ff_put_pixels_clamped_c(const int16_t *block, uint8_t *av_restrict pixels,\n                             ptrdiff_t line_size)\n{\n    int i;\n\n    /* read the pixels */\n    for (i = 0; i < 8; i++) {\n        pixels[0] = av_clip_uint8(block[0]);\n        pixels[1] = av_clip_uint8(block[1]);\n        pixels[2] = av_clip_uint8(block[2]);\n        pixels[3] = av_clip_uint8(block[3]);\n        pixels[4] = av_clip_uint8(block[4]);\n        pixels[5] = av_clip_uint8(block[5]);\n        pixels[6] = av_clip_uint8(block[6]);\n        pixels[7] = av_clip_uint8(block[7]);\n\n        pixels += line_size;\n        block  += 8;\n    }\n}\n\nstatic void put_pixels_clamped4_c(const int16_t *block, uint8_t *av_restrict pixels,\n                                 int line_size)\n{\n    int i;\n\n    /* read the pixels */\n    for(i=0;i<4;i++) {\n        pixels[0] = av_clip_uint8(block[0]);\n        pixels[1] = av_clip_uint8(block[1]);\n        pixels[2] = av_clip_uint8(block[2]);\n        pixels[3] = av_clip_uint8(block[3]);\n\n        pixels += line_size;\n        block += 8;\n    }\n}\n\nstatic void put_pixels_clamped2_c(const int16_t *block, uint8_t *av_restrict pixels,\n                                 int line_size)\n{\n    int i;\n\n    /* read the pixels */\n    for(i=0;i<2;i++) {\n        pixels[0] = av_clip_uint8(block[0]);\n        pixels[1] = av_clip_uint8(block[1]);\n\n        pixels += line_size;\n        block += 8;\n    }\n}\n\nstatic void put_signed_pixels_clamped_c(const int16_t *block,\n                                        uint8_t *av_restrict pixels,\n                                        ptrdiff_t line_size)\n{\n    int i, j;\n\n    for (i = 0; i < 8; i++) {\n        for (j = 0; j < 8; j++) {\n            if (*block < -128)\n                *pixels = 0;\n            else if (*block > 127)\n                *pixels = 255;\n            else\n                *pixels = (uint8_t) (*block + 128);\n            block++;\n            pixels++;\n        }\n        pixels += (line_size - 8);\n    }\n}\n\nvoid ff_add_pixels_clamped_c(const int16_t *block, uint8_t *av_restrict pixels,\n                             ptrdiff_t line_size)\n{\n    int i;\n\n    /* read the pixels */\n    for (i = 0; i < 8; i++) {\n        pixels[0] = av_clip_uint8(pixels[0] + block[0]);\n        pixels[1] = av_clip_uint8(pixels[1] + block[1]);\n        pixels[2] = av_clip_uint8(pixels[2] + block[2]);\n        pixels[3] = av_clip_uint8(pixels[3] + block[3]);\n        pixels[4] = av_clip_uint8(pixels[4] + block[4]);\n        pixels[5] = av_clip_uint8(pixels[5] + block[5]);\n        pixels[6] = av_clip_uint8(pixels[6] + block[6]);\n        pixels[7] = av_clip_uint8(pixels[7] + block[7]);\n        pixels   += line_size;\n        block    += 8;\n    }\n}\n\nstatic void add_pixels_clamped4_c(const int16_t *block, uint8_t *av_restrict pixels,\n                          int line_size)\n{\n    int i;\n\n    /* read the pixels */\n    for(i=0;i<4;i++) {\n        pixels[0] = av_clip_uint8(pixels[0] + block[0]);\n        pixels[1] = av_clip_uint8(pixels[1] + block[1]);\n        pixels[2] = av_clip_uint8(pixels[2] + block[2]);\n        pixels[3] = av_clip_uint8(pixels[3] + block[3]);\n        pixels += line_size;\n        block += 8;\n    }\n}\n\nstatic void add_pixels_clamped2_c(const int16_t *block, uint8_t *av_restrict pixels,\n                          int line_size)\n{\n    int i;\n\n    /* read the pixels */\n    for(i=0;i<2;i++) {\n        pixels[0] = av_clip_uint8(pixels[0] + block[0]);\n        pixels[1] = av_clip_uint8(pixels[1] + block[1]);\n        pixels += line_size;\n        block += 8;\n    }\n}\n\nstatic void ff_jref_idct4_put(uint8_t *dest, ptrdiff_t line_size, int16_t *block)\n{\n    ff_j_rev_dct4 (block);\n    put_pixels_clamped4_c(block, dest, line_size);\n}\nstatic void ff_jref_idct4_add(uint8_t *dest, ptrdiff_t line_size, int16_t *block)\n{\n    ff_j_rev_dct4 (block);\n    add_pixels_clamped4_c(block, dest, line_size);\n}\n\nstatic void ff_jref_idct2_put(uint8_t *dest, ptrdiff_t line_size, int16_t *block)\n{\n    ff_j_rev_dct2 (block);\n    put_pixels_clamped2_c(block, dest, line_size);\n}\nstatic void ff_jref_idct2_add(uint8_t *dest, ptrdiff_t line_size, int16_t *block)\n{\n    ff_j_rev_dct2 (block);\n    add_pixels_clamped2_c(block, dest, line_size);\n}\n\nstatic void ff_jref_idct1_put(uint8_t *dest, ptrdiff_t line_size, int16_t *block)\n{\n    dest[0] = av_clip_uint8((block[0] + 4)>>3);\n}\nstatic void ff_jref_idct1_add(uint8_t *dest, ptrdiff_t line_size, int16_t *block)\n{\n    dest[0] = av_clip_uint8(dest[0] + ((block[0] + 4)>>3));\n}\n\nav_cold void ff_idctdsp_init(IDCTDSPContext *c, AVCodecContext *avctx)\n{\n    const unsigned high_bit_depth = avctx->bits_per_raw_sample > 8;\n\n    if (avctx->lowres==1) {\n        c->idct_put  = ff_jref_idct4_put;\n        c->idct_add  = ff_jref_idct4_add;\n        c->idct      = ff_j_rev_dct4;\n        c->perm_type = FF_IDCT_PERM_NONE;\n    } else if (avctx->lowres==2) {\n        c->idct_put  = ff_jref_idct2_put;\n        c->idct_add  = ff_jref_idct2_add;\n        c->idct      = ff_j_rev_dct2;\n        c->perm_type = FF_IDCT_PERM_NONE;\n    } else if (avctx->lowres==3) {\n        c->idct_put  = ff_jref_idct1_put;\n        c->idct_add  = ff_jref_idct1_add;\n        c->idct      = ff_j_rev_dct1;\n        c->perm_type = FF_IDCT_PERM_NONE;\n    } else {\n        if (avctx->bits_per_raw_sample == 10 || avctx->bits_per_raw_sample == 9) {\n            /* 10-bit MPEG-4 Simple Studio Profile requires a higher precision IDCT\n               However, it only uses idct_put */\n            if (avctx->codec_id == AV_CODEC_ID_MPEG4 && avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO)\n                c->idct_put              = ff_simple_idct_put_int32_10bit;\n            else {\n                c->idct_put              = ff_simple_idct_put_int16_10bit;\n                c->idct_add              = ff_simple_idct_add_int16_10bit;\n                c->idct                  = ff_simple_idct_int16_10bit;\n            }\n            c->perm_type             = FF_IDCT_PERM_NONE;\n        } else if (avctx->bits_per_raw_sample == 12) {\n            c->idct_put              = ff_simple_idct_put_int16_12bit;\n            c->idct_add              = ff_simple_idct_add_int16_12bit;\n            c->idct                  = ff_simple_idct_int16_12bit;\n            c->perm_type             = FF_IDCT_PERM_NONE;\n        } else {\n            if (avctx->idct_algo == FF_IDCT_INT) {\n                c->idct_put  = ff_jref_idct_put;\n                c->idct_add  = ff_jref_idct_add;\n                c->idct      = ff_j_rev_dct;\n                c->perm_type = FF_IDCT_PERM_LIBMPEG2;\n#if CONFIG_FAANIDCT\n            } else if (avctx->idct_algo == FF_IDCT_FAAN) {\n                c->idct_put  = ff_faanidct_put;\n                c->idct_add  = ff_faanidct_add;\n                c->idct      = ff_faanidct;\n                c->perm_type = FF_IDCT_PERM_NONE;\n#endif /* CONFIG_FAANIDCT */\n            } else { // accurate/default\n                /* Be sure FF_IDCT_NONE will select this one, since it uses FF_IDCT_PERM_NONE */\n                c->idct_put  = ff_simple_idct_put_int16_8bit;\n                c->idct_add  = ff_simple_idct_add_int16_8bit;\n                c->idct      = ff_simple_idct_int16_8bit;\n                c->perm_type = FF_IDCT_PERM_NONE;\n            }\n        }\n    }\n\n    c->put_pixels_clamped        = ff_put_pixels_clamped_c;\n    c->put_signed_pixels_clamped = put_signed_pixels_clamped_c;\n    c->add_pixels_clamped        = ff_add_pixels_clamped_c;\n\n    if (CONFIG_MPEG4_DECODER && avctx->idct_algo == FF_IDCT_XVID)\n        ff_xvid_idct_init(c, avctx);\n\n    if (ARCH_AARCH64)\n        ff_idctdsp_init_aarch64(c, avctx, high_bit_depth);\n    if (ARCH_ALPHA)\n        ff_idctdsp_init_alpha(c, avctx, high_bit_depth);\n    if (ARCH_ARM)\n        ff_idctdsp_init_arm(c, avctx, high_bit_depth);\n    if (ARCH_PPC)\n        ff_idctdsp_init_ppc(c, avctx, high_bit_depth);\n    if (ARCH_X86)\n        ff_idctdsp_init_x86(c, avctx, high_bit_depth);\n    if (ARCH_MIPS)\n        ff_idctdsp_init_mips(c, avctx, high_bit_depth);\n\n    ff_init_scantable_permutation(c->idct_permutation,\n                                  c->perm_type);\n}\n", "/*\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#ifndef AVCODEC_IDCTDSP_H\n#define AVCODEC_IDCTDSP_H\n\n#include <stdint.h>\n\n#include \"config.h\"\n\n#include \"avcodec.h\"\n\n/**\n * Scantable.\n */\ntypedef struct ScanTable {\n    const uint8_t *scantable;\n    uint8_t permutated[64];\n    uint8_t raster_end[64];\n} ScanTable;\n\nenum idct_permutation_type {\n    FF_IDCT_PERM_NONE,\n    FF_IDCT_PERM_LIBMPEG2,\n    FF_IDCT_PERM_SIMPLE,\n    FF_IDCT_PERM_TRANSPOSE,\n    FF_IDCT_PERM_PARTTRANS,\n    FF_IDCT_PERM_SSE2,\n};\n\nvoid ff_init_scantable(uint8_t *permutation, ScanTable *st,\n                       const uint8_t *src_scantable);\nvoid ff_init_scantable_permutation(uint8_t *idct_permutation,\n                                   enum idct_permutation_type perm_type);\nint ff_init_scantable_permutation_x86(uint8_t *idct_permutation,\n                                      enum idct_permutation_type perm_type);\n\ntypedef struct IDCTDSPContext {\n    /* pixel ops : interface with DCT */\n    void (*put_pixels_clamped)(const int16_t *block /* align 16 */,\n                               uint8_t *av_restrict pixels /* align 8 */,\n                               ptrdiff_t line_size);\n    void (*put_signed_pixels_clamped)(const int16_t *block /* align 16 */,\n                                      uint8_t *av_restrict pixels /* align 8 */,\n                                      ptrdiff_t line_size);\n    void (*add_pixels_clamped)(const int16_t *block /* align 16 */,\n                               uint8_t *av_restrict pixels /* align 8 */,\n                               ptrdiff_t line_size);\n\n    void (*idct)(int16_t *block /* align 16 */);\n\n    /**\n     * block -> idct -> clip to unsigned 8 bit -> dest.\n     * (-1392, 0, 0, ...) -> idct -> (-174, -174, ...) -> put -> (0, 0, ...)\n     * @param line_size size in bytes of a horizontal line of dest\n     */\n    void (*idct_put)(uint8_t *dest /* align 8 */,\n                     ptrdiff_t line_size, int16_t *block /* align 16 */);\n\n    /**\n     * block -> idct -> add dest -> clip to unsigned 8 bit -> dest.\n     * @param line_size size in bytes of a horizontal line of dest\n     */\n    void (*idct_add)(uint8_t *dest /* align 8 */,\n                     ptrdiff_t line_size, int16_t *block /* align 16 */);\n\n    /**\n     * IDCT input permutation.\n     * Several optimized IDCTs need a permutated input (relative to the\n     * normal order of the reference IDCT).\n     * This permutation must be performed before the idct_put/add.\n     * Note, normally this can be merged with the zigzag/alternate scan<br>\n     * An example to avoid confusion:\n     * - (->decode coeffs -> zigzag reorder -> dequant -> reference IDCT -> ...)\n     * - (x -> reference DCT -> reference IDCT -> x)\n     * - (x -> reference DCT -> simple_mmx_perm = idct_permutation\n     *    -> simple_idct_mmx -> x)\n     * - (-> decode coeffs -> zigzag reorder -> simple_mmx_perm -> dequant\n     *    -> simple_idct_mmx -> ...)\n     */\n    uint8_t idct_permutation[64];\n    enum idct_permutation_type perm_type;\n} IDCTDSPContext;\n\nvoid ff_put_pixels_clamped_c(const int16_t *block, uint8_t *av_restrict pixels,\n                             ptrdiff_t line_size);\nvoid ff_add_pixels_clamped_c(const int16_t *block, uint8_t *av_restrict pixels,\n                             ptrdiff_t line_size);\n\nvoid ff_idctdsp_init(IDCTDSPContext *c, AVCodecContext *avctx);\n\nvoid ff_idctdsp_init_aarch64(IDCTDSPContext *c, AVCodecContext *avctx,\n                             unsigned high_bit_depth);\nvoid ff_idctdsp_init_alpha(IDCTDSPContext *c, AVCodecContext *avctx,\n                           unsigned high_bit_depth);\nvoid ff_idctdsp_init_arm(IDCTDSPContext *c, AVCodecContext *avctx,\n                         unsigned high_bit_depth);\nvoid ff_idctdsp_init_ppc(IDCTDSPContext *c, AVCodecContext *avctx,\n                         unsigned high_bit_depth);\nvoid ff_idctdsp_init_x86(IDCTDSPContext *c, AVCodecContext *avctx,\n                         unsigned high_bit_depth);\nvoid ff_idctdsp_init_mips(IDCTDSPContext *c, AVCodecContext *avctx,\n                          unsigned high_bit_depth);\n\n#endif /* AVCODEC_IDCTDSP_H */\n", "/*\n * The simplest mpeg encoder (well, it was the simplest!)\n * Copyright (c) 2000,2001 Fabrice Bellard\n * Copyright (c) 2002-2004 Michael Niedermayer <michaelni@gmx.at>\n *\n * 4MV & hq & B-frame encoding stuff by Michael Niedermayer <michaelni@gmx.at>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * The simplest mpeg encoder (well, it was the simplest!).\n */\n\n#include \"libavutil/attributes.h\"\n#include \"libavutil/avassert.h\"\n#include \"libavutil/imgutils.h\"\n#include \"libavutil/internal.h\"\n#include \"libavutil/motion_vector.h\"\n#include \"libavutil/timer.h\"\n#include \"avcodec.h\"\n#include \"blockdsp.h\"\n#include \"h264chroma.h\"\n#include \"idctdsp.h\"\n#include \"internal.h\"\n#include \"mathops.h\"\n#include \"mpeg_er.h\"\n#include \"mpegutils.h\"\n#include \"mpegvideo.h\"\n#include \"mpegvideodata.h\"\n#include \"mjpegenc.h\"\n#include \"msmpeg4.h\"\n#include \"qpeldsp.h\"\n#include \"thread.h\"\n#include \"wmv2.h\"\n#include <limits.h>\n\nstatic void dct_unquantize_mpeg1_intra_c(MpegEncContext *s,\n                                   int16_t *block, int n, int qscale)\n{\n    int i, level, nCoeffs;\n    const uint16_t *quant_matrix;\n\n    nCoeffs= s->block_last_index[n];\n\n    block[0] *= n < 4 ? s->y_dc_scale : s->c_dc_scale;\n    /* XXX: only MPEG-1 */\n    quant_matrix = s->intra_matrix;\n    for(i=1;i<=nCoeffs;i++) {\n        int j= s->intra_scantable.permutated[i];\n        level = block[j];\n        if (level) {\n            if (level < 0) {\n                level = -level;\n                level = (int)(level * qscale * quant_matrix[j]) >> 3;\n                level = (level - 1) | 1;\n                level = -level;\n            } else {\n                level = (int)(level * qscale * quant_matrix[j]) >> 3;\n                level = (level - 1) | 1;\n            }\n            block[j] = level;\n        }\n    }\n}\n\nstatic void dct_unquantize_mpeg1_inter_c(MpegEncContext *s,\n                                   int16_t *block, int n, int qscale)\n{\n    int i, level, nCoeffs;\n    const uint16_t *quant_matrix;\n\n    nCoeffs= s->block_last_index[n];\n\n    quant_matrix = s->inter_matrix;\n    for(i=0; i<=nCoeffs; i++) {\n        int j= s->intra_scantable.permutated[i];\n        level = block[j];\n        if (level) {\n            if (level < 0) {\n                level = -level;\n                level = (((level << 1) + 1) * qscale *\n                         ((int) (quant_matrix[j]))) >> 4;\n                level = (level - 1) | 1;\n                level = -level;\n            } else {\n                level = (((level << 1) + 1) * qscale *\n                         ((int) (quant_matrix[j]))) >> 4;\n                level = (level - 1) | 1;\n            }\n            block[j] = level;\n        }\n    }\n}\n\nstatic void dct_unquantize_mpeg2_intra_c(MpegEncContext *s,\n                                   int16_t *block, int n, int qscale)\n{\n    int i, level, nCoeffs;\n    const uint16_t *quant_matrix;\n\n    if (s->q_scale_type) qscale = ff_mpeg2_non_linear_qscale[qscale];\n    else                 qscale <<= 1;\n\n    if(s->alternate_scan) nCoeffs= 63;\n    else nCoeffs= s->block_last_index[n];\n\n    block[0] *= n < 4 ? s->y_dc_scale : s->c_dc_scale;\n    quant_matrix = s->intra_matrix;\n    for(i=1;i<=nCoeffs;i++) {\n        int j= s->intra_scantable.permutated[i];\n        level = block[j];\n        if (level) {\n            if (level < 0) {\n                level = -level;\n                level = (int)(level * qscale * quant_matrix[j]) >> 4;\n                level = -level;\n            } else {\n                level = (int)(level * qscale * quant_matrix[j]) >> 4;\n            }\n            block[j] = level;\n        }\n    }\n}\n\nstatic void dct_unquantize_mpeg2_intra_bitexact(MpegEncContext *s,\n                                   int16_t *block, int n, int qscale)\n{\n    int i, level, nCoeffs;\n    const uint16_t *quant_matrix;\n    int sum=-1;\n\n    if (s->q_scale_type) qscale = ff_mpeg2_non_linear_qscale[qscale];\n    else                 qscale <<= 1;\n\n    if(s->alternate_scan) nCoeffs= 63;\n    else nCoeffs= s->block_last_index[n];\n\n    block[0] *= n < 4 ? s->y_dc_scale : s->c_dc_scale;\n    sum += block[0];\n    quant_matrix = s->intra_matrix;\n    for(i=1;i<=nCoeffs;i++) {\n        int j= s->intra_scantable.permutated[i];\n        level = block[j];\n        if (level) {\n            if (level < 0) {\n                level = -level;\n                level = (int)(level * qscale * quant_matrix[j]) >> 4;\n                level = -level;\n            } else {\n                level = (int)(level * qscale * quant_matrix[j]) >> 4;\n            }\n            block[j] = level;\n            sum+=level;\n        }\n    }\n    block[63]^=sum&1;\n}\n\nstatic void dct_unquantize_mpeg2_inter_c(MpegEncContext *s,\n                                   int16_t *block, int n, int qscale)\n{\n    int i, level, nCoeffs;\n    const uint16_t *quant_matrix;\n    int sum=-1;\n\n    if (s->q_scale_type) qscale = ff_mpeg2_non_linear_qscale[qscale];\n    else                 qscale <<= 1;\n\n    if(s->alternate_scan) nCoeffs= 63;\n    else nCoeffs= s->block_last_index[n];\n\n    quant_matrix = s->inter_matrix;\n    for(i=0; i<=nCoeffs; i++) {\n        int j= s->intra_scantable.permutated[i];\n        level = block[j];\n        if (level) {\n            if (level < 0) {\n                level = -level;\n                level = (((level << 1) + 1) * qscale *\n                         ((int) (quant_matrix[j]))) >> 5;\n                level = -level;\n            } else {\n                level = (((level << 1) + 1) * qscale *\n                         ((int) (quant_matrix[j]))) >> 5;\n            }\n            block[j] = level;\n            sum+=level;\n        }\n    }\n    block[63]^=sum&1;\n}\n\nstatic void dct_unquantize_h263_intra_c(MpegEncContext *s,\n                                  int16_t *block, int n, int qscale)\n{\n    int i, level, qmul, qadd;\n    int nCoeffs;\n\n    av_assert2(s->block_last_index[n]>=0 || s->h263_aic);\n\n    qmul = qscale << 1;\n\n    if (!s->h263_aic) {\n        block[0] *= n < 4 ? s->y_dc_scale : s->c_dc_scale;\n        qadd = (qscale - 1) | 1;\n    }else{\n        qadd = 0;\n    }\n    if(s->ac_pred)\n        nCoeffs=63;\n    else\n        nCoeffs= s->intra_scantable.raster_end[ s->block_last_index[n] ];\n\n    for(i=1; i<=nCoeffs; i++) {\n        level = block[i];\n        if (level) {\n            if (level < 0) {\n                level = level * qmul - qadd;\n            } else {\n                level = level * qmul + qadd;\n            }\n            block[i] = level;\n        }\n    }\n}\n\nstatic void dct_unquantize_h263_inter_c(MpegEncContext *s,\n                                  int16_t *block, int n, int qscale)\n{\n    int i, level, qmul, qadd;\n    int nCoeffs;\n\n    av_assert2(s->block_last_index[n]>=0);\n\n    qadd = (qscale - 1) | 1;\n    qmul = qscale << 1;\n\n    nCoeffs= s->inter_scantable.raster_end[ s->block_last_index[n] ];\n\n    for(i=0; i<=nCoeffs; i++) {\n        level = block[i];\n        if (level) {\n            if (level < 0) {\n                level = level * qmul - qadd;\n            } else {\n                level = level * qmul + qadd;\n            }\n            block[i] = level;\n        }\n    }\n}\n\n\nstatic void gray16(uint8_t *dst, const uint8_t *src, ptrdiff_t linesize, int h)\n{\n    while(h--)\n        memset(dst + h*linesize, 128, 16);\n}\n\nstatic void gray8(uint8_t *dst, const uint8_t *src, ptrdiff_t linesize, int h)\n{\n    while(h--)\n        memset(dst + h*linesize, 128, 8);\n}\n\n/* init common dct for both encoder and decoder */\nstatic av_cold int dct_init(MpegEncContext *s)\n{\n    ff_blockdsp_init(&s->bdsp, s->avctx);\n    ff_h264chroma_init(&s->h264chroma, 8); //for lowres\n    ff_hpeldsp_init(&s->hdsp, s->avctx->flags);\n    ff_mpegvideodsp_init(&s->mdsp);\n    ff_videodsp_init(&s->vdsp, s->avctx->bits_per_raw_sample);\n\n    if (s->avctx->debug & FF_DEBUG_NOMC) {\n        int i;\n        for (i=0; i<4; i++) {\n            s->hdsp.avg_pixels_tab[0][i] = gray16;\n            s->hdsp.put_pixels_tab[0][i] = gray16;\n            s->hdsp.put_no_rnd_pixels_tab[0][i] = gray16;\n\n            s->hdsp.avg_pixels_tab[1][i] = gray8;\n            s->hdsp.put_pixels_tab[1][i] = gray8;\n            s->hdsp.put_no_rnd_pixels_tab[1][i] = gray8;\n        }\n    }\n\n    s->dct_unquantize_h263_intra = dct_unquantize_h263_intra_c;\n    s->dct_unquantize_h263_inter = dct_unquantize_h263_inter_c;\n    s->dct_unquantize_mpeg1_intra = dct_unquantize_mpeg1_intra_c;\n    s->dct_unquantize_mpeg1_inter = dct_unquantize_mpeg1_inter_c;\n    s->dct_unquantize_mpeg2_intra = dct_unquantize_mpeg2_intra_c;\n    if (s->avctx->flags & AV_CODEC_FLAG_BITEXACT)\n        s->dct_unquantize_mpeg2_intra = dct_unquantize_mpeg2_intra_bitexact;\n    s->dct_unquantize_mpeg2_inter = dct_unquantize_mpeg2_inter_c;\n\n    if (HAVE_INTRINSICS_NEON)\n        ff_mpv_common_init_neon(s);\n\n    if (ARCH_ALPHA)\n        ff_mpv_common_init_axp(s);\n    if (ARCH_ARM)\n        ff_mpv_common_init_arm(s);\n    if (ARCH_PPC)\n        ff_mpv_common_init_ppc(s);\n    if (ARCH_X86)\n        ff_mpv_common_init_x86(s);\n    if (ARCH_MIPS)\n        ff_mpv_common_init_mips(s);\n\n    return 0;\n}\n\nav_cold void ff_mpv_idct_init(MpegEncContext *s)\n{\n    ff_idctdsp_init(&s->idsp, s->avctx);\n\n    /* load & permutate scantables\n     * note: only wmv uses different ones\n     */\n    if (s->alternate_scan) {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_alternate_vertical_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_alternate_vertical_scan);\n    } else {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_zigzag_direct);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_zigzag_direct);\n    }\n    ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_horizontal_scan);\n    ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);\n}\n\nstatic int alloc_picture(MpegEncContext *s, Picture *pic, int shared)\n{\n    return ff_alloc_picture(s->avctx, pic, &s->me, &s->sc, shared, 0,\n                            s->chroma_x_shift, s->chroma_y_shift, s->out_format,\n                            s->mb_stride, s->mb_width, s->mb_height, s->b8_stride,\n                            &s->linesize, &s->uvlinesize);\n}\n\nstatic int init_duplicate_context(MpegEncContext *s)\n{\n    int y_size = s->b8_stride * (2 * s->mb_height + 1);\n    int c_size = s->mb_stride * (s->mb_height + 1);\n    int yc_size = y_size + 2 * c_size;\n    int i;\n\n    if (s->mb_height & 1)\n        yc_size += 2*s->b8_stride + 2*s->mb_stride;\n\n    s->sc.edge_emu_buffer =\n    s->me.scratchpad   =\n    s->me.temp         =\n    s->sc.rd_scratchpad   =\n    s->sc.b_scratchpad    =\n    s->sc.obmc_scratchpad = NULL;\n\n    if (s->encoding) {\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->me.map,\n                          ME_MAP_SIZE * sizeof(uint32_t), fail)\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->me.score_map,\n                          ME_MAP_SIZE * sizeof(uint32_t), fail)\n        if (s->noise_reduction) {\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->dct_error_sum,\n                              2 * 64 * sizeof(int), fail)\n        }\n    }\n    FF_ALLOCZ_OR_GOTO(s->avctx, s->blocks, 64 * 12 * 2 * sizeof(int16_t), fail)\n    s->block = s->blocks[0];\n\n    for (i = 0; i < 12; i++) {\n        s->pblocks[i] = &s->block[i];\n    }\n\n    FF_ALLOCZ_OR_GOTO(s->avctx, s->block32, sizeof(*s->block32), fail)\n\n    if (s->avctx->codec_tag == AV_RL32(\"VCR2\")) {\n        // exchange uv\n        FFSWAP(void *, s->pblocks[4], s->pblocks[5]);\n    }\n\n    if (s->out_format == FMT_H263) {\n        /* ac values */\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->ac_val_base,\n                          yc_size * sizeof(int16_t) * 16, fail);\n        s->ac_val[0] = s->ac_val_base + s->b8_stride + 1;\n        s->ac_val[1] = s->ac_val_base + y_size + s->mb_stride + 1;\n        s->ac_val[2] = s->ac_val[1] + c_size;\n    }\n\n    return 0;\nfail:\n    return -1; // free() through ff_mpv_common_end()\n}\n\nstatic void free_duplicate_context(MpegEncContext *s)\n{\n    if (!s)\n        return;\n\n    av_freep(&s->sc.edge_emu_buffer);\n    av_freep(&s->me.scratchpad);\n    s->me.temp =\n    s->sc.rd_scratchpad =\n    s->sc.b_scratchpad =\n    s->sc.obmc_scratchpad = NULL;\n\n    av_freep(&s->dct_error_sum);\n    av_freep(&s->me.map);\n    av_freep(&s->me.score_map);\n    av_freep(&s->blocks);\n    av_freep(&s->block32);\n    av_freep(&s->ac_val_base);\n    s->block = NULL;\n}\n\nstatic void backup_duplicate_context(MpegEncContext *bak, MpegEncContext *src)\n{\n#define COPY(a) bak->a = src->a\n    COPY(sc.edge_emu_buffer);\n    COPY(me.scratchpad);\n    COPY(me.temp);\n    COPY(sc.rd_scratchpad);\n    COPY(sc.b_scratchpad);\n    COPY(sc.obmc_scratchpad);\n    COPY(me.map);\n    COPY(me.score_map);\n    COPY(blocks);\n    COPY(block);\n    COPY(block32);\n    COPY(start_mb_y);\n    COPY(end_mb_y);\n    COPY(me.map_generation);\n    COPY(pb);\n    COPY(dct_error_sum);\n    COPY(dct_count[0]);\n    COPY(dct_count[1]);\n    COPY(ac_val_base);\n    COPY(ac_val[0]);\n    COPY(ac_val[1]);\n    COPY(ac_val[2]);\n#undef COPY\n}\n\nint ff_update_duplicate_context(MpegEncContext *dst, MpegEncContext *src)\n{\n    MpegEncContext bak;\n    int i, ret;\n    // FIXME copy only needed parts\n    // START_TIMER\n    backup_duplicate_context(&bak, dst);\n    memcpy(dst, src, sizeof(MpegEncContext));\n    backup_duplicate_context(dst, &bak);\n    for (i = 0; i < 12; i++) {\n        dst->pblocks[i] = &dst->block[i];\n    }\n    if (dst->avctx->codec_tag == AV_RL32(\"VCR2\")) {\n        // exchange uv\n        FFSWAP(void *, dst->pblocks[4], dst->pblocks[5]);\n    }\n    if (!dst->sc.edge_emu_buffer &&\n        (ret = ff_mpeg_framesize_alloc(dst->avctx, &dst->me,\n                                       &dst->sc, dst->linesize)) < 0) {\n        av_log(dst->avctx, AV_LOG_ERROR, \"failed to allocate context \"\n               \"scratch buffers.\\n\");\n        return ret;\n    }\n    // STOP_TIMER(\"update_duplicate_context\")\n    // about 10k cycles / 0.01 sec for  1000frames on 1ghz with 2 threads\n    return 0;\n}\n\nint ff_mpeg_update_thread_context(AVCodecContext *dst,\n                                  const AVCodecContext *src)\n{\n    int i, ret;\n    MpegEncContext *s = dst->priv_data, *s1 = src->priv_data;\n\n    if (dst == src)\n        return 0;\n\n    av_assert0(s != s1);\n\n    // FIXME can parameters change on I-frames?\n    // in that case dst may need a reinit\n    if (!s->context_initialized) {\n        int err;\n        memcpy(s, s1, sizeof(MpegEncContext));\n\n        s->avctx                 = dst;\n        s->bitstream_buffer      = NULL;\n        s->bitstream_buffer_size = s->allocated_bitstream_buffer_size = 0;\n\n        if (s1->context_initialized){\n//             s->picture_range_start  += MAX_PICTURE_COUNT;\n//             s->picture_range_end    += MAX_PICTURE_COUNT;\n            ff_mpv_idct_init(s);\n            if((err = ff_mpv_common_init(s)) < 0){\n                memset(s, 0, sizeof(MpegEncContext));\n                s->avctx = dst;\n                return err;\n            }\n        }\n    }\n\n    if (s->height != s1->height || s->width != s1->width || s->context_reinit) {\n        s->context_reinit = 0;\n        s->height = s1->height;\n        s->width  = s1->width;\n        if ((ret = ff_mpv_common_frame_size_change(s)) < 0)\n            return ret;\n    }\n\n    s->avctx->coded_height  = s1->avctx->coded_height;\n    s->avctx->coded_width   = s1->avctx->coded_width;\n    s->avctx->width         = s1->avctx->width;\n    s->avctx->height        = s1->avctx->height;\n\n    s->coded_picture_number = s1->coded_picture_number;\n    s->picture_number       = s1->picture_number;\n\n    av_assert0(!s->picture || s->picture != s1->picture);\n    if(s->picture)\n    for (i = 0; i < MAX_PICTURE_COUNT; i++) {\n        ff_mpeg_unref_picture(s->avctx, &s->picture[i]);\n        if (s1->picture && s1->picture[i].f->buf[0] &&\n            (ret = ff_mpeg_ref_picture(s->avctx, &s->picture[i], &s1->picture[i])) < 0)\n            return ret;\n    }\n\n#define UPDATE_PICTURE(pic)\\\ndo {\\\n    ff_mpeg_unref_picture(s->avctx, &s->pic);\\\n    if (s1->pic.f && s1->pic.f->buf[0])\\\n        ret = ff_mpeg_ref_picture(s->avctx, &s->pic, &s1->pic);\\\n    else\\\n        ret = ff_update_picture_tables(&s->pic, &s1->pic);\\\n    if (ret < 0)\\\n        return ret;\\\n} while (0)\n\n    UPDATE_PICTURE(current_picture);\n    UPDATE_PICTURE(last_picture);\n    UPDATE_PICTURE(next_picture);\n\n#define REBASE_PICTURE(pic, new_ctx, old_ctx)                                 \\\n    ((pic && pic >= old_ctx->picture &&                                       \\\n      pic < old_ctx->picture + MAX_PICTURE_COUNT) ?                           \\\n        &new_ctx->picture[pic - old_ctx->picture] : NULL)\n\n    s->last_picture_ptr    = REBASE_PICTURE(s1->last_picture_ptr,    s, s1);\n    s->current_picture_ptr = REBASE_PICTURE(s1->current_picture_ptr, s, s1);\n    s->next_picture_ptr    = REBASE_PICTURE(s1->next_picture_ptr,    s, s1);\n\n    // Error/bug resilience\n    s->next_p_frame_damaged = s1->next_p_frame_damaged;\n    s->workaround_bugs      = s1->workaround_bugs;\n    s->padding_bug_score    = s1->padding_bug_score;\n\n    // MPEG-4 timing info\n    memcpy(&s->last_time_base, &s1->last_time_base,\n           (char *) &s1->pb_field_time + sizeof(s1->pb_field_time) -\n           (char *) &s1->last_time_base);\n\n    // B-frame info\n    s->max_b_frames = s1->max_b_frames;\n    s->low_delay    = s1->low_delay;\n    s->droppable    = s1->droppable;\n\n    // DivX handling (doesn't work)\n    s->divx_packed  = s1->divx_packed;\n\n    if (s1->bitstream_buffer) {\n        if (s1->bitstream_buffer_size +\n            AV_INPUT_BUFFER_PADDING_SIZE > s->allocated_bitstream_buffer_size) {\n            av_fast_malloc(&s->bitstream_buffer,\n                           &s->allocated_bitstream_buffer_size,\n                           s1->allocated_bitstream_buffer_size);\n            if (!s->bitstream_buffer) {\n                s->bitstream_buffer_size = 0;\n                return AVERROR(ENOMEM);\n            }\n        }\n        s->bitstream_buffer_size = s1->bitstream_buffer_size;\n        memcpy(s->bitstream_buffer, s1->bitstream_buffer,\n               s1->bitstream_buffer_size);\n        memset(s->bitstream_buffer + s->bitstream_buffer_size, 0,\n               AV_INPUT_BUFFER_PADDING_SIZE);\n    }\n\n    // linesize-dependent scratch buffer allocation\n    if (!s->sc.edge_emu_buffer)\n        if (s1->linesize) {\n            if (ff_mpeg_framesize_alloc(s->avctx, &s->me,\n                                        &s->sc, s1->linesize) < 0) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Failed to allocate context \"\n                       \"scratch buffers.\\n\");\n                return AVERROR(ENOMEM);\n            }\n        } else {\n            av_log(s->avctx, AV_LOG_ERROR, \"Context scratch buffers could not \"\n                   \"be allocated due to unknown size.\\n\");\n        }\n\n    // MPEG-2/interlacing info\n    memcpy(&s->progressive_sequence, &s1->progressive_sequence,\n           (char *) &s1->rtp_mode - (char *) &s1->progressive_sequence);\n\n    if (!s1->first_field) {\n        s->last_pict_type = s1->pict_type;\n        if (s1->current_picture_ptr)\n            s->last_lambda_for[s1->pict_type] = s1->current_picture_ptr->f->quality;\n    }\n\n    return 0;\n}\n\n/**\n * Set the given MpegEncContext to common defaults\n * (same for encoding and decoding).\n * The changed fields will not depend upon the\n * prior state of the MpegEncContext.\n */\nvoid ff_mpv_common_defaults(MpegEncContext *s)\n{\n    s->y_dc_scale_table      =\n    s->c_dc_scale_table      = ff_mpeg1_dc_scale_table;\n    s->chroma_qscale_table   = ff_default_chroma_qscale_table;\n    s->progressive_frame     = 1;\n    s->progressive_sequence  = 1;\n    s->picture_structure     = PICT_FRAME;\n\n    s->coded_picture_number  = 0;\n    s->picture_number        = 0;\n\n    s->f_code                = 1;\n    s->b_code                = 1;\n\n    s->slice_context_count   = 1;\n}\n\n/**\n * Set the given MpegEncContext to defaults for decoding.\n * the changed fields will not depend upon\n * the prior state of the MpegEncContext.\n */\nvoid ff_mpv_decode_defaults(MpegEncContext *s)\n{\n    ff_mpv_common_defaults(s);\n}\n\nvoid ff_mpv_decode_init(MpegEncContext *s, AVCodecContext *avctx)\n{\n    s->avctx           = avctx;\n    s->width           = avctx->coded_width;\n    s->height          = avctx->coded_height;\n    s->codec_id        = avctx->codec->id;\n    s->workaround_bugs = avctx->workaround_bugs;\n\n    /* convert fourcc to upper case */\n    s->codec_tag          = avpriv_toupper4(avctx->codec_tag);\n}\n\n/**\n * Initialize and allocates MpegEncContext fields dependent on the resolution.\n */\nstatic int init_context_frame(MpegEncContext *s)\n{\n    int y_size, c_size, yc_size, i, mb_array_size, mv_table_size, x, y;\n\n    s->mb_width   = (s->width + 15) / 16;\n    s->mb_stride  = s->mb_width + 1;\n    s->b8_stride  = s->mb_width * 2 + 1;\n    mb_array_size = s->mb_height * s->mb_stride;\n    mv_table_size = (s->mb_height + 2) * s->mb_stride + 1;\n\n    /* set default edge pos, will be overridden\n     * in decode_header if needed */\n    s->h_edge_pos = s->mb_width * 16;\n    s->v_edge_pos = s->mb_height * 16;\n\n    s->mb_num     = s->mb_width * s->mb_height;\n\n    s->block_wrap[0] =\n    s->block_wrap[1] =\n    s->block_wrap[2] =\n    s->block_wrap[3] = s->b8_stride;\n    s->block_wrap[4] =\n    s->block_wrap[5] = s->mb_stride;\n\n    y_size  = s->b8_stride * (2 * s->mb_height + 1);\n    c_size  = s->mb_stride * (s->mb_height + 1);\n    yc_size = y_size + 2   * c_size;\n\n    if (s->mb_height & 1)\n        yc_size += 2*s->b8_stride + 2*s->mb_stride;\n\n    FF_ALLOCZ_OR_GOTO(s->avctx, s->mb_index2xy, (s->mb_num + 1) * sizeof(int),\n                      fail); // error resilience code looks cleaner with this\n    for (y = 0; y < s->mb_height; y++)\n        for (x = 0; x < s->mb_width; x++)\n            s->mb_index2xy[x + y * s->mb_width] = x + y * s->mb_stride;\n\n    s->mb_index2xy[s->mb_height * s->mb_width] = (s->mb_height - 1) * s->mb_stride + s->mb_width; // FIXME really needed?\n\n    if (s->encoding) {\n        /* Allocate MV tables */\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->p_mv_table_base,                 mv_table_size * 2 * sizeof(int16_t), fail)\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->b_forw_mv_table_base,            mv_table_size * 2 * sizeof(int16_t), fail)\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->b_back_mv_table_base,            mv_table_size * 2 * sizeof(int16_t), fail)\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->b_bidir_forw_mv_table_base,      mv_table_size * 2 * sizeof(int16_t), fail)\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->b_bidir_back_mv_table_base,      mv_table_size * 2 * sizeof(int16_t), fail)\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->b_direct_mv_table_base,          mv_table_size * 2 * sizeof(int16_t), fail)\n        s->p_mv_table            = s->p_mv_table_base + s->mb_stride + 1;\n        s->b_forw_mv_table       = s->b_forw_mv_table_base + s->mb_stride + 1;\n        s->b_back_mv_table       = s->b_back_mv_table_base + s->mb_stride + 1;\n        s->b_bidir_forw_mv_table = s->b_bidir_forw_mv_table_base + s->mb_stride + 1;\n        s->b_bidir_back_mv_table = s->b_bidir_back_mv_table_base + s->mb_stride + 1;\n        s->b_direct_mv_table     = s->b_direct_mv_table_base + s->mb_stride + 1;\n\n        /* Allocate MB type table */\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->mb_type, mb_array_size * sizeof(uint16_t), fail) // needed for encoding\n\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->lambda_table, mb_array_size * sizeof(int), fail)\n\n        FF_ALLOC_OR_GOTO(s->avctx, s->cplx_tab,\n                         mb_array_size * sizeof(float), fail);\n        FF_ALLOC_OR_GOTO(s->avctx, s->bits_tab,\n                         mb_array_size * sizeof(float), fail);\n\n    }\n\n    if (s->codec_id == AV_CODEC_ID_MPEG4 ||\n        (s->avctx->flags & AV_CODEC_FLAG_INTERLACED_ME)) {\n        /* interlaced direct mode decoding tables */\n        for (i = 0; i < 2; i++) {\n            int j, k;\n            for (j = 0; j < 2; j++) {\n                for (k = 0; k < 2; k++) {\n                    FF_ALLOCZ_OR_GOTO(s->avctx,\n                                      s->b_field_mv_table_base[i][j][k],\n                                      mv_table_size * 2 * sizeof(int16_t),\n                                      fail);\n                    s->b_field_mv_table[i][j][k] = s->b_field_mv_table_base[i][j][k] +\n                                                   s->mb_stride + 1;\n                }\n                FF_ALLOCZ_OR_GOTO(s->avctx, s->b_field_select_table [i][j], mb_array_size * 2 * sizeof(uint8_t), fail)\n                FF_ALLOCZ_OR_GOTO(s->avctx, s->p_field_mv_table_base[i][j], mv_table_size * 2 * sizeof(int16_t), fail)\n                s->p_field_mv_table[i][j] = s->p_field_mv_table_base[i][j] + s->mb_stride + 1;\n            }\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->p_field_select_table[i], mb_array_size * 2 * sizeof(uint8_t), fail)\n        }\n    }\n    if (s->out_format == FMT_H263) {\n        /* cbp values */\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->coded_block_base, y_size + (s->mb_height&1)*2*s->b8_stride, fail);\n        s->coded_block = s->coded_block_base + s->b8_stride + 1;\n\n        /* cbp, ac_pred, pred_dir */\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->cbp_table     , mb_array_size * sizeof(uint8_t), fail);\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->pred_dir_table, mb_array_size * sizeof(uint8_t), fail);\n    }\n\n    if (s->h263_pred || s->h263_plus || !s->encoding) {\n        /* dc values */\n        // MN: we need these for error resilience of intra-frames\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->dc_val_base, yc_size * sizeof(int16_t), fail);\n        s->dc_val[0] = s->dc_val_base + s->b8_stride + 1;\n        s->dc_val[1] = s->dc_val_base + y_size + s->mb_stride + 1;\n        s->dc_val[2] = s->dc_val[1] + c_size;\n        for (i = 0; i < yc_size; i++)\n            s->dc_val_base[i] = 1024;\n    }\n\n    /* which mb is an intra block */\n    FF_ALLOCZ_OR_GOTO(s->avctx, s->mbintra_table, mb_array_size, fail);\n    memset(s->mbintra_table, 1, mb_array_size);\n\n    /* init macroblock skip table */\n    FF_ALLOCZ_OR_GOTO(s->avctx, s->mbskip_table, mb_array_size + 2, fail);\n    // Note the + 1 is for a quicker MPEG-4 slice_end detection\n\n    return ff_mpeg_er_init(s);\nfail:\n    return AVERROR(ENOMEM);\n}\n\nstatic void clear_context(MpegEncContext *s)\n{\n    int i, j, k;\n\n    memset(&s->next_picture, 0, sizeof(s->next_picture));\n    memset(&s->last_picture, 0, sizeof(s->last_picture));\n    memset(&s->current_picture, 0, sizeof(s->current_picture));\n    memset(&s->new_picture, 0, sizeof(s->new_picture));\n\n    memset(s->thread_context, 0, sizeof(s->thread_context));\n\n    s->me.map = NULL;\n    s->me.score_map = NULL;\n    s->dct_error_sum = NULL;\n    s->block = NULL;\n    s->blocks = NULL;\n    s->block32 = NULL;\n    memset(s->pblocks, 0, sizeof(s->pblocks));\n    s->ac_val_base = NULL;\n    s->ac_val[0] =\n    s->ac_val[1] =\n    s->ac_val[2] =NULL;\n    s->sc.edge_emu_buffer = NULL;\n    s->me.scratchpad = NULL;\n    s->me.temp =\n    s->sc.rd_scratchpad =\n    s->sc.b_scratchpad =\n    s->sc.obmc_scratchpad = NULL;\n\n\n    s->bitstream_buffer = NULL;\n    s->allocated_bitstream_buffer_size = 0;\n    s->picture          = NULL;\n    s->mb_type          = NULL;\n    s->p_mv_table_base  = NULL;\n    s->b_forw_mv_table_base = NULL;\n    s->b_back_mv_table_base = NULL;\n    s->b_bidir_forw_mv_table_base = NULL;\n    s->b_bidir_back_mv_table_base = NULL;\n    s->b_direct_mv_table_base = NULL;\n    s->p_mv_table            = NULL;\n    s->b_forw_mv_table       = NULL;\n    s->b_back_mv_table       = NULL;\n    s->b_bidir_forw_mv_table = NULL;\n    s->b_bidir_back_mv_table = NULL;\n    s->b_direct_mv_table     = NULL;\n    for (i = 0; i < 2; i++) {\n        for (j = 0; j < 2; j++) {\n            for (k = 0; k < 2; k++) {\n                s->b_field_mv_table_base[i][j][k] = NULL;\n                s->b_field_mv_table[i][j][k] = NULL;\n            }\n            s->b_field_select_table[i][j] = NULL;\n            s->p_field_mv_table_base[i][j] = NULL;\n            s->p_field_mv_table[i][j] = NULL;\n        }\n        s->p_field_select_table[i] = NULL;\n    }\n\n    s->dc_val_base = NULL;\n    s->coded_block_base = NULL;\n    s->mbintra_table = NULL;\n    s->cbp_table = NULL;\n    s->pred_dir_table = NULL;\n\n    s->mbskip_table = NULL;\n\n    s->er.error_status_table = NULL;\n    s->er.er_temp_buffer = NULL;\n    s->mb_index2xy = NULL;\n    s->lambda_table = NULL;\n\n    s->cplx_tab = NULL;\n    s->bits_tab = NULL;\n}\n\n/**\n * init common structure for both encoder and decoder.\n * this assumes that some variables like width/height are already set\n */\nav_cold int ff_mpv_common_init(MpegEncContext *s)\n{\n    int i, ret;\n    int nb_slices = (HAVE_THREADS &&\n                     s->avctx->active_thread_type & FF_THREAD_SLICE) ?\n                    s->avctx->thread_count : 1;\n\n    clear_context(s);\n\n    if (s->encoding && s->avctx->slices)\n        nb_slices = s->avctx->slices;\n\n    if (s->codec_id == AV_CODEC_ID_MPEG2VIDEO && !s->progressive_sequence)\n        s->mb_height = (s->height + 31) / 32 * 2;\n    else\n        s->mb_height = (s->height + 15) / 16;\n\n    if (s->avctx->pix_fmt == AV_PIX_FMT_NONE) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"decoding to AV_PIX_FMT_NONE is not supported.\\n\");\n        return -1;\n    }\n\n    if (nb_slices > MAX_THREADS || (nb_slices > s->mb_height && s->mb_height)) {\n        int max_slices;\n        if (s->mb_height)\n            max_slices = FFMIN(MAX_THREADS, s->mb_height);\n        else\n            max_slices = MAX_THREADS;\n        av_log(s->avctx, AV_LOG_WARNING, \"too many threads/slices (%d),\"\n               \" reducing to %d\\n\", nb_slices, max_slices);\n        nb_slices = max_slices;\n    }\n\n    if ((s->width || s->height) &&\n        av_image_check_size(s->width, s->height, 0, s->avctx))\n        return -1;\n\n    dct_init(s);\n\n    /* set chroma shifts */\n    ret = av_pix_fmt_get_chroma_sub_sample(s->avctx->pix_fmt,\n                                           &s->chroma_x_shift,\n                                           &s->chroma_y_shift);\n    if (ret)\n        return ret;\n\n    FF_ALLOCZ_OR_GOTO(s->avctx, s->picture,\n                      MAX_PICTURE_COUNT * sizeof(Picture), fail);\n    for (i = 0; i < MAX_PICTURE_COUNT; i++) {\n        s->picture[i].f = av_frame_alloc();\n        if (!s->picture[i].f)\n            goto fail;\n    }\n    s->next_picture.f = av_frame_alloc();\n    if (!s->next_picture.f)\n        goto fail;\n    s->last_picture.f = av_frame_alloc();\n    if (!s->last_picture.f)\n        goto fail;\n    s->current_picture.f = av_frame_alloc();\n    if (!s->current_picture.f)\n        goto fail;\n    s->new_picture.f = av_frame_alloc();\n    if (!s->new_picture.f)\n        goto fail;\n\n    if (init_context_frame(s))\n        goto fail;\n\n    s->parse_context.state = -1;\n\n    s->context_initialized = 1;\n    memset(s->thread_context, 0, sizeof(s->thread_context));\n    s->thread_context[0]   = s;\n\n//     if (s->width && s->height) {\n    if (nb_slices > 1) {\n        for (i = 0; i < nb_slices; i++) {\n            if (i) {\n                s->thread_context[i] = av_memdup(s, sizeof(MpegEncContext));\n                if (!s->thread_context[i])\n                    goto fail;\n            }\n            if (init_duplicate_context(s->thread_context[i]) < 0)\n                goto fail;\n            s->thread_context[i]->start_mb_y =\n                (s->mb_height * (i) + nb_slices / 2) / nb_slices;\n            s->thread_context[i]->end_mb_y   =\n                (s->mb_height * (i + 1) + nb_slices / 2) / nb_slices;\n        }\n    } else {\n        if (init_duplicate_context(s) < 0)\n            goto fail;\n        s->start_mb_y = 0;\n        s->end_mb_y   = s->mb_height;\n    }\n    s->slice_context_count = nb_slices;\n//     }\n\n    return 0;\n fail:\n    ff_mpv_common_end(s);\n    return -1;\n}\n\n/**\n * Frees and resets MpegEncContext fields depending on the resolution.\n * Is used during resolution changes to avoid a full reinitialization of the\n * codec.\n */\nstatic void free_context_frame(MpegEncContext *s)\n{\n    int i, j, k;\n\n    av_freep(&s->mb_type);\n    av_freep(&s->p_mv_table_base);\n    av_freep(&s->b_forw_mv_table_base);\n    av_freep(&s->b_back_mv_table_base);\n    av_freep(&s->b_bidir_forw_mv_table_base);\n    av_freep(&s->b_bidir_back_mv_table_base);\n    av_freep(&s->b_direct_mv_table_base);\n    s->p_mv_table            = NULL;\n    s->b_forw_mv_table       = NULL;\n    s->b_back_mv_table       = NULL;\n    s->b_bidir_forw_mv_table = NULL;\n    s->b_bidir_back_mv_table = NULL;\n    s->b_direct_mv_table     = NULL;\n    for (i = 0; i < 2; i++) {\n        for (j = 0; j < 2; j++) {\n            for (k = 0; k < 2; k++) {\n                av_freep(&s->b_field_mv_table_base[i][j][k]);\n                s->b_field_mv_table[i][j][k] = NULL;\n            }\n            av_freep(&s->b_field_select_table[i][j]);\n            av_freep(&s->p_field_mv_table_base[i][j]);\n            s->p_field_mv_table[i][j] = NULL;\n        }\n        av_freep(&s->p_field_select_table[i]);\n    }\n\n    av_freep(&s->dc_val_base);\n    av_freep(&s->coded_block_base);\n    av_freep(&s->mbintra_table);\n    av_freep(&s->cbp_table);\n    av_freep(&s->pred_dir_table);\n\n    av_freep(&s->mbskip_table);\n\n    av_freep(&s->er.error_status_table);\n    av_freep(&s->er.er_temp_buffer);\n    av_freep(&s->mb_index2xy);\n    av_freep(&s->lambda_table);\n\n    av_freep(&s->cplx_tab);\n    av_freep(&s->bits_tab);\n\n    s->linesize = s->uvlinesize = 0;\n}\n\nint ff_mpv_common_frame_size_change(MpegEncContext *s)\n{\n    int i, err = 0;\n\n    if (!s->context_initialized)\n        return AVERROR(EINVAL);\n\n    if (s->slice_context_count > 1) {\n        for (i = 0; i < s->slice_context_count; i++) {\n            free_duplicate_context(s->thread_context[i]);\n        }\n        for (i = 1; i < s->slice_context_count; i++) {\n            av_freep(&s->thread_context[i]);\n        }\n    } else\n        free_duplicate_context(s);\n\n    free_context_frame(s);\n\n    if (s->picture)\n        for (i = 0; i < MAX_PICTURE_COUNT; i++) {\n                s->picture[i].needs_realloc = 1;\n        }\n\n    s->last_picture_ptr         =\n    s->next_picture_ptr         =\n    s->current_picture_ptr      = NULL;\n\n    // init\n    if (s->codec_id == AV_CODEC_ID_MPEG2VIDEO && !s->progressive_sequence)\n        s->mb_height = (s->height + 31) / 32 * 2;\n    else\n        s->mb_height = (s->height + 15) / 16;\n\n    if ((s->width || s->height) &&\n        (err = av_image_check_size(s->width, s->height, 0, s->avctx)) < 0)\n        goto fail;\n\n    if ((err = init_context_frame(s)))\n        goto fail;\n\n    memset(s->thread_context, 0, sizeof(s->thread_context));\n    s->thread_context[0]   = s;\n\n    if (s->width && s->height) {\n        int nb_slices = s->slice_context_count;\n        if (nb_slices > 1) {\n            for (i = 0; i < nb_slices; i++) {\n                if (i) {\n                    s->thread_context[i] = av_memdup(s, sizeof(MpegEncContext));\n                    if (!s->thread_context[i]) {\n                        err = AVERROR(ENOMEM);\n                        goto fail;\n                    }\n                }\n                if ((err = init_duplicate_context(s->thread_context[i])) < 0)\n                    goto fail;\n                s->thread_context[i]->start_mb_y =\n                    (s->mb_height * (i) + nb_slices / 2) / nb_slices;\n                s->thread_context[i]->end_mb_y   =\n                    (s->mb_height * (i + 1) + nb_slices / 2) / nb_slices;\n            }\n        } else {\n            err = init_duplicate_context(s);\n            if (err < 0)\n                goto fail;\n            s->start_mb_y = 0;\n            s->end_mb_y   = s->mb_height;\n        }\n        s->slice_context_count = nb_slices;\n    }\n\n    return 0;\n fail:\n    ff_mpv_common_end(s);\n    return err;\n}\n\n/* init common structure for both encoder and decoder */\nvoid ff_mpv_common_end(MpegEncContext *s)\n{\n    int i;\n\n    if (!s)\n        return ;\n\n    if (s->slice_context_count > 1) {\n        for (i = 0; i < s->slice_context_count; i++) {\n            free_duplicate_context(s->thread_context[i]);\n        }\n        for (i = 1; i < s->slice_context_count; i++) {\n            av_freep(&s->thread_context[i]);\n        }\n        s->slice_context_count = 1;\n    } else free_duplicate_context(s);\n\n    av_freep(&s->parse_context.buffer);\n    s->parse_context.buffer_size = 0;\n\n    av_freep(&s->bitstream_buffer);\n    s->allocated_bitstream_buffer_size = 0;\n\n    if (s->picture) {\n        for (i = 0; i < MAX_PICTURE_COUNT; i++) {\n            ff_free_picture_tables(&s->picture[i]);\n            ff_mpeg_unref_picture(s->avctx, &s->picture[i]);\n            av_frame_free(&s->picture[i].f);\n        }\n    }\n    av_freep(&s->picture);\n    ff_free_picture_tables(&s->last_picture);\n    ff_mpeg_unref_picture(s->avctx, &s->last_picture);\n    av_frame_free(&s->last_picture.f);\n    ff_free_picture_tables(&s->current_picture);\n    ff_mpeg_unref_picture(s->avctx, &s->current_picture);\n    av_frame_free(&s->current_picture.f);\n    ff_free_picture_tables(&s->next_picture);\n    ff_mpeg_unref_picture(s->avctx, &s->next_picture);\n    av_frame_free(&s->next_picture.f);\n    ff_free_picture_tables(&s->new_picture);\n    ff_mpeg_unref_picture(s->avctx, &s->new_picture);\n    av_frame_free(&s->new_picture.f);\n\n    free_context_frame(s);\n\n    s->context_initialized      = 0;\n    s->last_picture_ptr         =\n    s->next_picture_ptr         =\n    s->current_picture_ptr      = NULL;\n    s->linesize = s->uvlinesize = 0;\n}\n\n\nstatic void gray_frame(AVFrame *frame)\n{\n    int i, h_chroma_shift, v_chroma_shift;\n\n    av_pix_fmt_get_chroma_sub_sample(frame->format, &h_chroma_shift, &v_chroma_shift);\n\n    for(i=0; i<frame->height; i++)\n        memset(frame->data[0] + frame->linesize[0]*i, 0x80, frame->width);\n    for(i=0; i<AV_CEIL_RSHIFT(frame->height, v_chroma_shift); i++) {\n        memset(frame->data[1] + frame->linesize[1]*i,\n               0x80, AV_CEIL_RSHIFT(frame->width, h_chroma_shift));\n        memset(frame->data[2] + frame->linesize[2]*i,\n               0x80, AV_CEIL_RSHIFT(frame->width, h_chroma_shift));\n    }\n}\n\n/**\n * generic function called after decoding\n * the header and before a frame is decoded.\n */\nint ff_mpv_frame_start(MpegEncContext *s, AVCodecContext *avctx)\n{\n    int i, ret;\n    Picture *pic;\n    s->mb_skipped = 0;\n\n    if (!ff_thread_can_start_frame(avctx)) {\n        av_log(avctx, AV_LOG_ERROR, \"Attempt to start a frame outside SETUP state\\n\");\n        return -1;\n    }\n\n    /* mark & release old frames */\n    if (s->pict_type != AV_PICTURE_TYPE_B && s->last_picture_ptr &&\n        s->last_picture_ptr != s->next_picture_ptr &&\n        s->last_picture_ptr->f->buf[0]) {\n        ff_mpeg_unref_picture(s->avctx, s->last_picture_ptr);\n    }\n\n    /* release forgotten pictures */\n    /* if (MPEG-124 / H.263) */\n    for (i = 0; i < MAX_PICTURE_COUNT; i++) {\n        if (&s->picture[i] != s->last_picture_ptr &&\n            &s->picture[i] != s->next_picture_ptr &&\n            s->picture[i].reference && !s->picture[i].needs_realloc) {\n            ff_mpeg_unref_picture(s->avctx, &s->picture[i]);\n        }\n    }\n\n    ff_mpeg_unref_picture(s->avctx, &s->current_picture);\n    ff_mpeg_unref_picture(s->avctx, &s->last_picture);\n    ff_mpeg_unref_picture(s->avctx, &s->next_picture);\n\n    /* release non reference frames */\n    for (i = 0; i < MAX_PICTURE_COUNT; i++) {\n        if (!s->picture[i].reference)\n            ff_mpeg_unref_picture(s->avctx, &s->picture[i]);\n    }\n\n    if (s->current_picture_ptr && !s->current_picture_ptr->f->buf[0]) {\n        // we already have an unused image\n        // (maybe it was set before reading the header)\n        pic = s->current_picture_ptr;\n    } else {\n        i   = ff_find_unused_picture(s->avctx, s->picture, 0);\n        if (i < 0) {\n            av_log(s->avctx, AV_LOG_ERROR, \"no frame buffer available\\n\");\n            return i;\n        }\n        pic = &s->picture[i];\n    }\n\n    pic->reference = 0;\n    if (!s->droppable) {\n        if (s->pict_type != AV_PICTURE_TYPE_B)\n            pic->reference = 3;\n    }\n\n    pic->f->coded_picture_number = s->coded_picture_number++;\n\n    if (alloc_picture(s, pic, 0) < 0)\n        return -1;\n\n    s->current_picture_ptr = pic;\n    // FIXME use only the vars from current_pic\n    s->current_picture_ptr->f->top_field_first = s->top_field_first;\n    if (s->codec_id == AV_CODEC_ID_MPEG1VIDEO ||\n        s->codec_id == AV_CODEC_ID_MPEG2VIDEO) {\n        if (s->picture_structure != PICT_FRAME)\n            s->current_picture_ptr->f->top_field_first =\n                (s->picture_structure == PICT_TOP_FIELD) == s->first_field;\n    }\n    s->current_picture_ptr->f->interlaced_frame = !s->progressive_frame &&\n                                                 !s->progressive_sequence;\n    s->current_picture_ptr->field_picture      =  s->picture_structure != PICT_FRAME;\n\n    s->current_picture_ptr->f->pict_type = s->pict_type;\n    // if (s->avctx->flags && AV_CODEC_FLAG_QSCALE)\n    //     s->current_picture_ptr->quality = s->new_picture_ptr->quality;\n    s->current_picture_ptr->f->key_frame = s->pict_type == AV_PICTURE_TYPE_I;\n\n    if ((ret = ff_mpeg_ref_picture(s->avctx, &s->current_picture,\n                                   s->current_picture_ptr)) < 0)\n        return ret;\n\n    if (s->pict_type != AV_PICTURE_TYPE_B) {\n        s->last_picture_ptr = s->next_picture_ptr;\n        if (!s->droppable)\n            s->next_picture_ptr = s->current_picture_ptr;\n    }\n    ff_dlog(s->avctx, \"L%p N%p C%p L%p N%p C%p type:%d drop:%d\\n\",\n            s->last_picture_ptr, s->next_picture_ptr,s->current_picture_ptr,\n            s->last_picture_ptr    ? s->last_picture_ptr->f->data[0]    : NULL,\n            s->next_picture_ptr    ? s->next_picture_ptr->f->data[0]    : NULL,\n            s->current_picture_ptr ? s->current_picture_ptr->f->data[0] : NULL,\n            s->pict_type, s->droppable);\n\n    if ((!s->last_picture_ptr || !s->last_picture_ptr->f->buf[0]) &&\n        (s->pict_type != AV_PICTURE_TYPE_I)) {\n        int h_chroma_shift, v_chroma_shift;\n        av_pix_fmt_get_chroma_sub_sample(s->avctx->pix_fmt,\n                                         &h_chroma_shift, &v_chroma_shift);\n        if (s->pict_type == AV_PICTURE_TYPE_B && s->next_picture_ptr && s->next_picture_ptr->f->buf[0])\n            av_log(avctx, AV_LOG_DEBUG,\n                   \"allocating dummy last picture for B frame\\n\");\n        else if (s->pict_type != AV_PICTURE_TYPE_I)\n            av_log(avctx, AV_LOG_ERROR,\n                   \"warning: first frame is no keyframe\\n\");\n\n        /* Allocate a dummy frame */\n        i = ff_find_unused_picture(s->avctx, s->picture, 0);\n        if (i < 0) {\n            av_log(s->avctx, AV_LOG_ERROR, \"no frame buffer available\\n\");\n            return i;\n        }\n        s->last_picture_ptr = &s->picture[i];\n\n        s->last_picture_ptr->reference   = 3;\n        s->last_picture_ptr->f->key_frame = 0;\n        s->last_picture_ptr->f->pict_type = AV_PICTURE_TYPE_P;\n\n        if (alloc_picture(s, s->last_picture_ptr, 0) < 0) {\n            s->last_picture_ptr = NULL;\n            return -1;\n        }\n\n        if (!avctx->hwaccel) {\n            for(i=0; i<avctx->height; i++)\n                memset(s->last_picture_ptr->f->data[0] + s->last_picture_ptr->f->linesize[0]*i,\n                       0x80, avctx->width);\n            if (s->last_picture_ptr->f->data[2]) {\n                for(i=0; i<AV_CEIL_RSHIFT(avctx->height, v_chroma_shift); i++) {\n                    memset(s->last_picture_ptr->f->data[1] + s->last_picture_ptr->f->linesize[1]*i,\n                        0x80, AV_CEIL_RSHIFT(avctx->width, h_chroma_shift));\n                    memset(s->last_picture_ptr->f->data[2] + s->last_picture_ptr->f->linesize[2]*i,\n                        0x80, AV_CEIL_RSHIFT(avctx->width, h_chroma_shift));\n                }\n            }\n\n            if(s->codec_id == AV_CODEC_ID_FLV1 || s->codec_id == AV_CODEC_ID_H263){\n                for(i=0; i<avctx->height; i++)\n                memset(s->last_picture_ptr->f->data[0] + s->last_picture_ptr->f->linesize[0]*i, 16, avctx->width);\n            }\n        }\n\n        ff_thread_report_progress(&s->last_picture_ptr->tf, INT_MAX, 0);\n        ff_thread_report_progress(&s->last_picture_ptr->tf, INT_MAX, 1);\n    }\n    if ((!s->next_picture_ptr || !s->next_picture_ptr->f->buf[0]) &&\n        s->pict_type == AV_PICTURE_TYPE_B) {\n        /* Allocate a dummy frame */\n        i = ff_find_unused_picture(s->avctx, s->picture, 0);\n        if (i < 0) {\n            av_log(s->avctx, AV_LOG_ERROR, \"no frame buffer available\\n\");\n            return i;\n        }\n        s->next_picture_ptr = &s->picture[i];\n\n        s->next_picture_ptr->reference   = 3;\n        s->next_picture_ptr->f->key_frame = 0;\n        s->next_picture_ptr->f->pict_type = AV_PICTURE_TYPE_P;\n\n        if (alloc_picture(s, s->next_picture_ptr, 0) < 0) {\n            s->next_picture_ptr = NULL;\n            return -1;\n        }\n        ff_thread_report_progress(&s->next_picture_ptr->tf, INT_MAX, 0);\n        ff_thread_report_progress(&s->next_picture_ptr->tf, INT_MAX, 1);\n    }\n\n#if 0 // BUFREF-FIXME\n    memset(s->last_picture.f->data, 0, sizeof(s->last_picture.f->data));\n    memset(s->next_picture.f->data, 0, sizeof(s->next_picture.f->data));\n#endif\n    if (s->last_picture_ptr) {\n        if (s->last_picture_ptr->f->buf[0] &&\n            (ret = ff_mpeg_ref_picture(s->avctx, &s->last_picture,\n                                       s->last_picture_ptr)) < 0)\n            return ret;\n    }\n    if (s->next_picture_ptr) {\n        if (s->next_picture_ptr->f->buf[0] &&\n            (ret = ff_mpeg_ref_picture(s->avctx, &s->next_picture,\n                                       s->next_picture_ptr)) < 0)\n            return ret;\n    }\n\n    av_assert0(s->pict_type == AV_PICTURE_TYPE_I || (s->last_picture_ptr &&\n                                                 s->last_picture_ptr->f->buf[0]));\n\n    if (s->picture_structure!= PICT_FRAME) {\n        int i;\n        for (i = 0; i < 4; i++) {\n            if (s->picture_structure == PICT_BOTTOM_FIELD) {\n                s->current_picture.f->data[i] +=\n                    s->current_picture.f->linesize[i];\n            }\n            s->current_picture.f->linesize[i] *= 2;\n            s->last_picture.f->linesize[i]    *= 2;\n            s->next_picture.f->linesize[i]    *= 2;\n        }\n    }\n\n    /* set dequantizer, we can't do it during init as\n     * it might change for MPEG-4 and we can't do it in the header\n     * decode as init is not called for MPEG-4 there yet */\n    if (s->mpeg_quant || s->codec_id == AV_CODEC_ID_MPEG2VIDEO) {\n        s->dct_unquantize_intra = s->dct_unquantize_mpeg2_intra;\n        s->dct_unquantize_inter = s->dct_unquantize_mpeg2_inter;\n    } else if (s->out_format == FMT_H263 || s->out_format == FMT_H261) {\n        s->dct_unquantize_intra = s->dct_unquantize_h263_intra;\n        s->dct_unquantize_inter = s->dct_unquantize_h263_inter;\n    } else {\n        s->dct_unquantize_intra = s->dct_unquantize_mpeg1_intra;\n        s->dct_unquantize_inter = s->dct_unquantize_mpeg1_inter;\n    }\n\n    if (s->avctx->debug & FF_DEBUG_NOMC) {\n        gray_frame(s->current_picture_ptr->f);\n    }\n\n    return 0;\n}\n\n/* called after a frame has been decoded. */\nvoid ff_mpv_frame_end(MpegEncContext *s)\n{\n    emms_c();\n\n    if (s->current_picture.reference)\n        ff_thread_report_progress(&s->current_picture_ptr->tf, INT_MAX, 0);\n}\n\nvoid ff_print_debug_info(MpegEncContext *s, Picture *p, AVFrame *pict)\n{\n    ff_print_debug_info2(s->avctx, pict, s->mbskip_table, p->mb_type,\n                         p->qscale_table, p->motion_val, &s->low_delay,\n                         s->mb_width, s->mb_height, s->mb_stride, s->quarter_sample);\n}\n\nint ff_mpv_export_qp_table(MpegEncContext *s, AVFrame *f, Picture *p, int qp_type)\n{\n    AVBufferRef *ref = av_buffer_ref(p->qscale_table_buf);\n    int offset = 2*s->mb_stride + 1;\n    if(!ref)\n        return AVERROR(ENOMEM);\n    av_assert0(ref->size >= offset + s->mb_stride * ((f->height+15)/16));\n    ref->size -= offset;\n    ref->data += offset;\n    return av_frame_set_qp_table(f, ref, s->mb_stride, qp_type);\n}\n\nstatic inline int hpel_motion_lowres(MpegEncContext *s,\n                                     uint8_t *dest, uint8_t *src,\n                                     int field_based, int field_select,\n                                     int src_x, int src_y,\n                                     int width, int height, ptrdiff_t stride,\n                                     int h_edge_pos, int v_edge_pos,\n                                     int w, int h, h264_chroma_mc_func *pix_op,\n                                     int motion_x, int motion_y)\n{\n    const int lowres   = s->avctx->lowres;\n    const int op_index = FFMIN(lowres, 3);\n    const int s_mask   = (2 << lowres) - 1;\n    int emu = 0;\n    int sx, sy;\n\n    if (s->quarter_sample) {\n        motion_x /= 2;\n        motion_y /= 2;\n    }\n\n    sx = motion_x & s_mask;\n    sy = motion_y & s_mask;\n    src_x += motion_x >> lowres + 1;\n    src_y += motion_y >> lowres + 1;\n\n    src   += src_y * stride + src_x;\n\n    if ((unsigned)src_x > FFMAX( h_edge_pos - (!!sx) - w,                 0) ||\n        (unsigned)src_y > FFMAX((v_edge_pos >> field_based) - (!!sy) - h, 0)) {\n        s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, src,\n                                 s->linesize, s->linesize,\n                                 w + 1, (h + 1) << field_based,\n                                 src_x, src_y   << field_based,\n                                 h_edge_pos, v_edge_pos);\n        src = s->sc.edge_emu_buffer;\n        emu = 1;\n    }\n\n    sx = (sx << 2) >> lowres;\n    sy = (sy << 2) >> lowres;\n    if (field_select)\n        src += s->linesize;\n    pix_op[op_index](dest, src, stride, h, sx, sy);\n    return emu;\n}\n\n/* apply one mpeg motion vector to the three components */\nstatic av_always_inline void mpeg_motion_lowres(MpegEncContext *s,\n                                                uint8_t *dest_y,\n                                                uint8_t *dest_cb,\n                                                uint8_t *dest_cr,\n                                                int field_based,\n                                                int bottom_field,\n                                                int field_select,\n                                                uint8_t **ref_picture,\n                                                h264_chroma_mc_func *pix_op,\n                                                int motion_x, int motion_y,\n                                                int h, int mb_y)\n{\n    uint8_t *ptr_y, *ptr_cb, *ptr_cr;\n    int mx, my, src_x, src_y, uvsrc_x, uvsrc_y, sx, sy, uvsx, uvsy;\n    ptrdiff_t uvlinesize, linesize;\n    const int lowres     = s->avctx->lowres;\n    const int op_index   = FFMIN(lowres-1+s->chroma_x_shift, 3);\n    const int block_s    = 8>>lowres;\n    const int s_mask     = (2 << lowres) - 1;\n    const int h_edge_pos = s->h_edge_pos >> lowres;\n    const int v_edge_pos = s->v_edge_pos >> lowres;\n    linesize   = s->current_picture.f->linesize[0] << field_based;\n    uvlinesize = s->current_picture.f->linesize[1] << field_based;\n\n    // FIXME obviously not perfect but qpel will not work in lowres anyway\n    if (s->quarter_sample) {\n        motion_x /= 2;\n        motion_y /= 2;\n    }\n\n    if(field_based){\n        motion_y += (bottom_field - field_select)*((1 << lowres)-1);\n    }\n\n    sx = motion_x & s_mask;\n    sy = motion_y & s_mask;\n    src_x = s->mb_x * 2 * block_s + (motion_x >> lowres + 1);\n    src_y = (mb_y * 2 * block_s >> field_based) + (motion_y >> lowres + 1);\n\n    if (s->out_format == FMT_H263) {\n        uvsx    = ((motion_x >> 1) & s_mask) | (sx & 1);\n        uvsy    = ((motion_y >> 1) & s_mask) | (sy & 1);\n        uvsrc_x = src_x >> 1;\n        uvsrc_y = src_y >> 1;\n    } else if (s->out_format == FMT_H261) {\n        // even chroma mv's are full pel in H261\n        mx      = motion_x / 4;\n        my      = motion_y / 4;\n        uvsx    = (2 * mx) & s_mask;\n        uvsy    = (2 * my) & s_mask;\n        uvsrc_x = s->mb_x * block_s + (mx >> lowres);\n        uvsrc_y =    mb_y * block_s + (my >> lowres);\n    } else {\n        if(s->chroma_y_shift){\n            mx      = motion_x / 2;\n            my      = motion_y / 2;\n            uvsx    = mx & s_mask;\n            uvsy    = my & s_mask;\n            uvsrc_x = s->mb_x * block_s                 + (mx >> lowres + 1);\n            uvsrc_y =   (mb_y * block_s >> field_based) + (my >> lowres + 1);\n        } else {\n            if(s->chroma_x_shift){\n            //Chroma422\n                mx = motion_x / 2;\n                uvsx = mx & s_mask;\n                uvsy = motion_y & s_mask;\n                uvsrc_y = src_y;\n                uvsrc_x = s->mb_x*block_s               + (mx >> (lowres+1));\n            } else {\n            //Chroma444\n                uvsx = motion_x & s_mask;\n                uvsy = motion_y & s_mask;\n                uvsrc_x = src_x;\n                uvsrc_y = src_y;\n            }\n        }\n    }\n\n    ptr_y  = ref_picture[0] + src_y   * linesize   + src_x;\n    ptr_cb = ref_picture[1] + uvsrc_y * uvlinesize + uvsrc_x;\n    ptr_cr = ref_picture[2] + uvsrc_y * uvlinesize + uvsrc_x;\n\n    if ((unsigned) src_x > FFMAX( h_edge_pos - (!!sx) - 2 * block_s,       0) || uvsrc_y<0 ||\n        (unsigned) src_y > FFMAX((v_edge_pos >> field_based) - (!!sy) - h, 0)) {\n        s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, ptr_y,\n                                 linesize >> field_based, linesize >> field_based,\n                                 17, 17 + field_based,\n                                src_x, src_y << field_based, h_edge_pos,\n                                v_edge_pos);\n        ptr_y = s->sc.edge_emu_buffer;\n        if (!CONFIG_GRAY || !(s->avctx->flags & AV_CODEC_FLAG_GRAY)) {\n            uint8_t *ubuf = s->sc.edge_emu_buffer + 18 * s->linesize;\n            uint8_t *vbuf =ubuf + 10 * s->uvlinesize;\n            if (s->workaround_bugs & FF_BUG_IEDGE)\n                vbuf -= s->uvlinesize;\n            s->vdsp.emulated_edge_mc(ubuf,  ptr_cb,\n                                     uvlinesize >> field_based, uvlinesize >> field_based,\n                                     9, 9 + field_based,\n                                    uvsrc_x, uvsrc_y << field_based,\n                                    h_edge_pos >> 1, v_edge_pos >> 1);\n            s->vdsp.emulated_edge_mc(vbuf,  ptr_cr,\n                                     uvlinesize >> field_based,uvlinesize >> field_based,\n                                     9, 9 + field_based,\n                                    uvsrc_x, uvsrc_y << field_based,\n                                    h_edge_pos >> 1, v_edge_pos >> 1);\n            ptr_cb = ubuf;\n            ptr_cr = vbuf;\n        }\n    }\n\n    // FIXME use this for field pix too instead of the obnoxious hack which changes picture.f->data\n    if (bottom_field) {\n        dest_y  += s->linesize;\n        dest_cb += s->uvlinesize;\n        dest_cr += s->uvlinesize;\n    }\n\n    if (field_select) {\n        ptr_y   += s->linesize;\n        ptr_cb  += s->uvlinesize;\n        ptr_cr  += s->uvlinesize;\n    }\n\n    sx = (sx << 2) >> lowres;\n    sy = (sy << 2) >> lowres;\n    pix_op[lowres - 1](dest_y, ptr_y, linesize, h, sx, sy);\n\n    if (!CONFIG_GRAY || !(s->avctx->flags & AV_CODEC_FLAG_GRAY)) {\n        int hc = s->chroma_y_shift ? (h+1-bottom_field)>>1 : h;\n        uvsx = (uvsx << 2) >> lowres;\n        uvsy = (uvsy << 2) >> lowres;\n        if (hc) {\n            pix_op[op_index](dest_cb, ptr_cb, uvlinesize, hc, uvsx, uvsy);\n            pix_op[op_index](dest_cr, ptr_cr, uvlinesize, hc, uvsx, uvsy);\n        }\n    }\n    // FIXME h261 lowres loop filter\n}\n\nstatic inline void chroma_4mv_motion_lowres(MpegEncContext *s,\n                                            uint8_t *dest_cb, uint8_t *dest_cr,\n                                            uint8_t **ref_picture,\n                                            h264_chroma_mc_func * pix_op,\n                                            int mx, int my)\n{\n    const int lowres     = s->avctx->lowres;\n    const int op_index   = FFMIN(lowres, 3);\n    const int block_s    = 8 >> lowres;\n    const int s_mask     = (2 << lowres) - 1;\n    const int h_edge_pos = s->h_edge_pos >> lowres + 1;\n    const int v_edge_pos = s->v_edge_pos >> lowres + 1;\n    int emu = 0, src_x, src_y, sx, sy;\n    ptrdiff_t offset;\n    uint8_t *ptr;\n\n    if (s->quarter_sample) {\n        mx /= 2;\n        my /= 2;\n    }\n\n    /* In case of 8X8, we construct a single chroma motion vector\n       with a special rounding */\n    mx = ff_h263_round_chroma(mx);\n    my = ff_h263_round_chroma(my);\n\n    sx = mx & s_mask;\n    sy = my & s_mask;\n    src_x = s->mb_x * block_s + (mx >> lowres + 1);\n    src_y = s->mb_y * block_s + (my >> lowres + 1);\n\n    offset = src_y * s->uvlinesize + src_x;\n    ptr = ref_picture[1] + offset;\n    if ((unsigned) src_x > FFMAX(h_edge_pos - (!!sx) - block_s, 0) ||\n        (unsigned) src_y > FFMAX(v_edge_pos - (!!sy) - block_s, 0)) {\n        s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, ptr,\n                                 s->uvlinesize, s->uvlinesize,\n                                 9, 9,\n                                 src_x, src_y, h_edge_pos, v_edge_pos);\n        ptr = s->sc.edge_emu_buffer;\n        emu = 1;\n    }\n    sx = (sx << 2) >> lowres;\n    sy = (sy << 2) >> lowres;\n    pix_op[op_index](dest_cb, ptr, s->uvlinesize, block_s, sx, sy);\n\n    ptr = ref_picture[2] + offset;\n    if (emu) {\n        s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, ptr,\n                                 s->uvlinesize, s->uvlinesize,\n                                 9, 9,\n                                 src_x, src_y, h_edge_pos, v_edge_pos);\n        ptr = s->sc.edge_emu_buffer;\n    }\n    pix_op[op_index](dest_cr, ptr, s->uvlinesize, block_s, sx, sy);\n}\n\n/**\n * motion compensation of a single macroblock\n * @param s context\n * @param dest_y luma destination pointer\n * @param dest_cb chroma cb/u destination pointer\n * @param dest_cr chroma cr/v destination pointer\n * @param dir direction (0->forward, 1->backward)\n * @param ref_picture array[3] of pointers to the 3 planes of the reference picture\n * @param pix_op halfpel motion compensation function (average or put normally)\n * the motion vectors are taken from s->mv and the MV type from s->mv_type\n */\nstatic inline void MPV_motion_lowres(MpegEncContext *s,\n                                     uint8_t *dest_y, uint8_t *dest_cb,\n                                     uint8_t *dest_cr,\n                                     int dir, uint8_t **ref_picture,\n                                     h264_chroma_mc_func *pix_op)\n{\n    int mx, my;\n    int mb_x, mb_y, i;\n    const int lowres  = s->avctx->lowres;\n    const int block_s = 8 >>lowres;\n\n    mb_x = s->mb_x;\n    mb_y = s->mb_y;\n\n    switch (s->mv_type) {\n    case MV_TYPE_16X16:\n        mpeg_motion_lowres(s, dest_y, dest_cb, dest_cr,\n                           0, 0, 0,\n                           ref_picture, pix_op,\n                           s->mv[dir][0][0], s->mv[dir][0][1],\n                           2 * block_s, mb_y);\n        break;\n    case MV_TYPE_8X8:\n        mx = 0;\n        my = 0;\n        for (i = 0; i < 4; i++) {\n            hpel_motion_lowres(s, dest_y + ((i & 1) + (i >> 1) *\n                               s->linesize) * block_s,\n                               ref_picture[0], 0, 0,\n                               (2 * mb_x + (i & 1)) * block_s,\n                               (2 * mb_y + (i >> 1)) * block_s,\n                               s->width, s->height, s->linesize,\n                               s->h_edge_pos >> lowres, s->v_edge_pos >> lowres,\n                               block_s, block_s, pix_op,\n                               s->mv[dir][i][0], s->mv[dir][i][1]);\n\n            mx += s->mv[dir][i][0];\n            my += s->mv[dir][i][1];\n        }\n\n        if (!CONFIG_GRAY || !(s->avctx->flags & AV_CODEC_FLAG_GRAY))\n            chroma_4mv_motion_lowres(s, dest_cb, dest_cr, ref_picture,\n                                     pix_op, mx, my);\n        break;\n    case MV_TYPE_FIELD:\n        if (s->picture_structure == PICT_FRAME) {\n            /* top field */\n            mpeg_motion_lowres(s, dest_y, dest_cb, dest_cr,\n                               1, 0, s->field_select[dir][0],\n                               ref_picture, pix_op,\n                               s->mv[dir][0][0], s->mv[dir][0][1],\n                               block_s, mb_y);\n            /* bottom field */\n            mpeg_motion_lowres(s, dest_y, dest_cb, dest_cr,\n                               1, 1, s->field_select[dir][1],\n                               ref_picture, pix_op,\n                               s->mv[dir][1][0], s->mv[dir][1][1],\n                               block_s, mb_y);\n        } else {\n            if (s->picture_structure != s->field_select[dir][0] + 1 &&\n                s->pict_type != AV_PICTURE_TYPE_B && !s->first_field) {\n                ref_picture = s->current_picture_ptr->f->data;\n\n            }\n            mpeg_motion_lowres(s, dest_y, dest_cb, dest_cr,\n                               0, 0, s->field_select[dir][0],\n                               ref_picture, pix_op,\n                               s->mv[dir][0][0],\n                               s->mv[dir][0][1], 2 * block_s, mb_y >> 1);\n            }\n        break;\n    case MV_TYPE_16X8:\n        for (i = 0; i < 2; i++) {\n            uint8_t **ref2picture;\n\n            if (s->picture_structure == s->field_select[dir][i] + 1 ||\n                s->pict_type == AV_PICTURE_TYPE_B || s->first_field) {\n                ref2picture = ref_picture;\n            } else {\n                ref2picture = s->current_picture_ptr->f->data;\n            }\n\n            mpeg_motion_lowres(s, dest_y, dest_cb, dest_cr,\n                               0, 0, s->field_select[dir][i],\n                               ref2picture, pix_op,\n                               s->mv[dir][i][0], s->mv[dir][i][1] +\n                               2 * block_s * i, block_s, mb_y >> 1);\n\n            dest_y  +=  2 * block_s *  s->linesize;\n            dest_cb += (2 * block_s >> s->chroma_y_shift) * s->uvlinesize;\n            dest_cr += (2 * block_s >> s->chroma_y_shift) * s->uvlinesize;\n        }\n        break;\n    case MV_TYPE_DMV:\n        if (s->picture_structure == PICT_FRAME) {\n            for (i = 0; i < 2; i++) {\n                int j;\n                for (j = 0; j < 2; j++) {\n                    mpeg_motion_lowres(s, dest_y, dest_cb, dest_cr,\n                                       1, j, j ^ i,\n                                       ref_picture, pix_op,\n                                       s->mv[dir][2 * i + j][0],\n                                       s->mv[dir][2 * i + j][1],\n                                       block_s, mb_y);\n                }\n                pix_op = s->h264chroma.avg_h264_chroma_pixels_tab;\n            }\n        } else {\n            for (i = 0; i < 2; i++) {\n                mpeg_motion_lowres(s, dest_y, dest_cb, dest_cr,\n                                   0, 0, s->picture_structure != i + 1,\n                                   ref_picture, pix_op,\n                                   s->mv[dir][2 * i][0],s->mv[dir][2 * i][1],\n                                   2 * block_s, mb_y >> 1);\n\n                // after put we make avg of the same block\n                pix_op = s->h264chroma.avg_h264_chroma_pixels_tab;\n\n                // opposite parity is always in the same\n                // frame if this is second field\n                if (!s->first_field) {\n                    ref_picture = s->current_picture_ptr->f->data;\n                }\n            }\n        }\n        break;\n    default:\n        av_assert2(0);\n    }\n}\n\n/**\n * find the lowest MB row referenced in the MVs\n */\nstatic int lowest_referenced_row(MpegEncContext *s, int dir)\n{\n    int my_max = INT_MIN, my_min = INT_MAX, qpel_shift = !s->quarter_sample;\n    int my, off, i, mvs;\n\n    if (s->picture_structure != PICT_FRAME || s->mcsel)\n        goto unhandled;\n\n    switch (s->mv_type) {\n        case MV_TYPE_16X16:\n            mvs = 1;\n            break;\n        case MV_TYPE_16X8:\n            mvs = 2;\n            break;\n        case MV_TYPE_8X8:\n            mvs = 4;\n            break;\n        default:\n            goto unhandled;\n    }\n\n    for (i = 0; i < mvs; i++) {\n        my = s->mv[dir][i][1];\n        my_max = FFMAX(my_max, my);\n        my_min = FFMIN(my_min, my);\n    }\n\n    off = ((FFMAX(-my_min, my_max)<<qpel_shift) + 63) >> 6;\n\n    return av_clip(s->mb_y + off, 0, s->mb_height - 1);\nunhandled:\n    return s->mb_height-1;\n}\n\n/* put block[] to dest[] */\nstatic inline void put_dct(MpegEncContext *s,\n                           int16_t *block, int i, uint8_t *dest, int line_size, int qscale)\n{\n    s->dct_unquantize_intra(s, block, i, qscale);\n    s->idsp.idct_put(dest, line_size, block);\n}\n\n/* add block[] to dest[] */\nstatic inline void add_dct(MpegEncContext *s,\n                           int16_t *block, int i, uint8_t *dest, int line_size)\n{\n    if (s->block_last_index[i] >= 0) {\n        s->idsp.idct_add(dest, line_size, block);\n    }\n}\n\nstatic inline void add_dequant_dct(MpegEncContext *s,\n                           int16_t *block, int i, uint8_t *dest, int line_size, int qscale)\n{\n    if (s->block_last_index[i] >= 0) {\n        s->dct_unquantize_inter(s, block, i, qscale);\n\n        s->idsp.idct_add(dest, line_size, block);\n    }\n}\n\n/**\n * Clean dc, ac, coded_block for the current non-intra MB.\n */\nvoid ff_clean_intra_table_entries(MpegEncContext *s)\n{\n    int wrap = s->b8_stride;\n    int xy = s->block_index[0];\n\n    s->dc_val[0][xy           ] =\n    s->dc_val[0][xy + 1       ] =\n    s->dc_val[0][xy     + wrap] =\n    s->dc_val[0][xy + 1 + wrap] = 1024;\n    /* ac pred */\n    memset(s->ac_val[0][xy       ], 0, 32 * sizeof(int16_t));\n    memset(s->ac_val[0][xy + wrap], 0, 32 * sizeof(int16_t));\n    if (s->msmpeg4_version>=3) {\n        s->coded_block[xy           ] =\n        s->coded_block[xy + 1       ] =\n        s->coded_block[xy     + wrap] =\n        s->coded_block[xy + 1 + wrap] = 0;\n    }\n    /* chroma */\n    wrap = s->mb_stride;\n    xy = s->mb_x + s->mb_y * wrap;\n    s->dc_val[1][xy] =\n    s->dc_val[2][xy] = 1024;\n    /* ac pred */\n    memset(s->ac_val[1][xy], 0, 16 * sizeof(int16_t));\n    memset(s->ac_val[2][xy], 0, 16 * sizeof(int16_t));\n\n    s->mbintra_table[xy]= 0;\n}\n\n/* generic function called after a macroblock has been parsed by the\n   decoder or after it has been encoded by the encoder.\n\n   Important variables used:\n   s->mb_intra : true if intra macroblock\n   s->mv_dir   : motion vector direction\n   s->mv_type  : motion vector type\n   s->mv       : motion vector\n   s->interlaced_dct : true if interlaced dct used (mpeg2)\n */\nstatic av_always_inline\nvoid mpv_reconstruct_mb_internal(MpegEncContext *s, int16_t block[12][64],\n                            int lowres_flag, int is_mpeg12)\n{\n    const int mb_xy = s->mb_y * s->mb_stride + s->mb_x;\n\n    if (CONFIG_XVMC &&\n        s->avctx->hwaccel && s->avctx->hwaccel->decode_mb) {\n        s->avctx->hwaccel->decode_mb(s);//xvmc uses pblocks\n        return;\n    }\n\n    if(s->avctx->debug&FF_DEBUG_DCT_COEFF) {\n       /* print DCT coefficients */\n       int i,j;\n       av_log(s->avctx, AV_LOG_DEBUG, \"DCT coeffs of MB at %dx%d:\\n\", s->mb_x, s->mb_y);\n       for(i=0; i<6; i++){\n           for(j=0; j<64; j++){\n               av_log(s->avctx, AV_LOG_DEBUG, \"%5d\",\n                      block[i][s->idsp.idct_permutation[j]]);\n           }\n           av_log(s->avctx, AV_LOG_DEBUG, \"\\n\");\n       }\n    }\n\n    s->current_picture.qscale_table[mb_xy] = s->qscale;\n\n    /* update DC predictors for P macroblocks */\n    if (!s->mb_intra) {\n        if (!is_mpeg12 && (s->h263_pred || s->h263_aic)) {\n            if(s->mbintra_table[mb_xy])\n                ff_clean_intra_table_entries(s);\n        } else {\n            s->last_dc[0] =\n            s->last_dc[1] =\n            s->last_dc[2] = 128 << s->intra_dc_precision;\n        }\n    }\n    else if (!is_mpeg12 && (s->h263_pred || s->h263_aic))\n        s->mbintra_table[mb_xy]=1;\n\n    if ((s->avctx->flags & AV_CODEC_FLAG_PSNR) || s->frame_skip_threshold || s->frame_skip_factor ||\n        !(s->encoding && (s->intra_only || s->pict_type == AV_PICTURE_TYPE_B) &&\n          s->avctx->mb_decision != FF_MB_DECISION_RD)) { // FIXME precalc\n        uint8_t *dest_y, *dest_cb, *dest_cr;\n        int dct_linesize, dct_offset;\n        op_pixels_func (*op_pix)[4];\n        qpel_mc_func (*op_qpix)[16];\n        const int linesize   = s->current_picture.f->linesize[0]; //not s->linesize as this would be wrong for field pics\n        const int uvlinesize = s->current_picture.f->linesize[1];\n        const int readable= s->pict_type != AV_PICTURE_TYPE_B || s->encoding || s->avctx->draw_horiz_band || lowres_flag;\n        const int block_size= lowres_flag ? 8>>s->avctx->lowres : 8;\n\n        /* avoid copy if macroblock skipped in last frame too */\n        /* skip only during decoding as we might trash the buffers during encoding a bit */\n        if(!s->encoding){\n            uint8_t *mbskip_ptr = &s->mbskip_table[mb_xy];\n\n            if (s->mb_skipped) {\n                s->mb_skipped= 0;\n                av_assert2(s->pict_type!=AV_PICTURE_TYPE_I);\n                *mbskip_ptr = 1;\n            } else if(!s->current_picture.reference) {\n                *mbskip_ptr = 1;\n            } else{\n                *mbskip_ptr = 0; /* not skipped */\n            }\n        }\n\n        dct_linesize = linesize << s->interlaced_dct;\n        dct_offset   = s->interlaced_dct ? linesize : linesize * block_size;\n\n        if(readable){\n            dest_y=  s->dest[0];\n            dest_cb= s->dest[1];\n            dest_cr= s->dest[2];\n        }else{\n            dest_y = s->sc.b_scratchpad;\n            dest_cb= s->sc.b_scratchpad+16*linesize;\n            dest_cr= s->sc.b_scratchpad+32*linesize;\n        }\n\n        if (!s->mb_intra) {\n            /* motion handling */\n            /* decoding or more than one mb_type (MC was already done otherwise) */\n            if(!s->encoding){\n\n                if(HAVE_THREADS && s->avctx->active_thread_type&FF_THREAD_FRAME) {\n                    if (s->mv_dir & MV_DIR_FORWARD) {\n                        ff_thread_await_progress(&s->last_picture_ptr->tf,\n                                                 lowest_referenced_row(s, 0),\n                                                 0);\n                    }\n                    if (s->mv_dir & MV_DIR_BACKWARD) {\n                        ff_thread_await_progress(&s->next_picture_ptr->tf,\n                                                 lowest_referenced_row(s, 1),\n                                                 0);\n                    }\n                }\n\n                if(lowres_flag){\n                    h264_chroma_mc_func *op_pix = s->h264chroma.put_h264_chroma_pixels_tab;\n\n                    if (s->mv_dir & MV_DIR_FORWARD) {\n                        MPV_motion_lowres(s, dest_y, dest_cb, dest_cr, 0, s->last_picture.f->data, op_pix);\n                        op_pix = s->h264chroma.avg_h264_chroma_pixels_tab;\n                    }\n                    if (s->mv_dir & MV_DIR_BACKWARD) {\n                        MPV_motion_lowres(s, dest_y, dest_cb, dest_cr, 1, s->next_picture.f->data, op_pix);\n                    }\n                }else{\n                    op_qpix = s->me.qpel_put;\n                    if ((!s->no_rounding) || s->pict_type==AV_PICTURE_TYPE_B){\n                        op_pix = s->hdsp.put_pixels_tab;\n                    }else{\n                        op_pix = s->hdsp.put_no_rnd_pixels_tab;\n                    }\n                    if (s->mv_dir & MV_DIR_FORWARD) {\n                        ff_mpv_motion(s, dest_y, dest_cb, dest_cr, 0, s->last_picture.f->data, op_pix, op_qpix);\n                        op_pix = s->hdsp.avg_pixels_tab;\n                        op_qpix= s->me.qpel_avg;\n                    }\n                    if (s->mv_dir & MV_DIR_BACKWARD) {\n                        ff_mpv_motion(s, dest_y, dest_cb, dest_cr, 1, s->next_picture.f->data, op_pix, op_qpix);\n                    }\n                }\n            }\n\n            /* skip dequant / idct if we are really late ;) */\n            if(s->avctx->skip_idct){\n                if(  (s->avctx->skip_idct >= AVDISCARD_NONREF && s->pict_type == AV_PICTURE_TYPE_B)\n                   ||(s->avctx->skip_idct >= AVDISCARD_NONKEY && s->pict_type != AV_PICTURE_TYPE_I)\n                   || s->avctx->skip_idct >= AVDISCARD_ALL)\n                    goto skip_idct;\n            }\n\n            /* add dct residue */\n            if(s->encoding || !(   s->msmpeg4_version || s->codec_id==AV_CODEC_ID_MPEG1VIDEO || s->codec_id==AV_CODEC_ID_MPEG2VIDEO\n                                || (s->codec_id==AV_CODEC_ID_MPEG4 && !s->mpeg_quant))){\n                add_dequant_dct(s, block[0], 0, dest_y                          , dct_linesize, s->qscale);\n                add_dequant_dct(s, block[1], 1, dest_y              + block_size, dct_linesize, s->qscale);\n                add_dequant_dct(s, block[2], 2, dest_y + dct_offset             , dct_linesize, s->qscale);\n                add_dequant_dct(s, block[3], 3, dest_y + dct_offset + block_size, dct_linesize, s->qscale);\n\n                if (!CONFIG_GRAY || !(s->avctx->flags & AV_CODEC_FLAG_GRAY)) {\n                    if (s->chroma_y_shift){\n                        add_dequant_dct(s, block[4], 4, dest_cb, uvlinesize, s->chroma_qscale);\n                        add_dequant_dct(s, block[5], 5, dest_cr, uvlinesize, s->chroma_qscale);\n                    }else{\n                        dct_linesize >>= 1;\n                        dct_offset >>=1;\n                        add_dequant_dct(s, block[4], 4, dest_cb,              dct_linesize, s->chroma_qscale);\n                        add_dequant_dct(s, block[5], 5, dest_cr,              dct_linesize, s->chroma_qscale);\n                        add_dequant_dct(s, block[6], 6, dest_cb + dct_offset, dct_linesize, s->chroma_qscale);\n                        add_dequant_dct(s, block[7], 7, dest_cr + dct_offset, dct_linesize, s->chroma_qscale);\n                    }\n                }\n            } else if(is_mpeg12 || (s->codec_id != AV_CODEC_ID_WMV2)){\n                add_dct(s, block[0], 0, dest_y                          , dct_linesize);\n                add_dct(s, block[1], 1, dest_y              + block_size, dct_linesize);\n                add_dct(s, block[2], 2, dest_y + dct_offset             , dct_linesize);\n                add_dct(s, block[3], 3, dest_y + dct_offset + block_size, dct_linesize);\n\n                if (!CONFIG_GRAY || !(s->avctx->flags & AV_CODEC_FLAG_GRAY)) {\n                    if(s->chroma_y_shift){//Chroma420\n                        add_dct(s, block[4], 4, dest_cb, uvlinesize);\n                        add_dct(s, block[5], 5, dest_cr, uvlinesize);\n                    }else{\n                        //chroma422\n                        dct_linesize = uvlinesize << s->interlaced_dct;\n                        dct_offset   = s->interlaced_dct ? uvlinesize : uvlinesize*block_size;\n\n                        add_dct(s, block[4], 4, dest_cb, dct_linesize);\n                        add_dct(s, block[5], 5, dest_cr, dct_linesize);\n                        add_dct(s, block[6], 6, dest_cb+dct_offset, dct_linesize);\n                        add_dct(s, block[7], 7, dest_cr+dct_offset, dct_linesize);\n                        if(!s->chroma_x_shift){//Chroma444\n                            add_dct(s, block[8], 8, dest_cb+block_size, dct_linesize);\n                            add_dct(s, block[9], 9, dest_cr+block_size, dct_linesize);\n                            add_dct(s, block[10], 10, dest_cb+block_size+dct_offset, dct_linesize);\n                            add_dct(s, block[11], 11, dest_cr+block_size+dct_offset, dct_linesize);\n                        }\n                    }\n                }//fi gray\n            }\n            else if (CONFIG_WMV2_DECODER || CONFIG_WMV2_ENCODER) {\n                ff_wmv2_add_mb(s, block, dest_y, dest_cb, dest_cr);\n            }\n        } else {\n            /* Only MPEG-4 Simple Studio Profile is supported in > 8-bit mode.\n               TODO: Integrate 10-bit properly into mpegvideo.c so that ER works properly */\n            if (s->avctx->bits_per_raw_sample > 8){\n                const int act_block_size = block_size * 2;\n                s->idsp.idct_put(dest_y,                           dct_linesize, (int16_t*)(*s->block32)[0]);\n                s->idsp.idct_put(dest_y              + act_block_size, dct_linesize, (int16_t*)(*s->block32)[1]);\n                s->idsp.idct_put(dest_y + dct_offset,              dct_linesize, (int16_t*)(*s->block32)[2]);\n                s->idsp.idct_put(dest_y + dct_offset + act_block_size, dct_linesize, (int16_t*)(*s->block32)[3]);\n\n                dct_linesize = uvlinesize << s->interlaced_dct;\n                dct_offset   = s->interlaced_dct ? uvlinesize : uvlinesize*block_size;\n\n                s->idsp.idct_put(dest_cb,              dct_linesize, (int16_t*)(*s->block32)[4]);\n                s->idsp.idct_put(dest_cr,              dct_linesize, (int16_t*)(*s->block32)[5]);\n                s->idsp.idct_put(dest_cb + dct_offset, dct_linesize, (int16_t*)(*s->block32)[6]);\n                s->idsp.idct_put(dest_cr + dct_offset, dct_linesize, (int16_t*)(*s->block32)[7]);\n                if(!s->chroma_x_shift){//Chroma444\n                    s->idsp.idct_put(dest_cb + act_block_size,              dct_linesize, (int16_t*)(*s->block32)[8]);\n                    s->idsp.idct_put(dest_cr + act_block_size,              dct_linesize, (int16_t*)(*s->block32)[9]);\n                    s->idsp.idct_put(dest_cb + act_block_size + dct_offset, dct_linesize, (int16_t*)(*s->block32)[10]);\n                    s->idsp.idct_put(dest_cr + act_block_size + dct_offset, dct_linesize, (int16_t*)(*s->block32)[11]);\n                }\n            }\n            /* dct only in intra block */\n            else if(s->encoding || !(s->codec_id==AV_CODEC_ID_MPEG1VIDEO || s->codec_id==AV_CODEC_ID_MPEG2VIDEO)){\n                put_dct(s, block[0], 0, dest_y                          , dct_linesize, s->qscale);\n                put_dct(s, block[1], 1, dest_y              + block_size, dct_linesize, s->qscale);\n                put_dct(s, block[2], 2, dest_y + dct_offset             , dct_linesize, s->qscale);\n                put_dct(s, block[3], 3, dest_y + dct_offset + block_size, dct_linesize, s->qscale);\n\n                if (!CONFIG_GRAY || !(s->avctx->flags & AV_CODEC_FLAG_GRAY)) {\n                    if(s->chroma_y_shift){\n                        put_dct(s, block[4], 4, dest_cb, uvlinesize, s->chroma_qscale);\n                        put_dct(s, block[5], 5, dest_cr, uvlinesize, s->chroma_qscale);\n                    }else{\n                        dct_offset >>=1;\n                        dct_linesize >>=1;\n                        put_dct(s, block[4], 4, dest_cb,              dct_linesize, s->chroma_qscale);\n                        put_dct(s, block[5], 5, dest_cr,              dct_linesize, s->chroma_qscale);\n                        put_dct(s, block[6], 6, dest_cb + dct_offset, dct_linesize, s->chroma_qscale);\n                        put_dct(s, block[7], 7, dest_cr + dct_offset, dct_linesize, s->chroma_qscale);\n                    }\n                }\n            }else{\n                s->idsp.idct_put(dest_y,                           dct_linesize, block[0]);\n                s->idsp.idct_put(dest_y              + block_size, dct_linesize, block[1]);\n                s->idsp.idct_put(dest_y + dct_offset,              dct_linesize, block[2]);\n                s->idsp.idct_put(dest_y + dct_offset + block_size, dct_linesize, block[3]);\n\n                if (!CONFIG_GRAY || !(s->avctx->flags & AV_CODEC_FLAG_GRAY)) {\n                    if(s->chroma_y_shift){\n                        s->idsp.idct_put(dest_cb, uvlinesize, block[4]);\n                        s->idsp.idct_put(dest_cr, uvlinesize, block[5]);\n                    }else{\n\n                        dct_linesize = uvlinesize << s->interlaced_dct;\n                        dct_offset   = s->interlaced_dct ? uvlinesize : uvlinesize*block_size;\n\n                        s->idsp.idct_put(dest_cb,              dct_linesize, block[4]);\n                        s->idsp.idct_put(dest_cr,              dct_linesize, block[5]);\n                        s->idsp.idct_put(dest_cb + dct_offset, dct_linesize, block[6]);\n                        s->idsp.idct_put(dest_cr + dct_offset, dct_linesize, block[7]);\n                        if(!s->chroma_x_shift){//Chroma444\n                            s->idsp.idct_put(dest_cb + block_size,              dct_linesize, block[8]);\n                            s->idsp.idct_put(dest_cr + block_size,              dct_linesize, block[9]);\n                            s->idsp.idct_put(dest_cb + block_size + dct_offset, dct_linesize, block[10]);\n                            s->idsp.idct_put(dest_cr + block_size + dct_offset, dct_linesize, block[11]);\n                        }\n                    }\n                }//gray\n            }\n        }\nskip_idct:\n        if(!readable){\n            s->hdsp.put_pixels_tab[0][0](s->dest[0], dest_y ,   linesize,16);\n            if (!CONFIG_GRAY || !(s->avctx->flags & AV_CODEC_FLAG_GRAY)) {\n                s->hdsp.put_pixels_tab[s->chroma_x_shift][0](s->dest[1], dest_cb, uvlinesize,16 >> s->chroma_y_shift);\n                s->hdsp.put_pixels_tab[s->chroma_x_shift][0](s->dest[2], dest_cr, uvlinesize,16 >> s->chroma_y_shift);\n            }\n        }\n    }\n}\n\nvoid ff_mpv_reconstruct_mb(MpegEncContext *s, int16_t block[12][64])\n{\n#if !CONFIG_SMALL\n    if(s->out_format == FMT_MPEG1) {\n        if(s->avctx->lowres) mpv_reconstruct_mb_internal(s, block, 1, 1);\n        else                 mpv_reconstruct_mb_internal(s, block, 0, 1);\n    } else\n#endif\n    if(s->avctx->lowres) mpv_reconstruct_mb_internal(s, block, 1, 0);\n    else                  mpv_reconstruct_mb_internal(s, block, 0, 0);\n}\n\nvoid ff_mpeg_draw_horiz_band(MpegEncContext *s, int y, int h)\n{\n    ff_draw_horiz_band(s->avctx, s->current_picture_ptr->f,\n                       s->last_picture_ptr ? s->last_picture_ptr->f : NULL, y, h, s->picture_structure,\n                       s->first_field, s->low_delay);\n}\n\nvoid ff_init_block_index(MpegEncContext *s){ //FIXME maybe rename\n    const int linesize   = s->current_picture.f->linesize[0]; //not s->linesize as this would be wrong for field pics\n    const int uvlinesize = s->current_picture.f->linesize[1];\n    const int width_of_mb = (4 + (s->avctx->bits_per_raw_sample > 8)) - s->avctx->lowres;\n    const int height_of_mb = 4 - s->avctx->lowres;\n\n    s->block_index[0]= s->b8_stride*(s->mb_y*2    ) - 2 + s->mb_x*2;\n    s->block_index[1]= s->b8_stride*(s->mb_y*2    ) - 1 + s->mb_x*2;\n    s->block_index[2]= s->b8_stride*(s->mb_y*2 + 1) - 2 + s->mb_x*2;\n    s->block_index[3]= s->b8_stride*(s->mb_y*2 + 1) - 1 + s->mb_x*2;\n    s->block_index[4]= s->mb_stride*(s->mb_y + 1)                + s->b8_stride*s->mb_height*2 + s->mb_x - 1;\n    s->block_index[5]= s->mb_stride*(s->mb_y + s->mb_height + 2) + s->b8_stride*s->mb_height*2 + s->mb_x - 1;\n    //block_index is not used by mpeg2, so it is not affected by chroma_format\n\n    s->dest[0] = s->current_picture.f->data[0] + (int)((s->mb_x - 1U) <<  width_of_mb);\n    s->dest[1] = s->current_picture.f->data[1] + (int)((s->mb_x - 1U) << (width_of_mb - s->chroma_x_shift));\n    s->dest[2] = s->current_picture.f->data[2] + (int)((s->mb_x - 1U) << (width_of_mb - s->chroma_x_shift));\n\n    if(!(s->pict_type==AV_PICTURE_TYPE_B && s->avctx->draw_horiz_band && s->picture_structure==PICT_FRAME))\n    {\n        if(s->picture_structure==PICT_FRAME){\n        s->dest[0] += s->mb_y *   linesize << height_of_mb;\n        s->dest[1] += s->mb_y * uvlinesize << (height_of_mb - s->chroma_y_shift);\n        s->dest[2] += s->mb_y * uvlinesize << (height_of_mb - s->chroma_y_shift);\n        }else{\n            s->dest[0] += (s->mb_y>>1) *   linesize << height_of_mb;\n            s->dest[1] += (s->mb_y>>1) * uvlinesize << (height_of_mb - s->chroma_y_shift);\n            s->dest[2] += (s->mb_y>>1) * uvlinesize << (height_of_mb - s->chroma_y_shift);\n            av_assert1((s->mb_y&1) == (s->picture_structure == PICT_BOTTOM_FIELD));\n        }\n    }\n}\n\nvoid ff_mpeg_flush(AVCodecContext *avctx){\n    int i;\n    MpegEncContext *s = avctx->priv_data;\n\n    if (!s || !s->picture)\n        return;\n\n    for (i = 0; i < MAX_PICTURE_COUNT; i++)\n        ff_mpeg_unref_picture(s->avctx, &s->picture[i]);\n    s->current_picture_ptr = s->last_picture_ptr = s->next_picture_ptr = NULL;\n\n    ff_mpeg_unref_picture(s->avctx, &s->current_picture);\n    ff_mpeg_unref_picture(s->avctx, &s->last_picture);\n    ff_mpeg_unref_picture(s->avctx, &s->next_picture);\n\n    s->mb_x= s->mb_y= 0;\n    s->closed_gop= 0;\n\n    s->parse_context.state= -1;\n    s->parse_context.frame_start_found= 0;\n    s->parse_context.overread= 0;\n    s->parse_context.overread_index= 0;\n    s->parse_context.index= 0;\n    s->parse_context.last_index= 0;\n    s->bitstream_buffer_size=0;\n    s->pp_time=0;\n}\n\n/**\n * set qscale and update qscale dependent variables.\n */\nvoid ff_set_qscale(MpegEncContext * s, int qscale)\n{\n    if (qscale < 1)\n        qscale = 1;\n    else if (qscale > 31)\n        qscale = 31;\n\n    s->qscale = qscale;\n    s->chroma_qscale= s->chroma_qscale_table[qscale];\n\n    s->y_dc_scale= s->y_dc_scale_table[ qscale ];\n    s->c_dc_scale= s->c_dc_scale_table[ s->chroma_qscale ];\n}\n\nvoid ff_mpv_report_decode_progress(MpegEncContext *s)\n{\n    if (s->pict_type != AV_PICTURE_TYPE_B && !s->partitioned_frame && !s->er.error_occurred)\n        ff_thread_report_progress(&s->current_picture_ptr->tf, s->mb_y, 0);\n}\n"], "fixing_code": ["/*\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"config.h\"\n#include \"libavutil/attributes.h\"\n#include \"libavutil/common.h\"\n#include \"avcodec.h\"\n#include \"dct.h\"\n#include \"faanidct.h\"\n#include \"idctdsp.h\"\n#include \"simple_idct.h\"\n#include \"xvididct.h\"\n\nav_cold void ff_init_scantable(uint8_t *permutation, ScanTable *st,\n                               const uint8_t *src_scantable)\n{\n    int i, end;\n\n    st->scantable = src_scantable;\n\n    for (i = 0; i < 64; i++) {\n        int j = src_scantable[i];\n        st->permutated[i] = permutation[j];\n    }\n\n    end = -1;\n    for (i = 0; i < 64; i++) {\n        int j = st->permutated[i];\n        if (j > end)\n            end = j;\n        st->raster_end[i] = end;\n    }\n}\n\nav_cold void ff_init_scantable_permutation(uint8_t *idct_permutation,\n                                           enum idct_permutation_type perm_type)\n{\n    int i;\n\n    if (ARCH_X86)\n        if (ff_init_scantable_permutation_x86(idct_permutation,\n                                              perm_type))\n            return;\n\n    switch (perm_type) {\n    case FF_IDCT_PERM_NONE:\n        for (i = 0; i < 64; i++)\n            idct_permutation[i] = i;\n        break;\n    case FF_IDCT_PERM_LIBMPEG2:\n        for (i = 0; i < 64; i++)\n            idct_permutation[i] = (i & 0x38) | ((i & 6) >> 1) | ((i & 1) << 2);\n        break;\n    case FF_IDCT_PERM_TRANSPOSE:\n        for (i = 0; i < 64; i++)\n            idct_permutation[i] = ((i & 7) << 3) | (i >> 3);\n        break;\n    case FF_IDCT_PERM_PARTTRANS:\n        for (i = 0; i < 64; i++)\n            idct_permutation[i] = (i & 0x24) | ((i & 3) << 3) | ((i >> 3) & 3);\n        break;\n    default:\n        av_log(NULL, AV_LOG_ERROR,\n               \"Internal error, IDCT permutation not set\\n\");\n    }\n}\n\nvoid ff_put_pixels_clamped_c(const int16_t *block, uint8_t *av_restrict pixels,\n                             ptrdiff_t line_size)\n{\n    int i;\n\n    /* read the pixels */\n    for (i = 0; i < 8; i++) {\n        pixels[0] = av_clip_uint8(block[0]);\n        pixels[1] = av_clip_uint8(block[1]);\n        pixels[2] = av_clip_uint8(block[2]);\n        pixels[3] = av_clip_uint8(block[3]);\n        pixels[4] = av_clip_uint8(block[4]);\n        pixels[5] = av_clip_uint8(block[5]);\n        pixels[6] = av_clip_uint8(block[6]);\n        pixels[7] = av_clip_uint8(block[7]);\n\n        pixels += line_size;\n        block  += 8;\n    }\n}\n\nstatic void put_pixels_clamped4_c(const int16_t *block, uint8_t *av_restrict pixels,\n                                 int line_size)\n{\n    int i;\n\n    /* read the pixels */\n    for(i=0;i<4;i++) {\n        pixels[0] = av_clip_uint8(block[0]);\n        pixels[1] = av_clip_uint8(block[1]);\n        pixels[2] = av_clip_uint8(block[2]);\n        pixels[3] = av_clip_uint8(block[3]);\n\n        pixels += line_size;\n        block += 8;\n    }\n}\n\nstatic void put_pixels_clamped2_c(const int16_t *block, uint8_t *av_restrict pixels,\n                                 int line_size)\n{\n    int i;\n\n    /* read the pixels */\n    for(i=0;i<2;i++) {\n        pixels[0] = av_clip_uint8(block[0]);\n        pixels[1] = av_clip_uint8(block[1]);\n\n        pixels += line_size;\n        block += 8;\n    }\n}\n\nstatic void put_signed_pixels_clamped_c(const int16_t *block,\n                                        uint8_t *av_restrict pixels,\n                                        ptrdiff_t line_size)\n{\n    int i, j;\n\n    for (i = 0; i < 8; i++) {\n        for (j = 0; j < 8; j++) {\n            if (*block < -128)\n                *pixels = 0;\n            else if (*block > 127)\n                *pixels = 255;\n            else\n                *pixels = (uint8_t) (*block + 128);\n            block++;\n            pixels++;\n        }\n        pixels += (line_size - 8);\n    }\n}\n\nvoid ff_add_pixels_clamped_c(const int16_t *block, uint8_t *av_restrict pixels,\n                             ptrdiff_t line_size)\n{\n    int i;\n\n    /* read the pixels */\n    for (i = 0; i < 8; i++) {\n        pixels[0] = av_clip_uint8(pixels[0] + block[0]);\n        pixels[1] = av_clip_uint8(pixels[1] + block[1]);\n        pixels[2] = av_clip_uint8(pixels[2] + block[2]);\n        pixels[3] = av_clip_uint8(pixels[3] + block[3]);\n        pixels[4] = av_clip_uint8(pixels[4] + block[4]);\n        pixels[5] = av_clip_uint8(pixels[5] + block[5]);\n        pixels[6] = av_clip_uint8(pixels[6] + block[6]);\n        pixels[7] = av_clip_uint8(pixels[7] + block[7]);\n        pixels   += line_size;\n        block    += 8;\n    }\n}\n\nstatic void add_pixels_clamped4_c(const int16_t *block, uint8_t *av_restrict pixels,\n                          int line_size)\n{\n    int i;\n\n    /* read the pixels */\n    for(i=0;i<4;i++) {\n        pixels[0] = av_clip_uint8(pixels[0] + block[0]);\n        pixels[1] = av_clip_uint8(pixels[1] + block[1]);\n        pixels[2] = av_clip_uint8(pixels[2] + block[2]);\n        pixels[3] = av_clip_uint8(pixels[3] + block[3]);\n        pixels += line_size;\n        block += 8;\n    }\n}\n\nstatic void add_pixels_clamped2_c(const int16_t *block, uint8_t *av_restrict pixels,\n                          int line_size)\n{\n    int i;\n\n    /* read the pixels */\n    for(i=0;i<2;i++) {\n        pixels[0] = av_clip_uint8(pixels[0] + block[0]);\n        pixels[1] = av_clip_uint8(pixels[1] + block[1]);\n        pixels += line_size;\n        block += 8;\n    }\n}\n\nstatic void ff_jref_idct4_put(uint8_t *dest, ptrdiff_t line_size, int16_t *block)\n{\n    ff_j_rev_dct4 (block);\n    put_pixels_clamped4_c(block, dest, line_size);\n}\nstatic void ff_jref_idct4_add(uint8_t *dest, ptrdiff_t line_size, int16_t *block)\n{\n    ff_j_rev_dct4 (block);\n    add_pixels_clamped4_c(block, dest, line_size);\n}\n\nstatic void ff_jref_idct2_put(uint8_t *dest, ptrdiff_t line_size, int16_t *block)\n{\n    ff_j_rev_dct2 (block);\n    put_pixels_clamped2_c(block, dest, line_size);\n}\nstatic void ff_jref_idct2_add(uint8_t *dest, ptrdiff_t line_size, int16_t *block)\n{\n    ff_j_rev_dct2 (block);\n    add_pixels_clamped2_c(block, dest, line_size);\n}\n\nstatic void ff_jref_idct1_put(uint8_t *dest, ptrdiff_t line_size, int16_t *block)\n{\n    dest[0] = av_clip_uint8((block[0] + 4)>>3);\n}\nstatic void ff_jref_idct1_add(uint8_t *dest, ptrdiff_t line_size, int16_t *block)\n{\n    dest[0] = av_clip_uint8(dest[0] + ((block[0] + 4)>>3));\n}\n\nav_cold void ff_idctdsp_init(IDCTDSPContext *c, AVCodecContext *avctx)\n{\n    const unsigned high_bit_depth = avctx->bits_per_raw_sample > 8;\n\n    if (avctx->lowres==1) {\n        c->idct_put  = ff_jref_idct4_put;\n        c->idct_add  = ff_jref_idct4_add;\n        c->idct      = ff_j_rev_dct4;\n        c->perm_type = FF_IDCT_PERM_NONE;\n    } else if (avctx->lowres==2) {\n        c->idct_put  = ff_jref_idct2_put;\n        c->idct_add  = ff_jref_idct2_add;\n        c->idct      = ff_j_rev_dct2;\n        c->perm_type = FF_IDCT_PERM_NONE;\n    } else if (avctx->lowres==3) {\n        c->idct_put  = ff_jref_idct1_put;\n        c->idct_add  = ff_jref_idct1_add;\n        c->idct      = ff_j_rev_dct1;\n        c->perm_type = FF_IDCT_PERM_NONE;\n    } else {\n        if (avctx->bits_per_raw_sample == 10 || avctx->bits_per_raw_sample == 9) {\n            /* 10-bit MPEG-4 Simple Studio Profile requires a higher precision IDCT\n               However, it only uses idct_put */\n            if (c->mpeg4_studio_profile)\n                c->idct_put              = ff_simple_idct_put_int32_10bit;\n            else {\n                c->idct_put              = ff_simple_idct_put_int16_10bit;\n                c->idct_add              = ff_simple_idct_add_int16_10bit;\n                c->idct                  = ff_simple_idct_int16_10bit;\n            }\n            c->perm_type             = FF_IDCT_PERM_NONE;\n        } else if (avctx->bits_per_raw_sample == 12) {\n            c->idct_put              = ff_simple_idct_put_int16_12bit;\n            c->idct_add              = ff_simple_idct_add_int16_12bit;\n            c->idct                  = ff_simple_idct_int16_12bit;\n            c->perm_type             = FF_IDCT_PERM_NONE;\n        } else {\n            if (avctx->idct_algo == FF_IDCT_INT) {\n                c->idct_put  = ff_jref_idct_put;\n                c->idct_add  = ff_jref_idct_add;\n                c->idct      = ff_j_rev_dct;\n                c->perm_type = FF_IDCT_PERM_LIBMPEG2;\n#if CONFIG_FAANIDCT\n            } else if (avctx->idct_algo == FF_IDCT_FAAN) {\n                c->idct_put  = ff_faanidct_put;\n                c->idct_add  = ff_faanidct_add;\n                c->idct      = ff_faanidct;\n                c->perm_type = FF_IDCT_PERM_NONE;\n#endif /* CONFIG_FAANIDCT */\n            } else { // accurate/default\n                /* Be sure FF_IDCT_NONE will select this one, since it uses FF_IDCT_PERM_NONE */\n                c->idct_put  = ff_simple_idct_put_int16_8bit;\n                c->idct_add  = ff_simple_idct_add_int16_8bit;\n                c->idct      = ff_simple_idct_int16_8bit;\n                c->perm_type = FF_IDCT_PERM_NONE;\n            }\n        }\n    }\n\n    c->put_pixels_clamped        = ff_put_pixels_clamped_c;\n    c->put_signed_pixels_clamped = put_signed_pixels_clamped_c;\n    c->add_pixels_clamped        = ff_add_pixels_clamped_c;\n\n    if (CONFIG_MPEG4_DECODER && avctx->idct_algo == FF_IDCT_XVID)\n        ff_xvid_idct_init(c, avctx);\n\n    if (ARCH_AARCH64)\n        ff_idctdsp_init_aarch64(c, avctx, high_bit_depth);\n    if (ARCH_ALPHA)\n        ff_idctdsp_init_alpha(c, avctx, high_bit_depth);\n    if (ARCH_ARM)\n        ff_idctdsp_init_arm(c, avctx, high_bit_depth);\n    if (ARCH_PPC)\n        ff_idctdsp_init_ppc(c, avctx, high_bit_depth);\n    if (ARCH_X86)\n        ff_idctdsp_init_x86(c, avctx, high_bit_depth);\n    if (ARCH_MIPS)\n        ff_idctdsp_init_mips(c, avctx, high_bit_depth);\n\n    ff_init_scantable_permutation(c->idct_permutation,\n                                  c->perm_type);\n}\n", "/*\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#ifndef AVCODEC_IDCTDSP_H\n#define AVCODEC_IDCTDSP_H\n\n#include <stdint.h>\n\n#include \"config.h\"\n\n#include \"avcodec.h\"\n\n/**\n * Scantable.\n */\ntypedef struct ScanTable {\n    const uint8_t *scantable;\n    uint8_t permutated[64];\n    uint8_t raster_end[64];\n} ScanTable;\n\nenum idct_permutation_type {\n    FF_IDCT_PERM_NONE,\n    FF_IDCT_PERM_LIBMPEG2,\n    FF_IDCT_PERM_SIMPLE,\n    FF_IDCT_PERM_TRANSPOSE,\n    FF_IDCT_PERM_PARTTRANS,\n    FF_IDCT_PERM_SSE2,\n};\n\nvoid ff_init_scantable(uint8_t *permutation, ScanTable *st,\n                       const uint8_t *src_scantable);\nvoid ff_init_scantable_permutation(uint8_t *idct_permutation,\n                                   enum idct_permutation_type perm_type);\nint ff_init_scantable_permutation_x86(uint8_t *idct_permutation,\n                                      enum idct_permutation_type perm_type);\n\ntypedef struct IDCTDSPContext {\n    /* pixel ops : interface with DCT */\n    void (*put_pixels_clamped)(const int16_t *block /* align 16 */,\n                               uint8_t *av_restrict pixels /* align 8 */,\n                               ptrdiff_t line_size);\n    void (*put_signed_pixels_clamped)(const int16_t *block /* align 16 */,\n                                      uint8_t *av_restrict pixels /* align 8 */,\n                                      ptrdiff_t line_size);\n    void (*add_pixels_clamped)(const int16_t *block /* align 16 */,\n                               uint8_t *av_restrict pixels /* align 8 */,\n                               ptrdiff_t line_size);\n\n    void (*idct)(int16_t *block /* align 16 */);\n\n    /**\n     * block -> idct -> clip to unsigned 8 bit -> dest.\n     * (-1392, 0, 0, ...) -> idct -> (-174, -174, ...) -> put -> (0, 0, ...)\n     * @param line_size size in bytes of a horizontal line of dest\n     */\n    void (*idct_put)(uint8_t *dest /* align 8 */,\n                     ptrdiff_t line_size, int16_t *block /* align 16 */);\n\n    /**\n     * block -> idct -> add dest -> clip to unsigned 8 bit -> dest.\n     * @param line_size size in bytes of a horizontal line of dest\n     */\n    void (*idct_add)(uint8_t *dest /* align 8 */,\n                     ptrdiff_t line_size, int16_t *block /* align 16 */);\n\n    /**\n     * IDCT input permutation.\n     * Several optimized IDCTs need a permutated input (relative to the\n     * normal order of the reference IDCT).\n     * This permutation must be performed before the idct_put/add.\n     * Note, normally this can be merged with the zigzag/alternate scan<br>\n     * An example to avoid confusion:\n     * - (->decode coeffs -> zigzag reorder -> dequant -> reference IDCT -> ...)\n     * - (x -> reference DCT -> reference IDCT -> x)\n     * - (x -> reference DCT -> simple_mmx_perm = idct_permutation\n     *    -> simple_idct_mmx -> x)\n     * - (-> decode coeffs -> zigzag reorder -> simple_mmx_perm -> dequant\n     *    -> simple_idct_mmx -> ...)\n     */\n    uint8_t idct_permutation[64];\n    enum idct_permutation_type perm_type;\n\n    int mpeg4_studio_profile;\n} IDCTDSPContext;\n\nvoid ff_put_pixels_clamped_c(const int16_t *block, uint8_t *av_restrict pixels,\n                             ptrdiff_t line_size);\nvoid ff_add_pixels_clamped_c(const int16_t *block, uint8_t *av_restrict pixels,\n                             ptrdiff_t line_size);\n\nvoid ff_idctdsp_init(IDCTDSPContext *c, AVCodecContext *avctx);\n\nvoid ff_idctdsp_init_aarch64(IDCTDSPContext *c, AVCodecContext *avctx,\n                             unsigned high_bit_depth);\nvoid ff_idctdsp_init_alpha(IDCTDSPContext *c, AVCodecContext *avctx,\n                           unsigned high_bit_depth);\nvoid ff_idctdsp_init_arm(IDCTDSPContext *c, AVCodecContext *avctx,\n                         unsigned high_bit_depth);\nvoid ff_idctdsp_init_ppc(IDCTDSPContext *c, AVCodecContext *avctx,\n                         unsigned high_bit_depth);\nvoid ff_idctdsp_init_x86(IDCTDSPContext *c, AVCodecContext *avctx,\n                         unsigned high_bit_depth);\nvoid ff_idctdsp_init_mips(IDCTDSPContext *c, AVCodecContext *avctx,\n                          unsigned high_bit_depth);\n\n#endif /* AVCODEC_IDCTDSP_H */\n", "/*\n * The simplest mpeg encoder (well, it was the simplest!)\n * Copyright (c) 2000,2001 Fabrice Bellard\n * Copyright (c) 2002-2004 Michael Niedermayer <michaelni@gmx.at>\n *\n * 4MV & hq & B-frame encoding stuff by Michael Niedermayer <michaelni@gmx.at>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * The simplest mpeg encoder (well, it was the simplest!).\n */\n\n#include \"libavutil/attributes.h\"\n#include \"libavutil/avassert.h\"\n#include \"libavutil/imgutils.h\"\n#include \"libavutil/internal.h\"\n#include \"libavutil/motion_vector.h\"\n#include \"libavutil/timer.h\"\n#include \"avcodec.h\"\n#include \"blockdsp.h\"\n#include \"h264chroma.h\"\n#include \"idctdsp.h\"\n#include \"internal.h\"\n#include \"mathops.h\"\n#include \"mpeg_er.h\"\n#include \"mpegutils.h\"\n#include \"mpegvideo.h\"\n#include \"mpegvideodata.h\"\n#include \"mjpegenc.h\"\n#include \"msmpeg4.h\"\n#include \"qpeldsp.h\"\n#include \"thread.h\"\n#include \"wmv2.h\"\n#include <limits.h>\n\nstatic void dct_unquantize_mpeg1_intra_c(MpegEncContext *s,\n                                   int16_t *block, int n, int qscale)\n{\n    int i, level, nCoeffs;\n    const uint16_t *quant_matrix;\n\n    nCoeffs= s->block_last_index[n];\n\n    block[0] *= n < 4 ? s->y_dc_scale : s->c_dc_scale;\n    /* XXX: only MPEG-1 */\n    quant_matrix = s->intra_matrix;\n    for(i=1;i<=nCoeffs;i++) {\n        int j= s->intra_scantable.permutated[i];\n        level = block[j];\n        if (level) {\n            if (level < 0) {\n                level = -level;\n                level = (int)(level * qscale * quant_matrix[j]) >> 3;\n                level = (level - 1) | 1;\n                level = -level;\n            } else {\n                level = (int)(level * qscale * quant_matrix[j]) >> 3;\n                level = (level - 1) | 1;\n            }\n            block[j] = level;\n        }\n    }\n}\n\nstatic void dct_unquantize_mpeg1_inter_c(MpegEncContext *s,\n                                   int16_t *block, int n, int qscale)\n{\n    int i, level, nCoeffs;\n    const uint16_t *quant_matrix;\n\n    nCoeffs= s->block_last_index[n];\n\n    quant_matrix = s->inter_matrix;\n    for(i=0; i<=nCoeffs; i++) {\n        int j= s->intra_scantable.permutated[i];\n        level = block[j];\n        if (level) {\n            if (level < 0) {\n                level = -level;\n                level = (((level << 1) + 1) * qscale *\n                         ((int) (quant_matrix[j]))) >> 4;\n                level = (level - 1) | 1;\n                level = -level;\n            } else {\n                level = (((level << 1) + 1) * qscale *\n                         ((int) (quant_matrix[j]))) >> 4;\n                level = (level - 1) | 1;\n            }\n            block[j] = level;\n        }\n    }\n}\n\nstatic void dct_unquantize_mpeg2_intra_c(MpegEncContext *s,\n                                   int16_t *block, int n, int qscale)\n{\n    int i, level, nCoeffs;\n    const uint16_t *quant_matrix;\n\n    if (s->q_scale_type) qscale = ff_mpeg2_non_linear_qscale[qscale];\n    else                 qscale <<= 1;\n\n    if(s->alternate_scan) nCoeffs= 63;\n    else nCoeffs= s->block_last_index[n];\n\n    block[0] *= n < 4 ? s->y_dc_scale : s->c_dc_scale;\n    quant_matrix = s->intra_matrix;\n    for(i=1;i<=nCoeffs;i++) {\n        int j= s->intra_scantable.permutated[i];\n        level = block[j];\n        if (level) {\n            if (level < 0) {\n                level = -level;\n                level = (int)(level * qscale * quant_matrix[j]) >> 4;\n                level = -level;\n            } else {\n                level = (int)(level * qscale * quant_matrix[j]) >> 4;\n            }\n            block[j] = level;\n        }\n    }\n}\n\nstatic void dct_unquantize_mpeg2_intra_bitexact(MpegEncContext *s,\n                                   int16_t *block, int n, int qscale)\n{\n    int i, level, nCoeffs;\n    const uint16_t *quant_matrix;\n    int sum=-1;\n\n    if (s->q_scale_type) qscale = ff_mpeg2_non_linear_qscale[qscale];\n    else                 qscale <<= 1;\n\n    if(s->alternate_scan) nCoeffs= 63;\n    else nCoeffs= s->block_last_index[n];\n\n    block[0] *= n < 4 ? s->y_dc_scale : s->c_dc_scale;\n    sum += block[0];\n    quant_matrix = s->intra_matrix;\n    for(i=1;i<=nCoeffs;i++) {\n        int j= s->intra_scantable.permutated[i];\n        level = block[j];\n        if (level) {\n            if (level < 0) {\n                level = -level;\n                level = (int)(level * qscale * quant_matrix[j]) >> 4;\n                level = -level;\n            } else {\n                level = (int)(level * qscale * quant_matrix[j]) >> 4;\n            }\n            block[j] = level;\n            sum+=level;\n        }\n    }\n    block[63]^=sum&1;\n}\n\nstatic void dct_unquantize_mpeg2_inter_c(MpegEncContext *s,\n                                   int16_t *block, int n, int qscale)\n{\n    int i, level, nCoeffs;\n    const uint16_t *quant_matrix;\n    int sum=-1;\n\n    if (s->q_scale_type) qscale = ff_mpeg2_non_linear_qscale[qscale];\n    else                 qscale <<= 1;\n\n    if(s->alternate_scan) nCoeffs= 63;\n    else nCoeffs= s->block_last_index[n];\n\n    quant_matrix = s->inter_matrix;\n    for(i=0; i<=nCoeffs; i++) {\n        int j= s->intra_scantable.permutated[i];\n        level = block[j];\n        if (level) {\n            if (level < 0) {\n                level = -level;\n                level = (((level << 1) + 1) * qscale *\n                         ((int) (quant_matrix[j]))) >> 5;\n                level = -level;\n            } else {\n                level = (((level << 1) + 1) * qscale *\n                         ((int) (quant_matrix[j]))) >> 5;\n            }\n            block[j] = level;\n            sum+=level;\n        }\n    }\n    block[63]^=sum&1;\n}\n\nstatic void dct_unquantize_h263_intra_c(MpegEncContext *s,\n                                  int16_t *block, int n, int qscale)\n{\n    int i, level, qmul, qadd;\n    int nCoeffs;\n\n    av_assert2(s->block_last_index[n]>=0 || s->h263_aic);\n\n    qmul = qscale << 1;\n\n    if (!s->h263_aic) {\n        block[0] *= n < 4 ? s->y_dc_scale : s->c_dc_scale;\n        qadd = (qscale - 1) | 1;\n    }else{\n        qadd = 0;\n    }\n    if(s->ac_pred)\n        nCoeffs=63;\n    else\n        nCoeffs= s->intra_scantable.raster_end[ s->block_last_index[n] ];\n\n    for(i=1; i<=nCoeffs; i++) {\n        level = block[i];\n        if (level) {\n            if (level < 0) {\n                level = level * qmul - qadd;\n            } else {\n                level = level * qmul + qadd;\n            }\n            block[i] = level;\n        }\n    }\n}\n\nstatic void dct_unquantize_h263_inter_c(MpegEncContext *s,\n                                  int16_t *block, int n, int qscale)\n{\n    int i, level, qmul, qadd;\n    int nCoeffs;\n\n    av_assert2(s->block_last_index[n]>=0);\n\n    qadd = (qscale - 1) | 1;\n    qmul = qscale << 1;\n\n    nCoeffs= s->inter_scantable.raster_end[ s->block_last_index[n] ];\n\n    for(i=0; i<=nCoeffs; i++) {\n        level = block[i];\n        if (level) {\n            if (level < 0) {\n                level = level * qmul - qadd;\n            } else {\n                level = level * qmul + qadd;\n            }\n            block[i] = level;\n        }\n    }\n}\n\n\nstatic void gray16(uint8_t *dst, const uint8_t *src, ptrdiff_t linesize, int h)\n{\n    while(h--)\n        memset(dst + h*linesize, 128, 16);\n}\n\nstatic void gray8(uint8_t *dst, const uint8_t *src, ptrdiff_t linesize, int h)\n{\n    while(h--)\n        memset(dst + h*linesize, 128, 8);\n}\n\n/* init common dct for both encoder and decoder */\nstatic av_cold int dct_init(MpegEncContext *s)\n{\n    ff_blockdsp_init(&s->bdsp, s->avctx);\n    ff_h264chroma_init(&s->h264chroma, 8); //for lowres\n    ff_hpeldsp_init(&s->hdsp, s->avctx->flags);\n    ff_mpegvideodsp_init(&s->mdsp);\n    ff_videodsp_init(&s->vdsp, s->avctx->bits_per_raw_sample);\n\n    if (s->avctx->debug & FF_DEBUG_NOMC) {\n        int i;\n        for (i=0; i<4; i++) {\n            s->hdsp.avg_pixels_tab[0][i] = gray16;\n            s->hdsp.put_pixels_tab[0][i] = gray16;\n            s->hdsp.put_no_rnd_pixels_tab[0][i] = gray16;\n\n            s->hdsp.avg_pixels_tab[1][i] = gray8;\n            s->hdsp.put_pixels_tab[1][i] = gray8;\n            s->hdsp.put_no_rnd_pixels_tab[1][i] = gray8;\n        }\n    }\n\n    s->dct_unquantize_h263_intra = dct_unquantize_h263_intra_c;\n    s->dct_unquantize_h263_inter = dct_unquantize_h263_inter_c;\n    s->dct_unquantize_mpeg1_intra = dct_unquantize_mpeg1_intra_c;\n    s->dct_unquantize_mpeg1_inter = dct_unquantize_mpeg1_inter_c;\n    s->dct_unquantize_mpeg2_intra = dct_unquantize_mpeg2_intra_c;\n    if (s->avctx->flags & AV_CODEC_FLAG_BITEXACT)\n        s->dct_unquantize_mpeg2_intra = dct_unquantize_mpeg2_intra_bitexact;\n    s->dct_unquantize_mpeg2_inter = dct_unquantize_mpeg2_inter_c;\n\n    if (HAVE_INTRINSICS_NEON)\n        ff_mpv_common_init_neon(s);\n\n    if (ARCH_ALPHA)\n        ff_mpv_common_init_axp(s);\n    if (ARCH_ARM)\n        ff_mpv_common_init_arm(s);\n    if (ARCH_PPC)\n        ff_mpv_common_init_ppc(s);\n    if (ARCH_X86)\n        ff_mpv_common_init_x86(s);\n    if (ARCH_MIPS)\n        ff_mpv_common_init_mips(s);\n\n    return 0;\n}\n\nav_cold void ff_mpv_idct_init(MpegEncContext *s)\n{\n    if (s->codec_id == AV_CODEC_ID_MPEG4)\n        s->idsp.mpeg4_studio_profile = s->studio_profile;\n    ff_idctdsp_init(&s->idsp, s->avctx);\n\n    /* load & permutate scantables\n     * note: only wmv uses different ones\n     */\n    if (s->alternate_scan) {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_alternate_vertical_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_alternate_vertical_scan);\n    } else {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_zigzag_direct);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_zigzag_direct);\n    }\n    ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_horizontal_scan);\n    ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);\n}\n\nstatic int alloc_picture(MpegEncContext *s, Picture *pic, int shared)\n{\n    return ff_alloc_picture(s->avctx, pic, &s->me, &s->sc, shared, 0,\n                            s->chroma_x_shift, s->chroma_y_shift, s->out_format,\n                            s->mb_stride, s->mb_width, s->mb_height, s->b8_stride,\n                            &s->linesize, &s->uvlinesize);\n}\n\nstatic int init_duplicate_context(MpegEncContext *s)\n{\n    int y_size = s->b8_stride * (2 * s->mb_height + 1);\n    int c_size = s->mb_stride * (s->mb_height + 1);\n    int yc_size = y_size + 2 * c_size;\n    int i;\n\n    if (s->mb_height & 1)\n        yc_size += 2*s->b8_stride + 2*s->mb_stride;\n\n    s->sc.edge_emu_buffer =\n    s->me.scratchpad   =\n    s->me.temp         =\n    s->sc.rd_scratchpad   =\n    s->sc.b_scratchpad    =\n    s->sc.obmc_scratchpad = NULL;\n\n    if (s->encoding) {\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->me.map,\n                          ME_MAP_SIZE * sizeof(uint32_t), fail)\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->me.score_map,\n                          ME_MAP_SIZE * sizeof(uint32_t), fail)\n        if (s->noise_reduction) {\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->dct_error_sum,\n                              2 * 64 * sizeof(int), fail)\n        }\n    }\n    FF_ALLOCZ_OR_GOTO(s->avctx, s->blocks, 64 * 12 * 2 * sizeof(int16_t), fail)\n    s->block = s->blocks[0];\n\n    for (i = 0; i < 12; i++) {\n        s->pblocks[i] = &s->block[i];\n    }\n\n    FF_ALLOCZ_OR_GOTO(s->avctx, s->block32, sizeof(*s->block32), fail)\n\n    if (s->avctx->codec_tag == AV_RL32(\"VCR2\")) {\n        // exchange uv\n        FFSWAP(void *, s->pblocks[4], s->pblocks[5]);\n    }\n\n    if (s->out_format == FMT_H263) {\n        /* ac values */\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->ac_val_base,\n                          yc_size * sizeof(int16_t) * 16, fail);\n        s->ac_val[0] = s->ac_val_base + s->b8_stride + 1;\n        s->ac_val[1] = s->ac_val_base + y_size + s->mb_stride + 1;\n        s->ac_val[2] = s->ac_val[1] + c_size;\n    }\n\n    return 0;\nfail:\n    return -1; // free() through ff_mpv_common_end()\n}\n\nstatic void free_duplicate_context(MpegEncContext *s)\n{\n    if (!s)\n        return;\n\n    av_freep(&s->sc.edge_emu_buffer);\n    av_freep(&s->me.scratchpad);\n    s->me.temp =\n    s->sc.rd_scratchpad =\n    s->sc.b_scratchpad =\n    s->sc.obmc_scratchpad = NULL;\n\n    av_freep(&s->dct_error_sum);\n    av_freep(&s->me.map);\n    av_freep(&s->me.score_map);\n    av_freep(&s->blocks);\n    av_freep(&s->block32);\n    av_freep(&s->ac_val_base);\n    s->block = NULL;\n}\n\nstatic void backup_duplicate_context(MpegEncContext *bak, MpegEncContext *src)\n{\n#define COPY(a) bak->a = src->a\n    COPY(sc.edge_emu_buffer);\n    COPY(me.scratchpad);\n    COPY(me.temp);\n    COPY(sc.rd_scratchpad);\n    COPY(sc.b_scratchpad);\n    COPY(sc.obmc_scratchpad);\n    COPY(me.map);\n    COPY(me.score_map);\n    COPY(blocks);\n    COPY(block);\n    COPY(block32);\n    COPY(start_mb_y);\n    COPY(end_mb_y);\n    COPY(me.map_generation);\n    COPY(pb);\n    COPY(dct_error_sum);\n    COPY(dct_count[0]);\n    COPY(dct_count[1]);\n    COPY(ac_val_base);\n    COPY(ac_val[0]);\n    COPY(ac_val[1]);\n    COPY(ac_val[2]);\n#undef COPY\n}\n\nint ff_update_duplicate_context(MpegEncContext *dst, MpegEncContext *src)\n{\n    MpegEncContext bak;\n    int i, ret;\n    // FIXME copy only needed parts\n    // START_TIMER\n    backup_duplicate_context(&bak, dst);\n    memcpy(dst, src, sizeof(MpegEncContext));\n    backup_duplicate_context(dst, &bak);\n    for (i = 0; i < 12; i++) {\n        dst->pblocks[i] = &dst->block[i];\n    }\n    if (dst->avctx->codec_tag == AV_RL32(\"VCR2\")) {\n        // exchange uv\n        FFSWAP(void *, dst->pblocks[4], dst->pblocks[5]);\n    }\n    if (!dst->sc.edge_emu_buffer &&\n        (ret = ff_mpeg_framesize_alloc(dst->avctx, &dst->me,\n                                       &dst->sc, dst->linesize)) < 0) {\n        av_log(dst->avctx, AV_LOG_ERROR, \"failed to allocate context \"\n               \"scratch buffers.\\n\");\n        return ret;\n    }\n    // STOP_TIMER(\"update_duplicate_context\")\n    // about 10k cycles / 0.01 sec for  1000frames on 1ghz with 2 threads\n    return 0;\n}\n\nint ff_mpeg_update_thread_context(AVCodecContext *dst,\n                                  const AVCodecContext *src)\n{\n    int i, ret;\n    MpegEncContext *s = dst->priv_data, *s1 = src->priv_data;\n\n    if (dst == src)\n        return 0;\n\n    av_assert0(s != s1);\n\n    // FIXME can parameters change on I-frames?\n    // in that case dst may need a reinit\n    if (!s->context_initialized) {\n        int err;\n        memcpy(s, s1, sizeof(MpegEncContext));\n\n        s->avctx                 = dst;\n        s->bitstream_buffer      = NULL;\n        s->bitstream_buffer_size = s->allocated_bitstream_buffer_size = 0;\n\n        if (s1->context_initialized){\n//             s->picture_range_start  += MAX_PICTURE_COUNT;\n//             s->picture_range_end    += MAX_PICTURE_COUNT;\n            ff_mpv_idct_init(s);\n            if((err = ff_mpv_common_init(s)) < 0){\n                memset(s, 0, sizeof(MpegEncContext));\n                s->avctx = dst;\n                return err;\n            }\n        }\n    }\n\n    if (s->height != s1->height || s->width != s1->width || s->context_reinit) {\n        s->context_reinit = 0;\n        s->height = s1->height;\n        s->width  = s1->width;\n        if ((ret = ff_mpv_common_frame_size_change(s)) < 0)\n            return ret;\n    }\n\n    s->avctx->coded_height  = s1->avctx->coded_height;\n    s->avctx->coded_width   = s1->avctx->coded_width;\n    s->avctx->width         = s1->avctx->width;\n    s->avctx->height        = s1->avctx->height;\n\n    s->coded_picture_number = s1->coded_picture_number;\n    s->picture_number       = s1->picture_number;\n\n    av_assert0(!s->picture || s->picture != s1->picture);\n    if(s->picture)\n    for (i = 0; i < MAX_PICTURE_COUNT; i++) {\n        ff_mpeg_unref_picture(s->avctx, &s->picture[i]);\n        if (s1->picture && s1->picture[i].f->buf[0] &&\n            (ret = ff_mpeg_ref_picture(s->avctx, &s->picture[i], &s1->picture[i])) < 0)\n            return ret;\n    }\n\n#define UPDATE_PICTURE(pic)\\\ndo {\\\n    ff_mpeg_unref_picture(s->avctx, &s->pic);\\\n    if (s1->pic.f && s1->pic.f->buf[0])\\\n        ret = ff_mpeg_ref_picture(s->avctx, &s->pic, &s1->pic);\\\n    else\\\n        ret = ff_update_picture_tables(&s->pic, &s1->pic);\\\n    if (ret < 0)\\\n        return ret;\\\n} while (0)\n\n    UPDATE_PICTURE(current_picture);\n    UPDATE_PICTURE(last_picture);\n    UPDATE_PICTURE(next_picture);\n\n#define REBASE_PICTURE(pic, new_ctx, old_ctx)                                 \\\n    ((pic && pic >= old_ctx->picture &&                                       \\\n      pic < old_ctx->picture + MAX_PICTURE_COUNT) ?                           \\\n        &new_ctx->picture[pic - old_ctx->picture] : NULL)\n\n    s->last_picture_ptr    = REBASE_PICTURE(s1->last_picture_ptr,    s, s1);\n    s->current_picture_ptr = REBASE_PICTURE(s1->current_picture_ptr, s, s1);\n    s->next_picture_ptr    = REBASE_PICTURE(s1->next_picture_ptr,    s, s1);\n\n    // Error/bug resilience\n    s->next_p_frame_damaged = s1->next_p_frame_damaged;\n    s->workaround_bugs      = s1->workaround_bugs;\n    s->padding_bug_score    = s1->padding_bug_score;\n\n    // MPEG-4 timing info\n    memcpy(&s->last_time_base, &s1->last_time_base,\n           (char *) &s1->pb_field_time + sizeof(s1->pb_field_time) -\n           (char *) &s1->last_time_base);\n\n    // B-frame info\n    s->max_b_frames = s1->max_b_frames;\n    s->low_delay    = s1->low_delay;\n    s->droppable    = s1->droppable;\n\n    // DivX handling (doesn't work)\n    s->divx_packed  = s1->divx_packed;\n\n    if (s1->bitstream_buffer) {\n        if (s1->bitstream_buffer_size +\n            AV_INPUT_BUFFER_PADDING_SIZE > s->allocated_bitstream_buffer_size) {\n            av_fast_malloc(&s->bitstream_buffer,\n                           &s->allocated_bitstream_buffer_size,\n                           s1->allocated_bitstream_buffer_size);\n            if (!s->bitstream_buffer) {\n                s->bitstream_buffer_size = 0;\n                return AVERROR(ENOMEM);\n            }\n        }\n        s->bitstream_buffer_size = s1->bitstream_buffer_size;\n        memcpy(s->bitstream_buffer, s1->bitstream_buffer,\n               s1->bitstream_buffer_size);\n        memset(s->bitstream_buffer + s->bitstream_buffer_size, 0,\n               AV_INPUT_BUFFER_PADDING_SIZE);\n    }\n\n    // linesize-dependent scratch buffer allocation\n    if (!s->sc.edge_emu_buffer)\n        if (s1->linesize) {\n            if (ff_mpeg_framesize_alloc(s->avctx, &s->me,\n                                        &s->sc, s1->linesize) < 0) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Failed to allocate context \"\n                       \"scratch buffers.\\n\");\n                return AVERROR(ENOMEM);\n            }\n        } else {\n            av_log(s->avctx, AV_LOG_ERROR, \"Context scratch buffers could not \"\n                   \"be allocated due to unknown size.\\n\");\n        }\n\n    // MPEG-2/interlacing info\n    memcpy(&s->progressive_sequence, &s1->progressive_sequence,\n           (char *) &s1->rtp_mode - (char *) &s1->progressive_sequence);\n\n    if (!s1->first_field) {\n        s->last_pict_type = s1->pict_type;\n        if (s1->current_picture_ptr)\n            s->last_lambda_for[s1->pict_type] = s1->current_picture_ptr->f->quality;\n    }\n\n    return 0;\n}\n\n/**\n * Set the given MpegEncContext to common defaults\n * (same for encoding and decoding).\n * The changed fields will not depend upon the\n * prior state of the MpegEncContext.\n */\nvoid ff_mpv_common_defaults(MpegEncContext *s)\n{\n    s->y_dc_scale_table      =\n    s->c_dc_scale_table      = ff_mpeg1_dc_scale_table;\n    s->chroma_qscale_table   = ff_default_chroma_qscale_table;\n    s->progressive_frame     = 1;\n    s->progressive_sequence  = 1;\n    s->picture_structure     = PICT_FRAME;\n\n    s->coded_picture_number  = 0;\n    s->picture_number        = 0;\n\n    s->f_code                = 1;\n    s->b_code                = 1;\n\n    s->slice_context_count   = 1;\n}\n\n/**\n * Set the given MpegEncContext to defaults for decoding.\n * the changed fields will not depend upon\n * the prior state of the MpegEncContext.\n */\nvoid ff_mpv_decode_defaults(MpegEncContext *s)\n{\n    ff_mpv_common_defaults(s);\n}\n\nvoid ff_mpv_decode_init(MpegEncContext *s, AVCodecContext *avctx)\n{\n    s->avctx           = avctx;\n    s->width           = avctx->coded_width;\n    s->height          = avctx->coded_height;\n    s->codec_id        = avctx->codec->id;\n    s->workaround_bugs = avctx->workaround_bugs;\n\n    /* convert fourcc to upper case */\n    s->codec_tag          = avpriv_toupper4(avctx->codec_tag);\n}\n\n/**\n * Initialize and allocates MpegEncContext fields dependent on the resolution.\n */\nstatic int init_context_frame(MpegEncContext *s)\n{\n    int y_size, c_size, yc_size, i, mb_array_size, mv_table_size, x, y;\n\n    s->mb_width   = (s->width + 15) / 16;\n    s->mb_stride  = s->mb_width + 1;\n    s->b8_stride  = s->mb_width * 2 + 1;\n    mb_array_size = s->mb_height * s->mb_stride;\n    mv_table_size = (s->mb_height + 2) * s->mb_stride + 1;\n\n    /* set default edge pos, will be overridden\n     * in decode_header if needed */\n    s->h_edge_pos = s->mb_width * 16;\n    s->v_edge_pos = s->mb_height * 16;\n\n    s->mb_num     = s->mb_width * s->mb_height;\n\n    s->block_wrap[0] =\n    s->block_wrap[1] =\n    s->block_wrap[2] =\n    s->block_wrap[3] = s->b8_stride;\n    s->block_wrap[4] =\n    s->block_wrap[5] = s->mb_stride;\n\n    y_size  = s->b8_stride * (2 * s->mb_height + 1);\n    c_size  = s->mb_stride * (s->mb_height + 1);\n    yc_size = y_size + 2   * c_size;\n\n    if (s->mb_height & 1)\n        yc_size += 2*s->b8_stride + 2*s->mb_stride;\n\n    FF_ALLOCZ_OR_GOTO(s->avctx, s->mb_index2xy, (s->mb_num + 1) * sizeof(int),\n                      fail); // error resilience code looks cleaner with this\n    for (y = 0; y < s->mb_height; y++)\n        for (x = 0; x < s->mb_width; x++)\n            s->mb_index2xy[x + y * s->mb_width] = x + y * s->mb_stride;\n\n    s->mb_index2xy[s->mb_height * s->mb_width] = (s->mb_height - 1) * s->mb_stride + s->mb_width; // FIXME really needed?\n\n    if (s->encoding) {\n        /* Allocate MV tables */\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->p_mv_table_base,                 mv_table_size * 2 * sizeof(int16_t), fail)\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->b_forw_mv_table_base,            mv_table_size * 2 * sizeof(int16_t), fail)\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->b_back_mv_table_base,            mv_table_size * 2 * sizeof(int16_t), fail)\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->b_bidir_forw_mv_table_base,      mv_table_size * 2 * sizeof(int16_t), fail)\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->b_bidir_back_mv_table_base,      mv_table_size * 2 * sizeof(int16_t), fail)\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->b_direct_mv_table_base,          mv_table_size * 2 * sizeof(int16_t), fail)\n        s->p_mv_table            = s->p_mv_table_base + s->mb_stride + 1;\n        s->b_forw_mv_table       = s->b_forw_mv_table_base + s->mb_stride + 1;\n        s->b_back_mv_table       = s->b_back_mv_table_base + s->mb_stride + 1;\n        s->b_bidir_forw_mv_table = s->b_bidir_forw_mv_table_base + s->mb_stride + 1;\n        s->b_bidir_back_mv_table = s->b_bidir_back_mv_table_base + s->mb_stride + 1;\n        s->b_direct_mv_table     = s->b_direct_mv_table_base + s->mb_stride + 1;\n\n        /* Allocate MB type table */\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->mb_type, mb_array_size * sizeof(uint16_t), fail) // needed for encoding\n\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->lambda_table, mb_array_size * sizeof(int), fail)\n\n        FF_ALLOC_OR_GOTO(s->avctx, s->cplx_tab,\n                         mb_array_size * sizeof(float), fail);\n        FF_ALLOC_OR_GOTO(s->avctx, s->bits_tab,\n                         mb_array_size * sizeof(float), fail);\n\n    }\n\n    if (s->codec_id == AV_CODEC_ID_MPEG4 ||\n        (s->avctx->flags & AV_CODEC_FLAG_INTERLACED_ME)) {\n        /* interlaced direct mode decoding tables */\n        for (i = 0; i < 2; i++) {\n            int j, k;\n            for (j = 0; j < 2; j++) {\n                for (k = 0; k < 2; k++) {\n                    FF_ALLOCZ_OR_GOTO(s->avctx,\n                                      s->b_field_mv_table_base[i][j][k],\n                                      mv_table_size * 2 * sizeof(int16_t),\n                                      fail);\n                    s->b_field_mv_table[i][j][k] = s->b_field_mv_table_base[i][j][k] +\n                                                   s->mb_stride + 1;\n                }\n                FF_ALLOCZ_OR_GOTO(s->avctx, s->b_field_select_table [i][j], mb_array_size * 2 * sizeof(uint8_t), fail)\n                FF_ALLOCZ_OR_GOTO(s->avctx, s->p_field_mv_table_base[i][j], mv_table_size * 2 * sizeof(int16_t), fail)\n                s->p_field_mv_table[i][j] = s->p_field_mv_table_base[i][j] + s->mb_stride + 1;\n            }\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->p_field_select_table[i], mb_array_size * 2 * sizeof(uint8_t), fail)\n        }\n    }\n    if (s->out_format == FMT_H263) {\n        /* cbp values */\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->coded_block_base, y_size + (s->mb_height&1)*2*s->b8_stride, fail);\n        s->coded_block = s->coded_block_base + s->b8_stride + 1;\n\n        /* cbp, ac_pred, pred_dir */\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->cbp_table     , mb_array_size * sizeof(uint8_t), fail);\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->pred_dir_table, mb_array_size * sizeof(uint8_t), fail);\n    }\n\n    if (s->h263_pred || s->h263_plus || !s->encoding) {\n        /* dc values */\n        // MN: we need these for error resilience of intra-frames\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->dc_val_base, yc_size * sizeof(int16_t), fail);\n        s->dc_val[0] = s->dc_val_base + s->b8_stride + 1;\n        s->dc_val[1] = s->dc_val_base + y_size + s->mb_stride + 1;\n        s->dc_val[2] = s->dc_val[1] + c_size;\n        for (i = 0; i < yc_size; i++)\n            s->dc_val_base[i] = 1024;\n    }\n\n    /* which mb is an intra block */\n    FF_ALLOCZ_OR_GOTO(s->avctx, s->mbintra_table, mb_array_size, fail);\n    memset(s->mbintra_table, 1, mb_array_size);\n\n    /* init macroblock skip table */\n    FF_ALLOCZ_OR_GOTO(s->avctx, s->mbskip_table, mb_array_size + 2, fail);\n    // Note the + 1 is for a quicker MPEG-4 slice_end detection\n\n    return ff_mpeg_er_init(s);\nfail:\n    return AVERROR(ENOMEM);\n}\n\nstatic void clear_context(MpegEncContext *s)\n{\n    int i, j, k;\n\n    memset(&s->next_picture, 0, sizeof(s->next_picture));\n    memset(&s->last_picture, 0, sizeof(s->last_picture));\n    memset(&s->current_picture, 0, sizeof(s->current_picture));\n    memset(&s->new_picture, 0, sizeof(s->new_picture));\n\n    memset(s->thread_context, 0, sizeof(s->thread_context));\n\n    s->me.map = NULL;\n    s->me.score_map = NULL;\n    s->dct_error_sum = NULL;\n    s->block = NULL;\n    s->blocks = NULL;\n    s->block32 = NULL;\n    memset(s->pblocks, 0, sizeof(s->pblocks));\n    s->ac_val_base = NULL;\n    s->ac_val[0] =\n    s->ac_val[1] =\n    s->ac_val[2] =NULL;\n    s->sc.edge_emu_buffer = NULL;\n    s->me.scratchpad = NULL;\n    s->me.temp =\n    s->sc.rd_scratchpad =\n    s->sc.b_scratchpad =\n    s->sc.obmc_scratchpad = NULL;\n\n\n    s->bitstream_buffer = NULL;\n    s->allocated_bitstream_buffer_size = 0;\n    s->picture          = NULL;\n    s->mb_type          = NULL;\n    s->p_mv_table_base  = NULL;\n    s->b_forw_mv_table_base = NULL;\n    s->b_back_mv_table_base = NULL;\n    s->b_bidir_forw_mv_table_base = NULL;\n    s->b_bidir_back_mv_table_base = NULL;\n    s->b_direct_mv_table_base = NULL;\n    s->p_mv_table            = NULL;\n    s->b_forw_mv_table       = NULL;\n    s->b_back_mv_table       = NULL;\n    s->b_bidir_forw_mv_table = NULL;\n    s->b_bidir_back_mv_table = NULL;\n    s->b_direct_mv_table     = NULL;\n    for (i = 0; i < 2; i++) {\n        for (j = 0; j < 2; j++) {\n            for (k = 0; k < 2; k++) {\n                s->b_field_mv_table_base[i][j][k] = NULL;\n                s->b_field_mv_table[i][j][k] = NULL;\n            }\n            s->b_field_select_table[i][j] = NULL;\n            s->p_field_mv_table_base[i][j] = NULL;\n            s->p_field_mv_table[i][j] = NULL;\n        }\n        s->p_field_select_table[i] = NULL;\n    }\n\n    s->dc_val_base = NULL;\n    s->coded_block_base = NULL;\n    s->mbintra_table = NULL;\n    s->cbp_table = NULL;\n    s->pred_dir_table = NULL;\n\n    s->mbskip_table = NULL;\n\n    s->er.error_status_table = NULL;\n    s->er.er_temp_buffer = NULL;\n    s->mb_index2xy = NULL;\n    s->lambda_table = NULL;\n\n    s->cplx_tab = NULL;\n    s->bits_tab = NULL;\n}\n\n/**\n * init common structure for both encoder and decoder.\n * this assumes that some variables like width/height are already set\n */\nav_cold int ff_mpv_common_init(MpegEncContext *s)\n{\n    int i, ret;\n    int nb_slices = (HAVE_THREADS &&\n                     s->avctx->active_thread_type & FF_THREAD_SLICE) ?\n                    s->avctx->thread_count : 1;\n\n    clear_context(s);\n\n    if (s->encoding && s->avctx->slices)\n        nb_slices = s->avctx->slices;\n\n    if (s->codec_id == AV_CODEC_ID_MPEG2VIDEO && !s->progressive_sequence)\n        s->mb_height = (s->height + 31) / 32 * 2;\n    else\n        s->mb_height = (s->height + 15) / 16;\n\n    if (s->avctx->pix_fmt == AV_PIX_FMT_NONE) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"decoding to AV_PIX_FMT_NONE is not supported.\\n\");\n        return -1;\n    }\n\n    if (nb_slices > MAX_THREADS || (nb_slices > s->mb_height && s->mb_height)) {\n        int max_slices;\n        if (s->mb_height)\n            max_slices = FFMIN(MAX_THREADS, s->mb_height);\n        else\n            max_slices = MAX_THREADS;\n        av_log(s->avctx, AV_LOG_WARNING, \"too many threads/slices (%d),\"\n               \" reducing to %d\\n\", nb_slices, max_slices);\n        nb_slices = max_slices;\n    }\n\n    if ((s->width || s->height) &&\n        av_image_check_size(s->width, s->height, 0, s->avctx))\n        return -1;\n\n    dct_init(s);\n\n    /* set chroma shifts */\n    ret = av_pix_fmt_get_chroma_sub_sample(s->avctx->pix_fmt,\n                                           &s->chroma_x_shift,\n                                           &s->chroma_y_shift);\n    if (ret)\n        return ret;\n\n    FF_ALLOCZ_OR_GOTO(s->avctx, s->picture,\n                      MAX_PICTURE_COUNT * sizeof(Picture), fail);\n    for (i = 0; i < MAX_PICTURE_COUNT; i++) {\n        s->picture[i].f = av_frame_alloc();\n        if (!s->picture[i].f)\n            goto fail;\n    }\n    s->next_picture.f = av_frame_alloc();\n    if (!s->next_picture.f)\n        goto fail;\n    s->last_picture.f = av_frame_alloc();\n    if (!s->last_picture.f)\n        goto fail;\n    s->current_picture.f = av_frame_alloc();\n    if (!s->current_picture.f)\n        goto fail;\n    s->new_picture.f = av_frame_alloc();\n    if (!s->new_picture.f)\n        goto fail;\n\n    if (init_context_frame(s))\n        goto fail;\n\n    s->parse_context.state = -1;\n\n    s->context_initialized = 1;\n    memset(s->thread_context, 0, sizeof(s->thread_context));\n    s->thread_context[0]   = s;\n\n//     if (s->width && s->height) {\n    if (nb_slices > 1) {\n        for (i = 0; i < nb_slices; i++) {\n            if (i) {\n                s->thread_context[i] = av_memdup(s, sizeof(MpegEncContext));\n                if (!s->thread_context[i])\n                    goto fail;\n            }\n            if (init_duplicate_context(s->thread_context[i]) < 0)\n                goto fail;\n            s->thread_context[i]->start_mb_y =\n                (s->mb_height * (i) + nb_slices / 2) / nb_slices;\n            s->thread_context[i]->end_mb_y   =\n                (s->mb_height * (i + 1) + nb_slices / 2) / nb_slices;\n        }\n    } else {\n        if (init_duplicate_context(s) < 0)\n            goto fail;\n        s->start_mb_y = 0;\n        s->end_mb_y   = s->mb_height;\n    }\n    s->slice_context_count = nb_slices;\n//     }\n\n    return 0;\n fail:\n    ff_mpv_common_end(s);\n    return -1;\n}\n\n/**\n * Frees and resets MpegEncContext fields depending on the resolution.\n * Is used during resolution changes to avoid a full reinitialization of the\n * codec.\n */\nstatic void free_context_frame(MpegEncContext *s)\n{\n    int i, j, k;\n\n    av_freep(&s->mb_type);\n    av_freep(&s->p_mv_table_base);\n    av_freep(&s->b_forw_mv_table_base);\n    av_freep(&s->b_back_mv_table_base);\n    av_freep(&s->b_bidir_forw_mv_table_base);\n    av_freep(&s->b_bidir_back_mv_table_base);\n    av_freep(&s->b_direct_mv_table_base);\n    s->p_mv_table            = NULL;\n    s->b_forw_mv_table       = NULL;\n    s->b_back_mv_table       = NULL;\n    s->b_bidir_forw_mv_table = NULL;\n    s->b_bidir_back_mv_table = NULL;\n    s->b_direct_mv_table     = NULL;\n    for (i = 0; i < 2; i++) {\n        for (j = 0; j < 2; j++) {\n            for (k = 0; k < 2; k++) {\n                av_freep(&s->b_field_mv_table_base[i][j][k]);\n                s->b_field_mv_table[i][j][k] = NULL;\n            }\n            av_freep(&s->b_field_select_table[i][j]);\n            av_freep(&s->p_field_mv_table_base[i][j]);\n            s->p_field_mv_table[i][j] = NULL;\n        }\n        av_freep(&s->p_field_select_table[i]);\n    }\n\n    av_freep(&s->dc_val_base);\n    av_freep(&s->coded_block_base);\n    av_freep(&s->mbintra_table);\n    av_freep(&s->cbp_table);\n    av_freep(&s->pred_dir_table);\n\n    av_freep(&s->mbskip_table);\n\n    av_freep(&s->er.error_status_table);\n    av_freep(&s->er.er_temp_buffer);\n    av_freep(&s->mb_index2xy);\n    av_freep(&s->lambda_table);\n\n    av_freep(&s->cplx_tab);\n    av_freep(&s->bits_tab);\n\n    s->linesize = s->uvlinesize = 0;\n}\n\nint ff_mpv_common_frame_size_change(MpegEncContext *s)\n{\n    int i, err = 0;\n\n    if (!s->context_initialized)\n        return AVERROR(EINVAL);\n\n    if (s->slice_context_count > 1) {\n        for (i = 0; i < s->slice_context_count; i++) {\n            free_duplicate_context(s->thread_context[i]);\n        }\n        for (i = 1; i < s->slice_context_count; i++) {\n            av_freep(&s->thread_context[i]);\n        }\n    } else\n        free_duplicate_context(s);\n\n    free_context_frame(s);\n\n    if (s->picture)\n        for (i = 0; i < MAX_PICTURE_COUNT; i++) {\n                s->picture[i].needs_realloc = 1;\n        }\n\n    s->last_picture_ptr         =\n    s->next_picture_ptr         =\n    s->current_picture_ptr      = NULL;\n\n    // init\n    if (s->codec_id == AV_CODEC_ID_MPEG2VIDEO && !s->progressive_sequence)\n        s->mb_height = (s->height + 31) / 32 * 2;\n    else\n        s->mb_height = (s->height + 15) / 16;\n\n    if ((s->width || s->height) &&\n        (err = av_image_check_size(s->width, s->height, 0, s->avctx)) < 0)\n        goto fail;\n\n    if ((err = init_context_frame(s)))\n        goto fail;\n\n    memset(s->thread_context, 0, sizeof(s->thread_context));\n    s->thread_context[0]   = s;\n\n    if (s->width && s->height) {\n        int nb_slices = s->slice_context_count;\n        if (nb_slices > 1) {\n            for (i = 0; i < nb_slices; i++) {\n                if (i) {\n                    s->thread_context[i] = av_memdup(s, sizeof(MpegEncContext));\n                    if (!s->thread_context[i]) {\n                        err = AVERROR(ENOMEM);\n                        goto fail;\n                    }\n                }\n                if ((err = init_duplicate_context(s->thread_context[i])) < 0)\n                    goto fail;\n                s->thread_context[i]->start_mb_y =\n                    (s->mb_height * (i) + nb_slices / 2) / nb_slices;\n                s->thread_context[i]->end_mb_y   =\n                    (s->mb_height * (i + 1) + nb_slices / 2) / nb_slices;\n            }\n        } else {\n            err = init_duplicate_context(s);\n            if (err < 0)\n                goto fail;\n            s->start_mb_y = 0;\n            s->end_mb_y   = s->mb_height;\n        }\n        s->slice_context_count = nb_slices;\n    }\n\n    return 0;\n fail:\n    ff_mpv_common_end(s);\n    return err;\n}\n\n/* init common structure for both encoder and decoder */\nvoid ff_mpv_common_end(MpegEncContext *s)\n{\n    int i;\n\n    if (!s)\n        return ;\n\n    if (s->slice_context_count > 1) {\n        for (i = 0; i < s->slice_context_count; i++) {\n            free_duplicate_context(s->thread_context[i]);\n        }\n        for (i = 1; i < s->slice_context_count; i++) {\n            av_freep(&s->thread_context[i]);\n        }\n        s->slice_context_count = 1;\n    } else free_duplicate_context(s);\n\n    av_freep(&s->parse_context.buffer);\n    s->parse_context.buffer_size = 0;\n\n    av_freep(&s->bitstream_buffer);\n    s->allocated_bitstream_buffer_size = 0;\n\n    if (s->picture) {\n        for (i = 0; i < MAX_PICTURE_COUNT; i++) {\n            ff_free_picture_tables(&s->picture[i]);\n            ff_mpeg_unref_picture(s->avctx, &s->picture[i]);\n            av_frame_free(&s->picture[i].f);\n        }\n    }\n    av_freep(&s->picture);\n    ff_free_picture_tables(&s->last_picture);\n    ff_mpeg_unref_picture(s->avctx, &s->last_picture);\n    av_frame_free(&s->last_picture.f);\n    ff_free_picture_tables(&s->current_picture);\n    ff_mpeg_unref_picture(s->avctx, &s->current_picture);\n    av_frame_free(&s->current_picture.f);\n    ff_free_picture_tables(&s->next_picture);\n    ff_mpeg_unref_picture(s->avctx, &s->next_picture);\n    av_frame_free(&s->next_picture.f);\n    ff_free_picture_tables(&s->new_picture);\n    ff_mpeg_unref_picture(s->avctx, &s->new_picture);\n    av_frame_free(&s->new_picture.f);\n\n    free_context_frame(s);\n\n    s->context_initialized      = 0;\n    s->last_picture_ptr         =\n    s->next_picture_ptr         =\n    s->current_picture_ptr      = NULL;\n    s->linesize = s->uvlinesize = 0;\n}\n\n\nstatic void gray_frame(AVFrame *frame)\n{\n    int i, h_chroma_shift, v_chroma_shift;\n\n    av_pix_fmt_get_chroma_sub_sample(frame->format, &h_chroma_shift, &v_chroma_shift);\n\n    for(i=0; i<frame->height; i++)\n        memset(frame->data[0] + frame->linesize[0]*i, 0x80, frame->width);\n    for(i=0; i<AV_CEIL_RSHIFT(frame->height, v_chroma_shift); i++) {\n        memset(frame->data[1] + frame->linesize[1]*i,\n               0x80, AV_CEIL_RSHIFT(frame->width, h_chroma_shift));\n        memset(frame->data[2] + frame->linesize[2]*i,\n               0x80, AV_CEIL_RSHIFT(frame->width, h_chroma_shift));\n    }\n}\n\n/**\n * generic function called after decoding\n * the header and before a frame is decoded.\n */\nint ff_mpv_frame_start(MpegEncContext *s, AVCodecContext *avctx)\n{\n    int i, ret;\n    Picture *pic;\n    s->mb_skipped = 0;\n\n    if (!ff_thread_can_start_frame(avctx)) {\n        av_log(avctx, AV_LOG_ERROR, \"Attempt to start a frame outside SETUP state\\n\");\n        return -1;\n    }\n\n    /* mark & release old frames */\n    if (s->pict_type != AV_PICTURE_TYPE_B && s->last_picture_ptr &&\n        s->last_picture_ptr != s->next_picture_ptr &&\n        s->last_picture_ptr->f->buf[0]) {\n        ff_mpeg_unref_picture(s->avctx, s->last_picture_ptr);\n    }\n\n    /* release forgotten pictures */\n    /* if (MPEG-124 / H.263) */\n    for (i = 0; i < MAX_PICTURE_COUNT; i++) {\n        if (&s->picture[i] != s->last_picture_ptr &&\n            &s->picture[i] != s->next_picture_ptr &&\n            s->picture[i].reference && !s->picture[i].needs_realloc) {\n            ff_mpeg_unref_picture(s->avctx, &s->picture[i]);\n        }\n    }\n\n    ff_mpeg_unref_picture(s->avctx, &s->current_picture);\n    ff_mpeg_unref_picture(s->avctx, &s->last_picture);\n    ff_mpeg_unref_picture(s->avctx, &s->next_picture);\n\n    /* release non reference frames */\n    for (i = 0; i < MAX_PICTURE_COUNT; i++) {\n        if (!s->picture[i].reference)\n            ff_mpeg_unref_picture(s->avctx, &s->picture[i]);\n    }\n\n    if (s->current_picture_ptr && !s->current_picture_ptr->f->buf[0]) {\n        // we already have an unused image\n        // (maybe it was set before reading the header)\n        pic = s->current_picture_ptr;\n    } else {\n        i   = ff_find_unused_picture(s->avctx, s->picture, 0);\n        if (i < 0) {\n            av_log(s->avctx, AV_LOG_ERROR, \"no frame buffer available\\n\");\n            return i;\n        }\n        pic = &s->picture[i];\n    }\n\n    pic->reference = 0;\n    if (!s->droppable) {\n        if (s->pict_type != AV_PICTURE_TYPE_B)\n            pic->reference = 3;\n    }\n\n    pic->f->coded_picture_number = s->coded_picture_number++;\n\n    if (alloc_picture(s, pic, 0) < 0)\n        return -1;\n\n    s->current_picture_ptr = pic;\n    // FIXME use only the vars from current_pic\n    s->current_picture_ptr->f->top_field_first = s->top_field_first;\n    if (s->codec_id == AV_CODEC_ID_MPEG1VIDEO ||\n        s->codec_id == AV_CODEC_ID_MPEG2VIDEO) {\n        if (s->picture_structure != PICT_FRAME)\n            s->current_picture_ptr->f->top_field_first =\n                (s->picture_structure == PICT_TOP_FIELD) == s->first_field;\n    }\n    s->current_picture_ptr->f->interlaced_frame = !s->progressive_frame &&\n                                                 !s->progressive_sequence;\n    s->current_picture_ptr->field_picture      =  s->picture_structure != PICT_FRAME;\n\n    s->current_picture_ptr->f->pict_type = s->pict_type;\n    // if (s->avctx->flags && AV_CODEC_FLAG_QSCALE)\n    //     s->current_picture_ptr->quality = s->new_picture_ptr->quality;\n    s->current_picture_ptr->f->key_frame = s->pict_type == AV_PICTURE_TYPE_I;\n\n    if ((ret = ff_mpeg_ref_picture(s->avctx, &s->current_picture,\n                                   s->current_picture_ptr)) < 0)\n        return ret;\n\n    if (s->pict_type != AV_PICTURE_TYPE_B) {\n        s->last_picture_ptr = s->next_picture_ptr;\n        if (!s->droppable)\n            s->next_picture_ptr = s->current_picture_ptr;\n    }\n    ff_dlog(s->avctx, \"L%p N%p C%p L%p N%p C%p type:%d drop:%d\\n\",\n            s->last_picture_ptr, s->next_picture_ptr,s->current_picture_ptr,\n            s->last_picture_ptr    ? s->last_picture_ptr->f->data[0]    : NULL,\n            s->next_picture_ptr    ? s->next_picture_ptr->f->data[0]    : NULL,\n            s->current_picture_ptr ? s->current_picture_ptr->f->data[0] : NULL,\n            s->pict_type, s->droppable);\n\n    if ((!s->last_picture_ptr || !s->last_picture_ptr->f->buf[0]) &&\n        (s->pict_type != AV_PICTURE_TYPE_I)) {\n        int h_chroma_shift, v_chroma_shift;\n        av_pix_fmt_get_chroma_sub_sample(s->avctx->pix_fmt,\n                                         &h_chroma_shift, &v_chroma_shift);\n        if (s->pict_type == AV_PICTURE_TYPE_B && s->next_picture_ptr && s->next_picture_ptr->f->buf[0])\n            av_log(avctx, AV_LOG_DEBUG,\n                   \"allocating dummy last picture for B frame\\n\");\n        else if (s->pict_type != AV_PICTURE_TYPE_I)\n            av_log(avctx, AV_LOG_ERROR,\n                   \"warning: first frame is no keyframe\\n\");\n\n        /* Allocate a dummy frame */\n        i = ff_find_unused_picture(s->avctx, s->picture, 0);\n        if (i < 0) {\n            av_log(s->avctx, AV_LOG_ERROR, \"no frame buffer available\\n\");\n            return i;\n        }\n        s->last_picture_ptr = &s->picture[i];\n\n        s->last_picture_ptr->reference   = 3;\n        s->last_picture_ptr->f->key_frame = 0;\n        s->last_picture_ptr->f->pict_type = AV_PICTURE_TYPE_P;\n\n        if (alloc_picture(s, s->last_picture_ptr, 0) < 0) {\n            s->last_picture_ptr = NULL;\n            return -1;\n        }\n\n        if (!avctx->hwaccel) {\n            for(i=0; i<avctx->height; i++)\n                memset(s->last_picture_ptr->f->data[0] + s->last_picture_ptr->f->linesize[0]*i,\n                       0x80, avctx->width);\n            if (s->last_picture_ptr->f->data[2]) {\n                for(i=0; i<AV_CEIL_RSHIFT(avctx->height, v_chroma_shift); i++) {\n                    memset(s->last_picture_ptr->f->data[1] + s->last_picture_ptr->f->linesize[1]*i,\n                        0x80, AV_CEIL_RSHIFT(avctx->width, h_chroma_shift));\n                    memset(s->last_picture_ptr->f->data[2] + s->last_picture_ptr->f->linesize[2]*i,\n                        0x80, AV_CEIL_RSHIFT(avctx->width, h_chroma_shift));\n                }\n            }\n\n            if(s->codec_id == AV_CODEC_ID_FLV1 || s->codec_id == AV_CODEC_ID_H263){\n                for(i=0; i<avctx->height; i++)\n                memset(s->last_picture_ptr->f->data[0] + s->last_picture_ptr->f->linesize[0]*i, 16, avctx->width);\n            }\n        }\n\n        ff_thread_report_progress(&s->last_picture_ptr->tf, INT_MAX, 0);\n        ff_thread_report_progress(&s->last_picture_ptr->tf, INT_MAX, 1);\n    }\n    if ((!s->next_picture_ptr || !s->next_picture_ptr->f->buf[0]) &&\n        s->pict_type == AV_PICTURE_TYPE_B) {\n        /* Allocate a dummy frame */\n        i = ff_find_unused_picture(s->avctx, s->picture, 0);\n        if (i < 0) {\n            av_log(s->avctx, AV_LOG_ERROR, \"no frame buffer available\\n\");\n            return i;\n        }\n        s->next_picture_ptr = &s->picture[i];\n\n        s->next_picture_ptr->reference   = 3;\n        s->next_picture_ptr->f->key_frame = 0;\n        s->next_picture_ptr->f->pict_type = AV_PICTURE_TYPE_P;\n\n        if (alloc_picture(s, s->next_picture_ptr, 0) < 0) {\n            s->next_picture_ptr = NULL;\n            return -1;\n        }\n        ff_thread_report_progress(&s->next_picture_ptr->tf, INT_MAX, 0);\n        ff_thread_report_progress(&s->next_picture_ptr->tf, INT_MAX, 1);\n    }\n\n#if 0 // BUFREF-FIXME\n    memset(s->last_picture.f->data, 0, sizeof(s->last_picture.f->data));\n    memset(s->next_picture.f->data, 0, sizeof(s->next_picture.f->data));\n#endif\n    if (s->last_picture_ptr) {\n        if (s->last_picture_ptr->f->buf[0] &&\n            (ret = ff_mpeg_ref_picture(s->avctx, &s->last_picture,\n                                       s->last_picture_ptr)) < 0)\n            return ret;\n    }\n    if (s->next_picture_ptr) {\n        if (s->next_picture_ptr->f->buf[0] &&\n            (ret = ff_mpeg_ref_picture(s->avctx, &s->next_picture,\n                                       s->next_picture_ptr)) < 0)\n            return ret;\n    }\n\n    av_assert0(s->pict_type == AV_PICTURE_TYPE_I || (s->last_picture_ptr &&\n                                                 s->last_picture_ptr->f->buf[0]));\n\n    if (s->picture_structure!= PICT_FRAME) {\n        int i;\n        for (i = 0; i < 4; i++) {\n            if (s->picture_structure == PICT_BOTTOM_FIELD) {\n                s->current_picture.f->data[i] +=\n                    s->current_picture.f->linesize[i];\n            }\n            s->current_picture.f->linesize[i] *= 2;\n            s->last_picture.f->linesize[i]    *= 2;\n            s->next_picture.f->linesize[i]    *= 2;\n        }\n    }\n\n    /* set dequantizer, we can't do it during init as\n     * it might change for MPEG-4 and we can't do it in the header\n     * decode as init is not called for MPEG-4 there yet */\n    if (s->mpeg_quant || s->codec_id == AV_CODEC_ID_MPEG2VIDEO) {\n        s->dct_unquantize_intra = s->dct_unquantize_mpeg2_intra;\n        s->dct_unquantize_inter = s->dct_unquantize_mpeg2_inter;\n    } else if (s->out_format == FMT_H263 || s->out_format == FMT_H261) {\n        s->dct_unquantize_intra = s->dct_unquantize_h263_intra;\n        s->dct_unquantize_inter = s->dct_unquantize_h263_inter;\n    } else {\n        s->dct_unquantize_intra = s->dct_unquantize_mpeg1_intra;\n        s->dct_unquantize_inter = s->dct_unquantize_mpeg1_inter;\n    }\n\n    if (s->avctx->debug & FF_DEBUG_NOMC) {\n        gray_frame(s->current_picture_ptr->f);\n    }\n\n    return 0;\n}\n\n/* called after a frame has been decoded. */\nvoid ff_mpv_frame_end(MpegEncContext *s)\n{\n    emms_c();\n\n    if (s->current_picture.reference)\n        ff_thread_report_progress(&s->current_picture_ptr->tf, INT_MAX, 0);\n}\n\nvoid ff_print_debug_info(MpegEncContext *s, Picture *p, AVFrame *pict)\n{\n    ff_print_debug_info2(s->avctx, pict, s->mbskip_table, p->mb_type,\n                         p->qscale_table, p->motion_val, &s->low_delay,\n                         s->mb_width, s->mb_height, s->mb_stride, s->quarter_sample);\n}\n\nint ff_mpv_export_qp_table(MpegEncContext *s, AVFrame *f, Picture *p, int qp_type)\n{\n    AVBufferRef *ref = av_buffer_ref(p->qscale_table_buf);\n    int offset = 2*s->mb_stride + 1;\n    if(!ref)\n        return AVERROR(ENOMEM);\n    av_assert0(ref->size >= offset + s->mb_stride * ((f->height+15)/16));\n    ref->size -= offset;\n    ref->data += offset;\n    return av_frame_set_qp_table(f, ref, s->mb_stride, qp_type);\n}\n\nstatic inline int hpel_motion_lowres(MpegEncContext *s,\n                                     uint8_t *dest, uint8_t *src,\n                                     int field_based, int field_select,\n                                     int src_x, int src_y,\n                                     int width, int height, ptrdiff_t stride,\n                                     int h_edge_pos, int v_edge_pos,\n                                     int w, int h, h264_chroma_mc_func *pix_op,\n                                     int motion_x, int motion_y)\n{\n    const int lowres   = s->avctx->lowres;\n    const int op_index = FFMIN(lowres, 3);\n    const int s_mask   = (2 << lowres) - 1;\n    int emu = 0;\n    int sx, sy;\n\n    if (s->quarter_sample) {\n        motion_x /= 2;\n        motion_y /= 2;\n    }\n\n    sx = motion_x & s_mask;\n    sy = motion_y & s_mask;\n    src_x += motion_x >> lowres + 1;\n    src_y += motion_y >> lowres + 1;\n\n    src   += src_y * stride + src_x;\n\n    if ((unsigned)src_x > FFMAX( h_edge_pos - (!!sx) - w,                 0) ||\n        (unsigned)src_y > FFMAX((v_edge_pos >> field_based) - (!!sy) - h, 0)) {\n        s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, src,\n                                 s->linesize, s->linesize,\n                                 w + 1, (h + 1) << field_based,\n                                 src_x, src_y   << field_based,\n                                 h_edge_pos, v_edge_pos);\n        src = s->sc.edge_emu_buffer;\n        emu = 1;\n    }\n\n    sx = (sx << 2) >> lowres;\n    sy = (sy << 2) >> lowres;\n    if (field_select)\n        src += s->linesize;\n    pix_op[op_index](dest, src, stride, h, sx, sy);\n    return emu;\n}\n\n/* apply one mpeg motion vector to the three components */\nstatic av_always_inline void mpeg_motion_lowres(MpegEncContext *s,\n                                                uint8_t *dest_y,\n                                                uint8_t *dest_cb,\n                                                uint8_t *dest_cr,\n                                                int field_based,\n                                                int bottom_field,\n                                                int field_select,\n                                                uint8_t **ref_picture,\n                                                h264_chroma_mc_func *pix_op,\n                                                int motion_x, int motion_y,\n                                                int h, int mb_y)\n{\n    uint8_t *ptr_y, *ptr_cb, *ptr_cr;\n    int mx, my, src_x, src_y, uvsrc_x, uvsrc_y, sx, sy, uvsx, uvsy;\n    ptrdiff_t uvlinesize, linesize;\n    const int lowres     = s->avctx->lowres;\n    const int op_index   = FFMIN(lowres-1+s->chroma_x_shift, 3);\n    const int block_s    = 8>>lowres;\n    const int s_mask     = (2 << lowres) - 1;\n    const int h_edge_pos = s->h_edge_pos >> lowres;\n    const int v_edge_pos = s->v_edge_pos >> lowres;\n    linesize   = s->current_picture.f->linesize[0] << field_based;\n    uvlinesize = s->current_picture.f->linesize[1] << field_based;\n\n    // FIXME obviously not perfect but qpel will not work in lowres anyway\n    if (s->quarter_sample) {\n        motion_x /= 2;\n        motion_y /= 2;\n    }\n\n    if(field_based){\n        motion_y += (bottom_field - field_select)*((1 << lowres)-1);\n    }\n\n    sx = motion_x & s_mask;\n    sy = motion_y & s_mask;\n    src_x = s->mb_x * 2 * block_s + (motion_x >> lowres + 1);\n    src_y = (mb_y * 2 * block_s >> field_based) + (motion_y >> lowres + 1);\n\n    if (s->out_format == FMT_H263) {\n        uvsx    = ((motion_x >> 1) & s_mask) | (sx & 1);\n        uvsy    = ((motion_y >> 1) & s_mask) | (sy & 1);\n        uvsrc_x = src_x >> 1;\n        uvsrc_y = src_y >> 1;\n    } else if (s->out_format == FMT_H261) {\n        // even chroma mv's are full pel in H261\n        mx      = motion_x / 4;\n        my      = motion_y / 4;\n        uvsx    = (2 * mx) & s_mask;\n        uvsy    = (2 * my) & s_mask;\n        uvsrc_x = s->mb_x * block_s + (mx >> lowres);\n        uvsrc_y =    mb_y * block_s + (my >> lowres);\n    } else {\n        if(s->chroma_y_shift){\n            mx      = motion_x / 2;\n            my      = motion_y / 2;\n            uvsx    = mx & s_mask;\n            uvsy    = my & s_mask;\n            uvsrc_x = s->mb_x * block_s                 + (mx >> lowres + 1);\n            uvsrc_y =   (mb_y * block_s >> field_based) + (my >> lowres + 1);\n        } else {\n            if(s->chroma_x_shift){\n            //Chroma422\n                mx = motion_x / 2;\n                uvsx = mx & s_mask;\n                uvsy = motion_y & s_mask;\n                uvsrc_y = src_y;\n                uvsrc_x = s->mb_x*block_s               + (mx >> (lowres+1));\n            } else {\n            //Chroma444\n                uvsx = motion_x & s_mask;\n                uvsy = motion_y & s_mask;\n                uvsrc_x = src_x;\n                uvsrc_y = src_y;\n            }\n        }\n    }\n\n    ptr_y  = ref_picture[0] + src_y   * linesize   + src_x;\n    ptr_cb = ref_picture[1] + uvsrc_y * uvlinesize + uvsrc_x;\n    ptr_cr = ref_picture[2] + uvsrc_y * uvlinesize + uvsrc_x;\n\n    if ((unsigned) src_x > FFMAX( h_edge_pos - (!!sx) - 2 * block_s,       0) || uvsrc_y<0 ||\n        (unsigned) src_y > FFMAX((v_edge_pos >> field_based) - (!!sy) - h, 0)) {\n        s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, ptr_y,\n                                 linesize >> field_based, linesize >> field_based,\n                                 17, 17 + field_based,\n                                src_x, src_y << field_based, h_edge_pos,\n                                v_edge_pos);\n        ptr_y = s->sc.edge_emu_buffer;\n        if (!CONFIG_GRAY || !(s->avctx->flags & AV_CODEC_FLAG_GRAY)) {\n            uint8_t *ubuf = s->sc.edge_emu_buffer + 18 * s->linesize;\n            uint8_t *vbuf =ubuf + 10 * s->uvlinesize;\n            if (s->workaround_bugs & FF_BUG_IEDGE)\n                vbuf -= s->uvlinesize;\n            s->vdsp.emulated_edge_mc(ubuf,  ptr_cb,\n                                     uvlinesize >> field_based, uvlinesize >> field_based,\n                                     9, 9 + field_based,\n                                    uvsrc_x, uvsrc_y << field_based,\n                                    h_edge_pos >> 1, v_edge_pos >> 1);\n            s->vdsp.emulated_edge_mc(vbuf,  ptr_cr,\n                                     uvlinesize >> field_based,uvlinesize >> field_based,\n                                     9, 9 + field_based,\n                                    uvsrc_x, uvsrc_y << field_based,\n                                    h_edge_pos >> 1, v_edge_pos >> 1);\n            ptr_cb = ubuf;\n            ptr_cr = vbuf;\n        }\n    }\n\n    // FIXME use this for field pix too instead of the obnoxious hack which changes picture.f->data\n    if (bottom_field) {\n        dest_y  += s->linesize;\n        dest_cb += s->uvlinesize;\n        dest_cr += s->uvlinesize;\n    }\n\n    if (field_select) {\n        ptr_y   += s->linesize;\n        ptr_cb  += s->uvlinesize;\n        ptr_cr  += s->uvlinesize;\n    }\n\n    sx = (sx << 2) >> lowres;\n    sy = (sy << 2) >> lowres;\n    pix_op[lowres - 1](dest_y, ptr_y, linesize, h, sx, sy);\n\n    if (!CONFIG_GRAY || !(s->avctx->flags & AV_CODEC_FLAG_GRAY)) {\n        int hc = s->chroma_y_shift ? (h+1-bottom_field)>>1 : h;\n        uvsx = (uvsx << 2) >> lowres;\n        uvsy = (uvsy << 2) >> lowres;\n        if (hc) {\n            pix_op[op_index](dest_cb, ptr_cb, uvlinesize, hc, uvsx, uvsy);\n            pix_op[op_index](dest_cr, ptr_cr, uvlinesize, hc, uvsx, uvsy);\n        }\n    }\n    // FIXME h261 lowres loop filter\n}\n\nstatic inline void chroma_4mv_motion_lowres(MpegEncContext *s,\n                                            uint8_t *dest_cb, uint8_t *dest_cr,\n                                            uint8_t **ref_picture,\n                                            h264_chroma_mc_func * pix_op,\n                                            int mx, int my)\n{\n    const int lowres     = s->avctx->lowres;\n    const int op_index   = FFMIN(lowres, 3);\n    const int block_s    = 8 >> lowres;\n    const int s_mask     = (2 << lowres) - 1;\n    const int h_edge_pos = s->h_edge_pos >> lowres + 1;\n    const int v_edge_pos = s->v_edge_pos >> lowres + 1;\n    int emu = 0, src_x, src_y, sx, sy;\n    ptrdiff_t offset;\n    uint8_t *ptr;\n\n    if (s->quarter_sample) {\n        mx /= 2;\n        my /= 2;\n    }\n\n    /* In case of 8X8, we construct a single chroma motion vector\n       with a special rounding */\n    mx = ff_h263_round_chroma(mx);\n    my = ff_h263_round_chroma(my);\n\n    sx = mx & s_mask;\n    sy = my & s_mask;\n    src_x = s->mb_x * block_s + (mx >> lowres + 1);\n    src_y = s->mb_y * block_s + (my >> lowres + 1);\n\n    offset = src_y * s->uvlinesize + src_x;\n    ptr = ref_picture[1] + offset;\n    if ((unsigned) src_x > FFMAX(h_edge_pos - (!!sx) - block_s, 0) ||\n        (unsigned) src_y > FFMAX(v_edge_pos - (!!sy) - block_s, 0)) {\n        s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, ptr,\n                                 s->uvlinesize, s->uvlinesize,\n                                 9, 9,\n                                 src_x, src_y, h_edge_pos, v_edge_pos);\n        ptr = s->sc.edge_emu_buffer;\n        emu = 1;\n    }\n    sx = (sx << 2) >> lowres;\n    sy = (sy << 2) >> lowres;\n    pix_op[op_index](dest_cb, ptr, s->uvlinesize, block_s, sx, sy);\n\n    ptr = ref_picture[2] + offset;\n    if (emu) {\n        s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, ptr,\n                                 s->uvlinesize, s->uvlinesize,\n                                 9, 9,\n                                 src_x, src_y, h_edge_pos, v_edge_pos);\n        ptr = s->sc.edge_emu_buffer;\n    }\n    pix_op[op_index](dest_cr, ptr, s->uvlinesize, block_s, sx, sy);\n}\n\n/**\n * motion compensation of a single macroblock\n * @param s context\n * @param dest_y luma destination pointer\n * @param dest_cb chroma cb/u destination pointer\n * @param dest_cr chroma cr/v destination pointer\n * @param dir direction (0->forward, 1->backward)\n * @param ref_picture array[3] of pointers to the 3 planes of the reference picture\n * @param pix_op halfpel motion compensation function (average or put normally)\n * the motion vectors are taken from s->mv and the MV type from s->mv_type\n */\nstatic inline void MPV_motion_lowres(MpegEncContext *s,\n                                     uint8_t *dest_y, uint8_t *dest_cb,\n                                     uint8_t *dest_cr,\n                                     int dir, uint8_t **ref_picture,\n                                     h264_chroma_mc_func *pix_op)\n{\n    int mx, my;\n    int mb_x, mb_y, i;\n    const int lowres  = s->avctx->lowres;\n    const int block_s = 8 >>lowres;\n\n    mb_x = s->mb_x;\n    mb_y = s->mb_y;\n\n    switch (s->mv_type) {\n    case MV_TYPE_16X16:\n        mpeg_motion_lowres(s, dest_y, dest_cb, dest_cr,\n                           0, 0, 0,\n                           ref_picture, pix_op,\n                           s->mv[dir][0][0], s->mv[dir][0][1],\n                           2 * block_s, mb_y);\n        break;\n    case MV_TYPE_8X8:\n        mx = 0;\n        my = 0;\n        for (i = 0; i < 4; i++) {\n            hpel_motion_lowres(s, dest_y + ((i & 1) + (i >> 1) *\n                               s->linesize) * block_s,\n                               ref_picture[0], 0, 0,\n                               (2 * mb_x + (i & 1)) * block_s,\n                               (2 * mb_y + (i >> 1)) * block_s,\n                               s->width, s->height, s->linesize,\n                               s->h_edge_pos >> lowres, s->v_edge_pos >> lowres,\n                               block_s, block_s, pix_op,\n                               s->mv[dir][i][0], s->mv[dir][i][1]);\n\n            mx += s->mv[dir][i][0];\n            my += s->mv[dir][i][1];\n        }\n\n        if (!CONFIG_GRAY || !(s->avctx->flags & AV_CODEC_FLAG_GRAY))\n            chroma_4mv_motion_lowres(s, dest_cb, dest_cr, ref_picture,\n                                     pix_op, mx, my);\n        break;\n    case MV_TYPE_FIELD:\n        if (s->picture_structure == PICT_FRAME) {\n            /* top field */\n            mpeg_motion_lowres(s, dest_y, dest_cb, dest_cr,\n                               1, 0, s->field_select[dir][0],\n                               ref_picture, pix_op,\n                               s->mv[dir][0][0], s->mv[dir][0][1],\n                               block_s, mb_y);\n            /* bottom field */\n            mpeg_motion_lowres(s, dest_y, dest_cb, dest_cr,\n                               1, 1, s->field_select[dir][1],\n                               ref_picture, pix_op,\n                               s->mv[dir][1][0], s->mv[dir][1][1],\n                               block_s, mb_y);\n        } else {\n            if (s->picture_structure != s->field_select[dir][0] + 1 &&\n                s->pict_type != AV_PICTURE_TYPE_B && !s->first_field) {\n                ref_picture = s->current_picture_ptr->f->data;\n\n            }\n            mpeg_motion_lowres(s, dest_y, dest_cb, dest_cr,\n                               0, 0, s->field_select[dir][0],\n                               ref_picture, pix_op,\n                               s->mv[dir][0][0],\n                               s->mv[dir][0][1], 2 * block_s, mb_y >> 1);\n            }\n        break;\n    case MV_TYPE_16X8:\n        for (i = 0; i < 2; i++) {\n            uint8_t **ref2picture;\n\n            if (s->picture_structure == s->field_select[dir][i] + 1 ||\n                s->pict_type == AV_PICTURE_TYPE_B || s->first_field) {\n                ref2picture = ref_picture;\n            } else {\n                ref2picture = s->current_picture_ptr->f->data;\n            }\n\n            mpeg_motion_lowres(s, dest_y, dest_cb, dest_cr,\n                               0, 0, s->field_select[dir][i],\n                               ref2picture, pix_op,\n                               s->mv[dir][i][0], s->mv[dir][i][1] +\n                               2 * block_s * i, block_s, mb_y >> 1);\n\n            dest_y  +=  2 * block_s *  s->linesize;\n            dest_cb += (2 * block_s >> s->chroma_y_shift) * s->uvlinesize;\n            dest_cr += (2 * block_s >> s->chroma_y_shift) * s->uvlinesize;\n        }\n        break;\n    case MV_TYPE_DMV:\n        if (s->picture_structure == PICT_FRAME) {\n            for (i = 0; i < 2; i++) {\n                int j;\n                for (j = 0; j < 2; j++) {\n                    mpeg_motion_lowres(s, dest_y, dest_cb, dest_cr,\n                                       1, j, j ^ i,\n                                       ref_picture, pix_op,\n                                       s->mv[dir][2 * i + j][0],\n                                       s->mv[dir][2 * i + j][1],\n                                       block_s, mb_y);\n                }\n                pix_op = s->h264chroma.avg_h264_chroma_pixels_tab;\n            }\n        } else {\n            for (i = 0; i < 2; i++) {\n                mpeg_motion_lowres(s, dest_y, dest_cb, dest_cr,\n                                   0, 0, s->picture_structure != i + 1,\n                                   ref_picture, pix_op,\n                                   s->mv[dir][2 * i][0],s->mv[dir][2 * i][1],\n                                   2 * block_s, mb_y >> 1);\n\n                // after put we make avg of the same block\n                pix_op = s->h264chroma.avg_h264_chroma_pixels_tab;\n\n                // opposite parity is always in the same\n                // frame if this is second field\n                if (!s->first_field) {\n                    ref_picture = s->current_picture_ptr->f->data;\n                }\n            }\n        }\n        break;\n    default:\n        av_assert2(0);\n    }\n}\n\n/**\n * find the lowest MB row referenced in the MVs\n */\nstatic int lowest_referenced_row(MpegEncContext *s, int dir)\n{\n    int my_max = INT_MIN, my_min = INT_MAX, qpel_shift = !s->quarter_sample;\n    int my, off, i, mvs;\n\n    if (s->picture_structure != PICT_FRAME || s->mcsel)\n        goto unhandled;\n\n    switch (s->mv_type) {\n        case MV_TYPE_16X16:\n            mvs = 1;\n            break;\n        case MV_TYPE_16X8:\n            mvs = 2;\n            break;\n        case MV_TYPE_8X8:\n            mvs = 4;\n            break;\n        default:\n            goto unhandled;\n    }\n\n    for (i = 0; i < mvs; i++) {\n        my = s->mv[dir][i][1];\n        my_max = FFMAX(my_max, my);\n        my_min = FFMIN(my_min, my);\n    }\n\n    off = ((FFMAX(-my_min, my_max)<<qpel_shift) + 63) >> 6;\n\n    return av_clip(s->mb_y + off, 0, s->mb_height - 1);\nunhandled:\n    return s->mb_height-1;\n}\n\n/* put block[] to dest[] */\nstatic inline void put_dct(MpegEncContext *s,\n                           int16_t *block, int i, uint8_t *dest, int line_size, int qscale)\n{\n    s->dct_unquantize_intra(s, block, i, qscale);\n    s->idsp.idct_put(dest, line_size, block);\n}\n\n/* add block[] to dest[] */\nstatic inline void add_dct(MpegEncContext *s,\n                           int16_t *block, int i, uint8_t *dest, int line_size)\n{\n    if (s->block_last_index[i] >= 0) {\n        s->idsp.idct_add(dest, line_size, block);\n    }\n}\n\nstatic inline void add_dequant_dct(MpegEncContext *s,\n                           int16_t *block, int i, uint8_t *dest, int line_size, int qscale)\n{\n    if (s->block_last_index[i] >= 0) {\n        s->dct_unquantize_inter(s, block, i, qscale);\n\n        s->idsp.idct_add(dest, line_size, block);\n    }\n}\n\n/**\n * Clean dc, ac, coded_block for the current non-intra MB.\n */\nvoid ff_clean_intra_table_entries(MpegEncContext *s)\n{\n    int wrap = s->b8_stride;\n    int xy = s->block_index[0];\n\n    s->dc_val[0][xy           ] =\n    s->dc_val[0][xy + 1       ] =\n    s->dc_val[0][xy     + wrap] =\n    s->dc_val[0][xy + 1 + wrap] = 1024;\n    /* ac pred */\n    memset(s->ac_val[0][xy       ], 0, 32 * sizeof(int16_t));\n    memset(s->ac_val[0][xy + wrap], 0, 32 * sizeof(int16_t));\n    if (s->msmpeg4_version>=3) {\n        s->coded_block[xy           ] =\n        s->coded_block[xy + 1       ] =\n        s->coded_block[xy     + wrap] =\n        s->coded_block[xy + 1 + wrap] = 0;\n    }\n    /* chroma */\n    wrap = s->mb_stride;\n    xy = s->mb_x + s->mb_y * wrap;\n    s->dc_val[1][xy] =\n    s->dc_val[2][xy] = 1024;\n    /* ac pred */\n    memset(s->ac_val[1][xy], 0, 16 * sizeof(int16_t));\n    memset(s->ac_val[2][xy], 0, 16 * sizeof(int16_t));\n\n    s->mbintra_table[xy]= 0;\n}\n\n/* generic function called after a macroblock has been parsed by the\n   decoder or after it has been encoded by the encoder.\n\n   Important variables used:\n   s->mb_intra : true if intra macroblock\n   s->mv_dir   : motion vector direction\n   s->mv_type  : motion vector type\n   s->mv       : motion vector\n   s->interlaced_dct : true if interlaced dct used (mpeg2)\n */\nstatic av_always_inline\nvoid mpv_reconstruct_mb_internal(MpegEncContext *s, int16_t block[12][64],\n                            int lowres_flag, int is_mpeg12)\n{\n    const int mb_xy = s->mb_y * s->mb_stride + s->mb_x;\n\n    if (CONFIG_XVMC &&\n        s->avctx->hwaccel && s->avctx->hwaccel->decode_mb) {\n        s->avctx->hwaccel->decode_mb(s);//xvmc uses pblocks\n        return;\n    }\n\n    if(s->avctx->debug&FF_DEBUG_DCT_COEFF) {\n       /* print DCT coefficients */\n       int i,j;\n       av_log(s->avctx, AV_LOG_DEBUG, \"DCT coeffs of MB at %dx%d:\\n\", s->mb_x, s->mb_y);\n       for(i=0; i<6; i++){\n           for(j=0; j<64; j++){\n               av_log(s->avctx, AV_LOG_DEBUG, \"%5d\",\n                      block[i][s->idsp.idct_permutation[j]]);\n           }\n           av_log(s->avctx, AV_LOG_DEBUG, \"\\n\");\n       }\n    }\n\n    s->current_picture.qscale_table[mb_xy] = s->qscale;\n\n    /* update DC predictors for P macroblocks */\n    if (!s->mb_intra) {\n        if (!is_mpeg12 && (s->h263_pred || s->h263_aic)) {\n            if(s->mbintra_table[mb_xy])\n                ff_clean_intra_table_entries(s);\n        } else {\n            s->last_dc[0] =\n            s->last_dc[1] =\n            s->last_dc[2] = 128 << s->intra_dc_precision;\n        }\n    }\n    else if (!is_mpeg12 && (s->h263_pred || s->h263_aic))\n        s->mbintra_table[mb_xy]=1;\n\n    if ((s->avctx->flags & AV_CODEC_FLAG_PSNR) || s->frame_skip_threshold || s->frame_skip_factor ||\n        !(s->encoding && (s->intra_only || s->pict_type == AV_PICTURE_TYPE_B) &&\n          s->avctx->mb_decision != FF_MB_DECISION_RD)) { // FIXME precalc\n        uint8_t *dest_y, *dest_cb, *dest_cr;\n        int dct_linesize, dct_offset;\n        op_pixels_func (*op_pix)[4];\n        qpel_mc_func (*op_qpix)[16];\n        const int linesize   = s->current_picture.f->linesize[0]; //not s->linesize as this would be wrong for field pics\n        const int uvlinesize = s->current_picture.f->linesize[1];\n        const int readable= s->pict_type != AV_PICTURE_TYPE_B || s->encoding || s->avctx->draw_horiz_band || lowres_flag;\n        const int block_size= lowres_flag ? 8>>s->avctx->lowres : 8;\n\n        /* avoid copy if macroblock skipped in last frame too */\n        /* skip only during decoding as we might trash the buffers during encoding a bit */\n        if(!s->encoding){\n            uint8_t *mbskip_ptr = &s->mbskip_table[mb_xy];\n\n            if (s->mb_skipped) {\n                s->mb_skipped= 0;\n                av_assert2(s->pict_type!=AV_PICTURE_TYPE_I);\n                *mbskip_ptr = 1;\n            } else if(!s->current_picture.reference) {\n                *mbskip_ptr = 1;\n            } else{\n                *mbskip_ptr = 0; /* not skipped */\n            }\n        }\n\n        dct_linesize = linesize << s->interlaced_dct;\n        dct_offset   = s->interlaced_dct ? linesize : linesize * block_size;\n\n        if(readable){\n            dest_y=  s->dest[0];\n            dest_cb= s->dest[1];\n            dest_cr= s->dest[2];\n        }else{\n            dest_y = s->sc.b_scratchpad;\n            dest_cb= s->sc.b_scratchpad+16*linesize;\n            dest_cr= s->sc.b_scratchpad+32*linesize;\n        }\n\n        if (!s->mb_intra) {\n            /* motion handling */\n            /* decoding or more than one mb_type (MC was already done otherwise) */\n            if(!s->encoding){\n\n                if(HAVE_THREADS && s->avctx->active_thread_type&FF_THREAD_FRAME) {\n                    if (s->mv_dir & MV_DIR_FORWARD) {\n                        ff_thread_await_progress(&s->last_picture_ptr->tf,\n                                                 lowest_referenced_row(s, 0),\n                                                 0);\n                    }\n                    if (s->mv_dir & MV_DIR_BACKWARD) {\n                        ff_thread_await_progress(&s->next_picture_ptr->tf,\n                                                 lowest_referenced_row(s, 1),\n                                                 0);\n                    }\n                }\n\n                if(lowres_flag){\n                    h264_chroma_mc_func *op_pix = s->h264chroma.put_h264_chroma_pixels_tab;\n\n                    if (s->mv_dir & MV_DIR_FORWARD) {\n                        MPV_motion_lowres(s, dest_y, dest_cb, dest_cr, 0, s->last_picture.f->data, op_pix);\n                        op_pix = s->h264chroma.avg_h264_chroma_pixels_tab;\n                    }\n                    if (s->mv_dir & MV_DIR_BACKWARD) {\n                        MPV_motion_lowres(s, dest_y, dest_cb, dest_cr, 1, s->next_picture.f->data, op_pix);\n                    }\n                }else{\n                    op_qpix = s->me.qpel_put;\n                    if ((!s->no_rounding) || s->pict_type==AV_PICTURE_TYPE_B){\n                        op_pix = s->hdsp.put_pixels_tab;\n                    }else{\n                        op_pix = s->hdsp.put_no_rnd_pixels_tab;\n                    }\n                    if (s->mv_dir & MV_DIR_FORWARD) {\n                        ff_mpv_motion(s, dest_y, dest_cb, dest_cr, 0, s->last_picture.f->data, op_pix, op_qpix);\n                        op_pix = s->hdsp.avg_pixels_tab;\n                        op_qpix= s->me.qpel_avg;\n                    }\n                    if (s->mv_dir & MV_DIR_BACKWARD) {\n                        ff_mpv_motion(s, dest_y, dest_cb, dest_cr, 1, s->next_picture.f->data, op_pix, op_qpix);\n                    }\n                }\n            }\n\n            /* skip dequant / idct if we are really late ;) */\n            if(s->avctx->skip_idct){\n                if(  (s->avctx->skip_idct >= AVDISCARD_NONREF && s->pict_type == AV_PICTURE_TYPE_B)\n                   ||(s->avctx->skip_idct >= AVDISCARD_NONKEY && s->pict_type != AV_PICTURE_TYPE_I)\n                   || s->avctx->skip_idct >= AVDISCARD_ALL)\n                    goto skip_idct;\n            }\n\n            /* add dct residue */\n            if(s->encoding || !(   s->msmpeg4_version || s->codec_id==AV_CODEC_ID_MPEG1VIDEO || s->codec_id==AV_CODEC_ID_MPEG2VIDEO\n                                || (s->codec_id==AV_CODEC_ID_MPEG4 && !s->mpeg_quant))){\n                add_dequant_dct(s, block[0], 0, dest_y                          , dct_linesize, s->qscale);\n                add_dequant_dct(s, block[1], 1, dest_y              + block_size, dct_linesize, s->qscale);\n                add_dequant_dct(s, block[2], 2, dest_y + dct_offset             , dct_linesize, s->qscale);\n                add_dequant_dct(s, block[3], 3, dest_y + dct_offset + block_size, dct_linesize, s->qscale);\n\n                if (!CONFIG_GRAY || !(s->avctx->flags & AV_CODEC_FLAG_GRAY)) {\n                    if (s->chroma_y_shift){\n                        add_dequant_dct(s, block[4], 4, dest_cb, uvlinesize, s->chroma_qscale);\n                        add_dequant_dct(s, block[5], 5, dest_cr, uvlinesize, s->chroma_qscale);\n                    }else{\n                        dct_linesize >>= 1;\n                        dct_offset >>=1;\n                        add_dequant_dct(s, block[4], 4, dest_cb,              dct_linesize, s->chroma_qscale);\n                        add_dequant_dct(s, block[5], 5, dest_cr,              dct_linesize, s->chroma_qscale);\n                        add_dequant_dct(s, block[6], 6, dest_cb + dct_offset, dct_linesize, s->chroma_qscale);\n                        add_dequant_dct(s, block[7], 7, dest_cr + dct_offset, dct_linesize, s->chroma_qscale);\n                    }\n                }\n            } else if(is_mpeg12 || (s->codec_id != AV_CODEC_ID_WMV2)){\n                add_dct(s, block[0], 0, dest_y                          , dct_linesize);\n                add_dct(s, block[1], 1, dest_y              + block_size, dct_linesize);\n                add_dct(s, block[2], 2, dest_y + dct_offset             , dct_linesize);\n                add_dct(s, block[3], 3, dest_y + dct_offset + block_size, dct_linesize);\n\n                if (!CONFIG_GRAY || !(s->avctx->flags & AV_CODEC_FLAG_GRAY)) {\n                    if(s->chroma_y_shift){//Chroma420\n                        add_dct(s, block[4], 4, dest_cb, uvlinesize);\n                        add_dct(s, block[5], 5, dest_cr, uvlinesize);\n                    }else{\n                        //chroma422\n                        dct_linesize = uvlinesize << s->interlaced_dct;\n                        dct_offset   = s->interlaced_dct ? uvlinesize : uvlinesize*block_size;\n\n                        add_dct(s, block[4], 4, dest_cb, dct_linesize);\n                        add_dct(s, block[5], 5, dest_cr, dct_linesize);\n                        add_dct(s, block[6], 6, dest_cb+dct_offset, dct_linesize);\n                        add_dct(s, block[7], 7, dest_cr+dct_offset, dct_linesize);\n                        if(!s->chroma_x_shift){//Chroma444\n                            add_dct(s, block[8], 8, dest_cb+block_size, dct_linesize);\n                            add_dct(s, block[9], 9, dest_cr+block_size, dct_linesize);\n                            add_dct(s, block[10], 10, dest_cb+block_size+dct_offset, dct_linesize);\n                            add_dct(s, block[11], 11, dest_cr+block_size+dct_offset, dct_linesize);\n                        }\n                    }\n                }//fi gray\n            }\n            else if (CONFIG_WMV2_DECODER || CONFIG_WMV2_ENCODER) {\n                ff_wmv2_add_mb(s, block, dest_y, dest_cb, dest_cr);\n            }\n        } else {\n            /* Only MPEG-4 Simple Studio Profile is supported in > 8-bit mode.\n               TODO: Integrate 10-bit properly into mpegvideo.c so that ER works properly */\n            if (s->avctx->bits_per_raw_sample > 8){\n                const int act_block_size = block_size * 2;\n                s->idsp.idct_put(dest_y,                           dct_linesize, (int16_t*)(*s->block32)[0]);\n                s->idsp.idct_put(dest_y              + act_block_size, dct_linesize, (int16_t*)(*s->block32)[1]);\n                s->idsp.idct_put(dest_y + dct_offset,              dct_linesize, (int16_t*)(*s->block32)[2]);\n                s->idsp.idct_put(dest_y + dct_offset + act_block_size, dct_linesize, (int16_t*)(*s->block32)[3]);\n\n                dct_linesize = uvlinesize << s->interlaced_dct;\n                dct_offset   = s->interlaced_dct ? uvlinesize : uvlinesize*block_size;\n\n                s->idsp.idct_put(dest_cb,              dct_linesize, (int16_t*)(*s->block32)[4]);\n                s->idsp.idct_put(dest_cr,              dct_linesize, (int16_t*)(*s->block32)[5]);\n                s->idsp.idct_put(dest_cb + dct_offset, dct_linesize, (int16_t*)(*s->block32)[6]);\n                s->idsp.idct_put(dest_cr + dct_offset, dct_linesize, (int16_t*)(*s->block32)[7]);\n                if(!s->chroma_x_shift){//Chroma444\n                    s->idsp.idct_put(dest_cb + act_block_size,              dct_linesize, (int16_t*)(*s->block32)[8]);\n                    s->idsp.idct_put(dest_cr + act_block_size,              dct_linesize, (int16_t*)(*s->block32)[9]);\n                    s->idsp.idct_put(dest_cb + act_block_size + dct_offset, dct_linesize, (int16_t*)(*s->block32)[10]);\n                    s->idsp.idct_put(dest_cr + act_block_size + dct_offset, dct_linesize, (int16_t*)(*s->block32)[11]);\n                }\n            }\n            /* dct only in intra block */\n            else if(s->encoding || !(s->codec_id==AV_CODEC_ID_MPEG1VIDEO || s->codec_id==AV_CODEC_ID_MPEG2VIDEO)){\n                put_dct(s, block[0], 0, dest_y                          , dct_linesize, s->qscale);\n                put_dct(s, block[1], 1, dest_y              + block_size, dct_linesize, s->qscale);\n                put_dct(s, block[2], 2, dest_y + dct_offset             , dct_linesize, s->qscale);\n                put_dct(s, block[3], 3, dest_y + dct_offset + block_size, dct_linesize, s->qscale);\n\n                if (!CONFIG_GRAY || !(s->avctx->flags & AV_CODEC_FLAG_GRAY)) {\n                    if(s->chroma_y_shift){\n                        put_dct(s, block[4], 4, dest_cb, uvlinesize, s->chroma_qscale);\n                        put_dct(s, block[5], 5, dest_cr, uvlinesize, s->chroma_qscale);\n                    }else{\n                        dct_offset >>=1;\n                        dct_linesize >>=1;\n                        put_dct(s, block[4], 4, dest_cb,              dct_linesize, s->chroma_qscale);\n                        put_dct(s, block[5], 5, dest_cr,              dct_linesize, s->chroma_qscale);\n                        put_dct(s, block[6], 6, dest_cb + dct_offset, dct_linesize, s->chroma_qscale);\n                        put_dct(s, block[7], 7, dest_cr + dct_offset, dct_linesize, s->chroma_qscale);\n                    }\n                }\n            }else{\n                s->idsp.idct_put(dest_y,                           dct_linesize, block[0]);\n                s->idsp.idct_put(dest_y              + block_size, dct_linesize, block[1]);\n                s->idsp.idct_put(dest_y + dct_offset,              dct_linesize, block[2]);\n                s->idsp.idct_put(dest_y + dct_offset + block_size, dct_linesize, block[3]);\n\n                if (!CONFIG_GRAY || !(s->avctx->flags & AV_CODEC_FLAG_GRAY)) {\n                    if(s->chroma_y_shift){\n                        s->idsp.idct_put(dest_cb, uvlinesize, block[4]);\n                        s->idsp.idct_put(dest_cr, uvlinesize, block[5]);\n                    }else{\n\n                        dct_linesize = uvlinesize << s->interlaced_dct;\n                        dct_offset   = s->interlaced_dct ? uvlinesize : uvlinesize*block_size;\n\n                        s->idsp.idct_put(dest_cb,              dct_linesize, block[4]);\n                        s->idsp.idct_put(dest_cr,              dct_linesize, block[5]);\n                        s->idsp.idct_put(dest_cb + dct_offset, dct_linesize, block[6]);\n                        s->idsp.idct_put(dest_cr + dct_offset, dct_linesize, block[7]);\n                        if(!s->chroma_x_shift){//Chroma444\n                            s->idsp.idct_put(dest_cb + block_size,              dct_linesize, block[8]);\n                            s->idsp.idct_put(dest_cr + block_size,              dct_linesize, block[9]);\n                            s->idsp.idct_put(dest_cb + block_size + dct_offset, dct_linesize, block[10]);\n                            s->idsp.idct_put(dest_cr + block_size + dct_offset, dct_linesize, block[11]);\n                        }\n                    }\n                }//gray\n            }\n        }\nskip_idct:\n        if(!readable){\n            s->hdsp.put_pixels_tab[0][0](s->dest[0], dest_y ,   linesize,16);\n            if (!CONFIG_GRAY || !(s->avctx->flags & AV_CODEC_FLAG_GRAY)) {\n                s->hdsp.put_pixels_tab[s->chroma_x_shift][0](s->dest[1], dest_cb, uvlinesize,16 >> s->chroma_y_shift);\n                s->hdsp.put_pixels_tab[s->chroma_x_shift][0](s->dest[2], dest_cr, uvlinesize,16 >> s->chroma_y_shift);\n            }\n        }\n    }\n}\n\nvoid ff_mpv_reconstruct_mb(MpegEncContext *s, int16_t block[12][64])\n{\n#if !CONFIG_SMALL\n    if(s->out_format == FMT_MPEG1) {\n        if(s->avctx->lowres) mpv_reconstruct_mb_internal(s, block, 1, 1);\n        else                 mpv_reconstruct_mb_internal(s, block, 0, 1);\n    } else\n#endif\n    if(s->avctx->lowres) mpv_reconstruct_mb_internal(s, block, 1, 0);\n    else                  mpv_reconstruct_mb_internal(s, block, 0, 0);\n}\n\nvoid ff_mpeg_draw_horiz_band(MpegEncContext *s, int y, int h)\n{\n    ff_draw_horiz_band(s->avctx, s->current_picture_ptr->f,\n                       s->last_picture_ptr ? s->last_picture_ptr->f : NULL, y, h, s->picture_structure,\n                       s->first_field, s->low_delay);\n}\n\nvoid ff_init_block_index(MpegEncContext *s){ //FIXME maybe rename\n    const int linesize   = s->current_picture.f->linesize[0]; //not s->linesize as this would be wrong for field pics\n    const int uvlinesize = s->current_picture.f->linesize[1];\n    const int width_of_mb = (4 + (s->avctx->bits_per_raw_sample > 8)) - s->avctx->lowres;\n    const int height_of_mb = 4 - s->avctx->lowres;\n\n    s->block_index[0]= s->b8_stride*(s->mb_y*2    ) - 2 + s->mb_x*2;\n    s->block_index[1]= s->b8_stride*(s->mb_y*2    ) - 1 + s->mb_x*2;\n    s->block_index[2]= s->b8_stride*(s->mb_y*2 + 1) - 2 + s->mb_x*2;\n    s->block_index[3]= s->b8_stride*(s->mb_y*2 + 1) - 1 + s->mb_x*2;\n    s->block_index[4]= s->mb_stride*(s->mb_y + 1)                + s->b8_stride*s->mb_height*2 + s->mb_x - 1;\n    s->block_index[5]= s->mb_stride*(s->mb_y + s->mb_height + 2) + s->b8_stride*s->mb_height*2 + s->mb_x - 1;\n    //block_index is not used by mpeg2, so it is not affected by chroma_format\n\n    s->dest[0] = s->current_picture.f->data[0] + (int)((s->mb_x - 1U) <<  width_of_mb);\n    s->dest[1] = s->current_picture.f->data[1] + (int)((s->mb_x - 1U) << (width_of_mb - s->chroma_x_shift));\n    s->dest[2] = s->current_picture.f->data[2] + (int)((s->mb_x - 1U) << (width_of_mb - s->chroma_x_shift));\n\n    if(!(s->pict_type==AV_PICTURE_TYPE_B && s->avctx->draw_horiz_band && s->picture_structure==PICT_FRAME))\n    {\n        if(s->picture_structure==PICT_FRAME){\n        s->dest[0] += s->mb_y *   linesize << height_of_mb;\n        s->dest[1] += s->mb_y * uvlinesize << (height_of_mb - s->chroma_y_shift);\n        s->dest[2] += s->mb_y * uvlinesize << (height_of_mb - s->chroma_y_shift);\n        }else{\n            s->dest[0] += (s->mb_y>>1) *   linesize << height_of_mb;\n            s->dest[1] += (s->mb_y>>1) * uvlinesize << (height_of_mb - s->chroma_y_shift);\n            s->dest[2] += (s->mb_y>>1) * uvlinesize << (height_of_mb - s->chroma_y_shift);\n            av_assert1((s->mb_y&1) == (s->picture_structure == PICT_BOTTOM_FIELD));\n        }\n    }\n}\n\nvoid ff_mpeg_flush(AVCodecContext *avctx){\n    int i;\n    MpegEncContext *s = avctx->priv_data;\n\n    if (!s || !s->picture)\n        return;\n\n    for (i = 0; i < MAX_PICTURE_COUNT; i++)\n        ff_mpeg_unref_picture(s->avctx, &s->picture[i]);\n    s->current_picture_ptr = s->last_picture_ptr = s->next_picture_ptr = NULL;\n\n    ff_mpeg_unref_picture(s->avctx, &s->current_picture);\n    ff_mpeg_unref_picture(s->avctx, &s->last_picture);\n    ff_mpeg_unref_picture(s->avctx, &s->next_picture);\n\n    s->mb_x= s->mb_y= 0;\n    s->closed_gop= 0;\n\n    s->parse_context.state= -1;\n    s->parse_context.frame_start_found= 0;\n    s->parse_context.overread= 0;\n    s->parse_context.overread_index= 0;\n    s->parse_context.index= 0;\n    s->parse_context.last_index= 0;\n    s->bitstream_buffer_size=0;\n    s->pp_time=0;\n}\n\n/**\n * set qscale and update qscale dependent variables.\n */\nvoid ff_set_qscale(MpegEncContext * s, int qscale)\n{\n    if (qscale < 1)\n        qscale = 1;\n    else if (qscale > 31)\n        qscale = 31;\n\n    s->qscale = qscale;\n    s->chroma_qscale= s->chroma_qscale_table[qscale];\n\n    s->y_dc_scale= s->y_dc_scale_table[ qscale ];\n    s->c_dc_scale= s->c_dc_scale_table[ s->chroma_qscale ];\n}\n\nvoid ff_mpv_report_decode_progress(MpegEncContext *s)\n{\n    if (s->pict_type != AV_PICTURE_TYPE_B && !s->partitioned_frame && !s->er.error_occurred)\n        ff_thread_report_progress(&s->current_picture_ptr->tf, s->mb_y, 0);\n}\n"], "filenames": ["libavcodec/idctdsp.c", "libavcodec/idctdsp.h", "libavcodec/mpegvideo.c"], "buggy_code_start_loc": [261, 97, 331], "buggy_code_end_loc": [262, 97, 331], "fixing_code_start_loc": [261, 98, 332], "fixing_code_end_loc": [262, 100, 334], "type": "CWE-476", "message": "libavcodec in FFmpeg 4.0 may trigger a NULL pointer dereference if the studio profile is incorrectly detected while converting a crafted AVI file to MPEG4, leading to a denial of service, related to idctdsp.c and mpegvideo.c.", "other": {"cve": {"id": "CVE-2018-12460", "sourceIdentifier": "cve@mitre.org", "published": "2018-06-15T15:29:00.327", "lastModified": "2018-08-02T15:10:10.830", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "libavcodec in FFmpeg 4.0 may trigger a NULL pointer dereference if the studio profile is incorrectly detected while converting a crafted AVI file to MPEG4, leading to a denial of service, related to idctdsp.c and mpegvideo.c."}, {"lang": "es", "value": "libavcodec en FFmpeg 4.0 podr\u00eda desencadenar una desreferencia de puntero NULL si el perfil studio se detecta de forma incorrecta al convertir un archivo AVI manipulado a MPEG4, lo que conduce a una denegaci\u00f3n de servicio (DoS). Esto est\u00e1 relacionado con idctdsp.c y mpegvideo.c."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:4.0:*:*:*:*:*:*:*", "matchCriteriaId": "35169F84-5DDB-468A-9DB4-08CC657ABE8B"}]}]}], "references": [{"url": "https://github.com/FFmpeg/FFmpeg/commit/b3332a182f8ba33a34542e4a0370f38b914ccf7d", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/b3332a182f8ba33a34542e4a0370f38b914ccf7d"}}