{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *\n *  BlueZ - Bluetooth protocol stack for Linux\n *\n *  Copyright (C) 2006-2010  Nokia Corporation\n *  Copyright (C) 2004-2010  Marcel Holtmann <marcel@holtmann.org>\n *\n *\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#define _GNU_SOURCE\n#include <stdio.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/stat.h>\n#include <dirent.h>\n\n#include <glib.h>\n#include <dbus/dbus.h>\n\n#include \"bluetooth/bluetooth.h\"\n#include \"bluetooth/hci.h\"\n#include \"bluetooth/hci_lib.h\"\n#include \"bluetooth/sdp.h\"\n#include \"bluetooth/sdp_lib.h\"\n#include \"lib/uuid.h\"\n#include \"lib/mgmt.h\"\n\n#include \"gdbus/gdbus.h\"\n\n#include \"log.h\"\n#include \"textfile.h\"\n\n#include \"src/shared/mgmt.h\"\n#include \"src/shared/util.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/att.h\"\n#include \"src/shared/gatt-db.h\"\n#include \"src/shared/timeout.h\"\n\n#include \"btio/btio.h\"\n#include \"btd.h\"\n#include \"sdpd.h\"\n#include \"adapter.h\"\n#include \"device.h\"\n#include \"profile.h\"\n#include \"dbus-common.h\"\n#include \"error.h\"\n#include \"uuid-helper.h\"\n#include \"agent.h\"\n#include \"storage.h\"\n#include \"attrib/gattrib.h\"\n#include \"attrib/att.h\"\n#include \"attrib/gatt.h\"\n#include \"attrib-server.h\"\n#include \"gatt-database.h\"\n#include \"advertising.h\"\n#include \"adv_monitor.h\"\n#include \"eir.h\"\n#include \"battery.h\"\n\n#define MODE_OFF\t\t0x00\n#define MODE_CONNECTABLE\t0x01\n#define MODE_DISCOVERABLE\t0x02\n#define MODE_UNKNOWN\t\t0xff\n\n#define CONN_SCAN_TIMEOUT (3)\n#define IDLE_DISCOV_TIMEOUT (5)\n#define TEMP_DEV_TIMEOUT (3 * 60)\n#define BONDING_TIMEOUT (2 * 60)\n\n#define SCAN_TYPE_BREDR (1 << BDADDR_BREDR)\n#define SCAN_TYPE_LE ((1 << BDADDR_LE_PUBLIC) | (1 << BDADDR_LE_RANDOM))\n#define SCAN_TYPE_DUAL (SCAN_TYPE_BREDR | SCAN_TYPE_LE)\n\n#define HCI_RSSI_INVALID\t127\n#define DISTANCE_VAL_INVALID\t0x7FFF\n#define PATHLOSS_MAX\t\t137\n\n/*\n * These are known security keys that have been compromised.\n * If this grows or there are needs to be platform specific, it is\n * conceivable that these could be read from a config file.\n */\nstatic const struct mgmt_blocked_key_info blocked_keys[] = {\n\t/* Google Titan Security Keys */\n\t{ HCI_BLOCKED_KEY_TYPE_LTK,\n\t\t{0xbf, 0x01, 0xfb, 0x9d, 0x4e, 0xf3, 0xbc, 0x36,\n\t\t 0xd8, 0x74, 0xf5, 0x39, 0x41, 0x38, 0x68, 0x4c}},\n\t{ HCI_BLOCKED_KEY_TYPE_IRK,\n\t\t{0xa5, 0x99, 0xba, 0xe4, 0xe1, 0x7c, 0xa6, 0x18,\n\t\t 0x22, 0x8e, 0x07, 0x56, 0xb4, 0xe8, 0x5f, 0x01}},\n};\n\nstatic DBusConnection *dbus_conn = NULL;\n\nstatic uint32_t kernel_features = 0;\n\nstatic GList *adapter_list = NULL;\nstatic unsigned int adapter_remaining = 0;\nstatic bool powering_down = false;\n\nstatic GSList *adapters = NULL;\n\nstatic struct mgmt *mgmt_master = NULL;\n\nstatic uint8_t mgmt_version = 0;\nstatic uint8_t mgmt_revision = 0;\n\nstatic GSList *adapter_drivers = NULL;\n\nstatic GSList *disconnect_list = NULL;\nstatic GSList *conn_fail_list = NULL;\n\nstruct link_key_info {\n\tbdaddr_t bdaddr;\n\tunsigned char key[16];\n\tuint8_t type;\n\tuint8_t pin_len;\n\tbool is_blocked;\n};\n\nstruct smp_ltk_info {\n\tbdaddr_t bdaddr;\n\tuint8_t bdaddr_type;\n\tuint8_t authenticated;\n\tbool master;\n\tuint8_t enc_size;\n\tuint16_t ediv;\n\tuint64_t rand;\n\tuint8_t val[16];\n\tbool is_blocked;\n};\n\nstruct irk_info {\n\tbdaddr_t bdaddr;\n\tuint8_t bdaddr_type;\n\tuint8_t val[16];\n\tbool is_blocked;\n};\n\nstruct conn_param {\n\tbdaddr_t bdaddr;\n\tuint8_t  bdaddr_type;\n\tuint16_t min_interval;\n\tuint16_t max_interval;\n\tuint16_t latency;\n\tuint16_t timeout;\n};\n\nstruct discovery_filter {\n\tuint8_t type;\n\tchar *pattern;\n\tuint16_t pathloss;\n\tint16_t rssi;\n\tGSList *uuids;\n\tbool duplicate;\n\tbool discoverable;\n};\n\nstruct discovery_client {\n\tstruct btd_adapter *adapter;\n\tDBusMessage *msg;\n\tchar *owner;\n\tguint watch;\n\tstruct discovery_filter *discovery_filter;\n};\n\nstruct service_auth {\n\tguint id;\n\tunsigned int svc_id;\n\tservice_auth_cb cb;\n\tvoid *user_data;\n\tconst char *uuid;\n\tstruct btd_device *device;\n\tstruct btd_adapter *adapter;\n\tstruct agent *agent;\t\t/* NULL for queued auths */\n};\n\nstruct btd_adapter_pin_cb_iter {\n\tGSList *it;\t\t\t/* current callback function */\n\tunsigned int attempt;\t\t/* numer of times it() was called */\n\t/* When the iterator reaches the end, it is NULL and attempt is 0 */\n};\n\nstruct btd_adapter {\n\tint ref_count;\n\n\tuint16_t dev_id;\n\tstruct mgmt *mgmt;\n\n\tbdaddr_t bdaddr;\t\t/* controller Bluetooth address */\n\tuint8_t bdaddr_type;\t\t/* address type */\n\tuint32_t dev_class;\t\t/* controller class of device */\n\tchar *name;\t\t\t/* controller device name */\n\tchar *short_name;\t\t/* controller short name */\n\tuint32_t supported_settings;\t/* controller supported settings */\n\tuint32_t pending_settings;\t/* pending controller settings */\n\tuint32_t current_settings;\t/* current controller settings */\n\n\tchar *path;\t\t\t/* adapter object path */\n\tuint16_t manufacturer;\t\t/* adapter manufacturer */\n\tuint8_t major_class;\t\t/* configured major class */\n\tuint8_t minor_class;\t\t/* configured minor class */\n\tchar *system_name;\t\t/* configured system name */\n\tchar *modalias;\t\t\t/* device id (modalias) */\n\tbool stored_discoverable;\t/* stored discoverable mode */\n\tuint32_t discoverable_timeout;\t/* discoverable time(sec) */\n\tuint32_t pairable_timeout;\t/* pairable time(sec) */\n\n\tchar *current_alias;\t\t/* current adapter name alias */\n\tchar *stored_alias;\t\t/* stored adapter name alias */\n\n\tbool discovering;\t\t/* discovering property state */\n\tbool filtered_discovery;\t/* we are doing filtered discovery */\n\tbool no_scan_restart_delay;\t/* when this flag is set, restart scan\n\t\t\t\t\t * without delay */\n\tuint8_t discovery_type;\t\t/* current active discovery type */\n\tuint8_t discovery_enable;\t/* discovery enabled/disabled */\n\tbool discovery_suspended;\t/* discovery has been suspended */\n\tbool discovery_discoverable;\t/* discoverable while discovering */\n\tGSList *discovery_list;\t\t/* list of discovery clients */\n\tGSList *set_filter_list;\t/* list of clients that specified\n\t\t\t\t\t * filter, but don't scan yet\n\t\t\t\t\t */\n\t/* current discovery filter, if any */\n\tstruct mgmt_cp_start_service_discovery *current_discovery_filter;\n\tstruct discovery_client *client;\t/* active discovery client */\n\n\tGSList *discovery_found;\t/* list of found devices */\n\tunsigned int discovery_idle_timeout; /* timeout between discovery\n\t\t\t\t\t      * runs\n\t\t\t\t\t      */\n\tunsigned int passive_scan_timeout; /* timeout between passive scans */\n\n\tunsigned int pairable_timeout_id;\t/* pairable timeout id */\n\tguint auth_idle_id;\t\t/* Pending authorization dequeue */\n\tGQueue *auths;\t\t\t/* Ongoing and pending auths */\n\tbool pincode_requested;\t\t/* PIN requested during last bonding */\n\tGSList *connections;\t\t/* Connected devices */\n\tGSList *devices;\t\t/* Devices structure pointers */\n\tGSList *connect_list;\t\t/* Devices to connect when found */\n\tstruct btd_device *connect_le;\t/* LE device waiting to be connected */\n\tsdp_list_t *services;\t\t/* Services associated to adapter */\n\n\tstruct btd_gatt_database *database;\n\tstruct btd_adv_manager *adv_manager;\n\n\tstruct btd_adv_monitor_manager *adv_monitor_manager;\n\n\tstruct btd_battery_provider_manager *battery_provider_manager;\n\n\tgboolean initialized;\n\n\tGSList *pin_callbacks;\n\tGSList *msd_callbacks;\n\n\tGSList *drivers;\n\tGSList *profiles;\n\n\tstruct oob_handler *oob_handler;\n\n\tunsigned int load_ltks_id;\n\tunsigned int load_ltks_timeout;\n\n\tunsigned int confirm_name_id;\n\tunsigned int confirm_name_timeout;\n\n\tunsigned int pair_device_id;\n\tunsigned int pair_device_timeout;\n\n\tunsigned int db_id;\t\t/* Service event handler for GATT db */\n\n\tbool is_default;\t\t/* true if adapter is default one */\n\n\tbool le_simult_roles_supported;\n\tbool quality_report_supported;\n};\n\ntypedef enum {\n\tADAPTER_AUTHORIZE_DISCONNECTED = 0,\n\tADAPTER_AUTHORIZE_CHECK_CONNECTED\n} adapter_authorize_type;\n\nstatic struct btd_adapter *btd_adapter_lookup(uint16_t index)\n{\n\tGList *list;\n\n\tfor (list = g_list_first(adapter_list); list;\n\t\t\t\t\t\tlist = g_list_next(list)) {\n\t\tstruct btd_adapter *adapter = list->data;\n\n\t\tif (adapter->dev_id == index)\n\t\t\treturn adapter;\n\t}\n\n\treturn NULL;\n}\n\nstruct btd_adapter *btd_adapter_get_default(void)\n{\n\tGList *list;\n\n\tfor (list = g_list_first(adapter_list); list;\n\t\t\t\t\t\tlist = g_list_next(list)) {\n\t\tstruct btd_adapter *adapter = list->data;\n\n\t\tif (adapter->is_default)\n\t\t\treturn adapter;\n\t}\n\n\treturn NULL;\n}\n\nbool btd_adapter_is_default(struct btd_adapter *adapter)\n{\n\tif (!adapter)\n\t\treturn false;\n\n\treturn adapter->is_default;\n}\n\nuint16_t btd_adapter_get_index(struct btd_adapter *adapter)\n{\n\tif (!adapter)\n\t\treturn MGMT_INDEX_NONE;\n\n\treturn adapter->dev_id;\n}\n\nstatic gboolean process_auth_queue(gpointer user_data);\n\nstatic void dev_class_changed_callback(uint16_t index, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tconst struct mgmt_cod *rp = param;\n\tuint32_t dev_class;\n\n\tif (length < sizeof(*rp)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\"Wrong size of class of device changed parameters\");\n\t\treturn;\n\t}\n\n\tdev_class = rp->val[0] | (rp->val[1] << 8) | (rp->val[2] << 16);\n\n\tif (dev_class == adapter->dev_class)\n\t\treturn;\n\n\tDBG(\"Class: 0x%06x\", dev_class);\n\n\tadapter->dev_class = dev_class;\n\n\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\t\tADAPTER_INTERFACE, \"Class\");\n}\n\nstatic void set_dev_class_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Failed to set device class: %s (0x%02x)\",\n\t\t\t\t\t\tmgmt_errstr(status), status);\n\t\treturn;\n\t}\n\n\t/*\n\t * The parameters are identical and also the task that is\n\t * required in both cases. So it is safe to just call the\n\t * event handling functions here.\n\t */\n\tdev_class_changed_callback(adapter->dev_id, length, param, adapter);\n}\n\nstatic void set_dev_class(struct btd_adapter *adapter)\n{\n\tstruct mgmt_cp_set_dev_class cp;\n\n\t/*\n\t * If the controller does not support BR/EDR operation,\n\t * there is no point in trying to set a major and minor\n\t * class value.\n\t *\n\t * This is an optimization for Low Energy only controllers.\n\t */\n\tif (!(adapter->supported_settings & MGMT_SETTING_BREDR))\n\t\treturn;\n\n\tmemset(&cp, 0, sizeof(cp));\n\n\t/*\n\t * Silly workaround for a really stupid kernel bug :(\n\t *\n\t * All current kernel versions assign the major and minor numbers\n\t * straight to dev_class[0] and dev_class[1] without considering\n\t * the proper bit shifting.\n\t *\n\t * To make this work, shift the value in userspace for now until\n\t * we get a fixed kernel version.\n\t */\n\tcp.major = adapter->major_class & 0x1f;\n\tcp.minor = adapter->minor_class << 2;\n\n\tDBG(\"sending set device class command for index %u\", adapter->dev_id);\n\n\tif (mgmt_send(adapter->mgmt, MGMT_OP_SET_DEV_CLASS,\n\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\tset_dev_class_complete, adapter, NULL) > 0)\n\t\treturn;\n\n\tbtd_error(adapter->dev_id,\n\t\t\"Failed to set class of device for index %u\", adapter->dev_id);\n}\n\nvoid btd_adapter_set_class(struct btd_adapter *adapter, uint8_t major,\n\t\t\t\t\t\t\tuint8_t minor)\n{\n\tif (adapter->major_class == major && adapter->minor_class == minor)\n\t\treturn;\n\n\tDBG(\"class: major %u minor %u\", major, minor);\n\n\tadapter->major_class = major;\n\tadapter->minor_class = minor;\n\n\tset_dev_class(adapter);\n}\n\nstatic uint8_t get_mode(const char *mode)\n{\n\tif (strcasecmp(\"off\", mode) == 0)\n\t\treturn MODE_OFF;\n\telse if (strcasecmp(\"connectable\", mode) == 0)\n\t\treturn MODE_CONNECTABLE;\n\telse if (strcasecmp(\"discoverable\", mode) == 0)\n\t\treturn MODE_DISCOVERABLE;\n\telse\n\t\treturn MODE_UNKNOWN;\n}\n\nconst char *btd_adapter_get_storage_dir(struct btd_adapter *adapter)\n{\n\tstatic char dir[25];\n\n\tif (adapter->bdaddr_type == BDADDR_LE_RANDOM) {\n\t\tstrcpy(dir, \"static-\");\n\t\tba2str(&adapter->bdaddr, dir + 7);\n\t} else {\n\t\tba2str(&adapter->bdaddr, dir);\n\t}\n\n\treturn dir;\n}\n\nuint8_t btd_adapter_get_address_type(struct btd_adapter *adapter)\n{\n\treturn adapter->bdaddr_type;\n}\n\nstatic void store_adapter_info(struct btd_adapter *adapter)\n{\n\tGKeyFile *key_file;\n\tchar filename[PATH_MAX];\n\tchar *str;\n\tgsize length = 0;\n\tgboolean discoverable;\n\n\tkey_file = g_key_file_new();\n\n\tif (adapter->pairable_timeout != btd_opts.pairto)\n\t\tg_key_file_set_integer(key_file, \"General\", \"PairableTimeout\",\n\t\t\t\t\tadapter->pairable_timeout);\n\n\tif ((adapter->current_settings & MGMT_SETTING_DISCOVERABLE) &&\n\t\t\t\t\t\t!adapter->discoverable_timeout)\n\t\tdiscoverable = TRUE;\n\telse\n\t\tdiscoverable = FALSE;\n\n\tg_key_file_set_boolean(key_file, \"General\", \"Discoverable\",\n\t\t\t\t\t\t\tdiscoverable);\n\n\tif (adapter->discoverable_timeout != btd_opts.discovto)\n\t\tg_key_file_set_integer(key_file, \"General\",\n\t\t\t\t\t\"DiscoverableTimeout\",\n\t\t\t\t\tadapter->discoverable_timeout);\n\n\tif (adapter->stored_alias)\n\t\tg_key_file_set_string(key_file, \"General\", \"Alias\",\n\t\t\t\t\t\t\tadapter->stored_alias);\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/settings\",\n\t\t\t\t\tbtd_adapter_get_storage_dir(adapter));\n\n\tcreate_file(filename, 0600);\n\n\tstr = g_key_file_to_data(key_file, &length, NULL);\n\tg_file_set_contents(filename, str, length, NULL);\n\tg_free(str);\n\n\tg_key_file_free(key_file);\n}\n\nstatic void trigger_pairable_timeout(struct btd_adapter *adapter);\nstatic void adapter_start(struct btd_adapter *adapter);\nstatic void adapter_stop(struct btd_adapter *adapter);\nstatic void trigger_passive_scanning(struct btd_adapter *adapter);\nstatic bool set_mode(struct btd_adapter *adapter, uint16_t opcode,\n\t\t\t\t\t\t\tuint8_t mode);\n\nstatic void settings_changed(struct btd_adapter *adapter, uint32_t settings)\n{\n\tuint32_t changed_mask;\n\n\tchanged_mask = adapter->current_settings ^ settings;\n\n\tadapter->current_settings = settings;\n\tadapter->pending_settings &= ~changed_mask;\n\n\tDBG(\"Changed settings: 0x%08x\", changed_mask);\n\tDBG(\"Pending settings: 0x%08x\", adapter->pending_settings);\n\n\tif (changed_mask & MGMT_SETTING_POWERED) {\n\t        g_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Powered\");\n\n\t\tif (adapter->current_settings & MGMT_SETTING_POWERED) {\n\t\t\tadapter_start(adapter);\n\t\t} else {\n\t\t\tadapter_stop(adapter);\n\n\t\t\tif (powering_down) {\n\t\t\t\tadapter_remaining--;\n\n\t\t\t\tif (!adapter_remaining)\n\t\t\t\t\tbtd_exit();\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((changed_mask & MGMT_SETTING_LE) &&\n\t\t\t\tbtd_adapter_get_powered(adapter) &&\n\t\t\t\t(adapter->current_settings & MGMT_SETTING_LE))\n\t\ttrigger_passive_scanning(adapter);\n\n\tif (changed_mask & MGMT_SETTING_DISCOVERABLE) {\n\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Discoverable\");\n\t\tstore_adapter_info(adapter);\n\t\tbtd_adv_manager_refresh(adapter->adv_manager);\n\t}\n\n\tif (changed_mask & MGMT_SETTING_BONDABLE) {\n\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Pairable\");\n\n\t\ttrigger_pairable_timeout(adapter);\n\t}\n}\n\nstatic void new_settings_callback(uint16_t index, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tuint32_t settings;\n\n\tif (length < sizeof(settings)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Wrong size of new settings parameters\");\n\t\treturn;\n\t}\n\n\tsettings = get_le32(param);\n\n\tif (settings == adapter->current_settings)\n\t\treturn;\n\n\tDBG(\"Settings: 0x%08x\", settings);\n\n\tsettings_changed(adapter, settings);\n}\n\nstatic void set_mode_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\tbtd_error(adapter->dev_id, \"Failed to set mode: %s (0x%02x)\",\n\t\t\t\t\t\tmgmt_errstr(status), status);\n\t\treturn;\n\t}\n\n\t/*\n\t * The parameters are identical and also the task that is\n\t * required in both cases. So it is safe to just call the\n\t * event handling functions here.\n\t */\n\tnew_settings_callback(adapter->dev_id, length, param, adapter);\n}\n\nstatic void remove_temporary_devices(struct btd_adapter *adapter)\n{\n\tGSList *l, *next;\n\n\tfor (l = adapter->devices; l; l = next) {\n\t\tstruct btd_device *dev = l->data;\n\n\t\tnext = g_slist_next(l);\n\t\tif (device_is_temporary(dev))\n\t\t\tbtd_adapter_remove_device(adapter, dev);\n\t}\n}\n\nstatic bool set_mode(struct btd_adapter *adapter, uint16_t opcode,\n\t\t\t\t\t\t\tuint8_t mode)\n{\n\tstruct mgmt_mode cp;\n\tuint32_t setting = 0;\n\n\tmemset(&cp, 0, sizeof(cp));\n\tcp.val = mode;\n\n\tswitch (opcode) {\n\tcase MGMT_OP_SET_POWERED:\n\t\tsetting = MGMT_SETTING_POWERED;\n\t\tbreak;\n\tcase MGMT_OP_SET_CONNECTABLE:\n\t\tsetting = MGMT_SETTING_CONNECTABLE;\n\t\tbreak;\n\tcase MGMT_OP_SET_FAST_CONNECTABLE:\n\t\tsetting = MGMT_SETTING_FAST_CONNECTABLE;\n\t\tbreak;\n\tcase MGMT_OP_SET_DISCOVERABLE:\n\t\tsetting = MGMT_SETTING_DISCOVERABLE;\n\t\tbreak;\n\tcase MGMT_OP_SET_BONDABLE:\n\t\tsetting = MGMT_SETTING_BONDABLE;\n\t\tbreak;\n\t}\n\n\tadapter->pending_settings |= setting;\n\n\tDBG(\"sending set mode command for index %u\", adapter->dev_id);\n\n\tif (mgmt_send(adapter->mgmt, opcode,\n\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\tset_mode_complete, adapter, NULL) > 0)\n\t\treturn true;\n\n\tbtd_error(adapter->dev_id, \"Failed to set mode for index %u\",\n\t\t\t\t\t\t\tadapter->dev_id);\n\n\treturn false;\n}\n\nstatic bool set_discoverable(struct btd_adapter *adapter, uint8_t mode,\n\t\t\t\t\t\t\tuint16_t timeout)\n{\n\tstruct mgmt_cp_set_discoverable cp;\n\n\tmemset(&cp, 0, sizeof(cp));\n\tcp.val = mode;\n\tcp.timeout = htobs(timeout);\n\n\tDBG(\"sending set mode command for index %u\", adapter->dev_id);\n\n\tif (btd_has_kernel_features(KERNEL_CONN_CONTROL)) {\n\t\tif (mode)\n\t\t\tset_mode(adapter, MGMT_OP_SET_CONNECTABLE, mode);\n\t\telse\n\t\t\t/* This also disables discoverable so we're done */\n\t\t\treturn set_mode(adapter, MGMT_OP_SET_CONNECTABLE,\n\t\t\t\t\t\t\t\t\tmode);\n\t}\n\n\tif (mgmt_send(adapter->mgmt, MGMT_OP_SET_DISCOVERABLE,\n\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\tset_mode_complete, adapter, NULL) > 0)\n\t\treturn true;\n\n\tbtd_error(adapter->dev_id, \"Failed to set mode for index %u\",\n\t\t\t\t\t\t\tadapter->dev_id);\n\n\treturn false;\n}\n\nstatic bool pairable_timeout_handler(gpointer user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\tadapter->pairable_timeout_id = 0;\n\n\tset_mode(adapter, MGMT_OP_SET_BONDABLE, 0x00);\n\n\treturn FALSE;\n}\n\nstatic void trigger_pairable_timeout(struct btd_adapter *adapter)\n{\n\tif (adapter->pairable_timeout_id > 0) {\n\t\ttimeout_remove(adapter->pairable_timeout_id);\n\t\tadapter->pairable_timeout_id = 0;\n\t}\n\n\tif (!(adapter->current_settings & MGMT_SETTING_BONDABLE))\n\t\treturn;\n\n\tif (adapter->pairable_timeout > 0)\n\t\tadapter->pairable_timeout_id =\n\t\t\ttimeout_add_seconds(adapter->pairable_timeout,\n\t\t\t\t\tpairable_timeout_handler, adapter,\n\t\t\t\t\tNULL);\n}\n\nstatic void local_name_changed_callback(uint16_t index, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tconst struct mgmt_cp_set_local_name *rp = param;\n\n\tif (length < sizeof(*rp)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Wrong size of local name changed parameters\");\n\t\treturn;\n\t}\n\n\tif (!g_strcmp0(adapter->short_name, (const char *) rp->short_name) &&\n\t\t\t!g_strcmp0(adapter->name, (const char *) rp->name))\n\t\treturn;\n\n\tDBG(\"Name: %s\", rp->name);\n\tDBG(\"Short name: %s\", rp->short_name);\n\n\tg_free(adapter->name);\n\tadapter->name = g_strdup((const char *) rp->name);\n\n\tg_free(adapter->short_name);\n\tadapter->short_name = g_strdup((const char *) rp->short_name);\n\n\t/*\n\t * Changing the name (even manually via HCI) will update the\n\t * current alias property.\n\t *\n\t * In case the name is empty, use the short name.\n\t *\n\t * There is a difference between the stored alias (which is\n\t * configured by the user) and the current alias. The current\n\t * alias is temporary for the lifetime of the daemon.\n\t */\n\tif (adapter->name && adapter->name[0] != '\\0') {\n\t\tg_free(adapter->current_alias);\n\t\tadapter->current_alias = g_strdup(adapter->name);\n\t} else {\n\t\tg_free(adapter->current_alias);\n\t\tadapter->current_alias = g_strdup(adapter->short_name);\n\t}\n\n\tDBG(\"Current alias: %s\", adapter->current_alias);\n\n\tif (!adapter->current_alias)\n\t\treturn;\n\n\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\t\tADAPTER_INTERFACE, \"Alias\");\n\n\tattrib_gap_set(adapter, GATT_CHARAC_DEVICE_NAME,\n\t\t\t\t(const uint8_t *) adapter->current_alias,\n\t\t\t\t\tstrlen(adapter->current_alias));\n}\n\nstatic void set_local_name_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Failed to set local name: %s (0x%02x)\",\n\t\t\t\t\t\tmgmt_errstr(status), status);\n\t\treturn;\n\t}\n\n\t/*\n\t * The parameters are identical and also the task that is\n\t * required in both cases. So it is safe to just call the\n\t * event handling functions here.\n\t */\n\tlocal_name_changed_callback(adapter->dev_id, length, param, adapter);\n}\n\nstatic int set_name(struct btd_adapter *adapter, const char *name)\n{\n\tstruct mgmt_cp_set_local_name cp;\n\tchar maxname[MAX_NAME_LENGTH];\n\n\tmemset(maxname, 0, sizeof(maxname));\n\tstrncpy(maxname, name, MAX_NAME_LENGTH - 1);\n\n\tif (!g_utf8_validate(maxname, -1, NULL)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\"Name change failed: supplied name isn't valid UTF-8\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(&cp, 0, sizeof(cp));\n\tstrncpy((char *) cp.name, maxname, sizeof(cp.name) - 1);\n\n\tDBG(\"sending set local name command for index %u\", adapter->dev_id);\n\n\tif (mgmt_send(adapter->mgmt, MGMT_OP_SET_LOCAL_NAME,\n\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\tset_local_name_complete, adapter, NULL) > 0)\n\t\treturn 0;\n\n\tbtd_error(adapter->dev_id, \"Failed to set local name for index %u\",\n\t\t\t\t\t\t\tadapter->dev_id);\n\n\treturn -EIO;\n}\n\nint adapter_set_name(struct btd_adapter *adapter, const char *name)\n{\n\tif (g_strcmp0(adapter->system_name, name) == 0)\n\t\treturn 0;\n\n\tDBG(\"name: %s\", name);\n\n\tg_free(adapter->system_name);\n\tadapter->system_name = g_strdup(name);\n\n\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\t\tADAPTER_INTERFACE, \"Name\");\n\n\t/* alias is preferred over system name */\n\tif (adapter->stored_alias)\n\t\treturn 0;\n\n\tDBG(\"alias: %s\", name);\n\n\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\t\tADAPTER_INTERFACE, \"Alias\");\n\n\treturn set_name(adapter, name);\n}\n\nstruct btd_device *btd_adapter_find_device(struct btd_adapter *adapter,\n\t\t\t\t\t\t\tconst bdaddr_t *dst,\n\t\t\t\t\t\t\tuint8_t bdaddr_type)\n{\n\tstruct device_addr_type addr;\n\tstruct btd_device *device;\n\tGSList *list;\n\n\tif (!adapter)\n\t\treturn NULL;\n\n\tbacpy(&addr.bdaddr, dst);\n\taddr.bdaddr_type = bdaddr_type;\n\n\tlist = g_slist_find_custom(adapter->devices, &addr,\n\t\t\t\t\t\t\tdevice_addr_type_cmp);\n\tif (!list)\n\t\treturn NULL;\n\n\tdevice = list->data;\n\n\t/*\n\t * If we're looking up based on public address and the address\n\t * was not previously used over this bearer we may need to\n\t * update LE or BR/EDR support information.\n\t */\n\tif (bdaddr_type == BDADDR_BREDR)\n\t\tdevice_set_bredr_support(device);\n\telse\n\t\tdevice_set_le_support(device, bdaddr_type);\n\n\treturn device;\n}\n\nstatic int device_path_cmp(gconstpointer a, gconstpointer b)\n{\n\tconst struct btd_device *device = a;\n\tconst char *path = b;\n\tconst char *dev_path = device_get_path(device);\n\n\treturn strcasecmp(dev_path, path);\n}\n\nstruct btd_device *btd_adapter_find_device_by_path(struct btd_adapter *adapter,\n\t\t\t\t\t\t   const char *path)\n{\n\tGSList *list;\n\n\tif (!adapter)\n\t\treturn NULL;\n\n\tlist = g_slist_find_custom(adapter->devices, path, device_path_cmp);\n\tif (!list)\n\t\treturn NULL;\n\n\treturn list->data;\n}\n\nstatic void uuid_to_uuid128(uuid_t *uuid128, const uuid_t *uuid)\n{\n\tif (uuid->type == SDP_UUID16)\n\t\tsdp_uuid16_to_uuid128(uuid128, uuid);\n\telse if (uuid->type == SDP_UUID32)\n\t\tsdp_uuid32_to_uuid128(uuid128, uuid);\n\telse\n\t\tmemcpy(uuid128, uuid, sizeof(*uuid));\n}\n\nstatic bool is_supported_uuid(const uuid_t *uuid)\n{\n\tuuid_t tmp;\n\n\t/* mgmt versions from 1.3 onwards support all types of UUIDs */\n\tif (MGMT_VERSION(mgmt_version, mgmt_revision) >= MGMT_VERSION(1, 3))\n\t\treturn true;\n\n\tuuid_to_uuid128(&tmp, uuid);\n\n\tif (!sdp_uuid128_to_uuid(&tmp))\n\t\treturn false;\n\n\tif (tmp.type != SDP_UUID16)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void add_uuid_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\tbtd_error(adapter->dev_id, \"Failed to add UUID: %s (0x%02x)\",\n\t\t\t\t\t\tmgmt_errstr(status), status);\n\t\treturn;\n\t}\n\n\t/*\n\t * The parameters are identical and also the task that is\n\t * required in both cases. So it is safe to just call the\n\t * event handling functions here.\n\t */\n\tdev_class_changed_callback(adapter->dev_id, length, param, adapter);\n\n\tif (adapter->initialized)\n\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\t\tADAPTER_INTERFACE, \"UUIDs\");\n}\n\nstatic int add_uuid(struct btd_adapter *adapter, uuid_t *uuid, uint8_t svc_hint)\n{\n\tstruct mgmt_cp_add_uuid cp;\n\tuuid_t uuid128;\n\tuint128_t uint128;\n\n\tif (!is_supported_uuid(uuid)) {\n\t\tbtd_warn(adapter->dev_id,\n\t\t\t\t\"Ignoring unsupported UUID for addition\");\n\t\treturn 0;\n\t}\n\n\tuuid_to_uuid128(&uuid128, uuid);\n\n\tntoh128((uint128_t *) uuid128.value.uuid128.data, &uint128);\n\thtob128(&uint128, (uint128_t *) cp.uuid);\n\tcp.svc_hint = svc_hint;\n\n\tDBG(\"sending add uuid command for index %u\", adapter->dev_id);\n\n\tif (mgmt_send(adapter->mgmt, MGMT_OP_ADD_UUID,\n\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\tadd_uuid_complete, adapter, NULL) > 0)\n\t\treturn 0;\n\n\tbtd_error(adapter->dev_id, \"Failed to add UUID for index %u\",\n\t\t\t\t\t\t\tadapter->dev_id);\n\n\treturn -EIO;\n}\n\nstatic void remove_uuid_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\tbtd_error(adapter->dev_id, \"Failed to remove UUID: %s (0x%02x)\",\n\t\t\t\t\t\tmgmt_errstr(status), status);\n\t\treturn;\n\t}\n\n\t/*\n\t * The parameters are identical and also the task that is\n\t * required in both cases. So it is safe to just call the\n\t * event handling functions here.\n\t */\n\tdev_class_changed_callback(adapter->dev_id, length, param, adapter);\n\n\tif (adapter->initialized)\n\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\t\tADAPTER_INTERFACE, \"UUIDs\");\n}\n\nstatic int remove_uuid(struct btd_adapter *adapter, uuid_t *uuid)\n{\n\tstruct mgmt_cp_remove_uuid cp;\n\tuuid_t uuid128;\n\tuint128_t uint128;\n\n\tif (!is_supported_uuid(uuid)) {\n\t\tbtd_warn(adapter->dev_id,\n\t\t\t\t\"Ignoring unsupported UUID for removal\");\n\t\treturn 0;\n\t}\n\n\tuuid_to_uuid128(&uuid128, uuid);\n\n\tntoh128((uint128_t *) uuid128.value.uuid128.data, &uint128);\n\thtob128(&uint128, (uint128_t *) cp.uuid);\n\n\tDBG(\"sending remove uuid command for index %u\", adapter->dev_id);\n\n\tif (mgmt_send(adapter->mgmt, MGMT_OP_REMOVE_UUID,\n\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\tremove_uuid_complete, adapter, NULL) > 0)\n\t\treturn 0;\n\n\tbtd_error(adapter->dev_id, \"Failed to remove UUID for index %u\",\n\t\t\t\t\t\t\tadapter->dev_id);\n\n\treturn -EIO;\n}\n\nstatic void clear_uuids_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\tbtd_error(adapter->dev_id, \"Failed to clear UUIDs: %s (0x%02x)\",\n\t\t\t\t\t\tmgmt_errstr(status), status);\n\t\treturn;\n\t}\n\n\t/*\n\t * The parameters are identical and also the task that is\n\t * required in both cases. So it is safe to just call the\n\t * event handling functions here.\n\t */\n\tdev_class_changed_callback(adapter->dev_id, length, param, adapter);\n}\n\nstatic int clear_uuids(struct btd_adapter *adapter)\n{\n\tstruct mgmt_cp_remove_uuid cp;\n\n\tmemset(&cp, 0, sizeof(cp));\n\n\tDBG(\"sending clear uuids command for index %u\", adapter->dev_id);\n\n\tif (mgmt_send(adapter->mgmt, MGMT_OP_REMOVE_UUID,\n\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\tclear_uuids_complete, adapter, NULL) > 0)\n\t\treturn 0;\n\n\tbtd_error(adapter->dev_id, \"Failed to clear UUIDs for index %u\",\n\t\t\t\t\t\t\tadapter->dev_id);\n\n\treturn -EIO;\n}\n\nstatic uint8_t get_uuid_mask(uuid_t *uuid)\n{\n\tif (uuid->type != SDP_UUID16)\n\t\treturn 0;\n\n\tswitch (uuid->value.uuid16) {\n\tcase DIALUP_NET_SVCLASS_ID:\n\tcase CIP_SVCLASS_ID:\n\t\treturn 0x42;\t/* Telephony & Networking */\n\tcase IRMC_SYNC_SVCLASS_ID:\n\tcase OBEX_OBJPUSH_SVCLASS_ID:\n\tcase OBEX_FILETRANS_SVCLASS_ID:\n\tcase IRMC_SYNC_CMD_SVCLASS_ID:\n\tcase PBAP_PSE_SVCLASS_ID:\n\t\treturn 0x10;\t/* Object Transfer */\n\tcase HEADSET_SVCLASS_ID:\n\tcase HANDSFREE_SVCLASS_ID:\n\t\treturn 0x20;\t/* Audio */\n\tcase CORDLESS_TELEPHONY_SVCLASS_ID:\n\tcase INTERCOM_SVCLASS_ID:\n\tcase FAX_SVCLASS_ID:\n\tcase SAP_SVCLASS_ID:\n\t/*\n\t * Setting the telephony bit for the handsfree audio gateway\n\t * role is not required by the HFP specification, but the\n\t * Nokia 616 carkit is just plain broken! It will refuse\n\t * pairing without this bit set.\n\t */\n\tcase HANDSFREE_AGW_SVCLASS_ID:\n\t\treturn 0x40;\t/* Telephony */\n\tcase AUDIO_SOURCE_SVCLASS_ID:\n\tcase VIDEO_SOURCE_SVCLASS_ID:\n\t\treturn 0x08;\t/* Capturing */\n\tcase AUDIO_SINK_SVCLASS_ID:\n\tcase VIDEO_SINK_SVCLASS_ID:\n\t\treturn 0x04;\t/* Rendering */\n\tcase PANU_SVCLASS_ID:\n\tcase NAP_SVCLASS_ID:\n\tcase GN_SVCLASS_ID:\n\t\treturn 0x02;\t/* Networking */\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int uuid_cmp(const void *a, const void *b)\n{\n\tconst sdp_record_t *rec = a;\n\tconst uuid_t *uuid = b;\n\n\treturn sdp_uuid_cmp(&rec->svclass, uuid);\n}\n\nstatic void adapter_service_insert(struct btd_adapter *adapter, sdp_record_t *rec)\n{\n\tsdp_list_t *browse_list = NULL;\n\tuuid_t browse_uuid;\n\tgboolean new_uuid;\n\n\tDBG(\"%s\", adapter->path);\n\n\t/* skip record without a browse group */\n\tif (sdp_get_browse_groups(rec, &browse_list) < 0) {\n\t\tDBG(\"skipping record without browse group\");\n\t\treturn;\n\t}\n\n\tsdp_uuid16_create(&browse_uuid, PUBLIC_BROWSE_GROUP);\n\n\t/* skip record without public browse group */\n\tif (!sdp_list_find(browse_list, &browse_uuid, sdp_uuid_cmp))\n\t\tgoto done;\n\n\tif (sdp_list_find(adapter->services, &rec->svclass, uuid_cmp) == NULL)\n\t\tnew_uuid = TRUE;\n\telse\n\t\tnew_uuid = FALSE;\n\n\tadapter->services = sdp_list_insert_sorted(adapter->services, rec,\n\t\t\t\t\t\t\t\trecord_sort);\n\n\tif (new_uuid) {\n\t\tuint8_t svc_hint = get_uuid_mask(&rec->svclass);\n\t\tadd_uuid(adapter, &rec->svclass, svc_hint);\n\t}\n\ndone:\n\tsdp_list_free(browse_list, free);\n}\n\nint adapter_service_add(struct btd_adapter *adapter, sdp_record_t *rec)\n{\n\tint ret;\n\n\tDBG(\"%s\", adapter->path);\n\n\tret = add_record_to_server(&adapter->bdaddr, rec);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tadapter_service_insert(adapter, rec);\n\n\treturn 0;\n}\n\nvoid adapter_service_remove(struct btd_adapter *adapter, uint32_t handle)\n{\n\tsdp_record_t *rec = sdp_record_find(handle);\n\n\tDBG(\"%s\", adapter->path);\n\n\tif (!rec)\n\t\treturn;\n\n\tadapter->services = sdp_list_remove(adapter->services, rec);\n\n\tif (sdp_list_find(adapter->services, &rec->svclass, uuid_cmp) == NULL)\n\t\tremove_uuid(adapter, &rec->svclass);\n\n\tremove_record_from_server(rec->handle);\n}\n\nstatic struct btd_device *adapter_create_device(struct btd_adapter *adapter,\n\t\t\t\t\t\tconst bdaddr_t *bdaddr,\n\t\t\t\t\t\tuint8_t bdaddr_type)\n{\n\tstruct btd_device *device;\n\n\tdevice = device_create(adapter, bdaddr, bdaddr_type);\n\tif (!device)\n\t\treturn NULL;\n\n\tadapter->devices = g_slist_append(adapter->devices, device);\n\n\treturn device;\n}\n\nstatic void service_auth_cancel(struct service_auth *auth)\n{\n\tDBusError derr;\n\n\tif (auth->svc_id > 0)\n\t\tdevice_remove_svc_complete_callback(auth->device,\n\t\t\t\t\t\t\t\tauth->svc_id);\n\n\tdbus_error_init(&derr);\n\tdbus_set_error_const(&derr, ERROR_INTERFACE \".Canceled\", NULL);\n\n\tauth->cb(&derr, auth->user_data);\n\n\tdbus_error_free(&derr);\n\n\tif (auth->agent != NULL) {\n\t\tagent_cancel(auth->agent);\n\t\tagent_unref(auth->agent);\n\t}\n\n\tg_free(auth);\n}\n\nvoid btd_adapter_remove_device(struct btd_adapter *adapter,\n\t\t\t\tstruct btd_device *dev)\n{\n\tGList *l;\n\n\tadapter->connect_list = g_slist_remove(adapter->connect_list, dev);\n\n\tadapter->devices = g_slist_remove(adapter->devices, dev);\n\tbtd_adv_monitor_device_remove(adapter->adv_monitor_manager, dev);\n\n\tadapter->discovery_found = g_slist_remove(adapter->discovery_found,\n\t\t\t\t\t\t\t\t\tdev);\n\n\tadapter->connections = g_slist_remove(adapter->connections, dev);\n\n\tif (adapter->connect_le == dev)\n\t\tadapter->connect_le = NULL;\n\n\tl = adapter->auths->head;\n\twhile (l != NULL) {\n\t\tstruct service_auth *auth = l->data;\n\t\tGList *next = g_list_next(l);\n\n\t\tif (auth->device != dev) {\n\t\t\tl = next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tg_queue_delete_link(adapter->auths, l);\n\t\tl = next;\n\n\t\tservice_auth_cancel(auth);\n\t}\n\n\tdevice_remove(dev, TRUE);\n}\n\nstruct btd_device *btd_adapter_get_device(struct btd_adapter *adapter,\n\t\t\t\t\tconst bdaddr_t *addr,\n\t\t\t\t\tuint8_t addr_type)\n{\n\tstruct btd_device *device;\n\n\tif (!adapter)\n\t\treturn NULL;\n\n\tdevice = btd_adapter_find_device(adapter, addr, addr_type);\n\tif (device)\n\t\treturn device;\n\n\treturn adapter_create_device(adapter, addr, addr_type);\n}\n\nsdp_list_t *btd_adapter_get_services(struct btd_adapter *adapter)\n{\n\treturn adapter->services;\n}\n\nstatic void passive_scanning_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tconst struct mgmt_cp_start_discovery *rp = param;\n\n\tDBG(\"status 0x%02x\", status);\n\n\tif (length < sizeof(*rp)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\"Wrong size of start scanning return parameters\");\n\t\treturn;\n\t}\n\n\tif (status == MGMT_STATUS_SUCCESS) {\n\t\tadapter->discovery_type = rp->type;\n\t\tadapter->discovery_enable = 0x01;\n\t}\n}\n\nstatic bool passive_scanning_timeout(gpointer user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tstruct mgmt_cp_start_discovery cp;\n\n\tadapter->passive_scan_timeout = 0;\n\n\tcp.type = SCAN_TYPE_LE;\n\n\tmgmt_send(adapter->mgmt, MGMT_OP_START_DISCOVERY,\n\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\tpassive_scanning_complete, adapter, NULL);\n\n\treturn FALSE;\n}\n\nstatic void trigger_passive_scanning(struct btd_adapter *adapter)\n{\n\tif (!(adapter->current_settings & MGMT_SETTING_LE))\n\t\treturn;\n\n\tDBG(\"\");\n\n\tif (adapter->passive_scan_timeout > 0) {\n\t\ttimeout_remove(adapter->passive_scan_timeout);\n\t\tadapter->passive_scan_timeout = 0;\n\t}\n\n\t/*\n\t * When the kernel background scanning is available, there is\n\t * no need to start any discovery. The kernel will keep scanning\n\t * as long as devices are in its auto-connection list.\n\t */\n\tif (btd_has_kernel_features(KERNEL_CONN_CONTROL))\n\t\treturn;\n\n\t/*\n\t * If any client is running a discovery right now, then do not\n\t * even try to start passive scanning.\n\t *\n\t * The discovery procedure is using interleaved scanning and\n\t * thus will discover Low Energy devices as well.\n\t */\n\tif (adapter->discovery_list)\n\t\treturn;\n\n\tif (adapter->discovery_enable == 0x01)\n\t\treturn;\n\n\t/*\n\t * In case the discovery is suspended (for example for an ongoing\n\t * pairing attempt), then also do not start passive scanning.\n\t */\n\tif (adapter->discovery_suspended)\n\t\treturn;\n\n\t/*\n\t * If the list of connectable Low Energy devices is empty,\n\t * then do not start passive scanning.\n\t */\n\tif (!adapter->connect_list)\n\t\treturn;\n\n\tadapter->passive_scan_timeout = timeout_add_seconds(CONN_SCAN_TIMEOUT,\n\t\t\t\t\tpassive_scanning_timeout, adapter,\n\t\t\t\t\tNULL);\n}\n\nstatic void stop_passive_scanning_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tstruct btd_device *dev;\n\tint err;\n\n\tDBG(\"status 0x%02x (%s)\", status, mgmt_errstr(status));\n\n\tdev = adapter->connect_le;\n\tadapter->connect_le = NULL;\n\n\t/*\n\t * When the kernel background scanning is available, there is\n\t * no need to stop any discovery. The kernel will handle the\n\t * auto-connection by itself.\n\t */\n\tif (btd_has_kernel_features(KERNEL_CONN_CONTROL))\n\t\treturn;\n\n\t/*\n\t * MGMT_STATUS_REJECTED may be returned from kernel because the passive\n\t * scan timer had expired in kernel and passive scan was disabled just\n\t * around the time we called stop_passive_scanning().\n\t */\n\tif (status != MGMT_STATUS_SUCCESS && status != MGMT_STATUS_REJECTED) {\n\t\tbtd_error(adapter->dev_id, \"Stopping passive scanning failed: %s\",\n\t\t\t\t\t\t\tmgmt_errstr(status));\n\t\treturn;\n\t}\n\n\tadapter->discovery_type = 0x00;\n\tadapter->discovery_enable = 0x00;\n\n\tif (!dev) {\n\t\tDBG(\"Device removed while stopping passive scanning\");\n\t\ttrigger_passive_scanning(adapter);\n\t\treturn;\n\t}\n\n\terr = device_connect_le(dev);\n\tif (err < 0) {\n\t\tbtd_error(adapter->dev_id, \"LE auto connection failed: %s (%d)\",\n\t\t\t\t\t\t\tstrerror(-err), -err);\n\t\ttrigger_passive_scanning(adapter);\n\t}\n}\n\nstatic void stop_passive_scanning(struct btd_adapter *adapter)\n{\n\tstruct mgmt_cp_stop_discovery cp;\n\n\tDBG(\"\");\n\n\t/* If there are any normal discovery clients passive scanning\n\t * wont be running */\n\tif (adapter->discovery_list)\n\t\treturn;\n\n\tif (adapter->discovery_enable == 0x00)\n\t\treturn;\n\n\tcp.type = adapter->discovery_type;\n\n\tmgmt_send(adapter->mgmt, MGMT_OP_STOP_DISCOVERY,\n\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\tstop_passive_scanning_complete, adapter, NULL);\n}\n\nstatic void cancel_passive_scanning(struct btd_adapter *adapter)\n{\n\tif (!(adapter->current_settings & MGMT_SETTING_LE))\n\t\treturn;\n\n\tDBG(\"\");\n\n\tif (adapter->passive_scan_timeout > 0) {\n\t\ttimeout_remove(adapter->passive_scan_timeout);\n\t\tadapter->passive_scan_timeout = 0;\n\t}\n}\n\nstatic uint8_t get_scan_type(struct btd_adapter *adapter)\n{\n\tuint8_t type;\n\n\tif (adapter->current_settings & MGMT_SETTING_BREDR)\n\t\ttype = SCAN_TYPE_BREDR;\n\telse\n\t\ttype = 0;\n\n\tif (adapter->current_settings & MGMT_SETTING_LE)\n\t\ttype |= SCAN_TYPE_LE;\n\n\treturn type;\n}\n\nstatic void free_discovery_filter(struct discovery_filter *discovery_filter)\n{\n\tif (!discovery_filter)\n\t\treturn;\n\n\tg_slist_free_full(discovery_filter->uuids, free);\n\tfree(discovery_filter->pattern);\n\tg_free(discovery_filter);\n}\n\nstatic void invalidate_rssi_and_tx_power(gpointer a)\n{\n\tstruct btd_device *dev = a;\n\n\tdevice_set_rssi(dev, 0);\n\tdevice_set_tx_power(dev, 127);\n}\n\nstatic void discovery_cleanup(struct btd_adapter *adapter, int timeout)\n{\n\tGSList *l, *next;\n\n\tadapter->discovery_type = 0x00;\n\n\tif (adapter->discovery_idle_timeout > 0) {\n\t\ttimeout_remove(adapter->discovery_idle_timeout);\n\t\tadapter->discovery_idle_timeout = 0;\n\t}\n\n\tg_slist_free_full(adapter->discovery_found,\n\t\t\t\t\t\tinvalidate_rssi_and_tx_power);\n\tadapter->discovery_found = NULL;\n\n\tif (!adapter->devices)\n\t\treturn;\n\n\tfor (l = adapter->devices; l != NULL; l = next) {\n\t\tstruct btd_device *dev = l->data;\n\n\t\tnext = g_slist_next(l);\n\n\t\tif (device_is_temporary(dev) && !device_is_connectable(dev))\n\t\t\tbtd_adapter_remove_device(adapter, dev);\n\t}\n}\n\nstatic void discovery_free(void *user_data)\n{\n\tstruct discovery_client *client = user_data;\n\tstruct btd_adapter *adapter = client->adapter;\n\n\tDBG(\"%p\", client);\n\n\tif (client->watch)\n\t\tg_dbus_remove_watch(dbus_conn, client->watch);\n\n\tif (client->discovery_filter) {\n\t\tfree_discovery_filter(client->discovery_filter);\n\t\tclient->discovery_filter = NULL;\n\t}\n\n\tif (client->msg) {\n\t\tif (client == adapter->client) {\n\t\t\tg_dbus_send_message(dbus_conn,\n\t\t\t\t\t\tbtd_error_busy(client->msg));\n\t\t\tadapter->client = NULL;\n\t\t}\n\t\tdbus_message_unref(client->msg);\n\t}\n\n\tg_free(client->owner);\n\tg_free(client);\n}\n\nstatic void discovery_remove(struct discovery_client *client)\n{\n\tstruct btd_adapter *adapter = client->adapter;\n\n\tDBG(\"owner %s\", client->owner);\n\n\tadapter->set_filter_list = g_slist_remove(adapter->set_filter_list,\n\t\t\t\t\t\t\t\tclient);\n\n\tadapter->discovery_list = g_slist_remove(adapter->discovery_list,\n\t\t\t\t\t\t\t\tclient);\n\n\tif (adapter->client == client)\n\t\tadapter->client = NULL;\n\n\tif (client->watch && client->discovery_filter)\n\t\tadapter->set_filter_list = g_slist_prepend(\n\t\t\t\t\tadapter->set_filter_list, client);\n\telse\n\t\tdiscovery_free(client);\n\n\t/*\n\t * If there are other client discoveries in progress, then leave\n\t * it active. If not, then make sure to stop the restart timeout.\n\t */\n\tif (adapter->discovery_list)\n\t\treturn;\n\n\tdiscovery_cleanup(adapter, TEMP_DEV_TIMEOUT);\n}\n\nstatic void trigger_start_discovery(struct btd_adapter *adapter, guint delay);\n\nstatic struct discovery_client *discovery_complete(struct btd_adapter *adapter,\n\t\t\t\t\t\tuint8_t status)\n{\n\tstruct discovery_client *client = adapter->client;\n\tDBusMessage *reply;\n\n\tif (!client)\n\t\treturn NULL;\n\n\tadapter->client = NULL;\n\n\tif (!client->msg)\n\t\treturn client;\n\n\tif (!status) {\n\t\tg_dbus_send_reply(dbus_conn, client->msg, DBUS_TYPE_INVALID);\n\t} else  {\n\t\treply = btd_error_busy(client->msg);\n\t\tg_dbus_send_message(dbus_conn, reply);\n\t}\n\n\tdbus_message_unref(client->msg);\n\tclient->msg = NULL;\n\n\treturn client;\n}\n\nstatic void start_discovery_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tstruct discovery_client *client;\n\tconst struct mgmt_cp_start_discovery *rp = param;\n\n\tDBG(\"status 0x%02x\", status);\n\n\t/* Is there are no clients the discovery must have been stopped while\n\t * discovery command was pending.\n\t */\n\tif (!adapter->discovery_list) {\n\t\tstruct mgmt_cp_stop_discovery cp;\n\n\t\tif (status != MGMT_STATUS_SUCCESS)\n\t\t\treturn;\n\n\t\t/* Stop discovering as there are no clients left */\n\t\tcp.type = rp->type;\n\t\tmgmt_send(adapter->mgmt, MGMT_OP_STOP_DISCOVERY,\n\t\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\t\tNULL, NULL, NULL);\n\t\treturn;\n\t}\n\n\tif (length < sizeof(*rp)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\"Wrong size of start discovery return parameters\");\n\t\tdiscovery_complete(adapter, MGMT_STATUS_FAILED);\n\t\treturn;\n\t}\n\n\tif (status == MGMT_STATUS_SUCCESS) {\n\t\tadapter->discovery_type = rp->type;\n\t\tadapter->discovery_enable = 0x01;\n\n\t\tif (adapter->current_discovery_filter)\n\t\t\tadapter->filtered_discovery = true;\n\t\telse\n\t\t\tadapter->filtered_discovery = false;\n\n\t\tdiscovery_complete(adapter, status);\n\n\t\tif (adapter->discovering)\n\t\t\treturn;\n\n\t\tadapter->discovering = true;\n\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Discovering\");\n\t\treturn;\n\t}\n\n\t/* Reply with an error if the first discovery has failed */\n\tclient = discovery_complete(adapter, status);\n\tif (client) {\n\t\tdiscovery_remove(client);\n\t\treturn;\n\t}\n\n\t/*\n\t * In case the restart of the discovery failed, then just trigger\n\t * it for the next idle timeout again.\n\t */\n\ttrigger_start_discovery(adapter, IDLE_DISCOV_TIMEOUT * 2);\n}\n\nstatic bool start_discovery_timeout(gpointer user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tstruct mgmt_cp_start_service_discovery *sd_cp;\n\tuint8_t new_type;\n\n\tDBG(\"\");\n\n\tadapter->discovery_idle_timeout = 0;\n\n\t/* If we're doing filtered discovery, it must be quickly restarted */\n\tadapter->no_scan_restart_delay = !!adapter->current_discovery_filter;\n\n\tDBG(\"adapter->current_discovery_filter == %d\",\n\t    !!adapter->current_discovery_filter);\n\n\tnew_type = get_scan_type(adapter);\n\n\tif (adapter->discovery_enable == 0x01) {\n\t\tstruct mgmt_cp_stop_discovery cp;\n\n\t\t/*\n\t\t * If we're asked to start regular discovery, and there is an\n\t\t * already running regular discovery and it has the same type,\n\t\t * then just keep it.\n\t\t */\n\t\tif (!adapter->current_discovery_filter &&\n\t\t    !adapter->filtered_discovery &&\n\t\t    adapter->discovery_type == new_type) {\n\t\t\tif (adapter->discovering)\n\t\t\t\treturn FALSE;\n\n\t\t\tadapter->discovering = true;\n\t\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Discovering\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\t/*\n\t\t * Otherwise the current discovery must be stopped. So\n\t\t * queue up a stop discovery command.\n\t\t *\n\t\t * This can happen if a passive scanning for Low Energy\n\t\t * devices is ongoing, or scan type is changed between\n\t\t * regular and filtered, or filter was updated.\n\t\t */\n\t\tcp.type = adapter->discovery_type;\n\t\tmgmt_send(adapter->mgmt, MGMT_OP_STOP_DISCOVERY,\n\t\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\t\tNULL, NULL, NULL);\n\n\t\t/* Don't even bother to try to quickly start discovery\n\t\t * just after stopping it, it would fail with status\n\t\t * MGMT_BUSY. Instead discovering_callback will take\n\t\t * care of that.\n\t\t */\n\t\treturn FALSE;\n\n\t}\n\n\t/* Regular discovery is required */\n\tif (!adapter->current_discovery_filter) {\n\t\tstruct mgmt_cp_start_discovery cp;\n\n\t\tcp.type = new_type;\n\t\tmgmt_send(adapter->mgmt, MGMT_OP_START_DISCOVERY,\n\t\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\t\tstart_discovery_complete, adapter,\n\t\t\t\t\tNULL);\n\n\t\treturn FALSE;\n\t}\n\n\t/* Filtered discovery is required */\n\tsd_cp = adapter->current_discovery_filter;\n\n\tDBG(\"sending MGMT_OP_START_SERVICE_DISCOVERY %d, %d, %d\",\n\t\t\t\tsd_cp->rssi, sd_cp->type,\n\t\t\t\tbtohs(sd_cp->uuid_count));\n\n\tmgmt_send(adapter->mgmt, MGMT_OP_START_SERVICE_DISCOVERY,\n\t\t  adapter->dev_id, sizeof(*sd_cp) +\n\t\t  btohs(sd_cp->uuid_count) * 16,\n\t\t  sd_cp, start_discovery_complete, adapter, NULL);\n\n\treturn FALSE;\n}\n\nstatic void trigger_start_discovery(struct btd_adapter *adapter, guint delay)\n{\n\n\tDBG(\"\");\n\n\tcancel_passive_scanning(adapter);\n\n\tif (adapter->discovery_idle_timeout > 0) {\n\t\ttimeout_remove(adapter->discovery_idle_timeout);\n\t\tadapter->discovery_idle_timeout = 0;\n\t}\n\n\t/*\n\t * If the controller got powered down in between, then ensure\n\t * that we do not keep trying to restart discovery.\n\t *\n\t * This is safe-guard and should actually never trigger.\n\t */\n\tif (!btd_adapter_get_powered(adapter))\n\t\treturn;\n\n\tadapter->discovery_idle_timeout = timeout_add_seconds(delay,\n\t\t\t\t\tstart_discovery_timeout, adapter, NULL);\n}\n\nstatic void suspend_discovery_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\tDBG(\"status 0x%02x\", status);\n\n\tif (status == MGMT_STATUS_SUCCESS) {\n\t\tadapter->discovery_type = 0x00;\n\t\tadapter->discovery_enable = 0x00;\n\t\treturn;\n\t}\n}\n\nstatic void suspend_discovery(struct btd_adapter *adapter)\n{\n\tstruct mgmt_cp_stop_discovery cp;\n\n\tDBG(\"\");\n\n\tadapter->discovery_suspended = true;\n\n\t/*\n\t * If there are no clients discovering right now, then there is\n\t * also nothing to suspend.\n\t */\n\tif (!adapter->discovery_list)\n\t\treturn;\n\n\t/*\n\t * In case of being inside the idle phase, make sure to remove\n\t * the timeout to not trigger a restart.\n\t *\n\t * The restart will be triggered when the discovery is resumed.\n\t */\n\tif (adapter->discovery_idle_timeout > 0) {\n\t\ttimeout_remove(adapter->discovery_idle_timeout);\n\t\tadapter->discovery_idle_timeout = 0;\n\t}\n\n\tif (adapter->discovery_enable == 0x00)\n\t\treturn;\n\n\tcp.type = adapter->discovery_type;\n\n\tmgmt_send(adapter->mgmt, MGMT_OP_STOP_DISCOVERY,\n\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\tsuspend_discovery_complete, adapter, NULL);\n}\n\nstatic void resume_discovery(struct btd_adapter *adapter)\n{\n\tDBG(\"\");\n\n\tadapter->discovery_suspended = false;\n\n\t/*\n\t * If there are no clients discovering right now, then there is\n\t * also nothing to resume.\n\t */\n\tif (!adapter->discovery_list)\n\t\treturn;\n\n\t/*\n\t * Treat a suspended discovery session the same as extra long\n\t * idle time for a normal discovery. So just trigger the default\n\t * restart procedure.\n\t */\n\ttrigger_start_discovery(adapter, IDLE_DISCOV_TIMEOUT);\n}\n\nstatic void discovering_callback(uint16_t index, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_ev_discovering *ev = param;\n\tstruct btd_adapter *adapter = user_data;\n\n\tif (length < sizeof(*ev)) {\n\t\tbtd_error(adapter->dev_id, \"Too small discovering event\");\n\t\treturn;\n\t}\n\n\tDBG(\"hci%u type %u discovering %u method %d\", adapter->dev_id, ev->type,\n\t\t\t\tev->discovering, adapter->filtered_discovery);\n\n\tif (adapter->discovery_enable == ev->discovering)\n\t\treturn;\n\n\tadapter->discovery_type = ev->type;\n\tadapter->discovery_enable = ev->discovering;\n\n\t/*\n\t * Check for existing discoveries triggered by client applications\n\t * and ignore all others.\n\t *\n\t * If there are no clients, then it is good idea to trigger a\n\t * passive scanning attempt.\n\t */\n\tif (!adapter->discovery_list) {\n\t\tif (!adapter->connect_le)\n\t\t\ttrigger_passive_scanning(adapter);\n\t\treturn;\n\t}\n\n\tif (adapter->discovery_suspended)\n\t\treturn;\n\n\tswitch (adapter->discovery_enable) {\n\tcase 0x00:\n\t\tif (adapter->no_scan_restart_delay)\n\t\t\ttrigger_start_discovery(adapter, 0);\n\t\telse\n\t\t\ttrigger_start_discovery(adapter, IDLE_DISCOV_TIMEOUT);\n\t\tbreak;\n\n\tcase 0x01:\n\t\tif (adapter->discovery_idle_timeout > 0) {\n\t\t\ttimeout_remove(adapter->discovery_idle_timeout);\n\t\t\tadapter->discovery_idle_timeout = 0;\n\t\t}\n\n\t\tbreak;\n\t}\n}\n\nstatic bool set_discovery_discoverable(struct btd_adapter *adapter, bool enable)\n{\n\tif (adapter->discovery_discoverable == enable)\n\t\treturn true;\n\n\t/* Reset discoverable filter if already set */\n\tif (enable && (adapter->current_settings & MGMT_OP_SET_DISCOVERABLE))\n\t\treturn true;\n\n\tadapter->discovery_discoverable = enable;\n\n\treturn set_discoverable(adapter, enable, 0);\n}\n\nstatic void stop_discovery_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tstruct discovery_client *client;\n\n\tDBG(\"status 0x%02x\", status);\n\n\tclient = discovery_complete(adapter, status);\n\tif (client)\n\t\tdiscovery_remove(client);\n\n\tif (status != MGMT_STATUS_SUCCESS)\n\t\treturn;\n\n\tadapter->discovery_type = 0x00;\n\tadapter->discovery_enable = 0x00;\n\tadapter->filtered_discovery = false;\n\tadapter->no_scan_restart_delay = false;\n\tadapter->discovering = false;\n\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Discovering\");\n\n\ttrigger_passive_scanning(adapter);\n}\n\nstatic int compare_sender(gconstpointer a, gconstpointer b)\n{\n\tconst struct discovery_client *client = a;\n\tconst char *sender = b;\n\n\treturn g_strcmp0(client->owner, sender);\n}\n\nstatic gint g_strcmp(gconstpointer a, gconstpointer b)\n{\n\treturn strcmp(a, b);\n}\n\nstatic void extract_unique_uuids(gpointer data, gpointer user_data)\n{\n\tchar *uuid_str = data;\n\tGSList **uuids = user_data;\n\n\tif (!g_slist_find_custom(*uuids, uuid_str, g_strcmp))\n\t\t*uuids = g_slist_insert_sorted(*uuids, uuid_str, g_strcmp);\n}\n\n/*\n * This method merges all adapter filters into rssi, transport and uuids.\n * Returns 1 if there was no filtered scan, 0 otherwise.\n */\nstatic int merge_discovery_filters(struct btd_adapter *adapter, int *rssi,\n\t\t\t\t\tuint8_t *transport, GSList **uuids)\n{\n\tGSList *l;\n\tbool empty_uuid = false;\n\tbool has_regular_discovery = false;\n\tbool has_filtered_discovery = false;\n\n\tfor (l = adapter->discovery_list; l != NULL; l = g_slist_next(l)) {\n\t\tstruct discovery_client *client = l->data;\n\t\tstruct discovery_filter *item = client->discovery_filter;\n\n\t\tif (!item) {\n\t\t\thas_regular_discovery = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\thas_filtered_discovery = true;\n\n\t\t*transport |= item->type;\n\n\t\t/*\n\t\t * Rule for merging rssi and pathloss into rssi field of kernel\n\t\t * filter is as follow:\n\t\t * - if there's any client without proximity filter, then do no\n\t\t *   proximity filtering,\n\t\t * - if all clients specified RSSI, then use lowest value,\n\t\t * - if any client specified pathloss, then kernel filter should\n\t\t *   do no proximity, as kernel can't compute pathloss. We'll do\n\t\t *   filtering on our own.\n\t\t */\n\t\tif (item->rssi == DISTANCE_VAL_INVALID)\n\t\t\t*rssi = HCI_RSSI_INVALID;\n\t\telse if (*rssi != HCI_RSSI_INVALID && *rssi >= item->rssi)\n\t\t\t*rssi = item->rssi;\n\t\telse if (item->pathloss != DISTANCE_VAL_INVALID)\n\t\t\t*rssi = HCI_RSSI_INVALID;\n\n\t\tif (!g_slist_length(item->uuids))\n\t\t\tempty_uuid = true;\n\n\t\tg_slist_foreach(item->uuids, extract_unique_uuids, uuids);\n\t}\n\n\t/* If no proximity filtering is set, disable it */\n\tif (*rssi == DISTANCE_VAL_INVALID)\n\t\t*rssi = HCI_RSSI_INVALID;\n\n\t/*\n\t * Empty_uuid variable determines wether there was any filter with no\n\t * uuids. In this case someone might be looking for all devices in\n\t * certain proximity, and we need to have empty uuids in kernel filter.\n\t */\n\tif (empty_uuid) {\n\t\tg_slist_free(*uuids);\n\t\t*uuids = NULL;\n\t}\n\n\tif (has_regular_discovery) {\n\t\tif (!has_filtered_discovery)\n\t\t\treturn 1;\n\n\t\t/*\n\t\t * It there is both regular and filtered scan running, then\n\t\t * clear whole fitler to report all devices.\n\t\t */\n\t\t*transport = get_scan_type(adapter);\n\t\t*rssi = HCI_RSSI_INVALID;\n\t\tg_slist_free(*uuids);\n\t\t*uuids = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic void populate_mgmt_filter_uuids(uint8_t (*mgmt_uuids)[16], GSList *uuids)\n{\n\tGSList *l;\n\n\tfor (l = uuids; l != NULL; l = g_slist_next(l)) {\n\t\tbt_uuid_t uuid, u128;\n\t\tuint128_t uint128;\n\n\t\tbt_string_to_uuid(&uuid, l->data);\n\t\tbt_uuid_to_uuid128(&uuid, &u128);\n\n\t\tntoh128((uint128_t *) u128.value.u128.data, &uint128);\n\t\thtob128(&uint128, (uint128_t *) mgmt_uuids);\n\n\t\tmgmt_uuids++;\n\t}\n}\n\n/*\n * This method merges all adapter filters into one that will be send to kernel.\n * cp_ptr is set to null when regular non-filtered discovery is needed,\n * otherwise it's pointing to filter. Returns 0 on succes, -1 on error\n */\nstatic int discovery_filter_to_mgmt_cp(struct btd_adapter *adapter,\n\t\t       struct mgmt_cp_start_service_discovery **cp_ptr)\n{\n\tGSList *uuids = NULL;\n\tstruct mgmt_cp_start_service_discovery *cp;\n\tint rssi = DISTANCE_VAL_INVALID;\n\tint uuid_count;\n\tuint8_t discovery_type = 0;\n\n\tDBG(\"\");\n\n\tif (merge_discovery_filters(adapter, &rssi, &discovery_type, &uuids)) {\n\t\t/* There are only regular scans, run just regular scan. */\n\t\t*cp_ptr = NULL;\n\t\treturn 0;\n\t}\n\n\tuuid_count = g_slist_length(uuids);\n\n\tcp = g_try_malloc(sizeof(*cp) + 16*uuid_count);\n\t*cp_ptr = cp;\n\tif (!cp) {\n\t\tg_slist_free(uuids);\n\t\treturn -1;\n\t}\n\n\tcp->type = discovery_type;\n\tcp->rssi = rssi;\n\tcp->uuid_count = htobs(uuid_count);\n\tpopulate_mgmt_filter_uuids(cp->uuids, uuids);\n\n\tg_slist_free(uuids);\n\treturn 0;\n}\n\nstatic bool filters_equal(struct mgmt_cp_start_service_discovery *a,\n\t\t   struct mgmt_cp_start_service_discovery *b) {\n\tif (!a && !b)\n\t\treturn true;\n\n\tif ((!a && b) || (a && !b))\n\t\treturn false;\n\n\tif (a->type != b->type)\n\t\treturn false;\n\n\tif (a->rssi != b->rssi)\n\t\treturn false;\n\n\t/*\n\t * When we create mgmt_cp_start_service_discovery structure inside\n\t * discovery_filter_to_mgmt_cp, we always keep uuids sorted, and\n\t * unique, so we're safe to compare uuid_count, and uuids like that.\n\t */\n\tif (a->uuid_count != b->uuid_count)\n\t\treturn false;\n\n\tif (memcmp(a->uuids, b->uuids, 16 * a->uuid_count) != 0)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int update_discovery_filter(struct btd_adapter *adapter)\n{\n\tstruct mgmt_cp_start_service_discovery *sd_cp;\n\tGSList *l;\n\n\n\tDBG(\"\");\n\n\tif (discovery_filter_to_mgmt_cp(adapter, &sd_cp)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"discovery_filter_to_mgmt_cp returned error\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (l = adapter->discovery_list; l; l = g_slist_next(l)) {\n\t\tstruct discovery_client *client = l->data;\n\n\t\tif (!client->discovery_filter)\n\t\t\tcontinue;\n\n\t\tif (client->discovery_filter->discoverable)\n\t\t\tbreak;\n\t}\n\n\tset_discovery_discoverable(adapter, l ? true : false);\n\n\t/*\n\t * If filters are equal, then don't update scan, except for when\n\t * starting discovery.\n\t */\n\tif (filters_equal(adapter->current_discovery_filter, sd_cp) &&\n\t    adapter->discovering != 0) {\n\t\tDBG(\"filters were equal, deciding to not restart the scan.\");\n\t\tg_free(sd_cp);\n\t\treturn 0;\n\t}\n\n\tg_free(adapter->current_discovery_filter);\n\tadapter->current_discovery_filter = sd_cp;\n\n\ttrigger_start_discovery(adapter, 0);\n\n\treturn -EINPROGRESS;\n}\n\nstatic int discovery_stop(struct discovery_client *client)\n{\n\tstruct btd_adapter *adapter = client->adapter;\n\tstruct mgmt_cp_stop_discovery cp;\n\n\t/* Check if there are more client discovering */\n\tif (g_slist_next(adapter->discovery_list)) {\n\t\tdiscovery_remove(client);\n\t\tupdate_discovery_filter(adapter);\n\t\treturn 0;\n\t}\n\n\tif (adapter->discovery_discoverable)\n\t\tset_discovery_discoverable(adapter, false);\n\n\t/*\n\t * In the idle phase of a discovery, there is no need to stop it\n\t * and so it is enough to send out the signal and just return.\n\t */\n\tif (adapter->discovery_enable == 0x00) {\n\t\tdiscovery_remove(client);\n\t\tadapter->discovering = false;\n\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Discovering\");\n\n\t\ttrigger_passive_scanning(adapter);\n\n\t\treturn 0;\n\t}\n\n\tcp.type = adapter->discovery_type;\n\tadapter->client = client;\n\n\tmgmt_send(adapter->mgmt, MGMT_OP_STOP_DISCOVERY,\n\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\tstop_discovery_complete, adapter, NULL);\n\n\treturn -EINPROGRESS;\n}\n\nstatic void discovery_disconnect(DBusConnection *conn, void *user_data)\n{\n\tstruct discovery_client *client = user_data;\n\n\tDBG(\"owner %s\", client->owner);\n\n\tclient->watch = 0;\n\n\tdiscovery_stop(client);\n}\n\n/*\n * Returns true if client was already discovering, false otherwise. *client\n * will point to discovering client, or client that have pre-set his filter.\n */\nstatic bool get_discovery_client(struct btd_adapter *adapter, const char *owner,\n\t\t\t\tstruct discovery_client **client)\n{\n\tGSList *list = g_slist_find_custom(adapter->discovery_list, owner,\n\t\t\t\t\t\t\t\tcompare_sender);\n\tif (list) {\n\t\t*client = list->data;\n\t\treturn true;\n\t}\n\n\tlist = g_slist_find_custom(adapter->set_filter_list, owner,\n\t\t\t\t\t\t\t\tcompare_sender);\n\tif (list) {\n\t\t*client = list->data;\n\t\treturn false;\n\t}\n\n\t*client = NULL;\n\treturn false;\n}\n\nstatic DBusMessage *start_discovery(DBusConnection *conn,\n\t\t\t\t\tDBusMessage *msg, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tconst char *sender = dbus_message_get_sender(msg);\n\tstruct discovery_client *client;\n\tbool is_discovering;\n\tint err;\n\n\tDBG(\"sender %s\", sender);\n\n\tif (!btd_adapter_get_powered(adapter))\n\t\treturn btd_error_not_ready(msg);\n\n\tis_discovering = get_discovery_client(adapter, sender, &client);\n\n\t/*\n\t * Every client can only start one discovery, if the client\n\t * already started a discovery then return an error.\n\t */\n\tif (is_discovering)\n\t\treturn btd_error_busy(msg);\n\n\t/*\n\t * If there was pre-set filter, just reconnect it to discovery_list,\n\t * and trigger scan.\n\t */\n\tif (client) {\n\t\tif (client->msg)\n\t\t\treturn btd_error_busy(msg);\n\n\t\tadapter->set_filter_list = g_slist_remove(\n\t\t\t\t\t     adapter->set_filter_list, client);\n\t\tadapter->discovery_list = g_slist_prepend(\n\t\t\t\t\t      adapter->discovery_list, client);\n\n\t\tgoto done;\n\t}\n\n\tclient = g_new0(struct discovery_client, 1);\n\n\tclient->adapter = adapter;\n\tclient->owner = g_strdup(sender);\n\tclient->discovery_filter = NULL;\n\tclient->watch = g_dbus_add_disconnect_watch(dbus_conn, sender,\n\t\t\t\t\t\tdiscovery_disconnect, client,\n\t\t\t\t\t\tNULL);\n\tadapter->discovery_list = g_slist_prepend(adapter->discovery_list,\n\t\t\t\t\t\t\t\tclient);\n\ndone:\n\t/*\n\t * Just trigger the discovery here. In case an already running\n\t * discovery in idle phase exists, it will be restarted right\n\t * away.\n\t */\n\terr = update_discovery_filter(adapter);\n\tif (!err)\n\t\treturn dbus_message_new_method_return(msg);\n\n\t/* If the discovery has to be started wait it complete to reply */\n\tif (err == -EINPROGRESS) {\n\t\tclient->msg = dbus_message_ref(msg);\n\t\tadapter->client = client;\n\t\treturn NULL;\n\t}\n\n\treturn btd_error_failed(msg, strerror(-err));\n}\n\nstatic bool parse_uuids(DBusMessageIter *value, struct discovery_filter *filter)\n{\n\tDBusMessageIter arriter;\n\n\tif (dbus_message_iter_get_arg_type(value) != DBUS_TYPE_ARRAY)\n\t\treturn false;\n\n\tdbus_message_iter_recurse(value, &arriter);\n\twhile (dbus_message_iter_get_arg_type(&arriter) != DBUS_TYPE_INVALID) {\n\t\tbt_uuid_t uuid, u128;\n\t\tchar uuidstr[MAX_LEN_UUID_STR + 1];\n\t\tchar *uuid_param;\n\n\t\tif (dbus_message_iter_get_arg_type(&arriter) !=\n\t\t\t\t\t\tDBUS_TYPE_STRING)\n\t\t\treturn false;\n\n\t\tdbus_message_iter_get_basic(&arriter, &uuid_param);\n\n\t\tif (bt_string_to_uuid(&uuid, uuid_param))\n\t\t\treturn false;\n\n\t\tbt_uuid_to_uuid128(&uuid, &u128);\n\t\tbt_uuid_to_string(&u128, uuidstr, sizeof(uuidstr));\n\n\t\tfilter->uuids = g_slist_prepend(filter->uuids, strdup(uuidstr));\n\n\t\tdbus_message_iter_next(&arriter);\n\t}\n\n\treturn true;\n}\n\nstatic bool parse_rssi(DBusMessageIter *value, struct discovery_filter *filter)\n{\n\tif (dbus_message_iter_get_arg_type(value) != DBUS_TYPE_INT16)\n\t\treturn false;\n\n\tdbus_message_iter_get_basic(value, &filter->rssi);\n\t/* -127 <= RSSI <= +20 (spec V4.2 [Vol 2, Part E] 7.7.65.2) */\n\tif (filter->rssi > 20 || filter->rssi < -127)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool parse_pathloss(DBusMessageIter *value,\n\t\t\t\tstruct discovery_filter *filter)\n{\n\tif (dbus_message_iter_get_arg_type(value) != DBUS_TYPE_UINT16)\n\t\treturn false;\n\n\tdbus_message_iter_get_basic(value, &filter->pathloss);\n\t/* pathloss filter must be smaller that PATHLOSS_MAX */\n\tif (filter->pathloss > PATHLOSS_MAX)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool parse_transport(DBusMessageIter *value,\n\t\t\t\t\tstruct discovery_filter *filter)\n{\n\tchar *transport_str;\n\n\tif (dbus_message_iter_get_arg_type(value) != DBUS_TYPE_STRING)\n\t\treturn false;\n\n\tdbus_message_iter_get_basic(value, &transport_str);\n\n\tif (!strcmp(transport_str, \"bredr\"))\n\t\tfilter->type = SCAN_TYPE_BREDR;\n\telse if (!strcmp(transport_str, \"le\"))\n\t\tfilter->type = SCAN_TYPE_LE;\n\telse if (strcmp(transport_str, \"auto\"))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool parse_duplicate_data(DBusMessageIter *value,\n\t\t\t\t\tstruct discovery_filter *filter)\n{\n\tif (dbus_message_iter_get_arg_type(value) != DBUS_TYPE_BOOLEAN)\n\t\treturn false;\n\n\tdbus_message_iter_get_basic(value, &filter->duplicate);\n\n\treturn true;\n}\n\nstatic bool parse_discoverable(DBusMessageIter *value,\n\t\t\t\t\tstruct discovery_filter *filter)\n{\n\tif (dbus_message_iter_get_arg_type(value) != DBUS_TYPE_BOOLEAN)\n\t\treturn false;\n\n\tdbus_message_iter_get_basic(value, &filter->discoverable);\n\n\treturn true;\n}\n\nstatic bool parse_pattern(DBusMessageIter *value,\n\t\t\t\t\tstruct discovery_filter *filter)\n{\n\tconst char *pattern;\n\n\tif (dbus_message_iter_get_arg_type(value) != DBUS_TYPE_STRING)\n\t\treturn false;\n\n\tdbus_message_iter_get_basic(value, &pattern);\n\n\tfree(filter->pattern);\n\tfilter->pattern = strdup(pattern);\n\n\treturn true;\n}\n\nstruct filter_parser {\n\tconst char *name;\n\tbool (*func)(DBusMessageIter *iter, struct discovery_filter *filter);\n} parsers[] = {\n\t{ \"UUIDs\", parse_uuids },\n\t{ \"RSSI\", parse_rssi },\n\t{ \"Pathloss\", parse_pathloss },\n\t{ \"Transport\", parse_transport },\n\t{ \"DuplicateData\", parse_duplicate_data },\n\t{ \"Discoverable\", parse_discoverable },\n\t{ \"Pattern\", parse_pattern },\n\t{ }\n};\n\nstatic bool parse_discovery_filter_entry(char *key, DBusMessageIter *value,\n\t\t\t\t\t\tstruct discovery_filter *filter)\n{\n\tstruct filter_parser *parser;\n\n\tfor (parser = parsers; parser && parser->name; parser++) {\n\t\tif (!strcmp(parser->name, key))\n\t\t\treturn parser->func(value, filter);\n\t}\n\n\tDBG(\"Unknown key parameter: %s!\\n\", key);\n\treturn false;\n}\n\n/*\n * This method is responsible for parsing parameters to SetDiscoveryFilter. If\n * filter in msg was empty, sets *filter to NULL. If whole parsing was\n * successful, sets *filter to proper value.\n * Returns false on any error, and true on success.\n */\nstatic bool parse_discovery_filter_dict(struct btd_adapter *adapter,\n\t\t\t\t\tstruct discovery_filter **filter,\n\t\t\t\t\tDBusMessage *msg)\n{\n\tDBusMessageIter iter, subiter, dictiter, variantiter;\n\tbool is_empty = true;\n\n\t*filter = g_try_malloc(sizeof(**filter));\n\tif (!*filter)\n\t\treturn false;\n\n\t(*filter)->uuids = NULL;\n\t(*filter)->pathloss = DISTANCE_VAL_INVALID;\n\t(*filter)->rssi = DISTANCE_VAL_INVALID;\n\t(*filter)->type = get_scan_type(adapter);\n\t(*filter)->duplicate = false;\n\t(*filter)->discoverable = false;\n\t(*filter)->pattern = NULL;\n\n\tdbus_message_iter_init(msg, &iter);\n\tif (dbus_message_iter_get_arg_type(&iter) != DBUS_TYPE_ARRAY ||\n\t    dbus_message_iter_get_element_type(&iter) != DBUS_TYPE_DICT_ENTRY)\n\t\tgoto invalid_args;\n\n\tdbus_message_iter_recurse(&iter, &subiter);\n\tdo {\n\t\tint type = dbus_message_iter_get_arg_type(&subiter);\n\t\tchar *key;\n\n\t\tif (type == DBUS_TYPE_INVALID)\n\t\t\tbreak;\n\n\t\tis_empty = false;\n\t\tdbus_message_iter_recurse(&subiter, &dictiter);\n\n\t\tdbus_message_iter_get_basic(&dictiter, &key);\n\t\tif (!dbus_message_iter_next(&dictiter))\n\t\t\tgoto invalid_args;\n\n\t\tif (dbus_message_iter_get_arg_type(&dictiter) !=\n\t\t\t\t\t\t\t     DBUS_TYPE_VARIANT)\n\t\t\tgoto invalid_args;\n\n\t\tdbus_message_iter_recurse(&dictiter, &variantiter);\n\n\t\tif (!parse_discovery_filter_entry(key, &variantiter, *filter))\n\t\t\tgoto invalid_args;\n\n\t\tdbus_message_iter_next(&subiter);\n\t} while (true);\n\n\tif (is_empty) {\n\t\tg_free(*filter);\n\t\t*filter = NULL;\n\t\treturn true;\n\t}\n\n\t/* only pathlos or rssi can be set, never both */\n\tif ((*filter)->pathloss != DISTANCE_VAL_INVALID &&\n\t    (*filter)->rssi != DISTANCE_VAL_INVALID)\n\t\tgoto invalid_args;\n\n\tDBG(\"filtered discovery params: transport: %d rssi: %d pathloss: %d \"\n\t\t\" duplicate data: %s discoverable %s pattern %s\",\n\t\t(*filter)->type, (*filter)->rssi, (*filter)->pathloss,\n\t\t(*filter)->duplicate ? \"true\" : \"false\",\n\t\t(*filter)->discoverable ? \"true\" : \"false\",\n\t\t(*filter)->pattern);\n\n\treturn true;\n\ninvalid_args:\n\tg_slist_free_full((*filter)->uuids, g_free);\n\tg_free(*filter);\n\t*filter = NULL;\n\treturn false;\n}\n\nstatic DBusMessage *set_discovery_filter(DBusConnection *conn,\n\t\t\t\t\tDBusMessage *msg, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tstruct discovery_client *client;\n\tstruct discovery_filter *discovery_filter;\n\tconst char *sender = dbus_message_get_sender(msg);\n\tbool is_discovering;\n\n\tDBG(\"sender %s\", sender);\n\n\tif (!btd_adapter_get_powered(adapter))\n\t\treturn btd_error_not_ready(msg);\n\n\tif (MGMT_VERSION(mgmt_version, mgmt_revision) < MGMT_VERSION(1, 8))\n\t\treturn btd_error_not_supported(msg);\n\n\t/* parse parameters */\n\tif (!parse_discovery_filter_dict(adapter, &discovery_filter, msg))\n\t\treturn btd_error_invalid_args(msg);\n\n\tis_discovering = get_discovery_client(adapter, sender, &client);\n\n\tif (client) {\n\t\tfree_discovery_filter(client->discovery_filter);\n\t\tclient->discovery_filter = discovery_filter;\n\n\t\tif (is_discovering)\n\t\t\tupdate_discovery_filter(adapter);\n\n\t\tif (discovery_filter || is_discovering)\n\t\t\treturn dbus_message_new_method_return(msg);\n\n\t\t/* Removing pre-set filter */\n\t\tadapter->set_filter_list = g_slist_remove(\n\t\t\t\t\t      adapter->set_filter_list,\n\t\t\t\t\t      client);\n\t\tdiscovery_free(client);\n\t\tDBG(\"successfully cleared pre-set filter\");\n\t} else if (discovery_filter) {\n\t\t/* Client pre-setting his filter for first time */\n\t\tclient = g_new0(struct discovery_client, 1);\n\t\tclient->adapter = adapter;\n\t\tclient->owner = g_strdup(sender);\n\t\tclient->discovery_filter = discovery_filter;\n\t\tclient->watch = g_dbus_add_disconnect_watch(dbus_conn, sender,\n\t\t\t\t\t\tdiscovery_disconnect, client,\n\t\t\t\t\t\tNULL);\n\t\tadapter->set_filter_list = g_slist_prepend(\n\t\t\t\t\t     adapter->set_filter_list, client);\n\n\t\tDBG(\"successfully pre-set filter\");\n\t}\n\n\treturn dbus_message_new_method_return(msg);\n}\n\nstatic DBusMessage *stop_discovery(DBusConnection *conn,\n\t\t\t\t\tDBusMessage *msg, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tconst char *sender = dbus_message_get_sender(msg);\n\tstruct discovery_client *client;\n\tGSList *list;\n\tint err;\n\n\tDBG(\"sender %s\", sender);\n\n\tif (!btd_adapter_get_powered(adapter))\n\t\treturn btd_error_not_ready(msg);\n\n\tlist = g_slist_find_custom(adapter->discovery_list, sender,\n\t\t\t\t\t\tcompare_sender);\n\tif (!list)\n\t\treturn btd_error_failed(msg, \"No discovery started\");\n\n\tclient = list->data;\n\n\tif (client->msg)\n\t\treturn btd_error_busy(msg);\n\n\terr = discovery_stop(client);\n\tswitch (err) {\n\tcase 0:\n\t\treturn dbus_message_new_method_return(msg);\n\tcase -EINPROGRESS:\n\t\tclient->msg = dbus_message_ref(msg);\n\t\tadapter->client = client;\n\t\treturn NULL;\n\tdefault:\n\t\treturn btd_error_failed(msg, strerror(-err));\n\t}\n}\n\nstatic gboolean property_get_address(const GDBusPropertyTable *property,\n\t\t\t\t\tDBusMessageIter *iter, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tchar addr[18];\n\tconst char *str = addr;\n\n\tba2str(&adapter->bdaddr, addr);\n\n\tdbus_message_iter_append_basic(iter, DBUS_TYPE_STRING, &str);\n\n\treturn TRUE;\n}\n\nstatic gboolean property_get_address_type(const GDBusPropertyTable *property,\n\t\t\t\t\tDBusMessageIter *iter, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tconst char *str;\n\n\tif ((adapter->current_settings & MGMT_SETTING_LE) &&\n\t\t\t\t(adapter->bdaddr_type == BDADDR_LE_RANDOM))\n\t\tstr = \"random\";\n\telse\n\t\tstr = \"public\";\n\n\tdbus_message_iter_append_basic(iter, DBUS_TYPE_STRING, &str);\n\n\treturn TRUE;\n}\n\nstatic gboolean property_get_name(const GDBusPropertyTable *property,\n\t\t\t\t\tDBusMessageIter *iter, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tconst char *str = adapter->system_name ? : \"\";\n\n\tdbus_message_iter_append_basic(iter, DBUS_TYPE_STRING, &str);\n\n\treturn TRUE;\n}\n\nstatic gboolean property_get_alias(const GDBusPropertyTable *property,\n\t\t\t\t\tDBusMessageIter *iter, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tconst char *str;\n\n\tif (adapter->current_alias)\n\t\tstr = adapter->current_alias;\n\telse if (adapter->stored_alias)\n\t\tstr = adapter->stored_alias;\n\telse\n\t\tstr = adapter->system_name ? : \"\";\n\n\tdbus_message_iter_append_basic(iter, DBUS_TYPE_STRING, &str);\n\n\treturn TRUE;\n}\n\nstatic void property_set_alias(const GDBusPropertyTable *property,\n\t\t\t\tDBusMessageIter *iter,\n\t\t\t\tGDBusPendingPropertySet id, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tconst char *name;\n\tint ret;\n\n\tdbus_message_iter_get_basic(iter, &name);\n\n\tif (g_str_equal(name, \"\")  == TRUE) {\n\t\tif (adapter->stored_alias == NULL) {\n\t\t\t/* no alias set, nothing to restore */\n\t\t\tg_dbus_pending_property_success(id);\n\t\t\treturn;\n\t\t}\n\n\t\t/* restore to system name */\n\t\tret = set_name(adapter, adapter->system_name);\n\t} else {\n\t\tif (g_strcmp0(adapter->stored_alias, name) == 0) {\n\t\t\t/* alias already set, nothing to do */\n\t\t\tg_dbus_pending_property_success(id);\n\t\t\treturn;\n\t\t}\n\n\t\t/* set to alias */\n\t\tret = set_name(adapter, name);\n\t}\n\n\tif (ret >= 0) {\n\t\tg_free(adapter->stored_alias);\n\n\t\tif (g_str_equal(name, \"\")  == TRUE)\n\t\t\tadapter->stored_alias = NULL;\n\t\telse\n\t\t\tadapter->stored_alias = g_strdup(name);\n\n\t\tstore_adapter_info(adapter);\n\n\t\tg_dbus_pending_property_success(id);\n\t\treturn;\n\t}\n\n\tif (ret == -EINVAL)\n\t\tg_dbus_pending_property_error(id,\n\t\t\t\t\tERROR_INTERFACE \".InvalidArguments\",\n\t\t\t\t\t\"Invalid arguments in method call\");\n\telse\n\t\tg_dbus_pending_property_error(id, ERROR_INTERFACE \".Failed\",\n\t\t\t\t\t\t\tstrerror(-ret));\n}\n\nstatic gboolean property_get_class(const GDBusPropertyTable *property,\n\t\t\t\t\tDBusMessageIter *iter, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tdbus_uint32_t val = adapter->dev_class;\n\n\tdbus_message_iter_append_basic(iter, DBUS_TYPE_UINT32, &val);\n\n\treturn TRUE;\n}\n\nstatic gboolean property_get_mode(struct btd_adapter *adapter,\n\t\t\t\tuint32_t setting, DBusMessageIter *iter)\n{\n\tdbus_bool_t enable;\n\n\tenable = (adapter->current_settings & setting) ? TRUE : FALSE;\n\n\tdbus_message_iter_append_basic(iter, DBUS_TYPE_BOOLEAN, &enable);\n\n\treturn TRUE;\n}\n\nstruct property_set_data {\n\tstruct btd_adapter *adapter;\n\tGDBusPendingPropertySet id;\n};\n\nstatic void property_set_mode_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct property_set_data *data = user_data;\n\tstruct btd_adapter *adapter = data->adapter;\n\n\tDBG(\"%s (0x%02x)\", mgmt_errstr(status), status);\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\tconst char *dbus_err;\n\n\t\tbtd_error(adapter->dev_id, \"Failed to set mode: %s (0x%02x)\",\n\t\t\t\t\t\tmgmt_errstr(status), status);\n\n\t\tif (status == MGMT_STATUS_RFKILLED)\n\t\t\tdbus_err = ERROR_INTERFACE \".Blocked\";\n\t\telse\n\t\t\tdbus_err = ERROR_INTERFACE \".Failed\";\n\n\t\tg_dbus_pending_property_error(data->id, dbus_err,\n\t\t\t\t\t\t\tmgmt_errstr(status));\n\t\treturn;\n\t}\n\n\tg_dbus_pending_property_success(data->id);\n\n\t/*\n\t * The parameters are identical and also the task that is\n\t * required in both cases. So it is safe to just call the\n\t * event handling functions here.\n\t */\n\tnew_settings_callback(adapter->dev_id, length, param, adapter);\n}\n\nstatic void clear_discoverable(struct btd_adapter *adapter)\n{\n\tif (!btd_has_kernel_features(KERNEL_CONN_CONTROL))\n\t\treturn;\n\n\tif (!(adapter->current_settings & MGMT_SETTING_DISCOVERABLE))\n\t\treturn;\n\n\t/* If no timeout is set do nothing as both connectable and discoverable\n\t * flags are persistent on power toggle.\n\t */\n\tif (!adapter->discoverable_timeout)\n\t\treturn;\n\n\t/* If timeout was set kernel clears discoverable on its own when\n\t * powering off controller. This would leave connectable flag set\n\t * after power on.\n\t *\n\t * With kernel control clearing connectable clear also discoverable\n\t * flag so we need to clear connectable.\n\t */\n\tset_mode(adapter, MGMT_OP_SET_CONNECTABLE, 0x00);\n}\n\nstatic void property_set_mode(struct btd_adapter *adapter, uint32_t setting,\n\t\t\t\t\t\tDBusMessageIter *value,\n\t\t\t\t\t\tGDBusPendingPropertySet id)\n{\n\tstruct property_set_data *data;\n\tstruct mgmt_cp_set_discoverable cp;\n\tvoid *param;\n\tdbus_bool_t enable, current_enable;\n\tuint16_t opcode, len;\n\tuint8_t mode;\n\n\tdbus_message_iter_get_basic(value, &enable);\n\n\tif (adapter->pending_settings & setting) {\n\t\tg_dbus_pending_property_error(id, ERROR_INTERFACE \".Busy\",\n\t\t\t\t\t\tNULL);\n\t\treturn;\n\t}\n\n\tif (adapter->current_settings & setting)\n\t\tcurrent_enable = TRUE;\n\telse\n\t\tcurrent_enable = FALSE;\n\n\tif (enable == current_enable) {\n\t\tg_dbus_pending_property_success(id);\n\t\treturn;\n\t}\n\n\tmode = (enable == TRUE) ? 0x01 : 0x00;\n\n\tadapter->pending_settings |= setting;\n\n\tswitch (setting) {\n\tcase MGMT_SETTING_POWERED:\n\t\topcode = MGMT_OP_SET_POWERED;\n\t\tparam = &mode;\n\t\tlen = sizeof(mode);\n\n\t\tif (!mode) {\n\t\t\tclear_discoverable(adapter);\n\t\t\tremove_temporary_devices(adapter);\n\t\t}\n\n\t\tbreak;\n\tcase MGMT_SETTING_DISCOVERABLE:\n\t\tif (btd_has_kernel_features(KERNEL_CONN_CONTROL)) {\n\t\t\tif (mode) {\n\t\t\t\tset_mode(adapter, MGMT_OP_SET_CONNECTABLE,\n\t\t\t\t\t\t\t\t\tmode);\n\t\t\t} else {\n\t\t\t\topcode = MGMT_OP_SET_CONNECTABLE;\n\t\t\t\tparam = &mode;\n\t\t\t\tlen = sizeof(mode);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tmemset(&cp, 0, sizeof(cp));\n\t\tcp.val = mode;\n\t\tif (cp.val)\n\t\t\tcp.timeout = htobs(adapter->discoverable_timeout);\n\n\t\topcode = MGMT_OP_SET_DISCOVERABLE;\n\t\tparam = &cp;\n\t\tlen = sizeof(cp);\n\t\tbreak;\n\tcase MGMT_SETTING_BONDABLE:\n\t\topcode = MGMT_OP_SET_BONDABLE;\n\t\tparam = &mode;\n\t\tlen = sizeof(mode);\n\t\tbreak;\n\tdefault:\n\t\tgoto failed;\n\t}\n\n\tDBG(\"sending %s command for index %u\", mgmt_opstr(opcode),\n\t\t\t\t\t\t\tadapter->dev_id);\n\n\tdata = g_try_new0(struct property_set_data, 1);\n\tif (!data)\n\t\tgoto failed;\n\n\tdata->adapter = adapter;\n\tdata->id = id;\n\n\tif (mgmt_send(adapter->mgmt, opcode, adapter->dev_id, len, param,\n\t\t\tproperty_set_mode_complete, data, g_free) > 0)\n\t\treturn;\n\n\tg_free(data);\n\nfailed:\n\tbtd_error(adapter->dev_id, \"Failed to set mode for index %u\",\n\t\t\t\t\t\t\tadapter->dev_id);\n\n\tg_dbus_pending_property_error(id, ERROR_INTERFACE \".Failed\", NULL);\n}\n\nstatic gboolean property_get_powered(const GDBusPropertyTable *property,\n\t\t\t\t\tDBusMessageIter *iter, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\treturn property_get_mode(adapter, MGMT_SETTING_POWERED, iter);\n}\n\nstatic void property_set_powered(const GDBusPropertyTable *property,\n\t\t\t\tDBusMessageIter *iter,\n\t\t\t\tGDBusPendingPropertySet id, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\tif (powering_down) {\n\t\tg_dbus_pending_property_error(id, ERROR_INTERFACE \".Failed\",\n\t\t\t\t\t\t\t\"Powering down\");\n\t\treturn;\n\t}\n\n\tproperty_set_mode(adapter, MGMT_SETTING_POWERED, iter, id);\n}\n\nstatic gboolean property_get_discoverable(const GDBusPropertyTable *property,\n\t\t\t\t\tDBusMessageIter *iter, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\treturn property_get_mode(adapter, MGMT_SETTING_DISCOVERABLE, iter);\n}\n\nstatic void property_set_discoverable(const GDBusPropertyTable *property,\n\t\t\t\tDBusMessageIter *iter,\n\t\t\t\tGDBusPendingPropertySet id, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\tif (adapter->discoverable_timeout > 0 &&\n\t\t\t!btd_adapter_get_powered(adapter)) {\n\t\tg_dbus_pending_property_error(id, ERROR_INTERFACE \".Failed\",\n\t\t\t\t\t\t\t\t\"Not Powered\");\n\t\treturn;\n\t}\n\n\t/* Reset discovery_discoverable as Discoverable takes precedence */\n\tadapter->discovery_discoverable = false;\n\n\tproperty_set_mode(adapter, MGMT_SETTING_DISCOVERABLE, iter, id);\n}\n\nstatic gboolean property_get_discoverable_timeout(\n\t\t\t\t\tconst GDBusPropertyTable *property,\n\t\t\t\t\tDBusMessageIter *iter, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tdbus_uint32_t value = adapter->discoverable_timeout;\n\n\tdbus_message_iter_append_basic(iter, DBUS_TYPE_UINT32, &value);\n\n\treturn TRUE;\n}\n\nstatic void property_set_discoverable_timeout(\n\t\t\t\tconst GDBusPropertyTable *property,\n\t\t\t\tDBusMessageIter *iter,\n\t\t\t\tGDBusPendingPropertySet id, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tbool enabled;\n\tdbus_uint32_t value;\n\n\tdbus_message_iter_get_basic(iter, &value);\n\n\tadapter->discoverable_timeout = value;\n\n\tg_dbus_pending_property_success(id);\n\n\tstore_adapter_info(adapter);\n\n\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\tADAPTER_INTERFACE, \"DiscoverableTimeout\");\n\n\tif (adapter->pending_settings & MGMT_SETTING_DISCOVERABLE) {\n\t\tif (adapter->current_settings & MGMT_SETTING_DISCOVERABLE)\n\t\t\tenabled = false;\n\t\telse\n\t\t\tenabled = true;\n\t} else {\n\t\tif (adapter->current_settings & MGMT_SETTING_DISCOVERABLE)\n\t\t\tenabled = true;\n\t\telse\n\t\t\tenabled = false;\n\t}\n\n\tif (enabled)\n\t\tset_discoverable(adapter, 0x01, adapter->discoverable_timeout);\n}\n\nstatic gboolean property_get_pairable(const GDBusPropertyTable *property,\n\t\t\t\t\tDBusMessageIter *iter, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\treturn property_get_mode(adapter, MGMT_SETTING_BONDABLE, iter);\n}\n\nstatic void property_set_pairable(const GDBusPropertyTable *property,\n\t\t\t\tDBusMessageIter *iter,\n\t\t\t\tGDBusPendingPropertySet id, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\tproperty_set_mode(adapter, MGMT_SETTING_BONDABLE, iter, id);\n}\n\nstatic gboolean property_get_pairable_timeout(\n\t\t\t\t\tconst GDBusPropertyTable *property,\n\t\t\t\t\tDBusMessageIter *iter, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tdbus_uint32_t value = adapter->pairable_timeout;\n\n\tdbus_message_iter_append_basic(iter, DBUS_TYPE_UINT32, &value);\n\n\treturn TRUE;\n}\n\nstatic void property_set_pairable_timeout(const GDBusPropertyTable *property,\n\t\t\t\tDBusMessageIter *iter,\n\t\t\t\tGDBusPendingPropertySet id, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tdbus_uint32_t value;\n\n\tdbus_message_iter_get_basic(iter, &value);\n\n\tadapter->pairable_timeout = value;\n\n\tg_dbus_pending_property_success(id);\n\n\tstore_adapter_info(adapter);\n\n\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"PairableTimeout\");\n\n\ttrigger_pairable_timeout(adapter);\n}\n\nstatic gboolean property_get_discovering(const GDBusPropertyTable *property,\n\t\t\t\t\tDBusMessageIter *iter, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tdbus_bool_t discovering = adapter->discovering;\n\n\tdbus_message_iter_append_basic(iter, DBUS_TYPE_BOOLEAN, &discovering);\n\n\treturn TRUE;\n}\n\nstatic void add_gatt_uuid(struct gatt_db_attribute *attrib, void *user_data)\n{\n\tGHashTable *uuids = user_data;\n\tbt_uuid_t uuid, u128;\n\tchar uuidstr[MAX_LEN_UUID_STR + 1];\n\n\tif (!gatt_db_service_get_active(attrib))\n\t\treturn;\n\n\tif (!gatt_db_attribute_get_service_uuid(attrib, &uuid))\n\t\treturn;\n\n\tbt_uuid_to_uuid128(&uuid, &u128);\n\tbt_uuid_to_string(&u128, uuidstr, sizeof(uuidstr));\n\n\tg_hash_table_add(uuids, strdup(uuidstr));\n}\n\nstatic void iter_append_uuid(gpointer key, gpointer value, gpointer user_data)\n{\n\tDBusMessageIter *iter = user_data;\n\tconst char *uuid = key;\n\n\tdbus_message_iter_append_basic(iter, DBUS_TYPE_STRING, &uuid);\n}\n\nstatic gboolean property_get_uuids(const GDBusPropertyTable *property,\n\t\t\t\t\tDBusMessageIter *iter, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tDBusMessageIter entry;\n\tsdp_list_t *l;\n\tstruct gatt_db *db;\n\tGHashTable *uuids;\n\n\tuuids = g_hash_table_new_full(g_str_hash, g_str_equal, free, NULL);\n\tif (!uuids)\n\t\treturn FALSE;\n\n\t/* SDP records */\n\tfor (l = adapter->services; l != NULL; l = l->next) {\n\t\tsdp_record_t *rec = l->data;\n\t\tchar *uuid;\n\n\t\tuuid = bt_uuid2string(&rec->svclass);\n\t\tif (uuid == NULL)\n\t\t\tcontinue;\n\n\t\tg_hash_table_add(uuids, uuid);\n\t}\n\n\t/* GATT services */\n\tdb = btd_gatt_database_get_db(adapter->database);\n\tif (db)\n\t\tgatt_db_foreach_service(db, NULL, add_gatt_uuid, uuids);\n\n\tdbus_message_iter_open_container(iter, DBUS_TYPE_ARRAY,\n\t\t\t\t\tDBUS_TYPE_STRING_AS_STRING, &entry);\n\tg_hash_table_foreach(uuids, iter_append_uuid, &entry);\n\tdbus_message_iter_close_container(iter, &entry);\n\n\tg_hash_table_destroy(uuids);\n\n\treturn TRUE;\n}\n\nstatic gboolean property_exists_modalias(const GDBusPropertyTable *property,\n\t\t\t\t\t\t\tvoid *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\treturn adapter->modalias ? TRUE : FALSE;\n}\n\nstatic gboolean property_get_modalias(const GDBusPropertyTable *property,\n\t\t\t\t\tDBusMessageIter *iter, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tconst char *str = adapter->modalias ? : \"\";\n\n\tdbus_message_iter_append_basic(iter, DBUS_TYPE_STRING, &str);\n\n\treturn TRUE;\n}\n\nstatic gboolean property_get_roles(const GDBusPropertyTable *property,\n\t\t\t\t\tDBusMessageIter *iter, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tDBusMessageIter entry;\n\n\tdbus_message_iter_open_container(iter, DBUS_TYPE_ARRAY,\n\t\t\t\t\tDBUS_TYPE_STRING_AS_STRING, &entry);\n\n\tif (adapter->supported_settings & MGMT_SETTING_LE) {\n\t\tconst char *str = \"central\";\n\t\tdbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &str);\n\t}\n\n\tif (adapter->supported_settings & MGMT_SETTING_ADVERTISING) {\n\t\tconst char *str = \"peripheral\";\n\t\tdbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &str);\n\t}\n\n\tif (adapter->le_simult_roles_supported) {\n\t\tconst char *str = \"central-peripheral\";\n\t\tdbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &str);\n\t}\n\n\tdbus_message_iter_close_container(iter, &entry);\n\n\treturn TRUE;\n}\n\nstatic DBusMessage *remove_device(DBusConnection *conn,\n\t\t\t\t\tDBusMessage *msg, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tstruct btd_device *device;\n\tconst char *path;\n\tGSList *list;\n\n\tif (dbus_message_get_args(msg, NULL, DBUS_TYPE_OBJECT_PATH, &path,\n\t\t\t\t\t\tDBUS_TYPE_INVALID) == FALSE)\n\t\treturn btd_error_invalid_args(msg);\n\n\tlist = g_slist_find_custom(adapter->devices, path, device_path_cmp);\n\tif (!list)\n\t\treturn btd_error_does_not_exist(msg);\n\n\tif (!btd_adapter_get_powered(adapter))\n\t\treturn btd_error_not_ready(msg);\n\n\tdevice = list->data;\n\n\tbtd_device_set_temporary(device, true);\n\n\tif (!btd_device_is_connected(device)) {\n\t\tbtd_adapter_remove_device(adapter, device);\n\t\treturn dbus_message_new_method_return(msg);\n\t}\n\n\tdevice_request_disconnect(device, msg);\n\n\treturn NULL;\n}\n\nstatic DBusMessage *get_discovery_filters(DBusConnection *conn,\n\t\t\t\t\tDBusMessage *msg, void *user_data)\n{\n\tDBusMessage *reply;\n\tDBusMessageIter iter, array;\n\tstruct filter_parser *parser;\n\n\treply = dbus_message_new_method_return(msg);\n\n\tdbus_message_iter_init_append(reply, &iter);\n\n\tdbus_message_iter_open_container(&iter, DBUS_TYPE_ARRAY,\n\t\t\t\t\tDBUS_TYPE_STRING_AS_STRING, &array);\n\n\tfor (parser = parsers; parser && parser->name; parser++) {\n\t\tdbus_message_iter_append_basic(&array, DBUS_TYPE_STRING,\n\t\t\t\t\t\t\t&parser->name);\n\t}\n\n\tdbus_message_iter_close_container(&iter, &array);\n\n\treturn reply;\n}\n\nstruct device_connect_data {\n\tstruct btd_adapter *adapter;\n\tbdaddr_t dst;\n\tuint8_t dst_type;\n\tDBusMessage *msg;\n};\n\nstatic void device_browse_cb(struct btd_device *dev, int err, void *user_data)\n{\n\tDBG(\"err %d (%s)\", err, strerror(-err));\n\n\tif (!err)\n\t\tbtd_device_connect_services(dev, NULL);\n}\n\nstatic void device_connect_cb(GIOChannel *io, GError *gerr, gpointer user_data)\n{\n\tstruct device_connect_data *data = user_data;\n\tstruct btd_adapter *adapter = data->adapter;\n\tstruct btd_device *device;\n\tconst char *path;\n\n\tDBG(\"%s\", gerr ? gerr->message : \"\");\n\n\tif (gerr)\n\t\tgoto failed;\n\n\t/* object might already exist due to mgmt socket event */\n\tdevice = btd_adapter_get_device(adapter, &data->dst, data->dst_type);\n\tif (!device)\n\t\tgoto failed;\n\n\tpath = device_get_path(device);\n\n\tg_dbus_send_reply(dbus_conn, data->msg, DBUS_TYPE_OBJECT_PATH, &path,\n\t\t\t\t\t\t\tDBUS_TYPE_INVALID);\n\n\t/* continue with service discovery and connection */\n\tbtd_device_set_temporary(device, false);\n\tdevice_update_last_seen(device, data->dst_type);\n\n\tif (data->dst_type != BDADDR_BREDR){\n\t\tg_io_channel_set_close_on_unref(io, FALSE);\n\t\tdevice_attach_att(device, io);\n\t}\n\n\tdevice_discover_services(device);\n\tdevice_wait_for_svc_complete(device, device_browse_cb, NULL);\n\n\tg_io_channel_unref(io);\n\tdbus_message_unref(data->msg);\n\tfree(data);\n\treturn;\n\nfailed:\n\tg_dbus_send_error(dbus_conn, data->msg, \"org.bluez.Failed\", NULL);\n\tg_io_channel_unref(io);\n\tdbus_message_unref(data->msg);\n\tfree(data);\n}\n\nstatic void device_connect(struct btd_adapter *adapter, const bdaddr_t *dst,\n\t\t\t\t\tuint8_t dst_type, DBusMessage *msg)\n{\n\tstruct device_connect_data *data;\n\tGIOChannel *io;\n\n\tdata = new0(struct device_connect_data, 1);\n\tdata->adapter = adapter;\n\tbacpy(&data->dst, dst);\n\tdata->dst_type = dst_type;\n\tdata->msg = dbus_message_ref(msg);\n\n\tif (dst_type == BDADDR_BREDR)\n\t\tio = bt_io_connect(device_connect_cb, data, NULL, NULL,\n\t\t\t\tBT_IO_OPT_SOURCE_BDADDR, &adapter->bdaddr,\n\t\t\t\tBT_IO_OPT_SOURCE_TYPE, BDADDR_BREDR,\n\t\t\t\tBT_IO_OPT_DEST_BDADDR, dst,\n\t\t\t\tBT_IO_OPT_DEST_TYPE, BDADDR_BREDR,\n\t\t\t\tBT_IO_OPT_PSM, SDP_PSM,\n\t\t\t\tBT_IO_OPT_SEC_LEVEL, BT_IO_SEC_LOW,\n\t\t\t\tBT_IO_OPT_INVALID);\n\telse\n\t\tio = bt_io_connect(device_connect_cb, data, NULL, NULL,\n\t\t\t\tBT_IO_OPT_SOURCE_BDADDR, &adapter->bdaddr,\n\t\t\t\tBT_IO_OPT_SOURCE_TYPE, adapter->bdaddr_type,\n\t\t\t\tBT_IO_OPT_DEST_BDADDR, dst,\n\t\t\t\tBT_IO_OPT_DEST_TYPE, dst_type,\n\t\t\t\tBT_IO_OPT_CID, ATT_CID,\n\t\t\t\tBT_IO_OPT_SEC_LEVEL, BT_IO_SEC_LOW,\n\t\t\t\tBT_IO_OPT_INVALID);\n\n\tif (!io) {\n\t\tg_dbus_send_message(dbus_conn,\n\t\t\t\tbtd_error_failed(msg, \"Connect failed\"));\n\t\tdbus_message_unref(data->msg);\n\t\tfree(data);\n\t}\n}\n\nstatic DBusMessage *connect_device(DBusConnection *conn,\n\t\t\t\t\tDBusMessage *msg, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tDBusMessageIter iter, subiter, dictiter, value;\n\tuint8_t addr_type = BDADDR_BREDR;\n\tbdaddr_t addr = *BDADDR_ANY;\n\n\tDBG(\"sender %s\", dbus_message_get_sender(msg));\n\n\tif (!btd_adapter_get_powered(adapter))\n\t\treturn btd_error_not_ready(msg);\n\n\tdbus_message_iter_init(msg, &iter);\n\tif (dbus_message_iter_get_arg_type(&iter) != DBUS_TYPE_ARRAY ||\n\t    dbus_message_iter_get_element_type(&iter) != DBUS_TYPE_DICT_ENTRY)\n\t\treturn btd_error_invalid_args(msg);\n\n\tdbus_message_iter_recurse(&iter, &subiter);\n\twhile (true) {\n\t\tint type = dbus_message_iter_get_arg_type(&subiter);\n\t\tchar *key;\n\t\tchar *str;\n\n\t\tif (type == DBUS_TYPE_INVALID)\n\t\t\tbreak;\n\n\t\tdbus_message_iter_recurse(&subiter, &dictiter);\n\n\t\tdbus_message_iter_get_basic(&dictiter, &key);\n\t\tif (!dbus_message_iter_next(&dictiter))\n\t\t\treturn btd_error_invalid_args(msg);\n\n\t\tif (dbus_message_iter_get_arg_type(&dictiter) !=\n\t\t\t\t\t\t\tDBUS_TYPE_VARIANT)\n\t\t\treturn btd_error_invalid_args(msg);\n\n\t\tdbus_message_iter_recurse(&dictiter, &value);\n\n\t\tif (!strcmp(key, \"Address\")) {\n\t\t\tif (dbus_message_iter_get_arg_type(&value) !=\n\t\t\t\t\t\t\tDBUS_TYPE_STRING)\n\t\t\t\treturn btd_error_invalid_args(msg);\n\n\t\t\tdbus_message_iter_get_basic(&value, &str);\n\n\t\t\tif (str2ba(str, &addr) < 0 )\n\t\t\t\treturn btd_error_invalid_args(msg);\n\t\t} else if (!strcmp(key, \"AddressType\")) {\n\t\t\tif (dbus_message_iter_get_arg_type(&value) !=\n\t\t\t\t\t\t\tDBUS_TYPE_STRING)\n\t\t\t\treturn btd_error_invalid_args(msg);\n\n\t\t\tdbus_message_iter_get_basic(&value, &str);\n\n\n\t\t\tif (!strcmp(str, \"public\"))\n\t\t\t\taddr_type = BDADDR_LE_PUBLIC;\n\t\t\telse if (!strcmp(str, \"random\"))\n\t\t\t\taddr_type = BDADDR_LE_RANDOM;\n\t\t\telse\n\t\t\t\treturn btd_error_invalid_args(msg);\n\t\t} else {\n\t\t\treturn btd_error_invalid_args(msg);\n\t\t}\n\n\t\tdbus_message_iter_next(&subiter);\n\t}\n\n\tif (!bacmp(&addr, BDADDR_ANY))\n\t\treturn btd_error_invalid_args(msg);\n\n\tif (btd_adapter_find_device(adapter, &addr, addr_type))\n\t\treturn btd_error_already_exists(msg);\n\n\tdevice_connect(adapter, &addr, addr_type, msg);\n\treturn NULL;\n}\n\nstatic const GDBusMethodTable adapter_methods[] = {\n\t{ GDBUS_ASYNC_METHOD(\"StartDiscovery\", NULL, NULL, start_discovery) },\n\t{ GDBUS_METHOD(\"SetDiscoveryFilter\",\n\t\t\t\tGDBUS_ARGS({ \"properties\", \"a{sv}\" }), NULL,\n\t\t\t\tset_discovery_filter) },\n\t{ GDBUS_ASYNC_METHOD(\"StopDiscovery\", NULL, NULL, stop_discovery) },\n\t{ GDBUS_ASYNC_METHOD(\"RemoveDevice\",\n\t\t\tGDBUS_ARGS({ \"device\", \"o\" }), NULL, remove_device) },\n\t{ GDBUS_METHOD(\"GetDiscoveryFilters\", NULL,\n\t\t\tGDBUS_ARGS({ \"filters\", \"as\" }),\n\t\t\tget_discovery_filters) },\n\t{ GDBUS_EXPERIMENTAL_ASYNC_METHOD(\"ConnectDevice\",\n\t\t\t\tGDBUS_ARGS({ \"properties\", \"a{sv}\" }), NULL,\n\t\t\t\tconnect_device) },\n\t{ }\n};\n\nstatic const GDBusPropertyTable adapter_properties[] = {\n\t{ \"Address\", \"s\", property_get_address },\n\t{ \"AddressType\", \"s\", property_get_address_type },\n\t{ \"Name\", \"s\", property_get_name },\n\t{ \"Alias\", \"s\", property_get_alias, property_set_alias },\n\t{ \"Class\", \"u\", property_get_class },\n\t{ \"Powered\", \"b\", property_get_powered, property_set_powered },\n\t{ \"Discoverable\", \"b\", property_get_discoverable,\n\t\t\t\t\tproperty_set_discoverable },\n\t{ \"DiscoverableTimeout\", \"u\", property_get_discoverable_timeout,\n\t\t\t\t\tproperty_set_discoverable_timeout },\n\t{ \"Pairable\", \"b\", property_get_pairable, property_set_pairable },\n\t{ \"PairableTimeout\", \"u\", property_get_pairable_timeout,\n\t\t\t\t\tproperty_set_pairable_timeout },\n\t{ \"Discovering\", \"b\", property_get_discovering },\n\t{ \"UUIDs\", \"as\", property_get_uuids },\n\t{ \"Modalias\", \"s\", property_get_modalias, NULL,\n\t\t\t\t\tproperty_exists_modalias },\n\t{ \"Roles\", \"as\", property_get_roles },\n\t{ }\n};\n\nstatic int str2buf(const char *str, uint8_t *buf, size_t blen)\n{\n\tint i, dlen;\n\n\tif (str == NULL)\n\t\treturn -EINVAL;\n\n\tmemset(buf, 0, blen);\n\n\tdlen = MIN((strlen(str) / 2), blen);\n\n\tfor (i = 0; i < dlen; i++)\n\t\tsscanf(str + (i * 2), \"%02hhX\", &buf[i]);\n\n\treturn 0;\n}\n\nstatic bool is_blocked_key(uint8_t key_type, uint8_t *key_value)\n{\n\tuint32_t i = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(blocked_keys); ++i) {\n\t\tif (key_type == blocked_keys[i].type &&\n\t\t\t\t!memcmp(blocked_keys[i].val, key_value,\n\t\t\t\t\t\tsizeof(blocked_keys[i].val)))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic struct link_key_info *get_key_info(GKeyFile *key_file, const char *peer)\n{\n\tstruct link_key_info *info = NULL;\n\tchar *str;\n\n\tstr = g_key_file_get_string(key_file, \"LinkKey\", \"Key\", NULL);\n\tif (!str || strlen(str) < 32)\n\t\tgoto failed;\n\n\tinfo = g_new0(struct link_key_info, 1);\n\n\tstr2ba(peer, &info->bdaddr);\n\n\tif (!strncmp(str, \"0x\", 2))\n\t\tstr2buf(&str[2], info->key, sizeof(info->key));\n\telse\n\t\tstr2buf(&str[0], info->key, sizeof(info->key));\n\n\tinfo->type = g_key_file_get_integer(key_file, \"LinkKey\", \"Type\", NULL);\n\tinfo->pin_len = g_key_file_get_integer(key_file, \"LinkKey\", \"PINLength\",\n\t\t\t\t\t\tNULL);\n\n\tinfo->is_blocked = is_blocked_key(HCI_BLOCKED_KEY_TYPE_LINKKEY,\n\t\t\t\t\t\t\t\tinfo->key);\n\nfailed:\n\tg_free(str);\n\n\treturn info;\n}\n\nstatic struct smp_ltk_info *get_ltk(GKeyFile *key_file, const char *peer,\n\t\t\t\t\tuint8_t peer_type, const char *group)\n{\n\tstruct smp_ltk_info *ltk = NULL;\n\tGError *gerr = NULL;\n\tbool master;\n\tchar *key;\n\tchar *rand = NULL;\n\n\tkey = g_key_file_get_string(key_file, group, \"Key\", NULL);\n\tif (!key || strlen(key) < 32)\n\t\tgoto failed;\n\n\trand = g_key_file_get_string(key_file, group, \"Rand\", NULL);\n\tif (!rand)\n\t\tgoto failed;\n\n\tltk = g_new0(struct smp_ltk_info, 1);\n\n\t/* Default to assuming a master key */\n\tltk->master = true;\n\n\tstr2ba(peer, &ltk->bdaddr);\n\tltk->bdaddr_type = peer_type;\n\n\t/*\n\t * Long term keys should respond to an identity address which can\n\t * either be a public address or a random static address. Keys\n\t * stored for resolvable random and unresolvable random addresses\n\t * are ignored.\n\t *\n\t * This is an extra sanity check for older kernel versions or older\n\t * daemons that might have been instructed to store long term keys\n\t * for these temporary addresses.\n\t */\n\tif (ltk->bdaddr_type == BDADDR_LE_RANDOM &&\n\t\t\t\t\t(ltk->bdaddr.b[5] & 0xc0) != 0xc0) {\n\t\tg_free(ltk);\n\t\tltk = NULL;\n\t\tgoto failed;\n\t}\n\n\tif (!strncmp(key, \"0x\", 2))\n\t\tstr2buf(&key[2], ltk->val, sizeof(ltk->val));\n\telse\n\t\tstr2buf(&key[0], ltk->val, sizeof(ltk->val));\n\n\tif (!strncmp(rand, \"0x\", 2)) {\n\t\tuint64_t rand_le;\n\t\tstr2buf(&rand[2], (uint8_t *) &rand_le, sizeof(rand_le));\n\t\tltk->rand = le64_to_cpu(rand_le);\n\t} else {\n\t\tsscanf(rand, \"%\" PRIu64, &ltk->rand);\n\t}\n\n\tltk->authenticated = g_key_file_get_integer(key_file, group,\n\t\t\t\t\t\t\t\"Authenticated\", NULL);\n\tltk->enc_size = g_key_file_get_integer(key_file, group, \"EncSize\",\n\t\t\t\t\t\t\t\t\tNULL);\n\tltk->ediv = g_key_file_get_integer(key_file, group, \"EDiv\", NULL);\n\n\tmaster = g_key_file_get_boolean(key_file, group, \"Master\", &gerr);\n\tif (gerr)\n\t\tg_error_free(gerr);\n\telse\n\t\tltk->master = master;\n\n\tltk->is_blocked = is_blocked_key(HCI_BLOCKED_KEY_TYPE_LTK,\n\t\t\t\t\t\t\t\tltk->val);\n\nfailed:\n\tg_free(key);\n\tg_free(rand);\n\n\treturn ltk;\n}\n\nstatic struct smp_ltk_info *get_ltk_info(GKeyFile *key_file, const char *peer,\n\t\t\t\t\t\t\tuint8_t bdaddr_type)\n{\n\tDBG(\"%s\", peer);\n\n\treturn get_ltk(key_file, peer, bdaddr_type, \"LongTermKey\");\n}\n\nstatic struct smp_ltk_info *get_slave_ltk_info(GKeyFile *key_file,\n\t\t\t\t\t\t\tconst char *peer,\n\t\t\t\t\t\t\tuint8_t bdaddr_type)\n{\n\tstruct smp_ltk_info *ltk;\n\n\tDBG(\"%s\", peer);\n\n\tltk = get_ltk(key_file, peer, bdaddr_type, \"SlaveLongTermKey\");\n\tif (ltk)\n\t\tltk->master = false;\n\n\treturn ltk;\n}\n\nstatic struct irk_info *get_irk_info(GKeyFile *key_file, const char *peer,\n\t\t\t\t\t\t\tuint8_t bdaddr_type)\n{\n\tstruct irk_info *irk = NULL;\n\tchar *str;\n\n\tstr = g_key_file_get_string(key_file, \"IdentityResolvingKey\", \"Key\", NULL);\n\tif (!str || strlen(str) < 32)\n\t\tgoto failed;\n\n\tirk = g_new0(struct irk_info, 1);\n\n\tstr2ba(peer, &irk->bdaddr);\n\tirk->bdaddr_type = bdaddr_type;\n\n\tif (!strncmp(str, \"0x\", 2))\n\t\tstr2buf(&str[2], irk->val, sizeof(irk->val));\n\telse\n\t\tstr2buf(&str[0], irk->val, sizeof(irk->val));\n\n\tirk->is_blocked = is_blocked_key(HCI_BLOCKED_KEY_TYPE_LINKKEY,\n\t\t\t\t\t\t\t\tirk->val);\n\nfailed:\n\tg_free(str);\n\n\treturn irk;\n}\n\nstatic struct conn_param *get_conn_param(GKeyFile *key_file, const char *peer,\n\t\t\t\t\t\t\tuint8_t bdaddr_type)\n{\n\tstruct conn_param *param;\n\n\tif (!g_key_file_has_group(key_file, \"ConnectionParameters\"))\n\t\treturn NULL;\n\n\tparam = g_new0(struct conn_param, 1);\n\n\tparam->min_interval = g_key_file_get_integer(key_file,\n\t\t\t\t\t\t\t\"ConnectionParameters\",\n\t\t\t\t\t\t\t\"MinInterval\", NULL);\n\tparam->max_interval = g_key_file_get_integer(key_file,\n\t\t\t\t\t\t\t\"ConnectionParameters\",\n\t\t\t\t\t\t\t\"MaxInterval\", NULL);\n\tparam->latency = g_key_file_get_integer(key_file,\n\t\t\t\t\t\t\t\"ConnectionParameters\",\n\t\t\t\t\t\t\t\"Latency\", NULL);\n\tparam->timeout = g_key_file_get_integer(key_file,\n\t\t\t\t\t\t\t\"ConnectionParameters\",\n\t\t\t\t\t\t\t\"Timeout\", NULL);\n\tstr2ba(peer, &param->bdaddr);\n\tparam->bdaddr_type = bdaddr_type;\n\n\treturn param;\n}\n\nstatic int generate_and_write_irk(uint8_t *irk, GKeyFile *key_file,\n\t\t\t\t\t\t\tconst char *filename)\n{\n\tstruct bt_crypto *crypto;\n\tchar str_irk_out[33];\n\tgsize length = 0;\n\tchar *str;\n\tint i;\n\n\tcrypto = bt_crypto_new();\n\tif (!crypto) {\n\t\terror(\"Failed to open crypto\");\n\t\treturn -1;\n\t}\n\n\tif (!bt_crypto_random_bytes(crypto, irk, 16)) {\n\t\terror(\"Failed to generate IRK\");\n\t\tbt_crypto_unref(crypto);\n\t\treturn -1;\n\t}\n\n\tbt_crypto_unref(crypto);\n\n\tfor (i = 0; i < 16; i++)\n\t\tsprintf(str_irk_out + (i * 2), \"%02x\", irk[i]);\n\n\tstr_irk_out[32] = '\\0';\n\tinfo(\"Generated IRK successfully\");\n\n\tg_key_file_set_string(key_file, \"General\", \"IdentityResolvingKey\",\n\t\t\t\t\t\t\t\tstr_irk_out);\n\tstr = g_key_file_to_data(key_file, &length, NULL);\n\tg_file_set_contents(filename, str, length, NULL);\n\tg_free(str);\n\tDBG(\"Generated IRK written to file\");\n\treturn 0;\n}\n\nstatic int load_irk(struct btd_adapter *adapter, uint8_t *irk)\n{\n\tchar filename[PATH_MAX];\n\tGKeyFile *key_file;\n\tchar *str_irk;\n\tint ret;\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/identity\",\n\t\t\t\t\tbtd_adapter_get_storage_dir(adapter));\n\n\tkey_file = g_key_file_new();\n\tg_key_file_load_from_file(key_file, filename, 0, NULL);\n\n\tstr_irk = g_key_file_get_string(key_file, \"General\",\n\t\t\t\t\t\t\"IdentityResolvingKey\", NULL);\n\tif (!str_irk) {\n\t\tinfo(\"No IRK stored\");\n\t\tret = generate_and_write_irk(irk, key_file, filename);\n\t\tg_key_file_free(key_file);\n\t\treturn ret;\n\t}\n\n\tg_key_file_free(key_file);\n\n\tif (strlen(str_irk) != 32 || str2buf(str_irk, irk, 16)) {\n\t\t/* TODO re-create new IRK here? */\n\t\terror(\"Invalid IRK format, disabling privacy\");\n\t\tg_free(str_irk);\n\t\treturn -1;\n\t}\n\n\tg_free(str_irk);\n\tDBG(\"Successfully read IRK from file\");\n\treturn 0;\n}\n\nstatic void set_privacy_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\tbtd_error(adapter->dev_id, \"Failed to set privacy: %s (0x%02x)\",\n\t\t\t\t\t\tmgmt_errstr(status), status);\n\t\treturn;\n\t}\n\n\tDBG(\"Successfuly set privacy for index %u\", adapter->dev_id);\n}\n\nstatic int set_privacy(struct btd_adapter *adapter, uint8_t privacy)\n{\n\tstruct mgmt_cp_set_privacy cp;\n\n\tmemset(&cp, 0, sizeof(cp));\n\n\tif (privacy) {\n\t\tuint8_t irk[16];\n\n\t\tif (load_irk(adapter, irk) == 0) {\n\t\t\tcp.privacy = privacy;\n\t\t\tmemcpy(cp.irk, irk, 16);\n\t\t}\n\t}\n\n\tDBG(\"sending set privacy command for index %u\", adapter->dev_id);\n\tDBG(\"setting privacy mode 0x%02x for index %u\", cp.privacy,\n\t\t\t\t\t\t\tadapter->dev_id);\n\n\tif (mgmt_send(adapter->mgmt, MGMT_OP_SET_PRIVACY,\n\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\tset_privacy_complete, adapter, NULL) > 0)\n\t\treturn 0;\n\n\tbtd_error(adapter->dev_id, \"Failed to set privacy for index %u\",\n\t\t\t\t\t\t\tadapter->dev_id);\n\n\treturn -1;\n}\n\nstatic void load_link_keys_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\"Failed to load link keys for hci%u: %s (0x%02x)\",\n\t\t\t\tadapter->dev_id, mgmt_errstr(status), status);\n\t\treturn;\n\t}\n\n\tDBG(\"link keys loaded for hci%u\", adapter->dev_id);\n}\n\nstatic void load_link_keys(struct btd_adapter *adapter, GSList *keys,\n\t\t\t\t\t\t\tbool debug_keys)\n{\n\tstruct mgmt_cp_load_link_keys *cp;\n\tstruct mgmt_link_key_info *key;\n\tsize_t key_count, cp_size;\n\tunsigned int id;\n\tGSList *l;\n\n\t/*\n\t * If the controller does not support BR/EDR operation,\n\t * there is no point in trying to load the link keys into\n\t * the kernel.\n\t *\n\t * This is an optimization for Low Energy only controllers.\n\t */\n\tif (!(adapter->supported_settings & MGMT_SETTING_BREDR))\n\t\treturn;\n\n\tkey_count = g_slist_length(keys);\n\n\tDBG(\"hci%u keys %zu debug_keys %d\", adapter->dev_id, key_count,\n\t\t\t\t\t\t\t\tdebug_keys);\n\n\tcp_size = sizeof(*cp) + (key_count * sizeof(*key));\n\n\tcp = g_try_malloc0(cp_size);\n\tif (cp == NULL) {\n\t\tbtd_error(adapter->dev_id, \"No memory for link keys for hci%u\",\n\t\t\t\t\t\t\tadapter->dev_id);\n\t\treturn;\n\t}\n\n\t/*\n\t * Even if the list of stored keys is empty, it is important to\n\t * load an empty list into the kernel. That way it is ensured\n\t * that no old keys from a previous daemon are present.\n\t *\n\t * In addition it is also the only way to toggle the different\n\t * behavior for debug keys.\n\t */\n\tcp->debug_keys = debug_keys;\n\tcp->key_count = htobs(key_count);\n\n\tfor (l = keys, key = cp->keys; l != NULL; l = g_slist_next(l), key++) {\n\t\tstruct link_key_info *info = l->data;\n\n\t\tbacpy(&key->addr.bdaddr, &info->bdaddr);\n\t\tkey->addr.type = BDADDR_BREDR;\n\t\tkey->type = info->type;\n\t\tmemcpy(key->val, info->key, 16);\n\t\tkey->pin_len = info->pin_len;\n\t}\n\n\tid = mgmt_send(adapter->mgmt, MGMT_OP_LOAD_LINK_KEYS,\n\t\t\t\tadapter->dev_id, cp_size, cp,\n\t\t\t\tload_link_keys_complete, adapter, NULL);\n\n\tg_free(cp);\n\n\tif (id == 0)\n\t\tbtd_error(adapter->dev_id, \"Failed to load link keys for hci%u\",\n\t\t\t\t\t\t\tadapter->dev_id);\n}\n\nstatic bool load_ltks_timeout(gpointer user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\tbtd_error(adapter->dev_id, \"Loading LTKs timed out for hci%u\",\n\t\t\t\t\t\t\tadapter->dev_id);\n\n\tadapter->load_ltks_timeout = 0;\n\n\tmgmt_cancel(adapter->mgmt, adapter->load_ltks_id);\n\tadapter->load_ltks_id = 0;\n\n\treturn FALSE;\n}\n\nstatic void load_ltks_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Failed to load LTKs for hci%u: %s (0x%02x)\",\n\t\t\t\tadapter->dev_id, mgmt_errstr(status), status);\n\t}\n\n\tadapter->load_ltks_id = 0;\n\n\ttimeout_remove(adapter->load_ltks_timeout);\n\tadapter->load_ltks_timeout = 0;\n\n\tDBG(\"LTKs loaded for hci%u\", adapter->dev_id);\n}\n\nstatic void load_ltks(struct btd_adapter *adapter, GSList *keys)\n{\n\tstruct mgmt_cp_load_long_term_keys *cp;\n\tstruct mgmt_ltk_info *key;\n\tsize_t key_count, cp_size;\n\tGSList *l;\n\n\t/*\n\t * If the controller does not support Low Energy operation,\n\t * there is no point in trying to load the long term keys\n\t * into the kernel.\n\t *\n\t * While there is no harm in loading keys into the kernel,\n\t * this is an optimization to avoid a confusing warning\n\t * message when the loading of the keys timed out due to\n\t * a kernel bug (see comment below).\n\t */\n\tif (!(adapter->supported_settings & MGMT_SETTING_LE))\n\t\treturn;\n\n\tkey_count = g_slist_length(keys);\n\n\tDBG(\"hci%u keys %zu\", adapter->dev_id, key_count);\n\n\tcp_size = sizeof(*cp) + (key_count * sizeof(*key));\n\n\tcp = g_try_malloc0(cp_size);\n\tif (cp == NULL) {\n\t\tbtd_error(adapter->dev_id, \"No memory for LTKs for hci%u\",\n\t\t\t\t\t\t\tadapter->dev_id);\n\t\treturn;\n\t}\n\n\t/*\n\t * Even if the list of stored keys is empty, it is important to\n\t * load an empty list into the kernel. That way it is ensured\n\t * that no old keys from a previous daemon are present.\n\t */\n\tcp->key_count = htobs(key_count);\n\n\tfor (l = keys, key = cp->keys; l != NULL; l = g_slist_next(l), key++) {\n\t\tstruct smp_ltk_info *info = l->data;\n\n\t\tbacpy(&key->addr.bdaddr, &info->bdaddr);\n\t\tkey->addr.type = info->bdaddr_type;\n\t\tmemcpy(key->val, info->val, sizeof(info->val));\n\t\tkey->rand = cpu_to_le64(info->rand);\n\t\tkey->ediv = cpu_to_le16(info->ediv);\n\t\tkey->type = info->authenticated;\n\t\tkey->master = info->master;\n\t\tkey->enc_size = info->enc_size;\n\t}\n\n\tadapter->load_ltks_id = mgmt_send(adapter->mgmt,\n\t\t\t\t\tMGMT_OP_LOAD_LONG_TERM_KEYS,\n\t\t\t\t\tadapter->dev_id, cp_size, cp,\n\t\t\t\t\tload_ltks_complete, adapter, NULL);\n\n\tg_free(cp);\n\n\tif (adapter->load_ltks_id == 0) {\n\t\tbtd_error(adapter->dev_id, \"Failed to load LTKs for hci%u\",\n\t\t\t\t\t\t\tadapter->dev_id);\n\t\treturn;\n\t}\n\n\t/*\n\t * This timeout handling is needed since the kernel is stupid\n\t * and forgets to send a command complete response. However in\n\t * case of failures it does send a command status.\n\t */\n\tadapter->load_ltks_timeout = timeout_add_seconds(2,\n\t\t\t\t\t\tload_ltks_timeout, adapter,\n\t\t\t\t\t\tNULL);\n}\n\nstatic void load_irks_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\tif (status == MGMT_STATUS_UNKNOWN_COMMAND) {\n\t\tbtd_info(adapter->dev_id,\n\t\t\t\"Load IRKs failed: Kernel doesn't support LE Privacy\");\n\t\treturn;\n\t}\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Failed to load IRKs for hci%u: %s (0x%02x)\",\n\t\t\t\tadapter->dev_id, mgmt_errstr(status), status);\n\t\treturn;\n\t}\n\n\tDBG(\"IRKs loaded for hci%u\", adapter->dev_id);\n}\n\nstatic void load_irks(struct btd_adapter *adapter, GSList *irks)\n{\n\tstruct mgmt_cp_load_irks *cp;\n\tstruct mgmt_irk_info *irk;\n\tsize_t irk_count, cp_size;\n\tunsigned int id;\n\tGSList *l;\n\n\t/*\n\t * If the controller does not support LE Privacy operation,\n\t * there is no support for loading identity resolving keys\n\t * into the kernel.\n\t */\n\tif (!(adapter->supported_settings & MGMT_SETTING_PRIVACY))\n\t\treturn;\n\n\tirk_count = g_slist_length(irks);\n\n\tDBG(\"hci%u irks %zu\", adapter->dev_id, irk_count);\n\n\tcp_size = sizeof(*cp) + (irk_count * sizeof(*irk));\n\n\tcp = g_try_malloc0(cp_size);\n\tif (cp == NULL) {\n\t\tbtd_error(adapter->dev_id, \"No memory for IRKs for hci%u\",\n\t\t\t\t\t\t\tadapter->dev_id);\n\t\treturn;\n\t}\n\n\t/*\n\t * Even if the list of stored keys is empty, it is important to\n\t * load an empty list into the kernel. That way we tell the\n\t * kernel that we are able to handle New IRK events.\n\t */\n\tcp->irk_count = htobs(irk_count);\n\n\tfor (l = irks, irk = cp->irks; l != NULL; l = g_slist_next(l), irk++) {\n\t\tstruct irk_info *info = l->data;\n\n\t\tbacpy(&irk->addr.bdaddr, &info->bdaddr);\n\t\tirk->addr.type = info->bdaddr_type;\n\t\tmemcpy(irk->val, info->val, sizeof(irk->val));\n\t}\n\n\tid = mgmt_send(adapter->mgmt, MGMT_OP_LOAD_IRKS, adapter->dev_id,\n\t\t\tcp_size, cp, load_irks_complete, adapter, NULL);\n\n\tg_free(cp);\n\n\tif (id == 0)\n\t\tbtd_error(adapter->dev_id, \"Failed to IRKs for hci%u\",\n\t\t\t\t\t\t\tadapter->dev_id);\n}\n\nstatic void load_conn_params_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\"hci%u Load Connection Parameters failed: %s (0x%02x)\",\n\t\t\t\tadapter->dev_id, mgmt_errstr(status), status);\n\t\treturn;\n\t}\n\n\tDBG(\"Connection Parameters loaded for hci%u\", adapter->dev_id);\n}\n\nstatic void load_conn_params(struct btd_adapter *adapter, GSList *params)\n{\n\tstruct mgmt_cp_load_conn_param *cp;\n\tstruct mgmt_conn_param *param;\n\tsize_t param_count, cp_size;\n\tunsigned int id;\n\tGSList *l;\n\n\t/*\n\t * If the controller does not support Low Energy operation,\n\t * there is no point in trying to load the connection\n\t * parameters into the kernel.\n\t */\n\tif (!(adapter->supported_settings & MGMT_SETTING_LE))\n\t\treturn;\n\n\tparam_count = g_slist_length(params);\n\n\tDBG(\"hci%u conn params %zu\", adapter->dev_id, param_count);\n\n\tcp_size = sizeof(*cp) + (param_count * sizeof(*param));\n\n\tcp = g_try_malloc0(cp_size);\n\tif (cp == NULL) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\"Failed to allocate memory for connection parameters\");\n\t\treturn;\n\t}\n\n\tcp->param_count = htobs(param_count);\n\n\tfor (l = params, param = cp->params; l; l = g_slist_next(l), param++) {\n\t\tstruct conn_param *info = l->data;\n\n\t\tbacpy(&param->addr.bdaddr, &info->bdaddr);\n\t\tparam->addr.type = info->bdaddr_type;\n\t\tparam->min_interval = htobs(info->min_interval);\n\t\tparam->max_interval = htobs(info->max_interval);\n\t\tparam->latency = htobs(info->latency);\n\t\tparam->timeout = htobs(info->timeout);\n\t}\n\n\tid = mgmt_send(adapter->mgmt, MGMT_OP_LOAD_CONN_PARAM, adapter->dev_id,\n\t\t\tcp_size, cp, load_conn_params_complete, adapter, NULL);\n\n\tg_free(cp);\n\n\tif (id == 0)\n\t\tbtd_error(adapter->dev_id, \"Load connection parameters failed\");\n}\n\nstatic uint8_t get_le_addr_type(GKeyFile *keyfile)\n{\n\tuint8_t addr_type;\n\tchar *type;\n\n\ttype = g_key_file_get_string(keyfile, \"General\", \"AddressType\", NULL);\n\tif (!type)\n\t\treturn BDADDR_LE_PUBLIC;\n\n\tif (g_str_equal(type, \"public\"))\n\t\taddr_type = BDADDR_LE_PUBLIC;\n\telse if (g_str_equal(type, \"static\"))\n\t\taddr_type = BDADDR_LE_RANDOM;\n\telse\n\t\taddr_type = BDADDR_LE_PUBLIC;\n\n\tg_free(type);\n\n\treturn addr_type;\n}\n\nstatic void probe_devices(void *user_data)\n{\n\tstruct btd_device *device = user_data;\n\n\tdevice_probe_profiles(device, btd_device_get_uuids(device));\n}\n\nstatic bool load_bredr_defaults(struct btd_adapter *adapter,\n\t\t\t\tstruct mgmt_tlv_list *list,\n\t\t\t\tstruct btd_br_defaults *defaults)\n{\n\tif (btd_opts.mode == BT_MODE_LE)\n\t\treturn true;\n\n\tif (defaults->page_scan_type != 0xFFFF) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x0000,\n\t\t\t\t\t&defaults->page_scan_type))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->page_scan_interval) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x0001,\n\t\t\t\t\t&defaults->page_scan_interval))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->page_scan_win) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x0002,\n\t\t\t\t\t&defaults->page_scan_win))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->scan_type != 0xFFFF) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x0003,\n\t\t\t\t\t&defaults->scan_type))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->scan_interval) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x0004,\n\t\t\t\t\t&defaults->scan_interval))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->scan_win) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x0005,\n\t\t\t\t\t&defaults->scan_win))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->link_supervision_timeout) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x0006,\n\t\t\t\t\t&defaults->link_supervision_timeout))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->page_timeout) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x0007,\n\t\t\t\t\t&defaults->page_timeout))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->min_sniff_interval) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x0008,\n\t\t\t\t\t&defaults->min_sniff_interval))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->max_sniff_interval) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x0009,\n\t\t\t\t\t&defaults->max_sniff_interval))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool load_le_defaults(struct btd_adapter *adapter,\n\t\t\t\tstruct mgmt_tlv_list *list,\n\t\t\t\tstruct btd_le_defaults *defaults)\n{\n\tif (btd_opts.mode == BT_MODE_BREDR)\n\t\treturn true;\n\n\tif (defaults->min_adv_interval) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x000a,\n\t\t\t\t\t&defaults->min_adv_interval))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->max_adv_interval) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x000b,\n\t\t\t\t\t&defaults->max_adv_interval))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->adv_rotation_interval) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x000c,\n\t\t\t\t\t&defaults->adv_rotation_interval))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->scan_interval_autoconnect) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x000d,\n\t\t\t\t\t&defaults->scan_interval_autoconnect))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->scan_win_autoconnect) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x000e,\n\t\t\t\t\t&defaults->scan_win_autoconnect))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->scan_interval_suspend) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x000f,\n\t\t\t\t\t&defaults->scan_interval_suspend))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->scan_win_suspend) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x0010,\n\t\t\t\t\t&defaults->scan_win_suspend))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->scan_interval_discovery) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x0011,\n\t\t\t\t\t&defaults->scan_interval_discovery))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->scan_win_discovery) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x0012,\n\t\t\t\t\t&defaults->scan_win_discovery))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->scan_interval_adv_monitor) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x0013,\n\t\t\t\t\t&defaults->scan_interval_adv_monitor))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->scan_win_adv_monitor) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x0014,\n\t\t\t\t\t&defaults->scan_win_adv_monitor))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->scan_interval_connect) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x0015,\n\t\t\t\t\t&defaults->scan_interval_connect))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->scan_win_connect) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x0016,\n\t\t\t\t\t&defaults->scan_win_connect))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->min_conn_interval) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x0017,\n\t\t\t\t\t&defaults->min_conn_interval))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->max_conn_interval) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x0018,\n\t\t\t\t\t&defaults->max_conn_interval))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->conn_latency) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x0019,\n\t\t\t\t\t&defaults->conn_latency))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->conn_lsto) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x001a,\n\t\t\t\t\t&defaults->conn_lsto))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->autoconnect_timeout) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x001b,\n\t\t\t\t\t&defaults->autoconnect_timeout))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->advmon_allowlist_scan_duration) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x001d,\n\t\t\t\t&defaults->advmon_allowlist_scan_duration))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->advmon_no_filter_scan_duration) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x001e,\n\t\t\t\t&defaults->advmon_no_filter_scan_duration))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->enable_advmon_interleave_scan != 0xFF) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x001f,\n\t\t\t\t&defaults->enable_advmon_interleave_scan))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void load_defaults(struct btd_adapter *adapter)\n{\n\tstruct mgmt_tlv_list *list;\n\tunsigned int err = 0;\n\n\tif (!btd_opts.defaults.num_entries ||\n\t    !btd_has_kernel_features(KERNEL_SET_SYSTEM_CONFIG))\n\t\treturn;\n\n\tlist = mgmt_tlv_list_new();\n\n\tif (!load_bredr_defaults(adapter, list, &btd_opts.defaults.br))\n\t\tgoto done;\n\n\tif (!load_le_defaults(adapter, list, &btd_opts.defaults.le))\n\t\tgoto done;\n\n\terr = mgmt_send_tlv(adapter->mgmt, MGMT_OP_SET_DEF_SYSTEM_CONFIG,\n\t\t\tadapter->dev_id, list, NULL, NULL, NULL);\n\ndone:\n\tif (!err)\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Failed to set default system config for hci%u\",\n\t\t\t\tadapter->dev_id);\n\n\tmgmt_tlv_list_free(list);\n}\n\nstatic void load_devices(struct btd_adapter *adapter)\n{\n\tchar dirname[PATH_MAX];\n\tGSList *keys = NULL;\n\tGSList *ltks = NULL;\n\tGSList *irks = NULL;\n\tGSList *params = NULL;\n\tGSList *added_devices = NULL;\n\tDIR *dir;\n\tstruct dirent *entry;\n\n\tsnprintf(dirname, PATH_MAX, STORAGEDIR \"/%s\",\n\t\t\t\t\tbtd_adapter_get_storage_dir(adapter));\n\n\tdir = opendir(dirname);\n\tif (!dir) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Unable to open adapter storage directory: %s\",\n\t\t\t\t\t\t\t\tdirname);\n\t\treturn;\n\t}\n\n\twhile ((entry = readdir(dir)) != NULL) {\n\t\tstruct btd_device *device;\n\t\tchar filename[PATH_MAX];\n\t\tGKeyFile *key_file;\n\t\tstruct link_key_info *key_info;\n\t\tstruct smp_ltk_info *ltk_info;\n\t\tstruct smp_ltk_info *slave_ltk_info;\n\t\tGSList *list;\n\t\tstruct irk_info *irk_info;\n\t\tstruct conn_param *param;\n\t\tuint8_t bdaddr_type;\n\n\t\tif (entry->d_type == DT_UNKNOWN)\n\t\t\tentry->d_type = util_get_dt(dirname, entry->d_name);\n\n\t\tif (entry->d_type != DT_DIR || bachk(entry->d_name) < 0)\n\t\t\tcontinue;\n\n\t\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/%s/info\",\n\t\t\t\t\tbtd_adapter_get_storage_dir(adapter),\n\t\t\t\t\tentry->d_name);\n\n\t\tkey_file = g_key_file_new();\n\t\tg_key_file_load_from_file(key_file, filename, 0, NULL);\n\n\t\tkey_info = get_key_info(key_file, entry->d_name);\n\n\t\tbdaddr_type = get_le_addr_type(key_file);\n\n\t\tltk_info = get_ltk_info(key_file, entry->d_name, bdaddr_type);\n\n\t\tslave_ltk_info = get_slave_ltk_info(key_file, entry->d_name,\n\t\t\t\t\t\t\t\tbdaddr_type);\n\n\t\tirk_info = get_irk_info(key_file, entry->d_name, bdaddr_type);\n\n\t\t// If any key for the device is blocked, we discard all.\n\t\tif ((key_info && key_info->is_blocked) ||\n\t\t\t\t(ltk_info && ltk_info->is_blocked) ||\n\t\t\t\t(slave_ltk_info &&\n\t\t\t\t\tslave_ltk_info->is_blocked) ||\n\t\t\t\t(irk_info && irk_info->is_blocked)) {\n\n\t\t\tif (key_info) {\n\t\t\t\tg_free(key_info);\n\t\t\t\tkey_info = NULL;\n\t\t\t}\n\n\t\t\tif (ltk_info) {\n\t\t\t\tg_free(ltk_info);\n\t\t\t\tltk_info = NULL;\n\t\t\t}\n\n\t\t\tif (slave_ltk_info) {\n\t\t\t\tg_free(slave_ltk_info);\n\t\t\t\tslave_ltk_info = NULL;\n\t\t\t}\n\n\t\t\tif (irk_info) {\n\t\t\t\tg_free(irk_info);\n\t\t\t\tirk_info = NULL;\n\t\t\t}\n\n\t\t\tgoto free;\n\t\t}\n\n\t\tif (key_info)\n\t\t\tkeys = g_slist_append(keys, key_info);\n\n\t\tif (ltk_info)\n\t\t\tltks = g_slist_append(ltks, ltk_info);\n\n\t\tif (slave_ltk_info)\n\t\t\tltks = g_slist_append(ltks, slave_ltk_info);\n\n\t\tif (irk_info)\n\t\t\tirks = g_slist_append(irks, irk_info);\n\n\t\tparam = get_conn_param(key_file, entry->d_name, bdaddr_type);\n\t\tif (param)\n\t\t\tparams = g_slist_append(params, param);\n\n\t\tlist = g_slist_find_custom(adapter->devices, entry->d_name,\n\t\t\t\t\t\t\tdevice_address_cmp);\n\t\tif (list) {\n\t\t\tdevice = list->data;\n\t\t\tgoto device_exist;\n\t\t}\n\n\t\tdevice = device_create_from_storage(adapter, entry->d_name,\n\t\t\t\t\t\t\tkey_file);\n\t\tif (!device)\n\t\t\tgoto free;\n\n\t\tbtd_device_set_temporary(device, false);\n\t\tadapter->devices = g_slist_append(adapter->devices, device);\n\n\t\t/* TODO: register services from pre-loaded list of primaries */\n\n\t\tadded_devices = g_slist_append(added_devices, device);\n\ndevice_exist:\n\t\tif (key_info) {\n\t\t\tdevice_set_paired(device, BDADDR_BREDR);\n\t\t\tdevice_set_bonded(device, BDADDR_BREDR);\n\t\t}\n\n\t\tif (ltk_info || slave_ltk_info) {\n\t\t\tdevice_set_paired(device, bdaddr_type);\n\t\t\tdevice_set_bonded(device, bdaddr_type);\n\n\t\t\tif (ltk_info)\n\t\t\t\tdevice_set_ltk_enc_size(device,\n\t\t\t\t\t\t\tltk_info->enc_size);\n\t\t\telse if (slave_ltk_info)\n\t\t\t\tdevice_set_ltk_enc_size(device,\n\t\t\t\t\t\tslave_ltk_info->enc_size);\n\t\t}\n\nfree:\n\t\tg_key_file_free(key_file);\n\t}\n\n\tclosedir(dir);\n\n\tload_link_keys(adapter, keys, btd_opts.debug_keys);\n\tg_slist_free_full(keys, g_free);\n\n\tload_ltks(adapter, ltks);\n\tg_slist_free_full(ltks, g_free);\n\tload_irks(adapter, irks);\n\tg_slist_free_full(irks, g_free);\n\tload_conn_params(adapter, params);\n\tg_slist_free_full(params, g_free);\n\n\tg_slist_free_full(added_devices, probe_devices);\n}\n\nint btd_adapter_block_address(struct btd_adapter *adapter,\n\t\t\t\tconst bdaddr_t *bdaddr, uint8_t bdaddr_type)\n{\n\tstruct mgmt_cp_block_device cp;\n\tchar addr[18];\n\n\tba2str(bdaddr, addr);\n\tDBG(\"hci%u %s\", adapter->dev_id, addr);\n\n\tmemset(&cp, 0, sizeof(cp));\n\tbacpy(&cp.addr.bdaddr, bdaddr);\n\tcp.addr.type = bdaddr_type;\n\n\tif (mgmt_send(adapter->mgmt, MGMT_OP_BLOCK_DEVICE,\n\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\tNULL, NULL, NULL) > 0)\n\t\treturn 0;\n\n\treturn -EIO;\n}\n\nint btd_adapter_unblock_address(struct btd_adapter *adapter,\n\t\t\t\tconst bdaddr_t *bdaddr, uint8_t bdaddr_type)\n{\n\tstruct mgmt_cp_unblock_device cp;\n\tchar addr[18];\n\n\tba2str(bdaddr, addr);\n\tDBG(\"hci%u %s\", adapter->dev_id, addr);\n\n\tmemset(&cp, 0, sizeof(cp));\n\tbacpy(&cp.addr.bdaddr, bdaddr);\n\tcp.addr.type = bdaddr_type;\n\n\tif (mgmt_send(adapter->mgmt, MGMT_OP_UNBLOCK_DEVICE,\n\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\tNULL, NULL, NULL) > 0)\n\t\treturn 0;\n\n\treturn -EIO;\n}\n\nstatic int clear_blocked(struct btd_adapter *adapter)\n{\n\treturn btd_adapter_unblock_address(adapter, BDADDR_ANY, 0);\n}\n\nstatic void probe_driver(struct btd_adapter *adapter, gpointer user_data)\n{\n\tstruct btd_adapter_driver *driver = user_data;\n\tint err;\n\n\tif (driver->probe == NULL)\n\t\treturn;\n\n\terr = driver->probe(adapter);\n\tif (err < 0) {\n\t\tbtd_error(adapter->dev_id, \"%s: %s (%d)\", driver->name,\n\t\t\t\t\t\t\tstrerror(-err), -err);\n\t\treturn;\n\t}\n\n\tadapter->drivers = g_slist_prepend(adapter->drivers, driver);\n}\n\nstatic void load_drivers(struct btd_adapter *adapter)\n{\n\tGSList *l;\n\n\tfor (l = adapter_drivers; l; l = l->next)\n\t\tprobe_driver(adapter, l->data);\n}\n\nstatic void probe_profile(struct btd_profile *profile, void *data)\n{\n\tstruct btd_adapter *adapter = data;\n\tint err;\n\n\tif (profile->adapter_probe == NULL)\n\t\treturn;\n\n\terr = profile->adapter_probe(profile, adapter);\n\tif (err < 0) {\n\t\tbtd_error(adapter->dev_id, \"%s: %s (%d)\", profile->name,\n\t\t\t\t\t\t\tstrerror(-err), -err);\n\t\treturn;\n\t}\n\n\tadapter->profiles = g_slist_prepend(adapter->profiles, profile);\n}\n\nvoid adapter_add_profile(struct btd_adapter *adapter, gpointer p)\n{\n\tstruct btd_profile *profile = p;\n\n\tif (!adapter->initialized)\n\t\treturn;\n\n\tprobe_profile(profile, adapter);\n\n\tg_slist_foreach(adapter->devices, device_probe_profile, profile);\n}\n\nvoid adapter_remove_profile(struct btd_adapter *adapter, gpointer p)\n{\n\tstruct btd_profile *profile = p;\n\n\tif (!adapter->initialized)\n\t\treturn;\n\n\tif (profile->device_remove)\n\t\tg_slist_foreach(adapter->devices, device_remove_profile, p);\n\n\tadapter->profiles = g_slist_remove(adapter->profiles, profile);\n\n\tif (profile->adapter_remove)\n\t\tprofile->adapter_remove(profile, adapter);\n}\n\nstatic void adapter_add_connection(struct btd_adapter *adapter,\n\t\t\t\t\t\tstruct btd_device *device,\n\t\t\t\t\t\tuint8_t bdaddr_type)\n{\n\tdevice_add_connection(device, bdaddr_type);\n\n\tif (g_slist_find(adapter->connections, device)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Device is already marked as connected\");\n\t\treturn;\n\t}\n\n\tadapter->connections = g_slist_append(adapter->connections, device);\n}\n\nstatic void get_connections_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tconst struct mgmt_rp_get_connections *rp = param;\n\tuint16_t i, conn_count;\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Failed to get connections: %s (0x%02x)\",\n\t\t\t\t\t\tmgmt_errstr(status), status);\n\t\treturn;\n\t}\n\n\tif (length < sizeof(*rp)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Wrong size of get connections response\");\n\t\treturn;\n\t}\n\n\tconn_count = btohs(rp->conn_count);\n\n\tDBG(\"Connection count: %d\", conn_count);\n\n\tif (conn_count * sizeof(struct mgmt_addr_info) +\n\t\t\t\t\t\tsizeof(*rp) != length) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\"Incorrect packet size for get connections response\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < conn_count; i++) {\n\t\tconst struct mgmt_addr_info *addr = &rp->addr[i];\n\t\tstruct btd_device *device;\n\t\tchar address[18];\n\n\t\tba2str(&addr->bdaddr, address);\n\t\tDBG(\"Adding existing connection to %s\", address);\n\n\t\tdevice = btd_adapter_get_device(adapter, &addr->bdaddr,\n\t\t\t\t\t\t\t\taddr->type);\n\t\tif (device)\n\t\t\tadapter_add_connection(adapter, device, addr->type);\n\t}\n}\n\nstatic void load_connections(struct btd_adapter *adapter)\n{\n\tDBG(\"sending get connections command for index %u\", adapter->dev_id);\n\n\tif (mgmt_send(adapter->mgmt, MGMT_OP_GET_CONNECTIONS,\n\t\t\t\tadapter->dev_id, 0, NULL,\n\t\t\t\tget_connections_complete, adapter, NULL) > 0)\n\t\treturn;\n\n\tbtd_error(adapter->dev_id, \"Failed to get connections for index %u\",\n\t\t\t\t\t\t\tadapter->dev_id);\n}\n\nbool btd_adapter_get_pairable(struct btd_adapter *adapter)\n{\n\tif (adapter->current_settings & MGMT_SETTING_BONDABLE)\n\t\treturn true;\n\n\treturn false;\n}\n\nbool btd_adapter_get_powered(struct btd_adapter *adapter)\n{\n\tif ((adapter->current_settings & MGMT_SETTING_POWERED) &&\n\t\t\t!(adapter->pending_settings & MGMT_SETTING_POWERED))\n\t\treturn true;\n\n\treturn false;\n}\n\nbool btd_adapter_get_connectable(struct btd_adapter *adapter)\n{\n\tif (adapter->current_settings & MGMT_SETTING_CONNECTABLE)\n\t\treturn true;\n\n\treturn false;\n}\n\nbool btd_adapter_get_discoverable(struct btd_adapter *adapter)\n{\n\tif (adapter->current_settings & MGMT_SETTING_DISCOVERABLE)\n\t\treturn true;\n\n\treturn false;\n}\n\nbool btd_adapter_get_bredr(struct btd_adapter *adapter)\n{\n\tif (adapter->current_settings & MGMT_SETTING_BREDR)\n\t\treturn true;\n\n\treturn false;\n}\n\nstruct btd_gatt_database *btd_adapter_get_database(struct btd_adapter *adapter)\n{\n\tif (!adapter)\n\t\treturn NULL;\n\n\treturn adapter->database;\n}\n\nuint32_t btd_adapter_get_class(struct btd_adapter *adapter)\n{\n\treturn adapter->dev_class;\n}\n\nconst char *btd_adapter_get_name(struct btd_adapter *adapter)\n{\n\tif (adapter->stored_alias)\n\t\treturn adapter->stored_alias;\n\n\tif (adapter->system_name)\n\t\treturn adapter->system_name;\n\n\treturn NULL;\n}\n\nint adapter_connect_list_add(struct btd_adapter *adapter,\n\t\t\t\t\tstruct btd_device *device)\n{\n\t/*\n\t * If the adapter->connect_le device is getting added back to\n\t * the connect list it probably means that the connect attempt\n\t * failed and hence we should clear this pointer\n\t */\n\tif (device == adapter->connect_le)\n\t\tadapter->connect_le = NULL;\n\n\t/*\n\t * If kernel background scanning is supported then the\n\t * adapter_auto_connect_add() function is used to maintain what to\n\t * connect.\n\t */\n\tif (btd_has_kernel_features(KERNEL_CONN_CONTROL))\n\t\treturn 0;\n\n\tif (g_slist_find(adapter->connect_list, device)) {\n\t\tDBG(\"ignoring already added device %s\",\n\t\t\t\t\t\tdevice_get_path(device));\n\t\tgoto done;\n\t}\n\n\tif (!(adapter->supported_settings & MGMT_SETTING_LE)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\"Can't add %s to non-LE capable adapter connect list\",\n\t\t\t\t\t\tdevice_get_path(device));\n\t\treturn -ENOTSUP;\n\t}\n\n\tadapter->connect_list = g_slist_append(adapter->connect_list, device);\n\tDBG(\"%s added to %s's connect_list\", device_get_path(device),\n\t\t\t\t\t\t\tadapter->system_name);\n\ndone:\n\tif (!btd_adapter_get_powered(adapter))\n\t\treturn 0;\n\n\ttrigger_passive_scanning(adapter);\n\n\treturn 0;\n}\n\nvoid adapter_connect_list_remove(struct btd_adapter *adapter,\n\t\t\t\t\tstruct btd_device *device)\n{\n\t/*\n\t * If the adapter->connect_le device is being removed from the\n\t * connect list it means the connection was successful and hence\n\t * the pointer should be cleared\n\t */\n\tif (device == adapter->connect_le)\n\t\tadapter->connect_le = NULL;\n\n\tif (btd_has_kernel_features(KERNEL_CONN_CONTROL))\n\t\treturn;\n\n\tif (!g_slist_find(adapter->connect_list, device)) {\n\t\tDBG(\"device %s is not on the list, ignoring\",\n\t\t\t\t\t\tdevice_get_path(device));\n\t\treturn;\n\t}\n\n\tadapter->connect_list = g_slist_remove(adapter->connect_list, device);\n\tDBG(\"%s removed from %s's connect_list\", device_get_path(device),\n\t\t\t\t\t\t\tadapter->system_name);\n\n\tif (!adapter->connect_list) {\n\t\tstop_passive_scanning(adapter);\n\t\treturn;\n\t}\n\n\tif (!btd_adapter_get_powered(adapter))\n\t\treturn;\n\n\ttrigger_passive_scanning(adapter);\n}\n\nstatic void add_whitelist_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_rp_add_device *rp = param;\n\tstruct btd_adapter *adapter = user_data;\n\tstruct btd_device *dev;\n\tchar addr[18];\n\n\tif (length < sizeof(*rp)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Too small Add Device complete event\");\n\t\treturn;\n\t}\n\n\tba2str(&rp->addr.bdaddr, addr);\n\n\tdev = btd_adapter_find_device(adapter, &rp->addr.bdaddr,\n\t\t\t\t\t\t\trp->addr.type);\n\tif (!dev) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\"Add Device complete for unknown device %s\", addr);\n\t\treturn;\n\t}\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\t\"Failed to add device %s: %s (0x%02x)\",\n\t\t\t\t\taddr, mgmt_errstr(status), status);\n\t\treturn;\n\t}\n\n\tDBG(\"%s added to kernel whitelist\", addr);\n}\n\nvoid adapter_whitelist_add(struct btd_adapter *adapter, struct btd_device *dev)\n{\n\tstruct mgmt_cp_add_device cp;\n\n\tif (!btd_has_kernel_features(KERNEL_CONN_CONTROL))\n\t\treturn;\n\n\tmemset(&cp, 0, sizeof(cp));\n\tbacpy(&cp.addr.bdaddr, device_get_address(dev));\n\tcp.addr.type = BDADDR_BREDR;\n\tcp.action = 0x01;\n\n\tmgmt_send(adapter->mgmt, MGMT_OP_ADD_DEVICE,\n\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\tadd_whitelist_complete, adapter, NULL);\n}\n\nstatic void remove_whitelist_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_rp_remove_device *rp = param;\n\tchar addr[18];\n\n\tif (length < sizeof(*rp)) {\n\t\terror(\"Too small Remove Device complete event\");\n\t\treturn;\n\t}\n\n\tba2str(&rp->addr.bdaddr, addr);\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\terror(\"Failed to remove device %s: %s (0x%02x)\",\n\t\t\t\t\taddr, mgmt_errstr(status), status);\n\t\treturn;\n\t}\n\n\tDBG(\"%s removed from kernel whitelist\", addr);\n}\n\nvoid adapter_whitelist_remove(struct btd_adapter *adapter, struct btd_device *dev)\n{\n\tstruct mgmt_cp_remove_device cp;\n\n\tif (!btd_has_kernel_features(KERNEL_CONN_CONTROL))\n\t\treturn;\n\n\tmemset(&cp, 0, sizeof(cp));\n\tbacpy(&cp.addr.bdaddr, device_get_address(dev));\n\tcp.addr.type = BDADDR_BREDR;\n\n\tmgmt_send(adapter->mgmt, MGMT_OP_REMOVE_DEVICE,\n\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\tremove_whitelist_complete, adapter, NULL);\n}\n\nstatic void add_device_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_rp_add_device *rp = param;\n\tstruct btd_adapter *adapter = user_data;\n\tstruct btd_device *dev;\n\tchar addr[18];\n\n\tif (length < sizeof(*rp)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Too small Add Device complete event\");\n\t\treturn;\n\t}\n\n\tba2str(&rp->addr.bdaddr, addr);\n\n\tdev = btd_adapter_find_device(adapter, &rp->addr.bdaddr,\n\t\t\t\t\t\t\trp->addr.type);\n\tif (!dev) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\"Add Device complete for unknown device %s\", addr);\n\t\treturn;\n\t}\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\"Failed to add device %s (%u): %s (0x%02x)\",\n\t\t\taddr, rp->addr.type, mgmt_errstr(status), status);\n\t\tadapter->connect_list = g_slist_remove(adapter->connect_list,\n\t\t\t\t\t\t\t\t\tdev);\n\t\treturn;\n\t}\n\n\tDBG(\"%s (%u) added to kernel connect list\", addr, rp->addr.type);\n}\n\nvoid adapter_auto_connect_add(struct btd_adapter *adapter,\n\t\t\t\t\tstruct btd_device *device)\n{\n\tstruct mgmt_cp_add_device cp;\n\tconst bdaddr_t *bdaddr;\n\tuint8_t bdaddr_type;\n\tunsigned int id;\n\n\tif (!btd_has_kernel_features(KERNEL_CONN_CONTROL))\n\t\treturn;\n\n\tif (g_slist_find(adapter->connect_list, device)) {\n\t\tDBG(\"ignoring already added device %s\",\n\t\t\t\t\t\tdevice_get_path(device));\n\t\treturn;\n\t}\n\n\tbdaddr = device_get_address(device);\n\tbdaddr_type = btd_device_get_bdaddr_type(device);\n\n\tif (bdaddr_type == BDADDR_BREDR) {\n\t\tDBG(\"auto-connection feature is not avaiable for BR/EDR\");\n\t\treturn;\n\t}\n\n\tmemset(&cp, 0, sizeof(cp));\n\tbacpy(&cp.addr.bdaddr, bdaddr);\n\tcp.addr.type = bdaddr_type;\n\tcp.action = 0x02;\n\n\tid = mgmt_send(adapter->mgmt, MGMT_OP_ADD_DEVICE,\n\t\t\tadapter->dev_id, sizeof(cp), &cp, add_device_complete,\n\t\t\tadapter, NULL);\n\tif (id == 0)\n\t\treturn;\n\n\tadapter->connect_list = g_slist_append(adapter->connect_list, device);\n}\n\nstatic void set_device_wakeable_complete(uint8_t status, uint16_t length,\n\t\t\t\t\t const void *param, void *user_data)\n{\n\tconst struct mgmt_rp_set_device_flags *rp = param;\n\tstruct btd_adapter *adapter = user_data;\n\tstruct btd_device *dev;\n\tchar addr[18];\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\tbtd_error(adapter->dev_id, \"Set device flags return status: %s\",\n\t\t\t  mgmt_errstr(status));\n\t\treturn;\n\t}\n\n\tif (length < sizeof(*rp)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t  \"Too small Set Device Flags complete event: %d\",\n\t\t\t  length);\n\t\treturn;\n\t}\n\n\tba2str(&rp->addr.bdaddr, addr);\n\n\tdev = btd_adapter_find_device(adapter, &rp->addr.bdaddr, rp->addr.type);\n\tif (!dev) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t  \"Set Device Flags complete for unknown device %s\",\n\t\t\t  addr);\n\t\treturn;\n\t}\n\n\tdevice_set_wake_allowed_complete(dev);\n}\n\nvoid adapter_set_device_wakeable(struct btd_adapter *adapter,\n\t\t\t\t struct btd_device *device, bool wakeable)\n{\n\tstruct mgmt_cp_set_device_flags cp;\n\tconst bdaddr_t *bdaddr;\n\tuint8_t bdaddr_type;\n\n\tif (!btd_has_kernel_features(KERNEL_CONN_CONTROL))\n\t\treturn;\n\n\tbdaddr = device_get_address(device);\n\tbdaddr_type = btd_device_get_bdaddr_type(device);\n\n\tmemset(&cp, 0, sizeof(cp));\n\tbacpy(&cp.addr.bdaddr, bdaddr);\n\tcp.addr.type = bdaddr_type;\n\tcp.current_flags = btd_device_get_current_flags(device);\n\tif (wakeable)\n\t\tcp.current_flags |= DEVICE_FLAG_REMOTE_WAKEUP;\n\telse\n\t\tcp.current_flags &= ~DEVICE_FLAG_REMOTE_WAKEUP;\n\n\tmgmt_send(adapter->mgmt, MGMT_OP_SET_DEVICE_FLAGS, adapter->dev_id,\n\t\t  sizeof(cp), &cp, set_device_wakeable_complete, adapter, NULL);\n}\n\nstatic void device_flags_changed_callback(uint16_t index, uint16_t length,\n\t\t\t\t\t  const void *param, void *user_data)\n{\n\tconst struct mgmt_ev_device_flags_changed *ev = param;\n\tstruct btd_adapter *adapter = user_data;\n\tstruct btd_device *dev;\n\tchar addr[18];\n\n\tif (length < sizeof(*ev)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t  \"Too small Device Flags Changed event: %d\",\n\t\t\t  length);\n\t\treturn;\n\t}\n\n\tba2str(&ev->addr.bdaddr, addr);\n\n\tdev = btd_adapter_find_device(adapter, &ev->addr.bdaddr, ev->addr.type);\n\tif (!dev) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\"Device Flags Changed for unknown device %s\", addr);\n\t\treturn;\n\t}\n\n\tbtd_device_flags_changed(dev, ev->supported_flags, ev->current_flags);\n}\n\n\nstatic void remove_device_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_rp_remove_device *rp = param;\n\tchar addr[18];\n\n\tif (length < sizeof(*rp)) {\n\t\terror(\"Too small Remove Device complete event\");\n\t\treturn;\n\t}\n\n\tba2str(&rp->addr.bdaddr, addr);\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\terror(\"Failed to remove device %s (%u): %s (0x%02x)\",\n\t\t\taddr, rp->addr.type, mgmt_errstr(status), status);\n\t\treturn;\n\t}\n\n\tDBG(\"%s (%u) removed from kernel connect list\", addr, rp->addr.type);\n}\n\nvoid adapter_auto_connect_remove(struct btd_adapter *adapter,\n\t\t\t\t\tstruct btd_device *device)\n{\n\tstruct mgmt_cp_remove_device cp;\n\tconst bdaddr_t *bdaddr;\n\tuint8_t bdaddr_type;\n\tunsigned int id;\n\n\tif (!btd_has_kernel_features(KERNEL_CONN_CONTROL))\n\t\treturn;\n\n\tif (!g_slist_find(adapter->connect_list, device)) {\n\t\tDBG(\"ignoring not added device %s\", device_get_path(device));\n\t\treturn;\n\t}\n\n\tbdaddr = device_get_address(device);\n\tbdaddr_type = btd_device_get_bdaddr_type(device);\n\n\tif (bdaddr_type == BDADDR_BREDR) {\n\t\tDBG(\"auto-connection feature is not avaiable for BR/EDR\");\n\t\treturn;\n\t}\n\n\tmemset(&cp, 0, sizeof(cp));\n\tbacpy(&cp.addr.bdaddr, bdaddr);\n\tcp.addr.type = bdaddr_type;\n\n\tid = mgmt_send(adapter->mgmt, MGMT_OP_REMOVE_DEVICE,\n\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\tremove_device_complete, adapter, NULL);\n\tif (id == 0)\n\t\treturn;\n\n\tadapter->connect_list = g_slist_remove(adapter->connect_list, device);\n}\n\nstatic void adapter_start(struct btd_adapter *adapter)\n{\n\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\t\tADAPTER_INTERFACE, \"Powered\");\n\n\tDBG(\"adapter %s has been enabled\", adapter->path);\n\n\ttrigger_passive_scanning(adapter);\n}\n\nstatic void reply_pending_requests(struct btd_adapter *adapter)\n{\n\tGSList *l;\n\n\tif (!adapter)\n\t\treturn;\n\n\t/* pending bonding */\n\tfor (l = adapter->devices; l; l = l->next) {\n\t\tstruct btd_device *device = l->data;\n\n\t\tif (device_is_bonding(device, NULL))\n\t\t\tdevice_bonding_failed(device,\n\t\t\t\t\t\tHCI_OE_USER_ENDED_CONNECTION);\n\t}\n}\n\nstatic void remove_driver(gpointer data, gpointer user_data)\n{\n\tstruct btd_adapter_driver *driver = data;\n\tstruct btd_adapter *adapter = user_data;\n\n\tif (driver->remove)\n\t\tdriver->remove(adapter);\n}\n\nstatic void remove_profile(gpointer data, gpointer user_data)\n{\n\tstruct btd_profile *profile = data;\n\tstruct btd_adapter *adapter = user_data;\n\n\tif (profile->adapter_remove)\n\t\tprofile->adapter_remove(profile, adapter);\n}\n\nstatic void unload_drivers(struct btd_adapter *adapter)\n{\n\tg_slist_foreach(adapter->drivers, remove_driver, adapter);\n\tg_slist_free(adapter->drivers);\n\tadapter->drivers = NULL;\n\n\tg_slist_foreach(adapter->profiles, remove_profile, adapter);\n\tg_slist_free(adapter->profiles);\n\tadapter->profiles = NULL;\n}\n\nstatic void free_service_auth(gpointer data, gpointer user_data)\n{\n\tstruct service_auth *auth = data;\n\n\tg_free(auth);\n}\n\nstatic void remove_discovery_list(struct btd_adapter *adapter)\n{\n\tg_slist_free_full(adapter->set_filter_list, discovery_free);\n\tadapter->set_filter_list = NULL;\n\n\tg_slist_free_full(adapter->discovery_list, discovery_free);\n\tadapter->discovery_list = NULL;\n}\n\nstatic void adapter_free(gpointer user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\tDBG(\"%p\", adapter);\n\n\t/* Make sure the adapter's discovery list is cleaned up before freeing\n\t * the adapter.\n\t */\n\tremove_discovery_list(adapter);\n\n\tif (adapter->pairable_timeout_id > 0) {\n\t\ttimeout_remove(adapter->pairable_timeout_id);\n\t\tadapter->pairable_timeout_id = 0;\n\t}\n\n\tif (adapter->passive_scan_timeout > 0) {\n\t\ttimeout_remove(adapter->passive_scan_timeout);\n\t\tadapter->passive_scan_timeout = 0;\n\t}\n\n\tif (adapter->load_ltks_timeout > 0)\n\t\ttimeout_remove(adapter->load_ltks_timeout);\n\n\tif (adapter->confirm_name_timeout > 0)\n\t\ttimeout_remove(adapter->confirm_name_timeout);\n\n\tif (adapter->pair_device_timeout > 0)\n\t\ttimeout_remove(adapter->pair_device_timeout);\n\n\tif (adapter->auth_idle_id)\n\t\tg_source_remove(adapter->auth_idle_id);\n\n\tg_queue_foreach(adapter->auths, free_service_auth, NULL);\n\tg_queue_free(adapter->auths);\n\n\t/*\n\t * Unregister all handlers for this specific index since\n\t * the adapter bound to them is no longer valid.\n\t *\n\t * This also avoids having multiple instances of the same\n\t * handler in case indexes got removed and re-added.\n\t */\n\tmgmt_unregister_index(adapter->mgmt, adapter->dev_id);\n\n\t/*\n\t * Cancel all pending commands for this specific index\n\t * since the adapter bound to them is no longer valid.\n\t */\n\tmgmt_cancel_index(adapter->mgmt, adapter->dev_id);\n\n\tmgmt_unref(adapter->mgmt);\n\n\tsdp_list_free(adapter->services, NULL);\n\n\tg_slist_free(adapter->connections);\n\n\tg_free(adapter->path);\n\tg_free(adapter->name);\n\tg_free(adapter->short_name);\n\tg_free(adapter->system_name);\n\tg_free(adapter->stored_alias);\n\tg_free(adapter->current_alias);\n\tfree(adapter->modalias);\n\tg_free(adapter);\n}\n\nstruct btd_adapter *btd_adapter_ref(struct btd_adapter *adapter)\n{\n\t__sync_fetch_and_add(&adapter->ref_count, 1);\n\n\treturn adapter;\n}\n\nvoid btd_adapter_unref(struct btd_adapter *adapter)\n{\n\tif (__sync_sub_and_fetch(&adapter->ref_count, 1))\n\t\treturn;\n\n\tif (!adapter->path) {\n\t\tDBG(\"Freeing adapter %u\", adapter->dev_id);\n\n\t\tadapter_free(adapter);\n\t\treturn;\n\t}\n\n\tDBG(\"Freeing adapter %s\", adapter->path);\n\n\tg_dbus_unregister_interface(dbus_conn, adapter->path,\n\t\t\t\t\t\tADAPTER_INTERFACE);\n}\n\nstatic void convert_names_entry(char *key, char *value, void *user_data)\n{\n\tchar *address = user_data;\n\tchar *str = key;\n\tchar filename[PATH_MAX];\n\tGKeyFile *key_file;\n\tchar *data;\n\tgsize length = 0;\n\n\tif (strchr(key, '#'))\n\t\tstr[17] = '\\0';\n\n\tif (bachk(str) != 0)\n\t\treturn;\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/cache/%s\", address, str);\n\tcreate_file(filename, 0600);\n\n\tkey_file = g_key_file_new();\n\tg_key_file_load_from_file(key_file, filename, 0, NULL);\n\tg_key_file_set_string(key_file, \"General\", \"Name\", value);\n\n\tdata = g_key_file_to_data(key_file, &length, NULL);\n\tg_file_set_contents(filename, data, length, NULL);\n\tg_free(data);\n\n\tg_key_file_free(key_file);\n}\n\nstruct device_converter {\n\tchar *address;\n\tvoid (*cb)(GKeyFile *key_file, void *value);\n\tgboolean force;\n};\n\nstatic void set_device_type(GKeyFile *key_file, char type)\n{\n\tchar *techno;\n\tchar *addr_type = NULL;\n\tchar *str;\n\n\tswitch (type) {\n\tcase BDADDR_BREDR:\n\t\ttechno = \"BR/EDR\";\n\t\tbreak;\n\tcase BDADDR_LE_PUBLIC:\n\t\ttechno = \"LE\";\n\t\taddr_type = \"public\";\n\t\tbreak;\n\tcase BDADDR_LE_RANDOM:\n\t\ttechno = \"LE\";\n\t\taddr_type = \"static\";\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tstr = g_key_file_get_string(key_file, \"General\",\n\t\t\t\t\t\"SupportedTechnologies\", NULL);\n\tif (!str)\n\t\tg_key_file_set_string(key_file, \"General\",\n\t\t\t\t\t\"SupportedTechnologies\", techno);\n\telse if (!strstr(str, techno))\n\t\tg_key_file_set_string(key_file, \"General\",\n\t\t\t\t\t\"SupportedTechnologies\", \"BR/EDR;LE\");\n\n\tg_free(str);\n\n\tif (addr_type)\n\t\tg_key_file_set_string(key_file, \"General\", \"AddressType\",\n\t\t\t\t\taddr_type);\n}\n\nstatic void convert_aliases_entry(GKeyFile *key_file, void *value)\n{\n\tg_key_file_set_string(key_file, \"General\", \"Alias\", value);\n}\n\nstatic void convert_trusts_entry(GKeyFile *key_file, void *value)\n{\n\tg_key_file_set_boolean(key_file, \"General\", \"Trusted\", TRUE);\n}\n\nstatic void convert_classes_entry(GKeyFile *key_file, void *value)\n{\n\tg_key_file_set_string(key_file, \"General\", \"Class\", value);\n}\n\nstatic void convert_blocked_entry(GKeyFile *key_file, void *value)\n{\n\tg_key_file_set_boolean(key_file, \"General\", \"Blocked\", TRUE);\n}\n\nstatic void convert_did_entry(GKeyFile *key_file, void *value)\n{\n\tchar *vendor_str, *product_str, *version_str;\n\tuint16_t val;\n\n\tvendor_str = strchr(value, ' ');\n\tif (!vendor_str)\n\t\treturn;\n\n\t*(vendor_str++) = 0;\n\n\tif (g_str_equal(value, \"FFFF\"))\n\t\treturn;\n\n\tproduct_str = strchr(vendor_str, ' ');\n\tif (!product_str)\n\t\treturn;\n\n\t*(product_str++) = 0;\n\n\tversion_str = strchr(product_str, ' ');\n\tif (!version_str)\n\t\treturn;\n\n\t*(version_str++) = 0;\n\n\tval = (uint16_t) strtol(value, NULL, 16);\n\tg_key_file_set_integer(key_file, \"DeviceID\", \"Source\", val);\n\n\tval = (uint16_t) strtol(vendor_str, NULL, 16);\n\tg_key_file_set_integer(key_file, \"DeviceID\", \"Vendor\", val);\n\n\tval = (uint16_t) strtol(product_str, NULL, 16);\n\tg_key_file_set_integer(key_file, \"DeviceID\", \"Product\", val);\n\n\tval = (uint16_t) strtol(version_str, NULL, 16);\n\tg_key_file_set_integer(key_file, \"DeviceID\", \"Version\", val);\n}\n\nstatic void convert_linkkey_entry(GKeyFile *key_file, void *value)\n{\n\tchar *type_str, *length_str, *str;\n\tint val;\n\n\ttype_str = strchr(value, ' ');\n\tif (!type_str)\n\t\treturn;\n\n\t*(type_str++) = 0;\n\n\tlength_str = strchr(type_str, ' ');\n\tif (!length_str)\n\t\treturn;\n\n\t*(length_str++) = 0;\n\n\tstr = g_strconcat(\"0x\", value, NULL);\n\tg_key_file_set_string(key_file, \"LinkKey\", \"Key\", str);\n\tg_free(str);\n\n\tval = strtol(type_str, NULL, 16);\n\tg_key_file_set_integer(key_file, \"LinkKey\", \"Type\", val);\n\n\tval = strtol(length_str, NULL, 16);\n\tg_key_file_set_integer(key_file, \"LinkKey\", \"PINLength\", val);\n}\n\nstatic void convert_ltk_entry(GKeyFile *key_file, void *value)\n{\n\tchar *auth_str, *rand_str, *str;\n\tint i, ret;\n\tunsigned char auth, master, enc_size;\n\tunsigned short ediv;\n\n\tauth_str = strchr(value, ' ');\n\tif (!auth_str)\n\t\treturn;\n\n\t*(auth_str++) = 0;\n\n\tfor (i = 0, rand_str = auth_str; i < 4; i++) {\n\t\trand_str = strchr(rand_str, ' ');\n\t\tif (!rand_str || rand_str[1] == '\\0')\n\t\t\treturn;\n\n\t\trand_str++;\n\t}\n\n\tret = sscanf(auth_str, \" %hhd %hhd %hhd %hd\", &auth, &master,\n\t\t\t\t\t\t\t&enc_size, &ediv);\n\tif (ret < 4)\n\t\treturn;\n\n\tstr = g_strconcat(\"0x\", value, NULL);\n\tg_key_file_set_string(key_file, \"LongTermKey\", \"Key\", str);\n\tg_free(str);\n\n\tg_key_file_set_integer(key_file, \"LongTermKey\", \"Authenticated\", auth);\n\tg_key_file_set_integer(key_file, \"LongTermKey\", \"Master\", master);\n\tg_key_file_set_integer(key_file, \"LongTermKey\", \"EncSize\", enc_size);\n\tg_key_file_set_integer(key_file, \"LongTermKey\", \"EDiv\", ediv);\n\n\tstr = g_strconcat(\"0x\", rand_str, NULL);\n\tg_key_file_set_string(key_file, \"LongTermKey\", \"Rand\", str);\n\tg_free(str);\n}\n\nstatic void convert_profiles_entry(GKeyFile *key_file, void *value)\n{\n\tg_strdelimit(value, \" \", ';');\n\tg_key_file_set_string(key_file, \"General\", \"Services\", value);\n}\n\nstatic void convert_appearances_entry(GKeyFile *key_file, void *value)\n{\n\tg_key_file_set_string(key_file, \"General\", \"Appearance\", value);\n}\n\nstatic void convert_entry(char *key, char *value, void *user_data)\n{\n\tstruct device_converter *converter = user_data;\n\tchar type = BDADDR_BREDR;\n\tchar filename[PATH_MAX];\n\tGKeyFile *key_file;\n\tchar *data;\n\tgsize length = 0;\n\n\tif (strchr(key, '#')) {\n\t\tkey[17] = '\\0';\n\t\ttype = key[18] - '0';\n\t}\n\n\tif (bachk(key) != 0)\n\t\treturn;\n\n\tif (converter->force == FALSE) {\n\t\tstruct stat st;\n\t\tint err;\n\n\t\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/%s\",\n\t\t\t\tconverter->address, key);\n\n\t\terr = stat(filename, &st);\n\t\tif (err || !S_ISDIR(st.st_mode))\n\t\t\treturn;\n\t}\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/%s/info\",\n\t\t\tconverter->address, key);\n\n\tkey_file = g_key_file_new();\n\tg_key_file_load_from_file(key_file, filename, 0, NULL);\n\n\tset_device_type(key_file, type);\n\n\tconverter->cb(key_file, value);\n\n\tdata = g_key_file_to_data(key_file, &length, NULL);\n\tif (length > 0) {\n\t\tcreate_file(filename, 0600);\n\t\tg_file_set_contents(filename, data, length, NULL);\n\t}\n\n\tg_free(data);\n\n\tg_key_file_free(key_file);\n}\n\nstatic void convert_file(char *file, char *address,\n\t\t\t\tvoid (*cb)(GKeyFile *key_file, void *value),\n\t\t\t\tgboolean force)\n{\n\tchar filename[PATH_MAX];\n\tstruct device_converter converter;\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/%s\", address, file);\n\n\tconverter.address = address;\n\tconverter.cb = cb;\n\tconverter.force = force;\n\n\ttextfile_foreach(filename, convert_entry, &converter);\n}\n\nstatic gboolean record_has_uuid(const sdp_record_t *rec,\n\t\t\t\tconst char *profile_uuid)\n{\n\tsdp_list_t *pat;\n\n\tfor (pat = rec->pattern; pat != NULL; pat = pat->next) {\n\t\tchar *uuid;\n\t\tint ret;\n\n\t\tuuid = bt_uuid2string(pat->data);\n\t\tif (!uuid)\n\t\t\tcontinue;\n\n\t\tret = strcasecmp(uuid, profile_uuid);\n\n\t\tfree(uuid);\n\n\t\tif (ret == 0)\n\t\t\treturn TRUE;\n\t}\n\n\treturn FALSE;\n}\n\nstatic void store_attribute_uuid(GKeyFile *key_file, uint16_t start,\n\t\t\t\t\tuint16_t end, char *att_uuid,\n\t\t\t\t\tuuid_t uuid)\n{\n\tchar handle[6], uuid_str[33];\n\tint i;\n\n\tswitch (uuid.type) {\n\tcase SDP_UUID16:\n\t\tsprintf(uuid_str, \"%4.4X\", uuid.value.uuid16);\n\t\tbreak;\n\tcase SDP_UUID32:\n\t\tsprintf(uuid_str, \"%8.8X\", uuid.value.uuid32);\n\t\tbreak;\n\tcase SDP_UUID128:\n\t\tfor (i = 0; i < 16; i++)\n\t\t\tsprintf(uuid_str + (i * 2), \"%2.2X\",\n\t\t\t\t\tuuid.value.uuid128.data[i]);\n\t\tbreak;\n\tdefault:\n\t\tuuid_str[0] = '\\0';\n\t}\n\n\tsprintf(handle, \"%hu\", start);\n\tg_key_file_set_string(key_file, handle, \"UUID\", att_uuid);\n\tg_key_file_set_string(key_file, handle, \"Value\", uuid_str);\n\tg_key_file_set_integer(key_file, handle, \"EndGroupHandle\", end);\n}\n\nstatic void store_sdp_record(char *local, char *peer, int handle, char *value)\n{\n\tchar filename[PATH_MAX];\n\tGKeyFile *key_file;\n\tchar handle_str[11];\n\tchar *data;\n\tgsize length = 0;\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/cache/%s\", local, peer);\n\n\tkey_file = g_key_file_new();\n\tg_key_file_load_from_file(key_file, filename, 0, NULL);\n\n\tsprintf(handle_str, \"0x%8.8X\", handle);\n\tg_key_file_set_string(key_file, \"ServiceRecords\", handle_str, value);\n\n\tdata = g_key_file_to_data(key_file, &length, NULL);\n\tif (length > 0) {\n\t\tcreate_file(filename, 0600);\n\t\tg_file_set_contents(filename, data, length, NULL);\n\t}\n\n\tg_free(data);\n\n\tg_key_file_free(key_file);\n}\n\nstatic void convert_sdp_entry(char *key, char *value, void *user_data)\n{\n\tchar *src_addr = user_data;\n\tchar dst_addr[18];\n\tchar type = BDADDR_BREDR;\n\tint handle, ret;\n\tchar filename[PATH_MAX];\n\tGKeyFile *key_file;\n\tstruct stat st;\n\tsdp_record_t *rec;\n\tuuid_t uuid;\n\tchar *att_uuid, *prim_uuid;\n\tuint16_t start = 0, end = 0, psm = 0;\n\tint err;\n\tchar *data;\n\tgsize length = 0;\n\n\tret = sscanf(key, \"%17s#%hhu#%08X\", dst_addr, &type, &handle);\n\tif (ret < 3) {\n\t\tret = sscanf(key, \"%17s#%08X\", dst_addr, &handle);\n\t\tif (ret < 2)\n\t\t\treturn;\n\t}\n\n\tif (bachk(dst_addr) != 0)\n\t\treturn;\n\n\t/* Check if the device directory has been created as records should\n\t * only be converted for known devices */\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/%s\", src_addr, dst_addr);\n\n\terr = stat(filename, &st);\n\tif (err || !S_ISDIR(st.st_mode))\n\t\treturn;\n\n\t/* store device records in cache */\n\tstore_sdp_record(src_addr, dst_addr, handle, value);\n\n\t/* Retrieve device record and check if there is an\n\t * attribute entry in it */\n\tsdp_uuid16_create(&uuid, ATT_UUID);\n\tatt_uuid = bt_uuid2string(&uuid);\n\n\tsdp_uuid16_create(&uuid, GATT_PRIM_SVC_UUID);\n\tprim_uuid = bt_uuid2string(&uuid);\n\n\trec = record_from_string(value);\n\n\tif (record_has_uuid(rec, att_uuid))\n\t\tgoto failed;\n\n\t/* TODO: Do this through btd_gatt_database */\n\tif (!gatt_parse_record(rec, &uuid, &psm, &start, &end))\n\t\tgoto failed;\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/%s/attributes\", src_addr,\n\t\t\t\t\t\t\t\tdst_addr);\n\n\tkey_file = g_key_file_new();\n\tg_key_file_load_from_file(key_file, filename, 0, NULL);\n\n\tstore_attribute_uuid(key_file, start, end, prim_uuid, uuid);\n\n\tdata = g_key_file_to_data(key_file, &length, NULL);\n\tif (length > 0) {\n\t\tcreate_file(filename, 0600);\n\t\tg_file_set_contents(filename, data, length, NULL);\n\t}\n\n\tg_free(data);\n\tg_key_file_free(key_file);\n\nfailed:\n\tsdp_record_free(rec);\n\tfree(prim_uuid);\n\tfree(att_uuid);\n}\n\nstatic void convert_primaries_entry(char *key, char *value, void *user_data)\n{\n\tchar *address = user_data;\n\tint device_type = -1;\n\tuuid_t uuid;\n\tchar **services, **service, *prim_uuid;\n\tchar filename[PATH_MAX];\n\tGKeyFile *key_file;\n\tint ret;\n\tuint16_t start, end;\n\tchar uuid_str[MAX_LEN_UUID_STR + 1];\n\tchar *data;\n\tgsize length = 0;\n\n\tif (strchr(key, '#')) {\n\t\tkey[17] = '\\0';\n\t\tdevice_type = key[18] - '0';\n\t}\n\n\tif (bachk(key) != 0)\n\t\treturn;\n\n\tservices = g_strsplit(value, \" \", 0);\n\tif (services == NULL)\n\t\treturn;\n\n\tsdp_uuid16_create(&uuid, GATT_PRIM_SVC_UUID);\n\tprim_uuid = bt_uuid2string(&uuid);\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/%s/attributes\", address,\n\t\t\t\t\t\t\t\t\tkey);\n\tkey_file = g_key_file_new();\n\tg_key_file_load_from_file(key_file, filename, 0, NULL);\n\n\tfor (service = services; *service; service++) {\n\t\tret = sscanf(*service, \"%04hX#%04hX#%s\", &start, &end,\n\t\t\t\t\t\t\t\tuuid_str);\n\t\tif (ret < 3)\n\t\t\tcontinue;\n\n\t\tbt_string2uuid(&uuid, uuid_str);\n\t\tsdp_uuid128_to_uuid(&uuid);\n\n\t\tstore_attribute_uuid(key_file, start, end, prim_uuid, uuid);\n\t}\n\n\tg_strfreev(services);\n\n\tdata = g_key_file_to_data(key_file, &length, NULL);\n\tif (length == 0)\n\t\tgoto end;\n\n\tcreate_file(filename, 0600);\n\tg_file_set_contents(filename, data, length, NULL);\n\n\tif (device_type < 0)\n\t\tgoto end;\n\n\tg_free(data);\n\tg_key_file_free(key_file);\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/%s/info\", address, key);\n\n\tkey_file = g_key_file_new();\n\tg_key_file_load_from_file(key_file, filename, 0, NULL);\n\tset_device_type(key_file, device_type);\n\n\tdata = g_key_file_to_data(key_file, &length, NULL);\n\tif (length > 0) {\n\t\tcreate_file(filename, 0600);\n\t\tg_file_set_contents(filename, data, length, NULL);\n\t}\n\nend:\n\tg_free(data);\n\tfree(prim_uuid);\n\tg_key_file_free(key_file);\n}\n\nstatic void convert_ccc_entry(char *key, char *value, void *user_data)\n{\n\tchar *src_addr = user_data;\n\tchar dst_addr[18];\n\tchar type = BDADDR_BREDR;\n\tuint16_t handle;\n\tint ret, err;\n\tchar filename[PATH_MAX];\n\tGKeyFile *key_file;\n\tstruct stat st;\n\tchar group[6];\n\tchar *data;\n\tgsize length = 0;\n\n\tret = sscanf(key, \"%17s#%hhu#%04hX\", dst_addr, &type, &handle);\n\tif (ret < 3)\n\t\treturn;\n\n\tif (bachk(dst_addr) != 0)\n\t\treturn;\n\n\t/* Check if the device directory has been created as records should\n\t * only be converted for known devices */\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/%s\", src_addr, dst_addr);\n\n\terr = stat(filename, &st);\n\tif (err || !S_ISDIR(st.st_mode))\n\t\treturn;\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/%s/ccc\", src_addr,\n\t\t\t\t\t\t\t\tdst_addr);\n\tkey_file = g_key_file_new();\n\tg_key_file_load_from_file(key_file, filename, 0, NULL);\n\n\tsprintf(group, \"%hu\", handle);\n\tg_key_file_set_string(key_file, group, \"Value\", value);\n\n\tdata = g_key_file_to_data(key_file, &length, NULL);\n\tif (length > 0) {\n\t\tcreate_file(filename, 0600);\n\t\tg_file_set_contents(filename, data, length, NULL);\n\t}\n\n\tg_free(data);\n\tg_key_file_free(key_file);\n}\n\nstatic void convert_gatt_entry(char *key, char *value, void *user_data)\n{\n\tchar *src_addr = user_data;\n\tchar dst_addr[18];\n\tchar type = BDADDR_BREDR;\n\tuint16_t handle;\n\tint ret, err;\n\tchar filename[PATH_MAX];\n\tGKeyFile *key_file;\n\tstruct stat st;\n\tchar group[6];\n\tchar *data;\n\tgsize length = 0;\n\n\tret = sscanf(key, \"%17s#%hhu#%04hX\", dst_addr, &type, &handle);\n\tif (ret < 3)\n\t\treturn;\n\n\tif (bachk(dst_addr) != 0)\n\t\treturn;\n\n\t/* Check if the device directory has been created as records should\n\t * only be converted for known devices */\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/%s\", src_addr, dst_addr);\n\n\terr = stat(filename, &st);\n\tif (err || !S_ISDIR(st.st_mode))\n\t\treturn;\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/%s/gatt\", src_addr,\n\t\t\t\t\t\t\t\tdst_addr);\n\tkey_file = g_key_file_new();\n\tg_key_file_load_from_file(key_file, filename, 0, NULL);\n\n\tsprintf(group, \"%hu\", handle);\n\tg_key_file_set_string(key_file, group, \"Value\", value);\n\n\tdata = g_key_file_to_data(key_file, &length, NULL);\n\tif (length > 0) {\n\t\tcreate_file(filename, 0600);\n\t\tg_file_set_contents(filename, data, length, NULL);\n\t}\n\n\tg_free(data);\n\tg_key_file_free(key_file);\n}\n\nstatic void convert_proximity_entry(char *key, char *value, void *user_data)\n{\n\tchar *src_addr = user_data;\n\tchar *alert;\n\tchar filename[PATH_MAX];\n\tGKeyFile *key_file;\n\tstruct stat st;\n\tint err;\n\tchar *data;\n\tgsize length = 0;\n\n\tif (!strchr(key, '#'))\n\t\treturn;\n\n\tkey[17] = '\\0';\n\talert = &key[18];\n\n\tif (bachk(key) != 0)\n\t\treturn;\n\n\t/* Check if the device directory has been created as records should\n\t * only be converted for known devices */\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/%s\", src_addr, key);\n\n\terr = stat(filename, &st);\n\tif (err || !S_ISDIR(st.st_mode))\n\t\treturn;\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/%s/proximity\", src_addr,\n\t\t\t\t\t\t\t\t\tkey);\n\tkey_file = g_key_file_new();\n\tg_key_file_load_from_file(key_file, filename, 0, NULL);\n\n\tg_key_file_set_string(key_file, alert, \"Level\", value);\n\n\tdata = g_key_file_to_data(key_file, &length, NULL);\n\tif (length > 0) {\n\t\tcreate_file(filename, 0600);\n\t\tg_file_set_contents(filename, data, length, NULL);\n\t}\n\n\tg_free(data);\n\tg_key_file_free(key_file);\n}\n\nstatic void convert_device_storage(struct btd_adapter *adapter)\n{\n\tchar filename[PATH_MAX];\n\tchar address[18];\n\n\tba2str(&adapter->bdaddr, address);\n\n\t/* Convert device's name cache */\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/names\", address);\n\ttextfile_foreach(filename, convert_names_entry, address);\n\n\t/* Convert aliases */\n\tconvert_file(\"aliases\", address, convert_aliases_entry, TRUE);\n\n\t/* Convert trusts */\n\tconvert_file(\"trusts\", address, convert_trusts_entry, TRUE);\n\n\t/* Convert blocked */\n\tconvert_file(\"blocked\", address, convert_blocked_entry, TRUE);\n\n\t/* Convert profiles */\n\tconvert_file(\"profiles\", address, convert_profiles_entry, TRUE);\n\n\t/* Convert primaries */\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/primaries\", address);\n\ttextfile_foreach(filename, convert_primaries_entry, address);\n\n\t/* Convert linkkeys */\n\tconvert_file(\"linkkeys\", address, convert_linkkey_entry, TRUE);\n\n\t/* Convert longtermkeys */\n\tconvert_file(\"longtermkeys\", address, convert_ltk_entry, TRUE);\n\n\t/* Convert classes */\n\tconvert_file(\"classes\", address, convert_classes_entry, FALSE);\n\n\t/* Convert device ids */\n\tconvert_file(\"did\", address, convert_did_entry, FALSE);\n\n\t/* Convert sdp */\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/sdp\", address);\n\ttextfile_foreach(filename, convert_sdp_entry, address);\n\n\t/* Convert ccc */\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/ccc\", address);\n\ttextfile_foreach(filename, convert_ccc_entry, address);\n\n\t/* Convert appearances */\n\tconvert_file(\"appearances\", address, convert_appearances_entry, FALSE);\n\n\t/* Convert gatt */\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/gatt\", address);\n\ttextfile_foreach(filename, convert_gatt_entry, address);\n\n\t/* Convert proximity */\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/proximity\", address);\n\ttextfile_foreach(filename, convert_proximity_entry, address);\n}\n\nstatic void convert_config(struct btd_adapter *adapter, const char *filename,\n\t\t\t\t\t\t\tGKeyFile *key_file)\n{\n\tchar address[18];\n\tchar str[MAX_NAME_LENGTH + 1];\n\tchar config_path[PATH_MAX];\n\tint timeout;\n\tuint8_t mode;\n\tchar *data;\n\tgsize length = 0;\n\n\tba2str(&adapter->bdaddr, address);\n\tsnprintf(config_path, PATH_MAX, STORAGEDIR \"/%s/config\", address);\n\n\tif (read_pairable_timeout(address, &timeout) == 0)\n\t\tg_key_file_set_integer(key_file, \"General\",\n\t\t\t\t\t\t\"PairableTimeout\", timeout);\n\n\tif (read_discoverable_timeout(address, &timeout) == 0)\n\t\tg_key_file_set_integer(key_file, \"General\",\n\t\t\t\t\t\t\"DiscoverableTimeout\", timeout);\n\n\tif (read_on_mode(address, str, sizeof(str)) == 0) {\n\t\tmode = get_mode(str);\n\t\tg_key_file_set_boolean(key_file, \"General\", \"Discoverable\",\n\t\t\t\t\tmode == MODE_DISCOVERABLE);\n\t}\n\n\tif (read_local_name(&adapter->bdaddr, str) == 0)\n\t\tg_key_file_set_string(key_file, \"General\", \"Alias\", str);\n\n\tcreate_file(filename, 0600);\n\n\tdata = g_key_file_to_data(key_file, &length, NULL);\n\tg_file_set_contents(filename, data, length, NULL);\n\tg_free(data);\n}\n\nstatic void fix_storage(struct btd_adapter *adapter)\n{\n\tchar filename[PATH_MAX];\n\tchar address[18];\n\tchar *converted;\n\n\tba2str(&adapter->bdaddr, address);\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/config\", address);\n\tconverted = textfile_get(filename, \"converted\");\n\tif (!converted)\n\t\treturn;\n\n\tfree(converted);\n\n\ttextfile_del(filename, \"converted\");\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/names\", address);\n\ttextfile_del(filename, \"converted\");\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/aliases\", address);\n\ttextfile_del(filename, \"converted\");\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/trusts\", address);\n\ttextfile_del(filename, \"converted\");\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/blocked\", address);\n\ttextfile_del(filename, \"converted\");\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/profiles\", address);\n\ttextfile_del(filename, \"converted\");\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/primaries\", address);\n\ttextfile_del(filename, \"converted\");\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/linkkeys\", address);\n\ttextfile_del(filename, \"converted\");\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/longtermkeys\", address);\n\ttextfile_del(filename, \"converted\");\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/classes\", address);\n\ttextfile_del(filename, \"converted\");\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/did\", address);\n\ttextfile_del(filename, \"converted\");\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/sdp\", address);\n\ttextfile_del(filename, \"converted\");\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/ccc\", address);\n\ttextfile_del(filename, \"converted\");\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/appearances\", address);\n\ttextfile_del(filename, \"converted\");\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/gatt\", address);\n\ttextfile_del(filename, \"converted\");\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/proximity\", address);\n\ttextfile_del(filename, \"converted\");\n}\n\nstatic void load_config(struct btd_adapter *adapter)\n{\n\tGKeyFile *key_file;\n\tchar filename[PATH_MAX];\n\tstruct stat st;\n\tGError *gerr = NULL;\n\n\tkey_file = g_key_file_new();\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/settings\",\n\t\t\t\t\tbtd_adapter_get_storage_dir(adapter));\n\n\tif (stat(filename, &st) < 0) {\n\t\tconvert_config(adapter, filename, key_file);\n\t\tconvert_device_storage(adapter);\n\t}\n\n\tg_key_file_load_from_file(key_file, filename, 0, NULL);\n\n\t/* Get alias */\n\tadapter->stored_alias = g_key_file_get_string(key_file, \"General\",\n\t\t\t\t\t\t\t\t\"Alias\", NULL);\n\tif (!adapter->stored_alias) {\n\t\t/* fallback */\n\t\tadapter->stored_alias = g_key_file_get_string(key_file,\n\t\t\t\t\t\t\"General\", \"Name\", NULL);\n\t}\n\n\t/* Get pairable timeout */\n\tadapter->pairable_timeout = g_key_file_get_integer(key_file, \"General\",\n\t\t\t\t\t\t\"PairableTimeout\", &gerr);\n\tif (gerr) {\n\t\tadapter->pairable_timeout = btd_opts.pairto;\n\t\tg_error_free(gerr);\n\t\tgerr = NULL;\n\t}\n\n\t/* Get discoverable mode */\n\tadapter->stored_discoverable = g_key_file_get_boolean(key_file,\n\t\t\t\t\t\"General\", \"Discoverable\", &gerr);\n\tif (gerr) {\n\t\tadapter->stored_discoverable = false;\n\t\tg_error_free(gerr);\n\t\tgerr = NULL;\n\t}\n\n\t/* Get discoverable timeout */\n\tadapter->discoverable_timeout = g_key_file_get_integer(key_file,\n\t\t\t\t\"General\", \"DiscoverableTimeout\", &gerr);\n\tif (gerr) {\n\t\tadapter->discoverable_timeout = btd_opts.discovto;\n\t\tg_error_free(gerr);\n\t\tgerr = NULL;\n\t}\n\n\tg_key_file_free(key_file);\n}\n\nstatic struct btd_adapter *btd_adapter_new(uint16_t index)\n{\n\tstruct btd_adapter *adapter;\n\n\tadapter = g_try_new0(struct btd_adapter, 1);\n\tif (!adapter)\n\t\treturn NULL;\n\n\tadapter->dev_id = index;\n\tadapter->mgmt = mgmt_ref(mgmt_master);\n\tadapter->pincode_requested = false;\n\n\t/*\n\t * Setup default configuration values. These are either adapter\n\t * defaults or from a system wide configuration file.\n\t *\n\t * Some value might be overwritten later on by adapter specific\n\t * configuration. This is to make sure that sane defaults are\n\t * always present.\n\t */\n\tadapter->system_name = g_strdup(btd_opts.name);\n\tadapter->major_class = (btd_opts.class & 0x001f00) >> 8;\n\tadapter->minor_class = (btd_opts.class & 0x0000fc) >> 2;\n\tadapter->modalias = bt_modalias(btd_opts.did_source,\n\t\t\t\t\t\tbtd_opts.did_vendor,\n\t\t\t\t\t\tbtd_opts.did_product,\n\t\t\t\t\t\tbtd_opts.did_version);\n\tadapter->discoverable_timeout = btd_opts.discovto;\n\tadapter->pairable_timeout = btd_opts.pairto;\n\n\tDBG(\"System name: %s\", adapter->system_name);\n\tDBG(\"Major class: %u\", adapter->major_class);\n\tDBG(\"Minor class: %u\", adapter->minor_class);\n\tDBG(\"Modalias: %s\", adapter->modalias);\n\tDBG(\"Discoverable timeout: %u seconds\", adapter->discoverable_timeout);\n\tDBG(\"Pairable timeout: %u seconds\", adapter->pairable_timeout);\n\n\tadapter->auths = g_queue_new();\n\n\treturn btd_adapter_ref(adapter);\n}\n\nstatic void adapter_remove(struct btd_adapter *adapter)\n{\n\tGSList *l;\n\tstruct gatt_db *db;\n\n\tDBG(\"Removing adapter %s\", adapter->path);\n\n\tg_slist_free(adapter->connect_list);\n\tadapter->connect_list = NULL;\n\n\tfor (l = adapter->devices; l; l = l->next)\n\t\tdevice_remove(l->data, FALSE);\n\n\tg_slist_free(adapter->devices);\n\tadapter->devices = NULL;\n\n\tdiscovery_cleanup(adapter, 0);\n\n\tunload_drivers(adapter);\n\n\tdb = btd_gatt_database_get_db(adapter->database);\n\tgatt_db_unregister(db, adapter->db_id);\n\tadapter->db_id = 0;\n\n\tbtd_gatt_database_destroy(adapter->database);\n\tadapter->database = NULL;\n\n\tbtd_adv_manager_destroy(adapter->adv_manager);\n\tadapter->adv_manager = NULL;\n\n\tbtd_adv_monitor_manager_destroy(adapter->adv_monitor_manager);\n\tadapter->adv_monitor_manager = NULL;\n\n\tbtd_battery_provider_manager_destroy(adapter->battery_provider_manager);\n\tadapter->battery_provider_manager = NULL;\n\n\tg_slist_free(adapter->pin_callbacks);\n\tadapter->pin_callbacks = NULL;\n\n\tg_slist_free(adapter->msd_callbacks);\n\tadapter->msd_callbacks = NULL;\n}\n\nconst char *adapter_get_path(struct btd_adapter *adapter)\n{\n\tif (!adapter)\n\t\treturn NULL;\n\n\treturn adapter->path;\n}\n\nconst bdaddr_t *btd_adapter_get_address(struct btd_adapter *adapter)\n{\n\treturn &adapter->bdaddr;\n}\n\nstatic bool confirm_name_timeout(gpointer user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\tbtd_error(adapter->dev_id, \"Confirm name timed out for hci%u\",\n\t\t\t\t\t\t\tadapter->dev_id);\n\n\tadapter->confirm_name_timeout = 0;\n\n\tmgmt_cancel(adapter->mgmt, adapter->confirm_name_id);\n\tadapter->confirm_name_id = 0;\n\n\treturn FALSE;\n}\n\nstatic void confirm_name_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Failed to confirm name for hci%u: %s (0x%02x)\",\n\t\t\t\tadapter->dev_id, mgmt_errstr(status), status);\n\t}\n\n\tadapter->confirm_name_id = 0;\n\n\ttimeout_remove(adapter->confirm_name_timeout);\n\tadapter->confirm_name_timeout = 0;\n\n\tDBG(\"Confirm name complete for hci%u\", adapter->dev_id);\n}\n\nstatic void confirm_name(struct btd_adapter *adapter, const bdaddr_t *bdaddr,\n\t\t\t\t\tuint8_t bdaddr_type, bool name_known)\n{\n\tstruct mgmt_cp_confirm_name cp;\n\tchar addr[18];\n\n\tba2str(bdaddr, addr);\n\tDBG(\"hci%d bdaddr %s name_known %u\", adapter->dev_id, addr,\n\t\t\t\t\t\t\t\tname_known);\n\n\t/*\n\t * If the kernel does not answer the confirm name command with\n\t * a command complete or command status in time, this might\n\t * race against another device found event that also requires\n\t * to confirm the name. If there is a pending command, just\n\t * cancel it to be safe here.\n\t */\n\tif (adapter->confirm_name_id > 0) {\n\t\tbtd_warn(adapter->dev_id,\n\t\t\t\t\"Found pending confirm name for hci%u\",\n\t\t\t\t\t\t\tadapter->dev_id);\n\t\tmgmt_cancel(adapter->mgmt, adapter->confirm_name_id);\n\t}\n\n\tif (adapter->confirm_name_timeout > 0) {\n\t\ttimeout_remove(adapter->confirm_name_timeout);\n\t\tadapter->confirm_name_timeout = 0;\n\t}\n\n\tmemset(&cp, 0, sizeof(cp));\n\tbacpy(&cp.addr.bdaddr, bdaddr);\n\tcp.addr.type = bdaddr_type;\n\tcp.name_known = name_known;\n\n\tadapter->confirm_name_id = mgmt_reply(adapter->mgmt,\n\t\t\t\t\tMGMT_OP_CONFIRM_NAME,\n\t\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\t\tconfirm_name_complete, adapter, NULL);\n\n\tif (adapter->confirm_name_id == 0) {\n\t\tbtd_error(adapter->dev_id, \"Failed to confirm name for hci%u\",\n\t\t\t\t\t\t\tadapter->dev_id);\n\t\treturn;\n\t}\n\n\t/*\n\t * This timeout handling is needed since the kernel is stupid\n\t * and forgets to send a command complete response. However in\n\t * case of failures it does send a command status.\n\t */\n\tadapter->confirm_name_timeout = timeout_add_seconds(2,\n\t\t\t\t\t\tconfirm_name_timeout, adapter,\n\t\t\t\t\t\tNULL);\n}\n\nstatic void adapter_msd_notify(struct btd_adapter *adapter,\n\t\t\t\t\t\t\tstruct btd_device *dev,\n\t\t\t\t\t\t\tGSList *msd_list)\n{\n\tGSList *cb_l, *cb_next;\n\tGSList *msd_l, *msd_next;\n\n\tfor (cb_l = adapter->msd_callbacks; cb_l != NULL; cb_l = cb_next) {\n\t\tbtd_msd_cb_t cb = cb_l->data;\n\n\t\tcb_next = g_slist_next(cb_l);\n\n\t\tfor (msd_l = msd_list; msd_l != NULL; msd_l = msd_next) {\n\t\t\tconst struct eir_msd *msd = msd_l->data;\n\n\t\t\tmsd_next = g_slist_next(msd_l);\n\n\t\t\tcb(adapter, dev, msd->company, msd->data,\n\t\t\t\t\t\t\t\tmsd->data_len);\n\t\t}\n\t}\n}\n\nstatic bool is_filter_match(GSList *discovery_filter, struct eir_data *eir_data,\n\t\t\t\t\t\t\t\tint8_t rssi)\n{\n\tGSList *l, *m;\n\tbool got_match = false;\n\n\tfor (l = discovery_filter; l != NULL && got_match != true;\n\t\t\t\t\t\t\tl = g_slist_next(l)) {\n\t\tstruct discovery_client *client = l->data;\n\t\tstruct discovery_filter *item = client->discovery_filter;\n\n\t\t/*\n\t\t * If one of currently running scans is regular scan, then\n\t\t * return all devices as matches\n\t\t */\n\t\tif (!item) {\n\t\t\tgot_match = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* if someone started discovery with empty uuids, he wants all\n\t\t * devices in given proximity.\n\t\t */\n\t\tif (!item->uuids)\n\t\t\tgot_match = true;\n\t\telse {\n\t\t\tfor (m = item->uuids; m != NULL && got_match != true;\n\t\t\t\t\t\t\tm = g_slist_next(m)) {\n\t\t\t\t/* m->data contains string representation of\n\t\t\t\t * uuid.\n\t\t\t\t */\n\t\t\t\tif (g_slist_find_custom(eir_data->services,\n\t\t\t\t\t\t\tm->data,\n\t\t\t\t\t\t\tg_strcmp) != NULL)\n\t\t\t\t\tgot_match = true;\n\t\t\t}\n\t\t}\n\n\t\tif (got_match) {\n\t\t\t/* we have service match, check proximity */\n\t\t\tif (item->rssi == DISTANCE_VAL_INVALID ||\n\t\t\t    item->rssi <= rssi ||\n\t\t\t    item->pathloss == DISTANCE_VAL_INVALID ||\n\t\t\t    (eir_data->tx_power != 127 &&\n\t\t\t     eir_data->tx_power - rssi <= item->pathloss))\n\t\t\t\treturn true;\n\n\t\t\tgot_match = false;\n\t\t}\n\t}\n\n\treturn got_match;\n}\n\nstatic void filter_duplicate_data(void *data, void *user_data)\n{\n\tstruct discovery_client *client = data;\n\tbool *duplicate = user_data;\n\n\tif (*duplicate || !client->discovery_filter)\n\t\treturn;\n\n\t*duplicate = client->discovery_filter->duplicate;\n}\n\nstatic bool device_is_discoverable(struct btd_adapter *adapter,\n\t\t\t\t\tstruct eir_data *eir, const char *addr,\n\t\t\t\t\tuint8_t bdaddr_type)\n{\n\tGSList *l;\n\tbool discoverable;\n\n\tif (bdaddr_type == BDADDR_BREDR || adapter->filtered_discovery)\n\t\tdiscoverable = true;\n\telse\n\t\tdiscoverable = eir->flags & (EIR_LIM_DISC | EIR_GEN_DISC);\n\n\t/*\n\t * Mark as not discoverable if no client has requested discovery and\n\t * report has not set any discoverable flags.\n\t */\n\tif (!adapter->discovery_list && !discoverable)\n\t\treturn false;\n\n\t/* Do a prefix match for both address and name if pattern is set */\n\tfor (l = adapter->discovery_list; l; l = g_slist_next(l)) {\n\t\tstruct discovery_client *client = l->data;\n\t\tstruct discovery_filter *filter = client->discovery_filter;\n\t\tsize_t pattern_len;\n\n\t\tif (!filter || !filter->pattern)\n\t\t\tcontinue;\n\n\t\t/* Reset discoverable if a client has a pattern filter */\n\t\tdiscoverable = false;\n\n\t\tpattern_len = strlen(filter->pattern);\n\t\tif (!pattern_len)\n\t\t\treturn true;\n\n\t\tif (!strncmp(filter->pattern, addr, pattern_len))\n\t\t\treturn true;\n\n\t\tif (eir->name && !strncmp(filter->pattern, eir->name,\n\t\t\t\t\t\t\tpattern_len))\n\t\t\treturn true;\n\t}\n\n\treturn discoverable;\n}\n\nstatic void update_found_devices(struct btd_adapter *adapter,\n\t\t\t\t\tconst bdaddr_t *bdaddr,\n\t\t\t\t\tuint8_t bdaddr_type, int8_t rssi,\n\t\t\t\t\tbool confirm, bool legacy,\n\t\t\t\t\tbool not_connectable,\n\t\t\t\t\tconst uint8_t *data, uint8_t data_len)\n{\n\tstruct btd_device *dev;\n\tstruct bt_ad *ad = NULL;\n\tstruct eir_data eir_data;\n\tbool name_known, discoverable;\n\tchar addr[18];\n\tbool duplicate = false;\n\tstruct queue *matched_monitors = NULL;\n\n\tif (bdaddr_type != BDADDR_BREDR)\n\t\tad = bt_ad_new_with_data(data_len, data);\n\n\t/* During the background scanning, update the device only when the data\n\t * match at least one Adv monitor\n\t */\n\tif (ad) {\n\t\tmatched_monitors = btd_adv_monitor_content_filter(\n\t\t\t\t\tadapter->adv_monitor_manager, ad);\n\t\tbt_ad_unref(ad);\n\t\tad = NULL;\n\t}\n\n\tif (!adapter->discovering && !matched_monitors)\n\t\treturn;\n\n\tmemset(&eir_data, 0, sizeof(eir_data));\n\teir_parse(&eir_data, data, data_len);\n\n\tba2str(bdaddr, addr);\n\n\tdiscoverable = device_is_discoverable(adapter, &eir_data, addr,\n\t\t\t\t\t\t\tbdaddr_type);\n\n\tdev = btd_adapter_find_device(adapter, bdaddr, bdaddr_type);\n\tif (!dev) {\n\t\tif (!discoverable && !matched_monitors) {\n\t\t\teir_data_free(&eir_data);\n\t\t\treturn;\n\t\t}\n\n\t\tdev = adapter_create_device(adapter, bdaddr, bdaddr_type);\n\t}\n\n\tif (!dev) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\"Unable to create object for found device %s\", addr);\n\t\teir_data_free(&eir_data);\n\t\treturn;\n\t}\n\n\tdevice_update_last_seen(dev, bdaddr_type);\n\n\t/*\n\t * FIXME: We need to check for non-zero flags first because\n\t * older kernels send separate adv_ind and scan_rsp. Newer\n\t * kernels send them merged, so once we know which mgmt version\n\t * supports this we can make the non-zero check conditional.\n\t */\n\tif (bdaddr_type != BDADDR_BREDR && eir_data.flags &&\n\t\t\t\t\t!(eir_data.flags & EIR_BREDR_UNSUP)) {\n\t\tdevice_set_bredr_support(dev);\n\t\t/* Update last seen for BR/EDR in case its flag is set */\n\t\tdevice_update_last_seen(dev, BDADDR_BREDR);\n\t}\n\n\tif (eir_data.name != NULL && eir_data.name_complete)\n\t\tdevice_store_cached_name(dev, eir_data.name);\n\n\t/*\n\t * Only skip devices that are not connected, are temporary, and there\n\t * is no active discovery session ongoing and no matched Adv monitors\n\t */\n\tif (!btd_device_is_connected(dev) &&\n\t\t(device_is_temporary(dev) && !adapter->discovery_list) &&\n\t\t!matched_monitors) {\n\t\teir_data_free(&eir_data);\n\t\treturn;\n\t}\n\n\t/* If there is no matched Adv monitors, don't continue if not\n\t * discoverable or if active discovery filter don't match.\n\t */\n\tif (!matched_monitors && (!discoverable ||\n\t\t(adapter->filtered_discovery && !is_filter_match(\n\t\t\t\tadapter->discovery_list, &eir_data, rssi)))) {\n\t\teir_data_free(&eir_data);\n\t\treturn;\n\t}\n\n\tdevice_set_legacy(dev, legacy);\n\n\tif (adapter->filtered_discovery)\n\t\tdevice_set_rssi_with_delta(dev, rssi, 0);\n\telse\n\t\tdevice_set_rssi(dev, rssi);\n\n\tif (eir_data.tx_power != 127)\n\t\tdevice_set_tx_power(dev, eir_data.tx_power);\n\n\tif (eir_data.appearance != 0)\n\t\tdevice_set_appearance(dev, eir_data.appearance);\n\n\t/* Report an unknown name to the kernel even if there is a short name\n\t * known, but still update the name with the known short name. */\n\tname_known = device_name_known(dev);\n\n\tif (eir_data.name && (eir_data.name_complete || !name_known))\n\t\tbtd_device_device_set_name(dev, eir_data.name);\n\n\tif (eir_data.class != 0)\n\t\tdevice_set_class(dev, eir_data.class);\n\n\tif (eir_data.did_source || eir_data.did_vendor ||\n\t\t\teir_data.did_product || eir_data.did_version)\n\t\tbtd_device_set_pnpid(dev, eir_data.did_source,\n\t\t\t\t\t\t\teir_data.did_vendor,\n\t\t\t\t\t\t\teir_data.did_product,\n\t\t\t\t\t\t\teir_data.did_version);\n\n\tdevice_add_eir_uuids(dev, eir_data.services);\n\n\tif (adapter->discovery_list)\n\t\tg_slist_foreach(adapter->discovery_list, filter_duplicate_data,\n\t\t\t\t\t\t\t\t&duplicate);\n\n\tif (eir_data.msd_list) {\n\t\tdevice_set_manufacturer_data(dev, eir_data.msd_list, duplicate);\n\t\tadapter_msd_notify(adapter, dev, eir_data.msd_list);\n\t}\n\n\tif (eir_data.sd_list)\n\t\tdevice_set_service_data(dev, eir_data.sd_list, duplicate);\n\n\tif (eir_data.data_list)\n\t\tdevice_set_data(dev, eir_data.data_list, duplicate);\n\n\tif (bdaddr_type != BDADDR_BREDR)\n\t\tdevice_set_flags(dev, eir_data.flags);\n\n\teir_data_free(&eir_data);\n\n\t/* After the device is updated, notify the matched Adv monitors */\n\tif (matched_monitors) {\n\t\tbtd_adv_monitor_notify_monitors(adapter->adv_monitor_manager,\n\t\t\t\t\t\tdev, rssi, matched_monitors);\n\t\tqueue_destroy(matched_monitors, NULL);\n\t\tmatched_monitors = NULL;\n\t}\n\n\t/*\n\t * Only if at least one client has requested discovery, maintain\n\t * list of found devices and name confirming for legacy devices.\n\t * Otherwise, this is an event from passive discovery and we\n\t * should check if the device needs connecting to.\n\t */\n\tif (!adapter->discovery_list)\n\t\tgoto connect_le;\n\n\tif (g_slist_find(adapter->discovery_found, dev))\n\t\treturn;\n\n\tif (confirm)\n\t\tconfirm_name(adapter, bdaddr, bdaddr_type, name_known);\n\n\tadapter->discovery_found = g_slist_prepend(adapter->discovery_found,\n\t\t\t\t\t\t\t\t\tdev);\n\n\treturn;\n\nconnect_le:\n\t/* Ignore non-connectable events */\n\tif (not_connectable)\n\t\treturn;\n\n\t/*\n\t * If we're in the process of stopping passive scanning and\n\t * connecting another (or maybe even the same) LE device just\n\t * ignore this one.\n\t */\n\tif (adapter->connect_le)\n\t\treturn;\n\n\t/*\n\t * If kernel background scan is used then the kernel is\n\t * responsible for connecting.\n\t */\n\tif (btd_has_kernel_features(KERNEL_CONN_CONTROL))\n\t\treturn;\n\n\t/*\n\t * If this is an LE device that's not connected and part of the\n\t * connect_list stop passive scanning so that a connection\n\t * attempt to it can be made\n\t */\n\tif (bdaddr_type != BDADDR_BREDR && !btd_device_is_connected(dev) &&\n\t\t\t\tg_slist_find(adapter->connect_list, dev)) {\n\t\tadapter->connect_le = dev;\n\t\tstop_passive_scanning(adapter);\n\t}\n}\n\nstatic void device_found_callback(uint16_t index, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_ev_device_found *ev = param;\n\tstruct btd_adapter *adapter = user_data;\n\tconst uint8_t *eir;\n\tuint16_t eir_len;\n\tuint32_t flags;\n\tbool confirm_name;\n\tbool legacy;\n\tchar addr[18];\n\n\tif (length < sizeof(*ev)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\"Too short device found event (%u bytes)\", length);\n\t\treturn;\n\t}\n\n\teir_len = btohs(ev->eir_len);\n\tif (length != sizeof(*ev) + eir_len) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Device found event size mismatch (%u != %zu)\",\n\t\t\t\t\tlength, sizeof(*ev) + eir_len);\n\t\treturn;\n\t}\n\n\tif (eir_len == 0)\n\t\teir = NULL;\n\telse\n\t\teir = ev->eir;\n\n\tflags = btohl(ev->flags);\n\n\tba2str(&ev->addr.bdaddr, addr);\n\tDBG(\"hci%u addr %s, rssi %d flags 0x%04x eir_len %u\",\n\t\t\tindex, addr, ev->rssi, flags, eir_len);\n\n\tconfirm_name = (flags & MGMT_DEV_FOUND_CONFIRM_NAME);\n\tlegacy = (flags & MGMT_DEV_FOUND_LEGACY_PAIRING);\n\n\tupdate_found_devices(adapter, &ev->addr.bdaddr, ev->addr.type,\n\t\t\t\t\tev->rssi, confirm_name, legacy,\n\t\t\t\t\tflags & MGMT_DEV_FOUND_NOT_CONNECTABLE,\n\t\t\t\t\teir, eir_len);\n}\n\nstruct agent *adapter_get_agent(struct btd_adapter *adapter)\n{\n\treturn agent_get(NULL);\n}\n\nstatic void adapter_remove_connection(struct btd_adapter *adapter,\n\t\t\t\t\t\tstruct btd_device *device,\n\t\t\t\t\t\tuint8_t bdaddr_type)\n{\n\tDBG(\"\");\n\n\tif (!g_slist_find(adapter->connections, device)) {\n\t\tbtd_error(adapter->dev_id, \"No matching connection for device\");\n\t\treturn;\n\t}\n\n\tdevice_remove_connection(device, bdaddr_type);\n\n\tif (device_is_authenticating(device))\n\t\tdevice_cancel_authentication(device, TRUE);\n\n\t/* If another bearer is still connected */\n\tif (btd_device_is_connected(device))\n\t\treturn;\n\n\tadapter->connections = g_slist_remove(adapter->connections, device);\n}\n\nstatic void adapter_stop(struct btd_adapter *adapter)\n{\n\t/* check pending requests */\n\treply_pending_requests(adapter);\n\n\tcancel_passive_scanning(adapter);\n\n\tremove_discovery_list(adapter);\n\n\tdiscovery_cleanup(adapter, 0);\n\n\tadapter->filtered_discovery = false;\n\tadapter->no_scan_restart_delay = false;\n\tg_free(adapter->current_discovery_filter);\n\tadapter->current_discovery_filter = NULL;\n\n\tadapter->discovering = false;\n\n\twhile (adapter->connections) {\n\t\tstruct btd_device *device = adapter->connections->data;\n\t\tuint8_t addr_type = btd_device_get_bdaddr_type(device);\n\n\t\tadapter_remove_connection(adapter, device, BDADDR_BREDR);\n\t\tif (addr_type != BDADDR_BREDR)\n\t\t\tadapter_remove_connection(adapter, device, addr_type);\n\t}\n\n\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Discovering\");\n\n\tif (adapter->dev_class) {\n\t\t/* the kernel should reset the class of device when powering\n\t\t * down, but it does not. So force it here ... */\n\t\tadapter->dev_class = 0;\n\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\t\tADAPTER_INTERFACE, \"Class\");\n\t}\n\n\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\t\tADAPTER_INTERFACE, \"Powered\");\n\n\tDBG(\"adapter %s has been disabled\", adapter->path);\n}\n\nint btd_register_adapter_driver(struct btd_adapter_driver *driver)\n{\n\tadapter_drivers = g_slist_append(adapter_drivers, driver);\n\n\tif (driver->probe == NULL)\n\t\treturn 0;\n\n\tadapter_foreach(probe_driver, driver);\n\n\treturn 0;\n}\n\nstatic void unload_driver(struct btd_adapter *adapter, gpointer data)\n{\n\tstruct btd_adapter_driver *driver = data;\n\n\tif (driver->remove)\n\t\tdriver->remove(adapter);\n\n\tadapter->drivers = g_slist_remove(adapter->drivers, data);\n}\n\nvoid btd_unregister_adapter_driver(struct btd_adapter_driver *driver)\n{\n\tadapter_drivers = g_slist_remove(adapter_drivers, driver);\n\n\tadapter_foreach(unload_driver, driver);\n}\n\nstatic void agent_auth_cb(struct agent *agent, DBusError *derr,\n\t\t\t\t\t\t\tvoid *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tstruct service_auth *auth = g_queue_pop_head(adapter->auths);\n\n\tif (!auth) {\n\t\tDBG(\"No pending authorization\");\n\t\treturn;\n\t}\n\n\tauth->cb(derr, auth->user_data);\n\n\tif (auth->agent)\n\t\tagent_unref(auth->agent);\n\n\tg_free(auth);\n\n\t/* Stop processing if queue is empty */\n\tif (g_queue_is_empty(adapter->auths)) {\n\t\tif (adapter->auth_idle_id > 0)\n\t\t\tg_source_remove(adapter->auth_idle_id);\n\t\treturn;\n\t}\n\n\tif (adapter->auth_idle_id > 0)\n\t\treturn;\n\n\tadapter->auth_idle_id = g_idle_add(process_auth_queue, adapter);\n}\n\nstatic gboolean process_auth_queue(gpointer user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tDBusError err;\n\n\tadapter->auth_idle_id = 0;\n\n\tdbus_error_init(&err);\n\tdbus_set_error_const(&err, ERROR_INTERFACE \".Rejected\", NULL);\n\n\twhile (!g_queue_is_empty(adapter->auths)) {\n\t\tstruct service_auth *auth = adapter->auths->head->data;\n\t\tstruct btd_device *device = auth->device;\n\n\t\t/* Wait services to be resolved before asking authorization */\n\t\tif (auth->svc_id > 0)\n\t\t\treturn FALSE;\n\n\t\tif (device_is_trusted(device) == TRUE) {\n\t\t\tauth->cb(NULL, auth->user_data);\n\t\t\tgoto next;\n\t\t}\n\n\t\t/* If agent is set authorization is already ongoing */\n\t\tif (auth->agent)\n\t\t\treturn FALSE;\n\n\t\tauth->agent = agent_get(NULL);\n\t\tif (auth->agent == NULL) {\n\t\t\tbtd_warn(adapter->dev_id,\n\t\t\t\t\t\"Authentication attempt without agent\");\n\t\t\tauth->cb(&err, auth->user_data);\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (agent_authorize_service(auth->agent, device, auth->uuid,\n\t\t\t\t\tagent_auth_cb, adapter, NULL) < 0) {\n\t\t\tauth->cb(&err, auth->user_data);\n\t\t\tgoto next;\n\t\t}\n\n\t\tbreak;\n\nnext:\n\t\tif (auth->agent)\n\t\t\tagent_unref(auth->agent);\n\n\t\tg_free(auth);\n\n\t\tg_queue_pop_head(adapter->auths);\n\t}\n\n\tdbus_error_free(&err);\n\n\treturn FALSE;\n}\n\nstatic void svc_complete(struct btd_device *dev, int err, void *user_data)\n{\n\tstruct service_auth *auth = user_data;\n\tstruct btd_adapter *adapter = auth->adapter;\n\n\tauth->svc_id = 0;\n\n\tif (adapter->auth_idle_id != 0)\n\t\treturn;\n\n\tadapter->auth_idle_id = g_idle_add(process_auth_queue, adapter);\n}\n\nstatic int adapter_authorize(struct btd_adapter *adapter, const bdaddr_t *dst,\n\t\t\t\t\tconst char *uuid,\n\t\t\t\t\tadapter_authorize_type check_for_connection,\n\t\t\t\t\tservice_auth_cb cb, void *user_data)\n{\n\tstruct service_auth *auth;\n\tstruct btd_device *device;\n\tstatic guint id = 0;\n\n\tdevice = btd_adapter_find_device(adapter, dst, BDADDR_BREDR);\n\tif (!device)\n\t\treturn 0;\n\n\tif (device_is_disconnecting(device)) {\n\t\tDBG(\"Authorization request while disconnecting\");\n\t\treturn 0;\n\t}\n\n\t/* Device connected? */\n\tif (check_for_connection && !g_slist_find(adapter->connections, device))\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\"Authorization request for non-connected device!?\");\n\n\tauth = g_try_new0(struct service_auth, 1);\n\tif (!auth)\n\t\treturn 0;\n\n\tauth->cb = cb;\n\tauth->user_data = user_data;\n\tauth->uuid = uuid;\n\tauth->device = device;\n\tauth->adapter = adapter;\n\tauth->id = ++id;\n\tif (check_for_connection)\n\t\tauth->svc_id = device_wait_for_svc_complete(device, svc_complete, auth);\n\telse {\n\t\tif (adapter->auth_idle_id == 0)\n\t\t\tadapter->auth_idle_id = g_idle_add(process_auth_queue, adapter);\n\t}\n\n\tg_queue_push_tail(adapter->auths, auth);\n\n\treturn auth->id;\n}\n\nguint btd_request_authorization(const bdaddr_t *src, const bdaddr_t *dst,\n\t\t\t\t\tconst char *uuid, service_auth_cb cb,\n\t\t\t\t\tvoid *user_data)\n{\n\tstruct btd_adapter *adapter;\n\tGSList *l;\n\n\tif (bacmp(src, BDADDR_ANY) != 0) {\n\t\tadapter = adapter_find(src);\n\t\tif (!adapter)\n\t\t\treturn 0;\n\n\t\treturn adapter_authorize(adapter, dst, uuid,\n\t\t\t\tADAPTER_AUTHORIZE_CHECK_CONNECTED, cb, user_data);\n\t}\n\n\tfor (l = adapters; l != NULL; l = g_slist_next(l)) {\n\t\tguint id;\n\n\t\tadapter = l->data;\n\n\t\tid = adapter_authorize(adapter, dst, uuid,\n\t\t\t\tADAPTER_AUTHORIZE_CHECK_CONNECTED, cb, user_data);\n\t\tif (id != 0)\n\t\t\treturn id;\n\t}\n\n\treturn 0;\n}\n\nguint btd_request_authorization_cable_configured(const bdaddr_t *src, const bdaddr_t *dst,\n\t\t\t\t\t\tconst char *uuid, service_auth_cb cb,\n\t\t\t\t\t\tvoid *user_data)\n{\n\tstruct btd_adapter *adapter;\n\n\tif (bacmp(src, BDADDR_ANY) == 0)\n\t\treturn 0;\n\n\tadapter = adapter_find(src);\n\tif (!adapter)\n\t\treturn 0;\n\n\treturn adapter_authorize(adapter, dst, uuid,\n\t\t\tADAPTER_AUTHORIZE_DISCONNECTED, cb, user_data);\n}\n\nstatic struct service_auth *find_authorization(guint id)\n{\n\tGSList *l;\n\tGList *l2;\n\n\tfor (l = adapters; l != NULL; l = g_slist_next(l)) {\n\t\tstruct btd_adapter *adapter = l->data;\n\n\t\tfor (l2 = adapter->auths->head; l2 != NULL; l2 = l2->next) {\n\t\t\tstruct service_auth *auth = l2->data;\n\n\t\t\tif (auth->id == id)\n\t\t\t\treturn auth;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nint btd_cancel_authorization(guint id)\n{\n\tstruct service_auth *auth;\n\n\tauth = find_authorization(id);\n\tif (auth == NULL)\n\t\treturn -EPERM;\n\n\tif (auth->svc_id > 0)\n\t\tdevice_remove_svc_complete_callback(auth->device,\n\t\t\t\t\t\t\t\tauth->svc_id);\n\n\tg_queue_remove(auth->adapter->auths, auth);\n\n\tif (auth->agent) {\n\t\tagent_cancel(auth->agent);\n\t\tagent_unref(auth->agent);\n\t}\n\n\tg_free(auth);\n\n\treturn 0;\n}\n\nint btd_adapter_restore_powered(struct btd_adapter *adapter)\n{\n\tif (btd_adapter_get_powered(adapter))\n\t\treturn 0;\n\n\tset_mode(adapter, MGMT_OP_SET_POWERED, 0x01);\n\n\treturn 0;\n}\n\nvoid btd_adapter_register_pin_cb(struct btd_adapter *adapter,\n\t\t\t\t\t\t\tbtd_adapter_pin_cb_t cb)\n{\n\tadapter->pin_callbacks = g_slist_prepend(adapter->pin_callbacks, cb);\n}\n\nvoid btd_adapter_unregister_pin_cb(struct btd_adapter *adapter,\n\t\t\t\t\t\t\tbtd_adapter_pin_cb_t cb)\n{\n\tadapter->pin_callbacks = g_slist_remove(adapter->pin_callbacks, cb);\n}\n\nvoid btd_adapter_unregister_msd_cb(struct btd_adapter *adapter,\n\t\t\t\t\t\t\tbtd_msd_cb_t cb)\n{\n\tadapter->msd_callbacks = g_slist_remove(adapter->msd_callbacks, cb);\n}\n\nvoid btd_adapter_register_msd_cb(struct btd_adapter *adapter,\n\t\t\t\t\t\t\tbtd_msd_cb_t cb)\n{\n\tadapter->msd_callbacks = g_slist_prepend(adapter->msd_callbacks, cb);\n}\n\nint btd_adapter_set_fast_connectable(struct btd_adapter *adapter,\n\t\t\t\t\t\t\tgboolean enable)\n{\n\tif (!btd_adapter_get_powered(adapter))\n\t\treturn -EINVAL;\n\n\tset_mode(adapter, MGMT_OP_SET_FAST_CONNECTABLE, enable ? 0x01 : 0x00);\n\n\treturn 0;\n}\n\nint btd_adapter_read_clock(struct btd_adapter *adapter, const bdaddr_t *bdaddr,\n\t\t\t\tint which, int timeout, uint32_t *clock,\n\t\t\t\tuint16_t *accuracy)\n{\n\tif (!btd_adapter_get_powered(adapter))\n\t\treturn -EINVAL;\n\n\treturn -ENOSYS;\n}\n\nint btd_adapter_remove_bonding(struct btd_adapter *adapter,\n\t\t\t\tconst bdaddr_t *bdaddr, uint8_t bdaddr_type)\n{\n\tstruct mgmt_cp_unpair_device cp;\n\n\tmemset(&cp, 0, sizeof(cp));\n\tbacpy(&cp.addr.bdaddr, bdaddr);\n\tcp.addr.type = bdaddr_type;\n\tcp.disconnect = 1;\n\n\tif (mgmt_send(adapter->mgmt, MGMT_OP_UNPAIR_DEVICE,\n\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\tNULL, NULL, NULL) > 0)\n\t\treturn 0;\n\n\treturn -EIO;\n}\n\nstatic void pincode_reply_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_device *device = user_data;\n\n\t/* If the MGMT_OP_PIN_CODE_REPLY command is acknowledged, move the\n\t * starting time to that point. This give a better sense of time\n\t * evaluating the pincode. */\n\tdevice_bonding_restart_timer(device);\n}\n\nint btd_adapter_pincode_reply(struct btd_adapter *adapter,\n\t\t\t\t\tconst bdaddr_t *bdaddr,\n\t\t\t\t\tconst char *pin, size_t pin_len)\n{\n\tstruct btd_device *device;\n\tunsigned int id;\n\tchar addr[18];\n\n\tba2str(bdaddr, addr);\n\tDBG(\"hci%u addr %s pinlen %zu\", adapter->dev_id, addr, pin_len);\n\n\tif (pin == NULL) {\n\t\tstruct mgmt_cp_pin_code_neg_reply cp;\n\n\t\tmemset(&cp, 0, sizeof(cp));\n\t\tbacpy(&cp.addr.bdaddr, bdaddr);\n\t\tcp.addr.type = BDADDR_BREDR;\n\n\t\tid = mgmt_reply(adapter->mgmt, MGMT_OP_PIN_CODE_NEG_REPLY,\n\t\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\t\tNULL, NULL, NULL);\n\t} else {\n\t\tstruct mgmt_cp_pin_code_reply cp;\n\n\t\tif (pin_len > 16)\n\t\t\treturn -EINVAL;\n\n\t\tmemset(&cp, 0, sizeof(cp));\n\t\tbacpy(&cp.addr.bdaddr, bdaddr);\n\t\tcp.addr.type = BDADDR_BREDR;\n\t\tcp.pin_len = pin_len;\n\t\tmemcpy(cp.pin_code, pin, pin_len);\n\n\t\t/* Since a pincode was requested, update the starting time to\n\t\t * the point where the pincode is provided. */\n\t\tdevice = btd_adapter_find_device(adapter, bdaddr, BDADDR_BREDR);\n\t\tdevice_bonding_restart_timer(device);\n\n\t\tid = mgmt_reply(adapter->mgmt, MGMT_OP_PIN_CODE_REPLY,\n\t\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\t\tpincode_reply_complete, device, NULL);\n\t}\n\n\tif (id == 0)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nint btd_adapter_confirm_reply(struct btd_adapter *adapter,\n\t\t\t\tconst bdaddr_t *bdaddr, uint8_t bdaddr_type,\n\t\t\t\tgboolean success)\n{\n\tstruct mgmt_cp_user_confirm_reply cp;\n\tuint16_t opcode;\n\tchar addr[18];\n\n\tba2str(bdaddr, addr);\n\tDBG(\"hci%u addr %s success %d\", adapter->dev_id, addr, success);\n\n\tif (success)\n\t\topcode = MGMT_OP_USER_CONFIRM_REPLY;\n\telse\n\t\topcode = MGMT_OP_USER_CONFIRM_NEG_REPLY;\n\n\tmemset(&cp, 0, sizeof(cp));\n\tbacpy(&cp.addr.bdaddr, bdaddr);\n\tcp.addr.type = bdaddr_type;\n\n\tif (mgmt_reply(adapter->mgmt, opcode, adapter->dev_id, sizeof(cp), &cp,\n\t\t\t\t\t\t\tNULL, NULL, NULL) > 0)\n\t\treturn 0;\n\n\treturn -EIO;\n}\n\nstatic void user_confirm_request_callback(uint16_t index, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_ev_user_confirm_request *ev = param;\n\tstruct btd_adapter *adapter = user_data;\n\tstruct btd_device *device;\n\tchar addr[18];\n\tint err;\n\n\tif (length < sizeof(*ev)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Too small user confirm request event\");\n\t\treturn;\n\t}\n\n\tba2str(&ev->addr.bdaddr, addr);\n\tDBG(\"hci%u %s confirm_hint %u\", adapter->dev_id, addr,\n\t\t\t\t\t\t\tev->confirm_hint);\n\tdevice = btd_adapter_get_device(adapter, &ev->addr.bdaddr,\n\t\t\t\t\t\t\t\tev->addr.type);\n\tif (!device) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Unable to get device object for %s\", addr);\n\t\treturn;\n\t}\n\n\terr = device_confirm_passkey(device, ev->addr.type, btohl(ev->value),\n\t\t\t\t\t\t\tev->confirm_hint);\n\tif (err < 0) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"device_confirm_passkey: %s\", strerror(-err));\n\t\tbtd_adapter_confirm_reply(adapter, &ev->addr.bdaddr,\n\t\t\t\t\t\t\tev->addr.type, FALSE);\n\t}\n}\n\nint btd_adapter_passkey_reply(struct btd_adapter *adapter,\n\t\t\t\tconst bdaddr_t *bdaddr, uint8_t bdaddr_type,\n\t\t\t\tuint32_t passkey)\n{\n\tunsigned int id;\n\tchar addr[18];\n\n\tba2str(bdaddr, addr);\n\tDBG(\"hci%u addr %s passkey %06u\", adapter->dev_id, addr, passkey);\n\n\tif (passkey == INVALID_PASSKEY) {\n\t\tstruct mgmt_cp_user_passkey_neg_reply cp;\n\n\t\tmemset(&cp, 0, sizeof(cp));\n\t\tbacpy(&cp.addr.bdaddr, bdaddr);\n\t\tcp.addr.type = bdaddr_type;\n\n\t\tid = mgmt_reply(adapter->mgmt, MGMT_OP_USER_PASSKEY_NEG_REPLY,\n\t\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\t\tNULL, NULL, NULL);\n\t} else {\n\t\tstruct mgmt_cp_user_passkey_reply cp;\n\n\t\tmemset(&cp, 0, sizeof(cp));\n\t\tbacpy(&cp.addr.bdaddr, bdaddr);\n\t\tcp.addr.type = bdaddr_type;\n\t\tcp.passkey = htobl(passkey);\n\n\t\tid = mgmt_reply(adapter->mgmt, MGMT_OP_USER_PASSKEY_REPLY,\n\t\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\t\tNULL, NULL, NULL);\n\t}\n\n\tif (id == 0)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic void user_passkey_request_callback(uint16_t index, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_ev_user_passkey_request *ev = param;\n\tstruct btd_adapter *adapter = user_data;\n\tstruct btd_device *device;\n\tchar addr[18];\n\tint err;\n\n\tif (length < sizeof(*ev)) {\n\t\tbtd_error(adapter->dev_id, \"Too small passkey request event\");\n\t\treturn;\n\t}\n\n\tba2str(&ev->addr.bdaddr, addr);\n\tDBG(\"hci%u %s\", index, addr);\n\n\tdevice = btd_adapter_get_device(adapter, &ev->addr.bdaddr,\n\t\t\t\t\t\t\t\tev->addr.type);\n\tif (!device) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Unable to get device object for %s\", addr);\n\t\treturn;\n\t}\n\n\terr = device_request_passkey(device, ev->addr.type);\n\tif (err < 0) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"device_request_passkey: %s\", strerror(-err));\n\t\tbtd_adapter_passkey_reply(adapter, &ev->addr.bdaddr,\n\t\t\t\t\tev->addr.type, INVALID_PASSKEY);\n\t}\n}\n\nstatic void user_passkey_notify_callback(uint16_t index, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_ev_passkey_notify *ev = param;\n\tstruct btd_adapter *adapter = user_data;\n\tstruct btd_device *device;\n\tuint32_t passkey;\n\tchar addr[18];\n\tint err;\n\n\tif (length < sizeof(*ev)) {\n\t\tbtd_error(adapter->dev_id, \"Too small passkey notify event\");\n\t\treturn;\n\t}\n\n\tba2str(&ev->addr.bdaddr, addr);\n\tDBG(\"hci%u %s\", index, addr);\n\n\tdevice = btd_adapter_get_device(adapter, &ev->addr.bdaddr,\n\t\t\t\t\t\t\t\tev->addr.type);\n\tif (!device) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Unable to get device object for %s\", addr);\n\t\treturn;\n\t}\n\n\tpasskey = get_le32(&ev->passkey);\n\n\tDBG(\"passkey %06u entered %u\", passkey, ev->entered);\n\n\terr = device_notify_passkey(device, ev->addr.type, passkey,\n\t\t\t\t\t\t\t\tev->entered);\n\tif (err < 0)\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"device_notify_passkey: %s\", strerror(-err));\n}\n\nstruct btd_adapter_pin_cb_iter *btd_adapter_pin_cb_iter_new(\n\t\t\t\t\t\tstruct btd_adapter *adapter)\n{\n\tstruct btd_adapter_pin_cb_iter *iter =\n\t\t\t\tg_new0(struct btd_adapter_pin_cb_iter, 1);\n\n\titer->it = adapter->pin_callbacks;\n\titer->attempt = 1;\n\n\treturn iter;\n}\n\nvoid btd_adapter_pin_cb_iter_free(struct btd_adapter_pin_cb_iter *iter)\n{\n\tg_free(iter);\n}\n\nbool btd_adapter_pin_cb_iter_end(struct btd_adapter_pin_cb_iter *iter)\n{\n\treturn iter->it == NULL && iter->attempt == 0;\n}\n\nstatic ssize_t btd_adapter_pin_cb_iter_next(\n\t\t\t\t\tstruct btd_adapter_pin_cb_iter *iter,\n\t\t\t\t\tstruct btd_adapter *adapter,\n\t\t\t\t\tstruct btd_device *device,\n\t\t\t\t\tchar *pin_buf, bool *display)\n{\n\tbtd_adapter_pin_cb_t cb;\n\tssize_t ret;\n\n\twhile (iter->it != NULL) {\n\t\tcb = iter->it->data;\n\t\tret = cb(adapter, device, pin_buf, display, iter->attempt);\n\t\titer->attempt++;\n\t\tif (ret > 0)\n\t\t\treturn ret;\n\t\titer->attempt = 1;\n\t\titer->it = g_slist_next(iter->it);\n\t}\n\titer->attempt = 0;\n\n\treturn 0;\n}\n\nstatic void pin_code_request_callback(uint16_t index, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_ev_pin_code_request *ev = param;\n\tstruct btd_adapter *adapter = user_data;\n\tstruct btd_device *device;\n\tbool display = false;\n\tchar pin[17];\n\tssize_t pinlen;\n\tchar addr[18];\n\tint err;\n\tstruct btd_adapter_pin_cb_iter *iter;\n\n\tif (length < sizeof(*ev)) {\n\t\tbtd_error(adapter->dev_id, \"Too small PIN code request event\");\n\t\treturn;\n\t}\n\n\tba2str(&ev->addr.bdaddr, addr);\n\n\tDBG(\"hci%u %s\", adapter->dev_id, addr);\n\n\tdevice = btd_adapter_get_device(adapter, &ev->addr.bdaddr,\n\t\t\t\t\t\t\t\tev->addr.type);\n\tif (!device) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Unable to get device object for %s\", addr);\n\t\treturn;\n\t}\n\n\t/* Flag the request of a pincode to allow a bonding retry. */\n\tadapter->pincode_requested = true;\n\n\tmemset(pin, 0, sizeof(pin));\n\n\titer = device_bonding_iter(device);\n\tif (iter == NULL)\n\t\tpinlen = 0;\n\telse\n\t\tpinlen = btd_adapter_pin_cb_iter_next(iter, adapter, device,\n\t\t\t\t\t\t\t\tpin, &display);\n\n\tif (pinlen > 0 && (!ev->secure || pinlen == 16)) {\n\t\tif (display && device_is_bonding(device, NULL)) {\n\t\t\terr = device_notify_pincode(device, ev->secure, pin);\n\t\t\tif (err < 0) {\n\t\t\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\t\t\"device_notify_pin: %s\",\n\t\t\t\t\t\t\tstrerror(-err));\n\t\t\t\tbtd_adapter_pincode_reply(adapter,\n\t\t\t\t\t\t\t&ev->addr.bdaddr,\n\t\t\t\t\t\t\tNULL, 0);\n\t\t\t}\n\t\t} else {\n\t\t\tbtd_adapter_pincode_reply(adapter, &ev->addr.bdaddr,\n\t\t\t\t\t\t\t\tpin, pinlen);\n\t\t}\n\t\treturn;\n\t}\n\n\terr = device_request_pincode(device, ev->secure);\n\tif (err < 0) {\n\t\tbtd_error(adapter->dev_id, \"device_request_pin: %s\",\n\t\t\t\t\t\t\tstrerror(-err));\n\t\tbtd_adapter_pincode_reply(adapter, &ev->addr.bdaddr, NULL, 0);\n\t}\n}\n\nint adapter_cancel_bonding(struct btd_adapter *adapter, const bdaddr_t *bdaddr,\n\t\t\t\t\t\t\tuint8_t addr_type)\n{\n\tstruct mgmt_addr_info cp;\n\tchar addr[18];\n\n\tba2str(bdaddr, addr);\n\tDBG(\"hci%u bdaddr %s type %u\", adapter->dev_id, addr, addr_type);\n\n\tmemset(&cp, 0, sizeof(cp));\n\tbacpy(&cp.bdaddr, bdaddr);\n\tcp.type = addr_type;\n\n\tif (mgmt_reply(adapter->mgmt, MGMT_OP_CANCEL_PAIR_DEVICE,\n\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\tNULL, NULL, NULL) > 0)\n\t\treturn 0;\n\n\treturn -EIO;\n}\n\nstatic void check_oob_bonding_complete(struct btd_adapter *adapter,\n\t\t\t\t\tconst bdaddr_t *bdaddr, uint8_t status)\n{\n\tif (!adapter->oob_handler || !adapter->oob_handler->bonding_cb)\n\t\treturn;\n\n\tif (bacmp(bdaddr, &adapter->oob_handler->remote_addr) != 0)\n\t\treturn;\n\n\tadapter->oob_handler->bonding_cb(adapter, bdaddr, status,\n\t\t\t\t\tadapter->oob_handler->user_data);\n\n\tg_free(adapter->oob_handler);\n\tadapter->oob_handler = NULL;\n}\n\nstatic void bonding_complete(struct btd_adapter *adapter,\n\t\t\t\t\tconst bdaddr_t *bdaddr,\n\t\t\t\t\tuint8_t addr_type, uint8_t status)\n{\n\tstruct btd_device *device;\n\n\tif (status == 0)\n\t\tdevice = btd_adapter_get_device(adapter, bdaddr, addr_type);\n\telse\n\t\tdevice = btd_adapter_find_device(adapter, bdaddr, addr_type);\n\n\tif (device != NULL)\n\t\tdevice_bonding_complete(device, addr_type, status);\n\n\tresume_discovery(adapter);\n\n\tcheck_oob_bonding_complete(adapter, bdaddr, status);\n}\n\n/* bonding_attempt_complete() handles the end of a \"bonding attempt\" checking if\n * it should begin a new attempt or complete the bonding.\n */\nstatic void bonding_attempt_complete(struct btd_adapter *adapter,\n\t\t\t\t\tconst bdaddr_t *bdaddr,\n\t\t\t\t\tuint8_t addr_type, uint8_t status)\n{\n\tstruct btd_device *device;\n\tchar addr[18];\n\n\tba2str(bdaddr, addr);\n\tDBG(\"hci%u bdaddr %s type %u status 0x%x\", adapter->dev_id, addr,\n\t\t\t\t\t\t\taddr_type, status);\n\n\tif (status == 0)\n\t\tdevice = btd_adapter_get_device(adapter, bdaddr, addr_type);\n\telse\n\t\tdevice = btd_adapter_find_device(adapter, bdaddr, addr_type);\n\n\tif (status == MGMT_STATUS_AUTH_FAILED && adapter->pincode_requested) {\n\t\t/* On faliure, issue a bonding_retry if possible. */\n\t\tif (device != NULL) {\n\t\t\tif (device_bonding_attempt_retry(device) == 0)\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Ignore disconnects during retry. */\n\tif (status == MGMT_STATUS_DISCONNECTED &&\n\t\t\t\t\tdevice && device_is_retrying(device))\n\t\treturn;\n\n\t/* In any other case, finish the bonding. */\n\tbonding_complete(adapter, bdaddr, addr_type, status);\n}\n\nstruct pair_device_data {\n\tstruct btd_adapter *adapter;\n\tbdaddr_t bdaddr;\n\tuint8_t addr_type;\n};\n\nstatic void free_pair_device_data(void *user_data)\n{\n\tstruct pair_device_data *data = user_data;\n\n\tg_free(data);\n}\n\nstatic bool pair_device_timeout(gpointer user_data)\n{\n\tstruct pair_device_data *data = user_data;\n\tstruct btd_adapter *adapter = data->adapter;\n\n\tbtd_error(adapter->dev_id, \"Pair device timed out for hci%u\",\n\t\t\t\t\t\t\tadapter->dev_id);\n\n\tadapter->pair_device_timeout = 0;\n\n\tadapter_cancel_bonding(adapter, &data->bdaddr, data->addr_type);\n\n\treturn FALSE;\n}\n\nstatic void pair_device_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_rp_pair_device *rp = param;\n\tstruct pair_device_data *data = user_data;\n\tstruct btd_adapter *adapter = data->adapter;\n\n\tDBG(\"%s (0x%02x)\", mgmt_errstr(status), status);\n\n\tadapter->pair_device_id = 0;\n\n\tif (adapter->pair_device_timeout > 0) {\n\t\ttimeout_remove(adapter->pair_device_timeout);\n\t\tadapter->pair_device_timeout = 0;\n\t}\n\n\t/* Workaround for a kernel bug\n\t *\n\t * Broken kernels may reply to device pairing command with command\n\t * status instead of command complete event e.g. if adapter was not\n\t * powered.\n\t */\n\tif (status != MGMT_STATUS_SUCCESS && length < sizeof(*rp)) {\n\t\tbtd_error(adapter->dev_id, \"Pair device failed: %s (0x%02x)\",\n\t\t\t\t\t\tmgmt_errstr(status), status);\n\n\t\tbonding_attempt_complete(adapter, &data->bdaddr,\n\t\t\t\t\t\tdata->addr_type, status);\n\t\treturn;\n\t}\n\n\tif (length < sizeof(*rp)) {\n\t\tbtd_error(adapter->dev_id, \"Too small pair device response\");\n\t\treturn;\n\t}\n\n\tbonding_attempt_complete(adapter, &rp->addr.bdaddr, rp->addr.type,\n\t\t\t\t\t\t\t\t\tstatus);\n}\n\nint adapter_create_bonding(struct btd_adapter *adapter, const bdaddr_t *bdaddr,\n\t\t\t\t\tuint8_t addr_type, uint8_t io_cap)\n{\n\tif (adapter->pair_device_id > 0) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\"Unable pair since another pairing is in progress\");\n\t\treturn -EBUSY;\n\t}\n\n\tsuspend_discovery(adapter);\n\n\treturn adapter_bonding_attempt(adapter, bdaddr, addr_type, io_cap);\n}\n\n/* Starts a new bonding attempt in a fresh new bonding_req or a retried one. */\nint adapter_bonding_attempt(struct btd_adapter *adapter, const bdaddr_t *bdaddr,\n\t\t\t\t\tuint8_t addr_type, uint8_t io_cap)\n{\n\tstruct mgmt_cp_pair_device cp;\n\tchar addr[18];\n\tstruct pair_device_data *data;\n\tunsigned int id;\n\n\tba2str(bdaddr, addr);\n\tDBG(\"hci%u bdaddr %s type %d io_cap 0x%02x\",\n\t\t\t\tadapter->dev_id, addr, addr_type, io_cap);\n\n\t/* Reset the pincode_requested flag for a new bonding attempt. */\n\tadapter->pincode_requested = false;\n\n\tmemset(&cp, 0, sizeof(cp));\n\tbacpy(&cp.addr.bdaddr, bdaddr);\n\tcp.addr.type = addr_type;\n\tcp.io_cap = io_cap;\n\n\tdata = g_new0(struct pair_device_data, 1);\n\tdata->adapter = adapter;\n\tbacpy(&data->bdaddr, bdaddr);\n\tdata->addr_type = addr_type;\n\n\tid = mgmt_send(adapter->mgmt, MGMT_OP_PAIR_DEVICE,\n\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\tpair_device_complete, data,\n\t\t\t\tfree_pair_device_data);\n\n\tif (id == 0) {\n\t\tbtd_error(adapter->dev_id, \"Failed to pair %s for hci%u\",\n\t\t\t\t\t\t\taddr, adapter->dev_id);\n\t\tfree_pair_device_data(data);\n\t\treturn -EIO;\n\t}\n\n\tadapter->pair_device_id = id;\n\n\t/* Due to a bug in the kernel it is possible that a LE pairing\n\t * request never times out. Therefore, add a timer to clean up\n\t * if no response arrives\n\t */\n\tadapter->pair_device_timeout = timeout_add_seconds(BONDING_TIMEOUT,\n\t\t\t\t\t\tpair_device_timeout, data,\n\t\t\t\t\t\tNULL);\n\n\treturn 0;\n}\n\nstatic void disconnect_notify(struct btd_device *dev, uint8_t reason)\n{\n\tGSList *l;\n\n\tfor (l = disconnect_list; l; l = g_slist_next(l)) {\n\t\tbtd_disconnect_cb disconnect_cb = l->data;\n\t\tdisconnect_cb(dev, reason);\n\t}\n}\n\nstatic void dev_disconnected(struct btd_adapter *adapter,\n\t\t\t\t\tconst struct mgmt_addr_info *addr,\n\t\t\t\t\tuint8_t reason)\n{\n\tstruct btd_device *device;\n\tchar dst[18];\n\n\tba2str(&addr->bdaddr, dst);\n\n\tDBG(\"Device %s disconnected, reason %u\", dst, reason);\n\n\tdevice = btd_adapter_find_device(adapter, &addr->bdaddr, addr->type);\n\tif (device) {\n\t\tadapter_remove_connection(adapter, device, addr->type);\n\t\tdisconnect_notify(device, reason);\n\t}\n\n\tbonding_attempt_complete(adapter, &addr->bdaddr, addr->type,\n\t\t\t\t\t\tMGMT_STATUS_DISCONNECTED);\n}\n\nvoid btd_add_disconnect_cb(btd_disconnect_cb func)\n{\n\tdisconnect_list = g_slist_append(disconnect_list, func);\n}\n\nvoid btd_remove_disconnect_cb(btd_disconnect_cb func)\n{\n\tdisconnect_list = g_slist_remove(disconnect_list, func);\n}\n\nstatic void disconnect_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_rp_disconnect *rp = param;\n\tstruct btd_adapter *adapter = user_data;\n\n\tif (status == MGMT_STATUS_NOT_CONNECTED) {\n\t\tbtd_warn(adapter->dev_id,\n\t\t\t\t\"Disconnecting failed: already disconnected\");\n\t} else if (status != MGMT_STATUS_SUCCESS) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Failed to disconnect device: %s (0x%02x)\",\n\t\t\t\t\t\tmgmt_errstr(status), status);\n\t\treturn;\n\t}\n\n\tif (length < sizeof(*rp)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Too small device disconnect response\");\n\t\treturn;\n\t}\n\n\tdev_disconnected(adapter, &rp->addr, MGMT_DEV_DISCONN_LOCAL_HOST);\n}\n\nint btd_adapter_disconnect_device(struct btd_adapter *adapter,\n\t\t\t\t\t\tconst bdaddr_t *bdaddr,\n\t\t\t\t\t\tuint8_t bdaddr_type)\n\n{\n\tstruct mgmt_cp_disconnect cp;\n\n\tmemset(&cp, 0, sizeof(cp));\n\tbacpy(&cp.addr.bdaddr, bdaddr);\n\tcp.addr.type = bdaddr_type;\n\n\tif (mgmt_send(adapter->mgmt, MGMT_OP_DISCONNECT,\n\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\tdisconnect_complete, adapter, NULL) > 0)\n\t\treturn 0;\n\n\treturn -EIO;\n}\n\nstatic void auth_failed_callback(uint16_t index, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_ev_auth_failed *ev = param;\n\tstruct btd_adapter *adapter = user_data;\n\n\tif (length < sizeof(*ev)) {\n\t\tbtd_error(adapter->dev_id, \"Too small auth failed mgmt event\");\n\t\treturn;\n\t}\n\n\tbonding_attempt_complete(adapter, &ev->addr.bdaddr, ev->addr.type,\n\t\t\t\t\t\t\t\tev->status);\n}\n\nstatic void store_link_key(struct btd_adapter *adapter,\n\t\t\t\tstruct btd_device *device, const uint8_t *key,\n\t\t\t\tuint8_t type, uint8_t pin_length)\n{\n\tchar device_addr[18];\n\tchar filename[PATH_MAX];\n\tGKeyFile *key_file;\n\tgsize length = 0;\n\tchar key_str[33];\n\tchar *str;\n\tint i;\n\n\tba2str(device_get_address(device), device_addr);\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/%s/info\",\n\t\t\tbtd_adapter_get_storage_dir(adapter), device_addr);\n\tkey_file = g_key_file_new();\n\tg_key_file_load_from_file(key_file, filename, 0, NULL);\n\n\tfor (i = 0; i < 16; i++)\n\t\tsprintf(key_str + (i * 2), \"%2.2X\", key[i]);\n\n\tg_key_file_set_string(key_file, \"LinkKey\", \"Key\", key_str);\n\n\tg_key_file_set_integer(key_file, \"LinkKey\", \"Type\", type);\n\tg_key_file_set_integer(key_file, \"LinkKey\", \"PINLength\", pin_length);\n\n\tcreate_file(filename, 0600);\n\n\tstr = g_key_file_to_data(key_file, &length, NULL);\n\tg_file_set_contents(filename, str, length, NULL);\n\tg_free(str);\n\n\tg_key_file_free(key_file);\n}\n\nstatic void new_link_key_callback(uint16_t index, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_ev_new_link_key *ev = param;\n\tconst struct mgmt_addr_info *addr = &ev->key.addr;\n\tstruct btd_adapter *adapter = user_data;\n\tstruct btd_device *device;\n\tchar dst[18];\n\n\tif (length < sizeof(*ev)) {\n\t\tbtd_error(adapter->dev_id, \"Too small new link key event\");\n\t\treturn;\n\t}\n\n\tba2str(&addr->bdaddr, dst);\n\n\tDBG(\"hci%u new key for %s type %u pin_len %u store_hint %u\",\n\t\tadapter->dev_id, dst, ev->key.type, ev->key.pin_len,\n\t\tev->store_hint);\n\n\tif (ev->key.pin_len > 16) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Invalid PIN length (%u) in new_key event\",\n\t\t\t\t\t\t\tev->key.pin_len);\n\t\treturn;\n\t}\n\n\tdevice = btd_adapter_get_device(adapter, &addr->bdaddr, addr->type);\n\tif (!device) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Unable to get device object for %s\", dst);\n\t\treturn;\n\t}\n\n\tif (ev->store_hint) {\n\t\tconst struct mgmt_link_key_info *key = &ev->key;\n\n\t\tstore_link_key(adapter, device, key->val, key->type,\n\t\t\t\t\t\t\t\tkey->pin_len);\n\n\t\tdevice_set_bonded(device, BDADDR_BREDR);\n\t}\n\n\tbonding_complete(adapter, &addr->bdaddr, addr->type, 0);\n}\n\nstatic void store_longtermkey(struct btd_adapter *adapter, const bdaddr_t *peer,\n\t\t\t\tuint8_t bdaddr_type, const unsigned char *key,\n\t\t\t\tuint8_t master, uint8_t authenticated,\n\t\t\t\tuint8_t enc_size, uint16_t ediv,\n\t\t\t\tuint64_t rand)\n{\n\tconst char *group = master ? \"LongTermKey\" : \"SlaveLongTermKey\";\n\tchar device_addr[18];\n\tchar filename[PATH_MAX];\n\tGKeyFile *key_file;\n\tchar key_str[33];\n\tgsize length = 0;\n\tchar *str;\n\tint i;\n\n\tif (master != 0x00 && master != 0x01) {\n\t\terror(\"Unsupported LTK type %u\", master);\n\t\treturn;\n\t}\n\n\tba2str(peer, device_addr);\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/%s/info\",\n\t\t\tbtd_adapter_get_storage_dir(adapter), device_addr);\n\tkey_file = g_key_file_new();\n\tg_key_file_load_from_file(key_file, filename, 0, NULL);\n\n\t/* Old files may contain this so remove it in case it exists */\n\tg_key_file_remove_key(key_file, \"LongTermKey\", \"Master\", NULL);\n\n\tfor (i = 0; i < 16; i++)\n\t\tsprintf(key_str + (i * 2), \"%2.2X\", key[i]);\n\n\tg_key_file_set_string(key_file, group, \"Key\", key_str);\n\n\tg_key_file_set_integer(key_file, group, \"Authenticated\",\n\t\t\t\t\t\t\tauthenticated);\n\tg_key_file_set_integer(key_file, group, \"EncSize\", enc_size);\n\n\tg_key_file_set_integer(key_file, group, \"EDiv\", ediv);\n\tg_key_file_set_uint64(key_file, group, \"Rand\", rand);\n\n\tcreate_file(filename, 0600);\n\n\tstr = g_key_file_to_data(key_file, &length, NULL);\n\tg_file_set_contents(filename, str, length, NULL);\n\tg_free(str);\n\n\tg_key_file_free(key_file);\n}\n\nstatic void new_long_term_key_callback(uint16_t index, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_ev_new_long_term_key *ev = param;\n\tconst struct mgmt_addr_info *addr = &ev->key.addr;\n\tstruct btd_adapter *adapter = user_data;\n\tstruct btd_device *device;\n\tbool persistent;\n\tchar dst[18];\n\n\tif (length < sizeof(*ev)) {\n\t\tbtd_error(adapter->dev_id, \"Too small long term key event\");\n\t\treturn;\n\t}\n\n\tba2str(&addr->bdaddr, dst);\n\n\tDBG(\"hci%u new LTK for %s type %u enc_size %u\",\n\t\tadapter->dev_id, dst, ev->key.type, ev->key.enc_size);\n\n\tdevice = btd_adapter_get_device(adapter, &addr->bdaddr, addr->type);\n\tif (!device) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Unable to get device object for %s\", dst);\n\t\treturn;\n\t}\n\n\t/*\n\t * Some older kernel versions set store_hint for long term keys\n\t * from resolvable and unresolvable random addresses, but there\n\t * is no point in storing these. Next time around the device\n\t * address will be invalid.\n\t *\n\t * So only for identity addresses (public and static random) use\n\t * the store_hint as an indication if the long term key should\n\t * be persistently stored.\n\t *\n\t */\n\tif (addr->type == BDADDR_LE_RANDOM &&\n\t\t\t\t(addr->bdaddr.b[5] & 0xc0) != 0xc0)\n\t\tpersistent = false;\n\telse\n\t\tpersistent = !!ev->store_hint;\n\n\tif (persistent) {\n\t\tconst struct mgmt_ltk_info *key = &ev->key;\n\t\tuint16_t ediv;\n\t\tuint64_t rand;\n\n\t\tediv = le16_to_cpu(key->ediv);\n\t\trand = le64_to_cpu(key->rand);\n\n\t\tstore_longtermkey(adapter, &key->addr.bdaddr,\n\t\t\t\t\tkey->addr.type, key->val, key->master,\n\t\t\t\t\tkey->type, key->enc_size, ediv, rand);\n\n\t\tdevice_set_bonded(device, addr->type);\n\t}\n\n\tdevice_set_ltk_enc_size(device, ev->key.enc_size);\n\n\tbonding_complete(adapter, &addr->bdaddr, addr->type, 0);\n}\n\nstatic void store_csrk(struct btd_adapter *adapter, const bdaddr_t *peer,\n\t\t\t\tuint8_t bdaddr_type, const unsigned char *key,\n\t\t\t\tuint32_t counter, uint8_t type)\n{\n\tconst char *group;\n\tchar device_addr[18];\n\tchar filename[PATH_MAX];\n\tGKeyFile *key_file;\n\tchar key_str[33];\n\tgsize length = 0;\n\tgboolean auth;\n\tchar *str;\n\tint i;\n\n\tswitch (type) {\n\tcase 0x00:\n\t\tgroup = \"LocalSignatureKey\";\n\t\tauth = FALSE;\n\t\tbreak;\n\tcase 0x01:\n\t\tgroup = \"RemoteSignatureKey\";\n\t\tauth = FALSE;\n\t\tbreak;\n\tcase 0x02:\n\t\tgroup = \"LocalSignatureKey\";\n\t\tauth = TRUE;\n\t\tbreak;\n\tcase 0x03:\n\t\tgroup = \"RemoteSignatureKey\";\n\t\tauth = TRUE;\n\t\tbreak;\n\tdefault:\n\t\twarn(\"Unsupported CSRK type %u\", type);\n\t\treturn;\n\t}\n\n\tba2str(peer, device_addr);\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/%s/info\",\n\t\t\tbtd_adapter_get_storage_dir(adapter), device_addr);\n\n\tkey_file = g_key_file_new();\n\tg_key_file_load_from_file(key_file, filename, 0, NULL);\n\n\tfor (i = 0; i < 16; i++)\n\t\tsprintf(key_str + (i * 2), \"%2.2X\", key[i]);\n\n\tg_key_file_set_string(key_file, group, \"Key\", key_str);\n\tg_key_file_set_integer(key_file, group, \"Counter\", counter);\n\tg_key_file_set_boolean(key_file, group, \"Authenticated\", auth);\n\n\tcreate_file(filename, 0600);\n\n\tstr = g_key_file_to_data(key_file, &length, NULL);\n\tg_file_set_contents(filename, str, length, NULL);\n\tg_free(str);\n\n\tg_key_file_free(key_file);\n}\n\nstatic void new_csrk_callback(uint16_t index, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_ev_new_csrk *ev = param;\n\tconst struct mgmt_addr_info *addr = &ev->key.addr;\n\tconst struct mgmt_csrk_info *key = &ev->key;\n\tstruct btd_adapter *adapter = user_data;\n\tstruct btd_device *device;\n\tchar dst[18];\n\n\tif (length < sizeof(*ev)) {\n\t\tbtd_error(adapter->dev_id, \"Too small CSRK event\");\n\t\treturn;\n\t}\n\n\tba2str(&addr->bdaddr, dst);\n\n\tDBG(\"hci%u new CSRK for %s type %u\", adapter->dev_id, dst,\n\t\t\t\t\t\t\t\tev->key.type);\n\n\tdevice = btd_adapter_get_device(adapter, &addr->bdaddr, addr->type);\n\tif (!device) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Unable to get device object for %s\", dst);\n\t\treturn;\n\t}\n\n\tif (!ev->store_hint)\n\t\treturn;\n\n\tstore_csrk(adapter, &key->addr.bdaddr, key->addr.type, key->val, 0,\n\t\t\t\t\t\t\t\tkey->type);\n\n\tbtd_device_set_temporary(device, false);\n}\n\nstatic void store_irk(struct btd_adapter *adapter, const bdaddr_t *peer,\n\t\t\t\tuint8_t bdaddr_type, const unsigned char *key)\n{\n\tchar device_addr[18];\n\tchar filename[PATH_MAX];\n\tGKeyFile *key_file;\n\tchar *store_data;\n\tchar str[33];\n\tsize_t length = 0;\n\tint i;\n\n\tba2str(peer, device_addr);\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/%s/info\",\n\t\t\tbtd_adapter_get_storage_dir(adapter), device_addr);\n\tkey_file = g_key_file_new();\n\tg_key_file_load_from_file(key_file, filename, 0, NULL);\n\n\tfor (i = 0; i < 16; i++)\n\t\tsprintf(str + (i * 2), \"%2.2X\", key[i]);\n\n\tg_key_file_set_string(key_file, \"IdentityResolvingKey\", \"Key\", str);\n\n\tcreate_file(filename, 0600);\n\n\tstore_data = g_key_file_to_data(key_file, &length, NULL);\n\tg_file_set_contents(filename, store_data, length, NULL);\n\tg_free(store_data);\n\n\tg_key_file_free(key_file);\n}\n\nstatic void new_irk_callback(uint16_t index, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_ev_new_irk *ev = param;\n\tconst struct mgmt_addr_info *addr = &ev->key.addr;\n\tconst struct mgmt_irk_info *irk = &ev->key;\n\tstruct btd_adapter *adapter = user_data;\n\tstruct btd_device *device, *duplicate;\n\tbool persistent;\n\tchar dst[18], rpa[18];\n\n\tif (length < sizeof(*ev)) {\n\t\tbtd_error(adapter->dev_id, \"Too small New IRK event\");\n\t\treturn;\n\t}\n\n\tba2str(&addr->bdaddr, dst);\n\tba2str(&ev->rpa, rpa);\n\n\tDBG(\"hci%u new IRK for %s RPA %s\", adapter->dev_id, dst, rpa);\n\n\tif (bacmp(&ev->rpa, BDADDR_ANY)) {\n\t\tdevice = btd_adapter_get_device(adapter, &ev->rpa,\n\t\t\t\t\t\t\tBDADDR_LE_RANDOM);\n\t\tduplicate = btd_adapter_find_device(adapter, &addr->bdaddr,\n\t\t\t\t\t\t\t\taddr->type);\n\t\tif (duplicate == device)\n\t\t\tduplicate = NULL;\n\t} else {\n\t\tdevice = btd_adapter_get_device(adapter, &addr->bdaddr,\n\t\t\t\t\t\t\t\taddr->type);\n\t\tduplicate = NULL;\n\t}\n\n\tif (!device) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Unable to get device object for %s\", dst);\n\t\treturn;\n\t}\n\n\tdevice_update_addr(device, &addr->bdaddr, addr->type);\n\n\tif (duplicate)\n\t\tdevice_merge_duplicate(device, duplicate);\n\n\tpersistent = !!ev->store_hint;\n\tif (!persistent)\n\t\treturn;\n\n\tstore_irk(adapter, &addr->bdaddr, addr->type, irk->val);\n\n\tbtd_device_set_temporary(device, false);\n}\n\nstatic void store_conn_param(struct btd_adapter *adapter, const bdaddr_t *peer,\n\t\t\t\tuint8_t bdaddr_type, uint16_t min_interval,\n\t\t\t\tuint16_t max_interval, uint16_t latency,\n\t\t\t\tuint16_t timeout)\n{\n\tchar device_addr[18];\n\tchar filename[PATH_MAX];\n\tGKeyFile *key_file;\n\tchar *store_data;\n\tsize_t length = 0;\n\n\tba2str(peer, device_addr);\n\n\tDBG(\"\");\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/%s/info\",\n\t\t\tbtd_adapter_get_storage_dir(adapter), device_addr);\n\tkey_file = g_key_file_new();\n\tg_key_file_load_from_file(key_file, filename, 0, NULL);\n\n\tg_key_file_set_integer(key_file, \"ConnectionParameters\",\n\t\t\t\t\t\t\"MinInterval\", min_interval);\n\tg_key_file_set_integer(key_file, \"ConnectionParameters\",\n\t\t\t\t\t\t\"MaxInterval\", max_interval);\n\tg_key_file_set_integer(key_file, \"ConnectionParameters\",\n\t\t\t\t\t\t\"Latency\", latency);\n\tg_key_file_set_integer(key_file, \"ConnectionParameters\",\n\t\t\t\t\t\t\"Timeout\", timeout);\n\n\tcreate_file(filename, 0600);\n\n\tstore_data = g_key_file_to_data(key_file, &length, NULL);\n\tg_file_set_contents(filename, store_data, length, NULL);\n\tg_free(store_data);\n\n\tg_key_file_free(key_file);\n}\n\nstatic void new_conn_param(uint16_t index, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_ev_new_conn_param *ev = param;\n\tstruct btd_adapter *adapter = user_data;\n\tuint16_t min, max, latency, timeout;\n\tstruct btd_device *dev;\n\tchar dst[18];\n\n\n\tif (length < sizeof(*ev)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Too small New Connection Parameter event\");\n\t\treturn;\n\t}\n\n\tba2str(&ev->addr.bdaddr, dst);\n\n\tmin = btohs(ev->min_interval);\n\tmax = btohs(ev->max_interval);\n\tlatency = btohs(ev->latency);\n\ttimeout = btohs(ev->timeout);\n\n\tDBG(\"hci%u %s (%u) min 0x%04x max 0x%04x latency 0x%04x timeout 0x%04x\",\n\t\tadapter->dev_id, dst, ev->addr.type, min, max, latency, timeout);\n\n\tdev = btd_adapter_get_device(adapter, &ev->addr.bdaddr, ev->addr.type);\n\tif (!dev) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Unable to get device object for %s\", dst);\n\t\treturn;\n\t}\n\n\tif (!ev->store_hint)\n\t\treturn;\n\n\tstore_conn_param(adapter, &ev->addr.bdaddr, ev->addr.type,\n\t\t\t\t\tev->min_interval, ev->max_interval,\n\t\t\t\t\tev->latency, ev->timeout);\n}\n\nint adapter_set_io_capability(struct btd_adapter *adapter, uint8_t io_cap)\n{\n\tstruct mgmt_cp_set_io_capability cp;\n\n\tif (!btd_opts.pairable) {\n\t\tif (io_cap == IO_CAPABILITY_INVALID) {\n\t\t\tif (adapter->current_settings & MGMT_SETTING_BONDABLE)\n\t\t\t\tset_mode(adapter, MGMT_OP_SET_BONDABLE, 0x00);\n\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!(adapter->current_settings & MGMT_SETTING_BONDABLE))\n\t\t\tset_mode(adapter, MGMT_OP_SET_BONDABLE, 0x01);\n\t} else if (io_cap == IO_CAPABILITY_INVALID)\n\t\tio_cap = IO_CAPABILITY_NOINPUTNOOUTPUT;\n\n\tmemset(&cp, 0, sizeof(cp));\n\tcp.io_capability = io_cap;\n\n\tif (mgmt_send(adapter->mgmt, MGMT_OP_SET_IO_CAPABILITY,\n\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\tNULL, NULL, NULL) > 0)\n\t\treturn 0;\n\n\treturn -EIO;\n}\n\nint btd_adapter_add_remote_oob_data(struct btd_adapter *adapter,\n\t\t\t\t\tconst bdaddr_t *bdaddr,\n\t\t\t\t\tuint8_t *hash, uint8_t *randomizer)\n{\n\tstruct mgmt_cp_add_remote_oob_data cp;\n\tchar addr[18];\n\n\tba2str(bdaddr, addr);\n\tDBG(\"hci%d bdaddr %s\", adapter->dev_id, addr);\n\n\tmemset(&cp, 0, sizeof(cp));\n\tbacpy(&cp.addr.bdaddr, bdaddr);\n\tmemcpy(cp.hash192, hash, 16);\n\n\tif (randomizer)\n\t\tmemcpy(cp.rand192, randomizer, 16);\n\n\tif (mgmt_send(adapter->mgmt, MGMT_OP_ADD_REMOTE_OOB_DATA,\n\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\tNULL, NULL, NULL) > 0)\n\t\treturn 0;\n\n\treturn -EIO;\n}\n\nint btd_adapter_remove_remote_oob_data(struct btd_adapter *adapter,\n\t\t\t\t\t\t\tconst bdaddr_t *bdaddr)\n{\n\tstruct mgmt_cp_remove_remote_oob_data cp;\n\tchar addr[18];\n\n\tba2str(bdaddr, addr);\n\tDBG(\"hci%d bdaddr %s\", adapter->dev_id, addr);\n\n\tmemset(&cp, 0, sizeof(cp));\n\tbacpy(&cp.addr.bdaddr, bdaddr);\n\n\tif (mgmt_send(adapter->mgmt, MGMT_OP_REMOVE_REMOTE_OOB_DATA,\n\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\tNULL, NULL, NULL) > 0)\n\t\treturn 0;\n\n\treturn -EIO;\n}\n\nbool btd_adapter_ssp_enabled(struct btd_adapter *adapter)\n{\n\tif (adapter->current_settings & MGMT_SETTING_SSP)\n\t\treturn true;\n\n\treturn false;\n}\n\nvoid btd_adapter_set_oob_handler(struct btd_adapter *adapter,\n\t\t\t\t\t\tstruct oob_handler *handler)\n{\n\tadapter->oob_handler = handler;\n}\n\ngboolean btd_adapter_check_oob_handler(struct btd_adapter *adapter)\n{\n\treturn adapter->oob_handler != NULL;\n}\n\nstatic void read_local_oob_data_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_rp_read_local_oob_data *rp = param;\n\tstruct btd_adapter *adapter = user_data;\n\tconst uint8_t *hash, *randomizer;\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Read local OOB data failed: %s (0x%02x)\",\n\t\t\t\t\t\tmgmt_errstr(status), status);\n\t\thash = NULL;\n\t\trandomizer = NULL;\n\t} else if (length < sizeof(*rp)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Too small read local OOB data response\");\n\t\treturn;\n\t} else {\n\t\thash = rp->hash192;\n\t\trandomizer = rp->rand192;\n\t}\n\n\tif (!adapter->oob_handler || !adapter->oob_handler->read_local_cb)\n\t\treturn;\n\n\tadapter->oob_handler->read_local_cb(adapter, hash, randomizer,\n\t\t\t\t\tadapter->oob_handler->user_data);\n\n\tg_free(adapter->oob_handler);\n\tadapter->oob_handler = NULL;\n}\n\nint btd_adapter_read_local_oob_data(struct btd_adapter *adapter)\n{\n\tDBG(\"hci%u\", adapter->dev_id);\n\n\tif (mgmt_send(adapter->mgmt, MGMT_OP_READ_LOCAL_OOB_DATA,\n\t\t\tadapter->dev_id, 0, NULL, read_local_oob_data_complete,\n\t\t\tadapter, NULL) > 0)\n\t\treturn 0;\n\n\treturn -EIO;\n}\n\nvoid btd_adapter_for_each_device(struct btd_adapter *adapter,\n\t\t\tvoid (*cb)(struct btd_device *device, void *data),\n\t\t\tvoid *data)\n{\n\tg_slist_foreach(adapter->devices, (GFunc) cb, data);\n}\n\nstatic int adapter_cmp(gconstpointer a, gconstpointer b)\n{\n\tstruct btd_adapter *adapter = (struct btd_adapter *) a;\n\tconst bdaddr_t *bdaddr = b;\n\n\treturn bacmp(&adapter->bdaddr, bdaddr);\n}\n\nstatic int adapter_id_cmp(gconstpointer a, gconstpointer b)\n{\n\tstruct btd_adapter *adapter = (struct btd_adapter *) a;\n\tuint16_t id = GPOINTER_TO_UINT(b);\n\n\treturn adapter->dev_id == id ? 0 : -1;\n}\n\nstruct btd_adapter *adapter_find(const bdaddr_t *sba)\n{\n\tGSList *match;\n\n\tmatch = g_slist_find_custom(adapters, sba, adapter_cmp);\n\tif (!match)\n\t\treturn NULL;\n\n\treturn match->data;\n}\n\nstruct btd_adapter *adapter_find_by_id(int id)\n{\n\tGSList *match;\n\n\tmatch = g_slist_find_custom(adapters, GINT_TO_POINTER(id),\n\t\t\t\t\t\t\tadapter_id_cmp);\n\tif (!match)\n\t\treturn NULL;\n\n\treturn match->data;\n}\n\nvoid adapter_foreach(adapter_cb func, gpointer user_data)\n{\n\tg_slist_foreach(adapters, (GFunc) func, user_data);\n}\n\nstatic int set_did(struct btd_adapter *adapter, uint16_t vendor,\n\t\t\tuint16_t product, uint16_t version, uint16_t source)\n{\n\tstruct mgmt_cp_set_device_id cp;\n\n\tDBG(\"hci%u source %x vendor %x product %x version %x\",\n\t\t\tadapter->dev_id, source, vendor, product, version);\n\n\tmemset(&cp, 0, sizeof(cp));\n\n\tcp.source = htobs(source);\n\tcp.vendor = htobs(vendor);\n\tcp.product = htobs(product);\n\tcp.version = htobs(version);\n\n\tif (mgmt_send(adapter->mgmt, MGMT_OP_SET_DEVICE_ID,\n\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\tNULL, NULL, NULL) > 0)\n\t\treturn 0;\n\n\treturn -EIO;\n}\n\nstatic void services_modified(struct gatt_db_attribute *attrib, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\t\tADAPTER_INTERFACE, \"UUIDs\");\n}\n\nstatic int adapter_register(struct btd_adapter *adapter)\n{\n\tstruct agent *agent;\n\tstruct gatt_db *db;\n\n\tif (powering_down)\n\t\treturn -EBUSY;\n\n\tadapter->path = g_strdup_printf(\"/org/bluez/hci%d\", adapter->dev_id);\n\n\tif (!g_dbus_register_interface(dbus_conn,\n\t\t\t\t\tadapter->path, ADAPTER_INTERFACE,\n\t\t\t\t\tadapter_methods, NULL,\n\t\t\t\t\tadapter_properties, adapter,\n\t\t\t\t\tadapter_free)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Adapter interface init failed on path %s\",\n\t\t\t\t\t\t\tadapter->path);\n\t\tg_free(adapter->path);\n\t\tadapter->path = NULL;\n\t\treturn -EINVAL;\n\t}\n\n\tif (adapters == NULL)\n\t\tadapter->is_default = true;\n\n\tadapters = g_slist_append(adapters, adapter);\n\n\tagent = agent_get(NULL);\n\tif (agent) {\n\t\tuint8_t io_cap = agent_get_io_capability(agent);\n\t\tadapter_set_io_capability(adapter, io_cap);\n\t\tagent_unref(agent);\n\t}\n\n\t/* Don't start GATT database and advertising managers on\n\t * non-LE controllers.\n\t */\n\tif (!(adapter->supported_settings & MGMT_SETTING_LE) ||\n\t\t\t\t\tbtd_opts.mode == BT_MODE_BREDR)\n\t\tgoto load;\n\n\tadapter->database = btd_gatt_database_new(adapter);\n\tif (!adapter->database) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Failed to create GATT database for adapter\");\n\t\tadapters = g_slist_remove(adapters, adapter);\n\t\treturn -EINVAL;\n\t}\n\n\tadapter->adv_manager = btd_adv_manager_new(adapter, adapter->mgmt);\n\n\tif (g_dbus_get_flags() & G_DBUS_FLAG_ENABLE_EXPERIMENTAL) {\n\t\tif (adapter->supported_settings & MGMT_SETTING_LE) {\n\t\t\tadapter->adv_monitor_manager =\n\t\t\t\tbtd_adv_monitor_manager_create(adapter,\n\t\t\t\t\t\t\t\tadapter->mgmt);\n\t\t\tif (!adapter->adv_monitor_manager) {\n\t\t\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\t\t\"Failed to create Adv Monitor \"\n\t\t\t\t\t\t\"Manager for adapter\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tbtd_info(adapter->dev_id, \"Adv Monitor Manager \"\n\t\t\t\t\t\"skipped, LE unavailable\");\n\t\t}\n\t}\n\n\tif (g_dbus_get_flags() & G_DBUS_FLAG_ENABLE_EXPERIMENTAL) {\n\t\tadapter->battery_provider_manager =\n\t\t\tbtd_battery_provider_manager_create(adapter);\n\t}\n\n\tdb = btd_gatt_database_get_db(adapter->database);\n\tadapter->db_id = gatt_db_register(db, services_modified,\n\t\t\t\t\t\t\tservices_modified,\n\t\t\t\t\t\t\tadapter, NULL);\n\nload:\n\tmgmt_register(adapter->mgmt, MGMT_EV_DEVICE_FLAGS_CHANGED,\n\t\t\t\t\t\tadapter->dev_id,\n\t\t\t\t\t\tdevice_flags_changed_callback,\n\t\t\t\t\t\tadapter, NULL);\n\n\tload_config(adapter);\n\tfix_storage(adapter);\n\tload_drivers(adapter);\n\tbtd_profile_foreach(probe_profile, adapter);\n\tclear_blocked(adapter);\n\tload_defaults(adapter);\n\tload_devices(adapter);\n\n\t/* restore Service Changed CCC value for bonded devices */\n\tbtd_gatt_database_restore_svc_chng_ccc(adapter->database);\n\n\t/* retrieve the active connections: address the scenario where\n\t * the are active connections before the daemon've started */\n\tif (btd_adapter_get_powered(adapter))\n\t\tload_connections(adapter);\n\n\tadapter->initialized = TRUE;\n\n\tif (btd_opts.did_source) {\n\t\t/* DeviceID record is added by sdpd-server before any other\n\t\t * record is registered. */\n\t\tadapter_service_insert(adapter, sdp_record_find(0x10000));\n\t\tset_did(adapter, btd_opts.did_vendor, btd_opts.did_product,\n\t\t\t\tbtd_opts.did_version, btd_opts.did_source);\n\t}\n\n\tDBG(\"Adapter %s registered\", adapter->path);\n\n\treturn 0;\n}\n\nstatic int adapter_unregister(struct btd_adapter *adapter)\n{\n\tDBG(\"Unregister path: %s\", adapter->path);\n\n\tadapters = g_slist_remove(adapters, adapter);\n\n\tif (adapter->is_default && adapters != NULL) {\n\t\tstruct btd_adapter *new_default;\n\n\t\tnew_default = adapter_find_by_id(hci_get_route(NULL));\n\t\tif (new_default == NULL)\n\t\t\tnew_default = adapters->data;\n\n\t\tnew_default->is_default = true;\n\t}\n\n\tadapter_list = g_list_remove(adapter_list, adapter);\n\n\tadapter_remove(adapter);\n\tbtd_adapter_unref(adapter);\n\n\treturn 0;\n}\n\nstatic void disconnected_callback(uint16_t index, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_ev_device_disconnected *ev = param;\n\tstruct btd_adapter *adapter = user_data;\n\tuint8_t reason;\n\n\tif (length < sizeof(struct mgmt_addr_info)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Too small device disconnected event\");\n\t\treturn;\n\t}\n\n\tif (length < sizeof(*ev))\n\t\treason = MGMT_DEV_DISCONN_UNKNOWN;\n\telse\n\t\treason = ev->reason;\n\n\tdev_disconnected(adapter, &ev->addr, reason);\n}\n\nstatic void connected_callback(uint16_t index, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_ev_device_connected *ev = param;\n\tstruct btd_adapter *adapter = user_data;\n\tstruct btd_device *device;\n\tstruct eir_data eir_data;\n\tuint16_t eir_len;\n\tchar addr[18];\n\tbool name_known;\n\n\tif (length < sizeof(*ev)) {\n\t\tbtd_error(adapter->dev_id, \"Too small device connected event\");\n\t\treturn;\n\t}\n\n\teir_len = btohs(ev->eir_len);\n\tif (length < sizeof(*ev) + eir_len) {\n\t\tbtd_error(adapter->dev_id, \"Too small device connected event\");\n\t\treturn;\n\t}\n\n\tba2str(&ev->addr.bdaddr, addr);\n\n\tDBG(\"hci%u device %s connected eir_len %u\", index, addr, eir_len);\n\n\tdevice = btd_adapter_get_device(adapter, &ev->addr.bdaddr,\n\t\t\t\t\t\t\t\tev->addr.type);\n\tif (!device) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Unable to get device object for %s\", addr);\n\t\treturn;\n\t}\n\n\tmemset(&eir_data, 0, sizeof(eir_data));\n\tif (eir_len > 0)\n\t\teir_parse(&eir_data, ev->eir, eir_len);\n\n\tif (eir_data.class != 0)\n\t\tdevice_set_class(device, eir_data.class);\n\n\tadapter_add_connection(adapter, device, ev->addr.type);\n\n\tname_known = device_name_known(device);\n\n\tif (eir_data.name && (eir_data.name_complete || !name_known)) {\n\t\tdevice_store_cached_name(device, eir_data.name);\n\t\tbtd_device_device_set_name(device, eir_data.name);\n\t}\n\n\tif (eir_data.msd_list)\n\t\tadapter_msd_notify(adapter, device, eir_data.msd_list);\n\n\teir_data_free(&eir_data);\n}\n\nstatic void controller_resume_notify(struct btd_adapter *adapter)\n{\n\tGSList *l;\n\n\tfor (l = adapter->drivers; l; l = g_slist_next(l)) {\n\t\tstruct btd_adapter_driver *driver = l->data;\n\t\tif (driver->resume)\n\t\t\tdriver->resume(adapter);\n\t}\n}\n\nstatic void controller_resume_callback(uint16_t index, uint16_t length,\n\t\t\t\t       const void *param, void *user_data)\n{\n\tconst struct mgmt_ev_controller_resume *ev = param;\n\tstruct btd_adapter *adapter = user_data;\n\n\tif (length < sizeof(*ev)) {\n\t\tbtd_error(adapter->dev_id, \"Too small device resume event\");\n\t\treturn;\n\t}\n\n\tinfo(\"Controller resume with wake event 0x%x\", ev->wake_reason);\n\n\tcontroller_resume_notify(adapter);\n}\n\nstatic void device_blocked_callback(uint16_t index, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_ev_device_blocked *ev = param;\n\tstruct btd_adapter *adapter = user_data;\n\tstruct btd_device *device;\n\tchar addr[18];\n\n\tif (length < sizeof(*ev)) {\n\t\tbtd_error(adapter->dev_id, \"Too small device blocked event\");\n\t\treturn;\n\t}\n\n\tba2str(&ev->addr.bdaddr, addr);\n\tDBG(\"hci%u %s blocked\", index, addr);\n\n\tdevice = btd_adapter_find_device(adapter, &ev->addr.bdaddr,\n\t\t\t\t\t\t\t\tev->addr.type);\n\tif (device)\n\t\tdevice_block(device, TRUE);\n}\n\nstatic void device_unblocked_callback(uint16_t index, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_ev_device_unblocked *ev = param;\n\tstruct btd_adapter *adapter = user_data;\n\tstruct btd_device *device;\n\tchar addr[18];\n\n\tif (length < sizeof(*ev)) {\n\t\tbtd_error(adapter->dev_id, \"Too small device unblocked event\");\n\t\treturn;\n\t}\n\n\tba2str(&ev->addr.bdaddr, addr);\n\tDBG(\"hci%u %s unblocked\", index, addr);\n\n\tdevice = btd_adapter_find_device(adapter, &ev->addr.bdaddr,\n\t\t\t\t\t\t\t\tev->addr.type);\n\tif (device)\n\t\tdevice_unblock(device, FALSE, TRUE);\n}\n\nstatic void conn_fail_notify(struct btd_device *dev, uint8_t status)\n{\n\tGSList *l;\n\n\tfor (l = conn_fail_list; l; l = g_slist_next(l)) {\n\t\tbtd_conn_fail_cb conn_fail_cb = l->data;\n\t\tconn_fail_cb(dev, status);\n\t}\n}\n\nvoid btd_add_conn_fail_cb(btd_conn_fail_cb func)\n{\n\tconn_fail_list = g_slist_append(conn_fail_list, func);\n}\n\nvoid btd_remove_conn_fail_cb(btd_conn_fail_cb func)\n{\n\tconn_fail_list = g_slist_remove(conn_fail_list, func);\n}\n\nstatic void connect_failed_callback(uint16_t index, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_ev_connect_failed *ev = param;\n\tstruct btd_adapter *adapter = user_data;\n\tstruct btd_device *device;\n\tchar addr[18];\n\n\tif (length < sizeof(*ev)) {\n\t\tbtd_error(adapter->dev_id, \"Too small connect failed event\");\n\t\treturn;\n\t}\n\n\tba2str(&ev->addr.bdaddr, addr);\n\n\tDBG(\"hci%u %s status %u\", index, addr, ev->status);\n\n\tdevice = btd_adapter_find_device(adapter, &ev->addr.bdaddr,\n\t\t\t\t\t\t\t\tev->addr.type);\n\tif (device) {\n\t\tconn_fail_notify(device, ev->status);\n\n\t\t/* If the device is in a bonding process cancel any auth request\n\t\t * sent to the agent before proceeding, but keep the bonding\n\t\t * request structure. */\n\t\tif (device_is_bonding(device, NULL))\n\t\t\tdevice_cancel_authentication(device, FALSE);\n\t}\n\n\t/* In the case of security mode 3 devices */\n\tbonding_attempt_complete(adapter, &ev->addr.bdaddr, ev->addr.type,\n\t\t\t\t\t\t\t\tev->status);\n\n\t/* If the device is scheduled to retry the bonding wait until the retry\n\t * happens. In other case, proceed with cancel the bondig.\n\t */\n\tif (device && device_is_bonding(device, NULL)\n\t\t\t\t\t&& !device_is_retrying(device)) {\n\t\tdevice_cancel_authentication(device, TRUE);\n\t\tdevice_bonding_failed(device, ev->status);\n\t}\n\n\t/* In the case the bonding was canceled or did exists, remove the device\n\t * when it is temporary. */\n\tif (device && !device_is_bonding(device, NULL)\n\t\t\t\t\t\t&& device_is_temporary(device))\n\t\tbtd_adapter_remove_device(adapter, device);\n}\n\nstatic void remove_keys(struct btd_adapter *adapter,\n\t\t\t\t\tstruct btd_device *device, uint8_t type)\n{\n\tchar device_addr[18];\n\tchar filename[PATH_MAX];\n\tGKeyFile *key_file;\n\tgsize length = 0;\n\tchar *str;\n\n\tba2str(device_get_address(device), device_addr);\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/%s/info\",\n\t\t\tbtd_adapter_get_storage_dir(adapter), device_addr);\n\tkey_file = g_key_file_new();\n\tg_key_file_load_from_file(key_file, filename, 0, NULL);\n\n\tif (type == BDADDR_BREDR) {\n\t\tg_key_file_remove_group(key_file, \"LinkKey\", NULL);\n\t} else {\n\t\tg_key_file_remove_group(key_file, \"LongTermKey\", NULL);\n\t\tg_key_file_remove_group(key_file, \"LocalSignatureKey\", NULL);\n\t\tg_key_file_remove_group(key_file, \"RemoteSignatureKey\", NULL);\n\t\tg_key_file_remove_group(key_file, \"IdentityResolvingKey\", NULL);\n\t}\n\n\tstr = g_key_file_to_data(key_file, &length, NULL);\n\tg_file_set_contents(filename, str, length, NULL);\n\tg_free(str);\n\n\tg_key_file_free(key_file);\n}\n\nstatic void unpaired_callback(uint16_t index, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_ev_device_unpaired *ev = param;\n\tstruct btd_adapter *adapter = user_data;\n\tstruct btd_device *device;\n\tchar addr[18];\n\n\tif (length < sizeof(*ev)) {\n\t\tbtd_error(adapter->dev_id, \"Too small device unpaired event\");\n\t\treturn;\n\t}\n\n\tba2str(&ev->addr.bdaddr, addr);\n\n\tDBG(\"hci%u addr %s\", index, addr);\n\n\tdevice = btd_adapter_find_device(adapter, &ev->addr.bdaddr,\n\t\t\t\t\t\t\t\tev->addr.type);\n\tif (!device) {\n\t\tbtd_warn(adapter->dev_id,\n\t\t\t\"No device object for unpaired device %s\", addr);\n\t\treturn;\n\t}\n\n\tremove_keys(adapter, device, ev->addr.type);\n\tdevice_set_unpaired(device, ev->addr.type);\n}\n\nstatic void clear_devices_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\terror(\"Failed to clear devices: %s (0x%02x)\",\n\t\t\t\t\t\tmgmt_errstr(status), status);\n\t\treturn;\n\t}\n}\n\nstatic int clear_devices(struct btd_adapter *adapter)\n{\n\tstruct mgmt_cp_remove_device cp;\n\n\tif (!btd_has_kernel_features(KERNEL_CONN_CONTROL))\n\t\treturn 0;\n\n\tmemset(&cp, 0, sizeof(cp));\n\n\tDBG(\"sending clear devices command for index %u\", adapter->dev_id);\n\n\tif (mgmt_send(adapter->mgmt, MGMT_OP_REMOVE_DEVICE,\n\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\tclear_devices_complete, adapter, NULL) > 0)\n\t\treturn 0;\n\n\tbtd_error(adapter->dev_id, \"Failed to clear devices for index %u\",\n\t\t\t\t\t\t\tadapter->dev_id);\n\n\treturn -EIO;\n}\n\nstatic bool get_static_addr(struct btd_adapter *adapter)\n{\n\tstruct bt_crypto *crypto;\n\tGKeyFile *file;\n\tchar **addrs;\n\tchar mfg[7];\n\tchar *str;\n\tbool ret;\n\tgsize len, i;\n\n\tsnprintf(mfg, sizeof(mfg), \"0x%04x\", adapter->manufacturer);\n\n\tfile = g_key_file_new();\n\tg_key_file_load_from_file(file, STORAGEDIR \"/addresses\", 0, NULL);\n\taddrs = g_key_file_get_string_list(file, \"Static\", mfg, &len, NULL);\n\tif (addrs) {\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tbdaddr_t addr;\n\n\t\t\tstr2ba(addrs[i], &addr);\n\t\t\tif (adapter_find(&addr))\n\t\t\t\tcontinue;\n\n\t\t\t/* Usable address found in list */\n\t\t\tbacpy(&adapter->bdaddr, &addr);\n\t\t\tadapter->bdaddr_type = BDADDR_LE_RANDOM;\n\t\t\tret = true;\n\t\t\tgoto done;\n\t\t}\n\n\t\tlen++;\n\t\taddrs = g_renew(char *, addrs, len + 1);\n\t} else {\n\t\tlen = 1;\n\t\taddrs = g_new(char *, len + 1);\n\t}\n\n\t/* Initialize slot for new address */\n\taddrs[len - 1] = g_malloc(18);\n\taddrs[len] = NULL;\n\n\tcrypto = bt_crypto_new();\n\tif (!crypto) {\n\t\terror(\"Failed to open crypto\");\n\t\tret = false;\n\t\tgoto done;\n\t}\n\n\tret = bt_crypto_random_bytes(crypto, &adapter->bdaddr,\n\t\t\t\t\t\tsizeof(adapter->bdaddr));\n\tif (!ret) {\n\t\terror(\"Failed to generate static address\");\n\t\tbt_crypto_unref(crypto);\n\t\tgoto done;\n\t}\n\n\tbt_crypto_unref(crypto);\n\n\tadapter->bdaddr.b[5] |= 0xc0;\n\tadapter->bdaddr_type = BDADDR_LE_RANDOM;\n\n\tba2str(&adapter->bdaddr, addrs[len - 1]);\n\n\tg_key_file_set_string_list(file, \"Static\", mfg,\n\t\t\t\t\t\t(const char **)addrs, len);\n\n\tstr = g_key_file_to_data(file, &len, NULL);\n\tg_file_set_contents(STORAGEDIR \"/addresses\", str, len, NULL);\n\tg_free(str);\n\n\tret = true;\n\ndone:\n\tg_key_file_free(file);\n\tg_strfreev(addrs);\n\n\treturn ret;\n}\n\nstatic bool set_static_addr(struct btd_adapter *adapter)\n{\n\tstruct mgmt_cp_set_static_address cp;\n\n\t/* dual-mode adapters must have a public address */\n\tif (adapter->supported_settings & MGMT_SETTING_BREDR)\n\t\treturn false;\n\n\tif (!(adapter->supported_settings & MGMT_SETTING_LE))\n\t\treturn false;\n\n\tDBG(\"Setting static address\");\n\n\tif (!get_static_addr(adapter))\n\t\treturn false;\n\n\tbacpy(&cp.bdaddr, &adapter->bdaddr);\n\tif (mgmt_send(adapter->mgmt, MGMT_OP_SET_STATIC_ADDRESS,\n\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\tNULL, NULL, NULL) > 0) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void set_blocked_keys_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Failed to set blocked keys: %s (0x%02x)\",\n\t\t\t\tmgmt_errstr(status), status);\n\t\treturn;\n\t}\n\n\tDBG(\"Successfully set blocked keys for index %u\", adapter->dev_id);\n}\n\nstatic bool set_blocked_keys(struct btd_adapter *adapter)\n{\n\tuint8_t buffer[sizeof(struct mgmt_cp_set_blocked_keys) +\n\t\t\t\t\tsizeof(blocked_keys)] = { 0 };\n\tstruct mgmt_cp_set_blocked_keys *cp =\n\t\t\t\t(struct mgmt_cp_set_blocked_keys *)buffer;\n\tint i;\n\n\tcp->key_count = ARRAY_SIZE(blocked_keys);\n\tfor (i = 0; i < cp->key_count; ++i) {\n\t\tcp->keys[i].type = blocked_keys[i].type;\n\t\tmemcpy(cp->keys[i].val, blocked_keys[i].val,\n\t\t\t\t\t\tsizeof(cp->keys[i].val));\n\t}\n\n\treturn mgmt_send(mgmt_master, MGMT_OP_SET_BLOCKED_KEYS, adapter->dev_id,\n\t\t\t\t\t\tsizeof(buffer),\tbuffer,\n\t\t\t\t\t\tset_blocked_keys_complete,\n\t\t\t\t\t\tadapter, NULL);\n}\n\n#define EXP_FEAT(_uuid, _func) \\\n{ \\\n\t.uuid = _uuid, \\\n\t.func = _func, \\\n}\n\n/* d4992530-b9ec-469f-ab01-6c481c47da1c */\nstatic const uint8_t debug_uuid[16] = {\n\t0x1c, 0xda, 0x47, 0x1c, 0x48, 0x6c, 0x01, 0xab,\n\t0x9f, 0x46, 0xec, 0xb9, 0x30, 0x25, 0x99, 0xd4,\n};\n\n/* 671b10b5-42c0-4696-9227-eb28d1b049d6 */\nstatic const uint8_t le_simult_central_peripheral_uuid[16] = {\n\t0xd6, 0x49, 0xb0, 0xd1, 0x28, 0xeb, 0x27, 0x92,\n\t0x96, 0x46, 0xc0, 0x42, 0xb5, 0x10, 0x1b, 0x67,\n};\n\n/* 330859bc-7506-492d-9370-9a6f0614037f */\nstatic const uint8_t quality_report_uuid[16] = {\n\t0x7f, 0x03, 0x14, 0x06, 0x6f, 0x9a, 0x70, 0x93,\n\t0x2d, 0x49, 0x06, 0x75, 0xbc, 0x59, 0x08, 0x33,\n};\n\n/* 15c0a148-c273-11ea-b3de-0242ac130004 */\nstatic const uint8_t rpa_resolution_uuid[16] = {\n\t0x04, 0x00, 0x13, 0xac, 0x42, 0x02, 0xde, 0xb3,\n\t0xea, 0x11, 0x73, 0xc2, 0x48, 0xa1, 0xc0, 0x15,\n};\n\nstatic void set_exp_debug_complete(uint8_t status, uint16_t len,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tif (status != 0)\n\t\terror(\"Set Experimental Debug failed with status 0x%02x (%s)\",\n\t\t\t\t\t\tstatus, mgmt_errstr(status));\n\telse\n\t\tDBG(\"Experimental Debug successfully set\");\n}\n\nstatic void exp_debug_func(struct btd_adapter *adapter, uint32_t flags)\n{\n\tstruct mgmt_cp_set_exp_feature cp;\n\tuint8_t action = btd_opts.experimental ? 0x01 : 0x00;\n\n\t/* If already set don't attempt to set it again */\n\tif (action == (flags & BIT(0)))\n\t\treturn;\n\n\tmemset(&cp, 0, sizeof(cp));\n\tmemcpy(cp.uuid, debug_uuid, 16);\n\tcp.action = btd_opts.experimental ? 0x01 : 0x00;\n\n\tif (mgmt_send(adapter->mgmt, MGMT_OP_SET_EXP_FEATURE,\n\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\tset_exp_debug_complete, adapter, NULL) > 0)\n\t\treturn;\n\n\tbtd_error(adapter->dev_id, \"Failed to set exp debug\");\n}\n\nstatic void le_simult_central_peripheral_func(struct btd_adapter *adapter,\n\t\t\t\t\t\t\tuint32_t flags)\n{\n\tadapter->le_simult_roles_supported = flags & 0x01;\n}\n\nstatic void quality_report_func(struct btd_adapter *adapter, uint32_t flags)\n{\n\tadapter->quality_report_supported = le32_to_cpu(flags) & 0x01;\n\n\tbtd_info(adapter->dev_id, \"quality_report_supported %d\",\n\t\t\tadapter->quality_report_supported);\n}\n\nstatic void set_rpa_resolution_complete(uint8_t status, uint16_t len,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tif (status != 0)\n\t\terror(\"Set RPA Resolution failed with status 0x%02x (%s)\",\n\t\t\t\t\t\tstatus, mgmt_errstr(status));\n\telse\n\t\tDBG(\"RPA Resolution successfully set\");\n}\n\nstatic void rpa_resolution_func(struct btd_adapter *adapter, uint32_t flags)\n{\n\tstruct mgmt_cp_set_exp_feature cp;\n\tuint8_t action = btd_opts.experimental ? 0x01 : 0x00;\n\n\t/* If already set don't attempt to set it again */\n\tif (action == (flags & BIT(0)))\n\t\treturn;\n\n\tmemset(&cp, 0, sizeof(cp));\n\tmemcpy(cp.uuid, rpa_resolution_uuid, 16);\n\tcp.action = action;\n\n\tif (mgmt_send(adapter->mgmt, MGMT_OP_SET_EXP_FEATURE,\n\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\tset_rpa_resolution_complete, adapter, NULL) > 0)\n\t\treturn;\n\n\tbtd_error(adapter->dev_id, \"Failed to set RPA Resolution\");\n}\n\nstatic const struct exp_feat {\n\tconst uint8_t *uuid;\n\tvoid (*func)(struct btd_adapter *adapter, uint32_t flags);\n} exp_table[] = {\n\tEXP_FEAT(debug_uuid, exp_debug_func),\n\tEXP_FEAT(le_simult_central_peripheral_uuid,\n\t\t le_simult_central_peripheral_func),\n\tEXP_FEAT(quality_report_uuid, quality_report_func),\n\tEXP_FEAT(rpa_resolution_uuid, rpa_resolution_func),\n};\n\nstatic void read_exp_features_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tconst struct mgmt_rp_read_exp_features_info *rp = param;\n\tsize_t feature_count = 0;\n\tsize_t i = 0;\n\n\tDBG(\"index %u status 0x%02x\", adapter->dev_id, status);\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Failed to read exp features info: %s (0x%02x)\",\n\t\t\t\tmgmt_errstr(status), status);\n\t\treturn;\n\t}\n\n\tif (length < sizeof(*rp)) {\n\t\tbtd_error(adapter->dev_id, \"Response too small\");\n\t\treturn;\n\t}\n\n\tfeature_count = le16_to_cpu(rp->feature_count);\n\n\tif (length < sizeof(*rp) + (sizeof(*rp->features) * feature_count)) {\n\t\tbtd_error(adapter->dev_id, \"Response too small\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < feature_count; ++i) {\n\t\tsize_t j;\n\n\t\tfor (j = 0; j < ARRAY_SIZE(exp_table); j++) {\n\t\t\tconst struct exp_feat *feat = &exp_table[j];\n\n\t\t\tif (memcmp(rp->features[i].uuid, feat->uuid,\n\t\t\t\t\tsizeof(rp->features[i].uuid)))\n\t\t\t\tcontinue;\n\n\t\t\tif (feat->func)\n\t\t\t\tfeat->func(adapter, rp->features[i].flags);\n\t\t}\n\t}\n}\n\nstatic void read_exp_features(struct btd_adapter *adapter)\n{\n\tif (mgmt_send(adapter->mgmt, MGMT_OP_READ_EXP_FEATURES_INFO,\n\t\t\tadapter->dev_id, 0, NULL, read_exp_features_complete,\n\t\t\tadapter, NULL) > 0)\n\t\treturn;\n\n\tbtd_error(adapter->dev_id, \"Failed to read exp features info\");\n}\n\nstatic void read_info_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tconst struct mgmt_rp_read_info *rp = param;\n\tuint32_t missing_settings;\n\tint err;\n\n\tDBG(\"index %u status 0x%02x\", adapter->dev_id, status);\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Failed to read info for index %u: %s (0x%02x)\",\n\t\t\t\tadapter->dev_id, mgmt_errstr(status), status);\n\t\tgoto failed;\n\t}\n\n\tif (length < sizeof(*rp)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Too small read info complete response\");\n\t\tgoto failed;\n\t}\n\n\t/*\n\t * Store controller information for class of device, device\n\t * name, short name and settings.\n\t *\n\t * During the lifetime of the controller these will be updated by\n\t * events and the information is required to keep the current\n\t * state of the controller.\n\t */\n\tadapter->dev_class = rp->dev_class[0] | (rp->dev_class[1] << 8) |\n\t\t\t\t\t\t(rp->dev_class[2] << 16);\n\tadapter->name = g_strdup((const char *) rp->name);\n\tadapter->short_name = g_strdup((const char *) rp->short_name);\n\n\tadapter->manufacturer = btohs(rp->manufacturer);\n\n\tadapter->supported_settings = btohl(rp->supported_settings);\n\tadapter->current_settings = btohl(rp->current_settings);\n\n\tclear_uuids(adapter);\n\tclear_devices(adapter);\n\n\tif (bacmp(&rp->bdaddr, BDADDR_ANY) == 0) {\n\t\tif (!set_static_addr(adapter)) {\n\t\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\t\"No Bluetooth address for index %u\",\n\t\t\t\t\tadapter->dev_id);\n\t\t\tgoto failed;\n\t\t}\n\t} else {\n\t\tbacpy(&adapter->bdaddr, &rp->bdaddr);\n\t\tif (!(adapter->supported_settings & MGMT_SETTING_LE))\n\t\t\tadapter->bdaddr_type = BDADDR_BREDR;\n\t\telse\n\t\t\tadapter->bdaddr_type = BDADDR_LE_PUBLIC;\n\t}\n\n\tmissing_settings = adapter->current_settings ^\n\t\t\t\t\t\tadapter->supported_settings;\n\n\tswitch (btd_opts.mode) {\n\tcase BT_MODE_DUAL:\n\t\tif (missing_settings & MGMT_SETTING_SSP)\n\t\t\tset_mode(adapter, MGMT_OP_SET_SSP, 0x01);\n\t\tif (missing_settings & MGMT_SETTING_LE)\n\t\t\tset_mode(adapter, MGMT_OP_SET_LE, 0x01);\n\t\tif (missing_settings & MGMT_SETTING_BREDR)\n\t\t\tset_mode(adapter, MGMT_OP_SET_BREDR, 0x01);\n\t\tbreak;\n\tcase BT_MODE_BREDR:\n\t\tif (!(adapter->supported_settings & MGMT_SETTING_BREDR)) {\n\t\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Ignoring adapter withouth BR/EDR support\");\n\t\t\tgoto failed;\n\t\t}\n\n\t\tif (missing_settings & MGMT_SETTING_SSP)\n\t\t\tset_mode(adapter, MGMT_OP_SET_SSP, 0x01);\n\t\tif (missing_settings & MGMT_SETTING_BREDR)\n\t\t\tset_mode(adapter, MGMT_OP_SET_BREDR, 0x01);\n\t\tif (adapter->current_settings & MGMT_SETTING_LE)\n\t\t\tset_mode(adapter, MGMT_OP_SET_LE, 0x00);\n\t\tbreak;\n\tcase BT_MODE_LE:\n\t\tif (!(adapter->supported_settings & MGMT_SETTING_LE)) {\n\t\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Ignoring adapter withouth LE support\");\n\t\t\tgoto failed;\n\t\t}\n\n\t\tif (missing_settings & MGMT_SETTING_LE)\n\t\t\tset_mode(adapter, MGMT_OP_SET_LE, 0x01);\n\t\tif (adapter->current_settings & MGMT_SETTING_BREDR)\n\t\t\tset_mode(adapter, MGMT_OP_SET_BREDR, 0x00);\n\t\tbreak;\n\t}\n\n\tif (missing_settings & MGMT_SETTING_SECURE_CONN)\n\t\tset_mode(adapter, MGMT_OP_SET_SECURE_CONN, 0x01);\n\n\tif (adapter->supported_settings & MGMT_SETTING_PRIVACY)\n\t\tset_privacy(adapter, btd_opts.privacy);\n\n\tif (btd_opts.fast_conn &&\n\t\t\t(missing_settings & MGMT_SETTING_FAST_CONNECTABLE))\n\t\tset_mode(adapter, MGMT_OP_SET_FAST_CONNECTABLE, 0x01);\n\n\terr = adapter_register(adapter);\n\tif (err < 0) {\n\t\tbtd_error(adapter->dev_id, \"Unable to register new adapter\");\n\t\tgoto failed;\n\t}\n\n\t/*\n\t * Register all event notification handlers for controller.\n\t *\n\t * The handlers are registered after a succcesful read of the\n\t * controller info. From now on they can track updates and\n\t * notifications.\n\t */\n\tmgmt_register(adapter->mgmt, MGMT_EV_NEW_SETTINGS, adapter->dev_id,\n\t\t\t\t\tnew_settings_callback, adapter, NULL);\n\n\tmgmt_register(adapter->mgmt, MGMT_EV_CLASS_OF_DEV_CHANGED,\n\t\t\t\t\t\tadapter->dev_id,\n\t\t\t\t\t\tdev_class_changed_callback,\n\t\t\t\t\t\tadapter, NULL);\n\tmgmt_register(adapter->mgmt, MGMT_EV_LOCAL_NAME_CHANGED,\n\t\t\t\t\t\tadapter->dev_id,\n\t\t\t\t\t\tlocal_name_changed_callback,\n\t\t\t\t\t\tadapter, NULL);\n\n\tmgmt_register(adapter->mgmt, MGMT_EV_DISCOVERING,\n\t\t\t\t\t\tadapter->dev_id,\n\t\t\t\t\t\tdiscovering_callback,\n\t\t\t\t\t\tadapter, NULL);\n\n\tmgmt_register(adapter->mgmt, MGMT_EV_DEVICE_FOUND,\n\t\t\t\t\t\tadapter->dev_id,\n\t\t\t\t\t\tdevice_found_callback,\n\t\t\t\t\t\tadapter, NULL);\n\n\tmgmt_register(adapter->mgmt, MGMT_EV_DEVICE_DISCONNECTED,\n\t\t\t\t\t\tadapter->dev_id,\n\t\t\t\t\t\tdisconnected_callback,\n\t\t\t\t\t\tadapter, NULL);\n\n\tmgmt_register(adapter->mgmt, MGMT_EV_DEVICE_CONNECTED,\n\t\t\t\t\t\tadapter->dev_id,\n\t\t\t\t\t\tconnected_callback,\n\t\t\t\t\t\tadapter, NULL);\n\n\tmgmt_register(adapter->mgmt, MGMT_EV_CONNECT_FAILED,\n\t\t\t\t\t\tadapter->dev_id,\n\t\t\t\t\t\tconnect_failed_callback,\n\t\t\t\t\t\tadapter, NULL);\n\n\tmgmt_register(adapter->mgmt, MGMT_EV_DEVICE_UNPAIRED,\n\t\t\t\t\t\tadapter->dev_id,\n\t\t\t\t\t\tunpaired_callback,\n\t\t\t\t\t\tadapter, NULL);\n\n\tmgmt_register(adapter->mgmt, MGMT_EV_AUTH_FAILED,\n\t\t\t\t\t\tadapter->dev_id,\n\t\t\t\t\t\tauth_failed_callback,\n\t\t\t\t\t\tadapter, NULL);\n\n\tmgmt_register(adapter->mgmt, MGMT_EV_NEW_LINK_KEY,\n\t\t\t\t\t\tadapter->dev_id,\n\t\t\t\t\t\tnew_link_key_callback,\n\t\t\t\t\t\tadapter, NULL);\n\n\tmgmt_register(adapter->mgmt, MGMT_EV_NEW_LONG_TERM_KEY,\n\t\t\t\t\t\tadapter->dev_id,\n\t\t\t\t\t\tnew_long_term_key_callback,\n\t\t\t\t\t\tadapter, NULL);\n\n\tmgmt_register(adapter->mgmt, MGMT_EV_NEW_CSRK,\n\t\t\t\t\t\tadapter->dev_id,\n\t\t\t\t\t\tnew_csrk_callback,\n\t\t\t\t\t\tadapter, NULL);\n\n\tmgmt_register(adapter->mgmt, MGMT_EV_NEW_IRK,\n\t\t\t\t\t\tadapter->dev_id,\n\t\t\t\t\t\tnew_irk_callback,\n\t\t\t\t\t\tadapter, NULL);\n\n\tmgmt_register(adapter->mgmt, MGMT_EV_NEW_CONN_PARAM,\n\t\t\t\t\t\tadapter->dev_id,\n\t\t\t\t\t\tnew_conn_param,\n\t\t\t\t\t\tadapter, NULL);\n\n\tmgmt_register(adapter->mgmt, MGMT_EV_DEVICE_BLOCKED,\n\t\t\t\t\t\tadapter->dev_id,\n\t\t\t\t\t\tdevice_blocked_callback,\n\t\t\t\t\t\tadapter, NULL);\n\tmgmt_register(adapter->mgmt, MGMT_EV_DEVICE_UNBLOCKED,\n\t\t\t\t\t\tadapter->dev_id,\n\t\t\t\t\t\tdevice_unblocked_callback,\n\t\t\t\t\t\tadapter, NULL);\n\n\tmgmt_register(adapter->mgmt, MGMT_EV_PIN_CODE_REQUEST,\n\t\t\t\t\t\tadapter->dev_id,\n\t\t\t\t\t\tpin_code_request_callback,\n\t\t\t\t\t\tadapter, NULL);\n\n\tmgmt_register(adapter->mgmt, MGMT_EV_USER_CONFIRM_REQUEST,\n\t\t\t\t\t\tadapter->dev_id,\n\t\t\t\t\t\tuser_confirm_request_callback,\n\t\t\t\t\t\tadapter, NULL);\n\n\tmgmt_register(adapter->mgmt, MGMT_EV_USER_PASSKEY_REQUEST,\n\t\t\t\t\t\tadapter->dev_id,\n\t\t\t\t\t\tuser_passkey_request_callback,\n\t\t\t\t\t\tadapter, NULL);\n\n\tmgmt_register(adapter->mgmt, MGMT_EV_PASSKEY_NOTIFY,\n\t\t\t\t\t\tadapter->dev_id,\n\t\t\t\t\t\tuser_passkey_notify_callback,\n\t\t\t\t\t\tadapter, NULL);\n\n\tmgmt_register(adapter->mgmt, MGMT_EV_CONTROLLER_RESUME,\n\t\t\t\t\t\tadapter->dev_id,\n\t\t\t\t\t\tcontroller_resume_callback,\n\t\t\t\t\t\tadapter, NULL);\n\n\tset_dev_class(adapter);\n\n\tset_name(adapter, btd_adapter_get_name(adapter));\n\n\tif (btd_has_kernel_features(KERNEL_BLOCKED_KEYS_SUPPORTED) &&\n\t    !set_blocked_keys(adapter)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Failed to set blocked keys for index %u\",\n\t\t\t\tadapter->dev_id);\n\t\tgoto failed;\n\t}\n\n\tif (btd_opts.pairable &&\n\t\t\t!(adapter->current_settings & MGMT_SETTING_BONDABLE))\n\t\tset_mode(adapter, MGMT_OP_SET_BONDABLE, 0x01);\n\n\tif (!btd_has_kernel_features(KERNEL_CONN_CONTROL))\n\t\tset_mode(adapter, MGMT_OP_SET_CONNECTABLE, 0x01);\n\telse if (adapter->current_settings & MGMT_SETTING_CONNECTABLE)\n\t\tset_mode(adapter, MGMT_OP_SET_CONNECTABLE, 0x00);\n\n\tif (adapter->stored_discoverable && !adapter->discoverable_timeout)\n\t\tset_discoverable(adapter, 0x01, 0);\n\n\tif (btd_adapter_get_powered(adapter))\n\t\tadapter_start(adapter);\n\n\treturn;\n\nfailed:\n\t/*\n\t * Remove adapter from list in case of a failure.\n\t *\n\t * Leaving an adapter structure around for a controller that can\n\t * not be initilized makes no sense at the moment.\n\t *\n\t * This is a simplification to avoid constant checks if the\n\t * adapter is ready to do anything.\n\t */\n\tadapter_list = g_list_remove(adapter_list, adapter);\n\n\tbtd_adapter_unref(adapter);\n}\n\nstatic void reset_adv_monitors_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_rp_remove_adv_monitor *rp = param;\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\terror(\"Failed to reset Adv Monitors: %s (0x%02x)\",\n\t\t\tmgmt_errstr(status), status);\n\t\treturn;\n\t}\n\n\tif (length < sizeof(*rp)) {\n\t\terror(\"Wrong size of remove Adv Monitor response for reset \"\n\t\t\t\"all Adv Monitors\");\n\t\treturn;\n\t}\n\n\tDBG(\"Removed all Adv Monitors\");\n}\n\nstatic void reset_adv_monitors(uint16_t index)\n{\n\tstruct mgmt_cp_remove_adv_monitor cp;\n\n\tDBG(\"sending remove Adv Monitor command with handle 0\");\n\n\t/* Handle 0 indicates to remove all */\n\tcp.monitor_handle = 0;\n\tif (mgmt_send(mgmt_master, MGMT_OP_REMOVE_ADV_MONITOR, index,\n\t\t\tsizeof(cp), &cp, reset_adv_monitors_complete, NULL,\n\t\t\tNULL) > 0) {\n\t\treturn;\n\t}\n\n\terror(\"Failed to reset Adv Monitors\");\n}\n\nstatic void index_added(uint16_t index, uint16_t length, const void *param,\n\t\t\t\t\t\t\tvoid *user_data)\n{\n\tstruct btd_adapter *adapter;\n\n\tDBG(\"index %u\", index);\n\n\tadapter = btd_adapter_lookup(index);\n\tif (adapter) {\n\t\tbtd_warn(adapter->dev_id,\n\t\t\t\"Ignoring index added for an already existing adapter\");\n\t\treturn;\n\t}\n\n\treset_adv_monitors(index);\n\n\tadapter = btd_adapter_new(index);\n\tif (!adapter) {\n\t\tbtd_error(index,\n\t\t\t\"Unable to create new adapter for index %u\", index);\n\t\treturn;\n\t}\n\n\tif (btd_has_kernel_features(KERNEL_EXP_FEATURES))\n\t\tread_exp_features(adapter);\n\n\t/*\n\t * Protect against potential two executions of read controller info.\n\t *\n\t * In case the start of the daemon and the action of adding a new\n\t * controller coincide this function might be called twice.\n\t *\n\t * To avoid the double execution of reading the controller info,\n\t * add the adapter already to the list. If an adapter is already\n\t * present, the second notification will cause a warning. If the\n\t * command fails the adapter is removed from the list again.\n\t */\n\tadapter_list = g_list_append(adapter_list, adapter);\n\n\tDBG(\"sending read info command for index %u\", index);\n\n\tif (mgmt_send(mgmt_master, MGMT_OP_READ_INFO, index, 0, NULL,\n\t\t\t\t\tread_info_complete, adapter, NULL) > 0)\n\t\treturn;\n\n\tbtd_error(adapter->dev_id,\n\t\t\t\"Failed to read controller info for index %u\", index);\n\n\tadapter_list = g_list_remove(adapter_list, adapter);\n\n\tbtd_adapter_unref(adapter);\n}\n\nstatic void index_removed(uint16_t index, uint16_t length, const void *param,\n\t\t\t\t\t\t\tvoid *user_data)\n{\n\tstruct btd_adapter *adapter;\n\n\tDBG(\"index %u\", index);\n\n\tadapter = btd_adapter_lookup(index);\n\tif (!adapter) {\n\t\twarn(\"Ignoring index removal for a non-existent adapter\");\n\t\treturn;\n\t}\n\n\tadapter_unregister(adapter);\n}\n\nstatic void read_index_list_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_rp_read_index_list *rp = param;\n\tuint16_t num;\n\tint i;\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\terror(\"Failed to read index list: %s (0x%02x)\",\n\t\t\t\t\t\tmgmt_errstr(status), status);\n\t\treturn;\n\t}\n\n\tif (length < sizeof(*rp)) {\n\t\terror(\"Wrong size of read index list response\");\n\t\treturn;\n\t}\n\n\tnum = btohs(rp->num_controllers);\n\n\tDBG(\"Number of controllers: %d\", num);\n\n\tif (num * sizeof(uint16_t) + sizeof(*rp) != length) {\n\t\terror(\"Incorrect packet size for index list response\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < num; i++) {\n\t\tuint16_t index;\n\n\t\tindex = btohs(rp->index[i]);\n\n\t\tDBG(\"Found index %u\", index);\n\n\t\t/*\n\t\t * Pretend to be index added event notification.\n\t\t *\n\t\t * It is safe to just trigger the procedure for index\n\t\t * added notification. It does check against itself.\n\t\t */\n\t\tindex_added(index, 0, NULL, NULL);\n\t}\n}\n\nstatic void read_commands_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_rp_read_commands *rp = param;\n\tuint16_t num_commands, num_events;\n\tsize_t expected_len;\n\tint i;\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\terror(\"Failed to read supported commands: %s (0x%02x)\",\n\t\t\t\t\t\tmgmt_errstr(status), status);\n\t\treturn;\n\t}\n\n\tif (length < sizeof(*rp)) {\n\t\terror(\"Wrong size of read commands response\");\n\t\treturn;\n\t}\n\n\tnum_commands = btohs(rp->num_commands);\n\tnum_events = btohs(rp->num_events);\n\n\tDBG(\"Number of commands: %d\", num_commands);\n\tDBG(\"Number of events: %d\", num_events);\n\n\texpected_len = sizeof(*rp) + num_commands * sizeof(uint16_t) +\n\t\t\t\t\t\tnum_events * sizeof(uint16_t);\n\n\tif (length < expected_len) {\n\t\terror(\"Too small reply for supported commands: (%u != %zu)\",\n\t\t\t\t\t\t\tlength, expected_len);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < num_commands; i++) {\n\t\tuint16_t op = get_le16(rp->opcodes + i);\n\n\t\tswitch (op) {\n\t\tcase MGMT_OP_ADD_DEVICE:\n\t\t\tDBG(\"enabling kernel-side connection control\");\n\t\t\tkernel_features |= KERNEL_CONN_CONTROL;\n\t\t\tbreak;\n\t\tcase MGMT_OP_SET_BLOCKED_KEYS:\n\t\t\tDBG(\"kernel supports the set_blocked_keys op\");\n\t\t\tkernel_features |= KERNEL_BLOCKED_KEYS_SUPPORTED;\n\t\t\tbreak;\n\t\tcase MGMT_OP_SET_DEF_SYSTEM_CONFIG:\n\t\t\tDBG(\"kernel supports set system confic\");\n\t\t\tkernel_features |= KERNEL_SET_SYSTEM_CONFIG;\n\t\t\tbreak;\n\t\tcase MGMT_OP_READ_EXP_FEATURES_INFO:\n\t\t\tDBG(\"kernel supports exp features\");\n\t\t\tkernel_features |= KERNEL_EXP_FEATURES;\n\t\t\tbreak;\n\t\tcase MGMT_OP_ADD_EXT_ADV_PARAMS:\n\t\t\tDBG(\"kernel supports ext adv commands\");\n\t\t\tkernel_features |= KERNEL_HAS_EXT_ADV_ADD_CMDS;\n\t\t\tbreak;\n\t\tcase MGMT_OP_READ_CONTROLLER_CAP:\n\t\t\tDBG(\"kernel supports controller cap command\");\n\t\t\tkernel_features |= KERNEL_HAS_CONTROLLER_CAP_CMD;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (i = 0; i < num_events; i++) {\n\t\tuint16_t ev = get_le16(rp->opcodes + num_commands + i);\n\n\t\tswitch(ev) {\n\t\tcase MGMT_EV_CONTROLLER_RESUME:\n\t\t\tDBG(\"kernel supports suspend/resume events\");\n\t\t\tkernel_features |= KERNEL_HAS_RESUME_EVT;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void read_version_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_rp_read_version *rp = param;\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\terror(\"Failed to read version information: %s (0x%02x)\",\n\t\t\t\t\t\tmgmt_errstr(status), status);\n\t\treturn;\n\t}\n\n\tif (length < sizeof(*rp)) {\n\t\terror(\"Wrong size of read version response\");\n\t\treturn;\n\t}\n\n\tmgmt_version = rp->version;\n\tmgmt_revision = btohs(rp->revision);\n\n\tinfo(\"Bluetooth management interface %u.%u initialized\",\n\t\t\t\t\t\tmgmt_version, mgmt_revision);\n\n\tif (mgmt_version < 1) {\n\t\terror(\"Version 1.0 or later of management interface required\");\n\t\tabort();\n\t}\n\n\tDBG(\"sending read supported commands command\");\n\n\t/*\n\t * It is irrelevant if this command succeeds or fails. In case of\n\t * failure safe settings are assumed.\n\t */\n\tmgmt_send(mgmt_master, MGMT_OP_READ_COMMANDS,\n\t\t\t\tMGMT_INDEX_NONE, 0, NULL,\n\t\t\t\tread_commands_complete, NULL, NULL);\n\n\tmgmt_register(mgmt_master, MGMT_EV_INDEX_ADDED, MGMT_INDEX_NONE,\n\t\t\t\t\t\tindex_added, NULL, NULL);\n\tmgmt_register(mgmt_master, MGMT_EV_INDEX_REMOVED, MGMT_INDEX_NONE,\n\t\t\t\t\t\tindex_removed, NULL, NULL);\n\n\tDBG(\"sending read index list command\");\n\n\tif (mgmt_send(mgmt_master, MGMT_OP_READ_INDEX_LIST,\n\t\t\t\tMGMT_INDEX_NONE, 0, NULL,\n\t\t\t\tread_index_list_complete, NULL, NULL) > 0)\n\t\treturn;\n\n\terror(\"Failed to read controller index list\");\n}\n\nstatic void mgmt_debug(const char *str, void *user_data)\n{\n\tconst char *prefix = user_data;\n\n\tinfo(\"%s%s\", prefix, str);\n}\n\nint adapter_init(void)\n{\n\tdbus_conn = btd_get_dbus_connection();\n\n\tmgmt_master = mgmt_new_default();\n\tif (!mgmt_master) {\n\t\terror(\"Failed to access management interface\");\n\t\treturn -EIO;\n\t}\n\n\tif (getenv(\"MGMT_DEBUG\"))\n\t\tmgmt_set_debug(mgmt_master, mgmt_debug, \"mgmt: \", NULL);\n\n\tDBG(\"sending read version command\");\n\n\tif (mgmt_send(mgmt_master, MGMT_OP_READ_VERSION,\n\t\t\t\tMGMT_INDEX_NONE, 0, NULL,\n\t\t\t\tread_version_complete, NULL, NULL) > 0)\n\t\treturn 0;\n\n\terror(\"Failed to read management version information\");\n\n\treturn -EIO;\n}\n\nvoid adapter_cleanup(void)\n{\n\tg_list_free(adapter_list);\n\n\twhile (adapters) {\n\t\tstruct btd_adapter *adapter = adapters->data;\n\n\t\tadapter_remove(adapter);\n\t\tadapters = g_slist_remove(adapters, adapter);\n\t\tbtd_adapter_unref(adapter);\n\t}\n\n\t/*\n\t * In case there is another reference active, clear out\n\t * registered handlers for index added and index removed.\n\t *\n\t * This is just an extra precaution to be safe, and in\n\t * reality should not make a difference.\n\t */\n\tmgmt_unregister_index(mgmt_master, MGMT_INDEX_NONE);\n\n\t/*\n\t * In case there is another reference active, cancel\n\t * all pending global commands.\n\t *\n\t * This is just an extra precaution to avoid callbacks\n\t * that potentially then could leak memory or access\n\t * an invalid structure.\n\t */\n\tmgmt_cancel_index(mgmt_master, MGMT_INDEX_NONE);\n\n\tmgmt_unref(mgmt_master);\n\tmgmt_master = NULL;\n\n\tdbus_conn = NULL;\n}\n\nvoid adapter_shutdown(void)\n{\n\tGList *list;\n\n\tDBG(\"\");\n\n\tpowering_down = true;\n\n\tfor (list = g_list_first(adapter_list); list;\n\t\t\t\t\t\tlist = g_list_next(list)) {\n\t\tstruct btd_adapter *adapter = list->data;\n\n\t\tif (!(adapter->current_settings & MGMT_SETTING_POWERED))\n\t\t\tcontinue;\n\n\t\tclear_discoverable(adapter);\n\t\tremove_temporary_devices(adapter);\n\t\tset_mode(adapter, MGMT_OP_SET_POWERED, 0x00);\n\n\t\tadapter_remaining++;\n\t}\n\n\tif (!adapter_remaining)\n\t\tbtd_exit();\n}\n\n/*\n * Check if workaround for broken ATT server socket behavior is needed\n * where we need to connect an ATT client socket before pairing to get\n * early access to the ATT channel.\n */\nbool btd_le_connect_before_pairing(void)\n{\n\tif (MGMT_VERSION(mgmt_version, mgmt_revision) < MGMT_VERSION(1, 4))\n\t\treturn true;\n\n\treturn false;\n}\n\nbool btd_has_kernel_features(uint32_t features)\n{\n\treturn (kernel_features & features) ? true : false;\n}\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *\n *  BlueZ - Bluetooth protocol stack for Linux\n *\n *  Copyright (C) 2006-2010  Nokia Corporation\n *  Copyright (C) 2004-2010  Marcel Holtmann <marcel@holtmann.org>\n *\n *\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#define _GNU_SOURCE\n#include <stdio.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/stat.h>\n#include <dirent.h>\n\n#include <glib.h>\n#include <dbus/dbus.h>\n\n#include \"bluetooth/bluetooth.h\"\n#include \"bluetooth/hci.h\"\n#include \"bluetooth/hci_lib.h\"\n#include \"bluetooth/sdp.h\"\n#include \"bluetooth/sdp_lib.h\"\n#include \"lib/uuid.h\"\n#include \"lib/mgmt.h\"\n\n#include \"gdbus/gdbus.h\"\n\n#include \"log.h\"\n#include \"textfile.h\"\n\n#include \"src/shared/mgmt.h\"\n#include \"src/shared/util.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/att.h\"\n#include \"src/shared/gatt-db.h\"\n#include \"src/shared/timeout.h\"\n\n#include \"btio/btio.h\"\n#include \"btd.h\"\n#include \"sdpd.h\"\n#include \"adapter.h\"\n#include \"device.h\"\n#include \"profile.h\"\n#include \"dbus-common.h\"\n#include \"error.h\"\n#include \"uuid-helper.h\"\n#include \"agent.h\"\n#include \"storage.h\"\n#include \"attrib/gattrib.h\"\n#include \"attrib/att.h\"\n#include \"attrib/gatt.h\"\n#include \"attrib-server.h\"\n#include \"gatt-database.h\"\n#include \"advertising.h\"\n#include \"adv_monitor.h\"\n#include \"eir.h\"\n#include \"battery.h\"\n\n#define MODE_OFF\t\t0x00\n#define MODE_CONNECTABLE\t0x01\n#define MODE_DISCOVERABLE\t0x02\n#define MODE_UNKNOWN\t\t0xff\n\n#define CONN_SCAN_TIMEOUT (3)\n#define IDLE_DISCOV_TIMEOUT (5)\n#define TEMP_DEV_TIMEOUT (3 * 60)\n#define BONDING_TIMEOUT (2 * 60)\n\n#define SCAN_TYPE_BREDR (1 << BDADDR_BREDR)\n#define SCAN_TYPE_LE ((1 << BDADDR_LE_PUBLIC) | (1 << BDADDR_LE_RANDOM))\n#define SCAN_TYPE_DUAL (SCAN_TYPE_BREDR | SCAN_TYPE_LE)\n\n#define HCI_RSSI_INVALID\t127\n#define DISTANCE_VAL_INVALID\t0x7FFF\n#define PATHLOSS_MAX\t\t137\n\n/*\n * These are known security keys that have been compromised.\n * If this grows or there are needs to be platform specific, it is\n * conceivable that these could be read from a config file.\n */\nstatic const struct mgmt_blocked_key_info blocked_keys[] = {\n\t/* Google Titan Security Keys */\n\t{ HCI_BLOCKED_KEY_TYPE_LTK,\n\t\t{0xbf, 0x01, 0xfb, 0x9d, 0x4e, 0xf3, 0xbc, 0x36,\n\t\t 0xd8, 0x74, 0xf5, 0x39, 0x41, 0x38, 0x68, 0x4c}},\n\t{ HCI_BLOCKED_KEY_TYPE_IRK,\n\t\t{0xa5, 0x99, 0xba, 0xe4, 0xe1, 0x7c, 0xa6, 0x18,\n\t\t 0x22, 0x8e, 0x07, 0x56, 0xb4, 0xe8, 0x5f, 0x01}},\n};\n\nstatic DBusConnection *dbus_conn = NULL;\n\nstatic uint32_t kernel_features = 0;\n\nstatic GList *adapter_list = NULL;\nstatic unsigned int adapter_remaining = 0;\nstatic bool powering_down = false;\n\nstatic GSList *adapters = NULL;\n\nstatic struct mgmt *mgmt_master = NULL;\n\nstatic uint8_t mgmt_version = 0;\nstatic uint8_t mgmt_revision = 0;\n\nstatic GSList *adapter_drivers = NULL;\n\nstatic GSList *disconnect_list = NULL;\nstatic GSList *conn_fail_list = NULL;\n\nstruct link_key_info {\n\tbdaddr_t bdaddr;\n\tunsigned char key[16];\n\tuint8_t type;\n\tuint8_t pin_len;\n\tbool is_blocked;\n};\n\nstruct smp_ltk_info {\n\tbdaddr_t bdaddr;\n\tuint8_t bdaddr_type;\n\tuint8_t authenticated;\n\tbool master;\n\tuint8_t enc_size;\n\tuint16_t ediv;\n\tuint64_t rand;\n\tuint8_t val[16];\n\tbool is_blocked;\n};\n\nstruct irk_info {\n\tbdaddr_t bdaddr;\n\tuint8_t bdaddr_type;\n\tuint8_t val[16];\n\tbool is_blocked;\n};\n\nstruct conn_param {\n\tbdaddr_t bdaddr;\n\tuint8_t  bdaddr_type;\n\tuint16_t min_interval;\n\tuint16_t max_interval;\n\tuint16_t latency;\n\tuint16_t timeout;\n};\n\nstruct discovery_filter {\n\tuint8_t type;\n\tchar *pattern;\n\tuint16_t pathloss;\n\tint16_t rssi;\n\tGSList *uuids;\n\tbool duplicate;\n\tbool discoverable;\n};\n\nstruct discovery_client {\n\tstruct btd_adapter *adapter;\n\tDBusMessage *msg;\n\tchar *owner;\n\tguint watch;\n\tstruct discovery_filter *discovery_filter;\n};\n\nstruct service_auth {\n\tguint id;\n\tunsigned int svc_id;\n\tservice_auth_cb cb;\n\tvoid *user_data;\n\tconst char *uuid;\n\tstruct btd_device *device;\n\tstruct btd_adapter *adapter;\n\tstruct agent *agent;\t\t/* NULL for queued auths */\n};\n\nstruct btd_adapter_pin_cb_iter {\n\tGSList *it;\t\t\t/* current callback function */\n\tunsigned int attempt;\t\t/* numer of times it() was called */\n\t/* When the iterator reaches the end, it is NULL and attempt is 0 */\n};\n\nstruct btd_adapter {\n\tint ref_count;\n\n\tuint16_t dev_id;\n\tstruct mgmt *mgmt;\n\n\tbdaddr_t bdaddr;\t\t/* controller Bluetooth address */\n\tuint8_t bdaddr_type;\t\t/* address type */\n\tuint32_t dev_class;\t\t/* controller class of device */\n\tchar *name;\t\t\t/* controller device name */\n\tchar *short_name;\t\t/* controller short name */\n\tuint32_t supported_settings;\t/* controller supported settings */\n\tuint32_t pending_settings;\t/* pending controller settings */\n\tuint32_t current_settings;\t/* current controller settings */\n\n\tchar *path;\t\t\t/* adapter object path */\n\tuint16_t manufacturer;\t\t/* adapter manufacturer */\n\tuint8_t major_class;\t\t/* configured major class */\n\tuint8_t minor_class;\t\t/* configured minor class */\n\tchar *system_name;\t\t/* configured system name */\n\tchar *modalias;\t\t\t/* device id (modalias) */\n\tbool stored_discoverable;\t/* stored discoverable mode */\n\tuint32_t discoverable_timeout;\t/* discoverable time(sec) */\n\tuint32_t pairable_timeout;\t/* pairable time(sec) */\n\n\tchar *current_alias;\t\t/* current adapter name alias */\n\tchar *stored_alias;\t\t/* stored adapter name alias */\n\n\tbool discovering;\t\t/* discovering property state */\n\tbool filtered_discovery;\t/* we are doing filtered discovery */\n\tbool no_scan_restart_delay;\t/* when this flag is set, restart scan\n\t\t\t\t\t * without delay */\n\tuint8_t discovery_type;\t\t/* current active discovery type */\n\tuint8_t discovery_enable;\t/* discovery enabled/disabled */\n\tbool discovery_suspended;\t/* discovery has been suspended */\n\tbool discovery_discoverable;\t/* discoverable while discovering */\n\tGSList *discovery_list;\t\t/* list of discovery clients */\n\tGSList *set_filter_list;\t/* list of clients that specified\n\t\t\t\t\t * filter, but don't scan yet\n\t\t\t\t\t */\n\t/* current discovery filter, if any */\n\tstruct mgmt_cp_start_service_discovery *current_discovery_filter;\n\tstruct discovery_client *client;\t/* active discovery client */\n\n\tGSList *discovery_found;\t/* list of found devices */\n\tunsigned int discovery_idle_timeout; /* timeout between discovery\n\t\t\t\t\t      * runs\n\t\t\t\t\t      */\n\tunsigned int passive_scan_timeout; /* timeout between passive scans */\n\n\tunsigned int pairable_timeout_id;\t/* pairable timeout id */\n\tguint auth_idle_id;\t\t/* Pending authorization dequeue */\n\tGQueue *auths;\t\t\t/* Ongoing and pending auths */\n\tbool pincode_requested;\t\t/* PIN requested during last bonding */\n\tGSList *connections;\t\t/* Connected devices */\n\tGSList *devices;\t\t/* Devices structure pointers */\n\tGSList *connect_list;\t\t/* Devices to connect when found */\n\tstruct btd_device *connect_le;\t/* LE device waiting to be connected */\n\tsdp_list_t *services;\t\t/* Services associated to adapter */\n\n\tstruct btd_gatt_database *database;\n\tstruct btd_adv_manager *adv_manager;\n\n\tstruct btd_adv_monitor_manager *adv_monitor_manager;\n\n\tstruct btd_battery_provider_manager *battery_provider_manager;\n\n\tgboolean initialized;\n\n\tGSList *pin_callbacks;\n\tGSList *msd_callbacks;\n\n\tGSList *drivers;\n\tGSList *profiles;\n\n\tstruct oob_handler *oob_handler;\n\n\tunsigned int load_ltks_id;\n\tunsigned int load_ltks_timeout;\n\n\tunsigned int confirm_name_id;\n\tunsigned int confirm_name_timeout;\n\n\tunsigned int pair_device_id;\n\tunsigned int pair_device_timeout;\n\n\tunsigned int db_id;\t\t/* Service event handler for GATT db */\n\n\tbool is_default;\t\t/* true if adapter is default one */\n\n\tbool le_simult_roles_supported;\n\tbool quality_report_supported;\n};\n\ntypedef enum {\n\tADAPTER_AUTHORIZE_DISCONNECTED = 0,\n\tADAPTER_AUTHORIZE_CHECK_CONNECTED\n} adapter_authorize_type;\n\nstatic struct btd_adapter *btd_adapter_lookup(uint16_t index)\n{\n\tGList *list;\n\n\tfor (list = g_list_first(adapter_list); list;\n\t\t\t\t\t\tlist = g_list_next(list)) {\n\t\tstruct btd_adapter *adapter = list->data;\n\n\t\tif (adapter->dev_id == index)\n\t\t\treturn adapter;\n\t}\n\n\treturn NULL;\n}\n\nstruct btd_adapter *btd_adapter_get_default(void)\n{\n\tGList *list;\n\n\tfor (list = g_list_first(adapter_list); list;\n\t\t\t\t\t\tlist = g_list_next(list)) {\n\t\tstruct btd_adapter *adapter = list->data;\n\n\t\tif (adapter->is_default)\n\t\t\treturn adapter;\n\t}\n\n\treturn NULL;\n}\n\nbool btd_adapter_is_default(struct btd_adapter *adapter)\n{\n\tif (!adapter)\n\t\treturn false;\n\n\treturn adapter->is_default;\n}\n\nuint16_t btd_adapter_get_index(struct btd_adapter *adapter)\n{\n\tif (!adapter)\n\t\treturn MGMT_INDEX_NONE;\n\n\treturn adapter->dev_id;\n}\n\nstatic gboolean process_auth_queue(gpointer user_data);\n\nstatic void dev_class_changed_callback(uint16_t index, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tconst struct mgmt_cod *rp = param;\n\tuint32_t dev_class;\n\n\tif (length < sizeof(*rp)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\"Wrong size of class of device changed parameters\");\n\t\treturn;\n\t}\n\n\tdev_class = rp->val[0] | (rp->val[1] << 8) | (rp->val[2] << 16);\n\n\tif (dev_class == adapter->dev_class)\n\t\treturn;\n\n\tDBG(\"Class: 0x%06x\", dev_class);\n\n\tadapter->dev_class = dev_class;\n\n\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\t\tADAPTER_INTERFACE, \"Class\");\n}\n\nstatic void set_dev_class_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Failed to set device class: %s (0x%02x)\",\n\t\t\t\t\t\tmgmt_errstr(status), status);\n\t\treturn;\n\t}\n\n\t/*\n\t * The parameters are identical and also the task that is\n\t * required in both cases. So it is safe to just call the\n\t * event handling functions here.\n\t */\n\tdev_class_changed_callback(adapter->dev_id, length, param, adapter);\n}\n\nstatic void set_dev_class(struct btd_adapter *adapter)\n{\n\tstruct mgmt_cp_set_dev_class cp;\n\n\t/*\n\t * If the controller does not support BR/EDR operation,\n\t * there is no point in trying to set a major and minor\n\t * class value.\n\t *\n\t * This is an optimization for Low Energy only controllers.\n\t */\n\tif (!(adapter->supported_settings & MGMT_SETTING_BREDR))\n\t\treturn;\n\n\tmemset(&cp, 0, sizeof(cp));\n\n\t/*\n\t * Silly workaround for a really stupid kernel bug :(\n\t *\n\t * All current kernel versions assign the major and minor numbers\n\t * straight to dev_class[0] and dev_class[1] without considering\n\t * the proper bit shifting.\n\t *\n\t * To make this work, shift the value in userspace for now until\n\t * we get a fixed kernel version.\n\t */\n\tcp.major = adapter->major_class & 0x1f;\n\tcp.minor = adapter->minor_class << 2;\n\n\tDBG(\"sending set device class command for index %u\", adapter->dev_id);\n\n\tif (mgmt_send(adapter->mgmt, MGMT_OP_SET_DEV_CLASS,\n\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\tset_dev_class_complete, adapter, NULL) > 0)\n\t\treturn;\n\n\tbtd_error(adapter->dev_id,\n\t\t\"Failed to set class of device for index %u\", adapter->dev_id);\n}\n\nvoid btd_adapter_set_class(struct btd_adapter *adapter, uint8_t major,\n\t\t\t\t\t\t\tuint8_t minor)\n{\n\tif (adapter->major_class == major && adapter->minor_class == minor)\n\t\treturn;\n\n\tDBG(\"class: major %u minor %u\", major, minor);\n\n\tadapter->major_class = major;\n\tadapter->minor_class = minor;\n\n\tset_dev_class(adapter);\n}\n\nstatic uint8_t get_mode(const char *mode)\n{\n\tif (strcasecmp(\"off\", mode) == 0)\n\t\treturn MODE_OFF;\n\telse if (strcasecmp(\"connectable\", mode) == 0)\n\t\treturn MODE_CONNECTABLE;\n\telse if (strcasecmp(\"discoverable\", mode) == 0)\n\t\treturn MODE_DISCOVERABLE;\n\telse\n\t\treturn MODE_UNKNOWN;\n}\n\nconst char *btd_adapter_get_storage_dir(struct btd_adapter *adapter)\n{\n\tstatic char dir[25];\n\n\tif (adapter->bdaddr_type == BDADDR_LE_RANDOM) {\n\t\tstrcpy(dir, \"static-\");\n\t\tba2str(&adapter->bdaddr, dir + 7);\n\t} else {\n\t\tba2str(&adapter->bdaddr, dir);\n\t}\n\n\treturn dir;\n}\n\nuint8_t btd_adapter_get_address_type(struct btd_adapter *adapter)\n{\n\treturn adapter->bdaddr_type;\n}\n\nstatic void store_adapter_info(struct btd_adapter *adapter)\n{\n\tGKeyFile *key_file;\n\tchar filename[PATH_MAX];\n\tchar *str;\n\tgsize length = 0;\n\tgboolean discoverable;\n\n\tkey_file = g_key_file_new();\n\n\tif (adapter->pairable_timeout != btd_opts.pairto)\n\t\tg_key_file_set_integer(key_file, \"General\", \"PairableTimeout\",\n\t\t\t\t\tadapter->pairable_timeout);\n\n\tif ((adapter->current_settings & MGMT_SETTING_DISCOVERABLE) &&\n\t\t\t\t\t\t!adapter->discoverable_timeout)\n\t\tdiscoverable = TRUE;\n\telse\n\t\tdiscoverable = FALSE;\n\n\tg_key_file_set_boolean(key_file, \"General\", \"Discoverable\",\n\t\t\t\t\t\t\tdiscoverable);\n\n\tif (adapter->discoverable_timeout != btd_opts.discovto)\n\t\tg_key_file_set_integer(key_file, \"General\",\n\t\t\t\t\t\"DiscoverableTimeout\",\n\t\t\t\t\tadapter->discoverable_timeout);\n\n\tif (adapter->stored_alias)\n\t\tg_key_file_set_string(key_file, \"General\", \"Alias\",\n\t\t\t\t\t\t\tadapter->stored_alias);\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/settings\",\n\t\t\t\t\tbtd_adapter_get_storage_dir(adapter));\n\n\tcreate_file(filename, 0600);\n\n\tstr = g_key_file_to_data(key_file, &length, NULL);\n\tg_file_set_contents(filename, str, length, NULL);\n\tg_free(str);\n\n\tg_key_file_free(key_file);\n}\n\nstatic void trigger_pairable_timeout(struct btd_adapter *adapter);\nstatic void adapter_start(struct btd_adapter *adapter);\nstatic void adapter_stop(struct btd_adapter *adapter);\nstatic void trigger_passive_scanning(struct btd_adapter *adapter);\nstatic bool set_mode(struct btd_adapter *adapter, uint16_t opcode,\n\t\t\t\t\t\t\tuint8_t mode);\n\nstatic void settings_changed(struct btd_adapter *adapter, uint32_t settings)\n{\n\tuint32_t changed_mask;\n\n\tchanged_mask = adapter->current_settings ^ settings;\n\n\tadapter->current_settings = settings;\n\tadapter->pending_settings &= ~changed_mask;\n\n\tDBG(\"Changed settings: 0x%08x\", changed_mask);\n\tDBG(\"Pending settings: 0x%08x\", adapter->pending_settings);\n\n\tif (changed_mask & MGMT_SETTING_POWERED) {\n\t        g_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Powered\");\n\n\t\tif (adapter->current_settings & MGMT_SETTING_POWERED) {\n\t\t\tadapter_start(adapter);\n\t\t} else {\n\t\t\tadapter_stop(adapter);\n\n\t\t\tif (powering_down) {\n\t\t\t\tadapter_remaining--;\n\n\t\t\t\tif (!adapter_remaining)\n\t\t\t\t\tbtd_exit();\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((changed_mask & MGMT_SETTING_LE) &&\n\t\t\t\tbtd_adapter_get_powered(adapter) &&\n\t\t\t\t(adapter->current_settings & MGMT_SETTING_LE))\n\t\ttrigger_passive_scanning(adapter);\n\n\tif (changed_mask & MGMT_SETTING_DISCOVERABLE) {\n\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Discoverable\");\n\t\t/* Only persist discoverable setting if it was not set\n\t\t * temporarily by discovery.\n\t\t */\n\t\tif (!adapter->discovery_discoverable)\n\t\t\tstore_adapter_info(adapter);\n\t\tbtd_adv_manager_refresh(adapter->adv_manager);\n\t}\n\n\tif (changed_mask & MGMT_SETTING_BONDABLE) {\n\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Pairable\");\n\n\t\ttrigger_pairable_timeout(adapter);\n\t}\n}\n\nstatic void new_settings_callback(uint16_t index, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tuint32_t settings;\n\n\tif (length < sizeof(settings)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Wrong size of new settings parameters\");\n\t\treturn;\n\t}\n\n\tsettings = get_le32(param);\n\n\tif (settings == adapter->current_settings)\n\t\treturn;\n\n\tDBG(\"Settings: 0x%08x\", settings);\n\n\tsettings_changed(adapter, settings);\n}\n\nstatic void set_mode_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\tbtd_error(adapter->dev_id, \"Failed to set mode: %s (0x%02x)\",\n\t\t\t\t\t\tmgmt_errstr(status), status);\n\t\treturn;\n\t}\n\n\t/*\n\t * The parameters are identical and also the task that is\n\t * required in both cases. So it is safe to just call the\n\t * event handling functions here.\n\t */\n\tnew_settings_callback(adapter->dev_id, length, param, adapter);\n}\n\nstatic void remove_temporary_devices(struct btd_adapter *adapter)\n{\n\tGSList *l, *next;\n\n\tfor (l = adapter->devices; l; l = next) {\n\t\tstruct btd_device *dev = l->data;\n\n\t\tnext = g_slist_next(l);\n\t\tif (device_is_temporary(dev))\n\t\t\tbtd_adapter_remove_device(adapter, dev);\n\t}\n}\n\nstatic bool set_mode(struct btd_adapter *adapter, uint16_t opcode,\n\t\t\t\t\t\t\tuint8_t mode)\n{\n\tstruct mgmt_mode cp;\n\tuint32_t setting = 0;\n\n\tmemset(&cp, 0, sizeof(cp));\n\tcp.val = mode;\n\n\tswitch (opcode) {\n\tcase MGMT_OP_SET_POWERED:\n\t\tsetting = MGMT_SETTING_POWERED;\n\t\tbreak;\n\tcase MGMT_OP_SET_CONNECTABLE:\n\t\tsetting = MGMT_SETTING_CONNECTABLE;\n\t\tbreak;\n\tcase MGMT_OP_SET_FAST_CONNECTABLE:\n\t\tsetting = MGMT_SETTING_FAST_CONNECTABLE;\n\t\tbreak;\n\tcase MGMT_OP_SET_DISCOVERABLE:\n\t\tsetting = MGMT_SETTING_DISCOVERABLE;\n\t\tbreak;\n\tcase MGMT_OP_SET_BONDABLE:\n\t\tsetting = MGMT_SETTING_BONDABLE;\n\t\tbreak;\n\t}\n\n\tadapter->pending_settings |= setting;\n\n\tDBG(\"sending set mode command for index %u\", adapter->dev_id);\n\n\tif (mgmt_send(adapter->mgmt, opcode,\n\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\tset_mode_complete, adapter, NULL) > 0)\n\t\treturn true;\n\n\tbtd_error(adapter->dev_id, \"Failed to set mode for index %u\",\n\t\t\t\t\t\t\tadapter->dev_id);\n\n\treturn false;\n}\n\nstatic bool set_discoverable(struct btd_adapter *adapter, uint8_t mode,\n\t\t\t\t\t\t\tuint16_t timeout)\n{\n\tstruct mgmt_cp_set_discoverable cp;\n\n\tmemset(&cp, 0, sizeof(cp));\n\tcp.val = mode;\n\tcp.timeout = htobs(timeout);\n\n\tDBG(\"sending set mode command for index %u\", adapter->dev_id);\n\n\tif (btd_has_kernel_features(KERNEL_CONN_CONTROL)) {\n\t\tif (mode)\n\t\t\tset_mode(adapter, MGMT_OP_SET_CONNECTABLE, mode);\n\t\telse\n\t\t\t/* This also disables discoverable so we're done */\n\t\t\treturn set_mode(adapter, MGMT_OP_SET_CONNECTABLE,\n\t\t\t\t\t\t\t\t\tmode);\n\t}\n\n\tif (mgmt_send(adapter->mgmt, MGMT_OP_SET_DISCOVERABLE,\n\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\tset_mode_complete, adapter, NULL) > 0)\n\t\treturn true;\n\n\tbtd_error(adapter->dev_id, \"Failed to set mode for index %u\",\n\t\t\t\t\t\t\tadapter->dev_id);\n\n\treturn false;\n}\n\nstatic bool pairable_timeout_handler(gpointer user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\tadapter->pairable_timeout_id = 0;\n\n\tset_mode(adapter, MGMT_OP_SET_BONDABLE, 0x00);\n\n\treturn FALSE;\n}\n\nstatic void trigger_pairable_timeout(struct btd_adapter *adapter)\n{\n\tif (adapter->pairable_timeout_id > 0) {\n\t\ttimeout_remove(adapter->pairable_timeout_id);\n\t\tadapter->pairable_timeout_id = 0;\n\t}\n\n\tif (!(adapter->current_settings & MGMT_SETTING_BONDABLE))\n\t\treturn;\n\n\tif (adapter->pairable_timeout > 0)\n\t\tadapter->pairable_timeout_id =\n\t\t\ttimeout_add_seconds(adapter->pairable_timeout,\n\t\t\t\t\tpairable_timeout_handler, adapter,\n\t\t\t\t\tNULL);\n}\n\nstatic void local_name_changed_callback(uint16_t index, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tconst struct mgmt_cp_set_local_name *rp = param;\n\n\tif (length < sizeof(*rp)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Wrong size of local name changed parameters\");\n\t\treturn;\n\t}\n\n\tif (!g_strcmp0(adapter->short_name, (const char *) rp->short_name) &&\n\t\t\t!g_strcmp0(adapter->name, (const char *) rp->name))\n\t\treturn;\n\n\tDBG(\"Name: %s\", rp->name);\n\tDBG(\"Short name: %s\", rp->short_name);\n\n\tg_free(adapter->name);\n\tadapter->name = g_strdup((const char *) rp->name);\n\n\tg_free(adapter->short_name);\n\tadapter->short_name = g_strdup((const char *) rp->short_name);\n\n\t/*\n\t * Changing the name (even manually via HCI) will update the\n\t * current alias property.\n\t *\n\t * In case the name is empty, use the short name.\n\t *\n\t * There is a difference between the stored alias (which is\n\t * configured by the user) and the current alias. The current\n\t * alias is temporary for the lifetime of the daemon.\n\t */\n\tif (adapter->name && adapter->name[0] != '\\0') {\n\t\tg_free(adapter->current_alias);\n\t\tadapter->current_alias = g_strdup(adapter->name);\n\t} else {\n\t\tg_free(adapter->current_alias);\n\t\tadapter->current_alias = g_strdup(adapter->short_name);\n\t}\n\n\tDBG(\"Current alias: %s\", adapter->current_alias);\n\n\tif (!adapter->current_alias)\n\t\treturn;\n\n\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\t\tADAPTER_INTERFACE, \"Alias\");\n\n\tattrib_gap_set(adapter, GATT_CHARAC_DEVICE_NAME,\n\t\t\t\t(const uint8_t *) adapter->current_alias,\n\t\t\t\t\tstrlen(adapter->current_alias));\n}\n\nstatic void set_local_name_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Failed to set local name: %s (0x%02x)\",\n\t\t\t\t\t\tmgmt_errstr(status), status);\n\t\treturn;\n\t}\n\n\t/*\n\t * The parameters are identical and also the task that is\n\t * required in both cases. So it is safe to just call the\n\t * event handling functions here.\n\t */\n\tlocal_name_changed_callback(adapter->dev_id, length, param, adapter);\n}\n\nstatic int set_name(struct btd_adapter *adapter, const char *name)\n{\n\tstruct mgmt_cp_set_local_name cp;\n\tchar maxname[MAX_NAME_LENGTH];\n\n\tmemset(maxname, 0, sizeof(maxname));\n\tstrncpy(maxname, name, MAX_NAME_LENGTH - 1);\n\n\tif (!g_utf8_validate(maxname, -1, NULL)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\"Name change failed: supplied name isn't valid UTF-8\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(&cp, 0, sizeof(cp));\n\tstrncpy((char *) cp.name, maxname, sizeof(cp.name) - 1);\n\n\tDBG(\"sending set local name command for index %u\", adapter->dev_id);\n\n\tif (mgmt_send(adapter->mgmt, MGMT_OP_SET_LOCAL_NAME,\n\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\tset_local_name_complete, adapter, NULL) > 0)\n\t\treturn 0;\n\n\tbtd_error(adapter->dev_id, \"Failed to set local name for index %u\",\n\t\t\t\t\t\t\tadapter->dev_id);\n\n\treturn -EIO;\n}\n\nint adapter_set_name(struct btd_adapter *adapter, const char *name)\n{\n\tif (g_strcmp0(adapter->system_name, name) == 0)\n\t\treturn 0;\n\n\tDBG(\"name: %s\", name);\n\n\tg_free(adapter->system_name);\n\tadapter->system_name = g_strdup(name);\n\n\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\t\tADAPTER_INTERFACE, \"Name\");\n\n\t/* alias is preferred over system name */\n\tif (adapter->stored_alias)\n\t\treturn 0;\n\n\tDBG(\"alias: %s\", name);\n\n\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\t\tADAPTER_INTERFACE, \"Alias\");\n\n\treturn set_name(adapter, name);\n}\n\nstruct btd_device *btd_adapter_find_device(struct btd_adapter *adapter,\n\t\t\t\t\t\t\tconst bdaddr_t *dst,\n\t\t\t\t\t\t\tuint8_t bdaddr_type)\n{\n\tstruct device_addr_type addr;\n\tstruct btd_device *device;\n\tGSList *list;\n\n\tif (!adapter)\n\t\treturn NULL;\n\n\tbacpy(&addr.bdaddr, dst);\n\taddr.bdaddr_type = bdaddr_type;\n\n\tlist = g_slist_find_custom(adapter->devices, &addr,\n\t\t\t\t\t\t\tdevice_addr_type_cmp);\n\tif (!list)\n\t\treturn NULL;\n\n\tdevice = list->data;\n\n\t/*\n\t * If we're looking up based on public address and the address\n\t * was not previously used over this bearer we may need to\n\t * update LE or BR/EDR support information.\n\t */\n\tif (bdaddr_type == BDADDR_BREDR)\n\t\tdevice_set_bredr_support(device);\n\telse\n\t\tdevice_set_le_support(device, bdaddr_type);\n\n\treturn device;\n}\n\nstatic int device_path_cmp(gconstpointer a, gconstpointer b)\n{\n\tconst struct btd_device *device = a;\n\tconst char *path = b;\n\tconst char *dev_path = device_get_path(device);\n\n\treturn strcasecmp(dev_path, path);\n}\n\nstruct btd_device *btd_adapter_find_device_by_path(struct btd_adapter *adapter,\n\t\t\t\t\t\t   const char *path)\n{\n\tGSList *list;\n\n\tif (!adapter)\n\t\treturn NULL;\n\n\tlist = g_slist_find_custom(adapter->devices, path, device_path_cmp);\n\tif (!list)\n\t\treturn NULL;\n\n\treturn list->data;\n}\n\nstatic void uuid_to_uuid128(uuid_t *uuid128, const uuid_t *uuid)\n{\n\tif (uuid->type == SDP_UUID16)\n\t\tsdp_uuid16_to_uuid128(uuid128, uuid);\n\telse if (uuid->type == SDP_UUID32)\n\t\tsdp_uuid32_to_uuid128(uuid128, uuid);\n\telse\n\t\tmemcpy(uuid128, uuid, sizeof(*uuid));\n}\n\nstatic bool is_supported_uuid(const uuid_t *uuid)\n{\n\tuuid_t tmp;\n\n\t/* mgmt versions from 1.3 onwards support all types of UUIDs */\n\tif (MGMT_VERSION(mgmt_version, mgmt_revision) >= MGMT_VERSION(1, 3))\n\t\treturn true;\n\n\tuuid_to_uuid128(&tmp, uuid);\n\n\tif (!sdp_uuid128_to_uuid(&tmp))\n\t\treturn false;\n\n\tif (tmp.type != SDP_UUID16)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void add_uuid_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\tbtd_error(adapter->dev_id, \"Failed to add UUID: %s (0x%02x)\",\n\t\t\t\t\t\tmgmt_errstr(status), status);\n\t\treturn;\n\t}\n\n\t/*\n\t * The parameters are identical and also the task that is\n\t * required in both cases. So it is safe to just call the\n\t * event handling functions here.\n\t */\n\tdev_class_changed_callback(adapter->dev_id, length, param, adapter);\n\n\tif (adapter->initialized)\n\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\t\tADAPTER_INTERFACE, \"UUIDs\");\n}\n\nstatic int add_uuid(struct btd_adapter *adapter, uuid_t *uuid, uint8_t svc_hint)\n{\n\tstruct mgmt_cp_add_uuid cp;\n\tuuid_t uuid128;\n\tuint128_t uint128;\n\n\tif (!is_supported_uuid(uuid)) {\n\t\tbtd_warn(adapter->dev_id,\n\t\t\t\t\"Ignoring unsupported UUID for addition\");\n\t\treturn 0;\n\t}\n\n\tuuid_to_uuid128(&uuid128, uuid);\n\n\tntoh128((uint128_t *) uuid128.value.uuid128.data, &uint128);\n\thtob128(&uint128, (uint128_t *) cp.uuid);\n\tcp.svc_hint = svc_hint;\n\n\tDBG(\"sending add uuid command for index %u\", adapter->dev_id);\n\n\tif (mgmt_send(adapter->mgmt, MGMT_OP_ADD_UUID,\n\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\tadd_uuid_complete, adapter, NULL) > 0)\n\t\treturn 0;\n\n\tbtd_error(adapter->dev_id, \"Failed to add UUID for index %u\",\n\t\t\t\t\t\t\tadapter->dev_id);\n\n\treturn -EIO;\n}\n\nstatic void remove_uuid_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\tbtd_error(adapter->dev_id, \"Failed to remove UUID: %s (0x%02x)\",\n\t\t\t\t\t\tmgmt_errstr(status), status);\n\t\treturn;\n\t}\n\n\t/*\n\t * The parameters are identical and also the task that is\n\t * required in both cases. So it is safe to just call the\n\t * event handling functions here.\n\t */\n\tdev_class_changed_callback(adapter->dev_id, length, param, adapter);\n\n\tif (adapter->initialized)\n\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\t\tADAPTER_INTERFACE, \"UUIDs\");\n}\n\nstatic int remove_uuid(struct btd_adapter *adapter, uuid_t *uuid)\n{\n\tstruct mgmt_cp_remove_uuid cp;\n\tuuid_t uuid128;\n\tuint128_t uint128;\n\n\tif (!is_supported_uuid(uuid)) {\n\t\tbtd_warn(adapter->dev_id,\n\t\t\t\t\"Ignoring unsupported UUID for removal\");\n\t\treturn 0;\n\t}\n\n\tuuid_to_uuid128(&uuid128, uuid);\n\n\tntoh128((uint128_t *) uuid128.value.uuid128.data, &uint128);\n\thtob128(&uint128, (uint128_t *) cp.uuid);\n\n\tDBG(\"sending remove uuid command for index %u\", adapter->dev_id);\n\n\tif (mgmt_send(adapter->mgmt, MGMT_OP_REMOVE_UUID,\n\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\tremove_uuid_complete, adapter, NULL) > 0)\n\t\treturn 0;\n\n\tbtd_error(adapter->dev_id, \"Failed to remove UUID for index %u\",\n\t\t\t\t\t\t\tadapter->dev_id);\n\n\treturn -EIO;\n}\n\nstatic void clear_uuids_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\tbtd_error(adapter->dev_id, \"Failed to clear UUIDs: %s (0x%02x)\",\n\t\t\t\t\t\tmgmt_errstr(status), status);\n\t\treturn;\n\t}\n\n\t/*\n\t * The parameters are identical and also the task that is\n\t * required in both cases. So it is safe to just call the\n\t * event handling functions here.\n\t */\n\tdev_class_changed_callback(adapter->dev_id, length, param, adapter);\n}\n\nstatic int clear_uuids(struct btd_adapter *adapter)\n{\n\tstruct mgmt_cp_remove_uuid cp;\n\n\tmemset(&cp, 0, sizeof(cp));\n\n\tDBG(\"sending clear uuids command for index %u\", adapter->dev_id);\n\n\tif (mgmt_send(adapter->mgmt, MGMT_OP_REMOVE_UUID,\n\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\tclear_uuids_complete, adapter, NULL) > 0)\n\t\treturn 0;\n\n\tbtd_error(adapter->dev_id, \"Failed to clear UUIDs for index %u\",\n\t\t\t\t\t\t\tadapter->dev_id);\n\n\treturn -EIO;\n}\n\nstatic uint8_t get_uuid_mask(uuid_t *uuid)\n{\n\tif (uuid->type != SDP_UUID16)\n\t\treturn 0;\n\n\tswitch (uuid->value.uuid16) {\n\tcase DIALUP_NET_SVCLASS_ID:\n\tcase CIP_SVCLASS_ID:\n\t\treturn 0x42;\t/* Telephony & Networking */\n\tcase IRMC_SYNC_SVCLASS_ID:\n\tcase OBEX_OBJPUSH_SVCLASS_ID:\n\tcase OBEX_FILETRANS_SVCLASS_ID:\n\tcase IRMC_SYNC_CMD_SVCLASS_ID:\n\tcase PBAP_PSE_SVCLASS_ID:\n\t\treturn 0x10;\t/* Object Transfer */\n\tcase HEADSET_SVCLASS_ID:\n\tcase HANDSFREE_SVCLASS_ID:\n\t\treturn 0x20;\t/* Audio */\n\tcase CORDLESS_TELEPHONY_SVCLASS_ID:\n\tcase INTERCOM_SVCLASS_ID:\n\tcase FAX_SVCLASS_ID:\n\tcase SAP_SVCLASS_ID:\n\t/*\n\t * Setting the telephony bit for the handsfree audio gateway\n\t * role is not required by the HFP specification, but the\n\t * Nokia 616 carkit is just plain broken! It will refuse\n\t * pairing without this bit set.\n\t */\n\tcase HANDSFREE_AGW_SVCLASS_ID:\n\t\treturn 0x40;\t/* Telephony */\n\tcase AUDIO_SOURCE_SVCLASS_ID:\n\tcase VIDEO_SOURCE_SVCLASS_ID:\n\t\treturn 0x08;\t/* Capturing */\n\tcase AUDIO_SINK_SVCLASS_ID:\n\tcase VIDEO_SINK_SVCLASS_ID:\n\t\treturn 0x04;\t/* Rendering */\n\tcase PANU_SVCLASS_ID:\n\tcase NAP_SVCLASS_ID:\n\tcase GN_SVCLASS_ID:\n\t\treturn 0x02;\t/* Networking */\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int uuid_cmp(const void *a, const void *b)\n{\n\tconst sdp_record_t *rec = a;\n\tconst uuid_t *uuid = b;\n\n\treturn sdp_uuid_cmp(&rec->svclass, uuid);\n}\n\nstatic void adapter_service_insert(struct btd_adapter *adapter, sdp_record_t *rec)\n{\n\tsdp_list_t *browse_list = NULL;\n\tuuid_t browse_uuid;\n\tgboolean new_uuid;\n\n\tDBG(\"%s\", adapter->path);\n\n\t/* skip record without a browse group */\n\tif (sdp_get_browse_groups(rec, &browse_list) < 0) {\n\t\tDBG(\"skipping record without browse group\");\n\t\treturn;\n\t}\n\n\tsdp_uuid16_create(&browse_uuid, PUBLIC_BROWSE_GROUP);\n\n\t/* skip record without public browse group */\n\tif (!sdp_list_find(browse_list, &browse_uuid, sdp_uuid_cmp))\n\t\tgoto done;\n\n\tif (sdp_list_find(adapter->services, &rec->svclass, uuid_cmp) == NULL)\n\t\tnew_uuid = TRUE;\n\telse\n\t\tnew_uuid = FALSE;\n\n\tadapter->services = sdp_list_insert_sorted(adapter->services, rec,\n\t\t\t\t\t\t\t\trecord_sort);\n\n\tif (new_uuid) {\n\t\tuint8_t svc_hint = get_uuid_mask(&rec->svclass);\n\t\tadd_uuid(adapter, &rec->svclass, svc_hint);\n\t}\n\ndone:\n\tsdp_list_free(browse_list, free);\n}\n\nint adapter_service_add(struct btd_adapter *adapter, sdp_record_t *rec)\n{\n\tint ret;\n\n\tDBG(\"%s\", adapter->path);\n\n\tret = add_record_to_server(&adapter->bdaddr, rec);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tadapter_service_insert(adapter, rec);\n\n\treturn 0;\n}\n\nvoid adapter_service_remove(struct btd_adapter *adapter, uint32_t handle)\n{\n\tsdp_record_t *rec = sdp_record_find(handle);\n\n\tDBG(\"%s\", adapter->path);\n\n\tif (!rec)\n\t\treturn;\n\n\tadapter->services = sdp_list_remove(adapter->services, rec);\n\n\tif (sdp_list_find(adapter->services, &rec->svclass, uuid_cmp) == NULL)\n\t\tremove_uuid(adapter, &rec->svclass);\n\n\tremove_record_from_server(rec->handle);\n}\n\nstatic struct btd_device *adapter_create_device(struct btd_adapter *adapter,\n\t\t\t\t\t\tconst bdaddr_t *bdaddr,\n\t\t\t\t\t\tuint8_t bdaddr_type)\n{\n\tstruct btd_device *device;\n\n\tdevice = device_create(adapter, bdaddr, bdaddr_type);\n\tif (!device)\n\t\treturn NULL;\n\n\tadapter->devices = g_slist_append(adapter->devices, device);\n\n\treturn device;\n}\n\nstatic void service_auth_cancel(struct service_auth *auth)\n{\n\tDBusError derr;\n\n\tif (auth->svc_id > 0)\n\t\tdevice_remove_svc_complete_callback(auth->device,\n\t\t\t\t\t\t\t\tauth->svc_id);\n\n\tdbus_error_init(&derr);\n\tdbus_set_error_const(&derr, ERROR_INTERFACE \".Canceled\", NULL);\n\n\tauth->cb(&derr, auth->user_data);\n\n\tdbus_error_free(&derr);\n\n\tif (auth->agent != NULL) {\n\t\tagent_cancel(auth->agent);\n\t\tagent_unref(auth->agent);\n\t}\n\n\tg_free(auth);\n}\n\nvoid btd_adapter_remove_device(struct btd_adapter *adapter,\n\t\t\t\tstruct btd_device *dev)\n{\n\tGList *l;\n\n\tadapter->connect_list = g_slist_remove(adapter->connect_list, dev);\n\n\tadapter->devices = g_slist_remove(adapter->devices, dev);\n\tbtd_adv_monitor_device_remove(adapter->adv_monitor_manager, dev);\n\n\tadapter->discovery_found = g_slist_remove(adapter->discovery_found,\n\t\t\t\t\t\t\t\t\tdev);\n\n\tadapter->connections = g_slist_remove(adapter->connections, dev);\n\n\tif (adapter->connect_le == dev)\n\t\tadapter->connect_le = NULL;\n\n\tl = adapter->auths->head;\n\twhile (l != NULL) {\n\t\tstruct service_auth *auth = l->data;\n\t\tGList *next = g_list_next(l);\n\n\t\tif (auth->device != dev) {\n\t\t\tl = next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tg_queue_delete_link(adapter->auths, l);\n\t\tl = next;\n\n\t\tservice_auth_cancel(auth);\n\t}\n\n\tdevice_remove(dev, TRUE);\n}\n\nstruct btd_device *btd_adapter_get_device(struct btd_adapter *adapter,\n\t\t\t\t\tconst bdaddr_t *addr,\n\t\t\t\t\tuint8_t addr_type)\n{\n\tstruct btd_device *device;\n\n\tif (!adapter)\n\t\treturn NULL;\n\n\tdevice = btd_adapter_find_device(adapter, addr, addr_type);\n\tif (device)\n\t\treturn device;\n\n\treturn adapter_create_device(adapter, addr, addr_type);\n}\n\nsdp_list_t *btd_adapter_get_services(struct btd_adapter *adapter)\n{\n\treturn adapter->services;\n}\n\nstatic void passive_scanning_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tconst struct mgmt_cp_start_discovery *rp = param;\n\n\tDBG(\"status 0x%02x\", status);\n\n\tif (length < sizeof(*rp)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\"Wrong size of start scanning return parameters\");\n\t\treturn;\n\t}\n\n\tif (status == MGMT_STATUS_SUCCESS) {\n\t\tadapter->discovery_type = rp->type;\n\t\tadapter->discovery_enable = 0x01;\n\t}\n}\n\nstatic bool passive_scanning_timeout(gpointer user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tstruct mgmt_cp_start_discovery cp;\n\n\tadapter->passive_scan_timeout = 0;\n\n\tcp.type = SCAN_TYPE_LE;\n\n\tmgmt_send(adapter->mgmt, MGMT_OP_START_DISCOVERY,\n\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\tpassive_scanning_complete, adapter, NULL);\n\n\treturn FALSE;\n}\n\nstatic void trigger_passive_scanning(struct btd_adapter *adapter)\n{\n\tif (!(adapter->current_settings & MGMT_SETTING_LE))\n\t\treturn;\n\n\tDBG(\"\");\n\n\tif (adapter->passive_scan_timeout > 0) {\n\t\ttimeout_remove(adapter->passive_scan_timeout);\n\t\tadapter->passive_scan_timeout = 0;\n\t}\n\n\t/*\n\t * When the kernel background scanning is available, there is\n\t * no need to start any discovery. The kernel will keep scanning\n\t * as long as devices are in its auto-connection list.\n\t */\n\tif (btd_has_kernel_features(KERNEL_CONN_CONTROL))\n\t\treturn;\n\n\t/*\n\t * If any client is running a discovery right now, then do not\n\t * even try to start passive scanning.\n\t *\n\t * The discovery procedure is using interleaved scanning and\n\t * thus will discover Low Energy devices as well.\n\t */\n\tif (adapter->discovery_list)\n\t\treturn;\n\n\tif (adapter->discovery_enable == 0x01)\n\t\treturn;\n\n\t/*\n\t * In case the discovery is suspended (for example for an ongoing\n\t * pairing attempt), then also do not start passive scanning.\n\t */\n\tif (adapter->discovery_suspended)\n\t\treturn;\n\n\t/*\n\t * If the list of connectable Low Energy devices is empty,\n\t * then do not start passive scanning.\n\t */\n\tif (!adapter->connect_list)\n\t\treturn;\n\n\tadapter->passive_scan_timeout = timeout_add_seconds(CONN_SCAN_TIMEOUT,\n\t\t\t\t\tpassive_scanning_timeout, adapter,\n\t\t\t\t\tNULL);\n}\n\nstatic void stop_passive_scanning_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tstruct btd_device *dev;\n\tint err;\n\n\tDBG(\"status 0x%02x (%s)\", status, mgmt_errstr(status));\n\n\tdev = adapter->connect_le;\n\tadapter->connect_le = NULL;\n\n\t/*\n\t * When the kernel background scanning is available, there is\n\t * no need to stop any discovery. The kernel will handle the\n\t * auto-connection by itself.\n\t */\n\tif (btd_has_kernel_features(KERNEL_CONN_CONTROL))\n\t\treturn;\n\n\t/*\n\t * MGMT_STATUS_REJECTED may be returned from kernel because the passive\n\t * scan timer had expired in kernel and passive scan was disabled just\n\t * around the time we called stop_passive_scanning().\n\t */\n\tif (status != MGMT_STATUS_SUCCESS && status != MGMT_STATUS_REJECTED) {\n\t\tbtd_error(adapter->dev_id, \"Stopping passive scanning failed: %s\",\n\t\t\t\t\t\t\tmgmt_errstr(status));\n\t\treturn;\n\t}\n\n\tadapter->discovery_type = 0x00;\n\tadapter->discovery_enable = 0x00;\n\n\tif (!dev) {\n\t\tDBG(\"Device removed while stopping passive scanning\");\n\t\ttrigger_passive_scanning(adapter);\n\t\treturn;\n\t}\n\n\terr = device_connect_le(dev);\n\tif (err < 0) {\n\t\tbtd_error(adapter->dev_id, \"LE auto connection failed: %s (%d)\",\n\t\t\t\t\t\t\tstrerror(-err), -err);\n\t\ttrigger_passive_scanning(adapter);\n\t}\n}\n\nstatic void stop_passive_scanning(struct btd_adapter *adapter)\n{\n\tstruct mgmt_cp_stop_discovery cp;\n\n\tDBG(\"\");\n\n\t/* If there are any normal discovery clients passive scanning\n\t * wont be running */\n\tif (adapter->discovery_list)\n\t\treturn;\n\n\tif (adapter->discovery_enable == 0x00)\n\t\treturn;\n\n\tcp.type = adapter->discovery_type;\n\n\tmgmt_send(adapter->mgmt, MGMT_OP_STOP_DISCOVERY,\n\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\tstop_passive_scanning_complete, adapter, NULL);\n}\n\nstatic void cancel_passive_scanning(struct btd_adapter *adapter)\n{\n\tif (!(adapter->current_settings & MGMT_SETTING_LE))\n\t\treturn;\n\n\tDBG(\"\");\n\n\tif (adapter->passive_scan_timeout > 0) {\n\t\ttimeout_remove(adapter->passive_scan_timeout);\n\t\tadapter->passive_scan_timeout = 0;\n\t}\n}\n\nstatic uint8_t get_scan_type(struct btd_adapter *adapter)\n{\n\tuint8_t type;\n\n\tif (adapter->current_settings & MGMT_SETTING_BREDR)\n\t\ttype = SCAN_TYPE_BREDR;\n\telse\n\t\ttype = 0;\n\n\tif (adapter->current_settings & MGMT_SETTING_LE)\n\t\ttype |= SCAN_TYPE_LE;\n\n\treturn type;\n}\n\nstatic void free_discovery_filter(struct discovery_filter *discovery_filter)\n{\n\tif (!discovery_filter)\n\t\treturn;\n\n\tg_slist_free_full(discovery_filter->uuids, free);\n\tfree(discovery_filter->pattern);\n\tg_free(discovery_filter);\n}\n\nstatic void invalidate_rssi_and_tx_power(gpointer a)\n{\n\tstruct btd_device *dev = a;\n\n\tdevice_set_rssi(dev, 0);\n\tdevice_set_tx_power(dev, 127);\n}\n\nstatic void discovery_cleanup(struct btd_adapter *adapter, int timeout)\n{\n\tGSList *l, *next;\n\n\tadapter->discovery_type = 0x00;\n\n\tif (adapter->discovery_idle_timeout > 0) {\n\t\ttimeout_remove(adapter->discovery_idle_timeout);\n\t\tadapter->discovery_idle_timeout = 0;\n\t}\n\n\tg_slist_free_full(adapter->discovery_found,\n\t\t\t\t\t\tinvalidate_rssi_and_tx_power);\n\tadapter->discovery_found = NULL;\n\n\tif (!adapter->devices)\n\t\treturn;\n\n\tfor (l = adapter->devices; l != NULL; l = next) {\n\t\tstruct btd_device *dev = l->data;\n\n\t\tnext = g_slist_next(l);\n\n\t\tif (device_is_temporary(dev) && !device_is_connectable(dev))\n\t\t\tbtd_adapter_remove_device(adapter, dev);\n\t}\n}\n\nstatic void discovery_free(void *user_data)\n{\n\tstruct discovery_client *client = user_data;\n\tstruct btd_adapter *adapter = client->adapter;\n\n\tDBG(\"%p\", client);\n\n\tif (client->watch)\n\t\tg_dbus_remove_watch(dbus_conn, client->watch);\n\n\tif (client->discovery_filter) {\n\t\tfree_discovery_filter(client->discovery_filter);\n\t\tclient->discovery_filter = NULL;\n\t}\n\n\tif (client->msg) {\n\t\tif (client == adapter->client) {\n\t\t\tg_dbus_send_message(dbus_conn,\n\t\t\t\t\t\tbtd_error_busy(client->msg));\n\t\t\tadapter->client = NULL;\n\t\t}\n\t\tdbus_message_unref(client->msg);\n\t}\n\n\tg_free(client->owner);\n\tg_free(client);\n}\n\nstatic void discovery_remove(struct discovery_client *client)\n{\n\tstruct btd_adapter *adapter = client->adapter;\n\n\tDBG(\"owner %s\", client->owner);\n\n\tadapter->set_filter_list = g_slist_remove(adapter->set_filter_list,\n\t\t\t\t\t\t\t\tclient);\n\n\tadapter->discovery_list = g_slist_remove(adapter->discovery_list,\n\t\t\t\t\t\t\t\tclient);\n\n\tif (adapter->client == client)\n\t\tadapter->client = NULL;\n\n\tif (client->watch && client->discovery_filter)\n\t\tadapter->set_filter_list = g_slist_prepend(\n\t\t\t\t\tadapter->set_filter_list, client);\n\telse\n\t\tdiscovery_free(client);\n\n\t/*\n\t * If there are other client discoveries in progress, then leave\n\t * it active. If not, then make sure to stop the restart timeout.\n\t */\n\tif (adapter->discovery_list)\n\t\treturn;\n\n\tdiscovery_cleanup(adapter, TEMP_DEV_TIMEOUT);\n}\n\nstatic void trigger_start_discovery(struct btd_adapter *adapter, guint delay);\n\nstatic struct discovery_client *discovery_complete(struct btd_adapter *adapter,\n\t\t\t\t\t\tuint8_t status)\n{\n\tstruct discovery_client *client = adapter->client;\n\tDBusMessage *reply;\n\n\tif (!client)\n\t\treturn NULL;\n\n\tadapter->client = NULL;\n\n\tif (!client->msg)\n\t\treturn client;\n\n\tif (!status) {\n\t\tg_dbus_send_reply(dbus_conn, client->msg, DBUS_TYPE_INVALID);\n\t} else  {\n\t\treply = btd_error_busy(client->msg);\n\t\tg_dbus_send_message(dbus_conn, reply);\n\t}\n\n\tdbus_message_unref(client->msg);\n\tclient->msg = NULL;\n\n\treturn client;\n}\n\nstatic void start_discovery_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tstruct discovery_client *client;\n\tconst struct mgmt_cp_start_discovery *rp = param;\n\n\tDBG(\"status 0x%02x\", status);\n\n\t/* Is there are no clients the discovery must have been stopped while\n\t * discovery command was pending.\n\t */\n\tif (!adapter->discovery_list) {\n\t\tstruct mgmt_cp_stop_discovery cp;\n\n\t\tif (status != MGMT_STATUS_SUCCESS)\n\t\t\treturn;\n\n\t\t/* Stop discovering as there are no clients left */\n\t\tcp.type = rp->type;\n\t\tmgmt_send(adapter->mgmt, MGMT_OP_STOP_DISCOVERY,\n\t\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\t\tNULL, NULL, NULL);\n\t\treturn;\n\t}\n\n\tif (length < sizeof(*rp)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\"Wrong size of start discovery return parameters\");\n\t\tdiscovery_complete(adapter, MGMT_STATUS_FAILED);\n\t\treturn;\n\t}\n\n\tif (status == MGMT_STATUS_SUCCESS) {\n\t\tadapter->discovery_type = rp->type;\n\t\tadapter->discovery_enable = 0x01;\n\n\t\tif (adapter->current_discovery_filter)\n\t\t\tadapter->filtered_discovery = true;\n\t\telse\n\t\t\tadapter->filtered_discovery = false;\n\n\t\tdiscovery_complete(adapter, status);\n\n\t\tif (adapter->discovering)\n\t\t\treturn;\n\n\t\tadapter->discovering = true;\n\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Discovering\");\n\t\treturn;\n\t}\n\n\t/* Reply with an error if the first discovery has failed */\n\tclient = discovery_complete(adapter, status);\n\tif (client) {\n\t\tdiscovery_remove(client);\n\t\treturn;\n\t}\n\n\t/*\n\t * In case the restart of the discovery failed, then just trigger\n\t * it for the next idle timeout again.\n\t */\n\ttrigger_start_discovery(adapter, IDLE_DISCOV_TIMEOUT * 2);\n}\n\nstatic bool start_discovery_timeout(gpointer user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tstruct mgmt_cp_start_service_discovery *sd_cp;\n\tuint8_t new_type;\n\n\tDBG(\"\");\n\n\tadapter->discovery_idle_timeout = 0;\n\n\t/* If we're doing filtered discovery, it must be quickly restarted */\n\tadapter->no_scan_restart_delay = !!adapter->current_discovery_filter;\n\n\tDBG(\"adapter->current_discovery_filter == %d\",\n\t    !!adapter->current_discovery_filter);\n\n\tnew_type = get_scan_type(adapter);\n\n\tif (adapter->discovery_enable == 0x01) {\n\t\tstruct mgmt_cp_stop_discovery cp;\n\n\t\t/*\n\t\t * If we're asked to start regular discovery, and there is an\n\t\t * already running regular discovery and it has the same type,\n\t\t * then just keep it.\n\t\t */\n\t\tif (!adapter->current_discovery_filter &&\n\t\t    !adapter->filtered_discovery &&\n\t\t    adapter->discovery_type == new_type) {\n\t\t\tif (adapter->discovering)\n\t\t\t\treturn FALSE;\n\n\t\t\tadapter->discovering = true;\n\t\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Discovering\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\t/*\n\t\t * Otherwise the current discovery must be stopped. So\n\t\t * queue up a stop discovery command.\n\t\t *\n\t\t * This can happen if a passive scanning for Low Energy\n\t\t * devices is ongoing, or scan type is changed between\n\t\t * regular and filtered, or filter was updated.\n\t\t */\n\t\tcp.type = adapter->discovery_type;\n\t\tmgmt_send(adapter->mgmt, MGMT_OP_STOP_DISCOVERY,\n\t\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\t\tNULL, NULL, NULL);\n\n\t\t/* Don't even bother to try to quickly start discovery\n\t\t * just after stopping it, it would fail with status\n\t\t * MGMT_BUSY. Instead discovering_callback will take\n\t\t * care of that.\n\t\t */\n\t\treturn FALSE;\n\n\t}\n\n\t/* Regular discovery is required */\n\tif (!adapter->current_discovery_filter) {\n\t\tstruct mgmt_cp_start_discovery cp;\n\n\t\tcp.type = new_type;\n\t\tmgmt_send(adapter->mgmt, MGMT_OP_START_DISCOVERY,\n\t\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\t\tstart_discovery_complete, adapter,\n\t\t\t\t\tNULL);\n\n\t\treturn FALSE;\n\t}\n\n\t/* Filtered discovery is required */\n\tsd_cp = adapter->current_discovery_filter;\n\n\tDBG(\"sending MGMT_OP_START_SERVICE_DISCOVERY %d, %d, %d\",\n\t\t\t\tsd_cp->rssi, sd_cp->type,\n\t\t\t\tbtohs(sd_cp->uuid_count));\n\n\tmgmt_send(adapter->mgmt, MGMT_OP_START_SERVICE_DISCOVERY,\n\t\t  adapter->dev_id, sizeof(*sd_cp) +\n\t\t  btohs(sd_cp->uuid_count) * 16,\n\t\t  sd_cp, start_discovery_complete, adapter, NULL);\n\n\treturn FALSE;\n}\n\nstatic void trigger_start_discovery(struct btd_adapter *adapter, guint delay)\n{\n\n\tDBG(\"\");\n\n\tcancel_passive_scanning(adapter);\n\n\tif (adapter->discovery_idle_timeout > 0) {\n\t\ttimeout_remove(adapter->discovery_idle_timeout);\n\t\tadapter->discovery_idle_timeout = 0;\n\t}\n\n\t/*\n\t * If the controller got powered down in between, then ensure\n\t * that we do not keep trying to restart discovery.\n\t *\n\t * This is safe-guard and should actually never trigger.\n\t */\n\tif (!btd_adapter_get_powered(adapter))\n\t\treturn;\n\n\tadapter->discovery_idle_timeout = timeout_add_seconds(delay,\n\t\t\t\t\tstart_discovery_timeout, adapter, NULL);\n}\n\nstatic void suspend_discovery_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\tDBG(\"status 0x%02x\", status);\n\n\tif (status == MGMT_STATUS_SUCCESS) {\n\t\tadapter->discovery_type = 0x00;\n\t\tadapter->discovery_enable = 0x00;\n\t\treturn;\n\t}\n}\n\nstatic void suspend_discovery(struct btd_adapter *adapter)\n{\n\tstruct mgmt_cp_stop_discovery cp;\n\n\tDBG(\"\");\n\n\tadapter->discovery_suspended = true;\n\n\t/*\n\t * If there are no clients discovering right now, then there is\n\t * also nothing to suspend.\n\t */\n\tif (!adapter->discovery_list)\n\t\treturn;\n\n\t/*\n\t * In case of being inside the idle phase, make sure to remove\n\t * the timeout to not trigger a restart.\n\t *\n\t * The restart will be triggered when the discovery is resumed.\n\t */\n\tif (adapter->discovery_idle_timeout > 0) {\n\t\ttimeout_remove(adapter->discovery_idle_timeout);\n\t\tadapter->discovery_idle_timeout = 0;\n\t}\n\n\tif (adapter->discovery_enable == 0x00)\n\t\treturn;\n\n\tcp.type = adapter->discovery_type;\n\n\tmgmt_send(adapter->mgmt, MGMT_OP_STOP_DISCOVERY,\n\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\tsuspend_discovery_complete, adapter, NULL);\n}\n\nstatic void resume_discovery(struct btd_adapter *adapter)\n{\n\tDBG(\"\");\n\n\tadapter->discovery_suspended = false;\n\n\t/*\n\t * If there are no clients discovering right now, then there is\n\t * also nothing to resume.\n\t */\n\tif (!adapter->discovery_list)\n\t\treturn;\n\n\t/*\n\t * Treat a suspended discovery session the same as extra long\n\t * idle time for a normal discovery. So just trigger the default\n\t * restart procedure.\n\t */\n\ttrigger_start_discovery(adapter, IDLE_DISCOV_TIMEOUT);\n}\n\nstatic void discovering_callback(uint16_t index, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_ev_discovering *ev = param;\n\tstruct btd_adapter *adapter = user_data;\n\n\tif (length < sizeof(*ev)) {\n\t\tbtd_error(adapter->dev_id, \"Too small discovering event\");\n\t\treturn;\n\t}\n\n\tDBG(\"hci%u type %u discovering %u method %d\", adapter->dev_id, ev->type,\n\t\t\t\tev->discovering, adapter->filtered_discovery);\n\n\tif (adapter->discovery_enable == ev->discovering)\n\t\treturn;\n\n\tadapter->discovery_type = ev->type;\n\tadapter->discovery_enable = ev->discovering;\n\n\t/*\n\t * Check for existing discoveries triggered by client applications\n\t * and ignore all others.\n\t *\n\t * If there are no clients, then it is good idea to trigger a\n\t * passive scanning attempt.\n\t */\n\tif (!adapter->discovery_list) {\n\t\tif (!adapter->connect_le)\n\t\t\ttrigger_passive_scanning(adapter);\n\t\treturn;\n\t}\n\n\tif (adapter->discovery_suspended)\n\t\treturn;\n\n\tswitch (adapter->discovery_enable) {\n\tcase 0x00:\n\t\tif (adapter->no_scan_restart_delay)\n\t\t\ttrigger_start_discovery(adapter, 0);\n\t\telse\n\t\t\ttrigger_start_discovery(adapter, IDLE_DISCOV_TIMEOUT);\n\t\tbreak;\n\n\tcase 0x01:\n\t\tif (adapter->discovery_idle_timeout > 0) {\n\t\t\ttimeout_remove(adapter->discovery_idle_timeout);\n\t\t\tadapter->discovery_idle_timeout = 0;\n\t\t}\n\n\t\tbreak;\n\t}\n}\n\nstatic bool set_discovery_discoverable(struct btd_adapter *adapter, bool enable)\n{\n\tif (adapter->discovery_discoverable == enable)\n\t\treturn true;\n\n\t/* Reset discoverable filter if already set */\n\tif (enable && (adapter->current_settings & MGMT_OP_SET_DISCOVERABLE))\n\t\treturn true;\n\n\tadapter->discovery_discoverable = enable;\n\n\treturn set_discoverable(adapter, enable, 0);\n}\n\nstatic void stop_discovery_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tstruct discovery_client *client;\n\n\tDBG(\"status 0x%02x\", status);\n\n\tclient = discovery_complete(adapter, status);\n\tif (client)\n\t\tdiscovery_remove(client);\n\n\tif (status != MGMT_STATUS_SUCCESS)\n\t\treturn;\n\n\tadapter->discovery_type = 0x00;\n\tadapter->discovery_enable = 0x00;\n\tadapter->filtered_discovery = false;\n\tadapter->no_scan_restart_delay = false;\n\tadapter->discovering = false;\n\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Discovering\");\n\n\ttrigger_passive_scanning(adapter);\n}\n\nstatic int compare_sender(gconstpointer a, gconstpointer b)\n{\n\tconst struct discovery_client *client = a;\n\tconst char *sender = b;\n\n\treturn g_strcmp0(client->owner, sender);\n}\n\nstatic gint g_strcmp(gconstpointer a, gconstpointer b)\n{\n\treturn strcmp(a, b);\n}\n\nstatic void extract_unique_uuids(gpointer data, gpointer user_data)\n{\n\tchar *uuid_str = data;\n\tGSList **uuids = user_data;\n\n\tif (!g_slist_find_custom(*uuids, uuid_str, g_strcmp))\n\t\t*uuids = g_slist_insert_sorted(*uuids, uuid_str, g_strcmp);\n}\n\n/*\n * This method merges all adapter filters into rssi, transport and uuids.\n * Returns 1 if there was no filtered scan, 0 otherwise.\n */\nstatic int merge_discovery_filters(struct btd_adapter *adapter, int *rssi,\n\t\t\t\t\tuint8_t *transport, GSList **uuids)\n{\n\tGSList *l;\n\tbool empty_uuid = false;\n\tbool has_regular_discovery = false;\n\tbool has_filtered_discovery = false;\n\n\tfor (l = adapter->discovery_list; l != NULL; l = g_slist_next(l)) {\n\t\tstruct discovery_client *client = l->data;\n\t\tstruct discovery_filter *item = client->discovery_filter;\n\n\t\tif (!item) {\n\t\t\thas_regular_discovery = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\thas_filtered_discovery = true;\n\n\t\t*transport |= item->type;\n\n\t\t/*\n\t\t * Rule for merging rssi and pathloss into rssi field of kernel\n\t\t * filter is as follow:\n\t\t * - if there's any client without proximity filter, then do no\n\t\t *   proximity filtering,\n\t\t * - if all clients specified RSSI, then use lowest value,\n\t\t * - if any client specified pathloss, then kernel filter should\n\t\t *   do no proximity, as kernel can't compute pathloss. We'll do\n\t\t *   filtering on our own.\n\t\t */\n\t\tif (item->rssi == DISTANCE_VAL_INVALID)\n\t\t\t*rssi = HCI_RSSI_INVALID;\n\t\telse if (*rssi != HCI_RSSI_INVALID && *rssi >= item->rssi)\n\t\t\t*rssi = item->rssi;\n\t\telse if (item->pathloss != DISTANCE_VAL_INVALID)\n\t\t\t*rssi = HCI_RSSI_INVALID;\n\n\t\tif (!g_slist_length(item->uuids))\n\t\t\tempty_uuid = true;\n\n\t\tg_slist_foreach(item->uuids, extract_unique_uuids, uuids);\n\t}\n\n\t/* If no proximity filtering is set, disable it */\n\tif (*rssi == DISTANCE_VAL_INVALID)\n\t\t*rssi = HCI_RSSI_INVALID;\n\n\t/*\n\t * Empty_uuid variable determines wether there was any filter with no\n\t * uuids. In this case someone might be looking for all devices in\n\t * certain proximity, and we need to have empty uuids in kernel filter.\n\t */\n\tif (empty_uuid) {\n\t\tg_slist_free(*uuids);\n\t\t*uuids = NULL;\n\t}\n\n\tif (has_regular_discovery) {\n\t\tif (!has_filtered_discovery)\n\t\t\treturn 1;\n\n\t\t/*\n\t\t * It there is both regular and filtered scan running, then\n\t\t * clear whole fitler to report all devices.\n\t\t */\n\t\t*transport = get_scan_type(adapter);\n\t\t*rssi = HCI_RSSI_INVALID;\n\t\tg_slist_free(*uuids);\n\t\t*uuids = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic void populate_mgmt_filter_uuids(uint8_t (*mgmt_uuids)[16], GSList *uuids)\n{\n\tGSList *l;\n\n\tfor (l = uuids; l != NULL; l = g_slist_next(l)) {\n\t\tbt_uuid_t uuid, u128;\n\t\tuint128_t uint128;\n\n\t\tbt_string_to_uuid(&uuid, l->data);\n\t\tbt_uuid_to_uuid128(&uuid, &u128);\n\n\t\tntoh128((uint128_t *) u128.value.u128.data, &uint128);\n\t\thtob128(&uint128, (uint128_t *) mgmt_uuids);\n\n\t\tmgmt_uuids++;\n\t}\n}\n\n/*\n * This method merges all adapter filters into one that will be send to kernel.\n * cp_ptr is set to null when regular non-filtered discovery is needed,\n * otherwise it's pointing to filter. Returns 0 on succes, -1 on error\n */\nstatic int discovery_filter_to_mgmt_cp(struct btd_adapter *adapter,\n\t\t       struct mgmt_cp_start_service_discovery **cp_ptr)\n{\n\tGSList *uuids = NULL;\n\tstruct mgmt_cp_start_service_discovery *cp;\n\tint rssi = DISTANCE_VAL_INVALID;\n\tint uuid_count;\n\tuint8_t discovery_type = 0;\n\n\tDBG(\"\");\n\n\tif (merge_discovery_filters(adapter, &rssi, &discovery_type, &uuids)) {\n\t\t/* There are only regular scans, run just regular scan. */\n\t\t*cp_ptr = NULL;\n\t\treturn 0;\n\t}\n\n\tuuid_count = g_slist_length(uuids);\n\n\tcp = g_try_malloc(sizeof(*cp) + 16*uuid_count);\n\t*cp_ptr = cp;\n\tif (!cp) {\n\t\tg_slist_free(uuids);\n\t\treturn -1;\n\t}\n\n\tcp->type = discovery_type;\n\tcp->rssi = rssi;\n\tcp->uuid_count = htobs(uuid_count);\n\tpopulate_mgmt_filter_uuids(cp->uuids, uuids);\n\n\tg_slist_free(uuids);\n\treturn 0;\n}\n\nstatic bool filters_equal(struct mgmt_cp_start_service_discovery *a,\n\t\t   struct mgmt_cp_start_service_discovery *b) {\n\tif (!a && !b)\n\t\treturn true;\n\n\tif ((!a && b) || (a && !b))\n\t\treturn false;\n\n\tif (a->type != b->type)\n\t\treturn false;\n\n\tif (a->rssi != b->rssi)\n\t\treturn false;\n\n\t/*\n\t * When we create mgmt_cp_start_service_discovery structure inside\n\t * discovery_filter_to_mgmt_cp, we always keep uuids sorted, and\n\t * unique, so we're safe to compare uuid_count, and uuids like that.\n\t */\n\tif (a->uuid_count != b->uuid_count)\n\t\treturn false;\n\n\tif (memcmp(a->uuids, b->uuids, 16 * a->uuid_count) != 0)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int update_discovery_filter(struct btd_adapter *adapter)\n{\n\tstruct mgmt_cp_start_service_discovery *sd_cp;\n\n\tDBG(\"\");\n\n\tif (discovery_filter_to_mgmt_cp(adapter, &sd_cp)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"discovery_filter_to_mgmt_cp returned error\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Only attempt to overwrite current discoverable setting when not\n\t * discoverable.\n\t */\n\tif (!(adapter->current_settings & MGMT_OP_SET_DISCOVERABLE)) {\n\t\tGSList *l;\n\n\t\tfor (l = adapter->discovery_list; l; l = g_slist_next(l)) {\n\t\t\tstruct discovery_client *client = l->data;\n\n\t\t\tif (!client->discovery_filter)\n\t\t\t\tcontinue;\n\n\t\t\tif (client->discovery_filter->discoverable) {\n\t\t\t\tset_discovery_discoverable(adapter, true);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * If filters are equal, then don't update scan, except for when\n\t * starting discovery.\n\t */\n\tif (filters_equal(adapter->current_discovery_filter, sd_cp) &&\n\t    adapter->discovering != 0) {\n\t\tDBG(\"filters were equal, deciding to not restart the scan.\");\n\t\tg_free(sd_cp);\n\t\treturn 0;\n\t}\n\n\tg_free(adapter->current_discovery_filter);\n\tadapter->current_discovery_filter = sd_cp;\n\n\ttrigger_start_discovery(adapter, 0);\n\n\treturn -EINPROGRESS;\n}\n\nstatic int discovery_stop(struct discovery_client *client)\n{\n\tstruct btd_adapter *adapter = client->adapter;\n\tstruct mgmt_cp_stop_discovery cp;\n\n\t/* Check if there are more client discovering */\n\tif (g_slist_next(adapter->discovery_list)) {\n\t\tdiscovery_remove(client);\n\t\tupdate_discovery_filter(adapter);\n\t\treturn 0;\n\t}\n\n\tset_discovery_discoverable(adapter, false);\n\n\t/*\n\t * In the idle phase of a discovery, there is no need to stop it\n\t * and so it is enough to send out the signal and just return.\n\t */\n\tif (adapter->discovery_enable == 0x00) {\n\t\tdiscovery_remove(client);\n\t\tadapter->discovering = false;\n\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Discovering\");\n\n\t\ttrigger_passive_scanning(adapter);\n\n\t\treturn 0;\n\t}\n\n\tcp.type = adapter->discovery_type;\n\tadapter->client = client;\n\n\tmgmt_send(adapter->mgmt, MGMT_OP_STOP_DISCOVERY,\n\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\tstop_discovery_complete, adapter, NULL);\n\n\treturn -EINPROGRESS;\n}\n\nstatic void discovery_disconnect(DBusConnection *conn, void *user_data)\n{\n\tstruct discovery_client *client = user_data;\n\n\tDBG(\"owner %s\", client->owner);\n\n\tclient->watch = 0;\n\n\tdiscovery_stop(client);\n}\n\n/*\n * Returns true if client was already discovering, false otherwise. *client\n * will point to discovering client, or client that have pre-set his filter.\n */\nstatic bool get_discovery_client(struct btd_adapter *adapter, const char *owner,\n\t\t\t\tstruct discovery_client **client)\n{\n\tGSList *list = g_slist_find_custom(adapter->discovery_list, owner,\n\t\t\t\t\t\t\t\tcompare_sender);\n\tif (list) {\n\t\t*client = list->data;\n\t\treturn true;\n\t}\n\n\tlist = g_slist_find_custom(adapter->set_filter_list, owner,\n\t\t\t\t\t\t\t\tcompare_sender);\n\tif (list) {\n\t\t*client = list->data;\n\t\treturn false;\n\t}\n\n\t*client = NULL;\n\treturn false;\n}\n\nstatic DBusMessage *start_discovery(DBusConnection *conn,\n\t\t\t\t\tDBusMessage *msg, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tconst char *sender = dbus_message_get_sender(msg);\n\tstruct discovery_client *client;\n\tbool is_discovering;\n\tint err;\n\n\tDBG(\"sender %s\", sender);\n\n\tif (!btd_adapter_get_powered(adapter))\n\t\treturn btd_error_not_ready(msg);\n\n\tis_discovering = get_discovery_client(adapter, sender, &client);\n\n\t/*\n\t * Every client can only start one discovery, if the client\n\t * already started a discovery then return an error.\n\t */\n\tif (is_discovering)\n\t\treturn btd_error_busy(msg);\n\n\t/*\n\t * If there was pre-set filter, just reconnect it to discovery_list,\n\t * and trigger scan.\n\t */\n\tif (client) {\n\t\tif (client->msg)\n\t\t\treturn btd_error_busy(msg);\n\n\t\tadapter->set_filter_list = g_slist_remove(\n\t\t\t\t\t     adapter->set_filter_list, client);\n\t\tadapter->discovery_list = g_slist_prepend(\n\t\t\t\t\t      adapter->discovery_list, client);\n\n\t\tgoto done;\n\t}\n\n\tclient = g_new0(struct discovery_client, 1);\n\n\tclient->adapter = adapter;\n\tclient->owner = g_strdup(sender);\n\tclient->discovery_filter = NULL;\n\tclient->watch = g_dbus_add_disconnect_watch(dbus_conn, sender,\n\t\t\t\t\t\tdiscovery_disconnect, client,\n\t\t\t\t\t\tNULL);\n\tadapter->discovery_list = g_slist_prepend(adapter->discovery_list,\n\t\t\t\t\t\t\t\tclient);\n\ndone:\n\t/*\n\t * Just trigger the discovery here. In case an already running\n\t * discovery in idle phase exists, it will be restarted right\n\t * away.\n\t */\n\terr = update_discovery_filter(adapter);\n\tif (!err)\n\t\treturn dbus_message_new_method_return(msg);\n\n\t/* If the discovery has to be started wait it complete to reply */\n\tif (err == -EINPROGRESS) {\n\t\tclient->msg = dbus_message_ref(msg);\n\t\tadapter->client = client;\n\t\treturn NULL;\n\t}\n\n\treturn btd_error_failed(msg, strerror(-err));\n}\n\nstatic bool parse_uuids(DBusMessageIter *value, struct discovery_filter *filter)\n{\n\tDBusMessageIter arriter;\n\n\tif (dbus_message_iter_get_arg_type(value) != DBUS_TYPE_ARRAY)\n\t\treturn false;\n\n\tdbus_message_iter_recurse(value, &arriter);\n\twhile (dbus_message_iter_get_arg_type(&arriter) != DBUS_TYPE_INVALID) {\n\t\tbt_uuid_t uuid, u128;\n\t\tchar uuidstr[MAX_LEN_UUID_STR + 1];\n\t\tchar *uuid_param;\n\n\t\tif (dbus_message_iter_get_arg_type(&arriter) !=\n\t\t\t\t\t\tDBUS_TYPE_STRING)\n\t\t\treturn false;\n\n\t\tdbus_message_iter_get_basic(&arriter, &uuid_param);\n\n\t\tif (bt_string_to_uuid(&uuid, uuid_param))\n\t\t\treturn false;\n\n\t\tbt_uuid_to_uuid128(&uuid, &u128);\n\t\tbt_uuid_to_string(&u128, uuidstr, sizeof(uuidstr));\n\n\t\tfilter->uuids = g_slist_prepend(filter->uuids, strdup(uuidstr));\n\n\t\tdbus_message_iter_next(&arriter);\n\t}\n\n\treturn true;\n}\n\nstatic bool parse_rssi(DBusMessageIter *value, struct discovery_filter *filter)\n{\n\tif (dbus_message_iter_get_arg_type(value) != DBUS_TYPE_INT16)\n\t\treturn false;\n\n\tdbus_message_iter_get_basic(value, &filter->rssi);\n\t/* -127 <= RSSI <= +20 (spec V4.2 [Vol 2, Part E] 7.7.65.2) */\n\tif (filter->rssi > 20 || filter->rssi < -127)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool parse_pathloss(DBusMessageIter *value,\n\t\t\t\tstruct discovery_filter *filter)\n{\n\tif (dbus_message_iter_get_arg_type(value) != DBUS_TYPE_UINT16)\n\t\treturn false;\n\n\tdbus_message_iter_get_basic(value, &filter->pathloss);\n\t/* pathloss filter must be smaller that PATHLOSS_MAX */\n\tif (filter->pathloss > PATHLOSS_MAX)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool parse_transport(DBusMessageIter *value,\n\t\t\t\t\tstruct discovery_filter *filter)\n{\n\tchar *transport_str;\n\n\tif (dbus_message_iter_get_arg_type(value) != DBUS_TYPE_STRING)\n\t\treturn false;\n\n\tdbus_message_iter_get_basic(value, &transport_str);\n\n\tif (!strcmp(transport_str, \"bredr\"))\n\t\tfilter->type = SCAN_TYPE_BREDR;\n\telse if (!strcmp(transport_str, \"le\"))\n\t\tfilter->type = SCAN_TYPE_LE;\n\telse if (strcmp(transport_str, \"auto\"))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool parse_duplicate_data(DBusMessageIter *value,\n\t\t\t\t\tstruct discovery_filter *filter)\n{\n\tif (dbus_message_iter_get_arg_type(value) != DBUS_TYPE_BOOLEAN)\n\t\treturn false;\n\n\tdbus_message_iter_get_basic(value, &filter->duplicate);\n\n\treturn true;\n}\n\nstatic bool parse_discoverable(DBusMessageIter *value,\n\t\t\t\t\tstruct discovery_filter *filter)\n{\n\tif (dbus_message_iter_get_arg_type(value) != DBUS_TYPE_BOOLEAN)\n\t\treturn false;\n\n\tdbus_message_iter_get_basic(value, &filter->discoverable);\n\n\treturn true;\n}\n\nstatic bool parse_pattern(DBusMessageIter *value,\n\t\t\t\t\tstruct discovery_filter *filter)\n{\n\tconst char *pattern;\n\n\tif (dbus_message_iter_get_arg_type(value) != DBUS_TYPE_STRING)\n\t\treturn false;\n\n\tdbus_message_iter_get_basic(value, &pattern);\n\n\tfree(filter->pattern);\n\tfilter->pattern = strdup(pattern);\n\n\treturn true;\n}\n\nstruct filter_parser {\n\tconst char *name;\n\tbool (*func)(DBusMessageIter *iter, struct discovery_filter *filter);\n} parsers[] = {\n\t{ \"UUIDs\", parse_uuids },\n\t{ \"RSSI\", parse_rssi },\n\t{ \"Pathloss\", parse_pathloss },\n\t{ \"Transport\", parse_transport },\n\t{ \"DuplicateData\", parse_duplicate_data },\n\t{ \"Discoverable\", parse_discoverable },\n\t{ \"Pattern\", parse_pattern },\n\t{ }\n};\n\nstatic bool parse_discovery_filter_entry(char *key, DBusMessageIter *value,\n\t\t\t\t\t\tstruct discovery_filter *filter)\n{\n\tstruct filter_parser *parser;\n\n\tfor (parser = parsers; parser && parser->name; parser++) {\n\t\tif (!strcmp(parser->name, key))\n\t\t\treturn parser->func(value, filter);\n\t}\n\n\tDBG(\"Unknown key parameter: %s!\\n\", key);\n\treturn false;\n}\n\n/*\n * This method is responsible for parsing parameters to SetDiscoveryFilter. If\n * filter in msg was empty, sets *filter to NULL. If whole parsing was\n * successful, sets *filter to proper value.\n * Returns false on any error, and true on success.\n */\nstatic bool parse_discovery_filter_dict(struct btd_adapter *adapter,\n\t\t\t\t\tstruct discovery_filter **filter,\n\t\t\t\t\tDBusMessage *msg)\n{\n\tDBusMessageIter iter, subiter, dictiter, variantiter;\n\tbool is_empty = true;\n\n\t*filter = g_try_malloc(sizeof(**filter));\n\tif (!*filter)\n\t\treturn false;\n\n\t(*filter)->uuids = NULL;\n\t(*filter)->pathloss = DISTANCE_VAL_INVALID;\n\t(*filter)->rssi = DISTANCE_VAL_INVALID;\n\t(*filter)->type = get_scan_type(adapter);\n\t(*filter)->duplicate = false;\n\t(*filter)->discoverable = false;\n\t(*filter)->pattern = NULL;\n\n\tdbus_message_iter_init(msg, &iter);\n\tif (dbus_message_iter_get_arg_type(&iter) != DBUS_TYPE_ARRAY ||\n\t    dbus_message_iter_get_element_type(&iter) != DBUS_TYPE_DICT_ENTRY)\n\t\tgoto invalid_args;\n\n\tdbus_message_iter_recurse(&iter, &subiter);\n\tdo {\n\t\tint type = dbus_message_iter_get_arg_type(&subiter);\n\t\tchar *key;\n\n\t\tif (type == DBUS_TYPE_INVALID)\n\t\t\tbreak;\n\n\t\tis_empty = false;\n\t\tdbus_message_iter_recurse(&subiter, &dictiter);\n\n\t\tdbus_message_iter_get_basic(&dictiter, &key);\n\t\tif (!dbus_message_iter_next(&dictiter))\n\t\t\tgoto invalid_args;\n\n\t\tif (dbus_message_iter_get_arg_type(&dictiter) !=\n\t\t\t\t\t\t\t     DBUS_TYPE_VARIANT)\n\t\t\tgoto invalid_args;\n\n\t\tdbus_message_iter_recurse(&dictiter, &variantiter);\n\n\t\tif (!parse_discovery_filter_entry(key, &variantiter, *filter))\n\t\t\tgoto invalid_args;\n\n\t\tdbus_message_iter_next(&subiter);\n\t} while (true);\n\n\tif (is_empty) {\n\t\tg_free(*filter);\n\t\t*filter = NULL;\n\t\treturn true;\n\t}\n\n\t/* only pathlos or rssi can be set, never both */\n\tif ((*filter)->pathloss != DISTANCE_VAL_INVALID &&\n\t    (*filter)->rssi != DISTANCE_VAL_INVALID)\n\t\tgoto invalid_args;\n\n\tDBG(\"filtered discovery params: transport: %d rssi: %d pathloss: %d \"\n\t\t\" duplicate data: %s discoverable %s pattern %s\",\n\t\t(*filter)->type, (*filter)->rssi, (*filter)->pathloss,\n\t\t(*filter)->duplicate ? \"true\" : \"false\",\n\t\t(*filter)->discoverable ? \"true\" : \"false\",\n\t\t(*filter)->pattern);\n\n\treturn true;\n\ninvalid_args:\n\tg_slist_free_full((*filter)->uuids, g_free);\n\tg_free(*filter);\n\t*filter = NULL;\n\treturn false;\n}\n\nstatic DBusMessage *set_discovery_filter(DBusConnection *conn,\n\t\t\t\t\tDBusMessage *msg, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tstruct discovery_client *client;\n\tstruct discovery_filter *discovery_filter;\n\tconst char *sender = dbus_message_get_sender(msg);\n\tbool is_discovering;\n\n\tDBG(\"sender %s\", sender);\n\n\tif (!btd_adapter_get_powered(adapter))\n\t\treturn btd_error_not_ready(msg);\n\n\tif (MGMT_VERSION(mgmt_version, mgmt_revision) < MGMT_VERSION(1, 8))\n\t\treturn btd_error_not_supported(msg);\n\n\t/* parse parameters */\n\tif (!parse_discovery_filter_dict(adapter, &discovery_filter, msg))\n\t\treturn btd_error_invalid_args(msg);\n\n\tis_discovering = get_discovery_client(adapter, sender, &client);\n\n\tif (client) {\n\t\tfree_discovery_filter(client->discovery_filter);\n\t\tclient->discovery_filter = discovery_filter;\n\n\t\tif (is_discovering)\n\t\t\tupdate_discovery_filter(adapter);\n\n\t\tif (discovery_filter || is_discovering)\n\t\t\treturn dbus_message_new_method_return(msg);\n\n\t\t/* Removing pre-set filter */\n\t\tadapter->set_filter_list = g_slist_remove(\n\t\t\t\t\t      adapter->set_filter_list,\n\t\t\t\t\t      client);\n\t\tdiscovery_free(client);\n\t\tDBG(\"successfully cleared pre-set filter\");\n\t} else if (discovery_filter) {\n\t\t/* Client pre-setting his filter for first time */\n\t\tclient = g_new0(struct discovery_client, 1);\n\t\tclient->adapter = adapter;\n\t\tclient->owner = g_strdup(sender);\n\t\tclient->discovery_filter = discovery_filter;\n\t\tclient->watch = g_dbus_add_disconnect_watch(dbus_conn, sender,\n\t\t\t\t\t\tdiscovery_disconnect, client,\n\t\t\t\t\t\tNULL);\n\t\tadapter->set_filter_list = g_slist_prepend(\n\t\t\t\t\t     adapter->set_filter_list, client);\n\n\t\tDBG(\"successfully pre-set filter\");\n\t}\n\n\treturn dbus_message_new_method_return(msg);\n}\n\nstatic DBusMessage *stop_discovery(DBusConnection *conn,\n\t\t\t\t\tDBusMessage *msg, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tconst char *sender = dbus_message_get_sender(msg);\n\tstruct discovery_client *client;\n\tGSList *list;\n\tint err;\n\n\tDBG(\"sender %s\", sender);\n\n\tif (!btd_adapter_get_powered(adapter))\n\t\treturn btd_error_not_ready(msg);\n\n\tlist = g_slist_find_custom(adapter->discovery_list, sender,\n\t\t\t\t\t\tcompare_sender);\n\tif (!list)\n\t\treturn btd_error_failed(msg, \"No discovery started\");\n\n\tclient = list->data;\n\n\tif (client->msg)\n\t\treturn btd_error_busy(msg);\n\n\terr = discovery_stop(client);\n\tswitch (err) {\n\tcase 0:\n\t\treturn dbus_message_new_method_return(msg);\n\tcase -EINPROGRESS:\n\t\tclient->msg = dbus_message_ref(msg);\n\t\tadapter->client = client;\n\t\treturn NULL;\n\tdefault:\n\t\treturn btd_error_failed(msg, strerror(-err));\n\t}\n}\n\nstatic gboolean property_get_address(const GDBusPropertyTable *property,\n\t\t\t\t\tDBusMessageIter *iter, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tchar addr[18];\n\tconst char *str = addr;\n\n\tba2str(&adapter->bdaddr, addr);\n\n\tdbus_message_iter_append_basic(iter, DBUS_TYPE_STRING, &str);\n\n\treturn TRUE;\n}\n\nstatic gboolean property_get_address_type(const GDBusPropertyTable *property,\n\t\t\t\t\tDBusMessageIter *iter, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tconst char *str;\n\n\tif ((adapter->current_settings & MGMT_SETTING_LE) &&\n\t\t\t\t(adapter->bdaddr_type == BDADDR_LE_RANDOM))\n\t\tstr = \"random\";\n\telse\n\t\tstr = \"public\";\n\n\tdbus_message_iter_append_basic(iter, DBUS_TYPE_STRING, &str);\n\n\treturn TRUE;\n}\n\nstatic gboolean property_get_name(const GDBusPropertyTable *property,\n\t\t\t\t\tDBusMessageIter *iter, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tconst char *str = adapter->system_name ? : \"\";\n\n\tdbus_message_iter_append_basic(iter, DBUS_TYPE_STRING, &str);\n\n\treturn TRUE;\n}\n\nstatic gboolean property_get_alias(const GDBusPropertyTable *property,\n\t\t\t\t\tDBusMessageIter *iter, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tconst char *str;\n\n\tif (adapter->current_alias)\n\t\tstr = adapter->current_alias;\n\telse if (adapter->stored_alias)\n\t\tstr = adapter->stored_alias;\n\telse\n\t\tstr = adapter->system_name ? : \"\";\n\n\tdbus_message_iter_append_basic(iter, DBUS_TYPE_STRING, &str);\n\n\treturn TRUE;\n}\n\nstatic void property_set_alias(const GDBusPropertyTable *property,\n\t\t\t\tDBusMessageIter *iter,\n\t\t\t\tGDBusPendingPropertySet id, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tconst char *name;\n\tint ret;\n\n\tdbus_message_iter_get_basic(iter, &name);\n\n\tif (g_str_equal(name, \"\")  == TRUE) {\n\t\tif (adapter->stored_alias == NULL) {\n\t\t\t/* no alias set, nothing to restore */\n\t\t\tg_dbus_pending_property_success(id);\n\t\t\treturn;\n\t\t}\n\n\t\t/* restore to system name */\n\t\tret = set_name(adapter, adapter->system_name);\n\t} else {\n\t\tif (g_strcmp0(adapter->stored_alias, name) == 0) {\n\t\t\t/* alias already set, nothing to do */\n\t\t\tg_dbus_pending_property_success(id);\n\t\t\treturn;\n\t\t}\n\n\t\t/* set to alias */\n\t\tret = set_name(adapter, name);\n\t}\n\n\tif (ret >= 0) {\n\t\tg_free(adapter->stored_alias);\n\n\t\tif (g_str_equal(name, \"\")  == TRUE)\n\t\t\tadapter->stored_alias = NULL;\n\t\telse\n\t\t\tadapter->stored_alias = g_strdup(name);\n\n\t\tstore_adapter_info(adapter);\n\n\t\tg_dbus_pending_property_success(id);\n\t\treturn;\n\t}\n\n\tif (ret == -EINVAL)\n\t\tg_dbus_pending_property_error(id,\n\t\t\t\t\tERROR_INTERFACE \".InvalidArguments\",\n\t\t\t\t\t\"Invalid arguments in method call\");\n\telse\n\t\tg_dbus_pending_property_error(id, ERROR_INTERFACE \".Failed\",\n\t\t\t\t\t\t\tstrerror(-ret));\n}\n\nstatic gboolean property_get_class(const GDBusPropertyTable *property,\n\t\t\t\t\tDBusMessageIter *iter, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tdbus_uint32_t val = adapter->dev_class;\n\n\tdbus_message_iter_append_basic(iter, DBUS_TYPE_UINT32, &val);\n\n\treturn TRUE;\n}\n\nstatic gboolean property_get_mode(struct btd_adapter *adapter,\n\t\t\t\tuint32_t setting, DBusMessageIter *iter)\n{\n\tdbus_bool_t enable;\n\n\tenable = (adapter->current_settings & setting) ? TRUE : FALSE;\n\n\tdbus_message_iter_append_basic(iter, DBUS_TYPE_BOOLEAN, &enable);\n\n\treturn TRUE;\n}\n\nstruct property_set_data {\n\tstruct btd_adapter *adapter;\n\tGDBusPendingPropertySet id;\n};\n\nstatic void property_set_mode_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct property_set_data *data = user_data;\n\tstruct btd_adapter *adapter = data->adapter;\n\n\tDBG(\"%s (0x%02x)\", mgmt_errstr(status), status);\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\tconst char *dbus_err;\n\n\t\tbtd_error(adapter->dev_id, \"Failed to set mode: %s (0x%02x)\",\n\t\t\t\t\t\tmgmt_errstr(status), status);\n\n\t\tif (status == MGMT_STATUS_RFKILLED)\n\t\t\tdbus_err = ERROR_INTERFACE \".Blocked\";\n\t\telse\n\t\t\tdbus_err = ERROR_INTERFACE \".Failed\";\n\n\t\tg_dbus_pending_property_error(data->id, dbus_err,\n\t\t\t\t\t\t\tmgmt_errstr(status));\n\t\treturn;\n\t}\n\n\tg_dbus_pending_property_success(data->id);\n\n\t/*\n\t * The parameters are identical and also the task that is\n\t * required in both cases. So it is safe to just call the\n\t * event handling functions here.\n\t */\n\tnew_settings_callback(adapter->dev_id, length, param, adapter);\n}\n\nstatic void clear_discoverable(struct btd_adapter *adapter)\n{\n\tif (!btd_has_kernel_features(KERNEL_CONN_CONTROL))\n\t\treturn;\n\n\tif (!(adapter->current_settings & MGMT_SETTING_DISCOVERABLE))\n\t\treturn;\n\n\t/* If no timeout is set do nothing as both connectable and discoverable\n\t * flags are persistent on power toggle.\n\t */\n\tif (!adapter->discoverable_timeout)\n\t\treturn;\n\n\t/* If timeout was set kernel clears discoverable on its own when\n\t * powering off controller. This would leave connectable flag set\n\t * after power on.\n\t *\n\t * With kernel control clearing connectable clear also discoverable\n\t * flag so we need to clear connectable.\n\t */\n\tset_mode(adapter, MGMT_OP_SET_CONNECTABLE, 0x00);\n}\n\nstatic void property_set_mode(struct btd_adapter *adapter, uint32_t setting,\n\t\t\t\t\t\tDBusMessageIter *value,\n\t\t\t\t\t\tGDBusPendingPropertySet id)\n{\n\tstruct property_set_data *data;\n\tstruct mgmt_cp_set_discoverable cp;\n\tvoid *param;\n\tdbus_bool_t enable, current_enable;\n\tuint16_t opcode, len;\n\tuint8_t mode;\n\n\tdbus_message_iter_get_basic(value, &enable);\n\n\tif (adapter->pending_settings & setting) {\n\t\tg_dbus_pending_property_error(id, ERROR_INTERFACE \".Busy\",\n\t\t\t\t\t\tNULL);\n\t\treturn;\n\t}\n\n\tif (adapter->current_settings & setting)\n\t\tcurrent_enable = TRUE;\n\telse\n\t\tcurrent_enable = FALSE;\n\n\tif (enable == current_enable) {\n\t\tg_dbus_pending_property_success(id);\n\t\treturn;\n\t}\n\n\tmode = (enable == TRUE) ? 0x01 : 0x00;\n\n\tadapter->pending_settings |= setting;\n\n\tswitch (setting) {\n\tcase MGMT_SETTING_POWERED:\n\t\topcode = MGMT_OP_SET_POWERED;\n\t\tparam = &mode;\n\t\tlen = sizeof(mode);\n\n\t\tif (!mode) {\n\t\t\tclear_discoverable(adapter);\n\t\t\tremove_temporary_devices(adapter);\n\t\t}\n\n\t\tbreak;\n\tcase MGMT_SETTING_DISCOVERABLE:\n\t\tif (btd_has_kernel_features(KERNEL_CONN_CONTROL)) {\n\t\t\tif (mode) {\n\t\t\t\tset_mode(adapter, MGMT_OP_SET_CONNECTABLE,\n\t\t\t\t\t\t\t\t\tmode);\n\t\t\t} else {\n\t\t\t\topcode = MGMT_OP_SET_CONNECTABLE;\n\t\t\t\tparam = &mode;\n\t\t\t\tlen = sizeof(mode);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tmemset(&cp, 0, sizeof(cp));\n\t\tcp.val = mode;\n\t\tif (cp.val)\n\t\t\tcp.timeout = htobs(adapter->discoverable_timeout);\n\n\t\topcode = MGMT_OP_SET_DISCOVERABLE;\n\t\tparam = &cp;\n\t\tlen = sizeof(cp);\n\t\tbreak;\n\tcase MGMT_SETTING_BONDABLE:\n\t\topcode = MGMT_OP_SET_BONDABLE;\n\t\tparam = &mode;\n\t\tlen = sizeof(mode);\n\t\tbreak;\n\tdefault:\n\t\tgoto failed;\n\t}\n\n\tDBG(\"sending %s command for index %u\", mgmt_opstr(opcode),\n\t\t\t\t\t\t\tadapter->dev_id);\n\n\tdata = g_try_new0(struct property_set_data, 1);\n\tif (!data)\n\t\tgoto failed;\n\n\tdata->adapter = adapter;\n\tdata->id = id;\n\n\tif (mgmt_send(adapter->mgmt, opcode, adapter->dev_id, len, param,\n\t\t\tproperty_set_mode_complete, data, g_free) > 0)\n\t\treturn;\n\n\tg_free(data);\n\nfailed:\n\tbtd_error(adapter->dev_id, \"Failed to set mode for index %u\",\n\t\t\t\t\t\t\tadapter->dev_id);\n\n\tg_dbus_pending_property_error(id, ERROR_INTERFACE \".Failed\", NULL);\n}\n\nstatic gboolean property_get_powered(const GDBusPropertyTable *property,\n\t\t\t\t\tDBusMessageIter *iter, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\treturn property_get_mode(adapter, MGMT_SETTING_POWERED, iter);\n}\n\nstatic void property_set_powered(const GDBusPropertyTable *property,\n\t\t\t\tDBusMessageIter *iter,\n\t\t\t\tGDBusPendingPropertySet id, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\tif (powering_down) {\n\t\tg_dbus_pending_property_error(id, ERROR_INTERFACE \".Failed\",\n\t\t\t\t\t\t\t\"Powering down\");\n\t\treturn;\n\t}\n\n\tproperty_set_mode(adapter, MGMT_SETTING_POWERED, iter, id);\n}\n\nstatic gboolean property_get_discoverable(const GDBusPropertyTable *property,\n\t\t\t\t\tDBusMessageIter *iter, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\treturn property_get_mode(adapter, MGMT_SETTING_DISCOVERABLE, iter);\n}\n\nstatic void property_set_discoverable(const GDBusPropertyTable *property,\n\t\t\t\tDBusMessageIter *iter,\n\t\t\t\tGDBusPendingPropertySet id, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\tif (adapter->discoverable_timeout > 0 &&\n\t\t\t!btd_adapter_get_powered(adapter)) {\n\t\tg_dbus_pending_property_error(id, ERROR_INTERFACE \".Failed\",\n\t\t\t\t\t\t\t\t\"Not Powered\");\n\t\treturn;\n\t}\n\n\t/* Reset discovery_discoverable as Discoverable takes precedence */\n\tadapter->discovery_discoverable = false;\n\n\tproperty_set_mode(adapter, MGMT_SETTING_DISCOVERABLE, iter, id);\n}\n\nstatic gboolean property_get_discoverable_timeout(\n\t\t\t\t\tconst GDBusPropertyTable *property,\n\t\t\t\t\tDBusMessageIter *iter, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tdbus_uint32_t value = adapter->discoverable_timeout;\n\n\tdbus_message_iter_append_basic(iter, DBUS_TYPE_UINT32, &value);\n\n\treturn TRUE;\n}\n\nstatic void property_set_discoverable_timeout(\n\t\t\t\tconst GDBusPropertyTable *property,\n\t\t\t\tDBusMessageIter *iter,\n\t\t\t\tGDBusPendingPropertySet id, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tbool enabled;\n\tdbus_uint32_t value;\n\n\tdbus_message_iter_get_basic(iter, &value);\n\n\tadapter->discoverable_timeout = value;\n\n\tg_dbus_pending_property_success(id);\n\n\tstore_adapter_info(adapter);\n\n\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\tADAPTER_INTERFACE, \"DiscoverableTimeout\");\n\n\tif (adapter->pending_settings & MGMT_SETTING_DISCOVERABLE) {\n\t\tif (adapter->current_settings & MGMT_SETTING_DISCOVERABLE)\n\t\t\tenabled = false;\n\t\telse\n\t\t\tenabled = true;\n\t} else {\n\t\tif (adapter->current_settings & MGMT_SETTING_DISCOVERABLE)\n\t\t\tenabled = true;\n\t\telse\n\t\t\tenabled = false;\n\t}\n\n\tif (enabled)\n\t\tset_discoverable(adapter, 0x01, adapter->discoverable_timeout);\n}\n\nstatic gboolean property_get_pairable(const GDBusPropertyTable *property,\n\t\t\t\t\tDBusMessageIter *iter, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\treturn property_get_mode(adapter, MGMT_SETTING_BONDABLE, iter);\n}\n\nstatic void property_set_pairable(const GDBusPropertyTable *property,\n\t\t\t\tDBusMessageIter *iter,\n\t\t\t\tGDBusPendingPropertySet id, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\tproperty_set_mode(adapter, MGMT_SETTING_BONDABLE, iter, id);\n}\n\nstatic gboolean property_get_pairable_timeout(\n\t\t\t\t\tconst GDBusPropertyTable *property,\n\t\t\t\t\tDBusMessageIter *iter, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tdbus_uint32_t value = adapter->pairable_timeout;\n\n\tdbus_message_iter_append_basic(iter, DBUS_TYPE_UINT32, &value);\n\n\treturn TRUE;\n}\n\nstatic void property_set_pairable_timeout(const GDBusPropertyTable *property,\n\t\t\t\tDBusMessageIter *iter,\n\t\t\t\tGDBusPendingPropertySet id, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tdbus_uint32_t value;\n\n\tdbus_message_iter_get_basic(iter, &value);\n\n\tadapter->pairable_timeout = value;\n\n\tg_dbus_pending_property_success(id);\n\n\tstore_adapter_info(adapter);\n\n\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"PairableTimeout\");\n\n\ttrigger_pairable_timeout(adapter);\n}\n\nstatic gboolean property_get_discovering(const GDBusPropertyTable *property,\n\t\t\t\t\tDBusMessageIter *iter, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tdbus_bool_t discovering = adapter->discovering;\n\n\tdbus_message_iter_append_basic(iter, DBUS_TYPE_BOOLEAN, &discovering);\n\n\treturn TRUE;\n}\n\nstatic void add_gatt_uuid(struct gatt_db_attribute *attrib, void *user_data)\n{\n\tGHashTable *uuids = user_data;\n\tbt_uuid_t uuid, u128;\n\tchar uuidstr[MAX_LEN_UUID_STR + 1];\n\n\tif (!gatt_db_service_get_active(attrib))\n\t\treturn;\n\n\tif (!gatt_db_attribute_get_service_uuid(attrib, &uuid))\n\t\treturn;\n\n\tbt_uuid_to_uuid128(&uuid, &u128);\n\tbt_uuid_to_string(&u128, uuidstr, sizeof(uuidstr));\n\n\tg_hash_table_add(uuids, strdup(uuidstr));\n}\n\nstatic void iter_append_uuid(gpointer key, gpointer value, gpointer user_data)\n{\n\tDBusMessageIter *iter = user_data;\n\tconst char *uuid = key;\n\n\tdbus_message_iter_append_basic(iter, DBUS_TYPE_STRING, &uuid);\n}\n\nstatic gboolean property_get_uuids(const GDBusPropertyTable *property,\n\t\t\t\t\tDBusMessageIter *iter, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tDBusMessageIter entry;\n\tsdp_list_t *l;\n\tstruct gatt_db *db;\n\tGHashTable *uuids;\n\n\tuuids = g_hash_table_new_full(g_str_hash, g_str_equal, free, NULL);\n\tif (!uuids)\n\t\treturn FALSE;\n\n\t/* SDP records */\n\tfor (l = adapter->services; l != NULL; l = l->next) {\n\t\tsdp_record_t *rec = l->data;\n\t\tchar *uuid;\n\n\t\tuuid = bt_uuid2string(&rec->svclass);\n\t\tif (uuid == NULL)\n\t\t\tcontinue;\n\n\t\tg_hash_table_add(uuids, uuid);\n\t}\n\n\t/* GATT services */\n\tdb = btd_gatt_database_get_db(adapter->database);\n\tif (db)\n\t\tgatt_db_foreach_service(db, NULL, add_gatt_uuid, uuids);\n\n\tdbus_message_iter_open_container(iter, DBUS_TYPE_ARRAY,\n\t\t\t\t\tDBUS_TYPE_STRING_AS_STRING, &entry);\n\tg_hash_table_foreach(uuids, iter_append_uuid, &entry);\n\tdbus_message_iter_close_container(iter, &entry);\n\n\tg_hash_table_destroy(uuids);\n\n\treturn TRUE;\n}\n\nstatic gboolean property_exists_modalias(const GDBusPropertyTable *property,\n\t\t\t\t\t\t\tvoid *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\treturn adapter->modalias ? TRUE : FALSE;\n}\n\nstatic gboolean property_get_modalias(const GDBusPropertyTable *property,\n\t\t\t\t\tDBusMessageIter *iter, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tconst char *str = adapter->modalias ? : \"\";\n\n\tdbus_message_iter_append_basic(iter, DBUS_TYPE_STRING, &str);\n\n\treturn TRUE;\n}\n\nstatic gboolean property_get_roles(const GDBusPropertyTable *property,\n\t\t\t\t\tDBusMessageIter *iter, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tDBusMessageIter entry;\n\n\tdbus_message_iter_open_container(iter, DBUS_TYPE_ARRAY,\n\t\t\t\t\tDBUS_TYPE_STRING_AS_STRING, &entry);\n\n\tif (adapter->supported_settings & MGMT_SETTING_LE) {\n\t\tconst char *str = \"central\";\n\t\tdbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &str);\n\t}\n\n\tif (adapter->supported_settings & MGMT_SETTING_ADVERTISING) {\n\t\tconst char *str = \"peripheral\";\n\t\tdbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &str);\n\t}\n\n\tif (adapter->le_simult_roles_supported) {\n\t\tconst char *str = \"central-peripheral\";\n\t\tdbus_message_iter_append_basic(&entry, DBUS_TYPE_STRING, &str);\n\t}\n\n\tdbus_message_iter_close_container(iter, &entry);\n\n\treturn TRUE;\n}\n\nstatic DBusMessage *remove_device(DBusConnection *conn,\n\t\t\t\t\tDBusMessage *msg, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tstruct btd_device *device;\n\tconst char *path;\n\tGSList *list;\n\n\tif (dbus_message_get_args(msg, NULL, DBUS_TYPE_OBJECT_PATH, &path,\n\t\t\t\t\t\tDBUS_TYPE_INVALID) == FALSE)\n\t\treturn btd_error_invalid_args(msg);\n\n\tlist = g_slist_find_custom(adapter->devices, path, device_path_cmp);\n\tif (!list)\n\t\treturn btd_error_does_not_exist(msg);\n\n\tif (!btd_adapter_get_powered(adapter))\n\t\treturn btd_error_not_ready(msg);\n\n\tdevice = list->data;\n\n\tbtd_device_set_temporary(device, true);\n\n\tif (!btd_device_is_connected(device)) {\n\t\tbtd_adapter_remove_device(adapter, device);\n\t\treturn dbus_message_new_method_return(msg);\n\t}\n\n\tdevice_request_disconnect(device, msg);\n\n\treturn NULL;\n}\n\nstatic DBusMessage *get_discovery_filters(DBusConnection *conn,\n\t\t\t\t\tDBusMessage *msg, void *user_data)\n{\n\tDBusMessage *reply;\n\tDBusMessageIter iter, array;\n\tstruct filter_parser *parser;\n\n\treply = dbus_message_new_method_return(msg);\n\n\tdbus_message_iter_init_append(reply, &iter);\n\n\tdbus_message_iter_open_container(&iter, DBUS_TYPE_ARRAY,\n\t\t\t\t\tDBUS_TYPE_STRING_AS_STRING, &array);\n\n\tfor (parser = parsers; parser && parser->name; parser++) {\n\t\tdbus_message_iter_append_basic(&array, DBUS_TYPE_STRING,\n\t\t\t\t\t\t\t&parser->name);\n\t}\n\n\tdbus_message_iter_close_container(&iter, &array);\n\n\treturn reply;\n}\n\nstruct device_connect_data {\n\tstruct btd_adapter *adapter;\n\tbdaddr_t dst;\n\tuint8_t dst_type;\n\tDBusMessage *msg;\n};\n\nstatic void device_browse_cb(struct btd_device *dev, int err, void *user_data)\n{\n\tDBG(\"err %d (%s)\", err, strerror(-err));\n\n\tif (!err)\n\t\tbtd_device_connect_services(dev, NULL);\n}\n\nstatic void device_connect_cb(GIOChannel *io, GError *gerr, gpointer user_data)\n{\n\tstruct device_connect_data *data = user_data;\n\tstruct btd_adapter *adapter = data->adapter;\n\tstruct btd_device *device;\n\tconst char *path;\n\n\tDBG(\"%s\", gerr ? gerr->message : \"\");\n\n\tif (gerr)\n\t\tgoto failed;\n\n\t/* object might already exist due to mgmt socket event */\n\tdevice = btd_adapter_get_device(adapter, &data->dst, data->dst_type);\n\tif (!device)\n\t\tgoto failed;\n\n\tpath = device_get_path(device);\n\n\tg_dbus_send_reply(dbus_conn, data->msg, DBUS_TYPE_OBJECT_PATH, &path,\n\t\t\t\t\t\t\tDBUS_TYPE_INVALID);\n\n\t/* continue with service discovery and connection */\n\tbtd_device_set_temporary(device, false);\n\tdevice_update_last_seen(device, data->dst_type);\n\n\tif (data->dst_type != BDADDR_BREDR){\n\t\tg_io_channel_set_close_on_unref(io, FALSE);\n\t\tdevice_attach_att(device, io);\n\t}\n\n\tdevice_discover_services(device);\n\tdevice_wait_for_svc_complete(device, device_browse_cb, NULL);\n\n\tg_io_channel_unref(io);\n\tdbus_message_unref(data->msg);\n\tfree(data);\n\treturn;\n\nfailed:\n\tg_dbus_send_error(dbus_conn, data->msg, \"org.bluez.Failed\", NULL);\n\tg_io_channel_unref(io);\n\tdbus_message_unref(data->msg);\n\tfree(data);\n}\n\nstatic void device_connect(struct btd_adapter *adapter, const bdaddr_t *dst,\n\t\t\t\t\tuint8_t dst_type, DBusMessage *msg)\n{\n\tstruct device_connect_data *data;\n\tGIOChannel *io;\n\n\tdata = new0(struct device_connect_data, 1);\n\tdata->adapter = adapter;\n\tbacpy(&data->dst, dst);\n\tdata->dst_type = dst_type;\n\tdata->msg = dbus_message_ref(msg);\n\n\tif (dst_type == BDADDR_BREDR)\n\t\tio = bt_io_connect(device_connect_cb, data, NULL, NULL,\n\t\t\t\tBT_IO_OPT_SOURCE_BDADDR, &adapter->bdaddr,\n\t\t\t\tBT_IO_OPT_SOURCE_TYPE, BDADDR_BREDR,\n\t\t\t\tBT_IO_OPT_DEST_BDADDR, dst,\n\t\t\t\tBT_IO_OPT_DEST_TYPE, BDADDR_BREDR,\n\t\t\t\tBT_IO_OPT_PSM, SDP_PSM,\n\t\t\t\tBT_IO_OPT_SEC_LEVEL, BT_IO_SEC_LOW,\n\t\t\t\tBT_IO_OPT_INVALID);\n\telse\n\t\tio = bt_io_connect(device_connect_cb, data, NULL, NULL,\n\t\t\t\tBT_IO_OPT_SOURCE_BDADDR, &adapter->bdaddr,\n\t\t\t\tBT_IO_OPT_SOURCE_TYPE, adapter->bdaddr_type,\n\t\t\t\tBT_IO_OPT_DEST_BDADDR, dst,\n\t\t\t\tBT_IO_OPT_DEST_TYPE, dst_type,\n\t\t\t\tBT_IO_OPT_CID, ATT_CID,\n\t\t\t\tBT_IO_OPT_SEC_LEVEL, BT_IO_SEC_LOW,\n\t\t\t\tBT_IO_OPT_INVALID);\n\n\tif (!io) {\n\t\tg_dbus_send_message(dbus_conn,\n\t\t\t\tbtd_error_failed(msg, \"Connect failed\"));\n\t\tdbus_message_unref(data->msg);\n\t\tfree(data);\n\t}\n}\n\nstatic DBusMessage *connect_device(DBusConnection *conn,\n\t\t\t\t\tDBusMessage *msg, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tDBusMessageIter iter, subiter, dictiter, value;\n\tuint8_t addr_type = BDADDR_BREDR;\n\tbdaddr_t addr = *BDADDR_ANY;\n\n\tDBG(\"sender %s\", dbus_message_get_sender(msg));\n\n\tif (!btd_adapter_get_powered(adapter))\n\t\treturn btd_error_not_ready(msg);\n\n\tdbus_message_iter_init(msg, &iter);\n\tif (dbus_message_iter_get_arg_type(&iter) != DBUS_TYPE_ARRAY ||\n\t    dbus_message_iter_get_element_type(&iter) != DBUS_TYPE_DICT_ENTRY)\n\t\treturn btd_error_invalid_args(msg);\n\n\tdbus_message_iter_recurse(&iter, &subiter);\n\twhile (true) {\n\t\tint type = dbus_message_iter_get_arg_type(&subiter);\n\t\tchar *key;\n\t\tchar *str;\n\n\t\tif (type == DBUS_TYPE_INVALID)\n\t\t\tbreak;\n\n\t\tdbus_message_iter_recurse(&subiter, &dictiter);\n\n\t\tdbus_message_iter_get_basic(&dictiter, &key);\n\t\tif (!dbus_message_iter_next(&dictiter))\n\t\t\treturn btd_error_invalid_args(msg);\n\n\t\tif (dbus_message_iter_get_arg_type(&dictiter) !=\n\t\t\t\t\t\t\tDBUS_TYPE_VARIANT)\n\t\t\treturn btd_error_invalid_args(msg);\n\n\t\tdbus_message_iter_recurse(&dictiter, &value);\n\n\t\tif (!strcmp(key, \"Address\")) {\n\t\t\tif (dbus_message_iter_get_arg_type(&value) !=\n\t\t\t\t\t\t\tDBUS_TYPE_STRING)\n\t\t\t\treturn btd_error_invalid_args(msg);\n\n\t\t\tdbus_message_iter_get_basic(&value, &str);\n\n\t\t\tif (str2ba(str, &addr) < 0 )\n\t\t\t\treturn btd_error_invalid_args(msg);\n\t\t} else if (!strcmp(key, \"AddressType\")) {\n\t\t\tif (dbus_message_iter_get_arg_type(&value) !=\n\t\t\t\t\t\t\tDBUS_TYPE_STRING)\n\t\t\t\treturn btd_error_invalid_args(msg);\n\n\t\t\tdbus_message_iter_get_basic(&value, &str);\n\n\n\t\t\tif (!strcmp(str, \"public\"))\n\t\t\t\taddr_type = BDADDR_LE_PUBLIC;\n\t\t\telse if (!strcmp(str, \"random\"))\n\t\t\t\taddr_type = BDADDR_LE_RANDOM;\n\t\t\telse\n\t\t\t\treturn btd_error_invalid_args(msg);\n\t\t} else {\n\t\t\treturn btd_error_invalid_args(msg);\n\t\t}\n\n\t\tdbus_message_iter_next(&subiter);\n\t}\n\n\tif (!bacmp(&addr, BDADDR_ANY))\n\t\treturn btd_error_invalid_args(msg);\n\n\tif (btd_adapter_find_device(adapter, &addr, addr_type))\n\t\treturn btd_error_already_exists(msg);\n\n\tdevice_connect(adapter, &addr, addr_type, msg);\n\treturn NULL;\n}\n\nstatic const GDBusMethodTable adapter_methods[] = {\n\t{ GDBUS_ASYNC_METHOD(\"StartDiscovery\", NULL, NULL, start_discovery) },\n\t{ GDBUS_METHOD(\"SetDiscoveryFilter\",\n\t\t\t\tGDBUS_ARGS({ \"properties\", \"a{sv}\" }), NULL,\n\t\t\t\tset_discovery_filter) },\n\t{ GDBUS_ASYNC_METHOD(\"StopDiscovery\", NULL, NULL, stop_discovery) },\n\t{ GDBUS_ASYNC_METHOD(\"RemoveDevice\",\n\t\t\tGDBUS_ARGS({ \"device\", \"o\" }), NULL, remove_device) },\n\t{ GDBUS_METHOD(\"GetDiscoveryFilters\", NULL,\n\t\t\tGDBUS_ARGS({ \"filters\", \"as\" }),\n\t\t\tget_discovery_filters) },\n\t{ GDBUS_EXPERIMENTAL_ASYNC_METHOD(\"ConnectDevice\",\n\t\t\t\tGDBUS_ARGS({ \"properties\", \"a{sv}\" }), NULL,\n\t\t\t\tconnect_device) },\n\t{ }\n};\n\nstatic const GDBusPropertyTable adapter_properties[] = {\n\t{ \"Address\", \"s\", property_get_address },\n\t{ \"AddressType\", \"s\", property_get_address_type },\n\t{ \"Name\", \"s\", property_get_name },\n\t{ \"Alias\", \"s\", property_get_alias, property_set_alias },\n\t{ \"Class\", \"u\", property_get_class },\n\t{ \"Powered\", \"b\", property_get_powered, property_set_powered },\n\t{ \"Discoverable\", \"b\", property_get_discoverable,\n\t\t\t\t\tproperty_set_discoverable },\n\t{ \"DiscoverableTimeout\", \"u\", property_get_discoverable_timeout,\n\t\t\t\t\tproperty_set_discoverable_timeout },\n\t{ \"Pairable\", \"b\", property_get_pairable, property_set_pairable },\n\t{ \"PairableTimeout\", \"u\", property_get_pairable_timeout,\n\t\t\t\t\tproperty_set_pairable_timeout },\n\t{ \"Discovering\", \"b\", property_get_discovering },\n\t{ \"UUIDs\", \"as\", property_get_uuids },\n\t{ \"Modalias\", \"s\", property_get_modalias, NULL,\n\t\t\t\t\tproperty_exists_modalias },\n\t{ \"Roles\", \"as\", property_get_roles },\n\t{ }\n};\n\nstatic int str2buf(const char *str, uint8_t *buf, size_t blen)\n{\n\tint i, dlen;\n\n\tif (str == NULL)\n\t\treturn -EINVAL;\n\n\tmemset(buf, 0, blen);\n\n\tdlen = MIN((strlen(str) / 2), blen);\n\n\tfor (i = 0; i < dlen; i++)\n\t\tsscanf(str + (i * 2), \"%02hhX\", &buf[i]);\n\n\treturn 0;\n}\n\nstatic bool is_blocked_key(uint8_t key_type, uint8_t *key_value)\n{\n\tuint32_t i = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(blocked_keys); ++i) {\n\t\tif (key_type == blocked_keys[i].type &&\n\t\t\t\t!memcmp(blocked_keys[i].val, key_value,\n\t\t\t\t\t\tsizeof(blocked_keys[i].val)))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic struct link_key_info *get_key_info(GKeyFile *key_file, const char *peer)\n{\n\tstruct link_key_info *info = NULL;\n\tchar *str;\n\n\tstr = g_key_file_get_string(key_file, \"LinkKey\", \"Key\", NULL);\n\tif (!str || strlen(str) < 32)\n\t\tgoto failed;\n\n\tinfo = g_new0(struct link_key_info, 1);\n\n\tstr2ba(peer, &info->bdaddr);\n\n\tif (!strncmp(str, \"0x\", 2))\n\t\tstr2buf(&str[2], info->key, sizeof(info->key));\n\telse\n\t\tstr2buf(&str[0], info->key, sizeof(info->key));\n\n\tinfo->type = g_key_file_get_integer(key_file, \"LinkKey\", \"Type\", NULL);\n\tinfo->pin_len = g_key_file_get_integer(key_file, \"LinkKey\", \"PINLength\",\n\t\t\t\t\t\tNULL);\n\n\tinfo->is_blocked = is_blocked_key(HCI_BLOCKED_KEY_TYPE_LINKKEY,\n\t\t\t\t\t\t\t\tinfo->key);\n\nfailed:\n\tg_free(str);\n\n\treturn info;\n}\n\nstatic struct smp_ltk_info *get_ltk(GKeyFile *key_file, const char *peer,\n\t\t\t\t\tuint8_t peer_type, const char *group)\n{\n\tstruct smp_ltk_info *ltk = NULL;\n\tGError *gerr = NULL;\n\tbool master;\n\tchar *key;\n\tchar *rand = NULL;\n\n\tkey = g_key_file_get_string(key_file, group, \"Key\", NULL);\n\tif (!key || strlen(key) < 32)\n\t\tgoto failed;\n\n\trand = g_key_file_get_string(key_file, group, \"Rand\", NULL);\n\tif (!rand)\n\t\tgoto failed;\n\n\tltk = g_new0(struct smp_ltk_info, 1);\n\n\t/* Default to assuming a master key */\n\tltk->master = true;\n\n\tstr2ba(peer, &ltk->bdaddr);\n\tltk->bdaddr_type = peer_type;\n\n\t/*\n\t * Long term keys should respond to an identity address which can\n\t * either be a public address or a random static address. Keys\n\t * stored for resolvable random and unresolvable random addresses\n\t * are ignored.\n\t *\n\t * This is an extra sanity check for older kernel versions or older\n\t * daemons that might have been instructed to store long term keys\n\t * for these temporary addresses.\n\t */\n\tif (ltk->bdaddr_type == BDADDR_LE_RANDOM &&\n\t\t\t\t\t(ltk->bdaddr.b[5] & 0xc0) != 0xc0) {\n\t\tg_free(ltk);\n\t\tltk = NULL;\n\t\tgoto failed;\n\t}\n\n\tif (!strncmp(key, \"0x\", 2))\n\t\tstr2buf(&key[2], ltk->val, sizeof(ltk->val));\n\telse\n\t\tstr2buf(&key[0], ltk->val, sizeof(ltk->val));\n\n\tif (!strncmp(rand, \"0x\", 2)) {\n\t\tuint64_t rand_le;\n\t\tstr2buf(&rand[2], (uint8_t *) &rand_le, sizeof(rand_le));\n\t\tltk->rand = le64_to_cpu(rand_le);\n\t} else {\n\t\tsscanf(rand, \"%\" PRIu64, &ltk->rand);\n\t}\n\n\tltk->authenticated = g_key_file_get_integer(key_file, group,\n\t\t\t\t\t\t\t\"Authenticated\", NULL);\n\tltk->enc_size = g_key_file_get_integer(key_file, group, \"EncSize\",\n\t\t\t\t\t\t\t\t\tNULL);\n\tltk->ediv = g_key_file_get_integer(key_file, group, \"EDiv\", NULL);\n\n\tmaster = g_key_file_get_boolean(key_file, group, \"Master\", &gerr);\n\tif (gerr)\n\t\tg_error_free(gerr);\n\telse\n\t\tltk->master = master;\n\n\tltk->is_blocked = is_blocked_key(HCI_BLOCKED_KEY_TYPE_LTK,\n\t\t\t\t\t\t\t\tltk->val);\n\nfailed:\n\tg_free(key);\n\tg_free(rand);\n\n\treturn ltk;\n}\n\nstatic struct smp_ltk_info *get_ltk_info(GKeyFile *key_file, const char *peer,\n\t\t\t\t\t\t\tuint8_t bdaddr_type)\n{\n\tDBG(\"%s\", peer);\n\n\treturn get_ltk(key_file, peer, bdaddr_type, \"LongTermKey\");\n}\n\nstatic struct smp_ltk_info *get_slave_ltk_info(GKeyFile *key_file,\n\t\t\t\t\t\t\tconst char *peer,\n\t\t\t\t\t\t\tuint8_t bdaddr_type)\n{\n\tstruct smp_ltk_info *ltk;\n\n\tDBG(\"%s\", peer);\n\n\tltk = get_ltk(key_file, peer, bdaddr_type, \"SlaveLongTermKey\");\n\tif (ltk)\n\t\tltk->master = false;\n\n\treturn ltk;\n}\n\nstatic struct irk_info *get_irk_info(GKeyFile *key_file, const char *peer,\n\t\t\t\t\t\t\tuint8_t bdaddr_type)\n{\n\tstruct irk_info *irk = NULL;\n\tchar *str;\n\n\tstr = g_key_file_get_string(key_file, \"IdentityResolvingKey\", \"Key\", NULL);\n\tif (!str || strlen(str) < 32)\n\t\tgoto failed;\n\n\tirk = g_new0(struct irk_info, 1);\n\n\tstr2ba(peer, &irk->bdaddr);\n\tirk->bdaddr_type = bdaddr_type;\n\n\tif (!strncmp(str, \"0x\", 2))\n\t\tstr2buf(&str[2], irk->val, sizeof(irk->val));\n\telse\n\t\tstr2buf(&str[0], irk->val, sizeof(irk->val));\n\n\tirk->is_blocked = is_blocked_key(HCI_BLOCKED_KEY_TYPE_LINKKEY,\n\t\t\t\t\t\t\t\tirk->val);\n\nfailed:\n\tg_free(str);\n\n\treturn irk;\n}\n\nstatic struct conn_param *get_conn_param(GKeyFile *key_file, const char *peer,\n\t\t\t\t\t\t\tuint8_t bdaddr_type)\n{\n\tstruct conn_param *param;\n\n\tif (!g_key_file_has_group(key_file, \"ConnectionParameters\"))\n\t\treturn NULL;\n\n\tparam = g_new0(struct conn_param, 1);\n\n\tparam->min_interval = g_key_file_get_integer(key_file,\n\t\t\t\t\t\t\t\"ConnectionParameters\",\n\t\t\t\t\t\t\t\"MinInterval\", NULL);\n\tparam->max_interval = g_key_file_get_integer(key_file,\n\t\t\t\t\t\t\t\"ConnectionParameters\",\n\t\t\t\t\t\t\t\"MaxInterval\", NULL);\n\tparam->latency = g_key_file_get_integer(key_file,\n\t\t\t\t\t\t\t\"ConnectionParameters\",\n\t\t\t\t\t\t\t\"Latency\", NULL);\n\tparam->timeout = g_key_file_get_integer(key_file,\n\t\t\t\t\t\t\t\"ConnectionParameters\",\n\t\t\t\t\t\t\t\"Timeout\", NULL);\n\tstr2ba(peer, &param->bdaddr);\n\tparam->bdaddr_type = bdaddr_type;\n\n\treturn param;\n}\n\nstatic int generate_and_write_irk(uint8_t *irk, GKeyFile *key_file,\n\t\t\t\t\t\t\tconst char *filename)\n{\n\tstruct bt_crypto *crypto;\n\tchar str_irk_out[33];\n\tgsize length = 0;\n\tchar *str;\n\tint i;\n\n\tcrypto = bt_crypto_new();\n\tif (!crypto) {\n\t\terror(\"Failed to open crypto\");\n\t\treturn -1;\n\t}\n\n\tif (!bt_crypto_random_bytes(crypto, irk, 16)) {\n\t\terror(\"Failed to generate IRK\");\n\t\tbt_crypto_unref(crypto);\n\t\treturn -1;\n\t}\n\n\tbt_crypto_unref(crypto);\n\n\tfor (i = 0; i < 16; i++)\n\t\tsprintf(str_irk_out + (i * 2), \"%02x\", irk[i]);\n\n\tstr_irk_out[32] = '\\0';\n\tinfo(\"Generated IRK successfully\");\n\n\tg_key_file_set_string(key_file, \"General\", \"IdentityResolvingKey\",\n\t\t\t\t\t\t\t\tstr_irk_out);\n\tstr = g_key_file_to_data(key_file, &length, NULL);\n\tg_file_set_contents(filename, str, length, NULL);\n\tg_free(str);\n\tDBG(\"Generated IRK written to file\");\n\treturn 0;\n}\n\nstatic int load_irk(struct btd_adapter *adapter, uint8_t *irk)\n{\n\tchar filename[PATH_MAX];\n\tGKeyFile *key_file;\n\tchar *str_irk;\n\tint ret;\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/identity\",\n\t\t\t\t\tbtd_adapter_get_storage_dir(adapter));\n\n\tkey_file = g_key_file_new();\n\tg_key_file_load_from_file(key_file, filename, 0, NULL);\n\n\tstr_irk = g_key_file_get_string(key_file, \"General\",\n\t\t\t\t\t\t\"IdentityResolvingKey\", NULL);\n\tif (!str_irk) {\n\t\tinfo(\"No IRK stored\");\n\t\tret = generate_and_write_irk(irk, key_file, filename);\n\t\tg_key_file_free(key_file);\n\t\treturn ret;\n\t}\n\n\tg_key_file_free(key_file);\n\n\tif (strlen(str_irk) != 32 || str2buf(str_irk, irk, 16)) {\n\t\t/* TODO re-create new IRK here? */\n\t\terror(\"Invalid IRK format, disabling privacy\");\n\t\tg_free(str_irk);\n\t\treturn -1;\n\t}\n\n\tg_free(str_irk);\n\tDBG(\"Successfully read IRK from file\");\n\treturn 0;\n}\n\nstatic void set_privacy_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\tbtd_error(adapter->dev_id, \"Failed to set privacy: %s (0x%02x)\",\n\t\t\t\t\t\tmgmt_errstr(status), status);\n\t\treturn;\n\t}\n\n\tDBG(\"Successfuly set privacy for index %u\", adapter->dev_id);\n}\n\nstatic int set_privacy(struct btd_adapter *adapter, uint8_t privacy)\n{\n\tstruct mgmt_cp_set_privacy cp;\n\n\tmemset(&cp, 0, sizeof(cp));\n\n\tif (privacy) {\n\t\tuint8_t irk[16];\n\n\t\tif (load_irk(adapter, irk) == 0) {\n\t\t\tcp.privacy = privacy;\n\t\t\tmemcpy(cp.irk, irk, 16);\n\t\t}\n\t}\n\n\tDBG(\"sending set privacy command for index %u\", adapter->dev_id);\n\tDBG(\"setting privacy mode 0x%02x for index %u\", cp.privacy,\n\t\t\t\t\t\t\tadapter->dev_id);\n\n\tif (mgmt_send(adapter->mgmt, MGMT_OP_SET_PRIVACY,\n\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\tset_privacy_complete, adapter, NULL) > 0)\n\t\treturn 0;\n\n\tbtd_error(adapter->dev_id, \"Failed to set privacy for index %u\",\n\t\t\t\t\t\t\tadapter->dev_id);\n\n\treturn -1;\n}\n\nstatic void load_link_keys_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\"Failed to load link keys for hci%u: %s (0x%02x)\",\n\t\t\t\tadapter->dev_id, mgmt_errstr(status), status);\n\t\treturn;\n\t}\n\n\tDBG(\"link keys loaded for hci%u\", adapter->dev_id);\n}\n\nstatic void load_link_keys(struct btd_adapter *adapter, GSList *keys,\n\t\t\t\t\t\t\tbool debug_keys)\n{\n\tstruct mgmt_cp_load_link_keys *cp;\n\tstruct mgmt_link_key_info *key;\n\tsize_t key_count, cp_size;\n\tunsigned int id;\n\tGSList *l;\n\n\t/*\n\t * If the controller does not support BR/EDR operation,\n\t * there is no point in trying to load the link keys into\n\t * the kernel.\n\t *\n\t * This is an optimization for Low Energy only controllers.\n\t */\n\tif (!(adapter->supported_settings & MGMT_SETTING_BREDR))\n\t\treturn;\n\n\tkey_count = g_slist_length(keys);\n\n\tDBG(\"hci%u keys %zu debug_keys %d\", adapter->dev_id, key_count,\n\t\t\t\t\t\t\t\tdebug_keys);\n\n\tcp_size = sizeof(*cp) + (key_count * sizeof(*key));\n\n\tcp = g_try_malloc0(cp_size);\n\tif (cp == NULL) {\n\t\tbtd_error(adapter->dev_id, \"No memory for link keys for hci%u\",\n\t\t\t\t\t\t\tadapter->dev_id);\n\t\treturn;\n\t}\n\n\t/*\n\t * Even if the list of stored keys is empty, it is important to\n\t * load an empty list into the kernel. That way it is ensured\n\t * that no old keys from a previous daemon are present.\n\t *\n\t * In addition it is also the only way to toggle the different\n\t * behavior for debug keys.\n\t */\n\tcp->debug_keys = debug_keys;\n\tcp->key_count = htobs(key_count);\n\n\tfor (l = keys, key = cp->keys; l != NULL; l = g_slist_next(l), key++) {\n\t\tstruct link_key_info *info = l->data;\n\n\t\tbacpy(&key->addr.bdaddr, &info->bdaddr);\n\t\tkey->addr.type = BDADDR_BREDR;\n\t\tkey->type = info->type;\n\t\tmemcpy(key->val, info->key, 16);\n\t\tkey->pin_len = info->pin_len;\n\t}\n\n\tid = mgmt_send(adapter->mgmt, MGMT_OP_LOAD_LINK_KEYS,\n\t\t\t\tadapter->dev_id, cp_size, cp,\n\t\t\t\tload_link_keys_complete, adapter, NULL);\n\n\tg_free(cp);\n\n\tif (id == 0)\n\t\tbtd_error(adapter->dev_id, \"Failed to load link keys for hci%u\",\n\t\t\t\t\t\t\tadapter->dev_id);\n}\n\nstatic bool load_ltks_timeout(gpointer user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\tbtd_error(adapter->dev_id, \"Loading LTKs timed out for hci%u\",\n\t\t\t\t\t\t\tadapter->dev_id);\n\n\tadapter->load_ltks_timeout = 0;\n\n\tmgmt_cancel(adapter->mgmt, adapter->load_ltks_id);\n\tadapter->load_ltks_id = 0;\n\n\treturn FALSE;\n}\n\nstatic void load_ltks_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Failed to load LTKs for hci%u: %s (0x%02x)\",\n\t\t\t\tadapter->dev_id, mgmt_errstr(status), status);\n\t}\n\n\tadapter->load_ltks_id = 0;\n\n\ttimeout_remove(adapter->load_ltks_timeout);\n\tadapter->load_ltks_timeout = 0;\n\n\tDBG(\"LTKs loaded for hci%u\", adapter->dev_id);\n}\n\nstatic void load_ltks(struct btd_adapter *adapter, GSList *keys)\n{\n\tstruct mgmt_cp_load_long_term_keys *cp;\n\tstruct mgmt_ltk_info *key;\n\tsize_t key_count, cp_size;\n\tGSList *l;\n\n\t/*\n\t * If the controller does not support Low Energy operation,\n\t * there is no point in trying to load the long term keys\n\t * into the kernel.\n\t *\n\t * While there is no harm in loading keys into the kernel,\n\t * this is an optimization to avoid a confusing warning\n\t * message when the loading of the keys timed out due to\n\t * a kernel bug (see comment below).\n\t */\n\tif (!(adapter->supported_settings & MGMT_SETTING_LE))\n\t\treturn;\n\n\tkey_count = g_slist_length(keys);\n\n\tDBG(\"hci%u keys %zu\", adapter->dev_id, key_count);\n\n\tcp_size = sizeof(*cp) + (key_count * sizeof(*key));\n\n\tcp = g_try_malloc0(cp_size);\n\tif (cp == NULL) {\n\t\tbtd_error(adapter->dev_id, \"No memory for LTKs for hci%u\",\n\t\t\t\t\t\t\tadapter->dev_id);\n\t\treturn;\n\t}\n\n\t/*\n\t * Even if the list of stored keys is empty, it is important to\n\t * load an empty list into the kernel. That way it is ensured\n\t * that no old keys from a previous daemon are present.\n\t */\n\tcp->key_count = htobs(key_count);\n\n\tfor (l = keys, key = cp->keys; l != NULL; l = g_slist_next(l), key++) {\n\t\tstruct smp_ltk_info *info = l->data;\n\n\t\tbacpy(&key->addr.bdaddr, &info->bdaddr);\n\t\tkey->addr.type = info->bdaddr_type;\n\t\tmemcpy(key->val, info->val, sizeof(info->val));\n\t\tkey->rand = cpu_to_le64(info->rand);\n\t\tkey->ediv = cpu_to_le16(info->ediv);\n\t\tkey->type = info->authenticated;\n\t\tkey->master = info->master;\n\t\tkey->enc_size = info->enc_size;\n\t}\n\n\tadapter->load_ltks_id = mgmt_send(adapter->mgmt,\n\t\t\t\t\tMGMT_OP_LOAD_LONG_TERM_KEYS,\n\t\t\t\t\tadapter->dev_id, cp_size, cp,\n\t\t\t\t\tload_ltks_complete, adapter, NULL);\n\n\tg_free(cp);\n\n\tif (adapter->load_ltks_id == 0) {\n\t\tbtd_error(adapter->dev_id, \"Failed to load LTKs for hci%u\",\n\t\t\t\t\t\t\tadapter->dev_id);\n\t\treturn;\n\t}\n\n\t/*\n\t * This timeout handling is needed since the kernel is stupid\n\t * and forgets to send a command complete response. However in\n\t * case of failures it does send a command status.\n\t */\n\tadapter->load_ltks_timeout = timeout_add_seconds(2,\n\t\t\t\t\t\tload_ltks_timeout, adapter,\n\t\t\t\t\t\tNULL);\n}\n\nstatic void load_irks_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\tif (status == MGMT_STATUS_UNKNOWN_COMMAND) {\n\t\tbtd_info(adapter->dev_id,\n\t\t\t\"Load IRKs failed: Kernel doesn't support LE Privacy\");\n\t\treturn;\n\t}\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Failed to load IRKs for hci%u: %s (0x%02x)\",\n\t\t\t\tadapter->dev_id, mgmt_errstr(status), status);\n\t\treturn;\n\t}\n\n\tDBG(\"IRKs loaded for hci%u\", adapter->dev_id);\n}\n\nstatic void load_irks(struct btd_adapter *adapter, GSList *irks)\n{\n\tstruct mgmt_cp_load_irks *cp;\n\tstruct mgmt_irk_info *irk;\n\tsize_t irk_count, cp_size;\n\tunsigned int id;\n\tGSList *l;\n\n\t/*\n\t * If the controller does not support LE Privacy operation,\n\t * there is no support for loading identity resolving keys\n\t * into the kernel.\n\t */\n\tif (!(adapter->supported_settings & MGMT_SETTING_PRIVACY))\n\t\treturn;\n\n\tirk_count = g_slist_length(irks);\n\n\tDBG(\"hci%u irks %zu\", adapter->dev_id, irk_count);\n\n\tcp_size = sizeof(*cp) + (irk_count * sizeof(*irk));\n\n\tcp = g_try_malloc0(cp_size);\n\tif (cp == NULL) {\n\t\tbtd_error(adapter->dev_id, \"No memory for IRKs for hci%u\",\n\t\t\t\t\t\t\tadapter->dev_id);\n\t\treturn;\n\t}\n\n\t/*\n\t * Even if the list of stored keys is empty, it is important to\n\t * load an empty list into the kernel. That way we tell the\n\t * kernel that we are able to handle New IRK events.\n\t */\n\tcp->irk_count = htobs(irk_count);\n\n\tfor (l = irks, irk = cp->irks; l != NULL; l = g_slist_next(l), irk++) {\n\t\tstruct irk_info *info = l->data;\n\n\t\tbacpy(&irk->addr.bdaddr, &info->bdaddr);\n\t\tirk->addr.type = info->bdaddr_type;\n\t\tmemcpy(irk->val, info->val, sizeof(irk->val));\n\t}\n\n\tid = mgmt_send(adapter->mgmt, MGMT_OP_LOAD_IRKS, adapter->dev_id,\n\t\t\tcp_size, cp, load_irks_complete, adapter, NULL);\n\n\tg_free(cp);\n\n\tif (id == 0)\n\t\tbtd_error(adapter->dev_id, \"Failed to IRKs for hci%u\",\n\t\t\t\t\t\t\tadapter->dev_id);\n}\n\nstatic void load_conn_params_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\"hci%u Load Connection Parameters failed: %s (0x%02x)\",\n\t\t\t\tadapter->dev_id, mgmt_errstr(status), status);\n\t\treturn;\n\t}\n\n\tDBG(\"Connection Parameters loaded for hci%u\", adapter->dev_id);\n}\n\nstatic void load_conn_params(struct btd_adapter *adapter, GSList *params)\n{\n\tstruct mgmt_cp_load_conn_param *cp;\n\tstruct mgmt_conn_param *param;\n\tsize_t param_count, cp_size;\n\tunsigned int id;\n\tGSList *l;\n\n\t/*\n\t * If the controller does not support Low Energy operation,\n\t * there is no point in trying to load the connection\n\t * parameters into the kernel.\n\t */\n\tif (!(adapter->supported_settings & MGMT_SETTING_LE))\n\t\treturn;\n\n\tparam_count = g_slist_length(params);\n\n\tDBG(\"hci%u conn params %zu\", adapter->dev_id, param_count);\n\n\tcp_size = sizeof(*cp) + (param_count * sizeof(*param));\n\n\tcp = g_try_malloc0(cp_size);\n\tif (cp == NULL) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\"Failed to allocate memory for connection parameters\");\n\t\treturn;\n\t}\n\n\tcp->param_count = htobs(param_count);\n\n\tfor (l = params, param = cp->params; l; l = g_slist_next(l), param++) {\n\t\tstruct conn_param *info = l->data;\n\n\t\tbacpy(&param->addr.bdaddr, &info->bdaddr);\n\t\tparam->addr.type = info->bdaddr_type;\n\t\tparam->min_interval = htobs(info->min_interval);\n\t\tparam->max_interval = htobs(info->max_interval);\n\t\tparam->latency = htobs(info->latency);\n\t\tparam->timeout = htobs(info->timeout);\n\t}\n\n\tid = mgmt_send(adapter->mgmt, MGMT_OP_LOAD_CONN_PARAM, adapter->dev_id,\n\t\t\tcp_size, cp, load_conn_params_complete, adapter, NULL);\n\n\tg_free(cp);\n\n\tif (id == 0)\n\t\tbtd_error(adapter->dev_id, \"Load connection parameters failed\");\n}\n\nstatic uint8_t get_le_addr_type(GKeyFile *keyfile)\n{\n\tuint8_t addr_type;\n\tchar *type;\n\n\ttype = g_key_file_get_string(keyfile, \"General\", \"AddressType\", NULL);\n\tif (!type)\n\t\treturn BDADDR_LE_PUBLIC;\n\n\tif (g_str_equal(type, \"public\"))\n\t\taddr_type = BDADDR_LE_PUBLIC;\n\telse if (g_str_equal(type, \"static\"))\n\t\taddr_type = BDADDR_LE_RANDOM;\n\telse\n\t\taddr_type = BDADDR_LE_PUBLIC;\n\n\tg_free(type);\n\n\treturn addr_type;\n}\n\nstatic void probe_devices(void *user_data)\n{\n\tstruct btd_device *device = user_data;\n\n\tdevice_probe_profiles(device, btd_device_get_uuids(device));\n}\n\nstatic bool load_bredr_defaults(struct btd_adapter *adapter,\n\t\t\t\tstruct mgmt_tlv_list *list,\n\t\t\t\tstruct btd_br_defaults *defaults)\n{\n\tif (btd_opts.mode == BT_MODE_LE)\n\t\treturn true;\n\n\tif (defaults->page_scan_type != 0xFFFF) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x0000,\n\t\t\t\t\t&defaults->page_scan_type))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->page_scan_interval) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x0001,\n\t\t\t\t\t&defaults->page_scan_interval))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->page_scan_win) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x0002,\n\t\t\t\t\t&defaults->page_scan_win))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->scan_type != 0xFFFF) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x0003,\n\t\t\t\t\t&defaults->scan_type))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->scan_interval) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x0004,\n\t\t\t\t\t&defaults->scan_interval))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->scan_win) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x0005,\n\t\t\t\t\t&defaults->scan_win))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->link_supervision_timeout) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x0006,\n\t\t\t\t\t&defaults->link_supervision_timeout))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->page_timeout) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x0007,\n\t\t\t\t\t&defaults->page_timeout))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->min_sniff_interval) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x0008,\n\t\t\t\t\t&defaults->min_sniff_interval))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->max_sniff_interval) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x0009,\n\t\t\t\t\t&defaults->max_sniff_interval))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool load_le_defaults(struct btd_adapter *adapter,\n\t\t\t\tstruct mgmt_tlv_list *list,\n\t\t\t\tstruct btd_le_defaults *defaults)\n{\n\tif (btd_opts.mode == BT_MODE_BREDR)\n\t\treturn true;\n\n\tif (defaults->min_adv_interval) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x000a,\n\t\t\t\t\t&defaults->min_adv_interval))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->max_adv_interval) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x000b,\n\t\t\t\t\t&defaults->max_adv_interval))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->adv_rotation_interval) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x000c,\n\t\t\t\t\t&defaults->adv_rotation_interval))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->scan_interval_autoconnect) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x000d,\n\t\t\t\t\t&defaults->scan_interval_autoconnect))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->scan_win_autoconnect) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x000e,\n\t\t\t\t\t&defaults->scan_win_autoconnect))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->scan_interval_suspend) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x000f,\n\t\t\t\t\t&defaults->scan_interval_suspend))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->scan_win_suspend) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x0010,\n\t\t\t\t\t&defaults->scan_win_suspend))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->scan_interval_discovery) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x0011,\n\t\t\t\t\t&defaults->scan_interval_discovery))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->scan_win_discovery) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x0012,\n\t\t\t\t\t&defaults->scan_win_discovery))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->scan_interval_adv_monitor) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x0013,\n\t\t\t\t\t&defaults->scan_interval_adv_monitor))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->scan_win_adv_monitor) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x0014,\n\t\t\t\t\t&defaults->scan_win_adv_monitor))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->scan_interval_connect) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x0015,\n\t\t\t\t\t&defaults->scan_interval_connect))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->scan_win_connect) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x0016,\n\t\t\t\t\t&defaults->scan_win_connect))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->min_conn_interval) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x0017,\n\t\t\t\t\t&defaults->min_conn_interval))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->max_conn_interval) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x0018,\n\t\t\t\t\t&defaults->max_conn_interval))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->conn_latency) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x0019,\n\t\t\t\t\t&defaults->conn_latency))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->conn_lsto) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x001a,\n\t\t\t\t\t&defaults->conn_lsto))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->autoconnect_timeout) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x001b,\n\t\t\t\t\t&defaults->autoconnect_timeout))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->advmon_allowlist_scan_duration) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x001d,\n\t\t\t\t&defaults->advmon_allowlist_scan_duration))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->advmon_no_filter_scan_duration) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x001e,\n\t\t\t\t&defaults->advmon_no_filter_scan_duration))\n\t\t\treturn false;\n\t}\n\n\tif (defaults->enable_advmon_interleave_scan != 0xFF) {\n\t\tif (!mgmt_tlv_add_fixed(list, 0x001f,\n\t\t\t\t&defaults->enable_advmon_interleave_scan))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void load_defaults(struct btd_adapter *adapter)\n{\n\tstruct mgmt_tlv_list *list;\n\tunsigned int err = 0;\n\n\tif (!btd_opts.defaults.num_entries ||\n\t    !btd_has_kernel_features(KERNEL_SET_SYSTEM_CONFIG))\n\t\treturn;\n\n\tlist = mgmt_tlv_list_new();\n\n\tif (!load_bredr_defaults(adapter, list, &btd_opts.defaults.br))\n\t\tgoto done;\n\n\tif (!load_le_defaults(adapter, list, &btd_opts.defaults.le))\n\t\tgoto done;\n\n\terr = mgmt_send_tlv(adapter->mgmt, MGMT_OP_SET_DEF_SYSTEM_CONFIG,\n\t\t\tadapter->dev_id, list, NULL, NULL, NULL);\n\ndone:\n\tif (!err)\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Failed to set default system config for hci%u\",\n\t\t\t\tadapter->dev_id);\n\n\tmgmt_tlv_list_free(list);\n}\n\nstatic void load_devices(struct btd_adapter *adapter)\n{\n\tchar dirname[PATH_MAX];\n\tGSList *keys = NULL;\n\tGSList *ltks = NULL;\n\tGSList *irks = NULL;\n\tGSList *params = NULL;\n\tGSList *added_devices = NULL;\n\tDIR *dir;\n\tstruct dirent *entry;\n\n\tsnprintf(dirname, PATH_MAX, STORAGEDIR \"/%s\",\n\t\t\t\t\tbtd_adapter_get_storage_dir(adapter));\n\n\tdir = opendir(dirname);\n\tif (!dir) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Unable to open adapter storage directory: %s\",\n\t\t\t\t\t\t\t\tdirname);\n\t\treturn;\n\t}\n\n\twhile ((entry = readdir(dir)) != NULL) {\n\t\tstruct btd_device *device;\n\t\tchar filename[PATH_MAX];\n\t\tGKeyFile *key_file;\n\t\tstruct link_key_info *key_info;\n\t\tstruct smp_ltk_info *ltk_info;\n\t\tstruct smp_ltk_info *slave_ltk_info;\n\t\tGSList *list;\n\t\tstruct irk_info *irk_info;\n\t\tstruct conn_param *param;\n\t\tuint8_t bdaddr_type;\n\n\t\tif (entry->d_type == DT_UNKNOWN)\n\t\t\tentry->d_type = util_get_dt(dirname, entry->d_name);\n\n\t\tif (entry->d_type != DT_DIR || bachk(entry->d_name) < 0)\n\t\t\tcontinue;\n\n\t\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/%s/info\",\n\t\t\t\t\tbtd_adapter_get_storage_dir(adapter),\n\t\t\t\t\tentry->d_name);\n\n\t\tkey_file = g_key_file_new();\n\t\tg_key_file_load_from_file(key_file, filename, 0, NULL);\n\n\t\tkey_info = get_key_info(key_file, entry->d_name);\n\n\t\tbdaddr_type = get_le_addr_type(key_file);\n\n\t\tltk_info = get_ltk_info(key_file, entry->d_name, bdaddr_type);\n\n\t\tslave_ltk_info = get_slave_ltk_info(key_file, entry->d_name,\n\t\t\t\t\t\t\t\tbdaddr_type);\n\n\t\tirk_info = get_irk_info(key_file, entry->d_name, bdaddr_type);\n\n\t\t// If any key for the device is blocked, we discard all.\n\t\tif ((key_info && key_info->is_blocked) ||\n\t\t\t\t(ltk_info && ltk_info->is_blocked) ||\n\t\t\t\t(slave_ltk_info &&\n\t\t\t\t\tslave_ltk_info->is_blocked) ||\n\t\t\t\t(irk_info && irk_info->is_blocked)) {\n\n\t\t\tif (key_info) {\n\t\t\t\tg_free(key_info);\n\t\t\t\tkey_info = NULL;\n\t\t\t}\n\n\t\t\tif (ltk_info) {\n\t\t\t\tg_free(ltk_info);\n\t\t\t\tltk_info = NULL;\n\t\t\t}\n\n\t\t\tif (slave_ltk_info) {\n\t\t\t\tg_free(slave_ltk_info);\n\t\t\t\tslave_ltk_info = NULL;\n\t\t\t}\n\n\t\t\tif (irk_info) {\n\t\t\t\tg_free(irk_info);\n\t\t\t\tirk_info = NULL;\n\t\t\t}\n\n\t\t\tgoto free;\n\t\t}\n\n\t\tif (key_info)\n\t\t\tkeys = g_slist_append(keys, key_info);\n\n\t\tif (ltk_info)\n\t\t\tltks = g_slist_append(ltks, ltk_info);\n\n\t\tif (slave_ltk_info)\n\t\t\tltks = g_slist_append(ltks, slave_ltk_info);\n\n\t\tif (irk_info)\n\t\t\tirks = g_slist_append(irks, irk_info);\n\n\t\tparam = get_conn_param(key_file, entry->d_name, bdaddr_type);\n\t\tif (param)\n\t\t\tparams = g_slist_append(params, param);\n\n\t\tlist = g_slist_find_custom(adapter->devices, entry->d_name,\n\t\t\t\t\t\t\tdevice_address_cmp);\n\t\tif (list) {\n\t\t\tdevice = list->data;\n\t\t\tgoto device_exist;\n\t\t}\n\n\t\tdevice = device_create_from_storage(adapter, entry->d_name,\n\t\t\t\t\t\t\tkey_file);\n\t\tif (!device)\n\t\t\tgoto free;\n\n\t\tbtd_device_set_temporary(device, false);\n\t\tadapter->devices = g_slist_append(adapter->devices, device);\n\n\t\t/* TODO: register services from pre-loaded list of primaries */\n\n\t\tadded_devices = g_slist_append(added_devices, device);\n\ndevice_exist:\n\t\tif (key_info) {\n\t\t\tdevice_set_paired(device, BDADDR_BREDR);\n\t\t\tdevice_set_bonded(device, BDADDR_BREDR);\n\t\t}\n\n\t\tif (ltk_info || slave_ltk_info) {\n\t\t\tdevice_set_paired(device, bdaddr_type);\n\t\t\tdevice_set_bonded(device, bdaddr_type);\n\n\t\t\tif (ltk_info)\n\t\t\t\tdevice_set_ltk_enc_size(device,\n\t\t\t\t\t\t\tltk_info->enc_size);\n\t\t\telse if (slave_ltk_info)\n\t\t\t\tdevice_set_ltk_enc_size(device,\n\t\t\t\t\t\tslave_ltk_info->enc_size);\n\t\t}\n\nfree:\n\t\tg_key_file_free(key_file);\n\t}\n\n\tclosedir(dir);\n\n\tload_link_keys(adapter, keys, btd_opts.debug_keys);\n\tg_slist_free_full(keys, g_free);\n\n\tload_ltks(adapter, ltks);\n\tg_slist_free_full(ltks, g_free);\n\tload_irks(adapter, irks);\n\tg_slist_free_full(irks, g_free);\n\tload_conn_params(adapter, params);\n\tg_slist_free_full(params, g_free);\n\n\tg_slist_free_full(added_devices, probe_devices);\n}\n\nint btd_adapter_block_address(struct btd_adapter *adapter,\n\t\t\t\tconst bdaddr_t *bdaddr, uint8_t bdaddr_type)\n{\n\tstruct mgmt_cp_block_device cp;\n\tchar addr[18];\n\n\tba2str(bdaddr, addr);\n\tDBG(\"hci%u %s\", adapter->dev_id, addr);\n\n\tmemset(&cp, 0, sizeof(cp));\n\tbacpy(&cp.addr.bdaddr, bdaddr);\n\tcp.addr.type = bdaddr_type;\n\n\tif (mgmt_send(adapter->mgmt, MGMT_OP_BLOCK_DEVICE,\n\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\tNULL, NULL, NULL) > 0)\n\t\treturn 0;\n\n\treturn -EIO;\n}\n\nint btd_adapter_unblock_address(struct btd_adapter *adapter,\n\t\t\t\tconst bdaddr_t *bdaddr, uint8_t bdaddr_type)\n{\n\tstruct mgmt_cp_unblock_device cp;\n\tchar addr[18];\n\n\tba2str(bdaddr, addr);\n\tDBG(\"hci%u %s\", adapter->dev_id, addr);\n\n\tmemset(&cp, 0, sizeof(cp));\n\tbacpy(&cp.addr.bdaddr, bdaddr);\n\tcp.addr.type = bdaddr_type;\n\n\tif (mgmt_send(adapter->mgmt, MGMT_OP_UNBLOCK_DEVICE,\n\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\tNULL, NULL, NULL) > 0)\n\t\treturn 0;\n\n\treturn -EIO;\n}\n\nstatic int clear_blocked(struct btd_adapter *adapter)\n{\n\treturn btd_adapter_unblock_address(adapter, BDADDR_ANY, 0);\n}\n\nstatic void probe_driver(struct btd_adapter *adapter, gpointer user_data)\n{\n\tstruct btd_adapter_driver *driver = user_data;\n\tint err;\n\n\tif (driver->probe == NULL)\n\t\treturn;\n\n\terr = driver->probe(adapter);\n\tif (err < 0) {\n\t\tbtd_error(adapter->dev_id, \"%s: %s (%d)\", driver->name,\n\t\t\t\t\t\t\tstrerror(-err), -err);\n\t\treturn;\n\t}\n\n\tadapter->drivers = g_slist_prepend(adapter->drivers, driver);\n}\n\nstatic void load_drivers(struct btd_adapter *adapter)\n{\n\tGSList *l;\n\n\tfor (l = adapter_drivers; l; l = l->next)\n\t\tprobe_driver(adapter, l->data);\n}\n\nstatic void probe_profile(struct btd_profile *profile, void *data)\n{\n\tstruct btd_adapter *adapter = data;\n\tint err;\n\n\tif (profile->adapter_probe == NULL)\n\t\treturn;\n\n\terr = profile->adapter_probe(profile, adapter);\n\tif (err < 0) {\n\t\tbtd_error(adapter->dev_id, \"%s: %s (%d)\", profile->name,\n\t\t\t\t\t\t\tstrerror(-err), -err);\n\t\treturn;\n\t}\n\n\tadapter->profiles = g_slist_prepend(adapter->profiles, profile);\n}\n\nvoid adapter_add_profile(struct btd_adapter *adapter, gpointer p)\n{\n\tstruct btd_profile *profile = p;\n\n\tif (!adapter->initialized)\n\t\treturn;\n\n\tprobe_profile(profile, adapter);\n\n\tg_slist_foreach(adapter->devices, device_probe_profile, profile);\n}\n\nvoid adapter_remove_profile(struct btd_adapter *adapter, gpointer p)\n{\n\tstruct btd_profile *profile = p;\n\n\tif (!adapter->initialized)\n\t\treturn;\n\n\tif (profile->device_remove)\n\t\tg_slist_foreach(adapter->devices, device_remove_profile, p);\n\n\tadapter->profiles = g_slist_remove(adapter->profiles, profile);\n\n\tif (profile->adapter_remove)\n\t\tprofile->adapter_remove(profile, adapter);\n}\n\nstatic void adapter_add_connection(struct btd_adapter *adapter,\n\t\t\t\t\t\tstruct btd_device *device,\n\t\t\t\t\t\tuint8_t bdaddr_type)\n{\n\tdevice_add_connection(device, bdaddr_type);\n\n\tif (g_slist_find(adapter->connections, device)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Device is already marked as connected\");\n\t\treturn;\n\t}\n\n\tadapter->connections = g_slist_append(adapter->connections, device);\n}\n\nstatic void get_connections_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tconst struct mgmt_rp_get_connections *rp = param;\n\tuint16_t i, conn_count;\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Failed to get connections: %s (0x%02x)\",\n\t\t\t\t\t\tmgmt_errstr(status), status);\n\t\treturn;\n\t}\n\n\tif (length < sizeof(*rp)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Wrong size of get connections response\");\n\t\treturn;\n\t}\n\n\tconn_count = btohs(rp->conn_count);\n\n\tDBG(\"Connection count: %d\", conn_count);\n\n\tif (conn_count * sizeof(struct mgmt_addr_info) +\n\t\t\t\t\t\tsizeof(*rp) != length) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\"Incorrect packet size for get connections response\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < conn_count; i++) {\n\t\tconst struct mgmt_addr_info *addr = &rp->addr[i];\n\t\tstruct btd_device *device;\n\t\tchar address[18];\n\n\t\tba2str(&addr->bdaddr, address);\n\t\tDBG(\"Adding existing connection to %s\", address);\n\n\t\tdevice = btd_adapter_get_device(adapter, &addr->bdaddr,\n\t\t\t\t\t\t\t\taddr->type);\n\t\tif (device)\n\t\t\tadapter_add_connection(adapter, device, addr->type);\n\t}\n}\n\nstatic void load_connections(struct btd_adapter *adapter)\n{\n\tDBG(\"sending get connections command for index %u\", adapter->dev_id);\n\n\tif (mgmt_send(adapter->mgmt, MGMT_OP_GET_CONNECTIONS,\n\t\t\t\tadapter->dev_id, 0, NULL,\n\t\t\t\tget_connections_complete, adapter, NULL) > 0)\n\t\treturn;\n\n\tbtd_error(adapter->dev_id, \"Failed to get connections for index %u\",\n\t\t\t\t\t\t\tadapter->dev_id);\n}\n\nbool btd_adapter_get_pairable(struct btd_adapter *adapter)\n{\n\tif (adapter->current_settings & MGMT_SETTING_BONDABLE)\n\t\treturn true;\n\n\treturn false;\n}\n\nbool btd_adapter_get_powered(struct btd_adapter *adapter)\n{\n\tif ((adapter->current_settings & MGMT_SETTING_POWERED) &&\n\t\t\t!(adapter->pending_settings & MGMT_SETTING_POWERED))\n\t\treturn true;\n\n\treturn false;\n}\n\nbool btd_adapter_get_connectable(struct btd_adapter *adapter)\n{\n\tif (adapter->current_settings & MGMT_SETTING_CONNECTABLE)\n\t\treturn true;\n\n\treturn false;\n}\n\nbool btd_adapter_get_discoverable(struct btd_adapter *adapter)\n{\n\tif (adapter->current_settings & MGMT_SETTING_DISCOVERABLE)\n\t\treturn true;\n\n\treturn false;\n}\n\nbool btd_adapter_get_bredr(struct btd_adapter *adapter)\n{\n\tif (adapter->current_settings & MGMT_SETTING_BREDR)\n\t\treturn true;\n\n\treturn false;\n}\n\nstruct btd_gatt_database *btd_adapter_get_database(struct btd_adapter *adapter)\n{\n\tif (!adapter)\n\t\treturn NULL;\n\n\treturn adapter->database;\n}\n\nuint32_t btd_adapter_get_class(struct btd_adapter *adapter)\n{\n\treturn adapter->dev_class;\n}\n\nconst char *btd_adapter_get_name(struct btd_adapter *adapter)\n{\n\tif (adapter->stored_alias)\n\t\treturn adapter->stored_alias;\n\n\tif (adapter->system_name)\n\t\treturn adapter->system_name;\n\n\treturn NULL;\n}\n\nint adapter_connect_list_add(struct btd_adapter *adapter,\n\t\t\t\t\tstruct btd_device *device)\n{\n\t/*\n\t * If the adapter->connect_le device is getting added back to\n\t * the connect list it probably means that the connect attempt\n\t * failed and hence we should clear this pointer\n\t */\n\tif (device == adapter->connect_le)\n\t\tadapter->connect_le = NULL;\n\n\t/*\n\t * If kernel background scanning is supported then the\n\t * adapter_auto_connect_add() function is used to maintain what to\n\t * connect.\n\t */\n\tif (btd_has_kernel_features(KERNEL_CONN_CONTROL))\n\t\treturn 0;\n\n\tif (g_slist_find(adapter->connect_list, device)) {\n\t\tDBG(\"ignoring already added device %s\",\n\t\t\t\t\t\tdevice_get_path(device));\n\t\tgoto done;\n\t}\n\n\tif (!(adapter->supported_settings & MGMT_SETTING_LE)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\"Can't add %s to non-LE capable adapter connect list\",\n\t\t\t\t\t\tdevice_get_path(device));\n\t\treturn -ENOTSUP;\n\t}\n\n\tadapter->connect_list = g_slist_append(adapter->connect_list, device);\n\tDBG(\"%s added to %s's connect_list\", device_get_path(device),\n\t\t\t\t\t\t\tadapter->system_name);\n\ndone:\n\tif (!btd_adapter_get_powered(adapter))\n\t\treturn 0;\n\n\ttrigger_passive_scanning(adapter);\n\n\treturn 0;\n}\n\nvoid adapter_connect_list_remove(struct btd_adapter *adapter,\n\t\t\t\t\tstruct btd_device *device)\n{\n\t/*\n\t * If the adapter->connect_le device is being removed from the\n\t * connect list it means the connection was successful and hence\n\t * the pointer should be cleared\n\t */\n\tif (device == adapter->connect_le)\n\t\tadapter->connect_le = NULL;\n\n\tif (btd_has_kernel_features(KERNEL_CONN_CONTROL))\n\t\treturn;\n\n\tif (!g_slist_find(adapter->connect_list, device)) {\n\t\tDBG(\"device %s is not on the list, ignoring\",\n\t\t\t\t\t\tdevice_get_path(device));\n\t\treturn;\n\t}\n\n\tadapter->connect_list = g_slist_remove(adapter->connect_list, device);\n\tDBG(\"%s removed from %s's connect_list\", device_get_path(device),\n\t\t\t\t\t\t\tadapter->system_name);\n\n\tif (!adapter->connect_list) {\n\t\tstop_passive_scanning(adapter);\n\t\treturn;\n\t}\n\n\tif (!btd_adapter_get_powered(adapter))\n\t\treturn;\n\n\ttrigger_passive_scanning(adapter);\n}\n\nstatic void add_whitelist_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_rp_add_device *rp = param;\n\tstruct btd_adapter *adapter = user_data;\n\tstruct btd_device *dev;\n\tchar addr[18];\n\n\tif (length < sizeof(*rp)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Too small Add Device complete event\");\n\t\treturn;\n\t}\n\n\tba2str(&rp->addr.bdaddr, addr);\n\n\tdev = btd_adapter_find_device(adapter, &rp->addr.bdaddr,\n\t\t\t\t\t\t\trp->addr.type);\n\tif (!dev) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\"Add Device complete for unknown device %s\", addr);\n\t\treturn;\n\t}\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\t\"Failed to add device %s: %s (0x%02x)\",\n\t\t\t\t\taddr, mgmt_errstr(status), status);\n\t\treturn;\n\t}\n\n\tDBG(\"%s added to kernel whitelist\", addr);\n}\n\nvoid adapter_whitelist_add(struct btd_adapter *adapter, struct btd_device *dev)\n{\n\tstruct mgmt_cp_add_device cp;\n\n\tif (!btd_has_kernel_features(KERNEL_CONN_CONTROL))\n\t\treturn;\n\n\tmemset(&cp, 0, sizeof(cp));\n\tbacpy(&cp.addr.bdaddr, device_get_address(dev));\n\tcp.addr.type = BDADDR_BREDR;\n\tcp.action = 0x01;\n\n\tmgmt_send(adapter->mgmt, MGMT_OP_ADD_DEVICE,\n\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\tadd_whitelist_complete, adapter, NULL);\n}\n\nstatic void remove_whitelist_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_rp_remove_device *rp = param;\n\tchar addr[18];\n\n\tif (length < sizeof(*rp)) {\n\t\terror(\"Too small Remove Device complete event\");\n\t\treturn;\n\t}\n\n\tba2str(&rp->addr.bdaddr, addr);\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\terror(\"Failed to remove device %s: %s (0x%02x)\",\n\t\t\t\t\taddr, mgmt_errstr(status), status);\n\t\treturn;\n\t}\n\n\tDBG(\"%s removed from kernel whitelist\", addr);\n}\n\nvoid adapter_whitelist_remove(struct btd_adapter *adapter, struct btd_device *dev)\n{\n\tstruct mgmt_cp_remove_device cp;\n\n\tif (!btd_has_kernel_features(KERNEL_CONN_CONTROL))\n\t\treturn;\n\n\tmemset(&cp, 0, sizeof(cp));\n\tbacpy(&cp.addr.bdaddr, device_get_address(dev));\n\tcp.addr.type = BDADDR_BREDR;\n\n\tmgmt_send(adapter->mgmt, MGMT_OP_REMOVE_DEVICE,\n\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\tremove_whitelist_complete, adapter, NULL);\n}\n\nstatic void add_device_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_rp_add_device *rp = param;\n\tstruct btd_adapter *adapter = user_data;\n\tstruct btd_device *dev;\n\tchar addr[18];\n\n\tif (length < sizeof(*rp)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Too small Add Device complete event\");\n\t\treturn;\n\t}\n\n\tba2str(&rp->addr.bdaddr, addr);\n\n\tdev = btd_adapter_find_device(adapter, &rp->addr.bdaddr,\n\t\t\t\t\t\t\trp->addr.type);\n\tif (!dev) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\"Add Device complete for unknown device %s\", addr);\n\t\treturn;\n\t}\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\"Failed to add device %s (%u): %s (0x%02x)\",\n\t\t\taddr, rp->addr.type, mgmt_errstr(status), status);\n\t\tadapter->connect_list = g_slist_remove(adapter->connect_list,\n\t\t\t\t\t\t\t\t\tdev);\n\t\treturn;\n\t}\n\n\tDBG(\"%s (%u) added to kernel connect list\", addr, rp->addr.type);\n}\n\nvoid adapter_auto_connect_add(struct btd_adapter *adapter,\n\t\t\t\t\tstruct btd_device *device)\n{\n\tstruct mgmt_cp_add_device cp;\n\tconst bdaddr_t *bdaddr;\n\tuint8_t bdaddr_type;\n\tunsigned int id;\n\n\tif (!btd_has_kernel_features(KERNEL_CONN_CONTROL))\n\t\treturn;\n\n\tif (g_slist_find(adapter->connect_list, device)) {\n\t\tDBG(\"ignoring already added device %s\",\n\t\t\t\t\t\tdevice_get_path(device));\n\t\treturn;\n\t}\n\n\tbdaddr = device_get_address(device);\n\tbdaddr_type = btd_device_get_bdaddr_type(device);\n\n\tif (bdaddr_type == BDADDR_BREDR) {\n\t\tDBG(\"auto-connection feature is not avaiable for BR/EDR\");\n\t\treturn;\n\t}\n\n\tmemset(&cp, 0, sizeof(cp));\n\tbacpy(&cp.addr.bdaddr, bdaddr);\n\tcp.addr.type = bdaddr_type;\n\tcp.action = 0x02;\n\n\tid = mgmt_send(adapter->mgmt, MGMT_OP_ADD_DEVICE,\n\t\t\tadapter->dev_id, sizeof(cp), &cp, add_device_complete,\n\t\t\tadapter, NULL);\n\tif (id == 0)\n\t\treturn;\n\n\tadapter->connect_list = g_slist_append(adapter->connect_list, device);\n}\n\nstatic void set_device_wakeable_complete(uint8_t status, uint16_t length,\n\t\t\t\t\t const void *param, void *user_data)\n{\n\tconst struct mgmt_rp_set_device_flags *rp = param;\n\tstruct btd_adapter *adapter = user_data;\n\tstruct btd_device *dev;\n\tchar addr[18];\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\tbtd_error(adapter->dev_id, \"Set device flags return status: %s\",\n\t\t\t  mgmt_errstr(status));\n\t\treturn;\n\t}\n\n\tif (length < sizeof(*rp)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t  \"Too small Set Device Flags complete event: %d\",\n\t\t\t  length);\n\t\treturn;\n\t}\n\n\tba2str(&rp->addr.bdaddr, addr);\n\n\tdev = btd_adapter_find_device(adapter, &rp->addr.bdaddr, rp->addr.type);\n\tif (!dev) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t  \"Set Device Flags complete for unknown device %s\",\n\t\t\t  addr);\n\t\treturn;\n\t}\n\n\tdevice_set_wake_allowed_complete(dev);\n}\n\nvoid adapter_set_device_wakeable(struct btd_adapter *adapter,\n\t\t\t\t struct btd_device *device, bool wakeable)\n{\n\tstruct mgmt_cp_set_device_flags cp;\n\tconst bdaddr_t *bdaddr;\n\tuint8_t bdaddr_type;\n\n\tif (!btd_has_kernel_features(KERNEL_CONN_CONTROL))\n\t\treturn;\n\n\tbdaddr = device_get_address(device);\n\tbdaddr_type = btd_device_get_bdaddr_type(device);\n\n\tmemset(&cp, 0, sizeof(cp));\n\tbacpy(&cp.addr.bdaddr, bdaddr);\n\tcp.addr.type = bdaddr_type;\n\tcp.current_flags = btd_device_get_current_flags(device);\n\tif (wakeable)\n\t\tcp.current_flags |= DEVICE_FLAG_REMOTE_WAKEUP;\n\telse\n\t\tcp.current_flags &= ~DEVICE_FLAG_REMOTE_WAKEUP;\n\n\tmgmt_send(adapter->mgmt, MGMT_OP_SET_DEVICE_FLAGS, adapter->dev_id,\n\t\t  sizeof(cp), &cp, set_device_wakeable_complete, adapter, NULL);\n}\n\nstatic void device_flags_changed_callback(uint16_t index, uint16_t length,\n\t\t\t\t\t  const void *param, void *user_data)\n{\n\tconst struct mgmt_ev_device_flags_changed *ev = param;\n\tstruct btd_adapter *adapter = user_data;\n\tstruct btd_device *dev;\n\tchar addr[18];\n\n\tif (length < sizeof(*ev)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t  \"Too small Device Flags Changed event: %d\",\n\t\t\t  length);\n\t\treturn;\n\t}\n\n\tba2str(&ev->addr.bdaddr, addr);\n\n\tdev = btd_adapter_find_device(adapter, &ev->addr.bdaddr, ev->addr.type);\n\tif (!dev) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\"Device Flags Changed for unknown device %s\", addr);\n\t\treturn;\n\t}\n\n\tbtd_device_flags_changed(dev, ev->supported_flags, ev->current_flags);\n}\n\n\nstatic void remove_device_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_rp_remove_device *rp = param;\n\tchar addr[18];\n\n\tif (length < sizeof(*rp)) {\n\t\terror(\"Too small Remove Device complete event\");\n\t\treturn;\n\t}\n\n\tba2str(&rp->addr.bdaddr, addr);\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\terror(\"Failed to remove device %s (%u): %s (0x%02x)\",\n\t\t\taddr, rp->addr.type, mgmt_errstr(status), status);\n\t\treturn;\n\t}\n\n\tDBG(\"%s (%u) removed from kernel connect list\", addr, rp->addr.type);\n}\n\nvoid adapter_auto_connect_remove(struct btd_adapter *adapter,\n\t\t\t\t\tstruct btd_device *device)\n{\n\tstruct mgmt_cp_remove_device cp;\n\tconst bdaddr_t *bdaddr;\n\tuint8_t bdaddr_type;\n\tunsigned int id;\n\n\tif (!btd_has_kernel_features(KERNEL_CONN_CONTROL))\n\t\treturn;\n\n\tif (!g_slist_find(adapter->connect_list, device)) {\n\t\tDBG(\"ignoring not added device %s\", device_get_path(device));\n\t\treturn;\n\t}\n\n\tbdaddr = device_get_address(device);\n\tbdaddr_type = btd_device_get_bdaddr_type(device);\n\n\tif (bdaddr_type == BDADDR_BREDR) {\n\t\tDBG(\"auto-connection feature is not avaiable for BR/EDR\");\n\t\treturn;\n\t}\n\n\tmemset(&cp, 0, sizeof(cp));\n\tbacpy(&cp.addr.bdaddr, bdaddr);\n\tcp.addr.type = bdaddr_type;\n\n\tid = mgmt_send(adapter->mgmt, MGMT_OP_REMOVE_DEVICE,\n\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\tremove_device_complete, adapter, NULL);\n\tif (id == 0)\n\t\treturn;\n\n\tadapter->connect_list = g_slist_remove(adapter->connect_list, device);\n}\n\nstatic void adapter_start(struct btd_adapter *adapter)\n{\n\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\t\tADAPTER_INTERFACE, \"Powered\");\n\n\tDBG(\"adapter %s has been enabled\", adapter->path);\n\n\ttrigger_passive_scanning(adapter);\n}\n\nstatic void reply_pending_requests(struct btd_adapter *adapter)\n{\n\tGSList *l;\n\n\tif (!adapter)\n\t\treturn;\n\n\t/* pending bonding */\n\tfor (l = adapter->devices; l; l = l->next) {\n\t\tstruct btd_device *device = l->data;\n\n\t\tif (device_is_bonding(device, NULL))\n\t\t\tdevice_bonding_failed(device,\n\t\t\t\t\t\tHCI_OE_USER_ENDED_CONNECTION);\n\t}\n}\n\nstatic void remove_driver(gpointer data, gpointer user_data)\n{\n\tstruct btd_adapter_driver *driver = data;\n\tstruct btd_adapter *adapter = user_data;\n\n\tif (driver->remove)\n\t\tdriver->remove(adapter);\n}\n\nstatic void remove_profile(gpointer data, gpointer user_data)\n{\n\tstruct btd_profile *profile = data;\n\tstruct btd_adapter *adapter = user_data;\n\n\tif (profile->adapter_remove)\n\t\tprofile->adapter_remove(profile, adapter);\n}\n\nstatic void unload_drivers(struct btd_adapter *adapter)\n{\n\tg_slist_foreach(adapter->drivers, remove_driver, adapter);\n\tg_slist_free(adapter->drivers);\n\tadapter->drivers = NULL;\n\n\tg_slist_foreach(adapter->profiles, remove_profile, adapter);\n\tg_slist_free(adapter->profiles);\n\tadapter->profiles = NULL;\n}\n\nstatic void free_service_auth(gpointer data, gpointer user_data)\n{\n\tstruct service_auth *auth = data;\n\n\tg_free(auth);\n}\n\nstatic void remove_discovery_list(struct btd_adapter *adapter)\n{\n\tg_slist_free_full(adapter->set_filter_list, discovery_free);\n\tadapter->set_filter_list = NULL;\n\n\tg_slist_free_full(adapter->discovery_list, discovery_free);\n\tadapter->discovery_list = NULL;\n}\n\nstatic void adapter_free(gpointer user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\tDBG(\"%p\", adapter);\n\n\t/* Make sure the adapter's discovery list is cleaned up before freeing\n\t * the adapter.\n\t */\n\tremove_discovery_list(adapter);\n\n\tif (adapter->pairable_timeout_id > 0) {\n\t\ttimeout_remove(adapter->pairable_timeout_id);\n\t\tadapter->pairable_timeout_id = 0;\n\t}\n\n\tif (adapter->passive_scan_timeout > 0) {\n\t\ttimeout_remove(adapter->passive_scan_timeout);\n\t\tadapter->passive_scan_timeout = 0;\n\t}\n\n\tif (adapter->load_ltks_timeout > 0)\n\t\ttimeout_remove(adapter->load_ltks_timeout);\n\n\tif (adapter->confirm_name_timeout > 0)\n\t\ttimeout_remove(adapter->confirm_name_timeout);\n\n\tif (adapter->pair_device_timeout > 0)\n\t\ttimeout_remove(adapter->pair_device_timeout);\n\n\tif (adapter->auth_idle_id)\n\t\tg_source_remove(adapter->auth_idle_id);\n\n\tg_queue_foreach(adapter->auths, free_service_auth, NULL);\n\tg_queue_free(adapter->auths);\n\n\t/*\n\t * Unregister all handlers for this specific index since\n\t * the adapter bound to them is no longer valid.\n\t *\n\t * This also avoids having multiple instances of the same\n\t * handler in case indexes got removed and re-added.\n\t */\n\tmgmt_unregister_index(adapter->mgmt, adapter->dev_id);\n\n\t/*\n\t * Cancel all pending commands for this specific index\n\t * since the adapter bound to them is no longer valid.\n\t */\n\tmgmt_cancel_index(adapter->mgmt, adapter->dev_id);\n\n\tmgmt_unref(adapter->mgmt);\n\n\tsdp_list_free(adapter->services, NULL);\n\n\tg_slist_free(adapter->connections);\n\n\tg_free(adapter->path);\n\tg_free(adapter->name);\n\tg_free(adapter->short_name);\n\tg_free(adapter->system_name);\n\tg_free(adapter->stored_alias);\n\tg_free(adapter->current_alias);\n\tfree(adapter->modalias);\n\tg_free(adapter);\n}\n\nstruct btd_adapter *btd_adapter_ref(struct btd_adapter *adapter)\n{\n\t__sync_fetch_and_add(&adapter->ref_count, 1);\n\n\treturn adapter;\n}\n\nvoid btd_adapter_unref(struct btd_adapter *adapter)\n{\n\tif (__sync_sub_and_fetch(&adapter->ref_count, 1))\n\t\treturn;\n\n\tif (!adapter->path) {\n\t\tDBG(\"Freeing adapter %u\", adapter->dev_id);\n\n\t\tadapter_free(adapter);\n\t\treturn;\n\t}\n\n\tDBG(\"Freeing adapter %s\", adapter->path);\n\n\tg_dbus_unregister_interface(dbus_conn, adapter->path,\n\t\t\t\t\t\tADAPTER_INTERFACE);\n}\n\nstatic void convert_names_entry(char *key, char *value, void *user_data)\n{\n\tchar *address = user_data;\n\tchar *str = key;\n\tchar filename[PATH_MAX];\n\tGKeyFile *key_file;\n\tchar *data;\n\tgsize length = 0;\n\n\tif (strchr(key, '#'))\n\t\tstr[17] = '\\0';\n\n\tif (bachk(str) != 0)\n\t\treturn;\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/cache/%s\", address, str);\n\tcreate_file(filename, 0600);\n\n\tkey_file = g_key_file_new();\n\tg_key_file_load_from_file(key_file, filename, 0, NULL);\n\tg_key_file_set_string(key_file, \"General\", \"Name\", value);\n\n\tdata = g_key_file_to_data(key_file, &length, NULL);\n\tg_file_set_contents(filename, data, length, NULL);\n\tg_free(data);\n\n\tg_key_file_free(key_file);\n}\n\nstruct device_converter {\n\tchar *address;\n\tvoid (*cb)(GKeyFile *key_file, void *value);\n\tgboolean force;\n};\n\nstatic void set_device_type(GKeyFile *key_file, char type)\n{\n\tchar *techno;\n\tchar *addr_type = NULL;\n\tchar *str;\n\n\tswitch (type) {\n\tcase BDADDR_BREDR:\n\t\ttechno = \"BR/EDR\";\n\t\tbreak;\n\tcase BDADDR_LE_PUBLIC:\n\t\ttechno = \"LE\";\n\t\taddr_type = \"public\";\n\t\tbreak;\n\tcase BDADDR_LE_RANDOM:\n\t\ttechno = \"LE\";\n\t\taddr_type = \"static\";\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tstr = g_key_file_get_string(key_file, \"General\",\n\t\t\t\t\t\"SupportedTechnologies\", NULL);\n\tif (!str)\n\t\tg_key_file_set_string(key_file, \"General\",\n\t\t\t\t\t\"SupportedTechnologies\", techno);\n\telse if (!strstr(str, techno))\n\t\tg_key_file_set_string(key_file, \"General\",\n\t\t\t\t\t\"SupportedTechnologies\", \"BR/EDR;LE\");\n\n\tg_free(str);\n\n\tif (addr_type)\n\t\tg_key_file_set_string(key_file, \"General\", \"AddressType\",\n\t\t\t\t\taddr_type);\n}\n\nstatic void convert_aliases_entry(GKeyFile *key_file, void *value)\n{\n\tg_key_file_set_string(key_file, \"General\", \"Alias\", value);\n}\n\nstatic void convert_trusts_entry(GKeyFile *key_file, void *value)\n{\n\tg_key_file_set_boolean(key_file, \"General\", \"Trusted\", TRUE);\n}\n\nstatic void convert_classes_entry(GKeyFile *key_file, void *value)\n{\n\tg_key_file_set_string(key_file, \"General\", \"Class\", value);\n}\n\nstatic void convert_blocked_entry(GKeyFile *key_file, void *value)\n{\n\tg_key_file_set_boolean(key_file, \"General\", \"Blocked\", TRUE);\n}\n\nstatic void convert_did_entry(GKeyFile *key_file, void *value)\n{\n\tchar *vendor_str, *product_str, *version_str;\n\tuint16_t val;\n\n\tvendor_str = strchr(value, ' ');\n\tif (!vendor_str)\n\t\treturn;\n\n\t*(vendor_str++) = 0;\n\n\tif (g_str_equal(value, \"FFFF\"))\n\t\treturn;\n\n\tproduct_str = strchr(vendor_str, ' ');\n\tif (!product_str)\n\t\treturn;\n\n\t*(product_str++) = 0;\n\n\tversion_str = strchr(product_str, ' ');\n\tif (!version_str)\n\t\treturn;\n\n\t*(version_str++) = 0;\n\n\tval = (uint16_t) strtol(value, NULL, 16);\n\tg_key_file_set_integer(key_file, \"DeviceID\", \"Source\", val);\n\n\tval = (uint16_t) strtol(vendor_str, NULL, 16);\n\tg_key_file_set_integer(key_file, \"DeviceID\", \"Vendor\", val);\n\n\tval = (uint16_t) strtol(product_str, NULL, 16);\n\tg_key_file_set_integer(key_file, \"DeviceID\", \"Product\", val);\n\n\tval = (uint16_t) strtol(version_str, NULL, 16);\n\tg_key_file_set_integer(key_file, \"DeviceID\", \"Version\", val);\n}\n\nstatic void convert_linkkey_entry(GKeyFile *key_file, void *value)\n{\n\tchar *type_str, *length_str, *str;\n\tint val;\n\n\ttype_str = strchr(value, ' ');\n\tif (!type_str)\n\t\treturn;\n\n\t*(type_str++) = 0;\n\n\tlength_str = strchr(type_str, ' ');\n\tif (!length_str)\n\t\treturn;\n\n\t*(length_str++) = 0;\n\n\tstr = g_strconcat(\"0x\", value, NULL);\n\tg_key_file_set_string(key_file, \"LinkKey\", \"Key\", str);\n\tg_free(str);\n\n\tval = strtol(type_str, NULL, 16);\n\tg_key_file_set_integer(key_file, \"LinkKey\", \"Type\", val);\n\n\tval = strtol(length_str, NULL, 16);\n\tg_key_file_set_integer(key_file, \"LinkKey\", \"PINLength\", val);\n}\n\nstatic void convert_ltk_entry(GKeyFile *key_file, void *value)\n{\n\tchar *auth_str, *rand_str, *str;\n\tint i, ret;\n\tunsigned char auth, master, enc_size;\n\tunsigned short ediv;\n\n\tauth_str = strchr(value, ' ');\n\tif (!auth_str)\n\t\treturn;\n\n\t*(auth_str++) = 0;\n\n\tfor (i = 0, rand_str = auth_str; i < 4; i++) {\n\t\trand_str = strchr(rand_str, ' ');\n\t\tif (!rand_str || rand_str[1] == '\\0')\n\t\t\treturn;\n\n\t\trand_str++;\n\t}\n\n\tret = sscanf(auth_str, \" %hhd %hhd %hhd %hd\", &auth, &master,\n\t\t\t\t\t\t\t&enc_size, &ediv);\n\tif (ret < 4)\n\t\treturn;\n\n\tstr = g_strconcat(\"0x\", value, NULL);\n\tg_key_file_set_string(key_file, \"LongTermKey\", \"Key\", str);\n\tg_free(str);\n\n\tg_key_file_set_integer(key_file, \"LongTermKey\", \"Authenticated\", auth);\n\tg_key_file_set_integer(key_file, \"LongTermKey\", \"Master\", master);\n\tg_key_file_set_integer(key_file, \"LongTermKey\", \"EncSize\", enc_size);\n\tg_key_file_set_integer(key_file, \"LongTermKey\", \"EDiv\", ediv);\n\n\tstr = g_strconcat(\"0x\", rand_str, NULL);\n\tg_key_file_set_string(key_file, \"LongTermKey\", \"Rand\", str);\n\tg_free(str);\n}\n\nstatic void convert_profiles_entry(GKeyFile *key_file, void *value)\n{\n\tg_strdelimit(value, \" \", ';');\n\tg_key_file_set_string(key_file, \"General\", \"Services\", value);\n}\n\nstatic void convert_appearances_entry(GKeyFile *key_file, void *value)\n{\n\tg_key_file_set_string(key_file, \"General\", \"Appearance\", value);\n}\n\nstatic void convert_entry(char *key, char *value, void *user_data)\n{\n\tstruct device_converter *converter = user_data;\n\tchar type = BDADDR_BREDR;\n\tchar filename[PATH_MAX];\n\tGKeyFile *key_file;\n\tchar *data;\n\tgsize length = 0;\n\n\tif (strchr(key, '#')) {\n\t\tkey[17] = '\\0';\n\t\ttype = key[18] - '0';\n\t}\n\n\tif (bachk(key) != 0)\n\t\treturn;\n\n\tif (converter->force == FALSE) {\n\t\tstruct stat st;\n\t\tint err;\n\n\t\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/%s\",\n\t\t\t\tconverter->address, key);\n\n\t\terr = stat(filename, &st);\n\t\tif (err || !S_ISDIR(st.st_mode))\n\t\t\treturn;\n\t}\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/%s/info\",\n\t\t\tconverter->address, key);\n\n\tkey_file = g_key_file_new();\n\tg_key_file_load_from_file(key_file, filename, 0, NULL);\n\n\tset_device_type(key_file, type);\n\n\tconverter->cb(key_file, value);\n\n\tdata = g_key_file_to_data(key_file, &length, NULL);\n\tif (length > 0) {\n\t\tcreate_file(filename, 0600);\n\t\tg_file_set_contents(filename, data, length, NULL);\n\t}\n\n\tg_free(data);\n\n\tg_key_file_free(key_file);\n}\n\nstatic void convert_file(char *file, char *address,\n\t\t\t\tvoid (*cb)(GKeyFile *key_file, void *value),\n\t\t\t\tgboolean force)\n{\n\tchar filename[PATH_MAX];\n\tstruct device_converter converter;\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/%s\", address, file);\n\n\tconverter.address = address;\n\tconverter.cb = cb;\n\tconverter.force = force;\n\n\ttextfile_foreach(filename, convert_entry, &converter);\n}\n\nstatic gboolean record_has_uuid(const sdp_record_t *rec,\n\t\t\t\tconst char *profile_uuid)\n{\n\tsdp_list_t *pat;\n\n\tfor (pat = rec->pattern; pat != NULL; pat = pat->next) {\n\t\tchar *uuid;\n\t\tint ret;\n\n\t\tuuid = bt_uuid2string(pat->data);\n\t\tif (!uuid)\n\t\t\tcontinue;\n\n\t\tret = strcasecmp(uuid, profile_uuid);\n\n\t\tfree(uuid);\n\n\t\tif (ret == 0)\n\t\t\treturn TRUE;\n\t}\n\n\treturn FALSE;\n}\n\nstatic void store_attribute_uuid(GKeyFile *key_file, uint16_t start,\n\t\t\t\t\tuint16_t end, char *att_uuid,\n\t\t\t\t\tuuid_t uuid)\n{\n\tchar handle[6], uuid_str[33];\n\tint i;\n\n\tswitch (uuid.type) {\n\tcase SDP_UUID16:\n\t\tsprintf(uuid_str, \"%4.4X\", uuid.value.uuid16);\n\t\tbreak;\n\tcase SDP_UUID32:\n\t\tsprintf(uuid_str, \"%8.8X\", uuid.value.uuid32);\n\t\tbreak;\n\tcase SDP_UUID128:\n\t\tfor (i = 0; i < 16; i++)\n\t\t\tsprintf(uuid_str + (i * 2), \"%2.2X\",\n\t\t\t\t\tuuid.value.uuid128.data[i]);\n\t\tbreak;\n\tdefault:\n\t\tuuid_str[0] = '\\0';\n\t}\n\n\tsprintf(handle, \"%hu\", start);\n\tg_key_file_set_string(key_file, handle, \"UUID\", att_uuid);\n\tg_key_file_set_string(key_file, handle, \"Value\", uuid_str);\n\tg_key_file_set_integer(key_file, handle, \"EndGroupHandle\", end);\n}\n\nstatic void store_sdp_record(char *local, char *peer, int handle, char *value)\n{\n\tchar filename[PATH_MAX];\n\tGKeyFile *key_file;\n\tchar handle_str[11];\n\tchar *data;\n\tgsize length = 0;\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/cache/%s\", local, peer);\n\n\tkey_file = g_key_file_new();\n\tg_key_file_load_from_file(key_file, filename, 0, NULL);\n\n\tsprintf(handle_str, \"0x%8.8X\", handle);\n\tg_key_file_set_string(key_file, \"ServiceRecords\", handle_str, value);\n\n\tdata = g_key_file_to_data(key_file, &length, NULL);\n\tif (length > 0) {\n\t\tcreate_file(filename, 0600);\n\t\tg_file_set_contents(filename, data, length, NULL);\n\t}\n\n\tg_free(data);\n\n\tg_key_file_free(key_file);\n}\n\nstatic void convert_sdp_entry(char *key, char *value, void *user_data)\n{\n\tchar *src_addr = user_data;\n\tchar dst_addr[18];\n\tchar type = BDADDR_BREDR;\n\tint handle, ret;\n\tchar filename[PATH_MAX];\n\tGKeyFile *key_file;\n\tstruct stat st;\n\tsdp_record_t *rec;\n\tuuid_t uuid;\n\tchar *att_uuid, *prim_uuid;\n\tuint16_t start = 0, end = 0, psm = 0;\n\tint err;\n\tchar *data;\n\tgsize length = 0;\n\n\tret = sscanf(key, \"%17s#%hhu#%08X\", dst_addr, &type, &handle);\n\tif (ret < 3) {\n\t\tret = sscanf(key, \"%17s#%08X\", dst_addr, &handle);\n\t\tif (ret < 2)\n\t\t\treturn;\n\t}\n\n\tif (bachk(dst_addr) != 0)\n\t\treturn;\n\n\t/* Check if the device directory has been created as records should\n\t * only be converted for known devices */\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/%s\", src_addr, dst_addr);\n\n\terr = stat(filename, &st);\n\tif (err || !S_ISDIR(st.st_mode))\n\t\treturn;\n\n\t/* store device records in cache */\n\tstore_sdp_record(src_addr, dst_addr, handle, value);\n\n\t/* Retrieve device record and check if there is an\n\t * attribute entry in it */\n\tsdp_uuid16_create(&uuid, ATT_UUID);\n\tatt_uuid = bt_uuid2string(&uuid);\n\n\tsdp_uuid16_create(&uuid, GATT_PRIM_SVC_UUID);\n\tprim_uuid = bt_uuid2string(&uuid);\n\n\trec = record_from_string(value);\n\n\tif (record_has_uuid(rec, att_uuid))\n\t\tgoto failed;\n\n\t/* TODO: Do this through btd_gatt_database */\n\tif (!gatt_parse_record(rec, &uuid, &psm, &start, &end))\n\t\tgoto failed;\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/%s/attributes\", src_addr,\n\t\t\t\t\t\t\t\tdst_addr);\n\n\tkey_file = g_key_file_new();\n\tg_key_file_load_from_file(key_file, filename, 0, NULL);\n\n\tstore_attribute_uuid(key_file, start, end, prim_uuid, uuid);\n\n\tdata = g_key_file_to_data(key_file, &length, NULL);\n\tif (length > 0) {\n\t\tcreate_file(filename, 0600);\n\t\tg_file_set_contents(filename, data, length, NULL);\n\t}\n\n\tg_free(data);\n\tg_key_file_free(key_file);\n\nfailed:\n\tsdp_record_free(rec);\n\tfree(prim_uuid);\n\tfree(att_uuid);\n}\n\nstatic void convert_primaries_entry(char *key, char *value, void *user_data)\n{\n\tchar *address = user_data;\n\tint device_type = -1;\n\tuuid_t uuid;\n\tchar **services, **service, *prim_uuid;\n\tchar filename[PATH_MAX];\n\tGKeyFile *key_file;\n\tint ret;\n\tuint16_t start, end;\n\tchar uuid_str[MAX_LEN_UUID_STR + 1];\n\tchar *data;\n\tgsize length = 0;\n\n\tif (strchr(key, '#')) {\n\t\tkey[17] = '\\0';\n\t\tdevice_type = key[18] - '0';\n\t}\n\n\tif (bachk(key) != 0)\n\t\treturn;\n\n\tservices = g_strsplit(value, \" \", 0);\n\tif (services == NULL)\n\t\treturn;\n\n\tsdp_uuid16_create(&uuid, GATT_PRIM_SVC_UUID);\n\tprim_uuid = bt_uuid2string(&uuid);\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/%s/attributes\", address,\n\t\t\t\t\t\t\t\t\tkey);\n\tkey_file = g_key_file_new();\n\tg_key_file_load_from_file(key_file, filename, 0, NULL);\n\n\tfor (service = services; *service; service++) {\n\t\tret = sscanf(*service, \"%04hX#%04hX#%s\", &start, &end,\n\t\t\t\t\t\t\t\tuuid_str);\n\t\tif (ret < 3)\n\t\t\tcontinue;\n\n\t\tbt_string2uuid(&uuid, uuid_str);\n\t\tsdp_uuid128_to_uuid(&uuid);\n\n\t\tstore_attribute_uuid(key_file, start, end, prim_uuid, uuid);\n\t}\n\n\tg_strfreev(services);\n\n\tdata = g_key_file_to_data(key_file, &length, NULL);\n\tif (length == 0)\n\t\tgoto end;\n\n\tcreate_file(filename, 0600);\n\tg_file_set_contents(filename, data, length, NULL);\n\n\tif (device_type < 0)\n\t\tgoto end;\n\n\tg_free(data);\n\tg_key_file_free(key_file);\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/%s/info\", address, key);\n\n\tkey_file = g_key_file_new();\n\tg_key_file_load_from_file(key_file, filename, 0, NULL);\n\tset_device_type(key_file, device_type);\n\n\tdata = g_key_file_to_data(key_file, &length, NULL);\n\tif (length > 0) {\n\t\tcreate_file(filename, 0600);\n\t\tg_file_set_contents(filename, data, length, NULL);\n\t}\n\nend:\n\tg_free(data);\n\tfree(prim_uuid);\n\tg_key_file_free(key_file);\n}\n\nstatic void convert_ccc_entry(char *key, char *value, void *user_data)\n{\n\tchar *src_addr = user_data;\n\tchar dst_addr[18];\n\tchar type = BDADDR_BREDR;\n\tuint16_t handle;\n\tint ret, err;\n\tchar filename[PATH_MAX];\n\tGKeyFile *key_file;\n\tstruct stat st;\n\tchar group[6];\n\tchar *data;\n\tgsize length = 0;\n\n\tret = sscanf(key, \"%17s#%hhu#%04hX\", dst_addr, &type, &handle);\n\tif (ret < 3)\n\t\treturn;\n\n\tif (bachk(dst_addr) != 0)\n\t\treturn;\n\n\t/* Check if the device directory has been created as records should\n\t * only be converted for known devices */\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/%s\", src_addr, dst_addr);\n\n\terr = stat(filename, &st);\n\tif (err || !S_ISDIR(st.st_mode))\n\t\treturn;\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/%s/ccc\", src_addr,\n\t\t\t\t\t\t\t\tdst_addr);\n\tkey_file = g_key_file_new();\n\tg_key_file_load_from_file(key_file, filename, 0, NULL);\n\n\tsprintf(group, \"%hu\", handle);\n\tg_key_file_set_string(key_file, group, \"Value\", value);\n\n\tdata = g_key_file_to_data(key_file, &length, NULL);\n\tif (length > 0) {\n\t\tcreate_file(filename, 0600);\n\t\tg_file_set_contents(filename, data, length, NULL);\n\t}\n\n\tg_free(data);\n\tg_key_file_free(key_file);\n}\n\nstatic void convert_gatt_entry(char *key, char *value, void *user_data)\n{\n\tchar *src_addr = user_data;\n\tchar dst_addr[18];\n\tchar type = BDADDR_BREDR;\n\tuint16_t handle;\n\tint ret, err;\n\tchar filename[PATH_MAX];\n\tGKeyFile *key_file;\n\tstruct stat st;\n\tchar group[6];\n\tchar *data;\n\tgsize length = 0;\n\n\tret = sscanf(key, \"%17s#%hhu#%04hX\", dst_addr, &type, &handle);\n\tif (ret < 3)\n\t\treturn;\n\n\tif (bachk(dst_addr) != 0)\n\t\treturn;\n\n\t/* Check if the device directory has been created as records should\n\t * only be converted for known devices */\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/%s\", src_addr, dst_addr);\n\n\terr = stat(filename, &st);\n\tif (err || !S_ISDIR(st.st_mode))\n\t\treturn;\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/%s/gatt\", src_addr,\n\t\t\t\t\t\t\t\tdst_addr);\n\tkey_file = g_key_file_new();\n\tg_key_file_load_from_file(key_file, filename, 0, NULL);\n\n\tsprintf(group, \"%hu\", handle);\n\tg_key_file_set_string(key_file, group, \"Value\", value);\n\n\tdata = g_key_file_to_data(key_file, &length, NULL);\n\tif (length > 0) {\n\t\tcreate_file(filename, 0600);\n\t\tg_file_set_contents(filename, data, length, NULL);\n\t}\n\n\tg_free(data);\n\tg_key_file_free(key_file);\n}\n\nstatic void convert_proximity_entry(char *key, char *value, void *user_data)\n{\n\tchar *src_addr = user_data;\n\tchar *alert;\n\tchar filename[PATH_MAX];\n\tGKeyFile *key_file;\n\tstruct stat st;\n\tint err;\n\tchar *data;\n\tgsize length = 0;\n\n\tif (!strchr(key, '#'))\n\t\treturn;\n\n\tkey[17] = '\\0';\n\talert = &key[18];\n\n\tif (bachk(key) != 0)\n\t\treturn;\n\n\t/* Check if the device directory has been created as records should\n\t * only be converted for known devices */\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/%s\", src_addr, key);\n\n\terr = stat(filename, &st);\n\tif (err || !S_ISDIR(st.st_mode))\n\t\treturn;\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/%s/proximity\", src_addr,\n\t\t\t\t\t\t\t\t\tkey);\n\tkey_file = g_key_file_new();\n\tg_key_file_load_from_file(key_file, filename, 0, NULL);\n\n\tg_key_file_set_string(key_file, alert, \"Level\", value);\n\n\tdata = g_key_file_to_data(key_file, &length, NULL);\n\tif (length > 0) {\n\t\tcreate_file(filename, 0600);\n\t\tg_file_set_contents(filename, data, length, NULL);\n\t}\n\n\tg_free(data);\n\tg_key_file_free(key_file);\n}\n\nstatic void convert_device_storage(struct btd_adapter *adapter)\n{\n\tchar filename[PATH_MAX];\n\tchar address[18];\n\n\tba2str(&adapter->bdaddr, address);\n\n\t/* Convert device's name cache */\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/names\", address);\n\ttextfile_foreach(filename, convert_names_entry, address);\n\n\t/* Convert aliases */\n\tconvert_file(\"aliases\", address, convert_aliases_entry, TRUE);\n\n\t/* Convert trusts */\n\tconvert_file(\"trusts\", address, convert_trusts_entry, TRUE);\n\n\t/* Convert blocked */\n\tconvert_file(\"blocked\", address, convert_blocked_entry, TRUE);\n\n\t/* Convert profiles */\n\tconvert_file(\"profiles\", address, convert_profiles_entry, TRUE);\n\n\t/* Convert primaries */\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/primaries\", address);\n\ttextfile_foreach(filename, convert_primaries_entry, address);\n\n\t/* Convert linkkeys */\n\tconvert_file(\"linkkeys\", address, convert_linkkey_entry, TRUE);\n\n\t/* Convert longtermkeys */\n\tconvert_file(\"longtermkeys\", address, convert_ltk_entry, TRUE);\n\n\t/* Convert classes */\n\tconvert_file(\"classes\", address, convert_classes_entry, FALSE);\n\n\t/* Convert device ids */\n\tconvert_file(\"did\", address, convert_did_entry, FALSE);\n\n\t/* Convert sdp */\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/sdp\", address);\n\ttextfile_foreach(filename, convert_sdp_entry, address);\n\n\t/* Convert ccc */\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/ccc\", address);\n\ttextfile_foreach(filename, convert_ccc_entry, address);\n\n\t/* Convert appearances */\n\tconvert_file(\"appearances\", address, convert_appearances_entry, FALSE);\n\n\t/* Convert gatt */\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/gatt\", address);\n\ttextfile_foreach(filename, convert_gatt_entry, address);\n\n\t/* Convert proximity */\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/proximity\", address);\n\ttextfile_foreach(filename, convert_proximity_entry, address);\n}\n\nstatic void convert_config(struct btd_adapter *adapter, const char *filename,\n\t\t\t\t\t\t\tGKeyFile *key_file)\n{\n\tchar address[18];\n\tchar str[MAX_NAME_LENGTH + 1];\n\tchar config_path[PATH_MAX];\n\tint timeout;\n\tuint8_t mode;\n\tchar *data;\n\tgsize length = 0;\n\n\tba2str(&adapter->bdaddr, address);\n\tsnprintf(config_path, PATH_MAX, STORAGEDIR \"/%s/config\", address);\n\n\tif (read_pairable_timeout(address, &timeout) == 0)\n\t\tg_key_file_set_integer(key_file, \"General\",\n\t\t\t\t\t\t\"PairableTimeout\", timeout);\n\n\tif (read_discoverable_timeout(address, &timeout) == 0)\n\t\tg_key_file_set_integer(key_file, \"General\",\n\t\t\t\t\t\t\"DiscoverableTimeout\", timeout);\n\n\tif (read_on_mode(address, str, sizeof(str)) == 0) {\n\t\tmode = get_mode(str);\n\t\tg_key_file_set_boolean(key_file, \"General\", \"Discoverable\",\n\t\t\t\t\tmode == MODE_DISCOVERABLE);\n\t}\n\n\tif (read_local_name(&adapter->bdaddr, str) == 0)\n\t\tg_key_file_set_string(key_file, \"General\", \"Alias\", str);\n\n\tcreate_file(filename, 0600);\n\n\tdata = g_key_file_to_data(key_file, &length, NULL);\n\tg_file_set_contents(filename, data, length, NULL);\n\tg_free(data);\n}\n\nstatic void fix_storage(struct btd_adapter *adapter)\n{\n\tchar filename[PATH_MAX];\n\tchar address[18];\n\tchar *converted;\n\n\tba2str(&adapter->bdaddr, address);\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/config\", address);\n\tconverted = textfile_get(filename, \"converted\");\n\tif (!converted)\n\t\treturn;\n\n\tfree(converted);\n\n\ttextfile_del(filename, \"converted\");\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/names\", address);\n\ttextfile_del(filename, \"converted\");\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/aliases\", address);\n\ttextfile_del(filename, \"converted\");\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/trusts\", address);\n\ttextfile_del(filename, \"converted\");\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/blocked\", address);\n\ttextfile_del(filename, \"converted\");\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/profiles\", address);\n\ttextfile_del(filename, \"converted\");\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/primaries\", address);\n\ttextfile_del(filename, \"converted\");\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/linkkeys\", address);\n\ttextfile_del(filename, \"converted\");\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/longtermkeys\", address);\n\ttextfile_del(filename, \"converted\");\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/classes\", address);\n\ttextfile_del(filename, \"converted\");\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/did\", address);\n\ttextfile_del(filename, \"converted\");\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/sdp\", address);\n\ttextfile_del(filename, \"converted\");\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/ccc\", address);\n\ttextfile_del(filename, \"converted\");\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/appearances\", address);\n\ttextfile_del(filename, \"converted\");\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/gatt\", address);\n\ttextfile_del(filename, \"converted\");\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/proximity\", address);\n\ttextfile_del(filename, \"converted\");\n}\n\nstatic void load_config(struct btd_adapter *adapter)\n{\n\tGKeyFile *key_file;\n\tchar filename[PATH_MAX];\n\tstruct stat st;\n\tGError *gerr = NULL;\n\n\tkey_file = g_key_file_new();\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/settings\",\n\t\t\t\t\tbtd_adapter_get_storage_dir(adapter));\n\n\tif (stat(filename, &st) < 0) {\n\t\tconvert_config(adapter, filename, key_file);\n\t\tconvert_device_storage(adapter);\n\t}\n\n\tg_key_file_load_from_file(key_file, filename, 0, NULL);\n\n\t/* Get alias */\n\tadapter->stored_alias = g_key_file_get_string(key_file, \"General\",\n\t\t\t\t\t\t\t\t\"Alias\", NULL);\n\tif (!adapter->stored_alias) {\n\t\t/* fallback */\n\t\tadapter->stored_alias = g_key_file_get_string(key_file,\n\t\t\t\t\t\t\"General\", \"Name\", NULL);\n\t}\n\n\t/* Get pairable timeout */\n\tadapter->pairable_timeout = g_key_file_get_integer(key_file, \"General\",\n\t\t\t\t\t\t\"PairableTimeout\", &gerr);\n\tif (gerr) {\n\t\tadapter->pairable_timeout = btd_opts.pairto;\n\t\tg_error_free(gerr);\n\t\tgerr = NULL;\n\t}\n\n\t/* Get discoverable mode */\n\tadapter->stored_discoverable = g_key_file_get_boolean(key_file,\n\t\t\t\t\t\"General\", \"Discoverable\", &gerr);\n\tif (gerr) {\n\t\tadapter->stored_discoverable = false;\n\t\tg_error_free(gerr);\n\t\tgerr = NULL;\n\t}\n\n\t/* Get discoverable timeout */\n\tadapter->discoverable_timeout = g_key_file_get_integer(key_file,\n\t\t\t\t\"General\", \"DiscoverableTimeout\", &gerr);\n\tif (gerr) {\n\t\tadapter->discoverable_timeout = btd_opts.discovto;\n\t\tg_error_free(gerr);\n\t\tgerr = NULL;\n\t}\n\n\tg_key_file_free(key_file);\n}\n\nstatic struct btd_adapter *btd_adapter_new(uint16_t index)\n{\n\tstruct btd_adapter *adapter;\n\n\tadapter = g_try_new0(struct btd_adapter, 1);\n\tif (!adapter)\n\t\treturn NULL;\n\n\tadapter->dev_id = index;\n\tadapter->mgmt = mgmt_ref(mgmt_master);\n\tadapter->pincode_requested = false;\n\n\t/*\n\t * Setup default configuration values. These are either adapter\n\t * defaults or from a system wide configuration file.\n\t *\n\t * Some value might be overwritten later on by adapter specific\n\t * configuration. This is to make sure that sane defaults are\n\t * always present.\n\t */\n\tadapter->system_name = g_strdup(btd_opts.name);\n\tadapter->major_class = (btd_opts.class & 0x001f00) >> 8;\n\tadapter->minor_class = (btd_opts.class & 0x0000fc) >> 2;\n\tadapter->modalias = bt_modalias(btd_opts.did_source,\n\t\t\t\t\t\tbtd_opts.did_vendor,\n\t\t\t\t\t\tbtd_opts.did_product,\n\t\t\t\t\t\tbtd_opts.did_version);\n\tadapter->discoverable_timeout = btd_opts.discovto;\n\tadapter->pairable_timeout = btd_opts.pairto;\n\n\tDBG(\"System name: %s\", adapter->system_name);\n\tDBG(\"Major class: %u\", adapter->major_class);\n\tDBG(\"Minor class: %u\", adapter->minor_class);\n\tDBG(\"Modalias: %s\", adapter->modalias);\n\tDBG(\"Discoverable timeout: %u seconds\", adapter->discoverable_timeout);\n\tDBG(\"Pairable timeout: %u seconds\", adapter->pairable_timeout);\n\n\tadapter->auths = g_queue_new();\n\n\treturn btd_adapter_ref(adapter);\n}\n\nstatic void adapter_remove(struct btd_adapter *adapter)\n{\n\tGSList *l;\n\tstruct gatt_db *db;\n\n\tDBG(\"Removing adapter %s\", adapter->path);\n\n\tg_slist_free(adapter->connect_list);\n\tadapter->connect_list = NULL;\n\n\tfor (l = adapter->devices; l; l = l->next)\n\t\tdevice_remove(l->data, FALSE);\n\n\tg_slist_free(adapter->devices);\n\tadapter->devices = NULL;\n\n\tdiscovery_cleanup(adapter, 0);\n\n\tunload_drivers(adapter);\n\n\tdb = btd_gatt_database_get_db(adapter->database);\n\tgatt_db_unregister(db, adapter->db_id);\n\tadapter->db_id = 0;\n\n\tbtd_gatt_database_destroy(adapter->database);\n\tadapter->database = NULL;\n\n\tbtd_adv_manager_destroy(adapter->adv_manager);\n\tadapter->adv_manager = NULL;\n\n\tbtd_adv_monitor_manager_destroy(adapter->adv_monitor_manager);\n\tadapter->adv_monitor_manager = NULL;\n\n\tbtd_battery_provider_manager_destroy(adapter->battery_provider_manager);\n\tadapter->battery_provider_manager = NULL;\n\n\tg_slist_free(adapter->pin_callbacks);\n\tadapter->pin_callbacks = NULL;\n\n\tg_slist_free(adapter->msd_callbacks);\n\tadapter->msd_callbacks = NULL;\n}\n\nconst char *adapter_get_path(struct btd_adapter *adapter)\n{\n\tif (!adapter)\n\t\treturn NULL;\n\n\treturn adapter->path;\n}\n\nconst bdaddr_t *btd_adapter_get_address(struct btd_adapter *adapter)\n{\n\treturn &adapter->bdaddr;\n}\n\nstatic bool confirm_name_timeout(gpointer user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\tbtd_error(adapter->dev_id, \"Confirm name timed out for hci%u\",\n\t\t\t\t\t\t\tadapter->dev_id);\n\n\tadapter->confirm_name_timeout = 0;\n\n\tmgmt_cancel(adapter->mgmt, adapter->confirm_name_id);\n\tadapter->confirm_name_id = 0;\n\n\treturn FALSE;\n}\n\nstatic void confirm_name_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Failed to confirm name for hci%u: %s (0x%02x)\",\n\t\t\t\tadapter->dev_id, mgmt_errstr(status), status);\n\t}\n\n\tadapter->confirm_name_id = 0;\n\n\ttimeout_remove(adapter->confirm_name_timeout);\n\tadapter->confirm_name_timeout = 0;\n\n\tDBG(\"Confirm name complete for hci%u\", adapter->dev_id);\n}\n\nstatic void confirm_name(struct btd_adapter *adapter, const bdaddr_t *bdaddr,\n\t\t\t\t\tuint8_t bdaddr_type, bool name_known)\n{\n\tstruct mgmt_cp_confirm_name cp;\n\tchar addr[18];\n\n\tba2str(bdaddr, addr);\n\tDBG(\"hci%d bdaddr %s name_known %u\", adapter->dev_id, addr,\n\t\t\t\t\t\t\t\tname_known);\n\n\t/*\n\t * If the kernel does not answer the confirm name command with\n\t * a command complete or command status in time, this might\n\t * race against another device found event that also requires\n\t * to confirm the name. If there is a pending command, just\n\t * cancel it to be safe here.\n\t */\n\tif (adapter->confirm_name_id > 0) {\n\t\tbtd_warn(adapter->dev_id,\n\t\t\t\t\"Found pending confirm name for hci%u\",\n\t\t\t\t\t\t\tadapter->dev_id);\n\t\tmgmt_cancel(adapter->mgmt, adapter->confirm_name_id);\n\t}\n\n\tif (adapter->confirm_name_timeout > 0) {\n\t\ttimeout_remove(adapter->confirm_name_timeout);\n\t\tadapter->confirm_name_timeout = 0;\n\t}\n\n\tmemset(&cp, 0, sizeof(cp));\n\tbacpy(&cp.addr.bdaddr, bdaddr);\n\tcp.addr.type = bdaddr_type;\n\tcp.name_known = name_known;\n\n\tadapter->confirm_name_id = mgmt_reply(adapter->mgmt,\n\t\t\t\t\tMGMT_OP_CONFIRM_NAME,\n\t\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\t\tconfirm_name_complete, adapter, NULL);\n\n\tif (adapter->confirm_name_id == 0) {\n\t\tbtd_error(adapter->dev_id, \"Failed to confirm name for hci%u\",\n\t\t\t\t\t\t\tadapter->dev_id);\n\t\treturn;\n\t}\n\n\t/*\n\t * This timeout handling is needed since the kernel is stupid\n\t * and forgets to send a command complete response. However in\n\t * case of failures it does send a command status.\n\t */\n\tadapter->confirm_name_timeout = timeout_add_seconds(2,\n\t\t\t\t\t\tconfirm_name_timeout, adapter,\n\t\t\t\t\t\tNULL);\n}\n\nstatic void adapter_msd_notify(struct btd_adapter *adapter,\n\t\t\t\t\t\t\tstruct btd_device *dev,\n\t\t\t\t\t\t\tGSList *msd_list)\n{\n\tGSList *cb_l, *cb_next;\n\tGSList *msd_l, *msd_next;\n\n\tfor (cb_l = adapter->msd_callbacks; cb_l != NULL; cb_l = cb_next) {\n\t\tbtd_msd_cb_t cb = cb_l->data;\n\n\t\tcb_next = g_slist_next(cb_l);\n\n\t\tfor (msd_l = msd_list; msd_l != NULL; msd_l = msd_next) {\n\t\t\tconst struct eir_msd *msd = msd_l->data;\n\n\t\t\tmsd_next = g_slist_next(msd_l);\n\n\t\t\tcb(adapter, dev, msd->company, msd->data,\n\t\t\t\t\t\t\t\tmsd->data_len);\n\t\t}\n\t}\n}\n\nstatic bool is_filter_match(GSList *discovery_filter, struct eir_data *eir_data,\n\t\t\t\t\t\t\t\tint8_t rssi)\n{\n\tGSList *l, *m;\n\tbool got_match = false;\n\n\tfor (l = discovery_filter; l != NULL && got_match != true;\n\t\t\t\t\t\t\tl = g_slist_next(l)) {\n\t\tstruct discovery_client *client = l->data;\n\t\tstruct discovery_filter *item = client->discovery_filter;\n\n\t\t/*\n\t\t * If one of currently running scans is regular scan, then\n\t\t * return all devices as matches\n\t\t */\n\t\tif (!item) {\n\t\t\tgot_match = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* if someone started discovery with empty uuids, he wants all\n\t\t * devices in given proximity.\n\t\t */\n\t\tif (!item->uuids)\n\t\t\tgot_match = true;\n\t\telse {\n\t\t\tfor (m = item->uuids; m != NULL && got_match != true;\n\t\t\t\t\t\t\tm = g_slist_next(m)) {\n\t\t\t\t/* m->data contains string representation of\n\t\t\t\t * uuid.\n\t\t\t\t */\n\t\t\t\tif (g_slist_find_custom(eir_data->services,\n\t\t\t\t\t\t\tm->data,\n\t\t\t\t\t\t\tg_strcmp) != NULL)\n\t\t\t\t\tgot_match = true;\n\t\t\t}\n\t\t}\n\n\t\tif (got_match) {\n\t\t\t/* we have service match, check proximity */\n\t\t\tif (item->rssi == DISTANCE_VAL_INVALID ||\n\t\t\t    item->rssi <= rssi ||\n\t\t\t    item->pathloss == DISTANCE_VAL_INVALID ||\n\t\t\t    (eir_data->tx_power != 127 &&\n\t\t\t     eir_data->tx_power - rssi <= item->pathloss))\n\t\t\t\treturn true;\n\n\t\t\tgot_match = false;\n\t\t}\n\t}\n\n\treturn got_match;\n}\n\nstatic void filter_duplicate_data(void *data, void *user_data)\n{\n\tstruct discovery_client *client = data;\n\tbool *duplicate = user_data;\n\n\tif (*duplicate || !client->discovery_filter)\n\t\treturn;\n\n\t*duplicate = client->discovery_filter->duplicate;\n}\n\nstatic bool device_is_discoverable(struct btd_adapter *adapter,\n\t\t\t\t\tstruct eir_data *eir, const char *addr,\n\t\t\t\t\tuint8_t bdaddr_type)\n{\n\tGSList *l;\n\tbool discoverable;\n\n\tif (bdaddr_type == BDADDR_BREDR || adapter->filtered_discovery)\n\t\tdiscoverable = true;\n\telse\n\t\tdiscoverable = eir->flags & (EIR_LIM_DISC | EIR_GEN_DISC);\n\n\t/*\n\t * Mark as not discoverable if no client has requested discovery and\n\t * report has not set any discoverable flags.\n\t */\n\tif (!adapter->discovery_list && !discoverable)\n\t\treturn false;\n\n\t/* Do a prefix match for both address and name if pattern is set */\n\tfor (l = adapter->discovery_list; l; l = g_slist_next(l)) {\n\t\tstruct discovery_client *client = l->data;\n\t\tstruct discovery_filter *filter = client->discovery_filter;\n\t\tsize_t pattern_len;\n\n\t\tif (!filter || !filter->pattern)\n\t\t\tcontinue;\n\n\t\t/* Reset discoverable if a client has a pattern filter */\n\t\tdiscoverable = false;\n\n\t\tpattern_len = strlen(filter->pattern);\n\t\tif (!pattern_len)\n\t\t\treturn true;\n\n\t\tif (!strncmp(filter->pattern, addr, pattern_len))\n\t\t\treturn true;\n\n\t\tif (eir->name && !strncmp(filter->pattern, eir->name,\n\t\t\t\t\t\t\tpattern_len))\n\t\t\treturn true;\n\t}\n\n\treturn discoverable;\n}\n\nstatic void update_found_devices(struct btd_adapter *adapter,\n\t\t\t\t\tconst bdaddr_t *bdaddr,\n\t\t\t\t\tuint8_t bdaddr_type, int8_t rssi,\n\t\t\t\t\tbool confirm, bool legacy,\n\t\t\t\t\tbool not_connectable,\n\t\t\t\t\tconst uint8_t *data, uint8_t data_len)\n{\n\tstruct btd_device *dev;\n\tstruct bt_ad *ad = NULL;\n\tstruct eir_data eir_data;\n\tbool name_known, discoverable;\n\tchar addr[18];\n\tbool duplicate = false;\n\tstruct queue *matched_monitors = NULL;\n\n\tif (bdaddr_type != BDADDR_BREDR)\n\t\tad = bt_ad_new_with_data(data_len, data);\n\n\t/* During the background scanning, update the device only when the data\n\t * match at least one Adv monitor\n\t */\n\tif (ad) {\n\t\tmatched_monitors = btd_adv_monitor_content_filter(\n\t\t\t\t\tadapter->adv_monitor_manager, ad);\n\t\tbt_ad_unref(ad);\n\t\tad = NULL;\n\t}\n\n\tif (!adapter->discovering && !matched_monitors)\n\t\treturn;\n\n\tmemset(&eir_data, 0, sizeof(eir_data));\n\teir_parse(&eir_data, data, data_len);\n\n\tba2str(bdaddr, addr);\n\n\tdiscoverable = device_is_discoverable(adapter, &eir_data, addr,\n\t\t\t\t\t\t\tbdaddr_type);\n\n\tdev = btd_adapter_find_device(adapter, bdaddr, bdaddr_type);\n\tif (!dev) {\n\t\tif (!discoverable && !matched_monitors) {\n\t\t\teir_data_free(&eir_data);\n\t\t\treturn;\n\t\t}\n\n\t\tdev = adapter_create_device(adapter, bdaddr, bdaddr_type);\n\t}\n\n\tif (!dev) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\"Unable to create object for found device %s\", addr);\n\t\teir_data_free(&eir_data);\n\t\treturn;\n\t}\n\n\tdevice_update_last_seen(dev, bdaddr_type);\n\n\t/*\n\t * FIXME: We need to check for non-zero flags first because\n\t * older kernels send separate adv_ind and scan_rsp. Newer\n\t * kernels send them merged, so once we know which mgmt version\n\t * supports this we can make the non-zero check conditional.\n\t */\n\tif (bdaddr_type != BDADDR_BREDR && eir_data.flags &&\n\t\t\t\t\t!(eir_data.flags & EIR_BREDR_UNSUP)) {\n\t\tdevice_set_bredr_support(dev);\n\t\t/* Update last seen for BR/EDR in case its flag is set */\n\t\tdevice_update_last_seen(dev, BDADDR_BREDR);\n\t}\n\n\tif (eir_data.name != NULL && eir_data.name_complete)\n\t\tdevice_store_cached_name(dev, eir_data.name);\n\n\t/*\n\t * Only skip devices that are not connected, are temporary, and there\n\t * is no active discovery session ongoing and no matched Adv monitors\n\t */\n\tif (!btd_device_is_connected(dev) &&\n\t\t(device_is_temporary(dev) && !adapter->discovery_list) &&\n\t\t!matched_monitors) {\n\t\teir_data_free(&eir_data);\n\t\treturn;\n\t}\n\n\t/* If there is no matched Adv monitors, don't continue if not\n\t * discoverable or if active discovery filter don't match.\n\t */\n\tif (!matched_monitors && (!discoverable ||\n\t\t(adapter->filtered_discovery && !is_filter_match(\n\t\t\t\tadapter->discovery_list, &eir_data, rssi)))) {\n\t\teir_data_free(&eir_data);\n\t\treturn;\n\t}\n\n\tdevice_set_legacy(dev, legacy);\n\n\tif (adapter->filtered_discovery)\n\t\tdevice_set_rssi_with_delta(dev, rssi, 0);\n\telse\n\t\tdevice_set_rssi(dev, rssi);\n\n\tif (eir_data.tx_power != 127)\n\t\tdevice_set_tx_power(dev, eir_data.tx_power);\n\n\tif (eir_data.appearance != 0)\n\t\tdevice_set_appearance(dev, eir_data.appearance);\n\n\t/* Report an unknown name to the kernel even if there is a short name\n\t * known, but still update the name with the known short name. */\n\tname_known = device_name_known(dev);\n\n\tif (eir_data.name && (eir_data.name_complete || !name_known))\n\t\tbtd_device_device_set_name(dev, eir_data.name);\n\n\tif (eir_data.class != 0)\n\t\tdevice_set_class(dev, eir_data.class);\n\n\tif (eir_data.did_source || eir_data.did_vendor ||\n\t\t\teir_data.did_product || eir_data.did_version)\n\t\tbtd_device_set_pnpid(dev, eir_data.did_source,\n\t\t\t\t\t\t\teir_data.did_vendor,\n\t\t\t\t\t\t\teir_data.did_product,\n\t\t\t\t\t\t\teir_data.did_version);\n\n\tdevice_add_eir_uuids(dev, eir_data.services);\n\n\tif (adapter->discovery_list)\n\t\tg_slist_foreach(adapter->discovery_list, filter_duplicate_data,\n\t\t\t\t\t\t\t\t&duplicate);\n\n\tif (eir_data.msd_list) {\n\t\tdevice_set_manufacturer_data(dev, eir_data.msd_list, duplicate);\n\t\tadapter_msd_notify(adapter, dev, eir_data.msd_list);\n\t}\n\n\tif (eir_data.sd_list)\n\t\tdevice_set_service_data(dev, eir_data.sd_list, duplicate);\n\n\tif (eir_data.data_list)\n\t\tdevice_set_data(dev, eir_data.data_list, duplicate);\n\n\tif (bdaddr_type != BDADDR_BREDR)\n\t\tdevice_set_flags(dev, eir_data.flags);\n\n\teir_data_free(&eir_data);\n\n\t/* After the device is updated, notify the matched Adv monitors */\n\tif (matched_monitors) {\n\t\tbtd_adv_monitor_notify_monitors(adapter->adv_monitor_manager,\n\t\t\t\t\t\tdev, rssi, matched_monitors);\n\t\tqueue_destroy(matched_monitors, NULL);\n\t\tmatched_monitors = NULL;\n\t}\n\n\t/*\n\t * Only if at least one client has requested discovery, maintain\n\t * list of found devices and name confirming for legacy devices.\n\t * Otherwise, this is an event from passive discovery and we\n\t * should check if the device needs connecting to.\n\t */\n\tif (!adapter->discovery_list)\n\t\tgoto connect_le;\n\n\tif (g_slist_find(adapter->discovery_found, dev))\n\t\treturn;\n\n\tif (confirm)\n\t\tconfirm_name(adapter, bdaddr, bdaddr_type, name_known);\n\n\tadapter->discovery_found = g_slist_prepend(adapter->discovery_found,\n\t\t\t\t\t\t\t\t\tdev);\n\n\treturn;\n\nconnect_le:\n\t/* Ignore non-connectable events */\n\tif (not_connectable)\n\t\treturn;\n\n\t/*\n\t * If we're in the process of stopping passive scanning and\n\t * connecting another (or maybe even the same) LE device just\n\t * ignore this one.\n\t */\n\tif (adapter->connect_le)\n\t\treturn;\n\n\t/*\n\t * If kernel background scan is used then the kernel is\n\t * responsible for connecting.\n\t */\n\tif (btd_has_kernel_features(KERNEL_CONN_CONTROL))\n\t\treturn;\n\n\t/*\n\t * If this is an LE device that's not connected and part of the\n\t * connect_list stop passive scanning so that a connection\n\t * attempt to it can be made\n\t */\n\tif (bdaddr_type != BDADDR_BREDR && !btd_device_is_connected(dev) &&\n\t\t\t\tg_slist_find(adapter->connect_list, dev)) {\n\t\tadapter->connect_le = dev;\n\t\tstop_passive_scanning(adapter);\n\t}\n}\n\nstatic void device_found_callback(uint16_t index, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_ev_device_found *ev = param;\n\tstruct btd_adapter *adapter = user_data;\n\tconst uint8_t *eir;\n\tuint16_t eir_len;\n\tuint32_t flags;\n\tbool confirm_name;\n\tbool legacy;\n\tchar addr[18];\n\n\tif (length < sizeof(*ev)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\"Too short device found event (%u bytes)\", length);\n\t\treturn;\n\t}\n\n\teir_len = btohs(ev->eir_len);\n\tif (length != sizeof(*ev) + eir_len) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Device found event size mismatch (%u != %zu)\",\n\t\t\t\t\tlength, sizeof(*ev) + eir_len);\n\t\treturn;\n\t}\n\n\tif (eir_len == 0)\n\t\teir = NULL;\n\telse\n\t\teir = ev->eir;\n\n\tflags = btohl(ev->flags);\n\n\tba2str(&ev->addr.bdaddr, addr);\n\tDBG(\"hci%u addr %s, rssi %d flags 0x%04x eir_len %u\",\n\t\t\tindex, addr, ev->rssi, flags, eir_len);\n\n\tconfirm_name = (flags & MGMT_DEV_FOUND_CONFIRM_NAME);\n\tlegacy = (flags & MGMT_DEV_FOUND_LEGACY_PAIRING);\n\n\tupdate_found_devices(adapter, &ev->addr.bdaddr, ev->addr.type,\n\t\t\t\t\tev->rssi, confirm_name, legacy,\n\t\t\t\t\tflags & MGMT_DEV_FOUND_NOT_CONNECTABLE,\n\t\t\t\t\teir, eir_len);\n}\n\nstruct agent *adapter_get_agent(struct btd_adapter *adapter)\n{\n\treturn agent_get(NULL);\n}\n\nstatic void adapter_remove_connection(struct btd_adapter *adapter,\n\t\t\t\t\t\tstruct btd_device *device,\n\t\t\t\t\t\tuint8_t bdaddr_type)\n{\n\tDBG(\"\");\n\n\tif (!g_slist_find(adapter->connections, device)) {\n\t\tbtd_error(adapter->dev_id, \"No matching connection for device\");\n\t\treturn;\n\t}\n\n\tdevice_remove_connection(device, bdaddr_type);\n\n\tif (device_is_authenticating(device))\n\t\tdevice_cancel_authentication(device, TRUE);\n\n\t/* If another bearer is still connected */\n\tif (btd_device_is_connected(device))\n\t\treturn;\n\n\tadapter->connections = g_slist_remove(adapter->connections, device);\n}\n\nstatic void adapter_stop(struct btd_adapter *adapter)\n{\n\t/* check pending requests */\n\treply_pending_requests(adapter);\n\n\tcancel_passive_scanning(adapter);\n\n\tremove_discovery_list(adapter);\n\n\tdiscovery_cleanup(adapter, 0);\n\n\tadapter->filtered_discovery = false;\n\tadapter->no_scan_restart_delay = false;\n\tg_free(adapter->current_discovery_filter);\n\tadapter->current_discovery_filter = NULL;\n\n\tset_discovery_discoverable(adapter, false);\n\tadapter->discovering = false;\n\n\twhile (adapter->connections) {\n\t\tstruct btd_device *device = adapter->connections->data;\n\t\tuint8_t addr_type = btd_device_get_bdaddr_type(device);\n\n\t\tadapter_remove_connection(adapter, device, BDADDR_BREDR);\n\t\tif (addr_type != BDADDR_BREDR)\n\t\t\tadapter_remove_connection(adapter, device, addr_type);\n\t}\n\n\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Discovering\");\n\n\tif (adapter->dev_class) {\n\t\t/* the kernel should reset the class of device when powering\n\t\t * down, but it does not. So force it here ... */\n\t\tadapter->dev_class = 0;\n\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\t\tADAPTER_INTERFACE, \"Class\");\n\t}\n\n\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\t\tADAPTER_INTERFACE, \"Powered\");\n\n\tDBG(\"adapter %s has been disabled\", adapter->path);\n}\n\nint btd_register_adapter_driver(struct btd_adapter_driver *driver)\n{\n\tadapter_drivers = g_slist_append(adapter_drivers, driver);\n\n\tif (driver->probe == NULL)\n\t\treturn 0;\n\n\tadapter_foreach(probe_driver, driver);\n\n\treturn 0;\n}\n\nstatic void unload_driver(struct btd_adapter *adapter, gpointer data)\n{\n\tstruct btd_adapter_driver *driver = data;\n\n\tif (driver->remove)\n\t\tdriver->remove(adapter);\n\n\tadapter->drivers = g_slist_remove(adapter->drivers, data);\n}\n\nvoid btd_unregister_adapter_driver(struct btd_adapter_driver *driver)\n{\n\tadapter_drivers = g_slist_remove(adapter_drivers, driver);\n\n\tadapter_foreach(unload_driver, driver);\n}\n\nstatic void agent_auth_cb(struct agent *agent, DBusError *derr,\n\t\t\t\t\t\t\tvoid *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tstruct service_auth *auth = g_queue_pop_head(adapter->auths);\n\n\tif (!auth) {\n\t\tDBG(\"No pending authorization\");\n\t\treturn;\n\t}\n\n\tauth->cb(derr, auth->user_data);\n\n\tif (auth->agent)\n\t\tagent_unref(auth->agent);\n\n\tg_free(auth);\n\n\t/* Stop processing if queue is empty */\n\tif (g_queue_is_empty(adapter->auths)) {\n\t\tif (adapter->auth_idle_id > 0)\n\t\t\tg_source_remove(adapter->auth_idle_id);\n\t\treturn;\n\t}\n\n\tif (adapter->auth_idle_id > 0)\n\t\treturn;\n\n\tadapter->auth_idle_id = g_idle_add(process_auth_queue, adapter);\n}\n\nstatic gboolean process_auth_queue(gpointer user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tDBusError err;\n\n\tadapter->auth_idle_id = 0;\n\n\tdbus_error_init(&err);\n\tdbus_set_error_const(&err, ERROR_INTERFACE \".Rejected\", NULL);\n\n\twhile (!g_queue_is_empty(adapter->auths)) {\n\t\tstruct service_auth *auth = adapter->auths->head->data;\n\t\tstruct btd_device *device = auth->device;\n\n\t\t/* Wait services to be resolved before asking authorization */\n\t\tif (auth->svc_id > 0)\n\t\t\treturn FALSE;\n\n\t\tif (device_is_trusted(device) == TRUE) {\n\t\t\tauth->cb(NULL, auth->user_data);\n\t\t\tgoto next;\n\t\t}\n\n\t\t/* If agent is set authorization is already ongoing */\n\t\tif (auth->agent)\n\t\t\treturn FALSE;\n\n\t\tauth->agent = agent_get(NULL);\n\t\tif (auth->agent == NULL) {\n\t\t\tbtd_warn(adapter->dev_id,\n\t\t\t\t\t\"Authentication attempt without agent\");\n\t\t\tauth->cb(&err, auth->user_data);\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (agent_authorize_service(auth->agent, device, auth->uuid,\n\t\t\t\t\tagent_auth_cb, adapter, NULL) < 0) {\n\t\t\tauth->cb(&err, auth->user_data);\n\t\t\tgoto next;\n\t\t}\n\n\t\tbreak;\n\nnext:\n\t\tif (auth->agent)\n\t\t\tagent_unref(auth->agent);\n\n\t\tg_free(auth);\n\n\t\tg_queue_pop_head(adapter->auths);\n\t}\n\n\tdbus_error_free(&err);\n\n\treturn FALSE;\n}\n\nstatic void svc_complete(struct btd_device *dev, int err, void *user_data)\n{\n\tstruct service_auth *auth = user_data;\n\tstruct btd_adapter *adapter = auth->adapter;\n\n\tauth->svc_id = 0;\n\n\tif (adapter->auth_idle_id != 0)\n\t\treturn;\n\n\tadapter->auth_idle_id = g_idle_add(process_auth_queue, adapter);\n}\n\nstatic int adapter_authorize(struct btd_adapter *adapter, const bdaddr_t *dst,\n\t\t\t\t\tconst char *uuid,\n\t\t\t\t\tadapter_authorize_type check_for_connection,\n\t\t\t\t\tservice_auth_cb cb, void *user_data)\n{\n\tstruct service_auth *auth;\n\tstruct btd_device *device;\n\tstatic guint id = 0;\n\n\tdevice = btd_adapter_find_device(adapter, dst, BDADDR_BREDR);\n\tif (!device)\n\t\treturn 0;\n\n\tif (device_is_disconnecting(device)) {\n\t\tDBG(\"Authorization request while disconnecting\");\n\t\treturn 0;\n\t}\n\n\t/* Device connected? */\n\tif (check_for_connection && !g_slist_find(adapter->connections, device))\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\"Authorization request for non-connected device!?\");\n\n\tauth = g_try_new0(struct service_auth, 1);\n\tif (!auth)\n\t\treturn 0;\n\n\tauth->cb = cb;\n\tauth->user_data = user_data;\n\tauth->uuid = uuid;\n\tauth->device = device;\n\tauth->adapter = adapter;\n\tauth->id = ++id;\n\tif (check_for_connection)\n\t\tauth->svc_id = device_wait_for_svc_complete(device, svc_complete, auth);\n\telse {\n\t\tif (adapter->auth_idle_id == 0)\n\t\t\tadapter->auth_idle_id = g_idle_add(process_auth_queue, adapter);\n\t}\n\n\tg_queue_push_tail(adapter->auths, auth);\n\n\treturn auth->id;\n}\n\nguint btd_request_authorization(const bdaddr_t *src, const bdaddr_t *dst,\n\t\t\t\t\tconst char *uuid, service_auth_cb cb,\n\t\t\t\t\tvoid *user_data)\n{\n\tstruct btd_adapter *adapter;\n\tGSList *l;\n\n\tif (bacmp(src, BDADDR_ANY) != 0) {\n\t\tadapter = adapter_find(src);\n\t\tif (!adapter)\n\t\t\treturn 0;\n\n\t\treturn adapter_authorize(adapter, dst, uuid,\n\t\t\t\tADAPTER_AUTHORIZE_CHECK_CONNECTED, cb, user_data);\n\t}\n\n\tfor (l = adapters; l != NULL; l = g_slist_next(l)) {\n\t\tguint id;\n\n\t\tadapter = l->data;\n\n\t\tid = adapter_authorize(adapter, dst, uuid,\n\t\t\t\tADAPTER_AUTHORIZE_CHECK_CONNECTED, cb, user_data);\n\t\tif (id != 0)\n\t\t\treturn id;\n\t}\n\n\treturn 0;\n}\n\nguint btd_request_authorization_cable_configured(const bdaddr_t *src, const bdaddr_t *dst,\n\t\t\t\t\t\tconst char *uuid, service_auth_cb cb,\n\t\t\t\t\t\tvoid *user_data)\n{\n\tstruct btd_adapter *adapter;\n\n\tif (bacmp(src, BDADDR_ANY) == 0)\n\t\treturn 0;\n\n\tadapter = adapter_find(src);\n\tif (!adapter)\n\t\treturn 0;\n\n\treturn adapter_authorize(adapter, dst, uuid,\n\t\t\tADAPTER_AUTHORIZE_DISCONNECTED, cb, user_data);\n}\n\nstatic struct service_auth *find_authorization(guint id)\n{\n\tGSList *l;\n\tGList *l2;\n\n\tfor (l = adapters; l != NULL; l = g_slist_next(l)) {\n\t\tstruct btd_adapter *adapter = l->data;\n\n\t\tfor (l2 = adapter->auths->head; l2 != NULL; l2 = l2->next) {\n\t\t\tstruct service_auth *auth = l2->data;\n\n\t\t\tif (auth->id == id)\n\t\t\t\treturn auth;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nint btd_cancel_authorization(guint id)\n{\n\tstruct service_auth *auth;\n\n\tauth = find_authorization(id);\n\tif (auth == NULL)\n\t\treturn -EPERM;\n\n\tif (auth->svc_id > 0)\n\t\tdevice_remove_svc_complete_callback(auth->device,\n\t\t\t\t\t\t\t\tauth->svc_id);\n\n\tg_queue_remove(auth->adapter->auths, auth);\n\n\tif (auth->agent) {\n\t\tagent_cancel(auth->agent);\n\t\tagent_unref(auth->agent);\n\t}\n\n\tg_free(auth);\n\n\treturn 0;\n}\n\nint btd_adapter_restore_powered(struct btd_adapter *adapter)\n{\n\tif (btd_adapter_get_powered(adapter))\n\t\treturn 0;\n\n\tset_mode(adapter, MGMT_OP_SET_POWERED, 0x01);\n\n\treturn 0;\n}\n\nvoid btd_adapter_register_pin_cb(struct btd_adapter *adapter,\n\t\t\t\t\t\t\tbtd_adapter_pin_cb_t cb)\n{\n\tadapter->pin_callbacks = g_slist_prepend(adapter->pin_callbacks, cb);\n}\n\nvoid btd_adapter_unregister_pin_cb(struct btd_adapter *adapter,\n\t\t\t\t\t\t\tbtd_adapter_pin_cb_t cb)\n{\n\tadapter->pin_callbacks = g_slist_remove(adapter->pin_callbacks, cb);\n}\n\nvoid btd_adapter_unregister_msd_cb(struct btd_adapter *adapter,\n\t\t\t\t\t\t\tbtd_msd_cb_t cb)\n{\n\tadapter->msd_callbacks = g_slist_remove(adapter->msd_callbacks, cb);\n}\n\nvoid btd_adapter_register_msd_cb(struct btd_adapter *adapter,\n\t\t\t\t\t\t\tbtd_msd_cb_t cb)\n{\n\tadapter->msd_callbacks = g_slist_prepend(adapter->msd_callbacks, cb);\n}\n\nint btd_adapter_set_fast_connectable(struct btd_adapter *adapter,\n\t\t\t\t\t\t\tgboolean enable)\n{\n\tif (!btd_adapter_get_powered(adapter))\n\t\treturn -EINVAL;\n\n\tset_mode(adapter, MGMT_OP_SET_FAST_CONNECTABLE, enable ? 0x01 : 0x00);\n\n\treturn 0;\n}\n\nint btd_adapter_read_clock(struct btd_adapter *adapter, const bdaddr_t *bdaddr,\n\t\t\t\tint which, int timeout, uint32_t *clock,\n\t\t\t\tuint16_t *accuracy)\n{\n\tif (!btd_adapter_get_powered(adapter))\n\t\treturn -EINVAL;\n\n\treturn -ENOSYS;\n}\n\nint btd_adapter_remove_bonding(struct btd_adapter *adapter,\n\t\t\t\tconst bdaddr_t *bdaddr, uint8_t bdaddr_type)\n{\n\tstruct mgmt_cp_unpair_device cp;\n\n\tmemset(&cp, 0, sizeof(cp));\n\tbacpy(&cp.addr.bdaddr, bdaddr);\n\tcp.addr.type = bdaddr_type;\n\tcp.disconnect = 1;\n\n\tif (mgmt_send(adapter->mgmt, MGMT_OP_UNPAIR_DEVICE,\n\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\tNULL, NULL, NULL) > 0)\n\t\treturn 0;\n\n\treturn -EIO;\n}\n\nstatic void pincode_reply_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_device *device = user_data;\n\n\t/* If the MGMT_OP_PIN_CODE_REPLY command is acknowledged, move the\n\t * starting time to that point. This give a better sense of time\n\t * evaluating the pincode. */\n\tdevice_bonding_restart_timer(device);\n}\n\nint btd_adapter_pincode_reply(struct btd_adapter *adapter,\n\t\t\t\t\tconst bdaddr_t *bdaddr,\n\t\t\t\t\tconst char *pin, size_t pin_len)\n{\n\tstruct btd_device *device;\n\tunsigned int id;\n\tchar addr[18];\n\n\tba2str(bdaddr, addr);\n\tDBG(\"hci%u addr %s pinlen %zu\", adapter->dev_id, addr, pin_len);\n\n\tif (pin == NULL) {\n\t\tstruct mgmt_cp_pin_code_neg_reply cp;\n\n\t\tmemset(&cp, 0, sizeof(cp));\n\t\tbacpy(&cp.addr.bdaddr, bdaddr);\n\t\tcp.addr.type = BDADDR_BREDR;\n\n\t\tid = mgmt_reply(adapter->mgmt, MGMT_OP_PIN_CODE_NEG_REPLY,\n\t\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\t\tNULL, NULL, NULL);\n\t} else {\n\t\tstruct mgmt_cp_pin_code_reply cp;\n\n\t\tif (pin_len > 16)\n\t\t\treturn -EINVAL;\n\n\t\tmemset(&cp, 0, sizeof(cp));\n\t\tbacpy(&cp.addr.bdaddr, bdaddr);\n\t\tcp.addr.type = BDADDR_BREDR;\n\t\tcp.pin_len = pin_len;\n\t\tmemcpy(cp.pin_code, pin, pin_len);\n\n\t\t/* Since a pincode was requested, update the starting time to\n\t\t * the point where the pincode is provided. */\n\t\tdevice = btd_adapter_find_device(adapter, bdaddr, BDADDR_BREDR);\n\t\tdevice_bonding_restart_timer(device);\n\n\t\tid = mgmt_reply(adapter->mgmt, MGMT_OP_PIN_CODE_REPLY,\n\t\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\t\tpincode_reply_complete, device, NULL);\n\t}\n\n\tif (id == 0)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nint btd_adapter_confirm_reply(struct btd_adapter *adapter,\n\t\t\t\tconst bdaddr_t *bdaddr, uint8_t bdaddr_type,\n\t\t\t\tgboolean success)\n{\n\tstruct mgmt_cp_user_confirm_reply cp;\n\tuint16_t opcode;\n\tchar addr[18];\n\n\tba2str(bdaddr, addr);\n\tDBG(\"hci%u addr %s success %d\", adapter->dev_id, addr, success);\n\n\tif (success)\n\t\topcode = MGMT_OP_USER_CONFIRM_REPLY;\n\telse\n\t\topcode = MGMT_OP_USER_CONFIRM_NEG_REPLY;\n\n\tmemset(&cp, 0, sizeof(cp));\n\tbacpy(&cp.addr.bdaddr, bdaddr);\n\tcp.addr.type = bdaddr_type;\n\n\tif (mgmt_reply(adapter->mgmt, opcode, adapter->dev_id, sizeof(cp), &cp,\n\t\t\t\t\t\t\tNULL, NULL, NULL) > 0)\n\t\treturn 0;\n\n\treturn -EIO;\n}\n\nstatic void user_confirm_request_callback(uint16_t index, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_ev_user_confirm_request *ev = param;\n\tstruct btd_adapter *adapter = user_data;\n\tstruct btd_device *device;\n\tchar addr[18];\n\tint err;\n\n\tif (length < sizeof(*ev)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Too small user confirm request event\");\n\t\treturn;\n\t}\n\n\tba2str(&ev->addr.bdaddr, addr);\n\tDBG(\"hci%u %s confirm_hint %u\", adapter->dev_id, addr,\n\t\t\t\t\t\t\tev->confirm_hint);\n\tdevice = btd_adapter_get_device(adapter, &ev->addr.bdaddr,\n\t\t\t\t\t\t\t\tev->addr.type);\n\tif (!device) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Unable to get device object for %s\", addr);\n\t\treturn;\n\t}\n\n\terr = device_confirm_passkey(device, ev->addr.type, btohl(ev->value),\n\t\t\t\t\t\t\tev->confirm_hint);\n\tif (err < 0) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"device_confirm_passkey: %s\", strerror(-err));\n\t\tbtd_adapter_confirm_reply(adapter, &ev->addr.bdaddr,\n\t\t\t\t\t\t\tev->addr.type, FALSE);\n\t}\n}\n\nint btd_adapter_passkey_reply(struct btd_adapter *adapter,\n\t\t\t\tconst bdaddr_t *bdaddr, uint8_t bdaddr_type,\n\t\t\t\tuint32_t passkey)\n{\n\tunsigned int id;\n\tchar addr[18];\n\n\tba2str(bdaddr, addr);\n\tDBG(\"hci%u addr %s passkey %06u\", adapter->dev_id, addr, passkey);\n\n\tif (passkey == INVALID_PASSKEY) {\n\t\tstruct mgmt_cp_user_passkey_neg_reply cp;\n\n\t\tmemset(&cp, 0, sizeof(cp));\n\t\tbacpy(&cp.addr.bdaddr, bdaddr);\n\t\tcp.addr.type = bdaddr_type;\n\n\t\tid = mgmt_reply(adapter->mgmt, MGMT_OP_USER_PASSKEY_NEG_REPLY,\n\t\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\t\tNULL, NULL, NULL);\n\t} else {\n\t\tstruct mgmt_cp_user_passkey_reply cp;\n\n\t\tmemset(&cp, 0, sizeof(cp));\n\t\tbacpy(&cp.addr.bdaddr, bdaddr);\n\t\tcp.addr.type = bdaddr_type;\n\t\tcp.passkey = htobl(passkey);\n\n\t\tid = mgmt_reply(adapter->mgmt, MGMT_OP_USER_PASSKEY_REPLY,\n\t\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\t\tNULL, NULL, NULL);\n\t}\n\n\tif (id == 0)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic void user_passkey_request_callback(uint16_t index, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_ev_user_passkey_request *ev = param;\n\tstruct btd_adapter *adapter = user_data;\n\tstruct btd_device *device;\n\tchar addr[18];\n\tint err;\n\n\tif (length < sizeof(*ev)) {\n\t\tbtd_error(adapter->dev_id, \"Too small passkey request event\");\n\t\treturn;\n\t}\n\n\tba2str(&ev->addr.bdaddr, addr);\n\tDBG(\"hci%u %s\", index, addr);\n\n\tdevice = btd_adapter_get_device(adapter, &ev->addr.bdaddr,\n\t\t\t\t\t\t\t\tev->addr.type);\n\tif (!device) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Unable to get device object for %s\", addr);\n\t\treturn;\n\t}\n\n\terr = device_request_passkey(device, ev->addr.type);\n\tif (err < 0) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"device_request_passkey: %s\", strerror(-err));\n\t\tbtd_adapter_passkey_reply(adapter, &ev->addr.bdaddr,\n\t\t\t\t\tev->addr.type, INVALID_PASSKEY);\n\t}\n}\n\nstatic void user_passkey_notify_callback(uint16_t index, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_ev_passkey_notify *ev = param;\n\tstruct btd_adapter *adapter = user_data;\n\tstruct btd_device *device;\n\tuint32_t passkey;\n\tchar addr[18];\n\tint err;\n\n\tif (length < sizeof(*ev)) {\n\t\tbtd_error(adapter->dev_id, \"Too small passkey notify event\");\n\t\treturn;\n\t}\n\n\tba2str(&ev->addr.bdaddr, addr);\n\tDBG(\"hci%u %s\", index, addr);\n\n\tdevice = btd_adapter_get_device(adapter, &ev->addr.bdaddr,\n\t\t\t\t\t\t\t\tev->addr.type);\n\tif (!device) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Unable to get device object for %s\", addr);\n\t\treturn;\n\t}\n\n\tpasskey = get_le32(&ev->passkey);\n\n\tDBG(\"passkey %06u entered %u\", passkey, ev->entered);\n\n\terr = device_notify_passkey(device, ev->addr.type, passkey,\n\t\t\t\t\t\t\t\tev->entered);\n\tif (err < 0)\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"device_notify_passkey: %s\", strerror(-err));\n}\n\nstruct btd_adapter_pin_cb_iter *btd_adapter_pin_cb_iter_new(\n\t\t\t\t\t\tstruct btd_adapter *adapter)\n{\n\tstruct btd_adapter_pin_cb_iter *iter =\n\t\t\t\tg_new0(struct btd_adapter_pin_cb_iter, 1);\n\n\titer->it = adapter->pin_callbacks;\n\titer->attempt = 1;\n\n\treturn iter;\n}\n\nvoid btd_adapter_pin_cb_iter_free(struct btd_adapter_pin_cb_iter *iter)\n{\n\tg_free(iter);\n}\n\nbool btd_adapter_pin_cb_iter_end(struct btd_adapter_pin_cb_iter *iter)\n{\n\treturn iter->it == NULL && iter->attempt == 0;\n}\n\nstatic ssize_t btd_adapter_pin_cb_iter_next(\n\t\t\t\t\tstruct btd_adapter_pin_cb_iter *iter,\n\t\t\t\t\tstruct btd_adapter *adapter,\n\t\t\t\t\tstruct btd_device *device,\n\t\t\t\t\tchar *pin_buf, bool *display)\n{\n\tbtd_adapter_pin_cb_t cb;\n\tssize_t ret;\n\n\twhile (iter->it != NULL) {\n\t\tcb = iter->it->data;\n\t\tret = cb(adapter, device, pin_buf, display, iter->attempt);\n\t\titer->attempt++;\n\t\tif (ret > 0)\n\t\t\treturn ret;\n\t\titer->attempt = 1;\n\t\titer->it = g_slist_next(iter->it);\n\t}\n\titer->attempt = 0;\n\n\treturn 0;\n}\n\nstatic void pin_code_request_callback(uint16_t index, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_ev_pin_code_request *ev = param;\n\tstruct btd_adapter *adapter = user_data;\n\tstruct btd_device *device;\n\tbool display = false;\n\tchar pin[17];\n\tssize_t pinlen;\n\tchar addr[18];\n\tint err;\n\tstruct btd_adapter_pin_cb_iter *iter;\n\n\tif (length < sizeof(*ev)) {\n\t\tbtd_error(adapter->dev_id, \"Too small PIN code request event\");\n\t\treturn;\n\t}\n\n\tba2str(&ev->addr.bdaddr, addr);\n\n\tDBG(\"hci%u %s\", adapter->dev_id, addr);\n\n\tdevice = btd_adapter_get_device(adapter, &ev->addr.bdaddr,\n\t\t\t\t\t\t\t\tev->addr.type);\n\tif (!device) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Unable to get device object for %s\", addr);\n\t\treturn;\n\t}\n\n\t/* Flag the request of a pincode to allow a bonding retry. */\n\tadapter->pincode_requested = true;\n\n\tmemset(pin, 0, sizeof(pin));\n\n\titer = device_bonding_iter(device);\n\tif (iter == NULL)\n\t\tpinlen = 0;\n\telse\n\t\tpinlen = btd_adapter_pin_cb_iter_next(iter, adapter, device,\n\t\t\t\t\t\t\t\tpin, &display);\n\n\tif (pinlen > 0 && (!ev->secure || pinlen == 16)) {\n\t\tif (display && device_is_bonding(device, NULL)) {\n\t\t\terr = device_notify_pincode(device, ev->secure, pin);\n\t\t\tif (err < 0) {\n\t\t\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\t\t\"device_notify_pin: %s\",\n\t\t\t\t\t\t\tstrerror(-err));\n\t\t\t\tbtd_adapter_pincode_reply(adapter,\n\t\t\t\t\t\t\t&ev->addr.bdaddr,\n\t\t\t\t\t\t\tNULL, 0);\n\t\t\t}\n\t\t} else {\n\t\t\tbtd_adapter_pincode_reply(adapter, &ev->addr.bdaddr,\n\t\t\t\t\t\t\t\tpin, pinlen);\n\t\t}\n\t\treturn;\n\t}\n\n\terr = device_request_pincode(device, ev->secure);\n\tif (err < 0) {\n\t\tbtd_error(adapter->dev_id, \"device_request_pin: %s\",\n\t\t\t\t\t\t\tstrerror(-err));\n\t\tbtd_adapter_pincode_reply(adapter, &ev->addr.bdaddr, NULL, 0);\n\t}\n}\n\nint adapter_cancel_bonding(struct btd_adapter *adapter, const bdaddr_t *bdaddr,\n\t\t\t\t\t\t\tuint8_t addr_type)\n{\n\tstruct mgmt_addr_info cp;\n\tchar addr[18];\n\n\tba2str(bdaddr, addr);\n\tDBG(\"hci%u bdaddr %s type %u\", adapter->dev_id, addr, addr_type);\n\n\tmemset(&cp, 0, sizeof(cp));\n\tbacpy(&cp.bdaddr, bdaddr);\n\tcp.type = addr_type;\n\n\tif (mgmt_reply(adapter->mgmt, MGMT_OP_CANCEL_PAIR_DEVICE,\n\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\tNULL, NULL, NULL) > 0)\n\t\treturn 0;\n\n\treturn -EIO;\n}\n\nstatic void check_oob_bonding_complete(struct btd_adapter *adapter,\n\t\t\t\t\tconst bdaddr_t *bdaddr, uint8_t status)\n{\n\tif (!adapter->oob_handler || !adapter->oob_handler->bonding_cb)\n\t\treturn;\n\n\tif (bacmp(bdaddr, &adapter->oob_handler->remote_addr) != 0)\n\t\treturn;\n\n\tadapter->oob_handler->bonding_cb(adapter, bdaddr, status,\n\t\t\t\t\tadapter->oob_handler->user_data);\n\n\tg_free(adapter->oob_handler);\n\tadapter->oob_handler = NULL;\n}\n\nstatic void bonding_complete(struct btd_adapter *adapter,\n\t\t\t\t\tconst bdaddr_t *bdaddr,\n\t\t\t\t\tuint8_t addr_type, uint8_t status)\n{\n\tstruct btd_device *device;\n\n\tif (status == 0)\n\t\tdevice = btd_adapter_get_device(adapter, bdaddr, addr_type);\n\telse\n\t\tdevice = btd_adapter_find_device(adapter, bdaddr, addr_type);\n\n\tif (device != NULL)\n\t\tdevice_bonding_complete(device, addr_type, status);\n\n\tresume_discovery(adapter);\n\n\tcheck_oob_bonding_complete(adapter, bdaddr, status);\n}\n\n/* bonding_attempt_complete() handles the end of a \"bonding attempt\" checking if\n * it should begin a new attempt or complete the bonding.\n */\nstatic void bonding_attempt_complete(struct btd_adapter *adapter,\n\t\t\t\t\tconst bdaddr_t *bdaddr,\n\t\t\t\t\tuint8_t addr_type, uint8_t status)\n{\n\tstruct btd_device *device;\n\tchar addr[18];\n\n\tba2str(bdaddr, addr);\n\tDBG(\"hci%u bdaddr %s type %u status 0x%x\", adapter->dev_id, addr,\n\t\t\t\t\t\t\taddr_type, status);\n\n\tif (status == 0)\n\t\tdevice = btd_adapter_get_device(adapter, bdaddr, addr_type);\n\telse\n\t\tdevice = btd_adapter_find_device(adapter, bdaddr, addr_type);\n\n\tif (status == MGMT_STATUS_AUTH_FAILED && adapter->pincode_requested) {\n\t\t/* On faliure, issue a bonding_retry if possible. */\n\t\tif (device != NULL) {\n\t\t\tif (device_bonding_attempt_retry(device) == 0)\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Ignore disconnects during retry. */\n\tif (status == MGMT_STATUS_DISCONNECTED &&\n\t\t\t\t\tdevice && device_is_retrying(device))\n\t\treturn;\n\n\t/* In any other case, finish the bonding. */\n\tbonding_complete(adapter, bdaddr, addr_type, status);\n}\n\nstruct pair_device_data {\n\tstruct btd_adapter *adapter;\n\tbdaddr_t bdaddr;\n\tuint8_t addr_type;\n};\n\nstatic void free_pair_device_data(void *user_data)\n{\n\tstruct pair_device_data *data = user_data;\n\n\tg_free(data);\n}\n\nstatic bool pair_device_timeout(gpointer user_data)\n{\n\tstruct pair_device_data *data = user_data;\n\tstruct btd_adapter *adapter = data->adapter;\n\n\tbtd_error(adapter->dev_id, \"Pair device timed out for hci%u\",\n\t\t\t\t\t\t\tadapter->dev_id);\n\n\tadapter->pair_device_timeout = 0;\n\n\tadapter_cancel_bonding(adapter, &data->bdaddr, data->addr_type);\n\n\treturn FALSE;\n}\n\nstatic void pair_device_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_rp_pair_device *rp = param;\n\tstruct pair_device_data *data = user_data;\n\tstruct btd_adapter *adapter = data->adapter;\n\n\tDBG(\"%s (0x%02x)\", mgmt_errstr(status), status);\n\n\tadapter->pair_device_id = 0;\n\n\tif (adapter->pair_device_timeout > 0) {\n\t\ttimeout_remove(adapter->pair_device_timeout);\n\t\tadapter->pair_device_timeout = 0;\n\t}\n\n\t/* Workaround for a kernel bug\n\t *\n\t * Broken kernels may reply to device pairing command with command\n\t * status instead of command complete event e.g. if adapter was not\n\t * powered.\n\t */\n\tif (status != MGMT_STATUS_SUCCESS && length < sizeof(*rp)) {\n\t\tbtd_error(adapter->dev_id, \"Pair device failed: %s (0x%02x)\",\n\t\t\t\t\t\tmgmt_errstr(status), status);\n\n\t\tbonding_attempt_complete(adapter, &data->bdaddr,\n\t\t\t\t\t\tdata->addr_type, status);\n\t\treturn;\n\t}\n\n\tif (length < sizeof(*rp)) {\n\t\tbtd_error(adapter->dev_id, \"Too small pair device response\");\n\t\treturn;\n\t}\n\n\tbonding_attempt_complete(adapter, &rp->addr.bdaddr, rp->addr.type,\n\t\t\t\t\t\t\t\t\tstatus);\n}\n\nint adapter_create_bonding(struct btd_adapter *adapter, const bdaddr_t *bdaddr,\n\t\t\t\t\tuint8_t addr_type, uint8_t io_cap)\n{\n\tif (adapter->pair_device_id > 0) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\"Unable pair since another pairing is in progress\");\n\t\treturn -EBUSY;\n\t}\n\n\tsuspend_discovery(adapter);\n\n\treturn adapter_bonding_attempt(adapter, bdaddr, addr_type, io_cap);\n}\n\n/* Starts a new bonding attempt in a fresh new bonding_req or a retried one. */\nint adapter_bonding_attempt(struct btd_adapter *adapter, const bdaddr_t *bdaddr,\n\t\t\t\t\tuint8_t addr_type, uint8_t io_cap)\n{\n\tstruct mgmt_cp_pair_device cp;\n\tchar addr[18];\n\tstruct pair_device_data *data;\n\tunsigned int id;\n\n\tba2str(bdaddr, addr);\n\tDBG(\"hci%u bdaddr %s type %d io_cap 0x%02x\",\n\t\t\t\tadapter->dev_id, addr, addr_type, io_cap);\n\n\t/* Reset the pincode_requested flag for a new bonding attempt. */\n\tadapter->pincode_requested = false;\n\n\tmemset(&cp, 0, sizeof(cp));\n\tbacpy(&cp.addr.bdaddr, bdaddr);\n\tcp.addr.type = addr_type;\n\tcp.io_cap = io_cap;\n\n\tdata = g_new0(struct pair_device_data, 1);\n\tdata->adapter = adapter;\n\tbacpy(&data->bdaddr, bdaddr);\n\tdata->addr_type = addr_type;\n\n\tid = mgmt_send(adapter->mgmt, MGMT_OP_PAIR_DEVICE,\n\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\tpair_device_complete, data,\n\t\t\t\tfree_pair_device_data);\n\n\tif (id == 0) {\n\t\tbtd_error(adapter->dev_id, \"Failed to pair %s for hci%u\",\n\t\t\t\t\t\t\taddr, adapter->dev_id);\n\t\tfree_pair_device_data(data);\n\t\treturn -EIO;\n\t}\n\n\tadapter->pair_device_id = id;\n\n\t/* Due to a bug in the kernel it is possible that a LE pairing\n\t * request never times out. Therefore, add a timer to clean up\n\t * if no response arrives\n\t */\n\tadapter->pair_device_timeout = timeout_add_seconds(BONDING_TIMEOUT,\n\t\t\t\t\t\tpair_device_timeout, data,\n\t\t\t\t\t\tNULL);\n\n\treturn 0;\n}\n\nstatic void disconnect_notify(struct btd_device *dev, uint8_t reason)\n{\n\tGSList *l;\n\n\tfor (l = disconnect_list; l; l = g_slist_next(l)) {\n\t\tbtd_disconnect_cb disconnect_cb = l->data;\n\t\tdisconnect_cb(dev, reason);\n\t}\n}\n\nstatic void dev_disconnected(struct btd_adapter *adapter,\n\t\t\t\t\tconst struct mgmt_addr_info *addr,\n\t\t\t\t\tuint8_t reason)\n{\n\tstruct btd_device *device;\n\tchar dst[18];\n\n\tba2str(&addr->bdaddr, dst);\n\n\tDBG(\"Device %s disconnected, reason %u\", dst, reason);\n\n\tdevice = btd_adapter_find_device(adapter, &addr->bdaddr, addr->type);\n\tif (device) {\n\t\tadapter_remove_connection(adapter, device, addr->type);\n\t\tdisconnect_notify(device, reason);\n\t}\n\n\tbonding_attempt_complete(adapter, &addr->bdaddr, addr->type,\n\t\t\t\t\t\tMGMT_STATUS_DISCONNECTED);\n}\n\nvoid btd_add_disconnect_cb(btd_disconnect_cb func)\n{\n\tdisconnect_list = g_slist_append(disconnect_list, func);\n}\n\nvoid btd_remove_disconnect_cb(btd_disconnect_cb func)\n{\n\tdisconnect_list = g_slist_remove(disconnect_list, func);\n}\n\nstatic void disconnect_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_rp_disconnect *rp = param;\n\tstruct btd_adapter *adapter = user_data;\n\n\tif (status == MGMT_STATUS_NOT_CONNECTED) {\n\t\tbtd_warn(adapter->dev_id,\n\t\t\t\t\"Disconnecting failed: already disconnected\");\n\t} else if (status != MGMT_STATUS_SUCCESS) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Failed to disconnect device: %s (0x%02x)\",\n\t\t\t\t\t\tmgmt_errstr(status), status);\n\t\treturn;\n\t}\n\n\tif (length < sizeof(*rp)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Too small device disconnect response\");\n\t\treturn;\n\t}\n\n\tdev_disconnected(adapter, &rp->addr, MGMT_DEV_DISCONN_LOCAL_HOST);\n}\n\nint btd_adapter_disconnect_device(struct btd_adapter *adapter,\n\t\t\t\t\t\tconst bdaddr_t *bdaddr,\n\t\t\t\t\t\tuint8_t bdaddr_type)\n\n{\n\tstruct mgmt_cp_disconnect cp;\n\n\tmemset(&cp, 0, sizeof(cp));\n\tbacpy(&cp.addr.bdaddr, bdaddr);\n\tcp.addr.type = bdaddr_type;\n\n\tif (mgmt_send(adapter->mgmt, MGMT_OP_DISCONNECT,\n\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\tdisconnect_complete, adapter, NULL) > 0)\n\t\treturn 0;\n\n\treturn -EIO;\n}\n\nstatic void auth_failed_callback(uint16_t index, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_ev_auth_failed *ev = param;\n\tstruct btd_adapter *adapter = user_data;\n\n\tif (length < sizeof(*ev)) {\n\t\tbtd_error(adapter->dev_id, \"Too small auth failed mgmt event\");\n\t\treturn;\n\t}\n\n\tbonding_attempt_complete(adapter, &ev->addr.bdaddr, ev->addr.type,\n\t\t\t\t\t\t\t\tev->status);\n}\n\nstatic void store_link_key(struct btd_adapter *adapter,\n\t\t\t\tstruct btd_device *device, const uint8_t *key,\n\t\t\t\tuint8_t type, uint8_t pin_length)\n{\n\tchar device_addr[18];\n\tchar filename[PATH_MAX];\n\tGKeyFile *key_file;\n\tgsize length = 0;\n\tchar key_str[33];\n\tchar *str;\n\tint i;\n\n\tba2str(device_get_address(device), device_addr);\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/%s/info\",\n\t\t\tbtd_adapter_get_storage_dir(adapter), device_addr);\n\tkey_file = g_key_file_new();\n\tg_key_file_load_from_file(key_file, filename, 0, NULL);\n\n\tfor (i = 0; i < 16; i++)\n\t\tsprintf(key_str + (i * 2), \"%2.2X\", key[i]);\n\n\tg_key_file_set_string(key_file, \"LinkKey\", \"Key\", key_str);\n\n\tg_key_file_set_integer(key_file, \"LinkKey\", \"Type\", type);\n\tg_key_file_set_integer(key_file, \"LinkKey\", \"PINLength\", pin_length);\n\n\tcreate_file(filename, 0600);\n\n\tstr = g_key_file_to_data(key_file, &length, NULL);\n\tg_file_set_contents(filename, str, length, NULL);\n\tg_free(str);\n\n\tg_key_file_free(key_file);\n}\n\nstatic void new_link_key_callback(uint16_t index, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_ev_new_link_key *ev = param;\n\tconst struct mgmt_addr_info *addr = &ev->key.addr;\n\tstruct btd_adapter *adapter = user_data;\n\tstruct btd_device *device;\n\tchar dst[18];\n\n\tif (length < sizeof(*ev)) {\n\t\tbtd_error(adapter->dev_id, \"Too small new link key event\");\n\t\treturn;\n\t}\n\n\tba2str(&addr->bdaddr, dst);\n\n\tDBG(\"hci%u new key for %s type %u pin_len %u store_hint %u\",\n\t\tadapter->dev_id, dst, ev->key.type, ev->key.pin_len,\n\t\tev->store_hint);\n\n\tif (ev->key.pin_len > 16) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Invalid PIN length (%u) in new_key event\",\n\t\t\t\t\t\t\tev->key.pin_len);\n\t\treturn;\n\t}\n\n\tdevice = btd_adapter_get_device(adapter, &addr->bdaddr, addr->type);\n\tif (!device) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Unable to get device object for %s\", dst);\n\t\treturn;\n\t}\n\n\tif (ev->store_hint) {\n\t\tconst struct mgmt_link_key_info *key = &ev->key;\n\n\t\tstore_link_key(adapter, device, key->val, key->type,\n\t\t\t\t\t\t\t\tkey->pin_len);\n\n\t\tdevice_set_bonded(device, BDADDR_BREDR);\n\t}\n\n\tbonding_complete(adapter, &addr->bdaddr, addr->type, 0);\n}\n\nstatic void store_longtermkey(struct btd_adapter *adapter, const bdaddr_t *peer,\n\t\t\t\tuint8_t bdaddr_type, const unsigned char *key,\n\t\t\t\tuint8_t master, uint8_t authenticated,\n\t\t\t\tuint8_t enc_size, uint16_t ediv,\n\t\t\t\tuint64_t rand)\n{\n\tconst char *group = master ? \"LongTermKey\" : \"SlaveLongTermKey\";\n\tchar device_addr[18];\n\tchar filename[PATH_MAX];\n\tGKeyFile *key_file;\n\tchar key_str[33];\n\tgsize length = 0;\n\tchar *str;\n\tint i;\n\n\tif (master != 0x00 && master != 0x01) {\n\t\terror(\"Unsupported LTK type %u\", master);\n\t\treturn;\n\t}\n\n\tba2str(peer, device_addr);\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/%s/info\",\n\t\t\tbtd_adapter_get_storage_dir(adapter), device_addr);\n\tkey_file = g_key_file_new();\n\tg_key_file_load_from_file(key_file, filename, 0, NULL);\n\n\t/* Old files may contain this so remove it in case it exists */\n\tg_key_file_remove_key(key_file, \"LongTermKey\", \"Master\", NULL);\n\n\tfor (i = 0; i < 16; i++)\n\t\tsprintf(key_str + (i * 2), \"%2.2X\", key[i]);\n\n\tg_key_file_set_string(key_file, group, \"Key\", key_str);\n\n\tg_key_file_set_integer(key_file, group, \"Authenticated\",\n\t\t\t\t\t\t\tauthenticated);\n\tg_key_file_set_integer(key_file, group, \"EncSize\", enc_size);\n\n\tg_key_file_set_integer(key_file, group, \"EDiv\", ediv);\n\tg_key_file_set_uint64(key_file, group, \"Rand\", rand);\n\n\tcreate_file(filename, 0600);\n\n\tstr = g_key_file_to_data(key_file, &length, NULL);\n\tg_file_set_contents(filename, str, length, NULL);\n\tg_free(str);\n\n\tg_key_file_free(key_file);\n}\n\nstatic void new_long_term_key_callback(uint16_t index, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_ev_new_long_term_key *ev = param;\n\tconst struct mgmt_addr_info *addr = &ev->key.addr;\n\tstruct btd_adapter *adapter = user_data;\n\tstruct btd_device *device;\n\tbool persistent;\n\tchar dst[18];\n\n\tif (length < sizeof(*ev)) {\n\t\tbtd_error(adapter->dev_id, \"Too small long term key event\");\n\t\treturn;\n\t}\n\n\tba2str(&addr->bdaddr, dst);\n\n\tDBG(\"hci%u new LTK for %s type %u enc_size %u\",\n\t\tadapter->dev_id, dst, ev->key.type, ev->key.enc_size);\n\n\tdevice = btd_adapter_get_device(adapter, &addr->bdaddr, addr->type);\n\tif (!device) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Unable to get device object for %s\", dst);\n\t\treturn;\n\t}\n\n\t/*\n\t * Some older kernel versions set store_hint for long term keys\n\t * from resolvable and unresolvable random addresses, but there\n\t * is no point in storing these. Next time around the device\n\t * address will be invalid.\n\t *\n\t * So only for identity addresses (public and static random) use\n\t * the store_hint as an indication if the long term key should\n\t * be persistently stored.\n\t *\n\t */\n\tif (addr->type == BDADDR_LE_RANDOM &&\n\t\t\t\t(addr->bdaddr.b[5] & 0xc0) != 0xc0)\n\t\tpersistent = false;\n\telse\n\t\tpersistent = !!ev->store_hint;\n\n\tif (persistent) {\n\t\tconst struct mgmt_ltk_info *key = &ev->key;\n\t\tuint16_t ediv;\n\t\tuint64_t rand;\n\n\t\tediv = le16_to_cpu(key->ediv);\n\t\trand = le64_to_cpu(key->rand);\n\n\t\tstore_longtermkey(adapter, &key->addr.bdaddr,\n\t\t\t\t\tkey->addr.type, key->val, key->master,\n\t\t\t\t\tkey->type, key->enc_size, ediv, rand);\n\n\t\tdevice_set_bonded(device, addr->type);\n\t}\n\n\tdevice_set_ltk_enc_size(device, ev->key.enc_size);\n\n\tbonding_complete(adapter, &addr->bdaddr, addr->type, 0);\n}\n\nstatic void store_csrk(struct btd_adapter *adapter, const bdaddr_t *peer,\n\t\t\t\tuint8_t bdaddr_type, const unsigned char *key,\n\t\t\t\tuint32_t counter, uint8_t type)\n{\n\tconst char *group;\n\tchar device_addr[18];\n\tchar filename[PATH_MAX];\n\tGKeyFile *key_file;\n\tchar key_str[33];\n\tgsize length = 0;\n\tgboolean auth;\n\tchar *str;\n\tint i;\n\n\tswitch (type) {\n\tcase 0x00:\n\t\tgroup = \"LocalSignatureKey\";\n\t\tauth = FALSE;\n\t\tbreak;\n\tcase 0x01:\n\t\tgroup = \"RemoteSignatureKey\";\n\t\tauth = FALSE;\n\t\tbreak;\n\tcase 0x02:\n\t\tgroup = \"LocalSignatureKey\";\n\t\tauth = TRUE;\n\t\tbreak;\n\tcase 0x03:\n\t\tgroup = \"RemoteSignatureKey\";\n\t\tauth = TRUE;\n\t\tbreak;\n\tdefault:\n\t\twarn(\"Unsupported CSRK type %u\", type);\n\t\treturn;\n\t}\n\n\tba2str(peer, device_addr);\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/%s/info\",\n\t\t\tbtd_adapter_get_storage_dir(adapter), device_addr);\n\n\tkey_file = g_key_file_new();\n\tg_key_file_load_from_file(key_file, filename, 0, NULL);\n\n\tfor (i = 0; i < 16; i++)\n\t\tsprintf(key_str + (i * 2), \"%2.2X\", key[i]);\n\n\tg_key_file_set_string(key_file, group, \"Key\", key_str);\n\tg_key_file_set_integer(key_file, group, \"Counter\", counter);\n\tg_key_file_set_boolean(key_file, group, \"Authenticated\", auth);\n\n\tcreate_file(filename, 0600);\n\n\tstr = g_key_file_to_data(key_file, &length, NULL);\n\tg_file_set_contents(filename, str, length, NULL);\n\tg_free(str);\n\n\tg_key_file_free(key_file);\n}\n\nstatic void new_csrk_callback(uint16_t index, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_ev_new_csrk *ev = param;\n\tconst struct mgmt_addr_info *addr = &ev->key.addr;\n\tconst struct mgmt_csrk_info *key = &ev->key;\n\tstruct btd_adapter *adapter = user_data;\n\tstruct btd_device *device;\n\tchar dst[18];\n\n\tif (length < sizeof(*ev)) {\n\t\tbtd_error(adapter->dev_id, \"Too small CSRK event\");\n\t\treturn;\n\t}\n\n\tba2str(&addr->bdaddr, dst);\n\n\tDBG(\"hci%u new CSRK for %s type %u\", adapter->dev_id, dst,\n\t\t\t\t\t\t\t\tev->key.type);\n\n\tdevice = btd_adapter_get_device(adapter, &addr->bdaddr, addr->type);\n\tif (!device) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Unable to get device object for %s\", dst);\n\t\treturn;\n\t}\n\n\tif (!ev->store_hint)\n\t\treturn;\n\n\tstore_csrk(adapter, &key->addr.bdaddr, key->addr.type, key->val, 0,\n\t\t\t\t\t\t\t\tkey->type);\n\n\tbtd_device_set_temporary(device, false);\n}\n\nstatic void store_irk(struct btd_adapter *adapter, const bdaddr_t *peer,\n\t\t\t\tuint8_t bdaddr_type, const unsigned char *key)\n{\n\tchar device_addr[18];\n\tchar filename[PATH_MAX];\n\tGKeyFile *key_file;\n\tchar *store_data;\n\tchar str[33];\n\tsize_t length = 0;\n\tint i;\n\n\tba2str(peer, device_addr);\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/%s/info\",\n\t\t\tbtd_adapter_get_storage_dir(adapter), device_addr);\n\tkey_file = g_key_file_new();\n\tg_key_file_load_from_file(key_file, filename, 0, NULL);\n\n\tfor (i = 0; i < 16; i++)\n\t\tsprintf(str + (i * 2), \"%2.2X\", key[i]);\n\n\tg_key_file_set_string(key_file, \"IdentityResolvingKey\", \"Key\", str);\n\n\tcreate_file(filename, 0600);\n\n\tstore_data = g_key_file_to_data(key_file, &length, NULL);\n\tg_file_set_contents(filename, store_data, length, NULL);\n\tg_free(store_data);\n\n\tg_key_file_free(key_file);\n}\n\nstatic void new_irk_callback(uint16_t index, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_ev_new_irk *ev = param;\n\tconst struct mgmt_addr_info *addr = &ev->key.addr;\n\tconst struct mgmt_irk_info *irk = &ev->key;\n\tstruct btd_adapter *adapter = user_data;\n\tstruct btd_device *device, *duplicate;\n\tbool persistent;\n\tchar dst[18], rpa[18];\n\n\tif (length < sizeof(*ev)) {\n\t\tbtd_error(adapter->dev_id, \"Too small New IRK event\");\n\t\treturn;\n\t}\n\n\tba2str(&addr->bdaddr, dst);\n\tba2str(&ev->rpa, rpa);\n\n\tDBG(\"hci%u new IRK for %s RPA %s\", adapter->dev_id, dst, rpa);\n\n\tif (bacmp(&ev->rpa, BDADDR_ANY)) {\n\t\tdevice = btd_adapter_get_device(adapter, &ev->rpa,\n\t\t\t\t\t\t\tBDADDR_LE_RANDOM);\n\t\tduplicate = btd_adapter_find_device(adapter, &addr->bdaddr,\n\t\t\t\t\t\t\t\taddr->type);\n\t\tif (duplicate == device)\n\t\t\tduplicate = NULL;\n\t} else {\n\t\tdevice = btd_adapter_get_device(adapter, &addr->bdaddr,\n\t\t\t\t\t\t\t\taddr->type);\n\t\tduplicate = NULL;\n\t}\n\n\tif (!device) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Unable to get device object for %s\", dst);\n\t\treturn;\n\t}\n\n\tdevice_update_addr(device, &addr->bdaddr, addr->type);\n\n\tif (duplicate)\n\t\tdevice_merge_duplicate(device, duplicate);\n\n\tpersistent = !!ev->store_hint;\n\tif (!persistent)\n\t\treturn;\n\n\tstore_irk(adapter, &addr->bdaddr, addr->type, irk->val);\n\n\tbtd_device_set_temporary(device, false);\n}\n\nstatic void store_conn_param(struct btd_adapter *adapter, const bdaddr_t *peer,\n\t\t\t\tuint8_t bdaddr_type, uint16_t min_interval,\n\t\t\t\tuint16_t max_interval, uint16_t latency,\n\t\t\t\tuint16_t timeout)\n{\n\tchar device_addr[18];\n\tchar filename[PATH_MAX];\n\tGKeyFile *key_file;\n\tchar *store_data;\n\tsize_t length = 0;\n\n\tba2str(peer, device_addr);\n\n\tDBG(\"\");\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/%s/info\",\n\t\t\tbtd_adapter_get_storage_dir(adapter), device_addr);\n\tkey_file = g_key_file_new();\n\tg_key_file_load_from_file(key_file, filename, 0, NULL);\n\n\tg_key_file_set_integer(key_file, \"ConnectionParameters\",\n\t\t\t\t\t\t\"MinInterval\", min_interval);\n\tg_key_file_set_integer(key_file, \"ConnectionParameters\",\n\t\t\t\t\t\t\"MaxInterval\", max_interval);\n\tg_key_file_set_integer(key_file, \"ConnectionParameters\",\n\t\t\t\t\t\t\"Latency\", latency);\n\tg_key_file_set_integer(key_file, \"ConnectionParameters\",\n\t\t\t\t\t\t\"Timeout\", timeout);\n\n\tcreate_file(filename, 0600);\n\n\tstore_data = g_key_file_to_data(key_file, &length, NULL);\n\tg_file_set_contents(filename, store_data, length, NULL);\n\tg_free(store_data);\n\n\tg_key_file_free(key_file);\n}\n\nstatic void new_conn_param(uint16_t index, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_ev_new_conn_param *ev = param;\n\tstruct btd_adapter *adapter = user_data;\n\tuint16_t min, max, latency, timeout;\n\tstruct btd_device *dev;\n\tchar dst[18];\n\n\n\tif (length < sizeof(*ev)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Too small New Connection Parameter event\");\n\t\treturn;\n\t}\n\n\tba2str(&ev->addr.bdaddr, dst);\n\n\tmin = btohs(ev->min_interval);\n\tmax = btohs(ev->max_interval);\n\tlatency = btohs(ev->latency);\n\ttimeout = btohs(ev->timeout);\n\n\tDBG(\"hci%u %s (%u) min 0x%04x max 0x%04x latency 0x%04x timeout 0x%04x\",\n\t\tadapter->dev_id, dst, ev->addr.type, min, max, latency, timeout);\n\n\tdev = btd_adapter_get_device(adapter, &ev->addr.bdaddr, ev->addr.type);\n\tif (!dev) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Unable to get device object for %s\", dst);\n\t\treturn;\n\t}\n\n\tif (!ev->store_hint)\n\t\treturn;\n\n\tstore_conn_param(adapter, &ev->addr.bdaddr, ev->addr.type,\n\t\t\t\t\tev->min_interval, ev->max_interval,\n\t\t\t\t\tev->latency, ev->timeout);\n}\n\nint adapter_set_io_capability(struct btd_adapter *adapter, uint8_t io_cap)\n{\n\tstruct mgmt_cp_set_io_capability cp;\n\n\tif (!btd_opts.pairable) {\n\t\tif (io_cap == IO_CAPABILITY_INVALID) {\n\t\t\tif (adapter->current_settings & MGMT_SETTING_BONDABLE)\n\t\t\t\tset_mode(adapter, MGMT_OP_SET_BONDABLE, 0x00);\n\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!(adapter->current_settings & MGMT_SETTING_BONDABLE))\n\t\t\tset_mode(adapter, MGMT_OP_SET_BONDABLE, 0x01);\n\t} else if (io_cap == IO_CAPABILITY_INVALID)\n\t\tio_cap = IO_CAPABILITY_NOINPUTNOOUTPUT;\n\n\tmemset(&cp, 0, sizeof(cp));\n\tcp.io_capability = io_cap;\n\n\tif (mgmt_send(adapter->mgmt, MGMT_OP_SET_IO_CAPABILITY,\n\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\tNULL, NULL, NULL) > 0)\n\t\treturn 0;\n\n\treturn -EIO;\n}\n\nint btd_adapter_add_remote_oob_data(struct btd_adapter *adapter,\n\t\t\t\t\tconst bdaddr_t *bdaddr,\n\t\t\t\t\tuint8_t *hash, uint8_t *randomizer)\n{\n\tstruct mgmt_cp_add_remote_oob_data cp;\n\tchar addr[18];\n\n\tba2str(bdaddr, addr);\n\tDBG(\"hci%d bdaddr %s\", adapter->dev_id, addr);\n\n\tmemset(&cp, 0, sizeof(cp));\n\tbacpy(&cp.addr.bdaddr, bdaddr);\n\tmemcpy(cp.hash192, hash, 16);\n\n\tif (randomizer)\n\t\tmemcpy(cp.rand192, randomizer, 16);\n\n\tif (mgmt_send(adapter->mgmt, MGMT_OP_ADD_REMOTE_OOB_DATA,\n\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\tNULL, NULL, NULL) > 0)\n\t\treturn 0;\n\n\treturn -EIO;\n}\n\nint btd_adapter_remove_remote_oob_data(struct btd_adapter *adapter,\n\t\t\t\t\t\t\tconst bdaddr_t *bdaddr)\n{\n\tstruct mgmt_cp_remove_remote_oob_data cp;\n\tchar addr[18];\n\n\tba2str(bdaddr, addr);\n\tDBG(\"hci%d bdaddr %s\", adapter->dev_id, addr);\n\n\tmemset(&cp, 0, sizeof(cp));\n\tbacpy(&cp.addr.bdaddr, bdaddr);\n\n\tif (mgmt_send(adapter->mgmt, MGMT_OP_REMOVE_REMOTE_OOB_DATA,\n\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\tNULL, NULL, NULL) > 0)\n\t\treturn 0;\n\n\treturn -EIO;\n}\n\nbool btd_adapter_ssp_enabled(struct btd_adapter *adapter)\n{\n\tif (adapter->current_settings & MGMT_SETTING_SSP)\n\t\treturn true;\n\n\treturn false;\n}\n\nvoid btd_adapter_set_oob_handler(struct btd_adapter *adapter,\n\t\t\t\t\t\tstruct oob_handler *handler)\n{\n\tadapter->oob_handler = handler;\n}\n\ngboolean btd_adapter_check_oob_handler(struct btd_adapter *adapter)\n{\n\treturn adapter->oob_handler != NULL;\n}\n\nstatic void read_local_oob_data_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_rp_read_local_oob_data *rp = param;\n\tstruct btd_adapter *adapter = user_data;\n\tconst uint8_t *hash, *randomizer;\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Read local OOB data failed: %s (0x%02x)\",\n\t\t\t\t\t\tmgmt_errstr(status), status);\n\t\thash = NULL;\n\t\trandomizer = NULL;\n\t} else if (length < sizeof(*rp)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Too small read local OOB data response\");\n\t\treturn;\n\t} else {\n\t\thash = rp->hash192;\n\t\trandomizer = rp->rand192;\n\t}\n\n\tif (!adapter->oob_handler || !adapter->oob_handler->read_local_cb)\n\t\treturn;\n\n\tadapter->oob_handler->read_local_cb(adapter, hash, randomizer,\n\t\t\t\t\tadapter->oob_handler->user_data);\n\n\tg_free(adapter->oob_handler);\n\tadapter->oob_handler = NULL;\n}\n\nint btd_adapter_read_local_oob_data(struct btd_adapter *adapter)\n{\n\tDBG(\"hci%u\", adapter->dev_id);\n\n\tif (mgmt_send(adapter->mgmt, MGMT_OP_READ_LOCAL_OOB_DATA,\n\t\t\tadapter->dev_id, 0, NULL, read_local_oob_data_complete,\n\t\t\tadapter, NULL) > 0)\n\t\treturn 0;\n\n\treturn -EIO;\n}\n\nvoid btd_adapter_for_each_device(struct btd_adapter *adapter,\n\t\t\tvoid (*cb)(struct btd_device *device, void *data),\n\t\t\tvoid *data)\n{\n\tg_slist_foreach(adapter->devices, (GFunc) cb, data);\n}\n\nstatic int adapter_cmp(gconstpointer a, gconstpointer b)\n{\n\tstruct btd_adapter *adapter = (struct btd_adapter *) a;\n\tconst bdaddr_t *bdaddr = b;\n\n\treturn bacmp(&adapter->bdaddr, bdaddr);\n}\n\nstatic int adapter_id_cmp(gconstpointer a, gconstpointer b)\n{\n\tstruct btd_adapter *adapter = (struct btd_adapter *) a;\n\tuint16_t id = GPOINTER_TO_UINT(b);\n\n\treturn adapter->dev_id == id ? 0 : -1;\n}\n\nstruct btd_adapter *adapter_find(const bdaddr_t *sba)\n{\n\tGSList *match;\n\n\tmatch = g_slist_find_custom(adapters, sba, adapter_cmp);\n\tif (!match)\n\t\treturn NULL;\n\n\treturn match->data;\n}\n\nstruct btd_adapter *adapter_find_by_id(int id)\n{\n\tGSList *match;\n\n\tmatch = g_slist_find_custom(adapters, GINT_TO_POINTER(id),\n\t\t\t\t\t\t\tadapter_id_cmp);\n\tif (!match)\n\t\treturn NULL;\n\n\treturn match->data;\n}\n\nvoid adapter_foreach(adapter_cb func, gpointer user_data)\n{\n\tg_slist_foreach(adapters, (GFunc) func, user_data);\n}\n\nstatic int set_did(struct btd_adapter *adapter, uint16_t vendor,\n\t\t\tuint16_t product, uint16_t version, uint16_t source)\n{\n\tstruct mgmt_cp_set_device_id cp;\n\n\tDBG(\"hci%u source %x vendor %x product %x version %x\",\n\t\t\tadapter->dev_id, source, vendor, product, version);\n\n\tmemset(&cp, 0, sizeof(cp));\n\n\tcp.source = htobs(source);\n\tcp.vendor = htobs(vendor);\n\tcp.product = htobs(product);\n\tcp.version = htobs(version);\n\n\tif (mgmt_send(adapter->mgmt, MGMT_OP_SET_DEVICE_ID,\n\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\tNULL, NULL, NULL) > 0)\n\t\treturn 0;\n\n\treturn -EIO;\n}\n\nstatic void services_modified(struct gatt_db_attribute *attrib, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\t\tADAPTER_INTERFACE, \"UUIDs\");\n}\n\nstatic int adapter_register(struct btd_adapter *adapter)\n{\n\tstruct agent *agent;\n\tstruct gatt_db *db;\n\n\tif (powering_down)\n\t\treturn -EBUSY;\n\n\tadapter->path = g_strdup_printf(\"/org/bluez/hci%d\", adapter->dev_id);\n\n\tif (!g_dbus_register_interface(dbus_conn,\n\t\t\t\t\tadapter->path, ADAPTER_INTERFACE,\n\t\t\t\t\tadapter_methods, NULL,\n\t\t\t\t\tadapter_properties, adapter,\n\t\t\t\t\tadapter_free)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Adapter interface init failed on path %s\",\n\t\t\t\t\t\t\tadapter->path);\n\t\tg_free(adapter->path);\n\t\tadapter->path = NULL;\n\t\treturn -EINVAL;\n\t}\n\n\tif (adapters == NULL)\n\t\tadapter->is_default = true;\n\n\tadapters = g_slist_append(adapters, adapter);\n\n\tagent = agent_get(NULL);\n\tif (agent) {\n\t\tuint8_t io_cap = agent_get_io_capability(agent);\n\t\tadapter_set_io_capability(adapter, io_cap);\n\t\tagent_unref(agent);\n\t}\n\n\t/* Don't start GATT database and advertising managers on\n\t * non-LE controllers.\n\t */\n\tif (!(adapter->supported_settings & MGMT_SETTING_LE) ||\n\t\t\t\t\tbtd_opts.mode == BT_MODE_BREDR)\n\t\tgoto load;\n\n\tadapter->database = btd_gatt_database_new(adapter);\n\tif (!adapter->database) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Failed to create GATT database for adapter\");\n\t\tadapters = g_slist_remove(adapters, adapter);\n\t\treturn -EINVAL;\n\t}\n\n\tadapter->adv_manager = btd_adv_manager_new(adapter, adapter->mgmt);\n\n\tif (g_dbus_get_flags() & G_DBUS_FLAG_ENABLE_EXPERIMENTAL) {\n\t\tif (adapter->supported_settings & MGMT_SETTING_LE) {\n\t\t\tadapter->adv_monitor_manager =\n\t\t\t\tbtd_adv_monitor_manager_create(adapter,\n\t\t\t\t\t\t\t\tadapter->mgmt);\n\t\t\tif (!adapter->adv_monitor_manager) {\n\t\t\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\t\t\"Failed to create Adv Monitor \"\n\t\t\t\t\t\t\"Manager for adapter\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tbtd_info(adapter->dev_id, \"Adv Monitor Manager \"\n\t\t\t\t\t\"skipped, LE unavailable\");\n\t\t}\n\t}\n\n\tif (g_dbus_get_flags() & G_DBUS_FLAG_ENABLE_EXPERIMENTAL) {\n\t\tadapter->battery_provider_manager =\n\t\t\tbtd_battery_provider_manager_create(adapter);\n\t}\n\n\tdb = btd_gatt_database_get_db(adapter->database);\n\tadapter->db_id = gatt_db_register(db, services_modified,\n\t\t\t\t\t\t\tservices_modified,\n\t\t\t\t\t\t\tadapter, NULL);\n\nload:\n\tmgmt_register(adapter->mgmt, MGMT_EV_DEVICE_FLAGS_CHANGED,\n\t\t\t\t\t\tadapter->dev_id,\n\t\t\t\t\t\tdevice_flags_changed_callback,\n\t\t\t\t\t\tadapter, NULL);\n\n\tload_config(adapter);\n\tfix_storage(adapter);\n\tload_drivers(adapter);\n\tbtd_profile_foreach(probe_profile, adapter);\n\tclear_blocked(adapter);\n\tload_defaults(adapter);\n\tload_devices(adapter);\n\n\t/* restore Service Changed CCC value for bonded devices */\n\tbtd_gatt_database_restore_svc_chng_ccc(adapter->database);\n\n\t/* retrieve the active connections: address the scenario where\n\t * the are active connections before the daemon've started */\n\tif (btd_adapter_get_powered(adapter))\n\t\tload_connections(adapter);\n\n\tadapter->initialized = TRUE;\n\n\tif (btd_opts.did_source) {\n\t\t/* DeviceID record is added by sdpd-server before any other\n\t\t * record is registered. */\n\t\tadapter_service_insert(adapter, sdp_record_find(0x10000));\n\t\tset_did(adapter, btd_opts.did_vendor, btd_opts.did_product,\n\t\t\t\tbtd_opts.did_version, btd_opts.did_source);\n\t}\n\n\tDBG(\"Adapter %s registered\", adapter->path);\n\n\treturn 0;\n}\n\nstatic int adapter_unregister(struct btd_adapter *adapter)\n{\n\tDBG(\"Unregister path: %s\", adapter->path);\n\n\tadapters = g_slist_remove(adapters, adapter);\n\n\tif (adapter->is_default && adapters != NULL) {\n\t\tstruct btd_adapter *new_default;\n\n\t\tnew_default = adapter_find_by_id(hci_get_route(NULL));\n\t\tif (new_default == NULL)\n\t\t\tnew_default = adapters->data;\n\n\t\tnew_default->is_default = true;\n\t}\n\n\tadapter_list = g_list_remove(adapter_list, adapter);\n\n\tadapter_remove(adapter);\n\tbtd_adapter_unref(adapter);\n\n\treturn 0;\n}\n\nstatic void disconnected_callback(uint16_t index, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_ev_device_disconnected *ev = param;\n\tstruct btd_adapter *adapter = user_data;\n\tuint8_t reason;\n\n\tif (length < sizeof(struct mgmt_addr_info)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Too small device disconnected event\");\n\t\treturn;\n\t}\n\n\tif (length < sizeof(*ev))\n\t\treason = MGMT_DEV_DISCONN_UNKNOWN;\n\telse\n\t\treason = ev->reason;\n\n\tdev_disconnected(adapter, &ev->addr, reason);\n}\n\nstatic void connected_callback(uint16_t index, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_ev_device_connected *ev = param;\n\tstruct btd_adapter *adapter = user_data;\n\tstruct btd_device *device;\n\tstruct eir_data eir_data;\n\tuint16_t eir_len;\n\tchar addr[18];\n\tbool name_known;\n\n\tif (length < sizeof(*ev)) {\n\t\tbtd_error(adapter->dev_id, \"Too small device connected event\");\n\t\treturn;\n\t}\n\n\teir_len = btohs(ev->eir_len);\n\tif (length < sizeof(*ev) + eir_len) {\n\t\tbtd_error(adapter->dev_id, \"Too small device connected event\");\n\t\treturn;\n\t}\n\n\tba2str(&ev->addr.bdaddr, addr);\n\n\tDBG(\"hci%u device %s connected eir_len %u\", index, addr, eir_len);\n\n\tdevice = btd_adapter_get_device(adapter, &ev->addr.bdaddr,\n\t\t\t\t\t\t\t\tev->addr.type);\n\tif (!device) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Unable to get device object for %s\", addr);\n\t\treturn;\n\t}\n\n\tmemset(&eir_data, 0, sizeof(eir_data));\n\tif (eir_len > 0)\n\t\teir_parse(&eir_data, ev->eir, eir_len);\n\n\tif (eir_data.class != 0)\n\t\tdevice_set_class(device, eir_data.class);\n\n\tadapter_add_connection(adapter, device, ev->addr.type);\n\n\tname_known = device_name_known(device);\n\n\tif (eir_data.name && (eir_data.name_complete || !name_known)) {\n\t\tdevice_store_cached_name(device, eir_data.name);\n\t\tbtd_device_device_set_name(device, eir_data.name);\n\t}\n\n\tif (eir_data.msd_list)\n\t\tadapter_msd_notify(adapter, device, eir_data.msd_list);\n\n\teir_data_free(&eir_data);\n}\n\nstatic void controller_resume_notify(struct btd_adapter *adapter)\n{\n\tGSList *l;\n\n\tfor (l = adapter->drivers; l; l = g_slist_next(l)) {\n\t\tstruct btd_adapter_driver *driver = l->data;\n\t\tif (driver->resume)\n\t\t\tdriver->resume(adapter);\n\t}\n}\n\nstatic void controller_resume_callback(uint16_t index, uint16_t length,\n\t\t\t\t       const void *param, void *user_data)\n{\n\tconst struct mgmt_ev_controller_resume *ev = param;\n\tstruct btd_adapter *adapter = user_data;\n\n\tif (length < sizeof(*ev)) {\n\t\tbtd_error(adapter->dev_id, \"Too small device resume event\");\n\t\treturn;\n\t}\n\n\tinfo(\"Controller resume with wake event 0x%x\", ev->wake_reason);\n\n\tcontroller_resume_notify(adapter);\n}\n\nstatic void device_blocked_callback(uint16_t index, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_ev_device_blocked *ev = param;\n\tstruct btd_adapter *adapter = user_data;\n\tstruct btd_device *device;\n\tchar addr[18];\n\n\tif (length < sizeof(*ev)) {\n\t\tbtd_error(adapter->dev_id, \"Too small device blocked event\");\n\t\treturn;\n\t}\n\n\tba2str(&ev->addr.bdaddr, addr);\n\tDBG(\"hci%u %s blocked\", index, addr);\n\n\tdevice = btd_adapter_find_device(adapter, &ev->addr.bdaddr,\n\t\t\t\t\t\t\t\tev->addr.type);\n\tif (device)\n\t\tdevice_block(device, TRUE);\n}\n\nstatic void device_unblocked_callback(uint16_t index, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_ev_device_unblocked *ev = param;\n\tstruct btd_adapter *adapter = user_data;\n\tstruct btd_device *device;\n\tchar addr[18];\n\n\tif (length < sizeof(*ev)) {\n\t\tbtd_error(adapter->dev_id, \"Too small device unblocked event\");\n\t\treturn;\n\t}\n\n\tba2str(&ev->addr.bdaddr, addr);\n\tDBG(\"hci%u %s unblocked\", index, addr);\n\n\tdevice = btd_adapter_find_device(adapter, &ev->addr.bdaddr,\n\t\t\t\t\t\t\t\tev->addr.type);\n\tif (device)\n\t\tdevice_unblock(device, FALSE, TRUE);\n}\n\nstatic void conn_fail_notify(struct btd_device *dev, uint8_t status)\n{\n\tGSList *l;\n\n\tfor (l = conn_fail_list; l; l = g_slist_next(l)) {\n\t\tbtd_conn_fail_cb conn_fail_cb = l->data;\n\t\tconn_fail_cb(dev, status);\n\t}\n}\n\nvoid btd_add_conn_fail_cb(btd_conn_fail_cb func)\n{\n\tconn_fail_list = g_slist_append(conn_fail_list, func);\n}\n\nvoid btd_remove_conn_fail_cb(btd_conn_fail_cb func)\n{\n\tconn_fail_list = g_slist_remove(conn_fail_list, func);\n}\n\nstatic void connect_failed_callback(uint16_t index, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_ev_connect_failed *ev = param;\n\tstruct btd_adapter *adapter = user_data;\n\tstruct btd_device *device;\n\tchar addr[18];\n\n\tif (length < sizeof(*ev)) {\n\t\tbtd_error(adapter->dev_id, \"Too small connect failed event\");\n\t\treturn;\n\t}\n\n\tba2str(&ev->addr.bdaddr, addr);\n\n\tDBG(\"hci%u %s status %u\", index, addr, ev->status);\n\n\tdevice = btd_adapter_find_device(adapter, &ev->addr.bdaddr,\n\t\t\t\t\t\t\t\tev->addr.type);\n\tif (device) {\n\t\tconn_fail_notify(device, ev->status);\n\n\t\t/* If the device is in a bonding process cancel any auth request\n\t\t * sent to the agent before proceeding, but keep the bonding\n\t\t * request structure. */\n\t\tif (device_is_bonding(device, NULL))\n\t\t\tdevice_cancel_authentication(device, FALSE);\n\t}\n\n\t/* In the case of security mode 3 devices */\n\tbonding_attempt_complete(adapter, &ev->addr.bdaddr, ev->addr.type,\n\t\t\t\t\t\t\t\tev->status);\n\n\t/* If the device is scheduled to retry the bonding wait until the retry\n\t * happens. In other case, proceed with cancel the bondig.\n\t */\n\tif (device && device_is_bonding(device, NULL)\n\t\t\t\t\t&& !device_is_retrying(device)) {\n\t\tdevice_cancel_authentication(device, TRUE);\n\t\tdevice_bonding_failed(device, ev->status);\n\t}\n\n\t/* In the case the bonding was canceled or did exists, remove the device\n\t * when it is temporary. */\n\tif (device && !device_is_bonding(device, NULL)\n\t\t\t\t\t\t&& device_is_temporary(device))\n\t\tbtd_adapter_remove_device(adapter, device);\n}\n\nstatic void remove_keys(struct btd_adapter *adapter,\n\t\t\t\t\tstruct btd_device *device, uint8_t type)\n{\n\tchar device_addr[18];\n\tchar filename[PATH_MAX];\n\tGKeyFile *key_file;\n\tgsize length = 0;\n\tchar *str;\n\n\tba2str(device_get_address(device), device_addr);\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/%s/info\",\n\t\t\tbtd_adapter_get_storage_dir(adapter), device_addr);\n\tkey_file = g_key_file_new();\n\tg_key_file_load_from_file(key_file, filename, 0, NULL);\n\n\tif (type == BDADDR_BREDR) {\n\t\tg_key_file_remove_group(key_file, \"LinkKey\", NULL);\n\t} else {\n\t\tg_key_file_remove_group(key_file, \"LongTermKey\", NULL);\n\t\tg_key_file_remove_group(key_file, \"LocalSignatureKey\", NULL);\n\t\tg_key_file_remove_group(key_file, \"RemoteSignatureKey\", NULL);\n\t\tg_key_file_remove_group(key_file, \"IdentityResolvingKey\", NULL);\n\t}\n\n\tstr = g_key_file_to_data(key_file, &length, NULL);\n\tg_file_set_contents(filename, str, length, NULL);\n\tg_free(str);\n\n\tg_key_file_free(key_file);\n}\n\nstatic void unpaired_callback(uint16_t index, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_ev_device_unpaired *ev = param;\n\tstruct btd_adapter *adapter = user_data;\n\tstruct btd_device *device;\n\tchar addr[18];\n\n\tif (length < sizeof(*ev)) {\n\t\tbtd_error(adapter->dev_id, \"Too small device unpaired event\");\n\t\treturn;\n\t}\n\n\tba2str(&ev->addr.bdaddr, addr);\n\n\tDBG(\"hci%u addr %s\", index, addr);\n\n\tdevice = btd_adapter_find_device(adapter, &ev->addr.bdaddr,\n\t\t\t\t\t\t\t\tev->addr.type);\n\tif (!device) {\n\t\tbtd_warn(adapter->dev_id,\n\t\t\t\"No device object for unpaired device %s\", addr);\n\t\treturn;\n\t}\n\n\tremove_keys(adapter, device, ev->addr.type);\n\tdevice_set_unpaired(device, ev->addr.type);\n}\n\nstatic void clear_devices_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\terror(\"Failed to clear devices: %s (0x%02x)\",\n\t\t\t\t\t\tmgmt_errstr(status), status);\n\t\treturn;\n\t}\n}\n\nstatic int clear_devices(struct btd_adapter *adapter)\n{\n\tstruct mgmt_cp_remove_device cp;\n\n\tif (!btd_has_kernel_features(KERNEL_CONN_CONTROL))\n\t\treturn 0;\n\n\tmemset(&cp, 0, sizeof(cp));\n\n\tDBG(\"sending clear devices command for index %u\", adapter->dev_id);\n\n\tif (mgmt_send(adapter->mgmt, MGMT_OP_REMOVE_DEVICE,\n\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\tclear_devices_complete, adapter, NULL) > 0)\n\t\treturn 0;\n\n\tbtd_error(adapter->dev_id, \"Failed to clear devices for index %u\",\n\t\t\t\t\t\t\tadapter->dev_id);\n\n\treturn -EIO;\n}\n\nstatic bool get_static_addr(struct btd_adapter *adapter)\n{\n\tstruct bt_crypto *crypto;\n\tGKeyFile *file;\n\tchar **addrs;\n\tchar mfg[7];\n\tchar *str;\n\tbool ret;\n\tgsize len, i;\n\n\tsnprintf(mfg, sizeof(mfg), \"0x%04x\", adapter->manufacturer);\n\n\tfile = g_key_file_new();\n\tg_key_file_load_from_file(file, STORAGEDIR \"/addresses\", 0, NULL);\n\taddrs = g_key_file_get_string_list(file, \"Static\", mfg, &len, NULL);\n\tif (addrs) {\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tbdaddr_t addr;\n\n\t\t\tstr2ba(addrs[i], &addr);\n\t\t\tif (adapter_find(&addr))\n\t\t\t\tcontinue;\n\n\t\t\t/* Usable address found in list */\n\t\t\tbacpy(&adapter->bdaddr, &addr);\n\t\t\tadapter->bdaddr_type = BDADDR_LE_RANDOM;\n\t\t\tret = true;\n\t\t\tgoto done;\n\t\t}\n\n\t\tlen++;\n\t\taddrs = g_renew(char *, addrs, len + 1);\n\t} else {\n\t\tlen = 1;\n\t\taddrs = g_new(char *, len + 1);\n\t}\n\n\t/* Initialize slot for new address */\n\taddrs[len - 1] = g_malloc(18);\n\taddrs[len] = NULL;\n\n\tcrypto = bt_crypto_new();\n\tif (!crypto) {\n\t\terror(\"Failed to open crypto\");\n\t\tret = false;\n\t\tgoto done;\n\t}\n\n\tret = bt_crypto_random_bytes(crypto, &adapter->bdaddr,\n\t\t\t\t\t\tsizeof(adapter->bdaddr));\n\tif (!ret) {\n\t\terror(\"Failed to generate static address\");\n\t\tbt_crypto_unref(crypto);\n\t\tgoto done;\n\t}\n\n\tbt_crypto_unref(crypto);\n\n\tadapter->bdaddr.b[5] |= 0xc0;\n\tadapter->bdaddr_type = BDADDR_LE_RANDOM;\n\n\tba2str(&adapter->bdaddr, addrs[len - 1]);\n\n\tg_key_file_set_string_list(file, \"Static\", mfg,\n\t\t\t\t\t\t(const char **)addrs, len);\n\n\tstr = g_key_file_to_data(file, &len, NULL);\n\tg_file_set_contents(STORAGEDIR \"/addresses\", str, len, NULL);\n\tg_free(str);\n\n\tret = true;\n\ndone:\n\tg_key_file_free(file);\n\tg_strfreev(addrs);\n\n\treturn ret;\n}\n\nstatic bool set_static_addr(struct btd_adapter *adapter)\n{\n\tstruct mgmt_cp_set_static_address cp;\n\n\t/* dual-mode adapters must have a public address */\n\tif (adapter->supported_settings & MGMT_SETTING_BREDR)\n\t\treturn false;\n\n\tif (!(adapter->supported_settings & MGMT_SETTING_LE))\n\t\treturn false;\n\n\tDBG(\"Setting static address\");\n\n\tif (!get_static_addr(adapter))\n\t\treturn false;\n\n\tbacpy(&cp.bdaddr, &adapter->bdaddr);\n\tif (mgmt_send(adapter->mgmt, MGMT_OP_SET_STATIC_ADDRESS,\n\t\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\t\tNULL, NULL, NULL) > 0) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void set_blocked_keys_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Failed to set blocked keys: %s (0x%02x)\",\n\t\t\t\tmgmt_errstr(status), status);\n\t\treturn;\n\t}\n\n\tDBG(\"Successfully set blocked keys for index %u\", adapter->dev_id);\n}\n\nstatic bool set_blocked_keys(struct btd_adapter *adapter)\n{\n\tuint8_t buffer[sizeof(struct mgmt_cp_set_blocked_keys) +\n\t\t\t\t\tsizeof(blocked_keys)] = { 0 };\n\tstruct mgmt_cp_set_blocked_keys *cp =\n\t\t\t\t(struct mgmt_cp_set_blocked_keys *)buffer;\n\tint i;\n\n\tcp->key_count = ARRAY_SIZE(blocked_keys);\n\tfor (i = 0; i < cp->key_count; ++i) {\n\t\tcp->keys[i].type = blocked_keys[i].type;\n\t\tmemcpy(cp->keys[i].val, blocked_keys[i].val,\n\t\t\t\t\t\tsizeof(cp->keys[i].val));\n\t}\n\n\treturn mgmt_send(mgmt_master, MGMT_OP_SET_BLOCKED_KEYS, adapter->dev_id,\n\t\t\t\t\t\tsizeof(buffer),\tbuffer,\n\t\t\t\t\t\tset_blocked_keys_complete,\n\t\t\t\t\t\tadapter, NULL);\n}\n\n#define EXP_FEAT(_uuid, _func) \\\n{ \\\n\t.uuid = _uuid, \\\n\t.func = _func, \\\n}\n\n/* d4992530-b9ec-469f-ab01-6c481c47da1c */\nstatic const uint8_t debug_uuid[16] = {\n\t0x1c, 0xda, 0x47, 0x1c, 0x48, 0x6c, 0x01, 0xab,\n\t0x9f, 0x46, 0xec, 0xb9, 0x30, 0x25, 0x99, 0xd4,\n};\n\n/* 671b10b5-42c0-4696-9227-eb28d1b049d6 */\nstatic const uint8_t le_simult_central_peripheral_uuid[16] = {\n\t0xd6, 0x49, 0xb0, 0xd1, 0x28, 0xeb, 0x27, 0x92,\n\t0x96, 0x46, 0xc0, 0x42, 0xb5, 0x10, 0x1b, 0x67,\n};\n\n/* 330859bc-7506-492d-9370-9a6f0614037f */\nstatic const uint8_t quality_report_uuid[16] = {\n\t0x7f, 0x03, 0x14, 0x06, 0x6f, 0x9a, 0x70, 0x93,\n\t0x2d, 0x49, 0x06, 0x75, 0xbc, 0x59, 0x08, 0x33,\n};\n\n/* 15c0a148-c273-11ea-b3de-0242ac130004 */\nstatic const uint8_t rpa_resolution_uuid[16] = {\n\t0x04, 0x00, 0x13, 0xac, 0x42, 0x02, 0xde, 0xb3,\n\t0xea, 0x11, 0x73, 0xc2, 0x48, 0xa1, 0xc0, 0x15,\n};\n\nstatic void set_exp_debug_complete(uint8_t status, uint16_t len,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tif (status != 0)\n\t\terror(\"Set Experimental Debug failed with status 0x%02x (%s)\",\n\t\t\t\t\t\tstatus, mgmt_errstr(status));\n\telse\n\t\tDBG(\"Experimental Debug successfully set\");\n}\n\nstatic void exp_debug_func(struct btd_adapter *adapter, uint32_t flags)\n{\n\tstruct mgmt_cp_set_exp_feature cp;\n\tuint8_t action = btd_opts.experimental ? 0x01 : 0x00;\n\n\t/* If already set don't attempt to set it again */\n\tif (action == (flags & BIT(0)))\n\t\treturn;\n\n\tmemset(&cp, 0, sizeof(cp));\n\tmemcpy(cp.uuid, debug_uuid, 16);\n\tcp.action = btd_opts.experimental ? 0x01 : 0x00;\n\n\tif (mgmt_send(adapter->mgmt, MGMT_OP_SET_EXP_FEATURE,\n\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\tset_exp_debug_complete, adapter, NULL) > 0)\n\t\treturn;\n\n\tbtd_error(adapter->dev_id, \"Failed to set exp debug\");\n}\n\nstatic void le_simult_central_peripheral_func(struct btd_adapter *adapter,\n\t\t\t\t\t\t\tuint32_t flags)\n{\n\tadapter->le_simult_roles_supported = flags & 0x01;\n}\n\nstatic void quality_report_func(struct btd_adapter *adapter, uint32_t flags)\n{\n\tadapter->quality_report_supported = le32_to_cpu(flags) & 0x01;\n\n\tbtd_info(adapter->dev_id, \"quality_report_supported %d\",\n\t\t\tadapter->quality_report_supported);\n}\n\nstatic void set_rpa_resolution_complete(uint8_t status, uint16_t len,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tif (status != 0)\n\t\terror(\"Set RPA Resolution failed with status 0x%02x (%s)\",\n\t\t\t\t\t\tstatus, mgmt_errstr(status));\n\telse\n\t\tDBG(\"RPA Resolution successfully set\");\n}\n\nstatic void rpa_resolution_func(struct btd_adapter *adapter, uint32_t flags)\n{\n\tstruct mgmt_cp_set_exp_feature cp;\n\tuint8_t action = btd_opts.experimental ? 0x01 : 0x00;\n\n\t/* If already set don't attempt to set it again */\n\tif (action == (flags & BIT(0)))\n\t\treturn;\n\n\tmemset(&cp, 0, sizeof(cp));\n\tmemcpy(cp.uuid, rpa_resolution_uuid, 16);\n\tcp.action = action;\n\n\tif (mgmt_send(adapter->mgmt, MGMT_OP_SET_EXP_FEATURE,\n\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\tset_rpa_resolution_complete, adapter, NULL) > 0)\n\t\treturn;\n\n\tbtd_error(adapter->dev_id, \"Failed to set RPA Resolution\");\n}\n\nstatic const struct exp_feat {\n\tconst uint8_t *uuid;\n\tvoid (*func)(struct btd_adapter *adapter, uint32_t flags);\n} exp_table[] = {\n\tEXP_FEAT(debug_uuid, exp_debug_func),\n\tEXP_FEAT(le_simult_central_peripheral_uuid,\n\t\t le_simult_central_peripheral_func),\n\tEXP_FEAT(quality_report_uuid, quality_report_func),\n\tEXP_FEAT(rpa_resolution_uuid, rpa_resolution_func),\n};\n\nstatic void read_exp_features_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tconst struct mgmt_rp_read_exp_features_info *rp = param;\n\tsize_t feature_count = 0;\n\tsize_t i = 0;\n\n\tDBG(\"index %u status 0x%02x\", adapter->dev_id, status);\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Failed to read exp features info: %s (0x%02x)\",\n\t\t\t\tmgmt_errstr(status), status);\n\t\treturn;\n\t}\n\n\tif (length < sizeof(*rp)) {\n\t\tbtd_error(adapter->dev_id, \"Response too small\");\n\t\treturn;\n\t}\n\n\tfeature_count = le16_to_cpu(rp->feature_count);\n\n\tif (length < sizeof(*rp) + (sizeof(*rp->features) * feature_count)) {\n\t\tbtd_error(adapter->dev_id, \"Response too small\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < feature_count; ++i) {\n\t\tsize_t j;\n\n\t\tfor (j = 0; j < ARRAY_SIZE(exp_table); j++) {\n\t\t\tconst struct exp_feat *feat = &exp_table[j];\n\n\t\t\tif (memcmp(rp->features[i].uuid, feat->uuid,\n\t\t\t\t\tsizeof(rp->features[i].uuid)))\n\t\t\t\tcontinue;\n\n\t\t\tif (feat->func)\n\t\t\t\tfeat->func(adapter, rp->features[i].flags);\n\t\t}\n\t}\n}\n\nstatic void read_exp_features(struct btd_adapter *adapter)\n{\n\tif (mgmt_send(adapter->mgmt, MGMT_OP_READ_EXP_FEATURES_INFO,\n\t\t\tadapter->dev_id, 0, NULL, read_exp_features_complete,\n\t\t\tadapter, NULL) > 0)\n\t\treturn;\n\n\tbtd_error(adapter->dev_id, \"Failed to read exp features info\");\n}\n\nstatic void read_info_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tstruct btd_adapter *adapter = user_data;\n\tconst struct mgmt_rp_read_info *rp = param;\n\tuint32_t missing_settings;\n\tint err;\n\n\tDBG(\"index %u status 0x%02x\", adapter->dev_id, status);\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Failed to read info for index %u: %s (0x%02x)\",\n\t\t\t\tadapter->dev_id, mgmt_errstr(status), status);\n\t\tgoto failed;\n\t}\n\n\tif (length < sizeof(*rp)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Too small read info complete response\");\n\t\tgoto failed;\n\t}\n\n\t/*\n\t * Store controller information for class of device, device\n\t * name, short name and settings.\n\t *\n\t * During the lifetime of the controller these will be updated by\n\t * events and the information is required to keep the current\n\t * state of the controller.\n\t */\n\tadapter->dev_class = rp->dev_class[0] | (rp->dev_class[1] << 8) |\n\t\t\t\t\t\t(rp->dev_class[2] << 16);\n\tadapter->name = g_strdup((const char *) rp->name);\n\tadapter->short_name = g_strdup((const char *) rp->short_name);\n\n\tadapter->manufacturer = btohs(rp->manufacturer);\n\n\tadapter->supported_settings = btohl(rp->supported_settings);\n\tadapter->current_settings = btohl(rp->current_settings);\n\n\tclear_uuids(adapter);\n\tclear_devices(adapter);\n\n\tif (bacmp(&rp->bdaddr, BDADDR_ANY) == 0) {\n\t\tif (!set_static_addr(adapter)) {\n\t\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\t\"No Bluetooth address for index %u\",\n\t\t\t\t\tadapter->dev_id);\n\t\t\tgoto failed;\n\t\t}\n\t} else {\n\t\tbacpy(&adapter->bdaddr, &rp->bdaddr);\n\t\tif (!(adapter->supported_settings & MGMT_SETTING_LE))\n\t\t\tadapter->bdaddr_type = BDADDR_BREDR;\n\t\telse\n\t\t\tadapter->bdaddr_type = BDADDR_LE_PUBLIC;\n\t}\n\n\tmissing_settings = adapter->current_settings ^\n\t\t\t\t\t\tadapter->supported_settings;\n\n\tswitch (btd_opts.mode) {\n\tcase BT_MODE_DUAL:\n\t\tif (missing_settings & MGMT_SETTING_SSP)\n\t\t\tset_mode(adapter, MGMT_OP_SET_SSP, 0x01);\n\t\tif (missing_settings & MGMT_SETTING_LE)\n\t\t\tset_mode(adapter, MGMT_OP_SET_LE, 0x01);\n\t\tif (missing_settings & MGMT_SETTING_BREDR)\n\t\t\tset_mode(adapter, MGMT_OP_SET_BREDR, 0x01);\n\t\tbreak;\n\tcase BT_MODE_BREDR:\n\t\tif (!(adapter->supported_settings & MGMT_SETTING_BREDR)) {\n\t\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Ignoring adapter withouth BR/EDR support\");\n\t\t\tgoto failed;\n\t\t}\n\n\t\tif (missing_settings & MGMT_SETTING_SSP)\n\t\t\tset_mode(adapter, MGMT_OP_SET_SSP, 0x01);\n\t\tif (missing_settings & MGMT_SETTING_BREDR)\n\t\t\tset_mode(adapter, MGMT_OP_SET_BREDR, 0x01);\n\t\tif (adapter->current_settings & MGMT_SETTING_LE)\n\t\t\tset_mode(adapter, MGMT_OP_SET_LE, 0x00);\n\t\tbreak;\n\tcase BT_MODE_LE:\n\t\tif (!(adapter->supported_settings & MGMT_SETTING_LE)) {\n\t\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Ignoring adapter withouth LE support\");\n\t\t\tgoto failed;\n\t\t}\n\n\t\tif (missing_settings & MGMT_SETTING_LE)\n\t\t\tset_mode(adapter, MGMT_OP_SET_LE, 0x01);\n\t\tif (adapter->current_settings & MGMT_SETTING_BREDR)\n\t\t\tset_mode(adapter, MGMT_OP_SET_BREDR, 0x00);\n\t\tbreak;\n\t}\n\n\tif (missing_settings & MGMT_SETTING_SECURE_CONN)\n\t\tset_mode(adapter, MGMT_OP_SET_SECURE_CONN, 0x01);\n\n\tif (adapter->supported_settings & MGMT_SETTING_PRIVACY)\n\t\tset_privacy(adapter, btd_opts.privacy);\n\n\tif (btd_opts.fast_conn &&\n\t\t\t(missing_settings & MGMT_SETTING_FAST_CONNECTABLE))\n\t\tset_mode(adapter, MGMT_OP_SET_FAST_CONNECTABLE, 0x01);\n\n\terr = adapter_register(adapter);\n\tif (err < 0) {\n\t\tbtd_error(adapter->dev_id, \"Unable to register new adapter\");\n\t\tgoto failed;\n\t}\n\n\t/*\n\t * Register all event notification handlers for controller.\n\t *\n\t * The handlers are registered after a succcesful read of the\n\t * controller info. From now on they can track updates and\n\t * notifications.\n\t */\n\tmgmt_register(adapter->mgmt, MGMT_EV_NEW_SETTINGS, adapter->dev_id,\n\t\t\t\t\tnew_settings_callback, adapter, NULL);\n\n\tmgmt_register(adapter->mgmt, MGMT_EV_CLASS_OF_DEV_CHANGED,\n\t\t\t\t\t\tadapter->dev_id,\n\t\t\t\t\t\tdev_class_changed_callback,\n\t\t\t\t\t\tadapter, NULL);\n\tmgmt_register(adapter->mgmt, MGMT_EV_LOCAL_NAME_CHANGED,\n\t\t\t\t\t\tadapter->dev_id,\n\t\t\t\t\t\tlocal_name_changed_callback,\n\t\t\t\t\t\tadapter, NULL);\n\n\tmgmt_register(adapter->mgmt, MGMT_EV_DISCOVERING,\n\t\t\t\t\t\tadapter->dev_id,\n\t\t\t\t\t\tdiscovering_callback,\n\t\t\t\t\t\tadapter, NULL);\n\n\tmgmt_register(adapter->mgmt, MGMT_EV_DEVICE_FOUND,\n\t\t\t\t\t\tadapter->dev_id,\n\t\t\t\t\t\tdevice_found_callback,\n\t\t\t\t\t\tadapter, NULL);\n\n\tmgmt_register(adapter->mgmt, MGMT_EV_DEVICE_DISCONNECTED,\n\t\t\t\t\t\tadapter->dev_id,\n\t\t\t\t\t\tdisconnected_callback,\n\t\t\t\t\t\tadapter, NULL);\n\n\tmgmt_register(adapter->mgmt, MGMT_EV_DEVICE_CONNECTED,\n\t\t\t\t\t\tadapter->dev_id,\n\t\t\t\t\t\tconnected_callback,\n\t\t\t\t\t\tadapter, NULL);\n\n\tmgmt_register(adapter->mgmt, MGMT_EV_CONNECT_FAILED,\n\t\t\t\t\t\tadapter->dev_id,\n\t\t\t\t\t\tconnect_failed_callback,\n\t\t\t\t\t\tadapter, NULL);\n\n\tmgmt_register(adapter->mgmt, MGMT_EV_DEVICE_UNPAIRED,\n\t\t\t\t\t\tadapter->dev_id,\n\t\t\t\t\t\tunpaired_callback,\n\t\t\t\t\t\tadapter, NULL);\n\n\tmgmt_register(adapter->mgmt, MGMT_EV_AUTH_FAILED,\n\t\t\t\t\t\tadapter->dev_id,\n\t\t\t\t\t\tauth_failed_callback,\n\t\t\t\t\t\tadapter, NULL);\n\n\tmgmt_register(adapter->mgmt, MGMT_EV_NEW_LINK_KEY,\n\t\t\t\t\t\tadapter->dev_id,\n\t\t\t\t\t\tnew_link_key_callback,\n\t\t\t\t\t\tadapter, NULL);\n\n\tmgmt_register(adapter->mgmt, MGMT_EV_NEW_LONG_TERM_KEY,\n\t\t\t\t\t\tadapter->dev_id,\n\t\t\t\t\t\tnew_long_term_key_callback,\n\t\t\t\t\t\tadapter, NULL);\n\n\tmgmt_register(adapter->mgmt, MGMT_EV_NEW_CSRK,\n\t\t\t\t\t\tadapter->dev_id,\n\t\t\t\t\t\tnew_csrk_callback,\n\t\t\t\t\t\tadapter, NULL);\n\n\tmgmt_register(adapter->mgmt, MGMT_EV_NEW_IRK,\n\t\t\t\t\t\tadapter->dev_id,\n\t\t\t\t\t\tnew_irk_callback,\n\t\t\t\t\t\tadapter, NULL);\n\n\tmgmt_register(adapter->mgmt, MGMT_EV_NEW_CONN_PARAM,\n\t\t\t\t\t\tadapter->dev_id,\n\t\t\t\t\t\tnew_conn_param,\n\t\t\t\t\t\tadapter, NULL);\n\n\tmgmt_register(adapter->mgmt, MGMT_EV_DEVICE_BLOCKED,\n\t\t\t\t\t\tadapter->dev_id,\n\t\t\t\t\t\tdevice_blocked_callback,\n\t\t\t\t\t\tadapter, NULL);\n\tmgmt_register(adapter->mgmt, MGMT_EV_DEVICE_UNBLOCKED,\n\t\t\t\t\t\tadapter->dev_id,\n\t\t\t\t\t\tdevice_unblocked_callback,\n\t\t\t\t\t\tadapter, NULL);\n\n\tmgmt_register(adapter->mgmt, MGMT_EV_PIN_CODE_REQUEST,\n\t\t\t\t\t\tadapter->dev_id,\n\t\t\t\t\t\tpin_code_request_callback,\n\t\t\t\t\t\tadapter, NULL);\n\n\tmgmt_register(adapter->mgmt, MGMT_EV_USER_CONFIRM_REQUEST,\n\t\t\t\t\t\tadapter->dev_id,\n\t\t\t\t\t\tuser_confirm_request_callback,\n\t\t\t\t\t\tadapter, NULL);\n\n\tmgmt_register(adapter->mgmt, MGMT_EV_USER_PASSKEY_REQUEST,\n\t\t\t\t\t\tadapter->dev_id,\n\t\t\t\t\t\tuser_passkey_request_callback,\n\t\t\t\t\t\tadapter, NULL);\n\n\tmgmt_register(adapter->mgmt, MGMT_EV_PASSKEY_NOTIFY,\n\t\t\t\t\t\tadapter->dev_id,\n\t\t\t\t\t\tuser_passkey_notify_callback,\n\t\t\t\t\t\tadapter, NULL);\n\n\tmgmt_register(adapter->mgmt, MGMT_EV_CONTROLLER_RESUME,\n\t\t\t\t\t\tadapter->dev_id,\n\t\t\t\t\t\tcontroller_resume_callback,\n\t\t\t\t\t\tadapter, NULL);\n\n\tset_dev_class(adapter);\n\n\tset_name(adapter, btd_adapter_get_name(adapter));\n\n\tif (btd_has_kernel_features(KERNEL_BLOCKED_KEYS_SUPPORTED) &&\n\t    !set_blocked_keys(adapter)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"Failed to set blocked keys for index %u\",\n\t\t\t\tadapter->dev_id);\n\t\tgoto failed;\n\t}\n\n\tif (btd_opts.pairable &&\n\t\t\t!(adapter->current_settings & MGMT_SETTING_BONDABLE))\n\t\tset_mode(adapter, MGMT_OP_SET_BONDABLE, 0x01);\n\n\tif (!btd_has_kernel_features(KERNEL_CONN_CONTROL))\n\t\tset_mode(adapter, MGMT_OP_SET_CONNECTABLE, 0x01);\n\telse if (adapter->current_settings & MGMT_SETTING_CONNECTABLE)\n\t\tset_mode(adapter, MGMT_OP_SET_CONNECTABLE, 0x00);\n\n\tif (adapter->stored_discoverable && !adapter->discoverable_timeout)\n\t\tset_discoverable(adapter, 0x01, 0);\n\n\tif (btd_adapter_get_powered(adapter))\n\t\tadapter_start(adapter);\n\n\treturn;\n\nfailed:\n\t/*\n\t * Remove adapter from list in case of a failure.\n\t *\n\t * Leaving an adapter structure around for a controller that can\n\t * not be initilized makes no sense at the moment.\n\t *\n\t * This is a simplification to avoid constant checks if the\n\t * adapter is ready to do anything.\n\t */\n\tadapter_list = g_list_remove(adapter_list, adapter);\n\n\tbtd_adapter_unref(adapter);\n}\n\nstatic void reset_adv_monitors_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_rp_remove_adv_monitor *rp = param;\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\terror(\"Failed to reset Adv Monitors: %s (0x%02x)\",\n\t\t\tmgmt_errstr(status), status);\n\t\treturn;\n\t}\n\n\tif (length < sizeof(*rp)) {\n\t\terror(\"Wrong size of remove Adv Monitor response for reset \"\n\t\t\t\"all Adv Monitors\");\n\t\treturn;\n\t}\n\n\tDBG(\"Removed all Adv Monitors\");\n}\n\nstatic void reset_adv_monitors(uint16_t index)\n{\n\tstruct mgmt_cp_remove_adv_monitor cp;\n\n\tDBG(\"sending remove Adv Monitor command with handle 0\");\n\n\t/* Handle 0 indicates to remove all */\n\tcp.monitor_handle = 0;\n\tif (mgmt_send(mgmt_master, MGMT_OP_REMOVE_ADV_MONITOR, index,\n\t\t\tsizeof(cp), &cp, reset_adv_monitors_complete, NULL,\n\t\t\tNULL) > 0) {\n\t\treturn;\n\t}\n\n\terror(\"Failed to reset Adv Monitors\");\n}\n\nstatic void index_added(uint16_t index, uint16_t length, const void *param,\n\t\t\t\t\t\t\tvoid *user_data)\n{\n\tstruct btd_adapter *adapter;\n\n\tDBG(\"index %u\", index);\n\n\tadapter = btd_adapter_lookup(index);\n\tif (adapter) {\n\t\tbtd_warn(adapter->dev_id,\n\t\t\t\"Ignoring index added for an already existing adapter\");\n\t\treturn;\n\t}\n\n\treset_adv_monitors(index);\n\n\tadapter = btd_adapter_new(index);\n\tif (!adapter) {\n\t\tbtd_error(index,\n\t\t\t\"Unable to create new adapter for index %u\", index);\n\t\treturn;\n\t}\n\n\tif (btd_has_kernel_features(KERNEL_EXP_FEATURES))\n\t\tread_exp_features(adapter);\n\n\t/*\n\t * Protect against potential two executions of read controller info.\n\t *\n\t * In case the start of the daemon and the action of adding a new\n\t * controller coincide this function might be called twice.\n\t *\n\t * To avoid the double execution of reading the controller info,\n\t * add the adapter already to the list. If an adapter is already\n\t * present, the second notification will cause a warning. If the\n\t * command fails the adapter is removed from the list again.\n\t */\n\tadapter_list = g_list_append(adapter_list, adapter);\n\n\tDBG(\"sending read info command for index %u\", index);\n\n\tif (mgmt_send(mgmt_master, MGMT_OP_READ_INFO, index, 0, NULL,\n\t\t\t\t\tread_info_complete, adapter, NULL) > 0)\n\t\treturn;\n\n\tbtd_error(adapter->dev_id,\n\t\t\t\"Failed to read controller info for index %u\", index);\n\n\tadapter_list = g_list_remove(adapter_list, adapter);\n\n\tbtd_adapter_unref(adapter);\n}\n\nstatic void index_removed(uint16_t index, uint16_t length, const void *param,\n\t\t\t\t\t\t\tvoid *user_data)\n{\n\tstruct btd_adapter *adapter;\n\n\tDBG(\"index %u\", index);\n\n\tadapter = btd_adapter_lookup(index);\n\tif (!adapter) {\n\t\twarn(\"Ignoring index removal for a non-existent adapter\");\n\t\treturn;\n\t}\n\n\tadapter_unregister(adapter);\n}\n\nstatic void read_index_list_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_rp_read_index_list *rp = param;\n\tuint16_t num;\n\tint i;\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\terror(\"Failed to read index list: %s (0x%02x)\",\n\t\t\t\t\t\tmgmt_errstr(status), status);\n\t\treturn;\n\t}\n\n\tif (length < sizeof(*rp)) {\n\t\terror(\"Wrong size of read index list response\");\n\t\treturn;\n\t}\n\n\tnum = btohs(rp->num_controllers);\n\n\tDBG(\"Number of controllers: %d\", num);\n\n\tif (num * sizeof(uint16_t) + sizeof(*rp) != length) {\n\t\terror(\"Incorrect packet size for index list response\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < num; i++) {\n\t\tuint16_t index;\n\n\t\tindex = btohs(rp->index[i]);\n\n\t\tDBG(\"Found index %u\", index);\n\n\t\t/*\n\t\t * Pretend to be index added event notification.\n\t\t *\n\t\t * It is safe to just trigger the procedure for index\n\t\t * added notification. It does check against itself.\n\t\t */\n\t\tindex_added(index, 0, NULL, NULL);\n\t}\n}\n\nstatic void read_commands_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_rp_read_commands *rp = param;\n\tuint16_t num_commands, num_events;\n\tsize_t expected_len;\n\tint i;\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\terror(\"Failed to read supported commands: %s (0x%02x)\",\n\t\t\t\t\t\tmgmt_errstr(status), status);\n\t\treturn;\n\t}\n\n\tif (length < sizeof(*rp)) {\n\t\terror(\"Wrong size of read commands response\");\n\t\treturn;\n\t}\n\n\tnum_commands = btohs(rp->num_commands);\n\tnum_events = btohs(rp->num_events);\n\n\tDBG(\"Number of commands: %d\", num_commands);\n\tDBG(\"Number of events: %d\", num_events);\n\n\texpected_len = sizeof(*rp) + num_commands * sizeof(uint16_t) +\n\t\t\t\t\t\tnum_events * sizeof(uint16_t);\n\n\tif (length < expected_len) {\n\t\terror(\"Too small reply for supported commands: (%u != %zu)\",\n\t\t\t\t\t\t\tlength, expected_len);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < num_commands; i++) {\n\t\tuint16_t op = get_le16(rp->opcodes + i);\n\n\t\tswitch (op) {\n\t\tcase MGMT_OP_ADD_DEVICE:\n\t\t\tDBG(\"enabling kernel-side connection control\");\n\t\t\tkernel_features |= KERNEL_CONN_CONTROL;\n\t\t\tbreak;\n\t\tcase MGMT_OP_SET_BLOCKED_KEYS:\n\t\t\tDBG(\"kernel supports the set_blocked_keys op\");\n\t\t\tkernel_features |= KERNEL_BLOCKED_KEYS_SUPPORTED;\n\t\t\tbreak;\n\t\tcase MGMT_OP_SET_DEF_SYSTEM_CONFIG:\n\t\t\tDBG(\"kernel supports set system confic\");\n\t\t\tkernel_features |= KERNEL_SET_SYSTEM_CONFIG;\n\t\t\tbreak;\n\t\tcase MGMT_OP_READ_EXP_FEATURES_INFO:\n\t\t\tDBG(\"kernel supports exp features\");\n\t\t\tkernel_features |= KERNEL_EXP_FEATURES;\n\t\t\tbreak;\n\t\tcase MGMT_OP_ADD_EXT_ADV_PARAMS:\n\t\t\tDBG(\"kernel supports ext adv commands\");\n\t\t\tkernel_features |= KERNEL_HAS_EXT_ADV_ADD_CMDS;\n\t\t\tbreak;\n\t\tcase MGMT_OP_READ_CONTROLLER_CAP:\n\t\t\tDBG(\"kernel supports controller cap command\");\n\t\t\tkernel_features |= KERNEL_HAS_CONTROLLER_CAP_CMD;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (i = 0; i < num_events; i++) {\n\t\tuint16_t ev = get_le16(rp->opcodes + num_commands + i);\n\n\t\tswitch(ev) {\n\t\tcase MGMT_EV_CONTROLLER_RESUME:\n\t\t\tDBG(\"kernel supports suspend/resume events\");\n\t\t\tkernel_features |= KERNEL_HAS_RESUME_EVT;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void read_version_complete(uint8_t status, uint16_t length,\n\t\t\t\t\tconst void *param, void *user_data)\n{\n\tconst struct mgmt_rp_read_version *rp = param;\n\n\tif (status != MGMT_STATUS_SUCCESS) {\n\t\terror(\"Failed to read version information: %s (0x%02x)\",\n\t\t\t\t\t\tmgmt_errstr(status), status);\n\t\treturn;\n\t}\n\n\tif (length < sizeof(*rp)) {\n\t\terror(\"Wrong size of read version response\");\n\t\treturn;\n\t}\n\n\tmgmt_version = rp->version;\n\tmgmt_revision = btohs(rp->revision);\n\n\tinfo(\"Bluetooth management interface %u.%u initialized\",\n\t\t\t\t\t\tmgmt_version, mgmt_revision);\n\n\tif (mgmt_version < 1) {\n\t\terror(\"Version 1.0 or later of management interface required\");\n\t\tabort();\n\t}\n\n\tDBG(\"sending read supported commands command\");\n\n\t/*\n\t * It is irrelevant if this command succeeds or fails. In case of\n\t * failure safe settings are assumed.\n\t */\n\tmgmt_send(mgmt_master, MGMT_OP_READ_COMMANDS,\n\t\t\t\tMGMT_INDEX_NONE, 0, NULL,\n\t\t\t\tread_commands_complete, NULL, NULL);\n\n\tmgmt_register(mgmt_master, MGMT_EV_INDEX_ADDED, MGMT_INDEX_NONE,\n\t\t\t\t\t\tindex_added, NULL, NULL);\n\tmgmt_register(mgmt_master, MGMT_EV_INDEX_REMOVED, MGMT_INDEX_NONE,\n\t\t\t\t\t\tindex_removed, NULL, NULL);\n\n\tDBG(\"sending read index list command\");\n\n\tif (mgmt_send(mgmt_master, MGMT_OP_READ_INDEX_LIST,\n\t\t\t\tMGMT_INDEX_NONE, 0, NULL,\n\t\t\t\tread_index_list_complete, NULL, NULL) > 0)\n\t\treturn;\n\n\terror(\"Failed to read controller index list\");\n}\n\nstatic void mgmt_debug(const char *str, void *user_data)\n{\n\tconst char *prefix = user_data;\n\n\tinfo(\"%s%s\", prefix, str);\n}\n\nint adapter_init(void)\n{\n\tdbus_conn = btd_get_dbus_connection();\n\n\tmgmt_master = mgmt_new_default();\n\tif (!mgmt_master) {\n\t\terror(\"Failed to access management interface\");\n\t\treturn -EIO;\n\t}\n\n\tif (getenv(\"MGMT_DEBUG\"))\n\t\tmgmt_set_debug(mgmt_master, mgmt_debug, \"mgmt: \", NULL);\n\n\tDBG(\"sending read version command\");\n\n\tif (mgmt_send(mgmt_master, MGMT_OP_READ_VERSION,\n\t\t\t\tMGMT_INDEX_NONE, 0, NULL,\n\t\t\t\tread_version_complete, NULL, NULL) > 0)\n\t\treturn 0;\n\n\terror(\"Failed to read management version information\");\n\n\treturn -EIO;\n}\n\nvoid adapter_cleanup(void)\n{\n\tg_list_free(adapter_list);\n\n\twhile (adapters) {\n\t\tstruct btd_adapter *adapter = adapters->data;\n\n\t\tadapter_remove(adapter);\n\t\tadapters = g_slist_remove(adapters, adapter);\n\t\tbtd_adapter_unref(adapter);\n\t}\n\n\t/*\n\t * In case there is another reference active, clear out\n\t * registered handlers for index added and index removed.\n\t *\n\t * This is just an extra precaution to be safe, and in\n\t * reality should not make a difference.\n\t */\n\tmgmt_unregister_index(mgmt_master, MGMT_INDEX_NONE);\n\n\t/*\n\t * In case there is another reference active, cancel\n\t * all pending global commands.\n\t *\n\t * This is just an extra precaution to avoid callbacks\n\t * that potentially then could leak memory or access\n\t * an invalid structure.\n\t */\n\tmgmt_cancel_index(mgmt_master, MGMT_INDEX_NONE);\n\n\tmgmt_unref(mgmt_master);\n\tmgmt_master = NULL;\n\n\tdbus_conn = NULL;\n}\n\nvoid adapter_shutdown(void)\n{\n\tGList *list;\n\n\tDBG(\"\");\n\n\tpowering_down = true;\n\n\tfor (list = g_list_first(adapter_list); list;\n\t\t\t\t\t\tlist = g_list_next(list)) {\n\t\tstruct btd_adapter *adapter = list->data;\n\n\t\tif (!(adapter->current_settings & MGMT_SETTING_POWERED))\n\t\t\tcontinue;\n\n\t\tclear_discoverable(adapter);\n\t\tremove_temporary_devices(adapter);\n\t\tset_mode(adapter, MGMT_OP_SET_POWERED, 0x00);\n\n\t\tadapter_remaining++;\n\t}\n\n\tif (!adapter_remaining)\n\t\tbtd_exit();\n}\n\n/*\n * Check if workaround for broken ATT server socket behavior is needed\n * where we need to connect an ATT client socket before pairing to get\n * early access to the ATT channel.\n */\nbool btd_le_connect_before_pairing(void)\n{\n\tif (MGMT_VERSION(mgmt_version, mgmt_revision) < MGMT_VERSION(1, 4))\n\t\treturn true;\n\n\treturn false;\n}\n\nbool btd_has_kernel_features(uint32_t features)\n{\n\treturn (kernel_features & features) ? true : false;\n}\n"], "filenames": ["src/adapter.c"], "buggy_code_start_loc": [563], "buggy_code_end_loc": [6915], "fixing_code_start_loc": [563], "fixing_code_end_loc": [6925], "type": "CWE-863", "message": "bluetoothd from bluez incorrectly saves adapters' Discoverable status when a device is powered down, and restores it when powered up. If a device is powered down while discoverable, it will be discoverable when powered on again. This could lead to inadvertent exposure of the bluetooth stack to physically nearby attackers.", "other": {"cve": {"id": "CVE-2021-3658", "sourceIdentifier": "secalert@redhat.com", "published": "2022-03-02T23:15:08.787", "lastModified": "2022-06-03T16:22:03.880", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "bluetoothd from bluez incorrectly saves adapters' Discoverable status when a device is powered down, and restores it when powered up. If a device is powered down while discoverable, it will be discoverable when powered on again. This could lead to inadvertent exposure of the bluetooth stack to physically nearby attackers."}, {"lang": "es", "value": "bluetoothd de bluez guarda incorrectamente el estado Discoverable de los adaptadores cuando es apagado un dispositivo, y lo restaura cuando es encendido. Si un dispositivo es apagado mientras es detectado, ser\u00e1 detectado cuando es encendido de nuevo. Esto podr\u00eda conllevar a una exposici\u00f3n inadvertida de la pila bluetooth a atacantes f\u00edsicamente cercanos"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:A/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.3}, "baseSeverity": "LOW", "exploitabilityScore": 6.5, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-863"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bluez:bluez:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.61", "matchCriteriaId": "CB308421-876D-46FA-8DC3-A1EFA7AE3604"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1984728", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://git.kernel.org/pub/scm/bluetooth/bluez.git/commit/?id=b497b5942a8beb8f89ca1c359c54ad67ec843055", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/bluez/bluez/commit/b497b5942a8beb8f89ca1c359c54ad67ec843055", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://gitlab.gnome.org/GNOME/gnome-bluetooth/-/issues/89", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20220407-0002/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/bluez/bluez/commit/b497b5942a8beb8f89ca1c359c54ad67ec843055"}}