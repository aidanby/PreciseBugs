{"buggy_code": ["/* FriBidi\n * fribidi-char-sets-cap-rtl.c - CapRTL character set conversion routines\n *\n * Authors:\n *   Behdad Esfahbod, 2001, 2002, 2004\n *   Dov Grobgeld, 1999, 2000\n *\n * Copyright (C) 2004 Sharif FarsiWeb, Inc\n * Copyright (C) 2001,2002 Behdad Esfahbod\n * Copyright (C) 1999,2000 Dov Grobgeld\n * \n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n * \n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this library, in a file named COPYING; if not, write to the\n * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n * Boston, MA 02110-1301, USA\n * \n * For licensing issues, contact <fribidi.license@gmail.com>.\n */\n\n#include <common.h>\n\n#include <fribidi-char-sets-cap-rtl.h>\n\n#include <fribidi-unicode.h>\n#include <fribidi-mirroring.h>\n#include <fribidi-bidi-types.h>\n\n#include <bidi-types.h>\n\n#include <stdio.h>\n\nenum\n{\n# define _FRIBIDI_ADD_TYPE(TYPE,SYMBOL) TYPE = FRIBIDI_TYPE_##TYPE,\n# include \"fribidi-bidi-types-list.h\"\n# undef _FRIBIDI_ADD_TYPE\n  _FRIBIDI_MAX_TYPES_VALUE\n};\n\nenum\n{\n# define _FRIBIDI_ADD_TYPE(TYPE,SYMBOL) DUMMY_##TYPE,\n# include \"fribidi-bidi-types-list.h\"\n# undef _FRIBIDI_ADD_TYPE\n  _FRIBIDI_NUM_TYPES\n};\n\nstatic FriBidiCharType CapRTLCharTypes[] = {\n/* *INDENT-OFF* */\n  ON, ON, ON, ON, LTR,RTL,ON, ON, ON, ON, ON, ON, ON, BS, RLO,RLE, /* 00-0f */\n  LRO,LRE,PDF,WS, LRI, RLI, FSI, PDI, ON, ON, ON, ON, ON, ON, ON, ON,  /* 10-1f */\n  WS, ON, ON, ON, ET, ON, ON, ON, ON, ON, ON, ET, CS, ON, ES, ES,  /* 20-2f */\n  EN, EN, EN, EN, EN, EN, AN, AN, AN, AN, CS, ON, ON, ON, ON, ON,  /* 30-3f */\n  RTL,AL, AL, AL, AL, AL, AL, RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL, /* 40-4f */\n  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,ON, BS, ON, BN, ON,  /* 50-5f */\n  NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, /* 60-6f */\n  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,ON, SS, ON, WS, ON,  /* 70-7f */\n/* *INDENT-ON* */\n};\n\n#define CAPRTL_CHARS (int)(sizeof CapRTLCharTypes / sizeof CapRTLCharTypes[0])\n\nstatic FriBidiChar *caprtl_to_unicode = NULL;\n\nstatic void\ninit_cap_rtl (\n  void\n)\n{\n  int request[_FRIBIDI_NUM_TYPES];\n  FriBidiCharType to_type[_FRIBIDI_NUM_TYPES];\n  int num_types = 0, count = 0;\n  FriBidiCharType i;\n  char mark[CAPRTL_CHARS];\n\n  caprtl_to_unicode =\n    (FriBidiChar *) fribidi_malloc (CAPRTL_CHARS *\n\t\t\t\t    sizeof caprtl_to_unicode[0]);\n  for (i = 0; i < CAPRTL_CHARS; i++)\n    if (CapRTLCharTypes[i] == fribidi_get_bidi_type (i))\n      {\n\tcaprtl_to_unicode[i] = i;\n\tmark[i] = 1;\n      }\n    else\n      {\n\tint j;\n\n\tcaprtl_to_unicode[i] = FRIBIDI_UNICODE_CHARS;\n\tmark[i] = 0;\n\tif (fribidi_get_mirror_char (i, NULL))\n\t  {\n\t    DBG (\"warning: I could not map mirroring character map to itself in CapRTL\");\n\t  }\n\n\tfor (j = 0; j < num_types; j++)\n\t  if (to_type[j] == CapRTLCharTypes[i])\n\t    break;\n\tif (j == num_types)\n\t  {\n\t    num_types++;\n\t    to_type[j] = CapRTLCharTypes[i];\n\t    request[j] = 0;\n\t  }\n\trequest[j]++;\n\tcount++;\n      }\n  for (i = 0; i < 0x10000 && count; i++)\t/* Assign BMP chars to CapRTL entries */\n    if (!fribidi_get_mirror_char (i, NULL) && !(i < CAPRTL_CHARS && mark[i]))\n      {\n\tint j, k;\n\tFriBidiCharType t = fribidi_get_bidi_type (i);\n\tfor (j = 0; j < num_types; j++)\n\t  if (to_type[j] == t)\n\t    break;\n\tif (j >= num_types || !request[j])\t/* Do not need this type */\n\t  continue;\n\tfor (k = 0; k < CAPRTL_CHARS; k++)\n\t  if (caprtl_to_unicode[k] == FRIBIDI_UNICODE_CHARS\n\t      && to_type[j] == CapRTLCharTypes[k])\n\t    {\n\t      request[j]--;\n\t      count--;\n\t      caprtl_to_unicode[k] = i;\n\t      break;\n\t    }\n      }\n  if (count)\n    {\n      int j;\n\n      DBG (\"warning: could not find a mapping for CapRTL to Unicode:\");\n      for (j = 0; j < num_types; j++)\n\tif (request[j])\n\t  {\n\t    DBG2 (\"  need this type: %s\", fribidi_get_bidi_type_name (to_type[j]));\n\t  }\n    }\n}\n\nstatic char\nfribidi_unicode_to_cap_rtl_c (\n  /* input */\n  FriBidiChar uch\n)\n{\n  int i;\n\n  if (!caprtl_to_unicode)\n    init_cap_rtl ();\n\n  for (i = 0; i < CAPRTL_CHARS; i++)\n    if (uch == caprtl_to_unicode[i])\n      return (unsigned char) i;\n  return '?';\n}\n\nFriBidiStrIndex\nfribidi_cap_rtl_to_unicode (\n  /* input */\n  const char *s,\n  FriBidiStrIndex len,\n  /* output */\n  FriBidiChar *us\n)\n{\n  FriBidiStrIndex i, j;\n\n  if (!caprtl_to_unicode)\n    init_cap_rtl ();\n\n  j = 0;\n  for (i = 0; i < len; i++)\n    {\n      char ch;\n\n      ch = s[i];\n      if (ch == '_')\n\t{\n\t  switch (ch = s[++i])\n\t    {\n\t    case '>':\n\t      us[j++] = FRIBIDI_CHAR_LRM;\n\t      break;\n\t    case '<':\n\t      us[j++] = FRIBIDI_CHAR_RLM;\n\t      break;\n\t    case 'l':\n\t      us[j++] = FRIBIDI_CHAR_LRE;\n\t      break;\n\t    case 'r':\n\t      us[j++] = FRIBIDI_CHAR_RLE;\n\t      break;\n\t    case 'o':\n\t      us[j++] = FRIBIDI_CHAR_PDF;\n\t      break;\n\t    case 'L':\n\t      us[j++] = FRIBIDI_CHAR_LRO;\n\t      break;\n\t    case 'R':\n\t      us[j++] = FRIBIDI_CHAR_RLO;\n\t      break;\n            case 'i':\n              us[j++] = FRIBIDI_CHAR_LRI;\n\t      break;\n            case 'y':\n              us[j++] = FRIBIDI_CHAR_RLI;\n\t      break;\n            case 'f':\n              us[j++] = FRIBIDI_CHAR_FSI;\n\t      break;\n            case 'I':\n              us[j++] = FRIBIDI_CHAR_PDI;\n\t      break;\n\t    case '_':\n\t      us[j++] = '_';\n\t      break;\n\t    default:\n\t      us[j++] = '_';\n\t      i--;\n\t      break;\n\t    }\n\t}\n      else\n\tus[j++] = caprtl_to_unicode[(int) s[i]];\n    }\n\n  return j;\n}\n\nFriBidiStrIndex\nfribidi_unicode_to_cap_rtl (\n  /* input */\n  const FriBidiChar *us,\n  FriBidiStrIndex len,\n  /* output */\n  char *s\n)\n{\n  FriBidiStrIndex i;\n  int j;\n\n  j = 0;\n  for (i = 0; i < len; i++)\n    {\n      FriBidiChar ch = us[i];\n      if (!FRIBIDI_IS_EXPLICIT (fribidi_get_bidi_type (ch))\n          && !FRIBIDI_IS_ISOLATE (fribidi_get_bidi_type (ch))\n          && ch != '_' && ch != FRIBIDI_CHAR_LRM && ch != FRIBIDI_CHAR_RLM)\n\ts[j++] = fribidi_unicode_to_cap_rtl_c (ch);\n      else\n\t{\n\t  s[j++] = '_';\n\t  switch (ch)\n\t    {\n\t    case FRIBIDI_CHAR_LRM:\n\t      s[j++] = '>';\n\t      break;\n\t    case FRIBIDI_CHAR_RLM:\n\t      s[j++] = '<';\n\t      break;\n\t    case FRIBIDI_CHAR_LRE:\n\t      s[j++] = 'l';\n\t      break;\n\t    case FRIBIDI_CHAR_RLE:\n\t      s[j++] = 'r';\n\t      break;\n\t    case FRIBIDI_CHAR_PDF:\n\t      s[j++] = 'o';\n\t      break;\n\t    case FRIBIDI_CHAR_LRO:\n\t      s[j++] = 'L';\n\t      break;\n\t    case FRIBIDI_CHAR_RLO:\n\t      s[j++] = 'R';\n\t      break;\n\t    case FRIBIDI_CHAR_LRI:\n\t      s[j++] = 'i';\n\t      break;\n\t    case FRIBIDI_CHAR_RLI:\n\t      s[j++] = 'y';\n\t      break;\n\t    case FRIBIDI_CHAR_FSI:\n\t      s[j++] = 'f';\n\t      break;\n\t    case FRIBIDI_CHAR_PDI:\n\t      s[j++] = 'I';\n\t      break;\n\t    case '_':\n\t      s[j++] = '_';\n\t      break;\n\t    default:\n\t      j--;\n\t      if (ch < 256)\n\t\ts[j++] = fribidi_unicode_to_cap_rtl_c (ch);\n\t      else\n\t\ts[j++] = '?';\n\t      break;\n\t    }\n\t}\n    }\n  s[j] = 0;\n\n  return j;\n}\n\nconst char *\nfribidi_char_set_desc_cap_rtl (\n  void\n)\n{\n  static char *s = 0;\n  int l, i, j;\n\n  if (s)\n    return s;\n\n  l = 10000;\n  s = (char *) fribidi_malloc (l);\n  i = 0;\n  i += sprintf (s + i,\t\t/*l - i, */\n\t\t\"CapRTL is a character set for testing with the reference\\n\"\n\t\t\"implementation, with explicit marks escape strings, and\\n\"\n\t\t\"the property that contains all unicode character types in\\n\"\n\t\t\"ASCII range 1-127.\\n\"\n\t\t\"\\n\"\n\t\t\"Warning: CapRTL character types are subject to change.\\n\"\n\t\t\"\\n\" \"CapRTL's character types:\\n\");\n  for (j = 0; j < CAPRTL_CHARS; j++)\n    {\n      if (j % 4 == 0)\n\ts[i++] = '\\n';\n      i += sprintf (s + i, /*l - i, */ \"  * 0x%02x %c%c %-3s \", j,\n\t\t    j < 0x20 ? '^' : ' ',\n\t\t    j < 0x20 ? j + '@' : j < 0x7f ? j : ' ',\n\t\t    fribidi_get_bidi_type_name (CapRTLCharTypes[j]));\n    }\n  i += sprintf (s + i,\t\t/*l - i, */\n\t\t\"\\n\\n\"\n\t\t\"Escape sequences:\\n\"\n\t\t\"  Character `_' is used to escape explicit marks. The list is:\\n\"\n\t\t\"    * _>  LRM\\n\" \"    * _<  RLM\\n\"\n\t\t\"    * _l  LRE\\n\" \"    * _r  RLE\\n\"\n\t\t\"    * _L  LRO\\n\" \"    * _R  RLO\\n\"\n\t\t\"    * _o  PDF\\n\" \"    * _i  LRI\\n\"\n\t\t\"    * _y  RLI\\n\" \"    * _f  FSI\\n\"\n\t\t\"    * _I  PDI\\n\" \"    * __  `_' itself\\n\"\n                \"\\n\");\n  return s;\n}\n\n/* Editor directions:\n * vim:textwidth=78:tabstop=8:shiftwidth=2:autoindent:cindent\n */\n"], "fixing_code": ["/* FriBidi\n * fribidi-char-sets-cap-rtl.c - CapRTL character set conversion routines\n *\n * Authors:\n *   Behdad Esfahbod, 2001, 2002, 2004\n *   Dov Grobgeld, 1999, 2000\n *\n * Copyright (C) 2004 Sharif FarsiWeb, Inc\n * Copyright (C) 2001,2002 Behdad Esfahbod\n * Copyright (C) 1999,2000 Dov Grobgeld\n * \n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n * \n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this library, in a file named COPYING; if not, write to the\n * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n * Boston, MA 02110-1301, USA\n * \n * For licensing issues, contact <fribidi.license@gmail.com>.\n */\n\n#include <common.h>\n\n#include <fribidi-char-sets-cap-rtl.h>\n\n#include <fribidi-unicode.h>\n#include <fribidi-mirroring.h>\n#include <fribidi-bidi-types.h>\n\n#include <bidi-types.h>\n\n#include <stdio.h>\n\nenum\n{\n# define _FRIBIDI_ADD_TYPE(TYPE,SYMBOL) TYPE = FRIBIDI_TYPE_##TYPE,\n# include \"fribidi-bidi-types-list.h\"\n# undef _FRIBIDI_ADD_TYPE\n  _FRIBIDI_MAX_TYPES_VALUE\n};\n\nenum\n{\n# define _FRIBIDI_ADD_TYPE(TYPE,SYMBOL) DUMMY_##TYPE,\n# include \"fribidi-bidi-types-list.h\"\n# undef _FRIBIDI_ADD_TYPE\n  _FRIBIDI_NUM_TYPES\n};\n\nstatic FriBidiCharType CapRTLCharTypes[] = {\n/* *INDENT-OFF* */\n  ON, ON, ON, ON, LTR,RTL,ON, ON, ON, ON, ON, ON, ON, BS, RLO,RLE, /* 00-0f */\n  LRO,LRE,PDF,WS, LRI, RLI, FSI, PDI, ON, ON, ON, ON, ON, ON, ON, ON,  /* 10-1f */\n  WS, ON, ON, ON, ET, ON, ON, ON, ON, ON, ON, ET, CS, ON, ES, ES,  /* 20-2f */\n  EN, EN, EN, EN, EN, EN, AN, AN, AN, AN, CS, ON, ON, ON, ON, ON,  /* 30-3f */\n  RTL,AL, AL, AL, AL, AL, AL, RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL, /* 40-4f */\n  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,ON, BS, ON, BN, ON,  /* 50-5f */\n  NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, /* 60-6f */\n  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,ON, SS, ON, WS, ON,  /* 70-7f */\n/* *INDENT-ON* */\n};\n\n#define CAPRTL_CHARS (int)(sizeof CapRTLCharTypes / sizeof CapRTLCharTypes[0])\n\nstatic FriBidiChar *caprtl_to_unicode = NULL;\n\nstatic void\ninit_cap_rtl (\n  void\n)\n{\n  int request[_FRIBIDI_NUM_TYPES];\n  FriBidiCharType to_type[_FRIBIDI_NUM_TYPES];\n  int num_types = 0, count = 0;\n  FriBidiCharType i;\n  char mark[CAPRTL_CHARS];\n\n  caprtl_to_unicode =\n    (FriBidiChar *) fribidi_malloc (CAPRTL_CHARS *\n\t\t\t\t    sizeof caprtl_to_unicode[0]);\n  for (i = 0; i < CAPRTL_CHARS; i++)\n    if (CapRTLCharTypes[i] == fribidi_get_bidi_type (i))\n      {\n\tcaprtl_to_unicode[i] = i;\n\tmark[i] = 1;\n      }\n    else\n      {\n\tint j;\n\n\tcaprtl_to_unicode[i] = FRIBIDI_UNICODE_CHARS;\n\tmark[i] = 0;\n\tif (fribidi_get_mirror_char (i, NULL))\n\t  {\n\t    DBG (\"warning: I could not map mirroring character map to itself in CapRTL\");\n\t  }\n\n\tfor (j = 0; j < num_types; j++)\n\t  if (to_type[j] == CapRTLCharTypes[i])\n\t    break;\n\tif (j == num_types)\n\t  {\n\t    num_types++;\n\t    to_type[j] = CapRTLCharTypes[i];\n\t    request[j] = 0;\n\t  }\n\trequest[j]++;\n\tcount++;\n      }\n  for (i = 0; i < 0x10000 && count; i++)\t/* Assign BMP chars to CapRTL entries */\n    if (!fribidi_get_mirror_char (i, NULL) && !(i < CAPRTL_CHARS && mark[i]))\n      {\n\tint j, k;\n\tFriBidiCharType t = fribidi_get_bidi_type (i);\n\tfor (j = 0; j < num_types; j++)\n\t  if (to_type[j] == t)\n\t    break;\n\tif (j >= num_types || !request[j])\t/* Do not need this type */\n\t  continue;\n\tfor (k = 0; k < CAPRTL_CHARS; k++)\n\t  if (caprtl_to_unicode[k] == FRIBIDI_UNICODE_CHARS\n\t      && to_type[j] == CapRTLCharTypes[k])\n\t    {\n\t      request[j]--;\n\t      count--;\n\t      caprtl_to_unicode[k] = i;\n\t      break;\n\t    }\n      }\n  if (count)\n    {\n      int j;\n\n      DBG (\"warning: could not find a mapping for CapRTL to Unicode:\");\n      for (j = 0; j < num_types; j++)\n\tif (request[j])\n\t  {\n\t    DBG2 (\"  need this type: %s\", fribidi_get_bidi_type_name (to_type[j]));\n\t  }\n    }\n}\n\nstatic char\nfribidi_unicode_to_cap_rtl_c (\n  /* input */\n  FriBidiChar uch\n)\n{\n  int i;\n\n  if (!caprtl_to_unicode)\n    init_cap_rtl ();\n\n  for (i = 0; i < CAPRTL_CHARS; i++)\n    if (uch == caprtl_to_unicode[i])\n      return (unsigned char) i;\n  return '?';\n}\n\nFriBidiStrIndex\nfribidi_cap_rtl_to_unicode (\n  /* input */\n  const char *s,\n  FriBidiStrIndex len,\n  /* output */\n  FriBidiChar *us\n)\n{\n  FriBidiStrIndex i, j;\n\n  if (!caprtl_to_unicode)\n    init_cap_rtl ();\n\n  j = 0;\n  for (i = 0; i < len; i++)\n    {\n      char ch;\n\n      ch = s[i];\n      if (ch == '_')\n\t{\n\t  switch (ch = s[++i])\n\t    {\n\t    case '>':\n\t      us[j++] = FRIBIDI_CHAR_LRM;\n\t      break;\n\t    case '<':\n\t      us[j++] = FRIBIDI_CHAR_RLM;\n\t      break;\n\t    case 'l':\n\t      us[j++] = FRIBIDI_CHAR_LRE;\n\t      break;\n\t    case 'r':\n\t      us[j++] = FRIBIDI_CHAR_RLE;\n\t      break;\n\t    case 'o':\n\t      us[j++] = FRIBIDI_CHAR_PDF;\n\t      break;\n\t    case 'L':\n\t      us[j++] = FRIBIDI_CHAR_LRO;\n\t      break;\n\t    case 'R':\n\t      us[j++] = FRIBIDI_CHAR_RLO;\n\t      break;\n            case 'i':\n              us[j++] = FRIBIDI_CHAR_LRI;\n\t      break;\n            case 'y':\n              us[j++] = FRIBIDI_CHAR_RLI;\n\t      break;\n            case 'f':\n              us[j++] = FRIBIDI_CHAR_FSI;\n\t      break;\n            case 'I':\n              us[j++] = FRIBIDI_CHAR_PDI;\n\t      break;\n\t    case '_':\n\t      us[j++] = '_';\n\t      break;\n\t    default:\n\t      us[j++] = '_';\n\t      i--;\n\t      break;\n\t    }\n\t}\n      else\n      {\n        if ((int)s[i] < 0)\n          us[j++] = '?';\n        else\n          us[j++] = caprtl_to_unicode[(int) s[i]];\n      }\n    }\n\n  return j;\n}\n\nFriBidiStrIndex\nfribidi_unicode_to_cap_rtl (\n  /* input */\n  const FriBidiChar *us,\n  FriBidiStrIndex len,\n  /* output */\n  char *s\n)\n{\n  FriBidiStrIndex i;\n  int j;\n\n  j = 0;\n  for (i = 0; i < len; i++)\n    {\n      FriBidiChar ch = us[i];\n      if (!FRIBIDI_IS_EXPLICIT (fribidi_get_bidi_type (ch))\n          && !FRIBIDI_IS_ISOLATE (fribidi_get_bidi_type (ch))\n          && ch != '_' && ch != FRIBIDI_CHAR_LRM && ch != FRIBIDI_CHAR_RLM)\n\ts[j++] = fribidi_unicode_to_cap_rtl_c (ch);\n      else\n\t{\n\t  s[j++] = '_';\n\t  switch (ch)\n\t    {\n\t    case FRIBIDI_CHAR_LRM:\n\t      s[j++] = '>';\n\t      break;\n\t    case FRIBIDI_CHAR_RLM:\n\t      s[j++] = '<';\n\t      break;\n\t    case FRIBIDI_CHAR_LRE:\n\t      s[j++] = 'l';\n\t      break;\n\t    case FRIBIDI_CHAR_RLE:\n\t      s[j++] = 'r';\n\t      break;\n\t    case FRIBIDI_CHAR_PDF:\n\t      s[j++] = 'o';\n\t      break;\n\t    case FRIBIDI_CHAR_LRO:\n\t      s[j++] = 'L';\n\t      break;\n\t    case FRIBIDI_CHAR_RLO:\n\t      s[j++] = 'R';\n\t      break;\n\t    case FRIBIDI_CHAR_LRI:\n\t      s[j++] = 'i';\n\t      break;\n\t    case FRIBIDI_CHAR_RLI:\n\t      s[j++] = 'y';\n\t      break;\n\t    case FRIBIDI_CHAR_FSI:\n\t      s[j++] = 'f';\n\t      break;\n\t    case FRIBIDI_CHAR_PDI:\n\t      s[j++] = 'I';\n\t      break;\n\t    case '_':\n\t      s[j++] = '_';\n\t      break;\n\t    default:\n\t      j--;\n\t      if (ch < 256)\n\t\ts[j++] = fribidi_unicode_to_cap_rtl_c (ch);\n\t      else\n\t\ts[j++] = '?';\n\t      break;\n\t    }\n\t}\n    }\n  s[j] = 0;\n\n  return j;\n}\n\nconst char *\nfribidi_char_set_desc_cap_rtl (\n  void\n)\n{\n  static char *s = 0;\n  int l, i, j;\n\n  if (s)\n    return s;\n\n  l = 10000;\n  s = (char *) fribidi_malloc (l);\n  i = 0;\n  i += sprintf (s + i,\t\t/*l - i, */\n\t\t\"CapRTL is a character set for testing with the reference\\n\"\n\t\t\"implementation, with explicit marks escape strings, and\\n\"\n\t\t\"the property that contains all unicode character types in\\n\"\n\t\t\"ASCII range 1-127.\\n\"\n\t\t\"\\n\"\n\t\t\"Warning: CapRTL character types are subject to change.\\n\"\n\t\t\"\\n\" \"CapRTL's character types:\\n\");\n  for (j = 0; j < CAPRTL_CHARS; j++)\n    {\n      if (j % 4 == 0)\n\ts[i++] = '\\n';\n      i += sprintf (s + i, /*l - i, */ \"  * 0x%02x %c%c %-3s \", j,\n\t\t    j < 0x20 ? '^' : ' ',\n\t\t    j < 0x20 ? j + '@' : j < 0x7f ? j : ' ',\n\t\t    fribidi_get_bidi_type_name (CapRTLCharTypes[j]));\n    }\n  i += sprintf (s + i,\t\t/*l - i, */\n\t\t\"\\n\\n\"\n\t\t\"Escape sequences:\\n\"\n\t\t\"  Character `_' is used to escape explicit marks. The list is:\\n\"\n\t\t\"    * _>  LRM\\n\" \"    * _<  RLM\\n\"\n\t\t\"    * _l  LRE\\n\" \"    * _r  RLE\\n\"\n\t\t\"    * _L  LRO\\n\" \"    * _R  RLO\\n\"\n\t\t\"    * _o  PDF\\n\" \"    * _i  LRI\\n\"\n\t\t\"    * _y  RLI\\n\" \"    * _f  FSI\\n\"\n\t\t\"    * _I  PDI\\n\" \"    * __  `_' itself\\n\"\n                \"\\n\");\n  return s;\n}\n\n/* Editor directions:\n * vim:textwidth=78:tabstop=8:shiftwidth=2:autoindent:cindent\n */\n"], "filenames": ["lib/fribidi-char-sets-cap-rtl.c"], "buggy_code_start_loc": [235], "buggy_code_end_loc": [236], "fixing_code_start_loc": [235], "fixing_code_end_loc": [241], "type": "CWE-122", "message": "A heap-based buffer overflow flaw was found in the Fribidi package and affects the fribidi_cap_rtl_to_unicode() function of the fribidi-char-sets-cap-rtl.c file. This flaw allows an attacker to pass a specially crafted file to the Fribidi application with the '--caprtl' option, leading to a crash and causing a denial of service.", "other": {"cve": {"id": "CVE-2022-25309", "sourceIdentifier": "secalert@redhat.com", "published": "2022-09-06T18:15:11.493", "lastModified": "2023-02-12T22:15:25.363", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A heap-based buffer overflow flaw was found in the Fribidi package and affects the fribidi_cap_rtl_to_unicode() function of the fribidi-char-sets-cap-rtl.c file. This flaw allows an attacker to pass a specially crafted file to the Fribidi application with the '--caprtl' option, leading to a crash and causing a denial of service."}, {"lang": "es", "value": "Se ha encontrado un fallo de desbordamiento de b\u00fafer en la regi\u00f3n heap de la memoria en el paquete Fribidi y afecta a la funci\u00f3n fribidi_cap_rtl_to_unicode() del archivo fribidi-char-sets-cap-rtl.c. Este fallo permite a un atacante pasar un archivo especialmente dise\u00f1ado a la aplicaci\u00f3n Fribidi con la opci\u00f3n \"--caprtl\", conllevando a un bloqueo y causando una denegaci\u00f3n de servicio."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "secalert@redhat.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-122"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gnu:fribidi:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.12", "matchCriteriaId": "A9E50E4E-F644-4B2F-8972-60E055F52B68"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "7F6FB57C-2BC7-487C-96DD-132683AEB35D"}]}]}], "references": [{"url": "https://access.redhat.com/security/cve/CVE-2022-25309", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2047896", "source": "secalert@redhat.com", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/fribidi/fribidi/commit/f22593b82b5d1668d1997dbccd10a9c31ffea3b3", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/fribidi/fribidi/issues/182", "source": "secalert@redhat.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/fribidi/fribidi/commit/f22593b82b5d1668d1997dbccd10a9c31ffea3b3"}}