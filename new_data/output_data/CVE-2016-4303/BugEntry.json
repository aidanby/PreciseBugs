{"buggy_code": ["# iperf, Copyright (c) 2014, 2015, The Regents of the University of\n# California, through Lawrence Berkeley National Laboratory (subject\n# to receipt of any required approvals from the U.S. Dept. of\n# Energy).  All rights reserved.\n#\n# If you have questions about your rights to use or distribute this\n# software, please contact Berkeley Lab's Technology Transfer\n# Department at TTD@lbl.gov.\n#\n# NOTICE.  This software is owned by the U.S. Department of Energy.\n# As such, the U.S. Government has been granted for itself and others\n# acting on its behalf a paid-up, nonexclusive, irrevocable,\n# worldwide license in the Software to reproduce, prepare derivative\n# works, and perform publicly and display publicly.  Beginning five\n# (5) years after the date permission to assert copyright is obtained\n# from the U.S. Department of Energy, and subject to any subsequent\n# five (5) year renewals, the U.S. Government is granted for itself\n# and others acting on its behalf a paid-up, nonexclusive,\n# irrevocable, worldwide license in the Software to reproduce,\n# prepare derivative works, distribute copies to the public, perform\n# publicly and display publicly, and to permit others to do so.\n#\n# This code is distributed under a BSD style license, see the LICENSE\n# file for complete information.\n\n# Initialize the autoconf system for the specified tool, version and mailing list\nAC_INIT(iperf, 3.0.11, https://github.com/esnet/iperf, iperf, http://software.es.net/iperf/)\n\n# Specify where the auxiliary files created by configure should go. The config\n# directory is picked so that they don't clutter up more useful directories.\nAC_CONFIG_AUX_DIR(config)\n\n\n# Initialize the automake system\nAM_INIT_AUTOMAKE\n\nAM_MAINTAINER_MODE\nAM_CONFIG_HEADER(src/config.h)\n\nAC_CANONICAL_HOST\n\n# Checks for tools: c compiler, ranlib (used for creating static libraries),\n# symlinks and libtool\nAC_PROG_CC\nAC_PROG_RANLIB\nAC_PROG_LN_S\nAC_PROG_LIBTOOL\n\n\n# Sets a conditional makefile variable so that certain Makefile tasks will be\n# performed only on linux (currently, add -luuid to LD_FLAGS)\nAM_CONDITIONAL(LINUX, [case $host_os in linux*) true;; *) false;; esac]) \n\n# Add -Wall if we are using GCC.\nif test \"x$GCC\" = \"xyes\"; then\n  CFLAGS=\"$CFLAGS -Wall\"\nfi\n\n# Checks for header files.\nAC_HEADER_STDC\n\n# Check for systems which need -lsocket and -lnsl\n#AX_LIB_SOCKET_NSL\n\n# Solaris puts nanosleep in -lrt\nAC_SEARCH_LIBS(nanosleep, [rt], [], [\necho \"nanosleep() required for timing operations.\"\nexit 1\n])\n\n# Solaris puts hstrerror in -lresolv\nAC_SEARCH_LIBS(hstrerror, [resolv], [], [\necho \"nanosleep() required for timing operations.\"\nexit 1\n])\n\n# Checks for typedefs, structures, and compiler characteristics.\nAC_C_CONST\n\nAC_OUTPUT([Makefile src/Makefile src/version.h examples/Makefile iperf3.spec])\n", "/*\n  Copyright (c) 2009 Dave Gamble\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in\n  all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n  THE SOFTWARE.\n*/\n\n/* cJSON */\n/* JSON parser in C. */\n\n#include <string.h>\n#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include <stdint.h>  \n#include <sys/types.h>\n#include \"cjson.h\"\n\n#ifndef LLONG_MAX\n#define LLONG_MAX 9223372036854775807LL\n#endif\n#ifndef LLONG_MIN\n#define LLONG_MIN (-LLONG_MAX - 1LL)\n#endif\n\n\nstatic const char *ep;\n\nconst char *cJSON_GetErrorPtr( void )\n{\n\treturn ep;\n}\n\n\nstatic int cJSON_strcasecmp( const char *s1, const char *s2 )\n{\n\tif ( ! s1 )\n\t\treturn ( s1 == s2 ) ? 0 : 1;\n\tif ( ! s2 )\n\t\treturn 1;\n\tfor ( ; tolower(*s1) == tolower(*s2); ++s1, ++s2)\n\t\tif( *s1 == 0 )\n\t\t\treturn 0;\n\treturn tolower(*(const unsigned char *)s1) - tolower(*(const unsigned char *)s2);\n}\n\n\nstatic void *(*cJSON_malloc)( size_t ) = malloc;\nstatic void (*cJSON_free)( void * ) = free;\n\nvoid cJSON_InitHooks(cJSON_Hooks* hooks)\n{\n\tif ( ! hooks ) {\n\t\t/* Reset hooks. */\n\t\tcJSON_malloc = malloc;\n\t\tcJSON_free = free;\n\t\treturn;\n\t}\n\tcJSON_malloc = (hooks->malloc_fn) ? hooks->malloc_fn : malloc;\n\tcJSON_free = (hooks->free_fn) ? hooks->free_fn : free;\n}\n\n\nstatic char* cJSON_strdup( const char* str )\n{\n\tsize_t len;\n\tchar* copy;\n\n\tlen = strlen( str ) + 1;\n\tif ( ! ( copy = (char*) cJSON_malloc( len ) ) )\n\t\treturn 0;\n\tmemcpy( copy, str, len );\n\treturn copy;\n}\n\n\n/* Internal constructor. */\nstatic cJSON *cJSON_New_Item( void )\n{\n\tcJSON* node = (cJSON*) cJSON_malloc( sizeof(cJSON) );\n\tif ( node )\n\t\tmemset( node, 0, sizeof(cJSON) );\n\treturn node;\n}\n\n\n/* Delete a cJSON structure. */\nvoid cJSON_Delete( cJSON *c )\n{\n\tcJSON *next;\n\n\twhile ( c ) {\n\t\tnext = c->next;\n\t\tif ( ! ( c->type & cJSON_IsReference ) && c->child )\n\t\t\tcJSON_Delete( c->child );\n\t\tif ( ! ( c->type & cJSON_IsReference ) && c->valuestring )\n\t\t\tcJSON_free( c->valuestring );\n\t\tif ( c->string )\n\t\t\tcJSON_free( c->string );\n\t\tcJSON_free( c );\n\t\tc = next;\n\t}\n}\n\n\nstatic double ipow( double n, int exp )\n{\n\tdouble r;\n\n\tif ( exp < 0 )\n\t\treturn 1.0 / ipow( n, -exp );\n\tr = 1;\n\twhile ( exp > 0 ) {\n\t\tif ( exp & 1 )\n\t\t\tr *= n;\n\t\texp >>= 1;\n\t\tn *= n;\n\t}\n\treturn r;\n}\n\n\n/* Parse the input text to generate a number, and populate the result into item. */\nstatic const char *parse_number( cJSON *item, const char *num )\n{\n\tint64_t i = 0;\n\tdouble f = 0;\n\tint isint = 1;\n\tint sign = 1, scale = 0, subscale = 0, signsubscale = 1;\n\n\t/* Could use sscanf for this? */\n\tif ( *num == '-' ) {\n\t\t/* Has sign. */\n\t\tsign = -1;\n\t\t++num;\n\t}\n\tif ( *num == '0' )\n\t\t/* Is zero. */\n\t\t++num;\n\tif ( *num >= '1' && *num<='9' ) {\n\t\t/* Number. */\n\t\tdo {\n\t\t\ti = ( i * 10 ) + ( *num - '0' );\n\t\t\tf = ( f * 10.0 ) + ( *num - '0' );\n\t\t\t++num;\n\t\t} while ( *num >= '0' && *num <= '9' );\n\t}\n\tif ( *num == '.' && num[1] >= '0' && num[1] <= '9' ) {\n\t\t/* Fractional part. */\n\t\tisint = 0;\n\t\t++num;\n\t\tdo {\n\t\t\tf = ( f * 10.0 ) + ( *num++ - '0' );\n\t\t\tscale--;\n\t\t} while ( *num >= '0' && *num <= '9' );\n\t}\n\tif ( *num == 'e' || *num == 'E' ) {\n\t\t/* Exponent. */\n\t\tisint = 0;\n\t\t++num;\n\t\tif ( *num == '+' )\n\t\t\t++num;\n\t\telse if ( *num == '-' ) {\n\t\t\t/* With sign. */\n\t\t\tsignsubscale = -1;\n\t\t\t++num;\n\t\t}\n\t\twhile ( *num >= '0' && *num <= '9' )\n\t\t\tsubscale = ( subscale * 10 ) + ( *num++ - '0' );\n\t}\n\n\t/* Put it together. */\n\tif ( isint ) {\n\t\t/* Int: number = +/- number */\n\t\ti = sign * i;\n\t\titem->valueint = i;\n\t\titem->valuefloat = i;\n\t} else {\n\t\t/* Float: number = +/- number.fraction * 10^+/- exponent */\n\t\tf = sign * f * ipow( 10.0, scale + subscale * signsubscale );\n\t\titem->valueint = f;\n\t\titem->valuefloat = f;\n\t}\n\n\titem->type = cJSON_Number;\n\treturn num;\n}\n\n\n/* Render the number nicely from the given item into a string. */\nstatic char *print_number( cJSON *item )\n{\n\tchar *str;\n\tdouble f, f2;\n\tint64_t i;\n\n\tstr = (char*) cJSON_malloc( 64 );\n\tif ( str ) {\n\t\tf = item->valuefloat;\n\t\ti = f;\n\t\tf2 = i;\n\t\tif ( f2 == f && item->valueint >= LLONG_MIN && item->valueint <= LLONG_MAX )\n\t\t\tsprintf( str, \"%lld\", (long long) item->valueint );\n\t\telse\n\t\t\tsprintf( str, \"%g\", item->valuefloat );\n\t}\n\treturn str;\n}\n\n\n/* Parse the input text into an unescaped cstring, and populate item. */\nstatic const unsigned char firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };\n\nstatic const char *parse_string( cJSON *item, const char *str )\n{\n\tconst char *ptr = str + 1;\n\tchar *ptr2;\n\tchar *out;\n\tint len = 0;\n\tunsigned uc, uc2;\n\n\tif ( *str != '\\\"' ) {\n\t\t/* Not a string! */\n\t\tep = str;\n\t\treturn 0;\n\t}\n\t\n\t/* Skip escaped quotes. */\n\twhile ( *ptr != '\\\"' && *ptr && ++len )\n\t\tif ( *ptr++ == '\\\\' )\n\t\t\tptr++;\n\t\n\tif ( ! ( out = (char*) cJSON_malloc( len + 1 ) ) )\n\t\treturn 0;\n\t\n\tptr = str + 1;\n\tptr2 = out;\n\twhile ( *ptr != '\\\"' && *ptr ) {\n\t\tif ( *ptr != '\\\\' )\n\t\t\t*ptr2++ = *ptr++;\n\t\telse {\n\t\t\tptr++;\n\t\t\tswitch ( *ptr ) {\n\t\t\t\tcase 'b': *ptr2++ ='\\b'; break;\n\t\t\t\tcase 'f': *ptr2++ ='\\f'; break;\n\t\t\t\tcase 'n': *ptr2++ ='\\n'; break;\n\t\t\t\tcase 'r': *ptr2++ ='\\r'; break;\n\t\t\t\tcase 't': *ptr2++ ='\\t'; break;\n\t\t\t\tcase 'u':\n\t\t\t\t\t/* Transcode utf16 to utf8. */\n\t\t\t\t\t/* Get the unicode char. */\n\t\t\t\t\tsscanf( ptr + 1,\"%4x\", &uc );\n\t\t\t\t\tptr += 4;\n\t\t\t\t\t/* Check for invalid. */\n\t\t\t\t\tif ( ( uc >= 0xDC00 && uc <= 0xDFFF ) || uc == 0 )\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t/* UTF16 surrogate pairs. */\n\t\t\t\t\tif ( uc >= 0xD800 && uc <= 0xDBFF ) {\n\t\t\t\t\t\tif ( ptr[1] != '\\\\' || ptr[2] != 'u' )\n\t\t\t\t\t\t\t/* Missing second-half of surrogate. */\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tsscanf( ptr + 3, \"%4x\", &uc2 );\n\t\t\t\t\t\tptr += 6;\n\t\t\t\t\t\tif ( uc2 < 0xDC00 || uc2 > 0xDFFF )\n\t\t\t\t\t\t\t/* Invalid second-half of surrogate. */\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tuc = 0x10000 | ( ( uc & 0x3FF ) << 10 ) | ( uc2 & 0x3FF );\n\t\t\t\t\t}\n\n\t\t\t\t\tlen = 4;\n\t\t\t\t\tif ( uc < 0x80 )\n\t\t\t\t\t\tlen = 1;\n\t\t\t\t\telse if ( uc < 0x800 )\n\t\t\t\t\t\tlen = 2;\n\t\t\t\t\telse if ( uc < 0x10000 )\n\t\t\t\t\t\tlen = 3;\n\t\t\t\t\tptr2 += len;\n\t\t\t\t\t\n\t\t\t\t\tswitch ( len ) {\n\t\t\t\t\t\tcase 4: *--ptr2 = ( ( uc | 0x80) & 0xBF ); uc >>= 6;\n\t\t\t\t\t\tcase 3: *--ptr2 = ( ( uc | 0x80) & 0xBF ); uc >>= 6;\n\t\t\t\t\t\tcase 2: *--ptr2 = ( ( uc | 0x80) & 0xBF ); uc >>= 6;\n\t\t\t\t\t\tcase 1: *--ptr2 = ( uc | firstByteMark[len] );\n\t\t\t\t\t}\n\t\t\t\t\tptr2 += len;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:  *ptr2++ = *ptr; break;\n\t\t\t}\n\t\t\t++ptr;\n\t\t}\n\t}\n\t*ptr2 = 0;\n\tif ( *ptr == '\\\"' )\n\t\t++ptr;\n\titem->valuestring = out;\n\titem->type = cJSON_String;\n\treturn ptr;\n}\n\n\n/* Render the cstring provided to an escaped version that can be printed. */\nstatic char *print_string_ptr( const char *str )\n{\n\tconst char *ptr;\n\tchar *ptr2, *out;\n\tint len = 0;\n\tunsigned char token;\n\t\n\tif ( ! str )\n\t\treturn cJSON_strdup( \"\" );\n\tptr = str;\n\twhile ( ( token = *ptr ) && ++len ) {\n\t\tif ( strchr( \"\\\"\\\\\\b\\f\\n\\r\\t\", token ) )\n\t\t\t++len;\n\t\telse if ( token < 32 )\n\t\t\tlen += 5;\n\t\t++ptr;\n\t}\n\t\n\tif ( ! ( out = (char*) cJSON_malloc( len + 3 ) ) )\n\t\treturn 0;\n\n\tptr2 = out;\n\tptr = str;\n\t*ptr2++ = '\\\"';\n\twhile ( *ptr ) {\n\t\tif ( (unsigned char) *ptr > 31 && *ptr != '\\\"' && *ptr != '\\\\' )\n\t\t\t*ptr2++ = *ptr++;\n\t\telse {\n\t\t\t*ptr2++ = '\\\\';\n\t\t\tswitch ( token = *ptr++ ) {\n\t\t\t\tcase '\\\\': *ptr2++ = '\\\\'; break;\n\t\t\t\tcase '\\\"': *ptr2++ = '\\\"'; break;\n\t\t\t\tcase '\\b': *ptr2++ = 'b'; break;\n\t\t\t\tcase '\\f': *ptr2++ = 'f'; break;\n\t\t\t\tcase '\\n': *ptr2++ = 'n'; break;\n\t\t\t\tcase '\\r': *ptr2++ = 'r'; break;\n\t\t\t\tcase '\\t': *ptr2++ = 't'; break;\n\t\t\t\tdefault:\n\t\t\t\t/* Escape and print. */\n\t\t\t\tsprintf( ptr2, \"u%04x\", token );\n\t\t\t\tptr2 += 5;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t*ptr2++ = '\\\"';\n\t*ptr2++ = 0;\n\treturn out;\n}\n\n\n/* Invote print_string_ptr (which is useful) on an item. */\nstatic char *print_string( cJSON *item )\n{\n\treturn print_string_ptr( item->valuestring );\n}\n\n\n/* Predeclare these prototypes. */\nstatic const char *parse_value( cJSON *item, const char *value );\nstatic char *print_value( cJSON *item, int depth, int fmt );\nstatic const char *parse_array( cJSON *item, const char *value );\nstatic char *print_array( cJSON *item, int depth, int fmt );\nstatic const char *parse_object( cJSON *item, const char *value );\nstatic char *print_object( cJSON *item, int depth, int fmt );\n\n/* Utility to jump whitespace and cr/lf. */\nstatic const char *skip( const char *in )\n{\n\twhile ( in && *in && (unsigned char) *in <= 32 )\n\t\tin++;\n\treturn in;\n}\n\n\n/* Parse an object - create a new root, and populate. */\ncJSON *cJSON_Parse( const char *value )\n{\n\tcJSON *c;\n\tep = 0;\n\tif ( ! ( c = cJSON_New_Item() ) )\n\t\treturn 0;\t/* memory fail */\n\n\tif ( ! parse_value( c, skip( value ) ) ) {\n\t\tcJSON_Delete( c );\n\t\treturn 0;\n\t}\n\treturn c;\n}\n\n\n/* Render a cJSON item/entity/structure to text. */\nchar *cJSON_Print( cJSON *item )\n{\n\treturn print_value( item, 0, 1 );\n}\nchar *cJSON_PrintUnformatted( cJSON *item )\n{\n\treturn print_value( item, 0, 0 );\n}\n\n\n/* Parser core - when encountering text, process appropriately. */\nstatic const char *parse_value( cJSON *item, const char *value )\n{\n\tif ( ! value )\n\t\treturn 0;\t/* Fail on null. */\n\tif ( ! strncmp( value, \"null\", 4 ) ) {\n\t\titem->type = cJSON_NULL;\n\t\treturn value + 4;\n\t}\n\tif ( ! strncmp( value, \"false\", 5 ) ) {\n\t\titem->type = cJSON_False;\n\t\treturn value + 5;\n\t}\n\tif ( ! strncmp( value, \"true\", 4 ) ) {\n\t\titem->type = cJSON_True;\n\t\titem->valueint = 1;\n\t\treturn value + 4;\n\t}\n\tif ( *value == '\\\"' )\n\t\treturn parse_string( item, value );\n\tif ( *value == '-' || ( *value >= '0' && *value <= '9' ) )\n\t\treturn parse_number( item, value );\n\tif ( *value == '[' )\n\t\treturn parse_array( item, value );\n\tif ( *value == '{' )\n\t\treturn parse_object( item, value );\n\n\t/* Fail. */\n\tep = value;\n\treturn 0;\n}\n\n\n/* Render a value to text. */\nstatic char *print_value( cJSON *item, int depth, int fmt )\n{\n\tchar *out = 0;\n\n\tif ( ! item )\n\t\treturn 0;\n\tswitch ( ( item->type ) & 255 ) {\n\t\tcase cJSON_NULL:   out = cJSON_strdup( \"null\" ); break;\n\t\tcase cJSON_False:  out = cJSON_strdup( \"false\" ); break;\n\t\tcase cJSON_True:   out = cJSON_strdup( \"true\" ); break;\n\t\tcase cJSON_Number: out = print_number( item ); break;\n\t\tcase cJSON_String: out = print_string( item ); break;\n\t\tcase cJSON_Array:  out = print_array( item, depth, fmt ); break;\n\t\tcase cJSON_Object: out = print_object( item, depth, fmt ); break;\n\t}\n\treturn out;\n}\n\n\n/* Build an array from input text. */\nstatic const char *parse_array( cJSON *item, const char *value )\n{\n\tcJSON *child;\n\n\tif ( *value != '[' ) {\n\t\t/* Not an array! */\n\t\tep = value;\n\t\treturn 0;\n\t}\n\n\titem->type = cJSON_Array;\n\tvalue = skip( value + 1 );\n\tif ( *value == ']' )\n\t\treturn value + 1;\t/* empty array. */\n\n\tif ( ! ( item->child = child = cJSON_New_Item() ) )\n\t\treturn 0;\t\t /* memory fail */\n\tif ( ! ( value = skip( parse_value( child, skip( value ) ) ) ) )\n\t\treturn 0;\n\n\twhile ( *value == ',' ) {\n\t\tcJSON *new_item;\n\t\tif ( ! ( new_item = cJSON_New_Item() ) )\n\t\t\treturn 0;\t/* memory fail */\n\t\tchild->next = new_item;\n\t\tnew_item->prev = child;\n\t\tchild = new_item;\n\t\tif ( ! ( value = skip( parse_value( child, skip( value+1 ) ) ) ) )\n\t\t\treturn 0;\t/* memory fail */\n\t}\n\n\tif ( *value == ']' )\n\t\treturn value + 1;\t/* end of array */\n\t/* Malformed. */\n\tep = value;\n\treturn 0;\n}\n\n\n/* Render an array to text */\nstatic char *print_array( cJSON *item, int depth, int fmt )\n{\n\tchar **entries;\n\tchar *out = 0, *ptr, *ret;\n\tint len = 5;\n\tcJSON *child = item->child;\n\tint numentries = 0, i = 0, fail = 0;\n\t\n\t/* How many entries in the array? */\n\twhile ( child ) {\n\t\t++numentries;\n\t\tchild = child->next;\n\t}\n\t/* Allocate an array to hold the values for each. */\n\tif ( ! ( entries = (char**) cJSON_malloc( numentries * sizeof(char*) ) ) )\n\t\treturn 0;\n\tmemset( entries, 0, numentries * sizeof(char*) );\n\t/* Retrieve all the results. */\n\tchild = item->child;\n\twhile ( child && ! fail ) {\n\t\tret = print_value( child, depth + 1, fmt );\n\t\tentries[i++] = ret;\n\t\tif ( ret )\n\t\t\tlen += strlen( ret ) + 2 + ( fmt ? 1 : 0 );\n\t\telse\n\t\t\tfail = 1;\n\t\tchild = child -> next;\n\t}\n\t\n\t/* If we didn't fail, try to malloc the output string. */\n\tif ( ! fail ) {\n\t\tout = (char*) cJSON_malloc( len );\n\t\tif ( ! out )\n\t\t\tfail = 1;\n\t}\n\n\t/* Handle failure. */\n\tif ( fail ) {\n\t\tfor ( i = 0; i < numentries; ++i )\n\t\t\tif ( entries[i] )\n\t\t\t\tcJSON_free( entries[i] );\n\t\tcJSON_free( entries );\n\t\treturn 0;\n\t}\n\t\n\t/* Compose the output array. */\n\t*out = '[';\n\tptr = out + 1;\n\t*ptr = 0;\n\tfor ( i = 0; i < numentries; ++i ) {\n\t\tstrcpy( ptr, entries[i] );\n\t\tptr += strlen( entries[i] );\n\t\tif ( i != numentries - 1 ) {\n\t\t\t*ptr++ = ',';\n\t\t\tif ( fmt )\n\t\t\t\t*ptr++ = ' ';\n\t\t\t*ptr = 0;\n\t\t}\n\t\tcJSON_free( entries[i] );\n\t}\n\tcJSON_free( entries );\n\t*ptr++ = ']';\n\t*ptr++ = 0;\n\treturn out;\t\n}\n\n\n/* Build an object from the text. */\nstatic const char *parse_object( cJSON *item, const char *value )\n{\n\tcJSON *child;\n\n\tif ( *value != '{' ) {\n\t\t/* Not an object! */\n\t\tep = value;\n\t\treturn 0;\n\t}\n\t\n\titem->type = cJSON_Object;\n\tvalue =skip( value + 1 );\n\tif ( *value == '}' )\n\t\treturn value + 1;\t/* empty array. */\n\t\n\tif ( ! ( item->child = child = cJSON_New_Item() ) )\n\t\treturn 0;\n\tif ( ! ( value = skip( parse_string( child, skip( value ) ) ) ) )\n\t\treturn 0;\n\tchild->string = child->valuestring;\n\tchild->valuestring = 0;\n\tif ( *value != ':' ) {\n\t\t/* Fail! */\n\t\tep = value;\n\t\treturn 0;\n\t}\n\tif ( ! ( value = skip( parse_value( child, skip( value + 1 ) ) ) ) )\n\t\treturn 0;\n\t\n\twhile ( *value == ',' ) {\n\t\tcJSON *new_item;\n\t\tif ( ! ( new_item = cJSON_New_Item() ) )\n\t\t\treturn 0;\t/* memory fail */\n\t\tchild->next = new_item;\n\t\tnew_item->prev = child;\n\t\tchild = new_item;\n\t\tif ( ! ( value = skip( parse_string( child, skip( value + 1 ) ) ) ) )\n\t\t\treturn 0;\n\t\tchild->string = child->valuestring;\n\t\tchild->valuestring = 0;\n\t\tif ( *value != ':' ) {\n\t\t\t/* Fail! */\n\t\t\tep = value;\n\t\t\treturn 0;\n\t\t}\n\t\tif ( ! ( value = skip( parse_value( child, skip( value + 1 ) ) ) ) )\n\t\t\treturn 0;\n\t}\n\t\n\tif ( *value == '}' )\n\t\treturn value + 1;\t/* end of array */\n\t/* Malformed. */\n\tep = value;\n\treturn 0;\n}\n\n\n/* Render an object to text. */\nstatic char *print_object( cJSON *item, int depth, int fmt )\n{\n\tchar **entries = 0, **names = 0;\n\tchar *out = 0, *ptr, *ret, *str;\n\tint len = 7, i = 0, j;\n\tcJSON *child = item->child;\n\tint numentries = 0, fail = 0;\n\n\t/* Count the number of entries. */\n\twhile ( child ) {\n\t\t++numentries;\n\t\tchild = child->next;\n\t}\n\t/* Allocate space for the names and the objects. */\n\tif ( ! ( entries = (char**) cJSON_malloc( numentries * sizeof(char*) ) ) )\n\t\treturn 0;\n\tif ( ! ( names = (char**) cJSON_malloc( numentries * sizeof(char*) ) ) ) {\n\t\tcJSON_free( entries );\n\t\treturn 0;\n\t}\n\tmemset( entries, 0, sizeof(char*) * numentries );\n\tmemset( names, 0, sizeof(char*) * numentries );\n\n\t/* Collect all the results into our arrays. */\n\tchild = item->child;\n\t++depth;\n\tif ( fmt )\n\t\tlen += depth;\n\twhile ( child ) {\n\t\tnames[i] = str = print_string_ptr( child->string );\n\t\tentries[i++] = ret = print_value( child, depth, fmt );\n\t\tif ( str && ret )\n\t\t\tlen += strlen( ret ) + strlen( str ) + 2 + ( fmt ? 2 + depth : 0 );\n\t\telse\n\t\t\tfail = 1;\n\t\tchild = child->next;\n\t}\n\t\n\t/* Try to allocate the output string. */\n\tif ( ! fail ) {\n\t\tout = (char*) cJSON_malloc( len );\n\t\tif ( ! out )\n\t\t\tfail = 1;\n\t}\n\n\t/* Handle failure. */\n\tif ( fail ) {\n\t\tfor ( i = 0; i < numentries; ++i ) {\n\t\t\tif ( names[i] )\n\t\t\t\tcJSON_free( names[i] );\n\t\t\tif ( entries[i] )\n\t\t\t\tcJSON_free( entries[i] );\n\t\t}\n\t\tcJSON_free( names );\n\t\tcJSON_free( entries );\n\t\treturn 0;\n\t}\n\t\n\t/* Compose the output. */\n\t*out = '{';\n\tptr = out + 1;\n\tif ( fmt )\n\t\t*ptr++ = '\\n';\n\t*ptr = 0;\n\tfor ( i = 0; i < numentries; ++i ) {\n\t\tif ( fmt )\n\t\t\tfor ( j = 0; j < depth; ++j )\n\t\t\t\t*ptr++ = '\\t';\n\t\tstrcpy( ptr, names[i] );\n\t\tptr += strlen( names[i] );\n\t\t*ptr++ = ':';\n\t\tif ( fmt )\n\t\t\t*ptr++ = '\\t';\n\t\tstrcpy( ptr, entries[i] );\n\t\tptr += strlen( entries[i] );\n\t\tif ( i != numentries - 1 )\n\t\t\t*ptr++ = ',';\n\t\tif ( fmt )\n\t\t\t*ptr++ = '\\n';\n\t\t*ptr = 0;\n\t\tcJSON_free( names[i] );\n\t\tcJSON_free( entries[i] );\n\t}\n\t\n\tcJSON_free( names );\n\tcJSON_free( entries );\n\tif ( fmt )\n\t\tfor ( i = 0; i < depth - 1; ++i )\n\t\t\t*ptr++ = '\\t';\n\t*ptr++ = '}';\n\t*ptr++ = 0;\n\treturn out;\t\n}\n\n\nint cJSON_GetArraySize( cJSON *array )\n{\n\tcJSON *c = array->child;\n\tint i = 0;\n\twhile ( c ) {\n\t\t++i;\n\t\tc = c->next;\n\t}\n\treturn i;\n}\n\n\ncJSON *cJSON_GetArrayItem( cJSON *array, int item )\n{\n\tcJSON *c = array->child;\n\twhile ( c && item > 0 ) {\n\t\t--item;\n\t\tc = c->next;\n\t}\n\treturn c;\n}\n\n\ncJSON *cJSON_GetObjectItem( cJSON *object, const char *string )\n{\n\tcJSON *c = object->child;\n\twhile ( c && cJSON_strcasecmp( c->string, string ) )\n\t\tc = c->next;\n\treturn c;\n}\n\n\n/* Utility for array list handling. */\nstatic void suffix_object( cJSON *prev, cJSON *item )\n{\n\tprev->next = item;\n\titem->prev = prev;\n}\n\n\n/* Utility for handling references. */\nstatic cJSON *create_reference( cJSON *item )\n{\n\tcJSON *ref;\n\tif ( ! ( ref = cJSON_New_Item() ) )\n\t\treturn 0;\n\tmemcpy( ref, item, sizeof(cJSON) );\n\tref->string = 0;\n\tref->type |= cJSON_IsReference;\n\tref->next = ref->prev = 0;\n\treturn ref;\n}\n\n\n/* Add item to array/object. */\nvoid cJSON_AddItemToArray( cJSON *array, cJSON *item )\n{\n\tcJSON *c = array->child;\n\tif ( ! item )\n\t\treturn;\n\tif ( ! c ) {\n\t\tarray->child = item;\n\t} else {\n\t\twhile ( c && c->next )\n\t\t\tc = c->next;\n\t\tsuffix_object( c, item );\n\t}\n}\n\nvoid cJSON_AddItemToObject( cJSON *object, const char *string, cJSON *item )\n{\n\tif ( ! item )\n\t\treturn;\n\tif ( item->string )\n\t\tcJSON_free( item->string );\n\titem->string = cJSON_strdup( string );\n\tcJSON_AddItemToArray( object, item );\n}\n\nvoid cJSON_AddItemReferenceToArray( cJSON *array, cJSON *item )\n{\n\tcJSON_AddItemToArray( array, create_reference( item ) );\n}\n\nvoid cJSON_AddItemReferenceToObject( cJSON *object, const char *string, cJSON *item )\n{\n\tcJSON_AddItemToObject( object, string, create_reference( item ) );\n}\n\ncJSON *cJSON_DetachItemFromArray( cJSON *array, int which )\n{\n\tcJSON *c = array->child;\n\twhile ( c && which > 0 ) {\n\t\tc = c->next;\n\t\t--which;\n\t}\n\tif ( ! c )\n\t\treturn 0;\n\tif ( c->prev )\n\t\tc->prev->next = c->next;\n\tif ( c->next ) c->next->prev = c->prev;\n\tif ( c == array->child )\n\t\tarray->child = c->next;\n\tc->prev = c->next = 0;\n\treturn c;\n}\n\nvoid cJSON_DeleteItemFromArray( cJSON *array, int which )\n{\n\tcJSON_Delete( cJSON_DetachItemFromArray( array, which ) );\n}\n\ncJSON *cJSON_DetachItemFromObject( cJSON *object, const char *string )\n{\n\tint i = 0;\n\tcJSON *c = object->child;\n\twhile ( c && cJSON_strcasecmp( c->string, string ) ) {\n\t\t++i;\n\t\tc = c->next;\n\t}\n\tif ( c )\n\t\treturn cJSON_DetachItemFromArray( object, i );\n\treturn 0;\n}\n\nvoid cJSON_DeleteItemFromObject( cJSON *object, const char *string )\n{\n\tcJSON_Delete( cJSON_DetachItemFromObject( object, string ) );\n}\n\n/* Replace array/object items with new ones. */\nvoid cJSON_ReplaceItemInArray( cJSON *array, int which, cJSON *newitem )\n{\n\tcJSON *c = array->child;\n\twhile ( c && which > 0 ) {\n\t\tc = c->next;\n\t\t--which;\n\t}\n\tif ( ! c )\n\t\treturn;\n\tnewitem->next = c->next;\n\tnewitem->prev = c->prev;\n\tif ( newitem->next )\n\t\tnewitem->next->prev = newitem;\n\tif ( c == array->child )\n\t\tarray->child = newitem;\n\telse\n\t\tnewitem->prev->next = newitem;\n\tc->next = c->prev = 0;\n\tcJSON_Delete( c );\n}\n\nvoid cJSON_ReplaceItemInObject( cJSON *object, const char *string, cJSON *newitem )\n{\n\tint i = 0;\n\tcJSON *c = object->child;\n\twhile ( c && cJSON_strcasecmp( c->string, string ) ) {\n\t\t++i;\n\t\tc = c->next;\n\t}\n\tif ( c ) {\n\t\tnewitem->string = cJSON_strdup( string );\n\t\tcJSON_ReplaceItemInArray( object, i, newitem );\n\t}\n}\n\n\n/* Create basic types: */\n\ncJSON *cJSON_CreateNull( void )\n{\n\tcJSON *item = cJSON_New_Item();\n\tif ( item )\n\t\titem->type = cJSON_NULL;\n\treturn item;\n}\n\ncJSON *cJSON_CreateTrue( void )\n{\n\tcJSON *item = cJSON_New_Item();\n\tif ( item )\n\t\titem->type = cJSON_True;\n\treturn item;\n}\n\ncJSON *cJSON_CreateFalse( void )\n{\n\tcJSON *item = cJSON_New_Item();\n\tif ( item )\n\t\titem->type = cJSON_False;\n\treturn item;\n}\n\ncJSON *cJSON_CreateBool( int b )\n{\n\tcJSON *item = cJSON_New_Item();\n\tif ( item )\n\t\titem->type = b ? cJSON_True : cJSON_False;\n\treturn item;\n}\n\ncJSON *cJSON_CreateInt( int64_t num )\n{\n\tcJSON *item = cJSON_New_Item();\n\tif ( item ) {\n\t\titem->type = cJSON_Number;\n\t\titem->valuefloat = num;\n\t\titem->valueint = num;\n\t}\n\treturn item;\n}\n\ncJSON *cJSON_CreateFloat( double num )\n{\n\tcJSON *item = cJSON_New_Item();\n\tif ( item ) {\n\t\titem->type = cJSON_Number;\n\t\titem->valuefloat = num;\n\t\titem->valueint = num;\n\t}\n\treturn item;\n}\n\ncJSON *cJSON_CreateString( const char *string )\n{\n\tcJSON *item = cJSON_New_Item();\n\tif ( item ) {\n\t\titem->type = cJSON_String;\n\t\titem->valuestring = cJSON_strdup( string );\n\t}\n\treturn item;\n}\n\ncJSON *cJSON_CreateArray( void )\n{\n\tcJSON *item = cJSON_New_Item();\n\tif ( item )\n\t\titem->type = cJSON_Array;\n\treturn item;\n}\n\ncJSON *cJSON_CreateObject( void )\n{\n\tcJSON *item = cJSON_New_Item();\n\tif ( item )\n\t\titem->type = cJSON_Object;\n\treturn item;\n}\n\n\n/* Create Arrays. */\n\ncJSON *cJSON_CreateIntArray( int64_t *numbers, int count )\n{\n\tint i;\n\tcJSON *n = 0, *p = 0, *a = cJSON_CreateArray();\n\tfor ( i = 0; a && i < count; ++i ) {\n\t\tn = cJSON_CreateInt( numbers[i] );\n\t\tif ( ! i )\n\t\t\ta->child = n;\n\t\telse\n\t\t\tsuffix_object( p, n );\n\t\tp = n;\n\t}\n\treturn a;\n}\n\ncJSON *cJSON_CreateFloatArray( double *numbers, int count )\n{\n\tint i;\n\tcJSON *n = 0, *p = 0, *a = cJSON_CreateArray();\n\tfor ( i = 0; a && i < count; ++i ) {\n\t\tn = cJSON_CreateFloat( numbers[i] );\n\t\tif ( ! i )\n\t\t\ta->child = n;\n\t\telse\n\t\t\tsuffix_object( p, n );\n\t\tp = n;\n\t}\n\treturn a;\n}\n\ncJSON *cJSON_CreateStringArray( const char **strings, int count )\n{\n\tint i;\n\tcJSON *n = 0, *p = 0, *a = cJSON_CreateArray();\n\tfor ( i = 0; a && i < count; ++i ) {\n\t\tn = cJSON_CreateString( strings[i] );\n\t\tif ( ! i )\n\t\t\ta->child = n;\n\t\telse\n\t\t\tsuffix_object( p, n );\n\t\tp = n;\n\t}\n\treturn a;\n}\n", "/*\n  Copyright (c) 2009 Dave Gamble\n \n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n \n  The above copyright notice and this permission notice shall be included in\n  all copies or substantial portions of the Software.\n \n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n  THE SOFTWARE.\n*/\n\n#ifndef cJSON__h\n#define cJSON__h\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n/* cJSON Types: */\n#define cJSON_False 0\n#define cJSON_True 1\n#define cJSON_NULL 2\n#define cJSON_Number 3\n#define cJSON_String 4\n#define cJSON_Array 5\n#define cJSON_Object 6\n\t\n#define cJSON_IsReference 256\n\n/* The cJSON structure: */\ntypedef struct cJSON {\n\tstruct cJSON *next, *prev;\t/* next/prev allow you to walk array/object chains. Alternatively, use GetArraySize/GetArrayItem/GetObjectItem */\n\tstruct cJSON *child;\t\t/* An array or object item will have a child pointer pointing to a chain of the items in the array/object. */\n\n\tint type;\t\t\t/* The type of the item, as above. */\n\n\tchar *valuestring;\t\t/* The item's string, if type==cJSON_String */\n\tint64_t valueint;\t\t/* The item's number, if type==cJSON_Number */\n\tdouble valuefloat;\t\t/* The item's number, if type==cJSON_Number */\n\n\tchar *string;\t\t\t/* The item's name string, if this item is the child of, or is in the list of subitems of an object. */\n} cJSON;\n\ntypedef struct cJSON_Hooks {\n      void *(*malloc_fn)(size_t sz );\n      void (*free_fn)( void *ptr );\n} cJSON_Hooks;\n\n/* Supply malloc, realloc and free functions to cJSON */\nextern void cJSON_InitHooks( cJSON_Hooks* hooks );\n\n\n/* Supply a block of JSON, and this returns a cJSON object you can interrogate. Call cJSON_Delete when finished. */\nextern cJSON *cJSON_Parse( const char *value );\n/* Render a cJSON entity to text for transfer/storage. Free the char* when finished. */\nextern char *cJSON_Print( cJSON *item );\n/* Render a cJSON entity to text for transfer/storage without any formatting. Free the char* when finished. */\nextern char *cJSON_PrintUnformatted( cJSON *item );\n/* Delete a cJSON entity and all subentities. */\nextern void cJSON_Delete( cJSON *c );\n\n/* Returns the number of items in an array (or object). */\nextern int cJSON_GetArraySize( cJSON *array );\n/* Retrieve item number \"item\" from array \"array\". Returns NULL if unsuccessful. */\nextern cJSON *cJSON_GetArrayItem( cJSON *array, int item );\n/* Get item \"string\" from object. Case insensitive. */\nextern cJSON *cJSON_GetObjectItem( cJSON *object, const char *string );\n\n/* For analysing failed parses. This returns a pointer to the parse error. You'll probably need to look a few chars back to make sense of it. Defined when cJSON_Parse() returns 0. 0 when cJSON_Parse() succeeds. */\nextern const char *cJSON_GetErrorPtr( void );\n\t\n/* These calls create a cJSON item of the appropriate type. */\nextern cJSON *cJSON_CreateNull( void );\nextern cJSON *cJSON_CreateTrue( void );\nextern cJSON *cJSON_CreateFalse( void );\nextern cJSON *cJSON_CreateBool( int b );\nextern cJSON *cJSON_CreateInt( int64_t num );\nextern cJSON *cJSON_CreateFloat( double num );\nextern cJSON *cJSON_CreateString( const char *string );\nextern cJSON *cJSON_CreateArray( void );\nextern cJSON *cJSON_CreateObject( void );\n\n/* These utilities create an Array of count items. */\nextern cJSON *cJSON_CreateIntArray( int64_t *numbers, int count );\nextern cJSON *cJSON_CreateFloatArray( double *numbers, int count );\nextern cJSON *cJSON_CreateStringArray( const char **strings, int count );\n\n/* Append item to the specified array/object. */\nextern void cJSON_AddItemToArray( cJSON *array, cJSON *item );\nextern void cJSON_AddItemToObject( cJSON *object, const char *string, cJSON *item );\n/* Append reference to item to the specified array/object. Use this when you want to add an existing cJSON to a new cJSON, but don't want to corrupt your existing cJSON. */\nextern void cJSON_AddItemReferenceToArray( cJSON *array, cJSON *item );\nextern void cJSON_AddItemReferenceToObject( cJSON *object, const char *string, cJSON *item );\n\n/* Remove/Detatch items from Arrays/Objects. */\nextern cJSON *cJSON_DetachItemFromArray( cJSON *array, int which );\nextern void cJSON_DeleteItemFromArray( cJSON *array, int which );\nextern cJSON *cJSON_DetachItemFromObject( cJSON *object, const char *string );\nextern void cJSON_DeleteItemFromObject( cJSON *object, const char *string );\n\t\n/* Update array items. */\nextern void cJSON_ReplaceItemInArray( cJSON *array, int which, cJSON *newitem );\nextern void cJSON_ReplaceItemInObject( cJSON *object, const char *string, cJSON *newitem );\n\n#define cJSON_AddNullToObject( object, name )\t\tcJSON_AddItemToObject( object, name, cJSON_CreateNull() )\n#define cJSON_AddTrueToObject( object, name )\t\tcJSON_AddItemToObject( object, name, cJSON_CreateTrue() )\n#define cJSON_AddFalseToObject( object, name )\t\tcJSON_AddItemToObject( object, name, cJSON_CreateFalse() )\n#define cJSON_AddIntToObject( object, name, n )\t\tcJSON_AddItemToObject( object, name, cJSON_CreateInt( n ) )\n#define cJSON_AddFloatToObject( object, name, n )\tcJSON_AddItemToObject( object, name, cJSON_CreateFloat( n ) )\n#define cJSON_AddStringToObject( object, name, s )\tcJSON_AddItemToObject( object, name, cJSON_CreateString( s ) )\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n", "/*\n * iperf, Copyright (c) 2014, 2015, The Regents of the University of\n * California, through Lawrence Berkeley National Laboratory (subject\n * to receipt of any required approvals from the U.S. Dept. of\n * Energy).  All rights reserved.\n *\n * If you have questions about your rights to use or distribute this\n * software, please contact Berkeley Lab's Technology Transfer\n * Department at TTD@lbl.gov.\n *\n * NOTICE.  This software is owned by the U.S. Department of Energy.\n * As such, the U.S. Government has been granted for itself and others\n * acting on its behalf a paid-up, nonexclusive, irrevocable,\n * worldwide license in the Software to reproduce, prepare derivative\n * works, and perform publicly and display publicly.  Beginning five\n * (5) years after the date permission to assert copyright is obtained\n * from the U.S. Department of Energy, and subject to any subsequent\n * five (5) year renewals, the U.S. Government is granted for itself\n * and others acting on its behalf a paid-up, nonexclusive,\n * irrevocable, worldwide license in the Software to reproduce,\n * prepare derivative works, distribute copies to the public, perform\n * publicly and display publicly, and to permit others to do so.\n *\n * This code is distributed under a BSD style license, see the LICENSE file\n * for complete information.\n */\n#define _GNU_SOURCE\n#define __USE_GNU\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <getopt.h>\n#include <errno.h>\n#include <signal.h>\n#include <unistd.h>\n#include <assert.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <pthread.h>\n#include <stdint.h>\n#include <netinet/tcp.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sched.h>\n#include <setjmp.h>\n#include <stdarg.h>\n\n#include \"net.h\"\n#include \"iperf.h\"\n#include \"iperf_api.h\"\n#include \"iperf_udp.h\"\n#include \"iperf_tcp.h\"\n#include \"timer.h\"\n\n#include \"cjson.h\"\n#include \"units.h\"\n#include \"tcp_window_size.h\"\n#include \"iperf_util.h\"\n#include \"iperf_locale.h\"\n\n\n/* Forwards. */\nstatic int send_parameters(struct iperf_test *test);\nstatic int get_parameters(struct iperf_test *test);\nstatic int send_results(struct iperf_test *test);\nstatic int get_results(struct iperf_test *test);\nstatic int diskfile_send(struct iperf_stream *sp);\nstatic int diskfile_recv(struct iperf_stream *sp);\nstatic int JSON_write(int fd, cJSON *json);\nstatic void print_interval_results(struct iperf_test *test, struct iperf_stream *sp, cJSON *json_interval_streams);\nstatic cJSON *JSON_read(int fd);\n\n\n/*************************** Print usage functions ****************************/\n\nvoid\nusage()\n{\n    fputs(usage_shortstr, stderr);\n}\n\n\nvoid\nusage_long()\n{\n    fprintf(stderr, usage_longstr, UDP_RATE / (1024*1024), DURATION, DEFAULT_TCP_BLKSIZE / 1024, DEFAULT_UDP_BLKSIZE / 1024);\n}\n\n\nvoid warning(char *str)\n{\n    fprintf(stderr, \"warning: %s\\n\", str);\n}\n\n\n/************** Getter routines for some fields inside iperf_test *************/\n\nint\niperf_get_verbose(struct iperf_test *ipt)\n{\n    return ipt->verbose;\n}\n\nint\niperf_get_control_socket(struct iperf_test *ipt)\n{\n    return ipt->ctrl_sck;\n}\n\nint\niperf_get_test_omit(struct iperf_test *ipt)\n{\n    return ipt->omit;\n}\n\nint\niperf_get_test_duration(struct iperf_test *ipt)\n{\n    return ipt->duration;\n}\n\nuint64_t\niperf_get_test_rate(struct iperf_test *ipt)\n{\n    return ipt->settings->rate;\n}\n\nint\niperf_get_test_burst(struct iperf_test *ipt)\n{\n    return ipt->settings->burst;\n}\n\nchar\niperf_get_test_role(struct iperf_test *ipt)\n{\n    return ipt->role;\n}\n\nint\niperf_get_test_reverse(struct iperf_test *ipt)\n{\n    return ipt->reverse;\n}\n\nint\niperf_get_test_blksize(struct iperf_test *ipt)\n{\n    return ipt->settings->blksize;\n}\n\nint\niperf_get_test_socket_bufsize(struct iperf_test *ipt)\n{\n    return ipt->settings->socket_bufsize;\n}\n\ndouble\niperf_get_test_reporter_interval(struct iperf_test *ipt)\n{\n    return ipt->reporter_interval;\n}\n\ndouble\niperf_get_test_stats_interval(struct iperf_test *ipt)\n{\n    return ipt->stats_interval;\n}\n\nint\niperf_get_test_num_streams(struct iperf_test *ipt)\n{\n    return ipt->num_streams;\n}\n\nint\niperf_get_test_server_port(struct iperf_test *ipt)\n{\n    return ipt->server_port;\n}\n\nchar*\niperf_get_test_server_hostname(struct iperf_test *ipt)\n{\n    return ipt->server_hostname;\n}\n\nint\niperf_get_test_protocol_id(struct iperf_test *ipt)\n{\n    return ipt->protocol->id;\n}\n\nint\niperf_get_test_json_output(struct iperf_test *ipt)\n{\n    return ipt->json_output;\n}\n\nint\niperf_get_test_zerocopy(struct iperf_test *ipt)\n{\n    return ipt->zerocopy;\n}\n\nint\niperf_get_test_get_server_output(struct iperf_test *ipt)\n{\n    return ipt->get_server_output;\n}\n\nchar\niperf_get_test_unit_format(struct iperf_test *ipt)\n{\n    return ipt->settings->unit_format;\n}\n\nchar *\niperf_get_test_bind_address(struct iperf_test *ipt)\n{\n    return ipt->bind_address;\n}\n\nint\niperf_get_test_one_off(struct iperf_test *ipt)\n{\n    return ipt->one_off;\n}\n\n/************** Setter routines for some fields inside iperf_test *************/\n\nvoid\niperf_set_verbose(struct iperf_test *ipt, int verbose)\n{\n    ipt->verbose = verbose;\n}\n\nvoid\niperf_set_control_socket(struct iperf_test *ipt, int ctrl_sck)\n{\n    ipt->ctrl_sck = ctrl_sck;\n}\n\nvoid\niperf_set_test_omit(struct iperf_test *ipt, int omit)\n{\n    ipt->omit = omit;\n}\n\nvoid\niperf_set_test_duration(struct iperf_test *ipt, int duration)\n{\n    ipt->duration = duration;\n}\n\nvoid\niperf_set_test_reporter_interval(struct iperf_test *ipt, double reporter_interval)\n{\n    ipt->reporter_interval = reporter_interval;\n}\n\nvoid\niperf_set_test_stats_interval(struct iperf_test *ipt, double stats_interval)\n{\n    ipt->stats_interval = stats_interval;\n}\n\nvoid\niperf_set_test_state(struct iperf_test *ipt, signed char state)\n{\n    ipt->state = state;\n}\n\nvoid\niperf_set_test_blksize(struct iperf_test *ipt, int blksize)\n{\n    ipt->settings->blksize = blksize;\n}\n\nvoid\niperf_set_test_rate(struct iperf_test *ipt, uint64_t rate)\n{\n    ipt->settings->rate = rate;\n}\n\nvoid\niperf_set_test_burst(struct iperf_test *ipt, int burst)\n{\n    ipt->settings->burst = burst;\n}\n\nvoid\niperf_set_test_server_port(struct iperf_test *ipt, int server_port)\n{\n    ipt->server_port = server_port;\n}\n\nvoid\niperf_set_test_socket_bufsize(struct iperf_test *ipt, int socket_bufsize)\n{\n    ipt->settings->socket_bufsize = socket_bufsize;\n}\n\nvoid\niperf_set_test_num_streams(struct iperf_test *ipt, int num_streams)\n{\n    ipt->num_streams = num_streams;\n}\n\nstatic void\ncheck_sender_has_retransmits(struct iperf_test *ipt)\n{\n    if (ipt->sender && ipt->protocol->id == Ptcp && has_tcpinfo_retransmits())\n\tipt->sender_has_retransmits = 1;\n    else\n\tipt->sender_has_retransmits = 0;\n}\n\nvoid\niperf_set_test_role(struct iperf_test *ipt, char role)\n{\n    ipt->role = role;\n    if (role == 'c')\n\tipt->sender = 1;\n    else if (role == 's')\n\tipt->sender = 0;\n    if (ipt->reverse)\n        ipt->sender = ! ipt->sender;\n    check_sender_has_retransmits(ipt);\n}\n\nvoid\niperf_set_test_server_hostname(struct iperf_test *ipt, char *server_hostname)\n{\n    ipt->server_hostname = strdup(server_hostname);\n}\n\nvoid\niperf_set_test_reverse(struct iperf_test *ipt, int reverse)\n{\n    ipt->reverse = reverse;\n    if (ipt->reverse)\n        ipt->sender = ! ipt->sender;\n    check_sender_has_retransmits(ipt);\n}\n\nvoid\niperf_set_test_json_output(struct iperf_test *ipt, int json_output)\n{\n    ipt->json_output = json_output;\n}\n\nint\niperf_has_zerocopy( void )\n{\n    return has_sendfile();\n}\n\nvoid\niperf_set_test_zerocopy(struct iperf_test *ipt, int zerocopy)\n{\n    ipt->zerocopy = (zerocopy && has_sendfile());\n}\n\nvoid\niperf_set_test_get_server_output(struct iperf_test *ipt, int get_server_output)\n{\n    ipt->get_server_output = get_server_output;\n}\n\nvoid\niperf_set_test_unit_format(struct iperf_test *ipt, char unit_format)\n{\n    ipt->settings->unit_format = unit_format;\n}\n\nvoid\niperf_set_test_bind_address(struct iperf_test *ipt, char *bind_address)\n{\n    ipt->bind_address = strdup(bind_address);\n}\n\nvoid\niperf_set_test_one_off(struct iperf_test *ipt, int one_off)\n{\n    ipt->one_off = one_off;\n}\n\n/********************** Get/set test protocol structure ***********************/\n\nstruct protocol *\nget_protocol(struct iperf_test *test, int prot_id)\n{\n    struct protocol *prot;\n\n    SLIST_FOREACH(prot, &test->protocols, protocols) {\n        if (prot->id == prot_id)\n            break;\n    }\n\n    if (prot == NULL)\n        i_errno = IEPROTOCOL;\n\n    return prot;\n}\n\nint\nset_protocol(struct iperf_test *test, int prot_id)\n{\n    struct protocol *prot = NULL;\n\n    SLIST_FOREACH(prot, &test->protocols, protocols) {\n        if (prot->id == prot_id) {\n            test->protocol = prot;\n\t    check_sender_has_retransmits(test);\n            return 0;\n        }\n    }\n\n    i_errno = IEPROTOCOL;\n    return -1;\n}\n\n\n/************************** Iperf callback functions **************************/\n\nvoid\niperf_on_new_stream(struct iperf_stream *sp)\n{\n    connect_msg(sp);\n}\n\nvoid\niperf_on_test_start(struct iperf_test *test)\n{\n    if (test->json_output) {\n\tcJSON_AddItemToObject(test->json_start, \"test_start\", iperf_json_printf(\"protocol: %s  num_streams: %d  blksize: %d  omit: %d  duration: %d  bytes: %d  blocks: %d  reverse: %d\", test->protocol->name, (int64_t) test->num_streams, (int64_t) test->settings->blksize, (int64_t) test->omit, (int64_t) test->duration, (int64_t) test->settings->bytes, (int64_t) test->settings->blocks, test->reverse?(int64_t)1:(int64_t)0));\n    } else {\n\tif (test->verbose) {\n\t    if (test->settings->bytes)\n\t\tiprintf(test, test_start_bytes, test->protocol->name, test->num_streams, test->settings->blksize, test->omit, test->settings->bytes);\n\t    else if (test->settings->blocks)\n\t\tiprintf(test, test_start_blocks, test->protocol->name, test->num_streams, test->settings->blksize, test->omit, test->settings->blocks);\n\t    else\n\t\tiprintf(test, test_start_time, test->protocol->name, test->num_streams, test->settings->blksize, test->omit, test->duration);\n\t}\n    }\n}\n\n/* This converts an IPv6 string address from IPv4-mapped format into regular\n** old IPv4 format, which is easier on the eyes of network veterans.\n**\n** If the v6 address is not v4-mapped it is left alone.\n*/\nstatic void\nmapped_v4_to_regular_v4(char *str)\n{\n    char *prefix = \"::ffff:\";\n    int prefix_len;\n\n    prefix_len = strlen(prefix);\n    if (strncmp(str, prefix, prefix_len) == 0) {\n\tint str_len = strlen(str);\n\tmemmove(str, str + prefix_len, str_len - prefix_len + 1);\n    }\n}\n\nvoid\niperf_on_connect(struct iperf_test *test)\n{\n    time_t now_secs;\n    const char* rfc1123_fmt = \"%a, %d %b %Y %H:%M:%S GMT\";\n    char now_str[100];\n    char ipr[INET6_ADDRSTRLEN];\n    int port;\n    struct sockaddr_storage sa;\n    struct sockaddr_in *sa_inP;\n    struct sockaddr_in6 *sa_in6P;\n    socklen_t len;\n    int opt;\n\n    now_secs = time((time_t*) 0);\n    (void) strftime(now_str, sizeof(now_str), rfc1123_fmt, gmtime(&now_secs));\n    if (test->json_output)\n\tcJSON_AddItemToObject(test->json_start, \"timestamp\", iperf_json_printf(\"time: %s  timesecs: %d\", now_str, (int64_t) now_secs));\n    else if (test->verbose)\n\tiprintf(test, report_time, now_str);\n\n    if (test->role == 'c') {\n\tif (test->json_output)\n\t    cJSON_AddItemToObject(test->json_start, \"connecting_to\", iperf_json_printf(\"host: %s  port: %d\", test->server_hostname, (int64_t) test->server_port));\n\telse {\n\t    iprintf(test, report_connecting, test->server_hostname, test->server_port);\n\t    if (test->reverse)\n\t\tiprintf(test, report_reverse, test->server_hostname);\n\t}\n    } else {\n        len = sizeof(sa);\n        getpeername(test->ctrl_sck, (struct sockaddr *) &sa, &len);\n        if (getsockdomain(test->ctrl_sck) == AF_INET) {\n\t    sa_inP = (struct sockaddr_in *) &sa;\n            inet_ntop(AF_INET, &sa_inP->sin_addr, ipr, sizeof(ipr));\n\t    port = ntohs(sa_inP->sin_port);\n        } else {\n\t    sa_in6P = (struct sockaddr_in6 *) &sa;\n            inet_ntop(AF_INET6, &sa_in6P->sin6_addr, ipr, sizeof(ipr));\n\t    port = ntohs(sa_in6P->sin6_port);\n        }\n\tmapped_v4_to_regular_v4(ipr);\n\tif (test->json_output)\n\t    cJSON_AddItemToObject(test->json_start, \"accepted_connection\", iperf_json_printf(\"host: %s  port: %d\", ipr, (int64_t) port));\n\telse\n\t    iprintf(test, report_accepted, ipr, port);\n    }\n    if (test->json_output) {\n\tcJSON_AddStringToObject(test->json_start, \"cookie\", test->cookie);\n        if (test->protocol->id == SOCK_STREAM) {\n\t    if (test->settings->mss)\n\t\tcJSON_AddIntToObject(test->json_start, \"tcp_mss\", test->settings->mss);\n\t    else {\n\t\tlen = sizeof(opt);\n\t\tgetsockopt(test->ctrl_sck, IPPROTO_TCP, TCP_MAXSEG, &opt, &len);\n\t\tcJSON_AddIntToObject(test->json_start, \"tcp_mss_default\", opt);\n\t    }\n\t}\n    } else if (test->verbose) {\n        iprintf(test, report_cookie, test->cookie);\n        if (test->protocol->id == SOCK_STREAM) {\n            if (test->settings->mss)\n                iprintf(test, \"      TCP MSS: %d\\n\", test->settings->mss);\n            else {\n                len = sizeof(opt);\n                getsockopt(test->ctrl_sck, IPPROTO_TCP, TCP_MAXSEG, &opt, &len);\n                iprintf(test, \"      TCP MSS: %d (default)\\n\", opt);\n            }\n        }\n\n    }\n}\n\nvoid\niperf_on_test_finish(struct iperf_test *test)\n{\n}\n\n\n/******************************************************************************/\n\nint\niperf_parse_arguments(struct iperf_test *test, int argc, char **argv)\n{\n    static struct option longopts[] =\n    {\n        {\"port\", required_argument, NULL, 'p'},\n        {\"format\", required_argument, NULL, 'f'},\n        {\"interval\", required_argument, NULL, 'i'},\n        {\"daemon\", no_argument, NULL, 'D'},\n        {\"one-off\", no_argument, NULL, '1'},\n        {\"verbose\", no_argument, NULL, 'V'},\n        {\"json\", no_argument, NULL, 'J'},\n        {\"version\", no_argument, NULL, 'v'},\n        {\"server\", no_argument, NULL, 's'},\n        {\"client\", required_argument, NULL, 'c'},\n        {\"udp\", no_argument, NULL, 'u'},\n        {\"bandwidth\", required_argument, NULL, 'b'},\n        {\"time\", required_argument, NULL, 't'},\n        {\"bytes\", required_argument, NULL, 'n'},\n        {\"blockcount\", required_argument, NULL, 'k'},\n        {\"length\", required_argument, NULL, 'l'},\n        {\"parallel\", required_argument, NULL, 'P'},\n        {\"reverse\", no_argument, NULL, 'R'},\n        {\"window\", required_argument, NULL, 'w'},\n        {\"bind\", required_argument, NULL, 'B'},\n        {\"set-mss\", required_argument, NULL, 'M'},\n        {\"no-delay\", no_argument, NULL, 'N'},\n        {\"version4\", no_argument, NULL, '4'},\n        {\"version6\", no_argument, NULL, '6'},\n        {\"tos\", required_argument, NULL, 'S'},\n        {\"flowlabel\", required_argument, NULL, 'L'},\n        {\"zerocopy\", no_argument, NULL, 'Z'},\n        {\"omit\", required_argument, NULL, 'O'},\n        {\"file\", required_argument, NULL, 'F'},\n        {\"affinity\", required_argument, NULL, 'A'},\n        {\"title\", required_argument, NULL, 'T'},\n#if defined(linux) && defined(TCP_CONGESTION)\n        {\"linux-congestion\", required_argument, NULL, 'C'},\n#endif\n\t{\"get-server-output\", no_argument, NULL, OPT_GET_SERVER_OUTPUT},\n        {\"debug\", no_argument, NULL, 'd'},\n        {\"help\", no_argument, NULL, 'h'},\n        {NULL, 0, NULL, 0}\n    };\n    int flag;\n    int blksize;\n    int server_flag, client_flag, rate_flag, duration_flag;\n    char* comma;\n    char* slash;\n\n    blksize = 0;\n    server_flag = client_flag = rate_flag = duration_flag = 0;\n    while ((flag = getopt_long(argc, argv, \"p:f:i:D1VJvsc:ub:t:n:k:l:P:Rw:B:M:N46S:L:ZO:F:A:T:C:dh\", longopts, NULL)) != -1) {\n        switch (flag) {\n            case 'p':\n                test->server_port = atoi(optarg);\n                break;\n            case 'f':\n                test->settings->unit_format = *optarg;\n                break;\n            case 'i':\n                /* XXX: could potentially want separate stat collection and reporting intervals,\n                   but just set them to be the same for now */\n                test->stats_interval = test->reporter_interval = atof(optarg);\n                if ((test->stats_interval < MIN_INTERVAL || test->stats_interval > MAX_INTERVAL) && test->stats_interval != 0) {\n                    i_errno = IEINTERVAL;\n                    return -1;\n                }\n                break;\n            case 'D':\n\t\ttest->daemon = 1;\n\t\tserver_flag = 1;\n\t        break;\n            case '1':\n\t\ttest->one_off = 1;\n\t\tserver_flag = 1;\n\t        break;\n            case 'V':\n                test->verbose = 1;\n                break;\n            case 'J':\n                test->json_output = 1;\n                break;\n            case 'v':\n                printf(\"%s\\n\", version);\n\t\tsystem(\"uname -a\");\n                exit(0);\n            case 's':\n                if (test->role == 'c') {\n                    i_errno = IESERVCLIENT;\n                    return -1;\n                }\n\t\tiperf_set_test_role(test, 's');\n                break;\n            case 'c':\n                if (test->role == 's') {\n                    i_errno = IESERVCLIENT;\n                    return -1;\n                }\n\t\tiperf_set_test_role(test, 'c');\n\t\tiperf_set_test_server_hostname(test, optarg);\n                break;\n            case 'u':\n                set_protocol(test, Pudp);\n\t\tclient_flag = 1;\n                break;\n            case 'b':\n\t\tslash = strchr(optarg, '/');\n\t\tif (slash) {\n\t\t    *slash = '\\0';\n\t\t    ++slash;\n\t\t    test->settings->burst = atoi(slash);\n\t\t    if (test->settings->burst <= 0 ||\n\t\t        test->settings->burst > MAX_BURST) {\n\t\t\ti_errno = IEBURST;\n\t\t\treturn -1;\n\t\t    }\n\t\t}\n                test->settings->rate = unit_atof_rate(optarg);\n\t\trate_flag = 1;\n\t\tclient_flag = 1;\n                break;\n            case 't':\n                test->duration = atoi(optarg);\n                if (test->duration > MAX_TIME) {\n                    i_errno = IEDURATION;\n                    return -1;\n                }\n\t\tduration_flag = 1;\n\t\tclient_flag = 1;\n                break;\n            case 'n':\n                test->settings->bytes = unit_atoi(optarg);\n\t\tclient_flag = 1;\n                break;\n            case 'k':\n                test->settings->blocks = unit_atoi(optarg);\n\t\tclient_flag = 1;\n                break;\n            case 'l':\n                blksize = unit_atoi(optarg);\n\t\tclient_flag = 1;\n                break;\n            case 'P':\n                test->num_streams = atoi(optarg);\n                if (test->num_streams > MAX_STREAMS) {\n                    i_errno = IENUMSTREAMS;\n                    return -1;\n                }\n\t\tclient_flag = 1;\n                break;\n            case 'R':\n\t\tiperf_set_test_reverse(test, 1);\n\t\tclient_flag = 1;\n                break;\n            case 'w':\n                // XXX: This is a socket buffer, not specific to TCP\n                test->settings->socket_bufsize = unit_atof(optarg);\n                if (test->settings->socket_bufsize > MAX_TCP_BUFFER) {\n                    i_errno = IEBUFSIZE;\n                    return -1;\n                }\n\t\tclient_flag = 1;\n                break;\n            case 'B':\n                test->bind_address = strdup(optarg);\n                break;\n            case 'M':\n                test->settings->mss = atoi(optarg);\n                if (test->settings->mss > MAX_MSS) {\n                    i_errno = IEMSS;\n                    return -1;\n                }\n\t\tclient_flag = 1;\n                break;\n            case 'N':\n                test->no_delay = 1;\n\t\tclient_flag = 1;\n                break;\n            case '4':\n                test->settings->domain = AF_INET;\n                break;\n            case '6':\n                test->settings->domain = AF_INET6;\n                break;\n            case 'S':\n                test->settings->tos = strtol(optarg, NULL, 0);\n\t\tclient_flag = 1;\n                break;\n            case 'L':\n#if defined(linux)\n                test->settings->flowlabel = strtol(optarg, NULL, 0);\n\t\tif (test->settings->flowlabel < 1 || test->settings->flowlabel > 0xfffff) {\n                    i_errno = IESETFLOW;\n                    return -1;\n\t\t}\n\t\tclient_flag = 1;\n#else /* linux */\n                i_errno = IEUNIMP;\n                return -1;\n#endif /* linux */\n                break;\n            case 'Z':\n                if (!has_sendfile()) {\n                    i_errno = IENOSENDFILE;\n                    return -1;\n                }\n                test->zerocopy = 1;\n\t\tclient_flag = 1;\n                break;\n            case 'O':\n                test->omit = atoi(optarg);\n                if (test->omit < 0 || test->omit > 60) {\n                    i_errno = IEOMIT;\n                    return -1;\n                }\n\t\tclient_flag = 1;\n                break;\n            case 'F':\n                test->diskfile_name = optarg;\n                break;\n            case 'A':\n                test->affinity = atoi(optarg);\n                if (test->affinity < 0 || test->affinity > 1024) {\n                    i_errno = IEAFFINITY;\n                    return -1;\n                }\n\t\tcomma = strchr(optarg, ',');\n\t\tif (comma != NULL) {\n\t\t    test->server_affinity = atoi(comma+1);\n\t\t    if (test->server_affinity < 0 || test->server_affinity > 1024) {\n\t\t\ti_errno = IEAFFINITY;\n\t\t\treturn -1;\n\t\t    }\n\t\t    client_flag = 1;\n\t\t}\n                break;\n            case 'T':\n                test->title = strdup(optarg);\n\t\tclient_flag = 1;\n                break;\n\t    case 'C':\n#if defined(linux) && defined(TCP_CONGESTION)\n\t\ttest->congestion = strdup(optarg);\n\t\tclient_flag = 1;\n#else /* linux */\n\t\ti_errno = IEUNIMP;\n\t\treturn -1;\n#endif /* linux */\n\t\tbreak;\n\t    case 'd':\n\t\ttest->debug = 1;\n\t\tbreak;\n\t    case OPT_GET_SERVER_OUTPUT:\n\t\ttest->get_server_output = 1;\n\t\tclient_flag = 1;\n\t\tbreak;\n            case 'h':\n            default:\n                usage_long();\n                exit(1);\n        }\n    }\n\n    /* Check flag / role compatibility. */\n    if (test->role == 'c' && server_flag) {\n\ti_errno = IESERVERONLY;\n\treturn -1;\n    }\n    if (test->role == 's' && client_flag) {\n\ti_errno = IECLIENTONLY;\n\treturn -1;\n    }\n\n    if (blksize == 0) {\n\tif (test->protocol->id == Pudp)\n\t    blksize = DEFAULT_UDP_BLKSIZE;\n\telse\n\t    blksize = DEFAULT_TCP_BLKSIZE;\n    }\n    if (blksize <= 0 || blksize > MAX_BLOCKSIZE) {\n\ti_errno = IEBLOCKSIZE;\n\treturn -1;\n    }\n    if (test->protocol->id == Pudp &&\n\tblksize > MAX_UDP_BLOCKSIZE) {\n\ti_errno = IEUDPBLOCKSIZE;\n\treturn -1;\n    }\n    test->settings->blksize = blksize;\n\n    if (!rate_flag)\n\ttest->settings->rate = test->protocol->id == Pudp ? UDP_RATE : 0;\n\n    if ((test->settings->bytes != 0 || test->settings->blocks != 0) && ! duration_flag)\n        test->duration = 0;\n\n    /* Disallow specifying multiple test end conditions. The code actually\n    ** works just fine without this prohibition. As soon as any one of the\n    ** three possible end conditions is met, the test ends. So this check\n    ** could be removed if desired.\n    */\n    if ((duration_flag && test->settings->bytes != 0) ||\n        (duration_flag && test->settings->blocks != 0) ||\n\t(test->settings->bytes != 0 && test->settings->blocks != 0)) {\n        i_errno = IEENDCONDITIONS;\n        return -1;\n    }\n\n    /* For subsequent calls to getopt */\n#ifdef __APPLE__\n    optreset = 1;\n#endif\n    optind = 0;\n\n    if ((test->role != 'c') && (test->role != 's')) {\n        i_errno = IENOROLE;\n        return -1;\n    }\n\n    return 0;\n}\n\nint\niperf_set_send_state(struct iperf_test *test, signed char state)\n{\n    test->state = state;\n    if (Nwrite(test->ctrl_sck, (char*) &state, sizeof(state), Ptcp) < 0) {\n\ti_errno = IESENDMESSAGE;\n\treturn -1;\n    }\n    return 0;\n}\n\nvoid\niperf_check_throttle(struct iperf_stream *sp, struct timeval *nowP)\n{\n    double seconds;\n    uint64_t bits_per_second;\n\n    if (sp->test->done)\n        return;\n    seconds = timeval_diff(&sp->result->start_time, nowP);\n    bits_per_second = sp->result->bytes_sent * 8 / seconds;\n    if (bits_per_second < sp->test->settings->rate) {\n        sp->green_light = 1;\n        FD_SET(sp->socket, &sp->test->write_set);\n    } else {\n        sp->green_light = 0;\n        FD_CLR(sp->socket, &sp->test->write_set);\n    }\n}\n\nint\niperf_send(struct iperf_test *test, fd_set *write_setP)\n{\n    register int multisend, r, streams_active;\n    register struct iperf_stream *sp;\n    struct timeval now;\n\n    /* Can we do multisend mode? */\n    if (test->settings->burst != 0)\n        multisend = test->settings->burst;\n    else if (test->settings->rate == 0)\n        multisend = test->multisend;\n    else\n        multisend = 1;\t/* nope */\n\n    for (; multisend > 0; --multisend) {\n\tif (test->settings->rate != 0 && test->settings->burst == 0)\n\t    gettimeofday(&now, NULL);\n\tstreams_active = 0;\n\tSLIST_FOREACH(sp, &test->streams, streams) {\n\t    if (sp->green_light &&\n\t        (write_setP == NULL || FD_ISSET(sp->socket, write_setP))) {\n\t\tif ((r = sp->snd(sp)) < 0) {\n\t\t    if (r == NET_SOFTERROR)\n\t\t\tbreak;\n\t\t    i_errno = IESTREAMWRITE;\n\t\t    return r;\n\t\t}\n\t\tstreams_active = 1;\n\t\ttest->bytes_sent += r;\n\t\t++test->blocks_sent;\n\t\tif (test->settings->rate != 0 && test->settings->burst == 0)\n\t\t    iperf_check_throttle(sp, &now);\n\t\tif (multisend > 1 && test->settings->bytes != 0 && test->bytes_sent >= test->settings->bytes)\n\t\t    break;\n\t\tif (multisend > 1 && test->settings->blocks != 0 && test->blocks_sent >= test->settings->blocks)\n\t\t    break;\n\t    }\n\t}\n\tif (!streams_active)\n\t    break;\n    }\n    if (test->settings->burst != 0) {\n\tgettimeofday(&now, NULL);\n\tSLIST_FOREACH(sp, &test->streams, streams)\n\t    iperf_check_throttle(sp, &now);\n    }\n    if (write_setP != NULL)\n\tSLIST_FOREACH(sp, &test->streams, streams)\n\t    if (FD_ISSET(sp->socket, write_setP))\n\t\tFD_CLR(sp->socket, write_setP);\n\n    return 0;\n}\n\nint\niperf_recv(struct iperf_test *test, fd_set *read_setP)\n{\n    int r;\n    struct iperf_stream *sp;\n\n    SLIST_FOREACH(sp, &test->streams, streams) {\n\tif (FD_ISSET(sp->socket, read_setP)) {\n\t    if ((r = sp->rcv(sp)) < 0) {\n\t\ti_errno = IESTREAMREAD;\n\t\treturn r;\n\t    }\n\t    test->bytes_sent += r;\n\t    ++test->blocks_sent;\n\t    FD_CLR(sp->socket, read_setP);\n\t}\n    }\n\n    return 0;\n}\n\nint\niperf_init_test(struct iperf_test *test)\n{\n    struct timeval now;\n    struct iperf_stream *sp;\n\n    if (test->protocol->init) {\n        if (test->protocol->init(test) < 0)\n            return -1;\n    }\n\n    /* Init each stream. */\n    if (gettimeofday(&now, NULL) < 0) {\n\ti_errno = IEINITTEST;\n\treturn -1;\n    }\n    SLIST_FOREACH(sp, &test->streams, streams) {\n\tsp->result->start_time = now;\n    }\n\n    if (test->on_test_start)\n        test->on_test_start(test);\n\n    return 0;\n}\n\nstatic void\nsend_timer_proc(TimerClientData client_data, struct timeval *nowP)\n{\n    struct iperf_stream *sp = client_data.p;\n\n    /* All we do here is set or clear the flag saying that this stream may\n    ** be sent to.  The actual sending gets done in the send proc, after\n    ** checking the flag.\n    */\n    iperf_check_throttle(sp, nowP);\n}\n\nint\niperf_create_send_timers(struct iperf_test * test)\n{\n    struct timeval now;\n    struct iperf_stream *sp;\n    TimerClientData cd;\n\n    if (gettimeofday(&now, NULL) < 0) {\n\ti_errno = IEINITTEST;\n\treturn -1;\n    }\n    SLIST_FOREACH(sp, &test->streams, streams) {\n        sp->green_light = 1;\n\tif (test->settings->rate != 0) {\n\t    cd.p = sp;\n\t    sp->send_timer = tmr_create((struct timeval*) 0, send_timer_proc, cd, 100000L, 1);\n\t    /* (Repeat every tenth second - arbitrary often value.) */\n\t    if (sp->send_timer == NULL) {\n\t\ti_errno = IEINITTEST;\n\t\treturn -1;\n\t    }\n\t}\n    }\n    return 0;\n}\n\n/**\n * iperf_exchange_parameters - handles the param_Exchange part for client\n *\n */\n\nint\niperf_exchange_parameters(struct iperf_test *test)\n{\n    int s;\n    int32_t err;\n\n    if (test->role == 'c') {\n\n        if (send_parameters(test) < 0)\n            return -1;\n\n    } else {\n\n        if (get_parameters(test) < 0)\n            return -1;\n\n        if ((s = test->protocol->listen(test)) < 0) {\n\t    if (iperf_set_send_state(test, SERVER_ERROR) != 0)\n                return -1;\n            err = htonl(i_errno);\n            if (Nwrite(test->ctrl_sck, (char*) &err, sizeof(err), Ptcp) < 0) {\n                i_errno = IECTRLWRITE;\n                return -1;\n            }\n            err = htonl(errno);\n            if (Nwrite(test->ctrl_sck, (char*) &err, sizeof(err), Ptcp) < 0) {\n                i_errno = IECTRLWRITE;\n                return -1;\n            }\n            return -1;\n        }\n        FD_SET(s, &test->read_set);\n        test->max_fd = (s > test->max_fd) ? s : test->max_fd;\n        test->prot_listener = s;\n\n        // Send the control message to create streams and start the test\n\tif (iperf_set_send_state(test, CREATE_STREAMS) != 0)\n            return -1;\n\n    }\n\n    return 0;\n}\n\n/*************************************************************/\n\nint\niperf_exchange_results(struct iperf_test *test)\n{\n    if (test->role == 'c') {\n        /* Send results to server. */\n\tif (send_results(test) < 0)\n            return -1;\n        /* Get server results. */\n        if (get_results(test) < 0)\n            return -1;\n    } else {\n        /* Get client results. */\n        if (get_results(test) < 0)\n            return -1;\n        /* Send results to client. */\n\tif (send_results(test) < 0)\n            return -1;\n    }\n    return 0;\n}\n\n/*************************************************************/\n\nstatic int\nsend_parameters(struct iperf_test *test)\n{\n    int r = 0;\n    cJSON *j;\n\n    j = cJSON_CreateObject();\n    if (j == NULL) {\n\ti_errno = IESENDPARAMS;\n\tr = -1;\n    } else {\n\tif (test->protocol->id == Ptcp)\n\t    cJSON_AddTrueToObject(j, \"tcp\");\n\telse if (test->protocol->id == Pudp)\n\t    cJSON_AddTrueToObject(j, \"udp\");\n\tcJSON_AddIntToObject(j, \"omit\", test->omit);\n\tif (test->server_affinity != -1)\n\t    cJSON_AddIntToObject(j, \"server_affinity\", test->server_affinity);\n\tif (test->duration)\n\t    cJSON_AddIntToObject(j, \"time\", test->duration);\n\tif (test->settings->bytes)\n\t    cJSON_AddIntToObject(j, \"num\", test->settings->bytes);\n\tif (test->settings->blocks)\n\t    cJSON_AddIntToObject(j, \"blockcount\", test->settings->blocks);\n\tif (test->settings->mss)\n\t    cJSON_AddIntToObject(j, \"MSS\", test->settings->mss);\n\tif (test->no_delay)\n\t    cJSON_AddTrueToObject(j, \"nodelay\");\n\tcJSON_AddIntToObject(j, \"parallel\", test->num_streams);\n\tif (test->reverse)\n\t    cJSON_AddTrueToObject(j, \"reverse\");\n\tif (test->settings->socket_bufsize)\n\t    cJSON_AddIntToObject(j, \"window\", test->settings->socket_bufsize);\n\tif (test->settings->blksize)\n\t    cJSON_AddIntToObject(j, \"len\", test->settings->blksize);\n\tif (test->settings->rate)\n\t    cJSON_AddIntToObject(j, \"bandwidth\", test->settings->rate);\n\tif (test->settings->burst)\n\t    cJSON_AddIntToObject(j, \"burst\", test->settings->burst);\n\tif (test->settings->tos)\n\t    cJSON_AddIntToObject(j, \"TOS\", test->settings->tos);\n\tif (test->settings->flowlabel)\n\t    cJSON_AddIntToObject(j, \"flowlabel\", test->settings->flowlabel);\n\tif (test->title)\n\t    cJSON_AddStringToObject(j, \"title\", test->title);\n\tif (test->congestion)\n\t    cJSON_AddStringToObject(j, \"congestion\", test->congestion);\n\tif (test->get_server_output)\n\t    cJSON_AddIntToObject(j, \"get_server_output\", iperf_get_test_get_server_output(test));\n\n\tif (test->debug) {\n\t    printf(\"send_parameters:\\n%s\\n\", cJSON_Print(j));\n\t}\n\n\tif (JSON_write(test->ctrl_sck, j) < 0) {\n\t    i_errno = IESENDPARAMS;\n\t    r = -1;\n\t}\n\tcJSON_Delete(j);\n    }\n    return r;\n}\n\n/*************************************************************/\n\nstatic int\nget_parameters(struct iperf_test *test)\n{\n    int r = 0;\n    cJSON *j;\n    cJSON *j_p;\n\n    j = JSON_read(test->ctrl_sck);\n    if (j == NULL) {\n\ti_errno = IERECVPARAMS;\n        r = -1;\n    } else {\n\tif (test->debug) {\n\t    printf(\"get_parameters:\\n%s\\n\", cJSON_Print(j));\n\t}\n\n\tif ((j_p = cJSON_GetObjectItem(j, \"tcp\")) != NULL)\n\t    set_protocol(test, Ptcp);\n\tif ((j_p = cJSON_GetObjectItem(j, \"udp\")) != NULL)\n\t    set_protocol(test, Pudp);\n\tif ((j_p = cJSON_GetObjectItem(j, \"omit\")) != NULL)\n\t    test->omit = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"server_affinity\")) != NULL)\n\t    test->server_affinity = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"time\")) != NULL)\n\t    test->duration = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"num\")) != NULL)\n\t    test->settings->bytes = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"blockcount\")) != NULL)\n\t    test->settings->blocks = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"MSS\")) != NULL)\n\t    test->settings->mss = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"nodelay\")) != NULL)\n\t    test->no_delay = 1;\n\tif ((j_p = cJSON_GetObjectItem(j, \"parallel\")) != NULL)\n\t    test->num_streams = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"reverse\")) != NULL)\n\t    iperf_set_test_reverse(test, 1);\n\tif ((j_p = cJSON_GetObjectItem(j, \"window\")) != NULL)\n\t    test->settings->socket_bufsize = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"len\")) != NULL)\n\t    test->settings->blksize = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"bandwidth\")) != NULL)\n\t    test->settings->rate = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"burst\")) != NULL)\n\t    test->settings->burst = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"TOS\")) != NULL)\n\t    test->settings->tos = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"flowlabel\")) != NULL)\n\t    test->settings->flowlabel = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"title\")) != NULL)\n\t    test->title = strdup(j_p->valuestring);\n\tif ((j_p = cJSON_GetObjectItem(j, \"congestion\")) != NULL)\n\t    test->congestion = strdup(j_p->valuestring);\n\tif ((j_p = cJSON_GetObjectItem(j, \"get_server_output\")) != NULL)\n\t    iperf_set_test_get_server_output(test, 1);\n\tif (test->sender && test->protocol->id == Ptcp && has_tcpinfo_retransmits())\n\t    test->sender_has_retransmits = 1;\n\tcJSON_Delete(j);\n    }\n    return r;\n}\n\n/*************************************************************/\n\nstatic int\nsend_results(struct iperf_test *test)\n{\n    int r = 0;\n    cJSON *j;\n    cJSON *j_streams;\n    struct iperf_stream *sp;\n    cJSON *j_stream;\n    int sender_has_retransmits;\n    iperf_size_t bytes_transferred;\n    int retransmits;\n\n    j = cJSON_CreateObject();\n    if (j == NULL) {\n\ti_errno = IEPACKAGERESULTS;\n\tr = -1;\n    } else {\n\tcJSON_AddFloatToObject(j, \"cpu_util_total\", test->cpu_util[0]);\n\tcJSON_AddFloatToObject(j, \"cpu_util_user\", test->cpu_util[1]);\n\tcJSON_AddFloatToObject(j, \"cpu_util_system\", test->cpu_util[2]);\n\tif ( ! test->sender )\n\t    sender_has_retransmits = -1;\n\telse\n\t    sender_has_retransmits = test->sender_has_retransmits;\n\tcJSON_AddIntToObject(j, \"sender_has_retransmits\", sender_has_retransmits);\n\n\t/* If on the server and sending server output, then do this */\n\tif (test->role == 's' && test->get_server_output) {\n\t    if (test->json_output) {\n\t\t/* Add JSON output */\n\t\tcJSON_AddItemReferenceToObject(j, \"server_output_json\", test->json_top);\n\t    }\n\t    else {\n\t\t/* Add textual output */\n\t\tsize_t buflen = 0;\n\n\t\t/* Figure out how much room we need to hold the complete output string */\n\t\tstruct iperf_textline *t;\n\t\tTAILQ_FOREACH(t, &(test->server_output_list), textlineentries) {\n\t\t    buflen += strlen(t->line);\n\t\t}\n\n\t\t/* Allocate and build it up from the component lines */\n\t\tchar *output = calloc(buflen + 1, 1);\n\t\tTAILQ_FOREACH(t, &(test->server_output_list), textlineentries) {\n\t\t    strncat(output, t->line, buflen);\n\t\t    buflen -= strlen(t->line);\n\t\t}\n\n\t\tcJSON_AddStringToObject(j, \"server_output_text\", output);\n\t    }\n\t}\n\n\tj_streams = cJSON_CreateArray();\n\tif (j_streams == NULL) {\n\t    i_errno = IEPACKAGERESULTS;\n\t    r = -1;\n\t} else {\n\t    cJSON_AddItemToObject(j, \"streams\", j_streams);\n\t    SLIST_FOREACH(sp, &test->streams, streams) {\n\t\tj_stream = cJSON_CreateObject();\n\t\tif (j_stream == NULL) {\n\t\t    i_errno = IEPACKAGERESULTS;\n\t\t    r = -1;\n\t\t} else {\n\t\t    cJSON_AddItemToArray(j_streams, j_stream);\n\t\t    bytes_transferred = test->sender ? sp->result->bytes_sent : sp->result->bytes_received;\n\t\t    retransmits = (test->sender && test->sender_has_retransmits) ? sp->result->stream_retrans : -1;\n\t\t    cJSON_AddIntToObject(j_stream, \"id\", sp->id);\n\t\t    cJSON_AddIntToObject(j_stream, \"bytes\", bytes_transferred);\n\t\t    cJSON_AddIntToObject(j_stream, \"retransmits\", retransmits);\n\t\t    cJSON_AddFloatToObject(j_stream, \"jitter\", sp->jitter);\n\t\t    cJSON_AddIntToObject(j_stream, \"errors\", sp->cnt_error);\n\t\t    cJSON_AddIntToObject(j_stream, \"packets\", sp->packet_count);\n\t\t}\n\t    }\n\t    if (r == 0 && test->debug) {\n\t\tprintf(\"send_results\\n%s\\n\", cJSON_Print(j));\n\t    }\n\t    if (r == 0 && JSON_write(test->ctrl_sck, j) < 0) {\n\t\ti_errno = IESENDRESULTS;\n\t\tr = -1;\n\t    }\n\t}\n\tcJSON_Delete(j);\n    }\n    return r;\n}\n\n/*************************************************************/\n\nstatic int\nget_results(struct iperf_test *test)\n{\n    int r = 0;\n    cJSON *j;\n    cJSON *j_cpu_util_total;\n    cJSON *j_cpu_util_user;\n    cJSON *j_cpu_util_system;\n    cJSON *j_sender_has_retransmits;\n    int result_has_retransmits;\n    cJSON *j_streams;\n    int n, i;\n    cJSON *j_stream;\n    cJSON *j_id;\n    cJSON *j_bytes;\n    cJSON *j_retransmits;\n    cJSON *j_jitter;\n    cJSON *j_errors;\n    cJSON *j_packets;\n    cJSON *j_server_output;\n    int sid, cerror, pcount;\n    double jitter;\n    iperf_size_t bytes_transferred;\n    int retransmits;\n    struct iperf_stream *sp;\n\n    j = JSON_read(test->ctrl_sck);\n    if (j == NULL) {\n\ti_errno = IERECVRESULTS;\n        r = -1;\n    } else {\n\tj_cpu_util_total = cJSON_GetObjectItem(j, \"cpu_util_total\");\n\tj_cpu_util_user = cJSON_GetObjectItem(j, \"cpu_util_user\");\n\tj_cpu_util_system = cJSON_GetObjectItem(j, \"cpu_util_system\");\n\tj_sender_has_retransmits = cJSON_GetObjectItem(j, \"sender_has_retransmits\");\n\tif (j_cpu_util_total == NULL || j_cpu_util_user == NULL || j_cpu_util_system == NULL || j_sender_has_retransmits == NULL) {\n\t    i_errno = IERECVRESULTS;\n\t    r = -1;\n\t} else {\n\t    if (test->debug) {\n\t\tprintf(\"get_results\\n%s\\n\", cJSON_Print(j));\n\t    }\n\n\t    test->remote_cpu_util[0] = j_cpu_util_total->valuefloat;\n\t    test->remote_cpu_util[1] = j_cpu_util_user->valuefloat;\n\t    test->remote_cpu_util[2] = j_cpu_util_system->valuefloat;\n\t    result_has_retransmits = j_sender_has_retransmits->valueint;\n\t    if (! test->sender)\n\t\ttest->sender_has_retransmits = result_has_retransmits;\n\t    j_streams = cJSON_GetObjectItem(j, \"streams\");\n\t    if (j_streams == NULL) {\n\t\ti_errno = IERECVRESULTS;\n\t\tr = -1;\n\t    } else {\n\t        n = cJSON_GetArraySize(j_streams);\n\t\tfor (i=0; i<n; ++i) {\n\t\t    j_stream = cJSON_GetArrayItem(j_streams, i);\n\t\t    if (j_stream == NULL) {\n\t\t\ti_errno = IERECVRESULTS;\n\t\t\tr = -1;\n\t\t    } else {\n\t\t\tj_id = cJSON_GetObjectItem(j_stream, \"id\");\n\t\t\tj_bytes = cJSON_GetObjectItem(j_stream, \"bytes\");\n\t\t\tj_retransmits = cJSON_GetObjectItem(j_stream, \"retransmits\");\n\t\t\tj_jitter = cJSON_GetObjectItem(j_stream, \"jitter\");\n\t\t\tj_errors = cJSON_GetObjectItem(j_stream, \"errors\");\n\t\t\tj_packets = cJSON_GetObjectItem(j_stream, \"packets\");\n\t\t\tif (j_id == NULL || j_bytes == NULL || j_retransmits == NULL || j_jitter == NULL || j_errors == NULL || j_packets == NULL) {\n\t\t\t    i_errno = IERECVRESULTS;\n\t\t\t    r = -1;\n\t\t\t} else {\n\t\t\t    sid = j_id->valueint;\n\t\t\t    bytes_transferred = j_bytes->valueint;\n\t\t\t    retransmits = j_retransmits->valueint;\n\t\t\t    jitter = j_jitter->valuefloat;\n\t\t\t    cerror = j_errors->valueint;\n\t\t\t    pcount = j_packets->valueint;\n\t\t\t    SLIST_FOREACH(sp, &test->streams, streams)\n\t\t\t\tif (sp->id == sid) break;\n\t\t\t    if (sp == NULL) {\n\t\t\t\ti_errno = IESTREAMID;\n\t\t\t\tr = -1;\n\t\t\t    } else {\n\t\t\t\tif (test->sender) {\n\t\t\t\t    sp->jitter = jitter;\n\t\t\t\t    sp->cnt_error = cerror;\n\t\t\t\t    sp->packet_count = pcount;\n\t\t\t\t    sp->result->bytes_received = bytes_transferred;\n\t\t\t\t} else {\n\t\t\t\t    sp->result->bytes_sent = bytes_transferred;\n\t\t\t\t    sp->result->stream_retrans = retransmits;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t\t/*\n\t\t * If we're the client and we're supposed to get remote results,\n\t\t * look them up and process accordingly.\n\t\t */\n\t\tif (test->role == 'c' && iperf_get_test_get_server_output(test)) {\n\t\t    /* Look for JSON.  If we find it, grab the object so it doesn't get deleted. */\n\t\t    j_server_output = cJSON_DetachItemFromObject(j, \"server_output_json\");\n\t\t    if (j_server_output != NULL) {\n\t\t\ttest->json_server_output = j_server_output;\n\t\t    }\n\t\t    else {\n\t\t\t/* No JSON, look for textual output.  Make a copy of the text for later. */\n\t\t\tj_server_output = cJSON_GetObjectItem(j, \"server_output_text\");\n\t\t\tif (j_server_output != NULL) {\n\t\t\t    test->server_output_text = strdup(j_server_output->valuestring);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tcJSON_Delete(j);\n    }\n    return r;\n}\n\n/*************************************************************/\n\nstatic int\nJSON_write(int fd, cJSON *json)\n{\n    uint32_t hsize, nsize;\n    char *str;\n    int r = 0;\n\n    str = cJSON_PrintUnformatted(json);\n    if (str == NULL)\n\tr = -1;\n    else {\n\thsize = strlen(str);\n\tnsize = htonl(hsize);\n\tif (Nwrite(fd, (char*) &nsize, sizeof(nsize), Ptcp) < 0)\n\t    r = -1;\n\telse {\n\t    if (Nwrite(fd, str, hsize, Ptcp) < 0)\n\t\tr = -1;\n\t}\n\tfree(str);\n    }\n    return r;\n}\n\n/*************************************************************/\n\nstatic cJSON *\nJSON_read(int fd)\n{\n    uint32_t hsize, nsize;\n    char *str;\n    cJSON *json = NULL;\n\n    if (Nread(fd, (char*) &nsize, sizeof(nsize), Ptcp) >= 0) {\n\thsize = ntohl(nsize);\n\tstr = (char *) malloc(hsize+1);\t/* +1 for EOS */\n\tif (str != NULL) {\n\t    if (Nread(fd, str, hsize, Ptcp) >= 0) {\n\t\tstr[hsize] = '\\0';\t/* add the EOS */\n\t\tjson = cJSON_Parse(str);\n\t    }\n\t}\n\tfree(str);\n    }\n    return json;\n}\n\n/*************************************************************/\n/**\n * add_to_interval_list -- adds new interval to the interval_list\n */\n\nvoid\nadd_to_interval_list(struct iperf_stream_result * rp, struct iperf_interval_results * new)\n{\n    struct iperf_interval_results *irp;\n\n    irp = (struct iperf_interval_results *) malloc(sizeof(struct iperf_interval_results));\n    memcpy(irp, new, sizeof(struct iperf_interval_results));\n    TAILQ_INSERT_TAIL(&rp->interval_results, irp, irlistentries);\n}\n\n\n/************************************************************/\n\n/**\n * connect_msg -- displays connection message\n * denoting sender/receiver details\n *\n */\n\nvoid\nconnect_msg(struct iperf_stream *sp)\n{\n    char ipl[INET6_ADDRSTRLEN], ipr[INET6_ADDRSTRLEN];\n    int lport, rport;\n\n    if (getsockdomain(sp->socket) == AF_INET) {\n        inet_ntop(AF_INET, (void *) &((struct sockaddr_in *) &sp->local_addr)->sin_addr, ipl, sizeof(ipl));\n\tmapped_v4_to_regular_v4(ipl);\n        inet_ntop(AF_INET, (void *) &((struct sockaddr_in *) &sp->remote_addr)->sin_addr, ipr, sizeof(ipr));\n\tmapped_v4_to_regular_v4(ipr);\n        lport = ntohs(((struct sockaddr_in *) &sp->local_addr)->sin_port);\n        rport = ntohs(((struct sockaddr_in *) &sp->remote_addr)->sin_port);\n    } else {\n        inet_ntop(AF_INET6, (void *) &((struct sockaddr_in6 *) &sp->local_addr)->sin6_addr, ipl, sizeof(ipl));\n\tmapped_v4_to_regular_v4(ipl);\n        inet_ntop(AF_INET6, (void *) &((struct sockaddr_in6 *) &sp->remote_addr)->sin6_addr, ipr, sizeof(ipr));\n\tmapped_v4_to_regular_v4(ipr);\n        lport = ntohs(((struct sockaddr_in6 *) &sp->local_addr)->sin6_port);\n        rport = ntohs(((struct sockaddr_in6 *) &sp->remote_addr)->sin6_port);\n    }\n\n    if (sp->test->json_output)\n        cJSON_AddItemToArray(sp->test->json_connected, iperf_json_printf(\"socket: %d  local_host: %s  local_port: %d  remote_host: %s  remote_port: %d\", (int64_t) sp->socket, ipl, (int64_t) lport, ipr, (int64_t) rport));\n    else\n\tiprintf(sp->test, report_connected, sp->socket, ipl, lport, ipr, rport);\n}\n\n\n/**************************************************************************/\n\nstruct iperf_test *\niperf_new_test()\n{\n    struct iperf_test *test;\n\n    test = (struct iperf_test *) malloc(sizeof(struct iperf_test));\n    if (!test) {\n        i_errno = IENEWTEST;\n        return NULL;\n    }\n    /* initialize everything to zero */\n    memset(test, 0, sizeof(struct iperf_test));\n\n    test->settings = (struct iperf_settings *) malloc(sizeof(struct iperf_settings));\n    if (!test->settings) {\n        free(test);\n\ti_errno = IENEWTEST;\n\treturn NULL;\n    }\n    memset(test->settings, 0, sizeof(struct iperf_settings));\n\n    return test;\n}\n\n/**************************************************************************/\nint\niperf_defaults(struct iperf_test *testp)\n{\n    struct protocol *tcp, *udp;\n\n    testp->omit = OMIT;\n    testp->duration = DURATION;\n    testp->diskfile_name = (char*) 0;\n    testp->affinity = -1;\n    testp->server_affinity = -1;\n    testp->title = NULL;\n    testp->congestion = NULL;\n    testp->server_port = PORT;\n    testp->ctrl_sck = -1;\n    testp->prot_listener = -1;\n\n    testp->stats_callback = iperf_stats_callback;\n    testp->reporter_callback = iperf_reporter_callback;\n\n    testp->stats_interval = testp->reporter_interval = 1;\n    testp->num_streams = 1;\n\n    testp->settings->domain = AF_UNSPEC;\n    testp->settings->unit_format = 'a';\n    testp->settings->socket_bufsize = 0;    /* use autotuning */\n    testp->settings->blksize = DEFAULT_TCP_BLKSIZE;\n    testp->settings->rate = 0;\n    testp->settings->burst = 0;\n    testp->settings->mss = 0;\n    testp->settings->bytes = 0;\n    testp->settings->blocks = 0;\n    memset(testp->cookie, 0, COOKIE_SIZE);\n\n    testp->multisend = 10;\t/* arbitrary */\n\n    /* Set up protocol list */\n    SLIST_INIT(&testp->streams);\n    SLIST_INIT(&testp->protocols);\n\n    tcp = (struct protocol *) malloc(sizeof(struct protocol));\n    if (!tcp)\n        return -1;\n    memset(tcp, 0, sizeof(struct protocol));\n    udp = (struct protocol *) malloc(sizeof(struct protocol));\n    if (!udp) {\n        free(tcp);\n        return -1;\n    }\n    memset(udp, 0, sizeof(struct protocol));\n\n    tcp->id = Ptcp;\n    tcp->name = \"TCP\";\n    tcp->accept = iperf_tcp_accept;\n    tcp->listen = iperf_tcp_listen;\n    tcp->connect = iperf_tcp_connect;\n    tcp->send = iperf_tcp_send;\n    tcp->recv = iperf_tcp_recv;\n    tcp->init = NULL;\n    SLIST_INSERT_HEAD(&testp->protocols, tcp, protocols);\n\n    udp->id = Pudp;\n    udp->name = \"UDP\";\n    udp->accept = iperf_udp_accept;\n    udp->listen = iperf_udp_listen;\n    udp->connect = iperf_udp_connect;\n    udp->send = iperf_udp_send;\n    udp->recv = iperf_udp_recv;\n    udp->init = iperf_udp_init;\n    SLIST_INSERT_AFTER(tcp, udp, protocols);\n\n    set_protocol(testp, Ptcp);\n\n    testp->on_new_stream = iperf_on_new_stream;\n    testp->on_test_start = iperf_on_test_start;\n    testp->on_connect = iperf_on_connect;\n    testp->on_test_finish = iperf_on_test_finish;\n\n    TAILQ_INIT(&testp->server_output_list);\n\n    return 0;\n}\n\n\n/**************************************************************************/\nvoid\niperf_free_test(struct iperf_test *test)\n{\n    struct protocol *prot;\n    struct iperf_stream *sp;\n\n    /* Free streams */\n    while (!SLIST_EMPTY(&test->streams)) {\n        sp = SLIST_FIRST(&test->streams);\n        SLIST_REMOVE_HEAD(&test->streams, streams);\n        iperf_free_stream(sp);\n    }\n\n    if (test->server_hostname)\n\tfree(test->server_hostname);\n    if (test->bind_address)\n\tfree(test->bind_address);\n    free(test->settings);\n    if (test->title)\n\tfree(test->title);\n    if (test->congestion)\n\tfree(test->congestion);\n    if (test->omit_timer != NULL)\n\ttmr_cancel(test->omit_timer);\n    if (test->timer != NULL)\n\ttmr_cancel(test->timer);\n    if (test->stats_timer != NULL)\n\ttmr_cancel(test->stats_timer);\n    if (test->reporter_timer != NULL)\n\ttmr_cancel(test->reporter_timer);\n\n    /* Free protocol list */\n    while (!SLIST_EMPTY(&test->protocols)) {\n        prot = SLIST_FIRST(&test->protocols);\n        SLIST_REMOVE_HEAD(&test->protocols, protocols);        \n        free(prot);\n    }\n\n    if (test->server_output_text) {\n\tfree(test->server_output_text);\n\ttest->server_output_text = NULL;\n    }\n\n    /* Free output line buffers, if any (on the server only) */\n    struct iperf_textline *t;\n    while (!TAILQ_EMPTY(&test->server_output_list)) {\n\tt = TAILQ_FIRST(&test->server_output_list);\n\tTAILQ_REMOVE(&test->server_output_list, t, textlineentries);\n\tfree(t->line);\n\tfree(t);\n    }\n\n    /* XXX: Why are we setting these values to NULL? */\n    // test->streams = NULL;\n    test->stats_callback = NULL;\n    test->reporter_callback = NULL;\n    free(test);\n}\n\n\nvoid\niperf_reset_test(struct iperf_test *test)\n{\n    struct iperf_stream *sp;\n\n    /* Free streams */\n    while (!SLIST_EMPTY(&test->streams)) {\n        sp = SLIST_FIRST(&test->streams);\n        SLIST_REMOVE_HEAD(&test->streams, streams);\n        iperf_free_stream(sp);\n    }\n    if (test->omit_timer != NULL) {\n\ttmr_cancel(test->omit_timer);\n\ttest->omit_timer = NULL;\n    }\n    if (test->timer != NULL) {\n\ttmr_cancel(test->timer);\n\ttest->timer = NULL;\n    }\n    if (test->stats_timer != NULL) {\n\ttmr_cancel(test->stats_timer);\n\ttest->stats_timer = NULL;\n    }\n    if (test->reporter_timer != NULL) {\n\ttmr_cancel(test->reporter_timer);\n\ttest->reporter_timer = NULL;\n    }\n    test->done = 0;\n\n    SLIST_INIT(&test->streams);\n\n    test->role = 's';\n    test->sender = 0;\n    test->sender_has_retransmits = 0;\n    set_protocol(test, Ptcp);\n    test->omit = OMIT;\n    test->duration = DURATION;\n    test->server_affinity = -1;\n    test->state = 0;\n    \n    test->ctrl_sck = -1;\n    test->prot_listener = -1;\n\n    test->bytes_sent = 0;\n    test->blocks_sent = 0;\n\n    test->reverse = 0;\n    test->no_delay = 0;\n\n    FD_ZERO(&test->read_set);\n    FD_ZERO(&test->write_set);\n    \n    test->num_streams = 1;\n    test->settings->socket_bufsize = 0;\n    test->settings->blksize = DEFAULT_TCP_BLKSIZE;\n    test->settings->rate = 0;\n    test->settings->burst = 0;\n    test->settings->mss = 0;\n    memset(test->cookie, 0, COOKIE_SIZE);\n    test->multisend = 10;\t/* arbitrary */\n\n    /* Free output line buffers, if any (on the server only) */\n    struct iperf_textline *t;\n    while (!TAILQ_EMPTY(&test->server_output_list)) {\n\tt = TAILQ_FIRST(&test->server_output_list);\n\tTAILQ_REMOVE(&test->server_output_list, t, textlineentries);\n\tfree(t->line);\n\tfree(t);\n    }\n}\n\n\n/* Reset all of a test's stats back to zero.  Called when the omitting\n** period is over.\n*/\nvoid\niperf_reset_stats(struct iperf_test *test)\n{\n    struct timeval now;\n    struct iperf_stream *sp;\n    struct iperf_stream_result *rp;\n\n    test->bytes_sent = 0;\n    test->blocks_sent = 0;\n    gettimeofday(&now, NULL);\n    SLIST_FOREACH(sp, &test->streams, streams) {\n\tsp->omitted_packet_count = sp->packet_count;\n\tsp->jitter = 0;\n\tsp->outoforder_packets = 0;\n\tsp->cnt_error = 0;\n\trp = sp->result;\n        rp->bytes_sent = rp->bytes_received = 0;\n        rp->bytes_sent_this_interval = rp->bytes_received_this_interval = 0;\n\tif (test->sender && test->sender_has_retransmits) {\n\t    struct iperf_interval_results ir; /* temporary results structure */\n\t    save_tcpinfo(sp, &ir);\n\t    rp->stream_prev_total_retrans = get_total_retransmits(&ir);\n\t}\n\trp->stream_retrans = 0;\n\trp->start_time = now;\n    }\n}\n\n\n/**************************************************************************/\n\n/**\n * iperf_stats_callback -- handles the statistic gathering for both the client and server\n *\n * XXX: This function needs to be updated to reflect the new code\n */\n\n\nvoid\niperf_stats_callback(struct iperf_test *test)\n{\n    struct iperf_stream *sp;\n    struct iperf_stream_result *rp = NULL;\n    struct iperf_interval_results *irp, temp;\n\n    temp.omitted = test->omitting;\n    SLIST_FOREACH(sp, &test->streams, streams) {\n        rp = sp->result;\n\n\ttemp.bytes_transferred = test->sender ? rp->bytes_sent_this_interval : rp->bytes_received_this_interval;\n     \n\tirp = TAILQ_LAST(&rp->interval_results, irlisthead);\n        /* result->end_time contains timestamp of previous interval */\n        if ( irp != NULL ) /* not the 1st interval */\n            memcpy(&temp.interval_start_time, &rp->end_time, sizeof(struct timeval));\n        else /* or use timestamp from beginning */\n            memcpy(&temp.interval_start_time, &rp->start_time, sizeof(struct timeval));\n        /* now save time of end of this interval */\n        gettimeofday(&rp->end_time, NULL);\n        memcpy(&temp.interval_end_time, &rp->end_time, sizeof(struct timeval));\n        temp.interval_duration = timeval_diff(&temp.interval_start_time, &temp.interval_end_time);\n        //temp.interval_duration = timeval_diff(&temp.interval_start_time, &temp.interval_end_time);\n\tif (test->protocol->id == Ptcp) {\n\t    if ( has_tcpinfo()) {\n\t\tsave_tcpinfo(sp, &temp);\n\t\tif (test->sender && test->sender_has_retransmits) {\n\t\t    long total_retrans = get_total_retransmits(&temp);\n\t\t    temp.interval_retrans = total_retrans - rp->stream_prev_total_retrans;\n\t\t    rp->stream_retrans += temp.interval_retrans;\n\t\t    rp->stream_prev_total_retrans = total_retrans;\n\n\t\t    temp.snd_cwnd = get_snd_cwnd(&temp);\n\t\t}\n\t    }\n\t} else {\n\t    if (irp == NULL) {\n\t\ttemp.interval_packet_count = sp->packet_count;\n\t\ttemp.interval_outoforder_packets = sp->outoforder_packets;\n\t\ttemp.interval_cnt_error = sp->cnt_error;\n\t    } else {\n\t\ttemp.interval_packet_count = sp->packet_count - irp->packet_count;\n\t\ttemp.interval_outoforder_packets = sp->outoforder_packets - irp->outoforder_packets;\n\t\ttemp.interval_cnt_error = sp->cnt_error - irp->cnt_error;\n\t    }\n\t    temp.packet_count = sp->packet_count;\n\t    temp.jitter = sp->jitter;\n\t    temp.outoforder_packets = sp->outoforder_packets;\n\t    temp.cnt_error = sp->cnt_error;\n\t}\n        add_to_interval_list(rp, &temp);\n        rp->bytes_sent_this_interval = rp->bytes_received_this_interval = 0;\n    }\n}\n\nstatic void\niperf_print_intermediate(struct iperf_test *test)\n{\n    char ubuf[UNIT_LEN];\n    char nbuf[UNIT_LEN];\n    struct iperf_stream *sp = NULL;\n    struct iperf_interval_results *irp;\n    iperf_size_t bytes = 0;\n    double bandwidth;\n    int retransmits = 0;\n    double start_time, end_time;\n    cJSON *json_interval;\n    cJSON *json_interval_streams;\n    int total_packets = 0, lost_packets = 0;\n    double avg_jitter = 0.0, lost_percent;\n\n    if (test->json_output) {\n        json_interval = cJSON_CreateObject();\n\tif (json_interval == NULL)\n\t    return;\n\tcJSON_AddItemToArray(test->json_intervals, json_interval);\n        json_interval_streams = cJSON_CreateArray();\n\tif (json_interval_streams == NULL)\n\t    return;\n\tcJSON_AddItemToObject(json_interval, \"streams\", json_interval_streams);\n    } else {\n        json_interval = NULL;\n        json_interval_streams = NULL;\n    }\n\n    SLIST_FOREACH(sp, &test->streams, streams) {\n        print_interval_results(test, sp, json_interval_streams);\n\t/* sum up all streams */\n\tirp = TAILQ_LAST(&sp->result->interval_results, irlisthead);\n\tif (irp == NULL) {\n\t    iperf_err(test, \"iperf_print_intermediate error: interval_results is NULL\");\n\t    return;\n\t}\n        bytes += irp->bytes_transferred;\n\tif (test->protocol->id == Ptcp) {\n\t    if (test->sender && test->sender_has_retransmits) {\n\t\tretransmits += irp->interval_retrans;\n\t    }\n\t} else {\n            total_packets += irp->interval_packet_count;\n            lost_packets += irp->interval_cnt_error;\n            avg_jitter += irp->jitter;\n\t}\n    }\n\n    /* next build string with sum of all streams */\n    if (test->num_streams > 1 || test->json_output) {\n        sp = SLIST_FIRST(&test->streams); /* reset back to 1st stream */\n\t/* Only do this of course if there was a first stream */\n\tif (sp) {\n        irp = TAILQ_LAST(&sp->result->interval_results, irlisthead);    /* use 1st stream for timing info */\n\n        unit_snprintf(ubuf, UNIT_LEN, (double) bytes, 'A');\n\tbandwidth = (double) bytes / (double) irp->interval_duration;\n        unit_snprintf(nbuf, UNIT_LEN, bandwidth, test->settings->unit_format);\n\n        start_time = timeval_diff(&sp->result->start_time,&irp->interval_start_time);\n        end_time = timeval_diff(&sp->result->start_time,&irp->interval_end_time);\n\tif (test->protocol->id == Ptcp) {\n\t    if (test->sender && test->sender_has_retransmits) {\n\t\t/* Interval sum, TCP with retransmits. */\n\t\tif (test->json_output)\n\t\t    cJSON_AddItemToObject(json_interval, \"sum\", iperf_json_printf(\"start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  retransmits: %d  omitted: %b\", (double) start_time, (double) end_time, (double) irp->interval_duration, (int64_t) bytes, bandwidth * 8, (int64_t) retransmits, irp->omitted)); /* XXX irp->omitted or test->omitting? */\n\t\telse\n\t\t    iprintf(test, report_sum_bw_retrans_format, start_time, end_time, ubuf, nbuf, retransmits, irp->omitted?report_omitted:\"\"); /* XXX irp->omitted or test->omitting? */\n\t    } else {\n\t\t/* Interval sum, TCP without retransmits. */\n\t\tif (test->json_output)\n\t\t    cJSON_AddItemToObject(json_interval, \"sum\", iperf_json_printf(\"start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  omitted: %b\", (double) start_time, (double) end_time, (double) irp->interval_duration, (int64_t) bytes, bandwidth * 8, test->omitting));\n\t\telse\n\t\t    iprintf(test, report_sum_bw_format, start_time, end_time, ubuf, nbuf, test->omitting?report_omitted:\"\");\n\t    }\n\t} else {\n\t    /* Interval sum, UDP. */\n\t    if (test->sender) {\n\t\tif (test->json_output)\n\t\t    cJSON_AddItemToObject(json_interval, \"sum\", iperf_json_printf(\"start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  packets: %d  omitted: %b\", (double) start_time, (double) end_time, (double) irp->interval_duration, (int64_t) bytes, bandwidth * 8, (int64_t) total_packets, test->omitting));\n\t\telse\n\t\t    iprintf(test, report_sum_bw_udp_sender_format, start_time, end_time, ubuf, nbuf, total_packets, test->omitting?report_omitted:\"\");\n\t    } else {\n\t\tavg_jitter /= test->num_streams;\n\t\tlost_percent = 100.0 * lost_packets / total_packets;\n\t\tif (test->json_output)\n\t\t    cJSON_AddItemToObject(json_interval, \"sum\", iperf_json_printf(\"start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  jitter_ms: %f  lost_packets: %d  packets: %d  lost_percent: %f  omitted: %b\", (double) start_time, (double) end_time, (double) irp->interval_duration, (int64_t) bytes, bandwidth * 8, (double) avg_jitter * 1000.0, (int64_t) lost_packets, (int64_t) total_packets, (double) lost_percent, test->omitting));\n\t\telse\n\t\t    iprintf(test, report_sum_bw_udp_format, start_time, end_time, ubuf, nbuf, avg_jitter * 1000.0, lost_packets, total_packets, lost_percent, test->omitting?report_omitted:\"\");\n\t    }\n\t}\n\t}\n    }\n}\n\nstatic void\niperf_print_results(struct iperf_test *test)\n{\n\n    cJSON *json_summary_streams = NULL;\n    cJSON *json_summary_stream = NULL;\n    int total_retransmits = 0;\n    int total_packets = 0, lost_packets = 0;\n    char ubuf[UNIT_LEN];\n    char nbuf[UNIT_LEN];\n    struct stat sb;\n    char sbuf[UNIT_LEN];\n    struct iperf_stream *sp = NULL;\n    iperf_size_t bytes_sent, total_sent = 0;\n    iperf_size_t bytes_received, total_received = 0;\n    double start_time, end_time, avg_jitter = 0.0, lost_percent;\n    double bandwidth;\n\n    /* print final summary for all intervals */\n\n    if (test->json_output) {\n        json_summary_streams = cJSON_CreateArray();\n\tif (json_summary_streams == NULL)\n\t    return;\n\tcJSON_AddItemToObject(test->json_end, \"streams\", json_summary_streams);\n    } else {\n\tiprintf(test, \"%s\", report_bw_separator);\n\tif (test->verbose)\n\t    iprintf(test, \"%s\", report_summary);\n\tif (test->protocol->id == Ptcp) {\n\t    if (test->sender_has_retransmits)\n\t\tiprintf(test, \"%s\", report_bw_retrans_header);\n\t    else\n\t\tiprintf(test, \"%s\", report_bw_header);\n\t} else\n\t    iprintf(test, \"%s\", report_bw_udp_header);\n    }\n\n    start_time = 0.;\n    sp = SLIST_FIRST(&test->streams);\n    /* \n     * If there is at least one stream, then figure out the length of time\n     * we were running the tests and print out some statistics about\n     * the streams.  It's possible to not have any streams at all\n     * if the client got interrupted before it got to do anything.\n     */\n    if (sp) {\n    end_time = timeval_diff(&sp->result->start_time, &sp->result->end_time);\n    SLIST_FOREACH(sp, &test->streams, streams) {\n\tif (test->json_output) {\n\t    json_summary_stream = cJSON_CreateObject();\n\t    if (json_summary_stream == NULL)\n\t\treturn;\n\t    cJSON_AddItemToArray(json_summary_streams, json_summary_stream);\n\t}\n\n        bytes_sent = sp->result->bytes_sent;\n        bytes_received = sp->result->bytes_received;\n        total_sent += bytes_sent;\n        total_received += bytes_received;\n\n        if (test->protocol->id == Ptcp) {\n\t    if (test->sender_has_retransmits) {\n\t\ttotal_retransmits += sp->result->stream_retrans;\n\t    }\n\t} else {\n            total_packets += (sp->packet_count - sp->omitted_packet_count);\n            lost_packets += sp->cnt_error;\n            avg_jitter += sp->jitter;\n        }\n\n\tunit_snprintf(ubuf, UNIT_LEN, (double) bytes_sent, 'A');\n\tbandwidth = (double) bytes_sent / (double) end_time;\n\tunit_snprintf(nbuf, UNIT_LEN, bandwidth, test->settings->unit_format);\n\tif (test->protocol->id == Ptcp) {\n\t    if (test->sender_has_retransmits) {\n\t\t/* Summary, TCP with retransmits. */\n\t\tif (test->json_output)\n\t\t    cJSON_AddItemToObject(json_summary_stream, \"sender\", iperf_json_printf(\"socket: %d  start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  retransmits: %d\", (int64_t) sp->socket, (double) start_time, (double) end_time, (double) end_time, (int64_t) bytes_sent, bandwidth * 8, (int64_t) sp->result->stream_retrans));\n\t\telse\n\t\t    iprintf(test, report_bw_retrans_format, sp->socket, start_time, end_time, ubuf, nbuf, sp->result->stream_retrans, report_sender);\n\t    } else {\n\t\t/* Summary, TCP without retransmits. */\n\t\tif (test->json_output)\n\t\t    cJSON_AddItemToObject(json_summary_stream, \"sender\", iperf_json_printf(\"socket: %d  start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f\", (int64_t) sp->socket, (double) start_time, (double) end_time, (double) end_time, (int64_t) bytes_sent, bandwidth * 8));\n\t\telse\n\t\t    iprintf(test, report_bw_format, sp->socket, start_time, end_time, ubuf, nbuf, report_sender);\n\t    }\n\t} else {\n\t    /* Summary, UDP. */\n\t    lost_percent = 100.0 * sp->cnt_error / (sp->packet_count - sp->omitted_packet_count);\n\t    if (test->json_output)\n\t\tcJSON_AddItemToObject(json_summary_stream, \"udp\", iperf_json_printf(\"socket: %d  start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  jitter_ms: %f  lost_packets: %d  packets: %d  lost_percent: %f  out_of_order: %d\", (int64_t) sp->socket, (double) start_time, (double) end_time, (double) end_time, (int64_t) bytes_sent, bandwidth * 8, (double) sp->jitter * 1000.0, (int64_t) sp->cnt_error, (int64_t) (sp->packet_count - sp->omitted_packet_count), (double) lost_percent, (int64_t) sp->outoforder_packets));\n\t    else {\n\t\tiprintf(test, report_bw_udp_format, sp->socket, start_time, end_time, ubuf, nbuf, sp->jitter * 1000.0, sp->cnt_error, (sp->packet_count - sp->omitted_packet_count), lost_percent, \"\");\n\t\tif (test->role == 'c')\n\t\t    iprintf(test, report_datagrams, sp->socket, (sp->packet_count - sp->omitted_packet_count));\n\t\tif (sp->outoforder_packets > 0)\n\t\t    iprintf(test, report_sum_outoforder, start_time, end_time, sp->outoforder_packets);\n\t    }\n\t}\n\n\tif (sp->diskfile_fd >= 0) {\n\t    if (fstat(sp->diskfile_fd, &sb) == 0) {\n\t\tint percent = (int) ( ( (double) bytes_sent / (double) sb.st_size ) * 100.0 );\n\t\tunit_snprintf(sbuf, UNIT_LEN, (double) sb.st_size, 'A');\n\t\tif (test->json_output)\n\t\t    cJSON_AddItemToObject(json_summary_stream, \"diskfile\", iperf_json_printf(\"sent: %d  size: %d  percent: %d  filename: %s\", (int64_t) bytes_sent, (int64_t) sb.st_size, (int64_t) percent, test->diskfile_name));\n\t\telse\n\t\t    iprintf(test, report_diskfile, ubuf, sbuf, percent, test->diskfile_name);\n\t    }\n\t}\n\n\tunit_snprintf(ubuf, UNIT_LEN, (double) bytes_received, 'A');\n\tbandwidth = (double) bytes_received / (double) end_time;\n\tunit_snprintf(nbuf, UNIT_LEN, bandwidth, test->settings->unit_format);\n\tif (test->protocol->id == Ptcp) {\n\t    if (test->json_output)\n\t\tcJSON_AddItemToObject(json_summary_stream, \"receiver\", iperf_json_printf(\"socket: %d  start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f\", (int64_t) sp->socket, (double) start_time, (double) end_time, (double) end_time, (int64_t) bytes_received, bandwidth * 8));\n\t    else\n\t\tiprintf(test, report_bw_format, sp->socket, start_time, end_time, ubuf, nbuf, report_receiver);\n\t}\n    }\n    }\n\n    if (test->num_streams > 1 || test->json_output) {\n        unit_snprintf(ubuf, UNIT_LEN, (double) total_sent, 'A');\n\t/* If no tests were run, arbitrariliy set bandwidth to 0. */\n\tif (end_time > 0.0) {\n\t    bandwidth = (double) total_sent / (double) end_time;\n\t}\n\telse {\n\t    bandwidth = 0.0;\n\t}\n        unit_snprintf(nbuf, UNIT_LEN, bandwidth, test->settings->unit_format);\n        if (test->protocol->id == Ptcp) {\n\t    if (test->sender_has_retransmits) {\n\t\t/* Summary sum, TCP with retransmits. */\n\t\tif (test->json_output)\n\t\t    cJSON_AddItemToObject(test->json_end, \"sum_sent\", iperf_json_printf(\"start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  retransmits: %d\", (double) start_time, (double) end_time, (double) end_time, (int64_t) total_sent, bandwidth * 8, (int64_t) total_retransmits));\n\t\telse\n\t\t    iprintf(test, report_sum_bw_retrans_format, start_time, end_time, ubuf, nbuf, total_retransmits, report_sender);\n\t    } else {\n\t\t/* Summary sum, TCP without retransmits. */\n\t\tif (test->json_output)\n\t\t    cJSON_AddItemToObject(test->json_end, \"sum_sent\", iperf_json_printf(\"start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f\", (double) start_time, (double) end_time, (double) end_time, (int64_t) total_sent, bandwidth * 8));\n\t\telse\n\t\t    iprintf(test, report_sum_bw_format, start_time, end_time, ubuf, nbuf, report_sender);\n\t    }\n            unit_snprintf(ubuf, UNIT_LEN, (double) total_received, 'A');\n\t    /* If no tests were run, set received bandwidth to 0 */\n\t    if (end_time > 0.0) {\n\t\tbandwidth = (double) total_received / (double) end_time;\n\t    }\n\t    else {\n\t\tbandwidth = 0.0;\n\t    }\n            unit_snprintf(nbuf, UNIT_LEN, bandwidth, test->settings->unit_format);\n\t    if (test->json_output)\n\t\tcJSON_AddItemToObject(test->json_end, \"sum_received\", iperf_json_printf(\"start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f\", (double) start_time, (double) end_time, (double) end_time, (int64_t) total_received, bandwidth * 8));\n\t    else\n\t\tiprintf(test, report_sum_bw_format, start_time, end_time, ubuf, nbuf, report_receiver);\n        } else {\n\t    /* Summary sum, UDP. */\n            avg_jitter /= test->num_streams;\n\t    /* If no packets were sent, arbitrarily set loss percentage to 100. */\n\t    if (total_packets > 0) {\n\t\tlost_percent = 100.0 * lost_packets / total_packets;\n\t    }\n\t    else {\n\t\tlost_percent = 100.0;\n\t    }\n\t    if (test->json_output)\n\t\tcJSON_AddItemToObject(test->json_end, \"sum\", iperf_json_printf(\"start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  jitter_ms: %f  lost_packets: %d  packets: %d  lost_percent: %f\", (double) start_time, (double) end_time, (double) end_time, (int64_t) total_sent, bandwidth * 8, (double) avg_jitter * 1000.0, (int64_t) lost_packets, (int64_t) total_packets, (double) lost_percent));\n\t    else\n\t\tiprintf(test, report_sum_bw_udp_format, start_time, end_time, ubuf, nbuf, avg_jitter * 1000.0, lost_packets, total_packets, lost_percent, \"\");\n        }\n    }\n\n    if (test->json_output)\n\tcJSON_AddItemToObject(test->json_end, \"cpu_utilization_percent\", iperf_json_printf(\"host_total: %f  host_user: %f  host_system: %f  remote_total: %f  remote_user: %f  remote_system: %f\", (double) test->cpu_util[0], (double) test->cpu_util[1], (double) test->cpu_util[2], (double) test->remote_cpu_util[0], (double) test->remote_cpu_util[1], (double) test->remote_cpu_util[2]));\n    else {\n\tif (test->verbose) {\n\t    iprintf(test, report_cpu, report_local, test->sender?report_sender:report_receiver, test->cpu_util[0], test->cpu_util[1], test->cpu_util[2], report_remote, test->sender?report_receiver:report_sender, test->remote_cpu_util[0], test->remote_cpu_util[1], test->remote_cpu_util[2]);\n\t}\n\n\t/* Print server output if we're on the client and it was requested/provided */\n\tif (test->role == 'c' && iperf_get_test_get_server_output(test)) {\n\t    if (test->json_server_output) {\n\t\tiprintf(test, \"\\nServer JSON output:\\n%s\\n\", cJSON_Print(test->json_server_output));\n\t\tcJSON_Delete(test->json_server_output);\n\t\ttest->json_server_output = NULL;\n\t    }\n\t    if (test->server_output_text) {\n\t\tiprintf(test, \"\\nServer output:\\n%s\\n\", test->server_output_text);\n\t\ttest->server_output_text = NULL;\n\t    }\n\t}\n    }\n}\n\n/**************************************************************************/\n\n/**\n * iperf_reporter_callback -- handles the report printing\n *\n */\n\nvoid\niperf_reporter_callback(struct iperf_test *test)\n{\n    switch (test->state) {\n        case TEST_RUNNING:\n        case STREAM_RUNNING:\n            /* print interval results for each stream */\n            iperf_print_intermediate(test);\n            break;\n        case TEST_END:\n        case DISPLAY_RESULTS:\n            iperf_print_intermediate(test);\n            iperf_print_results(test);\n            break;\n    } \n\n}\n\n/**************************************************************************/\nstatic void\nprint_interval_results(struct iperf_test *test, struct iperf_stream *sp, cJSON *json_interval_streams)\n{\n    char ubuf[UNIT_LEN];\n    char nbuf[UNIT_LEN];\n    char cbuf[UNIT_LEN];\n    double st = 0., et = 0.;\n    struct iperf_interval_results *irp = NULL;\n    double bandwidth, lost_percent;\n\n    irp = TAILQ_LAST(&sp->result->interval_results, irlisthead); /* get last entry in linked list */\n    if (irp == NULL) {\n\tiperf_err(test, \"print_interval_results error: interval_results is NULL\");\n        return;\n    }\n    if (!test->json_output) {\n\t/* First stream? */\n\tif (sp == SLIST_FIRST(&test->streams)) {\n\t    /* It it's the first interval, print the header;\n\t    ** else if there's more than one stream, print the separator;\n\t    ** else nothing.\n\t    */\n\t    if (timeval_equals(&sp->result->start_time, &irp->interval_start_time)) {\n\t\tif (test->protocol->id == Ptcp) {\n\t\t    if (test->sender && test->sender_has_retransmits)\n\t\t\tiprintf(test, \"%s\", report_bw_retrans_cwnd_header);\n\t\t    else\n\t\t\tiprintf(test, \"%s\", report_bw_header);\n\t\t} else {\n\t\t    if (test->sender)\n\t\t\tiprintf(test, \"%s\", report_bw_udp_sender_header);\n\t\t    else\n\t\t\tiprintf(test, \"%s\", report_bw_udp_header);\n\t\t}\n\t    } else if (test->num_streams > 1)\n\t\tiprintf(test, \"%s\", report_bw_separator);\n\t}\n    }\n\n    unit_snprintf(ubuf, UNIT_LEN, (double) (irp->bytes_transferred), 'A');\n    bandwidth = (double) irp->bytes_transferred / (double) irp->interval_duration;\n    unit_snprintf(nbuf, UNIT_LEN, bandwidth, test->settings->unit_format);\n    \n    st = timeval_diff(&sp->result->start_time, &irp->interval_start_time);\n    et = timeval_diff(&sp->result->start_time, &irp->interval_end_time);\n    \n    if (test->protocol->id == Ptcp) {\n\tif (test->sender && test->sender_has_retransmits) {\n\t    /* Interval, TCP with retransmits. */\n\t    if (test->json_output)\n\t\tcJSON_AddItemToArray(json_interval_streams, iperf_json_printf(\"socket: %d  start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  retransmits: %d  snd_cwnd:  %d  omitted: %b\", (int64_t) sp->socket, (double) st, (double) et, (double) irp->interval_duration, (int64_t) irp->bytes_transferred, bandwidth * 8, (int64_t) irp->interval_retrans, (int64_t) irp->snd_cwnd, irp->omitted));\n\t    else {\n\t\tunit_snprintf(cbuf, UNIT_LEN, irp->snd_cwnd, 'A');\n\t\tiprintf(test, report_bw_retrans_cwnd_format, sp->socket, st, et, ubuf, nbuf, irp->interval_retrans, cbuf, irp->omitted?report_omitted:\"\");\n\t    }\n\t} else {\n\t    /* Interval, TCP without retransmits. */\n\t    if (test->json_output)\n\t\tcJSON_AddItemToArray(json_interval_streams, iperf_json_printf(\"socket: %d  start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  omitted: %b\", (int64_t) sp->socket, (double) st, (double) et, (double) irp->interval_duration, (int64_t) irp->bytes_transferred, bandwidth * 8, irp->omitted));\n\t    else\n\t\tiprintf(test, report_bw_format, sp->socket, st, et, ubuf, nbuf, irp->omitted?report_omitted:\"\");\n\t}\n    } else {\n\t/* Interval, UDP. */\n\tif (test->sender) {\n\t    if (test->json_output)\n\t\tcJSON_AddItemToArray(json_interval_streams, iperf_json_printf(\"socket: %d  start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  packets: %d  omitted: %b\", (int64_t) sp->socket, (double) st, (double) et, (double) irp->interval_duration, (int64_t) irp->bytes_transferred, bandwidth * 8, (int64_t) irp->interval_packet_count, irp->omitted));\n\t    else\n\t\tiprintf(test, report_bw_udp_sender_format, sp->socket, st, et, ubuf, nbuf, irp->interval_packet_count, irp->omitted?report_omitted:\"\");\n\t} else {\n\t    lost_percent = 100.0 * irp->interval_cnt_error / irp->interval_packet_count;\n\t    if (test->json_output)\n\t\tcJSON_AddItemToArray(json_interval_streams, iperf_json_printf(\"socket: %d  start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  jitter_ms: %f  lost_packets: %d  packets: %d  lost_percent: %f  omitted: %b\", (int64_t) sp->socket, (double) st, (double) et, (double) irp->interval_duration, (int64_t) irp->bytes_transferred, bandwidth * 8, (double) irp->jitter * 1000.0, (int64_t) irp->interval_cnt_error, (int64_t) irp->interval_packet_count, (double) lost_percent, irp->omitted));\n\t    else\n\t\tiprintf(test, report_bw_udp_format, sp->socket, st, et, ubuf, nbuf, irp->jitter * 1000.0, irp->interval_cnt_error, irp->interval_packet_count, lost_percent, irp->omitted?report_omitted:\"\");\n\t}\n    }\n}\n\n/**************************************************************************/\nvoid\niperf_free_stream(struct iperf_stream *sp)\n{\n    struct iperf_interval_results *irp, *nirp;\n\n    /* XXX: need to free interval list too! */\n    munmap(sp->buffer, sp->test->settings->blksize);\n    close(sp->buffer_fd);\n    if (sp->diskfile_fd >= 0)\n\tclose(sp->diskfile_fd);\n    for (irp = TAILQ_FIRST(&sp->result->interval_results); irp != TAILQ_END(sp->result->interval_results); irp = nirp) {\n        nirp = TAILQ_NEXT(irp, irlistentries);\n        free(irp);\n    }\n    free(sp->result);\n    if (sp->send_timer != NULL)\n\ttmr_cancel(sp->send_timer);\n    free(sp);\n}\n\n/**************************************************************************/\nstruct iperf_stream *\niperf_new_stream(struct iperf_test *test, int s)\n{\n    int i;\n    struct iperf_stream *sp;\n    char template[] = \"/tmp/iperf3.XXXXXX\";\n\n    h_errno = 0;\n\n    sp = (struct iperf_stream *) malloc(sizeof(struct iperf_stream));\n    if (!sp) {\n        i_errno = IECREATESTREAM;\n        return NULL;\n    }\n\n    memset(sp, 0, sizeof(struct iperf_stream));\n\n    sp->test = test;\n    sp->settings = test->settings;\n    sp->result = (struct iperf_stream_result *) malloc(sizeof(struct iperf_stream_result));\n    if (!sp->result) {\n        free(sp);\n        i_errno = IECREATESTREAM;\n        return NULL;\n    }\n\n    memset(sp->result, 0, sizeof(struct iperf_stream_result));\n    TAILQ_INIT(&sp->result->interval_results);\n    \n    /* Create and randomize the buffer */\n    sp->buffer_fd = mkstemp(template);\n    if (sp->buffer_fd == -1) {\n        i_errno = IECREATESTREAM;\n        free(sp->result);\n        free(sp);\n        return NULL;\n    }\n    if (unlink(template) < 0) {\n        i_errno = IECREATESTREAM;\n        free(sp->result);\n        free(sp);\n        return NULL;\n    }\n    if (ftruncate(sp->buffer_fd, test->settings->blksize) < 0) {\n        i_errno = IECREATESTREAM;\n        free(sp->result);\n        free(sp);\n        return NULL;\n    }\n    sp->buffer = (char *) mmap(NULL, test->settings->blksize, PROT_READ|PROT_WRITE, MAP_PRIVATE, sp->buffer_fd, 0);\n    if (sp->buffer == MAP_FAILED) {\n        i_errno = IECREATESTREAM;\n        free(sp->result);\n        free(sp);\n        return NULL;\n    }\n    srandom(time(NULL));\n    for (i = 0; i < test->settings->blksize; ++i)\n        sp->buffer[i] = random();\n\n    /* Set socket */\n    sp->socket = s;\n\n    sp->snd = test->protocol->send;\n    sp->rcv = test->protocol->recv;\n\n    if (test->diskfile_name != (char*) 0) {\n\tsp->diskfile_fd = open(test->diskfile_name, test->sender ? O_RDONLY : (O_WRONLY|O_CREAT|O_TRUNC), S_IRUSR|S_IWUSR);\n\tif (sp->diskfile_fd == -1) {\n\t    i_errno = IEFILE;\n            munmap(sp->buffer, sp->test->settings->blksize);\n            free(sp->result);\n            free(sp);\n\t    return NULL;\n\t}\n        sp->snd2 = sp->snd;\n\tsp->snd = diskfile_send;\n\tsp->rcv2 = sp->rcv;\n\tsp->rcv = diskfile_recv;\n    } else\n        sp->diskfile_fd = -1;\n\n    /* Initialize stream */\n    if (iperf_init_stream(sp, test) < 0) {\n        close(sp->buffer_fd);\n        munmap(sp->buffer, sp->test->settings->blksize);\n        free(sp->result);\n        free(sp);\n        return NULL;\n    }\n    iperf_add_stream(test, sp);\n\n    return sp;\n}\n\n/**************************************************************************/\nint\niperf_init_stream(struct iperf_stream *sp, struct iperf_test *test)\n{\n    socklen_t len;\n    int opt;\n\n    len = sizeof(struct sockaddr_storage);\n    if (getsockname(sp->socket, (struct sockaddr *) &sp->local_addr, &len) < 0) {\n        i_errno = IEINITSTREAM;\n        return -1;\n    }\n    len = sizeof(struct sockaddr_storage);\n    if (getpeername(sp->socket, (struct sockaddr *) &sp->remote_addr, &len) < 0) {\n        i_errno = IEINITSTREAM;\n        return -1;\n    }\n\n    /* Set IP TOS */\n    if ((opt = test->settings->tos)) {\n        if (getsockdomain(sp->socket) == AF_INET6) {\n#ifdef IPV6_TCLASS\n            if (setsockopt(sp->socket, IPPROTO_IPV6, IPV6_TCLASS, &opt, sizeof(opt)) < 0) {\n                i_errno = IESETCOS;\n                return -1;\n            }\n#else\n            i_errno = IESETCOS;\n            return -1;\n#endif\n        } else {\n            if (setsockopt(sp->socket, IPPROTO_IP, IP_TOS, &opt, sizeof(opt)) < 0) {\n                i_errno = IESETTOS;\n                return -1;\n            }\n        }\n    }\n\n    return 0;\n}\n\n/**************************************************************************/\nvoid\niperf_add_stream(struct iperf_test *test, struct iperf_stream *sp)\n{\n    int i;\n    struct iperf_stream *n, *prev;\n\n    if (SLIST_EMPTY(&test->streams)) {\n        SLIST_INSERT_HEAD(&test->streams, sp, streams);\n        sp->id = 1;\n    } else {\n        // for (n = test->streams, i = 2; n->next; n = n->next, ++i);\n        i = 2;\n        SLIST_FOREACH(n, &test->streams, streams) {\n            prev = n;\n            ++i;\n        }\n        SLIST_INSERT_AFTER(prev, sp, streams);\n        sp->id = i;\n    }\n}\n\n/* This pair of routines gets inserted into the snd/rcv function pointers\n** when there's a -F flag. They handle the file stuff and call the real\n** snd/rcv functions, which have been saved in snd2/rcv2.\n**\n** The advantage of doing it this way is that in the much more common\n** case of no -F flag, there is zero extra overhead.\n*/\n\nstatic int\ndiskfile_send(struct iperf_stream *sp)\n{\n    int r;\n\n    r = read(sp->diskfile_fd, sp->buffer, sp->test->settings->blksize);\n    if (r == 0)\n        sp->test->done = 1;\n    else\n\tr = sp->snd2(sp);\n    return r;\n}\n\nstatic int\ndiskfile_recv(struct iperf_stream *sp)\n{\n    int r;\n\n    r = sp->rcv2(sp);\n    if (r > 0) {\n\t(void) write(sp->diskfile_fd, sp->buffer, r);\n\t(void) fsync(sp->diskfile_fd);\n    }\n    return r;\n}\n\n\nvoid\niperf_catch_sigend(void (*handler)(int))\n{\n    signal(SIGINT, handler);\n    signal(SIGTERM, handler);\n    signal(SIGHUP, handler);\n}\n\nvoid\niperf_got_sigend(struct iperf_test *test)\n{\n    /*\n     * If we're the client, or if we're a server and running a test,\n     * then dump out the accumulated stats so far.\n     */\n    if (test->role == 'c' ||\n      (test->role == 's' && test->state == TEST_RUNNING)) {\n\n\ttest->done = 1;\n\tcpu_util(test->cpu_util);\n\ttest->stats_callback(test);\n\ttest->state = DISPLAY_RESULTS; /* change local state only */\n\tif (test->on_test_finish)\n\t    test->on_test_finish(test);\n\ttest->reporter_callback(test);\n    }\n\n    if (test->ctrl_sck >= 0) {\n\ttest->state = (test->role == 'c') ? CLIENT_TERMINATE : SERVER_TERMINATE;\n\t(void) Nwrite(test->ctrl_sck, (char*) &test->state, sizeof(signed char), Ptcp);\n    }\n    i_errno = (test->role == 'c') ? IECLIENTTERM : IESERVERTERM;\n    iperf_errexit(test, \"interrupt - %s\", iperf_strerror(i_errno));\n}\n\n\nint\niperf_json_start(struct iperf_test *test)\n{\n    test->json_top = cJSON_CreateObject();\n    if (test->json_top == NULL)\n        return -1;\n    if (test->title)\n\tcJSON_AddStringToObject(test->json_top, \"title\", test->title);\n    test->json_start = cJSON_CreateObject();\n    if (test->json_start == NULL)\n        return -1;\n    cJSON_AddItemToObject(test->json_top, \"start\", test->json_start);\n    test->json_connected = cJSON_CreateArray();\n    if (test->json_connected == NULL)\n        return -1;\n    cJSON_AddItemToObject(test->json_start, \"connected\", test->json_connected);\n    test->json_intervals = cJSON_CreateArray();\n    if (test->json_intervals == NULL)\n        return -1;\n    cJSON_AddItemToObject(test->json_top, \"intervals\", test->json_intervals);\n    test->json_end = cJSON_CreateObject();\n    if (test->json_end == NULL)\n        return -1;\n    cJSON_AddItemToObject(test->json_top, \"end\", test->json_end);\n    return 0;\n}\n\nint\niperf_json_finish(struct iperf_test *test)\n{\n    char *str;\n\n    /* Include server output */\n    if (test->json_server_output) {\n\tcJSON_AddItemToObject(test->json_top, \"server_output_json\", test->json_server_output);\n    }\n    if (test->server_output_text) {\n\tcJSON_AddStringToObject(test->json_top, \"server_output_text\", test->server_output_text);\n    }\n    str = cJSON_Print(test->json_top);\n    if (str == NULL)\n        return -1;\n    fputs(str, stdout);\n    putchar('\\n');\n    fflush(stdout);\n    free(str);\n    cJSON_Delete(test->json_top);\n    test->json_top = test->json_start = test->json_connected = test->json_intervals = test->json_server_output = test->json_end = NULL;\n    return 0;\n}\n\n\n/* CPU affinity stuff - linux only. */\n\nint\niperf_setaffinity(int affinity)\n{\n#ifdef linux\n    cpu_set_t cpu_set;\n\n    CPU_ZERO(&cpu_set);\n    CPU_SET(affinity, &cpu_set);\n    if (sched_setaffinity(0, sizeof(cpu_set_t), &cpu_set) != 0) {\n\ti_errno = IEAFFINITY;\n        return -1;\n    }\n    return 0;\n#else /*linux*/\n    i_errno = IEAFFINITY;\n    return -1;\n#endif /*linux*/\n}\n\nint\niperf_clearaffinity(void)\n{\n#ifdef linux\n    cpu_set_t cpu_set;\n    int i;\n\n    CPU_ZERO(&cpu_set);\n    for (i = 0; i < CPU_SETSIZE; ++i)\n\tCPU_SET(i, &cpu_set);\n    if (sched_setaffinity(0, sizeof(cpu_set_t), &cpu_set) != 0) {\n\ti_errno = IEAFFINITY;\n        return -1;\n    }\n    return 0;\n#else /*linux*/\n    i_errno = IEAFFINITY;\n    return -1;\n#endif /*linux*/\n}\n\nint\niprintf(struct iperf_test *test, const char* format, ...)\n{\n    va_list argp;\n    int r = -1;\n\n    /*\n     * There are roughly two use cases here.  If we're the client,\n     * want to print stuff directly to the output stream.\n     * If we're the sender we might need to buffer up output to send\n     * to the client.\n     *\n     * This doesn't make a whole lot of difference except there are\n     * some chunks of output on the client (on particular the whole\n     * of the server output with --get-server-output) that could\n     * easily exceed the size of the line buffer, but which don't need\n     * to be buffered up anyway.\n     */\n    if (test->role == 'c') {\n\tif (test->title)\n\t    printf(\"%s:  \", test->title);\n\tva_start(argp, format);\n\tr = vprintf(format, argp);\n\tva_end(argp);\n    }\n    else if (test->role == 's') {\n\tchar linebuffer[1024];\n\tva_start(argp, format);\n\tr = vsnprintf(linebuffer, sizeof(linebuffer), format, argp);\n\tva_end(argp);\n\tprintf(\"%s\", linebuffer);\n\n\tif (test->role == 's' && iperf_get_test_get_server_output(test)) {\n\t    struct iperf_textline *l = (struct iperf_textline *) malloc(sizeof(struct iperf_textline));\n\t    l->line = strdup(linebuffer);\n\t    TAILQ_INSERT_TAIL(&(test->server_output_list), l, textlineentries);\n\t}\n    }\n    return r;\n}\n", "/*\n * iperf, Copyright (c) 2014, The Regents of the University of\n * California, through Lawrence Berkeley National Laboratory (subject\n * to receipt of any required approvals from the U.S. Dept. of\n * Energy).  All rights reserved.\n *\n * If you have questions about your rights to use or distribute this\n * software, please contact Berkeley Lab's Technology Transfer\n * Department at TTD@lbl.gov.\n *\n * NOTICE.  This software is owned by the U.S. Department of Energy.\n * As such, the U.S. Government has been granted for itself and others\n * acting on its behalf a paid-up, nonexclusive, irrevocable,\n * worldwide license in the Software to reproduce, prepare derivative\n * works, and perform publicly and display publicly.  Beginning five\n * (5) years after the date permission to assert copyright is obtained\n * from the U.S. Department of Energy, and subject to any subsequent\n * five (5) year renewals, the U.S. Government is granted for itself\n * and others acting on its behalf a paid-up, nonexclusive,\n * irrevocable, worldwide license in the Software to reproduce,\n * prepare derivative works, distribute copies to the public, perform\n * publicly and display publicly, and to permit others to do so.\n *\n * This code is distributed under a BSD style license, see the LICENSE\n * file for complete information.\n */\n/* iperf_util.c\n *\n * Iperf utility functions\n *\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/select.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <time.h>\n#include <errno.h>\n\n#include \"config.h\"\n#include \"cjson.h\"\n\n/* make_cookie\n *\n * Generate and return a cookie string\n *\n * Iperf uses this function to create test \"cookies\" which\n * server as unique test identifiers. These cookies are also\n * used for the authentication of stream connections.\n */\n\nvoid\nmake_cookie(char *cookie)\n{\n    static int randomized = 0;\n    char hostname[500];\n    struct timeval tv;\n    char temp[1000];\n\n    if ( ! randomized )\n        srandom((int) time(0) ^ getpid());\n\n    /* Generate a string based on hostname, time, randomness, and filler. */\n    (void) gethostname(hostname, sizeof(hostname));\n    (void) gettimeofday(&tv, 0);\n    (void) snprintf(temp, sizeof(temp), \"%s.%ld.%06ld.%08lx%08lx.%s\", hostname, (unsigned long int) tv.tv_sec, (unsigned long int) tv.tv_usec, (unsigned long int) random(), (unsigned long int) random(), \"1234567890123456789012345678901234567890\");\n\n    /* Now truncate it to 36 bytes and terminate. */\n    memcpy(cookie, temp, 36);\n    cookie[36] = '\\0';\n}\n\n\n/* is_closed\n *\n * Test if the file descriptor fd is closed.\n * \n * Iperf uses this function to test whether a TCP stream socket\n * is closed, because accepting and denying an invalid connection\n * in iperf_tcp_accept is not considered an error.\n */\n\nint\nis_closed(int fd)\n{\n    struct timeval tv;\n    fd_set readset;\n\n    FD_ZERO(&readset);\n    FD_SET(fd, &readset);\n    tv.tv_sec = 0;\n    tv.tv_usec = 0;\n\n    if (select(fd+1, &readset, NULL, NULL, &tv) < 0) {\n        if (errno == EBADF)\n            return 1;\n    }\n    return 0;\n}\n\n\ndouble\ntimeval_to_double(struct timeval * tv)\n{\n    double d;\n\n    d = tv->tv_sec + tv->tv_usec / 1000000;\n\n    return d;\n}\n\nint\ntimeval_equals(struct timeval * tv0, struct timeval * tv1)\n{\n    if ( tv0->tv_sec == tv1->tv_sec && tv0->tv_usec == tv1->tv_usec )\n\treturn 1;\n    else\n\treturn 0;\n}\n\ndouble\ntimeval_diff(struct timeval * tv0, struct timeval * tv1)\n{\n    double time1, time2;\n    \n    time1 = tv0->tv_sec + (tv0->tv_usec / 1000000.0);\n    time2 = tv1->tv_sec + (tv1->tv_usec / 1000000.0);\n\n    time1 = time1 - time2;\n    if (time1 < 0)\n        time1 = -time1;\n    return time1;\n}\n\n\nint\ndelay(int64_t ns)\n{\n    struct timespec req, rem;\n\n    req.tv_sec = 0;\n\n    while (ns >= 1000000000L) {\n        ns -= 1000000000L;\n        req.tv_sec += 1;\n    }\n\n    req.tv_nsec = ns;\n\n    while (nanosleep(&req, &rem) == -1)\n        if (EINTR == errno)\n            memcpy(&req, &rem, sizeof(rem));\n        else\n            return -1;\n    return 0;\n}\n\n# ifdef DELAY_SELECT_METHOD\nint\ndelay(int us)\n{\n    struct timeval tv;\n\n    tv.tv_sec = 0;\n    tv.tv_usec = us;\n    (void) select(1, (fd_set *) 0, (fd_set *) 0, (fd_set *) 0, &tv);\n    return 1;\n}\n#endif\n\n\nvoid\ncpu_util(double pcpu[3])\n{\n    static struct timeval last;\n    static clock_t clast;\n    static struct rusage rlast;\n    struct timeval temp;\n    clock_t ctemp;\n    struct rusage rtemp;\n    double timediff;\n    double userdiff;\n    double systemdiff;\n\n    if (pcpu == NULL) {\n        gettimeofday(&last, NULL);\n        clast = clock();\n\tgetrusage(RUSAGE_SELF, &rlast);\n        return;\n    }\n\n    gettimeofday(&temp, NULL);\n    ctemp = clock();\n    getrusage(RUSAGE_SELF, &rtemp);\n\n    timediff = ((temp.tv_sec * 1000000.0 + temp.tv_usec) -\n                (last.tv_sec * 1000000.0 + last.tv_usec));\n    userdiff = ((rtemp.ru_utime.tv_sec * 1000000.0 + rtemp.ru_utime.tv_usec) -\n                (rlast.ru_utime.tv_sec * 1000000.0 + rlast.ru_utime.tv_usec));\n    systemdiff = ((rtemp.ru_stime.tv_sec * 1000000.0 + rtemp.ru_stime.tv_usec) -\n                  (rlast.ru_stime.tv_sec * 1000000.0 + rlast.ru_stime.tv_usec));\n\n    pcpu[0] = (((ctemp - clast) * 1000000.0 / CLOCKS_PER_SEC) / timediff) * 100;\n    pcpu[1] = (userdiff / timediff) * 100;\n    pcpu[2] = (systemdiff / timediff) * 100;\n}\n\nchar*\nget_system_info(void)\n    {\n    FILE* fp;\n    static char buf[1000];\n\n    fp = popen(\"uname -a\", \"r\");\n    if (fp == NULL)\n\treturn NULL;\n    fgets(buf, sizeof(buf), fp);\n    pclose(fp);\n    return buf;\n    }\n\n\n/* Helper routine for building cJSON objects in a printf-like manner.\n**\n** Sample call:\n**   j = iperf_json_printf(\"foo: %b  bar: %d  bletch: %f  eep: %s\", b, i, f, s);\n**\n** The four formatting characters and the types they expect are:\n**   %b  boolean           int\n**   %d  integer           int64_t\n**   %f  floating point    double\n**   %s  string            char *\n** If the values you're passing in are not these exact types, you must\n** cast them, there is no automatic type coercion/widening here.\n**\n** The colons mark the end of field names, and blanks are ignored.\n**\n** This routine is not particularly robust, but it's not part of the API,\n** it's just for internal iperf3 use.\n*/\ncJSON*\niperf_json_printf(const char *format, ...)\n{\n    cJSON* o;\n    va_list argp;\n    const char *cp;\n    char name[100];\n    char* np;\n    cJSON* j;\n\n    o = cJSON_CreateObject();\n    if (o == NULL)\n        return NULL;\n    va_start(argp, format);\n    np = name;\n    for (cp = format; *cp != '\\0'; ++cp) {\n\tswitch (*cp) {\n\t    case ' ':\n\t    break;\n\t    case ':':\n\t    *np = '\\0';\n\t    break;\n\t    case '%':\n\t    ++cp;\n\t    switch (*cp) {\n\t\tcase 'b':\n\t\tj = cJSON_CreateBool(va_arg(argp, int));\n\t\tbreak;\n\t\tcase 'd':\n\t\tj = cJSON_CreateInt(va_arg(argp, int64_t));\n\t\tbreak;\n\t\tcase 'f':\n\t\tj = cJSON_CreateFloat(va_arg(argp, double));\n\t\tbreak;\n\t\tcase 's':\n\t\tj = cJSON_CreateString(va_arg(argp, char *));\n\t\tbreak;\n\t\tdefault:\n\t\treturn NULL;\n\t    }\n\t    if (j == NULL)\n\t\treturn NULL;\n\t    cJSON_AddItemToObject(o, name, j);\n\t    np = name;\n\t    break;\n\t    default:\n\t    *np++ = *cp;\n\t    break;\n\t}\n    }\n    va_end(argp);\n    return o;\n}\n\n/* Debugging routine to dump out an fd_set. */\nvoid\niperf_dump_fdset(FILE *fp, char *str, int nfds, fd_set *fds)\n{\n    int fd;\n    int comma;\n\n    fprintf(fp, \"%s: [\", str);\n    comma = 0;\n    for (fd = 0; fd < nfds; ++fd) {\n        if (FD_ISSET(fd, fds)) {\n\t    if (comma)\n\t\tfprintf(fp, \", \");\n\t    fprintf(fp, \"%d\", fd);\n\t    comma = 1;\n\t}\n    }\n    fprintf(fp, \"]\\n\");\n}\n"], "fixing_code": ["# iperf, Copyright (c) 2014, 2015, The Regents of the University of\n# California, through Lawrence Berkeley National Laboratory (subject\n# to receipt of any required approvals from the U.S. Dept. of\n# Energy).  All rights reserved.\n#\n# If you have questions about your rights to use or distribute this\n# software, please contact Berkeley Lab's Technology Transfer\n# Department at TTD@lbl.gov.\n#\n# NOTICE.  This software is owned by the U.S. Department of Energy.\n# As such, the U.S. Government has been granted for itself and others\n# acting on its behalf a paid-up, nonexclusive, irrevocable,\n# worldwide license in the Software to reproduce, prepare derivative\n# works, and perform publicly and display publicly.  Beginning five\n# (5) years after the date permission to assert copyright is obtained\n# from the U.S. Department of Energy, and subject to any subsequent\n# five (5) year renewals, the U.S. Government is granted for itself\n# and others acting on its behalf a paid-up, nonexclusive,\n# irrevocable, worldwide license in the Software to reproduce,\n# prepare derivative works, distribute copies to the public, perform\n# publicly and display publicly, and to permit others to do so.\n#\n# This code is distributed under a BSD style license, see the LICENSE\n# file for complete information.\n\n# Initialize the autoconf system for the specified tool, version and mailing list\nAC_INIT(iperf, 3.0.11, https://github.com/esnet/iperf, iperf, http://software.es.net/iperf/)\n\n# Specify where the auxiliary files created by configure should go. The config\n# directory is picked so that they don't clutter up more useful directories.\nAC_CONFIG_AUX_DIR(config)\n\n\n# Initialize the automake system\nAM_INIT_AUTOMAKE\n\nAM_MAINTAINER_MODE\nAM_CONFIG_HEADER(src/config.h)\n\nAC_CANONICAL_HOST\n\n# Checks for tools: c compiler, ranlib (used for creating static libraries),\n# symlinks and libtool\nAC_PROG_CC\nAC_PROG_RANLIB\nAC_PROG_LN_S\nAC_PROG_LIBTOOL\n\n\n# Sets a conditional makefile variable so that certain Makefile tasks will be\n# performed only on linux (currently, add -luuid to LD_FLAGS)\nAM_CONDITIONAL(LINUX, [case $host_os in linux*) true;; *) false;; esac]) \n\n# Add -Wall if we are using GCC.\nif test \"x$GCC\" = \"xyes\"; then\n  CFLAGS=\"$CFLAGS -Wall\"\nfi\n\n# Checks for header files.\nAC_HEADER_STDC\n\n# Check for systems which need -lsocket and -lnsl\n#AX_LIB_SOCKET_NSL\n\n# Check for the math library (needed by cjson on some platforms)\nAC_SEARCH_LIBS(floor, [m], [], [\necho \"floor()\"\nexit 1\n])\n\n# Solaris puts nanosleep in -lrt\nAC_SEARCH_LIBS(nanosleep, [rt], [], [\necho \"nanosleep() required for timing operations.\"\nexit 1\n])\n\n# Solaris puts hstrerror in -lresolv\nAC_SEARCH_LIBS(hstrerror, [resolv], [], [\necho \"nanosleep() required for timing operations.\"\nexit 1\n])\n\n# Checks for typedefs, structures, and compiler characteristics.\nAC_C_CONST\n\nAC_OUTPUT([Makefile src/Makefile src/version.h examples/Makefile iperf3.spec])\n", "/*\n  Copyright (c) 2009 Dave Gamble\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in\n  all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n  THE SOFTWARE.\n*/\n\n/* cJSON */\n/* JSON parser in C. */\n\n#include <string.h>\n#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include <stdint.h>  \n#include <sys/types.h>\n#include \"cjson.h\"\n\n#ifndef LLONG_MAX\n#define LLONG_MAX 9223372036854775807LL\n#endif\n#ifndef LLONG_MIN\n#define LLONG_MIN (-LLONG_MAX - 1LL)\n#endif\nstatic const char *global_ep;\n\nconst char *cJSON_GetErrorPtr(void) {return global_ep;}\n\nstatic int cJSON_strcasecmp(const char *s1,const char *s2)\n{\n\tif (!s1) return (s1==s2)?0:1;if (!s2) return 1;\n\tfor(; tolower(*s1) == tolower(*s2); ++s1, ++s2)\tif(*s1 == 0)\treturn 0;\n\treturn tolower(*(const unsigned char *)s1) - tolower(*(const unsigned char *)s2);\n}\n\nstatic void *(*cJSON_malloc)(size_t sz) = malloc;\nstatic void (*cJSON_free)(void *ptr) = free;\n\nstatic char* cJSON_strdup(const char* str)\n{\n      size_t len;\n      char* copy;\n\n      len = strlen(str) + 1;\n      if (!(copy = (char*)cJSON_malloc(len))) return 0;\n      memcpy(copy,str,len);\n      return copy;\n}\n\nvoid cJSON_InitHooks(cJSON_Hooks* hooks)\n{\n    if (!hooks) { /* Reset hooks */\n        cJSON_malloc = malloc;\n        cJSON_free = free;\n        return;\n    }\n\n\tcJSON_malloc = (hooks->malloc_fn)?hooks->malloc_fn:malloc;\n\tcJSON_free\t = (hooks->free_fn)?hooks->free_fn:free;\n}\n\n/* Internal constructor. */\nstatic cJSON *cJSON_New_Item(void)\n{\n\tcJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));\n\tif (node) memset(node,0,sizeof(cJSON));\n\treturn node;\n}\n\n/* Delete a cJSON structure. */\nvoid cJSON_Delete(cJSON *c)\n{\n\tcJSON *next;\n\twhile (c)\n\t{\n\t\tnext=c->next;\n\t\tif (!(c->type&cJSON_IsReference) && c->child) cJSON_Delete(c->child);\n\t\tif (!(c->type&cJSON_IsReference) && c->valuestring) cJSON_free(c->valuestring);\n\t\tif (!(c->type&cJSON_StringIsConst) && c->string) cJSON_free(c->string);\n\t\tcJSON_free(c);\n\t\tc=next;\n\t}\n}\n\n/* Parse the input text to generate a number, and populate the result into item. */\nstatic const char *parse_number(cJSON *item,const char *num)\n{\n\tdouble n=0,sign=1,scale=0;int subscale=0,signsubscale=1;\n\n\tif (*num=='-') sign=-1,num++;\t/* Has sign? */\n\tif (*num=='0') num++;\t\t\t/* is zero */\n\tif (*num>='1' && *num<='9')\tdo\tn=(n*10.0)+(*num++ -'0');\twhile (*num>='0' && *num<='9');\t/* Number? */\n\tif (*num=='.' && num[1]>='0' && num[1]<='9') {num++;\t\tdo\tn=(n*10.0)+(*num++ -'0'),scale--; while (*num>='0' && *num<='9');}\t/* Fractional part? */\n\tif (*num=='e' || *num=='E')\t\t/* Exponent? */\n\t{\tnum++;if (*num=='+') num++;\telse if (*num=='-') signsubscale=-1,num++;\t\t/* With sign? */\n\t\twhile (*num>='0' && *num<='9') subscale=(subscale*10)+(*num++ - '0');\t/* Number? */\n\t}\n\n\tn=sign*n*pow(10.0,(scale+subscale*signsubscale));\t/* number = +/- number.fraction * 10^+/- exponent */\n\t\n\titem->valuedouble=n;\n\titem->valueint=(int64_t)n;\n\titem->type=cJSON_Number;\n\treturn num;\n}\n\nstatic int pow2gt (int x)\t{\t--x;\tx|=x>>1;\tx|=x>>2;\tx|=x>>4;\tx|=x>>8;\tx|=x>>16;\treturn x+1;\t}\n\ntypedef struct {char *buffer; int length; int offset; } printbuffer;\n\nstatic char* ensure(printbuffer *p,int needed)\n{\n\tchar *newbuffer;int newsize;\n\tif (!p || !p->buffer) return 0;\n\tneeded+=p->offset;\n\tif (needed<=p->length) return p->buffer+p->offset;\n\n\tnewsize=pow2gt(needed);\n\tnewbuffer=(char*)cJSON_malloc(newsize);\n\tif (!newbuffer) {cJSON_free(p->buffer);p->length=0,p->buffer=0;return 0;}\n\tif (newbuffer) memcpy(newbuffer,p->buffer,p->length);\n\tcJSON_free(p->buffer);\n\tp->length=newsize;\n\tp->buffer=newbuffer;\n\treturn newbuffer+p->offset;\n}\n\nstatic int update(printbuffer *p)\n{\n\tchar *str;\n\tif (!p || !p->buffer) return 0;\n\tstr=p->buffer+p->offset;\n\treturn p->offset+strlen(str);\n}\n\n/* Render the number nicely from the given item into a string. */\nstatic char *print_number(cJSON *item,printbuffer *p)\n{\n\tchar *str=0;\n\tdouble d=item->valuedouble;\n\tif (d==0)\n\t{\n\t\tif (p)\tstr=ensure(p,2);\n\t\telse\tstr=(char*)cJSON_malloc(2);\t/* special case for 0. */\n\t\tif (str) strcpy(str,\"0\");\n\t}\n\telse if (fabs(((double)item->valueint)-d)<=DBL_EPSILON && d<=LLONG_MAX && d>=LLONG_MIN)\n\t{\n\t\tif (p)\tstr=ensure(p,64);\n\t\telse\tstr=(char*)cJSON_malloc(64);\n\t\tif (str)\tsprintf(str,\"%lld\",(long long) item->valueint);\n\t}\n\telse\n\t{\n\t\tif (p)\tstr=ensure(p,64);\n\t\telse\tstr=(char*)cJSON_malloc(64);\t/* This is a nice tradeoff. */\n\t\tif (str)\n\t\t{\n\t\t\tif (fpclassify(d) != FP_ZERO && !isnormal(d))\t\t\t\tsprintf(str,\"null\");\n\t\t\telse if (fabs(floor(d)-d)<=DBL_EPSILON && fabs(d)<1.0e60)\tsprintf(str,\"%.0f\",d);\n\t\t\telse if (fabs(d)<1.0e-6 || fabs(d)>1.0e9)\t\t\t\t\tsprintf(str,\"%e\",d);\n\t\t\telse\t\t\t\t\t\t\t\t\t\t\t\t\t\tsprintf(str,\"%f\",d);\n\t\t}\n\t}\n\treturn str;\n}\n\nstatic unsigned parse_hex4(const char *str)\n{\n\tunsigned h=0;\n\tif (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;\n\th=h<<4;str++;\n\tif (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;\n\th=h<<4;str++;\n\tif (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;\n\th=h<<4;str++;\n\tif (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;\n\treturn h;\n}\n\n/* Parse the input text into an unescaped cstring, and populate item. */\nstatic const unsigned char firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };\nstatic const char *parse_string(cJSON *item,const char *str,const char **ep)\n{\n\tconst char *ptr=str+1,*end_ptr=str+1;char *ptr2;char *out;int len=0;unsigned uc,uc2;\n\tif (*str!='\\\"') {*ep=str;return 0;}\t/* not a string! */\n\t\n\twhile (*end_ptr!='\\\"' && *end_ptr && ++len) if (*end_ptr++ == '\\\\') end_ptr++;\t/* Skip escaped quotes. */\n\t\n\tout=(char*)cJSON_malloc(len+1);\t/* This is how long we need for the string, roughly. */\n\tif (!out) return 0;\n\titem->valuestring=out; /* assign here so out will be deleted during cJSON_Delete() later */\n\titem->type=cJSON_String;\n\t\n\tptr=str+1;ptr2=out;\n\twhile (ptr < end_ptr)\n\t{\n\t\tif (*ptr!='\\\\') *ptr2++=*ptr++;\n\t\telse\n\t\t{\n\t\t\tptr++;\n\t\t\tswitch (*ptr)\n\t\t\t{\n\t\t\t\tcase 'b': *ptr2++='\\b';\tbreak;\n\t\t\t\tcase 'f': *ptr2++='\\f';\tbreak;\n\t\t\t\tcase 'n': *ptr2++='\\n';\tbreak;\n\t\t\t\tcase 'r': *ptr2++='\\r';\tbreak;\n\t\t\t\tcase 't': *ptr2++='\\t';\tbreak;\n\t\t\t\tcase 'u':\t /* transcode utf16 to utf8. */\n\t\t\t\t\tuc=parse_hex4(ptr+1);ptr+=4;\t/* get the unicode char. */\n\t\t\t\t\tif (ptr >= end_ptr) {*ep=str;return 0;}\t/* invalid */\n\t\t\t\t\t\n\t\t\t\t\tif ((uc>=0xDC00 && uc<=0xDFFF) || uc==0)    {*ep=str;return 0;}\t/* check for invalid.   */\n\t\t\t\t\t\n\t\t\t\t\tif (uc>=0xD800 && uc<=0xDBFF)\t/* UTF16 surrogate pairs.\t*/\n\t\t\t\t\t{\n\t\t\t\t\t\tif (ptr+6 > end_ptr)    {*ep=str;return 0;}\t/* invalid */\n\t\t\t\t\t\tif (ptr[1]!='\\\\' || ptr[2]!='u')    {*ep=str;return 0;}\t/* missing second-half of surrogate.    */\n\t\t\t\t\t\tuc2=parse_hex4(ptr+3);ptr+=6;\n\t\t\t\t\t\tif (uc2<0xDC00 || uc2>0xDFFF)       {*ep=str;return 0;}\t/* invalid second-half of surrogate.    */\n\t\t\t\t\t\tuc=0x10000 + (((uc&0x3FF)<<10) | (uc2&0x3FF));\n\t\t\t\t\t}\n\n\t\t\t\t\tlen=4;if (uc<0x80) len=1;else if (uc<0x800) len=2;else if (uc<0x10000) len=3; ptr2+=len;\n\t\t\t\t\t\n\t\t\t\t\tswitch (len) {\n\t\t\t\t\t\tcase 4: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;\n\t\t\t\t\t\tcase 3: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;\n\t\t\t\t\t\tcase 2: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;\n\t\t\t\t\t\tcase 1: *--ptr2 =(uc | firstByteMark[len]);\n\t\t\t\t\t}\n\t\t\t\t\tptr2+=len;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:  *ptr2++=*ptr; break;\n\t\t\t}\n\t\t\tptr++;\n\t\t}\n\t}\n\t*ptr2=0;\n\tif (*ptr=='\\\"') ptr++;\n\treturn ptr;\n}\n\n/* Render the cstring provided to an escaped version that can be printed. */\nstatic char *print_string_ptr(const char *str,printbuffer *p)\n{\n\tconst char *ptr;char *ptr2,*out;int len=0,flag=0;unsigned char token;\n\n\tif (!str)\n\t{\n\t\tif (p)\tout=ensure(p,3);\n\t\telse\tout=(char*)cJSON_malloc(3);\n\t\tif (!out) return 0;\n\t\tstrcpy(out,\"\\\"\\\"\");\n\t\treturn out;\n\t}\n\t\n\tfor (ptr=str;*ptr;ptr++) flag|=((*ptr>0 && *ptr<32)||(*ptr=='\\\"')||(*ptr=='\\\\'))?1:0;\n\tif (!flag)\n\t{\n\t\tlen=ptr-str;\n\t\tif (p) out=ensure(p,len+3);\n\t\telse\t\tout=(char*)cJSON_malloc(len+3);\n\t\tif (!out) return 0;\n\t\tptr2=out;*ptr2++='\\\"';\n\t\tstrcpy(ptr2,str);\n\t\tptr2[len]='\\\"';\n\t\tptr2[len+1]=0;\n\t\treturn out;\n\t}\n\t\n\tptr=str;while ((token=*ptr) && ++len) {if (strchr(\"\\\"\\\\\\b\\f\\n\\r\\t\",token)) len++; else if (token<32) len+=5;ptr++;}\n\t\n\tif (p)\tout=ensure(p,len+3);\n\telse\tout=(char*)cJSON_malloc(len+3);\n\tif (!out) return 0;\n\n\tptr2=out;ptr=str;\n\t*ptr2++='\\\"';\n\twhile (*ptr)\n\t{\n\t\tif ((unsigned char)*ptr>31 && *ptr!='\\\"' && *ptr!='\\\\') *ptr2++=*ptr++;\n\t\telse\n\t\t{\n\t\t\t*ptr2++='\\\\';\n\t\t\tswitch (token=*ptr++)\n\t\t\t{\n\t\t\t\tcase '\\\\':\t*ptr2++='\\\\';\tbreak;\n\t\t\t\tcase '\\\"':\t*ptr2++='\\\"';\tbreak;\n\t\t\t\tcase '\\b':\t*ptr2++='b';\tbreak;\n\t\t\t\tcase '\\f':\t*ptr2++='f';\tbreak;\n\t\t\t\tcase '\\n':\t*ptr2++='n';\tbreak;\n\t\t\t\tcase '\\r':\t*ptr2++='r';\tbreak;\n\t\t\t\tcase '\\t':\t*ptr2++='t';\tbreak;\n\t\t\t\tdefault: sprintf(ptr2,\"u%04x\",token);ptr2+=5;\tbreak;\t/* escape and print */\n\t\t\t}\n\t\t}\n\t}\n\t*ptr2++='\\\"';*ptr2++=0;\n\treturn out;\n}\n/* Invote print_string_ptr (which is useful) on an item. */\nstatic char *print_string(cJSON *item,printbuffer *p)\t{return print_string_ptr(item->valuestring,p);}\n\n/* Predeclare these prototypes. */\nstatic const char *parse_value(cJSON *item,const char *value,const char **ep);\nstatic char *print_value(cJSON *item,int depth,int fmt,printbuffer *p);\nstatic const char *parse_array(cJSON *item,const char *value,const char **ep);\nstatic char *print_array(cJSON *item,int depth,int fmt,printbuffer *p);\nstatic const char *parse_object(cJSON *item,const char *value,const char **ep);\nstatic char *print_object(cJSON *item,int depth,int fmt,printbuffer *p);\n\n/* Utility to jump whitespace and cr/lf */\nstatic const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}\n\n/* Parse an object - create a new root, and populate. */\ncJSON *cJSON_ParseWithOpts(const char *value,const char **return_parse_end,int require_null_terminated)\n{\n\tconst char *end=0,**ep=return_parse_end?return_parse_end:&global_ep;\n\tcJSON *c=cJSON_New_Item();\n\t*ep=0;\n\tif (!c) return 0;       /* memory fail */\n\n\tend=parse_value(c,skip(value),ep);\n\tif (!end)\t{cJSON_Delete(c);return 0;}\t/* parse failure. ep is set. */\n\n\t/* if we require null-terminated JSON without appended garbage, skip and then check for a null terminator */\n\tif (require_null_terminated) {end=skip(end);if (*end) {cJSON_Delete(c);*ep=end;return 0;}}\n\tif (return_parse_end) *return_parse_end=end;\n\treturn c;\n}\n/* Default options for cJSON_Parse */\ncJSON *cJSON_Parse(const char *value) {return cJSON_ParseWithOpts(value,0,0);}\n\n/* Render a cJSON item/entity/structure to text. */\nchar *cJSON_Print(cJSON *item)\t\t\t\t{return print_value(item,0,1,0);}\nchar *cJSON_PrintUnformatted(cJSON *item)\t{return print_value(item,0,0,0);}\n\nchar *cJSON_PrintBuffered(cJSON *item,int prebuffer,int fmt)\n{\n\tprintbuffer p;\n\tp.buffer=(char*)cJSON_malloc(prebuffer);\n\tp.length=prebuffer;\n\tp.offset=0;\n\treturn print_value(item,0,fmt,&p);\n}\n\n\n/* Parser core - when encountering text, process appropriately. */\nstatic const char *parse_value(cJSON *item,const char *value,const char **ep)\n{\n\tif (!value)\t\t\t\t\t\treturn 0;\t/* Fail on null. */\n\tif (!strncmp(value,\"null\",4))\t{ item->type=cJSON_NULL;  return value+4; }\n\tif (!strncmp(value,\"false\",5))\t{ item->type=cJSON_False; return value+5; }\n\tif (!strncmp(value,\"true\",4))\t{ item->type=cJSON_True; item->valueint=1;\treturn value+4; }\n\tif (*value=='\\\"')\t\t\t\t{ return parse_string(item,value,ep); }\n\tif (*value=='-' || (*value>='0' && *value<='9'))\t{ return parse_number(item,value); }\n\tif (*value=='[')\t\t\t\t{ return parse_array(item,value,ep); }\n\tif (*value=='{')\t\t\t\t{ return parse_object(item,value,ep); }\n\n\t*ep=value;return 0;\t/* failure. */\n}\n\n/* Render a value to text. */\nstatic char *print_value(cJSON *item,int depth,int fmt,printbuffer *p)\n{\n\tchar *out=0;\n\tif (!item) return 0;\n\tif (p)\n\t{\n\t\tswitch ((item->type)&255)\n\t\t{\n\t\t\tcase cJSON_NULL:\t{out=ensure(p,5);\tif (out) strcpy(out,\"null\");\tbreak;}\n\t\t\tcase cJSON_False:\t{out=ensure(p,6);\tif (out) strcpy(out,\"false\");\tbreak;}\n\t\t\tcase cJSON_True:\t{out=ensure(p,5);\tif (out) strcpy(out,\"true\");\tbreak;}\n\t\t\tcase cJSON_Number:\tout=print_number(item,p);break;\n\t\t\tcase cJSON_String:\tout=print_string(item,p);break;\n\t\t\tcase cJSON_Array:\tout=print_array(item,depth,fmt,p);break;\n\t\t\tcase cJSON_Object:\tout=print_object(item,depth,fmt,p);break;\n\t\t}\n\t}\n\telse\n\t{\n\t\tswitch ((item->type)&255)\n\t\t{\n\t\t\tcase cJSON_NULL:\tout=cJSON_strdup(\"null\");\tbreak;\n\t\t\tcase cJSON_False:\tout=cJSON_strdup(\"false\");break;\n\t\t\tcase cJSON_True:\tout=cJSON_strdup(\"true\"); break;\n\t\t\tcase cJSON_Number:\tout=print_number(item,0);break;\n\t\t\tcase cJSON_String:\tout=print_string(item,0);break;\n\t\t\tcase cJSON_Array:\tout=print_array(item,depth,fmt,0);break;\n\t\t\tcase cJSON_Object:\tout=print_object(item,depth,fmt,0);break;\n\t\t}\n\t}\n\treturn out;\n}\n\n/* Build an array from input text. */\nstatic const char *parse_array(cJSON *item,const char *value,const char **ep)\n{\n\tcJSON *child;\n\tif (*value!='[')\t{*ep=value;return 0;}\t/* not an array! */\n\n\titem->type=cJSON_Array;\n\tvalue=skip(value+1);\n\tif (*value==']') return value+1;\t/* empty array. */\n\n\titem->child=child=cJSON_New_Item();\n\tif (!item->child) return 0;\t\t /* memory fail */\n\tvalue=skip(parse_value(child,skip(value),ep));\t/* skip any spacing, get the value. */\n\tif (!value) return 0;\n\n\twhile (*value==',')\n\t{\n\t\tcJSON *new_item;\n\t\tif (!(new_item=cJSON_New_Item())) return 0; \t/* memory fail */\n\t\tchild->next=new_item;new_item->prev=child;child=new_item;\n\t\tvalue=skip(parse_value(child,skip(value+1),ep));\n\t\tif (!value) return 0;\t/* memory fail */\n\t}\n\n\tif (*value==']') return value+1;\t/* end of array */\n\t*ep=value;return 0;\t/* malformed. */\n}\n\n/* Render an array to text */\nstatic char *print_array(cJSON *item,int depth,int fmt,printbuffer *p)\n{\n\tchar **entries;\n\tchar *out=0,*ptr,*ret;int len=5;\n\tcJSON *child=item->child;\n\tint numentries=0,i=0,fail=0;\n\tsize_t tmplen=0;\n\t\n\t/* How many entries in the array? */\n\twhile (child) numentries++,child=child->next;\n\t/* Explicitly handle numentries==0 */\n\tif (!numentries)\n\t{\n\t\tif (p)\tout=ensure(p,3);\n\t\telse\tout=(char*)cJSON_malloc(3);\n\t\tif (out) strcpy(out,\"[]\");\n\t\treturn out;\n\t}\n\n\tif (p)\n\t{\n\t\t/* Compose the output array. */\n\t\ti=p->offset;\n\t\tptr=ensure(p,1);if (!ptr) return 0;\t*ptr='[';\tp->offset++;\n\t\tchild=item->child;\n\t\twhile (child && !fail)\n\t\t{\n\t\t\tprint_value(child,depth+1,fmt,p);\n\t\t\tp->offset=update(p);\n\t\t\tif (child->next) {len=fmt?2:1;ptr=ensure(p,len+1);if (!ptr) return 0;*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;p->offset+=len;}\n\t\t\tchild=child->next;\n\t\t}\n\t\tptr=ensure(p,2);if (!ptr) return 0;\t*ptr++=']';*ptr=0;\n\t\tout=(p->buffer)+i;\n\t}\n\telse\n\t{\n\t\t/* Allocate an array to hold the values for each */\n\t\tentries=(char**)cJSON_malloc(numentries*sizeof(char*));\n\t\tif (!entries) return 0;\n\t\tmemset(entries,0,numentries*sizeof(char*));\n\t\t/* Retrieve all the results: */\n\t\tchild=item->child;\n\t\twhile (child && !fail)\n\t\t{\n\t\t\tret=print_value(child,depth+1,fmt,0);\n\t\t\tentries[i++]=ret;\n\t\t\tif (ret) len+=strlen(ret)+2+(fmt?1:0); else fail=1;\n\t\t\tchild=child->next;\n\t\t}\n\t\t\n\t\t/* If we didn't fail, try to malloc the output string */\n\t\tif (!fail)\tout=(char*)cJSON_malloc(len);\n\t\t/* If that fails, we fail. */\n\t\tif (!out) fail=1;\n\n\t\t/* Handle failure. */\n\t\tif (fail)\n\t\t{\n\t\t\tfor (i=0;i<numentries;i++) if (entries[i]) cJSON_free(entries[i]);\n\t\t\tcJSON_free(entries);\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\t/* Compose the output array. */\n\t\t*out='[';\n\t\tptr=out+1;*ptr=0;\n\t\tfor (i=0;i<numentries;i++)\n\t\t{\n\t\t\ttmplen=strlen(entries[i]);memcpy(ptr,entries[i],tmplen);ptr+=tmplen;\n\t\t\tif (i!=numentries-1) {*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;}\n\t\t\tcJSON_free(entries[i]);\n\t\t}\n\t\tcJSON_free(entries);\n\t\t*ptr++=']';*ptr++=0;\n\t}\n\treturn out;\t\n}\n\n/* Build an object from the text. */\nstatic const char *parse_object(cJSON *item,const char *value,const char **ep)\n{\n\tcJSON *child;\n\tif (*value!='{')\t{*ep=value;return 0;}\t/* not an object! */\n\t\n\titem->type=cJSON_Object;\n\tvalue=skip(value+1);\n\tif (*value=='}') return value+1;\t/* empty array. */\n\t\n\titem->child=child=cJSON_New_Item();\n\tif (!item->child) return 0;\n\tvalue=skip(parse_string(child,skip(value),ep));\n\tif (!value) return 0;\n\tchild->string=child->valuestring;child->valuestring=0;\n\tif (*value!=':') {*ep=value;return 0;}\t/* fail! */\n\tvalue=skip(parse_value(child,skip(value+1),ep));\t/* skip any spacing, get the value. */\n\tif (!value) return 0;\n\t\n\twhile (*value==',')\n\t{\n\t\tcJSON *new_item;\n\t\tif (!(new_item=cJSON_New_Item()))\treturn 0; /* memory fail */\n\t\tchild->next=new_item;new_item->prev=child;child=new_item;\n\t\tvalue=skip(parse_string(child,skip(value+1),ep));\n\t\tif (!value) return 0;\n\t\tchild->string=child->valuestring;child->valuestring=0;\n\t\tif (*value!=':') {*ep=value;return 0;}\t/* fail! */\n\t\tvalue=skip(parse_value(child,skip(value+1),ep));\t/* skip any spacing, get the value. */\n\t\tif (!value) return 0;\n\t}\n\t\n\tif (*value=='}') return value+1;\t/* end of array */\n\t*ep=value;return 0;\t/* malformed. */\n}\n\n/* Render an object to text. */\nstatic char *print_object(cJSON *item,int depth,int fmt,printbuffer *p)\n{\n\tchar **entries=0,**names=0;\n\tchar *out=0,*ptr,*ret,*str;int len=7,i=0,j;\n\tcJSON *child=item->child;\n\tint numentries=0,fail=0;\n\tsize_t tmplen=0;\n\t/* Count the number of entries. */\n\twhile (child) numentries++,child=child->next;\n\t/* Explicitly handle empty object case */\n\tif (!numentries)\n\t{\n\t\tif (p) out=ensure(p,fmt?depth+4:3);\n\t\telse\tout=(char*)cJSON_malloc(fmt?depth+4:3);\n\t\tif (!out)\treturn 0;\n\t\tptr=out;*ptr++='{';\n\t\tif (fmt) {*ptr++='\\n';for (i=0;i<depth;i++) *ptr++='\\t';}\n\t\t*ptr++='}';*ptr++=0;\n\t\treturn out;\n\t}\n\tif (p)\n\t{\n\t\t/* Compose the output: */\n\t\ti=p->offset;\n\t\tlen=fmt?2:1;\tptr=ensure(p,len+1);\tif (!ptr) return 0;\n\t\t*ptr++='{';\tif (fmt) *ptr++='\\n';\t*ptr=0;\tp->offset+=len;\n\t\tchild=item->child;depth++;\n\t\twhile (child)\n\t\t{\n\t\t\tif (fmt)\n\t\t\t{\n\t\t\t\tptr=ensure(p,depth);\tif (!ptr) return 0;\n\t\t\t\tfor (j=0;j<depth;j++) *ptr++='\\t';\n\t\t\t\tp->offset+=depth;\n\t\t\t}\n\t\t\tprint_string_ptr(child->string,p);\n\t\t\tp->offset=update(p);\n\t\t\t\n\t\t\tlen=fmt?2:1;\n\t\t\tptr=ensure(p,len);\tif (!ptr) return 0;\n\t\t\t*ptr++=':';if (fmt) *ptr++='\\t';\n\t\t\tp->offset+=len;\n\t\t\t\n\t\t\tprint_value(child,depth,fmt,p);\n\t\t\tp->offset=update(p);\n\n\t\t\tlen=(fmt?1:0)+(child->next?1:0);\n\t\t\tptr=ensure(p,len+1); if (!ptr) return 0;\n\t\t\tif (child->next) *ptr++=',';\n\t\t\tif (fmt) *ptr++='\\n';*ptr=0;\n\t\t\tp->offset+=len;\n\t\t\tchild=child->next;\n\t\t}\n\t\tptr=ensure(p,fmt?(depth+1):2);\t if (!ptr) return 0;\n\t\tif (fmt)\tfor (i=0;i<depth-1;i++) *ptr++='\\t';\n\t\t*ptr++='}';*ptr=0;\n\t\tout=(p->buffer)+i;\n\t}\n\telse\n\t{\n\t\t/* Allocate space for the names and the objects */\n\t\tentries=(char**)cJSON_malloc(numentries*sizeof(char*));\n\t\tif (!entries) return 0;\n\t\tnames=(char**)cJSON_malloc(numentries*sizeof(char*));\n\t\tif (!names) {cJSON_free(entries);return 0;}\n\t\tmemset(entries,0,sizeof(char*)*numentries);\n\t\tmemset(names,0,sizeof(char*)*numentries);\n\n\t\t/* Collect all the results into our arrays: */\n\t\tchild=item->child;depth++;if (fmt) len+=depth;\n\t\twhile (child && !fail)\n\t\t{\n\t\t\tnames[i]=str=print_string_ptr(child->string,0);\n\t\t\tentries[i++]=ret=print_value(child,depth,fmt,0);\n\t\t\tif (str && ret) len+=strlen(ret)+strlen(str)+2+(fmt?2+depth:0); else fail=1;\n\t\t\tchild=child->next;\n\t\t}\n\t\t\n\t\t/* Try to allocate the output string */\n\t\tif (!fail)\tout=(char*)cJSON_malloc(len);\n\t\tif (!out) fail=1;\n\n\t\t/* Handle failure */\n\t\tif (fail)\n\t\t{\n\t\t\tfor (i=0;i<numentries;i++) {if (names[i]) cJSON_free(names[i]);if (entries[i]) cJSON_free(entries[i]);}\n\t\t\tcJSON_free(names);cJSON_free(entries);\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\t/* Compose the output: */\n\t\t*out='{';ptr=out+1;if (fmt)*ptr++='\\n';*ptr=0;\n\t\tfor (i=0;i<numentries;i++)\n\t\t{\n\t\t\tif (fmt) for (j=0;j<depth;j++) *ptr++='\\t';\n\t\t\ttmplen=strlen(names[i]);memcpy(ptr,names[i],tmplen);ptr+=tmplen;\n\t\t\t*ptr++=':';if (fmt) *ptr++='\\t';\n\t\t\tstrcpy(ptr,entries[i]);ptr+=strlen(entries[i]);\n\t\t\tif (i!=numentries-1) *ptr++=',';\n\t\t\tif (fmt) *ptr++='\\n';*ptr=0;\n\t\t\tcJSON_free(names[i]);cJSON_free(entries[i]);\n\t\t}\n\t\t\n\t\tcJSON_free(names);cJSON_free(entries);\n\t\tif (fmt) for (i=0;i<depth-1;i++) *ptr++='\\t';\n\t\t*ptr++='}';*ptr++=0;\n\t}\n\treturn out;\t\n}\n\n/* Get Array size/item / object item. */\nint    cJSON_GetArraySize(cJSON *array)\t\t\t\t\t\t\t{cJSON *c=array->child;int i=0;while(c)i++,c=c->next;return i;}\ncJSON *cJSON_GetArrayItem(cJSON *array,int item)\t\t\t\t{cJSON *c=array?array->child:0;while (c && item>0) item--,c=c->next; return c;}\ncJSON *cJSON_GetObjectItem(cJSON *object,const char *string)\t{cJSON *c=object?object->child:0;while (c && cJSON_strcasecmp(c->string,string)) c=c->next; return c;}\nint cJSON_HasObjectItem(cJSON *object,const char *string)\t\t{return cJSON_GetObjectItem(object,string)?1:0;}\n\n/* Utility for array list handling. */\nstatic void suffix_object(cJSON *prev,cJSON *item) {prev->next=item;item->prev=prev;}\n/* Utility for handling references. */\nstatic cJSON *create_reference(cJSON *item) {cJSON *ref=cJSON_New_Item();if (!ref) return 0;memcpy(ref,item,sizeof(cJSON));ref->string=0;ref->type|=cJSON_IsReference;ref->next=ref->prev=0;return ref;}\n\n/* Add item to array/object. */\nvoid   cJSON_AddItemToArray(cJSON *array, cJSON *item)\t\t\t\t\t\t{cJSON *c=array->child;if (!item) return; if (!c) {array->child=item;} else {while (c && c->next) c=c->next; suffix_object(c,item);}}\nvoid   cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item)\t{if (!item) return; if (item->string) cJSON_free(item->string);item->string=cJSON_strdup(string);cJSON_AddItemToArray(object,item);}\nvoid   cJSON_AddItemToObjectCS(cJSON *object,const char *string,cJSON *item)\t{if (!item) return; if (!(item->type&cJSON_StringIsConst) && item->string) cJSON_free(item->string);item->string=(char*)string;item->type|=cJSON_StringIsConst;cJSON_AddItemToArray(object,item);}\nvoid\tcJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)\t\t\t\t\t\t{cJSON_AddItemToArray(array,create_reference(item));}\nvoid\tcJSON_AddItemReferenceToObject(cJSON *object,const char *string,cJSON *item)\t{cJSON_AddItemToObject(object,string,create_reference(item));}\n\ncJSON *cJSON_DetachItemFromArray(cJSON *array,int which)\t\t\t{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return 0;\n\tif (c->prev) c->prev->next=c->next;if (c->next) c->next->prev=c->prev;if (c==array->child) array->child=c->next;c->prev=c->next=0;return c;}\nvoid   cJSON_DeleteItemFromArray(cJSON *array,int which)\t\t\t{cJSON_Delete(cJSON_DetachItemFromArray(array,which));}\ncJSON *cJSON_DetachItemFromObject(cJSON *object,const char *string) {int i=0;cJSON *c=object->child;while (c && cJSON_strcasecmp(c->string,string)) i++,c=c->next;if (c) return cJSON_DetachItemFromArray(object,i);return 0;}\nvoid   cJSON_DeleteItemFromObject(cJSON *object,const char *string) {cJSON_Delete(cJSON_DetachItemFromObject(object,string));}\n\n/* Replace array/object items with new ones. */\nvoid   cJSON_InsertItemInArray(cJSON *array,int which,cJSON *newitem)\t\t{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) {cJSON_AddItemToArray(array,newitem);return;}\n\tnewitem->next=c;newitem->prev=c->prev;c->prev=newitem;if (c==array->child) array->child=newitem; else newitem->prev->next=newitem;}\nvoid   cJSON_ReplaceItemInArray(cJSON *array,int which,cJSON *newitem)\t\t{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return;\n\tnewitem->next=c->next;newitem->prev=c->prev;if (newitem->next) newitem->next->prev=newitem;\n\tif (c==array->child) array->child=newitem; else newitem->prev->next=newitem;c->next=c->prev=0;cJSON_Delete(c);}\nvoid   cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem){int i=0;cJSON *c=object->child;while(c && cJSON_strcasecmp(c->string,string))i++,c=c->next;if(c){newitem->string=cJSON_strdup(string);cJSON_ReplaceItemInArray(object,i,newitem);}}\n\n/* Create basic types: */\ncJSON *cJSON_CreateNull(void)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_NULL;return item;}\ncJSON *cJSON_CreateTrue(void)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_True;return item;}\ncJSON *cJSON_CreateFalse(void)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_False;return item;}\ncJSON *cJSON_CreateBool(int b)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}\ncJSON *cJSON_CreateNumber(double num)\t\t\t{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_Number;item->valuedouble=num;item->valueint=(int64_t)num;}return item;}\ncJSON *cJSON_CreateString(const char *string)\t{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_String;item->valuestring=cJSON_strdup(string);if(!item->valuestring){cJSON_Delete(item);return 0;}}return item;}\ncJSON *cJSON_CreateArray(void)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Array;return item;}\ncJSON *cJSON_CreateObject(void)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Object;return item;}\n\n/* Create Arrays: */\ncJSON *cJSON_CreateIntArray(const int *numbers,int count)\t\t{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!n){cJSON_Delete(a);return 0;}if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}\ncJSON *cJSON_CreateFloatArray(const float *numbers,int count)\t{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!n){cJSON_Delete(a);return 0;}if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}\ncJSON *cJSON_CreateDoubleArray(const double *numbers,int count)\t{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!n){cJSON_Delete(a);return 0;}if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}\ncJSON *cJSON_CreateStringArray(const char **strings,int count)\t{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateString(strings[i]);if(!n){cJSON_Delete(a);return 0;}if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}\n\n/* Duplication */\ncJSON *cJSON_Duplicate(cJSON *item,int recurse)\n{\n\tcJSON *newitem,*cptr,*nptr=0,*newchild;\n\t/* Bail on bad ptr */\n\tif (!item) return 0;\n\t/* Create new item */\n\tnewitem=cJSON_New_Item();\n\tif (!newitem) return 0;\n\t/* Copy over all vars */\n\tnewitem->type=item->type&(~cJSON_IsReference),newitem->valueint=item->valueint,newitem->valuedouble=item->valuedouble;\n\tif (item->valuestring)\t{newitem->valuestring=cJSON_strdup(item->valuestring);\tif (!newitem->valuestring)\t{cJSON_Delete(newitem);return 0;}}\n\tif (item->string)\t\t{newitem->string=cJSON_strdup(item->string);\t\t\tif (!newitem->string)\t\t{cJSON_Delete(newitem);return 0;}}\n\t/* If non-recursive, then we're done! */\n\tif (!recurse) return newitem;\n\t/* Walk the ->next chain for the child. */\n\tcptr=item->child;\n\twhile (cptr)\n\t{\n\t\tnewchild=cJSON_Duplicate(cptr,1);\t\t/* Duplicate (with recurse) each item in the ->next chain */\n\t\tif (!newchild) {cJSON_Delete(newitem);return 0;}\n\t\tif (nptr)\t{nptr->next=newchild,newchild->prev=nptr;nptr=newchild;}\t/* If newitem->child already set, then crosswire ->prev and ->next and move on */\n\t\telse\t\t{newitem->child=newchild;nptr=newchild;}\t\t\t\t\t/* Set newitem->child and move to it */\n\t\tcptr=cptr->next;\n\t}\n\treturn newitem;\n}\n\nvoid cJSON_Minify(char *json)\n{\n\tchar *into=json;\n\twhile (*json)\n\t{\n\t\tif (*json==' ') json++;\n\t\telse if (*json=='\\t') json++;\t/* Whitespace characters. */\n\t\telse if (*json=='\\r') json++;\n\t\telse if (*json=='\\n') json++;\n\t\telse if (*json=='/' && json[1]=='/')  while (*json && *json!='\\n') json++;\t/* double-slash comments, to end of line. */\n\t\telse if (*json=='/' && json[1]=='*') {while (*json && !(*json=='*' && json[1]=='/')) json++;json+=2;}\t/* multiline comments. */\n\t\telse if (*json=='\\\"'){*into++=*json++;while (*json && *json!='\\\"'){if (*json=='\\\\') *into++=*json++;*into++=*json++;}*into++=*json++;} /* string literals, which are \\\" sensitive. */\n\t\telse *into++=*json++;\t\t\t/* All other characters. */\n\t}\n\t*into=0;\t/* and null-terminate. */\n}\n", "/*\n  Copyright (c) 2009 Dave Gamble\n \n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n \n  The above copyright notice and this permission notice shall be included in\n  all copies or substantial portions of the Software.\n \n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n  THE SOFTWARE.\n*/\n\n#ifndef cJSON__h\n#define cJSON__h\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n/* cJSON Types: */\n#define cJSON_False  (1 << 0)\n#define cJSON_True   (1 << 1)\n#define cJSON_NULL   (1 << 2)\n#define cJSON_Number (1 << 3)\n#define cJSON_String (1 << 4)\n#define cJSON_Array  (1 << 5)\n#define cJSON_Object (1 << 6)\n\t\n#define cJSON_IsReference 256\n#define cJSON_StringIsConst 512\n\n/* The cJSON structure: */\ntypedef struct cJSON {\n\tstruct cJSON *next,*prev;\t/* next/prev allow you to walk array/object chains. Alternatively, use GetArraySize/GetArrayItem/GetObjectItem */\n\tstruct cJSON *child;\t\t/* An array or object item will have a child pointer pointing to a chain of the items in the array/object. */\n\n\tint type;\t\t\t\t\t/* The type of the item, as above. */\n\n\tchar *valuestring;\t\t\t/* The item's string, if type==cJSON_String */\n\tint64_t valueint;\t\t\t/* The item's number, if type==cJSON_Number */\n\tdouble valuedouble;\t\t\t/* The item's number, if type==cJSON_Number */\n\n\tchar *string;\t\t\t\t/* The item's name string, if this item is the child of, or is in the list of subitems of an object. */\n} cJSON;\n\ntypedef struct cJSON_Hooks {\n      void *(*malloc_fn)(size_t sz);\n      void (*free_fn)(void *ptr);\n} cJSON_Hooks;\n\n/* Supply malloc, realloc and free functions to cJSON */\nextern void cJSON_InitHooks(cJSON_Hooks* hooks);\n\n\n/* Supply a block of JSON, and this returns a cJSON object you can interrogate. Call cJSON_Delete when finished. */\nextern cJSON *cJSON_Parse(const char *value);\n/* Render a cJSON entity to text for transfer/storage. Free the char* when finished. */\nextern char  *cJSON_Print(cJSON *item);\n/* Render a cJSON entity to text for transfer/storage without any formatting. Free the char* when finished. */\nextern char  *cJSON_PrintUnformatted(cJSON *item);\n/* Render a cJSON entity to text using a buffered strategy. prebuffer is a guess at the final size. guessing well reduces reallocation. fmt=0 gives unformatted, =1 gives formatted */\nextern char *cJSON_PrintBuffered(cJSON *item,int prebuffer,int fmt);\n/* Delete a cJSON entity and all subentities. */\nextern void   cJSON_Delete(cJSON *c);\n\n/* Returns the number of items in an array (or object). */\nextern int\t  cJSON_GetArraySize(cJSON *array);\n/* Retrieve item number \"item\" from array \"array\". Returns NULL if unsuccessful. */\nextern cJSON *cJSON_GetArrayItem(cJSON *array,int item);\n/* Get item \"string\" from object. Case insensitive. */\nextern cJSON *cJSON_GetObjectItem(cJSON *object,const char *string);\nextern int cJSON_HasObjectItem(cJSON *object,const char *string);\n/* For analysing failed parses. This returns a pointer to the parse error. You'll probably need to look a few chars back to make sense of it. Defined when cJSON_Parse() returns 0. 0 when cJSON_Parse() succeeds. */\nextern const char *cJSON_GetErrorPtr(void);\n\t\n/* These calls create a cJSON item of the appropriate type. */\nextern cJSON *cJSON_CreateNull(void);\nextern cJSON *cJSON_CreateTrue(void);\nextern cJSON *cJSON_CreateFalse(void);\nextern cJSON *cJSON_CreateBool(int b);\nextern cJSON *cJSON_CreateNumber(double num);\nextern cJSON *cJSON_CreateString(const char *string);\nextern cJSON *cJSON_CreateArray(void);\nextern cJSON *cJSON_CreateObject(void);\n\n/* These utilities create an Array of count items. */\nextern cJSON *cJSON_CreateIntArray(const int *numbers,int count);\nextern cJSON *cJSON_CreateFloatArray(const float *numbers,int count);\nextern cJSON *cJSON_CreateDoubleArray(const double *numbers,int count);\nextern cJSON *cJSON_CreateStringArray(const char **strings,int count);\n\n/* Append item to the specified array/object. */\nextern void cJSON_AddItemToArray(cJSON *array, cJSON *item);\nextern void\tcJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item);\nextern void\tcJSON_AddItemToObjectCS(cJSON *object,const char *string,cJSON *item);\t/* Use this when string is definitely const (i.e. a literal, or as good as), and will definitely survive the cJSON object */\n/* Append reference to item to the specified array/object. Use this when you want to add an existing cJSON to a new cJSON, but don't want to corrupt your existing cJSON. */\nextern void cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item);\nextern void\tcJSON_AddItemReferenceToObject(cJSON *object,const char *string,cJSON *item);\n\n/* Remove/Detatch items from Arrays/Objects. */\nextern cJSON *cJSON_DetachItemFromArray(cJSON *array,int which);\nextern void   cJSON_DeleteItemFromArray(cJSON *array,int which);\nextern cJSON *cJSON_DetachItemFromObject(cJSON *object,const char *string);\nextern void   cJSON_DeleteItemFromObject(cJSON *object,const char *string);\n\t\n/* Update array items. */\nextern void cJSON_InsertItemInArray(cJSON *array,int which,cJSON *newitem);\t/* Shifts pre-existing items to the right. */\nextern void cJSON_ReplaceItemInArray(cJSON *array,int which,cJSON *newitem);\nextern void cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem);\n\n/* Duplicate a cJSON item */\nextern cJSON *cJSON_Duplicate(cJSON *item,int recurse);\n/* Duplicate will create a new, identical cJSON item to the one you pass, in new memory that will\nneed to be released. With recurse!=0, it will duplicate any children connected to the item.\nThe item->next and ->prev pointers are always zero on return from Duplicate. */\n\n/* ParseWithOpts allows you to require (and check) that the JSON is null terminated, and to retrieve the pointer to the final byte parsed. */\n/* If you supply a ptr in return_parse_end and parsing fails, then return_parse_end will contain a pointer to the error. If not, then cJSON_GetErrorPtr() does the job. */\nextern cJSON *cJSON_ParseWithOpts(const char *value,const char **return_parse_end,int require_null_terminated);\n\nextern void cJSON_Minify(char *json);\n\n/* Macros for creating things quickly. */\n#define cJSON_AddNullToObject(object,name)\t\tcJSON_AddItemToObject(object, name, cJSON_CreateNull())\n#define cJSON_AddTrueToObject(object,name)\t\tcJSON_AddItemToObject(object, name, cJSON_CreateTrue())\n#define cJSON_AddFalseToObject(object,name)\t\tcJSON_AddItemToObject(object, name, cJSON_CreateFalse())\n#define cJSON_AddBoolToObject(object,name,b)\tcJSON_AddItemToObject(object, name, cJSON_CreateBool(b))\n#define cJSON_AddNumberToObject(object,name,n)\tcJSON_AddItemToObject(object, name, cJSON_CreateNumber(n))\n#define cJSON_AddStringToObject(object,name,s)\tcJSON_AddItemToObject(object, name, cJSON_CreateString(s))\n\n/* When assigning an integer value, it needs to be propagated to valuedouble too. */\n#define cJSON_SetIntValue(object,val)\t\t\t((object)?(object)->valueint=(object)->valuedouble=(val):(val))\n#define cJSON_SetNumberValue(object,val)\t\t((object)?(object)->valueint=(object)->valuedouble=(val):(val))\n\n/* Macro for iterating over an array */\n#define cJSON_ArrayForEach(pos, head)\t\t\tfor(pos = (head)->child; pos != NULL; pos = pos->next)\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n", "/*\n * iperf, Copyright (c) 2014, 2015, The Regents of the University of\n * California, through Lawrence Berkeley National Laboratory (subject\n * to receipt of any required approvals from the U.S. Dept. of\n * Energy).  All rights reserved.\n *\n * If you have questions about your rights to use or distribute this\n * software, please contact Berkeley Lab's Technology Transfer\n * Department at TTD@lbl.gov.\n *\n * NOTICE.  This software is owned by the U.S. Department of Energy.\n * As such, the U.S. Government has been granted for itself and others\n * acting on its behalf a paid-up, nonexclusive, irrevocable,\n * worldwide license in the Software to reproduce, prepare derivative\n * works, and perform publicly and display publicly.  Beginning five\n * (5) years after the date permission to assert copyright is obtained\n * from the U.S. Department of Energy, and subject to any subsequent\n * five (5) year renewals, the U.S. Government is granted for itself\n * and others acting on its behalf a paid-up, nonexclusive,\n * irrevocable, worldwide license in the Software to reproduce,\n * prepare derivative works, distribute copies to the public, perform\n * publicly and display publicly, and to permit others to do so.\n *\n * This code is distributed under a BSD style license, see the LICENSE file\n * for complete information.\n */\n#define _GNU_SOURCE\n#define __USE_GNU\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <getopt.h>\n#include <errno.h>\n#include <signal.h>\n#include <unistd.h>\n#include <assert.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <pthread.h>\n#include <stdint.h>\n#include <netinet/tcp.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sched.h>\n#include <setjmp.h>\n#include <stdarg.h>\n\n#include \"net.h\"\n#include \"iperf.h\"\n#include \"iperf_api.h\"\n#include \"iperf_udp.h\"\n#include \"iperf_tcp.h\"\n#include \"timer.h\"\n\n#include \"cjson.h\"\n#include \"units.h\"\n#include \"tcp_window_size.h\"\n#include \"iperf_util.h\"\n#include \"iperf_locale.h\"\n\n\n/* Forwards. */\nstatic int send_parameters(struct iperf_test *test);\nstatic int get_parameters(struct iperf_test *test);\nstatic int send_results(struct iperf_test *test);\nstatic int get_results(struct iperf_test *test);\nstatic int diskfile_send(struct iperf_stream *sp);\nstatic int diskfile_recv(struct iperf_stream *sp);\nstatic int JSON_write(int fd, cJSON *json);\nstatic void print_interval_results(struct iperf_test *test, struct iperf_stream *sp, cJSON *json_interval_streams);\nstatic cJSON *JSON_read(int fd);\n\n\n/*************************** Print usage functions ****************************/\n\nvoid\nusage()\n{\n    fputs(usage_shortstr, stderr);\n}\n\n\nvoid\nusage_long()\n{\n    fprintf(stderr, usage_longstr, UDP_RATE / (1024*1024), DURATION, DEFAULT_TCP_BLKSIZE / 1024, DEFAULT_UDP_BLKSIZE / 1024);\n}\n\n\nvoid warning(char *str)\n{\n    fprintf(stderr, \"warning: %s\\n\", str);\n}\n\n\n/************** Getter routines for some fields inside iperf_test *************/\n\nint\niperf_get_verbose(struct iperf_test *ipt)\n{\n    return ipt->verbose;\n}\n\nint\niperf_get_control_socket(struct iperf_test *ipt)\n{\n    return ipt->ctrl_sck;\n}\n\nint\niperf_get_test_omit(struct iperf_test *ipt)\n{\n    return ipt->omit;\n}\n\nint\niperf_get_test_duration(struct iperf_test *ipt)\n{\n    return ipt->duration;\n}\n\nuint64_t\niperf_get_test_rate(struct iperf_test *ipt)\n{\n    return ipt->settings->rate;\n}\n\nint\niperf_get_test_burst(struct iperf_test *ipt)\n{\n    return ipt->settings->burst;\n}\n\nchar\niperf_get_test_role(struct iperf_test *ipt)\n{\n    return ipt->role;\n}\n\nint\niperf_get_test_reverse(struct iperf_test *ipt)\n{\n    return ipt->reverse;\n}\n\nint\niperf_get_test_blksize(struct iperf_test *ipt)\n{\n    return ipt->settings->blksize;\n}\n\nint\niperf_get_test_socket_bufsize(struct iperf_test *ipt)\n{\n    return ipt->settings->socket_bufsize;\n}\n\ndouble\niperf_get_test_reporter_interval(struct iperf_test *ipt)\n{\n    return ipt->reporter_interval;\n}\n\ndouble\niperf_get_test_stats_interval(struct iperf_test *ipt)\n{\n    return ipt->stats_interval;\n}\n\nint\niperf_get_test_num_streams(struct iperf_test *ipt)\n{\n    return ipt->num_streams;\n}\n\nint\niperf_get_test_server_port(struct iperf_test *ipt)\n{\n    return ipt->server_port;\n}\n\nchar*\niperf_get_test_server_hostname(struct iperf_test *ipt)\n{\n    return ipt->server_hostname;\n}\n\nint\niperf_get_test_protocol_id(struct iperf_test *ipt)\n{\n    return ipt->protocol->id;\n}\n\nint\niperf_get_test_json_output(struct iperf_test *ipt)\n{\n    return ipt->json_output;\n}\n\nint\niperf_get_test_zerocopy(struct iperf_test *ipt)\n{\n    return ipt->zerocopy;\n}\n\nint\niperf_get_test_get_server_output(struct iperf_test *ipt)\n{\n    return ipt->get_server_output;\n}\n\nchar\niperf_get_test_unit_format(struct iperf_test *ipt)\n{\n    return ipt->settings->unit_format;\n}\n\nchar *\niperf_get_test_bind_address(struct iperf_test *ipt)\n{\n    return ipt->bind_address;\n}\n\nint\niperf_get_test_one_off(struct iperf_test *ipt)\n{\n    return ipt->one_off;\n}\n\n/************** Setter routines for some fields inside iperf_test *************/\n\nvoid\niperf_set_verbose(struct iperf_test *ipt, int verbose)\n{\n    ipt->verbose = verbose;\n}\n\nvoid\niperf_set_control_socket(struct iperf_test *ipt, int ctrl_sck)\n{\n    ipt->ctrl_sck = ctrl_sck;\n}\n\nvoid\niperf_set_test_omit(struct iperf_test *ipt, int omit)\n{\n    ipt->omit = omit;\n}\n\nvoid\niperf_set_test_duration(struct iperf_test *ipt, int duration)\n{\n    ipt->duration = duration;\n}\n\nvoid\niperf_set_test_reporter_interval(struct iperf_test *ipt, double reporter_interval)\n{\n    ipt->reporter_interval = reporter_interval;\n}\n\nvoid\niperf_set_test_stats_interval(struct iperf_test *ipt, double stats_interval)\n{\n    ipt->stats_interval = stats_interval;\n}\n\nvoid\niperf_set_test_state(struct iperf_test *ipt, signed char state)\n{\n    ipt->state = state;\n}\n\nvoid\niperf_set_test_blksize(struct iperf_test *ipt, int blksize)\n{\n    ipt->settings->blksize = blksize;\n}\n\nvoid\niperf_set_test_rate(struct iperf_test *ipt, uint64_t rate)\n{\n    ipt->settings->rate = rate;\n}\n\nvoid\niperf_set_test_burst(struct iperf_test *ipt, int burst)\n{\n    ipt->settings->burst = burst;\n}\n\nvoid\niperf_set_test_server_port(struct iperf_test *ipt, int server_port)\n{\n    ipt->server_port = server_port;\n}\n\nvoid\niperf_set_test_socket_bufsize(struct iperf_test *ipt, int socket_bufsize)\n{\n    ipt->settings->socket_bufsize = socket_bufsize;\n}\n\nvoid\niperf_set_test_num_streams(struct iperf_test *ipt, int num_streams)\n{\n    ipt->num_streams = num_streams;\n}\n\nstatic void\ncheck_sender_has_retransmits(struct iperf_test *ipt)\n{\n    if (ipt->sender && ipt->protocol->id == Ptcp && has_tcpinfo_retransmits())\n\tipt->sender_has_retransmits = 1;\n    else\n\tipt->sender_has_retransmits = 0;\n}\n\nvoid\niperf_set_test_role(struct iperf_test *ipt, char role)\n{\n    ipt->role = role;\n    if (role == 'c')\n\tipt->sender = 1;\n    else if (role == 's')\n\tipt->sender = 0;\n    if (ipt->reverse)\n        ipt->sender = ! ipt->sender;\n    check_sender_has_retransmits(ipt);\n}\n\nvoid\niperf_set_test_server_hostname(struct iperf_test *ipt, char *server_hostname)\n{\n    ipt->server_hostname = strdup(server_hostname);\n}\n\nvoid\niperf_set_test_reverse(struct iperf_test *ipt, int reverse)\n{\n    ipt->reverse = reverse;\n    if (ipt->reverse)\n        ipt->sender = ! ipt->sender;\n    check_sender_has_retransmits(ipt);\n}\n\nvoid\niperf_set_test_json_output(struct iperf_test *ipt, int json_output)\n{\n    ipt->json_output = json_output;\n}\n\nint\niperf_has_zerocopy( void )\n{\n    return has_sendfile();\n}\n\nvoid\niperf_set_test_zerocopy(struct iperf_test *ipt, int zerocopy)\n{\n    ipt->zerocopy = (zerocopy && has_sendfile());\n}\n\nvoid\niperf_set_test_get_server_output(struct iperf_test *ipt, int get_server_output)\n{\n    ipt->get_server_output = get_server_output;\n}\n\nvoid\niperf_set_test_unit_format(struct iperf_test *ipt, char unit_format)\n{\n    ipt->settings->unit_format = unit_format;\n}\n\nvoid\niperf_set_test_bind_address(struct iperf_test *ipt, char *bind_address)\n{\n    ipt->bind_address = strdup(bind_address);\n}\n\nvoid\niperf_set_test_one_off(struct iperf_test *ipt, int one_off)\n{\n    ipt->one_off = one_off;\n}\n\n/********************** Get/set test protocol structure ***********************/\n\nstruct protocol *\nget_protocol(struct iperf_test *test, int prot_id)\n{\n    struct protocol *prot;\n\n    SLIST_FOREACH(prot, &test->protocols, protocols) {\n        if (prot->id == prot_id)\n            break;\n    }\n\n    if (prot == NULL)\n        i_errno = IEPROTOCOL;\n\n    return prot;\n}\n\nint\nset_protocol(struct iperf_test *test, int prot_id)\n{\n    struct protocol *prot = NULL;\n\n    SLIST_FOREACH(prot, &test->protocols, protocols) {\n        if (prot->id == prot_id) {\n            test->protocol = prot;\n\t    check_sender_has_retransmits(test);\n            return 0;\n        }\n    }\n\n    i_errno = IEPROTOCOL;\n    return -1;\n}\n\n\n/************************** Iperf callback functions **************************/\n\nvoid\niperf_on_new_stream(struct iperf_stream *sp)\n{\n    connect_msg(sp);\n}\n\nvoid\niperf_on_test_start(struct iperf_test *test)\n{\n    if (test->json_output) {\n\tcJSON_AddItemToObject(test->json_start, \"test_start\", iperf_json_printf(\"protocol: %s  num_streams: %d  blksize: %d  omit: %d  duration: %d  bytes: %d  blocks: %d  reverse: %d\", test->protocol->name, (int64_t) test->num_streams, (int64_t) test->settings->blksize, (int64_t) test->omit, (int64_t) test->duration, (int64_t) test->settings->bytes, (int64_t) test->settings->blocks, test->reverse?(int64_t)1:(int64_t)0));\n    } else {\n\tif (test->verbose) {\n\t    if (test->settings->bytes)\n\t\tiprintf(test, test_start_bytes, test->protocol->name, test->num_streams, test->settings->blksize, test->omit, test->settings->bytes);\n\t    else if (test->settings->blocks)\n\t\tiprintf(test, test_start_blocks, test->protocol->name, test->num_streams, test->settings->blksize, test->omit, test->settings->blocks);\n\t    else\n\t\tiprintf(test, test_start_time, test->protocol->name, test->num_streams, test->settings->blksize, test->omit, test->duration);\n\t}\n    }\n}\n\n/* This converts an IPv6 string address from IPv4-mapped format into regular\n** old IPv4 format, which is easier on the eyes of network veterans.\n**\n** If the v6 address is not v4-mapped it is left alone.\n*/\nstatic void\nmapped_v4_to_regular_v4(char *str)\n{\n    char *prefix = \"::ffff:\";\n    int prefix_len;\n\n    prefix_len = strlen(prefix);\n    if (strncmp(str, prefix, prefix_len) == 0) {\n\tint str_len = strlen(str);\n\tmemmove(str, str + prefix_len, str_len - prefix_len + 1);\n    }\n}\n\nvoid\niperf_on_connect(struct iperf_test *test)\n{\n    time_t now_secs;\n    const char* rfc1123_fmt = \"%a, %d %b %Y %H:%M:%S GMT\";\n    char now_str[100];\n    char ipr[INET6_ADDRSTRLEN];\n    int port;\n    struct sockaddr_storage sa;\n    struct sockaddr_in *sa_inP;\n    struct sockaddr_in6 *sa_in6P;\n    socklen_t len;\n    int opt;\n\n    now_secs = time((time_t*) 0);\n    (void) strftime(now_str, sizeof(now_str), rfc1123_fmt, gmtime(&now_secs));\n    if (test->json_output)\n\tcJSON_AddItemToObject(test->json_start, \"timestamp\", iperf_json_printf(\"time: %s  timesecs: %d\", now_str, (int64_t) now_secs));\n    else if (test->verbose)\n\tiprintf(test, report_time, now_str);\n\n    if (test->role == 'c') {\n\tif (test->json_output)\n\t    cJSON_AddItemToObject(test->json_start, \"connecting_to\", iperf_json_printf(\"host: %s  port: %d\", test->server_hostname, (int64_t) test->server_port));\n\telse {\n\t    iprintf(test, report_connecting, test->server_hostname, test->server_port);\n\t    if (test->reverse)\n\t\tiprintf(test, report_reverse, test->server_hostname);\n\t}\n    } else {\n        len = sizeof(sa);\n        getpeername(test->ctrl_sck, (struct sockaddr *) &sa, &len);\n        if (getsockdomain(test->ctrl_sck) == AF_INET) {\n\t    sa_inP = (struct sockaddr_in *) &sa;\n            inet_ntop(AF_INET, &sa_inP->sin_addr, ipr, sizeof(ipr));\n\t    port = ntohs(sa_inP->sin_port);\n        } else {\n\t    sa_in6P = (struct sockaddr_in6 *) &sa;\n            inet_ntop(AF_INET6, &sa_in6P->sin6_addr, ipr, sizeof(ipr));\n\t    port = ntohs(sa_in6P->sin6_port);\n        }\n\tmapped_v4_to_regular_v4(ipr);\n\tif (test->json_output)\n\t    cJSON_AddItemToObject(test->json_start, \"accepted_connection\", iperf_json_printf(\"host: %s  port: %d\", ipr, (int64_t) port));\n\telse\n\t    iprintf(test, report_accepted, ipr, port);\n    }\n    if (test->json_output) {\n\tcJSON_AddStringToObject(test->json_start, \"cookie\", test->cookie);\n        if (test->protocol->id == SOCK_STREAM) {\n\t    if (test->settings->mss)\n\t\tcJSON_AddNumberToObject(test->json_start, \"tcp_mss\", test->settings->mss);\n\t    else {\n\t\tlen = sizeof(opt);\n\t\tgetsockopt(test->ctrl_sck, IPPROTO_TCP, TCP_MAXSEG, &opt, &len);\n\t\tcJSON_AddNumberToObject(test->json_start, \"tcp_mss_default\", opt);\n\t    }\n\t}\n    } else if (test->verbose) {\n        iprintf(test, report_cookie, test->cookie);\n        if (test->protocol->id == SOCK_STREAM) {\n            if (test->settings->mss)\n                iprintf(test, \"      TCP MSS: %d\\n\", test->settings->mss);\n            else {\n                len = sizeof(opt);\n                getsockopt(test->ctrl_sck, IPPROTO_TCP, TCP_MAXSEG, &opt, &len);\n                iprintf(test, \"      TCP MSS: %d (default)\\n\", opt);\n            }\n        }\n\n    }\n}\n\nvoid\niperf_on_test_finish(struct iperf_test *test)\n{\n}\n\n\n/******************************************************************************/\n\nint\niperf_parse_arguments(struct iperf_test *test, int argc, char **argv)\n{\n    static struct option longopts[] =\n    {\n        {\"port\", required_argument, NULL, 'p'},\n        {\"format\", required_argument, NULL, 'f'},\n        {\"interval\", required_argument, NULL, 'i'},\n        {\"daemon\", no_argument, NULL, 'D'},\n        {\"one-off\", no_argument, NULL, '1'},\n        {\"verbose\", no_argument, NULL, 'V'},\n        {\"json\", no_argument, NULL, 'J'},\n        {\"version\", no_argument, NULL, 'v'},\n        {\"server\", no_argument, NULL, 's'},\n        {\"client\", required_argument, NULL, 'c'},\n        {\"udp\", no_argument, NULL, 'u'},\n        {\"bandwidth\", required_argument, NULL, 'b'},\n        {\"time\", required_argument, NULL, 't'},\n        {\"bytes\", required_argument, NULL, 'n'},\n        {\"blockcount\", required_argument, NULL, 'k'},\n        {\"length\", required_argument, NULL, 'l'},\n        {\"parallel\", required_argument, NULL, 'P'},\n        {\"reverse\", no_argument, NULL, 'R'},\n        {\"window\", required_argument, NULL, 'w'},\n        {\"bind\", required_argument, NULL, 'B'},\n        {\"set-mss\", required_argument, NULL, 'M'},\n        {\"no-delay\", no_argument, NULL, 'N'},\n        {\"version4\", no_argument, NULL, '4'},\n        {\"version6\", no_argument, NULL, '6'},\n        {\"tos\", required_argument, NULL, 'S'},\n        {\"flowlabel\", required_argument, NULL, 'L'},\n        {\"zerocopy\", no_argument, NULL, 'Z'},\n        {\"omit\", required_argument, NULL, 'O'},\n        {\"file\", required_argument, NULL, 'F'},\n        {\"affinity\", required_argument, NULL, 'A'},\n        {\"title\", required_argument, NULL, 'T'},\n#if defined(linux) && defined(TCP_CONGESTION)\n        {\"linux-congestion\", required_argument, NULL, 'C'},\n#endif\n\t{\"get-server-output\", no_argument, NULL, OPT_GET_SERVER_OUTPUT},\n        {\"debug\", no_argument, NULL, 'd'},\n        {\"help\", no_argument, NULL, 'h'},\n        {NULL, 0, NULL, 0}\n    };\n    int flag;\n    int blksize;\n    int server_flag, client_flag, rate_flag, duration_flag;\n    char* comma;\n    char* slash;\n\n    blksize = 0;\n    server_flag = client_flag = rate_flag = duration_flag = 0;\n    while ((flag = getopt_long(argc, argv, \"p:f:i:D1VJvsc:ub:t:n:k:l:P:Rw:B:M:N46S:L:ZO:F:A:T:C:dh\", longopts, NULL)) != -1) {\n        switch (flag) {\n            case 'p':\n                test->server_port = atoi(optarg);\n                break;\n            case 'f':\n                test->settings->unit_format = *optarg;\n                break;\n            case 'i':\n                /* XXX: could potentially want separate stat collection and reporting intervals,\n                   but just set them to be the same for now */\n                test->stats_interval = test->reporter_interval = atof(optarg);\n                if ((test->stats_interval < MIN_INTERVAL || test->stats_interval > MAX_INTERVAL) && test->stats_interval != 0) {\n                    i_errno = IEINTERVAL;\n                    return -1;\n                }\n                break;\n            case 'D':\n\t\ttest->daemon = 1;\n\t\tserver_flag = 1;\n\t        break;\n            case '1':\n\t\ttest->one_off = 1;\n\t\tserver_flag = 1;\n\t        break;\n            case 'V':\n                test->verbose = 1;\n                break;\n            case 'J':\n                test->json_output = 1;\n                break;\n            case 'v':\n                printf(\"%s\\n\", version);\n\t\tsystem(\"uname -a\");\n                exit(0);\n            case 's':\n                if (test->role == 'c') {\n                    i_errno = IESERVCLIENT;\n                    return -1;\n                }\n\t\tiperf_set_test_role(test, 's');\n                break;\n            case 'c':\n                if (test->role == 's') {\n                    i_errno = IESERVCLIENT;\n                    return -1;\n                }\n\t\tiperf_set_test_role(test, 'c');\n\t\tiperf_set_test_server_hostname(test, optarg);\n                break;\n            case 'u':\n                set_protocol(test, Pudp);\n\t\tclient_flag = 1;\n                break;\n            case 'b':\n\t\tslash = strchr(optarg, '/');\n\t\tif (slash) {\n\t\t    *slash = '\\0';\n\t\t    ++slash;\n\t\t    test->settings->burst = atoi(slash);\n\t\t    if (test->settings->burst <= 0 ||\n\t\t        test->settings->burst > MAX_BURST) {\n\t\t\ti_errno = IEBURST;\n\t\t\treturn -1;\n\t\t    }\n\t\t}\n                test->settings->rate = unit_atof_rate(optarg);\n\t\trate_flag = 1;\n\t\tclient_flag = 1;\n                break;\n            case 't':\n                test->duration = atoi(optarg);\n                if (test->duration > MAX_TIME) {\n                    i_errno = IEDURATION;\n                    return -1;\n                }\n\t\tduration_flag = 1;\n\t\tclient_flag = 1;\n                break;\n            case 'n':\n                test->settings->bytes = unit_atoi(optarg);\n\t\tclient_flag = 1;\n                break;\n            case 'k':\n                test->settings->blocks = unit_atoi(optarg);\n\t\tclient_flag = 1;\n                break;\n            case 'l':\n                blksize = unit_atoi(optarg);\n\t\tclient_flag = 1;\n                break;\n            case 'P':\n                test->num_streams = atoi(optarg);\n                if (test->num_streams > MAX_STREAMS) {\n                    i_errno = IENUMSTREAMS;\n                    return -1;\n                }\n\t\tclient_flag = 1;\n                break;\n            case 'R':\n\t\tiperf_set_test_reverse(test, 1);\n\t\tclient_flag = 1;\n                break;\n            case 'w':\n                // XXX: This is a socket buffer, not specific to TCP\n                test->settings->socket_bufsize = unit_atof(optarg);\n                if (test->settings->socket_bufsize > MAX_TCP_BUFFER) {\n                    i_errno = IEBUFSIZE;\n                    return -1;\n                }\n\t\tclient_flag = 1;\n                break;\n            case 'B':\n                test->bind_address = strdup(optarg);\n                break;\n            case 'M':\n                test->settings->mss = atoi(optarg);\n                if (test->settings->mss > MAX_MSS) {\n                    i_errno = IEMSS;\n                    return -1;\n                }\n\t\tclient_flag = 1;\n                break;\n            case 'N':\n                test->no_delay = 1;\n\t\tclient_flag = 1;\n                break;\n            case '4':\n                test->settings->domain = AF_INET;\n                break;\n            case '6':\n                test->settings->domain = AF_INET6;\n                break;\n            case 'S':\n                test->settings->tos = strtol(optarg, NULL, 0);\n\t\tclient_flag = 1;\n                break;\n            case 'L':\n#if defined(linux)\n                test->settings->flowlabel = strtol(optarg, NULL, 0);\n\t\tif (test->settings->flowlabel < 1 || test->settings->flowlabel > 0xfffff) {\n                    i_errno = IESETFLOW;\n                    return -1;\n\t\t}\n\t\tclient_flag = 1;\n#else /* linux */\n                i_errno = IEUNIMP;\n                return -1;\n#endif /* linux */\n                break;\n            case 'Z':\n                if (!has_sendfile()) {\n                    i_errno = IENOSENDFILE;\n                    return -1;\n                }\n                test->zerocopy = 1;\n\t\tclient_flag = 1;\n                break;\n            case 'O':\n                test->omit = atoi(optarg);\n                if (test->omit < 0 || test->omit > 60) {\n                    i_errno = IEOMIT;\n                    return -1;\n                }\n\t\tclient_flag = 1;\n                break;\n            case 'F':\n                test->diskfile_name = optarg;\n                break;\n            case 'A':\n                test->affinity = atoi(optarg);\n                if (test->affinity < 0 || test->affinity > 1024) {\n                    i_errno = IEAFFINITY;\n                    return -1;\n                }\n\t\tcomma = strchr(optarg, ',');\n\t\tif (comma != NULL) {\n\t\t    test->server_affinity = atoi(comma+1);\n\t\t    if (test->server_affinity < 0 || test->server_affinity > 1024) {\n\t\t\ti_errno = IEAFFINITY;\n\t\t\treturn -1;\n\t\t    }\n\t\t    client_flag = 1;\n\t\t}\n                break;\n            case 'T':\n                test->title = strdup(optarg);\n\t\tclient_flag = 1;\n                break;\n\t    case 'C':\n#if defined(linux) && defined(TCP_CONGESTION)\n\t\ttest->congestion = strdup(optarg);\n\t\tclient_flag = 1;\n#else /* linux */\n\t\ti_errno = IEUNIMP;\n\t\treturn -1;\n#endif /* linux */\n\t\tbreak;\n\t    case 'd':\n\t\ttest->debug = 1;\n\t\tbreak;\n\t    case OPT_GET_SERVER_OUTPUT:\n\t\ttest->get_server_output = 1;\n\t\tclient_flag = 1;\n\t\tbreak;\n            case 'h':\n            default:\n                usage_long();\n                exit(1);\n        }\n    }\n\n    /* Check flag / role compatibility. */\n    if (test->role == 'c' && server_flag) {\n\ti_errno = IESERVERONLY;\n\treturn -1;\n    }\n    if (test->role == 's' && client_flag) {\n\ti_errno = IECLIENTONLY;\n\treturn -1;\n    }\n\n    if (blksize == 0) {\n\tif (test->protocol->id == Pudp)\n\t    blksize = DEFAULT_UDP_BLKSIZE;\n\telse\n\t    blksize = DEFAULT_TCP_BLKSIZE;\n    }\n    if (blksize <= 0 || blksize > MAX_BLOCKSIZE) {\n\ti_errno = IEBLOCKSIZE;\n\treturn -1;\n    }\n    if (test->protocol->id == Pudp &&\n\tblksize > MAX_UDP_BLOCKSIZE) {\n\ti_errno = IEUDPBLOCKSIZE;\n\treturn -1;\n    }\n    test->settings->blksize = blksize;\n\n    if (!rate_flag)\n\ttest->settings->rate = test->protocol->id == Pudp ? UDP_RATE : 0;\n\n    if ((test->settings->bytes != 0 || test->settings->blocks != 0) && ! duration_flag)\n        test->duration = 0;\n\n    /* Disallow specifying multiple test end conditions. The code actually\n    ** works just fine without this prohibition. As soon as any one of the\n    ** three possible end conditions is met, the test ends. So this check\n    ** could be removed if desired.\n    */\n    if ((duration_flag && test->settings->bytes != 0) ||\n        (duration_flag && test->settings->blocks != 0) ||\n\t(test->settings->bytes != 0 && test->settings->blocks != 0)) {\n        i_errno = IEENDCONDITIONS;\n        return -1;\n    }\n\n    /* For subsequent calls to getopt */\n#ifdef __APPLE__\n    optreset = 1;\n#endif\n    optind = 0;\n\n    if ((test->role != 'c') && (test->role != 's')) {\n        i_errno = IENOROLE;\n        return -1;\n    }\n\n    return 0;\n}\n\nint\niperf_set_send_state(struct iperf_test *test, signed char state)\n{\n    test->state = state;\n    if (Nwrite(test->ctrl_sck, (char*) &state, sizeof(state), Ptcp) < 0) {\n\ti_errno = IESENDMESSAGE;\n\treturn -1;\n    }\n    return 0;\n}\n\nvoid\niperf_check_throttle(struct iperf_stream *sp, struct timeval *nowP)\n{\n    double seconds;\n    uint64_t bits_per_second;\n\n    if (sp->test->done)\n        return;\n    seconds = timeval_diff(&sp->result->start_time, nowP);\n    bits_per_second = sp->result->bytes_sent * 8 / seconds;\n    if (bits_per_second < sp->test->settings->rate) {\n        sp->green_light = 1;\n        FD_SET(sp->socket, &sp->test->write_set);\n    } else {\n        sp->green_light = 0;\n        FD_CLR(sp->socket, &sp->test->write_set);\n    }\n}\n\nint\niperf_send(struct iperf_test *test, fd_set *write_setP)\n{\n    register int multisend, r, streams_active;\n    register struct iperf_stream *sp;\n    struct timeval now;\n\n    /* Can we do multisend mode? */\n    if (test->settings->burst != 0)\n        multisend = test->settings->burst;\n    else if (test->settings->rate == 0)\n        multisend = test->multisend;\n    else\n        multisend = 1;\t/* nope */\n\n    for (; multisend > 0; --multisend) {\n\tif (test->settings->rate != 0 && test->settings->burst == 0)\n\t    gettimeofday(&now, NULL);\n\tstreams_active = 0;\n\tSLIST_FOREACH(sp, &test->streams, streams) {\n\t    if (sp->green_light &&\n\t        (write_setP == NULL || FD_ISSET(sp->socket, write_setP))) {\n\t\tif ((r = sp->snd(sp)) < 0) {\n\t\t    if (r == NET_SOFTERROR)\n\t\t\tbreak;\n\t\t    i_errno = IESTREAMWRITE;\n\t\t    return r;\n\t\t}\n\t\tstreams_active = 1;\n\t\ttest->bytes_sent += r;\n\t\t++test->blocks_sent;\n\t\tif (test->settings->rate != 0 && test->settings->burst == 0)\n\t\t    iperf_check_throttle(sp, &now);\n\t\tif (multisend > 1 && test->settings->bytes != 0 && test->bytes_sent >= test->settings->bytes)\n\t\t    break;\n\t\tif (multisend > 1 && test->settings->blocks != 0 && test->blocks_sent >= test->settings->blocks)\n\t\t    break;\n\t    }\n\t}\n\tif (!streams_active)\n\t    break;\n    }\n    if (test->settings->burst != 0) {\n\tgettimeofday(&now, NULL);\n\tSLIST_FOREACH(sp, &test->streams, streams)\n\t    iperf_check_throttle(sp, &now);\n    }\n    if (write_setP != NULL)\n\tSLIST_FOREACH(sp, &test->streams, streams)\n\t    if (FD_ISSET(sp->socket, write_setP))\n\t\tFD_CLR(sp->socket, write_setP);\n\n    return 0;\n}\n\nint\niperf_recv(struct iperf_test *test, fd_set *read_setP)\n{\n    int r;\n    struct iperf_stream *sp;\n\n    SLIST_FOREACH(sp, &test->streams, streams) {\n\tif (FD_ISSET(sp->socket, read_setP)) {\n\t    if ((r = sp->rcv(sp)) < 0) {\n\t\ti_errno = IESTREAMREAD;\n\t\treturn r;\n\t    }\n\t    test->bytes_sent += r;\n\t    ++test->blocks_sent;\n\t    FD_CLR(sp->socket, read_setP);\n\t}\n    }\n\n    return 0;\n}\n\nint\niperf_init_test(struct iperf_test *test)\n{\n    struct timeval now;\n    struct iperf_stream *sp;\n\n    if (test->protocol->init) {\n        if (test->protocol->init(test) < 0)\n            return -1;\n    }\n\n    /* Init each stream. */\n    if (gettimeofday(&now, NULL) < 0) {\n\ti_errno = IEINITTEST;\n\treturn -1;\n    }\n    SLIST_FOREACH(sp, &test->streams, streams) {\n\tsp->result->start_time = now;\n    }\n\n    if (test->on_test_start)\n        test->on_test_start(test);\n\n    return 0;\n}\n\nstatic void\nsend_timer_proc(TimerClientData client_data, struct timeval *nowP)\n{\n    struct iperf_stream *sp = client_data.p;\n\n    /* All we do here is set or clear the flag saying that this stream may\n    ** be sent to.  The actual sending gets done in the send proc, after\n    ** checking the flag.\n    */\n    iperf_check_throttle(sp, nowP);\n}\n\nint\niperf_create_send_timers(struct iperf_test * test)\n{\n    struct timeval now;\n    struct iperf_stream *sp;\n    TimerClientData cd;\n\n    if (gettimeofday(&now, NULL) < 0) {\n\ti_errno = IEINITTEST;\n\treturn -1;\n    }\n    SLIST_FOREACH(sp, &test->streams, streams) {\n        sp->green_light = 1;\n\tif (test->settings->rate != 0) {\n\t    cd.p = sp;\n\t    sp->send_timer = tmr_create((struct timeval*) 0, send_timer_proc, cd, 100000L, 1);\n\t    /* (Repeat every tenth second - arbitrary often value.) */\n\t    if (sp->send_timer == NULL) {\n\t\ti_errno = IEINITTEST;\n\t\treturn -1;\n\t    }\n\t}\n    }\n    return 0;\n}\n\n/**\n * iperf_exchange_parameters - handles the param_Exchange part for client\n *\n */\n\nint\niperf_exchange_parameters(struct iperf_test *test)\n{\n    int s;\n    int32_t err;\n\n    if (test->role == 'c') {\n\n        if (send_parameters(test) < 0)\n            return -1;\n\n    } else {\n\n        if (get_parameters(test) < 0)\n            return -1;\n\n        if ((s = test->protocol->listen(test)) < 0) {\n\t    if (iperf_set_send_state(test, SERVER_ERROR) != 0)\n                return -1;\n            err = htonl(i_errno);\n            if (Nwrite(test->ctrl_sck, (char*) &err, sizeof(err), Ptcp) < 0) {\n                i_errno = IECTRLWRITE;\n                return -1;\n            }\n            err = htonl(errno);\n            if (Nwrite(test->ctrl_sck, (char*) &err, sizeof(err), Ptcp) < 0) {\n                i_errno = IECTRLWRITE;\n                return -1;\n            }\n            return -1;\n        }\n        FD_SET(s, &test->read_set);\n        test->max_fd = (s > test->max_fd) ? s : test->max_fd;\n        test->prot_listener = s;\n\n        // Send the control message to create streams and start the test\n\tif (iperf_set_send_state(test, CREATE_STREAMS) != 0)\n            return -1;\n\n    }\n\n    return 0;\n}\n\n/*************************************************************/\n\nint\niperf_exchange_results(struct iperf_test *test)\n{\n    if (test->role == 'c') {\n        /* Send results to server. */\n\tif (send_results(test) < 0)\n            return -1;\n        /* Get server results. */\n        if (get_results(test) < 0)\n            return -1;\n    } else {\n        /* Get client results. */\n        if (get_results(test) < 0)\n            return -1;\n        /* Send results to client. */\n\tif (send_results(test) < 0)\n            return -1;\n    }\n    return 0;\n}\n\n/*************************************************************/\n\nstatic int\nsend_parameters(struct iperf_test *test)\n{\n    int r = 0;\n    cJSON *j;\n\n    j = cJSON_CreateObject();\n    if (j == NULL) {\n\ti_errno = IESENDPARAMS;\n\tr = -1;\n    } else {\n\tif (test->protocol->id == Ptcp)\n\t    cJSON_AddTrueToObject(j, \"tcp\");\n\telse if (test->protocol->id == Pudp)\n\t    cJSON_AddTrueToObject(j, \"udp\");\n\tcJSON_AddNumberToObject(j, \"omit\", test->omit);\n\tif (test->server_affinity != -1)\n\t    cJSON_AddNumberToObject(j, \"server_affinity\", test->server_affinity);\n\tif (test->duration)\n\t    cJSON_AddNumberToObject(j, \"time\", test->duration);\n\tif (test->settings->bytes)\n\t    cJSON_AddNumberToObject(j, \"num\", test->settings->bytes);\n\tif (test->settings->blocks)\n\t    cJSON_AddNumberToObject(j, \"blockcount\", test->settings->blocks);\n\tif (test->settings->mss)\n\t    cJSON_AddNumberToObject(j, \"MSS\", test->settings->mss);\n\tif (test->no_delay)\n\t    cJSON_AddTrueToObject(j, \"nodelay\");\n\tcJSON_AddNumberToObject(j, \"parallel\", test->num_streams);\n\tif (test->reverse)\n\t    cJSON_AddTrueToObject(j, \"reverse\");\n\tif (test->settings->socket_bufsize)\n\t    cJSON_AddNumberToObject(j, \"window\", test->settings->socket_bufsize);\n\tif (test->settings->blksize)\n\t    cJSON_AddNumberToObject(j, \"len\", test->settings->blksize);\n\tif (test->settings->rate)\n\t    cJSON_AddNumberToObject(j, \"bandwidth\", test->settings->rate);\n\tif (test->settings->burst)\n\t    cJSON_AddNumberToObject(j, \"burst\", test->settings->burst);\n\tif (test->settings->tos)\n\t    cJSON_AddNumberToObject(j, \"TOS\", test->settings->tos);\n\tif (test->settings->flowlabel)\n\t    cJSON_AddNumberToObject(j, \"flowlabel\", test->settings->flowlabel);\n\tif (test->title)\n\t    cJSON_AddStringToObject(j, \"title\", test->title);\n\tif (test->congestion)\n\t    cJSON_AddStringToObject(j, \"congestion\", test->congestion);\n\tif (test->get_server_output)\n<<<<<<< HEAD\n\t    cJSON_AddIntToObject(j, \"get_server_output\", iperf_get_test_get_server_output(test));\n=======\n\t    cJSON_AddNumberToObject(j, \"get_server_output\", iperf_get_test_get_server_output(test));\n\tif (test->udp_counters_64bit)\n\t    cJSON_AddNumberToObject(j, \"udp_counters_64bit\", iperf_get_test_udp_counters_64bit(test));\n\tif (test->no_fq_socket_pacing)\n\t    cJSON_AddNumberToObject(j, \"no_fq_socket_pacing\", iperf_get_no_fq_socket_pacing(test));\n\n\tcJSON_AddStringToObject(j, \"client_version\", IPERF_VERSION);\n>>>>>>> ed94082... Fix a buffer overflow / heap corruption issue that could occur if a\n\n\tif (test->debug) {\n\t    printf(\"send_parameters:\\n%s\\n\", cJSON_Print(j));\n\t}\n\n\tif (JSON_write(test->ctrl_sck, j) < 0) {\n\t    i_errno = IESENDPARAMS;\n\t    r = -1;\n\t}\n\tcJSON_Delete(j);\n    }\n    return r;\n}\n\n/*************************************************************/\n\nstatic int\nget_parameters(struct iperf_test *test)\n{\n    int r = 0;\n    cJSON *j;\n    cJSON *j_p;\n\n    j = JSON_read(test->ctrl_sck);\n    if (j == NULL) {\n\ti_errno = IERECVPARAMS;\n        r = -1;\n    } else {\n\tif (test->debug) {\n\t    printf(\"get_parameters:\\n%s\\n\", cJSON_Print(j));\n\t}\n\n\tif ((j_p = cJSON_GetObjectItem(j, \"tcp\")) != NULL)\n\t    set_protocol(test, Ptcp);\n\tif ((j_p = cJSON_GetObjectItem(j, \"udp\")) != NULL)\n\t    set_protocol(test, Pudp);\n\tif ((j_p = cJSON_GetObjectItem(j, \"omit\")) != NULL)\n\t    test->omit = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"server_affinity\")) != NULL)\n\t    test->server_affinity = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"time\")) != NULL)\n\t    test->duration = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"num\")) != NULL)\n\t    test->settings->bytes = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"blockcount\")) != NULL)\n\t    test->settings->blocks = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"MSS\")) != NULL)\n\t    test->settings->mss = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"nodelay\")) != NULL)\n\t    test->no_delay = 1;\n\tif ((j_p = cJSON_GetObjectItem(j, \"parallel\")) != NULL)\n\t    test->num_streams = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"reverse\")) != NULL)\n\t    iperf_set_test_reverse(test, 1);\n\tif ((j_p = cJSON_GetObjectItem(j, \"window\")) != NULL)\n\t    test->settings->socket_bufsize = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"len\")) != NULL)\n\t    test->settings->blksize = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"bandwidth\")) != NULL)\n\t    test->settings->rate = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"burst\")) != NULL)\n\t    test->settings->burst = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"TOS\")) != NULL)\n\t    test->settings->tos = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"flowlabel\")) != NULL)\n\t    test->settings->flowlabel = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"title\")) != NULL)\n\t    test->title = strdup(j_p->valuestring);\n\tif ((j_p = cJSON_GetObjectItem(j, \"congestion\")) != NULL)\n\t    test->congestion = strdup(j_p->valuestring);\n\tif ((j_p = cJSON_GetObjectItem(j, \"get_server_output\")) != NULL)\n\t    iperf_set_test_get_server_output(test, 1);\n\tif (test->sender && test->protocol->id == Ptcp && has_tcpinfo_retransmits())\n\t    test->sender_has_retransmits = 1;\n\tcJSON_Delete(j);\n    }\n    return r;\n}\n\n/*************************************************************/\n\nstatic int\nsend_results(struct iperf_test *test)\n{\n    int r = 0;\n    cJSON *j;\n    cJSON *j_streams;\n    struct iperf_stream *sp;\n    cJSON *j_stream;\n    int sender_has_retransmits;\n    iperf_size_t bytes_transferred;\n    int retransmits;\n\n    j = cJSON_CreateObject();\n    if (j == NULL) {\n\ti_errno = IEPACKAGERESULTS;\n\tr = -1;\n    } else {\n\tcJSON_AddNumberToObject(j, \"cpu_util_total\", test->cpu_util[0]);\n\tcJSON_AddNumberToObject(j, \"cpu_util_user\", test->cpu_util[1]);\n\tcJSON_AddNumberToObject(j, \"cpu_util_system\", test->cpu_util[2]);\n\tif ( ! test->sender )\n\t    sender_has_retransmits = -1;\n\telse\n\t    sender_has_retransmits = test->sender_has_retransmits;\n\tcJSON_AddNumberToObject(j, \"sender_has_retransmits\", sender_has_retransmits);\n\n\t/* If on the server and sending server output, then do this */\n\tif (test->role == 's' && test->get_server_output) {\n\t    if (test->json_output) {\n\t\t/* Add JSON output */\n\t\tcJSON_AddItemReferenceToObject(j, \"server_output_json\", test->json_top);\n\t    }\n\t    else {\n\t\t/* Add textual output */\n\t\tsize_t buflen = 0;\n\n\t\t/* Figure out how much room we need to hold the complete output string */\n\t\tstruct iperf_textline *t;\n\t\tTAILQ_FOREACH(t, &(test->server_output_list), textlineentries) {\n\t\t    buflen += strlen(t->line);\n\t\t}\n\n\t\t/* Allocate and build it up from the component lines */\n\t\tchar *output = calloc(buflen + 1, 1);\n\t\tTAILQ_FOREACH(t, &(test->server_output_list), textlineentries) {\n\t\t    strncat(output, t->line, buflen);\n\t\t    buflen -= strlen(t->line);\n\t\t}\n\n\t\tcJSON_AddStringToObject(j, \"server_output_text\", output);\n\t    }\n\t}\n\n\tj_streams = cJSON_CreateArray();\n\tif (j_streams == NULL) {\n\t    i_errno = IEPACKAGERESULTS;\n\t    r = -1;\n\t} else {\n\t    cJSON_AddItemToObject(j, \"streams\", j_streams);\n\t    SLIST_FOREACH(sp, &test->streams, streams) {\n\t\tj_stream = cJSON_CreateObject();\n\t\tif (j_stream == NULL) {\n\t\t    i_errno = IEPACKAGERESULTS;\n\t\t    r = -1;\n\t\t} else {\n\t\t    cJSON_AddItemToArray(j_streams, j_stream);\n\t\t    bytes_transferred = test->sender ? sp->result->bytes_sent : sp->result->bytes_received;\n\t\t    retransmits = (test->sender && test->sender_has_retransmits) ? sp->result->stream_retrans : -1;\n\t\t    cJSON_AddNumberToObject(j_stream, \"id\", sp->id);\n\t\t    cJSON_AddNumberToObject(j_stream, \"bytes\", bytes_transferred);\n\t\t    cJSON_AddNumberToObject(j_stream, \"retransmits\", retransmits);\n\t\t    cJSON_AddNumberToObject(j_stream, \"jitter\", sp->jitter);\n\t\t    cJSON_AddNumberToObject(j_stream, \"errors\", sp->cnt_error);\n\t\t    cJSON_AddNumberToObject(j_stream, \"packets\", sp->packet_count);\n\t\t}\n\t    }\n\t    if (r == 0 && test->debug) {\n\t\tprintf(\"send_results\\n%s\\n\", cJSON_Print(j));\n\t    }\n\t    if (r == 0 && JSON_write(test->ctrl_sck, j) < 0) {\n\t\ti_errno = IESENDRESULTS;\n\t\tr = -1;\n\t    }\n\t}\n\tcJSON_Delete(j);\n    }\n    return r;\n}\n\n/*************************************************************/\n\nstatic int\nget_results(struct iperf_test *test)\n{\n    int r = 0;\n    cJSON *j;\n    cJSON *j_cpu_util_total;\n    cJSON *j_cpu_util_user;\n    cJSON *j_cpu_util_system;\n    cJSON *j_sender_has_retransmits;\n    int result_has_retransmits;\n    cJSON *j_streams;\n    int n, i;\n    cJSON *j_stream;\n    cJSON *j_id;\n    cJSON *j_bytes;\n    cJSON *j_retransmits;\n    cJSON *j_jitter;\n    cJSON *j_errors;\n    cJSON *j_packets;\n    cJSON *j_server_output;\n    int sid, cerror, pcount;\n    double jitter;\n    iperf_size_t bytes_transferred;\n    int retransmits;\n    struct iperf_stream *sp;\n\n    j = JSON_read(test->ctrl_sck);\n    if (j == NULL) {\n\ti_errno = IERECVRESULTS;\n        r = -1;\n    } else {\n\tj_cpu_util_total = cJSON_GetObjectItem(j, \"cpu_util_total\");\n\tj_cpu_util_user = cJSON_GetObjectItem(j, \"cpu_util_user\");\n\tj_cpu_util_system = cJSON_GetObjectItem(j, \"cpu_util_system\");\n\tj_sender_has_retransmits = cJSON_GetObjectItem(j, \"sender_has_retransmits\");\n\tif (j_cpu_util_total == NULL || j_cpu_util_user == NULL || j_cpu_util_system == NULL || j_sender_has_retransmits == NULL) {\n\t    i_errno = IERECVRESULTS;\n\t    r = -1;\n\t} else {\n\t    if (test->debug) {\n\t\tprintf(\"get_results\\n%s\\n\", cJSON_Print(j));\n\t    }\n\n\t    test->remote_cpu_util[0] = j_cpu_util_total->valuedouble;\n\t    test->remote_cpu_util[1] = j_cpu_util_user->valuedouble;\n\t    test->remote_cpu_util[2] = j_cpu_util_system->valuedouble;\n\t    result_has_retransmits = j_sender_has_retransmits->valueint;\n\t    if (! test->sender)\n\t\ttest->sender_has_retransmits = result_has_retransmits;\n\t    j_streams = cJSON_GetObjectItem(j, \"streams\");\n\t    if (j_streams == NULL) {\n\t\ti_errno = IERECVRESULTS;\n\t\tr = -1;\n\t    } else {\n\t        n = cJSON_GetArraySize(j_streams);\n\t\tfor (i=0; i<n; ++i) {\n\t\t    j_stream = cJSON_GetArrayItem(j_streams, i);\n\t\t    if (j_stream == NULL) {\n\t\t\ti_errno = IERECVRESULTS;\n\t\t\tr = -1;\n\t\t    } else {\n\t\t\tj_id = cJSON_GetObjectItem(j_stream, \"id\");\n\t\t\tj_bytes = cJSON_GetObjectItem(j_stream, \"bytes\");\n\t\t\tj_retransmits = cJSON_GetObjectItem(j_stream, \"retransmits\");\n\t\t\tj_jitter = cJSON_GetObjectItem(j_stream, \"jitter\");\n\t\t\tj_errors = cJSON_GetObjectItem(j_stream, \"errors\");\n\t\t\tj_packets = cJSON_GetObjectItem(j_stream, \"packets\");\n\t\t\tif (j_id == NULL || j_bytes == NULL || j_retransmits == NULL || j_jitter == NULL || j_errors == NULL || j_packets == NULL) {\n\t\t\t    i_errno = IERECVRESULTS;\n\t\t\t    r = -1;\n\t\t\t} else {\n\t\t\t    sid = j_id->valueint;\n\t\t\t    bytes_transferred = j_bytes->valueint;\n\t\t\t    retransmits = j_retransmits->valueint;\n\t\t\t    jitter = j_jitter->valuedouble;\n\t\t\t    cerror = j_errors->valueint;\n\t\t\t    pcount = j_packets->valueint;\n\t\t\t    SLIST_FOREACH(sp, &test->streams, streams)\n\t\t\t\tif (sp->id == sid) break;\n\t\t\t    if (sp == NULL) {\n\t\t\t\ti_errno = IESTREAMID;\n\t\t\t\tr = -1;\n\t\t\t    } else {\n\t\t\t\tif (test->sender) {\n\t\t\t\t    sp->jitter = jitter;\n\t\t\t\t    sp->cnt_error = cerror;\n\t\t\t\t    sp->packet_count = pcount;\n\t\t\t\t    sp->result->bytes_received = bytes_transferred;\n\t\t\t\t} else {\n\t\t\t\t    sp->result->bytes_sent = bytes_transferred;\n\t\t\t\t    sp->result->stream_retrans = retransmits;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t\t/*\n\t\t * If we're the client and we're supposed to get remote results,\n\t\t * look them up and process accordingly.\n\t\t */\n\t\tif (test->role == 'c' && iperf_get_test_get_server_output(test)) {\n\t\t    /* Look for JSON.  If we find it, grab the object so it doesn't get deleted. */\n\t\t    j_server_output = cJSON_DetachItemFromObject(j, \"server_output_json\");\n\t\t    if (j_server_output != NULL) {\n\t\t\ttest->json_server_output = j_server_output;\n\t\t    }\n\t\t    else {\n\t\t\t/* No JSON, look for textual output.  Make a copy of the text for later. */\n\t\t\tj_server_output = cJSON_GetObjectItem(j, \"server_output_text\");\n\t\t\tif (j_server_output != NULL) {\n\t\t\t    test->server_output_text = strdup(j_server_output->valuestring);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tcJSON_Delete(j);\n    }\n    return r;\n}\n\n/*************************************************************/\n\nstatic int\nJSON_write(int fd, cJSON *json)\n{\n    uint32_t hsize, nsize;\n    char *str;\n    int r = 0;\n\n    str = cJSON_PrintUnformatted(json);\n    if (str == NULL)\n\tr = -1;\n    else {\n\thsize = strlen(str);\n\tnsize = htonl(hsize);\n\tif (Nwrite(fd, (char*) &nsize, sizeof(nsize), Ptcp) < 0)\n\t    r = -1;\n\telse {\n\t    if (Nwrite(fd, str, hsize, Ptcp) < 0)\n\t\tr = -1;\n\t}\n\tfree(str);\n    }\n    return r;\n}\n\n/*************************************************************/\n\nstatic cJSON *\nJSON_read(int fd)\n{\n    uint32_t hsize, nsize;\n    char *str;\n    cJSON *json = NULL;\n\n    if (Nread(fd, (char*) &nsize, sizeof(nsize), Ptcp) >= 0) {\n\thsize = ntohl(nsize);\n\tstr = (char *) malloc(hsize+1);\t/* +1 for EOS */\n\tif (str != NULL) {\n\t    if (Nread(fd, str, hsize, Ptcp) >= 0) {\n\t\tstr[hsize] = '\\0';\t/* add the EOS */\n\t\tjson = cJSON_Parse(str);\n\t    }\n\t}\n\tfree(str);\n    }\n    return json;\n}\n\n/*************************************************************/\n/**\n * add_to_interval_list -- adds new interval to the interval_list\n */\n\nvoid\nadd_to_interval_list(struct iperf_stream_result * rp, struct iperf_interval_results * new)\n{\n    struct iperf_interval_results *irp;\n\n    irp = (struct iperf_interval_results *) malloc(sizeof(struct iperf_interval_results));\n    memcpy(irp, new, sizeof(struct iperf_interval_results));\n    TAILQ_INSERT_TAIL(&rp->interval_results, irp, irlistentries);\n}\n\n\n/************************************************************/\n\n/**\n * connect_msg -- displays connection message\n * denoting sender/receiver details\n *\n */\n\nvoid\nconnect_msg(struct iperf_stream *sp)\n{\n    char ipl[INET6_ADDRSTRLEN], ipr[INET6_ADDRSTRLEN];\n    int lport, rport;\n\n    if (getsockdomain(sp->socket) == AF_INET) {\n        inet_ntop(AF_INET, (void *) &((struct sockaddr_in *) &sp->local_addr)->sin_addr, ipl, sizeof(ipl));\n\tmapped_v4_to_regular_v4(ipl);\n        inet_ntop(AF_INET, (void *) &((struct sockaddr_in *) &sp->remote_addr)->sin_addr, ipr, sizeof(ipr));\n\tmapped_v4_to_regular_v4(ipr);\n        lport = ntohs(((struct sockaddr_in *) &sp->local_addr)->sin_port);\n        rport = ntohs(((struct sockaddr_in *) &sp->remote_addr)->sin_port);\n    } else {\n        inet_ntop(AF_INET6, (void *) &((struct sockaddr_in6 *) &sp->local_addr)->sin6_addr, ipl, sizeof(ipl));\n\tmapped_v4_to_regular_v4(ipl);\n        inet_ntop(AF_INET6, (void *) &((struct sockaddr_in6 *) &sp->remote_addr)->sin6_addr, ipr, sizeof(ipr));\n\tmapped_v4_to_regular_v4(ipr);\n        lport = ntohs(((struct sockaddr_in6 *) &sp->local_addr)->sin6_port);\n        rport = ntohs(((struct sockaddr_in6 *) &sp->remote_addr)->sin6_port);\n    }\n\n    if (sp->test->json_output)\n        cJSON_AddItemToArray(sp->test->json_connected, iperf_json_printf(\"socket: %d  local_host: %s  local_port: %d  remote_host: %s  remote_port: %d\", (int64_t) sp->socket, ipl, (int64_t) lport, ipr, (int64_t) rport));\n    else\n\tiprintf(sp->test, report_connected, sp->socket, ipl, lport, ipr, rport);\n}\n\n\n/**************************************************************************/\n\nstruct iperf_test *\niperf_new_test()\n{\n    struct iperf_test *test;\n\n    test = (struct iperf_test *) malloc(sizeof(struct iperf_test));\n    if (!test) {\n        i_errno = IENEWTEST;\n        return NULL;\n    }\n    /* initialize everything to zero */\n    memset(test, 0, sizeof(struct iperf_test));\n\n    test->settings = (struct iperf_settings *) malloc(sizeof(struct iperf_settings));\n    if (!test->settings) {\n        free(test);\n\ti_errno = IENEWTEST;\n\treturn NULL;\n    }\n    memset(test->settings, 0, sizeof(struct iperf_settings));\n\n    return test;\n}\n\n/**************************************************************************/\nint\niperf_defaults(struct iperf_test *testp)\n{\n    struct protocol *tcp, *udp;\n\n    testp->omit = OMIT;\n    testp->duration = DURATION;\n    testp->diskfile_name = (char*) 0;\n    testp->affinity = -1;\n    testp->server_affinity = -1;\n    testp->title = NULL;\n    testp->congestion = NULL;\n    testp->server_port = PORT;\n    testp->ctrl_sck = -1;\n    testp->prot_listener = -1;\n\n    testp->stats_callback = iperf_stats_callback;\n    testp->reporter_callback = iperf_reporter_callback;\n\n    testp->stats_interval = testp->reporter_interval = 1;\n    testp->num_streams = 1;\n\n    testp->settings->domain = AF_UNSPEC;\n    testp->settings->unit_format = 'a';\n    testp->settings->socket_bufsize = 0;    /* use autotuning */\n    testp->settings->blksize = DEFAULT_TCP_BLKSIZE;\n    testp->settings->rate = 0;\n    testp->settings->burst = 0;\n    testp->settings->mss = 0;\n    testp->settings->bytes = 0;\n    testp->settings->blocks = 0;\n    memset(testp->cookie, 0, COOKIE_SIZE);\n\n    testp->multisend = 10;\t/* arbitrary */\n\n    /* Set up protocol list */\n    SLIST_INIT(&testp->streams);\n    SLIST_INIT(&testp->protocols);\n\n    tcp = (struct protocol *) malloc(sizeof(struct protocol));\n    if (!tcp)\n        return -1;\n    memset(tcp, 0, sizeof(struct protocol));\n    udp = (struct protocol *) malloc(sizeof(struct protocol));\n    if (!udp) {\n        free(tcp);\n        return -1;\n    }\n    memset(udp, 0, sizeof(struct protocol));\n\n    tcp->id = Ptcp;\n    tcp->name = \"TCP\";\n    tcp->accept = iperf_tcp_accept;\n    tcp->listen = iperf_tcp_listen;\n    tcp->connect = iperf_tcp_connect;\n    tcp->send = iperf_tcp_send;\n    tcp->recv = iperf_tcp_recv;\n    tcp->init = NULL;\n    SLIST_INSERT_HEAD(&testp->protocols, tcp, protocols);\n\n    udp->id = Pudp;\n    udp->name = \"UDP\";\n    udp->accept = iperf_udp_accept;\n    udp->listen = iperf_udp_listen;\n    udp->connect = iperf_udp_connect;\n    udp->send = iperf_udp_send;\n    udp->recv = iperf_udp_recv;\n    udp->init = iperf_udp_init;\n    SLIST_INSERT_AFTER(tcp, udp, protocols);\n\n    set_protocol(testp, Ptcp);\n\n    testp->on_new_stream = iperf_on_new_stream;\n    testp->on_test_start = iperf_on_test_start;\n    testp->on_connect = iperf_on_connect;\n    testp->on_test_finish = iperf_on_test_finish;\n\n    TAILQ_INIT(&testp->server_output_list);\n\n    return 0;\n}\n\n\n/**************************************************************************/\nvoid\niperf_free_test(struct iperf_test *test)\n{\n    struct protocol *prot;\n    struct iperf_stream *sp;\n\n    /* Free streams */\n    while (!SLIST_EMPTY(&test->streams)) {\n        sp = SLIST_FIRST(&test->streams);\n        SLIST_REMOVE_HEAD(&test->streams, streams);\n        iperf_free_stream(sp);\n    }\n\n    if (test->server_hostname)\n\tfree(test->server_hostname);\n    if (test->bind_address)\n\tfree(test->bind_address);\n    free(test->settings);\n    if (test->title)\n\tfree(test->title);\n    if (test->congestion)\n\tfree(test->congestion);\n    if (test->omit_timer != NULL)\n\ttmr_cancel(test->omit_timer);\n    if (test->timer != NULL)\n\ttmr_cancel(test->timer);\n    if (test->stats_timer != NULL)\n\ttmr_cancel(test->stats_timer);\n    if (test->reporter_timer != NULL)\n\ttmr_cancel(test->reporter_timer);\n\n    /* Free protocol list */\n    while (!SLIST_EMPTY(&test->protocols)) {\n        prot = SLIST_FIRST(&test->protocols);\n        SLIST_REMOVE_HEAD(&test->protocols, protocols);        \n        free(prot);\n    }\n\n    if (test->server_output_text) {\n\tfree(test->server_output_text);\n\ttest->server_output_text = NULL;\n    }\n\n    /* Free output line buffers, if any (on the server only) */\n    struct iperf_textline *t;\n    while (!TAILQ_EMPTY(&test->server_output_list)) {\n\tt = TAILQ_FIRST(&test->server_output_list);\n\tTAILQ_REMOVE(&test->server_output_list, t, textlineentries);\n\tfree(t->line);\n\tfree(t);\n    }\n\n    /* XXX: Why are we setting these values to NULL? */\n    // test->streams = NULL;\n    test->stats_callback = NULL;\n    test->reporter_callback = NULL;\n    free(test);\n}\n\n\nvoid\niperf_reset_test(struct iperf_test *test)\n{\n    struct iperf_stream *sp;\n\n    /* Free streams */\n    while (!SLIST_EMPTY(&test->streams)) {\n        sp = SLIST_FIRST(&test->streams);\n        SLIST_REMOVE_HEAD(&test->streams, streams);\n        iperf_free_stream(sp);\n    }\n    if (test->omit_timer != NULL) {\n\ttmr_cancel(test->omit_timer);\n\ttest->omit_timer = NULL;\n    }\n    if (test->timer != NULL) {\n\ttmr_cancel(test->timer);\n\ttest->timer = NULL;\n    }\n    if (test->stats_timer != NULL) {\n\ttmr_cancel(test->stats_timer);\n\ttest->stats_timer = NULL;\n    }\n    if (test->reporter_timer != NULL) {\n\ttmr_cancel(test->reporter_timer);\n\ttest->reporter_timer = NULL;\n    }\n    test->done = 0;\n\n    SLIST_INIT(&test->streams);\n\n    test->role = 's';\n    test->sender = 0;\n    test->sender_has_retransmits = 0;\n    set_protocol(test, Ptcp);\n    test->omit = OMIT;\n    test->duration = DURATION;\n    test->server_affinity = -1;\n    test->state = 0;\n    \n    test->ctrl_sck = -1;\n    test->prot_listener = -1;\n\n    test->bytes_sent = 0;\n    test->blocks_sent = 0;\n\n    test->reverse = 0;\n    test->no_delay = 0;\n\n    FD_ZERO(&test->read_set);\n    FD_ZERO(&test->write_set);\n    \n    test->num_streams = 1;\n    test->settings->socket_bufsize = 0;\n    test->settings->blksize = DEFAULT_TCP_BLKSIZE;\n    test->settings->rate = 0;\n    test->settings->burst = 0;\n    test->settings->mss = 0;\n    memset(test->cookie, 0, COOKIE_SIZE);\n    test->multisend = 10;\t/* arbitrary */\n\n    /* Free output line buffers, if any (on the server only) */\n    struct iperf_textline *t;\n    while (!TAILQ_EMPTY(&test->server_output_list)) {\n\tt = TAILQ_FIRST(&test->server_output_list);\n\tTAILQ_REMOVE(&test->server_output_list, t, textlineentries);\n\tfree(t->line);\n\tfree(t);\n    }\n}\n\n\n/* Reset all of a test's stats back to zero.  Called when the omitting\n** period is over.\n*/\nvoid\niperf_reset_stats(struct iperf_test *test)\n{\n    struct timeval now;\n    struct iperf_stream *sp;\n    struct iperf_stream_result *rp;\n\n    test->bytes_sent = 0;\n    test->blocks_sent = 0;\n    gettimeofday(&now, NULL);\n    SLIST_FOREACH(sp, &test->streams, streams) {\n\tsp->omitted_packet_count = sp->packet_count;\n\tsp->jitter = 0;\n\tsp->outoforder_packets = 0;\n\tsp->cnt_error = 0;\n\trp = sp->result;\n        rp->bytes_sent = rp->bytes_received = 0;\n        rp->bytes_sent_this_interval = rp->bytes_received_this_interval = 0;\n\tif (test->sender && test->sender_has_retransmits) {\n\t    struct iperf_interval_results ir; /* temporary results structure */\n\t    save_tcpinfo(sp, &ir);\n\t    rp->stream_prev_total_retrans = get_total_retransmits(&ir);\n\t}\n\trp->stream_retrans = 0;\n\trp->start_time = now;\n    }\n}\n\n\n/**************************************************************************/\n\n/**\n * iperf_stats_callback -- handles the statistic gathering for both the client and server\n *\n * XXX: This function needs to be updated to reflect the new code\n */\n\n\nvoid\niperf_stats_callback(struct iperf_test *test)\n{\n    struct iperf_stream *sp;\n    struct iperf_stream_result *rp = NULL;\n    struct iperf_interval_results *irp, temp;\n\n    temp.omitted = test->omitting;\n    SLIST_FOREACH(sp, &test->streams, streams) {\n        rp = sp->result;\n\n\ttemp.bytes_transferred = test->sender ? rp->bytes_sent_this_interval : rp->bytes_received_this_interval;\n     \n\tirp = TAILQ_LAST(&rp->interval_results, irlisthead);\n        /* result->end_time contains timestamp of previous interval */\n        if ( irp != NULL ) /* not the 1st interval */\n            memcpy(&temp.interval_start_time, &rp->end_time, sizeof(struct timeval));\n        else /* or use timestamp from beginning */\n            memcpy(&temp.interval_start_time, &rp->start_time, sizeof(struct timeval));\n        /* now save time of end of this interval */\n        gettimeofday(&rp->end_time, NULL);\n        memcpy(&temp.interval_end_time, &rp->end_time, sizeof(struct timeval));\n        temp.interval_duration = timeval_diff(&temp.interval_start_time, &temp.interval_end_time);\n        //temp.interval_duration = timeval_diff(&temp.interval_start_time, &temp.interval_end_time);\n\tif (test->protocol->id == Ptcp) {\n\t    if ( has_tcpinfo()) {\n\t\tsave_tcpinfo(sp, &temp);\n\t\tif (test->sender && test->sender_has_retransmits) {\n\t\t    long total_retrans = get_total_retransmits(&temp);\n\t\t    temp.interval_retrans = total_retrans - rp->stream_prev_total_retrans;\n\t\t    rp->stream_retrans += temp.interval_retrans;\n\t\t    rp->stream_prev_total_retrans = total_retrans;\n\n\t\t    temp.snd_cwnd = get_snd_cwnd(&temp);\n\t\t}\n\t    }\n\t} else {\n\t    if (irp == NULL) {\n\t\ttemp.interval_packet_count = sp->packet_count;\n\t\ttemp.interval_outoforder_packets = sp->outoforder_packets;\n\t\ttemp.interval_cnt_error = sp->cnt_error;\n\t    } else {\n\t\ttemp.interval_packet_count = sp->packet_count - irp->packet_count;\n\t\ttemp.interval_outoforder_packets = sp->outoforder_packets - irp->outoforder_packets;\n\t\ttemp.interval_cnt_error = sp->cnt_error - irp->cnt_error;\n\t    }\n\t    temp.packet_count = sp->packet_count;\n\t    temp.jitter = sp->jitter;\n\t    temp.outoforder_packets = sp->outoforder_packets;\n\t    temp.cnt_error = sp->cnt_error;\n\t}\n        add_to_interval_list(rp, &temp);\n        rp->bytes_sent_this_interval = rp->bytes_received_this_interval = 0;\n    }\n}\n\nstatic void\niperf_print_intermediate(struct iperf_test *test)\n{\n    char ubuf[UNIT_LEN];\n    char nbuf[UNIT_LEN];\n    struct iperf_stream *sp = NULL;\n    struct iperf_interval_results *irp;\n    iperf_size_t bytes = 0;\n    double bandwidth;\n    int retransmits = 0;\n    double start_time, end_time;\n    cJSON *json_interval;\n    cJSON *json_interval_streams;\n    int total_packets = 0, lost_packets = 0;\n    double avg_jitter = 0.0, lost_percent;\n\n    if (test->json_output) {\n        json_interval = cJSON_CreateObject();\n\tif (json_interval == NULL)\n\t    return;\n\tcJSON_AddItemToArray(test->json_intervals, json_interval);\n        json_interval_streams = cJSON_CreateArray();\n\tif (json_interval_streams == NULL)\n\t    return;\n\tcJSON_AddItemToObject(json_interval, \"streams\", json_interval_streams);\n    } else {\n        json_interval = NULL;\n        json_interval_streams = NULL;\n    }\n\n    SLIST_FOREACH(sp, &test->streams, streams) {\n        print_interval_results(test, sp, json_interval_streams);\n\t/* sum up all streams */\n\tirp = TAILQ_LAST(&sp->result->interval_results, irlisthead);\n\tif (irp == NULL) {\n\t    iperf_err(test, \"iperf_print_intermediate error: interval_results is NULL\");\n\t    return;\n\t}\n        bytes += irp->bytes_transferred;\n\tif (test->protocol->id == Ptcp) {\n\t    if (test->sender && test->sender_has_retransmits) {\n\t\tretransmits += irp->interval_retrans;\n\t    }\n\t} else {\n            total_packets += irp->interval_packet_count;\n            lost_packets += irp->interval_cnt_error;\n            avg_jitter += irp->jitter;\n\t}\n    }\n\n    /* next build string with sum of all streams */\n    if (test->num_streams > 1 || test->json_output) {\n        sp = SLIST_FIRST(&test->streams); /* reset back to 1st stream */\n\t/* Only do this of course if there was a first stream */\n\tif (sp) {\n        irp = TAILQ_LAST(&sp->result->interval_results, irlisthead);    /* use 1st stream for timing info */\n\n        unit_snprintf(ubuf, UNIT_LEN, (double) bytes, 'A');\n\tbandwidth = (double) bytes / (double) irp->interval_duration;\n        unit_snprintf(nbuf, UNIT_LEN, bandwidth, test->settings->unit_format);\n\n        start_time = timeval_diff(&sp->result->start_time,&irp->interval_start_time);\n        end_time = timeval_diff(&sp->result->start_time,&irp->interval_end_time);\n\tif (test->protocol->id == Ptcp) {\n\t    if (test->sender && test->sender_has_retransmits) {\n\t\t/* Interval sum, TCP with retransmits. */\n\t\tif (test->json_output)\n\t\t    cJSON_AddItemToObject(json_interval, \"sum\", iperf_json_printf(\"start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  retransmits: %d  omitted: %b\", (double) start_time, (double) end_time, (double) irp->interval_duration, (int64_t) bytes, bandwidth * 8, (int64_t) retransmits, irp->omitted)); /* XXX irp->omitted or test->omitting? */\n\t\telse\n\t\t    iprintf(test, report_sum_bw_retrans_format, start_time, end_time, ubuf, nbuf, retransmits, irp->omitted?report_omitted:\"\"); /* XXX irp->omitted or test->omitting? */\n\t    } else {\n\t\t/* Interval sum, TCP without retransmits. */\n\t\tif (test->json_output)\n\t\t    cJSON_AddItemToObject(json_interval, \"sum\", iperf_json_printf(\"start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  omitted: %b\", (double) start_time, (double) end_time, (double) irp->interval_duration, (int64_t) bytes, bandwidth * 8, test->omitting));\n\t\telse\n\t\t    iprintf(test, report_sum_bw_format, start_time, end_time, ubuf, nbuf, test->omitting?report_omitted:\"\");\n\t    }\n\t} else {\n\t    /* Interval sum, UDP. */\n\t    if (test->sender) {\n\t\tif (test->json_output)\n\t\t    cJSON_AddItemToObject(json_interval, \"sum\", iperf_json_printf(\"start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  packets: %d  omitted: %b\", (double) start_time, (double) end_time, (double) irp->interval_duration, (int64_t) bytes, bandwidth * 8, (int64_t) total_packets, test->omitting));\n\t\telse\n\t\t    iprintf(test, report_sum_bw_udp_sender_format, start_time, end_time, ubuf, nbuf, total_packets, test->omitting?report_omitted:\"\");\n\t    } else {\n\t\tavg_jitter /= test->num_streams;\n\t\tlost_percent = 100.0 * lost_packets / total_packets;\n\t\tif (test->json_output)\n\t\t    cJSON_AddItemToObject(json_interval, \"sum\", iperf_json_printf(\"start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  jitter_ms: %f  lost_packets: %d  packets: %d  lost_percent: %f  omitted: %b\", (double) start_time, (double) end_time, (double) irp->interval_duration, (int64_t) bytes, bandwidth * 8, (double) avg_jitter * 1000.0, (int64_t) lost_packets, (int64_t) total_packets, (double) lost_percent, test->omitting));\n\t\telse\n\t\t    iprintf(test, report_sum_bw_udp_format, start_time, end_time, ubuf, nbuf, avg_jitter * 1000.0, lost_packets, total_packets, lost_percent, test->omitting?report_omitted:\"\");\n\t    }\n\t}\n\t}\n    }\n}\n\nstatic void\niperf_print_results(struct iperf_test *test)\n{\n\n    cJSON *json_summary_streams = NULL;\n    cJSON *json_summary_stream = NULL;\n    int total_retransmits = 0;\n    int total_packets = 0, lost_packets = 0;\n    char ubuf[UNIT_LEN];\n    char nbuf[UNIT_LEN];\n    struct stat sb;\n    char sbuf[UNIT_LEN];\n    struct iperf_stream *sp = NULL;\n    iperf_size_t bytes_sent, total_sent = 0;\n    iperf_size_t bytes_received, total_received = 0;\n    double start_time, end_time, avg_jitter = 0.0, lost_percent;\n    double bandwidth;\n\n    /* print final summary for all intervals */\n\n    if (test->json_output) {\n        json_summary_streams = cJSON_CreateArray();\n\tif (json_summary_streams == NULL)\n\t    return;\n\tcJSON_AddItemToObject(test->json_end, \"streams\", json_summary_streams);\n    } else {\n\tiprintf(test, \"%s\", report_bw_separator);\n\tif (test->verbose)\n\t    iprintf(test, \"%s\", report_summary);\n\tif (test->protocol->id == Ptcp) {\n\t    if (test->sender_has_retransmits)\n\t\tiprintf(test, \"%s\", report_bw_retrans_header);\n\t    else\n\t\tiprintf(test, \"%s\", report_bw_header);\n\t} else\n\t    iprintf(test, \"%s\", report_bw_udp_header);\n    }\n\n    start_time = 0.;\n    sp = SLIST_FIRST(&test->streams);\n    /* \n     * If there is at least one stream, then figure out the length of time\n     * we were running the tests and print out some statistics about\n     * the streams.  It's possible to not have any streams at all\n     * if the client got interrupted before it got to do anything.\n     */\n    if (sp) {\n    end_time = timeval_diff(&sp->result->start_time, &sp->result->end_time);\n    SLIST_FOREACH(sp, &test->streams, streams) {\n\tif (test->json_output) {\n\t    json_summary_stream = cJSON_CreateObject();\n\t    if (json_summary_stream == NULL)\n\t\treturn;\n\t    cJSON_AddItemToArray(json_summary_streams, json_summary_stream);\n\t}\n\n        bytes_sent = sp->result->bytes_sent;\n        bytes_received = sp->result->bytes_received;\n        total_sent += bytes_sent;\n        total_received += bytes_received;\n\n        if (test->protocol->id == Ptcp) {\n\t    if (test->sender_has_retransmits) {\n\t\ttotal_retransmits += sp->result->stream_retrans;\n\t    }\n\t} else {\n            total_packets += (sp->packet_count - sp->omitted_packet_count);\n            lost_packets += sp->cnt_error;\n            avg_jitter += sp->jitter;\n        }\n\n\tunit_snprintf(ubuf, UNIT_LEN, (double) bytes_sent, 'A');\n\tbandwidth = (double) bytes_sent / (double) end_time;\n\tunit_snprintf(nbuf, UNIT_LEN, bandwidth, test->settings->unit_format);\n\tif (test->protocol->id == Ptcp) {\n\t    if (test->sender_has_retransmits) {\n\t\t/* Summary, TCP with retransmits. */\n\t\tif (test->json_output)\n\t\t    cJSON_AddItemToObject(json_summary_stream, \"sender\", iperf_json_printf(\"socket: %d  start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  retransmits: %d\", (int64_t) sp->socket, (double) start_time, (double) end_time, (double) end_time, (int64_t) bytes_sent, bandwidth * 8, (int64_t) sp->result->stream_retrans));\n\t\telse\n\t\t    iprintf(test, report_bw_retrans_format, sp->socket, start_time, end_time, ubuf, nbuf, sp->result->stream_retrans, report_sender);\n\t    } else {\n\t\t/* Summary, TCP without retransmits. */\n\t\tif (test->json_output)\n\t\t    cJSON_AddItemToObject(json_summary_stream, \"sender\", iperf_json_printf(\"socket: %d  start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f\", (int64_t) sp->socket, (double) start_time, (double) end_time, (double) end_time, (int64_t) bytes_sent, bandwidth * 8));\n\t\telse\n\t\t    iprintf(test, report_bw_format, sp->socket, start_time, end_time, ubuf, nbuf, report_sender);\n\t    }\n\t} else {\n\t    /* Summary, UDP. */\n\t    lost_percent = 100.0 * sp->cnt_error / (sp->packet_count - sp->omitted_packet_count);\n\t    if (test->json_output)\n\t\tcJSON_AddItemToObject(json_summary_stream, \"udp\", iperf_json_printf(\"socket: %d  start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  jitter_ms: %f  lost_packets: %d  packets: %d  lost_percent: %f  out_of_order: %d\", (int64_t) sp->socket, (double) start_time, (double) end_time, (double) end_time, (int64_t) bytes_sent, bandwidth * 8, (double) sp->jitter * 1000.0, (int64_t) sp->cnt_error, (int64_t) (sp->packet_count - sp->omitted_packet_count), (double) lost_percent, (int64_t) sp->outoforder_packets));\n\t    else {\n\t\tiprintf(test, report_bw_udp_format, sp->socket, start_time, end_time, ubuf, nbuf, sp->jitter * 1000.0, sp->cnt_error, (sp->packet_count - sp->omitted_packet_count), lost_percent, \"\");\n\t\tif (test->role == 'c')\n\t\t    iprintf(test, report_datagrams, sp->socket, (sp->packet_count - sp->omitted_packet_count));\n\t\tif (sp->outoforder_packets > 0)\n\t\t    iprintf(test, report_sum_outoforder, start_time, end_time, sp->outoforder_packets);\n\t    }\n\t}\n\n\tif (sp->diskfile_fd >= 0) {\n\t    if (fstat(sp->diskfile_fd, &sb) == 0) {\n\t\tint percent = (int) ( ( (double) bytes_sent / (double) sb.st_size ) * 100.0 );\n\t\tunit_snprintf(sbuf, UNIT_LEN, (double) sb.st_size, 'A');\n\t\tif (test->json_output)\n\t\t    cJSON_AddItemToObject(json_summary_stream, \"diskfile\", iperf_json_printf(\"sent: %d  size: %d  percent: %d  filename: %s\", (int64_t) bytes_sent, (int64_t) sb.st_size, (int64_t) percent, test->diskfile_name));\n\t\telse\n\t\t    iprintf(test, report_diskfile, ubuf, sbuf, percent, test->diskfile_name);\n\t    }\n\t}\n\n\tunit_snprintf(ubuf, UNIT_LEN, (double) bytes_received, 'A');\n\tbandwidth = (double) bytes_received / (double) end_time;\n\tunit_snprintf(nbuf, UNIT_LEN, bandwidth, test->settings->unit_format);\n\tif (test->protocol->id == Ptcp) {\n\t    if (test->json_output)\n\t\tcJSON_AddItemToObject(json_summary_stream, \"receiver\", iperf_json_printf(\"socket: %d  start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f\", (int64_t) sp->socket, (double) start_time, (double) end_time, (double) end_time, (int64_t) bytes_received, bandwidth * 8));\n\t    else\n\t\tiprintf(test, report_bw_format, sp->socket, start_time, end_time, ubuf, nbuf, report_receiver);\n\t}\n    }\n    }\n\n    if (test->num_streams > 1 || test->json_output) {\n        unit_snprintf(ubuf, UNIT_LEN, (double) total_sent, 'A');\n\t/* If no tests were run, arbitrariliy set bandwidth to 0. */\n\tif (end_time > 0.0) {\n\t    bandwidth = (double) total_sent / (double) end_time;\n\t}\n\telse {\n\t    bandwidth = 0.0;\n\t}\n        unit_snprintf(nbuf, UNIT_LEN, bandwidth, test->settings->unit_format);\n        if (test->protocol->id == Ptcp) {\n\t    if (test->sender_has_retransmits) {\n\t\t/* Summary sum, TCP with retransmits. */\n\t\tif (test->json_output)\n\t\t    cJSON_AddItemToObject(test->json_end, \"sum_sent\", iperf_json_printf(\"start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  retransmits: %d\", (double) start_time, (double) end_time, (double) end_time, (int64_t) total_sent, bandwidth * 8, (int64_t) total_retransmits));\n\t\telse\n\t\t    iprintf(test, report_sum_bw_retrans_format, start_time, end_time, ubuf, nbuf, total_retransmits, report_sender);\n\t    } else {\n\t\t/* Summary sum, TCP without retransmits. */\n\t\tif (test->json_output)\n\t\t    cJSON_AddItemToObject(test->json_end, \"sum_sent\", iperf_json_printf(\"start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f\", (double) start_time, (double) end_time, (double) end_time, (int64_t) total_sent, bandwidth * 8));\n\t\telse\n\t\t    iprintf(test, report_sum_bw_format, start_time, end_time, ubuf, nbuf, report_sender);\n\t    }\n            unit_snprintf(ubuf, UNIT_LEN, (double) total_received, 'A');\n\t    /* If no tests were run, set received bandwidth to 0 */\n\t    if (end_time > 0.0) {\n\t\tbandwidth = (double) total_received / (double) end_time;\n\t    }\n\t    else {\n\t\tbandwidth = 0.0;\n\t    }\n            unit_snprintf(nbuf, UNIT_LEN, bandwidth, test->settings->unit_format);\n\t    if (test->json_output)\n\t\tcJSON_AddItemToObject(test->json_end, \"sum_received\", iperf_json_printf(\"start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f\", (double) start_time, (double) end_time, (double) end_time, (int64_t) total_received, bandwidth * 8));\n\t    else\n\t\tiprintf(test, report_sum_bw_format, start_time, end_time, ubuf, nbuf, report_receiver);\n        } else {\n\t    /* Summary sum, UDP. */\n            avg_jitter /= test->num_streams;\n\t    /* If no packets were sent, arbitrarily set loss percentage to 100. */\n\t    if (total_packets > 0) {\n\t\tlost_percent = 100.0 * lost_packets / total_packets;\n\t    }\n\t    else {\n\t\tlost_percent = 100.0;\n\t    }\n\t    if (test->json_output)\n\t\tcJSON_AddItemToObject(test->json_end, \"sum\", iperf_json_printf(\"start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  jitter_ms: %f  lost_packets: %d  packets: %d  lost_percent: %f\", (double) start_time, (double) end_time, (double) end_time, (int64_t) total_sent, bandwidth * 8, (double) avg_jitter * 1000.0, (int64_t) lost_packets, (int64_t) total_packets, (double) lost_percent));\n\t    else\n\t\tiprintf(test, report_sum_bw_udp_format, start_time, end_time, ubuf, nbuf, avg_jitter * 1000.0, lost_packets, total_packets, lost_percent, \"\");\n        }\n    }\n\n    if (test->json_output)\n\tcJSON_AddItemToObject(test->json_end, \"cpu_utilization_percent\", iperf_json_printf(\"host_total: %f  host_user: %f  host_system: %f  remote_total: %f  remote_user: %f  remote_system: %f\", (double) test->cpu_util[0], (double) test->cpu_util[1], (double) test->cpu_util[2], (double) test->remote_cpu_util[0], (double) test->remote_cpu_util[1], (double) test->remote_cpu_util[2]));\n    else {\n\tif (test->verbose) {\n\t    iprintf(test, report_cpu, report_local, test->sender?report_sender:report_receiver, test->cpu_util[0], test->cpu_util[1], test->cpu_util[2], report_remote, test->sender?report_receiver:report_sender, test->remote_cpu_util[0], test->remote_cpu_util[1], test->remote_cpu_util[2]);\n\t}\n\n\t/* Print server output if we're on the client and it was requested/provided */\n\tif (test->role == 'c' && iperf_get_test_get_server_output(test)) {\n\t    if (test->json_server_output) {\n\t\tiprintf(test, \"\\nServer JSON output:\\n%s\\n\", cJSON_Print(test->json_server_output));\n\t\tcJSON_Delete(test->json_server_output);\n\t\ttest->json_server_output = NULL;\n\t    }\n\t    if (test->server_output_text) {\n\t\tiprintf(test, \"\\nServer output:\\n%s\\n\", test->server_output_text);\n\t\ttest->server_output_text = NULL;\n\t    }\n\t}\n    }\n}\n\n/**************************************************************************/\n\n/**\n * iperf_reporter_callback -- handles the report printing\n *\n */\n\nvoid\niperf_reporter_callback(struct iperf_test *test)\n{\n    switch (test->state) {\n        case TEST_RUNNING:\n        case STREAM_RUNNING:\n            /* print interval results for each stream */\n            iperf_print_intermediate(test);\n            break;\n        case TEST_END:\n        case DISPLAY_RESULTS:\n            iperf_print_intermediate(test);\n            iperf_print_results(test);\n            break;\n    } \n\n}\n\n/**************************************************************************/\nstatic void\nprint_interval_results(struct iperf_test *test, struct iperf_stream *sp, cJSON *json_interval_streams)\n{\n    char ubuf[UNIT_LEN];\n    char nbuf[UNIT_LEN];\n    char cbuf[UNIT_LEN];\n    double st = 0., et = 0.;\n    struct iperf_interval_results *irp = NULL;\n    double bandwidth, lost_percent;\n\n    irp = TAILQ_LAST(&sp->result->interval_results, irlisthead); /* get last entry in linked list */\n    if (irp == NULL) {\n\tiperf_err(test, \"print_interval_results error: interval_results is NULL\");\n        return;\n    }\n    if (!test->json_output) {\n\t/* First stream? */\n\tif (sp == SLIST_FIRST(&test->streams)) {\n\t    /* It it's the first interval, print the header;\n\t    ** else if there's more than one stream, print the separator;\n\t    ** else nothing.\n\t    */\n\t    if (timeval_equals(&sp->result->start_time, &irp->interval_start_time)) {\n\t\tif (test->protocol->id == Ptcp) {\n\t\t    if (test->sender && test->sender_has_retransmits)\n\t\t\tiprintf(test, \"%s\", report_bw_retrans_cwnd_header);\n\t\t    else\n\t\t\tiprintf(test, \"%s\", report_bw_header);\n\t\t} else {\n\t\t    if (test->sender)\n\t\t\tiprintf(test, \"%s\", report_bw_udp_sender_header);\n\t\t    else\n\t\t\tiprintf(test, \"%s\", report_bw_udp_header);\n\t\t}\n\t    } else if (test->num_streams > 1)\n\t\tiprintf(test, \"%s\", report_bw_separator);\n\t}\n    }\n\n    unit_snprintf(ubuf, UNIT_LEN, (double) (irp->bytes_transferred), 'A');\n    bandwidth = (double) irp->bytes_transferred / (double) irp->interval_duration;\n    unit_snprintf(nbuf, UNIT_LEN, bandwidth, test->settings->unit_format);\n    \n    st = timeval_diff(&sp->result->start_time, &irp->interval_start_time);\n    et = timeval_diff(&sp->result->start_time, &irp->interval_end_time);\n    \n    if (test->protocol->id == Ptcp) {\n\tif (test->sender && test->sender_has_retransmits) {\n\t    /* Interval, TCP with retransmits. */\n\t    if (test->json_output)\n\t\tcJSON_AddItemToArray(json_interval_streams, iperf_json_printf(\"socket: %d  start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  retransmits: %d  snd_cwnd:  %d  omitted: %b\", (int64_t) sp->socket, (double) st, (double) et, (double) irp->interval_duration, (int64_t) irp->bytes_transferred, bandwidth * 8, (int64_t) irp->interval_retrans, (int64_t) irp->snd_cwnd, irp->omitted));\n\t    else {\n\t\tunit_snprintf(cbuf, UNIT_LEN, irp->snd_cwnd, 'A');\n\t\tiprintf(test, report_bw_retrans_cwnd_format, sp->socket, st, et, ubuf, nbuf, irp->interval_retrans, cbuf, irp->omitted?report_omitted:\"\");\n\t    }\n\t} else {\n\t    /* Interval, TCP without retransmits. */\n\t    if (test->json_output)\n\t\tcJSON_AddItemToArray(json_interval_streams, iperf_json_printf(\"socket: %d  start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  omitted: %b\", (int64_t) sp->socket, (double) st, (double) et, (double) irp->interval_duration, (int64_t) irp->bytes_transferred, bandwidth * 8, irp->omitted));\n\t    else\n\t\tiprintf(test, report_bw_format, sp->socket, st, et, ubuf, nbuf, irp->omitted?report_omitted:\"\");\n\t}\n    } else {\n\t/* Interval, UDP. */\n\tif (test->sender) {\n\t    if (test->json_output)\n\t\tcJSON_AddItemToArray(json_interval_streams, iperf_json_printf(\"socket: %d  start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  packets: %d  omitted: %b\", (int64_t) sp->socket, (double) st, (double) et, (double) irp->interval_duration, (int64_t) irp->bytes_transferred, bandwidth * 8, (int64_t) irp->interval_packet_count, irp->omitted));\n\t    else\n\t\tiprintf(test, report_bw_udp_sender_format, sp->socket, st, et, ubuf, nbuf, irp->interval_packet_count, irp->omitted?report_omitted:\"\");\n\t} else {\n\t    lost_percent = 100.0 * irp->interval_cnt_error / irp->interval_packet_count;\n\t    if (test->json_output)\n\t\tcJSON_AddItemToArray(json_interval_streams, iperf_json_printf(\"socket: %d  start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  jitter_ms: %f  lost_packets: %d  packets: %d  lost_percent: %f  omitted: %b\", (int64_t) sp->socket, (double) st, (double) et, (double) irp->interval_duration, (int64_t) irp->bytes_transferred, bandwidth * 8, (double) irp->jitter * 1000.0, (int64_t) irp->interval_cnt_error, (int64_t) irp->interval_packet_count, (double) lost_percent, irp->omitted));\n\t    else\n\t\tiprintf(test, report_bw_udp_format, sp->socket, st, et, ubuf, nbuf, irp->jitter * 1000.0, irp->interval_cnt_error, irp->interval_packet_count, lost_percent, irp->omitted?report_omitted:\"\");\n\t}\n    }\n}\n\n/**************************************************************************/\nvoid\niperf_free_stream(struct iperf_stream *sp)\n{\n    struct iperf_interval_results *irp, *nirp;\n\n    /* XXX: need to free interval list too! */\n    munmap(sp->buffer, sp->test->settings->blksize);\n    close(sp->buffer_fd);\n    if (sp->diskfile_fd >= 0)\n\tclose(sp->diskfile_fd);\n    for (irp = TAILQ_FIRST(&sp->result->interval_results); irp != TAILQ_END(sp->result->interval_results); irp = nirp) {\n        nirp = TAILQ_NEXT(irp, irlistentries);\n        free(irp);\n    }\n    free(sp->result);\n    if (sp->send_timer != NULL)\n\ttmr_cancel(sp->send_timer);\n    free(sp);\n}\n\n/**************************************************************************/\nstruct iperf_stream *\niperf_new_stream(struct iperf_test *test, int s)\n{\n    int i;\n    struct iperf_stream *sp;\n    char template[] = \"/tmp/iperf3.XXXXXX\";\n\n    h_errno = 0;\n\n    sp = (struct iperf_stream *) malloc(sizeof(struct iperf_stream));\n    if (!sp) {\n        i_errno = IECREATESTREAM;\n        return NULL;\n    }\n\n    memset(sp, 0, sizeof(struct iperf_stream));\n\n    sp->test = test;\n    sp->settings = test->settings;\n    sp->result = (struct iperf_stream_result *) malloc(sizeof(struct iperf_stream_result));\n    if (!sp->result) {\n        free(sp);\n        i_errno = IECREATESTREAM;\n        return NULL;\n    }\n\n    memset(sp->result, 0, sizeof(struct iperf_stream_result));\n    TAILQ_INIT(&sp->result->interval_results);\n    \n    /* Create and randomize the buffer */\n    sp->buffer_fd = mkstemp(template);\n    if (sp->buffer_fd == -1) {\n        i_errno = IECREATESTREAM;\n        free(sp->result);\n        free(sp);\n        return NULL;\n    }\n    if (unlink(template) < 0) {\n        i_errno = IECREATESTREAM;\n        free(sp->result);\n        free(sp);\n        return NULL;\n    }\n    if (ftruncate(sp->buffer_fd, test->settings->blksize) < 0) {\n        i_errno = IECREATESTREAM;\n        free(sp->result);\n        free(sp);\n        return NULL;\n    }\n    sp->buffer = (char *) mmap(NULL, test->settings->blksize, PROT_READ|PROT_WRITE, MAP_PRIVATE, sp->buffer_fd, 0);\n    if (sp->buffer == MAP_FAILED) {\n        i_errno = IECREATESTREAM;\n        free(sp->result);\n        free(sp);\n        return NULL;\n    }\n    srandom(time(NULL));\n    for (i = 0; i < test->settings->blksize; ++i)\n        sp->buffer[i] = random();\n\n    /* Set socket */\n    sp->socket = s;\n\n    sp->snd = test->protocol->send;\n    sp->rcv = test->protocol->recv;\n\n    if (test->diskfile_name != (char*) 0) {\n\tsp->diskfile_fd = open(test->diskfile_name, test->sender ? O_RDONLY : (O_WRONLY|O_CREAT|O_TRUNC), S_IRUSR|S_IWUSR);\n\tif (sp->diskfile_fd == -1) {\n\t    i_errno = IEFILE;\n            munmap(sp->buffer, sp->test->settings->blksize);\n            free(sp->result);\n            free(sp);\n\t    return NULL;\n\t}\n        sp->snd2 = sp->snd;\n\tsp->snd = diskfile_send;\n\tsp->rcv2 = sp->rcv;\n\tsp->rcv = diskfile_recv;\n    } else\n        sp->diskfile_fd = -1;\n\n    /* Initialize stream */\n    if (iperf_init_stream(sp, test) < 0) {\n        close(sp->buffer_fd);\n        munmap(sp->buffer, sp->test->settings->blksize);\n        free(sp->result);\n        free(sp);\n        return NULL;\n    }\n    iperf_add_stream(test, sp);\n\n    return sp;\n}\n\n/**************************************************************************/\nint\niperf_init_stream(struct iperf_stream *sp, struct iperf_test *test)\n{\n    socklen_t len;\n    int opt;\n\n    len = sizeof(struct sockaddr_storage);\n    if (getsockname(sp->socket, (struct sockaddr *) &sp->local_addr, &len) < 0) {\n        i_errno = IEINITSTREAM;\n        return -1;\n    }\n    len = sizeof(struct sockaddr_storage);\n    if (getpeername(sp->socket, (struct sockaddr *) &sp->remote_addr, &len) < 0) {\n        i_errno = IEINITSTREAM;\n        return -1;\n    }\n\n    /* Set IP TOS */\n    if ((opt = test->settings->tos)) {\n        if (getsockdomain(sp->socket) == AF_INET6) {\n#ifdef IPV6_TCLASS\n            if (setsockopt(sp->socket, IPPROTO_IPV6, IPV6_TCLASS, &opt, sizeof(opt)) < 0) {\n                i_errno = IESETCOS;\n                return -1;\n            }\n#else\n            i_errno = IESETCOS;\n            return -1;\n#endif\n        } else {\n            if (setsockopt(sp->socket, IPPROTO_IP, IP_TOS, &opt, sizeof(opt)) < 0) {\n                i_errno = IESETTOS;\n                return -1;\n            }\n        }\n    }\n\n    return 0;\n}\n\n/**************************************************************************/\nvoid\niperf_add_stream(struct iperf_test *test, struct iperf_stream *sp)\n{\n    int i;\n    struct iperf_stream *n, *prev;\n\n    if (SLIST_EMPTY(&test->streams)) {\n        SLIST_INSERT_HEAD(&test->streams, sp, streams);\n        sp->id = 1;\n    } else {\n        // for (n = test->streams, i = 2; n->next; n = n->next, ++i);\n        i = 2;\n        SLIST_FOREACH(n, &test->streams, streams) {\n            prev = n;\n            ++i;\n        }\n        SLIST_INSERT_AFTER(prev, sp, streams);\n        sp->id = i;\n    }\n}\n\n/* This pair of routines gets inserted into the snd/rcv function pointers\n** when there's a -F flag. They handle the file stuff and call the real\n** snd/rcv functions, which have been saved in snd2/rcv2.\n**\n** The advantage of doing it this way is that in the much more common\n** case of no -F flag, there is zero extra overhead.\n*/\n\nstatic int\ndiskfile_send(struct iperf_stream *sp)\n{\n    int r;\n\n    r = read(sp->diskfile_fd, sp->buffer, sp->test->settings->blksize);\n    if (r == 0)\n        sp->test->done = 1;\n    else\n\tr = sp->snd2(sp);\n    return r;\n}\n\nstatic int\ndiskfile_recv(struct iperf_stream *sp)\n{\n    int r;\n\n    r = sp->rcv2(sp);\n    if (r > 0) {\n\t(void) write(sp->diskfile_fd, sp->buffer, r);\n\t(void) fsync(sp->diskfile_fd);\n    }\n    return r;\n}\n\n\nvoid\niperf_catch_sigend(void (*handler)(int))\n{\n    signal(SIGINT, handler);\n    signal(SIGTERM, handler);\n    signal(SIGHUP, handler);\n}\n\nvoid\niperf_got_sigend(struct iperf_test *test)\n{\n    /*\n     * If we're the client, or if we're a server and running a test,\n     * then dump out the accumulated stats so far.\n     */\n    if (test->role == 'c' ||\n      (test->role == 's' && test->state == TEST_RUNNING)) {\n\n\ttest->done = 1;\n\tcpu_util(test->cpu_util);\n\ttest->stats_callback(test);\n\ttest->state = DISPLAY_RESULTS; /* change local state only */\n\tif (test->on_test_finish)\n\t    test->on_test_finish(test);\n\ttest->reporter_callback(test);\n    }\n\n    if (test->ctrl_sck >= 0) {\n\ttest->state = (test->role == 'c') ? CLIENT_TERMINATE : SERVER_TERMINATE;\n\t(void) Nwrite(test->ctrl_sck, (char*) &test->state, sizeof(signed char), Ptcp);\n    }\n    i_errno = (test->role == 'c') ? IECLIENTTERM : IESERVERTERM;\n    iperf_errexit(test, \"interrupt - %s\", iperf_strerror(i_errno));\n}\n\n\nint\niperf_json_start(struct iperf_test *test)\n{\n    test->json_top = cJSON_CreateObject();\n    if (test->json_top == NULL)\n        return -1;\n    if (test->title)\n\tcJSON_AddStringToObject(test->json_top, \"title\", test->title);\n    test->json_start = cJSON_CreateObject();\n    if (test->json_start == NULL)\n        return -1;\n    cJSON_AddItemToObject(test->json_top, \"start\", test->json_start);\n    test->json_connected = cJSON_CreateArray();\n    if (test->json_connected == NULL)\n        return -1;\n    cJSON_AddItemToObject(test->json_start, \"connected\", test->json_connected);\n    test->json_intervals = cJSON_CreateArray();\n    if (test->json_intervals == NULL)\n        return -1;\n    cJSON_AddItemToObject(test->json_top, \"intervals\", test->json_intervals);\n    test->json_end = cJSON_CreateObject();\n    if (test->json_end == NULL)\n        return -1;\n    cJSON_AddItemToObject(test->json_top, \"end\", test->json_end);\n    return 0;\n}\n\nint\niperf_json_finish(struct iperf_test *test)\n{\n    char *str;\n\n    /* Include server output */\n    if (test->json_server_output) {\n\tcJSON_AddItemToObject(test->json_top, \"server_output_json\", test->json_server_output);\n    }\n    if (test->server_output_text) {\n\tcJSON_AddStringToObject(test->json_top, \"server_output_text\", test->server_output_text);\n    }\n    str = cJSON_Print(test->json_top);\n    if (str == NULL)\n        return -1;\n    fputs(str, stdout);\n    putchar('\\n');\n    fflush(stdout);\n    free(str);\n    cJSON_Delete(test->json_top);\n    test->json_top = test->json_start = test->json_connected = test->json_intervals = test->json_server_output = test->json_end = NULL;\n    return 0;\n}\n\n\n/* CPU affinity stuff - linux only. */\n\nint\niperf_setaffinity(int affinity)\n{\n#ifdef linux\n    cpu_set_t cpu_set;\n\n    CPU_ZERO(&cpu_set);\n    CPU_SET(affinity, &cpu_set);\n    if (sched_setaffinity(0, sizeof(cpu_set_t), &cpu_set) != 0) {\n\ti_errno = IEAFFINITY;\n        return -1;\n    }\n    return 0;\n#else /*linux*/\n    i_errno = IEAFFINITY;\n    return -1;\n#endif /*linux*/\n}\n\nint\niperf_clearaffinity(void)\n{\n#ifdef linux\n    cpu_set_t cpu_set;\n    int i;\n\n    CPU_ZERO(&cpu_set);\n    for (i = 0; i < CPU_SETSIZE; ++i)\n\tCPU_SET(i, &cpu_set);\n    if (sched_setaffinity(0, sizeof(cpu_set_t), &cpu_set) != 0) {\n\ti_errno = IEAFFINITY;\n        return -1;\n    }\n    return 0;\n#else /*linux*/\n    i_errno = IEAFFINITY;\n    return -1;\n#endif /*linux*/\n}\n\nint\niprintf(struct iperf_test *test, const char* format, ...)\n{\n    va_list argp;\n    int r = -1;\n\n    /*\n     * There are roughly two use cases here.  If we're the client,\n     * want to print stuff directly to the output stream.\n     * If we're the sender we might need to buffer up output to send\n     * to the client.\n     *\n     * This doesn't make a whole lot of difference except there are\n     * some chunks of output on the client (on particular the whole\n     * of the server output with --get-server-output) that could\n     * easily exceed the size of the line buffer, but which don't need\n     * to be buffered up anyway.\n     */\n    if (test->role == 'c') {\n\tif (test->title)\n\t    printf(\"%s:  \", test->title);\n\tva_start(argp, format);\n\tr = vprintf(format, argp);\n\tva_end(argp);\n    }\n    else if (test->role == 's') {\n\tchar linebuffer[1024];\n\tva_start(argp, format);\n\tr = vsnprintf(linebuffer, sizeof(linebuffer), format, argp);\n\tva_end(argp);\n\tprintf(\"%s\", linebuffer);\n\n\tif (test->role == 's' && iperf_get_test_get_server_output(test)) {\n\t    struct iperf_textline *l = (struct iperf_textline *) malloc(sizeof(struct iperf_textline));\n\t    l->line = strdup(linebuffer);\n\t    TAILQ_INSERT_TAIL(&(test->server_output_list), l, textlineentries);\n\t}\n    }\n    return r;\n}\n", "/*\n * iperf, Copyright (c) 2014, The Regents of the University of\n * California, through Lawrence Berkeley National Laboratory (subject\n * to receipt of any required approvals from the U.S. Dept. of\n * Energy).  All rights reserved.\n *\n * If you have questions about your rights to use or distribute this\n * software, please contact Berkeley Lab's Technology Transfer\n * Department at TTD@lbl.gov.\n *\n * NOTICE.  This software is owned by the U.S. Department of Energy.\n * As such, the U.S. Government has been granted for itself and others\n * acting on its behalf a paid-up, nonexclusive, irrevocable,\n * worldwide license in the Software to reproduce, prepare derivative\n * works, and perform publicly and display publicly.  Beginning five\n * (5) years after the date permission to assert copyright is obtained\n * from the U.S. Department of Energy, and subject to any subsequent\n * five (5) year renewals, the U.S. Government is granted for itself\n * and others acting on its behalf a paid-up, nonexclusive,\n * irrevocable, worldwide license in the Software to reproduce,\n * prepare derivative works, distribute copies to the public, perform\n * publicly and display publicly, and to permit others to do so.\n *\n * This code is distributed under a BSD style license, see the LICENSE\n * file for complete information.\n */\n/* iperf_util.c\n *\n * Iperf utility functions\n *\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <sys/select.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <time.h>\n#include <errno.h>\n\n#include \"config.h\"\n#include \"cjson.h\"\n\n/* make_cookie\n *\n * Generate and return a cookie string\n *\n * Iperf uses this function to create test \"cookies\" which\n * server as unique test identifiers. These cookies are also\n * used for the authentication of stream connections.\n */\n\nvoid\nmake_cookie(char *cookie)\n{\n    static int randomized = 0;\n    char hostname[500];\n    struct timeval tv;\n    char temp[1000];\n\n    if ( ! randomized )\n        srandom((int) time(0) ^ getpid());\n\n    /* Generate a string based on hostname, time, randomness, and filler. */\n    (void) gethostname(hostname, sizeof(hostname));\n    (void) gettimeofday(&tv, 0);\n    (void) snprintf(temp, sizeof(temp), \"%s.%ld.%06ld.%08lx%08lx.%s\", hostname, (unsigned long int) tv.tv_sec, (unsigned long int) tv.tv_usec, (unsigned long int) random(), (unsigned long int) random(), \"1234567890123456789012345678901234567890\");\n\n    /* Now truncate it to 36 bytes and terminate. */\n    memcpy(cookie, temp, 36);\n    cookie[36] = '\\0';\n}\n\n\n/* is_closed\n *\n * Test if the file descriptor fd is closed.\n * \n * Iperf uses this function to test whether a TCP stream socket\n * is closed, because accepting and denying an invalid connection\n * in iperf_tcp_accept is not considered an error.\n */\n\nint\nis_closed(int fd)\n{\n    struct timeval tv;\n    fd_set readset;\n\n    FD_ZERO(&readset);\n    FD_SET(fd, &readset);\n    tv.tv_sec = 0;\n    tv.tv_usec = 0;\n\n    if (select(fd+1, &readset, NULL, NULL, &tv) < 0) {\n        if (errno == EBADF)\n            return 1;\n    }\n    return 0;\n}\n\n\ndouble\ntimeval_to_double(struct timeval * tv)\n{\n    double d;\n\n    d = tv->tv_sec + tv->tv_usec / 1000000;\n\n    return d;\n}\n\nint\ntimeval_equals(struct timeval * tv0, struct timeval * tv1)\n{\n    if ( tv0->tv_sec == tv1->tv_sec && tv0->tv_usec == tv1->tv_usec )\n\treturn 1;\n    else\n\treturn 0;\n}\n\ndouble\ntimeval_diff(struct timeval * tv0, struct timeval * tv1)\n{\n    double time1, time2;\n    \n    time1 = tv0->tv_sec + (tv0->tv_usec / 1000000.0);\n    time2 = tv1->tv_sec + (tv1->tv_usec / 1000000.0);\n\n    time1 = time1 - time2;\n    if (time1 < 0)\n        time1 = -time1;\n    return time1;\n}\n\n\nint\ndelay(int64_t ns)\n{\n    struct timespec req, rem;\n\n    req.tv_sec = 0;\n\n    while (ns >= 1000000000L) {\n        ns -= 1000000000L;\n        req.tv_sec += 1;\n    }\n\n    req.tv_nsec = ns;\n\n    while (nanosleep(&req, &rem) == -1)\n        if (EINTR == errno)\n            memcpy(&req, &rem, sizeof(rem));\n        else\n            return -1;\n    return 0;\n}\n\n# ifdef DELAY_SELECT_METHOD\nint\ndelay(int us)\n{\n    struct timeval tv;\n\n    tv.tv_sec = 0;\n    tv.tv_usec = us;\n    (void) select(1, (fd_set *) 0, (fd_set *) 0, (fd_set *) 0, &tv);\n    return 1;\n}\n#endif\n\n\nvoid\ncpu_util(double pcpu[3])\n{\n    static struct timeval last;\n    static clock_t clast;\n    static struct rusage rlast;\n    struct timeval temp;\n    clock_t ctemp;\n    struct rusage rtemp;\n    double timediff;\n    double userdiff;\n    double systemdiff;\n\n    if (pcpu == NULL) {\n        gettimeofday(&last, NULL);\n        clast = clock();\n\tgetrusage(RUSAGE_SELF, &rlast);\n        return;\n    }\n\n    gettimeofday(&temp, NULL);\n    ctemp = clock();\n    getrusage(RUSAGE_SELF, &rtemp);\n\n    timediff = ((temp.tv_sec * 1000000.0 + temp.tv_usec) -\n                (last.tv_sec * 1000000.0 + last.tv_usec));\n    userdiff = ((rtemp.ru_utime.tv_sec * 1000000.0 + rtemp.ru_utime.tv_usec) -\n                (rlast.ru_utime.tv_sec * 1000000.0 + rlast.ru_utime.tv_usec));\n    systemdiff = ((rtemp.ru_stime.tv_sec * 1000000.0 + rtemp.ru_stime.tv_usec) -\n                  (rlast.ru_stime.tv_sec * 1000000.0 + rlast.ru_stime.tv_usec));\n\n    pcpu[0] = (((ctemp - clast) * 1000000.0 / CLOCKS_PER_SEC) / timediff) * 100;\n    pcpu[1] = (userdiff / timediff) * 100;\n    pcpu[2] = (systemdiff / timediff) * 100;\n}\n\nchar*\nget_system_info(void)\n    {\n    FILE* fp;\n    static char buf[1000];\n\n    fp = popen(\"uname -a\", \"r\");\n    if (fp == NULL)\n\treturn NULL;\n    fgets(buf, sizeof(buf), fp);\n    pclose(fp);\n    return buf;\n    }\n\n\n/* Helper routine for building cJSON objects in a printf-like manner.\n**\n** Sample call:\n**   j = iperf_json_printf(\"foo: %b  bar: %d  bletch: %f  eep: %s\", b, i, f, s);\n**\n** The four formatting characters and the types they expect are:\n**   %b  boolean           int\n**   %d  integer           int64_t\n**   %f  floating point    double\n**   %s  string            char *\n** If the values you're passing in are not these exact types, you must\n** cast them, there is no automatic type coercion/widening here.\n**\n** The colons mark the end of field names, and blanks are ignored.\n**\n** This routine is not particularly robust, but it's not part of the API,\n** it's just for internal iperf3 use.\n*/\ncJSON*\niperf_json_printf(const char *format, ...)\n{\n    cJSON* o;\n    va_list argp;\n    const char *cp;\n    char name[100];\n    char* np;\n    cJSON* j;\n\n    o = cJSON_CreateObject();\n    if (o == NULL)\n        return NULL;\n    va_start(argp, format);\n    np = name;\n    for (cp = format; *cp != '\\0'; ++cp) {\n\tswitch (*cp) {\n\t    case ' ':\n\t    break;\n\t    case ':':\n\t    *np = '\\0';\n\t    break;\n\t    case '%':\n\t    ++cp;\n\t    switch (*cp) {\n\t\tcase 'b':\n\t\tj = cJSON_CreateBool(va_arg(argp, int));\n\t\tbreak;\n\t\tcase 'd':\n\t\tj = cJSON_CreateNumber(va_arg(argp, int64_t));\n\t\tbreak;\n\t\tcase 'f':\n\t\tj = cJSON_CreateNumber(va_arg(argp, double));\n\t\tbreak;\n\t\tcase 's':\n\t\tj = cJSON_CreateString(va_arg(argp, char *));\n\t\tbreak;\n\t\tdefault:\n\t\treturn NULL;\n\t    }\n\t    if (j == NULL)\n\t\treturn NULL;\n\t    cJSON_AddItemToObject(o, name, j);\n\t    np = name;\n\t    break;\n\t    default:\n\t    *np++ = *cp;\n\t    break;\n\t}\n    }\n    va_end(argp);\n    return o;\n}\n\n/* Debugging routine to dump out an fd_set. */\nvoid\niperf_dump_fdset(FILE *fp, char *str, int nfds, fd_set *fds)\n{\n    int fd;\n    int comma;\n\n    fprintf(fp, \"%s: [\", str);\n    comma = 0;\n    for (fd = 0; fd < nfds; ++fd) {\n        if (FD_ISSET(fd, fds)) {\n\t    if (comma)\n\t\tfprintf(fp, \", \");\n\t    fprintf(fp, \"%d\", fd);\n\t    comma = 1;\n\t}\n    }\n    fprintf(fp, \"]\\n\");\n}\n"], "filenames": ["configure.ac", "src/cjson.c", "src/cjson.h", "src/iperf_api.c", "src/iperf_util.c"], "buggy_code_start_loc": [64, 43, 32, 526, 275], "buggy_code_end_loc": [64, 1034, 123, 1419, 279], "fixing_code_start_loc": [65, 43, 32, 526, 275], "fixing_code_end_loc": [71, 763, 148, 1429, 279], "type": "CWE-120", "message": "The parse_string function in cjson.c in the cJSON library mishandles UTF8/16 strings, which allows remote attackers to cause a denial of service (crash) or execute arbitrary code via a non-hex character in a JSON string, which triggers a heap-based buffer overflow.", "other": {"cve": {"id": "CVE-2016-4303", "sourceIdentifier": "cret@cert.org", "published": "2016-09-26T14:59:01.553", "lastModified": "2022-06-30T15:13:23.913", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The parse_string function in cjson.c in the cJSON library mishandles UTF8/16 strings, which allows remote attackers to cause a denial of service (crash) or execute arbitrary code via a non-hex character in a JSON string, which triggers a heap-based buffer overflow."}, {"lang": "es", "value": "La funci\u00f3n parse_string en cjson.c en la librer\u00eda cJSON no maneja correctamente cadenas UTF8/16, lo que permite a atacantes remotos provocar una denegaci\u00f3n de servicio (ca\u00edda) o ejecutar c\u00f3digo arbitrario a trav\u00e9s de un car\u00e1cter no hexadecimal en una cadena JSON, lo que desencadena un desbordamiento de b\u00fafer basado en memoria din\u00e1mica."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:iperf3_project:iperf3:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0", "versionEndExcluding": "3.0.12", "matchCriteriaId": "2BCFDE7A-C460-408E-BDB4-F75D31BB38CB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:iperf3_project:iperf3:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.1", "versionEndExcluding": "3.1.3", "matchCriteriaId": "8747285A-16C3-49CF-A43E-57BD1F297DE6"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:novell:suse_package_hub_for_suse_linux_enterprise:12:*:*:*:*:*:*:*", "matchCriteriaId": "B5BEF8F1-A70F-455C-BFDD-09E0A658F702"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:42.1:*:*:*:*:*:*:*", "matchCriteriaId": "4863BE36-D16A-4D75-90D9-FD76DB5B48B7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:13.2:*:*:*:*:*:*:*", "matchCriteriaId": "03117DF1-3BEC-4B8D-AD63-DBBDB2126081"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "http://blog.talosintel.com/2016/06/esnet-vulnerability.html", "source": "cret@cert.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2016-08/msg00082.html", "source": "cret@cert.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2016-08/msg00090.html", "source": "cret@cert.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://software.es.net/iperf/news.html#security-issue-iperf-3-1-3-iperf-3-0-12-released", "source": "cret@cert.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "http://www.talosintelligence.com/reports/TALOS-2016-0164/", "source": "cret@cert.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a", "source": "cret@cert.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/01/msg00023.html", "source": "cret@cert.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://raw.githubusercontent.com/esnet/security/master/cve-2016-4303/esnet-secadv-2016-0001.txt.asc", "source": "cret@cert.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a"}}