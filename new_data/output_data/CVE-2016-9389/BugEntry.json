{"buggy_code": ["/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2003 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * Image Library\n *\n * $Id$\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n#include <ctype.h>\n#include <inttypes.h>\n\n#include \"jasper/jas_math.h\"\n#include \"jasper/jas_image.h\"\n#include \"jasper/jas_malloc.h\"\n#include \"jasper/jas_string.h\"\n#include \"jasper/jas_debug.h\"\n\n/******************************************************************************\\\n* Types.\n\\******************************************************************************/\n\n#define\tFLOORDIV(x, y) ((x) / (y))\n\n/******************************************************************************\\\n* Local prototypes.\n\\******************************************************************************/\n\nstatic jas_image_cmpt_t *jas_image_cmpt_create0(void);\nstatic void jas_image_cmpt_destroy(jas_image_cmpt_t *cmpt);\nstatic jas_image_cmpt_t *jas_image_cmpt_create(uint_fast32_t tlx, uint_fast32_t tly,\n  uint_fast32_t hstep, uint_fast32_t vstep, uint_fast32_t width, uint_fast32_t\n  height, uint_fast16_t depth, bool sgnd, uint_fast32_t inmem);\nstatic void jas_image_setbbox(jas_image_t *image);\nstatic jas_image_cmpt_t *jas_image_cmpt_copy(jas_image_cmpt_t *cmpt);\nstatic int jas_image_growcmpts(jas_image_t *image, int maxcmpts);\nstatic uint_fast32_t inttobits(jas_seqent_t v, int prec, bool sgnd);\nstatic jas_seqent_t bitstoint(uint_fast32_t v, int prec, bool sgnd);\nstatic int putint(jas_stream_t *out, int sgnd, int prec, long val);\nstatic int getint(jas_stream_t *in, int sgnd, int prec, long *val);\nstatic void jas_image_calcbbox2(jas_image_t *image, jas_image_coord_t *tlx,\n  jas_image_coord_t *tly, jas_image_coord_t *brx, jas_image_coord_t *bry);\nstatic long uptomult(long x, long y);\nstatic long downtomult(long x, long y);\nstatic long convert(long val, int oldsgnd, int oldprec, int newsgnd,\n  int newprec);\nstatic void jas_image_calcbbox2(jas_image_t *image, jas_image_coord_t *tlx,\n  jas_image_coord_t *tly, jas_image_coord_t *brx, jas_image_coord_t *bry);\n\n/******************************************************************************\\\n* Global data.\n\\******************************************************************************/\n\nstatic int jas_image_numfmts = 0;\nstatic jas_image_fmtinfo_t jas_image_fmtinfos[JAS_IMAGE_MAXFMTS];\n\n/******************************************************************************\\\n* Create and destroy operations.\n\\******************************************************************************/\n\njas_image_t *jas_image_create(int numcmpts, jas_image_cmptparm_t *cmptparms,\n  int clrspc)\n{\n\tjas_image_t *image;\n\tuint_fast32_t rawsize;\n\tuint_fast32_t inmem;\n\tint cmptno;\n\tjas_image_cmptparm_t *cmptparm;\n\n\tif (!(image = jas_image_create0())) {\n\t\treturn 0;\n\t}\n\n\timage->clrspc_ = clrspc;\n\timage->maxcmpts_ = numcmpts;\n\timage->inmem_ = true;\n\n\t/* Allocate memory for the per-component information. */\n\tif (!(image->cmpts_ = jas_alloc2(image->maxcmpts_,\n\t  sizeof(jas_image_cmpt_t *)))) {\n\t\tjas_image_destroy(image);\n\t\treturn 0;\n\t}\n\t/* Initialize in case of failure. */\n\tfor (cmptno = 0; cmptno < image->maxcmpts_; ++cmptno) {\n\t\timage->cmpts_[cmptno] = 0;\n\t}\n\n\t/* Compute the approximate raw size of the image. */\n\trawsize = 0;\n\tfor (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,\n\t  ++cmptparm) {\n\t\trawsize += cmptparm->width * cmptparm->height *\n\t\t  (cmptparm->prec + 7) / 8;\n\t}\n\t/* Decide whether to buffer the image data in memory, based on the\n\t  raw size of the image. */\n\tinmem = (rawsize < JAS_IMAGE_INMEMTHRESH);\n\n\t/* Create the individual image components. */\n\tfor (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,\n\t  ++cmptparm) {\n\t\tif (!(image->cmpts_[cmptno] = jas_image_cmpt_create(cmptparm->tlx,\n\t\t  cmptparm->tly, cmptparm->hstep, cmptparm->vstep,\n\t\t  cmptparm->width, cmptparm->height, cmptparm->prec,\n\t\t  cmptparm->sgnd, inmem))) {\n\t\t\tjas_image_destroy(image);\n\t\t\treturn 0;\n\t\t}\n\t\t++image->numcmpts_;\n\t}\n\n\t/* Determine the bounding box for all of the components on the\n\t  reference grid (i.e., the image area) */\n\tjas_image_setbbox(image);\n\n\treturn image;\n}\n\njas_image_t *jas_image_create0()\n{\n\tjas_image_t *image;\n\n\tif (!(image = jas_malloc(sizeof(jas_image_t)))) {\n\t\treturn 0;\n\t}\n\n\timage->tlx_ = 0;\n\timage->tly_ = 0;\n\timage->brx_ = 0;\n\timage->bry_ = 0;\n\timage->clrspc_ = JAS_CLRSPC_UNKNOWN;\n\timage->numcmpts_ = 0;\n\timage->maxcmpts_ = 0;\n\timage->cmpts_ = 0;\n\timage->inmem_ = true;\n\timage->cmprof_ = 0;\n\n\treturn image;\n}\n\njas_image_t *jas_image_copy(jas_image_t *image)\n{\n\tjas_image_t *newimage;\n\tint cmptno;\n\n\tif (!(newimage = jas_image_create0())) {\n\t\tgoto error;\n\t}\n\n\tif (jas_image_growcmpts(newimage, image->numcmpts_)) {\n\t\tgoto error;\n\t}\n\tfor (cmptno = 0; cmptno < image->numcmpts_; ++cmptno) {\n\t\tif (!(newimage->cmpts_[cmptno] = jas_image_cmpt_copy(image->cmpts_[cmptno]))) {\n\t\t\tgoto error;\n\t\t}\n\t\t++newimage->numcmpts_;\n\t}\n\n\tjas_image_setbbox(newimage);\n\n\tif (image->cmprof_) {\n\t\tif (!(newimage->cmprof_ = jas_cmprof_copy(image->cmprof_)))\n\t\t\tgoto error;\n\t}\n\n\treturn newimage;\nerror:\n\tif (newimage) {\n\t\tjas_image_destroy(newimage);\n\t}\n\treturn 0;\n}\n\nstatic jas_image_cmpt_t *jas_image_cmpt_create0()\n{\n\tjas_image_cmpt_t *cmpt;\n\tif (!(cmpt = jas_malloc(sizeof(jas_image_cmpt_t)))) {\n\t\treturn 0;\n\t}\n\tmemset(cmpt, 0, sizeof(jas_image_cmpt_t));\n\tcmpt->type_ = JAS_IMAGE_CT_UNKNOWN;\n\treturn cmpt;\n}\n\nstatic jas_image_cmpt_t *jas_image_cmpt_copy(jas_image_cmpt_t *cmpt)\n{\n\tjas_image_cmpt_t *newcmpt;\n\n\tif (!(newcmpt = jas_image_cmpt_create0())) {\n\t\treturn 0;\n\t}\n\tnewcmpt->tlx_ = cmpt->tlx_;\n\tnewcmpt->tly_ = cmpt->tly_;\n\tnewcmpt->hstep_ = cmpt->hstep_;\n\tnewcmpt->vstep_ = cmpt->vstep_;\n\tnewcmpt->width_ = cmpt->width_;\n\tnewcmpt->height_ = cmpt->height_;\n\tnewcmpt->prec_ = cmpt->prec_;\n\tnewcmpt->sgnd_ = cmpt->sgnd_;\n\tnewcmpt->cps_ = cmpt->cps_;\n\tnewcmpt->type_ = cmpt->type_;\n\tif (!(newcmpt->stream_ = jas_stream_memopen(0, 0))) {\n\t\tgoto error;\n\t}\n\tif (jas_stream_seek(cmpt->stream_, 0, SEEK_SET)) {\n\t\tgoto error;\n\t}\n\tif (jas_stream_copy(newcmpt->stream_, cmpt->stream_, -1)) {\n\t\tgoto error;\n\t}\n\tif (jas_stream_seek(newcmpt->stream_, 0, SEEK_SET)) {\n\t\tgoto error;\n\t}\n\treturn newcmpt;\nerror:\n\tif (newcmpt) {\n\t\tjas_image_cmpt_destroy(newcmpt);\n\t}\n\treturn 0;\n}\n\nvoid jas_image_destroy(jas_image_t *image)\n{\n\tint i;\n\n\tif (image->cmpts_) {\n\t\tfor (i = 0; i < image->numcmpts_; ++i) {\n\t\t\tjas_image_cmpt_destroy(image->cmpts_[i]);\n\t\t\timage->cmpts_[i] = 0;\n\t\t}\n\t\tjas_free(image->cmpts_);\n\t}\n\tif (image->cmprof_)\n\t\tjas_cmprof_destroy(image->cmprof_);\n\tjas_free(image);\n}\n\nstatic jas_image_cmpt_t *jas_image_cmpt_create(uint_fast32_t tlx,\n  uint_fast32_t tly, uint_fast32_t hstep, uint_fast32_t vstep,\n  uint_fast32_t width, uint_fast32_t height, uint_fast16_t depth, bool sgnd,\n  uint_fast32_t inmem)\n{\n\tjas_image_cmpt_t *cmpt;\n\tsize_t size;\n\n\tif (!(cmpt = jas_malloc(sizeof(jas_image_cmpt_t)))) {\n\t\tgoto error;\n\t}\n\n\tcmpt->type_ = JAS_IMAGE_CT_UNKNOWN;\n\tcmpt->tlx_ = tlx;\n\tcmpt->tly_ = tly;\n\tcmpt->hstep_ = hstep;\n\tcmpt->vstep_ = vstep;\n\tcmpt->width_ = width;\n\tcmpt->height_ = height;\n\tcmpt->prec_ = depth;\n\tcmpt->sgnd_ = sgnd;\n\tcmpt->stream_ = 0;\n\tcmpt->cps_ = (depth + 7) / 8;\n\n\t// Compute the number of samples in the image component, while protecting\n\t// against overflow.\n\t// size = cmpt->width_ * cmpt->height_ * cmpt->cps_;\n\tif (!jas_safe_size_mul(cmpt->width_, cmpt->height_, &size) ||\n\t  !jas_safe_size_mul(size, cmpt->cps_, &size)) {\n\t\tgoto error;\n\t}\n\tcmpt->stream_ = (inmem) ? jas_stream_memopen(0, size) :\n\t  jas_stream_tmpfile();\n\tif (!cmpt->stream_) {\n\t\tgoto error;\n\t}\n\n\t/* Zero the component data.  This isn't necessary, but it is\n\tconvenient for debugging purposes. */\n\t/* Note: conversion of size - 1 to long can overflow */\n\tif (jas_stream_seek(cmpt->stream_, size - 1, SEEK_SET) < 0 ||\n\t  jas_stream_putc(cmpt->stream_, 0) == EOF ||\n\t  jas_stream_seek(cmpt->stream_, 0, SEEK_SET) < 0) {\n\t\tgoto error;\n\t}\n\n\treturn cmpt;\n\nerror:\n\tif (cmpt) {\n\t\tjas_image_cmpt_destroy(cmpt);\n\t}\n\treturn 0;\n}\n\nstatic void jas_image_cmpt_destroy(jas_image_cmpt_t *cmpt)\n{\n\tif (cmpt->stream_) {\n\t\tjas_stream_close(cmpt->stream_);\n\t}\n\tjas_free(cmpt);\n}\n\n/******************************************************************************\\\n* Load and save operations.\n\\******************************************************************************/\n\njas_image_t *jas_image_decode(jas_stream_t *in, int fmt, char *optstr)\n{\n\tjas_image_fmtinfo_t *fmtinfo;\n\tjas_image_t *image;\n\n\timage = 0;\n\n\t/* If possible, try to determine the format of the input data. */\n\tif (fmt < 0) {\n\t\tif ((fmt = jas_image_getfmt(in)) < 0)\n\t\t\tgoto error;\n\t}\n\n\t/* Is it possible to decode an image represented in this format? */\n\tif (!(fmtinfo = jas_image_lookupfmtbyid(fmt)))\n\t\tgoto error;\n\tif (!fmtinfo->ops.decode)\n\t\tgoto error;\n\n\t/* Decode the image. */\n\tif (!(image = (*fmtinfo->ops.decode)(in, optstr)))\n\t\tgoto error;\n\n\t/* Create a color profile if needed. */\n\tif (!jas_clrspc_isunknown(image->clrspc_) &&\n\t  !jas_clrspc_isgeneric(image->clrspc_) && !image->cmprof_) {\n\t\tif (!(image->cmprof_ =\n\t\t  jas_cmprof_createfromclrspc(jas_image_clrspc(image))))\n\t\t\tgoto error;\n\t}\n\n\treturn image;\nerror:\n\tif (image)\n\t\tjas_image_destroy(image);\n\treturn 0;\n}\n\nint jas_image_encode(jas_image_t *image, jas_stream_t *out, int fmt, char *optstr)\n{\n\tjas_image_fmtinfo_t *fmtinfo;\n\tif (!(fmtinfo = jas_image_lookupfmtbyid(fmt))) {\n\t\treturn -1;\n\t}\n\treturn (fmtinfo->ops.encode) ? (*fmtinfo->ops.encode)(image, out,\n\t  optstr) : (-1);\n}\n\n/******************************************************************************\\\n* Component read and write operations.\n\\******************************************************************************/\n\nint jas_image_readcmpt(jas_image_t *image, int cmptno, jas_image_coord_t x,\n  jas_image_coord_t y, jas_image_coord_t width, jas_image_coord_t height,\n  jas_matrix_t *data)\n{\n\tjas_image_cmpt_t *cmpt;\n\tjas_image_coord_t i;\n\tjas_image_coord_t j;\n\tint k;\n\tjas_seqent_t v;\n\tint c;\n\tjas_seqent_t *dr;\n\tjas_seqent_t *d;\n\tint drs;\n\n\tif (cmptno < 0 || cmptno >= image->numcmpts_) {\n\t\treturn -1;\n\t}\n\n\tcmpt = image->cmpts_[cmptno];\n\tif (x >= cmpt->width_ || y >= cmpt->height_ ||\n\t  x + width > cmpt->width_ ||\n\t  y + height > cmpt->height_) {\n\t\treturn -1;\n\t}\n\n\tif (!jas_matrix_numrows(data) || !jas_matrix_numcols(data)) {\n\t\treturn -1;\n\t}\n\n\tif (jas_matrix_numrows(data) != height || jas_matrix_numcols(data) != width) {\n\t\tif (jas_matrix_resize(data, height, width)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tdr = jas_matrix_getref(data, 0, 0);\n\tdrs = jas_matrix_rowstep(data);\n\tfor (i = 0; i < height; ++i, dr += drs) {\n\t\td = dr;\n\t\tif (jas_stream_seek(cmpt->stream_, (cmpt->width_ * (y + i) + x)\n\t\t  * cmpt->cps_, SEEK_SET) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (j = width; j > 0; --j, ++d) {\n\t\t\tv = 0;\n\t\t\tfor (k = cmpt->cps_; k > 0; --k) {\n\t\t\t\tif ((c = jas_stream_getc(cmpt->stream_)) == EOF) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tv = (v << 8) | (c & 0xff);\n\t\t\t}\n\t\t\t*d = bitstoint(v, cmpt->prec_, cmpt->sgnd_);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint jas_image_writecmpt(jas_image_t *image, int cmptno, jas_image_coord_t x, jas_image_coord_t y, jas_image_coord_t width,\n  jas_image_coord_t height, jas_matrix_t *data)\n{\n\tjas_image_cmpt_t *cmpt;\n\tjas_image_coord_t i;\n\tjas_image_coord_t j;\n\tjas_seqent_t *d;\n\tjas_seqent_t *dr;\n\tint drs;\n\tjas_seqent_t v;\n\tint k;\n\tint c;\n\n\tif (cmptno < 0 || cmptno >= image->numcmpts_) {\n\t\treturn -1;\n\t}\n\n\tcmpt = image->cmpts_[cmptno];\n\tif (x >= cmpt->width_ || y >= cmpt->height_ ||\n\t  x + width > cmpt->width_ ||\n\t  y + height > cmpt->height_) {\n\t\treturn -1;\n\t}\n\n\tif (!jas_matrix_numrows(data) || !jas_matrix_numcols(data)) {\n\t\treturn -1;\n\t}\n\n\tif (jas_matrix_numrows(data) != height || jas_matrix_numcols(data) != width) {\n\t\treturn -1;\n\t}\n\n\tdr = jas_matrix_getref(data, 0, 0);\n\tdrs = jas_matrix_rowstep(data);\n\tfor (i = 0; i < height; ++i, dr += drs) {\n\t\td = dr;\n\t\tif (jas_stream_seek(cmpt->stream_, (cmpt->width_ * (y + i) + x)\n\t\t  * cmpt->cps_, SEEK_SET) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (j = width; j > 0; --j, ++d) {\n\t\t\tv = inttobits(*d, cmpt->prec_, cmpt->sgnd_);\n\t\t\tfor (k = cmpt->cps_; k > 0; --k) {\n\t\t\t\tc = (v >> (8 * (cmpt->cps_ - 1))) & 0xff;\n\t\t\t\tif (jas_stream_putc(cmpt->stream_,\n\t\t\t\t  (unsigned char) c) == EOF) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tv <<= 8;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/******************************************************************************\\\n* File format operations.\n\\******************************************************************************/\n\nvoid jas_image_clearfmts()\n{\n\tint i;\n\tjas_image_fmtinfo_t *fmtinfo;\n\tfor (i = 0; i < jas_image_numfmts; ++i) {\n\t\tfmtinfo = &jas_image_fmtinfos[i];\n\t\tif (fmtinfo->name) {\n\t\t\tjas_free(fmtinfo->name);\n\t\t\tfmtinfo->name = 0;\n\t\t}\n\t\tif (fmtinfo->ext) {\n\t\t\tjas_free(fmtinfo->ext);\n\t\t\tfmtinfo->ext = 0;\n\t\t}\n\t\tif (fmtinfo->desc) {\n\t\t\tjas_free(fmtinfo->desc);\n\t\t\tfmtinfo->desc = 0;\n\t\t}\n\t}\n\tjas_image_numfmts = 0;\n}\n\nint jas_image_addfmt(int id, char *name, char *ext, char *desc,\n  jas_image_fmtops_t *ops)\n{\n\tjas_image_fmtinfo_t *fmtinfo;\n\tassert(id >= 0 && name && ext && ops);\n\tif (jas_image_numfmts >= JAS_IMAGE_MAXFMTS) {\n\t\treturn -1;\n\t}\n\tfmtinfo = &jas_image_fmtinfos[jas_image_numfmts];\n\tfmtinfo->id = id;\n\tif (!(fmtinfo->name = jas_strdup(name))) {\n\t\treturn -1;\n\t}\n\tif (!(fmtinfo->ext = jas_strdup(ext))) {\n\t\tjas_free(fmtinfo->name);\n\t\treturn -1;\n\t}\n\tif (!(fmtinfo->desc = jas_strdup(desc))) {\n\t\tjas_free(fmtinfo->name);\n\t\tjas_free(fmtinfo->ext);\n\t\treturn -1;\n\t}\n\tfmtinfo->ops = *ops;\n\t++jas_image_numfmts;\n\treturn 0;\n}\n\nint jas_image_strtofmt(char *name)\n{\n\tjas_image_fmtinfo_t *fmtinfo;\n\tif (!(fmtinfo = jas_image_lookupfmtbyname(name))) {\n\t\treturn -1;\n\t}\n\treturn fmtinfo->id;\n}\n\nchar *jas_image_fmttostr(int fmt)\n{\n\tjas_image_fmtinfo_t *fmtinfo;\n\tif (!(fmtinfo = jas_image_lookupfmtbyid(fmt))) {\n\t\treturn 0;\n\t}\n\treturn fmtinfo->name;\n}\n\nint jas_image_getfmt(jas_stream_t *in)\n{\n\tjas_image_fmtinfo_t *fmtinfo;\n\tint found;\n\tint i;\n\n\t/* Check for data in each of the supported formats. */\n\tfound = 0;\n\tfor (i = 0, fmtinfo = jas_image_fmtinfos; i < jas_image_numfmts; ++i,\n\t  ++fmtinfo) {\n\t\tif (fmtinfo->ops.validate) {\n\t\t\t/* Is the input data valid for this format? */\n\t\t\tif (!(*fmtinfo->ops.validate)(in)) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn found ? fmtinfo->id : (-1);\n}\n\nint jas_image_fmtfromname(char *name)\n{\n\tint i;\n\tchar *ext;\n\tjas_image_fmtinfo_t *fmtinfo;\n\t/* Get the file name extension. */\n\tif (!(ext = strrchr(name, '.'))) {\n\t\treturn -1;\n\t}\n\t++ext;\n\t/* Try to find a format that uses this extension. */\t\n\tfor (i = 0, fmtinfo = jas_image_fmtinfos; i < jas_image_numfmts; ++i,\n\t  ++fmtinfo) {\n\t\t/* Do we have a match? */\n\t\tif (!strcmp(ext, fmtinfo->ext)) {\n\t\t\treturn fmtinfo->id;\n\t\t}\n\t}\n\treturn -1;\n}\n\n/******************************************************************************\\\n* Miscellaneous operations.\n\\******************************************************************************/\n\nuint_fast32_t jas_image_rawsize(jas_image_t *image)\n{\n\tuint_fast32_t rawsize;\n\tint cmptno;\n\tjas_image_cmpt_t *cmpt;\n\n\trawsize = 0;\n\tfor (cmptno = 0; cmptno < image->numcmpts_; ++cmptno) {\n\t\tcmpt = image->cmpts_[cmptno];\n\t\trawsize += (cmpt->width_ * cmpt->height_ * cmpt->prec_ +\n\t\t  7) / 8;\n\t}\n\treturn rawsize;\n}\n\nvoid jas_image_delcmpt(jas_image_t *image, int cmptno)\n{\n\tif (cmptno >= image->numcmpts_) {\n\t\treturn;\n\t}\n\tjas_image_cmpt_destroy(image->cmpts_[cmptno]);\n\tif (cmptno < image->numcmpts_) {\n\t\tmemmove(&image->cmpts_[cmptno], &image->cmpts_[cmptno + 1],\n\t\t  (image->numcmpts_ - 1 - cmptno) * sizeof(jas_image_cmpt_t *));\n\t}\n\t--image->numcmpts_;\n\n\tjas_image_setbbox(image);\n}\n\nint jas_image_addcmpt(jas_image_t *image, int cmptno,\n  jas_image_cmptparm_t *cmptparm)\n{\n\tjas_image_cmpt_t *newcmpt;\n\tif (cmptno < 0) {\n\t\tcmptno = image->numcmpts_;\n\t}\n\tassert(cmptno >= 0 && cmptno <= image->numcmpts_);\n\tif (image->numcmpts_ >= image->maxcmpts_) {\n\t\tif (jas_image_growcmpts(image, image->maxcmpts_ + 128)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (!(newcmpt = jas_image_cmpt_create(cmptparm->tlx,\n\t  cmptparm->tly, cmptparm->hstep, cmptparm->vstep,\n\t  cmptparm->width, cmptparm->height, cmptparm->prec,\n\t  cmptparm->sgnd, 1))) {\n\t\treturn -1;\n\t}\n\tif (cmptno < image->numcmpts_) {\n\t\tmemmove(&image->cmpts_[cmptno + 1], &image->cmpts_[cmptno],\n\t\t  (image->numcmpts_ - cmptno) * sizeof(jas_image_cmpt_t *));\n\t}\n\timage->cmpts_[cmptno] = newcmpt;\n\t++image->numcmpts_;\n\n\tjas_image_setbbox(image);\n\n\treturn 0;\n}\n\njas_image_fmtinfo_t *jas_image_lookupfmtbyid(int id)\n{\n\tint i;\n\tjas_image_fmtinfo_t *fmtinfo;\n\n\tfor (i = 0, fmtinfo = jas_image_fmtinfos; i < jas_image_numfmts; ++i, ++fmtinfo) {\n\t\tif (fmtinfo->id == id) {\n\t\t\treturn fmtinfo;\n\t\t}\n\t}\n\treturn 0;\n}\n\njas_image_fmtinfo_t *jas_image_lookupfmtbyname(const char *name)\n{\n\tint i;\n\tjas_image_fmtinfo_t *fmtinfo;\n\n\tfor (i = 0, fmtinfo = jas_image_fmtinfos; i < jas_image_numfmts; ++i, ++fmtinfo) {\n\t\tif (!strcmp(fmtinfo->name, name)) {\n\t\t\treturn fmtinfo;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n\n\n\nstatic uint_fast32_t inttobits(jas_seqent_t v, int prec, bool sgnd)\n{\n\tuint_fast32_t ret;\n\tret = ((sgnd && v < 0) ? ((1 << prec) + v) : v) & JAS_ONES(prec);\n\treturn ret;\n}\n\nstatic jas_seqent_t bitstoint(uint_fast32_t v, int prec, bool sgnd)\n{\n\tjas_seqent_t ret;\n\tv &= JAS_ONES(prec);\n\tret = (sgnd && (v & (1 << (prec - 1)))) ? (v - (1 << prec)) : v;\n\treturn ret;\n}\n\nstatic void jas_image_setbbox(jas_image_t *image)\n{\n\tjas_image_cmpt_t *cmpt;\n\tint cmptno;\n\tint_fast32_t x;\n\tint_fast32_t y;\n\n\tif (image->numcmpts_ > 0) {\n\t\t/* Determine the bounding box for all of the components on the\n\t\t  reference grid (i.e., the image area) */\n\t\tcmpt = image->cmpts_[0];\n\t\timage->tlx_ = cmpt->tlx_;\n\t\timage->tly_ = cmpt->tly_;\n\t\timage->brx_ = cmpt->tlx_ + cmpt->hstep_ * (cmpt->width_ - 1) + 1;\n\t\timage->bry_ = cmpt->tly_ + cmpt->vstep_ * (cmpt->height_ - 1) + 1;\n\t\tfor (cmptno = 1; cmptno < image->numcmpts_; ++cmptno) {\n\t\t\tcmpt = image->cmpts_[cmptno];\n\t\t\tif (image->tlx_ > cmpt->tlx_) {\n\t\t\t\timage->tlx_ = cmpt->tlx_;\n\t\t\t}\n\t\t\tif (image->tly_ > cmpt->tly_) {\n\t\t\t\timage->tly_ = cmpt->tly_;\n\t\t\t}\n\t\t\tx = cmpt->tlx_ + cmpt->hstep_ * (cmpt->width_ - 1) + 1;\n\t\t\tif (image->brx_ < x) {\n\t\t\t\timage->brx_ = x;\n\t\t\t}\n\t\t\ty = cmpt->tly_ + cmpt->vstep_ * (cmpt->height_ - 1) + 1;\n\t\t\tif (image->bry_ < y) {\n\t\t\t\timage->bry_ = y;\n\t\t\t}\n\t\t}\n\t} else {\n\t\timage->tlx_ = 0;\n\t\timage->tly_ = 0;\n\t\timage->brx_ = 0;\n\t\timage->bry_ = 0;\n\t}\n}\n\nstatic int jas_image_growcmpts(jas_image_t *image, int maxcmpts)\n{\n\tjas_image_cmpt_t **newcmpts;\n\tint cmptno;\n\n\tnewcmpts = (!image->cmpts_) ? jas_alloc2(maxcmpts,\n\t  sizeof(jas_image_cmpt_t *)) :\n\t  jas_realloc2(image->cmpts_, maxcmpts, sizeof(jas_image_cmpt_t *));\n\tif (!newcmpts) {\n\t\treturn -1;\n\t}\n\timage->cmpts_ = newcmpts;\n\timage->maxcmpts_ = maxcmpts;\n\tfor (cmptno = image->numcmpts_; cmptno < image->maxcmpts_; ++cmptno) {\n\t\timage->cmpts_[cmptno] = 0;\n\t}\n\treturn 0;\n}\n\nint jas_image_copycmpt(jas_image_t *dstimage, int dstcmptno,\n  jas_image_t *srcimage, int srccmptno)\n{\n\tjas_image_cmpt_t *newcmpt;\n\tif (dstimage->numcmpts_ >= dstimage->maxcmpts_) {\n\t\tif (jas_image_growcmpts(dstimage, dstimage->maxcmpts_ + 128)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (!(newcmpt = jas_image_cmpt_copy(srcimage->cmpts_[srccmptno]))) {\n\t\treturn -1;\n\t}\n\tif (dstcmptno < dstimage->numcmpts_) {\n\t\tmemmove(&dstimage->cmpts_[dstcmptno + 1], &dstimage->cmpts_[dstcmptno],\n\t\t  (dstimage->numcmpts_ - dstcmptno) * sizeof(jas_image_cmpt_t *));\n\t}\n\tdstimage->cmpts_[dstcmptno] = newcmpt;\n\t++dstimage->numcmpts_;\n\n\tjas_image_setbbox(dstimage);\n\treturn 0;\n}\n\nvoid jas_image_dump(jas_image_t *image, FILE *out)\n{\n\tlong buf[1024];\n\tint cmptno;\n\tint n;\n\tint i;\n\tint width;\n\tint height;\n\tjas_image_cmpt_t *cmpt;\n\tfor (cmptno = 0; cmptno < image->numcmpts_; ++cmptno) {\n\t\tcmpt = image->cmpts_[cmptno];\n\t\tfprintf(out, \"prec=%d, sgnd=%d, cmpttype=%\"PRIiFAST32\"\\n\", cmpt->prec_,\n\t\t  cmpt->sgnd_, cmpt->type_);\n\t\twidth = jas_image_cmptwidth(image, cmptno);\n\t\theight = jas_image_cmptheight(image, cmptno);\n\t\tn = JAS_MIN(16, width);\n\t\tif (jas_image_readcmpt2(image, cmptno, 0, 0, n, 1, buf)) {\n\t\t\tabort();\n\t\t}\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\tfprintf(out, \" f(%d,%d)=%ld\", i, 0, buf[i]);\n\t\t}\n\t\tfprintf(out, \"\\n\");\n\t\tif (jas_image_readcmpt2(image, cmptno, width - n, height - 1, n, 1, buf)) {\n\t\t\tabort();\n\t\t}\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\tfprintf(out, \" f(%d,%d)=%ld\", width - n + i, height - 1, buf[i]);\n\t\t}\n\t\tfprintf(out, \"\\n\");\n\t}\n}\n\nint jas_image_depalettize(jas_image_t *image, int cmptno, int numlutents,\n  int_fast32_t *lutents, int dtype, int newcmptno)\n{\n\tjas_image_cmptparm_t cmptparms;\n\tint_fast32_t v;\n\tint i;\n\tint j;\n\tjas_image_cmpt_t *cmpt;\n\n\tcmpt = image->cmpts_[cmptno];\n\tcmptparms.tlx = cmpt->tlx_;\n\tcmptparms.tly = cmpt->tly_;\n\tcmptparms.hstep = cmpt->hstep_;\n\tcmptparms.vstep = cmpt->vstep_;\n\tcmptparms.width = cmpt->width_;\n\tcmptparms.height = cmpt->height_;\n\tcmptparms.prec = JAS_IMAGE_CDT_GETPREC(dtype);\n\tcmptparms.sgnd = JAS_IMAGE_CDT_GETSGND(dtype);\n\n\tif (jas_image_addcmpt(image, newcmptno, &cmptparms)) {\n\t\treturn -1;\n\t}\n\tif (newcmptno <= cmptno) {\n\t\t++cmptno;\n\t\tcmpt = image->cmpts_[cmptno];\n\t}\n\n\tfor (j = 0; j < cmpt->height_; ++j) {\n\t\tfor (i = 0; i < cmpt->width_; ++i) {\n\t\t\tv = jas_image_readcmptsample(image, cmptno, i, j);\n\t\t\tif (v < 0) {\n\t\t\t\tv = 0;\n\t\t\t} else if (v >= numlutents) {\n\t\t\t\tv = numlutents - 1;\n\t\t\t}\n\t\t\tjas_image_writecmptsample(image, newcmptno, i, j,\n\t\t\t  lutents[v]);\n\t\t}\n\t}\n\treturn 0;\n}\n\nint jas_image_readcmptsample(jas_image_t *image, int cmptno, int x, int y)\n{\n\tjas_image_cmpt_t *cmpt;\n\tuint_fast32_t v;\n\tint k;\n\tint c;\n\n\tcmpt = image->cmpts_[cmptno];\n\n\tif (jas_stream_seek(cmpt->stream_, (cmpt->width_ * y + x) * cmpt->cps_,\n\t  SEEK_SET) < 0) {\n\t\treturn -1;\n\t}\n\tv = 0;\n\tfor (k = cmpt->cps_; k > 0; --k) {\n\t\tif ((c = jas_stream_getc(cmpt->stream_)) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\tv = (v << 8) | (c & 0xff);\n\t}\n\treturn bitstoint(v, cmpt->prec_, cmpt->sgnd_);\n}\n\nvoid jas_image_writecmptsample(jas_image_t *image, int cmptno, int x, int y,\n  int_fast32_t v)\n{\n\tjas_image_cmpt_t *cmpt;\n\tuint_fast32_t t;\n\tint k;\n\tint c;\n\n\tcmpt = image->cmpts_[cmptno];\n\n\tif (jas_stream_seek(cmpt->stream_, (cmpt->width_ * y + x) * cmpt->cps_,\n\t  SEEK_SET) < 0) {\n\t\treturn;\n\t}\n\tt = inttobits(v, cmpt->prec_, cmpt->sgnd_);\n\tfor (k = cmpt->cps_; k > 0; --k) {\n\t\tc = (t >> (8 * (cmpt->cps_ - 1))) & 0xff;\n\t\tif (jas_stream_putc(cmpt->stream_, (unsigned char) c) == EOF) {\n\t\t\treturn;\n\t\t}\n\t\tt <<= 8;\n\t}\n}\n\nint jas_image_getcmptbytype(jas_image_t *image, int ctype)\n{\n\tint cmptno;\n\n\tfor (cmptno = 0; cmptno < image->numcmpts_; ++cmptno) {\n\t\tif (image->cmpts_[cmptno]->type_ == ctype) {\n\t\t\treturn cmptno;\n\t\t}\n\t}\n\treturn -1;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/***********************************************/\n/***********************************************/\n/***********************************************/\n/***********************************************/\n\nint jas_image_readcmpt2(jas_image_t *image, int cmptno, jas_image_coord_t x,\n  jas_image_coord_t y, jas_image_coord_t width, jas_image_coord_t height,\n  long *buf)\n{\n\tjas_image_cmpt_t *cmpt;\n\tjas_image_coord_t i;\n\tjas_image_coord_t j;\n\tlong v;\n\tlong *bufptr;\n\n\tif (cmptno < 0 || cmptno >= image->numcmpts_)\n\t\tgoto error;\n\tcmpt = image->cmpts_[cmptno];\n\tif (x < 0 || x >= cmpt->width_ || y < 0 || y >= cmpt->height_ ||\n\t  width < 0 || height < 0 || x + width > cmpt->width_ ||\n\t  y + height > cmpt->height_)\n\t\tgoto error;\n\n\tbufptr = buf;\n\tfor (i = 0; i < height; ++i) {\n\t\tif (jas_stream_seek(cmpt->stream_, (cmpt->width_ * (y + i) + x)\n\t\t  * cmpt->cps_, SEEK_SET) < 0)\n\t\t\tgoto error;\n\t\tfor (j = 0; j < width; ++j) {\n\t\t\tif (getint(cmpt->stream_, cmpt->sgnd_, cmpt->prec_, &v))\n\t\t\t\tgoto error;\n\t\t\t*bufptr++ = v;\n\t\t}\n\t}\n\n\treturn 0;\nerror:\n\treturn -1;\n}\n\nint jas_image_writecmpt2(jas_image_t *image, int cmptno, jas_image_coord_t x,\n  jas_image_coord_t y, jas_image_coord_t width, jas_image_coord_t height,\n  long *buf)\n{\n\tjas_image_cmpt_t *cmpt;\n\tjas_image_coord_t i;\n\tjas_image_coord_t j;\n\tlong v;\n\tlong *bufptr;\n\n\tif (cmptno < 0 || cmptno >= image->numcmpts_)\n\t\tgoto error;\n\tcmpt = image->cmpts_[cmptno];\n\tif (x < 0 || x >= cmpt->width_ || y < 0 || y >= cmpt->height_ ||\n\t  width < 0 || height < 0 || x + width > cmpt->width_ ||\n\t  y + height > cmpt->height_)\n\t\tgoto error;\n\n\tbufptr = buf;\n\tfor (i = 0; i < height; ++i) {\n\t\tif (jas_stream_seek(cmpt->stream_, (cmpt->width_ * (y + i) + x)\n\t\t  * cmpt->cps_, SEEK_SET) < 0)\n\t\t\tgoto error;\n\t\tfor (j = 0; j < width; ++j) {\n\t\t\tv = *bufptr++;\n\t\t\tif (putint(cmpt->stream_, cmpt->sgnd_, cmpt->prec_, v))\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\n\treturn 0;\nerror:\n\treturn -1;\n}\n\nint jas_image_sampcmpt(jas_image_t *image, int cmptno, int newcmptno,\n  jas_image_coord_t ho, jas_image_coord_t vo, jas_image_coord_t hs,\n  jas_image_coord_t vs, int sgnd, int prec)\n{\n\tjas_image_cmpt_t *oldcmpt;\n\tjas_image_cmpt_t *newcmpt;\n\tint width;\n\tint height;\n\tjas_image_coord_t tlx;\n\tjas_image_coord_t tly;\n\tjas_image_coord_t brx;\n\tjas_image_coord_t bry;\n\tint i;\n\tint j;\n\tjas_image_cmptparm_t cmptparm;\n\tjas_image_coord_t ax;\n\tjas_image_coord_t ay;\n\tjas_image_coord_t bx;\n\tjas_image_coord_t by;\n\tjas_image_coord_t d0;\n\tjas_image_coord_t d1;\n\tjas_image_coord_t d2;\n\tjas_image_coord_t d3;\n\tjas_image_coord_t oldx;\n\tjas_image_coord_t oldy;\n\tjas_image_coord_t x;\n\tjas_image_coord_t y;\n\tlong v;\n\tjas_image_coord_t cmptbrx;\n\tjas_image_coord_t cmptbry;\n\n\tassert(cmptno >= 0 && cmptno < image->numcmpts_);\n\toldcmpt = image->cmpts_[cmptno];\n\tassert(oldcmpt->tlx_ == 0 && oldcmpt->tly_ == 0);\n\tjas_image_calcbbox2(image, &tlx, &tly, &brx, &bry);\n\twidth = FLOORDIV(brx - ho + hs, hs);\n\theight = FLOORDIV(bry - vo + vs, vs);\n\tcmptparm.tlx = ho;\n\tcmptparm.tly = vo;\n\tcmptparm.hstep = hs;\n\tcmptparm.vstep = vs;\n\tcmptparm.width = width;\n\tcmptparm.height = height;\n\tcmptparm.prec = prec;\n\tcmptparm.sgnd = sgnd;\n\tif (jas_image_addcmpt(image, newcmptno, &cmptparm))\n\t\tgoto error;\ncmptbrx = oldcmpt->tlx_ + (oldcmpt->width_ - 1) * oldcmpt->hstep_;\ncmptbry = oldcmpt->tly_ + (oldcmpt->height_ - 1) * oldcmpt->vstep_;\n\tnewcmpt = image->cmpts_[newcmptno];\n\tjas_stream_rewind(newcmpt->stream_);\n\tfor (i = 0; i < height; ++i) {\n\t\ty = newcmpt->tly_ + newcmpt->vstep_ * i;\n\t\tfor (j = 0; j < width; ++j) {\n\t\t\tx = newcmpt->tlx_ + newcmpt->hstep_ * j;\n\t\t\tax = downtomult(x - oldcmpt->tlx_, oldcmpt->hstep_) + oldcmpt->tlx_;\n\t\t\tay = downtomult(y - oldcmpt->tly_, oldcmpt->vstep_) + oldcmpt->tly_;\n\t\t\tbx = uptomult(x - oldcmpt->tlx_, oldcmpt->hstep_) + oldcmpt->tlx_;\n\t\t\tif (bx > cmptbrx)\n\t\t\t\tbx = cmptbrx;\n\t\t\tby = uptomult(y - oldcmpt->tly_, oldcmpt->vstep_) + oldcmpt->tly_;\n\t\t\tif (by > cmptbry)\n\t\t\t\tby = cmptbry;\n\t\t\td0 = (ax - x) * (ax - x) + (ay - y) * (ay - y);\n\t\t\td1 = (bx - x) * (bx - x) + (ay - y) * (ay - y);\n\t\t\td2 = (bx - x) * (bx - x) + (by - y) * (by - y);\n\t\t\td3 = (ax - x) * (ax - x) + (by - y) * (by - y);\n\t\t\tif (d0 <= d1 && d0 <= d2 && d0 <= d3) {\n\t\t\t\toldx = (ax - oldcmpt->tlx_) / oldcmpt->hstep_;\n\t\t\t\toldy = (ay - oldcmpt->tly_) / oldcmpt->vstep_;\n\t\t\t} else if (d1 <= d0 && d1 <= d2 && d1 <= d3) {\n\t\t\t\toldx = (bx - oldcmpt->tlx_) / oldcmpt->hstep_;\n\t\t\t\toldy = (ay - oldcmpt->tly_) / oldcmpt->vstep_;\n\t\t\t} else if (d2 <= d0 && d2 <= d1 && d1 <= d3) {\n\t\t\t\toldx = (bx - oldcmpt->tlx_) / oldcmpt->hstep_;\n\t\t\t\toldy = (by - oldcmpt->tly_) / oldcmpt->vstep_;\n\t\t\t} else {\n\t\t\t\toldx = (ax - oldcmpt->tlx_) / oldcmpt->hstep_;\n\t\t\t\toldy = (by - oldcmpt->tly_) / oldcmpt->vstep_;\n\t\t\t}\n\t\t\tassert(oldx >= 0 && oldx < oldcmpt->width_ &&\n\t\t\t  oldy >= 0 && oldy < oldcmpt->height_);\n\t\t\tif (jas_stream_seek(oldcmpt->stream_, oldcmpt->cps_ *\n\t\t\t  (oldy * oldcmpt->width_ + oldx), SEEK_SET) < 0)\n\t\t\t\tgoto error;\n\t\t\tif (getint(oldcmpt->stream_, oldcmpt->sgnd_,\n\t\t\t  oldcmpt->prec_, &v))\n\t\t\t\tgoto error;\n\t\t\tif (newcmpt->prec_ != oldcmpt->prec_ ||\n\t\t\t  newcmpt->sgnd_ != oldcmpt->sgnd_) {\n\t\t\t\tv = convert(v, oldcmpt->sgnd_, oldcmpt->prec_,\n\t\t\t\t  newcmpt->sgnd_, newcmpt->prec_);\n\t\t\t}\n\t\t\tif (putint(newcmpt->stream_, newcmpt->sgnd_,\n\t\t\t  newcmpt->prec_, v))\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\treturn 0;\nerror:\n\treturn -1;\n}\n\nint jas_image_ishomosamp(jas_image_t *image)\n{\n\tjas_image_coord_t hstep;\n\tjas_image_coord_t vstep;\n\tint result;\n\tint i;\n\thstep = jas_image_cmpthstep(image, 0);\n\tvstep = jas_image_cmptvstep(image, 0);\n\tresult = 1;\n\tfor (i = 0; i < image->numcmpts_; ++i) {\n\t\tif (jas_image_cmpthstep(image, i) != hstep ||\n\t\t  jas_image_cmptvstep(image, i) != vstep) {\n\t\t\tresult = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}\n\n/* Note: This function defines a bounding box differently. */\nstatic void jas_image_calcbbox2(jas_image_t *image, jas_image_coord_t *tlx,\n  jas_image_coord_t *tly, jas_image_coord_t *brx, jas_image_coord_t *bry)\n{\n\tjas_image_cmpt_t *cmpt;\n\tjas_image_coord_t tmptlx;\n\tjas_image_coord_t tmptly;\n\tjas_image_coord_t tmpbrx;\n\tjas_image_coord_t tmpbry;\n\tjas_image_coord_t t;\n\tint i;\n\tif (image->numcmpts_ > 0) {\n\t\tcmpt = image->cmpts_[0];\n\t\ttmptlx = cmpt->tlx_;\n\t\ttmptly = cmpt->tly_;\n\t\ttmpbrx = cmpt->tlx_ + cmpt->hstep_ * (cmpt->width_ - 1);\n\t\ttmpbry = cmpt->tly_ + cmpt->vstep_ * (cmpt->height_ - 1);\n\t\tfor (i = 0; i < image->numcmpts_; ++i) {\n\t\t\tcmpt = image->cmpts_[i];\n\t\t\tif (cmpt->tlx_ < tmptlx)\n\t\t\t\ttmptlx = cmpt->tlx_;\n\t\t\tif (cmpt->tly_ < tmptly)\n\t\t\t\ttmptly = cmpt->tly_;\n\t\t\tt = cmpt->tlx_ + cmpt->hstep_ * (cmpt->width_ - 1);\n\t\t\tif (t > tmpbrx)\n\t\t\t\ttmpbrx = t;\n\t\t\tt = cmpt->tly_ + cmpt->vstep_ * (cmpt->height_ - 1);\n\t\t\tif (t > tmpbry)\n\t\t\t\ttmpbry = t;\n\t\t}\n\t} else {\n\t\ttmptlx = 0;\n\t\ttmptly = 0;\n\t\ttmpbrx = -1;\n\t\ttmpbry = -1;\n\t}\n\t*tlx = tmptlx;\n\t*tly = tmptly;\n\t*brx = tmpbrx;\n\t*bry = tmpbry;\n}\n\nstatic inline long decode_twos_comp(ulong c, int prec)\n{\n\tlong result;\n\tassert(prec >= 2);\n\tjas_eprintf(\"warning: support for signed data is untested\\n\");\n\t// NOTE: Is this correct?\n\tresult = (c & ((1 << (prec - 1)) - 1)) - (c & (1 << (prec - 1)));\n\treturn result;\n}\n\nstatic inline ulong encode_twos_comp(long n, int prec)\n{\n\tulong result;\n\tassert(prec >= 2);\n\tjas_eprintf(\"warning: support for signed data is untested\\n\");\n\t// NOTE: Is this correct?\n\tif (n < 0) {\n\t\tresult = -n;\n\t\tresult = (result ^ 0xffffffffUL) + 1;\n\t\tresult &= (1 << prec) - 1;\n\t} else {\n\t\tresult = n;\n\t}\n\treturn result;\n}\n\nstatic int getint(jas_stream_t *in, int sgnd, int prec, long *val)\n{\n\tlong v;\n\tint n;\n\tint c;\n\tassert((!sgnd && prec >= 1) || (sgnd && prec >= 2));\n\tn = (prec + 7) / 8;\n\tv = 0;\n\twhile (--n >= 0) {\n\t\tif ((c = jas_stream_getc(in)) == EOF)\n\t\t\treturn -1;\n\t\tv = (v << 8) | c;\n\t}\n\tv &= ((1 << prec) - 1);\n\tif (sgnd) {\n\t\t*val = decode_twos_comp(v, prec);\n\t} else {\n\t\t*val = v;\n\t}\n\treturn 0;\n}\n\nstatic int putint(jas_stream_t *out, int sgnd, int prec, long val)\n{\n\tint n;\n\tint c;\n\tbool s;\n\tulong tmp;\n\tassert((!sgnd && prec >= 1) || (sgnd && prec >= 2));\n\tif (sgnd) {\n\t\tval = encode_twos_comp(val, prec);\n\t}\n\tassert(val >= 0);\n\tval &= (1 << prec) - 1;\n\tn = (prec + 7) / 8;\n\twhile (--n >= 0) {\n\t\tc = (val >> (n * 8)) & 0xff;\n\t\tif (jas_stream_putc(out, c) != c)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic long convert(long val, int oldsgnd, int oldprec, int newsgnd,\n  int newprec)\n{\n\tif (newsgnd != oldsgnd) {\n\t}\n\tif (newprec != oldprec) {\n\t\tif (newprec > oldprec) {\n\t\t\tval <<= newprec - oldprec;\n\t\t} else if (oldprec > newprec) {\n\t\t\tval >>= oldprec - newprec;\n\t\t}\n\t}\n\treturn val;\n}\n\nstatic long downtomult(long x, long y)\n{\n\tassert(x >= 0);\n\treturn (x / y) * y;\n}\n\nstatic long uptomult(long x, long y)\n{\n\tassert(x >= 0);\n\treturn ((x + y - 1) / y) * y;\n}\n\njas_image_t *jas_image_chclrspc(jas_image_t *image, jas_cmprof_t *outprof,\n  int intent)\n{\n\tjas_image_t *inimage;\n\tint minhstep;\n\tint minvstep;\n\tint i;\n\tint j;\n\tint k;\n\tint n;\n\tint hstep;\n\tint vstep;\n\tint numinauxchans;\n\tint numoutauxchans;\n\tint numinclrchans;\n\tint numoutclrchans;\n\tint prec;\n\tjas_image_t *outimage;\n\tint cmpttype;\n\tint numoutchans;\n\tjas_cmprof_t *inprof;\n\tjas_cmprof_t *tmpprof;\n\tjas_image_cmptparm_t cmptparm;\n\tint width;\n\tint height;\n\tjas_cmxform_t *xform;\n\tjas_cmpixmap_t inpixmap;\n\tjas_cmpixmap_t outpixmap;\n\tjas_cmcmptfmt_t *incmptfmts;\n\tjas_cmcmptfmt_t *outcmptfmts;\n\n#if 0\njas_eprintf(\"IMAGE\\n\");\njas_image_dump(image, stderr);\n#endif\n\n\toutimage = 0;\n\txform = 0;\n\tif (!(inimage = jas_image_copy(image)))\n\t\tgoto error;\n\timage = 0;\n\n\tif (!jas_image_ishomosamp(inimage)) {\n\t\tminhstep = jas_image_cmpthstep(inimage, 0);\n\t\tminvstep = jas_image_cmptvstep(inimage, 0);\n\t\tfor (i = 1; i < jas_image_numcmpts(inimage); ++i) {\n\t\t\thstep = jas_image_cmpthstep(inimage, i);\n\t\t\tvstep = jas_image_cmptvstep(inimage, i);\n\t\t\tif (hstep < minhstep) {\n\t\t\t\tminhstep = hstep;\n\t\t\t}\n\t\t\tif (vstep < minvstep) {\n\t\t\t\tminvstep = vstep;\n\t\t\t}\n\t\t}\n\t\tn = jas_image_numcmpts(inimage);\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\tcmpttype = jas_image_cmpttype(inimage, i);\n\t\t\tif (jas_image_sampcmpt(inimage, i, i + 1, 0, 0, minhstep, minvstep,\n\t\t\t  jas_image_cmptsgnd(inimage, i), jas_image_cmptprec(inimage, i))) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tjas_image_setcmpttype(inimage, i + 1, cmpttype);\n\t\t\tjas_image_delcmpt(inimage, i);\n\t\t}\n\t}\n\n\twidth = jas_image_cmptwidth(inimage, 0);\n\theight = jas_image_cmptheight(inimage, 0);\n\thstep = jas_image_cmpthstep(inimage, 0);\n\tvstep = jas_image_cmptvstep(inimage, 0);\n\n\tif (!(inprof = jas_image_cmprof(inimage))) {\n\t\tabort();\n\t}\n\tnuminclrchans = jas_clrspc_numchans(jas_cmprof_clrspc(inprof));\n\tnuminauxchans = jas_image_numcmpts(inimage) - numinclrchans;\n\tnumoutclrchans = jas_clrspc_numchans(jas_cmprof_clrspc(outprof));\n\tnumoutauxchans = 0;\n\tnumoutchans = numoutclrchans + numoutauxchans;\n\tprec = 8;\n\n\tif (!(outimage = jas_image_create0())) {\n\t\tgoto error;\n\t}\n\n\t/* Create a component for each of the colorants. */\n\tfor (i = 0; i < numoutclrchans; ++i) {\n\t\tcmptparm.tlx = 0;\n\t\tcmptparm.tly = 0;\n\t\tcmptparm.hstep = hstep;\n\t\tcmptparm.vstep = vstep;\n\t\tcmptparm.width = width;\n\t\tcmptparm.height = height;\n\t\tcmptparm.prec = prec;\n\t\tcmptparm.sgnd = 0;\n\t\tif (jas_image_addcmpt(outimage, -1, &cmptparm))\n\t\t\tgoto error;\n\t\tjas_image_setcmpttype(outimage, i, JAS_IMAGE_CT_COLOR(i));\n\t}\n#if 0\n\t/* Copy the auxiliary components without modification. */\n\tfor (i = 0; i < jas_image_numcmpts(inimage); ++i) {\n\t\tif (!ISCOLOR(jas_image_cmpttype(inimage, i))) {\n\t\t\tjas_image_copycmpt(outimage, -1, inimage, i);\n/* XXX - need to specify laydown of component on ref. grid */\n\t\t}\n\t}\n#endif\n\n\tif (!(tmpprof = jas_cmprof_copy(outprof)))\n\t\tgoto error;\n\tassert(!jas_image_cmprof(outimage));\n\tjas_image_setcmprof(outimage, tmpprof);\n\ttmpprof = 0;\n\tjas_image_setclrspc(outimage, jas_cmprof_clrspc(outprof));\n\n\tif (!(xform = jas_cmxform_create(inprof, outprof, 0, JAS_CMXFORM_OP_FWD,\n\t  intent, 0))) {\n\t\tgoto error;\n\t}\n\n\tinpixmap.numcmpts = numinclrchans;\n\tif (!(incmptfmts = jas_alloc2(numinclrchans, sizeof(jas_cmcmptfmt_t)))) {\n\t\tabort();\n\t}\n\tinpixmap.cmptfmts = incmptfmts;\n\tfor (i = 0; i < numinclrchans; ++i) {\n\t\tj = jas_image_getcmptbytype(inimage, JAS_IMAGE_CT_COLOR(i));\n\t\tassert(j >= 0);\n\t\tif (!(incmptfmts[i].buf = jas_alloc2(width, sizeof(long)))) {\n\t\t\tgoto error;\n\t\t}\n\t\tincmptfmts[i].prec = jas_image_cmptprec(inimage, j);\n\t\tincmptfmts[i].sgnd = jas_image_cmptsgnd(inimage, j);\n\t\tincmptfmts[i].width = width;\n\t\tincmptfmts[i].height = 1;\n\t}\n\n\toutpixmap.numcmpts = numoutclrchans;\n\tif (!(outcmptfmts = jas_alloc2(numoutclrchans, sizeof(jas_cmcmptfmt_t)))) {\n\t\tabort();\n\t}\n\toutpixmap.cmptfmts = outcmptfmts;\n\n\tfor (i = 0; i < numoutclrchans; ++i) {\n\t\tj = jas_image_getcmptbytype(outimage, JAS_IMAGE_CT_COLOR(i));\n\t\tassert(j >= 0);\n\t\tif (!(outcmptfmts[i].buf = jas_alloc2(width, sizeof(long))))\n\t\t\tgoto error;\n\t\toutcmptfmts[i].prec = jas_image_cmptprec(outimage, j);\n\t\toutcmptfmts[i].sgnd = jas_image_cmptsgnd(outimage, j);\n\t\toutcmptfmts[i].width = width;\n\t\toutcmptfmts[i].height = 1;\n\t}\n\n\tfor (i = 0; i < height; ++i) {\n\t\tfor (j = 0; j < numinclrchans; ++j) {\n\t\t\tk = jas_image_getcmptbytype(inimage, JAS_IMAGE_CT_COLOR(j));\n\t\t\tif (jas_image_readcmpt2(inimage, k, 0, i, width, 1,\n\t\t\t  incmptfmts[j].buf))\n\t\t\t\tgoto error;\n\t\t}\n\t\tjas_cmxform_apply(xform, &inpixmap, &outpixmap);\n\t\tfor (j = 0; j < numoutclrchans; ++j) {\n\t\t\tk = jas_image_getcmptbytype(outimage, JAS_IMAGE_CT_COLOR(j));\n\t\t\tif (jas_image_writecmpt2(outimage, k, 0, i, width, 1,\n\t\t\t  outcmptfmts[j].buf))\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\n\tfor (i = 0; i < numoutclrchans; ++i) {\n\t\tjas_free(outcmptfmts[i].buf);\n\t}\n\tjas_free(outcmptfmts);\n\tfor (i = 0; i < numinclrchans; ++i) {\n\t\tjas_free(incmptfmts[i].buf);\n\t}\n\tjas_free(incmptfmts);\n\tjas_cmxform_destroy(xform);\n\tjas_image_destroy(inimage);\n\n#if 0\njas_eprintf(\"INIMAGE\\n\");\njas_image_dump(inimage, stderr);\njas_eprintf(\"OUTIMAGE\\n\");\njas_image_dump(outimage, stderr);\n#endif\n\treturn outimage;\nerror:\n\tif (xform)\n\t\tjas_cmxform_destroy(xform);\n\tif (inimage)\n\t\tjas_image_destroy(inimage);\n\tif (outimage)\n\t\tjas_image_destroy(outimage);\n\treturn 0;\n}\n", "/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2003 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * Image Class\n *\n * $Id$\n */\n\n#ifndef JAS_IMAGE_H\n#define JAS_IMAGE_H\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <jasper/jas_config.h>\n#include <jasper/jas_stream.h>\n#include <jasper/jas_seq.h>\n#include <jasper/jas_cm.h>\n#include <stdio.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/******************************************************************************\\\n* Constants.\n\\******************************************************************************/\n\n/*\n * Miscellaneous constants.\n */\n\n/* The threshold at which image data is no longer stored in memory. */\n#define JAS_IMAGE_INMEMTHRESH\t(16 * 1024 * 1024)\n\n/*\n * Component types\n */\n\n#define\tJAS_IMAGE_CT_UNKNOWN\t0x10000\n#define\tJAS_IMAGE_CT_COLOR(n)\t((n) & 0x7fff)\n#define\tJAS_IMAGE_CT_OPACITY\t0x08000\n\n#define\tJAS_IMAGE_CT_RGB_R\t0\n#define\tJAS_IMAGE_CT_RGB_G\t1\n#define\tJAS_IMAGE_CT_RGB_B\t2\n\n#define\tJAS_IMAGE_CT_YCBCR_Y\t0\n#define\tJAS_IMAGE_CT_YCBCR_CB\t1\n#define\tJAS_IMAGE_CT_YCBCR_CR\t2\n\n#define\tJAS_IMAGE_CT_GRAY_Y\t0\n\n/******************************************************************************\\\n* Simple types.\n\\******************************************************************************/\n\n/* Image coordinate. */\ntypedef int_fast32_t jas_image_coord_t;\n\n/* Color space (e.g., RGB, YCbCr). */\ntypedef int_fast16_t jas_image_colorspc_t;\n\n/* Component type (e.g., color, opacity). */\ntypedef int_fast32_t jas_image_cmpttype_t;\n\n/* Component sample data format (e.g., real/integer, signedness, precision). */\ntypedef int_fast16_t jas_image_smpltype_t;\n\n/******************************************************************************\\\n* Image class and supporting classes.\n\\******************************************************************************/\n\n/* Image component class. */\n\ntypedef struct {\n\n\tjas_image_coord_t tlx_;\n\t/* The x-coordinate of the top-left corner of the component. */\n\n\tjas_image_coord_t tly_;\n\t/* The y-coordinate of the top-left corner of the component. */\n\n\tjas_image_coord_t hstep_;\n\t/* The horizontal sampling period in units of the reference grid. */\n\n\tjas_image_coord_t vstep_;\n\t/* The vertical sampling period in units of the reference grid. */\n\n\tjas_image_coord_t width_;\n\t/* The component width in samples. */\n\n\tjas_image_coord_t height_;\n\t/* The component height in samples. */\n\n#ifdef FIX_ME\n\tint smpltype_;\n#else\n\tint prec_;\n\t/* The precision of the sample data (i.e., the number of bits per\n\tsample).  If the samples are signed values, this quantity\n\tincludes the sign bit. */\n\n\tint sgnd_;\n\t/* The signedness of the sample data. */\n#endif\n\n\tjas_stream_t *stream_;\n\t/* The stream containing the component data. */\n\n\tint cps_;\n\t/* The number of characters per sample in the stream. */\n\n\tjas_image_cmpttype_t type_;\n\t/* The type of component (e.g., opacity, red, green, blue, luma). */\n\n} jas_image_cmpt_t;\n\n/* Image class. */\n\ntypedef struct {\n\n\tjas_image_coord_t tlx_;\n\t/* The x-coordinate of the top-left corner of the image bounding box. */\n\n\tjas_image_coord_t tly_;\n\t/* The y-coordinate of the top-left corner of the image bounding box. */\n\n\tjas_image_coord_t brx_;\n\t/* The x-coordinate of the bottom-right corner of the image bounding\n\t  box (plus one). */\n\n\tjas_image_coord_t bry_;\n\t/* The y-coordinate of the bottom-right corner of the image bounding\n\t  box (plus one). */\n\n\tint numcmpts_;\n\t/* The number of components. */\n\n\tint maxcmpts_;\n\t/* The maximum number of components that this image can have (i.e., the\n\t  allocated size of the components array). */\n\n\tjas_image_cmpt_t **cmpts_;\n\t/* Per-component information. */\n\n\tjas_clrspc_t clrspc_;\n\n\tjas_cmprof_t *cmprof_;\n\n\tbool inmem_;\n\n} jas_image_t;\n\n/* Component parameters class. */\n/* This data type exists solely/mainly for the purposes of the\n  jas_image_create function. */\n\ntypedef struct {\n\n\tjas_image_coord_t tlx;\n\t/* The x-coordinate of the top-left corner of the component. */\n\n\tjas_image_coord_t tly;\n\t/* The y-coordinate of the top-left corner of the component. */\n\n\tjas_image_coord_t hstep;\n\t/* The horizontal sampling period in units of the reference grid. */\n\n\tjas_image_coord_t vstep;\n\t/* The vertical sampling period in units of the reference grid. */\n\n\tjas_image_coord_t width;\n\t/* The width of the component in samples. */\n\n\tjas_image_coord_t height;\n\t/* The height of the component in samples. */\n\n#ifdef FIX_ME\n\tint smpltype;\n#else\n\tint prec;\n\t/* The precision of the component sample data. */\n\n\tint sgnd;\n\t/* The signedness of the component sample data. */\n#endif\n\n} jas_image_cmptparm_t;\n\n/******************************************************************************\\\n* File format related classes.\n\\******************************************************************************/\n\n#define\tJAS_IMAGE_MAXFMTS\t32\n/* The maximum number of image data formats supported. */\n\n/* Image format-dependent operations. */\n\ntypedef struct {\n\n\tjas_image_t *(*decode)(jas_stream_t *in, char *opts);\n\t/* Decode image data from a stream. */\n\n\tint (*encode)(jas_image_t *image, jas_stream_t *out, char *opts);\n\t/* Encode image data to a stream. */\n\n\tint (*validate)(jas_stream_t *in);\n\t/* Determine if stream data is in a particular format. */\n\n} jas_image_fmtops_t;\n\n/* Image format information. */\n\ntypedef struct {\n\n\tint id;\n\t/* The ID for this format. */\n\n\tchar *name;\n\t/* The name by which this format is identified. */\n\n\tchar *ext;\n\t/* The file name extension associated with this format. */\n\n\tchar *desc;\n\t/* A brief description of the format. */\n\n\tjas_image_fmtops_t ops;\n\t/* The operations for this format. */\n\n} jas_image_fmtinfo_t;\n\n/******************************************************************************\\\n* Image operations.\n\\******************************************************************************/\n\n/* Create an image. */\njas_image_t *jas_image_create(int numcmpts,\n  jas_image_cmptparm_t *cmptparms, jas_clrspc_t clrspc);\n\n/* Create an \"empty\" image. */\njas_image_t *jas_image_create0(void);\n\n/* Clone an image. */\njas_image_t *jas_image_copy(jas_image_t *image);\n\n/* Deallocate any resources associated with an image. */\nvoid jas_image_destroy(jas_image_t *image);\n\n/* Get the width of the image in units of the image reference grid. */\n#define jas_image_width(image) \\\n\t((image)->brx_ - (image)->tlx_)\n\n/* Get the height of the image in units of the image reference grid. */\n#define\tjas_image_height(image) \\\n\t((image)->bry_ - (image)->tly_)\n\n/* Get the x-coordinate of the top-left corner of the image bounding box\n  on the reference grid. */\n#define jas_image_tlx(image) \\\n\t((image)->tlx_)\n\n/* Get the y-coordinate of the top-left corner of the image bounding box\n  on the reference grid. */\n#define jas_image_tly(image) \\\n\t((image)->tly_)\n\n/* Get the x-coordinate of the bottom-right corner of the image bounding box\n  on the reference grid (plus one). */\n#define jas_image_brx(image) \\\n\t((image)->brx_)\n\n/* Get the y-coordinate of the bottom-right corner of the image bounding box\n  on the reference grid (plus one). */\n#define jas_image_bry(image) \\\n\t((image)->bry_)\n\n/* Get the number of image components. */\n#define\tjas_image_numcmpts(image) \\\n\t((image)->numcmpts_)\n\n/* Get the color model used by the image. */\n#define\tjas_image_clrspc(image) \\\n\t((image)->clrspc_)\n\n/* Set the color model for an image. */\n#define jas_image_setclrspc(image, clrspc) \\\n\t((image)->clrspc_ = (clrspc))\n\n#define jas_image_cmpttype(image, cmptno) \\\n\t((image)->cmpts_[(cmptno)]->type_)\n#define jas_image_setcmpttype(image, cmptno, type) \\\n\t((image)->cmpts_[(cmptno)]->type_ = (type))\n\n/* Get the width of a component. */\n#define\tjas_image_cmptwidth(image, cmptno) \\\n\t((image)->cmpts_[cmptno]->width_)\n\n/* Get the height of a component. */\n#define\tjas_image_cmptheight(image, cmptno) \\\n\t((image)->cmpts_[cmptno]->height_)\n\n/* Get the signedness of the sample data for a component. */\n#define\tjas_image_cmptsgnd(image, cmptno) \\\n\t((image)->cmpts_[cmptno]->sgnd_)\n\n/* Get the precision of the sample data for a component. */\n#define\tjas_image_cmptprec(image, cmptno) \\\n\t((image)->cmpts_[cmptno]->prec_)\n\n/* Get the horizontal subsampling factor for a component. */\n#define\tjas_image_cmpthstep(image, cmptno) \\\n\t((image)->cmpts_[cmptno]->hstep_)\n\n/* Get the vertical subsampling factor for a component. */\n#define\tjas_image_cmptvstep(image, cmptno) \\\n\t((image)->cmpts_[cmptno]->vstep_)\n\n/* Get the x-coordinate of the top-left corner of a component. */\n#define\tjas_image_cmpttlx(image, cmptno) \\\n\t((image)->cmpts_[cmptno]->tlx_)\n\n/* Get the y-coordinate of the top-left corner of a component. */\n#define\tjas_image_cmpttly(image, cmptno) \\\n\t((image)->cmpts_[cmptno]->tly_)\n\n/* Get the x-coordinate of the bottom-right corner of a component\n  (plus \"one\"). */\n#define\tjas_image_cmptbrx(image, cmptno) \\\n\t((image)->cmpts_[cmptno]->tlx_ + (image)->cmpts_[cmptno]->width_ * \\\n\t  (image)->cmpts_[cmptno]->hstep_)\n\n/* Get the y-coordinate of the bottom-right corner of a component\n  (plus \"one\"). */\n#define\tjas_image_cmptbry(image, cmptno) \\\n\t((image)->cmpts_[cmptno]->tly_ + (image)->cmpts_[cmptno]->height_ * \\\n\t  (image)->cmpts_[cmptno]->vstep_)\n\n/* Get the raw size of an image (i.e., the nominal size of the image without\n  any compression. */\nuint_fast32_t jas_image_rawsize(jas_image_t *image);\n\n/* Create an image from a stream in some specified format. */\njas_image_t *jas_image_decode(jas_stream_t *in, int fmt, char *optstr);\n\n/* Write an image to a stream in a specified format. */\nint jas_image_encode(jas_image_t *image, jas_stream_t *out, int fmt,\n  char *optstr);\n\n/* Read a rectangular region of an image component. */\n/* The position and size of the rectangular region to be read is specified\nrelative to the component's coordinate system. */\nint jas_image_readcmpt(jas_image_t *image, int cmptno,\n  jas_image_coord_t x, jas_image_coord_t y, jas_image_coord_t width, jas_image_coord_t height,\n  jas_matrix_t *data);\n\n/* Write a rectangular region of an image component. */\nint jas_image_writecmpt(jas_image_t *image, int cmptno,\n  jas_image_coord_t x, jas_image_coord_t y, jas_image_coord_t width, jas_image_coord_t height,\n  jas_matrix_t *data);\n\n/* Delete a component from an image. */\nvoid jas_image_delcmpt(jas_image_t *image, int cmptno);\n\n/* Add a component to an image. */\nint jas_image_addcmpt(jas_image_t *image, int cmptno,\n  jas_image_cmptparm_t *cmptparm);\n\n/* Copy a component from one image to another. */\nint jas_image_copycmpt(jas_image_t *dstimage, int dstcmptno,\n  jas_image_t *srcimage, int srccmptno);\n\n#define\tJAS_IMAGE_CDT_GETSGND(dtype) (((dtype) >> 7) & 1)\n#define\tJAS_IMAGE_CDT_SETSGND(dtype) (((dtype) & 1) << 7)\n#define\tJAS_IMAGE_CDT_GETPREC(dtype) ((dtype) & 0x7f)\n#define\tJAS_IMAGE_CDT_SETPREC(dtype) ((dtype) & 0x7f)\n\n#define\tjas_image_cmptdtype(image, cmptno) \\\n\t(JAS_IMAGE_CDT_SETSGND((image)->cmpts_[cmptno]->sgnd_) | JAS_IMAGE_CDT_SETPREC((image)->cmpts_[cmptno]->prec_))\n\nint jas_image_depalettize(jas_image_t *image, int cmptno, int numlutents,\n  int_fast32_t *lutents, int dtype, int newcmptno);\n\nint jas_image_readcmptsample(jas_image_t *image, int cmptno, int x, int y);\nvoid jas_image_writecmptsample(jas_image_t *image, int cmptno, int x, int y,\n  int_fast32_t v);\n\nint jas_image_getcmptbytype(jas_image_t *image, int ctype);\n\n/******************************************************************************\\\n* Image format-related operations.\n\\******************************************************************************/\n\n/* Clear the table of image formats. */\nvoid jas_image_clearfmts(void);\n\n/* Add entry to table of image formats. */\nint jas_image_addfmt(int id, char *name, char *ext, char *desc,\n  jas_image_fmtops_t *ops);\n\n/* Get the ID for the image format with the specified name. */\nint jas_image_strtofmt(char *s);\n\n/* Get the name of the image format with the specified ID. */\nchar *jas_image_fmttostr(int fmt);\n\n/* Lookup image format information by the format ID. */\njas_image_fmtinfo_t *jas_image_lookupfmtbyid(int id);\n\n/* Lookup image format information by the format name. */\njas_image_fmtinfo_t *jas_image_lookupfmtbyname(const char *name);\n\n/* Guess the format of an image file based on its name. */\nint jas_image_fmtfromname(char *filename);\n\n/* Get the format of image data in a stream. */\nint jas_image_getfmt(jas_stream_t *in);\n\n\n#define\tjas_image_cmprof(image)\t((image)->cmprof_)\nint jas_image_ishomosamp(jas_image_t *image);\nint jas_image_sampcmpt(jas_image_t *image, int cmptno, int newcmptno,\n  jas_image_coord_t ho, jas_image_coord_t vo, jas_image_coord_t hs,\n  jas_image_coord_t vs, int sgnd, int prec);\nint jas_image_writecmpt2(jas_image_t *image, int cmptno, jas_image_coord_t x,\n  jas_image_coord_t y, jas_image_coord_t width, jas_image_coord_t height,\n  long *buf);\nint jas_image_readcmpt2(jas_image_t *image, int cmptno, jas_image_coord_t x,\n  jas_image_coord_t y, jas_image_coord_t width, jas_image_coord_t height,\n  long *buf);\n\n#define\tjas_image_setcmprof(image, cmprof) ((image)->cmprof_ = cmprof)\njas_image_t *jas_image_chclrspc(jas_image_t *image, jas_cmprof_t *outprof,\n  int intent);\nvoid jas_image_dump(jas_image_t *image, FILE *out);\n\n/******************************************************************************\\\n* Image format-dependent operations.\n\\******************************************************************************/\n\n#if !defined(EXCLUDE_JPG_SUPPORT)\n/* Format-dependent operations for JPG support. */\njas_image_t *jpg_decode(jas_stream_t *in, char *optstr);\nint jpg_encode(jas_image_t *image, jas_stream_t *out, char *optstr);\nint jpg_validate(jas_stream_t *in);\n#endif\n\n#if !defined(EXCLUDE_MIF_SUPPORT)\n/* Format-dependent operations for MIF support. */\njas_image_t *mif_decode(jas_stream_t *in, char *optstr);\nint mif_encode(jas_image_t *image, jas_stream_t *out, char *optstr);\nint mif_validate(jas_stream_t *in);\n#endif\n\n#if !defined(EXCLUDE_PNM_SUPPORT)\n/* Format-dependent operations for PNM support. */\njas_image_t *pnm_decode(jas_stream_t *in, char *optstr);\nint pnm_encode(jas_image_t *image, jas_stream_t *out, char *optstr);\nint pnm_validate(jas_stream_t *in);\n#endif\n\n#if !defined(EXCLUDE_RAS_SUPPORT)\n/* Format-dependent operations for Sun Rasterfile support. */\njas_image_t *ras_decode(jas_stream_t *in, char *optstr);\nint ras_encode(jas_image_t *image, jas_stream_t *out, char *optstr);\nint ras_validate(jas_stream_t *in);\n#endif\n\n#if !defined(EXCLUDE_BMP_SUPPORT)\n/* Format-dependent operations for BMP support. */\njas_image_t *bmp_decode(jas_stream_t *in, char *optstr);\nint bmp_encode(jas_image_t *image, jas_stream_t *out, char *optstr);\nint bmp_validate(jas_stream_t *in);\n#endif\n\n#if !defined(EXCLUDE_JP2_SUPPORT)\n/* Format-dependent operations for JP2 support. */\njas_image_t *jp2_decode(jas_stream_t *in, char *optstr);\nint jp2_encode(jas_image_t *image, jas_stream_t *out, char *optstr);\nint jp2_validate(jas_stream_t *in);\n#endif\n\n#if !defined(EXCLUDE_JPC_SUPPORT)\n/* Format-dependent operations for JPEG-2000 code stream support. */\njas_image_t *jpc_decode(jas_stream_t *in, char *optstr);\nint jpc_encode(jas_image_t *image, jas_stream_t *out, char *optstr);\nint jpc_validate(jas_stream_t *in);\n#endif\n\n#if !defined(EXCLUDE_PGX_SUPPORT)\n/* Format-dependent operations for PGX support. */\njas_image_t *pgx_decode(jas_stream_t *in, char *optstr);\nint pgx_encode(jas_image_t *image, jas_stream_t *out, char *optstr);\nint pgx_validate(jas_stream_t *in);\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n", "/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2003 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * $Id$\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <inttypes.h>\n\n#include \"jasper/jas_types.h\"\n#include \"jasper/jas_math.h\"\n#include \"jasper/jas_tvp.h\"\n#include \"jasper/jas_malloc.h\"\n#include \"jasper/jas_debug.h\"\n\n#include \"jpc_fix.h\"\n#include \"jpc_dec.h\"\n#include \"jpc_cs.h\"\n#include \"jpc_mct.h\"\n#include \"jpc_t2dec.h\"\n#include \"jpc_t1dec.h\"\n#include \"jpc_math.h\"\n\n/******************************************************************************\\\n*\n\\******************************************************************************/\n\n#define\tJPC_MHSOC\t0x0001\n  /* In the main header, expecting a SOC marker segment. */\n#define\tJPC_MHSIZ\t0x0002\n  /* In the main header, expecting a SIZ marker segment. */\n#define\tJPC_MH\t\t0x0004\n  /* In the main header, expecting \"other\" marker segments. */\n#define\tJPC_TPHSOT\t0x0008\n  /* In a tile-part header, expecting a SOT marker segment. */\n#define\tJPC_TPH\t\t0x0010\n  /* In a tile-part header, expecting \"other\" marker segments. */\n#define\tJPC_MT\t\t0x0020\n  /* In the main trailer. */\n\ntypedef struct {\n\n\tuint_fast16_t id;\n\t/* The marker segment type. */\n\n\tint validstates;\n\t/* The states in which this type of marker segment can be\n\t  validly encountered. */\n\n\tint (*action)(jpc_dec_t *dec, jpc_ms_t *ms);\n\t/* The action to take upon encountering this type of marker segment. */\n\n} jpc_dec_mstabent_t;\n\n/******************************************************************************\\\n*\n\\******************************************************************************/\n\n/* COD/COC parameters have been specified. */\n#define\tJPC_CSET\t0x0001\n/* QCD/QCC parameters have been specified. */\n#define\tJPC_QSET\t0x0002\n/* COD/COC parameters set from a COC marker segment. */\n#define\tJPC_COC\t0x0004\n/* QCD/QCC parameters set from a QCC marker segment. */\n#define\tJPC_QCC\t0x0008\n\n/******************************************************************************\\\n* Local function prototypes.\n\\******************************************************************************/\n\nstatic int jpc_dec_dump(jpc_dec_t *dec, FILE *out);\n\njpc_ppxstab_t *jpc_ppxstab_create(void);\nvoid jpc_ppxstab_destroy(jpc_ppxstab_t *tab);\nint jpc_ppxstab_grow(jpc_ppxstab_t *tab, int maxents);\nint jpc_ppxstab_insert(jpc_ppxstab_t *tab, jpc_ppxstabent_t *ent);\njpc_streamlist_t *jpc_ppmstabtostreams(jpc_ppxstab_t *tab);\nint jpc_pptstabwrite(jas_stream_t *out, jpc_ppxstab_t *tab);\njpc_ppxstabent_t *jpc_ppxstabent_create(void);\nvoid jpc_ppxstabent_destroy(jpc_ppxstabent_t *ent);\n\nint jpc_streamlist_numstreams(jpc_streamlist_t *streamlist);\njpc_streamlist_t *jpc_streamlist_create(void);\nint jpc_streamlist_insert(jpc_streamlist_t *streamlist, int streamno,\n  jas_stream_t *stream);\njas_stream_t *jpc_streamlist_remove(jpc_streamlist_t *streamlist, int streamno);\nvoid jpc_streamlist_destroy(jpc_streamlist_t *streamlist);\njas_stream_t *jpc_streamlist_get(jpc_streamlist_t *streamlist, int streamno);\n\nstatic void jpc_dec_cp_resetflags(jpc_dec_cp_t *cp);\nstatic jpc_dec_cp_t *jpc_dec_cp_create(uint_fast16_t numcomps);\nstatic int jpc_dec_cp_isvalid(jpc_dec_cp_t *cp);\nstatic jpc_dec_cp_t *jpc_dec_cp_copy(jpc_dec_cp_t *cp);\nstatic int jpc_dec_cp_setfromcod(jpc_dec_cp_t *cp, jpc_cod_t *cod);\nstatic int jpc_dec_cp_setfromcoc(jpc_dec_cp_t *cp, jpc_coc_t *coc);\nstatic int jpc_dec_cp_setfromcox(jpc_dec_cp_t *cp, jpc_dec_ccp_t *ccp,\n  jpc_coxcp_t *compparms, int flags);\nstatic int jpc_dec_cp_setfromqcd(jpc_dec_cp_t *cp, jpc_qcd_t *qcd);\nstatic int jpc_dec_cp_setfromqcc(jpc_dec_cp_t *cp, jpc_qcc_t *qcc);\nstatic int jpc_dec_cp_setfromqcx(jpc_dec_cp_t *cp, jpc_dec_ccp_t *ccp,\n  jpc_qcxcp_t *compparms, int flags);\nstatic int jpc_dec_cp_setfromrgn(jpc_dec_cp_t *cp, jpc_rgn_t *rgn);\nstatic int jpc_dec_cp_prepare(jpc_dec_cp_t *cp);\nstatic void jpc_dec_cp_destroy(jpc_dec_cp_t *cp);\nstatic int jpc_dec_cp_setfrompoc(jpc_dec_cp_t *cp, jpc_poc_t *poc, int reset);\nstatic int jpc_pi_addpchgfrompoc(jpc_pi_t *pi, jpc_poc_t *poc);\n\nstatic int jpc_dec_decode(jpc_dec_t *dec);\nstatic jpc_dec_t *jpc_dec_create(jpc_dec_importopts_t *impopts, jas_stream_t *in);\nstatic void jpc_dec_destroy(jpc_dec_t *dec);\nstatic void jpc_dequantize(jas_matrix_t *x, jpc_fix_t absstepsize);\nstatic void jpc_undo_roi(jas_matrix_t *x, int roishift, int bgshift, int numbps);\nstatic jpc_fix_t jpc_calcabsstepsize(int stepsize, int numbits);\nstatic int jpc_dec_tiledecode(jpc_dec_t *dec, jpc_dec_tile_t *tile);\nstatic int jpc_dec_tileinit(jpc_dec_t *dec, jpc_dec_tile_t *tile);\nstatic int jpc_dec_tilefini(jpc_dec_t *dec, jpc_dec_tile_t *tile);\nstatic int jpc_dec_process_soc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_sot(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_sod(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_eoc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_cod(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_coc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_rgn(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_qcd(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_qcc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_poc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_ppm(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_ppt(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_com(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_unk(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_crg(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_parseopts(char *optstr, jpc_dec_importopts_t *opts);\n\nstatic jpc_dec_mstabent_t *jpc_dec_mstab_lookup(uint_fast16_t id);\n\n/******************************************************************************\\\n* Global data.\n\\******************************************************************************/\n\njpc_dec_mstabent_t jpc_dec_mstab[] = {\n\t{JPC_MS_SOC, JPC_MHSOC, jpc_dec_process_soc},\n\t{JPC_MS_SOT, JPC_MH | JPC_TPHSOT, jpc_dec_process_sot},\n\t{JPC_MS_SOD, JPC_TPH, jpc_dec_process_sod},\n\t{JPC_MS_EOC, JPC_TPHSOT, jpc_dec_process_eoc},\n\t{JPC_MS_SIZ, JPC_MHSIZ, jpc_dec_process_siz},\n\t{JPC_MS_COD, JPC_MH | JPC_TPH, jpc_dec_process_cod},\n\t{JPC_MS_COC, JPC_MH | JPC_TPH, jpc_dec_process_coc},\n\t{JPC_MS_RGN, JPC_MH | JPC_TPH, jpc_dec_process_rgn},\n\t{JPC_MS_QCD, JPC_MH | JPC_TPH, jpc_dec_process_qcd},\n\t{JPC_MS_QCC, JPC_MH | JPC_TPH, jpc_dec_process_qcc},\n\t{JPC_MS_POC, JPC_MH | JPC_TPH, jpc_dec_process_poc},\n\t{JPC_MS_TLM, JPC_MH, 0},\n\t{JPC_MS_PLM, JPC_MH, 0},\n\t{JPC_MS_PLT, JPC_TPH, 0},\n\t{JPC_MS_PPM, JPC_MH, jpc_dec_process_ppm},\n\t{JPC_MS_PPT, JPC_TPH, jpc_dec_process_ppt},\n\t{JPC_MS_SOP, 0, 0},\n\t{JPC_MS_CRG, JPC_MH, jpc_dec_process_crg},\n\t{JPC_MS_COM, JPC_MH | JPC_TPH, jpc_dec_process_com},\n\t{0, JPC_MH | JPC_TPH, jpc_dec_process_unk}\n};\n\n/******************************************************************************\\\n* The main entry point for the JPEG-2000 decoder.\n\\******************************************************************************/\n\njas_image_t *jpc_decode(jas_stream_t *in, char *optstr)\n{\n\tjpc_dec_importopts_t opts;\n\tjpc_dec_t *dec;\n\tjas_image_t *image;\n\n\tdec = 0;\n\n\tif (jpc_dec_parseopts(optstr, &opts)) {\n\t\tgoto error;\n\t}\n\n\tjpc_initluts();\n\n\tif (!(dec = jpc_dec_create(&opts, in))) {\n\t\tgoto error;\n\t}\n\n\t/* Do most of the work. */\n\tif (jpc_dec_decode(dec)) {\n\t\tgoto error;\n\t}\n\n\tif (jas_image_numcmpts(dec->image) >= 3) {\n\t\tjas_image_setclrspc(dec->image, JAS_CLRSPC_SRGB);\n\t\tjas_image_setcmpttype(dec->image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));\n\t\tjas_image_setcmpttype(dec->image, 1,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));\n\t\tjas_image_setcmpttype(dec->image, 2,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));\n\t} else {\n\t\tjas_image_setclrspc(dec->image, JAS_CLRSPC_SGRAY);\n\t\tjas_image_setcmpttype(dec->image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));\n\t}\n\n\t/* Save the return value. */\n\timage = dec->image;\n\n\t/* Stop the image from being discarded. */\n\tdec->image = 0;\n\n\t/* Destroy decoder. */\n\tjpc_dec_destroy(dec);\n\n\treturn image;\n\nerror:\n\tif (dec) {\n\t\tjpc_dec_destroy(dec);\n\t}\n\treturn 0;\n}\n\ntypedef enum {\n\tOPT_MAXLYRS,\n\tOPT_MAXPKTS,\n\tOPT_DEBUG\n} optid_t;\n\njas_taginfo_t decopts[] = {\n\t{OPT_MAXLYRS, \"maxlyrs\"},\n\t{OPT_MAXPKTS, \"maxpkts\"},\n\t{OPT_DEBUG, \"debug\"},\n\t{-1, 0}\n};\n\nstatic int jpc_dec_parseopts(char *optstr, jpc_dec_importopts_t *opts)\n{\n\tjas_tvparser_t *tvp;\n\n\topts->debug = 0;\n\topts->maxlyrs = JPC_MAXLYRS;\n\topts->maxpkts = -1;\n\n\tif (!(tvp = jas_tvparser_create(optstr ? optstr : \"\"))) {\n\t\treturn -1;\n\t}\n\n\twhile (!jas_tvparser_next(tvp)) {\n\t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(decopts,\n\t\t  jas_tvparser_gettag(tvp)))->id) {\n\t\tcase OPT_MAXLYRS:\n\t\t\topts->maxlyrs = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_DEBUG:\n\t\t\topts->debug = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_MAXPKTS:\n\t\t\topts->maxpkts = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tjas_eprintf(\"warning: ignoring invalid option %s\\n\",\n\t\t\t  jas_tvparser_gettag(tvp));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tjas_tvparser_destroy(tvp);\n\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Code for table-driven code stream decoder.\n\\******************************************************************************/\n\nstatic jpc_dec_mstabent_t *jpc_dec_mstab_lookup(uint_fast16_t id)\n{\n\tjpc_dec_mstabent_t *mstabent;\n\tfor (mstabent = jpc_dec_mstab; mstabent->id != 0; ++mstabent) {\n\t\tif (mstabent->id == id) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn mstabent;\n}\n\nstatic int jpc_dec_decode(jpc_dec_t *dec)\n{\n\tjpc_ms_t *ms;\n\tjpc_dec_mstabent_t *mstabent;\n\tint ret;\n\tjpc_cstate_t *cstate;\n\n\tif (!(cstate = jpc_cstate_create())) {\n\t\treturn -1;\n\t}\n\tdec->cstate = cstate;\n\n\t/* Initially, we should expect to encounter a SOC marker segment. */\n\tdec->state = JPC_MHSOC;\n\n\tfor (;;) {\n\n\t\t/* Get the next marker segment in the code stream. */\n\t\tif (!(ms = jpc_getms(dec->in, cstate))) {\n\t\t\tjas_eprintf(\"cannot get marker segment\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tmstabent = jpc_dec_mstab_lookup(ms->id);\n\t\tassert(mstabent);\n\n\t\t/* Ensure that this type of marker segment is permitted\n\t\t  at this point in the code stream. */\n\t\tif (!(dec->state & mstabent->validstates)) {\n\t\t\tjas_eprintf(\"unexpected marker segment type\\n\");\n\t\t\tjpc_ms_destroy(ms);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Process the marker segment. */\n\t\tif (mstabent->action) {\n\t\t\tret = (*mstabent->action)(dec, ms);\n\t\t} else {\n\t\t\t/* No explicit action is required. */\n\t\t\tret = 0;\n\t\t}\n\n\t\t/* Destroy the marker segment. */\n\t\tjpc_ms_destroy(ms);\n\n\t\tif (ret < 0) {\n\t\t\treturn -1;\n\t\t} else if (ret > 0) {\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_crg(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tint cmptno;\n\tjpc_dec_cmpt_t *cmpt;\n\tjpc_crg_t *crg;\n\n\tcrg = &ms->parms.crg;\n\tfor (cmptno = 0, cmpt = dec->cmpts; cmptno < dec->numcomps; ++cmptno,\n\t  ++cmpt) {\n\t\t/* Ignore the information in the CRG marker segment for now.\n\t\t  This information serves no useful purpose for decoding anyhow.\n\t\t  Some other parts of the code need to be changed if these lines\n\t\t  are uncommented.\n\t\tcmpt->hsubstep = crg->comps[cmptno].hoff;\n\t\tcmpt->vsubstep = crg->comps[cmptno].voff;\n\t\t*/\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_soc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\t/* Eliminate warnings about unused variables. */\n\tms = 0;\n\n\t/* We should expect to encounter a SIZ marker segment next. */\n\tdec->state = JPC_MHSIZ;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_sot(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_dec_tile_t *tile;\n\tjpc_sot_t *sot = &ms->parms.sot;\n\tjas_image_cmptparm_t *compinfos;\n\tjas_image_cmptparm_t *compinfo;\n\tjpc_dec_cmpt_t *cmpt;\n\tint cmptno;\n\n\tif (dec->state == JPC_MH) {\n\n\t\tif (!(compinfos = jas_alloc2(dec->numcomps,\n\t\t  sizeof(jas_image_cmptparm_t)))) {\n\t\t\tabort();\n\t\t}\n\t\tfor (cmptno = 0, cmpt = dec->cmpts, compinfo = compinfos;\n\t\t  cmptno < dec->numcomps; ++cmptno, ++cmpt, ++compinfo) {\n\t\t\tcompinfo->tlx = 0;\n\t\t\tcompinfo->tly = 0;\n\t\t\tcompinfo->prec = cmpt->prec;\n\t\t\tcompinfo->sgnd = cmpt->sgnd;\n\t\t\tcompinfo->width = cmpt->width;\n\t\t\tcompinfo->height = cmpt->height;\n\t\t\tcompinfo->hstep = cmpt->hstep;\n\t\t\tcompinfo->vstep = cmpt->vstep;\n\t\t}\n\n\t\tif (!(dec->image = jas_image_create(dec->numcomps, compinfos,\n\t\t  JAS_CLRSPC_UNKNOWN))) {\n\t\t\tjas_free(compinfos);\n\t\t\treturn -1;\n\t\t}\n\t\tjas_free(compinfos);\n\n\t\t/* Is the packet header information stored in PPM marker segments in\n\t\t  the main header? */\n\t\tif (dec->ppmstab) {\n\t\t\t/* Convert the PPM marker segment data into a collection of streams\n\t\t\t  (one stream per tile-part). */\n\t\t\tif (!(dec->pkthdrstreams = jpc_ppmstabtostreams(dec->ppmstab))) {\n\t\t\t\tabort();\n\t\t\t}\n\t\t\tjpc_ppxstab_destroy(dec->ppmstab);\n\t\t\tdec->ppmstab = 0;\n\t\t}\n\t}\n\n\tif (sot->len > 0) {\n\t\tdec->curtileendoff = jas_stream_getrwcount(dec->in) - ms->len -\n\t\t  4 + sot->len;\n\t} else {\n\t\tdec->curtileendoff = 0;\n\t}\n\n\tif (JAS_CAST(int, sot->tileno) >= dec->numtiles) {\n\t\tjas_eprintf(\"invalid tile number in SOT marker segment\\n\");\n\t\treturn -1;\n\t}\n\t/* Set the current tile. */\n\tdec->curtile = &dec->tiles[sot->tileno];\n\ttile = dec->curtile;\n\t/* Ensure that this is the expected part number. */\n\tif (sot->partno != tile->partno) {\n\t\treturn -1;\n\t}\n\tif (tile->numparts > 0 && sot->partno >= tile->numparts) {\n\t\treturn -1;\n\t}\n\tif (!tile->numparts && sot->numparts > 0) {\n\t\ttile->numparts = sot->numparts;\n\t}\n\n\ttile->pptstab = 0;\n\n\tswitch (tile->state) {\n\tcase JPC_TILE_INIT:\n\t\t/* This is the first tile-part for this tile. */\n\t\ttile->state = JPC_TILE_ACTIVE;\n\t\tassert(!tile->cp);\n\t\tif (!(tile->cp = jpc_dec_cp_copy(dec->cp))) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_resetflags(dec->cp);\n\t\tbreak;\n\tdefault:\n\t\tif (sot->numparts == sot->partno - 1) {\n\t\t\ttile->state = JPC_TILE_ACTIVELAST;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* Note: We do not increment the expected tile-part number until\n\t  all processing for this tile-part is complete. */\n\n\t/* We should expect to encounter other tile-part header marker\n\t  segments next. */\n\tdec->state = JPC_TPH;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_sod(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_dec_tile_t *tile;\n\tint pos;\n\n\t/* Eliminate compiler warnings about unused variables. */\n\tms = 0;\n\n\tif (!(tile = dec->curtile)) {\n\t\treturn -1;\n\t}\n\n\tif (!tile->partno) {\n\t\tif (!jpc_dec_cp_isvalid(tile->cp)) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_prepare(tile->cp);\n\t\tif (jpc_dec_tileinit(dec, tile)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Are packet headers stored in the main header or tile-part header? */\n\tif (dec->pkthdrstreams) {\n\t\t/* Get the stream containing the packet header data for this\n\t\t  tile-part. */\n\t\tif (!(tile->pkthdrstream = jpc_streamlist_remove(dec->pkthdrstreams, 0))) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (tile->pptstab) {\n\t\tif (!tile->pkthdrstream) {\n\t\t\tif (!(tile->pkthdrstream = jas_stream_memopen(0, 0))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tpos = jas_stream_tell(tile->pkthdrstream);\n\t\tjas_stream_seek(tile->pkthdrstream, 0, SEEK_END);\n\t\tif (jpc_pptstabwrite(tile->pkthdrstream, tile->pptstab)) {\n\t\t\treturn -1;\n\t\t}\n\t\tjas_stream_seek(tile->pkthdrstream, pos, SEEK_SET);\n\t\tjpc_ppxstab_destroy(tile->pptstab);\n\t\ttile->pptstab = 0;\n\t}\n\n\tif (jas_getdbglevel() >= 10) {\n\t\tjpc_dec_dump(dec, stderr);\n\t}\n\n\tif (jpc_dec_decodepkts(dec, (tile->pkthdrstream) ? tile->pkthdrstream :\n\t  dec->in, dec->in)) {\n\t\tjas_eprintf(\"jpc_dec_decodepkts failed\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Gobble any unconsumed tile data. */\n\tif (dec->curtileendoff > 0) {\n\t\tlong curoff;\n\t\tuint_fast32_t n;\n\t\tcuroff = jas_stream_getrwcount(dec->in);\n\t\tif (curoff < dec->curtileendoff) {\n\t\t\tn = dec->curtileendoff - curoff;\n\t\t\tjas_eprintf(\"warning: ignoring trailing garbage (%lu bytes)\\n\",\n\t\t\t  (unsigned long) n);\n\n\t\t\twhile (n-- > 0) {\n\t\t\t\tif (jas_stream_getc(dec->in) == EOF) {\n\t\t\t\t\tjas_eprintf(\"read error\\n\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (curoff > dec->curtileendoff) {\n\t\t\tjas_eprintf(\"warning: not enough tile data (%lu bytes)\\n\",\n\t\t\t  (unsigned long) curoff - dec->curtileendoff);\n\t\t}\n\n\t}\n\n\tif (tile->numparts > 0 && tile->partno == tile->numparts - 1) {\n\t\tif (jpc_dec_tiledecode(dec, tile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_tilefini(dec, tile);\n\t}\n\n\tdec->curtile = 0;\n\n\t/* Increment the expected tile-part number. */\n\t++tile->partno;\n\n\t/* We should expect to encounter a SOT marker segment next. */\n\tdec->state = JPC_TPHSOT;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_tileinit(jpc_dec_t *dec, jpc_dec_tile_t *tile)\n{\n\tjpc_dec_tcomp_t *tcomp;\n\tint compno;\n\tint rlvlno;\n\tjpc_dec_rlvl_t *rlvl;\n\tjpc_dec_band_t *band;\n\tjpc_dec_prc_t *prc;\n\tint bndno;\n\tjpc_tsfb_band_t *bnd;\n\tint bandno;\n\tjpc_dec_ccp_t *ccp;\n\tint prccnt;\n\tjpc_dec_cblk_t *cblk;\n\tint cblkcnt;\n\tuint_fast32_t tlprcxstart;\n\tuint_fast32_t tlprcystart;\n\tuint_fast32_t brprcxend;\n\tuint_fast32_t brprcyend;\n\tuint_fast32_t tlcbgxstart;\n\tuint_fast32_t tlcbgystart;\n\tuint_fast32_t brcbgxend;\n\tuint_fast32_t brcbgyend;\n\tuint_fast32_t cbgxstart;\n\tuint_fast32_t cbgystart;\n\tuint_fast32_t cbgxend;\n\tuint_fast32_t cbgyend;\n\tuint_fast32_t tlcblkxstart;\n\tuint_fast32_t tlcblkystart;\n\tuint_fast32_t brcblkxend;\n\tuint_fast32_t brcblkyend;\n\tuint_fast32_t cblkxstart;\n\tuint_fast32_t cblkystart;\n\tuint_fast32_t cblkxend;\n\tuint_fast32_t cblkyend;\n\tuint_fast32_t tmpxstart;\n\tuint_fast32_t tmpystart;\n\tuint_fast32_t tmpxend;\n\tuint_fast32_t tmpyend;\n\tjpc_dec_cp_t *cp;\n\tjpc_tsfb_band_t bnds[64];\n\tjpc_pchg_t *pchg;\n\tint pchgno;\n\tjpc_dec_cmpt_t *cmpt;\n\n\tcp = tile->cp;\n\ttile->realmode = 0;\n\tif (cp->mctid == JPC_MCT_ICT) {\n\t\ttile->realmode = 1;\n\t}\n\n\tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <\n\t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {\n\t\tccp = &tile->cp->ccps[compno];\n\t\tif (ccp->qmfbid == JPC_COX_INS) {\n\t\t\ttile->realmode = 1;\n\t\t}\n\t\ttcomp->numrlvls = ccp->numrlvls;\n\t\tif (!(tcomp->rlvls = jas_alloc2(tcomp->numrlvls,\n\t\t  sizeof(jpc_dec_rlvl_t)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (!(tcomp->data = jas_seq2d_create(JPC_CEILDIV(tile->xstart,\n\t\t  cmpt->hstep), JPC_CEILDIV(tile->ystart, cmpt->vstep),\n\t\t  JPC_CEILDIV(tile->xend, cmpt->hstep), JPC_CEILDIV(tile->yend,\n\t\t  cmpt->vstep)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (!(tcomp->tsfb = jpc_cod_gettsfb(ccp->qmfbid,\n\t\t  tcomp->numrlvls - 1))) {\n\t\t\treturn -1;\n\t\t}\n\t\t{\n\t\t\tjpc_tsfb_getbands(tcomp->tsfb, jas_seq2d_xstart(tcomp->data),\n\t\t\t  jas_seq2d_ystart(tcomp->data), jas_seq2d_xend(tcomp->data),\n\t\t\t  jas_seq2d_yend(tcomp->data), bnds);\n\t\t}\n\t\tfor (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno < tcomp->numrlvls;\n\t\t  ++rlvlno, ++rlvl) {\n\t\t\trlvl->bands = 0;\n\t\t\trlvl->xstart = JPC_CEILDIVPOW2(tcomp->xstart,\n\t\t\t  tcomp->numrlvls - 1 - rlvlno);\n\t\t\trlvl->ystart = JPC_CEILDIVPOW2(tcomp->ystart,\n\t\t\t  tcomp->numrlvls - 1 - rlvlno);\n\t\t\trlvl->xend = JPC_CEILDIVPOW2(tcomp->xend,\n\t\t\t  tcomp->numrlvls - 1 - rlvlno);\n\t\t\trlvl->yend = JPC_CEILDIVPOW2(tcomp->yend,\n\t\t\t  tcomp->numrlvls - 1 - rlvlno);\n\t\t\trlvl->prcwidthexpn = ccp->prcwidthexpns[rlvlno];\n\t\t\trlvl->prcheightexpn = ccp->prcheightexpns[rlvlno];\n\t\t\ttlprcxstart = JPC_FLOORDIVPOW2(rlvl->xstart,\n\t\t\t  rlvl->prcwidthexpn) << rlvl->prcwidthexpn;\n\t\t\ttlprcystart = JPC_FLOORDIVPOW2(rlvl->ystart,\n\t\t\t  rlvl->prcheightexpn) << rlvl->prcheightexpn;\n\t\t\tbrprcxend = JPC_CEILDIVPOW2(rlvl->xend,\n\t\t\t  rlvl->prcwidthexpn) << rlvl->prcwidthexpn;\n\t\t\tbrprcyend = JPC_CEILDIVPOW2(rlvl->yend,\n\t\t\t  rlvl->prcheightexpn) << rlvl->prcheightexpn;\n\t\t\trlvl->numhprcs = (brprcxend - tlprcxstart) >>\n\t\t\t  rlvl->prcwidthexpn;\n\t\t\trlvl->numvprcs = (brprcyend - tlprcystart) >>\n\t\t\t  rlvl->prcheightexpn;\n\t\t\trlvl->numprcs = rlvl->numhprcs * rlvl->numvprcs;\n\n\t\t\tif (rlvl->xstart >= rlvl->xend || rlvl->ystart >= rlvl->yend) {\n\t\t\t\trlvl->bands = 0;\n\t\t\t\trlvl->numprcs = 0;\n\t\t\t\trlvl->numhprcs = 0;\n\t\t\t\trlvl->numvprcs = 0;\n\t\t\t\tcontinue;\n\t\t\t}\t\n\t\t\tif (!rlvlno) {\n\t\t\t\ttlcbgxstart = tlprcxstart;\n\t\t\t\ttlcbgystart = tlprcystart;\n\t\t\t\tbrcbgxend = brprcxend;\n\t\t\t\tbrcbgyend = brprcyend;\n\t\t\t\trlvl->cbgwidthexpn = rlvl->prcwidthexpn;\n\t\t\t\trlvl->cbgheightexpn = rlvl->prcheightexpn;\n\t\t\t} else {\n\t\t\t\ttlcbgxstart = JPC_CEILDIVPOW2(tlprcxstart, 1);\n\t\t\t\ttlcbgystart = JPC_CEILDIVPOW2(tlprcystart, 1);\n\t\t\t\tbrcbgxend = JPC_CEILDIVPOW2(brprcxend, 1);\n\t\t\t\tbrcbgyend = JPC_CEILDIVPOW2(brprcyend, 1);\n\t\t\t\trlvl->cbgwidthexpn = rlvl->prcwidthexpn - 1;\n\t\t\t\trlvl->cbgheightexpn = rlvl->prcheightexpn - 1;\n\t\t\t}\n\t\t\trlvl->cblkwidthexpn = JAS_MIN(ccp->cblkwidthexpn,\n\t\t\t  rlvl->cbgwidthexpn);\n\t\t\trlvl->cblkheightexpn = JAS_MIN(ccp->cblkheightexpn,\n\t\t\t  rlvl->cbgheightexpn);\n\n\t\t\trlvl->numbands = (!rlvlno) ? 1 : 3;\n\t\t\tif (!(rlvl->bands = jas_alloc2(rlvl->numbands,\n\t\t\t  sizeof(jpc_dec_band_t)))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (bandno = 0, band = rlvl->bands;\n\t\t\t  bandno < rlvl->numbands; ++bandno, ++band) {\n\t\t\t\tbndno = (!rlvlno) ? 0 : (3 * (rlvlno - 1) +\n\t\t\t\t  bandno + 1);\n\t\t\t\tbnd = &bnds[bndno];\n\n\t\t\t\tband->orient = bnd->orient;\n\t\t\t\tband->stepsize = ccp->stepsizes[bndno];\n\t\t\t\tband->analgain = JPC_NOMINALGAIN(ccp->qmfbid,\n\t\t\t\t  tcomp->numrlvls - 1, rlvlno, band->orient);\n\t\t\t\tband->absstepsize = jpc_calcabsstepsize(band->stepsize,\n\t\t\t\t  cmpt->prec + band->analgain);\n\t\t\t\tband->numbps = ccp->numguardbits +\n\t\t\t\t  JPC_QCX_GETEXPN(band->stepsize) - 1;\n\t\t\t\tband->roishift = (ccp->roishift + band->numbps >= JPC_PREC) ?\n\t\t\t\t  (JPC_PREC - 1 - band->numbps) : ccp->roishift;\n\t\t\t\tband->data = 0;\n\t\t\t\tband->prcs = 0;\n\t\t\t\tif (bnd->xstart == bnd->xend || bnd->ystart == bnd->yend) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!(band->data = jas_seq2d_create(0, 0, 0, 0))) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tjas_seq2d_bindsub(band->data, tcomp->data, bnd->locxstart,\n\t\t\t\t  bnd->locystart, bnd->locxend, bnd->locyend);\n\t\t\t\tjas_seq2d_setshift(band->data, bnd->xstart, bnd->ystart);\n\n\t\t\t\tassert(rlvl->numprcs);\n\n\t\t\t\tif (!(band->prcs = jas_alloc2(rlvl->numprcs,\n\t\t\t\t  sizeof(jpc_dec_prc_t)))) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n/************************************************/\n\t\t\t\tcbgxstart = tlcbgxstart;\n\t\t\t\tcbgystart = tlcbgystart;\n\t\t\t\tfor (prccnt = rlvl->numprcs, prc = band->prcs;\n\t\t\t\t  prccnt > 0; --prccnt, ++prc) {\n\t\t\t\t\tcbgxend = cbgxstart + (1 << rlvl->cbgwidthexpn);\n\t\t\t\t\tcbgyend = cbgystart + (1 << rlvl->cbgheightexpn);\n\t\t\t\t\tprc->xstart = JAS_MAX(cbgxstart, JAS_CAST(uint_fast32_t,\n\t\t\t\t\t  jas_seq2d_xstart(band->data)));\n\t\t\t\t\tprc->ystart = JAS_MAX(cbgystart, JAS_CAST(uint_fast32_t,\n\t\t\t\t\t  jas_seq2d_ystart(band->data)));\n\t\t\t\t\tprc->xend = JAS_MIN(cbgxend, JAS_CAST(uint_fast32_t,\n\t\t\t\t\t  jas_seq2d_xend(band->data)));\n\t\t\t\t\tprc->yend = JAS_MIN(cbgyend, JAS_CAST(uint_fast32_t,\n\t\t\t\t\t  jas_seq2d_yend(band->data)));\n\t\t\t\t\tif (prc->xend > prc->xstart && prc->yend > prc->ystart) {\n\t\t\t\t\t\ttlcblkxstart = JPC_FLOORDIVPOW2(prc->xstart,\n\t\t\t\t\t\t  rlvl->cblkwidthexpn) << rlvl->cblkwidthexpn;\n\t\t\t\t\t\ttlcblkystart = JPC_FLOORDIVPOW2(prc->ystart,\n\t\t\t\t\t\t  rlvl->cblkheightexpn) << rlvl->cblkheightexpn;\n\t\t\t\t\t\tbrcblkxend = JPC_CEILDIVPOW2(prc->xend,\n\t\t\t\t\t\t  rlvl->cblkwidthexpn) << rlvl->cblkwidthexpn;\n\t\t\t\t\t\tbrcblkyend = JPC_CEILDIVPOW2(prc->yend,\n\t\t\t\t\t\t  rlvl->cblkheightexpn) << rlvl->cblkheightexpn;\n\t\t\t\t\t\tprc->numhcblks = (brcblkxend - tlcblkxstart) >>\n\t\t\t\t\t\t  rlvl->cblkwidthexpn;\n\t\t\t\t\t\tprc->numvcblks = (brcblkyend - tlcblkystart) >>\n\t\t\t\t\t\t  rlvl->cblkheightexpn;\n\t\t\t\t\t\tprc->numcblks = prc->numhcblks * prc->numvcblks;\n\t\t\t\t\t\tassert(prc->numcblks > 0);\n\n\t\t\t\t\t\tif (!(prc->incltagtree = jpc_tagtree_create(\n\t\t\t\t\t\t  prc->numhcblks, prc->numvcblks))) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!(prc->numimsbstagtree = jpc_tagtree_create(\n\t\t\t\t\t\t  prc->numhcblks, prc->numvcblks))) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!(prc->cblks = jas_alloc2(prc->numcblks,\n\t\t\t\t\t\t  sizeof(jpc_dec_cblk_t)))) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcblkxstart = cbgxstart;\n\t\t\t\t\t\tcblkystart = cbgystart;\n\t\t\t\t\t\tfor (cblkcnt = prc->numcblks, cblk = prc->cblks; cblkcnt > 0;) {\n\t\t\t\t\t\t\tcblkxend = cblkxstart + (1 << rlvl->cblkwidthexpn);\n\t\t\t\t\t\t\tcblkyend = cblkystart + (1 << rlvl->cblkheightexpn);\n\t\t\t\t\t\t\ttmpxstart = JAS_MAX(cblkxstart, prc->xstart);\n\t\t\t\t\t\t\ttmpystart = JAS_MAX(cblkystart, prc->ystart);\n\t\t\t\t\t\t\ttmpxend = JAS_MIN(cblkxend, prc->xend);\n\t\t\t\t\t\t\ttmpyend = JAS_MIN(cblkyend, prc->yend);\n\t\t\t\t\t\t\tif (tmpxend > tmpxstart && tmpyend > tmpystart) {\n\t\t\t\t\t\t\t\tcblk->firstpassno = -1;\n\t\t\t\t\t\t\t\tcblk->mqdec = 0;\n\t\t\t\t\t\t\t\tcblk->nulldec = 0;\n\t\t\t\t\t\t\t\tcblk->flags = 0;\n\t\t\t\t\t\t\t\tcblk->numpasses = 0;\n\t\t\t\t\t\t\t\tcblk->segs.head = 0;\n\t\t\t\t\t\t\t\tcblk->segs.tail = 0;\n\t\t\t\t\t\t\t\tcblk->curseg = 0;\n\t\t\t\t\t\t\t\tcblk->numimsbs = 0;\n\t\t\t\t\t\t\t\tcblk->numlenbits = 3;\n\t\t\t\t\t\t\t\tcblk->flags = 0;\n\t\t\t\t\t\t\t\tif (!(cblk->data = jas_seq2d_create(0, 0, 0, 0))) {\n\t\t\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tjas_seq2d_bindsub(cblk->data, band->data,\n\t\t\t\t\t\t\t\t  tmpxstart, tmpystart, tmpxend, tmpyend);\n\t\t\t\t\t\t\t\t++cblk;\n\t\t\t\t\t\t\t\t--cblkcnt;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcblkxstart += 1 << rlvl->cblkwidthexpn;\n\t\t\t\t\t\t\tif (cblkxstart >= cbgxend) {\n\t\t\t\t\t\t\t\tcblkxstart = cbgxstart;\n\t\t\t\t\t\t\t\tcblkystart += 1 << rlvl->cblkheightexpn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprc->cblks = 0;\n\t\t\t\t\t\tprc->incltagtree = 0;\n\t\t\t\t\t\tprc->numimsbstagtree = 0;\n\t\t\t\t\t}\n\t\t\t\t\tcbgxstart += 1 << rlvl->cbgwidthexpn;\n\t\t\t\t\tif (cbgxstart >= brcbgxend) {\n\t\t\t\t\t\tcbgxstart = tlcbgxstart;\n\t\t\t\t\t\tcbgystart += 1 << rlvl->cbgheightexpn;\n\t\t\t\t\t}\n\n\t\t\t\t}\n/********************************************/\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!(tile->pi = jpc_dec_pi_create(dec, tile))) {\n\t\treturn -1;\n\t}\n\n\tfor (pchgno = 0; pchgno < jpc_pchglist_numpchgs(tile->cp->pchglist);\n\t  ++pchgno) {\n\t\tpchg = jpc_pchg_copy(jpc_pchglist_get(tile->cp->pchglist, pchgno));\n\t\tassert(pchg);\n\t\tjpc_pi_addpchg(tile->pi, pchg);\n\t}\n\tjpc_pi_init(tile->pi);\n\n\treturn 0;\n}\n\nstatic int jpc_dec_tilefini(jpc_dec_t *dec, jpc_dec_tile_t *tile)\n{\n\tjpc_dec_tcomp_t *tcomp;\n\tint compno;\n\tint bandno;\n\tint rlvlno;\n\tjpc_dec_band_t *band;\n\tjpc_dec_rlvl_t *rlvl;\n\tint prcno;\n\tjpc_dec_prc_t *prc;\n\tjpc_dec_seg_t *seg;\n\tjpc_dec_cblk_t *cblk;\n\tint cblkno;\n\n\tif (tile->tcomps) {\n\n\t\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t\t  ++compno, ++tcomp) {\n\t\t\tfor (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno < tcomp->numrlvls;\n\t\t\t  ++rlvlno, ++rlvl) {\n\t\t\t\tif (!rlvl->bands) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (bandno = 0, band = rlvl->bands; bandno < rlvl->numbands;\n\t\t\t\t  ++bandno, ++band) {\n\t\t\t\t\tif (band->prcs) {\n\t\t\t\t\t\tfor (prcno = 0, prc = band->prcs; prcno <\n\t\t\t\t\t\t  rlvl->numprcs; ++prcno, ++prc) {\n\t\t\t\t\t\t\tif (!prc->cblks) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (cblkno = 0, cblk = prc->cblks; cblkno <\n\t\t\t\t\t\t\t  prc->numcblks; ++cblkno, ++cblk) {\n\n\t\t\t\t\t\t\t\twhile (cblk->segs.head) {\n\t\t\t\t\t\t\t\t\tseg = cblk->segs.head;\n\t\t\t\t\t\t\t\t\tjpc_seglist_remove(&cblk->segs, seg);\n\t\t\t\t\t\t\t\t\tjpc_seg_destroy(seg);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tjas_matrix_destroy(cblk->data);\n\t\t\t\t\t\t\t\tif (cblk->mqdec) {\n\t\t\t\t\t\t\t\t\tjpc_mqdec_destroy(cblk->mqdec);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (cblk->nulldec) {\n\t\t\t\t\t\t\t\t\tjpc_bitstream_close(cblk->nulldec);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (cblk->flags) {\n\t\t\t\t\t\t\t\t\tjas_matrix_destroy(cblk->flags);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (prc->incltagtree) {\n\t\t\t\t\t\t\t\tjpc_tagtree_destroy(prc->incltagtree);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (prc->numimsbstagtree) {\n\t\t\t\t\t\t\t\tjpc_tagtree_destroy(prc->numimsbstagtree);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (prc->cblks) {\n\t\t\t\t\t\t\t\tjas_free(prc->cblks);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (band->data) {\n\t\t\t\t\t\tjas_matrix_destroy(band->data);\n\t\t\t\t\t}\n\t\t\t\t\tif (band->prcs) {\n\t\t\t\t\t\tjas_free(band->prcs);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (rlvl->bands) {\n\t\t\t\t\tjas_free(rlvl->bands);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tcomp->rlvls) {\n\t\t\t\tjas_free(tcomp->rlvls);\n\t\t\t}\n\t\t\tif (tcomp->data) {\n\t\t\t\tjas_matrix_destroy(tcomp->data);\n\t\t\t}\n\t\t\tif (tcomp->tsfb) {\n\t\t\t\tjpc_tsfb_destroy(tcomp->tsfb);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tile->cp) {\n\t\tjpc_dec_cp_destroy(tile->cp);\n\t\t//tile->cp = 0;\n\t}\n\tif (tile->tcomps) {\n\t\tjas_free(tile->tcomps);\n\t\t//tile->tcomps = 0;\n\t}\n\tif (tile->pi) {\n\t\tjpc_pi_destroy(tile->pi);\n\t\t//tile->pi = 0;\n\t}\n\tif (tile->pkthdrstream) {\n\t\tjas_stream_close(tile->pkthdrstream);\n\t\t//tile->pkthdrstream = 0;\n\t}\n\tif (tile->pptstab) {\n\t\tjpc_ppxstab_destroy(tile->pptstab);\n\t\t//tile->pptstab = 0;\n\t}\n\n\ttile->state = JPC_TILE_DONE;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_tiledecode(jpc_dec_t *dec, jpc_dec_tile_t *tile)\n{\n\tint i;\n\tint j;\n\tjpc_dec_tcomp_t *tcomp;\n\tjpc_dec_rlvl_t *rlvl;\n\tjpc_dec_band_t *band;\n\tint compno;\n\tint rlvlno;\n\tint bandno;\n\tint adjust;\n\tint v;\n\tjpc_dec_ccp_t *ccp;\n\tjpc_dec_cmpt_t *cmpt;\n\n\tif (jpc_dec_decodecblks(dec, tile)) {\n\t\tjas_eprintf(\"jpc_dec_decodecblks failed\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Perform dequantization. */\n\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t  ++compno, ++tcomp) {\n\t\tccp = &tile->cp->ccps[compno];\n\t\tfor (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno < tcomp->numrlvls;\n\t\t  ++rlvlno, ++rlvl) {\n\t\t\tif (!rlvl->bands) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (bandno = 0, band = rlvl->bands;\n\t\t\t  bandno < rlvl->numbands; ++bandno, ++band) {\n\t\t\t\tif (!band->data) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tjpc_undo_roi(band->data, band->roishift, ccp->roishift -\n\t\t\t\t  band->roishift, band->numbps);\n\t\t\t\tif (tile->realmode) {\n\t\t\t\t\tjas_matrix_asl(band->data, JPC_FIX_FRACBITS);\n\t\t\t\t\tjpc_dequantize(band->data, band->absstepsize);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Apply an inverse wavelet transform if necessary. */\n\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t  ++compno, ++tcomp) {\n\t\tccp = &tile->cp->ccps[compno];\n\t\tjpc_tsfb_synthesize(tcomp->tsfb, tcomp->data);\n\t}\n\n\n\t/* Apply an inverse intercomponent transform if necessary. */\n\tswitch (tile->cp->mctid) {\n\tcase JPC_MCT_RCT:\n\t\tif (dec->numcomps < 3) {\n\t\t\tjas_eprintf(\"RCT requires at least three components\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_irct(tile->tcomps[0].data, tile->tcomps[1].data,\n\t\t  tile->tcomps[2].data);\n\t\tbreak;\n\tcase JPC_MCT_ICT:\n\t\tif (dec->numcomps < 3) {\n\t\t\tjas_eprintf(\"ICT requires at least three components\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_iict(tile->tcomps[0].data, tile->tcomps[1].data,\n\t\t  tile->tcomps[2].data);\n\t\tbreak;\n\t}\n\n\t/* Perform rounding and convert to integer values. */\n\tif (tile->realmode) {\n\t\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t\t  ++compno, ++tcomp) {\n\t\t\tfor (i = 0; i < jas_matrix_numrows(tcomp->data); ++i) {\n\t\t\t\tfor (j = 0; j < jas_matrix_numcols(tcomp->data); ++j) {\n\t\t\t\t\tv = jas_matrix_get(tcomp->data, i, j);\n\t\t\t\t\tv = jpc_fix_round(v);\n\t\t\t\t\tjas_matrix_set(tcomp->data, i, j, jpc_fixtoint(v));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Perform level shift. */\n\tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <\n\t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {\n\t\tadjust = cmpt->sgnd ? 0 : (1 << (cmpt->prec - 1));\n\t\tfor (i = 0; i < jas_matrix_numrows(tcomp->data); ++i) {\n\t\t\tfor (j = 0; j < jas_matrix_numcols(tcomp->data); ++j) {\n\t\t\t\t*jas_matrix_getref(tcomp->data, i, j) += adjust;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Perform clipping. */\n\tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <\n\t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {\n\t\tjpc_fix_t mn;\n\t\tjpc_fix_t mx;\n\t\tmn = cmpt->sgnd ? (-(1 << (cmpt->prec - 1))) : (0);\n\t\tmx = cmpt->sgnd ? ((1 << (cmpt->prec - 1)) - 1) : ((1 <<\n\t\t  cmpt->prec) - 1);\n\t\tjas_matrix_clip(tcomp->data, mn, mx);\n\t}\n\n\t/* XXX need to free tsfb struct */\n\n\t/* Write the data for each component of the image. */\n\tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <\n\t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {\n\t\tif (jas_image_writecmpt(dec->image, compno, tcomp->xstart -\n\t\t  JPC_CEILDIV(dec->xstart, cmpt->hstep), tcomp->ystart -\n\t\t  JPC_CEILDIV(dec->ystart, cmpt->vstep), jas_matrix_numcols(\n\t\t  tcomp->data), jas_matrix_numrows(tcomp->data), tcomp->data)) {\n\t\t\tjas_eprintf(\"write component failed\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_eoc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tint tileno;\n\tjpc_dec_tile_t *tile;\n\n\t/* Eliminate compiler warnings about unused variables. */\n\tms = 0;\n\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,\n\t  ++tile) {\n\t\tif (tile->state == JPC_TILE_ACTIVE) {\n\t\t\tif (jpc_dec_tiledecode(dec, tile)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\t/* If the tile has not yet been finalized, finalize it. */\n\t\t// OLD CODE: jpc_dec_tilefini(dec, tile);\n\t\tif (tile->state != JPC_TILE_DONE) {\n\t\t\tjpc_dec_tilefini(dec, tile);\n\t\t}\n\t}\n\n\t/* We are done processing the code stream. */\n\tdec->state = JPC_MT;\n\n\treturn 1;\n}\n\nstatic int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_siz_t *siz = &ms->parms.siz;\n\tint compno;\n\tint tileno;\n\tjpc_dec_tile_t *tile;\n\tjpc_dec_tcomp_t *tcomp;\n\tint htileno;\n\tint vtileno;\n\tjpc_dec_cmpt_t *cmpt;\n\tsize_t size;\n\n\tdec->xstart = siz->xoff;\n\tdec->ystart = siz->yoff;\n\tdec->xend = siz->width;\n\tdec->yend = siz->height;\n\tdec->tilewidth = siz->tilewidth;\n\tdec->tileheight = siz->tileheight;\n\tdec->tilexoff = siz->tilexoff;\n\tdec->tileyoff = siz->tileyoff;\n\tdec->numcomps = siz->numcomps;\n\tif (!(dec->cp = jpc_dec_cp_create(dec->numcomps))) {\n\t\treturn -1;\n\t}\n\n\tif (!(dec->cmpts = jas_alloc2(dec->numcomps, sizeof(jpc_dec_cmpt_t)))) {\n\t\treturn -1;\n\t}\n\n\tfor (compno = 0, cmpt = dec->cmpts; compno < dec->numcomps; ++compno,\n\t  ++cmpt) {\n\t\tcmpt->prec = siz->comps[compno].prec;\n\t\tcmpt->sgnd = siz->comps[compno].sgnd;\n\t\tcmpt->hstep = siz->comps[compno].hsamp;\n\t\tcmpt->vstep = siz->comps[compno].vsamp;\n\t\tcmpt->width = JPC_CEILDIV(dec->xend, cmpt->hstep) -\n\t\t  JPC_CEILDIV(dec->xstart, cmpt->hstep);\n\t\tcmpt->height = JPC_CEILDIV(dec->yend, cmpt->vstep) -\n\t\t  JPC_CEILDIV(dec->ystart, cmpt->vstep);\n\t\tcmpt->hsubstep = 0;\n\t\tcmpt->vsubstep = 0;\n\t}\n\n\tdec->image = 0;\n\n\tdec->numhtiles = JPC_CEILDIV(dec->xend - dec->tilexoff, dec->tilewidth);\n\tdec->numvtiles = JPC_CEILDIV(dec->yend - dec->tileyoff, dec->tileheight);\n\tif (!jas_safe_size_mul(dec->numhtiles, dec->numvtiles, &size)) {\n\t\treturn -1;\n\t}\n\tdec->numtiles = size;\n\tJAS_DBGLOG(10, (\"numtiles = %d; numhtiles = %d; numvtiles = %d;\\n\",\n\t  dec->numtiles, dec->numhtiles, dec->numvtiles));\n\tif (!(dec->tiles = jas_alloc2(dec->numtiles, sizeof(jpc_dec_tile_t)))) {\n\t\treturn -1;\n\t}\n\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,\n\t  ++tile) {\n\t\thtileno = tileno % dec->numhtiles;\n\t\tvtileno = tileno / dec->numhtiles;\n\t\ttile->realmode = 0;\n\t\ttile->state = JPC_TILE_INIT;\n\t\ttile->xstart = JAS_MAX(dec->tilexoff + htileno * dec->tilewidth,\n\t\t  dec->xstart);\n\t\ttile->ystart = JAS_MAX(dec->tileyoff + vtileno * dec->tileheight,\n\t\t  dec->ystart);\n\t\ttile->xend = JAS_MIN(dec->tilexoff + (htileno + 1) *\n\t\t  dec->tilewidth, dec->xend);\n\t\ttile->yend = JAS_MIN(dec->tileyoff + (vtileno + 1) *\n\t\t  dec->tileheight, dec->yend);\n\t\ttile->numparts = 0;\n\t\ttile->partno = 0;\n\t\ttile->pkthdrstream = 0;\n\t\ttile->pkthdrstreampos = 0;\n\t\ttile->pptstab = 0;\n\t\ttile->cp = 0;\n\t\ttile->pi = 0;\n\t\tif (!(tile->tcomps = jas_alloc2(dec->numcomps,\n\t\t  sizeof(jpc_dec_tcomp_t)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (compno = 0, cmpt = dec->cmpts, tcomp = tile->tcomps;\n\t\t  compno < dec->numcomps; ++compno, ++cmpt, ++tcomp) {\n\t\t\ttcomp->rlvls = 0;\n\t\t\ttcomp->numrlvls = 0;\n\t\t\ttcomp->data = 0;\n\t\t\ttcomp->xstart = JPC_CEILDIV(tile->xstart, cmpt->hstep);\n\t\t\ttcomp->ystart = JPC_CEILDIV(tile->ystart, cmpt->vstep);\n\t\t\ttcomp->xend = JPC_CEILDIV(tile->xend, cmpt->hstep);\n\t\t\ttcomp->yend = JPC_CEILDIV(tile->yend, cmpt->vstep);\n\t\t\ttcomp->tsfb = 0;\n\t\t}\n\t}\n\n\tdec->pkthdrstreams = 0;\n\n\t/* We should expect to encounter other main header marker segments\n\t  or an SOT marker segment next. */\n\tdec->state = JPC_MH;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_cod(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_cod_t *cod = &ms->parms.cod;\n\tjpc_dec_tile_t *tile;\n\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromcod(dec->cp, cod);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno != 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromcod(tile->cp, cod);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_coc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_coc_t *coc = &ms->parms.coc;\n\tjpc_dec_tile_t *tile;\n\n\tif (JAS_CAST(int, coc->compno) >= dec->numcomps) {\n\t\tjas_eprintf(\"invalid component number in COC marker segment\\n\");\n\t\treturn -1;\n\t}\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromcoc(dec->cp, coc);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno > 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromcoc(tile->cp, coc);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_rgn(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_rgn_t *rgn = &ms->parms.rgn;\n\tjpc_dec_tile_t *tile;\n\n\tif (JAS_CAST(int, rgn->compno) >= dec->numcomps) {\n\t\tjas_eprintf(\"invalid component number in RGN marker segment\\n\");\n\t\treturn -1;\n\t}\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromrgn(dec->cp, rgn);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno > 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromrgn(tile->cp, rgn);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_qcd(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_qcd_t *qcd = &ms->parms.qcd;\n\tjpc_dec_tile_t *tile;\n\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromqcd(dec->cp, qcd);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno > 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromqcd(tile->cp, qcd);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_qcc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_qcc_t *qcc = &ms->parms.qcc;\n\tjpc_dec_tile_t *tile;\n\n\tif (JAS_CAST(int, qcc->compno) >= dec->numcomps) {\n\t\tjas_eprintf(\"invalid component number in QCC marker segment\\n\");\n\t\treturn -1;\n\t}\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromqcc(dec->cp, qcc);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno > 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromqcc(tile->cp, qcc);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_poc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_poc_t *poc = &ms->parms.poc;\n\tjpc_dec_tile_t *tile;\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tif (jpc_dec_cp_setfrompoc(dec->cp, poc, 1)) {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (!tile->partno) {\n\t\t\tif (jpc_dec_cp_setfrompoc(tile->cp, poc, (!tile->partno))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\tjpc_pi_addpchgfrompoc(tile->pi, poc);\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_ppm(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_ppm_t *ppm = &ms->parms.ppm;\n\tjpc_ppxstabent_t *ppmstabent;\n\n\tif (!dec->ppmstab) {\n\t\tif (!(dec->ppmstab = jpc_ppxstab_create())) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!(ppmstabent = jpc_ppxstabent_create())) {\n\t\treturn -1;\n\t}\n\tppmstabent->ind = ppm->ind;\n\tppmstabent->data = ppm->data;\n\tppm->data = 0;\n\tppmstabent->len = ppm->len;\n\tif (jpc_ppxstab_insert(dec->ppmstab, ppmstabent)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_ppt(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_ppt_t *ppt = &ms->parms.ppt;\n\tjpc_dec_tile_t *tile;\n\tjpc_ppxstabent_t *pptstabent;\n\n\ttile = dec->curtile;\n\tif (!tile->pptstab) {\n\t\tif (!(tile->pptstab = jpc_ppxstab_create())) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (!(pptstabent = jpc_ppxstabent_create())) {\n\t\treturn -1;\n\t}\n\tpptstabent->ind = ppt->ind;\n\tpptstabent->data = ppt->data;\n\tppt->data = 0;\n\tpptstabent->len = ppt->len;\n\tif (jpc_ppxstab_insert(tile->pptstab, pptstabent)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_com(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\t/* Eliminate compiler warnings about unused variables. */\n\tdec = 0;\n\tms = 0;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_unk(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\t/* Eliminate compiler warnings about unused variables. */\n\tdec = 0;\n\n\tjas_eprintf(\"warning: ignoring unknown marker segment\\n\");\n\tjpc_ms_dump(ms, stderr);\n\treturn 0;\n}\n\n/******************************************************************************\\\n*\n\\******************************************************************************/\n\nstatic jpc_dec_cp_t *jpc_dec_cp_create(uint_fast16_t numcomps)\n{\n\tjpc_dec_cp_t *cp;\n\tjpc_dec_ccp_t *ccp;\n\tint compno;\n\n\tif (!(cp = jas_malloc(sizeof(jpc_dec_cp_t)))) {\n\t\treturn 0;\n\t}\n\tcp->flags = 0;\n\tcp->numcomps = numcomps;\n\tcp->prgord = 0;\n\tcp->numlyrs = 0;\n\tcp->mctid = 0;\n\tcp->csty = 0;\n\tif (!(cp->ccps = jas_alloc2(cp->numcomps, sizeof(jpc_dec_ccp_t)))) {\n\t\tgoto error;\n\t}\n\tif (!(cp->pchglist = jpc_pchglist_create())) {\n\t\tgoto error;\n\t}\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tccp->flags = 0;\n\t\tccp->numrlvls = 0;\n\t\tccp->cblkwidthexpn = 0;\n\t\tccp->cblkheightexpn = 0;\n\t\tccp->qmfbid = 0;\n\t\tccp->numstepsizes = 0;\n\t\tccp->numguardbits = 0;\n\t\tccp->roishift = 0;\n\t\tccp->cblkctx = 0;\n\t}\n\treturn cp;\nerror:\n\tif (cp) {\n\t\tjpc_dec_cp_destroy(cp);\n\t}\n\treturn 0;\n}\n\nstatic jpc_dec_cp_t *jpc_dec_cp_copy(jpc_dec_cp_t *cp)\n{\n\tjpc_dec_cp_t *newcp;\n\tjpc_dec_ccp_t *newccp;\n\tjpc_dec_ccp_t *ccp;\n\tint compno;\n\n\tif (!(newcp = jpc_dec_cp_create(cp->numcomps))) {\n\t\treturn 0;\n\t}\n\tnewcp->flags = cp->flags;\n\tnewcp->prgord = cp->prgord;\n\tnewcp->numlyrs = cp->numlyrs;\n\tnewcp->mctid = cp->mctid;\n\tnewcp->csty = cp->csty;\n\tjpc_pchglist_destroy(newcp->pchglist);\n\tnewcp->pchglist = 0;\n\tif (!(newcp->pchglist = jpc_pchglist_copy(cp->pchglist))) {\n\t\tjas_free(newcp);\n\t\treturn 0;\n\t}\n\tfor (compno = 0, newccp = newcp->ccps, ccp = cp->ccps;\n\t  compno < cp->numcomps;\n\t  ++compno, ++newccp, ++ccp) {\n\t\t*newccp = *ccp;\n\t}\n\treturn newcp;\n}\n\nstatic void jpc_dec_cp_resetflags(jpc_dec_cp_t *cp)\n{\n\tint compno;\n\tjpc_dec_ccp_t *ccp;\n\tcp->flags &= (JPC_CSET | JPC_QSET);\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tccp->flags = 0;\n\t}\n}\n\nstatic void jpc_dec_cp_destroy(jpc_dec_cp_t *cp)\n{\n\tif (cp->ccps) {\n\t\tjas_free(cp->ccps);\n\t}\n\tif (cp->pchglist) {\n\t\tjpc_pchglist_destroy(cp->pchglist);\n\t}\n\tjas_free(cp);\n}\n\nstatic int jpc_dec_cp_isvalid(jpc_dec_cp_t *cp)\n{\n\tuint_fast16_t compcnt;\n\tjpc_dec_ccp_t *ccp;\n\n\tif (!(cp->flags & JPC_CSET) || !(cp->flags & JPC_QSET)) {\n\t\treturn 0;\n\t}\n\tfor (compcnt = cp->numcomps, ccp = cp->ccps; compcnt > 0; --compcnt,\n\t  ++ccp) {\n\t\t/* Is there enough step sizes for the number of bands? */\n\t\tif ((ccp->qsty != JPC_QCX_SIQNT && JAS_CAST(int, ccp->numstepsizes) < 3 *\n\t\t  ccp->numrlvls - 2) || (ccp->qsty == JPC_QCX_SIQNT &&\n\t\t  ccp->numstepsizes != 1)) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic void calcstepsizes(uint_fast16_t refstepsize, int numrlvls,\n  uint_fast16_t *stepsizes)\n{\n\tint bandno;\n\tint numbands;\n\tuint_fast16_t expn;\n\tuint_fast16_t mant;\n\texpn = JPC_QCX_GETEXPN(refstepsize);\n\tmant = JPC_QCX_GETMANT(refstepsize);\n\tnumbands = 3 * numrlvls - 2;\n\tfor (bandno = 0; bandno < numbands; ++bandno) {\n\t\tstepsizes[bandno] = JPC_QCX_MANT(mant) | JPC_QCX_EXPN(expn +\n\t\t  (numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0))));\n\t}\n}\n\nstatic int jpc_dec_cp_prepare(jpc_dec_cp_t *cp)\n{\n\tjpc_dec_ccp_t *ccp;\n\tint compno;\n\tint i;\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tif (!(ccp->csty & JPC_COX_PRT)) {\n\t\t\tfor (i = 0; i < JPC_MAXRLVLS; ++i) {\n\t\t\t\tccp->prcwidthexpns[i] = 15;\n\t\t\t\tccp->prcheightexpns[i] = 15;\n\t\t\t}\n\t\t}\n\t\tif (ccp->qsty == JPC_QCX_SIQNT) {\n\t\t\tcalcstepsizes(ccp->stepsizes[0], ccp->numrlvls, ccp->stepsizes);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromcod(jpc_dec_cp_t *cp, jpc_cod_t *cod)\n{\n\tjpc_dec_ccp_t *ccp;\n\tint compno;\n\tcp->flags |= JPC_CSET;\n\tcp->prgord = cod->prg;\n\tif (cod->mctrans) {\n\t\tcp->mctid = (cod->compparms.qmfbid == JPC_COX_INS) ? (JPC_MCT_ICT) : (JPC_MCT_RCT);\n\t} else {\n\t\tcp->mctid = JPC_MCT_NONE;\n\t}\n\tcp->numlyrs = cod->numlyrs;\n\tcp->csty = cod->csty & (JPC_COD_SOP | JPC_COD_EPH);\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tjpc_dec_cp_setfromcox(cp, ccp, &cod->compparms, 0);\n\t}\n\tcp->flags |= JPC_CSET;\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromcoc(jpc_dec_cp_t *cp, jpc_coc_t *coc)\n{\n\tjpc_dec_cp_setfromcox(cp, &cp->ccps[coc->compno], &coc->compparms, JPC_COC);\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromcox(jpc_dec_cp_t *cp, jpc_dec_ccp_t *ccp,\n  jpc_coxcp_t *compparms, int flags)\n{\n\tint rlvlno;\n\n\t/* Eliminate compiler warnings about unused variables. */\n\tcp = 0;\n\n\tif ((flags & JPC_COC) || !(ccp->flags & JPC_COC)) {\n\t\tccp->numrlvls = compparms->numdlvls + 1;\n\t\tccp->cblkwidthexpn = JPC_COX_GETCBLKSIZEEXPN(\n\t\t  compparms->cblkwidthval);\n\t\tccp->cblkheightexpn = JPC_COX_GETCBLKSIZEEXPN(\n\t\t  compparms->cblkheightval);\n\t\tccp->qmfbid = compparms->qmfbid;\n\t\tccp->cblkctx = compparms->cblksty;\n\t\tccp->csty = compparms->csty & JPC_COX_PRT;\n\t\tfor (rlvlno = 0; rlvlno < compparms->numrlvls; ++rlvlno) {\n\t\t\tccp->prcwidthexpns[rlvlno] =\n\t\t\t  compparms->rlvls[rlvlno].parwidthval;\n\t\t\tccp->prcheightexpns[rlvlno] =\n\t\t\t  compparms->rlvls[rlvlno].parheightval;\n\t\t}\n\t\tccp->flags |= flags | JPC_CSET;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromqcd(jpc_dec_cp_t *cp, jpc_qcd_t *qcd)\n{\n\tint compno;\n\tjpc_dec_ccp_t *ccp;\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tjpc_dec_cp_setfromqcx(cp, ccp, &qcd->compparms, 0);\n\t}\n\tcp->flags |= JPC_QSET;\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromqcc(jpc_dec_cp_t *cp, jpc_qcc_t *qcc)\n{\n\treturn jpc_dec_cp_setfromqcx(cp, &cp->ccps[qcc->compno], &qcc->compparms, JPC_QCC);\n}\n\nstatic int jpc_dec_cp_setfromqcx(jpc_dec_cp_t *cp, jpc_dec_ccp_t *ccp,\n  jpc_qcxcp_t *compparms, int flags)\n{\n\tint bandno;\n\n\t/* Eliminate compiler warnings about unused variables. */\n\tcp = 0;\n\n\tif ((flags & JPC_QCC) || !(ccp->flags & JPC_QCC)) {\n\t\tccp->flags |= flags | JPC_QSET;\n\t\tfor (bandno = 0; bandno < compparms->numstepsizes; ++bandno) {\n\t\t\tccp->stepsizes[bandno] = compparms->stepsizes[bandno];\n\t\t}\n\t\tccp->numstepsizes = compparms->numstepsizes;\n\t\tccp->numguardbits = compparms->numguard;\n\t\tccp->qsty = compparms->qntsty;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromrgn(jpc_dec_cp_t *cp, jpc_rgn_t *rgn)\n{\n\tjpc_dec_ccp_t *ccp;\n\tccp = &cp->ccps[rgn->compno];\n\tccp->roishift = rgn->roishift;\n\treturn 0;\n}\n\nstatic int jpc_pi_addpchgfrompoc(jpc_pi_t *pi, jpc_poc_t *poc)\n{\n\tint pchgno;\n\tjpc_pchg_t *pchg;\n\tfor (pchgno = 0; pchgno < poc->numpchgs; ++pchgno) {\n\t\tif (!(pchg = jpc_pchg_copy(&poc->pchgs[pchgno]))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jpc_pchglist_insert(pi->pchglist, -1, pchg)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfrompoc(jpc_dec_cp_t *cp, jpc_poc_t *poc, int reset)\n{\n\tint pchgno;\n\tjpc_pchg_t *pchg;\n\tif (reset) {\n\t\twhile (jpc_pchglist_numpchgs(cp->pchglist) > 0) {\n\t\t\tpchg = jpc_pchglist_remove(cp->pchglist, 0);\n\t\t\tjpc_pchg_destroy(pchg);\n\t\t}\n\t}\n\tfor (pchgno = 0; pchgno < poc->numpchgs; ++pchgno) {\n\t\tif (!(pchg = jpc_pchg_copy(&poc->pchgs[pchgno]))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jpc_pchglist_insert(cp->pchglist, -1, pchg)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic jpc_fix_t jpc_calcabsstepsize(int stepsize, int numbits)\n{\n\tjpc_fix_t absstepsize;\n\tint n;\n\n\tabsstepsize = jpc_inttofix(1);\n\tn = JPC_FIX_FRACBITS - 11;\n\tabsstepsize |= (n >= 0) ? (JPC_QCX_GETMANT(stepsize) << n) :\n\t  (JPC_QCX_GETMANT(stepsize) >> (-n));\n\tn = numbits - JPC_QCX_GETEXPN(stepsize);\n\tabsstepsize = (n >= 0) ? (absstepsize << n) : (absstepsize >> (-n));\n\treturn absstepsize;\n}\n\nstatic void jpc_dequantize(jas_matrix_t *x, jpc_fix_t absstepsize)\n{\n\tint i;\n\tint j;\n\tint t;\n\n\tassert(absstepsize >= 0);\n\tif (absstepsize == jpc_inttofix(1)) {\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < jas_matrix_numrows(x); ++i) {\n\t\tfor (j = 0; j < jas_matrix_numcols(x); ++j) {\n\t\t\tt = jas_matrix_get(x, i, j);\n\t\t\tif (t) {\n\t\t\t\tt = jpc_fix_mul(t, absstepsize);\n\t\t\t} else {\n\t\t\t\tt = 0;\n\t\t\t}\n\t\t\tjas_matrix_set(x, i, j, t);\n\t\t}\n\t}\n\n}\n\nstatic void jpc_undo_roi(jas_matrix_t *x, int roishift, int bgshift, int numbps)\n{\n\tint i;\n\tint j;\n\tint thresh;\n\tjpc_fix_t val;\n\tjpc_fix_t mag;\n\tbool warn;\n\tuint_fast32_t mask;\n\n\tif (roishift < 0) {\n\t\t/* We could instead return an error here. */\n\t\t/* I do not think it matters much. */\n\t\tjas_eprintf(\"warning: forcing negative ROI shift to zero \"\n\t\t  \"(bitstream is probably corrupt)\\n\");\n\t\troishift = 0;\n\t}\n\tif (roishift == 0 && bgshift == 0) {\n\t\treturn;\n\t}\n\tthresh = 1 << roishift;\n\n\twarn = false;\n\tfor (i = 0; i < jas_matrix_numrows(x); ++i) {\n\t\tfor (j = 0; j < jas_matrix_numcols(x); ++j) {\n\t\t\tval = jas_matrix_get(x, i, j);\n\t\t\tmag = JAS_ABS(val);\n\t\t\tif (mag >= thresh) {\n\t\t\t\t/* We are dealing with ROI data. */\n\t\t\t\tmag >>= roishift;\n\t\t\t\tval = (val < 0) ? (-mag) : mag;\n\t\t\t\tjas_matrix_set(x, i, j, val);\n\t\t\t} else {\n\t\t\t\t/* We are dealing with non-ROI (i.e., background) data. */\n\t\t\t\tmag <<= bgshift;\n\t\t\t\tmask = (JAS_CAST(uint_fast32_t, 1) << numbps) - 1;\n\t\t\t\t/* Perform a basic sanity check on the sample value. */\n\t\t\t\t/* Some implementations write garbage in the unused\n\t\t\t\t  most-significant bit planes introduced by ROI shifting.\n\t\t\t\t  Here we ensure that any such bits are masked off. */\n\t\t\t\tif (mag & (~mask)) {\n\t\t\t\t\tif (!warn) {\n\t\t\t\t\t\tjas_eprintf(\"warning: possibly corrupt code stream\\n\");\n\t\t\t\t\t\twarn = true;\n\t\t\t\t\t}\n\t\t\t\t\tmag &= mask;\n\t\t\t\t}\n\t\t\t\tval = (val < 0) ? (-mag) : mag;\n\t\t\t\tjas_matrix_set(x, i, j, val);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic jpc_dec_t *jpc_dec_create(jpc_dec_importopts_t *impopts, jas_stream_t *in)\n{\n\tjpc_dec_t *dec;\n\n\tif (!(dec = jas_malloc(sizeof(jpc_dec_t)))) {\n\t\treturn 0;\n\t}\n\n\tdec->image = 0;\n\tdec->xstart = 0;\n\tdec->ystart = 0;\n\tdec->xend = 0;\n\tdec->yend = 0;\n\tdec->tilewidth = 0;\n\tdec->tileheight = 0;\n\tdec->tilexoff = 0;\n\tdec->tileyoff = 0;\n\tdec->numhtiles = 0;\n\tdec->numvtiles = 0;\n\tdec->numtiles = 0;\n\tdec->tiles = 0;\n\tdec->curtile = 0;\n\tdec->numcomps = 0;\n\tdec->in = in;\n\tdec->cp = 0;\n\tdec->maxlyrs = impopts->maxlyrs;\n\tdec->maxpkts = impopts->maxpkts;\ndec->numpkts = 0;\n\tdec->ppmseqno = 0;\n\tdec->state = 0;\n\tdec->cmpts = 0;\n\tdec->pkthdrstreams = 0;\n\tdec->ppmstab = 0;\n\tdec->curtileendoff = 0;\n\n\treturn dec;\n}\n\nstatic void jpc_dec_destroy(jpc_dec_t *dec)\n{\n\tif (dec->cstate) {\n\t\tjpc_cstate_destroy(dec->cstate);\n\t}\n\tif (dec->pkthdrstreams) {\n\t\tjpc_streamlist_destroy(dec->pkthdrstreams);\n\t}\n\tif (dec->image) {\n\t\tjas_image_destroy(dec->image);\n\t}\n\n\tif (dec->cp) {\n\t\tjpc_dec_cp_destroy(dec->cp);\n\t}\n\n\tif (dec->cmpts) {\n\t\tjas_free(dec->cmpts);\n\t}\n\n\tif (dec->tiles) {\n\t\tjas_free(dec->tiles);\n\t}\n\n\tjas_free(dec);\n}\n\n/******************************************************************************\\\n*\n\\******************************************************************************/\n\nvoid jpc_seglist_insert(jpc_dec_seglist_t *list, jpc_dec_seg_t *ins, jpc_dec_seg_t *node)\n{\n\tjpc_dec_seg_t *prev;\n\tjpc_dec_seg_t *next;\n\n\tprev = ins;\n\tnode->prev = prev;\n\tnext = prev ? (prev->next) : 0;\n\tnode->prev = prev;\n\tnode->next = next;\n\tif (prev) {\n\t\tprev->next = node;\n\t} else {\n\t\tlist->head = node;\n\t}\n\tif (next) {\n\t\tnext->prev = node;\n\t} else {\n\t\tlist->tail = node;\n\t}\n}\n\nvoid jpc_seglist_remove(jpc_dec_seglist_t *list, jpc_dec_seg_t *seg)\n{\n\tjpc_dec_seg_t *prev;\n\tjpc_dec_seg_t *next;\n\n\tprev = seg->prev;\n\tnext = seg->next;\n\tif (prev) {\n\t\tprev->next = next;\n\t} else {\n\t\tlist->head = next;\n\t}\n\tif (next) {\n\t\tnext->prev = prev;\n\t} else {\n\t\tlist->tail = prev;\n\t}\n\tseg->prev = 0;\n\tseg->next = 0;\n}\n\njpc_dec_seg_t *jpc_seg_alloc()\n{\n\tjpc_dec_seg_t *seg;\n\n\tif (!(seg = jas_malloc(sizeof(jpc_dec_seg_t)))) {\n\t\treturn 0;\n\t}\n\tseg->prev = 0;\n\tseg->next = 0;\n\tseg->passno = -1;\n\tseg->numpasses = 0;\n\tseg->maxpasses = 0;\n\tseg->type = JPC_SEG_INVALID;\n\tseg->stream = 0;\n\tseg->cnt = 0;\n\tseg->complete = 0;\n\tseg->lyrno = -1;\n\treturn seg;\n}\n\nvoid jpc_seg_destroy(jpc_dec_seg_t *seg)\n{\n\tif (seg->stream) {\n\t\tjas_stream_close(seg->stream);\n\t}\n\tjas_free(seg);\n}\n\nstatic int jpc_dec_dump(jpc_dec_t *dec, FILE *out)\n{\n\tjpc_dec_tile_t *tile;\n\tint tileno;\n\tjpc_dec_tcomp_t *tcomp;\n\tint compno;\n\tjpc_dec_rlvl_t *rlvl;\n\tint rlvlno;\n\tjpc_dec_band_t *band;\n\tint bandno;\n\tjpc_dec_prc_t *prc;\n\tint prcno;\n\tjpc_dec_cblk_t *cblk;\n\tint cblkno;\n\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles;\n\t  ++tileno, ++tile) {\n\t\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t\t  ++compno, ++tcomp) {\n\t\t\tfor (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno <\n\t\t\t  tcomp->numrlvls; ++rlvlno, ++rlvl) {\n\t\t\t\tfprintf(out, \"RESOLUTION LEVEL %d\\n\", rlvlno);\n\t\t\t\tfprintf(out, \"xs =%\"PRIuFAST32\", ys = %\"PRIuFAST32\", xe = %\"PRIuFAST32\", ye = %\"PRIuFAST32\", w = %\"PRIuFAST32\", h = %\"PRIuFAST32\"\\n\",\n\t\t\t\t  rlvl->xstart, rlvl->ystart, rlvl->xend, rlvl->yend, rlvl->xend -\n\t\t\t\t  rlvl->xstart, rlvl->yend - rlvl->ystart);\n\t\t\t\tfor (bandno = 0, band = rlvl->bands;\n\t\t\t\t  bandno < rlvl->numbands; ++bandno, ++band) {\n\t\t\t\t\tfprintf(out, \"BAND %d\\n\", bandno);\n\t\t\t\t\tfprintf(out, \"xs =%\"PRIiFAST32\", ys = %\"PRIiFAST32\", xe = %\"PRIiFAST32\", ye = %\"PRIiFAST32\", w = %\"PRIiFAST32\", h = %\"PRIiFAST32\"\\n\",\n\t\t\t\t\t  jas_seq2d_xstart(band->data), jas_seq2d_ystart(band->data), jas_seq2d_xend(band->data),\n\t\t\t\t\t  jas_seq2d_yend(band->data), jas_seq2d_xend(band->data) - jas_seq2d_xstart(band->data),\n\t\t\t\t\t  jas_seq2d_yend(band->data) - jas_seq2d_ystart(band->data));\n\t\t\t\t\tfor (prcno = 0, prc = band->prcs;\n\t\t\t\t\t  prcno < rlvl->numprcs; ++prcno,\n\t\t\t\t\t  ++prc) {\n\t\t\t\t\t\tfprintf(out, \"CODE BLOCK GROUP %d\\n\", prcno);\n\t\t\t\t\t\tfprintf(out, \"xs =%\"PRIuFAST32\", ys = %\"PRIuFAST32\", xe = %\"PRIuFAST32\", ye = %\"PRIuFAST32\", w = %\"PRIuFAST32\", h = %\"PRIuFAST32\"\\n\",\n\t\t\t\t\t\t  prc->xstart, prc->ystart, prc->xend, prc->yend, prc->xend -\n\t\t\t\t\t\t  prc->xstart, prc->yend - prc->ystart);\n\t\t\t\t\t\tfor (cblkno = 0, cblk =\n\t\t\t\t\t\t  prc->cblks; cblkno <\n\t\t\t\t\t\t  prc->numcblks; ++cblkno,\n\t\t\t\t\t\t  ++cblk) {\n\t\t\t\t\t\t\tfprintf(out, \"CODE BLOCK %d\\n\", cblkno);\n\t\t\t\t\t\t\tfprintf(out, \"xs =%\"PRIiFAST32\", ys = %\"PRIiFAST32\", xe = %\"PRIiFAST32\", ye = %\"PRIiFAST32\", w = %\"PRIiFAST32\", h = %\"PRIiFAST32\"\\n\",\n\t\t\t\t\t\t\t  jas_seq2d_xstart(cblk->data), jas_seq2d_ystart(cblk->data), jas_seq2d_xend(cblk->data),\n\t\t\t\t\t\t\t  jas_seq2d_yend(cblk->data), jas_seq2d_xend(cblk->data) - jas_seq2d_xstart(cblk->data),\n\t\t\t\t\t\t\t  jas_seq2d_yend(cblk->data) - jas_seq2d_ystart(cblk->data));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\njpc_streamlist_t *jpc_streamlist_create()\n{\n\tjpc_streamlist_t *streamlist;\n\tint i;\n\n\tif (!(streamlist = jas_malloc(sizeof(jpc_streamlist_t)))) {\n\t\treturn 0;\n\t}\n\tstreamlist->numstreams = 0;\n\tstreamlist->maxstreams = 100;\n\tif (!(streamlist->streams = jas_alloc2(streamlist->maxstreams,\n\t  sizeof(jas_stream_t *)))) {\n\t\tjas_free(streamlist);\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < streamlist->maxstreams; ++i) {\n\t\tstreamlist->streams[i] = 0;\n\t}\n\treturn streamlist;\n}\n\nint jpc_streamlist_insert(jpc_streamlist_t *streamlist, int streamno,\n  jas_stream_t *stream)\n{\n\tjas_stream_t **newstreams;\n\tint newmaxstreams;\n\tint i;\n\t/* Grow the array of streams if necessary. */\n\tif (streamlist->numstreams >= streamlist->maxstreams) {\n\t\tnewmaxstreams = streamlist->maxstreams + 1024;\n\t\tif (!(newstreams = jas_realloc2(streamlist->streams,\n\t\t  (newmaxstreams + 1024), sizeof(jas_stream_t *)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (i = streamlist->numstreams; i < streamlist->maxstreams; ++i) {\n\t\t\tstreamlist->streams[i] = 0;\n\t\t}\n\t\tstreamlist->maxstreams = newmaxstreams;\n\t\tstreamlist->streams = newstreams;\n\t}\n\tif (streamno != streamlist->numstreams) {\n\t\t/* Can only handle insertion at start of list. */\n\t\treturn -1;\n\t}\n\tstreamlist->streams[streamno] = stream;\n\t++streamlist->numstreams;\n\treturn 0;\n}\n\njas_stream_t *jpc_streamlist_remove(jpc_streamlist_t *streamlist, int streamno)\n{\n\tjas_stream_t *stream;\n\tint i;\n\tif (streamno >= streamlist->numstreams) {\n\t\tabort();\n\t}\n\tstream = streamlist->streams[streamno];\n\tfor (i = streamno + 1; i < streamlist->numstreams; ++i) {\n\t\tstreamlist->streams[i - 1] = streamlist->streams[i];\n\t}\n\t--streamlist->numstreams;\n\treturn stream;\n}\n\nvoid jpc_streamlist_destroy(jpc_streamlist_t *streamlist)\n{\n\tint streamno;\n\tif (streamlist->streams) {\n\t\tfor (streamno = 0; streamno < streamlist->numstreams;\n\t\t  ++streamno) {\n\t\t\tjas_stream_close(streamlist->streams[streamno]);\n\t\t}\n\t\tjas_free(streamlist->streams);\n\t}\n\tjas_free(streamlist);\n}\n\njas_stream_t *jpc_streamlist_get(jpc_streamlist_t *streamlist, int streamno)\n{\n\tassert(streamno < streamlist->numstreams);\n\treturn streamlist->streams[streamno];\n}\n\nint jpc_streamlist_numstreams(jpc_streamlist_t *streamlist)\n{\n\treturn streamlist->numstreams;\n}\n\njpc_ppxstab_t *jpc_ppxstab_create()\n{\n\tjpc_ppxstab_t *tab;\n\n\tif (!(tab = jas_malloc(sizeof(jpc_ppxstab_t)))) {\n\t\treturn 0;\n\t}\n\ttab->numents = 0;\n\ttab->maxents = 0;\n\ttab->ents = 0;\n\treturn tab;\n}\n\nvoid jpc_ppxstab_destroy(jpc_ppxstab_t *tab)\n{\n\tint i;\n\tfor (i = 0; i < tab->numents; ++i) {\n\t\tjpc_ppxstabent_destroy(tab->ents[i]);\n\t}\n\tif (tab->ents) {\n\t\tjas_free(tab->ents);\n\t}\n\tjas_free(tab);\n}\n\nint jpc_ppxstab_grow(jpc_ppxstab_t *tab, int maxents)\n{\n\tjpc_ppxstabent_t **newents;\n\tif (tab->maxents < maxents) {\n\t\tnewents = (tab->ents) ? jas_realloc2(tab->ents, maxents,\n\t\t  sizeof(jpc_ppxstabent_t *)) : jas_alloc2(maxents, sizeof(jpc_ppxstabent_t *));\n\t\tif (!newents) {\n\t\t\treturn -1;\n\t\t}\n\t\ttab->ents = newents;\n\t\ttab->maxents = maxents;\n\t}\n\treturn 0;\n}\n\nint jpc_ppxstab_insert(jpc_ppxstab_t *tab, jpc_ppxstabent_t *ent)\n{\n\tint inspt;\n\tint i;\n\n\tfor (i = 0; i < tab->numents; ++i) {\n\t\tif (tab->ents[i]->ind > ent->ind) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tinspt = i;\n\n\tif (tab->numents >= tab->maxents) {\n\t\tif (jpc_ppxstab_grow(tab, tab->maxents + 128)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tfor (i = tab->numents; i > inspt; --i) {\n\t\ttab->ents[i] = tab->ents[i - 1];\n\t}\n\ttab->ents[i] = ent;\n\t++tab->numents;\n\n\treturn 0;\n}\n\njpc_streamlist_t *jpc_ppmstabtostreams(jpc_ppxstab_t *tab)\n{\n\tjpc_streamlist_t *streams;\n\tuchar *dataptr;\n\tuint_fast32_t datacnt;\n\tuint_fast32_t tpcnt;\n\tjpc_ppxstabent_t *ent;\n\tint entno;\n\tjas_stream_t *stream;\n\tint n;\n\n\tif (!(streams = jpc_streamlist_create())) {\n\t\tgoto error;\n\t}\n\n\tif (!tab->numents) {\n\t\treturn streams;\n\t}\n\n\tentno = 0;\n\tent = tab->ents[entno];\n\tdataptr = ent->data;\n\tdatacnt = ent->len;\n\tfor (;;) {\n\n\t\t/* Get the length of the packet header data for the current\n\t\t  tile-part. */\n\t\tif (datacnt < 4) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (!(stream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (jpc_streamlist_insert(streams, jpc_streamlist_numstreams(streams),\n\t\t  stream)) {\n\t\t\tgoto error;\n\t\t}\n\t\ttpcnt = (dataptr[0] << 24) | (dataptr[1] << 16) | (dataptr[2] << 8)\n\t\t  | dataptr[3];\n\t\tdatacnt -= 4;\n\t\tdataptr += 4;\n\n\t\t/* Get the packet header data for the current tile-part. */\n\t\twhile (tpcnt) {\n\t\t\tif (!datacnt) {\n\t\t\t\tif (++entno >= tab->numents) {\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tent = tab->ents[entno];\n\t\t\t\tdataptr = ent->data;\n\t\t\t\tdatacnt = ent->len;\n\t\t\t}\n\t\t\tn = JAS_MIN(tpcnt, datacnt);\n\t\t\tif (jas_stream_write(stream, dataptr, n) != n) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\ttpcnt -= n;\n\t\t\tdataptr += n;\n\t\t\tdatacnt -= n;\n\t\t}\n\t\tjas_stream_rewind(stream);\n\t\tif (!datacnt) {\n\t\t\tif (++entno >= tab->numents) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tent = tab->ents[entno];\n\t\t\tdataptr = ent->data;\n\t\t\tdatacnt = ent->len;\n\t\t}\n\t}\n\n\treturn streams;\n\nerror:\n\tif (streams) {\n\t\tjpc_streamlist_destroy(streams);\n\t}\n\treturn 0;\n}\n\nint jpc_pptstabwrite(jas_stream_t *out, jpc_ppxstab_t *tab)\n{\n\tint i;\n\tjpc_ppxstabent_t *ent;\n\tfor (i = 0; i < tab->numents; ++i) {\n\t\tent = tab->ents[i];\n\t\tif (jas_stream_write(out, ent->data, ent->len) != JAS_CAST(int, ent->len)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\njpc_ppxstabent_t *jpc_ppxstabent_create()\n{\n\tjpc_ppxstabent_t *ent;\n\tif (!(ent = jas_malloc(sizeof(jpc_ppxstabent_t)))) {\n\t\treturn 0;\n\t}\n\tent->data = 0;\n\tent->len = 0;\n\tent->ind = 0;\n\treturn ent;\n}\n\nvoid jpc_ppxstabent_destroy(jpc_ppxstabent_t *ent)\n{\n\tif (ent->data) {\n\t\tjas_free(ent->data);\n\t}\n\tjas_free(ent);\n}\n"], "fixing_code": ["/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2003 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * Image Library\n *\n * $Id$\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n#include <ctype.h>\n#include <inttypes.h>\n#include <stdbool.h>\n\n#include \"jasper/jas_math.h\"\n#include \"jasper/jas_image.h\"\n#include \"jasper/jas_malloc.h\"\n#include \"jasper/jas_string.h\"\n#include \"jasper/jas_debug.h\"\n\n/******************************************************************************\\\n* Types.\n\\******************************************************************************/\n\n#define\tFLOORDIV(x, y) ((x) / (y))\n\n/******************************************************************************\\\n* Local prototypes.\n\\******************************************************************************/\n\nstatic jas_image_cmpt_t *jas_image_cmpt_create0(void);\nstatic void jas_image_cmpt_destroy(jas_image_cmpt_t *cmpt);\nstatic jas_image_cmpt_t *jas_image_cmpt_create(uint_fast32_t tlx, uint_fast32_t tly,\n  uint_fast32_t hstep, uint_fast32_t vstep, uint_fast32_t width, uint_fast32_t\n  height, uint_fast16_t depth, bool sgnd, uint_fast32_t inmem);\nstatic void jas_image_setbbox(jas_image_t *image);\nstatic jas_image_cmpt_t *jas_image_cmpt_copy(jas_image_cmpt_t *cmpt);\nstatic int jas_image_growcmpts(jas_image_t *image, int maxcmpts);\nstatic uint_fast32_t inttobits(jas_seqent_t v, int prec, bool sgnd);\nstatic jas_seqent_t bitstoint(uint_fast32_t v, int prec, bool sgnd);\nstatic int putint(jas_stream_t *out, int sgnd, int prec, long val);\nstatic int getint(jas_stream_t *in, int sgnd, int prec, long *val);\nstatic void jas_image_calcbbox2(jas_image_t *image, jas_image_coord_t *tlx,\n  jas_image_coord_t *tly, jas_image_coord_t *brx, jas_image_coord_t *bry);\nstatic long uptomult(long x, long y);\nstatic long downtomult(long x, long y);\nstatic long convert(long val, int oldsgnd, int oldprec, int newsgnd,\n  int newprec);\nstatic void jas_image_calcbbox2(jas_image_t *image, jas_image_coord_t *tlx,\n  jas_image_coord_t *tly, jas_image_coord_t *brx, jas_image_coord_t *bry);\n\n/******************************************************************************\\\n* Global data.\n\\******************************************************************************/\n\nstatic int jas_image_numfmts = 0;\nstatic jas_image_fmtinfo_t jas_image_fmtinfos[JAS_IMAGE_MAXFMTS];\n\n/******************************************************************************\\\n* Create and destroy operations.\n\\******************************************************************************/\n\njas_image_t *jas_image_create(int numcmpts, jas_image_cmptparm_t *cmptparms,\n  int clrspc)\n{\n\tjas_image_t *image;\n\tuint_fast32_t rawsize;\n\tuint_fast32_t inmem;\n\tint cmptno;\n\tjas_image_cmptparm_t *cmptparm;\n\n\tif (!(image = jas_image_create0())) {\n\t\treturn 0;\n\t}\n\n\timage->clrspc_ = clrspc;\n\timage->maxcmpts_ = numcmpts;\n\timage->inmem_ = true;\n\n\t/* Allocate memory for the per-component information. */\n\tif (!(image->cmpts_ = jas_alloc2(image->maxcmpts_,\n\t  sizeof(jas_image_cmpt_t *)))) {\n\t\tjas_image_destroy(image);\n\t\treturn 0;\n\t}\n\t/* Initialize in case of failure. */\n\tfor (cmptno = 0; cmptno < image->maxcmpts_; ++cmptno) {\n\t\timage->cmpts_[cmptno] = 0;\n\t}\n\n\t/* Compute the approximate raw size of the image. */\n\trawsize = 0;\n\tfor (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,\n\t  ++cmptparm) {\n\t\trawsize += cmptparm->width * cmptparm->height *\n\t\t  (cmptparm->prec + 7) / 8;\n\t}\n\t/* Decide whether to buffer the image data in memory, based on the\n\t  raw size of the image. */\n\tinmem = (rawsize < JAS_IMAGE_INMEMTHRESH);\n\n\t/* Create the individual image components. */\n\tfor (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,\n\t  ++cmptparm) {\n\t\tif (!(image->cmpts_[cmptno] = jas_image_cmpt_create(cmptparm->tlx,\n\t\t  cmptparm->tly, cmptparm->hstep, cmptparm->vstep,\n\t\t  cmptparm->width, cmptparm->height, cmptparm->prec,\n\t\t  cmptparm->sgnd, inmem))) {\n\t\t\tjas_image_destroy(image);\n\t\t\treturn 0;\n\t\t}\n\t\t++image->numcmpts_;\n\t}\n\n\t/* Determine the bounding box for all of the components on the\n\t  reference grid (i.e., the image area) */\n\tjas_image_setbbox(image);\n\n\treturn image;\n}\n\njas_image_t *jas_image_create0()\n{\n\tjas_image_t *image;\n\n\tif (!(image = jas_malloc(sizeof(jas_image_t)))) {\n\t\treturn 0;\n\t}\n\n\timage->tlx_ = 0;\n\timage->tly_ = 0;\n\timage->brx_ = 0;\n\timage->bry_ = 0;\n\timage->clrspc_ = JAS_CLRSPC_UNKNOWN;\n\timage->numcmpts_ = 0;\n\timage->maxcmpts_ = 0;\n\timage->cmpts_ = 0;\n\timage->inmem_ = true;\n\timage->cmprof_ = 0;\n\n\treturn image;\n}\n\njas_image_t *jas_image_copy(jas_image_t *image)\n{\n\tjas_image_t *newimage;\n\tint cmptno;\n\n\tif (!(newimage = jas_image_create0())) {\n\t\tgoto error;\n\t}\n\n\tif (jas_image_growcmpts(newimage, image->numcmpts_)) {\n\t\tgoto error;\n\t}\n\tfor (cmptno = 0; cmptno < image->numcmpts_; ++cmptno) {\n\t\tif (!(newimage->cmpts_[cmptno] = jas_image_cmpt_copy(image->cmpts_[cmptno]))) {\n\t\t\tgoto error;\n\t\t}\n\t\t++newimage->numcmpts_;\n\t}\n\n\tjas_image_setbbox(newimage);\n\n\tif (image->cmprof_) {\n\t\tif (!(newimage->cmprof_ = jas_cmprof_copy(image->cmprof_)))\n\t\t\tgoto error;\n\t}\n\n\treturn newimage;\nerror:\n\tif (newimage) {\n\t\tjas_image_destroy(newimage);\n\t}\n\treturn 0;\n}\n\nstatic jas_image_cmpt_t *jas_image_cmpt_create0()\n{\n\tjas_image_cmpt_t *cmpt;\n\tif (!(cmpt = jas_malloc(sizeof(jas_image_cmpt_t)))) {\n\t\treturn 0;\n\t}\n\tmemset(cmpt, 0, sizeof(jas_image_cmpt_t));\n\tcmpt->type_ = JAS_IMAGE_CT_UNKNOWN;\n\treturn cmpt;\n}\n\nstatic jas_image_cmpt_t *jas_image_cmpt_copy(jas_image_cmpt_t *cmpt)\n{\n\tjas_image_cmpt_t *newcmpt;\n\n\tif (!(newcmpt = jas_image_cmpt_create0())) {\n\t\treturn 0;\n\t}\n\tnewcmpt->tlx_ = cmpt->tlx_;\n\tnewcmpt->tly_ = cmpt->tly_;\n\tnewcmpt->hstep_ = cmpt->hstep_;\n\tnewcmpt->vstep_ = cmpt->vstep_;\n\tnewcmpt->width_ = cmpt->width_;\n\tnewcmpt->height_ = cmpt->height_;\n\tnewcmpt->prec_ = cmpt->prec_;\n\tnewcmpt->sgnd_ = cmpt->sgnd_;\n\tnewcmpt->cps_ = cmpt->cps_;\n\tnewcmpt->type_ = cmpt->type_;\n\tif (!(newcmpt->stream_ = jas_stream_memopen(0, 0))) {\n\t\tgoto error;\n\t}\n\tif (jas_stream_seek(cmpt->stream_, 0, SEEK_SET)) {\n\t\tgoto error;\n\t}\n\tif (jas_stream_copy(newcmpt->stream_, cmpt->stream_, -1)) {\n\t\tgoto error;\n\t}\n\tif (jas_stream_seek(newcmpt->stream_, 0, SEEK_SET)) {\n\t\tgoto error;\n\t}\n\treturn newcmpt;\nerror:\n\tif (newcmpt) {\n\t\tjas_image_cmpt_destroy(newcmpt);\n\t}\n\treturn 0;\n}\n\nvoid jas_image_destroy(jas_image_t *image)\n{\n\tint i;\n\n\tif (image->cmpts_) {\n\t\tfor (i = 0; i < image->numcmpts_; ++i) {\n\t\t\tjas_image_cmpt_destroy(image->cmpts_[i]);\n\t\t\timage->cmpts_[i] = 0;\n\t\t}\n\t\tjas_free(image->cmpts_);\n\t}\n\tif (image->cmprof_)\n\t\tjas_cmprof_destroy(image->cmprof_);\n\tjas_free(image);\n}\n\nstatic jas_image_cmpt_t *jas_image_cmpt_create(uint_fast32_t tlx,\n  uint_fast32_t tly, uint_fast32_t hstep, uint_fast32_t vstep,\n  uint_fast32_t width, uint_fast32_t height, uint_fast16_t depth, bool sgnd,\n  uint_fast32_t inmem)\n{\n\tjas_image_cmpt_t *cmpt;\n\tsize_t size;\n\n\tif (!(cmpt = jas_malloc(sizeof(jas_image_cmpt_t)))) {\n\t\tgoto error;\n\t}\n\n\tcmpt->type_ = JAS_IMAGE_CT_UNKNOWN;\n\tcmpt->tlx_ = tlx;\n\tcmpt->tly_ = tly;\n\tcmpt->hstep_ = hstep;\n\tcmpt->vstep_ = vstep;\n\tcmpt->width_ = width;\n\tcmpt->height_ = height;\n\tcmpt->prec_ = depth;\n\tcmpt->sgnd_ = sgnd;\n\tcmpt->stream_ = 0;\n\tcmpt->cps_ = (depth + 7) / 8;\n\n\t// Compute the number of samples in the image component, while protecting\n\t// against overflow.\n\t// size = cmpt->width_ * cmpt->height_ * cmpt->cps_;\n\tif (!jas_safe_size_mul(cmpt->width_, cmpt->height_, &size) ||\n\t  !jas_safe_size_mul(size, cmpt->cps_, &size)) {\n\t\tgoto error;\n\t}\n\tcmpt->stream_ = (inmem) ? jas_stream_memopen(0, size) :\n\t  jas_stream_tmpfile();\n\tif (!cmpt->stream_) {\n\t\tgoto error;\n\t}\n\n\t/* Zero the component data.  This isn't necessary, but it is\n\tconvenient for debugging purposes. */\n\t/* Note: conversion of size - 1 to long can overflow */\n\tif (jas_stream_seek(cmpt->stream_, size - 1, SEEK_SET) < 0 ||\n\t  jas_stream_putc(cmpt->stream_, 0) == EOF ||\n\t  jas_stream_seek(cmpt->stream_, 0, SEEK_SET) < 0) {\n\t\tgoto error;\n\t}\n\n\treturn cmpt;\n\nerror:\n\tif (cmpt) {\n\t\tjas_image_cmpt_destroy(cmpt);\n\t}\n\treturn 0;\n}\n\nstatic void jas_image_cmpt_destroy(jas_image_cmpt_t *cmpt)\n{\n\tif (cmpt->stream_) {\n\t\tjas_stream_close(cmpt->stream_);\n\t}\n\tjas_free(cmpt);\n}\n\n/******************************************************************************\\\n* Load and save operations.\n\\******************************************************************************/\n\njas_image_t *jas_image_decode(jas_stream_t *in, int fmt, char *optstr)\n{\n\tjas_image_fmtinfo_t *fmtinfo;\n\tjas_image_t *image;\n\n\timage = 0;\n\n\t/* If possible, try to determine the format of the input data. */\n\tif (fmt < 0) {\n\t\tif ((fmt = jas_image_getfmt(in)) < 0)\n\t\t\tgoto error;\n\t}\n\n\t/* Is it possible to decode an image represented in this format? */\n\tif (!(fmtinfo = jas_image_lookupfmtbyid(fmt)))\n\t\tgoto error;\n\tif (!fmtinfo->ops.decode)\n\t\tgoto error;\n\n\t/* Decode the image. */\n\tif (!(image = (*fmtinfo->ops.decode)(in, optstr)))\n\t\tgoto error;\n\n\t/* Create a color profile if needed. */\n\tif (!jas_clrspc_isunknown(image->clrspc_) &&\n\t  !jas_clrspc_isgeneric(image->clrspc_) && !image->cmprof_) {\n\t\tif (!(image->cmprof_ =\n\t\t  jas_cmprof_createfromclrspc(jas_image_clrspc(image))))\n\t\t\tgoto error;\n\t}\n\n\treturn image;\nerror:\n\tif (image)\n\t\tjas_image_destroy(image);\n\treturn 0;\n}\n\nint jas_image_encode(jas_image_t *image, jas_stream_t *out, int fmt, char *optstr)\n{\n\tjas_image_fmtinfo_t *fmtinfo;\n\tif (!(fmtinfo = jas_image_lookupfmtbyid(fmt))) {\n\t\treturn -1;\n\t}\n\treturn (fmtinfo->ops.encode) ? (*fmtinfo->ops.encode)(image, out,\n\t  optstr) : (-1);\n}\n\n/******************************************************************************\\\n* Component read and write operations.\n\\******************************************************************************/\n\nint jas_image_readcmpt(jas_image_t *image, int cmptno, jas_image_coord_t x,\n  jas_image_coord_t y, jas_image_coord_t width, jas_image_coord_t height,\n  jas_matrix_t *data)\n{\n\tjas_image_cmpt_t *cmpt;\n\tjas_image_coord_t i;\n\tjas_image_coord_t j;\n\tint k;\n\tjas_seqent_t v;\n\tint c;\n\tjas_seqent_t *dr;\n\tjas_seqent_t *d;\n\tint drs;\n\n\tif (cmptno < 0 || cmptno >= image->numcmpts_) {\n\t\treturn -1;\n\t}\n\n\tcmpt = image->cmpts_[cmptno];\n\tif (x >= cmpt->width_ || y >= cmpt->height_ ||\n\t  x + width > cmpt->width_ ||\n\t  y + height > cmpt->height_) {\n\t\treturn -1;\n\t}\n\n\tif (!jas_matrix_numrows(data) || !jas_matrix_numcols(data)) {\n\t\treturn -1;\n\t}\n\n\tif (jas_matrix_numrows(data) != height || jas_matrix_numcols(data) != width) {\n\t\tif (jas_matrix_resize(data, height, width)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tdr = jas_matrix_getref(data, 0, 0);\n\tdrs = jas_matrix_rowstep(data);\n\tfor (i = 0; i < height; ++i, dr += drs) {\n\t\td = dr;\n\t\tif (jas_stream_seek(cmpt->stream_, (cmpt->width_ * (y + i) + x)\n\t\t  * cmpt->cps_, SEEK_SET) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (j = width; j > 0; --j, ++d) {\n\t\t\tv = 0;\n\t\t\tfor (k = cmpt->cps_; k > 0; --k) {\n\t\t\t\tif ((c = jas_stream_getc(cmpt->stream_)) == EOF) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tv = (v << 8) | (c & 0xff);\n\t\t\t}\n\t\t\t*d = bitstoint(v, cmpt->prec_, cmpt->sgnd_);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint jas_image_writecmpt(jas_image_t *image, int cmptno, jas_image_coord_t x, jas_image_coord_t y, jas_image_coord_t width,\n  jas_image_coord_t height, jas_matrix_t *data)\n{\n\tjas_image_cmpt_t *cmpt;\n\tjas_image_coord_t i;\n\tjas_image_coord_t j;\n\tjas_seqent_t *d;\n\tjas_seqent_t *dr;\n\tint drs;\n\tjas_seqent_t v;\n\tint k;\n\tint c;\n\n\tif (cmptno < 0 || cmptno >= image->numcmpts_) {\n\t\treturn -1;\n\t}\n\n\tcmpt = image->cmpts_[cmptno];\n\tif (x >= cmpt->width_ || y >= cmpt->height_ ||\n\t  x + width > cmpt->width_ ||\n\t  y + height > cmpt->height_) {\n\t\treturn -1;\n\t}\n\n\tif (!jas_matrix_numrows(data) || !jas_matrix_numcols(data)) {\n\t\treturn -1;\n\t}\n\n\tif (jas_matrix_numrows(data) != height || jas_matrix_numcols(data) != width) {\n\t\treturn -1;\n\t}\n\n\tdr = jas_matrix_getref(data, 0, 0);\n\tdrs = jas_matrix_rowstep(data);\n\tfor (i = 0; i < height; ++i, dr += drs) {\n\t\td = dr;\n\t\tif (jas_stream_seek(cmpt->stream_, (cmpt->width_ * (y + i) + x)\n\t\t  * cmpt->cps_, SEEK_SET) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (j = width; j > 0; --j, ++d) {\n\t\t\tv = inttobits(*d, cmpt->prec_, cmpt->sgnd_);\n\t\t\tfor (k = cmpt->cps_; k > 0; --k) {\n\t\t\t\tc = (v >> (8 * (cmpt->cps_ - 1))) & 0xff;\n\t\t\t\tif (jas_stream_putc(cmpt->stream_,\n\t\t\t\t  (unsigned char) c) == EOF) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tv <<= 8;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/******************************************************************************\\\n* File format operations.\n\\******************************************************************************/\n\nvoid jas_image_clearfmts()\n{\n\tint i;\n\tjas_image_fmtinfo_t *fmtinfo;\n\tfor (i = 0; i < jas_image_numfmts; ++i) {\n\t\tfmtinfo = &jas_image_fmtinfos[i];\n\t\tif (fmtinfo->name) {\n\t\t\tjas_free(fmtinfo->name);\n\t\t\tfmtinfo->name = 0;\n\t\t}\n\t\tif (fmtinfo->ext) {\n\t\t\tjas_free(fmtinfo->ext);\n\t\t\tfmtinfo->ext = 0;\n\t\t}\n\t\tif (fmtinfo->desc) {\n\t\t\tjas_free(fmtinfo->desc);\n\t\t\tfmtinfo->desc = 0;\n\t\t}\n\t}\n\tjas_image_numfmts = 0;\n}\n\nint jas_image_addfmt(int id, char *name, char *ext, char *desc,\n  jas_image_fmtops_t *ops)\n{\n\tjas_image_fmtinfo_t *fmtinfo;\n\tassert(id >= 0 && name && ext && ops);\n\tif (jas_image_numfmts >= JAS_IMAGE_MAXFMTS) {\n\t\treturn -1;\n\t}\n\tfmtinfo = &jas_image_fmtinfos[jas_image_numfmts];\n\tfmtinfo->id = id;\n\tif (!(fmtinfo->name = jas_strdup(name))) {\n\t\treturn -1;\n\t}\n\tif (!(fmtinfo->ext = jas_strdup(ext))) {\n\t\tjas_free(fmtinfo->name);\n\t\treturn -1;\n\t}\n\tif (!(fmtinfo->desc = jas_strdup(desc))) {\n\t\tjas_free(fmtinfo->name);\n\t\tjas_free(fmtinfo->ext);\n\t\treturn -1;\n\t}\n\tfmtinfo->ops = *ops;\n\t++jas_image_numfmts;\n\treturn 0;\n}\n\nint jas_image_strtofmt(char *name)\n{\n\tjas_image_fmtinfo_t *fmtinfo;\n\tif (!(fmtinfo = jas_image_lookupfmtbyname(name))) {\n\t\treturn -1;\n\t}\n\treturn fmtinfo->id;\n}\n\nchar *jas_image_fmttostr(int fmt)\n{\n\tjas_image_fmtinfo_t *fmtinfo;\n\tif (!(fmtinfo = jas_image_lookupfmtbyid(fmt))) {\n\t\treturn 0;\n\t}\n\treturn fmtinfo->name;\n}\n\nint jas_image_getfmt(jas_stream_t *in)\n{\n\tjas_image_fmtinfo_t *fmtinfo;\n\tint found;\n\tint i;\n\n\t/* Check for data in each of the supported formats. */\n\tfound = 0;\n\tfor (i = 0, fmtinfo = jas_image_fmtinfos; i < jas_image_numfmts; ++i,\n\t  ++fmtinfo) {\n\t\tif (fmtinfo->ops.validate) {\n\t\t\t/* Is the input data valid for this format? */\n\t\t\tif (!(*fmtinfo->ops.validate)(in)) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn found ? fmtinfo->id : (-1);\n}\n\nint jas_image_fmtfromname(char *name)\n{\n\tint i;\n\tchar *ext;\n\tjas_image_fmtinfo_t *fmtinfo;\n\t/* Get the file name extension. */\n\tif (!(ext = strrchr(name, '.'))) {\n\t\treturn -1;\n\t}\n\t++ext;\n\t/* Try to find a format that uses this extension. */\t\n\tfor (i = 0, fmtinfo = jas_image_fmtinfos; i < jas_image_numfmts; ++i,\n\t  ++fmtinfo) {\n\t\t/* Do we have a match? */\n\t\tif (!strcmp(ext, fmtinfo->ext)) {\n\t\t\treturn fmtinfo->id;\n\t\t}\n\t}\n\treturn -1;\n}\n\n/******************************************************************************\\\n* Miscellaneous operations.\n\\******************************************************************************/\n\nbool jas_image_cmpt_domains_same(jas_image_t *image)\n{\n\tint cmptno;\n\tjas_image_cmpt_t *cmpt;\n\tjas_image_cmpt_t *cmpt0;\n\n\tcmpt0 = image->cmpts_[0];\n\tfor (cmptno = 1; cmptno < image->numcmpts_; ++cmptno) {\n\t\tcmpt = image->cmpts_[cmptno];\n\t\tif (cmpt->tlx_ != cmpt0->tlx_ || cmpt->tly_ != cmpt0->tly_ ||\n\t\t  cmpt->hstep_ != cmpt0->hstep_ || cmpt->vstep_ != cmpt0->vstep_ ||\n\t\t  cmpt->width_ != cmpt0->width_ || cmpt->height_ != cmpt0->height_) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nuint_fast32_t jas_image_rawsize(jas_image_t *image)\n{\n\tuint_fast32_t rawsize;\n\tint cmptno;\n\tjas_image_cmpt_t *cmpt;\n\n\trawsize = 0;\n\tfor (cmptno = 0; cmptno < image->numcmpts_; ++cmptno) {\n\t\tcmpt = image->cmpts_[cmptno];\n\t\trawsize += (cmpt->width_ * cmpt->height_ * cmpt->prec_ +\n\t\t  7) / 8;\n\t}\n\treturn rawsize;\n}\n\nvoid jas_image_delcmpt(jas_image_t *image, int cmptno)\n{\n\tif (cmptno >= image->numcmpts_) {\n\t\treturn;\n\t}\n\tjas_image_cmpt_destroy(image->cmpts_[cmptno]);\n\tif (cmptno < image->numcmpts_) {\n\t\tmemmove(&image->cmpts_[cmptno], &image->cmpts_[cmptno + 1],\n\t\t  (image->numcmpts_ - 1 - cmptno) * sizeof(jas_image_cmpt_t *));\n\t}\n\t--image->numcmpts_;\n\n\tjas_image_setbbox(image);\n}\n\nint jas_image_addcmpt(jas_image_t *image, int cmptno,\n  jas_image_cmptparm_t *cmptparm)\n{\n\tjas_image_cmpt_t *newcmpt;\n\tif (cmptno < 0) {\n\t\tcmptno = image->numcmpts_;\n\t}\n\tassert(cmptno >= 0 && cmptno <= image->numcmpts_);\n\tif (image->numcmpts_ >= image->maxcmpts_) {\n\t\tif (jas_image_growcmpts(image, image->maxcmpts_ + 128)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (!(newcmpt = jas_image_cmpt_create(cmptparm->tlx,\n\t  cmptparm->tly, cmptparm->hstep, cmptparm->vstep,\n\t  cmptparm->width, cmptparm->height, cmptparm->prec,\n\t  cmptparm->sgnd, 1))) {\n\t\treturn -1;\n\t}\n\tif (cmptno < image->numcmpts_) {\n\t\tmemmove(&image->cmpts_[cmptno + 1], &image->cmpts_[cmptno],\n\t\t  (image->numcmpts_ - cmptno) * sizeof(jas_image_cmpt_t *));\n\t}\n\timage->cmpts_[cmptno] = newcmpt;\n\t++image->numcmpts_;\n\n\tjas_image_setbbox(image);\n\n\treturn 0;\n}\n\njas_image_fmtinfo_t *jas_image_lookupfmtbyid(int id)\n{\n\tint i;\n\tjas_image_fmtinfo_t *fmtinfo;\n\n\tfor (i = 0, fmtinfo = jas_image_fmtinfos; i < jas_image_numfmts; ++i, ++fmtinfo) {\n\t\tif (fmtinfo->id == id) {\n\t\t\treturn fmtinfo;\n\t\t}\n\t}\n\treturn 0;\n}\n\njas_image_fmtinfo_t *jas_image_lookupfmtbyname(const char *name)\n{\n\tint i;\n\tjas_image_fmtinfo_t *fmtinfo;\n\n\tfor (i = 0, fmtinfo = jas_image_fmtinfos; i < jas_image_numfmts; ++i, ++fmtinfo) {\n\t\tif (!strcmp(fmtinfo->name, name)) {\n\t\t\treturn fmtinfo;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n\n\n\nstatic uint_fast32_t inttobits(jas_seqent_t v, int prec, bool sgnd)\n{\n\tuint_fast32_t ret;\n\tret = ((sgnd && v < 0) ? ((1 << prec) + v) : v) & JAS_ONES(prec);\n\treturn ret;\n}\n\nstatic jas_seqent_t bitstoint(uint_fast32_t v, int prec, bool sgnd)\n{\n\tjas_seqent_t ret;\n\tv &= JAS_ONES(prec);\n\tret = (sgnd && (v & (1 << (prec - 1)))) ? (v - (1 << prec)) : v;\n\treturn ret;\n}\n\nstatic void jas_image_setbbox(jas_image_t *image)\n{\n\tjas_image_cmpt_t *cmpt;\n\tint cmptno;\n\tint_fast32_t x;\n\tint_fast32_t y;\n\n\tif (image->numcmpts_ > 0) {\n\t\t/* Determine the bounding box for all of the components on the\n\t\t  reference grid (i.e., the image area) */\n\t\tcmpt = image->cmpts_[0];\n\t\timage->tlx_ = cmpt->tlx_;\n\t\timage->tly_ = cmpt->tly_;\n\t\timage->brx_ = cmpt->tlx_ + cmpt->hstep_ * (cmpt->width_ - 1) + 1;\n\t\timage->bry_ = cmpt->tly_ + cmpt->vstep_ * (cmpt->height_ - 1) + 1;\n\t\tfor (cmptno = 1; cmptno < image->numcmpts_; ++cmptno) {\n\t\t\tcmpt = image->cmpts_[cmptno];\n\t\t\tif (image->tlx_ > cmpt->tlx_) {\n\t\t\t\timage->tlx_ = cmpt->tlx_;\n\t\t\t}\n\t\t\tif (image->tly_ > cmpt->tly_) {\n\t\t\t\timage->tly_ = cmpt->tly_;\n\t\t\t}\n\t\t\tx = cmpt->tlx_ + cmpt->hstep_ * (cmpt->width_ - 1) + 1;\n\t\t\tif (image->brx_ < x) {\n\t\t\t\timage->brx_ = x;\n\t\t\t}\n\t\t\ty = cmpt->tly_ + cmpt->vstep_ * (cmpt->height_ - 1) + 1;\n\t\t\tif (image->bry_ < y) {\n\t\t\t\timage->bry_ = y;\n\t\t\t}\n\t\t}\n\t} else {\n\t\timage->tlx_ = 0;\n\t\timage->tly_ = 0;\n\t\timage->brx_ = 0;\n\t\timage->bry_ = 0;\n\t}\n}\n\nstatic int jas_image_growcmpts(jas_image_t *image, int maxcmpts)\n{\n\tjas_image_cmpt_t **newcmpts;\n\tint cmptno;\n\n\tnewcmpts = (!image->cmpts_) ? jas_alloc2(maxcmpts,\n\t  sizeof(jas_image_cmpt_t *)) :\n\t  jas_realloc2(image->cmpts_, maxcmpts, sizeof(jas_image_cmpt_t *));\n\tif (!newcmpts) {\n\t\treturn -1;\n\t}\n\timage->cmpts_ = newcmpts;\n\timage->maxcmpts_ = maxcmpts;\n\tfor (cmptno = image->numcmpts_; cmptno < image->maxcmpts_; ++cmptno) {\n\t\timage->cmpts_[cmptno] = 0;\n\t}\n\treturn 0;\n}\n\nint jas_image_copycmpt(jas_image_t *dstimage, int dstcmptno,\n  jas_image_t *srcimage, int srccmptno)\n{\n\tjas_image_cmpt_t *newcmpt;\n\tif (dstimage->numcmpts_ >= dstimage->maxcmpts_) {\n\t\tif (jas_image_growcmpts(dstimage, dstimage->maxcmpts_ + 128)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (!(newcmpt = jas_image_cmpt_copy(srcimage->cmpts_[srccmptno]))) {\n\t\treturn -1;\n\t}\n\tif (dstcmptno < dstimage->numcmpts_) {\n\t\tmemmove(&dstimage->cmpts_[dstcmptno + 1], &dstimage->cmpts_[dstcmptno],\n\t\t  (dstimage->numcmpts_ - dstcmptno) * sizeof(jas_image_cmpt_t *));\n\t}\n\tdstimage->cmpts_[dstcmptno] = newcmpt;\n\t++dstimage->numcmpts_;\n\n\tjas_image_setbbox(dstimage);\n\treturn 0;\n}\n\nvoid jas_image_dump(jas_image_t *image, FILE *out)\n{\n\tlong buf[1024];\n\tint cmptno;\n\tint n;\n\tint i;\n\tint width;\n\tint height;\n\tjas_image_cmpt_t *cmpt;\n\tfor (cmptno = 0; cmptno < image->numcmpts_; ++cmptno) {\n\t\tcmpt = image->cmpts_[cmptno];\n\t\tfprintf(out, \"prec=%d, sgnd=%d, cmpttype=%\"PRIiFAST32\"\\n\", cmpt->prec_,\n\t\t  cmpt->sgnd_, cmpt->type_);\n\t\twidth = jas_image_cmptwidth(image, cmptno);\n\t\theight = jas_image_cmptheight(image, cmptno);\n\t\tn = JAS_MIN(16, width);\n\t\tif (jas_image_readcmpt2(image, cmptno, 0, 0, n, 1, buf)) {\n\t\t\tabort();\n\t\t}\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\tfprintf(out, \" f(%d,%d)=%ld\", i, 0, buf[i]);\n\t\t}\n\t\tfprintf(out, \"\\n\");\n\t\tif (jas_image_readcmpt2(image, cmptno, width - n, height - 1, n, 1, buf)) {\n\t\t\tabort();\n\t\t}\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\tfprintf(out, \" f(%d,%d)=%ld\", width - n + i, height - 1, buf[i]);\n\t\t}\n\t\tfprintf(out, \"\\n\");\n\t}\n}\n\nint jas_image_depalettize(jas_image_t *image, int cmptno, int numlutents,\n  int_fast32_t *lutents, int dtype, int newcmptno)\n{\n\tjas_image_cmptparm_t cmptparms;\n\tint_fast32_t v;\n\tint i;\n\tint j;\n\tjas_image_cmpt_t *cmpt;\n\n\tcmpt = image->cmpts_[cmptno];\n\tcmptparms.tlx = cmpt->tlx_;\n\tcmptparms.tly = cmpt->tly_;\n\tcmptparms.hstep = cmpt->hstep_;\n\tcmptparms.vstep = cmpt->vstep_;\n\tcmptparms.width = cmpt->width_;\n\tcmptparms.height = cmpt->height_;\n\tcmptparms.prec = JAS_IMAGE_CDT_GETPREC(dtype);\n\tcmptparms.sgnd = JAS_IMAGE_CDT_GETSGND(dtype);\n\n\tif (jas_image_addcmpt(image, newcmptno, &cmptparms)) {\n\t\treturn -1;\n\t}\n\tif (newcmptno <= cmptno) {\n\t\t++cmptno;\n\t\tcmpt = image->cmpts_[cmptno];\n\t}\n\n\tfor (j = 0; j < cmpt->height_; ++j) {\n\t\tfor (i = 0; i < cmpt->width_; ++i) {\n\t\t\tv = jas_image_readcmptsample(image, cmptno, i, j);\n\t\t\tif (v < 0) {\n\t\t\t\tv = 0;\n\t\t\t} else if (v >= numlutents) {\n\t\t\t\tv = numlutents - 1;\n\t\t\t}\n\t\t\tjas_image_writecmptsample(image, newcmptno, i, j,\n\t\t\t  lutents[v]);\n\t\t}\n\t}\n\treturn 0;\n}\n\nint jas_image_readcmptsample(jas_image_t *image, int cmptno, int x, int y)\n{\n\tjas_image_cmpt_t *cmpt;\n\tuint_fast32_t v;\n\tint k;\n\tint c;\n\n\tcmpt = image->cmpts_[cmptno];\n\n\tif (jas_stream_seek(cmpt->stream_, (cmpt->width_ * y + x) * cmpt->cps_,\n\t  SEEK_SET) < 0) {\n\t\treturn -1;\n\t}\n\tv = 0;\n\tfor (k = cmpt->cps_; k > 0; --k) {\n\t\tif ((c = jas_stream_getc(cmpt->stream_)) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\tv = (v << 8) | (c & 0xff);\n\t}\n\treturn bitstoint(v, cmpt->prec_, cmpt->sgnd_);\n}\n\nvoid jas_image_writecmptsample(jas_image_t *image, int cmptno, int x, int y,\n  int_fast32_t v)\n{\n\tjas_image_cmpt_t *cmpt;\n\tuint_fast32_t t;\n\tint k;\n\tint c;\n\n\tcmpt = image->cmpts_[cmptno];\n\n\tif (jas_stream_seek(cmpt->stream_, (cmpt->width_ * y + x) * cmpt->cps_,\n\t  SEEK_SET) < 0) {\n\t\treturn;\n\t}\n\tt = inttobits(v, cmpt->prec_, cmpt->sgnd_);\n\tfor (k = cmpt->cps_; k > 0; --k) {\n\t\tc = (t >> (8 * (cmpt->cps_ - 1))) & 0xff;\n\t\tif (jas_stream_putc(cmpt->stream_, (unsigned char) c) == EOF) {\n\t\t\treturn;\n\t\t}\n\t\tt <<= 8;\n\t}\n}\n\nint jas_image_getcmptbytype(jas_image_t *image, int ctype)\n{\n\tint cmptno;\n\n\tfor (cmptno = 0; cmptno < image->numcmpts_; ++cmptno) {\n\t\tif (image->cmpts_[cmptno]->type_ == ctype) {\n\t\t\treturn cmptno;\n\t\t}\n\t}\n\treturn -1;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/***********************************************/\n/***********************************************/\n/***********************************************/\n/***********************************************/\n\nint jas_image_readcmpt2(jas_image_t *image, int cmptno, jas_image_coord_t x,\n  jas_image_coord_t y, jas_image_coord_t width, jas_image_coord_t height,\n  long *buf)\n{\n\tjas_image_cmpt_t *cmpt;\n\tjas_image_coord_t i;\n\tjas_image_coord_t j;\n\tlong v;\n\tlong *bufptr;\n\n\tif (cmptno < 0 || cmptno >= image->numcmpts_)\n\t\tgoto error;\n\tcmpt = image->cmpts_[cmptno];\n\tif (x < 0 || x >= cmpt->width_ || y < 0 || y >= cmpt->height_ ||\n\t  width < 0 || height < 0 || x + width > cmpt->width_ ||\n\t  y + height > cmpt->height_)\n\t\tgoto error;\n\n\tbufptr = buf;\n\tfor (i = 0; i < height; ++i) {\n\t\tif (jas_stream_seek(cmpt->stream_, (cmpt->width_ * (y + i) + x)\n\t\t  * cmpt->cps_, SEEK_SET) < 0)\n\t\t\tgoto error;\n\t\tfor (j = 0; j < width; ++j) {\n\t\t\tif (getint(cmpt->stream_, cmpt->sgnd_, cmpt->prec_, &v))\n\t\t\t\tgoto error;\n\t\t\t*bufptr++ = v;\n\t\t}\n\t}\n\n\treturn 0;\nerror:\n\treturn -1;\n}\n\nint jas_image_writecmpt2(jas_image_t *image, int cmptno, jas_image_coord_t x,\n  jas_image_coord_t y, jas_image_coord_t width, jas_image_coord_t height,\n  long *buf)\n{\n\tjas_image_cmpt_t *cmpt;\n\tjas_image_coord_t i;\n\tjas_image_coord_t j;\n\tlong v;\n\tlong *bufptr;\n\n\tif (cmptno < 0 || cmptno >= image->numcmpts_)\n\t\tgoto error;\n\tcmpt = image->cmpts_[cmptno];\n\tif (x < 0 || x >= cmpt->width_ || y < 0 || y >= cmpt->height_ ||\n\t  width < 0 || height < 0 || x + width > cmpt->width_ ||\n\t  y + height > cmpt->height_)\n\t\tgoto error;\n\n\tbufptr = buf;\n\tfor (i = 0; i < height; ++i) {\n\t\tif (jas_stream_seek(cmpt->stream_, (cmpt->width_ * (y + i) + x)\n\t\t  * cmpt->cps_, SEEK_SET) < 0)\n\t\t\tgoto error;\n\t\tfor (j = 0; j < width; ++j) {\n\t\t\tv = *bufptr++;\n\t\t\tif (putint(cmpt->stream_, cmpt->sgnd_, cmpt->prec_, v))\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\n\treturn 0;\nerror:\n\treturn -1;\n}\n\nint jas_image_sampcmpt(jas_image_t *image, int cmptno, int newcmptno,\n  jas_image_coord_t ho, jas_image_coord_t vo, jas_image_coord_t hs,\n  jas_image_coord_t vs, int sgnd, int prec)\n{\n\tjas_image_cmpt_t *oldcmpt;\n\tjas_image_cmpt_t *newcmpt;\n\tint width;\n\tint height;\n\tjas_image_coord_t tlx;\n\tjas_image_coord_t tly;\n\tjas_image_coord_t brx;\n\tjas_image_coord_t bry;\n\tint i;\n\tint j;\n\tjas_image_cmptparm_t cmptparm;\n\tjas_image_coord_t ax;\n\tjas_image_coord_t ay;\n\tjas_image_coord_t bx;\n\tjas_image_coord_t by;\n\tjas_image_coord_t d0;\n\tjas_image_coord_t d1;\n\tjas_image_coord_t d2;\n\tjas_image_coord_t d3;\n\tjas_image_coord_t oldx;\n\tjas_image_coord_t oldy;\n\tjas_image_coord_t x;\n\tjas_image_coord_t y;\n\tlong v;\n\tjas_image_coord_t cmptbrx;\n\tjas_image_coord_t cmptbry;\n\n\tassert(cmptno >= 0 && cmptno < image->numcmpts_);\n\toldcmpt = image->cmpts_[cmptno];\n\tassert(oldcmpt->tlx_ == 0 && oldcmpt->tly_ == 0);\n\tjas_image_calcbbox2(image, &tlx, &tly, &brx, &bry);\n\twidth = FLOORDIV(brx - ho + hs, hs);\n\theight = FLOORDIV(bry - vo + vs, vs);\n\tcmptparm.tlx = ho;\n\tcmptparm.tly = vo;\n\tcmptparm.hstep = hs;\n\tcmptparm.vstep = vs;\n\tcmptparm.width = width;\n\tcmptparm.height = height;\n\tcmptparm.prec = prec;\n\tcmptparm.sgnd = sgnd;\n\tif (jas_image_addcmpt(image, newcmptno, &cmptparm))\n\t\tgoto error;\ncmptbrx = oldcmpt->tlx_ + (oldcmpt->width_ - 1) * oldcmpt->hstep_;\ncmptbry = oldcmpt->tly_ + (oldcmpt->height_ - 1) * oldcmpt->vstep_;\n\tnewcmpt = image->cmpts_[newcmptno];\n\tjas_stream_rewind(newcmpt->stream_);\n\tfor (i = 0; i < height; ++i) {\n\t\ty = newcmpt->tly_ + newcmpt->vstep_ * i;\n\t\tfor (j = 0; j < width; ++j) {\n\t\t\tx = newcmpt->tlx_ + newcmpt->hstep_ * j;\n\t\t\tax = downtomult(x - oldcmpt->tlx_, oldcmpt->hstep_) + oldcmpt->tlx_;\n\t\t\tay = downtomult(y - oldcmpt->tly_, oldcmpt->vstep_) + oldcmpt->tly_;\n\t\t\tbx = uptomult(x - oldcmpt->tlx_, oldcmpt->hstep_) + oldcmpt->tlx_;\n\t\t\tif (bx > cmptbrx)\n\t\t\t\tbx = cmptbrx;\n\t\t\tby = uptomult(y - oldcmpt->tly_, oldcmpt->vstep_) + oldcmpt->tly_;\n\t\t\tif (by > cmptbry)\n\t\t\t\tby = cmptbry;\n\t\t\td0 = (ax - x) * (ax - x) + (ay - y) * (ay - y);\n\t\t\td1 = (bx - x) * (bx - x) + (ay - y) * (ay - y);\n\t\t\td2 = (bx - x) * (bx - x) + (by - y) * (by - y);\n\t\t\td3 = (ax - x) * (ax - x) + (by - y) * (by - y);\n\t\t\tif (d0 <= d1 && d0 <= d2 && d0 <= d3) {\n\t\t\t\toldx = (ax - oldcmpt->tlx_) / oldcmpt->hstep_;\n\t\t\t\toldy = (ay - oldcmpt->tly_) / oldcmpt->vstep_;\n\t\t\t} else if (d1 <= d0 && d1 <= d2 && d1 <= d3) {\n\t\t\t\toldx = (bx - oldcmpt->tlx_) / oldcmpt->hstep_;\n\t\t\t\toldy = (ay - oldcmpt->tly_) / oldcmpt->vstep_;\n\t\t\t} else if (d2 <= d0 && d2 <= d1 && d1 <= d3) {\n\t\t\t\toldx = (bx - oldcmpt->tlx_) / oldcmpt->hstep_;\n\t\t\t\toldy = (by - oldcmpt->tly_) / oldcmpt->vstep_;\n\t\t\t} else {\n\t\t\t\toldx = (ax - oldcmpt->tlx_) / oldcmpt->hstep_;\n\t\t\t\toldy = (by - oldcmpt->tly_) / oldcmpt->vstep_;\n\t\t\t}\n\t\t\tassert(oldx >= 0 && oldx < oldcmpt->width_ &&\n\t\t\t  oldy >= 0 && oldy < oldcmpt->height_);\n\t\t\tif (jas_stream_seek(oldcmpt->stream_, oldcmpt->cps_ *\n\t\t\t  (oldy * oldcmpt->width_ + oldx), SEEK_SET) < 0)\n\t\t\t\tgoto error;\n\t\t\tif (getint(oldcmpt->stream_, oldcmpt->sgnd_,\n\t\t\t  oldcmpt->prec_, &v))\n\t\t\t\tgoto error;\n\t\t\tif (newcmpt->prec_ != oldcmpt->prec_ ||\n\t\t\t  newcmpt->sgnd_ != oldcmpt->sgnd_) {\n\t\t\t\tv = convert(v, oldcmpt->sgnd_, oldcmpt->prec_,\n\t\t\t\t  newcmpt->sgnd_, newcmpt->prec_);\n\t\t\t}\n\t\t\tif (putint(newcmpt->stream_, newcmpt->sgnd_,\n\t\t\t  newcmpt->prec_, v))\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\treturn 0;\nerror:\n\treturn -1;\n}\n\nint jas_image_ishomosamp(jas_image_t *image)\n{\n\tjas_image_coord_t hstep;\n\tjas_image_coord_t vstep;\n\tint result;\n\tint i;\n\thstep = jas_image_cmpthstep(image, 0);\n\tvstep = jas_image_cmptvstep(image, 0);\n\tresult = 1;\n\tfor (i = 0; i < image->numcmpts_; ++i) {\n\t\tif (jas_image_cmpthstep(image, i) != hstep ||\n\t\t  jas_image_cmptvstep(image, i) != vstep) {\n\t\t\tresult = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}\n\n/* Note: This function defines a bounding box differently. */\nstatic void jas_image_calcbbox2(jas_image_t *image, jas_image_coord_t *tlx,\n  jas_image_coord_t *tly, jas_image_coord_t *brx, jas_image_coord_t *bry)\n{\n\tjas_image_cmpt_t *cmpt;\n\tjas_image_coord_t tmptlx;\n\tjas_image_coord_t tmptly;\n\tjas_image_coord_t tmpbrx;\n\tjas_image_coord_t tmpbry;\n\tjas_image_coord_t t;\n\tint i;\n\tif (image->numcmpts_ > 0) {\n\t\tcmpt = image->cmpts_[0];\n\t\ttmptlx = cmpt->tlx_;\n\t\ttmptly = cmpt->tly_;\n\t\ttmpbrx = cmpt->tlx_ + cmpt->hstep_ * (cmpt->width_ - 1);\n\t\ttmpbry = cmpt->tly_ + cmpt->vstep_ * (cmpt->height_ - 1);\n\t\tfor (i = 0; i < image->numcmpts_; ++i) {\n\t\t\tcmpt = image->cmpts_[i];\n\t\t\tif (cmpt->tlx_ < tmptlx)\n\t\t\t\ttmptlx = cmpt->tlx_;\n\t\t\tif (cmpt->tly_ < tmptly)\n\t\t\t\ttmptly = cmpt->tly_;\n\t\t\tt = cmpt->tlx_ + cmpt->hstep_ * (cmpt->width_ - 1);\n\t\t\tif (t > tmpbrx)\n\t\t\t\ttmpbrx = t;\n\t\t\tt = cmpt->tly_ + cmpt->vstep_ * (cmpt->height_ - 1);\n\t\t\tif (t > tmpbry)\n\t\t\t\ttmpbry = t;\n\t\t}\n\t} else {\n\t\ttmptlx = 0;\n\t\ttmptly = 0;\n\t\ttmpbrx = -1;\n\t\ttmpbry = -1;\n\t}\n\t*tlx = tmptlx;\n\t*tly = tmptly;\n\t*brx = tmpbrx;\n\t*bry = tmpbry;\n}\n\nstatic inline long decode_twos_comp(ulong c, int prec)\n{\n\tlong result;\n\tassert(prec >= 2);\n\tjas_eprintf(\"warning: support for signed data is untested\\n\");\n\t// NOTE: Is this correct?\n\tresult = (c & ((1 << (prec - 1)) - 1)) - (c & (1 << (prec - 1)));\n\treturn result;\n}\n\nstatic inline ulong encode_twos_comp(long n, int prec)\n{\n\tulong result;\n\tassert(prec >= 2);\n\tjas_eprintf(\"warning: support for signed data is untested\\n\");\n\t// NOTE: Is this correct?\n\tif (n < 0) {\n\t\tresult = -n;\n\t\tresult = (result ^ 0xffffffffUL) + 1;\n\t\tresult &= (1 << prec) - 1;\n\t} else {\n\t\tresult = n;\n\t}\n\treturn result;\n}\n\nstatic int getint(jas_stream_t *in, int sgnd, int prec, long *val)\n{\n\tlong v;\n\tint n;\n\tint c;\n\tassert((!sgnd && prec >= 1) || (sgnd && prec >= 2));\n\tn = (prec + 7) / 8;\n\tv = 0;\n\twhile (--n >= 0) {\n\t\tif ((c = jas_stream_getc(in)) == EOF)\n\t\t\treturn -1;\n\t\tv = (v << 8) | c;\n\t}\n\tv &= ((1 << prec) - 1);\n\tif (sgnd) {\n\t\t*val = decode_twos_comp(v, prec);\n\t} else {\n\t\t*val = v;\n\t}\n\treturn 0;\n}\n\nstatic int putint(jas_stream_t *out, int sgnd, int prec, long val)\n{\n\tint n;\n\tint c;\n\tbool s;\n\tulong tmp;\n\tassert((!sgnd && prec >= 1) || (sgnd && prec >= 2));\n\tif (sgnd) {\n\t\tval = encode_twos_comp(val, prec);\n\t}\n\tassert(val >= 0);\n\tval &= (1 << prec) - 1;\n\tn = (prec + 7) / 8;\n\twhile (--n >= 0) {\n\t\tc = (val >> (n * 8)) & 0xff;\n\t\tif (jas_stream_putc(out, c) != c)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic long convert(long val, int oldsgnd, int oldprec, int newsgnd,\n  int newprec)\n{\n\tif (newsgnd != oldsgnd) {\n\t}\n\tif (newprec != oldprec) {\n\t\tif (newprec > oldprec) {\n\t\t\tval <<= newprec - oldprec;\n\t\t} else if (oldprec > newprec) {\n\t\t\tval >>= oldprec - newprec;\n\t\t}\n\t}\n\treturn val;\n}\n\nstatic long downtomult(long x, long y)\n{\n\tassert(x >= 0);\n\treturn (x / y) * y;\n}\n\nstatic long uptomult(long x, long y)\n{\n\tassert(x >= 0);\n\treturn ((x + y - 1) / y) * y;\n}\n\njas_image_t *jas_image_chclrspc(jas_image_t *image, jas_cmprof_t *outprof,\n  int intent)\n{\n\tjas_image_t *inimage;\n\tint minhstep;\n\tint minvstep;\n\tint i;\n\tint j;\n\tint k;\n\tint n;\n\tint hstep;\n\tint vstep;\n\tint numinauxchans;\n\tint numoutauxchans;\n\tint numinclrchans;\n\tint numoutclrchans;\n\tint prec;\n\tjas_image_t *outimage;\n\tint cmpttype;\n\tint numoutchans;\n\tjas_cmprof_t *inprof;\n\tjas_cmprof_t *tmpprof;\n\tjas_image_cmptparm_t cmptparm;\n\tint width;\n\tint height;\n\tjas_cmxform_t *xform;\n\tjas_cmpixmap_t inpixmap;\n\tjas_cmpixmap_t outpixmap;\n\tjas_cmcmptfmt_t *incmptfmts;\n\tjas_cmcmptfmt_t *outcmptfmts;\n\n#if 0\njas_eprintf(\"IMAGE\\n\");\njas_image_dump(image, stderr);\n#endif\n\n\toutimage = 0;\n\txform = 0;\n\tif (!(inimage = jas_image_copy(image)))\n\t\tgoto error;\n\timage = 0;\n\n\tif (!jas_image_ishomosamp(inimage)) {\n\t\tminhstep = jas_image_cmpthstep(inimage, 0);\n\t\tminvstep = jas_image_cmptvstep(inimage, 0);\n\t\tfor (i = 1; i < jas_image_numcmpts(inimage); ++i) {\n\t\t\thstep = jas_image_cmpthstep(inimage, i);\n\t\t\tvstep = jas_image_cmptvstep(inimage, i);\n\t\t\tif (hstep < minhstep) {\n\t\t\t\tminhstep = hstep;\n\t\t\t}\n\t\t\tif (vstep < minvstep) {\n\t\t\t\tminvstep = vstep;\n\t\t\t}\n\t\t}\n\t\tn = jas_image_numcmpts(inimage);\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\tcmpttype = jas_image_cmpttype(inimage, i);\n\t\t\tif (jas_image_sampcmpt(inimage, i, i + 1, 0, 0, minhstep, minvstep,\n\t\t\t  jas_image_cmptsgnd(inimage, i), jas_image_cmptprec(inimage, i))) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tjas_image_setcmpttype(inimage, i + 1, cmpttype);\n\t\t\tjas_image_delcmpt(inimage, i);\n\t\t}\n\t}\n\n\twidth = jas_image_cmptwidth(inimage, 0);\n\theight = jas_image_cmptheight(inimage, 0);\n\thstep = jas_image_cmpthstep(inimage, 0);\n\tvstep = jas_image_cmptvstep(inimage, 0);\n\n\tif (!(inprof = jas_image_cmprof(inimage))) {\n\t\tabort();\n\t}\n\tnuminclrchans = jas_clrspc_numchans(jas_cmprof_clrspc(inprof));\n\tnuminauxchans = jas_image_numcmpts(inimage) - numinclrchans;\n\tnumoutclrchans = jas_clrspc_numchans(jas_cmprof_clrspc(outprof));\n\tnumoutauxchans = 0;\n\tnumoutchans = numoutclrchans + numoutauxchans;\n\tprec = 8;\n\n\tif (!(outimage = jas_image_create0())) {\n\t\tgoto error;\n\t}\n\n\t/* Create a component for each of the colorants. */\n\tfor (i = 0; i < numoutclrchans; ++i) {\n\t\tcmptparm.tlx = 0;\n\t\tcmptparm.tly = 0;\n\t\tcmptparm.hstep = hstep;\n\t\tcmptparm.vstep = vstep;\n\t\tcmptparm.width = width;\n\t\tcmptparm.height = height;\n\t\tcmptparm.prec = prec;\n\t\tcmptparm.sgnd = 0;\n\t\tif (jas_image_addcmpt(outimage, -1, &cmptparm))\n\t\t\tgoto error;\n\t\tjas_image_setcmpttype(outimage, i, JAS_IMAGE_CT_COLOR(i));\n\t}\n#if 0\n\t/* Copy the auxiliary components without modification. */\n\tfor (i = 0; i < jas_image_numcmpts(inimage); ++i) {\n\t\tif (!ISCOLOR(jas_image_cmpttype(inimage, i))) {\n\t\t\tjas_image_copycmpt(outimage, -1, inimage, i);\n/* XXX - need to specify laydown of component on ref. grid */\n\t\t}\n\t}\n#endif\n\n\tif (!(tmpprof = jas_cmprof_copy(outprof)))\n\t\tgoto error;\n\tassert(!jas_image_cmprof(outimage));\n\tjas_image_setcmprof(outimage, tmpprof);\n\ttmpprof = 0;\n\tjas_image_setclrspc(outimage, jas_cmprof_clrspc(outprof));\n\n\tif (!(xform = jas_cmxform_create(inprof, outprof, 0, JAS_CMXFORM_OP_FWD,\n\t  intent, 0))) {\n\t\tgoto error;\n\t}\n\n\tinpixmap.numcmpts = numinclrchans;\n\tif (!(incmptfmts = jas_alloc2(numinclrchans, sizeof(jas_cmcmptfmt_t)))) {\n\t\tabort();\n\t}\n\tinpixmap.cmptfmts = incmptfmts;\n\tfor (i = 0; i < numinclrchans; ++i) {\n\t\tj = jas_image_getcmptbytype(inimage, JAS_IMAGE_CT_COLOR(i));\n\t\tassert(j >= 0);\n\t\tif (!(incmptfmts[i].buf = jas_alloc2(width, sizeof(long)))) {\n\t\t\tgoto error;\n\t\t}\n\t\tincmptfmts[i].prec = jas_image_cmptprec(inimage, j);\n\t\tincmptfmts[i].sgnd = jas_image_cmptsgnd(inimage, j);\n\t\tincmptfmts[i].width = width;\n\t\tincmptfmts[i].height = 1;\n\t}\n\n\toutpixmap.numcmpts = numoutclrchans;\n\tif (!(outcmptfmts = jas_alloc2(numoutclrchans, sizeof(jas_cmcmptfmt_t)))) {\n\t\tabort();\n\t}\n\toutpixmap.cmptfmts = outcmptfmts;\n\n\tfor (i = 0; i < numoutclrchans; ++i) {\n\t\tj = jas_image_getcmptbytype(outimage, JAS_IMAGE_CT_COLOR(i));\n\t\tassert(j >= 0);\n\t\tif (!(outcmptfmts[i].buf = jas_alloc2(width, sizeof(long))))\n\t\t\tgoto error;\n\t\toutcmptfmts[i].prec = jas_image_cmptprec(outimage, j);\n\t\toutcmptfmts[i].sgnd = jas_image_cmptsgnd(outimage, j);\n\t\toutcmptfmts[i].width = width;\n\t\toutcmptfmts[i].height = 1;\n\t}\n\n\tfor (i = 0; i < height; ++i) {\n\t\tfor (j = 0; j < numinclrchans; ++j) {\n\t\t\tk = jas_image_getcmptbytype(inimage, JAS_IMAGE_CT_COLOR(j));\n\t\t\tif (jas_image_readcmpt2(inimage, k, 0, i, width, 1,\n\t\t\t  incmptfmts[j].buf))\n\t\t\t\tgoto error;\n\t\t}\n\t\tjas_cmxform_apply(xform, &inpixmap, &outpixmap);\n\t\tfor (j = 0; j < numoutclrchans; ++j) {\n\t\t\tk = jas_image_getcmptbytype(outimage, JAS_IMAGE_CT_COLOR(j));\n\t\t\tif (jas_image_writecmpt2(outimage, k, 0, i, width, 1,\n\t\t\t  outcmptfmts[j].buf))\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\n\tfor (i = 0; i < numoutclrchans; ++i) {\n\t\tjas_free(outcmptfmts[i].buf);\n\t}\n\tjas_free(outcmptfmts);\n\tfor (i = 0; i < numinclrchans; ++i) {\n\t\tjas_free(incmptfmts[i].buf);\n\t}\n\tjas_free(incmptfmts);\n\tjas_cmxform_destroy(xform);\n\tjas_image_destroy(inimage);\n\n#if 0\njas_eprintf(\"INIMAGE\\n\");\njas_image_dump(inimage, stderr);\njas_eprintf(\"OUTIMAGE\\n\");\njas_image_dump(outimage, stderr);\n#endif\n\treturn outimage;\nerror:\n\tif (xform)\n\t\tjas_cmxform_destroy(xform);\n\tif (inimage)\n\t\tjas_image_destroy(inimage);\n\tif (outimage)\n\t\tjas_image_destroy(outimage);\n\treturn 0;\n}\n", "/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2003 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * Image Class\n *\n * $Id$\n */\n\n#ifndef JAS_IMAGE_H\n#define JAS_IMAGE_H\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <jasper/jas_config.h>\n#include <jasper/jas_stream.h>\n#include <jasper/jas_seq.h>\n#include <jasper/jas_cm.h>\n#include <stdio.h>\n#include <stdbool.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/******************************************************************************\\\n* Constants.\n\\******************************************************************************/\n\n/*\n * Miscellaneous constants.\n */\n\n/* The threshold at which image data is no longer stored in memory. */\n#define JAS_IMAGE_INMEMTHRESH\t(16 * 1024 * 1024)\n\n/*\n * Component types\n */\n\n#define\tJAS_IMAGE_CT_UNKNOWN\t0x10000\n#define\tJAS_IMAGE_CT_COLOR(n)\t((n) & 0x7fff)\n#define\tJAS_IMAGE_CT_OPACITY\t0x08000\n\n#define\tJAS_IMAGE_CT_RGB_R\t0\n#define\tJAS_IMAGE_CT_RGB_G\t1\n#define\tJAS_IMAGE_CT_RGB_B\t2\n\n#define\tJAS_IMAGE_CT_YCBCR_Y\t0\n#define\tJAS_IMAGE_CT_YCBCR_CB\t1\n#define\tJAS_IMAGE_CT_YCBCR_CR\t2\n\n#define\tJAS_IMAGE_CT_GRAY_Y\t0\n\n/******************************************************************************\\\n* Simple types.\n\\******************************************************************************/\n\n/* Image coordinate. */\ntypedef int_fast32_t jas_image_coord_t;\n\n/* Color space (e.g., RGB, YCbCr). */\ntypedef int_fast16_t jas_image_colorspc_t;\n\n/* Component type (e.g., color, opacity). */\ntypedef int_fast32_t jas_image_cmpttype_t;\n\n/* Component sample data format (e.g., real/integer, signedness, precision). */\ntypedef int_fast16_t jas_image_smpltype_t;\n\n/******************************************************************************\\\n* Image class and supporting classes.\n\\******************************************************************************/\n\n/* Image component class. */\n\ntypedef struct {\n\n\tjas_image_coord_t tlx_;\n\t/* The x-coordinate of the top-left corner of the component. */\n\n\tjas_image_coord_t tly_;\n\t/* The y-coordinate of the top-left corner of the component. */\n\n\tjas_image_coord_t hstep_;\n\t/* The horizontal sampling period in units of the reference grid. */\n\n\tjas_image_coord_t vstep_;\n\t/* The vertical sampling period in units of the reference grid. */\n\n\tjas_image_coord_t width_;\n\t/* The component width in samples. */\n\n\tjas_image_coord_t height_;\n\t/* The component height in samples. */\n\n#ifdef FIX_ME\n\tint smpltype_;\n#else\n\tint prec_;\n\t/* The precision of the sample data (i.e., the number of bits per\n\tsample).  If the samples are signed values, this quantity\n\tincludes the sign bit. */\n\n\tint sgnd_;\n\t/* The signedness of the sample data. */\n#endif\n\n\tjas_stream_t *stream_;\n\t/* The stream containing the component data. */\n\n\tint cps_;\n\t/* The number of characters per sample in the stream. */\n\n\tjas_image_cmpttype_t type_;\n\t/* The type of component (e.g., opacity, red, green, blue, luma). */\n\n} jas_image_cmpt_t;\n\n/* Image class. */\n\ntypedef struct {\n\n\tjas_image_coord_t tlx_;\n\t/* The x-coordinate of the top-left corner of the image bounding box. */\n\n\tjas_image_coord_t tly_;\n\t/* The y-coordinate of the top-left corner of the image bounding box. */\n\n\tjas_image_coord_t brx_;\n\t/* The x-coordinate of the bottom-right corner of the image bounding\n\t  box (plus one). */\n\n\tjas_image_coord_t bry_;\n\t/* The y-coordinate of the bottom-right corner of the image bounding\n\t  box (plus one). */\n\n\tint numcmpts_;\n\t/* The number of components. */\n\n\tint maxcmpts_;\n\t/* The maximum number of components that this image can have (i.e., the\n\t  allocated size of the components array). */\n\n\tjas_image_cmpt_t **cmpts_;\n\t/* Per-component information. */\n\n\tjas_clrspc_t clrspc_;\n\n\tjas_cmprof_t *cmprof_;\n\n\tbool inmem_;\n\n} jas_image_t;\n\n/* Component parameters class. */\n/* This data type exists solely/mainly for the purposes of the\n  jas_image_create function. */\n\ntypedef struct {\n\n\tjas_image_coord_t tlx;\n\t/* The x-coordinate of the top-left corner of the component. */\n\n\tjas_image_coord_t tly;\n\t/* The y-coordinate of the top-left corner of the component. */\n\n\tjas_image_coord_t hstep;\n\t/* The horizontal sampling period in units of the reference grid. */\n\n\tjas_image_coord_t vstep;\n\t/* The vertical sampling period in units of the reference grid. */\n\n\tjas_image_coord_t width;\n\t/* The width of the component in samples. */\n\n\tjas_image_coord_t height;\n\t/* The height of the component in samples. */\n\n#ifdef FIX_ME\n\tint smpltype;\n#else\n\tint prec;\n\t/* The precision of the component sample data. */\n\n\tint sgnd;\n\t/* The signedness of the component sample data. */\n#endif\n\n} jas_image_cmptparm_t;\n\n/******************************************************************************\\\n* File format related classes.\n\\******************************************************************************/\n\n#define\tJAS_IMAGE_MAXFMTS\t32\n/* The maximum number of image data formats supported. */\n\n/* Image format-dependent operations. */\n\ntypedef struct {\n\n\tjas_image_t *(*decode)(jas_stream_t *in, char *opts);\n\t/* Decode image data from a stream. */\n\n\tint (*encode)(jas_image_t *image, jas_stream_t *out, char *opts);\n\t/* Encode image data to a stream. */\n\n\tint (*validate)(jas_stream_t *in);\n\t/* Determine if stream data is in a particular format. */\n\n} jas_image_fmtops_t;\n\n/* Image format information. */\n\ntypedef struct {\n\n\tint id;\n\t/* The ID for this format. */\n\n\tchar *name;\n\t/* The name by which this format is identified. */\n\n\tchar *ext;\n\t/* The file name extension associated with this format. */\n\n\tchar *desc;\n\t/* A brief description of the format. */\n\n\tjas_image_fmtops_t ops;\n\t/* The operations for this format. */\n\n} jas_image_fmtinfo_t;\n\n/******************************************************************************\\\n* Image operations.\n\\******************************************************************************/\n\n/* Create an image. */\njas_image_t *jas_image_create(int numcmpts,\n  jas_image_cmptparm_t *cmptparms, jas_clrspc_t clrspc);\n\n/* Create an \"empty\" image. */\njas_image_t *jas_image_create0(void);\n\n/* Clone an image. */\njas_image_t *jas_image_copy(jas_image_t *image);\n\n/* Deallocate any resources associated with an image. */\nvoid jas_image_destroy(jas_image_t *image);\n\n/* Get the width of the image in units of the image reference grid. */\n#define jas_image_width(image) \\\n\t((image)->brx_ - (image)->tlx_)\n\n/* Get the height of the image in units of the image reference grid. */\n#define\tjas_image_height(image) \\\n\t((image)->bry_ - (image)->tly_)\n\n/* Get the x-coordinate of the top-left corner of the image bounding box\n  on the reference grid. */\n#define jas_image_tlx(image) \\\n\t((image)->tlx_)\n\n/* Get the y-coordinate of the top-left corner of the image bounding box\n  on the reference grid. */\n#define jas_image_tly(image) \\\n\t((image)->tly_)\n\n/* Get the x-coordinate of the bottom-right corner of the image bounding box\n  on the reference grid (plus one). */\n#define jas_image_brx(image) \\\n\t((image)->brx_)\n\n/* Get the y-coordinate of the bottom-right corner of the image bounding box\n  on the reference grid (plus one). */\n#define jas_image_bry(image) \\\n\t((image)->bry_)\n\n/* Get the number of image components. */\n#define\tjas_image_numcmpts(image) \\\n\t((image)->numcmpts_)\n\n/* Get the color model used by the image. */\n#define\tjas_image_clrspc(image) \\\n\t((image)->clrspc_)\n\n/* Set the color model for an image. */\n#define jas_image_setclrspc(image, clrspc) \\\n\t((image)->clrspc_ = (clrspc))\n\n#define jas_image_cmpttype(image, cmptno) \\\n\t((image)->cmpts_[(cmptno)]->type_)\n#define jas_image_setcmpttype(image, cmptno, type) \\\n\t((image)->cmpts_[(cmptno)]->type_ = (type))\n\n/* Get the width of a component. */\n#define\tjas_image_cmptwidth(image, cmptno) \\\n\t((image)->cmpts_[cmptno]->width_)\n\n/* Get the height of a component. */\n#define\tjas_image_cmptheight(image, cmptno) \\\n\t((image)->cmpts_[cmptno]->height_)\n\n/* Get the signedness of the sample data for a component. */\n#define\tjas_image_cmptsgnd(image, cmptno) \\\n\t((image)->cmpts_[cmptno]->sgnd_)\n\n/* Get the precision of the sample data for a component. */\n#define\tjas_image_cmptprec(image, cmptno) \\\n\t((image)->cmpts_[cmptno]->prec_)\n\n/* Get the horizontal subsampling factor for a component. */\n#define\tjas_image_cmpthstep(image, cmptno) \\\n\t((image)->cmpts_[cmptno]->hstep_)\n\n/* Get the vertical subsampling factor for a component. */\n#define\tjas_image_cmptvstep(image, cmptno) \\\n\t((image)->cmpts_[cmptno]->vstep_)\n\n/* Get the x-coordinate of the top-left corner of a component. */\n#define\tjas_image_cmpttlx(image, cmptno) \\\n\t((image)->cmpts_[cmptno]->tlx_)\n\n/* Get the y-coordinate of the top-left corner of a component. */\n#define\tjas_image_cmpttly(image, cmptno) \\\n\t((image)->cmpts_[cmptno]->tly_)\n\n/* Get the x-coordinate of the bottom-right corner of a component\n  (plus \"one\"). */\n#define\tjas_image_cmptbrx(image, cmptno) \\\n\t((image)->cmpts_[cmptno]->tlx_ + (image)->cmpts_[cmptno]->width_ * \\\n\t  (image)->cmpts_[cmptno]->hstep_)\n\n/* Get the y-coordinate of the bottom-right corner of a component\n  (plus \"one\"). */\n#define\tjas_image_cmptbry(image, cmptno) \\\n\t((image)->cmpts_[cmptno]->tly_ + (image)->cmpts_[cmptno]->height_ * \\\n\t  (image)->cmpts_[cmptno]->vstep_)\n\n// Test if all components are specified at the same positions in space. */\nbool jas_image_cmpt_domains_same(jas_image_t *image);\n\n/* Get the raw size of an image (i.e., the nominal size of the image without\n  any compression. */\nuint_fast32_t jas_image_rawsize(jas_image_t *image);\n\n/* Create an image from a stream in some specified format. */\njas_image_t *jas_image_decode(jas_stream_t *in, int fmt, char *optstr);\n\n/* Write an image to a stream in a specified format. */\nint jas_image_encode(jas_image_t *image, jas_stream_t *out, int fmt,\n  char *optstr);\n\n/* Read a rectangular region of an image component. */\n/* The position and size of the rectangular region to be read is specified\nrelative to the component's coordinate system. */\nint jas_image_readcmpt(jas_image_t *image, int cmptno,\n  jas_image_coord_t x, jas_image_coord_t y, jas_image_coord_t width, jas_image_coord_t height,\n  jas_matrix_t *data);\n\n/* Write a rectangular region of an image component. */\nint jas_image_writecmpt(jas_image_t *image, int cmptno,\n  jas_image_coord_t x, jas_image_coord_t y, jas_image_coord_t width, jas_image_coord_t height,\n  jas_matrix_t *data);\n\n/* Delete a component from an image. */\nvoid jas_image_delcmpt(jas_image_t *image, int cmptno);\n\n/* Add a component to an image. */\nint jas_image_addcmpt(jas_image_t *image, int cmptno,\n  jas_image_cmptparm_t *cmptparm);\n\n/* Copy a component from one image to another. */\nint jas_image_copycmpt(jas_image_t *dstimage, int dstcmptno,\n  jas_image_t *srcimage, int srccmptno);\n\n#define\tJAS_IMAGE_CDT_GETSGND(dtype) (((dtype) >> 7) & 1)\n#define\tJAS_IMAGE_CDT_SETSGND(dtype) (((dtype) & 1) << 7)\n#define\tJAS_IMAGE_CDT_GETPREC(dtype) ((dtype) & 0x7f)\n#define\tJAS_IMAGE_CDT_SETPREC(dtype) ((dtype) & 0x7f)\n\n#define\tjas_image_cmptdtype(image, cmptno) \\\n\t(JAS_IMAGE_CDT_SETSGND((image)->cmpts_[cmptno]->sgnd_) | JAS_IMAGE_CDT_SETPREC((image)->cmpts_[cmptno]->prec_))\n\nint jas_image_depalettize(jas_image_t *image, int cmptno, int numlutents,\n  int_fast32_t *lutents, int dtype, int newcmptno);\n\nint jas_image_readcmptsample(jas_image_t *image, int cmptno, int x, int y);\nvoid jas_image_writecmptsample(jas_image_t *image, int cmptno, int x, int y,\n  int_fast32_t v);\n\nint jas_image_getcmptbytype(jas_image_t *image, int ctype);\n\n/******************************************************************************\\\n* Image format-related operations.\n\\******************************************************************************/\n\n/* Clear the table of image formats. */\nvoid jas_image_clearfmts(void);\n\n/* Add entry to table of image formats. */\nint jas_image_addfmt(int id, char *name, char *ext, char *desc,\n  jas_image_fmtops_t *ops);\n\n/* Get the ID for the image format with the specified name. */\nint jas_image_strtofmt(char *s);\n\n/* Get the name of the image format with the specified ID. */\nchar *jas_image_fmttostr(int fmt);\n\n/* Lookup image format information by the format ID. */\njas_image_fmtinfo_t *jas_image_lookupfmtbyid(int id);\n\n/* Lookup image format information by the format name. */\njas_image_fmtinfo_t *jas_image_lookupfmtbyname(const char *name);\n\n/* Guess the format of an image file based on its name. */\nint jas_image_fmtfromname(char *filename);\n\n/* Get the format of image data in a stream. */\nint jas_image_getfmt(jas_stream_t *in);\n\n\n#define\tjas_image_cmprof(image)\t((image)->cmprof_)\nint jas_image_ishomosamp(jas_image_t *image);\nint jas_image_sampcmpt(jas_image_t *image, int cmptno, int newcmptno,\n  jas_image_coord_t ho, jas_image_coord_t vo, jas_image_coord_t hs,\n  jas_image_coord_t vs, int sgnd, int prec);\nint jas_image_writecmpt2(jas_image_t *image, int cmptno, jas_image_coord_t x,\n  jas_image_coord_t y, jas_image_coord_t width, jas_image_coord_t height,\n  long *buf);\nint jas_image_readcmpt2(jas_image_t *image, int cmptno, jas_image_coord_t x,\n  jas_image_coord_t y, jas_image_coord_t width, jas_image_coord_t height,\n  long *buf);\n\n#define\tjas_image_setcmprof(image, cmprof) ((image)->cmprof_ = cmprof)\njas_image_t *jas_image_chclrspc(jas_image_t *image, jas_cmprof_t *outprof,\n  int intent);\nvoid jas_image_dump(jas_image_t *image, FILE *out);\n\n/******************************************************************************\\\n* Image format-dependent operations.\n\\******************************************************************************/\n\n#if !defined(EXCLUDE_JPG_SUPPORT)\n/* Format-dependent operations for JPG support. */\njas_image_t *jpg_decode(jas_stream_t *in, char *optstr);\nint jpg_encode(jas_image_t *image, jas_stream_t *out, char *optstr);\nint jpg_validate(jas_stream_t *in);\n#endif\n\n#if !defined(EXCLUDE_MIF_SUPPORT)\n/* Format-dependent operations for MIF support. */\njas_image_t *mif_decode(jas_stream_t *in, char *optstr);\nint mif_encode(jas_image_t *image, jas_stream_t *out, char *optstr);\nint mif_validate(jas_stream_t *in);\n#endif\n\n#if !defined(EXCLUDE_PNM_SUPPORT)\n/* Format-dependent operations for PNM support. */\njas_image_t *pnm_decode(jas_stream_t *in, char *optstr);\nint pnm_encode(jas_image_t *image, jas_stream_t *out, char *optstr);\nint pnm_validate(jas_stream_t *in);\n#endif\n\n#if !defined(EXCLUDE_RAS_SUPPORT)\n/* Format-dependent operations for Sun Rasterfile support. */\njas_image_t *ras_decode(jas_stream_t *in, char *optstr);\nint ras_encode(jas_image_t *image, jas_stream_t *out, char *optstr);\nint ras_validate(jas_stream_t *in);\n#endif\n\n#if !defined(EXCLUDE_BMP_SUPPORT)\n/* Format-dependent operations for BMP support. */\njas_image_t *bmp_decode(jas_stream_t *in, char *optstr);\nint bmp_encode(jas_image_t *image, jas_stream_t *out, char *optstr);\nint bmp_validate(jas_stream_t *in);\n#endif\n\n#if !defined(EXCLUDE_JP2_SUPPORT)\n/* Format-dependent operations for JP2 support. */\njas_image_t *jp2_decode(jas_stream_t *in, char *optstr);\nint jp2_encode(jas_image_t *image, jas_stream_t *out, char *optstr);\nint jp2_validate(jas_stream_t *in);\n#endif\n\n#if !defined(EXCLUDE_JPC_SUPPORT)\n/* Format-dependent operations for JPEG-2000 code stream support. */\njas_image_t *jpc_decode(jas_stream_t *in, char *optstr);\nint jpc_encode(jas_image_t *image, jas_stream_t *out, char *optstr);\nint jpc_validate(jas_stream_t *in);\n#endif\n\n#if !defined(EXCLUDE_PGX_SUPPORT)\n/* Format-dependent operations for PGX support. */\njas_image_t *pgx_decode(jas_stream_t *in, char *optstr);\nint pgx_encode(jas_image_t *image, jas_stream_t *out, char *optstr);\nint pgx_validate(jas_stream_t *in);\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n", "/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2003 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * $Id$\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <inttypes.h>\n\n#include \"jasper/jas_types.h\"\n#include \"jasper/jas_math.h\"\n#include \"jasper/jas_tvp.h\"\n#include \"jasper/jas_malloc.h\"\n#include \"jasper/jas_debug.h\"\n\n#include \"jpc_fix.h\"\n#include \"jpc_dec.h\"\n#include \"jpc_cs.h\"\n#include \"jpc_mct.h\"\n#include \"jpc_t2dec.h\"\n#include \"jpc_t1dec.h\"\n#include \"jpc_math.h\"\n\n/******************************************************************************\\\n*\n\\******************************************************************************/\n\n#define\tJPC_MHSOC\t0x0001\n  /* In the main header, expecting a SOC marker segment. */\n#define\tJPC_MHSIZ\t0x0002\n  /* In the main header, expecting a SIZ marker segment. */\n#define\tJPC_MH\t\t0x0004\n  /* In the main header, expecting \"other\" marker segments. */\n#define\tJPC_TPHSOT\t0x0008\n  /* In a tile-part header, expecting a SOT marker segment. */\n#define\tJPC_TPH\t\t0x0010\n  /* In a tile-part header, expecting \"other\" marker segments. */\n#define\tJPC_MT\t\t0x0020\n  /* In the main trailer. */\n\ntypedef struct {\n\n\tuint_fast16_t id;\n\t/* The marker segment type. */\n\n\tint validstates;\n\t/* The states in which this type of marker segment can be\n\t  validly encountered. */\n\n\tint (*action)(jpc_dec_t *dec, jpc_ms_t *ms);\n\t/* The action to take upon encountering this type of marker segment. */\n\n} jpc_dec_mstabent_t;\n\n/******************************************************************************\\\n*\n\\******************************************************************************/\n\n/* COD/COC parameters have been specified. */\n#define\tJPC_CSET\t0x0001\n/* QCD/QCC parameters have been specified. */\n#define\tJPC_QSET\t0x0002\n/* COD/COC parameters set from a COC marker segment. */\n#define\tJPC_COC\t0x0004\n/* QCD/QCC parameters set from a QCC marker segment. */\n#define\tJPC_QCC\t0x0008\n\n/******************************************************************************\\\n* Local function prototypes.\n\\******************************************************************************/\n\nstatic int jpc_dec_dump(jpc_dec_t *dec, FILE *out);\n\njpc_ppxstab_t *jpc_ppxstab_create(void);\nvoid jpc_ppxstab_destroy(jpc_ppxstab_t *tab);\nint jpc_ppxstab_grow(jpc_ppxstab_t *tab, int maxents);\nint jpc_ppxstab_insert(jpc_ppxstab_t *tab, jpc_ppxstabent_t *ent);\njpc_streamlist_t *jpc_ppmstabtostreams(jpc_ppxstab_t *tab);\nint jpc_pptstabwrite(jas_stream_t *out, jpc_ppxstab_t *tab);\njpc_ppxstabent_t *jpc_ppxstabent_create(void);\nvoid jpc_ppxstabent_destroy(jpc_ppxstabent_t *ent);\n\nint jpc_streamlist_numstreams(jpc_streamlist_t *streamlist);\njpc_streamlist_t *jpc_streamlist_create(void);\nint jpc_streamlist_insert(jpc_streamlist_t *streamlist, int streamno,\n  jas_stream_t *stream);\njas_stream_t *jpc_streamlist_remove(jpc_streamlist_t *streamlist, int streamno);\nvoid jpc_streamlist_destroy(jpc_streamlist_t *streamlist);\njas_stream_t *jpc_streamlist_get(jpc_streamlist_t *streamlist, int streamno);\n\nstatic void jpc_dec_cp_resetflags(jpc_dec_cp_t *cp);\nstatic jpc_dec_cp_t *jpc_dec_cp_create(uint_fast16_t numcomps);\nstatic int jpc_dec_cp_isvalid(jpc_dec_cp_t *cp);\nstatic jpc_dec_cp_t *jpc_dec_cp_copy(jpc_dec_cp_t *cp);\nstatic int jpc_dec_cp_setfromcod(jpc_dec_cp_t *cp, jpc_cod_t *cod);\nstatic int jpc_dec_cp_setfromcoc(jpc_dec_cp_t *cp, jpc_coc_t *coc);\nstatic int jpc_dec_cp_setfromcox(jpc_dec_cp_t *cp, jpc_dec_ccp_t *ccp,\n  jpc_coxcp_t *compparms, int flags);\nstatic int jpc_dec_cp_setfromqcd(jpc_dec_cp_t *cp, jpc_qcd_t *qcd);\nstatic int jpc_dec_cp_setfromqcc(jpc_dec_cp_t *cp, jpc_qcc_t *qcc);\nstatic int jpc_dec_cp_setfromqcx(jpc_dec_cp_t *cp, jpc_dec_ccp_t *ccp,\n  jpc_qcxcp_t *compparms, int flags);\nstatic int jpc_dec_cp_setfromrgn(jpc_dec_cp_t *cp, jpc_rgn_t *rgn);\nstatic int jpc_dec_cp_prepare(jpc_dec_cp_t *cp);\nstatic void jpc_dec_cp_destroy(jpc_dec_cp_t *cp);\nstatic int jpc_dec_cp_setfrompoc(jpc_dec_cp_t *cp, jpc_poc_t *poc, int reset);\nstatic int jpc_pi_addpchgfrompoc(jpc_pi_t *pi, jpc_poc_t *poc);\n\nstatic int jpc_dec_decode(jpc_dec_t *dec);\nstatic jpc_dec_t *jpc_dec_create(jpc_dec_importopts_t *impopts, jas_stream_t *in);\nstatic void jpc_dec_destroy(jpc_dec_t *dec);\nstatic void jpc_dequantize(jas_matrix_t *x, jpc_fix_t absstepsize);\nstatic void jpc_undo_roi(jas_matrix_t *x, int roishift, int bgshift, int numbps);\nstatic jpc_fix_t jpc_calcabsstepsize(int stepsize, int numbits);\nstatic int jpc_dec_tiledecode(jpc_dec_t *dec, jpc_dec_tile_t *tile);\nstatic int jpc_dec_tileinit(jpc_dec_t *dec, jpc_dec_tile_t *tile);\nstatic int jpc_dec_tilefini(jpc_dec_t *dec, jpc_dec_tile_t *tile);\nstatic int jpc_dec_process_soc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_sot(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_sod(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_eoc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_cod(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_coc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_rgn(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_qcd(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_qcc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_poc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_ppm(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_ppt(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_com(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_unk(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_crg(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_parseopts(char *optstr, jpc_dec_importopts_t *opts);\n\nstatic jpc_dec_mstabent_t *jpc_dec_mstab_lookup(uint_fast16_t id);\n\n/******************************************************************************\\\n* Global data.\n\\******************************************************************************/\n\njpc_dec_mstabent_t jpc_dec_mstab[] = {\n\t{JPC_MS_SOC, JPC_MHSOC, jpc_dec_process_soc},\n\t{JPC_MS_SOT, JPC_MH | JPC_TPHSOT, jpc_dec_process_sot},\n\t{JPC_MS_SOD, JPC_TPH, jpc_dec_process_sod},\n\t{JPC_MS_EOC, JPC_TPHSOT, jpc_dec_process_eoc},\n\t{JPC_MS_SIZ, JPC_MHSIZ, jpc_dec_process_siz},\n\t{JPC_MS_COD, JPC_MH | JPC_TPH, jpc_dec_process_cod},\n\t{JPC_MS_COC, JPC_MH | JPC_TPH, jpc_dec_process_coc},\n\t{JPC_MS_RGN, JPC_MH | JPC_TPH, jpc_dec_process_rgn},\n\t{JPC_MS_QCD, JPC_MH | JPC_TPH, jpc_dec_process_qcd},\n\t{JPC_MS_QCC, JPC_MH | JPC_TPH, jpc_dec_process_qcc},\n\t{JPC_MS_POC, JPC_MH | JPC_TPH, jpc_dec_process_poc},\n\t{JPC_MS_TLM, JPC_MH, 0},\n\t{JPC_MS_PLM, JPC_MH, 0},\n\t{JPC_MS_PLT, JPC_TPH, 0},\n\t{JPC_MS_PPM, JPC_MH, jpc_dec_process_ppm},\n\t{JPC_MS_PPT, JPC_TPH, jpc_dec_process_ppt},\n\t{JPC_MS_SOP, 0, 0},\n\t{JPC_MS_CRG, JPC_MH, jpc_dec_process_crg},\n\t{JPC_MS_COM, JPC_MH | JPC_TPH, jpc_dec_process_com},\n\t{0, JPC_MH | JPC_TPH, jpc_dec_process_unk}\n};\n\n/******************************************************************************\\\n* The main entry point for the JPEG-2000 decoder.\n\\******************************************************************************/\n\njas_image_t *jpc_decode(jas_stream_t *in, char *optstr)\n{\n\tjpc_dec_importopts_t opts;\n\tjpc_dec_t *dec;\n\tjas_image_t *image;\n\n\tdec = 0;\n\n\tif (jpc_dec_parseopts(optstr, &opts)) {\n\t\tgoto error;\n\t}\n\n\tjpc_initluts();\n\n\tif (!(dec = jpc_dec_create(&opts, in))) {\n\t\tgoto error;\n\t}\n\n\t/* Do most of the work. */\n\tif (jpc_dec_decode(dec)) {\n\t\tgoto error;\n\t}\n\n\tif (jas_image_numcmpts(dec->image) >= 3) {\n\t\tjas_image_setclrspc(dec->image, JAS_CLRSPC_SRGB);\n\t\tjas_image_setcmpttype(dec->image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));\n\t\tjas_image_setcmpttype(dec->image, 1,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));\n\t\tjas_image_setcmpttype(dec->image, 2,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));\n\t} else {\n\t\tjas_image_setclrspc(dec->image, JAS_CLRSPC_SGRAY);\n\t\tjas_image_setcmpttype(dec->image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));\n\t}\n\n\t/* Save the return value. */\n\timage = dec->image;\n\n\t/* Stop the image from being discarded. */\n\tdec->image = 0;\n\n\t/* Destroy decoder. */\n\tjpc_dec_destroy(dec);\n\n\treturn image;\n\nerror:\n\tif (dec) {\n\t\tjpc_dec_destroy(dec);\n\t}\n\treturn 0;\n}\n\ntypedef enum {\n\tOPT_MAXLYRS,\n\tOPT_MAXPKTS,\n\tOPT_DEBUG\n} optid_t;\n\njas_taginfo_t decopts[] = {\n\t{OPT_MAXLYRS, \"maxlyrs\"},\n\t{OPT_MAXPKTS, \"maxpkts\"},\n\t{OPT_DEBUG, \"debug\"},\n\t{-1, 0}\n};\n\nstatic int jpc_dec_parseopts(char *optstr, jpc_dec_importopts_t *opts)\n{\n\tjas_tvparser_t *tvp;\n\n\topts->debug = 0;\n\topts->maxlyrs = JPC_MAXLYRS;\n\topts->maxpkts = -1;\n\n\tif (!(tvp = jas_tvparser_create(optstr ? optstr : \"\"))) {\n\t\treturn -1;\n\t}\n\n\twhile (!jas_tvparser_next(tvp)) {\n\t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(decopts,\n\t\t  jas_tvparser_gettag(tvp)))->id) {\n\t\tcase OPT_MAXLYRS:\n\t\t\topts->maxlyrs = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_DEBUG:\n\t\t\topts->debug = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_MAXPKTS:\n\t\t\topts->maxpkts = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tjas_eprintf(\"warning: ignoring invalid option %s\\n\",\n\t\t\t  jas_tvparser_gettag(tvp));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tjas_tvparser_destroy(tvp);\n\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Code for table-driven code stream decoder.\n\\******************************************************************************/\n\nstatic jpc_dec_mstabent_t *jpc_dec_mstab_lookup(uint_fast16_t id)\n{\n\tjpc_dec_mstabent_t *mstabent;\n\tfor (mstabent = jpc_dec_mstab; mstabent->id != 0; ++mstabent) {\n\t\tif (mstabent->id == id) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn mstabent;\n}\n\nstatic int jpc_dec_decode(jpc_dec_t *dec)\n{\n\tjpc_ms_t *ms;\n\tjpc_dec_mstabent_t *mstabent;\n\tint ret;\n\tjpc_cstate_t *cstate;\n\n\tif (!(cstate = jpc_cstate_create())) {\n\t\treturn -1;\n\t}\n\tdec->cstate = cstate;\n\n\t/* Initially, we should expect to encounter a SOC marker segment. */\n\tdec->state = JPC_MHSOC;\n\n\tfor (;;) {\n\n\t\t/* Get the next marker segment in the code stream. */\n\t\tif (!(ms = jpc_getms(dec->in, cstate))) {\n\t\t\tjas_eprintf(\"cannot get marker segment\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tmstabent = jpc_dec_mstab_lookup(ms->id);\n\t\tassert(mstabent);\n\n\t\t/* Ensure that this type of marker segment is permitted\n\t\t  at this point in the code stream. */\n\t\tif (!(dec->state & mstabent->validstates)) {\n\t\t\tjas_eprintf(\"unexpected marker segment type\\n\");\n\t\t\tjpc_ms_destroy(ms);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Process the marker segment. */\n\t\tif (mstabent->action) {\n\t\t\tret = (*mstabent->action)(dec, ms);\n\t\t} else {\n\t\t\t/* No explicit action is required. */\n\t\t\tret = 0;\n\t\t}\n\n\t\t/* Destroy the marker segment. */\n\t\tjpc_ms_destroy(ms);\n\n\t\tif (ret < 0) {\n\t\t\treturn -1;\n\t\t} else if (ret > 0) {\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_crg(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tint cmptno;\n\tjpc_dec_cmpt_t *cmpt;\n\tjpc_crg_t *crg;\n\n\tcrg = &ms->parms.crg;\n\tfor (cmptno = 0, cmpt = dec->cmpts; cmptno < dec->numcomps; ++cmptno,\n\t  ++cmpt) {\n\t\t/* Ignore the information in the CRG marker segment for now.\n\t\t  This information serves no useful purpose for decoding anyhow.\n\t\t  Some other parts of the code need to be changed if these lines\n\t\t  are uncommented.\n\t\tcmpt->hsubstep = crg->comps[cmptno].hoff;\n\t\tcmpt->vsubstep = crg->comps[cmptno].voff;\n\t\t*/\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_soc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\t/* Eliminate warnings about unused variables. */\n\tms = 0;\n\n\t/* We should expect to encounter a SIZ marker segment next. */\n\tdec->state = JPC_MHSIZ;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_sot(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_dec_tile_t *tile;\n\tjpc_sot_t *sot = &ms->parms.sot;\n\tjas_image_cmptparm_t *compinfos;\n\tjas_image_cmptparm_t *compinfo;\n\tjpc_dec_cmpt_t *cmpt;\n\tint cmptno;\n\n\tif (dec->state == JPC_MH) {\n\n\t\tif (!(compinfos = jas_alloc2(dec->numcomps,\n\t\t  sizeof(jas_image_cmptparm_t)))) {\n\t\t\tabort();\n\t\t}\n\t\tfor (cmptno = 0, cmpt = dec->cmpts, compinfo = compinfos;\n\t\t  cmptno < dec->numcomps; ++cmptno, ++cmpt, ++compinfo) {\n\t\t\tcompinfo->tlx = 0;\n\t\t\tcompinfo->tly = 0;\n\t\t\tcompinfo->prec = cmpt->prec;\n\t\t\tcompinfo->sgnd = cmpt->sgnd;\n\t\t\tcompinfo->width = cmpt->width;\n\t\t\tcompinfo->height = cmpt->height;\n\t\t\tcompinfo->hstep = cmpt->hstep;\n\t\t\tcompinfo->vstep = cmpt->vstep;\n\t\t}\n\n\t\tif (!(dec->image = jas_image_create(dec->numcomps, compinfos,\n\t\t  JAS_CLRSPC_UNKNOWN))) {\n\t\t\tjas_free(compinfos);\n\t\t\treturn -1;\n\t\t}\n\t\tjas_free(compinfos);\n\n\t\t/* Is the packet header information stored in PPM marker segments in\n\t\t  the main header? */\n\t\tif (dec->ppmstab) {\n\t\t\t/* Convert the PPM marker segment data into a collection of streams\n\t\t\t  (one stream per tile-part). */\n\t\t\tif (!(dec->pkthdrstreams = jpc_ppmstabtostreams(dec->ppmstab))) {\n\t\t\t\tabort();\n\t\t\t}\n\t\t\tjpc_ppxstab_destroy(dec->ppmstab);\n\t\t\tdec->ppmstab = 0;\n\t\t}\n\t}\n\n\tif (sot->len > 0) {\n\t\tdec->curtileendoff = jas_stream_getrwcount(dec->in) - ms->len -\n\t\t  4 + sot->len;\n\t} else {\n\t\tdec->curtileendoff = 0;\n\t}\n\n\tif (JAS_CAST(int, sot->tileno) >= dec->numtiles) {\n\t\tjas_eprintf(\"invalid tile number in SOT marker segment\\n\");\n\t\treturn -1;\n\t}\n\t/* Set the current tile. */\n\tdec->curtile = &dec->tiles[sot->tileno];\n\ttile = dec->curtile;\n\t/* Ensure that this is the expected part number. */\n\tif (sot->partno != tile->partno) {\n\t\treturn -1;\n\t}\n\tif (tile->numparts > 0 && sot->partno >= tile->numparts) {\n\t\treturn -1;\n\t}\n\tif (!tile->numparts && sot->numparts > 0) {\n\t\ttile->numparts = sot->numparts;\n\t}\n\n\ttile->pptstab = 0;\n\n\tswitch (tile->state) {\n\tcase JPC_TILE_INIT:\n\t\t/* This is the first tile-part for this tile. */\n\t\ttile->state = JPC_TILE_ACTIVE;\n\t\tassert(!tile->cp);\n\t\tif (!(tile->cp = jpc_dec_cp_copy(dec->cp))) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_resetflags(dec->cp);\n\t\tbreak;\n\tdefault:\n\t\tif (sot->numparts == sot->partno - 1) {\n\t\t\ttile->state = JPC_TILE_ACTIVELAST;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* Note: We do not increment the expected tile-part number until\n\t  all processing for this tile-part is complete. */\n\n\t/* We should expect to encounter other tile-part header marker\n\t  segments next. */\n\tdec->state = JPC_TPH;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_sod(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_dec_tile_t *tile;\n\tint pos;\n\n\t/* Eliminate compiler warnings about unused variables. */\n\tms = 0;\n\n\tif (!(tile = dec->curtile)) {\n\t\treturn -1;\n\t}\n\n\tif (!tile->partno) {\n\t\tif (!jpc_dec_cp_isvalid(tile->cp)) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_prepare(tile->cp);\n\t\tif (jpc_dec_tileinit(dec, tile)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Are packet headers stored in the main header or tile-part header? */\n\tif (dec->pkthdrstreams) {\n\t\t/* Get the stream containing the packet header data for this\n\t\t  tile-part. */\n\t\tif (!(tile->pkthdrstream = jpc_streamlist_remove(dec->pkthdrstreams, 0))) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (tile->pptstab) {\n\t\tif (!tile->pkthdrstream) {\n\t\t\tif (!(tile->pkthdrstream = jas_stream_memopen(0, 0))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tpos = jas_stream_tell(tile->pkthdrstream);\n\t\tjas_stream_seek(tile->pkthdrstream, 0, SEEK_END);\n\t\tif (jpc_pptstabwrite(tile->pkthdrstream, tile->pptstab)) {\n\t\t\treturn -1;\n\t\t}\n\t\tjas_stream_seek(tile->pkthdrstream, pos, SEEK_SET);\n\t\tjpc_ppxstab_destroy(tile->pptstab);\n\t\ttile->pptstab = 0;\n\t}\n\n\tif (jas_getdbglevel() >= 10) {\n\t\tjpc_dec_dump(dec, stderr);\n\t}\n\n\tif (jpc_dec_decodepkts(dec, (tile->pkthdrstream) ? tile->pkthdrstream :\n\t  dec->in, dec->in)) {\n\t\tjas_eprintf(\"jpc_dec_decodepkts failed\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Gobble any unconsumed tile data. */\n\tif (dec->curtileendoff > 0) {\n\t\tlong curoff;\n\t\tuint_fast32_t n;\n\t\tcuroff = jas_stream_getrwcount(dec->in);\n\t\tif (curoff < dec->curtileendoff) {\n\t\t\tn = dec->curtileendoff - curoff;\n\t\t\tjas_eprintf(\"warning: ignoring trailing garbage (%lu bytes)\\n\",\n\t\t\t  (unsigned long) n);\n\n\t\t\twhile (n-- > 0) {\n\t\t\t\tif (jas_stream_getc(dec->in) == EOF) {\n\t\t\t\t\tjas_eprintf(\"read error\\n\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (curoff > dec->curtileendoff) {\n\t\t\tjas_eprintf(\"warning: not enough tile data (%lu bytes)\\n\",\n\t\t\t  (unsigned long) curoff - dec->curtileendoff);\n\t\t}\n\n\t}\n\n\tif (tile->numparts > 0 && tile->partno == tile->numparts - 1) {\n\t\tif (jpc_dec_tiledecode(dec, tile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_tilefini(dec, tile);\n\t}\n\n\tdec->curtile = 0;\n\n\t/* Increment the expected tile-part number. */\n\t++tile->partno;\n\n\t/* We should expect to encounter a SOT marker segment next. */\n\tdec->state = JPC_TPHSOT;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_tileinit(jpc_dec_t *dec, jpc_dec_tile_t *tile)\n{\n\tjpc_dec_tcomp_t *tcomp;\n\tint compno;\n\tint rlvlno;\n\tjpc_dec_rlvl_t *rlvl;\n\tjpc_dec_band_t *band;\n\tjpc_dec_prc_t *prc;\n\tint bndno;\n\tjpc_tsfb_band_t *bnd;\n\tint bandno;\n\tjpc_dec_ccp_t *ccp;\n\tint prccnt;\n\tjpc_dec_cblk_t *cblk;\n\tint cblkcnt;\n\tuint_fast32_t tlprcxstart;\n\tuint_fast32_t tlprcystart;\n\tuint_fast32_t brprcxend;\n\tuint_fast32_t brprcyend;\n\tuint_fast32_t tlcbgxstart;\n\tuint_fast32_t tlcbgystart;\n\tuint_fast32_t brcbgxend;\n\tuint_fast32_t brcbgyend;\n\tuint_fast32_t cbgxstart;\n\tuint_fast32_t cbgystart;\n\tuint_fast32_t cbgxend;\n\tuint_fast32_t cbgyend;\n\tuint_fast32_t tlcblkxstart;\n\tuint_fast32_t tlcblkystart;\n\tuint_fast32_t brcblkxend;\n\tuint_fast32_t brcblkyend;\n\tuint_fast32_t cblkxstart;\n\tuint_fast32_t cblkystart;\n\tuint_fast32_t cblkxend;\n\tuint_fast32_t cblkyend;\n\tuint_fast32_t tmpxstart;\n\tuint_fast32_t tmpystart;\n\tuint_fast32_t tmpxend;\n\tuint_fast32_t tmpyend;\n\tjpc_dec_cp_t *cp;\n\tjpc_tsfb_band_t bnds[64];\n\tjpc_pchg_t *pchg;\n\tint pchgno;\n\tjpc_dec_cmpt_t *cmpt;\n\n\tcp = tile->cp;\n\ttile->realmode = 0;\n\tif (cp->mctid == JPC_MCT_ICT) {\n\t\ttile->realmode = 1;\n\t}\n\n\tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <\n\t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {\n\t\tccp = &tile->cp->ccps[compno];\n\t\tif (ccp->qmfbid == JPC_COX_INS) {\n\t\t\ttile->realmode = 1;\n\t\t}\n\t\ttcomp->numrlvls = ccp->numrlvls;\n\t\tif (!(tcomp->rlvls = jas_alloc2(tcomp->numrlvls,\n\t\t  sizeof(jpc_dec_rlvl_t)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (!(tcomp->data = jas_seq2d_create(JPC_CEILDIV(tile->xstart,\n\t\t  cmpt->hstep), JPC_CEILDIV(tile->ystart, cmpt->vstep),\n\t\t  JPC_CEILDIV(tile->xend, cmpt->hstep), JPC_CEILDIV(tile->yend,\n\t\t  cmpt->vstep)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (!(tcomp->tsfb = jpc_cod_gettsfb(ccp->qmfbid,\n\t\t  tcomp->numrlvls - 1))) {\n\t\t\treturn -1;\n\t\t}\n\t\t{\n\t\t\tjpc_tsfb_getbands(tcomp->tsfb, jas_seq2d_xstart(tcomp->data),\n\t\t\t  jas_seq2d_ystart(tcomp->data), jas_seq2d_xend(tcomp->data),\n\t\t\t  jas_seq2d_yend(tcomp->data), bnds);\n\t\t}\n\t\tfor (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno < tcomp->numrlvls;\n\t\t  ++rlvlno, ++rlvl) {\n\t\t\trlvl->bands = 0;\n\t\t\trlvl->xstart = JPC_CEILDIVPOW2(tcomp->xstart,\n\t\t\t  tcomp->numrlvls - 1 - rlvlno);\n\t\t\trlvl->ystart = JPC_CEILDIVPOW2(tcomp->ystart,\n\t\t\t  tcomp->numrlvls - 1 - rlvlno);\n\t\t\trlvl->xend = JPC_CEILDIVPOW2(tcomp->xend,\n\t\t\t  tcomp->numrlvls - 1 - rlvlno);\n\t\t\trlvl->yend = JPC_CEILDIVPOW2(tcomp->yend,\n\t\t\t  tcomp->numrlvls - 1 - rlvlno);\n\t\t\trlvl->prcwidthexpn = ccp->prcwidthexpns[rlvlno];\n\t\t\trlvl->prcheightexpn = ccp->prcheightexpns[rlvlno];\n\t\t\ttlprcxstart = JPC_FLOORDIVPOW2(rlvl->xstart,\n\t\t\t  rlvl->prcwidthexpn) << rlvl->prcwidthexpn;\n\t\t\ttlprcystart = JPC_FLOORDIVPOW2(rlvl->ystart,\n\t\t\t  rlvl->prcheightexpn) << rlvl->prcheightexpn;\n\t\t\tbrprcxend = JPC_CEILDIVPOW2(rlvl->xend,\n\t\t\t  rlvl->prcwidthexpn) << rlvl->prcwidthexpn;\n\t\t\tbrprcyend = JPC_CEILDIVPOW2(rlvl->yend,\n\t\t\t  rlvl->prcheightexpn) << rlvl->prcheightexpn;\n\t\t\trlvl->numhprcs = (brprcxend - tlprcxstart) >>\n\t\t\t  rlvl->prcwidthexpn;\n\t\t\trlvl->numvprcs = (brprcyend - tlprcystart) >>\n\t\t\t  rlvl->prcheightexpn;\n\t\t\trlvl->numprcs = rlvl->numhprcs * rlvl->numvprcs;\n\n\t\t\tif (rlvl->xstart >= rlvl->xend || rlvl->ystart >= rlvl->yend) {\n\t\t\t\trlvl->bands = 0;\n\t\t\t\trlvl->numprcs = 0;\n\t\t\t\trlvl->numhprcs = 0;\n\t\t\t\trlvl->numvprcs = 0;\n\t\t\t\tcontinue;\n\t\t\t}\t\n\t\t\tif (!rlvlno) {\n\t\t\t\ttlcbgxstart = tlprcxstart;\n\t\t\t\ttlcbgystart = tlprcystart;\n\t\t\t\tbrcbgxend = brprcxend;\n\t\t\t\tbrcbgyend = brprcyend;\n\t\t\t\trlvl->cbgwidthexpn = rlvl->prcwidthexpn;\n\t\t\t\trlvl->cbgheightexpn = rlvl->prcheightexpn;\n\t\t\t} else {\n\t\t\t\ttlcbgxstart = JPC_CEILDIVPOW2(tlprcxstart, 1);\n\t\t\t\ttlcbgystart = JPC_CEILDIVPOW2(tlprcystart, 1);\n\t\t\t\tbrcbgxend = JPC_CEILDIVPOW2(brprcxend, 1);\n\t\t\t\tbrcbgyend = JPC_CEILDIVPOW2(brprcyend, 1);\n\t\t\t\trlvl->cbgwidthexpn = rlvl->prcwidthexpn - 1;\n\t\t\t\trlvl->cbgheightexpn = rlvl->prcheightexpn - 1;\n\t\t\t}\n\t\t\trlvl->cblkwidthexpn = JAS_MIN(ccp->cblkwidthexpn,\n\t\t\t  rlvl->cbgwidthexpn);\n\t\t\trlvl->cblkheightexpn = JAS_MIN(ccp->cblkheightexpn,\n\t\t\t  rlvl->cbgheightexpn);\n\n\t\t\trlvl->numbands = (!rlvlno) ? 1 : 3;\n\t\t\tif (!(rlvl->bands = jas_alloc2(rlvl->numbands,\n\t\t\t  sizeof(jpc_dec_band_t)))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (bandno = 0, band = rlvl->bands;\n\t\t\t  bandno < rlvl->numbands; ++bandno, ++band) {\n\t\t\t\tbndno = (!rlvlno) ? 0 : (3 * (rlvlno - 1) +\n\t\t\t\t  bandno + 1);\n\t\t\t\tbnd = &bnds[bndno];\n\n\t\t\t\tband->orient = bnd->orient;\n\t\t\t\tband->stepsize = ccp->stepsizes[bndno];\n\t\t\t\tband->analgain = JPC_NOMINALGAIN(ccp->qmfbid,\n\t\t\t\t  tcomp->numrlvls - 1, rlvlno, band->orient);\n\t\t\t\tband->absstepsize = jpc_calcabsstepsize(band->stepsize,\n\t\t\t\t  cmpt->prec + band->analgain);\n\t\t\t\tband->numbps = ccp->numguardbits +\n\t\t\t\t  JPC_QCX_GETEXPN(band->stepsize) - 1;\n\t\t\t\tband->roishift = (ccp->roishift + band->numbps >= JPC_PREC) ?\n\t\t\t\t  (JPC_PREC - 1 - band->numbps) : ccp->roishift;\n\t\t\t\tband->data = 0;\n\t\t\t\tband->prcs = 0;\n\t\t\t\tif (bnd->xstart == bnd->xend || bnd->ystart == bnd->yend) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!(band->data = jas_seq2d_create(0, 0, 0, 0))) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tjas_seq2d_bindsub(band->data, tcomp->data, bnd->locxstart,\n\t\t\t\t  bnd->locystart, bnd->locxend, bnd->locyend);\n\t\t\t\tjas_seq2d_setshift(band->data, bnd->xstart, bnd->ystart);\n\n\t\t\t\tassert(rlvl->numprcs);\n\n\t\t\t\tif (!(band->prcs = jas_alloc2(rlvl->numprcs,\n\t\t\t\t  sizeof(jpc_dec_prc_t)))) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n/************************************************/\n\t\t\t\tcbgxstart = tlcbgxstart;\n\t\t\t\tcbgystart = tlcbgystart;\n\t\t\t\tfor (prccnt = rlvl->numprcs, prc = band->prcs;\n\t\t\t\t  prccnt > 0; --prccnt, ++prc) {\n\t\t\t\t\tcbgxend = cbgxstart + (1 << rlvl->cbgwidthexpn);\n\t\t\t\t\tcbgyend = cbgystart + (1 << rlvl->cbgheightexpn);\n\t\t\t\t\tprc->xstart = JAS_MAX(cbgxstart, JAS_CAST(uint_fast32_t,\n\t\t\t\t\t  jas_seq2d_xstart(band->data)));\n\t\t\t\t\tprc->ystart = JAS_MAX(cbgystart, JAS_CAST(uint_fast32_t,\n\t\t\t\t\t  jas_seq2d_ystart(band->data)));\n\t\t\t\t\tprc->xend = JAS_MIN(cbgxend, JAS_CAST(uint_fast32_t,\n\t\t\t\t\t  jas_seq2d_xend(band->data)));\n\t\t\t\t\tprc->yend = JAS_MIN(cbgyend, JAS_CAST(uint_fast32_t,\n\t\t\t\t\t  jas_seq2d_yend(band->data)));\n\t\t\t\t\tif (prc->xend > prc->xstart && prc->yend > prc->ystart) {\n\t\t\t\t\t\ttlcblkxstart = JPC_FLOORDIVPOW2(prc->xstart,\n\t\t\t\t\t\t  rlvl->cblkwidthexpn) << rlvl->cblkwidthexpn;\n\t\t\t\t\t\ttlcblkystart = JPC_FLOORDIVPOW2(prc->ystart,\n\t\t\t\t\t\t  rlvl->cblkheightexpn) << rlvl->cblkheightexpn;\n\t\t\t\t\t\tbrcblkxend = JPC_CEILDIVPOW2(prc->xend,\n\t\t\t\t\t\t  rlvl->cblkwidthexpn) << rlvl->cblkwidthexpn;\n\t\t\t\t\t\tbrcblkyend = JPC_CEILDIVPOW2(prc->yend,\n\t\t\t\t\t\t  rlvl->cblkheightexpn) << rlvl->cblkheightexpn;\n\t\t\t\t\t\tprc->numhcblks = (brcblkxend - tlcblkxstart) >>\n\t\t\t\t\t\t  rlvl->cblkwidthexpn;\n\t\t\t\t\t\tprc->numvcblks = (brcblkyend - tlcblkystart) >>\n\t\t\t\t\t\t  rlvl->cblkheightexpn;\n\t\t\t\t\t\tprc->numcblks = prc->numhcblks * prc->numvcblks;\n\t\t\t\t\t\tassert(prc->numcblks > 0);\n\n\t\t\t\t\t\tif (!(prc->incltagtree = jpc_tagtree_create(\n\t\t\t\t\t\t  prc->numhcblks, prc->numvcblks))) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!(prc->numimsbstagtree = jpc_tagtree_create(\n\t\t\t\t\t\t  prc->numhcblks, prc->numvcblks))) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!(prc->cblks = jas_alloc2(prc->numcblks,\n\t\t\t\t\t\t  sizeof(jpc_dec_cblk_t)))) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcblkxstart = cbgxstart;\n\t\t\t\t\t\tcblkystart = cbgystart;\n\t\t\t\t\t\tfor (cblkcnt = prc->numcblks, cblk = prc->cblks; cblkcnt > 0;) {\n\t\t\t\t\t\t\tcblkxend = cblkxstart + (1 << rlvl->cblkwidthexpn);\n\t\t\t\t\t\t\tcblkyend = cblkystart + (1 << rlvl->cblkheightexpn);\n\t\t\t\t\t\t\ttmpxstart = JAS_MAX(cblkxstart, prc->xstart);\n\t\t\t\t\t\t\ttmpystart = JAS_MAX(cblkystart, prc->ystart);\n\t\t\t\t\t\t\ttmpxend = JAS_MIN(cblkxend, prc->xend);\n\t\t\t\t\t\t\ttmpyend = JAS_MIN(cblkyend, prc->yend);\n\t\t\t\t\t\t\tif (tmpxend > tmpxstart && tmpyend > tmpystart) {\n\t\t\t\t\t\t\t\tcblk->firstpassno = -1;\n\t\t\t\t\t\t\t\tcblk->mqdec = 0;\n\t\t\t\t\t\t\t\tcblk->nulldec = 0;\n\t\t\t\t\t\t\t\tcblk->flags = 0;\n\t\t\t\t\t\t\t\tcblk->numpasses = 0;\n\t\t\t\t\t\t\t\tcblk->segs.head = 0;\n\t\t\t\t\t\t\t\tcblk->segs.tail = 0;\n\t\t\t\t\t\t\t\tcblk->curseg = 0;\n\t\t\t\t\t\t\t\tcblk->numimsbs = 0;\n\t\t\t\t\t\t\t\tcblk->numlenbits = 3;\n\t\t\t\t\t\t\t\tcblk->flags = 0;\n\t\t\t\t\t\t\t\tif (!(cblk->data = jas_seq2d_create(0, 0, 0, 0))) {\n\t\t\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tjas_seq2d_bindsub(cblk->data, band->data,\n\t\t\t\t\t\t\t\t  tmpxstart, tmpystart, tmpxend, tmpyend);\n\t\t\t\t\t\t\t\t++cblk;\n\t\t\t\t\t\t\t\t--cblkcnt;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcblkxstart += 1 << rlvl->cblkwidthexpn;\n\t\t\t\t\t\t\tif (cblkxstart >= cbgxend) {\n\t\t\t\t\t\t\t\tcblkxstart = cbgxstart;\n\t\t\t\t\t\t\t\tcblkystart += 1 << rlvl->cblkheightexpn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprc->cblks = 0;\n\t\t\t\t\t\tprc->incltagtree = 0;\n\t\t\t\t\t\tprc->numimsbstagtree = 0;\n\t\t\t\t\t}\n\t\t\t\t\tcbgxstart += 1 << rlvl->cbgwidthexpn;\n\t\t\t\t\tif (cbgxstart >= brcbgxend) {\n\t\t\t\t\t\tcbgxstart = tlcbgxstart;\n\t\t\t\t\t\tcbgystart += 1 << rlvl->cbgheightexpn;\n\t\t\t\t\t}\n\n\t\t\t\t}\n/********************************************/\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!(tile->pi = jpc_dec_pi_create(dec, tile))) {\n\t\treturn -1;\n\t}\n\n\tfor (pchgno = 0; pchgno < jpc_pchglist_numpchgs(tile->cp->pchglist);\n\t  ++pchgno) {\n\t\tpchg = jpc_pchg_copy(jpc_pchglist_get(tile->cp->pchglist, pchgno));\n\t\tassert(pchg);\n\t\tjpc_pi_addpchg(tile->pi, pchg);\n\t}\n\tjpc_pi_init(tile->pi);\n\n\treturn 0;\n}\n\nstatic int jpc_dec_tilefini(jpc_dec_t *dec, jpc_dec_tile_t *tile)\n{\n\tjpc_dec_tcomp_t *tcomp;\n\tint compno;\n\tint bandno;\n\tint rlvlno;\n\tjpc_dec_band_t *band;\n\tjpc_dec_rlvl_t *rlvl;\n\tint prcno;\n\tjpc_dec_prc_t *prc;\n\tjpc_dec_seg_t *seg;\n\tjpc_dec_cblk_t *cblk;\n\tint cblkno;\n\n\tif (tile->tcomps) {\n\n\t\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t\t  ++compno, ++tcomp) {\n\t\t\tfor (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno < tcomp->numrlvls;\n\t\t\t  ++rlvlno, ++rlvl) {\n\t\t\t\tif (!rlvl->bands) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (bandno = 0, band = rlvl->bands; bandno < rlvl->numbands;\n\t\t\t\t  ++bandno, ++band) {\n\t\t\t\t\tif (band->prcs) {\n\t\t\t\t\t\tfor (prcno = 0, prc = band->prcs; prcno <\n\t\t\t\t\t\t  rlvl->numprcs; ++prcno, ++prc) {\n\t\t\t\t\t\t\tif (!prc->cblks) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (cblkno = 0, cblk = prc->cblks; cblkno <\n\t\t\t\t\t\t\t  prc->numcblks; ++cblkno, ++cblk) {\n\n\t\t\t\t\t\t\t\twhile (cblk->segs.head) {\n\t\t\t\t\t\t\t\t\tseg = cblk->segs.head;\n\t\t\t\t\t\t\t\t\tjpc_seglist_remove(&cblk->segs, seg);\n\t\t\t\t\t\t\t\t\tjpc_seg_destroy(seg);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tjas_matrix_destroy(cblk->data);\n\t\t\t\t\t\t\t\tif (cblk->mqdec) {\n\t\t\t\t\t\t\t\t\tjpc_mqdec_destroy(cblk->mqdec);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (cblk->nulldec) {\n\t\t\t\t\t\t\t\t\tjpc_bitstream_close(cblk->nulldec);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (cblk->flags) {\n\t\t\t\t\t\t\t\t\tjas_matrix_destroy(cblk->flags);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (prc->incltagtree) {\n\t\t\t\t\t\t\t\tjpc_tagtree_destroy(prc->incltagtree);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (prc->numimsbstagtree) {\n\t\t\t\t\t\t\t\tjpc_tagtree_destroy(prc->numimsbstagtree);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (prc->cblks) {\n\t\t\t\t\t\t\t\tjas_free(prc->cblks);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (band->data) {\n\t\t\t\t\t\tjas_matrix_destroy(band->data);\n\t\t\t\t\t}\n\t\t\t\t\tif (band->prcs) {\n\t\t\t\t\t\tjas_free(band->prcs);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (rlvl->bands) {\n\t\t\t\t\tjas_free(rlvl->bands);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tcomp->rlvls) {\n\t\t\t\tjas_free(tcomp->rlvls);\n\t\t\t}\n\t\t\tif (tcomp->data) {\n\t\t\t\tjas_matrix_destroy(tcomp->data);\n\t\t\t}\n\t\t\tif (tcomp->tsfb) {\n\t\t\t\tjpc_tsfb_destroy(tcomp->tsfb);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tile->cp) {\n\t\tjpc_dec_cp_destroy(tile->cp);\n\t\t//tile->cp = 0;\n\t}\n\tif (tile->tcomps) {\n\t\tjas_free(tile->tcomps);\n\t\t//tile->tcomps = 0;\n\t}\n\tif (tile->pi) {\n\t\tjpc_pi_destroy(tile->pi);\n\t\t//tile->pi = 0;\n\t}\n\tif (tile->pkthdrstream) {\n\t\tjas_stream_close(tile->pkthdrstream);\n\t\t//tile->pkthdrstream = 0;\n\t}\n\tif (tile->pptstab) {\n\t\tjpc_ppxstab_destroy(tile->pptstab);\n\t\t//tile->pptstab = 0;\n\t}\n\n\ttile->state = JPC_TILE_DONE;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_tiledecode(jpc_dec_t *dec, jpc_dec_tile_t *tile)\n{\n\tint i;\n\tint j;\n\tjpc_dec_tcomp_t *tcomp;\n\tjpc_dec_rlvl_t *rlvl;\n\tjpc_dec_band_t *band;\n\tint compno;\n\tint rlvlno;\n\tint bandno;\n\tint adjust;\n\tint v;\n\tjpc_dec_ccp_t *ccp;\n\tjpc_dec_cmpt_t *cmpt;\n\n\tif (jpc_dec_decodecblks(dec, tile)) {\n\t\tjas_eprintf(\"jpc_dec_decodecblks failed\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Perform dequantization. */\n\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t  ++compno, ++tcomp) {\n\t\tccp = &tile->cp->ccps[compno];\n\t\tfor (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno < tcomp->numrlvls;\n\t\t  ++rlvlno, ++rlvl) {\n\t\t\tif (!rlvl->bands) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (bandno = 0, band = rlvl->bands;\n\t\t\t  bandno < rlvl->numbands; ++bandno, ++band) {\n\t\t\t\tif (!band->data) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tjpc_undo_roi(band->data, band->roishift, ccp->roishift -\n\t\t\t\t  band->roishift, band->numbps);\n\t\t\t\tif (tile->realmode) {\n\t\t\t\t\tjas_matrix_asl(band->data, JPC_FIX_FRACBITS);\n\t\t\t\t\tjpc_dequantize(band->data, band->absstepsize);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Apply an inverse wavelet transform if necessary. */\n\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t  ++compno, ++tcomp) {\n\t\tccp = &tile->cp->ccps[compno];\n\t\tjpc_tsfb_synthesize(tcomp->tsfb, tcomp->data);\n\t}\n\n\n\t/* Apply an inverse intercomponent transform if necessary. */\n\tswitch (tile->cp->mctid) {\n\tcase JPC_MCT_RCT:\n\t\tif (dec->numcomps < 3) {\n\t\t\tjas_eprintf(\"RCT requires at least three components\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (!jas_image_cmpt_domains_same(dec->image)) {\n\t\t\tjas_eprintf(\"RCT requires all components have the same domain\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_irct(tile->tcomps[0].data, tile->tcomps[1].data,\n\t\t  tile->tcomps[2].data);\n\t\tbreak;\n\tcase JPC_MCT_ICT:\n\t\tif (dec->numcomps < 3) {\n\t\t\tjas_eprintf(\"ICT requires at least three components\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (!jas_image_cmpt_domains_same(dec->image)) {\n\t\t\tjas_eprintf(\"RCT requires all components have the same domain\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_iict(tile->tcomps[0].data, tile->tcomps[1].data,\n\t\t  tile->tcomps[2].data);\n\t\tbreak;\n\t}\n\n\t/* Perform rounding and convert to integer values. */\n\tif (tile->realmode) {\n\t\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t\t  ++compno, ++tcomp) {\n\t\t\tfor (i = 0; i < jas_matrix_numrows(tcomp->data); ++i) {\n\t\t\t\tfor (j = 0; j < jas_matrix_numcols(tcomp->data); ++j) {\n\t\t\t\t\tv = jas_matrix_get(tcomp->data, i, j);\n\t\t\t\t\tv = jpc_fix_round(v);\n\t\t\t\t\tjas_matrix_set(tcomp->data, i, j, jpc_fixtoint(v));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Perform level shift. */\n\tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <\n\t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {\n\t\tadjust = cmpt->sgnd ? 0 : (1 << (cmpt->prec - 1));\n\t\tfor (i = 0; i < jas_matrix_numrows(tcomp->data); ++i) {\n\t\t\tfor (j = 0; j < jas_matrix_numcols(tcomp->data); ++j) {\n\t\t\t\t*jas_matrix_getref(tcomp->data, i, j) += adjust;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Perform clipping. */\n\tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <\n\t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {\n\t\tjpc_fix_t mn;\n\t\tjpc_fix_t mx;\n\t\tmn = cmpt->sgnd ? (-(1 << (cmpt->prec - 1))) : (0);\n\t\tmx = cmpt->sgnd ? ((1 << (cmpt->prec - 1)) - 1) : ((1 <<\n\t\t  cmpt->prec) - 1);\n\t\tjas_matrix_clip(tcomp->data, mn, mx);\n\t}\n\n\t/* XXX need to free tsfb struct */\n\n\t/* Write the data for each component of the image. */\n\tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <\n\t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {\n\t\tif (jas_image_writecmpt(dec->image, compno, tcomp->xstart -\n\t\t  JPC_CEILDIV(dec->xstart, cmpt->hstep), tcomp->ystart -\n\t\t  JPC_CEILDIV(dec->ystart, cmpt->vstep), jas_matrix_numcols(\n\t\t  tcomp->data), jas_matrix_numrows(tcomp->data), tcomp->data)) {\n\t\t\tjas_eprintf(\"write component failed\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_eoc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tint tileno;\n\tjpc_dec_tile_t *tile;\n\n\t/* Eliminate compiler warnings about unused variables. */\n\tms = 0;\n\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,\n\t  ++tile) {\n\t\tif (tile->state == JPC_TILE_ACTIVE) {\n\t\t\tif (jpc_dec_tiledecode(dec, tile)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\t/* If the tile has not yet been finalized, finalize it. */\n\t\t// OLD CODE: jpc_dec_tilefini(dec, tile);\n\t\tif (tile->state != JPC_TILE_DONE) {\n\t\t\tjpc_dec_tilefini(dec, tile);\n\t\t}\n\t}\n\n\t/* We are done processing the code stream. */\n\tdec->state = JPC_MT;\n\n\treturn 1;\n}\n\nstatic int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_siz_t *siz = &ms->parms.siz;\n\tint compno;\n\tint tileno;\n\tjpc_dec_tile_t *tile;\n\tjpc_dec_tcomp_t *tcomp;\n\tint htileno;\n\tint vtileno;\n\tjpc_dec_cmpt_t *cmpt;\n\tsize_t size;\n\n\tdec->xstart = siz->xoff;\n\tdec->ystart = siz->yoff;\n\tdec->xend = siz->width;\n\tdec->yend = siz->height;\n\tdec->tilewidth = siz->tilewidth;\n\tdec->tileheight = siz->tileheight;\n\tdec->tilexoff = siz->tilexoff;\n\tdec->tileyoff = siz->tileyoff;\n\tdec->numcomps = siz->numcomps;\n\tif (!(dec->cp = jpc_dec_cp_create(dec->numcomps))) {\n\t\treturn -1;\n\t}\n\n\tif (!(dec->cmpts = jas_alloc2(dec->numcomps, sizeof(jpc_dec_cmpt_t)))) {\n\t\treturn -1;\n\t}\n\n\tfor (compno = 0, cmpt = dec->cmpts; compno < dec->numcomps; ++compno,\n\t  ++cmpt) {\n\t\tcmpt->prec = siz->comps[compno].prec;\n\t\tcmpt->sgnd = siz->comps[compno].sgnd;\n\t\tcmpt->hstep = siz->comps[compno].hsamp;\n\t\tcmpt->vstep = siz->comps[compno].vsamp;\n\t\tcmpt->width = JPC_CEILDIV(dec->xend, cmpt->hstep) -\n\t\t  JPC_CEILDIV(dec->xstart, cmpt->hstep);\n\t\tcmpt->height = JPC_CEILDIV(dec->yend, cmpt->vstep) -\n\t\t  JPC_CEILDIV(dec->ystart, cmpt->vstep);\n\t\tcmpt->hsubstep = 0;\n\t\tcmpt->vsubstep = 0;\n\t}\n\n\tdec->image = 0;\n\n\tdec->numhtiles = JPC_CEILDIV(dec->xend - dec->tilexoff, dec->tilewidth);\n\tdec->numvtiles = JPC_CEILDIV(dec->yend - dec->tileyoff, dec->tileheight);\n\tif (!jas_safe_size_mul(dec->numhtiles, dec->numvtiles, &size)) {\n\t\treturn -1;\n\t}\n\tdec->numtiles = size;\n\tJAS_DBGLOG(10, (\"numtiles = %d; numhtiles = %d; numvtiles = %d;\\n\",\n\t  dec->numtiles, dec->numhtiles, dec->numvtiles));\n\tif (!(dec->tiles = jas_alloc2(dec->numtiles, sizeof(jpc_dec_tile_t)))) {\n\t\treturn -1;\n\t}\n\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,\n\t  ++tile) {\n\t\thtileno = tileno % dec->numhtiles;\n\t\tvtileno = tileno / dec->numhtiles;\n\t\ttile->realmode = 0;\n\t\ttile->state = JPC_TILE_INIT;\n\t\ttile->xstart = JAS_MAX(dec->tilexoff + htileno * dec->tilewidth,\n\t\t  dec->xstart);\n\t\ttile->ystart = JAS_MAX(dec->tileyoff + vtileno * dec->tileheight,\n\t\t  dec->ystart);\n\t\ttile->xend = JAS_MIN(dec->tilexoff + (htileno + 1) *\n\t\t  dec->tilewidth, dec->xend);\n\t\ttile->yend = JAS_MIN(dec->tileyoff + (vtileno + 1) *\n\t\t  dec->tileheight, dec->yend);\n\t\ttile->numparts = 0;\n\t\ttile->partno = 0;\n\t\ttile->pkthdrstream = 0;\n\t\ttile->pkthdrstreampos = 0;\n\t\ttile->pptstab = 0;\n\t\ttile->cp = 0;\n\t\ttile->pi = 0;\n\t\tif (!(tile->tcomps = jas_alloc2(dec->numcomps,\n\t\t  sizeof(jpc_dec_tcomp_t)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (compno = 0, cmpt = dec->cmpts, tcomp = tile->tcomps;\n\t\t  compno < dec->numcomps; ++compno, ++cmpt, ++tcomp) {\n\t\t\ttcomp->rlvls = 0;\n\t\t\ttcomp->numrlvls = 0;\n\t\t\ttcomp->data = 0;\n\t\t\ttcomp->xstart = JPC_CEILDIV(tile->xstart, cmpt->hstep);\n\t\t\ttcomp->ystart = JPC_CEILDIV(tile->ystart, cmpt->vstep);\n\t\t\ttcomp->xend = JPC_CEILDIV(tile->xend, cmpt->hstep);\n\t\t\ttcomp->yend = JPC_CEILDIV(tile->yend, cmpt->vstep);\n\t\t\ttcomp->tsfb = 0;\n\t\t}\n\t}\n\n\tdec->pkthdrstreams = 0;\n\n\t/* We should expect to encounter other main header marker segments\n\t  or an SOT marker segment next. */\n\tdec->state = JPC_MH;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_cod(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_cod_t *cod = &ms->parms.cod;\n\tjpc_dec_tile_t *tile;\n\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromcod(dec->cp, cod);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno != 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromcod(tile->cp, cod);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_coc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_coc_t *coc = &ms->parms.coc;\n\tjpc_dec_tile_t *tile;\n\n\tif (JAS_CAST(int, coc->compno) >= dec->numcomps) {\n\t\tjas_eprintf(\"invalid component number in COC marker segment\\n\");\n\t\treturn -1;\n\t}\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromcoc(dec->cp, coc);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno > 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromcoc(tile->cp, coc);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_rgn(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_rgn_t *rgn = &ms->parms.rgn;\n\tjpc_dec_tile_t *tile;\n\n\tif (JAS_CAST(int, rgn->compno) >= dec->numcomps) {\n\t\tjas_eprintf(\"invalid component number in RGN marker segment\\n\");\n\t\treturn -1;\n\t}\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromrgn(dec->cp, rgn);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno > 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromrgn(tile->cp, rgn);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_qcd(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_qcd_t *qcd = &ms->parms.qcd;\n\tjpc_dec_tile_t *tile;\n\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromqcd(dec->cp, qcd);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno > 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromqcd(tile->cp, qcd);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_qcc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_qcc_t *qcc = &ms->parms.qcc;\n\tjpc_dec_tile_t *tile;\n\n\tif (JAS_CAST(int, qcc->compno) >= dec->numcomps) {\n\t\tjas_eprintf(\"invalid component number in QCC marker segment\\n\");\n\t\treturn -1;\n\t}\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromqcc(dec->cp, qcc);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno > 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromqcc(tile->cp, qcc);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_poc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_poc_t *poc = &ms->parms.poc;\n\tjpc_dec_tile_t *tile;\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tif (jpc_dec_cp_setfrompoc(dec->cp, poc, 1)) {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (!tile->partno) {\n\t\t\tif (jpc_dec_cp_setfrompoc(tile->cp, poc, (!tile->partno))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\tjpc_pi_addpchgfrompoc(tile->pi, poc);\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_ppm(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_ppm_t *ppm = &ms->parms.ppm;\n\tjpc_ppxstabent_t *ppmstabent;\n\n\tif (!dec->ppmstab) {\n\t\tif (!(dec->ppmstab = jpc_ppxstab_create())) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!(ppmstabent = jpc_ppxstabent_create())) {\n\t\treturn -1;\n\t}\n\tppmstabent->ind = ppm->ind;\n\tppmstabent->data = ppm->data;\n\tppm->data = 0;\n\tppmstabent->len = ppm->len;\n\tif (jpc_ppxstab_insert(dec->ppmstab, ppmstabent)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_ppt(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_ppt_t *ppt = &ms->parms.ppt;\n\tjpc_dec_tile_t *tile;\n\tjpc_ppxstabent_t *pptstabent;\n\n\ttile = dec->curtile;\n\tif (!tile->pptstab) {\n\t\tif (!(tile->pptstab = jpc_ppxstab_create())) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (!(pptstabent = jpc_ppxstabent_create())) {\n\t\treturn -1;\n\t}\n\tpptstabent->ind = ppt->ind;\n\tpptstabent->data = ppt->data;\n\tppt->data = 0;\n\tpptstabent->len = ppt->len;\n\tif (jpc_ppxstab_insert(tile->pptstab, pptstabent)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_com(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\t/* Eliminate compiler warnings about unused variables. */\n\tdec = 0;\n\tms = 0;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_unk(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\t/* Eliminate compiler warnings about unused variables. */\n\tdec = 0;\n\n\tjas_eprintf(\"warning: ignoring unknown marker segment\\n\");\n\tjpc_ms_dump(ms, stderr);\n\treturn 0;\n}\n\n/******************************************************************************\\\n*\n\\******************************************************************************/\n\nstatic jpc_dec_cp_t *jpc_dec_cp_create(uint_fast16_t numcomps)\n{\n\tjpc_dec_cp_t *cp;\n\tjpc_dec_ccp_t *ccp;\n\tint compno;\n\n\tif (!(cp = jas_malloc(sizeof(jpc_dec_cp_t)))) {\n\t\treturn 0;\n\t}\n\tcp->flags = 0;\n\tcp->numcomps = numcomps;\n\tcp->prgord = 0;\n\tcp->numlyrs = 0;\n\tcp->mctid = 0;\n\tcp->csty = 0;\n\tif (!(cp->ccps = jas_alloc2(cp->numcomps, sizeof(jpc_dec_ccp_t)))) {\n\t\tgoto error;\n\t}\n\tif (!(cp->pchglist = jpc_pchglist_create())) {\n\t\tgoto error;\n\t}\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tccp->flags = 0;\n\t\tccp->numrlvls = 0;\n\t\tccp->cblkwidthexpn = 0;\n\t\tccp->cblkheightexpn = 0;\n\t\tccp->qmfbid = 0;\n\t\tccp->numstepsizes = 0;\n\t\tccp->numguardbits = 0;\n\t\tccp->roishift = 0;\n\t\tccp->cblkctx = 0;\n\t}\n\treturn cp;\nerror:\n\tif (cp) {\n\t\tjpc_dec_cp_destroy(cp);\n\t}\n\treturn 0;\n}\n\nstatic jpc_dec_cp_t *jpc_dec_cp_copy(jpc_dec_cp_t *cp)\n{\n\tjpc_dec_cp_t *newcp;\n\tjpc_dec_ccp_t *newccp;\n\tjpc_dec_ccp_t *ccp;\n\tint compno;\n\n\tif (!(newcp = jpc_dec_cp_create(cp->numcomps))) {\n\t\treturn 0;\n\t}\n\tnewcp->flags = cp->flags;\n\tnewcp->prgord = cp->prgord;\n\tnewcp->numlyrs = cp->numlyrs;\n\tnewcp->mctid = cp->mctid;\n\tnewcp->csty = cp->csty;\n\tjpc_pchglist_destroy(newcp->pchglist);\n\tnewcp->pchglist = 0;\n\tif (!(newcp->pchglist = jpc_pchglist_copy(cp->pchglist))) {\n\t\tjas_free(newcp);\n\t\treturn 0;\n\t}\n\tfor (compno = 0, newccp = newcp->ccps, ccp = cp->ccps;\n\t  compno < cp->numcomps;\n\t  ++compno, ++newccp, ++ccp) {\n\t\t*newccp = *ccp;\n\t}\n\treturn newcp;\n}\n\nstatic void jpc_dec_cp_resetflags(jpc_dec_cp_t *cp)\n{\n\tint compno;\n\tjpc_dec_ccp_t *ccp;\n\tcp->flags &= (JPC_CSET | JPC_QSET);\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tccp->flags = 0;\n\t}\n}\n\nstatic void jpc_dec_cp_destroy(jpc_dec_cp_t *cp)\n{\n\tif (cp->ccps) {\n\t\tjas_free(cp->ccps);\n\t}\n\tif (cp->pchglist) {\n\t\tjpc_pchglist_destroy(cp->pchglist);\n\t}\n\tjas_free(cp);\n}\n\nstatic int jpc_dec_cp_isvalid(jpc_dec_cp_t *cp)\n{\n\tuint_fast16_t compcnt;\n\tjpc_dec_ccp_t *ccp;\n\n\tif (!(cp->flags & JPC_CSET) || !(cp->flags & JPC_QSET)) {\n\t\treturn 0;\n\t}\n\tfor (compcnt = cp->numcomps, ccp = cp->ccps; compcnt > 0; --compcnt,\n\t  ++ccp) {\n\t\t/* Is there enough step sizes for the number of bands? */\n\t\tif ((ccp->qsty != JPC_QCX_SIQNT && JAS_CAST(int, ccp->numstepsizes) < 3 *\n\t\t  ccp->numrlvls - 2) || (ccp->qsty == JPC_QCX_SIQNT &&\n\t\t  ccp->numstepsizes != 1)) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic void calcstepsizes(uint_fast16_t refstepsize, int numrlvls,\n  uint_fast16_t *stepsizes)\n{\n\tint bandno;\n\tint numbands;\n\tuint_fast16_t expn;\n\tuint_fast16_t mant;\n\texpn = JPC_QCX_GETEXPN(refstepsize);\n\tmant = JPC_QCX_GETMANT(refstepsize);\n\tnumbands = 3 * numrlvls - 2;\n\tfor (bandno = 0; bandno < numbands; ++bandno) {\n\t\tstepsizes[bandno] = JPC_QCX_MANT(mant) | JPC_QCX_EXPN(expn +\n\t\t  (numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0))));\n\t}\n}\n\nstatic int jpc_dec_cp_prepare(jpc_dec_cp_t *cp)\n{\n\tjpc_dec_ccp_t *ccp;\n\tint compno;\n\tint i;\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tif (!(ccp->csty & JPC_COX_PRT)) {\n\t\t\tfor (i = 0; i < JPC_MAXRLVLS; ++i) {\n\t\t\t\tccp->prcwidthexpns[i] = 15;\n\t\t\t\tccp->prcheightexpns[i] = 15;\n\t\t\t}\n\t\t}\n\t\tif (ccp->qsty == JPC_QCX_SIQNT) {\n\t\t\tcalcstepsizes(ccp->stepsizes[0], ccp->numrlvls, ccp->stepsizes);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromcod(jpc_dec_cp_t *cp, jpc_cod_t *cod)\n{\n\tjpc_dec_ccp_t *ccp;\n\tint compno;\n\tcp->flags |= JPC_CSET;\n\tcp->prgord = cod->prg;\n\tif (cod->mctrans) {\n\t\tcp->mctid = (cod->compparms.qmfbid == JPC_COX_INS) ? (JPC_MCT_ICT) : (JPC_MCT_RCT);\n\t} else {\n\t\tcp->mctid = JPC_MCT_NONE;\n\t}\n\tcp->numlyrs = cod->numlyrs;\n\tcp->csty = cod->csty & (JPC_COD_SOP | JPC_COD_EPH);\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tjpc_dec_cp_setfromcox(cp, ccp, &cod->compparms, 0);\n\t}\n\tcp->flags |= JPC_CSET;\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromcoc(jpc_dec_cp_t *cp, jpc_coc_t *coc)\n{\n\tjpc_dec_cp_setfromcox(cp, &cp->ccps[coc->compno], &coc->compparms, JPC_COC);\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromcox(jpc_dec_cp_t *cp, jpc_dec_ccp_t *ccp,\n  jpc_coxcp_t *compparms, int flags)\n{\n\tint rlvlno;\n\n\t/* Eliminate compiler warnings about unused variables. */\n\tcp = 0;\n\n\tif ((flags & JPC_COC) || !(ccp->flags & JPC_COC)) {\n\t\tccp->numrlvls = compparms->numdlvls + 1;\n\t\tccp->cblkwidthexpn = JPC_COX_GETCBLKSIZEEXPN(\n\t\t  compparms->cblkwidthval);\n\t\tccp->cblkheightexpn = JPC_COX_GETCBLKSIZEEXPN(\n\t\t  compparms->cblkheightval);\n\t\tccp->qmfbid = compparms->qmfbid;\n\t\tccp->cblkctx = compparms->cblksty;\n\t\tccp->csty = compparms->csty & JPC_COX_PRT;\n\t\tfor (rlvlno = 0; rlvlno < compparms->numrlvls; ++rlvlno) {\n\t\t\tccp->prcwidthexpns[rlvlno] =\n\t\t\t  compparms->rlvls[rlvlno].parwidthval;\n\t\t\tccp->prcheightexpns[rlvlno] =\n\t\t\t  compparms->rlvls[rlvlno].parheightval;\n\t\t}\n\t\tccp->flags |= flags | JPC_CSET;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromqcd(jpc_dec_cp_t *cp, jpc_qcd_t *qcd)\n{\n\tint compno;\n\tjpc_dec_ccp_t *ccp;\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tjpc_dec_cp_setfromqcx(cp, ccp, &qcd->compparms, 0);\n\t}\n\tcp->flags |= JPC_QSET;\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromqcc(jpc_dec_cp_t *cp, jpc_qcc_t *qcc)\n{\n\treturn jpc_dec_cp_setfromqcx(cp, &cp->ccps[qcc->compno], &qcc->compparms, JPC_QCC);\n}\n\nstatic int jpc_dec_cp_setfromqcx(jpc_dec_cp_t *cp, jpc_dec_ccp_t *ccp,\n  jpc_qcxcp_t *compparms, int flags)\n{\n\tint bandno;\n\n\t/* Eliminate compiler warnings about unused variables. */\n\tcp = 0;\n\n\tif ((flags & JPC_QCC) || !(ccp->flags & JPC_QCC)) {\n\t\tccp->flags |= flags | JPC_QSET;\n\t\tfor (bandno = 0; bandno < compparms->numstepsizes; ++bandno) {\n\t\t\tccp->stepsizes[bandno] = compparms->stepsizes[bandno];\n\t\t}\n\t\tccp->numstepsizes = compparms->numstepsizes;\n\t\tccp->numguardbits = compparms->numguard;\n\t\tccp->qsty = compparms->qntsty;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromrgn(jpc_dec_cp_t *cp, jpc_rgn_t *rgn)\n{\n\tjpc_dec_ccp_t *ccp;\n\tccp = &cp->ccps[rgn->compno];\n\tccp->roishift = rgn->roishift;\n\treturn 0;\n}\n\nstatic int jpc_pi_addpchgfrompoc(jpc_pi_t *pi, jpc_poc_t *poc)\n{\n\tint pchgno;\n\tjpc_pchg_t *pchg;\n\tfor (pchgno = 0; pchgno < poc->numpchgs; ++pchgno) {\n\t\tif (!(pchg = jpc_pchg_copy(&poc->pchgs[pchgno]))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jpc_pchglist_insert(pi->pchglist, -1, pchg)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfrompoc(jpc_dec_cp_t *cp, jpc_poc_t *poc, int reset)\n{\n\tint pchgno;\n\tjpc_pchg_t *pchg;\n\tif (reset) {\n\t\twhile (jpc_pchglist_numpchgs(cp->pchglist) > 0) {\n\t\t\tpchg = jpc_pchglist_remove(cp->pchglist, 0);\n\t\t\tjpc_pchg_destroy(pchg);\n\t\t}\n\t}\n\tfor (pchgno = 0; pchgno < poc->numpchgs; ++pchgno) {\n\t\tif (!(pchg = jpc_pchg_copy(&poc->pchgs[pchgno]))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jpc_pchglist_insert(cp->pchglist, -1, pchg)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic jpc_fix_t jpc_calcabsstepsize(int stepsize, int numbits)\n{\n\tjpc_fix_t absstepsize;\n\tint n;\n\n\tabsstepsize = jpc_inttofix(1);\n\tn = JPC_FIX_FRACBITS - 11;\n\tabsstepsize |= (n >= 0) ? (JPC_QCX_GETMANT(stepsize) << n) :\n\t  (JPC_QCX_GETMANT(stepsize) >> (-n));\n\tn = numbits - JPC_QCX_GETEXPN(stepsize);\n\tabsstepsize = (n >= 0) ? (absstepsize << n) : (absstepsize >> (-n));\n\treturn absstepsize;\n}\n\nstatic void jpc_dequantize(jas_matrix_t *x, jpc_fix_t absstepsize)\n{\n\tint i;\n\tint j;\n\tint t;\n\n\tassert(absstepsize >= 0);\n\tif (absstepsize == jpc_inttofix(1)) {\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < jas_matrix_numrows(x); ++i) {\n\t\tfor (j = 0; j < jas_matrix_numcols(x); ++j) {\n\t\t\tt = jas_matrix_get(x, i, j);\n\t\t\tif (t) {\n\t\t\t\tt = jpc_fix_mul(t, absstepsize);\n\t\t\t} else {\n\t\t\t\tt = 0;\n\t\t\t}\n\t\t\tjas_matrix_set(x, i, j, t);\n\t\t}\n\t}\n\n}\n\nstatic void jpc_undo_roi(jas_matrix_t *x, int roishift, int bgshift, int numbps)\n{\n\tint i;\n\tint j;\n\tint thresh;\n\tjpc_fix_t val;\n\tjpc_fix_t mag;\n\tbool warn;\n\tuint_fast32_t mask;\n\n\tif (roishift < 0) {\n\t\t/* We could instead return an error here. */\n\t\t/* I do not think it matters much. */\n\t\tjas_eprintf(\"warning: forcing negative ROI shift to zero \"\n\t\t  \"(bitstream is probably corrupt)\\n\");\n\t\troishift = 0;\n\t}\n\tif (roishift == 0 && bgshift == 0) {\n\t\treturn;\n\t}\n\tthresh = 1 << roishift;\n\n\twarn = false;\n\tfor (i = 0; i < jas_matrix_numrows(x); ++i) {\n\t\tfor (j = 0; j < jas_matrix_numcols(x); ++j) {\n\t\t\tval = jas_matrix_get(x, i, j);\n\t\t\tmag = JAS_ABS(val);\n\t\t\tif (mag >= thresh) {\n\t\t\t\t/* We are dealing with ROI data. */\n\t\t\t\tmag >>= roishift;\n\t\t\t\tval = (val < 0) ? (-mag) : mag;\n\t\t\t\tjas_matrix_set(x, i, j, val);\n\t\t\t} else {\n\t\t\t\t/* We are dealing with non-ROI (i.e., background) data. */\n\t\t\t\tmag <<= bgshift;\n\t\t\t\tmask = (JAS_CAST(uint_fast32_t, 1) << numbps) - 1;\n\t\t\t\t/* Perform a basic sanity check on the sample value. */\n\t\t\t\t/* Some implementations write garbage in the unused\n\t\t\t\t  most-significant bit planes introduced by ROI shifting.\n\t\t\t\t  Here we ensure that any such bits are masked off. */\n\t\t\t\tif (mag & (~mask)) {\n\t\t\t\t\tif (!warn) {\n\t\t\t\t\t\tjas_eprintf(\"warning: possibly corrupt code stream\\n\");\n\t\t\t\t\t\twarn = true;\n\t\t\t\t\t}\n\t\t\t\t\tmag &= mask;\n\t\t\t\t}\n\t\t\t\tval = (val < 0) ? (-mag) : mag;\n\t\t\t\tjas_matrix_set(x, i, j, val);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic jpc_dec_t *jpc_dec_create(jpc_dec_importopts_t *impopts, jas_stream_t *in)\n{\n\tjpc_dec_t *dec;\n\n\tif (!(dec = jas_malloc(sizeof(jpc_dec_t)))) {\n\t\treturn 0;\n\t}\n\n\tdec->image = 0;\n\tdec->xstart = 0;\n\tdec->ystart = 0;\n\tdec->xend = 0;\n\tdec->yend = 0;\n\tdec->tilewidth = 0;\n\tdec->tileheight = 0;\n\tdec->tilexoff = 0;\n\tdec->tileyoff = 0;\n\tdec->numhtiles = 0;\n\tdec->numvtiles = 0;\n\tdec->numtiles = 0;\n\tdec->tiles = 0;\n\tdec->curtile = 0;\n\tdec->numcomps = 0;\n\tdec->in = in;\n\tdec->cp = 0;\n\tdec->maxlyrs = impopts->maxlyrs;\n\tdec->maxpkts = impopts->maxpkts;\ndec->numpkts = 0;\n\tdec->ppmseqno = 0;\n\tdec->state = 0;\n\tdec->cmpts = 0;\n\tdec->pkthdrstreams = 0;\n\tdec->ppmstab = 0;\n\tdec->curtileendoff = 0;\n\n\treturn dec;\n}\n\nstatic void jpc_dec_destroy(jpc_dec_t *dec)\n{\n\tif (dec->cstate) {\n\t\tjpc_cstate_destroy(dec->cstate);\n\t}\n\tif (dec->pkthdrstreams) {\n\t\tjpc_streamlist_destroy(dec->pkthdrstreams);\n\t}\n\tif (dec->image) {\n\t\tjas_image_destroy(dec->image);\n\t}\n\n\tif (dec->cp) {\n\t\tjpc_dec_cp_destroy(dec->cp);\n\t}\n\n\tif (dec->cmpts) {\n\t\tjas_free(dec->cmpts);\n\t}\n\n\tif (dec->tiles) {\n\t\tjas_free(dec->tiles);\n\t}\n\n\tjas_free(dec);\n}\n\n/******************************************************************************\\\n*\n\\******************************************************************************/\n\nvoid jpc_seglist_insert(jpc_dec_seglist_t *list, jpc_dec_seg_t *ins, jpc_dec_seg_t *node)\n{\n\tjpc_dec_seg_t *prev;\n\tjpc_dec_seg_t *next;\n\n\tprev = ins;\n\tnode->prev = prev;\n\tnext = prev ? (prev->next) : 0;\n\tnode->prev = prev;\n\tnode->next = next;\n\tif (prev) {\n\t\tprev->next = node;\n\t} else {\n\t\tlist->head = node;\n\t}\n\tif (next) {\n\t\tnext->prev = node;\n\t} else {\n\t\tlist->tail = node;\n\t}\n}\n\nvoid jpc_seglist_remove(jpc_dec_seglist_t *list, jpc_dec_seg_t *seg)\n{\n\tjpc_dec_seg_t *prev;\n\tjpc_dec_seg_t *next;\n\n\tprev = seg->prev;\n\tnext = seg->next;\n\tif (prev) {\n\t\tprev->next = next;\n\t} else {\n\t\tlist->head = next;\n\t}\n\tif (next) {\n\t\tnext->prev = prev;\n\t} else {\n\t\tlist->tail = prev;\n\t}\n\tseg->prev = 0;\n\tseg->next = 0;\n}\n\njpc_dec_seg_t *jpc_seg_alloc()\n{\n\tjpc_dec_seg_t *seg;\n\n\tif (!(seg = jas_malloc(sizeof(jpc_dec_seg_t)))) {\n\t\treturn 0;\n\t}\n\tseg->prev = 0;\n\tseg->next = 0;\n\tseg->passno = -1;\n\tseg->numpasses = 0;\n\tseg->maxpasses = 0;\n\tseg->type = JPC_SEG_INVALID;\n\tseg->stream = 0;\n\tseg->cnt = 0;\n\tseg->complete = 0;\n\tseg->lyrno = -1;\n\treturn seg;\n}\n\nvoid jpc_seg_destroy(jpc_dec_seg_t *seg)\n{\n\tif (seg->stream) {\n\t\tjas_stream_close(seg->stream);\n\t}\n\tjas_free(seg);\n}\n\nstatic int jpc_dec_dump(jpc_dec_t *dec, FILE *out)\n{\n\tjpc_dec_tile_t *tile;\n\tint tileno;\n\tjpc_dec_tcomp_t *tcomp;\n\tint compno;\n\tjpc_dec_rlvl_t *rlvl;\n\tint rlvlno;\n\tjpc_dec_band_t *band;\n\tint bandno;\n\tjpc_dec_prc_t *prc;\n\tint prcno;\n\tjpc_dec_cblk_t *cblk;\n\tint cblkno;\n\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles;\n\t  ++tileno, ++tile) {\n\t\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t\t  ++compno, ++tcomp) {\n\t\t\tfor (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno <\n\t\t\t  tcomp->numrlvls; ++rlvlno, ++rlvl) {\n\t\t\t\tfprintf(out, \"RESOLUTION LEVEL %d\\n\", rlvlno);\n\t\t\t\tfprintf(out, \"xs =%\"PRIuFAST32\", ys = %\"PRIuFAST32\", xe = %\"PRIuFAST32\", ye = %\"PRIuFAST32\", w = %\"PRIuFAST32\", h = %\"PRIuFAST32\"\\n\",\n\t\t\t\t  rlvl->xstart, rlvl->ystart, rlvl->xend, rlvl->yend, rlvl->xend -\n\t\t\t\t  rlvl->xstart, rlvl->yend - rlvl->ystart);\n\t\t\t\tfor (bandno = 0, band = rlvl->bands;\n\t\t\t\t  bandno < rlvl->numbands; ++bandno, ++band) {\n\t\t\t\t\tfprintf(out, \"BAND %d\\n\", bandno);\n\t\t\t\t\tfprintf(out, \"xs =%\"PRIiFAST32\", ys = %\"PRIiFAST32\", xe = %\"PRIiFAST32\", ye = %\"PRIiFAST32\", w = %\"PRIiFAST32\", h = %\"PRIiFAST32\"\\n\",\n\t\t\t\t\t  jas_seq2d_xstart(band->data), jas_seq2d_ystart(band->data), jas_seq2d_xend(band->data),\n\t\t\t\t\t  jas_seq2d_yend(band->data), jas_seq2d_xend(band->data) - jas_seq2d_xstart(band->data),\n\t\t\t\t\t  jas_seq2d_yend(band->data) - jas_seq2d_ystart(band->data));\n\t\t\t\t\tfor (prcno = 0, prc = band->prcs;\n\t\t\t\t\t  prcno < rlvl->numprcs; ++prcno,\n\t\t\t\t\t  ++prc) {\n\t\t\t\t\t\tfprintf(out, \"CODE BLOCK GROUP %d\\n\", prcno);\n\t\t\t\t\t\tfprintf(out, \"xs =%\"PRIuFAST32\", ys = %\"PRIuFAST32\", xe = %\"PRIuFAST32\", ye = %\"PRIuFAST32\", w = %\"PRIuFAST32\", h = %\"PRIuFAST32\"\\n\",\n\t\t\t\t\t\t  prc->xstart, prc->ystart, prc->xend, prc->yend, prc->xend -\n\t\t\t\t\t\t  prc->xstart, prc->yend - prc->ystart);\n\t\t\t\t\t\tfor (cblkno = 0, cblk =\n\t\t\t\t\t\t  prc->cblks; cblkno <\n\t\t\t\t\t\t  prc->numcblks; ++cblkno,\n\t\t\t\t\t\t  ++cblk) {\n\t\t\t\t\t\t\tfprintf(out, \"CODE BLOCK %d\\n\", cblkno);\n\t\t\t\t\t\t\tfprintf(out, \"xs =%\"PRIiFAST32\", ys = %\"PRIiFAST32\", xe = %\"PRIiFAST32\", ye = %\"PRIiFAST32\", w = %\"PRIiFAST32\", h = %\"PRIiFAST32\"\\n\",\n\t\t\t\t\t\t\t  jas_seq2d_xstart(cblk->data), jas_seq2d_ystart(cblk->data), jas_seq2d_xend(cblk->data),\n\t\t\t\t\t\t\t  jas_seq2d_yend(cblk->data), jas_seq2d_xend(cblk->data) - jas_seq2d_xstart(cblk->data),\n\t\t\t\t\t\t\t  jas_seq2d_yend(cblk->data) - jas_seq2d_ystart(cblk->data));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\njpc_streamlist_t *jpc_streamlist_create()\n{\n\tjpc_streamlist_t *streamlist;\n\tint i;\n\n\tif (!(streamlist = jas_malloc(sizeof(jpc_streamlist_t)))) {\n\t\treturn 0;\n\t}\n\tstreamlist->numstreams = 0;\n\tstreamlist->maxstreams = 100;\n\tif (!(streamlist->streams = jas_alloc2(streamlist->maxstreams,\n\t  sizeof(jas_stream_t *)))) {\n\t\tjas_free(streamlist);\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < streamlist->maxstreams; ++i) {\n\t\tstreamlist->streams[i] = 0;\n\t}\n\treturn streamlist;\n}\n\nint jpc_streamlist_insert(jpc_streamlist_t *streamlist, int streamno,\n  jas_stream_t *stream)\n{\n\tjas_stream_t **newstreams;\n\tint newmaxstreams;\n\tint i;\n\t/* Grow the array of streams if necessary. */\n\tif (streamlist->numstreams >= streamlist->maxstreams) {\n\t\tnewmaxstreams = streamlist->maxstreams + 1024;\n\t\tif (!(newstreams = jas_realloc2(streamlist->streams,\n\t\t  (newmaxstreams + 1024), sizeof(jas_stream_t *)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (i = streamlist->numstreams; i < streamlist->maxstreams; ++i) {\n\t\t\tstreamlist->streams[i] = 0;\n\t\t}\n\t\tstreamlist->maxstreams = newmaxstreams;\n\t\tstreamlist->streams = newstreams;\n\t}\n\tif (streamno != streamlist->numstreams) {\n\t\t/* Can only handle insertion at start of list. */\n\t\treturn -1;\n\t}\n\tstreamlist->streams[streamno] = stream;\n\t++streamlist->numstreams;\n\treturn 0;\n}\n\njas_stream_t *jpc_streamlist_remove(jpc_streamlist_t *streamlist, int streamno)\n{\n\tjas_stream_t *stream;\n\tint i;\n\tif (streamno >= streamlist->numstreams) {\n\t\tabort();\n\t}\n\tstream = streamlist->streams[streamno];\n\tfor (i = streamno + 1; i < streamlist->numstreams; ++i) {\n\t\tstreamlist->streams[i - 1] = streamlist->streams[i];\n\t}\n\t--streamlist->numstreams;\n\treturn stream;\n}\n\nvoid jpc_streamlist_destroy(jpc_streamlist_t *streamlist)\n{\n\tint streamno;\n\tif (streamlist->streams) {\n\t\tfor (streamno = 0; streamno < streamlist->numstreams;\n\t\t  ++streamno) {\n\t\t\tjas_stream_close(streamlist->streams[streamno]);\n\t\t}\n\t\tjas_free(streamlist->streams);\n\t}\n\tjas_free(streamlist);\n}\n\njas_stream_t *jpc_streamlist_get(jpc_streamlist_t *streamlist, int streamno)\n{\n\tassert(streamno < streamlist->numstreams);\n\treturn streamlist->streams[streamno];\n}\n\nint jpc_streamlist_numstreams(jpc_streamlist_t *streamlist)\n{\n\treturn streamlist->numstreams;\n}\n\njpc_ppxstab_t *jpc_ppxstab_create()\n{\n\tjpc_ppxstab_t *tab;\n\n\tif (!(tab = jas_malloc(sizeof(jpc_ppxstab_t)))) {\n\t\treturn 0;\n\t}\n\ttab->numents = 0;\n\ttab->maxents = 0;\n\ttab->ents = 0;\n\treturn tab;\n}\n\nvoid jpc_ppxstab_destroy(jpc_ppxstab_t *tab)\n{\n\tint i;\n\tfor (i = 0; i < tab->numents; ++i) {\n\t\tjpc_ppxstabent_destroy(tab->ents[i]);\n\t}\n\tif (tab->ents) {\n\t\tjas_free(tab->ents);\n\t}\n\tjas_free(tab);\n}\n\nint jpc_ppxstab_grow(jpc_ppxstab_t *tab, int maxents)\n{\n\tjpc_ppxstabent_t **newents;\n\tif (tab->maxents < maxents) {\n\t\tnewents = (tab->ents) ? jas_realloc2(tab->ents, maxents,\n\t\t  sizeof(jpc_ppxstabent_t *)) : jas_alloc2(maxents, sizeof(jpc_ppxstabent_t *));\n\t\tif (!newents) {\n\t\t\treturn -1;\n\t\t}\n\t\ttab->ents = newents;\n\t\ttab->maxents = maxents;\n\t}\n\treturn 0;\n}\n\nint jpc_ppxstab_insert(jpc_ppxstab_t *tab, jpc_ppxstabent_t *ent)\n{\n\tint inspt;\n\tint i;\n\n\tfor (i = 0; i < tab->numents; ++i) {\n\t\tif (tab->ents[i]->ind > ent->ind) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tinspt = i;\n\n\tif (tab->numents >= tab->maxents) {\n\t\tif (jpc_ppxstab_grow(tab, tab->maxents + 128)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tfor (i = tab->numents; i > inspt; --i) {\n\t\ttab->ents[i] = tab->ents[i - 1];\n\t}\n\ttab->ents[i] = ent;\n\t++tab->numents;\n\n\treturn 0;\n}\n\njpc_streamlist_t *jpc_ppmstabtostreams(jpc_ppxstab_t *tab)\n{\n\tjpc_streamlist_t *streams;\n\tuchar *dataptr;\n\tuint_fast32_t datacnt;\n\tuint_fast32_t tpcnt;\n\tjpc_ppxstabent_t *ent;\n\tint entno;\n\tjas_stream_t *stream;\n\tint n;\n\n\tif (!(streams = jpc_streamlist_create())) {\n\t\tgoto error;\n\t}\n\n\tif (!tab->numents) {\n\t\treturn streams;\n\t}\n\n\tentno = 0;\n\tent = tab->ents[entno];\n\tdataptr = ent->data;\n\tdatacnt = ent->len;\n\tfor (;;) {\n\n\t\t/* Get the length of the packet header data for the current\n\t\t  tile-part. */\n\t\tif (datacnt < 4) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (!(stream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (jpc_streamlist_insert(streams, jpc_streamlist_numstreams(streams),\n\t\t  stream)) {\n\t\t\tgoto error;\n\t\t}\n\t\ttpcnt = (dataptr[0] << 24) | (dataptr[1] << 16) | (dataptr[2] << 8)\n\t\t  | dataptr[3];\n\t\tdatacnt -= 4;\n\t\tdataptr += 4;\n\n\t\t/* Get the packet header data for the current tile-part. */\n\t\twhile (tpcnt) {\n\t\t\tif (!datacnt) {\n\t\t\t\tif (++entno >= tab->numents) {\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tent = tab->ents[entno];\n\t\t\t\tdataptr = ent->data;\n\t\t\t\tdatacnt = ent->len;\n\t\t\t}\n\t\t\tn = JAS_MIN(tpcnt, datacnt);\n\t\t\tif (jas_stream_write(stream, dataptr, n) != n) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\ttpcnt -= n;\n\t\t\tdataptr += n;\n\t\t\tdatacnt -= n;\n\t\t}\n\t\tjas_stream_rewind(stream);\n\t\tif (!datacnt) {\n\t\t\tif (++entno >= tab->numents) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tent = tab->ents[entno];\n\t\t\tdataptr = ent->data;\n\t\t\tdatacnt = ent->len;\n\t\t}\n\t}\n\n\treturn streams;\n\nerror:\n\tif (streams) {\n\t\tjpc_streamlist_destroy(streams);\n\t}\n\treturn 0;\n}\n\nint jpc_pptstabwrite(jas_stream_t *out, jpc_ppxstab_t *tab)\n{\n\tint i;\n\tjpc_ppxstabent_t *ent;\n\tfor (i = 0; i < tab->numents; ++i) {\n\t\tent = tab->ents[i];\n\t\tif (jas_stream_write(out, ent->data, ent->len) != JAS_CAST(int, ent->len)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\njpc_ppxstabent_t *jpc_ppxstabent_create()\n{\n\tjpc_ppxstabent_t *ent;\n\tif (!(ent = jas_malloc(sizeof(jpc_ppxstabent_t)))) {\n\t\treturn 0;\n\t}\n\tent->data = 0;\n\tent->len = 0;\n\tent->ind = 0;\n\treturn ent;\n}\n\nvoid jpc_ppxstabent_destroy(jpc_ppxstabent_t *ent)\n{\n\tif (ent->data) {\n\t\tjas_free(ent->data);\n\t}\n\tjas_free(ent);\n}\n"], "filenames": ["src/libjasper/base/jas_image.c", "src/libjasper/include/jasper/jas_image.h", "src/libjasper/jpc/jpc_dec.c"], "buggy_code_start_loc": [79, 81, 1093], "buggy_code_end_loc": [656, 400, 1099], "fixing_code_start_loc": [80, 82, 1094], "fixing_code_end_loc": [676, 405, 1108], "type": "NVD-CWE-Other", "message": "The jpc_irct and jpc_iict functions in jpc_mct.c in JasPer before 1.900.14 allow remote attackers to cause a denial of service (assertion failure).", "other": {"cve": {"id": "CVE-2016-9389", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-23T18:59:00.663", "lastModified": "2019-01-16T19:29:11.967", "vulnStatus": "Modified", "evaluatorComment": "<a href=\"http://cwe.mitre.org/data/definitions/617.html\">CWE-617: Reachable Assertion</a>", "descriptions": [{"lang": "en", "value": "The jpc_irct and jpc_iict functions in jpc_mct.c in JasPer before 1.900.14 allow remote attackers to cause a denial of service (assertion failure)."}, {"lang": "es", "value": "Las funciones jpc_irct y jpc_iict en jpc_mct.c en JasPer en versiones anteriores a 1.900.14 permiten a atacantes remotos provocar una denegaci\u00f3n de servicio (fallo de aserci\u00f3n)."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jasper_project:jasper:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.900.13", "matchCriteriaId": "DD936921-2D82-49F2-9D8E-046DBBF2A9EC"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2016/11/17/1", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "VDB Entry"]}, {"url": "http://www.securityfocus.com/bid/94371", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:1208", "source": "cve@mitre.org"}, {"url": "https://blogs.gentoo.org/ago/2016/11/16/jasper-multiple-assertion-failure", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1396963", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/mdadams/jasper/commit/dee11ec440d7908d1daf69f40a3324b27cf213ba", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3693-1/", "source": "cve@mitre.org"}, {"url": "https://www.oracle.com/technetwork/security-advisory/cpujan2019-5072801.html", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/mdadams/jasper/commit/dee11ec440d7908d1daf69f40a3324b27cf213ba"}}