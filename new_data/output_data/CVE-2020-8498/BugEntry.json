{"buggy_code": ["<?php\n/**\n * GistPress\n *\n * @package   GistPress\n * @author    Brady Vercher <brady@blazersix.com>\n * @author    Gary Jones\n * @copyright Copyright (c) 2012, Blazer Six, Inc.\n * @license   GPL-2.0+\n */\n\n/**\n * The main plugin class.\n *\n * @package GistPress\n * @author Brady Vercher <brady@blazersix.com>\n * @author Gary Jones\n */\nclass GistPress {\n\t/**\n\t * Logger object.\n\t *\n\t * @var object\n\t */\n\tprotected $logger = null;\n\n\t/**\n\t * Toggle to short-circuit shortcode output and delete its corresponding\n\t * transient so output can be regenerated the next time it is run.\n\t *\n\t * @var bool\n\t */\n\tprotected $delete_shortcode_transients = false;\n\n\t/**\n\t * Sets a logger instance on the object.\n\t *\n\t * Since logging is optional, the dependency injection is done via this\n\t * method, instead of being required through a constructor.\n\t *\n\t * Under PSR-1, this method would be called setLogger().\n\t *\n\t * @see https://github.com/php-fig/log/blob/master/Psr/Log/LoggerAwareInterface.php\n\t *\n\t * @since 1.1.0\n\t *\n\t * @param object $logger Logger object.\n\t */\n\tpublic function set_logger( $logger ) {\n\t\t$this->logger = $logger;\n\t}\n\n\t/**\n\t * Return logger instance.\n\t *\n\t * Under PSR-1, this method would be called getLogger().\n\t *\n\t * @since 1.1.0\n\t *\n\t * @return object\n\t */\n\tpublic function get_logger() {\n\t\treturn $this->logger;\n\t}\n\n\t/**\n\t * Set up the plugin.\n\t *\n\t * Adds a [gist] shortcode to do the bulk of the heavy lifting. An embed\n\t * handler is registered to mimic oEmbed functionality, but it relies on\n\t * the shortcode for processing.\n\t *\n\t * Supported formats:\n\t *\n\t * * Old link: https://gist.github.com/{{id}}#file_{{filename}}\n\t * * Old link with username: https://gist.github.com/{{user}}/{{id}}#file_{{filename}}\n\t * * New bookmark: https://gist.github.com/{{id}}#file-{{file_slug}}\n\t * * New bookmark with username: https://gist.github.com/{{user}}/{{id}}#file-{{sanitized-filename}}\n\t *\n\t * @since 1.1.0\n\t */\n\tpublic function run() {\n\t\t$oembed_pattern = '#https://gist\\.github\\.com/(?:.*/)?([a-z0-9]+)(?:\\#file([_-])(.*))?#i';\n\t\twp_embed_register_handler( 'gist', $oembed_pattern, array( $this, 'wp_embed_handler' ) );\n\t\tadd_shortcode( 'gist', array( $this, 'shortcode' ) );\n\n\t\tadd_action( 'init', array( $this, 'style' ), 15 );\n\t\tadd_action( 'post_updated', array( $this, 'delete_gist_transients' ), 10, 3 );\n\t}\n\n\t/**\n\t * Register the Gist style sheet so it can be embedded once.\n\t *\n\t * @since 1.0.0\n\t */\n\tpublic function style() {\n\t\twp_register_style( 'gistpress', get_option( 'gistpress_stylesheet' ) );\n\t}\n\n\t/**\n\t * WP embed handler to generate a shortcode string from a Gist URL.\n\t *\n\t * Parses Gist URLs for oEmbed support. Returns the value as a shortcode\n\t * string to let the shortcode method handle processing. The value\n\t * returned also does not have wpautop() applied, which is a must for\n\t * source code.\n\t *\n\t * @since 1.0.0\n\t *\n\t * @param array $matches Search results against the regex pattern listed in `run()`.\n\t * @return string Shortcode.\n\t */\n\tpublic function wp_embed_handler( array $matches ) {\n\t\t$shortcode = '[gist';\n\n\t\tif ( isset( $matches[1] ) && ! empty( $matches[1] ) ) {\n\t\t\t$shortcode .= ' id=\"' . esc_attr( $matches[1] ) . '\"';\n\t\t}\n\n\t\t// Make specific to a single file.\n\t\tif ( isset( $matches[3] ) && ! empty( $matches[3] ) ) {\n\t\t\t$real_file_name = $this->get_file_name( $matches[3], $matches[2], $matches[1] );\n\t\t\tif ( $real_file_name ) {\n\t\t\t\t$shortcode .= ' file=\"' . esc_attr( $real_file_name ) . '\"';\n\t\t\t}\n\t\t}\n\n\t\t// This attribute added so we can identify if a oembed URL or direct shortcode was used.\n\t\t$shortcode .= ' oembed=\"1\"]';\n\n\t\treturn $shortcode;\n\t}\n\n\t/**\n\t * Gist shortcode.\n\t *\n\t * Works with secret Gists, too.\n\t *\n\t * Shortcode attributes:\n\t *\n\t * - id - The Gist id (found in the URL). The only required attribute.\n\t * - embed_stylesheet - Whether the external style sheet should be enqueued for output in the footer.\n\t *     * If the footer is too late, set to false and enqueue the 'github-gist' style before 'wp_head'.\n\t *     * Any custom styles should be added to the theme's style sheet.\n\t * - file - Name of a specific file in a Gist.\n\t * - highlight - Comma-separated list of line numbers to highlight.\n\t *     * Ranges can be specified. Ex: 2,4,6-10,12\n\t * - highlight_color - Background color of highlighted lines.\n\t *     * To change it globally, hook into the filter and supply a different color.\n\t * - lines - A range of lines to limit the Gist to.\n\t *     * Suited for single file Gists or shortcodes using the 'file' attribute.\n\t * - lines_start - A number to start counting from for line numbers.\n\t * - show_line_numbers - Whether line numbers should be displayed.\n\t * - show_meta - Whether the trailing meta information in default Gist embeds should be displayed.\n\t *\n\t * @since 1.0.0\n\t *\n\t * @uses GistPress::rebuild_shortcode() Rebuild shortcode string.\n\t * @uses GistPress::standardize_attributes() Set defaults and sanitize.\n\t * @uses GistPress::shortcode_hash() Get hash of attributes.\n\t * @uses GistPress::transient_key() Transient key name.\n\t * @uses GistPress::debug_log() Potentially log a debug message.\n\t * @uses GistPress::debug_log() Gist retrieval failure string.\n\t *\n\t * @param array $rawattr Raw attributes of the shortcode.\n\t * @return string HTML content to display the Gist.\n\t */\n\tpublic function shortcode( array $rawattr ) {\n\t\t$shortcode = $this->rebuild_shortcode( $rawattr );\n\n\t\t$attr = $this->standardize_attributes( $rawattr );\n\n\t\t$shortcode_hash = $this->shortcode_hash( 'gist', $attr );\n\n\t\t// Short-circuit the shortcode output and just delete the transient.\n\t\t// This is set to true when posts are updated.\n\t\tif ( $this->delete_shortcode_transients ) {\n\t\t\tdelete_transient( $this->transient_key( $shortcode_hash ) );\n\t\t\tdelete_transient( $this->gist_files_transient_key( $attr['id'] ) );\n\n\t\t\treturn '';\n\t\t}\n\n\t\t// Log what we're dealing with - title uses original attributes, but hashed against processed attributes.\n\t\t$this->debug_log( '<h2>' . $shortcode . '</h2>', $shortcode_hash );\n\n\t\t// Bail if the ID is not set.\n\t\tif ( empty( $attr['id'] ) ) {\n\t\t\t$this->debug_log( __( 'Shortcode did not have a required id attribute.', 'gistpress' ), $shortcode_hash );\n\t\t\treturn '';\n\t\t}\n\n\t\t$url = 'https://gist.github.com/' . $attr['id'];\n\t\t$json_url = $url . '.json';\n\n\t\tif ( is_feed() ) {\n\t\t\t$html = sprintf( '<a href=\"%s\" target=\"_blank\"><em>%s</em></a>', esc_url( $url ), __( 'View this code snippet on GitHub.', 'gistpress' ) );\n\n\t\t\t/**\n\t\t\t * Filter what is shown in feeds.\n\t\t\t *\n\t\t\t * @since 2.0.0\n\t\t\t *\n\t\t\t * @param string $html Markup to show in feeds.\n\t\t\t */\n\t\t\treturn apply_filters( 'gistpress_feed_html', $html );\n\t\t}\n\n\t\t$html = $this->get_gist_html( $json_url, $attr );\n\n\t\tif ( $this->unknown() === $html ) {\n\t\t\treturn make_clickable( $url );\n\t\t}\n\n\t\t// If there was a result, return it.\n\t\tif ( $html ) {\n\t\t\tif ( $attr['embed_stylesheet'] ) {\n\t\t\t\twp_enqueue_style( 'gistpress' );\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Filter the output HTML.\n\t\t\t *\n\t\t\t * @since 2.0.0\n\t\t\t *\n\t\t\t * @param string $html The output HTML.\n\t\t\t * @param string $url  The URL to the Gist.\n\t\t\t * @param array  $attr Shortcode attributes, standardized.\n\t\t\t * @param int    $id   Post ID.\n\t\t\t */\n\t\t\t$html = apply_filters( 'gistpress_html', $html, $url, $attr, get_the_ID() );\n\n\t\t\tforeach ( $attr as $key => $value ) {\n\t\t\t\t$message  = '<strong>' . $key . __( ' (shortcode attribute)', 'gistpress' ) . ':</strong> ';\n\t\t\t\t$message .= is_scalar( $value ) ? $value : print_r( $value, true );\n\t\t\t\t$this->debug_log( $message, $shortcode_hash );\n\t\t\t}\n\t\t\t$this->debug_log( '<strong>Gist:</strong><br />' . $html, $shortcode_hash );\n\n\t\t\treturn $html;\n\t\t}\n\n\t\treturn '';\n\t}\n\n\t/**\n\t * Helper method to determine if a shortcode attribute is true or false.\n\t *\n\t * @since 1.1.0\n\t *\n\t * @param string|int|bool $var Attribute value.\n\t * @return bool\n\t */\n\tpublic function shortcode_bool( $var ) {\n\t\t$falsey = array( 'false', '0', 'no', 'n' );\n\n\t\treturn ( ! $var || in_array( strtolower( $var ), $falsey, true ) ) ? false : true;\n\t}\n\n\t/**\n\t * Parses and expands the shortcode 'highlight' attribute and returns it\n\t * in a usable format.\n\t *\n\t * @since 1.1.0\n\t *\n\t * @param string $line_numbers Comma-separated list of line numbers and ranges.\n\t * @return array|null List of line numbers, or null if no line numbers given\n\t */\n\tpublic function parse_highlight_arg( $line_numbers ) {\n\t\tif ( empty( $line_numbers ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Determine which lines should be highlighted.\n\t\t$highlight = array_map( 'trim', explode( ',', $line_numbers ) );\n\n\t\t// Convert any ranges.\n\t\tforeach ( $highlight as $index => $num ) {\n\t\t\tif ( false !== strpos( $num, '-' ) ) {\n\t\t\t\tunset( $highlight[ $index ] );\n\n\t\t\t\t$range = array_map( 'trim', explode( '-', $num ) );\n\t\t\t\tforeach ( range( $range[0], $range[1] ) as $line ) {\n\t\t\t\t\tarray_push( $highlight, $line );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn array_unique( $highlight );\n\t}\n\n\t/**\n\t * Parses the shortcode 'lines' attribute into min and max values.\n\t *\n\t * @since 1.1.0\n\t *\n\t * @param string $line_numbers Range of line numbers separated by a dash.\n\t * @return array Associative array with min and max line numbers.\n\t */\n\tpublic function parse_line_number_arg( $line_numbers ) {\n\t\tif ( empty( $line_numbers ) ) {\n\t\t\treturn array( 'min' => 0, 'max' => 0 );\n\t\t}\n\n\t\tif ( false === strpos( $line_numbers, '-' ) ) {\n\t\t\t$range = array_fill_keys( array( 'min', 'max' ), absint( trim( $line_numbers ) ) );\n\t\t} else {\n\t\t\t$numbers = array_map( 'absint', array_map( 'trim', explode( '-', $line_numbers ) ) );\n\n\t\t\t$range = array(\n\t\t\t\t'min' => $numbers[0],\n\t\t\t\t'max' => $numbers[1],\n\t\t\t);\n\t\t}\n\n\t\treturn $range;\n\t}\n\n\t/**\n\t * Retrieve Gist HTML.\n\t *\n\t * Gist HTML can come from one of three different sources:\n\t *   Remote JSON endpoint,\n\t *   Transient,\n\t *   Post meta cache.\n\t *\n\t * When a Gist is initially requested, the HTML is fetched from the JSON\n\t * endpoint and cached in a post meta field. It is then processed to limit\n\t * line numbers, highlight specific lines, and add a few extra classes as\n\t * style hooks. The processed HTML is then stored in a transient using a\n\t * hash of the shortcodes attributes for the key.\n\t *\n\t * On subsequent requests, the HTML is fetched from the transient until it\n\t * expires, then it is requested from the remote URL again.\n\t *\n\t * In the event the HTML can't be fetched from the remote endpoint and the\n\t * transient has expired, the HTML is retrieved from the post meta backup.\n\t *\n\t * This algorithm allows Gist HTML to stay in sync with any changes GitHub\n\t * may make to their markup, while providing a local cache for faster\n\t * retrieval and a backup in case GitHub can't be reached.\n\t *\n\t * @since 1.1.0\n\t *\n\t * @param string $url   The JSON endpoint for the Gist.\n\t * @param array  $args  List of shortcode attributes.\n\t * @return string Gist HTML or {{unknown}} if it could not be determined.\n\t */\n\tpublic function get_gist_html( $url, array $args ) {\n\t\t// Add a specific file from a Gist to the URL.\n\t\tif ( ! empty( $args['file'] ) ) {\n\t\t\t$url = add_query_arg( 'file', urlencode( $args['file'] ), $url );\n\t\t}\n\n\t\t$shortcode_hash = $this->shortcode_hash( 'gist', $args );\n\t\t$raw_key = '_gist_raw_' . md5( $url );\n\t\t$transient_key = $this->transient_key( $shortcode_hash );\n\n\t\t$html = get_transient( $transient_key );\n\n\t\tif ( empty( $html ) ) {\n\t\t\t$html = get_transient( $raw_key );\n\t\t\t$transient_expire = DAY_IN_SECONDS;\n\n\t\t\tif ( $html && $this->unknown() !== $html ) {\n\t\t\t\t$html = $this->process_gist_html( $html, $args );\n\t\t\t\t$this->debug_log( __( '<strong>Raw Source:</strong> Transient Cache', 'gistpress' ), $shortcode_hash );\n\t\t\t} else {\n\t\t\t\t// Retrieve raw html from Gist JSON endpoint.\n\t\t\t\t$json = $this->fetch_gist( $url );\n\n\t\t\t\tif ( ! empty( $json->div ) ) {\n\t\t\t\t\tset_transient( $raw_key, $json->div, $transient_expire );\n\n\t\t\t\t\t// Update the post meta fallback. See http://core.trac.wordpress.org/ticket/21767 for details.\n\t\t\t\t\tupdate_post_meta( get_the_ID(), $raw_key, addslashes( $json->div ) );\n\n\t\t\t\t\t$html = $this->process_gist_html( $json->div, $args );\n\n\t\t\t\t\t$this->debug_log( __( '<strong>Raw Source:</strong> Remote JSON Endpoint - ', 'gistpress' ) . $url, $shortcode_hash );\n\t\t\t\t\t$this->debug_log( __( '<strong>Output Source:</strong> Processed the raw source.', 'gistpress' ), $shortcode_hash );\n\t\t\t\t}\n\n\t\t\t\t// Update the style sheet reference.\n\t\t\t\tif ( ! empty( $json->stylesheet ) ) {\n\t\t\t\t\tupdate_option( 'gistpress_stylesheet', $json->stylesheet );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Failures are cached, too. Update the post to attempt to fetch again.\n\t\t\t$html = ( $html ) ? $html : $this->unknown();\n\n\t\t\tif ( $this->unknown() === $html && ( $fallback = get_post_meta( get_the_ID(), $raw_key, true ) ) ) {\n\t\t\t\t// Return the fallback instead of the string representing unknown.\n\t\t\t\t$html = $this->process_gist_html( $fallback, $args );\n\n\t\t\t\t// Cache the fallback for an hour.\n\t\t\t\t$transient_expire = HOUR_IN_SECONDS;\n\n\t\t\t\t$this->debug_log( __( '<strong>Raw Source:</strong> Post Meta Fallback', 'gistpress' ), $shortcode_hash );\n\t\t\t\t$this->debug_log( __( '<strong>Output Source:</strong> Processed Raw Source', 'gistpress' ), $shortcode_hash );\n\t\t\t} elseif ( $this->unknown() === $html ) {\n\t\t\t\t$this->debug_log( '<strong style=\"color: #e00;\">' . __( 'Remote call and transient failed and fallback was empty.', 'gistpress' ) . '</strong>', $shortcode_hash );\n\t\t\t}\n\n\t\t\t// Cache the processed HTML.\n\t\t\tset_transient( $transient_key, $html, $transient_expire );\n\t\t} else {\n\t\t\t$this->debug_log( __( '<strong>Output Source:</strong> Transient Cache', 'gistpress' ), $shortcode_hash );\n\t\t}\n\n\t\t$this->debug_log( '<strong>' . __( 'JSON Endpoint:', 'gistpress' ) . '</strong> ' . $url, $shortcode_hash );\n\t\t$this->debug_log( '<strong>' . __( 'Raw Key (Transient & Post Meta):', 'gistpress' ) . '</strong> ' . $raw_key, $shortcode_hash );\n\t\t$this->debug_log( '<strong>' . __( 'Processed Output Key (Transient):', 'gistpress' ) . '</strong> ' . $transient_key, $shortcode_hash );\n\n\t\t// Strip unnecessary elements from HTML output.\n\t\t$html = preg_replace( '/^<!DOCTYPE.+?>/i', '', str_ireplace( array( '<html>', '</html>', '<body>', '</body>' ), '', $html ) );\n\n\t\treturn $html;\n\t}\n\n\t/**\n\t * Fetch Gist data from its JSON endpoint.\n\t *\n\t * @since 1.1.0\n\t *\n\t * @param string $url Gist JSON endpoint.\n\t * @return object|bool Gist JSON object, or false if anything except a HTTP\n\t *                     Status code of 200 was received.\n\t */\n\tpublic function fetch_gist( $url ) {\n\t\t$response = wp_remote_get( $url, array( 'sslverify' => false ) );\n\n\t\tif ( 200 === wp_remote_retrieve_response_code( $response ) ) {\n\t\t\treturn json_decode( wp_remote_retrieve_body( $response ) );\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Process the HTML returned from a Gist's JSON endpoint based on settings\n\t * passed through the shortcode.\n\t *\n\t * @since 1.1.0\n\t *\n\t * @param string $html HTML from the Gist's JSON endpoint.\n\t * @param array  $args List of shortcode attributes.\n\t * @return string Modified HTML.\n\t */\n\tpublic function process_gist_html( $html, array $args ) {\n\t\t// Remove the line number cell if it has been disabled.\n\t\tif ( ! $args['show_line_numbers'] ) {\n\t\t\t$html = preg_replace( '#<td id=\"[^\"]*\" class=\"blob-num js-line-number\" data-line-number=\"\\d+\"></td>#s', '', $html );\n\t\t}\n\n\t\t// Remove the meta section if it has been disabled.\n\t\tif ( ! $args['show_meta'] ) {\n\t\t\t$html = preg_replace( '#<div class=\"gist-meta\">.*?</div>#s', '', $html );\n\t\t}\n\n\t\tif ( ! class_exists( 'DOMDocument' ) ) {\n\t\t\treturn $html;\n\t\t}\n\n\t\t$dom = new DOMDocument();\n\t\t$dom->loadHTML( $html );\n\n\t\t$lines = $dom->getElementsByTagName( 'tr' );\n\n\t\tif ( ! empty( $args['highlight'] ) ) {\n\t\t\t// Flip to use isset() when looping through the lines.\n\t\t\t$highlight = array_flip( $args['highlight'] );\n\t\t}\n\n\t\t$lines_to_remove = array();\n\t\tforeach ( $lines as $key => $line ) {\n\t\t\t// Remove lines if they're not in the specified range and continue.\n\t\t\tif (\n\t\t\t\t( $args['lines']['min'] && $key < $args['lines']['min'] - 1 ) ||\n\t\t\t\t( $args['lines']['max'] && $key > $args['lines']['max'] - 1 )\n\t\t\t) {\n\t\t\t\t$lines_to_remove[] = $line;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Add classes for styling.\n\t\t\t$classes = array( 'line' );\n\n\t\t\tif ( isset( $highlight[ $key + 1 ] ) ) {\n\t\t\t\t$classes[] = 'line-highlight';\n\n\t\t\t\tif ( ! empty( $args['highlight_color'] ) ) {\n\t\t\t\t\t$style = 'background-color: ' . $args['highlight_color'] . ' !important';\n\n\t\t\t\t\tforeach ( $line->getElementsByTagName( 'td' ) as $cell ) {\n\t\t\t\t\t\t$value = $cell->getAttribute( 'style' );\n\t\t\t\t\t\t$value = empty( $value ) ? $style : $value . ';' . $style;\n\t\t\t\t\t\t$cell->setAttribute( 'style', $value );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Filter the classes applied to a line of the Gist.\n\t\t\t *\n\t\t\t * @since 2.0.0\n\t\t\t *\n\t\t\t * @param array $classes List of HTML class values.\n\t\t\t */\n\t\t\t$classes = apply_filters( 'gistpress_line_classes', $classes );\n\t\t\t$class = ( ! empty( $classes ) && is_array( $classes ) ) ? implode( ' ', $classes ) : '';\n\n\t\t\t$value = $line->getAttribute( 'class' );\n\t\t\t$value = empty( $value ) ? $class : $value . ' ' . $class;\n\t\t\t$line->setAttribute( 'class', $value );\n\t\t}\n\n\t\tforeach ( $lines_to_remove as $line ) {\n\t\t\t$line->parentNode->removeChild( $line );\n\t\t}\n\n\t\t$html = $dom->saveHTML();\n\n\t\t// Restrict the line number display if a range has been specified.\n\t\tif (\n\t\t\t$args['show_line_numbers'] &&\n\t\t\t( ( $args['lines']['min'] && $args['lines']['max'] ) || ! empty( $args['lines_start'] ) )\n\t\t) {\n\t\t\t$html = $this->process_gist_line_numbers( $html, $args['lines'], $args['lines_start'] );\n\t\t}\n\n\t\treturn $html;\n\t}\n\n\t/**\n\t * Removes line numbers from the Gist's HTML that fall outside the\n\t * supplied range and modifies the starting number if specified.\n\t *\n\t * @since 1.1.0\n\t *\n\t * @param string $html  HTML from the Gist's JSON endpoint.\n\t * @param array  $range Array of min and max values.\n\t * @param int    $start Optional. Line number to start counting at.\n\t * @return string Modified HTML.\n\t */\n\tpublic function process_gist_line_numbers( $html, array $range, $start = null ) {\n\t\t$start = empty( $start ) ? absint( $range['min'] ) : absint( $start );\n\n\t\t$dom = new DOMDocument();\n\t\t$dom->loadHTML( $html );\n\t\t$lines = $dom->getElementsByTagName( 'tr' );\n\n\t\tforeach ( $lines as $i => $line ) {\n\t\t\t$line\n\t\t\t\t->getElementsByTagName( 'td' )\n\t\t\t\t->item( 0 )\n\t\t\t\t->setAttribute( 'data-line-number', $start + $i );\n\t\t}\n\n\t\treturn $dom->saveHTML();\n\t}\n\n\t/**\n\t * Removes transients associated with Gists embedded in a post.\n\t *\n\t * Retrieves the keys of meta data associated with a post and deletes any\n\t * transients with a matching embed key.\n\t *\n\t * @since 1.1.0\n\t *\n\t * @param int     $post_id     Post ID.\n\t * @param WP_Post $post_after  Post object after update.\n\t * @param WP_Post $post_before Post object before update.\n\t */\n\tpublic function delete_gist_transients( $post_id, WP_Post $post_after, WP_Post $post_before ) {\n\t\t$this->delete_shortcode_transients = true;\n\n\t\t// Run the shortcodes to clear associated transients.\n\t\tdo_shortcode( $GLOBALS['wp_embed']->autoembed( $post_after->post_content ) );\n\t\tdo_shortcode( $GLOBALS['wp_embed']->autoembed( $post_before->post_content ) );\n\n\t\t// Delete raw transients whose keys match a post meta fallback.\n\t\t$keys = get_post_custom_keys( $post_id );\n\n\t\tif ( $keys ) {\n\t\t\tforeach ( $keys as $key ) {\n\t\t\t\tif ( 0 === strpos( $key, '_gist_raw_' ) ) {\n\t\t\t\t\tdelete_transient( $key );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Rebuild the original shortcode as a string with raw attributes.\n\t *\n\t * @since 1.1.1\n\t *\n\t * @param array $rawattr Raw attributes => values.\n\t * @return string Gist shortcode.\n\t */\n\tprotected function rebuild_shortcode( array $rawattr ) {\n\t\t$attrs = array();\n\t\tforeach ( $rawattr as $key => $value ) {\n\t\t\tif ( 'oembed' !== $key ) {\n\t\t\t\t$attrs[] = $key . '=\"' . $value . '\"';\n\t\t\t}\n\t\t}\n\t\treturn '[gist ' . implode( ' ', $attrs ) . ']';\n\t}\n\n\t/**\n\t * Set defaults and sanitize shortcode attributes and attribute values.\n\t *\n\t * @since 1.1.1\n\t *\n\t * @param array $rawattr Associative array of raw attributes => values.\n\t * @return array Standardized and sanitized shortcode attributes.\n\t */\n\tprotected function standardize_attributes( array $rawattr ) {\n\t\t/**\n\t\t * Filter the shortcode attributes defaults.\n\t\t *\n\t\t * @since 2.0.0\n\t\t *\n\t\t * @see standardize_attributes()\n\t\t *\n\t\t * @param array $gistpress_shortcode_defaults {\n\t\t * \tShortcode attributes defaults.\n\t\t *\n\t\t * \t@type bool   $embed_stylesheet  Filterable value to include style sheet or not. Default is true\n\t\t *                                      to include it.\n\t\t * \t@type string $file              File name within gist. Default is an empty string, indicating\n\t\t *                                      all files.\n\t\t * \t@type array  $highlight         Lines to highlight. Default is empty array, to highlight\n\t\t *                                      no lines.\n\t\t * \t@type string $highlight_color   Filterable hex color code. Default is #ffc.\n\t\t * \t@type string $id                Gist ID. Non-optional.\n\t\t * \t@type string $lines             Number of lines to show. Default is empty string, indicating\n\t\t *                                      all lines in the gist.\n\t\t * \t@type string $lines_start       Which line number to start from. Default is empty string,\n\t\t *                                      indicating line number 1.\n\t\t * \t@type bool   $show_line_numbers Show line numbers or not, default is true, to show line numbers.\n\t\t * \t@type bool   $show_meta         Show meta information or not, default is true, to show\n\t\t *                                      meta information.\n\t\t * }\n\t\t */\n\t\t$defaults = apply_filters(\n\t\t\t'gistpress_shortcode_defaults',\n\t\t\tarray(\n\n\t\t\t\t/**\n\t\t\t\t * Filter to include the style sheet or not.\n\t\t\t\t *\n\t\t\t\t * @since 2.0.0\n\t\t\t\t *\n\t\t\t\t * @param bool $gistpress_stylesheet_default Include default style sheet or not.\n\t\t\t\t *                                           Default is true, to include it.\n\t\t\t\t */\n\t\t\t\t'embed_stylesheet'  => apply_filters( 'gistpress_stylesheet_default', true ),\n\t\t\t\t'file'              => '',\n\t\t\t\t'highlight'         => array(),\n\n\t\t\t\t/**\n\t\t\t\t * Filter highlight color.\n\t\t\t\t *\n\t\t\t\t * @since 2.0.0\n\t\t\t\t *\n\t\t\t\t * @param string $gistpress_highlight_color Hex color code for highlighting lines.\n\t\t\t\t *                                          Default is `#ffc`.\n\t\t\t\t */\n\t\t\t\t'highlight_color'   => apply_filters( 'gistpress_highlight_color', '#ffc' ),\n\t\t\t\t'id'                => '',\n\t\t\t\t'lines'             => '',\n\t\t\t\t'lines_start'       => '',\n\t\t\t\t'show_line_numbers' => true,\n\t\t\t\t'show_meta'         => true,\n\t\t\t\t'oembed'            => 0, // Private use only.\n\t\t\t)\n\t\t);\n\n\t\t// Sanitize attributes.\n\t\t$attr = shortcode_atts( $defaults, $rawattr );\n\t\t$attr['embed_stylesheet']  = $this->shortcode_bool( $attr['embed_stylesheet'] );\n\t\t$attr['show_line_numbers'] = $this->shortcode_bool( $attr['show_line_numbers'] );\n\t\t$attr['show_meta']         = $this->shortcode_bool( $attr['show_meta'] );\n\t\t$attr['highlight']         = $this->parse_highlight_arg( $attr['highlight'] );\n\t\t$attr['lines']             = $this->parse_line_number_arg( $attr['lines'] );\n\n\t\treturn $attr;\n\t}\n\n\t/**\n\t * Try to determine the real file name from a sanitized file name.\n\t *\n\t * The new Gist \"bookmark\" URLs point to sanitized file names so that both\n\t * hyphen and period in a file name show up as a hyphen e.g. a filename of\n\t * foo.bar and foo-bar both appear in the bookmark URL as foo-bar. The\n\t * correct original filenames are listed in the JSON data for the overall\n\t * Gist, so this method does a call to that, and loops through the listed\n\t * file names to see if it can determine which file was meant.\n\t *\n\t * If a Gist has two files that both resolve to the same sanitized filename,\n\t * then we don't have any way to determine which one the other determined,\n\t * so we just return the first one we find. If that's incorrect, the author\n\t * can use the shortcode approach, which allows a specific file name to be\n\t * used.\n\t *\n\t * @since 2.1.0\n\t *\n\t * @param  string $sanitized_filename Sanitized filename, such as foo-bar-php.\n\t * @param  string $delimiter          Either underscore or hyphen.\n\t * @param  string $id                 Gist ID.\n\t * @return string                     Filename, or empty string if it couldn't be determined.\n\t */\n\tprotected function get_file_name( $sanitized_filename, $delimiter, $id ) {\n\t\t// Old style link - filename wasn't actually changed.\n\t\tif ( '_' === $delimiter ) {\n\t\t\treturn $sanitized_filename;\n\t\t}\n\n\t\t// New style bookmark - filename had . replaced with -\n\t\t// Means we have to go and look up what the filename could have been.\n\t\t$transient_key = $this->gist_files_transient_key( $id );\n\t\t$gist_files = get_transient( $transient_key );\n\n\t\tif ( ! $gist_files ) {\n\t\t\t$url = 'https://gist.github.com/' . $id . '.json';\n\t\t\t$json = $this->fetch_gist( $url );\n\n\t\t\tif ( $json && ! empty( $json->files ) ) {\n\t\t\t\t$gist_files = $json->files;\n\t\t\t\tset_transient( $transient_key, $gist_files, WEEK_IN_SECONDS );\n\t\t\t} else {\n\t\t\t\tset_transient( $transient_key, array(), MINUTE_IN_SECONDS * 15 );\n\t\t\t}\n\t\t}\n\n\t\t// If a gist has foo.bar.php and foo-bar.php, then we can't yet\n\t\t// determine which was actually wanted, since both give the same\n\t\t// bookmark URL. Here, we just return the first one we find.\n\t\tif ( ! empty( $gist_files ) ) {\n\t\t\tforeach ( $gist_files as $file ) {\n\t\t\t\tif ( str_replace( '.', '-', $file ) === $sanitized_filename ) {\n\t\t\t\t\treturn $file;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn '';\n\t}\n\n\t/**\n\t * Wrapper for a PSR-3 compatible logger.\n\t *\n\t * If no logger has been set via the set_logger() method on an instance of\n\t * this class, or WP_DEBUG is not enabled, then log messages quietly die\n\t * here.\n\t *\n\t * @since 1.1.0\n\t *\n\t * @param string $message A message to log for the current shortcode.\n\t * @param mixed  $id      Optional. An ID under which the message should be grouped.\n\t */\n\tprotected function debug_log( $message, $id = null ) {\n\t\tif ( defined( 'WP_DEBUG' ) && WP_DEBUG && isset( $this->logger ) ) {\n\t\t\t$this->logger->debug( $message, array( 'key' => $id ) );\n\t\t}\n\t}\n\n\t/**\n\t * Sort a shortcode's attributes by name and hash it for use as a cache\n\t * key and logger message grouping.\n\t *\n\t * @since 1.1.0\n\t *\n\t * @param string $tag  Shortcode tag, used as hash prefix.\n\t * @param array  $args Associative array of shortcode attributes.\n\t * @return string md5 hash as a 32-character hexadecimal number.\n\t */\n\tprotected function shortcode_hash( $tag, array $args ) {\n\t\tksort( $args );\n\t\treturn md5( $tag . '_' . serialize( $args ) );\n\t}\n\n\t/**\n\t * Get the transient key.\n\t *\n\t * @since 1.1.0\n\t *\n\t * @param string $identifier The identifier part of the key.\n\t * @return string Transient key name.\n\t */\n\tprotected function transient_key( $identifier ) {\n\t\treturn 'gist_html_' . $identifier;\n\t}\n\n\t/**\n\t * Get the transient key for a list of a Gist's files.\n\t *\n\t * @since 2.1.0\n\t *\n\t * @param string $gist_id The Gist id.\n\t * @return string Transient key name.\n\t */\n\tprotected function gist_files_transient_key( $gist_id ) {\n\t\treturn 'gist_files_' . md5( $gist_id );\n\t}\n\n\t/**\n\t * String to identify a failure when retrieving a Gist's HTML.\n\t *\n\t * @since 1.1.0\n\t *\n\t * @return string\n\t */\n\tprotected function unknown() {\n\t\treturn '{{unknown}}';\n\t}\n\n\t/**\n\t * Escape a regular expression replacement string.\n\t *\n\t * @since 2.0.2\n\t * @link http://www.procata.com/blog/archives/2005/11/13/two-preg_replace-escaping-gotchas/\n\t *\n\t * @param string $str String to escape.\n\t * @return string\n\t */\n\tpublic function preg_replace_quote( $str ) {\n\t\treturn preg_replace( '/(\\$|\\\\\\\\)(?=\\d)/', '\\\\\\\\$1', $str );\n\t}\n}\n"], "fixing_code": ["<?php\n/**\n * GistPress\n *\n * @package   GistPress\n * @author    Brady Vercher <brady@blazersix.com>\n * @author    Gary Jones\n * @copyright Copyright (c) 2012, Blazer Six, Inc.\n * @license   GPL-2.0+\n */\n\n/**\n * The main plugin class.\n *\n * @package GistPress\n * @author Brady Vercher <brady@blazersix.com>\n * @author Gary Jones\n */\nclass GistPress {\n\t/**\n\t * Logger object.\n\t *\n\t * @var object\n\t */\n\tprotected $logger = null;\n\n\t/**\n\t * Toggle to short-circuit shortcode output and delete its corresponding\n\t * transient so output can be regenerated the next time it is run.\n\t *\n\t * @var bool\n\t */\n\tprotected $delete_shortcode_transients = false;\n\n\t/**\n\t * Sets a logger instance on the object.\n\t *\n\t * Since logging is optional, the dependency injection is done via this\n\t * method, instead of being required through a constructor.\n\t *\n\t * Under PSR-1, this method would be called setLogger().\n\t *\n\t * @see https://github.com/php-fig/log/blob/master/Psr/Log/LoggerAwareInterface.php\n\t *\n\t * @since 1.1.0\n\t *\n\t * @param object $logger Logger object.\n\t */\n\tpublic function set_logger( $logger ) {\n\t\t$this->logger = $logger;\n\t}\n\n\t/**\n\t * Return logger instance.\n\t *\n\t * Under PSR-1, this method would be called getLogger().\n\t *\n\t * @since 1.1.0\n\t *\n\t * @return object\n\t */\n\tpublic function get_logger() {\n\t\treturn $this->logger;\n\t}\n\n\t/**\n\t * Set up the plugin.\n\t *\n\t * Adds a [gist] shortcode to do the bulk of the heavy lifting. An embed\n\t * handler is registered to mimic oEmbed functionality, but it relies on\n\t * the shortcode for processing.\n\t *\n\t * Supported formats:\n\t *\n\t * * Old link: https://gist.github.com/{{id}}#file_{{filename}}\n\t * * Old link with username: https://gist.github.com/{{user}}/{{id}}#file_{{filename}}\n\t * * New bookmark: https://gist.github.com/{{id}}#file-{{file_slug}}\n\t * * New bookmark with username: https://gist.github.com/{{user}}/{{id}}#file-{{sanitized-filename}}\n\t *\n\t * @since 1.1.0\n\t */\n\tpublic function run() {\n\t\t$oembed_pattern = '#https://gist\\.github\\.com/(?:.*/)?([a-z0-9]+)(?:\\#file([_-])(.*))?#i';\n\t\twp_embed_register_handler( 'gist', $oembed_pattern, array( $this, 'wp_embed_handler' ) );\n\t\tadd_shortcode( 'gist', array( $this, 'shortcode' ) );\n\n\t\tadd_action( 'init', array( $this, 'style' ), 15 );\n\t\tadd_action( 'post_updated', array( $this, 'delete_gist_transients' ), 10, 3 );\n\t}\n\n\t/**\n\t * Register the Gist style sheet so it can be embedded once.\n\t *\n\t * @since 1.0.0\n\t */\n\tpublic function style() {\n\t\twp_register_style( 'gistpress', get_option( 'gistpress_stylesheet' ) );\n\t}\n\n\t/**\n\t * WP embed handler to generate a shortcode string from a Gist URL.\n\t *\n\t * Parses Gist URLs for oEmbed support. Returns the value as a shortcode\n\t * string to let the shortcode method handle processing. The value\n\t * returned also does not have wpautop() applied, which is a must for\n\t * source code.\n\t *\n\t * @since 1.0.0\n\t *\n\t * @param array $matches Search results against the regex pattern listed in `run()`.\n\t * @return string Shortcode.\n\t */\n\tpublic function wp_embed_handler( array $matches ) {\n\t\t$shortcode = '[gist';\n\n\t\tif ( isset( $matches[1] ) && ! empty( $matches[1] ) ) {\n\t\t\t$shortcode .= ' id=\"' . esc_attr( $matches[1] ) . '\"';\n\t\t}\n\n\t\t// Make specific to a single file.\n\t\tif ( isset( $matches[3] ) && ! empty( $matches[3] ) ) {\n\t\t\t$real_file_name = $this->get_file_name( $matches[3], $matches[2], $matches[1] );\n\t\t\tif ( $real_file_name ) {\n\t\t\t\t$shortcode .= ' file=\"' . esc_attr( $real_file_name ) . '\"';\n\t\t\t}\n\t\t}\n\n\t\t// This attribute added so we can identify if a oembed URL or direct shortcode was used.\n\t\t$shortcode .= ' oembed=\"1\"]';\n\n\t\treturn $shortcode;\n\t}\n\n\t/**\n\t * Gist shortcode.\n\t *\n\t * Works with secret Gists, too.\n\t *\n\t * Shortcode attributes:\n\t *\n\t * - id - The Gist id (found in the URL). The only required attribute.\n\t * - embed_stylesheet - Whether the external style sheet should be enqueued for output in the footer.\n\t *     * If the footer is too late, set to false and enqueue the 'github-gist' style before 'wp_head'.\n\t *     * Any custom styles should be added to the theme's style sheet.\n\t * - file - Name of a specific file in a Gist.\n\t * - highlight - Comma-separated list of line numbers to highlight.\n\t *     * Ranges can be specified. Ex: 2,4,6-10,12\n\t * - highlight_color - Background color of highlighted lines.\n\t *     * To change it globally, hook into the filter and supply a different color.\n\t * - lines - A range of lines to limit the Gist to.\n\t *     * Suited for single file Gists or shortcodes using the 'file' attribute.\n\t * - lines_start - A number to start counting from for line numbers.\n\t * - show_line_numbers - Whether line numbers should be displayed.\n\t * - show_meta - Whether the trailing meta information in default Gist embeds should be displayed.\n\t *\n\t * @since 1.0.0\n\t *\n\t * @uses GistPress::rebuild_shortcode() Rebuild shortcode string.\n\t * @uses GistPress::standardize_attributes() Set defaults and sanitize.\n\t * @uses GistPress::shortcode_hash() Get hash of attributes.\n\t * @uses GistPress::transient_key() Transient key name.\n\t * @uses GistPress::debug_log() Potentially log a debug message.\n\t * @uses GistPress::debug_log() Gist retrieval failure string.\n\t *\n\t * @param array $rawattr Raw attributes of the shortcode.\n\t * @return string HTML content to display the Gist.\n\t */\n\tpublic function shortcode( array $rawattr ) {\n\t\t$shortcode = $this->rebuild_shortcode( $rawattr );\n\n\t\t$attr = $this->standardize_attributes( $rawattr );\n\n\t\t$shortcode_hash = $this->shortcode_hash( 'gist', $attr );\n\n\t\t// Short-circuit the shortcode output and just delete the transient.\n\t\t// This is set to true when posts are updated.\n\t\tif ( $this->delete_shortcode_transients ) {\n\t\t\tdelete_transient( $this->transient_key( $shortcode_hash ) );\n\t\t\tdelete_transient( $this->gist_files_transient_key( $attr['id'] ) );\n\n\t\t\treturn '';\n\t\t}\n\n\t\t// Log what we're dealing with - title uses original attributes, but hashed against processed attributes.\n\t\t$this->debug_log( '<h2>' . $shortcode . '</h2>', $shortcode_hash );\n\n\t\t// Bail if the ID is not set.\n\t\tif ( empty( $attr['id'] ) ) {\n\t\t\t$this->debug_log( __( 'Shortcode did not have a required id attribute.', 'gistpress' ), $shortcode_hash );\n\t\t\treturn '';\n\t\t}\n\n\t\t$url = 'https://gist.github.com/' . $attr['id'];\n\t\t$json_url = $url . '.json';\n\n\t\tif ( is_feed() ) {\n\t\t\t$html = sprintf( '<a href=\"%s\" target=\"_blank\"><em>%s</em></a>', esc_url( $url ), __( 'View this code snippet on GitHub.', 'gistpress' ) );\n\n\t\t\t/**\n\t\t\t * Filter what is shown in feeds.\n\t\t\t *\n\t\t\t * @since 2.0.0\n\t\t\t *\n\t\t\t * @param string $html Markup to show in feeds.\n\t\t\t */\n\t\t\treturn apply_filters( 'gistpress_feed_html', $html );\n\t\t}\n\n\t\t$html = $this->get_gist_html( $json_url, $attr );\n\n\t\tif ( $this->unknown() === $html ) {\n\t\t\treturn make_clickable( $url );\n\t\t}\n\n\t\t// If there was a result, return it.\n\t\tif ( $html ) {\n\t\t\tif ( $attr['embed_stylesheet'] ) {\n\t\t\t\twp_enqueue_style( 'gistpress' );\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Filter the output HTML.\n\t\t\t *\n\t\t\t * @since 2.0.0\n\t\t\t *\n\t\t\t * @param string $html The output HTML.\n\t\t\t * @param string $url  The URL to the Gist.\n\t\t\t * @param array  $attr Shortcode attributes, standardized.\n\t\t\t * @param int    $id   Post ID.\n\t\t\t */\n\t\t\t$html = apply_filters( 'gistpress_html', $html, $url, $attr, get_the_ID() );\n\n\t\t\tforeach ( $attr as $key => $value ) {\n\t\t\t\t$message  = '<strong>' . $key . __( ' (shortcode attribute)', 'gistpress' ) . ':</strong> ';\n\t\t\t\t$message .= is_scalar( $value ) ? $value : print_r( $value, true );\n\t\t\t\t$this->debug_log( $message, $shortcode_hash );\n\t\t\t}\n\t\t\t$this->debug_log( '<strong>Gist:</strong><br />' . $html, $shortcode_hash );\n\n\t\t\treturn $html;\n\t\t}\n\n\t\treturn '';\n\t}\n\n\t/**\n\t * Helper method to determine if a shortcode attribute is true or false.\n\t *\n\t * @since 1.1.0\n\t *\n\t * @param string|int|bool $var Attribute value.\n\t * @return bool\n\t */\n\tpublic function shortcode_bool( $var ) {\n\t\t$falsey = array( 'false', '0', 'no', 'n' );\n\n\t\treturn ( ! $var || in_array( strtolower( $var ), $falsey, true ) ) ? false : true;\n\t}\n\n\t/**\n\t * Parses and expands the shortcode 'highlight' attribute and returns it\n\t * in a usable format.\n\t *\n\t * @since 1.1.0\n\t *\n\t * @param string $line_numbers Comma-separated list of line numbers and ranges.\n\t * @return array|null List of line numbers, or null if no line numbers given\n\t */\n\tpublic function parse_highlight_arg( $line_numbers ) {\n\t\tif ( empty( $line_numbers ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Determine which lines should be highlighted.\n\t\t$highlight = array_map( 'trim', explode( ',', $line_numbers ) );\n\n\t\t// Convert any ranges.\n\t\tforeach ( $highlight as $index => $num ) {\n\t\t\tif ( false !== strpos( $num, '-' ) ) {\n\t\t\t\tunset( $highlight[ $index ] );\n\n\t\t\t\t$range = array_map( 'trim', explode( '-', $num ) );\n\t\t\t\tforeach ( range( $range[0], $range[1] ) as $line ) {\n\t\t\t\t\tarray_push( $highlight, $line );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn array_unique( $highlight );\n\t}\n\n\t/**\n\t * Parses the shortcode 'lines' attribute into min and max values.\n\t *\n\t * @since 1.1.0\n\t *\n\t * @param string $line_numbers Range of line numbers separated by a dash.\n\t * @return array Associative array with min and max line numbers.\n\t */\n\tpublic function parse_line_number_arg( $line_numbers ) {\n\t\tif ( empty( $line_numbers ) ) {\n\t\t\treturn array( 'min' => 0, 'max' => 0 );\n\t\t}\n\n\t\tif ( false === strpos( $line_numbers, '-' ) ) {\n\t\t\t$range = array_fill_keys( array( 'min', 'max' ), absint( trim( $line_numbers ) ) );\n\t\t} else {\n\t\t\t$numbers = array_map( 'absint', array_map( 'trim', explode( '-', $line_numbers ) ) );\n\n\t\t\t$range = array(\n\t\t\t\t'min' => $numbers[0],\n\t\t\t\t'max' => $numbers[1],\n\t\t\t);\n\t\t}\n\n\t\treturn $range;\n\t}\n\n\t/**\n\t * Retrieve Gist HTML.\n\t *\n\t * Gist HTML can come from one of three different sources:\n\t *   Remote JSON endpoint,\n\t *   Transient,\n\t *   Post meta cache.\n\t *\n\t * When a Gist is initially requested, the HTML is fetched from the JSON\n\t * endpoint and cached in a post meta field. It is then processed to limit\n\t * line numbers, highlight specific lines, and add a few extra classes as\n\t * style hooks. The processed HTML is then stored in a transient using a\n\t * hash of the shortcodes attributes for the key.\n\t *\n\t * On subsequent requests, the HTML is fetched from the transient until it\n\t * expires, then it is requested from the remote URL again.\n\t *\n\t * In the event the HTML can't be fetched from the remote endpoint and the\n\t * transient has expired, the HTML is retrieved from the post meta backup.\n\t *\n\t * This algorithm allows Gist HTML to stay in sync with any changes GitHub\n\t * may make to their markup, while providing a local cache for faster\n\t * retrieval and a backup in case GitHub can't be reached.\n\t *\n\t * @since 1.1.0\n\t *\n\t * @param string $url   The JSON endpoint for the Gist.\n\t * @param array  $args  List of shortcode attributes.\n\t * @return string Gist HTML or {{unknown}} if it could not be determined.\n\t */\n\tpublic function get_gist_html( $url, array $args ) {\n\t\t// Add a specific file from a Gist to the URL.\n\t\tif ( ! empty( $args['file'] ) ) {\n\t\t\t$url = add_query_arg( 'file', urlencode( $args['file'] ), $url );\n\t\t}\n\n\t\t$shortcode_hash = $this->shortcode_hash( 'gist', $args );\n\t\t$raw_key = '_gist_raw_' . md5( $url );\n\t\t$transient_key = $this->transient_key( $shortcode_hash );\n\n\t\t$html = get_transient( $transient_key );\n\n\t\tif ( empty( $html ) ) {\n\t\t\t$html = get_transient( $raw_key );\n\t\t\t$transient_expire = DAY_IN_SECONDS;\n\n\t\t\tif ( $html && $this->unknown() !== $html ) {\n\t\t\t\t$html = $this->process_gist_html( $html, $args );\n\t\t\t\t$this->debug_log( __( '<strong>Raw Source:</strong> Transient Cache', 'gistpress' ), $shortcode_hash );\n\t\t\t} else {\n\t\t\t\t// Retrieve raw html from Gist JSON endpoint.\n\t\t\t\t$json = $this->fetch_gist( $url );\n\n\t\t\t\tif ( ! empty( $json->div ) ) {\n\t\t\t\t\tset_transient( $raw_key, $json->div, $transient_expire );\n\n\t\t\t\t\t// Update the post meta fallback. See http://core.trac.wordpress.org/ticket/21767 for details.\n\t\t\t\t\tupdate_post_meta( get_the_ID(), $raw_key, addslashes( $json->div ) );\n\n\t\t\t\t\t$html = $this->process_gist_html( $json->div, $args );\n\n\t\t\t\t\t$this->debug_log( __( '<strong>Raw Source:</strong> Remote JSON Endpoint - ', 'gistpress' ) . $url, $shortcode_hash );\n\t\t\t\t\t$this->debug_log( __( '<strong>Output Source:</strong> Processed the raw source.', 'gistpress' ), $shortcode_hash );\n\t\t\t\t}\n\n\t\t\t\t// Update the style sheet reference.\n\t\t\t\tif ( ! empty( $json->stylesheet ) ) {\n\t\t\t\t\tupdate_option( 'gistpress_stylesheet', $json->stylesheet );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Failures are cached, too. Update the post to attempt to fetch again.\n\t\t\t$html = ( $html ) ? $html : $this->unknown();\n\n\t\t\tif ( $this->unknown() === $html && ( $fallback = get_post_meta( get_the_ID(), $raw_key, true ) ) ) {\n\t\t\t\t// Return the fallback instead of the string representing unknown.\n\t\t\t\t$html = $this->process_gist_html( $fallback, $args );\n\n\t\t\t\t// Cache the fallback for an hour.\n\t\t\t\t$transient_expire = HOUR_IN_SECONDS;\n\n\t\t\t\t$this->debug_log( __( '<strong>Raw Source:</strong> Post Meta Fallback', 'gistpress' ), $shortcode_hash );\n\t\t\t\t$this->debug_log( __( '<strong>Output Source:</strong> Processed Raw Source', 'gistpress' ), $shortcode_hash );\n\t\t\t} elseif ( $this->unknown() === $html ) {\n\t\t\t\t$this->debug_log( '<strong style=\"color: #e00;\">' . __( 'Remote call and transient failed and fallback was empty.', 'gistpress' ) . '</strong>', $shortcode_hash );\n\t\t\t}\n\n\t\t\t// Cache the processed HTML.\n\t\t\tset_transient( $transient_key, $html, $transient_expire );\n\t\t} else {\n\t\t\t$this->debug_log( __( '<strong>Output Source:</strong> Transient Cache', 'gistpress' ), $shortcode_hash );\n\t\t}\n\n\t\t$this->debug_log( '<strong>' . __( 'JSON Endpoint:', 'gistpress' ) . '</strong> ' . $url, $shortcode_hash );\n\t\t$this->debug_log( '<strong>' . __( 'Raw Key (Transient & Post Meta):', 'gistpress' ) . '</strong> ' . $raw_key, $shortcode_hash );\n\t\t$this->debug_log( '<strong>' . __( 'Processed Output Key (Transient):', 'gistpress' ) . '</strong> ' . $transient_key, $shortcode_hash );\n\n\t\t// Strip unnecessary elements from HTML output.\n\t\t$html = preg_replace( '/^<!DOCTYPE.+?>/i', '', str_ireplace( array( '<html>', '</html>', '<body>', '</body>' ), '', $html ) );\n\n\t\treturn $html;\n\t}\n\n\t/**\n\t * Fetch Gist data from its JSON endpoint.\n\t *\n\t * @since 1.1.0\n\t *\n\t * @param string $url Gist JSON endpoint.\n\t * @return object|bool Gist JSON object, or false if anything except a HTTP\n\t *                     Status code of 200 was received.\n\t */\n\tpublic function fetch_gist( $url ) {\n\t\t$response = wp_remote_get( $url, array( 'sslverify' => false ) );\n\n\t\tif ( 200 === wp_remote_retrieve_response_code( $response ) ) {\n\t\t\treturn json_decode( wp_remote_retrieve_body( $response ) );\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Process the HTML returned from a Gist's JSON endpoint based on settings\n\t * passed through the shortcode.\n\t *\n\t * @since 1.1.0\n\t *\n\t * @param string $html HTML from the Gist's JSON endpoint.\n\t * @param array  $args List of shortcode attributes.\n\t * @return string Modified HTML.\n\t */\n\tpublic function process_gist_html( $html, array $args ) {\n\t\t// Remove the line number cell if it has been disabled.\n\t\tif ( ! $args['show_line_numbers'] ) {\n\t\t\t$html = preg_replace( '#<td id=\"[^\"]*\" class=\"blob-num js-line-number\" data-line-number=\"\\d+\"></td>#s', '', $html );\n\t\t}\n\n\t\t// Remove the meta section if it has been disabled.\n\t\tif ( ! $args['show_meta'] ) {\n\t\t\t$html = preg_replace( '#<div class=\"gist-meta\">.*?</div>#s', '', $html );\n\t\t}\n\n\t\tif ( ! class_exists( 'DOMDocument' ) ) {\n\t\t\treturn $html;\n\t\t}\n\n\t\t$dom = new DOMDocument();\n\t\t$dom->loadHTML( $html );\n\n\t\t$lines = $dom->getElementsByTagName( 'tr' );\n\n\t\tif ( ! empty( $args['highlight'] ) ) {\n\t\t\t// Flip to use isset() when looping through the lines.\n\t\t\t$highlight = array_flip( $args['highlight'] );\n\t\t}\n\n\t\t$lines_to_remove = array();\n\t\tforeach ( $lines as $key => $line ) {\n\t\t\t// Remove lines if they're not in the specified range and continue.\n\t\t\tif (\n\t\t\t\t( $args['lines']['min'] && $key < $args['lines']['min'] - 1 ) ||\n\t\t\t\t( $args['lines']['max'] && $key > $args['lines']['max'] - 1 )\n\t\t\t) {\n\t\t\t\t$lines_to_remove[] = $line;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Add classes for styling.\n\t\t\t$classes = array( 'line' );\n\n\t\t\tif ( isset( $highlight[ $key + 1 ] ) ) {\n\t\t\t\t$classes[] = 'line-highlight';\n\n\t\t\t\tif ( ! empty( $args['highlight_color'] ) ) {\n\t\t\t\t\t$style = 'background-color: ' . $args['highlight_color'] . ' !important';\n\n\t\t\t\t\tforeach ( $line->getElementsByTagName( 'td' ) as $cell ) {\n\t\t\t\t\t\t$value = $cell->getAttribute( 'style' );\n\t\t\t\t\t\t$value = empty( $value ) ? $style : $value . ';' . $style;\n\t\t\t\t\t\t$cell->setAttribute( 'style', $value );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Filter the classes applied to a line of the Gist.\n\t\t\t *\n\t\t\t * @since 2.0.0\n\t\t\t *\n\t\t\t * @param array $classes List of HTML class values.\n\t\t\t */\n\t\t\t$classes = apply_filters( 'gistpress_line_classes', $classes );\n\t\t\t$class = ( ! empty( $classes ) && is_array( $classes ) ) ? implode( ' ', $classes ) : '';\n\n\t\t\t$value = $line->getAttribute( 'class' );\n\t\t\t$value = empty( $value ) ? $class : $value . ' ' . $class;\n\t\t\t$line->setAttribute( 'class', $value );\n\t\t}\n\n\t\tforeach ( $lines_to_remove as $line ) {\n\t\t\t$line->parentNode->removeChild( $line );\n\t\t}\n\n\t\t$html = $dom->saveHTML();\n\n\t\t// Restrict the line number display if a range has been specified.\n\t\tif (\n\t\t\t$args['show_line_numbers'] &&\n\t\t\t( ( $args['lines']['min'] && $args['lines']['max'] ) || ! empty( $args['lines_start'] ) )\n\t\t) {\n\t\t\t$html = $this->process_gist_line_numbers( $html, $args['lines'], $args['lines_start'] );\n\t\t}\n\n\t\treturn $html;\n\t}\n\n\t/**\n\t * Removes line numbers from the Gist's HTML that fall outside the\n\t * supplied range and modifies the starting number if specified.\n\t *\n\t * @since 1.1.0\n\t *\n\t * @param string $html  HTML from the Gist's JSON endpoint.\n\t * @param array  $range Array of min and max values.\n\t * @param int    $start Optional. Line number to start counting at.\n\t * @return string Modified HTML.\n\t */\n\tpublic function process_gist_line_numbers( $html, array $range, $start = null ) {\n\t\t$start = empty( $start ) ? absint( $range['min'] ) : absint( $start );\n\n\t\t$dom = new DOMDocument();\n\t\t$dom->loadHTML( $html );\n\t\t$lines = $dom->getElementsByTagName( 'tr' );\n\n\t\tforeach ( $lines as $i => $line ) {\n\t\t\t$line\n\t\t\t\t->getElementsByTagName( 'td' )\n\t\t\t\t->item( 0 )\n\t\t\t\t->setAttribute( 'data-line-number', $start + $i );\n\t\t}\n\n\t\treturn $dom->saveHTML();\n\t}\n\n\t/**\n\t * Removes transients associated with Gists embedded in a post.\n\t *\n\t * Retrieves the keys of meta data associated with a post and deletes any\n\t * transients with a matching embed key.\n\t *\n\t * @since 1.1.0\n\t *\n\t * @param int     $post_id     Post ID.\n\t * @param WP_Post $post_after  Post object after update.\n\t * @param WP_Post $post_before Post object before update.\n\t */\n\tpublic function delete_gist_transients( $post_id, WP_Post $post_after, WP_Post $post_before ) {\n\t\t$this->delete_shortcode_transients = true;\n\n\t\t// Run the shortcodes to clear associated transients.\n\t\tdo_shortcode( $GLOBALS['wp_embed']->autoembed( $post_after->post_content ) );\n\t\tdo_shortcode( $GLOBALS['wp_embed']->autoembed( $post_before->post_content ) );\n\n\t\t// Delete raw transients whose keys match a post meta fallback.\n\t\t$keys = get_post_custom_keys( $post_id );\n\n\t\tif ( $keys ) {\n\t\t\tforeach ( $keys as $key ) {\n\t\t\t\tif ( 0 === strpos( $key, '_gist_raw_' ) ) {\n\t\t\t\t\tdelete_transient( $key );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Rebuild the original shortcode as a string with raw attributes.\n\t *\n\t * @since 1.1.1\n\t *\n\t * @param array $rawattr Raw attributes => values.\n\t * @return string Gist shortcode.\n\t */\n\tprotected function rebuild_shortcode( array $rawattr ) {\n\t\t$attrs = array();\n\t\tforeach ( $rawattr as $key => $value ) {\n\t\t\tif ( 'oembed' !== $key ) {\n\t\t\t\t$attrs[] = $key . '=\"' . $value . '\"';\n\t\t\t}\n\t\t}\n\t\treturn '[gist ' . implode( ' ', $attrs ) . ']';\n\t}\n\n\t/**\n\t * Set defaults and sanitize shortcode attributes and attribute values.\n\t *\n\t * @since 1.1.1\n\t *\n\t * @param array $rawattr Associative array of raw attributes => values.\n\t * @return array Standardized and sanitized shortcode attributes.\n\t */\n\tprotected function standardize_attributes( array $rawattr ) {\n\t\t/**\n\t\t * Filter the shortcode attributes defaults.\n\t\t *\n\t\t * @since 2.0.0\n\t\t *\n\t\t * @see standardize_attributes()\n\t\t *\n\t\t * @param array $gistpress_shortcode_defaults {\n\t\t * \tShortcode attributes defaults.\n\t\t *\n\t\t * \t@type bool   $embed_stylesheet  Filterable value to include style sheet or not. Default is true\n\t\t *                                      to include it.\n\t\t * \t@type string $file              File name within gist. Default is an empty string, indicating\n\t\t *                                      all files.\n\t\t * \t@type array  $highlight         Lines to highlight. Default is empty array, to highlight\n\t\t *                                      no lines.\n\t\t * \t@type string $highlight_color   Filterable hex color code. Default is #ffc.\n\t\t * \t@type string $id                Gist ID. Non-optional.\n\t\t * \t@type string $lines             Number of lines to show. Default is empty string, indicating\n\t\t *                                      all lines in the gist.\n\t\t * \t@type string $lines_start       Which line number to start from. Default is empty string,\n\t\t *                                      indicating line number 1.\n\t\t * \t@type bool   $show_line_numbers Show line numbers or not, default is true, to show line numbers.\n\t\t * \t@type bool   $show_meta         Show meta information or not, default is true, to show\n\t\t *                                      meta information.\n\t\t * }\n\t\t */\n\t\t$defaults = apply_filters(\n\t\t\t'gistpress_shortcode_defaults',\n\t\t\tarray(\n\n\t\t\t\t/**\n\t\t\t\t * Filter to include the style sheet or not.\n\t\t\t\t *\n\t\t\t\t * @since 2.0.0\n\t\t\t\t *\n\t\t\t\t * @param bool $gistpress_stylesheet_default Include default style sheet or not.\n\t\t\t\t *                                           Default is true, to include it.\n\t\t\t\t */\n\t\t\t\t'embed_stylesheet'  => apply_filters( 'gistpress_stylesheet_default', true ),\n\t\t\t\t'file'              => '',\n\t\t\t\t'highlight'         => array(),\n\n\t\t\t\t/**\n\t\t\t\t * Filter highlight color.\n\t\t\t\t *\n\t\t\t\t * @since 2.0.0\n\t\t\t\t *\n\t\t\t\t * @param string $gistpress_highlight_color Hex color code for highlighting lines.\n\t\t\t\t *                                          Default is `#ffc`.\n\t\t\t\t */\n\t\t\t\t'highlight_color'   => apply_filters( 'gistpress_highlight_color', '#ffc' ),\n\t\t\t\t'id'                => '',\n\t\t\t\t'lines'             => '',\n\t\t\t\t'lines_start'       => '',\n\t\t\t\t'show_line_numbers' => true,\n\t\t\t\t'show_meta'         => true,\n\t\t\t\t'oembed'            => 0, // Private use only.\n\t\t\t)\n\t\t);\n\n\t\t// Sanitize attributes.\n\t\t$attr = shortcode_atts( $defaults, $rawattr );\n\t\t$attr['id']                = preg_replace( '/[^a-z0-9]+/i', '', $attr['id'] );\n\t\t$attr['embed_stylesheet']  = $this->shortcode_bool( $attr['embed_stylesheet'] );\n\t\t$attr['show_line_numbers'] = $this->shortcode_bool( $attr['show_line_numbers'] );\n\t\t$attr['show_meta']         = $this->shortcode_bool( $attr['show_meta'] );\n\t\t$attr['highlight']         = $this->parse_highlight_arg( $attr['highlight'] );\n\t\t$attr['lines']             = $this->parse_line_number_arg( $attr['lines'] );\n\n\t\treturn $attr;\n\t}\n\n\t/**\n\t * Try to determine the real file name from a sanitized file name.\n\t *\n\t * The new Gist \"bookmark\" URLs point to sanitized file names so that both\n\t * hyphen and period in a file name show up as a hyphen e.g. a filename of\n\t * foo.bar and foo-bar both appear in the bookmark URL as foo-bar. The\n\t * correct original filenames are listed in the JSON data for the overall\n\t * Gist, so this method does a call to that, and loops through the listed\n\t * file names to see if it can determine which file was meant.\n\t *\n\t * If a Gist has two files that both resolve to the same sanitized filename,\n\t * then we don't have any way to determine which one the other determined,\n\t * so we just return the first one we find. If that's incorrect, the author\n\t * can use the shortcode approach, which allows a specific file name to be\n\t * used.\n\t *\n\t * @since 2.1.0\n\t *\n\t * @param  string $sanitized_filename Sanitized filename, such as foo-bar-php.\n\t * @param  string $delimiter          Either underscore or hyphen.\n\t * @param  string $id                 Gist ID.\n\t * @return string                     Filename, or empty string if it couldn't be determined.\n\t */\n\tprotected function get_file_name( $sanitized_filename, $delimiter, $id ) {\n\t\t// Old style link - filename wasn't actually changed.\n\t\tif ( '_' === $delimiter ) {\n\t\t\treturn $sanitized_filename;\n\t\t}\n\n\t\t// New style bookmark - filename had . replaced with -\n\t\t// Means we have to go and look up what the filename could have been.\n\t\t$transient_key = $this->gist_files_transient_key( $id );\n\t\t$gist_files = get_transient( $transient_key );\n\n\t\tif ( ! $gist_files ) {\n\t\t\t$url = 'https://gist.github.com/' . $id . '.json';\n\t\t\t$json = $this->fetch_gist( $url );\n\n\t\t\tif ( $json && ! empty( $json->files ) ) {\n\t\t\t\t$gist_files = $json->files;\n\t\t\t\tset_transient( $transient_key, $gist_files, WEEK_IN_SECONDS );\n\t\t\t} else {\n\t\t\t\tset_transient( $transient_key, array(), MINUTE_IN_SECONDS * 15 );\n\t\t\t}\n\t\t}\n\n\t\t// If a gist has foo.bar.php and foo-bar.php, then we can't yet\n\t\t// determine which was actually wanted, since both give the same\n\t\t// bookmark URL. Here, we just return the first one we find.\n\t\tif ( ! empty( $gist_files ) ) {\n\t\t\tforeach ( $gist_files as $file ) {\n\t\t\t\tif ( str_replace( '.', '-', $file ) === $sanitized_filename ) {\n\t\t\t\t\treturn $file;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn '';\n\t}\n\n\t/**\n\t * Wrapper for a PSR-3 compatible logger.\n\t *\n\t * If no logger has been set via the set_logger() method on an instance of\n\t * this class, or WP_DEBUG is not enabled, then log messages quietly die\n\t * here.\n\t *\n\t * @since 1.1.0\n\t *\n\t * @param string $message A message to log for the current shortcode.\n\t * @param mixed  $id      Optional. An ID under which the message should be grouped.\n\t */\n\tprotected function debug_log( $message, $id = null ) {\n\t\tif ( defined( 'WP_DEBUG' ) && WP_DEBUG && isset( $this->logger ) ) {\n\t\t\t$this->logger->debug( $message, array( 'key' => $id ) );\n\t\t}\n\t}\n\n\t/**\n\t * Sort a shortcode's attributes by name and hash it for use as a cache\n\t * key and logger message grouping.\n\t *\n\t * @since 1.1.0\n\t *\n\t * @param string $tag  Shortcode tag, used as hash prefix.\n\t * @param array  $args Associative array of shortcode attributes.\n\t * @return string md5 hash as a 32-character hexadecimal number.\n\t */\n\tprotected function shortcode_hash( $tag, array $args ) {\n\t\tksort( $args );\n\t\treturn md5( $tag . '_' . serialize( $args ) );\n\t}\n\n\t/**\n\t * Get the transient key.\n\t *\n\t * @since 1.1.0\n\t *\n\t * @param string $identifier The identifier part of the key.\n\t * @return string Transient key name.\n\t */\n\tprotected function transient_key( $identifier ) {\n\t\treturn 'gist_html_' . $identifier;\n\t}\n\n\t/**\n\t * Get the transient key for a list of a Gist's files.\n\t *\n\t * @since 2.1.0\n\t *\n\t * @param string $gist_id The Gist id.\n\t * @return string Transient key name.\n\t */\n\tprotected function gist_files_transient_key( $gist_id ) {\n\t\treturn 'gist_files_' . md5( $gist_id );\n\t}\n\n\t/**\n\t * String to identify a failure when retrieving a Gist's HTML.\n\t *\n\t * @since 1.1.0\n\t *\n\t * @return string\n\t */\n\tprotected function unknown() {\n\t\treturn '{{unknown}}';\n\t}\n\n\t/**\n\t * Escape a regular expression replacement string.\n\t *\n\t * @since 2.0.2\n\t * @link http://www.procata.com/blog/archives/2005/11/13/two-preg_replace-escaping-gotchas/\n\t *\n\t * @param string $str String to escape.\n\t * @return string\n\t */\n\tpublic function preg_replace_quote( $str ) {\n\t\treturn preg_replace( '/(\\$|\\\\\\\\)(?=\\d)/', '\\\\\\\\$1', $str );\n\t}\n}\n"], "filenames": ["includes/class-gistpress.php"], "buggy_code_start_loc": [683], "buggy_code_end_loc": [683], "fixing_code_start_loc": [684], "fixing_code_end_loc": [685], "type": "CWE-79", "message": "XSS exists in the shortcode functionality of the GistPress plugin before 3.0.2 for WordPress via the includes/class-gistpress.php id parameter. This allows an attacker with the WordPress Contributor role to execute arbitrary JavaScript code with the privileges of other users (e.g., ones who have the publish_posts capability).", "other": {"cve": {"id": "CVE-2020-8498", "sourceIdentifier": "cve@mitre.org", "published": "2020-01-30T23:15:10.157", "lastModified": "2020-02-03T20:12:03.940", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "XSS exists in the shortcode functionality of the GistPress plugin before 3.0.2 for WordPress via the includes/class-gistpress.php id parameter. This allows an attacker with the WordPress Contributor role to execute arbitrary JavaScript code with the privileges of other users (e.g., ones who have the publish_posts capability)."}, {"lang": "es", "value": "Se presenta una vulnerabilidad de tipo XSS en la funcionalidad shortcode del plugin GistPress versiones anteriores a 3.0.2 para WordPress, por medio del par\u00e1metro id del archivo includes/class-gistpress.php. Esto permite a un atacante con el rol WordPress Contributor ejecutar c\u00f3digo JavaScript arbitrario con los privilegios de otros usuarios (por ejemplo, aquellos que poseen la capacidad publish_posts)."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gistpress_project:gistpress:*:*:*:*:*:wordpress:*:*", "versionEndExcluding": "3.0.2", "matchCriteriaId": "9BA6ED54-D107-4748-AC44-9C2462E2CD83"}]}]}], "references": [{"url": "https://github.com/bradyvercher/gistpress/commit/e3f260edb6673227b0471c74b7ab13c094411ef7", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/bradyvercher/gistpress/releases/tag/v3.0.2", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://wpvulndb.com/vulnerabilities/10053", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/bradyvercher/gistpress/commit/e3f260edb6673227b0471c74b7ab13c094411ef7"}}