{"buggy_code": ["/*\n* ModSecurity for Apache 2.x, http://www.modsecurity.org/\n* Copyright (c) 2004-2011 Trustwave Holdings, Inc. (http://www.trustwave.com/)\n*\n* You may not use this file except in compliance with\n* the License. \u00a0You may obtain a copy of the License at\n*\n* \u00a0 \u00a0 http://www.apache.org/licenses/LICENSE-2.0\n*\n* If any of the files related to licensing are missing or if you have any\n* other questions related to licensing please contact Trustwave Holdings, Inc.\n* directly using the email address security@modsecurity.org.\n*/\n\n#include <limits.h>\n\n#include \"modsecurity.h\"\n#include \"msc_logging.h\"\n#include \"msc_util.h\"\n#include \"http_log.h\"\n#include \"apr_lib.h\"\n#include \"acmp.h\"\n#include \"msc_crypt.h\"\n\n#if defined(WITH_LUA)\n#include \"msc_lua.h\"\n#endif\n\n\n/* -- Directory context creation and initialisation -- */\n\n/**\n * Creates a fresh directory configuration.\n */\nvoid *create_directory_config(apr_pool_t *mp, char *path)\n{\n    directory_config *dcfg = (directory_config *)apr_pcalloc(mp, sizeof(directory_config));\n    if (dcfg == NULL) return NULL;\n\n    #ifdef DEBUG_CONF\n    ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, mp, \"Created directory config %pp path %s\", dcfg, path);\n    #endif\n\n    dcfg->mp = mp;\n    dcfg->is_enabled = NOT_SET;\n\n    dcfg->reqbody_access = NOT_SET;\n    dcfg->reqintercept_oe = NOT_SET;\n    dcfg->reqbody_buffering = NOT_SET;\n    dcfg->reqbody_inmemory_limit = NOT_SET;\n    dcfg->reqbody_limit = NOT_SET;\n    dcfg->reqbody_no_files_limit = NOT_SET;\n    dcfg->resbody_access = NOT_SET;\n\n    dcfg->debuglog_name = NOT_SET_P;\n    dcfg->debuglog_level = NOT_SET;\n    dcfg->debuglog_fd = NOT_SET_P;\n\n    dcfg->of_limit = NOT_SET;\n    dcfg->if_limit_action = NOT_SET;\n    dcfg->of_limit_action = NOT_SET;\n    dcfg->of_mime_types = NOT_SET_P;\n    dcfg->of_mime_types_cleared = NOT_SET;\n\n    dcfg->cookie_format = NOT_SET;\n    dcfg->argument_separator = NOT_SET;\n    dcfg->cookiev0_separator = NOT_SET_P;\n\n    dcfg->rule_inheritance = NOT_SET;\n    dcfg->rule_exceptions = apr_array_make(mp, 16, sizeof(rule_exception *));\n    dcfg->hash_method = apr_array_make(mp, 16, sizeof(hash_method *));\n\n    /* audit log variables */\n    dcfg->auditlog_flag = NOT_SET;\n    dcfg->auditlog_type = NOT_SET;\n    dcfg->max_rule_time = NOT_SET;\n    dcfg->auditlog_dirperms = NOT_SET;\n    dcfg->auditlog_fileperms = NOT_SET;\n    dcfg->auditlog_name = NOT_SET_P;\n    dcfg->auditlog2_name = NOT_SET_P;\n    dcfg->auditlog_fd = NOT_SET_P;\n    dcfg->auditlog2_fd = NOT_SET_P;\n    dcfg->auditlog_storage_dir = NOT_SET_P;\n    dcfg->auditlog_parts = NOT_SET_P;\n    dcfg->auditlog_relevant_regex = NOT_SET_P;\n\n    dcfg->ruleset = NULL;\n\n    /* Upload */\n    dcfg->tmp_dir = NOT_SET_P;\n    dcfg->upload_dir = NOT_SET_P;\n    dcfg->upload_keep_files = NOT_SET;\n    dcfg->upload_validates_files = NOT_SET;\n    dcfg->upload_filemode = NOT_SET;\n    dcfg->upload_file_limit = NOT_SET;\n\n    /* These are only used during the configuration process. */\n    dcfg->tmp_chain_starter = NULL;\n    dcfg->tmp_default_actionset = NULL;\n    dcfg->tmp_rule_placeholders = NULL;\n\n    /* Misc */\n    dcfg->data_dir = NOT_SET_P;\n    dcfg->webappid = NOT_SET_P;\n    dcfg->sensor_id = NOT_SET_P;\n    dcfg->httpBlkey = NOT_SET_P;\n\n    /* Content injection. */\n    dcfg->content_injection_enabled = NOT_SET;\n\n    /* Stream inspection */\n    dcfg->stream_inbody_inspection = NOT_SET;\n    dcfg->stream_outbody_inspection = NOT_SET;\n\n    /* Geo Lookups */\n    dcfg->geo = NOT_SET_P;\n\n    /* Gsb Lookups */\n    dcfg->gsb = NOT_SET_P;\n\n    /* Unicode Map */\n    dcfg->u_map = NOT_SET_P;\n\n    /* Cache */\n    dcfg->cache_trans = NOT_SET;\n    dcfg->cache_trans_incremental = NOT_SET;\n    dcfg->cache_trans_min = NOT_SET;\n    dcfg->cache_trans_max = NOT_SET;\n    dcfg->cache_trans_maxitems = NOT_SET;\n\n    /* Rule ids */\n    dcfg->rule_id_htab = apr_hash_make(mp);\n    dcfg->component_signatures = apr_array_make(mp, 16, sizeof(char *));\n\n    dcfg->request_encoding = NOT_SET_P;\n    dcfg->disable_backend_compression = NOT_SET;\n\n    /* Collection timeout */\n    dcfg->col_timeout = NOT_SET;\n\n    dcfg->crypto_key = NOT_SET_P;\n    dcfg->crypto_key_len = NOT_SET;\n    dcfg->crypto_key_add = NOT_SET;\n    dcfg->crypto_param_name = NOT_SET_P;\n    dcfg->hash_is_enabled = NOT_SET;\n    dcfg->hash_enforcement = NOT_SET;\n    dcfg->crypto_hash_href_rx = NOT_SET;\n    dcfg->crypto_hash_faction_rx = NOT_SET;\n    dcfg->crypto_hash_location_rx = NOT_SET;\n    dcfg->crypto_hash_iframesrc_rx = NOT_SET;\n    dcfg->crypto_hash_framesrc_rx = NOT_SET;\n    dcfg->crypto_hash_href_pm = NOT_SET;\n    dcfg->crypto_hash_faction_pm = NOT_SET;\n    dcfg->crypto_hash_location_pm = NOT_SET;\n    dcfg->crypto_hash_iframesrc_pm = NOT_SET;\n    dcfg->crypto_hash_framesrc_pm = NOT_SET;\n\n\n    return dcfg;\n}\n\n/**\n * Copies rules between one phase of two configuration contexts,\n * taking exceptions into account.\n */\nstatic void copy_rules_phase(apr_pool_t *mp,\n                             apr_array_header_t *parent_phase_arr,\n                             apr_array_header_t *child_phase_arr,\n                             apr_array_header_t *exceptions_arr)\n{\n    rule_exception **exceptions;\n    msre_rule **rules;\n    int i, j;\n    int mode = 0;\n\n    rules = (msre_rule **)parent_phase_arr->elts;\n    for(i = 0; i < parent_phase_arr->nelts; i++) {\n        msre_rule *rule = (msre_rule *)rules[i];\n        int copy = 1;\n\n        if (mode == 0) {\n            /* First rule in the chain. */\n            exceptions = (rule_exception **)exceptions_arr->elts;\n            for(j = 0; j < exceptions_arr->nelts; j++) {\n\n                /* Process exceptions. */\n                switch(exceptions[j]->type) {\n                    case RULE_EXCEPTION_REMOVE_ID :\n                        if ((rule->actionset != NULL)&&(rule->actionset->id != NULL)) {\n                            int ruleid = atoi(rule->actionset->id);\n                            if (rule_id_in_range(ruleid, exceptions[j]->param)) copy--;\n                        }\n                        break;\n                    case RULE_EXCEPTION_REMOVE_MSG :\n                        if ((rule->actionset != NULL)&&(rule->actionset->msg != NULL)) {\n                            char *my_error_msg = NULL;\n\n                            int rc = msc_regexec(exceptions[j]->param_data,\n                                    rule->actionset->msg, strlen(rule->actionset->msg),\n                                    &my_error_msg);\n                            if (rc >= 0) copy--;\n                        }\n                        break;\n                    case RULE_EXCEPTION_REMOVE_TAG :\n                        if ((rule->actionset != NULL)&&(apr_is_empty_table(rule->actionset->actions) == 0)) {\n                            char *my_error_msg = NULL;\n                            const apr_array_header_t *tarr = NULL;\n                            const apr_table_entry_t *telts = NULL;\n                            int c;\n\n                            tarr = apr_table_elts(rule->actionset->actions);\n                            telts = (const apr_table_entry_t*)tarr->elts;\n\n                            for (c = 0; c < tarr->nelts; c++) {\n                                msre_action *action = (msre_action *)telts[c].val;\n                                if(strcmp(\"tag\", action->metadata->name) == 0)  {\n\n                                    int rc = msc_regexec(exceptions[j]->param_data,\n                                            action->param, strlen(action->param),\n                                            &my_error_msg);\n                                    if (rc >= 0) copy--;\n                                }\n                            }\n                        }\n                        break;\n                }\n            }\n\n            if (copy > 0) {\n#ifdef DEBUG_CONF\n                ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, mp, \"Copy rule %pp [id \\\"%s\\\"]\", rule, rule->actionset->id);\n#endif\n\n                /* Copy the rule. */\n                *(msre_rule **)apr_array_push(child_phase_arr) = rule;\n                if (rule->actionset->is_chained) mode = 2;\n            } else {\n                if (rule->actionset->is_chained) mode = 1;\n            }\n        } else {\n            if (mode == 2) {\n#ifdef DEBUG_CONF\n                ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, mp, \"Copy chain %pp for rule %pp [id \\\"%s\\\"]\", rule, rule->chain_starter, rule->chain_starter->actionset->id);\n#endif\n\n                /* Copy the rule (it belongs to the chain we want to include. */\n                *(msre_rule **)apr_array_push(child_phase_arr) = rule;\n            }\n\n            if ((rule->actionset == NULL)||(rule->actionset->is_chained == 0)) mode = 0;\n        }\n    }\n}\n\n/**\n * Copies rules between two configuration contexts,\n * taking exceptions into account.\n */\nstatic int copy_rules(apr_pool_t *mp, msre_ruleset *parent_ruleset,\n                      msre_ruleset *child_ruleset,\n                      apr_array_header_t *exceptions_arr)\n{\n    copy_rules_phase(mp, parent_ruleset->phase_request_headers,\n        child_ruleset->phase_request_headers, exceptions_arr);\n    copy_rules_phase(mp, parent_ruleset->phase_request_body,\n        child_ruleset->phase_request_body, exceptions_arr);\n    copy_rules_phase(mp, parent_ruleset->phase_response_headers,\n        child_ruleset->phase_response_headers, exceptions_arr);\n    copy_rules_phase(mp, parent_ruleset->phase_response_body,\n        child_ruleset->phase_response_body, exceptions_arr);\n    copy_rules_phase(mp, parent_ruleset->phase_logging,\n        child_ruleset->phase_logging, exceptions_arr);\n\n    return 1;\n}\n\n/**\n * Merges two directory configurations.\n */\nvoid *merge_directory_configs(apr_pool_t *mp, void *_parent, void *_child)\n{\n    directory_config *parent = (directory_config *)_parent;\n    directory_config *child = (directory_config *)_child;\n    directory_config *merged = create_directory_config(mp, NULL);\n\n    #ifdef DEBUG_CONF\n    ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, mp, \"Merge parent %pp child %pp RESULT %pp\", _parent, _child, merged);\n    #endif\n\n    if (merged == NULL) return NULL;\n\n    /* Use values from the child configuration where possible,\n     * otherwise use the parent's.\n     */\n\n    merged->is_enabled = (child->is_enabled == NOT_SET\n        ? parent->is_enabled : child->is_enabled);\n\n    /* IO parameters */\n    merged->reqbody_access = (child->reqbody_access == NOT_SET\n        ? parent->reqbody_access : child->reqbody_access);\n    merged->reqbody_buffering = (child->reqbody_buffering == NOT_SET\n        ? parent->reqbody_buffering : child->reqbody_buffering);\n    merged->reqbody_inmemory_limit = (child->reqbody_inmemory_limit == NOT_SET\n        ? parent->reqbody_inmemory_limit : child->reqbody_inmemory_limit);\n    merged->reqbody_limit = (child->reqbody_limit == NOT_SET\n        ? parent->reqbody_limit : child->reqbody_limit);\n    merged->reqbody_no_files_limit = (child->reqbody_no_files_limit == NOT_SET\n        ? parent->reqbody_no_files_limit : child->reqbody_no_files_limit);\n    merged->resbody_access = (child->resbody_access == NOT_SET\n        ? parent->resbody_access : child->resbody_access);\n\n    merged->of_limit = (child->of_limit == NOT_SET\n        ? parent->of_limit : child->of_limit);\n    merged->if_limit_action = (child->if_limit_action == NOT_SET\n        ? parent->if_limit_action : child->if_limit_action);\n    merged->of_limit_action = (child->of_limit_action == NOT_SET\n        ? parent->of_limit_action : child->of_limit_action);\n    merged->reqintercept_oe = (child->reqintercept_oe == NOT_SET\n        ? parent->reqintercept_oe : child->reqintercept_oe);\n\n    if (child->of_mime_types != NOT_SET_P) {\n        /* Child added to the table */\n\n        if (child->of_mime_types_cleared == 1) {\n            /* The list of MIME types was cleared in the child,\n             * which means the parent's MIME types went away and\n             * we should not take them into consideration here.\n             */\n            merged->of_mime_types = child->of_mime_types;\n            merged->of_mime_types_cleared = 1;\n        } else {\n            /* Add MIME types defined in the child to those\n             * defined in the parent context.\n             */\n            if (parent->of_mime_types == NOT_SET_P) {\n                merged->of_mime_types = child->of_mime_types;\n                merged->of_mime_types_cleared = NOT_SET;\n            } else {\n                merged->of_mime_types = apr_table_overlay(mp, parent->of_mime_types,\n                    child->of_mime_types);\n                if (merged->of_mime_types == NULL) return NULL;\n            }\n        }\n    } else {\n        /* Child did not add to the table */\n\n        if (child->of_mime_types_cleared == 1) {\n            merged->of_mime_types_cleared = 1;\n        } else {\n            merged->of_mime_types = parent->of_mime_types;\n            merged->of_mime_types_cleared = parent->of_mime_types_cleared;\n        }\n    }\n\n    /* debug log */\n    if (child->debuglog_fd == NOT_SET_P) {\n        merged->debuglog_name = parent->debuglog_name;\n        merged->debuglog_fd = parent->debuglog_fd;\n    } else {\n        merged->debuglog_name = child->debuglog_name;\n        merged->debuglog_fd = child->debuglog_fd;\n    }\n\n    merged->debuglog_level = (child->debuglog_level == NOT_SET\n        ? parent->debuglog_level : child->debuglog_level);\n\n    merged->cookie_format = (child->cookie_format == NOT_SET\n        ? parent->cookie_format : child->cookie_format);\n    merged->argument_separator = (child->argument_separator == NOT_SET\n        ? parent->argument_separator : child->argument_separator);\n    merged->cookiev0_separator = (child->cookiev0_separator == NOT_SET_P\n        ? parent->cookiev0_separator : child->cookiev0_separator);\n\n\n    /* rule inheritance */\n    if ((child->rule_inheritance == NOT_SET)||(child->rule_inheritance == 1)) {\n        merged->rule_inheritance = parent->rule_inheritance;\n        if ((child->ruleset == NULL)&&(parent->ruleset == NULL)) {\n            #ifdef DEBUG_CONF\n            ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, mp, \"No rules in this context.\");\n            #endif\n\n            /* Do nothing, there are no rules in either context. */\n        } else\n        if (child->ruleset == NULL) {\n            #ifdef DEBUG_CONF\n            ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, mp, \"Using parent rules in this context.\");\n            #endif\n\n            /* Copy the rules from the parent context. */\n            merged->ruleset = msre_ruleset_create(parent->ruleset->engine, mp);\n            copy_rules(mp, parent->ruleset, merged->ruleset, child->rule_exceptions);\n        } else\n        if (parent->ruleset == NULL) {\n            #ifdef DEBUG_CONF\n            ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, mp, \"Using child rules in this context.\");\n            #endif\n\n            /* Copy child rules. */\n            merged->ruleset = msre_ruleset_create(child->ruleset->engine, mp);\n            merged->ruleset->phase_request_headers = apr_array_copy(mp,\n                child->ruleset->phase_request_headers);\n            merged->ruleset->phase_request_body = apr_array_copy(mp,\n                child->ruleset->phase_request_body);\n            merged->ruleset->phase_response_headers = apr_array_copy(mp,\n                child->ruleset->phase_response_headers);\n            merged->ruleset->phase_response_body = apr_array_copy(mp,\n                child->ruleset->phase_response_body);\n            merged->ruleset->phase_logging = apr_array_copy(mp,\n                child->ruleset->phase_logging);\n        } else {\n            #ifdef DEBUG_CONF\n            ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, mp, \"Using parent then child rules in this context.\");\n            #endif\n\n            /* Copy parent rules, then add child rules to it. */\n            merged->ruleset = msre_ruleset_create(parent->ruleset->engine, mp);\n            copy_rules(mp, parent->ruleset, merged->ruleset, child->rule_exceptions);\n\n            apr_array_cat(merged->ruleset->phase_request_headers,\n                child->ruleset->phase_request_headers);\n            apr_array_cat(merged->ruleset->phase_request_body,\n                child->ruleset->phase_request_body);\n            apr_array_cat(merged->ruleset->phase_response_headers,\n                child->ruleset->phase_response_headers);\n            apr_array_cat(merged->ruleset->phase_response_body,\n                child->ruleset->phase_response_body);\n            apr_array_cat(merged->ruleset->phase_logging,\n                child->ruleset->phase_logging);\n        }\n    } else {\n        merged->rule_inheritance = 0;\n        if (child->ruleset != NULL) {\n            /* Copy child rules. */\n            merged->ruleset = msre_ruleset_create(child->ruleset->engine, mp);\n            merged->ruleset->phase_request_headers = apr_array_copy(mp,\n                child->ruleset->phase_request_headers);\n            merged->ruleset->phase_request_body = apr_array_copy(mp,\n                child->ruleset->phase_request_body);\n            merged->ruleset->phase_response_headers = apr_array_copy(mp,\n                child->ruleset->phase_response_headers);\n            merged->ruleset->phase_response_body = apr_array_copy(mp,\n                child->ruleset->phase_response_body);\n            merged->ruleset->phase_logging = apr_array_copy(mp,\n                child->ruleset->phase_logging);\n        }\n    }\n\n    /* Merge rule exceptions. */\n    merged->rule_exceptions = apr_array_append(mp, parent->rule_exceptions,\n        child->rule_exceptions);\n\n    merged->hash_method = apr_array_append(mp, parent->hash_method,\n        child->hash_method);\n\n    /* audit log variables */\n    merged->auditlog_flag = (child->auditlog_flag == NOT_SET\n        ? parent->auditlog_flag : child->auditlog_flag);\n    merged->auditlog_type = (child->auditlog_type == NOT_SET\n        ? parent->auditlog_type : child->auditlog_type);\n    merged->max_rule_time = (child->max_rule_time == NOT_SET\n        ? parent->max_rule_time : child->max_rule_time);\n    merged->auditlog_dirperms = (child->auditlog_dirperms == NOT_SET\n        ? parent->auditlog_dirperms : child->auditlog_dirperms);\n    merged->auditlog_fileperms = (child->auditlog_fileperms == NOT_SET\n        ? parent->auditlog_fileperms : child->auditlog_fileperms);\n    if (child->auditlog_fd != NOT_SET_P) {\n        merged->auditlog_fd = child->auditlog_fd;\n        merged->auditlog_name = child->auditlog_name;\n    } else {\n        merged->auditlog_fd = parent->auditlog_fd;\n        merged->auditlog_name = parent->auditlog_name;\n    }\n    if (child->auditlog2_fd != NOT_SET_P) {\n        merged->auditlog2_fd = child->auditlog2_fd;\n        merged->auditlog2_name = child->auditlog2_name;\n    } else {\n        merged->auditlog2_fd = parent->auditlog2_fd;\n        merged->auditlog2_name = parent->auditlog2_name;\n    }\n    merged->auditlog_storage_dir = (child->auditlog_storage_dir == NOT_SET_P\n        ? parent->auditlog_storage_dir : child->auditlog_storage_dir);\n    merged->auditlog_parts = (child->auditlog_parts == NOT_SET_P\n        ? parent->auditlog_parts : child->auditlog_parts);\n    merged->auditlog_relevant_regex = (child->auditlog_relevant_regex == NOT_SET_P\n        ? parent->auditlog_relevant_regex : child->auditlog_relevant_regex);\n\n    /* Upload */\n    merged->tmp_dir = (child->tmp_dir == NOT_SET_P\n        ? parent->tmp_dir : child->tmp_dir);\n    merged->upload_dir = (child->upload_dir == NOT_SET_P\n        ? parent->upload_dir : child->upload_dir);\n    merged->upload_keep_files = (child->upload_keep_files == NOT_SET\n        ? parent->upload_keep_files : child->upload_keep_files);\n    merged->upload_validates_files = (child->upload_validates_files == NOT_SET\n        ? parent->upload_validates_files : child->upload_validates_files);\n    merged->upload_filemode = (child->upload_filemode == NOT_SET\n        ? parent->upload_filemode : child->upload_filemode);\n    merged->upload_file_limit = (child->upload_file_limit == NOT_SET\n        ? parent->upload_file_limit : child->upload_file_limit);\n\n    /* Misc */\n    merged->data_dir = (child->data_dir == NOT_SET_P\n        ? parent->data_dir : child->data_dir);\n    merged->webappid = (child->webappid == NOT_SET_P\n        ? parent->webappid : child->webappid);\n    merged->sensor_id = (child->sensor_id == NOT_SET_P\n        ? parent->sensor_id : child->sensor_id);\n    merged->httpBlkey = (child->httpBlkey == NOT_SET_P\n        ? parent->httpBlkey : child->httpBlkey);\n\n    /* Content injection. */\n    merged->content_injection_enabled = (child->content_injection_enabled == NOT_SET\n        ? parent->content_injection_enabled : child->content_injection_enabled);\n\n    /* Stream inspection */\n    merged->stream_inbody_inspection = (child->stream_inbody_inspection == NOT_SET\n        ? parent->stream_inbody_inspection : child->stream_inbody_inspection);\n    merged->stream_outbody_inspection = (child->stream_outbody_inspection == NOT_SET\n        ? parent->stream_outbody_inspection : child->stream_outbody_inspection);\n\n    /* Geo Lookup */\n    merged->geo = (child->geo == NOT_SET_P\n        ? parent->geo : child->geo);\n\n    /* Gsb Lookup */\n    merged->gsb = (child->gsb == NOT_SET_P\n        ? parent->gsb : child->gsb);\n\n    /* Unicode Map */\n    merged->u_map = (child->u_map == NOT_SET_P\n        ? parent->u_map : child->u_map);\n\n    /* Cache */\n    merged->cache_trans = (child->cache_trans == NOT_SET\n        ? parent->cache_trans : child->cache_trans);\n    merged->cache_trans_incremental = (child->cache_trans_incremental == NOT_SET\n        ? parent->cache_trans_incremental : child->cache_trans_incremental);\n    merged->cache_trans_min = (child->cache_trans_min == (apr_size_t)NOT_SET\n        ? parent->cache_trans_min : child->cache_trans_min);\n    merged->cache_trans_max = (child->cache_trans_max == (apr_size_t)NOT_SET\n        ? parent->cache_trans_max : child->cache_trans_max);\n    merged->cache_trans_maxitems = (child->cache_trans_maxitems == (apr_size_t)NOT_SET\n        ? parent->cache_trans_maxitems : child->cache_trans_maxitems);\n\n    /* Merge component signatures. */\n    merged->component_signatures = apr_array_append(mp, parent->component_signatures,\n        child->component_signatures);\n\n    merged->request_encoding = (child->request_encoding == NOT_SET_P\n        ? parent->request_encoding : child->request_encoding);\n\n    merged->disable_backend_compression = (child->disable_backend_compression == NOT_SET\n        ? parent->disable_backend_compression : child->disable_backend_compression);\n\n    merged->col_timeout = (child->col_timeout == NOT_SET\n        ? parent->col_timeout : child->col_timeout);\n\n    /* Hash */\n    merged->crypto_key = (child->crypto_key == NOT_SET_P\n        ? parent->crypto_key : child->crypto_key);\n    merged->crypto_key_len = (child->crypto_key_len == NOT_SET\n        ? parent->crypto_key_len : child->crypto_key_len);\n    merged->crypto_key_add = (child->crypto_key_add == NOT_SET\n        ? parent->crypto_key_add : child->crypto_key_add);\n    merged->crypto_param_name = (child->crypto_param_name == NOT_SET_P\n        ? parent->crypto_param_name : child->crypto_param_name);\n    merged->hash_is_enabled = (child->hash_is_enabled == NOT_SET\n        ? parent->hash_is_enabled : child->hash_is_enabled);\n    merged->hash_enforcement = (child->hash_enforcement == NOT_SET\n        ? parent->hash_enforcement : child->hash_enforcement);\n    merged->crypto_hash_href_rx = (child->crypto_hash_href_rx == NOT_SET\n        ? parent->crypto_hash_href_rx : child->crypto_hash_href_rx);\n    merged->crypto_hash_faction_rx = (child->crypto_hash_faction_rx == NOT_SET\n        ? parent->crypto_hash_faction_rx : child->crypto_hash_faction_rx);\n    merged->crypto_hash_location_rx = (child->crypto_hash_location_rx == NOT_SET\n        ? parent->crypto_hash_location_rx : child->crypto_hash_location_rx);\n    merged->crypto_hash_iframesrc_rx = (child->crypto_hash_iframesrc_rx == NOT_SET\n        ? parent->crypto_hash_iframesrc_rx : child->crypto_hash_iframesrc_rx);\n    merged->crypto_hash_framesrc_rx = (child->crypto_hash_framesrc_rx == NOT_SET\n        ? parent->crypto_hash_framesrc_rx : child->crypto_hash_framesrc_rx);\n    merged->crypto_hash_href_pm = (child->crypto_hash_href_pm == NOT_SET\n        ? parent->crypto_hash_href_pm : child->crypto_hash_href_pm);\n    merged->crypto_hash_faction_pm = (child->crypto_hash_faction_pm == NOT_SET\n        ? parent->crypto_hash_faction_pm : child->crypto_hash_faction_pm);\n    merged->crypto_hash_location_pm = (child->crypto_hash_location_pm == NOT_SET\n        ? parent->crypto_hash_location_pm : child->crypto_hash_location_pm);\n    merged->crypto_hash_iframesrc_pm = (child->crypto_hash_iframesrc_pm == NOT_SET\n        ? parent->crypto_hash_iframesrc_pm : child->crypto_hash_iframesrc_pm);\n    merged->crypto_hash_framesrc_pm = (child->crypto_hash_framesrc_pm == NOT_SET\n        ? parent->crypto_hash_framesrc_pm : child->crypto_hash_framesrc_pm);\n\n    return merged;\n}\n\n/**\n * Initialise directory configuration. This function is *not* meant\n * to be called for directory configuration instances created during\n * the configuration phase. It can only be called on copies of those\n * (created fresh for every transaction).\n */\nvoid init_directory_config(directory_config *dcfg)\n{\n    if (dcfg == NULL) return;\n\n    if (dcfg->is_enabled == NOT_SET) dcfg->is_enabled = 0;\n\n    if (dcfg->reqbody_access == NOT_SET) dcfg->reqbody_access = 0;\n    if (dcfg->reqintercept_oe == NOT_SET) dcfg->reqintercept_oe = 0;\n    if (dcfg->reqbody_buffering == NOT_SET) dcfg->reqbody_buffering = REQUEST_BODY_FORCEBUF_OFF;\n    if (dcfg->reqbody_inmemory_limit == NOT_SET)\n        dcfg->reqbody_inmemory_limit = REQUEST_BODY_DEFAULT_INMEMORY_LIMIT;\n    if (dcfg->reqbody_limit == NOT_SET) dcfg->reqbody_limit = REQUEST_BODY_DEFAULT_LIMIT;\n    if (dcfg->reqbody_no_files_limit == NOT_SET) dcfg->reqbody_no_files_limit = REQUEST_BODY_NO_FILES_DEFAULT_LIMIT;\n    if (dcfg->resbody_access == NOT_SET) dcfg->resbody_access = 0;\n    if (dcfg->of_limit == NOT_SET) dcfg->of_limit = RESPONSE_BODY_DEFAULT_LIMIT;\n    if (dcfg->if_limit_action == NOT_SET) dcfg->if_limit_action = REQUEST_BODY_LIMIT_ACTION_REJECT;\n    if (dcfg->of_limit_action == NOT_SET) dcfg->of_limit_action = RESPONSE_BODY_LIMIT_ACTION_REJECT;\n\n    if (dcfg->of_mime_types == NOT_SET_P) {\n        dcfg->of_mime_types = apr_table_make(dcfg->mp, 3);\n        if (dcfg->of_mime_types_cleared != 1) {\n            apr_table_setn(dcfg->of_mime_types, \"text/plain\", \"1\");\n            apr_table_setn(dcfg->of_mime_types, \"text/html\", \"1\");\n        }\n    }\n\n    if (dcfg->debuglog_fd == NOT_SET_P) dcfg->debuglog_fd = NULL;\n    if (dcfg->debuglog_name == NOT_SET_P) dcfg->debuglog_name = NULL;\n    if (dcfg->debuglog_level == NOT_SET) dcfg->debuglog_level = 0;\n\n    if (dcfg->cookie_format == NOT_SET) dcfg->cookie_format = 0;\n    if (dcfg->argument_separator == NOT_SET) dcfg->argument_separator = '&';\n    if (dcfg->cookiev0_separator == NOT_SET_P) dcfg->cookiev0_separator = NULL;\n\n    if (dcfg->rule_inheritance == NOT_SET) dcfg->rule_inheritance = 1;\n\n    /* audit log variables */\n    if (dcfg->auditlog_flag == NOT_SET) dcfg->auditlog_flag = 0;\n    if (dcfg->auditlog_type == NOT_SET) dcfg->auditlog_type = AUDITLOG_SERIAL;\n    if (dcfg->max_rule_time == NOT_SET) dcfg->max_rule_time = 0;\n    if (dcfg->auditlog_dirperms == NOT_SET) dcfg->auditlog_dirperms = CREATEMODE_DIR;\n    if (dcfg->auditlog_fileperms == NOT_SET) dcfg->auditlog_fileperms = CREATEMODE;\n    if (dcfg->auditlog_fd == NOT_SET_P) dcfg->auditlog_fd = NULL;\n    if (dcfg->auditlog2_fd == NOT_SET_P) dcfg->auditlog2_fd = NULL;\n    if (dcfg->auditlog_name == NOT_SET_P) dcfg->auditlog_name = NULL;\n    if (dcfg->auditlog2_name == NOT_SET_P) dcfg->auditlog2_name = NULL;\n    if (dcfg->auditlog_storage_dir == NOT_SET_P) dcfg->auditlog_storage_dir = NULL;\n    if (dcfg->auditlog_parts == NOT_SET_P) dcfg->auditlog_parts = \"ABCFHZ\";\n    if (dcfg->auditlog_relevant_regex == NOT_SET_P) dcfg->auditlog_relevant_regex = NULL;\n\n    /* Upload */\n    if (dcfg->tmp_dir == NOT_SET_P) dcfg->tmp_dir = guess_tmp_dir(dcfg->mp);\n    if (dcfg->upload_dir == NOT_SET_P) dcfg->upload_dir = NULL;\n    if (dcfg->upload_keep_files == NOT_SET) dcfg->upload_keep_files = KEEP_FILES_OFF;\n    if (dcfg->upload_validates_files == NOT_SET) dcfg->upload_validates_files = 0;\n    if (dcfg->upload_filemode == NOT_SET) dcfg->upload_filemode = 0600;\n    if (dcfg->upload_file_limit == NOT_SET) dcfg->upload_file_limit = 100;\n\n    /* Misc */\n    if (dcfg->data_dir == NOT_SET_P) dcfg->data_dir = NULL;\n    if (dcfg->webappid == NOT_SET_P) dcfg->webappid = \"default\";\n    if (dcfg->sensor_id == NOT_SET_P) dcfg->sensor_id = \"default\";\n    if (dcfg->httpBlkey == NOT_SET_P) dcfg->httpBlkey = NULL;\n\n    /* Content injection. */\n    if (dcfg->content_injection_enabled == NOT_SET) dcfg->content_injection_enabled = 0;\n\n    /* Stream inspection */\n    if (dcfg->stream_inbody_inspection == NOT_SET) dcfg->stream_inbody_inspection = 0;\n    if (dcfg->stream_outbody_inspection == NOT_SET) dcfg->stream_outbody_inspection = 0;\n\n    /* Geo Lookup */\n    if (dcfg->geo == NOT_SET_P) dcfg->geo = NULL;\n\n    /* Gsb Lookup */\n    if (dcfg->gsb == NOT_SET_P) dcfg->gsb = NULL;\n\n    /* Unicode Map */\n    if (dcfg->u_map == NOT_SET_P) dcfg->u_map = NULL;\n\n    /* Cache */\n    if (dcfg->cache_trans == NOT_SET) dcfg->cache_trans = MODSEC_CACHE_DISABLED;\n    if (dcfg->cache_trans_incremental == NOT_SET) dcfg->cache_trans_incremental = 0;\n    if (dcfg->cache_trans_min == (apr_size_t)NOT_SET) dcfg->cache_trans_min = 32;\n    if (dcfg->cache_trans_max == (apr_size_t)NOT_SET) dcfg->cache_trans_max = 1024;\n    if (dcfg->cache_trans_maxitems == (apr_size_t)NOT_SET) dcfg->cache_trans_maxitems = 512;\n\n    if (dcfg->request_encoding == NOT_SET_P) dcfg->request_encoding = NULL;\n\n    if (dcfg->disable_backend_compression == NOT_SET) dcfg->disable_backend_compression = 0;\n\n    if (dcfg->col_timeout == NOT_SET) dcfg->col_timeout = 3600;\n\n    /* Hash */\n    if (dcfg->crypto_key == NOT_SET_P) dcfg->crypto_key = getkey(dcfg->mp);\n    if (dcfg->crypto_key_len == NOT_SET) dcfg->crypto_key_len = strlen(dcfg->crypto_key);\n    if (dcfg->crypto_key_add == NOT_SET) dcfg->crypto_key_add = HASH_KEYONLY;\n    if (dcfg->crypto_param_name == NOT_SET_P) dcfg->crypto_param_name = \"crypt\";\n    if (dcfg->hash_is_enabled == NOT_SET) dcfg->hash_is_enabled = HASH_DISABLED;\n    if (dcfg->hash_enforcement == NOT_SET) dcfg->hash_enforcement = HASH_DISABLED;\n    if (dcfg->crypto_hash_href_rx == NOT_SET) dcfg->crypto_hash_href_rx = 0;\n    if (dcfg->crypto_hash_faction_rx == NOT_SET) dcfg->crypto_hash_faction_rx = 0;\n    if (dcfg->crypto_hash_location_rx == NOT_SET) dcfg->crypto_hash_location_rx = 0;\n    if (dcfg->crypto_hash_iframesrc_rx == NOT_SET) dcfg->crypto_hash_iframesrc_rx = 0;\n    if (dcfg->crypto_hash_framesrc_rx == NOT_SET) dcfg->crypto_hash_framesrc_rx = 0;\n    if (dcfg->crypto_hash_href_pm == NOT_SET) dcfg->crypto_hash_href_pm = 0;\n    if (dcfg->crypto_hash_faction_pm == NOT_SET) dcfg->crypto_hash_faction_pm = 0;\n    if (dcfg->crypto_hash_location_pm == NOT_SET) dcfg->crypto_hash_location_pm = 0;\n    if (dcfg->crypto_hash_iframesrc_pm == NOT_SET) dcfg->crypto_hash_iframesrc_pm = 0;\n    if (dcfg->crypto_hash_framesrc_pm == NOT_SET) dcfg->crypto_hash_framesrc_pm = 0;\n\n}\n\n/**\n *\n */\nstatic const char *add_rule(cmd_parms *cmd, directory_config *dcfg, int type,\n                            const char *p1, const char *p2, const char *p3)\n{\n    char *my_error_msg = NULL;\n    //msre_rule *rule = NULL, *tmp_rule = NULL;\n    char *rid = NULL;\n    msre_rule *rule = NULL;\n    extern msc_engine *modsecurity;\n    int offset = 0;\n\n    #ifdef DEBUG_CONF\n    ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, cmd->pool,\n        \"Rule: type=%d p1='%s' p2='%s' p3='%s'\", type, p1, p2, p3);\n    #endif\n\n    /* Create a ruleset if one does not exist. */\n    if ((dcfg->ruleset == NULL)||(dcfg->ruleset == NOT_SET_P)) {\n        dcfg->ruleset = msre_ruleset_create(modsecurity->msre, cmd->pool);\n        if (dcfg->ruleset == NULL) return FATAL_ERROR;\n    }\n\n    /* Create the rule now. */\n    switch(type) {\n        #if defined(WITH_LUA)\n        case RULE_TYPE_LUA :\n            rule = msre_rule_lua_create(dcfg->ruleset, cmd->directive->filename,\n                cmd->directive->line_num, p1, p2, &my_error_msg);\n            break;\n        #endif\n        default :\n            rule = msre_rule_create(dcfg->ruleset, type, cmd->directive->filename,\n                cmd->directive->line_num, p1, p2, p3, &my_error_msg);\n            break;\n    }\n\n    if (rule == NULL) {\n        return my_error_msg;\n    }\n\n    /* Rules must have uniq ID */\n    if (\n#if defined(WITH_LUA)\n            type != RULE_TYPE_LUA &&\n#endif\n            (dcfg->tmp_chain_starter == NULL))\n                if(rule->actionset == NULL)\n                    return \"ModSecurity: Rules must have at least id action\";\n\n    if(rule->actionset != NULL && (dcfg->tmp_chain_starter == NULL))    {\n        if(rule->actionset->id == NOT_SET_P\n#if defined(WITH_LUA)\n            && (type != RULE_TYPE_LUA)\n#endif\n          )\n            return \"ModSecurity: No action id present within the rule\";\n#if defined(WITH_LUA)\n        if(type != RULE_TYPE_LUA)\n#endif\n        {\n            rid = apr_hash_get(dcfg->rule_id_htab, rule->actionset->id, APR_HASH_KEY_STRING);\n            if(rid != NULL) {\n                return \"ModSecurity: Found another rule with the same id\";\n            } else    {\n                apr_hash_set(dcfg->rule_id_htab, apr_pstrdup(dcfg->mp, rule->actionset->id), APR_HASH_KEY_STRING, apr_pstrdup(dcfg->mp, \"1\"));\n            }\n\n            //tmp_rule = msre_ruleset_fetch_rule(dcfg->ruleset, rule->actionset->id, offset);\n            //if(tmp_rule != NULL)\n            //    return \"ModSecurity: Found another rule with the same id\";\n        }\n    }\n\n    /* Create default actionset if one does not already exist. */\n    if (dcfg->tmp_default_actionset == NULL) {\n        dcfg->tmp_default_actionset = msre_actionset_create_default(modsecurity->msre);\n        if (dcfg->tmp_default_actionset == NULL) return FATAL_ERROR;\n    }\n\n    /* Check some cases prior to merging so we know where it came from */\n\n    /* Check syntax for chained rules */\n    if ((rule->actionset != NULL) && (dcfg->tmp_chain_starter != NULL)) {\n        /* Must NOT specify a disruptive action. */\n        if (rule->actionset->intercept_action != NOT_SET) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: Disruptive actions can only \"\n                \"be specified by chain starter rules.\");\n        }\n\n        /* Must NOT specify a skipafter action. */\n        if (rule->actionset->skip_after != NOT_SET_P) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: SkipAfter actions can only \"\n                \"be specified by chain starter rules.\");\n        }\n\n        /* Must NOT specify a phase. */\n        if (rule->actionset->phase != NOT_SET) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: Execution phases can only be \"\n                \"specified by chain starter rules.\");\n        }\n\n        /* Must NOT use metadata actions. */\n        /* ENH: loop through to check for tags */\n        if ((rule->actionset->id != NOT_SET_P)\n            ||(rule->actionset->rev != NOT_SET_P)\n            ||(rule->actionset->msg != NOT_SET_P)\n            ||(rule->actionset->severity != NOT_SET)\n            ||(rule->actionset->version != NOT_SET_P)\n            ||(rule->actionset->accuracy != NOT_SET)\n            ||(rule->actionset->maturity != NOT_SET)\n            ||(rule->actionset->logdata != NOT_SET_P))\n        {\n            return apr_psprintf(cmd->pool, \"ModSecurity: Metadata actions (id, rev, msg, tag, severity, ver, accuracy, maturity, logdata) \"\n                \" can only be specified by chain starter rules.\");\n        }\n\n        /* Must NOT use skip. */\n        if (rule->actionset->skip_count != NOT_SET) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: The skip action can only be used \"\n                \" by chain starter rules. \");\n        }\n    }\n\n    /* Merge actions with the parent.\n     *\n     * ENH Probably do not want this done fully for chained rules.\n     */\n    rule->actionset = msre_actionset_merge(modsecurity->msre, dcfg->tmp_default_actionset,\n        rule->actionset, 1);\n\n    /* Keep track of the parent action for \"block\" */\n    rule->actionset->parent_intercept_action_rec = dcfg->tmp_default_actionset->intercept_action_rec;\n    rule->actionset->parent_intercept_action = dcfg->tmp_default_actionset->intercept_action;\n\n    /* Must NOT specify a disruptive action in logging phase. */\n    if ((rule->actionset != NULL)\n        && (rule->actionset->phase == PHASE_LOGGING)\n        && (rule->actionset->intercept_action != ACTION_ALLOW)\n        && (rule->actionset->intercept_action != ACTION_ALLOW_REQUEST)\n        && (rule->actionset->intercept_action != ACTION_NONE)\n    ) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Disruptive actions \"\n            \"cannot be specified in the logging phase.\");\n    }\n\n    if (dcfg->tmp_chain_starter != NULL) {\n        rule->chain_starter = dcfg->tmp_chain_starter;\n        rule->actionset->phase = rule->chain_starter->actionset->phase;\n    }\n\n    if (rule->actionset->is_chained != 1) {\n        /* If this rule is part of the chain but does\n         * not want more rules to follow in the chain\n         * then cut it (the chain).\n         */\n        dcfg->tmp_chain_starter = NULL;\n    } else {\n        /* On the other hand, if this rule wants other\n         * rules to follow it, then start a new chain\n         * if there isn't one already.\n         */\n        if (dcfg->tmp_chain_starter == NULL) {\n            dcfg->tmp_chain_starter = rule;\n        }\n    }\n\n    /* Optimisation */\n    if ((rule->op_name != NULL)&&(strcasecmp(rule->op_name, \"inspectFile\") == 0)) {\n        dcfg->upload_validates_files = 1;\n    }\n\n    /* Create skip table if one does not already exist. */\n    if (dcfg->tmp_rule_placeholders == NULL) {\n        dcfg->tmp_rule_placeholders = apr_table_make(cmd->pool, 10);\n        if (dcfg->tmp_rule_placeholders == NULL) return FATAL_ERROR;\n    }\n\n    /* Keep track of any rule IDs we need to skip after */\n    if (rule->actionset->skip_after != NOT_SET_P) {\n        char *tmp_id = apr_pstrdup(cmd->pool, rule->actionset->skip_after);\n        apr_table_setn(dcfg->tmp_rule_placeholders, tmp_id, tmp_id);\n\n        #ifdef DEBUG_CONF\n        ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, cmd->pool,\n            \"Watching for skipafter target rule id=\\\"%s\\\".\", tmp_id);\n        #endif\n\n    }\n\n    #ifdef DEBUG_CONF\n    ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, cmd->pool,\n        \"Adding rule %pp phase=%d id=\\\"%s\\\".\", rule, rule->actionset->phase, (rule->actionset->id == NOT_SET_P\n        ? \"(none)\" : rule->actionset->id));\n    #endif\n\n    /* Add rule to the recipe. */\n    if (msre_ruleset_rule_add(dcfg->ruleset, rule, rule->actionset->phase) < 0) {\n        return \"Internal Error: Failed to add rule to the ruleset.\";\n    }\n\n    /* Add an additional placeholder if this rule ID is on the list */\n    if ((rule->actionset->id != NULL) && apr_table_get(dcfg->tmp_rule_placeholders, rule->actionset->id)) {\n        msre_rule *phrule = apr_palloc(rule->ruleset->mp, sizeof(msre_rule));\n        if (phrule == NULL) {\n            return FATAL_ERROR;\n        }\n\n        #ifdef DEBUG_CONF\n        ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, cmd->pool,\n            \"Adding placeholder %pp for rule %pp id=\\\"%s\\\".\", phrule, rule, rule->actionset->id);\n        #endif\n\n        /* shallow copy of original rule with placeholder marked as target */\n        memcpy(phrule, rule, sizeof(msre_rule));\n        phrule->placeholder = RULE_PH_SKIPAFTER;\n\n        /* Add placeholder. */\n        if (msre_ruleset_rule_add(dcfg->ruleset, phrule, phrule->actionset->phase) < 0) {\n            return \"Internal Error: Failed to add placeholder to the ruleset.\";\n        }\n\n        /* No longer need to search for the ID */\n        apr_table_unset(dcfg->tmp_rule_placeholders, rule->actionset->id);\n    }\n\n    /* Update the unparsed rule */\n    rule->unparsed = msre_rule_generate_unparsed(dcfg->ruleset->mp, rule, NULL, NULL, NULL);\n\n    return NULL;\n}\n\n/**\n *\n */\nstatic const char *add_marker(cmd_parms *cmd, directory_config *dcfg,\n                              const char *p1, const char *p2, const char *p3)\n{\n    char *my_error_msg = NULL;\n    msre_rule *rule = NULL;\n    extern msc_engine *modsecurity;\n    int p;\n\n    #ifdef DEBUG_CONF\n    ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, cmd->pool,\n        \"Rule: type=%d p1='%s' p2='%s' p3='%s'\", RULE_TYPE_MARKER, p1, p2, p3);\n    #endif\n\n    /* Create a ruleset if one does not exist. */\n    if ((dcfg->ruleset == NULL)||(dcfg->ruleset == NOT_SET_P)) {\n        dcfg->ruleset = msre_ruleset_create(modsecurity->msre, cmd->pool);\n        if (dcfg->ruleset == NULL) return FATAL_ERROR;\n    }\n\n    /* Create the rule now. */\n    rule = msre_rule_create(dcfg->ruleset, RULE_TYPE_MARKER, cmd->directive->filename, cmd->directive->line_num, p1, p2, p3, &my_error_msg);\n    if (rule == NULL) {\n        return my_error_msg;\n    }\n\n    /* This is a marker */\n    rule->placeholder = RULE_PH_MARKER;\n\n    /* Add placeholder to each phase */\n    for (p = PHASE_FIRST; p <= PHASE_LAST; p++) {\n        #ifdef DEBUG_CONF\n        ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, cmd->pool,\n            \"Adding marker %pp phase=%d id=\\\"%s\\\".\", rule, p, (rule->actionset->id == NOT_SET_P\n            ? \"(none)\" : rule->actionset->id));\n        #endif\n\n        if (msre_ruleset_rule_add(dcfg->ruleset, rule, p) < 0) {\n            return \"Internal Error: Failed to add marker to the ruleset.\";\n        }\n    }\n\n    /* No longer need to search for the ID */\n    if (dcfg->tmp_rule_placeholders != NULL) {\n        apr_table_unset(dcfg->tmp_rule_placeholders, rule->actionset->id);\n    }\n\n    return NULL;\n}\n\n/**\n *\n */\nstatic const char *update_rule_action(cmd_parms *cmd, directory_config *dcfg,\n                                      const char *p1, const char *p2, int offset)\n{\n    char *my_error_msg = NULL;\n    msre_rule *rule = NULL;\n    msre_actionset *new_actionset = NULL;\n    msre_ruleset *ruleset = dcfg->ruleset;\n    extern msc_engine *modsecurity;\n\n    /* Get the ruleset if one exists */\n    if ((ruleset == NULL)||(ruleset == NOT_SET_P)) {\n        return NULL;\n    }\n\n    #ifdef DEBUG_CONF\n    ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, cmd->pool,\n        \"Update rule id=\\\"%s\\\" with action \\\"%s\\\".\", p1, p2);\n    #endif\n\n    /* Fetch the rule */\n    rule = msre_ruleset_fetch_rule(ruleset, p1, offset);\n    if (rule == NULL) {\n        #ifdef DEBUG_CONF\n        ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, cmd->pool,\n            \"Update rule id=\\\"%s\\\" with action \\\"%s\\\" failed: Rule not found.\", p1, p2);\n        #endif\n        return NULL;\n    }\n\n    /* Check the rule actionset */\n    /* ENH: Can this happen? */\n    if (rule->actionset == NULL) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Attempt to update action for rule \\\"%s\\\" failed: Rule does not have an actionset.\", p1);\n    }\n\n    /* Create a new actionset */\n    new_actionset = msre_actionset_create(modsecurity->msre, p2, &my_error_msg);\n    if (new_actionset == NULL) return FATAL_ERROR;\n    if (my_error_msg != NULL) return my_error_msg;\n\n    /* Must NOT change an id */\n    if ((new_actionset->id != NOT_SET_P) && (rule->actionset->id != NULL) && (strcmp(rule->actionset->id, new_actionset->id) != 0)) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Rule IDs cannot be updated via SecRuleUpdateActionById.\");\n    }\n\n    /* Must NOT alter the phase */\n    if ((new_actionset->phase != NOT_SET) && (rule->actionset->phase != new_actionset->phase)) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Rule phases cannot be updated via SecRuleUpdateActionById.\");\n    }\n\n    #ifdef DEBUG_CONF\n    {\n        char *actions = msre_actionset_generate_action_string(ruleset->mp, rule->actionset);\n        ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, cmd->pool,\n            \"Update rule %pp id=\\\"%s\\\" old action: \\\"%s\\\"\",\n            rule,\n            (rule->actionset->id == NOT_SET_P ? \"(none)\" : rule->actionset->id),\n            actions);\n    }\n    #endif\n\n    /* Merge new actions with the rule */\n    /* ENH: Will this leak the old actionset? */\n    rule->actionset = msre_actionset_merge(modsecurity->msre, rule->actionset,\n        new_actionset, 1);\n    msre_actionset_set_defaults(rule->actionset);\n\n    /* Update the unparsed rule */\n    rule->unparsed = msre_rule_generate_unparsed(ruleset->mp, rule, NULL, NULL, NULL);\n\n    #ifdef DEBUG_CONF\n    {\n        char *actions = msre_actionset_generate_action_string(ruleset->mp, rule->actionset);\n        ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, cmd->pool,\n            \"Update rule %pp id=\\\"%s\\\" new action: \\\"%s\\\"\",\n            rule,\n            (rule->actionset->id == NOT_SET_P ? \"(none)\" : rule->actionset->id),\n            actions);\n    }\n    #endif\n\n    return NULL;\n}\n\n/* -- Configuration directives -- */\n\nstatic const char *cmd_action(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    return add_rule(cmd, (directory_config *)_dcfg, RULE_TYPE_ACTION, SECACTION_TARGETS, SECACTION_ARGS, p1);\n}\n\nstatic const char *cmd_marker(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    const char *action = apr_pstrcat(dcfg->mp, SECMARKER_BASE_ACTIONS, p1, NULL);\n    return add_marker(cmd, (directory_config *)_dcfg, SECMARKER_TARGETS, SECMARKER_ARGS, action);\n}\n\nstatic const char *cmd_cookiev0_separator(cmd_parms *cmd, void *_dcfg,\n        const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n\n    if (strlen(p1) != 1) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Invalid cookie v0 separator: %s\", p1);\n    }\n\n    dcfg->cookiev0_separator = p1;\n\n    return NULL;\n}\n\nstatic const char *cmd_argument_separator(cmd_parms *cmd, void *_dcfg,\n        const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n\n    if (strlen(p1) != 1) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Invalid argument separator: %s\", p1);\n    }\n\n    dcfg->argument_separator = p1[0];\n\n    return NULL;\n}\n\nstatic const char *cmd_audit_engine(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    directory_config *dcfg = _dcfg;\n\n    if (strcasecmp(p1, \"On\") == 0) dcfg->auditlog_flag = AUDITLOG_ON;\n    else\n        if (strcasecmp(p1, \"Off\") == 0) dcfg->auditlog_flag = AUDITLOG_OFF;\n        else\n            if (strcasecmp(p1, \"RelevantOnly\") == 0) dcfg->auditlog_flag = AUDITLOG_RELEVANT;\n            else\n                return (const char *)apr_psprintf(cmd->pool,\n                        \"ModSecurity: Unrecognised parameter value for SecAuditEngine: %s\", p1);\n\n    return NULL;\n}\n\nstatic const char *cmd_audit_log(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    directory_config *dcfg = _dcfg;\n\n    dcfg->auditlog_name = (char *)p1;\n\n    if (dcfg->auditlog_name[0] == '|') {\n        const char *pipe_name = dcfg->auditlog_name + 1;\n        piped_log *pipe_log;\n\n        pipe_log = ap_open_piped_log(cmd->pool, pipe_name);\n        if (pipe_log == NULL) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: Failed to open the audit log pipe: %s\",\n                    pipe_name);\n        }\n        dcfg->auditlog_fd = ap_piped_log_write_fd(pipe_log);\n    }\n    else {\n        const char *file_name = ap_server_root_relative(cmd->pool, dcfg->auditlog_name);\n        apr_status_t rc;\n\n        rc = apr_file_open(&dcfg->auditlog_fd, file_name,\n                APR_WRITE | APR_APPEND | APR_CREATE | APR_BINARY,\n                CREATEMODE, cmd->pool);\n\n        if (rc != APR_SUCCESS) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: Failed to open the audit log file: %s\",\n                    file_name);\n        }\n    }\n\n    return NULL;\n}\n\nstatic const char *cmd_audit_log2(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    directory_config *dcfg = _dcfg;\n\n    if (dcfg->auditlog_name == NOT_SET_P) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Cannot configure a secondary audit log without a primary defined: %s\", p1);\n    }\n\n    dcfg->auditlog2_name = (char *)p1;\n\n    if (dcfg->auditlog2_name[0] == '|') {\n        const char *pipe_name = ap_server_root_relative(cmd->pool, dcfg->auditlog2_name + 1);\n        piped_log *pipe_log;\n\n        pipe_log = ap_open_piped_log(cmd->pool, pipe_name);\n        if (pipe_log == NULL) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: Failed to open the secondary audit log pipe: %s\",\n                    pipe_name);\n        }\n        dcfg->auditlog2_fd = ap_piped_log_write_fd(pipe_log);\n    }\n    else {\n        const char *file_name = ap_server_root_relative(cmd->pool, dcfg->auditlog2_name);\n        apr_status_t rc;\n\n        rc = apr_file_open(&dcfg->auditlog2_fd, file_name,\n                APR_WRITE | APR_APPEND | APR_CREATE | APR_BINARY,\n                CREATEMODE, cmd->pool);\n\n        if (rc != APR_SUCCESS) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: Failed to open the secondary audit log file: %s\",\n                    file_name);\n        }\n    }\n\n    return NULL;\n}\n\nstatic const char *cmd_audit_log_parts(cmd_parms *cmd, void *_dcfg,\n        const char *p1)\n{\n    directory_config *dcfg = _dcfg;\n\n    if (is_valid_parts_specification((char *)p1) != 1) {\n        return apr_psprintf(cmd->pool, \"Invalid parts specification for SecAuditLogParts: %s\", p1);\n    }\n\n    dcfg->auditlog_parts = (char *)p1;\n    return NULL;\n}\n\nstatic const char *cmd_audit_log_relevant_status(cmd_parms *cmd, void *_dcfg,\n        const char *p1)\n{\n    directory_config *dcfg = _dcfg;\n\n    dcfg->auditlog_relevant_regex = msc_pregcomp(cmd->pool, p1, PCRE_DOTALL, NULL, NULL);\n    if (dcfg->auditlog_relevant_regex == NULL) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Invalid regular expression: %s\", p1);\n    }\n\n    return NULL;\n}\n\nstatic const char *cmd_audit_log_type(cmd_parms *cmd, void *_dcfg,\n        const char *p1)\n{\n    directory_config *dcfg = _dcfg;\n\n    if (strcasecmp(p1, \"Serial\") == 0) dcfg->auditlog_type = AUDITLOG_SERIAL;\n    else\n        if (strcasecmp(p1, \"Concurrent\") == 0) dcfg->auditlog_type = AUDITLOG_CONCURRENT;\n        else\n            return (const char *)apr_psprintf(cmd->pool,\n                    \"ModSecurity: Unrecognised parameter value for SecAuditLogType: %s\", p1);\n\n    return NULL;\n}\n\nstatic const char *cmd_audit_log_dirmode(cmd_parms *cmd, void *_dcfg,\n        const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n\n    if (dcfg == NULL) return NULL;\n\n    if (strcasecmp(p1, \"default\") == 0) {\n        dcfg->auditlog_dirperms = NOT_SET;\n    }\n    else {\n        long int mode = strtol(p1, NULL, 8); /* expects octal mode */\n        if ((mode == LONG_MAX)||(mode == LONG_MIN)||(mode <= 0)||(mode > 07777)) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecAuditLogDirMode: %s\", p1);\n        }\n\n        dcfg->auditlog_dirperms = mode2fileperms(mode);\n    }\n\n    return NULL;\n}\n\nstatic const char *cmd_audit_log_filemode(cmd_parms *cmd, void *_dcfg,\n        const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n\n    if (dcfg == NULL) return NULL;\n\n    if (strcasecmp(p1, \"default\") == 0) {\n        dcfg->auditlog_fileperms = NOT_SET;\n    }\n    else {\n        long int mode = strtol(p1, NULL, 8); /* expects octal mode */\n        if ((mode == LONG_MAX)||(mode == LONG_MIN)||(mode <= 0)||(mode > 07777)) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecAuditLogFileMode: %s\", p1);\n        }\n\n        dcfg->auditlog_fileperms = mode2fileperms(mode);\n    }\n\n    return NULL;\n}\n\nstatic const char *cmd_audit_log_storage_dir(cmd_parms *cmd, void *_dcfg,\n                                             const char *p1)\n{\n    directory_config *dcfg = _dcfg;\n\n    dcfg->auditlog_storage_dir = ap_server_root_relative(cmd->pool, p1);\n\n    return NULL;\n}\n\nstatic const char *cmd_cookie_format(cmd_parms *cmd, void *_dcfg,\n                                     const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n\n    if (strcmp(p1, \"0\") == 0) dcfg->cookie_format = COOKIES_V0;\n    else\n    if (strcmp(p1, \"1\") == 0) dcfg->cookie_format = COOKIES_V1;\n    else {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Invalid cookie format: %s\", p1);\n    }\n\n    return NULL;\n}\n\nstatic const char *cmd_chroot_dir(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    char cwd[1025] = \"\";\n\n    if (cmd->server->is_virtual) {\n        return \"ModSecurity: SecChrootDir not allowed in VirtualHost\";\n    }\n\n    chroot_dir = (char *)p1;\n\n    if (getcwd(cwd, 1024) == NULL) {\n        return \"ModSecurity: Failed to get the current working directory\";\n    }\n\n    if (chdir(chroot_dir) < 0) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Failed to chdir to %s, errno=%d (%s)\",\n            chroot_dir, errno, strerror(errno));\n    }\n\n    if (chdir(cwd) < 0) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Failed to chdir to %s, errno=%d (%s)\",\n            cwd, errno, strerror(errno));\n    }\n\n    return NULL;\n}\n\n/**\n * Adds component signature to the list of signatures kept in configuration.\n */\nstatic const char *cmd_component_signature(cmd_parms *cmd, void *_dcfg,\n                                           const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n\n    /* ENH Enforce \"Name/VersionX.Y.Z (comment)\" format. */\n    *(char **)apr_array_push(dcfg->component_signatures) = (char *)p1;\n\n    return NULL;\n}\n\nstatic const char *cmd_content_injection(cmd_parms *cmd, void *_dcfg, int flag)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n    dcfg->content_injection_enabled = flag;\n    return NULL;\n}\n\nstatic const char *cmd_data_dir(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n\n    if (cmd->server->is_virtual) {\n        return \"ModSecurity: SecDataDir not allowed in VirtualHost.\";\n    }\n\n    dcfg->data_dir = ap_server_root_relative(cmd->pool, p1);\n\n    return NULL;\n}\n\nstatic const char *cmd_debug_log(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    apr_status_t rc;\n\n    dcfg->debuglog_name = ap_server_root_relative(cmd->pool, p1);\n\n    rc = apr_file_open(&dcfg->debuglog_fd, dcfg->debuglog_name,\n                   APR_WRITE | APR_APPEND | APR_CREATE | APR_BINARY,\n                   CREATEMODE, cmd->pool);\n\n    if (rc != APR_SUCCESS) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Failed to open debug log file: %s\",\n            dcfg->debuglog_name);\n    }\n\n    return NULL;\n}\n\n/**\n* \\brief Add SecCollectionTimeout configuration option\n*\n* \\param cmd Pointer to configuration data\n* \\param _dcfg Pointer to directory configuration\n* \\param p1 Pointer to configuration option\n*\n* \\retval NULL On failure\n* \\retval apr_psprintf On Success\n*/\nstatic const char *cmd_collection_timeout(cmd_parms *cmd, void *_dcfg,\n                                       const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n\n    dcfg->col_timeout = atoi(p1);\n    /* max 30 days */\n    if ((dcfg->col_timeout >= 0)&&(dcfg->col_timeout <= 2592000)) return NULL;\n\n    return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecCollectionTimeout: %s\", p1);\n}\n\nstatic const char *cmd_debug_log_level(cmd_parms *cmd, void *_dcfg,\n                                       const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n\n    dcfg->debuglog_level = atoi(p1);\n    if ((dcfg->debuglog_level >= 0)&&(dcfg->debuglog_level <= 9)) return NULL;\n\n    return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecDebugLogLevel: %s\", p1);\n}\n\nstatic const char *cmd_default_action(cmd_parms *cmd, void *_dcfg,\n                                      const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    extern msc_engine *modsecurity;\n    char *my_error_msg = NULL;\n\n    dcfg->tmp_default_actionset = msre_actionset_create(modsecurity->msre, p1, &my_error_msg);\n    if (dcfg->tmp_default_actionset == NULL) {\n        if (my_error_msg != NULL) return my_error_msg;\n        else return FATAL_ERROR;\n    }\n\n    /* Must specify a disruptive action. */\n    /* ENH: Remove this requirement? */\n    if (dcfg->tmp_default_actionset->intercept_action == NOT_SET) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: SecDefaultAction must specify a disruptive action.\");\n    }\n\n    /* Must specify a phase. */\n    /* ENH: Remove this requirement? */\n    if (dcfg->tmp_default_actionset->phase == NOT_SET) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: SecDefaultAction must specify a phase.\");\n    }\n\n    /* Must not use metadata actions. */\n    /* ENH: loop through to check for tags */\n    if ((dcfg->tmp_default_actionset->id != NOT_SET_P)\n        ||(dcfg->tmp_default_actionset->rev != NOT_SET_P)\n        ||(dcfg->tmp_default_actionset->version != NOT_SET_P)\n        ||(dcfg->tmp_default_actionset->maturity != NOT_SET)\n        ||(dcfg->tmp_default_actionset->accuracy != NOT_SET)\n        ||(dcfg->tmp_default_actionset->msg != NOT_SET_P))\n    {\n        return apr_psprintf(cmd->pool, \"ModSecurity: SecDefaultAction must not \"\n            \"contain any metadata actions (id, rev, msg, tag, severity, ver, accuracy, maturity, logdata).\");\n    }\n    /* These are just a warning for now. */\n    if ((dcfg->tmp_default_actionset->severity != NOT_SET)\n        ||(dcfg->tmp_default_actionset->logdata != NOT_SET_P))\n    {\n        ap_log_perror(APLOG_MARK,\n            APLOG_STARTUP|APLOG_WARNING|APLOG_NOERRNO, 0, cmd->pool,\n            \"ModSecurity: WARNING Using \\\"severity\\\" or \\\"logdata\\\" in \"\n            \"SecDefaultAction is deprecated (%s:%d).\",\n            cmd->directive->filename, cmd->directive->line_num);\n    }\n\n    if (apr_table_get(dcfg->tmp_default_actionset->actions, \"t\")) {\n        ap_log_perror(APLOG_MARK,\n            APLOG_STARTUP|APLOG_WARNING|APLOG_NOERRNO, 0, cmd->pool,\n            \"ModSecurity: WARNING Using transformations in \"\n            \"SecDefaultAction is deprecated (%s:%d).\",\n            cmd->directive->filename, cmd->directive->line_num);\n    }\n\n    /* Must not use chain. */\n    if (dcfg->tmp_default_actionset->is_chained != NOT_SET) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: SecDefaultAction must not \"\n            \"contain a chain action.\");\n    }\n\n    /* Must not use skip. */\n    if (dcfg->tmp_default_actionset->skip_count != NOT_SET) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: SecDefaultAction must not \"\n            \"contain a skip action.\");\n    }\n\n    /* Must not use skipAfter. */\n    if (dcfg->tmp_default_actionset->skip_after != NOT_SET_P) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: SecDefaultAction must not \"\n            \"contain a skipAfter action.\");\n    }\n\n    return NULL;\n}\n\nstatic const char *cmd_disable_backend_compression(cmd_parms *cmd, void *_dcfg, int flag)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n    dcfg->disable_backend_compression = flag;\n    return NULL;\n}\n\nstatic const char *cmd_guardian_log(cmd_parms *cmd, void *_dcfg,\n                                    const char *p1, const char *p2)\n{\n    extern char *guardianlog_name;\n    extern apr_file_t *guardianlog_fd;\n    extern char *guardianlog_condition;\n\n    if (cmd->server->is_virtual) {\n        return \"ModSecurity: SecGuardianLog not allowed in VirtualHost\";\n    }\n\n    if (p2 != NULL) {\n        if (strncmp(p2, \"env=\", 4) != 0) {\n            return \"ModSecurity: Error in condition clause\";\n        }\n        if ( (p2[4] == '\\0') || ((p2[4] == '!')&&(p2[5] == '\\0')) ) {\n            return \"ModSecurity: Missing variable name\";\n        }\n        guardianlog_condition = apr_pstrdup(cmd->pool, p2 + 4);\n    }\n\n    guardianlog_name = (char *)p1;\n\n    if (guardianlog_name[0] == '|') {\n        const char *pipe_name = ap_server_root_relative(cmd->pool, guardianlog_name + 1);\n        piped_log *pipe_log;\n\n        pipe_log = ap_open_piped_log(cmd->pool, pipe_name);\n        if (pipe_log == NULL) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: Failed to open the guardian log pipe: %s\",\n                pipe_name);\n        }\n        guardianlog_fd = ap_piped_log_write_fd(pipe_log);\n    }\n    else {\n        const char *file_name = ap_server_root_relative(cmd->pool, guardianlog_name);\n        apr_status_t rc;\n\n        rc = apr_file_open(&guardianlog_fd, file_name,\n            APR_WRITE | APR_APPEND | APR_CREATE | APR_BINARY,\n            CREATEMODE, cmd->pool);\n\n        if (rc != APR_SUCCESS) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: Failed to open the guardian log file: %s\",\n                file_name);\n        }\n    }\n\n    return NULL;\n}\n\n/**\n* \\brief Add SecStreamInBodyInspection configuration option\n*\n* \\param cmd Pointer to configuration data\n* \\param _dcfg Pointer to directory configuration\n* \\param p1 Pointer to configuration option\n*\n* \\retval NULL On failure\n* \\retval apr_psprintf On Success\n*/\nstatic const char *cmd_stream_inbody_inspection(cmd_parms *cmd, void *_dcfg, int flag)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n    dcfg->stream_inbody_inspection = flag;\n    return NULL;\n}\n\n\n/**\n* \\brief Add SecStreamOutBodyInspection configuration option\n*\n* \\param cmd Pointer to configuration data\n* \\param _dcfg Pointer to directory configuration\n* \\param p1 Pointer to configuration option\n*\n* \\retval NULL On failure\n* \\retval apr_psprintf On Success\n*/\nstatic const char *cmd_stream_outbody_inspection(cmd_parms *cmd, void *_dcfg, int flag)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n    dcfg->stream_outbody_inspection = flag;\n    return NULL;\n}\n/**\n* \\brief Add SecRulePerfTime configuration option\n*\n* \\param cmd Pointer to configuration data\n* \\param _dcfg Pointer to directory configuration\n* \\param p1 Pointer to configuration option\n*\n* \\retval NULL On failure\n* \\retval apr_psprintf On Success\n*/\nstatic const char *cmd_rule_perf_time(cmd_parms *cmd, void *_dcfg,\n        const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    long int limit;\n\n    if (dcfg == NULL) return NULL;\n\n    limit = strtol(p1, NULL, 10);\n    if ((limit == LONG_MAX)||(limit == LONG_MIN)||(limit <= 0)) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecRulePerfTime: %s\", p1);\n    }\n\n    dcfg->max_rule_time = limit;\n\n    return NULL;\n}\n\n/**\n* \\brief Add SecReadStateLimit configuration option\n*\n* \\param cmd Pointer to configuration data\n* \\param _dcfg Pointer to directory configuration\n* \\param p1 Pointer to configuration option\n*\n* \\retval NULL On failure\n* \\retval apr_psprintf On Success\n*/\nstatic const char *cmd_conn_read_state_limit(cmd_parms *cmd, void *_dcfg,\n        const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    long int limit;\n\n    if (dcfg == NULL) return NULL;\n\n    limit = strtol(p1, NULL, 10);\n    if ((limit == LONG_MAX)||(limit == LONG_MIN)||(limit <= 0)) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecReadStateLimit: %s\", p1);\n    }\n\n    conn_read_state_limit = limit;\n\n    return NULL;\n}\n\n/**\n* \\brief Add SecWriteStateLimit configuration option\n*\n* \\param cmd Pointer to configuration data\n* \\param _dcfg Pointer to directory configuration\n* \\param p1 Pointer to configuration option\n*\n* \\retval NULL On failure\n* \\retval apr_psprintf On Success\n*/\nstatic const char *cmd_conn_write_state_limit(cmd_parms *cmd, void *_dcfg,\n        const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    long int limit;\n\n    if (dcfg == NULL) return NULL;\n\n    limit = strtol(p1, NULL, 10);\n    if ((limit == LONG_MAX)||(limit == LONG_MIN)||(limit <= 0)) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecWriteStateLimit: %s\", p1);\n    }\n\n    conn_write_state_limit = limit;\n\n    return NULL;\n}\n\n\nstatic const char *cmd_request_body_inmemory_limit(cmd_parms *cmd, void *_dcfg,\n                                                   const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    long int limit;\n\n    if (dcfg == NULL) return NULL;\n\n    limit = strtol(p1, NULL, 10);\n    if ((limit == LONG_MAX)||(limit == LONG_MIN)||(limit <= 0)) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecRequestBodyInMemoryLimit: %s\", p1);\n    }\n\n    dcfg->reqbody_inmemory_limit = limit;\n\n    return NULL;\n}\n\nstatic const char *cmd_request_body_limit(cmd_parms *cmd, void *_dcfg,\n                                          const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    long int limit;\n\n    if (dcfg == NULL) return NULL;\n\n    limit = strtol(p1, NULL, 10);\n    if ((limit == LONG_MAX)||(limit == LONG_MIN)||(limit <= 0)) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecRequestBodyLimit: %s\", p1);\n    }\n\n    dcfg->reqbody_limit = limit;\n\n    return NULL;\n}\n\nstatic const char *cmd_request_body_no_files_limit(cmd_parms *cmd, void *_dcfg,\n                                                   const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    long int limit;\n\n    if (dcfg == NULL) return NULL;\n\n    limit = strtol(p1, NULL, 10);\n    if ((limit == LONG_MAX)||(limit == LONG_MIN)||(limit <= 0)) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecRequestBodyNoFilesLimit: %s\", p1);\n    }\n\n    dcfg->reqbody_no_files_limit = limit;\n\n    return NULL;\n}\n\nstatic const char *cmd_request_body_access(cmd_parms *cmd, void *_dcfg,\n                                           const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n\n    if (strcasecmp(p1, \"on\") == 0) dcfg->reqbody_access = 1;\n    else\n    if (strcasecmp(p1, \"off\") == 0) dcfg->reqbody_access = 0;\n    else\n    return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecRequestBodyAccess: %s\", p1);\n\n    return NULL;\n}\n\n/**\n* \\brief Add SecInterceptOnError configuration option\n*\n* \\param cmd Pointer to configuration data\n* \\param _dcfg Pointer to directory configuration\n* \\param p1 Pointer to configuration option\n*\n* \\retval NULL On failure\n* \\retval apr_psprintf On success\n*/\nstatic const char *cmd_request_intercept_on_error(cmd_parms *cmd, void *_dcfg,\n                                           const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n\n    if (strcasecmp(p1, \"on\") == 0) dcfg->reqintercept_oe = 1;\n    else\n    if (strcasecmp(p1, \"off\") == 0) dcfg->reqintercept_oe = 0;\n    else\n    return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecInterceptOnError: %s\", p1);\n\n    return NULL;\n}\n\n\nstatic const char *cmd_request_encoding(cmd_parms *cmd, void *_dcfg,\n                                        const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n\n    /* ENH Validate encoding */\n\n    dcfg->request_encoding = p1;\n\n    return NULL;\n}\n\nstatic const char *cmd_response_body_access(cmd_parms *cmd, void *_dcfg,\n                                            const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n\n    if (strcasecmp(p1, \"on\") == 0) dcfg->resbody_access = 1;\n    else\n    if (strcasecmp(p1, \"off\") == 0) dcfg->resbody_access = 0;\n    else\n    return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecResponseBodyAccess: %s\", p1);\n\n    return NULL;\n}\n\nstatic const char *cmd_response_body_limit(cmd_parms *cmd, void *_dcfg,\n                                           const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    long int limit;\n\n    limit = strtol(p1, NULL, 10);\n    if ((limit == LONG_MAX)||(limit == LONG_MIN)||(limit <= 0)) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecResponseBodyLimit: %s\", p1);\n    }\n\n    if (limit > RESPONSE_BODY_HARD_LIMIT) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Response size limit can not exceed the hard limit: %li\", RESPONSE_BODY_HARD_LIMIT);\n    }\n\n    dcfg->of_limit = limit;\n\n    return NULL;\n}\n\nstatic const char *cmd_response_body_limit_action(cmd_parms *cmd, void *_dcfg,\n                                                  const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n\n    if (dcfg->is_enabled == MODSEC_DETECTION_ONLY)  {\n        dcfg->of_limit_action = RESPONSE_BODY_LIMIT_ACTION_PARTIAL;\n        return NULL;\n    }\n\n    if (strcasecmp(p1, \"ProcessPartial\") == 0) dcfg->of_limit_action = RESPONSE_BODY_LIMIT_ACTION_PARTIAL;\n    else\n    if (strcasecmp(p1, \"Reject\") == 0) dcfg->of_limit_action = RESPONSE_BODY_LIMIT_ACTION_REJECT;\n    else\n    return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecResponseBodyLimitAction: %s\", p1);\n\n    return NULL;\n}\n\n/**\n* \\brief Add SecRequestBodyLimitAction configuration option\n*\n* \\param cmd Pointer to configuration data\n* \\param _dcfg Pointer to directory configuration\n* \\param p1 Pointer to configuration option\n*\n* \\retval NULL On failure\n* \\retval apr_psprintf On success\n*/\nstatic const char *cmd_resquest_body_limit_action(cmd_parms *cmd, void *_dcfg,\n                                                  const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n\n    if (dcfg->is_enabled == MODSEC_DETECTION_ONLY)  {\n        dcfg->if_limit_action = REQUEST_BODY_LIMIT_ACTION_PARTIAL;\n        return NULL;\n    }\n\n    if (strcasecmp(p1, \"ProcessPartial\") == 0) dcfg->if_limit_action = REQUEST_BODY_LIMIT_ACTION_PARTIAL;\n    else\n    if (strcasecmp(p1, \"Reject\") == 0) dcfg->if_limit_action = REQUEST_BODY_LIMIT_ACTION_REJECT;\n    else\n    return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecRequestBodyLimitAction: %s\", p1);\n\n    return NULL;\n}\n\nstatic const char *cmd_response_body_mime_type(cmd_parms *cmd, void *_dcfg,\n                                               const char *_p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    char *p1 = apr_pstrdup(cmd->pool, _p1);\n\n    /* TODO check whether the parameter is a valid MIME type of \"???\" */\n\n    if ((dcfg->of_mime_types == NULL)||(dcfg->of_mime_types == NOT_SET_P)) {\n        dcfg->of_mime_types = apr_table_make(cmd->pool, 10);\n    }\n\n    strtolower_inplace((unsigned char *)p1);\n    apr_table_setn(dcfg->of_mime_types, p1, \"1\");\n\n    return NULL;\n}\n\nstatic const char *cmd_response_body_mime_types_clear(cmd_parms *cmd,\n                                                      void *_dcfg)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n\n    dcfg->of_mime_types_cleared = 1;\n\n    if ((dcfg->of_mime_types != NULL)&&(dcfg->of_mime_types != NOT_SET_P)) {\n        apr_table_clear(dcfg->of_mime_types);\n    }\n\n    return NULL;\n}\n\n/**\n * \\brief Add SecRuleUpdateTargetById\n *\n * \\param cmd Pointer to configuration data\n * \\param _dcfg Pointer to directory configuration\n * \\param p1 Pointer to configuration option\n * \\param p2 Pointer to configuration option\n * \\param p3 Pointer to configuration option\n *\n * \\retval NULL On failure|Success\n */\nstatic const char *cmd_rule_update_target_by_id(cmd_parms *cmd, void *_dcfg,\n        const char *p1, const char *p2, const char *p3)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    rule_exception *re = apr_pcalloc(cmd->pool, sizeof(rule_exception));\n    if (dcfg == NULL) return NULL;\n\n    if(p1 == NULL)  {\n        return apr_psprintf(cmd->pool, \"Updating target by ID with no ID\");\n    }\n\n    re->type = RULE_EXCEPTION_REMOVE_ID;\n    /* TODO: Validate the range here, while we can still tell the user if it's invalid */\n    re->param = p1;\n\n    return msre_ruleset_rule_update_target_matching_exception(NULL, dcfg->ruleset, re, p2, p3);\n}\n\n/**\n * \\brief Add SecRuleUpdateTargetByTag  configuration option\n *\n * \\param cmd Pointer to configuration data\n * \\param _dcfg Pointer to directory configuration\n * \\param p1 Pointer to configuration option RULETAG\n * \\param p2 Pointer to configuration option TARGET\n * \\param p3 Pointer to configuration option REPLACED_TARGET\n * \\todo Finish documenting\n *\n * \\retval NULL On success\n * \\retval apr_psprintf On failure\n *\n * \\todo Figure out error checking\n */\nstatic const char *cmd_rule_update_target_by_tag(cmd_parms *cmd, void *_dcfg,\n        const char *p1, const char *p2, const char *p3)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    rule_exception *re = apr_pcalloc(cmd->pool, sizeof(rule_exception));\n    if (dcfg == NULL) return NULL;\n\n    if(p1 == NULL)  {\n        return apr_psprintf(cmd->pool, \"Updating target by tag with no tag\");\n    }\n\n    re->type = RULE_EXCEPTION_REMOVE_TAG;\n    re->param = p1;\n    re->param_data = msc_pregcomp(cmd->pool, p1, 0, NULL, NULL);\n    if (re->param_data == NULL) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Invalid regular expression: %s\", p1);\n    }\n\n    return msre_ruleset_rule_update_target_matching_exception(NULL, dcfg->ruleset, re, p2, p3);\n}\n/**\n * \\brief Add SecRuleUpdateTargetByMsg configuration option\n *\n * \\param cmd Pointer to configuration data\n * \\param _dcfg Pointer to directory configuration\n * \\param p1 Pointer to configuration option RULEMSG\n * \\param p2 Pointer to configuration option TARGET\n * \\param p3 Pointer to configuration option REPLACED_TARGET\n * \\todo Finish documenting\n *\n * \\retval NULL On success\n * \\retval apr_psprintf On failure\n *\n * \\todo Figure out error checking\n */\nstatic const char *cmd_rule_update_target_by_msg(cmd_parms *cmd, void *_dcfg,\n        const char *p1, const char *p2, const char *p3)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    rule_exception *re = apr_pcalloc(cmd->pool, sizeof(rule_exception));\n    if (dcfg == NULL) return NULL;\n\n    if(p1 == NULL)  {\n        return apr_psprintf(cmd->pool, \"Updating target by message with no message\");\n    }\n\n    re->type = RULE_EXCEPTION_REMOVE_MSG;\n    re->param = p1;\n    re->param_data = msc_pregcomp(cmd->pool, p1, 0, NULL, NULL);\n    if (re->param_data == NULL) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Invalid regular expression: %s\", p1);\n    }\n\n    return msre_ruleset_rule_update_target_matching_exception(NULL, dcfg->ruleset, re, p2, p3);\n}\n\n\nstatic const char *cmd_rule(cmd_parms *cmd, void *_dcfg,\n        const char *p1, const char *p2, const char *p3)\n{\n    return add_rule(cmd, (directory_config *)_dcfg, RULE_TYPE_NORMAL, p1, p2, p3);\n}\n\nstatic const char *cmd_rule_engine(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n\n    if (strcasecmp(p1, \"on\") == 0) dcfg->is_enabled = MODSEC_ENABLED;\n    else\n    if (strcasecmp(p1, \"off\") == 0) dcfg->is_enabled = MODSEC_DISABLED;\n    else\n    if (strcasecmp(p1, \"detectiononly\") == 0) {\n        dcfg->is_enabled = MODSEC_DETECTION_ONLY;\n        dcfg->of_limit_action = RESPONSE_BODY_LIMIT_ACTION_PARTIAL;\n        dcfg->if_limit_action = REQUEST_BODY_LIMIT_ACTION_PARTIAL;\n    } else\n    return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecRuleEngine: %s\", p1);\n\n    return NULL;\n}\n\nstatic const char *cmd_rule_inheritance(cmd_parms *cmd, void *_dcfg, int flag)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n    dcfg->rule_inheritance = flag;\n    return NULL;\n}\n\nstatic const char *cmd_rule_script(cmd_parms *cmd, void *_dcfg,\n                                   const char *p1, const char *p2)\n{\n    #if defined(WITH_LUA)\n    const char *filename = resolve_relative_path(cmd->pool, cmd->directive->filename, p1);\n    return add_rule(cmd, (directory_config *)_dcfg, RULE_TYPE_LUA, filename, p2, NULL);\n    #else\n    ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, cmd->pool, \"Ignoring SecRuleScript \\\"%s\\\" directive (%s:%d): No Lua scripting support.\", p1, cmd->directive->filename, cmd->directive->line_num);\n    return NULL;\n    #endif\n}\n\nstatic const char *cmd_rule_remove_by_id(cmd_parms *cmd, void *_dcfg,\n                                         const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    rule_exception *re = apr_pcalloc(cmd->pool, sizeof(rule_exception));\n    if (dcfg == NULL) return NULL;\n\n    re->type = RULE_EXCEPTION_REMOVE_ID;\n    re->param = p1;\n    *(rule_exception **)apr_array_push(dcfg->rule_exceptions) = re;\n\n    /* Remove the corresponding rules from the context straight away. */\n    msre_ruleset_rule_remove_with_exception(dcfg->ruleset, re);\n\n    return NULL;\n}\n\n/**\n* \\brief Add SecRuleRemoveByTag  configuration option\n*\n* \\param cmd Pointer to configuration data\n* \\param _dcfg Pointer to directory configuration\n* \\param p1 Pointer to configuration option\n*\n* \\retval NULL On failure\n* \\retval apr_psprintf On success\n*/\nstatic const char *cmd_rule_remove_by_tag(cmd_parms *cmd, void *_dcfg,\n                                          const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    rule_exception *re = apr_pcalloc(cmd->pool, sizeof(rule_exception));\n    if (dcfg == NULL) return NULL;\n\n    re->type = RULE_EXCEPTION_REMOVE_TAG;\n    re->param = p1;\n    re->param_data = msc_pregcomp(cmd->pool, p1, 0, NULL, NULL);\n    if (re->param_data == NULL) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Invalid regular expression: %s\", p1);\n    }\n    *(rule_exception **)apr_array_push(dcfg->rule_exceptions) = re;\n\n    /* Remove the corresponding rules from the context straight away. */\n    msre_ruleset_rule_remove_with_exception(dcfg->ruleset, re);\n\n    #ifdef DEBUG_CONF\n    ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, cmd->pool, \"Added exception %pp (%d %s) to dcfg %pp.\", re, re->type, re->param, dcfg);\n    #endif\n\n    return NULL;\n}\n\nstatic const char *cmd_rule_remove_by_msg(cmd_parms *cmd, void *_dcfg,\n                                          const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    rule_exception *re = apr_pcalloc(cmd->pool, sizeof(rule_exception));\n    if (dcfg == NULL) return NULL;\n\n    re->type = RULE_EXCEPTION_REMOVE_MSG;\n    re->param = p1;\n    re->param_data = msc_pregcomp(cmd->pool, p1, 0, NULL, NULL);\n    if (re->param_data == NULL) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Invalid regular expression: %s\", p1);\n    }\n    *(rule_exception **)apr_array_push(dcfg->rule_exceptions) = re;\n\n    /* Remove the corresponding rules from the context straight away. */\n    msre_ruleset_rule_remove_with_exception(dcfg->ruleset, re);\n\n    #ifdef DEBUG_CONF\n    ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, cmd->pool, \"Added exception %pp (%d %s) to dcfg %pp.\", re, re->type, re->param, dcfg);\n    #endif\n\n    return NULL;\n}\n\nstatic const char *cmd_rule_update_action_by_id(cmd_parms *cmd, void *_dcfg,\n        const char *p1, const char *p2)\n{\n    int offset = 0, rule_id = atoi(p1);\n    char *opt = strchr(p1,':');\n    char *savedptr = NULL;\n    char *param = apr_pstrdup(cmd->pool, p1);\n\n    if ((rule_id == LONG_MAX)||(rule_id == LONG_MIN)||(rule_id <= 0)) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for ID for update action: %s\", p1);\n    }\n\n    if(opt != NULL) {\n        opt++;\n        offset = atoi(opt);\n        opt = apr_strtok(param,\":\", &savedptr);\n        return update_rule_action(cmd, (directory_config *)_dcfg, (const char *)opt, p2, offset);\n    }\n\n    return update_rule_action(cmd, (directory_config *)_dcfg, p1, p2, offset);\n}\n\nstatic const char *cmd_server_signature(cmd_parms *cmd, void *_dcfg,\n                                        const char *p1)\n{\n    if (cmd->server->is_virtual) {\n        return \"ModSecurity: SecServerSignature not allowed in VirtualHost\";\n    }\n    new_server_signature = (char *)p1;\n    return NULL;\n}\n\nstatic const char *cmd_tmp_dir(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n\n    if (dcfg == NULL) return NULL;\n\n    if (strcasecmp(p1, \"none\") == 0) dcfg->tmp_dir = NULL;\n    else dcfg->tmp_dir = ap_server_root_relative(cmd->pool, p1);\n\n    return NULL;\n}\n\nstatic const char *cmd_upload_dir(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n\n    if (dcfg == NULL) return NULL;\n\n    if (strcasecmp(p1, \"none\") == 0) dcfg->upload_dir = NULL;\n    else dcfg->upload_dir = ap_server_root_relative(cmd->pool, p1);\n\n    return NULL;\n}\n\nstatic const char *cmd_upload_file_limit(cmd_parms *cmd, void *_dcfg,\n                                         const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n\n    if (dcfg == NULL) return NULL;\n\n    if (strcasecmp(p1, \"default\") == 0) {\n        dcfg->upload_file_limit = NOT_SET;\n    }\n    else {\n        dcfg->upload_file_limit = atoi(p1);\n    }\n\n    return NULL;\n}\n\nstatic const char *cmd_upload_filemode(cmd_parms *cmd, void *_dcfg,\n                                       const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n\n    if (dcfg == NULL) return NULL;\n\n    if (strcasecmp(p1, \"default\") == 0) {\n        dcfg->upload_filemode = NOT_SET;\n    }\n    else {\n        long int mode = strtol(p1, NULL, 8); /* expects octal mode */\n        if ((mode == LONG_MAX)||(mode == LONG_MIN)||(mode <= 0)||(mode > 07777)) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecUploadFileMode: %s\", p1);\n        }\n\n        dcfg->upload_filemode = (int)mode;\n    }\n\n    return NULL;\n}\n\nstatic const char *cmd_upload_keep_files(cmd_parms *cmd, void *_dcfg,\n                                         const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n\n    if (dcfg == NULL) return NULL;\n\n    if (strcasecmp(p1, \"on\") == 0) {\n        dcfg->upload_keep_files = KEEP_FILES_ON;\n    } else\n    if (strcasecmp(p1, \"off\") == 0) {\n        dcfg->upload_keep_files = KEEP_FILES_OFF;\n    } else\n    if (strcasecmp(p1, \"relevantonly\") == 0) {\n        dcfg->upload_keep_files = KEEP_FILES_RELEVANT_ONLY;\n    } else {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Invalid setting for SecUploadKeepFiles: %s\",\n            p1);\n    }\n    return NULL;\n}\n\nstatic const char *cmd_web_app_id(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n\n    /* ENH enforce format (letters, digits, ., _, -) */\n    dcfg->webappid = p1;\n\n    return NULL;\n}\n\nstatic const char *cmd_sensor_id(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n\n    /* ENH enforce format (letters, digits, ., _, -) */\n    dcfg->sensor_id = p1;\n\n    return NULL;\n}\n\n\n/**\n* \\brief Add SecHash configuration option\n*\n* \\param cmd Pointer to configuration data\n* \\param _dcfg Pointer to directory configuration\n* \\param p1 Pointer to configuration option\n*\n* \\retval NULL On failure\n* \\retval apr_psprintf On Success\n*/\nstatic const char *cmd_hash_engine(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n\n    if (strcasecmp(p1, \"on\") == 0)  {\n        dcfg->hash_is_enabled = HASH_ENABLED;\n        dcfg->hash_enforcement = HASH_ENABLED;\n    }\n    else if (strcasecmp(p1, \"off\") == 0)    {\n        dcfg->hash_is_enabled = HASH_DISABLED;\n        dcfg->hash_enforcement = HASH_DISABLED;\n    }\n    else return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecRuleEngine: %s\", p1);\n\n    return NULL;\n}\n\n/**\n* \\brief Add SecHashPram configuration option\n*\n* \\param cmd Pointer to configuration data\n* \\param _dcfg Pointer to directory configuration\n* \\param p1 Pointer to configuration option\n*\n* \\retval NULL On success\n*/\nstatic const char *cmd_hash_param(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n\n    if (dcfg == NULL) return NULL;\n\n    if (p1 == NULL) return NULL;\n    dcfg->crypto_param_name = p1;\n\n    return NULL;\n}\n\n/**\n* \\brief Add SecHashKey configuration option\n*\n* \\param cmd Pointer to configuration data\n* \\param _dcfg Pointer to directory configuration\n* \\param _p1 Pointer to configuration option\n* \\param _p2 Pointer to configuration option\n*\n* \\retval NULL On success\n*/\nstatic const char *cmd_hash_key(cmd_parms *cmd, void *_dcfg, const char *_p1, const char *_p2)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    char *p1 = NULL;\n\n    if (dcfg == NULL) return NULL;\n    if (_p1 == NULL) return NULL;\n\n    if (strcasecmp(_p1, \"Rand\") == 0)    {\n        p1 = apr_pstrdup(cmd->pool, getkey(cmd->pool));\n        dcfg->crypto_key = p1;\n        dcfg->crypto_key_len = strlen(dcfg->crypto_key);\n    } else    {\n        p1 = apr_pstrdup(cmd->pool, _p1);\n        dcfg->crypto_key = p1;\n        dcfg->crypto_key_len = strlen(p1);\n    }\n\n    if(_p2 == NULL)  {\n        return NULL;\n    } else    {\n        if (strcasecmp(_p2, \"KeyOnly\") == 0)\n            dcfg->crypto_key_add = HASH_KEYONLY;\n        else if (strcasecmp(_p2, \"SessionID\") == 0)\n            dcfg->crypto_key_add = HASH_SESSIONID;\n        else if (strcasecmp(_p2, \"RemoteIP\") == 0)\n            dcfg->crypto_key_add = HASH_REMOTEIP;\n    }\n    return NULL;\n}\n\n/**\n* \\brief Add SecHashMethodPm configuration option\n*\n* \\param cmd Pointer to configuration data\n* \\param _dcfg Pointer to directory configuration\n* \\param p1 Pointer to configuration option\n* \\param p2 Pointer to configuration option\n*\n* \\retval NULL On failure\n* \\retval apr_psprintf On Success\n*/\nstatic const char *cmd_hash_method_pm(cmd_parms *cmd, void *_dcfg,\n        const char *p1, const char *p2)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    rule_exception *re = apr_pcalloc(cmd->pool, sizeof(hash_method));\n    const char *_p2 = apr_pstrdup(cmd->pool, p2);\n    ACMP *p = NULL;\n    const char *phrase = NULL;\n    const char *next = NULL;\n\n    if (dcfg == NULL) return NULL;\n\n    p = acmp_create(0, cmd->pool);\n    if (p == NULL) return NULL;\n\n    if(phrase == NULL)\n        phrase = apr_pstrdup(cmd->pool, _p2);\n\n    for (;;) {\n        while((apr_isspace(*phrase) != 0) && (*phrase != '\\0')) phrase++;\n        if (*phrase == '\\0') break;\n        next = phrase;\n        while((apr_isspace(*next) == 0) && (*next != 0)) next++;\n        acmp_add_pattern(p, phrase, NULL, NULL, next - phrase);\n        phrase = next;\n    }\n\n    acmp_prepare(p);\n\n    if (strcasecmp(p1, \"HashHref\") == 0) {\n        re->type = HASH_URL_HREF_HASH_PM;\n        re->param = _p2;\n        re->param_data = (void *)p;\n        if (re->param_data == NULL) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: Invalid pattern: %s\", p2);\n        }\n        dcfg->crypto_hash_href_pm = 1;\n    }\n    else if (strcasecmp(p1, \"HashFormAction\") == 0) {\n        re->type = HASH_URL_FACTION_HASH_PM;\n        re->param = _p2;\n        re->param_data = (void *)p;\n        if (re->param_data == NULL) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: Invalid pattern: %s\", p2);\n        }\n        dcfg->crypto_hash_faction_pm = 1;\n    }\n    else if (strcasecmp(p1, \"HashLocation\") == 0) {\n        re->type = HASH_URL_LOCATION_HASH_PM;\n        re->param = _p2;\n        re->param_data = (void *)p;\n        if (re->param_data == NULL) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: Invalid pattern: %s\", p2);\n        }\n        dcfg->crypto_hash_location_pm = 1;\n    }\n    else if (strcasecmp(p1, \"HashIframeSrc\") == 0) {\n        re->type = HASH_URL_IFRAMESRC_HASH_PM;\n        re->param = _p2;\n        re->param_data = (void *)p;\n        if (re->param_data == NULL) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: Invalid pattern: %s\", p2);\n        }\n        dcfg->crypto_hash_iframesrc_pm = 1;\n    }\n    else if (strcasecmp(p1, \"HashFrameSrc\") == 0) {\n        re->type = HASH_URL_FRAMESRC_HASH_PM;\n        re->param = _p2;\n        re->param_data = (void *)p;\n        if (re->param_data == NULL) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: Invalid pattern: %s\", p2);\n        }\n        dcfg->crypto_hash_framesrc_pm = 1;\n    }\n\n    *(hash_method **)apr_array_push(dcfg->hash_method) = re;\n\n    return NULL;\n}\n\n/**\n * \\brief Add SecHashMethodRx configuration option\n *\n * \\param cmd Pointer to configuration data\n * \\param _dcfg Pointer to directory configuration\n * \\param p1 Pointer to configuration option\n * \\param p2 Pointer to configuration option\n *\n * \\retval NULL On failure\n * \\retval apr_psprintf On Success\n */\nstatic const char *cmd_hash_method_rx(cmd_parms *cmd, void *_dcfg,\n        const char *p1, const char *p2)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    rule_exception *re = apr_pcalloc(cmd->pool, sizeof(hash_method));\n    const char *_p2 = apr_pstrdup(cmd->pool, p2);\n    if (dcfg == NULL) return NULL;\n\n    if (strcasecmp(p1, \"HashHref\") == 0) {\n        re->type = HASH_URL_HREF_HASH_RX;\n        re->param = _p2;\n        re->param_data = msc_pregcomp(cmd->pool, p2, 0, NULL, NULL);\n        if (re->param_data == NULL) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: Invalid regular expression: %s\", p2);\n        }\n        dcfg->crypto_hash_href_rx = 1;\n    }\n    else if (strcasecmp(p1, \"HashFormAction\") == 0) {\n        re->type = HASH_URL_FACTION_HASH_RX;\n        re->param = _p2;\n        re->param_data = msc_pregcomp(cmd->pool, p2, 0, NULL, NULL);\n        if (re->param_data == NULL) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: Invalid regular expression: %s\", p2);\n        }\n        dcfg->crypto_hash_faction_rx = 1;\n    }\n    else if (strcasecmp(p1, \"HashLocation\") == 0) {\n        re->type = HASH_URL_LOCATION_HASH_RX;\n        re->param = _p2;\n        re->param_data = msc_pregcomp(cmd->pool, p2, 0, NULL, NULL);\n        if (re->param_data == NULL) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: Invalid regular expression: %s\", p2);\n        }\n        dcfg->crypto_hash_location_rx = 1;\n    }\n    else if (strcasecmp(p1, \"HashIframeSrc\") == 0) {\n        re->type = HASH_URL_IFRAMESRC_HASH_RX;\n        re->param = _p2;\n        re->param_data = msc_pregcomp(cmd->pool, p2, 0, NULL, NULL);\n        if (re->param_data == NULL) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: Invalid regular expression: %s\", p2);\n        }\n        dcfg->crypto_hash_iframesrc_rx = 1;\n    }\n    else if (strcasecmp(p1, \"HashFrameSrc\") == 0) {\n        re->type = HASH_URL_FRAMESRC_HASH_RX;\n        re->param = _p2;\n        re->param_data = msc_pregcomp(cmd->pool, p2, 0, NULL, NULL);\n        if (re->param_data == NULL) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: Invalid regular expression: %s\", p2);\n        }\n        dcfg->crypto_hash_framesrc_rx = 1;\n    }\n\n    *(hash_method **)apr_array_push(dcfg->hash_method) = re;\n\n    return NULL;\n}\n\n/**\n* \\brief Add SecHttpBlKey configuration option\n*\n* \\param cmd Pointer to configuration data\n* \\param _dcfg Pointer to directory configuration\n* \\param p1 Pointer to configuration option\n*\n* \\retval NULL On success\n*/\nstatic const char *cmd_httpBl_key(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n\n    if (dcfg == NULL) return NULL;\n\n    if (p1 == NULL) return NULL;\n    dcfg->httpBlkey = p1;\n\n    return NULL;\n}\n\n/* PCRE Limits */\n\nstatic const char *cmd_pcre_match_limit(cmd_parms *cmd,\n        void *_dcfg, const char *p1)\n{\n    long val;\n\n    if (cmd->server->is_virtual) {\n        return \"ModSecurity: SecPcreMatchLimit not allowed in VirtualHost\";\n    }\n\n    val = atol(p1);\n    if (val <= 0) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Invalid setting for \"\n                \"SecPcreMatchLimit: %s\", p1);\n    }\n    msc_pcre_match_limit = (unsigned long int)val;\n\n    return NULL;\n}\n\nstatic const char *cmd_pcre_match_limit_recursion(cmd_parms *cmd,\n        void *_dcfg, const char *p1)\n{\n    long val;\n\n    if (cmd->server->is_virtual) {\n        return \"ModSecurity: SecPcreMatchLimitRecursion not allowed in VirtualHost\";\n    }\n\n    val = atol(p1);\n    if (val <= 0) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Invalid setting for \"\n                \"SecPcreMatchLimitRecursion: %s\", p1);\n    }\n    msc_pcre_match_limit_recursion = (unsigned long int)val;\n\n    return NULL;\n}\n\n\n/* -- Geo Lookup configuration -- */\n\nstatic const char *cmd_geo_lookup_db(cmd_parms *cmd, void *_dcfg,\n        const char *p1)\n{\n    const char *filename = resolve_relative_path(cmd->pool, cmd->directive->filename, p1);\n    char *error_msg;\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n\n    if (geo_init(dcfg, filename, &error_msg) <= 0) {\n        return error_msg;\n    }\n\n    return NULL;\n}\n\n/**\n* \\brief Add SecUnicodeCodePage configuration option\n*\n* \\param cmd Pointer to configuration data\n* \\param _dcfg Pointer to directory configuration\n* \\param p1 Pointer to configuration option\n*\n* \\retval NULL On success\n*/\nstatic const char *cmd_unicode_codepage(cmd_parms *cmd,\n                                        void *_dcfg, const char *p1)\n{\n    long val;\n\n    val = atol(p1);\n    if (val <= 0) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Invalid setting for \"\n                                       \"SecUnicodeCodePage: %s\", p1);\n    }\n\n    unicode_codepage = (unsigned long int)val;\n\n    return NULL;\n}\n\n/**\n* \\brief Add SecUnicodeMapFile configuration option\n*\n* \\param cmd Pointer to configuration data\n* \\param _dcfg Pointer to directory configuration\n* \\param p1 Pointer to configuration option\n*\n* \\retval NULL On success\n*/\nstatic const char *cmd_unicode_map(cmd_parms *cmd, void *_dcfg,\n                                     const char *p1)\n{\n    const char *filename = resolve_relative_path(cmd->pool, cmd->directive->filename, p1);\n    char *error_msg;\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n\n    if (unicode_map_init(dcfg, filename, &error_msg) <= 0) {\n        return error_msg;\n    }\n\n    return NULL;\n}\n\n/**\n* \\brief Add SecGsbLookupDb configuration option\n*\n* \\param cmd Pointer to configuration data\n* \\param _dcfg Pointer to directory configuration\n* \\param p1 Pointer to configuration option\n*\n* \\retval NULL On success\n*/\nstatic const char *cmd_gsb_lookup_db(cmd_parms *cmd, void *_dcfg,\n                                     const char *p1)\n{\n    const char *filename = resolve_relative_path(cmd->pool, cmd->directive->filename, p1);\n    char *error_msg;\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n\n    if (gsb_db_init(dcfg, filename, &error_msg) <= 0) {\n        return error_msg;\n    }\n\n    return NULL;\n}\n\n/* -- Cache -- */\n\nstatic const char *cmd_cache_transformations(cmd_parms *cmd, void *_dcfg,\n                                             const char *p1, const char *p2)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n\n    if (dcfg == NULL) return NULL;\n\n    if (strcasecmp(p1, \"on\") == 0)\n        dcfg->cache_trans = MODSEC_CACHE_ENABLED;\n    else if (strcasecmp(p1, \"off\") == 0)\n        dcfg->cache_trans = MODSEC_CACHE_DISABLED;\n    else\n        return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecCacheTransformations: %s\", p1);\n\n    /* Process options */\n    if (p2 != NULL) {\n        apr_table_t *vartable = apr_table_make(cmd->pool, 4);\n        apr_status_t rc;\n        char *error_msg = NULL;\n        const char *charval = NULL;\n        apr_int64_t intval = 0;\n\n        if (vartable == NULL) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: Unable to process options for SecCacheTransformations\");\n        }\n        rc = msre_parse_generic(cmd->pool, p2, vartable, &error_msg);\n        if (rc < 0) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: Unable to parse options for SecCacheTransformations: %s\", error_msg);\n        }\n\n        /* incremental */\n        charval = apr_table_get(vartable, \"incremental\");\n        if (charval != NULL) {\n            if (strcasecmp(charval, \"on\") == 0)\n                dcfg->cache_trans_incremental = 1;\n            else if (strcasecmp(charval, \"off\") == 0)\n                dcfg->cache_trans_incremental = 0;\n            else\n                return apr_psprintf(cmd->pool, \"ModSecurity: SecCacheTransformations invalid incremental value: %s\", charval);\n        }\n\n        /* minlen */\n        charval = apr_table_get(vartable, \"minlen\");\n        if (charval != NULL) {\n            intval = apr_atoi64(charval);\n            if (errno == ERANGE) {\n                return apr_psprintf(cmd->pool, \"ModSecurity: SecCacheTransformations minlen out of range: %s\", charval);\n            }\n            if (intval < 0) {\n                return apr_psprintf(cmd->pool, \"ModSecurity: SecCacheTransformations minlen must be positive: %s\", charval);\n            }\n\n            /* The NOT_SET indicator is -1, a signed long, and therfore\n             * we cannot be >= the unsigned value of NOT_SET.\n             */\n            if ((unsigned long)intval >= (unsigned long)NOT_SET) {\n                return apr_psprintf(cmd->pool, \"ModSecurity: SecCacheTransformations minlen must be less than: %lu\", (unsigned long)NOT_SET);\n            }\n            dcfg->cache_trans_min = (apr_size_t)intval;\n        }\n\n        /* maxlen */\n        charval = apr_table_get(vartable, \"maxlen\");\n        if (charval != NULL) {\n            intval = apr_atoi64(charval);\n            if (errno == ERANGE) {\n                return apr_psprintf(cmd->pool, \"ModSecurity: SecCacheTransformations maxlen out of range: %s\", charval);\n            }\n            if (intval < 0) {\n                return apr_psprintf(cmd->pool, \"ModSecurity: SecCacheTransformations maxlen must be positive: %s\", charval);\n            }\n\n            /* The NOT_SET indicator is -1, a signed long, and therfore\n             * we cannot be >= the unsigned value of NOT_SET.\n             */\n            if ((unsigned long)intval >= (unsigned long)NOT_SET) {\n                return apr_psprintf(cmd->pool, \"ModSecurity: SecCacheTransformations maxlen must be less than: %lu\", (unsigned long)NOT_SET);\n            }\n            if ((intval != 0) && ((apr_size_t)intval < dcfg->cache_trans_min)) {\n                return apr_psprintf(cmd->pool, \"ModSecurity: SecCacheTransformations maxlen must not be less than minlen: %lu < %\" APR_SIZE_T_FMT, (unsigned long)intval, dcfg->cache_trans_min);\n            }\n            dcfg->cache_trans_max = (apr_size_t)intval;\n\n        }\n\n        /* maxitems */\n        charval = apr_table_get(vartable, \"maxitems\");\n        if (charval != NULL) {\n            intval = apr_atoi64(charval);\n            if (errno == ERANGE) {\n                return apr_psprintf(cmd->pool, \"ModSecurity: SecCacheTransformations maxitems out of range: %s\", charval);\n            }\n            if (intval < 0) {\n                return apr_psprintf(cmd->pool, \"ModSecurity: SecCacheTransformations maxitems must be positive: %s\", charval);\n            }\n            dcfg->cache_trans_maxitems = (apr_size_t)intval;\n        }\n    }\n\n    return NULL;\n}\n\n\n/* -- Configuration directives definitions -- */\n\n#define CMD_SCOPE_MAIN  (RSRC_CONF)\n#define CMD_SCOPE_ANY   (RSRC_CONF | ACCESS_CONF)\n\n#if defined(HTACCESS_CONFIG)\n#define CMD_SCOPE_HTACCESS  (OR_OPTIONS)\n#endif\n\nconst command_rec module_directives[] = {\n\n#ifdef HTACCESS_CONFIG\n    AP_INIT_TAKE1 (\n        \"SecAction\",\n        cmd_action,\n        NULL,\n        CMD_SCOPE_HTACCESS,\n        \"an action list\"\n    ),\n#else\n    AP_INIT_TAKE1 (\n        \"SecAction\",\n        cmd_action,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"an action list\"\n    ),\n#endif\n\n    AP_INIT_TAKE1 (\n        \"SecArgumentSeparator\",\n        cmd_argument_separator,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"character that will be used as separator when parsing application/x-www-form-urlencoded content.\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecCookiev0Separator\",\n        cmd_cookiev0_separator,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"character that will be used as separator when parsing cookie v0 content.\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecAuditEngine\",\n        cmd_audit_engine,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"On, Off or RelevantOnly to determine the level of audit logging\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecAuditLog\",\n        cmd_audit_log,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"filename of the primary audit log file\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecAuditLog2\",\n        cmd_audit_log2,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"filename of the secondary audit log file\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecAuditLogParts\",\n        cmd_audit_log_parts,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"list of audit log parts that go into the log.\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecAuditLogRelevantStatus\",\n        cmd_audit_log_relevant_status,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"regular expression that will be used to determine if the response status is relevant for audit logging\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecAuditLogType\",\n        cmd_audit_log_type,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"whether to use the old audit log format (Serial) or new (Concurrent)\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecAuditLogStorageDir\",\n        cmd_audit_log_storage_dir,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"path to the audit log storage area; absolute, or relative to the root of the server\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecAuditLogDirMode\",\n        cmd_audit_log_dirmode,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"octal permissions mode for concurrent audit log directories\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecAuditLogFileMode\",\n        cmd_audit_log_filemode,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"octal permissions mode for concurrent audit log files\"\n    ),\n\n    AP_INIT_TAKE12 (\n        \"SecCacheTransformations\",\n        cmd_cache_transformations,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"whether or not to cache transformations. Defaults to true.\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecChrootDir\",\n        cmd_chroot_dir,\n        NULL,\n        CMD_SCOPE_MAIN,\n        \"path of the directory to which server will be chrooted\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecComponentSignature\",\n        cmd_component_signature,\n        NULL,\n        CMD_SCOPE_MAIN,\n        \"component signature to add to ModSecurity signature.\"\n    ),\n\n    AP_INIT_FLAG (\n        \"SecContentInjection\",\n        cmd_content_injection,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"On or Off\"\n    ),\n\n    AP_INIT_FLAG (\n        \"SecStreamOutBodyInspection\",\n        cmd_stream_outbody_inspection,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"On or Off\"\n    ),\n\n    AP_INIT_FLAG (\n        \"SecStreamInBodyInspection\",\n        cmd_stream_inbody_inspection,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"On or Off\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecCookieFormat\",\n        cmd_cookie_format,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"version of the Cookie specification to use for parsing. Possible values are 0 and 1.\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecDataDir\",\n        cmd_data_dir,\n        NULL,\n        CMD_SCOPE_MAIN,\n        \"path to the persistent data storage area\" // TODO\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecDebugLog\",\n        cmd_debug_log,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"path to the debug log file\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecDebugLogLevel\",\n        cmd_debug_log_level,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"debug log level, which controls the verbosity of logging.\"\n        \" Use values from 0 (no logging) to 9 (a *lot* of logging).\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecCollectionTimeout\",\n        cmd_collection_timeout,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"set default collections timeout. default it 3600\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecDefaultAction\",\n        cmd_default_action,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"default action list\"\n    ),\n\n    AP_INIT_FLAG (\n        \"SecDisableBackendCompression\",\n        cmd_disable_backend_compression,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"When set to On, removes the compression headers from the backend requests.\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecGsbLookupDB\",\n        cmd_gsb_lookup_db,\n        NULL,\n        RSRC_CONF,\n        \"database google safe browsing\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecUnicodeCodePage\",\n        cmd_unicode_codepage,\n        NULL,\n        CMD_SCOPE_MAIN,\n        \"Unicode CodePage\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecUnicodeMapFile\",\n        cmd_unicode_map,\n        NULL,\n        CMD_SCOPE_MAIN,\n        \"Unicode Map file\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecGeoLookupDB\",\n        cmd_geo_lookup_db,\n        NULL,\n        RSRC_CONF,\n        \"database for geographical lookups module.\"\n    ),\n\n    AP_INIT_TAKE12 (\n        \"SecGuardianLog\",\n        cmd_guardian_log,\n        NULL,\n        CMD_SCOPE_MAIN,\n        \"The filename of the filter debugging log file\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecMarker\",\n        cmd_marker,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"marker for a skipAfter target\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecPcreMatchLimit\",\n        cmd_pcre_match_limit,\n        NULL,\n        CMD_SCOPE_MAIN,\n        \"PCRE match limit\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecPcreMatchLimitRecursion\",\n        cmd_pcre_match_limit_recursion,\n        NULL,\n        CMD_SCOPE_MAIN,\n        \"PCRE match limit recursion\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecRequestBodyAccess\",\n        cmd_request_body_access,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"On or Off\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecInterceptOnError\",\n        cmd_request_intercept_on_error,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"On or Off\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecRulePerfTime\",\n        cmd_rule_perf_time,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"Threshold to log slow rules in usecs.\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecReadStateLimit\",\n        cmd_conn_read_state_limit,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"maximum number of threads in READ_BUSY state per ip address\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecWriteStateLimit\",\n        cmd_conn_write_state_limit,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"maximum number of threads in WRITE_BUSY state per ip address\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecRequestBodyInMemoryLimit\",\n        cmd_request_body_inmemory_limit,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"maximum request body size that will be placed in memory (except for POST urlencoded requests).\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecRequestBodyLimit\",\n        cmd_request_body_limit,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"maximum request body size ModSecurity will accept.\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecRequestBodyNoFilesLimit\",\n        cmd_request_body_no_files_limit,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"maximum request body size ModSecurity will accept, but excluding the size of uploaded files.\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecRequestEncoding\",\n        cmd_request_encoding,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"character encoding used in request.\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecResponseBodyAccess\",\n        cmd_response_body_access,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"On or Off\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecResponseBodyLimit\",\n        cmd_response_body_limit,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"byte limit for response body\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecResponseBodyLimitAction\",\n        cmd_response_body_limit_action,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"what happens when the response body limit is reached\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecRequestBodyLimitAction\",\n        cmd_resquest_body_limit_action,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"what happens when the request body limit is reached\"\n    ),\n\n    AP_INIT_ITERATE (\n        \"SecResponseBodyMimeType\",\n        cmd_response_body_mime_type,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"adds given MIME types to the list of types that will be buffered on output\"\n    ),\n\n    AP_INIT_NO_ARGS (\n        \"SecResponseBodyMimeTypesClear\",\n        cmd_response_body_mime_types_clear,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"clears the list of MIME types that will be buffered on output\"\n    ),\n\n#ifdef HTACCESS_CONFIG\n    AP_INIT_TAKE23 (\n        \"SecRule\",\n        cmd_rule,\n        NULL,\n        CMD_SCOPE_HTACCESS,\n        \"rule target, operator and optional action list\"\n    ),\n#else\n    AP_INIT_TAKE23 (\n        \"SecRule\",\n        cmd_rule,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"rule target, operator and optional action list\"\n    ),\n#endif\n\n    AP_INIT_TAKE1 (\n        \"SecRuleEngine\",\n        cmd_rule_engine,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"On or Off\"\n    ),\n\n    AP_INIT_FLAG (\n        \"SecRuleInheritance\",\n        cmd_rule_inheritance,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"On or Off\"\n    ),\n\n    AP_INIT_TAKE12 (\n        \"SecRuleScript\",\n        cmd_rule_script,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"rule script and optional actionlist\"\n    ),\n\n#ifdef HTACCESS_CONFIG\n    AP_INIT_ITERATE (\n        \"SecRuleRemoveById\",\n        cmd_rule_remove_by_id,\n        NULL,\n        CMD_SCOPE_HTACCESS,\n        \"rule ID for removal\"\n    ),\n\n    AP_INIT_ITERATE (\n        \"SecRuleRemoveByTag\",\n        cmd_rule_remove_by_tag,\n        NULL,\n        CMD_SCOPE_HTACCESS,\n        \"rule tag for removal\"\n    ),\n\n    AP_INIT_ITERATE (\n        \"SecRuleRemoveByMsg\",\n        cmd_rule_remove_by_msg,\n        NULL,\n        CMD_SCOPE_HTACCESS,\n        \"rule message for removal\"\n    ),\n#else\n    AP_INIT_ITERATE (\n        \"SecRuleRemoveById\",\n        cmd_rule_remove_by_id,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"rule ID for removal\"\n    ),\n\n    AP_INIT_ITERATE (\n        \"SecRuleRemoveByTag\",\n        cmd_rule_remove_by_tag,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"rule tag for removal\"\n    ),\n\n    AP_INIT_ITERATE (\n        \"SecRuleRemoveByMsg\",\n        cmd_rule_remove_by_msg,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"rule message for removal\"\n    ),\n#endif\n\n    AP_INIT_TAKE2 (\n        \"SecHashMethodPm\",\n        cmd_hash_method_pm,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"Hash method and pattern\"\n    ),\n\n    AP_INIT_TAKE2 (\n        \"SecHashMethodRx\",\n        cmd_hash_method_rx,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"Hash method and regex\"\n    ),\n\n#ifdef HTACCESS_CONFIG\n    AP_INIT_TAKE2 (\n        \"SecRuleUpdateActionById\",\n        cmd_rule_update_action_by_id,\n        NULL,\n        CMD_SCOPE_HTACCESS,\n        \"updated action list\"\n    ),\n\n    AP_INIT_TAKE23 (\n        \"SecRuleUpdateTargetById\",\n        cmd_rule_update_target_by_id,\n        NULL,\n        CMD_SCOPE_HTACCESS,\n        \"updated target list\"\n    ),\n\n    AP_INIT_TAKE23 (\n        \"SecRuleUpdateTargetByTag\",\n        cmd_rule_update_target_by_tag,\n        NULL,\n        CMD_SCOPE_HTACCESS,\n        \"rule tag pattern and updated target list\"\n    ),\n\n    AP_INIT_TAKE23 (\n        \"SecRuleUpdateTargetByMsg\",\n        cmd_rule_update_target_by_msg,\n        NULL,\n        CMD_SCOPE_HTACCESS,\n        \"rule message pattern and updated target list\"\n    ),\n#else\n    AP_INIT_TAKE2 (\n        \"SecRuleUpdateActionById\",\n        cmd_rule_update_action_by_id,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"updated action list\"\n    ),\n\n    AP_INIT_TAKE23 (\n        \"SecRuleUpdateTargetById\",\n        cmd_rule_update_target_by_id,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"updated target list\"\n    ),\n\n    AP_INIT_TAKE23 (\n        \"SecRuleUpdateTargetByTag\",\n        cmd_rule_update_target_by_tag,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"rule tag pattern and updated target list\"\n    ),\n\n    AP_INIT_TAKE23 (\n        \"SecRuleUpdateTargetByMsg\",\n        cmd_rule_update_target_by_msg,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"rule message pattern and updated target list\"\n    ),\n#endif\n\n    AP_INIT_TAKE1 (\n        \"SecServerSignature\",\n        cmd_server_signature,\n        NULL,\n        CMD_SCOPE_MAIN,\n        \"the new signature of the server\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecTmpDir\",\n        cmd_tmp_dir,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"path to the temporary storage area\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecUploadDir\",\n        cmd_upload_dir,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"path to the file upload area\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecUploadFileLimit\",\n        cmd_upload_file_limit,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"limit the number of uploaded files processed\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecUploadFileMode\",\n        cmd_upload_filemode,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"octal permissions mode for uploaded files\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecUploadKeepFiles\",\n        cmd_upload_keep_files,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"On or Off\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecWebAppId\",\n        cmd_web_app_id,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"id\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecSensorId\",\n        cmd_sensor_id,\n        NULL,\n        CMD_SCOPE_MAIN,\n        \"sensor id\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecHttpBlKey\",\n        cmd_httpBl_key,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"httpBl access key\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecHashEngine\",\n        cmd_hash_engine,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"On or Off\"\n    ),\n\n    AP_INIT_TAKE2 (\n        \"SecHashKey\",\n        cmd_hash_key,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"Set Hash key\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecHashParam\",\n        cmd_hash_param,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"Set Hash parameter\"\n    ),\n\n    { NULL }\n};\n", "/*\n* ModSecurity for Apache 2.x, http://www.modsecurity.org/\n* Copyright (c) 2004-2011 Trustwave Holdings, Inc. (http://www.trustwave.com/)\n*\n* You may not use this file except in compliance with\n* the License. \u00a0You may obtain a copy of the License at\n*\n* \u00a0 \u00a0 http://www.apache.org/licenses/LICENSE-2.0\n*\n* If any of the files related to licensing are missing or if you have any\n* other questions related to licensing please contact Trustwave Holdings, Inc.\n* directly using the email address security@modsecurity.org.\n*/\n\n#ifndef _MODSECURITY_H_\n#define _MODSECURITY_H_\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include <limits.h>\n#include <libxml/tree.h>\n#include <libxml/HTMLparser.h>\n\ntypedef struct rule_exception rule_exception;\ntypedef struct rule_exception hash_method;\ntypedef struct modsec_rec modsec_rec;\ntypedef struct directory_config directory_config;\ntypedef struct error_message_t error_message_t;\ntypedef struct msc_engine msc_engine;\ntypedef struct msc_data_chunk msc_data_chunk;\ntypedef struct msc_arg msc_arg;\ntypedef struct msc_string msc_string;\ntypedef struct msc_parm msc_parm;\n\n#include \"msc_release.h\"\n#include \"msc_logging.h\"\n#include \"msc_multipart.h\"\n#include \"msc_pcre.h\"\n#include \"msc_util.h\"\n#include \"msc_xml.h\"\n#include \"msc_geo.h\"\n#include \"msc_gsb.h\"\n#include \"msc_unicode.h\"\n#include \"re.h\"\n#include \"msc_crypt.h\"\n\n#include \"ap_config.h\"\n#include \"apr_md5.h\"\n#include \"apr_strings.h\"\n#include \"apr_hash.h\"\n#include \"httpd.h\"\n#include \"http_config.h\"\n#include \"http_log.h\"\n#include \"http_protocol.h\"\n\n#if defined(WITH_LUA)\n#include \"msc_lua.h\"\n#endif\n\n\n#define PHASE_REQUEST_HEADERS       1\n#define PHASE_REQUEST_BODY          2\n#define PHASE_RESPONSE_HEADERS      3\n#define PHASE_RESPONSE_BODY         4\n#define PHASE_LOGGING               5\n#define PHASE_FIRST                 PHASE_REQUEST_HEADERS\n#define PHASE_LAST                  PHASE_LOGGING\n\n#define NOT_SET                    -1l\n#define NOT_SET_P         ((void *)-1l)\n\n#define CREATEMODE ( APR_UREAD | APR_UWRITE | APR_GREAD )\n#define CREATEMODE_DIR ( APR_UREAD | APR_UWRITE | APR_UEXECUTE | APR_GREAD | APR_GEXECUTE )\n\n#if defined(NETWARE)\n#define CREATEMODE_UNISTD ( S_IREAD | S_IWRITE )\n#elif defined(WIN32)\n#define CREATEMODE_UNISTD ( _S_IREAD | _S_IWRITE )\n#else\n#define CREATEMODE_UNISTD ( S_IRUSR | S_IWUSR | S_IRGRP )\n#endif\n\n#if !defined(O_BINARY)\n#define O_BINARY (0)\n#endif\n\n#ifndef PIPE_BUF\n#define PIPE_BUF (512)\n#endif\n\n#define REQUEST_BODY_HARD_LIMIT                 1073741824L\n#define REQUEST_BODY_DEFAULT_INMEMORY_LIMIT     131072\n#define REQUEST_BODY_DEFAULT_LIMIT              134217728\n#define REQUEST_BODY_NO_FILES_DEFAULT_LIMIT     1048576\n#define RESPONSE_BODY_DEFAULT_LIMIT             524288\n#define RESPONSE_BODY_HARD_LIMIT                1073741824L\n\n#define RESPONSE_BODY_LIMIT_ACTION_REJECT       0\n#define RESPONSE_BODY_LIMIT_ACTION_PARTIAL      1\n\n#define REQUEST_BODY_FORCEBUF_OFF               0\n#define REQUEST_BODY_FORCEBUF_ON                1\n\n#define REQUEST_BODY_LIMIT_ACTION_REJECT       0\n#define REQUEST_BODY_LIMIT_ACTION_PARTIAL      1\n\n#define SECACTION_TARGETS                       \"REMOTE_ADDR\"\n#define SECACTION_ARGS                          \"@unconditionalMatch\"\n\n#define SECMARKER_TARGETS                       \"REMOTE_ADDR\"\n#define SECMARKER_ARGS                          \"@noMatch\"\n#define SECMARKER_BASE_ACTIONS                  \"t:none,pass,marker:\"\n\n#if !defined(OS2) && !defined(WIN32) && !defined(BEOS) && !defined(NETWARE)\n#include \"unixd.h\"\n#define __SET_MUTEX_PERMS\n#endif\n\n#define COOKIES_V0                      0\n#define COOKIES_V1                      1\n\n#ifdef WIN32\n#include <direct.h>\n#else\n#include <sys/types.h>\n#include <unistd.h>\n#endif\n\n#define NOTE_MSR \"modsecurity-tx-context\"\n\n#define FATAL_ERROR \"ModSecurity: Fatal error (memory allocation or unexpected internal error)!\"\n\nextern DSOLOCAL char *new_server_signature;\nextern DSOLOCAL char *chroot_dir;\n\nextern module AP_MODULE_DECLARE_DATA security2_module;\n\nextern DSOLOCAL const command_rec module_directives[];\n\nextern DSOLOCAL unsigned long int msc_pcre_match_limit;\n\nextern DSOLOCAL unsigned long int msc_pcre_match_limit_recursion;\n\nextern DSOLOCAL unsigned long int conn_read_state_limit;\n\nextern DSOLOCAL unsigned long int conn_write_state_limit;\n\nextern DSOLOCAL unsigned long int unicode_codepage;\n\nextern DSOLOCAL int *unicode_map_table;\n\n#define RESBODY_STATUS_NOT_READ         0   /* we were not configured to read the body */\n#define RESBODY_STATUS_ERROR            1   /* error occured while we were reading the body */\n#define RESBODY_STATUS_PARTIAL          2   /* partial body content available in the brigade */\n#define RESBODY_STATUS_READ_BRIGADE     3   /* body was read but not flattened */\n#define RESBODY_STATUS_READ             4   /* body was read and flattened */\n\n#define IF_STATUS_NONE                  0\n#define IF_STATUS_WANTS_TO_RUN          1\n#define IF_STATUS_COMPLETE              2\n\n#define OF_STATUS_NOT_STARTED           0\n#define OF_STATUS_IN_PROGRESS           1\n#define OF_STATUS_COMPLETE              2\n\n#define MSC_REQBODY_NONE                0\n#define MSC_REQBODY_MEMORY              1\n#define MSC_REQBODY_DISK                2\n\n#define ACTION_NONE                     0\n#define ACTION_DENY                     1\n#define ACTION_REDIRECT                 2\n#define ACTION_PROXY                    3\n#define ACTION_DROP                     4\n#define ACTION_ALLOW                    5\n#define ACTION_ALLOW_REQUEST            6\n#define ACTION_ALLOW_PHASE              7\n#define ACTION_PAUSE                    8\n\n#define MODSEC_DISABLED                 0\n#define MODSEC_DETECTION_ONLY           1\n#define MODSEC_ENABLED                  2\n\n#define HASH_DISABLED             0\n#define HASH_ENABLED              1\n\n#define HASH_URL_HREF_HASH_RX     0\n#define HASH_URL_HREF_HASH_PM     1\n#define HASH_URL_FACTION_HASH_RX  2\n#define HASH_URL_FACTION_HASH_PM  3\n#define HASH_URL_LOCATION_HASH_RX 4\n#define HASH_URL_LOCATION_HASH_PM 5\n#define HASH_URL_IFRAMESRC_HASH_RX 6\n#define HASH_URL_IFRAMESRC_HASH_PM 7\n#define HASH_URL_FRAMESRC_HASH_RX 8\n#define HASH_URL_FRAMESRC_HASH_PM 9\n\n#define HASH_KEYONLY              0\n#define HASH_SESSIONID            1\n#define HASH_REMOTEIP             2\n\n#define MODSEC_CACHE_DISABLED           0\n#define MODSEC_CACHE_ENABLED            1\n\n#define MODSEC_OFFLINE                  0\n#define MODSEC_ONLINE                   1\n\n#define REGEX_CAPTURE_BUFLEN            1024\n\n#define KEEP_FILES_OFF                  0\n#define KEEP_FILES_ON                   1\n#define KEEP_FILES_RELEVANT_ONLY        2\n\n#define RULE_EXCEPTION_IMPORT_ID        1\n#define RULE_EXCEPTION_IMPORT_MSG       2\n#define RULE_EXCEPTION_REMOVE_ID        3\n#define RULE_EXCEPTION_REMOVE_MSG       4\n#define RULE_EXCEPTION_REMOVE_TAG       5\n\n#define NBSP                            160\n\nstruct rule_exception {\n    int                  type;\n    const char          *param;\n    void                *param_data;\n};\n\nstruct modsec_rec {\n    apr_pool_t          *mp;\n    msc_engine          *modsecurity;\n\n    request_rec         *r_early;\n    request_rec         *r;\n    directory_config    *dcfg1;\n    directory_config    *dcfg2;\n    directory_config    *usercfg;\n    directory_config    *txcfg;\n\n    unsigned int         reqbody_should_exist;\n    unsigned int         reqbody_chunked;\n\n    unsigned int         phase;\n    unsigned int         phase_request_headers_complete;\n    unsigned int         phase_request_body_complete;\n\n    apr_bucket_brigade  *if_brigade;\n    unsigned int         if_status;\n    unsigned int         if_started_forwarding;\n\n    apr_size_t           reqbody_length;\n\n    apr_bucket_brigade  *of_brigade;\n    unsigned int         of_status;\n    unsigned int         of_done_reading;\n    unsigned int         of_skipping;\n    unsigned int         of_partial;\n    unsigned int         of_is_error;\n\n    unsigned int         resbody_status;\n    apr_size_t           resbody_length;\n    char                *resbody_data;\n    unsigned int         resbody_contains_html;\n\n    apr_size_t           stream_input_length;\n    char                *stream_input_data;\n    apr_size_t           stream_output_length;\n    char                *stream_output_data;\n    unsigned int        of_stream_changed;\n    unsigned int        if_stream_changed;\n\n    apr_array_header_t  *error_messages;\n    apr_array_header_t  *alerts;\n\n    const char          *txid;\n    const char          *sessionid;\n    const char          *userid;\n\n    const char          *server_software;\n    const char          *local_addr;\n    unsigned int         local_port;\n    const char          *local_user;\n\n    /* client */\n\n    const char          *remote_addr;\n    unsigned int         remote_port;\n    const char          *remote_user;\n\n    /* useragent */\n    const char          *useragent_ip;\n\n    /* request */\n\n    const char          *request_line;\n    const char          *request_method;\n    const char          *request_uri;\n    const char          *query_string;\n    const char          *request_protocol;\n\n    const char          *hostname;\n\n    apr_table_t         *request_headers;\n\n    apr_off_t            request_content_length;\n    const char          *request_content_type;\n\n    apr_table_t         *arguments;\n    apr_table_t         *arguments_to_sanitize;\n    apr_table_t         *request_headers_to_sanitize;\n    apr_table_t         *response_headers_to_sanitize;\n    apr_table_t         *request_cookies;\n    apr_table_t         *pattern_to_sanitize;\n\n    unsigned int        urlencoded_error;\n    unsigned int        inbound_error;\n    unsigned int        outbound_error;\n\n    unsigned int         is_relevant;\n\n    apr_table_t         *tx_vars;\n\n    /* ENH: refactor to allow arbitrary var tables */\n    apr_table_t         *geo_vars;\n\n    /* response */\n    unsigned int         response_status;\n    const char          *status_line;\n    const char          *response_protocol;\n    apr_table_t         *response_headers;\n    unsigned int         response_headers_sent;\n    apr_off_t            bytes_sent;\n\n    /* modsecurity request body processing stuff */\n\n    unsigned int         msc_reqbody_storage;       /* on disk or in memory */\n    unsigned int         msc_reqbody_spilltodisk;\n    unsigned int         msc_reqbody_read;\n\n    apr_pool_t          *msc_reqbody_mp;             /* this is where chunks are allocated from  */\n    apr_array_header_t  *msc_reqbody_chunks;         /* data chunks when stored in memory        */\n    unsigned int         msc_reqbody_length;         /* the amount of data received              */\n    int                  msc_reqbody_chunk_position; /* used when retrieving the body            */\n    unsigned int         msc_reqbody_chunk_offset;   /* offset of the chunk currently in use     */\n    msc_data_chunk      *msc_reqbody_chunk_current;  /* current chunk                            */\n    char                *msc_reqbody_buffer;\n\n    const char          *msc_reqbody_filename;       /* when stored on disk */\n    int                  msc_reqbody_fd;\n    msc_data_chunk      *msc_reqbody_disk_chunk;\n\n    const char          *msc_reqbody_processor;\n    int                  msc_reqbody_error;\n    const char          *msc_reqbody_error_msg;\n\n    apr_size_t           msc_reqbody_no_files_length;\n\n    char                *multipart_filename;\n    char                *multipart_name;\n    multipart_data      *mpd;                        /* MULTIPART processor data structure */\n\n    xml_data            *xml;                        /* XML processor data structure       */\n\n    /* audit logging */\n    char                *new_auditlog_boundary;\n    char                *new_auditlog_filename;\n    apr_file_t          *new_auditlog_fd;\n    unsigned int         new_auditlog_size;\n    apr_md5_ctx_t        new_auditlog_md5ctx;\n\n    unsigned int         was_intercepted;\n    unsigned int         rule_was_intercepted;\n    unsigned int         intercept_phase;\n    msre_actionset      *intercept_actionset;\n    const char          *intercept_message;\n\n    /* performance measurement */\n    apr_time_t       request_time;\n    apr_time_t\t\t time_phase1;\n    apr_time_t\t\t time_phase2;\n    apr_time_t\t\t time_phase3;\n    apr_time_t\t\t time_phase4;\n    apr_time_t\t\t time_phase5;\n    apr_time_t\t\t time_storage_read;\n    apr_time_t\t\t time_storage_write;\n    apr_time_t\t\t time_logging;\n    apr_time_t\t\t time_gc;\n    apr_table_t      *perf_rules;\n\n    apr_array_header_t  *matched_rules;\n    msc_string          *matched_var;\n    int                  highest_severity;\n\n    /* upload */\n    int                  upload_extract_files;\n    int                  upload_remove_files;\n    int                  upload_files_count;\n\n    /* other */\n    apr_table_t         *collections_original;\n    apr_table_t         *collections;\n    apr_table_t         *collections_dirty;\n\n    /* rule processing temp pool */\n    apr_pool_t          *msc_rule_mptmp;\n\n    /* content injection */\n    const char          *content_prepend;\n    apr_off_t            content_prepend_len;\n    const char          *content_append;\n    apr_off_t            content_append_len;\n\n    /* data cache */\n    apr_hash_t          *tcache;\n    apr_size_t           tcache_items;\n\n    /* removed rules */\n    apr_array_header_t  *removed_rules;\n    apr_array_header_t  *removed_rules_tag;\n    apr_array_header_t  *removed_rules_msg;\n\n    /* removed targets */\n    apr_table_t         *removed_targets;\n\n    /* When \"allow\" is executed the variable below is\n     * updated to contain the scope of the allow action. Set\n     * at 0 by default, it will have ACTION_ALLOW if we are\n     * to allow phases 1-4 and ACTION_ALLOW_REQUEST if we\n     * are to allow phases 1-2 only.\n     */\n    unsigned int         allow_scope;\n\n    /* matched vars */\n    apr_table_t         *matched_vars;\n\n    /* Generic request body processor context to be used by custom parsers. */\n    void                *reqbody_processor_ctx;\n\n    htmlDocPtr          crypto_html_tree;\n#if defined(WITH_LUA)\n    #ifdef CACHE_LUA\n    lua_State           *L;\n    #endif\n#endif\n};\n\nstruct directory_config {\n    apr_pool_t          *mp;\n\n    msre_ruleset        *ruleset;\n\n    int                  is_enabled;\n    int                  reqbody_access;\n    int                  reqintercept_oe;\n    int                  reqbody_buffering;\n    long int             reqbody_inmemory_limit;\n    long int             reqbody_limit;\n    long int             reqbody_no_files_limit;\n    int                  resbody_access;\n\n    long int             of_limit;\n    apr_table_t         *of_mime_types;\n    int                  of_mime_types_cleared;\n    int                  of_limit_action;\n    int                  if_limit_action;\n\n    const char          *debuglog_name;\n    int                  debuglog_level;\n    apr_file_t          *debuglog_fd;\n\n    int                  cookie_format;\n    int                  argument_separator;\n    const char           *cookiev0_separator;\n\n    int                  rule_inheritance;\n    apr_array_header_t  *rule_exceptions;\n\n\n    /* -- Audit log -- */\n\n    /* Max rule time */\n    int                  max_rule_time;\n\n    /* Whether audit log should be enabled in the context or not */\n    int                  auditlog_flag;\n\n    /* AUDITLOG_SERIAL (single file) or AUDITLOG_CONCURRENT (multiple files) */\n    int                  auditlog_type;\n\n    /* Mode for audit log directories and files */\n    apr_fileperms_t      auditlog_dirperms;\n    apr_fileperms_t      auditlog_fileperms;\n\n    /* The name of the audit log file (for the old type), or the\n     * name of the index file (for the new audit log type)\n     */\n    char                *auditlog_name;\n    /* The name of the secondary index file */\n    char                *auditlog2_name;\n\n    /* The file descriptors for the files above */\n    apr_file_t          *auditlog_fd;\n    apr_file_t          *auditlog2_fd;\n\n    /* For the new-style audit log only, the path where\n     * audit log entries will be stored\n     */\n    char                *auditlog_storage_dir;\n\n    /* A list of parts to include in the new-style audit log\n     * entry. By default, it contains 'ABCFHZ'. Have a look at\n     * the AUDITLOG_PART_* constants above to decipher the\n     * meaning.\n     */\n    char                *auditlog_parts;\n\n    /* A regular expression that determines if a response\n     * status is treated as relevant.\n     */\n    msc_regex_t         *auditlog_relevant_regex;\n\n    /* Upload */\n    const char          *tmp_dir;\n    const char          *upload_dir;\n    int                  upload_keep_files;\n    int                  upload_validates_files;\n    int                  upload_filemode; /* int only so NOT_SET works */\n    int                  upload_file_limit;\n\n    /* Used only in the configuration phase. */\n    msre_rule           *tmp_chain_starter;\n    msre_actionset      *tmp_default_actionset;\n    apr_table_t         *tmp_rule_placeholders;\n\n    /* Misc */\n    const char          *data_dir;\n    const char          *webappid;\n    const char          *sensor_id;\n    const char          *httpBlkey;\n\n    /* Content injection. */\n    int                  content_injection_enabled;\n\n    /* Stream Inspection */\n    int                 stream_inbody_inspection;\n    int                 stream_outbody_inspection;\n\n    /* Geo Lookup */\n    geo_db              *geo;\n\n    /* Gsb Lookup */\n    gsb_db              *gsb;\n\n    /* Unicode map */\n    unicode_map         *u_map;\n\n    /* Cache */\n    int                  cache_trans;\n    int                  cache_trans_incremental;\n    apr_size_t           cache_trans_min;\n    apr_size_t           cache_trans_max;\n    apr_size_t           cache_trans_maxitems;\n\n    /* Array to hold signatures of components, which will\n     * appear in the ModSecurity signature in the audit log.\n     */\n    apr_array_header_t  *component_signatures;\n\n    /* Request character encoding. */\n    const char          *request_encoding;\n\n    int disable_backend_compression;\n\n    /* Collection timeout */\n    int col_timeout;\n\n    /* hash of ids */\n    apr_hash_t          *rule_id_htab;\n\n    /* Hash */\n    apr_array_header_t  *hash_method;\n    const char *crypto_key;\n    int                 crypto_key_len;\n    const char          *crypto_param_name;\n    int                 hash_is_enabled;\n    int                 hash_enforcement;\n    int                 crypto_key_add;\n    int                 crypto_hash_href_rx;\n    int                 crypto_hash_faction_rx;\n    int                 crypto_hash_location_rx;\n    int                 crypto_hash_iframesrc_rx;\n    int                 crypto_hash_framesrc_rx;\n    int                 crypto_hash_href_pm;\n    int                 crypto_hash_faction_pm;\n    int                 crypto_hash_location_pm;\n    int                 crypto_hash_iframesrc_pm;\n    int                 crypto_hash_framesrc_pm;\n};\n\nstruct error_message_t {\n    const char          *file;\n    int                  line;\n    int                  level;\n    apr_status_t         status;\n    const char          *message;\n};\n\nstruct msc_engine {\n    apr_pool_t              *mp;\n    apr_global_mutex_t      *auditlog_lock;\n    apr_global_mutex_t      *geo_lock;\n    msre_engine             *msre;\n    unsigned int             processing_mode;\n};\n\nstruct msc_data_chunk {\n    char                    *data;\n    apr_size_t               length;\n    unsigned int             is_permanent;\n};\n\nstruct msc_arg {\n    const char              *name;\n    unsigned int             name_len;\n    unsigned int             name_origin_offset;\n    unsigned int             name_origin_len;\n    const char              *value;\n    unsigned int             value_len;\n    unsigned int             value_origin_offset;\n    unsigned int             value_origin_len;\n    const char              *origin;\n};\n\nstruct msc_string {\n    char                    *name;\n    unsigned int             name_len;\n    char                    *value;\n    unsigned int             value_len;\n};\n\nstruct msc_parm {\n    char                    *value;\n    int                     pad_1;\n    int                     pad_2;\n};\n\n/* Engine functions */\n\nmsc_engine DSOLOCAL *modsecurity_create(apr_pool_t *mp, int processing_mode);\n\nint DSOLOCAL modsecurity_init(msc_engine *msce, apr_pool_t *mp);\n\nvoid DSOLOCAL modsecurity_child_init(msc_engine *msce);\n\nvoid DSOLOCAL modsecurity_shutdown(msc_engine *msce);\n\napr_status_t DSOLOCAL modsecurity_tx_init(modsec_rec *msr);\n\napr_status_t DSOLOCAL modsecurity_process_phase(modsec_rec *msr, unsigned int phase);\n\n\n/* Request body functions */\n\napr_status_t DSOLOCAL modsecurity_request_body_start(modsec_rec *msr, char **error_msg);\n\napr_status_t DSOLOCAL modsecurity_request_body_store(modsec_rec *msr,\n    const char *data, apr_size_t length, char **error_msg);\n\napr_status_t DSOLOCAL modsecurity_request_body_end(modsec_rec *msr, char **error_msg);\n\napr_status_t DSOLOCAL modsecurity_request_body_to_stream(modsec_rec *msr, const char *buffer, int buflen, char **error_msg);\n\napr_status_t DSOLOCAL modsecurity_request_body_retrieve_start(modsec_rec *msr, char **error_msg);\n\napr_status_t DSOLOCAL modsecurity_request_body_retrieve_end(modsec_rec *msr);\n\n/* Retrieves up to nbytes bytes of the request body. Returns 1 on\n * success, 0 when there is no more data, or -1 on error. On return\n * nbytes will contain the number of bytes stored in the buffer.\n */\napr_status_t DSOLOCAL modsecurity_request_body_retrieve(modsec_rec *msr, msc_data_chunk **chunk,\n    long int nbytes, char **error_msg);\n\nvoid DSOLOCAL msc_add(modsec_rec *msr, int level, msre_actionset *actionset,\n    const char *action_message, const char *rule_message);\n\nconst char DSOLOCAL *msc_alert_message(modsec_rec *msr, msre_actionset *actionset, const char *action_message,\n    const char *rule_message);\n\nvoid DSOLOCAL msc_alert(modsec_rec *msr, int level, msre_actionset *actionset, const char *action_message,\n    const char *rule_message);\n\napr_status_t DSOLOCAL modsecurity_request_body_clear(modsec_rec *msr, char **error_msg);\n\n#endif\n", "/*\n* ModSecurity for Apache 2.x, http://www.modsecurity.org/\n* Copyright (c) 2004-2011 Trustwave Holdings, Inc. (http://www.trustwave.com/)\n*\n* You may not use this file except in compliance with\n* the License. \u00a0You may obtain a copy of the License at\n*\n* \u00a0 \u00a0 http://www.apache.org/licenses/LICENSE-2.0\n*\n* If any of the files related to licensing are missing or if you have any\n* other questions related to licensing please contact Trustwave Holdings, Inc.\n* directly using the email address security@modsecurity.org.\n*/\n\n#include \"msc_xml.h\"\n\n\n/**\n * Initialise XML parser.\n */\nint xml_init(modsec_rec *msr, char **error_msg) {\n    if (error_msg == NULL) return -1;\n    *error_msg = NULL;\n\n    msr->xml = apr_pcalloc(msr->mp, sizeof(xml_data));\n    if (msr->xml == NULL) return -1;\n\n    return 1;\n}\n\n#if 0\nstatic void xml_receive_sax_error(void *data, const char *msg, ...) {\n    modsec_rec *msr = (modsec_rec *)data;\n    char message[256];\n\n    if (msr == NULL) return;\n\n    apr_snprintf(message, sizeof(message), \"%s (line %d offset %d)\",\n        log_escape_nq(msr->mp, msr->xml->parsing_ctx->lastError.message),\n        msr->xml->parsing_ctx->lastError.line,\n        msr->xml->parsing_ctx->lastError.int2);\n\n    msr_log(msr, 5, \"XML: Parsing error: %s\", message);\n}\n#endif\n\n/**\n * Feed one chunk of data to the XML parser.\n */\nint xml_process_chunk(modsec_rec *msr, const char *buf, unsigned int size, char **error_msg) {\n    if (error_msg == NULL) return -1;\n    *error_msg = NULL;\n\n    /* We want to initialise our parsing context here, to\n     * enable us to pass it the first chunk of data so that\n     * it can attempt to auto-detect the encoding.\n     */\n    if (msr->xml->parsing_ctx == NULL) {\n\n        /* First invocation. */\n\n        msr_log(msr, 4, \"XML: Initialising parser.\");\n\n        /* NOTE When Sax interface is used libxml will not\n         *      create the document object, but we need it.\n\n        msr->xml->sax_handler = (xmlSAXHandler *)apr_pcalloc(msr->mp, sizeof(xmlSAXHandler));\n        if (msr->xml->sax_handler == NULL) return -1;\n        msr->xml->sax_handler->error = xml_receive_sax_error;\n        msr->xml->sax_handler->warning = xml_receive_sax_error;\n        msr->xml->parsing_ctx = xmlCreatePushParserCtxt(msr->xml->sax_handler, msr,\n            buf, size, \"body.xml\");\n\n        */\n\n        msr->xml->parsing_ctx = xmlCreatePushParserCtxt(NULL, NULL, buf, size, \"body.xml\");\n        if (msr->xml->parsing_ctx == NULL) {\n            *error_msg = apr_psprintf(msr->mp, \"XML: Failed to create parsing context.\");\n            return -1;\n        }\n    } else {\n\n        /* Not a first invocation. */\n\n        xmlParseChunk(msr->xml->parsing_ctx, buf, size, 0);\n        if (msr->xml->parsing_ctx->wellFormed != 1) {\n            *error_msg = apr_psprintf(msr->mp, \"XML: Failed parsing document.\");\n            return -1;\n        }\n    }\n\n    return 1;\n}\n\n/**\n * Finalise XML parsing.\n */\nint xml_complete(modsec_rec *msr, char **error_msg) {\n    if (error_msg == NULL) return -1;\n    *error_msg = NULL;\n\n    /* Only if we have a context, meaning we've done some work. */\n    if (msr->xml->parsing_ctx != NULL) {\n        /* This is how we signalise the end of parsing to libxml. */\n        xmlParseChunk(msr->xml->parsing_ctx, NULL, 0, 1);\n\n        /* Preserve the results for our reference. */\n        msr->xml->well_formed = msr->xml->parsing_ctx->wellFormed;\n        msr->xml->doc = msr->xml->parsing_ctx->myDoc;\n\n        /* Clean up everything else. */\n        xmlFreeParserCtxt(msr->xml->parsing_ctx);\n        msr->xml->parsing_ctx = NULL;\n        msr_log(msr, 4, \"XML: Parsing complete (well_formed %u).\", msr->xml->well_formed);\n\n        if (msr->xml->well_formed != 1) {\n            *error_msg = apr_psprintf(msr->mp, \"XML: Failed parsing document.\");\n            return -1;\n        }\n    }\n\n    return 1;\n}\n\n/**\n * Frees the resources used for XML parsing.\n */\napr_status_t xml_cleanup(modsec_rec *msr) {\n    if (msr->xml->doc != NULL) {\n        xmlFreeDoc(msr->xml->doc);\n        msr->xml->doc = NULL;\n    }\n\n    return 1;\n}\n"], "fixing_code": ["/*\n* ModSecurity for Apache 2.x, http://www.modsecurity.org/\n* Copyright (c) 2004-2011 Trustwave Holdings, Inc. (http://www.trustwave.com/)\n*\n* You may not use this file except in compliance with\n* the License. \u00a0You may obtain a copy of the License at\n*\n* \u00a0 \u00a0 http://www.apache.org/licenses/LICENSE-2.0\n*\n* If any of the files related to licensing are missing or if you have any\n* other questions related to licensing please contact Trustwave Holdings, Inc.\n* directly using the email address security@modsecurity.org.\n*/\n\n#include <limits.h>\n\n#include \"modsecurity.h\"\n#include \"msc_logging.h\"\n#include \"msc_util.h\"\n#include \"http_log.h\"\n#include \"apr_lib.h\"\n#include \"acmp.h\"\n#include \"msc_crypt.h\"\n\n#if defined(WITH_LUA)\n#include \"msc_lua.h\"\n#endif\n\n\n/* -- Directory context creation and initialisation -- */\n\n/**\n * Creates a fresh directory configuration.\n */\nvoid *create_directory_config(apr_pool_t *mp, char *path)\n{\n    directory_config *dcfg = (directory_config *)apr_pcalloc(mp, sizeof(directory_config));\n    if (dcfg == NULL) return NULL;\n\n    #ifdef DEBUG_CONF\n    ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, mp, \"Created directory config %pp path %s\", dcfg, path);\n    #endif\n\n    dcfg->mp = mp;\n    dcfg->is_enabled = NOT_SET;\n\n    dcfg->reqbody_access = NOT_SET;\n    dcfg->reqintercept_oe = NOT_SET;\n    dcfg->reqbody_buffering = NOT_SET;\n    dcfg->reqbody_inmemory_limit = NOT_SET;\n    dcfg->reqbody_limit = NOT_SET;\n    dcfg->reqbody_no_files_limit = NOT_SET;\n    dcfg->resbody_access = NOT_SET;\n\n    dcfg->debuglog_name = NOT_SET_P;\n    dcfg->debuglog_level = NOT_SET;\n    dcfg->debuglog_fd = NOT_SET_P;\n\n    dcfg->of_limit = NOT_SET;\n    dcfg->if_limit_action = NOT_SET;\n    dcfg->of_limit_action = NOT_SET;\n    dcfg->of_mime_types = NOT_SET_P;\n    dcfg->of_mime_types_cleared = NOT_SET;\n\n    dcfg->cookie_format = NOT_SET;\n    dcfg->argument_separator = NOT_SET;\n    dcfg->cookiev0_separator = NOT_SET_P;\n\n    dcfg->rule_inheritance = NOT_SET;\n    dcfg->rule_exceptions = apr_array_make(mp, 16, sizeof(rule_exception *));\n    dcfg->hash_method = apr_array_make(mp, 16, sizeof(hash_method *));\n\n    /* audit log variables */\n    dcfg->auditlog_flag = NOT_SET;\n    dcfg->auditlog_type = NOT_SET;\n    dcfg->max_rule_time = NOT_SET;\n    dcfg->auditlog_dirperms = NOT_SET;\n    dcfg->auditlog_fileperms = NOT_SET;\n    dcfg->auditlog_name = NOT_SET_P;\n    dcfg->auditlog2_name = NOT_SET_P;\n    dcfg->auditlog_fd = NOT_SET_P;\n    dcfg->auditlog2_fd = NOT_SET_P;\n    dcfg->auditlog_storage_dir = NOT_SET_P;\n    dcfg->auditlog_parts = NOT_SET_P;\n    dcfg->auditlog_relevant_regex = NOT_SET_P;\n\n    dcfg->ruleset = NULL;\n\n    /* Upload */\n    dcfg->tmp_dir = NOT_SET_P;\n    dcfg->upload_dir = NOT_SET_P;\n    dcfg->upload_keep_files = NOT_SET;\n    dcfg->upload_validates_files = NOT_SET;\n    dcfg->upload_filemode = NOT_SET;\n    dcfg->upload_file_limit = NOT_SET;\n\n    /* These are only used during the configuration process. */\n    dcfg->tmp_chain_starter = NULL;\n    dcfg->tmp_default_actionset = NULL;\n    dcfg->tmp_rule_placeholders = NULL;\n\n    /* Misc */\n    dcfg->data_dir = NOT_SET_P;\n    dcfg->webappid = NOT_SET_P;\n    dcfg->sensor_id = NOT_SET_P;\n    dcfg->httpBlkey = NOT_SET_P;\n\n    /* Content injection. */\n    dcfg->content_injection_enabled = NOT_SET;\n\n    /* Stream inspection */\n    dcfg->stream_inbody_inspection = NOT_SET;\n    dcfg->stream_outbody_inspection = NOT_SET;\n\n    /* Geo Lookups */\n    dcfg->geo = NOT_SET_P;\n\n    /* Gsb Lookups */\n    dcfg->gsb = NOT_SET_P;\n\n    /* Unicode Map */\n    dcfg->u_map = NOT_SET_P;\n\n    /* Cache */\n    dcfg->cache_trans = NOT_SET;\n    dcfg->cache_trans_incremental = NOT_SET;\n    dcfg->cache_trans_min = NOT_SET;\n    dcfg->cache_trans_max = NOT_SET;\n    dcfg->cache_trans_maxitems = NOT_SET;\n\n    /* Rule ids */\n    dcfg->rule_id_htab = apr_hash_make(mp);\n    dcfg->component_signatures = apr_array_make(mp, 16, sizeof(char *));\n\n    dcfg->request_encoding = NOT_SET_P;\n    dcfg->disable_backend_compression = NOT_SET;\n\n    /* Collection timeout */\n    dcfg->col_timeout = NOT_SET;\n\n    dcfg->crypto_key = NOT_SET_P;\n    dcfg->crypto_key_len = NOT_SET;\n    dcfg->crypto_key_add = NOT_SET;\n    dcfg->crypto_param_name = NOT_SET_P;\n    dcfg->hash_is_enabled = NOT_SET;\n    dcfg->hash_enforcement = NOT_SET;\n    dcfg->crypto_hash_href_rx = NOT_SET;\n    dcfg->crypto_hash_faction_rx = NOT_SET;\n    dcfg->crypto_hash_location_rx = NOT_SET;\n    dcfg->crypto_hash_iframesrc_rx = NOT_SET;\n    dcfg->crypto_hash_framesrc_rx = NOT_SET;\n    dcfg->crypto_hash_href_pm = NOT_SET;\n    dcfg->crypto_hash_faction_pm = NOT_SET;\n    dcfg->crypto_hash_location_pm = NOT_SET;\n    dcfg->crypto_hash_iframesrc_pm = NOT_SET;\n    dcfg->crypto_hash_framesrc_pm = NOT_SET;\n\n\n    /* xml external entity */\n    dcfg->xml_external_entity = NOT_SET;\n\n    return dcfg;\n}\n\n/**\n * Copies rules between one phase of two configuration contexts,\n * taking exceptions into account.\n */\nstatic void copy_rules_phase(apr_pool_t *mp,\n                             apr_array_header_t *parent_phase_arr,\n                             apr_array_header_t *child_phase_arr,\n                             apr_array_header_t *exceptions_arr)\n{\n    rule_exception **exceptions;\n    msre_rule **rules;\n    int i, j;\n    int mode = 0;\n\n    rules = (msre_rule **)parent_phase_arr->elts;\n    for(i = 0; i < parent_phase_arr->nelts; i++) {\n        msre_rule *rule = (msre_rule *)rules[i];\n        int copy = 1;\n\n        if (mode == 0) {\n            /* First rule in the chain. */\n            exceptions = (rule_exception **)exceptions_arr->elts;\n            for(j = 0; j < exceptions_arr->nelts; j++) {\n\n                /* Process exceptions. */\n                switch(exceptions[j]->type) {\n                    case RULE_EXCEPTION_REMOVE_ID :\n                        if ((rule->actionset != NULL)&&(rule->actionset->id != NULL)) {\n                            int ruleid = atoi(rule->actionset->id);\n                            if (rule_id_in_range(ruleid, exceptions[j]->param)) copy--;\n                        }\n                        break;\n                    case RULE_EXCEPTION_REMOVE_MSG :\n                        if ((rule->actionset != NULL)&&(rule->actionset->msg != NULL)) {\n                            char *my_error_msg = NULL;\n\n                            int rc = msc_regexec(exceptions[j]->param_data,\n                                    rule->actionset->msg, strlen(rule->actionset->msg),\n                                    &my_error_msg);\n                            if (rc >= 0) copy--;\n                        }\n                        break;\n                    case RULE_EXCEPTION_REMOVE_TAG :\n                        if ((rule->actionset != NULL)&&(apr_is_empty_table(rule->actionset->actions) == 0)) {\n                            char *my_error_msg = NULL;\n                            const apr_array_header_t *tarr = NULL;\n                            const apr_table_entry_t *telts = NULL;\n                            int c;\n\n                            tarr = apr_table_elts(rule->actionset->actions);\n                            telts = (const apr_table_entry_t*)tarr->elts;\n\n                            for (c = 0; c < tarr->nelts; c++) {\n                                msre_action *action = (msre_action *)telts[c].val;\n                                if(strcmp(\"tag\", action->metadata->name) == 0)  {\n\n                                    int rc = msc_regexec(exceptions[j]->param_data,\n                                            action->param, strlen(action->param),\n                                            &my_error_msg);\n                                    if (rc >= 0) copy--;\n                                }\n                            }\n                        }\n                        break;\n                }\n            }\n\n            if (copy > 0) {\n#ifdef DEBUG_CONF\n                ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, mp, \"Copy rule %pp [id \\\"%s\\\"]\", rule, rule->actionset->id);\n#endif\n\n                /* Copy the rule. */\n                *(msre_rule **)apr_array_push(child_phase_arr) = rule;\n                if (rule->actionset->is_chained) mode = 2;\n            } else {\n                if (rule->actionset->is_chained) mode = 1;\n            }\n        } else {\n            if (mode == 2) {\n#ifdef DEBUG_CONF\n                ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, mp, \"Copy chain %pp for rule %pp [id \\\"%s\\\"]\", rule, rule->chain_starter, rule->chain_starter->actionset->id);\n#endif\n\n                /* Copy the rule (it belongs to the chain we want to include. */\n                *(msre_rule **)apr_array_push(child_phase_arr) = rule;\n            }\n\n            if ((rule->actionset == NULL)||(rule->actionset->is_chained == 0)) mode = 0;\n        }\n    }\n}\n\n/**\n * Copies rules between two configuration contexts,\n * taking exceptions into account.\n */\nstatic int copy_rules(apr_pool_t *mp, msre_ruleset *parent_ruleset,\n                      msre_ruleset *child_ruleset,\n                      apr_array_header_t *exceptions_arr)\n{\n    copy_rules_phase(mp, parent_ruleset->phase_request_headers,\n        child_ruleset->phase_request_headers, exceptions_arr);\n    copy_rules_phase(mp, parent_ruleset->phase_request_body,\n        child_ruleset->phase_request_body, exceptions_arr);\n    copy_rules_phase(mp, parent_ruleset->phase_response_headers,\n        child_ruleset->phase_response_headers, exceptions_arr);\n    copy_rules_phase(mp, parent_ruleset->phase_response_body,\n        child_ruleset->phase_response_body, exceptions_arr);\n    copy_rules_phase(mp, parent_ruleset->phase_logging,\n        child_ruleset->phase_logging, exceptions_arr);\n\n    return 1;\n}\n\n/**\n * Merges two directory configurations.\n */\nvoid *merge_directory_configs(apr_pool_t *mp, void *_parent, void *_child)\n{\n    directory_config *parent = (directory_config *)_parent;\n    directory_config *child = (directory_config *)_child;\n    directory_config *merged = create_directory_config(mp, NULL);\n\n    #ifdef DEBUG_CONF\n    ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, mp, \"Merge parent %pp child %pp RESULT %pp\", _parent, _child, merged);\n    #endif\n\n    if (merged == NULL) return NULL;\n\n    /* Use values from the child configuration where possible,\n     * otherwise use the parent's.\n     */\n\n    merged->is_enabled = (child->is_enabled == NOT_SET\n        ? parent->is_enabled : child->is_enabled);\n\n    /* IO parameters */\n    merged->reqbody_access = (child->reqbody_access == NOT_SET\n        ? parent->reqbody_access : child->reqbody_access);\n    merged->reqbody_buffering = (child->reqbody_buffering == NOT_SET\n        ? parent->reqbody_buffering : child->reqbody_buffering);\n    merged->reqbody_inmemory_limit = (child->reqbody_inmemory_limit == NOT_SET\n        ? parent->reqbody_inmemory_limit : child->reqbody_inmemory_limit);\n    merged->reqbody_limit = (child->reqbody_limit == NOT_SET\n        ? parent->reqbody_limit : child->reqbody_limit);\n    merged->reqbody_no_files_limit = (child->reqbody_no_files_limit == NOT_SET\n        ? parent->reqbody_no_files_limit : child->reqbody_no_files_limit);\n    merged->resbody_access = (child->resbody_access == NOT_SET\n        ? parent->resbody_access : child->resbody_access);\n\n    merged->of_limit = (child->of_limit == NOT_SET\n        ? parent->of_limit : child->of_limit);\n    merged->if_limit_action = (child->if_limit_action == NOT_SET\n        ? parent->if_limit_action : child->if_limit_action);\n    merged->of_limit_action = (child->of_limit_action == NOT_SET\n        ? parent->of_limit_action : child->of_limit_action);\n    merged->reqintercept_oe = (child->reqintercept_oe == NOT_SET\n        ? parent->reqintercept_oe : child->reqintercept_oe);\n\n    if (child->of_mime_types != NOT_SET_P) {\n        /* Child added to the table */\n\n        if (child->of_mime_types_cleared == 1) {\n            /* The list of MIME types was cleared in the child,\n             * which means the parent's MIME types went away and\n             * we should not take them into consideration here.\n             */\n            merged->of_mime_types = child->of_mime_types;\n            merged->of_mime_types_cleared = 1;\n        } else {\n            /* Add MIME types defined in the child to those\n             * defined in the parent context.\n             */\n            if (parent->of_mime_types == NOT_SET_P) {\n                merged->of_mime_types = child->of_mime_types;\n                merged->of_mime_types_cleared = NOT_SET;\n            } else {\n                merged->of_mime_types = apr_table_overlay(mp, parent->of_mime_types,\n                    child->of_mime_types);\n                if (merged->of_mime_types == NULL) return NULL;\n            }\n        }\n    } else {\n        /* Child did not add to the table */\n\n        if (child->of_mime_types_cleared == 1) {\n            merged->of_mime_types_cleared = 1;\n        } else {\n            merged->of_mime_types = parent->of_mime_types;\n            merged->of_mime_types_cleared = parent->of_mime_types_cleared;\n        }\n    }\n\n    /* debug log */\n    if (child->debuglog_fd == NOT_SET_P) {\n        merged->debuglog_name = parent->debuglog_name;\n        merged->debuglog_fd = parent->debuglog_fd;\n    } else {\n        merged->debuglog_name = child->debuglog_name;\n        merged->debuglog_fd = child->debuglog_fd;\n    }\n\n    merged->debuglog_level = (child->debuglog_level == NOT_SET\n        ? parent->debuglog_level : child->debuglog_level);\n\n    merged->cookie_format = (child->cookie_format == NOT_SET\n        ? parent->cookie_format : child->cookie_format);\n    merged->argument_separator = (child->argument_separator == NOT_SET\n        ? parent->argument_separator : child->argument_separator);\n    merged->cookiev0_separator = (child->cookiev0_separator == NOT_SET_P\n        ? parent->cookiev0_separator : child->cookiev0_separator);\n\n\n    /* rule inheritance */\n    if ((child->rule_inheritance == NOT_SET)||(child->rule_inheritance == 1)) {\n        merged->rule_inheritance = parent->rule_inheritance;\n        if ((child->ruleset == NULL)&&(parent->ruleset == NULL)) {\n            #ifdef DEBUG_CONF\n            ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, mp, \"No rules in this context.\");\n            #endif\n\n            /* Do nothing, there are no rules in either context. */\n        } else\n        if (child->ruleset == NULL) {\n            #ifdef DEBUG_CONF\n            ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, mp, \"Using parent rules in this context.\");\n            #endif\n\n            /* Copy the rules from the parent context. */\n            merged->ruleset = msre_ruleset_create(parent->ruleset->engine, mp);\n            copy_rules(mp, parent->ruleset, merged->ruleset, child->rule_exceptions);\n        } else\n        if (parent->ruleset == NULL) {\n            #ifdef DEBUG_CONF\n            ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, mp, \"Using child rules in this context.\");\n            #endif\n\n            /* Copy child rules. */\n            merged->ruleset = msre_ruleset_create(child->ruleset->engine, mp);\n            merged->ruleset->phase_request_headers = apr_array_copy(mp,\n                child->ruleset->phase_request_headers);\n            merged->ruleset->phase_request_body = apr_array_copy(mp,\n                child->ruleset->phase_request_body);\n            merged->ruleset->phase_response_headers = apr_array_copy(mp,\n                child->ruleset->phase_response_headers);\n            merged->ruleset->phase_response_body = apr_array_copy(mp,\n                child->ruleset->phase_response_body);\n            merged->ruleset->phase_logging = apr_array_copy(mp,\n                child->ruleset->phase_logging);\n        } else {\n            #ifdef DEBUG_CONF\n            ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, mp, \"Using parent then child rules in this context.\");\n            #endif\n\n            /* Copy parent rules, then add child rules to it. */\n            merged->ruleset = msre_ruleset_create(parent->ruleset->engine, mp);\n            copy_rules(mp, parent->ruleset, merged->ruleset, child->rule_exceptions);\n\n            apr_array_cat(merged->ruleset->phase_request_headers,\n                child->ruleset->phase_request_headers);\n            apr_array_cat(merged->ruleset->phase_request_body,\n                child->ruleset->phase_request_body);\n            apr_array_cat(merged->ruleset->phase_response_headers,\n                child->ruleset->phase_response_headers);\n            apr_array_cat(merged->ruleset->phase_response_body,\n                child->ruleset->phase_response_body);\n            apr_array_cat(merged->ruleset->phase_logging,\n                child->ruleset->phase_logging);\n        }\n    } else {\n        merged->rule_inheritance = 0;\n        if (child->ruleset != NULL) {\n            /* Copy child rules. */\n            merged->ruleset = msre_ruleset_create(child->ruleset->engine, mp);\n            merged->ruleset->phase_request_headers = apr_array_copy(mp,\n                child->ruleset->phase_request_headers);\n            merged->ruleset->phase_request_body = apr_array_copy(mp,\n                child->ruleset->phase_request_body);\n            merged->ruleset->phase_response_headers = apr_array_copy(mp,\n                child->ruleset->phase_response_headers);\n            merged->ruleset->phase_response_body = apr_array_copy(mp,\n                child->ruleset->phase_response_body);\n            merged->ruleset->phase_logging = apr_array_copy(mp,\n                child->ruleset->phase_logging);\n        }\n    }\n\n    /* Merge rule exceptions. */\n    merged->rule_exceptions = apr_array_append(mp, parent->rule_exceptions,\n        child->rule_exceptions);\n\n    merged->hash_method = apr_array_append(mp, parent->hash_method,\n        child->hash_method);\n\n    /* audit log variables */\n    merged->auditlog_flag = (child->auditlog_flag == NOT_SET\n        ? parent->auditlog_flag : child->auditlog_flag);\n    merged->auditlog_type = (child->auditlog_type == NOT_SET\n        ? parent->auditlog_type : child->auditlog_type);\n    merged->max_rule_time = (child->max_rule_time == NOT_SET\n        ? parent->max_rule_time : child->max_rule_time);\n    merged->auditlog_dirperms = (child->auditlog_dirperms == NOT_SET\n        ? parent->auditlog_dirperms : child->auditlog_dirperms);\n    merged->auditlog_fileperms = (child->auditlog_fileperms == NOT_SET\n        ? parent->auditlog_fileperms : child->auditlog_fileperms);\n    if (child->auditlog_fd != NOT_SET_P) {\n        merged->auditlog_fd = child->auditlog_fd;\n        merged->auditlog_name = child->auditlog_name;\n    } else {\n        merged->auditlog_fd = parent->auditlog_fd;\n        merged->auditlog_name = parent->auditlog_name;\n    }\n    if (child->auditlog2_fd != NOT_SET_P) {\n        merged->auditlog2_fd = child->auditlog2_fd;\n        merged->auditlog2_name = child->auditlog2_name;\n    } else {\n        merged->auditlog2_fd = parent->auditlog2_fd;\n        merged->auditlog2_name = parent->auditlog2_name;\n    }\n    merged->auditlog_storage_dir = (child->auditlog_storage_dir == NOT_SET_P\n        ? parent->auditlog_storage_dir : child->auditlog_storage_dir);\n    merged->auditlog_parts = (child->auditlog_parts == NOT_SET_P\n        ? parent->auditlog_parts : child->auditlog_parts);\n    merged->auditlog_relevant_regex = (child->auditlog_relevant_regex == NOT_SET_P\n        ? parent->auditlog_relevant_regex : child->auditlog_relevant_regex);\n\n    /* Upload */\n    merged->tmp_dir = (child->tmp_dir == NOT_SET_P\n        ? parent->tmp_dir : child->tmp_dir);\n    merged->upload_dir = (child->upload_dir == NOT_SET_P\n        ? parent->upload_dir : child->upload_dir);\n    merged->upload_keep_files = (child->upload_keep_files == NOT_SET\n        ? parent->upload_keep_files : child->upload_keep_files);\n    merged->upload_validates_files = (child->upload_validates_files == NOT_SET\n        ? parent->upload_validates_files : child->upload_validates_files);\n    merged->upload_filemode = (child->upload_filemode == NOT_SET\n        ? parent->upload_filemode : child->upload_filemode);\n    merged->upload_file_limit = (child->upload_file_limit == NOT_SET\n        ? parent->upload_file_limit : child->upload_file_limit);\n\n    /* Misc */\n    merged->data_dir = (child->data_dir == NOT_SET_P\n        ? parent->data_dir : child->data_dir);\n    merged->webappid = (child->webappid == NOT_SET_P\n        ? parent->webappid : child->webappid);\n    merged->sensor_id = (child->sensor_id == NOT_SET_P\n        ? parent->sensor_id : child->sensor_id);\n    merged->httpBlkey = (child->httpBlkey == NOT_SET_P\n        ? parent->httpBlkey : child->httpBlkey);\n\n    /* Content injection. */\n    merged->content_injection_enabled = (child->content_injection_enabled == NOT_SET\n        ? parent->content_injection_enabled : child->content_injection_enabled);\n\n    /* Stream inspection */\n    merged->stream_inbody_inspection = (child->stream_inbody_inspection == NOT_SET\n        ? parent->stream_inbody_inspection : child->stream_inbody_inspection);\n    merged->stream_outbody_inspection = (child->stream_outbody_inspection == NOT_SET\n        ? parent->stream_outbody_inspection : child->stream_outbody_inspection);\n\n    /* Geo Lookup */\n    merged->geo = (child->geo == NOT_SET_P\n        ? parent->geo : child->geo);\n\n    /* Gsb Lookup */\n    merged->gsb = (child->gsb == NOT_SET_P\n        ? parent->gsb : child->gsb);\n\n    /* Unicode Map */\n    merged->u_map = (child->u_map == NOT_SET_P\n        ? parent->u_map : child->u_map);\n\n    /* Cache */\n    merged->cache_trans = (child->cache_trans == NOT_SET\n        ? parent->cache_trans : child->cache_trans);\n    merged->cache_trans_incremental = (child->cache_trans_incremental == NOT_SET\n        ? parent->cache_trans_incremental : child->cache_trans_incremental);\n    merged->cache_trans_min = (child->cache_trans_min == (apr_size_t)NOT_SET\n        ? parent->cache_trans_min : child->cache_trans_min);\n    merged->cache_trans_max = (child->cache_trans_max == (apr_size_t)NOT_SET\n        ? parent->cache_trans_max : child->cache_trans_max);\n    merged->cache_trans_maxitems = (child->cache_trans_maxitems == (apr_size_t)NOT_SET\n        ? parent->cache_trans_maxitems : child->cache_trans_maxitems);\n\n    /* Merge component signatures. */\n    merged->component_signatures = apr_array_append(mp, parent->component_signatures,\n        child->component_signatures);\n\n    merged->request_encoding = (child->request_encoding == NOT_SET_P\n        ? parent->request_encoding : child->request_encoding);\n\n    merged->disable_backend_compression = (child->disable_backend_compression == NOT_SET\n        ? parent->disable_backend_compression : child->disable_backend_compression);\n\n    merged->col_timeout = (child->col_timeout == NOT_SET\n        ? parent->col_timeout : child->col_timeout);\n\n    /* Hash */\n    merged->crypto_key = (child->crypto_key == NOT_SET_P\n        ? parent->crypto_key : child->crypto_key);\n    merged->crypto_key_len = (child->crypto_key_len == NOT_SET\n        ? parent->crypto_key_len : child->crypto_key_len);\n    merged->crypto_key_add = (child->crypto_key_add == NOT_SET\n        ? parent->crypto_key_add : child->crypto_key_add);\n    merged->crypto_param_name = (child->crypto_param_name == NOT_SET_P\n        ? parent->crypto_param_name : child->crypto_param_name);\n    merged->hash_is_enabled = (child->hash_is_enabled == NOT_SET\n        ? parent->hash_is_enabled : child->hash_is_enabled);\n    merged->hash_enforcement = (child->hash_enforcement == NOT_SET\n        ? parent->hash_enforcement : child->hash_enforcement);\n    merged->crypto_hash_href_rx = (child->crypto_hash_href_rx == NOT_SET\n        ? parent->crypto_hash_href_rx : child->crypto_hash_href_rx);\n    merged->crypto_hash_faction_rx = (child->crypto_hash_faction_rx == NOT_SET\n        ? parent->crypto_hash_faction_rx : child->crypto_hash_faction_rx);\n    merged->crypto_hash_location_rx = (child->crypto_hash_location_rx == NOT_SET\n        ? parent->crypto_hash_location_rx : child->crypto_hash_location_rx);\n    merged->crypto_hash_iframesrc_rx = (child->crypto_hash_iframesrc_rx == NOT_SET\n        ? parent->crypto_hash_iframesrc_rx : child->crypto_hash_iframesrc_rx);\n    merged->crypto_hash_framesrc_rx = (child->crypto_hash_framesrc_rx == NOT_SET\n        ? parent->crypto_hash_framesrc_rx : child->crypto_hash_framesrc_rx);\n    merged->crypto_hash_href_pm = (child->crypto_hash_href_pm == NOT_SET\n        ? parent->crypto_hash_href_pm : child->crypto_hash_href_pm);\n    merged->crypto_hash_faction_pm = (child->crypto_hash_faction_pm == NOT_SET\n        ? parent->crypto_hash_faction_pm : child->crypto_hash_faction_pm);\n    merged->crypto_hash_location_pm = (child->crypto_hash_location_pm == NOT_SET\n        ? parent->crypto_hash_location_pm : child->crypto_hash_location_pm);\n    merged->crypto_hash_iframesrc_pm = (child->crypto_hash_iframesrc_pm == NOT_SET\n        ? parent->crypto_hash_iframesrc_pm : child->crypto_hash_iframesrc_pm);\n    merged->crypto_hash_framesrc_pm = (child->crypto_hash_framesrc_pm == NOT_SET\n        ? parent->crypto_hash_framesrc_pm : child->crypto_hash_framesrc_pm);\n\n    /* xml external entity */\n    merged->xml_external_entity = (child->xml_external_entity == NOT_SET\n        ? parent->xml_external_entity : child->xml_external_entity);\n\n    return merged;\n}\n\n/**\n * Initialise directory configuration. This function is *not* meant\n * to be called for directory configuration instances created during\n * the configuration phase. It can only be called on copies of those\n * (created fresh for every transaction).\n */\nvoid init_directory_config(directory_config *dcfg)\n{\n    if (dcfg == NULL) return;\n\n    if (dcfg->is_enabled == NOT_SET) dcfg->is_enabled = 0;\n\n    if (dcfg->reqbody_access == NOT_SET) dcfg->reqbody_access = 0;\n    if (dcfg->reqintercept_oe == NOT_SET) dcfg->reqintercept_oe = 0;\n    if (dcfg->reqbody_buffering == NOT_SET) dcfg->reqbody_buffering = REQUEST_BODY_FORCEBUF_OFF;\n    if (dcfg->reqbody_inmemory_limit == NOT_SET)\n        dcfg->reqbody_inmemory_limit = REQUEST_BODY_DEFAULT_INMEMORY_LIMIT;\n    if (dcfg->reqbody_limit == NOT_SET) dcfg->reqbody_limit = REQUEST_BODY_DEFAULT_LIMIT;\n    if (dcfg->reqbody_no_files_limit == NOT_SET) dcfg->reqbody_no_files_limit = REQUEST_BODY_NO_FILES_DEFAULT_LIMIT;\n    if (dcfg->resbody_access == NOT_SET) dcfg->resbody_access = 0;\n    if (dcfg->of_limit == NOT_SET) dcfg->of_limit = RESPONSE_BODY_DEFAULT_LIMIT;\n    if (dcfg->if_limit_action == NOT_SET) dcfg->if_limit_action = REQUEST_BODY_LIMIT_ACTION_REJECT;\n    if (dcfg->of_limit_action == NOT_SET) dcfg->of_limit_action = RESPONSE_BODY_LIMIT_ACTION_REJECT;\n\n    if (dcfg->of_mime_types == NOT_SET_P) {\n        dcfg->of_mime_types = apr_table_make(dcfg->mp, 3);\n        if (dcfg->of_mime_types_cleared != 1) {\n            apr_table_setn(dcfg->of_mime_types, \"text/plain\", \"1\");\n            apr_table_setn(dcfg->of_mime_types, \"text/html\", \"1\");\n        }\n    }\n\n    if (dcfg->debuglog_fd == NOT_SET_P) dcfg->debuglog_fd = NULL;\n    if (dcfg->debuglog_name == NOT_SET_P) dcfg->debuglog_name = NULL;\n    if (dcfg->debuglog_level == NOT_SET) dcfg->debuglog_level = 0;\n\n    if (dcfg->cookie_format == NOT_SET) dcfg->cookie_format = 0;\n    if (dcfg->argument_separator == NOT_SET) dcfg->argument_separator = '&';\n    if (dcfg->cookiev0_separator == NOT_SET_P) dcfg->cookiev0_separator = NULL;\n\n    if (dcfg->rule_inheritance == NOT_SET) dcfg->rule_inheritance = 1;\n\n    /* audit log variables */\n    if (dcfg->auditlog_flag == NOT_SET) dcfg->auditlog_flag = 0;\n    if (dcfg->auditlog_type == NOT_SET) dcfg->auditlog_type = AUDITLOG_SERIAL;\n    if (dcfg->max_rule_time == NOT_SET) dcfg->max_rule_time = 0;\n    if (dcfg->auditlog_dirperms == NOT_SET) dcfg->auditlog_dirperms = CREATEMODE_DIR;\n    if (dcfg->auditlog_fileperms == NOT_SET) dcfg->auditlog_fileperms = CREATEMODE;\n    if (dcfg->auditlog_fd == NOT_SET_P) dcfg->auditlog_fd = NULL;\n    if (dcfg->auditlog2_fd == NOT_SET_P) dcfg->auditlog2_fd = NULL;\n    if (dcfg->auditlog_name == NOT_SET_P) dcfg->auditlog_name = NULL;\n    if (dcfg->auditlog2_name == NOT_SET_P) dcfg->auditlog2_name = NULL;\n    if (dcfg->auditlog_storage_dir == NOT_SET_P) dcfg->auditlog_storage_dir = NULL;\n    if (dcfg->auditlog_parts == NOT_SET_P) dcfg->auditlog_parts = \"ABCFHZ\";\n    if (dcfg->auditlog_relevant_regex == NOT_SET_P) dcfg->auditlog_relevant_regex = NULL;\n\n    /* Upload */\n    if (dcfg->tmp_dir == NOT_SET_P) dcfg->tmp_dir = guess_tmp_dir(dcfg->mp);\n    if (dcfg->upload_dir == NOT_SET_P) dcfg->upload_dir = NULL;\n    if (dcfg->upload_keep_files == NOT_SET) dcfg->upload_keep_files = KEEP_FILES_OFF;\n    if (dcfg->upload_validates_files == NOT_SET) dcfg->upload_validates_files = 0;\n    if (dcfg->upload_filemode == NOT_SET) dcfg->upload_filemode = 0600;\n    if (dcfg->upload_file_limit == NOT_SET) dcfg->upload_file_limit = 100;\n\n    /* Misc */\n    if (dcfg->data_dir == NOT_SET_P) dcfg->data_dir = NULL;\n    if (dcfg->webappid == NOT_SET_P) dcfg->webappid = \"default\";\n    if (dcfg->sensor_id == NOT_SET_P) dcfg->sensor_id = \"default\";\n    if (dcfg->httpBlkey == NOT_SET_P) dcfg->httpBlkey = NULL;\n\n    /* Content injection. */\n    if (dcfg->content_injection_enabled == NOT_SET) dcfg->content_injection_enabled = 0;\n\n    /* Stream inspection */\n    if (dcfg->stream_inbody_inspection == NOT_SET) dcfg->stream_inbody_inspection = 0;\n    if (dcfg->stream_outbody_inspection == NOT_SET) dcfg->stream_outbody_inspection = 0;\n\n    /* Geo Lookup */\n    if (dcfg->geo == NOT_SET_P) dcfg->geo = NULL;\n\n    /* Gsb Lookup */\n    if (dcfg->gsb == NOT_SET_P) dcfg->gsb = NULL;\n\n    /* Unicode Map */\n    if (dcfg->u_map == NOT_SET_P) dcfg->u_map = NULL;\n\n    /* Cache */\n    if (dcfg->cache_trans == NOT_SET) dcfg->cache_trans = MODSEC_CACHE_DISABLED;\n    if (dcfg->cache_trans_incremental == NOT_SET) dcfg->cache_trans_incremental = 0;\n    if (dcfg->cache_trans_min == (apr_size_t)NOT_SET) dcfg->cache_trans_min = 32;\n    if (dcfg->cache_trans_max == (apr_size_t)NOT_SET) dcfg->cache_trans_max = 1024;\n    if (dcfg->cache_trans_maxitems == (apr_size_t)NOT_SET) dcfg->cache_trans_maxitems = 512;\n\n    if (dcfg->request_encoding == NOT_SET_P) dcfg->request_encoding = NULL;\n\n    if (dcfg->disable_backend_compression == NOT_SET) dcfg->disable_backend_compression = 0;\n\n    if (dcfg->col_timeout == NOT_SET) dcfg->col_timeout = 3600;\n\n    /* Hash */\n    if (dcfg->crypto_key == NOT_SET_P) dcfg->crypto_key = getkey(dcfg->mp);\n    if (dcfg->crypto_key_len == NOT_SET) dcfg->crypto_key_len = strlen(dcfg->crypto_key);\n    if (dcfg->crypto_key_add == NOT_SET) dcfg->crypto_key_add = HASH_KEYONLY;\n    if (dcfg->crypto_param_name == NOT_SET_P) dcfg->crypto_param_name = \"crypt\";\n    if (dcfg->hash_is_enabled == NOT_SET) dcfg->hash_is_enabled = HASH_DISABLED;\n    if (dcfg->hash_enforcement == NOT_SET) dcfg->hash_enforcement = HASH_DISABLED;\n    if (dcfg->crypto_hash_href_rx == NOT_SET) dcfg->crypto_hash_href_rx = 0;\n    if (dcfg->crypto_hash_faction_rx == NOT_SET) dcfg->crypto_hash_faction_rx = 0;\n    if (dcfg->crypto_hash_location_rx == NOT_SET) dcfg->crypto_hash_location_rx = 0;\n    if (dcfg->crypto_hash_iframesrc_rx == NOT_SET) dcfg->crypto_hash_iframesrc_rx = 0;\n    if (dcfg->crypto_hash_framesrc_rx == NOT_SET) dcfg->crypto_hash_framesrc_rx = 0;\n    if (dcfg->crypto_hash_href_pm == NOT_SET) dcfg->crypto_hash_href_pm = 0;\n    if (dcfg->crypto_hash_faction_pm == NOT_SET) dcfg->crypto_hash_faction_pm = 0;\n    if (dcfg->crypto_hash_location_pm == NOT_SET) dcfg->crypto_hash_location_pm = 0;\n    if (dcfg->crypto_hash_iframesrc_pm == NOT_SET) dcfg->crypto_hash_iframesrc_pm = 0;\n    if (dcfg->crypto_hash_framesrc_pm == NOT_SET) dcfg->crypto_hash_framesrc_pm = 0;\n\n    /* xml external entity */\n    if (dcfg->xml_external_entity == NOT_SET) dcfg->xml_external_entity = 0;\n\n}\n\n/**\n *\n */\nstatic const char *add_rule(cmd_parms *cmd, directory_config *dcfg, int type,\n                            const char *p1, const char *p2, const char *p3)\n{\n    char *my_error_msg = NULL;\n    //msre_rule *rule = NULL, *tmp_rule = NULL;\n    char *rid = NULL;\n    msre_rule *rule = NULL;\n    extern msc_engine *modsecurity;\n    int offset = 0;\n\n    #ifdef DEBUG_CONF\n    ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, cmd->pool,\n        \"Rule: type=%d p1='%s' p2='%s' p3='%s'\", type, p1, p2, p3);\n    #endif\n\n    /* Create a ruleset if one does not exist. */\n    if ((dcfg->ruleset == NULL)||(dcfg->ruleset == NOT_SET_P)) {\n        dcfg->ruleset = msre_ruleset_create(modsecurity->msre, cmd->pool);\n        if (dcfg->ruleset == NULL) return FATAL_ERROR;\n    }\n\n    /* Create the rule now. */\n    switch(type) {\n        #if defined(WITH_LUA)\n        case RULE_TYPE_LUA :\n            rule = msre_rule_lua_create(dcfg->ruleset, cmd->directive->filename,\n                cmd->directive->line_num, p1, p2, &my_error_msg);\n            break;\n        #endif\n        default :\n            rule = msre_rule_create(dcfg->ruleset, type, cmd->directive->filename,\n                cmd->directive->line_num, p1, p2, p3, &my_error_msg);\n            break;\n    }\n\n    if (rule == NULL) {\n        return my_error_msg;\n    }\n\n    /* Rules must have uniq ID */\n    if (\n#if defined(WITH_LUA)\n            type != RULE_TYPE_LUA &&\n#endif\n            (dcfg->tmp_chain_starter == NULL))\n                if(rule->actionset == NULL)\n                    return \"ModSecurity: Rules must have at least id action\";\n\n    if(rule->actionset != NULL && (dcfg->tmp_chain_starter == NULL))    {\n        if(rule->actionset->id == NOT_SET_P\n#if defined(WITH_LUA)\n            && (type != RULE_TYPE_LUA)\n#endif\n          )\n            return \"ModSecurity: No action id present within the rule\";\n#if defined(WITH_LUA)\n        if(type != RULE_TYPE_LUA)\n#endif\n        {\n            rid = apr_hash_get(dcfg->rule_id_htab, rule->actionset->id, APR_HASH_KEY_STRING);\n            if(rid != NULL) {\n                return \"ModSecurity: Found another rule with the same id\";\n            } else    {\n                apr_hash_set(dcfg->rule_id_htab, apr_pstrdup(dcfg->mp, rule->actionset->id), APR_HASH_KEY_STRING, apr_pstrdup(dcfg->mp, \"1\"));\n            }\n\n            //tmp_rule = msre_ruleset_fetch_rule(dcfg->ruleset, rule->actionset->id, offset);\n            //if(tmp_rule != NULL)\n            //    return \"ModSecurity: Found another rule with the same id\";\n        }\n    }\n\n    /* Create default actionset if one does not already exist. */\n    if (dcfg->tmp_default_actionset == NULL) {\n        dcfg->tmp_default_actionset = msre_actionset_create_default(modsecurity->msre);\n        if (dcfg->tmp_default_actionset == NULL) return FATAL_ERROR;\n    }\n\n    /* Check some cases prior to merging so we know where it came from */\n\n    /* Check syntax for chained rules */\n    if ((rule->actionset != NULL) && (dcfg->tmp_chain_starter != NULL)) {\n        /* Must NOT specify a disruptive action. */\n        if (rule->actionset->intercept_action != NOT_SET) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: Disruptive actions can only \"\n                \"be specified by chain starter rules.\");\n        }\n\n        /* Must NOT specify a skipafter action. */\n        if (rule->actionset->skip_after != NOT_SET_P) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: SkipAfter actions can only \"\n                \"be specified by chain starter rules.\");\n        }\n\n        /* Must NOT specify a phase. */\n        if (rule->actionset->phase != NOT_SET) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: Execution phases can only be \"\n                \"specified by chain starter rules.\");\n        }\n\n        /* Must NOT use metadata actions. */\n        /* ENH: loop through to check for tags */\n        if ((rule->actionset->id != NOT_SET_P)\n            ||(rule->actionset->rev != NOT_SET_P)\n            ||(rule->actionset->msg != NOT_SET_P)\n            ||(rule->actionset->severity != NOT_SET)\n            ||(rule->actionset->version != NOT_SET_P)\n            ||(rule->actionset->accuracy != NOT_SET)\n            ||(rule->actionset->maturity != NOT_SET)\n            ||(rule->actionset->logdata != NOT_SET_P))\n        {\n            return apr_psprintf(cmd->pool, \"ModSecurity: Metadata actions (id, rev, msg, tag, severity, ver, accuracy, maturity, logdata) \"\n                \" can only be specified by chain starter rules.\");\n        }\n\n        /* Must NOT use skip. */\n        if (rule->actionset->skip_count != NOT_SET) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: The skip action can only be used \"\n                \" by chain starter rules. \");\n        }\n    }\n\n    /* Merge actions with the parent.\n     *\n     * ENH Probably do not want this done fully for chained rules.\n     */\n    rule->actionset = msre_actionset_merge(modsecurity->msre, dcfg->tmp_default_actionset,\n        rule->actionset, 1);\n\n    /* Keep track of the parent action for \"block\" */\n    rule->actionset->parent_intercept_action_rec = dcfg->tmp_default_actionset->intercept_action_rec;\n    rule->actionset->parent_intercept_action = dcfg->tmp_default_actionset->intercept_action;\n\n    /* Must NOT specify a disruptive action in logging phase. */\n    if ((rule->actionset != NULL)\n        && (rule->actionset->phase == PHASE_LOGGING)\n        && (rule->actionset->intercept_action != ACTION_ALLOW)\n        && (rule->actionset->intercept_action != ACTION_ALLOW_REQUEST)\n        && (rule->actionset->intercept_action != ACTION_NONE)\n    ) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Disruptive actions \"\n            \"cannot be specified in the logging phase.\");\n    }\n\n    if (dcfg->tmp_chain_starter != NULL) {\n        rule->chain_starter = dcfg->tmp_chain_starter;\n        rule->actionset->phase = rule->chain_starter->actionset->phase;\n    }\n\n    if (rule->actionset->is_chained != 1) {\n        /* If this rule is part of the chain but does\n         * not want more rules to follow in the chain\n         * then cut it (the chain).\n         */\n        dcfg->tmp_chain_starter = NULL;\n    } else {\n        /* On the other hand, if this rule wants other\n         * rules to follow it, then start a new chain\n         * if there isn't one already.\n         */\n        if (dcfg->tmp_chain_starter == NULL) {\n            dcfg->tmp_chain_starter = rule;\n        }\n    }\n\n    /* Optimisation */\n    if ((rule->op_name != NULL)&&(strcasecmp(rule->op_name, \"inspectFile\") == 0)) {\n        dcfg->upload_validates_files = 1;\n    }\n\n    /* Create skip table if one does not already exist. */\n    if (dcfg->tmp_rule_placeholders == NULL) {\n        dcfg->tmp_rule_placeholders = apr_table_make(cmd->pool, 10);\n        if (dcfg->tmp_rule_placeholders == NULL) return FATAL_ERROR;\n    }\n\n    /* Keep track of any rule IDs we need to skip after */\n    if (rule->actionset->skip_after != NOT_SET_P) {\n        char *tmp_id = apr_pstrdup(cmd->pool, rule->actionset->skip_after);\n        apr_table_setn(dcfg->tmp_rule_placeholders, tmp_id, tmp_id);\n\n        #ifdef DEBUG_CONF\n        ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, cmd->pool,\n            \"Watching for skipafter target rule id=\\\"%s\\\".\", tmp_id);\n        #endif\n\n    }\n\n    #ifdef DEBUG_CONF\n    ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, cmd->pool,\n        \"Adding rule %pp phase=%d id=\\\"%s\\\".\", rule, rule->actionset->phase, (rule->actionset->id == NOT_SET_P\n        ? \"(none)\" : rule->actionset->id));\n    #endif\n\n    /* Add rule to the recipe. */\n    if (msre_ruleset_rule_add(dcfg->ruleset, rule, rule->actionset->phase) < 0) {\n        return \"Internal Error: Failed to add rule to the ruleset.\";\n    }\n\n    /* Add an additional placeholder if this rule ID is on the list */\n    if ((rule->actionset->id != NULL) && apr_table_get(dcfg->tmp_rule_placeholders, rule->actionset->id)) {\n        msre_rule *phrule = apr_palloc(rule->ruleset->mp, sizeof(msre_rule));\n        if (phrule == NULL) {\n            return FATAL_ERROR;\n        }\n\n        #ifdef DEBUG_CONF\n        ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, cmd->pool,\n            \"Adding placeholder %pp for rule %pp id=\\\"%s\\\".\", phrule, rule, rule->actionset->id);\n        #endif\n\n        /* shallow copy of original rule with placeholder marked as target */\n        memcpy(phrule, rule, sizeof(msre_rule));\n        phrule->placeholder = RULE_PH_SKIPAFTER;\n\n        /* Add placeholder. */\n        if (msre_ruleset_rule_add(dcfg->ruleset, phrule, phrule->actionset->phase) < 0) {\n            return \"Internal Error: Failed to add placeholder to the ruleset.\";\n        }\n\n        /* No longer need to search for the ID */\n        apr_table_unset(dcfg->tmp_rule_placeholders, rule->actionset->id);\n    }\n\n    /* Update the unparsed rule */\n    rule->unparsed = msre_rule_generate_unparsed(dcfg->ruleset->mp, rule, NULL, NULL, NULL);\n\n    return NULL;\n}\n\n/**\n *\n */\nstatic const char *add_marker(cmd_parms *cmd, directory_config *dcfg,\n                              const char *p1, const char *p2, const char *p3)\n{\n    char *my_error_msg = NULL;\n    msre_rule *rule = NULL;\n    extern msc_engine *modsecurity;\n    int p;\n\n    #ifdef DEBUG_CONF\n    ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, cmd->pool,\n        \"Rule: type=%d p1='%s' p2='%s' p3='%s'\", RULE_TYPE_MARKER, p1, p2, p3);\n    #endif\n\n    /* Create a ruleset if one does not exist. */\n    if ((dcfg->ruleset == NULL)||(dcfg->ruleset == NOT_SET_P)) {\n        dcfg->ruleset = msre_ruleset_create(modsecurity->msre, cmd->pool);\n        if (dcfg->ruleset == NULL) return FATAL_ERROR;\n    }\n\n    /* Create the rule now. */\n    rule = msre_rule_create(dcfg->ruleset, RULE_TYPE_MARKER, cmd->directive->filename, cmd->directive->line_num, p1, p2, p3, &my_error_msg);\n    if (rule == NULL) {\n        return my_error_msg;\n    }\n\n    /* This is a marker */\n    rule->placeholder = RULE_PH_MARKER;\n\n    /* Add placeholder to each phase */\n    for (p = PHASE_FIRST; p <= PHASE_LAST; p++) {\n        #ifdef DEBUG_CONF\n        ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, cmd->pool,\n            \"Adding marker %pp phase=%d id=\\\"%s\\\".\", rule, p, (rule->actionset->id == NOT_SET_P\n            ? \"(none)\" : rule->actionset->id));\n        #endif\n\n        if (msre_ruleset_rule_add(dcfg->ruleset, rule, p) < 0) {\n            return \"Internal Error: Failed to add marker to the ruleset.\";\n        }\n    }\n\n    /* No longer need to search for the ID */\n    if (dcfg->tmp_rule_placeholders != NULL) {\n        apr_table_unset(dcfg->tmp_rule_placeholders, rule->actionset->id);\n    }\n\n    return NULL;\n}\n\n/**\n *\n */\nstatic const char *update_rule_action(cmd_parms *cmd, directory_config *dcfg,\n                                      const char *p1, const char *p2, int offset)\n{\n    char *my_error_msg = NULL;\n    msre_rule *rule = NULL;\n    msre_actionset *new_actionset = NULL;\n    msre_ruleset *ruleset = dcfg->ruleset;\n    extern msc_engine *modsecurity;\n\n    /* Get the ruleset if one exists */\n    if ((ruleset == NULL)||(ruleset == NOT_SET_P)) {\n        return NULL;\n    }\n\n    #ifdef DEBUG_CONF\n    ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, cmd->pool,\n        \"Update rule id=\\\"%s\\\" with action \\\"%s\\\".\", p1, p2);\n    #endif\n\n    /* Fetch the rule */\n    rule = msre_ruleset_fetch_rule(ruleset, p1, offset);\n    if (rule == NULL) {\n        #ifdef DEBUG_CONF\n        ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, cmd->pool,\n            \"Update rule id=\\\"%s\\\" with action \\\"%s\\\" failed: Rule not found.\", p1, p2);\n        #endif\n        return NULL;\n    }\n\n    /* Check the rule actionset */\n    /* ENH: Can this happen? */\n    if (rule->actionset == NULL) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Attempt to update action for rule \\\"%s\\\" failed: Rule does not have an actionset.\", p1);\n    }\n\n    /* Create a new actionset */\n    new_actionset = msre_actionset_create(modsecurity->msre, p2, &my_error_msg);\n    if (new_actionset == NULL) return FATAL_ERROR;\n    if (my_error_msg != NULL) return my_error_msg;\n\n    /* Must NOT change an id */\n    if ((new_actionset->id != NOT_SET_P) && (rule->actionset->id != NULL) && (strcmp(rule->actionset->id, new_actionset->id) != 0)) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Rule IDs cannot be updated via SecRuleUpdateActionById.\");\n    }\n\n    /* Must NOT alter the phase */\n    if ((new_actionset->phase != NOT_SET) && (rule->actionset->phase != new_actionset->phase)) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Rule phases cannot be updated via SecRuleUpdateActionById.\");\n    }\n\n    #ifdef DEBUG_CONF\n    {\n        char *actions = msre_actionset_generate_action_string(ruleset->mp, rule->actionset);\n        ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, cmd->pool,\n            \"Update rule %pp id=\\\"%s\\\" old action: \\\"%s\\\"\",\n            rule,\n            (rule->actionset->id == NOT_SET_P ? \"(none)\" : rule->actionset->id),\n            actions);\n    }\n    #endif\n\n    /* Merge new actions with the rule */\n    /* ENH: Will this leak the old actionset? */\n    rule->actionset = msre_actionset_merge(modsecurity->msre, rule->actionset,\n        new_actionset, 1);\n    msre_actionset_set_defaults(rule->actionset);\n\n    /* Update the unparsed rule */\n    rule->unparsed = msre_rule_generate_unparsed(ruleset->mp, rule, NULL, NULL, NULL);\n\n    #ifdef DEBUG_CONF\n    {\n        char *actions = msre_actionset_generate_action_string(ruleset->mp, rule->actionset);\n        ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, cmd->pool,\n            \"Update rule %pp id=\\\"%s\\\" new action: \\\"%s\\\"\",\n            rule,\n            (rule->actionset->id == NOT_SET_P ? \"(none)\" : rule->actionset->id),\n            actions);\n    }\n    #endif\n\n    return NULL;\n}\n\n/* -- Configuration directives -- */\n\nstatic const char *cmd_action(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    return add_rule(cmd, (directory_config *)_dcfg, RULE_TYPE_ACTION, SECACTION_TARGETS, SECACTION_ARGS, p1);\n}\n\nstatic const char *cmd_marker(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    const char *action = apr_pstrcat(dcfg->mp, SECMARKER_BASE_ACTIONS, p1, NULL);\n    return add_marker(cmd, (directory_config *)_dcfg, SECMARKER_TARGETS, SECMARKER_ARGS, action);\n}\n\nstatic const char *cmd_cookiev0_separator(cmd_parms *cmd, void *_dcfg,\n        const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n\n    if (strlen(p1) != 1) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Invalid cookie v0 separator: %s\", p1);\n    }\n\n    dcfg->cookiev0_separator = p1;\n\n    return NULL;\n}\n\nstatic const char *cmd_argument_separator(cmd_parms *cmd, void *_dcfg,\n        const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n\n    if (strlen(p1) != 1) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Invalid argument separator: %s\", p1);\n    }\n\n    dcfg->argument_separator = p1[0];\n\n    return NULL;\n}\n\nstatic const char *cmd_audit_engine(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    directory_config *dcfg = _dcfg;\n\n    if (strcasecmp(p1, \"On\") == 0) dcfg->auditlog_flag = AUDITLOG_ON;\n    else\n        if (strcasecmp(p1, \"Off\") == 0) dcfg->auditlog_flag = AUDITLOG_OFF;\n        else\n            if (strcasecmp(p1, \"RelevantOnly\") == 0) dcfg->auditlog_flag = AUDITLOG_RELEVANT;\n            else\n                return (const char *)apr_psprintf(cmd->pool,\n                        \"ModSecurity: Unrecognised parameter value for SecAuditEngine: %s\", p1);\n\n    return NULL;\n}\n\nstatic const char *cmd_audit_log(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    directory_config *dcfg = _dcfg;\n\n    dcfg->auditlog_name = (char *)p1;\n\n    if (dcfg->auditlog_name[0] == '|') {\n        const char *pipe_name = dcfg->auditlog_name + 1;\n        piped_log *pipe_log;\n\n        pipe_log = ap_open_piped_log(cmd->pool, pipe_name);\n        if (pipe_log == NULL) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: Failed to open the audit log pipe: %s\",\n                    pipe_name);\n        }\n        dcfg->auditlog_fd = ap_piped_log_write_fd(pipe_log);\n    }\n    else {\n        const char *file_name = ap_server_root_relative(cmd->pool, dcfg->auditlog_name);\n        apr_status_t rc;\n\n        rc = apr_file_open(&dcfg->auditlog_fd, file_name,\n                APR_WRITE | APR_APPEND | APR_CREATE | APR_BINARY,\n                CREATEMODE, cmd->pool);\n\n        if (rc != APR_SUCCESS) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: Failed to open the audit log file: %s\",\n                    file_name);\n        }\n    }\n\n    return NULL;\n}\n\nstatic const char *cmd_audit_log2(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    directory_config *dcfg = _dcfg;\n\n    if (dcfg->auditlog_name == NOT_SET_P) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Cannot configure a secondary audit log without a primary defined: %s\", p1);\n    }\n\n    dcfg->auditlog2_name = (char *)p1;\n\n    if (dcfg->auditlog2_name[0] == '|') {\n        const char *pipe_name = ap_server_root_relative(cmd->pool, dcfg->auditlog2_name + 1);\n        piped_log *pipe_log;\n\n        pipe_log = ap_open_piped_log(cmd->pool, pipe_name);\n        if (pipe_log == NULL) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: Failed to open the secondary audit log pipe: %s\",\n                    pipe_name);\n        }\n        dcfg->auditlog2_fd = ap_piped_log_write_fd(pipe_log);\n    }\n    else {\n        const char *file_name = ap_server_root_relative(cmd->pool, dcfg->auditlog2_name);\n        apr_status_t rc;\n\n        rc = apr_file_open(&dcfg->auditlog2_fd, file_name,\n                APR_WRITE | APR_APPEND | APR_CREATE | APR_BINARY,\n                CREATEMODE, cmd->pool);\n\n        if (rc != APR_SUCCESS) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: Failed to open the secondary audit log file: %s\",\n                    file_name);\n        }\n    }\n\n    return NULL;\n}\n\nstatic const char *cmd_audit_log_parts(cmd_parms *cmd, void *_dcfg,\n        const char *p1)\n{\n    directory_config *dcfg = _dcfg;\n\n    if (is_valid_parts_specification((char *)p1) != 1) {\n        return apr_psprintf(cmd->pool, \"Invalid parts specification for SecAuditLogParts: %s\", p1);\n    }\n\n    dcfg->auditlog_parts = (char *)p1;\n    return NULL;\n}\n\nstatic const char *cmd_audit_log_relevant_status(cmd_parms *cmd, void *_dcfg,\n        const char *p1)\n{\n    directory_config *dcfg = _dcfg;\n\n    dcfg->auditlog_relevant_regex = msc_pregcomp(cmd->pool, p1, PCRE_DOTALL, NULL, NULL);\n    if (dcfg->auditlog_relevant_regex == NULL) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Invalid regular expression: %s\", p1);\n    }\n\n    return NULL;\n}\n\nstatic const char *cmd_audit_log_type(cmd_parms *cmd, void *_dcfg,\n        const char *p1)\n{\n    directory_config *dcfg = _dcfg;\n\n    if (strcasecmp(p1, \"Serial\") == 0) dcfg->auditlog_type = AUDITLOG_SERIAL;\n    else\n        if (strcasecmp(p1, \"Concurrent\") == 0) dcfg->auditlog_type = AUDITLOG_CONCURRENT;\n        else\n            return (const char *)apr_psprintf(cmd->pool,\n                    \"ModSecurity: Unrecognised parameter value for SecAuditLogType: %s\", p1);\n\n    return NULL;\n}\n\nstatic const char *cmd_audit_log_dirmode(cmd_parms *cmd, void *_dcfg,\n        const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n\n    if (dcfg == NULL) return NULL;\n\n    if (strcasecmp(p1, \"default\") == 0) {\n        dcfg->auditlog_dirperms = NOT_SET;\n    }\n    else {\n        long int mode = strtol(p1, NULL, 8); /* expects octal mode */\n        if ((mode == LONG_MAX)||(mode == LONG_MIN)||(mode <= 0)||(mode > 07777)) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecAuditLogDirMode: %s\", p1);\n        }\n\n        dcfg->auditlog_dirperms = mode2fileperms(mode);\n    }\n\n    return NULL;\n}\n\nstatic const char *cmd_audit_log_filemode(cmd_parms *cmd, void *_dcfg,\n        const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n\n    if (dcfg == NULL) return NULL;\n\n    if (strcasecmp(p1, \"default\") == 0) {\n        dcfg->auditlog_fileperms = NOT_SET;\n    }\n    else {\n        long int mode = strtol(p1, NULL, 8); /* expects octal mode */\n        if ((mode == LONG_MAX)||(mode == LONG_MIN)||(mode <= 0)||(mode > 07777)) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecAuditLogFileMode: %s\", p1);\n        }\n\n        dcfg->auditlog_fileperms = mode2fileperms(mode);\n    }\n\n    return NULL;\n}\n\nstatic const char *cmd_audit_log_storage_dir(cmd_parms *cmd, void *_dcfg,\n                                             const char *p1)\n{\n    directory_config *dcfg = _dcfg;\n\n    dcfg->auditlog_storage_dir = ap_server_root_relative(cmd->pool, p1);\n\n    return NULL;\n}\n\nstatic const char *cmd_cookie_format(cmd_parms *cmd, void *_dcfg,\n                                     const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n\n    if (strcmp(p1, \"0\") == 0) dcfg->cookie_format = COOKIES_V0;\n    else\n    if (strcmp(p1, \"1\") == 0) dcfg->cookie_format = COOKIES_V1;\n    else {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Invalid cookie format: %s\", p1);\n    }\n\n    return NULL;\n}\n\nstatic const char *cmd_chroot_dir(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    char cwd[1025] = \"\";\n\n    if (cmd->server->is_virtual) {\n        return \"ModSecurity: SecChrootDir not allowed in VirtualHost\";\n    }\n\n    chroot_dir = (char *)p1;\n\n    if (getcwd(cwd, 1024) == NULL) {\n        return \"ModSecurity: Failed to get the current working directory\";\n    }\n\n    if (chdir(chroot_dir) < 0) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Failed to chdir to %s, errno=%d (%s)\",\n            chroot_dir, errno, strerror(errno));\n    }\n\n    if (chdir(cwd) < 0) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Failed to chdir to %s, errno=%d (%s)\",\n            cwd, errno, strerror(errno));\n    }\n\n    return NULL;\n}\n\n/**\n * Adds component signature to the list of signatures kept in configuration.\n */\nstatic const char *cmd_component_signature(cmd_parms *cmd, void *_dcfg,\n                                           const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n\n    /* ENH Enforce \"Name/VersionX.Y.Z (comment)\" format. */\n    *(char **)apr_array_push(dcfg->component_signatures) = (char *)p1;\n\n    return NULL;\n}\n\nstatic const char *cmd_content_injection(cmd_parms *cmd, void *_dcfg, int flag)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n    dcfg->content_injection_enabled = flag;\n    return NULL;\n}\n\nstatic const char *cmd_data_dir(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n\n    if (cmd->server->is_virtual) {\n        return \"ModSecurity: SecDataDir not allowed in VirtualHost.\";\n    }\n\n    dcfg->data_dir = ap_server_root_relative(cmd->pool, p1);\n\n    return NULL;\n}\n\nstatic const char *cmd_debug_log(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    apr_status_t rc;\n\n    dcfg->debuglog_name = ap_server_root_relative(cmd->pool, p1);\n\n    rc = apr_file_open(&dcfg->debuglog_fd, dcfg->debuglog_name,\n                   APR_WRITE | APR_APPEND | APR_CREATE | APR_BINARY,\n                   CREATEMODE, cmd->pool);\n\n    if (rc != APR_SUCCESS) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Failed to open debug log file: %s\",\n            dcfg->debuglog_name);\n    }\n\n    return NULL;\n}\n\n/**\n* \\brief Add SecCollectionTimeout configuration option\n*\n* \\param cmd Pointer to configuration data\n* \\param _dcfg Pointer to directory configuration\n* \\param p1 Pointer to configuration option\n*\n* \\retval NULL On failure\n* \\retval apr_psprintf On Success\n*/\nstatic const char *cmd_collection_timeout(cmd_parms *cmd, void *_dcfg,\n                                       const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n\n    dcfg->col_timeout = atoi(p1);\n    /* max 30 days */\n    if ((dcfg->col_timeout >= 0)&&(dcfg->col_timeout <= 2592000)) return NULL;\n\n    return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecCollectionTimeout: %s\", p1);\n}\n\nstatic const char *cmd_debug_log_level(cmd_parms *cmd, void *_dcfg,\n                                       const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n\n    dcfg->debuglog_level = atoi(p1);\n    if ((dcfg->debuglog_level >= 0)&&(dcfg->debuglog_level <= 9)) return NULL;\n\n    return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecDebugLogLevel: %s\", p1);\n}\n\nstatic const char *cmd_default_action(cmd_parms *cmd, void *_dcfg,\n                                      const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    extern msc_engine *modsecurity;\n    char *my_error_msg = NULL;\n\n    dcfg->tmp_default_actionset = msre_actionset_create(modsecurity->msre, p1, &my_error_msg);\n    if (dcfg->tmp_default_actionset == NULL) {\n        if (my_error_msg != NULL) return my_error_msg;\n        else return FATAL_ERROR;\n    }\n\n    /* Must specify a disruptive action. */\n    /* ENH: Remove this requirement? */\n    if (dcfg->tmp_default_actionset->intercept_action == NOT_SET) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: SecDefaultAction must specify a disruptive action.\");\n    }\n\n    /* Must specify a phase. */\n    /* ENH: Remove this requirement? */\n    if (dcfg->tmp_default_actionset->phase == NOT_SET) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: SecDefaultAction must specify a phase.\");\n    }\n\n    /* Must not use metadata actions. */\n    /* ENH: loop through to check for tags */\n    if ((dcfg->tmp_default_actionset->id != NOT_SET_P)\n        ||(dcfg->tmp_default_actionset->rev != NOT_SET_P)\n        ||(dcfg->tmp_default_actionset->version != NOT_SET_P)\n        ||(dcfg->tmp_default_actionset->maturity != NOT_SET)\n        ||(dcfg->tmp_default_actionset->accuracy != NOT_SET)\n        ||(dcfg->tmp_default_actionset->msg != NOT_SET_P))\n    {\n        return apr_psprintf(cmd->pool, \"ModSecurity: SecDefaultAction must not \"\n            \"contain any metadata actions (id, rev, msg, tag, severity, ver, accuracy, maturity, logdata).\");\n    }\n    /* These are just a warning for now. */\n    if ((dcfg->tmp_default_actionset->severity != NOT_SET)\n        ||(dcfg->tmp_default_actionset->logdata != NOT_SET_P))\n    {\n        ap_log_perror(APLOG_MARK,\n            APLOG_STARTUP|APLOG_WARNING|APLOG_NOERRNO, 0, cmd->pool,\n            \"ModSecurity: WARNING Using \\\"severity\\\" or \\\"logdata\\\" in \"\n            \"SecDefaultAction is deprecated (%s:%d).\",\n            cmd->directive->filename, cmd->directive->line_num);\n    }\n\n    if (apr_table_get(dcfg->tmp_default_actionset->actions, \"t\")) {\n        ap_log_perror(APLOG_MARK,\n            APLOG_STARTUP|APLOG_WARNING|APLOG_NOERRNO, 0, cmd->pool,\n            \"ModSecurity: WARNING Using transformations in \"\n            \"SecDefaultAction is deprecated (%s:%d).\",\n            cmd->directive->filename, cmd->directive->line_num);\n    }\n\n    /* Must not use chain. */\n    if (dcfg->tmp_default_actionset->is_chained != NOT_SET) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: SecDefaultAction must not \"\n            \"contain a chain action.\");\n    }\n\n    /* Must not use skip. */\n    if (dcfg->tmp_default_actionset->skip_count != NOT_SET) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: SecDefaultAction must not \"\n            \"contain a skip action.\");\n    }\n\n    /* Must not use skipAfter. */\n    if (dcfg->tmp_default_actionset->skip_after != NOT_SET_P) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: SecDefaultAction must not \"\n            \"contain a skipAfter action.\");\n    }\n\n    return NULL;\n}\n\nstatic const char *cmd_disable_backend_compression(cmd_parms *cmd, void *_dcfg, int flag)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n    dcfg->disable_backend_compression = flag;\n    return NULL;\n}\n\nstatic const char *cmd_guardian_log(cmd_parms *cmd, void *_dcfg,\n                                    const char *p1, const char *p2)\n{\n    extern char *guardianlog_name;\n    extern apr_file_t *guardianlog_fd;\n    extern char *guardianlog_condition;\n\n    if (cmd->server->is_virtual) {\n        return \"ModSecurity: SecGuardianLog not allowed in VirtualHost\";\n    }\n\n    if (p2 != NULL) {\n        if (strncmp(p2, \"env=\", 4) != 0) {\n            return \"ModSecurity: Error in condition clause\";\n        }\n        if ( (p2[4] == '\\0') || ((p2[4] == '!')&&(p2[5] == '\\0')) ) {\n            return \"ModSecurity: Missing variable name\";\n        }\n        guardianlog_condition = apr_pstrdup(cmd->pool, p2 + 4);\n    }\n\n    guardianlog_name = (char *)p1;\n\n    if (guardianlog_name[0] == '|') {\n        const char *pipe_name = ap_server_root_relative(cmd->pool, guardianlog_name + 1);\n        piped_log *pipe_log;\n\n        pipe_log = ap_open_piped_log(cmd->pool, pipe_name);\n        if (pipe_log == NULL) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: Failed to open the guardian log pipe: %s\",\n                pipe_name);\n        }\n        guardianlog_fd = ap_piped_log_write_fd(pipe_log);\n    }\n    else {\n        const char *file_name = ap_server_root_relative(cmd->pool, guardianlog_name);\n        apr_status_t rc;\n\n        rc = apr_file_open(&guardianlog_fd, file_name,\n            APR_WRITE | APR_APPEND | APR_CREATE | APR_BINARY,\n            CREATEMODE, cmd->pool);\n\n        if (rc != APR_SUCCESS) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: Failed to open the guardian log file: %s\",\n                file_name);\n        }\n    }\n\n    return NULL;\n}\n\n/**\n* \\brief Add SecStreamInBodyInspection configuration option\n*\n* \\param cmd Pointer to configuration data\n* \\param _dcfg Pointer to directory configuration\n* \\param p1 Pointer to configuration option\n*\n* \\retval NULL On failure\n* \\retval apr_psprintf On Success\n*/\nstatic const char *cmd_stream_inbody_inspection(cmd_parms *cmd, void *_dcfg, int flag)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n    dcfg->stream_inbody_inspection = flag;\n    return NULL;\n}\n\n\n/**\n* \\brief Add SecStreamOutBodyInspection configuration option\n*\n* \\param cmd Pointer to configuration data\n* \\param _dcfg Pointer to directory configuration\n* \\param p1 Pointer to configuration option\n*\n* \\retval NULL On failure\n* \\retval apr_psprintf On Success\n*/\nstatic const char *cmd_stream_outbody_inspection(cmd_parms *cmd, void *_dcfg, int flag)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n    dcfg->stream_outbody_inspection = flag;\n    return NULL;\n}\n/**\n* \\brief Add SecRulePerfTime configuration option\n*\n* \\param cmd Pointer to configuration data\n* \\param _dcfg Pointer to directory configuration\n* \\param p1 Pointer to configuration option\n*\n* \\retval NULL On failure\n* \\retval apr_psprintf On Success\n*/\nstatic const char *cmd_rule_perf_time(cmd_parms *cmd, void *_dcfg,\n        const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    long int limit;\n\n    if (dcfg == NULL) return NULL;\n\n    limit = strtol(p1, NULL, 10);\n    if ((limit == LONG_MAX)||(limit == LONG_MIN)||(limit <= 0)) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecRulePerfTime: %s\", p1);\n    }\n\n    dcfg->max_rule_time = limit;\n\n    return NULL;\n}\n\n/**\n* \\brief Add SecReadStateLimit configuration option\n*\n* \\param cmd Pointer to configuration data\n* \\param _dcfg Pointer to directory configuration\n* \\param p1 Pointer to configuration option\n*\n* \\retval NULL On failure\n* \\retval apr_psprintf On Success\n*/\nstatic const char *cmd_conn_read_state_limit(cmd_parms *cmd, void *_dcfg,\n        const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    long int limit;\n\n    if (dcfg == NULL) return NULL;\n\n    limit = strtol(p1, NULL, 10);\n    if ((limit == LONG_MAX)||(limit == LONG_MIN)||(limit <= 0)) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecReadStateLimit: %s\", p1);\n    }\n\n    conn_read_state_limit = limit;\n\n    return NULL;\n}\n\n/**\n* \\brief Add SecWriteStateLimit configuration option\n*\n* \\param cmd Pointer to configuration data\n* \\param _dcfg Pointer to directory configuration\n* \\param p1 Pointer to configuration option\n*\n* \\retval NULL On failure\n* \\retval apr_psprintf On Success\n*/\nstatic const char *cmd_conn_write_state_limit(cmd_parms *cmd, void *_dcfg,\n        const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    long int limit;\n\n    if (dcfg == NULL) return NULL;\n\n    limit = strtol(p1, NULL, 10);\n    if ((limit == LONG_MAX)||(limit == LONG_MIN)||(limit <= 0)) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecWriteStateLimit: %s\", p1);\n    }\n\n    conn_write_state_limit = limit;\n\n    return NULL;\n}\n\n\nstatic const char *cmd_request_body_inmemory_limit(cmd_parms *cmd, void *_dcfg,\n                                                   const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    long int limit;\n\n    if (dcfg == NULL) return NULL;\n\n    limit = strtol(p1, NULL, 10);\n    if ((limit == LONG_MAX)||(limit == LONG_MIN)||(limit <= 0)) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecRequestBodyInMemoryLimit: %s\", p1);\n    }\n\n    dcfg->reqbody_inmemory_limit = limit;\n\n    return NULL;\n}\n\nstatic const char *cmd_request_body_limit(cmd_parms *cmd, void *_dcfg,\n                                          const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    long int limit;\n\n    if (dcfg == NULL) return NULL;\n\n    limit = strtol(p1, NULL, 10);\n    if ((limit == LONG_MAX)||(limit == LONG_MIN)||(limit <= 0)) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecRequestBodyLimit: %s\", p1);\n    }\n\n    dcfg->reqbody_limit = limit;\n\n    return NULL;\n}\n\nstatic const char *cmd_request_body_no_files_limit(cmd_parms *cmd, void *_dcfg,\n                                                   const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    long int limit;\n\n    if (dcfg == NULL) return NULL;\n\n    limit = strtol(p1, NULL, 10);\n    if ((limit == LONG_MAX)||(limit == LONG_MIN)||(limit <= 0)) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecRequestBodyNoFilesLimit: %s\", p1);\n    }\n\n    dcfg->reqbody_no_files_limit = limit;\n\n    return NULL;\n}\n\nstatic const char *cmd_request_body_access(cmd_parms *cmd, void *_dcfg,\n                                           const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n\n    if (strcasecmp(p1, \"on\") == 0) dcfg->reqbody_access = 1;\n    else\n    if (strcasecmp(p1, \"off\") == 0) dcfg->reqbody_access = 0;\n    else\n    return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecRequestBodyAccess: %s\", p1);\n\n    return NULL;\n}\n\n/**\n* \\brief Add SecInterceptOnError configuration option\n*\n* \\param cmd Pointer to configuration data\n* \\param _dcfg Pointer to directory configuration\n* \\param p1 Pointer to configuration option\n*\n* \\retval NULL On failure\n* \\retval apr_psprintf On success\n*/\nstatic const char *cmd_request_intercept_on_error(cmd_parms *cmd, void *_dcfg,\n                                           const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n\n    if (strcasecmp(p1, \"on\") == 0) dcfg->reqintercept_oe = 1;\n    else\n    if (strcasecmp(p1, \"off\") == 0) dcfg->reqintercept_oe = 0;\n    else\n    return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecInterceptOnError: %s\", p1);\n\n    return NULL;\n}\n\n\nstatic const char *cmd_request_encoding(cmd_parms *cmd, void *_dcfg,\n                                        const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n\n    /* ENH Validate encoding */\n\n    dcfg->request_encoding = p1;\n\n    return NULL;\n}\n\nstatic const char *cmd_response_body_access(cmd_parms *cmd, void *_dcfg,\n                                            const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n\n    if (strcasecmp(p1, \"on\") == 0) dcfg->resbody_access = 1;\n    else\n    if (strcasecmp(p1, \"off\") == 0) dcfg->resbody_access = 0;\n    else\n    return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecResponseBodyAccess: %s\", p1);\n\n    return NULL;\n}\n\nstatic const char *cmd_response_body_limit(cmd_parms *cmd, void *_dcfg,\n                                           const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    long int limit;\n\n    limit = strtol(p1, NULL, 10);\n    if ((limit == LONG_MAX)||(limit == LONG_MIN)||(limit <= 0)) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecResponseBodyLimit: %s\", p1);\n    }\n\n    if (limit > RESPONSE_BODY_HARD_LIMIT) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Response size limit can not exceed the hard limit: %li\", RESPONSE_BODY_HARD_LIMIT);\n    }\n\n    dcfg->of_limit = limit;\n\n    return NULL;\n}\n\nstatic const char *cmd_response_body_limit_action(cmd_parms *cmd, void *_dcfg,\n                                                  const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n\n    if (dcfg->is_enabled == MODSEC_DETECTION_ONLY)  {\n        dcfg->of_limit_action = RESPONSE_BODY_LIMIT_ACTION_PARTIAL;\n        return NULL;\n    }\n\n    if (strcasecmp(p1, \"ProcessPartial\") == 0) dcfg->of_limit_action = RESPONSE_BODY_LIMIT_ACTION_PARTIAL;\n    else\n    if (strcasecmp(p1, \"Reject\") == 0) dcfg->of_limit_action = RESPONSE_BODY_LIMIT_ACTION_REJECT;\n    else\n    return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecResponseBodyLimitAction: %s\", p1);\n\n    return NULL;\n}\n\n/**\n* \\brief Add SecRequestBodyLimitAction configuration option\n*\n* \\param cmd Pointer to configuration data\n* \\param _dcfg Pointer to directory configuration\n* \\param p1 Pointer to configuration option\n*\n* \\retval NULL On failure\n* \\retval apr_psprintf On success\n*/\nstatic const char *cmd_resquest_body_limit_action(cmd_parms *cmd, void *_dcfg,\n                                                  const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n\n    if (dcfg->is_enabled == MODSEC_DETECTION_ONLY)  {\n        dcfg->if_limit_action = REQUEST_BODY_LIMIT_ACTION_PARTIAL;\n        return NULL;\n    }\n\n    if (strcasecmp(p1, \"ProcessPartial\") == 0) dcfg->if_limit_action = REQUEST_BODY_LIMIT_ACTION_PARTIAL;\n    else\n    if (strcasecmp(p1, \"Reject\") == 0) dcfg->if_limit_action = REQUEST_BODY_LIMIT_ACTION_REJECT;\n    else\n    return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecRequestBodyLimitAction: %s\", p1);\n\n    return NULL;\n}\n\nstatic const char *cmd_response_body_mime_type(cmd_parms *cmd, void *_dcfg,\n                                               const char *_p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    char *p1 = apr_pstrdup(cmd->pool, _p1);\n\n    /* TODO check whether the parameter is a valid MIME type of \"???\" */\n\n    if ((dcfg->of_mime_types == NULL)||(dcfg->of_mime_types == NOT_SET_P)) {\n        dcfg->of_mime_types = apr_table_make(cmd->pool, 10);\n    }\n\n    strtolower_inplace((unsigned char *)p1);\n    apr_table_setn(dcfg->of_mime_types, p1, \"1\");\n\n    return NULL;\n}\n\nstatic const char *cmd_response_body_mime_types_clear(cmd_parms *cmd,\n                                                      void *_dcfg)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n\n    dcfg->of_mime_types_cleared = 1;\n\n    if ((dcfg->of_mime_types != NULL)&&(dcfg->of_mime_types != NOT_SET_P)) {\n        apr_table_clear(dcfg->of_mime_types);\n    }\n\n    return NULL;\n}\n\n/**\n * \\brief Add SecRuleUpdateTargetById\n *\n * \\param cmd Pointer to configuration data\n * \\param _dcfg Pointer to directory configuration\n * \\param p1 Pointer to configuration option\n * \\param p2 Pointer to configuration option\n * \\param p3 Pointer to configuration option\n *\n * \\retval NULL On failure|Success\n */\nstatic const char *cmd_rule_update_target_by_id(cmd_parms *cmd, void *_dcfg,\n        const char *p1, const char *p2, const char *p3)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    rule_exception *re = apr_pcalloc(cmd->pool, sizeof(rule_exception));\n    if (dcfg == NULL) return NULL;\n\n    if(p1 == NULL)  {\n        return apr_psprintf(cmd->pool, \"Updating target by ID with no ID\");\n    }\n\n    re->type = RULE_EXCEPTION_REMOVE_ID;\n    /* TODO: Validate the range here, while we can still tell the user if it's invalid */\n    re->param = p1;\n\n    return msre_ruleset_rule_update_target_matching_exception(NULL, dcfg->ruleset, re, p2, p3);\n}\n\n/**\n * \\brief Add SecRuleUpdateTargetByTag  configuration option\n *\n * \\param cmd Pointer to configuration data\n * \\param _dcfg Pointer to directory configuration\n * \\param p1 Pointer to configuration option RULETAG\n * \\param p2 Pointer to configuration option TARGET\n * \\param p3 Pointer to configuration option REPLACED_TARGET\n * \\todo Finish documenting\n *\n * \\retval NULL On success\n * \\retval apr_psprintf On failure\n *\n * \\todo Figure out error checking\n */\nstatic const char *cmd_rule_update_target_by_tag(cmd_parms *cmd, void *_dcfg,\n        const char *p1, const char *p2, const char *p3)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    rule_exception *re = apr_pcalloc(cmd->pool, sizeof(rule_exception));\n    if (dcfg == NULL) return NULL;\n\n    if(p1 == NULL)  {\n        return apr_psprintf(cmd->pool, \"Updating target by tag with no tag\");\n    }\n\n    re->type = RULE_EXCEPTION_REMOVE_TAG;\n    re->param = p1;\n    re->param_data = msc_pregcomp(cmd->pool, p1, 0, NULL, NULL);\n    if (re->param_data == NULL) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Invalid regular expression: %s\", p1);\n    }\n\n    return msre_ruleset_rule_update_target_matching_exception(NULL, dcfg->ruleset, re, p2, p3);\n}\n/**\n * \\brief Add SecRuleUpdateTargetByMsg configuration option\n *\n * \\param cmd Pointer to configuration data\n * \\param _dcfg Pointer to directory configuration\n * \\param p1 Pointer to configuration option RULEMSG\n * \\param p2 Pointer to configuration option TARGET\n * \\param p3 Pointer to configuration option REPLACED_TARGET\n * \\todo Finish documenting\n *\n * \\retval NULL On success\n * \\retval apr_psprintf On failure\n *\n * \\todo Figure out error checking\n */\nstatic const char *cmd_rule_update_target_by_msg(cmd_parms *cmd, void *_dcfg,\n        const char *p1, const char *p2, const char *p3)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    rule_exception *re = apr_pcalloc(cmd->pool, sizeof(rule_exception));\n    if (dcfg == NULL) return NULL;\n\n    if(p1 == NULL)  {\n        return apr_psprintf(cmd->pool, \"Updating target by message with no message\");\n    }\n\n    re->type = RULE_EXCEPTION_REMOVE_MSG;\n    re->param = p1;\n    re->param_data = msc_pregcomp(cmd->pool, p1, 0, NULL, NULL);\n    if (re->param_data == NULL) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Invalid regular expression: %s\", p1);\n    }\n\n    return msre_ruleset_rule_update_target_matching_exception(NULL, dcfg->ruleset, re, p2, p3);\n}\n\n\nstatic const char *cmd_rule(cmd_parms *cmd, void *_dcfg,\n        const char *p1, const char *p2, const char *p3)\n{\n    return add_rule(cmd, (directory_config *)_dcfg, RULE_TYPE_NORMAL, p1, p2, p3);\n}\n\nstatic const char *cmd_rule_engine(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n\n    if (strcasecmp(p1, \"on\") == 0) dcfg->is_enabled = MODSEC_ENABLED;\n    else\n    if (strcasecmp(p1, \"off\") == 0) dcfg->is_enabled = MODSEC_DISABLED;\n    else\n    if (strcasecmp(p1, \"detectiononly\") == 0) {\n        dcfg->is_enabled = MODSEC_DETECTION_ONLY;\n        dcfg->of_limit_action = RESPONSE_BODY_LIMIT_ACTION_PARTIAL;\n        dcfg->if_limit_action = REQUEST_BODY_LIMIT_ACTION_PARTIAL;\n    } else\n    return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecRuleEngine: %s\", p1);\n\n    return NULL;\n}\n\nstatic const char *cmd_rule_inheritance(cmd_parms *cmd, void *_dcfg, int flag)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n    dcfg->rule_inheritance = flag;\n    return NULL;\n}\n\nstatic const char *cmd_rule_script(cmd_parms *cmd, void *_dcfg,\n                                   const char *p1, const char *p2)\n{\n    #if defined(WITH_LUA)\n    const char *filename = resolve_relative_path(cmd->pool, cmd->directive->filename, p1);\n    return add_rule(cmd, (directory_config *)_dcfg, RULE_TYPE_LUA, filename, p2, NULL);\n    #else\n    ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, cmd->pool, \"Ignoring SecRuleScript \\\"%s\\\" directive (%s:%d): No Lua scripting support.\", p1, cmd->directive->filename, cmd->directive->line_num);\n    return NULL;\n    #endif\n}\n\nstatic const char *cmd_rule_remove_by_id(cmd_parms *cmd, void *_dcfg,\n                                         const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    rule_exception *re = apr_pcalloc(cmd->pool, sizeof(rule_exception));\n    if (dcfg == NULL) return NULL;\n\n    re->type = RULE_EXCEPTION_REMOVE_ID;\n    re->param = p1;\n    *(rule_exception **)apr_array_push(dcfg->rule_exceptions) = re;\n\n    /* Remove the corresponding rules from the context straight away. */\n    msre_ruleset_rule_remove_with_exception(dcfg->ruleset, re);\n\n    return NULL;\n}\n\n/**\n* \\brief Add SecRuleRemoveByTag  configuration option\n*\n* \\param cmd Pointer to configuration data\n* \\param _dcfg Pointer to directory configuration\n* \\param p1 Pointer to configuration option\n*\n* \\retval NULL On failure\n* \\retval apr_psprintf On success\n*/\nstatic const char *cmd_rule_remove_by_tag(cmd_parms *cmd, void *_dcfg,\n                                          const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    rule_exception *re = apr_pcalloc(cmd->pool, sizeof(rule_exception));\n    if (dcfg == NULL) return NULL;\n\n    re->type = RULE_EXCEPTION_REMOVE_TAG;\n    re->param = p1;\n    re->param_data = msc_pregcomp(cmd->pool, p1, 0, NULL, NULL);\n    if (re->param_data == NULL) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Invalid regular expression: %s\", p1);\n    }\n    *(rule_exception **)apr_array_push(dcfg->rule_exceptions) = re;\n\n    /* Remove the corresponding rules from the context straight away. */\n    msre_ruleset_rule_remove_with_exception(dcfg->ruleset, re);\n\n    #ifdef DEBUG_CONF\n    ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, cmd->pool, \"Added exception %pp (%d %s) to dcfg %pp.\", re, re->type, re->param, dcfg);\n    #endif\n\n    return NULL;\n}\n\nstatic const char *cmd_rule_remove_by_msg(cmd_parms *cmd, void *_dcfg,\n                                          const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    rule_exception *re = apr_pcalloc(cmd->pool, sizeof(rule_exception));\n    if (dcfg == NULL) return NULL;\n\n    re->type = RULE_EXCEPTION_REMOVE_MSG;\n    re->param = p1;\n    re->param_data = msc_pregcomp(cmd->pool, p1, 0, NULL, NULL);\n    if (re->param_data == NULL) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Invalid regular expression: %s\", p1);\n    }\n    *(rule_exception **)apr_array_push(dcfg->rule_exceptions) = re;\n\n    /* Remove the corresponding rules from the context straight away. */\n    msre_ruleset_rule_remove_with_exception(dcfg->ruleset, re);\n\n    #ifdef DEBUG_CONF\n    ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, cmd->pool, \"Added exception %pp (%d %s) to dcfg %pp.\", re, re->type, re->param, dcfg);\n    #endif\n\n    return NULL;\n}\n\nstatic const char *cmd_rule_update_action_by_id(cmd_parms *cmd, void *_dcfg,\n        const char *p1, const char *p2)\n{\n    int offset = 0, rule_id = atoi(p1);\n    char *opt = strchr(p1,':');\n    char *savedptr = NULL;\n    char *param = apr_pstrdup(cmd->pool, p1);\n\n    if ((rule_id == LONG_MAX)||(rule_id == LONG_MIN)||(rule_id <= 0)) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for ID for update action: %s\", p1);\n    }\n\n    if(opt != NULL) {\n        opt++;\n        offset = atoi(opt);\n        opt = apr_strtok(param,\":\", &savedptr);\n        return update_rule_action(cmd, (directory_config *)_dcfg, (const char *)opt, p2, offset);\n    }\n\n    return update_rule_action(cmd, (directory_config *)_dcfg, p1, p2, offset);\n}\n\nstatic const char *cmd_server_signature(cmd_parms *cmd, void *_dcfg,\n                                        const char *p1)\n{\n    if (cmd->server->is_virtual) {\n        return \"ModSecurity: SecServerSignature not allowed in VirtualHost\";\n    }\n    new_server_signature = (char *)p1;\n    return NULL;\n}\n\nstatic const char *cmd_tmp_dir(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n\n    if (dcfg == NULL) return NULL;\n\n    if (strcasecmp(p1, \"none\") == 0) dcfg->tmp_dir = NULL;\n    else dcfg->tmp_dir = ap_server_root_relative(cmd->pool, p1);\n\n    return NULL;\n}\n\nstatic const char *cmd_upload_dir(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n\n    if (dcfg == NULL) return NULL;\n\n    if (strcasecmp(p1, \"none\") == 0) dcfg->upload_dir = NULL;\n    else dcfg->upload_dir = ap_server_root_relative(cmd->pool, p1);\n\n    return NULL;\n}\n\nstatic const char *cmd_upload_file_limit(cmd_parms *cmd, void *_dcfg,\n                                         const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n\n    if (dcfg == NULL) return NULL;\n\n    if (strcasecmp(p1, \"default\") == 0) {\n        dcfg->upload_file_limit = NOT_SET;\n    }\n    else {\n        dcfg->upload_file_limit = atoi(p1);\n    }\n\n    return NULL;\n}\n\nstatic const char *cmd_upload_filemode(cmd_parms *cmd, void *_dcfg,\n                                       const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n\n    if (dcfg == NULL) return NULL;\n\n    if (strcasecmp(p1, \"default\") == 0) {\n        dcfg->upload_filemode = NOT_SET;\n    }\n    else {\n        long int mode = strtol(p1, NULL, 8); /* expects octal mode */\n        if ((mode == LONG_MAX)||(mode == LONG_MIN)||(mode <= 0)||(mode > 07777)) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecUploadFileMode: %s\", p1);\n        }\n\n        dcfg->upload_filemode = (int)mode;\n    }\n\n    return NULL;\n}\n\nstatic const char *cmd_upload_keep_files(cmd_parms *cmd, void *_dcfg,\n                                         const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n\n    if (dcfg == NULL) return NULL;\n\n    if (strcasecmp(p1, \"on\") == 0) {\n        dcfg->upload_keep_files = KEEP_FILES_ON;\n    } else\n    if (strcasecmp(p1, \"off\") == 0) {\n        dcfg->upload_keep_files = KEEP_FILES_OFF;\n    } else\n    if (strcasecmp(p1, \"relevantonly\") == 0) {\n        dcfg->upload_keep_files = KEEP_FILES_RELEVANT_ONLY;\n    } else {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Invalid setting for SecUploadKeepFiles: %s\",\n            p1);\n    }\n    return NULL;\n}\n\nstatic const char *cmd_web_app_id(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n\n    /* ENH enforce format (letters, digits, ., _, -) */\n    dcfg->webappid = p1;\n\n    return NULL;\n}\n\nstatic const char *cmd_sensor_id(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n\n    /* ENH enforce format (letters, digits, ., _, -) */\n    dcfg->sensor_id = p1;\n\n    return NULL;\n}\n\n/**\n* \\brief Add SecXmlExternalEntity configuration option\n*\n* \\param cmd Pointer to configuration data\n* \\param _dcfg Pointer to directory configuration\n* \\param p1 Pointer to configuration option\n*\n* \\retval NULL On failure\n* \\retval apr_psprintf On Success\n*/\nstatic const char *cmd_xml_external_entity(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n\n    if (strcasecmp(p1, \"on\") == 0)  {\n        dcfg->xml_external_entity = 1;\n    }\n    else if (strcasecmp(p1, \"off\") == 0)    {\n        dcfg->xml_external_entity = 0;\n    }\n    else return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecXmlExternalEntity: %s\", p1);\n\n    return NULL;\n}\n\n\n/**\n* \\brief Add SecHashEngine configuration option\n*\n* \\param cmd Pointer to configuration data\n* \\param _dcfg Pointer to directory configuration\n* \\param p1 Pointer to configuration option\n*\n* \\retval NULL On failure\n* \\retval apr_psprintf On Success\n*/\nstatic const char *cmd_hash_engine(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n\n    if (strcasecmp(p1, \"on\") == 0)  {\n        dcfg->hash_is_enabled = HASH_ENABLED;\n        dcfg->hash_enforcement = HASH_ENABLED;\n    }\n    else if (strcasecmp(p1, \"off\") == 0)    {\n        dcfg->hash_is_enabled = HASH_DISABLED;\n        dcfg->hash_enforcement = HASH_DISABLED;\n    }\n    else return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SexHashEngine: %s\", p1);\n\n    return NULL;\n}\n\n/**\n* \\brief Add SecHashPram configuration option\n*\n* \\param cmd Pointer to configuration data\n* \\param _dcfg Pointer to directory configuration\n* \\param p1 Pointer to configuration option\n*\n* \\retval NULL On success\n*/\nstatic const char *cmd_hash_param(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n\n    if (dcfg == NULL) return NULL;\n\n    if (p1 == NULL) return NULL;\n    dcfg->crypto_param_name = p1;\n\n    return NULL;\n}\n\n/**\n* \\brief Add SecHashKey configuration option\n*\n* \\param cmd Pointer to configuration data\n* \\param _dcfg Pointer to directory configuration\n* \\param _p1 Pointer to configuration option\n* \\param _p2 Pointer to configuration option\n*\n* \\retval NULL On success\n*/\nstatic const char *cmd_hash_key(cmd_parms *cmd, void *_dcfg, const char *_p1, const char *_p2)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    char *p1 = NULL;\n\n    if (dcfg == NULL) return NULL;\n    if (_p1 == NULL) return NULL;\n\n    if (strcasecmp(_p1, \"Rand\") == 0)    {\n        p1 = apr_pstrdup(cmd->pool, getkey(cmd->pool));\n        dcfg->crypto_key = p1;\n        dcfg->crypto_key_len = strlen(dcfg->crypto_key);\n    } else    {\n        p1 = apr_pstrdup(cmd->pool, _p1);\n        dcfg->crypto_key = p1;\n        dcfg->crypto_key_len = strlen(p1);\n    }\n\n    if(_p2 == NULL)  {\n        return NULL;\n    } else    {\n        if (strcasecmp(_p2, \"KeyOnly\") == 0)\n            dcfg->crypto_key_add = HASH_KEYONLY;\n        else if (strcasecmp(_p2, \"SessionID\") == 0)\n            dcfg->crypto_key_add = HASH_SESSIONID;\n        else if (strcasecmp(_p2, \"RemoteIP\") == 0)\n            dcfg->crypto_key_add = HASH_REMOTEIP;\n    }\n    return NULL;\n}\n\n/**\n* \\brief Add SecHashMethodPm configuration option\n*\n* \\param cmd Pointer to configuration data\n* \\param _dcfg Pointer to directory configuration\n* \\param p1 Pointer to configuration option\n* \\param p2 Pointer to configuration option\n*\n* \\retval NULL On failure\n* \\retval apr_psprintf On Success\n*/\nstatic const char *cmd_hash_method_pm(cmd_parms *cmd, void *_dcfg,\n        const char *p1, const char *p2)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    rule_exception *re = apr_pcalloc(cmd->pool, sizeof(hash_method));\n    const char *_p2 = apr_pstrdup(cmd->pool, p2);\n    ACMP *p = NULL;\n    const char *phrase = NULL;\n    const char *next = NULL;\n\n    if (dcfg == NULL) return NULL;\n\n    p = acmp_create(0, cmd->pool);\n    if (p == NULL) return NULL;\n\n    if(phrase == NULL)\n        phrase = apr_pstrdup(cmd->pool, _p2);\n\n    for (;;) {\n        while((apr_isspace(*phrase) != 0) && (*phrase != '\\0')) phrase++;\n        if (*phrase == '\\0') break;\n        next = phrase;\n        while((apr_isspace(*next) == 0) && (*next != 0)) next++;\n        acmp_add_pattern(p, phrase, NULL, NULL, next - phrase);\n        phrase = next;\n    }\n\n    acmp_prepare(p);\n\n    if (strcasecmp(p1, \"HashHref\") == 0) {\n        re->type = HASH_URL_HREF_HASH_PM;\n        re->param = _p2;\n        re->param_data = (void *)p;\n        if (re->param_data == NULL) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: Invalid pattern: %s\", p2);\n        }\n        dcfg->crypto_hash_href_pm = 1;\n    }\n    else if (strcasecmp(p1, \"HashFormAction\") == 0) {\n        re->type = HASH_URL_FACTION_HASH_PM;\n        re->param = _p2;\n        re->param_data = (void *)p;\n        if (re->param_data == NULL) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: Invalid pattern: %s\", p2);\n        }\n        dcfg->crypto_hash_faction_pm = 1;\n    }\n    else if (strcasecmp(p1, \"HashLocation\") == 0) {\n        re->type = HASH_URL_LOCATION_HASH_PM;\n        re->param = _p2;\n        re->param_data = (void *)p;\n        if (re->param_data == NULL) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: Invalid pattern: %s\", p2);\n        }\n        dcfg->crypto_hash_location_pm = 1;\n    }\n    else if (strcasecmp(p1, \"HashIframeSrc\") == 0) {\n        re->type = HASH_URL_IFRAMESRC_HASH_PM;\n        re->param = _p2;\n        re->param_data = (void *)p;\n        if (re->param_data == NULL) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: Invalid pattern: %s\", p2);\n        }\n        dcfg->crypto_hash_iframesrc_pm = 1;\n    }\n    else if (strcasecmp(p1, \"HashFrameSrc\") == 0) {\n        re->type = HASH_URL_FRAMESRC_HASH_PM;\n        re->param = _p2;\n        re->param_data = (void *)p;\n        if (re->param_data == NULL) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: Invalid pattern: %s\", p2);\n        }\n        dcfg->crypto_hash_framesrc_pm = 1;\n    }\n\n    *(hash_method **)apr_array_push(dcfg->hash_method) = re;\n\n    return NULL;\n}\n\n/**\n * \\brief Add SecHashMethodRx configuration option\n *\n * \\param cmd Pointer to configuration data\n * \\param _dcfg Pointer to directory configuration\n * \\param p1 Pointer to configuration option\n * \\param p2 Pointer to configuration option\n *\n * \\retval NULL On failure\n * \\retval apr_psprintf On Success\n */\nstatic const char *cmd_hash_method_rx(cmd_parms *cmd, void *_dcfg,\n        const char *p1, const char *p2)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    rule_exception *re = apr_pcalloc(cmd->pool, sizeof(hash_method));\n    const char *_p2 = apr_pstrdup(cmd->pool, p2);\n    if (dcfg == NULL) return NULL;\n\n    if (strcasecmp(p1, \"HashHref\") == 0) {\n        re->type = HASH_URL_HREF_HASH_RX;\n        re->param = _p2;\n        re->param_data = msc_pregcomp(cmd->pool, p2, 0, NULL, NULL);\n        if (re->param_data == NULL) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: Invalid regular expression: %s\", p2);\n        }\n        dcfg->crypto_hash_href_rx = 1;\n    }\n    else if (strcasecmp(p1, \"HashFormAction\") == 0) {\n        re->type = HASH_URL_FACTION_HASH_RX;\n        re->param = _p2;\n        re->param_data = msc_pregcomp(cmd->pool, p2, 0, NULL, NULL);\n        if (re->param_data == NULL) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: Invalid regular expression: %s\", p2);\n        }\n        dcfg->crypto_hash_faction_rx = 1;\n    }\n    else if (strcasecmp(p1, \"HashLocation\") == 0) {\n        re->type = HASH_URL_LOCATION_HASH_RX;\n        re->param = _p2;\n        re->param_data = msc_pregcomp(cmd->pool, p2, 0, NULL, NULL);\n        if (re->param_data == NULL) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: Invalid regular expression: %s\", p2);\n        }\n        dcfg->crypto_hash_location_rx = 1;\n    }\n    else if (strcasecmp(p1, \"HashIframeSrc\") == 0) {\n        re->type = HASH_URL_IFRAMESRC_HASH_RX;\n        re->param = _p2;\n        re->param_data = msc_pregcomp(cmd->pool, p2, 0, NULL, NULL);\n        if (re->param_data == NULL) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: Invalid regular expression: %s\", p2);\n        }\n        dcfg->crypto_hash_iframesrc_rx = 1;\n    }\n    else if (strcasecmp(p1, \"HashFrameSrc\") == 0) {\n        re->type = HASH_URL_FRAMESRC_HASH_RX;\n        re->param = _p2;\n        re->param_data = msc_pregcomp(cmd->pool, p2, 0, NULL, NULL);\n        if (re->param_data == NULL) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: Invalid regular expression: %s\", p2);\n        }\n        dcfg->crypto_hash_framesrc_rx = 1;\n    }\n\n    *(hash_method **)apr_array_push(dcfg->hash_method) = re;\n\n    return NULL;\n}\n\n/**\n* \\brief Add SecHttpBlKey configuration option\n*\n* \\param cmd Pointer to configuration data\n* \\param _dcfg Pointer to directory configuration\n* \\param p1 Pointer to configuration option\n*\n* \\retval NULL On success\n*/\nstatic const char *cmd_httpBl_key(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n\n    if (dcfg == NULL) return NULL;\n\n    if (p1 == NULL) return NULL;\n    dcfg->httpBlkey = p1;\n\n    return NULL;\n}\n\n/* PCRE Limits */\n\nstatic const char *cmd_pcre_match_limit(cmd_parms *cmd,\n        void *_dcfg, const char *p1)\n{\n    long val;\n\n    if (cmd->server->is_virtual) {\n        return \"ModSecurity: SecPcreMatchLimit not allowed in VirtualHost\";\n    }\n\n    val = atol(p1);\n    if (val <= 0) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Invalid setting for \"\n                \"SecPcreMatchLimit: %s\", p1);\n    }\n    msc_pcre_match_limit = (unsigned long int)val;\n\n    return NULL;\n}\n\nstatic const char *cmd_pcre_match_limit_recursion(cmd_parms *cmd,\n        void *_dcfg, const char *p1)\n{\n    long val;\n\n    if (cmd->server->is_virtual) {\n        return \"ModSecurity: SecPcreMatchLimitRecursion not allowed in VirtualHost\";\n    }\n\n    val = atol(p1);\n    if (val <= 0) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Invalid setting for \"\n                \"SecPcreMatchLimitRecursion: %s\", p1);\n    }\n    msc_pcre_match_limit_recursion = (unsigned long int)val;\n\n    return NULL;\n}\n\n\n/* -- Geo Lookup configuration -- */\n\nstatic const char *cmd_geo_lookup_db(cmd_parms *cmd, void *_dcfg,\n        const char *p1)\n{\n    const char *filename = resolve_relative_path(cmd->pool, cmd->directive->filename, p1);\n    char *error_msg;\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n\n    if (geo_init(dcfg, filename, &error_msg) <= 0) {\n        return error_msg;\n    }\n\n    return NULL;\n}\n\n/**\n* \\brief Add SecUnicodeCodePage configuration option\n*\n* \\param cmd Pointer to configuration data\n* \\param _dcfg Pointer to directory configuration\n* \\param p1 Pointer to configuration option\n*\n* \\retval NULL On success\n*/\nstatic const char *cmd_unicode_codepage(cmd_parms *cmd,\n                                        void *_dcfg, const char *p1)\n{\n    long val;\n\n    val = atol(p1);\n    if (val <= 0) {\n        return apr_psprintf(cmd->pool, \"ModSecurity: Invalid setting for \"\n                                       \"SecUnicodeCodePage: %s\", p1);\n    }\n\n    unicode_codepage = (unsigned long int)val;\n\n    return NULL;\n}\n\n/**\n* \\brief Add SecUnicodeMapFile configuration option\n*\n* \\param cmd Pointer to configuration data\n* \\param _dcfg Pointer to directory configuration\n* \\param p1 Pointer to configuration option\n*\n* \\retval NULL On success\n*/\nstatic const char *cmd_unicode_map(cmd_parms *cmd, void *_dcfg,\n                                     const char *p1)\n{\n    const char *filename = resolve_relative_path(cmd->pool, cmd->directive->filename, p1);\n    char *error_msg;\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n\n    if (unicode_map_init(dcfg, filename, &error_msg) <= 0) {\n        return error_msg;\n    }\n\n    return NULL;\n}\n\n/**\n* \\brief Add SecGsbLookupDb configuration option\n*\n* \\param cmd Pointer to configuration data\n* \\param _dcfg Pointer to directory configuration\n* \\param p1 Pointer to configuration option\n*\n* \\retval NULL On success\n*/\nstatic const char *cmd_gsb_lookup_db(cmd_parms *cmd, void *_dcfg,\n                                     const char *p1)\n{\n    const char *filename = resolve_relative_path(cmd->pool, cmd->directive->filename, p1);\n    char *error_msg;\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n\n    if (gsb_db_init(dcfg, filename, &error_msg) <= 0) {\n        return error_msg;\n    }\n\n    return NULL;\n}\n\n/* -- Cache -- */\n\nstatic const char *cmd_cache_transformations(cmd_parms *cmd, void *_dcfg,\n                                             const char *p1, const char *p2)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n\n    if (dcfg == NULL) return NULL;\n\n    if (strcasecmp(p1, \"on\") == 0)\n        dcfg->cache_trans = MODSEC_CACHE_ENABLED;\n    else if (strcasecmp(p1, \"off\") == 0)\n        dcfg->cache_trans = MODSEC_CACHE_DISABLED;\n    else\n        return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecCacheTransformations: %s\", p1);\n\n    /* Process options */\n    if (p2 != NULL) {\n        apr_table_t *vartable = apr_table_make(cmd->pool, 4);\n        apr_status_t rc;\n        char *error_msg = NULL;\n        const char *charval = NULL;\n        apr_int64_t intval = 0;\n\n        if (vartable == NULL) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: Unable to process options for SecCacheTransformations\");\n        }\n        rc = msre_parse_generic(cmd->pool, p2, vartable, &error_msg);\n        if (rc < 0) {\n            return apr_psprintf(cmd->pool, \"ModSecurity: Unable to parse options for SecCacheTransformations: %s\", error_msg);\n        }\n\n        /* incremental */\n        charval = apr_table_get(vartable, \"incremental\");\n        if (charval != NULL) {\n            if (strcasecmp(charval, \"on\") == 0)\n                dcfg->cache_trans_incremental = 1;\n            else if (strcasecmp(charval, \"off\") == 0)\n                dcfg->cache_trans_incremental = 0;\n            else\n                return apr_psprintf(cmd->pool, \"ModSecurity: SecCacheTransformations invalid incremental value: %s\", charval);\n        }\n\n        /* minlen */\n        charval = apr_table_get(vartable, \"minlen\");\n        if (charval != NULL) {\n            intval = apr_atoi64(charval);\n            if (errno == ERANGE) {\n                return apr_psprintf(cmd->pool, \"ModSecurity: SecCacheTransformations minlen out of range: %s\", charval);\n            }\n            if (intval < 0) {\n                return apr_psprintf(cmd->pool, \"ModSecurity: SecCacheTransformations minlen must be positive: %s\", charval);\n            }\n\n            /* The NOT_SET indicator is -1, a signed long, and therfore\n             * we cannot be >= the unsigned value of NOT_SET.\n             */\n            if ((unsigned long)intval >= (unsigned long)NOT_SET) {\n                return apr_psprintf(cmd->pool, \"ModSecurity: SecCacheTransformations minlen must be less than: %lu\", (unsigned long)NOT_SET);\n            }\n            dcfg->cache_trans_min = (apr_size_t)intval;\n        }\n\n        /* maxlen */\n        charval = apr_table_get(vartable, \"maxlen\");\n        if (charval != NULL) {\n            intval = apr_atoi64(charval);\n            if (errno == ERANGE) {\n                return apr_psprintf(cmd->pool, \"ModSecurity: SecCacheTransformations maxlen out of range: %s\", charval);\n            }\n            if (intval < 0) {\n                return apr_psprintf(cmd->pool, \"ModSecurity: SecCacheTransformations maxlen must be positive: %s\", charval);\n            }\n\n            /* The NOT_SET indicator is -1, a signed long, and therfore\n             * we cannot be >= the unsigned value of NOT_SET.\n             */\n            if ((unsigned long)intval >= (unsigned long)NOT_SET) {\n                return apr_psprintf(cmd->pool, \"ModSecurity: SecCacheTransformations maxlen must be less than: %lu\", (unsigned long)NOT_SET);\n            }\n            if ((intval != 0) && ((apr_size_t)intval < dcfg->cache_trans_min)) {\n                return apr_psprintf(cmd->pool, \"ModSecurity: SecCacheTransformations maxlen must not be less than minlen: %lu < %\" APR_SIZE_T_FMT, (unsigned long)intval, dcfg->cache_trans_min);\n            }\n            dcfg->cache_trans_max = (apr_size_t)intval;\n\n        }\n\n        /* maxitems */\n        charval = apr_table_get(vartable, \"maxitems\");\n        if (charval != NULL) {\n            intval = apr_atoi64(charval);\n            if (errno == ERANGE) {\n                return apr_psprintf(cmd->pool, \"ModSecurity: SecCacheTransformations maxitems out of range: %s\", charval);\n            }\n            if (intval < 0) {\n                return apr_psprintf(cmd->pool, \"ModSecurity: SecCacheTransformations maxitems must be positive: %s\", charval);\n            }\n            dcfg->cache_trans_maxitems = (apr_size_t)intval;\n        }\n    }\n\n    return NULL;\n}\n\n\n/* -- Configuration directives definitions -- */\n\n#define CMD_SCOPE_MAIN  (RSRC_CONF)\n#define CMD_SCOPE_ANY   (RSRC_CONF | ACCESS_CONF)\n\n#if defined(HTACCESS_CONFIG)\n#define CMD_SCOPE_HTACCESS  (OR_OPTIONS)\n#endif\n\nconst command_rec module_directives[] = {\n\n#ifdef HTACCESS_CONFIG\n    AP_INIT_TAKE1 (\n        \"SecAction\",\n        cmd_action,\n        NULL,\n        CMD_SCOPE_HTACCESS,\n        \"an action list\"\n    ),\n#else\n    AP_INIT_TAKE1 (\n        \"SecAction\",\n        cmd_action,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"an action list\"\n    ),\n#endif\n\n    AP_INIT_TAKE1 (\n        \"SecArgumentSeparator\",\n        cmd_argument_separator,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"character that will be used as separator when parsing application/x-www-form-urlencoded content.\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecCookiev0Separator\",\n        cmd_cookiev0_separator,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"character that will be used as separator when parsing cookie v0 content.\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecAuditEngine\",\n        cmd_audit_engine,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"On, Off or RelevantOnly to determine the level of audit logging\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecAuditLog\",\n        cmd_audit_log,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"filename of the primary audit log file\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecAuditLog2\",\n        cmd_audit_log2,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"filename of the secondary audit log file\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecAuditLogParts\",\n        cmd_audit_log_parts,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"list of audit log parts that go into the log.\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecAuditLogRelevantStatus\",\n        cmd_audit_log_relevant_status,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"regular expression that will be used to determine if the response status is relevant for audit logging\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecAuditLogType\",\n        cmd_audit_log_type,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"whether to use the old audit log format (Serial) or new (Concurrent)\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecAuditLogStorageDir\",\n        cmd_audit_log_storage_dir,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"path to the audit log storage area; absolute, or relative to the root of the server\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecAuditLogDirMode\",\n        cmd_audit_log_dirmode,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"octal permissions mode for concurrent audit log directories\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecAuditLogFileMode\",\n        cmd_audit_log_filemode,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"octal permissions mode for concurrent audit log files\"\n    ),\n\n    AP_INIT_TAKE12 (\n        \"SecCacheTransformations\",\n        cmd_cache_transformations,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"whether or not to cache transformations. Defaults to true.\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecChrootDir\",\n        cmd_chroot_dir,\n        NULL,\n        CMD_SCOPE_MAIN,\n        \"path of the directory to which server will be chrooted\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecComponentSignature\",\n        cmd_component_signature,\n        NULL,\n        CMD_SCOPE_MAIN,\n        \"component signature to add to ModSecurity signature.\"\n    ),\n\n    AP_INIT_FLAG (\n        \"SecContentInjection\",\n        cmd_content_injection,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"On or Off\"\n    ),\n\n    AP_INIT_FLAG (\n        \"SecStreamOutBodyInspection\",\n        cmd_stream_outbody_inspection,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"On or Off\"\n    ),\n\n    AP_INIT_FLAG (\n        \"SecStreamInBodyInspection\",\n        cmd_stream_inbody_inspection,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"On or Off\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecCookieFormat\",\n        cmd_cookie_format,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"version of the Cookie specification to use for parsing. Possible values are 0 and 1.\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecDataDir\",\n        cmd_data_dir,\n        NULL,\n        CMD_SCOPE_MAIN,\n        \"path to the persistent data storage area\" // TODO\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecDebugLog\",\n        cmd_debug_log,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"path to the debug log file\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecDebugLogLevel\",\n        cmd_debug_log_level,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"debug log level, which controls the verbosity of logging.\"\n        \" Use values from 0 (no logging) to 9 (a *lot* of logging).\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecCollectionTimeout\",\n        cmd_collection_timeout,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"set default collections timeout. default it 3600\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecDefaultAction\",\n        cmd_default_action,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"default action list\"\n    ),\n\n    AP_INIT_FLAG (\n        \"SecDisableBackendCompression\",\n        cmd_disable_backend_compression,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"When set to On, removes the compression headers from the backend requests.\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecGsbLookupDB\",\n        cmd_gsb_lookup_db,\n        NULL,\n        RSRC_CONF,\n        \"database google safe browsing\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecUnicodeCodePage\",\n        cmd_unicode_codepage,\n        NULL,\n        CMD_SCOPE_MAIN,\n        \"Unicode CodePage\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecUnicodeMapFile\",\n        cmd_unicode_map,\n        NULL,\n        CMD_SCOPE_MAIN,\n        \"Unicode Map file\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecGeoLookupDB\",\n        cmd_geo_lookup_db,\n        NULL,\n        RSRC_CONF,\n        \"database for geographical lookups module.\"\n    ),\n\n    AP_INIT_TAKE12 (\n        \"SecGuardianLog\",\n        cmd_guardian_log,\n        NULL,\n        CMD_SCOPE_MAIN,\n        \"The filename of the filter debugging log file\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecMarker\",\n        cmd_marker,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"marker for a skipAfter target\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecPcreMatchLimit\",\n        cmd_pcre_match_limit,\n        NULL,\n        CMD_SCOPE_MAIN,\n        \"PCRE match limit\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecPcreMatchLimitRecursion\",\n        cmd_pcre_match_limit_recursion,\n        NULL,\n        CMD_SCOPE_MAIN,\n        \"PCRE match limit recursion\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecRequestBodyAccess\",\n        cmd_request_body_access,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"On or Off\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecInterceptOnError\",\n        cmd_request_intercept_on_error,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"On or Off\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecRulePerfTime\",\n        cmd_rule_perf_time,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"Threshold to log slow rules in usecs.\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecReadStateLimit\",\n        cmd_conn_read_state_limit,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"maximum number of threads in READ_BUSY state per ip address\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecWriteStateLimit\",\n        cmd_conn_write_state_limit,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"maximum number of threads in WRITE_BUSY state per ip address\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecRequestBodyInMemoryLimit\",\n        cmd_request_body_inmemory_limit,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"maximum request body size that will be placed in memory (except for POST urlencoded requests).\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecRequestBodyLimit\",\n        cmd_request_body_limit,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"maximum request body size ModSecurity will accept.\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecRequestBodyNoFilesLimit\",\n        cmd_request_body_no_files_limit,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"maximum request body size ModSecurity will accept, but excluding the size of uploaded files.\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecRequestEncoding\",\n        cmd_request_encoding,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"character encoding used in request.\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecResponseBodyAccess\",\n        cmd_response_body_access,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"On or Off\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecResponseBodyLimit\",\n        cmd_response_body_limit,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"byte limit for response body\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecResponseBodyLimitAction\",\n        cmd_response_body_limit_action,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"what happens when the response body limit is reached\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecRequestBodyLimitAction\",\n        cmd_resquest_body_limit_action,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"what happens when the request body limit is reached\"\n    ),\n\n    AP_INIT_ITERATE (\n        \"SecResponseBodyMimeType\",\n        cmd_response_body_mime_type,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"adds given MIME types to the list of types that will be buffered on output\"\n    ),\n\n    AP_INIT_NO_ARGS (\n        \"SecResponseBodyMimeTypesClear\",\n        cmd_response_body_mime_types_clear,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"clears the list of MIME types that will be buffered on output\"\n    ),\n\n#ifdef HTACCESS_CONFIG\n    AP_INIT_TAKE23 (\n        \"SecRule\",\n        cmd_rule,\n        NULL,\n        CMD_SCOPE_HTACCESS,\n        \"rule target, operator and optional action list\"\n    ),\n#else\n    AP_INIT_TAKE23 (\n        \"SecRule\",\n        cmd_rule,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"rule target, operator and optional action list\"\n    ),\n#endif\n\n    AP_INIT_TAKE1 (\n        \"SecRuleEngine\",\n        cmd_rule_engine,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"On or Off\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecXmlExternalEntity\",\n        cmd_xml_external_entity,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"On or Off\"\n    ),\n\n    AP_INIT_FLAG (\n        \"SecRuleInheritance\",\n        cmd_rule_inheritance,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"On or Off\"\n    ),\n\n    AP_INIT_TAKE12 (\n        \"SecRuleScript\",\n        cmd_rule_script,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"rule script and optional actionlist\"\n    ),\n\n#ifdef HTACCESS_CONFIG\n    AP_INIT_ITERATE (\n        \"SecRuleRemoveById\",\n        cmd_rule_remove_by_id,\n        NULL,\n        CMD_SCOPE_HTACCESS,\n        \"rule ID for removal\"\n    ),\n\n    AP_INIT_ITERATE (\n        \"SecRuleRemoveByTag\",\n        cmd_rule_remove_by_tag,\n        NULL,\n        CMD_SCOPE_HTACCESS,\n        \"rule tag for removal\"\n    ),\n\n    AP_INIT_ITERATE (\n        \"SecRuleRemoveByMsg\",\n        cmd_rule_remove_by_msg,\n        NULL,\n        CMD_SCOPE_HTACCESS,\n        \"rule message for removal\"\n    ),\n#else\n    AP_INIT_ITERATE (\n        \"SecRuleRemoveById\",\n        cmd_rule_remove_by_id,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"rule ID for removal\"\n    ),\n\n    AP_INIT_ITERATE (\n        \"SecRuleRemoveByTag\",\n        cmd_rule_remove_by_tag,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"rule tag for removal\"\n    ),\n\n    AP_INIT_ITERATE (\n        \"SecRuleRemoveByMsg\",\n        cmd_rule_remove_by_msg,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"rule message for removal\"\n    ),\n#endif\n\n    AP_INIT_TAKE2 (\n        \"SecHashMethodPm\",\n        cmd_hash_method_pm,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"Hash method and pattern\"\n    ),\n\n    AP_INIT_TAKE2 (\n        \"SecHashMethodRx\",\n        cmd_hash_method_rx,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"Hash method and regex\"\n    ),\n\n#ifdef HTACCESS_CONFIG\n    AP_INIT_TAKE2 (\n        \"SecRuleUpdateActionById\",\n        cmd_rule_update_action_by_id,\n        NULL,\n        CMD_SCOPE_HTACCESS,\n        \"updated action list\"\n    ),\n\n    AP_INIT_TAKE23 (\n        \"SecRuleUpdateTargetById\",\n        cmd_rule_update_target_by_id,\n        NULL,\n        CMD_SCOPE_HTACCESS,\n        \"updated target list\"\n    ),\n\n    AP_INIT_TAKE23 (\n        \"SecRuleUpdateTargetByTag\",\n        cmd_rule_update_target_by_tag,\n        NULL,\n        CMD_SCOPE_HTACCESS,\n        \"rule tag pattern and updated target list\"\n    ),\n\n    AP_INIT_TAKE23 (\n        \"SecRuleUpdateTargetByMsg\",\n        cmd_rule_update_target_by_msg,\n        NULL,\n        CMD_SCOPE_HTACCESS,\n        \"rule message pattern and updated target list\"\n    ),\n#else\n    AP_INIT_TAKE2 (\n        \"SecRuleUpdateActionById\",\n        cmd_rule_update_action_by_id,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"updated action list\"\n    ),\n\n    AP_INIT_TAKE23 (\n        \"SecRuleUpdateTargetById\",\n        cmd_rule_update_target_by_id,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"updated target list\"\n    ),\n\n    AP_INIT_TAKE23 (\n        \"SecRuleUpdateTargetByTag\",\n        cmd_rule_update_target_by_tag,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"rule tag pattern and updated target list\"\n    ),\n\n    AP_INIT_TAKE23 (\n        \"SecRuleUpdateTargetByMsg\",\n        cmd_rule_update_target_by_msg,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"rule message pattern and updated target list\"\n    ),\n#endif\n\n    AP_INIT_TAKE1 (\n        \"SecServerSignature\",\n        cmd_server_signature,\n        NULL,\n        CMD_SCOPE_MAIN,\n        \"the new signature of the server\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecTmpDir\",\n        cmd_tmp_dir,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"path to the temporary storage area\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecUploadDir\",\n        cmd_upload_dir,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"path to the file upload area\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecUploadFileLimit\",\n        cmd_upload_file_limit,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"limit the number of uploaded files processed\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecUploadFileMode\",\n        cmd_upload_filemode,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"octal permissions mode for uploaded files\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecUploadKeepFiles\",\n        cmd_upload_keep_files,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"On or Off\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecWebAppId\",\n        cmd_web_app_id,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"id\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecSensorId\",\n        cmd_sensor_id,\n        NULL,\n        CMD_SCOPE_MAIN,\n        \"sensor id\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecHttpBlKey\",\n        cmd_httpBl_key,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"httpBl access key\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecHashEngine\",\n        cmd_hash_engine,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"On or Off\"\n    ),\n\n    AP_INIT_TAKE2 (\n        \"SecHashKey\",\n        cmd_hash_key,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"Set Hash key\"\n    ),\n\n    AP_INIT_TAKE1 (\n        \"SecHashParam\",\n        cmd_hash_param,\n        NULL,\n        CMD_SCOPE_ANY,\n        \"Set Hash parameter\"\n    ),\n\n    { NULL }\n};\n", "/*\n* ModSecurity for Apache 2.x, http://www.modsecurity.org/\n* Copyright (c) 2004-2011 Trustwave Holdings, Inc. (http://www.trustwave.com/)\n*\n* You may not use this file except in compliance with\n* the License. \u00a0You may obtain a copy of the License at\n*\n* \u00a0 \u00a0 http://www.apache.org/licenses/LICENSE-2.0\n*\n* If any of the files related to licensing are missing or if you have any\n* other questions related to licensing please contact Trustwave Holdings, Inc.\n* directly using the email address security@modsecurity.org.\n*/\n\n#ifndef _MODSECURITY_H_\n#define _MODSECURITY_H_\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include <limits.h>\n#include <libxml/tree.h>\n#include <libxml/HTMLparser.h>\n\ntypedef struct rule_exception rule_exception;\ntypedef struct rule_exception hash_method;\ntypedef struct modsec_rec modsec_rec;\ntypedef struct directory_config directory_config;\ntypedef struct error_message_t error_message_t;\ntypedef struct msc_engine msc_engine;\ntypedef struct msc_data_chunk msc_data_chunk;\ntypedef struct msc_arg msc_arg;\ntypedef struct msc_string msc_string;\ntypedef struct msc_parm msc_parm;\n\n#include \"msc_release.h\"\n#include \"msc_logging.h\"\n#include \"msc_multipart.h\"\n#include \"msc_pcre.h\"\n#include \"msc_util.h\"\n#include \"msc_xml.h\"\n#include \"msc_geo.h\"\n#include \"msc_gsb.h\"\n#include \"msc_unicode.h\"\n#include \"re.h\"\n#include \"msc_crypt.h\"\n\n#include \"ap_config.h\"\n#include \"apr_md5.h\"\n#include \"apr_strings.h\"\n#include \"apr_hash.h\"\n#include \"httpd.h\"\n#include \"http_config.h\"\n#include \"http_log.h\"\n#include \"http_protocol.h\"\n\n#if defined(WITH_LUA)\n#include \"msc_lua.h\"\n#endif\n\n\n#define PHASE_REQUEST_HEADERS       1\n#define PHASE_REQUEST_BODY          2\n#define PHASE_RESPONSE_HEADERS      3\n#define PHASE_RESPONSE_BODY         4\n#define PHASE_LOGGING               5\n#define PHASE_FIRST                 PHASE_REQUEST_HEADERS\n#define PHASE_LAST                  PHASE_LOGGING\n\n#define NOT_SET                    -1l\n#define NOT_SET_P         ((void *)-1l)\n\n#define CREATEMODE ( APR_UREAD | APR_UWRITE | APR_GREAD )\n#define CREATEMODE_DIR ( APR_UREAD | APR_UWRITE | APR_UEXECUTE | APR_GREAD | APR_GEXECUTE )\n\n#if defined(NETWARE)\n#define CREATEMODE_UNISTD ( S_IREAD | S_IWRITE )\n#elif defined(WIN32)\n#define CREATEMODE_UNISTD ( _S_IREAD | _S_IWRITE )\n#else\n#define CREATEMODE_UNISTD ( S_IRUSR | S_IWUSR | S_IRGRP )\n#endif\n\n#if !defined(O_BINARY)\n#define O_BINARY (0)\n#endif\n\n#ifndef PIPE_BUF\n#define PIPE_BUF (512)\n#endif\n\n#define REQUEST_BODY_HARD_LIMIT                 1073741824L\n#define REQUEST_BODY_DEFAULT_INMEMORY_LIMIT     131072\n#define REQUEST_BODY_DEFAULT_LIMIT              134217728\n#define REQUEST_BODY_NO_FILES_DEFAULT_LIMIT     1048576\n#define RESPONSE_BODY_DEFAULT_LIMIT             524288\n#define RESPONSE_BODY_HARD_LIMIT                1073741824L\n\n#define RESPONSE_BODY_LIMIT_ACTION_REJECT       0\n#define RESPONSE_BODY_LIMIT_ACTION_PARTIAL      1\n\n#define REQUEST_BODY_FORCEBUF_OFF               0\n#define REQUEST_BODY_FORCEBUF_ON                1\n\n#define REQUEST_BODY_LIMIT_ACTION_REJECT       0\n#define REQUEST_BODY_LIMIT_ACTION_PARTIAL      1\n\n#define SECACTION_TARGETS                       \"REMOTE_ADDR\"\n#define SECACTION_ARGS                          \"@unconditionalMatch\"\n\n#define SECMARKER_TARGETS                       \"REMOTE_ADDR\"\n#define SECMARKER_ARGS                          \"@noMatch\"\n#define SECMARKER_BASE_ACTIONS                  \"t:none,pass,marker:\"\n\n#if !defined(OS2) && !defined(WIN32) && !defined(BEOS) && !defined(NETWARE)\n#include \"unixd.h\"\n#define __SET_MUTEX_PERMS\n#endif\n\n#define COOKIES_V0                      0\n#define COOKIES_V1                      1\n\n#ifdef WIN32\n#include <direct.h>\n#else\n#include <sys/types.h>\n#include <unistd.h>\n#endif\n\n#define NOTE_MSR \"modsecurity-tx-context\"\n\n#define FATAL_ERROR \"ModSecurity: Fatal error (memory allocation or unexpected internal error)!\"\n\nextern DSOLOCAL char *new_server_signature;\nextern DSOLOCAL char *chroot_dir;\n\nextern module AP_MODULE_DECLARE_DATA security2_module;\n\nextern DSOLOCAL const command_rec module_directives[];\n\nextern DSOLOCAL unsigned long int msc_pcre_match_limit;\n\nextern DSOLOCAL unsigned long int msc_pcre_match_limit_recursion;\n\nextern DSOLOCAL unsigned long int conn_read_state_limit;\n\nextern DSOLOCAL unsigned long int conn_write_state_limit;\n\nextern DSOLOCAL unsigned long int unicode_codepage;\n\nextern DSOLOCAL int *unicode_map_table;\n\n#define RESBODY_STATUS_NOT_READ         0   /* we were not configured to read the body */\n#define RESBODY_STATUS_ERROR            1   /* error occured while we were reading the body */\n#define RESBODY_STATUS_PARTIAL          2   /* partial body content available in the brigade */\n#define RESBODY_STATUS_READ_BRIGADE     3   /* body was read but not flattened */\n#define RESBODY_STATUS_READ             4   /* body was read and flattened */\n\n#define IF_STATUS_NONE                  0\n#define IF_STATUS_WANTS_TO_RUN          1\n#define IF_STATUS_COMPLETE              2\n\n#define OF_STATUS_NOT_STARTED           0\n#define OF_STATUS_IN_PROGRESS           1\n#define OF_STATUS_COMPLETE              2\n\n#define MSC_REQBODY_NONE                0\n#define MSC_REQBODY_MEMORY              1\n#define MSC_REQBODY_DISK                2\n\n#define ACTION_NONE                     0\n#define ACTION_DENY                     1\n#define ACTION_REDIRECT                 2\n#define ACTION_PROXY                    3\n#define ACTION_DROP                     4\n#define ACTION_ALLOW                    5\n#define ACTION_ALLOW_REQUEST            6\n#define ACTION_ALLOW_PHASE              7\n#define ACTION_PAUSE                    8\n\n#define MODSEC_DISABLED                 0\n#define MODSEC_DETECTION_ONLY           1\n#define MODSEC_ENABLED                  2\n\n#define HASH_DISABLED             0\n#define HASH_ENABLED              1\n\n#define HASH_URL_HREF_HASH_RX     0\n#define HASH_URL_HREF_HASH_PM     1\n#define HASH_URL_FACTION_HASH_RX  2\n#define HASH_URL_FACTION_HASH_PM  3\n#define HASH_URL_LOCATION_HASH_RX 4\n#define HASH_URL_LOCATION_HASH_PM 5\n#define HASH_URL_IFRAMESRC_HASH_RX 6\n#define HASH_URL_IFRAMESRC_HASH_PM 7\n#define HASH_URL_FRAMESRC_HASH_RX 8\n#define HASH_URL_FRAMESRC_HASH_PM 9\n\n#define HASH_KEYONLY              0\n#define HASH_SESSIONID            1\n#define HASH_REMOTEIP             2\n\n#define MODSEC_CACHE_DISABLED           0\n#define MODSEC_CACHE_ENABLED            1\n\n#define MODSEC_OFFLINE                  0\n#define MODSEC_ONLINE                   1\n\n#define REGEX_CAPTURE_BUFLEN            1024\n\n#define KEEP_FILES_OFF                  0\n#define KEEP_FILES_ON                   1\n#define KEEP_FILES_RELEVANT_ONLY        2\n\n#define RULE_EXCEPTION_IMPORT_ID        1\n#define RULE_EXCEPTION_IMPORT_MSG       2\n#define RULE_EXCEPTION_REMOVE_ID        3\n#define RULE_EXCEPTION_REMOVE_MSG       4\n#define RULE_EXCEPTION_REMOVE_TAG       5\n\n#define NBSP                            160\n\nstruct rule_exception {\n    int                  type;\n    const char          *param;\n    void                *param_data;\n};\n\nstruct modsec_rec {\n    apr_pool_t          *mp;\n    msc_engine          *modsecurity;\n\n    request_rec         *r_early;\n    request_rec         *r;\n    directory_config    *dcfg1;\n    directory_config    *dcfg2;\n    directory_config    *usercfg;\n    directory_config    *txcfg;\n\n    unsigned int         reqbody_should_exist;\n    unsigned int         reqbody_chunked;\n\n    unsigned int         phase;\n    unsigned int         phase_request_headers_complete;\n    unsigned int         phase_request_body_complete;\n\n    apr_bucket_brigade  *if_brigade;\n    unsigned int         if_status;\n    unsigned int         if_started_forwarding;\n\n    apr_size_t           reqbody_length;\n\n    apr_bucket_brigade  *of_brigade;\n    unsigned int         of_status;\n    unsigned int         of_done_reading;\n    unsigned int         of_skipping;\n    unsigned int         of_partial;\n    unsigned int         of_is_error;\n\n    unsigned int         resbody_status;\n    apr_size_t           resbody_length;\n    char                *resbody_data;\n    unsigned int         resbody_contains_html;\n\n    apr_size_t           stream_input_length;\n    char                *stream_input_data;\n    apr_size_t           stream_output_length;\n    char                *stream_output_data;\n    unsigned int        of_stream_changed;\n    unsigned int        if_stream_changed;\n\n    apr_array_header_t  *error_messages;\n    apr_array_header_t  *alerts;\n\n    const char          *txid;\n    const char          *sessionid;\n    const char          *userid;\n\n    const char          *server_software;\n    const char          *local_addr;\n    unsigned int         local_port;\n    const char          *local_user;\n\n    /* client */\n\n    const char          *remote_addr;\n    unsigned int         remote_port;\n    const char          *remote_user;\n\n    /* useragent */\n    const char          *useragent_ip;\n\n    /* request */\n\n    const char          *request_line;\n    const char          *request_method;\n    const char          *request_uri;\n    const char          *query_string;\n    const char          *request_protocol;\n\n    const char          *hostname;\n\n    apr_table_t         *request_headers;\n\n    apr_off_t            request_content_length;\n    const char          *request_content_type;\n\n    apr_table_t         *arguments;\n    apr_table_t         *arguments_to_sanitize;\n    apr_table_t         *request_headers_to_sanitize;\n    apr_table_t         *response_headers_to_sanitize;\n    apr_table_t         *request_cookies;\n    apr_table_t         *pattern_to_sanitize;\n\n    unsigned int        urlencoded_error;\n    unsigned int        inbound_error;\n    unsigned int        outbound_error;\n\n    unsigned int         is_relevant;\n\n    apr_table_t         *tx_vars;\n\n    /* ENH: refactor to allow arbitrary var tables */\n    apr_table_t         *geo_vars;\n\n    /* response */\n    unsigned int         response_status;\n    const char          *status_line;\n    const char          *response_protocol;\n    apr_table_t         *response_headers;\n    unsigned int         response_headers_sent;\n    apr_off_t            bytes_sent;\n\n    /* modsecurity request body processing stuff */\n\n    unsigned int         msc_reqbody_storage;       /* on disk or in memory */\n    unsigned int         msc_reqbody_spilltodisk;\n    unsigned int         msc_reqbody_read;\n\n    apr_pool_t          *msc_reqbody_mp;             /* this is where chunks are allocated from  */\n    apr_array_header_t  *msc_reqbody_chunks;         /* data chunks when stored in memory        */\n    unsigned int         msc_reqbody_length;         /* the amount of data received              */\n    int                  msc_reqbody_chunk_position; /* used when retrieving the body            */\n    unsigned int         msc_reqbody_chunk_offset;   /* offset of the chunk currently in use     */\n    msc_data_chunk      *msc_reqbody_chunk_current;  /* current chunk                            */\n    char                *msc_reqbody_buffer;\n\n    const char          *msc_reqbody_filename;       /* when stored on disk */\n    int                  msc_reqbody_fd;\n    msc_data_chunk      *msc_reqbody_disk_chunk;\n\n    const char          *msc_reqbody_processor;\n    int                  msc_reqbody_error;\n    const char          *msc_reqbody_error_msg;\n\n    apr_size_t           msc_reqbody_no_files_length;\n\n    char                *multipart_filename;\n    char                *multipart_name;\n    multipart_data      *mpd;                        /* MULTIPART processor data structure */\n\n    xml_data            *xml;                        /* XML processor data structure       */\n\n    /* audit logging */\n    char                *new_auditlog_boundary;\n    char                *new_auditlog_filename;\n    apr_file_t          *new_auditlog_fd;\n    unsigned int         new_auditlog_size;\n    apr_md5_ctx_t        new_auditlog_md5ctx;\n\n    unsigned int         was_intercepted;\n    unsigned int         rule_was_intercepted;\n    unsigned int         intercept_phase;\n    msre_actionset      *intercept_actionset;\n    const char          *intercept_message;\n\n    /* performance measurement */\n    apr_time_t       request_time;\n    apr_time_t\t\t time_phase1;\n    apr_time_t\t\t time_phase2;\n    apr_time_t\t\t time_phase3;\n    apr_time_t\t\t time_phase4;\n    apr_time_t\t\t time_phase5;\n    apr_time_t\t\t time_storage_read;\n    apr_time_t\t\t time_storage_write;\n    apr_time_t\t\t time_logging;\n    apr_time_t\t\t time_gc;\n    apr_table_t      *perf_rules;\n\n    apr_array_header_t  *matched_rules;\n    msc_string          *matched_var;\n    int                  highest_severity;\n\n    /* upload */\n    int                  upload_extract_files;\n    int                  upload_remove_files;\n    int                  upload_files_count;\n\n    /* other */\n    apr_table_t         *collections_original;\n    apr_table_t         *collections;\n    apr_table_t         *collections_dirty;\n\n    /* rule processing temp pool */\n    apr_pool_t          *msc_rule_mptmp;\n\n    /* content injection */\n    const char          *content_prepend;\n    apr_off_t            content_prepend_len;\n    const char          *content_append;\n    apr_off_t            content_append_len;\n\n    /* data cache */\n    apr_hash_t          *tcache;\n    apr_size_t           tcache_items;\n\n    /* removed rules */\n    apr_array_header_t  *removed_rules;\n    apr_array_header_t  *removed_rules_tag;\n    apr_array_header_t  *removed_rules_msg;\n\n    /* removed targets */\n    apr_table_t         *removed_targets;\n\n    /* When \"allow\" is executed the variable below is\n     * updated to contain the scope of the allow action. Set\n     * at 0 by default, it will have ACTION_ALLOW if we are\n     * to allow phases 1-4 and ACTION_ALLOW_REQUEST if we\n     * are to allow phases 1-2 only.\n     */\n    unsigned int         allow_scope;\n\n    /* matched vars */\n    apr_table_t         *matched_vars;\n\n    /* Generic request body processor context to be used by custom parsers. */\n    void                *reqbody_processor_ctx;\n\n    htmlDocPtr          crypto_html_tree;\n#if defined(WITH_LUA)\n    #ifdef CACHE_LUA\n    lua_State           *L;\n    #endif\n#endif\n};\n\nstruct directory_config {\n    apr_pool_t          *mp;\n\n    msre_ruleset        *ruleset;\n\n    int                  is_enabled;\n    int                  reqbody_access;\n    int                  reqintercept_oe;\n    int                  reqbody_buffering;\n    long int             reqbody_inmemory_limit;\n    long int             reqbody_limit;\n    long int             reqbody_no_files_limit;\n    int                  resbody_access;\n\n    long int             of_limit;\n    apr_table_t         *of_mime_types;\n    int                  of_mime_types_cleared;\n    int                  of_limit_action;\n    int                  if_limit_action;\n\n    const char          *debuglog_name;\n    int                  debuglog_level;\n    apr_file_t          *debuglog_fd;\n\n    int                  cookie_format;\n    int                  argument_separator;\n    const char           *cookiev0_separator;\n\n    int                  rule_inheritance;\n    apr_array_header_t  *rule_exceptions;\n\n\n    /* -- Audit log -- */\n\n    /* Max rule time */\n    int                  max_rule_time;\n\n    /* Whether audit log should be enabled in the context or not */\n    int                  auditlog_flag;\n\n    /* AUDITLOG_SERIAL (single file) or AUDITLOG_CONCURRENT (multiple files) */\n    int                  auditlog_type;\n\n    /* Mode for audit log directories and files */\n    apr_fileperms_t      auditlog_dirperms;\n    apr_fileperms_t      auditlog_fileperms;\n\n    /* The name of the audit log file (for the old type), or the\n     * name of the index file (for the new audit log type)\n     */\n    char                *auditlog_name;\n    /* The name of the secondary index file */\n    char                *auditlog2_name;\n\n    /* The file descriptors for the files above */\n    apr_file_t          *auditlog_fd;\n    apr_file_t          *auditlog2_fd;\n\n    /* For the new-style audit log only, the path where\n     * audit log entries will be stored\n     */\n    char                *auditlog_storage_dir;\n\n    /* A list of parts to include in the new-style audit log\n     * entry. By default, it contains 'ABCFHZ'. Have a look at\n     * the AUDITLOG_PART_* constants above to decipher the\n     * meaning.\n     */\n    char                *auditlog_parts;\n\n    /* A regular expression that determines if a response\n     * status is treated as relevant.\n     */\n    msc_regex_t         *auditlog_relevant_regex;\n\n    /* Upload */\n    const char          *tmp_dir;\n    const char          *upload_dir;\n    int                  upload_keep_files;\n    int                  upload_validates_files;\n    int                  upload_filemode; /* int only so NOT_SET works */\n    int                  upload_file_limit;\n\n    /* Used only in the configuration phase. */\n    msre_rule           *tmp_chain_starter;\n    msre_actionset      *tmp_default_actionset;\n    apr_table_t         *tmp_rule_placeholders;\n\n    /* Misc */\n    const char          *data_dir;\n    const char          *webappid;\n    const char          *sensor_id;\n    const char          *httpBlkey;\n\n    /* Content injection. */\n    int                  content_injection_enabled;\n\n    /* Stream Inspection */\n    int                 stream_inbody_inspection;\n    int                 stream_outbody_inspection;\n\n    /* Geo Lookup */\n    geo_db              *geo;\n\n    /* Gsb Lookup */\n    gsb_db              *gsb;\n\n    /* Unicode map */\n    unicode_map         *u_map;\n\n    /* Cache */\n    int                  cache_trans;\n    int                  cache_trans_incremental;\n    apr_size_t           cache_trans_min;\n    apr_size_t           cache_trans_max;\n    apr_size_t           cache_trans_maxitems;\n\n    /* Array to hold signatures of components, which will\n     * appear in the ModSecurity signature in the audit log.\n     */\n    apr_array_header_t  *component_signatures;\n\n    /* Request character encoding. */\n    const char          *request_encoding;\n\n    int disable_backend_compression;\n\n    /* Collection timeout */\n    int col_timeout;\n\n    /* hash of ids */\n    apr_hash_t          *rule_id_htab;\n\n    /* Hash */\n    apr_array_header_t  *hash_method;\n    const char *crypto_key;\n    int                 crypto_key_len;\n    const char          *crypto_param_name;\n    int                 hash_is_enabled;\n    int                 hash_enforcement;\n    int                 crypto_key_add;\n    int                 crypto_hash_href_rx;\n    int                 crypto_hash_faction_rx;\n    int                 crypto_hash_location_rx;\n    int                 crypto_hash_iframesrc_rx;\n    int                 crypto_hash_framesrc_rx;\n    int                 crypto_hash_href_pm;\n    int                 crypto_hash_faction_pm;\n    int                 crypto_hash_location_pm;\n    int                 crypto_hash_iframesrc_pm;\n    int                 crypto_hash_framesrc_pm;\n\n    /* xml */\n    int                 xml_external_entity;\n};\n\nstruct error_message_t {\n    const char          *file;\n    int                  line;\n    int                  level;\n    apr_status_t         status;\n    const char          *message;\n};\n\nstruct msc_engine {\n    apr_pool_t              *mp;\n    apr_global_mutex_t      *auditlog_lock;\n    apr_global_mutex_t      *geo_lock;\n    msre_engine             *msre;\n    unsigned int             processing_mode;\n};\n\nstruct msc_data_chunk {\n    char                    *data;\n    apr_size_t               length;\n    unsigned int             is_permanent;\n};\n\nstruct msc_arg {\n    const char              *name;\n    unsigned int             name_len;\n    unsigned int             name_origin_offset;\n    unsigned int             name_origin_len;\n    const char              *value;\n    unsigned int             value_len;\n    unsigned int             value_origin_offset;\n    unsigned int             value_origin_len;\n    const char              *origin;\n};\n\nstruct msc_string {\n    char                    *name;\n    unsigned int             name_len;\n    char                    *value;\n    unsigned int             value_len;\n};\n\nstruct msc_parm {\n    char                    *value;\n    int                     pad_1;\n    int                     pad_2;\n};\n\n/* Engine functions */\n\nmsc_engine DSOLOCAL *modsecurity_create(apr_pool_t *mp, int processing_mode);\n\nint DSOLOCAL modsecurity_init(msc_engine *msce, apr_pool_t *mp);\n\nvoid DSOLOCAL modsecurity_child_init(msc_engine *msce);\n\nvoid DSOLOCAL modsecurity_shutdown(msc_engine *msce);\n\napr_status_t DSOLOCAL modsecurity_tx_init(modsec_rec *msr);\n\napr_status_t DSOLOCAL modsecurity_process_phase(modsec_rec *msr, unsigned int phase);\n\n\n/* Request body functions */\n\napr_status_t DSOLOCAL modsecurity_request_body_start(modsec_rec *msr, char **error_msg);\n\napr_status_t DSOLOCAL modsecurity_request_body_store(modsec_rec *msr,\n    const char *data, apr_size_t length, char **error_msg);\n\napr_status_t DSOLOCAL modsecurity_request_body_end(modsec_rec *msr, char **error_msg);\n\napr_status_t DSOLOCAL modsecurity_request_body_to_stream(modsec_rec *msr, const char *buffer, int buflen, char **error_msg);\n\napr_status_t DSOLOCAL modsecurity_request_body_retrieve_start(modsec_rec *msr, char **error_msg);\n\napr_status_t DSOLOCAL modsecurity_request_body_retrieve_end(modsec_rec *msr);\n\n/* Retrieves up to nbytes bytes of the request body. Returns 1 on\n * success, 0 when there is no more data, or -1 on error. On return\n * nbytes will contain the number of bytes stored in the buffer.\n */\napr_status_t DSOLOCAL modsecurity_request_body_retrieve(modsec_rec *msr, msc_data_chunk **chunk,\n    long int nbytes, char **error_msg);\n\nvoid DSOLOCAL msc_add(modsec_rec *msr, int level, msre_actionset *actionset,\n    const char *action_message, const char *rule_message);\n\nconst char DSOLOCAL *msc_alert_message(modsec_rec *msr, msre_actionset *actionset, const char *action_message,\n    const char *rule_message);\n\nvoid DSOLOCAL msc_alert(modsec_rec *msr, int level, msre_actionset *actionset, const char *action_message,\n    const char *rule_message);\n\napr_status_t DSOLOCAL modsecurity_request_body_clear(modsec_rec *msr, char **error_msg);\n\n#endif\n", "/*\n* ModSecurity for Apache 2.x, http://www.modsecurity.org/\n* Copyright (c) 2004-2011 Trustwave Holdings, Inc. (http://www.trustwave.com/)\n*\n* You may not use this file except in compliance with\n* the License. \u00a0You may obtain a copy of the License at\n*\n* \u00a0 \u00a0 http://www.apache.org/licenses/LICENSE-2.0\n*\n* If any of the files related to licensing are missing or if you have any\n* other questions related to licensing please contact Trustwave Holdings, Inc.\n* directly using the email address security@modsecurity.org.\n*/\n\n#include \"msc_xml.h\"\n\nstatic xmlParserInputBufferPtr\nxml_unload_external_entity(const char *URI, xmlCharEncoding enc)    {\n    return NULL;\n}\n\n\n/**\n * Initialise XML parser.\n */\nint xml_init(modsec_rec *msr, char **error_msg) {\n    xmlParserInputBufferCreateFilenameFunc entity;\n\n    if (error_msg == NULL) return -1;\n    *error_msg = NULL;\n\n    msr->xml = apr_pcalloc(msr->mp, sizeof(xml_data));\n    if (msr->xml == NULL) return -1;\n\n    if(msr->txcfg->xml_external_entity == 0)    {\n        entity = xmlParserInputBufferCreateFilenameDefault(xml_unload_external_entity);\n    }\n\n    return 1;\n}\n\n#if 0\nstatic void xml_receive_sax_error(void *data, const char *msg, ...) {\n    modsec_rec *msr = (modsec_rec *)data;\n    char message[256];\n\n    if (msr == NULL) return;\n\n    apr_snprintf(message, sizeof(message), \"%s (line %d offset %d)\",\n        log_escape_nq(msr->mp, msr->xml->parsing_ctx->lastError.message),\n        msr->xml->parsing_ctx->lastError.line,\n        msr->xml->parsing_ctx->lastError.int2);\n\n    msr_log(msr, 5, \"XML: Parsing error: %s\", message);\n}\n#endif\n\n/**\n * Feed one chunk of data to the XML parser.\n */\nint xml_process_chunk(modsec_rec *msr, const char *buf, unsigned int size, char **error_msg) {\n    if (error_msg == NULL) return -1;\n    *error_msg = NULL;\n\n    /* We want to initialise our parsing context here, to\n     * enable us to pass it the first chunk of data so that\n     * it can attempt to auto-detect the encoding.\n     */\n    if (msr->xml->parsing_ctx == NULL) {\n\n        /* First invocation. */\n\n        msr_log(msr, 4, \"XML: Initialising parser.\");\n\n        /* NOTE When Sax interface is used libxml will not\n         *      create the document object, but we need it.\n\n        msr->xml->sax_handler = (xmlSAXHandler *)apr_pcalloc(msr->mp, sizeof(xmlSAXHandler));\n        if (msr->xml->sax_handler == NULL) return -1;\n        msr->xml->sax_handler->error = xml_receive_sax_error;\n        msr->xml->sax_handler->warning = xml_receive_sax_error;\n        msr->xml->parsing_ctx = xmlCreatePushParserCtxt(msr->xml->sax_handler, msr,\n            buf, size, \"body.xml\");\n\n        */\n\n        msr->xml->parsing_ctx = xmlCreatePushParserCtxt(NULL, NULL, buf, size, \"body.xml\");\n        if (msr->xml->parsing_ctx == NULL) {\n            *error_msg = apr_psprintf(msr->mp, \"XML: Failed to create parsing context.\");\n            return -1;\n        }\n    } else {\n\n        /* Not a first invocation. */\n\n        xmlParseChunk(msr->xml->parsing_ctx, buf, size, 0);\n        if (msr->xml->parsing_ctx->wellFormed != 1) {\n            *error_msg = apr_psprintf(msr->mp, \"XML: Failed parsing document.\");\n            return -1;\n        }\n    }\n\n    return 1;\n}\n\n/**\n * Finalise XML parsing.\n */\nint xml_complete(modsec_rec *msr, char **error_msg) {\n    if (error_msg == NULL) return -1;\n    *error_msg = NULL;\n\n    /* Only if we have a context, meaning we've done some work. */\n    if (msr->xml->parsing_ctx != NULL) {\n        /* This is how we signalise the end of parsing to libxml. */\n        xmlParseChunk(msr->xml->parsing_ctx, NULL, 0, 1);\n\n        /* Preserve the results for our reference. */\n        msr->xml->well_formed = msr->xml->parsing_ctx->wellFormed;\n        msr->xml->doc = msr->xml->parsing_ctx->myDoc;\n\n        /* Clean up everything else. */\n        xmlFreeParserCtxt(msr->xml->parsing_ctx);\n        msr->xml->parsing_ctx = NULL;\n        msr_log(msr, 4, \"XML: Parsing complete (well_formed %u).\", msr->xml->well_formed);\n\n        if (msr->xml->well_formed != 1) {\n            *error_msg = apr_psprintf(msr->mp, \"XML: Failed parsing document.\");\n            return -1;\n        }\n    }\n\n    return 1;\n}\n\n/**\n * Frees the resources used for XML parsing.\n */\napr_status_t xml_cleanup(modsec_rec *msr) {\n    if (msr->xml->doc != NULL) {\n        xmlFreeDoc(msr->xml->doc);\n        msr->xml->doc = NULL;\n    }\n\n    return 1;\n}\n"], "filenames": ["apache2/apache2_config.c", "apache2/modsecurity.h", "apache2/msc_xml.c"], "buggy_code_start_loc": [157, 597, 16], "buggy_code_end_loc": [3225, 597, 26], "fixing_code_start_loc": [158, 598, 17], "fixing_code_end_loc": [3270, 601, 38], "type": "CWE-611", "message": "ModSecurity before 2.7.3 allows remote attackers to read arbitrary files, send HTTP requests to intranet servers, or cause a denial of service (CPU and memory consumption) via an XML external entity declaration in conjunction with an entity reference, aka an XML External Entity (XXE) vulnerability.", "other": {"cve": {"id": "CVE-2013-1915", "sourceIdentifier": "secalert@redhat.com", "published": "2013-04-25T23:55:01.530", "lastModified": "2021-02-12T17:27:08.113", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ModSecurity before 2.7.3 allows remote attackers to read arbitrary files, send HTTP requests to intranet servers, or cause a denial of service (CPU and memory consumption) via an XML external entity declaration in conjunction with an entity reference, aka an XML External Entity (XXE) vulnerability."}, {"lang": "es", "value": "ModSecurity antes de v2.7.3 permite a atacantes remotos leer archivos arbitrarios, enviar peticiones HTTP a los servidores de la intranet, o causar una denegaci\u00f3n de servicio (consumo de CPU y memoria) a trav\u00e9s de una declaraci\u00f3n de entidad externa XML junto con una referencia de entidad, tambi\u00e9n conocido como una Entidad Externa XML (XXE) vulnerabilidad."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-611"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:trustwave:modsecurity:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.7.3", "matchCriteriaId": "09CE7AA4-96F3-4001-986B-DE288F2F16E0"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:11.4:*:*:*:*:*:*:*", "matchCriteriaId": "DE554781-1EB9-446E-911F-6C11970C47F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:12.2:*:*:*:*:*:*:*", "matchCriteriaId": "D806A17E-B8F9-466D-807D-3F1E77603DC8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:12.3:*:*:*:*:*:*:*", "matchCriteriaId": "DFBF430B-0832-44B0-AA0E-BA9E467F7668"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:17:*:*:*:*:*:*:*", "matchCriteriaId": "2DA9D861-3EAF-42F5-B0B6-A4CD7BDD6188"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:18:*:*:*:*:*:*:*", "matchCriteriaId": "E14271AE-1309-48F3-B9C6-D7DEEC488279"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:19:*:*:*:*:*:*:*", "matchCriteriaId": "5991814D-CA77-4C25-90D2-DB542B17E0AD"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "036E8A89-7A16-411F-9D31-676313BB7244"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "16F59A04-14CF-49E2-9973-645477EA09DA"}]}]}], "references": [{"url": "http://lists.fedoraproject.org/pipermail/package-announce/2013-April/101898.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2013-April/101911.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2013-April/102616.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2013-08/msg00020.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2013-08/msg00025.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2013-08/msg00031.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.debian.org/security/2013/dsa-2659", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.mandriva.com/security/advisories?name=MDVSA-2013:156", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2013/04/03/7", "source": "secalert@redhat.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/58810", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=947842", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/SpiderLabs/ModSecurity/blob/master/CHANGES", "source": "secalert@redhat.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/SpiderLabs/ModSecurity/commit/d4d80b38aa85eccb26e3c61b04d16e8ca5de76fe", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/SpiderLabs/ModSecurity/commit/d4d80b38aa85eccb26e3c61b04d16e8ca5de76fe"}}