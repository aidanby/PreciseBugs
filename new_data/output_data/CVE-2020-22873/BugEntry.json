{"buggy_code": ["/* jsi.h : External API header file for Jsi. */\n#ifndef __JSI_H__\n#define __JSI_H__\n\n#define JSI_VERSION_MAJOR   3\n#define JSI_VERSION_MINOR   0\n#define JSI_VERSION_RELEASE 6\n\n#define JSI_VERSION (JSI_VERSION_MAJOR + ((Jsi_Number)JSI_VERSION_MINOR/100.0) + ((Jsi_Number)JSI_VERSION_RELEASE/10000.0))\n\n#ifndef JSI_EXTERN\n#define JSI_EXTERN extern\n#endif\n\n#ifdef offsetof\n#define Jsi_Offset(type, field) ((long) offsetof(type, field))\n#else\n#define Jsi_Offset(type, field) ((long) ((char *) &((type *) 0)->field))\n#endif\n\n#ifndef __GNUC__\n#define __attribute__(X)\n#endif\n\n#ifndef __USE_XOPEN\n#define __USE_XOPEN\n#endif\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n\n#ifdef __WIN32\n#define __USE_MINGW_ANSI_STDIO 1\n#endif\n\n#include <stdbool.h>\n#include <inttypes.h>\n#include <stdint.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <stdio.h> \n#include <dirent.h>\n\n/* --TYPEDEFS-- */\ntypedef int64_t Jsi_Wide;\ntypedef uint64_t Jsi_UWide;\ntypedef long double ldouble;\n#ifdef JSI_USE_LONG_DOUBLE\ntypedef ldouble Jsi_Number;\n#define JSI_NUMLMOD \"L\"\n#else\ntypedef double Jsi_Number;\n#define JSI_NUMLMOD\n#endif\ntypedef double time_d;\ntypedef int64_t time_w;\ntypedef uint32_t Jsi_Sig; // Signature field\n\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long ulong;\ntypedef unsigned short ushort;\n#define JSI_NUMGFMT JSI_NUMLMOD \"g\"\n#define JSI_NUMFFMT JSI_NUMLMOD \"f\"\n#define JSI_NUMEFMT JSI_NUMLMOD \"e\"\n/* -- */\n\n\n/* --ENUMS-- */\ntypedef enum {\n    /* Jsi Return Codes. */\n    JSI_OK=0, JSI_ERROR=1, JSI_RETURN=2, JSI_BREAK=3,\n    JSI_CONTINUE=4, JSI_SIGNAL=5, JSI_EXIT=6, JSI_EVAL=7,    \n} Jsi_RC;\n\ntypedef enum {\n    JSI_MAP_NONE, JSI_MAP_HASH, JSI_MAP_TREE, JSI_MAP_LIST /*, JSI_MAP_STACK */\n} Jsi_Map_Type;\n\ntypedef enum {\n    JSI_KEYS_STRING = 0,    // A string that gets stored in hash.\n    JSI_KEYS_STRINGKEY = 1, // A pointer to strings in another hash such as Jsi_KeyLookup()\n    JSI_KEYS_ONEWORD = 2,   // A pointer.\n    JSI_KEYS_RESERVED = 3,  // Unused.\n    JSI_KEYS_STRUCT_MINSIZE = 4 // Any number >= 4 is the number of bytes in a struct/key.\n} Jsi_Key_Type;\n\ntypedef enum {\n    JSI_OT_UNDEF,       /* Undefined */\n    JSI_OT_BOOL,        /* Boolean object, use d.val */\n    JSI_OT_NUMBER,      /* Number object, use d.num */\n    JSI_OT_STRING,      /* String object, use d.str */\n    JSI_OT_OBJECT,      /* Common object */\n    JSI_OT_ARRAY,       /* NOT A REAL TYPE: is just an JSI_OT_OBJECT with array elements */\n    JSI_OT_FUNCTION,    /* Function object, use d.fobj */\n    JSI_OT_REGEXP,      /* RegExp object, use d.robj */\n    JSI_OT_ITER,        /* Iter object, use d.iobj */\n    JSI_OT_USEROBJ,     /* UserDefined object, use d.uobj */\n    JSI_OT__MAX = JSI_OT_USEROBJ\n} Jsi_otype;\n\ntypedef enum {          /* TYPE         CONSTRUCTOR JSI_VALUE-DATA  IMPLICIT-PROTOTYPE  */\n    JSI_VT_UNDEF,       /* undefined    none        none            none                */\n    JSI_VT_BOOL,        /* boolean      Boolean     d.val           none                */\n    JSI_VT_NUMBER,      /* number       Number      d.num           Number.prototype    */\n    JSI_VT_STRING,      /* string       String      d.str           String.prototype    */\n    JSI_VT_OBJECT,      /* object       Jsi_Obj     d.obj           Jsi_Obj.prototype   */\n    JSI_VT_NULL,        /* null         none        none            none                */\n    JSI_VT_VARIABLE,    /* lvalue       none        d.lval          none                */\n    JSI_VT__MAX = JSI_VT_VARIABLE\n} Jsi_vtype;\n\ntypedef enum {\n    JSI_TT_UNDEFINED= (1<<JSI_OT_UNDEF),    //  0x1\n    JSI_TT_BOOLEAN  = (1<<JSI_OT_BOOL),     //  0x2\n    JSI_TT_NUMBER   = (1<<JSI_OT_NUMBER),   //  0x4\n    JSI_TT_STRING   = (1<<JSI_OT_STRING),   //  0x8\n    JSI_TT_OBJECT   = (1<<JSI_OT_OBJECT),   //  0x10\n    JSI_TT_ARRAY    = (1<<JSI_OT_ARRAY),    //  0x20\n    JSI_TT_FUNCTION = (1<<JSI_OT_FUNCTION), //  0x40\n    JSI_TT_REGEXP   = (1<<JSI_OT_REGEXP),   //  0x80\n    JSI_TT_ITEROBJ  = (1<<JSI_OT_ITER),     //  0x100\n    JSI_TT_USEROBJ  = (1<<JSI_OT_USEROBJ),  //  0x200\n    JSI_TT_NULL     = (1<<(JSI_OT_USEROBJ+1)),//0x400\n    JSI_TT_ANY      = (1<<(JSI_OT_USEROBJ+2)),//0x800\n    JSI_TT_VOID     = (1<<(JSI_OT_USEROBJ+3)) //0x1000\n} Jsi_ttype;\n\ntypedef enum {\n    /* General flags. */\n    JSI_NONE=0, JSI_NO_ERRMSG=1, \n    JSI_CMP_NOCASE=1, JSI_CMP_CHARSET_SCAN=2,\n    JSI_CMP_EXACT=0x4,\n    JSI_EVAL_ARGV0=0x1, JSI_EVAL_GLOBAL=0x2, JSI_EVAL_NOSKIPBANG=0x4, JSI_EVAL_AUTOINDEX=0x8,\n    JSI_EVAL_RETURN         =0x10, // Return top of stack as result\n    JSI_EVAL_ONCE           =0x20, // Source files only once.\n    JSI_EVAL_ISMAIN         =0x40, // Set isMain to true.\n    JSI_EVAL_EXISTS         =0x80, // Source if exists.\n    JSI_EVAL_ERRIGNORE      =0x100,// Source ignores errors.\n\n    /* Flags for Jsi_CmdProc */\n    JSI_CALL_CONSTRUCTOR    =0x1,\n    JSI_CALL_BUILTIN        =0x2,\n    \n    JSI_CMDSPEC_ISOBJ       = 0x1,\n    JSI_CMDSPEC_PROTO       = 0x2,\n    JSI_CMDSPEC_NONTHIS     = 0x4,\n    JSI_CMDSPEC_SUBCMDS     = 0x8,      // Has sub-commands.\n    \n    JSI_CMD_HAS_ATTR        = 0x100,\n    JSI_CMD_IS_CONSTRUCTOR  = 0x200,\n    JSI_CMD_IS_OBJ          = 0x400,\n    JSI_CMD_LOG_TEST        = 0x1000,\n    JSI_CMD_LOG_DEBUG       = 0x2000,\n    JSI_CMD_LOG_TRACE       = 0x4000,\n    JSI_CMD_MASK            = 0xffff,\n    \n    JSI_OM_READONLY         = 0x01,     /* ecma read-only */\n    JSI_OM_DONTENUM         = 0x02,     /* ecma emumerable */\n    JSI_OM_DONTDEL          = 0x04,     /* ecma configurable */\n    JSI_OM_INNERSHARED      = 0x08,\n    JSI_OM_ISARRAYLIST      = 0x10,\n    JSI_OM_ISSTRKEY         = 0x20,\n    JSI_OM_UNUSED           = 0x40,\n    JSI_OM_ISSTATIC         = 0x80,\n    \n    JSI_INTACCESS_READ      = 0x0,\n    JSI_INTACCESS_WRITE     = 0x1,\n    JSI_INTACCESS_NETWORK   = 0x2,\n    JSI_INTACCESS_SETSSL    = 0x3,\n    JSI_INTACCESS_MAININTERP= 0x4,\n    JSI_INTACCESS_CREATE    = 0x5,\n    \n    JSI_LOG_BUG=0,   JSI_LOG_ERROR,   JSI_LOG_WARN,\n    JSI_LOG_INFO,    JSI_LOG_UNUSED,  JSI_LOG_PARSE,\n    JSI_LOG_TEST,    JSI_LOG_DEBUG,   JSI_LOG_TRACE,\n    JSI__LOGLAST=JSI_LOG_TRACE,\n    \n    JSI_SORT_NOCASE = 0x1, JSI_SORT_DESCEND = 0x2, JSI_SORT_DICT = 0x4,\n    \n    JSI_NAME_FUNCTIONS = 0x1, JSI_NAME_DATA = 0x2,\n    \n    JSI_TREE_ORDER_IN=0, JSI_TREE_ORDER_PRE=0x10, JSI_TREE_ORDER_POST=0x20, // Jsi_TreeSearchFirst()\n    JSI_TREE_ORDER_LEVEL=0x30, JSI_TREE_ORDER_MASK=0x30,\n    JSI_TREE_SEARCH_KEY=0x10, // Use key even if NULL\n    JSI_TREE_USERFLAG_MASK=0x7f,\n    JSI_LIST_REVERSE=0x8, // Jsi_ListSearchFirst\n    JSI_MUTEX_RECURSIVE=2,\n    \n    JSI_FS_NOCLOSE=0x1, JSI_FS_READONLY=0x2, JSI_FS_WRITEONLY=0x4, JSI_FS_APPEND=0x8,\n    JSI_FS_COMPRESS=0x100,\n    JSI_FSMODESIZE=15,\n    JSI_FILE_TYPE_FILES=0x1, JSI_FILE_TYPE_DIRS=0x2,    JSI_FILE_TYPE_MOUNT=0x4,\n    JSI_FILE_TYPE_LINK=0x8,  JSI_FILE_TYPE_PIPE=0x10,   JSI_FILE_TYPE_BLOCK=0x20,\n    JSI_FILE_TYPE_CHAR=0x40, JSI_FILE_TYPE_SOCKET=0x80, JSI_FILE_TYPE_HIDDEN=0x100,\n    \n    JSI_OUTPUT_QUOTE = 0x1,\n    JSI_OUTPUT_JSON = 0x2,\n    JSI_OUTPUT_NEWLINES = 0x4,\n    JSI_OUTPUT_STDERR = 0x8,\n    JSI_JSON_STATIC_DEFAULT =100,\n    JSI_JSON_STRICT   = 0x101, /* property names must be quoted. */\n    JSI_STUBS_STRICT  = 0x1, JSI_STUBS_SIG = 0xdeadaa00, JSI_SIG_TYPEDEF,\n    JSI_SIG_OPTS = 0xdeadab00,\n    JSI_SIG_OPTS_STRUCT, JSI_SIG_OPTS_ENUM, JSI_SIG_OPTS_VARDEF, JSI_SIG_OPTS_FIELD,\n    JSI_SIG_OPTS_USER1=0xdeadab20,\n\n    JSI_EVENT_TIMER=0, JSI_EVENT_SIGNAL=1, JSI_EVENT_ALWAYS=2,\n    JSI_ZIP_MAIN=0x1,  JSI_ZIP_INDEX=0x2,\n\n    JSI_DBI_READONLY     =0x0001, /* Db is created readonly */\n    JSI_DBI_NOCREATE     =0x0002, /* Db must already exist. */\n    JSI_DBI_NO_MUTEX     =0x0004, /* Disable mutex. */\n    JSI_DBI_FULL_MUTEX   =0x0008, /* Use full mutex. */\n    \n    JSI_MAX_NUMBER_STRING=50,\n    JSI_BUFSIZ=8192\n\n} Jsi_Enums; /* Debugging is easier with enums than #define. */\n\n/* -- */\n\n\n/* --STRUCTS-- */\n\ntypedef struct Jsi_Interp Jsi_Interp;\ntypedef struct Jsi_Obj Jsi_Obj;\ntypedef struct Jsi_Value Jsi_Value;\ntypedef struct Jsi_Func Jsi_Func;\ntypedef struct Jsi_IterObj Jsi_IterObj;\ntypedef struct Jsi_FuncObj Jsi_FuncObj;\ntypedef struct Jsi_UserObjReg Jsi_UserObjReg;\ntypedef struct Jsi_UserObj Jsi_UserObj;\ntypedef struct Jsi_HashEntry Jsi_HashEntry;\ntypedef struct Jsi_Hash Jsi_Hash;\ntypedef struct Jsi_HashSearch Jsi_HashSearch;\ntypedef struct Jsi_TreeEntry Jsi_TreeEntry;\ntypedef struct Jsi_Tree Jsi_Tree;\ntypedef struct Jsi_TreeSearch Jsi_TreeSearch;\ntypedef struct Jsi_List Jsi_List;\ntypedef struct Jsi_ListEntry Jsi_ListEntry;\ntypedef struct Jsi_ListSearch Jsi_ListSearch;\ntypedef struct Jsi_Map Jsi_Map;\ntypedef struct Jsi_MapEntry Jsi_MapEntry;\ntypedef struct Jsi_MapSearch Jsi_MapSearch;\ntypedef struct Jsi_Regex_ Jsi_Regex;\ntypedef struct Jsi_Db Jsi_Db;\ntypedef struct Jsi_DbBinds Jsi_DbBinds;\ntypedef struct Jsi_Mutex Jsi_Mutex;\ntypedef struct Jsi_ScopeStrs Jsi_ScopeStrs;\ntypedef struct Jsi_OpCodes Jsi_OpCodes;\ntypedef struct Jsi_Chan* Jsi_Channel;\ntypedef struct Jsi_CS_Ctx Jsi_CS_Ctx;\ntypedef struct Jsi_OptionSpec Jsi_OptionSpec;\n\ntypedef struct Jsi_OptionSpec Jsi_StructSpec;\ntypedef struct Jsi_OptionSpec Jsi_FieldSpec;\ntypedef struct Jsi_OptionSpec Jsi_EnumSpec;\ntypedef struct Jsi_OptionSpec Jsi_VarSpec;\n\ntypedef Jsi_RC (Jsi_InitProc)(Jsi_Interp *interp, int release); // When release>1, the main interp is exiting.\ntypedef Jsi_RC (Jsi_DeleteProc)(Jsi_Interp *interp, void *data);\ntypedef Jsi_RC (Jsi_EventHandlerProc)(Jsi_Interp *interp, void *data);\ntypedef Jsi_RC (Jsi_ValueHandlerProc)(Jsi_Interp *interp, Jsi_Value *v, struct Jsi_OptionSpec* spec, void *record);\ntypedef void (Jsi_DeleteVoidProc)(void *data);\ntypedef Jsi_RC (Jsi_csgset)(Jsi_Interp *interp, void *data, Jsi_Wide *s, Jsi_OptionSpec *spec, int idx, bool isSet);\ntypedef int (Jsi_IterProc)(Jsi_IterObj *iterObj, Jsi_Value *val, Jsi_Value *var, int index);\n\n/* -- */\n\n\n/* --INTERP-- */\n\n/* Options and flags for Jsi_InterpNew/Jsi_Main */\ntypedef struct {\n    int argc;                   // Arguments from main().\n    char **argv;                // ...\n    Jsi_InitProc* initProc;     // Initialization proc\n    uint mem_debug:2;           // Memory debug level;\n    bool no_interactive:1;      // Jsi_Main: does not default to interactive mode when no script arg given.\n    bool auto_delete:1;         // Jsi_Main: auto delete interp upon return.\n    bool no_exit:1;             // Do not exit, even on error.\n    uint reserved:11;           // Reserved for future use.\n    int exitCode:16;            // Call exit with this code.\n    Jsi_Interp* interp;         // Jsi_InterpNew sets this to let Jsi_Main use this interp.\n    void *reserved2[8];         // Reserved for future\n} Jsi_InterpOpts;\n\nJSI_EXTERN Jsi_Interp* Jsi_InterpNew(Jsi_InterpOpts *opts); /*STUB = 1*/\nJSI_EXTERN void Jsi_InterpDelete( Jsi_Interp* interp); /*STUB = 2*/\nJSI_EXTERN void Jsi_InterpOnDelete(Jsi_Interp *interp, Jsi_DeleteProc *freeProc, void *ptr);  /*STUB = 3*/\nJSI_EXTERN Jsi_RC Jsi_Interactive(Jsi_Interp* interp, int flags); /*STUB = 4*/\nJSI_EXTERN bool Jsi_InterpGone( Jsi_Interp* interp); /*STUB = 5*/\nJSI_EXTERN Jsi_Value* Jsi_InterpResult(Jsi_Interp *interp); /*STUB = 6*/\nJSI_EXTERN const char* Jsi_InterpLastError(Jsi_Interp *interp, const char **errFilePtr, int *errLinePtr); /*STUB = 7*/\nJSI_EXTERN void* Jsi_InterpGetData(Jsi_Interp *interp, const char *key, Jsi_DeleteProc **proc); /*STUB = 8*/\nJSI_EXTERN void Jsi_InterpSetData(Jsi_Interp *interp, const char *key, void *data, Jsi_DeleteProc *proc); /*STUB = 9*/\nJSI_EXTERN void Jsi_InterpFreeData(Jsi_Interp *interp, const char *key); /*STUB = 10*/\nJSI_EXTERN bool Jsi_InterpSafe(Jsi_Interp *interp); /*STUB = 11*/\nJSI_EXTERN Jsi_RC Jsi_InterpAccess(Jsi_Interp *interp, Jsi_Value* resource, int aflag); /*STUB = 12*/\nJSI_EXTERN Jsi_Interp* Jsi_Main(Jsi_InterpOpts *opts); /*STUB = 13*/\n/* -- */\n\n\n/* --MEMORY-- */\nJSI_EXTERN void* Jsi_Malloc(uint size); /*STUB = 14*/\nJSI_EXTERN void* Jsi_Calloc(uint n, uint size); /*STUB = 15*/\nJSI_EXTERN void* Jsi_Realloc(void *m, uint size); /*STUB = 16*/\nJSI_EXTERN void  Jsi_Free(void *m); /*STUB = 17*/\nJSI_EXTERN int Jsi_ObjIncrRefCount(Jsi_Interp* interp, Jsi_Obj *obj); /*STUB = 18*/\nJSI_EXTERN int Jsi_ObjDecrRefCount(Jsi_Interp* interp, Jsi_Obj *obj); /*STUB = 19*/\nJSI_EXTERN int Jsi_IncrRefCount(Jsi_Interp* interp, Jsi_Value *v); /*STUB = 20*/\nJSI_EXTERN int Jsi_DecrRefCount(Jsi_Interp* interp, Jsi_Value *v); /*STUB = 21*/\nJSI_EXTERN bool Jsi_IsShared(Jsi_Interp* interp, Jsi_Value *v); /*STUB = 22*/\nJSI_EXTERN Jsi_RC Jsi_DeleteData(Jsi_Interp* interp, void *m); /*STUB = 23*/\n/* -- */\n\n\n/* --STRINGS-- */\nJSI_EXTERN uint Jsi_Strlen(const char *str); /*STUB = 24*/\nJSI_EXTERN uint Jsi_StrlenSet(const char *str, uint len); /*STUB = 25*/\nJSI_EXTERN int Jsi_Strcmp(const char *str1, const char *str2); /*STUB = 26*/\nJSI_EXTERN int Jsi_Strncmp(const char *str1, const char *str2, int n); /*STUB = 27*/\nJSI_EXTERN int Jsi_Strncasecmp(const char *str1, const char *str2, int n); /*STUB = 28*/\nJSI_EXTERN int Jsi_StrcmpDict(const char *str1, const char *str2, int nocase, int dict); /*STUB = 29*/\nJSI_EXTERN char* Jsi_Strcpy(char *dst, const char *src); /*STUB = 30*/\nJSI_EXTERN char* Jsi_Strncpy(char *dst, const char *src, int len); /*STUB = 31*/\nJSI_EXTERN char* Jsi_Strdup(const char *n); /*STUB = 32*/\nJSI_EXTERN char* Jsi_StrdupLen(const char *str, int len); /*STUB = 407*/\nJSI_EXTERN char* Jsi_Strrchr(const char *str, int c); /*STUB = 33*/\nJSI_EXTERN char* Jsi_Strstr(const char *str, const char *sub); /*STUB = 34*/\nJSI_EXTERN char* Jsi_Strrstr(const char *str, const char *sub); /*STUB = 233*/ \nJSI_EXTERN char* Jsi_Strchr(const char *str, int c); /*STUB = 36*/\nJSI_EXTERN int Jsi_Strpos(const char *str, int start, const char *nid, int nocase); /*STUB = 37*/\nJSI_EXTERN int Jsi_Strrpos(const char *str, int start, const char *nid, int nocase); /*STUB = 38*/\nJSI_EXTERN bool Jsi_StrIsAlnum(const char *cp); /*STUB = 416*/\n#define Jsi_Stzcpy(buf,src) Jsi_Strncpy(buf, src, sizeof(buf))\n\n/* Dynamic strings. */\n#ifndef JSI_DSTRING_STATIC_SIZE\n#define JSI_DSTRING_STATIC_SIZE 200\n#endif\n\ntypedef struct {\n#define JSI_DSTRING_DECL_FIELDS(siz) \\\n    const char *strA; /* Allocated string, or = {\"string\"}.*/ \\\n    uint len;       /* Length of string. */ \\\n    uint spaceAvl;  /* Amount of space available or allocated. */ \\\n    uint staticSize;/* The sizeof \"Str\", or 0 if used \"= {}\" */ \\\n    char Str[siz];  /* Static string */\n    JSI_DSTRING_DECL_FIELDS(JSI_DSTRING_STATIC_SIZE)\n} Jsi_DString;\n\n/* Declares a custom Jsi_DString* variable with other than default size... */\n#define JSI_DSTRING_VAR(namPtr, siz) \\\n    struct { JSI_DSTRING_DECL_FIELDS(siz) } _STATIC_##namPtr; \\\n    Jsi_DString *namPtr = (Jsi_DString *)&_STATIC_##namPtr; \\\n    namPtr->staticSize = siz; namPtr->strA=0; \\\n    namPtr->Str[0] = 0; namPtr->spaceAvl = namPtr->len = 0\n\nJSI_EXTERN char*   Jsi_DSAppendLen(Jsi_DString *dsPtr,const char *bytes, int length);  /*STUB = 39*/\nJSI_EXTERN char*   Jsi_DSAppend(Jsi_DString *dsPtr, const char *str, ...)  /*STUB = 40*/  __attribute__((sentinel));\nJSI_EXTERN void    Jsi_DSFree(Jsi_DString *dsPtr);  /*STUB = 41*/\nJSI_EXTERN char*   Jsi_DSFreeDup(Jsi_DString *dsPtr);  /*STUB = 42*/\nJSI_EXTERN void    Jsi_DSInit(Jsi_DString *dsPtr);  /*STUB = 43*/\nJSI_EXTERN uint    Jsi_DSLength(Jsi_DString *dsPtr);  /*STUB = 44*/\nJSI_EXTERN char*   Jsi_DSPrintf(Jsi_DString *dsPtr, const char *fmt, ...)  /*STUB = 45*/ __attribute__((format (printf,2,3)));\nJSI_EXTERN char*   Jsi_DSSet(Jsi_DString *dsPtr, const char *str);  /*STUB = 46*/\nJSI_EXTERN uint    Jsi_DSSetLength(Jsi_DString *dsPtr, uint length);  /*STUB = 47*/\nJSI_EXTERN char*   Jsi_DSValue(Jsi_DString *dsPtr);  /*STUB = 48*/\n/* -- */\n\n\n/* --FUNC/VAR/CMD-- */\ntypedef void (Jsi_DelCmdProc)(Jsi_Interp *interp, void *privData);\ntypedef Jsi_RC (Jsi_CmdProc)(Jsi_Interp *interp, Jsi_Value *args, \n    Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr);\n#define Jsi_CmdProcDecl(name,...) Jsi_RC name(Jsi_Interp *interp, Jsi_Value *args, \\\n    Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr, ##__VA_ARGS__)\n\ntypedef struct Jsi_CmdSpec {\n    const char *name;       /* Cmd name */\n    Jsi_CmdProc *proc;      /* Command handler */\n    int minArgs;\n    int maxArgs;            /* Max args or -1 */\n    const char *argStr;     /* Argument description */\n    const char *help;       /* Short help string. */\n    uint retType;           /* Return type(s) or'ed Jsi_otype. */\n    int flags;              /* JSI_CMD_* flags. */\n    const char *info;       /* Detailed description. Use JSI_DETAIL macro. */\n    Jsi_OptionSpec *opts;   /* Options for arg, default is first. */\n    Jsi_DelCmdProc *delProc;/* Callback to handle command delete. */\n    void *reserved[4];      /* Reserved for internal use. */\n} Jsi_CmdSpec;\n\ntypedef struct {\n    bool Test;\n    bool Debug;\n    bool Trace;\n    int traceCall;\n    bool coverage;\n    bool profile;\n} Jsi_ModuleConf;\n\ntypedef struct {\n    struct Jsi_OptionSpec *spec;\n    void *data;\n    Jsi_CmdSpec *cmdSpec;\n    Jsi_Value *info;\n    void *reserved[3]; // Reserved for future use.\n    Jsi_ModuleConf modConf;\n    void *reserved2[3]; // Reserved for future use.\n} Jsi_PkgOpts;\n\ntypedef struct {\n    char *str;\n    int32_t len;\n    uint32_t flags;\n} Jsi_String;\n\nJSI_EXTERN Jsi_Value* Jsi_CommandCreate(Jsi_Interp *interp, const char *name, Jsi_CmdProc *cmdProc, void *privData); /*STUB = 49*/\nJSI_EXTERN Jsi_Value* Jsi_CommandCreateSpecs(Jsi_Interp *interp, const char *name, Jsi_CmdSpec *cmdSpecs, void *privData, int flags); /*STUB = 50*/\nJSI_EXTERN void* Jsi_CommandNewObj(Jsi_Interp *interp, const char *name, const char *arg1, const char *opts, const char *var);  /*STUB = 51*/\nJSI_EXTERN Jsi_RC Jsi_CommandInvokeJSON(Jsi_Interp *interp, const char *cmd, const char *json, Jsi_Value **ret); /*STUB = 52*/\nJSI_EXTERN Jsi_RC Jsi_CommandInvoke(Jsi_Interp *interp, const char *cmdstr, Jsi_Value *args, Jsi_Value **ret); /*STUB = 53*/\nJSI_EXTERN Jsi_RC Jsi_CommandDelete(Jsi_Interp *interp, const char *name); /*STUB = 54*/\nJSI_EXTERN Jsi_CmdSpec* Jsi_FunctionGetSpecs(Jsi_Func *funcPtr); /*STUB = 55*/\nJSI_EXTERN bool Jsi_FunctionIsConstructor(Jsi_Func *funcPtr); /*STUB = 56*/\nJSI_EXTERN bool Jsi_FunctionReturnIgnored(Jsi_Interp *interp, Jsi_Func *funcPtr); /*STUB = 57*/\nJSI_EXTERN void* Jsi_FunctionPrivData(Jsi_Func *funcPtr); /*STUB = 58*/\nJSI_EXTERN Jsi_RC Jsi_FunctionArguments(Jsi_Interp *interp, Jsi_Value *func, int *argcPtr); /*STUB = 59*/\nJSI_EXTERN Jsi_RC Jsi_FunctionApply(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret); /*STUB = 60*/\nJSI_EXTERN Jsi_RC Jsi_FunctionInvoke(Jsi_Interp *interp, Jsi_Value *tocall, Jsi_Value *args, Jsi_Value **ret, Jsi_Value *_this); /*STUB = 61*/\nJSI_EXTERN Jsi_RC Jsi_FunctionInvokeJSON(Jsi_Interp *interp, Jsi_Value *tocall, const char *json, Jsi_Value **ret); /*STUB = 62*/\nJSI_EXTERN int Jsi_FunctionInvokeBool(Jsi_Interp *interp, Jsi_Value *func, Jsi_Value *arg); /*STUB = 63*/\nJSI_EXTERN Jsi_RC Jsi_FunctionInvokeString(Jsi_Interp *interp, Jsi_Value *func, Jsi_Value *arg, Jsi_DString *dStr); /*STUB = 64*/\nJSI_EXTERN Jsi_Value* Jsi_VarLookup(Jsi_Interp *interp, const char *varname); /*STUB = 65*/\nJSI_EXTERN Jsi_Value* Jsi_NameLookup(Jsi_Interp *interp, const char *varname); /*STUB = 66*/\nJSI_EXTERN Jsi_Value* Jsi_NameLookup2(Jsi_Interp *interp, const char *name, const char *inObj); /*STUB = 67*/\nJSI_EXTERN Jsi_RC Jsi_PkgProvideEx(Jsi_Interp *interp, const char *name, Jsi_Number version, Jsi_InitProc *initProc, Jsi_PkgOpts* popts); /*STUB = 68*/\nJSI_EXTERN Jsi_Number Jsi_PkgRequireEx(Jsi_Interp *interp, const char *name, Jsi_Number version, Jsi_PkgOpts **poptsPtr); /*STUB = 69*/\nJSI_EXTERN Jsi_Number Jsi_PkgVersion(Jsi_Interp *interp, const char *name, const char **filePtr); /*STUB = 70*/\n#define Jsi_PkgRequire(i,n,v) Jsi_PkgRequireEx(i,n,v,NULL)\n#define Jsi_PkgProvide(i,n,v,p) Jsi_PkgProvideEx(i,n,v,p,NULL)\n/* -- */\n\n/* UTF-8 and Unicode */\ntypedef int32_t Jsi_UniChar;\nJSI_EXTERN uint Jsi_NumUtfBytes(char c); /*STUB = 71*/\nJSI_EXTERN uint Jsi_NumUtfChars(const char *utf, int length); /*STUB = 72*/\nJSI_EXTERN uint Jsi_UtfGetIndex(const char *utf, int index, char outbuf[5]); /*STUB = 73*/\nJSI_EXTERN const char* Jsi_UtfAtIndex(const char *utf, int index); /*STUB = 74*/\nJSI_EXTERN uint Jsi_UniCharToUtf(Jsi_UniChar uc, char *dest); /*STUB = 75*/\nJSI_EXTERN uint Jsi_UtfToUniChar(const char *utf, Jsi_UniChar *ch); /*STUB = 76*/\nJSI_EXTERN uint Jsi_UtfToUniCharCase(const char *utf, Jsi_UniChar *ch, int upper); /*STUB = 77*/\nJSI_EXTERN uint Jsi_UtfDecode(const char *str, char* oututf); /*STUB = 78*/\nJSI_EXTERN uint Jsi_UtfEncode(const char *utf, char *outstr); /*STUB = 79*/\nJSI_EXTERN char* Jsi_UtfSubstr(const char *str, int n, int len, Jsi_DString *dStr); /*STUB = 80*/\nJSI_EXTERN int Jsi_UtfIndexToOffset(const char *utf, int index); /*STUB = 81*/\n/* -- */\n\n\n/* --OBJECT-- */\nJSI_EXTERN Jsi_Obj* Jsi_ObjNew(Jsi_Interp* interp); /*STUB = 82*/\nJSI_EXTERN Jsi_Obj* Jsi_ObjNewType(Jsi_Interp* interp, Jsi_otype type); /*STUB = 83*/\nJSI_EXTERN void Jsi_ObjFree(Jsi_Interp* interp, Jsi_Obj *obj); /*STUB = 84*/\nJSI_EXTERN Jsi_Obj* Jsi_ObjNewObj(Jsi_Interp *interp, Jsi_Value **items, int count); /*STUB = 85*/\nJSI_EXTERN Jsi_Obj* Jsi_ObjNewArray(Jsi_Interp *interp, Jsi_Value **items, int count, int copy); /*STUB = 86*/\n\nJSI_EXTERN bool      Jsi_ObjIsArray(Jsi_Interp *interp, Jsi_Obj *o); /*STUB = 87*/\nJSI_EXTERN void     Jsi_ObjSetLength(Jsi_Interp *interp, Jsi_Obj *obj, uint len); /*STUB = 88*/\nJSI_EXTERN int      Jsi_ObjGetLength(Jsi_Interp *interp, Jsi_Obj *obj); /*STUB = 89*/\nJSI_EXTERN const char* Jsi_ObjTypeStr(Jsi_Interp *interp, Jsi_Obj *obj); /*STUB = 90*/\nJSI_EXTERN Jsi_otype Jsi_ObjTypeGet(Jsi_Obj *obj); /*STUB = 91*/\nJSI_EXTERN void     Jsi_ObjListifyArray(Jsi_Interp *interp, Jsi_Obj *obj); /*STUB = 92*/\nJSI_EXTERN Jsi_RC      Jsi_ObjArraySet(Jsi_Interp *interp, Jsi_Obj *obj, Jsi_Value *value, int arrayindex); /*STUB = 93*/\nJSI_EXTERN Jsi_RC      Jsi_ObjArrayAdd(Jsi_Interp *interp, Jsi_Obj *o, Jsi_Value *v); /*STUB = 94*/\nJSI_EXTERN Jsi_TreeEntry* Jsi_ObjInsert(Jsi_Interp *interp, Jsi_Obj *obj, const char *key, Jsi_Value *nv, int flags); /*STUB = 95*/\nJSI_EXTERN void    Jsi_ObjFromDS(Jsi_DString *dsPtr, Jsi_Obj *obj);  /*STUB = 96*/\nJSI_EXTERN Jsi_IterObj* Jsi_IterObjNew(Jsi_Interp *interp, Jsi_IterProc *iterProc); /*STUB = 412*/\nJSI_EXTERN void Jsi_IterObjFree(Jsi_IterObj *iobj); /*STUB = 413*/\nJSI_EXTERN void Jsi_IterGetKeys(Jsi_Interp *interp, Jsi_Value *target, Jsi_IterObj *iterobj, int depth); /*STUB = 414*/\nJSI_EXTERN int Jsi_ObjArraySizer(Jsi_Interp *interp, Jsi_Obj *obj, uint n); /*STUB = 35*/\n\nstruct Jsi_IterObj {\n    Jsi_Interp *interp;\n    const char **keys;\n    uint size; \n    uint count;\n    uint iter;\n    bool isArrayList;            /* If an array list do not store keys. */\n    bool isof;\n    Jsi_Obj *obj;\n    uint cur;                    /* Current array cursor. */\n    int depth;                  /* Used to create list of keys. */\n    Jsi_IterProc *iterCmd;\n};\n\n/* -- */\n\n\n/* --VALUE-- */\nJSI_EXTERN Jsi_Value* Jsi_ValueNew(Jsi_Interp *interp); /*STUB = 97*/\nJSI_EXTERN Jsi_Value* Jsi_ValueNew1(Jsi_Interp *interp); /*STUB = 98*/\nJSI_EXTERN void Jsi_ValueFree(Jsi_Interp *interp, Jsi_Value* v); /*STUB = 99*/\n\nJSI_EXTERN Jsi_Value* Jsi_ValueNewNull(Jsi_Interp *interp); /*STUB = 100*/\nJSI_EXTERN Jsi_Value* Jsi_ValueNewBoolean(Jsi_Interp *interp, int bval); /*STUB = 101*/\nJSI_EXTERN Jsi_Value* Jsi_ValueNewNumber(Jsi_Interp *interp, Jsi_Number n); /*STUB = 102*/\nJSI_EXTERN Jsi_Value* Jsi_ValueNewBlob(Jsi_Interp *interp, uchar *s, uint len); /*STUB = 103*/\nJSI_EXTERN Jsi_Value* Jsi_ValueNewString(Jsi_Interp *interp, const char *s, int len); /*STUB = 104*/\nJSI_EXTERN Jsi_Value* Jsi_ValueNewStringKey(Jsi_Interp *interp, const char *s); /*STUB = 105*/\nJSI_EXTERN Jsi_Value* Jsi_ValueNewStringConst(Jsi_Interp *interp, const char *s, int len); /*STUB = 409*/\nJSI_EXTERN Jsi_Value* Jsi_ValueNewStringDup(Jsi_Interp *interp, const char *s); /*STUB = 106*/\nJSI_EXTERN Jsi_Value* Jsi_ValueNewArray(Jsi_Interp *interp, const char **items, int count); /*STUB = 107*/\nJSI_EXTERN Jsi_Value* Jsi_ValueNewObj(Jsi_Interp *interp, Jsi_Obj *o) ; /*STUB = 108*/\n#define Jsi_ValueNewBlobString(interp, s) Jsi_ValueNewBlob(interp, (uchar*)s, Jsi_Strlen(s))\n#define Jsi_ValueNewArrayObj(interp, items, count, copy) Jsi_ValueNewObj(interp, Jsi_ObjNewArray(interp, items, count, copy))\n\nJSI_EXTERN Jsi_RC Jsi_GetStringFromValue(Jsi_Interp* interp, Jsi_Value *value, const char **s); /*STUB = 109*/\nJSI_EXTERN Jsi_RC Jsi_GetNumberFromValue(Jsi_Interp* interp, Jsi_Value *value, Jsi_Number *n); /*STUB = 110*/\nJSI_EXTERN Jsi_RC Jsi_GetBoolFromValue(Jsi_Interp* interp, Jsi_Value *value, bool *n); /*STUB = 111*/\nJSI_EXTERN Jsi_RC Jsi_GetIntFromValue(Jsi_Interp* interp, Jsi_Value *value, int *n); /*STUB = 112*/\nJSI_EXTERN Jsi_RC Jsi_GetLongFromValue(Jsi_Interp* interp, Jsi_Value *value, long *n); /*STUB = 113*/\nJSI_EXTERN Jsi_RC Jsi_GetWideFromValue(Jsi_Interp* interp, Jsi_Value *value, Jsi_Wide *n); /*STUB = 114*/\nJSI_EXTERN Jsi_RC Jsi_GetDoubleFromValue(Jsi_Interp* interp, Jsi_Value *value, Jsi_Number *n); /*STUB = 115*/\nJSI_EXTERN Jsi_RC Jsi_GetIntFromValueBase(Jsi_Interp* interp, Jsi_Value *value, int *n, int base, int flags); /*STUB = 116*/\nJSI_EXTERN Jsi_RC Jsi_ValueGetBoolean(Jsi_Interp *interp, Jsi_Value *pv, bool *val); /*STUB = 117*/\nJSI_EXTERN Jsi_RC Jsi_ValueGetNumber(Jsi_Interp *interp, Jsi_Value *pv, Jsi_Number *val); /*STUB = 118*/\n\nJSI_EXTERN bool Jsi_ValueIsType(Jsi_Interp *interp, Jsi_Value *pv, Jsi_vtype vtype); /*STUB = 119*/\nJSI_EXTERN bool Jsi_ValueIsObjType(Jsi_Interp *interp, Jsi_Value *v, Jsi_otype otype); /*STUB = 120*/\nJSI_EXTERN bool Jsi_ValueIsTrue(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 121*/\nJSI_EXTERN bool Jsi_ValueIsFalse(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 122*/\nJSI_EXTERN bool Jsi_ValueIsNumber(Jsi_Interp *interp, Jsi_Value *pv); /*STUB = 123*/\nJSI_EXTERN bool Jsi_ValueIsArray(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 124*/\nJSI_EXTERN bool Jsi_ValueIsBoolean(Jsi_Interp *interp, Jsi_Value *pv); /*STUB = 125*/\nJSI_EXTERN bool Jsi_ValueIsNull(Jsi_Interp *interp, Jsi_Value *pv); /*STUB = 126*/\nJSI_EXTERN bool Jsi_ValueIsUndef(Jsi_Interp *interp, Jsi_Value *pv); /*STUB = 127*/\nJSI_EXTERN bool Jsi_ValueIsFunction(Jsi_Interp *interp, Jsi_Value *pv); /*STUB = 128*/\nJSI_EXTERN bool Jsi_ValueIsString(Jsi_Interp *interp, Jsi_Value *pv); /*STUB = 129*/\n\nJSI_EXTERN Jsi_Value* Jsi_ValueMakeObject(Jsi_Interp *interp, Jsi_Value **v, Jsi_Obj *o); /*STUB = 130*/\nJSI_EXTERN Jsi_Value* Jsi_ValueMakeArrayObject(Jsi_Interp *interp, Jsi_Value **v, Jsi_Obj *o); /*STUB = 131*/\nJSI_EXTERN Jsi_Value* Jsi_ValueMakeNumber(Jsi_Interp *interp, Jsi_Value **v, Jsi_Number n); /*STUB = 132*/\nJSI_EXTERN Jsi_Value* Jsi_ValueMakeBool(Jsi_Interp *interp, Jsi_Value **v, int b); /*STUB = 133*/\nJSI_EXTERN Jsi_Value* Jsi_ValueMakeString(Jsi_Interp *interp, Jsi_Value **v, const char *s); /*STUB = 134*/\nJSI_EXTERN Jsi_Value* Jsi_ValueMakeStringKey(Jsi_Interp *interp, Jsi_Value **v, const char *s); /*STUB = 135*/\nJSI_EXTERN Jsi_Value* Jsi_ValueMakeBlob(Jsi_Interp *interp, Jsi_Value **v, uchar *s, int len); /*STUB = 136*/\nJSI_EXTERN Jsi_Value* Jsi_ValueMakeNull(Jsi_Interp *interp, Jsi_Value **v); /*STUB = 137*/\nJSI_EXTERN Jsi_Value* Jsi_ValueMakeUndef(Jsi_Interp *interp, Jsi_Value **v); /*STUB = 138*/\nJSI_EXTERN Jsi_Value* Jsi_ValueMakeDStringObject(Jsi_Interp *interp, Jsi_Value **v, Jsi_DString *dsPtr); /*STUB = 139*/\nJSI_EXTERN bool Jsi_ValueIsStringKey(Jsi_Interp* interp, Jsi_Value *key); /*STUB = 140*/\n#define Jsi_ValueMakeStringDup(interp, v, s) Jsi_ValueMakeString(interp, v, Jsi_Strdup(s))\n\nJSI_EXTERN const char*  Jsi_ValueToString(Jsi_Interp *interp, Jsi_Value *v, int *lenPtr); /*STUB = 141*/\nJSI_EXTERN Jsi_RC       Jsi_ValueToBool(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 142*/\nJSI_EXTERN Jsi_RC       Jsi_ValueToNumber(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 143*/\nJSI_EXTERN Jsi_Number   Jsi_ValueToNumberInt(Jsi_Interp *interp, Jsi_Value *v, int isInt); /*STUB = 144*/\nJSI_EXTERN Jsi_RC       Jsi_ValueToObject(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 145*/\n\nJSI_EXTERN void     Jsi_ValueReset(Jsi_Interp *interp, Jsi_Value **v); /*STUB = 146*/\nJSI_EXTERN const char* Jsi_ValueGetDString(Jsi_Interp* interp, Jsi_Value* v, Jsi_DString *dStr, int quote); /*STUB = 147*/\nJSI_EXTERN char*    Jsi_ValueString(Jsi_Interp* interp, Jsi_Value* v, int *lenPtr); /*STUB = 148*/\nJSI_EXTERN uchar*   Jsi_ValueBlob(Jsi_Interp *interp, Jsi_Value* v, int *lenPtr); /*STUB = 149*/\nJSI_EXTERN char*    Jsi_ValueGetStringLen(Jsi_Interp *interp, Jsi_Value *pv, int *lenPtr); /*STUB = 150*/\nJSI_EXTERN int      Jsi_ValueStrlen(Jsi_Value* v); /*STUB = 151*/\nJSI_EXTERN void     Jsi_ValueFromDS(Jsi_Interp *interp, Jsi_DString *dsPtr, Jsi_Value **ret);  /*STUB = 152*/\nJSI_EXTERN int      Jsi_ValueInstanceOf( Jsi_Interp *interp, Jsi_Value* v1, Jsi_Value* v2); /*STUB = 153*/\nJSI_EXTERN Jsi_Obj* Jsi_ValueGetObj(Jsi_Interp* interp, Jsi_Value* v); /*STUB = 154*/\nJSI_EXTERN Jsi_vtype Jsi_ValueTypeGet(Jsi_Value *pv); /*STUB = 155*/\nJSI_EXTERN const char* Jsi_ValueTypeStr(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 156*/\nJSI_EXTERN int      Jsi_ValueCmp(Jsi_Interp *interp, Jsi_Value *v1, Jsi_Value* v2, int cmpFlags); /*STUB = 157*/\nJSI_EXTERN Jsi_RC Jsi_ValueGetIndex( Jsi_Interp *interp, Jsi_Value *valPtr, const char **tablePtr, const char *msg, int flags, int *indexPtr); /*STUB = 158*/\n\nJSI_EXTERN Jsi_RC Jsi_ValueArraySort(Jsi_Interp *interp, Jsi_Value *val, int sortFlags); /*STUB = 159*/\nJSI_EXTERN Jsi_Value* Jsi_ValueArrayConcat(Jsi_Interp *interp, Jsi_Value *arg1, Jsi_Value *arg2); /*STUB = 160*/\nJSI_EXTERN Jsi_RC Jsi_ValueArrayPush(Jsi_Interp *interp, Jsi_Value *arg1, Jsi_Value *arg2); /*STUB = 161*/\nJSI_EXTERN Jsi_Value* Jsi_ValueArrayPop(Jsi_Interp *interp, Jsi_Value *arg1); /*STUB = 162*/\nJSI_EXTERN void Jsi_ValueArrayShift(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 163*/\nJSI_EXTERN Jsi_Value* Jsi_ValueArrayUnshift(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 164*/\nJSI_EXTERN Jsi_Value* Jsi_ValueArrayIndex(Jsi_Interp *interp, Jsi_Value *args, int index); /*STUB = 165*/\nJSI_EXTERN char* Jsi_ValueArrayIndexToStr(Jsi_Interp *interp, Jsi_Value *args, int index, int *lenPtr); /*STUB = 166*/\n#define Jsi_ValueArraySet(interp, dest, value, index) Jsi_ObjArraySet(interp, Jsi_ValueGetObj(interp, dest), value, index)\n\n#define Jsi_ValueInsertFixed(i,t,k,v) Jsi_ValueInsert(i,t,k,v,JSI_OM_READONLY | JSI_OM_DONTDEL | JSI_OM_DONTENUM)\nJSI_EXTERN Jsi_RC Jsi_ValueInsert(Jsi_Interp *interp, Jsi_Value *target, const char *key, Jsi_Value *val, int flags); /*STUB = 167*/\nJSI_EXTERN Jsi_RC Jsi_ValueInsertArray(Jsi_Interp *interp, Jsi_Value *target, int index, Jsi_Value *val, int flags); /*STUB = 411*/\nJSI_EXTERN int Jsi_ValueGetLength(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 168*/\nJSI_EXTERN Jsi_Value* Jsi_ValueObjLookup(Jsi_Interp *interp, Jsi_Value *target, const char *key, int iskeystr); /*STUB = 169*/\nJSI_EXTERN bool Jsi_ValueKeyPresent(Jsi_Interp *interp, Jsi_Value *target, const char *k, int isstrkey); /*STUB = 170*/\nJSI_EXTERN Jsi_RC Jsi_ValueGetKeys(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *ret); /*STUB = 171*/\n\nJSI_EXTERN void Jsi_ValueCopy(Jsi_Interp *interp, Jsi_Value *to, Jsi_Value *from ); /*STUB = 172*/\nJSI_EXTERN void Jsi_ValueReplace(Jsi_Interp *interp, Jsi_Value **to, Jsi_Value *from ); /*STUB = 173*/\nJSI_EXTERN void Jsi_ValueDup2(Jsi_Interp *interp, Jsi_Value **to, Jsi_Value *from); /*STUB = 174*/\nJSI_EXTERN Jsi_Value* Jsi_ValueDupJSON(Jsi_Interp *interp, Jsi_Value *val); /*STUB = 175*/\nJSI_EXTERN void Jsi_ValueMove(Jsi_Interp *interp, Jsi_Value *to, Jsi_Value *from); /*STUB = 176*/\nJSI_EXTERN bool  Jsi_ValueIsEqual(Jsi_Interp *interp, Jsi_Value *v1, Jsi_Value* v2); /*STUB = 177*/\n/* -- */\n\n\n/* --USEROBJ-- */\ntypedef bool (Jsi_UserObjIsTrueProc)(void *data);\ntypedef bool (Jsi_UserObjIsEquProc)(void *data1, void *data2);\ntypedef Jsi_Obj* (Jsi_UserGetObjProc)(Jsi_Interp *interp, void *data);\n\ntypedef struct Jsi_UserObjReg {\n    const char *name;\n    Jsi_CmdSpec *spec;\n    Jsi_DeleteProc *freefun;\n    Jsi_UserObjIsTrueProc *istrue;\n    Jsi_UserObjIsEquProc *isequ;\n} Jsi_UserObjReg;\n\nJSI_EXTERN Jsi_Hash* Jsi_UserObjRegister    (Jsi_Interp *interp, Jsi_UserObjReg *reg); /*STUB = 178*/\nJSI_EXTERN Jsi_RC Jsi_UserObjUnregister  (Jsi_Interp *interp, Jsi_UserObjReg *reg); /*STUB = 179*/\nJSI_EXTERN int Jsi_UserObjNew    (Jsi_Interp *interp, Jsi_UserObjReg* reg, Jsi_Obj *obj, void *data); /*STUB = 180*/\nJSI_EXTERN void* Jsi_UserObjGetData(Jsi_Interp *interp, Jsi_Value* value, Jsi_Func *funcPtr); /*STUB = 181*/\nJSI_EXTERN Jsi_RC Jsi_UserObjName(Jsi_Interp *interp, Jsi_Value *v, Jsi_DString *dStr); /*STUB = 418*/ /*LAST*/\n/* -- */\n\n\n/* --UTILITY-- */\n#define JSI_NOTUSED(n) (void)n /* Eliminate annoying compiler warning. */\nJSI_EXTERN char* Jsi_NumberToString(Jsi_Interp *interp, Jsi_Number d, char *buf, int bsiz); /*STUB = 182*/\nJSI_EXTERN Jsi_Number Jsi_Version(void); /*STUB = 183*/\nJSI_EXTERN Jsi_Value* Jsi_ReturnValue(Jsi_Interp *interp); /*STUB = 184*/\nJSI_EXTERN Jsi_RC Jsi_Mount( Jsi_Interp *interp, Jsi_Value *archive, Jsi_Value *mount, Jsi_Value **ret); /*STUB = 185*/\nJSI_EXTERN Jsi_Value* Jsi_Executable(Jsi_Interp *interp); /*STUB = 186*/\nJSI_EXTERN Jsi_Regex* Jsi_RegExpNew(Jsi_Interp *interp, const char *regtxt, int flag); /*STUB = 187*/\nJSI_EXTERN void Jsi_RegExpFree(Jsi_Regex* re); /*STUB = 188*/\nJSI_EXTERN Jsi_RC Jsi_RegExpMatch( Jsi_Interp *interp,  Jsi_Value *pattern, const char *str, int *rc, Jsi_DString *dStr); /*STUB = 189*/\nJSI_EXTERN Jsi_RC Jsi_RegExpMatches(Jsi_Interp *interp, Jsi_Value *pattern, const char *str, int slen, Jsi_Value *ret); /*STUB = 190*/\nJSI_EXTERN bool Jsi_GlobMatch(const char *pattern, const char *string, int nocase); /*STUB = 191*/\nJSI_EXTERN char* Jsi_FileRealpath(Jsi_Interp *interp, Jsi_Value *path, char *newpath); /*STUB = 192*/\nJSI_EXTERN char* Jsi_FileRealpathStr(Jsi_Interp *interp, const char *path, char *newpath); /*STUB = 193*/\nJSI_EXTERN char* Jsi_NormalPath(Jsi_Interp *interp, const char *path, Jsi_DString *dStr); /*STUB = 194*/\nJSI_EXTERN char* Jsi_ValueNormalPath(Jsi_Interp *interp, Jsi_Value *path, Jsi_DString *dStr); /*STUB = 195*/\nJSI_EXTERN Jsi_RC Jsi_PathNormalize(Jsi_Interp *interp, Jsi_Value **pathPtr); /*STUB = 410*/\nJSI_EXTERN Jsi_RC Jsi_JSONParse(Jsi_Interp *interp, const char *js, Jsi_Value **ret, int flags); /*STUB = 196*/\nJSI_EXTERN Jsi_RC Jsi_JSONParseFmt(Jsi_Interp *interp, Jsi_Value **ret, const char *fmt, ...) /*STUB = 197*/ __attribute__((format (printf,3,4)));\nJSI_EXTERN char* Jsi_JSONQuote(Jsi_Interp *interp, const char *str, int len, Jsi_DString *dStr); /*STUB = 198*/\nJSI_EXTERN Jsi_RC Jsi_EvalString(Jsi_Interp* interp, const char *str, int flags); /*STUB = 199*/\nJSI_EXTERN Jsi_RC Jsi_EvalFile(Jsi_Interp* interp, Jsi_Value *fname, int flags); /*STUB = 200*/\nJSI_EXTERN Jsi_RC Jsi_EvalCmdJSON(Jsi_Interp *interp, const char *cmd, const char *jsonArgs, Jsi_DString *dStr, int flags); /*STUB = 201*/\nJSI_EXTERN Jsi_RC Jsi_EvalZip(Jsi_Interp *interp, const char *exeFile, const char *mntDir, int *jsFound); /*STUB = 202*/\nJSI_EXTERN int Jsi_DictionaryCompare(const char *left, const char *right); /*STUB = 203*/\nJSI_EXTERN Jsi_RC Jsi_GetBool(Jsi_Interp* interp, const char *string, bool *n); /*STUB = 204*/\nJSI_EXTERN Jsi_RC Jsi_GetInt(Jsi_Interp* interp, const char *string, int *n, int base); /*STUB = 205*/\nJSI_EXTERN Jsi_RC Jsi_GetWide(Jsi_Interp* interp, const char *string, Jsi_Wide *n, int base); /*STUB = 206*/\nJSI_EXTERN Jsi_RC Jsi_GetDouble(Jsi_Interp* interp, const char *string, Jsi_Number *n); /*STUB = 207*/\nJSI_EXTERN Jsi_RC Jsi_FormatString(Jsi_Interp *interp, Jsi_Value *args, Jsi_DString *dStr); /*STUB = 208*/\nJSI_EXTERN void Jsi_SplitStr(const char *str, int *argcPtr, char ***argvPtr,  const char *splitCh, Jsi_DString *dStr); /*STUB = 209*/\nJSI_EXTERN Jsi_RC Jsi_Sleep(Jsi_Interp *interp, Jsi_Number dtim); /*STUB = 210*/\nJSI_EXTERN void Jsi_Preserve(Jsi_Interp* interp, void *data); /*STUB = 211*/\nJSI_EXTERN void Jsi_Release(Jsi_Interp* interp, void *data); /*STUB = 212*/\nJSI_EXTERN void Jsi_EventuallyFree(Jsi_Interp* interp, void *data, Jsi_DeleteProc* proc); /*STUB = 213*/\nJSI_EXTERN void Jsi_ShiftArgs(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 214*/\nJSI_EXTERN Jsi_Value* Jsi_StringSplit(Jsi_Interp *interp, const char *str, const char *spliton); /*STUB = 215*/\nJSI_EXTERN Jsi_RC Jsi_GetIndex( Jsi_Interp *interp, const char *str, const char **tablePtr, const char *msg, int flags, int *indexPtr); /*STUB = 216*/\nJSI_EXTERN void* Jsi_PrototypeGet(Jsi_Interp *interp, const char *key); /*STUB = 217*/\nJSI_EXTERN Jsi_RC  Jsi_PrototypeDefine(Jsi_Interp *interp, const char *key, Jsi_Value *proto); /*STUB = 218*/\nJSI_EXTERN Jsi_RC Jsi_PrototypeObjSet(Jsi_Interp *interp, const char *key, Jsi_Obj *obj); /*STUB = 219*/\nJSI_EXTERN Jsi_RC Jsi_ThisDataSet(Jsi_Interp *interp, Jsi_Value *_this, void *value); /*STUB = 220*/\nJSI_EXTERN void* Jsi_ThisDataGet(Jsi_Interp *interp, Jsi_Value *_this); /*STUB = 221*/\nJSI_EXTERN Jsi_RC Jsi_FuncObjToString(Jsi_Interp *interp, Jsi_Func *f, Jsi_DString *dStr, int flags); /*STUB = 222*/\nJSI_EXTERN void* Jsi_UserObjDataFromVar(Jsi_Interp *interp, const char *var); /*STUB = 223*/\nJSI_EXTERN const char* Jsi_KeyAdd(Jsi_Interp *interp, const char *str); /*STUB = 224*/\nJSI_EXTERN const char* Jsi_KeyLookup(Jsi_Interp *interp, const char *str); /*STUB = 225*/\nJSI_EXTERN bool Jsi_IsReserved(Jsi_Interp *interp, const char* str, bool sql); /*STUB = 415*/\nJSI_EXTERN Jsi_RC Jsi_SqlObjBinds(Jsi_Interp* interp, Jsi_DString* zStr, const char *varName, bool addTypes, bool addDefaults, bool nullDefaults); /*STUB = 417*/\nJSI_EXTERN Jsi_RC Jsi_DatetimeFormat(Jsi_Interp *interp, Jsi_Number date, const char *fmt, int isUtc, Jsi_DString *dStr);  /*STUB = 226*/\nJSI_EXTERN Jsi_RC Jsi_DatetimeParse(Jsi_Interp *interp, const char *str, const char *fmt, int isUtc, Jsi_Number *datePtr, bool noMsg); /*STUB = 227*/\nJSI_EXTERN Jsi_Number Jsi_DateTime(void); /*STUB = 228*/\n#define JSI_DATE_JULIAN2UNIX(d)  (Jsi_Number)(((Jsi_Number)d - 2440587.5)*86400.0)\n#define JSI_DATE_UNIX2JULIAN(d)  (Jsi_Number)((Jsi_Number)d/86400.0+2440587.5)\n\ntypedef enum { Jsi_CHash_SHA2_256, Jsi_CHash_SHA1, Jsi_CHash_MD5, Jsi_CHash_SHA3_224, \n    Jsi_CHash_SHA3_384, Jsi_CHash_SHA3_512, Jsi_CHash_SHA3_256 } Jsi_CryptoHashType;\n\nJSI_EXTERN Jsi_RC Jsi_Encrypt(Jsi_Interp *interp, Jsi_DString *inout, const char *key, uint keyLen, bool decrypt); /*STUB = 229*/\nJSI_EXTERN Jsi_RC Jsi_CryptoHash(char *outbuf, const char *str, int len, Jsi_CryptoHashType type, uint strength, bool noHex, int *sizPtr); /*STUB = 230*/\nJSI_EXTERN Jsi_RC Jsi_Base64(const char *str, int len, Jsi_DString *buf, bool decode); /*STUB = 231*/\nJSI_EXTERN int Jsi_HexStr(const uchar *data, int len, Jsi_DString *dStr, bool decode); /*STUB = 232*/\nJSI_EXTERN uint32_t Jsi_Crc32(uint32_t crc, const void *ptr, size_t buf_len); /*STUB = 234*/\nJSI_EXTERN Jsi_RC Jsi_FileRead(Jsi_Interp *interp, Jsi_Value *name, Jsi_DString *dStr); /*STUB = 408*/\n\nJSI_EXTERN int Jsi_NumberIsInfinity(Jsi_Number a);  /*STUB = 235*/\nJSI_EXTERN bool Jsi_NumberIsEqual(Jsi_Number n1, Jsi_Number n2);  /*STUB = 236*/\nJSI_EXTERN bool Jsi_NumberIsFinite(Jsi_Number value);  /*STUB = 237*/\nJSI_EXTERN bool Jsi_NumberIsInteger(Jsi_Number n);  /*STUB = 238*/\nJSI_EXTERN bool Jsi_NumberIsNaN(Jsi_Number a);  /*STUB = 239*/\nJSI_EXTERN bool Jsi_NumberIsNormal(Jsi_Number a);  /*STUB = 240*/\nJSI_EXTERN bool Jsi_NumberIsSubnormal(Jsi_Number a);  /*STUB = 241*/\nJSI_EXTERN bool Jsi_NumberIsWide(Jsi_Number n);  /*STUB = 242*/\nJSI_EXTERN Jsi_Number Jsi_NumberInfinity(int i);  /*STUB = 243*/\nJSI_EXTERN Jsi_Number Jsi_NumberNaN(void);  /*STUB = 244*/\nJSI_EXTERN void Jsi_NumberDtoA(Jsi_Interp *interp, Jsi_Number value, char* buf, int bsiz, int prec);  /*STUB = 245*/\nJSI_EXTERN void Jsi_NumberItoA10(Jsi_Wide value, char* buf, int bsiz);  /*STUB = 246*/\nJSI_EXTERN void Jsi_NumberUtoA10(Jsi_UWide, char* buf, int bsiz);  /*STUB = 247*/\n\n/* -- */\n\n#define JSI_WORDKEY_CAST (void*)(uintptr_t)\n\nstruct Jsi_MapOpts;\n\ntypedef Jsi_RC (Jsi_HashDeleteProc)(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *data);\ntypedef Jsi_RC (Jsi_TreeDeleteProc)(Jsi_Interp *interp, Jsi_TreeEntry *hPtr, void *data);\ntypedef Jsi_RC (Jsi_MapDeleteProc)(Jsi_Interp *interp, Jsi_MapEntry *hPtr, void *data);\ntypedef Jsi_Value *(Jsi_MapFmtKeyProc)(Jsi_MapEntry* hPtr, struct Jsi_MapOpts *opts, int flags);\ntypedef Jsi_RC (Jsi_TreeWalkProc)(Jsi_Tree* treePtr, Jsi_TreeEntry* hPtr, void *data);\ntypedef int (Jsi_RBCompareProc)(Jsi_Tree *treePtr, const void *key1, const void *key2);\n\ntypedef struct Jsi_MapOpts {\n    Jsi_Map_Type mapType; // Read-only\n    Jsi_Key_Type keyType; // Read-only\n    Jsi_Interp *interp;\n    Jsi_Wide flags;\n    void *user, *user2;\n    Jsi_MapFmtKeyProc *fmtKeyProc;\n    Jsi_RBCompareProc *compareTreeProc;\n    union {\n        Jsi_RC (*freeHashProc)(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *data);\n        Jsi_RC (*freeTreeProc)(Jsi_Interp *interp, Jsi_TreeEntry *hPtr, void *data);\n        Jsi_RC (*freeListProc)(Jsi_Interp *interp, Jsi_ListEntry *hPtr, void *data);\n    };\n    union {\n        Jsi_RC (*lockHashProc) (Jsi_Hash *tablePtr, int lock);\n        Jsi_RC (*lockTreeProc) (Jsi_Tree *tablePtr, int lock);\n    };\n} Jsi_MapOpts;\n\n/* --HASH-- */\ntypedef struct Jsi_HashSearch {\n    Jsi_Hash *tablePtr;\n    unsigned long nextIndex; \n    Jsi_HashEntry *nextEntryPtr;\n} Jsi_HashSearch;\n\nJSI_EXTERN Jsi_Hash* Jsi_HashNew(Jsi_Interp *interp, uint keyType, Jsi_HashDeleteProc *freeProc); /*STUB = 248*/\nJSI_EXTERN Jsi_RC Jsi_HashConf(Jsi_Hash *hashPtr, Jsi_MapOpts *opts, bool set); /*STUB = 249*/\nJSI_EXTERN void Jsi_HashDelete(Jsi_Hash *hashPtr); /*STUB = 250*/\nJSI_EXTERN void Jsi_HashClear(Jsi_Hash *hashPtr); /*STUB = 251*/\nJSI_EXTERN Jsi_HashEntry* Jsi_HashSet(Jsi_Hash *hashPtr, const void *key, void *value); /*STUB = 252*/\nJSI_EXTERN void* Jsi_HashGet(Jsi_Hash *hashPtr, const void *key, int flags); /*STUB = 253*/\nJSI_EXTERN bool Jsi_HashUnset(Jsi_Hash *tbl, const void *key); /*STUB = 254*/\nJSI_EXTERN void* Jsi_HashKeyGet(Jsi_HashEntry *h); /*STUB = 255*/\nJSI_EXTERN Jsi_RC Jsi_HashKeysDump(Jsi_Interp *interp, Jsi_Hash *hashPtr, Jsi_Value **ret, int flags); /*STUB = 256*/\nJSI_EXTERN void* Jsi_HashValueGet(Jsi_HashEntry *h); /*STUB = 257*/\nJSI_EXTERN void Jsi_HashValueSet(Jsi_HashEntry *h, void *value); /*STUB = 258*/\nJSI_EXTERN Jsi_HashEntry* Jsi_HashEntryFind (Jsi_Hash *hashPtr, const void *key); /*STUB = 259*/\nJSI_EXTERN Jsi_HashEntry* Jsi_HashEntryNew (Jsi_Hash *hashPtr, const void *key, bool *isNew); /*STUB = 260*/\nJSI_EXTERN int Jsi_HashEntryDelete (Jsi_HashEntry *entryPtr); /*STUB = 261*/\nJSI_EXTERN Jsi_HashEntry* Jsi_HashSearchFirst (Jsi_Hash *hashPtr, Jsi_HashSearch *searchPtr); /*STUB = 262*/\nJSI_EXTERN Jsi_HashEntry* Jsi_HashSearchNext (Jsi_HashSearch *searchPtr); /*STUB = 263*/\nJSI_EXTERN uint Jsi_HashSize(Jsi_Hash *hashPtr); /*STUB = 264*/\n/* -- */\n\n\n/* --TREE-- */\n\ntypedef struct Jsi_TreeSearch {\n    Jsi_Tree *treePtr;\n    uint top, max, left, epoch; \n    int flags;\n    Jsi_TreeEntry *staticPtrs[200], *current;\n    Jsi_TreeEntry **Ptrs;\n} Jsi_TreeSearch;\n\nJSI_EXTERN Jsi_Tree* Jsi_TreeNew(Jsi_Interp *interp, uint keyType, Jsi_TreeDeleteProc *freeProc); /*STUB = 265*/\nJSI_EXTERN Jsi_RC Jsi_TreeConf(Jsi_Tree *treePtr, Jsi_MapOpts *opts, bool set); /*STUB = 266*/\nJSI_EXTERN void Jsi_TreeDelete(Jsi_Tree *treePtr); /*STUB = 267*/\nJSI_EXTERN void Jsi_TreeClear(Jsi_Tree *treePtr); /*STUB = 268*/\nJSI_EXTERN Jsi_TreeEntry* Jsi_TreeObjSetValue(Jsi_Obj* obj, const char *key, Jsi_Value *val, int isstrkey); /*STUB = 269*/\nJSI_EXTERN Jsi_Value*     Jsi_TreeObjGetValue(Jsi_Obj* obj, const char *key, int isstrkey); /*STUB = 270*/\nJSI_EXTERN void* Jsi_TreeValueGet(Jsi_TreeEntry *hPtr); /*STUB = 271*/\nJSI_EXTERN void Jsi_TreeValueSet(Jsi_TreeEntry *hPtr, void *value); /*STUB = 272*/\nJSI_EXTERN void* Jsi_TreeKeyGet(Jsi_TreeEntry *hPtr); /*STUB = 273*/\nJSI_EXTERN Jsi_TreeEntry* Jsi_TreeEntryFind(Jsi_Tree *treePtr, const void *key); /*STUB = 274*/\nJSI_EXTERN Jsi_TreeEntry* Jsi_TreeEntryNew(Jsi_Tree *treePtr, const void *key, bool *isNew); /*STUB = 275*/\nJSI_EXTERN int Jsi_TreeEntryDelete(Jsi_TreeEntry *entryPtr); /*STUB = 276*/\nJSI_EXTERN Jsi_TreeEntry* Jsi_TreeSearchFirst(Jsi_Tree *treePtr, Jsi_TreeSearch *searchPtr, int flags, const void *startKey); /*STUB = 277*/\nJSI_EXTERN Jsi_TreeEntry* Jsi_TreeSearchNext(Jsi_TreeSearch *searchPtr); /*STUB = 278*/\nJSI_EXTERN void Jsi_TreeSearchDone(Jsi_TreeSearch *searchPtr); /*STUB = 279*/\nJSI_EXTERN int Jsi_TreeWalk(Jsi_Tree* treePtr, Jsi_TreeWalkProc* callback, void *data, int flags); /*STUB = 280*/\nJSI_EXTERN Jsi_TreeEntry* Jsi_TreeSet(Jsi_Tree *treePtr, const void *key, void *value); /*STUB = 281*/\nJSI_EXTERN void* Jsi_TreeGet(Jsi_Tree *treePtr, void *key, int flags); /*STUB = 282*/\nJSI_EXTERN bool Jsi_TreeUnset(Jsi_Tree *treePtr, void *key); /*STUB = 283*/\nJSI_EXTERN uint Jsi_TreeSize(Jsi_Tree *treePtr); /*STUB = 284*/ \nJSI_EXTERN Jsi_Tree* Jsi_TreeFromValue(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 285*/\nJSI_EXTERN Jsi_RC Jsi_TreeKeysDump(Jsi_Interp *interp, Jsi_Tree *hashPtr, Jsi_Value **ret, int flags); /*STUB = 286*/\n/* -- */\n\n\n/* --LIST-- */\ntypedef struct Jsi_List {\n    uint sig;\n    int numEntries;\n    Jsi_ListEntry *head;\n    Jsi_ListEntry *tail;\n    Jsi_MapOpts opts;\n} Jsi_List;\n\ntypedef struct Jsi_ListEntry {\n    uint sig;\n    Jsi_Map_Type typ;    \n    struct Jsi_ListEntry *next;\n    struct Jsi_ListEntry *prev;\n    Jsi_List *list;\n    void *value;\n} Jsi_ListEntry;\n\ntypedef struct Jsi_ListSearch {\n    int flags;\n    Jsi_List *tablePtr;\n    unsigned long nextIndex; \n    Jsi_ListEntry *nextEntryPtr;\n} Jsi_ListSearch;\n\nJSI_EXTERN Jsi_List* Jsi_ListNew(Jsi_Interp *interp, Jsi_Wide flags, Jsi_HashDeleteProc *freeProc); /*STUB = 287*/\nJSI_EXTERN Jsi_RC Jsi_ListConf(Jsi_List *list, Jsi_MapOpts *opts, bool set); /*STUB = 288*/\nJSI_EXTERN void Jsi_ListDelete(Jsi_List *list); /*STUB = 289*/\nJSI_EXTERN void Jsi_ListClear(Jsi_List *list); /*STUB = 290*/\n//#define Jsi_ListSet(l, before, value) Jsi_ListPush(l, before, Jsi_ListEntryNew(l, value))\n//#define Jsi_ListGet(l, le) (le)->value \n//#define Jsi_ListKeyGet(le) (le)\n//#define Jsi_ListKeysDump(interp, list, ret, flags) JSI_ERROR\nJSI_EXTERN void* Jsi_ListValueGet(Jsi_ListEntry *list); /*STUB = 291*/\nJSI_EXTERN void Jsi_ListValueSet(Jsi_ListEntry *list, const void *value); /*STUB = 292*/\n//#define Jsi_ListEntryFind(l, le) (le)\nJSI_EXTERN Jsi_ListEntry* Jsi_ListEntryNew(Jsi_List *list, const void *value, Jsi_ListEntry *before); /*STUB = 293*/\nJSI_EXTERN int Jsi_ListEntryDelete(Jsi_ListEntry *entry); /*STUB = 294*/\nJSI_EXTERN Jsi_ListEntry* Jsi_ListSearchFirst (Jsi_List *list, Jsi_ListSearch *search, int flags); /*STUB = 295*/\nJSI_EXTERN Jsi_ListEntry* Jsi_ListSearchNext (Jsi_ListSearch *search); /*STUB = 296*/\nJSI_EXTERN uint Jsi_ListSize(Jsi_List *list); /*STUB = 297*/\n/* end of hash-compat functions. */\n\nJSI_EXTERN Jsi_ListEntry* Jsi_ListPush(Jsi_List *list, Jsi_ListEntry *entry, Jsi_ListEntry *before); /*STUB = 298*/\nJSI_EXTERN Jsi_ListEntry* Jsi_ListPop(Jsi_List *list, Jsi_ListEntry *entry); /*STUB = 299*/\n#define Jsi_ListPushFront(list,entry)   Jsi_ListPush(list, entry, list->head)\n#define Jsi_ListPushBack(list,entry)    Jsi_ListPush(list, entry, NULL)\n#define Jsi_ListPushFrontNew(list,v)    Jsi_ListEntryNew(list, v, list->head)\n#define Jsi_ListPushBackNew(list,v)     Jsi_ListEntryNew(list, v, NULL)\n#define Jsi_ListPopFront(list)          Jsi_ListPop(list, list->head)\n#define Jsi_ListPopBack(list)           Jsi_ListPop(list, list->tail)\n#define Jsi_ListEntryNext(entry)        (entry)->next \n#define Jsi_ListEntryPrev(entry)        (entry)->prev\n#define Jsi_ListGetFront(list)          (list)->head\n#define Jsi_ListGetBack(list)           (list)->tail\n\n/* -- */\n\n\n/* --STACK-- */\ntypedef struct {\n    int len;\n    int maxlen;\n    void **vector;\n} Jsi_Stack;\n\nJSI_EXTERN Jsi_Stack* Jsi_StackNew(void); /*STUB = 300*/\nJSI_EXTERN void Jsi_StackFree(Jsi_Stack *stack); /*STUB = 301*/\nJSI_EXTERN int Jsi_StackSize(Jsi_Stack *stack); /*STUB = 302*/\nJSI_EXTERN void Jsi_StackPush(Jsi_Stack *stack, void *element); /*STUB = 303*/\nJSI_EXTERN void* Jsi_StackPop(Jsi_Stack *stack); /*STUB = 304*/\nJSI_EXTERN void* Jsi_StackPeek(Jsi_Stack *stack); /*STUB = 305*/\nJSI_EXTERN void* Jsi_StackUnshift(Jsi_Stack *stack); /*STUB = 306*/\nJSI_EXTERN void* Jsi_StackHead(Jsi_Stack *stack); /*STUB = 307*/\nJSI_EXTERN void Jsi_StackFreeElements(Jsi_Interp *interp, Jsi_Stack *stack, Jsi_DeleteProc *freeFunc); /*STUB = 308*/\n/* -- */\n\n/* --MAP-- */\ntypedef struct Jsi_MapSearch {\n    Jsi_Map_Type typ;\n    union {\n        Jsi_TreeSearch tree;\n        Jsi_HashSearch hash;\n        Jsi_ListSearch list;\n    } v;\n} Jsi_MapSearch;\n\nJSI_EXTERN Jsi_Map* Jsi_MapNew(Jsi_Interp *interp, Jsi_Map_Type mapType, Jsi_Key_Type keyType, Jsi_MapDeleteProc *freeProc); /*STUB = 309*/\nJSI_EXTERN Jsi_RC Jsi_MapConf(Jsi_Map *mapPtr, Jsi_MapOpts *opts, bool set); /*STUB = 310*/\nJSI_EXTERN void Jsi_MapDelete (Jsi_Map *mapPtr); /*STUB = 311*/\nJSI_EXTERN void Jsi_MapClear (Jsi_Map *mapPtr); /*STUB = 312*/\nJSI_EXTERN Jsi_MapEntry* Jsi_MapSet(Jsi_Map *mapPtr, const void *key, const void *value); /*STUB = 313*/\nJSI_EXTERN void* Jsi_MapGet(Jsi_Map *mapPtr, const void *key, int flags); /*STUB = 314*/\nJSI_EXTERN void* Jsi_MapKeyGet(Jsi_MapEntry *h, int flags); /*STUB = 315*/\nJSI_EXTERN Jsi_RC Jsi_MapKeysDump(Jsi_Interp *interp, Jsi_Map *mapPtr, Jsi_Value **ret, int flags); /*STUB = 316*/\nJSI_EXTERN void* Jsi_MapValueGet(Jsi_MapEntry *h); /*STUB = 317*/\nJSI_EXTERN void Jsi_MapValueSet(Jsi_MapEntry *h, const void *value); /*STUB = 318*/\nJSI_EXTERN Jsi_MapEntry* Jsi_MapEntryFind (Jsi_Map *mapPtr, const void *key); /*STUB = 319*/\nJSI_EXTERN Jsi_MapEntry* Jsi_MapEntryNew (Jsi_Map *mapPtr, const void *key, bool *isNew); /*STUB = 320*/\nJSI_EXTERN int Jsi_MapEntryDelete (Jsi_MapEntry *entryPtr); /*STUB = 321*/\nJSI_EXTERN Jsi_MapEntry* Jsi_MapSearchFirst (Jsi_Map *mapPtr, Jsi_MapSearch *searchPtr, int flags); /*STUB = 322*/\nJSI_EXTERN Jsi_MapEntry* Jsi_MapSearchNext (Jsi_MapSearch *srchPtr); /*STUB = 323*/\nJSI_EXTERN void Jsi_MapSearchDone (Jsi_MapSearch *searchPtr);  /*STUB = 324*/\nJSI_EXTERN uint Jsi_MapSize(Jsi_Map *mapPtr); /*STUB = 325*/\n\n\n// Define typed wrappers for 5 main Map functions: Set, Get, KeyGet, EntryFind, EntryNew\n#define JSI_MAP_EXTN(Prefix, keyType, valType) \\\nJSI_EXTERN Jsi_MapEntry *Prefix ## _Set(Jsi_Map *mapPtr, keyType key, valType value); \\\nJSI_EXTERN valType Prefix ## _Get(Jsi_Map *mapPtr, keyType key); \\\nJSI_EXTERN keyType Prefix ## _KeyGet(Jsi_MapEntry *h); \\\nJSI_EXTERN Jsi_MapEntry* Prefix ## _EntryFind (Jsi_Map *mapPtr, keyType key); \\\nJSI_EXTERN Jsi_MapEntry* Prefix ## _EntryNew (Jsi_Map *mapPtr, keyType key, int *isNew);\n\n#define JSI_MAP_DEFN(Prefix, keyType, valType) \\\nJsi_MapEntry *Prefix ## _Set(Jsi_Map *mapPtr, keyType key, valType value) { return Jsi_MapSet(mapPtr, (void*)key, (void*)value); } \\\nvalType Prefix ## _Get(Jsi_Map *mapPtr, keyType key) { return (valType)Jsi_MapGet(mapPtr, (void*)key); } \\\nkeyType Prefix ## _KeyGet(Jsi_MapEntry *h) { return (keyType)Jsi_MapKeyGet(h); } \\\nJsi_MapEntry* Prefix ## _EntryFind (Jsi_Map *mapPtr, keyType key) { return  Jsi_MapEntryFind(mapPtr, (void*)key); } \\\nJsi_MapEntry* Prefix ## _EntryNew (Jsi_Map *mapPtr, keyType key, int *isNew) { return  Jsi_MapEntryNew(mapPtr, (void*)key, isNew); }\n   \n/* -- */\n\n\n/* --OPTIONS-- */\ntypedef Jsi_RC (Jsi_OptionParseProc) (\n    Jsi_Interp *interp, Jsi_OptionSpec *spec, Jsi_Value *value, const char *str, void *record, Jsi_Wide flags);\ntypedef Jsi_RC (Jsi_OptionFormatProc) (\n    Jsi_Interp *interp, Jsi_OptionSpec *spec, Jsi_Value **retValue, Jsi_DString *retStr, void *record, Jsi_Wide flags);\ntypedef Jsi_RC (Jsi_OptionFormatStringProc) (\n    Jsi_Interp *interp, Jsi_OptionSpec *spec, Jsi_DString **retValue, void *record);\ntypedef void (Jsi_OptionFreeProc) (Jsi_Interp *interp, Jsi_OptionSpec *spec, void *ptr);\n\ntypedef Jsi_RC (Jsi_OptionBitOp)(Jsi_Interp *interp, Jsi_OptionSpec *spec, void *data, Jsi_Wide *s, int isSet);\n\ntypedef struct {\n    const char *name;\n    Jsi_OptionParseProc *parseProc;\n    Jsi_OptionFormatProc *formatProc;\n    Jsi_OptionFreeProc *freeProc;\n    const char *help;\n    const char *info;\n    void* data;\n} Jsi_OptionCustom;\n\ntypedef enum {\n    JSI_OPTION_BOOL=1,\n    JSI_OPTION_INT8,  JSI_OPTION_INT16,  JSI_OPTION_INT32,  JSI_OPTION_INT64,\n    JSI_OPTION_UINT8, JSI_OPTION_UINT16, JSI_OPTION_UINT32, JSI_OPTION_UINT64,\n    JSI_OPTION_FLOAT,\n    JSI_OPTION_DOUBLE,    // Same as NUMBER when !JSI_USE_LONG_DOUBLE.\n    JSI_OPTION_LDOUBLE,   // A long double\n    JSI_OPTION_STRBUF,    // Fixed size string buffer.\n    JSI_OPTION_TIME_W,    // Jsi_Wide: milliseconds since Jan 1, 1970.\n    JSI_OPTION_TIME_D,    // double: milliseconds since Jan 1, 1970.\n    // Non-portable fields start here\n    JSI_OPTION_TIME_T,    // time_t: seconds since Jan 1, 1970. \n    JSI_OPTION_SIZE_T,\n    JSI_OPTION_SSIZE_T,\n    JSI_OPTION_INTPTR_T,  // Int big enough to store a pointer.\n    JSI_OPTION_UINTPTR_T, \n    JSI_OPTION_NUMBER,    // Same as DOUBLE when !JSI_USE_LONG_DOUBLE.\n    JSI_OPTION_INT, JSI_OPTION_UINT,\n    JSI_OPTION_LONG, JSI_OPTION_ULONG, JSI_OPTION_SHORT, JSI_OPTION_USHORT,\n    JSI_OPTION_STRING, JSI_OPTION_DSTRING, JSI_OPTION_STRKEY,\n    JSI_OPTION_VALUE, JSI_OPTION_VAR, JSI_OPTION_OBJ, JSI_OPTION_ARRAY, JSI_OPTION_REGEXP,\n    JSI_OPTION_FUNC,      // Note: .data can contain string args to check\n    JSI_OPTION_USEROBJ,   // Note: .data can contain string obj name to check\n    JSI_OPTION_CUSTOM,    // Note: set .custom, .data, etc.\n    JSI_OPTION_END\n} Jsi_OptionId;\n\ntypedef const char* Jsi_Strkey;\n#ifdef __cplusplus\ntypedef void* Jsi_Strbuf;\n#else\ntypedef char Jsi_Strbuf[];\n#endif\n\ntypedef union {\n    bool           BOOL;\n    int8_t         INT8;\n    int16_t        INT16;\n    int32_t        INT32;\n    int64_t        INT64;\n    uint8_t        UINT8;\n    uint16_t       UINT16;\n    uint32_t       UINT32;\n    uint64_t       UINT64;\n    float          FLOAT;\n    double         DOUBLE;\n    ldouble        LDOUBLE;\n    Jsi_Number     NUMBER;\n    char*          STRBUF;\n    time_d         TIME_D;\n    time_w         TIME_W;\n    time_t         TIME_T;\n    size_t         SIZE_T;\n    ssize_t        SSIZE_T;\n    intptr_t       INTPTR_T;\n    uintptr_t      UINTPTR_T;\n    int            INT;\n    uint           UINT;\n    long           LONG;\n    ulong          ULONG;\n    short          SHORT;\n    ushort         USHORT;\n    Jsi_DString    DSTRING;\n    const char*    STRKEY;\n    Jsi_Value*     STRING;\n    Jsi_Value*     VALUE;\n    Jsi_Value*     VAR;\n    Jsi_Value*     OBJ;\n    Jsi_Value*     ARRAY;\n    Jsi_Value*     REGEXP;\n    Jsi_Value*     FUNC;\n    Jsi_Value*     USEROBJ;\n    void*          CUSTOM;\n    Jsi_csgset*    OPT_BITS;\n    struct Jsi_OptionSpec* OPT_CARRAY;\n} Jsi_OptionValue;\n\ntypedef union { /* Field used at compile-time by JSI_OPT() to provide type checking for the var */\n    bool           *BOOL;\n    int8_t         *INT8;\n    int16_t        *INT16;\n    int32_t        *INT32;\n    int64_t        *INT64;\n    uint8_t        *UINT8;\n    uint16_t       *UINT16;\n    uint32_t       *UINT32;\n    uint64_t       *UINT64;\n    float          *FLOAT;\n    double         *DOUBLE;\n    ldouble        *LDOUBLE;\n    Jsi_Number     *NUMBER;\n#ifdef __cplusplus\n    Jsi_Strbuf      STRBUF;\n#else\n    Jsi_Strbuf      *STRBUF;\n#endif\n    time_t         *TIME_T;\n    time_w         *TIME_W;\n    time_d         *TIME_D;\n    size_t         *SIZE_T;\n    ssize_t        *SSIZE_T;\n    intptr_t       *INTPTR_T;\n    uintptr_t      *UINTPTR_T;\n    int            *INT;\n    uint           *UINT;\n    long           *LONG;\n    ulong          *ULONG;\n    short          *SHORT;\n    ushort         *USHORT;\n    Jsi_DString    *DSTRING;\n    const char*    *STRKEY;\n    Jsi_Value*     *VALUE;\n    Jsi_Value*     *STRING;\n    Jsi_Value*     *VAR;\n    Jsi_Value*     *OBJ;\n    Jsi_Value*     *ARRAY;\n    Jsi_Value*     *REGEXP;\n    Jsi_Value*     *FUNC;\n    Jsi_Value*     *USEROBJ;\n    void           *CUSTOM;\n    Jsi_csgset     *OPT_BITS;\n    struct Jsi_OptionSpec *OPT_CARRAY;\n} Jsi_OptionInitVal;\n\ntypedef struct {\n    Jsi_Sig sig;\n    Jsi_OptionId id;\n    const char *idName, *cName;\n    int size;\n    const char *fmt, *xfmt, *sfmt, *help;\n    Jsi_OptionInitVal init;\n    Jsi_Wide flags;\n    Jsi_Wide user;\n    const char *userData;       /* User data. */ \\\n    uchar *extData;             /* Extension data. */\n    uchar *extra;\n    Jsi_HashEntry *hPtr;\n} Jsi_OptionTypedef;\n\nstruct Jsi_OptionSpec {\n    Jsi_Sig sig;                /* Signature field. */\n    Jsi_OptionId id;\n    const char *name;           /* The field name. */\n    uint offset;                /* Jsi_Offset of field. */\n    uint size;                  /* The sizeof() of field. */\n    Jsi_OptionInitVal init;     /* Initialization value */\n    const char *help;           /* A short one-line help string, without newlines. */\n    Jsi_Wide flags;             /* Lower 32 bits: the JSI_OPTS_* flags below. Upper 32 for custom/other. */\n    Jsi_OptionCustom *custom;   /* Custom handler. */\n    void *data;                 /* User data for custom options: eg. the bit for BOOLBIT. */\n    const char *info;           /* Longer command description. Use JSI_DETAIL macro to allow compile-out.*/\n    const char *tname;          /* Type name for field or external name used by the DB interface. */\n    Jsi_Wide value;             /* Value field. */\n    uint32_t bits;              /* Size of bitfield */\n    uint32_t boffset;           /* Bit offset of field (or struct) */\n    uint32_t idx;               /* Index (of field) */\n    uint32_t ssig;              /* Signature (for struct) */\n    uint32_t crc;               /* Crc (for struct) */\n    uint32_t arrSize;           /* Size of array */\n    const char *userData;       /* User data. */\n    uchar *extData;             /* Extension data. */\n    uchar *extra;               /* Extra pointer (currently unused). */\n    const Jsi_OptionTypedef *type;\n};\n\n/* JSI_OPT is a macro used for option definitions, eg:\n * \n *      typedef struct { int debug; int bool; } MyStruct;\n * \n *      Jsi_OptionSpec MyOptions[] = {\n *          JSI_OPT(BOOL,  MyStruct,  debug ),\n *          JSI_OPT(INT,   MyStruct,  max,   .help=\"Max value\"),\n *          JSI_OPT_END(   MyStruct, .help=\"My first struct\" )\n *      }\n*/\n\n#define JSI_OPT_(s, typ, strct, nam, ...) \\\n    { .sig=s, .id=JSI_OPTION_##typ, .name=#nam, .offset=Jsi_Offset(strct, nam), .size=sizeof(((strct *) 0)->nam), \\\n      .init={.typ=(&((strct *) 0)->nam)}, ##__VA_ARGS__ }\n\n#define JSI_OPT_END_(s, strct, ...) { .sig=s, .id=JSI_OPTION_END, .name=#strct, .offset=__LINE__, .size=sizeof(strct), \\\n      .init={.CUSTOM=(void*)__FILE__}, ##__VA_ARGS__}\n\n#define JSI_OPT_BITS_(s, strct, nam, hlp, flgs, bsget, fidx, tnam, bdata) \\\n    { .sig=s, .id=JSI_OPTION_CUSTOM, .name=#nam, .offset=0, .size=0, \\\n        .init={.OPT_BITS=&bsget}, .help=hlp, .flags=flgs, .custom=Jsi_Opt_SwitchBitfield, .data=bdata,\\\n        .info=0, .tname=#nam, .value=0, .bits=0, .boffset=0, .idx=fidx }\n\n#define JSI_OPT_CARRAY_(s, strct, nam, hlp, flgs, aropt, asiz, tnam, sinit) \\\n    { .sig=s, .id=JSI_OPTION_CUSTOM, .name=#nam, .offset=Jsi_Offset(strct, nam), .size=sizeof(((strct *) 0)->nam), \\\n        .init={.OPT_CARRAY=aropt}, .help=hlp, .flags=flgs, .custom=Jsi_Opt_SwitchCArray, .data=0,\\\n        .info=0, .tname=tnam, .value=0, .bits=0, .boffset=0, .idx=0, .ssig=0, .crc=0, .arrSize=asiz, .extData=sinit, .extra=0 }\n\n#define JSI_OPT_CARRAY_ITEM_(s, typ, strct, nam, ...) \\\n    { .sig=s, .id=JSI_OPTION_##typ, .name=#nam, .offset=0, .size=sizeof(((strct *) 0)->nam), \\\n      .init={.typ=(&((strct *) 0)->nam[0])}, ##__VA_ARGS__ }\n\n#define JSI_OPT(typ, strct, nam, ...) JSI_OPT_(JSI_SIG_OPTS, typ, strct, nam, ##__VA_ARGS__) \n#define JSI_OPT_END(strct, ...) JSI_OPT_END_(JSI_SIG_OPTS, strct, ##__VA_ARGS__)\n#define JSI_OPT_BITS(strct, nam, hlp, flgs, bsget, fidx, tnam, bdata) JSI_OPT_BITS_(JSI_SIG_OPTS, strct, nam, hlp, flgs, bsget, fidx, tnam, bdata)\n#define JSI_OPT_CARRAY(strct, nam, hlp, flgs, aropt, asiz, tnam, sinit) JSI_OPT_CARRAY_(JSI_SIG_OPTS, strct, nam, hlp, flgs, aropt, asiz, tnam, sinit)\n#define JSI_OPT_CARRAY_ITEM(typ, strct, nam, ...) JSI_OPT_CARRAY_ITEM_(JSI_SIG_OPTS, typ, strct, nam, ##__VA_ARGS__)\n\n#define JSI_OPT_END_IDX(opt) ((sizeof(opt)/sizeof(opt[0]))-1)\n\n/* builtin handler for Custom. */\n#define Jsi_Opt_SwitchEnum          (Jsi_OptionCustom*)0x1 /* An Enum: choices are in .data=stringlist */\n#define Jsi_Opt_SwitchBitset        (Jsi_OptionCustom*)0x2 /* Bits in an int: choices are in .data=stringlist */\n#define Jsi_Opt_SwitchSuboption     (Jsi_OptionCustom*)0x3 /* Sub-structs: subspec is in .data={...} */\n#define Jsi_Opt_SwitchBitfield      (Jsi_OptionCustom*)0x4 /* Struct bitfields: used by \"jsish -c\" */\n#define Jsi_Opt_SwitchValueVerify   (Jsi_OptionCustom*)0x5 /* Callback to verify Jsi_Value* correctness in .data=func. */\n#define Jsi_Opt_SwitchCArray        (Jsi_OptionCustom*)0x6 /* C Array described in .data=type. */\n#define Jsi_Opt_SwitchNull          (Jsi_OptionCustom*)0x7 /* Set is ignored, and get returns null */\n#define Jsi_Opt_SwitchParentFunc    (Jsi_OptionCustom*)0x8 /* Name of a func in parent. Sig string is in .data*/\n\nenum {\n    /* Jsi_OptionsProcess() flags */\n    JSI_OPTS_PREFIX         =   (1<<27), /* Allow matching unique prefix of object members. */\n    JSI_OPTS_IS_UPDATE      =   (1<<28), /* This is an update/conf (do not reset the specified flags) */\n    JSI_OPTS_IGNORE_EXTRA   =   (1<<29), /* Ignore extra members not found in spec. */\n    JSI_OPTS_FORCE_STRICT   =   (1<<30), /* Override Interp->compat to disable JSI_OPTS_IGNORE_EXTRA. */\n    JSI_OPTS_VERBOSE        =   (1<<31), /* Dump verbose options */\n    JSI_OPTS_INCR           =   (1<<7),  /* Options is an increment. */\n\n    /* Jsi_OptionSpec flags. */\n    JSI_OPT_IS_SPECIFIED    =   (1<<0),   /* User set the option. */\n    JSI_OPT_INIT_ONLY       =   (1<<1),   /* Allow set only at init, disallowing update/conf. */\n    JSI_OPT_READ_ONLY       =   (1<<2),   /* Value can not be set. */\n    JSI_OPT_NO_DUPVALUE     =   (1<<3),   /* Values are not to be duped. */\n    JSI_OPT_NO_CLEAR        =   (1<<4),   /* Values are not to be cleared: watch for memory leaks */\n    JSI_OPT_REQUIRED        =   (1<<5),  /* Field must be specified (if not IS_UPDATE). */\n    JSI_OPT_PASS2           =   (1<<6),   /* Options to be processed only on pass2. */\n    JSI_OPT_DB_DIRTY        =   (1<<8),   /* Used to limit DB updates. */\n    JSI_OPT_DB_IGNORE       =   (1<<9),   /* Field is not to be used for DB. */\n    JSI_OPT_DB_ROWID        =   (1<<10),  /* Field used by DB to store rowid. */\n    JSI_OPT_CUST_NOCASE     =   (1<<11),  /* Ignore case (eg. for ENUM and BITSET). */\n    JSI_OPT_FORCE_INT       =   (1<<12),  /* Force int instead of text for enum/bitset. */\n    JSI_OPT_BITSET_ENUM     =   (1<<13),  /* Mark field as a bitset/enum map custom field. */\n    JSI_OPT_TIME_DATEONLY   =   (1<<14),  /* Time field is date only. */\n    JSI_OPT_TIME_TIMEONLY   =   (1<<15),  /* Time field is time only. */\n    JSI_OPT_IS_BITS         =   (1<<16),  /* Is a C bit-field. */\n    JSI_OPT_FMT_STRING      =   (1<<17),  /* Format value (eg. time) as string. */\n    JSI_OPT_FMT_NUMBER      =   (1<<18),  /* Format value (eg. enum) as number. */\n    JSI_OPT_FMT_HEX         =   (1<<19),  /* Format number in hex. */\n    JSI_OPT_STRICT          =   (1<<20),  /* Strict mode. */\n    JSI_OPT_LOCKSAFE        =   (1<<21),  /* Field may not be configured when isSafe. */\n    JSI_OPT_COERCE          =   (1<<22),  /* Coerce input value to required type. */\n    JSI_OPT_NO_SIG          =   (1<<23),  /* No signature. */\n    JSI_OPT_ENUM_SPEC       =   (1<<24),  /* Enum has spec rather than a list of strings. */\n    JSI_OPT_ENUM_UNSIGNED   =   (1<<25),  /* Enum value is unsigned. */\n    JSI_OPT_ENUM_EXACT      =   (1<<26),  /* Enum must be an exact match. */\n    JSI_OPTIONS_USER_FIRSTBIT  =   48,    /* First bit of user flags: the lower 48 bits are internal. */\n};\n\nJSI_EXTERN const Jsi_OptionTypedef* Jsi_OptionTypeInfo(Jsi_OptionId typ); /*STUB = 326*/\nJSI_EXTERN Jsi_OptionTypedef* Jsi_TypeLookup(Jsi_Interp* interp, const char *typ); /*STUB = 327*/\nJSI_EXTERN int Jsi_OptionsProcess(Jsi_Interp *interp, Jsi_OptionSpec *specs, void *data, Jsi_Value *value, Jsi_Wide flags); /*STUB = 328*/\nJSI_EXTERN int Jsi_OptionsProcessJSON(Jsi_Interp *interp, Jsi_OptionSpec *opts, void *data, const char *json, Jsi_Wide flags); /*STUB = 329*/\nJSI_EXTERN Jsi_RC Jsi_OptionsConf(Jsi_Interp *interp, Jsi_OptionSpec *specs, void *data, Jsi_Value *value, Jsi_Value **ret, Jsi_Wide flags); /*STUB = 330*/\nJSI_EXTERN void Jsi_OptionsFree(Jsi_Interp *interp, Jsi_OptionSpec *specs, void *data, Jsi_Wide flags); /*STUB = 331*/\nJSI_EXTERN Jsi_RC Jsi_OptionsGet(Jsi_Interp *interp, Jsi_OptionSpec *specs, void *data, const char *option, Jsi_Value** valuePtr, Jsi_Wide flags); /*STUB = 332*/\nJSI_EXTERN Jsi_RC Jsi_OptionsSet(Jsi_Interp *interp, Jsi_OptionSpec *specs, void* data, const char *option, Jsi_Value *valuePtr, Jsi_Wide flags); /*STUB = 333*/\nJSI_EXTERN Jsi_RC Jsi_OptionsDump(Jsi_Interp *interp, Jsi_OptionSpec *specs, void *data, Jsi_Value** ret, Jsi_Wide flags); /*STUB = 334*/\nJSI_EXTERN int Jsi_OptionsChanged(Jsi_Interp *interp, Jsi_OptionSpec *specs, const char *pattern, ...) /*STUB = 335*/ __attribute__((sentinel));\nJSI_EXTERN bool Jsi_OptionsValid(Jsi_Interp *interp, Jsi_OptionSpec* spec);  /*STUB = 336*/\nJSI_EXTERN const char* Jsi_OptionsData(Jsi_Interp *interp, Jsi_OptionSpec *specs, Jsi_DString *dStr, bool schema);\nJSI_EXTERN Jsi_OptionSpec* Jsi_OptionsFind(Jsi_Interp *interp, Jsi_OptionSpec *specs, const char *name, Jsi_Wide flags); /*STUB = 337*/\nJSI_EXTERN Jsi_Value* Jsi_OptionsCustomPrint(void* clientData, Jsi_Interp *interp, const char *optionName, void *data, int offset); /*STUB = 338*/\nJSI_EXTERN Jsi_OptionCustom* Jsi_OptionCustomBuiltin(Jsi_OptionCustom* cust); /*STUB = 339*/\n/* Create a duplicate of static specs.   Use this for threaded access to Jsi_OptionsChanged(). */\nJSI_EXTERN Jsi_OptionSpec* Jsi_OptionsDup(Jsi_Interp *interp, const Jsi_OptionSpec *staticSpecs); /*STUB = 340*/\nJSI_EXTERN const Jsi_OptionSpec* Jsi_OptionSpecsCached(Jsi_Interp *interp, const Jsi_OptionSpec *staticSpecs);  /*STUB = 341*/\n/* -- */\n\n\n/* --THREADS/MUTEX-- */\nJSI_EXTERN Jsi_RC Jsi_MutexLock(Jsi_Interp *interp, Jsi_Mutex *mtx); /*STUB = 342*/\nJSI_EXTERN void Jsi_MutexUnlock(Jsi_Interp *interp, Jsi_Mutex *mtx); /*STUB = 343*/\nJSI_EXTERN void Jsi_MutexDelete(Jsi_Interp *interp, Jsi_Mutex *mtx); /*STUB = 344*/\nJSI_EXTERN Jsi_Mutex* Jsi_MutexNew(Jsi_Interp *interp, int timeout, int flags); /*STUB = 345*/\nJSI_EXTERN void* Jsi_CurrentThread(void); /*STUB = 346*/\nJSI_EXTERN void* Jsi_InterpThread(Jsi_Interp *interp); /*STUB = 347*/\n/* -- */\n\n\n/* --LOGGING-- */\n#define Jsi_LogBug(fmt,...) Jsi_LogMsg(interp, JSI_LOG_BUG, fmt, ##__VA_ARGS__)\n#define Jsi_LogError(fmt,...) Jsi_LogMsg(interp, JSI_LOG_ERROR, fmt, ##__VA_ARGS__)\n#define Jsi_LogParse(fmt,...) Jsi_LogMsg(interp, JSI_LOG_PARSE, fmt, ##__VA_ARGS__)\n#define Jsi_LogWarn(fmt,...) Jsi_LogMsg(interp, JSI_LOG_WARN, fmt, ##__VA_ARGS__)\n#define Jsi_LogInfo(fmt,...) Jsi_LogMsg(interp, JSI_LOG_INFO, fmt, ##__VA_ARGS__)\n#define Jsi_LogDebug(fmt,...) Jsi_LogMsg(interp, JSI_LOG_DEBUG, fmt, ##__VA_ARGS__)\n#define Jsi_LogTrace(fmt,...) Jsi_LogMsg(interp, JSI_LOG_TRACE, fmt, ##__VA_ARGS__)\n#define Jsi_LogTest(fmt,...) Jsi_LogMsg(interp, JSI_LOG_TEST, fmt, ##__VA_ARGS__)\n\nJSI_EXTERN Jsi_RC Jsi_LogMsg(Jsi_Interp *interp, uint level, const char *format,...)  /*STUB = 348*/ __attribute__((format (printf,3,4)));\n\n\n/* --EVENTS-- */\ntypedef struct {\n    Jsi_Sig sig;\n    uint id;\n    int evType;                 /* Is signal handler. */\n    int sigNum;\n    int once;                   /* Execute once */\n    long initialms;             /* initial relative timer value */\n    long when_sec;              /* seconds */\n    long when_ms;               /* milliseconds */\n    bool busy;                  /* In event callback. */\n    uint count;                 /* Times executed */\n    Jsi_HashEntry *hPtr;\n    Jsi_Value *funcVal;         /* JS Function to call. */\n    Jsi_EventHandlerProc *handler;  /* C-function handler. */\n    void *data;\n} Jsi_Event;\n\nJSI_EXTERN Jsi_Event* Jsi_EventNew(Jsi_Interp *interp, Jsi_EventHandlerProc *callback, void* data); /*STUB = 349*/\nJSI_EXTERN void Jsi_EventFree(Jsi_Interp *interp, Jsi_Event* event); /*STUB = 350*/\nJSI_EXTERN int Jsi_EventProcess(Jsi_Interp *interp, int maxEvents); /*STUB = 351*/\n/* -- */\n\n\n/* --JSON-- */\n#define JSI_JSON_DECLARE(p, tokens, maxsz) \\\n    Jsi_JsonParser p = {0}; \\\n    Jsi_JsonTok tokens[maxsz>0?maxsz:JSI_JSON_STATIC_DEFAULT]; \\\n    Jsi_JsonInit(&p, tokens, maxsz>0?maxsz:JSI_JSON_STATIC_DEFAULT)\n\ntypedef enum {\n    JSI_JTYPE_PRIMITIVE = 0,\n    JSI_JTYPE_OBJECT = 1,\n    JSI_JTYPE_ARRAY = 2,\n    JSI_JTYPE_STRING = 3,\n    JSI_JTYPE_INVALID=-1\n} Jsi_JsonTypeEnum;\n\ntypedef enum {\n    JSI_JSON_ERR_NOMEM = -1,\n    JSI_JSON_ERR_INVAL = -2,\n    JSI_JSON_ERR_PART = -3,\n    JSI_JSON_ERR_NONE = 0\n} Jsi_JsonErrEnum;\n\ntypedef struct {\n    Jsi_JsonTypeEnum type;\n    int start;\n    int end;\n    uint size;\n    int parent;\n} Jsi_JsonTok;\n\ntypedef struct {\n    uint pos;           /* offset in the JSON string */\n    uint toknext;       /* next token to allocate */\n    int toksuper;       /* superior token node, e.g parent object or array */\n    Jsi_JsonTok *tokens, *static_tokens;\n    uint num_tokens;\n    int no_malloc;      /* Disable parser dynamic growth tokens array. */\n    bool strict;/* Strict parsing. */\n    Jsi_Wide flags;\n    const char *errStr;\n    void *reserved[4];     /* Reserved for future */\n} Jsi_JsonParser;\n\n\nJSI_EXTERN void Jsi_JsonInit(Jsi_JsonParser *parser, Jsi_JsonTok *static_tokens, uint num_tokens); /*STUB = 352*/\nJSI_EXTERN void Jsi_JsonReset(Jsi_JsonParser *parser); /*STUB = 353*/\nJSI_EXTERN void Jsi_JsonFree(Jsi_JsonParser *parser); /*STUB = 354*/\nJSI_EXTERN Jsi_JsonErrEnum Jsi_JsonParse(Jsi_JsonParser *parser, const char *js); /*STUB = 355*/\nJSI_EXTERN Jsi_JsonTok* Jsi_JsonGetToken(Jsi_JsonParser *parser, uint index); /*STUB = 356*/\nJSI_EXTERN Jsi_JsonTypeEnum Jsi_JsonGetType(Jsi_JsonParser *parser, uint index); /*STUB = 357*/\nJSI_EXTERN int Jsi_JsonTokLen(Jsi_JsonParser *parser, uint index); /*STUB = 358*/\nJSI_EXTERN const char* Jsi_JsonGetTokstr(Jsi_JsonParser *parser, const char *js, uint index, uint *len); /*STUB = 359*/\nJSI_EXTERN const char* Jsi_JsonGetTypename(int type); /*STUB = 360*/\nJSI_EXTERN const char* Jsi_JsonGetErrname(int code); /*STUB = 361*/\nJSI_EXTERN void Jsi_JsonDump(Jsi_JsonParser *parser, const char *js); /*STUB = 362*/\n/* -- */\n\n\n/* --VFS-- */\nstruct Jsi_LoadHandle; struct Jsi_LoadHandle;\n\ntypedef struct Jsi_LoadHandle Jsi_LoadHandle;\ntypedef struct stat Jsi_StatBuf;\ntypedef struct dirent Jsi_Dirent;\n\ntypedef int (Jsi_FSStatProc) (Jsi_Interp *interp, Jsi_Value* path, Jsi_StatBuf *buf);\ntypedef int (Jsi_FSAccessProc) (Jsi_Interp *interp, Jsi_Value* path, int mode);\ntypedef int (Jsi_FSChmodProc) (Jsi_Interp *interp, Jsi_Value* path, int mode);\ntypedef Jsi_Channel (Jsi_FSOpenProc) (Jsi_Interp *interp, Jsi_Value* path, const char* modes);\ntypedef int (Jsi_FSLstatProc) (Jsi_Interp *interp, Jsi_Value* path, Jsi_StatBuf *buf);\ntypedef int (Jsi_FSCreateDirectoryProc) (Jsi_Interp *interp, Jsi_Value* path);\ntypedef int (Jsi_FSRemoveProc) (Jsi_Interp *interp, Jsi_Value* path, int flags);\ntypedef int (Jsi_FSCopyDirectoryProc) (Jsi_Interp *interp, Jsi_Value *srcPathPtr, Jsi_Value *destPathPtr, Jsi_Value **errorPtr);\ntypedef int (Jsi_FSCopyFileProc) (Jsi_Interp *interp, Jsi_Value *srcPathPtr, Jsi_Value *destPathPtr);\ntypedef int (Jsi_FSRemoveDirectoryProc) (Jsi_Interp *interp, Jsi_Value* path, int recursive, Jsi_Value **errorPtr);\ntypedef int (Jsi_FSRenameProc) (Jsi_Interp *interp, Jsi_Value *srcPathPtr, Jsi_Value *destPathPtr);\ntypedef Jsi_Value * (Jsi_FSListVolumesProc) (Jsi_Interp *interp);\ntypedef char* (Jsi_FSRealPathProc) (Jsi_Interp *interp, Jsi_Value* path, char *newPath);\ntypedef int (Jsi_FSLinkProc) (Jsi_Interp *interp, Jsi_Value* path, Jsi_Value *toPath, int linkType);\ntypedef int (Jsi_FSReadlinkProc)(Jsi_Interp *interp, Jsi_Value *path, char *buf, int size);\ntypedef int (Jsi_FSReadProc)(Jsi_Channel chan, char *buf, int size);\ntypedef int (Jsi_FSGetcProc)(Jsi_Channel chan);\ntypedef int (Jsi_FSEofProc)(Jsi_Channel chan);\ntypedef int (Jsi_FSTruncateProc)(Jsi_Channel chan, uint len);\ntypedef int (Jsi_FSUngetcProc)(Jsi_Channel chan, int ch);\ntypedef char *(Jsi_FSGetsProc)(Jsi_Channel chan, char *s, int size);\ntypedef int (Jsi_FSPutsProc)(Jsi_Channel chan, const char* str);\ntypedef int (Jsi_FSWriteProc)(Jsi_Channel chan, const char *buf, int size);\ntypedef int (Jsi_FSFlushProc)(Jsi_Channel chan);\ntypedef int (Jsi_FSSeekProc)(Jsi_Channel chan, Jsi_Wide offset, int mode);\ntypedef int (Jsi_FSTellProc)(Jsi_Channel chan);\ntypedef int (Jsi_FSCloseProc)(Jsi_Channel chan);\ntypedef int (Jsi_FSRewindProc)(Jsi_Channel chan);\ntypedef bool (Jsi_FSPathInFilesystemProc) (Jsi_Interp *interp, Jsi_Value* path,void* *clientDataPtr);\ntypedef int (Jsi_FSScandirProc)(Jsi_Interp *interp, Jsi_Value *path, Jsi_Dirent ***namelist,\n  int (*filter)(const Jsi_Dirent *), int (*compar)(const Jsi_Dirent **, const Jsi_Dirent**));\n\ntypedef struct Jsi_Filesystem {\n    const char *typeName;\n    int structureLength;    \n    int version;\n    Jsi_FSPathInFilesystemProc *pathInFilesystemProc;\n    Jsi_FSRealPathProc *realpathProc;\n    Jsi_FSStatProc *statProc;\n    Jsi_FSLstatProc *lstatProc;\n    Jsi_FSAccessProc *accessProc;\n    Jsi_FSChmodProc *chmodProc;\n    Jsi_FSOpenProc *openProc;\n    Jsi_FSScandirProc *scandirProc;\n    Jsi_FSReadProc *readProc;\n    Jsi_FSWriteProc *writeProc;\n    Jsi_FSGetsProc *getsProc;\n    Jsi_FSGetcProc *getcProc;\n    Jsi_FSUngetcProc *ungetcProc;\n    Jsi_FSPutsProc *putsProc;\n    \n    Jsi_FSFlushProc *flushProc;\n    Jsi_FSSeekProc *seekProc;\n    Jsi_FSTellProc *tellProc;\n    Jsi_FSEofProc *eofProc;\n    Jsi_FSTruncateProc *truncateProc;\n    Jsi_FSRewindProc *rewindProc;\n    Jsi_FSCloseProc *closeProc;\n    Jsi_FSLinkProc *linkProc;\n    Jsi_FSReadlinkProc *readlinkProc;\n    Jsi_FSListVolumesProc *listVolumesProc;\n    Jsi_FSCreateDirectoryProc *createDirectoryProc;\n    Jsi_FSRemoveProc *removeProc;\n    Jsi_FSRenameProc *renameProc;\n    void *reserved[10];     /* Reserved for future */\n} Jsi_Filesystem;\n\ntypedef struct Jsi_Chan {\n    FILE *fp;\n    const char *fname;  /* May be set by fs or by source */\n    Jsi_Filesystem *fsPtr;\n    int isNative;\n    int flags;\n    char modes[JSI_FSMODESIZE];\n    void *data;\n    void *reserved[4];     /* Reserved for future */\n    ssize_t resInt[2];\n} Jsi_Chan;\n\nJSI_EXTERN Jsi_RC Jsi_FSRegister(Jsi_Filesystem *fsPtr, void *data); /*STUB = 363*/\nJSI_EXTERN Jsi_RC Jsi_FSUnregister(Jsi_Filesystem *fsPtr); /*STUB = 364*/\nJSI_EXTERN Jsi_Channel Jsi_FSNameToChannel(Jsi_Interp *interp, const char *name); /*STUB = 365*/\nJSI_EXTERN char* Jsi_GetCwd(Jsi_Interp *interp, Jsi_DString *cwdPtr); /*STUB = 366*/\nJSI_EXTERN int Jsi_Lstat(Jsi_Interp *interp, Jsi_Value* path, Jsi_StatBuf *buf); /*STUB = 367*/\nJSI_EXTERN int Jsi_Stat(Jsi_Interp *interp, Jsi_Value* path, Jsi_StatBuf *buf); /*STUB = 368*/\nJSI_EXTERN int Jsi_Access(Jsi_Interp *interp, Jsi_Value* path, int mode); /*STUB = 369*/\nJSI_EXTERN int Jsi_Remove(Jsi_Interp *interp, Jsi_Value* path, int flags); /*STUB = 370*/\nJSI_EXTERN int Jsi_Rename(Jsi_Interp *interp, Jsi_Value *src, Jsi_Value *dst); /*STUB = 371*/\nJSI_EXTERN int Jsi_Chdir(Jsi_Interp *interp, Jsi_Value* path); /*STUB = 372*/\nJSI_EXTERN Jsi_Channel Jsi_Open(Jsi_Interp *interp, Jsi_Value *file, const char *modeString); /*STUB = 373*/\nJSI_EXTERN int Jsi_Eof(Jsi_Interp *interp, Jsi_Channel chan); /*STUB = 374*/\nJSI_EXTERN int Jsi_Close(Jsi_Interp *interp, Jsi_Channel chan); /*STUB = 375*/\nJSI_EXTERN int Jsi_Read(Jsi_Interp *interp, Jsi_Channel chan, char *bufPtr, int toRead); /*STUB = 376*/\nJSI_EXTERN int Jsi_Write(Jsi_Interp *interp, Jsi_Channel chan, const char *bufPtr, int slen); /*STUB = 377*/\nJSI_EXTERN Jsi_Wide Jsi_Seek(Jsi_Interp *interp, Jsi_Channel chan, Jsi_Wide offset, int mode); /*STUB = 378*/\nJSI_EXTERN Jsi_Wide Jsi_Tell(Jsi_Interp *interp, Jsi_Channel chan); /*STUB = 379*/\nJSI_EXTERN int Jsi_Truncate(Jsi_Interp *interp, Jsi_Channel chan, uint len); /*STUB = 380*/\nJSI_EXTERN Jsi_Wide Jsi_Rewind(Jsi_Interp *interp, Jsi_Channel chan); /*STUB = 381*/\nJSI_EXTERN int Jsi_Flush(Jsi_Interp *interp, Jsi_Channel chan); /*STUB = 382*/\nJSI_EXTERN int Jsi_Getc(Jsi_Interp *interp, Jsi_Channel chan); /*STUB = 383*/\nJSI_EXTERN int Jsi_Printf(Jsi_Interp *interp, Jsi_Channel chan, const char *fmt, ...) /*STUB = 384*/ __attribute__((format (printf,3,4))); \nJSI_EXTERN int Jsi_Ungetc(Jsi_Interp *interp, Jsi_Channel chan, int ch); /*STUB = 385*/\nJSI_EXTERN char* Jsi_Gets(Jsi_Interp *interp, Jsi_Channel chan, char *s, int size); /*STUB = 386*/\nJSI_EXTERN int Jsi_Puts(Jsi_Interp *interp, Jsi_Channel chan, const char *str, int size); /*STUB = 387*/\n\ntypedef int (Jsi_ScandirFilter)(const Jsi_Dirent *);\ntypedef int (Jsi_ScandirCompare)(const Jsi_Dirent **, const Jsi_Dirent**);\nJSI_EXTERN int Jsi_Scandir(Jsi_Interp *interp, Jsi_Value *path, Jsi_Dirent ***namelist, Jsi_ScandirFilter *filter, Jsi_ScandirCompare *compare ); /*STUB = 388*/\nJSI_EXTERN int Jsi_SetChannelOption(Jsi_Interp *interp, Jsi_Channel chan, const char *optionName, const char *newValue); /*STUB = 389*/\nJSI_EXTERN char* Jsi_Realpath(Jsi_Interp *interp, Jsi_Value *path, char *newname); /*STUB = 390*/\nJSI_EXTERN int Jsi_Readlink(Jsi_Interp *interp, Jsi_Value* path, char *ret, int len); /*STUB = 391*/\nJSI_EXTERN Jsi_Channel Jsi_GetStdChannel(Jsi_Interp *interp, int id); /*STUB = 392*/\nJSI_EXTERN bool Jsi_FSNative(Jsi_Interp *interp, Jsi_Value* path); /*STUB = 393*/\nJSI_EXTERN int Jsi_Link(Jsi_Interp *interp, Jsi_Value* src, Jsi_Value *dest, int typ); /*STUB = 394*/\nJSI_EXTERN int Jsi_Chmod(Jsi_Interp *interp, Jsi_Value* path, int mode); /*STUB = 395*/\n\nJSI_EXTERN Jsi_RC Jsi_StubLookup(Jsi_Interp *interp, const char *name, void **ptr); /*STUB = 396*/\nJSI_EXTERN Jsi_RC Jsi_DllLookup(Jsi_Interp *interp, const char *module, const char *name, void **ptr); /*STUB = 404*/\nJSI_EXTERN Jsi_RC Jsi_LoadLibrary(Jsi_Interp *interp, const char *pathName, bool noInit); /*STUB = 405*/\nJSI_EXTERN int Jsi_AddAutoFiles(Jsi_Interp *interp, const char *dir);  /*STUB = 397*/\n\n/* -- */\n\n\n\n/* --DATABASE-- */\n\nJSI_EXTERN Jsi_Db* Jsi_DbNew(const char *zFile, int inFlags); /*STUB = 398*/\nJSI_EXTERN void* Jsi_DbHandle(Jsi_Interp *interp, Jsi_Db* db); /*STUB = 399*/\n\n/* -- */\n\n\n/* --CData-- */\n\n#define  JSI_CDATA_OPTION_CHANGED(name) \\\n        (vrPtr->spec && Jsi_OptionsChanged(interp, vrPtr->spec, #name, NULL))\n#define  JSI_CDATA_OPTION_RESET(name) \\\n        (cmdPtr->queryOpts.mode && !options->name && JSI_CDATA_OPTION_CHANGED(name))\n \ntypedef struct Jsi_CData_Static {\n    const char* name;\n    Jsi_StructSpec* structs;\n    Jsi_EnumSpec* enums;\n    Jsi_VarSpec *vars;\n    Jsi_OptionTypedef* types;\n    struct Jsi_CData_Static* nextPtr;\n} Jsi_CData_Static;\n\n/* Struct for Carray to bind Data/Option pairs to individual SQLite binding chars. */\ntypedef struct Jsi_CDataDb {\n#define JSI_DBDATA_FIELDS \\\n    Jsi_StructSpec *sf;     /* Struct fields for data. */ \\\n    void *data;             /* Data pointer for array/map */ \\\n    uint arrSize;           /* If an array, number of elements: 0 means 1. */ \\\n    char prefix;            /* Sqlite char bind prefix. One of: '@' '$' ':' '?' or 0 for any */ \\\n    Jsi_StructSpec* slKey;  /* Struct for key (for map using a struct key). */ \\\n    int (*callback)(Jsi_Interp *interp, struct Jsi_CDataDb* obPtr, void *data); /* C callback for select queries. */ \\\n    uint maxSize;           /* Limit size of array/map*/ \\\n    bool noAuto;            /* Do not auto-create map keys. */ \\\n    bool isPtrs;            /* \"data\" an array of pointers. */ \\\n    bool isPtr2;            /* \"data\" is pointer to pointers, which is updated. */ \\\n    bool isMap;             /* \"data\" is a map: use Jsi_MapConf() for details. */ \\\n    bool memClear;          /* Before query free and zero all data (eg. DStrings). */ \\\n    bool memFree;           /* Reset as per mem_clear, then free data items. Query may be empty. */ \\\n    bool dirtyOnly;         /* Sqlite dirty filter for UPDATE/INSERT/REPLACE. */ \\\n    bool noBegin;           /* Disable wrapping UPDATE in BEGIN/COMMIT. */ \\\n    bool noCache;           /* Disable Db caching statement. */ \\\n    bool noStatic;          /* Disable binding text with SQLITE_STATIC. */ \\\n    intptr_t reserved[4];   /* Internal use. */\nJSI_DBDATA_FIELDS\n} Jsi_CDataDb;\n\nJSI_EXTERN int Jsi_DbQuery(Jsi_Db *jdb, Jsi_CDataDb *cd, const char *query); /*STUB = 400*/\nJSI_EXTERN Jsi_CDataDb* Jsi_CDataLookup(Jsi_Interp *interp, const char *name); /*STUB = 401*/\nJSI_EXTERN Jsi_RC Jsi_CDataRegister(Jsi_Interp *interp, Jsi_CData_Static *statics); /*STUB = 402*/\nJSI_EXTERN Jsi_RC Jsi_CDataStructInit(Jsi_Interp *interp, uchar* data, const char *sname); /*STUB = 403*/\nJSI_EXTERN Jsi_StructSpec* Jsi_CDataStruct(Jsi_Interp *interp, const char *name); /*STUB = 406*/\n/* -- */\n\n\n/* String */\ntypedef char STRING1[(1<<0)+1]; // Include a char for the null byte.\ntypedef char STRING2[(1<<1)+1];\ntypedef char STRING4[(1<<2)+1];\ntypedef char STRING8[(1<<3)+1];\ntypedef char STRING16[(1<<4)+1];\ntypedef char STRING32[(1<<5)+1];\ntypedef char STRING64[(1<<6)+1];\ntypedef char STRING128[(1<<7)+1];\ntypedef char STRING256[(1<<8)+1];\ntypedef char STRING512[(1<<9)+1];\ntypedef char STRING1024[(1<<10)+1];\ntypedef char STRING2048[(1<<11)+1];\ntypedef char STRING4096[(1<<12)+1];\ntypedef char STRING8192[(1<<13)+1];\ntypedef char STRING16384[(1<<14)+1];\ntypedef char STRING32768[(1<<15)+1];\ntypedef char STRING65536[(1<<16)+1];\n\n/* -- */\n\n\n#define JSI_STUBS_STRUCTSIZES (sizeof(Jsi_MapSearch)+sizeof(Jsi_TreeSearch) \\\n    +sizeof(Jsi_HashSearch)+sizeof(Jsi_Filesystem)+sizeof(Jsi_Chan)+sizeof(Jsi_Event) \\\n    +sizeof(Jsi_CDataDb)+sizeof(Jsi_Stack)+sizeof(Jsi_OptionSpec)+sizeof(Jsi_CmdSpec) \\\n    +sizeof(Jsi_UserObjReg)+sizeof(Jsi_String) + sizeof(Jsi_PkgOpts))\n\n#ifndef JSI_OMIT_STUBS\n#ifdef JSI_USE_STUBS\n#ifndef JSISTUBCALL\n#define JSISTUBCALL(ptr,func) ptr->func\n#endif\n#include \"jsiStubs.h\"\n#else\n#define JSI_EXTENSION_INI\n#define Jsi_StubsInit(i,f) JSI_OK\n#endif\n#endif\n\n\n/* Optional compile-out commands/options string information. */\n#ifdef JSI_OMIT_INFO\n#define JSI_INFO(n) NULL\n#endif\n#ifndef JSI_INFO\n#define JSI_INFO(n) n\n#endif\n\n#endif /* __JSI_H__ */\n\n\n", "#ifndef JSI_LITE_ONLY\n#ifndef JSI_AMALGAMATION\n#include \"jsiInt.h\"\n#else\nchar *strptime(const char *buf, const char *fmt, struct tm *tm);\n#endif\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <signal.h>\n#include <limits.h>\n#ifndef __WIN32\n#include <sys/wait.h>\n#endif\n\nstatic Jsi_RC consoleInputCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[1024];\n    char *cp, *p = buf;\n    buf[0] = 0;\n    if (!interp->stdinStr)\n        p=fgets(buf, sizeof(buf), stdin);\n    else {\n        int ilen;\n        cp = Jsi_ValueString(interp, interp->stdinStr, &ilen);\n        if (!cp || ilen<=0)\n            p = NULL;\n        else {\n            Jsi_Strncpy(buf, cp, sizeof(buf));\n            buf[sizeof(buf)-1] = 0;\n            p = Jsi_Strchr(buf, '\\n');\n            if (p) { *p = 0;}\n            ilen = Jsi_Strlen(buf);\n            p = (cp + ilen + (p?1:0));\n            Jsi_ValueMakeStringDup(interp, &interp->stdinStr, p);\n            p = buf;\n        }\n    }\n    \n    if (p == NULL) {\n        Jsi_ValueMakeUndef(interp, ret);\n        return JSI_OK;\n    }\n    if ((p = Jsi_Strchr(buf, '\\r'))) *p = 0;\n    if ((p = Jsi_Strchr(buf, '\\n'))) *p = 0;\n    Jsi_ValueMakeStringDup(interp, ret, buf);\n    return JSI_OK;\n}\n\ntypedef struct {\n    bool trace;\n    bool once;\n    bool noError;\n    bool autoIndex;\n    bool isMain;\n    bool global;\n    bool exists;\n    uint level;\n} SourceData;\n\nstatic Jsi_OptionSpec SourceOptions[] = {\n    JSI_OPT(BOOL,   SourceData, autoIndex,  .help=\"Look for and load Jsi_Auto.jsi auto-index file\" ),\n    JSI_OPT(BOOL,   SourceData, exists, .help=\"Source file only if exists\" ),\n    JSI_OPT(BOOL,   SourceData, global, .help=\"File is to be sourced in global frame rather than local\" ),\n    JSI_OPT(BOOL,   SourceData, isMain, .help=\"Coerce to true the value of Info.isMain()\" ),\n    JSI_OPT(UINT,   SourceData, level,  .help=\"Frame to source file in\" ),\n    JSI_OPT(BOOL,   SourceData, noError,.help=\"Ignore errors in sourced file\" ),\n    JSI_OPT(BOOL,   SourceData, once,   .help=\"Source file only if not already sourced (Default: Interp.debugOpts.includeOnce)\" ),\n    JSI_OPT(BOOL,   SourceData, trace,  .help=\"Trace include statements (Default: Interp.debugOpts.includeTrace)\" ),\n    JSI_OPT_END(SourceData, .help=\"Options for source command\")\n};\n\n\nstatic Jsi_RC SysSourceCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    jsi_Pstate *ps = interp->ps;\n    Jsi_RC rc = JSI_OK;\n    int flags = 0;\n    int i, argc;\n    SourceData data = {.trace = interp->debugOpts.includeTrace, .once = interp->debugOpts.includeOnce};\n    Jsi_Value *v, *va = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_Value *vo = Jsi_ValueArrayIndex(interp, args, 1);\n    if (vo) {\n        if (!Jsi_ValueIsObjType(interp, vo, JSI_OT_OBJECT)) { /* Future options. */\n            Jsi_LogError(\"arg2: expected object 'options'\");\n            return JSI_ERROR;\n        }\n        if (Jsi_OptionsProcess(interp, SourceOptions, &data, vo, 0) < 0) {\n            return JSI_ERROR;\n        }\n        if (data.autoIndex)\n            flags |= JSI_EVAL_AUTOINDEX;\n    }\n    if ((interp->includeDepth+1) > interp->maxIncDepth) \n        return Jsi_LogError(\"max source depth exceeded\");\n    if (data.once)\n        flags|= JSI_EVAL_ONCE;\n    if (data.exists)\n        flags|= JSI_EVAL_EXISTS;\n    if (data.noError)\n        flags|= JSI_EVAL_ERRIGNORE;\n    if (data.global) {\n        flags|= JSI_EVAL_GLOBAL;\n        if (data.level)\n            return Jsi_LogError(\"invalid ot specify both global and level\");\n    } else if (!data.level)\n        data.level = interp->framePtr->level;\n    interp->includeCnt++;\n    interp->includeDepth++;\n    int oisi = interp->isMain;\n    interp->isMain = data.isMain;\n    const char *sop = (data.once?\" <ONCE>\":\"\");\n    if (!Jsi_ValueIsArray(interp, va)) {\n        v = va;\n        if (v && Jsi_ValueIsString(interp,v)) {\n            if (data.trace)\n                Jsi_LogInfo(\"sourcing: %s%s\", Jsi_ValueString(interp, v, 0), sop);\n            rc = jsi_evalStrFile(ps->interp, v, NULL, flags, data.level);\n        } else {\n            Jsi_LogError(\"expected string\");\n            rc = JSI_ERROR;\n        }\n        goto done;\n    }\n    argc = Jsi_ValueGetLength(interp, va);\n    for (i=0; i<argc && rc == JSI_OK; i++) {\n        v = Jsi_ValueArrayIndex(interp, va, i);\n        if (v && Jsi_ValueIsString(interp,v)) {\n            if (data.trace)\n                Jsi_LogInfo(\"sourcing: %s%s\", Jsi_ValueString(interp, v, 0), sop);\n            rc = jsi_evalStrFile(ps->interp, v, 0, flags, data.level);\n        } else {\n            Jsi_LogError(\"expected string\");\n            rc = JSI_ERROR;\n            break;\n        }\n    }\ndone:\n    if (rc == JSI_OK)\n        Jsi_ValueCopy(interp, *ret, interp->retValue);\n    interp->isMain = oisi;\n    interp->includeDepth--;\n    return rc;\n}\n\nstatic void jsiGetTime(long *seconds, long *milliseconds)\n{\n    struct timeval tv;\n\n    gettimeofday(&tv, NULL);\n    *seconds = tv.tv_sec;\n    *milliseconds = tv.tv_usec / 1000;\n}\n\nvoid Jsi_EventFree(Jsi_Interp *interp, Jsi_Event* event) {\n    SIGASSERTV(event,EVENT);\n    if (event->funcVal)\n        Jsi_DecrRefCount(interp, event->funcVal);\n    if (event->hPtr) {\n        Jsi_HashValueSet(event->hPtr, NULL);\n        Jsi_HashEntryDelete(event->hPtr);\n    }\n    _JSI_MEMCLEAR(event);\n    Jsi_Free(event);\n}\n\n/* Create an event and add to interp event table. */\nJsi_Event* Jsi_EventNew(Jsi_Interp *interp, Jsi_EventHandlerProc *callback, void* data)\n{\n    Jsi_Event *evPtr;\n    while (1) {\n        bool isNew;\n        uintptr_t id = ++interp->eventIdx;\n        Jsi_HashEntry *hPtr = Jsi_HashEntryNew(interp->eventTbl, (void*)id, &isNew);\n        if (!isNew)\n            continue;\n        evPtr = (Jsi_Event*)Jsi_Calloc(1, sizeof(*evPtr));\n        SIGINIT(evPtr,EVENT);\n        evPtr->id = id;\n        evPtr->handler = callback;\n        evPtr->data = data;\n        evPtr->hPtr = hPtr;\n        Jsi_HashValueSet(hPtr, evPtr);\n        break;\n    }\n    return evPtr;\n}\n\n/* Process events and return count. */\nint Jsi_EventProcess(Jsi_Interp *interp, int maxEvents)\n{\n    Jsi_Event *evPtr;\n    Jsi_HashEntry *hPtr;\n    Jsi_HashSearch search;\n    Jsi_Value* nret = NULL;\n    Jsi_RC rc;\n    int cnt = 0, newIdx = interp->eventIdx;\n    long cur_sec, cur_ms;\n    jsiGetTime(&cur_sec, &cur_ms);\n    Jsi_Value *vpargs = NULL;\n\n    /*if (Jsi_MutexLock(interp, interp->Mutex) != JSI_OK)\n        return JSI_ERROR;*/\n\n    for (hPtr = Jsi_HashSearchFirst(interp->eventTbl, &search);\n            hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {\n\n        if (!(evPtr = (Jsi_Event*)Jsi_HashValueGet(hPtr)))\n            continue;\n        SIGASSERT(evPtr,EVENT);\n        if ((int)evPtr->id > newIdx) /* Avoid infinite loop of event creating events. */\n            continue;\n        switch (evPtr->evType) {\n        case JSI_EVENT_SIGNAL:\n#ifndef JSI_OMIT_SIGNAL   /* TODO: win signals? */\n            if (!jsi_SignalIsSet(interp, evPtr->sigNum))\n                continue;\n            jsi_SignalClear(interp, evPtr->sigNum);\n#endif\n            break;\n        case JSI_EVENT_TIMER:\n            if (cur_sec <= evPtr->when_sec && (cur_sec != evPtr->when_sec || cur_ms < evPtr-> when_ms)) {\n                if (evPtr->when_sec && evPtr->when_ms)\n                    continue;\n            }\n            cnt++;\n            evPtr->count++;\n            break;\n        case JSI_EVENT_ALWAYS:\n            break;\n        default:\n            assert(0);\n        }\n        if (evPtr->busy)\n            continue;\n        evPtr->busy = 1;\n        if (evPtr->handler) {\n            rc = evPtr->handler(interp, evPtr->data);\n        } else {\n            if (vpargs == NULL) {\n                vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, NULL, 0, 0));\n                Jsi_IncrRefCount(interp, vpargs);\n            }\n            if (!nret)\n                nret = Jsi_ValueNew1(interp);\n            rc = Jsi_FunctionInvoke(interp, evPtr->funcVal, vpargs, &nret, NULL);\n        }\n        evPtr->busy = 0;\n        if (interp->deleting) {\n            cnt = -1;\n            goto bail;\n        }\n        if (rc != JSI_OK) {\n            if (interp->exited) {\n                cnt = rc;\n                goto bail;\n            }\n            Jsi_LogError(\"event function call failure\");\n        }\n        if (evPtr->once) {\n            Jsi_EventFree(interp, evPtr);\n        } else {\n            evPtr->when_sec = cur_sec + evPtr->initialms / 1000;\n            evPtr->when_ms = cur_ms + evPtr->initialms % 1000;\n            if (evPtr->when_ms >= 1000) {\n                evPtr->when_sec++;\n                evPtr->when_ms -= 1000;\n            }\n        }\n        if (maxEvents>=0 && cnt>=maxEvents)\n            break;\n    }\nbail:\n    if (vpargs)\n        Jsi_DecrRefCount(interp, vpargs);\n    if (nret)\n        Jsi_DecrRefCount(interp, nret);\n    /*Jsi_MutexUnlock(interp, interp->Mutex);*/\n\n    static int evCnt = 0;\n    evCnt++;\n    if (interp->parent && interp->busyCallback)\n        Jsi_EventProcess(interp->parent, maxEvents);\n    return cnt;\n}\n\n/*\n * \\brief: sleep for so many milliseconds with interp mutex unlocked.\n */\nJsi_RC Jsi_Sleep(Jsi_Interp *interp, Jsi_Number dtim) {\n    uint utim = 0;\n    if (dtim <= 0)\n        return JSI_OK;\n    Jsi_MutexUnlock(interp, interp->Mutex);\n    dtim = (dtim/1e3);\n    if (dtim>1) {\n        utim = 1e6*(dtim - (Jsi_Number)((int)dtim));\n        dtim = (int)dtim;\n    } else if (dtim<1) {\n        utim = 1e6 * dtim;\n        dtim = 0;\n    }\n    if (utim>0)\n        usleep(utim);\n    if (dtim>0)\n        sleep(dtim);\n    if (Jsi_MutexLock(interp, interp->Mutex) != JSI_OK) {\n        Jsi_LogBug(\"could not reget mutex\");\n        return JSI_ERROR;\n    }\n    return JSI_OK;\n}\n\n#ifndef JSI_OMIT_EVENT\ntypedef struct {\n    int minTime;\n    int maxEvents;\n    int maxPasses;\n    int sleep;\n} jsiUpdateData;\n\nstatic Jsi_OptionSpec jsiUpdateOptions[] = {\n    JSI_OPT(INT,    jsiUpdateData, maxEvents,  .help=\"Maximum number of events to process (or -1 for all)\" ),\n    JSI_OPT(INT,    jsiUpdateData, maxPasses,  .help=\"Maximum passes through event queue\" ),\n    JSI_OPT(INT,    jsiUpdateData, minTime,    .help=\"Minimum milliseconds before returning, or -1 to loop forever (default is 0)\" ),\n    JSI_OPT(INT,    jsiUpdateData, sleep,      .help=\"Time to sleep time (in milliseconds) between event checks. Default is 1\" ),\n    JSI_OPT_END(jsiUpdateData, .help=\"Options for update command\")\n};\n\n#define FN_update JSI_INFO(\"\\\nReturns the number of events processed. \\\nEvents are processed until minTime (in milliseconds) is exceeded, or forever if -1.\\n\\\nThe default minTime is 0, meaning return as soon as no events can be processed. \\\nA positive mintime will result in sleeps between event checks.\")\nstatic Jsi_RC SysUpdateCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int maxEvents = -1, hasopts = 0;\n    int cnt = 0, lcnt = 0;\n    Jsi_RC rc = JSI_OK;\n    Jsi_Value *opts = Jsi_ValueArrayIndex(interp, args, 0);\n    long cur_sec, cur_ms;\n    long start_sec, start_ms;\n    jsiGetTime(&start_sec, &start_ms);\n    jsiUpdateData udata = {};\n    udata.sleep = 1;\n       \n    if (opts != NULL) {\n        Jsi_Number dms = 0;\n        if (opts->vt == JSI_VT_OBJECT) {\n            hasopts = 1;\n            if (Jsi_OptionsProcess(interp, jsiUpdateOptions, &udata, opts, 0) < 0) {\n                return JSI_ERROR;\n            }\n        } else if (opts->vt != JSI_VT_NULL && Jsi_GetNumberFromValue(interp, opts, &dms) != JSI_OK)\n            return JSI_ERROR;\n        else\n            udata.minTime = (unsigned long)dms;\n    }\n  \n    while (1) {\n        long long diftime;\n        if (!interp->EventHdlId && (interp->interpStrEvents || Jsi_DSLength(&interp->interpEvalQ)))\n            jsi_AddEventHandler(interp); \n        int ne = Jsi_EventProcess(interp, maxEvents);\n        if (ne<0)\n            break;\n        cnt += ne;\n        if (Jsi_InterpGone(interp))\n            return JSI_ERROR;\n        if (udata.minTime==0)\n            break;\n        jsiGetTime(&cur_sec, &cur_ms);\n        if (cur_sec == start_sec)\n            diftime = (long long)(cur_ms-start_ms);\n        else\n            diftime = (cur_sec-start_sec)*1000LL + cur_ms + (1000-start_ms);\n        if (udata.minTime>0 && diftime >= (long long)udata.minTime)\n            break;\n        if (udata.maxPasses && ++lcnt >= udata.maxPasses)\n            break;\n        if ((rc = Jsi_Sleep(interp, udata.sleep)) != JSI_OK)\n            break;\n    }\n    if (hasopts)\n        Jsi_OptionsFree(interp, jsiUpdateOptions, &udata, 0);\n    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)cnt);\n    return rc;\n}\n\nstatic Jsi_RC intervalTimer(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr, int once)\n{\n    bool isNew;\n    Jsi_Event *evPtr;\n    uintptr_t id;\n    Jsi_Number milli;\n    long milliseconds, cur_sec, cur_ms;\n    Jsi_Value *fv = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_Value *tv = Jsi_ValueArrayIndex(interp, args, 1);\n    \n    if (!Jsi_ValueIsFunction(interp, fv)) \n        return Jsi_LogError(\"arg1: expected function 'callback'\");\n    if (Jsi_GetNumberFromValue(interp, tv, &milli) != JSI_OK) \n        return Jsi_LogError(\"arg2: expected number 'ms'\");\n    milliseconds = (long)milli;\n    if (milliseconds < 0)\n        milliseconds = 0;\n    while (1) {\n        id = ++interp->eventIdx;\n        Jsi_HashEntry *hPtr = Jsi_HashEntryNew(interp->eventTbl, (void*)id, &isNew);\n        if (!isNew)\n            continue;\n        evPtr = (Jsi_Event*)Jsi_Calloc(1, sizeof(*evPtr));\n        SIGINIT(evPtr,EVENT);\n        evPtr->id = id;\n        evPtr->funcVal = fv;\n        Jsi_IncrRefCount(interp, fv);\n        evPtr->hPtr = hPtr;\n        jsiGetTime(&cur_sec, &cur_ms);\n        evPtr->initialms = milliseconds;\n        evPtr->when_sec = cur_sec + milliseconds / 1000;\n        evPtr->when_ms = cur_ms + milliseconds % 1000;\n        if (evPtr->when_ms >= 1000) {\n            evPtr->when_sec++;\n            evPtr->when_ms -= 1000;\n        }\n        evPtr->once = once;\n        Jsi_HashValueSet(hPtr, evPtr);\n        break;\n    }\n    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)id);\n    return JSI_OK;\n}\n\nstatic Jsi_RC setIntervalCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    return intervalTimer(interp, args, _this, ret, funcPtr, 0);\n}\n\nstatic Jsi_RC clearIntervalCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Number nid;\n    uintptr_t id;\n    Jsi_Value *tv = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_HashEntry *hPtr;\n    if (Jsi_GetNumberFromValue(interp, tv, &nid) != JSI_OK) \n        return Jsi_LogError(\"arg1: expected number 'ms'\");\n    id = (uintptr_t)nid;\n    if (interp->EventHdlId && id==interp->EventHdlId)\n        return Jsi_LogError(\"can not clear internal handler\");\n    hPtr = Jsi_HashEntryFind(interp->eventTbl, (void*)id);\n    if (hPtr == NULL) \n        return Jsi_LogError(\"id not found: %\" PRId64, (Jsi_Wide)id);\n    Jsi_HashEntryDelete(hPtr);\n    return JSI_OK;\n}\n\nstatic Jsi_RC setTimeoutCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    return intervalTimer(interp, args, _this, ret, funcPtr, 1);\n}\n#endif\n\nstatic Jsi_RC SysExitCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int err = 0;\n    Jsi_Value *v = NULL;\n    Jsi_Number n;\n    if (Jsi_ValueGetLength(interp, args) > 0) {\n        v = Jsi_ValueArrayIndex(interp, args, 0);\n        if (v && Jsi_GetNumberFromValue(interp,v, &n) == JSI_OK)\n            err = (int)n;\n        else \n            return Jsi_LogError(\"arg1: expected number 'code'\");\n    }\n    if (interp->onExit && interp->parent) {\n        bool b = Jsi_FunctionInvokeBool(interp->parent, interp->onExit, v);\n        if (Jsi_InterpGone(interp))\n            return JSI_ERROR;\n        if (b)\n            return JSI_OK;\n    }\n    if (interp->parent == NULL && interp == interp->mainInterp && interp->debugOpts.isDebugger)\n        jsi_DoExit(interp, err); // In debugger, skip memory cleanup.\n    else {\n        interp->exited = 1;\n        interp->exitCode = err;\n        return JSI_ERROR;\n        /* TODO: cleanup events, etc. */\n    }\n    return JSI_OK;\n}\n\n\nstatic Jsi_RC parseIntCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Wide w = 0;\n    Jsi_Number d = 0;\n\n    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_Value *bv = Jsi_ValueArrayIndex(interp, args, 1);\n    if (!v)\n        return JSI_ERROR;\n    char *eptr, *str = Jsi_ValueString(interp, v, NULL);\n    int base = 0;\n    if (!str) {\n        if (Jsi_ValueIsNumber(interp, v))\n            Jsi_GetNumberFromValue(interp, v, &d);\n        else\n            goto nanval;\n    }\n    else if (str[0] == '0' && str[1] == 'x')\n        d = (Jsi_Number)strtoll(str, &eptr, 16);\n    else if (str[0] == '0' && !bv)\n        d = (Jsi_Number)strtoll(str, &eptr, 8);\n    else if (base == 0 && !bv)\n        d = Jsi_ValueToNumberInt(interp, v, 1);\n    else {\n        if (str == NULL || JSI_OK != Jsi_GetIntFromValue(interp, bv, &base) || base<2 || base>36)\n            return JSI_ERROR;\n        d = (Jsi_Number)strtoll(str, &eptr, base);\n    }\n    if (Jsi_NumberIsNaN(d) || (Jsi_NumberIsFinite(d)==0 && Jsi_GetDoubleFromValue(interp, v, &d) != JSI_OK))\nnanval:\n        Jsi_ValueDup2(interp, ret, interp->NaNValue);\n    else {\n        w = (Jsi_Wide)d;\n        Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)w);\n    }\n    return JSI_OK;\n}\n\nstatic Jsi_RC parseFloatCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Number n;\n    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_ValueToNumber(interp, v);\n    if (Jsi_GetDoubleFromValue(interp, v, &n) != JSI_OK)\n        Jsi_ValueDup2(interp, ret, interp->NaNValue);\n    else {\n        Jsi_ValueMakeNumber(interp, ret, n);\n    }\n    return JSI_OK;\n}\n\n// Return file path as a Jsi_Value, if it exists.\nJsi_Value * jsi_AccessFile(Jsi_Interp *interp, const char *name, int mode)\n{\n    //TODO: Optimize by not allocing Jsi_Value if access() fails and not in /zvfs with no other mounts.\n    if (0 && access(name, R_OK) <0) {\n        if (interp->mountCnt==0)\n            return NULL;\n        if (interp->selfZvfs && interp->mountCnt==1 && Jsi_Strncmp(name, JSI_ZVFS_DIR, Jsi_Strlen(JSI_ZVFS_DIR)))\n            return NULL;\n    }\n    Jsi_Value *fpath = Jsi_ValueNewStringDup(interp, name); \n    Jsi_IncrRefCount(interp, fpath);\n    if (Jsi_Access(interp, fpath, mode) >= 0)\n        return fpath;\n    Jsi_DecrRefCount(interp, fpath);\n    return NULL;\n}\n\nstatic jsi_PkgInfo* jsi_PkgGet(Jsi_Interp *interp, const char *name)\n{\n     return (jsi_PkgInfo*)Jsi_HashGet(interp->packageHash, name, 0);\n}\n\nJsi_Number Jsi_PkgVersion(Jsi_Interp *interp, const char *name, const char **filePtr)\n{\n    jsi_PkgInfo *ptr = jsi_PkgGet(interp, name);\n    if (ptr) {\n        if (filePtr)\n            *filePtr = ptr->loadFile;\n        return ptr->version;\n    }\n    return -1;\n}\n\n// Load one package. Note: Currently ver is ignored.\nstatic Jsi_RC jsi_PkgLoadOne(Jsi_Interp *interp, const char *name, const char *path, int len, Jsi_Value **fval, Jsi_Number ver)\n{\n    bool trace = interp->debugOpts.pkgTrace;\n    Jsi_RC rc = JSI_CONTINUE;\n    const char *fn;\n    const char *ext;\n    if (!path)\n        return JSI_CONTINUE;\n    if (len<0)\n        len = Jsi_Strlen(path);\n#ifdef __WIN32\n    ext = \".dll\";\n#else\n    ext = \".so\";\n#endif\n    Jsi_Value *fpath = NULL;\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    int i;\n    const char *sf = \"\";\n    if (trace)\n        sf = jsi_GetCurFile(interp);\n    for (i=0; i<4 && rc == JSI_CONTINUE; i++) {\n        const char *pref = (i%2 ? name : \"\"), *ps = (i%2 ? \"/\" : \"\");\n        if (i<2) {\n#ifdef JSI_OMIT_LOAD\n        continue;\n#endif\n            Jsi_DSSetLength(&dStr, 0);\n            Jsi_DSAppendLen(&dStr, path, len);\n            Jsi_DSAppend(&dStr, \"/\", pref, ps, name, ext, NULL);\n            fn = Jsi_DSValue(&dStr);\n            if ((fpath = jsi_AccessFile(interp, fn, R_OK))) {\n                if (trace)\n                    Jsi_Printf(interp, jsi_Stderr,\"Package-Trace: load('%s') from %s\\n\", fn, sf);\n                rc = Jsi_LoadLibrary(interp, fn, 0);\n            }\n        } else {\n            Jsi_DSSetLength(&dStr, 0);\n            Jsi_DSAppendLen(&dStr, path, len);\n            Jsi_DSAppend(&dStr, \"/\", pref, ps, name, \".jsi\", NULL);\n            fn = Jsi_DSValue(&dStr);\n            if ((fpath = jsi_AccessFile(interp, fn, R_OK))) {\n                if (trace)\n                    Jsi_Printf(interp, jsi_Stderr, \"Package-Trace: source('%s') from %s\\n\", fn, sf);\n                int oisi = interp->isMain;\n                interp->isMain = 0;\n                rc = Jsi_EvalFile(interp, fpath, JSI_EVAL_GLOBAL);\n                interp->isMain = oisi;\n            }\n        }\n    }\n    int needErr = 1;\n    if (rc == JSI_OK) {\n        ver = Jsi_PkgVersion(interp, name, NULL);\n        if (ver < 0) {\n            rc = Jsi_LogError(\"package missing provide('%s') in file: %s\", name, Jsi_DSValue(&dStr));\n            needErr = 0;\n        }\n    }\n    if (rc == JSI_OK) {\n        *fval = fpath;\n    }\n    else if (fpath)\n        Jsi_DecrRefCount(interp, fpath);\n    if (rc == JSI_ERROR && needErr)\n        Jsi_LogError(\"within require('%s') in file: %s\", name, Jsi_DSValue(&dStr));\n    Jsi_DSFree(&dStr);\n    return rc;\n}\n\n// Load package from pkgDirs or executable path.  Note. ver currently unused.\nstatic Jsi_RC jsi_PkgLoad(Jsi_Interp *interp, const char *name, Jsi_Number ver) {\n    Jsi_RC rc;\n    const char *cp = NULL, *path;\n    int len;\n    uint i = 0;\n    Jsi_Value *fval = NULL;\n    Jsi_Value *pval = interp->pkgDirs;\n    if (pval) {\n        Jsi_Obj* obj = pval->d.obj;\n        bool isJsish = !Jsi_Strcmp(name, \"Jsish\");\n        for (; i<obj->arrCnt; i++) {\n            const char *pnam = Jsi_ValueString(interp, obj->arr[i], NULL);\n            if (isJsish && interp->selfZvfs && Jsi_Strncmp(pnam, JSI_ZVFS_DIR, sizeof(JSI_ZVFS_DIR)-1))\n                continue;\n            rc = jsi_PkgLoadOne(interp, name, pnam, -1, &fval, ver);\n            if (rc != JSI_CONTINUE)\n                goto done;\n        }\n    }\n    // Check executable dir.\n    path = jsiIntData.execName;\n    if (path)\n        cp = Jsi_Strrchr(path, '/');\n    if (cp) {\n        len = cp-path;\n        rc = jsi_PkgLoadOne(interp, name, path, len, &fval, ver);\n        if (rc != JSI_CONTINUE)\n            goto done;\n    }\n    // Check script dir.\n    if ((path = interp->framePtr->fileName) || (interp->argv0 && (path = Jsi_ValueString(interp, interp->argv0, NULL)))) {\n        if ((cp = Jsi_Strrchr(path, '/'))) {\n            len = (cp-path);\n            rc = jsi_PkgLoadOne(interp, name, path, len, &fval, ver);\n            if (rc != JSI_CONTINUE)\n                goto done;\n        }\n    } else if (interp->curDir) { // Interactive mode \n        rc = jsi_PkgLoadOne(interp, name, interp->curDir, Jsi_Strlen(interp->curDir), &fval, ver);\n        if (rc != JSI_CONTINUE)\n            goto done;\n    }\n    return JSI_ERROR;\n    \ndone:\n    if (rc == JSI_CONTINUE)\n        rc = JSI_ERROR;\n    if (rc == JSI_OK) {\n        Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->packageHash, name);\n        if (!hPtr)\n            rc = JSI_ERROR;\n        else {\n            jsi_PkgInfo *ptr, *ptr2;\n            Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->packageHash, name);\n            if (hPtr) {\n                ptr = (jsi_PkgInfo*)Jsi_HashValueGet(hPtr);\n                if (ptr)\n                    if (fval) {\n                        char *fval2 = Jsi_Realpath(interp, fval, NULL);\n                        ptr->loadFile = Jsi_KeyAdd(interp, fval2);\n                        if (interp->parent && ptr->initProc) {\n                            if (interp->debugOpts.pkgTrace)\n                                Jsi_Printf(interp, jsi_Stderr , \"Package-Trace: load from topLevel: %s\\n\", name);\n                            ptr2 = jsi_PkgGet(interp->topInterp, name);\n                            if (ptr2)\n                                ptr2->loadFile = Jsi_KeyAdd(interp->topInterp, ptr->loadFile);\n                        }\n                        Jsi_DecrRefCount(interp, fval);\n                        free(fval2);\n                    }\n            }\n        }\n    }\n    if (rc != JSI_OK && fval)\n        Jsi_DecrRefCount(interp, fval);\n    return rc;\n}\n\nJsi_Number Jsi_PkgRequireEx(Jsi_Interp *interp, const char *name, Jsi_Number version, Jsi_PkgOpts **poptsPtr)\n{\n    jsi_PkgInfo *ptr = jsi_PkgGet(interp, name), *ptr2 = NULL;\n    if (ptr) {\n        if (version)\n            ptr->lastReq = version;\n        if (ptr->initProc && ptr->needInit) {\n            if ((*ptr->initProc)(interp, 0) != JSI_OK) \n                return -1;\n            ptr->needInit = 0;\n        }\n            if (poptsPtr)\n                *poptsPtr = &ptr->popts;\n        return ptr->version;\n    } else if ((ptr2 = jsi_PkgGet(interp->topInterp, name)) && ptr2->initProc) {\n        // C-extensions load from topInterp\n        if (interp->debugOpts.pkgTrace)\n            Jsi_Printf(interp, jsi_Stderr , \"Package-Trace: load from topLevel: %s\\n\", name);\n        ptr = (jsi_PkgInfo*)Jsi_Calloc(1, sizeof(*ptr));\n        *ptr = *ptr2;\n        if (ptr->loadFile)\n            ptr->loadFile = Jsi_KeyAdd(interp->topInterp, ptr->loadFile);\n        ptr->needInit = 1;\n        Jsi_HashSet(interp->packageHash, name, ptr);\n        if ((*ptr2->initProc)(interp, 0) == JSI_OK && (ptr = jsi_PkgGet(interp, name))) {\n            ptr->needInit = 0;\n            return ptr->version;\n            if (poptsPtr)\n                *poptsPtr = &ptr->popts;\n        }\n    }\n    if (interp->pkgReqDepth>interp->maxIncDepth) {\n        Jsi_LogError(\"recursive require('%s')\", name);\n        return -1;\n    }\n    \n    interp->pkgReqDepth++;\n    version = jsi_VersionNormalize(version, NULL, 0);\n    if (jsi_PkgLoad(interp, name, version) != JSI_OK) {\n        Jsi_LogError(\"failed require('%s')\", name);\n        interp->pkgReqDepth--;\n        return -1;\n    }\n    interp->pkgReqDepth--;\n    ptr = jsi_PkgGet(interp, name);\n    if (!ptr) {\n        Jsi_LogError(\"package not found for require('%s')\", name);\n        return -1;\n    }\n    if (poptsPtr)\n        *poptsPtr = &ptr->popts;\n    return ptr->version;\n}\n\nJsi_RC jsi_GetVerFromVal(Jsi_Interp *interp, Jsi_Value *val, Jsi_Number *nPtr, bool isProvide)\n{\n    Jsi_Number n = *nPtr;\n    if (!val)\n        return Jsi_LogError(\"missing version\");\n    if (Jsi_ValueIsNumber(interp, val)) {\n        if (Jsi_GetDoubleFromValue(interp, val, &n) != JSI_OK || Jsi_NumberIsNaN(n) || (isProvide?n<=0.0:n<0.0) || n>=100.0)\n            return Jsi_LogError(\"bad version: %.\" JSI_VERFMT_LEN JSI_NUMGFMT, n);\n        *nPtr = n;\n        return JSI_OK;\n    }\n    const char *vstr = Jsi_ValueString(interp, val, NULL), *vs = vstr;\n    if (!vstr)\n        return Jsi_LogError(\"bad version\");\n    uint v[3] = {};\n    while (*vs && (isdigit(*vs) || *vs=='.')) vs++;\n    if (*vs || sscanf(vstr, \"%u.%u.%u\", v, v+1, v+2) < 1 || v[0]>=100 || v[1]>=100 || v[2]>=100)\n        return Jsi_LogError(\"bad version string: %s\", vstr);\n    *nPtr = jsi_VersionNormalize((Jsi_Number)v[0] + ((Jsi_Number)v[1]/100.0) + ((Jsi_Number)v[2]/10000.0), NULL, 0);\n    return JSI_OK;\n}\n\nJsi_Number jsi_VersionNormalize(Jsi_Number ver, char *obuf, size_t osiz)\n{\n    ver = ((Jsi_Number)((uint)(0.5+ver*10000.0)))/10000.0;\n    if (obuf) {\n        uint n = (uint)(0.5+10000.0*ver);\n        uint v[3] = {n/10000};\n        n -= v[0]*10000; v[1] = n/100;\n        n -= v[1]*100; v[2] = n;\n        snprintf(obuf, osiz, \"%u.%u.%u\", v[0], v[1], v[2]);\n    }\n    return ver;\n}\n   \nstatic Jsi_OptionSpec jsiModuleOptions[] = {\n    JSI_OPT(BOOL,  Jsi_ModuleConf, Debug,   .help=\"Enable LogDebug messages for module\" ),\n    JSI_OPT(BOOL,  Jsi_ModuleConf, Test,    .help=\"Enable LogTest messages for module\" ),\n    JSI_OPT(BOOL,  Jsi_ModuleConf, Trace,   .help=\"Enable LogTrace messages for module\" ),\n    JSI_OPT(BOOL,  Jsi_ModuleConf, coverage,.help=\"On exit generate detailed code coverage for function calls (with profile)\" ),\n    JSI_OPT(BOOL,  Jsi_ModuleConf, profile, .help=\"On exit generate profile of function calls\" ),\n    JSI_OPT(CUSTOM,Jsi_ModuleConf, traceCall,.help=\"Trace commands\", .flags=0,  .custom=Jsi_Opt_SwitchBitset,  .data=jsi_callTraceStrs),\n    JSI_OPT_END(Jsi_ModuleConf, .help=\"Options for require command\")\n};\n\nJsi_RC jsi_PkgDumpInfo(Jsi_Interp *interp, const char *name, Jsi_Value **ret) {\n    jsi_PkgInfo *ptr;\n    Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->packageHash, name);\n    if (hPtr && ((ptr = (jsi_PkgInfo*)Jsi_HashValueGet(hPtr)))) {\n        Jsi_Obj *nobj = Jsi_ObjNew(interp);\n        Jsi_ValueMakeObject(interp, ret, nobj);\n        Jsi_ObjInsert(interp, nobj, \"name\", Jsi_ValueNewStringDup(interp, name), 0);\n        Jsi_ObjInsert(interp, nobj, \"version\", Jsi_ValueNewNumber(interp, ptr->version), 0);\n        Jsi_ObjInsert(interp, nobj, \"lastReq\", Jsi_ValueNewNumber(interp, ptr->lastReq), 0);\n        char buf[200];\n        jsi_VersionNormalize(ptr->version, buf, sizeof(buf));\n        Jsi_ObjInsert(interp, nobj, \"verStr\", Jsi_ValueNewStringDup(interp, buf), 0);\n        const char *cp = (ptr->loadFile?ptr->loadFile:\"\");\n        Jsi_ObjInsert(interp, nobj, \"loadFile\", Jsi_ValueNewStringDup(interp, cp), 0);\n        Jsi_Value *fval2, *fval = Jsi_NameLookup(interp, name);\n        if (!fval || !Jsi_ValueIsFunction(interp, fval))\n            fval = Jsi_ValueNewNull(interp);\n        Jsi_ObjInsert(interp, nobj, \"func\", fval, 0);\n        fval = ptr->popts.info;\n        if (!fval) fval = interp->NullValue;\n        if (!Jsi_ValueIsObjType(interp, fval, JSI_OT_FUNCTION))\n            Jsi_ObjInsert(interp, nobj, \"info\", fval, 0);\n        else {\n            fval2 = Jsi_ValueNew1(interp);\n            Jsi_RC rc = Jsi_FunctionInvoke(interp, fval, NULL, &fval2, NULL);\n            if (rc != JSI_OK)\n                Jsi_LogWarn(\"status call failed\");\n            Jsi_ObjInsert(interp, nobj, \"info\", fval2, 0);\n            Jsi_DecrRefCount(interp, fval2);\n        }\n        fval = interp->NullValue;\n        if (ptr->popts.spec && ptr->popts.data) {\n            fval = Jsi_ValueNew1(interp);\n            Jsi_OptionsConf(interp, ptr->popts.spec, ptr->popts.data, NULL, &fval, 0);\n        }\n        Jsi_ObjInsert(interp, nobj, \"status\", fval, 0);\n        if (fval != interp->NullValue)\n            Jsi_DecrRefCount(interp, fval);\n\n        fval = Jsi_ValueNew1(interp);\n        Jsi_OptionsConf(interp, jsiModuleOptions, &ptr->popts.modConf, NULL, &fval, 0);\n        Jsi_ObjInsert(interp, nobj, \"moduleOpts\", fval, 0);\n        Jsi_DecrRefCount(interp, fval);\n\n        return JSI_OK;\n    }\n    return JSI_ERROR;\n}\n\nstatic Jsi_RC InfoPackageCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    const char *name = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    if (!name || jsi_PkgDumpInfo(interp, name, ret) != JSI_OK)\n        Jsi_ValueMakeNull(interp, ret);\n    return JSI_OK;\n}\n\n#define FN_require JSI_INFO(\"\\\nWith no arguments, returns the list of all loaded packages.\\n\\\nWith one argument, loads the package (if necessary) and returns its version.\\n\\\nWith two arguments, returns object containing: version, loadFile, func.\\n\\\nA third argument sets options for package or module.\\n\\\nNote an error is thrown if requested version is greater than actual version.\")\nstatic Jsi_RC SysRequireCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Number n = 0;\n    int argc = Jsi_ValueGetLength(interp, args);\n    if (argc == 0)\n        return Jsi_HashKeysDump(interp, interp->packageHash, ret, 0);\n        \n    Jsi_Value *vname = Jsi_ValueArrayIndex(interp, args, 0);\n    const char *name = NULL;\n    if (Jsi_ValueIsString(interp, vname)) {\n        name = Jsi_ValueString(interp, vname, NULL);\n        if (!Jsi_StrIsAlnum(name))\n            name = NULL;\n    }\n    if (!name) \n        return Jsi_LogError(\"invalid or missing package name\");\n    if (argc>1) {\n        Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 1);\n        if (jsi_GetVerFromVal(interp, v, &n, 0) != JSI_OK)\n            return JSI_ERROR;\n        n = jsi_VersionNormalize(n, NULL, 0);\n    }\n    int isMain = interp->isMain;\n    interp->isMain = 0;\n    Jsi_Number ver = Jsi_PkgRequireEx(interp, name, n, NULL);\n    interp->isMain = isMain;\n    if (ver < 0)\n        return JSI_ERROR;\n    Jsi_RC rc = JSI_OK;\n    if (argc==2) {\n        if (ver < n) \n            rc = Jsi_LogType(\"package '%s' downlevel: %.\" JSI_NUMGFMT \" < %.\" JSI_VERFMT_LEN JSI_NUMGFMT, name, ver, n);\n        if (rc != JSI_OK)\n            return rc;\n        return jsi_PkgDumpInfo(interp, name, ret);\n    }\n    Jsi_Value *opts = Jsi_ValueArrayIndex(interp, args, 2);\n       \n    if (opts != NULL) {\n        jsi_PkgInfo *pkg = jsi_PkgGet(interp, name);\n        if (!pkg) return JSI_ERROR;\n        Jsi_ModuleConf *mptr = &pkg->popts.modConf;\n        if (Jsi_OptionsProcess(interp, jsiModuleOptions, mptr, opts, 0) < 0)\n            return JSI_ERROR;\n        if (pkg->popts.cmdSpec) {\n            int *fl = &pkg->popts.cmdSpec->flags;\n            if (mptr->Test) *fl |= JSI_CMD_LOG_TEST; else *fl &=  ~JSI_CMD_LOG_TEST;\n            if (mptr->Debug) *fl |= JSI_CMD_LOG_DEBUG; else *fl &=  ~JSI_CMD_LOG_DEBUG;\n            if (mptr->Trace) *fl |= JSI_CMD_LOG_TRACE; else *fl &=  ~JSI_CMD_LOG_TRACE;\n        }\n    }\n\n    Jsi_ValueMakeNumber(interp, ret, ver);\n    return rc;\n}\n\nJsi_RC Jsi_PkgProvideEx(Jsi_Interp *interp, const char *name, Jsi_Number version, \n    Jsi_InitProc *initProc, Jsi_PkgOpts* popts)\n{\n    jsi_PkgInfo *ptr;\n    Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->packageHash, name);\n    Jsi_Value *opts = (popts?popts->info:NULL);\n    if (version<0) {\n        if (hPtr) {\n            ptr = (jsi_PkgInfo*)Jsi_HashValueGet(hPtr);\n            Jsi_HashEntryDelete(hPtr);\n        }\n        return JSI_OK;\n    }\n    version = jsi_VersionNormalize(version, NULL, 0);\n    if (version == 0) \n        return Jsi_LogError(\"Version must be > 0\");\n    else {\n        if (hPtr) {\n            ptr = (jsi_PkgInfo*)Jsi_HashValueGet(hPtr);\n            if (ptr && ptr->needInit==0) \n                return Jsi_LogError(\"package %s already provided from: %s\", name, ptr->loadFile?ptr->loadFile:\"\");\n            return JSI_OK;\n        }\n        if (!Jsi_StrIsAlnum(name)) \n            return Jsi_LogError(\"invalid package name\");\n        if (opts && !Jsi_ValueIsObjType(interp, opts, JSI_OT_OBJECT) && !Jsi_ValueIsObjType(interp, opts, JSI_OT_FUNCTION))\n            return Jsi_LogError(\"opts must be function or object\");\n        ptr = (jsi_PkgInfo*)Jsi_Calloc(1, sizeof(*ptr));\n        ptr->version = version;\n        ptr->initProc = initProc;\n        if (popts) {\n            ptr->popts = *popts;\n            if (popts->info)\n                Jsi_IncrRefCount(interp, popts->info);\n        }\n        if (interp->framePtr->fileName && !initProc)\n            ptr->loadFile = Jsi_KeyAdd(interp->topInterp, interp->framePtr->fileName);\n        Jsi_HashSet(interp->packageHash, (void*)name, ptr);\n        if (initProc && interp->parent) { // Provide C extensions to topInterp.\n            ptr = jsi_PkgGet(interp->topInterp, name);\n            if (ptr == NULL) {\n                Jsi_PkgOpts po = {};\n                Jsi_Value *nopts = NULL;\n                if (opts) {\n                    nopts = Jsi_ValueNew(interp);\n                    Jsi_CleanValue(interp, interp->topInterp, po.info, &nopts);\n                    po.info = nopts;\n                }\n                Jsi_RC rc = Jsi_PkgProvideEx(interp->topInterp, name, version, initProc, &po);\n                if (rc != JSI_OK)\n                    return JSI_ERROR;\n                ptr = jsi_PkgGet(interp->topInterp, name);\n                if (!ptr)\n                    return JSI_ERROR;\n                ptr->needInit = 1;\n            }\n        }\n\n    }\n    return JSI_OK;\n}\n        \nstatic Jsi_RC SysProvideCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Number n = 1;\n    const char *name = NULL, *cp;\n    Jsi_Value *vname = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_RC rc = JSI_OK;\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    Jsi_Func *f = NULL;\n    if (!vname) {\n        name = jsi_GetCurFile(interp);\n        if (!name)\n            return JSI_ERROR;\n        if ((cp = strrchr(name, '/')))\n            name = cp+1;\n        if ((cp = strrchr(name, '.')))\n            Jsi_DSAppendLen(&dStr, name, (cp-name));\n        else\n            Jsi_DSAppend(&dStr, name, NULL);\n        name = Jsi_DSValue(&dStr);\n    } else if (Jsi_ValueIsString(interp, vname)) {\n        name = Jsi_ValueString(interp, vname, NULL);\n        if (!Jsi_StrIsAlnum(name))\n            name = NULL;\n    } else if (Jsi_ValueIsFunction(interp, vname)) {\n        f = vname->d.obj->d.fobj->func;\n        name = f->name;\n    }\n    if (!name) \n        rc = Jsi_LogError(\"invalid or missing package name\");\n    else {\n        Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 1);\n        if (v && jsi_GetVerFromVal(interp, v, &n, 1) != JSI_OK)\n            return JSI_ERROR;\n        if (rc == JSI_OK) {\n            Jsi_PkgOpts po = {};\n            po.info = Jsi_ValueArrayIndex(interp, args, 2);\n            rc = Jsi_PkgProvideEx(interp, name, n, NULL, &po);\n        }\n    }\n    Jsi_DSFree(&dStr);\n    if (rc == JSI_OK && f)\n        f->pkg = jsi_PkgGet(interp, name);\n    return rc;\n}\n\nJsi_RC jsi_NoOpCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    return JSI_OK;\n}\n\nstatic Jsi_RC isNaNCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Number n;\n    int rc = 0;\n    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n    if (Jsi_ValueIsBoolean(interp, v))\n        rc = 0;\n    else if (!Jsi_ValueIsNumber(interp, v) || Jsi_GetDoubleFromValue(interp, v, &n) != JSI_OK || Jsi_NumberIsNaN(n))\n        rc = 1;\n    Jsi_ValueMakeBool(interp, ret, rc);\n    return JSI_OK;\n}\nstatic Jsi_RC isFiniteCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Number n;\n    int rc = 1;\n    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n    if (!Jsi_ValueIsNumber(interp, v) || Jsi_GetDoubleFromValue(interp, v, &n) != JSI_OK || !Jsi_NumberIsFinite(n))\n        rc = 0;\n    Jsi_ValueMakeBool(interp, ret, rc);\n    return JSI_OK;\n}\n\n/* Returns a url-encoded version of str */\n/* IMPORTANT: be sure to free() the returned string after use */\nstatic char *url_encode(char *str) {\n  char *pstr = str, *buf = (char*)Jsi_Malloc(Jsi_Strlen(str) * 3 + 1), *pbuf = buf;\n  while (*pstr) {\n    if (isalnum(*pstr) || *pstr == '-' || *pstr == '_' || *pstr == '.' || *pstr == '~') \n      *pbuf++ = *pstr;\n    else if (*pstr == ' ') \n      *pbuf++ = '+';\n    else \n      *pbuf++ = '%', *pbuf++ = jsi_toHexChar(*pstr >> 4), *pbuf++ = jsi_toHexChar(*pstr & 15);\n    pstr++;\n  }\n  *pbuf = '\\0';\n  return buf;\n}\n\n/* Returns a url-decoded version of str */\n/* IMPORTANT: be sure to free() the returned string after use */\nstatic char *url_decode(char *str, int *len) {\n  char *pstr = str, *buf = (char*)Jsi_Malloc(Jsi_Strlen(str) + 1), *pbuf = buf;\n  while (*pstr) {\n    if (*pstr == '%') {\n      if (pstr[1] && pstr[2]) {\n        *pbuf++ = jsi_fromHexChar(pstr[1]) << 4 | jsi_fromHexChar(pstr[2]);\n        pstr += 2;\n      }\n    } else if (*pstr == '+') { \n      *pbuf++ = ' ';\n    } else {\n      *pbuf++ = *pstr;\n    }\n    pstr++;\n  }\n  *pbuf = '\\0';\n  *len = (pbuf-buf);\n  return buf;\n}\n\nstatic Jsi_RC EncodeURICmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char *cp, *str = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    cp = url_encode(str);\n    Jsi_ValueMakeString(interp, ret, cp);\n    return JSI_OK;\n}\n\nstatic Jsi_RC DecodeURICmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char *cp, *str = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    int len;\n    cp = url_decode(str, &len);\n    Jsi_ValueMakeBlob(interp, ret, (uchar*)cp, len);\n    return JSI_OK;\n}\n\nstatic Jsi_RC SysSleepCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Number dtim = 1;\n    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n    if (v) {\n        if (Jsi_GetDoubleFromValue(interp, v, &dtim) != JSI_OK) {\n            return JSI_ERROR;\n        }\n    }\n    return Jsi_Sleep(interp, dtim);\n}\n\n\nstatic Jsi_RC SysGetEnvCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    extern char **environ;\n    char *cp;\n    int i;\n    if (interp->isSafe)\n        return Jsi_LogError(\"no getenv in safe mode\");\n    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n    if (v != NULL) {\n        const char *fnam = Jsi_ValueString(interp, v, NULL);\n        if (!fnam) \n            return Jsi_LogError(\"arg1: expected string 'name'\");\n        cp = getenv(fnam);\n        if (cp != NULL) {\n            Jsi_ValueMakeStringDup(interp, ret, cp);\n        }\n        return JSI_OK;\n    }\n   /* Single object containing result members. */\n    Jsi_Value *vres;\n    Jsi_Obj  *ores = Jsi_ObjNew(interp);\n    Jsi_Value *nnv;\n    char *val, nam[200];\n    //Jsi_ObjIncrRefCount(interp, ores);\n    vres = Jsi_ValueMakeObject(interp, NULL, ores);\n    //Jsi_IncrRefCount(interp, vres);\n    \n    for (i=0; ; i++) {\n        int n;\n        cp = environ[i];\n        if (cp == 0 || ((val = Jsi_Strchr(cp, '='))==NULL))\n            break;\n        n = val-cp+1;\n        if (n>=(int)sizeof(nam))\n            n = sizeof(nam)-1;\n        Jsi_Strncpy(nam, cp, n);\n        val = val+1;\n        nnv = Jsi_ValueMakeStringDup(interp, NULL, val);\n        Jsi_ObjInsert(interp, ores, nam, nnv, 0);\n    }\n    Jsi_ValueReplace(interp, ret, vres);\n    return JSI_OK;\n}\n\nstatic Jsi_RC SysSetEnvCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                        Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n    const char *fnam = Jsi_ValueString(interp, v, NULL);\n    Jsi_Value *vv = Jsi_ValueArrayIndex(interp, args, 1);\n    const char *cp = NULL, *fval = (vv?Jsi_ValueString(interp, vv, NULL):NULL);\n    int rc = -1;\n    if (fnam == 0) \n        return Jsi_LogError(\"arg1: expected string 'name'\");\n    if (interp->isSafe)\n        return Jsi_LogError(\"no setenv in safe mode\");\n\n    if (fnam[0] != 0) {\n#ifndef __WIN32\n        if (fval)\n            rc = setenv(fnam, fval, 1);\n        else\n            cp = getenv(fnam);\n#else  /* TODO: win setenv */\n        if (!fval)\n            cp = getenv(fnam);\n        else {\n            char ebuf[JSI_BUFSIZ];\n            snprintf(ebuf, sizeof(ebuf), \"%s=%s\", fnam, fval);\n            rc = _putenv(ebuf);\n        }\n#endif\n    }\n    if (rc != 0) \n        return Jsi_LogError(\"setenv failure: %s = %s\", fnam, fval);\n    if (cp)\n        Jsi_ValueMakeStringDup(interp, ret, cp);\n    return JSI_OK;\n}\n\nstatic Jsi_RC SysGetPidCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                        Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n#ifdef __WIN32\n    return Jsi_LogError(\"unsupported\");\n#else\n    Jsi_Number pid = 0;\n    bool bv = 0;\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);\n    if (arg && Jsi_GetBoolFromValue(interp, arg, &bv) != JSI_OK)\n        return JSI_ERROR;\n    if (bv)\n        pid = (Jsi_Number)getppid();\n    else\n        pid = (Jsi_Number)getpid();\n    Jsi_ValueMakeNumber(interp, ret, pid);\n    return JSI_OK;\n#endif\n}\n\nstatic Jsi_RC SysGetUserCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                        Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[JSI_BUFSIZ];\n    const char* name, *cname;\n#ifdef __WIN32\n    cname = name = getenv(\"USERNAME\");\n#else\n    char tbuf[L_cuserid] = {}, cbuf[L_cuserid] = {};\n    cname = cuserid(cbuf);\n    getlogin_r(tbuf, sizeof(tbuf));\n    name = tbuf;\n#endif\n    if (!cname) cname = \"\";\n    if (!name || !name[0]) name = cname;\n    snprintf(buf, sizeof(buf),\n        \"{uid:%d, gid:%d, uid:%d, guid:%d, pid:%d, pidp:%d, user:\\\"%s\\\", cuserid:\\\"%s\\\"}\",\n#ifdef __WIN32\n        0, 0, 0, 0, 0, 0, name, name);\n#else\n        (int)getuid(), (int)getgid(), (int)geteuid(), getpid(), getppid(), (int)getegid(), name, cname);\n#endif\n    return Jsi_JSONParse(interp, buf, ret, 0);\n}\n\n// Replacement for popen when there is no /bin/sh.  It uses execvp.\nstatic FILE *jsi_popen(char **cmdv, const char *type, int *cpid)\n{\n#ifdef __WIN32\n    return NULL;\n#else\n    int fd[2], pid, find = (*type != 'w' ? 1 : 0);\n    if (!cmdv[0] || pipe(fd)<0)\n        return NULL;\n    pid = fork();\n    if (pid<0) {\n        close(fd[0]);\n        close(fd[1]);\n        return NULL;\n    }\n\n    if (pid) {\n        *cpid = pid;\n        close(fd[find]);\n        return fdopen(fd[1-find], type);\n    }\n    if (fd[find] != find) {\n        dup2(fd[find], find);\n        close(fd[find]);\n    }\n    close(fd[1-find]);\n    execvp(cmdv[0], cmdv);\n    //execlp(\"sh\", \"sh\", \"-c\", cmd, NULL);\n    _exit(127);\n#endif\n}\n\nstatic int jsi_pclose(FILE *fp, int cpid)\n{\n#ifdef __WIN32\n    return -1;\n#else\n    pid_t pid;\n    int pstat;\n    fclose(fp);\n    do {\n        pid = waitpid(cpid, &pstat, 0);\n    } while (pid == -1 && errno == EINTR);\n    return (pid == -1 ? -1 : pstat);\n#endif\n}\n\n\ntypedef struct {\n    Jsi_Value* inputStr;\n    Jsi_Value* chdir;\n    bool bg;\n    bool noError;\n    bool trim;\n    bool retCode;\n    bool retAll;\n    bool retval;\n    bool noRedir;\n    bool noShell;\n} ExecOpts;\n\nstatic Jsi_OptionSpec ExecOptions[] = {\n    JSI_OPT(BOOL,   ExecOpts, bg,       .help=\"Run command in background using system() and return OS code\" ),\n    JSI_OPT(STRING, ExecOpts, chdir,    .help=\"Change to directory\" ),\n    JSI_OPT(STRING, ExecOpts, inputStr, .help=\"Use string as input and return OS code\" ),\n    JSI_OPT(BOOL,   ExecOpts, noError,  .help=\"Suppress all OS errors\" ),\n    JSI_OPT(BOOL,   ExecOpts, noRedir,  .help=\"Disable redirect and shell escapes in command\" ),\n    JSI_OPT(BOOL,   ExecOpts, noShell,  .help=\"Do not use native popen which invokes via /bin/sh\" ),\n    JSI_OPT(BOOL,   ExecOpts, trim,     .help=\"Trim trailing whitespace from output\" ),\n    JSI_OPT(BOOL,   ExecOpts, retAll,   .help=\"Return the OS return code and data as an object\" ),\n    JSI_OPT(BOOL,   ExecOpts, retCode,  .help=\"Return only the OS return code\" ),\n    JSI_OPT_END(ExecOpts, .help=\"Exec options\")\n};\n\n#define FN_exec JSI_INFO(\"\\\nIf the command ends with '&', set the 'bg' option to true.\\n\\\nThe second argument can be a string, which is the same as setting the 'inputStr' option.\\n\\\nBy default, returns the string output, unless the 'bg', 'inputStr', 'retCode' or 'retAll' options are used\")\nJsi_RC jsi_SysExecCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr, bool restricted)\n{\n    int n, exitCode = 0, hasopts = 0, sLen, sLen2 = 0;\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);\n    const char *cp2=NULL, *cp = Jsi_ValueString(interp, arg, &sLen);\n    FILE *fp = NULL;\n    if (restricted && Jsi_ValueGetLength(interp, args)>1)\n        return Jsi_LogError(\"restricted may not have args\");\n    if (interp->isSafe) {\n        int rc =0, no = 1;\n        if (restricted)\n            no = 0;\n        else if (interp->safeExecPattern && cp) {\n            Jsi_Value *seq = Jsi_ValueNew1(interp);\n            Jsi_RC rrc = jsi_RegExpValueNew(interp, interp->safeExecPattern, seq);\n            if (rrc == JSI_OK && Jsi_RegExpMatch(interp, seq, cp, &rc, NULL)!=JSI_OK)\n                rrc = JSI_ERROR;\n            Jsi_DecrRefCount(interp, seq);\n            if (rrc != JSI_OK)\n                return Jsi_LogError(\"invalid regex\");\n            if (rc)\n                no = 0;\n            restricted = 1;\n        }\n        if (no)\n            return Jsi_LogError(\"no exec in safe mode\");\n    }\n    Jsi_RC rc = JSI_OK;\n    Jsi_Value *opt = Jsi_ValueArrayIndex(interp, args, 1);\n    Jsi_DString dStr = {}, cStr = {};\n    ExecOpts edata = {};\n    edata.retval = 1;\n    \n    if (opt != NULL) {\n        if (opt->vt == JSI_VT_OBJECT && opt->d.obj->ot == JSI_OT_OBJECT) {\n            hasopts = 1;\n            if (Jsi_OptionsProcess(interp, ExecOptions, &edata, opt, 0) < 0) {\n                return JSI_ERROR;\n            }\n            if (edata.retCode)\n                edata.retval = 0;\n        } else if (Jsi_ValueString(interp, opt, NULL)) {\n            edata.inputStr = opt;\n        } else \n            return Jsi_LogError(\"arg 2: expected options or string 'input'?\");\n    }\n    if (restricted || edata.noRedir) {\n        // Sanity check command string to disallow shell escapes, redirection, etc.\n        if (strcspn(cp, \"<>|;&$`=\") != strlen(cp))\n            return Jsi_LogError(\"restricted chars in exec string: %s\", cp);\n    }\n    int isbg = 0, ec = 0;\n    const char *ocd = NULL, *cd = (edata.chdir ? Jsi_ValueString(interp, edata.chdir, NULL) : NULL);\n    if (cd && interp->isSafe) {\n        cd = NULL;\n        rc = Jsi_LogError(\"no chdir in safe mode\");\n        goto done;        \n    }\n    if (cd) {\n        ocd = Jsi_GetCwd(interp, &cStr);\n        if (!Jsi_FSNative(interp, edata.chdir) || Jsi_Chdir(interp, edata.chdir)<0) {\n            cd = NULL;\n            rc = Jsi_LogError(\"chdir failed\");\n            goto done;        \n        }\n    }\n    if (edata.bg || (isbg=((sLen>1 && cp[sLen-1] == '&')))) {\n        if (edata.inputStr) {\n            rc = Jsi_LogError(\"input string may not used with bg\");\n            goto done;\n        }\n        if (edata.noShell) {\n            rc = Jsi_LogError(\"noShell may not used with bg\");\n            goto done;\n        }\n        if (!isbg) {\n            Jsi_DSAppend(&dStr, cp, \" &\", NULL);\n            cp = Jsi_DSValue(&dStr);\n        }\n        edata.bg = 1;\n        edata.retCode = 1;\n        edata.retval = 0;\n        exitCode = ((ec=system(cp))>>8);\n        Jsi_DSSetLength(&dStr, 0);\n    } else {\n        const char *type = (edata.inputStr?\"w\":\"r\");\n        bool native = !edata.noShell;\n#ifdef __WIN32\n        native = 1;\n#else\n        if (native)\n            native = (access(\"/bin/sh\", X_OK)==0);\n#endif\n        int cpid;\n        if (native)\n            fp = popen(cp, type);\n        else {\n            int argc;\n            char **argv;\n            Jsi_DString pStr = {};\n            Jsi_SplitStr(cp, &argc, &argv, NULL, &pStr);\n            fp = jsi_popen(argv, type, &cpid);\n            Jsi_DSFree(&pStr);\n        }\n        if (!fp) \n            exitCode = errno;\n        else {\n            if (edata.inputStr) {\n                edata.retCode = 1;\n                edata.retval = 0;\n                cp2 = Jsi_ValueString(interp, edata.inputStr, &sLen2);\n                while ((n=fwrite(cp2, 1, sLen2, fp))>0) {\n                    sLen2 -= n;\n                }\n            } else {\n                char buf[JSI_BUFSIZ];;\n                while ((n=fread(buf, 1, sizeof(buf), fp))>0)\n                    Jsi_DSAppendLen(&dStr, buf, n);\n            }\n            if (native)\n                exitCode = ((ec=pclose(fp))>>8);\n            else\n                exitCode = ((ec=jsi_pclose(fp, cpid))>>8);\n        }\n    }\n    if (exitCode && edata.noError==0 && edata.retCode==0 && edata.retAll==0) {\n        if (exitCode==ENOENT)\n            Jsi_LogError(\"command not found: %s\", cp);\n        else\n            Jsi_LogError(\"program exit code (%x)\", exitCode);\n        rc = JSI_ERROR;\n    }\n    if (edata.trim) {\n        char *cp = Jsi_DSValue(&dStr);\n        int iLen = Jsi_DSLength(&dStr);\n        while (iLen>0 && isspace(cp[iLen-1]))\n            iLen--;\n        cp[iLen] = 0;\n        Jsi_DSSetLength(&dStr, iLen);\n    }\n    if (edata.retAll) {\n        Jsi_Obj *nobj = Jsi_ObjNew(interp);\n        Jsi_ValueMakeObject(interp, ret, nobj);\n        Jsi_Value *cval = Jsi_ValueNewNumber(interp, (Jsi_Number)exitCode);\n        Jsi_ObjInsert(interp, nobj, \"code\", cval, 0);\n        cval = Jsi_ValueNewNumber(interp, (Jsi_Number)(ec&0xff));\n        Jsi_ObjInsert(interp, nobj, \"status\", cval, 0);\n        cval = Jsi_ValueNew(interp);\n        Jsi_ValueFromDS(interp, &dStr, &cval);\n        Jsi_ObjInsert(interp, nobj, \"data\", cval, 0);\n        \n    } else if (edata.retval)\n        Jsi_ValueFromDS(interp, &dStr, ret);\n    else {\n        Jsi_DSFree(&dStr);\n        Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)exitCode);\n    }\ndone:\n    if (cd && ocd) {\n        Jsi_Value *oc = Jsi_ValueNewStringDup(interp, ocd);\n        Jsi_IncrRefCount(interp, oc);\n        Jsi_Chdir(interp, oc);\n        Jsi_DecrRefCount(interp, oc);\n    }\n    Jsi_DSFree(&cStr);\n    if (hasopts)\n        Jsi_OptionsFree(interp, ExecOptions, &edata, 0);\n    return rc;\n}\n\nstatic Jsi_RC SysExecCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    return jsi_SysExecCmd(interp, args, _this, ret, funcPtr, false);\n}\n\nvoid jsi_SysPutsCmdPrefix(Jsi_Interp *interp, jsi_LogOptions *popts,Jsi_DString *dStr, int* quote, const char **fnPtr) {\n    int didx = 0;\n    const char *cp;\n    const char *fn = interp->curIp->fname;\n    if (fn && !popts->full && (cp=Jsi_Strrchr(fn, '/')))\n        fn = cp +1;\n    if (popts->time || (didx=popts->date)) {\n        if (popts->time && popts->date)\n            didx = 2;\n        const char *fmts[3] = { \"%H:%M:%S.%f\", \"%F\", \"%F %H:%M:%S.%f\" },\n            *fmt = (popts->timeFmt?popts->timeFmt:fmts[didx]);\n        Jsi_DatetimeFormat(interp, Jsi_DateTime(), fmt, popts->isUTC, dStr);\n        Jsi_DSAppend(dStr, \", \", NULL);\n    }\n    if (popts->file && popts->before) {\n        Jsi_DSPrintf(dStr, \"%s:%d: \", fn, interp->curIp->Line);\n        if (interp->curIp->Line<1000)\n            Jsi_DSAppend(dStr, (interp->curIp->Line<10?\"  \":\" \"), NULL);\n    }\n    if (Jsi_DSLength(dStr)) {\n        *quote = 1;\n    }\n    if (*quote)\n        Jsi_DSAppendLen(dStr, \"\\\"\", 1);\n    if (fnPtr)\n        *fnPtr = fn;\n\n}\n\nstatic Jsi_RC SysPutsCmd_(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret,\n    Jsi_Func *funcPtr, bool stdErr, jsi_LogOptions *popts, const char *argStr, bool conLog)\n{\n    int i, cnt = 0, quote = (popts->file);\n    const char *fn = NULL;\n    Jsi_DString dStr, oStr;\n    if (interp->noStderr)\n        stdErr = 0;\n    Jsi_Chan *chan = (stdErr ? jsi_Stderr : jsi_Stdout);\n    Jsi_DSInit(&dStr);\n    Jsi_DSInit(&oStr);\n    if (popts->chan && !stdErr) {\n        Jsi_UserObj *uobj = popts->chan->d.obj->d.uobj;\n        jsi_UserObjToName(interp, uobj, &dStr);\n        Jsi_Channel nchan = Jsi_FSNameToChannel(interp, Jsi_DSValue(&dStr));\n        if (nchan)\n            chan = nchan;\n        Jsi_DSSetLength(&dStr, 0);\n    }\n    if (interp->curIp)\n        jsi_SysPutsCmdPrefix(interp, popts, &dStr, &quote, &fn);\n    if (!args)\n        Jsi_DSAppend(&dStr, argStr?argStr:\"\", NULL);\n    else {\n        int argc = Jsi_ValueGetLength(interp, args);\n        if (conLog && argc>0 && (argStr=Jsi_ValueString(interp, Jsi_ValueArrayIndex(interp, args, 0), NULL))) {\n            if ((!interp->logOpts.Error && jsi_PrefixMatch(argStr, \"ERROR: \")) \n                || (!interp->logOpts.Warn && jsi_PrefixMatch(argStr, \"WARN: \")) \n                || (!interp->logOpts.Info && jsi_PrefixMatch(argStr, \"INFO: \")))\n                goto done;\n        }\n \n        for (i = 0; i < argc; ++i) {\n            Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, i);\n            if (!v) continue;\n            int len = 0;\n            if (cnt++)\n                Jsi_DSAppendLen(&dStr, \" \", 1);\n            const char *cp = Jsi_ValueString(interp, v, &len);\n            if (cp) {\n                Jsi_DSAppendLen(&dStr, cp, len);\n                continue;\n            }\n            Jsi_DSSetLength(&oStr, 0);\n            Jsi_ValueGetDString(interp, v, &oStr, 1);\n            Jsi_DSAppend(&dStr, Jsi_DSValue(&oStr), NULL);\n        }\n    }\n    if (quote)\n        Jsi_DSAppendLen(&dStr, \"\\\"\", 1);\n    if (popts->file && !popts->before) {\n        Jsi_DSPrintf(&dStr, \", %s:%d\", fn?fn:\"\", interp->curIp->Line);\n    }\n    if (popts->func) {\n        // Note: could have looked this up on the stackFrame.\n        if (!interp->prevActiveFunc || !((fn=interp->prevActiveFunc->name)))\n            fn = \"\";\n        Jsi_DSPrintf(&dStr, \", %s%s\", fn[0]?fn:\"\", fn[0]?\"()\":\"\");\n    }\n    Jsi_DSAppend(&dStr, \"\\n\", NULL);\n    Jsi_Puts(interp, chan, Jsi_DSValue(&dStr), Jsi_DSLength(&dStr));\ndone:\n    Jsi_DSFree(&dStr);\n    Jsi_DSFree(&oStr);\n    return JSI_OK;\n}\n\nstatic Jsi_RC SysPrintfCmd_(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret,\n    Jsi_Func *funcPtr, Jsi_Channel chan)\n{\n    Jsi_DString dStr;\n    Jsi_RC rc = Jsi_FormatString(interp, args, &dStr);\n    if (rc != JSI_OK)\n        return rc;\n    const char *cp;\n    int len = Jsi_DSLength(&dStr);\n    Jsi_Puts(interp, chan, cp = Jsi_DSValue(&dStr), len);\n    if (len>0 && cp[len-1]!='\\n')\n        Jsi_Flush(interp, chan);\n    Jsi_DSFree(&dStr);\n    return rc;\n}\n\nstatic Jsi_RC SysPrintfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret,\n    Jsi_Func *funcPtr)\n{\n    return SysPrintfCmd_(interp, args, _this, ret, funcPtr, jsi_Stdout);\n}\n\nstatic Jsi_RC consolePrintfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret,\n    Jsi_Func *funcPtr)\n{\n    return SysPrintfCmd_(interp, args, _this, ret, funcPtr, jsi_Stderr);\n}\n\nstatic Jsi_RC consoleLogCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret,\n    Jsi_Func *funcPtr)\n{\n    int conLog = ((!interp->logOpts.Error) || (!interp->logOpts.Warn) || (!interp->logOpts.Info));\n    return SysPutsCmd_(interp, args, _this, ret, funcPtr, 1, &interp->logOpts, NULL, conLog);\n}\n\nstatic Jsi_RC consolePutsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret,\n    Jsi_Func *funcPtr)\n{\n    jsi_LogOptions lo = {};\n    return SysPutsCmd_(interp, args, _this, ret, funcPtr, 1, (interp->tracePuts?&interp->logOpts:&lo), NULL, 0);\n}\n\n#define FN_puts JSI_INFO(\"\\\nEach argument is quoted.  Use Interp.logOpts to control source line and/or timestamps output.\")\nstatic Jsi_RC SysPutsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret,\n    Jsi_Func *funcPtr)\n{\n    jsi_LogOptions lo = {};\n    return SysPutsCmd_(interp, args, _this, ret, funcPtr, 0, (interp->tracePuts?&interp->logOpts:&lo), NULL, 0);\n}\n\nstatic Jsi_RC SysLogCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret,\n    Jsi_Func *funcPtr)\n{\n    return SysPutsCmd_(interp, args, _this, ret, funcPtr, 0, &interp->logOpts, NULL, 0);\n}\n\ntypedef struct {\n    jsi_AssertMode mode;\n    bool noStderr;\n} AssertData;\n\nstatic Jsi_OptionSpec AssertOptions[] = {\n    JSI_OPT(CUSTOM, AssertData, mode,     .help=\"Action when assertion fails. Default from Interp.assertMode\", .flags=0, .custom=Jsi_Opt_SwitchEnum, .data=jsi_AssertModeStrs ),\n    JSI_OPT(BOOL,   AssertData, noStderr, .help=\"Logged msg to stdout. Default from Interp.noStderr\" ),\n    JSI_OPT_END(AssertData, .help=\"Options for assert command\")\n};\n\nstatic char *jsi_GetCurPSLine(Jsi_Interp *interp) {\n    char *cp = NULL;\n    int line = interp->curIp->Line;\n    if (interp->framePtr->ps &&  (cp=interp->framePtr->ps->lexer->d.str))\n        while (line-- > 1)\n            if ((cp = Jsi_Strchr(cp, '\\n'))) cp++;\n    return cp;\n}\n    \n#define FN_assert JSI_INFO(\"\\\nAssert does nothing by default, but can be \\\nenabled with \\\"use assert\\\" or setting Interp.asserts.\")\nJsi_RC jsi_AssertCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (!interp->asserts)\n        return JSI_OK;\n    int rc = 0;\n    Jsi_RC rv = JSI_OK;\n    Jsi_Number d;\n    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n    const char *msg = Jsi_ValueArrayIndexToStr(interp, args, 1, NULL);\n    Jsi_Value *opts = Jsi_ValueArrayIndex(interp, args, 2);\n    //int hasopts = 0;\n    bool b;\n    AssertData udata = {\n        .mode=interp->assertMode,\n        .noStderr=interp->noStderr\n    };\n    \n    if (opts != NULL) {\n        if (opts->vt == JSI_VT_OBJECT) {\n            //hasopts = 1;\n            if (Jsi_OptionsProcess(interp, AssertOptions, &udata, opts, 0) < 0) {\n                return JSI_ERROR;\n            }\n        } else //if (opts->vt != JSI_VT_NULL)\n            return Jsi_LogError(\"arg 3: expected object 'options'\");\n    }\n\n    if (Jsi_ValueGetNumber(interp,v, &d) == JSI_OK)\n        rc = (int)d;\n    else if (Jsi_ValueGetBoolean(interp,v, &b) == JSI_OK)\n        rc = b;\n    else if (Jsi_ValueIsFunction(interp, v)) {\n        if (!msg) {\n        }\n        Jsi_Value *vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, NULL, 0, 0));\n        Jsi_IncrRefCount(interp, vpargs);\n        rc = Jsi_FunctionInvoke(interp, v, vpargs, ret, NULL);\n        Jsi_DecrRefCount(interp, vpargs);\n        if (rc != JSI_OK)\n            return JSI_OK;\n        bool b;\n        if (Jsi_ValueGetNumber(interp, *ret, &d) == JSI_OK)\n            rc = (int)d;\n        else if (Jsi_ValueGetBoolean(interp, *ret, &b) == JSI_OK)\n            rc = b;\n        else \n            return Jsi_LogError(\"invalid function assert\");\n    } else \n        return Jsi_LogError(\"invalid assert\");\n    if (rc == 0) {\n        char mbuf[1024];\n        mbuf[0] = 0;\n        if (!msg) {\n            char *ce, *cp = jsi_GetCurPSLine(interp);\n            if (cp) {\n                cp = Jsi_Strstr(cp, \"assert(\");\n                while (cp && *cp && isspace(*cp)) cp++;\n                if (cp) {\n                    Jsi_Strncpy(mbuf, cp, sizeof(mbuf)-1);\n                    mbuf[sizeof(mbuf)-1] = 0;\n                    ce=Jsi_Strstr(mbuf, \");\");\n                    if (ce) {\n                        ce[1] = 0;\n                        msg = mbuf;\n                    }\n                }\n            }\n            if (!msg)\n                msg = \"ASSERT\";\n        }\n        //Jsi_ValueDup2(interp, ret, v);\n        if (udata.mode != jsi_AssertModeThrow) {\n            Jsi_DString dStr;\n            jsi_LogOptions lo = {}, *loPtr = ((udata.mode==jsi_AssertModeLog || interp->tracePuts)?&interp->logOpts:&lo);\n            Jsi_DSInit(&dStr);\n            const char *imsg = Jsi_DSAppend(&dStr, msg, NULL);\n            SysPutsCmd_(interp, NULL, _this, ret, funcPtr, !udata.noStderr, loPtr, imsg, 0);\n            Jsi_DSFree(&dStr);\n        } else\n            rv = Jsi_LogError(\"%s\", msg);\n    }\n    Jsi_ValueMakeUndef(interp, ret);\n    return rv;\n}\n\ntypedef struct {\n    bool utc, secs, iso;\n    const char *fmt;\n} DateOpts;\n\nstatic Jsi_OptionSpec DateOptions[] = {\n    JSI_OPT(BOOL,   DateOpts, secs, .help=\"Time is seconds (out for parse, in for format)\" ),\n    JSI_OPT(STRKEY, DateOpts, fmt, .help=\"Format string for time\" ),\n    JSI_OPT(BOOL,   DateOpts, iso, .help=\"ISO fmt plus milliseconds ie: %FT%T.%f\" ),\n    JSI_OPT(BOOL,   DateOpts, utc, .help=\"Time is utc (in for parse, out for format)\" ),\n    JSI_OPT_END(DateOpts, .help=\"Date options\")\n};\n\nstatic const char *timeFmts[] = {\n    \"%Y-%m-%d %H:%M:%S\",\n    \"%Y-%m-%dT%H:%M:%S\",\n    \"%Y-%m-%d %H:%M\",\n    \"%Y-%m-%dT%H:%M\",\n    \"%Y-%m-%d\",\n    \"%H:%M:%S\",\n    \"%H:%M\",\n    \"%c\",\n    NULL\n};\n\nJsi_RC Jsi_DatetimeParse(Jsi_Interp *interp, const char *str, const char *fmt, int isUtc, Jsi_Number *datePtr, bool noMsg)\n{\n    char fmt1[JSI_BUFSIZ];\n    const char *rv = NULL;;\n    Jsi_Number n = -1;\n    int j = 0, tofs = 0;\n    Jsi_RC rc = JSI_OK;\n    Jsi_Number ms = 0;\n    struct tm tm = {};\n    tm.tm_isdst = -1;\n    time_t t;\n    if (!str || !Jsi_Strcmp(\"now\", str)) {\n        struct timeval tv;\n        gettimeofday(&tv, NULL);\n        n = tv.tv_sec*1000.0 + (tv.tv_usec)/1000.0;\n        if (isUtc) {\n            time_t t = time(NULL);\n            struct tm lt = {0};\n            lt.tm_isdst = -1;\n            localtime_r(&t, &lt);\n            \n#ifdef __WIN32\n            {\n                time_t tt = 0;\n                n += (int)time(&tt);\n            }\n#else\n            n += (lt.tm_gmtoff)*1000.0;\n#endif\n        }\n        if (datePtr)\n            *datePtr = n;\n        return rc;\n    }\n    if (fmt && fmt[0]) {\n        const char *efp = Jsi_Strstr(fmt, \"%f\");\n        if (efp && efp > fmt && efp[-1] != '%' && (Jsi_Strlen(fmt)+10)<(int)sizeof(fmt1)) {\n            snprintf(fmt1, sizeof(fmt1), \"%.*s:%%S.\", (int)(efp-fmt), fmt);\n            fmt = fmt1;\n        }\n        rv = strptime(str, fmt, &tm);\n    } else {\n        if (fmt) j++;\n        while (timeFmts[j]) {\n            rv = strptime(str, timeFmts[j], &tm);\n            if (rv != NULL)\n                break;\n            j++;\n        }\n    }\n    if (!rv) {\n        rc = JSI_ERROR;\n        if (!noMsg)\n            Jsi_LogError(\"datetime parse failed\");\n    } else {\n        if (*rv == '.' && isdigit(rv[1]) && isdigit(rv[2]) && isdigit(rv[3])) {\n            ms = atof(rv+1);\n            rv += 4;\n        }\n#if 0\n        if (!isUtc) {\n#ifdef __WIN32\n#ifdef JSI_IS64BIT\n            t = internal_timegm(&tm);\n#else\n            t = _mkgmtime(&tm); // TODO: undefined in mingw 64\n#endif\n#else\n            t = timegm(&tm);\n#endif\n        } else\n#endif\n        {\n            int th, ts;\n            char ss[3];\n            t = mktime(&tm);\n            if (rv[0] == ' ') rv++;\n            if (rv[0] && sscanf(rv, \"%[+-]%2d:%2d\", ss, &th, &ts) == 3) {\n                int sign = (rv[0] == '-' ? 1 : -1);\n                tofs = (3600*th+60*ts)*sign;\n            }\n            if (isUtc) {\n#ifdef __WIN32\n                time_t tt = 0;\n                tofs += (int)time(&tt);\n#else\n                tofs += tm.tm_gmtoff;\n#endif\n            }\n        }\n        if (t==-1) {\n            rc = JSI_ERROR;\n            if (!noMsg)\n                Jsi_LogError(\"mktime failed\");\n        }\n        n = (Jsi_Number)(t+tofs)*1000.0 + ms;\n    }\n    if (rc == JSI_OK && datePtr)\n        *datePtr = n;\n    return rc;\n}\n\nJsi_RC Jsi_DatetimeFormat(Jsi_Interp *interp, Jsi_Number num, const char *fmt, int isUtc, Jsi_DString *dStr)\n{\n    char buf[JSI_BUFSIZ], fmt1[JSI_BUFSIZ], fmt2[JSI_BUFSIZ];\n    time_t tt;\n    Jsi_RC rc = JSI_OK;\n    fmt2[0] = 0;\n    \n    tt = (time_t)(num/1000);\n    if (fmt==NULL)\n        fmt = timeFmts[0];\n    else if (*fmt == 0) {\n        if (!isUtc)\n            fmt = timeFmts[1];\n        else\n            fmt = timeFmts[2];\n    }\n    \n    const char *efp = Jsi_Strstr(fmt, \"%f\");\n    if (efp && efp > fmt && efp[-1] != '%' && ((efp-fmt)+10)<(int)sizeof(fmt1)) {\n        int elen = (efp-fmt)+1;\n        Jsi_Strncpy(fmt1, fmt, elen);\n        Jsi_Strcpy(fmt1+elen, \"%S.\");\n        Jsi_Strcpy(fmt2, efp+2);\n        fmt = fmt1;\n    } else\n        efp = NULL;\n    struct tm tm = {}, *tmp=&tm;\n    tm.tm_isdst = -1;\n#ifdef __WIN32\n    if (isUtc)\n        tmp = gmtime(&tt);\n    else\n        tmp = localtime(&tt);\n#else\n    if (isUtc)\n        gmtime_r(&tt, &tm);\n    else\n        localtime_r(&tt, &tm);\n#endif\n    buf[0] = 0;\n    int rr = strftime(buf, sizeof(buf), fmt, tmp);\n       \n    if (rr<=0)\n        rc = Jsi_LogError(\"time format error: %d\", (int)tt);\n    else {\n        Jsi_DSAppendLen(dStr, buf, -1);\n        if (efp) {\n            snprintf(buf, sizeof(buf), \"%3.3d\", (int)(((Jsi_Wide)num)%1000));\n            Jsi_DSAppendLen(dStr, buf[1]=='.'?buf+2:buf, -1);\n        }\n    }\n    if (rc == JSI_OK && fmt2[0]) {\n        buf[0] = 0;\n        int rr = strftime(buf, sizeof(buf), fmt2, tmp);\n           \n        if (rr<=0)\n            rc = Jsi_LogError(\"time format error\");\n        else\n            Jsi_DSAppendLen(dStr, buf, -1);\n    }\n    return rc;\n}\n\n/* Get time in milliseconds since Jan 1, 1970 */\nJsi_Number Jsi_DateTime(void)\n{\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    Jsi_Number num = ((Jsi_Number)tv.tv_sec*1000.0 + (Jsi_Number)tv.tv_usec/1000.0);\n    return num;\n}\n\ndouble jsi_GetTimestamp(void) {\n#ifdef __WIN32\n    return Jsi_DateTime()/1000;\n#else\n    struct timespec tv;\n    clock_gettime(CLOCK_MONOTONIC, &tv);\n    return (double)tv.tv_sec + (double)tv.tv_nsec/1000000000.0;\n#endif\n}\n\n\nstatic Jsi_RC DateStrptimeCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    const char *str = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    Jsi_Value *opt = Jsi_ValueArrayIndex(interp, args, 1);\n    Jsi_Number w = 0;\n    int isOpt = 0;\n    DateOpts opts = {};\n    const char *fmt = NULL;\n    if (opt != NULL && opt->vt != JSI_VT_NULL && !(fmt = Jsi_ValueString(interp, opt, NULL))) {\n        if (Jsi_OptionsProcess(interp, DateOptions, &opts, opt, 0) < 0) {\n            return JSI_ERROR;\n        }\n        isOpt = 1;\n        fmt = opts.fmt;\n    }\n    if (!str || !*str)\n        str = \"now\";\n    Jsi_RC rc = Jsi_DatetimeParse(interp, str, fmt, opts.utc, &w, true);\n    if (rc != JSI_OK) {\n        Jsi_ValueDup2(interp, ret, interp->NaNValue);\n        rc = JSI_OK;\n    } else {\n        if (opts.secs)\n            w = (Jsi_Number)((Jsi_Wide)(w/1000));\n        Jsi_ValueMakeNumber(interp, ret, w);\n    }\n    if (isOpt)\n        Jsi_OptionsFree(interp, DateOptions, &opts, 0);\n    return rc;\n}\n\n#define FN_strftime JSI_INFO(\"\\\nNull or no value will use current time.\")\nstatic Jsi_RC DateStrftimeCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Value* val = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_Value* opt = Jsi_ValueArrayIndex(interp, args, 1);\n    const char *fmt = NULL;//, *cp = NULL;\n    DateOpts opts = {};\n    Jsi_Number num;\n    int isOpt = 0;\n    Jsi_RC rc = JSI_OK;\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    \n    if (val==NULL || Jsi_ValueIsNull(interp, val)) {\n        //num = 1000.0 * (Jsi_Number)time(NULL);\n        struct timeval tv;\n        gettimeofday(&tv, NULL);\n        num = tv.tv_sec*1000LL + ((Jsi_Wide)tv.tv_usec)/1000LL;\n\n   /* } else if ((cp=Jsi_ValueString(interp, val, NULL))) {*/\n        /* Handle below */\n    } else if (Jsi_GetDoubleFromValue(interp, val, &num) != JSI_OK)\n        return JSI_ERROR;\n        \n    if (opt != NULL && opt->vt != JSI_VT_NULL && !(fmt = Jsi_ValueString(interp, opt, NULL))) {\n        if (Jsi_OptionsProcess(interp, DateOptions, &opts, opt, 0) < 0) {\n            return JSI_ERROR;\n        }\n        isOpt = 1;\n        fmt = opts.fmt;\n        if (opts.iso) {\n            if (fmt)\n                return Jsi_LogError(\"Do not use both iso and fmt\");\n            fmt = \"%FT%T.%f\";\n        }\n    }\n    const char *errMsg = \"time format error\";\n/*    if (cp) {\n        if (isdigit(*cp))\n            rc = Jsi_GetDouble(interp, cp, &num);\n        else {\n            if (Jsi_Strcmp(cp,\"now\")==0) {\n                num = Jsi_DateTime();\n            } else {\n                rc = JSI_ERROR;\n                errMsg = \"allowable strings are 'now' or digits\";\n            }\n        }\n    }*/\n    if (rc == JSI_OK) {\n        if (opts.secs)\n            num = (Jsi_Number)((Jsi_Wide)(num*1000));\n        rc = Jsi_DatetimeFormat(interp, num, fmt, opts.utc, &dStr);\n    }\n    if (rc != JSI_OK)\n        Jsi_LogError(\"%s\", errMsg);\n    else\n        Jsi_ValueFromDS(interp, &dStr, ret);\n    if (isOpt)\n        Jsi_OptionsFree(interp, DateOptions, &opts, 0);\n    Jsi_DSFree(&dStr);\n    return rc;\n}\n\n#define FN_infovars JSI_INFO(\"\\\nReturns all values, data or function.\")\nstatic Jsi_RC InfoVarsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char *key;\n    int n, curlen = 0, isreg = 0, isobj = 0;\n    Jsi_HashEntry *hPtr;\n    Jsi_HashSearch search;\n    Jsi_Value *v;\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);\n    const char *name = NULL;\n\n    if (arg) {\n        if (arg->vt == JSI_VT_STRING)\n            name = arg->d.s.str;\n        else if (arg->vt == JSI_VT_OBJECT) {\n            switch (arg->d.obj->ot) {\n                case JSI_OT_STRING: name = arg->d.obj->d.s.str; break;\n                case JSI_OT_REGEXP: isreg = 1; break;\n                case JSI_OT_FUNCTION:\n                case JSI_OT_OBJECT: isobj = 1; break;\n                default: return Jsi_LogError(\"bad type\");\n            }\n        } else\n            return Jsi_LogError(\"bad type\");;\n    }\n    Jsi_Obj *nobj = Jsi_ObjNew(interp);\n    if (name)\n        Jsi_ValueMakeObject(interp, ret, nobj);\n    else\n        Jsi_ValueMakeArrayObject(interp, ret, nobj);\n    if (isobj) {\n        Jsi_TreeEntry* tPtr;\n        Jsi_TreeSearch search;\n        for (tPtr = Jsi_TreeSearchFirst(arg->d.obj->tree, &search, 0, NULL);\n            tPtr; tPtr = Jsi_TreeSearchNext(&search)) {\n            v = (Jsi_Value*)Jsi_TreeValueGet(tPtr);\n            if (v==NULL || Jsi_ValueIsFunction(interp, v)) continue;\n    \n            n = curlen++;\n            key = (char*)Jsi_TreeKeyGet(tPtr);\n            Jsi_ObjArraySet(interp, nobj, Jsi_ValueNewStringKey(interp, key), n);\n        }\n        Jsi_TreeSearchDone(&search);\n        return JSI_OK;\n    }\n    for (hPtr = Jsi_HashSearchFirst(interp->varTbl, &search);\n        hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {\n        if (Jsi_HashValueGet(hPtr))\n            continue;\n        key = (char*)Jsi_HashKeyGet(hPtr);\n        if (name) {\n            if (Jsi_Strcmp(name,key))\n                continue;\n            v = Jsi_VarLookup(interp, key);\n            Jsi_ObjInsert(interp, nobj, \"type\", Jsi_ValueNewStringKey(interp,Jsi_ValueTypeStr(interp, v)),0);\n            return JSI_OK;\n        }\n        if (isreg) {\n            int ismat;\n            Jsi_RegExpMatch(interp, arg, key, &ismat, NULL);\n            if (!ismat)\n                continue;\n        }\n        n = curlen++;\n        Jsi_ObjArraySet(interp, nobj, Jsi_ValueNewStringKey(interp, key), n);\n    }\n    return JSI_OK;\n}\n\nstatic Jsi_Value *jsiNewConcatValue(Jsi_Interp *interp, const char *c1, const char *c2)\n{\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    Jsi_DSAppend(&dStr, c1, c2, NULL);\n    Jsi_Value *val = Jsi_ValueNewStringKey(interp, Jsi_DSValue(&dStr));\n    Jsi_DSFree(&dStr);\n    return val;\n}\n\nstatic Jsi_RC InfoFuncDataSub(Jsi_Interp *interp, Jsi_Value *arg, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr, int flags, Jsi_Obj *nobj)\n{\n    const char *key, *name = NULL, *ename;\n    int n, curlen = 0, isreg = 0, isobj = 0, isglob = 0, nLen = 0;\n    Jsi_HashEntry *hPtr;\n    Jsi_HashSearch search;\n    Jsi_FuncObj *fo;\n    Jsi_Func *func;\n    Jsi_Obj *fobj;\n    Jsi_Value *val, *nval;\n    int isfunc = (flags&1);\n    int isdata = (flags&2);\n    int addPre = (flags&4);\n    Jsi_DString dPre = {};\n    \n    if (!nobj) {\n        nobj = Jsi_ObjNew(interp);\n        Jsi_ValueMakeArrayObject(interp, ret, nobj);\n    }\n    \n    if (!arg)\n        name = \"*\";\n    else {\n        if (arg->vt == JSI_VT_STRING)\n            name = Jsi_ValueString(interp, arg, &nLen);\n        else if (arg->vt == JSI_VT_OBJECT) {\n            switch (arg->d.obj->ot) {\n                case JSI_OT_STRING: name = Jsi_ValueString(interp, arg, &nLen); break;\n                case JSI_OT_REGEXP: isreg = 1; break;\n                case JSI_OT_OBJECT: isobj = 1; break;\n                case JSI_OT_FUNCTION:\n                    fo = arg->d.obj->d.fobj;\n                    if (fo->func->type&FC_BUILDIN)\n                        return JSI_OK;\n                    goto dumpfunc;\n                break;\n                default: return JSI_OK;\n            }\n        } else\n            return JSI_OK;\n    }\n    ename = name;\n    if (isobj) {\n        Jsi_TreeEntry* tPtr;\n        Jsi_TreeSearch search;\n\ndumpobj:\n        for (tPtr = Jsi_TreeSearchFirst(arg->d.obj->tree, &search, 0, NULL);\n            tPtr; tPtr = Jsi_TreeSearchNext(&search)) {\n            Jsi_Value *v = (Jsi_Value*)Jsi_TreeValueGet(tPtr);\n            key = (char*)Jsi_TreeKeyGet(tPtr);\n            if (v==NULL) continue;\n            if (Jsi_ValueIsFunction(interp, v)) {\n                if (!isfunc) continue;\n            } else {\n                if (!isdata) continue;\n            }\n            if (isreg) {\n                int ismat;\n                Jsi_RegExpMatch(interp, arg, key, &ismat, NULL);\n                if (!ismat)\n                    continue;\n            } else if (ename) {\n                if (isglob) {\n                    if (!Jsi_GlobMatch(ename, key, 0))\n                        continue;\n                } else {\n                    if (Jsi_Strcmp(ename, key))\n                        continue;\n                }\n            }\n    \n            n = curlen++;\n            nval = jsiNewConcatValue(interp, (addPre?Jsi_DSValue(&dPre):\"\"), key);\n            Jsi_ObjArraySet(interp, nobj, nval, n);\n        }\n        Jsi_TreeSearchDone(&search);\n        Jsi_DSFree(&dPre);\n        return JSI_OK;\n    }\n    \n    Jsi_ScopeStrs *sstrs;            \n    const char *gs, *gb, *dotStr;\n    \n    if (name) {\n        val = Jsi_NameLookup(interp, name);\n        if (val)\n            goto dumpvar;\n        gs=Jsi_Strchr(name,'*');\n        gb=Jsi_Strchr(name,'[');\n        dotStr = Jsi_Strrchr(name, '.');\n        if (dotStr && ((gs && gs < dotStr) || (gb && gb < dotStr))) \n            return Jsi_LogError(\"glob must be after last dot\");\n        isglob = (gs || gb);\n        if (!isglob)\n            return JSI_OK;\n        if (dotStr) {\n            if (addPre)\n                Jsi_DSAppendLen(&dPre, name, dotStr-ename+1);\n            ename = dotStr+1;\n            Jsi_DString pStr = {};\n            Jsi_DSAppendLen(&pStr, name, dotStr-name);\n            val = Jsi_NameLookup(interp, Jsi_DSValue(&pStr));\n            Jsi_DSFree(&pStr);\n            if (!val)\n                return JSI_OK;\n            if (Jsi_ValueIsObjType(interp, val, JSI_OT_OBJECT)) {\n                arg = val;\n                goto dumpobj;\n            }\n            return JSI_OK;\n        } \n    }\n        \n    for (hPtr = Jsi_HashSearchFirst(interp->varTbl, &search);\n        hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {\n        key = (char*)Jsi_HashKeyGet(hPtr);\n        if (!isfunc)\n            goto doreg;\n        if (!(fobj = (Jsi_Obj*)Jsi_HashValueGet(hPtr)))\n            continue;\n        if (isfunc && name && isreg==0 && isglob==0) {\n\n            if (Jsi_Strcmp(key, name))\n                continue;\n            /* Fill object with args and locals of func. */\n            fo = fobj->d.fobj; \n            goto dumpfunc;\n        }\ndoreg:\n        if (isreg) {\n            int ismat;\n            Jsi_RegExpMatch(interp, arg, key, &ismat, NULL);\n            if (!ismat)\n                continue;\n        } else if (name) {\n            if (isglob) {\n                if (!Jsi_GlobMatch(name, key, 0))\n                    continue;\n            } else {\n                if (Jsi_Strcmp(name, key))\n                    continue;\n            }\n        }\n        n = curlen++;\n        nval = jsiNewConcatValue(interp, (addPre?Jsi_DSValue(&dPre):\"\"), key);\n        Jsi_ObjArraySet(interp, nobj, nval, n);\n    }\n    Jsi_DSFree(&dPre);\n    return JSI_OK;\n\ndumpfunc:\n{\n    nobj = Jsi_ObjNew(interp);\n    Jsi_ValueMakeObject(interp, ret, nobj);\n    func = fo->func;\n    sstrs = func->argnames;\n    int sscnt = (sstrs?sstrs->count:0);\n    const char *strs[sscnt+1];\n    int i;\n    for (i=0; i<sscnt; i++)\n        strs[i] = sstrs->args[i].name;\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    Jsi_Value *aval = Jsi_ValueNewArray(interp, strs, sscnt);\n    Jsi_ObjInsert(interp, nobj, \"argList\", aval, 0);\n    sstrs = func->localnames;\n    Jsi_Value *lval = Jsi_ValueNewArray(interp, strs, sscnt);\n    Jsi_ObjInsert(interp, nobj, \"locals\", lval, 0);\n    jsi_FuncArgsToString(interp, func, &dStr, 1);\n    lval = Jsi_ValueNewStringDup(interp, Jsi_DSValue(&dStr));\n    Jsi_ObjInsert(interp, nobj, \"args\", lval, 0);\n    Jsi_DSFree(&dStr);\n    if (func->retType)\n        Jsi_ObjInsert(interp, nobj, \"retType\", Jsi_ValueNewStringKey(interp, jsi_typeName(interp, func->retType, &dStr)), 0);\n    Jsi_DSFree(&dStr);\n    if (func->script) {\n        lval = Jsi_ValueNewStringKey(interp, func->script);\n        Jsi_ObjInsert(interp, nobj, \"script\", lval, 0);\n        const char *ftype = (func->scriptFile?\"script\":\"eval\");\n        if (!func->opcodes) {\n            ftype = (func->callback == jsi_AliasInvoke ? \"alias\" : \"builtin\");\n        } else {\n            int l1 = func->opcodes->codes->Line;\n            int l2 = func->bodyline.last_line;\n            if (l1>l2) { int lt = l1; l1 = l2; l2 = lt; }\n            lval = Jsi_ValueNewNumber(interp, (Jsi_Number)l1);\n            Jsi_ObjInsert(interp, nobj, \"lineStart\", lval, 0);\n            lval = Jsi_ValueNewNumber(interp, (Jsi_Number)l2);\n            Jsi_ObjInsert(interp, nobj, \"lineEnd\", lval, 0);\n            int len;\n            const char *cp = jsi_FuncGetCode(interp, func, &len);\n            if (cp) {\n                lval = Jsi_ValueNewBlob(interp, (uchar*)cp, len);\n                Jsi_ObjInsert(interp, nobj, \"code\", lval, 0);\n            }\n        }\n        Jsi_ObjInsert(interp, nobj, \"ftype\", Jsi_ValueNewStringKey(interp, ftype), 0);\n    }\n    return JSI_OK;\n}\ndumpvar:\n    if (isfunc && Jsi_ValueIsFunction(interp, val)) {\n        fo = val->d.obj->d.fobj;\n        goto dumpfunc;\n    }\n    nobj = Jsi_ObjNew(interp);\n    Jsi_ValueMakeObject(interp, ret, nobj);\n    Jsi_Value *aval = Jsi_ValueNewStringDup(interp, ename);\n    Jsi_ObjInsert(interp, nobj, \"name\", aval, 0);\n    aval = Jsi_ValueNewStringDup(interp, jsi_ValueTypeName(interp, val));\n    Jsi_ObjInsert(interp, nobj, \"type\", aval, 0);\n    return JSI_OK;\n}\n\nstatic Jsi_RC InfoLookupCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char *str = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    if (!str)\n        return JSI_OK;\n    Jsi_Value *val = Jsi_NameLookup(interp, str);\n    if (!val)\n        return JSI_OK;\n    Jsi_ValueDup2(interp, ret, val);\n    return JSI_OK;\n}\n\n\n#define FN_infolevel JSI_INFO(\"\\\nWith no arg, returns the number of the current stack frame level.\\n\\\nOtherwise returns details on the specified level.\\n\\\nThe topmost level is 1, and 0 is the current level, \\\nand a negative level translates as relative to the current level.\")\nstatic Jsi_RC InfoLevelCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    uint argc =  Jsi_ValueGetLength(interp, args);\n    if (argc<=0) {\n        Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)interp->framePtr->level);\n        return JSI_OK;\n    }\n    Jsi_Number num = 0;\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);\n    jsi_Frame *f = interp->framePtr;\n    if (Jsi_GetNumberFromValue(interp, arg, &num) != JSI_OK)\n        return JSI_ERROR;\n    int lev = (int)num;\n    if (lev <= 0)\n        lev = f->level+lev;\n    if (lev <= 0 || lev > f->level) \n        return Jsi_LogError(\"level %d not between 1 and %d\", (int)num, f->level);\n    while (f->level != lev  && f->parent)\n        f = f->parent;\n    char buf[JSI_BUFSIZ];\n    //int line = (f != interp->framePtr ? f->line : (interp->curIp ? interp->curIp->Line : 0));\n    int line = (f->line ? f->line : (interp->curIp ? interp->curIp->Line : 0));\n    snprintf(buf, sizeof(buf), \"{funcName:\\\"%s\\\", fileName:\\\"%s\\\", line:%d, level:%d, tryDepth:%d, withDepth:%d}\",\n        f->funcName?f->funcName:\"\", f->fileName?f->fileName:\"\", line, f->level, f->tryDepth, f->withDepth\n        );\n    \n    Jsi_RC rc = Jsi_JSONParse(interp, buf, ret, 0);\n    if (rc != JSI_OK)\n        return rc;\n    Jsi_Func *who = f->evalFuncPtr;\n    Jsi_Obj *obj = Jsi_ObjNewArray(interp, NULL, 0, 0);\n    Jsi_Value *val = Jsi_ValueMakeArrayObject(interp, NULL, obj);\n    if (who && who->localnames) {\n        int i;\n        for (i = 0; i < who->localnames->count; ++i) {\n            const char *argkey = jsi_ScopeStrsGet(who->localnames, i);\n            Jsi_Value *v = Jsi_ValueMakeStringKey(interp, NULL, argkey);\n            Jsi_ObjArrayAdd(interp, obj, v);\n\n        }\n    }\n    Jsi_ValueInsert(interp, *ret, \"locals\", val, 0);\n    Jsi_ValueInsert(interp, *ret, \"scope\", f->incsc, 0);\n    Jsi_ValueInsert(interp, *ret, \"inthis\", f->inthis, 0);\n    return rc;\n}\n\nstatic Jsi_RC InfoFilesCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    return Jsi_HashKeysDump(interp, interp->fileTbl, ret, 0);\n}\n\nstatic Jsi_RC InfoFuncsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);\n    return InfoFuncDataSub(interp, arg, _this, ret, funcPtr, 1, NULL);\n}\n\n#define FN_infodata JSI_INFO(\"\\\nLike info.vars(), but does not return function values.\")\nstatic Jsi_RC InfoDataCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);\n    return InfoFuncDataSub(interp, arg, _this, ret, funcPtr, 2, NULL);\n}\n\nstatic const char* jsi_SqlKeysWords =\n    \",ABORT,ACTION,ADD,AFTER,ALL,ALTER,ANALYZE,AND,\" \n    \"AS,ASC,ATTACH,AUTOINCREMENT,BEFORE,BEGIN,\" \n    \"BETWEEN,BY,CASCADE,CASE,CAST,CHECK,COLLATE,\" \n    \"COLUMN,COMMIT,CONFLICT,CONSTRAINT,CREATE,CROSS,\" \n    \"CURRENT,CURRENT_DATE,CURRENT_TIME,CURRENT_TIMESTAMP,\" \n    \"DATABASE,DEFAULT,DEFERRABLE,DEFERRED,DELETE,DESC,\" \n    \"DETACH,DISTINCT,DO,DROP,EACH,ELSE,END,\" \n    \"ESCAPE,EXCEPT,EXCLUDE,EXCLUSIVE,EXISTS,EXPLAIN,\" \n    \"FAIL,FILTER,FIRST,FOLLOWING,FOR,FOREIGN,FROM,\" \n    \"FULL,GLOB,GROUP,GROUPS,HAVING,IF,IGNORE,\" \n    \"IMMEDIATE,IN,INDEX,INDEXED,INITIALLY,INNER,\" \n    \"INSERT,INSTEAD,INTERSECT,INTO,IS,ISNULL,JOIN,\" \n    \"KEY,LAST,LEFT,LIKE,LIMIT,MATCH,NATURAL,NO,\" \n    \"NOT,NOTHING,NOTNULL,NULL,NULLS,OF,OFFSET,ON,\" \n    \"OR,ORDER,OTHERS,OUTER,OVER,PARTITION,PLAN,\" \n    \"PRAGMA,PRECEDING,PRIMARY,QUERY,RAISE,RANGE,\" \n    \"RECURSIVE,REFERENCES,REGEXP,REINDEX,RELEASE,\" \n    \"RENAME,REPLACE,RESTRICT,RIGHT,ROLLBACK,ROW,\" \n    \"ROWS,SAVEPOINT,SELECT,SET,TABLE,TEMP,TEMPORARY,\" \n    \"THEN,TIES,TO,TRANSACTION,TRIGGER,UNBOUNDED,\" \n    \"UNION,UNIQUE,UPDATE,USING,VACUUM,VALUES,VIEW,\" \n    \"VIRTUAL,WHEN,WHERE,WINDOW,WITH,WITHOUT,\";\n\nstatic int jsi_SqlIsKeyword(const char *str) {\n    char kbuf[25];\n    int i;\n    if (!str[0] || !isalpha(str[0])) return 0;\n    kbuf[0]=',';\n    for (i=0; str[i]; i++) {\n        if (i>20) return 0;\n        if (!isalpha(str[i])) return 0;\n        kbuf[i+1] = toupper(str[i]);\n    }\n    kbuf[++i] = ',';\n    kbuf[++i] = 0;\n    return (Jsi_Strstr(jsi_SqlKeysWords, kbuf)!=NULL);\n}\n\nbool Jsi_IsReserved(Jsi_Interp *interp, const char* str, bool sql) {\n    if (sql)\n        return jsi_SqlIsKeyword(str);\n    return (Jsi_HashEntryFind(interp->lexkeyTbl, str)!=NULL);\n}\n\nstatic Jsi_RC InfoKeywordsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    bool isSql = 0;\n    Jsi_Value* vsql = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_Value* val = Jsi_ValueArrayIndex(interp, args, 1);\n    const char *str = NULL;\n    if (vsql && Jsi_ValueGetBoolean(interp, vsql, &isSql) != JSI_OK)\n            return Jsi_LogError(\"arg1: expected bool 'isSql'\");\n    if (val) {\n        str = Jsi_ValueString(interp, val, NULL);\n        if (!str)\n            return Jsi_LogError(\"arg2: expected string 'name'\");\n    }\n\n    if (!str) {\n        if (!isSql) {\n            if (interp->lexkeyTbl) {\n                Jsi_HashKeysDump(interp, interp->lexkeyTbl, ret, 0);\n                Jsi_ValueArraySort(interp, *ret, 0);\n            }\n        } else {\n            Jsi_DString dStr = {};\n            int vargc; char **vargv;\n            Jsi_SplitStr(jsi_SqlKeysWords+1, &vargc, &vargv, \",\", &dStr);\n            Jsi_ValueMakeArrayObject(interp, ret, NULL);\n            Jsi_Obj *obj = (*ret)->d.obj;\n            int i;\n            for (i = 0; i < (vargc-1); ++i)\n                Jsi_ObjArraySet(interp, obj, Jsi_ValueNewStringDup(interp, vargv[i]), i);\n            Jsi_DSFree(&dStr);\n        }\n        return JSI_OK;\n    }\n    Jsi_ValueMakeBool(interp, ret, Jsi_IsReserved(interp, str, isSql));\n    return JSI_OK;\n}\n\nstatic Jsi_RC InfoOptionsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    uint i, argc =  Jsi_ValueGetLength(interp, args);\n    Jsi_DString dStr = {};\n    const char *str;\n    bool bv = 0;\n    if (argc && Jsi_GetBoolFromValue(interp, Jsi_ValueArrayIndex(interp, args, 0), &bv) != JSI_OK)\n        return JSI_ERROR;\n    Jsi_DSAppend(&dStr, \"[\", NULL);\n    for (i=1; (str = jsi_OptionTypeStr((Jsi_OptionId)i, bv)); i++)\n        Jsi_DSAppend(&dStr, (i>1?\", \":\"\"), \"\\\"\", str, \"\\\"\", NULL);\n    Jsi_DSAppend(&dStr, \"]\", NULL);\n    Jsi_JSONParse(interp, Jsi_DSValue(&dStr), ret, 0);\n    Jsi_DSFree(&dStr);\n    return JSI_OK;\n}\nstatic Jsi_RC InfoVersionCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Value *full = Jsi_ValueArrayIndex(interp, args, 0);\n    if (!full)\n        Jsi_ValueMakeNumber(interp, ret, Jsi_Version());\n    else if (!Jsi_ValueIsBoolean(interp, full))\n        return Jsi_LogError(\"arg1: expected bool 'full'\");\n    else if (!Jsi_ValueIsTrue(interp, full))\n        Jsi_ValueMakeNumber(interp, ret, Jsi_Version());\n    else {\n        char buf[JSI_BUFSIZ];\n        snprintf(buf, sizeof(buf),\n            \"{major:%d, minor:%d, release:%d, verStr:\\\"%d.%d.%d\\\"}\",\n            JSI_VERSION_MAJOR, JSI_VERSION_MINOR, JSI_VERSION_RELEASE,\n            JSI_VERSION_MAJOR, JSI_VERSION_MINOR, JSI_VERSION_RELEASE);\n        return Jsi_JSONParse(interp, buf, ret, 0);\n    }\n    return JSI_OK;\n}\n\n\nstatic bool jsi_isMain(Jsi_Interp *interp) {\n    int isi = (interp->isMain);\n    if (isi == 0) {\n        const char *c2 = interp->curFile;\n        Jsi_Value *v1 = interp->argv0;\n        if (c2 && v1 && Jsi_ValueIsString(interp, v1)) {\n            char *c1 = Jsi_ValueString(interp, v1, NULL);\n            isi = (c1 && !Jsi_Strcmp(c1,c2));\n        }\n    }\n    return isi;\n}\n\nstatic Jsi_RC InfoIsMainCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_ValueMakeBool(interp, ret, jsi_isMain(interp));\n    return JSI_OK;\n}\n\nstatic Jsi_RC InfoArgv0Cmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (interp->argv0)\n        Jsi_ValueDup2(interp, ret, interp->argv0);\n     return JSI_OK;\n}\n\nstatic Jsi_RC InfoExecZipCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (interp->execZip)\n        Jsi_ValueDup2(interp, ret, interp->execZip);\n     return JSI_OK;\n}\n\n#ifndef JSI_OMIT_DEBUG\nstatic Jsi_RC DebugAddCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (!interp->breakpointHash)\n        interp->breakpointHash = Jsi_HashNew(interp, JSI_KEYS_STRING, jsi_HashFree);\n    int argc = Jsi_ValueGetLength(interp, args);\n    jsi_BreakPoint *bptr, bp = {};\n    Jsi_Number vnum;\n    if (argc>1 && Jsi_ValueGetBoolean(interp, Jsi_ValueArrayIndex(interp, args, 1), &bp.temp) != JSI_OK) \n        return Jsi_LogError(\"bad boolean\");\n    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n    if (Jsi_ValueGetNumber(interp, v, &vnum) == JSI_OK) {\n        bp.line = (int)vnum;\n        bp.file = interp->curFile;\n    } else {\n        const char *val = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n        const char *cp;\n        \n        if (isdigit(val[0])) {\n            if (Jsi_GetInt(interp, val, &bp.line, 0) != JSI_OK) \n                return Jsi_LogError(\"bad number\");\n            bp.file = interp->curFile;\n        } else if ((cp = Jsi_Strchr(val, ':'))) {\n            if (Jsi_GetInt(interp, cp+1, &bp.line, 0) != JSI_OK) \n                return Jsi_LogError(\"bad number\");\n            Jsi_DString dStr = {};\n            Jsi_DSAppendLen(&dStr, val, cp-val);\n            bp.file = Jsi_KeyAdd(interp, Jsi_DSValue(&dStr));\n            Jsi_DSFree(&dStr);\n        } else {\n            bp.func = Jsi_KeyAdd(interp, val);\n        }\n    }\n    if (bp.line<=0 && !bp.func) \n        return Jsi_LogError(\"bad number\");\n    char nbuf[100];\n    bp.id = ++interp->debugOpts.breakIdx;\n    bp.enabled = 1;\n    snprintf(nbuf, sizeof(nbuf), \"%d\", bp.id);\n    bptr = (jsi_BreakPoint*)Jsi_Malloc(sizeof(*bptr));\n    *bptr = bp;\n    Jsi_HashSet(interp->breakpointHash, (void*)nbuf, bptr);\n    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)bp.id);\n    return JSI_OK;\n}\n\nstatic Jsi_RC DebugRemoveCmd_(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr, int op)\n{\n    Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 0);\n    if (interp->breakpointHash)\n    {\n        int num;\n        char nbuf[100];\n        if (Jsi_GetIntFromValue(interp, val, &num) != JSI_OK) \n            return Jsi_LogError(\"bad number\");\n        \n        snprintf(nbuf, sizeof(nbuf), \"%d\", num);\n        Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->breakpointHash, nbuf);\n        jsi_BreakPoint* bptr;\n        if (hPtr && (bptr = (jsi_BreakPoint*)Jsi_HashValueGet(hPtr))) {\n            switch (op) {\n                case 1: bptr->enabled = 0; break;\n                case 2: bptr->enabled = 1; break;\n                default:\n                    Jsi_HashEntryDelete(hPtr);\n            }\n            return JSI_OK;\n        }\n    }\n    return Jsi_LogError(\"unknown breakpoint\");\n}\n\nstatic Jsi_RC DebugRemoveCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    return DebugRemoveCmd_(interp, args, _this, ret, funcPtr, 0);\n}\n\nstatic Jsi_RC DebugEnableCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 1);\n    bool bval;\n    if (Jsi_ValueGetBoolean(interp, val, &bval) != JSI_OK)\n        return JSI_ERROR;\n    return DebugRemoveCmd_(interp, args, _this, ret, funcPtr, bval ? 2 : 1);\n}\n\nstatic Jsi_RC DebugInfoCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (!interp->breakpointHash) {\n        Jsi_ValueMakeArrayObject(interp, ret, NULL);\n        return JSI_OK;\n    }\n    int argc = Jsi_ValueGetLength(interp, args);\n    if (argc == 0)\n        return Jsi_HashKeysDump(interp, interp->breakpointHash, ret, 0);\n    Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 0);\n    int num;\n    char nbuf[100];\n    if (Jsi_GetIntFromValue(interp, val, &num) != JSI_OK) \n        return Jsi_LogError(\"bad number\");\n    \n    snprintf(nbuf, sizeof(nbuf), \"%d\", num);\n    Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->breakpointHash, nbuf);\n    if (!hPtr) \n        return Jsi_LogError(\"unknown breakpoint\");\n    jsi_BreakPoint* bp = (jsi_BreakPoint*)Jsi_HashValueGet(hPtr);\n    if (!bp) return JSI_ERROR;\n    Jsi_DString dStr = {};\n    if (bp->func)\n        Jsi_DSPrintf(&dStr, \"{id:%d, type:\\\"func\\\", func:\\\"%s\\\", hits:%d, enabled:%s, temporary:%s}\",\n         bp->id, bp->func, bp->hits, bp->enabled?\"true\":\"false\", bp->temp?\"true\":\"false\");\n    else\n        Jsi_DSPrintf(&dStr, \"{id:%d, type:\\\"line\\\", file:\\\"%s\\\", line:%d, hits:%d, enabled:%s}\",\n            bp->id, bp->file?bp->file:\"\", bp->line, bp->hits, bp->enabled?\"true\":\"false\");\n    Jsi_RC rc = Jsi_JSONParse(interp, Jsi_DSValue(&dStr), ret, 0);\n    Jsi_DSFree(&dStr);\n    return rc;\n}\n#endif\n\nstatic Jsi_RC InfoScriptCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);\n    int isreg = 0;\n    const char *name = NULL;\n\n    if (!arg) {\n        name = jsi_GetCurFile(interp);\n    } else {\n        if (arg->vt == JSI_VT_OBJECT) {\n            switch (arg->d.obj->ot) {\n                case JSI_OT_FUNCTION: name = arg->d.obj->d.fobj->func->script; break;\n                case JSI_OT_REGEXP: isreg = 1; break;\n                default: break;\n            }\n        } else\n            return JSI_OK;\n    }\n    if (isreg) {\n        Jsi_HashEntry *hPtr;\n        Jsi_HashSearch search;\n        int curlen = 0, n;\n        const char *key;\n        Jsi_Obj *nobj = Jsi_ObjNew(interp);\n        Jsi_ValueMakeArrayObject(interp, ret, nobj);\n        for (hPtr = Jsi_HashSearchFirst(interp->fileTbl, &search);\n            hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {\n            key = (const char*)Jsi_HashKeyGet(hPtr);\n            if (isreg) {\n                int ismat;\n                Jsi_RegExpMatch(interp, arg, key, &ismat, NULL);\n                if (!ismat)\n                    continue;\n            }\n            n = curlen++;\n            Jsi_ObjArraySet(interp, nobj, Jsi_ValueNewStringKey(interp, key), n);\n        }\n        return JSI_OK;\n    }\n    if (name)\n        Jsi_ValueMakeStringDup(interp, ret, name);\n    return JSI_OK;\n}\n\nstatic Jsi_RC InfoScriptDirCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    const char *path = interp->curDir;\n    if (path)\n        Jsi_ValueMakeStringDup(interp, ret, path);\n    return JSI_OK;\n}\n\nstatic int isBigEndian()\n{\n    union { unsigned short s; unsigned char c[2]; } uval = {0x0102};\n    return uval.c[0] == 1;\n}\n\nstatic Jsi_RC InfoPlatformCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[JSI_BUFSIZ];\n    size_t crcSizes[] = { sizeof(int), sizeof(void*), sizeof(time_t), sizeof(Jsi_Number), (size_t)isBigEndian() };\n#ifdef __WIN32\n    const char *os=\"win\", *platform = \"win\";\n#elif defined(__FreeBSD__)\n    const char *os=\"freebsd\", *platform = \"unix\";\n#else\n    const char *os=\"linux\", *platform = \"unix\";\n#endif\n#ifndef JSI_OMIT_THREADS\n    int thrd = 1;\n#else\n    int thrd = 0;\n#endif\n    if (Jsi_FunctionReturnIgnored(interp, funcPtr))\n        return JSI_OK;\n    snprintf(buf, sizeof(buf),\n        \"{exeExt:\\\"%s\\\", dllExt:\\\"%s\\\", os:\\\"%s\\\", platform:\\\"%s\\\", hasThreads:%s, pointerSize:%zu, timeSize:%zu \"\n        \"intSize:%zu, wideSize:%zu, numberSize:%zu, crc:%x, isBigEndian:%s, confArgs:\\\"%s\\\"}\",\n#ifdef __WIN32\n        \".exe\", \".dll\",\n#else\n        \"\", \".so\",\n#endif\n        os, platform, thrd?\"true\":\"false\", sizeof(void*), sizeof(time_t), sizeof(int),\n        sizeof(Jsi_Wide), sizeof(Jsi_Number), Jsi_Crc32(0, (uchar*)crcSizes, sizeof(crcSizes)),\n        isBigEndian()? \"true\" : \"false\", interp->confArgs);\n        \n    return Jsi_JSONParse(interp, buf, ret, 0);\n}\n\nstatic Jsi_RC InfoNamedCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Obj *nobj;\n    char *argStr = NULL;\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);\n    if (arg  && (argStr = (char*)Jsi_ValueString(interp, arg, NULL)) == NULL) \n        return Jsi_LogError(\"arg1: expected string 'name'\");\n    if (argStr && argStr[0] == '#') {\n        Jsi_Obj *obj = jsi_UserObjFromName(interp, argStr);\n        if (!obj) \n            return Jsi_LogError(\"Unknown object: %s\", argStr);\n        Jsi_ValueMakeObject(interp, ret, obj);\n        return JSI_OK;\n    }\n    nobj = Jsi_ObjNew(interp);\n    Jsi_ValueMakeArrayObject(interp, ret, nobj);\n    return jsi_UserObjDump(interp, argStr, nobj);\n}\n\n\nconst char* Jsi_OptionsData(Jsi_Interp *interp, Jsi_OptionSpec *specs, Jsi_DString *dStr, bool schema) {\n    const Jsi_OptionSpec *send;\n    for (send = specs; send->id>=JSI_OPTION_BOOL && send->id<JSI_OPTION_END; send++) ;\n    if (!send)\n        return NULL;\n    if (schema) {\n        char tbuf[100];\n        int i = 0;\n        if (send->name)\n            Jsi_DSAppend(dStr, \"  -- '\", send->name, \"\\': \", NULL);\n        if (send->help)\n            Jsi_DSAppend(dStr,  send->help, NULL);\n        Jsi_DSAppend(dStr, \"\\n\", NULL);\n        for (; specs->id>=JSI_OPTION_BOOL && specs->id<JSI_OPTION_END; specs++) {\n            const char *tstr = NULL;\n            if (specs->flags&JSI_OPT_DB_DIRTY)\n                continue;\n            if (!Jsi_Strcmp(specs->name, \"rowid\"))\n                continue;\n            switch(specs->id) {\n            case JSI_OPTION_BOOL: tstr = \"BOOLEAN\"; break;\n            case JSI_OPTION_TIME_T: tstr = \"TIMESTAMP\"; break;\n            case JSI_OPTION_TIME_D:\n            case JSI_OPTION_TIME_W:\n                if (specs->flags & JSI_OPT_TIME_TIMEONLY)\n                    tstr = \"TIME\";\n                else if (specs->flags & JSI_OPT_TIME_TIMEONLY)\n                    tstr = \"DATE\";\n                else\n                    tstr = \"DATETIME\";\n                break;\n            case JSI_OPTION_SIZE_T:\n            case JSI_OPTION_SSIZE_T:\n            case JSI_OPTION_INTPTR_T:\n            case JSI_OPTION_UINTPTR_T:\n            case JSI_OPTION_UINT:\n            case JSI_OPTION_INT:\n            case JSI_OPTION_ULONG:\n            case JSI_OPTION_LONG:\n            case JSI_OPTION_USHORT:\n            case JSI_OPTION_SHORT:\n            case JSI_OPTION_UINT8:\n            case JSI_OPTION_UINT16:\n            case JSI_OPTION_UINT32:\n            case JSI_OPTION_UINT64:\n            case JSI_OPTION_INT8:\n            case JSI_OPTION_INT16:\n            case JSI_OPTION_INT32:\n            case JSI_OPTION_INT64: tstr = \"INT\"; break;\n            case JSI_OPTION_FLOAT:\n            case JSI_OPTION_NUMBER:\n            case JSI_OPTION_LDOUBLE:\n            case JSI_OPTION_DOUBLE: tstr = \"FLOAT\"; break;\n            \n            case JSI_OPTION_STRBUF:\n                tstr = tbuf;\n                snprintf(tbuf, sizeof(tbuf), \"VARCHAR(%d)\", specs->size);;\n                break;\n            case JSI_OPTION_DSTRING: \n            case JSI_OPTION_STRKEY:\n            case JSI_OPTION_STRING:\n                tstr = \"TEXT\";\n                break;\n            case JSI_OPTION_CUSTOM:\n                if (specs->custom == Jsi_Opt_SwitchEnum || specs->custom == Jsi_Opt_SwitchBitset) {\n                    if (specs->flags&JSI_OPT_FORCE_INT)\n                        tstr = \"INT\";\n                    else\n                        tstr = \"TEXT\";\n                } else\n                    tstr = \"\";\n                break;\n            case JSI_OPTION_VALUE: /* Unsupported. */\n            case JSI_OPTION_VAR:\n            case JSI_OPTION_OBJ:\n            case JSI_OPTION_ARRAY:\n            case JSI_OPTION_FUNC:\n            case JSI_OPTION_USEROBJ:\n            case JSI_OPTION_REGEXP:\n                break;\n#ifdef __cplusplus\n            case JSI_OPTION_END:\n#else\n            default:\n#endif\n                Jsi_LogBug(\"invalid option type: %d\", specs->id);\n            }\n            \n            if (!tstr) continue;\n            Jsi_DSAppend(dStr, (i?\"\\n ,\":\"  \"), specs->name, \" \", (tstr[0]?tstr:specs->tname), NULL);\n\n            const char *cp;\n            if ((cp=specs->userData)) {\n                const char *udrest = NULL;\n                if (!Jsi_Strcmp(cp, \"DEFAULT\")) {\n                    if ((specs->id == JSI_OPTION_TIME_D || specs->id <= JSI_OPTION_TIME_T)) {\n                        if (specs->flags & JSI_OPT_TIME_DATEONLY)\n                            udrest = \"(round((julianday('now') - 2440587.5)*86400000))\";\n                        else if (specs->flags & JSI_OPT_TIME_TIMEONLY)\n                            udrest = \"(round((julianday('now')-julianday('now','start of day') - 2440587.5)*86400000))\";\n                        else\n                            udrest = \"(round((julianday('now') - 2440587.5)*86400000.0))\";\n                    } else if (specs->id <= JSI_OPTION_TIME_T) {\n                        if (specs->flags & JSI_OPT_TIME_DATEONLY)\n                            udrest = \"(round((julianday('now') - 2440587.5)*86400))\";\n                        else if (specs->flags & JSI_OPT_TIME_TIMEONLY)\n                            udrest = \"(round((julianday('now')-julianday('now','start of day') - 2440587.5)*86400))\";\n                        else\n                            udrest = \"(round((julianday('now') - 2440587.5)*86400.0))\";\n                    }\n                }\n                Jsi_DSAppend(dStr, \" \", cp, udrest, NULL);\n            }\n            if (specs->help)\n                Jsi_DSAppend(dStr, \" -- \", specs->help, NULL);\n            if (specs->id==JSI_OPTION_END)\n                break;\n            i++;\n        }\n        if (send->userData)\n            Jsi_DSAppend(dStr,  send->userData, NULL);\n        Jsi_DSAppend(dStr, \"\\n  -- MD5=\", NULL);\n\n    } else {\n        int i = 0;\n        Jsi_DSAppend(dStr, \"\\n/* \", send->name, \": \", NULL);\n        if (send->help)\n            Jsi_DSAppend(dStr,  send->help, NULL);\n        Jsi_DSAppend(dStr, \" */\\ntypedef struct \",  send->name, \" {\", NULL);\n        for (; specs->id>=JSI_OPTION_BOOL && specs->id<JSI_OPTION_END; specs++) {\n            int nsz = 0;\n            const char *tstr = NULL;\n            switch(specs->id) {\n            case JSI_OPTION_STRBUF: nsz=1;\n            case JSI_OPTION_BOOL:\n            case JSI_OPTION_TIME_T:\n            case JSI_OPTION_TIME_W:\n            case JSI_OPTION_TIME_D:;\n            case JSI_OPTION_SIZE_T:\n            case JSI_OPTION_SSIZE_T:\n            case JSI_OPTION_INTPTR_T:\n            case JSI_OPTION_UINTPTR_T:\n            case JSI_OPTION_INT:\n            case JSI_OPTION_UINT:\n            case JSI_OPTION_LONG:\n            case JSI_OPTION_ULONG:\n            case JSI_OPTION_SHORT:\n            case JSI_OPTION_USHORT:\n            case JSI_OPTION_UINT8:\n            case JSI_OPTION_UINT16:\n            case JSI_OPTION_UINT32:\n            case JSI_OPTION_UINT64:\n            case JSI_OPTION_INT8:\n            case JSI_OPTION_INT16:\n            case JSI_OPTION_INT32:\n            case JSI_OPTION_INT64:\n            case JSI_OPTION_FLOAT:\n            case JSI_OPTION_DOUBLE:\n            case JSI_OPTION_LDOUBLE:\n            case JSI_OPTION_NUMBER:\n            case JSI_OPTION_DSTRING:\n            case JSI_OPTION_STRKEY: \n            case JSI_OPTION_STRING:\n                tstr = jsi_OptionTypeStr(specs->id, 1); \n                break;\n            case JSI_OPTION_CUSTOM:\n                if (specs->custom == Jsi_Opt_SwitchEnum || specs->custom == Jsi_Opt_SwitchBitset) {\n                    tstr = \"int\";\n                } else {\n                    tstr = \"char\";\n                    nsz = 1;\n                }\n                break;\n            case JSI_OPTION_VALUE: /* Unsupported. */\n            case JSI_OPTION_VAR:\n            case JSI_OPTION_OBJ:\n            case JSI_OPTION_ARRAY:\n            case JSI_OPTION_REGEXP:\n            case JSI_OPTION_FUNC:\n            case JSI_OPTION_USEROBJ:\n                break;\n#ifdef __cplusplus\n            case JSI_OPTION_END:\n#else\n            default:\n#endif\n                Jsi_LogBug(\"invalid option type: %d\", specs->id);\n            }\n            \n            if (!tstr) continue;\n            Jsi_DSAppend(dStr, \"\\n    \", tstr, \" \", specs->name, NULL);\n            if (nsz) {\n                Jsi_DSPrintf(dStr, \"[%d]\", specs->size);\n            }\n            Jsi_DSAppend(dStr, \";\", NULL);\n            if (specs->help)\n                Jsi_DSAppend(dStr, \" /* \", specs->help, \" */\", NULL);\n            if (specs->id==JSI_OPTION_END)\n                break;\n            i++;\n        }\n        Jsi_DSAppend(dStr, \"\\n};\\n// MD5=\", NULL);\n\n    }\n    char buf[33];\n    Jsi_CryptoHash(buf, Jsi_DSValue(dStr), Jsi_DSLength(dStr), Jsi_CHash_MD5, 0, 0, NULL);\n    //Jsi_Md5Str(buf, Jsi_DSValue(dStr), -1);\n    Jsi_DSAppend(dStr, buf, NULL);\n\n    return Jsi_DSValue(dStr);\n}\n\nstatic Jsi_RC InfoExecutableCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (jsiIntData.execName == NULL)\n        Jsi_ValueMakeNull(interp, ret);\n    else\n        Jsi_ValueMakeStringKey(interp, ret, jsiIntData.execName);\n    return JSI_OK;\n}\n\n#define FN_infoevent JSI_INFO(\"\\\nWith no args, returns list of all outstanding events.  With one arg, returns info\\\nfor the given event id.\")\n\n#ifndef JSI_OMIT_EVENT\nstatic Jsi_RC InfoEventCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    uint n = 0;\n    int nid;\n    Jsi_HashEntry *hPtr;\n    Jsi_HashSearch search;\n    Jsi_Obj *nobj;\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);\n    \n    if (arg && Jsi_GetIntFromValue(interp, arg, &nid) != JSI_OK)\n        return JSI_ERROR;\n    if (!arg) {\n        nobj = Jsi_ObjNew(interp);\n        Jsi_ValueMakeArrayObject(interp, ret, nobj);\n    }\n\n    for (hPtr = Jsi_HashSearchFirst(interp->eventTbl, &search);\n        hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {\n        uintptr_t id;\n        id = (uintptr_t)Jsi_HashKeyGet(hPtr);\n        if (!arg) {\n            Jsi_ObjArraySet(interp, nobj, Jsi_ValueNewNumber(interp, (Jsi_Number)id), n);\n            n++;\n        } else if (id == (uint)nid) {\n            Jsi_Event *evPtr = (Jsi_Event *)Jsi_HashValueGet(hPtr);\n            Jsi_DString dStr;\n            if (!evPtr) return JSI_ERROR;\n            Jsi_DSInit(&dStr);\n            switch (evPtr->evType) {\n                case JSI_EVENT_SIGNAL:\n                    Jsi_DSPrintf(&dStr, \"{ type:\\\"signal\\\", sigNum:%d, count:%u, builtin:%s, busy:%s }\", \n                        evPtr->sigNum, evPtr->count, (evPtr->handler?\"true\":\"false\"),\n                        (evPtr->busy?\"true\":\"false\") );\n                    break;\n                case JSI_EVENT_TIMER: {\n             \n                    long cur_sec, cur_ms;\n                    uint64_t ms;\n                    jsiGetTime(&cur_sec, &cur_ms);\n                    ms = (evPtr->when_sec*1000LL + evPtr->when_ms) - (cur_sec * 1000LL + cur_ms);\n                    Jsi_DSPrintf(&dStr, \"{ type:\\\"timer\\\", once:%s, when:%\" PRId64 \", count:%u, initial:%\" PRId64 \", builtin:%s, busy:%s }\",\n                        evPtr->once?\"true\":\"false\", (Jsi_Wide)ms, evPtr->count, (Jsi_Wide)evPtr->initialms, (evPtr->handler?\"true\":\"false\"),\n                        (evPtr->busy?\"true\":\"false\") );\n                    break;\n                }\n                case JSI_EVENT_ALWAYS:\n                    Jsi_DSPrintf(&dStr, \"{ type:\\\"always\\\", count:%u, builtin:%s, busy:%s }\", \n                        evPtr->count, (evPtr->handler?\"true\":\"false\"), (evPtr->busy?\"true\":\"false\") );\n                    break;\n            }\n            Jsi_RC rc = Jsi_JSONParse(interp, Jsi_DSValue(&dStr), ret, 0);\n            Jsi_DSFree(&dStr);\n            return rc;\n        }\n    }\n    return JSI_OK;\n}\n\nstatic Jsi_RC eventInfoCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    return InfoEventCmd(interp, args, _this, ret, funcPtr);\n}\n#endif\n\nstatic Jsi_RC InfoErrorCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Obj *nobj = Jsi_ObjNew(interp);\n    Jsi_ValueMakeObject(interp, ret, nobj);\n    Jsi_ValueInsert( interp, *ret, \"file\", Jsi_ValueNewStringKey(interp, interp->errFile?interp->errFile:\"\"), 0);\n    Jsi_ValueInsert(interp, *ret, \"line\", Jsi_ValueNewNumber(interp, interp->errLine), 0);\n    return JSI_OK;\n}\n\nvoid jsi_DumpCmdSpec(Jsi_Interp *interp, Jsi_Obj *nobj, Jsi_CmdSpec* spec, const char *name)\n{\n    Jsi_ObjInsert(interp, nobj, \"minArgs\", Jsi_ValueNewNumber(interp, spec->minArgs),0);\n    Jsi_ObjInsert(interp, nobj, \"maxArgs\", Jsi_ValueNewNumber(interp, spec->maxArgs),0);\n    if (spec->help)\n        Jsi_ObjInsert(interp, nobj, \"help\", Jsi_ValueNewStringKey(interp, spec->help),0);\n    if (spec->info)\n        Jsi_ObjInsert(interp, nobj, \"info\", Jsi_ValueNewStringKey(interp, spec->info),0);\n    Jsi_ObjInsert(interp, nobj, \"args\", Jsi_ValueNewStringKey(interp, spec->argStr?spec->argStr:\"\"),0);\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    Jsi_ObjInsert(interp, nobj, \"retType\", Jsi_ValueNewStringKey(interp, jsi_typeName(interp, spec->retType, &dStr)), 0);\n    Jsi_DSFree(&dStr);\n    Jsi_ObjInsert(interp, nobj, \"name\", Jsi_ValueNewStringKey(interp, name?name:spec->name),0);\n    Jsi_ObjInsert(interp, nobj, \"type\", Jsi_ValueNewStringKey(interp, \"command\"),0);\n    Jsi_ObjInsert(interp, nobj, \"flags\", Jsi_ValueNewNumber(interp, spec->flags),0);\n    if (spec->opts) {\n        Jsi_Obj *sobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n        Jsi_Value *svalue = Jsi_ValueMakeObject(interp, NULL, sobj);\n        Jsi_OptionSpec *os = spec->opts;\n        jsi_DumpOptionSpecs(interp, sobj, os);\n        Jsi_ObjInsert(interp, nobj, \"options\", svalue, 0);\n        while (os->id != JSI_OPTION_END) os++;\n        Jsi_ObjInsert(interp, nobj, \"optHelp\", Jsi_ValueNewStringKey(interp, (os->help?os->help:\"\")), 0);\n\n    }\n}\nvoid jsi_DumpCmdItem(Jsi_Interp *interp, Jsi_Obj *nobj, Jsi_CmdSpecItem* csi, const char *name)\n{\n    Jsi_ObjInsert(interp, nobj, \"name\", Jsi_ValueNewStringKey(interp, name), 0);\n    Jsi_ObjInsert(interp, nobj, \"type\", Jsi_ValueNewStringKey(interp, \"object\"),0);\n    Jsi_ObjInsert(interp, nobj, \"constructor\", Jsi_ValueNewBoolean(interp, csi && csi->isCons), 0);\n    if (csi && csi->help)\n        Jsi_ObjInsert(interp, nobj, \"help\", Jsi_ValueNewStringDup(interp, csi->help),0);\n    if (csi && csi->info)\n        Jsi_ObjInsert(interp, nobj, \"info\", Jsi_ValueNewStringDup(interp, csi->info),0);\n    if (csi && csi->isCons && csi->spec->argStr)\n        Jsi_ObjInsert(interp, nobj, \"args\", Jsi_ValueNewStringDup(interp, csi->spec->argStr),0);\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    Jsi_ObjInsert(interp, nobj, \"retType\", Jsi_ValueNewStringKey(interp, jsi_typeName(interp, csi->spec->retType, &dStr)), 0);\n    Jsi_DSFree(&dStr);\n    if (csi && csi->isCons && csi->spec->opts) {\n        Jsi_Obj *sobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n        Jsi_Value *svalue = Jsi_ValueMakeObject(interp, NULL, sobj);\n        Jsi_OptionSpec *os = csi->spec->opts;\n        jsi_DumpOptionSpecs(interp, sobj, os);\n        Jsi_ObjInsert(interp, nobj, \"options\", svalue, 0);\n        while (os->id != JSI_OPTION_END) os++;\n        Jsi_ObjInsert(interp, nobj, \"optHelp\", Jsi_ValueNewStringKey(interp, (os->help?os->help:\"\")), 0);\n    }\n}\n\n\ntypedef struct {\n    bool full;\n    bool constructor;\n} InfoCmdsData;\n\nstatic Jsi_OptionSpec InfoCmdsOptions[] = {\n    JSI_OPT(BOOL,   InfoCmdsData, full,  .help=\"Return full path\" ),\n    JSI_OPT(BOOL,   InfoCmdsData, constructor, .help=\"Do not exclude constructor\" ),\n    JSI_OPT_END(InfoCmdsData, .help=\"Options for Info.cmds\")\n};\n\nstatic Jsi_RC InfoCmdsCmdSub(Jsi_Interp *interp, Jsi_Value *arg, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr, int all, int sort, Jsi_Obj *nobj, int add)\n{\n    const char *key, *name = NULL, *cp;\n    int tail = (add&2);\n    int curlen = 0, icnt = 0, isglob = 0, dots = 0, gotFirst = 0, ninc;\n    Jsi_MapEntry *hPtr = NULL;\n    Jsi_MapSearch search;\n    Jsi_CmdSpecItem *csi = NULL;\n    Jsi_DString dStr;\n    const char *skey;\n    Jsi_CmdSpec *spec = NULL;\n    \n    Jsi_DSInit(&dStr);\n    int isreg = 0;\n\n    if (!arg)\n        name = \"*\";\n    else {\n        if (arg->vt == JSI_VT_STRING)\n            name = arg->d.s.str;\n        else if (arg->vt == JSI_VT_OBJECT) {\n            switch (arg->d.obj->ot) {\n                case JSI_OT_STRING: name = arg->d.obj->d.s.str; break;\n                case JSI_OT_REGEXP: isreg = 1; break;\n                case JSI_OT_FUNCTION:\n                    spec = arg->d.obj->d.fobj->func->cmdSpec;\n                    if (!spec)\n                        return JSI_OK;\n                    skey = spec->name;\n                    goto dumpfunc;\n                    break;\n                default: return JSI_OK;\n            }\n        } else\n            return JSI_OK;\n    }\n    ninc = 0;\n    isglob = (isreg == 0 && name && (Jsi_Strchr(name,'*') || Jsi_Strchr(name,'[')));\n    if (isglob) {\n        cp = name;\n        while (*cp) { if (*cp == '.') dots++; cp++; }\n    }\n    while (1) {\n        if (++icnt == 1) {\n           /* if (0 && name)\n                hPtr = Jsi_MapEntryFind(interp->cmdSpecTbl, \"\");\n            else */ {\n                hPtr = Jsi_MapSearchFirst(interp->cmdSpecTbl, &search, 0);\n                gotFirst = 1;\n            }\n        } else if (icnt == 2 && name && !gotFirst)\n            hPtr = Jsi_MapSearchFirst(interp->cmdSpecTbl, &search, 0);\n        else\n            hPtr = Jsi_MapSearchNext(&search);\n        if (!hPtr)\n            break;\n        csi = (Jsi_CmdSpecItem*)Jsi_MapValueGet(hPtr);\n        key = (const char *)Jsi_MapKeyGet(hPtr, 0);\n        if (isglob && dots == 0 && *key && Jsi_GlobMatch(name, key, 0) && !Jsi_Strchr(key, '.')) {\n                Jsi_ObjArraySet(interp, nobj, Jsi_ValueNewStringKey(interp, key), curlen++);\n                ninc++;\n        }\n        if (isglob == 0 && name && key[0] && Jsi_Strcmp(name, key)==0) {\n            skey = (char*)name;\n            spec = NULL;\n            goto dumpfunc;\n        }\n        assert(csi);\n        do {\n            int i;\n            for (i=0; csi->spec[i].name; i++) {\n                Jsi_DSSetLength(&dStr, 0);\n                spec = csi->spec+i;\n                if (i==0 && spec->flags&JSI_CMD_IS_CONSTRUCTOR && !all) /* ignore constructor name. */\n                    continue;\n                if (key[0])\n                    Jsi_DSAppend(&dStr, key, \".\", NULL);\n                Jsi_DSAppend(&dStr, spec->name, NULL);\n                skey = Jsi_DSValue(&dStr);\n                if (isglob) {\n                    if (!(((key[0]==0 && dots == 0) || (key[0] && dots == 1)) &&\n                        Jsi_GlobMatch(name, skey, 0)))\n                    continue;\n                }\n                if (name && isglob == 0 && Jsi_Strcmp(name,skey) == 0) {\ndumpfunc:\n                    nobj = Jsi_ObjNew(interp);\n                    Jsi_ValueMakeObject(interp, ret, nobj);\n                    if (spec == NULL)\n                        jsi_DumpCmdItem(interp, nobj, csi, skey);\n                    else\n                        jsi_DumpCmdSpec(interp, nobj, spec, skey);\n                    Jsi_DSFree(&dStr);\n                    return JSI_OK;\n                    \n                } else if (isglob == 0 && isreg == 0)\n                    continue;\n                if (isreg) {\n                    int ismat;\n                    Jsi_RegExpMatch(interp, arg, skey, &ismat, NULL);\n                    if (!ismat)\n                        continue;\n                }\n                Jsi_ObjArraySet(interp, nobj, Jsi_ValueNewStringKey(interp, tail?spec->name:skey), curlen++);\n                ninc++;\n            }\n            csi = csi->next;\n        } while (csi);\n    }\n    Jsi_DSFree(&dStr);\n    if (sort && (*ret)->vt != JSI_VT_UNDEF)\n        Jsi_ValueArraySort(interp, *ret, 0);\n    return JSI_OK;    \n}\n\n// TODO: does not show loaded commands.\nstatic Jsi_RC InfoCmdsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    InfoCmdsData data = {};\n    Jsi_Value *vo = Jsi_ValueArrayIndex(interp, args, 1);\n    if (vo) {\n        if (!Jsi_ValueIsObjType(interp, vo, JSI_OT_OBJECT)) /* Future options. */\n            return Jsi_LogError(\"arg2: expected object 'options'\");\n        if (Jsi_OptionsProcess(interp, InfoCmdsOptions, &data, vo, 0) < 0) {\n            return JSI_ERROR;\n        }\n    }\n\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_Obj *nobj = Jsi_ObjNew(interp);\n    Jsi_ValueMakeArrayObject(interp, ret, nobj);\n    int ff = (data.full ? 0 : 2);\n    return InfoCmdsCmdSub(interp, arg, _this, ret, funcPtr, data.constructor, 1, nobj, ff);\n}\n\n\nstatic Jsi_RC InfoMethodsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_RC rc = InfoFuncDataSub(interp, arg, _this, ret, funcPtr, 1, NULL);\n    if (rc == JSI_OK && Jsi_ValueIsArray(interp, *ret)) {\n        Jsi_Obj *nobj = (*ret)->d.obj;\n        InfoCmdsCmdSub(interp, arg, _this, ret, funcPtr, 0, 1, nobj, 3);\n    }\n    return rc;\n}\n\nstatic Jsi_RC InfoLocalsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n   // if (!interp->framePtr->funcName)\n   //     return Jsi_LogError(\"Not in function\");\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);\n    bool varsOnly = 0;\n    if (arg)\n        Jsi_ValueGetBoolean(interp, arg, &varsOnly);\n    Jsi_ValueMakeObject(interp, ret, NULL);\n    Jsi_Value *cs = interp->framePtr->incsc;\n    Jsi_Obj *nobj = (*ret)->d.obj;\n    Jsi_TreeEntry* tPtr;\n    Jsi_TreeSearch search;\n    for (tPtr = Jsi_TreeSearchFirst(cs->d.obj->tree, &search, 0, NULL);\n        tPtr; tPtr = Jsi_TreeSearchNext(&search)) {\n        Jsi_Value *v = (Jsi_Value*)Jsi_TreeValueGet(tPtr);\n        if (v==NULL) continue;\n        if (Jsi_ValueIsFunction(interp, v)) {\n            if (varsOnly) continue;\n        } else {\n            if (arg && !varsOnly) continue;\n        }\n\n        const char* key = (char*)Jsi_TreeKeyGet(tPtr);\n        Jsi_ObjInsert(interp, nobj, key, v, 0);\n    }\n    Jsi_TreeSearchDone(&search);\n\n    return JSI_OK;\n}\n\nstatic Jsi_RC InfoCompletionsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int slen, argc = Jsi_ValueGetLength(interp, args);\n    Jsi_Value *arg1 = Jsi_ValueArrayIndex(interp, args, 0);\n    char *key, *substr, *str = Jsi_ValueString(interp, arg1, &slen);\n    int start = 0, end = slen-1;\n    if (!str)\n        return JSI_ERROR;\n    if (argc>1) {\n        Jsi_Number n1;\n        if (Jsi_GetNumberFromValue(interp, Jsi_ValueArrayIndex(interp, args, 1), &n1) != JSI_OK)\n            return JSI_ERROR;\n        start = (int)n1;\n        if (start<0) start = 0;\n        if (start>=slen) start=slen-1;\n    }\n    if (argc>2) {\n        Jsi_Number n2;\n        if (Jsi_GetNumberFromValue(interp, Jsi_ValueArrayIndex(interp, args, 2), &n2) != JSI_OK)\n            return JSI_ERROR;\n        end = (int)n2;\n        if (end<0) end = slen-1;\n        if (end>=slen) end=slen-1;\n    }\n\n    Jsi_DString dStr = {};\n    Jsi_DSAppendLen(&dStr, str?str+start:\"\", end-start+1);\n    Jsi_DSAppend(&dStr, \"*\", NULL);\n    substr = Jsi_DSValue(&dStr);\n    Jsi_Value *arg = Jsi_ValueNewStringDup(interp, substr);\n    Jsi_IncrRefCount(interp, arg);\n    \n    Jsi_Obj *nobj = Jsi_ObjNew(interp);\n    Jsi_ValueMakeArrayObject(interp, ret, nobj);\n\n    Jsi_RC rc = InfoCmdsCmdSub(interp, arg, _this, ret, funcPtr, 0, 0, nobj, 0);\n    if (rc != JSI_OK || (Jsi_ValueIsArray(interp, *ret) && (*ret)->d.obj->arrCnt>0))\n        goto done;\n    rc = InfoFuncDataSub(interp, arg, _this, ret, funcPtr, 0x7, nobj);\n    if (rc != JSI_OK || (Jsi_ValueIsArray(interp, *ret) && (*ret)->d.obj->arrCnt>0))\n        goto done;\n    if (str) {\n        substr[end-start+1] = 0;\n        slen = Jsi_Strlen(substr);\n    }\n    if (str == NULL || !Jsi_Strchr(substr, '.')) {\n        Jsi_HashEntry *hPtr;\n        Jsi_HashSearch search;\n        int n = Jsi_ValueGetLength(interp, *ret);\n        for (hPtr = Jsi_HashSearchFirst(interp->lexkeyTbl, &search);\n            hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {\n            key = (char*)Jsi_HashKeyGet(hPtr);\n            if (str == NULL || !Jsi_Strncmp(substr, key, slen))\n                Jsi_ValueArraySet(interp, *ret, Jsi_ValueNewStringKey(interp, key), n++);\n        }\n    }\n    Jsi_ValueArraySort(interp, *ret, 0);\ndone:\n    Jsi_DSFree(&dStr);\n    Jsi_DecrRefCount(interp, arg);\n    return rc;\n}\n\nJsi_Value * Jsi_LookupCS(Jsi_Interp *interp, const char *name, int *ofs)\n{\n    const char *csdot = Jsi_Strrchr(name, '.');\n    int len;\n    *ofs = 0;\n    if (csdot == name)\n        return NULL;\n    if (!csdot)\n        return interp->csc;\n    if (!csdot[1])\n        return NULL;\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    Jsi_DSAppendLen(&dStr, name, len=csdot-name);\n    Jsi_Value *cs = Jsi_NameLookup(interp, Jsi_DSValue(&dStr));\n    Jsi_DSFree(&dStr);\n    *ofs = len+1;\n    return cs;\n}\n\nstatic void ValueObjDeleteStr(Jsi_Interp *interp, Jsi_Value *target, const char *key, int force)\n{\n    const char *kstr = key;\n    if (target->vt != JSI_VT_OBJECT) return;\n\n    Jsi_TreeEntry *hPtr;\n    Jsi_MapEntry *hePtr = Jsi_MapEntryFind(target->d.obj->tree->opts.interp->strKeyTbl, key);\n    if (hePtr)\n        kstr = (const char*)Jsi_MapKeyGet(hePtr, 0);\n    hPtr = Jsi_TreeEntryFind(target->d.obj->tree, kstr);\n    if (hPtr == NULL || ( hPtr->f.bits.dontdel && !force))\n        return;\n    Jsi_TreeEntryDelete(hPtr);\n}\n\nJsi_RC Jsi_CommandDelete(Jsi_Interp *interp, const char *name) {\n    int ofs;\n    Jsi_Value *fv = Jsi_NameLookup(interp, name);\n    Jsi_Value *cs = Jsi_LookupCS(interp, name, &ofs);\n    if (cs) {\n        const char *key = name + ofs;\n        ValueObjDeleteStr(interp, cs, key, 1);\n    }\n    if (fv)\n        Jsi_DecrRefCount(interp, fv);\n    return JSI_OK;\n}\n\n\nJsi_Value * jsi_CommandCreate(Jsi_Interp *interp, const char *name, Jsi_CmdProc *cmdProc, void *privData, int flags, Jsi_CmdSpec *cspec)\n{\n    Jsi_Value *n = NULL;\n    const char *csdot = Jsi_Strrchr(name, '.');\n    if (0 && csdot) {\n        Jsi_LogBug(\"commands with dot unsupported: %s\", name);\n        return NULL;\n    }\n    if (csdot == name) {\n        name = csdot+1;\n        csdot = NULL;\n    }\n    if (!csdot) {\n        n = jsi_MakeFuncValue(interp, cmdProc, name, NULL, cspec);\n        Jsi_IncrRefCount(interp, n);\n        Jsi_ObjDecrRefCount(interp, n->d.obj);\n        Jsi_Func *f = n->d.obj->d.fobj->func;\n        f->privData = privData;\n        f->name = Jsi_KeyAdd(interp, name);\n        Jsi_ValueInsertFixed(interp, interp->csc, f->name, n);\n        return n;\n    }\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    Jsi_DSAppendLen(&dStr, name, csdot-name);\n    Jsi_Value *cs = Jsi_NameLookup(interp, Jsi_DSValue(&dStr));\n    Jsi_DSFree(&dStr);\n    if (cs) {\n    \n        n = jsi_MakeFuncValue(interp, cmdProc, csdot+1, NULL, cspec);\n        Jsi_IncrRefCount(interp, n);\n        Jsi_ObjDecrRefCount(interp, n->d.obj);\n        Jsi_Func *f = n->d.obj->d.fobj->func;\n        \n        f->name = Jsi_KeyAdd(interp, csdot+1);\n        f->privData = privData;\n        Jsi_ValueInsertFixed(interp, cs, f->name, n);\n        //Jsi_ObjDecrRefCount(interp, n->d.obj);\n    }\n    return n;\n}\n\nJsi_Value * Jsi_CommandCreate(Jsi_Interp *interp, const char *name, Jsi_CmdProc *cmdProc, void *privData)\n{\n    Jsi_Value *v = jsi_CommandCreate(interp, name, cmdProc, privData, 1, 0);\n    if (v)\n        Jsi_HashSet(interp->genValueTbl, v, v);\n    return v;\n}\n\n// Sanity check builtin args signature.\nbool jsi_CommandArgCheck(Jsi_Interp *interp, Jsi_CmdSpec *cmdSpec, Jsi_Func *f, const char *parent)\n{\n    bool rc = 1;\n    Jsi_DString dStr = {};\n    Jsi_DSAppend(&dStr, cmdSpec->argStr, NULL);\n    const char *elips = Jsi_Strstr(cmdSpec->argStr, \"...\");\n    if (cmdSpec->maxArgs<0 && !elips)\n        Jsi_DSAppend(&dStr, \", ...\", NULL);\n    int aCnt = 0, i = -1;\n    char *cp = Jsi_DSValue(&dStr);\n    while (cp[++i]) if (cp[i]==',') aCnt++;\n    \n    if (cmdSpec->maxArgs>=0) {\n        aCnt++;\n        if (cmdSpec->minArgs<0 || cmdSpec->minArgs>cmdSpec->maxArgs || \n            cmdSpec->minArgs>aCnt || cmdSpec->maxArgs>aCnt || elips) {\n            rc = 0;\n        }                    \n    } else {\n        if (cmdSpec->minArgs<0 || cmdSpec->minArgs>aCnt) {\n            rc = 0;\n        }                    \n    }\n    Jsi_DSFree(&dStr);\n    if (!rc) {\n        jsi_TypeMismatch(interp);\n        Jsi_LogWarn(\"inconsistent arg string for \\\"%s.%s(%s)\\\" [%d,%d]\",\n            parent, cmdSpec->name, cmdSpec->argStr, cmdSpec->minArgs, cmdSpec->maxArgs);\n    }\n    if (f->argnames==NULL && cmdSpec->argStr) {\n        // At least give a clue where the problem is.\n        const char *ocfile = interp->curFile;\n        jsi_Pline *opl = interp->parseLine, pline;\n        interp->parseLine = &pline;\n        pline.first_line = 1;\n        interp->curFile = cmdSpec->name;\n        f->argnames = jsi_ParseArgStr(interp, cmdSpec->argStr);\n        interp->curFile = ocfile;\n        interp->parseLine = opl;\n    }\n    return rc;\n}\n\nstatic Jsi_Value *CommandCreateWithSpec(Jsi_Interp *interp, Jsi_CmdSpec *cSpec, int idx, Jsi_Value *proto, void *privData,\n    const char *parentName, jsi_PkgInfo *pkg)\n{\n    Jsi_CmdSpec *cmdSpec = cSpec+idx;\n    int iscons = (cmdSpec->flags&JSI_CMD_IS_CONSTRUCTOR);\n    Jsi_Value *func = NULL;\n    Jsi_Func *f;\n    if (cmdSpec->name)\n        Jsi_KeyAdd(interp, cmdSpec->name);\n    if (cmdSpec->proc == NULL)\n    {\n        func = jsi_ProtoObjValueNew1(interp, cmdSpec->name);\n        Jsi_ValueInsertFixed(interp, NULL, cmdSpec->name, func);\n        f = func->d.obj->d.fobj->func;\n    } else {\n    \n        func = jsi_MakeFuncValueSpec(interp, cmdSpec, privData);\n    #ifdef JSI_MEM_DEBUG\n        func->VD.label = \"CMDspec\";\n        func->VD.label2 = cmdSpec->name;\n    #endif\n        //Jsi_IncrRefCount(interp, func);\n        //Jsi_HashSet(interp->genValueTbl, func, func);\n        Jsi_ValueInsertFixed(interp, (iscons?NULL:proto), cmdSpec->name, func);\n        f = func->d.obj->d.fobj->func;\n    \n        if (cmdSpec->name)\n            f->name = cmdSpec->name;\n        f->f.flags = (cmdSpec->flags & JSI_CMD_MASK);\n        f->f.bits.hasattr = 1;\n        if (iscons) {\n            f->f.bits.iscons = 1;\n            Jsi_ValueInsertFixed(interp, func, \"prototype\", proto);\n            Jsi_PrototypeObjSet(interp, \"Function\", Jsi_ValueGetObj(interp, func));\n        }\n    }\n    func->d.obj->d.fobj->func->parentName = parentName;\n    func->d.obj->d.fobj->func->pkg = pkg;\n    func->d.obj->d.fobj->func->parentSpec = cSpec;\n    if (cmdSpec->argStr && interp->typeCheck.all)\n        jsi_CommandArgCheck(interp, cmdSpec, f, parentName);\n\n    f->retType = cmdSpec->retType;\n    if (f->retType & JSI_TT_UNDEFINED)\n        Jsi_LogBug(\"illegal use of 'undefined' in a return type: %s\", cmdSpec->name);\n    return func;\n}\n\n\nJsi_Value *Jsi_CommandCreateSpecs(Jsi_Interp *interp, const char *name, Jsi_CmdSpec *cmdSpecs,\n    void *privData, int flags)\n{\n    int i = 0;\n    Jsi_Value *proto = NULL;\n    Jsi_CmdProc *cmdProc = NULL;\n    if (!cmdSpecs[0].name)\n        return NULL;\n    if (!name)\n        name = cmdSpecs[0].name;\n    name = Jsi_KeyAdd(interp, name);\n    if (flags & JSI_CMDSPEC_PROTO) {\n        proto = (Jsi_Value*)privData;\n        privData = NULL;\n        i++;\n    /*} else if (!Jsi_Strcmp(name, cmdSpecs[0].name)) {\n        cmdProc = cmdSpecs[0].proc;\n        i++;*/\n    } else if (!*name)\n        proto = NULL;\n    else {\n        if (!(flags & JSI_CMDSPEC_ISOBJ)) {\n            cmdProc = cmdSpecs[0].proc;\n            proto = jsi_CommandCreate(interp, name, cmdProc, privData, 0, cmdSpecs);\n        } else {\n            proto = jsi_ProtoValueNew(interp, name, NULL);\n        }\n    }\n    jsi_PkgInfo *pkg = jsi_PkgGet(interp, name);\n    for (; cmdSpecs[i].name; i++)\n        CommandCreateWithSpec(interp,  cmdSpecs, i, proto, privData, name, pkg);\n\n    bool isNew;\n    Jsi_MapEntry *hPtr = Jsi_MapEntryNew(interp->cmdSpecTbl, name, &isNew);\n    if (!hPtr || !isNew) {\n        Jsi_LogBug(\"failed cmdspec register: %s\", name);\n        return NULL;\n    }\n    Jsi_CmdSpecItem *op, *p = (Jsi_CmdSpecItem*)Jsi_Calloc(1,sizeof(*p));\n    SIGINIT(p,CMDSPECITEM);\n    p->spec = cmdSpecs;\n    p->flags = flags;\n    p->proto = proto;\n    p->privData = privData;\n    p->name = (const char*)Jsi_MapKeyGet(hPtr, 0);\n    p->hPtr = hPtr;\n    Jsi_CmdSpec *csi = cmdSpecs;\n    p->isCons = (csi && csi->flags&JSI_CMD_IS_CONSTRUCTOR);\n    while (csi->name)\n        csi++;\n    p->help = csi->help;\n    p->info = csi->info;\n    if (!isNew) {\n        op = (Jsi_CmdSpecItem*)Jsi_MapValueGet(hPtr);\n        p->next = op;\n    }\n    Jsi_MapValueSet(hPtr, p);\n    return proto;\n}\n\nvoid jsi_CmdSpecDelete(Jsi_Interp *interp, void *ptr)\n{\n    Jsi_CmdSpecItem *cs = (Jsi_CmdSpecItem*)ptr;\n    Jsi_CmdSpec *p;\n    SIGASSERTV(cs,CMDSPECITEM);\n    //return;\n    while (cs) {\n        p = cs->spec;\n        Jsi_Value *proto = cs->proto;\n        if (proto)\n            Jsi_DecrRefCount(interp, proto);\n        while (0 && p && p->name) {\n            /*Jsi_Value *proto = p->proto;\n            if (proto)\n                Jsi_DecrRefCount(interp, proto);*/\n            p++;\n        }\n        ptr = cs;\n        cs = cs->next;\n        Jsi_Free(ptr);\n    }\n}\n\nstatic Jsi_RC SysVerConvertCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_Value *flag = Jsi_ValueArrayIndex(interp, args, 1);\n    if (!val) goto bail;\n    if (Jsi_ValueIsNumber(interp, val)) {\n        char buf[200];\n        Jsi_Number n;\n        if (Jsi_GetNumberFromValue(interp, val, &n) != JSI_OK)\n            goto bail;\n        jsi_VersionNormalize(n, buf, sizeof(buf));\n        int trunc = 0;\n        if (flag && (Jsi_GetIntFromValue(interp, flag, &trunc) != JSI_OK\n            || trunc<0 || trunc>2))\n            return Jsi_LogError(\"arg2: bad trunc: expected int between 0 and 2\");\n        if (trunc) {\n            int len = Jsi_Strlen(buf)-1;\n            while (trunc>0 && len>1) {\n                if (buf[len] == '0' && buf[len-1] == '.')\n                    buf[len-1] = 0;\n                len -= 2;\n                trunc--;\n            }\n        }\n        Jsi_ValueMakeStringDup(interp, ret, buf);\n        return JSI_OK;\n    }\n    if (Jsi_ValueIsString(interp, val)) {\n        Jsi_Number n;\n        if (jsi_GetVerFromVal(interp, val, &n, 0) == JSI_OK) {\n            Jsi_ValueMakeNumber(interp, ret, n);\n            return JSI_OK;\n        }\n    }\nbail:\n    Jsi_ValueMakeNull(interp, ret);\n    return JSI_OK;\n}\n\nstatic void jsi_sysTypeGet(Jsi_Interp *interp, Jsi_Value *arg, Jsi_DString *dStr) {\n    Jsi_DSFree(dStr);\n    if (!Jsi_ValueIsObjType(interp, arg, JSI_OT_OBJECT)) {\n        Jsi_DSAppend(dStr, jsi_ValueTypeName(interp, arg), NULL);\n        return;\n    }\n    uint i;\n    const char *pre = \"\";\n    Jsi_DSAppend(dStr, \"{\", NULL);\n    Jsi_IterObj *io = Jsi_IterObjNew(interp, NULL);\n    Jsi_IterGetKeys(interp, arg, io, 0);\n    for (i=0; i<io->count; i++) {\n        Jsi_Value *targ = Jsi_ValueObjLookup(interp, arg, io->keys[i], true);\n        Jsi_DSAppend(dStr, pre, io->keys[i], \":\", jsi_ValueTypeName(interp, targ), NULL);\n        pre = \",\";\n    }\n    Jsi_DSAppend(dStr, \"}\", NULL);\n    Jsi_IterObjFree(io);\n}\n\nstatic Jsi_RC SysMatchObjCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char *sp, *cp, *cs, *ss, *ce, *cc;\n    bool ok = 1, partial=0, noerror;\n    Jsi_Value *arg1 = Jsi_ValueArrayIndex(interp, args, 0);\n    if (!arg1 || !Jsi_ValueIsObjType(interp, arg1, JSI_OT_OBJECT))\n        return Jsi_LogError(\"arg 1: exected object\");\n    Jsi_Value *arg2 = Jsi_ValueArrayIndex(interp, args, 1),\n        *arg3 = Jsi_ValueArrayIndex(interp, args, 2),\n        *arg4 = Jsi_ValueArrayIndex(interp, args, 3);\n    \n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    Jsi_RC rc = JSI_OK;\n    if (!arg2) {\n        jsi_sysTypeGet(interp, arg1, &dStr);\n        Jsi_ValueMakeStringDup(interp, ret, Jsi_DSValue(&dStr));\n        Jsi_ValueFromDS(interp, &dStr, ret);\n        return JSI_OK;\n    }\n    sp = Jsi_ValueString(interp, arg2, NULL);\n    if (!sp) {\n        rc = Jsi_LogError(\"arg 2: exected string\");\n        goto done;\n    }\n    if (arg3 && Jsi_GetBoolFromValue(interp, arg3, &partial) != JSI_OK) {\n        rc = Jsi_LogError(\"expected bool 'partial'\");\n        goto done;\n    }\n    if (arg3 && Jsi_GetBoolFromValue(interp, arg4, &noerror) != JSI_OK) {\n        rc = Jsi_LogError(\"expected bool 'noerror'\");\n        goto done;\n    }\n    jsi_sysTypeGet(interp, arg1, &dStr);\n    cp = Jsi_DSValue(&dStr);\n    if (sp) {\n        if (Jsi_Strcmp(cp, sp)) {\n            if (partial && *cp && *sp) {\n                /*Jsi_DString eStr = {}, fStr = {};\n                char *ss = Jsi_AppendLen(&eStr, sp+1, Jsi_Strlen(sp)-2);\n                int vargc; char **vargv;\n                Jsi_SplitStr(Jsi_DSValue(&eStr), &vargc, &vargv, \",\", &fStr);*/\n                cs=cp+1; ss=sp;\n                while (*cs) {\n                    Jsi_DString eStr = {};\n                    ce=Jsi_Strchr(cs,','); \n                    if (!ce) ce = cs+Jsi_Strlen(cs);\n                    Jsi_DSAppend(&eStr, \",\", NULL);\n                    int elen = ce-cs;\n                    cc = Jsi_DSAppendLen(&eStr, cs, elen); // obj key.\n                    int dlen = Jsi_Strlen(cc);\n                    if (dlen>1 && cc[dlen-1]=='}')\n                        cc[--dlen] = 0;\n                    if (*ss=='{' && !Jsi_Strncmp(ss+1, cc+1, dlen-1))\n                        ss = ss+dlen;\n                    else\n                        ss = Jsi_Strstr(ss, cc);\n                    Jsi_DSFree(&eStr);\n                    if (!ss) goto mismatch;\n                    cs=(*ce?ce+1:ce);\n                }\n                goto done;\n            }\nmismatch:\n            ok = 0;\n            if (interp->asserts && !noerror)\n                rc = Jsi_LogError(\"matchobj failed: expected '%s' not '%s'\", cp, sp); \n            else\n                Jsi_LogWarn(\"matchobj failed: expected '%s' not '%s'\", cp, sp);\n        }\n        //goto done;\n    }\ndone:\n    Jsi_DSFree(&dStr);\n    if (rc == JSI_OK)\n        Jsi_ValueMakeBool(interp, ret, ok);\n    return rc;\n    \n/*badstr:\n    Jsi_DSFree(&dStr);\n    return Jsi_LogError(\"array elements must be a string\");*/\n\n}\n\nstatic Jsi_RC SysTimesCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_RC rc = JSI_OK;\n    int i, n=1, argc = Jsi_ValueGetLength(interp, args);\n    Jsi_Value *func = Jsi_ValueArrayIndex(interp, args, 0);\n    if (Jsi_ValueIsBoolean(interp, func)) {\n        bool bv;\n        if (argc != 1)\n            return Jsi_LogError(\"bool must be only arg\");\n        Jsi_GetBoolFromValue(interp, func, &bv);\n        double now = jsi_GetTimestamp();\n        if (bv)\n            interp->timesStart = now;\n        else {\n            char buf[100];\n            snprintf(buf, sizeof(buf), \" (times = %.6f sec)\\n\", (now-interp->timesStart));\n            Jsi_Puts(interp, jsi_Stderr, buf, -1);\n        }\n        Jsi_ValueMakeNumber(interp, ret, 0);\n        return JSI_OK;\n    }\n    Jsi_Wide diff, start, end;\n    if (!Jsi_ValueIsFunction(interp, func))\n        return Jsi_LogError(\"arg1: expected function|bool\");\n    if (argc > 1 && Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, 1), &n) != JSI_OK)\n        return JSI_ERROR;\n    if (n<=0) \n        return Jsi_LogError(\"count not > 0: %d\", n);\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    start = (Jsi_Wide) tv.tv_sec * 1000000 + tv.tv_usec;\n    for (i=0; i<n && rc == JSI_OK; i++) {\n        rc = Jsi_FunctionInvoke(interp, func, NULL, ret, NULL);\n    }\n    gettimeofday(&tv, NULL);\n    end = (Jsi_Wide) tv.tv_sec * 1000000 + tv.tv_usec;\n    diff = (end - start);\n    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)diff);\n    return rc;\n}\n\nstatic Jsi_RC SysFormatCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_DString dStr;\n    Jsi_RC rc = Jsi_FormatString(interp, args, &dStr);\n    if (rc != JSI_OK)\n        return rc;\n    Jsi_ValueFromDS(interp, &dStr, ret);\n    return JSI_OK;\n}\n\nstatic Jsi_RC SysQuoteCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_DString dStr = {};\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);\n    const char *str = Jsi_ValueGetDString(interp, arg, &dStr, 1);\n    Jsi_ValueMakeStringDup(interp, ret, str);\n    Jsi_DSFree(&dStr);\n    return JSI_OK;\n}\n// Karl Malbrain's compact CRC-32. See \"A compact CCITT crc16 and crc32 C implementation that balances processor cache usage against speed\": http://www.geocities.com/malbrain/\nuint32_t Jsi_Crc32(uint32_t crc, const void *ptr, size_t buf_len)\n{\n    static const uint32_t s_crc32[16] = {\n        0x00000000, 0x1db71064, 0x3b6e20c8, 0x26d930ac, 0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c,\n        0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c, 0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c\n    };\n    uint32_t crcu32 = (uint32_t)crc;\n    uchar *uptr = (uchar *)ptr;\n    if (!uptr) return 0;\n    crcu32 = ~crcu32;\n    while (buf_len--) {\n        uchar b = *uptr++;\n        crcu32 = (crcu32 >> 4) ^ s_crc32[(crcu32 & 0xF) ^ (b & 0xF)];\n        crcu32 = (crcu32 >> 4) ^ s_crc32[(crcu32 & 0xF) ^ (b >> 4)];\n    }\n    return ~crcu32;\n}\n\nstatic Jsi_RC SysCrc32Cmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int ilen;\n    char *inbuffer = Jsi_ValueArrayIndexToStr(interp, args, 0, &ilen);\n    Jsi_Number crc = 0;\n    int argc = Jsi_ValueGetLength(interp, args);\n    if (argc>1)\n        Jsi_ValueGetNumber(interp, Jsi_ValueArrayIndex(interp, args, 1), &crc);\n    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)Jsi_Crc32((uint32_t)crc, (uchar*)inbuffer, ilen));\n    return JSI_OK;\n}\n\n#ifndef JSI_OMIT_BASE64\nstatic const char b64ev[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\nstatic int atend;\n\nstatic int\nb64getidx(const char *buffer, int len, int *posn) {\n    char c;\n    char *idx;\n    if (atend) return -1;\n    do {\n    if ((*posn)>=len) {\n        atend = 1;\n        return -1;\n    }\n    c = buffer[(*posn)++];\n    if (c<0 || c=='=') {\n        atend = 1;\n        return -1;\n    }\n    idx = Jsi_Strchr(b64ev, c);\n    } while (!idx);\n    return idx - b64ev; \n} \n\nstatic void B64DecodeDStr(const char *inbuffer, int ilen, Jsi_DString *dStr)\n{\n    int olen, pos;\n    char outbuffer[3];\n    int c[4];\n    \n    pos = 0; \n    atend = 0;\n    while (!atend) {\n        if (inbuffer[pos]=='\\n' ||inbuffer[pos]=='\\r') { pos++; continue; }\n        c[0] = b64getidx(inbuffer, ilen, &pos);\n        c[1] = b64getidx(inbuffer, ilen, &pos);\n        c[2] = b64getidx(inbuffer, ilen, &pos);\n        c[3] = b64getidx(inbuffer, ilen, &pos);\n\n        olen = 0;\n        if (c[0]>=0 && c[1]>=0) {\n            outbuffer[0] = ((c[0]<<2)&0xfc)|((c[1]>>4)&0x03);\n            olen++;\n            if (c[2]>=0) {\n                outbuffer[1] = ((c[1]<<4)&0xf0)|((c[2]>>2)&0x0f);\n                olen++;\n                if (c[3]>=0) {\n                    outbuffer[2] = ((c[2]<<6)&0xc0)|((c[3])&0x3f);\n                    olen++;\n                }\n            }\n        }\n\n        if (olen>0)\n            Jsi_DSAppendLen(dStr, outbuffer, olen);\n        olen = 0;\n    }\n    if (olen>0)\n        Jsi_DSAppendLen(dStr, outbuffer, olen);\n}\n\nstatic Jsi_RC B64Decode(Jsi_Interp *interp, char *inbuffer, int ilen, Jsi_Value **ret)\n{\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    B64DecodeDStr(inbuffer, ilen, &dStr);\n    Jsi_ValueFromDS(interp, &dStr, ret);\n    return JSI_OK;\n}\n\nstatic Jsi_RC\nB64EncodeDStr(const char *ib, int ilen, Jsi_DString *dStr)\n{\n    int i=0, pos=0;\n    char c[74];\n    \n    while (pos<ilen) {\n#define PPDCS(n,s) ((pos+n)>ilen?'=':b64ev[s])\n        c[i++]=b64ev[(ib[pos]>>2)&0x3f];\n        c[i++]=PPDCS(1,((ib[pos]<<4)&0x30)|((ib[pos+1]>>4)&0x0f));\n        c[i++]=PPDCS(2,((ib[pos+1]<<2)&0x3c)|((ib[pos+2]>>6)&0x03));\n        c[i++]=PPDCS(3,ib[pos+2]&0x3f);\n        if (i>=72) {\n            c[i++]='\\n';\n            c[i]=0;\n            Jsi_DSAppendLen(dStr, c, i);\n            i=0;\n        }\n        pos+=3;\n    }\n    if (i) {\n        /*    c[i++]='\\n';*/\n        c[i]=0;\n        Jsi_DSAppendLen(dStr, c, i);\n        i=0;\n    }\n    return JSI_OK;\n}\n\nstatic Jsi_RC\nB64Encode(Jsi_Interp *interp, char *ib, int ilen, Jsi_Value **ret)\n{\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    B64EncodeDStr(ib, ilen, &dStr);\n    Jsi_ValueFromDS(interp, &dStr, ret);\n    return JSI_OK;\n}\n\nJsi_RC Jsi_Base64(const char *str, int len, Jsi_DString *dStr, bool decode)\n{\n    if (len<0)\n        len = Jsi_Strlen(str);\n    if (decode)\n        B64DecodeDStr(str, len, dStr);\n    else\n        B64EncodeDStr(str, len, dStr);\n    return JSI_OK;\n}\n\nstatic Jsi_RC B64DecodeCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int ilen;\n    char *inbuffer = Jsi_ValueArrayIndexToStr(interp, args, 0, &ilen);\n    return B64Decode(interp, inbuffer, ilen, ret);\n}\n\nstatic Jsi_RC B64EncodeCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int ilen;\n    char *inbuffer = Jsi_ValueArrayIndexToStr(interp, args, 0, &ilen);\n    return B64Encode(interp, inbuffer, ilen, ret);\n}\n\nstatic Jsi_RC SysBase64Cmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 1);\n    bool dec = 0;\n    if (arg && Jsi_GetBoolFromValue(interp, arg, &dec) != JSI_OK) \n        return Jsi_LogError(\"arg2: expected bool 'decode'\");\n    if (dec)\n        return B64DecodeCmd(interp, args, _this, ret, funcPtr);\n    else\n        return B64EncodeCmd(interp, args, _this, ret, funcPtr);\n}\n\nstatic Jsi_RC SysArgArrayCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);\n    if (!arg)\n        Jsi_ValueMakeNull(interp, ret);\n    else if (Jsi_ValueIsArray(interp, arg) || Jsi_ValueIsNull(interp, arg))\n        Jsi_ValueCopy(interp, *ret, arg);\n    else\n        Jsi_ValueMakeArrayObject(interp, ret, Jsi_ObjNewArray(interp, &arg, 1, 1));\n    return JSI_OK;\n}\n\nstatic Jsi_RC SysCompleteCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    bool bal = 0;\n    char *arg = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    if (arg)\n        bal = jsi_StrIsBalanced(arg);\n    Jsi_ValueMakeBool(interp, ret, bal);\n    return JSI_OK;\n}\n\nstatic Jsi_RC SysHexStrCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 1);\n    bool dec = 0;\n    if (arg && Jsi_GetBoolFromValue(interp, arg, &dec) != JSI_OK) \n        return Jsi_LogError(\"arg2: expected bool 'decode'\");\n    int len;\n    const char *str = Jsi_ValueArrayIndexToStr(interp, args, 0, &len);\n    if (!str || len<=0)\n        return Jsi_LogError(\"expected string\");\n    Jsi_DString dStr = {};\n    if (Jsi_HexStr((const uchar*)str, len, &dStr, dec)<0) {\n        Jsi_DSFree(&dStr);\n        return Jsi_LogError(\"invalid hex string\");\n    }\n    Jsi_ValueFromDS(interp, &dStr, ret);\n    return JSI_OK;\n}\n#endif\n\n\nstatic const char *hashTypeStrs[] = { \"sha256\", \"sha1\", \"md5\", \"sha3_224\", \"sha3_384\", \"sha3_512\", \"sha3_256\", NULL };\n\ntypedef struct {\n    uint hashcash;\n    Jsi_Value *file;\n    Jsi_CryptoHashType type;\n    bool noHex;\n} HashOpts;\n\n\nstatic Jsi_OptionSpec HashOptions[] = {\n    JSI_OPT(STRING,  HashOpts, file,      .help=\"Read data from file and append to str\" ),\n    JSI_OPT(UINT,    HashOpts, hashcash,  .help=\"Search for a hash with this many leading zero bits by appending :nonce (Proof-Of-Work)\" ),\n    JSI_OPT(BOOL,    HashOpts, noHex,     .help=\"Return binary digest, without conversion to hex chars\" ),\n    JSI_OPT(CUSTOM,  HashOpts, type,      .help=\"Type of hash\", .flags=0, .custom=Jsi_Opt_SwitchEnum, .data=hashTypeStrs ),\n    JSI_OPT_END(HashOpts, .help=\"Options for hash\")\n};\n\nstatic Jsi_RC SysHashCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int n, hasopts = 0, olen;\n    const char *cp = NULL;\n    Jsi_RC rc = JSI_OK;\n    Jsi_DString dStr = {};\n    HashOpts edata = {};\n    char zbuf[1024];\n    \n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);\n    if (!arg || !Jsi_ValueIsString(interp, arg))\n        return Jsi_LogError(\"arg 1: expected string\");\n        \n    cp=Jsi_ValueString(interp, arg, &n);\n    Jsi_DSAppendLen(&dStr, cp, n);\n    Jsi_Value *opt = Jsi_ValueArrayIndex(interp, args, 1);\n    if (opt) {\n        if (opt->vt != JSI_VT_OBJECT || opt->d.obj->ot != JSI_OT_OBJECT)\n            return Jsi_LogError(\"arg1: expected object 'options'\");\n        if (Jsi_OptionsProcess(interp, HashOptions, &edata, opt, 0) < 0)\n            return JSI_ERROR;\n        hasopts = 1;\n    }\n    \n    if (edata.file) {\n        Jsi_Channel in = Jsi_Open(interp, edata.file, \"rb\");\n        \n        if( in==0 ) {\n            rc = Jsi_LogError(\"unable to open file\");\n            goto done;\n        }\n        for(;;) {\n            int n;\n            n = Jsi_Read(interp, in, zbuf, sizeof(zbuf));\n            if( n<=0 ) break;\n            Jsi_DSAppendLen(&dStr, zbuf, n);;\n        }\n        Jsi_Close(interp, in);\n    }\n    cp = Jsi_DSValue(&dStr);\n    n = Jsi_DSLength(&dStr);\n    memset(zbuf, 0, sizeof(zbuf));\n    Jsi_CryptoHash(zbuf, cp, n, edata.type, edata.hashcash, edata.noHex, &olen);\n        \ndone:\n    Jsi_DSFree(&dStr);\n    if (hasopts)\n        Jsi_OptionsFree(interp, HashOptions, &edata, 0);\n    if (rc == JSI_OK) {\n        jsi_ValueMakeBlobDup(interp, ret, (uchar*)zbuf, olen);\n    }\n    return rc;\n\n}\n\n\n#ifndef JSI_OMIT_ENCRYPT\n\n#define FN_encrypt JSI_INFO(\"\\\nKeys that are not 16 bytes use the MD5 hash of the key.\")\nstatic Jsi_RC SysEncryptCmd_(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr, bool decrypt)\n{\n    int ilen, klen;\n    Jsi_RC rc = JSI_OK;\n    const char *key, *str = Jsi_ValueArrayIndexToStr(interp, args, 0, &ilen);\n    Jsi_DString dStr = {};\n    if (!str || !ilen) \n        return Jsi_LogError(\"data must be a non-empty string\");\n    if (decrypt && (ilen%4) != 1) {\n        rc = Jsi_LogError(\"data length incorrect and can not be decrypted\");\n        goto done;\n    }\n    key = Jsi_ValueArrayIndexToStr(interp, args, 1, &klen);\n    Jsi_DSAppendLen(&dStr, str, ilen);\n    rc = Jsi_Encrypt(interp, &dStr, key, klen, decrypt);\n\n    if (rc == JSI_OK)\n        Jsi_ValueMakeDStringObject(interp, ret, &dStr);\n    else\n        Jsi_DSFree(&dStr);\ndone:\n    return rc;\n}\nstatic Jsi_RC SysEncryptCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    return SysEncryptCmd_(interp, args, _this, ret, funcPtr, 0);\n}\nstatic Jsi_RC SysDecryptCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    return SysEncryptCmd_(interp, args, _this, ret, funcPtr, 1);\n}\n#endif\n\nstatic Jsi_RC SysFromCharCodeCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char unibuf[JSI_BUFSIZ+1];\n    int i = 1;    \n    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n    if (!v) return Jsi_LogError(\"arg1: expected number\");\n\n    Jsi_ValueToNumber(interp, v);\n#if JSI_UTF8\n    i = Jsi_UniCharToUtf(v->d.num, unibuf);\n#else\n    unibuf[0] = (char) v->d.num;\n#endif\n    unibuf[i] = 0;\n    Jsi_ValueMakeStringDup(interp, ret, unibuf);\n    return JSI_OK;\n}\n/* Commands visible at the toplevel. */\n\nstatic Jsi_vtype jsi_getValType(Jsi_Value* val) {\n    switch (val->vt) {\n        case JSI_VT_BOOL:\n        case JSI_VT_NUMBER:\n        case JSI_VT_STRING:\n            return val->vt;\n        case JSI_VT_OBJECT:\n            switch (val->d.obj->ot) {\n                case JSI_OT_BOOL: return JSI_VT_BOOL;\n                case JSI_OT_NUMBER: return JSI_VT_NUMBER;\n                case JSI_OT_STRING: return JSI_VT_STRING;\n                default: break;\n            }\n            break;\n        default:\n            break;\n    }\n    return JSI_VT_UNDEF;\n}\n\nstatic Jsi_RC SysRunModuleCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Value *v1 = Jsi_ValueArrayIndex(interp, args, 0),\n    *v2 = Jsi_ValueArrayIndex(interp, args, 1);\n    const char *cp, *mod = NULL;\n    Jsi_RC rc = JSI_OK;\n    Jsi_DString dStr = {}, nStr = {};\n    Jsi_Value *cmd = NULL;\n    Jsi_Value *vpargs, *vargs[2] = {};\n    uint i, n = 0, siz, anum = 0, acnt=0;\n    Jsi_Value **arr;\n    Jsi_Obj *obj;\n    const char *anam;\n    bool isMain = jsi_isMain(interp);\n    if (interp->isMain)\n        interp->isMain = 0;\n    \n    if (v2 && !Jsi_ValueIsObjType(interp, v2, JSI_OT_ARRAY))\n        return Jsi_LogError(\"arg 2: expected array|undefined\");\n    if (!v1 || Jsi_ValueIsNull(interp, v1)) {\n        mod = interp->framePtr->fileName;\n        if (mod) mod = Jsi_Strrchr(mod, '/');\n        if (!mod) return JSI_ERROR;\n        mod++;\n        cp = Jsi_Strrchr(mod, '.');\n        int len = (cp?(cp-mod):(int)Jsi_Strlen(mod));\n        mod = Jsi_DSAppendLen(&dStr, mod, len);\n    } else {\n        mod = Jsi_ValueString(interp, v1, NULL);\n        if (!mod) {\n            if (Jsi_ValueIsObjType(interp, v1, JSI_OT_FUNCTION))\n                cmd = v1;\n            else\n                return Jsi_LogError(\"arg 1: expected string|function|undefined\");\n        }\n    }\n    if (!v2 && isMain)\n        v2 = interp->args;\n\n    if (!cmd && mod) {\n        cmd = Jsi_NameLookup(interp, mod);\n        if (!cmd)\n            cmd = jsi_LoadFunction(interp, mod, NULL);\n    }\n    if (!cmd || !Jsi_ValueIsObjType(interp, cmd, JSI_OT_FUNCTION)) {\n        rc = Jsi_LogError(\"unknown command: %s\", (mod?mod:\"\"));\n        goto done;\n    }\n    \n    if (!v2) {\n        obj = Jsi_ObjNewArray(interp, NULL, 0, 0);\n        vargs[n++] = Jsi_ValueNewObj(interp, obj);\n        vargs[n++] = Jsi_ValueNewObj(interp, obj=Jsi_ObjNew(interp));\n    } else {\n        arr = v2->d.obj->arr;\n        siz = v2->d.obj->arrCnt;\n        for (i=0; i<siz; i+=2) {\n            anam = Jsi_ValueToString(interp, arr[i], NULL);\n            if (i==0 && siz==1 && !Jsi_Strcmp(anam, \"-h\")) { anum=1; break; }\n            if (anam[0] != '-') break;\n            if (anam[0] == '-' && anam[1] == '-' && !anam[2]) {acnt++; break;}\n            anum += 2;\n        }\n        if (anum != 1 && (anum>siz)) {\n            if (anam)\n                interp->lastPushStr = (char*)anam;\n            rc = Jsi_LogError(\"missing argument\");\n            goto done;\n        }\n        obj = Jsi_ObjNewArray(interp, arr+anum+acnt, siz-anum-acnt, 0);\n        vargs[n++] = Jsi_ValueNewObj(interp, obj);\n        vargs[n++] = Jsi_ValueNewObj(interp, obj=Jsi_ObjNew(interp));\n        bool isLong = 0;\n        for (i=0; i<anum; i+=2) {\n            int anLen;\n            const char *astr, *anam = Jsi_ValueToString(interp, arr[i], &anLen);\n            if (anum<=1 && !Jsi_Strcmp(anam,\"-h\") ) anam = \"help\";\n            else if (anam && anam[0] == '-') anam++;\n            else {\n                rc = Jsi_LogError(\"bad option: %d\", i);\n                goto done;\n            }\n                \n            Jsi_Value *aval;\n            if  (anum==1)\n                aval = Jsi_ValueNewBoolean(interp, isLong);\n            else {\n                bool bv;\n                Jsi_Number nv;\n                astr = Jsi_ValueToString(interp, arr[i+1], NULL);\n                if (Jsi_GetBool(interp, astr, &bv) == JSI_OK) aval = Jsi_ValueNewBoolean(interp, bv);\n                else if (Jsi_GetDouble(interp, astr, &nv) == JSI_OK) aval = Jsi_ValueNewNumber(interp, nv);\n                else if (!Jsi_Strcmp(astr, \"null\"))  aval = Jsi_ValueNewNull(interp);\n                else aval = arr[i+1];\n            }\n            Jsi_ObjInsert(interp, obj, anam, aval, 0);\n        }\n    }\n    \n    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, vargs, n, 0));\n    \n    Jsi_IncrRefCount(interp, cmd);\n    Jsi_IncrRefCount(interp, vpargs);\n    for (i=0; i<n; i++)\n        Jsi_IncrRefCount(interp, vargs[i]);\n    rc = Jsi_FunctionInvoke(interp, cmd, vpargs, ret, NULL);\n    Jsi_DecrRefCount(interp, cmd);\n    for (i=0; i<n; i++)\n        Jsi_DecrRefCount(interp, vargs[i]);\n    Jsi_DecrRefCount(interp, vpargs);\n    if (rc == JSI_OK && !Jsi_ValueIsUndef(interp, *ret) && isMain && funcPtr && funcPtr->callflags.bits.isdiscard) {\n        Jsi_DSSetLength(&dStr, 0);\n        cp = Jsi_ValueGetDString(interp, *ret, &dStr, 0);\n        if (cp && (!(cp=Jsi_Strrchr(cp, '\\n')) || cp[1]))\n            Jsi_DSAppend(&dStr, \"\\n\", NULL);\n        Jsi_Puts(interp, jsi_Stdout, Jsi_DSValue(&dStr), -1);\n    }\n\ndone:\n    Jsi_DSFree(&dStr);\n    Jsi_DSFree(&nStr);\n    return rc;\n}\n\nstatic Jsi_RC SysRunMainCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (jsi_isMain(interp))\n        return SysRunModuleCmd(interp, args, _this, ret, funcPtr);\n    return JSI_OK;\n}\n\nstatic const char *jsi_FindHelpStr(const char *fstr, const char *key, Jsi_DString *dPtr) {\n    if (!fstr) return \"\";\n    Jsi_DSSetLength(dPtr, 0);\n    const char *cp, *ce;\n    int len = Jsi_Strlen(key);\n    while (fstr) {\n        while (isspace(*fstr)) fstr++;\n        cp = fstr;\n        if (!Jsi_Strncmp(cp, key, len) && isspace(cp[-1]) && (cp[len]==':' || isspace(cp[len]))) {\n            ce = NULL;\n            cp = Jsi_Strstr(cp, \"// \");\n            if (cp)\n                ce = Jsi_Strchr(cp, '\\n');\n            if (cp && ce)\n                return Jsi_DSAppendLen(dPtr, cp, ce-cp);\n            fstr = ce;\n        } else {\n            fstr = Jsi_Strchr(cp, '\\n');\n            if (fstr == cp) break;\n        }\n    }\n    return \"\";\n}\n\nstatic bool jsi_ModLogEnabled(Jsi_Interp *interp, Jsi_Value *v1, const char *name) {\n    jsi_Frame *fptr = interp->framePtr;\n    Jsi_Value *v2 = Jsi_ValueObjLookup(interp, v1, name, 0);\n    if (v2 && Jsi_ValueIsTrue(interp, v2)) return true;\n#ifndef JSI_OMIT_INTERP_ENV\n    const char *fname = fptr->funcName;\n    if (!fname) return false;\n    const char *cp;\n    static int isinit = 0;\n    static const char *ce = NULL;\n    if (!isinit) {\n        isinit = 1;\n        ce = getenv(\"JSI_PARSEOPTS\");\n    }\n    if (!ce) return false;\n    int len = Jsi_Strlen(fname);\n    cp = Jsi_Strstr(ce, fname);\n    if (!cp || cp[len]!='=') return false;\n    char buf[JSI_BUFSIZ];\n    snprintf(buf, sizeof(buf), \"%s=%s\", fname, name);\n    return (Jsi_Strstr(ce, buf) != NULL);\n#endif\n    return false;\n}\n\nstatic Jsi_RC SysParseOptsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Value *v1 = Jsi_ValueArrayIndex(interp, args, 0),\n    *v2 = Jsi_ValueArrayIndex(interp, args, 1),\n    *v3 = Jsi_ValueArrayIndex(interp, args, 2);\n    if (!v1 || !Jsi_ValueIsObjType(interp, v1, JSI_OT_OBJECT))\n        return Jsi_LogError(\"arg 1: expected object 'self'\");\n    if (!v2 || !Jsi_ValueIsObjType(interp, v2, JSI_OT_OBJECT))\n        return Jsi_LogError(\"arg 2: expected object 'options'\");\n\n    Jsi_TreeEntry *tPtr, *tPtr2;\n    Jsi_TreeSearch search;\n    for (tPtr = Jsi_TreeSearchFirst(v2->d.obj->tree, &search, 0, NULL);\n        tPtr; tPtr = Jsi_TreeSearchNext(&search)) {\n        Jsi_Value *v = (Jsi_Value*)Jsi_TreeValueGet(tPtr);\n        if (v==NULL) continue;\n        const char *key = (char*)Jsi_TreeKeyGet(tPtr);\n        if (!Jsi_ValueObjLookup(interp, v1, key, 1))\n            Jsi_ObjInsert(interp, v1->d.obj, key, v, 0);\n    }\n    Jsi_TreeSearchDone(&search);\n    Jsi_RC rc = JSI_OK;\n\n    if (!v3 || Jsi_ValueIsNull(interp, v3) || Jsi_ValueIsUndef(interp, v3)) {\n        //return JSI_OK;\n    } else {\n        //bool isArr = Jsi_ValueIsObjType(interp, v3, JSI_OT_ARRAY);\n        if (!Jsi_ValueIsObjType(interp, v3, JSI_OT_OBJECT))\n            return Jsi_LogError(\"arg 3: expected object|null\");\n    \n        Jsi_Value *oVal;\n        int cnt = 0;\n        for (tPtr = Jsi_TreeSearchFirst(v3->d.obj->tree, &search, 0, NULL);\n            tPtr && rc == JSI_OK; tPtr = Jsi_TreeSearchNext(&search)) {\n            Jsi_Value *val;\n            const char *key;\n            cnt++;\n            val = (Jsi_Value*)Jsi_TreeValueGet(tPtr);\n            key = (char*)Jsi_TreeKeyGet(tPtr);\n            if (!val || !key) continue;\n            if (Jsi_ValueIsUndef(interp, val)) {\n                rc = Jsi_LogError(\"value undefined for arg: '%s'\", key);\n                break;\n            }\n\n            if (cnt == 1 && !Jsi_Strcmp(key, \"help\") && v3->d.obj->tree->numEntries==1) {\n                int isLong = 1;//Jsi_ValueIsTrue(interp, val);\n                const char *help = \"\", *es = NULL, *fstr = NULL, *fname = interp->framePtr->ip->fname;\n                Jsi_TreeSearchDone(&search);\n                if (fname) {\n                    jsi_FileInfo  *fi = (typeof(fi))Jsi_HashGet(interp->fileTbl, fname, 0);\n                    fstr = fi->str;\n                }\n                if (!fstr)\n                    fstr = interp->framePtr->ps->lexer->d.str;\n                Jsi_DString dStr = {}, hStr = {}, vStr = {};\n                if (fstr) fstr = Jsi_Strstr(fstr, \"var options = \");\n                if (fstr) fstr = Jsi_Strchr(fstr, '{');\n                if (fstr) es = Jsi_Strchr(fstr, '\\n');\n                if (es) {\n                    help = Jsi_DSAppendLen(&hStr, fstr+1, es-fstr-1);\n                    fstr = es;\n                }\n                const char *mod = (fname?fname:interp->framePtr->fileName);\n                if (mod && (mod = Jsi_Strrchr(mod, '/')))\n                    mod++;\n                while (help && isspace(help[0])) help++;\n                while (help && help[0] == '/') help++;\n                while (help && isspace(help[0])) help++;\n                if (isLong)\n                    Jsi_DSPrintf(&dStr, \"\\n%s.  Options are:\\n\", help);\n                else\n                    Jsi_DSPrintf(&dStr, \"\\n%s.  Options are:\\n    \", help);\n                for (tPtr = Jsi_TreeSearchFirst(v2->d.obj->tree, &search, 0, NULL);\n                    tPtr; tPtr = Jsi_TreeSearchNext(&search)) {\n                    Jsi_Value *v = (Jsi_Value*)Jsi_TreeValueGet(tPtr);\n                    const char *vstr, *key = (char*)Jsi_TreeKeyGet(tPtr);\n                    if (!v || !key) continue;\n                    help = jsi_FindHelpStr(fstr, key, &hStr);\n                    int vlen, klen = Jsi_Strlen(key);\n                    Jsi_DSSetLength(&vStr, 0);\n                    vstr = Jsi_ValueGetDString(interp, v, &vStr, 1);\n                    vlen = Jsi_Strlen(vstr);\n                    if (!isLong)\n                        Jsi_DSPrintf(&dStr, \" -%s\", key);\n                    else\n                        Jsi_DSPrintf(&dStr, \"\\t-%s%s\\t%s\\t%s%s\\n\", key, (klen<7?\"\\t\":\"\"), vstr, (vlen<7?\"\\t\":\"\"), help);\n                }\n                if (isLong)\n                    Jsi_DSAppend(&dStr, \"\\nAccepted by all .jsi modules: -Debug, -Trace, -Test.\", NULL);\n                else\n                    Jsi_DSAppend(&dStr, \"\\nUse -help for long help.\", NULL);\n                rc = JSI_BREAK;\n                Jsi_ValueFromDS(interp, &dStr, ret);\n                Jsi_DSFree(&hStr);\n                Jsi_DSFree(&vStr);\n                break;\n            }\n            Jsi_vtype oTyp, vTyp = jsi_getValType(val);\n            if (!Jsi_Strcmp(key, \"Debug\") || !Jsi_Strcmp(key, \"Test\") || !Jsi_Strcmp(key, \"Trace\")) {\n                oTyp = JSI_VT_BOOL; // Accept these 3 as builtin options.\n                oVal = NULL;\n            } else if (!(tPtr2=Jsi_TreeEntryFind(v2->d.obj->tree, key)) || !(oVal = (Jsi_Value*)Jsi_TreeValueGet(tPtr2))) {\n                Jsi_TreeSearchDone(&search);\n                Jsi_DString dStr = {};\n                int cnt = 0;\n                for (tPtr = Jsi_TreeSearchFirst(v2->d.obj->tree, &search, 0, NULL);\n                    tPtr; tPtr = Jsi_TreeSearchNext(&search)) {\n                    const char *key = (char*)Jsi_TreeKeyGet(tPtr);\n                    if (!key) continue;\n                    cnt++;\n                    Jsi_DSAppend(&dStr, (cnt>1?\", \":\"\"), key, NULL);\n                }\n                Jsi_LogType(\"\\nUnknown option: \\\"%s\\\" is not one of:\\n  %s\\n\\n\", key, Jsi_DSValue(&dStr));\n                rc = JSI_BREAK;\n                Jsi_DSFree(&dStr);\n                break;\n            } else {\n                oTyp = jsi_getValType(oVal);\n            }\n            switch (oTyp) {\n                case JSI_VT_UNDEF:\n                case JSI_VT_NULL:\n                    break;\n                default:\n                    if (oTyp != vTyp) {\n                        rc = Jsi_LogError(\"type mismatch for '%s': '%s' is not a %s\",\n                            key, jsi_ValueTypeName(interp, val), (oVal?jsi_ValueTypeName(interp, oVal):\"boolean\"));\n                    }\n            }\n            if (rc == JSI_OK)\n                Jsi_ObjInsert(interp, v1->d.obj, key, val, 0);\n        }\n        Jsi_TreeSearchDone(&search);\n    }\n    if (rc == JSI_OK) {\n        jsi_Frame *fptr = interp->framePtr;\n        Jsi_Func *pf = interp->prevActiveFunc;\n        Jsi_ModuleConf *mo = NULL;\n        if (pf && pf->pkg)\n            mo = &pf->pkg->popts.modConf;\n        if (jsi_ModLogEnabled(interp, v1, \"Debug\") || (mo && mo->Debug)) {\n            jsi_evalStrFile(interp, NULL, \"this.LogDebug = console.log.bind(null, 'DEBUG:');\", 0, fptr->level);\n            fptr->logflag |= (1<<jsi_Oplf_debug);\n        }\n        if (jsi_ModLogEnabled(interp, v1, \"Trace\") || (mo && mo->Trace)) {\n            jsi_evalStrFile(interp, NULL, \"this.LogTrace = console.log.bind(null, 'TRACE:');\", 0, fptr->level);\n            fptr->logflag |= (1<<jsi_Oplf_trace);\n        }\n        if (jsi_ModLogEnabled(interp, v1, \"Test\") || (mo && mo->Test)) {\n            jsi_evalStrFile(interp, NULL, \"this.LogTest = console.log.bind(null, 'TEST: ');\", 0, fptr->level);\n            fptr->logflag |= (1<<jsi_Oplf_test);\n        }\n    }\n    return rc;\n}\n\nstatic Jsi_CmdSpec consoleCmds[] = {\n    { \"assert\", jsi_AssertCmd,      1,  3, \"expr:boolean|number|function, msg:string=void, options:object=void\",  .help=\"Same as System.assert()\", .retType=(uint)JSI_TT_VOID, .flags=0, .info=0, .opts=AssertOptions},\n    { \"error\",  consoleLogCmd,      1, -1, \"val, ...\", .help=\"Same as log\", .retType=(uint)JSI_TT_VOID, .flags=0 },\n    { \"input\",  consoleInputCmd,    0,  0, \"\", .help=\"Read input from the console\", .retType=(uint)JSI_TT_STRING|JSI_TT_VOID },\n    { \"log\",    consoleLogCmd,      1, -1, \"val, ...\", .help=\"Same as System.puts, but goes to stderr and includes file:line\", .retType=(uint)JSI_TT_VOID, .flags=0 },\n    { \"printf\", consolePrintfCmd,   1, -1, \"format:string, ...\", .help=\"Same as System.printf but goes to stderr\", .retType=(uint)JSI_TT_VOID, .flags=0 },\n    { \"puts\",   consolePutsCmd,     1, -1, \"val, ...\", .help=\"Same as System.puts, but goes to stderr\", .retType=(uint)JSI_TT_VOID, .flags=0 },\n    { \"warn\",   consoleLogCmd,      1, -1, \"val, ...\", .help=\"Same as log\", .retType=(uint)JSI_TT_VOID, .flags=0 },\n    { NULL, 0,0,0,0,  .help=\"Console input and output to stderr\" }\n};\n\n#ifndef JSI_OMIT_EVENT\nstatic Jsi_CmdSpec eventCmds[] = {\n    { \"clearInterval\",clearIntervalCmd, 1,  1, \"id:number\", .help=\"Delete an event (created with setInterval/setTimeout)\", .retType=(uint)JSI_TT_VOID },\n    { \"info\",       eventInfoCmd,       1,  1, \"id:number\", .help=\"Return info for the given event id\", .retType=(uint)JSI_TT_OBJECT },\n    { \"names\",      eventInfoCmd,       0,  0, \"\", .help=\"Return list event ids (created with setTimeout/setInterval)\", .retType=(uint)JSI_TT_ARRAY },\n    { \"setInterval\",setIntervalCmd,     2,  2, \"callback:function, millisecs:number\", .help=\"Setup recurring function to run every given millisecs\", .retType=(uint)JSI_TT_NUMBER },\n    { \"setTimeout\", setTimeoutCmd,      2,  2, \"callback:function, millisecs:number\", .help=\"Setup function to run after given millisecs\", .retType=(uint)JSI_TT_NUMBER },\n    { \"update\",     SysUpdateCmd,       0,  1, \"options:number|object=void\", .help=\"Service all events, eg. setInterval/setTimeout\", .retType=(uint)JSI_TT_NUMBER, .flags=0, .info=FN_update, .opts=jsiUpdateOptions },\n    { NULL, 0,0,0,0,  .help=\"Event management\" }\n};\n#endif\n\n#ifndef JSI_OMIT_DEBUG\nstatic Jsi_CmdSpec debugCmds[] = {\n    { \"add\",        DebugAddCmd,    1,  2, \"val:string|number, temp:boolean=false\", .help=\"Add a breakpoint for line, file:line or func\", .retType=(uint)JSI_TT_NUMBER },\n    { \"remove\",     DebugRemoveCmd, 1,  1, \"id:number\", .help=\"Remove breakpoint\", .retType=(uint)JSI_TT_VOID },\n    { \"enable\",     DebugEnableCmd, 2,  2, \"id:number, on:boolean\", .help=\"Enable/disable breakpoint\", .retType=(uint)JSI_TT_VOID },\n    { \"info\",       DebugInfoCmd,   0,  1, \"id:number=void\", .help=\"Return info about one breakpoint, or list of bp numbers\", .retType=(uint)JSI_TT_OBJECT|JSI_TT_ARRAY },\n    { NULL, 0,0,0,0,  .help=\"Debugger breakpoint management\" }\n};\n#endif\n\nstatic Jsi_CmdSpec infoCmds[] = {\n    { \"argv0\",      InfoArgv0Cmd,       0,  0, \"\", .help=\"Return initial start script file name\", .retType=(uint)JSI_TT_STRING|JSI_TT_VOID },\n    { \"cmds\",       InfoCmdsCmd,        0,  2, \"val:string|regexp='*', options:object=void\", .help=\"Return details or list of matching commands\", .retType=(uint)JSI_TT_ARRAY|JSI_TT_OBJECT, .flags=0, .info=0, .opts=InfoCmdsOptions },\n    { \"completions\",InfoCompletionsCmd, 1,  3, \"str:string, start:number=0, end:number=void\", .help=\"Return command completions on portion of string from start to end\", .retType=(uint)JSI_TT_ARRAY },\n    { \"data\",       InfoDataCmd,        0,  1, \"val:string|regexp|object=void\", .help=\"Return list of matching data (non-functions)\", .retType=(uint)JSI_TT_ARRAY|JSI_TT_OBJECT, .flags=0, .info=FN_infodata },\n    { \"error\",      InfoErrorCmd,       0,  0, \"\", .help=\"Return file and line number of error (used inside catch)\", .retType=(uint)JSI_TT_OBJECT },\n#ifndef JSI_OMIT_EVENT\n    { \"event\",      InfoEventCmd,       0,  1, \"id:number=void\", .help=\"List events or info for 1 event (setTimeout/setInterval)\", .retType=(uint)JSI_TT_ARRAY|JSI_TT_OBJECT, .flags=0, .info=FN_infoevent },\n#endif\n    { \"executable\", InfoExecutableCmd,  0,  0, \"\", .help=\"Return name of executable\", .retType=(uint)JSI_TT_STRING },\n    { \"execZip\",    InfoExecZipCmd,     0,  0, \"\", .help=\"If executing a .zip file, return file name\", .retType=(uint)JSI_TT_STRING|JSI_TT_VOID },\n    { \"files\",      InfoFilesCmd,       0,  0, \"\", .help=\"Return list of all sourced files\", .retType=(uint)JSI_TT_ARRAY },\n    { \"funcs\",      InfoFuncsCmd,       0,  1, \"string|regexp|object=void\", .help=\"Return details or list of matching functions\", .retType=(uint)JSI_TT_ARRAY|JSI_TT_OBJECT },\n    { \"locals\",     InfoLocalsCmd,      0,  1, \"filter:boolean=void\", .help=\"Return locals; use filter=true/false just vars/functions\", .retType=(uint)JSI_TT_OBJECT },\n    { \"interp\",     jsi_InterpInfo,     0,  1, \"interp:userobj=void\", .help=\"Return info on given or current interp\", .retType=(uint)JSI_TT_OBJECT },\n    { \"isMain\",     InfoIsMainCmd,      0,  0, \"\", .help=\"Return true if current script was the main script invoked from command-line\", .retType=(uint)JSI_TT_BOOLEAN },\n    { \"keywords\",   InfoKeywordsCmd,    0,  2, \"isSql=false, name:string=void\", .help=\"Return/lookup reserved keyword\", .retType=(uint)JSI_TT_ARRAY|JSI_TT_BOOLEAN },\n    { \"level\",      InfoLevelCmd,       0,  1, \"level:number=void\", .help=\"Return current level or details of a call-stack frame\", .retType=(uint)JSI_TT_ARRAY|JSI_TT_OBJECT|JSI_TT_NUMBER, .flags=0, .info=FN_infolevel },\n    { \"lookup\",     InfoLookupCmd,      1,  1, \"name:string\", .help=\"Given string name, lookup and return value, eg: function\", .retType=(uint)JSI_TT_ANY },\n    { \"methods\",    InfoMethodsCmd,     1,  1, \"val:string|regexp\", .help=\"Return functions and commands\", .retType=(uint)JSI_TT_ARRAY|JSI_TT_OBJECT },\n    { \"named\",      InfoNamedCmd,       0,  1, \"name:string=void\", .help=\"Returns command names for builtin Objects, eg: 'File', 'Interp', sub-Object names, or the named object\", .retType=(uint)JSI_TT_ARRAY|JSI_TT_USEROBJ },\n    { \"options\",    InfoOptionsCmd,     0,  1, \"ctype:boolean=false\", .help=\"Return Option type name, or with true the C type\", .retType=(uint)JSI_TT_ARRAY },\n    { \"package\",    InfoPackageCmd,     1,  1, \"pkgName:string\", .help=\"Return info about provided package if exists, else null\", .retType=(uint)JSI_TT_OBJECT|JSI_TT_NULL },\n    { \"platform\",   InfoPlatformCmd,    0,  0, \"\", .help=\"N/A. Returns general platform information for JSI\", .retType=(uint)JSI_TT_OBJECT  },\n    { \"script\",     InfoScriptCmd,      0,  1, \"func:function|regexp=void\", .help=\"Get current script file name, or file containing function\", .retType=(uint)JSI_TT_STRING|JSI_TT_ARRAY|JSI_TT_VOID },\n    { \"scriptDir\",  InfoScriptDirCmd,   0,  0, \"\", .help=\"Get directory of current script\", .retType=(uint)JSI_TT_STRING|JSI_TT_VOID },\n    { \"vars\",       InfoVarsCmd,        0,  1, \"val:string|regexp|object=void\", .help=\"Return details or list of matching variables\", .retType=(uint)JSI_TT_ARRAY|JSI_TT_OBJECT, .flags=0, .info=FN_infovars },\n    { \"version\",    InfoVersionCmd,     0,  1, \"full:boolean=false\", .help=\"JSI version: returns object when full=true\", .retType=(uint)JSI_TT_NUMBER|JSI_TT_OBJECT  },\n    { NULL, 0,0,0,0, .help=\"Commands for inspecting internal state information in JSI\"  }\n};\nstatic Jsi_RC SysSqlValuesCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                         Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    const char *name = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    if (!name) return Jsi_LogError(\"expected name\");\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 1);\n    if (!arg)\n        arg = Jsi_VarLookup(interp, name);\n    if (!arg || !Jsi_ValueIsObjType(interp, arg, JSI_OT_OBJECT))\n        return Jsi_LogError(\"expected object 'values'\");\n    Jsi_DString dStr = {};\n    Jsi_DSAppend(&dStr, \"(\", NULL);\n    Jsi_IterObj *io = Jsi_IterObjNew(interp, NULL);\n    Jsi_IterGetKeys(interp, arg, io, 0);\n    uint i;\n    const char *pre = \"\";\n    for (i=0; i<io->count; i++) {\n        Jsi_DSAppend(&dStr, pre, io->keys[i], NULL);\n        pre = \",\";\n    }\n    pre = \"\";\n    Jsi_DSAppend(&dStr, \") VALUES(\", NULL);\n    for (i=0; i<io->count; i++) {\n        Jsi_DSAppend(&dStr, pre, \"$\", name, \"(\", io->keys[i], \")\", NULL);\n        pre = \",\";\n    }\n    Jsi_IterObjFree(io);\n\n    Jsi_DSAppend(&dStr, \")\", NULL);\n    Jsi_ValueFromDS(interp, &dStr, ret);\n    return JSI_OK;\n}\n\nstatic Jsi_CmdSpec utilCmds[] = {\n#ifndef JSI_OMIT_BASE64\n    { \"argArray\",   SysArgArrayCmd,  1,  1, \"arg:any|undefined\", .help=\"Coerces non-null to an array, if necessary\", .retType=(uint)JSI_TT_ARRAY|JSI_TT_NULL },\n    { \"complete\",   SysCompleteCmd,  1,  1, \"val:string\",.help=\"Return true if string is complete command with balanced braces, etc\", .retType=(uint)JSI_TT_BOOLEAN },\n    { \"base64\",     SysBase64Cmd,    1,  2, \"val:string, decode:boolean=false\",.help=\"Base64 encode/decode a string\", .retType=(uint)JSI_TT_STRING },\n    { \"hexStr\",     SysHexStrCmd,    1,  2, \"val:string, decode:boolean=false\",.help=\"Hex encode/decode a string\", .retType=(uint)JSI_TT_STRING },\n#endif\n    { \"crc32\",      SysCrc32Cmd,     1,  2, \"val:string, crcSeed=0\",.help=\"Calculate 32-bit CRC\", .retType=(uint)JSI_TT_NUMBER },\n#ifndef JSI_OMIT_ENCRYPT\n    { \"decrypt\",    SysDecryptCmd,   2,  2, \"val:string, key:string\", .help=\"Decrypt data using BTEA encryption\", .retType=(uint)JSI_TT_STRING, .flags=0, .info=FN_encrypt },\n    { \"encrypt\",    SysEncryptCmd,   2,  2, \"val:string, key:string\", .help=\"Encrypt data using BTEA encryption\", .retType=(uint)JSI_TT_STRING, .flags=0, .info=FN_encrypt },\n#endif\n    { \"fromCharCode\",SysFromCharCodeCmd, 1, 1, \"code:number\", .help=\"Return char with given character code\", .retType=(uint)JSI_TT_STRING, .flags=JSI_CMDSPEC_NONTHIS},\n    { \"getenv\",     SysGetEnvCmd,    0,  1, \"name:string=void\", .help=\"Get one or all environment\", .retType=(uint)JSI_TT_STRING|JSI_TT_OBJECT|JSI_TT_VOID  },\n    { \"getpid\",     SysGetPidCmd,    0,  1, \"parent:boolean=false\", .help=\"Get process/parent id\", .retType=(uint)JSI_TT_NUMBER },\n    { \"getuser\",    SysGetUserCmd,   0,  0, \"\", .help=\"Get userid info\", .retType=(uint)JSI_TT_OBJECT },\n    { \"hash\",       SysHashCmd,      1,  2, \"val:string, options|object=void\", .help=\"Return hash (default SHA256) of string/file\", .retType=(uint)JSI_TT_STRING, .flags=0, .info=0, .opts=HashOptions},\n    { \"setenv\",     SysSetEnvCmd,    1,  2, \"name:string, value:string=void\", .help=\"Set/get an environment var\"  },\n    { \"sqlValues\",  SysSqlValuesCmd, 1,  2, \"name:string, var:object=void\", .help=\"Get object values for SQL\"  },\n    { \"times\",      SysTimesCmd,     1,  2, \"callback:function|boolean, count:number=1\", .help=\"Call function count times and return execution time in microseconds\", .retType=(uint)JSI_TT_NUMBER },\n    { \"verConvert\", SysVerConvertCmd,1,  2, \"ver:string|number, zeroTrim:number=0\", .help=\"Convert a version to/from a string/number, or return null if not a version. For string output zeroTrim says how many trailing .0 to trim (0-2)\", .retType=(uint)JSI_TT_NUMBER|JSI_TT_STRING|JSI_TT_NULL },\n    { NULL, 0,0,0,0, .help=\"Utilities commands\"  }\n};\n\nstatic Jsi_CmdSpec sysCmds[] = {\n    { \"assert\", jsi_AssertCmd,       1,  3, \"expr:boolean|number|function, msg:string=void, options:object=void\",  .help=\"Throw or output msg if expr is false\", .retType=(uint)JSI_TT_VOID, .flags=0, .info=FN_assert, .opts=AssertOptions },\n#ifndef JSI_OMIT_EVENT\n    { \"clearInterval\",clearIntervalCmd,1,1, \"id:number\", .help=\"Delete event id returned from setInterval/setTimeout/info.events()\", .retType=(uint)JSI_TT_VOID },\n#endif\n    { \"decodeURI\",  DecodeURICmd,    1,  1, \"val:string\", .help=\"Decode an HTTP URL\", .retType=(uint)JSI_TT_STRING },\n    { \"encodeURI\",  EncodeURICmd,    1,  1, \"val:string\", .help=\"Encode an HTTP URL\", .retType=(uint)JSI_TT_STRING },\n    { \"exec\",       SysExecCmd,      1,  2, \"val:string, options:string|object=void\", .help=\"Execute an OS command\", .retType=(uint)JSI_TT_ANY, .flags=0, .info=FN_exec, .opts=ExecOptions},\n    { \"exit\",       SysExitCmd,      0,  1, \"code:number=0\", .help=\"Exit the current interpreter\", .retType=(uint)JSI_TT_VOID },\n    { \"format\",     SysFormatCmd,    1, -1, \"format:string, ...\", .help=\"Printf style formatting: adds %q and %S\", .retType=(uint)JSI_TT_STRING },\n    { \"isFinite\",   isFiniteCmd,     1,  1, \"val\", .help=\"Return true if is a finite number\", .retType=(uint)JSI_TT_BOOLEAN },\n    { \"isMain\",     InfoIsMainCmd,   0,  0, \"\", .help=\"Return true if current script was the main script invoked from command-line\", .retType=(uint)JSI_TT_BOOLEAN },\n    { \"isNaN\",      isNaNCmd,        1,  1, \"val\", .help=\"Return true if not a number\", .retType=(uint)JSI_TT_BOOLEAN },\n#ifndef JSI_OMIT_LOAD\n    { \"load\",       jsi_LoadLoadCmd, 1,  1, \"shlib:string\", .help=\"Load a shared executable and invoke its _Init call\", .retType=(uint)JSI_TT_VOID },\n#endif\n    { \"log\",        SysLogCmd,       1, -1, \"val, ...\", .help=\"Same as puts, but includes file:line\", .retType=(uint)JSI_TT_VOID, .flags=0 },\n    { \"matchObj\",   SysMatchObjCmd,  1,  4, \"obj:object, match:string=void, partial=false, noerror=false\", .help=\"Object field names/types matching. Single arg generates string\", .retType=(uint)JSI_TT_BOOLEAN|JSI_TT_STRING },\n    { \"noOp\",       jsi_NoOpCmd,     0, -1, \"\", .help=\"A No-Op. A zero overhead command call that is useful for debugging\" },\n    { \"parseInt\",   parseIntCmd,     1,  2, \"val:any, base:number=10\", .help=\"Convert string to an integer\", .retType=(uint)JSI_TT_NUMBER },\n    { \"parseFloat\", parseFloatCmd,   1,  1, \"val\", .help=\"Convert string to a double\", .retType=(uint)JSI_TT_NUMBER },\n    { \"parseOpts\",  SysParseOptsCmd, 2,  3, \"self:object|userobj, options:object, conf:object|null|undefined\", .help=\"Parse options\", .retType=(uint)JSI_TT_ANY, .flags=0},\n    { \"printf\",     SysPrintfCmd,    1, -1, \"format:string, ...\", .help=\"Formatted output to stdout\", .retType=(uint)JSI_TT_VOID, .flags=0 },\n    { \"provide\",    SysProvideCmd,   0,  3, \"name:string|function=void, version:number|string=1.0, opts:object|function=void\", .help=\"Provide a package for use with require. Default is the file tail-rootname\", .retType=(uint)JSI_TT_VOID },\n    { \"puts\",       SysPutsCmd,      1, -1, \"val, ...\", .help=\"Output one or more values to stdout\", .retType=(uint)JSI_TT_VOID, .flags=0, .info=FN_puts },\n    { \"quote\",      SysQuoteCmd,     1,  1, \"val:string\", .help=\"Return quoted string\", .retType=(uint)JSI_TT_STRING },\n    { \"require\",    SysRequireCmd,   0,  3, \"name:string=void, version:number|string=1, options:object=void\", .help=\"Load/query packages\", .retType=(uint)JSI_TT_NUMBER|JSI_TT_OBJECT|JSI_TT_ARRAY, .flags=0, .info=FN_require, .opts=jsiModuleOptions },\n    { \"runMain\",    SysRunMainCmd,   0,  2, \"cmd:string|null|function=void, conf:array=undefined\", .help=\"If isMain invokes runModule\", .retType=(uint)JSI_TT_ANY, .flags=0},\n    { \"runModule\",  SysRunModuleCmd, 0,  2, \"cmd:string|null|function=void, conf:array=undefined\", .help=\"Invoke named module. If name is empty, uses file basename. If isMain and no args givine parses console.args\", .retType=(uint)JSI_TT_ANY, .flags=0},\n    { \"sleep\",      SysSleepCmd,     0,  1, \"secs:number=1.0\",  .help=\"sleep for N milliseconds, minimum .001\", .retType=(uint)JSI_TT_VOID },\n#ifndef JSI_OMIT_EVENT\n    { \"setInterval\",setIntervalCmd,  2,  2, \"callback:function, ms:number\", .help=\"Setup recurring function to run every given millisecs\", .retType=(uint)JSI_TT_NUMBER },\n    { \"setTimeout\", setTimeoutCmd,   2,  2, \"callback:function, ms:number\", .help=\"Setup function to run after given millisecs\", .retType=(uint)JSI_TT_NUMBER },\n#endif\n    { \"source\",     SysSourceCmd,    1,  2, \"val:string|array, options:object=void\",  .help=\"Load and evaluate source files: trailing '/' appends PARENTDIR.jsi\", .retType=(uint)JSI_TT_ANY, .flags=0, .info=0, .opts=SourceOptions},\n    { \"strftime\",   DateStrftimeCmd, 0,  2, \"num:number=null, options:string|object=void\",  .help=\"Format numeric time (in ms) to a string\", .retType=(uint)JSI_TT_STRING, .flags=0, .info=FN_strftime, .opts=DateOptions },\n    { \"strptime\",   DateStrptimeCmd, 0,  2, \"val:string=void, options:string|object=void\",  .help=\"Parse time from string and return ms time since 1970-01-01 in UTC, or NaN\", .retType=(uint)JSI_TT_NUMBER, .flags=0, .info=0, .opts=DateOptions },\n    { \"times\",      SysTimesCmd,     1,  2, \"callback:function|boolean, count:number=1\", .help=\"Call function count times and return execution time in microseconds\", .retType=(uint)JSI_TT_NUMBER },\n#ifndef JSI_OMIT_LOAD\n    { \"unload\",     jsi_LoadUnloadCmd,1, 1,  \"shlib:string\", .help=\"Unload a shared executable and invoke its _Done call\", .retType=(uint)JSI_TT_VOID },\n#endif\n#ifndef JSI_OMIT_EVENT\n    { \"update\",     SysUpdateCmd,    0,  1, \"options:number|object=void\", .help=\"Service all events, eg. setInterval/setTimeout\", .retType=(uint)JSI_TT_NUMBER, .flags=0, .info=FN_update, .opts=jsiUpdateOptions },\n#endif\n    { NULL, 0,0,0,0, .help=\"Builtin system commands. All methods are exported as global\" }\n};\n\nJsi_RC jsi_InitCmds(Jsi_Interp *interp, int release)\n{\n    if (release) return JSI_OK;\n    interp->console = Jsi_CommandCreateSpecs(interp, \"console\", consoleCmds, NULL, 0);\n    Jsi_IncrRefCount(interp, interp->console);\n    Jsi_ValueInsertFixed(interp, interp->console, \"args\", interp->args);\n        \n    Jsi_CommandCreateSpecs(interp, \"\",       sysCmds,    NULL, 0);\n    Jsi_CommandCreateSpecs(interp, \"System\", sysCmds,    NULL, 0);\n    Jsi_CommandCreateSpecs(interp, \"Info\",   infoCmds,   NULL, 0);\n    Jsi_CommandCreateSpecs(interp, \"Util\",   utilCmds,   NULL, 0);\n#ifndef JSI_OMIT_EVENT\n    Jsi_CommandCreateSpecs(interp, \"Event\",  eventCmds,  NULL, 0);\n#endif\n#ifndef JSI_OMIT_DEBUG\n    Jsi_CommandCreateSpecs(interp, \"Debugger\",  debugCmds,  NULL, 0);\n#endif\n    return JSI_OK;\n}\n#endif\n", "#ifndef JSI_LITE_ONLY\n#ifndef _JSI_CODE_C_\n#define _JSI_CODE_C_\n#ifndef JSI_AMALGAMATION\n#include \"jsiInt.h\"\n#endif\n\n/* replace continue/break(coded as OP_RESERVED) jmp\n * |------------------| \\\n * |                  | \\\\ where 'continue' jmp (jmp to step code)\n * |       ops        |  / \n * |                  | / \\\n * |------------------|    \\ where 'break' jmp (jmp after step code)\n * |                  |    /\n * |       step       |   /\n * |                  |  /\n * |------------------| /\n * 1. break_only used only in switch\n * 2. desire_label, only replace if current iter statement has the same label with opcode\n * 3. topop, if not replace in current iter statment, make sure when jmp out of this loop/switch\n *    corrent stack elems poped(for in always has 2 elem, while switch has 1)\n */\n\nstatic const char *jsi_op_names[OP_LASTOP] = {\n    \"NOP\",\n    \"PUSHNUM\",\n    \"PUSHSTR\",\n    \"PUSHVSTR\",\n    \"PUSHVAR\",\n    \"PUSHUND\",\n    \"PUSHNULL\",\n    \"PUSHBOO\",\n    \"PUSHFUN\",\n    \"PUSHREG\",\n    \"PUSHARG\",\n    \"PUSHTHS\",\n    \"PUSHTOP\",\n    \"PUSHTOP2\",\n    \"UNREF\",\n    \"POP\",\n    \"LOCAL\",\n    \"NEG\",\n    \"POS\",\n    \"NOT\",\n    \"BNOT\",\n    \"ADD\",\n    \"SUB\",\n    \"MUL\",\n    \"DIV\",\n    \"MOD\",\n    \"LESS\",\n    \"GREATER\",\n    \"LESSEQU\",\n    \"GREATEREQU\",\n    \"EQUAL\",\n    \"NOTEQUAL\",\n    \"STRICTEQU\",\n    \"STRICTNEQ\",\n    \"BAND\",\n    \"BOR\",\n    \"BXOR\",\n    \"SHF\",\n    \"INSTANCEOF\",\n    \"ASSIGN\",\n    \"SUBSCRIPT\",\n    \"INC\",\n    \"TYPEOF\",\n    \"IN\",\n    \"DEC\",\n    \"KEY\",\n    \"NEXT\",\n    \"JTRUE\",\n    \"JFALSE\",\n    \"JTRUE_NP\",\n    \"JFALSE_NP\",\n    \"JMP\",\n    \"JMPPOP\",\n    \"FCALL\",\n    \"NEWFCALL\",\n    \"RET\",\n    \"DELETE\",\n    \"CHTHIS\",\n    \"OBJECT\",\n    \"ARRAY\",\n    \"EVAL\",\n    \"STRY\",\n    \"ETRY\",\n    \"SCATCH\",\n    \"ECATCH\",\n    \"SFINAL\",\n    \"EFINAL\",\n    \"THROW\",\n    \"WITH\",\n    \"EWITH\",\n    \"RESERVED\",\n    \"DEBUG\"\n};\n\nstatic int jsiOpCodesCnt[3] = {0,0,0};\n\nvoid jsi_FreeOpcodes(Jsi_OpCodes *ops) {\n    int i;\n    if (!ops) return;\n    for (i=0; i<ops->code_len; i++) {\n        jsi_OpCode *op = ops->codes+i;\n        if (op->data && op->alloc)\n            Jsi_Free(op->data);\n        _JSI_MEMCLEAR(op);\n    }\n    jsiOpCodesCnt[1]++;\n    jsiOpCodesCnt[2]--;\n#ifdef JSI_MEM_DEBUG\n    if (ops->hPtr)\n        Jsi_HashEntryDelete(ops->hPtr);\n#endif\n    Jsi_Free(ops->codes);\n    Jsi_Free(ops);\n}\n\nstatic Jsi_OpCodes *codes_new(int size)\n{\n    Jsi_OpCodes *ops = (Jsi_OpCodes *)Jsi_Calloc(1, sizeof(*ops));\n    jsiOpCodesCnt[0]++;\n    jsiOpCodesCnt[2]++;\n    ops->codes = (jsi_OpCode *)Jsi_Calloc(size, sizeof(jsi_OpCode));\n    ops->code_size = size;\n#ifdef JSI_MEM_DEBUG\n    static int idNum = 0;\n    ops->hPtr = Jsi_HashSet(jsiIntData.mainInterp->codesTbl, ops, ops);\n    ops->id = idNum++;\n#endif\n    return ops;\n}\n\nstatic int codes_insert(Jsi_OpCodes *c, jsi_Eopcode code, void *extra, int doalloc)\n{\n    if (c->code_size - c->code_len <= 0) {\n        c->code_size += 100;\n        c->codes = (jsi_OpCode *)Jsi_Realloc(c->codes, c->code_size * sizeof(jsi_OpCode));\n    }\n    c->codes[c->code_len].op = code;\n    c->codes[c->code_len].data = extra;\n    c->codes[c->code_len].alloc = doalloc;\n    c->code_len ++;\n    return 0;\n}\n\nstatic int codes_insertln(Jsi_OpCodes *c, jsi_Eopcode code, void *extra, jsi_Pstate *pstate, jsi_Pline *line, int doalloc)\n{\n    if (c->code_size - c->code_len <= 0) {\n        c->code_size += 100;\n        c->codes = (jsi_OpCode *)Jsi_Realloc(c->codes, c->code_size * sizeof(jsi_OpCode));\n    }\n    c->codes[c->code_len].op = code;\n    c->codes[c->code_len].data = extra;\n    c->codes[c->code_len].Line = line->first_line;\n    c->codes[c->code_len].Lofs = line->first_column;\n    c->codes[c->code_len].fname = jsi_PstateGetFilename(pstate);\n    c->codes[c->code_len].alloc = doalloc;\n    c->code_len ++;\n    return 0;\n}\n\n\nstatic Jsi_OpCodes *codes_join(Jsi_OpCodes *a, Jsi_OpCodes *b)\n{\n    Jsi_OpCodes *ret = codes_new(a->code_len + b->code_len);\n    memcpy(ret->codes, a->codes, a->code_len * sizeof(jsi_OpCode));\n    memcpy(&ret->codes[a->code_len], b->codes, b->code_len * sizeof(jsi_OpCode));\n    ret->code_size = a->code_len + b->code_len;\n    ret->code_len = ret->code_size;\n    ret->expr_counter = a->expr_counter + b->expr_counter;\n#if 0\n    a->code_len=0;\n    jsi_FreeOpcodes(a);\n    b->code_len=0;\n    jsi_FreeOpcodes(b);\n#else\n    Jsi_Free(a->codes);\n    Jsi_Free(b->codes);\n#ifdef JSI_MEM_DEBUG\n    if (a->hPtr)\n        Jsi_HashEntryDelete(a->hPtr);\n    if (b->hPtr)\n        Jsi_HashEntryDelete(b->hPtr);\n#endif\n    Jsi_Free(a);\n    Jsi_Free(b);\n#endif\n    jsiOpCodesCnt[1]++;\n    jsiOpCodesCnt[2]-=2;\n    return ret;\n}\n\nstatic Jsi_OpCodes *codes_join3(Jsi_OpCodes *a, Jsi_OpCodes *b, Jsi_OpCodes *c)\n{\n    return codes_join(codes_join(a, b), c);\n}\n\nstatic Jsi_OpCodes *codes_join4(Jsi_OpCodes *a, Jsi_OpCodes *b, Jsi_OpCodes *c, Jsi_OpCodes *d)\n{\n    return codes_join(codes_join(a, b), codes_join(c, d));\n}\n\n#define JSI_NEW_CODES(doalloc,code, extra) do {                 \\\n        Jsi_OpCodes *r = codes_new(3);                  \\\n        codes_insert(r, (code), (void *)(uintptr_t)(extra), doalloc);   \\\n        return r;                                   \\\n    } while(0)\n\n#define JSI_NEW_CODESLN(doalloc,code, extra) do {                 \\\n        Jsi_OpCodes *r = codes_new(3);                  \\\n        codes_insertln(r, (code), (void *)(uintptr_t)(extra), p, line, doalloc);   \\\n        return r;                                   \\\n    } while(0)\n\nstatic Jsi_OpCodes *code_push_undef() { JSI_NEW_CODES(0,OP_PUSHUND, 0); }\nstatic Jsi_OpCodes *code_push_null() { JSI_NEW_CODES(0,OP_PUSHNULL, 0); }\nstatic Jsi_OpCodes *code_push_bool(int v) { JSI_NEW_CODES(0,OP_PUSHBOO, v); }\nstatic Jsi_OpCodes *code_push_num(Jsi_Number *v) { JSI_NEW_CODES(1,OP_PUSHNUM, v); }\nstatic Jsi_OpCodes *code_push_string(jsi_Pstate *p, jsi_Pline *line, const char *str) {\n    if (*str == 'c' && !Jsi_Strcmp(str,\"callee\"))\n        p->interp->hasCallee = 1;\n    JSI_NEW_CODESLN(0,OP_PUSHSTR, str);\n}\n\nstatic Jsi_OpCodes *code_push_vstring(jsi_Pstate *p, jsi_Pline *line, Jsi_String *s) {\n    JSI_NEW_CODESLN(0,OP_PUSHVSTR, s);\n}\n\nstatic Jsi_OpCodes *code_push_index(jsi_Pstate *p, jsi_Pline *line, const char *varname, int local)\n{\n    jsi_FastVar *n = (typeof(n))Jsi_Calloc(1, sizeof(*n));\n    n->sig = JSI_SIG_FASTVAR;\n    n->ps = p;\n    n->context_id = -1;\n    n->local = local;\n    n->varname = (char*)Jsi_KeyAdd(p->interp, varname);\n    Jsi_HashSet(p->fastVarTbl, n, n);\n    JSI_NEW_CODESLN(1,OP_PUSHVAR, n);\n}\n\nstatic Jsi_OpCodes *code_push_this(jsi_Pstate *p, jsi_Pline *line) { JSI_NEW_CODESLN(0,OP_PUSHTHS, 0); }\nstatic Jsi_OpCodes *code_push_top() { JSI_NEW_CODES(0,OP_PUSHTOP, 0); }\nstatic Jsi_OpCodes *code_push_top2() { JSI_NEW_CODES(0,OP_PUSHTOP2, 0); }\nstatic Jsi_OpCodes *code_unref() { JSI_NEW_CODES(0,OP_UNREF, 0); }\nstatic Jsi_OpCodes *code_push_args() { JSI_NEW_CODES(0,OP_PUSHARG, 0); }\nstatic Jsi_OpCodes *code_push_func_sub(jsi_Pstate *p, jsi_Pline *line, Jsi_Func *fun) { p->funcDefs++; JSI_NEW_CODESLN(0,OP_PUSHFUN, fun); }\nstatic Jsi_OpCodes *code_push_func(jsi_Pstate *p, jsi_Pline *line, Jsi_Func *fun) {\n    Jsi_OpCodes* codes = code_push_func_sub(p, line, fun);\n    if (codes && fun && fun->name)\n        codes->codes[0].local = 1;\n    return codes;\n}\nstatic Jsi_OpCodes *code_push_regex(jsi_Pstate *p, jsi_Pline *line, Jsi_Regex *reg) { JSI_NEW_CODESLN(0,OP_PUSHREG, reg); }\n\nstatic Jsi_OpCodes *code_local(jsi_Pstate *p, jsi_Pline *line, const char *varname) { JSI_NEW_CODESLN(0,OP_LOCAL, varname); }\n\nstatic Jsi_OpCodes *code_nop() { JSI_NEW_CODES(0,OP_NOP, 0); }\nstatic Jsi_OpCodes *code_neg() { JSI_NEW_CODES(0,OP_NEG, 0); }\nstatic Jsi_OpCodes *code_pos() { JSI_NEW_CODES(0,OP_POS, 0); }\nstatic Jsi_OpCodes *code_bnot() { JSI_NEW_CODES(0,OP_BNOT, 0); }\nstatic Jsi_OpCodes *code_not() { JSI_NEW_CODES(0,OP_NOT, 0); }\nstatic Jsi_OpCodes *code_mul() { JSI_NEW_CODES(0,OP_MUL, 0); }\nstatic Jsi_OpCodes *code_div() { JSI_NEW_CODES(0,OP_DIV, 0); }\nstatic Jsi_OpCodes *code_mod() { JSI_NEW_CODES(0,OP_MOD, 0); }\nstatic Jsi_OpCodes *code_add() { JSI_NEW_CODES(0,OP_ADD, 0); }\nstatic Jsi_OpCodes *code_sub() { JSI_NEW_CODES(0,OP_SUB, 0); }\nstatic Jsi_OpCodes *code_in() { JSI_NEW_CODES(0,OP_IN, 0); }\nstatic Jsi_OpCodes *code_less() { JSI_NEW_CODES(0,OP_LESS, 0); }\nstatic Jsi_OpCodes *code_greater() { JSI_NEW_CODES(0,OP_GREATER, 0); }\nstatic Jsi_OpCodes *code_lessequ() { JSI_NEW_CODES(0,OP_LESSEQU, 0); }\nstatic Jsi_OpCodes *code_greaterequ() { JSI_NEW_CODES(0,OP_GREATEREQU, 0); }\nstatic Jsi_OpCodes *code_equal() { JSI_NEW_CODES(0,OP_EQUAL, 0); } \nstatic Jsi_OpCodes *code_notequal() { JSI_NEW_CODES(0,OP_NOTEQUAL, 0); }\nstatic Jsi_OpCodes *code_eequ() { JSI_NEW_CODES(0,OP_STRICTEQU, 0); }\nstatic Jsi_OpCodes *code_nneq() { JSI_NEW_CODES(0,OP_STRICTNEQ, 0); }\nstatic Jsi_OpCodes *code_band() { JSI_NEW_CODES(0,OP_BAND, 0); }\nstatic Jsi_OpCodes *code_bor() { JSI_NEW_CODES(0,OP_BOR, 0); }\nstatic Jsi_OpCodes *code_bxor() { JSI_NEW_CODES(0,OP_BXOR, 0); }\nstatic Jsi_OpCodes *code_shf(int right) { JSI_NEW_CODES(0,OP_SHF, right); }\nstatic Jsi_OpCodes *code_instanceof() { JSI_NEW_CODES(0,OP_INSTANCEOF, 0); }\nstatic Jsi_OpCodes *code_assign(jsi_Pstate *p, jsi_Pline *line, int h) { JSI_NEW_CODESLN(0,OP_ASSIGN, h); }\nstatic Jsi_OpCodes *code_subscript(jsi_Pstate *p, jsi_Pline *line, int right_val) { JSI_NEW_CODESLN(0,OP_SUBSCRIPT, right_val); }\nstatic Jsi_OpCodes *code_inc(jsi_Pstate *p, jsi_Pline *line, int e) { JSI_NEW_CODESLN(0,OP_INC, e); }\nstatic Jsi_OpCodes *code_dec(jsi_Pstate *p, jsi_Pline *line, int e) { JSI_NEW_CODESLN(0,OP_DEC, e); }\nstatic Jsi_OpCodes *code_typeof(jsi_Pstate *p, jsi_Pline *line, int e) { JSI_NEW_CODESLN(0,OP_TYPEOF, e); }\n\nstatic Jsi_OpCodes *code__fcall(jsi_Pstate *p, jsi_Pline *line, int argc, const char *name, const char *namePre, Jsi_OpCodes *argCodes) {\n    jsi_FuncCallCheck(p,line,argc,1, name, namePre, argCodes);JSI_NEW_CODESLN(0,OP_FCALL, argc);\n}\nstatic Jsi_OpCodes *code_fcall(jsi_Pstate *p, jsi_Pline *line, int argc, const char *name, const char *namePre, Jsi_OpCodes *argCodes, Jsi_OpCodes* pref) {\n    Jsi_OpCodes *codes = code__fcall(p, line, argc, name, namePre, argCodes);\n    int i;\n    if (!name || !codes || !pref)\n        return codes;\n    jsi_OpLogFlags logflag = jsi_Oplf_none;\n    if (name[0] == 'a' && !Jsi_Strcmp(name, \"assert\"))\n        logflag = jsi_Oplf_assert;\n    else if (name[0] == 'L' && name[1] == 'o') {\n        if (!Jsi_Strcmp(name, \"LogDebug\"))\n            logflag = jsi_Oplf_debug;\n        else if (!Jsi_Strcmp(name, \"LogTrace\"))\n            logflag = jsi_Oplf_trace;\n        else if (!Jsi_Strcmp(name, \"LogTest\"))\n            logflag = jsi_Oplf_test;\n    }\n    if (logflag) {\n        codes->codes[0].logflag = logflag;\n        if (argCodes)\n            for (i=0; i<argCodes->code_len; i++)\n                argCodes->codes[i].logflag = logflag;\n        for (i=0; i<pref->code_len; i++)\n            pref->codes[i].logflag = logflag;\n    }\n    return codes;\n}\nstatic Jsi_OpCodes *code_newfcall(jsi_Pstate *p, jsi_Pline *line, int argc, const char *name, Jsi_OpCodes *argCodes) {\n    jsi_FuncCallCheck(p,line,argc,1, name, NULL, argCodes); JSI_NEW_CODESLN(0,OP_NEWFCALL, argc);\n}\nstatic Jsi_OpCodes *code_ret(jsi_Pstate *p, jsi_Pline *line, int n) { JSI_NEW_CODESLN(0,OP_RET, n); }\nstatic Jsi_OpCodes *code_delete(int n) { JSI_NEW_CODES(0,OP_DELETE, n); }\nstatic Jsi_OpCodes *code_chthis(jsi_Pstate *p, jsi_Pline *line, int n) { JSI_NEW_CODESLN(0,OP_CHTHIS, n); }\nstatic Jsi_OpCodes *code_pop(int n) { JSI_NEW_CODES(0,OP_POP, n); }\nstatic Jsi_OpCodes *code_jfalse(int off) { JSI_NEW_CODES(0,OP_JFALSE, off); }\nstatic Jsi_OpCodes *code_jtrue(int off) { JSI_NEW_CODES(0,OP_JTRUE, off); }\nstatic Jsi_OpCodes *code_jfalse_np(int off) { JSI_NEW_CODES(0,OP_JFALSE_NP, off); }\nstatic Jsi_OpCodes *code_jtrue_np(int off) { JSI_NEW_CODES(0,OP_JTRUE_NP, off); }\nstatic Jsi_OpCodes *code_jmp(int off) { JSI_NEW_CODES(0,OP_JMP, off); }\nstatic Jsi_OpCodes *code_object(jsi_Pstate *p, jsi_Pline *line, int c) { JSI_NEW_CODESLN(0,OP_OBJECT, c); }\nstatic Jsi_OpCodes *code_array(jsi_Pstate *p, jsi_Pline *line, int c) { JSI_NEW_CODESLN(0,OP_ARRAY, c); }\nstatic Jsi_OpCodes *code_key() { JSI_NEW_CODES(0,OP_KEY, 0); }\nstatic Jsi_OpCodes *code_next() { JSI_NEW_CODES(0,OP_NEXT, 0); }\n\nstatic Jsi_OpCodes *code_eval(jsi_Pstate *p, jsi_Pline *line, int argc, Jsi_OpCodes *c) {\n    jsi_FreeOpcodes(c); // Eliminate leak of unused opcodes.\n    JSI_NEW_CODESLN(0,OP_EVAL, argc);\n}\n\nstatic Jsi_OpCodes *code_stry(jsi_Pstate *p, jsi_Pline *line, int trylen, int catchlen, int finlen)\n{ \n    jsi_TryInfo *ti = (jsi_TryInfo *)Jsi_Calloc(1,sizeof(*ti));\n    ti->trylen = trylen;\n    ti->catchlen = catchlen;\n    ti->finallen = finlen;\n    JSI_NEW_CODESLN(1,OP_STRY, ti); \n}\nstatic Jsi_OpCodes *code_etry(jsi_Pstate *p, jsi_Pline *line) { JSI_NEW_CODESLN(0,OP_ETRY, 0); }\nstatic Jsi_OpCodes *code_scatch(jsi_Pstate *p, jsi_Pline *line, const char *var) { JSI_NEW_CODESLN(0,OP_SCATCH, var); }\nstatic Jsi_OpCodes *code_ecatch(jsi_Pstate *p, jsi_Pline *line) { JSI_NEW_CODESLN(0,OP_ECATCH, 0); }\nstatic Jsi_OpCodes *code_sfinal(jsi_Pstate *p, jsi_Pline *line) { JSI_NEW_CODESLN(0,OP_SFINAL, 0); }\nstatic Jsi_OpCodes *code_efinal(jsi_Pstate *p, jsi_Pline *line) { JSI_NEW_CODESLN(0,OP_EFINAL, 0); }\nstatic Jsi_OpCodes *code_throw(jsi_Pstate *p, jsi_Pline *line) { JSI_NEW_CODESLN(0,OP_THROW, 0); }\nstatic Jsi_OpCodes *code_with(jsi_Pstate *p, jsi_Pline *line, int withlen) { JSI_NEW_CODESLN(0,OP_WITH, withlen); }\nstatic Jsi_OpCodes *code_ewith(jsi_Pstate *p, jsi_Pline *line) { JSI_NEW_CODESLN(0,OP_EWITH, 0); }\n\nstatic Jsi_OpCodes *code_debug(jsi_Pstate *p, jsi_Pline *line) { JSI_NEW_CODESLN(0,OP_DEBUG, 0); }\nstatic Jsi_OpCodes *code_reserved(jsi_Pstate *p, jsi_Pline *line, int type, const char *id)\n{\n    jsi_ReservedInfo *ri = (jsi_ReservedInfo*)Jsi_Calloc(1, sizeof(*ri));\n    ri->type = type;\n    ri->label = id;\n    ri->topop = 0;\n    JSI_NEW_CODESLN(1,OP_RESERVED, ri);\n}\n\nstatic jsi_JmpPopInfo *jpinfo_new(int off, int topop)\n{\n    jsi_JmpPopInfo *r = (jsi_JmpPopInfo *)Jsi_Calloc(1, sizeof(*r));\n    r->off = off;\n    r->topop = topop;\n    return r;\n}\n\nstatic void code_reserved_replace(Jsi_OpCodes *ops, int step_len, int break_only,\n                           const char *desire_label, int topop)\n{\n    int i;\n    for (i = 0; i < ops->code_len; ++i) {\n        if (ops->codes[i].op != OP_RESERVED) continue;\n        jsi_ReservedInfo *ri = (jsi_ReservedInfo *)ops->codes[i].data;\n\n        if (ri->label) {\n            if (!desire_label || Jsi_Strcmp(ri->label, desire_label) != 0) {\n                ri->topop += topop;\n                continue;\n            }\n        }\n        \n        if (ri->type == RES_CONTINUE) {\n            if (break_only) {\n                ri->topop += topop;\n                continue;\n            } else {\n                int topop = ri->topop;\n                Jsi_Free(ri);       /* kill reserved Warn, replace with other opcode */\n /*               if (ops->codes[i].data && ops->codes[i].alloc) //TODO: memory leak?\n                    Jsi_Free(ops->codes[i].data);*/\n                if (topop) {\n                    ops->codes[i].data = jpinfo_new(ops->code_len - i, topop);\n                    ops->codes[i].op = OP_JMPPOP;\n                    ops->codes[i].alloc = 1;\n                } else {\n                    ops->codes[i].data = (void *)(uintptr_t)(ops->code_len - i);\n                    ops->codes[i].op = OP_JMP;\n                    ops->codes[i].alloc = 0;\n                }\n            }\n        } else if (ri->type == RES_BREAK) {\n            int topop = ri->topop;\n            Jsi_Free(ri);\n/*           if (ops->codes[i].data && ops->codes[i].alloc)\n                Jsi_Free(ops->codes[i].data); */\n            if (topop) {\n                ops->codes[i].data = jpinfo_new(step_len + ops->code_len - i, topop);\n                ops->codes[i].op = OP_JMPPOP;\n                ops->codes[i].alloc = 1;\n            } else {\n                ops->codes[i].data = (void *)(uintptr_t)(step_len + ops->code_len - i);\n                ops->codes[i].op = OP_JMP;\n                ops->codes[i].alloc = 0;\n            }\n        }\n    }\n}\n\nconst char* jsi_opcode_string(uint opCode)\n{\n    if (opCode >= (sizeof(jsi_op_names)/sizeof(jsi_op_names[0])))\n        return \"NULL\";\n    return jsi_op_names[opCode];\n}\n\nvoid jsi_code_decode(Jsi_Interp *interp, jsi_OpCode *op, int currentip, char *buf, int bsiz)\n{\n    if (_JSICASTINT(op->op) < 0 || op->op >= OP_LASTOP) {\n        snprintf(buf, bsiz, \"Bad opcode[%d] at %d\", op->op, currentip);\n    }\n    char nbuf[100];\n    snprintf(nbuf, sizeof(nbuf), \"%d#%d\", currentip, op->Line);\n    snprintf(buf, bsiz, \"%-8s %s \", nbuf, jsi_op_names[op->op]);\n\n    int sl = Jsi_Strlen(buf);\n    char *bp = buf + sl;\n    bsiz -= sl;\n    if (op->op == OP_PUSHBOO || op->op == OP_FCALL || op->op == OP_EVAL ||\n        op->op == OP_POP || op->op == OP_ASSIGN ||\n        op->op == OP_RET || op->op == OP_NEWFCALL ||\n        op->op == OP_DELETE || op->op == OP_CHTHIS ||\n        op->op == OP_OBJECT || op->op == OP_ARRAY ||\n        op->op == OP_SHF ||\n        op->op == OP_INC || op->op == OP_DEC) snprintf(bp, bsiz, \"%\" PRId64, (Jsi_Wide)(uintptr_t)op->data);\n    else if (op->op == OP_PUSHNUM) Jsi_NumberDtoA(interp, *((Jsi_Number *)op->data), bp, bsiz, 0);\n    else if (op->op == OP_PUSHVSTR) {\n        Jsi_String *ss = (Jsi_String*)op->data;\n        snprintf(bp, bsiz, \"\\\"%s\\\"\", ss->str);\n    } else if (op->op == OP_PUSHSTR || op->op == OP_LOCAL ||\n             op->op == OP_SCATCH) snprintf(bp, bsiz, \"\\\"%s\\\"\", op->data ? (char*)op->data:\"(NoCatch)\");\n    else if (op->op == OP_PUSHVAR) snprintf(bp, bsiz, \"var: \\\"%s\\\"\", ((jsi_FastVar *)op->data)->varname);\n    else if (op->op == OP_PUSHFUN) snprintf(bp, bsiz, \"func: 0x%\" PRIx64, (Jsi_Wide)(uintptr_t)op->data);\n    else if (op->op == OP_JTRUE || op->op == OP_JFALSE ||\n             op->op == OP_JTRUE_NP || op->op == OP_JFALSE_NP ||\n             op->op == OP_JMP) snprintf(bp, bsiz, \"{%\" PRIu64 \"}\\t#%\" PRIu64 \"\", (Jsi_Wide)(uintptr_t)op->data, (Jsi_Wide)((uintptr_t)currentip + (uintptr_t)op->data));\n    else if (op->op == OP_JMPPOP) {\n        jsi_JmpPopInfo *jp = (jsi_JmpPopInfo*)op->data;\n        snprintf(bp, bsiz, \"{%d},%d\\t#%d\", jp->off, jp->topop, currentip + jp->off);\n    }\n    else if (op->op == OP_STRY) {\n        jsi_TryInfo *t = (jsi_TryInfo *)op->data;\n        snprintf(bp, bsiz, \"{try:%d, catch:%d, final:%d}\", t->trylen, t->catchlen, t->finallen);\n    }\n}\n\nvoid jsi_mark_local(Jsi_OpCodes *ops) // Mark variables as declared with \"var\"\n{\n    return;\n    int i = 0;\n    if (ops == NULL || ops->codes == NULL)\n        return;\n    while (i < ops->code_len) {\n        if (ops->codes[i].op == OP_PUSHVAR)\n            ops->codes[i].local = 1;\n        i++;\n    }\n}\n\nstatic jsi_ForinVar *forinvar_new(jsi_Pstate *pstate, const char *varname, Jsi_OpCodes *local, Jsi_OpCodes *lval)\n{\n    jsi_ForinVar *r = (jsi_ForinVar*)Jsi_Calloc(1,sizeof(*r));\n    r->sig = JSI_SIG_FORINVAR;\n    r->varname = varname;\n    r->local = local;\n    r->lval = lval;\n    return r;\n}\n\nstatic Jsi_OpCodes *make_forin(Jsi_OpCodes *lval, jsi_Pline *line, Jsi_OpCodes *expr, Jsi_OpCodes *stat, const char *label, int isof)\n{\n    Jsi_OpCodes *keycode = code_key();\n    keycode->codes[0].isof = isof;\n    keycode->codes[0].Line = line->first_line;\n    Jsi_OpCodes *init = codes_join(expr, keycode);\n    Jsi_OpCodes *cond = codes_join3(lval, code_next(),\n                                   code_jfalse(stat->code_len + 2));\n    Jsi_OpCodes *stat_jmp = code_jmp(-(cond->code_len + stat->code_len));\n    code_reserved_replace(stat, 1, 0, label, 2);\n    return codes_join3(codes_join(init, cond), \n                          codes_join(stat, stat_jmp), code_pop(2));\n}\n\nstatic jsi_CaseExprStat *exprstat_new(jsi_Pstate *pstate, Jsi_OpCodes *expr, Jsi_OpCodes *stat, int isdef)\n{\n    jsi_CaseExprStat *r = (jsi_CaseExprStat*)Jsi_Calloc(1,sizeof(*r));\n    r->sig = JSI_SIG_CASESTAT;\n    r->expr = expr;\n    r->stat = stat;\n    r->isdefault = isdef;\n    return r;\n}\n\nstatic jsi_CaseList *caselist_new(jsi_Pstate *pstate, jsi_CaseExprStat *es)\n{\n    jsi_CaseList *a = (jsi_CaseList*)Jsi_Calloc(1,sizeof(*a));\n    a->sig = JSI_SIG_CASELIST;\n    a->es = es;\n    a->tail = a;\n    return a;\n}\n\nstatic jsi_CaseList *caselist_insert(jsi_Pstate *pstate, jsi_CaseList *a, jsi_CaseExprStat *es)\n{\n    jsi_CaseList *b = (jsi_CaseList*)Jsi_Calloc(1,sizeof(*b));\n    a->sig = JSI_SIG_CASELIST;\n    b->es = es;\n    a->tail->next = b;\n    a->tail = b;\n    return a;\n}\n\nstatic void caselist_free(jsi_CaseList *c)\n{\n    jsi_CaseList *a = c;\n    while (a) {\n        a = c->next;\n        if (c->es) Jsi_Free(c->es);\n        Jsi_Free(c);\n        c = a;\n    }\n}\n\nstatic Jsi_OpCodes *opassign(jsi_Pstate *pstate, jsi_Pline *line, Jsi_OpCodes *lval, Jsi_OpCodes *oprand, Jsi_OpCodes *op)\n{\n    Jsi_OpCodes *ret;\n    if ((lval)->lvalue_flag == 1) {\n        ret = codes_join3(lval, \n                             codes_join3(code_push_top(), oprand, op),\n                             code_assign(pstate, line, 1));\n    } else {\n        ret = codes_join3(lval,\n                             codes_join4(code_push_top2(), code_subscript(pstate, line, 1), oprand, op),\n                             code_assign(pstate, line, 2));\n    }\n    return ret;\n}\n\n#endif\n#endif\n", "/* The interpreter evaluation engine for jsi. */\n#ifndef JSI_LITE_ONLY\n#ifndef JSI_AMALGAMATION\n#include \"jsiInt.h\"\n#endif\n#include <math.h>\n\n#define _jsi_STACK (interp->Stack)\n#define _jsi_STACKIDX(s) interp->Stack[s]\n#define _jsi_TOP (interp->Stack[interp->framePtr->Sp-1])\n#define _jsi_TOQ (interp->Stack[interp->framePtr->Sp-2])\n#define _jsi_THIS (interp->Obj_this)\n#define _jsi_THISIDX(s) interp->Obj_this[s]\n\nstatic Jsi_RC jsi_EvalLogErr(Jsi_Interp *interp, const char *str) { Jsi_LogMsg(interp, JSI_ERROR, \"%s\", str); return JSI_ERROR; }\n\n#define _jsi_StrictChk(v) ((strict==0 || !Jsi_NumberIsNaN(v->d.num)) ? JSI_OK : jsi_EvalLogErr(interp, \"value is NaN\"))\n#define _jsi_StrictChk2(v1,v2)  ((strict==0  || (Jsi_NumberIsNaN(v1->d.num)==0 && Jsi_NumberIsNaN(v2->d.num)==0))  ? JSI_OK : jsi_EvalLogErr(interp, \"value is NaN\"))\n#define _jsi_StrictUChk(v) ((strict==0 || v->vt != JSI_VT_UNDEF) ? JSI_OK : jsi_EvalLogErr(interp, \"value is undefined\"))\n#define _jsi_StrictUChk2(v1,v2)  ((strict==0  || (v1->vt != JSI_VT_UNDEF && v2->vt != JSI_VT_UNDEF))  ? JSI_OK : jsi_EvalLogErr(interp, \"value is undefined\"))\n#define _jsi_StrictUChk3(v1,v2)  ((strict==0  || (v1->vt != JSI_VT_UNDEF || v2->vt == JSI_VT_UNDEF))  ? JSI_OK : jsi_EvalLogErr(interp, \"lhs value undefined in ===/!==\") )\n\nstatic jsi_Pstate* jsiNewParser(Jsi_Interp* interp, const char *codeStr, Jsi_Channel fp, int iseval)\n{\n    bool isNew;\n    Jsi_HashEntry *hPtr = NULL;\n    hPtr = Jsi_HashEntryNew(interp->codeTbl, (void*)codeStr, &isNew);\n    if (!hPtr) return NULL;\n    jsi_Pstate *ps, *topPs;\n\n    if (isNew==0 && ((ps = (jsi_Pstate *)Jsi_HashValueGet(hPtr)))) {\n        interp->codeCacheHit++;\n        return ps;\n    }\n    ps = jsi_PstateNew(interp);\n    ps->eval_flag = iseval;\n    if (codeStr)\n        jsi_PstateSetString(ps, codeStr);\n    else\n        jsi_PstateSetFile(ps, fp, 1);\n        \n    interp->inParse++;\n    topPs = interp->parsePs;\n    interp->parsePs = ps;\n    yyparse(ps);\n    interp->parsePs = topPs;\n    interp->inParse--;\n    \n    if (ps->err_count) {\n        Jsi_HashEntryDelete(hPtr);\n        jsi_PstateFree(ps);\n        return NULL;\n    }\n    if (isNew) {\n        Jsi_HashValueSet(hPtr, ps);\n        ps->hPtr = hPtr;\n    }\n    return ps;\n}\n\n/* eval here is diff from Jsi_CmdProc, current scope Jsi_LogWarn should be past to eval */\n/* make evaling script execute in the same context */\nstatic Jsi_RC jsiEvalOp(Jsi_Interp* interp, jsi_Pstate *ps, char *program,\n                       jsi_ScopeChain *scope, Jsi_Value *currentScope, Jsi_Value *_this, Jsi_Value **ret)\n{\n    Jsi_RC r = JSI_OK;\n    jsi_Pstate *newps = jsiNewParser(interp, program, NULL, 1);\n    if (newps) {\n        int oef = newps->eval_flag;\n        newps->eval_flag = 1;\n        interp->ps = newps;\n        r = jsi_evalcode(newps, NULL, newps->opcodes, scope, currentScope, _this, ret);\n        if (r) {\n            Jsi_ValueDup2(interp, &ps->last_exception, newps->last_exception);\n        }\n        newps->eval_flag = oef;\n        interp->ps = ps;\n    } else  {\n        //Jsi_ValueMakeStringKey(interp, &ps->last_exception, \"Syntax Error\");\n        r = JSI_ERROR;\n    }\n    return r;\n}\n                     \nstatic Jsi_Value** jsi_ValuesAlloc(Jsi_Interp *interp, int cnt, Jsi_Value**old, int oldsz) {\n    int i;\n    Jsi_Value **v = (Jsi_Value **)Jsi_Realloc(old, cnt* sizeof(Jsi_Value*));\n    for (i=oldsz; i<cnt; i++)\n        v[i] = NULL;\n    return v;\n}\n\nstatic void jsiSetupStack(Jsi_Interp *interp)\n{\n    int oldsz = interp->maxStack;\n    if (interp->maxStack)\n        interp->maxStack += STACK_INCR_SIZE;\n    else\n        interp->maxStack = STACK_INIT_SIZE;\n    _jsi_STACK = jsi_ValuesAlloc(interp, interp->maxStack, _jsi_STACK, oldsz);\n    _jsi_THIS = jsi_ValuesAlloc(interp, interp->maxStack, _jsi_THIS, oldsz); //TODO:!!! use interp->framePtr for this.\n}\n\nstatic void jsiPush(Jsi_Interp* interp, int n) {\n    int i = 0;\n    do {\n        if (!_jsi_STACKIDX(interp->framePtr->Sp))\n            _jsi_STACKIDX(interp->framePtr->Sp) = Jsi_ValueNew1(interp);\n        if (!_jsi_THISIDX(interp->framePtr->Sp))\n            _jsi_THISIDX(interp->framePtr->Sp) = Jsi_ValueNew1(interp);\n        if (i++ >= n) break;\n        interp->framePtr->Sp++;\n    } while (1);\n}\n\n/* Before setting a value in the _jsi_STACK/obj, unlink any reference to it. */\n\nstatic void jsiClearStack(Jsi_Interp *interp, int ofs) {\n    Jsi_Value **vPtr = &_jsi_STACKIDX(interp->framePtr->Sp-ofs), *v = *vPtr;\n    if (!v) return;\n#ifndef XX_NEWSTACK\n    Jsi_ValueReset(interp, vPtr);\n#else\n    if (v->refCnt<=1)\n        Jsi_ValueReset(interp, vPtr);\n    else {\n        Jsi_DecrRefCount(interp, v);\n        _jsi_STACKIDX(interp->framePtr->Sp-ofs) = Jsi_ValueNew1(interp);\n    }\n#endif\n}\n\nstatic void jsiClearThis(Jsi_Interp *interp, int ofs) {\n    Jsi_Value **vPtr = &_jsi_THISIDX(ofs), *v = *vPtr;\n    if (!v) return;\n#ifndef XX_NEWSTACK\n    Jsi_ValueReset(interp, vPtr);\n#else\n    if (v->refCnt<=1)\n        Jsi_ValueReset(interp, vPtr);\n    else {\n        Jsi_DecrRefCount(interp, v);\n        _jsi_THISIDX(ofs) = Jsi_ValueNew1(interp);\n    }\n#endif\n}\n\n\nstatic Jsi_RC inline jsi_ValueAssign(Jsi_Interp *interp, Jsi_Value *dst, Jsi_Value* src, int lop)\n{\n    Jsi_Value *v;\n    if (dst->vt != JSI_VT_VARIABLE) {\n        if (interp->strict) \n            return Jsi_LogError(\"operand not a left value\");\n    } else {\n        v = dst->d.lval;\n        SIGASSERT(v, VALUE);\n        int strict = interp->strict;\n        if (strict && lop == OP_PUSHFUN && interp->curIp[-1].local)\n            dst->f.bits.local = 1;\n        if (strict && dst->f.bits.local==0) {\n            const char *varname = \"\";\n            if (v->f.bits.lookupfailed)\n                varname = v->d.lookupFail;\n            Jsi_RC rc = Jsi_LogType(\"function created global: \\\"%s\\\"\", varname);\n            dst->f.bits.local=1;\n            if (rc != JSI_OK)\n                return rc;\n        }\n        if (v == src)\n            return JSI_OK;\n        if (v->f.bits.readonly) {\n            if (interp->strict) \n                return Jsi_LogError(\"assign to readonly variable\");\n            return JSI_OK;\n        }\n        if (Jsi_ValueIsFunction(interp, src))\n            Jsi_ValueMove(interp,v, src);\n        else\n            Jsi_ValueCopy(interp,v, src);\n        SIGASSERT(v, VALUE);\n        v->f.bits.readonly = 0;\n#ifdef JSI_MEM_DEBUG\n    if (!v->VD.label2)\n        v->VD.label2 = \"ValueAssign\";\n#endif\n    }\n    return JSI_OK;\n}\n\n/* pop n values from _jsi_STACK */\nstatic void jsiPop(Jsi_Interp* interp, int n) {\n    int t = n;\n    while (t > 0) {\n        Assert((interp->framePtr->Sp-t)>=0);\n/*        Jsi_Value *v = _jsi_STACKIDX(interp->framePtr->Sp-t);\n         if (v->refCnt>1) puts(\"OO\");*/\n        jsiClearStack(interp,t);\n        --t;\n    }\n    interp->framePtr->Sp -= n;\n}\n\n/* Convert preceding _jsi_STACK variable(s) into value(s). */\nstatic void jsiVarDeref(Jsi_Interp* interp, int n) {\n    while(interp->framePtr->Sp<n) // Assert and Log may map-out Ops.\n        jsiPush(interp, 1);\n    int i;\n    for (i=1; i<=n; i++) {\n        Jsi_Value *vb = _jsi_STACKIDX(interp->framePtr->Sp - i);\n        if (vb->vt == JSI_VT_VARIABLE) {\n            SIGASSERTV(vb->d.lval, VALUE);\n            Jsi_ValueCopy(interp, vb, vb->d.lval);\n        }\n    }\n}\n\n#define common_math_opr(opr) {                      \\\n    jsiVarDeref(interp,2);                                     \\\n    Jsi_ValueToNumber(interp, _jsi_TOP);     \\\n    Jsi_ValueToNumber(interp, _jsi_TOQ);     \\\n    rc = _jsi_StrictChk2(_jsi_TOP, _jsi_TOQ); \\\n    _jsi_TOQ->d.num = _jsi_TOQ->d.num opr _jsi_TOP->d.num;            \\\n    jsiPop(interp, 1);                                          \\\n}\n\n#define common_bitwise_opr(opr) {                       \\\n    Jsi_UWide a, b;                                       \\\n    jsiVarDeref(interp,2);                                     \\\n    Jsi_ValueToNumber(interp, _jsi_TOP);     \\\n    Jsi_ValueToNumber(interp, _jsi_TOQ);     \\\n    rc = _jsi_StrictChk2(_jsi_TOP, _jsi_TOQ); \\\n    a = _jsi_TOQ->d.num; b = _jsi_TOP->d.num;                   \\\n    _jsi_TOQ->d.num = (Jsi_Number)(a opr b);                  \\\n    jsiPop(interp, 1);                                          \\\n}\n\nstatic Jsi_RC jsi_logic_less(Jsi_Interp* interp, int i1, int i2) {\n    Jsi_Value *v, *v1 = _jsi_STACK[interp->framePtr->Sp-i1], *v2 = _jsi_STACK[interp->framePtr->Sp-i2], *res = _jsi_TOQ;\n    int val = 0, l1 = 0, l2 = 0; \n    bool strict = interp->strict;\n    Jsi_RC rc = JSI_OK;\n    rc = _jsi_StrictUChk2(v1, v2);\n    if (rc != JSI_OK)\n        return JSI_ERROR;\n    char *s1 = Jsi_ValueString(interp, v1, &l1);\n    char *s2 = Jsi_ValueString(interp, v2, &l2);\n    Jsi_Number n1, n2;\n\n    if (s1 || s2) {\n        char *str;\n        if (!(s1 && s2)) {\n            v = (s1 ? v2 : v1);\n            jsi_ValueToPrimitive(interp, &v);\n            Jsi_ValueToString(interp, v, NULL);\n            str = Jsi_ValueString(interp, v, (s1?&l2:&l1));\n            if (s1) s2 = str; else s1 = str;\n        }\n        Assert(l1>=0 && l1<=JSI_MAX_ALLOC_BUF);\n        Assert(l2>=0 && l2<=JSI_MAX_ALLOC_BUF);\n        //int mlen = (l1>l2?l1:l2);\n        val = Jsi_Strcmp(s1, s2);\n  \n        if (val > 0) val = 0;\n        else if (val < 0) val = 1;\n        else val = (l1 < l2);\n        jsiClearStack(interp,2);\n        Jsi_ValueMakeBool(interp, &res, val);\n    } else {\n        Jsi_ValueToNumber(interp, v1);\n        Jsi_ValueToNumber(interp, v2);\n        rc = _jsi_StrictChk2(v1,v2);\n        if (rc != JSI_OK)\n            return JSI_ERROR;\n        n1 = v1->d.num; n2 = v2->d.num;\n        if (Jsi_NumberIsNaN(n1) || Jsi_NumberIsNaN(n2)) {\n            jsiClearStack(interp,2);\n            Jsi_ValueMakeUndef(interp, &res);\n        } else {\n            val = (n1 < n2);\n            jsiClearStack(interp,2);\n            Jsi_ValueMakeBool(interp, &res, val);\n        }\n    }\n    return JSI_OK;\n}\n\nstatic const char *jsi_evalprint(Jsi_Value *v)\n{\n    static char buf[100];\n    if (!v)\n        return \"nil\";\n    if (v->vt == JSI_VT_NUMBER) {\n        snprintf(buf, 100, \"NUM:%\" JSI_NUMGFMT \" \", v->d.num);\n    } else if (v->vt == JSI_VT_BOOL) {\n        snprintf(buf, 100, \"BOO:%d\", v->d.val);\n    } else if (v->vt == JSI_VT_STRING) {\n        snprintf(buf, 100, \"STR:'%s'\", v->d.s.str);\n    } else if (v->vt == JSI_VT_VARIABLE) {\n        snprintf(buf, 100, \"VAR:%p\", v->d.lval);\n    } else if (v->vt == JSI_VT_NULL) {\n        snprintf(buf, 100, \"NULL\");\n    } else if (v->vt == JSI_VT_OBJECT) {\n        snprintf(buf, 100, \"OBJ:%p\", v->d.obj);\n    } else if (v->vt == JSI_VT_UNDEF) {\n        snprintf(buf, 100, \"UNDEFINED\");\n    }\n    return buf;\n}\n/* destroy top of trylist */\n#define pop_try(head) jsi_pop_try(interp, &head)\nstatic void jsi_pop_try(Jsi_Interp* interp, jsi_TryList **head)\n{\n    interp->framePtr->tryDepth--;\n    jsi_TryList *t = (*head)->next;\n    Jsi_Free(*head);\n    *head = t;\n    interp->tryList = t;\n}\n\nstatic void jsi_push_try(Jsi_Interp* interp, jsi_TryList **head, jsi_TryList *n)\n{\n    interp->tryList = n;\n    interp->framePtr->tryDepth++;\n    n->next = *head;\n    *head = n;\n}\n\n/* restore scope chain */\n#define JSI_RESTORE_SCOPE() jsi_restore_scope(interp, ps, trylist, \\\n    &scope, &currentScope, &context_id)\nstatic void jsi_restore_scope(Jsi_Interp* interp, jsi_Pstate *ps, jsi_TryList* trylist,\n  jsi_ScopeChain **scope, Jsi_Value **currentScope, int *context_id) {\n\n/* JSI_RESTORE_SCOPE(scope_save, curscope_save)*/\n    if (*scope != (trylist->scope_save)) {\n        jsi_ScopeChainFree(interp, *scope);\n        *scope = (trylist->scope_save);\n        interp->framePtr->ingsc = *scope;\n    }\n    if (*currentScope != (trylist->curscope_save)) {\n        Jsi_DecrRefCount(interp, *currentScope);\n        *currentScope = (trylist->curscope_save); \n        interp->framePtr->incsc = *currentScope;\n    }\n    *context_id = ps->_context_id++; \n}\n\n#define JSI_DO_THROW(nam) if (jsi_do_throw(interp, ps, &ip, &trylist,&scope, &currentScope, &context_id, (interp->framePtr->Sp?_jsi_TOP:NULL), nam) != JSI_OK) { rc = JSI_ERROR; break; }\n\nstatic int jsi_do_throw(Jsi_Interp *interp, jsi_Pstate *ps, jsi_OpCode **ipp, jsi_TryList **tlp,\n     jsi_ScopeChain **scope, Jsi_Value **currentScope, int *context_id, Jsi_Value *top, const char *nam) {\n    if (Jsi_InterpGone(interp))\n        return JSI_ERROR;\n    jsi_TryList *trylist = *tlp;\n    while (1) {\n        if (trylist == NULL) {\n            const char *str = (top?Jsi_ValueString(interp, top, NULL):\"\");\n            if (str) {\n                if (!Jsi_Strcmp(nam, \"help\"))\n                    Jsi_LogError(\"...%s\", str);\n                else\n                    Jsi_LogError(\"%s: %s\", nam, str);\n            }\n            return JSI_ERROR;\n        }\n        if (trylist->type == jsi_TL_TRY) {\n            int n = interp->framePtr->Sp - trylist->d.td.tsp;\n            jsiPop(interp, n);\n            if (*ipp >= trylist->d.td.tstart && *ipp < trylist->d.td.tend) {\n                *ipp = trylist->d.td.cstart - 1;\n                break;\n            } else if (*ipp >= trylist->d.td.cstart && *ipp < trylist->d.td.cend) {\n                trylist->d.td.last_op = jsi_LOP_THROW;\n                *ipp = trylist->d.td.fstart - 1;\n                break;\n            } else if (*ipp >= trylist->d.td.fstart && *ipp < trylist->d.td.fend) {\n                jsi_pop_try(interp, tlp);\n                trylist = *tlp;\n            } else Jsi_LogBug(\"Throw within a try, but not in its scope?\");\n        } else {\n            jsi_restore_scope(interp, ps, trylist, scope, currentScope, context_id);\n            jsi_pop_try(interp, tlp);\n            trylist = *tlp;\n        }\n    }\n    return JSI_OK;\n}\n\nstatic jsi_TryList *jsi_trylist_new(jsi_try_op_type t, jsi_ScopeChain *scope_save, Jsi_Value *curscope_save)\n{\n    jsi_TryList *n = (jsi_TryList *)Jsi_Calloc(1,sizeof(*n));\n    \n    n->type = t;\n    n->curscope_save = curscope_save;\n    /*Jsi_IncrRefCount(interp, curscope_save);*/\n    n->scope_save = scope_save;\n    \n    return n;\n}\n\nstatic void jsiDumpInstr(Jsi_Interp *interp, jsi_Pstate *ps, Jsi_Value *_this,\n    jsi_TryList *trylist, jsi_OpCode *ip, Jsi_OpCodes *opcodes)\n{\n    int i;\n    char buf[200];\n    jsi_code_decode(interp, ip, ip - opcodes->codes, buf, sizeof(buf));\n    Jsi_Printf(interp, jsi_Stderr, \"%p: %-30.200s : THIS=%s, STACK=[\", ip, buf, jsi_evalprint(_this));\n    for (i = 0; i < interp->framePtr->Sp; ++i) {\n        Jsi_Printf(interp, jsi_Stderr, \"%s%s\", (i>0?\", \":\"\"), jsi_evalprint(_jsi_STACKIDX(i)));\n    }\n    Jsi_Printf(interp, jsi_Stderr, \"]\");\n    if (ip->fname) {\n        const char *fn = ip->fname,  *cp = Jsi_Strrchr(fn, '/');\n        if (cp) fn = cp+1;\n        Jsi_Printf(interp, jsi_Stderr, \", %s:%d\", fn, ip->Line);\n    }\n    Jsi_Printf(interp, jsi_Stderr, \"\\n\");\n    jsi_TryList *tlt = trylist;\n    for (i = 0; tlt; tlt = tlt->next) i++;\n    if (ps->last_exception)\n        Jsi_Printf(interp, jsi_Stderr, \"TL: %d, excpt: %s\\n\", i, jsi_evalprint(ps->last_exception));\n}\n\nstatic int jsi_cmpstringp(const void *p1, const void *p2)\n{\n   return Jsi_Strcmp(* (char * const *) p1, * (char * const *) p2);\n}\n\nvoid jsi_SortDString(Jsi_Interp *interp, Jsi_DString *dStr, const char *sep) {\n    int argc, i;\n    char **argv;\n    Jsi_DString sStr;\n    Jsi_DSInit(&sStr);\n    Jsi_SplitStr(Jsi_DSValue(dStr), &argc, &argv, sep, &sStr);\n    qsort(argv, argc, sizeof(char*), jsi_cmpstringp);\n    Jsi_DSSetLength(dStr, 0);\n    for (i=0; i<argc; i++)\n        Jsi_DSAppend(dStr, (i?\" \":\"\"), argv[i], NULL);\n    Jsi_DSFree(&sStr);\n}\n\nstatic void jsi_ValueObjDelete(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *key, int force)\n{\n    if (target->vt != JSI_VT_OBJECT) return;\n    const char *kstr = Jsi_ValueToString(interp, key, NULL);\n    Jsi_TreeEntry *hPtr;\n    if (!Jsi_ValueIsStringKey(interp, key)) {\n        Jsi_MapEntry *hePtr = Jsi_MapEntryFind(target->d.obj->tree->opts.interp->strKeyTbl, kstr);\n        if (hePtr)\n            kstr = (char*)Jsi_MapKeyGet(hePtr, 0);\n    }\n    hPtr = Jsi_TreeEntryFind(target->d.obj->tree, kstr);\n    if (hPtr == NULL || (hPtr->f.bits.dontdel && !force))\n        return;\n    Jsi_TreeEntryDelete(hPtr);\n}\n\nstatic void jsiObjGetNames(Jsi_Interp *interp, Jsi_Obj *obj, Jsi_DString* dStr, int flags) {\n    Jsi_TreeEntry *hPtr;\n    Jsi_TreeSearch srch;\n    Jsi_Value *v;\n    int m = 0;\n    Jsi_DSInit(dStr);\n    if (obj->isarrlist)\n        obj = interp->Array_prototype->d.obj;\n    else if (!obj->tree->numEntries && obj->__proto__)\n        obj = obj->__proto__->d.obj;\n    for (hPtr=Jsi_TreeSearchFirst(obj->tree, &srch,  JSI_TREE_ORDER_IN, NULL); hPtr; hPtr=Jsi_TreeSearchNext(&srch)) {\n        v = (Jsi_Value*)Jsi_TreeValueGet(hPtr);\n        if (!v) continue;\n        if ((flags&JSI_NAME_FUNCTIONS) && !Jsi_ValueIsFunction(interp,v)) {\n            continue;\n        }\n        if ((flags&JSI_NAME_DATA) && Jsi_ValueIsFunction(interp,v)) {\n            continue;\n        }\n\n        Jsi_DSAppend(dStr, (m++?\" \":\"\"), Jsi_TreeKeyGet(hPtr), NULL);\n    }\n    Jsi_TreeSearchDone(&srch);\n}\n\nstatic void jsi_DumpFunctions(Jsi_Interp *interp, const char *spnam) {\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    Jsi_MapEntry *hPtr;\n    Jsi_MapSearch search;\n    Jsi_CmdSpecItem *csi = NULL;\n    Jsi_CmdSpec *cs;\n    Jsi_Value *lsf = interp->lastSubscriptFail;\n    Jsi_Obj *lso = ((lsf && lsf->vt == JSI_VT_OBJECT)?lsf->d.obj:0);\n    const char *varname = NULL;\n    int m = 0;\n    \n    if (lso) {\n        spnam = interp->lastSubscriptFailStr;\n        if (!spnam) spnam = interp->lastPushStr;\n        if (!spnam) spnam = \"\";\n        if (lso->ot == JSI_OT_USEROBJ && lso->d.uobj->reg && lso->d.uobj->interp == interp) {\n            cs = lso->d.uobj->reg->spec;\n            if (cs)\n                goto dumpspec;\n        } else if (lso->ot == JSI_OT_FUNCTION) {\n            cs = lso->d.fobj->func->cmdSpec;\n            if (cs)\n                goto dumpspec;\n        } else if (lso->ot == JSI_OT_OBJECT) {\n            jsiObjGetNames(interp, lso, &dStr, JSI_NAME_FUNCTIONS);\n            Jsi_LogError(\"'%s', functions are: %s.\",\n                spnam, Jsi_DSValue(&dStr));\n            Jsi_DSFree(&dStr);\n            return;\n        } else {\n            const char *sustr = NULL;\n            switch (lso->ot) {\n                case JSI_OT_STRING: sustr = \"String\"; break;\n                case JSI_OT_NUMBER: sustr = \"Number\"; break;\n                case JSI_OT_BOOL: sustr = \"Boolean\"; break;\n                default: break;\n            }\n            if (sustr) {\n                hPtr = Jsi_MapEntryFind(interp->cmdSpecTbl, sustr);\n                csi = (Jsi_CmdSpecItem*)Jsi_MapValueGet(hPtr);\n                cs = csi->spec;\n                if (!spnam[0])\n                    spnam = sustr;\n                goto dumpspec;\n            }\n        }\n    }\n    if (!spnam) spnam = \"\";\n    if (!*spnam) {\n        for (hPtr = Jsi_MapSearchFirst(interp->cmdSpecTbl, &search, 0);\n            hPtr; hPtr = Jsi_MapSearchNext(&search)) {\n            csi = (Jsi_CmdSpecItem*)Jsi_MapValueGet(hPtr);\n            if (csi->name && csi->name[0])\n                Jsi_DSAppend(&dStr, (m++?\" \":\"\"), csi->name, NULL);\n        }\n        Jsi_MapSearchDone(&search);\n    }\n    \n    varname = spnam;\n    if ((hPtr = Jsi_MapEntryFind(interp->cmdSpecTbl, spnam))) {\n        csi = (Jsi_CmdSpecItem*)Jsi_MapValueGet(hPtr);\n        while (csi) {\n            int n;\n            cs = csi->spec;\ndumpspec:\n            n = 0;\n            while (cs->name) {\n                if (n != 0 || !(cs->flags & JSI_CMD_IS_CONSTRUCTOR)) {\n                    if (!*cs->name) continue;\n                    Jsi_DSAppend(&dStr, (m?\" \":\"\"), cs->name, NULL);\n                    n++; m++;\n                }\n                cs++;\n            }\n            csi = (csi?csi->next:NULL);\n        }\n        jsi_SortDString(interp, &dStr, \" \");\n        if (varname)\n            spnam = varname;\n        else if (interp->lastPushStr && !spnam[0])\n            spnam = interp->lastPushStr;\n        Jsi_LogError(\"'%s' sub-commands are: %s.\",\n            spnam, Jsi_DSValue(&dStr));\n        Jsi_DSFree(&dStr);\n    } else {\n        Jsi_LogError(\"can not execute expression: '%s' not a function\",\n            varname ? varname : \"\");\n    }\n}\n\n/* Attempt to dynamically load function XX by doing an eval of Jsi_Auto.XX */\n/* TODO: prevent infinite loop/recursion. */\nJsi_Value *jsi_LoadFunction(Jsi_Interp *interp, const char *str, Jsi_Value *tret) {\n    Jsi_DString dStr = {};\n    Jsi_Value *v;\n    int i;\n    const char *curFile = interp->curFile;\n    interp->curFile = \"<jsiLoadFunction>\";\n    for (i=0; i<2; i++) {\n        Jsi_DSAppend(&dStr, \"Jsi_Auto.\", str, NULL);\n        Jsi_VarLookup(interp, Jsi_DSValue(&dStr));\n        v = Jsi_NameLookup(interp, Jsi_DSValue(&dStr));\n        if (v)\n            jsi_ValueDebugLabel(v, \"jsiLoadFunction\",\"f1\");\n        Jsi_DSFree(&dStr);\n        if (v) {\n            const char *cp = Jsi_ValueGetDString(interp, v, &dStr, 0);\n            v = NULL;\n            if (Jsi_EvalString(interp, cp, 0) == JSI_OK) {\n                v = Jsi_NameLookup(interp, str);\n                if (v)\n                    jsi_ValueDebugLabel(v, \"jsiLoadFunction\",\"f2\");\n            }\n            Jsi_DSFree(&dStr);\n            if (v) {\n                tret = v;\n                break;\n            }\n        }\n        if (interp->autoLoaded++ || i>0)\n            break;\n        /*  Index not in memory, so try loading Jsi_Auto from the autoload.jsi file. */\n        if (interp->autoFiles == NULL)\n            return tret;\n        Jsi_Value **ifs = &interp->autoFiles;\n        int i, ifn = 1;\n        if (Jsi_ValueIsArray(interp, interp->autoFiles)) {\n            ifs = interp->autoFiles->d.obj->arr;\n            ifn = interp->autoFiles->d.obj->arrCnt;\n        }\n        for (i=0; i<ifn; i++) {  \n            if (Jsi_EvalFile(interp, ifs[i], 0) != JSI_OK)\n                break;\n            interp->autoLoaded++;\n        }\n    }\n    interp->curFile = curFile;\n    return tret;\n}\n\nvoid jsi_TraceFuncCall(Jsi_Interp *interp, Jsi_Func *fstatic, jsi_OpCode *iPtr,\n    Jsi_Value *_this, Jsi_Value* args, Jsi_Value *ret, int tc)\n{\n    jsi_OpCode *ip = (iPtr ? iPtr : interp->curIp);\n    if (!ip)\n        return;\n    const char *ff, *fname = ip->fname?ip->fname:\"\";\n    if ((tc&jsi_callTraceFullPath)==0 && ((ff=Jsi_Strrchr(fname,'/'))))\n        fname = ff+1;\n    if (interp->traceHook)\n        (*interp->traceHook)(interp, fstatic->name, ip->fname, ip->Line, fstatic->cmdSpec, _this, args, ret);\n    else {\n        const char *fp = ((tc&jsi_callTraceNoParent)?NULL:fstatic->parentName);\n        if (fp && !*fp)\n            fp = NULL;\n        Jsi_DString aStr;\n        Jsi_DSInit(&aStr);\n        Jsi_DString dStr;\n        Jsi_DSInit(&dStr);\n        Jsi_DString pStr;\n        Jsi_DSInit(&pStr);\n        Jsi_DString *sPtr = NULL;\n        int plen = 0;\n        if (ret) {\n            sPtr = &dStr;\n            Jsi_DSAppend(sPtr, \" <-- \", NULL);\n            plen = Jsi_DSLength(sPtr);\n            Jsi_ValueGetDString(interp, ret, sPtr, 0);\n        } else if ((tc&jsi_callTraceArgs)) {\n            sPtr = &aStr;\n            Jsi_ValueGetDString(interp, args, sPtr, JSI_OUTPUT_JSON);\n        }\n        if (sPtr) {\n            if (!(tc&jsi_callTraceNoTrunc)) {\n                const char *cp0 = Jsi_DSValue(sPtr), *cp1 = Jsi_Strchr(cp0, '\\n');\n                int nlen = 0, clen = Jsi_DSLength(sPtr);\n                if (cp1) {\n                    nlen = (cp1-cp0);\n                    if (nlen>60) nlen = 60;\n                }  else if (clen>60)\n                    nlen = 60;\n                else nlen = clen;\n                if (nlen != clen && clen>plen) {\n                    Jsi_DSSetLength(sPtr, nlen);\n                    Jsi_DSAppend(sPtr, \"...\", NULL);\n                }\n            }\n        }\n        if (interp->parent && interp->debugOpts.traceCallback) {\n            Jsi_DString jStr={}, kStr={}, lStr={};\n            Jsi_DSPrintf(&kStr, \"[\\\"%s%s%s\\\", %s, %s, \\\"%s\\\", %d, %d ]\",\n                (fp?fp:\"\"), (fp?\".\":\"\"), fstatic->name, \n                (ret?\"null\":Jsi_JSONQuote(interp, Jsi_DSValue(&aStr),-1, &jStr)),\n                (ret?Jsi_JSONQuote(interp, Jsi_DSValue(&dStr),-1, &lStr):\"null\"),\n                 fname, ip->Line, ip->Lofs);\n            if (Jsi_FunctionInvokeJSON(interp->parent, interp->debugOpts.traceCallback, Jsi_DSValue(&kStr), NULL) != JSI_OK)\n                Jsi_DSPrintf(&pStr, \"failed trace call\\n\");\n            Jsi_DSFree(&jStr);\n            Jsi_DSFree(&kStr);\n            Jsi_DSFree(&lStr);\n        } else if ((tc&jsi_callTraceBefore))\n            Jsi_DSPrintf(&pStr, \"%s:%d %*s#%d: %c %s%s%s(%s) %s\\n\",\n                fname, ip->Line,\n                (interp->level-1)*2, \"\", interp->level,\n                (ret?'<':'>'), (fp?fp:\"\"), (fp?\".\":\"\"), fstatic->name, Jsi_DSValue(&aStr), Jsi_DSValue(&dStr));\n        else {\n            if (!interp->curIp || !interp->logOpts.before) {\n                Jsi_DSPrintf(&pStr, \"%*s#%d: %c %s%s%s(%s) in %s:%d%s\\n\", (interp->level-1)*2, \"\", interp->level,\n                    (ret?'<':'>'), (fp?fp:\"\"), (fp?\".\":\"\"), fstatic->name, Jsi_DSValue(&aStr),\n                fname, ip->Line, Jsi_DSValue(&dStr));\n            } else {\n                int quote = 0;\n                jsi_SysPutsCmdPrefix(interp, &interp->logOpts, &pStr, &quote, NULL);\n                Jsi_DSPrintf(&pStr, \"%*s#%d: %c %s%s%s(%s) \\n\", (interp->level-1)*2, \"\", interp->level,\n                    (ret?'<':'>'), (fp?fp:\"\"), (fp?\".\":\"\"), fstatic->name, Jsi_DSValue(&aStr));\n                Jsi_DSAppend(&pStr, Jsi_DSValue(&dStr), NULL);\n            }\n        }\n        if (Jsi_DSLength(&pStr))\n            Jsi_Puts(interp, jsi_Stderr, Jsi_DSValue(&pStr), -1);\n        Jsi_DSFree(&pStr);\n        Jsi_DSFree(&dStr);\n        Jsi_DSFree(&aStr);\n    }\n}\n\nJsi_RC jsi_FunctionSubCall(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Value *tocall, int discard)\n{\n    Jsi_RC rc = JSI_OK;\n    const char *oldCurFunc = interp->curFunction, *spnam = \"\";\n    jsi_OpCode *ip = interp->curIp;\n    int adds, as_constructor = (ip->op == OP_NEWFCALL);\n    double timStart = 0;\n    int docall;\n    int calltrc = 0, profile = interp->profile, coverage = interp->coverage;\n    jsi_PkgInfo *pkg;\n    int tc;\n    \n    //char *lpv = interp->lastPushStr;\n    if (tocall->vt == JSI_VT_UNDEF && tocall->f.bits.lookupfailed && tocall->d.lookupFail && !interp->noAutoLoad) {\n        spnam = tocall->d.lookupFail;\n        tocall->f.bits.lookupfailed = 0;\n        tocall = jsi_LoadFunction(interp, spnam, tocall);\n        interp->lastPushStr = (char*)spnam;\n        interp->curIp = ip;\n    }\n    if (!Jsi_ValueIsFunction(interp, tocall)) {\n       // if (tocall->f.bits.subscriptfailed && tocall->d.lookupFail)\n       //     spnam = tocall->d.lookupFail;\n        jsi_DumpFunctions(interp, spnam);\n        rc = JSI_ERROR;\n        goto empty_func;\n    }\n\n    if (tocall->d.obj->d.fobj==NULL || tocall->d.obj->d.fobj->func==NULL) {   /* empty function */\nempty_func:\n        //jsiPop(interp, stackargc);\n        //jsiClearStack(interp,1);\n        //Jsi_ValueMakeUndef(interp, &_jsi_TOP);\n        interp->curFunction = oldCurFunc;\n        Jsi_DecrRefCount(interp, _this);\n        if (rc==JSI_OK)\n            rc = JSI_CONTINUE;\n        return rc;\n        //goto done;\n    }\n    \n    Jsi_FuncObj *fobj = tocall->d.obj->d.fobj;\n    Jsi_Func *funcPtr = fobj->func;\n    if (funcPtr->callback == jsi_NoOpCmd || tocall->d.obj->isNoOp) {\n        jsi_NoOpCmd(interp, NULL, NULL, NULL, NULL);\n        goto empty_func;\n    }\n    if (!interp->asserts && funcPtr->callback == jsi_AssertCmd)\n        goto empty_func;\n    const char *onam = funcPtr->name;\n//        if (!onam) // Override blank name with last index.\n//            funcPtr->name = lpv;\n    if (funcPtr->name && funcPtr->name[0] && funcPtr->type == FC_NORMAL)\n        interp->curFunction = funcPtr->name;\n    adds = funcPtr->callflags.bits.addargs;\n    Jsi_CmdSpec *cs  = funcPtr->cmdSpec;\n    if (adds && (cs->flags&JSI_CMDSPEC_NONTHIS))\n        adds = 0;\n\n    Jsi_Func *pprevActive = interp->prevActiveFunc, *prevActive = interp->prevActiveFunc = interp->activeFunc;\n    interp->activeFunc = funcPtr;\n\n    rc = jsi_SharedArgs(interp, args, funcPtr, 1); /* make arg vars to share arguments */\n    if (rc != JSI_OK)\n        goto bail;\n    funcPtr->callflags.bits.addargs = 0;\n    jsi_InitLocalVar(interp, args, funcPtr);\n    jsi_SetCallee(interp, args, tocall);\n    \n    pkg = funcPtr->pkg;\n    tc = interp->traceCall;\n    if (pkg) {\n        tc |= pkg->popts.modConf.traceCall;\n        profile |= pkg->popts.modConf.profile;\n        coverage |= pkg->popts.modConf.coverage;\n    }\n\n    if (as_constructor) {                       /* new Constructor */\n        Jsi_Obj *newobj = Jsi_ObjNewType(interp, JSI_OT_OBJECT);\n        Jsi_Value *proto = NULL;\n        if (!interp->subOpts.noproto)\n            proto = Jsi_ValueObjLookup(interp, tocall, \"prototype\", 0);\n        if (proto && proto->vt == JSI_VT_OBJECT) {\n            newobj->__proto__ = proto;\n            newobj->clearProto = 1;\n            Jsi_IncrRefCount(interp, proto);\n        }\n        Jsi_ValueReset(interp, &_this);\n        Jsi_ValueMakeObject(interp, &_this, newobj);            \n        /* TODO: constructor specifics??? */\n        calltrc = (tc&jsi_callTraceNew);\n    }\n    if (funcPtr->type == FC_NORMAL)\n        calltrc = (tc&jsi_callTraceFuncs);\n    else\n        calltrc = (tc&jsi_callTraceCmds);\n    if (calltrc && funcPtr->name)\n        jsi_TraceFuncCall(interp, funcPtr, ip, _this, args, 0, tc);\n\n    //Jsi_Value *spretPtr = *ret;\n \n    interp->activeFunc = funcPtr;\n    docall = (rc==JSI_OK);\n    if (profile || coverage) {\n        interp->profileCnt++;\n        timStart = jsi_GetTimestamp();\n    }\n    if (funcPtr->type == FC_NORMAL) {\n        if (docall) {\n            rc = jsi_evalcode(interp->ps, funcPtr, funcPtr->opcodes, tocall->d.obj->d.fobj->scope, \n                args, _this, ret);\n        }\n        interp->funcCallCnt++;\n    } else if (!funcPtr->callback) {\n        Jsi_LogError(\"can not call:\\\"%s()\\\"\", funcPtr->name);\n    } else {\n        int oldcf = funcPtr->callflags.i;\n        funcPtr->callflags.bits.iscons = (as_constructor?JSI_CALL_CONSTRUCTOR:0);\n        if (funcPtr->f.bits.hasattr)\n        {\n#define SPTR(s) (s?s:\"\")\n            if ((funcPtr->f.bits.isobj) && _this->vt != JSI_VT_OBJECT) {\n                rc = JSI_ERROR;\n                docall = 0;\n                Jsi_LogError(\"'this' is not object: \\\"%s()\\\"\", funcPtr->name);\n            } else if ((!(funcPtr->f.bits.iscons)) && as_constructor) {\n                rc = JSI_ERROR;\n                docall = 0;\n                Jsi_LogError(\"can not call as constructor: \\\"%s()\\\"\", funcPtr->name);\n            } else {\n                int aCnt = Jsi_ValueGetLength(interp, args);\n                if (aCnt<(cs->minArgs+adds)) {\n                    Jsi_LogError(\"missing args, expected \\\"%s(%s)\\\" \", cs->name, SPTR(cs->argStr));\n                    rc = JSI_ERROR;\n                    docall = 0;\n                } else if (cs->maxArgs>=0 && (aCnt>cs->maxArgs+adds)) {\n                    Jsi_LogError(\"extra args, expected \\\"%s(%s)\\\" \", cs->name, SPTR(cs->argStr));\n                    rc = JSI_ERROR;\n                    docall = 0;\n                }\n            }\n        }\n        if (docall) {\n            funcPtr->fobj = fobj; // Backlink for bind.\n            funcPtr->callflags.bits.isdiscard = discard;\n            rc = funcPtr->callback(interp, args, \n                _this, ret, funcPtr);\n            interp->cmdCallCnt++;\n        }\n        funcPtr->callflags.i = oldcf;\n    }\n    if (profile || coverage) {\n        double timEnd = jsi_GetTimestamp(), timUsed = (timEnd - timStart);;\n        assert(timUsed>=0);\n        funcPtr->allTime += timUsed;\n        if (interp->framePtr->evalFuncPtr)\n            interp->framePtr->evalFuncPtr->subTime += timUsed;\n        else\n            interp->subTime += timUsed;\n    }\n    if (calltrc && (tc&jsi_callTraceReturn) && funcPtr->name)\n        jsi_TraceFuncCall(interp, funcPtr, ip, _this, NULL, *ret, tc);\n    if (!onam)\n        funcPtr->name = NULL;\n    if (docall) {\n        funcPtr->callCnt++;\n        if (rc == JSI_OK && !as_constructor && funcPtr->retType && (interp->typeCheck.all || interp->typeCheck.run))\n            rc = jsi_ArgTypeCheck(interp, funcPtr->retType, *ret, \"returned from\", funcPtr->name, 0, funcPtr, 0);\n    }\n    interp->prevActiveFunc = pprevActive;\n    interp->activeFunc = prevActive;\n\n    if (as_constructor) {\n        if (_this->vt == JSI_VT_OBJECT)\n            _this->d.obj->constructor = tocall->d.obj;\n        if ((*ret)->vt != JSI_VT_OBJECT) {\n            Jsi_ValueReset(interp, ret);\n            Jsi_ValueCopy(interp, *ret, _this);\n        }\n    }\n\nbail:\n    jsi_SharedArgs(interp, args, funcPtr, 0); /* make arg vars to shared arguments */\n    Jsi_DecrRefCount(interp, _this);\n    interp->curFunction = oldCurFunc;\n\n    return rc;\n}\n\nJsi_RC jsiEvalFunction(jsi_Pstate *ps, jsi_OpCode *ip, int discard) {\n    Jsi_Interp *interp = ps->interp;\n    int stackargc = (int)(uintptr_t)ip->data;\n    jsiVarDeref(interp, stackargc + 1);\n    int tocall_index = interp->framePtr->Sp - stackargc - 1;\n    Jsi_Value *_this = _jsi_THISIDX(tocall_index),\n        *tocall = _jsi_STACKIDX(tocall_index), **spargs = _jsi_STACK+(interp->framePtr->Sp - stackargc),   \n        *spretPtr = Jsi_ValueNew1(interp), *spretPtrOld = spretPtr,\n        *args = Jsi_ValueNewArrayObj(interp, spargs, stackargc, 1);\n        \n    Jsi_IncrRefCount(interp, args);\n    if (_this->vt != JSI_VT_OBJECT)\n        _this = Jsi_ValueDup(interp, interp->Top_object);\n    else {\n        _this = Jsi_ValueDup(interp, _this);\n        jsiClearThis(interp, tocall_index);\n    }   \n    Jsi_RC rc = jsi_FunctionSubCall(interp, args, _this, &spretPtr, tocall, discard);\n    \n    jsiPop(interp, stackargc);\n    jsiClearStack(interp,1);\n    if (rc == JSI_CONTINUE) {\n        Jsi_ValueMakeUndef(interp, &_jsi_TOP);\n        rc = JSI_OK;\n    }\n    if (spretPtr == spretPtrOld) {\n        Jsi_ValueMove(interp, _jsi_TOP, spretPtr);\n        Jsi_DecrRefCount(interp, spretPtr);\n    } else {\n        /*  returning a (non-copied) value reference */\n        Jsi_DecrRefCount(interp, _jsi_TOP);\n        _jsi_TOP = spretPtr;\n    }\n    Jsi_DecrRefCount(interp, args);\n    return rc;\n}\n\nstatic Jsi_RC jsi_PushVar(jsi_Pstate *ps, jsi_OpCode *ip, jsi_ScopeChain *scope, Jsi_Value *currentScope, int context_id) {\n    Jsi_Interp *interp = ps->interp;\n    jsi_FastVar *fvar = (typeof(fvar))ip->data;\n    SIGASSERT(fvar,FASTVAR);\n    Jsi_Value **dvPtr = &_jsi_STACKIDX(interp->framePtr->Sp), *dv = *dvPtr, *v = NULL;\n    if (fvar->context_id == context_id && fvar->ps == ps) {\n        v = fvar->lval;\n    } else {\n        char *varname = fvar->varname;\n        v = Jsi_ValueObjLookup(interp, currentScope, varname, 1);\n        if (v) {\n            fvar->local = 1;\n            if (v->vt == JSI_VT_UNDEF) {\n                v->d.lookupFail = varname;\n                v->f.bits.lookupfailed = 1;\n            }\n        } else {\n            v = jsi_ScopeChainObjLookupUni(scope, varname);\n            if (v) \n                fvar->local = 1;\n            else {\n                /* add to global scope.  TODO: do not define if a right_val??? */\n                Jsi_Value *global_scope = scope->chains_cnt > 0 ? scope->chains[0]:currentScope;\n                Jsi_Value key = VALINIT, *kPtr = &key; // Note: a string key so no reset needed.\n                Jsi_ValueMakeStringKey(interp, &kPtr, varname);\n                v = jsi_ValueObjKeyAssign(interp, global_scope, &key, NULL, JSI_OM_DONTENUM);\n                if (v->vt == JSI_VT_UNDEF) {\n                    v->d.lookupFail = varname;\n                    v->f.bits.lookupfailed = 1;\n                }\n                jsi_ValueDebugLabel(v, \"var\", varname);\n                bool isNew;\n                Jsi_HashEntry *hPtr = Jsi_HashEntryNew(interp->varTbl, varname, &isNew);\n                if (hPtr && isNew)\n                    Jsi_HashValueSet(hPtr, 0);\n            }\n        }\n        \n        Jsi_IncrRefCount(interp, v);\n\n    }\n    if (dv != v && (dv->vt != JSI_VT_VARIABLE || dv->d.lval != v)) {\n        Jsi_ValueReset(interp, dvPtr);\n        dv->vt = JSI_VT_VARIABLE;\n        SIGASSERT(v, VALUE);\n        dv->d.lval = v;\n        dv->f.bits.local = (fvar->local);\n    }\n    SIGASSERT(v, VALUE);\n    jsiPush(interp,1);\n    return JSI_OK;\n}\n\nstatic void jsi_PushFunc(jsi_Pstate *ps, jsi_OpCode *ip, jsi_ScopeChain *scope, Jsi_Value *currentScope) {\n    /* TODO: now that we're caching ps, may need to reference function ps for context_id??? */\n    Jsi_Interp *interp = ps->interp;\n    Jsi_FuncObj *fo = jsi_FuncObjNew(interp, (Jsi_Func *)ip->data);\n    fo->scope = jsi_ScopeChainDupNext(interp, scope, currentScope);\n    Jsi_Obj *obj = Jsi_ObjNewType(interp, JSI_OT_FUNCTION);\n    obj->d.fobj = fo;\n    \n    Jsi_Value *v = _jsi_STACKIDX(interp->framePtr->Sp), *fun_prototype = jsi_ObjValueNew(interp);\n    fun_prototype->d.obj->__proto__ = interp->Object_prototype;                \n    Jsi_ValueMakeObject(interp, &v, obj);\n    Jsi_ValueInsert(interp, v, \"prototype\", fun_prototype, JSI_OM_DONTDEL|JSI_OM_DONTENUM);\n    /* TODO: make own prototype and prototype.constructor */\n    \n    bool isNew;\n    Jsi_HashEntry *hPtr;  Jsi_Value *vv;\n    if (interp->framePtr->Sp == 1 && (vv=_jsi_STACKIDX(0))->vt == JSI_VT_VARIABLE) {\n        const char *varname = NULL;\n        vv = vv->d.lval;\n        if (vv && vv->f.bits.lookupfailed && vv->d.lookupFail) {\n            varname = vv->d.lookupFail;\n            vv->f.bits.lookupfailed = 0;\n        }\n        if (varname) {\n            if (!fo->func->name)\n                fo->func->name = varname;\n            hPtr = Jsi_HashEntryNew(interp->varTbl, varname, &isNew);\n            if (hPtr)\n                Jsi_HashValueSet(hPtr, obj);\n        }\n    }\n    hPtr = Jsi_HashEntryNew(interp->funcObjTbl, fo, &isNew);\n    if (hPtr && isNew) {\n        Jsi_ObjIncrRefCount(interp, obj);\n        Jsi_HashValueSet(hPtr, obj);\n    }\n    jsiPush(interp,1);\n}\n\nstatic Jsi_RC jsi_evalSubscript(Jsi_Interp *interp, Jsi_Value *src, Jsi_Value *idx, jsi_OpCode *ip,  jsi_OpCode *end,\n    Jsi_Value *currentScope)\n{\n    Jsi_RC rc = JSI_OK;\n    jsiVarDeref(interp,2);\n    int isnull;\n    if ((isnull=Jsi_ValueIsNull(interp, src)) || Jsi_ValueIsUndef(interp, src)) {\n        Jsi_LogError(\"invalid subscript of %s\", (isnull?\"null\":\"undefined\"));\n        jsiPop(interp, 1);\n        return JSI_ERROR;\n    }\n    Jsi_String *str = jsi_ValueString(src);\n    if (str && Jsi_ValueIsNumber(interp, idx)) {\n        int bLen, cLen;\n        char bbuf[10], *cp = Jsi_ValueString(interp, src, &bLen);\n        int n = (int)idx->d.num;\n        cLen = bLen;\n#if JSI__UTF8\n        if (str->flags&JSI_IS_UTF || !(str->flags&JSI_UTF_CHECKED)) {\n            cLen = Jsi_NumUtfChars(cp, bLen);\n            str->flags |= JSI_UTF_CHECKED;\n            if (cLen != bLen)\n                str->flags |= JSI_IS_UTF;\n        }\n#endif\n        if (n<0 || n>=cLen) {\n            Jsi_ValueMakeUndef(interp, &src);\n        } else {\n            if (cLen != bLen)\n                Jsi_UtfGetIndex(cp, n, bbuf);\n            else {\n                bbuf[0] = cp[n];\n                bbuf[1] = 0;\n            }\n            Jsi_ValueMakeStringDup(interp, &src, bbuf);\n        }\n        jsiPop(interp, 1);\n        return rc;\n    }\n    Jsi_ValueToObject(interp, src);\n    if (interp->hasCallee && (src->d.obj == currentScope->d.obj || (interp->framePtr->arguments && src->d.obj == interp->framePtr->arguments->d.obj))) {\n        if (idx->vt == JSI_VT_STRING && Jsi_Strcmp(idx->d.s.str, \"callee\") == 0) {\n            jsiClearStack(interp,1);\n            Jsi_ValueMakeStringKey(interp, &idx, \"\\1callee\\1\");\n        }\n    }\n    int bsc = Jsi_ValueIsObjType(interp, src, JSI_OT_NUMBER); // Previous bad subscript.\n    if (bsc == 0 && interp->lastSubscriptFail && interp->lastSubscriptFail->vt != JSI_VT_UNDEF)\n        Jsi_ValueReset(interp, &interp->lastSubscriptFail);\n\n    if (src->vt != JSI_VT_UNDEF) {\n        int right_val = (uintptr_t)ip->data;\n        Jsi_Value res = VALINIT, \n            *resPtr = &res,\n            *vp = jsi_ValueSubscript(interp, src, idx, &resPtr);\n        if (!vp && bsc == 0) {\n            /* eg. so we can list available commands for  \"db.xx()\" */\n            if (idx->vt == JSI_VT_STRING)\n                interp->lastSubscriptFailStr = idx->d.s.str;\n            Jsi_ValueDup2(interp, &interp->lastSubscriptFail, src);\n        }\n        if (vp)\n            Jsi_IncrRefCount(interp, vp);\n        jsiClearStack(interp,2);\n        if (!vp)\n            Jsi_ValueMakeUndef(interp, &src);\n        else {\n            //printf(\"IDX(%p): %s\\n\", idx, Jsi_ValueString(interp, idx, NULL));\n            if (right_val || vp->f.bits.readonly) {\n                if (vp == resPtr && (res.vt == JSI_VT_OBJECT || res.vt == JSI_VT_STRING))  // TODO:*** Undo using ValueCopy. ***\n                    Jsi_ValueMove(interp, src, vp);\n                else\n                    Jsi_ValueCopy(interp, src, vp);\n            } else {\n                assert(vp != resPtr);\n                res.vt = JSI_VT_VARIABLE;\n                res.d.lval = vp;\n                Jsi_ValueCopy(interp, src, resPtr);\n            }\n            Jsi_DecrRefCount(interp, vp);\n        }\n    }\n    jsiPop(interp, 1);\n    return rc;\n}\n\nvoid jsi_DebuggerStmt(void) {\n    // Called for \"debugger\" statement.\n}\n\nstatic Jsi_RC jsi_ValueAssignCheck(Jsi_Interp *interp, Jsi_Value *val, int lop) {\n    if (lop == OP_FCALL || lop == OP_NEWFCALL)\n        return JSI_OK;\n    if (val->f.bits.lookupfailed && val->d.lookupFail)\n        return Jsi_LogType(\"assign from undef var: %s\", val->d.lookupFail);\n    return JSI_OK;\n}\n\nJsi_RC jsi_evalcode_sub(jsi_Pstate *ps, Jsi_OpCodes *opcodes, \n     jsi_ScopeChain *scope, Jsi_Value *currentScope,\n     Jsi_Value *_this, Jsi_Value *vret)\n{\n    Jsi_Interp* interp = ps->interp;\n    jsi_OpCode *ip = &opcodes->codes[0];\n    Jsi_RC rc = JSI_OK;\n    int curLine = 0;\n    int context_id = ps->_context_id++, lop = -1;\n    jsi_OpCode *end = &opcodes->codes[opcodes->code_len];\n    jsi_TryList  *trylist = NULL;\n    bool strict = interp->strict;\n    const char *curFile = NULL;\n    \n    if (currentScope->vt != JSI_VT_OBJECT) {\n        Jsi_LogBug(\"Eval: current scope is not a object\");\n        return JSI_ERROR;\n    }\n    if (interp->maxDepth>0 && interp->level > interp->maxDepth)\n        rc = Jsi_LogError(\"Exceeded call depth: %d\", interp->level);\n    \n    while(ip < end && rc == JSI_OK) {\n        int plop = ip->op;\n\n        if (ip->logflag) { // Mask out LogDebug, etc if not enabled.\n            interp->curIp = ip;\n            switch (ip->logflag) {\n                case jsi_Oplf_assert:\n                    if (!interp->asserts) {\n                        ip++;\n                        if (ip->logflag != jsi_Oplf_assert && (ip->op == OP_POP || ip->op == OP_RET))\n                            ip++;\n                        continue;\n                    }\n                    break;\n                case jsi_Oplf_debug:\n                    if (!interp->logOpts.Debug && !(interp->framePtr->logflag &(1<<jsi_Oplf_debug))) {\n                        ip++;\n                        if (ip->logflag != jsi_Oplf_debug && (ip->op == OP_POP || ip->op == OP_RET))\n                            ip++;\n                        continue;\n                    }\n                    break;\n                case jsi_Oplf_test:\n                    if (!interp->logOpts.Test && !(interp->framePtr->logflag &(1<<jsi_Oplf_test))) {\n                        ip++;\n                        if (ip->logflag != jsi_Oplf_test && (ip->op == OP_POP || ip->op == OP_RET))\n                            ip++;\n                        continue;\n                    }\n                    break;\n                case jsi_Oplf_trace:\n                    if (!interp->logOpts.Trace && !(interp->framePtr->logflag &(1<<jsi_Oplf_trace))) {\n                        ip++;\n                        if (ip->logflag != jsi_Oplf_trace && (ip->op == OP_POP || ip->op == OP_RET))\n                            ip++;\n                        continue;\n                    }\n                    break;\n                default:\n                    break;\n            }\n        }\n        if (interp->interrupted) {\n            if (!interp->framePtr->tryDepth) {\n                Jsi_LogError(\"program interrupted: function=%s\", interp->framePtr->funcName);\n                interp->interrupted = 0;\n            } else {\n                interp->interrupted++;\n            }\n            rc = JSI_ERROR;\n            break;\n        }\n        if (interp->exited) {\n            rc = JSI_ERROR;\n            break;\n        }\n        interp->opCnt++;\n        if (interp->maxOpCnt && interp->opCnt > interp->maxOpCnt) {\n            puts(\"EXEC CAP EXCEED\");\n            interp->maxOpCnt += 1000;\n            rc = Jsi_LogError(\"Exceeded execution cap: %d\", interp->opCnt);\n            interp->exited = 1;\n            interp->exitCode = 99;\n            break;\n        }\n        if (interp->traceOp) {\n            jsiDumpInstr(interp, ps, _this, trylist, ip, opcodes);\n        }\n        if (interp->parent && interp->busyCallback && (interp->opCnt%(interp->busyInterval<=0?100000:interp->busyInterval))==0) {\n            // Handle parent interp events.\n            if (jsi_FuncIsNoop(interp, interp->busyCallback))\n                Jsi_EventProcess(interp->parent, -1);\n            else {\n                Jsi_DString nStr;\n                Jsi_DSInit(&nStr);\n                Jsi_DSPrintf(&nStr, \"[\\\"#Interp_%d\\\", %d]\", interp->objId, interp->opCnt);//TODO: use actual time interval rather than opCnt.\n                if (Jsi_FunctionInvokeJSON(interp->parent, interp->busyCallback, Jsi_DSValue(&nStr), NULL) != JSI_OK)\n                    rc = JSI_ERROR;\n                Jsi_DSFree(&nStr);\n            }\n        }\n        ip->hit=1;\n#ifndef USE_STATIC_STACK\n        if ((interp->maxStack-interp->framePtr->Sp)<STACK_MIN_PAD)\n            jsiSetupStack(interp);\n#endif\n        jsiPush(interp,0);\n        interp->curIp = ip;\n        // Carry forward line/file info from previous OPs.\n        if (!ip->Line)\n            ip->Line = curLine;\n        else\n            curLine = ip->Line;\n        if (!ip->fname)\n            ip->fname = curFile;\n        else\n            curFile = ip->fname;\n        if (interp->debugOpts.hook) {\n            interp->framePtr->fileName = curFile;\n            interp->framePtr->line = curLine;\n            if ((rc = (*interp->debugOpts.hook)(interp, curFile, curLine, interp->framePtr->level, interp->curFunction, jsi_opcode_string(ip->op), ip, NULL)) != JSI_OK)\n                break;\n        }\n\n        switch(ip->op) {\n            case OP_NOP:\n            case OP_LASTOP:\n                break;\n            case OP_PUSHUND:\n                Jsi_ValueMakeUndef(interp, &_jsi_STACKIDX(interp->framePtr->Sp));\n                jsiPush(interp,1);\n                break;\n            case OP_PUSHNULL:\n                Jsi_ValueMakeNull(interp, &_jsi_STACKIDX(interp->framePtr->Sp));\n                jsiPush(interp,1);\n                break;\n            case OP_PUSHBOO:\n                Jsi_ValueMakeBool(interp, &_jsi_STACKIDX(interp->framePtr->Sp), (uintptr_t)ip->data);\n                jsiPush(interp,1);\n                break;\n            case OP_PUSHNUM:\n                Jsi_ValueMakeNumber(interp, &_jsi_STACKIDX(interp->framePtr->Sp), (*((Jsi_Number *)ip->data)));\n                jsiPush(interp,1);\n                break;\n            case OP_PUSHSTR: {\n                Jsi_Value **v = &_jsi_STACKIDX(interp->framePtr->Sp);\n                Jsi_ValueMakeStringKey(interp, v, (char*)ip->data);\n                interp->lastPushStr = Jsi_ValueString(interp, *v, NULL);\n                jsiPush(interp,1);\n                break;\n            }\n            case OP_PUSHVSTR: {\n                Jsi_String *s = (Jsi_String *)ip->data;\n                Jsi_Value **v = &_jsi_STACKIDX(interp->framePtr->Sp);\n                if (s->flags&1)\n                    jsi_ValueMakeBlobDup(interp,v, (uchar*)s->str, s->len);\n                else {\n                    Jsi_ValueMakeStringKey(interp, v, s->str);\n                    interp->lastPushStr = s->str;\n                }\n                jsiPush(interp,1);\n                break;\n            }\n            case OP_PUSHVAR: {\n                rc = jsi_PushVar(ps, ip, scope, currentScope, context_id);      \n                break;\n            }\n            case OP_PUSHFUN: {\n                jsi_PushFunc(ps, ip, scope, currentScope);\n                break;\n            }\n            case OP_NEWFCALL:\n                if (interp->maxUserObjs && interp->userObjCnt > interp->maxUserObjs) {\n                    rc = Jsi_LogError(\"Max 'new' count exceeded\");\n                    break;\n                }\n            case OP_FCALL: {\n                /* TODO: need reliable way to capture func string name to handle unknown functions.*/\n                int discard = ((ip+1)<end && ip[1].op == OP_POP);\n                switch (jsiEvalFunction(ps, ip, discard)) {        /* throw an execption */\n                    case JSI_OK: break;\n                    case JSI_BREAK:\n                        if (interp->framePtr->tryDepth<=0)\n                            interp->isHelp = 1;\n                        JSI_DO_THROW(\"help\");\n                        break;\n                    default:  \n                        JSI_DO_THROW(\"fcall\");\n                }\n                strict = interp->strict;\n                /* TODO: new Function return a function without scopechain, add here */\n                break;\n            }\n            case OP_SUBSCRIPT: {\n                rc = jsi_evalSubscript(interp, _jsi_TOQ, _jsi_TOP, ip, end, currentScope);\n                break;\n            }\n            case OP_ASSIGN: {\n                Jsi_Value *sval = _jsi_TOP, *dval = _jsi_TOQ;\n                bool globThis = (sval->vt == JSI_VT_OBJECT && sval->d.obj == interp->csc->d.obj);\n                if ((uintptr_t)ip->data == 1) {\n                    jsiVarDeref(interp,1);\n                    rc = jsi_ValueAssign(interp, dval, sval, lop);                    \n                    if (strict && sval->vt == JSI_VT_UNDEF)\n                        rc = jsi_ValueAssignCheck(interp, sval, lop);\n                    jsiPop(interp,1);\n                } else {\n                    jsiVarDeref(interp, 3);\n                    Jsi_Value *v3 = _jsi_STACKIDX(interp->framePtr->Sp-3);\n                    if (v3->vt == JSI_VT_OBJECT) {\n                        if (strict && sval->vt == JSI_VT_UNDEF)\n                            rc = jsi_ValueAssignCheck(interp, sval, lop);\n                        jsi_ValueObjKeyAssign(interp, v3, dval, sval, 0);\n                        jsi_ValueDebugLabel(sval, \"assign\", NULL);\n                    } else if (strict)\n                        rc = Jsi_LogError(\"assign to a non-exist object\");\n                    jsiClearStack(interp,3);\n                    Jsi_ValueCopy(interp,v3, sval);\n                    dval = v3;\n                    jsiPop(interp, 2);\n                }\n                if (interp->framePtr->level<=1 && globThis && rc == JSI_OK && dval && dval->vt == JSI_VT_VARIABLE) {\n                    dval = dval->d.lval;\n                    //printf(\"GLOBAL THIS: %p\\n\", dval);\n                    Jsi_HashSet(interp->genValueTbl, dval, dval);\n                }\n                break;\n            }\n            case OP_PUSHREG: {\n                Jsi_Obj *obj = Jsi_ObjNewType(interp, JSI_OT_REGEXP);\n                obj->d.robj = (Jsi_Regex *)ip->data;\n                Jsi_ValueMakeObject(interp, &_jsi_STACKIDX(interp->framePtr->Sp), obj);\n                jsiPush(interp,1);\n                break;\n            }\n            case OP_PUSHARG:\n                //Jsi_ValueCopy(interp,_jsi_STACKIDX(interp->framePtr->Sp), currentScope);\n                \n                if (!interp->framePtr->arguments) {\n                    interp->framePtr->arguments = Jsi_ValueNewObj(interp,\n                        Jsi_ObjNewArray(interp, currentScope->d.obj->arr, currentScope->d.obj->arrCnt, 0));\n                    Jsi_IncrRefCount(interp, interp->framePtr->arguments);\n                    if (interp->hasCallee) {\n                        Jsi_Value *callee = Jsi_ValueObjLookup(interp, currentScope, \"\\1callee\\1\", 0);\n                        if (callee)\n                            Jsi_ValueInsert(interp, interp->framePtr->arguments, \"\\1callee\\1\", callee, JSI_OM_DONTENUM);\n                    }\n                    // interp->framePtr->arguments->d.obj->__proto__ = interp->Object_prototype; // ecma\n                }\n                Jsi_ValueCopy(interp,_jsi_STACKIDX(interp->framePtr->Sp), interp->framePtr->arguments);\n                jsiPush(interp,1);\n                break;\n            case OP_PUSHTHS: { //TODO: Value copy can cause memory leak!\n                Jsi_Value *tval = _jsi_STACKIDX(interp->framePtr->Sp);\n                Jsi_ValueCopy(interp, tval, _this);\n                /*if (interp->csc == _this)\n                    Jsi_ValueDup2(interp, &tval, _this);\n                else\n                    Jsi_ValueCopy(interp, tval, _this);*/\n                jsiPush(interp,1);\n                break;\n            }\n            case OP_PUSHTOP:\n                Jsi_ValueCopy(interp,_jsi_STACKIDX(interp->framePtr->Sp), _jsi_TOP);\n                jsiPush(interp,1);\n                break;\n            case OP_UNREF:\n                jsiVarDeref(interp,1);\n                break;\n            case OP_PUSHTOP2: {\n                Jsi_Value *vp1 = _jsi_STACKIDX(interp->framePtr->Sp);\n                Jsi_Value *vp2 = _jsi_STACKIDX(interp->framePtr->Sp+1);\n                if (!vp1 || !vp2)\n                    rc = Jsi_LogError(\"Invalid lookup/push\");\n                else {\n                    Jsi_ValueCopy(interp, vp1, _jsi_TOQ);\n                    Jsi_ValueCopy(interp, vp2, _jsi_TOP);\n                    jsiPush(interp, 2);\n                }\n                break;\n            }\n            case OP_CHTHIS: {\n                if (ip->data) {\n                    int t = interp->framePtr->Sp - 2;\n                    Assert(t>=0);\n                    Jsi_Value *v = _jsi_THISIDX(t);\n                    jsiClearThis(interp, t);\n                    Jsi_ValueCopy(interp, v, _jsi_TOQ);\n                    if (v->vt == JSI_VT_VARIABLE) {\n                        Jsi_ValueCopy(interp, v, v->d.lval);\n                    }\n                    Jsi_ValueToObject(interp, v);\n                }\n                break;\n            }\n            case OP_LOCAL: {\n                Jsi_Value key = VALINIT, *kPtr = &key; // Note we use a string key so no reset needed.\n                Jsi_ValueMakeStringKey(interp, &kPtr, (char*)ip->data);\n                jsi_ValueObjKeyAssign(interp, currentScope, kPtr, NULL, JSI_OM_DONTENUM);\n                context_id = ps->_context_id++;\n                break;\n            }\n            case OP_POP: {\n                Jsi_Value *tval = _jsi_TOP;\n                if ((interp->evalFlags&JSI_EVAL_RETURN) && (ip+1) >= end && \n                (Jsi_ValueIsObjType(interp, tval, JSI_OT_ITER)==0 &&\n                Jsi_ValueIsObjType(interp, tval, JSI_OT_FUNCTION)==0)) {\n                    /* Interactive and last instruction is a pop: save result. */\n                    Jsi_ValueMove(interp, vret, tval); /*TODO***: correct ***/\n                    tval->vt = JSI_VT_UNDEF;\n                }\n                jsiPop(interp, (uintptr_t)ip->data);\n                break;\n            }\n            case OP_NEG:\n                jsiVarDeref(interp,1);\n                Jsi_ValueToNumber(interp, _jsi_TOP);\n                rc = _jsi_StrictChk(_jsi_TOP);\n                _jsi_TOP->d.num = -(_jsi_TOP->d.num);\n                break;\n            case OP_POS:\n                jsiVarDeref(interp,1);\n                Jsi_ValueToNumber(interp, _jsi_TOP);\n                rc = _jsi_StrictChk(_jsi_TOP);\n                break;\n            case OP_NOT: {\n                int val = 0;\n                jsiVarDeref(interp,1);\n                \n                val = Jsi_ValueIsTrue(interp, _jsi_TOP);\n                \n                jsiClearStack(interp,1);\n                Jsi_ValueMakeBool(interp, &_jsi_TOP, !val);\n                break;\n            }\n            case OP_BNOT: {\n                jsiVarDeref(interp,1);\n                jsi_ValueToOInt32(interp, _jsi_TOP);\n                rc = _jsi_StrictChk(_jsi_TOP);\n                _jsi_TOP->d.num = (Jsi_Number)(~((int)_jsi_TOP->d.num));\n                break;\n            }\n            case OP_ADD: {\n                jsiVarDeref(interp,2);\n                Jsi_Value *v, *v1 = _jsi_TOP, *v2 = _jsi_TOQ;\n                int l1, l2;\n                if (strict)\n                    if (Jsi_ValueIsUndef(interp, v1) || Jsi_ValueIsUndef(interp, v2)) {\n                        rc = Jsi_LogError(\"operand value to + is undefined\");\n                        break;\n                    }\n                char *s1 = Jsi_ValueString(interp, v1, &l1);\n                char *s2 = Jsi_ValueString(interp, v2, &l2);\n                if (s1 || s2) {\n                    char *str;\n                    if (!(s1 && s2)) {\n                        v = (s1 ? v2 : v1);\n                        jsi_ValueToPrimitive(interp, &v);\n                        Jsi_ValueToString(interp, v, NULL);\n                        str = Jsi_ValueString(interp, v, (s1?&l2:&l1));\n                        if (s1) s2 = str; else s1 = str;\n                    }\n                    Assert(l1>=0 && l1<=JSI_MAX_ALLOC_BUF);\n                    Assert(l2>=0 && l2<=JSI_MAX_ALLOC_BUF);\n                    str = (char*)Jsi_Malloc(l1+l2+1);\n                    memcpy(str, s2, l2);\n                    memcpy(str+l2, s1, l1);\n                    str[l1+l2] = 0;\n                    jsiClearStack(interp,2);\n                    Jsi_ValueMakeBlob(interp, &v2, (uchar*)str, l1+l2);\n                } else {\n                    Jsi_ValueToNumber(interp, v1);\n                    Jsi_ValueToNumber(interp, v2);\n                    rc = _jsi_StrictChk2(v1, v2);\n                    Jsi_Number n = v1->d.num + v2->d.num;\n                    jsiClearStack(interp,2);\n                    Jsi_ValueMakeNumber(interp, &v2, n);\n                }\n                jsiPop(interp,1);\n                break;\n            }\n            case OP_IN: {\n                Jsi_Value *v, *vl;\n                const char *cp = NULL;\n                Jsi_Number nval;\n                jsiVarDeref(interp,2);\n                vl = _jsi_TOQ;\n                v = _jsi_TOP;\n                if (Jsi_ValueIsString(interp,vl))\n                    cp = Jsi_ValueGetStringLen(interp, vl, NULL);\n                else if (Jsi_ValueIsNumber(interp,vl))\n                    Jsi_ValueGetNumber(interp, vl, &nval);\n                else {\n                    if (strict)\n                        Jsi_LogWarn(\"expected string or number before IN\");\n                    Jsi_ValueMakeBool(interp, &_jsi_TOQ, 0);\n                    jsiPop(interp,1);\n                    break;\n                }\n                \n                if (v->vt == JSI_VT_VARIABLE) {\n                    v = v->d.lval;\n                    SIGASSERT(v, VALUE);\n                }\n                if (v->vt != JSI_VT_OBJECT || v->d.obj->ot != JSI_OT_OBJECT) {\n                    if (strict)\n                        Jsi_LogWarn(\"expected object after IN\");\n                    Jsi_ValueMakeBool(interp, &_jsi_TOQ, 0);\n                    jsiPop(interp,1);\n                    break;\n                }\n                int bval = 0;\n                char nbuf[100];\n                Jsi_Value *vv;\n                Jsi_Obj *obj = v->d.obj;\n                if (!cp) {\n                    snprintf(nbuf, sizeof(nbuf), \"%d\", (int)nval);\n                    cp = nbuf;\n                }\n                if (obj->arr) {\n                    vv = jsi_ObjArrayLookup(interp, obj, (char*)cp);\n                } else {\n                    vv = Jsi_TreeObjGetValue(obj, (char*)cp, 1);\n                }\n                bval = (vv != 0);\n                Jsi_ValueMakeBool(interp, &_jsi_TOQ, bval);\n                jsiPop(interp,1);\n                break;\n            }\n            case OP_SUB: \n                common_math_opr(-); break;\n            case OP_MUL:\n                common_math_opr(*); break;\n            case OP_DIV:\n                common_math_opr(/); break;\n            case OP_MOD: {\n                jsiVarDeref(interp,2);\n                if (!Jsi_ValueIsType(interp,_jsi_TOP, JSI_VT_NUMBER))\n                    Jsi_ValueToNumber(interp, _jsi_TOP);\n                if (!Jsi_ValueIsType(interp,_jsi_TOQ, JSI_VT_NUMBER))\n                    Jsi_ValueToNumber(interp, _jsi_TOQ);\n                rc = _jsi_StrictChk2(_jsi_TOP,_jsi_TOQ);\n                if (rc == JSI_OK)\n                    _jsi_TOQ->d.num = fmod(_jsi_TOQ->d.num, _jsi_TOP->d.num);\n                jsiPop(interp,1);\n                break;\n            }\n            case OP_LESS:\n                jsiVarDeref(interp,2);\n                rc = jsi_logic_less(interp,2,1);\n                jsiPop(interp,1);\n                break;\n            case OP_GREATER:\n                jsiVarDeref(interp,2);\n                rc = jsi_logic_less(interp,1,2);\n                jsiPop(interp,1);\n                break;\n            case OP_LESSEQU:\n                jsiVarDeref(interp,2);\n                rc = jsi_logic_less(interp,1,2);\n                if (rc == JSI_OK)\n                    _jsi_TOQ->d.val = !_jsi_TOQ->d.val;\n                jsiPop(interp,1);\n                break;\n            case OP_GREATEREQU:\n                jsiVarDeref(interp,2);\n                rc = jsi_logic_less(interp,2,1);\n                if (rc == JSI_OK)\n                    _jsi_TOQ->d.val = !_jsi_TOQ->d.val;\n                jsiPop(interp,1);\n                break;\n            case OP_EQUAL:\n            case OP_NOTEQUAL: {\n                jsiVarDeref(interp,2);\n                int r = Jsi_ValueCmp(interp, _jsi_TOP, _jsi_TOQ, 0);\n                r = (ip->op == OP_EQUAL ? !r : r);\n                jsiClearStack(interp,2);\n                Jsi_ValueMakeBool(interp, &_jsi_TOQ, r);\n                jsiPop(interp,1);\n                break;\n            }\n            case OP_STRICTEQU:\n            case OP_STRICTNEQ: {\n                int r = 0;\n                jsiVarDeref(interp,2);\n                rc = _jsi_StrictUChk3(_jsi_TOQ, _jsi_TOP);\n                r = !Jsi_ValueIsEqual(interp, _jsi_TOP, _jsi_TOQ);\n                r = (ip->op == OP_STRICTEQU ? !r : r);\n                jsiClearStack(interp,2);\n                Jsi_ValueMakeBool(interp, &_jsi_TOQ, r);\n                jsiPop(interp,1);\n                break;\n            }\n            case OP_BAND: \n                common_bitwise_opr(&); break;\n            case OP_BOR:\n                common_bitwise_opr(|); break;\n            case OP_BXOR:\n                common_bitwise_opr(^); break;\n            case OP_SHF: {\n                jsiVarDeref(interp,2);\n                jsi_ValueToOInt32(interp, _jsi_TOQ);\n                jsi_ValueToOInt32(interp, _jsi_TOP);\n                int t1 = (int)_jsi_TOQ->d.num;\n                int t2 = ((unsigned int)_jsi_TOP->d.num) & 0x1f;\n                if (ip->data) {                 /* shift right */\n                    if ((uintptr_t)ip->data == 2) {   /* unsigned shift */\n                        unsigned int t3 = (unsigned int)t1;\n                        t3 >>= t2;\n                        Jsi_ValueMakeNumber(interp, &_jsi_TOQ, t3);\n                    } else {\n                        t1 >>= t2;\n                        Jsi_ValueMakeNumber(interp, &_jsi_TOQ, t1);\n                    }\n                } else {\n                    t1 <<= t2;\n                    Jsi_ValueMakeNumber(interp, &_jsi_TOQ, t1);\n                }\n                jsiPop(interp,1);\n                break;\n            }\n            case OP_KEY: {\n                jsiVarDeref(interp,1);\n                if (ip->isof && !Jsi_ValueIsArray(interp, _jsi_TOP)) {\n                    rc = Jsi_LogError(\"operand not an array\");\n                    break;\n                }\n                if (_jsi_TOP->vt != JSI_VT_UNDEF && _jsi_TOP->vt != JSI_VT_NULL)\n                    Jsi_ValueToObject(interp, _jsi_TOP);\n                Jsi_Value *spret = Jsi_ValueNew1(interp);\n                jsi_ValueObjGetKeys(interp, _jsi_TOP, spret, ip->isof);\n                Jsi_ValueReplace(interp, _jsi_STACK+interp->framePtr->Sp, spret);  \n                Jsi_DecrRefCount(interp, spret);  \n                jsiPush(interp,1);\n                break;\n            }\n            case OP_NEXT: {\n                Jsi_Value *toq = _jsi_TOQ, *top = _jsi_TOP;\n                if (toq->vt != JSI_VT_OBJECT || toq->d.obj->ot != JSI_OT_ITER) Jsi_LogBug(\"next: toq not a iter\\n\");\n                if (top->vt != JSI_VT_VARIABLE) {\n                    rc = Jsi_LogError (\"invalid for/in left hand-side\");\n                    break;\n                }\n                if (strict && top->f.bits.local==0) {\n                    const char *varname = \"\";\n                    Jsi_Value *v = top->d.lval;\n                    if (v->f.bits.lookupfailed)\n                        varname = v->d.lookupFail;\n\n                    rc = Jsi_LogError(\"function created global: \\\"%s\\\"\", varname);\n                    break;\n                }\n                \n                Jsi_IterObj *io = toq->d.obj->d.iobj;\n                if (io->iterCmd) {\n                    io->iterCmd(io, top, _jsi_STACKIDX(interp->framePtr->Sp-3), io->iter++);\n                } else {\n                    while (io->iter < io->count) {\n                        if (!io->isArrayList) {\n                            if (Jsi_ValueKeyPresent(interp, _jsi_STACKIDX(interp->framePtr->Sp-3), io->keys[io->iter],1)) \n                                break;\n                        } else {\n                            while (io->cur < io->obj->arrCnt) {\n                                if (io->obj->arr[io->cur]) break;\n                                io->cur++;\n                            }\n                            if (io->cur >= io->obj->arrCnt) {\n                                /* TODO: Is this really a bug??? */\n                                /* Jsi_LogBug(\"NOT FOUND LIST ARRAY\");*/\n                                io->iter = io->count;\n                                break;\n                            } else if (io->obj->arr[io->cur]) {\n                                io->cur++;\n                                break;\n                            }\n                        }\n                        io->iter++;\n                    }\n                    if (io->iter >= io->count) {\n                        jsiClearStack(interp,1);\n                        Jsi_ValueMakeNumber(interp, &_jsi_TOP, 0);\n                    } else {\n                        Jsi_Value **vPtr = &_jsi_TOP->d.lval, *v = *vPtr;\n                        SIGASSERT(v, VALUE);\n                        Jsi_ValueReset(interp, vPtr);\n                        if (io->isArrayList) {\n                            if (!io->isof)\n                                Jsi_ValueMakeNumber(interp, &v, io->cur-1);\n                            else if (!io->obj->arr[io->cur-1])\n                                Jsi_ValueMakeNull(interp, &v);\n                            else\n                                Jsi_ValueCopy(interp, v, io->obj->arr[io->cur-1]);\n                        } else\n                            Jsi_ValueMakeStringKey(interp, &v, io->keys[io->iter]);\n                        io->iter++;\n                        \n                        jsiClearStack(interp,1);\n                        Jsi_ValueMakeNumber(interp, &_jsi_TOP, 1);\n                    }\n                    break;\n                }\n            }\n            case OP_INC:\n            case OP_DEC: {\n                int inc = ip->op == OP_INC ? 1 : -1;\n                \n                if (_jsi_TOP->vt != JSI_VT_VARIABLE) {\n                    rc = Jsi_LogError(\"operand not left value\");\n                    break;\n                }\n                Jsi_Value *v = _jsi_TOP->d.lval;\n                SIGASSERT(v, VALUE);\n                Jsi_ValueToNumber(interp, v);\n                rc = _jsi_StrictChk(v);\n                v->d.num += inc;\n                    \n                jsiVarDeref(interp,1);\n                if (ip->data) {\n                    _jsi_TOP->d.num -= inc;\n                }\n                break;\n            }\n            case OP_TYPEOF: {\n                const char *typ;\n                Jsi_Value *v = _jsi_TOP;\n                if (v->vt == JSI_VT_VARIABLE) {\n                    v = v->d.lval;\n                    SIGASSERT(v, VALUE);\n                }\n                typ = Jsi_ValueTypeStr(interp, v);\n                jsiVarDeref(interp,1);\n                Jsi_ValueMakeStringKey(interp, &_jsi_TOP, (char*)typ);\n                break;\n            }\n            case OP_INSTANCEOF: {\n\n                jsiVarDeref(interp,2);\n                int bval = Jsi_ValueInstanceOf(interp, _jsi_TOQ, _jsi_TOP);\n                jsiPop(interp,1);\n                Jsi_ValueMakeBool(interp, &_jsi_TOP, bval);\n                break;\n            }\n            case OP_JTRUE:\n            case OP_JFALSE: \n            case OP_JTRUE_NP:\n            case OP_JFALSE_NP: {\n                jsiVarDeref(interp,1);\n                int off = (uintptr_t)ip->data - 1; \n                int r = Jsi_ValueIsTrue(interp, _jsi_TOP);\n                \n                if (ip->op == OP_JTRUE || ip->op == OP_JFALSE) jsiPop(interp,1);\n                ip += ((ip->op == OP_JTRUE || ip->op == OP_JTRUE_NP) ^ r) ? 0 : off;\n                break;\n            }\n            case OP_JMPPOP: \n                jsiPop(interp, ((jsi_JmpPopInfo *)ip->data)->topop);\n            case OP_JMP: {\n                int off = (ip->op == OP_JMP ? (uintptr_t)ip->data - 1\n                            : (uintptr_t)((jsi_JmpPopInfo *)ip->data)->off - 1);\n\n                while (1) {\n                    if (trylist == NULL) break;\n                    jsi_OpCode *tojmp = ip + off;\n\n                    /* jmp out of a try block, should execute the finally block */\n                    /* while jmp out a 'with' block, restore the scope */\n\n                    if (trylist->type == jsi_TL_TRY) { \n                        if (tojmp >= trylist->d.td.tstart && tojmp < trylist->d.td.fend) break;\n                        \n                        if (ip >= trylist->d.td.tstart && ip < trylist->d.td.cend) {\n                            trylist->d.td.last_op = jsi_LOP_JMP;\n                            trylist->d.td.ld.tojmp = tojmp;\n                            \n                            ip = trylist->d.td.fstart - 1;\n                            off = 0;\n                            break;\n                        } else if (ip >= trylist->d.td.fstart && ip < trylist->d.td.fend) {\n                            pop_try(trylist);\n                        } else Jsi_LogBug(\"jmp within a try, but not in its scope?\");\n                    } else {\n                        /* with block */\n                        \n                        if (tojmp >= trylist->d.wd.wstart && tojmp < trylist->d.wd.wend) break;\n                        \n                        JSI_RESTORE_SCOPE();\n                        pop_try(trylist);\n                    }\n                }\n                \n                ip += off;\n                break;\n            }\n            case OP_EVAL: {\n                int stackargc = (uintptr_t)ip->data;\n                jsiVarDeref(interp, stackargc);\n\n                int r = 0;\n                Jsi_Value *spPtr = Jsi_ValueNew1(interp);\n                if (stackargc > 0) {\n                    if (_jsi_STACKIDX(interp->framePtr->Sp - stackargc)->vt == JSI_VT_UNDEF) {\n                        Jsi_LogError(\"undefined value to eval()\");\n                        goto undef_eval;\n                    }\n                    int plen;\n                    char *pro = Jsi_ValueString(interp, _jsi_STACKIDX(interp->framePtr->Sp - stackargc), &plen);\n                    if (pro) {\n                        pro = Jsi_StrdupLen(pro, plen);\n                        r = jsiEvalOp(interp, ps, pro, scope, currentScope, _this, &spPtr);\n                        Jsi_Free(pro);\n                    } else {\n                        Jsi_ValueCopy(interp, spPtr, _jsi_STACKIDX(interp->framePtr->Sp - stackargc));\n                    }\n                }\nundef_eval:\n                jsiPop(interp, stackargc);\n                Jsi_ValueCopy(interp, _jsi_STACK[interp->framePtr->Sp], spPtr); /*TODO: is this correct?*/\n                Jsi_DecrRefCount(interp, spPtr);\n                jsiPush(interp,1);\n\n                if (r) {\n                    JSI_DO_THROW(\"eval\");\n                }\n                break;\n            }\n            case OP_RET: {\n                if (interp->framePtr->Sp>=1 && ip->data) {\n                    jsiVarDeref(interp,1);\n                    Jsi_ValueMove(interp, vret, _jsi_TOP);\n                }\n                jsiPop(interp, (uintptr_t)ip->data);\n                interp->didReturn = 1;\n                if (trylist) {\n                    while (trylist) {\n                        if (trylist->type == jsi_TL_TRY && trylist->inCatch)\n                            JSI_RESTORE_SCOPE();\n                        pop_try(trylist);\n                    }\n                    goto done;\n                }\n                ip = end;\n                break;\n            }\n            case OP_DELETE: {\n                int count = (uintptr_t)ip->data;\n                if (count == 1) { // Non-standard.\n                    if (_jsi_TOP->vt != JSI_VT_VARIABLE)\n                        rc = Jsi_LogError(\"delete a right value\");\n                    else {\n                        Jsi_Value **vPtr = &_jsi_TOP->d.lval, *v = *vPtr;\n                        SIGASSERT(v, VALUE);\n                        if (v->f.bits.dontdel) {\n                            if (strict) rc = Jsi_LogWarn(\"delete not allowed\");\n                        } else if (v != currentScope) {\n                            Jsi_ValueReset(interp,vPtr);     /* not allow to delete arguments */\n                        }\n                        else if (strict)\n                            Jsi_LogWarn(\"Delete arguments\");\n                    }\n                    jsiPop(interp,1);\n                } else if (count == 2) {\n                    jsiVarDeref(interp,2);\n                    assert(interp->framePtr->Sp>=2);\n                    if (strict) {\n                        if (_jsi_TOQ->vt != JSI_VT_OBJECT) Jsi_LogWarn(\"delete non-object key, ignore\");\n                        if (_jsi_TOQ->d.obj == currentScope->d.obj) Jsi_LogWarn(\"Delete arguments\");\n                    }\n                    jsi_ValueObjDelete(interp, _jsi_TOQ, _jsi_TOP, 0);\n                    \n                    jsiPop(interp,2);\n                } else Jsi_LogBug(\"delete\");\n                break;\n            }\n            case OP_OBJECT: {\n                int itemcount = (uintptr_t)ip->data;\n                Assert(itemcount>=0);\n                jsiVarDeref(interp, itemcount * 2);\n                Jsi_Obj *obj = Jsi_ObjNewObj(interp, _jsi_STACK+(interp->framePtr->Sp-itemcount*2), itemcount*2);\n                jsiPop(interp, itemcount * 2 - 1);       /* one left */\n                jsiClearStack(interp,1);\n                Jsi_ValueMakeObject(interp, &_jsi_TOP, obj);\n                break;\n            }\n            case OP_ARRAY: {\n                int itemcount = (uintptr_t)ip->data;\n                Assert(itemcount>=0);\n                jsiVarDeref(interp, itemcount);\n                Jsi_Obj *obj = Jsi_ObjNewArray(interp, _jsi_STACK+(interp->framePtr->Sp-itemcount), itemcount, 1);\n                jsiPop(interp, itemcount - 1);\n                jsiClearStack(interp,1);\n                Jsi_ValueMakeObject(interp, &_jsi_TOP, obj);\n                break;\n            }\n            case OP_STRY: {\n                jsi_TryInfo *ti = (jsi_TryInfo *)ip->data;\n                jsi_TryList *n = jsi_trylist_new(jsi_TL_TRY, scope, currentScope);\n                \n                n->d.td.tstart = ip;                            /* make every thing pointed to right pos */\n                n->d.td.tend = n->d.td.tstart + ti->trylen;\n                n->d.td.cstart = n->d.td.tend + 1;\n                n->d.td.cend = n->d.td.tend + ti->catchlen;\n                n->d.td.fstart = n->d.td.cend + 1;\n                n->d.td.fend = n->d.td.cend + ti->finallen;\n                n->d.td.tsp = interp->framePtr->Sp;\n                n->inCatch=0;\n                n->inFinal=0;\n\n                jsi_push_try(interp, &trylist, n);\n                break;\n            }\n            case OP_ETRY: {             /* means nothing happen go to final */\n                if (trylist == NULL || trylist->type != jsi_TL_TRY)\n                    Jsi_LogBug(\"Unexpected ETRY opcode??\");\n\n                ip = trylist->d.td.fstart - 1;\n                break;\n            }\n            case OP_SCATCH: {\n                if (trylist == NULL || trylist->type != jsi_TL_TRY) \n                    Jsi_LogBug(\"Unexpected SCATCH opcode??\");\n\n                if (!ip->data) {\n                    JSI_DO_THROW(\"catch\");\n                } else {\n                    trylist->inCatch=1;\n                    /* new scope and make var */\n                    scope = jsi_ScopeChainDupNext(interp, scope, currentScope);\n                    currentScope = jsi_ObjValueNew(interp);\n                    interp->framePtr->ingsc = scope;  //TODO: changing frame\n                    interp->framePtr->incsc = currentScope;\n                    Jsi_IncrRefCount(interp, currentScope);\n                    Jsi_Value *excpt = Jsi_ValueNew1(interp);\n                    if (ps->last_exception && ps->last_exception->vt != JSI_VT_UNDEF) {\n                        //TODO: fix test262 crash in freeValueTbl@jsiInterp.c:565 for last_exception which is\n                        // freed in jsi_PstateFree@jsiPstate.c:251. Is this code the problem?\n                        Jsi_Value *ple = ps->last_exception;\n                        Jsi_ValueCopy(interp, excpt, ple);\n                        Jsi_ValueReset(interp, &ps->last_exception);\n                    } else if (interp->errMsgBuf[0]) {\n                        Jsi_ValueMakeStringDup(interp, &excpt, interp->errMsgBuf);\n                        interp->errMsgBuf[0] = 0;\n                    }\n                    Jsi_ValueInsert(interp, currentScope, (char*)ip->data, excpt, JSI_OM_DONTENUM);\n                    Jsi_DecrRefCount(interp, excpt);\n                    context_id = ps->_context_id++;\n                }\n                break;\n            }\n            case OP_ECATCH: {\n                if (trylist == NULL || trylist->type != jsi_TL_TRY)\n                    Jsi_LogBug(\"Unexpected ECATCH opcode??\");\n\n                trylist->inCatch=0;\n                ip = trylist->d.td.fstart - 1;\n                break;\n            }\n            case OP_SFINAL: {\n                if (trylist == NULL || trylist->type != jsi_TL_TRY)\n                    Jsi_LogBug(\"Unexpected SFINAL opcode??\");\n\n                /* restore scatch scope chain */\n                trylist->inFinal = 1;\n                JSI_RESTORE_SCOPE();\n                break;\n            }\n            case OP_EFINAL: {\n                if (trylist == NULL || trylist->type != jsi_TL_TRY)\n                    Jsi_LogBug(\"Unexpected EFINAL opcode??\");\n\n                trylist->inFinal = 0;\n                int last_op = trylist->d.td.last_op;\n                jsi_OpCode *tojmp = (last_op == jsi_LOP_JMP ? trylist->d.td.ld.tojmp : 0);\n                \n                pop_try(trylist);\n\n                if (last_op == jsi_LOP_THROW) {\n                    JSI_DO_THROW(\"finally\");\n                } else if (last_op == jsi_LOP_JMP) {\n                    while (1) {\n                        if (trylist == NULL) {\n                            ip = tojmp;\n                            break;\n                        }\n                        /* same as jmp opcode, see above */\n                        if (trylist->type == jsi_TL_TRY) {\n                            if (tojmp >= trylist->d.td.tstart && tojmp < trylist->d.td.fend) {\n                                ip = tojmp;\n                                break;\n                            }\n                            \n                            if (ip >= trylist->d.td.tstart && ip < trylist->d.td.cend) {\n                                trylist->d.td.last_op = jsi_LOP_JMP;\n                                trylist->d.td.ld.tojmp = tojmp;\n                                \n                                ip = trylist->d.td.fstart - 1;\n                                break;\n                            } else if (ip >= trylist->d.td.fstart && ip < trylist->d.td.fend) {\n                                pop_try(trylist);\n                            } else Jsi_LogBug(\"jmp within a try, but not in its scope?\");\n                        } else {        /* 'with' block */\n                            if (tojmp >= trylist->d.wd.wstart && tojmp < trylist->d.wd.wend) {\n                                ip = tojmp;\n                                break;\n                            }\n                            JSI_RESTORE_SCOPE();\n                            pop_try(trylist);\n                        }\n                    }\n                }\n                break;\n            }\n            case OP_THROW: {\n                jsiVarDeref(interp,1);\n                Jsi_ValueDup2(interp,&ps->last_exception, _jsi_TOP);\n                interp->didReturn = 1; /* TODO: could possibly hide _jsi_STACK problem */\n                JSI_DO_THROW(\"throw\");\n                break;\n            }\n            case OP_WITH: {\n                static int warnwith = 1;\n                if (strict && warnwith && interp->typeCheck.nowith) {\n                    warnwith = 0;\n                    rc = Jsi_LogError(\"use of with is illegal due to \\\"use nowith\\\"\");\n                    break;\n                }\n                jsiVarDeref(interp,1);\n                Jsi_ValueToObject(interp, _jsi_TOP);\n                \n                jsi_TryList *n = jsi_trylist_new(jsi_TL_WITH, scope, currentScope);\n                \n                n->d.wd.wstart = ip;\n                n->d.wd.wend = n->d.wd.wstart + (uintptr_t)ip->data;\n\n                jsi_push_try(interp, &trylist, n);\n                interp->framePtr->withDepth++;\n                \n                /* make expr to top of scope chain */\n                scope = jsi_ScopeChainDupNext(interp, scope, currentScope);\n                currentScope = Jsi_ValueNew1(interp);\n                interp->framePtr->ingsc = scope;\n                interp->framePtr->incsc = currentScope;\n                Jsi_ValueCopy(interp, currentScope, _jsi_TOP);\n                jsiPop(interp,1);\n                \n                context_id = ps->_context_id++;\n                break;\n            }\n            case OP_EWITH: {\n                if (trylist == NULL || trylist->type != jsi_TL_WITH)\n                    Jsi_LogBug(\"Unexpected EWITH opcode??\");\n\n                JSI_RESTORE_SCOPE();\n                \n                pop_try(trylist);\n                interp->framePtr->withDepth--;\n                break;\n            }\n            case OP_DEBUG: {\n                jsi_DebuggerStmt();\n                jsiPush(interp,1);\n                break;\n            }\n            case OP_RESERVED: {\n                jsi_ReservedInfo *ri = (jsi_ReservedInfo *)ip->data;\n                const char *cmd = ri->type == RES_CONTINUE ? \"continue\" : \"break\";\n                /* TODO: continue/break out of labeled scope: see tests/prob/break.jsi. */\n                if (ri->label) {\n                    Jsi_LogError(\"%s: label(%s) not found\", cmd, ri->label);\n                } else {\n                    Jsi_LogError(\"%s must be inside loop(or switch)\", cmd);\n                }\n                rc = JSI_ERROR;\n                break;\n            }\n#ifndef __cplusplus\n            default:\n                Jsi_LogBug(\"invalid op ceod: %d\", ip->op);\n#endif\n        }\n        lop = plop;\n        ip++;\n    }\ndone:\n    while (trylist) {\n        JSI_RESTORE_SCOPE();\n        pop_try(trylist);\n    }\n    return rc;\n}\n\n// Bottom-most eval() routine creates stack frame.\nJsi_RC jsi_evalcode(jsi_Pstate *ps, Jsi_Func *func, Jsi_OpCodes *opcodes, \n         jsi_ScopeChain *scope, Jsi_Value *fargs,\n         Jsi_Value *_this,\n         Jsi_Value **vret)\n{\n    Jsi_Interp *interp = ps->interp;\n    if (interp->exited)\n        return JSI_ERROR;\n    Jsi_RC rc;\n    jsi_Frame frame = *interp->framePtr;\n    frame.parent = interp->framePtr;\n    interp->framePtr = &frame;\n    frame.parent->child = interp->framePtr = &frame;\n    frame.ps = ps;\n    frame.ingsc = scope;\n    frame.incsc = fargs;\n    frame.inthis = _this;\n    frame.opcodes = opcodes;\n    frame.fileName = ((func && func->script)?func->script:interp->curFile);\n    frame.funcName = interp->curFunction;\n    frame.dirName = interp->curDir;\n    if (frame.fileName && frame.fileName == frame.parent->fileName)\n        frame.logflag = frame.parent->logflag;\n    else\n        frame.logflag = 0;\n    frame.level = frame.parent->level+1;\n    frame.evalFuncPtr = func;\n    frame.arguments = NULL;\n   // if (func && func->strict)\n    //    frame.strict = 1;\n    if (interp->curIp)\n        frame.parent->line = interp->curIp->Line;\n    frame.ip = interp->curIp;\n    interp->refCount++;\n    interp->level++;\n    Jsi_IncrRefCount(interp, fargs);\n    rc = jsi_evalcode_sub(ps, opcodes, scope, fargs, _this, *vret);\n    Jsi_DecrRefCount(interp, fargs);\n    if (interp->didReturn == 0 && !interp->exited) {\n        if ((interp->evalFlags&JSI_EVAL_RETURN)==0)\n            Jsi_ValueMakeUndef(interp, vret);\n        /*if (interp->framePtr->Sp != oldSp) //TODO: at some point after memory refs???\n            Jsi_LogBug(\"Stack not balance after execute script\");*/\n    }\n    if (frame.arguments)\n        Jsi_DecrRefCount(interp, frame.arguments);\n    interp->didReturn = 0;\n    interp->refCount--;\n    interp->level--;\n    interp->framePtr = frame.parent;\n    interp->framePtr->child = NULL;\n    interp->curIp = frame.ip;\n    if (interp->exited)\n        rc = JSI_ERROR;\n    return rc;\n}\n\nJsi_RC jsi_JsPreprocessLine(Jsi_Interp* interp, char *buf, size_t bsiz, uint ilen, int jOpts[4], int lineNo) {\n    if (buf[0]==';' && buf[1] && buf[2]) {\n        // Wrap \";XXX;\" in a puts(\"XXX ==> \", XXX)\n        if (!jOpts[0]) {\n            if (!Jsi_Strcmp(buf, \"=!EXPECTSTART!=\\n\") || !Jsi_Strcmp(buf, \"=!INPUTSTART!=\\n\") ) {\n                return JSI_OK;\n            }\n        } else {\n            if (!Jsi_Strcmp(buf, \"=!EXPECTEND!=\\n\") || !Jsi_Strcmp(buf, \"=!INPUTEND!=\\n\")) {\n                jOpts[0] = 0;\n                return JSI_OK;\n            }\n        }\n        if (buf[ilen-1]=='\\n' && buf[ilen-2]==';' && (2*ilen+12)<bsiz) {\n            if (Jsi_Strchr(buf, '`')) {\n                return Jsi_LogError(\"back-tick is illegal in unitTest on line %d: %s\", lineNo, buf);\n            }\n            char ubuf[bsiz], *ucp = ubuf;\n            buf[ilen-=2] = 0;\n            Jsi_Strcpy(ubuf, buf+1);\n            while (*ucp && isspace(*ucp)) ucp++;\n            if (ilen>2 && ucp[0]=='\\'' && ubuf[ilen-2]=='\\'')\n                snprintf(buf, bsiz, \"puts(`%s`);\\n\", ucp); //output a 'Comment'\n                \n            else if (interp->debugOpts.testFmtCallback) {\n                Jsi_DString kStr={};\n                Jsi_Value *vrc = Jsi_ValueNew1(interp);\n                Jsi_DSPrintf(&kStr, \"[\\\"%s\\\", %d ]\", ucp, lineNo);\n                Jsi_RC rcs = Jsi_FunctionInvokeJSON(interp->parent, interp->debugOpts.testFmtCallback, Jsi_DSValue(&kStr), &vrc);\n                if (rcs == JSI_OK) {\n                    const char *cps = Jsi_ValueString(interp, vrc, NULL);\n                    if (!cps)\n                        rcs = JSI_ERROR;\n                    else\n                        snprintf(buf, bsiz, \"%s\", cps);\n                }\n                Jsi_DecrRefCount(interp, vrc);\n                Jsi_DSFree(&kStr);\n                if (rcs != JSI_OK)\n                    return Jsi_LogError(\"failure in debugOpts.testFmtCallback\");\n            } else if (ilen>3 && ubuf[0]=='/' && ubuf[0]=='/') {\n                char *ecp = ubuf+2;\n                while (*ecp && isspace(*ecp)) ecp++;\n                snprintf(buf, bsiz, \"printf(`%%s ==>`, \\\"%s\\\"); try { %s; puts('\\\\nFAIL!\\\\n'); } \"\n                    \"catch(err) { puts('\\\\nPASS!: err =',err); }\\n\", ecp, ecp);\n            } else {\n                snprintf(buf, bsiz, \"printf(`%%s ==> `,`%s`),puts(%s);\\n\", ucp, ucp);\n            }\n        }\n    }\n    return JSI_OK;\n}\n\nJsi_RC jsi_JsPreprocessLineCB(Jsi_Interp* interp, char *buf, size_t bsiz, uint ilen, int jOpts[4], int lineNo) {\n    const char *jpp = interp->jsppChars;\n    if (!jpp[0] || !jpp[1])\n        return JSI_OK;\n    if (buf[0] && jpp[0] == buf[0] && ilen>2 && buf[ilen-2]==jpp[1]) {\n        Jsi_DString dStr = {};\n        buf[ilen-2] = 0; // Remove last char and newline.\n        Jsi_Value *inStr = Jsi_ValueNewStringDup(interp, buf+1);\n        Jsi_IncrRefCount(interp, inStr);\n        Jsi_RC rc = Jsi_FunctionInvokeString(interp, interp->jsppCallback, inStr, &dStr);\n        if (Jsi_InterpGone(interp))\n            return JSI_ERROR;\n        if (rc != JSI_OK) {\n            Jsi_DSFree(&dStr);\n            Jsi_DecrRefCount(interp, inStr);\n            return JSI_ERROR;\n        }\n        Jsi_DecrRefCount(interp, inStr);\n        Jsi_DSAppendLen(&dStr, \"\\n\", 1);\n        Jsi_Strncpy(buf, Jsi_DSValue(&dStr), bsiz);\n        buf[bsiz-1] = 0;\n        Jsi_DSFree(&dStr);\n    }\n    return JSI_OK;\n}\n\nJsi_RC jsi_evalStrFile(Jsi_Interp* interp, Jsi_Value *path, const char *str, int flags, int level)\n{\n    Jsi_Channel tinput = NULL, input = Jsi_GetStdChannel(interp, 0);\n    Jsi_Value *npath = path;\n    Jsi_RC rc = JSI_ERROR;\n    const char *ustr = NULL, *ostr = str;\n    if (Jsi_MutexLock(interp, interp->Mutex) != JSI_OK)\n        return rc;\n    int oldSp, uskip = 0, fncOfs = 0, fnLen;\n    int oldef = interp->evalFlags;\n    jsi_Pstate *oldps = interp->ps;\n    const char *oldFile = interp->curFile;\n    char *origFile = Jsi_ValueString(interp, path, &fnLen);\n    const char *fname = origFile;\n    char *oldDir = interp->curDir, *cp;\n    char dirBuf[PATH_MAX];\n    jsi_Pstate *ps = NULL;\n    jsi_FileInfo *fi = NULL;\n    int exists = (flags&JSI_EVAL_EXISTS);\n    int ignore = (flags&JSI_EVAL_ERRIGNORE);\n    if (flags & JSI_EVAL_GLOBAL)\n        level = 1;\n    int oisi = interp->isMain;\n    if (flags & JSI_EVAL_ISMAIN)\n        interp->isMain = 1;\n    \n    oldSp = interp->framePtr->Sp;\n    dirBuf[0] = 0;\n    Jsi_DString dStr, fStr;\n    Jsi_DSInit(&dStr);\n    Jsi_DSInit(&fStr);\n\n    if (str == NULL) {\n        if (fname != NULL) {\n            if (fnLen>2 && fname[fnLen-1]=='/') {\n                Jsi_DSAppendLen(&fStr, fname, fnLen-1);\n                const char *fcp = Jsi_DSValue(&fStr), *fce = strrchr(fcp,'/');\n                if (fce) {\n                    fname = Jsi_DSAppend(&fStr, fce, \".jsi\", NULL);\n                    npath = Jsi_ValueNewStringDup(interp, fname);\n                    Jsi_IncrRefCount(interp, npath);\n                }\n            }\n            if (!Jsi_Strcmp(fname,\"-\"))\n                input = Jsi_GetStdChannel(interp, 0);\n            else {\n                /* Use translated FileName. */\n                if (interp->curDir && fname[0] != '/' && fname[0] != '~') {\n                    char dirBuf2[PATH_MAX], *np;\n                    snprintf(dirBuf, sizeof(dirBuf), \"%s/%s\", interp->curDir, fname);\n                    if ((np=Jsi_FileRealpathStr(interp, dirBuf, dirBuf2)) == NULL) {\n                        Jsi_LogError(\"Can not open '%s'\", fname);\n                        goto bail;\n                    }\n                    if (npath != path)\n                        Jsi_IncrRefCount(interp, npath);\n                    npath = Jsi_ValueNewStringDup(interp, np);\n                    Jsi_IncrRefCount(interp, npath);\n                    fname = Jsi_ValueString(interp, npath, NULL);\n                }\n                if (flags&JSI_EVAL_ARGV0) {\n                    if (interp->argv0)\n                        Jsi_DecrRefCount(interp, interp->argv0);\n                    interp->argv0 = Jsi_ValueNewStringDup(interp, fname);\n                    Jsi_IncrRefCount(interp, interp->argv0);\n                }\n                \n                bool osafe = interp->isSafe;\n                if (interp->startSafe  && flags&JSI_EVAL_ARGV0) {\n                    if (interp->safeReadDirs || interp->safeMode == jsi_safe_None)\n                        interp->isSafe = 0;\n                    else {\n                        char vds[PATH_MAX], *cp;\n                        const char *vda[2] = {vds};\n                        Jsi_Strncpy(vds, Jsi_ValueString(interp, npath, NULL), sizeof(vds)-1);\n                        vds[sizeof(vds)-1] = 0;\n                        cp = Jsi_Strrchr(vds, '/');\n                        if (cp)\n                            cp[1] = 0;\n                        Jsi_DString pStr = {};\n                        vda[1] = Jsi_GetCwd(interp, &pStr);\n                        interp->safeReadDirs = Jsi_ValueNewArray(interp, vda, 2);\n                        Jsi_IncrRefCount(interp, interp->safeReadDirs);\n                        if (interp->safeMode == jsi_safe_WriteRead || interp->safeMode == jsi_safe_Lockdown) {\n                            if (!interp->safeWriteDirs) {\n                                interp->safeWriteDirs = interp->safeReadDirs;\n                                Jsi_IncrRefCount(interp, interp->safeWriteDirs);\n                            }\n                        } else if (interp->safeMode == jsi_safe_Write) {\n                            interp->safeWriteDirs = Jsi_ValueNewArray(interp, vda+1, 1);\n                            Jsi_IncrRefCount(interp, interp->safeWriteDirs);\n                        }\n                        Jsi_DSFree(&pStr);\n                    }\n                }\n                tinput = input = Jsi_Open(interp, npath, (exists?\"-r\":\"r\"));\n                interp->isSafe = osafe;\n                if (!input) {\n                    if (exists)\n                        rc = JSI_OK;\n                    //Jsi_LogError(\"Can not open '%s'\", fname);\n                    goto bail;\n                }\n            }\n            cp = Jsi_Strrchr(fname, '.');\n            if (cp && !Jsi_Strcmp(cp, \".jsi\") && interp->isMain) {\n                interp->typeCheck.parse = interp->typeCheck.run = interp->typeCheck.all = 1;\n                interp->strict = 1;\n            }\n            bool isNew;\n            Jsi_HashEntry *hPtr;\n            hPtr = Jsi_HashEntryNew(interp->fileTbl, fname, &isNew);\n            if (isNew == 0 && hPtr) {\n                if ((flags & JSI_EVAL_ONCE)) {\n                    rc = JSI_OK;\n                    goto bail;\n                }\n                fi = (jsi_FileInfo *)Jsi_HashValueGet(hPtr);\n                if (!fi) goto bail;\n                interp->curFile = fi->fileName;\n                interp->curDir = fi->dirName;\n                \n            } else {\n                fi = (jsi_FileInfo *)Jsi_Calloc(1,sizeof(*fi));\n                if (!fi) goto bail;\n                Jsi_HashValueSet(hPtr, fi);\n                fi->origFile = (char*)Jsi_KeyAdd(interp, origFile);\n                interp->curFile = fi->fileName = (char*)Jsi_KeyAdd(interp, fname);\n                char *dfname = Jsi_Strdup(fname);\n                if ((cp = Jsi_Strrchr(dfname,'/')))\n                    *cp = 0;\n                interp->curDir = fi->dirName = (char*)Jsi_KeyAdd(interp, dfname);\n                Jsi_Free(dfname);\n            }\n            if (!input->fname)\n                input->fname = interp->curFile;\n\n            int cnt = 0, noncmt = 0, jppOpts[4]={};\n            uint ilen;\n            char buf[JSI_BUFSIZ*2];\n            const char *jpp;\n            while (cnt<MAX_LOOP_COUNT) {\n                if (!Jsi_Gets(interp, input, buf, sizeof(buf)))\n                    break;\n                if (++cnt==1 && (!(flags&JSI_EVAL_NOSKIPBANG)) && (buf[0] == '#' && buf[1] == '!')) {\n                    Jsi_DSAppend(&dStr, \"\\n\", NULL);\n                    uskip=1;\n                    continue;\n                }\n                if (!noncmt) {\n                    int bi;\n                    if (!buf[0] || (buf[0] == '/' && buf[1] == '/'))\n                        goto cont;\n                    for (bi=0; buf[bi]; bi++) if (!isspace(buf[bi])) break;\n                    if (!buf[bi])\n                        goto cont;\n                }\n                if (!noncmt++)\n                    fncOfs = Jsi_DSLength(&dStr)-uskip;\n                jpp = interp->jsppChars;\n                if (jpp || interp->unitTest)\n                    ilen = Jsi_Strlen(buf);\n                if (interp->unitTest && buf[0]==';' && buf[1] && buf[2]) {\n                    if (interp->unitTest&1 && jsi_JsPreprocessLine(interp, buf, sizeof(buf), ilen, jppOpts, cnt) != JSI_OK)\n                        goto bail;\n                } else if (interp->jsppCallback && interp->jsppChars) {\n                    if (jsi_JsPreprocessLineCB(interp, buf, sizeof(buf), ilen, jppOpts, cnt) != JSI_OK)\n                        goto bail;\n                }\ncont:\n                Jsi_DSAppend(&dStr, buf,  NULL);\n            }\n            if (cnt>=MAX_LOOP_COUNT)\n                Jsi_LogError(\"source file too large\");\n            str = Jsi_DSValue(&dStr);\n\n        }\n        if (interp->curDir && (flags&JSI_EVAL_AUTOINDEX))\n            Jsi_AddAutoFiles(interp, interp->curDir);\n    }\n    ustr = str + fncOfs;\n    // See if \"use XXX\" is on first non // or empty line (or second if there is a #! on first line)\n    if (ustr && *ustr && !Jsi_Strncmp(ustr+uskip, \"\\\"use \", 5)) {\n        ustr += 5+uskip;\n        const char *cpe = ustr;\n        while (*cpe && *cpe != '\\\"' && *cpe != '\\n' && (isalpha(*cpe) || *cpe ==',' || *cpe =='!')) cpe++;\n        if (*cpe == '\\\"') {\n            Jsi_DString cStr;\n            Jsi_DSInit(&cStr);\n            cpe = Jsi_DSAppendLen(&cStr, ustr, (cpe-ustr));\n            rc = jsi_ParseTypeCheckStr(interp, cpe);\n            Jsi_DSFree(&cStr);\n            if (rc != JSI_OK)\n                goto bail;\n        }\n    }\n\n    /* TODO: cleanup interp->framePtr->Sp stuff. */\n    oldSp = interp->framePtr->Sp;\n    // Evaluate code.\n    rc = JSI_OK;\n    ps = jsiNewParser(interp, str, input, 0);\n    interp->evalFlags = flags;\n    if (!ps)\n        rc = JSI_ERROR;\n    else {\n        Jsi_ValueMakeUndef(interp, &interp->retValue);\n        interp->ps = ps;\n        Jsi_Value *retValue = interp->retValue;\n        if (!interp->strict)\n            interp->strict = (jsi_GetDirective(interp, ps->opcodes, \"use strict\")!=NULL);\n        const char *curFile = interp->curFile;\n\n        if (level <= 0)\n            rc = jsi_evalcode(ps, NULL, ps->opcodes, interp->gsc, interp->csc, interp->csc, &retValue);\n        else {\n            jsi_Frame *fptr = interp->framePtr;\n            while (fptr && fptr->level > level)\n                fptr = fptr->parent;\n            if (!fptr)\n                rc = JSI_ERROR;\n            else\n                rc = jsi_evalcode(ps, NULL, ps->opcodes, fptr->ingsc, fptr->incsc, fptr->inthis, &retValue);\n        }\n        interp->curFile = curFile;\n        if (rc != JSI_OK)\n            rc = (ignore?JSI_OK:JSI_ERROR);\n        else if (ps->last_exception || oldps->last_exception)\n            Jsi_ValueDup2(interp, &oldps->last_exception, ps->last_exception); //TODO: dup even if null?\n        interp->ps = oldps;\n        interp->evalFlags = oldef;\n        if (rc == JSI_OK && ps && !ostr)\n            fi->str = ps->lexer->d.str;\n    }\n    \nbail:\n    interp->curFile = oldFile;\n    interp->curDir = oldDir;\n    interp->framePtr->Sp = oldSp;\n    interp->isMain = oisi;\n    if (path != npath)\n        Jsi_DecrRefCount(interp, npath);\n    Jsi_DSFree(&dStr);\n    Jsi_DSFree(&fStr);\n    if (tinput)\n        Jsi_Close(interp, tinput);\n    Jsi_MutexUnlock(interp, interp->Mutex);\n    if (interp->exited && interp->level <= 0)\n    {\n        rc = JSI_EXIT;\n        if (!interp->parent)\n            Jsi_InterpDelete(interp);\n    }\n\n    return rc;\n}\n\nJsi_RC Jsi_EvalFile(Jsi_Interp* interp, Jsi_Value *fname, int flags)\n{\n    int isnull;\n    if ((isnull=Jsi_ValueIsNull(interp, fname)) || Jsi_ValueIsUndef(interp, fname)) \n        return Jsi_LogError(\"invalid file eval %s\", (isnull?\"null\":\"undefined\"));\n    int lev = interp->framePtr->level;\n    return jsi_evalStrFile(interp, fname, NULL, flags, lev);\n}\n\nJsi_RC Jsi_EvalString(Jsi_Interp* interp, const char *str, int flags)\n{\n    int lev = interp->framePtr->level;\n    return jsi_evalStrFile(interp, NULL, (char*)str, flags, lev);\n}\n\n#undef _jsi_THIS\n#undef _jsi_STACK\n#undef _jsi_STACKIDX\n#undef _jsi_THISIDX\n#undef _jsi_TOP\n#undef _jsi_TOQ\n\n#endif\n", "#ifndef JSI_AMALGAMATION\n#include \"jsiInt.h\"\n#endif\n#include <stdio.h>\n#include <string.h>\n#include <fcntl.h>\n#include <assert.h>\n#include <dirent.h>\n\n#ifndef __WIN32\n#include <pwd.h>\n#include <unistd.h>\n#else\n#include <windef.h>\n#endif\n#include <limits.h>\n\n#ifndef JSI_LITE_ONLY\n\n#define _JSI_GETFP(ch,in) (ch && ch->fp ? ch->fp : (in?stdin:stdout))\n\n//static Jsi_CmdSpec filesysCmds[];\n\nstatic char* jsi_FSRealPathProc(Jsi_Interp *interp, Jsi_Value *path, char *newPath);\n\n\ntypedef struct FileObj {\n#ifdef JSI_HAS_SIG\n    jsi_Sig sig;\n#endif\n    Jsi_Interp *interp;\n    Jsi_Channel chan;\n    Jsi_Value *fname;\n    char *filename;\n    char *mode;\n    Jsi_Obj *fobj;\n    int objId;\n} FileObj;\n\nstatic void fileObjErase(FileObj *fo);\nstatic Jsi_RC fileObjFree(Jsi_Interp *interp, void *data);\nstatic bool fileObjIsTrue(void *data);\nstatic bool fileObjEqual(void *data1, void *data2);\n\n#ifdef __WIN32\nchar *get_current_dir_name() {\n    static char buf[MAX_PATH] = \".\";\n    getcwd(buf, sizeof(buf));\n    return buf;\n}\n#endif\n\nstatic const char *jsi_TildePath(Jsi_Interp *interp, const char* path, Jsi_DString *dStr) {\n    if (*path != '~')\n        return path;\n    const char *homedir = jsi_GetHomeDir(interp);\n    if (!homedir)\n        return path;\n    Jsi_DSAppend(dStr, homedir, path[1] == '/' ? \"\" : \"/\", path+1, NULL);\n    return Jsi_DSValue(dStr);\n}\n\nint jsi_FSScandirProc(Jsi_Interp *interp, Jsi_Value *path, Jsi_Dirent ***namelist,\n   int (*filter)(const Jsi_Dirent *), int (*compar)(const Jsi_Dirent **, const Jsi_Dirent**))\n{\n    const char *dirname = Jsi_ValueToString(interp, path, NULL);\n    Jsi_DString dStr = {};\n    if (*dirname == '~')\n        dirname = jsi_TildePath(interp, dirname, &dStr);\n    int rc = scandir(dirname, namelist, filter, compar);\n    Jsi_DSFree(&dStr);\n    return rc;\n}\n\nstatic int jsi_FSCreateDirectoryProc(Jsi_Interp *interp, Jsi_Value* path) {\n    const char *pathPtr = Jsi_ValueToString(interp, path, NULL);\n    Jsi_DString dStr = {};\n    int rc;\n    if (*pathPtr == '~')\n        pathPtr = jsi_TildePath(interp, pathPtr, &dStr);\n\n#ifdef __WIN32\n    rc = mkdir(pathPtr);\n#else\n    rc = mkdir(pathPtr, 0666);\n#endif\n    Jsi_DSFree(&dStr);\n    return rc;\n}\n\nstatic int jsi_FSRenameProc(Jsi_Interp *interp, Jsi_Value *src, Jsi_Value *dest) {\n    const char *zSrc = Jsi_ValueToString(interp, src, NULL);\n    const char *zDest = Jsi_ValueToString(interp, dest, NULL);\n    Jsi_DString dStr = {}, eStr = {};\n    if (*zSrc == '~')\n        zSrc = jsi_TildePath(interp, zSrc, &dStr);\n    if (*zDest == '~')\n        zDest = jsi_TildePath(interp, zDest, &eStr);\n    int rc = rename(zSrc, zDest);\n    Jsi_DSFree(&dStr);\n    Jsi_DSFree(&eStr);\n    return rc;\n}\n\nstatic Jsi_Value * jsi_FSListVolumesProc(Jsi_Interp *interp) {return 0;}\n\nstatic int jsi_FSRemoveProc(Jsi_Interp *interp, Jsi_Value* path, int flags) {\n    const char *pathPtr = Jsi_ValueToString(interp, path, NULL);\n    Jsi_DString dStr = {};\n    if (*pathPtr == '~')\n        pathPtr = jsi_TildePath(interp, pathPtr, &dStr);\n    int rc = remove(pathPtr);\n    Jsi_DSFree(&dStr);\n    return rc;\n}\n\nstatic bool jsi_FSPathInFilesystemProc(Jsi_Interp *interp, Jsi_Value* path,void **clientDataPtr) {return 1;}\n\nstatic int jsi_FSAccessProc(Jsi_Interp *interp, Jsi_Value* path, int mode) {\n    const char *pathPtr = Jsi_ValueToString(interp, path, NULL);\n    Jsi_DString dStr = {};\n    if (*pathPtr == '~')\n        pathPtr = jsi_TildePath(interp, pathPtr, &dStr);\n    int rc = access(pathPtr, mode);\n    Jsi_DSFree(&dStr);\n    return rc;\n}\n\nstatic int jsi_FSChmodProc(Jsi_Interp *interp, Jsi_Value* path, int mode) {\n#ifdef __WIN32\n    return -1;\n#else\n    const char *pathPtr = Jsi_ValueToString(interp, path, NULL);\n    Jsi_DString dStr = {};\n    if (*pathPtr == '~')\n        pathPtr = jsi_TildePath(interp, pathPtr, &dStr);\n    int rc = chmod(pathPtr, mode);\n    Jsi_DSFree(&dStr);\n    return rc;\n#endif\n}\n\nstatic int jsi_FSStatProc(Jsi_Interp *interp, Jsi_Value* path, Jsi_StatBuf *buf) {\n    const char *pathPtr = Jsi_ValueToString(interp, path, NULL);\n    Jsi_DString dStr = {};\n    if (*pathPtr == '~')\n        pathPtr = jsi_TildePath(interp, pathPtr, &dStr);\n    int rc = stat(pathPtr, buf);\n    Jsi_DSFree(&dStr);\n    return rc;\n}\n\nstatic int jsi_FSLstatProc(Jsi_Interp *interp, Jsi_Value* path, Jsi_StatBuf *buf) {\n#ifdef __WIN32\n    return jsi_FSStatProc(interp, path, buf);\n#else\n    const char *pathPtr = Jsi_ValueToString(interp, path, NULL);\n    Jsi_DString dStr = {};\n    if (*pathPtr == '~')\n        pathPtr = jsi_TildePath(interp, pathPtr, &dStr);\n    int rc = lstat(pathPtr, buf);\n    Jsi_DSFree(&dStr);\n    return rc;\n#endif\n}\nstatic int jsi_FSFlushProc(Jsi_Channel chan) { return fflush(_JSI_GETFP(chan,0));}\nstatic int jsi_FSTellProc(Jsi_Channel chan) { return ftell(_JSI_GETFP(chan,1));}\nstatic int jsi_FSEofProc(Jsi_Channel chan) { return feof(_JSI_GETFP(chan,1));}\nstatic int jsi_FSTruncateProc(Jsi_Channel chan, unsigned int len) { return ftruncate(fileno(_JSI_GETFP(chan,1)), len);}\nstatic int jsi_FSRewindProc(Jsi_Channel chan) { rewind(_JSI_GETFP(chan,1)); return 0;}\nstatic int jsi_FSCloseProc(Jsi_Channel chan) { return fclose(_JSI_GETFP(chan,1));}\nstatic int jsi_FSSeekProc(Jsi_Channel chan, Jsi_Wide offset, int mode) { return fseek(_JSI_GETFP(chan,1), offset, mode);}\n\nstatic int jsi_FSWriteProc(Jsi_Channel chan, const char *buf, int size) {\n    return fwrite(buf, 1, size, _JSI_GETFP(chan,0));\n}\n\nstatic int jsi_FSReadProc(Jsi_Channel chan, char *buf, int size) {\n    return fread(buf, 1, size, _JSI_GETFP(chan,0));\n}\n\n#ifdef __WIN32\n#define jsi_FSLinkProc NULL\n#define jsi_FSReadlinkProc NULL\n#else //__WIN32\nstatic int jsi_FSLinkProc(Jsi_Interp *interp, Jsi_Value* path, Jsi_Value *toPath, int linkType) {\n    const char *pathPtr = Jsi_ValueToString(interp, path, NULL);\n    const char *toPtr = Jsi_ValueToString(interp, toPath, NULL);\n    Jsi_DString dStr = {}, eStr = {};\n    int rc;\n    if (*pathPtr == '~')\n        pathPtr = jsi_TildePath(interp, pathPtr, &dStr);\n    if (*toPtr == '~')\n        toPtr = jsi_TildePath(interp, toPtr, &eStr);\n    if (linkType != 0)\n        rc = link(pathPtr, toPtr);\n    else\n        rc = symlink(pathPtr, toPtr);\n    Jsi_DSFree(&dStr);\n    Jsi_DSFree(&eStr);\n    return rc;\n}\n\nstatic int jsi_FSReadlinkProc(Jsi_Interp *interp, Jsi_Value *path, char *buf, int size) {\n    const char *pathPtr = Jsi_ValueToString(interp, path, NULL);\n    Jsi_DString dStr = {};\n    if (*pathPtr == '~')\n        pathPtr = jsi_TildePath(interp, pathPtr, &dStr);\n    int rc = readlink(pathPtr, buf, size);\n    Jsi_DSFree(&dStr);\n    return rc;\n}\n#endif // __WIN32\n\nstatic int jsi_FSGetcProc(Jsi_Channel chan) {\n    return fgetc(_JSI_GETFP(chan,1));\n}\n\nstatic int jsi_FSUngetcProc(Jsi_Channel chan, int ch) {\n    return ungetc(ch, _JSI_GETFP(chan,1));\n}\n\nstatic char * jsi_FSGetsProc(Jsi_Channel chan, char *s, int size) {\n    return fgets(s, size, _JSI_GETFP(chan,1));\n}\n\nstatic int jsi_FSPutsProc(Jsi_Channel chan, const char *s) {\n    return fputs(s, _JSI_GETFP(chan,0));\n}\n\n/* Not used as Jsi_Open already handles native. */\nJsi_Channel jsi_FSOpenProc(Jsi_Interp *interp, Jsi_Value *file, const char *modeString)\n{\n    return Jsi_Open(interp, file, modeString);\n}\n\ntypedef struct FSList {\n    Jsi_Filesystem* fsPtr;\n    void *data;\n    struct FSList *next;\n} FSList;\n\nstatic FSList *jsiFSList = NULL;\n\nstatic Jsi_Filesystem jsiFilesystem = {\n    .typeName=\"native\",\n    .structureLength=sizeof(Jsi_Filesystem),\n    .version=1,\n    .pathInFilesystemProc=jsi_FSPathInFilesystemProc,\n    .realpathProc=jsi_FSRealPathProc,\n    .statProc=jsi_FSStatProc,\n    .lstatProc=jsi_FSLstatProc,\n    .accessProc=jsi_FSAccessProc,\n    .chmodProc=jsi_FSChmodProc,\n    .openProc=jsi_FSOpenProc,\n    .scandirProc=jsi_FSScandirProc,\n    .readProc=jsi_FSReadProc,\n    .writeProc=jsi_FSWriteProc,\n    .getsProc=jsi_FSGetsProc,\n    .getcProc=jsi_FSGetcProc,\n    .ungetcProc=jsi_FSUngetcProc,\n    .putsProc=jsi_FSPutsProc,\n    .flushProc=jsi_FSFlushProc,\n    .seekProc=jsi_FSSeekProc,\n    .tellProc=jsi_FSTellProc,\n    .eofProc=jsi_FSEofProc,\n    .truncateProc=jsi_FSTruncateProc,\n    .rewindProc=jsi_FSRewindProc,\n    .closeProc=jsi_FSCloseProc,\n    .linkProc=jsi_FSLinkProc,\n    .readlinkProc=jsi_FSReadlinkProc,\n    .listVolumesProc=jsi_FSListVolumesProc,\n    .createDirectoryProc=jsi_FSCreateDirectoryProc,\n    .removeProc=jsi_FSRemoveProc,\n    .renameProc=jsi_FSRenameProc,\n};\n\nJsi_Channel Jsi_GetStdChannel(Jsi_Interp *interp, int id) {\n    if (id<0 || id>2)\n        return NULL;\n    return jsiIntData.stdChans+id;\n}\n\nJsi_RC Jsi_FSRegister(Jsi_Filesystem *fsPtr, void *data) {\n    FSList *fsl = (FSList *)Jsi_Calloc(1, sizeof(*fsl));\n    fsl->fsPtr = fsPtr;\n    fsl->data = data;\n    fsl->next = jsiFSList;\n    jsiFSList = fsl;\n    return JSI_OK;\n}\n\nJsi_RC Jsi_FSUnregister(Jsi_Filesystem *fsPtr) {\n    FSList *fsl = jsiFSList, *flast = NULL;\n    while (fsl) {\n        if (fsl->fsPtr == fsPtr) {\n            if (flast)\n                flast->next = fsl->next;\n            else\n                jsiFSList = fsl->next;\n            Jsi_Free(fsl);\n            break;\n        }\n        flast = fsl;\n        fsl = fsl->next;\n    }\n    return JSI_OK;\n}\n\nJsi_Filesystem* Jsi_FilesystemForPath(Jsi_Interp *interp, Jsi_Value* path, void**clientDataPtr) {\n    FSList *fsl = jsiFSList;\n    if (!fsl) return NULL;\n    clientDataPtr = NULL;\n    const char *pathStr = Jsi_ValueToString(interp, path, NULL);\n    if (!pathStr || pathStr[0] == '~')\n        return &jsiFilesystem;\n    if (pathStr[0] == '.' && pathStr[1] == 0)\n        return (jsiIntData.cwdFsPtr ? jsiIntData.cwdFsPtr : &jsiFilesystem);\n    Jsi_Value *tpath = NULL;\n    if (Jsi_Strstr(pathStr, \"..\")) {\n        Jsi_DString dStr;\n        Jsi_DSInit(&dStr);\n        pathStr = Jsi_ValueNormalPath(interp, path, &dStr);\n        tpath = path = Jsi_ValueNewStringDup(interp, pathStr);\n        Jsi_IncrRefCount(interp, tpath);\n        Jsi_DSFree(&dStr);\n    }\n    while (1) {\n        if (fsl->fsPtr->pathInFilesystemProc && fsl->fsPtr->pathInFilesystemProc(interp, path, clientDataPtr))\n            break;\n        if (!fsl->next)\n            break;\n        fsl = fsl->next;\n    }\n    if (tpath)\n        Jsi_DecrRefCount(interp, tpath);\n    return (fsl ? fsl->fsPtr : &jsiFilesystem);\n}\n\nint Jsi_Readlink(Jsi_Interp *interp, Jsi_Value* path, char *ret, int len) {\n#ifdef __WIN32\n    return -1;\n#else\n    void *data;\n    Jsi_Filesystem *fsPtr = Jsi_FilesystemForPath(interp, path, &data);\n    if (fsPtr == NULL || !fsPtr->readlinkProc) return -1;\n    return fsPtr->readlinkProc(interp, path, ret, len);\n#endif\n}\n\nint Jsi_Stat(Jsi_Interp *interp, Jsi_Value* path, Jsi_StatBuf *buf) {\n    void *data;\n    Jsi_Filesystem *fsPtr = Jsi_FilesystemForPath(interp, path, &data);\n    if (fsPtr == NULL || !fsPtr->statProc) return -1;\n    return fsPtr->statProc(interp, path, buf);\n}\n\nint Jsi_Link(Jsi_Interp *interp, Jsi_Value* src, Jsi_Value *dest, int typ) {\n    void *data;\n    Jsi_Filesystem *fsPtr = Jsi_FilesystemForPath(interp, src, &data);\n    if (fsPtr == NULL || !fsPtr->linkProc) return -1;\n    return fsPtr->linkProc(interp, src, dest, typ);\n}\n\nint Jsi_Lstat(Jsi_Interp *interp, Jsi_Value* path, Jsi_StatBuf *buf) {\n    void *data;\n    Jsi_Filesystem *fsPtr = Jsi_FilesystemForPath(interp, path, &data);\n    if (fsPtr == NULL || !fsPtr->lstatProc) return -1;\n    return fsPtr->lstatProc(interp, path, buf);\n}\n\nint Jsi_Chmod(Jsi_Interp *interp, Jsi_Value* path, int mode) {\n    void *data;\n    Jsi_Filesystem *fsPtr = Jsi_FilesystemForPath(interp, path, &data);\n    if (fsPtr == NULL || !fsPtr->chmodProc) return -1;\n    return fsPtr->chmodProc(interp, path, mode);\n}\nint Jsi_Access(Jsi_Interp *interp, Jsi_Value* path, int mode) {\n    void *data;\n    Jsi_Filesystem *fsPtr = Jsi_FilesystemForPath(interp, path, &data);\n    if (fsPtr == NULL || !fsPtr->accessProc) return -1;\n    if (interp->isSafe && fsPtr && fsPtr == &jsiFilesystem) {\n        int aflag = (mode&W_OK ? JSI_INTACCESS_WRITE : JSI_INTACCESS_READ);\n        if (Jsi_InterpAccess(interp, path, aflag) != JSI_OK)\n            return -1;\n    }\n    return fsPtr->accessProc(interp, path, mode);\n}\nint Jsi_Remove(Jsi_Interp *interp, Jsi_Value* path, int flags) {\n    void *data;\n    Jsi_Filesystem *fsPtr = Jsi_FilesystemForPath(interp, path, &data);\n    if (fsPtr == NULL || !fsPtr->removeProc) return -1;\n    return fsPtr->removeProc(interp, path, flags);\n}\nint Jsi_Rename(Jsi_Interp *interp, Jsi_Value *src, Jsi_Value *dst) {\n    void *data;\n    Jsi_Filesystem *fsPtr = Jsi_FilesystemForPath(interp, src, &data);\n    if (fsPtr != Jsi_FilesystemForPath(interp, src, &data)) return -1;\n    if (fsPtr == NULL || !fsPtr->renameProc) return -1;\n    return fsPtr->renameProc(interp, src,dst);\n}\n\nint Jsi_Scandir(Jsi_Interp *interp, Jsi_Value* path, Jsi_Dirent ***namelist,\n int (*filter)(const Jsi_Dirent *), int (*compar)(const Jsi_Dirent **, const Jsi_Dirent**)) \n {\n    void *data;\n    Jsi_Filesystem *fsPtr = Jsi_FilesystemForPath(interp, path, &data);\n    if (fsPtr == NULL || !fsPtr->scandirProc) return -1;\n    return fsPtr->scandirProc(interp, path, namelist, filter, compar);\n}\n\nbool Jsi_FSNative(Jsi_Interp *interp, Jsi_Value *file) {\n    void *data;\n    Jsi_Filesystem *fsPtr = Jsi_FilesystemForPath(interp, file, &data);\n    if (fsPtr && fsPtr == &jsiFilesystem)\n        return 1;\n    else\n        return 0;\n}\n\nstatic Jsi_Filesystem *jsi_FilesysFind(const char *name)\n{\n    FSList *fsPtr = jsiFSList;\n    while (fsPtr != NULL) {\n        if (!Jsi_Strcmp(fsPtr->fsPtr->typeName, name))\n            return fsPtr->fsPtr;\n        fsPtr = fsPtr->next;\n    }\n    return NULL;\n}\n\nJsi_Channel Jsi_Open(Jsi_Interp *interp, Jsi_Value *file, const char *modeString)\n{\n    /* Find fsys, and use open there. */\n    Jsi_Filesystem *fsPtr;\n    Jsi_Chan *ch = NULL;\n    void *data;\n    int fnl = 0;\n    const char *fileName = Jsi_ValueString(interp, file, &fnl), *oldFN = fileName;\n    if (!fileName || !fnl) {\n        Jsi_LogError(\"expected string filename\");\n        return NULL;\n    }\n    if (!Jsi_Strcmp(fileName, \"stdin\")) return jsiIntData.stdChans;\n    if (!Jsi_Strcmp(fileName, \"stdout\")) return jsiIntData.stdChans+1;\n    if (!Jsi_Strcmp(fileName, \"stderr\")) return jsiIntData.stdChans+2;\n    const char *s = modeString;\n    bool quiet = 0;\n    if (s[0]=='-') {\n        quiet = true;\n        s++;\n    }\n    char Mode[sizeof(ch->modes)];\n    Jsi_StatBuf sb;\n    Jsi_Value *path = NULL;\n    int n, i, mode = 0, rc, writ, aflag;\n    if (!s)\n        s = \"r\";\n    if (Jsi_Strlen(s) >= sizeof(ch->modes)) {\n        Jsi_LogError(\"mode too long: %s\", s);\n        return NULL;\n    }\n    if (Jsi_Strchr(s, 'z') || Jsi_Strchr(s, 'Z')) {\n        Jsi_Filesystem *fsPtr = jsi_FilesysFind(\"jfz\");\n        if (!fsPtr) {\n            Jsi_LogError(\"compressed files unsupported\");\n            return NULL;\n        }\n        ch = fsPtr->openProc(interp, file, s);\n        if (!ch) {\n            if (!quiet)\n                Jsi_LogError(\"File open failed '%s'\", fileName);\n            return NULL;\n        }\n        Jsi_Chan *nch = (Jsi_Chan *)Jsi_Calloc(1,sizeof(*nch));\n        *nch = *ch;\n        nch->fsPtr = fsPtr;\n        return nch;\n    }\n    for (i=0, n = 0; s[i]; i++) {\n        switch (s[i]) {\n            case '+': break;\n            case 'b': break;\n            case 'r': if (!Jsi_Strchr(s,'+')) mode |= JSI_FS_READONLY; break;\n            case 'a':\n            case 'w': if (!Jsi_Strchr(s,'+')) mode |= JSI_FS_WRITEONLY; break;\n            default: Jsi_LogError(\"unknown mode char: %c\", s[i]); return NULL;\n        }\n        Mode[n++] = s[i];\n    }\n    Mode[n] = 0;\n    /* Fixup files in the ~ dir */\n    rc = Jsi_Stat(interp, file,&sb);\n    if ((rc != 0 || *fileName == '~') && (fileName = Jsi_FileRealpath(interp, file, NULL))) {\n        path = Jsi_ValueNewString(interp, fileName, -1);\n        Jsi_IncrRefCount(interp, path);\n        rc = Jsi_Stat(interp, path, &sb);\n        if (rc == 0)\n            file = path;\n    }\n    if (!fileName) {\n        Jsi_LogError(\"file error: %s\", oldFN);\n        return NULL;\n    }\n\n    if (rc == 0 &&  sb.st_mode & S_IFDIR )\n    {\n        Jsi_LogError(\"can not open directory: %s\", fileName);\n        goto done;\n    }\n    fsPtr = Jsi_FilesystemForPath(interp, file, &data);\n    writ = (Jsi_Strchr(s,'w') || Jsi_Strchr(s,'a') || Jsi_Strchr(s,'+'));\n    aflag = (writ ? JSI_INTACCESS_WRITE : JSI_INTACCESS_READ);\n    if (fsPtr && fsPtr != &jsiFilesystem) {\n        ch = fsPtr->openProc(interp, file, Mode);\n        if (ch)\n            ch->isNative = 0;\n        else\n            Jsi_LogError(\"File open failed '%s'\", fileName);\n    } else {\n        if (interp->isSafe && ((rc && Jsi_InterpAccess(interp, file, JSI_INTACCESS_CREATE) != JSI_OK)\n        || Jsi_InterpAccess(interp, file, aflag) != JSI_OK)) {\n            Jsi_LogError(\"%s access denied: %s\", writ?\"write\":\"read\", fileName);\n            goto done;\n        }\n        FILE *fp = fopen(fileName, Mode);\n        fsPtr = &jsiFilesystem;\n        if (!fp) {\n            if (!quiet)\n                Jsi_LogError(\"File open failed '%s'\", fileName);\n            goto done;\n        }\n        ch = (Jsi_Chan *)Jsi_Calloc(1,sizeof(*ch));\n        ch->fp = fp;\n        ch->isNative = 1;\n    }\n    if (ch) {\n        ch->flags |= mode; // + (zLevel<<24);\n        Jsi_Strcpy(ch->modes, s);\n        ch->fsPtr = fsPtr;\n        ch->fname = fileName;\n    }\ndone:\n    if (path)\n        Jsi_DecrRefCount(interp, path);\n    return ch;\n}\n\nint Jsi_SetChannelOption(Jsi_Interp *interp, Jsi_Channel chan, const char *optionName,\n    const char *newValue) {return JSI_OK;}\n    \nJsi_Wide Jsi_Seek(Jsi_Interp *interp, Jsi_Channel chan, Jsi_Wide offset, int mode) {\n    if (chan->fsPtr==0 || !chan->fsPtr->seekProc) return -1;\n    return chan->fsPtr->seekProc(chan, offset, mode);\n}\nJsi_Wide Jsi_Tell(Jsi_Interp *interp, Jsi_Channel chan) {\n    if (chan->fsPtr==0 || !chan->fsPtr->tellProc) return -1;\n    return chan->fsPtr->tellProc(chan);\n}\nint Jsi_Eof(Jsi_Interp *interp, Jsi_Channel chan) {\n    if (chan->fsPtr==0 || !chan->fsPtr->eofProc) return -1;\n    return chan->fsPtr->eofProc(chan);\n}\nJsi_Wide Jsi_Rewind(Jsi_Interp *interp, Jsi_Channel chan) {\n    if (chan->fsPtr==0 || !chan->fsPtr->rewindProc) return -1;\n    return chan->fsPtr->rewindProc(chan);\n}\n\n/*Jsi_StatBuf* Jsi_AllocStatBuf(void) {return 0;}*/\n\nint Jsi_Read(Jsi_Interp *interp, Jsi_Channel chan, char *bufPtr, int toRead) {\n    if (chan->fsPtr==0 || !chan->fsPtr->readProc) return -1;\n    return chan->fsPtr->readProc(chan, bufPtr, toRead);\n}\nint Jsi_Write(Jsi_Interp *interp, Jsi_Channel chan, const char *bufPtr, int slen) {\n    if (chan->fsPtr==0 || !chan->fsPtr->writeProc) return -1;\n    return chan->fsPtr->writeProc(chan, bufPtr, slen);\n}\nint Jsi_Truncate(Jsi_Interp *interp, Jsi_Channel chan, unsigned int len) {\n    if (chan->fsPtr==0 || !chan->fsPtr->truncateProc) return -1;\n    return chan->fsPtr->truncateProc(chan, len);\n}\n\nint Jsi_Close(Jsi_Interp *interp, Jsi_Channel chan) {\n    if (chan->fsPtr==0 || !chan->fsPtr->closeProc) return -1;\n    if (chan->flags&JSI_FS_NOCLOSE) return -1;\n    int rc = chan->fsPtr->closeProc(chan);\n    if (rc == 0)\n        Jsi_Free(chan);\n    return rc;\n}\nint Jsi_Flush(Jsi_Interp *interp, Jsi_Channel chan) {\n    if (chan->fsPtr==0 || !chan->fsPtr->flushProc) return -1;\n    return chan->fsPtr->flushProc(chan);\n}\n\nint Jsi_Getc(Jsi_Interp *interp, Jsi_Channel chan) {\n    if (chan->fsPtr==0 || !chan->fsPtr->getcProc) return -1;\n    return chan->fsPtr->getcProc(chan);\n}\n\nint Jsi_Ungetc(Jsi_Interp *interp, Jsi_Channel chan, int ch) {\n    if (chan->fsPtr==0 || !chan->fsPtr->ungetcProc) return -1;\n    return chan->fsPtr->ungetcProc(chan, ch);\n}\n\nchar * Jsi_Gets(Jsi_Interp *interp, Jsi_Channel chan, char *s, int size) {\n    if (chan->fsPtr==0 || !chan->fsPtr->getsProc) return NULL;\n    return chan->fsPtr->getsProc(chan, s, size);\n}\n\nint Jsi_Chdir(Jsi_Interp *interp, Jsi_Value* path) {\n    void *data;\n    int rc = 0;\n    const char *pathPtr = Jsi_ValueToString(interp, path, NULL);\n    if (interp->isSafe && Jsi_InterpAccess(interp, path, JSI_INTACCESS_READ) != JSI_OK) \n        return Jsi_LogError(\"read access denied\");\n    Jsi_Filesystem *fsPtr = Jsi_FilesystemForPath(interp, path, &data);\n    if (fsPtr == &jsiFilesystem) {\n        rc = chdir(pathPtr);\n        if (rc < 0)\n            return -1;\n        /* If change out of native fs, GetCwd will use pwdStr */\n        fsPtr = NULL;\n    }\n    Jsi_DSSetLength(&jsiIntData.pwdStr, 0);\n    Jsi_DSAppendLen(&jsiIntData.pwdStr, pathPtr, -1);\n    jsiIntData.cwdFsPtr = fsPtr;\n    jsiIntData.pwd = fsPtr ? Jsi_DSValue(&jsiIntData.pwdStr) : NULL;\n    return rc;\n}\n\nchar* Jsi_ValueNormalPath(Jsi_Interp *interp, Jsi_Value *file, Jsi_DString *dStr) {\n    return Jsi_NormalPath(interp, Jsi_ValueString(interp, file, NULL), dStr);\n}\n\nchar *Jsi_FileRealpath(Jsi_Interp *interp, Jsi_Value *spath, char *newname)\n{\n    char *path = Jsi_ValueString(interp, spath, 0);\n    if (!path) return NULL;\n    return Jsi_FileRealpathStr(interp, path, newname);\n}\n\nstatic char* jsi_FSRealPathProc(Jsi_Interp *interp, Jsi_Value *src, char *newPath) {\n    return Jsi_FileRealpath(interp, src, newPath);\n}\n\nJsi_RC Jsi_PathNormalize(Jsi_Interp *interp, Jsi_Value **pathPtr) {\n    Jsi_Value *path = *pathPtr;\n    if (!path) {\n        Jsi_DString dStr = {};\n        *pathPtr = Jsi_ValueNewStringDup(interp, Jsi_GetCwd(interp, &dStr));\n        Jsi_IncrRefCount(interp, *pathPtr);\n        Jsi_DSFree(&dStr);\n    } else {\n        const char *rn = Jsi_Realpath(interp, path, NULL);\n        if (!rn) return JSI_ERROR;\n        Jsi_DecrRefCount(interp, *pathPtr);\n        *pathPtr = Jsi_ValueNewString(interp, rn, -1);\n        Jsi_IncrRefCount(interp, *pathPtr);\n    }\n    return JSI_OK;\n}\n\nchar *Jsi_Realpath(Jsi_Interp *interp, Jsi_Value *src, char *newname)\n{\n    /* TODO: resolve pwd first. */\n    void *data;\n    const char *cp = NULL;\n    Jsi_Filesystem *fsPtr;\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    const char *npath = Jsi_ValueNormalPath(interp, src, &dStr);\n    if (!npath) return NULL;\n    Jsi_Value *tPtr = Jsi_ValueNew1(interp);\n    Jsi_ValueMakeStringDup(interp, &tPtr, npath);\n    fsPtr = Jsi_FilesystemForPath(interp, tPtr, &data);\n    if (fsPtr) {\n        if (fsPtr->realpathProc)\n            cp = fsPtr->realpathProc(interp, src, newname);\n        else if (!newname)\n            cp = Jsi_Strdup(npath);\n        else {\n            Jsi_Strncpy(newname, npath, PATH_MAX);\n            if (Jsi_Strlen(npath)>=PATH_MAX)\n                newname[PATH_MAX-1] = 0;\n        }\n    }\n    Jsi_DSFree(&dStr);\n    Jsi_DecrRefCount(interp, tPtr);\n    return (char*)cp;\n}\n\n\nstatic void fileObjErase(FileObj *fo)\n{\n    if (fo->filename) {\n        Jsi_Close(fo->interp, fo->chan);\n        Jsi_Free(fo->filename);\n        Jsi_DecrRefCount(fo->interp, fo->fname);\n        Jsi_Free(fo->mode);\n    }\n    fo->filename = NULL;\n}\n\nstatic Jsi_RC fileObjFree(Jsi_Interp *interp, void *data)\n{\n    FileObj *fo = (FileObj *)data;\n    SIGASSERT(fo,FILEOBJ);\n    fileObjErase(fo);\n    Jsi_Free(fo);\n    return JSI_OK;\n}\n\nstatic bool fileObjIsTrue(void *data)\n{\n    FileObj *fo = (FileObj *)data;\n    SIGASSERT(fo,FILEOBJ);\n    if (!fo->filename) return JSI_OK;\n    else return 1;\n}\n\nstatic bool fileObjEqual(void *data1, void *data2)\n{\n    return (data1 == data2);\n}\n\nstatic int try_open_file(Jsi_Interp *interp, FileObj *udf, Jsi_Value *args)\n{\n    int ret = JSI_ERROR;\n    fileObjErase(udf);\n    // TODO: stdin, stdout, stderr, etc.\n    Jsi_Value *fname = Jsi_ValueArrayIndex(interp, args, 0);\n    if (fname && Jsi_ValueIsString(interp, fname)) {\n        Jsi_Value *vmode = Jsi_ValueArrayIndex(interp, args, 1);\n        const char *mode = NULL;\n        const char *fstr = Jsi_ValueString(interp, fname, NULL);\n        if (vmode && Jsi_ValueIsString(interp,vmode)) {\n            mode = Jsi_ValueString(interp, vmode, NULL);\n        }\n        int writ = (mode && (Jsi_Strchr(mode,'w')||Jsi_Strchr(mode,'+')));\n        int aflag = (writ ? JSI_INTACCESS_WRITE : JSI_INTACCESS_READ);\n        if (interp->isSafe && Jsi_InterpAccess(interp, fname, aflag) != JSI_OK)\n            return Jsi_LogError(\"Safe open failed\");\n        char *rmode = Jsi_Strdup(mode ? mode : \"r\");\n        Jsi_Channel chan = Jsi_Open(interp, fname, rmode);\n        if (chan) {\n            udf->chan = chan;\n            udf->fname = fname;\n            udf->interp = interp;\n            Jsi_IncrRefCount(interp, fname);\n            udf->filename = Jsi_Strdup(fstr);\n            udf->mode = Jsi_Strdup(rmode);\n            ret = JSI_OK;\n        }\n        Jsi_Free(rmode);\n    }\n    return ret;\n}\n\n#define UdfGet(udf, _this, funcPtr) \\\n   FileObj *udf = (FileObj *)Jsi_UserObjGetData(interp, _this, funcPtr); \\\n    if (!udf) \\\n        return Jsi_LogError(\"Channel.%s called with non-file object\", funcPtr->cmdSpec->name);\n\nstatic Jsi_RC FilesysOpenCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    UdfGet(udf, _this, funcPtr);\n    if (try_open_file(interp, udf, args) != JSI_OK) {\n        Jsi_ValueMakeBool(interp, ret, 0);\n    }\n    Jsi_ValueMakeBool(interp, ret, 1);\n    return JSI_OK;\n}\n\nstatic Jsi_RC FilesysCloseCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    UdfGet(udf, _this, funcPtr);\n    fileObjErase(udf);\n    Jsi_ValueMakeBool(interp, ret, 1);\n    return JSI_OK;\n}\n\nstatic Jsi_RC FilesysGetsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int len;\n    UdfGet(udf, _this, funcPtr);\n    if (!udf->filename) {\n        Jsi_ValueMakeUndef(interp, ret);\n        return JSI_OK;\n    }\n    char buf[JSI_BUFSIZ];\n    if (!Jsi_Gets(interp, udf->chan, buf, sizeof(buf))) {\n        Jsi_ValueMakeUndef(interp, ret);\n        return JSI_OK;\n    }\n    buf[sizeof(buf)-1] = 0;\n    len = Jsi_Strlen(buf);\n    if (len > 0 && buf[len-1] == '\\n')\n        buf[len-1] = 0;\n    Jsi_ValueMakeStringDup(interp, ret, buf);\n    return JSI_OK;\n}\n\n\nstatic Jsi_RC FilesysModeCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    UdfGet(udf, _this, funcPtr);\n    if (udf->mode)\n        Jsi_ValueMakeStringKey(interp, ret, udf->mode);\n    return JSI_OK;\n}\n\nstatic Jsi_RC FilesysFilenameCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    UdfGet(udf, _this, funcPtr);\n    if (udf->filename)\n        Jsi_ValueMakeStringDup(interp, ret, udf->filename);\n    return JSI_OK;\n}\n\nstatic Jsi_RC FilesysReadCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int  sum = 0, n;\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    UdfGet(udf, _this, funcPtr);\n    char buf[JSI_BUFSIZ];\n    int argc = Jsi_ValueGetLength(interp, args);\n    int nsiz = -1, cnt = 0, rsiz;\n    \n    if (!udf->filename) {\n        goto bail;\n    }\n    if (argc>0 && Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, 0), &nsiz) != JSI_OK)\n        goto bail;\n    while (cnt++ < MAX_LOOP_COUNT) {\n        rsiz = sizeof(buf);\n        if (nsiz>0 && ((sum+rsiz)>nsiz))\n            rsiz = (nsiz-sum);\n        if ((n = Jsi_Read(interp, udf->chan, buf, rsiz)) <= 0)\n            break;\n        Jsi_DSAppendLen(&dStr, buf, n);\n        sum += n;\n        if (nsiz>=0 && sum >=nsiz)\n            break;\n    }\n    if (Jsi_DSLength(&dStr)>0)\n        Jsi_ValueMakeDStringObject(interp, ret, &dStr);\n    return JSI_OK;\n    \nbail:\n    Jsi_DSFree(&dStr);\n    Jsi_ValueMakeUndef(interp, ret);\n    return JSI_OK;\n}\n\n\nstatic Jsi_RC FilesysSeekCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    static const char *posStr[] = { \"set\", \"cur\", \"end\", NULL };\n    enum { W_SET, W_CUR, W_END };\n    UdfGet(udf, _this, funcPtr);\n    Jsi_Value *vPos = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_Value *vWhence = Jsi_ValueArrayIndex(interp, args, 1);\n    int mode = 0, p;\n    Jsi_Wide pos;\n    Jsi_Number num;\n    if (Jsi_ValueGetNumber(interp, vPos, &num) != JSI_OK)\n        return JSI_ERROR;\n    if (Jsi_ValueGetIndex(interp, vWhence, posStr, \"position\", 0, &p) != JSI_OK)\n        return JSI_ERROR;\n    switch (p) {\n        case W_SET: mode = SEEK_SET; break;\n        case W_CUR: mode = SEEK_CUR; break;\n        case W_END: mode = SEEK_END; break;\n    }\n    pos = (Jsi_Wide)num;\n    pos = Jsi_Seek(interp, udf->chan, pos, mode);\n    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)pos);\n    return JSI_OK;\n}\n\nstatic Jsi_RC FilesysTruncateCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    UdfGet(udf, _this, funcPtr);\n    Jsi_Value *vPos = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_Number num;\n    if (Jsi_ValueGetNumber(interp, vPos, &num) != JSI_OK)\n        return JSI_ERROR;\n    num = (Jsi_Number)Jsi_Truncate(interp, udf->chan, (unsigned int)num);\n    Jsi_ValueMakeNumber(interp, ret, num);\n    return JSI_OK;\n}\n\nstatic Jsi_RC FilesysStatCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    UdfGet(udf, _this, funcPtr);\n#if JSI__FILESYS==1\n    return jsi_FileStatCmd(interp, udf->fname, _this, ret, funcPtr, 0);\n#else\n    return JSI_ERROR;\n#endif\n}\n\nstatic Jsi_RC FilesysLstatCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    UdfGet(udf, _this, funcPtr);\n#if JSI__FILESYS==1\n    return jsi_FileStatCmd(interp, udf->fname, _this, ret, funcPtr, 1);\n#else\n    return JSI_ERROR;\n#endif\n}\n\nstatic Jsi_RC FilesysTellCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    UdfGet(udf, _this, funcPtr);\n    Jsi_Wide pos = Jsi_Tell(interp, udf->chan);\n    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)pos);\n    return JSI_OK;\n}\n\nstatic Jsi_RC FilesysFlushCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    UdfGet(udf, _this, funcPtr);\n    int pos = Jsi_Flush(interp, udf->chan);\n    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)pos);\n    return JSI_OK;\n}\n\nstatic Jsi_RC FilesysWriteCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int  sum = 0, n, m;\n    UdfGet(udf, _this, funcPtr);\n    char *buf = Jsi_ValueArrayIndexToStr(interp, args, 0, &m);\n\n    if (!udf->filename) {\n        goto bail;\n    }\n    while (m > 0 && sum < MAX_LOOP_COUNT && (n = Jsi_Write(interp, udf->chan, buf, m)) > 0) {\n        /* TODO: limit max size. */\n        sum += n;\n        m -= n;\n    }\nbail:\n    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)sum);\n    return JSI_OK;\n}\n\nstatic Jsi_RC FilesysPutsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n   \n    UdfGet(udf, _this, funcPtr);\n    if (!udf->filename) {\n        Jsi_ValueMakeBool(interp, ret, 0);\n        return JSI_OK;\n    }\n    Jsi_Value *toput = Jsi_ValueArrayIndex(interp, args, 0);\n    if (!toput) {\n        Jsi_ValueMakeBool(interp, ret, 0);\n        return JSI_OK;\n    }\n    const char * cp = Jsi_ValueToString(interp, toput, NULL);\n\n    if (Jsi_Printf(interp, udf->chan, \"%s\\n\", cp?cp:\"\") < 0) {\n        Jsi_ValueMakeBool(interp, ret, 0);\n        return JSI_OK;\n    }\n    Jsi_ValueMakeBool(interp, ret, 1);\n    return JSI_OK;\n}\n\nstatic Jsi_RC FilesysEofCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    UdfGet(udf, _this, funcPtr);\n    Jsi_ValueMakeBool(interp, ret, Jsi_Eof(interp, udf->chan));\n    return JSI_OK;\n}\n\nint Jsi_Printf(Jsi_Interp *interp, Jsi_Channel chan, const char *fmt, ...)\n{\n    va_list va;\n    int n;\n    FILE *fp = (chan && chan->fp ? chan->fp : stdout);\n    va_start(va,fmt);\n    n = vfprintf(fp, fmt, va);\n    va_end(va);\n    return n;\n}\n\nint Jsi_Puts(Jsi_Interp *interp, Jsi_Channel chan, const char *str, int size)\n{\n    int code = 0, len = Jsi_Strlen(str);\n    if (chan->fsPtr==0 || !chan->fsPtr->putsProc) {\n        FILE *fp = (chan && chan->fp ? chan->fp : stdout);\n        code = fputs(str, fp);\n    } else {\n        if (interp && interp->debugOpts.putsCallback && interp->parent) {\n            int code = 0;\n            Jsi_DString jStr={}, kStr={};\n            Jsi_DSPrintf(&kStr, \"[%s, %d]\",\n                Jsi_JSONQuote(interp, str, size, &jStr), (chan->fp == stderr?1:0));\n            if (Jsi_FunctionInvokeJSON(interp->parent, interp->debugOpts.putsCallback, Jsi_DSValue(&kStr), NULL) != JSI_OK)\n                code = 1;\n            Jsi_DSFree(&jStr);\n            Jsi_DSFree(&kStr);\n            return code;\n        } else if (interp && interp->stdoutStr) {\n            Jsi_DString dStr = {};\n            Jsi_DSAppend(&dStr, Jsi_ValueString(interp, interp->stdoutStr, NULL), NULL);\n            Jsi_DSAppend(&dStr, str, NULL);\n            Jsi_ValueFromDS(interp, &dStr, &interp->stdoutStr);\n        } else\n\n            code = chan->fsPtr->putsProc(chan, str);\n    }\n    if (size>=0 && len < size) {\n        Jsi_Puts(interp, chan, \"\\\\0\", -1);\n        Jsi_Puts(interp, chan, str+len+1, size-len-1);\n    }\n    return code;\n}\n\nstatic Jsi_RC FilesysConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr);\n    \n\nstatic Jsi_CmdSpec filesysCmds[] = {\n    { \"Channel\",   FilesysConstructor,1,  2,  \"file:string, mode:string='r'\", .help=\"A file input/output object. The mode string is r or w and an optional +\", .retType=(uint)JSI_TT_USEROBJ, .flags=JSI_CMD_IS_CONSTRUCTOR },\n    { \"close\",  FilesysCloseCmd,   0,  0, \"\", .help=\"Close the file\", .retType=(uint)JSI_TT_BOOLEAN },\n    { \"eof\",    FilesysEofCmd,     0,  0, \"\", .help=\"Return true if read to end-of-file\", .retType=(uint)JSI_TT_BOOLEAN },\n    { \"filename\", FilesysFilenameCmd, 0,  0, \"\", .help=\"Get file name\", .retType=(uint)(uint)JSI_TT_STRING },\n    { \"flush\",  FilesysFlushCmd,   0,  0, \"\", .help=\"Flush file output\", .retType=(uint)JSI_TT_NUMBER },\n    { \"gets\",   FilesysGetsCmd,    0,  0, \"\", .help=\"Get one line of input\", .retType=(uint)JSI_TT_STRING|JSI_TT_VOID },\n    { \"lstat\",  FilesysLstatCmd,   0,  0, \"\", .help=\"Return status for file\", .retType=(uint)JSI_TT_OBJECT },\n    { \"mode\",   FilesysModeCmd,    0,  0, \"\", .help=\"Get file mode used with open\", .retType=(uint)JSI_TT_STRING },\n    { \"open\",   FilesysOpenCmd,    1, -1, \"file:string, mode:string='r'\", .help=\"Open the file (after close)\", .retType=(uint)JSI_TT_BOOLEAN },\n    { \"puts\",   FilesysPutsCmd,    1,  1, \"str\", .help=\"Write one line of output\", .retType=(uint)JSI_TT_BOOLEAN },\n    { \"read\",   FilesysReadCmd,    0,  1, \"size:number=-1\", .help=\"Read some or all of file\", .retType=(uint)JSI_TT_STRING|JSI_TT_VOID },\n    { \"seek\",   FilesysSeekCmd,    2,  2, \"pos:number, whence:string\", .help=\"Seek to position. Return 0 if ok\", .retType=(uint)JSI_TT_NUMBER },\n    { \"stat\",   FilesysStatCmd,    0,  0, \"\", .help=\"Return status for file\", .retType=(uint)JSI_TT_OBJECT },\n    { \"truncate\",FilesysTruncateCmd,    1,  1, \"pos:number\", .help=\"Truncate file\", .retType=(uint)JSI_TT_NUMBER },\n    { \"tell\",   FilesysTellCmd,    0,  0, \"\", .help=\"Return current position\", .retType=(uint)JSI_TT_NUMBER },\n    { \"write\",  FilesysWriteCmd,   1,  1, \"data\", .help=\"Write data to file\", .retType=(uint)JSI_TT_NUMBER },\n    { NULL, 0,0,0,0, .help=\"Commands for accessing Channel objects for file IO\" }\n};\n\n\nstatic Jsi_UserObjReg fileobject = {\n    \"Channel\",\n    filesysCmds,\n    fileObjFree,\n    fileObjIsTrue,\n    fileObjEqual\n};\n\nstatic Jsi_RC FilesysConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Value *that = _this;\n    if (!Jsi_FunctionIsConstructor(funcPtr)) {\n        Jsi_Obj *o = Jsi_ObjNew(interp);\n        Jsi_PrototypeObjSet(interp, \"File\", o);\n        Jsi_ValueMakeObject(interp, ret, o);\n        that = *ret;\n    }\n\n    FileObj *fobj = (FileObj *)Jsi_Calloc(1,sizeof(*fobj));\n    SIGINIT(fobj, FILEOBJ);\n    if (try_open_file(interp, fobj, args) != JSI_OK) { /* Error out on open fail */\n        Jsi_Free(fobj);\n        return JSI_ERROR;\n    }\n    Jsi_Obj *nobj = (Jsi_Obj*)Jsi_ValueGetObj(interp, that);\n    fobj->objId = Jsi_UserObjNew(interp, &fileobject, nobj, fobj);\n    if (fobj->objId<0) {\n        Jsi_Free(fobj); // TODO: finish cleanup\n        return JSI_ERROR;\n    }\n    fobj->fobj = nobj;\n    return JSI_OK;\n}\n\nstatic void SetupStdChan(Jsi_Chan* ch, FILE *fp, Jsi_Filesystem *fsPtr, int flags) {\n    memset(ch, 0, sizeof(*ch));\n    ch->fp = fp;\n    ch->fsPtr = fsPtr;\n    ch->flags = flags|JSI_FS_NOCLOSE;\n}\n\nJsi_Channel Jsi_FSNameToChannel(Jsi_Interp *interp, const char *name)\n{\n    if (Jsi_Strlen(name)==1) {\n        switch (name[0]) {\n            case '0' : return jsiIntData.stdChans;\n            case '1' : return jsiIntData.stdChans+1;\n            case '2' : return jsiIntData.stdChans+2;\n        }\n    }\n    if (!Jsi_Strcmp(name, \"stdin\")) return jsiIntData.stdChans;\n    if (!Jsi_Strcmp(name, \"stdout\")) return jsiIntData.stdChans+1;\n    if (!Jsi_Strcmp(name, \"stderr\")) return jsiIntData.stdChans+2;\n    Jsi_Obj *obj = jsi_UserObjFromName(interp, name);\n    if (!obj)\n        return NULL;\n    Jsi_UserObj *uobj = obj->d.uobj;\n    if (uobj->reg != &fileobject)\n        return NULL;\n    FileObj *fobj = (FileObj *)uobj->data;\n    return fobj->chan;\n}\n\nvoid jsi_FilesysDone(Jsi_Interp *interp)\n{\n    Jsi_UserObjUnregister(interp, &fileobject);\n    Jsi_InitZvfs(interp, 1);\n    while (jsiFSList != NULL) {\n        FSList *fsPtr = jsiFSList;\n        jsiFSList = fsPtr->next;\n        if (fsPtr)\n            Jsi_Free(fsPtr);\n    }\n}\n\nJsi_RC jsi_InitFilesys(Jsi_Interp *interp, int release)\n{\n    if (release) {\n        jsi_FilesysDone(interp);\n        return JSI_OK;\n    }\n    Jsi_DSInit(&jsiIntData.pwdStr);\n    Jsi_Hash *fsys = Jsi_UserObjRegister(interp, &fileobject);\n    if (!fsys)\n        return Jsi_LogBug(\"Can not init file system\");\n    Jsi_CommandCreateSpecs(interp, fileobject.name, filesysCmds, fsys, JSI_CMDSPEC_ISOBJ);\n    if (jsiFSList == NULL) {\n        Jsi_FSRegister(&jsiFilesystem, NULL);\n        SetupStdChan(jsiIntData.stdChans, stdin, &jsiFilesystem, JSI_FS_READONLY);\n        SetupStdChan(jsiIntData.stdChans+1, stdout, &jsiFilesystem, JSI_FS_WRITEONLY);\n        SetupStdChan(jsiIntData.stdChans+2, stderr, &jsiFilesystem, JSI_FS_WRITEONLY);\n    }\n#if JSI__ZVFS==1\n    Jsi_InitZvfs(interp, 0);\n#endif\n#ifndef JSI_OMIT_VFS\n    jsi_InitVfs(interp, 0);\n#endif\n    return JSI_OK;\n}\n\n#endif // JSI_LITE_ONLY\n\n\nconst char *jsi_GetHomeDir(Jsi_Interp *interp) {\n    const char *str = NULL;\n    if (interp->homeDir)\n        return interp->homeDir;\n#ifdef __WIN32\n    str = getenv(\"USERPROFILE\"); /* TODO: windows home dir. */\n#else\n        \n    if ((str = getenv(\"HOME\")) == NULL) {\n        struct passwd pwd, *pw;\n        char buf[20000];\n        if (getpwuid_r(getuid(), &pwd, buf, sizeof(buf), &pw) == 0 && pw->pw_dir)        \n            str = pw->pw_dir;\n    }\n#endif\n    if (!str) {\n        Jsi_LogBug(\"no home dir\");\n        str = \"/\";\n    }\n#ifdef JSI_LITE_ONLY\n    return str;\n#else\n    return (interp->homeDir = Jsi_KeyAdd(interp, str));\n#endif\n}\n\n/* TODO: reconcile with NormalizeUnixPath */\nchar* Jsi_NormalPath(Jsi_Interp *interp, const char *path, Jsi_DString *dStr) {\n    char prefix[3] = \"\";\n    char cdbuf[PATH_MAX];\n    Jsi_DSInit(dStr);\n    if (!path || !path[0]) return NULL;\n    if (*path == '/')\n        Jsi_DSAppend(dStr, path, NULL);\n#ifdef __WIN32  /* TODO: add proper handling for windows paths. */\n    else if (*path && path[1] == ':') {\n        Jsi_DSAppend(dStr, path, NULL);\n        return Jsi_DSValue(dStr);\n    }\n#endif\n    else if (path[0] == '~') {\n        Jsi_DSAppend(dStr, jsi_GetHomeDir(interp), (path[1] == '/' ? \"\" : \"/\"), path+1, NULL);\n    } else if (path[0] == '.' && path[1] == 0) {\n        if (jsiIntData.pwd) {\n            Jsi_DSAppend(dStr, jsiIntData.pwd, NULL);\n        } else {\n            Jsi_DSAppend(dStr, getcwd(cdbuf, sizeof(cdbuf)), NULL);\n        }\n    } else {\n        if (jsiIntData.pwd) {\n            Jsi_DSAppend(dStr, jsiIntData.pwd, \"/\", path, NULL);\n        } else {\n            Jsi_DSAppend(dStr, getcwd(cdbuf, sizeof(cdbuf)), \"/\", path, NULL);\n        }\n    }\n    Jsi_DString sStr = {};\n    char *cp = Jsi_DSValue(dStr);\n#ifdef __WIN32\n    if (*cp && cp[1] == ':') {\n        prefix[0] = *cp;\n        prefix[1] = cp[1];\n        prefix[2] = 0;\n        cp += 2;\n    }\n#endif\n    int i=0, n=0, m, nmax, unclean=0, slens[PATH_MAX];\n    char *sp = cp, *ss;\n    char *sptrs[PATH_MAX];\n    while (*cp && n<PATH_MAX) {\n        while (*cp && *cp == '/') {\n            cp++;\n            if (*cp == '/')\n                unclean = 1;\n        }\n        sptrs[n] = cp;\n        if (cp[0] == '.' && (cp[1] == '.' || cp[1] == '/'))\n            unclean = 1;\n        ss = cp++;\n        while (*ss && *ss != '/')\n            ss++;\n        slens[n++] = (ss-cp) + 1;\n        cp = ss;\n    }\n    if (!unclean)\n        return sp;\n    /* Need to remove //, /./, /../ */\n    nmax = n--;\n    while (n>0) {\n        if (slens[n]<=0) {\n            n--;\n            continue;\n        }\n        if (Jsi_Strncmp(sptrs[n],\".\",slens[n])==0)\n            slens[n] = 0;\n        else if (Jsi_Strncmp(ss,\"..\",slens[n])==0) {\n            int cnt = 0;\n            m = n-1;\n            while (m>=0 && cnt<1) {\n                if (slens[m])\n                    cnt++;\n                slens[m] = 0;\n                m--;\n            }\n            if (cnt<1)\n                return sp;  /* Can't fix it */\n        }\n        n--;\n    }\n    /* TODO: prefix for windows. */\n    Jsi_DSAppend(&sStr, prefix, NULL);\n    for (i=0; i<nmax; i++) {\n        if (slens[i]) {\n#ifdef __WIN32\n            Jsi_DSAppend(&sStr, \"/\" /*\"\\\\\"*/, NULL);\n#else\n            Jsi_DSAppend(&sStr, \"/\", NULL);\n#endif\n            Jsi_DSAppendLen(&sStr, sptrs[i], slens[i]);\n        }\n    }\n    Jsi_DSSetLength(dStr, 0);\n    Jsi_DSAppend(dStr, Jsi_DSValue(&sStr), NULL);\n    Jsi_DSFree(&sStr);\n    return Jsi_DSValue(dStr);\n}\n\n#ifdef __WIN32\n#define realpath(R,N) _fullpath(N,R, _MAX_PATH)\n\n/* For ridding backslashes from env vars */\nstatic void DeBackSlashify(char *cp) {\n    char *dp = cp;\n    while (*cp) {\n        if (*cp == '\\\\') {\n            *dp = '/';\n        } else\n            *dp = *cp;\n        cp++; dp++;\n    }\n    *dp = 0;\n}\n\n#else\n\nstatic void NormalizeUnixPath(Jsi_Interp *interp, char *path) {\n    char **argv; int argc, i;\n    if (!Jsi_Strstr(path, \"./\")) return;\n    Jsi_DString dStr = {}, eStr = {};\n    if (path[0] != '/' && Jsi_Strstr(path, \"..\")) {\n        char *npath = Jsi_GetCwd(interp, &eStr);\n        if (npath && Jsi_Strcmp(npath,\"/\")) {\n            Jsi_DSAppend(&eStr, \"/\", path, NULL);\n            path = Jsi_DSValue(&eStr);\n        }\n    }\n    Jsi_DString sStr;\n    Jsi_DSInit(&sStr);\n    Jsi_SplitStr(path, &argc, &argv, \"/\", &sStr);\n    char *cp = path;\n    *cp = 0;\n    for (i=0; i<argc; i++) {\n        if (i == 0 && argv[0][0] == 0) {\n            continue;\n        } else if (argv[i][0] == 0) {\n            continue;\n        } else if (i && !Jsi_Strcmp(argv[i],\".\")) {\n            continue;\n        } else if (!Jsi_Strcmp(argv[i],\"..\")) {\n            char *pcp = Jsi_DSValue(&dStr), *lcp = pcp;\n            pcp = Jsi_Strrchr(pcp, '/');\n            if (pcp && pcp != Jsi_DSValue(&dStr)) {\n                *pcp = 0;\n                Jsi_DSSetLength(&dStr, Jsi_Strlen(lcp));\n            }\n            continue;\n        } else {\n            Jsi_DSAppend(&dStr, (i>0?\"/\":\"\"), argv[i], NULL);\n        }\n    }\n    Jsi_DSFree(&sStr);\n    Jsi_Strcpy(path, Jsi_DSValue(&dStr));\n    Jsi_DSFree(&dStr);\n    Jsi_DSFree(&eStr);\n}\n#endif\n\nchar * Jsi_GetCwd(Jsi_Interp *interp, Jsi_DString *cwdPtr) {\n    char cdbuf[PATH_MAX];\n    Jsi_DSInit(cwdPtr);\n    if (jsiIntData.cwdFsPtr)\n        Jsi_DSAppend(cwdPtr, Jsi_DSValue(&jsiIntData.pwdStr), NULL);\n    else\n        Jsi_DSAppend(cwdPtr, getcwd(cdbuf, sizeof(cdbuf)), NULL);\n#ifdef __WIN32\n    DeBackSlashify(Jsi_DSValue(cwdPtr));\n#endif\n    return Jsi_DSValue(cwdPtr);\n}\n\nchar *Jsi_FileRealpathStr(Jsi_Interp *interp, const char *path, char *newname)\n{\n    if (!path || !path[0]) return NULL;\n    Jsi_DString dStr, eStr;\n    char *npath = (char*)path, *apath;\n    Jsi_DSInit(&dStr); Jsi_DSInit(&eStr);\n    if (*path == '~') {\n#ifndef __WIN32\n        struct passwd pw, *pwp; /* TODO: could fallback to using env HOME. */\n        char buf[JSI_BUFSIZ];\n        int n = getpwuid_r(getuid(), &pw, buf, sizeof(buf), &pwp);\n        const char *homedir = (n == 0 ? pwp->pw_dir : \"\");\n        Jsi_DSAppend(&dStr, homedir, path[1] == '/' ? \"\" : \"/\", path+1, NULL);\n#else\n        const char *homedir = getenv(\"HOMEPATH\");\n        if (!homedir) homedir = \"/\";\n        const char *homedrv = getenv(\"HOMEDRIVE\");\n        if (!homedrv) homedrv = \"\";\n        Jsi_DSAppend(&dStr, homedrv, homedir, path[1] == '/' ? \"\" : \"/\", path+1, NULL);\n#endif\n        npath = Jsi_DSValue(&dStr);\n    }\n#ifdef __WIN32\n    if (Jsi_Strncmp(path, JSI_ZVFS_DIR, sizeof(JSI_ZVFS_DIR)-1)==0 || Jsi_Strncmp(path, JSI_VFS_DIR, sizeof(JSI_VFS_DIR)-1)==0)\n        apath = NULL;\n    else\n#endif\n    apath = realpath(npath, newname);\n    if (!apath) {\n        if ((path[0] == '.' && path[1] == '/') || (path[0] != '/' && \n        !(path[0] == '.' && path[1] == '.') && path[1] != ':')) {\n            Jsi_GetCwd(interp, &eStr);\n            Jsi_DSAppend(&eStr, \"/\", path, NULL);\n            npath = Jsi_DSValue(&eStr);\n            apath = realpath(npath, newname);\n            //npath = (char*)path;\n        }\n    }\n    if (!apath) {\n        if (newname)\n            Jsi_Strcpy(apath=newname, npath);\n        else\n            apath = Jsi_Strdup(npath);\n#ifndef __WIN32\n        /* If path not exists on unix we try to eliminate ../ and /./ etc.*/\n        NormalizeUnixPath(interp, apath);\n#endif\n    }\n#ifdef __WIN32\n    DeBackSlashify(apath);\n#endif\n    Jsi_DSFree(&dStr); Jsi_DSFree(&eStr);\n    return apath;\n}\n\n", "#ifndef JSI_LITE_ONLY\n#ifndef JSI_AMALGAMATION\n#include \"jsiInt.h\"\n#endif\n\n/* Return value from call to function will is not used. */\nbool Jsi_FunctionReturnIgnored(Jsi_Interp *interp, Jsi_Func *funcPtr) {\n    return funcPtr->callflags.bits.isdiscard;\n}\n\nbool Jsi_FunctionIsConstructor(Jsi_Func *funcPtr)\n{\n    return (funcPtr->f.bits.iscons);\n}\n\nJsi_CmdSpec *Jsi_FunctionGetSpecs(Jsi_Func *funcPtr)\n{\n    return funcPtr->cmdSpec;\n}\n\nvoid *Jsi_FunctionPrivData(Jsi_Func *funcPtr)\n{\n    return funcPtr->privData;\n}\n\nconst char *jsi_TypeName(Jsi_Interp *interp, Jsi_ttype otyp)\n{\n    switch (otyp) {\n        case JSI_TT_NUMBER:     return \"number\"; \n        case JSI_TT_STRING:     return \"string\"; \n        case JSI_TT_BOOLEAN:    return \"boolean\"; \n        case JSI_TT_ARRAY:      return \"array\"; \n        case JSI_TT_FUNCTION:   return \"function\"; \n        case JSI_TT_OBJECT:     return \"object\"; \n        case JSI_TT_REGEXP:     return \"regexp\"; \n        case JSI_TT_ANY:        return \"any\"; \n        case JSI_TT_USEROBJ:    return \"userobj\"; \n        case JSI_TT_ITEROBJ:    return \"iterobj\"; \n        case JSI_TT_UNDEFINED:      return \"undefined\";\n        case JSI_TT_VOID:       return \"void\";\n        case JSI_TT_NULL:       return \"null\"; \n    }\n    return \"undefined\";\n}\nconst char *jsi_ObjectTypeName(Jsi_Interp *interp, Jsi_otype otyp)\n{\n    switch (otyp) {\n        case JSI_OT_NUMBER:     return \"number\"; \n        case JSI_OT_STRING:     return \"string\"; \n        case JSI_OT_BOOL:       return \"boolean\"; \n        case JSI_OT_ARRAY:      return \"array\"; \n        case JSI_OT_FUNCTION:   return \"function\"; \n        case JSI_OT_OBJECT:     return \"object\"; \n        case JSI_OT_REGEXP:     return \"regexp\"; \n        case JSI_OT_ITER:       return \"iter\"; \n        case JSI_OT_USEROBJ:    return \"userobj\"; \n        case JSI_OT_UNDEF:      return \"any\";\n    }\n    return \"undefined\";\n}\n\nconst char *jsi_ValueTypeName(Jsi_Interp *interp, Jsi_Value *val)\n{\n    switch (val->vt) {\n        case JSI_VT_NUMBER:     return \"number\"; \n        case JSI_VT_STRING:     return \"string\"; \n        case JSI_VT_BOOL:       return \"boolean\"; \n        case JSI_VT_OBJECT:     if (val->d.obj->ot == JSI_OT_OBJECT && val->d.obj->isarrlist) return \"array\"; return jsi_ObjectTypeName(interp, val->d.obj->ot); \n        case JSI_VT_VARIABLE:   return \"variable\"; \n        case JSI_VT_NULL:       return \"null\"; \n        case JSI_VT_UNDEF:      break;\n    }\n    return \"undefined\";\n}\n\nint jsi_typeGet(Jsi_Interp *interp, const char *tname) {\n    if (!tname)\n        return 0;\n    if (Jsi_Strchr(tname, '|')) {\n        int argc, i, rc, val = 0;\n        char **argv;\n        Jsi_DString dStr;\n        Jsi_DSInit(&dStr);\n        Jsi_SplitStr(tname, &argc, &argv, \"|\", &dStr);\n        for (i=0; i<argc; i++) {\n            rc = jsi_typeGet(interp, argv[i]);\n            if (rc < 0)\n                break;\n            val |= rc;\n        }\n        Jsi_DSFree(&dStr);\n        if (i<argc)\n            return -1;\n        return val;\n    }\n    switch (tname[0]) {\n        case 'b': if (Jsi_Strcmp(tname, \"boolean\")==0) return JSI_TT_BOOLEAN; break;\n        case 's': if (Jsi_Strcmp(tname, \"string\")==0) return JSI_TT_STRING; break;\n        case 'n': if (Jsi_Strcmp(tname, \"null\")==0) return JSI_TT_NULL;\n                  if (Jsi_Strcmp(tname, \"number\")==0) return JSI_TT_NUMBER; break;\n        case 'o': if (Jsi_Strcmp(tname, \"object\")==0) return JSI_TT_OBJECT; break;\n        case 'r': if (Jsi_Strcmp(tname, \"regexp\")==0) return JSI_TT_REGEXP; break;\n        case 'f': if (Jsi_Strcmp(tname, \"function\")==0) return JSI_TT_FUNCTION; break;\n        case 'i': if (Jsi_Strcmp(tname, \"iterobj\")==0) return JSI_TT_ITEROBJ;\n        case 'u': if (Jsi_Strcmp(tname, \"userobj\")==0) return JSI_TT_USEROBJ;\n                  if (Jsi_Strcmp(tname, \"undefined\")==0) return JSI_TT_UNDEFINED; break;\n        case 'a': if (Jsi_Strcmp(tname, \"array\")==0) return JSI_TT_ARRAY;\n                  if (Jsi_Strcmp(tname, \"any\")==0) return JSI_TT_ANY; break;\n        case 'v': if (Jsi_Strcmp(tname, \"void\")==0) return JSI_TT_VOID; break;\n    }\n    Jsi_LogWarn(\"Type \\\"%s\\\" is not one of boolean, string, number, function, array, object, regexp, userobj, null, undefined, void or any\", tname);\n    return 0;\n}\n\nconst char *jsi_typeName(Jsi_Interp *interp, int typ, Jsi_DString *dStr) {\n    if (typ<=0 || (typ&JSI_TT_ANY)) {\n        Jsi_DSAppend(dStr, \"any\", NULL);\n        return Jsi_DSValue(dStr);\n    }\n    int i = 0;\n    if (typ&JSI_TT_NUMBER) Jsi_DSAppend(dStr, (i++?\"|\":\"\"), \"number\", NULL);\n    if (typ&JSI_TT_STRING) Jsi_DSAppend(dStr, (i++?\"|\":\"\"), \"string\", NULL);\n    if (typ&JSI_TT_BOOLEAN)  Jsi_DSAppend(dStr, (i++?\"|\":\"\"), \"boolean\", NULL);\n    if (typ&JSI_TT_ARRAY)   Jsi_DSAppend(dStr, (i++?\"|\":\"\"), \"array\", NULL);\n    if (typ&JSI_TT_FUNCTION) Jsi_DSAppend(dStr, (i++?\"|\":\"\"), \"function\", NULL);\n    if (typ&JSI_TT_OBJECT) Jsi_DSAppend(dStr, (i++?\"|\":\"\"), \"object\", NULL);\n    if (typ&JSI_TT_REGEXP) Jsi_DSAppend(dStr, (i++?\"|\":\"\"), \"regexp\", NULL);\n    if (typ&JSI_TT_USEROBJ) Jsi_DSAppend(dStr, (i++?\"|\":\"\"), \"userobj\", NULL);\n    if (typ&JSI_TT_ITEROBJ) Jsi_DSAppend(dStr, (i++?\"|\":\"\"), \"iterobj\", NULL);\n    if (typ&JSI_TT_NULL) Jsi_DSAppend(dStr, (i++?\"|\":\"\"), \"null\", NULL);\n    if (typ&JSI_TT_UNDEFINED) Jsi_DSAppend(dStr, (i++?\"|\":\"\"), \"undefined\", NULL);\n    if (typ&JSI_TT_VOID) Jsi_DSAppend(dStr, (i++?\"|\":\"\"), \"void\", NULL);\n    return Jsi_DSValue(dStr);\n}\n\nconst char* jsi_FuncGetCode(Jsi_Interp *interp, Jsi_Func *func, int *lenPtr) {\n    if (interp->subOpts.noFuncString || !func->bodyStr)\n        return NULL;\n    const char *cp, *cp2;\n    if (func->startPos == -1) {\n        cp = func->bodyStr;\n        int cplin = func->bodyline.last_line-1;\n        while (*cp && cplin>0) {\n            if (*cp=='\\n' && --cplin<=0)\n                break;\n            cp++;\n        }\n        while (*cp && isspace(*cp))\n            cp++;\n        func->startPos = (*cp?(cp - func->bodyStr):-2);\n    }\n    if (func->startPos >= 0) {\n        int len = func->endPos - func->startPos;\n        cp = func->bodyStr + func->startPos;\n        while (len>0 && (isspace(cp[len-1]) || cp[len-1]==';')) len--;\n        if (*cp != 'f' && Jsi_Strncmp(cp, \"function\", 8) && (cp2=Jsi_Strstr(cp, \"function\"))) {\n            len -= (cp2-cp);\n            cp = cp2;\n        }\n        *lenPtr = len;\n        return cp;\n    }\n    return NULL;\n}\n\nconst char *jsiFuncInfo(Jsi_Interp *interp, Jsi_DString *dStr, Jsi_Func* func, Jsi_Value *arg) {\n    if (!func) return \"\";\n    if (func->name)\n        Jsi_DSPrintf(dStr, \", in call to '%s'\", func->name);\n    else\n        Jsi_DSPrintf(dStr, \", in call to function\");\n    if (func->script) {\n        const char *cp = Jsi_Strrchr(func->script, '/');\n        if (cp)\n            cp++;\n        else\n            cp = func->script;\n        Jsi_DSPrintf(dStr, \" declared at %s:%d.%d\", cp, func->bodyline.first_line, func->bodyline.first_column);\n    }\n        if (arg) {\n        Jsi_DSAppend(dStr, \" <\", NULL);\n        Jsi_ValueGetDString(interp, arg, dStr, 0);\n        Jsi_DSAppend(dStr, \">.\", NULL);\n    }\n    return Jsi_DSValue(dStr);\n}\n\n// Check argument matches type.  If func is null, this is a parse. An index of 0 is the return value.\nJsi_RC jsi_ArgTypeCheck(Jsi_Interp *interp, int typ,  Jsi_Value *arg, const char *p1,\n    const char *p2, int index, Jsi_Func *func, bool isdefault) {\n    Jsi_RC rc = JSI_OK;\n    char idxBuf[200];\n    idxBuf[0] = 0;\n    if (func && arg->vt == JSI_VT_UNDEF && !interp->typeCheck.noundef && index>0 && !isdefault && !(typ&JSI_TT_UNDEFINED)) {\n        snprintf(idxBuf, sizeof(idxBuf), \" arg %d\", index);\n        jsi_TypeMismatch(interp);\n       \n        Jsi_DString fStr = {};\n        rc = Jsi_LogType(\"call with undefined var %s%s '%s'%s\", p1, idxBuf, p2, jsiFuncInfo(interp, &fStr, func, arg));\n        Jsi_DSFree(&fStr);\n        return rc;\n    }\n    if (typ <= 0)\n        return JSI_OK;\n    //if (typ&JSI_TT_VOID)\n    //    return JSI_OK;\n    if (interp->typeCheck.all==0) {\n        if (func ? (interp->typeCheck.run==0) : (interp->typeCheck.parse==0))\n            return JSI_OK;\n    }\n    if (index == 0 && func && func->type == FC_BUILDIN && \n        interp->typeCheck.all == 0) // Normally do not check return types for builtins.\n        return JSI_OK; \n    if ((typ&JSI_TT_ANY)) return JSI_OK;\n    if (index == 0 && arg->vt == JSI_VT_UNDEF) {\n        if (!(typ&JSI_TT_VOID)) \n            goto done;\n        return JSI_OK;\n    }\n    if (isdefault && index && typ&JSI_TT_VOID && arg->vt == JSI_VT_UNDEF)\n        return JSI_OK;\n    if (typ&JSI_TT_UNDEFINED && Jsi_ValueIsUndef(interp, arg)) return rc;\n    if (typ&JSI_TT_NUMBER && Jsi_ValueIsNumber(interp, arg)) return rc;\n    if (typ&JSI_TT_STRING && Jsi_ValueIsString(interp, arg)) return rc;\n    if (typ&JSI_TT_BOOLEAN && Jsi_ValueIsBoolean(interp, arg))  return rc;\n    if (typ&JSI_TT_ARRAY && Jsi_ValueIsArray(interp, arg))   return rc;\n    if (typ&JSI_TT_FUNCTION && Jsi_ValueIsFunction(interp, arg)) return rc;\n    if (typ&JSI_TT_REGEXP && Jsi_ValueIsObjType(interp, arg, JSI_OT_REGEXP)) return rc;\n    if (typ&JSI_TT_USEROBJ && Jsi_ValueIsObjType(interp, arg, JSI_OT_USEROBJ)) return rc;\n    if (typ&JSI_TT_ITEROBJ && Jsi_ValueIsObjType(interp, arg, JSI_OT_ITER)) return rc;\n    if (typ&JSI_TT_OBJECT && (\n        Jsi_ValueIsObjType(interp, arg, JSI_OT_OBJECT) && Jsi_ValueIsArray(interp, arg)==0))\n        return rc;\n    if (typ&JSI_TT_NULL && Jsi_ValueIsNull(interp, arg)) return rc;\ndone:\n    {\n        Jsi_DString dStr = {};\n        const char *exp = jsi_typeName(interp, typ, &dStr);\n        const char *vtyp = jsi_ValueTypeName(interp, arg);\n        if (index>0)\n            snprintf(idxBuf, sizeof(idxBuf), \" arg %d\", index);\n        if (interp->typeCheck.error)\n            rc = JSI_ERROR;\n        jsi_TypeMismatch(interp);\n        Jsi_DString fStr = {};\n        rc = Jsi_LogType(\"type mismatch %s%s '%s': expected \\\"%s\\\" but got \\\"%s\\\"%s\",\n            p1, idxBuf, p2, exp, vtyp, jsiFuncInfo(interp, &fStr, func, arg));\n        Jsi_DSFree(&fStr);\n        Jsi_DSFree(&dStr);\n    }\n    return rc;\n}\n\nJsi_RC jsi_StaticArgTypeCheck(Jsi_Interp *interp, int atyp, const char *p1, const char *p2, int index, Jsi_Func *func, jsi_Pline *line) {\n    Assert(index>0);\n    Jsi_RC rc;\n    if (interp->typeCheck.parse==0 && interp->typeCheck.all==0)\n        return JSI_OK;\n    int ai = index-1+func->callflags.bits.addargs;\n    if (func->argnames == NULL || ai>=func->argnames->count || ai<0)\n        return JSI_OK;\n    int typ = func->argnames->args[ai].type;\n    if (typ <= 0)\n        return JSI_OK;\n    if (index == 0 && func && func->type == FC_BUILDIN && \n        interp->typeCheck.all==0) // Normally do not check return types for builtins.\n        return JSI_OK; \n    if ((typ&JSI_TT_ANY)) return JSI_OK;\n    if (index == 0 && atyp == JSI_VT_UNDEF) {\n        if (!(typ&JSI_TT_VOID)) \n            goto done;\n        return JSI_OK;\n    }\n/*    if (index == 0 && (typ&JSI_TT_VOID)) {\n        if (atyp != JSI_VT_UNDEF && !(typ&JSI_TT_UNDEFINED))\n            goto done;\n        return JSI_OK;\n    }*/\n    if (atyp == JSI_VT_UNDEF)\n        return JSI_OK;\n    rc = JSI_OK;\n    if (typ&JSI_TT_UNDEFINED && atyp == JSI_TT_UNDEFINED) return rc;\n    if (typ&JSI_TT_NUMBER && atyp==JSI_TT_NUMBER) return rc;\n    if (typ&JSI_TT_STRING && atyp==JSI_TT_STRING) return rc;\n    if (typ&JSI_TT_BOOLEAN && atyp==JSI_TT_BOOLEAN)  return rc;\n    if (typ&JSI_TT_ARRAY && atyp==JSI_TT_ARRAY)   return rc;\n    if (typ&JSI_TT_FUNCTION && atyp==JSI_TT_FUNCTION) return rc;\n    if (typ&JSI_TT_REGEXP && atyp==JSI_TT_REGEXP) return rc;\n    if (typ&JSI_TT_USEROBJ && atyp==JSI_TT_USEROBJ) return rc;\n    if (typ&JSI_TT_ITEROBJ && atyp==JSI_TT_ITEROBJ) return rc;\n    if (typ&JSI_TT_OBJECT && atyp==JSI_TT_OBJECT) return rc;\n    if (typ&JSI_TT_NULL && atyp==JSI_TT_NULL) return rc;\ndone:\n    {\n        Jsi_DString dStr = {};\n        const char *exp = jsi_typeName(interp, typ, &dStr);\n        const char *vtyp = jsi_TypeName(interp, (Jsi_ttype)atyp);\n        char idxBuf[200];\n        idxBuf[0] = 0;\n        if (index>0)\n            snprintf(idxBuf, sizeof(idxBuf), \" arg %d\", index);\n        if (line)\n            interp->parseLine = line;\n        if (interp->typeCheck.error)\n            rc = JSI_ERROR;\n        jsi_TypeMismatch(interp);\n        Jsi_DString fStr = {};\n        rc = Jsi_LogType(\"type mismatch %s%s '%s': expected \\\"%s\\\" but got \\\"%s\\\"%s\",\n            p1, idxBuf, p2, exp, vtyp, jsiFuncInfo(interp, &fStr, func, NULL));\n        Jsi_DSFree(&fStr);\n        Jsi_DSFree(&dStr);\n    }\n    return rc;\n}\n\nint jsiPopArgs(Jsi_OpCodes *argCodes, int i)\n{\n    int m=i-1, n = (uintptr_t)argCodes->codes[i].data, cnt = 0;\n    if (argCodes->codes[i].op == OP_OBJECT)\n        n *= 2;\n    for (; m>=0 && cnt<n; m--, cnt++) {\n        int op = argCodes->codes[m].op;\n        if (op == OP_ARRAY || op == OP_OBJECT)\n            m = jsiPopArgs(argCodes, m);\n    }\n    return m+1;\n}\n\nJsi_RC jsi_RunFuncCallCheck(Jsi_Interp *interp, Jsi_Func *func, int argc, const char *name, jsi_Pline *line, Jsi_OpCodes *argCodes, bool isParse)\n{\n    Jsi_RC rc = JSI_OK;\n    if (interp->typeCheck.all==0) {\n        if (!argCodes ? (interp->typeCheck.run==0) : (interp->typeCheck.parse==0))\n            return JSI_OK;\n    }\n\n    Jsi_CmdSpec *spec = func->cmdSpec;\n    Jsi_ScopeStrs *ss = func->argnames;\n    if (ss==NULL && spec == NULL)\n        return JSI_OK;\n    int i, minArgs, maxArgs, mis = 0, varargs = 0;\n    char nbuf[100];\n    if (func->type == FC_BUILDIN) {\n        varargs =  (spec->maxArgs<0);\n        maxArgs = spec->maxArgs + func->callflags.bits.addargs;\n        minArgs = spec->minArgs + func->callflags.bits.addargs;\n    } else {\n        varargs = ss->varargs;\n        minArgs = (ss->firstDef>0 ? ss->firstDef-1 : ss->count);\n        maxArgs = ss->count;\n        mis = (argc != ss->count);\n        if (func->retType == 0 && ss && ss->typeCnt == 0 && interp->typeCheck.all==0)\n            return JSI_OK;\n    }\n    if (varargs) {\n        if (argc >= minArgs)\n            return JSI_OK;\n        mis = (argc<minArgs);\n    } else \n        mis = (argc<minArgs || argc>maxArgs);\n    if (mis) {\n        if (varargs)\n            snprintf(nbuf, sizeof(nbuf), \"%d or more\", minArgs);\n        else if (maxArgs > minArgs)\n            snprintf(nbuf, sizeof(nbuf), \"%d-%d\", minArgs, maxArgs);\n        else\n            snprintf(nbuf, sizeof(nbuf), \"%d\", maxArgs);\n        if (line)\n            interp->parseLine = line;\n        if (interp->typeCheck.error)\n            rc = JSI_ERROR;\n        Jsi_DString dStr = {};\n        Jsi_FuncObjToString(interp, func, &dStr, 2);\n        if (isParse)\n            Jsi_LogWarn(\"got %d args, expected %s, calling %s\", argc, nbuf, Jsi_DSValue(&dStr));\n        else\n            rc = Jsi_LogType(\"got %d args, expected %s, calling %s\", argc, nbuf, Jsi_DSValue(&dStr));\n        jsi_TypeMismatch(interp);\n        Jsi_DSFree(&dStr);\n        if (line)\n            interp->parseLine = NULL;\n        return rc;\n    }\n    if (argCodes && argCodes->code_len>=argc) {\n        int cl = argCodes->code_len;\n        int aind=argc-1;\n        for (i=cl-1; rc == JSI_OK && i>=0 && aind>=0; i--,aind--) {\n            Jsi_ttype atyp = JSI_TT_ANY;\n            switch (argCodes->codes[i].op) {\n                case OP_PUSHSTR: atyp=JSI_TT_STRING; break;\n                case OP_PUSHNUM: atyp=JSI_TT_NUMBER; break;\n                case OP_PUSHBOO: atyp=JSI_TT_BOOLEAN; break;\n                case OP_PUSHFUN: atyp=JSI_TT_FUNCTION; break;\n                case OP_PUSHTHS: atyp=JSI_TT_OBJECT; break;\n                case OP_PUSHREG: atyp=JSI_TT_REGEXP; break;\n                case OP_PUSHUND: atyp=JSI_TT_VOID; break;\n                case OP_PUSHNULL: atyp=JSI_TT_NULL; break;\n                case OP_PUSHARG: atyp=JSI_TT_ARRAY; break;\n                case OP_SUBSCRIPT: i++; break;\n                case OP_ARRAY: atyp=JSI_TT_ARRAY; i=jsiPopArgs(argCodes, i); break;\n                case OP_OBJECT: atyp=JSI_TT_OBJECT; i=jsiPopArgs(argCodes, i); break;\n                default: break;\n            }\n            if (atyp == JSI_TT_ANY) continue;\n            rc = jsi_StaticArgTypeCheck(interp, atyp, \"for argument\", name, aind+1, func, line);  \n        }\n    }\n    return rc;\n}\n\nint jsi_BuiltinCmd(Jsi_Interp *interp, const char *name)\n{\n    Jsi_Value *val = Jsi_NameLookup(interp, name);\n    if (!name)\n        return 0;\n    if (!Jsi_ValueIsFunction(interp, val))\n        return 0;\n    Jsi_Func *f = val->d.obj->d.fobj->func;\n    return (f->type == FC_BUILDIN);\n}\n\n// Parse time function call checker.\nvoid jsi_FuncCallCheck(jsi_Pstate *p, jsi_Pline *line, int argc, bool isNew, const char *name, const char *namePre, Jsi_OpCodes *argCodes)\n{\n    Jsi_Interp *interp = p->interp;\n    if (name == NULL || !(interp->typeCheck.funcsig|interp->typeCheck.all|interp->typeCheck.parse))\n        return;\n    if (name && isdigit(name[0]))\n        return;\n    Jsi_Value *val;\n    val = Jsi_NameLookup2(interp, name, namePre);\n    Jsi_Func *f = NULL;\n    if (val != NULL) {\n        if (Jsi_ValueIsFunction(interp, val))\n            f = val->d.obj->d.fobj->func;\n    } else if (interp->staticFuncsTbl) {\n        f = (Jsi_Func*)Jsi_HashGet(interp->staticFuncsTbl, (void*)name, 0);\n    }\n    if (f)\n        jsi_RunFuncCallCheck(interp, f, argc, name, line, argCodes, 1);\n    else if (interp->typeCheck.funcsig && (namePre==NULL || jsi_BuiltinCmd(interp, namePre))) {\n        if (line)\n            interp->parseLine = line;\n        Jsi_LogWarn(\"called function '%s' with no previous definition\", name);\n        jsi_TypeMismatch(interp);\n        if (line)\n            interp->parseLine = NULL;\n    }\n}\n\nint jsi_FuncSigsMatch(jsi_Pstate *pstate, Jsi_Func *f1, Jsi_Func *f2)\n{\n    // Skip where both functions have no types.\n    if (f1->retType==0 && f1->argnames->typeCnt==0 && f1->argnames->varargs==0 &&\n        f2->retType==0 && f2->argnames->typeCnt==0 && f2->argnames->varargs==0 &&\n        pstate->interp->typeCheck.all==0)\n        return 1;\n    if (f1->retType != f2->retType)\n        return 0;\n    if (f1->argnames->count != f2->argnames->count)\n        return 0;\n    if (f1->argnames->typeCnt != f2->argnames->typeCnt)\n        return 0;\n    if (f1->argnames->varargs != f2->argnames->varargs)\n        return 0;\n    int i;\n    for (i=0; i<f1->argnames->count; i++) {\n        Jsi_ScopeStrs *a1 = f1->argnames, *a2 = f2->argnames;\n        if (a1->args[i].type != a2->args[i].type)\n            return 0;\n        Jsi_Value *v1, *v2;\n        v1 = a1->args[i].defValue;\n        v2 = a2->args[i].defValue;\n        if (v1==NULL && v2 == NULL)\n            continue;\n        if (v1==NULL || v2 == NULL)\n            return 0;\n        if (v1->vt != v2->vt)\n            return 0;\n        if (Jsi_ValueCmp(pstate->interp, v1, v2, 0))\n            return 0;\n    }\n    return 1;\n}\n\n// Return directive from first instruction.\nconst char* jsi_GetDirective(Jsi_Interp *interp, Jsi_OpCodes *ops, const char *str) {\n    if (!ops) return NULL;\n    if (!ops->code_len) return NULL;\n    if (ops->codes[0].op != OP_PUSHSTR || !ops->codes[0].data) return NULL;\n    if (Jsi_Strncmp((char*)ops->codes[0].data, str, Jsi_Strlen(str))) return NULL;\n    return (char*)ops->codes[0].data;\n}\n\n/* TODO: if not in a file (an eval) save copy of body string from pstate->lexer??? */\nJsi_Func *jsi_FuncMake(jsi_Pstate *pstate, Jsi_ScopeStrs *args, Jsi_OpCodes *ops, jsi_Pline* line, const char *name, int isArrow)\n{\n    Jsi_Interp *interp = pstate->interp;\n    Jsi_ScopeStrs *localvar = jsi_ScopeGetVarlist(pstate);\n    Jsi_Func *f = jsi_FuncNew(interp);\n    jsi_Lexer *l = pstate->lexer;\n    if (isArrow)\n        f->isArrow = isArrow;\n    f->type = FC_NORMAL;\n    f->opcodes = ops;\n    f->argnames = args;\n    f->localnames = localvar;\n    f->script = interp->curFile;\n    f->bodyline = *line;\n    f->retType = (Jsi_otype)args->retType;\n    if (!pstate->eval_flag) {\n        f->scriptFile = f->script;\n    }\n    if (l->ltype == LT_STRING)\n        f->bodyStr = l->d.str;\n    f->endPos = l->cur;\n    f->startPos = -1; // Have to get these from newline count.\n    if (f->retType & JSI_TT_UNDEFINED)\n        Jsi_LogWarn(\"illegal use of 'undefined' in a return type: %s\", name?name:\"\");\n    \n    //f->strict = (jsi_GetDirective(interp, ops, \"use strict\") != NULL);\n    pstate->argType = 0;\n    if (localvar && args && (interp->strict)) {\n        int i, j;\n        for (i=0; i<args->count; i++) {\n            for (j=0; j<args->count; j++) {\n                if (i != j && !Jsi_Strcmp(args->args[i].name, args->args[j].name)) {\n                        if (line)\n                            interp->parseLine = line;\n                        Jsi_LogWarn(\"function %s():  duplicate parameter name '%s'\", name?name:\"\", args->args[i].name);\n                        if (line)\n                            interp->parseLine = NULL;\n                        jsi_TypeMismatch(interp);\n                        if (interp->typeCheck.error)\n                            pstate->err_count++;\n                }\n            }\n            for (j=0; j<localvar->count; j++) {\n                if (!Jsi_Strcmp(localvar->args[j].name, args->args[i].name)) {\n                        if (line)\n                            interp->parseLine = line;\n                        Jsi_LogWarn(\"function %s():  parameter name conflicts with 'var %s'\", name?name:\"\", localvar->args[j].name);\n                        if (line)\n                            interp->parseLine = NULL;\n                        jsi_TypeMismatch(interp);\n                        if (interp->typeCheck.error)\n                            pstate->err_count++;\n                }\n            }\n        }\n    }\n    if (name) {\n        f->name = Jsi_KeyAdd(interp, name);\n        if ((interp->typeCheck.run|interp->typeCheck.parse|interp->typeCheck.all|interp->typeCheck.funcsig)) {\n            \n            if (f->retType && !(f->retType&JSI_TT_VOID) && ops && ops->code_len && ops->codes[ops->code_len-1].op != OP_RET) {\n                if (line)\n                    interp->parseLine = line;\n                Jsi_LogWarn(\"missing return at end of function '%s'\", name);\n                if (line)\n                    interp->parseLine = NULL;\n                //if (interp->typeCheck.error)\n                 //   pstate->err_count++;\n            }\n             \n            if (interp->staticFuncsTbl) {\n                Jsi_Func *fo = (Jsi_Func*)Jsi_HashGet(interp->staticFuncsTbl, (void*)name, 0);\n                \n                // Forward declaration signature compare (indicated by an empty body).\n                if (interp->typeCheck.funcsig && fo && fo->opcodes && fo->opcodes->code_len == 1 && fo->opcodes->codes->op == OP_NOP) {\n                    if (!jsi_FuncSigsMatch(pstate, f, fo)) {\n                        if (line)\n                            interp->parseLine = line;\n                        Jsi_LogWarn(\"possible signature mismatch for function '%s' at %.120s:%d\", name, fo->script, fo->bodyline.first_line);\n                        if (line)\n                            interp->parseLine = NULL;\n                        jsi_TypeMismatch(interp);\n                    }\n                    //printf(\"OLD: %s\\n\", name);\n                }\n                Jsi_HashSet(interp->staticFuncsTbl, name, f);\n            }\n        }\n    }\n    return f;\n}\n\nJsi_RC Jsi_FunctionArguments(Jsi_Interp *interp, Jsi_Value *func, int *argcPtr)\n{\n    Jsi_FuncObj *funcPtr;\n    Jsi_Func *f;\n    if (!Jsi_ValueIsFunction(interp, func))\n        return JSI_ERROR;\n    funcPtr = func->d.obj->d.fobj;\n    f = funcPtr->func;\n    SIGASSERT(f, FUNC);\n    *argcPtr = f->argnames->count;\n    return JSI_OK;\n}\n\nbool jsi_FuncIsNoop(Jsi_Interp* interp, Jsi_Value *func) {\n    Jsi_FuncObj *funcPtr;\n    Jsi_Func *f;\n    if (func->vt != JSI_VT_OBJECT || func->d.obj->ot != JSI_OT_FUNCTION)\n        return 0;\n    funcPtr = func->d.obj->d.fobj;\n    f = funcPtr->func;\n    return (f->callback == jsi_NoOpCmd);\n}\n\nvoid jsi_InitLocalVar(Jsi_Interp *interp, Jsi_Value *arguments, Jsi_Func *who)\n{\n    SIGASSERTV(who, FUNC);\n    if (who->localnames) {\n        int i;\n        for (i = 0; i < who->localnames->count; ++i) {\n            const char *argkey = jsi_ScopeStrsGet(who->localnames, i);\n            if (argkey) {\n                DECL_VALINIT(key);// = VALINIT;\n                Jsi_Value *v __attribute__((unused));\n                Jsi_Value *kPtr = &key; // Note: a string key so no reset needed.\n                Jsi_ValueMakeStringKey(interp, &kPtr, argkey);\n                v = jsi_ValueObjKeyAssign(interp, arguments, kPtr, NULL, JSI_OM_DONTENUM);\n                jsi_ValueDebugLabel(v, \"locals\", who->name);\n            }\n        }\n    }\n}\n\nJsi_RC jsi_FuncArgsToString(Jsi_Interp *interp, Jsi_Func *f, Jsi_DString *dStr, int withTypes)\n{\n    if (f->type == FC_NORMAL) {\n        int i;\n        for (i = 0; i < f->argnames->count; ++i) {\n            jsi_ArgValue *av = f->argnames->args+i;\n            if (i) Jsi_DSAppend(dStr, \", \", NULL);\n            Jsi_DSAppend(dStr,  jsi_ScopeStrsGet(f->argnames, i), NULL);\n            if (withTypes && av) {\n                Jsi_DString tStr = {};\n                int atyp = av->type;\n                if (av->defValue)\n                    atyp &= ~(av->defValue->vt==JSI_VT_NULL?JSI_TT_NULL:(1<<av->defValue->vt));\n                if (atyp) {\n                    Jsi_DSAppend(dStr, \":\", jsi_typeName(interp, atyp, &tStr), NULL);\n                }\n                Jsi_DSSetLength(&tStr, 0);\n                if (av->defValue)\n                    Jsi_DSAppend(dStr, \"=\", Jsi_ValueGetDString(interp, av->defValue, &tStr, 1), NULL);\n                Jsi_DSFree(&tStr);\n            }\n        }\n    } else if (f->cmdSpec && f->cmdSpec->argStr)\n        Jsi_DSAppend(dStr, f->cmdSpec->argStr, NULL);\n    return JSI_OK;\n}\n\nJsi_RC Jsi_FuncObjToString(Jsi_Interp *interp, Jsi_Func *f, Jsi_DString *dStr, int flags)\n{\n    int withBody = flags&1;\n    int withTypes = flags&2;\n    int withJSON = flags&4;\n    int withFull = (flags&8 && !withJSON);\n    if (withFull && f->type == FC_NORMAL && f->opcodes) {\n        int len;\n        const char *cp = jsi_FuncGetCode(interp, f, &len);\n        if (cp) {\n            Jsi_DSAppendLen(dStr,cp, len);\n            return JSI_OK;\n        }\n    }\n    Jsi_CmdSpec *spec = f->cmdSpec;\n    if (withJSON)\n        Jsi_DSAppend(dStr, \"\\\"\", NULL);\n    if (f->type == FC_NORMAL) {\n        Jsi_DSAppend(dStr, \"function \", f->name?f->name:\"\", \"(\", NULL);\n        jsi_FuncArgsToString(interp, f, dStr, withTypes);\n        Jsi_DSAppend(dStr, \")\", NULL);\n        if (withTypes && f->retType) {\n            Jsi_DString tStr;\n            Jsi_DSInit(&tStr);\n            Jsi_DSAppend(dStr, \":\", jsi_typeName(interp, f->retType, &tStr), NULL);\n            Jsi_DSFree(&tStr);\n        }\n        if (withBody)\n            Jsi_DSAppend(dStr, \" {...}\", NULL);\n    } else {\n        Jsi_DSAppend(dStr, \"function \", f->name?f->name:\"\", \"(\",\n            (spec&&spec->argStr)?spec->argStr:\"\", \")\", NULL);\n        if (withBody)\n            Jsi_DSAppend(dStr, \" { [native code] }\", NULL);\n    }\n    if (withJSON)\n        Jsi_DSAppend(dStr, \"\\\"\", NULL);\n    return JSI_OK;\n}\n\nJsi_Value *jsi_MakeFuncValue(Jsi_Interp *interp, Jsi_CmdProc *callback, const char *name, Jsi_Value** toVal, Jsi_CmdSpec *cspec)\n{\n    Jsi_Obj *o = Jsi_ObjNew(interp);\n    Jsi_Func *f = jsi_FuncNew(interp);\n    Jsi_ObjIncrRefCount(interp, o);\n    o->ot = JSI_OT_FUNCTION;\n    f->type = FC_BUILDIN;\n    f->callback = callback;\n    f->privData = NULL;\n    o->d.fobj = jsi_FuncObjNew(interp, f);\n    f->cmdSpec = cspec;\n    if (!cspec) {\n        f->cmdSpec = (Jsi_CmdSpec*)Jsi_Calloc(2,sizeof(Jsi_CmdSpec));\n        f->cmdSpec->reserved[3] = (void*)0x1;\n        f->cmdSpec->maxArgs = -1;\n        if (name)\n            f->cmdSpec->name = (char*)Jsi_KeyAdd(interp, name);\n    }\n    f->script = interp->curFile;\n    f->callback = callback;\n    return Jsi_ValueMakeObject(interp, toVal, o);\n}\n\nJsi_Value *jsi_MakeFuncValueSpec(Jsi_Interp *interp, Jsi_CmdSpec *cmdSpec, void *privData)\n{\n    Jsi_Obj *o = Jsi_ObjNew(interp);\n    Jsi_Func *f = jsi_FuncNew(interp);\n    o->ot = JSI_OT_FUNCTION;\n    f->type = FC_BUILDIN;\n    f->cmdSpec = cmdSpec;\n    f->callback = cmdSpec->proc;\n    f->privData = privData;\n    f->f.flags = (cmdSpec->flags & JSI_CMD_MASK);\n    f->script = interp->curFile;\n    o->d.fobj = jsi_FuncObjNew(interp, f);\n    return Jsi_ValueMakeObject(interp, NULL, o);\n}\n\n\n/* Call a function with args: args and/or ret can be NULL. */\nstatic Jsi_RC jsi_FunctionInvoke(Jsi_Interp *interp, Jsi_Value *tocall, Jsi_Value *args, Jsi_Value **ret, Jsi_Value *_this)\n{\n    if (interp->maxDepth>0 && interp->maxDepth && interp->callDepth>=interp->maxDepth)\n        return Jsi_LogError(\"max call depth exceeded\");\n    if (interp->deleting)\n        return JSI_ERROR;\n    if (!Jsi_ValueIsFunction(interp, tocall)) \n        return Jsi_LogError(\"can not execute expression, expression is not a function\");\n    if (!tocall->d.obj->d.fobj) {   /* empty function */\n        return JSI_OK;\n    }\n    if (!ret) {\n        if (!interp->nullFuncRet) {\n            interp->nullFuncRet = Jsi_ValueNew(interp);\n            Jsi_IncrRefCount(interp, interp->nullFuncRet);\n        }\n        ret = &interp->nullFuncRet;\n        Jsi_ValueMakeUndef(interp, ret);\n    }\n    if (!args) {\n        if (!interp->nullFuncArg) {\n            interp->nullFuncArg = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, NULL, 0, 0));\n            Jsi_IncrRefCount(interp, interp->nullFuncArg);\n        }\n        args = interp->nullFuncArg;\n    }\n    /* func to call */\n    Jsi_Func *funcPtr = tocall->d.obj->d.fobj->func;\n    SIGASSERT(funcPtr, FUNC);\n    \n    /* prepare args */\n    if (args->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, args->d.obj)) \n        return Jsi_LogError(\"argument must be an array\");\n    /* new this */\n    Jsi_Value *fthis = Jsi_ValueDup(interp, _this ? _this : tocall);\n    Jsi_Func *prevActive = interp->activeFunc;\n    Jsi_RC res = jsi_SharedArgs(interp, args, funcPtr, 1);\n    bool isalloc = 0;\n    int calltrc = 0;\n    int tc = interp->traceCall | (funcPtr->pkg?funcPtr->pkg->popts.modConf.traceCall:0);\n    interp->callDepth++;\n    if (res == JSI_OK) {\n        jsi_InitLocalVar(interp, args, funcPtr);\n        jsi_SetCallee(interp, args, tocall);\n        isalloc = 1;\n        Jsi_IncrRefCount(interp, args);\n        if (funcPtr->type == FC_NORMAL) {\n            if ((tc&jsi_callTraceFuncs) && funcPtr->name)\n                calltrc = 1;\n        } else {\n            if ((tc&jsi_callTraceCmds) && funcPtr->name)\n                calltrc = 1;\n        }\n        interp->activeFunc = funcPtr;\n        if (funcPtr->type == FC_NORMAL) {\n            if (calltrc)\n                jsi_TraceFuncCall(interp, funcPtr, NULL, fthis, args, NULL, tc);\n            res = jsi_evalcode(interp->ps, funcPtr, funcPtr->opcodes, tocall->d.obj->d.fobj->scope, \n                args, fthis, ret);\n        } else {\n            if (calltrc)\n                jsi_TraceFuncCall(interp, funcPtr, NULL, fthis, args, NULL, tc);\n            res = funcPtr->callback(interp, args, fthis, ret, funcPtr);\n        }\n        funcPtr->callCnt++;\n    }\n    interp->callDepth--;\n    if (res == JSI_OK && funcPtr->retType)\n        res = jsi_ArgTypeCheck(interp, funcPtr->retType, *ret, \"returned from\", funcPtr->name, 0, funcPtr, 0);\n    if (calltrc && (tc&jsi_callTraceReturn))\n        jsi_TraceFuncCall(interp, funcPtr, NULL, fthis, NULL, *ret, tc);\n    interp->activeFunc = prevActive;\n    jsi_SharedArgs(interp, args, funcPtr, 0);\n    if (isalloc) \n        Jsi_DecrRefCount(interp, args);\n    Jsi_DecrRefCount(interp, fthis);\n    return res;\n}\n\nJsi_RC Jsi_FunctionInvoke(Jsi_Interp *interp, Jsi_Value *func, Jsi_Value *args, Jsi_Value **ret, Jsi_Value *_this)\n{\n    // Arrange for error reporting to point to called function.\n    Jsi_Func *fstatic = func->d.obj->d.fobj->func;\n    jsi_OpCode *oldops = interp->curIp;\n    if (fstatic->opcodes)\n        interp->curIp = fstatic->opcodes->codes;\n    Jsi_RC rc = jsi_FunctionInvoke(interp, func, args, ret, _this);\n    interp->curIp = oldops;\n    if (Jsi_InterpGone(interp))\n        return JSI_ERROR;\n    return rc;\n}\n\n// Do typechecking for callback using argStr from .data in builtin Jsi_Options: may not use = or ...\nbool jsi_FuncArgCheck(Jsi_Interp *interp, Jsi_Func *f, const char *argStr)\n{\n    int i, atyp, ftyp, rc = 0, acnt;\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    int argc = 0;\n    char **argv, *sname, *stype, *cp;\n    if (!argStr)\n        goto done;\n    if (f->type == FC_BUILDIN) {\n        // Check builtin cmd\n        jsi_CommandArgCheck(interp, f->cmdSpec, f, f->parentName);\n        goto done;\n    }\n    if ((cp=Jsi_Strchr(argStr, '='))) {\n        Jsi_LogWarn(\"may not have default value in option, expected: %s\", argStr);\n        goto done;\n    }\n    if (Jsi_Strstr(argStr, \"...\")) {\n        Jsi_LogWarn(\"may not have ... in args, expected: %s\", argStr);\n        goto done;\n    }\n    if (argStr[0]) {\n        Jsi_SplitStr(argStr, &argc, &argv, \",\", &dStr);\n        if (argc<=0)\n            goto done;\n    }\n    if (!f->argnames) {\n        if (argStr[0])\n            Jsi_LogWarn(\"function has no args, expected: %s\", argStr);\n        else\n            rc = 1;\n        goto done;\n    } else {\n        if (f->argnames->varargs) { // TODO: could allow varargs...\n            if (argc < f->argnames->argCnt) {\n                Jsi_LogWarn(\"vararg argument mismatch, expected: %s\", argStr);\n                goto done;\n            }\n        }\n        else if (f->argnames->argCnt != argc) {\n            if (argc)\n                Jsi_LogWarn(\"argument mismatch, expected: %s\", argStr);\n            else\n                Jsi_LogWarn(\"function should have no arguments\");\n            goto done;\n        }\n\n    }\n    acnt = f->argnames->argCnt;\n    for (i=0; i<argc && i<acnt; i++) {\n        sname = argv[i];\n        stype = NULL;\n        while (sname && *sname && isspace(*sname)) { sname++; }\n        if ((cp=Jsi_Strchr(sname, ':')))\n        {\n            stype = cp+1;\n            *cp = 0;\n            while (*stype && isspace(*stype)) { stype++; }\n            if (*stype) {\n                cp = stype+Jsi_Strlen(stype)-1;\n                while (cp>=stype && isspace(*cp)) { *cp = 0; cp--; }\n            }\n        }\n        if (sname && *sname) {\n            cp = sname+Jsi_Strlen(sname)-1;\n            while (cp>=sname && isspace(*cp)) { *cp = 0; cp--; }\n        }\n        ftyp = f->argnames->args[i].type;\n        if (ftyp<=0 || (ftyp&JSI_TT_ANY))\n            continue;\n        atyp = jsi_typeGet(interp, stype);\n        if (ftyp != atyp && atyp) {\n            Jsi_LogWarn(\"argument %d of function \\\"%s\\\" does not match \\\"func(%s)\\\"\" ,\n                i+1, f->name, argStr);\n            goto done;\n        }\n    }\n    rc = 1;\ndone:\n    Jsi_DSFree(&dStr);\n    if (!rc)\n        jsi_TypeMismatch(interp);\n    return rc;\n}\n\n/* Call function that returns a bool with a single argument. Returns -1, else 0/1 for false/true,  */\nint Jsi_FunctionInvokeBool(Jsi_Interp *interp, Jsi_Value *func, Jsi_Value *arg)\n{\n    if (interp->deleting)\n        return JSI_ERROR;\n    Jsi_Value *vpargs, *frPtr = Jsi_ValueNew1(interp);\n    Jsi_RC rc;\n    int bres = 0;\n    if (!arg) {\n        if (!interp->nullFuncArg) {\n            interp->nullFuncArg = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, NULL, 0, 0));\n            Jsi_IncrRefCount(interp, interp->nullFuncArg);\n        }\n        vpargs = interp->nullFuncArg;\n    } else {\n        vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, &arg, 1, 1));\n    }\n    Jsi_IncrRefCount(interp, vpargs);\n    rc = Jsi_FunctionInvoke(interp, func, vpargs, &frPtr, NULL);\n    Jsi_DecrRefCount(interp, vpargs);\n    if (rc == JSI_OK)\n        bres = Jsi_ValueIsTrue(interp, frPtr);\n    else {\n        bres = 2;\n        Jsi_LogError(\"function call failed\");\n    }\n    Jsi_DecrRefCount(interp, frPtr);\n    if (Jsi_InterpGone(interp))\n        return JSI_ERROR;\n    return bres;\n}\n\n// Invoke function with one string argument.\nJsi_RC Jsi_FunctionInvokeString(Jsi_Interp *interp, Jsi_Value *func, Jsi_Value *arg, Jsi_DString *dStr)\n{\n    if (interp->deleting)\n        return JSI_ERROR;\n    Jsi_Value *vpargs, *frPtr = Jsi_ValueNew1(interp);\n    Jsi_RC rc;\n    if (!arg) {\n        if (!interp->nullFuncArg) {\n            interp->nullFuncArg = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, NULL, 0, 0));\n            Jsi_IncrRefCount(interp, interp->nullFuncArg);\n        }\n        vpargs = interp->nullFuncArg;\n    } else {\n        vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, &arg, 1, 1));\n    }\n    Jsi_IncrRefCount(interp, vpargs);\n    rc = Jsi_FunctionInvoke(interp, func, vpargs, &frPtr, NULL);\n    Jsi_DecrRefCount(interp, vpargs);\n    if (rc != JSI_OK)\n        Jsi_LogError(\"function call failed\");\n    else\n        Jsi_ValueGetDString(interp, frPtr, dStr, 0);\n    Jsi_DecrRefCount(interp, frPtr);\n    return rc;\n}\n       \n\nJsi_FuncObj *jsi_FuncObjNew(Jsi_Interp *interp, Jsi_Func *func)\n{\n    Jsi_FuncObj *f = (Jsi_FuncObj*)Jsi_Calloc(1,sizeof(Jsi_FuncObj));\n    f->interp = interp;\n    SIGINIT(f,FUNCOBJ);\n    f->func = func;\n    func->refCnt++;\n    return f;\n}\n\nvoid jsi_FuncFree(Jsi_Interp *interp, Jsi_Func *func)\n{\n    if (--func->refCnt > 0)\n        return;\n    jsi_PkgInfo *pkg = func->pkg;\n    bool profile = (interp->profile || (pkg?pkg->popts.modConf.profile:0)), \n        cover = (interp->coverage || (pkg?pkg->popts.modConf.coverage:0));\n    if (profile || cover) {\n        Jsi_DString dStr;\n        Jsi_DSInit(&dStr);\n        const char *file = func->script;\n        if (!file)\n            file = \"\";\n        int line = func->bodyline.last_line;\n        if (!func->callCnt) {\n            if (cover && func->type == FC_NORMAL && func->name)\n                Jsi_DSPrintf(&dStr, \"COVERAGE: func=%s  file=%s:%d  cover=0%%\\n\", func->name, file, line );\n        } else {\n            char buf[JSI_BUFSIZ];\n            if (func->type == FC_BUILDIN) {\n                const char *fnam = func->parentName;\n                snprintf(buf, sizeof(buf), \"cmd=%s%s%s\", fnam, fnam[0]?\".\":\"\", func->name);\n                interp->cmdSelfTime += (func->allTime-func->subTime);\n            } else {\n                \n                double coverage = 0; // Calculate hits/all.\n                if (func->opcodes && func->opcodes->code_len>0) {\n                    int i, cchit=0, ccall=0, ccline=0, cchitline=0;\n                    Jsi_OpCodes *oc = func->opcodes;\n                    for (i=0; i<oc->code_len; i++) {\n                        if (oc->codes[i].Line<=0) continue;\n                        if (ccline != oc->codes[i].Line) {\n                            ccline = oc->codes[i].Line;\n                            ccall++;\n                            interp->coverAll++;\n                        }\n                        if (cchitline != oc->codes[i].Line && oc->codes[i].hit) {\n                            cchitline = oc->codes[i].Line;\n                            cchit++;\n                            interp->coverHit++;\n                        }\n                    }\n                    if (ccall)\n                        coverage = (int)(100.0*cchit/ccall);\n                        \n                    if (cover && cchit<ccall) { // Generate the misses list.\n                        char cbuf[JSI_BUFSIZ];\n                        int lastout = 0, lastpos=0, dupcnt=0, cccnt=0;\n                        cbuf[0] = 0;\n                        ccline=cchitline=0;\n                        for (i=0; i<oc->code_len; i++) {\n                            int ismiss = 0;\n                            if (i==oc->code_len) {\n                                ismiss = (ccline>0 && cchitline != ccline);\n                            } else {\n                                if (oc->codes[i].Line<=0) continue;\n                                ismiss = (ccline>0 && ccline != oc->codes[i].Line && cchitline != ccline);\n                            }\n                            if (ismiss) {\n                                cccnt++;\n                                const char *sep = (cccnt>1?\",\":\"\");\n                                if (lastout && (lastout+1)==ccline) {\n                                    sep = \"-\";\n                                    dupcnt++;\n                                    if (dupcnt>1)\n                                        cbuf[lastpos]=0; // Inefficient, but reliable.\n                                    else\n                                        lastpos = Jsi_Strlen(cbuf);\n                                } else \n                                    dupcnt = 0;\n                                int cbl = Jsi_Strlen(cbuf);\n                                snprintf(cbuf+cbl, sizeof(cbuf)-cbl, \"%s%d\", sep, ccline);\n                                lastout = ccline;\n                            }\n                            ccline = oc->codes[i].Line;\n                            if (oc->codes[i].hit)\n                                cchitline = ccline;\n                        }\n                        Jsi_DSPrintf(&dStr, \"COVERAGE: func=%s  file=%s:%d  cover=%2.1f%%  hits=%d,  all=%d,  misses=%s\\n\", \n                            func->name, file, line, coverage, cchit, ccall, cbuf);\n                    }\n                }\n                snprintf(buf, sizeof(buf), \"cover=%#5.1f%%  func=%s file=%s:%d\", coverage, func->name, file, line);\n                interp->funcSelfTime += (func->allTime-func->subTime);\n            }\n            if (profile)\n                Jsi_DSPrintf(&dStr, \"PROFILE:  self=%6.6f  all=%6.6f  #calls=%-8d  self/call=%6.6f  all/call=%6.6f  %s %s%s\\n\",\n                    (func->allTime-func->subTime), (double)(func->allTime), func->callCnt, \n                    (double)(func->allTime-func->subTime)/func->callCnt,  (double)(func->allTime)/func->callCnt, \n                    buf, interp->parent?\" ::\":\"\", (interp->parent&&interp->name?interp->name:\"\"));\n        }\n        if (Jsi_DSLength(&dStr))\n            Jsi_Puts(interp, jsi_Stderr, Jsi_DSValue(&dStr), -1);\n        Jsi_DSFree(&dStr);\n    }\n\n    if (func->opcodes)\n        jsi_FreeOpcodes(func->opcodes);\n    if (func->hPtr)\n        Jsi_HashEntryDelete(func->hPtr);\n    if (func->localnames)\n        jsi_ScopeStrsFree(interp, func->localnames);\n    if (func->argnames)\n        jsi_ScopeStrsFree(interp, func->argnames);\n    if (func->cmdSpec && (intptr_t)func->cmdSpec->reserved[3]& 0x1)\n        Jsi_Free(func->cmdSpec);\n    _JSI_MEMCLEAR(func);\n    Jsi_Free(func);\n    interp->funcCnt--;\n}\n\nJsi_Func *jsi_FuncNew(Jsi_Interp *interp)\n{\n     Jsi_Func *func = (Jsi_Func*)Jsi_Calloc(1, sizeof(Jsi_Func));\n     SIGINIT(func, FUNC);\n     func->hPtr = Jsi_HashSet(interp->funcsTbl, func, func);\n     func->refCnt = 1;\n     interp->funcCnt++;\n     return func;\n}\n\nvoid jsi_FuncObjFree(Jsi_FuncObj *fobj)\n{\n    if (fobj->scope)\n        jsi_ScopeChainFree(fobj->interp, fobj->scope);\n    if (fobj->bindArgs)\n        Jsi_DecrRefCount(fobj->interp, fobj->bindArgs);\n    if (fobj->bindFunc)\n        Jsi_DecrRefCount(fobj->interp, fobj->bindFunc);\n    if (fobj->func)\n        jsi_FuncFree(fobj->interp, fobj->func);\n    _JSI_MEMCLEAR(fobj);\n    Jsi_Free(fobj);\n}\n\n#endif\n", "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <stdint.h>\n#ifndef JSI_AMALGAMATION\n#include \"jsiInt.h\"\n#endif\n\n#define REBUILD_MULTIPLIER  3\n\n#if JSI_IS64BIT\n#define RANDOM_INDEX        HashOneWord\n#define DOWNSHIFT_START     62\n#else \n#define RANDOM_INDEX(tablePtr, i) \\\n    (((((uintptr_t) (i))*1103515245) >> (tablePtr)->downShift) & (tablePtr)->mask)\n#define DOWNSHIFT_START 28\n#endif\n\nstatic jsi_Hash jsi_HashArray (const void *key, size_t length);\nstatic Jsi_HashEntry *jsi_HashArrayFind (Jsi_Hash *tablePtr, const void \n*key);\nstatic Jsi_HashEntry *jsi_HashArrayCreate (Jsi_Hash *tablePtr,\n    const void *key, bool *newPtr);\nstatic jsi_Hash HashString (const char *string);\nstatic void RebuildTable (Jsi_Hash *tablePtr);\nstatic Jsi_HashEntry *HashStringFind (Jsi_Hash *tablePtr,\n    const void *key);\nstatic Jsi_HashEntry *HashStringCreate (Jsi_Hash *tablePtr,\n    const void *key, bool *newPtr);\nstatic Jsi_HashEntry *HashOneWordFind (Jsi_Hash *tablePtr,\n    const void *key);\nstatic Jsi_HashEntry *HashOneWordCreate (Jsi_Hash *tablePtr,\n    const void *key, bool *newPtr);\n\n#if JSI_IS64BIT\nstatic jsi_Hash HashOneWord (Jsi_Hash *tablePtr,\n    const void *key));\n\n#endif /* JSI_IS64BIT */\n\nstatic jsi_Hash\nHashString( const char *string)\n{\n    jsi_Hash result = 0;\n    jsi_Hash c;\n    while ((c = *string++) != 0)\n        result += (result << 3) + c;\n\n    return (jsi_Hash)result;\n}\nstatic Jsi_HashEntry *\nHashStringFind( Jsi_Hash *tablePtr, const void *key)\n{\n    jsi_Hash hval;\n    Jsi_HashEntry *hPtr;\n    size_t hindex;\n\n    hval = HashString((char *)key);\n    hindex = hval & tablePtr->mask;\n\n    /*\n     * Search all of the entries in the appropriate bucket.\n     */\n\n    for (hPtr = tablePtr->buckets[hindex]; hPtr != NULL;\n            hPtr = hPtr->nextPtr) {\n        if (hPtr->hval == hval) {\n            const char *p1, *p2;\n\n            for (p1 = (char*)key, p2 = hPtr->key.string; ; p1++, p2++) {\n                if (*p1 != *p2) {\n                    break;\n                }\n                if (*p1 == '\\0') {\n                    return hPtr;\n                }\n            }\n        }\n    }\n    return NULL;\n}\n\nstatic Jsi_HashEntry *\nHashStringCreate( Jsi_Hash *tablePtr, const void *key, bool *newPtr)\n{\n    jsi_Hash hval;\n    Jsi_HashEntry **bucketPtr;\n    Jsi_HashEntry *hPtr;\n    size_t size, hindex;\n\n    hval = HashString((const char*)key);\n    hindex = hval & tablePtr->mask;\n\n    for (hPtr = tablePtr->buckets[hindex]; hPtr != NULL;\n            hPtr = hPtr->nextPtr) {\n        if (hPtr->hval == hval) {\n            const char *p1, *p2;\n\n            for (p1 = (const char*)key, p2 = hPtr->key.string; ; p1++, p2++) {\n                if (*p1 != *p2) {\n                    break;\n                }\n                if (*p1 == '\\0') {\n                    if (newPtr)\n                        *newPtr = 0;\n                    return hPtr;\n                }\n            }\n        }\n    }\n\n    if (newPtr)\n        *newPtr = 1;\n    size = sizeof(Jsi_HashEntry) + Jsi_Strlen((char*)key) - sizeof(jsi_HashKey) + 1;\n    hPtr = (Jsi_HashEntry*)Jsi_Calloc(1, size);\n    hPtr->typ = JSI_MAP_HASH;\n    bucketPtr = tablePtr->buckets + hindex;\n    hPtr->tablePtr = tablePtr;\n    hPtr->nextPtr = *bucketPtr;\n    hPtr->hval = hval;\n    hPtr->clientData = 0;\n    Jsi_Strcpy(hPtr->key.string, (char*)key);\n    *bucketPtr = hPtr;\n    tablePtr->numEntries++;\n\n    if (tablePtr->numEntries >= tablePtr->rebuildSize)\n        RebuildTable(tablePtr);\n        \n    return hPtr;\n}\n\n#if JSI_IS64BIT\n/*\n *----------------------------------------------------------------------\n *\n * HashOneWord --\n *\n *  Compute a one-word hash value of a 64-bit word, which then can\n *  be used to generate a hash index.\n *\n *  From Knuth, it's a multiplicative hash.  Multiplies an unsigned\n *  64-bit value with the golden ratio (sqrt(5) - 1) / 2.  The\n *  downshift value is 64 - n, when n is the log2 of the size of\n *  the hash table.\n *      \n * Results:\n *  The return value is a one-word summary of the information in\n *  64 bit word.\n *\n * Side effects:\n *  None.\n *\n *----------------------------------------------------------------------\n */\nstatic jsi_Hash\nHashOneWord(\n    Jsi_Hash *tablePtr,\n    const void *key)\n{\n    uint64_t a0, a1;\n    uint64_t y0, y1;\n    uint64_t y2, y3;\n    uint64_t p1, p2;\n    uint64_t result;\n    /* Compute key * GOLDEN_RATIO in 128-bit arithmetic */\n    a0 = (uint64_t)key & 0x00000000FFFFFFFF;\n    a1 = (uint64_t)key >> 32;\n\n    y0 = a0 * 0x000000007f4a7c13;\n    y1 = a0 * 0x000000009e3779b9;\n    y2 = a1 * 0x000000007f4a7c13;\n    y3 = a1 * 0x000000009e3779b9;\n    y1 += y0 >> 32;     /* Can't carry */\n    y1 += y2;           /* Might carry */\n    if (y1 < y2) {\n        y3 += (1LL << 32);  /* Propagate */\n    }\n\n    /* 128-bit product: p1 = loword, p2 = hiword */\n    p1 = ((y1 & 0x00000000FFFFFFFF) << 32) + (y0 & 0x00000000FFFFFFFF);\n    p2 = y3 + (y1 >> 32);\n\n    /* Left shift the value downward by the size of the table */\n    if (tablePtr->downShift > 0) {\n        if (tablePtr->downShift < 64) {\n            result = ((p2 << (64 - tablePtr->downShift)) |\n                      (p1 >> (tablePtr->downShift & 63)));\n        } else {\n            result = p2 >> (tablePtr->downShift & 63);\n        }\n    } else {\n        result = p1;\n    }\n    /* Finally mask off the high bits */\n    return (jsi_Hash)(result & tablePtr->mask);\n}\n\n#endif /* JSI_IS64BIT */\n\nstatic Jsi_HashEntry *\nHashOneWordFind( Jsi_Hash *tablePtr,  const void *key)\n{\n     Jsi_HashEntry *hPtr;\n    size_t hindex;\n\n    hindex = RANDOM_INDEX(tablePtr, key);\n\n    /*\n     * Search all of the entries in the appropriate bucket.\n     */\n    for (hPtr = tablePtr->buckets[hindex]; hPtr != NULL;\n        hPtr = hPtr->nextPtr) {\n    if (hPtr->key.oneWordValue == key) {\n        return hPtr;\n    }\n    }\n    return NULL;\n}\n\nstatic Jsi_HashEntry *\nHashOneWordCreate( Jsi_Hash *tablePtr, const void *key, bool *newPtr)\n{\n    Jsi_HashEntry **bucketPtr;\n     Jsi_HashEntry *hPtr;\n    size_t hindex;\n\n    hindex = RANDOM_INDEX(tablePtr, key);\n\n\n    for (hPtr = tablePtr->buckets[hindex]; hPtr != NULL;\n        hPtr = hPtr->nextPtr) {\n        if (hPtr->key.oneWordValue == key) {\n            if (newPtr)\n                *newPtr = 0;\n            return hPtr;\n        }\n    }\n\n    if (newPtr)\n        *newPtr = 1;\n    hPtr = (Jsi_HashEntry*)Jsi_Calloc(1, sizeof(*hPtr));\n    hPtr->typ = JSI_MAP_HASH;\n    bucketPtr = tablePtr->buckets + hindex;\n    hPtr->tablePtr = tablePtr;\n    hPtr->nextPtr = *bucketPtr;\n    hPtr->hval = (jsi_Hash)key;\n    hPtr->clientData = 0;\n    hPtr->key.oneWordValue = (void *)key; \n    *bucketPtr = hPtr;\n    tablePtr->numEntries++;\n\n\n    if (tablePtr->numEntries >= tablePtr->rebuildSize)\n        RebuildTable(tablePtr);\n\n    return hPtr;\n}\n\nstatic jsi_Hash\njsi_HashArray(const void *key, size_t length )\n{\n    const uchar *string = (const uchar *) key;\n    unsigned int result = 0;\n    int i;\n\n     for (i=0 ; i<(int)length; i++) {\n        result += (result<<3) + string[i];\n    }\n    return (jsi_Hash)result;\n}\n\nstatic Jsi_HashEntry *\njsi_HashArrayFind( Jsi_Hash *tablePtr, const void *key)\n{\n    jsi_Hash hval = jsi_HashArray(key, tablePtr->keyType);\n    size_t hindex = hval & tablePtr->mask;\n    Jsi_HashEntry *hPtr = tablePtr->buckets[hindex];\n\n    for (; hPtr != NULL; hPtr = hPtr->nextPtr)\n        if (hPtr->hval == hval && !memcmp(hPtr->key.string, key, tablePtr->keyType))\n            return hPtr;\n\n    return NULL;\n}\n\nstatic Jsi_HashEntry *\njsi_HashArrayCreate( Jsi_Hash *tablePtr,  const void *key, bool *newPtr)\n{\n    jsi_Hash hval = jsi_HashArray(key, tablePtr->keyType);\n    size_t size, hindex = hval & tablePtr->mask;\n    Jsi_HashEntry *hPtr = tablePtr->buckets[hindex];\n\n    for (; hPtr != NULL; hPtr = hPtr->nextPtr)\n        if (hPtr->hval == hval && !memcmp(hPtr->key.string, key, tablePtr->keyType)) {\n            if (newPtr)\n                *newPtr = 0;\n            return hPtr;\n        }\n\n    /* Entry not found.  Add a new one to the bucket. */\n    if (newPtr)\n        *newPtr = 1;\n    assert(tablePtr->keyType >= JSI_KEYS_STRUCT_MINSIZE);\n    size = sizeof(Jsi_HashEntry) + tablePtr->keyType;\n    if ((uint)tablePtr->keyType > sizeof(jsi_HashKey)) // Avoid memory checker problems by not truncating struct.\n        size -= sizeof(jsi_HashKey);\n    hPtr = (Jsi_HashEntry*)Jsi_Calloc(1, size);\n    Jsi_HashEntry **bucketPtr = tablePtr->buckets + hindex;\n    hPtr->typ = JSI_MAP_HASH;\n    hPtr->tablePtr = tablePtr;\n    hPtr->nextPtr = *bucketPtr;\n    hPtr->hval = hval;\n    hPtr->clientData = 0;\n    memcpy(hPtr->key.string, key, tablePtr->keyType);\n    *bucketPtr = hPtr;\n    tablePtr->numEntries++;\n\n    /*\n     * If the table has exceeded a decent size, rebuild it with many\n     * more buckets.\n     */\n    if (tablePtr->numEntries >= tablePtr->rebuildSize)\n        RebuildTable(tablePtr);\n\n    return hPtr;\n}\n\n\nJsi_HashEntry *\nJsi_HashEntryFind( Jsi_Hash *tablePtr, const void *key)\n{\n    if (tablePtr->opts.lockHashProc && (*tablePtr->opts.lockHashProc)(tablePtr, 1) != JSI_OK)\n        return NULL;\n    Jsi_HashEntry *hPtr = (*((tablePtr)->findProc))(tablePtr, key);\n    if (tablePtr->opts.lockHashProc)\n        (*tablePtr->opts.lockHashProc)(tablePtr, 0);\n    return hPtr;\n}\n\nJsi_HashEntry *\nJsi_HashEntryNew(Jsi_Hash *tablePtr, const void *key, bool *newPtr)\n{\n    if (tablePtr->opts.lockHashProc && (*tablePtr->opts.lockHashProc)(tablePtr, 1) != JSI_OK)\n        return NULL;\n    Jsi_HashEntry *hPtr =  (*((tablePtr)->createProc))(tablePtr, key, newPtr);\n#ifdef JSI_HAS_SIG_HASHENTRY\n    SIGINIT(hPtr, HASHENTRY);\n#endif\n    if (tablePtr->opts.lockHashProc)\n        (*tablePtr->opts.lockHashProc)(tablePtr, 0);\n    return hPtr;\n}\n\nstatic void\nRebuildTable(Jsi_Hash *tablePtr)\n{\n    Jsi_HashEntry **bucketPtr, **oldBuckets;\n    Jsi_HashEntry **oldChainPtr, **endPtr;\n    Jsi_HashEntry *hPtr, *nextPtr;\n    size_t hindex;\n\n    oldBuckets = tablePtr->buckets;\n    endPtr = tablePtr->buckets + tablePtr->numBuckets;\n    tablePtr->numBuckets <<= 2;\n    tablePtr->buckets = (Jsi_HashEntry**)Jsi_Calloc(tablePtr->numBuckets, \n                   sizeof(Jsi_HashEntry *));\n    tablePtr->rebuildSize <<= 2;\n    tablePtr->downShift -= 2;\n    tablePtr->mask = tablePtr->numBuckets - 1;\n\n \n    if (tablePtr->keyType == JSI_KEYS_ONEWORD) {\n\n        for (oldChainPtr = oldBuckets; oldChainPtr < endPtr; oldChainPtr++) {\n            for (hPtr = *oldChainPtr; hPtr != NULL; hPtr = nextPtr) {\n            nextPtr = hPtr->nextPtr;\n            hindex = RANDOM_INDEX(tablePtr, hPtr->key.oneWordValue);\n            bucketPtr = tablePtr->buckets + hindex;\n            hPtr->nextPtr = *bucketPtr;\n            *bucketPtr = hPtr;\n            }\n        }\n    } else {\n        for (oldChainPtr = oldBuckets; oldChainPtr < endPtr; oldChainPtr++) {\n            for (hPtr = *oldChainPtr; hPtr != NULL; hPtr = nextPtr) {\n            nextPtr = hPtr->nextPtr;\n            hindex = hPtr->hval & tablePtr->mask;\n            bucketPtr = tablePtr->buckets + hindex;\n            hPtr->nextPtr = *bucketPtr;\n            *bucketPtr = hPtr;\n            }\n        }\n    }\n\n    if (oldBuckets != tablePtr->staticBuckets) {\n        Jsi_Free(oldBuckets);\n    }\n}\n\nJsi_Hash *\nJsi_HashNew(Jsi_Interp *interp, unsigned int keyType, Jsi_HashDeleteProc freeProc)\n{\n    Jsi_Hash *tablePtr = (Jsi_Hash*)Jsi_Calloc(1,sizeof(*tablePtr));\n    SIGINIT(tablePtr, HASH);\n    tablePtr->opts.mapType = (Jsi_Map_Type)JSI_MAP_HASH;\n    tablePtr->typ = JSI_MAP_HASH;\n    tablePtr->opts.interp = interp;\n    tablePtr->buckets = tablePtr->staticBuckets;\n#if !(JSI_SMALL_HASH_TABLE && !(JSI_SMALL_HASH_TABLE & (JSI_SMALL_HASH_TABLE - 1)))\n#error \"small hash must be a power of two\"\n#endif\n    tablePtr->numBuckets = JSI_SMALL_HASH_TABLE;\n    tablePtr->rebuildSize = JSI_SMALL_HASH_TABLE * REBUILD_MULTIPLIER;\n    tablePtr->downShift = DOWNSHIFT_START;\n    tablePtr->opts.freeHashProc = freeProc;\n    tablePtr->mask = (jsi_Hash)(tablePtr->numBuckets - 1);\n    tablePtr->opts.keyType = (Jsi_Key_Type)keyType;\n    tablePtr->keyType = (Jsi_Key_Type)keyType;\n\n    switch (keyType) {\n    case JSI_KEYS_STRING:   /* NUL terminated string keys. */\n        tablePtr->findProc = HashStringFind;\n        tablePtr->createProc = HashStringCreate;\n        break;\n\n    case JSI_KEYS_STRINGKEY: /* Lookup from another String hash, eg. Jsi_KeyAdd() */\n    case JSI_KEYS_ONEWORD: /* A pointer. */\n        tablePtr->findProc = HashOneWordFind;\n        tablePtr->createProc = HashOneWordCreate;\n        break;\n\n    default:            /* Structs. */\n        if (keyType < JSI_KEYS_STRUCT_MINSIZE) {\n            Jsi_LogError(\"Jsi_HashNew: Key size can't be %d, must be >= %d\", keyType, JSI_KEYS_STRUCT_MINSIZE);\n            Jsi_Free(tablePtr);\n            return NULL;\n        }\n        tablePtr->findProc = jsi_HashArrayFind;\n        tablePtr->createProc = jsi_HashArrayCreate;\n        break;\n    }\n    return tablePtr;\n}\n\nint\nJsi_HashEntryDelete(Jsi_HashEntry *entryPtr)\n{\n    Jsi_HashEntry *prevPtr;\n    Jsi_HashEntry **bucketPtr;\n    size_t hindex;\n    Jsi_Hash *tablePtr = entryPtr->tablePtr;\n    Jsi_Interp *interp = tablePtr->opts.interp;\n    JSI_NOTUSED(interp);\n    int cnt = 0;\n#ifdef JSI_HAS_SIG_HASHENTRY\n    SIGASSERT(entryPtr, HASHENTRY);\n#endif\n    if (tablePtr->opts.lockHashProc && (*tablePtr->opts.lockHashProc)(tablePtr, 1) != JSI_OK)\n        return 0;\n    if (tablePtr->keyType == JSI_KEYS_ONEWORD) {\n        hindex = RANDOM_INDEX(tablePtr, (const void *)entryPtr->hval);\n    } else {\n        hindex = (entryPtr->hval & tablePtr->mask);\n    }\n    bucketPtr = tablePtr->buckets + hindex;\n    if (*bucketPtr == entryPtr) {\n        *bucketPtr = entryPtr->nextPtr;\n        cnt++;\n    } else {\n        for (prevPtr = *bucketPtr; /*empty*/; prevPtr = prevPtr->nextPtr) {\n            if (prevPtr == NULL) {\n                Jsi_LogBug(\"malformed bucket chain in Jsi_HashEntryDelete\");\n            }\n            if (prevPtr->nextPtr == entryPtr) {\n                prevPtr->nextPtr = entryPtr->nextPtr;\n                cnt++;\n                break;\n            }\n        }\n    }\n    if (tablePtr->opts.freeHashProc && entryPtr->clientData)\n        (tablePtr->opts.freeHashProc)(tablePtr->opts.interp, entryPtr, entryPtr->clientData);\n\n    if (tablePtr->opts.lockHashProc)\n        (*tablePtr->opts.lockHashProc)(tablePtr, 0);\n    tablePtr->numEntries--;\n    Jsi_Free(entryPtr);\n    return cnt;\n}\n\nvoid\nJsi_HashClear(Jsi_Hash *tablePtr)\n{\n    Jsi_HashEntry *hPtr, *nextPtr;\n    size_t i;\n    if (!tablePtr)\n        return;\n    if (tablePtr->opts.lockHashProc && (*tablePtr->opts.lockHashProc)(tablePtr, 1) != JSI_OK)\n        return;\n    for (i = 0; i < (size_t)tablePtr->numBuckets; i++) {\n        hPtr = tablePtr->buckets[i];\n        while (hPtr != NULL) {\n            nextPtr = hPtr->nextPtr;\n            if (tablePtr->opts.freeHashProc && hPtr->clientData)\n                (tablePtr->opts.freeHashProc)(tablePtr->opts.interp, hPtr, hPtr->clientData);\n            Jsi_Free(hPtr);\n            hPtr = nextPtr;\n            tablePtr->buckets[i] = hPtr;\n        }\n    }\n    \n    if (tablePtr->buckets != tablePtr->staticBuckets) {\n        Jsi_Free(tablePtr->buckets);\n    }\n    if (tablePtr->opts.lockHashProc)\n        (*tablePtr->opts.lockHashProc)(tablePtr, 0);\n}\n\n\nvoid\nJsi_HashDelete(Jsi_Hash *tablePtr)\n{\n    Jsi_HashClear(tablePtr);\n    Jsi_Free(tablePtr);\n}\n\nJsi_HashEntry *\nJsi_HashSearchFirst(Jsi_Hash *tablePtr, Jsi_HashSearch *searchPtr) \n{\n    searchPtr->tablePtr = tablePtr;\n    searchPtr->nextIndex = 0;\n    searchPtr->nextEntryPtr = NULL;\n    return Jsi_HashSearchNext(searchPtr);\n}\n\n\nvoid *Jsi_HashValueGet(Jsi_HashEntry *h)\n{\n    return h->clientData;\n}\n\nvoid Jsi_HashValueSet(Jsi_HashEntry *h, void *value)\n{\n    h->clientData = value;\n}\n\nvoid *Jsi_HashKeyGet(Jsi_HashEntry *hPtr)\n{\n    Jsi_Hash *t = hPtr->tablePtr;\n    return (t->keyType == JSI_KEYS_ONEWORD || t->keyType == JSI_KEYS_STRINGKEY ? hPtr->key.oneWordValue : hPtr->key.string);\n}\n\nJsi_HashEntry *\nJsi_HashSearchNext(Jsi_HashSearch *searchPtr)\n{\n    Jsi_HashEntry *hPtr;\n    Jsi_Hash *tablePtr = searchPtr->tablePtr;\n    int locked = 0;\n    \n    while (searchPtr->nextEntryPtr == NULL) {\n        if (searchPtr->nextIndex >= (size_t)tablePtr->numBuckets) {\n            if (tablePtr->opts.lockHashProc && locked)\n                (*tablePtr->opts.lockHashProc)(tablePtr, 0);\n            return NULL;\n        }\n        if (tablePtr->opts.lockHashProc && locked == 0 && (*tablePtr->opts.lockHashProc)(tablePtr, locked++) != JSI_OK)\n            return NULL;\n        searchPtr->nextEntryPtr =\n            tablePtr->buckets[searchPtr->nextIndex];\n        searchPtr->nextIndex++;\n    }\n    if (tablePtr->opts.lockHashProc && locked)\n        (*tablePtr->opts.lockHashProc)(tablePtr, 0);\n    hPtr = searchPtr->nextEntryPtr;\n    searchPtr->nextEntryPtr = hPtr->nextPtr;\n    return hPtr;\n}\n\n\nJsi_HashEntry* Jsi_HashSet(Jsi_Hash *tbl, const void *key, void *value) {\n    Jsi_HashEntry *hPtr;\n    bool isNew;\n    hPtr = Jsi_HashEntryNew(tbl, key, &isNew);\n    if (!hPtr) return hPtr;\n    Jsi_HashValueSet(hPtr, value);\n    return hPtr;\n}\n\nvoid *Jsi_HashGet(Jsi_Hash *tbl, const void *key, int flags) {\n    Jsi_HashEntry *hPtr;\n    hPtr = Jsi_HashEntryFind(tbl, key);\n    if (!hPtr)\n        return NULL;\n    return Jsi_HashValueGet(hPtr);\n}\n\n// Delete entry, invoking the freeProc.\nbool Jsi_HashUnset(Jsi_Hash *tbl, const void *key) {\n    Jsi_HashEntry *hPtr;\n    hPtr = Jsi_HashEntryFind(tbl, key);\n    if (!hPtr)\n        return false;\n    Jsi_HashEntryDelete(hPtr);\n    return true;\n}\n\nJsi_RC Jsi_HashConf(Jsi_Hash *hashPtr, Jsi_MapOpts *opts, bool set)\n{\n    if (set)\n        hashPtr->opts = *opts;\n    else\n        *opts = hashPtr->opts;\n    return JSI_OK;\n}\n\n#ifndef JSI_LITE_ONLY\n\nstatic Jsi_Value *jsi_hashFmtKey(Jsi_MapEntry* h, struct Jsi_MapOpts *opts, int flags)\n{\n    Jsi_HashEntry* hPtr = (Jsi_HashEntry*)h;\n    void *key = Jsi_HashKeyGet(hPtr);\n    if (opts->keyType == JSI_KEYS_ONEWORD)\n        return Jsi_ValueNewNumber(opts->interp, (Jsi_Number)(intptr_t)key);\n    char nbuf[100];\n    snprintf(nbuf, sizeof(nbuf), \"%p\", key);\n    return Jsi_ValueNewStringDup(opts->interp, nbuf);\n}\n\nJsi_RC Jsi_HashKeysDump(Jsi_Interp *interp, Jsi_Hash *tablePtr, Jsi_Value **ret, int flags) {\n    char *key;\n    int n = 0;\n    Jsi_HashEntry *hPtr;\n    Jsi_HashSearch search;\n    Jsi_Obj *nobj;\n    Jsi_MapFmtKeyProc* fmtKeyProc = (Jsi_MapFmtKeyProc*)tablePtr->opts.fmtKeyProc;\n    \n    if (!fmtKeyProc && tablePtr->keyType == JSI_KEYS_ONEWORD && flags!=JSI_KEYS_ONEWORD )\n        fmtKeyProc = jsi_hashFmtKey;\n    \n    if (!fmtKeyProc && tablePtr->keyType >= JSI_KEYS_STRUCT_MINSIZE) \n        return Jsi_LogError(\"Can not dump struct hash\");\n    nobj = Jsi_ObjNew(interp);\n    Jsi_ValueMakeArrayObject(interp, ret, nobj);\n    for (hPtr = Jsi_HashSearchFirst(tablePtr, &search);\n        hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {\n        key = (char*)Jsi_HashKeyGet(hPtr);\n        Jsi_Value *val;\n        if (fmtKeyProc) {\n            val = (*fmtKeyProc)((Jsi_MapEntry*)hPtr, &tablePtr->opts, flags);\n            if (!val) {\n                Jsi_LogError(\"key format failed\");\n                Jsi_ValueMakeUndef(interp, ret);\n                return JSI_ERROR;\n            }\n        } else if (tablePtr->keyType == JSI_KEYS_ONEWORD)\n            val = Jsi_ValueNewNumber(interp, (Jsi_Number)(uintptr_t)key);\n        else\n            val = Jsi_ValueNewStringKey(interp, key);\n        Jsi_ObjArraySet(interp, nobj, val, n++);\n        if (fmtKeyProc && val->refCnt>1) //TODO: Hmmm. for StructKey Jsi_OptionsDump() returns refCnt=1\n            Jsi_DecrRefCount(interp, val);\n\n    }\n    return JSI_OK;\n}\n#endif\n\nuint Jsi_HashSize(Jsi_Hash *hashPtr) { return hashPtr->numEntries; }\n", "#ifndef JSI_LITE_ONLY\n#define __JSIINT_C__\n#ifndef JSI_AMALGAMATION\n#include \"jsiInt.h\"\n#endif\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n#include <assert.h>\n\n#ifdef __WIN32\n#include <windows.h>\n#include <shlwapi.h>\n#ifndef JSI_OMIT_THREADS\n#include <process.h>\n#endif\n#else\n#ifndef JSI_OMIT_THREADS\n#include <pthread.h>\n#endif\n#endif\n\n#if (JSI_VERSION_MINOR<0 || JSI_VERSION_MINOR>99 || JSI_VERSION_RELEASE<0 || JSI_VERSION_RELEASE>99)\n#error \"VERSION MINOR/RELEASE not between 0-99 inclusive\"\n#endif\n\nstatic Jsi_OptionSpec InterpDebugOptions[] = {\n    JSI_OPT(CUSTOM,Jsi_DebugInterp, debugCallback,  .help=\"Command in parent interp for handling debugging\", .flags=0, .custom=Jsi_Opt_SwitchParentFunc, .data=(void*)\"file:string, line:number, level:number, func:string, opstr:string, bpId:number, emsg:string\" ),\n    JSI_OPT(BOOL,  Jsi_DebugInterp, doContinue,     .help=\"Continue execution until breakpoint\" ),\n    JSI_OPT(BOOL,  Jsi_DebugInterp, forceBreak,     .help=\"Force debugger to break\" ),\n    JSI_OPT(BOOL,  Jsi_DebugInterp, includeOnce,    .help=\"Source the file only if not already sourced\" ),\n    JSI_OPT(BOOL,  Jsi_DebugInterp, includeTrace,   .help=\"Trace includes\" ),\n    JSI_OPT(INT,   Jsi_DebugInterp, minLevel,       .help=\"Disable eval callback for level higher than this\" ),\n    JSI_OPT(CUSTOM,Jsi_DebugInterp, msgCallback,    .help=\"Comand in parent interp to handle Jsi_LogError/Jsi_LogWarn,..\", .flags=0, .custom=Jsi_Opt_SwitchParentFunc, .data=(void*)\"msg:string, type:string, file:string, line:number, col:number\" ),\n    JSI_OPT(BOOL,  Jsi_DebugInterp, pkgTrace,       .help=\"Trace package loads\" ),\n    JSI_OPT(CUSTOM,Jsi_DebugInterp, putsCallback,   .help=\"Comand in parent interp to handle puts output\", .flags=0, .custom=Jsi_Opt_SwitchParentFunc, .data=(void*)\"msg:string, isStderr:number\" ),\n    JSI_OPT(CUSTOM,Jsi_DebugInterp, traceCallback,  .help=\"Comand in parent interp to handle traceCall\", .flags=0, .custom=Jsi_Opt_SwitchParentFunc, .data=(void*)\"cmd:string, args:string, ret:string, file:string, line:number, col:number\" ),\n    JSI_OPT(CUSTOM,Jsi_DebugInterp, testFmtCallback,.help=\"Comand in parent interp to format unittest string\", .flags=0, .custom=Jsi_Opt_SwitchParentFunc, .data=(void*)\"cmd:string, line:number\" ),\n    JSI_OPT_END(Jsi_DebugInterp, .help=\"Interp options for debugging\")\n};\n\nJsi_OptionSpec jsi_InterpLogOptions[] = {\n    JSI_OPT(BOOL,   jsi_LogOptions, Test,    .help=\"Enable LogTest messages\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, Debug,   .help=\"Enable LogDebug messages\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, Trace,   .help=\"Enable LogTrace messages\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, Info,    .help=\"Enable LogInfo messages\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, Warn,    .help=\"Enable LogWarn messages\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, Error,   .help=\"Enable LogError messages\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, time,    .help=\"Prefix with time\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, date,    .help=\"Prefix with date\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, file,    .help=\"Ouptut contains file:line\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, func,    .help=\"Output function\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, full,    .help=\"Show full file path\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, ftail,   .help=\"Show tail of file only, even in LogWarn, etc\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, before,  .help=\"Output file:line before message string\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, isUTC,   .help=\"Time is to be UTC\" ),\n    JSI_OPT(STRKEY, jsi_LogOptions, timeFmt, .help=\"A format string to use with strftime\" ),\n    JSI_OPT(USEROBJ,jsi_LogOptions, chan,    .help=\"Channel to send output to\", .flags=0, .custom=0, .data=(void*)\"Channel\" ),\n    JSI_OPT_END(jsi_LogOptions, .help=\"Interp options for logging\")\n};\nstatic Jsi_OptionSpec InterpSubOptions[] = {\n    JSI_OPT(STRKEY,jsi_SubOptions, blacklist,   .help=\"Comma separated modules to disable loading for\", jsi_IIOF ),\n    JSI_OPT(BOOL,  jsi_SubOptions, compat,      .help=\"Ignore unknown options via JSI_OPTS_IGNORE_EXTRA in option parser\" ),\n    JSI_OPT(INT,   jsi_SubOptions, dblPrec,     .help=\"Format precision of double where 0=max, -1=max-1, ... (max-1)\" ),\n    JSI_OPT(BOOL,  jsi_SubOptions, istty,       .help=\"Indicates interp is in interactive mode\", jsi_IIRO),\n    JSI_OPT(BOOL,  jsi_SubOptions, logColNums,  .help=\"Display column numbers in error messages\"),\n    JSI_OPT(BOOL,  jsi_SubOptions, logAllowDups,.help=\"Log should not filter out duplicate messages\"),\n    JSI_OPT(BOOL,  jsi_SubOptions, mutexUnlock, .help=\"Unlock own mutex when evaling in other interps (true)\", jsi_IIOF),\n    JSI_OPT(BOOL,  jsi_SubOptions, noproto,     .help=\"Disable support of the OOP symbols:  __proto__, prototype, constructor, etc\"),\n    JSI_OPT(BOOL,  jsi_SubOptions, noFuncString,.help=\"Disable viewing code body for functions\", jsi_IIOF),\n    JSI_OPT(BOOL,  jsi_SubOptions, noRegex,     .help=\"Disable viewing code for functions\", jsi_IIOF),\n    JSI_OPT(BOOL,  jsi_SubOptions, noReadline,  .help=\"In interactive mode disable use of readline\" ),\n    JSI_OPT(BOOL,  jsi_SubOptions, outUndef,    .help=\"In interactive mode output result values that are undefined\"),\n    JSI_OPT(STRKEY,jsi_SubOptions, prompt,      .help=\"Prompt for interactive mode ('$ ')\" ),\n    JSI_OPT(STRKEY,jsi_SubOptions, prompt2,     .help=\"Prompt for interactive mode line continue ('> ')\" ),\n    JSI_OPT_END(jsi_SubOptions, .help=\"Lesser sub-feature options\")\n};\n\nstatic const char *jsi_SafeModeStrs[] = { \"none\", \"read\", \"write\", \"writeRead\", \"lockdown\", NULL };\nstatic const char *jsi_TypeChkStrs[] = { \"parse\", \"run\", \"all\", \"error\", \"strict\", \"noundef\", \"nowith\", \"funcsig\", NULL };\nconst char *jsi_callTraceStrs[] = { \"funcs\", \"cmds\", \"new\", \"return\", \"args\", \"notrunc\", \"noparent\", \"full\", \"before\", NULL};\nconst char *jsi_AssertModeStrs[] = { \"throw\", \"log\", \"puts\", NULL};\n\nstatic Jsi_OptionSpec InterpOptions[] = {\n    JSI_OPT(ARRAY, Jsi_Interp, args,        .help=\"The console.arguments for interp\", jsi_IIOF),\n    JSI_OPT(BOOL,  Jsi_Interp, asserts,     .help=\"Enable assert\" ),\n    JSI_OPT(CUSTOM,Jsi_Interp, assertMode,  .help=\"Action upon assert failure\", .flags=0, .custom=Jsi_Opt_SwitchEnum, .data=jsi_AssertModeStrs ),\n    JSI_OPT(ARRAY, Jsi_Interp, autoFiles,   .help=\"File(s) to source for loading Jsi_Auto to handle unknown commands\"),\n    JSI_OPT(CUSTOM,Jsi_Interp, busyCallback,.help=\"Command in parent interp (or noOp) to periodically call\", .flags=0, .custom=Jsi_Opt_SwitchParentFunc, .data=(void*)\"interpName:string, opCnt:number\"),\n    JSI_OPT(INT   ,Jsi_Interp, busyInterval,.help=\"Call busyCallback command after this many op-code evals (100000)\"),\n    JSI_OPT(STRKEY,Jsi_Interp, confFile,    .help=\"Config file of options in non-strict JSON form\", jsi_IIOF|JSI_OPT_LOCKSAFE),\n    JSI_OPT(BOOL,  Jsi_Interp, coverage,    .help=\"On exit generate detailed code coverage for function calls (with profile)\"),\n    JSI_OPT(CUSTOM,Jsi_Interp, debugOpts,   .help=\"Options for debugging\", .flags=0, .custom=Jsi_Opt_SwitchSuboption, .data=InterpDebugOptions),\n    JSI_OPT(BOOL,  Jsi_Interp, interactive, .help=\"Force interactive mode. ie. ignore no_interactive flag\", jsi_IIOF),\n    JSI_OPT(BOOL,  Jsi_Interp, hasOpenSSL,  .help=\"Is SSL available in WebSocket\", jsi_IIOF),\n    JSI_OPT(STRKEY,Jsi_Interp, historyFile, .help=\"In interactive mode, file to use for history (~/.jsish_history)\", jsi_IIOF),\n    JSI_OPT(BOOL,  Jsi_Interp, isSafe,      .help=\"Is this a safe interp (ie. with limited or no file access)\", jsi_IIOF),\n    JSI_OPT(STRKEY,Jsi_Interp, jsppChars,   .help=\"Line preprocessor when sourcing files. Line starts with first char, and either ends with it, or matches string\"),\n    JSI_OPT(FUNC,  Jsi_Interp, jsppCallback,.help=\"Command to preprocess lines that match jsppChars. Call func(interpName:string, opCnt:number)\"),\n    JSI_OPT(INT,   Jsi_Interp, lockTimeout, .help=\"Thread time-out for mutex lock acquires (milliseconds)\" ),\n    JSI_OPT(CUSTOM,Jsi_Interp, logOpts,     .help=\"Options for log output to add file/line/time\", .flags=0, .custom=Jsi_Opt_SwitchSuboption, .data=jsi_InterpLogOptions),\n    JSI_OPT(INT,   Jsi_Interp, maxDepth,    .help=\"Depth limit of recursive function calls (1000)\", .flags=JSI_OPT_LOCKSAFE),\n    JSI_OPT(INT,   Jsi_Interp, maxArrayList,.help=\"Maximum array convertable to list (100000)\", .flags=JSI_OPT_LOCKSAFE),\n    JSI_OPT(INT,   Jsi_Interp, maxIncDepth, .help=\"Maximum allowed source/require nesting depth (50)\", .flags=JSI_OPT_LOCKSAFE),\n    JSI_OPT(INT,   Jsi_Interp, maxInterpDepth,.help=\"Maximum nested subinterp create depth (10)\", .flags=JSI_OPT_LOCKSAFE),\n    JSI_OPT(INT,   Jsi_Interp, maxUserObjs, .help=\"Maximum number of 'new' object calls, eg. File, RegExp, etc\", .flags=JSI_OPT_LOCKSAFE ),\n    JSI_OPT(INT,   Jsi_Interp, maxOpCnt,    .help=\"Execution limit for op-code evaluation\", jsi_IIOF|JSI_OPT_LOCKSAFE ),\n    JSI_OPT(INT,   Jsi_Interp, memDebug,    .help=\"Memory debugging level: 1=summary, 2=detail\", .flags=JSI_OPT_NO_CLEAR),\n    JSI_OPT(STRKEY,Jsi_Interp, name,        .help=\"Optional text name for this interp\"),\n    JSI_OPT(BOOL,  Jsi_Interp, noAutoLoad,  .help=\"Disable autoload\", .flags=JSI_OPT_LOCKSAFE ),\n    JSI_OPT(BOOL,  Jsi_Interp, noConfig,    .help=\"Disable use of Interp.conf to change options after create\", jsi_IIOF),\n    JSI_OPT(BOOL,  Jsi_Interp, noInput,     .help=\"Disable use of console.input()\" ),\n    JSI_OPT(BOOL,  Jsi_Interp, noLoad,      .help=\"Disable load of shared libs\", .flags=JSI_OPT_LOCKSAFE),\n    JSI_OPT(BOOL,  Jsi_Interp, noNetwork,   .help=\"Disable new Socket/WebSocket, or load of builtin MySql\" ),\n    JSI_OPT(BOOL,  Jsi_Interp, noStderr,    .help=\"Make puts, log, assert, etc use stdout\" ),\n    JSI_OPT(BOOL,  Jsi_Interp, noSubInterps,.help=\"Disallow sub-interp creation\"),\n    JSI_OPT(FUNC,  Jsi_Interp, onComplete,  .help=\"Function to return commands completions for interactive mode.  Default uses Info.completions \", .flags=0, .custom=0, .data=(void*)\"prefix:string, start:number, end:number\" ),\n    JSI_OPT(FUNC,  Jsi_Interp, onEval,      .help=\"Function to get control for interactive evals\", .flags=0, .custom=0, .data=(void*)\"cmd:string\" ),\n    JSI_OPT(FUNC,  Jsi_Interp, onExit,      .help=\"Command to call in parent on exit, returns true to continue\", jsi_IIOF , .custom=0, .data=(void*)\"\"),\n    JSI_OPT(ARRAY, Jsi_Interp, pkgDirs,     .help=\"list of library directories for require() to search\" ),\n    JSI_OPT(BOOL,  Jsi_Interp, profile,     .help=\"On exit generate profile of function calls\"),\n    JSI_OPT(VALUE, Jsi_Interp, retValue,    .help=\"Return value from last eval\", jsi_IIRO),\n    JSI_OPT(CUSTOM,Jsi_Interp, safeMode,    .help=\"In safe mode source() support for pwd and script-dir \", jsi_IIOF, .custom=Jsi_Opt_SwitchEnum, .data=jsi_SafeModeStrs ),\n    JSI_OPT(ARRAY, Jsi_Interp, safeReadDirs,.help=\"In safe mode, files/dirs to allow reads to\", jsi_IIOF),\n    JSI_OPT(ARRAY, Jsi_Interp, safeWriteDirs,.help=\"In safe mode, files/dirs to allow writes to\", jsi_IIOF),\n    JSI_OPT(STRKEY, Jsi_Interp,safeExecPattern,.help=\"In safe mode, regexp pattern allow exec of commands\", jsi_IIOF),\n    JSI_OPT(STRKEY,Jsi_Interp, scriptStr,   .help=\"Interp init script string\", jsi_IIOF),\n    JSI_OPT(STRING,Jsi_Interp, scriptFile,  .help=\"Interp init script file\"),\n    JSI_OPT(STRING,Jsi_Interp, stdinStr,    .help=\"String to use as stdin for console.input()\"),\n    JSI_OPT(STRING,Jsi_Interp, stdoutStr,   .help=\"String to collect stdout for puts()\"),\n    JSI_OPT(BOOL,  Jsi_Interp, strict,      .help=\"Globally enable strict: same as 'use strict' in main program\"),\n    JSI_OPT(CUSTOM,Jsi_Interp, subOpts,     .help=\"Infrequently used sub-options\", .flags=0, .custom=Jsi_Opt_SwitchSuboption, .data=InterpSubOptions),\n    JSI_OPT(BOOL,  Jsi_Interp, subthread,   .help=\"Create a threaded Interp\", jsi_IIOF|JSI_OPT_LOCKSAFE),\n    JSI_OPT(CUSTOM,Jsi_Interp, traceCall,   .help=\"Trace commands\", .flags=0,  .custom=Jsi_Opt_SwitchBitset,  .data=jsi_callTraceStrs),\n    JSI_OPT(INT,   Jsi_Interp, traceOp,     .help=\"Set debugging level for OPCODE execution\"),\n    JSI_OPT(BOOL,  Jsi_Interp, tracePuts,   .help=\"Trace puts by making it use logOpts\" ),\n    JSI_OPT(CUSTOM,Jsi_Interp, typeCheck,   .help=\"Type-check control options\", .flags=0, .custom=Jsi_Opt_SwitchBitset, .data=jsi_TypeChkStrs),\n    JSI_OPT(INT,   Jsi_Interp, typeWarnMax, .help=\"Type checking is silently disabled after this many warnings (50)\" ),\n    JSI_OPT(OBJ,   Jsi_Interp, udata,       .help=\"User data\"),\n    JSI_OPT(UINT,  Jsi_Interp, unitTest,    .help=\"Unit test control bits: 1=subst, 2=Puts with file:line prefix\" ),\n    JSI_OPT_END(Jsi_Interp, .help=\"Options for the Jsi interpreter\")\n};\n\n/* Object for each interp created. */\ntypedef struct InterpObj {\n#ifdef JSI_HAS_SIG\n    jsi_Sig sig;\n#endif\n    Jsi_Interp *subinterp;\n    Jsi_Interp *parent;\n    //char *interpname;\n    char *mode;\n    Jsi_Obj *fobj;\n    int objId;\n    int deleting;\n} InterpObj;\n\n/* Global state of interps. */\n\ntypedef struct {\n#ifdef JSI_HAS_SIG\n    jsi_Sig sig;\n#endif\n    int refCount;\n    const char *cmdName;\n    Jsi_Value *args;\n    Jsi_Value *func;\n    Jsi_Value *cmdVal;\n    InterpObj *intobj;\n    Jsi_Interp *dinterp; // Dest interp.\n    Jsi_Interp *subinterp;\n} AliasCmd;\n\n\nstatic void interpObjErase(InterpObj *fo);\nstatic Jsi_RC interpObjFree(Jsi_Interp *interp, void *data);\nstatic bool interpObjIsTrue(void *data);\nstatic bool interpObjEqual(void *data1, void *data2);\n\nstatic Jsi_RC jsi_InterpConfFiles(Jsi_Interp *interp);\n\n/* Call a command with JSON args.  Returned string by using Jsi_ValueGetDString(..., flags). */\nJsi_RC Jsi_EvalCmdJSON(Jsi_Interp *interp, const char *cmd, const char *jsonArgs, Jsi_DString *dStr, int flags)\n{\n    if (Jsi_MutexLock(interp, interp->Mutex) != JSI_OK)\n        return JSI_ERROR;\n    Jsi_Value *nrPtr = Jsi_ValueNew1(interp);\n    Jsi_RC rc = Jsi_CommandInvokeJSON(interp, cmd, jsonArgs, &nrPtr);\n    Jsi_DSInit(dStr);\n    Jsi_ValueGetDString(interp, nrPtr, dStr, flags /*JSI_OUTPUT_JSON*/);\n    Jsi_DecrRefCount(interp, nrPtr);\n    Jsi_MutexUnlock(interp, interp->Mutex);\n    return rc;\n}\n\n/* Call a function with JSON args.  Return a primative. */\nJsi_RC Jsi_FunctionInvokeJSON(Jsi_Interp *interp, Jsi_Value *func, const char *json, Jsi_Value **ret)\n{\n    if (!Jsi_ValueIsFunction(interp, func))\n        return JSI_ERROR;\n    Jsi_Value *aPtr = Jsi_ValueNew1(interp);\n    Jsi_RC rc = Jsi_JSONParse(interp, json, &aPtr, 0);\n    if (rc == JSI_OK)\n        rc = Jsi_FunctionInvoke(interp, func, aPtr, ret, NULL);\n    Jsi_DecrRefCount(interp, aPtr);\n    return rc;\n}\n/* Lookup cmd from cmdstr and invoke with JSON args. */\n/*\n *   Jsi_CommandInvokeJSON(interp, \"info.cmds\", \"[\\\"*\\\",true]\", ret);\n */\nJsi_RC Jsi_CommandInvokeJSON(Jsi_Interp *interp, const char *cmdstr, const char *json, Jsi_Value **ret)\n{\n    Jsi_Value *func = Jsi_NameLookup(interp, cmdstr);\n    if (func)\n        return Jsi_FunctionInvokeJSON(interp, func, json, ret);\n    return Jsi_LogError(\"can not find cmd: %s\", cmdstr);\n}\n\n/* Clean-copying of value between interps: uses JSON parse if needed. */\nJsi_RC Jsi_CleanValue(Jsi_Interp *interp, Jsi_Interp *tointerp, Jsi_Value *val, Jsi_Value **ret)\n{\n    Jsi_RC rc = JSI_OK;\n    const char *cp;\n    int len, iskey;\n    Jsi_Obj *obj;\n    switch (val->vt) {\n        case JSI_VT_UNDEF: Jsi_ValueMakeUndef(interp, ret); return rc;\n        case JSI_VT_NULL: Jsi_ValueMakeNull(tointerp, ret); return rc;\n        case JSI_VT_BOOL: Jsi_ValueMakeBool(tointerp, ret, val->d.val); return rc;\n        case JSI_VT_NUMBER: Jsi_ValueMakeNumber(tointerp, ret, val->d.num); return rc;\n        case JSI_VT_STRING:\n            iskey = val->f.bits.isstrkey;\n            cp = val->d.s.str;\n            len = val->d.s.len;\nmakestr:\n            if (iskey) {\n                Jsi_ValueMakeStringKey(interp, ret, cp);\n                return rc;\n            }\n            jsi_ValueMakeBlobDup(tointerp, ret, (uchar*)cp, len);\n            return rc;\n        case JSI_VT_OBJECT:\n            obj = val->d.obj;\n            switch (obj->ot) {\n                case JSI_OT_BOOL: Jsi_ValueMakeBool(tointerp, ret, obj->d.val); return rc;\n                case JSI_OT_NUMBER: Jsi_ValueMakeNumber(tointerp, ret, obj->d.num); return rc;\n                case JSI_OT_STRING:\n                    cp = obj->d.s.str;\n                    len = obj->d.s.len;\n                    iskey = obj->isstrkey;\n                    goto makestr;\n                default: break;\n            }\n            break;\n        default:\n            break;\n    }\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    cp = Jsi_ValueGetDString(interp, val, &dStr, JSI_OUTPUT_JSON);\n    if (Jsi_JSONParse(tointerp, cp, ret, 0) != JSI_OK) {\n        Jsi_DSFree(&dStr);\n        return Jsi_LogWarn(\"bad JSON parse in subinterp\");\n    }\n    Jsi_DSFree(&dStr);\n    return rc;\n}\n\n/* Invoke command in target interp. */\nJsi_RC jsi_AliasInvoke(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    AliasCmd *ac = (AliasCmd *)funcPtr->cmdSpec->reserved[2];\n    Jsi_Interp *dinterp = ac->dinterp;\n    Jsi_Value *nargs = NULL;\n    int inc=0, argc = Jsi_ValueGetLength(interp, args);\n    if (!ac) {\n        Jsi_LogBug(\"BAD ALIAS INVOKE OF DELETED\");\n        return JSI_ERROR;\n    }\n    SIGASSERT(ac,ALIASCMD);\n    bool isthrd = (interp != dinterp && interp->threadId != dinterp->threadId);\n    Jsi_Value *nrPtr = Jsi_ValueNew1(dinterp);\n\n     if (argc == 0 && ac->args)\n        nargs = ac->args;\n     else if (argc) {\n        if (dinterp == interp)\n            Jsi_ValueCopy(interp, nrPtr, args);\n        else if (Jsi_CleanValue(interp, dinterp, args, &nrPtr) != JSI_OK)\n            return JSI_ERROR;\n        if (ac->args && Jsi_ValueGetLength(dinterp, ac->args)) {\n            nargs = Jsi_ValueArrayConcat(dinterp, ac->args, nrPtr);\n            Jsi_IncrRefCount(dinterp, nargs);\n            inc=1;\n        } else {\n            nargs = nrPtr;\n        }\n    }\n\n    if (isthrd) {\n        /* Post to thread event in sub-interps queue. */\n        if (Jsi_MutexLock(interp, dinterp->QMutex) != JSI_OK)\n            return JSI_ERROR;\n\n       /* Is an async call. */\n        InterpStrEvent *se, *s = (InterpStrEvent *)Jsi_Calloc(1, sizeof(*s));\n        // TODO: is s->data inited?\n        Jsi_DSInit(&s->data);\n        Jsi_ValueGetDString(interp, nargs, &s->data, JSI_OUTPUT_JSON);\n        if (inc)\n            Jsi_DecrRefCount(dinterp, nargs);\n        Jsi_DecrRefCount(dinterp, nrPtr);\n        s->acfunc = ac->func;\n        Jsi_IncrRefCount(dinterp, ac->func);\n        se = dinterp->interpStrEvents;\n        if (!se)\n            dinterp->interpStrEvents = s;\n        else {\n            while (se->next)\n                se = se->next;\n            se->next = s;\n        }\n\n        Jsi_MutexUnlock(interp, dinterp->QMutex);\n        return JSI_OK;\n    }\n\n    if (dinterp != interp) {\n        if (interp->subOpts.mutexUnlock) Jsi_MutexUnlock(interp, interp->Mutex);\n        if (Jsi_MutexLock(interp, dinterp->Mutex) != JSI_OK) {\n            if (interp->subOpts.mutexUnlock) Jsi_MutexLock(interp, interp->Mutex);\n            return JSI_ERROR;\n        }\n    }\n    ac->refCount++;\n    Jsi_Value *srPtr, **srpPtr = ret;\n    if (dinterp != interp) {\n        srPtr = Jsi_ValueNew1(dinterp);\n        srpPtr = &srPtr;\n    }\n    Jsi_RC rc = Jsi_FunctionInvoke(dinterp, ac->func, nargs, srpPtr, NULL);\n    ac->refCount--;\n    if (inc)\n        Jsi_DecrRefCount(dinterp, nargs);\n    Jsi_DecrRefCount(dinterp, nrPtr);\n    if (dinterp != interp) {\n        Jsi_MutexUnlock(interp, dinterp->Mutex);\n        if (interp->subOpts.mutexUnlock && Jsi_MutexLock(interp, interp->Mutex) != JSI_OK) {\n            return JSI_ERROR;\n        }\n    }\n    if (dinterp != interp) {\n        Jsi_CleanValue(dinterp, interp, *srpPtr, ret);\n        Jsi_DecrRefCount(dinterp, srPtr);\n        if (rc != JSI_OK && dinterp->errMsgBuf[0] && interp != dinterp) {\n            Jsi_Strcpy(interp->errMsgBuf, dinterp->errMsgBuf);\n            interp->errLine = dinterp->errLine;\n            interp->errFile = dinterp->errFile;\n            dinterp->errMsgBuf[0] = 0;\n        }\n    }\n    return rc;\n}\n\n\nstatic Jsi_RC jsi_AliasFree(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *data) {\n    /* TODO: deal with other copies of func may be floating around (refCount). */\n    AliasCmd *ac = (AliasCmd *)data;\n    if (!ac) return JSI_ERROR;\n    SIGASSERT(ac,ALIASCMD);\n    if (ac->func)\n        Jsi_DecrRefCount(ac->dinterp, ac->func);\n    if (ac->args)\n        Jsi_DecrRefCount(ac->dinterp, ac->args);\n    if (!ac->cmdVal)\n        return JSI_OK;\n    Jsi_Func *fobj = ac->cmdVal->d.obj->d.fobj->func;\n    fobj->cmdSpec->reserved[2] = NULL;\n    fobj->cmdSpec->proc = NULL;\n    if (ac->intobj && ac->intobj->subinterp) {\n        Jsi_CommandDelete(ac->intobj->subinterp, ac->cmdName);\n        //if (Jsi_Strchr(ac->cmdName, '.'))\n        //    Jsi_LogBug(\"alias free with X.Y dot name leaks memory: %s\", ac->cmdName);\n    } else\n        Jsi_DecrRefCount(ac->subinterp, ac->cmdVal);\n    _JSI_MEMCLEAR(ac);\n    Jsi_Free(ac);\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_AliasCreateCmd(Jsi_Interp* interp, const char* key, AliasCmd* ac) {\n    if (Jsi_InterpGone(interp))\n        return JSI_ERROR;\n    key = Jsi_KeyAdd(interp, key);\n    Jsi_Value *cmd = jsi_CommandCreate(interp, key, jsi_AliasInvoke, NULL, 0, 0);\n    if (!cmd)\n        return Jsi_LogBug(\"command create failure\");\n    ac->cmdVal = cmd;\n    Jsi_Func *fobj = cmd->d.obj->d.fobj->func;\n    fobj->cmdSpec->reserved[2] = ac;\n    cmd->d.obj->isNoOp = (ac->func->d.obj->d.fobj->func->callback == jsi_NoOpCmd);\n    return JSI_OK;\n}\n\n#define FN_intalias JSI_INFO(\"With 0 args, returns list of all aliases in interp.\\n\\\nWith 1 arg returns func for given alias name.\\n\\\nWith 2 args where arg2 == null, returns args for given alias name .\\n\\\nWith 3 args, create/update an alias for func and args. \\n\\\nDelete an alias by creating it with null for both func and args.\")\nstatic Jsi_RC InterpAliasCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    InterpObj *udf = (InterpObj *)Jsi_UserObjGetData(interp, _this, funcPtr);\n    Jsi_Interp *sinterp = (udf ? udf->subinterp : interp );\n    Jsi_Hash *aliases = sinterp->aliasHash;\n    if (!aliases)\n        return Jsi_LogError(\"Sub-interp gone\");\n    int argc = Jsi_ValueGetLength(interp, args);\n    if (argc == 0)\n        return Jsi_HashKeysDump(interp, aliases, ret, 0);\n    Jsi_HashEntry *hPtr;\n    char *key = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    if (!key)\n        return Jsi_LogError(\"expected string\");\n    AliasCmd* ac;\n    if (argc == 1) {\n        hPtr = Jsi_HashEntryFind(aliases, (void*)key);\n        if (!hPtr)\n            return JSI_OK;\n        ac = (AliasCmd*)Jsi_HashValueGet(hPtr);\n        if (!ac) return JSI_ERROR;\n        SIGASSERT(ac,ALIASCMD);\n        Jsi_ValueDup2(interp, ret, ac->func);\n        return JSI_OK;\n    }\n    Jsi_Value *afunc = Jsi_ValueArrayIndex(interp, args, 1);\n    if (argc == 2) {\n        hPtr = Jsi_HashEntryFind(aliases, (void*)key);\n        if (!hPtr)\n            return JSI_OK;\n        ac = (AliasCmd*)Jsi_HashValueGet(hPtr);\n        if (!Jsi_ValueIsNull(interp, afunc))\n            return Jsi_LogError(\"arg 2: expected null to query args\");\n        if (!ac) return JSI_ERROR;\n        SIGASSERT(ac,ALIASCMD);\n        Jsi_ValueDup2(interp, ret, ac->args); //TODO: JSON??\n        return JSI_OK;\n    }\n    \n    if (argc < 3)\n        return JSI_ERROR;\n    bool isthrd = (interp->threadId != sinterp->threadId);\n    //if (isthrd)\n        //return Jsi_LogError(\"alias not supported with threads\");\n    bool isNew;\n    Jsi_Value *aargs = Jsi_ValueArrayIndex(interp, args, 2);\n    if (Jsi_ValueIsNull(interp, afunc) && Jsi_ValueIsNull(interp, aargs)) {\n        hPtr = Jsi_HashEntryFind(aliases, (void*)key);\n        if (hPtr == NULL)\n            return JSI_OK;\n        ac = (AliasCmd*)Jsi_HashValueGet(hPtr);\n        if (!ac) return JSI_ERROR;\n        if (0 && ac->cmdVal)\n            Jsi_DecrRefCount(interp, ac->cmdVal);\n        jsi_AliasFree(interp, NULL, ac);\n        Jsi_HashValueSet(hPtr, NULL);\n        Jsi_HashEntryDelete(hPtr);\n        return JSI_OK;\n    }\n    hPtr = Jsi_HashEntryNew(aliases, (void*)key, &isNew);\n    if (!hPtr)\n        return Jsi_LogError(\"create failed: %s\", key);\n    if (!Jsi_ValueIsFunction(interp, afunc))\n        return Jsi_LogError(\"arg 2: expected function\");\n    if (Jsi_ValueIsNull(interp, aargs) == 0 && Jsi_ValueIsArray(interp, aargs) == 0)\n        return Jsi_LogError(\"arg 3: expected array or null\");\n    if (!isNew) {\n        jsi_AliasFree(interp, NULL, Jsi_HashValueGet(hPtr));\n    }\n    ac = (AliasCmd*)Jsi_Calloc(1, sizeof(AliasCmd));\n    SIGINIT(ac, ALIASCMD);\n    ac->cmdName = (const char*)Jsi_HashKeyGet(hPtr);\n    ac->func = afunc;\n    Jsi_IncrRefCount(interp, afunc);\n    if (!Jsi_ValueIsNull(interp, aargs)) {\n        ac->args = aargs;\n        Jsi_IncrRefCount(interp, aargs);\n    }\n    ac->intobj = udf;\n    ac->dinterp = interp;\n    ac->subinterp = sinterp;\n    Jsi_HashValueSet(hPtr, ac);\n    if (!isthrd)\n        return jsi_AliasCreateCmd(sinterp, key, ac);\n\n    Jsi_Value *vasync = Jsi_ValueArrayIndex(interp, args, 3);\n    bool async = 0;\n    if (vasync && Jsi_GetBoolFromValue(interp, vasync, &async))\n        return JSI_ERROR;\n        \n    if (!async) {\n        if (Jsi_MutexLock(interp, sinterp->Mutex) != JSI_OK)\n            return JSI_ERROR;\n        Jsi_RC rc = jsi_AliasCreateCmd(sinterp, key, ac);\n        Jsi_MutexUnlock(interp, sinterp->Mutex);\n        return rc;\n    }\n\n    /* Post to thread event in sub-interps queue. */\n    if (Jsi_MutexLock(interp, sinterp->QMutex) != JSI_OK)\n        return JSI_ERROR;\n\n    /* Is an async call. */\n    InterpStrEvent *se, *s = (InterpStrEvent *)Jsi_Calloc(1, sizeof(*s));\n    // TODO: is s->data inited?\n    s->acdata = ac;\n    Jsi_DSInit(&s->func);\n    Jsi_DSAppend(&s->func, ac->cmdName, NULL);\n    se = sinterp->interpStrEvents;\n    if (!se)\n        sinterp->interpStrEvents = s;\n    else {\n        while (se->next)\n            se = se->next;\n        se->next = s;\n    }\n\n    Jsi_MutexUnlock(interp, sinterp->QMutex);\n    return JSI_OK;\n}\n\nstatic Jsi_RC freeCodeTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    jsi_Pstate *ps = (jsi_Pstate *)ptr;\n    if (!ps) return JSI_OK;\n    ps->hPtr = NULL;\n    jsi_PstateFree(ps);\n    return JSI_OK;\n}\n\nstatic Jsi_RC freeOnDeleteTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    if (!ptr) return JSI_OK;\n    Jsi_DeleteProc *proc = (Jsi_DeleteProc *)ptr;\n    proc(interp, NULL);\n    return JSI_OK;\n}\n\nstatic Jsi_RC freeAssocTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    if (!ptr) return JSI_OK;\n    jsi_DelAssocData(interp, ptr);\n    return JSI_OK;\n}\n\nstatic Jsi_RC freeEventTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    Jsi_Event *event = (Jsi_Event *)ptr;\n    SIGASSERT(event,EVENT);\n    if (!ptr) return JSI_OK;\n    Jsi_HashValueSet(event->hPtr, NULL);\n    event->hPtr = NULL;\n    Jsi_EventFree(interp, event);\n    return JSI_OK;\n}\nJsi_RC jsi_HashFree(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    Jsi_Free(ptr);\n    return JSI_OK;\n}\n\n\nstatic Jsi_RC packageHashFree(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    jsi_PkgInfo *p = (jsi_PkgInfo*)ptr;\n    if (p->popts.info) Jsi_DecrRefCount(interp, p->popts.info);\n    Jsi_Free(p);\n    return JSI_OK;\n}\n\nstatic Jsi_RC regExpFree(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    Jsi_RegExpFree((Jsi_Regex*)ptr);\n    return JSI_OK;\n}\n\nstatic Jsi_RC freeCmdSpecTbl(Jsi_Interp *interp, Jsi_MapEntry *hPtr, void *ptr) {\n    if (!ptr) return JSI_OK;\n    jsi_CmdSpecDelete(interp, ptr);\n    return JSI_OK;\n}\n\nstatic Jsi_RC freeGenObjTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    Jsi_Obj *obj = (Jsi_Obj *)ptr;\n    SIGASSERT(obj,OBJ);\n    if (!obj) return JSI_OK;\n    Jsi_ObjDecrRefCount(interp, obj);\n    return JSI_OK;\n}\n\n\nstatic Jsi_RC freeFuncsTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    Jsi_Func *func = (Jsi_Func *)ptr;\n    if (!func) return JSI_OK;\n    SIGASSERT(func,FUNC);\n    func->hPtr = NULL;\n    jsi_FuncFree(interp, func);\n    return JSI_OK;\n}\n\nstatic Jsi_RC freeFuncObjTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    Jsi_Obj *v = (Jsi_Obj *)ptr;\n    if (!v) return JSI_OK;\n    SIGASSERT(v,OBJ);\n    if (v->ot != JSI_OT_FUNCTION)\n        fprintf(stderr, \"invalid func obj\\n\");\n    else if (v->d.fobj) {\n        if (v->d.fobj->scope) {\n            jsi_ScopeChain *scope = v->d.fobj->scope;\n            v->d.fobj->scope = NULL;\n            jsi_ScopeChainFree(interp, scope);\n        }\n    }\n    Jsi_ObjDecrRefCount(interp, v);\n    return JSI_OK;\n}\n\nstatic Jsi_RC freeBindObjTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    Jsi_Obj *v = (Jsi_Obj *)ptr;\n    if (!v) return JSI_OK;\n    SIGASSERT(v,OBJ);\n    if (v->ot != JSI_OT_FUNCTION)\n        fprintf(stderr, \"invalid func obj\\n\");\n    else if (v->d.fobj && v->d.fobj->scope) {\n        v->d.fobj->scope = NULL;\n    }\n    Jsi_ObjDecrRefCount(interp, v);\n    return JSI_OK;\n}\n\n/* TODO: incr ref before add then just decr till done. */\nstatic Jsi_RC freeValueTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    Jsi_Value *val = (Jsi_Value *)ptr;\n    if (!val) return JSI_OK;\n    SIGASSERT(val,VALUE);\n    //printf(\"GEN: %p\\n\", val);\n   /* if (val->refCnt>1)\n        Jsi_DecrRefCount(interp, val);*/\n    Jsi_DecrRefCount(interp, val);\n    return JSI_OK;\n}\n\nstatic Jsi_RC freeUserdataTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    if (ptr)\n        jsi_UserObjDelete(interp, ptr);\n    return JSI_OK;\n}\n\nvoid Jsi_ShiftArgs(Jsi_Interp *interp, Jsi_Value *v) {\n    if (!v)\n        v = interp->args;\n    if (v==NULL || v->vt != JSI_VT_OBJECT || v->d.obj->arr == NULL || v->d.obj->arrCnt <= 0)\n        return;\n    Jsi_Obj *obj = v->d.obj;\n    int n = v->d.obj->arrCnt;\n    n--;\n    v = obj->arr[0];\n    if (v)\n        Jsi_DecrRefCount(interp, v);\n    if (n>0)\n        memmove(obj->arr, obj->arr+1, n*sizeof(Jsi_Value*));\n    obj->arr[n] = NULL;\n    Jsi_ObjSetLength(interp, obj, n);\n}\n\nJsi_Value *Jsi_Executable(Jsi_Interp *interp)\n{\n    return jsiIntData.execValue;\n}\n\nstatic Jsi_RC KeyLocker(Jsi_Hash* tbl, int lock)\n{\n    if (!lock)\n        Jsi_MutexUnlock(jsiIntData.mainInterp, jsiIntData.mainInterp->Mutex);\n    else\n        return Jsi_MutexLock(jsiIntData.mainInterp, jsiIntData.mainInterp->Mutex);\n    return JSI_OK;\n}\n\n#ifdef JSI_USE_MANY_STRKEY\nstatic Jsi_RC KeyLockerTree(Jsi_Tree* tree, int lock) { return KeyLocker((Jsi_Hash*)tree, lock); }\n#endif\n\nstatic int jsi_deleted = 0, jsi_exitCode = 0; // TODO: move to jsiIntData\nstatic Jsi_Value *jsi_vf = NULL;\n\nstatic Jsi_RC jsi_InterpDelete(Jsi_Interp *interp, void *ptr) {\n    if (jsi_vf)\n        Jsi_DecrRefCount(interp, jsi_vf);\n    jsi_vf = NULL;\n    jsi_exitCode = interp->exitCode;\n    jsi_deleted = 1;\n    return JSI_OK;\n}\n\nJsi_Interp* Jsi_Main(Jsi_InterpOpts *opts)\n{\n    int rc = 0;\n    Jsi_Interp* interp = NULL;\n    int argc = 0, first = 1;\n    char **argv = NULL;\n    if (opts) {\n        interp = opts->interp;\n        argc = opts->argc;\n        argv = opts->argv;\n    }\n    if (!interp)\n        interp = Jsi_InterpNew(opts);\n    if (!interp)\n        return NULL;\n    Jsi_InterpOnDelete(interp, &jsi_InterpDelete, (void*)&jsi_InterpDelete);\n    argc -= interp->iskips;\n    argv += interp->iskips;\n\n#ifndef NO_JAZ\n    /* Mount zip at end of executable */\n    Jsi_Value *v = Jsi_Executable(interp);\n    const char *exeFile = (v?Jsi_ValueString(interp, v, NULL):NULL);\n    int jsFound = 0;\n    if (v && (argc != 2 || Jsi_Strcmp(argv[1], \"--nozvfs\"))) {\n        rc = Jsi_EvalZip(interp, exeFile, JSI_ZVFS_DIR, &jsFound);\n        if (rc == JSI_OK) {\n            interp->selfZvfs = 1;\n            if (!jsFound) {\n#if (JSI__FILESYS && JSI__ZVFS)\n                fprintf(stderr, \"warning: no main.jsi or autoload.jsi\\n\");\n#endif\n            }\n            if (jsi_deleted)\n                return jsi_DoExit(interp, jsi_exitCode);\n            else if (rc != 0) {\n                fprintf(stderr, \"Error\\n\");\n                return jsi_DoExit(interp, 1);\n            }\n        }\n    }\n#endif\n    const char *ext = NULL, *ai1, *iext = (argc<=1?NULL:Jsi_Strrchr(argv[1], '.'));\n    if (interp->selfZvfs && iext && Jsi_Strcmp(iext,\".fossil\")==0) {\n        rc = Jsi_EvalString(interp, \"runModule('Archive');\", JSI_EVAL_ISMAIN);\n        goto done;\n    }\n    Jsi_ShiftArgs(interp, NULL);\n    if (argc <= 1) {\n        if (interp->opts.no_interactive && !interp->interactive)\n            return interp;\n        rc = Jsi_Interactive(interp, JSI_OUTPUT_QUOTE|JSI_OUTPUT_NEWLINES);\n        goto done;\n    }\n    ai1 = argv[1];\n    if ((!Jsi_Strcmp(ai1, \"-help\") || !Jsi_Strcmp(ai1, \"-h\")) && argc<=3) {\n        if (argc>2) {\n            if (Jsi_PkgRequire(interp, \"Help\", 0)>=0) {\n                char tbuf[BUFSIZ];\n                snprintf(tbuf, sizeof(tbuf), \"return runModule('Help', '%s'.trim().split(null));\", argv[2]);\n                Jsi_RC rc = Jsi_EvalString(interp, tbuf, 0);\n                const char *hstr = Jsi_ValueToString(interp, interp->retValue, NULL);\n                if (rc == JSI_OK)\n                    puts(hstr);\n                return jsi_DoExit(interp, 1);\n            }\n        }\n        dohelp:\n        puts(\"USAGE:\\n  jsish [PREFIX-OPTS] [COMMAND-OPTS|FILE] ...\\n\"\n          \"\\nPREFIX-OPTS:\\n\"\n          \"  --C FILE\\tOption file of config options.\\n\"\n          \"  --F\\t\\tTrace all function calls and returns.\\n\"\n          \"  --I OPT:VAL\\tInterp option: equivalent to Interp.conf({OPT:VAL}).\\n\"\n          \"  --L PATH\\tSet safeMode to \\\"lockdown\\\" using PATH for safe(Read/Write)Dirs.\\n\"\n          \"  --T OPT\\tTypecheck option: equivalent to \\\"use OPT\\\".\\n\"\n          \"  --U\\t\\tDisplay unittest output, minus pass/fail compare.\\n\"\n          \"  --V\\t\\tSame as --U, but adds file and line number to output.\\n\"\n          \"\\nCOMMAND-OPTS:\\n\"\n          \"  -a\\t\\tArchive: mount an archive (zip, sqlar or fossil repo) and run module.\\n\"\n          \"  -c\\t\\tCData: generate .c or JSON output from a .jsc description.\\n\"\n          \"  -d\\t\\tDebug: console script debugger.\\n\"\n          \"  -e CODE ...\\tEvaluate javascript CODE.\\n\"\n          \"  -g\\t\\tGendeep: generate html output from markdeep source.\\n\"\n          \"  -h ?CMD?\\tHelp: show help for jsish or its commands.\\n\"\n          \"  -m\\t\\tModule: utility create/manage/invoke a Module.\\n\"\n          \"  -s\\t\\tSafe: runs script in safe sub-interp.\\n\"\n          \"  -u\\t\\tUnitTest: test script file(s) or directories .js/.jsi files.\\n\"\n          \"  -w\\t\\tWget: web client to download file from url.\\n\"\n          \"  -v\\t\\tVersion: show version detail: add an arg to show only X.Y.Z\\n\"\n          \"  -z\\t\\tZip: append/manage zip files at end of executable.\\n\"\n          \"  -D\\t\\tDebugUI: web-gui script debugger.\\n\"\n          \"  -J\\t\\tJSpp: preprocess javascript for web.\\n\"\n          \"  -S\\t\\tSqliteUI: web-gui for sqlite database file.\\n\"\n          \"  -W\\t\\tWebsrv: web server to serve out content.\\n\"\n          \"\\nInterp options may also be set via the confFile.'\\n\"\n           );\n        return jsi_DoExit(interp, 1);\n    }\n    if (!Jsi_Strcmp(ai1, \"-version\"))\n        ai1 = \"-v\";\n    if (ai1[0] == '-') {\n        switch (ai1[1]) {\n            case 'a':\n                rc = Jsi_EvalString(interp, \"runModule('Archive');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'c':\n                rc = Jsi_EvalString(interp, \"runModule('Cdata');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'd':\n                interp->debugOpts.isDebugger = 1;\n                rc = Jsi_EvalString(interp, \"runModule('Debug');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'D':\n                interp->debugOpts.isDebugger = 1;\n                rc = Jsi_EvalString(interp, \"runModule('DebugUI');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'e':\n                if (argc < 3)\n                    rc = Jsi_LogError(\"missing argument\");\n                else {\n                    rc = Jsi_EvalString(interp, argv[2], JSI_EVAL_ISMAIN|JSI_EVAL_NOSKIPBANG);\n                    if (rc == JSI_OK && argc>3) {\n                        first += 2;\n                        Jsi_ShiftArgs(interp, NULL);\n                        Jsi_ShiftArgs(interp, NULL);\n                        goto dofile;\n                    }\n                }\n                break;\n            case 'g':\n                rc = Jsi_EvalString(interp, \"runModule('GenDeep');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'h':\n                goto dohelp;\n            case 'J':\n                rc = Jsi_EvalString(interp, \"runModule('Jspp');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'm':\n                if (argc <= 2 || argv[2][0] == '-')\n                    rc = Jsi_EvalString(interp, \"runModule('Module');\", JSI_EVAL_ISMAIN);\n                else {\n                    Jsi_DString dStr = {}, eStr = {};\n                    const char *cps, *cpe;\n                    cps = Jsi_Strrchr(argv[2], '/');\n                    if (cps) cps++; else cps = argv[2];\n                    cpe = Jsi_Strrchr(cps, '.');\n                    int len = (cpe?cpe-cps:(int)Jsi_Strlen(cps));\n                    if (cpe)\n                        Jsi_DSPrintf(&dStr, \"source(\\\"%s\\\");\", argv[2]);\n                    else\n                        Jsi_DSPrintf(&dStr, \"require(\\\"%s\\\");\", argv[2]);\n                    Jsi_DSPrintf(&dStr, \"puts(runModule(\\\"%.*s\\\",console.args.slice(1)));\", len, cps);\n                    rc = Jsi_EvalString(interp, Jsi_DSValue(&dStr), JSI_EVAL_NOSKIPBANG);\n                    Jsi_DSFree(&dStr);\n                    Jsi_DSFree(&eStr);\n                }\n                break;\n            case 's':\n                rc = Jsi_EvalString(interp, \"runModule('Safe');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'S':\n                rc = Jsi_EvalString(interp, \"runModule('SqliteUI');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'u':\n                rc = Jsi_EvalString(interp, \"exit(runModule('UnitTest'));\", JSI_EVAL_ISMAIN);\n                break;\n            case 'v': {\n                char str[200] = \"\\n\";\n                    \n                Jsi_Value* fval = Jsi_ValueNewStringKey(interp, \"/zvfs/lib/sourceid.txt\");\n                if (!Jsi_Access(interp, fval, R_OK)) {\n                    Jsi_Channel chan = Jsi_Open(interp, fval, \"r\");\n                    if (chan)\n                        Jsi_Read(interp, chan, str, sizeof(str));\n                }\n                if (argc>2)\n                    printf(\"%u.%u.%u\\n\", JSI_VERSION_MAJOR, JSI_VERSION_MINOR, JSI_VERSION_RELEASE);\n                else \n                    printf(\"%u.%u.%u %.\" JSI_VERFMT_LEN JSI_NUMGFMT \" %s\", JSI_VERSION_MAJOR, JSI_VERSION_MINOR, JSI_VERSION_RELEASE, Jsi_Version(), str);\n                return jsi_DoExit(interp, 1);\n            }\n            case 'w':\n                rc = Jsi_EvalString(interp, \"runModule('Wget');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'W':\n                rc = Jsi_EvalString(interp, \"runModule('Websrv');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'z':\n                rc = Jsi_EvalString(interp, \"runModule('Zip');\", JSI_EVAL_ISMAIN);\n                break;\n            default:\n                puts(\"usage: jsish [  --C FILE | --I OPT:VAL | --L PATH | --T OPT | --U | --V | --F ] | -e STRING |\\n\\t\"\n                \"| -a | -c | -d | -D | -h | -m | -s | -S | -u | -v | -w | -W | -z | FILE ...\\nUse -help for long help.\");\n                return jsi_DoExit(interp, 1);\n        }\n    } else {\ndofile:\n        ext = Jsi_Strrchr(argv[first], '.');\n\n        /* Support running \"main.jsi\" from a zip file. */\n        if (ext && (Jsi_Strcmp(ext,\".zip\")==0 ||Jsi_Strcmp(ext,\".jsz\")==0 ) ) {\n            rc = Jsi_EvalZip(interp, argv[first], NULL, &jsFound);\n            if (rc<0) {\n                fprintf(stderr, \"zip mount failed\\n\");\n                return jsi_DoExit(interp, 1);\n            }\n            if (!(jsFound&JSI_ZIP_MAIN)) {\n                fprintf(stderr, \"main.jsi not found\\n\");\n                return jsi_DoExit(interp, 1);\n            }\n        } else if (ext && !Jsi_Strcmp(ext,\".jsc\")) {\n            Jsi_DString dStr = {};\n            Jsi_DSPrintf(&dStr, \"console.args.unshift('%s'); runModule('CData');\", argv[first]);\n            rc = Jsi_EvalString(interp, Jsi_DSValue(&dStr), JSI_EVAL_ISMAIN|JSI_EVAL_NOSKIPBANG);\n            Jsi_DSFree(&dStr);\n\n        } else {\n            if (argc>1) {\n                jsi_vf = Jsi_ValueNewStringKey(interp, argv[first]);\n                Jsi_IncrRefCount(interp, jsi_vf);\n            }\n            rc = Jsi_EvalFile(interp, jsi_vf, JSI_EVAL_ARGV0|JSI_EVAL_AUTOINDEX|JSI_EVAL_ISMAIN);\n            if (jsi_vf) {\n                Jsi_DecrRefCount(interp, jsi_vf);\n                jsi_vf = NULL;\n            }\n\n        }\n    }\n    if (jsi_deleted) //TODO: rationalize jsi_deleted, jsi_exitCode, etc\n        return jsi_DoExit(rc==JSI_EXIT?NULL:interp, jsi_exitCode);\n    if (rc == 0) {\n        /* Skip output from an ending semicolon which evaluates to undefined */\n        Jsi_Value *ret = Jsi_ReturnValue(interp);\n        if (!Jsi_ValueIsType(interp, ret, JSI_VT_UNDEF)) {\n            Jsi_DString dStr = {};\n            fputs(Jsi_ValueGetDString(interp, ret, &dStr, 0), stdout);\n            Jsi_DSFree(&dStr);\n            fputs(\"\\n\", stdout);\n        }\n    } else {\n        if (!interp->parent && !interp->isHelp)\n            fputs(\"ERROR\\n\", stderr);\n        return jsi_DoExit(interp, 1);\n    }\n\ndone:\n    if (rc == JSI_EXIT) {\n        if (opts)\n            opts->exitCode = jsi_exitCode;\n        return NULL;\n    }\n    if (jsi_deleted == 0 && interp->opts.auto_delete) {\n        Jsi_InterpDelete(interp);\n        return NULL;\n    }\n    return interp;\n}\n\nbool jsi_ModBlacklisted(Jsi_Interp *interp, const char *mod) {\n    if (!interp->subOpts.blacklist) return false;\n    const char *blstr =Jsi_Strstr(interp->subOpts.blacklist, mod);\n    if (!blstr) return false;\n    if ((blstr==interp->subOpts.blacklist || !isalnum(blstr[-1])) && !isalnum(blstr[Jsi_Strlen(mod)]))\n        return false;\n    return true;\n}\n\n// Get control during script evaluation to support debugging.\nstatic Jsi_RC jsi_InterpDebugHook(struct Jsi_Interp* interp, const char *curFile,\n    int curLine, int curLevel, const char *curFunc, const char *opCode, jsi_OpCode *op, const char *emsg)\n{\n    // TODO: when code is run in debugger, parser.y should attribute op for case stmt to skip str compares, etc.\n    int isfun=0;\n    if (interp->isInCallback || curLine<=0)\n        return JSI_OK;\n    if (op && op->nodebug)\n        return JSI_OK;\n    int isbp = 0, bpId = 0, cont = interp->debugOpts.doContinue,\n        stop = (interp->debugOpts.noFilter || interp->debugOpts.forceBreak);\n    if (!curFunc)\n        curFunc = \"\";\n\n    if (interp->parent && interp->parent->sigmask) {\n        interp->parent->sigmask = 0;\n        opCode = \"SIGINT\";\n\n    } else if (Jsi_Strcmp(opCode, \"DEBUG\") || !interp->parent) {\n\n        // Avoid overhead of multiple ops on same line of code.\n        int sameLine = (interp->debugOpts.lastLine == curLine && interp->debugOpts.lastLevel == curLevel\n            && interp->debugOpts.lastFile == curFile);\n\n        if (sameLine && stop==0 && (interp->debugOpts.bpLast==0\n            || (interp->debugOpts.bpOpCnt+10) >= interp->opCnt)) //TODO: need better way to detect bp dups.\n            goto done;\n\n        if (!interp->debugOpts.debugCallback || !interp->parent) {\n            fprintf(stderr, \"FILE %s:%d (%d) %s %s\\n\", curFile, curLine, curLevel, curFunc, opCode);\n            return JSI_OK;\n        }\n\n        // Check for breakpoints.\n        if (interp->breakpointHash) {\n            Jsi_HashEntry *hPtr;\n            Jsi_HashSearch search;\n            for (hPtr = Jsi_HashSearchFirst(interp->breakpointHash, &search);\n                hPtr != NULL && stop == 0; hPtr = Jsi_HashSearchNext(&search)) {\n                jsi_BreakPoint* bptr = (jsi_BreakPoint*)Jsi_HashValueGet(hPtr);\n                if (bptr == NULL || bptr->enabled == 0) continue;\n                if (bptr->func)\n                    stop = (!Jsi_Strcmp(bptr->func, curFunc));\n                else\n                    stop = (bptr->line == curLine && !Jsi_Strcmp(bptr->file, curFile));\n                if (stop) {\n                    isbp = 1;\n                    bpId = bptr->id;\n                    bptr->hits++;\n                    if (bptr->temp)\n                        bptr->enabled = 0;\n                }\n            }\n        }\n\n        if (stop == 0) { // No breakpoint.\n            if (cont  // Cmd is \"continue\"\n                // Handle \"next\" by skipping calls into functions.\n                || (interp->debugOpts.minLevel>0 && curLevel>interp->debugOpts.minLevel)\n                || (isfun=(Jsi_Strcmp(opCode, \"PUSHVAR\")==0 && op[1].op == OP_PUSHFUN)))\n            {\n                if (isfun) {\n                    interp->debugOpts.lastLine = curLine;\n                    interp->debugOpts.lastLevel = curLevel;\n                    interp->debugOpts.lastFile = curFile;\n                }\ndone:\n                return JSI_OK;\n            }\n        }\n    }\n    interp->debugOpts.bpLast = isbp;\n    interp->debugOpts.bpOpCnt = interp->opCnt;\n    interp->debugOpts.lastLine = curLine;\n    interp->debugOpts.lastLevel = curLevel;\n    interp->debugOpts.lastFile = curFile;\n    interp->debugOpts.forceBreak = 0;\n\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    if (emsg && Jsi_Strchr(emsg,'\\\"'))\n        emsg = 0;\n    Jsi_DSPrintf(&dStr, \"[\\\"%s\\\", %d, %d, \\\"%s\\\", \\\"%s\\\", %d, \\\"%s\\\"]\", curFile?curFile:\"\", curLine, curLevel, curFunc, opCode, bpId, emsg?emsg:\"\");\n    interp->isInCallback = 1;\n    Jsi_RC rc = JSI_ERROR;\n    if (interp->debugOpts.debugCallback)\n        rc = Jsi_FunctionInvokeJSON(interp->parent, interp->debugOpts.debugCallback, Jsi_DSValue(&dStr), &interp->retValue);\n    interp->isInCallback = 0;\n    if (interp->parent->exited == 0 && rc != JSI_OK)\n        Jsi_LogError(\"debugger failure\");\n    return rc;\n}\n\nJsi_RC jsi_ParseTypeCheckStr(Jsi_Interp *interp, const char *str) {\n    uint *iptr = (uint*)&interp->typeCheck;\n    const char *wcp = str, *wcn = wcp;\n    while (wcn && wcp) {\n        int isnot = 0;\n        if (*wcp == '!') { isnot = 1; wcp++; }\n        wcn = Jsi_Strchr(wcp, ',');\n        int ti, wlen = (wcn?(wcn-wcp):(int)Jsi_Strlen(wcp));\n#define _JSIPARSETYPES(nam, field) \\\n        if (wlen == (sizeof(#nam)-1) && !Jsi_Strncmp(#nam, wcp, (sizeof(#nam)-1))) { \\\n            interp->field = (1-isnot); \\\n            wcp = (wcn?wcn+1:NULL); \\\n            continue; \\\n        }\n        _JSIPARSETYPES(Debug, logOpts.Debug)\n        _JSIPARSETYPES(Trace, logOpts.Trace)\n        _JSIPARSETYPES(Test,  logOpts.Test)\n        _JSIPARSETYPES(Info, logOpts.Info)\n        _JSIPARSETYPES(Warn, logOpts.Warn)\n        _JSIPARSETYPES(Error,  logOpts.Error)\n        _JSIPARSETYPES(full,  logOpts.full)\n        _JSIPARSETYPES(before,  logOpts.before)\n        _JSIPARSETYPES(time,  logOpts.time)\n        _JSIPARSETYPES(date,  logOpts.date)\n        _JSIPARSETYPES(asserts, asserts)\n        _JSIPARSETYPES(assert, asserts)\n        _JSIPARSETYPES(noproto, subOpts.noproto)\n\n        const char **tstrs = jsi_TypeChkStrs;\n        for (ti=0; tstrs[ti]; ti++) {\n            wlen = Jsi_Strlen(tstrs[ti]);\n            if (!Jsi_Strncmp(tstrs[ti], wcp, wlen) && (!tstrs[ti][wlen] || tstrs[ti][wlen] == ',')) break;\n        }\n        if (tstrs[ti]) {\n            if (isnot)\n                *iptr &= ~(1<<ti);\n            else {\n                *iptr |= (1<<ti);\n                if (!Jsi_Strcmp(tstrs[ti], \"all\"))\n                    interp->typeCheck.parse = interp->typeCheck.run = 1;\n                if (!Jsi_Strcmp(tstrs[ti], \"strict\")) {\n                    interp->typeCheck.parse = interp->typeCheck.run = interp->typeCheck.all = 1;\n                    if (interp->framePtr->level<=0 || interp->isMain)\n                        interp->strict = 1;\n                }\n            }\n        } else {\n            Jsi_DString wStr = {};\n            int i;\n            tstrs = jsi_TypeChkStrs;\n            for (i=0; tstrs[i]; i++) Jsi_DSAppend(&wStr, i?\", \":\"\", tstrs[i], NULL);\n            Jsi_LogWarn(\"unknown typeCheck warn option(s) \\\"%s\\\" not in: Debug, Trace, Test, Info, Warn, Error, assert, %s, noproto, full, before, time, date\", str, Jsi_DSValue(&wStr));\n            Jsi_DSFree(&wStr);\n        }\n        wcp = (wcn?wcn+1:NULL);\n    }\n    return JSI_OK;\n}\n\nstatic Jsi_Interp* jsi_InterpNew(Jsi_Interp *parent, Jsi_Value *opts, Jsi_InterpOpts *iopts)\n{\n    Jsi_Interp* interp;\n    if (parent && parent->noSubInterps) {\n        interp = parent;\n        Jsi_LogError(\"subinterps disallowed\");\n        return NULL;\n    }\n    if (opts && parent && (Jsi_ValueIsObjType(parent, opts, JSI_OT_OBJECT)==0 ||\n        Jsi_TreeSize(opts->d.obj->tree)<=0))\n        opts = NULL;\n    interp = (Jsi_Interp *)Jsi_Calloc(1,sizeof(*interp) + sizeof(jsi_Frame));\n    interp->framePtr = (jsi_Frame*)(((uchar*)interp)+sizeof(*interp));\n    if (!parent)\n        interp->maxInterpDepth = JSI_MAX_SUBINTERP_DEPTH;\n    else {\n        interp->maxInterpDepth = parent->maxInterpDepth;\n        interp->interpDepth = parent->interpDepth+1;\n        if (interp->interpDepth > interp->maxInterpDepth) {\n            Jsi_Free(interp);\n            interp = parent;\n            Jsi_LogError(\"exceeded max subinterp depth\");\n            return NULL;\n        }\n    }\n    interp->maxDepth = JSI_MAX_EVAL_DEPTH;\n    interp->maxIncDepth = JSI_MAX_INCLUDE_DEPTH;\n    interp->typeWarnMax = 50;\n    interp->subOpts.dblPrec = __DBL_DECIMAL_DIG__-1;\n    interp->subOpts.prompt = \"$ \";\n    interp->subOpts.prompt2 = \"> \";\n\n    int iocnt;\n    if (iopts) {\n        iopts->interp = interp;\n        interp->opts = *iopts;\n    }\n    interp->logOpts.file = 1;\n    interp->logOpts.func = 1;\n    interp->logOpts.Info = 1;\n    interp->logOpts.Warn = 1;\n    interp->logOpts.Error = 1;\n    int argc = interp->opts.argc;\n    char **argv = interp->opts.argv;\n    char *argv0 = (argv?argv[0]:NULL);\n    interp->parent = parent;\n    interp->topInterp = (parent == NULL ? interp: parent->topInterp);\n    if (jsiIntData.mainInterp == NULL)\n        jsiIntData.mainInterp = interp->topInterp;\n    interp->mainInterp = jsiIntData.mainInterp; // The first interps handles exit.\n    interp->memDebug = interp->opts.mem_debug;\n    if (parent) {\n        interp->dbPtr = parent->dbPtr;\n    } else {\n        interp->dbPtr = &interp->dbStatic;\n    }\n#ifdef JSI_MEM_DEBUG\n    if (!interp->dbPtr->valueDebugTbl) {\n        interp->dbPtr->valueDebugTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, NULL);\n        interp->dbPtr->objDebugTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, NULL);\n    }\n#endif\n    if (parent) {\n        if (parent->pkgDirs)\n            interp->pkgDirs = Jsi_ValueDupJSON(interp, parent->pkgDirs);\n    } else {\n#ifdef JSI_PKG_DIRS\n        interp->pkgDirs = Jsi_StringSplit(interp, JSI_PKG_DIRS, \",\");\n        Jsi_IncrRefCount(interp, interp->pkgDirs);\n#endif\n    }\n#ifdef JSI_USE_COMPAT\n    interp->compat = JSI_USE_COMPAT;\n#endif\n#ifndef JSI_CONF_ARGS\n#define JSI_CONF_ARGS \"\"\n#endif\n    interp->confArgs = JSI_CONF_ARGS;\n    for (iocnt = 1; (iocnt+1)<argc; iocnt+=2)\n    {\n        const char *aio = argv[iocnt];\n        if (Jsi_Strcmp(aio, \"--T\") == 0 || Jsi_Strcmp(aio, \"--C\") == 0 || Jsi_Strcmp(aio, \"--L\") == 0) {\n            continue;\n        }\n        if (Jsi_Strcmp(aio, \"--F\") == 0 || Jsi_Strcmp(aio, \"--U\") == 0 || Jsi_Strcmp(aio, \"--V\") == 0) {\n            iocnt--;\n            continue;\n        }\n        if (!Jsi_Strcmp(aio, \"--I\")) {\n            const char *aio2 = argv[iocnt+1];\n            if (!Jsi_Strncmp(\"memDebug:\", aio2, sizeof(\"memDebug\")))\n                interp->memDebug=strtol(aio2+sizeof(\"memDebug\"), NULL, 0);\n            else if (!Jsi_Strncmp(\"compat\", aio2, sizeof(\"compat\")))\n                interp->subOpts.compat=strtol(aio2+sizeof(\"compat\"), NULL, 0);\n            continue;\n        }\n        break;\n    }\n    SIGINIT(interp,INTERP);\n    interp->NullValue = Jsi_ValueNewNull(interp);\n    Jsi_IncrRefCount(interp, interp->NullValue);\n#ifdef __WIN32\n    Jsi_DString cwdStr;\n    Jsi_DSInit(&cwdStr);\n    interp->curDir = Jsi_Strdup(Jsi_GetCwd(interp, &cwdStr));\n    Jsi_DSFree(&cwdStr);\n#else\n    char buf[JSI_BUFSIZ];\n    interp->curDir = getcwd(buf, sizeof(buf));\n    interp->curDir = Jsi_Strdup(interp->curDir?interp->curDir:\".\");\n#endif\n    interp->onDeleteTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeOnDeleteTbl);\n    interp->assocTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, freeAssocTbl);\n    interp->cmdSpecTbl = Jsi_MapNew(interp, JSI_MAP_TREE, JSI_KEYS_STRING, freeCmdSpecTbl);\n    interp->eventTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeEventTbl);\n    interp->fileTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, jsi_HashFree);\n    interp->funcObjTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeFuncObjTbl);\n    interp->funcsTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeFuncsTbl);\n    interp->bindTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeBindObjTbl);\n    interp->protoTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL/*freeValueTbl*/);\n    interp->regexpTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, regExpFree);\n    interp->preserveTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, jsi_HashFree);\n    interp->loadTbl = (parent?parent->loadTbl:Jsi_HashNew(interp, JSI_KEYS_STRING, jsi_FreeOneLoadHandle));\n    interp->packageHash = Jsi_HashNew(interp, JSI_KEYS_STRING, packageHashFree);\n    interp->aliasHash = Jsi_HashNew(interp, JSI_KEYS_STRING, jsi_AliasFree);\n\n    interp->lockTimeout = -1;\n#ifdef JSI_LOCK_TIMEOUT\n    interp->lockTimeout JSI_LOCK_TIMEOUT;\n#endif\n#ifndef JSI_DO_UNLOCK\n#define JSI_DO_UNLOCK 1\n#endif\n    interp->subOpts.mutexUnlock = JSI_DO_UNLOCK;\n    Jsi_Map_Type mapType = JSI_MAP_HASH;\n#ifdef JSI_USE_MANY_STRKEY\n    mapType = JSI_MAP_TREE;\n#endif\n\n    if (interp == jsiIntData.mainInterp || interp->threadId != jsiIntData.mainInterp->threadId) {\n        interp->strKeyTbl = Jsi_MapNew(interp,  mapType, JSI_KEYS_STRING, NULL);\n        interp->subOpts.privKeys = 1;\n    }\n    // Handle interp options: -T value and -Ixxx value\n    for (iocnt = 1; (iocnt+1)<argc && !interp->parent; iocnt+=2)\n    {\n        const char *aio = argv[iocnt];\n        if (Jsi_Strcmp(aio, \"--F\") == 0) {\n            interp->traceCall |= (jsi_callTraceFuncs |jsi_callTraceArgs |jsi_callTraceReturn | jsi_callTraceBefore | jsi_callTraceFullPath);\n            iocnt--;\n            interp->iskips++;\n            continue;\n        }\n        if (Jsi_Strcmp(aio, \"--U\") == 0) {\n            interp->asserts = 1;\n            interp->unitTest = 1;\n            iocnt--;\n            interp->iskips++;\n            continue;\n        }\n        if (Jsi_Strcmp(aio, \"--V\") == 0) {\n            interp->asserts = 1;\n            interp->unitTest = 5;\n            interp->tracePuts = 1;\n            iocnt--;\n            interp->iskips++;\n            continue;\n        }\n        if (Jsi_Strcmp(aio, \"--C\") == 0) {\n            if (interp->confFile)\n               Jsi_LogWarn(\"overriding confFile: %s\", interp->confFile);\n            interp->confFile = argv[iocnt+1];\n            interp->iskips+=2;\n            continue;\n        }\n        if (Jsi_Strcmp(aio, \"--L\") == 0) {\n            struct stat sb;\n            const char* path = argv[iocnt+1]; //TODO: convert to Jsi_Value first?\n            if (!path || stat(path, &sb)\n                || !((S_ISREG(sb.st_mode) && !access(path, W_OK)) || (S_ISDIR(sb.st_mode) && !access(path, X_OK)))) {\n                Jsi_LogError(\"Lockdown path must exist and be a writable file or executable dir: %s\", path);\n                Jsi_InterpDelete(interp);\n                return NULL;\n            }\n            interp->isSafe = true;\n            interp->safeMode = jsi_safe_Lockdown;\n            if (interp->safeWriteDirs) {\n                Jsi_LogWarn(\"Overriding safeWriteDirs\");\n                Jsi_DecrRefCount(interp, interp->safeWriteDirs);\n            }\n            const char *vda[2] = {};\n            char npath[PATH_MAX];\n            vda[0] = Jsi_FileRealpathStr(interp, path, npath);\n            interp->safeWriteDirs = Jsi_ValueNewArray(interp, vda, 1);\n            Jsi_IncrRefCount(interp, interp->safeWriteDirs);\n            if (!interp->safeReadDirs) {\n                interp->safeReadDirs = interp->safeWriteDirs;\n                Jsi_IncrRefCount(interp, interp->safeReadDirs);\n            }\n            interp->iskips+=2;\n            continue;\n        }\n        if (Jsi_Strcmp(aio, \"--T\") == 0) {\n            if (jsi_ParseTypeCheckStr(interp, argv[iocnt+1]) != JSI_OK) {\n                Jsi_InterpDelete(interp);\n                return NULL;\n            }\n            interp->iskips+=2;\n            continue;\n        }\n        if (!Jsi_Strcmp(aio, \"--I\"))  {\n            bool bv = 1;\n            char *aio2 = argv[iocnt+1], *aioc = Jsi_Strchr(aio2, ':'),\n                argNamS[50], *argNam = aio2;\n            const char *argVal;\n            if (!Jsi_Strcmp(\"traceCall\", aio2))\n                interp->traceCall |= (jsi_callTraceFuncs |jsi_callTraceArgs |jsi_callTraceReturn | jsi_callTraceBefore | jsi_callTraceFullPath);\n            else {\n                if (aioc) {\n                    argNam = argNamS;\n                    argVal = aioc+1;\n                    snprintf(argNamS, sizeof(argNamS), \"%.*s\", (int)(aioc-aio2), aio2);\n                }\n                \n                DECL_VALINIT(argV);\n                Jsi_Value *argValue = &argV;\n                Jsi_Number dv;\n                if (!aioc || Jsi_GetBool(interp, argVal, &bv) == JSI_OK) {\n                    Jsi_ValueMakeBool(interp, &argValue, bv);\n                } else if (!Jsi_Strcmp(\"null\", argVal)) {\n                    Jsi_ValueMakeNull(interp, &argValue);\n                } else if (Jsi_GetDouble(interp, argVal, &dv) == JSI_OK) {\n                    Jsi_ValueMakeNumber(interp, &argValue, dv);\n                } else {\n                    Jsi_ValueMakeStringKey(interp, &argValue, argVal);\n                }\n                if (JSI_OK != Jsi_OptionsSet(interp, InterpOptions, interp, argNam, argValue, 0)) {\n                    Jsi_InterpDelete(interp);\n                    return NULL;\n                }\n            }\n            interp->iskips+=2;\n            continue;\n        }\n        break;\n    }\n    if (!interp->strKeyTbl)\n        interp->strKeyTbl = jsiIntData.mainInterp->strKeyTbl;\n    if (opts) {\n        interp->inopts = opts = Jsi_ValueDupJSON(interp, opts);\n        if (Jsi_OptionsProcess(interp, InterpOptions, interp, opts, 0) < 0) {\n            Jsi_DecrRefCount(interp, opts);\n            interp->inopts = NULL;\n            Jsi_InterpDelete(interp);\n            return NULL;\n        }\n    }\n    if (interp == jsiIntData.mainInterp) {\n        interp->subthread = 0;\n    } else {\n        if (opts) {\n            if (interp->subOpts.privKeys && interp->strKeyTbl == jsiIntData.mainInterp->strKeyTbl) {\n                //Jsi_HashDelete(interp->strKeyTbl);\n                Jsi_OptionsFree(interp, InterpOptions, interp, 0); /* Reparse options to populate new key table. */\n                interp->strKeyTbl = Jsi_MapNew(interp, mapType, JSI_KEYS_STRING, NULL);\n                if (opts->vt != JSI_VT_NULL) Jsi_OptionsProcess(interp, InterpOptions, interp, opts, 0);\n            } else if (interp->subOpts.privKeys == 0 && interp->strKeyTbl != jsiIntData.mainInterp->strKeyTbl) {\n                Jsi_OptionsFree(interp, InterpOptions, interp, 0); /* Reparse options to populate new key table. */\n                Jsi_MapDelete(interp->strKeyTbl);\n                interp->strKeyTbl = jsiIntData.mainInterp->strKeyTbl;\n                if (opts->vt != JSI_VT_NULL) Jsi_OptionsProcess(interp, InterpOptions, interp, opts, 0);\n            }\n        }\n        if (parent && parent->isSafe) {\n            interp->isSafe = 1;\n            interp->safeMode = parent->safeMode;\n        }\n        if (interp->subthread && interp->isSafe) {\n            interp->subthread = 0;\n            Jsi_LogError(\"threading disallowed in safe mode\");\n            Jsi_InterpDelete(interp);\n            return NULL;\n        }\n        if (interp->subthread)\n            jsiIntData.mainInterp->threadCnt++;\n        if (interp->subthread && interp->strKeyTbl == jsiIntData.mainInterp->strKeyTbl)\n            jsiIntData.mainInterp->threadShrCnt++;\n        if (jsiIntData.mainInterp->threadShrCnt)\n#ifdef JSI_USE_MANY_STRKEY\n            jsiIntData.mainInterp->strKeyTbl->v.tree->opts.lockTreeProc = KeyLockerTree;\n#else\n            jsiIntData.mainInterp->strKeyTbl->v.hash->opts.lockHashProc = KeyLocker;\n#endif\n    }\n    if (parent && parent->isSafe) {\n        interp->isSafe = 1;\n        interp->safeMode = parent->safeMode;\n        interp->maxOpCnt = parent->maxOpCnt;\n        if (interp->safeWriteDirs || interp->safeReadDirs || interp->safeExecPattern) {\n            Jsi_LogWarn(\"ignoring safe* options in safe sub-sub-interp\");\n            if (interp->safeWriteDirs) Jsi_DecrRefCount(interp, interp->safeWriteDirs);\n            if (interp->safeReadDirs) Jsi_DecrRefCount(interp, interp->safeReadDirs);\n            interp->safeWriteDirs = interp->safeReadDirs = NULL;\n            interp->safeExecPattern = NULL;\n        }\n    }\n\n    jsi_InterpConfFiles(interp);\n    if (!interp->udata) {\n        interp->udata = Jsi_ValueNewObj(interp, NULL);\n        Jsi_IncrRefCount(interp, interp->udata);\n    }\n    if (interp->subthread && !interp->scriptStr && !interp->scriptFile) {\n        Jsi_LogError(\"subthread interp must be specify either scriptFile or scriptStr\");\n        Jsi_InterpDelete(interp);\n        return NULL;\n    }\n#ifndef JSI_MEM_DEBUG\n    static int warnNoDebug = 0;\n    if (interp->memDebug && warnNoDebug == 0) {\n        Jsi_LogWarn(\"ignoring memDebug as jsi was compiled without memory debugging\");\n        warnNoDebug = 1;\n    }\n#endif\n    interp->threadId = Jsi_CurrentThread();\n    if (interp->parent && interp->subthread==0 && interp->threadId != interp->parent->threadId) {\n        interp->threadId = interp->parent->threadId;\n#ifndef JSI_MEM_DEBUG\n        Jsi_LogWarn(\"non-threaded sub-interp created by different thread than parent\");\n#endif\n    }\n    if (interp->safeMode != jsi_safe_None)\n        interp->isSafe = interp->startSafe = 1;\n    if (!interp->parent) {\n        if (interp->isSafe)\n            interp->startSafe = 1;\n        if (interp->debugOpts.msgCallback)\n            Jsi_LogWarn(\"ignoring msgCallback\");\n        if (interp->debugOpts.putsCallback)\n            Jsi_LogWarn(\"ignoring putsCallback\");\n        if (interp->busyCallback)\n            Jsi_LogWarn(\"ignoring busyCallback\");\n        if (interp->debugOpts.traceCallback)\n            Jsi_LogWarn(\"ignoring traceCallback\");\n    } else if (interp->busyCallback && interp->threadId != interp->parent->threadId) {\n        Jsi_LogWarn(\"disabling busyCallback due to threads\");\n        interp->busyCallback = NULL;\n    }\n    if (interp == jsiIntData.mainInterp)\n        interp->lexkeyTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);\n    else\n        interp->lexkeyTbl = jsiIntData.mainInterp->lexkeyTbl;\n    interp->thisTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeValueTbl);\n    interp->userdataTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, freeUserdataTbl);\n    interp->varTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);\n    interp->codeTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, freeCodeTbl);\n    interp->genValueTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD,freeValueTbl);\n    interp->genObjTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeGenObjTbl);\n#ifdef JSI_MEM_DEBUG\n    interp->codesTbl = (interp == jsiIntData.mainInterp ? Jsi_HashNew(interp, JSI_KEYS_ONEWORD, NULL) : jsiIntData.mainInterp->codesTbl);\n#endif\n    if (interp->typeCheck.all|interp->typeCheck.parse|interp->typeCheck.funcsig)\n        interp->staticFuncsTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);\n    interp->maxArrayList = MAX_ARRAY_LIST;\n    if (!jsiIntData.isInit) {\n        jsiIntData.isInit = 1;\n        jsi_InitValue(interp, 0);\n        jsiIntData.interpsTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, 0);\n    }\n\n    /* current scope, also global */\n    interp->csc = Jsi_ValueNew1(interp);\n    Jsi_ValueMakeObject(interp, &interp->csc, Jsi_ObjNew(interp));\n    interp->framePtr->incsc = interp->csc;\n\n#define JSIDOINIT(nam) if (!jsi_ModBlacklisted(interp,#nam)) { if (jsi_Init##nam(interp, 0) != JSI_OK) { Jsi_LogBug(\"Init failure in %s\", #nam); } }\n#define JSIDOINIT2(nam) if (!jsi_ModBlacklisted(interp,#nam)) { if (Jsi_Init##nam(interp, 0) != JSI_OK) { Jsi_LogBug(\"Init failure in %s\", #nam); } }\n\n    JSIDOINIT(Proto);\n\n    if (interp->pkgDirs) // Fix-up because above, array was not yet initialized.\n        interp->pkgDirs->d.obj->__proto__ = interp->Array_prototype;\n\n    Jsi_Value *modObj = Jsi_ValueNewObj(interp, Jsi_ObjNewType(interp, JSI_OT_OBJECT));\n    Jsi_ValueInsert(interp, interp->csc, \"Jsi_Auto\", modObj, JSI_OM_DONTDEL);\n\n    /* initial scope chain, nothing */\n    interp->framePtr->ingsc = interp->gsc = jsi_ScopeChainNew(interp, 0);\n\n    interp->ps = jsi_PstateNew(interp); /* Default parser. */\n    if (interp->unitTest&2) {\n        interp->logOpts.before = 1;\n        interp->logOpts.full = 1;\n        interp->tracePuts = 1;\n        interp->noStderr = 1;\n    }\n    if (interp->args && argc) {\n        Jsi_LogBug(\"args may not be specified both as options and parameter\");\n        Jsi_InterpDelete(interp);\n        return NULL;\n    }\n    if (interp->maxDepth>JSI_MAX_EVAL_DEPTH)\n        interp->maxDepth = JSI_MAX_EVAL_DEPTH;\n\n    // Create the args array.\n    if (argc >= 0 && !interp->args) {\n        Jsi_Value *iargs = Jsi_ValueNew1(interp);\n        iargs->f.bits.dontdel = 1;\n        iargs->f.bits.readonly = 1;\n        Jsi_Obj *iobj = Jsi_ObjNew(interp);\n        Jsi_ValueMakeArrayObject(interp, &iargs, iobj);\n        int i = 1, ii = (iocnt>1 ? iocnt : 1);\n        int msiz = (argc?argc-iocnt:0);\n        Jsi_ObjArraySizer(interp, iobj, msiz);\n        iobj->arrMaxSize = msiz;\n        iocnt--;\n        iobj->arrCnt = argc-iocnt;\n        for (i = 1; ii < argc; ++ii, i++) {\n            iobj->arr[i-1] = Jsi_ValueNewStringKey(interp, argv[ii]);\n            Jsi_IncrRefCount(interp, iobj->arr[i-1]);\n            jsi_ValueDebugLabel(iobj->arr[i-1], \"InterpCreate\", \"args\");\n        }\n        Jsi_ObjSetLength(interp, iobj, msiz);\n        interp->args = iargs;\n    } else if (interp->parent && interp->args) {\n        // Avoid strings from sneeking in with options from parent...\n        Jsi_Value *nar = Jsi_ValueDupJSON(interp, interp->args);\n        Jsi_DecrRefCount(interp, interp->args);\n        interp->args = nar;\n    }\n    JSIDOINIT(Options);\n    JSIDOINIT(Cmds);\n    JSIDOINIT(Interp);\n    JSIDOINIT(JSON);\n\n    interp->retValue = Jsi_ValueNew1(interp);\n    interp->Mutex = Jsi_MutexNew(interp, -1, JSI_MUTEX_RECURSIVE);\n    if (1 || interp->subthread) {\n        interp->QMutex = Jsi_MutexNew(interp, -1, JSI_MUTEX_RECURSIVE);\n        //Jsi_DSInit(&interp->interpEvalQ);\n    }\n    JSIDOINIT(Lexer);\n    if (interp != jsiIntData.mainInterp && !parent)\n        Jsi_HashSet(jsiIntData.interpsTbl, interp, NULL);\n\n    if (!interp->isSafe) {\n        JSIDOINIT(Load);\n#if JSI__SIGNAL==1\n        JSIDOINIT(Signal);\n#endif\n    }\n    if (interp->isSafe == 0 || interp->startSafe || interp->safeWriteDirs!=NULL || interp->safeReadDirs!=NULL) {\n#if JSI__FILESYS==1\n        JSIDOINIT(FileCmds);\n        JSIDOINIT(Filesys);\n#endif\n    }\n#if JSI__SQLITE==1\n    JSIDOINIT2(Sqlite);\n#else\n    Jsi_initSqlite(interp, 0);\n#endif\n#if JSI__MYSQL==1\n    if (!interp->noNetwork) {\n        JSIDOINIT2(MySql);\n    }\n#endif\n#if JSI__SOCKET==1\n    JSIDOINIT2(Socket);\n#endif\n#if JSI__WEBSOCKET==1\n    JSIDOINIT2(WebSocket);\n#endif\n\n#if JSI__CDATA==1\n    JSIDOINIT(CData);\n#endif\n\n#ifdef JSI_USER_EXTENSION\n    extern int JSI_USER_EXTENSION(Jsi_Interp *interp, int release);\n    if (JSI_USER_EXTENSION (interp, 0) != JSI_OK) {\n        fprintf(stderr, \"extension load failed\");\n        return jsi_DoExit(interp, 1);\n    }\n#endif\n    Jsi_PkgProvide(interp, \"Jsi\", JSI_VERSION, NULL);\n    if (argc > 0) {\n        char *ss = argv0;\n        char epath[PATH_MAX] = \"\"; // Path of executable\n#ifdef __WIN32\n\n        if (GetModuleFileName(NULL, epath, sizeof(epath))>0)\n            ss = epath;\n#else\n#ifndef PROC_SELF_DIR\n#define PROC_SELF_DIR \"/proc/self/exe\"\n#endif\n        if (ss && *ss != '/' && readlink(PROC_SELF_DIR, epath, sizeof(epath)) && epath[0])\n            ss = epath;\n#endif\n        Jsi_Value *src = Jsi_ValueNewStringDup(interp, ss);\n        Jsi_IncrRefCount(interp, src);\n        jsiIntData.execName = Jsi_Realpath(interp, src, NULL);\n        Jsi_DecrRefCount(interp, src);\n        if (!jsiIntData.execName) jsiIntData.execName = Jsi_Strdup(\"\");\n        jsiIntData.execValue = Jsi_ValueNewString(interp, jsiIntData.execName, -1);\n        Jsi_IncrRefCount(interp, jsiIntData.execValue);\n        Jsi_HashSet(interp->genValueTbl, jsiIntData.execValue, jsiIntData.execValue);\n    }\n\n    //interp->nocacheOpCodes = 1;\n    if (interp->debugOpts.debugCallback && !interp->debugOpts.hook) {\n        interp->debugOpts.hook = jsi_InterpDebugHook;\n    }\n    interp->startTime = jsi_GetTimestamp();\n#ifdef JSI_INTERP_EXTENSION_CODE // For extending interp from jsi.c\n    JSI_INTERP_EXTENSION_CODE\n#endif\n    if (interp->opts.initProc && (*interp->opts.initProc)(interp, 0) != JSI_OK)\n        Jsi_LogBug(\"Init failure in initProc\");\n\n    return interp;\n}\n\nJsi_Interp* Jsi_InterpNew(Jsi_InterpOpts *opts)\n{\n    return jsi_InterpNew(NULL, NULL, opts);\n}\n\nbool Jsi_InterpGone( Jsi_Interp* interp)\n{\n    return (interp == NULL || interp->deleting || interp->destroying || interp->exited);\n}\n\nstatic void DeleteAllInterps() { /* Delete toplevel interps. */\n    Jsi_HashEntry *hPtr;\n    Jsi_HashSearch search;\n    if (!jsiIntData.interpsTbl)\n        return;\n    for (hPtr = Jsi_HashSearchFirst(jsiIntData.interpsTbl, &search); hPtr; hPtr = Jsi_HashSearchNext(&search)) {\n        Jsi_Interp *interp = (Jsi_Interp *)Jsi_HashKeyGet(hPtr);\n        Jsi_HashEntryDelete(hPtr);\n        interp->destroying = 1;\n        Jsi_InterpDelete(interp);\n    }\n    Jsi_HashDelete(jsiIntData.interpsTbl);\n    jsiIntData.interpsTbl = NULL;\n    jsiIntData.isInit = 0;\n}\n\n#ifdef JSI_MEM_DEBUG\n\ntypedef enum { MDB_INOBJ=1, MDB_VISITED=2 } jsi_MDB;\n\nvoid jsiFlagDebugValues(Jsi_Interp *interp, Jsi_Obj *obj)\n{\n    Jsi_Value *v;\n    int oflags;\n    if (obj->ot != JSI_OT_OBJECT && obj->ot != JSI_OT_ARRAY)\n        return;\n    if (obj->tree) {\n        Jsi_TreeEntry *hPtr;\n        Jsi_TreeSearch srch;\n        for (hPtr=Jsi_TreeSearchFirst(obj->tree, &srch,  JSI_TREE_ORDER_IN, NULL); hPtr;\n            hPtr=Jsi_TreeSearchNext(&srch)) {\n            v = (Jsi_Value*)Jsi_TreeValueGet(hPtr);\n            if (v == NULL || v->sig != JSI_SIG_VALUE) continue;\n            oflags = v->VD.flags;\n            v->VD.flags |= (MDB_VISITED|MDB_INOBJ);\n            if (oflags&MDB_VISITED || v->vt != JSI_VT_OBJECT)\n                continue;\n            jsiFlagDebugValues(interp, v->d.obj);\n        }\n    }\n    if (obj->arr) {\n        uint i;\n        for (i=0; i<obj->arrCnt; i++) {\n            v = obj->arr[i];\n            if (v == NULL || v->sig != JSI_SIG_VALUE) continue;\n            oflags = v->VD.flags;\n            v->VD.flags |= (MDB_VISITED|MDB_INOBJ);\n            if (oflags&MDB_VISITED || v->vt != JSI_VT_OBJECT)\n                continue;\n            jsiFlagDebugValues(interp, v->d.obj);\n        }\n    }\n}\n\nvoid jsi_DebugDumpValues(Jsi_Interp *interp)\n{\n    if (jsiIntData.mainInterp != interp) return;\n    int vdLev = interp->memDebug;\n    int have = (interp->dbPtr->valueDebugTbl->numEntries || interp->dbPtr->objDebugTbl->numEntries);\n    if ((have && vdLev>0) || vdLev>=3) {\n        // First traverse all Object trees/arrays and mark all values contained therein.\n        Jsi_HashSearch search;\n        Jsi_HashEntry *hPtr;\n        for (hPtr = Jsi_HashSearchFirst(interp->dbPtr->objDebugTbl, &search);\n            hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {\n            Jsi_Obj *vp = (Jsi_Obj *)Jsi_HashKeyGet(hPtr);\n            if (vp!=NULL && vp->sig == JSI_SIG_OBJ) {\n                jsiFlagDebugValues(interp, vp);\n            }\n        }\n        if (interp->dbPtr->valueDebugTbl->numEntries != interp->dbPtr->valueCnt)\n            fprintf(stderr, \"\\n\\nValues table/alloc mismatch: table=%d, alloc=%d\\n\",\n                interp->dbPtr->valueDebugTbl->numEntries, interp->dbPtr->valueCnt);\n        // Dump unfreed values and objs.\n        int refSum=0, refsum=0;\n        int bcnt[4] = {};\n        if (vdLev>1 && interp->dbPtr->valueDebugTbl->numEntries)\n            fprintf(stderr, \"\\n\\nUNFREED VALUES \\\"[*ptr,#refCnt,type,idx:label,label2]: @file:line in func() ...\\\"\\n\");\n        for (hPtr = Jsi_HashSearchFirst(interp->dbPtr->valueDebugTbl, &search);\n            hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {\n            Jsi_Value *vp = (Jsi_Value *)Jsi_HashKeyGet(hPtr);\n            if (vp==NULL || vp->sig != JSI_SIG_VALUE) {\n                bcnt[0]++;\n                if (vdLev>1)\n                    fprintf(stderr, \"BAD VALUE: %p\\n\", vp);\n            } else {\n                bcnt[1]++;\n                refSum += vp->refCnt;\n                if (vdLev>1) {\n                    char ebuf[JSI_BUFSIZ], ebuf2[JSI_MAX_NUMBER_STRING];\n                    ebuf[0] = 0;\n                    if (vp->vt==JSI_VT_OBJECT)\n                        snprintf(ebuf, sizeof(ebuf), \" {obj=%p, otype=%s}\", vp->d.obj, Jsi_ObjTypeStr(interp, vp->d.obj));\n                    else if (vp->vt==JSI_VT_NUMBER)\n                        snprintf(ebuf, sizeof(ebuf), \" {num=%s}\", Jsi_NumberToString(interp, vp->d.num, ebuf2, sizeof(ebuf2)));\n                    else if (vp->vt==JSI_VT_BOOL)\n                        snprintf(ebuf, sizeof(ebuf), \" {bool=%s}\", vp->d.val?\"true\":\"false\");\n                    else if (vp->vt==JSI_VT_STRING) {\n                        const char *sbuf = ((vp->d.s.str && Jsi_Strlen(vp->d.s.str)>40)?\"...\":\"\");\n                        snprintf(ebuf, sizeof(ebuf), \" {string=\\\"%.40s%s\\\"}\", (vp->d.s.str?vp->d.s.str:\"\"), sbuf);\n                    }\n                    const char *pfx = \"\";\n                    if (!(vp->VD.flags&MDB_INOBJ))\n                        pfx = \"!\"; // Value is not contained in an object.\n                    fprintf(stderr, \"[%s*%p,#%d,%s,%d:%s%s%s]:%s @%s:%d in %s()%s\\n\", pfx,\n                        vp, vp->refCnt, Jsi_ValueTypeStr(interp, vp), vp->VD.Idx,\n                        (vp->VD.label?vp->VD.label:\"\"), (vp->VD.label2?\":\":\"\"),\n                        (vp->VD.label2?vp->VD.label2:\"\"), vp->VD.interp==jsiIntData.mainInterp?\"\":\"!\",\n                        vp->VD.fname, vp->VD.line, vp->VD.func, ebuf);\n                }\n            }\n        }\n        if (interp->dbPtr->objDebugTbl->numEntries != interp->dbPtr->objCnt)\n            fprintf(stderr, \"\\n\\nObject table/alloc mismatch: table=%d, alloc=%d\\n\",\n                interp->dbPtr->objDebugTbl->numEntries, interp->dbPtr->objCnt);\n        if (vdLev>1 && interp->dbPtr->objDebugTbl->numEntries)\n            fprintf(stderr, \"\\n\\nUNFREED OBJECTS \\\"[*ptr,#refCnt,type,idx:label,label2]: @file:line in func() ...\\\"\\n\");\n        for (hPtr = Jsi_HashSearchFirst(interp->dbPtr->objDebugTbl, &search);\n            hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {\n            Jsi_Obj *vp = (Jsi_Obj *)Jsi_HashKeyGet(hPtr);\n            if (vp==NULL || vp->sig != JSI_SIG_OBJ) {\n                bcnt[2]++;\n                fprintf(stderr, \"BAD OBJ: %p\\n\", vp);\n            } else {\n                bcnt[3]++;\n                refsum += vp->refcnt;\n                if (vdLev>1) {\n                    char ebuf[JSI_BUFSIZ], ebuf2[JSI_MAX_NUMBER_STRING];\n                    ebuf[0] = 0;\n                    if (vp->ot==JSI_OT_OBJECT) {\n                        if (vp->isarrlist)\n                            snprintf(ebuf, sizeof(ebuf), \"tree#%d, array#%d\", (vp->tree?vp->tree->numEntries:0), vp->arrCnt);\n                        else\n                            snprintf(ebuf, sizeof(ebuf), \"tree#%d\", (vp->tree?vp->tree->numEntries:0));\n                    } else if (vp->ot==JSI_OT_NUMBER)\n                        snprintf(ebuf, sizeof(ebuf), \"num=%s\", Jsi_NumberToString(interp, vp->d.num, ebuf2, sizeof(ebuf2)));\n                    else if (vp->ot==JSI_OT_BOOL)\n                        snprintf(ebuf, sizeof(ebuf), \"bool=%s\", vp->d.val?\"true\":\"false\");\n                    else if (vp->ot==JSI_OT_STRING) {\n                        const char *sbuf = ((vp->d.s.str && Jsi_Strlen(vp->d.s.str)>40)?\"...\":\"\");\n                        snprintf(ebuf, sizeof(ebuf), \"string=\\\"%.40s%s\\\"\", (vp->d.s.str?vp->d.s.str:\"\"), sbuf);\n                    }\n                    fprintf(stderr, \"[*%p,#%d,%s,%d:%s%s%s]:%s @%s:%d in %s() {%s}\\n\",\n                        vp, vp->refcnt, Jsi_ObjTypeStr(interp, vp), vp->VD.Idx, vp->VD.label?vp->VD.label:\"\",\n                        vp->VD.label2?\":\":\"\",vp->VD.label2?vp->VD.label2:\"\", vp->VD.interp==jsiIntData.mainInterp?\"\":\"!\",\n                        vp->VD.fname, vp->VD.line,\n                        vp->VD.func, ebuf);\n                }\n            }\n        }\n        fprintf(stderr, \"\\nVALUES: bad=%d,unfreed=%d,allocs=%d,refsum=%d  | OBJECTS: bad=%d,unfreed=%d,allocs=%d,refsum=%d  interp=%p\\n\",\n            bcnt[0], bcnt[1], interp->dbPtr->valueAllocCnt, refSum, bcnt[2], bcnt[3], interp->dbPtr->objAllocCnt, refsum, interp);\n\n        if (interp->codesTbl)\n            for (hPtr = Jsi_HashSearchFirst(interp->codesTbl, &search);\n                hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {\n                Jsi_OpCodes *vp = (Jsi_OpCodes *)Jsi_HashKeyGet(hPtr);\n                fprintf(stderr, \"unfreed opcodes: %d\\n\", vp->id);\n            }\n    }\n    Jsi_HashDelete(interp->dbPtr->valueDebugTbl);\n    Jsi_HashDelete(interp->dbPtr->objDebugTbl);\n    Jsi_HashDelete(interp->codesTbl);\n    bool isMainInt = (interp == jsiIntData.mainInterp);\n    if (isMainInt && vdLev>3)\n        _exit(1); // Avoid sanitize output.\n}\n#endif\n\nstatic Jsi_RC jsiInterpDelete(Jsi_Interp* interp, void *unused)\n{\n    SIGASSERT(interp,INTERP);\n    bool isMainInt = (interp == jsiIntData.mainInterp);\n    int mainFlag = (isMainInt ? 2 : 1);\n    if (isMainInt)\n        DeleteAllInterps();\n    if (interp->opts.initProc)\n        (*interp->opts.initProc)(interp, mainFlag);\n    jsiIntData.delInterp = interp;\n    if (interp->gsc) jsi_ScopeChainFree(interp, interp->gsc);\n    if (interp->csc) Jsi_DecrRefCount(interp, interp->csc);\n    if (interp->ps) jsi_PstateFree(interp->ps);\n    int i;\n    for (i=0; i<interp->maxStack; i++) {\n        if (interp->Stack[i]) Jsi_DecrRefCount(interp, interp->Stack[i]);\n        if (interp->Obj_this[i]) Jsi_DecrRefCount(interp, interp->Obj_this[i]);\n    }\n    if (interp->Stack) {\n        Jsi_Free(interp->Stack);\n        Jsi_Free(interp->Obj_this);\n    }\n\n    if (interp->argv0)\n        Jsi_DecrRefCount(interp, interp->argv0);\n    if (interp->console)\n        Jsi_DecrRefCount(interp, interp->console);\n    if (interp->lastSubscriptFail)\n        Jsi_DecrRefCount(interp, interp->lastSubscriptFail);\n    if (interp->nullFuncRet)\n        Jsi_DecrRefCount(interp, interp->nullFuncRet);\n    Jsi_HashDelete(interp->codeTbl);\n    Jsi_MapDelete(interp->cmdSpecTbl);\n    Jsi_HashDelete(interp->fileTbl);\n    Jsi_HashDelete(interp->funcObjTbl);\n    Jsi_HashDelete(interp->funcsTbl);\n    if (interp->profileCnt) { // TODO: resolve some values from dbPtr, others not.\n        double endTime = jsi_GetTimestamp();\n        double coverage = (int)(100.0*interp->coverHit/interp->coverAll);\n        Jsi_DString dStr;\n        Jsi_DSInit(&dStr);\n        Jsi_DSPrintf(&dStr, \"PROFILE: TOTAL: time=%.6f, func=%.6f, cmd=%.6f, #funcs=%d, #cmds=%d, cover=%2.1f%%, #values=%d, #objs=%d %s%s\\n\",\n            endTime-interp->startTime, interp->funcSelfTime, interp->cmdSelfTime, interp->funcCallCnt, interp->cmdCallCnt,\n            coverage, interp->dbPtr->valueAllocCnt,  interp->dbPtr->objAllocCnt,\n            interp->parent?\" ::\":\"\", (interp->parent&&interp->name?interp->name:\"\"));\n        Jsi_Puts(interp, jsi_Stderr, Jsi_DSValue(&dStr), -1);\n        Jsi_DSFree(&dStr);\n    }\n    if (isMainInt)\n        Jsi_HashDelete(interp->lexkeyTbl);\n    Jsi_HashDelete(interp->protoTbl);\n    if (interp->subthread)\n        jsiIntData.mainInterp->threadCnt--;\n    if (interp->subthread && interp->strKeyTbl == jsiIntData.mainInterp->strKeyTbl)\n        jsiIntData.mainInterp->threadShrCnt--;\n    if (!jsiIntData.mainInterp->threadShrCnt)\n#ifdef JSI_USE_MANY_STRKEY\n        jsiIntData.mainInterp->strKeyTbl->v.tree->opts.lockTreeProc = NULL;\n#else\n        jsiIntData.mainInterp->strKeyTbl->v.hash->opts.lockHashProc = NULL;\n#endif\n    //Jsi_ValueMakeUndef(interp, &interp->ret);\n    Jsi_HashDelete(interp->thisTbl);\n    Jsi_HashDelete(interp->varTbl);\n    Jsi_HashDelete(interp->genValueTbl);\n    Jsi_HashDelete(interp->genObjTbl);\n    Jsi_HashDelete(interp->aliasHash);\n    if (interp->staticFuncsTbl)\n        Jsi_HashDelete(interp->staticFuncsTbl);\n    if (interp->breakpointHash)\n        Jsi_HashDelete(interp->breakpointHash);\n    if (interp->preserveTbl->numEntries!=0)\n        Jsi_LogBug(\"Preserves unbalanced\");\n    Jsi_HashDelete(interp->preserveTbl);\n    if (interp->curDir)\n        Jsi_Free(interp->curDir);\n    if (isMainInt) {\n        jsi_InitFilesys(interp, mainFlag);\n    }\n#ifndef JSI_OMIT_VFS\n    jsi_InitVfs(interp, 1);\n#endif\n#ifndef JSI_OMIT_CDATA\n        jsi_InitCData(interp, mainFlag);\n#endif\n#if JSI__MYSQL==1\n        Jsi_InitMySql(interp, mainFlag);\n#endif\n    while (interp->interpStrEvents) {\n        InterpStrEvent *se = interp->interpStrEvents;\n        interp->interpStrEvents = se->next;\n        if (se->acfunc)\n            Jsi_DecrRefCount(interp, se->acfunc);\n        if (se->acdata)\n            Jsi_Free(se->acdata);\n        Jsi_Free(se);\n    }\n\n    if (interp->Mutex)\n        Jsi_MutexDelete(interp, interp->Mutex);\n    if (interp->QMutex) {\n        Jsi_MutexDelete(interp, interp->QMutex);\n        Jsi_DSFree(&interp->interpEvalQ);\n    }\n    if (interp->nullFuncArg)\n        Jsi_DecrRefCount(interp, interp->nullFuncArg);\n    if (interp->NullValue)\n        Jsi_DecrRefCount(interp, interp->NullValue);\n    if (interp->Function_prototype_prototype) {\n        if (interp->Function_prototype_prototype->refCnt>1)\n            Jsi_DecrRefCount(interp, interp->Function_prototype_prototype);\n        Jsi_DecrRefCount(interp, interp->Function_prototype_prototype);\n    }\n    if (interp->Object_prototype) {\n        Jsi_DecrRefCount(interp, interp->Object_prototype);\n    }\n    Jsi_HashDelete(interp->regexpTbl);\n    Jsi_OptionsFree(interp, InterpOptions, interp, 0);\n    Jsi_HashDelete(interp->userdataTbl);\n    Jsi_HashDelete(interp->eventTbl);\n    if (interp->inopts)\n        Jsi_DecrRefCount(interp, interp->inopts);\n    if (interp->safeWriteDirs)\n        Jsi_DecrRefCount(interp, interp->safeWriteDirs);\n    if (interp->safeReadDirs)\n        Jsi_DecrRefCount(interp, interp->safeReadDirs);\n    if (interp->pkgDirs)\n        Jsi_DecrRefCount(interp, interp->pkgDirs);\n    for (i=0; interp->cleanObjs[i]; i++) {\n        interp->cleanObjs[i]->tree->opts.freeHashProc = 0;\n        Jsi_ObjFree(interp, interp->cleanObjs[i]);\n    }\n    Jsi_HashDelete(interp->bindTbl);\n    for (i = 0; i <= interp->cur_scope; i++)\n        jsi_ScopeStrsFree(interp, interp->scopes[i]);\n#if JSI__ZVFS==1\n    Jsi_InitZvfs(interp, mainFlag);\n#endif\n    if (!interp->parent)\n        Jsi_HashDelete(interp->loadTbl);\n    if (interp->packageHash)\n        Jsi_HashDelete(interp->packageHash);\n    Jsi_HashDelete(interp->assocTbl);\n    interp->cleanup = 1;\n    jsi_AllObjOp(interp, NULL, -1);\n#ifdef JSI_MEM_DEBUG\n    jsi_DebugDumpValues(interp);\n#endif\n    if (isMainInt || interp->strKeyTbl != jsiIntData.mainInterp->strKeyTbl)\n        Jsi_MapDelete(interp->strKeyTbl);\n\n    if (isMainInt)\n        jsiIntData.mainInterp = NULL;\n    _JSI_MEMCLEAR(interp);\n    jsiIntData.delInterp = NULL;\n    Jsi_Free(interp);\n    return JSI_OK;\n}\n\nvoid Jsi_InterpDelete(Jsi_Interp* interp)\n{\n    if (interp->deleting || interp->level > 0 || !interp->onDeleteTbl)\n        return;\n    interp->deleting = 1;\n    Jsi_HashDelete(interp->onDeleteTbl);\n    interp->onDeleteTbl = NULL;\n    Jsi_EventuallyFree(interp, interp, jsiInterpDelete);\n}\n\ntypedef struct {\n    void *data;\n    Jsi_Interp *interp;\n    int refCnt;\n    Jsi_DeleteProc* proc;\n} PreserveData;\n\nvoid Jsi_Preserve(Jsi_Interp* interp, void *data) {\n    bool isNew;\n    PreserveData *ptr;\n    Jsi_HashEntry *hPtr = Jsi_HashEntryNew(interp->preserveTbl, data, &isNew);\n    assert(hPtr);\n    if (!isNew) {\n        ptr = (PreserveData*)Jsi_HashValueGet(hPtr);\n        if (ptr) {\n            assert(interp == ptr->interp);\n            ptr->refCnt++;\n        }\n    } else {\n        ptr = (PreserveData*)Jsi_Calloc(1,sizeof(*ptr));\n        Jsi_HashValueSet(hPtr, ptr);\n        ptr->interp = interp;\n        ptr->data = data;\n        ptr->refCnt = 1;\n    }\n}\n\nvoid Jsi_Release(Jsi_Interp* interp, void *data) {\n    Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->preserveTbl, data);\n    if (!hPtr) return;\n    PreserveData *ptr = (PreserveData*)Jsi_HashValueGet(hPtr);\n    if (!ptr) return;\n    assert(ptr->interp == interp);\n    if (--ptr->refCnt > 0) return;\n    if (ptr->proc)\n        (*ptr->proc)(interp, data);\n    Jsi_Free(ptr);\n    Jsi_HashEntryDelete(hPtr);\n}\n\nvoid Jsi_EventuallyFree(Jsi_Interp* interp, void *data, Jsi_DeleteProc* proc) {\n    Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->preserveTbl, data);\n    if (!hPtr) {\n        (*proc)(interp, data);\n        return;\n    }\n    PreserveData *ptr = (PreserveData*)Jsi_HashValueGet(hPtr);\n    assert(ptr && ptr->interp == interp);\n    JSI_NOWARN(ptr);\n    Jsi_HashEntryDelete(hPtr);\n}\n\nvoid Jsi_InterpOnDelete(Jsi_Interp *interp, Jsi_DeleteProc *freeProc, void *ptr)\n{\n    if (freeProc)\n        Jsi_HashSet(interp->onDeleteTbl, ptr, (void*)freeProc);\n    else {\n        Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->onDeleteTbl, ptr);\n        if (hPtr)\n            Jsi_HashEntryDelete(hPtr);\n    }\n}\n\nstatic void interpObjErase(InterpObj *fo)\n{\n    SIGASSERTV(fo,INTERPOBJ);\n    if (fo->subinterp) {\n        Jsi_Interp *interp = fo->subinterp;\n        fo->subinterp = NULL;\n        Jsi_InterpDelete(interp);\n        /*fclose(fo->fp);\n        Jsi_Free(fo->interpname);\n        Jsi_Free(fo->mode);*/\n    }\n    fo->subinterp = NULL;\n}\n\nstatic Jsi_RC interpObjFree(Jsi_Interp *interp, void *data)\n{\n    InterpObj *fo = (InterpObj *)data;\n    SIGASSERT(fo,INTERPOBJ);\n    if (fo->deleting) return JSI_OK;\n    fo->deleting = 1;\n    interpObjErase(fo);\n    Jsi_Free(fo);\n    return JSI_OK;\n}\n\nstatic bool interpObjIsTrue(void *data)\n{\n    InterpObj *fo = (InterpObj *)data;\n    SIGASSERT(fo,INTERPOBJ);\n    if (!fo->subinterp) return 0;\n    else return 1;\n}\n\nstatic bool interpObjEqual(void *data1, void *data2)\n{\n    return (data1 == data2);\n}\n\n/* TODO: possibly support async func-callback.  Also for call/send. */\nstatic Jsi_RC InterpEvalCmd_(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr, int flags)\n{\n    int isFile = flags&2;\n    int isUplevel = flags&1;\n    int lev = 0;\n    bool async = 0;\n    Jsi_RC rc = JSI_OK;\n    int isthrd;\n    Jsi_Interp *sinterp = interp;\n    Jsi_ValueMakeUndef(interp, ret);\n    InterpObj *udf = (InterpObj *)Jsi_UserObjGetData(interp, _this, funcPtr);\n    if (udf)\n        sinterp = udf->subinterp;\n    if (Jsi_InterpGone(interp) || Jsi_InterpGone(sinterp))\n        return Jsi_LogError(\"Sub-interp gone\");\n    isthrd = (interp->threadId != sinterp->threadId);\n    jsi_Frame *f = sinterp->framePtr;\n    Jsi_Value *nw = Jsi_ValueArrayIndex(interp, args, 1);\n    if (!isUplevel) {\n        if (nw && Jsi_GetBoolFromValue(interp, nw, &async))\n            return JSI_ERROR;\n    } else {\n        if (isthrd)\n            return Jsi_LogError(\"can not use uplevel() with threaded interp\");\n        Jsi_Number nlev = sinterp->framePtr->level;\n        if (nw && Jsi_GetNumberFromValue(interp, nw, &nlev)!=JSI_OK)\n            return Jsi_LogError(\"expected number\");\n        lev = (int)nlev;\n        if (lev <= 0)\n            lev = f->level+lev;\n        if (lev <= 0 || lev > f->level)\n            return Jsi_LogError(\"level %d not between 1 and %d\", (int)nlev, f->level);\n    }\n\n    char *cp = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    if (cp==NULL || *cp == 0)\n        return JSI_OK;\n    if (async && isthrd) {\n        /* Post to thread event in sub-interps queue. TODO: could just use event like below... */\n        if (Jsi_MutexLock(interp, sinterp->QMutex) != JSI_OK)\n            return JSI_ERROR;\n        Jsi_DSAppend(&sinterp->interpEvalQ, Jsi_Strlen(Jsi_DSValue(&sinterp->interpEvalQ))?\";\":\"\", cp, NULL);\n        Jsi_MutexUnlock(interp, sinterp->QMutex);\n        return JSI_OK;\n    }\n    if (interp->subOpts.mutexUnlock) Jsi_MutexUnlock(interp, interp->Mutex);\n    if (!isthrd) {\n        int ostrict = sinterp->strict;\n        sinterp->strict = 0;\n        sinterp->level++;\n        if (interp->framePtr->tryDepth)\n            sinterp->framePtr->tryDepth++;\n        if (isFile) {\n            int sflags = 0;\n            if (!sinterp->includeCnt) {\n                sflags = JSI_EVAL_ARGV0|JSI_EVAL_AUTOINDEX;\n                sinterp->isMain = 1;\n            }\n            if (sinterp->debugOpts.debugCallback && !sinterp->includeCnt)  // TODO: safe debugging can't use \"source\"\n                // TODO: we do this in debugger, even though it is illegal for interps to share objects.\n                sinterp->autoFiles = Jsi_ValueDup(sinterp, interp->autoFiles);\n            sinterp->includeCnt++;\n            rc = Jsi_EvalFile(sinterp, Jsi_ValueArrayIndex(interp, args, 0), sflags);\n        } else if (isUplevel == 0 || lev <= 1)\n            rc = (Jsi_EvalString(sinterp, cp, 0) == 0 ? JSI_OK : JSI_ERROR);\n        else {\n            rc = (jsi_evalStrFile(sinterp, NULL, cp, 0, lev) == 0 ? JSI_OK : JSI_ERROR);\n        }\n        sinterp->strict = ostrict;\n        if (interp->framePtr->tryDepth) {\n            sinterp->framePtr->tryDepth--;\n            if (rc != JSI_OK && interp != sinterp) {\n                Jsi_Strcpy(interp->errMsgBuf, sinterp->errMsgBuf);\n                interp->errLine = sinterp->errLine;\n                interp->errFile = sinterp->errFile;\n                sinterp->errMsgBuf[0] = 0;\n            }\n        }\n        sinterp->level--;\n    } else {\n        if (Jsi_MutexLock(interp, sinterp->QMutex) != JSI_OK)\n            return JSI_ERROR;\n        InterpStrEvent *se, *s = (InterpStrEvent *)Jsi_Calloc(1, sizeof(*s));\n        SIGINIT(s,INTERPSTREVENT);\n        s->isExec = 1;\n        s->tryDepth = interp->framePtr->tryDepth;\n        Jsi_DSInit(&s->data);\n        Jsi_DSAppend(&s->data, cp, NULL);\n        Jsi_DSInit(&s->func);\n        //s->mutex = Jsi_MutexNew(interp, -1, JSI_MUTEX_RECURSIVE);\n        //Jsi_MutexLock(s->mutex);\n        se = sinterp->interpStrEvents;\n        if (!se)\n            sinterp->interpStrEvents = s;\n        else {\n            while (se->next)\n                se = se->next;\n            se->next = s;\n        }\n\n        Jsi_MutexUnlock(interp, sinterp->QMutex);\n        while (s->isExec)      /* Wait until done. TODO: timeout??? */\n            Jsi_Sleep(interp, 1);\n        rc = (s->rc == 0 ? JSI_OK : JSI_ERROR);\n        if (rc != JSI_OK)\n            Jsi_LogError(\"eval failed: %s\", Jsi_DSValue(&s->data));\n        Jsi_DSFree(&s->func);\n        Jsi_DSFree(&s->data);\n        Jsi_Free(s);\n    }\n\n    if (interp->subOpts.mutexUnlock && Jsi_MutexLock(interp, interp->Mutex) != JSI_OK) {\n        return JSI_ERROR;\n    }\n\n    if (Jsi_InterpGone(sinterp))\n    {\n        /* TODO: perhaps exit() be able to delete. */\n        //Jsi_InterpDelete(sinterp);\n        return JSI_OK;\n    }\n    /*if (rc != JSI_OK && !async)\n        return rc;*/\n    if (sinterp->retValue->vt != JSI_VT_UNDEF) {\n        if (sinterp == interp)\n            Jsi_ValueCopy(interp, *ret, sinterp->retValue);\n        else\n            Jsi_CleanValue(sinterp, interp, sinterp->retValue, ret);\n    }\n    return rc;\n}\n\nJsi_Interp *jsi_DoExit(Jsi_Interp *interp, int rc)\n{\n    if (rc<0 || rc>127) rc = 127;\n    if (!interp || !interp->opts.no_exit) {\n        if (rc) {\n            Jsi_Flush(interp, jsi_Stdout);\n            Jsi_Flush(interp, jsi_Stderr);\n        }\n        exit(rc);\n    }\n    fprintf(stderr, \"ignoring attempted exit: may cause a crash\\n\");\n    if (interp) interp->deleting = 1;\n    return NULL;\n}\n\n#define FN_interpeval JSI_INFO(\"\\\nWhen the 'async' option is used on a threaded interp, the script is queued as an Event.\")\n\nstatic Jsi_RC InterpEvalCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    return InterpEvalCmd_(interp, args, _this, ret, funcPtr, 0);\n}\n\n\n#define FN_interpuplevel JSI_INFO(\"\\\nThe level argument is as returned by Info.level().  Not supported with threads.\")\nstatic Jsi_RC InterpUplevelCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    return InterpEvalCmd_(interp, args, _this, ret, funcPtr, 1);\n}\n\nstatic Jsi_RC InterpSourceCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    return InterpEvalCmd_(interp, args, _this, ret, funcPtr, 2);\n}\n\nstatic Jsi_RC InterpValueCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    InterpObj *udf = (InterpObj *)Jsi_UserObjGetData(interp, _this, funcPtr);\n    Jsi_Interp *sinterp = interp;\n    if (udf) {\n        if (!udf->subinterp)\n        return Jsi_LogError(\"Sub-interp gone\");\n        sinterp = udf->subinterp;\n        if (interp->threadId != udf->subinterp->threadId)\n            return Jsi_LogError(\"value not supported with threads\");\n    }\n    Jsi_Value *nw = Jsi_ValueArrayIndex(interp, args, 1);\n    jsi_Frame *f = sinterp->framePtr;\n    Jsi_Number nlev = sinterp->framePtr->level;\n    if (nw && Jsi_GetNumberFromValue(interp, nw, &nlev))\n        return JSI_ERROR;\n    int lev = (int)nlev;\n    if (lev <= 0)\n        lev = f->level+lev;\n    if (lev <= 0 || lev > f->level)\n        return Jsi_LogError(\"level %d not between 1 and %d\", (int)nlev, f->level);\n    while (f->level != lev  && f->parent)\n        f = f->parent;\n\n    const char* arg = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    Jsi_Value *val = NULL;\n    if (arg) {\n        if (f == sinterp->framePtr)\n            val = Jsi_NameLookup(sinterp, arg);\n        else {\n            jsi_Frame *of = sinterp->framePtr;\n            sinterp->framePtr = f;\n            val = Jsi_NameLookup(sinterp, arg);\n            sinterp->framePtr = of;\n        }\n    }\n    if (!val)\n        return Jsi_LogError(\"unknown var: %s\", arg);\n    if (sinterp == interp) {\n        Jsi_ValueCopy(interp, *ret, val);\n        return JSI_OK;\n    }\n    Jsi_CleanValue(sinterp, interp, val, ret);\n    return JSI_OK;\n}\n\nstatic Jsi_RC InterpInfoCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    InterpObj *udf = (InterpObj *)Jsi_UserObjGetData(interp, _this, funcPtr);\n    Jsi_Interp *subinterp = interp;\n    if (udf) {\n        if (!udf->subinterp)\n            return Jsi_LogError(\"Sub-interp gone\");\n        subinterp = udf->subinterp;\n    }\n    return jsi_InterpInfo(subinterp, args, _this, ret, funcPtr);\n}\n\nJsi_RC jsi_InterpInfo(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Interp *sinterp = interp;\n    Jsi_DString dStr = {}, cStr = {};\n    char tbuf[1024];\n    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n    tbuf[0] = 0;\n    if (v) {\n        InterpObj *udf = NULL;\n        if (v && v->vt == JSI_VT_OBJECT && v->d.obj->ot == JSI_OT_USEROBJ)\n            udf = (InterpObj *)v->d.obj->d.uobj->data;\n        if (udf && udf->subinterp) {\n            SIGASSERT(udf, INTERPOBJ);\n            sinterp = udf->subinterp;\n        } else\n            return Jsi_LogError(\"unknown interp\");\n    }\n    if (sinterp->subthread)\n        snprintf(tbuf, sizeof(tbuf), \", thread:{errorCnt:%u, evalCnt:%u, msgCnt:%u }\",\n            sinterp->threadErrCnt, sinterp->threadEvalCnt, sinterp->threadMsgCnt );\n    const char *funcstr = sinterp->framePtr->funcName;\n    if (!funcstr)\n        funcstr = \"\";\n    int curLine = (sinterp->curIp?sinterp->curIp->Line:0);\n    Jsi_DSPrintf(&dStr, \"{curLevel:%d, curLine:%d, curFile:\\\"%s\\\", curFunc:\\\"%s\\\", hasExited:%d, \"\n        \"opCnt:%d, isSafe:%s, depth:%d, codeCacheHits: %d, typeMismatchCnt:%d, \"\n        \"funcCallCnt:%d, cmdCallCnt:%d, includeCnt:%d, includeDepth:%d, pkgReqDepth:%d, \"\n        \"cwd:\\\"%s\\\", lockTimeout: %d, name, \\\"%s\\\" %s%s};\",\n        sinterp->level, curLine, jsi_GetCurFile(sinterp), funcstr?funcstr:\"\",\n        sinterp->exited, sinterp->opCnt, sinterp->isSafe?\"true\":\"false\",\n        sinterp->interpDepth, sinterp->codeCacheHit, sinterp->typeMismatchCnt,\n        sinterp->funcCallCnt, sinterp->cmdCallCnt, sinterp->includeCnt, sinterp->includeDepth, sinterp->pkgReqDepth,\n        (sinterp->curDir?sinterp->curDir:Jsi_GetCwd(sinterp,&cStr)),\n        sinterp->lockTimeout, sinterp->name?sinterp->name:\"\", tbuf[0]?\",\":\"\", tbuf);\n    Jsi_RC rc = Jsi_JSONParse(interp, Jsi_DSValue(&dStr), ret, 0);\n    if (rc != JSI_OK)\n        puts(Jsi_DSValue(&dStr));\n    Jsi_DSFree(&dStr);\n    Jsi_DSFree(&cStr);\n    return rc;\n}\n\nstatic Jsi_RC SubInterpEvalCallback(Jsi_Interp *interp, void* data)\n{\n    Jsi_RC rc = JSI_OK;\n    Jsi_DString dStr = {};\n    if (Jsi_MutexLock(interp, interp->QMutex) != JSI_OK)\n        return JSI_ERROR;\n    char *cp = Jsi_DSValue(&interp->interpEvalQ);\n    if (*cp) {\n        Jsi_DSAppend(&dStr, cp, NULL);\n        Jsi_DSSetLength(&interp->interpEvalQ, 0);\n        interp->threadEvalCnt++;\n        Jsi_MutexUnlock(interp, interp->QMutex);\n        if (Jsi_EvalString(interp, Jsi_DSValue(&dStr), 0) != JSI_OK)\n            rc = JSI_ERROR;\n        Jsi_DSSetLength(&dStr, 0);\n        if (Jsi_MutexLock(interp, interp->QMutex) != JSI_OK)\n            return JSI_ERROR;\n    }\n    Jsi_MutexUnlock(interp, interp->QMutex);\n    Jsi_DSFree(&dStr);\n    if (Jsi_MutexLock(interp, interp->QMutex) != JSI_OK)\n        return JSI_ERROR;\n\n    /* Process subevents. */\n    InterpStrEvent *oldse, *se = interp->interpStrEvents;\n    Jsi_MutexUnlock(interp, interp->QMutex);\n    while (se) {\n        oldse = se;\n        int isExec = se->isExec;\n        if (se->acdata) {\n            jsi_AliasCreateCmd(interp, Jsi_DSValue(&se->func), se->acdata);\n        }\n        else if (se->acfunc) {\n            if (JSI_OK != Jsi_FunctionInvokeJSON(interp, se->acfunc, Jsi_DSValue(&se->data), NULL))\n                rc = JSI_ERROR;\n            Jsi_DecrRefCount(interp, se->acfunc);\n        }\n        else if (isExec) {\n            if (se->tryDepth)\n                interp->framePtr->tryDepth++;\n            se->rc = Jsi_EvalString(interp, Jsi_DSValue(&se->data), 0);\n            Jsi_DSSetLength(&se->data, 0);\n            if (se->rc != JSI_OK && se->tryDepth) {\n                Jsi_DSAppend(&se->data, interp->errMsgBuf, NULL);\n                se->errLine = interp->errLine;\n                se->errFile = interp->errFile;\n            } else {\n                Jsi_ValueGetDString(interp, interp->retValue, &se->data, JSI_OUTPUT_JSON);\n            }\n            if (se->tryDepth)\n                interp->framePtr->tryDepth--;\n\n        /* Otherwise, async calls. */\n        /*} else if (se->objData) {\n            if (JSI_OK != Jsi_CommandInvoke(interp, Jsi_DSValue(&se->func), se->objData, NULL))\n                rc = JSI_ERROR;*/\n        } else {\n            const char *scp = Jsi_DSValue(&se->data);\n            if (JSI_OK != Jsi_CommandInvokeJSON(interp, Jsi_DSValue(&se->func), scp, NULL))\n                rc = JSI_ERROR;\n        }\n        if (!isExec) {\n            Jsi_DSFree(&se->func);\n            Jsi_DSFree(&se->data);\n        }\n        if (Jsi_MutexLock(interp, interp->QMutex) != JSI_OK)\n            return JSI_ERROR;\n        interp->interpStrEvents = se->next;\n        if (!isExec) Jsi_Free(se);\n        se = interp->interpStrEvents;\n        Jsi_MutexUnlock(interp, interp->QMutex);\n        if (isExec)\n            oldse->isExec = 0;\n    }\n\n    return rc;\n}\n\n\nstatic Jsi_RC ThreadEvalCallback(Jsi_Interp *interp, void* data) {\n    Jsi_RC rc;\n\n    if ((rc=SubInterpEvalCallback(interp, data)) != JSI_OK)\n        interp->threadErrCnt++;\n    return rc;\n}\n\n/* Create an event handler in interp to handle call/eval/send asyncronously via 'Sys.update()'. */\nvoid jsi_AddEventHandler(Jsi_Interp *interp)\n{\n    Jsi_Event *ev;\n    while (!interp->EventHdlId) { /* Find an empty event slot. */\n        bool isNew;\n        uintptr_t id = ++interp->eventIdx;\n        Jsi_HashEntry *hPtr = Jsi_HashEntryNew(interp->eventTbl, (void*)id, &isNew);\n        if (!isNew)\n            continue;\n        ev = (Jsi_Event*)Jsi_Calloc(1, sizeof(*ev));\n        SIGINIT(ev,EVENT);\n        ev->id = id;\n        ev->handler = ThreadEvalCallback;\n        ev->hPtr = hPtr;\n        ev->evType = JSI_EVENT_ALWAYS;\n        Jsi_HashValueSet(hPtr, ev);\n        interp->EventHdlId = id;\n    }\n}\n\n#define FN_call JSI_INFO(\"\\\nInvoke function in sub-interp with arguments.\\n\\\nSince interps are not allowed to share objects, \\\ndata is automatically cleansed by encoding/decoding to/from JSON if required.\\n\\\nUnless an 'async' parameter is true call is acyncronous.\\n\\\nOtherwise waits until the sub-interp is idle, \\\nto make call and return result.\")\n\nstatic Jsi_RC InterpCallCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    InterpObj *udf = (InterpObj *)Jsi_UserObjGetData(interp, _this, funcPtr);\n    int isthrd;\n    Jsi_Interp *sinterp;\n    if (udf)\n        sinterp = udf->subinterp;\n    else\n        return Jsi_LogError(\"Apply Interp.call in a non-subinterp\");\n    if (Jsi_InterpGone(sinterp))\n        return Jsi_LogError(\"Sub-interp gone\");\n    isthrd = (interp->threadId != sinterp->threadId);\n\n    Jsi_Value *func = NULL;\n    char *fname = NULL;\n    func = Jsi_ValueArrayIndex(interp, args, 0);\n    fname = Jsi_ValueString(interp, func, NULL);\n    if (!fname)\n        return Jsi_LogError(\"function name must be a string\");\n    if (Jsi_MutexLock(interp, sinterp->Mutex) != JSI_OK)\n        return JSI_ERROR;\n    Jsi_Value *namLU = Jsi_NameLookup(sinterp, fname);\n    Jsi_MutexUnlock(interp, sinterp->Mutex);\n    if (namLU == NULL)\n        return Jsi_LogError(\"unknown function: %s\", fname);\n\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 1);\n    char *cp = Jsi_ValueString(interp, arg, NULL);\n\n    if (cp == NULL && !Jsi_ValueIsArray(interp, arg))\n        return Jsi_LogError(\"expected string or array\");\n\n    Jsi_Value *vwait = Jsi_ValueArrayIndex(interp, args, 2);\n    Jsi_RC rc = JSI_OK;\n    bool wait = 0;\n    if (vwait && Jsi_GetBoolFromValue(interp, vwait, &wait))\n        return JSI_ERROR;\n\n    if (wait) {\n        Jsi_DString dStr = {};\n        if (cp == NULL)\n            cp = (char*)Jsi_ValueGetDString(interp, arg, &dStr, JSI_OUTPUT_JSON);\n        if (interp->subOpts.mutexUnlock) Jsi_MutexUnlock(interp, interp->Mutex);\n        if (Jsi_MutexLock(interp, sinterp->Mutex) != JSI_OK) {\n            if (interp->subOpts.mutexUnlock) Jsi_MutexLock(interp, interp->Mutex);\n            return JSI_ERROR;\n        }\n        Jsi_Value *srPtr = Jsi_ValueNew1(sinterp);\n        /* TODO: call from this interp may not be safe if threaded.\n         * Could instead use async code below then wait for unlock on se->mutex. */\n        rc = Jsi_CommandInvokeJSON(sinterp, fname, cp, &srPtr);\n        Jsi_DSSetLength(&dStr, 0);\n        Jsi_CleanValue(sinterp, interp, srPtr, ret);\n        //Jsi_ValueCopy(interp, *ret, srPtr);\n        Jsi_DecrRefCount(sinterp, srPtr);\n        Jsi_DSFree(&dStr);\n        Jsi_MutexUnlock(interp, sinterp->Mutex);\n        if (interp->subOpts.mutexUnlock && Jsi_MutexLock(interp, interp->Mutex) != JSI_OK) {\n            Jsi_LogBug(\"mutex re-get failed\");\n            return JSI_ERROR;\n        }\n        return rc;\n    }\n\n    /* Post to thread event in sub-interps queue. */\n    if (Jsi_MutexLock(interp, sinterp->QMutex) != JSI_OK)\n        return JSI_ERROR;\n\n    /* Is an async call. */\n    InterpStrEvent *se, *s = (InterpStrEvent *)Jsi_Calloc(1, sizeof(*s));\n    // TODO: is s->data inited?\n    Jsi_DSInit(&s->data);\n    if (!cp) {\n        Jsi_ValueGetDString(interp, arg, &s->data, JSI_OUTPUT_JSON);\n    } else {\n        Jsi_DSSetLength(&s->data, 0);\n        Jsi_DSAppend(&s->data, cp, NULL);\n    }\n    Jsi_DSInit(&s->func);\n    Jsi_DSAppend(&s->func, fname, NULL);\n    se = sinterp->interpStrEvents;\n    if (!se)\n        sinterp->interpStrEvents = s;\n    else {\n        while (se->next)\n            se = se->next;\n        se->next = s;\n    }\n\n    Jsi_MutexUnlock(interp, sinterp->QMutex);\n    if (!isthrd) {\n        if (SubInterpEvalCallback(sinterp, NULL) != JSI_OK)\n            sinterp->threadErrCnt++;\n    }\n    return JSI_OK;\n}\n\nJsi_RC Jsi_Mount( Jsi_Interp *interp, Jsi_Value *archive, Jsi_Value *mount, Jsi_Value **ret)\n{\n#if JSI__ZVFS==1\n    return Zvfs_Mount(interp, archive, mount, ret);\n#else\n    return JSI_ERROR;\n#endif\n}\n\n/* Looks in dir for autoload.jsi or lib/autoload.jsi to add to autoFiles list. */\nint Jsi_AddAutoFiles(Jsi_Interp *interp, const char *dir) {\n    Jsi_DString dStr = {};\n    Jsi_StatBuf stat;\n    int i, cnt = 0;\n    for (i=0; i<2; i++) {\n        Jsi_DSAppend(&dStr, dir, (i==0?\"/lib\":\"\"),\"/autoload.jsi\", NULL);\n        Jsi_Value *v = Jsi_ValueNewStringKey(interp, Jsi_DSValue(&dStr));\n        if (Jsi_Stat(interp, v, &stat) != 0)\n            Jsi_ValueFree(interp, v);\n        else {\n            if (!interp->autoFiles) {\n                interp->autoFiles = Jsi_ValueNewArray(interp, 0, 0);\n                Jsi_IncrRefCount(interp, interp->autoFiles);\n            }\n            Jsi_ObjArrayAdd(interp, interp->autoFiles->d.obj, v);\n            cnt++;\n            interp->autoLoaded = 0;\n        }\n        Jsi_DSSetLength(&dStr, 0);\n    }\n    Jsi_DSFree(&dStr);\n    return cnt;\n}\n\nJsi_RC Jsi_EvalZip(Jsi_Interp *interp, const char *exeFile, const char *mntDir, int *jsFound)\n{\n#if JSI__ZVFS==1\n    Jsi_StatBuf stat;\n    Jsi_Value *vinit, *linit, *vmnt = NULL;\n    Jsi_Value *vexe = Jsi_ValueNewStringKey(interp, exeFile);\n    Jsi_Value *ret = NULL;\n    Jsi_RC rc;\n    const char *omntDir = mntDir;\n    int pass = 0;\n    Jsi_IncrRefCount(interp, vexe);\n    Jsi_HashSet(interp->genValueTbl, vexe, vexe);\n    if (jsFound)\n        *jsFound = 0;\n    if (!mntDir)\n        ret = Jsi_ValueNew(interp);\n    else {\n        vmnt = Jsi_ValueNewStringKey(interp, mntDir);\n        Jsi_IncrRefCount(interp, vmnt);\n        Jsi_HashSet(interp->genValueTbl, vmnt, vmnt);\n    }\n    bool osafe = interp->isSafe;\n    if (interp->startSafe)\n        interp->isSafe = 0;\n    rc =Jsi_Mount(interp, vexe, vmnt, &ret);\n    interp->isSafe = osafe;\n    if (rc != JSI_OK)\n        return rc;\n    Jsi_DString dStr, bStr;\n    Jsi_DSInit(&dStr);\n    Jsi_DSInit(&bStr);\n    if (!mntDir) {\n        mntDir = Jsi_KeyAdd(interp, Jsi_ValueString(interp, ret, NULL));\n        Jsi_DecrRefCount(interp, ret);\n    }\ndochk:\n    Jsi_DSAppend(&dStr, mntDir, \"/main.jsi\", NULL);\n    if (interp->pkgDirs)\n        Jsi_ValueArrayPush(interp, interp->pkgDirs, Jsi_ValueNewStringKey(interp, mntDir));\n    else {\n        interp->pkgDirs = Jsi_ValueNewArray(interp, &mntDir, 1);\n        Jsi_IncrRefCount(interp, interp->pkgDirs);\n    }\n    vinit = Jsi_ValueNewStringKey(interp,  Jsi_DSValue(&dStr));\n    Jsi_IncrRefCount(interp, vinit);\n    Jsi_HashSet(interp->genValueTbl, vinit, vinit);\n    Jsi_DSFree(&dStr);\n    Jsi_DSAppend(&dStr, mntDir, \"/lib\", NULL);\n    const char *str = Jsi_DSValue(&dStr);\n    linit = Jsi_ValueNewStringKey(interp, str);\n    Jsi_IncrRefCount(interp, linit);\n    if (Jsi_Stat(interp, linit, &stat) == 0)\n        Jsi_ValueArrayPush(interp, interp->pkgDirs, linit);\n    Jsi_DecrRefCount(interp, linit);\n    Jsi_DSFree(&dStr);\n    Jsi_DSFree(&bStr);\n    if (Jsi_Stat(interp, vinit, &stat) == 0) {\n        if (jsFound)\n            *jsFound |= JSI_ZIP_MAIN;\n        interp->execZip = vexe;\n        return Jsi_EvalFile(interp, vinit, JSI_EVAL_ARGV0|JSI_EVAL_AUTOINDEX);\n    }\n    if (Jsi_AddAutoFiles(interp, mntDir) && omntDir)\n        *jsFound = JSI_ZIP_INDEX;\n    if (!pass++) {\n        str = Jsi_Strrchr(exeFile, '/');\n        if (str) str++;\n        else str = exeFile;\n        char *bn = Jsi_DSAppend(&bStr, mntDir, \"/\", str, NULL);\n        bn = Jsi_Strrchr(bn, '.');\n        if (bn) *bn = 0;\n        mntDir = Jsi_DSValue(&bStr);\n        linit = Jsi_ValueNewStringKey(interp, mntDir);\n        Jsi_IncrRefCount(interp, linit);\n        int bsi = Jsi_Stat(interp, linit, &stat);\n        Jsi_DecrRefCount(interp, linit);\n        if (bsi == 0)\n            goto dochk;\n        Jsi_DSFree(&bStr);\n    }\n#endif\n    return JSI_OK;\n}\n\n#ifndef JSI_OMIT_THREADS\n\n#ifdef __WIN32\n#define JSITHREADRET void\n#else\n#define JSITHREADRET void*\n#endif\n\nstatic JSITHREADRET NewInterpThread(void* iPtr)\n{\n    int rc = JSI_OK;\n    InterpObj *udf = (InterpObj *)iPtr;\n    Jsi_Interp *interp = udf->subinterp;\n    interp->threadId = Jsi_CurrentThread();\n    if (interp->scriptStr)\n        rc = Jsi_EvalString(interp, interp->scriptStr, 0);\n    else if (interp->scriptFile) {\n        if (!interp->debugOpts.debugCallback) // Debug will use Interp.source() instead.\n            Jsi_EvalFile(interp, interp->scriptFile, 0);\n    } else {\n        Jsi_LogBug(\"no eval\");\n    }\n    if (rc != JSI_OK) {\n        Jsi_LogError(\"eval failure\");\n        interp->threadErrCnt++;\n        if (Jsi_MutexLock(interp, interp->Mutex) != JSI_OK)\n            return NULL;\n        Jsi_MutexUnlock(interp, interp->Mutex);\n    }\n    interpObjErase(udf);\n#ifndef __WIN32\n    /* TODO: should we wait/notify parent??? */\n    pthread_detach(pthread_self());\n    return NULL;\n#endif\n}\n#endif\n\nstatic Jsi_RC InterpConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr);\nstatic Jsi_RC InterpConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr);\n\nstatic Jsi_CmdSpec interpCmds[] = {\n    { \"Interp\", InterpConstructor,0,  1, \"options:object=void\", .help=\"Create a new interp\", .retType=(uint)JSI_TT_USEROBJ, .flags=JSI_CMD_IS_CONSTRUCTOR, .info=0, .opts=InterpOptions},\n    { \"alias\",  InterpAliasCmd,   0,  4, \"name:string=void, func:function|null=void, args:array|null=void, async=false\",.help=\"Set/get global alias bindings for command in an interp\", .retType=(uint)JSI_TT_ANY, .flags=0, .info=FN_intalias },\n    { \"call\",   InterpCallCmd,    2,  3, \"funcName:string, args:array, wait:boolean=false\", .help=\"Call named function in subinterp\", .retType=(uint)JSI_TT_ANY, .flags=0, .info=FN_call },\n    { \"conf\",   InterpConfCmd,    0,  1, \"options:string|object=void\",.help=\"Configure option(s)\" , .retType=(uint)JSI_TT_ANY,.flags=0,.info=0,.opts=InterpOptions},\n    { \"eval\",   InterpEvalCmd,    1,  2, \"js:string, async:boolean=false\", .help=\"Interpret script within sub-interp\", .retType=(uint)JSI_TT_ANY, .flags=0, .info=FN_interpeval },\n    { \"info\",   InterpInfoCmd,    0,  0, \"\", .help=\"Returns internal statistics about interp\", .retType=(uint)JSI_TT_OBJECT },\n    { \"source\", InterpSourceCmd,  1,  2, \"file:string, async:boolean=false\", .help=\"Interpret file within sub-interp\", .retType=(uint)JSI_TT_ANY, .flags=0, .info=FN_interpeval },\n    { \"uplevel\",InterpUplevelCmd, 2,  2, \"js:string, level:number=0\", .help=\"Interpret code at the given stack level\", .retType=(uint)JSI_TT_ANY, .flags=0, .info=FN_interpuplevel },\n    { \"value\",  InterpValueCmd,   1,  2, \"var:string, level:number=0\", .help=\"Lookup value of variable at stack level\", .retType=(uint)JSI_TT_ANY },\n    { NULL,     0,0,0,0, .help=\"Commands for accessing interps\" }\n};\n\nstatic Jsi_UserObjReg interpobject = {\n    \"Interp\",\n    interpCmds,\n    interpObjFree,\n    interpObjIsTrue,\n    interpObjEqual\n};\n\n\nstatic Jsi_RC InterpConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Obj *fobj;\n    Jsi_Value *toacc;\n    InterpObj *cmdPtr = (InterpObj *)Jsi_Calloc(1,sizeof(*cmdPtr));\n    int rc = JSI_OK;\n    SIGINIT(cmdPtr,INTERPOBJ);\n    cmdPtr->parent = interp;\n\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);\n\n    if (!(cmdPtr->subinterp = jsi_InterpNew(interp, arg, NULL))) {\n        Jsi_Free(cmdPtr);\n        return JSI_ERROR;\n    }\n    Jsi_Interp *sinterp = cmdPtr->subinterp;\n    sinterp->opts.no_exit = interp->opts.no_exit;\n    toacc = NULL;\n    if (Jsi_FunctionIsConstructor(funcPtr)) {\n        toacc = _this;\n    } else {\n        Jsi_Obj *o = Jsi_ObjNew(interp);\n        Jsi_PrototypeObjSet(interp, \"Interp\", o);\n        Jsi_ValueMakeObject(interp, ret, o);\n        toacc = *ret;\n    }\n\n    fobj = Jsi_ValueGetObj(interp, toacc);\n    if ((cmdPtr->objId = Jsi_UserObjNew(interp, &interpobject, fobj, cmdPtr))<0)\n        goto bail;\n    sinterp->objId = cmdPtr->objId;\n    cmdPtr->fobj = fobj;\n#ifndef JSI_OMIT_THREADS\n    if (sinterp->subthread) {\n#ifdef __WIN32\n        if (!_beginthread( NewInterpThread, 0, cmdPtr )) {\n            Jsi_LogError(\"thread create failed\");\n            goto bail;\n        }\n#else\n        pthread_t nthread;\n        if (pthread_create(&nthread, NULL, NewInterpThread, cmdPtr) != 0) {\n            Jsi_LogError(\"thread create failed\");\n            goto bail;\n        }\n#endif //__WIN32\n#else\n    if (0) {\n#endif //JSI_OMIT_THREADS\n    } else {\n        //sinterp->framePtr->tryDepth++;\n        if (sinterp->scriptStr != 0) {\n            if (sinterp->scriptFile && !interp->curFile)\n                sinterp->curFile = Jsi_ValueString(sinterp, sinterp->scriptFile, NULL);\n            rc = Jsi_EvalString(sinterp, sinterp->scriptStr, JSI_EVAL_ISMAIN);\n        } else if (sinterp->scriptFile && !sinterp->debugOpts.debugCallback) {\n            int len;\n            if (Jsi_ValueString(interp, sinterp->scriptFile, &len) && len==0)\n                Jsi_Interactive(sinterp, JSI_OUTPUT_QUOTE|JSI_OUTPUT_NEWLINES);\n            else\n                rc = Jsi_EvalFile(sinterp, sinterp->scriptFile, JSI_EVAL_ISMAIN);\n        }\n        //sinterp->framePtr->tryDepth--;\n        if (rc == JSI_EXIT)\n            return JSI_OK;\n        if (rc != JSI_OK) {\n            /*Jsi_Strcpy(interp->errMsgBuf, sinterp->errMsgBuf);\n            interp->errLine = sinterp->errLine;\n            interp->errFile = sinterp->errFile;\n            sinterp->errMsgBuf[0] = 0;*/\n            goto bail;\n        }\n    }\n    return JSI_OK;\n\nbail:\n    interpObjErase(cmdPtr);\n    Jsi_ValueMakeUndef(interp, ret);\n    return JSI_ERROR;\n}\n\nstatic Jsi_RC Jsi_DoneInterp(Jsi_Interp *interp)\n{\n    Jsi_UserObjUnregister(interp, &interpobject);\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_InterpConfFile(Jsi_Interp *interp, const char *fname, bool etc)\n{\n    Jsi_RC rc;\n    Jsi_DString dStr = {};\n    Jsi_Value *opts = NULL, *fn = Jsi_ValueNewStringConst(interp, fname, -1);\n    Jsi_IncrRefCount(interp, fn);\n    bool isSafe = interp->isSafe;\n    if (etc)\n        interp->isSafe = 0;\n    rc = Jsi_FileRead(interp, fn, &dStr);\n    if (rc != JSI_OK)\n        goto done;\n    opts = Jsi_ValueNew1(interp);\n    if (rc == JSI_OK)\n        rc = Jsi_JSONParse(interp, Jsi_DSValue(&dStr), &opts, 0);\n    if (rc == JSI_OK\n        && Jsi_OptionsProcess(interp, InterpOptions, interp, opts, 0) < 0)\n        rc = JSI_ERROR;\ndone:\n    if (etc && isSafe)\n        interp->isSafe = 1;\n    if (opts)\n        Jsi_DecrRefCount(interp, opts);\n    Jsi_DecrRefCount(interp, fn);\n    Jsi_DSFree(&dStr);\n    return rc;\n}\n\nstatic Jsi_RC jsi_InterpConfFiles(Jsi_Interp *interp)\n{\n    Jsi_RC rc = JSI_OK;\n#ifndef JSI__CONFFILE\n#define JSI__CONFFILE \"/etc/jsish.conf\"\n#endif\n    const char *fn = JSI__CONFFILE;\n    if (!fn || !fn[0])\n        return JSI_OK;\n    if (interp->confFile)\n        rc = jsi_InterpConfFile(interp, interp->confFile, 0);\n    if (rc == JSI_OK && access(fn, R_OK)==0)\n        rc = jsi_InterpConfFile(interp, fn, 1);\n    if (rc != JSI_OK)\n        Jsi_LogWarn(\"parse failure: %s\", fn);\n    if (interp->jsppChars && Jsi_Strlen(interp->jsppChars)!=2) {\n        Jsi_LogWarn(\"jsppChars ignored: length not 2: %s\", interp->jsppChars);\n        interp->jsppChars = NULL;\n    }\n    return rc;\n}\n\nstatic Jsi_RC InterpConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    InterpObj *udf = (typeof(udf))Jsi_UserObjGetData(interp, _this, funcPtr);\n    Jsi_RC rc;\n    Jsi_Value *opts = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_Interp *sinterp = interp;\n    if (!udf || udf->subinterp == interp) {\n        if (interp->noConfig && opts && !Jsi_ValueIsString(interp, opts))\n            return Jsi_LogError(\"Interp conf() is disabled for set\");\n        rc = Jsi_OptionsConf(interp, InterpOptions, interp, opts, ret, 0);\n    } else {\n        sinterp = udf->subinterp;\n        Jsi_Value *popts = opts;\n        if (opts && opts->vt != JSI_VT_NULL && !Jsi_ValueString(interp, opts, NULL) && opts->vt == JSI_VT_OBJECT) {\n            popts = Jsi_ValueNew1(sinterp);\n            Jsi_CleanValue(interp, sinterp, opts, &popts);\n        }\n        rc = Jsi_OptionsConf(sinterp, InterpOptions, sinterp, popts, ret, 0);\n        if (popts && popts != opts)\n            Jsi_DecrRefCount(sinterp, popts);\n        Jsi_CleanValue(sinterp, interp, *ret, ret);\n    }\n    return rc;\n}\n\nJsi_Value *Jsi_ReturnValue(Jsi_Interp *interp) {\n    return interp->retValue;\n}\n\nJsi_RC jsi_InitInterp(Jsi_Interp *interp, int release)\n{\n    if (release) return Jsi_DoneInterp(interp);\n    Jsi_Hash *isys;\n    if (!(isys = Jsi_UserObjRegister(interp, &interpobject)))\n        Jsi_LogBug(\"Can not init interp\");\n\n    Jsi_CommandCreateSpecs(interp, interpobject.name, interpCmds, isys, JSI_CMDSPEC_ISOBJ);\n    return JSI_OK;\n}\n\nbool Jsi_InterpSafe(Jsi_Interp *interp)\n{\n    return interp->isSafe;\n}\n\nJsi_RC Jsi_InterpAccess(Jsi_Interp *interp, Jsi_Value* resource, int aflag)\n{\n    switch (aflag) {\n        case JSI_INTACCESS_NETWORK:\n            return (interp->noNetwork?JSI_ERROR:JSI_OK);\n        case JSI_INTACCESS_MAININTERP:\n            return (interp->parent?JSI_ERROR:JSI_OK);\n        case JSI_INTACCESS_SETSSL:\n            interp->hasOpenSSL = 1;\n            return JSI_OK;\n        case JSI_INTACCESS_CREATE:\n            return (interp->isSafe && interp->safeMode==jsi_safe_Lockdown?JSI_ERROR: JSI_OK);\n        case JSI_INTACCESS_WRITE:\n        case JSI_INTACCESS_READ:\n            break;\n        default:\n            return JSI_ERROR;\n    }\n    if (!resource)\n        return JSI_ERROR;\n    Jsi_Value *v, *dirs = ((aflag==JSI_INTACCESS_WRITE) ? interp->safeWriteDirs : interp->safeReadDirs);\n    if (!interp->isSafe)\n        return JSI_OK;\n    if (!dirs)\n        return JSI_ERROR;\n    char pbuf[PATH_MAX];\n    int i, m, argc = Jsi_ValueGetLength(interp, dirs);\n    char *str, *dstr = Jsi_Realpath(interp, resource, pbuf);\n    if (!dstr)\n        return JSI_ERROR;\n    for (i=0; i<argc; i++) {\n        v = Jsi_ValueArrayIndex(interp, dirs, i);\n        if (!v) continue;\n        str = Jsi_ValueString(interp, v, &m);\n        if (!str || m<=0) continue;\n        if (!Jsi_Strcmp(str, dstr)) // Exact match.\n            return JSI_OK;\n        if (Jsi_Strncmp(str, dstr, m))\n            continue;\n        if (m>1 && str[m-1]=='/')\n            return JSI_OK;\n        if (dstr[m] == '/')\n            return JSI_OK;\n    }\n    return JSI_ERROR;\n}\n\nJsi_Value *Jsi_InterpResult(Jsi_Interp *interp)\n{\n    return interp->retValue;\n}\n\nconst char *Jsi_InterpLastError(Jsi_Interp *interp, const char **errFilePtr, int *errLinePtr)\n{\n    if (errFilePtr)\n        *errFilePtr = interp->errFile;\n    if (errLinePtr)\n        *errLinePtr = interp->errLine;\n    return interp->errMsgBuf;\n}\n\n#ifdef __WIN32\nvoid bzero(void *s, size_t n) {\n    memset(s, 0, n);\n}\n#endif\n#endif\n", "#ifndef JSI_LITE_ONLY\n\n#ifndef JSI_AMALGAMATION\n#include \"jsiInt.h\"\n#endif\n\nstatic void jsonNewDString(Jsi_Interp *interp, Jsi_DString *dStr, const char* str, int len)\n{\n    char buf[100], *dp = buf;\n    const char *cp = str;\n    int ulen;\n    \n    while ((cp-str)<len) {\n        if (*cp == '\\\\') {\n            switch (cp[1]) {\n                case 'b': *dp++ = '\\b'; break;\n                case 'n': *dp++ = '\\n'; break;\n                case 'r': *dp++ = '\\r'; break;\n                case 'f': *dp++ = '\\f'; break;\n                case 't': *dp++ = '\\t'; break;\n                case '\\\"': *dp++ = '\\\"'; break;\n                case '\\\\': *dp++ = '\\\\'; break;\n                case 'u': \n                    if ((ulen=Jsi_UtfDecode(cp+2, dp))) {\n                        dp += ulen;\n                        cp += 4;\n                    } else {                    \n                        *dp++ = '\\\\';\n                        *dp++ = 'u';\n                    }\n                    break;\n            }\n            cp+=2;\n        } else {\n            *dp++ = *cp++;\n        }\n        if ((dp-buf)>90) {\n            *dp = 0;\n            Jsi_DSAppendLen(dStr, buf, dp-buf);\n            dp = buf;\n        }\n    }\n    *dp = 0;\n    Jsi_DSAppendLen(dStr, buf, dp-buf);\n}\n\nstatic Jsi_Value *jsonNewStringObj(Jsi_Interp *interp, const char* str, int len)\n{\n    Jsi_Value *v = NULL;\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    jsonNewDString(interp, &dStr, str, len);\n    v = Jsi_ValueNew(interp);\n    Jsi_ValueFromDS(interp, &dStr, &v);\n    //Jsi_DSFree(&dStr);\n    return v;\n}\n\nstatic Jsi_Value* jsonGenObject(Jsi_Interp *interp, Jsi_JsonParser *p, const char *js, uint pos, uint *endPos);\nstatic Jsi_Value* jsonGenArray(Jsi_Interp *interp, Jsi_JsonParser *p, const char *js, uint pos, uint *endPos);\n\nstatic Jsi_Value*\njsonGen1Value(Jsi_Interp *interp, Jsi_JsonParser *p, const char *js, uint i, uint *endPos, int incr)\n{\n    uint len;\n    const char *t;\n    Jsi_Value *v = NULL;\n    \n    switch (p->tokens[i].type) {\n        case JSI_JTYPE_PRIMITIVE:\n            t = Jsi_JsonGetTokstr(p, js, i, &len);\n            if (len == 4 && Jsi_Strncmp(t, \"true\", len)==0)\n                v = Jsi_ValueMakeBool(interp, NULL, 1);\n            else if (len == 5 && Jsi_Strncmp(t, \"false\", len)==0)\n                v = Jsi_ValueMakeBool(interp, NULL, 0);\n            else if (len == 4 && Jsi_Strncmp(t, \"null\", len)==0)\n                v = Jsi_ValueMakeNull(interp, NULL);\n            else if (len == 9 && Jsi_Strncmp(t, \"undefined\", len)==0)\n                v = Jsi_ValueMakeNull(interp, NULL);\n            else {\n                char *ep;\n                Jsi_Number d;\n                d = strtod(t,&ep);\n                if (ep>(t+len))\n                    Jsi_LogWarn(\"bad number %*s\", len, t);\n                v = Jsi_ValueMakeNumber(interp, NULL, d);\n            }\n            break;\n        case JSI_JTYPE_STRING:\n            t = Jsi_JsonGetTokstr(p, js, i, &len);\n            v = jsonNewStringObj(interp, t, len);\n            break;\n        case JSI_JTYPE_ARRAY:\n            v = jsonGenArray(interp, p, js, i, &i);\n            i--;\n            break;\n        case JSI_JTYPE_OBJECT:\n            v = jsonGenObject(interp, p, js, i, &i);\n            i--;\n            break;\n        default:\n            break;\n    }\n    if (endPos)\n        *endPos = i;\n    if (v == NULL)\n        v = Jsi_ValueMakeUndef(interp, NULL);\n    if (incr)\n        Jsi_IncrRefCount(interp, v);\n    return v;\n}\n\nstatic Jsi_Value*\njsonGenObject(Jsi_Interp *interp, Jsi_JsonParser *p, const char *js, uint pos, uint *endPos)\n{\n    Jsi_Obj *obj = Jsi_ObjNewType(interp, JSI_OT_OBJECT);\n    Jsi_Value *nv, *v = Jsi_ValueMakeObject(interp, NULL, obj);\n    uint i, n, len;\n    Jsi_JsonTok *tok;\n    const char *t;\n    tok = p->tokens+pos;\n    for (i=pos+1, n=0; i<p->toknext && n<tok->size; i++, n++) {\n\n        Jsi_DString dStr;\n        t = Jsi_JsonGetTokstr(p, js, i, &len);\n        i++; n++;\n        if (n>=tok->size)\n            nv = Jsi_ValueMakeUndef(interp, NULL);\n        else\n            nv = jsonGen1Value(interp, p, js, i, &i, 0);\n        Jsi_DSInit(&dStr);\n        Jsi_DSAppendLen(&dStr, t, len);\n        Jsi_ObjInsert(interp, obj, Jsi_DSValue(&dStr), nv, 0);\n        Jsi_DSFree(&dStr);\n    }\n    if (endPos)\n        *endPos = i;\n    return v;\n}\n\nstatic Jsi_Value*\njsonGenArray(Jsi_Interp *interp, Jsi_JsonParser *p, const char *js, uint pos, uint *endPos)\n{\n    if (js==NULL || !js[0])\n        return NULL;\n    Jsi_Value *v = Jsi_ValueNewArray(interp, 0, 0);\n    Jsi_Obj *nobj = v->d.obj;\n    uint i, n;\n    Jsi_JsonTok *tok;\n    \n    tok = p->tokens+pos;\n    Jsi_ValueMakeArrayObject(interp, &v, nobj);\n    for (i=pos+1, n=0; i<p->toknext && n<tok->size; i++, n++) {\n        if (n >= nobj->arrMaxSize) {\n            if (Jsi_ObjArraySizer(interp, nobj, n+1)<=0) {\n                break;\n            }\n        }\n        nobj->arr[n] = jsonGen1Value(interp, p, js, i, &i, 1);\n    }\n    Jsi_ObjSetLength(interp, nobj, n);\n    if (endPos)\n        *endPos = i;\n    return v;\n}\n\nJsi_RC Jsi_JSONParse(Jsi_Interp *interp, const char *js, Jsi_Value **ret, int flags)\n{\n    uint i = 0, r;\n    Jsi_RC result = JSI_OK;\n    int strict = (flags & JSI_JSON_STRICT);\n    Jsi_JsonTok *tok;\n    Jsi_Value *v;\n    const char *err;\n    Jsi_Number d;\n    if (js == NULL)\n        return JSI_OK;\n    while (isspace(*js))\n        js++;\n    if (js[0] == 0)\n        return JSI_OK;\n    switch (js[0]) {\n        case 't': if (Jsi_Strcmp(js,\"true\")==0) { if (ret) Jsi_ValueMakeBool(interp, ret, 1); return JSI_OK; } break;\n        case 'f': if (Jsi_Strcmp(js,\"false\")==0) { if (ret) Jsi_ValueMakeBool(interp, ret, 0); return JSI_OK; } break;\n        case 'n': if (Jsi_Strcmp(js,\"null\")==0) { if (ret) Jsi_ValueMakeNull(interp, ret); return JSI_OK; } break;\n        case '0': case '1': case '2': case '3': case '4': case '5': \n        case '6': case '7': case '8': case '9': case '-':\n            if (Jsi_GetDouble(interp, js, &d) == JSI_OK) { if (ret) Jsi_ValueMakeNumber(interp, ret, d); return JSI_OK; } break;\n    }\n    JSI_JSON_DECLARE(pp, tokens, 0);\n    Jsi_JsonParser *p = &pp;\n    pp.strict = strict;\n    pp.flags = flags;\n\n    r = Jsi_JsonParse(p, js);\n    if (r != JSI_JSON_ERR_NONE) {\n        int ofs = pp.pos, len = Jsi_Strlen(js);\n        if (ofs<0 || ofs>len)\n            ofs = 0;\n        err = p->errStr;\n        if (!err)\n            err = Jsi_JsonGetErrname(r);\n        if (interp)\n            Jsi_LogError(\"JSON parse error (%s) at offset %d \\\"%.30s\\\"\", err, ofs, js+ofs);\n        result = JSI_ERROR;\n        goto done;\n    }\n    if (!ret)\n        goto done;\n    tok = p->tokens;\n    if (tok->size<=0) {\n        if (!*ret)\n            *ret = Jsi_ValueNew1(interp);\n        if (tok->type == JSI_JTYPE_OBJECT)\n            Jsi_ValueMakeObject(interp, ret, Jsi_ObjNewObj(interp, NULL, 0));\n        else if (tok->type == JSI_JTYPE_ARRAY)\n            Jsi_ValueMakeArrayObject(interp, ret, Jsi_ObjNew(interp));\n        else\n            Jsi_ValueMakeUndef(interp, ret);\n        goto done;\n    }\n    v = jsonGen1Value(interp, p, js, i, &i, 1);\n    Jsi_ValueReplace(interp, ret, v);\n    Jsi_DecrRefCount(interp, v);\ndone:\n    Jsi_JsonFree(&pp);\n    return result;\n}\n\n// Perform an sprintf format, then return the JSON parsed results.\nJsi_RC Jsi_JSONParseFmt(Jsi_Interp *interp, Jsi_Value **ret, const char *fmt, ...) \n{\n    va_list argList;\n    uint n;\n    char buf[JSI_BUFSIZ], *cp = buf;\n    Jsi_DString dStr = {};\n    va_start(argList, fmt);\n    n = vsnprintf(buf, sizeof(buf), fmt, argList);\n    if (n>JSI_MAX_ALLOC_BUF) {\n        Jsi_LogError(\"Jsi_JSONParseFmt error: rc = %d\", n);\n        va_end(argList);\n        return JSI_ERROR;\n    }\n    if (n >= sizeof(buf)) {\n        uint m;\n        Jsi_DSSetLength(&dStr, n+1);\n        m = vsnprintf(Jsi_DSValue(&dStr), n+1, fmt, argList);\n        assert(m == n);\n        JSI_NOWARN(m);\n        cp = Jsi_DSValue(&dStr);\n    }\n    va_end(argList);\n    return Jsi_JSONParse(interp, cp, ret, 0);\n}\n\n// Process options from json string. Handles only primatives and string. Returns number of fields parsed.\nint Jsi_OptionsProcessJSON(Jsi_Interp *interp, Jsi_OptionSpec *opts, void *data, const char *json, Jsi_Wide flags)\n{\n    uint i = 0, r, len;\n    Jsi_RC rc = JSI_OK;\n    int result = 0;\n    int strict = (flags & JSI_JSON_STRICT);\n    Jsi_JsonTok *tok;\n    const char *err;\n    Jsi_Value *v = NULL;\n    Jsi_DString nStr;\n    const char *t, *name = NULL;\n    if (json == NULL)\n        return 0;\n    while (isspace(*json))\n        json++;\n    if (json[0] == 0)\n        return 0;\n        \n    JSI_JSON_DECLARE(pp, tokens, 0);\n    Jsi_JsonParser *p = &pp;\n    pp.strict = strict;\n    pp.flags = flags;\n\n    r = Jsi_JsonParse(p, json);\n    if (r != JSI_JSON_ERR_NONE) {\n        int ofs = pp.pos, len = Jsi_Strlen(json);\n        if (ofs<0 || ofs>len)\n            ofs = 0;\n        err = p->errStr;\n        if (!err)\n            err = Jsi_JsonGetErrname(r);\n        Jsi_LogError(\"JSON parse error (%s) at offset %d \\\"%.30s\\\"\", err, ofs, json+ofs);\n        result = -1;\n        goto done;\n    }\n    tok = p->tokens;\n    Jsi_DSInit(&nStr);\n    if (tok->size%2 || tok->type != JSI_JTYPE_OBJECT) {\n        result = -1;\n        goto done;\n    }\n    v = Jsi_ValueNew1(interp);\n    for (i=1; i<p->toknext && i<tok->size; i++) {\n        if (p->tokens[i].type != JSI_JTYPE_STRING) {\n            result = Jsi_LogError(\"expected string at %d\", i-1);\n            goto bail;\n        }\n        name = Jsi_JsonGetTokstr(p, json, i, &len);\n        Jsi_DSSetLength(&nStr, 0);\n        Jsi_DSAppendLen(&nStr, name, len);\n        name = Jsi_DSValue(&nStr);\n        i++;\n        switch (p->tokens[i].type) {\n            case JSI_JTYPE_PRIMITIVE:\n                t = Jsi_JsonGetTokstr(p, json, i, &len);\n                if ((len == 4 && Jsi_Strncmp(t, \"true\", len)==0) || (len == 5 && Jsi_Strncmp(t, \"false\", len)==0)) {\n                    Jsi_ValueMakeBool(interp, &v, (bool)(len==4?1:0));\n                } else if (len == 4 && Jsi_Strncmp(t, \"null\", len)==0) {\n                    Jsi_ValueMakeNull(interp, &v);\n                } else {\n                    char *ep;\n                    Jsi_Number d = strtod(t,&ep);\n                    if (ep>(t+len)) {\n                        result = Jsi_LogError(\"bad number %*s\", len, t);\n                        goto bail;\n                    }\n                    Jsi_ValueMakeNumber(interp, &v, d);\n                }\n                break;\n            case JSI_JTYPE_STRING:\n                t = Jsi_JsonGetTokstr(p, json, i, &len);\n                Jsi_DString dStr;\n                Jsi_DSInit(&dStr);\n                jsonNewDString(interp, &dStr, t, len);\n                Jsi_ValueMakeStringKey(interp, &v, Jsi_DSValue(&dStr));\n                Jsi_DSFree(&dStr);\n                break;\n            case JSI_JTYPE_ARRAY:\n            case JSI_JTYPE_OBJECT:\n            default:\n                result = -1;\n                goto bail;\n                break;\n        }\n        result++;\n        rc = Jsi_OptionsSet(interp, opts, data, name, v, 0);\n        if (rc == JSI_OK)\n            continue;\n\nbail:\n        Jsi_LogError(\"bad at field: %s\", name);\n        result = -1;\n        break;\n    }\n\ndone:\n    Jsi_DSFree(&nStr);\n    if (v)\n        Jsi_DecrRefCount(interp, v);\n    Jsi_JsonFree(&pp);\n    return result;\n}\n\nstatic Jsi_RC JSONParseCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    bool strict = 1;\n    Jsi_Value *jsv = Jsi_ValueArrayIndex(interp, args, 1);\n    if (jsv && Jsi_ValueGetBoolean(interp, jsv, &strict) != JSI_OK) \n        return Jsi_LogError(\"Expected boolean\");\n    jsv = Jsi_ValueArrayIndex(interp, args, 0); \n    const char *js = Jsi_ValueToString(interp, jsv, NULL);\n    return Jsi_JSONParse(interp, js, ret, strict);\n}\n\n\n\nstatic Jsi_RC JSONCheckCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n\n    int r;\n    Jsi_RC result = JSI_OK;\n    bool strict = 1;\n    const char *cp;\n    JSI_JSON_DECLARE(p, tokens, 0);\n    Jsi_Value *jsv = Jsi_ValueArrayIndex(interp, args, 1);\n    if (jsv && Jsi_ValueGetBoolean(interp, jsv, &strict) != JSI_OK) \n        return Jsi_LogError(\"Expected boolean\");\n    p.strict = strict;\n    jsv = Jsi_ValueArrayIndex(interp, args, 0);\n    cp = Jsi_ValueToString(interp, jsv, NULL);\n    \n    r = Jsi_JsonParse(&p, cp);\n    Jsi_ValueMakeBool(interp, ret, r == JSI_JSON_ERR_NONE);\n    Jsi_JsonFree(&p);\n    return result;\n}\n\n// Apply JSON quoting to str and append result to dsPtr.\nchar *\nJsi_JSONQuote(Jsi_Interp *interp, const char *str, int len, Jsi_DString *dsPtr)\n{\n    const char *cp = str;\n    int i = 0;\n    if (len<0)\n        len = Jsi_Strlen(str);\n    char cbuf[10];\n    Jsi_DSAppend(dsPtr,\"\\\"\",NULL);\n    while (*cp && i++<len) {\n        if (*cp == '\\\\' /* || *cp == '/' */ || *cp == '\\\"') {\n            cbuf[0] = '\\\\';\n            cbuf[1] = *cp;\n            cbuf[2] = 0;\n            Jsi_DSAppend(dsPtr,cbuf,NULL);\n        } else if (!isprint(*cp)) {\n            int ilen;\n            switch (*cp) {\n                case '\\b': Jsi_DSAppend(dsPtr,\"\\\\b\",NULL); break;\n                case '\\n': Jsi_DSAppend(dsPtr,\"\\\\n\",NULL); break;\n                case '\\r': Jsi_DSAppend(dsPtr,\"\\\\r\",NULL); break;\n                case '\\f': Jsi_DSAppend(dsPtr,\"\\\\f\",NULL); break;\n                case '\\t': Jsi_DSAppend(dsPtr,\"\\\\t\",NULL); break;\n                default:\n                    if ((ilen = Jsi_UtfEncode(cp, cbuf))) {\n                        Jsi_DSAppend(dsPtr,cbuf,NULL);\n                        cp += (ilen-1);\n                    }\n            }\n        } else {\n            cbuf[0] = *cp;\n            cbuf[1] = 0;\n            Jsi_DSAppend(dsPtr,cbuf,NULL);\n        }\n        cp++;\n    }\n    \n    Jsi_DSAppend(dsPtr,\"\\\"\", NULL);\n    return Jsi_DSValue(dsPtr);;\n}\n\nstatic Jsi_RC JSONStringifyCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    bool strict = 1;\n    Jsi_Value *jsv = Jsi_ValueArrayIndex(interp, args, 1);\n    if (jsv && Jsi_ValueGetBoolean(interp, jsv, &strict) != JSI_OK) \n        return Jsi_LogError(\"Expected boolean\");\n    int quote = JSI_OUTPUT_JSON;\n    if (strict) quote|=JSI_JSON_STRICT;\n    Jsi_DString dStr = {};\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_ValueGetDString(interp, arg, &dStr, quote);\n    Jsi_ValueFromDS(interp, &dStr, ret);\n    return JSI_OK;\n}\n\nJsi_RC Jsi_CommandInvoke(Jsi_Interp *interp, const char *cmdstr, Jsi_Value *args, Jsi_Value **ret)\n{\n    Jsi_Value *func = Jsi_NameLookup(interp, cmdstr);\n    if (func)\n        return Jsi_FunctionInvoke(interp, func, args, ret, NULL);\n    return Jsi_LogError(\"can not find cmd: %s\", cmdstr);\n}\n\nstatic Jsi_CmdSpec jsonCmds[] = {\n    { \"check\",      JSONCheckCmd,       1, 2, \"str:string, strict:boolean=true\", .help=\"Return true if str is JSON\", .retType=(uint)JSI_TT_BOOLEAN },\n    { \"parse\",      JSONParseCmd,       1, 2, \"str:string, strict:boolean=true\", .help=\"Parse JSON and return js\", .retType=(uint)JSI_TT_ANY },\n    { \"stringify\",  JSONStringifyCmd,   1, 2, \"value:any,  strict:boolean=true\", .help=\"Return JSON from a js object\", .retType=(uint)JSI_TT_STRING },\n    { NULL, 0,0,0,0, .help=\"Commands for handling JSON data\" }\n};\n\nJsi_RC jsi_InitJSON(Jsi_Interp *interp, int release) {\n    if (release) return JSI_OK;\n    Jsi_CommandCreateSpecs(interp, \"JSON\", jsonCmds, NULL, 0);\n#ifdef TEST_JSON_INVOKE\n    Jsi_Value *ret = Jsi_ValueNew1(interp);\n    Jsi_CommandInvokeJSON(interp, \"Info.cmds\", \"[\\\"*\\\", true]\", ret);\n    Jsi_DString dStr = {};\n    Jsi_Puts(NULL, Jsi_ValueGetDString(interp, ret, &dStr, 1), -1);\n    Jsi_DSFree(&dStr);\n    Jsi_DecrRefCount(interp, ret);\n#endif\n    return JSI_OK;\n}\n#endif\n", "#if JSI__MYSQL==1\n/* JSI Javascript Interface to MySql. */\n\ntypedef enum { MYSQL_SIG_DB = 0xbeefdeaa, MYSQL_SIG_FUNC, MYSQL_SIG_EXEC, MYSQL_SIG_STMT } MySql_Sig;\n\n#define SQLSIGASSERT(s,n) assert(s->sig == MYSQL_SIG_##n)\n#define SQLSIGINIT(s,n) s->sig = MYSQL_SIG_##n\n\n#ifndef NDEBUG\n#ifndef _JSI_MEMCLEAR\n#define _JSI_MEMCLEAR(s) memset(s, 0, sizeof(*s));\n#endif\n#else\n#define _JSI_MEMCLEAR(s)\n#endif\n#ifndef JSI_DB_DSTRING_SIZE\n#define JSI_DB_DSTRING_SIZE 2000\n#endif\n\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <mysql/mysql.h>\n#include <mysql/my_config.h>\n\n#if JSI__MEMDEBUG\n#include \"jsiInt.h\"\n#else\n#include \"jsi.h\"\nJSI_EXTENSION_INI\n#endif\n\n#ifndef NUM_PREPARED_STMTS\n#define NUM_PREPARED_STMTS 100\n#endif\n#ifndef MAX_PREPARED_STMTS\n#define MAX_PREPARED_STMTS 10000\n#endif\n\n#ifndef JSI_DBQUERY_PRINTF\n#define JSI_DBQUERY_PRINTF(fmt, ...) fprintf(stderr, fmt, ##__VA_ARGS__)\n#endif\n\ntypedef struct mydb_ObjCmd {\n    int init;\n    int activeCnt;  /* Count of active objects. */ \n    int newCnt;  /* Total number of new. */ \n} mydb_ObjCmd;\n\nstatic mydb_ObjCmd mydbObjCmd = {};\n\nstatic Jsi_OptionSpec mydb_ObjCmd_Specs[] =\n{\n    JSI_OPT(INT,   mydb_ObjCmd, init, .help=\"Init counter\"),\n    JSI_OPT(INT,   mydb_ObjCmd, activeCnt, .help=\"Number of active objects\"),\n    JSI_OPT(INT,   mydb_ObjCmd, newCnt,    .help=\"Number of new calls\"),\n    JSI_OPT_END(mydb_ObjCmd, .help=\"Options for Sqlite module\")\n};\n\n/*\n** New SQL functions can be created as JSI scripts.  Each such function\n** is described by an instance of the following structure.\n*/\ntypedef struct SqlFunc SqlFunc;\nstruct SqlFunc {\n    MySql_Sig sig;\n    Jsi_Interp  *interp;    /* The JSI interpret to execute the function */\n    Jsi_Value   *tocall;    /* Callee */\n    char        *pScript;   /* The char* representation of the script */\n    Jsi_DString dScript;\n    char        *zName;     /* Name of this function */\n    SqlFunc     *pNext;     /* Next function on the list of them all */\n};\n\n/*\n** New collation sequences function can be created as JSI scripts.  Each such\n** function is described by an instance of the following structure.\n*/\ntypedef struct SqlCollate SqlCollate;\nstruct SqlCollate {\n    MySql_Sig sig;\n    Jsi_Interp  *interp;   /* The JSI interpret to execute the function */\n    Jsi_Value   *zScript;  /* The function to be run */\n    SqlCollate  *pNext;    /* Next function on the list of them all */\n};\n\ntypedef struct SqlFieldResults {\n    MYSQL_FIELD *field;\n    my_bool isnull;\n    unsigned long len;\n    int vsize;\n    enum enum_field_types mapType; // Maps to one of DOUBLE, BOOL, VARCHAR or TIMESTAMP\n    Jsi_OptionId jsiTypeMap;  // Type of data for Jsi.\n    union { // Space for data.\n        char vchar;\n        double vdouble;  // Must convert if Jsi_Number is a long double.\n        long long vlonglong;\n        my_bool vbool;\n        char *vstring;\n        MYSQL_TIME timestamp;\n    } buffer;\n} SqlFieldResults;\n\n/*\n    result_bind[0].buffer_type = MYSQL_TYPE_LONG;\n    result_bind[0].buffer = &result_int;\n    result_bind[0].buffer_length = sizeof(result_int);\n    result_bind[0].length = &result_len;\n    result_bind[0].is_null = &result_is_null[0];\n*/\n\n/*\n** Prepared statements are cached for faster execution.  Each prepared\n** statement is described by an instance of the following structure.\n*/\ntypedef struct MysqlPrep MysqlPrep;\nstruct MysqlPrep {\n    MySql_Sig sig;\n    int deleting;\n    MysqlPrep *pNext;  /* Next in linked list */\n    MysqlPrep *pPrev;  /* Previous on the list */\n    MYSQL_STMT    *myStmt;  /* The prepared statement */\n    MYSQL_RES     *resultMetaData;\n    MYSQL_RES     *paramMetaData;\n    MYSQL_BIND    *bindParam;\n    MYSQL_BIND    *bindResult;\n    SqlFieldResults *fieldResult;\n    SqlFieldResults *fieldParam;\n    //int resultColumns, paramCount;\n    uint nSql;                /* chars in zSql[] */\n    char *zSql;        /* Text of the SQL statement */\n    const char *zRawSql;     /* SQL before named params extracted. */\n    \n    int numParam; // Count of input params.\n    int numCol; // Count of columns in results\n    Jsi_HashEntry *entry;\n    Jsi_ListEntry *elPtr;\n    char **colNames;       /* List of column names. */\n    Jsi_OptionId *colTypes;\n    // Following used by named params.\n    char *origSql;\n    char **paramNames;       /* List of param names. */\n    int *paramMyTypes;\n    int paramCnt;\n    Jsi_DString *naStr;\n};\n\nstatic const char *myexecFmtStrs[] = {\n    \"rows\", \"arrays\", \"array1d\", \"list\", \"column\", \"json\",\n    \"json2\", \"html\", \"csv\", \"insert\", \"line\", \"tabs\", \"none\", NULL\n};\n\ntypedef enum {\n    _mdb_EF_ROWS, _mdb_EF_ARRAYS, _mdb_EF_ARRAY1D, _mdb_EF_LIST, _mdb_EF_COLUMN, _mdb_EF_JSON,\n    _mdb_EF_JSON2, _mdb_EF_HTML, _mdb_EF_CSV, _mdb_EF_INSERT, _mdb_EF_LINE, _mdb_EF_TABS, _mdb_EF_NONE\n} mdbOutput_Mode;\n\n\nconst char *mdbTypeChkStrs[] = { \"convert\", \"error\", \"warn\", \"disable\", NULL };\n\ntypedef enum { mdbTypeCheck_Cast, mdbTypeCheck_Error, mdbTypeCheck_Warn,  mdbTypeCheck_None } mdbTypeCheck_Mode;\n\ntypedef struct QueryOpts {\n    MySql_Sig sig;\n    Jsi_Value *callback, *values;\n    Jsi_Value *paramVar;\n    int limit, objOpts;\n    mdbOutput_Mode mode;\n    mdbTypeCheck_Mode typeCheck;\n    bool mapundef, nocache, headers, noNamedParams, prefetch;\n    const char *separator;\n    const char *nullvalue;\n    const char *table;\n    //const char *CData; // Name of cdata to use for query.\n    const char* objName;\n    Jsi_Value *width;\n    int maxString;\n} QueryOpts;\n\nstatic const char *trcModeStrs[] = {\"eval\", \"delete\", \"prepare\", \"step\", NULL}; // Bit-set packed into an int.\nstatic const char *objSqlModeStrs[] = { \"getSql\", \"noTypes\", \"noDefaults\", \"nullDefaults\", NULL };\nenum {mdbTMODE_EVAL=0x1, mdbTMODE_DELETE=0x2, mdbTMODE_PREPARE=0x4, mdbTMODE_STEP=0x4};\nenum {OBJMODE_SQLONLY=0x1, OBJMODE_NOTYPES=0x2, OBJMODE_NODEFAULTS=0x4, OBJMODE_NULLDEFAULTS=0x8};\n\n\ntypedef struct MySqlObj {\n    MySql_Sig sig;\n    MYSQL  *db;               /* The \"real\" database structure. MUST BE FIRST */\n    Jsi_Interp *interp;        /* The interpreter used for this database */\n    mydb_ObjCmd *_;\n    Jsi_Value *host;\n    const char *user;\n    const char *password;\n    const char *database;\n    int port;\n    char *zNull;               /* Text to substitute for an SQL NULL value */\n    SqlFunc *pFunc;            /* List of SQL functions */\n    int rc;                    /* Return code of most recent mysql_exec() */\n    Jsi_List *stmtCache;\n//    MysqlPrep *stmtList; /* List of prepared statements*/\n//    MysqlPrep *stmtLast; /* Last statement in the list */\n    Jsi_Hash *stmtHash;        /* Hash table for statements. */\n    int maxStmts;               /* The next maximum number of stmtList */\n    int numStmts;                 /* Number of statements in stmtList */\n    bool bindWarn, forceInt, reconnect, enableMulti;\n    int nStep, nSort;          /* Statistics for most recent operation */\n    int nTransaction;          /* Number of nested [transaction] methods */\n    int errorCnt;               /* Count of errors. */\n    Jsi_Value *key;             /* Key, for codec. */\n    int hasOpts;\n    Jsi_Obj *userObjPtr;\n    QueryOpts queryOpts, *optPtr;\n    int objId;\n    int debug;\n    int deleted;\n    Jsi_Event *event;\n    //int trace;\n    Jsi_DString name;\n    int last_errno;\n    Jsi_Number version;\n    int dbflags;\n    Jsi_Value* udata;\n    Jsi_Value *sslKey, *sslCert, *sslCA, *sslCAPath, *sslCipher;\n    Jsi_Hash *typeNameHash;\n} MySqlObj;\n\ntypedef struct MyDbEvalContext {\n    MySqlObj *jdb;                /* Database handle */\n    Jsi_DString *dzSql;               /* Object holding string zSql */\n    const char *zSql;               /* Remaining SQL to execute */\n    MysqlPrep *prep;      /* Current statement */\n    int nCol;                       /* Number of columns returned by pStmt */\n    Jsi_Value *tocall;\n    Jsi_Value *ret;\n    /*OBS */\n    Jsi_Value *pArray;              /* Name of array variable */\n    Jsi_Value *pValVar;             /* Name of list for values. */\n    int nocache;\n    int namedParams;\n} MyDbEvalContext;\n\nstatic Jsi_RC mdbIsNumArray(Jsi_Interp *interp, Jsi_Value *value);\nstatic Jsi_RC mdbPrepareAndBind(MyDbEvalContext *p );\nstatic void mdbReleaseStmt( MySqlObj *jdb, MysqlPrep *prep, int discard );\n\nvoid mdbTypeNameHashInit(MySqlObj *jdb) {\n    Jsi_Interp *interp = jdb->interp;\n    Jsi_Hash *hPtr = jdb->typeNameHash = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);\n    Jsi_HashSet(hPtr, (void*)\"string\", (void*)MYSQL_TYPE_STRING);\n    Jsi_HashSet(hPtr, (void*)\"double\", (void*)MYSQL_TYPE_DOUBLE);\n    Jsi_HashSet(hPtr, (void*)\"integer\", (void*)MYSQL_TYPE_LONGLONG);\n    Jsi_HashSet(hPtr, (void*)\"bool\", (void*)MYSQL_TYPE_TINY);\n    Jsi_HashSet(hPtr, (void*)\"blob\", (void*)MYSQL_TYPE_BLOB);\n    Jsi_HashSet(hPtr, (void*)\"date\", (void*)MYSQL_TYPE_DATE);\n    Jsi_HashSet(hPtr, (void*)\"time\", (void*)MYSQL_TYPE_TIME);\n    Jsi_HashSet(hPtr, (void*)\"timestamp\", (void*)MYSQL_TYPE_TIMESTAMP);\n    Jsi_HashSet(hPtr, (void*)\"datetime\", (void*)MYSQL_TYPE_DATETIME);\n}\n\nstatic Jsi_OptionSpec QueryFmtOptions[] =\n{\n    JSI_OPT(FUNC,   QueryOpts, callback, .help=\"Function to call with each row result\", .flags=0, .custom=0, .data=(void*)\"values:object\" ),\n    JSI_OPT(BOOL,   QueryOpts, headers, .help=\"First row returned contains column labels\"),\n    JSI_OPT(INT,    QueryOpts, limit, .help=\"Maximum number of returned values\"),\n    JSI_OPT(BOOL,   QueryOpts, mapundef, .help=\"In variable binds, map an 'undefined' var to null\"),\n    JSI_OPT(INT,    QueryOpts, maxString, .help=\"If not using prefetch, the maximum string value size (0=8K)\"),\n    JSI_OPT(CUSTOM, QueryOpts, mode, .help=\"Set output mode of returned data\", .flags=0, .custom=Jsi_Opt_SwitchEnum,  .data=myexecFmtStrs),\n    JSI_OPT(BOOL,   QueryOpts, nocache, .help=\"Disable query cache\"),\n    JSI_OPT(BOOL,   QueryOpts, noNamedParams, .help=\"Disable translating sql to support named params\"),\n    JSI_OPT(STRKEY, QueryOpts, nullvalue, .help=\"Null string output (for non-json mode)\"),\n    JSI_OPT(STRKEY, QueryOpts, objName,  .help=\"Object var name for CREATE/INSERT: replaces %s with fields in query\" ),\n    JSI_OPT(CUSTOM, QueryOpts, objOpts,     .help=\"Options for objName\", .flags=0,  .custom=Jsi_Opt_SwitchBitset,  .data=objSqlModeStrs),\n    JSI_OPT(ARRAY,  QueryOpts, paramVar, .help=\"Array var to use for parameters\" ),\n    JSI_OPT(BOOL,   QueryOpts, prefetch, .help=\"Let client library cache entire results\"),\n    JSI_OPT(STRKEY, QueryOpts, separator, .help=\"Separator string (for csv and text mode)\"),\n    //JSI_OPT(STRKEY, QueryOpts, CData, .help=\"Name of CData object to use\"),\n    JSI_OPT(STRKEY, QueryOpts, table, .help=\"Table name for mode=insert\"),\n    JSI_OPT(CUSTOM, QueryOpts, typeCheck,   .help=\"Type check mode (error)\", .flags=0, .custom=Jsi_Opt_SwitchEnum, .data=mdbTypeChkStrs),\n    JSI_OPT(ARRAY,  QueryOpts, values, .help=\"Values for ? bind parameters\" ),\n    JSI_OPT(CUSTOM, QueryOpts, width, .help=\"In column mode, set column widths\", .flags=0, .custom=Jsi_Opt_SwitchValueVerify, .data=(void*)mdbIsNumArray),\n    JSI_OPT_END(QueryOpts, .help=\"MySql query options\")\n};\n\n\n#ifndef jsi_IIOF\n#define jsi_IIOF .flags=JSI_OPT_INIT_ONLY\n#define jsi_IIRO .flags=JSI_OPT_READ_ONLY\n#endif\nstatic Jsi_OptionSpec SqlOptions[] =\n{\n    JSI_OPT(BOOL,   MySqlObj, bindWarn, .help=\"Treat failed variable binds as a warning\", jsi_IIOF),\n    JSI_OPT(STRKEY, MySqlObj, database, .help=\"Database to use\", jsi_IIOF ),\n    JSI_OPT(CUSTOM, MySqlObj, debug,    .help=\"Enable debug trace for various operations\", .flags=0, .custom=Jsi_Opt_SwitchBitset,  .data=trcModeStrs),\n    JSI_OPT(BOOL,   MySqlObj, enableMulti,.help=\"Accept muiltiple semi-colon separated statements in eval()\", jsi_IIOF),\n    JSI_OPT(INT,    MySqlObj, errorCnt, .help=\"Count of errors\", .flags=JSI_OPT_READ_ONLY),\n    JSI_OPT(CUSTOM, MySqlObj, queryOpts, .help=\"Default options for exec\", .flags=0, .custom=Jsi_Opt_SwitchSuboption, .data=QueryFmtOptions),\n    JSI_OPT(BOOL,   MySqlObj, forceInt, .help=\"Bind float as int if possible\"),\n    JSI_OPT(STRING, MySqlObj, host,     .help=\"IP address or host name for mysqld (default is 127.0.0.1)\"),\n    JSI_OPT(INT,    MySqlObj, maxStmts, .help=\"Max cache size for compiled statements\"),\n    JSI_OPT(DSTRING,MySqlObj, name,     .help=\"Name for this db handle\"),\n    JSI_OPT(INT,    MySqlObj, numStmts, .help=\"Current size of compiled statement cache\", .flags=JSI_OPT_READ_ONLY),\n    JSI_OPT(STRKEY, MySqlObj, password, .help=\"Database password.\", jsi_IIOF ),\n    JSI_OPT(INT,    MySqlObj, port,     .help=\"IP port for mysqld\", jsi_IIOF),\n    JSI_OPT(BOOL,   MySqlObj, reconnect, .help=\"Reconnect\"),\n    JSI_OPT(STRING, MySqlObj, sslKey, .help=\"SSL key\"),\n    JSI_OPT(STRING, MySqlObj, sslCert, .help=\"SSL Cert\"),\n    JSI_OPT(STRING, MySqlObj, sslCA, .help=\"SSL CA\"),\n    JSI_OPT(STRING, MySqlObj, sslCAPath, .help=\"SSL CA path\"),\n    JSI_OPT(STRING, MySqlObj, sslCipher, .help=\"SSL Cipher\"),\n    JSI_OPT(OBJ,    MySqlObj, udata,    .help=\"User data.\" ),\n    JSI_OPT(STRKEY, MySqlObj, user,     .help=\"Database user name. Default is current user-name.\", jsi_IIOF ),\n    JSI_OPT(DOUBLE, MySqlObj, version,  .help=\"Mysql version number\", .flags=JSI_OPT_READ_ONLY),\n    JSI_OPT_END(MySqlObj, .help=\"MySql options\")\n};\n\n/* Start of code. */\n\n// Convert MySql time to JS unix time in ms. TODO: handle \"neg\" and years outside of unix time.\nstatic Jsi_Number mdbMyTimeToJS(MYSQL_TIME* mtm)\n{\n    struct tm tm;\n    tm.tm_sec = mtm->second;\n    tm.tm_min = mtm->minute;\n    tm.tm_hour = mtm->hour;\n    tm.tm_mday = mtm->day;\n    tm.tm_mon = mtm->month-1;\n    tm.tm_year = mtm->year - 1900;\n    time_t tim = mktime(&tm);\n    if (tim == (time_t)-1)\n        return -1;\n    return (Jsi_Number)tim*1000 + (Jsi_Number)mtm->second_part/1000000.0;\n}\n\nstatic void mdbJsToMyTime(Jsi_Number time, MYSQL_TIME* mtm, int utc)\n{\n    struct tm tm;\n    time_t tim = (time_t)(time/1000);\n    if (utc)\n        gmtime_r(&tim, &tm);\n    else\n        localtime_r(&tim, &tm);\n    mtm->second = tm.tm_sec;\n    mtm->minute = tm.tm_min;\n    mtm->hour = tm.tm_hour;\n    mtm->day = tm.tm_mday;\n    mtm->month = tm.tm_mon+1;\n    mtm->year = tm.tm_year + 1900;\n    Jsi_Number secs = (tim/1000.0);\n    mtm->second_part = (int)((secs-(int)secs)*1000000);\n}\n\nstatic Jsi_RC mdbEvalInit(\n    Jsi_Interp *interp,\n    MyDbEvalContext *p,               /* Pointer to structure to initialize */\n    MySqlObj *jdb,                  /* Database handle */\n    const char* zSql,                /* Value containing SQL script */\n    Jsi_DString *dStr,\n    Jsi_Obj *pArray,                /* Name of Jsi array to set (*) element of */\n    Jsi_Obj *pValVar                  /* Name element in array for list. */\n) {\n    p->dzSql = dStr;\n    p->zSql = Jsi_DSAppend(p->dzSql, zSql?zSql:\"\", NULL);\n    p->jdb = jdb;\n    return JSI_OK;\n}\n\nstatic void mdbEvalFinalize(MyDbEvalContext *p) {\n    if( p->prep) {\n        mdbReleaseStmt(p->jdb, p->prep, p->nocache);\n        p->prep = 0;\n    }\n    Jsi_DSFree(p->dzSql);\n}\n\nstatic void mdbEvalRowInfo( MyDbEvalContext *eval, int *pnCol, char ***papColName, Jsi_OptionId **papColType) {\n    if (!papColName) {\n        //TODO: Array ???\n    }\n    *papColName = eval->prep->colNames;\n    *papColType = eval->prep->colTypes;\n    *pnCol = eval->prep->numCol;\n}\n\n/* Step statement. Return JSI_OK if there is a ROW result, JSI_BREAK if done, else JSI_ERROR. */\nstatic Jsi_RC mdbEvalStepSub(MyDbEvalContext *eval, int release, int *erc) {\n    MySqlObj *jdb = eval->jdb;\n    Jsi_Interp *interp = jdb->interp;\n    MysqlPrep *prep = eval->prep;\n    SQLSIGASSERT(prep, STMT);\n    MYSQL_STMT *myStmt = prep->myStmt;\n\n    if (jdb->debug & mdbTMODE_STEP)\n        JSI_DBQUERY_PRINTF( \"DEBUG: step: %s\\n\", prep->zSql);\n    int m = mysql_stmt_fetch(myStmt);\n    if (m == MYSQL_NO_DATA)\n        return JSI_BREAK;\n    if (m) \n        return Jsi_LogError(\"fetch failed: %s\", mysql_error(jdb->db));\n    return JSI_OK;\n#if 0\n    if( eval->pArray ) {\n        mdbEvalRowInfo(eval, 0, 0, 0);\n    }\n    if (release==0)\n        return JSI_BREAK;\n    eval->prep = 0;\n    return JSI_OK;\n#endif\n}\n\nstatic void mdbRelease1Stmt( MySqlObj *jdb, MysqlPrep *prep ) {\n    // TODO: split out parts reusable by cached query.\n    int i;\n    if (prep->deleting)\n        return;\n    prep->deleting = 1;\n    if (prep->myStmt)\n        mysql_stmt_close(prep->myStmt);\n    if (prep->resultMetaData)\n        mysql_free_result(prep->resultMetaData);\n    if (prep->paramMetaData)\n        mysql_free_result(prep->paramMetaData);\n    if (prep->bindParam)\n        Jsi_Free(prep->bindParam);\n    if (prep->fieldParam)\n        Jsi_Free(prep->fieldParam);\n    if (prep->bindResult) {\n        for (i=0; i<prep->numCol; i++) {\n            MYSQL_BIND *bind = prep->bindResult+i;\n            if (bind->buffer_type == MYSQL_TYPE_STRING && bind->buffer)\n                Jsi_Free(bind->buffer);\n        }\n        Jsi_Free(prep->bindResult);\n    }\n    if (prep->fieldResult)\n        Jsi_Free(prep->fieldResult);\n    if (prep->colTypes)\n        Jsi_Free(prep->colTypes);\n    if (prep->colNames)\n        Jsi_Free(prep->colNames);\n    if (prep->zSql)\n        Jsi_Free(prep->zSql);\n    if (prep->naStr) {\n        Jsi_Free(prep->origSql);\n        Jsi_DSFree(prep->naStr);\n        Jsi_Free(prep->naStr);\n    }\n    if (prep->entry)\n        Jsi_HashEntryDelete(prep->entry);\n    if (prep->elPtr) {\n        Jsi_ListEntry *pPtr = prep->elPtr;\n        prep->elPtr = NULL;\n        Jsi_ListEntryDelete(pPtr);\n    }\n    Jsi_Free(prep);\n    jdb->numStmts--;\n}\n\n\nstatic Jsi_RC mdbStmtFreeProc(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *value) {\n    MySqlObj *jdb = (MySqlObj*)interp;\n    Jsi_ListEntry *l = (Jsi_ListEntry*)hPtr;\n    mdbRelease1Stmt(jdb, (MysqlPrep*)Jsi_ListValueGet(l));\n    return JSI_OK;\n}\n\nstatic void mdbStmtLimit( MySqlObj *jdb)\n{\n    while(jdb->numStmts>jdb->maxStmts ) {\n        Jsi_ListEntry *l = Jsi_ListPopBack(jdb->stmtCache);\n        mdbRelease1Stmt(jdb, (MysqlPrep*)Jsi_ListValueGet(l));\n        jdb->numStmts = Jsi_ListSize(jdb->stmtCache);\n    }\n}\n\n/*\n** Finalize and free a list of prepared statements\n*/\nstatic void mdbFlushStmtCache( MySqlObj *jdb ) {\n    Jsi_ListClear(jdb->stmtCache);\n    jdb->numStmts = 0;\n}\n\n/*\n** Release a statement reference obtained by calling mdbPrepareAndBind().\n** There should be exactly one call to this function for each call to\n** mdbPrepareAndBind().\n**\n** If the discard parameter is non-zero, then the statement is deleted\n** immediately. Otherwise it is added to the LRU list and may be returned\n** by a subsequent call to mdbPrepareAndBind().\n*/\nstatic void mdbReleaseStmt( MySqlObj *jdb, MysqlPrep *prep, int discard ) {\n    if( jdb->maxStmts<=0 || discard ) {\n        /* If the cache is turned off, deallocated the statement */\n        mdbRelease1Stmt(jdb, prep);\n    } else {\n        /* Add the prepared statement to the beginning of the cache list. */\n        if (!prep->elPtr)\n            prep->elPtr = Jsi_ListPushFrontNew(jdb->stmtCache, prep);\n        else\n            Jsi_ListPushFront(jdb->stmtCache, prep->elPtr);\n        mdbStmtLimit(jdb);\n    }\n}\n\nlong long mdbLastInsertRowid(MySqlObj* jdb)\n{\n    return mysql_insert_id(jdb->db);\n}\n\n\nstatic const char *mdbFindEndStr(const char *cp) {\n    const char endc = *cp;\n    cp++;\n    while (*cp && *cp != endc) {\n        if (*cp == '\\\\' && cp[1]) cp++;\n        cp++;\n    }\n    if (*cp != endc)\n        return NULL;\n    return ++cp;\n}\n// Collect named parameters and translate Sql to use ?\nstatic Jsi_RC MySqlExtractParmNames(MySqlObj* jdb, const char *sql, Jsi_DString *sStr, Jsi_DString *nStr) {\n    const char *ocp, *cp = sql;\n    int cnt = 0;\n    while (*cp) {\n        if (*cp == '\\\"'||*cp == '\\'') {\n            ocp = cp;\n            cp = mdbFindEndStr(cp);\n            if (!cp)\n                return JSI_ERROR;\n            Jsi_DSAppendLen(sStr, ocp, cp-ocp+1);\n        } else if ((*cp == '@' || *cp == ':' || *cp == '$' ) && (isalpha(cp[1]) || cp[1] == '_')) {\n            ocp = cp;\n            cp+=2;\n            while (*cp && (isalnum(*cp) || *cp == '_'))\n                cp++;\n            if (*ocp == '$' && *cp == '(') {\n                const char *ttp = NULL, *ttb = NULL, *eq = NULL;\n                cp++;\n                if (*cp == '[')\n                    eq = cp++;\n                while (*cp && (isalnum(*cp) || *cp == '_' || *cp == ':' || *cp == '.' || *cp == ']')) {\n                    if (*cp == ':') {\n                        if (ttp)\n                            return JSI_ERROR;\n                        ttp = cp;\n                    }\n                    if (*cp == ']') {\n                        if (ttb)\n                            return JSI_ERROR;\n                        ttb = cp;\n                        if (cp[1] != ')' && cp[1] != ':' && cp[1] != '.')\n                            return JSI_ERROR;\n                    }\n                    cp++;\n                }\n                if (*cp != ')')\n                    return JSI_ERROR;\n                if (eq && !ttb)\n                    return JSI_ERROR;\n                if (ttp) {\n                    Jsi_DString tStr = {};\n                    Jsi_DSAppendLen(&tStr, ttp+1, (cp - ttp - 1));\n                    if (!jdb->typeNameHash) mdbTypeNameHashInit(jdb);\n                    int rc = (Jsi_HashEntryFind(jdb->typeNameHash, Jsi_DSValue(&tStr)) != NULL);\n                    if (!rc) {\n                        Jsi_DString eStr = {};\n                        Jsi_HashEntry *hPtr;\n                        Jsi_HashSearch search;\n                        Jsi_Interp *interp = jdb->interp;\n                        int n = 0;\n                        for (hPtr = Jsi_HashSearchFirst(jdb->typeNameHash, &search);\n                            hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {\n                            const char *key = (char*)Jsi_HashKeyGet(hPtr);\n                            Jsi_DSAppend(&eStr, (n++?\", \":\"\"), key, NULL);\n                        }\n                        Jsi_LogWarn(\"bind type \\\"%s\\\" is not one of: %s\", Jsi_DSValue(&tStr), Jsi_DSValue(&eStr));\n                        Jsi_DSFree(&eStr);\n                    }\n                    Jsi_DSFree(&tStr);\n                    if (!rc)\n                        return JSI_ERROR;\n                }\n            } else\n                cp--;\n            if (cnt++)\n                Jsi_DSAppendLen(nStr, \" \", 1);\n            Jsi_DSAppendLen(nStr, ocp, cp-ocp+1);\n            Jsi_DSAppendLen(sStr, \"?\", 1);\n        } else if (*cp == '\\\\' && cp[1]) {\n            Jsi_DSAppendLen(sStr, cp, 2);\n            cp++;\n        } else {\n            Jsi_DSAppendLen(sStr, cp, 1);\n        }\n        cp++;\n    }\n    return JSI_OK;\n}\n\n/*\n** Search the cache for a prepared-statement object that implements the\n** first SQL statement in the buffer pointed to by parameter zIn. If\n** no such prepared-statement can be found, allocate and prepare a new\n** one. In either case, bind the current values of the relevant Jsi\n** variables to any $var, :var or @var variables in the statement. Before\n** returning, set *ppPreStmt to point to the prepared-statement object.\n**\n** Output parameter *pzOut is set to point to the next SQL statement in\n** buffer zIn, or to the '\\0' byte at the end of zIn if there is no\n** next statement.\n**\n** If successful, JSI_OK is returned. Otherwise, JSI_ERROR is returned\n** and an error message loaded into interpreter jdb->interp.\n*/\nstatic Jsi_RC mdbPrepareStmt(MyDbEvalContext *p)\n{\n    MySqlObj *jdb = p->jdb;\n    //int namedParams = !jdb->optPtr->noNamedParams;\n    const char *zSql = p->zSql;         /* Pointer to first SQL statement in zIn */\n    MYSQL_STMT *myStmt;            /* Prepared statement object */\n    MysqlPrep *prep = 0;  /* Pointer to cached statement */\n    Jsi_RC rc = JSI_OK;\n    Jsi_Interp *interp = jdb->interp;\n\n\n    Jsi_HashEntry *entry = Jsi_HashEntryFind(jdb->stmtHash, zSql);\n    if (entry && ((prep = (MysqlPrep*)Jsi_HashValueGet(entry)))) {\n        \n        if (jdb->debug & mdbTMODE_PREPARE)\n            JSI_DBQUERY_PRINTF( \"DEBUG: prepare cache-hit: %s\\n\", zSql);\n        myStmt = prep->myStmt;\n\n        /* When a prepared statement is found, unlink it from the\n        ** cache list.  It will later be added back to the beginning\n        ** of the cache list in order to implement LRU replacement.\n        */\n        Jsi_ListPop(jdb->stmtCache, prep->elPtr);\n        jdb->numStmts = Jsi_ListSize(jdb->stmtCache);\n        \n        // Sanity check for schema check: right now we just use number of columns\n        if (prep->numCol != (int)mysql_stmt_field_count(prep->myStmt)) {\n            mdbRelease1Stmt(jdb, prep);\n            prep = NULL;\n        }\n    }\n    \n    /* If no prepared statement was found. Compile the SQL text. Also allocate\n    ** a new MysqlPrep structure.  */\n    if (!prep) {\n        myStmt = mysql_stmt_init(jdb->db);\n        if (!myStmt) \n            return Jsi_LogError(\"can't get statement: %s\", mysql_error(jdb->db));\n        char **paramNames;\n        int paramCnt;\n        int namedParams = 0;\n        Jsi_DString *naStr = NULL;\n        if (p->namedParams)\n        {\n            Jsi_RC rc = JSI_OK;\n            Jsi_DString nsStr, nnStr;\n            Jsi_DSInit(&nsStr);\n            Jsi_DSInit(&nnStr);\n            if (MySqlExtractParmNames(jdb, zSql, &nsStr, &nnStr) != JSI_OK)\n                rc = Jsi_LogError(\"parsing names from query: %s\", zSql);\n            else if (Jsi_DSLength(&nnStr)) {\n                namedParams = 1;\n                zSql = Jsi_DSFreeDup(&nsStr);\n                naStr = (Jsi_DString*)Jsi_Calloc(1, sizeof(*naStr));\n                Jsi_SplitStr(Jsi_DSValue(&nnStr), &paramCnt, &paramNames, \" \", naStr);\n            }\n            Jsi_DSFree(&nsStr);\n            Jsi_DSFree(&nnStr);\n            if (rc != JSI_OK)\n                return rc;\n        }\n\n        if (mysql_stmt_prepare(myStmt, zSql, Jsi_Strlen(zSql)) )\n        {\n            Jsi_LogError(\"error in sql: %s\", mysql_error(jdb->db));\n            mysql_stmt_close(myStmt);\n            if (namedParams) {\n                Jsi_DSFree(naStr);\n                Jsi_Free(naStr);\n                Jsi_Free((char*)zSql);\n            }\n            return JSI_ERROR;\n        }\n\n        if (jdb->debug & mdbTMODE_PREPARE)\n            JSI_DBQUERY_PRINTF( \"DEBUG: prepare new: %s\\n\", zSql);\n        assert( prep==0 );\n        prep = (MysqlPrep*)Jsi_Calloc(1, sizeof(MysqlPrep));\n        jdb->numStmts++;\n        prep->sig = MYSQL_SIG_STMT;\n        prep->myStmt = myStmt;\n        if (!namedParams)\n            prep->zSql = Jsi_Strdup(zSql);\n        else {\n            prep->zSql = (char*)zSql;\n            prep->origSql = Jsi_Strdup(p->zSql);\n            prep->naStr = naStr;\n            prep->paramCnt = paramCnt;\n            prep->paramNames = paramNames;\n        }\n        prep->paramMetaData = mysql_stmt_param_metadata(myStmt);\n        prep->resultMetaData = mysql_stmt_result_metadata(myStmt);\n        prep->numCol = mysql_stmt_field_count(myStmt);\n        if (prep->numCol>0)\n            prep->bindResult = (MYSQL_BIND *)Jsi_Calloc(prep->numCol, sizeof(MYSQL_BIND));\n        prep->numParam = mysql_stmt_param_count(myStmt);\n        if (prep->numParam>0 && !prep->bindParam) {\n            prep->bindParam = (MYSQL_BIND *)Jsi_Calloc(prep->numParam, sizeof(MYSQL_BIND));\n            prep->fieldParam = (SqlFieldResults*)Jsi_Calloc(prep->numParam, sizeof(*prep->fieldParam));\n        }\n        bool isNew = 0;\n        prep->entry = Jsi_HashEntryNew(jdb->stmtHash, p->zSql, &isNew);\n        if (!isNew)\n            JSI_DBQUERY_PRINTF( \"mysql dup stmt entry\");\n        Jsi_HashValueSet(prep->entry, prep);\n    }\n    p->prep = prep;\n    return rc;\n}\n\n/*\n** Return one of JSI_OK, JSI_BREAK or JSI_ERROR. If JSI_ERROR is\n** returned, then an error message is stored in the interpreter before\n** returning.\n**\n** A return value of JSI_OK means there is a row of data available. The\n** data may be accessed using mdbEvalRowInfo() and dbEvalColumnValue(). This\n** is analogous to a return of _MYSQLN_(ROW) from mysql_step(). If JSI_BREAK\n** is returned, then the SQL script has finished executing and there are\n** no further rows available. This is similar to _MYSQLN_(DONE).\n*/\nstatic Jsi_RC mdbEvalPrep(MyDbEvalContext *p) {\n    MysqlPrep *prep = p->prep;\n    Jsi_Interp *interp = p->jdb->interp;\n    Jsi_RC rc = JSI_OK;\n    if( p->prep==0 ) {\n        rc = mdbPrepareAndBind(p); //p->jdb, p->zSql, &p->zSql, &p->prep);\n        if( rc!=JSI_OK )\n            return rc;\n        prep = p->prep;\n        if (p->jdb->optPtr->prefetch) {\n            my_bool aBool = 1;\n            mysql_stmt_attr_set(prep->myStmt, STMT_ATTR_UPDATE_MAX_LENGTH, &aBool);\n        }\n        if (mysql_stmt_execute(prep->myStmt)) {\n            Jsi_Interp *interp = p->jdb->interp;\n            rc = Jsi_LogError(\"execute failed: %s\", mysql_error(p->jdb->db));\n        }\n        if (p->jdb->optPtr->prefetch && mysql_stmt_store_result(prep->myStmt)) {\n            Jsi_LogWarn(\"prefetch failed, disabling: %s\", mysql_error(p->jdb->db));\n            p->jdb->optPtr->prefetch = 0;\n        }\n        MYSQL_RES *res = mysql_stmt_result_metadata(prep->myStmt);\n        MYSQL_FIELD *field;\n        if (res) {\n            // Setup field mappings to/from Jsi.\n            prep->fieldResult = (SqlFieldResults*)Jsi_Calloc(res->field_count, sizeof(*prep->fieldResult));\n            prep->colNames = (char**)Jsi_Calloc(res->field_count, sizeof(char*));\n            prep->colTypes = (Jsi_OptionId*)Jsi_Calloc(res->field_count, sizeof(int));\n            int iCnt = 0;\n            while((field = mysql_fetch_field(res)))\n            {\n                assert(iCnt<prep->numCol);\n                SqlFieldResults *fres = prep->fieldResult+iCnt;\n                MYSQL_BIND *bindResult = prep->bindResult+iCnt;\n                \n                bindResult->buffer = &fres->buffer.vchar;\n                fres->field = field;\n                prep->colNames[iCnt] = field->name;\n                switch (field->type) {\n                    case MYSQL_TYPE_TINY:\n                    case MYSQL_TYPE_BIT:\n                        if (field->length == 1) {\n                            fres->jsiTypeMap = JSI_OPTION_BOOL;\n                            fres->mapType = MYSQL_TYPE_DOUBLE;\n                            fres->vsize = 1;\n                            break;\n                            \n                        }\n                    case MYSQL_TYPE_SHORT:\n                    case MYSQL_TYPE_LONG:\n                    case MYSQL_TYPE_DECIMAL:\n                        fres->jsiTypeMap = JSI_OPTION_INT64;\n                        fres->mapType = MYSQL_TYPE_LONG;\n                        fres->vsize = sizeof(long long);\n                        break;\n                    case MYSQL_TYPE_LONGLONG:\n                        fres->jsiTypeMap = JSI_OPTION_INT64;\n                        fres->mapType = MYSQL_TYPE_LONGLONG;\n                        fres->vsize = sizeof(long long);\n                        break;\n                    \n                    case MYSQL_TYPE_FLOAT:\n                    case MYSQL_TYPE_DOUBLE:\n                        fres->jsiTypeMap = JSI_OPTION_DOUBLE;\n                        fres->mapType = MYSQL_TYPE_DOUBLE;\n                        fres->vsize = sizeof(double);\n                        break;\n                    case MYSQL_TYPE_TIME:\n                    case MYSQL_TYPE_DATE:\n                    case MYSQL_TYPE_DATETIME:\n                    case MYSQL_TYPE_TIMESTAMP:\n                        fres->jsiTypeMap = JSI_OPTION_TIME_D; //TODO: time\n                        fres->mapType = MYSQL_TYPE_DATETIME;\n                        fres->vsize = sizeof(MYSQL_TIME);\n                        break;\n                    case MYSQL_TYPE_STRING:\n                    default:\n                        if (IS_NUM(field->type)) {\n                            fres->mapType = MYSQL_TYPE_LONGLONG;\n                            fres->jsiTypeMap = JSI_OPTION_DOUBLE;\n                            fres->vsize = sizeof(double);\n                        } else {\n                            fres->jsiTypeMap = JSI_OPTION_STRING;\n                            fres->mapType = MYSQL_TYPE_STRING;\n                            if (p->jdb->optPtr->prefetch)\n                                fres->vsize = field->max_length;\n                            else\n                                fres->vsize = p->jdb->optPtr->maxString;\n                            if (fres->vsize <= 0)\n                                fres->vsize = JSI_BUFSIZ;\n                            bindResult->buffer = fres->buffer.vstring = (char*)Jsi_Malloc(fres->vsize);\n                            fres->buffer.vstring[0] = 0;\n                        }\n                        break;\n                }\n                prep->colTypes[iCnt] = fres->jsiTypeMap;\n                bindResult->buffer_type = fres->mapType;\n                bindResult->buffer_length = fres->vsize;\n                bindResult->length = &fres->len;\n                bindResult->is_null = &fres->isnull;\n                iCnt++;\n            }\n        }\n        else return JSI_BREAK;\n        if (mysql_stmt_bind_result(prep->myStmt, prep->bindResult)) {\n            fprintf(stderr, \"mysql_stmt_bind_Result(), failed. Error:%s\\n\", mysql_stmt_error(prep->myStmt));\n            return JSI_ERROR;\n        }\n        mysql_free_result(res);\n    }\n    return rc;\n}\n\nstatic Jsi_RC mdbEvalStep(MyDbEvalContext *p) {\n    Jsi_RC rc = JSI_OK;\n    if( p->prep==0)\n        rc = mdbEvalPrep(p);\n    if (rc == JSI_BREAK)\n        return JSI_BREAK;\n    if (rc == JSI_OK)\n        rc = mdbEvalStepSub(p, 1, NULL);\n    return rc;\n}\n\nconst char *mysqlGetbindParamName(MysqlPrep* pStmt, int n) {\n    if (n>=1 && n<=pStmt->paramCnt)\n        return pStmt->paramNames[n-1];\n    return NULL;\n}\n  \n/*\nenum enum_field_types { MYSQL_TYPE_DECIMAL, MYSQL_TYPE_TINY,\n                        MYSQL_TYPE_SHORT,  MYSQL_TYPE_LONG,\n                        MYSQL_TYPE_FLOAT,  MYSQL_TYPE_DOUBLE,\n                        MYSQL_TYPE_NULL,   MYSQL_TYPE_TIMESTAMP,\n                        MYSQL_TYPE_LONGLONG,MYSQL_TYPE_INT24,\n                        MYSQL_TYPE_DATE,   MYSQL_TYPE_TIME,\n                        MYSQL_TYPE_DATETIME, MYSQL_TYPE_YEAR,\n                        MYSQL_TYPE_NEWDATE, MYSQL_TYPE_VARCHAR,\n                        MYSQL_TYPE_BIT,\n                        MYSQL_TYPE_NEWDECIMAL=246,\n                        MYSQL_TYPE_ENUM=247,\n                        MYSQL_TYPE_SET=248,\n                        MYSQL_TYPE_TINY_BLOB=249,\n                        MYSQL_TYPE_MEDIUM_BLOB=250,\n                        MYSQL_TYPE_LONG_BLOB=251,\n                        MYSQL_TYPE_BLOB=252,\n                        MYSQL_TYPE_VAR_STRING=253,\n                        MYSQL_TYPE_STRING=254,\n                        MYSQL_TYPE_GEOMETRY=255\n\n};\n*/\n/*\n * MYSQL_TYPE_TINY  1\nMYSQL_TYPE_SHORT    2\nMYSQL_TYPE_LONG 4\nMYSQL_TYPE_LONGLONG 8\nMYSQL_TYPE_FLOAT    4\nMYSQL_TYPE_DOUBLE   8\nMYSQL_TYPE_TIME sizeof(MYSQL_TIME)\nMYSQL_TYPE_DATE sizeof(MYSQL_TIME)\nMYSQL_TYPE_DATETIME sizeof(MYSQL_TIME)\nMYSQL_TYPE_STRING   data length\nMYSQL_TYPE_BLOB data_length\n*/\n\n\nstatic Jsi_RC mdbPrepareAndBind(MyDbEvalContext *p)\n{\n    if (mdbPrepareStmt(p) != JSI_OK)\n        return JSI_ERROR;\n    MysqlPrep *prep = p->prep;\n    MySqlObj *jdb = p->jdb;\n    Jsi_Interp *interp = jdb->interp;\n    Jsi_Value *pv = NULL, *apv = NULL;\n    char tname[50];\n\n    Jsi_RC rc = JSI_OK;\n    int i, n, nVar = prep->numParam;\n\n    if (nVar<=0)\n        return rc;\n    if (!prep->bindParam)\n        prep->bindParam = (MYSQL_BIND*)Jsi_Calloc(nVar, sizeof(MYSQL_BIND));\n    else\n        memset(prep->bindParam, 0, (nVar * sizeof(MYSQL_BIND)));\n    for(i=1; i<=nVar; i++) {\n        int btype = 0;\n        int isInt = 0;\n        int isBlob = 0;\n        const char *zVar = mysqlGetbindParamName(prep, i);\n        tname[0] = 0;\n        if (zVar == NULL) {\n            if (!jdb->optPtr || !(apv=jdb->optPtr->values))\n                return Jsi_LogError(\"? bind without values for param %d\", i);\n            if (!(pv =Jsi_ValueArrayIndex(interp, apv, i-1))) \n                return Jsi_LogError(\"array element %d missing\", nVar);\n        }\n        else if ((zVar[0]!='$' && zVar[0]!=':' && zVar[0]!='@') ) \n            return Jsi_LogError(\"can not find bind var %s\", zVar); else {\n           \n            int zvLen = Jsi_Strlen(zVar);\n            char *zcp;\n            if (zVar[0] =='$' && ((zcp = Jsi_Strchr(zVar,'('))) && zVar[zvLen-1] == ')')\n            {\n                Jsi_DString vStr;\n                Jsi_DSInit(&vStr);\n                Jsi_DSAppendLen(&vStr, zVar+1, (zcp-zVar-1));\n                int slen = Jsi_Strlen(zcp);\n                const char *ttp;\n                if (jdb->optPtr->typeCheck!=mdbTypeCheck_None && (ttp = Jsi_Strchr(zVar,':'))) {\n                    // Extract bind-type.\n                    Jsi_DString tStr = {};\n                    int tlen = Jsi_Strlen(ttp+1);\n                    Jsi_DSAppendLen(&tStr, ttp+1, tlen-1);\n                    snprintf(tname, sizeof(tname), \"%s\", Jsi_DSValue(&tStr));\n                    Jsi_HashEntry *hPtr = Jsi_HashEntryFind(jdb->typeNameHash, tname);\n                    assert(hPtr);\n                    btype = (long)Jsi_HashValueGet(hPtr);\n                    Jsi_DSFree(&tStr);\n                    slen -= tlen;\n                }\n\n                if (isdigit(zcp[1])) {\n                    Jsi_DSAppendLen(&vStr, \"[\", 1);\n                    Jsi_DSAppendLen(&vStr, zcp+1, slen-2);\n                    Jsi_DSAppendLen(&vStr, \"]\", 1);\n                } else {\n                    if (zcp[1] != '[')\n                        Jsi_DSAppendLen(&vStr, \".\", 1);\n                    Jsi_DSAppendLen(&vStr, zcp+1, slen-2);\n                }\n                pv = Jsi_NameLookup(interp, Jsi_DSValue(&vStr));\n                Jsi_DSFree(&vStr);\n            } else\n                pv = Jsi_VarLookup(interp, &zVar[1]);\n        }\n        Jsi_Number r;\n        SqlFieldResults *fres = prep->fieldParam+i-1;\n        MYSQL_BIND *bind = prep->bindParam+i-1;\n        memset(bind, 0, sizeof(*bind));\n        // Now create binding.\n        if(!pv ) {\n            if (!jdb->bindWarn) {\n                rc = Jsi_LogError(\"unknown bind param: %s\", zVar);\n                break;\n            } else\n                Jsi_LogWarn(\"unknown bind param: %s\", zVar);\n        } else {\n            if (btype && !Jsi_ValueIsUndef(interp, pv)) {\n                int done = 0, match = 1, cast = (jdb->optPtr->typeCheck==mdbTypeCheck_Cast);\n                switch (btype) {\n                    case MYSQL_TYPE_BLOB:\n                        isBlob = 1;\n                    case MYSQL_TYPE_STRING:\n                        if (cast)\n                            Jsi_ValueToString(interp, pv, &n);\n                        else\n                            match = Jsi_ValueIsString(interp, pv); \n                        break;\n                    case MYSQL_TYPE_DOUBLE:\n                        if (cast)\n                            Jsi_ValueToNumber(interp, pv);\n                        else\n                            match = Jsi_ValueIsNumber(interp, pv); \n                        break;\n                    case MYSQL_TYPE_LONGLONG:\n                        isInt = 1;\n                        if (cast)\n                            Jsi_ValueToNumber(interp, pv);\n                        else\n                            match = Jsi_ValueIsNumber(interp, pv); \n                        break;\n                    case MYSQL_TYPE_TINY:\n                        if (cast)\n                            Jsi_ValueToBool(interp, pv);\n                        else\n                            match = Jsi_ValueIsBoolean(interp, pv); \n                        break;\n                    case MYSQL_TYPE_TIME:\n                    case MYSQL_TYPE_DATE:\n                    case MYSQL_TYPE_DATETIME:\n                    case MYSQL_TYPE_TIMESTAMP:\n                        if (cast)\n                            Jsi_ValueToNumber(interp, pv);\n                        else if (!Jsi_ValueIsNumber(interp, pv))\n                            goto errout;\n                        Jsi_GetNumberFromValue(interp, pv, &r);\n                        bind->buffer_type = (enum enum_field_types)btype;\n                        bind->buffer=&fres->buffer.timestamp;\n                        bind->buffer_length = sizeof(fres->buffer.timestamp);\n                        bind->length = NULL;\n                        mdbJsToMyTime(r, &fres->buffer.timestamp, 1);\n                        done = 1;\n                        break;\n                    default:\n                        Jsi_LogBug(\"Unhandled bind type: %s = %d\", tname, btype);\n                }\n                if (done)\n                    continue;\n                 if (cast == 0 && match == 0) \nerrout:\n                 {\n                    int ltyp = (jdb->optPtr->typeCheck==mdbTypeCheck_Error?JSI_LOG_ERROR:JSI_LOG_WARN);\n                    Jsi_LogMsg(interp, ltyp, \"bind param \\\"%s\\\" type is not \\\"%s\\\"\", zVar, tname);\n                    if (ltyp == JSI_LOG_ERROR)\n                        return JSI_ERROR;\n                }\n            }\n            \n            if (Jsi_ValueIsBoolean(interp, pv)) {\n                bool nb;\n                Jsi_GetBoolFromValue(interp, pv, &nb);\n                n = nb;\n                bind->buffer_type = MYSQL_TYPE_TINY;\n                bind->buffer = &fres->buffer.vchar;\n                bind->buffer_length = sizeof(fres->buffer.vchar);\n                bind->length = &fres->len;\n                //bind->is_null = &fres->isnull;\n                fres->buffer.vchar = n;\n                \n            } else if (Jsi_ValueIsNumber(interp, pv)) {\n                Jsi_Number r;\n                Jsi_Wide wv;\n                Jsi_GetNumberFromValue(interp, pv, &r);\n                wv = (Jsi_Wide)r;\n                bind->buffer_type = MYSQL_TYPE_DOUBLE;\n                bind->buffer = &fres->buffer.vdouble;\n                bind->buffer_length = sizeof(fres->buffer.vdouble);\n                bind->length = &fres->len;\n                fres->buffer.vdouble = (double)r;\n                if (isInt || (jdb->forceInt && (((Jsi_Number)wv)-r)==0)) {\n                    bind->buffer = &fres->buffer.vlonglong;\n                    bind->buffer_type = MYSQL_TYPE_LONGLONG;\n                    bind->buffer_length = sizeof(fres->buffer.vlonglong);\n                    fres->buffer.vlonglong = wv;\n                }\n            } else if (Jsi_ValueIsNull(interp, pv) || (Jsi_ValueIsUndef(interp, pv) && jdb->optPtr->mapundef)) {\nbindnull:\n                bind->buffer_type = MYSQL_TYPE_NULL;\n                bind->buffer = &fres->buffer.vchar;\n                bind->buffer_length = sizeof(fres->buffer.vchar);\n                bind->length = &fres->len;\n                fres->buffer.vchar = 0;\n\n            } else if (Jsi_ValueIsString(interp, pv)) {\n                char *sstr = Jsi_ValueGetStringLen(interp, pv, &n);\n                bind->buffer_type = MYSQL_TYPE_STRING;\n                bind->buffer=sstr;\n                bind->buffer_length = n;\n                bind->length = NULL;\n                if (isBlob)\n                    bind->buffer_type = MYSQL_TYPE_BLOB;\n            } else {\n                if (!jdb->bindWarn) {\n                    rc = Jsi_LogError(\"bind param must be string/number/bool/null: %s\", zVar);\n                    break;\n                } else {\n                    Jsi_LogWarn(\"bind param must be string/number/bool/null: %s\", zVar);\n                    goto bindnull;\n                }\n            }\n        }\n    }\n    if (mysql_stmt_bind_param(prep->myStmt, prep->bindParam))\n        rc = Jsi_LogError(\"bind failed: %s\", mysql_error(jdb->db));\n    return rc;\n}\n\n\nstatic void mdbClose(MYSQL  *db) {\n        mysql_close(db);\n}\n\nstatic Jsi_RC mdbIsNumArray(Jsi_Interp *interp, Jsi_Value *value)\n{\n    if (!Jsi_ValueIsArray(interp, value)) \n        return Jsi_LogError(\"expected array of numbers\");\n    int i, argc = Jsi_ValueGetLength(interp, value);\n    for (i=0; i<argc; i++) {\n        Jsi_Value *v = Jsi_ValueArrayIndex(interp, value, i);\n        if (!Jsi_ValueIsNumber(interp, v)) \n            return Jsi_LogError(\"expected array of numbers\");\n    }\n    return JSI_OK;\n}\n\n/*\n** JSI calls this procedure when an MYSQL  database command is\n** deleted.\n*/\nstatic void mdbDeleteCmd(MySqlObj *jdb)\n{\n    Jsi_Interp *interp = jdb->interp;\n    if (jdb->debug & mdbTMODE_DELETE)\n        JSI_DBQUERY_PRINTF( \"DEBUG: delete\\n\");\n    if (jdb->stmtCache)\n        mdbFlushStmtCache(jdb);\n    if (jdb->stmtHash)\n        Jsi_HashDelete(jdb->stmtHash);\n    //closeIncrblobChannels(jdb);\n    if (jdb->db) {\n        mdbClose(jdb->db);\n    }\n    while( jdb->pFunc ) {\n        SqlFunc *pFunc = jdb->pFunc;\n        jdb->pFunc = pFunc->pNext;\n        Jsi_DSFree(&pFunc->dScript);\n        Jsi_DecrRefCount(interp, pFunc->tocall);\n        Jsi_Free((char*)pFunc);\n    }\n    if( jdb->zNull ) {\n        Jsi_Free(jdb->zNull);\n    }\n    if (jdb->typeNameHash)\n        Jsi_HashDelete(jdb->typeNameHash);\n    Jsi_OptionsFree(interp, SqlOptions, jdb, 0);\n    if (jdb->stmtCache)\n        Jsi_ListDelete(jdb->stmtCache);\n}\n\n/*\n** Return a JSON formatted value for the iCol'th column of the row currently pointed to by\n** the MyDbEvalContext structure passed as the first argument.\n*/\nstatic void mdbEvalSetColumnJSON(MyDbEvalContext *p, int iCol, Jsi_DString *dStr) {\n    Jsi_Interp *interp = p->jdb->interp;\n    char nbuf[200];\n    MysqlPrep *prep = p->prep;\n    SqlFieldResults *field = prep->fieldResult+iCol;\n    if (field->isnull) {\n        Jsi_DSAppend(dStr, \"null\", NULL);\n        return;\n    }\n    const char *zBlob = \"\";\n    int bytes = 0;\n\n    switch(field->jsiTypeMap) {\n        case JSI_OPTION_BOOL: {\n            snprintf(nbuf, sizeof(nbuf), \"%s\", field->buffer.vchar?\"true\":\"false\");\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        case JSI_OPTION_INT64: {\n            snprintf(nbuf, sizeof(nbuf), \"%lld\", field->buffer.vlonglong);\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        case JSI_OPTION_DOUBLE: {\n            Jsi_NumberToString(interp, field->buffer.vdouble, nbuf, sizeof(nbuf));\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        //case JSI_OPTION_TIME_T:\n        case JSI_OPTION_TIME_D:\n        case JSI_OPTION_TIME_W: {\n            Jsi_Number jtime = mdbMyTimeToJS(&field->buffer.timestamp);\n            Jsi_NumberToString(interp, jtime, nbuf, sizeof(nbuf));\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        case JSI_OPTION_STRING:\n            zBlob = field->buffer.vstring;\n        default:\n        {\n            if( !zBlob ) {\n                Jsi_DSAppend(dStr, \"null\", NULL);\n                return;\n            }\n            Jsi_JSONQuote(interp, zBlob, bytes, dStr);\n            return;\n        }\n    }\n}\n\nstatic void mdbEvalSetColumn(MyDbEvalContext *p, int iCol, Jsi_DString *dStr) {\n    //Jsi_Interp *interp = p->jdb->interp;\n    char nbuf[200];\n    MysqlPrep *prep = p->prep;\n    SqlFieldResults *field = prep->fieldResult+iCol;\n    Jsi_Interp *interp = p->jdb->interp;\n    if (field->isnull)\n        return;\n        \n    switch(field->jsiTypeMap) {\n        case JSI_OPTION_STRING: {\n            int bytes = field->len;\n            const char *zBlob = field->buffer.vstring;\n    \n            if( !zBlob ) {\n                const char *nv = p->jdb->optPtr->nullvalue;\n                Jsi_DSAppend(dStr, nv?nv:\"null\", NULL);\n                return;\n            }\n            Jsi_DSAppendLen(dStr, zBlob, bytes);\n            return;\n        }\n        case JSI_OPTION_BOOL: {\n            snprintf(nbuf, sizeof(nbuf), \"%s\", field->buffer.vchar?\"true\":\"false\");\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        case JSI_OPTION_INT64: {\n            snprintf(nbuf, sizeof(nbuf), \"%lld\", field->buffer.vlonglong);\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        //case JSI_OPTION_TIME_T:\n        case JSI_OPTION_TIME_D:\n        case JSI_OPTION_TIME_W: {\n            Jsi_Number jtime = mdbMyTimeToJS(&field->buffer.timestamp);\n            Jsi_NumberToString(interp, jtime, nbuf, sizeof(nbuf));\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        case JSI_OPTION_DOUBLE: {\n            Jsi_NumberToString(interp, field->buffer.vdouble, nbuf, sizeof(nbuf));\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        default:\n            Jsi_LogWarn(\"unknown type: %d\", field->jsiTypeMap);\n    \n    }\n}\n\n\nstatic Jsi_Value* mdbEvalSetColumnValue(MyDbEvalContext *p, int iCol, Jsi_Value **val) {\n    Jsi_Interp *interp = p->jdb->interp;\n    MysqlPrep *prep = p->prep;\n    SqlFieldResults *field = prep->fieldResult+iCol;\n    if (field->isnull)\n        return Jsi_ValueMakeNull(interp, val);\n        \n    switch(field->jsiTypeMap) {\n        case JSI_OPTION_STRING: {\n            int bytes = field->len;\n            char *zBlob = field->buffer.vstring;\n            if( !zBlob ) {\n                return Jsi_ValueMakeNull(interp, val);\n            }\n            zBlob = (char*)Jsi_Malloc(bytes+1);\n            memcpy(zBlob, field->buffer.vstring, bytes);\n            zBlob[bytes] = 0;\n            return Jsi_ValueMakeBlob(interp, val, (unsigned char*)zBlob, bytes+1);\n        }\n        case JSI_OPTION_BOOL:\n            return Jsi_ValueMakeBool(interp, val, field->buffer.vchar);\n        case JSI_OPTION_INT64:\n             return Jsi_ValueMakeNumber(interp, val, (Jsi_Number)field->buffer.vlonglong);\n        //case JSI_OPTION_TIME_T:\n        case JSI_OPTION_TIME_D:\n        case JSI_OPTION_TIME_W: {\n            Jsi_Number jtime = mdbMyTimeToJS(&field->buffer.timestamp);\n            return Jsi_ValueMakeNumber(interp, val, jtime);\n        }\n        case JSI_OPTION_DOUBLE:\n             return Jsi_ValueMakeNumber(interp, val, (Jsi_Number)field->buffer.vdouble);\n        default:\n            Jsi_LogWarn(\"unknown type: %d\", field->jsiTypeMap);\n    }\n    return Jsi_ValueNew1(interp);\n}\n\nstatic Jsi_RC mdbEvalCallCmd( MyDbEvalContext *p, Jsi_Interp *interp, Jsi_RC result)\n{\n    int cnt = 0;\n    Jsi_RC rc = result;\n    Jsi_Value *varg1;\n    Jsi_Obj *argso;\n    char **apColName = NULL;\n    Jsi_OptionId *apColType = NULL;\n    if (p->jdb->debug & mdbTMODE_EVAL)\n        JSI_DBQUERY_PRINTF( \"DEBUG: eval\\n\");\n\n    while( (rc==JSI_OK) && JSI_OK==(rc = mdbEvalStep(p)) ) {\n        int i;\n        int nCol;\n\n        cnt++;\n        mdbEvalRowInfo(p, &nCol, &apColName, &apColType);\n        if (nCol<=0)\n            continue;\n        if (Jsi_ValueIsNull(interp,p->tocall))\n            continue;\n        /* Single object containing sql result members. */\n        varg1 = Jsi_ValueMakeObject(interp, NULL, argso = Jsi_ObjNew(interp));\n        for(i=0; i<nCol; i++) {\n            Jsi_Value *nnv = mdbEvalSetColumnValue(p, i, NULL);\n            Jsi_ObjInsert(interp, argso, apColName[i], nnv, 0);\n        }\n        Jsi_IncrRefCount(interp, varg1);\n        bool rb = Jsi_FunctionInvokeBool(interp, p->tocall, varg1);\n        if (Jsi_InterpGone(interp))\n            return JSI_ERROR;\n        Jsi_DecrRefCount(interp, varg1);\n        if (rb)\n            break;\n    }\n    //mdbEvalFinalize(p);\n\n    if( rc==JSI_OK || rc==JSI_BREAK ) {\n        //Jsi_ResetResult(interp);\n        rc = JSI_OK;\n    }\n    return rc;\n}\n\nstatic MySqlObj *_mysql_getDbHandle(Jsi_Interp *interp, Jsi_Value *_this, Jsi_Func *funcPtr)\n{\n    MySqlObj *jdb = (MySqlObj*)Jsi_UserObjGetData(interp, _this, funcPtr);\n    if (!jdb) {\n        Jsi_LogError(\"MySql call to a non-mysql object\");\n        return NULL;\n    }\n    if (!jdb->db)\n    {\n        Jsi_LogError(\"MySql db is closed\");\n        return NULL;\n    }\n    return jdb;\n}\n\nstatic void mysqlObjErase(MySqlObj *jdb)\n{\n    mdbDeleteCmd(jdb);\n    jdb->db = NULL;\n}\n\nstatic Jsi_RC mysqlObjFree(Jsi_Interp *interp, void *data)\n{\n    MySqlObj *jdb = (MySqlObj*)data;\n    SQLSIGASSERT(jdb,DB);\n    jdb->_->activeCnt--;\n    mysqlObjErase(jdb);\n    _JSI_MEMCLEAR(jdb);\n    Jsi_Free(jdb);\n    return JSI_OK;\n}\n\nstatic bool mysqlObjIsTrue(void *data)\n{\n    MySqlObj *jdb = (MySqlObj*)data;\n    SQLSIGASSERT(jdb,DB);\n    if (!jdb->db) return 0;\n    else return 1;\n}\n\nstatic bool mysqlObjEqual(void *data1, void *data2)\n{\n    //SQLSIGASSERT(data1,DB);\n    //SQLSIGASSERT(data2,DB);\n    return (data1 == data2);\n}\nstatic MYSQL* mdbConnect(Jsi_Interp *interp, MySqlObj* jdb)\n{\n    return mysql_real_connect(jdb->db,\n        jdb->host?Jsi_ValueString(interp, jdb->host, NULL):NULL,\n        jdb->user, jdb->password, jdb->database,\n        jdb->port, 0, jdb->dbflags);\n}\n\n#define FN_MySql JSI_INFO(\"\\\nCreate a mysql client.\")\nstatic Jsi_RC MySqlConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr);\n\nstatic Jsi_RC MySqlReconnectCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                         Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    MySqlObj *jdb  = _mysql_getDbHandle(interp, _this, funcPtr);\n    if (!jdb) return JSI_ERROR;\n    int oldMax = jdb->maxStmts;\n    jdb->maxStmts = 0;\n    mdbStmtLimit(jdb);\n    jdb->maxStmts = oldMax;\n    mysql_close(jdb->db);\n    jdb->db = mysql_init(NULL);\n    if (!mdbConnect(interp, jdb)) \n        return Jsi_LogError(\"reconnect failed: %s\", mysql_error(jdb->db));\n    return JSI_OK;\n}\n\n#define FN_evaluate JSI_INFO(\"\\\nVariable binding is NOT performed.  \\\nReturns number of modified fields\")\nstatic Jsi_RC MySqlEvalCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                         Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    MySqlObj *jdb  = _mysql_getDbHandle(interp, _this, funcPtr);\n    if (!jdb) return JSI_ERROR;\n    int zLen, cnt = 0;\n    Jsi_RC rc = JSI_OK;\n    const char *zSql = Jsi_ValueArrayIndexToStr(interp, args, 0, &zLen);\n\n    if (mysql_real_query(jdb->db, zSql, zLen))\n        rc = Jsi_LogError(\"mysql error: %s\", mysql_error(jdb->db));\n    else if (jdb->enableMulti) {\n        MYSQL_RES *results;\n        int sr = mysql_next_result(jdb->db);\n        while (sr == 0 && (results = mysql_store_result(jdb->db)))\n            mysql_free_result(results);\n        cnt = mysql_field_count(jdb->db);\n    }\n        \n    if (rc == JSI_OK)\n        Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)cnt);\n    return rc;\n}\n\n/*\n** If a field contains any character identified by a 1 in the following\n** array, then the string must be quoted for CSV.\n*/\nstatic const char needCsvQuote[] = {\n  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   \n  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   \n  1, 0, 1, 0, 0, 0, 0, 1,   0, 0, 0, 0, 0, 0, 0, 0, \n  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, \n  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, \n  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, \n  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, \n  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 1, \n  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   \n  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   \n  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   \n  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   \n  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   \n  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   \n  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   \n  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   \n};\n\n/*\n** Output a single term of CSV.  Actually, p->separator is used for\n** the separator, which may or may not be a comma.  p->nullvalue is\n** the null value.  Strings are quoted if necessary.\n*/\nstatic void mdbOutputCsv(QueryOpts *p, const char *z, Jsi_DString *dStr, int bSep)\n{\n    if( z==0 ) {\n        Jsi_DSAppend(dStr,  p->nullvalue?p->nullvalue:\"\", NULL);\n    } else {\n        int i;\n        int nSep = Jsi_Strlen(p->separator);\n        for(i=0; z[i]; i++) {\n            if( needCsvQuote[((unsigned char*)z)[i]] || \n                (z[i]==p->separator[0] && (nSep==1 || memcmp(z, p->separator, nSep)==0)) ) {\n                i = 0;\n                break;\n            }\n        }\n        if( i==0 ) {\n            Jsi_DSAppend(dStr, \"\\\"\", NULL);\n            for(i=0; z[i]; i++) {\n                if( z[i]=='\"' ) Jsi_DSAppend(dStr, \"\\\"\", NULL);\n                Jsi_DSAppendLen(dStr, z+i, 1);\n            }\n            Jsi_DSAppend(dStr, \"\\\"\", NULL);\n        } else {\n            Jsi_DSAppend(dStr, z, NULL);\n        }\n    }\n    if( bSep ) {\n        Jsi_DSAppend(dStr, p->separator, NULL);\n    }\n}\n\nstatic void mdbOutputHtmlString(QueryOpts *p, const char *z, Jsi_DString *dStr)\n{\n    while( *z ) {\n        switch (*z) {\n        case '<':\n            Jsi_DSAppend(dStr, \"&lt;\", NULL);\n            break;\n        case '>':\n            Jsi_DSAppend(dStr, \"&gt;\", NULL);\n            break;\n        case '&':\n            Jsi_DSAppend(dStr, \"&amp;\", NULL);\n            break;\n        case '\\\"':\n            Jsi_DSAppend(dStr, \"&quot;\", NULL);\n            break;\n        case '\\'':\n            Jsi_DSAppend(dStr, \"&#39;\", NULL);\n            break;\n        default:\n            Jsi_DSAppendLen(dStr, z, 1);\n            break;\n        }\n        z++;\n    }\n}\n/*\n** Output the given string as a quoted string using SQL quoting conventions.\n*/\nstatic void mdbOutputQuotedString(Jsi_DString *dStr, const char *z) {\n    int i;\n    int nSingle = 0;\n    for(i=0; z[i]; i++) {\n        if( z[i]=='\\'' ) nSingle++;\n    }\n    if( nSingle==0 ) {\n        Jsi_DSAppend(dStr,\"'\", z, \"'\", NULL);\n    } else {\n        Jsi_DSAppend(dStr,\"'\", NULL);\n        while( *z ) {\n            for(i=0; z[i] && z[i]!='\\''; i++) {}\n            if( i==0 ) {\n                Jsi_DSAppend(dStr,\"''\", NULL);\n                z++;\n            } else if( z[i]=='\\'' ) {\n                Jsi_DSAppendLen(dStr,z, i);\n                Jsi_DSAppend(dStr,\"''\", NULL);\n                z += i+1;\n            } else {\n                Jsi_DSAppend(dStr, z, NULL);\n                break;\n            }\n        }\n        Jsi_DSAppend(dStr,\"'\", NULL);\n    }\n}\n\nstatic Jsi_RC MySqlQueryCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                             Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_RC rc = JSI_OK;\n    MySqlObj *jdb;\n    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    Jsi_Value *vSql = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_DString eStr = {};\n    JSI_DSTRING_VAR(dStr, JSI_DB_DSTRING_SIZE);\n    const char *zSql = Jsi_ValueGetDString(interp, vSql, &eStr, 0);\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 1);\n    int cnt = 0;\n    char **apColName = NULL;\n    Jsi_OptionId *apColType = NULL;\n    int isopts = 0;\n    MyDbEvalContext sEval = {};\n    QueryOpts opts, *oEopt = NULL;\n    opts = jdb->queryOpts;\n    opts.callback = NULL;\n    opts.width = NULL;\n    Jsi_Value *callback = NULL, *width = NULL;\n            \n    if (arg) {\n        if (Jsi_ValueIsFunction(interp,arg))\n            callback = opts.callback = arg;\n        else if (Jsi_ValueIsString(interp, arg))\n            opts.objName = Jsi_ValueString(interp, arg, NULL);\n        else if (Jsi_ValueIsObjType(interp, arg, JSI_OT_ARRAY))\n            opts.values = arg;\n        else if (Jsi_ValueIsObjType(interp, arg, JSI_OT_OBJECT))\n            isopts = 1;\n        else  {\n            rc = Jsi_LogError(\"argument must be null, a function, string, array or options\");\n            goto bail;\n        }\n    }\n\n    if (isopts) {\n        if (Jsi_OptionsProcess(interp, QueryFmtOptions, &opts, arg, 0) < 0) {\n            rc = JSI_ERROR;\n            goto bail;\n        }\n        callback = (opts.callback ? opts.callback : jdb->queryOpts.callback);\n        width = (opts.width ? opts.width : jdb->queryOpts.width);\n    }\n/*    if (jdb->queryOpts.CData) {\n        char *cdata = (char*)jdb->queryOpts.CData;\n        MySqlObjMultipleBind* copts = Jsi_CarrayLookup(interp, cdata);\n        if (!copts) \n            return Jsi_LogError(\"unknown CData option: %s\", jdb->queryOpts.CData);\n        int n = MySqlObjQuery(jdb, copts->opts, copts->data, copts->numData, zSql, copts->flags);\n        Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)n);\n        return JSI_OK;\n    } */\n    if (opts.objName) {\n        if (Jsi_SqlObjBinds(interp, &eStr, opts.objName,  !(opts.objOpts&OBJMODE_NOTYPES), \n        !(opts.objOpts&OBJMODE_NODEFAULTS), (opts.objOpts&OBJMODE_NULLDEFAULTS)!=0) != JSI_OK)\n            goto bail;\n        zSql = Jsi_DSValue(&eStr);\n    }\n    if (!opts.separator) {\n        switch (opts.mode) {\n            case _mdb_EF_LIST: opts.separator = \"|\"; break;\n            case _mdb_EF_COLUMN: opts.separator = \" \"; break;\n            case _mdb_EF_TABS: opts.separator = \"\\t\"; break;\n            default: opts.separator = \",\";\n        }\n    }\n    Jsi_DString sStr;\n    Jsi_DSInit(&sStr);\n    sEval.nocache = opts.nocache;\n    if (mdbEvalInit(interp, &sEval, jdb, zSql, &sStr, 0, 0) != JSI_OK) {\n        rc = JSI_ERROR;\n        goto bail;\n    }\n    sEval.namedParams = (opts.noNamedParams==0 && !opts.values);\n    sEval.ret = *ret;\n    oEopt = jdb->optPtr;\n    jdb->optPtr = &opts;\n    \n    if (sEval.namedParams) {\n        rc = mdbEvalPrep(&sEval);\n        if (rc == JSI_ERROR)\n            goto bail;\n        if (rc == JSI_BREAK) {\n            rc = JSI_OK;\n            goto bail;\n        }\n    }\n    if (opts.mode == _mdb_EF_NONE)\n        goto bail;\n    if (callback) {\n        sEval.tocall = callback;\n        if (opts.mode != _mdb_EF_ROWS)\n            rc = Jsi_LogError(\"'mode' must be 'rows' with 'callback'\");\n        else \n            rc = mdbEvalCallCmd(&sEval, interp, JSI_OK);\n        goto bail;\n    }\n    switch (opts.mode) {\n        case _mdb_EF_NONE:\n            while(JSI_OK==(rc = mdbEvalStep(&sEval)) ) {\n                cnt++;\n                if (opts.limit && cnt>=opts.limit) break;\n            }\n            goto bail;\n            break;\n        case _mdb_EF_JSON:\n            if (opts.headers) {\n                Jsi_DSAppend(dStr, \"[ \", NULL);\n                while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {\n                    int i;\n                    int nCol;\n                    mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n                    if (cnt == 0) {\n                        Jsi_DSAppend(dStr, \"[\", NULL);\n                        for(i=0; i<nCol; i++) {\n                            if (i)\n                                Jsi_DSAppend(dStr, \", \", NULL);\n                            Jsi_JSONQuote(interp, apColName[i], -1, dStr);\n                        }\n                        Jsi_DSAppend(dStr, \"]\", NULL);\n                        cnt++;\n                    }\n                    if (cnt)\n                        Jsi_DSAppend(dStr, \", \", NULL);\n                    Jsi_DSAppend(dStr, \"[\", NULL);\n                    for(i=0; i<nCol; i++) {\n                        if (i)\n                            Jsi_DSAppend(dStr, \", \", NULL);\n                        mdbEvalSetColumnJSON(&sEval, i, dStr);\n                    }\n                    Jsi_DSAppend(dStr, \"]\", NULL);\n                    cnt++;\n                    if (opts.limit && cnt>opts.limit) break;\n                }\n                Jsi_DSAppend(dStr, \" ]\", NULL);\n                \n            } else {\n                Jsi_DSAppend(dStr, \"[ \", NULL);\n                while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {\n                    int i;\n                    int nCol;\n                    mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n                    if (cnt)\n                        Jsi_DSAppend(dStr, \", \", NULL);\n                    Jsi_DSAppend(dStr, \"{\", NULL);\n                    for(i=0; i<nCol; i++) {\n                        if (i)\n                            Jsi_DSAppend(dStr, \", \", NULL);\n                        Jsi_JSONQuote(interp, apColName[i], -1, dStr);\n                        Jsi_DSAppend(dStr, \":\", NULL);\n                        mdbEvalSetColumnJSON(&sEval, i, dStr);\n                    }\n                    Jsi_DSAppend(dStr, \"}\", NULL);\n                    cnt++;\n                    if (opts.limit && cnt>=opts.limit) break;\n                }\n                Jsi_DSAppend(dStr, \" ]\", NULL);\n            }\n            break;\n            \n        case _mdb_EF_JSON2: {\n                while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {\n                    int i;\n                    int nCol;\n                    mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n                    if (cnt == 0 && 1) {\n                        Jsi_DSAppend(dStr, \"{ \\\"names\\\": [ \", NULL);\n                        for(i=0; i<nCol; i++) {\n                            if (i)\n                                Jsi_DSAppend(dStr, \", \", NULL);\n                            Jsi_JSONQuote(interp, apColName[i], -1, dStr);\n                        }\n                        Jsi_DSAppend(dStr, \" ], \\\"values\\\": [ \", NULL);\n                    }\n                    if (cnt)\n                        Jsi_DSAppend(dStr, \", \", NULL);\n                    Jsi_DSAppend(dStr, \"[\", NULL);\n                    for(i=0; i<nCol; i++) {\n                        if (i)\n                            Jsi_DSAppend(dStr, \", \", NULL);\n                        mdbEvalSetColumnJSON(&sEval, i, dStr);\n                    }\n                    Jsi_DSAppend(dStr, \" ]\", NULL);\n                    cnt++;\n                    if (opts.limit && cnt>=opts.limit) break;\n                }\n                if (cnt)\n                    Jsi_DSAppend(dStr, \" ] } \", NULL);\n            }\n            break;\n            \n        case _mdb_EF_LIST:\n            while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {\n                int i;\n                int nCol;\n                mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n                if (cnt == 0 && opts.headers) {\n                    for(i=0; i<nCol; i++) {\n                        if (i)\n                            Jsi_DSAppend(dStr, opts.separator, NULL);\n                        Jsi_DSAppend(dStr, apColName[i], NULL);\n                    }\n                }\n    \n                if (cnt || opts.headers)\n                    Jsi_DSAppend(dStr, \"\\n\", NULL);\n                for(i=0; i<nCol; i++) {\n                    if (i)\n                        Jsi_DSAppend(dStr, opts.separator, NULL);\n                    mdbEvalSetColumn(&sEval, i, dStr);\n                }\n                cnt++;\n                if (opts.limit && cnt>=opts.limit) break;\n            }\n            break;\n            \n        case _mdb_EF_COLUMN: {\n            int *wids = NULL;\n            Jsi_DString vStr = {};\n            while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {\n                int i, w;\n                int nCol;\n                \n                mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n                if (cnt == 0 && nCol>0) {\n                    Jsi_DString sStr;\n                    wids = (int*)Jsi_Calloc(nCol, sizeof(int));\n                    Jsi_DSInit(&sStr);\n                    for(i=0; i<nCol; i++) {\n                        int j = Jsi_Strlen(apColName[i]);\n                        wids[i] = (j<10?10:j);\n                        if (width) {\n                            Jsi_Value *wv = Jsi_ValueArrayIndex(interp, width, i);\n                            if (wv) {\n                                Jsi_Number dv;\n                                Jsi_ValueGetNumber(interp, wv, &dv);\n                                if (dv>0)\n                                    wids[i] = (int)dv;\n                            }\n                        }\n                        w = (j<wids[i] ? j : wids[i]);\n                        Jsi_DSAppendLen(dStr, apColName[i], w);\n                        w = (j<wids[i] ? wids[i]-j+1 : 0);\n                        while (w-- > 0)\n                            Jsi_DSAppend(dStr, \" \", NULL);\n                    }\n                    for(i=0; i<nCol && opts.headers; i++) {\n                        w = wids[i];\n                        w -= Jsi_Strlen(apColName[i]);\n                        if (i) {\n                            Jsi_DSAppend(dStr, opts.separator, NULL);\n                            Jsi_DSAppend(&sStr, opts.separator, NULL);\n                        }\n                        w = wids[i];\n                        while (w-- > 0)\n                            Jsi_DSAppend(&sStr, \"-\", NULL);\n                    }\n                    if (opts.headers)\n                        Jsi_DSAppend(dStr, \"\\n\", Jsi_DSValue(&sStr), \"\\n\", NULL);\n                    Jsi_DSFree(&sStr);\n                }\n    \n                if (cnt)\n                    Jsi_DSAppend(dStr, \"\\n\", NULL);\n                for(i=0; i<nCol; i++) {\n                    if (i)\n                        Jsi_DSAppend(dStr, opts.separator, NULL);\n                    Jsi_DSSetLength(&vStr, 0);\n                    mdbEvalSetColumn(&sEval, i, &vStr);\n                    int nl = Jsi_DSLength(&vStr);\n                    if (nl > wids[i]) {\n                        Jsi_DSSetLength(&vStr, wids[i]);\n                        w = 0;\n                    } else {\n                        w = wids[i]-nl;\n                    }\n                    Jsi_DSAppend(dStr, Jsi_DSValue(&vStr), NULL);\n                    while (w-- > 0)\n                        Jsi_DSAppend(dStr, \" \", NULL);\n                }\n                cnt++;\n                if (opts.limit && cnt>=opts.limit) break;\n            }\n            Jsi_DSFree(&vStr);\n            if (wids)\n                Jsi_Free(wids);\n            break;\n        }\n        \n        case _mdb_EF_INSERT: {\n            Jsi_DString vStr = {};    \n            while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {\n                int i;\n                int nCol;\n                const char *tbl = (opts.table ? opts.table : \"table\");\n                if (cnt)\n                    Jsi_DSAppend(dStr, \"\\n\", NULL);\n                Jsi_DSAppend(dStr, \"INSERT INTO \", tbl, \" VALUES(\", NULL);\n                mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n                for(i=0; i<nCol; i++) {\n                    Jsi_Number dv;\n                    const char *azArg;\n                    Jsi_DSSetLength(&vStr, 0);\n                    mdbEvalSetColumn(&sEval, i, &vStr);\n                    \n                    MysqlPrep *prep = sEval.prep;\n                    Jsi_OptionId ptype = prep->fieldResult[i].jsiTypeMap;\n                    \n                    azArg = Jsi_DSValue(&vStr);\n                    const char *zSep = i>0 ? \",\": \"\";\n                    if (azArg[i]==0 && ptype != JSI_OPTION_STRING) {\n                      Jsi_DSAppend(dStr, zSep, \"NULL\", NULL);\n                    } else if( ptype ==JSI_OPTION_STRING) {\n                      if( zSep[0] ) Jsi_DSAppend(dStr,zSep, NULL);\n                      mdbOutputQuotedString(dStr, azArg);\n                    } else if (ptype==JSI_OPTION_BOOL || ptype ==JSI_OPTION_DOUBLE) {\n                      Jsi_DSAppend(dStr, zSep, azArg, NULL);\n                    } else if( Jsi_GetDouble(interp, azArg, &dv) == JSI_OK ) {\n                      Jsi_DSAppend(dStr, zSep, azArg, NULL);\n                    } else {\n                      if( zSep[0] ) Jsi_DSAppend(dStr,zSep, NULL);\n                      mdbOutputQuotedString(dStr, azArg);\n                    }\n                }\n                Jsi_DSAppend(dStr, \");\", NULL);\n                cnt++;\n                if (opts.limit && cnt>=opts.limit) break;\n            }\n            Jsi_DSFree(&vStr);\n        }\n    \n        case _mdb_EF_TABS:\n        case _mdb_EF_CSV: {\n            Jsi_DString vStr = {};  \n            while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {\n                int i;\n                int nCol;\n                mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n                if (cnt == 0 && opts.headers) {\n                    for(i=0; i<nCol; i++) {\n                        if (i)\n                            Jsi_DSAppend(dStr, opts.separator, NULL);\n                        Jsi_DSAppend(dStr, apColName[i], NULL);\n                    }\n                }\n    \n                if (cnt || opts.headers)\n                    Jsi_DSAppend(dStr, \"\\n\", NULL);\n                for(i=0; i<nCol; i++) {\n                    if (i)\n                        Jsi_DSAppend(dStr, opts.separator, NULL);\n                    Jsi_DSSetLength(&vStr, 0);\n                    mdbEvalSetColumn(&sEval, i, &vStr);\n                    if (opts.mode == _mdb_EF_CSV)\n                        mdbOutputCsv(&opts, Jsi_DSValue(&vStr), dStr, 0);\n                    else\n                        Jsi_DSAppend(dStr, Jsi_DSValue(&vStr), NULL);\n                }\n                cnt++;\n                if (opts.limit && cnt>=opts.limit) break;\n            }\n            Jsi_DSFree(&vStr);\n            break;\n        }\n            \n        case _mdb_EF_LINE: {\n            int i, w = 5, ww;\n            int nCol;\n            Jsi_DString vStr = {};   \n            while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {\n                mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n                if (cnt == 0) {\n                    for(i=0; i<nCol; i++) {\n                        ww = Jsi_Strlen(apColName[i]);\n                        if (ww>w)\n                            w = ww;\n                    }\n                }\n    \n                for(i=0; i<nCol; i++) {\n                    Jsi_DString eStr;\n                    Jsi_DSInit(&eStr);\n                    Jsi_DSSetLength(&vStr, 0);\n                    mdbEvalSetColumn(&sEval, i, &vStr);\n                    Jsi_DSPrintf(&eStr, \"%*s = %s\", w, apColName[i], Jsi_DSValue(&vStr));\n                    Jsi_DSAppend(dStr, (cnt?\"\\n\":\"\"), Jsi_DSValue(&eStr), NULL);\n                    Jsi_DSFree(&eStr);\n                }\n                cnt++;\n                if (opts.limit && cnt>=opts.limit) break;\n            }\n            Jsi_DSFree(&vStr);\n            break;\n        }\n            \n        case _mdb_EF_HTML: {\n            Jsi_DString vStr = {};   \n            while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {\n                int i;\n                int nCol;\n                mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n                if (cnt == 0 && opts.headers) {\n                    Jsi_DSAppend(dStr, \"<TR>\", NULL);\n                    for(i=0; i<nCol; i++) {\n                        Jsi_DSAppend(dStr, \"<TH>\", NULL);\n                        mdbOutputHtmlString(&opts, apColName[i], dStr);\n                        Jsi_DSAppend(dStr, \"</TH>\", NULL);\n                    }\n                    Jsi_DSAppend(dStr, \"</TR>\", NULL);\n                }\n                if (cnt || opts.headers)\n                    Jsi_DSAppend(dStr, \"\\n\", NULL);\n                Jsi_DSAppend(dStr, \"<TR>\", NULL);\n                for(i=0; i<nCol; i++) {\n                    Jsi_DSAppend(dStr, \"<TD>\", NULL);\n                    Jsi_DSSetLength(&vStr, 0);\n                    mdbEvalSetColumn(&sEval, i, &vStr);\n                    mdbOutputHtmlString(&opts, Jsi_DSValue(&vStr), dStr);\n                    Jsi_DSAppend(dStr, \"</TD>\", NULL);\n                }\n                Jsi_DSAppend(dStr, \"</TR>\", NULL);\n                cnt++;\n                if (opts.limit && cnt>=opts.limit) break;\n            }\n            Jsi_DSFree(&vStr);\n            break;\n        }\n            \n        case _mdb_EF_ROWS:\n        {\n            Jsi_Value *vcur, *vrow;\n            int cnt = 0;\n            Jsi_Obj *oall, *ocur;\n            Jsi_ValueMakeArrayObject(interp, ret, oall = Jsi_ObjNewType(interp, JSI_OT_ARRAY));\n    \n            while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {\n                int i;\n                int nCol;\n                mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n                ocur = Jsi_ObjNewType(interp, JSI_OT_OBJECT);\n                vrow = Jsi_ValueMakeObject(interp, NULL, ocur);\n                for(i=0; i<nCol; i++) {\n                    vcur = mdbEvalSetColumnValue(&sEval, i, NULL);\n                    Jsi_ObjInsert(interp, ocur, apColName[i], vcur, 0);\n                }\n                Jsi_ObjArrayAdd(interp, oall, vrow);\n                cnt++;\n                if (opts.limit && cnt>=opts.limit) break;\n            }\n            mdbEvalFinalize(&sEval);\n            if (rc != JSI_ERROR)\n                rc = JSI_OK;\n            goto bail;\n            break;\n        }\n        case _mdb_EF_ARRAYS:\n        {\n            Jsi_Value *vcur, *vrow;\n            int cnt = 0;\n            Jsi_Obj *oall, *ocur;\n            Jsi_ValueMakeArrayObject(interp, ret, oall = Jsi_ObjNewType(interp, JSI_OT_ARRAY));\n    \n            while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {\n                int i;\n                int nCol;\n                mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n                if (cnt == 0 && opts.headers) {\n                    vrow = Jsi_ValueMakeArrayObject(interp, NULL, ocur = Jsi_ObjNewType(interp, JSI_OT_ARRAY));\n                    for(i=0; i<nCol; i++) {\n                        vcur = Jsi_ValueNewStringDup(interp, apColName[i]);\n                        Jsi_ObjArrayAdd(interp, ocur, vcur);\n                    }\n                    Jsi_ObjArrayAdd(interp, oall, vrow);\n                }\n                vrow = Jsi_ValueMakeArrayObject(interp, NULL, ocur = Jsi_ObjNewType(interp, JSI_OT_ARRAY));\n                for(i=0; i<nCol; i++) {\n                    vcur = mdbEvalSetColumnValue(&sEval, i, NULL);\n                    Jsi_ObjArrayAdd(interp, ocur, vcur);\n                }\n                Jsi_ObjArrayAdd(interp, oall, vrow);\n                cnt++;\n                if (opts.limit && cnt>=opts.limit) break;\n            }\n            mdbEvalFinalize(&sEval);\n            if (rc != JSI_ERROR)\n                rc = JSI_OK;\n            goto bail;\n            break;\n        }\n        case _mdb_EF_ARRAY1D:\n        {\n            Jsi_Value *vcur;\n            int cnt = 0;\n            Jsi_Obj *oall;\n            Jsi_ValueMakeArrayObject(interp, ret, oall = Jsi_ObjNewType(interp, JSI_OT_ARRAY));\n    \n            while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {\n                int i;\n                int nCol;\n                mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n                if (cnt == 0 && opts.headers) {\n                    for(i=0; i<nCol; i++) {\n                        vcur = Jsi_ValueNewStringDup(interp, apColName[i]);\n                        Jsi_ObjArrayAdd(interp, oall, vcur);\n                    }\n                }\n                for(i=0; i<nCol; i++) {\n                    vcur = mdbEvalSetColumnValue(&sEval, i, NULL);\n                    Jsi_ObjArrayAdd(interp, oall, vcur);\n                }\n                cnt++;\n                if (opts.limit && cnt>=opts.limit) break;\n            }\n            mdbEvalFinalize(&sEval);\n            if (rc != JSI_ERROR)\n                rc = JSI_OK;\n            goto bail;\n            break;\n        }\n    }\n    if( rc==JSI_BREAK ) {\n        rc = JSI_OK;\n    }\n    Jsi_ValueMakeStringDup(interp, ret, Jsi_DSValue(dStr));\nbail:\n    mdbEvalFinalize(&sEval);\n    if (isopts) {\n        Jsi_OptionsFree(interp, QueryFmtOptions, &opts, 0);\n    }\n    Jsi_DSFree(dStr);\n    Jsi_DSFree(&eStr);\n    jdb->optPtr = oEopt;\n\n    return rc;\n}\n\nstatic Jsi_RC MySqlOnecolumnCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                          Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_RC rc;\n    MySqlObj *jdb;\n    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    Jsi_Value *vSql = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    Jsi_DString sStr;\n    Jsi_DSInit(&sStr);\n    MyDbEvalContext sEval = {};\n    const char *zSql = Jsi_ValueGetDString(interp, vSql, &dStr, 0);\n\n    sEval.nocache = jdb->queryOpts.nocache;\n    if (mdbEvalInit(interp, &sEval, jdb, zSql, &sStr, 0, 0) != JSI_OK)\n        return JSI_ERROR;\n    sEval.ret = *ret;\n    sEval.tocall = NULL;\n    int cnt = 0;\n\n\n    if( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {\n        int nCol = sEval.prep->numCol;\n        if (nCol>0)\n            mdbEvalSetColumnValue(&sEval, 0, ret);\n        cnt++;\n    }\n    mdbEvalFinalize(&sEval);\n    if( rc==JSI_BREAK ) {\n        rc = JSI_OK;\n    }\n    Jsi_DSFree(&dStr);\n    return rc;\n}\n\nstatic Jsi_RC MySqlExistsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                           Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_RC rc;\n    MySqlObj *jdb;\n    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    Jsi_Value *vSql = Jsi_ValueArrayIndex(interp, args, 0);\n    const char *zSql;\n    Jsi_DString dStr = {};\n    MyDbEvalContext sEval = {};\n    zSql = Jsi_ValueGetDString(interp, vSql, &dStr, 0);\n\n    Jsi_DString sStr;\n    Jsi_DSInit(&sStr);\n    sEval.nocache = jdb->queryOpts.nocache;\n    if (mdbEvalInit(interp, &sEval, jdb, zSql, &sStr, 0, 0) != JSI_OK)\n        return JSI_ERROR;\n    sEval.ret = *ret;\n    int cnt = 0;\n\n\n    if( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {\n        int nCol = sEval.prep->numCol;\n        if (nCol>0)\n            cnt++;\n    }\n    mdbEvalFinalize(&sEval);\n    if( rc==JSI_BREAK ) {\n        rc = JSI_OK;\n    }\n    Jsi_DSFree(&dStr);\n    Jsi_ValueMakeBool(interp, ret, cnt);\n    return rc;\n}\n\nstatic Jsi_RC MySqlLastRowidCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                                    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Wide rowid;\n    MySqlObj *jdb;\n    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    rowid = mdbLastInsertRowid(jdb);\n    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)rowid);\n    return JSI_OK;\n}\n\n/*\nstatic Jsi_RC MySqlInterruptCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                              Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    MySqlObj *jdb;\n    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    _SQL_LITE_N_(_interrupt)(jdb->db);\n    return JSI_OK;\n} */\n\n\nstatic Jsi_RC MySqlCompleteCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                             Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    MySqlObj *jdb;\n    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    Jsi_Value *s = Jsi_ValueArrayIndex(interp, args, 0);\n    const char *str =  Jsi_ValueString(interp, s, NULL);\n    int isComplete = 0;\n    if (str)\n        isComplete = 0; // sqlite3_complete( str );\n    Jsi_ValueMakeBool(interp, ret, isComplete);\n    return JSI_OK;\n}\n\nstatic Jsi_RC MySqlErrorNoCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                              Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    MySqlObj *jdb;\n    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    int n = mysql_errno(jdb->db);\n    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)n);\n    return JSI_OK;\n}\n\nstatic Jsi_RC MySqlErrorStateCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                              Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    MySqlObj *jdb;\n    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    const char *str = mysql_sqlstate(jdb->db);\n    if (str)\n        Jsi_ValueMakeStringDup(interp, ret, str);\n    return JSI_OK;\n}\n\nstatic Jsi_RC MySqlLastQueryCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                              Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    MySqlObj *jdb;\n    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    const char *str = mysql_info(jdb->db);\n    if (str)\n        Jsi_ValueMakeStringDup(interp, ret, str);\n    return JSI_OK;\n}\n\nstatic Jsi_RC MySqlResetCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                              Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    MySqlObj *jdb;\n    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n#if (MYSQL_VERSION_ID >= 50703 && !defined(JSI_NO_MYSQL_RESET))\n    int oldMax = jdb->maxStmts;\n    jdb->maxStmts = 0;\n    mdbStmtLimit(jdb);\n    jdb->maxStmts = oldMax;\n    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)mysql_reset_connection(jdb->db));\n#else\n    Jsi_LogWarn(\"mysql reset unavailable: requires version 5.7.3+\");\n#endif\n    return JSI_OK;    \n}\n\n\nstatic Jsi_RC MySqlPingCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                              Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    MySqlObj *jdb;\n    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    int n = mysql_ping(jdb->db);\n    bool noErr = 0;\n    Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 0);\n    if (val)\n        Jsi_ValueGetBoolean(interp, val, &noErr);\n    if (n && noErr==0) \n        return Jsi_LogError(\"ping failed: (%d) %s\", n, mysql_error(jdb->db));\n    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)n);\n\n    return JSI_OK;    \n}\n\nstatic Jsi_RC MySqlAffectedRowsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                              Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    MySqlObj *jdb;\n    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)mysql_affected_rows(jdb->db));\n    return JSI_OK;\n}\nstatic Jsi_RC MySqlInfoCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                              Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    MySqlObj *jdb;\n    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    Jsi_Obj *nobj = Jsi_ObjNew(interp);\n    Jsi_ValueMakeObject(interp, ret, nobj);\n    const char *str, *svals[20];\n    int i = 0;\n    svals[i++] = \"clientInfo\";\n    svals[i++] = mysql_get_client_info();\n    svals[i++] = \"hostInfo\";\n    svals[i++] = mysql_get_host_info(jdb->db);\n    svals[i++] = \"serverInfo\";\n    svals[i++] = mysql_get_server_info(jdb->db);\n    svals[i++] = \"stat\";\n    svals[i++] = mysql_stat(jdb->db);\n    svals[i++] = 0;\n    i = 0;\n    while (svals[i]) {\n        str = svals[i+1];\n        Jsi_ObjInsert(interp, nobj, svals[i], str?Jsi_ValueNewStringDup(interp, str):Jsi_ValueNewNull(interp), 0);\n    }\n    Jsi_ObjInsert(interp, nobj, \"threadId\", Jsi_ValueNewNumber(interp, (Jsi_Number)mysql_thread_id(jdb->db)), 0);\n    Jsi_ObjInsert(interp, nobj, \"protocolVersion\", Jsi_ValueNewNumber(interp, (Jsi_Number)mysql_get_proto_info(jdb->db)), 0);\n    Jsi_ObjInsert(interp, nobj, \"clientVersion\", Jsi_ValueNewNumber(interp, (Jsi_Number)mysql_get_client_version()), 0);\n    Jsi_ObjInsert(interp, nobj, \"serverVersion\", Jsi_ValueNewNumber(interp, (Jsi_Number)mysql_get_server_version(jdb->db)), 0);\n    Jsi_ObjInsert(interp, nobj, \"warningCount\", Jsi_ValueNewNumber(interp, (Jsi_Number)mysql_warning_count(jdb->db)), 0);\n    return JSI_OK;\n}\n\nstatic Jsi_RC MySqlConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                         Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    MySqlObj *jdb;\n    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    int oms = jdb->maxStmts;\n    const char *oldu = jdb->user, *oldpw = jdb->password, *olddb = jdb->database;\n    Jsi_RC rc = Jsi_OptionsConf(interp, SqlOptions, jdb, Jsi_ValueArrayIndex(interp, args, 0), ret, 0);\n    if (jdb->maxStmts<0 || jdb->maxStmts>MAX_PREPARED_STMTS) {\n        JSI_DBQUERY_PRINTF( \"option maxStmts value %d is not in range 0..%d\", jdb->maxStmts, MAX_PREPARED_STMTS);\n        jdb->maxStmts = oms;\n        rc = JSI_ERROR;\n    }\n    if (oldu != jdb->user || oldpw != jdb->password || olddb != jdb->database)\n        if (!mysql_change_user(jdb->db, jdb->user, jdb->password, jdb->database)) {\n            rc = JSI_ERROR;\n            jdb->user = oldu;\n            jdb->password = oldpw;\n            jdb->database = olddb;\n        }\n    mdbStmtLimit(jdb);\n    return rc;\n}\n\nstatic Jsi_CmdSpec mysqlCmds[] = {\n    { \"MySql\",          MySqlConstructor,    0,  1,  \"options:object=void\",  \n        .help=\"Create a new db connection to a MySql database:\", .retType=(uint)JSI_TT_USEROBJ, .flags=JSI_CMD_IS_CONSTRUCTOR, .info=0, .opts=SqlOptions },\n    { \"affectedRows\",   MySqlAffectedRowsCmd,0, 0, \"\", .help=\"Return affected rows\", .retType=(uint)JSI_TT_NUMBER },\n    { \"complete\",       MySqlCompleteCmd,   1,  1, \"sql:string\", .help=\"Return true if sql is complete\", .retType=(uint)JSI_TT_BOOLEAN },\n    { \"conf\",           MySqlConfCmd,       0,  1, \"options:string|object=void\", .help=\"Configure options\", .retType=(uint)JSI_TT_ANY, .flags=0, .info=0, .opts=SqlOptions },\n    { \"errorNo\",        MySqlErrorNoCmd,    0,  0, \"\", .help = \"Return error code returned by most recent call to mysql3_exec()\", .retType=(uint)JSI_TT_NUMBER },\n    { \"errorState\",     MySqlErrorStateCmd, 0,  0, \"\", .help = \"Return the mysql error state str\" , .retType=(uint)JSI_TT_STRING},\n    { \"eval\",           MySqlEvalCmd,       1,  1, \"sql:string\", .help=\"Run sql commands without input/output\", .retType=(uint)JSI_TT_NUMBER },\n    { \"exists\",         MySqlExistsCmd,     1,  1, \"sql:string\", .help=\"Execute sql, and return true if there is at least one result value\", .retType=(uint)JSI_TT_BOOLEAN },\n    { \"info\",           MySqlInfoCmd,       0,  0, \"\", .help=\"Return info about last query\", .retType=(uint)JSI_TT_OBJECT },\n    { \"lastQuery\",      MySqlLastQueryCmd,  0,  0, \"\", .help=\"Return info string about most recently executed statement\", .retType=(uint)JSI_TT_STRING },\n    { \"lastRowid\",      MySqlLastRowidCmd,  0,  0, \"\", .help=\"Return rowid of last insert\", .retType=(uint)JSI_TT_NUMBER },\n    { \"onecolumn\",      MySqlOnecolumnCmd,  1,  1, \"sql:string\", .help=\"Execute sql, and return a single value\", .retType=(uint)JSI_TT_ANY },\n    { \"ping\",           MySqlPingCmd,       0,  1, \"noError:boolean=false\", .help=\"Ping connection\", .retType=(uint)JSI_TT_NUMBER },\n    { \"query\",          MySqlQueryCmd,      1,  2, \"sql:string, options:function|string|array|object=void\", .help=\"Run sql query with input and/or outputs.\", .retType=(uint)JSI_TT_ANY, .flags=0, .info=0, .opts=QueryFmtOptions },\n    { \"reconnect\",      MySqlReconnectCmd,  0,  0, \"\", .help=\"Reconnect with current settings\", .retType=(uint)JSI_TT_VOID },\n    { \"reset\",          MySqlResetCmd,      0,  0, \"\", .help=\"Reset connection\", .retType=(uint)JSI_TT_NUMBER },\n    { NULL, 0,0,0,0, .help=\"Commands for accessing mysql databases\" }\n};\n\n    \nstatic Jsi_RC mysqlObjFree(Jsi_Interp *interp, void *data);\nstatic bool  mysqlObjEqual(void *data1, void *data2);\nstatic bool  mysqlObjIsTrue(void *data);\n\nstatic Jsi_UserObjReg mysqlobject = {\n    .name   = \"MySql\",\n    .spec   = mysqlCmds,\n    .freefun= mysqlObjFree,\n    .istrue = mysqlObjIsTrue,\n    .isequ  = mysqlObjEqual\n};\n\nstatic Jsi_RC MySqlConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    MySqlObj *jdb;\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_LogTest(\"Creating new MySql\");\n        \n    jdb = (MySqlObj*)Jsi_Calloc(1, sizeof(*jdb));\n    SQLSIGINIT(jdb, DB);\n    const char *groupname = \"mysqljsi\";\n    jdb->_ = &mydbObjCmd;\n    jdb->_->newCnt++;\n    jdb->_->activeCnt++;\n\n    jdb->maxStmts = NUM_PREPARED_STMTS;\n    jdb->forceInt = 1;\n    jdb->interp = interp;\n    jdb->hasOpts = (arg != NULL && !Jsi_ValueIsNull(interp,arg));\n    if (jdb->hasOpts && Jsi_OptionsProcess(interp, SqlOptions, jdb, arg, 0) < 0) {\n        jdb->deleted = 1;\n        mysqlObjFree(interp, jdb);\n        return JSI_ERROR;\n    }\n    if (!jdb->udata) {\n        jdb->udata = Jsi_ValueNewObj(interp, NULL);\n        Jsi_IncrRefCount(interp, jdb->udata);\n    }\n    jdb->db = mysql_init(NULL);\n    jdb->version = (MYSQL_VERSION_MAJOR + ((Jsi_Number)MYSQL_VERSION_MINOR/100.0) + ((Jsi_Number)MYSQL_VERSION_PATCH/10000.0));\n\n#if (MYSQL_VERSION_ID>=32350)\n    if (jdb->reconnect)\n    {\n      my_bool reconnect = 1;\n      mysql_options(jdb->db, MYSQL_OPT_RECONNECT, &reconnect);\n    }\n    mysql_options(jdb->db, MYSQL_READ_DEFAULT_GROUP, groupname);\n#endif\n\n#if (MYSQL_VERSION_ID >= 40107)\n    if (jdb->sslKey) {\n        const char *sslcert = Jsi_ValueString(interp, jdb->sslCert, NULL),\n            *sslca = Jsi_ValueString(interp, jdb->sslCA, NULL),\n            *sslcapath = Jsi_ValueString(interp, jdb->sslCAPath, NULL),\n            *sslcipher = Jsi_ValueString(interp, jdb->sslCipher, NULL),\n            *sslkey = Jsi_ValueString(interp, jdb->sslKey, NULL);\n        mysql_ssl_set(jdb->db, sslkey, sslcert, sslca, sslcapath, sslcipher);\n        jdb->dbflags |= CLIENT_SSL;\n    }\n#endif\n\n    if (!mdbConnect(interp, jdb)) {\n        Jsi_LogError(\"connect failed %s\", mysql_error(jdb->db));\n        mysqlObjFree(interp, jdb);\n        return JSI_ERROR;\n    }\n\n    if (jdb->enableMulti) {\n        if (mysql_set_server_option(jdb->db, MYSQL_OPTION_MULTI_STATEMENTS_ON))\n            Jsi_LogWarn(\"multi on failed %s\", mysql_error(jdb->db));\n    }\n    //jdb->event = Jsi_EventNew(interp, mysqlUpdate, jdb); //TODO: events\n    Jsi_Value *toacc = NULL;\n    if (Jsi_FunctionIsConstructor(funcPtr)) {\n        toacc = _this;\n    } else {\n        Jsi_Obj *o = Jsi_ObjNew(interp);\n        Jsi_PrototypeObjSet(interp, \"MySql\", o);\n        Jsi_ValueMakeObject(interp, ret, o);\n        toacc = *ret;\n    }\n\n    Jsi_Obj *fobj = Jsi_ValueGetObj(interp, toacc);\n    if ((jdb->objId = Jsi_UserObjNew(interp, &mysqlobject, fobj, jdb))<0) {\n        mysqlObjFree(interp, jdb);\n        Jsi_ValueMakeUndef(interp, ret);\n        return JSI_ERROR;\n    }\n    jdb->stmtHash = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);\n    jdb->userObjPtr = fobj;\n    jdb->optPtr = &jdb->queryOpts;\n    jdb->stmtCache = Jsi_ListNew((Jsi_Interp*)jdb, 0, mdbStmtFreeProc);\n    return JSI_OK;\n}\n\n\nstatic Jsi_RC Jsi_DoneMySql(Jsi_Interp *interp)\n{\n    if (Jsi_UserObjUnregister(interp, &mysqlobject) != JSI_OK)\n        return JSI_ERROR;\n    Jsi_PkgProvide(interp, \"MySql\", -1, NULL);\n    return JSI_OK;\n}\n\nJsi_RC Jsi_InitMySql(Jsi_Interp *interp, int release)\n{\n    if (release) {\n        if (!--mydbObjCmd.init)\n            mysql_library_end();\n        return Jsi_DoneMySql(interp);\n    }\n    Jsi_Hash* dbSys;\n#if JSI_USE_STUBS\n  if (Jsi_StubsInit(interp, 0) != JSI_OK)\n    return JSI_ERROR;\n#endif\n#ifndef JSI_OMIT_THREADS\n    if (mydbObjCmd.init == 0 && mysql_library_init(0, NULL, NULL))\n        return Jsi_LogError(\"failed to initialize MySQL library\\n\");\n#else\n    return Jsi_LogError(\"Threads required for mysql\");\n#endif\n\n    Jsi_Value *info = Jsi_ValueNew1(interp);\n    Jsi_JSONParseFmt(interp, &info, \"{pkgVer:%d}\", MYSQL_VERSION_ID);\n    Jsi_PkgOpts dbPkgOpts = { mydb_ObjCmd_Specs, &mydbObjCmd, mysqlCmds, info};\n    Jsi_RC rc = Jsi_PkgProvideEx(interp, \"MySql\", 1.1, Jsi_InitMySql, &dbPkgOpts);\n    Jsi_DecrRefCount(interp, info);\n    if (rc != JSI_OK)\n        rc = JSI_ERROR;\n    else if (!(dbSys = Jsi_UserObjRegister(interp, &mysqlobject))) \n        rc = Jsi_LogError(\"Failed to init mysql extension\");\n    else if (!Jsi_CommandCreateSpecs(interp, mysqlobject.name, mysqlCmds, dbSys, JSI_CMDSPEC_ISOBJ))\n        rc = JSI_ERROR;\n    if (rc == JSI_OK)\n        mydbObjCmd.init++;\n    else\n        mysql_library_end();\n    return rc;\n}\n\n#endif\n", "#include <math.h>\n#ifndef JSI_AMALGAMATION\n#include \"jsiInt.h\"\n#endif\n\nbool Jsi_NumberIsSubnormal(Jsi_Number a) { return fpclassify(a) == FP_SUBNORMAL; }\n\nbool Jsi_NumberIsNormal(Jsi_Number a) { return (fpclassify(a) == FP_ZERO || isnormal(a)); }\n\nbool Jsi_NumberIsNaN(Jsi_Number n)\n{\n    return isnan(n);\n}\n\nint Jsi_NumberIsInfinity(Jsi_Number a) {\n#if JSI__MUSL==1 || defined(__FreeBSD__) || defined(__WIN32)\n    if (!isinf(a))\n        return 0;\n    return (a<0 ? -1 : 1);\n#else\n    return isinf(a);\n#endif\n}\nbool Jsi_NumberIsInteger(Jsi_Number n) { return (isnormal(n) ? (Jsi_Number)((Jsi_Wide)(n)) == (n) : n==0.0); }\n\nbool Jsi_NumberIsSafeInteger(Jsi_Number n) {\n    Jsi_Number n1 = fabsl(n),\n    n2 = 9007199254740991LL;\n    return (Jsi_NumberIsInteger(n) && n1<=n2);\n}\n\nbool Jsi_NumberIsWide(Jsi_Number n) { return (isnormal(n) && (Jsi_Number)((Jsi_Wide)(n)) == (n)); }\n\nJsi_Number Jsi_NumberInfinity(int i)\n{\n    Jsi_Number r = INFINITY;\n    if (i < 0) r = -r;\n    return r;\n}\n\nJsi_Number Jsi_NumberNaN(void)\n{\n    return NAN;\n}\n\nvoid Jsi_NumberItoA10(Jsi_Wide value, char* buf, int bsiz)\n{\n    snprintf(buf, bsiz, \"%\" PRId64, value);\n}\n\nvoid Jsi_NumberUtoA10(Jsi_UWide value, char* buf, int bsiz)\n{\n    snprintf(buf, bsiz, \"%\" PRIu64, value);\n}\n\nbool Jsi_NumberIsFinite(Jsi_Number value)\n{\n    Jsi_Number r = INFINITY;\n    return (Jsi_NumberIsNaN(value)==0 && value != r && r != -value);\n}\n\nvoid Jsi_NumberDtoA(Jsi_Interp *interp, Jsi_Number value, char* buf, int bsiz, int prec)\n{\n    int dp = interp->subOpts.dblPrec-1, dm = __DBL_DECIMAL_DIG__;\n    if (prec==0)\n        prec = (dp<=0?dm+dp:dp);\n    else if (prec<0)\n            prec = dm+prec;\n    if (prec<=0)\n        prec = dm-1;\n    if (Jsi_NumberIsNaN(value))\n        Jsi_Strcpy(buf,\"NaN\");\n    else\n        snprintf(buf, bsiz, \"%.*\" JSI_NUMGFMT, prec, value);\n}\n\nbool Jsi_NumberIsEqual(Jsi_Number n1, Jsi_Number n2)\n{\n    return (n1 == n2); // TODO: Do we need more than this?\n}\n\n#ifndef JSI_LITE_ONLY\nstatic Jsi_RC NumberConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (Jsi_FunctionIsConstructor(funcPtr)) {\n        Jsi_Number nv = 0.0;\n        Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n        if (v) {\n            Jsi_ValueToNumber(interp, v);\n            nv = v->d.num;\n        }\n        _this->d.obj->ot = JSI_OT_NUMBER;\n        _this->d.obj->d.num = nv;\n        Jsi_ValueToObject(interp, _this);\n        Jsi_ValueMakeNumber(interp, ret, nv);\n        return JSI_OK;\n    }\n    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n    if (v) {\n        Jsi_ValueToNumber(interp, v);\n        Jsi_ValueDup2(interp, ret, v);\n        Jsi_ValueToObject(interp, *ret);\n        return JSI_OK;\n    }\n    Jsi_ValueMakeNumber(interp, ret, 0.0);\n    return JSI_OK;\n}\n\n   \n#define ChkStringN(_this, funcPtr, dest) \\\n    if (_this->vt == JSI_VT_OBJECT && _this->d.obj->ot == JSI_OT_FUNCTION &&  \\\n       _this->d.obj->__proto__ == interp->Number_prototype->d.obj->__proto__ ) { \\\n        skip = 1; \\\n        dest = Jsi_ValueArrayIndex(interp, args, 0); \\\n    } else if (_this->vt != JSI_VT_OBJECT || _this->d.obj->ot != JSI_OT_NUMBER) { \\\n        Jsi_LogError(\"apply Number.%s to a non-number object\", funcPtr->cmdSpec->name); \\\n        return JSI_ERROR; \\\n    } else  { \\\n        dest = _this; \\\n    }\n    \nstatic Jsi_RC NumberToFixedCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[100];\n    int prec = 0, skip = 0;\n    Jsi_Number num;\n    Jsi_Value *v;\n    ChkStringN(_this, funcPtr, v);\n    Jsi_Value *pa = Jsi_ValueArrayIndex(interp, args, skip);\n    if (pa && Jsi_GetIntFromValue(interp, pa, &prec) != JSI_OK)\n        return JSI_ERROR;\n    if (prec<0) prec = 0;\n    Jsi_GetDoubleFromValue(interp, v, &num);\n    snprintf(buf, sizeof(buf), \"%.*\" JSI_NUMFFMT, prec, num);\n    Jsi_ValueMakeStringDup(interp, ret, buf);\n    return JSI_OK;\n}\n\nstatic Jsi_RC NumberToPrecisionCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[100];\n    int prec = 0, skip = 0;\n    Jsi_Number num;\n    Jsi_Value *v;\n    ChkStringN(_this, funcPtr, v);\n    if (Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, skip), &prec) != JSI_OK)\n        return JSI_ERROR;\n    if (prec<=0) return JSI_ERROR;\n    Jsi_GetDoubleFromValue(interp, v, &num);\n    snprintf(buf, sizeof(buf),\"%.*\" JSI_NUMFFMT, prec, num);\n    if (num<0)\n        prec++;\n    buf[prec+1] = 0;\n    if (buf[prec] == '.')\n        buf[prec] = 0;\n    Jsi_ValueMakeStringDup(interp, ret, buf);\n    return JSI_OK;\n}\n\nstatic Jsi_RC NumberToExponentialCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[100];\n    int prec = 0, skip = 0;\n    Jsi_Number num;\n    Jsi_Value *v;\n    ChkStringN(_this, funcPtr, v);\n    if (Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, skip), &prec) != JSI_OK)\n        return JSI_ERROR;\n    if (prec<0) prec = 0;\n    Jsi_GetDoubleFromValue(interp, v, &num);\n    snprintf(buf, sizeof(buf), \"%.*\" JSI_NUMEFMT, prec, num);\n#ifdef __WIN32\n    char *e = strrchr(buf, 'e');\n    if (e && (e[1]=='+' || e[1]=='-')) {\n        e++;\n        int eNum = atoi(e);\n        if (e[0]=='-')\n            eNum = -eNum;\n        e++;\n        snprintf(e, (e-buf), \"%02d\", eNum);\n    }\n#endif\n    Jsi_ValueMakeStringDup(interp, ret, buf);\n    return JSI_OK;\n}\n\nstatic Jsi_RC NumberToStringCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[500];\n    int radix = 10, skip = 0, argc = Jsi_ValueGetLength(interp, args);\n    Jsi_Number num;\n    Jsi_Value *v;\n    ChkStringN(_this, funcPtr, v);\n    Jsi_GetDoubleFromValue(interp, v, &num);\n    if (argc>skip && (Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, skip), &radix) != JSI_OK\n        || radix<2))\n        return JSI_ERROR;\n    if (argc==skip)\n        return jsi_ObjectToStringCmd(interp, args, _this, ret, funcPtr);\n    switch (radix) {\n        case 16: snprintf(buf, sizeof(buf), \"%\" PRIx64, (Jsi_Wide)num); break;\n        case 8: snprintf(buf, sizeof(buf), \"%\" PRIo64, (Jsi_Wide)num); break;\n        case 10: snprintf(buf, sizeof(buf), \"%\" PRId64, (Jsi_Wide)num); break;\n        default: return jsi_ObjectToStringCmd(interp, args, _this, ret, funcPtr);\n    }\n    Jsi_ValueMakeStringDup(interp, ret, buf);\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_NumberIsFiniteCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr, int op)\n{\n    Jsi_Number num;\n    Jsi_Value *v;\n    bool b = 0;\n    int skip = 0;\n    ChkStringN(_this, funcPtr, v);\n    if (Jsi_GetNumberFromValue(interp, v, &num) != JSI_OK)\n        return JSI_ERROR;\n    switch (op) {\n        case 1: b = Jsi_NumberIsFinite(num); break;\n        case 2: b = Jsi_NumberIsInteger(num); break;\n        case 3: b = Jsi_NumberIsNaN(num); break;\n        case 4: b = Jsi_NumberIsSafeInteger(num); break;\n    }\n    Jsi_ValueMakeBool(interp, ret, b);\n    skip++;\n    return JSI_OK;\n}\n\nstatic Jsi_RC NumberIsFiniteCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr) {\n    return jsi_NumberIsFiniteCmd(interp, args, _this, ret, funcPtr, 1);\n}\nstatic Jsi_RC NumberIsIntegerCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr) {\n    return jsi_NumberIsFiniteCmd(interp, args, _this, ret, funcPtr, 2);\n}\nstatic Jsi_RC NumberIsNaNCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr) {\n    return jsi_NumberIsFiniteCmd(interp, args, _this, ret, funcPtr, 3);\n}\nstatic Jsi_RC NumberIsSafeIntegerCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr) {\n    return jsi_NumberIsFiniteCmd(interp, args, _this, ret, funcPtr, 4);\n}\nstatic Jsi_CmdSpec numberCmds[] = {\n    { \"Number\",         NumberConstructor,      0, 1, \"num:string=0\", .help=\"Number constructor\", .retType=(uint)JSI_TT_NUMBER, .flags=JSI_CMD_IS_CONSTRUCTOR },\n    { \"isFinite\",       NumberIsFiniteCmd,      0, 0, \"\", .help=\"Return true if is finite\", .retType=(uint)JSI_TT_BOOLEAN },\n    { \"isInteger\",      NumberIsIntegerCmd,     0, 0, \"\", .help=\"Return true if is an integer\", .retType=(uint)JSI_TT_BOOLEAN },\n    { \"isNaN\",          NumberIsNaNCmd,         0, 0, \"\", .help=\"Return true if is NaN\", .retType=(uint)JSI_TT_BOOLEAN },\n    { \"isSafeInteger\",  NumberIsSafeIntegerCmd, 0, 0, \"\", .help=\"Return true if is a safe integer\", .retType=(uint)JSI_TT_BOOLEAN },\n    { \"toFixed\",        NumberToFixedCmd,       0, 1, \"num:number=0\", .help=\"Formats a number with x numbers of digits after the decimal point\", .retType=(uint)JSI_TT_STRING },\n    { \"toExponential\",  NumberToExponentialCmd, 1, 1, \"num:number\", .help=\"Converts a number into an exponential notation\", .retType=(uint)JSI_TT_STRING },\n    { \"toPrecision\",    NumberToPrecisionCmd,   1, 1, \"num:number\", .help=\"Formats a number to x length\", .retType=(uint)JSI_TT_STRING },\n    { \"toString\",       NumberToStringCmd,      0, 1, \"radix:number=10\", .help=\"Convert to string\", .retType=(uint)JSI_TT_STRING }, \n    { NULL, 0,0,0,0, .help=\"Commands for accessing number objects\" }\n};\n\nJsi_RC jsi_InitNumber(Jsi_Interp *interp, int release)\n{\n    if (release) return JSI_OK;\n    Jsi_Value *val, *global = interp->csc;\n    val = interp->Number_prototype = Jsi_CommandCreateSpecs(interp, \"Number\", numberCmds, NULL, JSI_CMDSPEC_ISOBJ);\n\n    Jsi_Value *NaN = Jsi_ValueMakeNumber(interp, NULL, Jsi_NumberNaN());\n\n    Jsi_Value *Inf = Jsi_ValueMakeNumber(interp, NULL, Jsi_NumberInfinity(1));\n    \n    Jsi_ValueInsertFixed(interp, global, \"NaN\", NaN);\n    Jsi_ValueInsertFixed(interp, global, \"Infinity\", Inf);\n    interp->NaNValue = NaN;\n    interp->InfValue = Inf;\n#define MCONST(name,v) Jsi_ValueInsert(interp, val, name, Jsi_ValueNewNumber(interp, v), JSI_OM_READONLY)\n    MCONST(\"MAX_VALUE\", DBL_MAX);\n    MCONST(\"MIN_VALUE\", DBL_MIN);\n    MCONST(\"NEGATIVE_INFINITY\", Jsi_NumberInfinity(-1));\n    Jsi_ValueInsertFixed(interp, val, \"POSITIVE_INFINITY\", Inf);\n    Jsi_ValueInsertFixed(interp, val, \"NaN\", NaN);\n    return JSI_OK;\n}\n#endif\n", "#ifndef JSI_AMALGAMATION\n#include \"jsiInt.h\"\n#endif\n\n#define _JSI_OPNM(nam) .sig=JSI_SIG_TYPEDEF, .id=JSI_OPTION_##nam, .idName=#nam\n// Note: these need to be in the same order as JSI_OPT_* in jsi.h \nstatic Jsi_OptionTypedef jsi_OptTypeInfo[] = {\n    {.sig=JSI_SIG_TYPEDEF, .id=JSI_OPTION_END,.idName=\"NONE\", },\n    {_JSI_OPNM(BOOL),    .cName=\"bool\",     .size=sizeof(bool),       .fmt=PRIu8,  .xfmt=\"\"  PRIu8,    .sfmt=SCNu8, .help=\"Boolean value: true or false\" },\n    {_JSI_OPNM(INT8),    .cName=\"int8_t\",   .size=sizeof(int8_t),     .fmt=PRId8,  .xfmt=\"#\" PRIx8,    .sfmt=SCNd8, .help=\"An 8-bit integer\" },\n    {_JSI_OPNM(INT16),   .cName=\"int16_t\",  .size=sizeof(int16_t),    .fmt=PRId16, .xfmt=\"#\" PRIx16,   .sfmt=SCNd16, .help=\"An 16-bit integer\" },\n    {_JSI_OPNM(INT32),   .cName=\"int32_t\",  .size=sizeof(int32_t),    .fmt=PRId32, .xfmt=\"#\" PRIx32,   .sfmt=SCNd32, .help=\"An 32-bit integer\" },\n    {_JSI_OPNM(INT64),   .cName=\"int64_t\",  .size=sizeof(int64_t),    .fmt=PRId64, .xfmt=\"#\" PRIx64,   .sfmt=SCNd64, .help=\"An 64-bit integer\" },\n    {_JSI_OPNM(UINT8),   .cName=\"uint8_t\",  .size=sizeof(uint8_t),    .fmt=PRIu8,  .xfmt=\"#\" PRIx8,    .sfmt=SCNu8, .help=\"Unsigned 8-bit integer\" },\n    {_JSI_OPNM(UINT16),  .cName=\"uint16_t\", .size=sizeof(uint16_t),   .fmt=PRIu16, .xfmt=\"#\" PRIx16,   .sfmt=SCNu16, .help=\"Unsigned 16-bit integer\" },\n    {_JSI_OPNM(UINT32),  .cName=\"uint32_t\", .size=sizeof(uint32_t),   .fmt=PRIu32, .xfmt=\"#\" PRIx32,   .sfmt=SCNu32, .help=\"Unsigned 32-bit integer\" },\n    {_JSI_OPNM(UINT64),  .cName=\"uint64_t\", .size=sizeof(uint64_t),   .fmt=PRIu64, .xfmt=\"#\" PRIx64,   .sfmt=SCNu64, .help=\"Unsigned 64-bit integer\" },\n    {_JSI_OPNM(FLOAT),   .cName=\"float\",    .size=sizeof(float),      .fmt=\"g\",    .xfmt=\"#\" \"g\",      .sfmt=\"g\", .help=\"Floating point\" },\n    {_JSI_OPNM(DOUBLE),  .cName=\"double\",   .size=sizeof(double),     .fmt=\"lg\",   .xfmt=\"#\" \"lg\",     .sfmt=\"lg\", .help=\"Floating point double\" },\n    {_JSI_OPNM(LDOUBLE),  .cName=\"ldouble\", .size=sizeof(ldouble),    .fmt=\"Lg\",   .xfmt=\"#\" \"Lg\",     .sfmt=\"Lg\", .help=\"Floating point long double\" },\n    {_JSI_OPNM(STRBUF),  .cName=\"Jsi_Strbuf\",.size=0,                 .fmt=\"s\",    .xfmt=\"s\",    .sfmt=0 /*\"s\"*/, .help=\"A fixed size string buffer\" },\n    {_JSI_OPNM(TIME_W),  .cName=\"time_w\",   .size=sizeof(time_w),     .fmt=PRId64, .xfmt=\"#\" PRIx64,   .sfmt=SCNd64, .help=\"A time value in milliseconds stored as a 64 bit integer\" },\n    {_JSI_OPNM(TIME_D),  .cName=\"time_d\",   .size=sizeof(time_d),     .fmt=\"g\",    .xfmt=\"#\" \"g\",      .sfmt=\"g\", .help=\"A time value in milliseconds stored as a double\" },\n    {_JSI_OPNM(TIME_T),  .cName=\"time_t\",   .size=sizeof(time_t),     .fmt=\"ld\",   .xfmt=\"#lx\",  .sfmt=\"ld\", .help=\"A time value stored in a unix time_t\" },\n    {_JSI_OPNM(SIZE_T),  .cName=\"size_t\",   .size=sizeof(size_t),     .fmt=\"zd\",   .xfmt=\"#zx\",  .sfmt=\"z\", .help=\"Size unsigned\" },\n    {_JSI_OPNM(SSIZE_T), .cName=\"ssize_t\",  .size=sizeof(ssize_t),    .fmt=\"zu\",   .xfmt=\"#zx\",  .sfmt=\"zu\", .help=\"Size integer\" },\n    {_JSI_OPNM(INTPTR_T),.cName=\"intptr_t\", .size=sizeof(intptr_t),   .fmt=\"d\",    .xfmt=\"#x\",   .sfmt=\"d\", .help=\"Integer large enough to store pointer\" },\n    {_JSI_OPNM(UINTPTR_T),.cName=\"uintptr_t\",.size=sizeof(uintptr_t), .fmt=\"u\",    .xfmt=\"#x\",   .sfmt=\"u\", .help=\"Unsigned large enough to store pointer\" },\n    {_JSI_OPNM(NUMBER),  .cName=\"Jsi_Number\",.size=sizeof(Jsi_Number),.fmt=JSI_NUMGFMT,.xfmt=\"#\" JSI_NUMGFMT,.sfmt=JSI_NUMGFMT, .help=\"Double or long double\" },\n    {_JSI_OPNM(INT),     .cName=\"int\",      .size=sizeof(int),        .fmt=\"d\",    .xfmt=\"#x\",   .sfmt=\"d\", .help=\"Integer\" },\n    {_JSI_OPNM(UINT),    .cName=\"uint\",     .size=sizeof(uint),       .fmt=\"u\",    .xfmt=\"#x\",   .sfmt=\"u\", .help=\"Unsigned\" },\n    {_JSI_OPNM(LONG),    .cName=\"long\",     .size=sizeof(long),       .fmt=\"ld\",   .xfmt=\"#lx\",  .sfmt=\"ld\", .help=\"Long\" },\n    {_JSI_OPNM(ULONG),   .cName=\"ulong\",    .size=sizeof(ulong),      .fmt=\"lu\",   .xfmt=\"#lx\",  .sfmt=\"lu\", .help=\"Unsigned long\" },\n    {_JSI_OPNM(SHORT),   .cName=\"short\",    .size=sizeof(short),      .fmt=\"hd\",   .xfmt=\"#hx\",  .sfmt=\"hd\", .help=\"Short\" },\n    {_JSI_OPNM(USHORT),  .cName=\"ushort\",   .size=sizeof(ushort),     .fmt=\"hu\",   .xfmt=\"#hx\",  .sfmt=\"hu\", .help=\"Unsigned short\" },\n    {_JSI_OPNM(STRING),  .cName=\"Jsi_Value*\",.size=sizeof(Jsi_Value*),.fmt=\"s\",    .xfmt=\"s\", .sfmt=0, .help=\"A string Value\"},\n    {_JSI_OPNM(DSTRING), .cName=\"Jsi_DString\",.size=sizeof(Jsi_DString), .fmt=0,    .xfmt=0, .sfmt=0, .help=\"A dynamic string\"},\n    {_JSI_OPNM(STRKEY),  .cName=\"const char*\",.size=sizeof(const char *), .fmt=0,    .xfmt=0, .sfmt=0, .help=\"Const string\"},\n    {_JSI_OPNM(VALUE),   .cName=\"Jsi_Value*\",.size=sizeof(Jsi_Value*), .fmt=0,    .xfmt=0, .sfmt=0, .help=\"A Value\"},\n    {_JSI_OPNM(VAR),     .cName=\"Jsi_Value*\",.size=sizeof(Jsi_Value*), .fmt=0,    .xfmt=0, .sfmt=0, .help=\"A Var Value\"},\n    {_JSI_OPNM(OBJ),     .cName=\"Jsi_Value*\",.size=sizeof(Jsi_Value*), .fmt=0,    .xfmt=0, .sfmt=0, .help=\"An Object Value\"},\n    {_JSI_OPNM(ARRAY),   .cName=\"Jsi_Value*\",.size=sizeof(Jsi_Value*), .fmt=0,    .xfmt=0, .sfmt=0, .help=\"An Array Value\"},\n    {_JSI_OPNM(REGEXP),  .cName=\"Jsi_Value*\",.size=sizeof(Jsi_Value*), .fmt=0,    .xfmt=0, .sfmt=0, .help=\"A Regex Value\"},\n    {_JSI_OPNM(FUNC),    .cName=\"Jsi_Value*\",.size=sizeof(Jsi_Value*), .fmt=0,    .xfmt=0, .sfmt=0, .help=\"A Func Value\"}, \n    {_JSI_OPNM(USEROBJ), .cName=\"Jsi_Value*\",.size=sizeof(Jsi_Value*), .fmt=0,    .xfmt=0, .sfmt=0, .help=\"A User-define Object Value\"}, \n    {_JSI_OPNM(CUSTOM),  .cName=\"\", .size=0, .fmt=0,    .xfmt=0, .sfmt=0, .help=\"A Custom value\"},\n    {_JSI_OPNM(END)}\n};\n\nconst Jsi_OptionTypedef* Jsi_OptionsStr2Type(const char *str, bool cName) {\n    int typ;\n    for (typ=JSI_OPTION_BOOL; typ < JSI_OPTION_END; typ++) {\n        const char *snam = (cName?jsi_OptTypeInfo[typ].cName:jsi_OptTypeInfo[typ].idName);\n        if (snam && snam[0] && !Jsi_Strcmp(str, snam))\n            return jsi_OptTypeInfo+typ;\n    }\n    return NULL;\n}\n\nconst Jsi_OptionTypedef* Jsi_OptionTypeInfo(Jsi_OptionId typ) {\n    if (typ>=JSI_OPTION_BOOL && typ < JSI_OPTION_END)\n        return jsi_OptTypeInfo+typ;\n    return NULL;\n}\n\nconst char *jsi_OptionTypeStr(Jsi_OptionId typ, bool cName)\n{\n    const Jsi_OptionTypedef* ti = Jsi_OptionTypeInfo(typ);\n    if (ti)\n        return (cName?ti->cName:ti->idName);\n    return NULL;\n}\n\nbool Jsi_OptionsValid(Jsi_Interp *interp,  Jsi_OptionSpec* spec)\n{\n    int i = 0;\n    while (spec[i].id>=JSI_OPTION_BOOL && spec[i].id < JSI_OPTION_END) {\n        SIGASSERTMASK(spec+i, OPTS, 0xff);\n        if (spec[i].help && Jsi_Strchr(spec[i].help, '\\n')) {\n            if (interp)\n                Jsi_LogError(\"item \\\"%s\\\": help contains newline\", spec[i].name);\n            return 0;\n        }\n        i++;\n    }\n    return (i>0);\n}\n\n#ifndef JSI_LITE_ONLY\n\nstatic void jsi_DumpOptionSpec(Jsi_Interp *interp, Jsi_Obj *nobj, Jsi_OptionSpec* spec, int addName);\n\nstatic Jsi_RC jsi_DeleteSpecCacheTable(Jsi_Interp *interp, void *clientData)\n{\n  Jsi_Hash *tablePtr = (Jsi_Hash *) clientData;\n  Jsi_HashEntry *entryPtr;\n  Jsi_HashSearch search;\n\n  for (entryPtr = Jsi_HashSearchFirst(tablePtr,&search); entryPtr != NULL;\n      entryPtr = Jsi_HashSearchNext(&search)) {\n\n    Jsi_Free(Jsi_HashValueGet(entryPtr));\n  }\n  Jsi_HashDelete(tablePtr);\n  return JSI_OK;\n}\n\nstatic Jsi_OptionSpec * jsi_GetCachedOptionSpecs(Jsi_Interp *interp, const Jsi_OptionSpec *staticSpecs)\n{\n    Jsi_OptionSpec *cachedSpecs;\n    Jsi_Hash *specCacheTablePtr;\n    Jsi_HashEntry *entryPtr;\n    bool isNew;\n\n    specCacheTablePtr = (Jsi_Hash*)Jsi_InterpGetData(interp, \"jsi:OptionSpec\", NULL);\n    if (specCacheTablePtr == NULL) {\n        specCacheTablePtr = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, 0);\n        Jsi_InterpSetData(interp, \"jsi:OptionSpec\", specCacheTablePtr, jsi_DeleteSpecCacheTable);\n    }\n    \n    entryPtr = Jsi_HashEntryNew(specCacheTablePtr, (char *) staticSpecs, &isNew);\n    if (isNew) {\n        unsigned int entrySpace = sizeof(Jsi_OptionSpec);\n        const Jsi_OptionSpec *staticSpecPtr;\n\n        for (staticSpecPtr=staticSpecs; staticSpecPtr->id>=JSI_OPTION_BOOL && staticSpecPtr->id!=JSI_OPTION_END; staticSpecPtr++)\n            entrySpace += sizeof(Jsi_OptionSpec);\n        assert(staticSpecPtr->id==JSI_OPTION_END);\n\n        cachedSpecs = (Jsi_OptionSpec *) Jsi_Malloc(entrySpace);\n        memcpy((void *) cachedSpecs, (void *) staticSpecs, entrySpace);\n        Jsi_HashValueSet(entryPtr, cachedSpecs);\n\n    } else {\n        cachedSpecs = (Jsi_OptionSpec *) Jsi_HashValueGet(entryPtr);\n    }\n\n    return cachedSpecs;\n}\n\nconst Jsi_OptionSpec *\nJsi_OptionSpecsCached(Jsi_Interp *interp, const Jsi_OptionSpec *staticSpecs)\n{\n#ifdef NO_CACHED_SPECS\n    return (Jsi_OptionSpec*)staticSpecs;\n#else\n    /* If we aren't master interp, need to cache due to init and modified flags if Jsi_OptionsChanged is called. */\n    if (interp->mainInterp == NULL) {\n        interp->mainInterp = interp;\n    }\n    if (interp == interp->mainInterp) {\n        return staticSpecs;\n    }\n    return jsi_GetCachedOptionSpecs(interp, staticSpecs);\n#endif\n}\n\n/**********************************/\nJsi_OptionSpec *\nJsi_OptionsFind(Jsi_Interp *interp, Jsi_OptionSpec *specs, const char *name, Jsi_Wide flags)\n{\n    Jsi_OptionSpec *specPtr;\n    char c;      /* First character of current argument. */\n    Jsi_OptionSpec *matchPtr; /* Matching spec, or NULL. */\n    size_t length;\n    const char *matStr = NULL;\n    \n    if (name == NULL) {\n        Jsi_LogError(\"Null name for option\");\n        return NULL;\n    }\n    c = name[0];\n    length = Jsi_Strlen(name);\n    matchPtr = NULL;\n    for (specPtr = specs; specPtr->id>=JSI_OPTION_BOOL && specPtr->id < JSI_OPTION_END && specPtr->name; specPtr++) {\n\n        if ((specPtr->name[0] != c)\n                || (Jsi_Strncmp(specPtr->name, name, length) != 0)) {\n            continue;\n        }\n        if (specPtr->name[length] == 0) {\n            return specPtr;   /* Stop on a perfect match. */\n        }\n        if (matchPtr != NULL) {\n            Jsi_LogError(\"ambiguous option \\\"%s\\\" matches both \\\"%s\\\" and \\\"%s\\\"\", name, matStr, specPtr->name);\n            return (Jsi_OptionSpec *) NULL;\n        }\n        matchPtr = specPtr;\n        matStr = specPtr->name;\n    }\n\n    if (matchPtr == NULL) {\n        Jsi_DString dStr = {};\n        Jsi_DSAppend(&dStr, \"unknown option \\\"\", name, \"\\\" not one of: \", NULL);\n    \n        for (specPtr = specs; specPtr->id>=JSI_OPTION_BOOL && specPtr->id < JSI_OPTION_END && specPtr->name; specPtr++) {\n            if (specPtr->name == NULL) {\n                break;\n            }\n            if (name[0] != '?' || _JSICASTINT(specPtr->id) < 0 || specPtr->id >= JSI_OPTION_END) {\n                Jsi_DSAppend(&dStr, specPtr->name, \" \", NULL);\n            } else {\n\n                Jsi_DSAppend(&dStr, \"?\", specPtr->name, \" <\", jsi_OptTypeInfo[specPtr->id].idName, \">? \", NULL);\n            }\n        }\n        assert(specPtr->id == JSI_OPTION_END);\n        Jsi_LogError(\"%s\", Jsi_DSValue(&dStr));\n        Jsi_DSFree(&dStr);\n        return (Jsi_OptionSpec *) NULL;\n    }\n    return matchPtr;\n}\n\n\nJsi_RC\njsi_SetOption_(Jsi_Interp *interp, Jsi_OptionSpec *specPtr, const char *string /*UNUSED*/, void* rec, Jsi_Value *argValue, Jsi_Wide flags, bool isSafe)\n{\n    Jsi_Wide wcount = 0;\n    bool bn;\n    Jsi_Number nv;\n    bool isIncr = (flags & JSI_OPTS_INCR);\n    const char *expType = NULL;\n    char *record = (char*)rec, *ptr = record + specPtr->offset;\n    Jsi_OptionCustom* cust = NULL;\n    const char *emsg = NULL, *epre = \"\";\n\n    if (specPtr->id<JSI_OPTION_BOOL || specPtr->id>=JSI_OPTION_END) \n        return Jsi_LogBug(\"unknown option id \\\"%d\\\" for \\\"%s\\\"\", specPtr->id, specPtr->name);\n    if (specPtr->custom  && specPtr->id == JSI_OPTION_CUSTOM) {\n        cust = Jsi_OptionCustomBuiltin(specPtr->custom);\n        if (cust && cust->parseProc) {\n            int lastErrCnt = interp->logErrorCnt;\n            Jsi_OptionSpec *oep = interp->parseMsgSpec;\n            interp->parseMsgSpec = specPtr;\n            Jsi_RC rc = (*cust->parseProc)(interp, specPtr, argValue, NULL, record, flags);\n            if (rc != JSI_OK) {\n                if (!interp->csc || lastErrCnt == interp->logErrorCnt)\n                    Jsi_LogError(\"invalid value\");\n                interp->parseMsgSpec = oep;\n                return JSI_ERROR;\n            }\n            interp->parseMsgSpec = oep;\n        } else \n            return Jsi_LogBug(\"missing or bad custom for \\\"%s\\\"\", specPtr->name);\n        goto done;\n    }\n\n    switch (specPtr->id) {\n    case JSI_OPTION_CUSTOM:\n        if (!specPtr->custom) \n            return Jsi_LogBug(\"missing or custom for \\\"%s\\\"\", specPtr->name);\n\n    case JSI_OPTION_BOOL: {\n        if (!argValue)\n            *(char*)ptr = 0;\n        else if (!Jsi_ValueIsBoolean(interp, argValue))\n            goto bail;\n        Jsi_GetBoolFromValue(interp, argValue, &bn);\n        *(char*)ptr = bn;\n        break;\n    }\n\n    case JSI_OPTION_INT:\n    case JSI_OPTION_UINT:\n    case JSI_OPTION_LONG:\n    case JSI_OPTION_INTPTR_T:\n    case JSI_OPTION_UINTPTR_T:\n    case JSI_OPTION_SIZE_T:\n    case JSI_OPTION_SSIZE_T:\n    case JSI_OPTION_ULONG:\n    case JSI_OPTION_SHORT:\n    case JSI_OPTION_USHORT:\n    case JSI_OPTION_UINT64:\n    case JSI_OPTION_INT64:\n    case JSI_OPTION_INT8:\n    case JSI_OPTION_UINT8:\n    case JSI_OPTION_INT16:\n    case JSI_OPTION_UINT16:\n    case JSI_OPTION_INT32:\n    case JSI_OPTION_UINT32:\n        wcount = 0;\n        if (argValue) {\n            if (!Jsi_ValueIsNumber(interp, argValue))\n                goto bail;\n\n            if (Jsi_GetWideFromValue(interp, argValue, &wcount) != JSI_OK) {\n                return JSI_ERROR;\n            }\n            \n        }\n        switch (specPtr->id) {\n#define _JSI_OPTSETTYP(typ, n, ptr) if (isIncr) n += *((typ *)ptr); \\\n    if (isIncr || ((Jsi_Wide)(typ)(n)) == (n)) interp->cdataIncrVal = *((typ *)ptr) = (typ)(n); else expType = #typ;\n            case JSI_OPTION_INT:    _JSI_OPTSETTYP(int, wcount, ptr); break;\n            case JSI_OPTION_UINT:   _JSI_OPTSETTYP(uint, wcount, ptr); break;\n            case JSI_OPTION_INTPTR_T: _JSI_OPTSETTYP(intptr_t, wcount, ptr); break;\n            case JSI_OPTION_UINTPTR_T:_JSI_OPTSETTYP(uintptr_t, wcount, ptr); break;\n            case JSI_OPTION_SIZE_T:   _JSI_OPTSETTYP(size_t, wcount, ptr); break;\n            case JSI_OPTION_SSIZE_T:  _JSI_OPTSETTYP(ssize_t, wcount, ptr); break;\n            case JSI_OPTION_LONG:   _JSI_OPTSETTYP(long, wcount, ptr); break;\n            case JSI_OPTION_ULONG:  _JSI_OPTSETTYP(ulong, wcount, ptr); break;\n            case JSI_OPTION_SHORT:  _JSI_OPTSETTYP(short, wcount, ptr); break;\n            case JSI_OPTION_USHORT: _JSI_OPTSETTYP(ushort, wcount, ptr); break;\n            case JSI_OPTION_INT8:   _JSI_OPTSETTYP(int8_t, wcount, ptr); break;\n            case JSI_OPTION_UINT8:  _JSI_OPTSETTYP(uint8_t, wcount, ptr) break;\n            case JSI_OPTION_INT16:  _JSI_OPTSETTYP(int16_t, wcount, ptr); break;\n            case JSI_OPTION_UINT16: _JSI_OPTSETTYP(uint16_t, wcount, ptr); break;\n            case JSI_OPTION_INT32:  _JSI_OPTSETTYP(int32_t, wcount, ptr); break;\n            case JSI_OPTION_UINT32: _JSI_OPTSETTYP(uint32_t, wcount, ptr); break;\n            case JSI_OPTION_INT64:  _JSI_OPTSETTYP(int64_t, wcount, ptr); break;\n            case JSI_OPTION_UINT64: _JSI_OPTSETTYP(uint64_t, wcount, ptr); break; // TODO: might loose top sign bit...\n            default: break;\n        }\n        if (expType)\n            return Jsi_LogType(\"not a %s\", expType);\n        isIncr = 0;\n        break;\n\n    case JSI_OPTION_NUMBER:\n    case JSI_OPTION_DOUBLE:\n    case JSI_OPTION_LDOUBLE:\n    case JSI_OPTION_FLOAT:\n        nv = 0;\n        if (argValue) {\n            if (!Jsi_ValueIsNumber(interp, argValue))\n                goto bail;\n            if (Jsi_GetNumberFromValue(interp, argValue, &nv) != JSI_OK) {\n                return JSI_ERROR;\n            }\n        }\n            \n        switch (specPtr->id) {\n#define _JSI_OPTSETNTYP(typ, n, ptr) if (!argValue) *(typ*)ptr = 0; else { if (isIncr) n += *((typ *)ptr); \\\n            interp->cdataIncrVal = *((typ *)ptr) = (typ)(n); \\\n            if (interp->strict && Jsi_NumberIsNaN((Jsi_Number)(*((typ *)ptr)))) return Jsi_LogError(\"not a number\"); }\n\n            case JSI_OPTION_NUMBER: _JSI_OPTSETNTYP(Jsi_Number, nv, ptr); break;\n            case JSI_OPTION_LDOUBLE: _JSI_OPTSETNTYP(ldouble, nv, ptr); break;\n            case JSI_OPTION_FLOAT: _JSI_OPTSETNTYP(float, nv, ptr); break;\n            case JSI_OPTION_DOUBLE: _JSI_OPTSETNTYP(double, nv, ptr); break;\n            default: break;\n        }\n        isIncr = 0;\n        break;\n    case JSI_OPTION_STRKEY:\n    {\n        if (argValue == NULL || Jsi_ValueIsNull(interp, argValue))\n            *(const char**)ptr = NULL;\n        else {\n            const char *scp;\n            if (Jsi_GetStringFromValue(interp, argValue, &scp) != JSI_OK) {\n                return JSI_ERROR;\n            }\n            *(const char**)ptr = Jsi_KeyAdd(interp,scp);\n        }\n    }\n    break;\n    case JSI_OPTION_STRBUF:\n    {\n        if (argValue == NULL || Jsi_ValueIsNull(interp, argValue))\n            *(char*)ptr = 0;\n        else {\n            int sLen;\n            const char *scp = Jsi_ValueString(interp, argValue, &sLen);\n            if (!scp)\n                goto bail;\n            if (sLen>(int)(specPtr->size-1)) {\n                return Jsi_LogError(\"String too long\");\n                //sLen = specPtr->size-1;\n            }\n            memcpy((char*)ptr, scp, sLen);\n            ((char*)ptr)[sLen] = 0;\n        }\n    }\n    break;\n    \n#define _JSI_OPT_CHECKNULL(argValue) if (!argValue || Jsi_ValueIsNull(interp, argValue)) { \\\n         if (*((Jsi_Value **)ptr)) \\\n            Jsi_DecrRefCount(interp, *((Jsi_Value **)ptr)); \\\n        *((Jsi_Value **)ptr) = NULL; \\\n        break; \\\n    }\n\n#define _JSI_OPT_ARGSET(argValue, ptr) \\\n    if (!(specPtr->flags&JSI_OPT_NO_DUPVALUE)) {\\\n        Jsi_IncrRefCount(interp, argValue); \\\n        if (*((Jsi_Value **)ptr)) Jsi_DecrRefCount(interp, *((Jsi_Value **)ptr)); \\\n    }\\\n    *((Jsi_Value **)ptr) = argValue;\n    \n    case JSI_OPTION_STRING:\n        if (argValue == *((Jsi_Value **)ptr))\n            break;\n        _JSI_OPT_CHECKNULL(argValue);\n        if (!Jsi_ValueIsString(interp, argValue))\n            goto bail;\n        _JSI_OPT_ARGSET(argValue, ptr);\n        break;\n        \n    case JSI_OPTION_DSTRING:\n        Jsi_DSInit((Jsi_DString *)ptr);\n        if (argValue && !Jsi_ValueIsNull(interp, argValue))\n        {\n            int sLen;\n            const char *scp = Jsi_ValueString(interp, argValue, &sLen);\n            if (!scp)\n                goto bail;\n            Jsi_DSAppendLen((Jsi_DString *)ptr, scp, sLen);\n        }\n        break;\n    \n    case JSI_OPTION_TIME_D: {\n       if (argValue)\n        {\n            Jsi_Number nv = 0;\n            if (Jsi_ValueIsNumber(interp, argValue)) {\n                Jsi_GetNumberFromValue(interp, argValue, &nv);\n                *(double*)ptr = nv;\n            } else {\n                const char *scp;\n                if (Jsi_GetStringFromValue(interp, argValue, &scp) != JSI_OK) {\n                    return JSI_ERROR;\n                }\n                if (JSI_OK != Jsi_DatetimeParse(interp, scp, \"\", 0, &nv, false))\n                    return JSI_ERROR;\n                *(double*)ptr = nv;\n            }\n        } else {\n            *(double*)ptr = 0;\n        }\n        break;\n    }\n    case JSI_OPTION_TIME_W: {\n       if (argValue)\n        {\n            if (Jsi_ValueIsNumber(interp, argValue)) {\n                Jsi_GetNumberFromValue(interp, argValue, (Jsi_Number*)ptr);\n            } else {\n                const char *scp;\n                Jsi_Number num;\n                if (Jsi_GetStringFromValue(interp, argValue, &scp) != JSI_OK) {\n                    return JSI_ERROR;\n                }\n                if (JSI_OK != Jsi_DatetimeParse(interp, scp, \"\", 0, &num, false))\n                    return JSI_ERROR;\n                *(Jsi_Wide*)ptr = (Jsi_Wide)num;\n            }\n        } else {\n            *(Jsi_Wide*)ptr = 0;\n        }\n        break;\n    }\n    case JSI_OPTION_TIME_T: {\n       if (argValue)\n        {\n            if (Jsi_ValueIsNumber(interp, argValue)) {\n                Jsi_Number num;\n                Jsi_GetNumberFromValue(interp, argValue, &num);\n                *(time_t*)ptr = (time_t)num;\n            } else {\n                const char *scp;\n                if (Jsi_GetStringFromValue(interp, argValue, &scp) != JSI_OK) {\n                    return JSI_ERROR;\n                }\n                Jsi_Number nval;\n                if (JSI_OK != Jsi_DatetimeParse(interp, scp, \"\", 0, &nval, false))\n                    return JSI_ERROR;\n                *(time_t*)ptr = nval/1000LL;\n            }\n        } else {\n            *(time_t*)ptr = 0;\n        }\n        break;\n    }\n    case JSI_OPTION_VAR:\n        _JSI_OPT_CHECKNULL(argValue);\n        if (argValue->vt != JSI_VT_NULL && argValue->vt != JSI_VT_VARIABLE) \n            goto bail;\n        _JSI_OPT_ARGSET(argValue, ptr);\n        break;\n\n    case JSI_OPTION_FUNC:\n        _JSI_OPT_CHECKNULL(argValue);\n        if (argValue->vt != JSI_VT_OBJECT || argValue->d.obj->ot != JSI_OT_FUNCTION) \n            goto bail;\n        if (specPtr->data && (interp->typeCheck.run|interp->typeCheck.all))\n            if (!jsi_FuncArgCheck(interp, argValue->d.obj->d.fobj->func, (char*)specPtr->data)) \n                return Jsi_LogError(\"failed setting func pointer for %s\", specPtr->name);\n\n        _JSI_OPT_ARGSET(argValue, ptr);\n        break;\n        \n    case JSI_OPTION_USEROBJ:\n        _JSI_OPT_CHECKNULL(argValue);\n        if (argValue->vt != JSI_VT_OBJECT || argValue->d.obj->ot != JSI_OT_USEROBJ) \n            goto bail;\n        if (specPtr->data && Jsi_Strcmp((char*)specPtr->data, argValue->d.obj->d.uobj->reg->name)) \n            return Jsi_LogError(\"expected id %s for %s\",(char*)specPtr->data,  specPtr->name);\n        _JSI_OPT_ARGSET(argValue, ptr);\n        break;\n\n    case JSI_OPTION_REGEXP:\n        _JSI_OPT_CHECKNULL(argValue);\n        if (argValue->vt != JSI_VT_OBJECT || argValue->d.obj->ot != JSI_OT_REGEXP)\n            goto bail;\n        _JSI_OPT_ARGSET(argValue, ptr);\n        break;\n\n    case JSI_OPTION_OBJ:\n        _JSI_OPT_CHECKNULL(argValue);\n        if (argValue->vt != JSI_VT_OBJECT)\n            goto bail;\n\n    case JSI_OPTION_VALUE:\n         _JSI_OPT_CHECKNULL(argValue);\n         _JSI_OPT_ARGSET(argValue, ptr);\n        break;\n    case JSI_OPTION_ARRAY:\n        _JSI_OPT_CHECKNULL(argValue);\n        if (argValue->vt != JSI_VT_OBJECT || !argValue->d.obj->isarrlist)\n            goto bail;\n        _JSI_OPT_ARGSET(argValue, ptr);\n        break;\n#ifdef __cplusplus\n    case JSI_OPTION_END:\n#else\n    default:\n#endif\n        Jsi_LogBug(\"invalid option id: %d\", specPtr->id);\n    }\ndone:\n    specPtr->flags |= JSI_OPT_IS_SPECIFIED;\n    if (isIncr)\n        return Jsi_LogError(\"incr invalid for %s\", specPtr->name);\n    return JSI_OK;\n\nbail:\n    if (!emsg) {\n        emsg = jsi_OptTypeInfo[specPtr->id].cName;\n        epre = \"expected \";\n    }\n    return Jsi_LogError(\"%s%s: for %s option \\\"%.40s\\\"\", epre, emsg, (cust?cust->name:\"\"), specPtr->name);\n}\n\nJsi_RC\njsi_SetOption(Jsi_Interp *interp, Jsi_OptionSpec *specPtr, const char *string /*UNUSED*/, void* rec, Jsi_Value *argValue, Jsi_Wide flags, bool isSafe)\n{\n    Jsi_Value *oa = interp->lastParseOpt;\n    interp->lastParseOpt = argValue;\n    Jsi_RC rc = jsi_SetOption_(interp, specPtr, string, rec, argValue, flags, isSafe);\n    interp->lastParseOpt = oa;\n    return rc;\n}\n\nJsi_RC\nJsi_OptionsSet(Jsi_Interp *interp, Jsi_OptionSpec *specs, void* rec, const char *option, Jsi_Value *valuePtr, Jsi_Wide flags)\n{\n    char *record = (char*)rec;\n    Jsi_OptionSpec *specPtr;\n    specs = jsi_GetCachedOptionSpecs(interp, specs);\n    const char *cp = NULL, *cb = NULL;\n    bool isSafe = interp->isSafe;\n    if (option) {\n        cp = Jsi_Strchr(option, '.');\n        cb = Jsi_Strchr(option, '[');\n    }\n    if (cp && (!cb || cp<cb) ) {\n        Jsi_DString dStr;\n        int len = (cp-option);\n        Jsi_DSInit(&dStr);\n        cp = Jsi_DSAppendLen(&dStr, option, len);\n        specPtr = Jsi_OptionsFind(interp, specs, cp, flags);\n        Jsi_DSFree(&dStr);\n        if (!specPtr || !specPtr->data|| specPtr->id != JSI_OPTION_CUSTOM || specPtr->custom != Jsi_Opt_SwitchSuboption) \n            return Jsi_LogError(\"unknown or bad sub-config option: %s\", option);\n        cp = option+len+1;\n        return Jsi_OptionsSet(interp, (Jsi_OptionSpec *)(specPtr->data), (void*)(((char*)rec)+specPtr->offset), cp, valuePtr, flags);\n    }\n    if (cb && cb != option) {\n        char *ce = Jsi_Strchr(option, ']');\n        Jsi_Wide ul;\n        Jsi_DString dStr;\n        Jsi_DSInit(&dStr);\n        int len = 0;\n        if (ce && ce>cb) {\n            len = (ce-cb-1);\n            cp = Jsi_DSAppendLen(&dStr, cb+1, len);\n        }\n        if (len <= 0 || Jsi_GetWide(interp, cp, &ul, 0) != JSI_OK || ul<0) \n            return Jsi_LogError(\"bad sub-array option: %s\", option);\n        len = (cb-option);\n        Jsi_DSSetLength(&dStr, 0);\n        cp = Jsi_DSAppendLen(&dStr, option, len);\n        specPtr = Jsi_OptionsFind(interp, specs, cp, flags);\n        Jsi_DSFree(&dStr);\n        if (!specPtr || !specPtr->init.OPT_CARRAY|| specPtr->id != JSI_OPTION_CUSTOM || specPtr->custom != Jsi_Opt_SwitchCArray) {\nbail:\n            return Jsi_LogError(\"unknown or bad array option: %s\", option);\n        }\n        cp = cb+1;\n        Jsi_OptionSpec *subSpec = specPtr->init.OPT_CARRAY;\n        int isize, size = specPtr->arrSize;\n        if (!subSpec || size<=0 || (isize=subSpec->size)<=0)\n            goto bail;\n        isize = isize/size;\n        uchar *s = (((uchar*)rec)+specPtr->offset + isize*ul);\n        if (ce[1] != '.' || !subSpec->data) {\n            if (Jsi_OptionsSet(interp, subSpec, (void*)s, subSpec->name, valuePtr, flags) != JSI_OK)\n                return JSI_ERROR;\n        } else {\n            if (Jsi_OptionsSet(interp, (Jsi_OptionSpec *)subSpec->data, (void*)s, ce+2, valuePtr, flags) != JSI_OK)\n                return JSI_ERROR;\n        }\n        return JSI_OK;\n    }\n    specPtr = Jsi_OptionsFind(interp, specs, option, flags);\n    if (!specPtr)\n        return JSI_ERROR;\n    return jsi_SetOption(interp, specPtr, option, record, valuePtr, flags, isSafe);\n}\n\nJsi_RC\njsi_GetOption(Jsi_Interp *interp, Jsi_OptionSpec *specPtr, void* record, const char *option, Jsi_Value **valuePtr, Jsi_Wide flags)\n{\n    char *ptr;\n    \n    if (specPtr == NULL) \n        return Jsi_LogError(\"no such option: %s\", option);\n    //isNull = ((*string == '\\0') && (specPtr->flags & JSI_OPTION_NULL_OK));\n    \n    ptr = (char *)record + specPtr->offset;\n    if (_JSICASTINT(specPtr->id)<0 || specPtr->id>=JSI_OPTION_END) \n        return Jsi_LogError(\"no such option: %s\", option);\n    if (specPtr->custom) {\n        Jsi_OptionCustom* cust = Jsi_OptionCustomBuiltin(specPtr->custom);\n        if (cust->formatProc)\n            return (*cust->formatProc) (interp, specPtr, valuePtr, NULL, record, flags);\n    }\n\n    switch (specPtr->id) {\n    case JSI_OPTION_BOOL:\n        Jsi_ValueMakeBool(interp, valuePtr,*(bool*)ptr );\n        break;\n    case JSI_OPTION_INT:\n        Jsi_ValueMakeNumber(interp, valuePtr, (Jsi_Number)(*(int *)ptr));\n        break;\n    case JSI_OPTION_UINT:\n        Jsi_ValueMakeNumber(interp, valuePtr, (Jsi_Number)(*(uint *)ptr));\n        break;\n    case JSI_OPTION_INT8:\n        Jsi_ValueMakeNumber(interp, valuePtr, (Jsi_Number)(*(int8_t *)ptr));\n        break;\n    case JSI_OPTION_INT16:\n        Jsi_ValueMakeNumber(interp, valuePtr, (Jsi_Number)(*(int16_t *)ptr));\n        break;\n    case JSI_OPTION_INT32:\n        Jsi_ValueMakeNumber(interp, valuePtr, (Jsi_Number)(*(int32_t *)ptr));\n        break;\n    case JSI_OPTION_INT64:\n        Jsi_ValueMakeNumber(interp, valuePtr, (Jsi_Number)(*(Jsi_Wide *)ptr));\n        break;\n    case JSI_OPTION_UINT8:\n        Jsi_ValueMakeNumber(interp, valuePtr, (Jsi_Number)(*(uint8_t *)ptr));\n        break;\n    case JSI_OPTION_UINT16:\n        Jsi_ValueMakeNumber(interp, valuePtr, (Jsi_Number)(*(uint16_t *)ptr));\n        break;\n    case JSI_OPTION_UINT32:\n        Jsi_ValueMakeNumber(interp, valuePtr, (Jsi_Number)(*(uint32_t *)ptr));\n        break;\n    case JSI_OPTION_UINT64:\n        Jsi_ValueMakeNumber(interp, valuePtr, (Jsi_Number)(*(uint64_t *)ptr));\n        break;\n    case JSI_OPTION_FLOAT:\n        Jsi_ValueMakeNumber(interp, valuePtr, (Jsi_Number)*(float *)ptr);\n        break;\n    case JSI_OPTION_DOUBLE:\n        Jsi_ValueMakeNumber(interp, valuePtr, (Jsi_Number)*(double *)ptr);\n        break;\n    case JSI_OPTION_LDOUBLE:\n        Jsi_ValueMakeNumber(interp, valuePtr, (Jsi_Number)*(ldouble *)ptr);\n        break;\n    case JSI_OPTION_NUMBER:\n        Jsi_ValueMakeNumber(interp, valuePtr, *(Jsi_Number *)ptr);\n        break;\n    case JSI_OPTION_SIZE_T:\n        Jsi_ValueMakeNumber(interp, valuePtr, *(size_t *)ptr);\n        break;\n    case JSI_OPTION_SSIZE_T:\n        Jsi_ValueMakeNumber(interp, valuePtr, *(ssize_t *)ptr);\n        break;\n    case JSI_OPTION_INTPTR_T:\n        Jsi_ValueMakeNumber(interp, valuePtr, *(intptr_t *)ptr);\n        break;\n    case JSI_OPTION_UINTPTR_T:\n        Jsi_ValueMakeNumber(interp, valuePtr, *(uintptr_t *)ptr);\n        break;\n    case JSI_OPTION_LONG:\n        Jsi_ValueMakeNumber(interp, valuePtr, *(long *)ptr);\n        break;\n    case JSI_OPTION_ULONG:\n        Jsi_ValueMakeNumber(interp, valuePtr, *(ulong *)ptr);\n        break;\n    case JSI_OPTION_SHORT:\n        Jsi_ValueMakeNumber(interp, valuePtr, *(short *)ptr);\n        break;\n    case JSI_OPTION_USHORT:\n        Jsi_ValueMakeNumber(interp, valuePtr, *(ushort *)ptr);\n        break;\n        \n    case JSI_OPTION_DSTRING:\n        Jsi_ValueFromDS(interp, (Jsi_DString*)ptr, valuePtr);\n        break;\n    \n    case JSI_OPTION_TIME_W: {\n        Jsi_DString dStr = {};\n        Jsi_DatetimeFormat(interp, (Jsi_Number)(*(Jsi_Wide*)ptr), \"\", 0, &dStr);\n        Jsi_ValueFromDS(interp, &dStr, valuePtr);\n        break;\n    }\n    case JSI_OPTION_TIME_D: {\n        Jsi_DString dStr = {};\n        Jsi_DatetimeFormat(interp, (Jsi_Number)(*(double*)ptr), \"\", 0, &dStr);\n        Jsi_ValueFromDS(interp, &dStr, valuePtr);\n        break;\n    }\n    case JSI_OPTION_TIME_T: {\n        Jsi_DString dStr = {};\n        Jsi_DatetimeFormat(interp, 1000LL* (Jsi_Number)*(time_t*)ptr, \"%Y-%m-%d %H:%M:%S\", 0, &dStr);\n        Jsi_ValueFromDS(interp, &dStr, valuePtr);\n        break;\n    }\n    case JSI_OPTION_STRBUF:\n        if (ptr)\n            Jsi_ValueMakeStringDup(interp, valuePtr, ptr);\n        else\n            Jsi_ValueMakeNull(interp, valuePtr);\n        break;\n\n    case JSI_OPTION_STRKEY:\n        ptr = *(char **)ptr;\n        if (ptr)\n            Jsi_ValueMakeStringDup(interp, valuePtr, ptr);\n        else\n            Jsi_ValueMakeNull(interp, valuePtr);\n        break;\n\n    case JSI_OPTION_STRING:\n    case JSI_OPTION_VAR:\n    case JSI_OPTION_FUNC:\n    case JSI_OPTION_USEROBJ:\n    case JSI_OPTION_OBJ:\n    case JSI_OPTION_VALUE:\n    case JSI_OPTION_REGEXP:\n    case JSI_OPTION_ARRAY:\n        if (*(Jsi_Value **)ptr)\n            Jsi_ValueCopy(interp, *valuePtr, *(Jsi_Value **)ptr);\n        else\n            Jsi_ValueMakeNull(interp, valuePtr);\n        break;\n\n    case JSI_OPTION_CUSTOM:\n        break;\n\n#ifdef __cplusplus\n    case JSI_OPTION_END:\n#else\n    default:\n#endif\n        Jsi_LogBug(\"invalid option id %d\", specPtr->id);\n        return JSI_ERROR;\n    }\n\n    return JSI_OK;\n}\n\nJsi_Value *\nJsi_OptionsCustomPrint(void* clientData, Jsi_Interp *interp, const char *name, void *rec, int offset)\n{\n    char *record = (char*)rec;\n    Jsi_Value *valuePtr;\n    valuePtr = *(Jsi_Value **)(record + offset);\n    return valuePtr;\n}\n\n\nJsi_RC\nJsi_OptionsGet(Jsi_Interp *interp, Jsi_OptionSpec *specs, void *rec, const char *option, Jsi_Value** valuePtr, Jsi_Wide flags)\n{\n    char *record = (char*)rec;\n    Jsi_OptionSpec *specPtr;\n    const char *cp = NULL, *cb = NULL;\n    if (option) {\n        cp = Jsi_Strchr(option, '.');\n        cb = Jsi_Strchr(option, '[');\n    }\n    if (cp && (!cb || cp<cb) ) {\n        Jsi_DString dStr;\n        int len = (cp-option);\n        Jsi_DSInit(&dStr);\n        cp = Jsi_DSAppendLen(&dStr, option, len);\n        specPtr = Jsi_OptionsFind(interp, specs, cp, flags);\n        Jsi_DSFree(&dStr);\n        if (!specPtr || !specPtr->data || specPtr->id != JSI_OPTION_CUSTOM || specPtr->custom != Jsi_Opt_SwitchSuboption) \n            return Jsi_LogError(\"unknown or bad sub-config option: %s\", option);\n        cp = option+len+1;\n        return Jsi_OptionsGet(interp, (Jsi_OptionSpec *)(specPtr->data), (void*)(((char*)rec)+specPtr->offset), cp, valuePtr, flags);\n    }\n    if (cb && cb != option) {\n        char *ce = Jsi_Strchr(option, ']');\n        Jsi_Wide ul;\n        Jsi_DString dStr;\n        Jsi_DSInit(&dStr);\n        int len = 0;\n        if (ce && ce>cb) {\n            len = (ce-cb-1);\n            cp = Jsi_DSAppendLen(&dStr, cb+1, len);\n        }\n        if (len <= 0 || Jsi_GetWide(interp, cp, &ul, 0) != JSI_OK || ul<0) \n            return Jsi_LogError(\"bad sub-array option: %s\", option);\n        len = (cb-option);\n        Jsi_DSSetLength(&dStr, 0);\n        cp = Jsi_DSAppendLen(&dStr, option, len);\n        specPtr = Jsi_OptionsFind(interp, specs, cp, flags);\n        Jsi_DSFree(&dStr);\n        if (!specPtr || !specPtr->init.OPT_CARRAY|| specPtr->id != JSI_OPTION_CUSTOM || specPtr->custom != Jsi_Opt_SwitchCArray) {\nbail:\n            return Jsi_LogError(\"unknown or bad array option: %s\", option);\n        }\n        cp = cb+1;\n        Jsi_OptionSpec *subSpec = specPtr->init.OPT_CARRAY;\n        int isize, size = specPtr->arrSize;\n        if (!subSpec || size<=0 || (isize=subSpec->size)<=0)\n            goto bail;\n        isize = isize/size;\n        uchar *s = (((uchar*)rec)+specPtr->offset + isize*ul);\n        if (ce[1] != '.' || !subSpec->data) {\n            if (Jsi_OptionsGet(interp, subSpec, (void*)s, subSpec->name, valuePtr, flags) != JSI_OK)\n                return JSI_ERROR;\n        } else {\n            if (Jsi_OptionsGet(interp, (Jsi_OptionSpec *)subSpec->data, (void*)s, ce+2, valuePtr, flags) != JSI_OK)\n                return JSI_ERROR;\n        }\n        return JSI_OK;\n    }\n\n    specPtr = Jsi_OptionsFind(interp, specs, option, flags);\n    if (specPtr == NULL || jsi_GetOption(interp, specPtr, record, option, valuePtr, flags) != JSI_OK) {\n        return JSI_ERROR;\n    }\n\n    return JSI_OK;\n\n}\n\nJsi_RC\nJsi_OptionsDump(Jsi_Interp *interp, Jsi_OptionSpec *specs, void *rec, Jsi_Value **ret, Jsi_Wide flags)\n{\n    char *record = (char*)rec;\n    Jsi_OptionSpec *specPtr = specs;\n    int len = 0, i = 0, count = 0;\n    if (!Jsi_OptionsValid(interp, specs))\n        return Jsi_LogError(\"invalid options\");\n    \n    while (specPtr->id>=JSI_OPTION_BOOL && specPtr->id < JSI_OPTION_END && specPtr->name) {\n        specPtr++;\n        len+=2;\n    }\n    if (!len)\n        return JSI_OK;\n    Jsi_Value *rv = Jsi_ValueMakeObject(interp, NULL, NULL);\n    Jsi_IncrRefCount(interp, rv);\n    Jsi_Obj *obj = rv->d.obj;\n    specPtr = specs;\n    while (specPtr->id>=JSI_OPTION_BOOL && specPtr->id < JSI_OPTION_END && specPtr->name) {\n        Jsi_Value  *vv = Jsi_ValueNew1(interp);\n        if (jsi_GetOption(interp, specPtr, record, NULL, &vv, flags) != JSI_OK) {\n            Jsi_DecrRefCount(interp, vv);\n            Jsi_DecrRefCount(interp, rv);\n            return JSI_ERROR;\n        }\n        if (flags&JSI_OPTS_VERBOSE) {\n            // dump: id,value,help,info,init\n            Jsi_Value *vrv = Jsi_ValueMakeObject(interp, NULL, NULL);\n            Jsi_IncrRefCount(interp, vrv);\n            Jsi_Obj *vobj = vrv->d.obj;\n            Jsi_ObjInsert(interp, vobj, \"value\", vv, 0);\n            Jsi_DecrRefCount(interp, vv);\n            vv = vrv;\n            jsi_DumpOptionSpec(interp, vobj, specPtr, 0);\n        }\n        Jsi_ObjInsert(interp, obj, specPtr->name, vv, 0);\n        Jsi_DecrRefCount(interp, vv);\n        count++;\n        i++;\n        specPtr++;\n    }\n    assert(specPtr->id == JSI_OPTION_END);\n    Jsi_ValueReplace(interp, ret, rv);\n    Jsi_DecrRefCount(interp, rv);\n    return JSI_OK;\n}\n\nint\nJsi_OptionsProcess(Jsi_Interp *interp, Jsi_OptionSpec *specs,  void *rec, Jsi_Value *args, Jsi_Wide flags)\n{\n    Jsi_OptionSpec *specPtr;\n    int count = 0;\n    char *record = (char*)rec;\n    Jsi_TreeEntry *tPtr;\n    Jsi_TreeSearch search;\n    Jsi_Obj *to;\n    bool isSafe = interp->isSafe;\n    if (!Jsi_OptionsValid(interp, specs))\n        return -1;\n\n    if (interp->subOpts.compat && !(flags&JSI_OPTS_FORCE_STRICT))\n        flags |=  JSI_OPTS_IGNORE_EXTRA;\n    specs = jsi_GetCachedOptionSpecs(interp, specs);\n    \n    if (args == NULL || args->vt == JSI_VT_NULL) {\n        for (specPtr = specs; specPtr->id>=JSI_OPTION_BOOL && specPtr->id < JSI_OPTION_END && specPtr->name; specPtr++) {\n            specPtr->flags &= ~JSI_OPT_IS_SPECIFIED;\n            if (jsi_SetOption(interp, specPtr, (char*)specPtr->name, record, NULL, flags, isSafe) != JSI_OK)\n                return -1;\n        }\n        assert(specPtr->id == JSI_OPTION_END);\n        return 0;\n    }\n    if (args->vt != JSI_VT_OBJECT || args->d.obj->ot != JSI_OT_OBJECT || args->d.obj->arr) {\n        Jsi_LogError(\"expected object\");\n        return -1;\n    }\n    to = args->d.obj;\n    int reqCnt = 0;\n    if ((JSI_OPTS_IS_UPDATE&flags)==0 && !(JSI_OPT_PASS2&flags)) {\n        for (specPtr = specs; specPtr->id>=JSI_OPTION_BOOL && specPtr->id < JSI_OPTION_END && specPtr->name; specPtr++) {\n            specPtr->flags &= ~JSI_OPT_IS_SPECIFIED;\n            if (specPtr->flags &  JSI_OPT_REQUIRED)\n                reqCnt++;\n        }\n        assert(specPtr->id == JSI_OPTION_END);\n    }\n        \n    for (tPtr = Jsi_TreeSearchFirst(to->tree, &search, 0, NULL);\n        tPtr != NULL; tPtr = Jsi_TreeSearchNext(&search)) {\n        \n        const char *arg;\n        Jsi_Value *optval;\n        count++;\n        arg =(char*) Jsi_TreeKeyGet(tPtr);\n        optval = (Jsi_Value*)Jsi_TreeValueGet(tPtr);\n\n        specPtr = Jsi_OptionsFind(interp, specs, arg, flags);\n        if (specPtr == NULL) {\n            if (flags&JSI_OPTS_IGNORE_EXTRA)\n                continue;\n            count = -1;\n            goto done;\n        }\n        if (((JSI_OPT_PASS2&flags) && !(JSI_OPT_PASS2&specPtr->flags))\n            || ((JSI_OPT_PASS2&specPtr->flags) && !(JSI_OPT_PASS2&flags)))\n            continue;\n            \n        if ((JSI_OPT_READ_ONLY&specPtr->flags)) {\n            Jsi_LogError(\"Error option is readonly: \\\"%.40s\\\"\", specPtr->name);\n            count = -1;\n            goto done;\n        }\n        if ((JSI_OPTS_IS_UPDATE&flags) && (JSI_OPT_INIT_ONLY&specPtr->flags)) {\n            Jsi_LogError(\"Error can not update option: \\\"%.40s\\\"\", specPtr->name);\n            count = -1;\n            goto done;\n        }\n        if (isSafe && (JSI_OPTS_IS_UPDATE&flags) && (JSI_OPT_LOCKSAFE&specPtr->flags)) {\n            Jsi_LogError(\"Error isSafe disallows updating option: \\\"%.40s\\\"\", specPtr->name);\n            count = -1;\n            goto done;\n        }\n\n        if (jsi_SetOption(interp, specPtr, (char*)arg, record, optval, flags, isSafe) != JSI_OK) {\n            count = -1;\n            goto done;\n        }\n \n        specPtr->flags |= JSI_OPT_IS_SPECIFIED;\n    }\n    if (reqCnt) {\n        for (specPtr = specs; specPtr->id>=JSI_OPTION_BOOL && specPtr->id < JSI_OPTION_END && specPtr->name; specPtr++) {\n            if (specPtr->flags &  JSI_OPT_REQUIRED &&\n                !(specPtr->flags&JSI_OPT_IS_SPECIFIED)) {\n\n                Jsi_LogError(\"Error required field not specified: \\\"%.40s\\\"\", specPtr->name);\n                count = -1;\n            }\n        }\n    }\n\ndone:\n    Jsi_TreeSearchDone(&search);\n    if (count<0 && !(JSI_OPTS_IS_UPDATE&flags))\n        Jsi_OptionsFree(interp, specs, rec, flags);\n    return count;\n}\n\nJsi_RC\nJsi_OptionsConf(Jsi_Interp *interp, Jsi_OptionSpec *specs,  void *rec, Jsi_Value *val, Jsi_Value **ret, Jsi_Wide flags)\n{\n    flags |= JSI_OPTS_IS_UPDATE;\n    if (!Jsi_OptionsValid(interp, specs))\n        return Jsi_LogError(\"invalid options\");\n    \n    if (!val)\n        return Jsi_OptionsDump(interp, specs, rec, ret, flags);\n    if (val->vt == JSI_VT_NULL)\n        return Jsi_OptionsDump(interp, specs, rec, ret, flags|JSI_OPTS_VERBOSE);\n    if (Jsi_ValueIsString(interp, val)) {\n        const char *cp = Jsi_ValueString(interp, val, NULL);\n        if (cp && *cp)\n            return Jsi_OptionsGet(interp, specs, rec, cp, ret, flags);\n        Jsi_Obj *sobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n        Jsi_Value *svalue = Jsi_ValueMakeObject(interp, NULL, sobj);\n        jsi_DumpOptionSpecs(interp, sobj, specs);\n        Jsi_ValueReplace(interp, ret, svalue);\n        return JSI_OK;\n    }\n    if (val->vt != JSI_VT_OBJECT) \n        return Jsi_LogError(\"expected string, object, or null\");\n    if (Jsi_OptionsProcess(interp, specs, rec, val, JSI_OPTS_IS_UPDATE|flags) < 0)\n        return JSI_ERROR;\n    return JSI_OK;\n}\n\nstatic const char **jsi_OptGetEnumList(Jsi_OptionSpec* spec) {\n    const char **list = (const char**)spec->data;\n    Jsi_OptionSpec* es=NULL;\n    int fflags = (spec->flags);\n    if (spec->id != JSI_OPTION_CUSTOM || spec->custom != Jsi_Opt_SwitchEnum)\n        return list;\n    if (list && (fflags & JSI_OPT_ENUM_SPEC)) {\n        es = (typeof(es))list;\n        while (es->id != JSI_OPTION_END)\n            es++;\n        list = es->init.STRKEY;\n    }\n    return list;\n}\n\nstatic void jsi_DumpCustomSpec(Jsi_Interp *interp, Jsi_Obj *nobj, Jsi_OptionSpec* spec)\n{\n    Jsi_OptionCustom* cspec = Jsi_OptionCustomBuiltin(spec->custom);\n    void *data = spec->data;\n    if (cspec->help) {\n        if (Jsi_Strchr(cspec->help, '\\n'))\n            Jsi_LogError(\"%s .help contains newline: %s\", cspec->name, cspec->help);\n        Jsi_ObjInsert(interp, nobj, \"help\", Jsi_ValueNewStringKey(interp, cspec->help),0);\n    }\n    if (cspec->info)\n        Jsi_ObjInsert(interp, nobj, \"info\", Jsi_ValueNewStringKey(interp, cspec->info),0);\n    Jsi_ObjInsert(interp, nobj, \"name\", Jsi_ValueNewStringKey(interp, cspec->name),0);\n\n    if (data && (spec->custom == Jsi_Opt_SwitchEnum || spec->custom == Jsi_Opt_SwitchBitset)) {\n        Jsi_Obj *sobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n        Jsi_Value *svalue = Jsi_ValueMakeObject(interp, NULL, sobj);\n        const char **lst = jsi_OptGetEnumList(spec);\n        int i = 0;\n        while (lst[i]) {\n            Jsi_ObjArrayAdd(interp, sobj, Jsi_ValueNewStringKey(interp, lst[i]));\n            i++;\n        }\n        Jsi_ObjInsert(interp, nobj, (spec->custom == Jsi_Opt_SwitchBitset?\"bitSet\":\"enumList\"), svalue, 0);\n    } else if (spec->custom == Jsi_Opt_SwitchSuboption) {\n        Jsi_OptionSpec* subSpec = (Jsi_OptionSpec*)data;\n        Jsi_Obj *sobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n        Jsi_Value *svalue = Jsi_ValueMakeObject(interp, NULL, sobj);\n        jsi_DumpOptionSpecs(interp, sobj, subSpec);\n        Jsi_ObjInsert(interp, nobj, \"subSpec\", svalue, 0);\n    }\n}\n\nstatic void jsi_DumpOptionSpec(Jsi_Interp *interp, Jsi_Obj *nobj, Jsi_OptionSpec* spec, int addName)\n{\n    if (addName)\n        Jsi_ObjInsert(interp, nobj, \"name\", Jsi_ValueNewStringKey(interp, spec->name),0);\n    if (spec->help) {\n        if (Jsi_Strchr(spec->help, '\\n'))\n            Jsi_LogError(\"%s .help contains newline: %s\", spec->name, spec->help);\n        Jsi_ObjInsert(interp, nobj, \"help\", Jsi_ValueNewStringKey(interp, spec->help),0);\n    }\n    if (spec->info)\n        Jsi_ObjInsert(interp, nobj, \"info\", Jsi_ValueNewStringKey(interp, spec->info),0);\n    Jsi_ObjInsert(interp, nobj, \"type\", Jsi_ValueNewStringKey(interp, jsi_OptionTypeStr(spec->id,0)),0);\n    Jsi_ObjInsert(interp, nobj, \"cName\", Jsi_ValueNewStringKey(interp, jsi_OptionTypeStr(spec->id,1)),0);\n    Jsi_ObjInsert(interp, nobj, \"initOnly\", Jsi_ValueNewBoolean(interp, (spec->flags & JSI_OPT_INIT_ONLY)!=0), 0);\n    Jsi_ObjInsert(interp, nobj, \"readOnly\", Jsi_ValueNewBoolean(interp, (spec->flags & JSI_OPT_READ_ONLY)!=0), 0);\n    Jsi_ObjInsert(interp, nobj, \"required\", Jsi_ValueNewBoolean(interp, (spec->flags & JSI_OPT_REQUIRED)!=0), 0);\n    Jsi_ObjInsert(interp, nobj, \"noCase\", Jsi_ValueNewBoolean(interp, (spec->flags & JSI_OPT_CUST_NOCASE)!=0), 0);\n    Jsi_ObjInsert(interp, nobj, \"size\", Jsi_ValueNewNumber(interp, (Jsi_Number)spec->size), 0);\n    if (spec->flags)\n        Jsi_ObjInsert(interp, nobj, \"flags\", Jsi_ValueNewNumber(interp, (Jsi_Number)spec->flags), 0);\n    if (spec->data) {\n        if (spec->id == JSI_OPTION_FUNC && spec->data) \n            Jsi_ObjInsert(interp, nobj, \"args\", Jsi_ValueNewStringDup(interp, (char*)spec->data), 0);\n        else if (spec->id == JSI_OPTION_CUSTOM && (spec->custom == Jsi_Opt_SwitchBitset ||\n            spec->custom == Jsi_Opt_SwitchEnum)) {\n            const char **list = jsi_OptGetEnumList(spec);\n            if (list)\n                Jsi_ObjInsert(interp, nobj, \"data\", Jsi_ValueNewArray(interp, list, -1), 0);\n        }\n    }\n    if (spec->id == JSI_OPTION_CUSTOM && spec->custom) {\n        Jsi_Obj *sobj = Jsi_ObjNewType(interp, JSI_OT_OBJECT);\n        Jsi_Value *cvalue = Jsi_ValueMakeObject(interp, NULL, sobj);\n        jsi_DumpCustomSpec(interp, sobj,  spec);\n        Jsi_ObjInsert(interp, nobj, \"customArg\", cvalue,0);\n        Jsi_OptionSpec *os = spec;\n        while (os->id != JSI_OPTION_END) os++;\n        Jsi_ObjInsert(interp, nobj, \"customArgHelp\", Jsi_ValueNewStringKey(interp, (os->help?os->help:\"\")), 0);\n        \n    }\n}\n\nvoid jsi_DumpOptionSpecs(Jsi_Interp *interp, Jsi_Obj *nobj, Jsi_OptionSpec* spec)\n{\n    int i = 0;\n    while (spec[i].id>=JSI_OPTION_BOOL && spec[i].id < JSI_OPTION_END) {\n        Jsi_Obj *sobj = Jsi_ObjNewType(interp, JSI_OT_OBJECT);\n        Jsi_Value *svalue = Jsi_ValueMakeObject(interp, NULL, sobj);\n        jsi_DumpOptionSpec(interp, sobj, spec+i, 1);\n        Jsi_ObjArrayAdd(interp, nobj, svalue);\n        i++;\n    }\n}\n\nstatic Jsi_RC jsi_ValueToVerify(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value *inValue, const char *inStr, void *record, Jsi_Wide flags)\n{\n    if (inStr)\n        return JSI_ERROR;\n    Jsi_Value **s = (Jsi_Value**)((char*)record) + spec->offset;\n    Jsi_ValueHandlerProc *vfunc = (Jsi_ValueHandlerProc*)spec->data;\n    if (!vfunc) \n        return Jsi_LogError(\"custom value spec did not set data: %s\", spec->name);\n    if (!inValue) {\n        if (*s)\n            Jsi_DecrRefCount(interp, *s);\n        *s = NULL;\n        return JSI_OK;\n    }\n    if (vfunc(interp, inValue, spec, record) != JSI_OK)\n        return JSI_ERROR;\n    *s = inValue;\n    if (*s)\n        Jsi_IncrRefCount(interp, *s);\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_VerifyToValue(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value **outValue, Jsi_DString *dStr, void *record, Jsi_Wide flags)\n{\n    if (dStr)\n        return JSI_ERROR;\n    Jsi_Value **s = (Jsi_Value**)(((char*)record) + spec->offset);\n    if (*s)\n        Jsi_ValueReplace(interp, outValue, *s);\n    return JSI_OK;\n}\n\nstatic void jsi_VerifyFree(Jsi_Interp *interp, Jsi_OptionSpec* spec, void *ptr)\n{\n    Jsi_Value **v = (Jsi_Value**)ptr;\n    if (v && *v)\n        Jsi_DecrRefCount(interp, *v);\n}\n\nstatic Jsi_OptionCustom jsi_OptSwitchValueVerify = {\n    .name=\"verify\", .parseProc=jsi_ValueToVerify, .formatProc=jsi_VerifyToValue, .freeProc=jsi_VerifyFree, .help=\"Verify that a value id is correct\"\n};\n\n\nstatic Jsi_RC ValueToCArray(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value *inValue, const char *inStr, void *record, Jsi_Wide flags)\n{\n    if (inStr)\n        return JSI_ERROR;\n    uchar *s = (uchar*)((char*)record) + spec->offset;\n    Jsi_OptionSpec *subSpec = spec->init.OPT_CARRAY;\n    int argc, i, isize, size = spec->arrSize;\n    if (!subSpec || size<=0 || (isize=subSpec->size)<=0)\n        goto bail;\n    isize = isize/size;\n    if (!Jsi_ValueIsArray(interp, inValue)) \n        return Jsi_LogError(\"expected array\");\n    argc = Jsi_ValueGetLength(interp, inValue);\n    if (argc != size) \n        return Jsi_LogError(\"array length %d was not %d\", argc, size);\n    for (i = 0; i<size; i++) {\n        Jsi_Value *v = Jsi_ValueArrayIndex(interp, inValue, i);\n        if (Jsi_OptionsSet(interp, subSpec, (void*)s, subSpec->name, v, 0) != JSI_OK)\n            return JSI_ERROR;\n        s += isize;\n    }\n    return JSI_OK;\nbail:\n    return Jsi_LogError(\"bad config\");\n}\n\nstatic Jsi_RC jsi_CArrayToValue(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value **outValue, Jsi_DString *dStr, void *record, Jsi_Wide flags)\n{\n    Jsi_Obj *obj = NULL;\n    if (dStr)\n        return JSI_ERROR;\n    uchar *s = (uchar*)((char*)record) + spec->offset;\n    Jsi_OptionSpec *subSpec = spec->init.OPT_CARRAY;\n    int i, cnt, isize, size = spec->arrSize;\n    if (!subSpec || size<=0 || (isize=subSpec->size)<=0)\n        goto bail;\n    isize = isize/size;\n#ifndef JSI_LITE_ONLY //TODO: already in lite #ifdef\n    obj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    cnt = 0;\n    for (i=0; i<size; i++) {\n        Jsi_Value *v = Jsi_ValueNew1(interp);\n        cnt++;\n        Jsi_RC rc = Jsi_OptionsGet(interp, subSpec, s, spec->name, &v, 0);\n        Jsi_ObjArrayAdd(interp, obj, v);\n        Jsi_DecrRefCount(interp, v);\n        if (JSI_OK != rc)\n            goto bail;\n        s += isize;\n    }\n    Jsi_ValueMakeArrayObject(interp, outValue, obj);\n#endif\n    return JSI_OK;\nbail:\n    if (obj)\n        Jsi_ObjFree(interp, obj);\n    Jsi_LogError(\"bad config\");\n    return JSI_ERROR;\n}\n\nstatic void jsi_CArrayFree(Jsi_Interp *interp, Jsi_OptionSpec* spec, void *ptr)\n{\n    /*Jsi_OptionSpec *subSpec = spec->init.ini.OPT_CARRAY; // TODO: ???\n    if (!subSpec) {\n        Jsi_Value **v = (Jsi_Value**)ptr;\n        if (v)\n            Jsi_DecrRefCount(interp, *v);\n    }\n    int i, isize, size = spec->asize;\n    if ((isize=subSpec->size)<=0)\n        return;\n    isize = isize/size;\n    uchar *s = (uchar*)ptr;\n    for (i=0; i<size; i++) {\n        Jsi_OptionsFree(interp, subSpec, s, 0);\n        s += isize;\n    }*/\n}\n\nstatic Jsi_OptionCustom jsi_OptSwitchCArray = {\n    .name=\"array\", .parseProc=ValueToCArray, .formatProc=jsi_CArrayToValue, .freeProc=jsi_CArrayFree, .help=\"Array of OPT types\"\n};\n#else\n\nstatic Jsi_OptionSpec * jsi_GetCachedOptionSpecs(Jsi_Interp *interp, const Jsi_OptionSpec *staticSpecs)\n{\n    return (Jsi_OptionSpec *)staticSpecs;\n}\n\n#endif\n\n\n/*\n *----------------------------------------------------------------------\n * Given the configuration specifications and one or more option\n * patterns (terminated by a NULL), indicate if any of the matching\n * configuration options has been reset.\n *\n * Results:\n *      Returns count of each options that has changed, 0 otherwise.\n *\n *----------------------------------------------------------------------\n */\nint Jsi_OptionsChanged(Jsi_Interp *interp, Jsi_OptionSpec *spec, const char *pattern, ...)\n{\n    va_list argList;\n    Jsi_OptionSpec *specPtr;\n    const char *option = pattern;\n    int cnt = 0;\n    \n    va_start(argList, pattern);\n    spec = jsi_GetCachedOptionSpecs(interp, spec);\n    do  {\n        for (specPtr = spec; specPtr->id>=JSI_OPTION_BOOL && specPtr->id < JSI_OPTION_END; specPtr++) {\n            if ((Jsi_GlobMatch(option, specPtr->name, 0)) &&\n                    (specPtr->flags & JSI_OPT_IS_SPECIFIED)) {\n                cnt++;\n            }\n        }\n        assert(specPtr->id == JSI_OPTION_END);\n\n    } while ((option = va_arg(argList, char *)) != NULL);\n    va_end(argList);\n    return cnt;\n}\n\nJsi_OptionSpec *\nJsi_OptionsDup(Jsi_Interp *interp, const Jsi_OptionSpec *staticSpecs)\n{\n    unsigned int entrySpace = sizeof(Jsi_OptionSpec);\n    const Jsi_OptionSpec *staticSpecPtr;\n    Jsi_OptionSpec *newSpecs;\n\n    for (staticSpecPtr=staticSpecs; staticSpecPtr->id>=JSI_OPTION_BOOL && staticSpecPtr->id<JSI_OPTION_END && staticSpecPtr->name;\n            staticSpecPtr++) {\n        entrySpace += sizeof(Jsi_OptionSpec);\n    }\n\n    newSpecs = (Jsi_OptionSpec *) Jsi_Malloc(entrySpace);\n    memcpy((void *) newSpecs, (void *) staticSpecs, entrySpace);\n    return newSpecs;\n}\n\n/* Free data items and reset values back to 0. */\nvoid\nJsi_OptionsFree(Jsi_Interp *interp, Jsi_OptionSpec *specs, void *rec, Jsi_Wide flags /*unused*/)\n{\n    Jsi_OptionSpec *specPtr;\n    char *record = (char*)rec;\n    for (specPtr = specs; specPtr->id>=JSI_OPTION_BOOL && specPtr->id < JSI_OPTION_END && specPtr->name; specPtr++) {\n        char *ptr = record + specPtr->offset;\n        if (specPtr->flags&JSI_OPT_NO_CLEAR)\n            continue;\n        if (specPtr->custom) {\n            Jsi_OptionCustom* cust = Jsi_OptionCustomBuiltin(specPtr->custom);\n            if (cust->freeProc != NULL) {\n                (*cust->freeProc)(interp, specPtr, (char **)ptr);\n                continue;\n            }\n        }\n\n        switch (specPtr->id) {\n#ifndef JSI_LITE_ONLY\n        case JSI_OPTION_VALUE:\n        case JSI_OPTION_STRING:\n        case JSI_OPTION_OBJ:\n        case JSI_OPTION_REGEXP:\n        case JSI_OPTION_ARRAY:\n        case JSI_OPTION_FUNC:\n        case JSI_OPTION_USEROBJ:\n        case JSI_OPTION_VAR:\n        {\n            Jsi_Value **vpp = (Jsi_Value**)ptr, *vPtr = *vpp;\n            if (vPtr && (!(specPtr->flags&JSI_OPT_NO_DUPVALUE)))\n                Jsi_DecrRefCount(interp, vPtr);\n            *vpp = 0;\n            break;\n        }\n#endif\n        case JSI_OPTION_STRKEY:\n            *(char**)ptr = 0;\n            break;\n        case JSI_OPTION_STRBUF:\n            *(char*)ptr = 0;\n            break;\n        case JSI_OPTION_DSTRING:\n            Jsi_DSFree((Jsi_DString *)ptr);\n            break;\n        case JSI_OPTION_TIME_T:\n            *(time_t*)ptr = 0;\n            break;\n        case JSI_OPTION_NUMBER:\n            *(Jsi_Number*)ptr = 0;\n            break;\n        case JSI_OPTION_FLOAT:\n            *(float*)ptr = 0;\n            break;\n        case JSI_OPTION_LDOUBLE:\n            *(ldouble*)ptr = 0;\n            break;\n        case JSI_OPTION_DOUBLE:\n        case JSI_OPTION_TIME_D:\n            *(double*)ptr = 0;\n            break;\n        case JSI_OPTION_TIME_W:\n            *(Jsi_Wide*)ptr = 0;\n            break;\n        case JSI_OPTION_INT8:  *(int8_t*)ptr = 0; break;\n        case JSI_OPTION_INT16: *(int16_t*)ptr = 0; break;\n        case JSI_OPTION_INT32: *(int32_t*)ptr = 0; break;\n        case JSI_OPTION_INT64: *(int64_t*)ptr = 0; break;\n        case JSI_OPTION_UINT8: *(uint8_t*)ptr = 0; break;\n        case JSI_OPTION_UINT16:*(uint16_t*)ptr = 0; break;\n        case JSI_OPTION_UINT32:*(uint32_t*)ptr = 0; break;\n        case JSI_OPTION_UINT64:*(uint64_t*)ptr = 0; break;\n        case JSI_OPTION_INT: *(int*)ptr = 0; break;\n        case JSI_OPTION_UINT: *(uint*)ptr = 0; break;\n        case JSI_OPTION_BOOL: *(bool*)ptr = 0; break;\n        case JSI_OPTION_CUSTOM:\n            break;\n        default:\n            if (specPtr->size>0)\n                memset(ptr, 0, specPtr->size);\n            break;\n        }\n    }\n}\n\nstatic Jsi_RC jsi_ValueToEnum(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value *inValue, const char *inStr, void *record, Jsi_Wide flags)\n{\n    int n = 0;\n    char *s = (char*)(((char*)record) + spec->offset);\n    const char **list = (const char **)spec->data;\n    Jsi_OptionSpec* es=NULL;\n    int fflags = (flags|spec->flags);\n    int cflags = (fflags&JSI_OPT_CUST_NOCASE?JSI_CMP_NOCASE:0);\n    if (fflags&JSI_OPT_ENUM_EXACT)\n        cflags |= JSI_CMP_EXACT;\n    if (list && (fflags & JSI_OPT_ENUM_SPEC)) {\n        es = (typeof(es))list;\n        while (es->id != JSI_OPTION_END) es++;\n        list = es->init.STRKEY;\n        es = (typeof(es))spec->data;\n    }\n    if (!list) \n        return Jsi_LogError(\"custom enum spec did not set data: %s\", spec->name);\n    if (inStr) {\n        if (JSI_OK != Jsi_GetIndex(interp, (char*)inStr, list, \"enum\", cflags, &n))\n            return JSI_ERROR;\n    } else\n#ifndef JSI_LITE_ONLY\n    if (JSI_OK != Jsi_ValueGetIndex(interp, inValue, list, \"enum\", cflags, &n))\n        return JSI_ERROR;\n\n#endif\n    if (fflags&JSI_OPT_ENUM_UNSIGNED) {\n        uint64_t u = (uint64_t)n;\n        if (es)\n            u = es[n].value;\n        switch (spec->size) {\n            case 1: *(uint8_t*)s = (uint8_t)u; break;\n            case 2: *(uint16_t*)s = (uint16_t)u; break;\n            case 4: *(uint32_t*)s = (uint32_t)u; break;\n            case 8: *(uint64_t*)s = (uint64_t)u; break;\n            default:\n                return Jsi_LogError(\"enum size must be 1, 2, 4, or 8: %s\", spec->name);\n        }\n    } else {\n        int64_t m = n;\n        if (es)\n            m = es[n].value;\n        switch (spec->size) {\n            case 1: *(int8_t*)s = (int8_t)m; break;\n            case 2: *(int16_t*)s = (int16_t)m; break;\n            case 4: *(int32_t*)s = (int32_t)m; break;\n            case 8: *(int64_t*)s = (int64_t)m; break;\n            default: \n                return Jsi_LogError(\"enum size must be 1, 2, 4, or 8: %s\", spec->name);\n        }\n    }\n    \n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_EnumToValue(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value **outValue, Jsi_DString *outStr, void *record, Jsi_Wide flags)\n{\n    uint i = 0, j, esiz = 0;\n    int64_t n;\n    char *s = (char*)(((char*)record) + spec->offset);\n    const char **list = (const char**)spec->data;\n    Jsi_OptionSpec* es=NULL, *esp = NULL;\n    int fflags = (flags|spec->flags);\n    int uflag = (fflags&JSI_OPT_ENUM_UNSIGNED);\n    if (list && (fflags & JSI_OPT_ENUM_SPEC)) {\n        esp = es = (typeof(es))list;\n        while (es->id != JSI_OPTION_END) es++;\n        list = es->init.STRKEY;\n        esiz = es->size;\n        es = (typeof(es))spec->data;\n    }\n    if (!list) \n        return Jsi_LogError(\"custom enum spec did not set data: %s\", spec->name);\n    if (outStr) {\n        if (uflag) {\n            switch (spec->size) {\n                case 1: n = *(uint8_t*)s; break;\n                case 2: n = *(uint16_t*)s; break;\n                case 4: n = *(uint32_t*)s; break;\n                case 8: n = *(uint64_t*)s; break;\n                default: \n                    return Jsi_LogError(\"enum size %d must be 1, 2, 4, or 8: %s\", spec->size, spec->name);\n            }\n        } else {\n            switch (spec->size) {\n                case 1: n = *(int8_t*)s; break;\n                case 2: n = *(int16_t*)s; break;\n                case 4: n = *(int32_t*)s; break;\n                case 8: n = *(int64_t*)s; break;\n                default: \n                    return Jsi_LogError(\"enum size %d must be 1, 2, 4, or 8: %s\", spec->size, spec->name);\n            }\n        }\n        if (spec->flags&JSI_OPT_FMT_NUMBER) {\n            Jsi_DSPrintf(outStr, \"%\" PRIu64, (uint64_t)n);\n            return JSI_OK;\n        }\n        \n        if (es) {\n            for (j=0; j<esiz && list[j]; j++) {\n                if (n == esp[j].value) {\n                    i = j;\n                    break;\n                }\n                if (j>=esiz)\n                    i = esiz;\n            }\n        } else\n            for (i=0; i<n && list[i]; i++) ; /* Look forward til n */\n        if (list[i])\n            Jsi_DSAppendLen(outStr, list[i], -1);\n        else if ((spec->flags&JSI_OPT_COERCE)) {\n            Jsi_DSPrintf(outStr, \"%\" PRIu64, (uint64_t)n);\n            return JSI_OK;\n        } else\n            return Jsi_LogError(\"enum has unknown value: %d\", *s);\n        return JSI_OK;\n    }\n#ifndef JSI_LITE_ONLY\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    Jsi_RC rc = jsi_EnumToValue(interp, spec, NULL, &dStr, record, flags);\n    if (rc == JSI_OK)\n        Jsi_ValueMakeStringKey(interp, outValue, Jsi_DSValue(&dStr));\n    Jsi_DSFree(&dStr);\n    return rc;\n#endif\n    return JSI_ERROR;\n}\n\nstatic Jsi_OptionCustom jsi_OptSwitchEnum = {\n    .name=\"enum\", .parseProc=jsi_ValueToEnum, .formatProc=jsi_EnumToValue, .freeProc=0, .help=\"one value from list\"\n};\n\n\nstatic Jsi_RC jsi_ValueToBitset(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value *inValue, const char *inStr, void *record, Jsi_Wide flags)\n{\n    // TODO: change this to not use byte instead of int...\n    int i, argc, n;\n    char *s =(((char*)record) + spec->offset);\n    char **argv;\n    const char *cp, **list = (const char**)spec->data;\n    uint64_t m = 0, im = 0;\n    int fflags = ((flags|spec->flags)&JSI_OPT_CUST_NOCASE?JSI_CMP_NOCASE:0);\n    if (!list) \n        return Jsi_LogError(\"custom enum spec did not set data: %s\", spec->name);\n    switch (spec->size) {\n        case 1: im = *(uint8_t*)s; break;\n        case 2: im = *(uint16_t*)s; break;\n        case 4: im = *(uint32_t*)s; break;\n        case 8: im = *(uint64_t*)s; break;\n        default: \n            return Jsi_LogError(\"bitset size must be 1, 2, 4, or 8: %s\", spec->name);\n    }\n\n#ifndef JSI_LITE_ONLY\n    if (!inStr && Jsi_ValueIsString(interp, inValue))\n        inStr = Jsi_ValueString(interp, inValue, NULL);\n#endif\n    if (inStr) {\n        if (*inStr == '+') {\n            inStr++;\n            m = im;\n        }\n        if (*inStr) {\n            Jsi_DString sStr;\n            Jsi_DSInit(&sStr);\n            Jsi_SplitStr(inStr, &argc, &argv, \",\", &sStr);\n            \n            for (i=0; i<argc; i++) {\n                int isnot = 0;\n                cp = argv[i];\n                if (*cp == '!') { isnot = 1; cp++; }\n                if (JSI_OK != Jsi_GetIndex(interp, cp, list, \"enum\", fflags, &n))\n                    return JSI_ERROR;\n                if (n >= (int)(spec->size*8)) \n                    return Jsi_LogError(\"list larger than field size: %s\", spec->name);\n                if (isnot)\n                    m &= ~(1<<n);\n                else\n                    m |= (1<<n);\n            }\n            Jsi_DSFree(&sStr);\n        }\n    } else {\n#ifndef JSI_LITE_ONLY\n        if (!inValue) {\n            *s = 0;\n            return JSI_OK;\n        }\n        if (Jsi_ValueIsObjType(interp, inValue, JSI_OT_OBJECT) && !Jsi_ValueIsArray(interp, inValue)) {\n            Jsi_TreeEntry *tPtr;\n            Jsi_TreeSearch search;\n            Jsi_Tree *tp = Jsi_TreeFromValue(interp, inValue);\n            \n            m = im;\n            for (tPtr = (tp?Jsi_TreeSearchFirst(tp, &search, 0, NULL):NULL);\n                tPtr != NULL; tPtr = Jsi_TreeSearchNext(&search)) {\n                cp =(char*) Jsi_TreeKeyGet(tPtr);\n                Jsi_Value *optval = (Jsi_Value*)Jsi_TreeValueGet(tPtr);\n                \n                if (JSI_OK != Jsi_GetIndex(interp, cp, list, \"bitset\", fflags, &n)) {\n                    Jsi_TreeSearchDone(&search);\n                    return JSI_ERROR;\n                }\n                if (!Jsi_ValueIsBoolean(interp, optval)) {\n                    Jsi_TreeSearchDone(&search);\n                    return Jsi_LogError(\"object member is not a bool: %s\", cp);\n                }\n                bool vb;\n                Jsi_ValueGetBoolean(interp, optval, &vb);\n                if (!vb)\n                    m &= ~(1<<n);\n                else\n                    m |= (1<<n);\n            }\n            if (tp)\n                Jsi_TreeSearchDone(&search);\n            *s = m;\n            return JSI_OK;\n        }\n        \n        if (!Jsi_ValueIsArray(interp, inValue)) \n            return Jsi_LogError(\"expected array or object\");\n        argc = Jsi_ValueGetLength(interp, inValue);\n        for (i=0; i<argc; i++) {\n            int isnot = 0;\n            Jsi_Value *v = Jsi_ValueArrayIndex(interp, inValue, i);\n            const char *cp = (v?Jsi_ValueString(interp, v, NULL):\"\");\n            if (!cp) \n                return Jsi_LogError(\"expected string\");\n            if (i == 0) {\n                if (*cp == '+' && !cp[1]) {\n                    m = im;\n                    continue;\n                }\n            }\n            if (*cp == '!') { isnot = 1; cp++; }\n            if (JSI_OK != Jsi_GetIndex(interp, cp, list, \"bitset\", fflags, &n))\n                return JSI_ERROR;\n            if (isnot)\n                m &= ~(1<<n);\n            else\n                m |= (1<<n);\n        }\n        *s = m;\n#endif\n    }\n    switch (spec->size) {\n        case 1: *(uint8_t*)s = (uint8_t)m; break;\n        case 2: *(uint16_t*)s = (uint16_t)m; break;\n        case 4: *(uint32_t*)s = (uint32_t)m; break;\n        case 8: *(uint64_t*)s = (uint64_t)m; break;\n    }\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_BitsetToValue(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value **outValue, Jsi_DString *outStr, void *record, Jsi_Wide flags)\n{\n    int i, n, cnt = 0, *s = (int*)(((char*)record) + spec->offset);\n    const char **list = (const char**)spec->data;\n    if (!list) \n        return Jsi_LogError(\"custom enum spec did not set data: %s\", spec->name);\n    if (outStr) {\n        n = *s;\n        for (i=0; list[i]; i++) {\n            if (i >= (int)(spec->size*8)) \n                return Jsi_LogError(\"list larger than field size: %s\", spec->name);\n            if (!(n & (1<<i)))\n                continue;\n            if (cnt++)\n                Jsi_DSAppendLen(outStr, \", \", 1);\n            Jsi_DSAppendLen(outStr, list[i], -1);\n        }\n        return JSI_OK;\n    }\n#ifndef JSI_LITE_ONLY\n    Jsi_Obj *obj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    n = *s;\n    for (i=0; list[i]; i++) {\n        Jsi_Value *v;\n        if (!(n&(1<<i))) continue;\n        cnt++;\n        v = Jsi_ValueMakeStringKey(interp, NULL, list[i]);\n        Jsi_ObjArrayAdd(interp, obj, v);\n    }\n    Jsi_ValueMakeArrayObject(interp, outValue, obj);\n#endif\n    return JSI_OK;\n}\n\nstatic Jsi_OptionCustom jsi_OptSwitchBitset = {\n    .name=\"bitset\", .parseProc=jsi_ValueToBitset, .formatProc=jsi_BitsetToValue, .freeProc=0, .help=\"An int field accessed a bit at a time\"\n};\n\n#ifndef JSI_LITE_ONLY\n/* Scanning function */\nstatic Jsi_RC jsi_ValueToSubopt(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value *inValue, const char *inStr, void *record, Jsi_Wide flags)\n{\n    if (inStr)\n        return JSI_ERROR;\n    char *s = ((char*)record) + spec->offset;\n    Jsi_OptionSpec *subspec = (Jsi_OptionSpec *)spec->data;\n  \n    if (spec == subspec) \n        return Jsi_LogError(\"subspec was recursive\");\n    if (!subspec) \n        return Jsi_LogError(\"custom suboption spec did not set data: %s\", spec->name);\n    if (inValue && Jsi_ValueIsNull(interp, inValue) == 0 &&\n        (Jsi_ValueIsObjType(interp, inValue, JSI_OT_OBJECT)==0 || inValue->d.obj->isarrlist)) \n        return Jsi_LogError(\"expected object\");\n    return (Jsi_OptionsProcess(interp, subspec, s, inValue, flags)<0 ? JSI_ERROR : JSI_OK);\n}\n\n/* Printing function. */\nstatic Jsi_RC jsi_SuboptToValue(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value **outValue, Jsi_DString *outStr, void *record, Jsi_Wide flags)\n{\n    if (outStr)\n        return JSI_ERROR;\n    char *s = ((char*)record) + spec->offset;\n    Jsi_OptionSpec *subspec = (Jsi_OptionSpec *)spec->data;\n    if (spec == subspec) \n        return Jsi_LogError(\"recursive subspec not allowed\");\n    if (!subspec) \n        return Jsi_LogError(\"custom suboption spec did not set data: %s\", spec->name);\n    return Jsi_OptionsDump(interp, subspec, s, outValue, flags);\n}\n\nstatic void jsi_SuboptFree(Jsi_Interp *interp, Jsi_OptionSpec* spec, void *ptr)\n{\n    Jsi_OptionSpec *subspec = (Jsi_OptionSpec *)spec->data;\n    Jsi_OptionsFree(interp, subspec, ptr, 0);\n}\n\nstatic Jsi_OptionCustom jsi_OptSwitchSuboption = {\n    .name=\"suboption\", .parseProc=jsi_ValueToSubopt, .formatProc=jsi_SuboptToValue, .freeProc=jsi_SuboptFree,\n};\n\n/* Parent Function: Scanning function */\nstatic Jsi_RC jsi_ValueToParentFunc(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value *inValue, const char *inStr, void *record, Jsi_Wide flags)\n{\n    if (inStr)\n        return JSI_ERROR;\n    Jsi_Value *val;\n    Jsi_Value **v = (Jsi_Value **)(((char*)record) + spec->offset);\n    const char *s, *subspec = (const char *)spec->data;\n    Jsi_Interp *pinterp = interp->parent;\n    if (!pinterp)\n        return Jsi_LogError(\"no parent interp\");\n    if (!subspec) \n        return Jsi_LogError(\"custom parentfunc spec did not set data: %s\", spec->name);\n    if (!inValue || Jsi_ValueIsNull(interp, inValue)) {\n        if (*v) Jsi_DecrRefCount(pinterp, *v);\n        *v = NULL;\n        return JSI_OK;\n    }\n    if (!(s=Jsi_ValueString(interp, inValue, NULL))) {\n        return Jsi_LogError(\"expected string or null\");\n    }\n    val = Jsi_NameLookup(pinterp, s);\n    if (!val)\n        return Jsi_LogError(\"value not found in parent: %s\", s);\n    if (!Jsi_ValueIsFunction(pinterp, val))\n        return Jsi_LogError(\"expected a func value\");\n    if (spec->data && (interp->strict || pinterp->strict))\n        if (!jsi_FuncIsNoop(pinterp, val)\n            && !jsi_FuncArgCheck(pinterp, val->d.obj->d.fobj->func, (char*)spec->data)) \n            return Jsi_LogError(\"failed setting func pointer for %s\", spec->name);\n\n    *v = val;\n    Jsi_IncrRefCount(pinterp, val);\n    return JSI_OK;\n}\n\n/* Printing function. */\nstatic Jsi_RC jsi_ParentFuncToValue(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value **outValue, Jsi_DString *outStr, void *record, Jsi_Wide flags)\n{\n    if (outStr)\n        return JSI_ERROR;\n    Jsi_Value **v = (Jsi_Value **)(((char*)record) + spec->offset);\n    //const char *s, *subspec = (const char *)spec->data;\n    if (!*v) {\n        Jsi_ValueMakeNull(interp, outValue);\n        return JSI_OK;\n    }\n    if (!interp->parent)\n        return Jsi_LogError(\"no parent interp\");\n    if (spec->data) {\n        Jsi_DString dStr = {};\n        Jsi_DSPrintf(&dStr, \"func(%s)\", (char*)spec->data);\n        Jsi_ValueFromDS(interp, &dStr, outValue);\n    }\n    return JSI_OK;\n}\n\nstatic void jsi_ParentFuncFree(Jsi_Interp *interp, Jsi_OptionSpec* spec, void *ptr)\n{\n    Jsi_Value **v = (Jsi_Value **)(((char*)ptr));\n    if (!interp->parent) return;\n    if (*v)\n        Jsi_DecrRefCount(interp->parent, *v);\n    *v = NULL;\n}\n\nstatic Jsi_OptionCustom jsi_OptSwitchParentFunc = {\n    .name=\"funcinparent\", .parseProc=jsi_ValueToParentFunc, .formatProc=jsi_ParentFuncToValue, .freeProc=jsi_ParentFuncFree,\n};\n\n/* Scanning function */\nstatic Jsi_RC jsi_ValueToBitfield(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value *inValue,\n    const char *inStr, void *record, Jsi_Wide flags)\n{\n    Jsi_csgset *bsget = spec->init.OPT_BITS;\n    Jsi_Interp *d = interp;\n    int idx = spec->idx;\n    uchar *data = (uchar*)record;\n    Jsi_Number num;\n    Jsi_OptionSpec* enumSpec = (typeof(enumSpec))spec->data;\n\n    if (!d || !bsget || idx<0) \n        return Jsi_LogBug(\"invalid bitfield\");\n    if (enumSpec) {\n        struct numStruct { int64_t numVal; } nval = {};\n        Jsi_OptionSpec eSpec[] = {\n            JSI_OPT(CUSTOM, typeof(nval), numVal, .help=spec->help, .flags=JSI_OPT_ENUM_SPEC,\n                .custom=Jsi_Opt_SwitchEnum, .data=(void*)enumSpec, .info=0, .tname=spec->tname, .value=0, .bits=0, .boffset=8*sizeof(int64_t) ),\n            JSI_OPT_END(typeof(nval))\n        };\n        if (JSI_OK != jsi_ValueToEnum(interp, eSpec, inValue, inStr, (void*)&nval, flags))\n            return JSI_ERROR;\n        num = (Jsi_Number)nval.numVal;\n    } else if (inStr) {\n        if (Jsi_GetDouble(interp, inStr, &num) != JSI_OK)\n            return JSI_ERROR;\n    } else {\n        if (inValue && !Jsi_ValueIsNumber(interp, inValue)) \n            return JSI_ERROR;\n        Jsi_ValueGetNumber(interp, inValue, &num);\n    }\n    int64_t inum = (int64_t)num;\n    return (*bsget)(interp, data, &inum, spec, idx, 1);\n}\n\n/* Printing function. */\nstatic Jsi_RC jsi_BitfieldToValue(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value **outValue,\n    Jsi_DString *outStr, void *record, Jsi_Wide flags)\n{\n    Jsi_csgset *bsget = spec->init.OPT_BITS;\n    Jsi_Interp *d = interp;\n    int idx = spec->idx;\n    uchar *data = (uchar*)record;\n    int64_t inum;\n    Jsi_OptionSpec* enumSpec = (typeof(enumSpec))spec->data;\n\n    if (!d || !bsget || idx<0) \n        return Jsi_LogBug(\"invalid bitfield\");\n    Jsi_RC rc = (*bsget)(interp, data, &inum, spec, idx, 0);\n    if (rc != JSI_OK)\n        return JSI_ERROR;\n\n    if (enumSpec) {\n        struct numStruct { int64_t numVal; } nval = { inum };\n        Jsi_OptionSpec eSpec[] = {\n            JSI_OPT(CUSTOM, struct numStruct, numVal, .help=spec->help, .flags=JSI_OPT_ENUM_SPEC, .custom=Jsi_Opt_SwitchEnum,\n            .data=(void*)enumSpec, .info=0, .tname=spec->tname, .value=0, .bits=0, .boffset=8*sizeof(int64_t) ), //TODO: extra\n            JSI_OPT_END(struct numStruct)\n        };\n        if (JSI_OK != jsi_EnumToValue(interp, eSpec, outValue, outStr, (void*)&nval, flags))\n            return JSI_ERROR;\n    } else if (outStr) {\n        char obuf[100];\n        snprintf(obuf, sizeof(obuf), \"%\" PRId64, inum);\n        Jsi_DSAppend(outStr, obuf, NULL);\n    } else {\n        Jsi_Number num = (Jsi_Number)inum;\n        Jsi_ValueMakeNumber(interp, outValue, num);\n    }\n    return JSI_OK;\n}\n\nstatic Jsi_OptionCustom jsi_OptSwitchBitfield = {\n    .name=\"bitfield\", .parseProc=jsi_ValueToBitfield, .formatProc=jsi_BitfieldToValue\n};\n\n/* Scanning function */\nstatic Jsi_RC jsi_ValueToNull(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value *inValue, const char *inStr, void *record, Jsi_Wide flags)\n{\n    return JSI_OK;\n}\n\n/* Printing function. */\nstatic Jsi_RC jsi_NullToValue(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value **outValue, Jsi_DString *outStr, void *record, Jsi_Wide flags)\n{\n    Jsi_ValueMakeNull(interp, outValue);\n    return JSI_OK;\n}\n\nstatic Jsi_OptionCustom jsi_OptSwitchNull = {\n    .name=\"null\", .parseProc=jsi_ValueToNull, .formatProc=jsi_NullToValue\n};\n\n#endif\n\ntypedef struct {\n    Jsi_OptionInitVal init;\n} jsi_IniValStruct;\n\nstatic Jsi_OptionCustom* custOpts[] = { NULL,\n    &jsi_OptSwitchEnum, \n    &jsi_OptSwitchBitset,\n#ifndef JSI_LITE_ONLY\n    &jsi_OptSwitchSuboption, \n    &jsi_OptSwitchBitfield,\n    &jsi_OptSwitchValueVerify,\n    &jsi_OptSwitchCArray,\n    &jsi_OptSwitchNull,\n    &jsi_OptSwitchParentFunc\n#else\n    NULL,\n    NULL,\n    NULL,\n    NULL,\n    NULL,\n    NULL\n#endif\n};\n\nJsi_OptionCustom* Jsi_OptionCustomBuiltin(Jsi_OptionCustom* cust) {\n    if ((uintptr_t)cust < (uintptr_t)(sizeof(custOpts)/sizeof(custOpts[0])))\n        return custOpts[(uintptr_t)cust];\n    return cust;\n}\n\nJsi_RC jsi_InitOptions(Jsi_Interp *interp, int release) {\n    if (release) return JSI_OK;\n    assert((sizeof(jsi_OptTypeInfo)/sizeof(jsi_OptTypeInfo[0])) == (JSI_OPTION_END+1));\n    int i;\n    for (i=JSI_OPTION_BOOL; i<JSI_OPTION_END; i++)\n        assert(jsi_OptTypeInfo[i].id == (Jsi_OptionId)i);\n    return JSI_OK;\n}\n", "#ifndef JSI_LITE_ONLY\n#ifndef JSI_AMALGAMATION\n#include \"jsiInt.h\"\n#endif\n\n// SCOPESTRS\n\nJsi_ScopeStrs *jsi_ScopeStrsNew()\n{\n    Jsi_ScopeStrs *ret = (Jsi_ScopeStrs *)Jsi_Calloc(1, sizeof(*ret));\n    return ret;\n}\n\nvoid jsi_ScopeStrsFree(Jsi_Interp *interp, Jsi_ScopeStrs *ss)\n{\n    if (!ss) return;\n    int i;\n    for (i=0; i<ss->count; i++)\n        if (ss->args[i].defValue)\n            Jsi_DecrRefCount(interp, ss->args[i].defValue);\n    if (ss->args)\n        Jsi_Free(ss->args);\n    Jsi_Free(ss);\n}\n\nvoid jsi_ScopeStrsPush(Jsi_Interp *interp, Jsi_ScopeStrs *ss, const char *string, int argType)\n{\n    if (ss->count >= ss->_size) {\n        int osz = ss->_size, isold = (ss->args!=NULL);\n        ss->_size += ALLOC_MOD_SIZE;\n        if (!isold)\n            ss->args = (jsi_ArgValue*)Jsi_Calloc(ss->_size,  sizeof(ss->args[0]));\n        else {\n            ss->args = (jsi_ArgValue*)Jsi_Realloc(ss->args, (ss->_size) * sizeof(ss->args[0]));\n            memset(ss->args+osz, 0, (ss->_size-osz)* sizeof(ss->args[0]));\n        }\n    }\n    ss->args[ss->count].name = (char*)Jsi_KeyAdd(interp, string);\n    ss->args[ss->count].type = argType;\n    if (argType)\n        ss->typeCnt++;\n    ss->count++;\n}\n\nstatic Jsi_ScopeStrs *jsi_ScopeStrsDup(jsi_Pstate *ps, Jsi_ScopeStrs *ss)\n{\n    Jsi_ScopeStrs *n = jsi_ScopeStrsNew();\n    int i;\n    if (!ss) return n;\n    *n = *ss;\n    if (!ss->args) return n;\n    n->args = (jsi_ArgValue*)Jsi_Calloc(n->count, sizeof(ss->args[0]));\n    n->_size = n->count;\n    memcpy(n->args, ss->args, (n->count *  sizeof(ss->args[0])));\n    for (i = 0; i < ss->count; ++i) {\n        if (ss->args[i].defValue)\n            Jsi_IncrRefCount(ps->interp, ss->args[i].defValue);\n    }\n    return n;\n}\n\nconst char *jsi_ScopeStrsGet(Jsi_ScopeStrs *ss, int i)\n{\n    if (i < 0 || i >= ss->count)\n        return NULL;\n    return ss->args[i].name;\n}\n\nJsi_ScopeStrs *jsi_ArgsOptAdd(jsi_Pstate *pstate, Jsi_ScopeStrs *a)\n{\n    jsi_PstatePush(pstate);\n    return a;\n}\n\nJsi_ScopeStrs *jsi_argInsert(jsi_Pstate *pstate, Jsi_ScopeStrs *a, const char *name, Jsi_Value *defValue, jsi_Pline *lPtr, bool prepend)\n{\n    Jsi_Interp *interp = pstate->interp;\n    if (!a)\n        a = jsi_ScopeStrsNew();\n    pstate->args = a;\n    int atyp = pstate->argType;\n    if (defValue) {\n        int vt = defValue->vt;\n        if (vt == JSI_VT_NULL)\n            vt = JSI_TT_NULL;\n        else if (vt == JSI_VT_UNDEF && defValue->d.num==1)\n            vt = JSI_TT_VOID;\n        else if (vt == JSI_VT_OBJECT && defValue->d.obj->ot==JSI_OT_STRING)\n            vt = JSI_TT_STRING;\n        else\n            vt = (1<<defValue->vt);\n        atyp |= vt;\n    }\n    jsi_ScopeStrsPush(interp, a, name, atyp);\n    pstate->argType = 0;\n    a->args[a->count-1].defValue = defValue;\n    a->argCnt++;\n    if (prepend) {\n        jsi_ArgValue t;\n        int i, end = a->argCnt-1;\n        t = a->args[end];\n        for (i=end-1; i>=0; i--)\n            a->args[i+1]=a->args[i];\n        a->args[0] = t;\n    }\n    jsi_Pline *opl = interp->parseLine;\n    interp->parseLine = lPtr;\n    if (defValue) {\n        Jsi_IncrRefCount(interp, defValue);\n        if (a->firstDef==0)\n            a->firstDef = a->argCnt;\n            if (atyp)\n                jsi_ArgTypeCheck(interp, atyp, defValue, \"default value\", name, a->argCnt, NULL, 1);\n    } else {\n        if (a->firstDef && (interp->typeCheck.run || interp->typeCheck.all) )\n            Jsi_LogWarn(\"expected default value in argument list: \\\"%s\\\"\", name);\n    }\n    interp->parseLine = opl;\n    return a;\n}\n\n\n// PSTATE \n\nvoid jsi_PstatePush(jsi_Pstate *ps)\n{\n    Jsi_Interp *interp = ps->interp;\n    if (interp->cur_scope >= (int)(JSI_MAX_SCOPE - 1)) {\n        Jsi_LogBug(\"Scope chain too short\");\n        return;\n    }\n    interp->cur_scope++;\n}\n\nvoid jsi_PstatePop(jsi_Pstate *ps)\n{\n    Jsi_Interp *interp = ps->interp;\n    if (interp->cur_scope <= 0) {\n        Jsi_LogBug(\"No more scope to pop\");\n        return;\n    }\n    jsi_ScopeStrsFree(interp, interp->scopes[interp->cur_scope]);\n    interp->scopes[interp->cur_scope] = NULL;\n    interp->cur_scope--;\n}\n\nvoid jsi_PstateAddVar(jsi_Pstate *ps, jsi_Pline *line, const char *str)\n{\n    Jsi_Interp *interp = ps->interp;\n    int i;\n    if (interp->scopes[interp->cur_scope] == NULL)\n        interp->scopes[interp->cur_scope] = (Jsi_ScopeStrs *)jsi_ScopeStrsNew();\n    \n    for (i = 0; i < interp->scopes[interp->cur_scope]->count; ++i) {\n        if (Jsi_Strcmp(str, interp->scopes[interp->cur_scope]->args[i].name) == 0) {\n            Jsi_Interp *interp = ps->interp;\n            if (interp && interp->strict) {\n                interp->parseLine = line;\n                Jsi_LogWarn(\"duplicate var: %s\", str);\n                interp->parseLine = NULL;\n            }\n            return;\n        }\n    }\n    jsi_ScopeStrsPush(ps->interp, interp->scopes[interp->cur_scope], str, JSI_VT_UNDEF);\n}\n\nJsi_ScopeStrs *jsi_ScopeGetVarlist(jsi_Pstate *ps)\n{\n    Jsi_Interp *interp = ps->interp;\n    return jsi_ScopeStrsDup(ps, interp->scopes[interp->cur_scope]);\n}\n\n#if 0\nstatic int fastVarFree(Jsi_Interp *interp, void *ptr) {\n    FastVar *fv = ptr;\n    Jsi_Value *v = fv->var.lval;\n    if (v) {\n        //printf(\"FV FREE: %p (%d/%d)\\n\", fv, v->refCnt, v->vt == JSI_VT_OBJECT?v->d.obj->refcnt:-99);\n        //Jsi_DecrRefCount(interp, v);\n    }\n    return JSI_OK;\n}\n#endif\n\n\nstatic Jsi_RC jsi_StringFree(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *d) {\n    Jsi_String *s = (Jsi_String *)d;\n    if (s->flags&1)\n        Jsi_Free(s->str);\n    Jsi_Free(s);\n    return JSI_OK;\n}\n\njsi_Pstate *jsi_PstateNew(Jsi_Interp *interp)\n{\n    jsi_Pstate *ps = (jsi_Pstate *)Jsi_Calloc(1,sizeof(*ps));\n    SIGINIT(ps,PARSER);\n    ps->lexer = (jsi_Lexer*)Jsi_Calloc(1,sizeof(*ps->lexer));\n    ps->lexer->pstate = ps;\n    ps->interp = interp;\n    ps->fastVarTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, NULL /*fastVarFree*/);\n    ps->strTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, jsi_StringFree);\n    return ps;\n}\n\nconst char *jsi_PstateGetFilename(jsi_Pstate *ps)\n{\n    Jsi_Interp *interp = ps->interp;\n    return interp->curFile;\n}\n\nvoid jsi_PstateClear(jsi_Pstate *ps)\n{\n    jsi_Lexer* l = ps->lexer;\n    if (l->ltype == LT_FILE)\n    {\n        if (l->d.fp)\n            Jsi_Close(ps->interp, l->d.fp);\n        l->d.fp = NULL;\n    }\n    if (l->ltype == LT_STRING)\n    {\n        l->d.str = NULL;\n    }\n    l->ltype = LT_NONE;\n    l->last_token = 0;\n    l->cur_line = 1;\n    l->cur_char = 0;\n    l->cur = 0;\n    ps->err_count = 0;\n}\n\nint jsi_PstateSetFile(jsi_Pstate *ps, Jsi_Channel fp, int skipbang)\n{\n    jsi_Lexer *l = ps->lexer;\n    jsi_PstateClear(ps);\n    l->ltype = LT_FILE;\n    l->d.fp = fp;\n    Jsi_Rewind(ps->interp, fp);\n    if (skipbang) {\n        char buf[1000];\n        if (Jsi_Gets(ps->interp, fp, buf, 1000) && (buf[0] != '#' || buf[1] != '!')) {\n            Jsi_Rewind(ps->interp, fp);\n        }\n    }\n            \n    return JSI_OK;\n}\n\n\nint jsi_PstateSetString(jsi_Pstate *ps, const char *str)\n{\n    Jsi_Interp *interp = ps->interp;\n    jsi_Lexer *l = ps->lexer;\n    jsi_PstateClear(ps);\n    l->ltype = LT_STRING;\n    Jsi_HashEntry *hPtr = Jsi_HashEntryNew(interp->codeTbl, (void*)str, NULL);\n    assert(hPtr);\n    l->d.str = (char*)Jsi_HashKeyGet(hPtr);\n    return JSI_OK;\n}\n\nvoid jsi_PstateFree(jsi_Pstate *ps)\n{\n    /* TODO: when do we free opcodes */\n    jsi_PstateClear(ps);\n    Jsi_Free(ps->lexer);\n    if (ps->opcodes)\n        jsi_FreeOpcodes(ps->opcodes);\n    if (ps->hPtr)\n        Jsi_HashEntryDelete(ps->hPtr);\n    if (ps->argsTbl)\n        Jsi_HashDelete(ps->argsTbl);\n    if (ps->fastVarTbl)\n        Jsi_HashDelete(ps->fastVarTbl);\n    if (ps->strTbl)\n        Jsi_HashDelete(ps->strTbl);\n    if (ps->last_exception)\n        Jsi_DecrRefCount(ps->interp, ps->last_exception);\n    _JSI_MEMCLEAR(ps);\n    Jsi_Free(ps);\n}\n\n#endif\n", "#ifndef JSI_LITE_ONLY\n#ifndef JSI_AMALGAMATION\n#include \"jsiInt.h\"\n#endif\n/* TODO: handle delete */\n\n#define ChkRegexp(_this, funcPtr, dest) \\\n    if (_this->vt == JSI_VT_OBJECT && _this->d.obj->ot == JSI_OT_FUNCTION &&  \\\n       _this->d.obj->__proto__ == interp->RegExp_prototype->d.obj->__proto__ ) { \\\n        skip = 1; \\\n        dest = Jsi_ValueArrayIndex(interp, args, 0); \\\n    } else if (_this->vt != JSI_VT_OBJECT || _this->d.obj->ot != JSI_OT_REGEXP) { \\\n        return Jsi_LogError(\"apply Regexp.%s to a non-regex object\", funcPtr->cmdSpec->name); \\\n    } else  { \\\n        dest = _this; \\\n    }\n\nvoid Jsi_RegExpFree(Jsi_Regex* re) {\n    regfree(&re->reg);\n    _JSI_MEMCLEAR(re);\n    Jsi_Free(re);\n}\n\nJsi_Regex* Jsi_RegExpNew(Jsi_Interp *interp, const char *regtxt, int eflag)\n{\n    bool isNew;\n    Jsi_HashEntry *hPtr;\n    int flag = REG_EXTENDED;\n    char c, *cm, *ce;\n    const char *cp;\n    Jsi_Regex *re;\n    if (interp->subOpts.noRegex) {\n        Jsi_LogError(\"regex disabled for interp\");\n        return NULL;\n    }\n\n    eflag |= JSI_REG_STATIC;\n    if (!regtxt[0])\n        return NULL;\n    hPtr = Jsi_HashEntryFind(interp->regexpTbl, regtxt);\n    if (hPtr) {\n        re = (Jsi_Regex*)Jsi_HashValueGet(hPtr);\n        if (JSI_REG_STATIC & eflag)\n            re->eflags |= JSI_REG_STATIC;\n        return re;\n    }\n    cp = regtxt+1;\n    if (regtxt[0] != '/')\n        return NULL;\n    ce = (char*)Jsi_Strrchr(cp, '/');\n    if (ce == cp || !ce)\n        return NULL;\n    cm = ce + 1;    \n    while (*cm) {\n        c = *cm++;\n        if (c == 'i') flag |= REG_ICASE;\n        else if (c == 'g') eflag |= JSI_REG_GLOB;\n        else if (c == 'm') { /* PERL NON-STANDARD */\n            eflag |= JSI_REG_NEWLINE;\n            flag |= REG_NEWLINE;\n        }\n#ifdef RE_DOT_NEWLINE\n        else if (c == 's') { /* PERL NON-STANDARD */\n            eflag |= JSI_REG_DOT_NEWLINE;\n            flag |= RE_DOT_NEWLINE;\n        }\n#endif\n    }\n    *ce = 0;\n    regex_t reg;\n    if (regcomp(&reg, cp, flag)) {\n        *ce++ = '/';\n        Jsi_LogError(\"Invalid regex string '%s'\", cp);\n        return NULL;\n    }\n    *ce++ = '/';\n    re = (Jsi_Regex*)Jsi_Calloc(1, sizeof(Jsi_Regex));\n    SIGINIT(re, REGEXP);\n    assert (re);\n    re->reg = reg;\n    re->eflags = eflag;\n    re->flags = flag;\n    hPtr = Jsi_HashEntryNew(interp->regexpTbl, regtxt, &isNew);\n    assert(hPtr);\n    Jsi_HashValueSet(hPtr, re);\n    re->pattern = (char*)Jsi_HashKeyGet(hPtr);\n    return re;\n\n}\n\nJsi_RC jsi_RegExpValueNew(Jsi_Interp *interp, const char *regtxt, Jsi_Value *ret)\n{\n    \n    Jsi_DString dStr = {};\n    Jsi_DSAppend(&dStr, \"/\", regtxt, \"/\", NULL);\n    Jsi_Regex *re = Jsi_RegExpNew(interp, Jsi_DSValue(&dStr), 0);\n    Jsi_DSFree(&dStr);\n    if (re == NULL)\n        return JSI_ERROR;\n    Jsi_Obj *o = Jsi_ObjNewType(interp, JSI_OT_REGEXP);\n    Jsi_ValueMakeObject(interp, &ret, o);\n    ret->d.obj->d.robj = re;\n    ret->d.obj->ot = JSI_OT_REGEXP;\n    return JSI_OK;\n}\n\n\nstatic Jsi_RC RegExp_constructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Value *target;\n    \n    if (Jsi_FunctionIsConstructor(funcPtr))\n        target = _this;\n    else {\n        Jsi_Obj *o = Jsi_ObjNewType(interp, JSI_OT_REGEXP);\n        Jsi_ValueMakeObject(interp, ret, o);\n        target = *ret;\n    }\n    \n    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n    const char *regtxt = \"\";\n    const char *mods = NULL;\n    if (v) {\n        if (v->vt == JSI_VT_OBJECT && v->d.obj->ot == JSI_OT_REGEXP) {\n            Jsi_ValueCopy(interp,target, v);\n            return JSI_OK;\n        } else if (!(regtxt = Jsi_ValueString(interp, v, NULL))) {\n            return JSI_ERROR;\n        }\n    }\n    Jsi_Value *f = Jsi_ValueArrayIndex(interp, args, 1);\n    if (f)\n        mods = Jsi_ValueString(interp, f, NULL);\n    Jsi_DString dStr = {};\n    Jsi_DSAppend(&dStr, \"/\", regtxt, \"/\", mods, NULL);\n    Jsi_Regex *re = Jsi_RegExpNew(interp, Jsi_DSValue(&dStr), 0);\n    Jsi_DSFree(&dStr);\n    if (re == NULL)\n        return JSI_ERROR;\n    target->d.obj->d.robj = re;\n    target->d.obj->ot = JSI_OT_REGEXP;\n    return JSI_OK;\n}\n\n// Preform regexc setting *rc to 1 if match occurs.  If dStr != NULL, it is used to return matching strings.\nJsi_RC Jsi_RegExpMatch(Jsi_Interp *interp, Jsi_Value *pattern, const char *v, int *rc, Jsi_DString *dStr)\n{\n    Jsi_Regex *re;\n    int regexec_flags = 0;\n    if (rc)\n        *rc = 0;\n    if (pattern == NULL || pattern->vt != JSI_VT_OBJECT || pattern->d.obj->ot != JSI_OT_REGEXP) \n        return Jsi_LogError(\"expected pattern\");\n    re = pattern->d.obj->d.robj;\n    regex_t *reg = &re->reg;\n    \n    regmatch_t pos = {};\n    if (dStr)\n        Jsi_DSInit(dStr);\n        \n    int r  = regexec(reg, v, 1, &pos, regexec_flags);\n\n    if (r >= REG_BADPAT) {\n        char buf[100];\n\n        regerror(r, reg, buf, sizeof(buf));\n        return Jsi_LogError(\"error while matching pattern: %s\", buf);\n    }\n    if (r != REG_NOMATCH) {\n        if (rc) *rc = 1;\n        if (dStr && pos.rm_so >= 0 && pos.rm_eo >= 0 &&  pos.rm_eo >= pos.rm_so)\n            Jsi_DSAppendLen(dStr, v + pos.rm_so, pos.rm_eo - pos.rm_so);\n    }\n    \n    return JSI_OK;\n}\n\n\n\nJsi_RC jsi_RegExpMatches(Jsi_Interp *interp, Jsi_Value *pattern, const char *str, int n, Jsi_Value *ret, int *ofs, bool match)\n{\n    Jsi_Regex *re;\n    int regexec_flags = 0;\n    Jsi_Value *seq = pattern;\n\n    if (seq == NULL || seq->vt != JSI_VT_OBJECT || seq->d.obj->ot != JSI_OT_REGEXP) {\n        Jsi_ValueMakeNull(interp, &ret);\n        return JSI_OK;\n    }\n    re = seq->d.obj->d.robj;\n    regex_t *reg = &re->reg;\n    \n    regmatch_t pos[MAX_SUBREGEX] = {};\n    int num_matches = 0, r;\n    int isglob = (re->eflags&JSI_REG_GLOB);\n    Jsi_Obj *obj;\n    \n    do {\n        r = regexec(reg, str, MAX_SUBREGEX, pos, regexec_flags);\n\n        if (r >= REG_BADPAT) {\n            char buf[JSI_BUFSIZ];\n\n            regerror(r, reg, buf, sizeof(buf));\n            return Jsi_LogError(\"error while matching pattern: %s\", buf);\n        }\n        if (r == REG_NOMATCH) {\n            if (num_matches == 0) {\n                Jsi_ValueMakeNull(interp, &ret);\n                return JSI_OK;\n            }\n            break;\n        }\n\n        if (num_matches == 0) {\n            obj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n            obj->__proto__ = interp->Array_prototype;\n            Jsi_ValueMakeObject(interp, &ret, obj);\n            Jsi_ObjSetLength(interp, ret->d.obj, 0);\n        }\n    \n        int i;\n        for (i = 0; i < MAX_SUBREGEX; ++i) {\n            if (pos[i].rm_so <= 0 && pos[i].rm_eo <= 0)\n                break;\n            if (i && pos[i].rm_so == pos[i-1].rm_so && pos[i].rm_eo == pos[i-1].rm_eo)\n                continue;\n    \n            int olen = -1;\n            char *ostr = jsi_SubstrDup(str, -1, pos[i].rm_so, pos[i].rm_eo - pos[i].rm_so, &olen);\n            Jsi_Value *val = Jsi_ValueMakeBlob(interp, NULL, (uchar*)ostr, olen);\n            if (ofs)\n                *ofs = pos[i].rm_eo;\n            Jsi_ValueInsertArray(interp, ret, num_matches, val, 0);\n            num_matches++;\n            if ( match && isglob)\n                break;\n        }\n        if (num_matches && match && !isglob)\n            return JSI_OK;\n        if (num_matches == 1 && (ofs || !isglob))\n            break;\n        \n        str += pos[0].rm_eo;\n        n -= pos[0].rm_eo;\n\n        regexec_flags |= REG_NOTBOL;\n    } while (n && pos[0].rm_eo>0);\n    \n    return JSI_OK;\n}\n\nJsi_RC Jsi_RegExpMatches(Jsi_Interp *interp, Jsi_Value *pattern, const char *str, int slen, Jsi_Value *ret)\n{\n    return jsi_RegExpMatches(interp, pattern, str, slen, ret, NULL, 0);\n}\n\n\n#define FN_regexec JSI_INFO(\"\\\nPerform regexp match checking.  Returns the array of matches.\\\nWith the global flag g, sets lastIndex and returns next match.\")\nstatic Jsi_RC RegexpExecCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int skip = 0;\n    Jsi_Value *v;\n    ChkRegexp(_this, funcPtr, v);\n    /* TODO: add lastIndex support. */\n    int slen;\n    char *str = Jsi_ValueString(interp,Jsi_ValueArrayIndex(interp, args, skip), &slen);\n    if (!str) \n        return Jsi_LogError(\"expected string\");\n    if (v == NULL || v->vt != JSI_VT_OBJECT || v->d.obj->ot != JSI_OT_REGEXP) \n        return Jsi_LogError(\"expected pattern\");\n    Jsi_Regex *re = v->d.obj->d.robj;\n    int isglob = (re->eflags&JSI_REG_GLOB);\n    Jsi_Value *l = NULL;\n    Jsi_Number lv = 0;\n    if (isglob) {\n        l = Jsi_ValueObjLookup(interp, v, \"lastIndex\", 0);\n        if (l && Jsi_ValueGetNumber(interp, l, &lv) != JSI_OK) \n            return Jsi_LogError(\"lastIndex not a number\");\n        if (l)\n            re->lastIndex = (int)lv;\n    }\n    int ofs = 0;\n    Jsi_RC rc = jsi_RegExpMatches(interp, v, re->lastIndex<slen?str+re->lastIndex:\"\", -1, *ret, isglob?&ofs:NULL, 0);\n    if (isglob) {\n        if (rc != JSI_OK)\n            return rc;\n        re->lastIndex += ofs;\n        if (Jsi_ValueIsNull(interp, *ret))\n            re->lastIndex = 0;\n        lv = (Jsi_Number)re->lastIndex;\n        if (!l)\n            Jsi_ValueInsert(interp, v, \"lastIndex\", Jsi_ValueNewNumber(interp, lv), JSI_OM_DONTDEL);\n        else if (l->vt == JSI_VT_NUMBER)\n            l->d.num = lv;\n        else if (l->vt == JSI_VT_OBJECT && l->d.obj->ot == JSI_OT_NUMBER)\n            l->d.obj->d.num = lv;\n    }\n    return rc;\n}\n\nstatic Jsi_RC RegexpTestCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int skip = 0, rc = 0;\n    Jsi_Value *v;\n    ChkRegexp(_this, funcPtr, v);\n    char *str = Jsi_ValueString(interp,Jsi_ValueArrayIndex(interp, args, skip), NULL);\n    if (!str) \n        return Jsi_LogError(\"expected string\");\n    if (Jsi_RegExpMatch(interp, v, str, &rc, NULL) != JSI_OK)\n        return JSI_ERROR;    \n    Jsi_ValueMakeBool(interp, ret, rc != 0);\n    return JSI_OK;\n}\n\nstatic Jsi_CmdSpec regexpCmds[] = {\n    { \"RegExp\",  RegExp_constructor,    1, 2, \"val:regexp|string, flags:string\", .help=\"Create a regexp object\", .retType=(uint)JSI_TT_REGEXP, .flags=JSI_CMD_IS_CONSTRUCTOR  },\n    { \"exec\",    RegexpExecCmd,         1, 1, \"val:string\", .help=\"return matching string\", .retType=(uint)JSI_TT_ARRAY|JSI_TT_OBJECT|JSI_TT_NULL, 0, .info=FN_regexec  },\n    { \"test\",    RegexpTestCmd,         1, 1, \"val:string\", .help=\"test if a string matches\", .retType=(uint)JSI_TT_BOOLEAN },\n    { NULL, 0,0,0,0,.help=\"Commands for managing reqular expression objects\" }\n};\n\nJsi_RC jsi_InitRegexp(Jsi_Interp *interp, int release)\n{\n    if (!release)\n        interp->RegExp_prototype = Jsi_CommandCreateSpecs(interp, \"RegExp\", regexpCmds, NULL, JSI_CMDSPEC_ISOBJ);\n    return JSI_OK;\n}\n\n#endif\n", "#define JSI_SQLITE_DB_VFS \"SQLITE_DB_VFS\"\n\n#ifndef JSI_AMALGAMATION\n#ifdef JSI_MEM_DEBUG\n#include \"jsiInt.h\"\n#else\n#include \"jsi.h\"\n#ifdef JSI_SQLITE_SHARED\nJSI_EXTENSION_INI\n#endif\n#endif\n#endif\n\ntypedef struct jsi_DbVfs {\n    int sig; \n    int (*dbcQuery)(Jsi_Db *jdb, Jsi_CDataDb *dbc, const char *query);\n    void *(*dbHandle)(Jsi_Interp *interp, Jsi_Db* jdb);\n    Jsi_Db* (*dbNew)(const char *zFile, int inFlags /* JSI_DBI_* */);\n} jsi_DbVfs;\n\njsi_DbVfs SqliteDbVfs = {\n    0x1234, &Jsi_DbQuery, &Jsi_DbHandle, Jsi_DbNew\n};\n\n\n#if JSI__SQLITE==1\n/*\n** 2001 September 15\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** A JSI (Javascript) Interface to SQLite.\n*/\n\ntypedef enum { SQLITE_SIG_DB = 0xbeefdead, SQLITE_SIG_FUNC, SQLITE_SIG_EXEC, SQLITE_SIG_STMT } Sqlite_Sig;\n\n#define SQLSIGASSERT(s,n) assert(s->sig == SQLITE_SIG_##n)\n#ifndef _JSI_MEMCLEAR\n#ifndef NDEBUG\n#define _JSI_MEMCLEAR(s) memset(s, 0, sizeof(*s));\n#else\n#define _JSI_MEMCLEAR(s)\n#endif\n#endif\n#ifndef JSI_DB_DSTRING_SIZE\n#define JSI_DB_DSTRING_SIZE 2000\n#endif\n\n#ifndef JSI_DBQUERY_BEGIN_STR\n#define JSI_DBQUERY_BEGIN_STR \"BEGIN;\"\n#endif\n#ifndef JSI_DBQUERY_ROLLBACK_STR\n#define JSI_DBQUERY_ROLLBACK_STR \"ROLLBACK;\"\n#endif\n#ifndef JSI_DBQUERY_COMMIT_STR\n#define JSI_DBQUERY_COMMIT_STR \"COMMIT;\"\n#endif\n\n#include <errno.h>\n\n/*\n** Some additional include files are needed if this file is not\n** appended to the amalgamation.\n*/\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n#include <limits.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <inttypes.h>\n\n#ifndef SQLITE_AMALGAMATION\n#include \"sqlite3.h\"\n#endif\n\n\n#ifndef NUM_PREPARED_STMTS\n#define NUM_PREPARED_STMTS 100\n#endif\n#ifndef MAX_PREPARED_STMTS\n#define MAX_PREPARED_STMTS 10000\n#endif\n\n#ifndef JSI_DBQUERY_PRINTF\n#define JSI_DBQUERY_PRINTF(fmt, ...) fprintf(stderr, fmt, ##__VA_ARGS__)\n#endif\n/*\n** When JSI uses UTF-8 and SQLite is configured to use iso8859, then we\n** have to do a translation when going between the two.  Set the\n** UTF_TRANSLATION_NEEDED macro to indicate that we need to do\n** this translation.\n*/\n#if defined(JSI_UTF_MAX) && !defined(SQLITE_UTF8)\n# define UTF_TRANSLATION_NEEDED 1\n#endif\n\ntypedef struct db_ObjCmd {\n  int activeCnt;  /* Count of active objects. */ \n  int newCnt;  /* Total number of new. */ \n} db_ObjCmd;\n\n#ifndef JSI_LITE_ONLY\nstatic db_ObjCmd dbObjCmd = {};\n\nstatic Jsi_OptionSpec db_ObjCmd_Specs[] =\n{\n    JSI_OPT(INT,   db_ObjCmd, activeCnt, .help=\"Number of active objects\"),\n    JSI_OPT(INT,   db_ObjCmd, newCnt,    .help=\"Number of new calls\"),\n    JSI_OPT_END(db_ObjCmd, .help=\"Options for Sqlite module\")\n};\n#endif\n\n/*\n** New SQL functions can be created as JSI scripts.  Each such function\n** is described by an instance of the following structure.\n*/\ntypedef struct SqlFunc SqlFunc;\nstruct SqlFunc {\n    Sqlite_Sig sig;\n    Jsi_Interp  *interp;    /* The JSI interpret to execute the function */\n    Jsi_Value   *tocall;    /* Callee */\n    char        *pScript;   /* The char* representation of the script */\n    Jsi_DString dScript;\n    char        *zName;     /* Name of this function */\n    SqlFunc     *pNext;     /* Next function on the list of them all */\n};\n\n/*\n** New collation sequences function can be created as JSI scripts.  Each such\n** function is described by an instance of the following structure.\n*/\ntypedef struct SqlCollate SqlCollate;\nstruct SqlCollate {\n    Sqlite_Sig sig;\n    Jsi_Interp  *interp;   /* The JSI interpret to execute the function */\n    Jsi_Value   *zScript;  /* The function to be run */\n    Jsi_Db      *jdb;\n    SqlCollate  *pNext;    /* Next function on the list of them all */\n};\n\n/*\n** Prepared statements are cached for faster execution.  Each prepared\n** statement is described by an instance of the following structure.\n*/\ntypedef struct SqlPreparedStmt SqlPreparedStmt;\nstruct SqlPreparedStmt {\n    Sqlite_Sig sig;\n    int deleting;\n    SqlPreparedStmt *pNext;  /* Next in linked list */\n    SqlPreparedStmt *pPrev;  /* Previous on the list */\n    sqlite3_stmt    *pStmt;  /* The prepared statement */\n    uint nSql;                /* chars in zSql[] */\n    const char *zSql;        /* Text of the SQL statement */\n    Jsi_HashEntry *entry;\n    Jsi_ListEntry *elPtr;\n    //int nParm;               /* Size of apParm array */\n    //Jsi_Value **apParm;      /* Array of referenced object pointers */\n};\n\n#ifndef JSI_LITE_ONLY\nstatic const char *sqexecFmtStrs[] = {\n    \"rows\", \"arrays\", \"array1d\", \"list\", \"column\", \"json\",\n    \"json2\", \"html\", \"csv\", \"insert\", \"line\", \"tabs\", \"none\", NULL\n};\nstatic const char *mtxStrs[] = { \"default\", \"none\", \"full\", NULL };\nstatic const char *trcModeStrs[] = {\"eval\", \"delete\", \"prepare\", \"step\", NULL}; // Bit-set packed into an int.\nstatic const char *dbTypeChkStrs[] = { \"convert\", \"warn\", \"error\", \"disable\", NULL };\nstatic const char *objSqlModeStrs[] = { \"getSql\", \"noTypes\", \"noDefaults\", \"nullDefaults\", NULL };\n#endif\n\nenum {OBJMODE_SQLONLY=0x1, OBJMODE_NOTYPES=0x2, OBJMODE_NODEFAULTS=0x4, OBJMODE_NULLDEFAULTS=0x8};\nenum {TMODE_EVAL=0x1, TMODE_DELETE=0x2, TMODE_PREPARE=0x4, TMODE_STEP=0x4};\ntypedef enum { MUTEX_DEFAULT, MUTEX_NONE, MUTEX_FULL } Mutex_Type;\ntypedef enum { dbTypeCheck_Cast, dbTypeCheck_Warn, dbTypeCheck_Error, dbTypeCheck_None } dbTypeCheck_Mode;\ntypedef enum {\n    _JSI_EF_ROWS, _JSI_EF_ARRAYS, _JSI_EF_ARRAY1D, _JSI_EF_LIST, _JSI_EF_COLUMN, _JSI_EF_JSON,\n    _JSI_EF_JSON2, _JSI_EF_HTML, _JSI_EF_CSV, _JSI_EF_INSERT, _JSI_EF_LINE, _JSI_EF_TABS, _JSI_EF_NONE\n} Output_Mode;\n\ntypedef struct QueryOpts {\n    Sqlite_Sig sig;\n    Jsi_Value *callback, *values;\n    int limit, objOpts;\n    Output_Mode mode;\n    dbTypeCheck_Mode typeCheck;\n    bool mapundef, nocache, headers, retChanged, echo;\n    const char *separator;\n    const char *nullvalue;\n    const char *table;\n    const char *cdata; // Name of C data array to use for query.\n    const char *objName;\n    Jsi_Value *width;\n} QueryOpts;\n\n\n/*\n** There is one instance of this structure for each SQLite database\n** that has been opened by the SQLite JSI interface.\n*/\ntypedef struct Jsi_Db {\n    Sqlite_Sig sig;\n    sqlite3 *db;               /* The \"real\" database structure. MUST BE FIRST */\n    Jsi_Interp *interp;        /* The interpreter used for this database */\n    db_ObjCmd *_;              // Module data.\n    Jsi_Value *onBusy;               /* The busy callback routine */\n    Jsi_Value *onCommit;             /* The commit hook callback routine */\n    Jsi_Value *onTrace;              /* The trace callback routine */\n    Jsi_Value *onProfile;            /* The profile callback routine */\n    Jsi_Value *onProgress;           /* The progress callback routine */\n    Jsi_Value *onAuth;               /* The authorization callback routine */\n    Jsi_Value *onUpdate;      /* Update hook script (if any) */\n    Jsi_Value *onRollback;    /* Rollback hook script (if any) */\n    Jsi_Value *onWalHook;        /* Wal hook script (if any) */\n    Jsi_Value *onNeedCollate;   /* Collation needed script */\n    Jsi_Value *onUnlock;    /* Unlock notify script (if any) */\n    Jsi_Value *udata;\n    int disableAuth;           /* Disable the authorizer if it exists */\n    uint progressSteps;\n    SqlFunc *pFunc;            /* List of SQL functions */\n    SqlCollate *pCollate;      /* List of SQL collation functions */\n    int rc;                    /* Return code of most recent sqlite3_exec() */\n    Jsi_Hash *stmtHash;        /* Hash table for statements. */\n    Jsi_List *stmtCache;\n    int stmtCacheMax;               /* The next maximum number of stmtList */\n    int stmtCacheCnt;                 /* Number of statements in stmtList */\n    /*IncrblobChannel *pIncrblob; * Linked list of open incrblob channels */\n    Jsi_Hash *strKeyTbl;       /* Used with JSI_LITE_ONLY */\n    bool noJsonConv;\n    bool bindWarn;\n    bool forceInt;\n    bool readonly;\n    bool noCreate;\n    bool noConfig;\n    bool load;\n    bool echo;\n    int timeout;\n    int stepCnt, sortCnt;          /* Statistics for most recent operation */\n    int nTransaction;          /* Number of nested [transaction] methods */\n    int errCnt;               /* Count of errors. */\n    Jsi_Value *vfs;\n    int hasOpts;\n    Jsi_Obj *fobj;\n    QueryOpts queryOpts, *optPtr;\n    int objId;\n    Mutex_Type mutex;\n    uint64_t lastInsertId;\n    int debug, changeCnt, changeCntAll, errorCode;\n    Jsi_Value *version;\n    Jsi_DString name;\n    Jsi_Hash *typeNameHash;\n} Jsi_Db;\n\nstatic const int jsi_DbPkgVersion = 2;\n/*\n** Structure used with dbEvalXXX() functions:\n**\n**   dbEvalInit(interp,)\n**   dbEvalStep()\n**   dbEvalFinalize()\n**   dbEvalRowInfo()\n**   dbEvalColumnValue()\n*/\n#define SQL_MAX_STATIC_TYPES 100\ntypedef struct DbEvalContext {\n    Jsi_Db *jdb;                /* Database handle */\n    Jsi_DString *dSql;               /* Object holding string zSql */\n    const char *zSql;               /* Remaining SQL to execute */\n    SqlPreparedStmt *pPreStmt;      /* Current statement */\n    int nCol;                       /* Number of columns returned by pStmt */\n    char **apColName;             /* Array of column names */\n    int *apColType;\n    char staticColNames[JSI_BUFSIZ];  /* Attempt to avoid mallocing space for name storage. */\n    int staticColTypes[SQL_MAX_STATIC_TYPES];\n    Jsi_Value *tocall;\n    Jsi_Value *ret;\n    /*OBS */\n    Jsi_Value *pArray;              /* Name of array variable */\n    Jsi_Value *pValVar;             /* Name of list for values. */\n    int nocache;\n} DbEvalContext;\n\n#ifndef JSI_LITE_ONLY\n\nstatic Jsi_RC dbIsNumArray(Jsi_Interp *interp, Jsi_Value *value, Jsi_OptionSpec* spec, void *record);\n\n\nstatic Jsi_OptionSpec ExecFmtOptions[] =\n{\n    JSI_OPT(FUNC,   QueryOpts, callback,    .help=\"Function to call with each row result\", .flags=0, .custom=0, .data=(void*)\"values:object\" ),\n    JSI_OPT(STRKEY, QueryOpts, cdata,       .help=\"Name of Cdata array object to use\"),\n    JSI_OPT(BOOL,   QueryOpts, echo,        .help=\"Output query string to log\"),\n    JSI_OPT(BOOL,   QueryOpts, headers,     .help=\"First row returned contains column labels\"),\n    JSI_OPT(INT,    QueryOpts, limit,       .help=\"Maximum number of returned values\"),\n    JSI_OPT(BOOL,   QueryOpts, mapundef,    .help=\"In variable bind, map an 'undefined' var to null\"),\n    JSI_OPT(CUSTOM, QueryOpts, mode,        .help=\"Set output mode of returned data\", .flags=0, .custom=Jsi_Opt_SwitchEnum,  .data=(void*)sqexecFmtStrs),\n    JSI_OPT(BOOL,   QueryOpts, nocache,     .help=\"Disable query cache\"),\n    JSI_OPT(STRKEY, QueryOpts, nullvalue,   .help=\"Null string output (for non js/json mode)\"),\n    JSI_OPT(STRKEY, QueryOpts, objName,     .help=\"Object var name for CREATE/INSERT: replaces %s with fields in query\" ),\n    JSI_OPT(CUSTOM, QueryOpts, objOpts,     .help=\"Options for objName\", .flags=0,  .custom=Jsi_Opt_SwitchBitset,  .data=objSqlModeStrs),\n    JSI_OPT(BOOL,   QueryOpts, retChanged,  .help=\"Query returns value of sqlite3_changed()\"),\n    JSI_OPT(STRKEY, QueryOpts, separator,   .help=\"Separator string (for csv and text mode)\"),\n    JSI_OPT(CUSTOM, QueryOpts, typeCheck,   .help=\"Type check mode (warn)\", .flags=0, .custom=Jsi_Opt_SwitchEnum, .data=(void*)dbTypeChkStrs),\n    JSI_OPT(STRKEY, QueryOpts, table,       .help=\"Table name for mode=insert\"),\n    JSI_OPT(ARRAY,  QueryOpts, values,      .help=\"Values for ? bind parameters\" ),\n    JSI_OPT(CUSTOM, QueryOpts, width,       .help=\"In column mode, set column widths\", .flags=0, .custom=Jsi_Opt_SwitchValueVerify, .data=(void*)dbIsNumArray),\n    JSI_OPT_END(QueryOpts, .help=\"Options for query()\")\n};\n\n#ifndef jsi_IIOF\n#define jsi_IIOF .flags=JSI_OPT_INIT_ONLY\n#define jsi_IIRO .flags=JSI_OPT_READ_ONLY\n#endif\nstatic Jsi_OptionSpec SqlOptions[] =\n{\n    JSI_OPT(BOOL,   Jsi_Db, bindWarn,   .help=\"Treat failed variable binds as a warning\", jsi_IIOF),\n    JSI_OPT(INT,    Jsi_Db, changeCnt,  .help=\"The number of rows modified, inserted, or deleted by last command\"),\n    JSI_OPT(INT,    Jsi_Db, changeCntAll,.help=\"Total number of rows modified, inserted, or deleted since db opened\"),\n    JSI_OPT(CUSTOM, Jsi_Db, debug,      .help=\"Enable debug trace for various operations\", .flags=0,  .custom=Jsi_Opt_SwitchBitset,  .data=trcModeStrs),\n    JSI_OPT(BOOL,   Jsi_Db, echo,       .help=\"Output query/eval string to log\"),\n    JSI_OPT(INT,    Jsi_Db, errCnt,     .help=\"Count of errors in script callbacks\", jsi_IIRO),\n    JSI_OPT(INT,    Jsi_Db, errorCode,  .help=\"Numeric error code returned by the most recent call to sqlite3_exec\"),\n    JSI_OPT(BOOL,   Jsi_Db, forceInt,   .help=\"Bind float as int if possible\"),\n    JSI_OPT(BOOL,   Jsi_Db, noJsonConv, .help=\"Do not JSON auto-convert array and object in CHARJSON columns\" ),\n    JSI_OPT(UINT64, Jsi_Db, lastInsertId,.help=\"The rowid of last insert\"),\n    JSI_OPT(BOOL,   Jsi_Db, load,       .help=\"Extensions can be loaded\" ),\n    JSI_OPT(CUSTOM, Jsi_Db, mutex,      .help=\"Mutex type to use\", jsi_IIOF, .custom=Jsi_Opt_SwitchEnum, .data=mtxStrs),\n    JSI_OPT(DSTRING,Jsi_Db, name,       .help=\"The dbname to use instead of 'main'\", jsi_IIOF),\n    JSI_OPT(BOOL,   Jsi_Db, noConfig,   .help=\"Disable use of Sqlite.conf to change options after create\", jsi_IIOF),\n    JSI_OPT(BOOL,   Jsi_Db, noCreate,   .help=\"Database is must already exist (false)\", jsi_IIOF),\n    JSI_OPT(FUNC,   Jsi_Db, onAuth,     .help=\"Function to call for auth\", .flags=0, .custom=0, .data=(void*)\"db:userobj, code:string, descr1:string, decr2:string, dbname:string, trigname:string\"),\n    JSI_OPT(FUNC,   Jsi_Db, onBusy,     .help=\"Function to call when busy\", .flags=0, .custom=0, .data=(void*)\"db:userobj, tries:number\"),\n    JSI_OPT(FUNC,   Jsi_Db, onCommit,   .help=\"Function to call on commit\", .flags=0, .custom=0, .data=(void*)\"db:userobj\"),\n    JSI_OPT(FUNC,   Jsi_Db, onNeedCollate,.help=\"Function to call for collation\", .flags=0, .custom=0, .data=(void*)\"db:userobj, name:string\"),\n    JSI_OPT(FUNC,   Jsi_Db, onProfile,  .help=\"Function to call for profile\", .flags=0, .custom=0, .data=(void*)\"db:userobj, sql:string, time:number\"),\n    JSI_OPT(FUNC,   Jsi_Db, onProgress, .help=\"Function to call for progress: progressSteps must be >0\", .flags=0, .custom=0, .data=(void*)\"db:userobj\"),\n    JSI_OPT(FUNC,   Jsi_Db, onRollback, .help=\"Function to call for rollback\", .flags=0, .custom=0, .data=(void*)\"db:userobj\"),\n    JSI_OPT(FUNC,   Jsi_Db, onTrace,    .help=\"Function to call for trace\", .flags=0, .custom=0, .data=(void*)\"db:userobj, sql:string\"),\n    JSI_OPT(FUNC,   Jsi_Db, onUpdate,   .help=\"Function to call for update\", .flags=0, .custom=0, .data=(void*)\"db:userobj, op:string, dbname:string, table:string, rowid:number\"),\n    JSI_OPT(FUNC,   Jsi_Db, onWalHook,  .help=\"Function to call for WAL\", .flags=0, .custom=0, .data=(void*)\"db:userobj, dbname:string, entry:number\"),\n    JSI_OPT(UINT,   Jsi_Db, progressSteps,.help=\"Number of steps between calling onProgress: 0 is disabled\", ),\n    JSI_OPT(CUSTOM, Jsi_Db, queryOpts,  .help=\"Default options for to use with query()\", .flags=0, .custom=Jsi_Opt_SwitchSuboption, .data=ExecFmtOptions),\n    JSI_OPT(BOOL,   Jsi_Db, readonly,   .help=\"Database opened in readonly mode\", jsi_IIOF),\n    JSI_OPT(INT,    Jsi_Db, sortCnt,    .help=\"Number of sorts in most recent operation\", jsi_IIRO),\n    JSI_OPT(INT,    Jsi_Db, stepCnt,    .help=\"Number of steps in most recent operation\", jsi_IIRO),\n    JSI_OPT(INT,    Jsi_Db, stmtCacheCnt,.help=\"Current size of compiled statement cache\", jsi_IIRO),\n    JSI_OPT(INT,    Jsi_Db, stmtCacheMax,.help=\"Max cache size for compiled statements\"),\n    JSI_OPT(INT,    Jsi_Db, timeout,    .help=\"Amount of time to wait when file is locked, in ms\"),\n    JSI_OPT(OBJ,    Jsi_Db, udata,      .help=\"User data\" ),\n    JSI_OPT(OBJ,    Jsi_Db, version,    .help=\"Sqlite version info\"),\n    JSI_OPT(INT,    Jsi_Db, timeout,    .help=\"Amount of time to wait when file is locked, in ms\"),\n    JSI_OPT(STRING, Jsi_Db, vfs,        .help=\"VFS to use\", jsi_IIOF),\n    JSI_OPT_END(Jsi_Db, .help=\"Options for source command\")\n};\n\n\n#endif\n\nvoid dbTypeNameHashInit(Jsi_Db *jdb) {\n    Jsi_Interp *interp = jdb->interp;\n    Jsi_Hash *hPtr = jdb->typeNameHash = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);\n    Jsi_HashSet(hPtr, (void*)\"blob\", (void*)JSI_OPTION_STRBUF);\n    Jsi_HashSet(hPtr, (void*)\"string\", (void*)JSI_OPTION_STRING);\n    Jsi_HashSet(hPtr, (void*)\"double\", (void*)JSI_OPTION_DOUBLE);\n    Jsi_HashSet(hPtr, (void*)\"integer\", (void*)JSI_OPTION_INT64);\n    Jsi_HashSet(hPtr, (void*)\"bool\", (void*)JSI_OPTION_BOOL);\n    Jsi_HashSet(hPtr, (void*)\"time_d\", (void*)JSI_OPTION_TIME_D);\n    Jsi_HashSet(hPtr, (void*)\"time_w\", (void*)JSI_OPTION_TIME_W);\n    Jsi_HashSet(hPtr, (void*)\"time_t\", (void*)JSI_OPTION_TIME_T);\n    Jsi_HashSet(hPtr, (void*)\"date\", (void*)JSI_OPTION_TIME_W);\n    Jsi_HashSet(hPtr, (void*)\"time\", (void*)JSI_OPTION_TIME_W);\n    Jsi_HashSet(hPtr, (void*)\"datetime\", (void*)JSI_OPTION_TIME_W);\n}\n\n#define SQLITE_OMIT_INCRBLOB\n\n// Return 1 if ok, else return 0 and set erc to -1 or -2 for timeout.\nstatic int dbExecCmd(Jsi_Db *jdb, const char *zQuery, int *erc)\n{\n    int rc = sqlite3_exec(jdb->db, zQuery, 0, 0, 0);\n    if (rc == SQLITE_BUSY) {\n        if (erc) *erc = -2;\n    } else if (rc != SQLITE_OK) {\n        if (erc) *erc = -1;\n    } else\n        return 1;\n    return 0;\n}\n\nstatic void dbEvalRowInfo(\n    DbEvalContext *p,               /* Evaluation context */\n    int *pnCol,                     /* OUT: Number of column names */\n    char ***papColName,           /* OUT: Array of column names */\n    int **papColType\n) {\n    /* Compute column names */\n    // Jsi_Interp *interp = p->jdb->interp;\n\n    if( 0==p->apColName ) {\n        sqlite3_stmt *pStmt = p->pPreStmt->pStmt;\n        uint i;                        /* Iterator variable */\n        uint nCol;                     /* Number of columns returned by pStmt */\n        char **apColName = 0;      /* Array of column names */\n        int *apColType = 0;\n        const char *zColName;         /* Column name */\n        int numRid = 0;               /* Number of times rowid seen. */\n\n        p->nCol = nCol = sqlite3_column_count(pStmt);\n        if( nCol>0 && (papColName || p->pArray) ) {\n            uint cnLen = sizeof(char*)*nCol, cnStart = cnLen;\n            for(i=0; i<nCol && cnLen<sizeof(p->staticColNames); i++)\n                cnLen += Jsi_Strlen(sqlite3_column_name(pStmt,i))+1;\n            if (cnLen>=sizeof(p->staticColNames)) {\n                apColName = (char**)Jsi_Calloc(nCol, sizeof(char*) );\n                cnStart = 0;\n            } else {\n                apColName = (char**)p->staticColNames;\n            }\n            if (papColType) {\n                if (nCol < SQL_MAX_STATIC_TYPES)\n                    apColType = p->staticColTypes;\n                else\n                    apColType = (int*)Jsi_Calloc(nCol, sizeof(int));\n            }\n            for(i=0; i<nCol; i++) {\n                zColName = sqlite3_column_name(pStmt,i);\n                if (cnStart==0)\n                    apColName[i] = Jsi_Strdup(zColName);\n                else {\n                    apColName[i] = p->staticColNames+cnStart;\n                    Jsi_Strcpy(apColName[i], zColName);\n                    cnStart += Jsi_Strlen(zColName)+1;\n                }\n                if (apColType)\n                    apColType[i] = sqlite3_column_type(pStmt,i);\n                /* Check if rowid appears first, and more than once. */\n                if ((i == 0 || numRid>0) &&\n                        (zColName[0] == 'r' && Jsi_Strcmp(zColName,\"rowid\") == 0)) {\n                    numRid++;\n                }\n            }\n            /* Change first rowid to oid. */\n            if (numRid > 1) {\n                if (apColName != (char**)p->staticColNames) {\n                    Jsi_Free(apColName[0]);\n                    apColName[0] = Jsi_Strdup(\"oid\");\n                } else {\n                    Jsi_Strcpy(apColName[0], \"oid\");\n                }\n            }\n            p->apColName = apColName;\n            p->apColType = apColType;\n        }\n    }\n    if( papColName ) {\n        *papColName = p->apColName;\n    }\n    if( papColType ) {\n        *papColType = p->apColType;\n    }\n    if( pnCol ) {\n        *pnCol = p->nCol;\n    }\n}\n\n#ifndef JSI_LITE_ONLY\nstatic Jsi_RC dbPrepareAndBind( Jsi_Db *jdb, char const *zIn, char const **pzOut,  SqlPreparedStmt **ppPreStmt );\n#endif\nstatic void dbReleaseColumnNames(DbEvalContext *p);\nstatic void dbReleaseStmt( Jsi_Db *jdb, SqlPreparedStmt *pPreStmt, int discard );\n\n\n/* Step statement. Return JSI_OK if there is a ROW result, JSI_BREAK if done, else JSI_ERROR. */\nstatic Jsi_RC dbEvalStepSub(DbEvalContext *p, int release, int *erc) {\n    int rcs;\n    Jsi_Db *jdb = p->jdb;\n    Jsi_Interp *interp = jdb->interp;\n    JSI_NOTUSED(interp);\n    SqlPreparedStmt *pPreStmt = p->pPreStmt;\n    SQLSIGASSERT(pPreStmt, STMT);\n    sqlite3_stmt *pStmt = pPreStmt->pStmt;\n\n    if (jdb->debug & TMODE_STEP)\n        JSI_DBQUERY_PRINTF( \"DEBUG: step: %s\\n\", pPreStmt->zSql);\n    rcs = sqlite3_step(pStmt);\n    if( rcs==SQLITE_BUSY ) {\n        if (erc) *erc = -2;\n        return JSI_ERROR;\n    }\n    if( rcs==SQLITE_ROW ) {\n        return JSI_OK;\n    }\n    if( p->pArray ) {\n        dbEvalRowInfo(p, 0, 0, 0);\n    }\n    rcs = sqlite3_reset(pStmt);\n\n    jdb->stepCnt = sqlite3_stmt_status(pStmt,SQLITE_STMTSTATUS_FULLSCAN_STEP,1);\n    jdb->sortCnt = sqlite3_stmt_status(pStmt,SQLITE_STMTSTATUS_SORT,1);\n    if (release==0 && rcs==SQLITE_OK)\n        return JSI_BREAK;\n    dbReleaseColumnNames(p);\n    p->pPreStmt = 0;\n\n    if( rcs!=SQLITE_OK ) {\n        /* If a run-time error occurs, report the error and stop reading\n        ** the SQL.  */\n        Jsi_LogError(\"%s\", sqlite3_errmsg(jdb->db));\n        dbReleaseStmt(jdb, pPreStmt, 1);\n        return JSI_ERROR;\n    } else {\n        dbReleaseStmt(jdb, pPreStmt, p->nocache);\n    }\n    return JSI_BREAK;\n}\n\nstatic Jsi_RC dbEvalInit(\n    Jsi_Interp *interp,\n    DbEvalContext *p,               /* Pointer to structure to initialize */\n    Jsi_Db *jdb,                  /* Database handle */\n    const char* zSql,                /* Value containing SQL script */\n    Jsi_DString *dStr,\n    Jsi_Obj *pArray,                /* Name of Jsi array to set (*) element of */\n    Jsi_Obj *pValVar                  /* Name element in array for list. */\n) {\n    p->dSql = dStr;\n    p->zSql = Jsi_DSAppend(p->dSql, zSql?zSql:\"\", NULL);\n    p->jdb = jdb;\n    return JSI_OK;\n}\n\nstatic void dbPrepStmtFree( Jsi_Db *jdb, SqlPreparedStmt *prep)\n{\n    if (prep->deleting)\n        return;\n    prep->deleting = 1;\n    if (prep->pStmt)\n        sqlite3_finalize( prep->pStmt );\n    if (prep->entry) {\n        Jsi_HashEntry *hPtr = prep->entry;\n        prep->entry = NULL;\n        Jsi_HashEntryDelete(hPtr);\n    }\n    if (prep->elPtr)\n        Jsi_ListEntryDelete(prep->elPtr);\n    Jsi_Free( (char*)prep );\n    jdb->stmtCacheCnt--;\n}\n\n/*\n** Finalize and free a list of prepared statements\n*/\n\nstatic void dbPrepStmtLimit( Jsi_Db *jdb)\n{\n    while(jdb->stmtCacheCnt>jdb->stmtCacheMax ) {\n        Jsi_ListEntry *l = Jsi_ListPopBack(jdb->stmtCache);\n        dbPrepStmtFree(jdb, (SqlPreparedStmt*)Jsi_ListValueGet(l));\n        jdb->stmtCacheCnt = Jsi_ListSize(jdb->stmtCache);\n    }\n}\n\n\nstatic Jsi_RC dbStmtFreeProc(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *value) {\n    Jsi_Db *jdb = (Jsi_Db*)interp;\n    Jsi_ListEntry *l = (Jsi_ListEntry*)hPtr;\n    SqlPreparedStmt *prep = (SqlPreparedStmt *)Jsi_ListValueGet(l);\n    prep->elPtr = NULL;\n    dbPrepStmtFree(jdb, prep);\n    return JSI_OK;\n}\n\n#ifndef JSI_LITE_ONLY\n\n/*\n** Finalize and free a list of prepared statements\n*/\nstatic void dbFlushStmtCache( Jsi_Db *jdb ) {\n    Jsi_ListClear(jdb->stmtCache);\n    jdb->stmtCacheCnt = 0;\n}\n\n#endif\n\n/*\n** Release a statement reference obtained by calling dbPrepareAndBind().\n** There should be exactly one call to this function for each call to\n** dbPrepareAndBind().\n**\n** If the discard parameter is non-zero, then the statement is deleted\n** immediately. Otherwise it is added to the LRU list and may be returned\n** by a subsequent call to dbPrepareAndBind().\n*/\nstatic void dbReleaseStmt(\n    Jsi_Db *jdb,                  /* Database handle */\n    SqlPreparedStmt *pPreStmt,      /* Prepared statement handle to release */\n    int discard                     /* True to delete (not cache) the pPreStmt */\n) {\n    //int i;\n    //Jsi_Interp *interp = jdb->interp;\n\n    /* Free the bound string and blob parameters */\n    /*for(i=0; i<pPreStmt->nParm; i++) {\n        Jsi_DecrRefCount(interp, pPreStmt->apParm[i]);\n    }*/\n    //pPreStmt->nParm = 0;\n\n    if( jdb->stmtCacheMax<=0 || discard ) {\n        /* If the cache is turned off, deallocated the statement */\n        dbPrepStmtFree(jdb, pPreStmt);\n    } else {\n        /* Add the prepared statement to the beginning of the cache list, then limit. */\n        if (!pPreStmt->elPtr)\n            pPreStmt->elPtr = Jsi_ListPushFrontNew(jdb->stmtCache, pPreStmt);\n        else\n            Jsi_ListPushFront(jdb->stmtCache, pPreStmt->elPtr);\n        dbPrepStmtLimit(jdb);\n        jdb->stmtCacheCnt = Jsi_ListSize(jdb->stmtCache);\n    }\n}\n\n/*\n** Release any cache of column names currently held as part of\n** the DbEvalContext structure passed as the first argument.\n*/\nstatic void dbReleaseColumnNames(DbEvalContext *p) {\n    //Jsi_Interp *interp = p->jdb->interp;\n\n    if( p->apColName && p->apColName != (char**)p->staticColNames) {\n        int i;\n        for(i=0; i<p->nCol; i++) {\n            Jsi_Free(p->apColName[i]);\n        }\n        Jsi_Free((char *)p->apColName);\n    }\n    if( p->apColType && p->apColType != p->staticColTypes) {\n        Jsi_Free((char *)p->apColType);\n    }\n    p->apColName = NULL;\n    p->apColType = NULL;\n    p->nCol = 0;\n}\n\n/*\n** Search the cache for a prepared-statement object that implements the\n** first SQL statement in the buffer pointed to by parameter zIn. If\n** no such prepared-statement can be found, allocate and prepare a new\n** one. In either case, bind the current values of the relevant Jsi\n** variables to any $var, :var or @var variables in the statement. Before\n** returning, set *ppPreStmt to point to the prepared-statement object.\n**\n** Output parameter *pzOut is set to point to the next SQL statement in\n** buffer zIn, or to the '\\0' byte at the end of zIn if there is no\n** next statement.\n**\n** If successful, JSI_OK is returned. Otherwise, JSI_ERROR is returned\n** and an error message loaded into interpreter jdb->interp.\n*/\nstatic Jsi_RC dbPrepareStmt(\n    Jsi_Db *jdb,                  /* Database object */\n    char const *zIn,                /* SQL to compile */\n    char const **pzOut,             /* OUT: Pointer to next SQL statement */\n    SqlPreparedStmt **ppPreStmt     /* OUT: Object used to cache statement */\n) {\n    const char *zSql = zIn;         /* Pointer to first SQL statement in zIn */\n    sqlite3_stmt *pStmt;            /* Prepared statement object */\n    SqlPreparedStmt *pPreStmt = 0;  /* Pointer to cached statement */\n   // int nSql;                       /* Length of zSql in bytes */\n    //int nVar;                       /* Number of variables in statement */\n    //int iParm = 0;                  /* Next free entry in apParm */\n    Jsi_RC rc = JSI_OK;\n    Jsi_Interp *interp = jdb->interp;\n    JSI_NOTUSED(interp);\n\n    *ppPreStmt = 0;\n\n    /* Trim spaces from the start of zSql and calculate the remaining length. */\n    while( isspace(zSql[0]) ) {\n        zSql++;\n    }\n    //nSql = Jsi_Strlen(zSql);\n    Jsi_HashEntry *entry = Jsi_HashEntryFind(jdb->stmtHash, zSql);\n    if (entry && ((pPreStmt = (SqlPreparedStmt*)Jsi_HashValueGet(entry)))) {\n        \n        if (jdb->debug & TMODE_PREPARE)\n            JSI_DBQUERY_PRINTF( \"DEBUG: prepare cache-hit: %s\\n\", zSql);\n        pStmt = pPreStmt->pStmt;\n        *pzOut = &zSql[pPreStmt->nSql];\n\n        /* When a prepared statement is found, unlink it from the\n        ** cache list.  It will later be added back to the beginning\n        ** of the cache list in order to implement LRU replacement.\n        */\n        Jsi_ListPop(jdb->stmtCache, pPreStmt->elPtr);\n        jdb->stmtCacheCnt = Jsi_ListSize(jdb->stmtCache);\n\n    }\n\n    /* If no prepared statement was found. Compile the SQL text. Also allocate\n    ** a new SqlPreparedStmt structure.  */\n    if( pPreStmt==0 ) {\n        int nByte;\n\n        if( SQLITE_OK!=sqlite3_prepare_v2(jdb->db, zSql, -1, &pStmt, pzOut) )\n        \n            return Jsi_LogError(\"PREPARE: %s\", sqlite3_errmsg(jdb->db));\n        if( pStmt==0 ) {\n            if( SQLITE_OK!=sqlite3_errcode(jdb->db) ) {\n                /* A compile-time error in the statement. */\n                Jsi_LogError(\"PREP: %s\", sqlite3_errmsg(jdb->db));\n                return JSI_ERROR;\n            } else {\n                /* The statement was a no-op.  Continue to the next statement\n                ** in the SQL string.\n                */\n                return JSI_OK;\n            }\n        }\n\n        if (jdb->debug & TMODE_PREPARE)\n            JSI_DBQUERY_PRINTF( \"DEBUG: prepare new: %s\\n\", zSql);\n        assert( pPreStmt==0 );\n        //nVar = sqlite3_bind_parameter_count(pStmt);\n        jdb->stmtCacheCnt++;\n        nByte = sizeof(SqlPreparedStmt); // + nVar*sizeof(Jsi_Obj *);\n        pPreStmt = (SqlPreparedStmt*)Jsi_Calloc(1, nByte);\n        pPreStmt->sig = SQLITE_SIG_STMT;\n\n        pPreStmt->pStmt = pStmt;\n        pPreStmt->nSql = (*pzOut - zSql);\n        pPreStmt->zSql = sqlite3_sql(pStmt);\n        bool isNew = 0;\n        pPreStmt->entry = Jsi_HashEntryNew(jdb->stmtHash, zSql, &isNew);\n        if (!isNew)\n            JSI_DBQUERY_PRINTF( \"sqlite dup stmt entry\");\n        Jsi_HashValueSet(pPreStmt->entry, pPreStmt);\n            \n        //pPreStmt->apParm = (Jsi_Value **)&pPreStmt[1];\n    }\n    assert( pPreStmt );\n    assert( Jsi_Strlen(pPreStmt->zSql)==pPreStmt->nSql );\n    assert( 0==memcmp(pPreStmt->zSql, zSql, pPreStmt->nSql) );\n    *ppPreStmt = pPreStmt;\n    //pPreStmt->nParm = iParm; \n    return rc;\n}\n\n\n#ifndef JSI_LITE_ONLY\n\n/*\n** Return one of JSI_OK, JSI_BREAK or JSI_ERROR. If JSI_ERROR is\n** returned, then an error message is stored in the interpreter before\n** returning.\n**\n** A return value of JSI_OK means there is a row of data available. The\n** data may be accessed using dbEvalRowInfo() and dbEvalColumnValue(). This\n** is analogous to a return of SQLITE_ROW from sqlite3_step(). If JSI_BREAK\n** is returned, then the SQL script has finished executing and there are\n** no further rows available. This is similar to SQLITE_DONE.\n*/\nstatic Jsi_RC dbEvalStep(DbEvalContext *p) {\n    while( p->zSql[0] || p->pPreStmt ) {\n        Jsi_RC rc;\n        if( p->pPreStmt==0 ) {\n            rc = dbPrepareAndBind(p->jdb, p->zSql, &p->zSql, &p->pPreStmt);\n            if( rc!=JSI_OK ) return rc;\n        }\n        rc = dbEvalStepSub(p, 1, NULL);\n        if (rc != JSI_BREAK)\n            return rc;\n    }\n    \n    /* Finished */\n    return JSI_BREAK;\n}\n\nstatic Jsi_RC dbBindStmt(Jsi_Db *jdb, SqlPreparedStmt *prep)\n{\n    sqlite3_stmt *pStmt = prep->pStmt;    /* Object used to cache statement */\n    Jsi_Interp *interp = jdb->interp;\n    int i, btype = 0, bindArr=0, n;\n    Jsi_RC rc = JSI_OK;\n    Jsi_Number r;\n    Jsi_Wide wv;\n \n    Jsi_Value *pv = NULL, *apv = NULL;\n    int nVar = sqlite3_bind_parameter_count(pStmt);\n    char tname[50];\n    \n   /* Bind values to parameters that begin with @, $, :, or ? */\n    for(i=1; i<=nVar; i++) {\n        tname[0] = 0;\n        int isInt = 0, isBlob = 0;\n        const char *zVar = sqlite3_bind_parameter_name(pStmt, i);\n        if (zVar == NULL) {\n            if (!jdb->optPtr || !(apv=jdb->optPtr->values)) \n                return Jsi_LogError(\"? bind without values for param %d\", i);\n            if (!(pv =Jsi_ValueArrayIndex(interp, apv, i-1))) \n                return Jsi_LogError(\"array element %d missing\", nVar);\n        }\n        else if((zVar[0]=='$' || zVar[0]==':' || zVar[0]=='@') ) {\n            int zvLen = Jsi_Strlen(zVar);\n            char *zcp;\n            if (zVar[0] =='$' && ((zcp = (char*)Jsi_Strchr(zVar,'('))) && zVar[zvLen-1] == ')')\n            {\n                bindArr = 1;\n                Jsi_DString vStr;\n                Jsi_DSInit(&vStr);\n                Jsi_DSAppendLen(&vStr, zVar+1, (zcp-zVar-1));\n                int slen = Jsi_Strlen(zcp);\n                const char *ttp;\n                if ((ttp = Jsi_Strchr(zVar,':'))) { // Extract bind-type.\n                    Jsi_DString tStr = {};\n                    int tlen = Jsi_Strlen(ttp+1);\n                    Jsi_DSAppendLen(&tStr, ttp+1, tlen-1);\n                    if (!jdb->typeNameHash)\n                        dbTypeNameHashInit(jdb);\n                    Jsi_HashEntry *htPtr = Jsi_HashEntryFind(jdb->typeNameHash, Jsi_DSValue(&tStr));\n                    int rc = ( htPtr != NULL);\n                    if (!htPtr) {\n                        Jsi_DString eStr = {};\n                        Jsi_HashSearch search;\n                        Jsi_Interp *interp = jdb->interp;\n                        int n = 0;\n                        Jsi_HashEntry *hPtr;\n                        for (hPtr = Jsi_HashSearchFirst(jdb->typeNameHash, &search);\n                            hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {\n                            const char *key = (char*)Jsi_HashKeyGet(hPtr);\n                            Jsi_DSAppend(&eStr, (n++?\", \":\"\"), key, NULL);\n                        }\n                        Jsi_LogWarn(\"bind type \\\"%s\\\" is not one of: %s\", Jsi_DSValue(&tStr), Jsi_DSValue(&eStr));\n                        Jsi_DSFree(&eStr);\n                    }\n                    Jsi_Strcpy(tname, Jsi_DSValue(&tStr));\n                    Jsi_DSFree(&tStr);\n                    if (!rc)\n                        return JSI_ERROR;\n\n                    btype = (uintptr_t)Jsi_HashValueGet(htPtr);\n                    Jsi_DSFree(&tStr);\n                    slen -= tlen;\n                }\n\n                if (isdigit(zcp[1])) {\n                    Jsi_DSAppendLen(&vStr, \"[\", 1);\n                    Jsi_DSAppendLen(&vStr, zcp+1, slen-2);\n                    Jsi_DSAppendLen(&vStr, \"]\", 1);\n                } else {\n                    if (zcp[1] != '[')\n                        Jsi_DSAppendLen(&vStr, \".\", 1);\n                    Jsi_DSAppendLen(&vStr, zcp+1, slen-2);\n                }\n                pv = Jsi_NameLookup(interp, Jsi_DSValue(&vStr));\n                Jsi_DSFree(&vStr);\n            } else\n                pv = Jsi_VarLookup(interp, &zVar[1]);\n        } else \n            return Jsi_LogError(\"can not find bind var %s\", zVar);\n            \n        if(!pv ) {\n            if (!jdb->bindWarn) {\n                Jsi_LogError(\"unknown bind param: %s\", zVar);\n                rc = JSI_ERROR;\n                break;\n            } else\n                Jsi_LogWarn(\"unknown bind param: %s\", zVar);\n        } else {\n            int match = 1, cast = (jdb->optPtr->typeCheck==dbTypeCheck_Cast);\n            if (btype && !Jsi_ValueIsUndef(interp, pv)) {\n                switch (btype) {\n                    case JSI_OPTION_STRBUF:\n                        isBlob = 1;\n                    case JSI_OPTION_STRING:\n                        if (cast)\n                            Jsi_ValueToString(interp, pv, &n);\n                        else\n                            match = Jsi_ValueIsString(interp, pv);\n                        break;\n                    case JSI_OPTION_NUMBER:\n                    case JSI_OPTION_DOUBLE:\n                        if (cast)\n                            Jsi_ValueToNumber(interp, pv);\n                        else\n                            match = Jsi_ValueIsNumber(interp, pv);\n                        break;\n                    case JSI_OPTION_TIME_W:\n                    case JSI_OPTION_TIME_T:\n                    case JSI_OPTION_INT64:\n                        isInt = 1;\n                        if (cast)\n                            Jsi_ValueToNumber(interp, pv);\n                        else\n                            match = Jsi_ValueIsNumber(interp, pv);\n                        break;\n                    case JSI_OPTION_BOOL:\n                        if (cast)\n                            Jsi_ValueToBool(interp, pv);\n                        else\n                            match = Jsi_ValueIsNumber(interp, pv);\n                        break;\n                    case JSI_OPTION_TIME_D:\n                        if (cast)\n                            Jsi_ValueToNumber(interp, pv); //TODO: do something more for dates?\n                        else\n                            match = Jsi_ValueIsNumber(interp, pv);\n                        break;\n                    default:\n                        Jsi_LogBug(\"Unhandled bind type: %s = %d\", tname, btype);\n                }\n                if (cast == 0 && match == 0) {\n                    int ltyp = (jdb->optPtr->typeCheck==dbTypeCheck_Error?JSI_LOG_ERROR:JSI_LOG_WARN);\n                    Jsi_LogMsg(interp, ltyp, \"bind param \\\"%s\\\" type is not \\\"%s\\\"\", zVar, tname);\n                    if (ltyp == JSI_LOG_ERROR)\n                        return JSI_ERROR;\n                }\n            }\n            bool bn, isArr;\n            const char *dectyp;\n            if (Jsi_ValueIsBoolean(interp, pv)) {\n                Jsi_GetBoolFromValue(interp, pv, &bn);\n                sqlite3_bind_int(pStmt, i, bn);\n            } else if (Jsi_ValueIsNumber(interp, pv)) {\n                Jsi_GetNumberFromValue(interp, pv, &r);\n                wv = (Jsi_Wide)r;\n                if (isInt || (jdb->forceInt && (((Jsi_Number)wv)-r)==0))\n                    sqlite3_bind_int64(pStmt, i,wv);\n                else\n                    sqlite3_bind_double(pStmt, i,(double)r);\n            } else if (Jsi_ValueIsNull(interp, pv) || (Jsi_ValueIsUndef(interp, pv) && jdb->queryOpts.mapundef)) {\n                sqlite3_bind_null(pStmt, i);\n            } else if (Jsi_ValueIsString(interp, pv)) {\n                const char *sstr = Jsi_ValueGetStringLen(interp, pv, &n);\n                if (!sstr) sstr = \"\";\n                if (isBlob)\n                    sqlite3_bind_blob(pStmt, i, (char *)sstr, n, SQLITE_TRANSIENT );\n                else\n                    sqlite3_bind_text(pStmt, i, (char *)sstr, n, SQLITE_TRANSIENT );\n            } else if (!jdb->noJsonConv && bindArr && ((isArr=Jsi_ValueIsArray(interp, pv))\n                || Jsi_ValueIsObjType(interp, pv, JSI_OT_OBJECT))\n                && (((dectyp = sqlite3_column_decltype(pStmt, i))==NULL) || \n                    !Jsi_Strncasecmp(dectyp,\"charjson\",8))) {\n                    // Limitation: on INSERT can not access decltype.\n                    Jsi_DString jStr = {};\n                    Jsi_ValueGetDString(interp, pv, &jStr, JSI_OUTPUT_JSON|JSI_JSON_STRICT);\n                    n = Jsi_DSLength(&jStr);\n                    sqlite3_bind_text(pStmt, i, Jsi_DSValue(&jStr), n, SQLITE_TRANSIENT );\n                    Jsi_DSFree(&jStr);\n            } else {\n                if (!jdb->bindWarn) {\n                    Jsi_LogError(\"bind param must be string/number/bool/null: %s\", zVar);\n                    rc = JSI_ERROR;\n                    break;\n                } else\n                    Jsi_LogWarn(\"bind param must be string/number/bool/null: %s\", zVar);\n                sqlite3_bind_null(pStmt, i);\n            }\n\n        }\n    }\n    return rc;\n}\n\nstatic Jsi_RC dbPrepareAndBind(\n    Jsi_Db *jdb,                  /* Database object */\n    char const *zIn,                /* SQL to compile */\n    char const **pzOut,             /* OUT: Pointer to next SQL statement */\n    SqlPreparedStmt **ppPreStmt     /* OUT: Object used to cache statement */\n) {\n    if (dbPrepareStmt(jdb, zIn, pzOut, ppPreStmt) != JSI_OK)\n        return JSI_ERROR;\n    return dbBindStmt(jdb, *ppPreStmt);\n}\n#endif\n\n/*\n** Free all resources currently held by the DbEvalContext structure passed\n** as the first argument. There should be exactly one call to this function\n** for each call to dbEvalInit(interp,).\n*/\nstatic void dbEvalFinalize(DbEvalContext *p) {\n//  Jsi_Interp *interp = p->jdb->interp;\n\n    if( p->pPreStmt ) {\n        sqlite3_reset(p->pPreStmt->pStmt);\n        dbReleaseStmt(p->jdb, p->pPreStmt, p->nocache);\n        p->pPreStmt = 0;\n    }\n    if (p->dSql)\n        Jsi_DSFree(p->dSql);\n    dbReleaseColumnNames(p);\n}\n\nstatic void DbClose(sqlite3 *db) {\n        sqlite3_close(db);\n}\n\n#ifndef JSI_LITE_ONLY\n\nstatic Jsi_RC sqliteObjFree(Jsi_Interp *interp, void *data);\nstatic bool  sqliteObjEqual(void *data1, void *data2);\nstatic bool  sqliteObjIsTrue(void *data);\n\nstatic Jsi_RC dbIsNumArray(Jsi_Interp *interp, Jsi_Value *value, Jsi_OptionSpec* spec, void *record)\n{\n    if (!Jsi_ValueIsArray(interp, value)) \n        return Jsi_LogError(\"expected array of numbers\");\n    int i, argc = Jsi_ValueGetLength(interp, value);\n    for (i=0; i<argc; i++) {\n        Jsi_Value *v = Jsi_ValueArrayIndex(interp, value, i);\n        if (!Jsi_ValueIsNumber(interp, v)) \n            return Jsi_LogError(\"expected array of numbers\");\n    }\n    return JSI_OK;\n}\n\n\n/*\n** JSI calls this procedure when an sqlite3 database command is\n** deleted.\n*/\nstatic void dbDeleteCmd(Jsi_Db *jdb)\n{\n    Jsi_Interp *interp = jdb->interp;\n    if (jdb->debug & TMODE_DELETE)\n        JSI_DBQUERY_PRINTF( \"DEBUG: delete\\n\");\n    dbFlushStmtCache(jdb);\n    if (jdb->stmtHash)\n        Jsi_HashDelete(jdb->stmtHash);\n    //closeIncrblobChannels(jdb);\n    if (jdb->db) {\n        DbClose(jdb->db);\n    }\n    while( jdb->pFunc ) {\n        SqlFunc *pFunc = jdb->pFunc;\n        jdb->pFunc = pFunc->pNext;\n        Jsi_DSFree(&pFunc->dScript);\n        Jsi_DecrRefCount(interp, pFunc->tocall);\n        Jsi_Free((char*)pFunc);\n    }\n    while( jdb->pCollate ) {\n        SqlCollate *pCollate = jdb->pCollate;\n        jdb->pCollate = pCollate->pNext;\n        Jsi_Free((char*)pCollate);\n    }\n\n    Jsi_OptionsFree(interp, SqlOptions, jdb, 0);\n    if (jdb->stmtCache)\n        Jsi_ListDelete(jdb->stmtCache);\n}\n\nstatic int dbGetIntBool(Jsi_Interp *interp, Jsi_Value* v)\n{\n    if (Jsi_ValueIsNumber(interp, v)) {\n        Jsi_Number d;\n        Jsi_ValueGetNumber(interp, v, &d);\n        return (int)d;\n    }\n    if (Jsi_ValueIsBoolean(interp, v)) {\n        bool n;\n        Jsi_ValueGetBoolean(interp, v, &n);\n        return n;\n    }\n    return 0;\n}\n\n\n/*\n** This routine is called when a database file is locked while trying\n** to execute SQL.\n*/\nstatic int dbBusyHandler(void *cd, int nTries) {\n    int rc;\n    Jsi_Db *jdb = (Jsi_Db*)cd;\n    Jsi_Value *vpargs, *items[3] = {}, *ret;\n    Jsi_Interp *interp = jdb->interp;\n\n    items[0] = Jsi_ValueNewObj(interp, jdb->fobj);\n    items[1] = Jsi_ValueMakeNumber(interp, NULL, (Jsi_Number)nTries);\n    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, 2, 0));\n    Jsi_IncrRefCount(interp, vpargs);\n    ret = Jsi_ValueNew1(interp);\n    rc = Jsi_FunctionInvoke(interp, jdb->onBusy, vpargs, &ret, NULL);\n    if( JSI_OK!=rc ) {\n        jdb->errCnt++;\n        rc = 1;\n    } else\n        rc = dbGetIntBool(interp, ret);\n    Jsi_DecrRefCount(interp, vpargs);\n    Jsi_DecrRefCount(interp, ret);\n    return rc;\n}\n\n/*\n** This routine is invoked as the 'progress callback' for the database.\n*/\nstatic int dbProgressHandler(void *cd) {\n    Jsi_Db *jdb = (Jsi_Db*)cd;\n    Jsi_Value *vpargs, *items[3] = {}, *ret;\n    Jsi_Interp *interp = jdb->interp;\n\n    items[0] = Jsi_ValueNewObj(interp, jdb->fobj);\n    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, 1, 0));\n    Jsi_IncrRefCount(interp, vpargs);\n    ret = Jsi_ValueNew1(interp);\n    int rc = Jsi_FunctionInvoke(interp, jdb->onProgress, vpargs, &ret, NULL);\n    if( JSI_OK!=rc ) {\n        jdb->errCnt++;\n        rc = 1;\n    } else\n        rc = dbGetIntBool(interp, ret);\n    Jsi_DecrRefCount(interp, vpargs);\n    Jsi_DecrRefCount(interp, ret);\n    return rc;\n}\n\n/*\n** This routine is called by the SQLite trace handler whenever a new\n** block of SQL is executed.  The JSI script in jdb->onTrace is executed.\n*/\nstatic void dbTraceHandler(void *cd, const char *zSql)\n{\n    int rc;\n    Jsi_Db *jdb = (Jsi_Db*)cd;\n    Jsi_Value *vpargs, *items[2] = {}, *ret;\n    Jsi_Interp *interp = jdb->interp;\n    items[0] = Jsi_ValueNewObj(interp, jdb->fobj);\n    items[1] = Jsi_ValueMakeStringDup(interp, NULL, zSql);\n    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, 2, 0));\n    Jsi_IncrRefCount(interp, vpargs);\n    ret = Jsi_ValueNew1(interp);\n    rc = Jsi_FunctionInvoke(interp, jdb->onTrace, vpargs, &ret, NULL);\n    Jsi_DecrRefCount(interp, vpargs);\n    Jsi_DecrRefCount(interp, ret);\n    if (rc != JSI_OK)\n        jdb->errCnt++;\n}\n\n/*\n** This routine is called by the SQLite profile handler after a statement\n** SQL has executed.  The JSI script in jdb->onProfile is evaluated.\n*/\nstatic void dbProfileHandler(void *cd, const char *zSql, sqlite_uint64 tm) {\n    int rc;\n    Jsi_Db *jdb = (Jsi_Db*)cd;\n    Jsi_Interp *interp = jdb->interp;\n    Jsi_Value *vpargs, *items[3] = {}, *ret;\n\n    items[0] = Jsi_ValueNewObj(interp, jdb->fobj);\n    items[1] = Jsi_ValueMakeStringDup(interp, NULL, zSql);\n    items[2] = Jsi_ValueMakeNumber(interp, NULL, (Jsi_Number)tm);\n    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, 3, 0));\n    Jsi_IncrRefCount(interp, vpargs);\n    ret = Jsi_ValueNew1(interp);\n    rc = Jsi_FunctionInvoke(interp, jdb->onProfile, vpargs, &ret, NULL);\n    Jsi_DecrRefCount(interp, vpargs);\n    Jsi_DecrRefCount(interp, ret);\n    if (rc != JSI_OK)\n        jdb->errCnt++;\n}\n\n/*\n** This routine is called when a transaction is committed.  The\n** JSI script in jdb->onCommit is executed.  If it returns non-zero or\n** if it throws an exception, the transaction is rolled back instead\n** of being committed.\n*/\nstatic int dbCommitHandler(void *cd) {\n    int rc = 0;\n    Jsi_Db *jdb = (Jsi_Db*)cd;\n    Jsi_Interp *interp = jdb->interp;\n    Jsi_Value *vpargs, *items[2] = {}, *ret = Jsi_ValueNew1(interp);\n    \n    items[0] = Jsi_ValueNewObj(interp, jdb->fobj);\n    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, 1, 0));\n    Jsi_IncrRefCount(interp, vpargs);\n    if( JSI_OK!=Jsi_FunctionInvoke(interp, jdb->onCommit, NULL, &ret, NULL) ) {\n        jdb->errCnt++;\n        rc = 1;\n    } else\n        rc = dbGetIntBool(interp, ret);\n    Jsi_DecrRefCount(interp, vpargs);\n    Jsi_DecrRefCount(interp, ret);\n    return rc;\n}\n\n/*\n** This procedure handles wal_hook callbacks.\n*/\nstatic int dbWalHandler( void *cd, sqlite3 *db, const char *zDb, int nEntry ){\n    int rc;\n    Jsi_Db *jdb = (Jsi_Db*)cd;\n    Jsi_Interp *interp = jdb->interp;\n    Jsi_Value *vpargs, *items[3] = {}, *ret;\n\n    items[0] = Jsi_ValueNewObj(interp, jdb->fobj);\n    items[1] = Jsi_ValueMakeStringDup(interp, NULL, zDb);\n    items[2] = Jsi_ValueMakeNumber(interp, NULL, (Jsi_Number)nEntry);\n    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, 3, 0));\n    Jsi_IncrRefCount(interp, vpargs);\n    ret = Jsi_ValueNew(interp);\n    rc = Jsi_FunctionInvoke(interp, jdb->onWalHook, vpargs, &ret, NULL);\n    Jsi_DecrRefCount(interp, vpargs);\n    if (rc != JSI_OK) {\n        jdb->errCnt++;\n        rc = 1;\n    } else\n        rc = dbGetIntBool(jdb->interp, ret);\n    Jsi_DecrRefCount(interp, ret);\n    return rc;\n}\n \nstatic void dbRollbackHandler(void *cd) {\n    Jsi_Db *jdb = (Jsi_Db*)cd;\n    Jsi_Interp *interp = jdb->interp;\n    Jsi_Value *vpargs, *items[2] = {}, *ret = Jsi_ValueNew1(interp);\n    \n    items[0] = Jsi_ValueNewObj(interp, jdb->fobj);\n    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, 1, 0));\n    Jsi_IncrRefCount(interp, vpargs);\n    Jsi_FunctionInvoke(interp, jdb->onRollback, NULL, &ret, NULL);\n    Jsi_DecrRefCount(interp, vpargs);\n    Jsi_DecrRefCount(interp, ret);\n}\n\n\nstatic void dbUpdateHandler(\n    void *p,\n    int op,\n    const char *zDb,\n    const char *zTbl,\n    sqlite_int64 rowid\n) {\n    Jsi_Db *jdb = (Jsi_Db *)p;\n    Jsi_Interp *interp = jdb->interp;\n    int rc, i = 0;\n    Jsi_Value *vpargs, *items[10] = {}, *ret;\n    \n    assert( op==SQLITE_INSERT || op==SQLITE_UPDATE || op==SQLITE_DELETE );\n    items[i++] = Jsi_ValueNewObj(interp, jdb->fobj);\n    items[i++] = Jsi_ValueMakeStringDup(interp, NULL, (op==SQLITE_INSERT)?\"INSERT\":(op==SQLITE_UPDATE)?\"UPDATE\":\"DELETE\");\n    items[i++] = Jsi_ValueMakeStringDup(interp, NULL, zDb);\n    items[i++] = Jsi_ValueMakeStringDup(interp, NULL, zTbl);\n    items[i++] = Jsi_ValueMakeNumber(interp, NULL, (Jsi_Number)rowid);\n    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, i, 0));\n    Jsi_IncrRefCount(interp, vpargs);\n    ret = Jsi_ValueNew1(interp);\n    rc = Jsi_FunctionInvoke(interp, jdb->onUpdate, vpargs, &ret, NULL);\n    Jsi_DecrRefCount(interp, vpargs);\n    Jsi_DecrRefCount(interp, ret);\n    if (rc != JSI_OK)\n        jdb->errCnt++;\n}\n\nstatic void dbCollateNeeded(\n    void *cd,\n    sqlite3 *db,\n    int enc,\n    const char *zName\n) {\n    int rc;\n    Jsi_Db *jdb = (Jsi_Db*)cd;\n    Jsi_Interp *interp = jdb->interp;\n    Jsi_Value *vpargs, *items[2], *ret;\n    items[0] = Jsi_ValueNewObj(interp, jdb->fobj);\n    items[1] = Jsi_ValueMakeStringDup(interp, NULL, zName);\n    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, 2, 0));\n    Jsi_IncrRefCount(interp, vpargs);\n    ret = Jsi_ValueNew1(interp);\n    rc = Jsi_FunctionInvoke(interp, jdb->onNeedCollate, vpargs,& ret, NULL);\n    Jsi_DecrRefCount(interp, vpargs);\n    Jsi_DecrRefCount(interp, ret);\n    if (rc != JSI_OK)\n        jdb->errCnt++;\n\n}\n\n/*\n** This routine is called to evaluate an SQL collation function implemented\n** using JSI script.\n*/\nstatic int dbSqlCollate(\n    void *pCtx,\n    int nA,\n    const void *zA,\n    int nB,\n    const void *zB\n) {\n    SqlCollate *p = (SqlCollate *)pCtx;\n    Jsi_Interp *interp = p->interp;\n\n    int rc;\n    //Jsi_Db *jdb = (Jsi_Db*)cd;\n    Jsi_Value *vpargs, *items[3], *ret;\n\n    items[0] = Jsi_ValueNewObj(interp, p->jdb->fobj);\n    items[1] = Jsi_ValueMakeStringDup(interp, NULL, (char*)zA);\n    items[2] = Jsi_ValueMakeStringDup(interp, NULL, (char*)zB);\n    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, 3, 0));\n    ret = Jsi_ValueNew1(interp);\n    rc = Jsi_FunctionInvoke(interp, p->zScript, vpargs, &ret, NULL);\n    if( JSI_OK!=rc ) {\n        //jdb->errCnt++;\n        rc = 0;\n    } else\n        rc = dbGetIntBool(interp, ret);\n    Jsi_DecrRefCount(interp, vpargs);\n    Jsi_DecrRefCount(interp, ret);\n    return rc;\n}\n\nstatic Jsi_Value* dbGetValueGet(Jsi_Interp *interp, sqlite3_value *pIn)\n{\n    Jsi_Value *v = Jsi_ValueNew(interp);\n    switch (sqlite3_value_type(pIn)) {\n    case SQLITE_BLOB: {\n        int bytes;\n        bytes = sqlite3_value_bytes(pIn);\n        const char *zBlob = (char*) sqlite3_value_blob(pIn);\n        if(!zBlob ) {\n            return Jsi_ValueMakeNull(interp, &v);\n        }\n        unsigned char *uptr = (unsigned char*)Jsi_Malloc(bytes+1);\n        memcpy(uptr, zBlob, bytes);\n        uptr[bytes] = 0;\n        return Jsi_ValueMakeBlob(interp, &v, uptr, bytes);\n    }\n    case SQLITE_INTEGER: {\n        sqlite_int64 n = sqlite3_value_int64(pIn);\n        if( n>=-2147483647 && n<=2147483647 ) {\n            return Jsi_ValueMakeNumber(interp, &v, n);\n        } else {\n            return Jsi_ValueMakeNumber(interp, &v, n);\n        }\n    }\n    case SQLITE_FLOAT: {\n        return Jsi_ValueMakeNumber(interp, &v, (Jsi_Number)sqlite3_value_double(pIn));\n    }\n    case SQLITE_NULL: {\n        return Jsi_ValueMakeNull(interp, &v);\n    }\n    default:\n        return Jsi_ValueMakeStringDup(interp, &v, (char *)sqlite3_value_text(pIn));\n    }\n    return v;\n}\n\nstatic void jsiSqlFuncUnixTime(sqlite3_context *context, int argc, sqlite3_value**argv) {\n    Jsi_Db *jdb = (Jsi_Db*)sqlite3_user_data(context);\n    SQLSIGASSERT(jdb,DB);\n    Jsi_Interp *interp = jdb->interp;\n    if (argc>3) {\n        Jsi_LogWarn(\"sqlite unixtime, expected: str fmt isutc\");\n        return;\n    }\n    const char *str = NULL, *fmt = NULL;\n    bool isUtc = 0;\n    if (argc>=1)\n        str = (char *)sqlite3_value_text(argv[0]);\n    if (argc>=2)\n        fmt = (char *)sqlite3_value_text(argv[1]);\n    if (argc>=3)\n        isUtc = (bool)sqlite3_value_int64(argv[2]);\n    Jsi_Number d = 0;\n    Jsi_DatetimeParse(interp, str, fmt, isUtc, &d, 0);\n    sqlite3_result_double(context, (double)d);\n}\n\nstatic void jsiSqlFunc(sqlite3_context *context, int argc, sqlite3_value**argv) {\n    SqlFunc *p = (SqlFunc*)sqlite3_user_data(context);\n    int i;\n    int rc;\n    Jsi_Interp *interp = p->interp;\n    Jsi_Value *vpargs, *itemsStatic[100], **items = itemsStatic, *ret;\n    if (argc>100)\n        items = (Jsi_Value**)Jsi_Calloc(argc, sizeof(Jsi_Value*));\n\n    for(i=0; i<argc; i++) {\n        items[i] = dbGetValueGet(interp, argv[i]);\n    }\n    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, argc, 0));\n    Jsi_IncrRefCount(interp, vpargs);\n    ret = Jsi_ValueNew1(interp);\n    rc = Jsi_FunctionInvoke(interp, p->tocall, vpargs, &ret, NULL);\n    Jsi_DecrRefCount(interp, vpargs);\n    if (items != itemsStatic)\n        Jsi_Free(items);\n\n    bool b;\n    if( rc != JSI_OK) {\n        char buf[250];\n        snprintf(buf, sizeof(buf), \"error in function: %.200s\", p->zName);\n        sqlite3_result_error(context, buf, -1);\n\n    } else if (Jsi_ValueIsBoolean(interp, ret)) {\n        Jsi_GetBoolFromValue(interp, ret, &b);\n        sqlite3_result_int(context, b);\n    } else if (Jsi_ValueIsNumber(interp, ret)) {\n        Jsi_Number d;\n        // if (Jsi_GetIntFromValueBase(interp, ret, &i, 0, JSI_NO_ERRMSG);\n        // sqlite3_result_int64(context, v);\n        Jsi_GetNumberFromValue(interp, ret, &d);\n        sqlite3_result_double(context, (double)d);\n    } else {\n        const char * data;\n        if (!(data = Jsi_ValueGetStringLen(interp, ret, &i))) {\n            //TODO: handle objects???\n            data = Jsi_ValueToString(interp, ret, NULL);\n            i = Jsi_Strlen(data);\n        }\n        sqlite3_result_text(context, (char *)data, i, SQLITE_TRANSIENT );\n    }\n    Jsi_DecrRefCount(interp, ret);\n}\n\n/*\n** This is the authentication function.  It appends the authentication\n** type code and the two arguments to zCmd[] then invokes the result\n** on the interpreter.  The reply is examined to determine if the\n** authentication fails or succeeds.\n*/\nstatic int dbAuthCallback(\n    void *pArg,\n    int code,\n    const char *zArg1,\n    const char *zArg2,\n    const char *zArg3,\n    const char *zArg4\n) {\n    const char *zCode;\n    int rc;\n    const char *zReply;\n    Jsi_Db *jdb = (Jsi_Db*)pArg;\n    Jsi_Interp *interp = jdb->interp;\n    if( jdb->disableAuth ) return SQLITE_OK;\n\n    switch( code ) {\n    case SQLITE_COPY              :\n        zCode=\"SQLITE_COPY\";\n        break;\n    case SQLITE_CREATE_INDEX      :\n        zCode=\"SQLITE_CREATE_INDEX\";\n        break;\n    case SQLITE_CREATE_TABLE      :\n        zCode=\"SQLITE_CREATE_TABLE\";\n        break;\n    case SQLITE_CREATE_TEMP_INDEX :\n        zCode=\"SQLITE_CREATE_TEMP_INDEX\";\n        break;\n    case SQLITE_CREATE_TEMP_TABLE :\n        zCode=\"SQLITE_CREATE_TEMP_TABLE\";\n        break;\n    case SQLITE_CREATE_TEMP_TRIGGER:\n        zCode=\"SQLITE_CREATE_TEMP_TRIGGER\";\n        break;\n    case SQLITE_CREATE_TEMP_VIEW  :\n        zCode=\"SQLITE_CREATE_TEMP_VIEW\";\n        break;\n    case SQLITE_CREATE_TRIGGER    :\n        zCode=\"SQLITE_CREATE_TRIGGER\";\n        break;\n    case SQLITE_CREATE_VIEW       :\n        zCode=\"SQLITE_CREATE_VIEW\";\n        break;\n    case SQLITE_DELETE            :\n        zCode=\"SQLITE_DELETE\";\n        break;\n    case SQLITE_DROP_INDEX        :\n        zCode=\"SQLITE_DROP_INDEX\";\n        break;\n    case SQLITE_DROP_TABLE        :\n        zCode=\"SQLITE_DROP_TABLE\";\n        break;\n    case SQLITE_DROP_TEMP_INDEX   :\n        zCode=\"SQLITE_DROP_TEMP_INDEX\";\n        break;\n    case SQLITE_DROP_TEMP_TABLE   :\n        zCode=\"SQLITE_DROP_TEMP_TABLE\";\n        break;\n    case SQLITE_DROP_TEMP_TRIGGER :\n        zCode=\"SQLITE_DROP_TEMP_TRIGGER\";\n        break;\n    case SQLITE_DROP_TEMP_VIEW    :\n        zCode=\"SQLITE_DROP_TEMP_VIEW\";\n        break;\n    case SQLITE_DROP_TRIGGER      :\n        zCode=\"SQLITE_DROP_TRIGGER\";\n        break;\n    case SQLITE_DROP_VIEW         :\n        zCode=\"SQLITE_DROP_VIEW\";\n        break;\n    case SQLITE_INSERT            :\n        zCode=\"SQLITE_INSERT\";\n        break;\n    case SQLITE_PRAGMA            :\n        zCode=\"SQLITE_PRAGMA\";\n        break;\n    case SQLITE_READ              :\n        zCode=\"SQLITE_READ\";\n        break;\n    case SQLITE_SELECT            :\n        zCode=\"SQLITE_SELECT\";\n        break;\n    case SQLITE_TRANSACTION       :\n        zCode=\"SQLITE_TRANSACTION\";\n        break;\n    case SQLITE_UPDATE            :\n        zCode=\"SQLITE_UPDATE\";\n        break;\n    case SQLITE_ATTACH            :\n        zCode=\"SQLITE_ATTACH\";\n        break;\n    case SQLITE_DETACH            :\n        zCode=\"SQLITE_DETACH\";\n        break;\n    case SQLITE_ALTER_TABLE       :\n        zCode=\"SQLITE_ALTER_TABLE\";\n        break;\n    case SQLITE_REINDEX           :\n        zCode=\"SQLITE_REINDEX\";\n        break;\n    case SQLITE_ANALYZE           :\n        zCode=\"SQLITE_ANALYZE\";\n        break;\n    case SQLITE_CREATE_VTABLE     :\n        zCode=\"SQLITE_CREATE_VTABLE\";\n        break;\n    case SQLITE_DROP_VTABLE       :\n        zCode=\"SQLITE_DROP_VTABLE\";\n        break;\n    case SQLITE_FUNCTION          :\n        zCode=\"SQLITE_FUNCTION\";\n        break;\n    case SQLITE_SAVEPOINT         :\n        zCode=\"SQLITE_SAVEPOINT\";\n        break;\n    default                       :\n        zCode=\"????\";\n        break;\n    }\n    int i = 0;\n    Jsi_Value *vpargs, *items[10] = {}, *ret;\n    items[i++] = Jsi_ValueNewObj(interp, jdb->fobj);\n    items[i++] = Jsi_ValueMakeStringDup(interp, NULL, zCode);\n    items[i++] = Jsi_ValueMakeStringDup(interp, NULL, zArg1 ? zArg1 : \"\");\n    items[i++] = Jsi_ValueMakeStringDup(interp, NULL, zArg2 ? zArg2 : \"\");\n    items[i++] = Jsi_ValueMakeStringDup(interp, NULL, zArg3 ? zArg3 : \"\");\n    items[i++] = Jsi_ValueMakeStringDup(interp, NULL, zArg4 ? zArg4 : \"\");\n    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, i, 0));\n    Jsi_IncrRefCount(interp, vpargs);\n    ret = Jsi_ValueNew(interp);\n    rc = Jsi_FunctionInvoke(interp, jdb->onAuth, vpargs, &ret, NULL);\n    Jsi_DecrRefCount(interp, vpargs);\n\n    if (rc == JSI_OK && (zReply = Jsi_ValueGetStringLen(interp, ret, NULL)))\n    {\n        if( Jsi_Strcmp(zReply,\"SQLITE_OK\")==0 ) {\n            rc = SQLITE_OK;\n        } else if( Jsi_Strcmp(zReply,\"SQLITE_DENY\")==0 ) {\n            rc = SQLITE_DENY;\n        } else if( Jsi_Strcmp(zReply,\"SQLITE_IGNORE\")==0 ) {\n            rc = SQLITE_IGNORE;\n        } else {\n            rc = 999;\n        }\n    }\n    Jsi_DecrRefCount(interp, ret);\n    return rc;\n}\n\n/*\n** This routine reads a line of text from FILE in, stores\n** the text in memory obtained from malloc() and returns a pointer\n** to the text.  NULL is returned at end of file, or if malloc()\n** fails.\n**\n** The interface is like \"readline\" but no command-line editing\n** is done.\n**\n** copied from shell.c from '.import' command\n*/\nstatic char *dbLocalGetline(Jsi_Interp *interp, char *zPrompt, Jsi_Channel in) {\n    char *zLine;\n    int nLine;\n    int n;\n    int eol;\n\n    nLine = 100;\n    zLine = (char*)Jsi_Malloc( nLine );\n    if( zLine==0 ) return 0;\n    n = 0;\n    eol = 0;\n    while( !eol ) {\n        if( n+100>nLine ) {\n            nLine = nLine*2 + 100;\n            zLine = (char*)Jsi_Realloc(zLine, nLine);\n            if( zLine==0 ) return 0;\n        }\n        if( Jsi_Gets(interp, in, &zLine[n], nLine - n)==0 ) {\n            if( n==0 ) {\n                Jsi_Free(zLine);\n                return 0;\n            }\n            zLine[n] = 0;\n            eol = 1;\n            break;\n        }\n        while( zLine[n] ) {\n            n++;\n        }\n        if( n>0 && zLine[n-1]=='\\n' ) {\n            n--;\n            zLine[n] = 0;\n            eol = 1;\n        }\n    }\n    zLine = (char*)Jsi_Realloc( zLine, n+1 );\n    return zLine;\n}\n\n\n/*\n** This function is part of the implementation of the command:\n**\n**   $db transaction [-deferred|-immediate|-exclusive] SCRIPT\n**\n** It is invoked after evaluating the script SCRIPT to commit or rollback\n** the transaction or savepoint opened by the [transaction] command.\n*/\nstatic Jsi_RC dbTransPostCmd(\n    Jsi_Db *jdb,                       /* Sqlite3Db for $db */\n    Jsi_Interp *interp,                  /* Jsi interpreter */\n    Jsi_RC result                           /* Result of evaluating SCRIPT */\n) {\n    static const char *azEnd[] = {\n        \"RELEASE _jsi_transaction\",        /* rc==JSI_ERROR, nTransaction!=0 */\n        \"COMMIT\",                          /* rc!=JSI_ERROR, nTransaction==0 */\n        \"ROLLBACK TO _jsi_transaction ; RELEASE _jsi_transaction\",\n        \"ROLLBACK\"                         /* rc==JSI_ERROR, nTransaction==0 */\n    };\n    Jsi_RC rc = result;\n    const char *zEnd;\n\n    jdb->nTransaction--;\n    zEnd = azEnd[(rc==JSI_ERROR)*2 + (jdb->nTransaction==0)];\n\n    jdb->disableAuth++;\n    if( sqlite3_exec(jdb->db, zEnd, 0, 0, 0)) {\n        /* This is a tricky scenario to handle. The most likely cause of an\n        ** error is that the exec() above was an attempt to commit the\n        ** top-level transaction that returned SQLITE_BUSY. Or, less likely,\n        ** that an IO-error has occured. In either case, throw a Jsi exception\n        ** and try to rollback the transaction.\n        **\n        ** But it could also be that the user executed one or more BEGIN,\n        ** COMMIT, SAVEPOINT, RELEASE or ROLLBACK commands that are confusing\n        ** this method's logic. Not clear how this would be best handled.\n        */\n        if( rc!=JSI_ERROR ) {\n            Jsi_LogError(\"%s\", sqlite3_errmsg(jdb->db));\n            rc = JSI_ERROR;\n        }\n        sqlite3_exec(jdb->db, \"ROLLBACK\", 0, 0, 0);\n    }\n    jdb->disableAuth--;\n\n    return rc;\n}\n\n\n\n#if 0\nstatic void dbEvalRowInfo(\n    DbEvalContext *p,               /* Evaluation context */\n    int *pnCol,                     /* OUT: Number of column names */\n    char ***papColName,           /* OUT: Array of column names */\n    int **papColType\n) {\n    /* Compute column names */\n    // Jsi_Interp *interp = p->jdb->interp;\n\n    if( 0==p->apColName ) {\n        sqlite3_stmt *pStmt = p->pPreStmt->pStmt;\n        int i;                        /* Iterator variable */\n        int nCol;                     /* Number of columns returned by pStmt */\n        char **apColName = 0;      /* Array of column names */\n        int *apColType = 0;\n        const char *zColName;         /* Column name */\n        int numRid = 0;               /* Number of times rowid seen. */\n\n        p->nCol = nCol = sqlite3_column_count(pStmt);\n        if( nCol>0 && (papColName || p->pArray) ) {\n            int cnLen = sizeof(char*)*nCol, cnStart = cnLen;\n            for(i=0; i<nCol && cnLen<sizeof(p->staticColNames); i++)\n                cnLen += Jsi_Strlen(sqlite3_column_name(pStmt,i))+1;\n            if (cnLen>=sizeof(p->staticColNames)) {\n                apColName = (char**)Jsi_Calloc(nCol, sizeof(char*) );\n                cnStart = 0;\n            } else {\n                apColName = (char**)p->staticColNames;\n            }\n            if (papColType) {\n                if (nCol < SQL_MAX_STATIC_TYPES)\n                    apColType = p->staticColTypes;\n                else\n                    apColType = (int*)Jsi_Calloc(nCol, sizeof(int));\n            }\n            for(i=0; i<nCol; i++) {\n                zColName = sqlite3_column_name(pStmt,i);\n                if (cnStart==0)\n                    apColName[i] = Jsi_Strdup(zColName);\n                else {\n                    apColName[i] = p->staticColNames+cnStart;\n                    Jsi_Strcpy(apColName[i], zColName);\n                    cnStart += Jsi_Strlen(zColName)+1;\n                }\n                if (apColType)\n                    apColType[i] = sqlite3_column_type(pStmt,i);\n                /* Check if rowid appears first, and more than once. */\n                if ((i == 0 || numRid>0) &&\n                        (zColName[0] == 'r' && Jsi_Strcmp(zColName,\"rowid\") == 0)) {\n                    numRid++;\n                }\n            }\n            /* Change first rowid to oid. */\n            if (numRid > 1) {\n                if (apColName != (char**)p->staticColNames) {\n                    Jsi_Free(apColName[0]);\n                    apColName[0] = Jsi_Strdup(\"oid\");\n                } else {\n                    Jsi_Strcpy(apColName[0], \"oid\");\n                }\n            }\n            p->apColName = apColName;\n            p->apColType = apColType;\n        }\n    }\n    if( papColName ) {\n        *papColName = p->apColName;\n    }\n    if( papColType ) {\n        *papColType = p->apColType;\n    }\n    if( pnCol ) {\n        *pnCol = p->nCol;\n    }\n}\n#endif\n\n/*\n** Return a JSON formatted value for the iCol'th column of the row currently pointed to by\n** the DbEvalContext structure passed as the first argument.\n*/\nstatic void dbEvalSetColumnJSON(DbEvalContext *p, int iCol, Jsi_DString *dStr) {\n    Jsi_Interp *interp = p->jdb->interp;\n    char nbuf[200];\n\n    sqlite3_stmt *pStmt = p->pPreStmt->pStmt;\n\n    switch( sqlite3_column_type(pStmt, iCol) ) {\n    case SQLITE_BLOB: {\n        int bytes = sqlite3_column_bytes(pStmt, iCol);\n        const char *zBlob = (char*)sqlite3_column_blob(pStmt, iCol);\n        if( !zBlob ) {\n            Jsi_DSAppend(dStr, \"null\", NULL);\n            return;\n        }\n        Jsi_JSONQuote(interp, zBlob, bytes, dStr);\n        return;\n    }\n    case SQLITE_INTEGER: {\n        sqlite_int64 v = sqlite3_column_int64(pStmt, iCol);\n        if (v==0 || v==1) {\n            const char *dectyp = sqlite3_column_decltype(pStmt, iCol);\n            if (dectyp && !Jsi_Strncasecmp(dectyp,\"bool\", 4)) {\n                Jsi_DSAppend(dStr, (v?\"true\":\"false\"), NULL);\n                return;\n            }\n        }\n#ifdef __WIN32\n        snprintf(nbuf, sizeof(nbuf), \"%\" PRId64, (Jsi_Wide)v);\n#else\n        snprintf(nbuf, sizeof(nbuf), \"%lld\", v);\n#endif\n        Jsi_DSAppend(dStr, nbuf, NULL);\n        return;\n    }\n    case SQLITE_FLOAT: {\n        Jsi_NumberToString(interp, sqlite3_column_double(pStmt, iCol), nbuf, sizeof(nbuf));\n        Jsi_DSAppend(dStr, nbuf, NULL);\n        return;\n    }\n    case SQLITE_NULL: {\n        Jsi_DSAppend(dStr, \"null\", NULL);\n        return;\n    }\n    }\n    const char *str = (char*)sqlite3_column_text(pStmt, iCol );\n    if (!str)\n        str = p->jdb->optPtr->nullvalue;\n    Jsi_JSONQuote(interp, str?str:\"\", -1, dStr);\n}\n\nstatic void dbEvalSetColumn(DbEvalContext *p, int iCol, Jsi_DString *dStr) {\n    Jsi_Interp *interp = p->jdb->interp;\n    char nbuf[200];\n\n    sqlite3_stmt *pStmt = p->pPreStmt->pStmt;\n\n    switch( sqlite3_column_type(pStmt, iCol) ) {\n    case SQLITE_BLOB: {\n        int bytes = sqlite3_column_bytes(pStmt, iCol);\n        const char *zBlob = (char*)sqlite3_column_blob(pStmt, iCol);\n        if( !zBlob ) {\n            return;\n        }\n        Jsi_DSAppendLen(dStr, zBlob, bytes);\n        return;\n    }\n    case SQLITE_INTEGER: {\n        sqlite_int64 v = sqlite3_column_int64(pStmt, iCol);\n        if (v==0 || v==1) {\n            const char *dectyp = sqlite3_column_decltype(pStmt, iCol);\n            if (dectyp && !Jsi_Strncasecmp(dectyp,\"bool\", 4)) {\n                Jsi_DSAppend(dStr, (v?\"true\":\"false\"), NULL);\n                return;\n            }\n        }\n#ifdef __WIN32\n        snprintf(nbuf, sizeof(nbuf), \"%\" PRId64, (Jsi_Wide)v);\n#else\n        snprintf(nbuf, sizeof(nbuf), \"%lld\", v);\n#endif\n        Jsi_DSAppend(dStr, nbuf, NULL);\n        return;\n    }\n    case SQLITE_FLOAT: {\n        Jsi_NumberToString(interp, sqlite3_column_double(pStmt, iCol), nbuf, sizeof(nbuf));\n        Jsi_DSAppend(dStr, nbuf, NULL);\n        return;\n    }\n    case SQLITE_NULL: {\n        return;\n    }\n    }\n    const char *str = (char*)sqlite3_column_text(pStmt, iCol );\n    if (!str)\n        str = p->jdb->optPtr->nullvalue;\n    Jsi_DSAppend(dStr, str?str:\"\", NULL);\n}\n\n\nstatic Jsi_Value* dbEvalSetColumnValue(DbEvalContext *p, int iCol, Jsi_Value **val) {\n    Jsi_Interp *interp = p->jdb->interp;\n\n    sqlite3_stmt *pStmt = p->pPreStmt->pStmt;\n    const char *str;\n    \n    switch( sqlite3_column_type(pStmt, iCol) ) {\n    case SQLITE_BLOB: {\n        int bytes = sqlite3_column_bytes(pStmt, iCol);\n        const char *zBlob = (char*)sqlite3_column_blob(pStmt, iCol);\n        if( !zBlob )\n            return Jsi_ValueMakeNull(interp, val);\n        unsigned char *uptr = (unsigned char*)Jsi_Malloc(bytes+1);\n        memcpy(uptr, zBlob, bytes);\n        uptr[bytes] = 0;\n        return Jsi_ValueMakeBlob(interp, val, uptr, bytes);\n        break;\n    }\n    case SQLITE_INTEGER: {\n        sqlite_int64 v = sqlite3_column_int64(pStmt, iCol);\n        if (v==0 ||v==1) {\n            const char *dectyp = sqlite3_column_decltype(pStmt, iCol);\n            if (dectyp && !Jsi_Strncasecmp(dectyp,\"bool\", 4)) {\n                return Jsi_ValueMakeBool(interp, val, v);\n            }\n        }\n        if( v>=-2147483647 && v<=2147483647 ) {\n            return Jsi_ValueMakeNumber(interp, val, v);\n        } else {\n            return Jsi_ValueMakeNumber(interp, val, v);\n        }\n        break;\n    }\n    case SQLITE_FLOAT: {\n        return Jsi_ValueMakeNumber(interp, val, (Jsi_Number)sqlite3_column_double(pStmt, iCol));\n        break;\n    }\n    case SQLITE_NULL: {\n        return Jsi_ValueMakeNull(interp, val);\n        break;;\n    }\n    case SQLITE_TEXT: {\n        if (!p->jdb->noJsonConv) {\n            const char *dectyp = sqlite3_column_decltype(pStmt, iCol);\n            if (dectyp && !Jsi_Strncasecmp(dectyp, \"charjson\", 8)) {\n                Jsi_Value *v = Jsi_ValueNew(interp);// NULL; //Jsi_ValueNew1(interp);\n                str = (char*)sqlite3_column_text(pStmt, iCol );\n                if (JSI_OK != Jsi_JSONParse(interp, str, &v, 0))\n                    Jsi_LogWarn(\"JSON parse failure for CHARJSON column\");\n                return v;\n            }\n        }\n    }\n    default:\n        str = (char*)sqlite3_column_text(pStmt, iCol );\n        if (!str)\n            str = p->jdb->optPtr->nullvalue;\n        return Jsi_ValueMakeStringDup(interp, val, str?str:\"\");\n    }\n    return Jsi_ValueNew1(interp);\n}\n\n\n# define SQLITE_JSI_NRE 0\n# define DbUseNre() 0\n# define Jsi_NRAddCallback(a,b,c,d,e,f) 0\n# define Jsi_NREvalObj(a,b,c) 0\n# define Jsi_NRCreateCommand(a,b,c,d,e,f) 0\n\n#include <stdio.h>\n\nstatic Jsi_RC dbEvalCallCmd( DbEvalContext *p, Jsi_Interp *interp, Jsi_RC result)\n{\n    int cnt = 0;\n    Jsi_RC rc = result;\n    Jsi_Value *varg1;\n    Jsi_Obj *argso;\n    char **apColName = NULL;\n    int *apColType = NULL;\n    if (p->jdb->debug & TMODE_EVAL)\n        JSI_DBQUERY_PRINTF( \"DEBUG: eval\\n\");\n\n    while( (rc==JSI_OK) && JSI_OK==(rc = dbEvalStep(p)) ) {\n        int i;\n        int nCol;\n\n        cnt++;\n        dbEvalRowInfo(p, &nCol, &apColName, &apColType);\n        if (nCol<=0)\n            continue;\n        if (Jsi_ValueIsNull(interp,p->tocall))\n            continue;\n        /* Single object containing sql result members. */\n        varg1 = Jsi_ValueMakeObject(interp, NULL, argso = Jsi_ObjNew(interp));\n        for(i=0; i<nCol; i++) {\n            Jsi_Value *nnv = dbEvalSetColumnValue(p, i, NULL);\n            Jsi_ObjInsert(interp, argso, apColName[i], nnv, 0);\n        }\n        Jsi_IncrRefCount(interp, varg1);\n        bool rb = Jsi_FunctionInvokeBool(interp, p->tocall, varg1);\n        Jsi_DecrRefCount(interp, varg1);\n        if (Jsi_InterpGone(interp))\n            return JSI_ERROR;\n        if (rb)\n            break;\n    }\n    //dbEvalFinalize(p);\n\n    if( rc==JSI_OK || rc==JSI_BREAK ) {\n        //Jsi_ResetResult(interp);\n        rc = JSI_OK;\n    }\n    return rc;\n}\n\nstatic Jsi_Db *dbGetDbHandle(Jsi_Interp *interp, Jsi_Value *_this, Jsi_Func *funcPtr)\n{\n    Jsi_Db *jdb = (Jsi_Db*)Jsi_UserObjGetData(interp, _this, funcPtr);\n    if (!jdb) {\n        Jsi_LogError(\"Sqlite call to a non-sqlite object\");\n        return NULL;\n    }\n    if (!jdb->db)\n    {\n        Jsi_LogError(\"Sqlite db closed\");\n        return NULL;\n    }\n    return jdb;\n}\n\nstatic void sqliteObjErase(Jsi_Db *jdb)\n{\n    dbDeleteCmd(jdb);\n    jdb->db = NULL;\n}\n\nstatic Jsi_RC sqliteObjFree(Jsi_Interp *interp, void *data)\n{\n    Jsi_Db *db = (Jsi_Db*)data;\n    SQLSIGASSERT(db,DB);\n    db->_->activeCnt--;\n    sqliteObjErase(db);\n    _JSI_MEMCLEAR(db);\n    Jsi_Free(db);\n    return JSI_OK;\n}\n\nstatic bool sqliteObjIsTrue(void *data)\n{\n    Jsi_Db *db = (Jsi_Db*)data;\n    SQLSIGASSERT(db,DB);\n    if (!db->db) return 0;\n    else return 1;\n}\n\nstatic bool sqliteObjEqual(void *data1, void *data2)\n{\n    //SQLSIGASSERT(data1,DB);\n    //SQLSIGASSERT(data2,DB);\n    return (data1 == data2);\n}\n\nstatic Jsi_RC dbStmtFreeProc(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *value);\n\nstatic Jsi_RC SqliteConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                             Jsi_Value **ret, Jsi_Func *funcPtr);\n\nstatic Jsi_RC SqliteCollateCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                            Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Db *jdb;\n    Jsi_Value *func;\n\n    SqlCollate *pCollate;\n    char *zName;\n    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n\n    zName = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    func = Jsi_ValueArrayIndex(interp, args, 1);\n    pCollate = (SqlCollate*)Jsi_Calloc(1, sizeof(*pCollate));\n    if( pCollate==0 ) return JSI_ERROR;\n    pCollate->jdb = jdb;\n    pCollate->interp = interp;\n    pCollate->pNext = jdb->pCollate;\n    pCollate->zScript = func; /*(char*)&pCollate[1];*/\n    jdb->pCollate = pCollate;\n\n    if( sqlite3_create_collation(jdb->db, zName, SQLITE_UTF8, pCollate, dbSqlCollate) )\n    \n        return Jsi_LogError(\"%s\", (char *)sqlite3_errmsg(jdb->db));\n    return JSI_OK;\n}\n\nstatic const char *copyConflictStrs[] = {\n    \"ROLLBACK\", \"ABORT\", \"FAIL\", \"IGNORE\", \"REPLACE\", 0\n};\nenum { CC_ROLLBACK, CC_ABORT, CC_FAIL, CC_IGNORE, CC_REPLACE, CC__MAX };\n\ntypedef struct ImportData {\n    int limit;\n    int conflict;\n    bool csv;\n    bool headers;\n    const char *separator;\n    const char *nullvalue;\n} ImportData;\n\nstatic Jsi_OptionSpec ImportOptions[] =\n{\n    JSI_OPT(BOOL,   ImportData, headers, .help=\"First row contains column labels\"),\n    JSI_OPT(BOOL,   ImportData, csv, .help=\"Treat input values as CSV\"),\n    JSI_OPT(CUSTOM, ImportData, conflict, .help=\"Set conflict resolution\", .flags=0, .custom=Jsi_Opt_SwitchEnum,  .data=copyConflictStrs),\n    JSI_OPT(INT,    ImportData, limit, .help=\"Maximum number of lines to load\"),\n    JSI_OPT(STRKEY, ImportData, nullvalue, .help=\"Null string\"),\n    JSI_OPT(STRKEY, ImportData, separator, .help=\"Separator string; default is comma if csv, else tabs\"),\n    JSI_OPT_END(ImportData, .help=\"Options for the Sqlite import command\")\n};\n\n#define FN_import JSI_INFO(\"\\\nImport data from a file into table. SqlOptions include the 'separator' \\\nto use, which defaults to commas for csv, or tabs otherwise.\\n\\\nIf a column contains a null string, or the \\\nvalue of 'nullvalue', a null is inserted for the column.\\n\\\nA 'conflict' is one of the sqlite conflict algorithms: \\\n   rollback, abort, fail, ignore, replace\\n\\\nOn success, return the number of lines processed, not necessarily same \\\nas 'changeCnt' due to the conflict algorithm selected. \\\n\")\n\nstatic Jsi_RC SqliteImportCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                         Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Db *jdb;\n    Jsi_RC rv = JSI_OK;\n    int rc;\n    char *zTable;               /* Insert data into this table */\n    char *zFile;                /* The file from which to extract data */\n    const char *zConflict;            /* The conflict algorithm to use */\n    sqlite3_stmt *pStmt;        /* A statement */\n    int nCol;                   /* Number of columns in the table */\n    int nByte;                  /* Number of bytes in an SQL string */\n    int i, j;                   /* Loop counters */\n    int nSep;                   /* Number of bytes in zSep[] */\n    int nNull;                  /* Number of bytes in zNull[] */\n    char *zSql;                 /* An SQL statement */\n    char *zLine;                /* A single line of input from the file */\n    char **azCol;               /* zLine[] broken up into columns */\n    const char *onCommit;              /* How to commit changes */\n    Jsi_Channel in;                   /* The input file */\n    int lineno = 0;             /* Line number of input file */\n    int created = 0;\n    const char *zSep;\n    const char *zNull;\n\n    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 2);\n    ImportData opts = {};\n\n    if (arg) {\n        if (Jsi_OptionsProcess(interp, ImportOptions, &opts, arg, 0) < 0)\n            return JSI_ERROR;\n    }\n    zConflict = copyConflictStrs[opts.conflict];\n    \n    if(opts.separator ) {\n        zSep = opts.separator;\n    } else {\n        zSep = (opts.csv ? \",\" : \"\\t\");\n    }\n    if(opts.nullvalue ) {\n        zNull = opts.nullvalue;\n    } else {\n        zNull = \"\";\n    }\n    zTable = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    Jsi_Value *fname = Jsi_ValueArrayIndex(interp, args, 1);\n    zFile = Jsi_ValueArrayIndexToStr(interp, args, 1, NULL);\n    nSep = Jsi_Strlen(zSep);\n    nNull = Jsi_Strlen(zNull);\n    if( nSep==0 ) \n        return Jsi_LogError(\"Error: non-null separator required for copy\");\n\n\n    zSql = sqlite3_mprintf(\"SELECT * FROM '%q'\", zTable);\n    if (zSql==0) \n        return Jsi_LogError(\"Error: bad table: %s\", zTable);\n    \n    if (opts.headers) {\n        in = Jsi_Open(interp, fname, \"rb\");\n        if( in==0 ) \n            return Jsi_LogError(\"Error: cannot open file: %s\", zFile);\n        if ((zLine = dbLocalGetline(interp, 0, in))==0 ) {\n            Jsi_Close(interp, in);\n            return JSI_ERROR;\n        }\n        Jsi_Close(interp, in);\n        char *zn, *ze, *z = zLine;\n        Jsi_DString cStr = {};\n        int zlen = 0, icnt = 0;\n        Jsi_DSAppend(&cStr, \"CREATE TABLE IF NOT EXISTS '\", zTable, \"' (\", NULL);\n        while (1) {\n            zn = Jsi_Strstr(z, zSep);\n            if (!zn) zlen = Jsi_Strlen(z);\n            else zlen = zn-z;\n            if (zlen<=0) break;\n            ze = z+zlen-1;\n            Jsi_DSAppend(&cStr, (icnt?\",\":\"\"), \"'\", NULL);\n            icnt++;\n            if (opts.csv && *z=='\"' && zn>z && *ze == '\"')\n                Jsi_DSAppendLen(&cStr, z+1, zlen-2);\n            else\n                Jsi_DSAppendLen(&cStr, z, zlen);\n            Jsi_DSAppend(&cStr, \"'\", NULL);\n            if (!zn) break;\n            z = zn+nSep;\n        }\n        Jsi_DSAppend(&cStr, \");\", NULL);\n        Jsi_Free(zLine);\n        if (zlen<=0) {\n            Jsi_DSFree(&cStr);\n            Jsi_LogError(\"null header problem\");\n            return JSI_ERROR;\n        }\n        rc = sqlite3_exec(jdb->db, Jsi_DSValue(&cStr), 0, 0, 0);\n        Jsi_DSFree(&cStr);\n        if (rc) \n            return Jsi_LogError(\"%s\", sqlite3_errmsg(jdb->db));\n        created = 1;\n    }\n    \n    nByte = Jsi_Strlen(zSql);\n    rc = sqlite3_prepare(jdb->db, zSql, -1, &pStmt, 0);\n        sqlite3_free(zSql);\n    if( rc ) {\n        Jsi_LogError(\"%s\", sqlite3_errmsg(jdb->db));\n        nCol = 0;\n    } else {\n        nCol = sqlite3_column_count(pStmt);\n    }\n    sqlite3_finalize(pStmt);\n    if( nCol==0 ) {\n        rc = JSI_ERROR;\n        goto bail;\n    }\n    zSql = (char*)Jsi_Malloc( nByte + 50 + nCol*2 );\n    if( zSql==0 ) {\n        Jsi_LogError(\"Error: can't malloc()\");\n        rc = JSI_ERROR;\n        goto bail;\n    }\n    sqlite3_snprintf(nByte+50, zSql, \"INSERT OR %q INTO '%q' VALUES(?\",\n                     zConflict, zTable);\n    j = Jsi_Strlen(zSql);\n    for(i=1; i<nCol; i++) {\n        zSql[j++] = ',';\n        zSql[j++] = '?';\n    }\n    zSql[j++] = ')';\n    zSql[j] = 0;\n    rc = sqlite3_prepare(jdb->db, zSql, -1, &pStmt, 0);\n    Jsi_Free(zSql);\n    if( rc ) {\n        Jsi_LogError(\"Error: %s\", sqlite3_errmsg(jdb->db));\n        sqlite3_finalize(pStmt);\n        return JSI_ERROR;\n    }\n    in = Jsi_Open(interp, fname, \"rb\");\n    if( in==0 ) {\n        Jsi_LogError(\"Error: cannot open file: %s\", zFile);\n        sqlite3_finalize(pStmt);\n        return JSI_ERROR;\n    }\n    azCol = (char**)Jsi_Malloc( sizeof(azCol[0])*(nCol+1) );\n    if( azCol==0 ) {\n        Jsi_LogError(\"Error: can't malloc()\");\n        Jsi_Close(interp, in);\n        rc = JSI_ERROR;\n        goto bail;\n    }\n    (void)sqlite3_exec(jdb->db, \"BEGIN\", 0, 0, 0);\n    onCommit = \"COMMIT\";\n    while ((zLine = dbLocalGetline(interp, 0, in))!=0 ) {\n        char *z;\n        i = 0;\n        lineno++;\n        if (opts.limit>0 && lineno > opts.limit) {\n            Jsi_Free(zLine);\n            break;\n        }\n        if (lineno == 1 && opts.headers) {\n            Jsi_Free(zLine);\n            continue;\n        }\n        if (opts.csv && Jsi_Strchr(zLine,'\"')) \n        {\n            char *zn, *z = zLine;\n            Jsi_DString sStr = {};\n            int qcnt = 0;\n            i = -1;\n            while (*z) if (*z++ == '\"') qcnt++;\n            z = zLine;\n            if (qcnt%2) { /* aggregate quote spanning newlines */\n                Jsi_DSAppend(&sStr, zLine, NULL);\n                do {\n                    lineno++;\n                    Jsi_DSAppend(&sStr, \"\\n\", NULL);\n                    Jsi_Free(zLine);\n                    if (((zLine = dbLocalGetline(interp, 0, in)))==0)\n                        break;\n                    Jsi_DSAppend(&sStr, zLine, NULL);\n                    z = zLine;\n                    while (*z) if (*z++ == '\"') qcnt++;\n                } while (qcnt%2);\n                z = Jsi_DSValue(&sStr);\n            }\n            if (qcnt%2) {\n                Jsi_DSFree(&sStr);\n                Jsi_Free(zLine);\n                Jsi_Close(interp, in);\n                Jsi_LogError(\"unterminated string at line: %d\", lineno);\n                break;\n            }\n            while (z) {\n                if (*z != '\\\"') { /* Handle un-quoted value */\n                    zn = Jsi_Strstr(z, zSep);\n                    azCol[++i] = z;\n                    if (!zn)\n                        break;\n                    *zn = 0;\n                    z = zn+nSep;\n                    continue;\n                }\n                /* Handle quoted value */\n                zn = ++z;\n                Jsi_DString cStr = {};\n                while (1) {\n                    if (!zn)\n                        break;\n                    if (*zn != '\"')\n                        Jsi_DSAppendLen(&cStr, zn, 1);\n                    else {\n                        if (zn[1] == '\"') {\n                            zn++;\n                            Jsi_DSAppendLen(&cStr, \"\\\"\", 1);\n                        } else if (zn[1] == 0) {\n                            break;\n                        } else if (Jsi_Strncmp(zn+1,zSep, nSep)==0) {\n                            *zn = 0;\n                            zn += (nSep + 1);\n                            break;\n                        } else {\n                            /* Invalid, comma should be right after close quote, so just eat quote. */\n                            Jsi_DSAppendLen(&cStr, zn, 1);\n                        }\n                    }\n                    zn++;\n                }\n                Jsi_Strcpy(z, Jsi_DSValue(&cStr));\n                Jsi_DSFree(&cStr);\n                azCol[++i] = z;\n                z = zn;\n            }\n        } else {\n            azCol[0] = zLine;\n            for(i=0, z=zLine; *z; z++) {\n                if( *z==zSep[0] && Jsi_Strncmp(z, zSep, nSep)==0 ) {\n                    *z = 0;\n                    i++;\n                    if( i<nCol ) {\n                        azCol[i] = &z[nSep];\n                        z += nSep-1;\n                    }\n                }\n            }\n        }\n        if( i+1!=nCol ) {\n            Jsi_LogError(\"%s line %d: expected %d columns of data but found %d\",\n                 zFile, lineno, nCol, i+1);\n            onCommit = \"ROLLBACK\";\n            break;\n        }\n        for(i=0; i<nCol; i++) {\n            /* check for null data, if so, bind as null */\n            if( (nNull>0 && Jsi_Strcmp(azCol[i], zNull)==0)\n                    || Jsi_Strlen(azCol[i])==0\n              ) {\n                sqlite3_bind_null(pStmt, i+1);\n            } else {\n                sqlite3_bind_text(pStmt, i+1, azCol[i], -1, SQLITE_STATIC );\n            }\n        }\n        sqlite3_step(pStmt);\n        rc = sqlite3_reset(pStmt);\n        if (zLine)\n            Jsi_Free(zLine);\n        if( rc!=SQLITE_OK ) {\n            Jsi_LogError(\"%s at line: %d\", sqlite3_errmsg(jdb->db), lineno);\n            onCommit = \"ROLLBACK\";\n            break;\n        }\n    }\n    Jsi_Free(azCol);\n    Jsi_Close(interp, in);\n    sqlite3_finalize(pStmt);\n    (void)sqlite3_exec(jdb->db, onCommit, 0, 0, 0);\n\n    if( onCommit[0] == 'C' ) {\n        /* success, set result as number of lines processed */\n        Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)lineno);\n        rv = JSI_OK;\n    } else {\n        rv = JSI_ERROR;\n    }\n    \nbail:\n    if (rc != JSI_OK && created && opts.conflict == CC_ROLLBACK) {\n        Jsi_DString cStr = {};\n        Jsi_DSAppend(&cStr, \"DROP TABLE IF EXISTS '\", zTable, \"';\", NULL);\n        (void)sqlite3_exec(jdb->db, Jsi_DSValue(&cStr), 0, 0, 0);\n        Jsi_DSFree(&cStr);\n    }\n    return rv;\n}\n\n#define FN_evaluate JSI_INFO(\"\\\nSupports multiple semicolon seperated commands.\\n\\\nVariable binding is NOT performed, results are discarded, and  \\\nreturns sqlite3_changes()\")\nstatic Jsi_RC SqliteEvalCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                         Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int rc = SQLITE_OK, rc2;\n    Jsi_Db *jdb;\n    sqlite3_stmt *pStmt = NULL;\n\n    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    sqlite3 *db = jdb->db;\n    const char *zSql = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    const char *zStart = zSql, *zLeftover = NULL, *zErrMsg = NULL;\n    int lnum = 1;\n    if (jdb->echo && zSql)\n        Jsi_LogInfo(\"SQL-EVAL: %s\\n\", zSql); \n\n    while( zSql && zSql[0] && (SQLITE_OK == rc) ) {\n        rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, &zLeftover);\n\n        if( SQLITE_OK != rc ) {\n            break;\n        } else {\n            if( !pStmt ) {\n                /* this happens for a comment or white-space */\n                zSql = zLeftover;\n                while( isspace(zSql[0]) ) zSql++;\n                continue;\n            }\n\n            do {\n                if (jdb->debug & TMODE_STEP)\n                    JSI_DBQUERY_PRINTF( \"DEBUG: step: %s\\n\", zSql);\n                rc = sqlite3_step(pStmt);\n            } while( rc == SQLITE_ROW );\n            rc2 = sqlite3_finalize(pStmt);\n            if( rc!=SQLITE_NOMEM ) rc = rc2;\n            if( rc==SQLITE_OK ) {\n                zSql = zLeftover;\n                while( isspace(zSql[0]) ) zSql++;\n            } else {\n            }\n        }\n    }\n \n    if (rc == SQLITE_OK) {\n        Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)sqlite3_changes(jdb->db));\n        return JSI_OK;\n    }\n    while (zSql && zStart<zSql) {\n        if (zStart[0] == '\\n') lnum++;\n        zStart++;\n    }\n    zErrMsg = sqlite3_errmsg(db);\n    Jsi_LogError(\"sqlite error: %s in statement at line %d\", (zErrMsg ? zErrMsg : \"\"), lnum);\n    return JSI_ERROR;\n}\n\n/*\n** If a field contains any character identified by a 1 in the following\n** array, then the string must be quoted for CSV.\n*/\nstatic const char needCsvQuote[] = {\n  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   \n  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   \n  1, 0, 1, 0, 0, 0, 0, 1,   0, 0, 0, 0, 0, 0, 0, 0, \n  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, \n  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, \n  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, \n  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, \n  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 1, \n  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   \n  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   \n  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   \n  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   \n  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   \n  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   \n  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   \n  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   \n};\n\n/*\n** Output a single term of CSV.  Actually, p->separator is used for\n** the separator, which may or may not be a comma.  p->nullvalue is\n** the null value.  Strings are quoted if necessary.\n*/\nstatic void dbOutputCsv(QueryOpts *p, const char *z, Jsi_DString *dStr, int bSep)\n{\n    if( z==0 ) {\n        Jsi_DSAppend(dStr,  p->nullvalue?p->nullvalue:\"\", NULL);\n    } else {\n        int i;\n        int nSep = Jsi_Strlen(p->separator);\n        for(i=0; z[i]; i++) {\n            if( needCsvQuote[((unsigned char*)z)[i]] || \n                (z[i]==p->separator[0] && (nSep==1 || memcmp(z, p->separator, nSep)==0)) ) {\n                i = 0;\n                break;\n            }\n        }\n        if( i==0 ) {\n            Jsi_DSAppend(dStr, \"\\\"\", NULL);\n            for(i=0; z[i]; i++) {\n                if( z[i]=='\"' ) Jsi_DSAppend(dStr, \"\\\"\", NULL);\n                Jsi_DSAppendLen(dStr, z+i, 1);\n            }\n            Jsi_DSAppend(dStr, \"\\\"\", NULL);\n        } else {\n            Jsi_DSAppend(dStr, z, NULL);\n        }\n    }\n    if( bSep ) {\n        Jsi_DSAppend(dStr, p->separator, NULL);\n    }\n}\n\nstatic void dbOutputHtmlString(QueryOpts *p, const char *z, Jsi_DString *dStr)\n{\n    while( *z ) {\n        switch (*z) {\n        case '<':\n            Jsi_DSAppend(dStr, \"&lt;\", NULL);\n            break;\n        case '>':\n            Jsi_DSAppend(dStr, \"&gt;\", NULL);\n            break;\n        case '&':\n            Jsi_DSAppend(dStr, \"&amp;\", NULL);\n            break;\n        case '\\\"':\n            Jsi_DSAppend(dStr, \"&quot;\", NULL);\n            break;\n        case '\\'':\n            Jsi_DSAppend(dStr, \"&#39;\", NULL);\n            break;\n        default:\n            Jsi_DSAppendLen(dStr, z, 1);\n            break;\n        }\n        z++;\n    }\n}\n/*\n** Output the given string as a quoted string using SQL quoting conventions.\n*/\nstatic void dbOutputQuotedString(Jsi_DString *dStr, const char *z) {\n    int i;\n    int nSingle = 0;\n    for(i=0; z[i]; i++) {\n        if( z[i]=='\\'' ) nSingle++;\n    }\n    if( nSingle==0 ) {\n        Jsi_DSAppend(dStr,\"'\", z, \"'\", NULL);\n    } else {\n        Jsi_DSAppend(dStr,\"'\", NULL);\n        while( *z ) {\n            for(i=0; z[i] && z[i]!='\\''; i++) {}\n            if( i==0 ) {\n                Jsi_DSAppend(dStr,\"''\", NULL);\n                z++;\n            } else if( z[i]=='\\'' ) {\n                Jsi_DSAppendLen(dStr,z, i);\n                Jsi_DSAppend(dStr,\"''\", NULL);\n                z += i+1;\n            } else {\n                Jsi_DSAppend(dStr, z, NULL);\n                break;\n            }\n        }\n        Jsi_DSAppend(dStr,\"'\", NULL);\n    }\n}\n/*\n** Output the given string as a hex-encoded blob (eg. X'1234' )\n*/\nstatic void dbOutputHexBlob(Jsi_DString *dStr, const void *pBlob, int nBlob){\n  int i;\n  char out[100], *zBlob = (char *)pBlob;\n  Jsi_DSAppend(dStr, \"X'\", NULL);\n  for(i=0; i<nBlob; i++){ snprintf(out, sizeof(out),\"%02x\",zBlob[i]&0xff);Jsi_DSAppend(dStr, out, NULL); }\n  Jsi_DSAppend(dStr, \"'\", NULL);\n}\n\nbool dbIsAlnumStr(const char *cp)\n{\n    if (!cp || !*cp) return 0;\n    while (*cp)\n        if (isalnum(*cp) || *cp == '_')\n            cp++;\n        else\n            return 0;\n    return 1;\n}\n\n#define FN_sqlexec JSI_INFO(\"\\\nReturn values in formatted as JSON, HTML, etc. , optionally calling function with a result object\")\nstatic Jsi_RC SqliteQueryCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                             Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_RC rc = JSI_OK;\n    Jsi_Db *jdb;\n    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    Jsi_Value *vSql = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_DString eStr = {};\n#ifdef JSI_DB_DSTRING_SIZE\n    JSI_DSTRING_VAR(dStr, JSI_DB_DSTRING_SIZE);\n#else\n    Jsi_DString ddStr, *dStr = &ddStr;\n    Jsi_DSInit(dStr);\n#endif\n    const char *zSql = Jsi_ValueGetDString(interp, vSql, &eStr, 0);\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 1);\n    int cnt = 0;\n    char **apColName = NULL;\n    int *apColType = NULL, isopts = 0;\n    DbEvalContext sEval = {};\n    QueryOpts opts, *oEopt = jdb->optPtr;\n    opts = jdb->queryOpts;\n    opts.callback = NULL;\n    opts.width = NULL;\n    Jsi_Value *callback = NULL, *width = NULL;\n            \n    if (arg) {\n        if (Jsi_ValueIsFunction(interp,arg))\n            callback = opts.callback = arg;\n        else if (Jsi_ValueIsString(interp, arg))\n            opts.objName = Jsi_ValueString(interp, arg, NULL);\n        else if (Jsi_ValueIsObjType(interp, arg, JSI_OT_ARRAY))\n            opts.values = arg;\n        else if (Jsi_ValueIsObjType(interp, arg, JSI_OT_OBJECT))\n            isopts = 1;\n        else {\n            rc = Jsi_LogError(\"arg 2: expected function, string, array or options\");\n            goto bail;\n        }\n    }\n\n    if (isopts) {\n        if (Jsi_OptionsProcess(interp, ExecFmtOptions, &opts, arg, 0) < 0) {\n            rc = JSI_ERROR;\n            goto bail;\n        }\n        callback = (opts.callback ? opts.callback : jdb->queryOpts.callback);\n        width = (opts.width ? opts.width : jdb->queryOpts.width);\n    }\n    if (opts.retChanged) {\n        if (opts.callback) {\n            rc = Jsi_LogError(\"can not use retChanged with callback\");\n            goto bail;\n        }\n        opts.mode = _JSI_EF_NONE;\n        opts.headers = 0;\n    }\n    if (opts.cdata) {\n        Jsi_CDataDb* copts = Jsi_CDataLookup(interp, opts.cdata);\n        if (!copts)\n            rc = Jsi_LogError(\"unknown cdata name: %s\", opts.cdata);\n        else {\n            int n = Jsi_DbQuery(jdb, copts, zSql);\n            Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)n);\n        }\n        goto bail;\n    }\n    if (opts.objName) {\n        if (Jsi_SqlObjBinds(interp, &eStr, opts.objName, !(opts.objOpts&OBJMODE_NOTYPES), \n            !(opts.objOpts&OBJMODE_NODEFAULTS), (opts.objOpts&OBJMODE_NULLDEFAULTS)!=0) != JSI_OK)\n            goto bail;\n        zSql = Jsi_DSValue(&eStr);\n    }\n    if ((jdb->echo || opts.echo) && zSql)\n        Jsi_LogInfo(\"SQL-ECHO: %s\\n\", zSql); \n    if ((opts.objOpts&OBJMODE_SQLONLY)) {\n        if (opts.objName)\n            Jsi_ValueMakeStringDup(interp, ret, zSql);\n        else\n            rc = Jsi_LogError(\"'objOpts.sqlOnly' can only be used with 'objName'\");\n        goto bail;\n    }\n    if (!opts.separator) {\n        switch (opts.mode) {\n            case _JSI_EF_LIST: opts.separator = \"|\"; break;\n            case _JSI_EF_COLUMN: opts.separator = \" \"; break;\n            case _JSI_EF_TABS: opts.separator = \"\\t\"; break;\n            default: opts.separator = \",\";\n        }\n    }\n    Jsi_DString sStr;\n    Jsi_DSInit(&sStr);\n    sEval.nocache = opts.nocache;\n    if ((rc = dbEvalInit(interp, &sEval, jdb, zSql, &sStr, 0, 0)) != JSI_OK)\n        goto bail;\n    sEval.ret = *ret;\n    jdb->optPtr = &opts;\n    if (callback) {\n        sEval.tocall = callback;\n        if (opts.mode != _JSI_EF_ROWS) {\n            Jsi_LogError(\"'mode' must be 'rows' with 'callback'\");\n            rc = JSI_ERROR;\n            goto bail;\n        }\n        rc = dbEvalCallCmd(&sEval, interp, JSI_OK);\n        goto bail;\n    } else\n    switch (opts.mode) {\n    case _JSI_EF_NONE:\n        while(JSI_OK==(rc = dbEvalStep(&sEval)) ) {\n            cnt++;\n            if (opts.limit && cnt>=opts.limit) break;\n        }\n        if (opts.retChanged)\n            Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)sqlite3_changes(jdb->db));\n        if (rc == JSI_BREAK)\n            rc = JSI_OK;\n        goto bail;\n        break;\n    case _JSI_EF_JSON:\n        if (opts.headers) {\n            Jsi_DSAppend(dStr, \"[ \", NULL);\n            while( JSI_OK==(rc = dbEvalStep(&sEval)) ) {\n                int i;\n                int nCol;\n                dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n                if (cnt == 0) {\n                    Jsi_DSAppend(dStr, \"[\", NULL);\n                    for(i=0; i<nCol; i++) {\n                        if (i)\n                            Jsi_DSAppend(dStr, \", \", NULL);\n                        Jsi_JSONQuote(interp, apColName[i], -1, dStr);\n                    }\n                    Jsi_DSAppend(dStr, \"]\", NULL);\n                    cnt++;\n                }\n                if (cnt)\n                    Jsi_DSAppend(dStr, \", \", NULL);\n                Jsi_DSAppend(dStr, \"[\", NULL);\n                for(i=0; i<nCol; i++) {\n                    if (i)\n                        Jsi_DSAppend(dStr, \", \", NULL);\n                    dbEvalSetColumnJSON(&sEval, i, dStr);\n                }\n                Jsi_DSAppend(dStr, \"]\", NULL);\n                cnt++;\n                if (opts.limit && cnt>opts.limit) break;\n            }\n            Jsi_DSAppend(dStr, \" ]\", NULL);\n            \n        } else {\n            Jsi_DSAppend(dStr, \"[ \", NULL);\n            while( JSI_OK==(rc = dbEvalStep(&sEval)) ) {\n                int i;\n                int nCol;\n                dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n                if (cnt)\n                    Jsi_DSAppend(dStr, \", \", NULL);\n                Jsi_DSAppend(dStr, \"{\", NULL);\n                for(i=0; i<nCol; i++) {\n                    if (i)\n                        Jsi_DSAppend(dStr, \", \", NULL);\n                    Jsi_JSONQuote(interp, apColName[i], -1, dStr);\n                    Jsi_DSAppend(dStr, \":\", NULL);\n                    dbEvalSetColumnJSON(&sEval, i, dStr);\n                }\n                Jsi_DSAppend(dStr, \"}\", NULL);\n                cnt++;\n                if (opts.limit && cnt>=opts.limit) break;\n            }\n            Jsi_DSAppend(dStr, \" ]\", NULL);\n        }\n        break;\n        \n    case _JSI_EF_JSON2: {\n            while( JSI_OK==(rc = dbEvalStep(&sEval)) ) {\n                int i;\n                int nCol;\n                dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n                if (cnt == 0 && 1) {\n                    Jsi_DSAppend(dStr, \"{ \\\"names\\\": [ \", NULL);\n                    for(i=0; i<nCol; i++) {\n                        if (i)\n                            Jsi_DSAppend(dStr, \", \", NULL);\n                        Jsi_JSONQuote(interp, apColName[i], -1, dStr);\n                    }\n                    Jsi_DSAppend(dStr, \" ], \\\"values\\\": [ \", NULL);\n                }\n                if (cnt)\n                    Jsi_DSAppend(dStr, \", \", NULL);\n                Jsi_DSAppend(dStr, \"[\", NULL);\n                for(i=0; i<nCol; i++) {\n                    if (i)\n                        Jsi_DSAppend(dStr, \", \", NULL);\n                    dbEvalSetColumnJSON(&sEval, i, dStr);\n                }\n                Jsi_DSAppend(dStr, \" ]\", NULL);\n                cnt++;\n                if (opts.limit && cnt>=opts.limit) break;\n            }\n            if (cnt)\n                Jsi_DSAppend(dStr, \" ] } \", NULL);\n        }\n        break;\n        \n    case _JSI_EF_LIST:\n        while( JSI_OK==(rc = dbEvalStep(&sEval)) ) {\n            int i;\n            int nCol;\n            dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n            if (cnt == 0 && opts.headers) {\n                for(i=0; i<nCol; i++) {\n                    if (i)\n                        Jsi_DSAppend(dStr, opts.separator, NULL);\n                    Jsi_DSAppend(dStr, apColName[i], NULL);\n                }\n            }\n\n            if (cnt || opts.headers)\n                Jsi_DSAppend(dStr, \"\\n\", NULL);\n            for(i=0; i<nCol; i++) {\n                if (i)\n                    Jsi_DSAppend(dStr, opts.separator, NULL);\n                dbEvalSetColumn(&sEval, i, dStr);\n            }\n            cnt++;\n            if (opts.limit && cnt>=opts.limit) break;\n        }\n        break;\n        \n    case _JSI_EF_COLUMN: {\n        int *wids = NULL;\n        Jsi_DString vStr = {};\n        while( JSI_OK==(rc = dbEvalStep(&sEval)) ) {\n            int i, w;\n            int nCol;\n            \n            dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n            if (cnt == 0 && nCol>0) {\n                Jsi_DString sStr;\n                wids = (int*)Jsi_Calloc(nCol, sizeof(int));\n                Jsi_DSInit(&sStr);\n                for(i=0; i<nCol; i++) {\n                    int j = Jsi_Strlen(apColName[i]);\n                    wids[i] = (j<10?10:j);\n                    if (width) {\n                        Jsi_Value *wv = Jsi_ValueArrayIndex(interp, width, i);\n                        if (wv) {\n                            Jsi_Number dv;\n                            Jsi_ValueGetNumber(interp, wv, &dv);\n                            if (dv>0)\n                                wids[i] = (int)dv;\n                        }\n                    }\n                    w = (j<wids[i] ? j : wids[i]);\n                    Jsi_DSAppendLen(dStr, apColName[i], w);\n                    w = (j<wids[i] ? wids[i]-j+1 : 0);\n                    while (w-- > 0)\n                        Jsi_DSAppend(dStr, \" \", NULL);\n                }\n                for(i=0; i<nCol && opts.headers; i++) {\n                    w = wids[i];\n                    w -= Jsi_Strlen(apColName[i]);\n                    if (i) {\n                        Jsi_DSAppend(dStr, opts.separator, NULL);\n                        Jsi_DSAppend(&sStr, opts.separator, NULL);\n                    }\n                    w = wids[i];\n                    while (w-- > 0)\n                        Jsi_DSAppend(&sStr, \"-\", NULL);\n                }\n                if (opts.headers)\n                    Jsi_DSAppend(dStr, \"\\n\", Jsi_DSValue(&sStr), \"\\n\", NULL);\n                Jsi_DSFree(&sStr);\n            }\n\n            if (cnt)\n                Jsi_DSAppend(dStr, \"\\n\", NULL);\n            for(i=0; i<nCol; i++) {\n                if (i)\n                    Jsi_DSAppend(dStr, opts.separator, NULL);\n                Jsi_DSSetLength(&vStr, 0);\n                dbEvalSetColumn(&sEval, i, &vStr);\n                int nl = Jsi_DSLength(&vStr);\n                if (nl > wids[i]) {\n                    Jsi_DSSetLength(&vStr, wids[i]);\n                    w = 0;\n                } else {\n                    w = wids[i]-nl;\n                }\n                Jsi_DSAppend(dStr, Jsi_DSValue(&vStr), NULL);\n                while (w-- > 0)\n                    Jsi_DSAppend(dStr, \" \", NULL);\n            }\n            cnt++;\n            if (opts.limit && cnt>=opts.limit) break;\n        }\n        Jsi_DSFree(&vStr);\n        if (wids)\n            Jsi_Free(wids);\n        break;\n    }\n    \n    case _JSI_EF_INSERT: {\n        Jsi_DString vStr = {};    \n        while( JSI_OK==(rc = dbEvalStep(&sEval)) ) {\n            int i;\n            int nCol;\n            const char *tbl = (opts.table ? opts.table : \"table\");\n            Jsi_DSAppend(dStr, \"INSERT INTO \\\"\", tbl, \"\\\" VALUES(\", NULL);\n            dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n            for(i=0; i<nCol; i++) {\n                Jsi_Number dv;\n                const char *azArg;\n                Jsi_DSSetLength(&vStr, 0);\n                dbEvalSetColumn(&sEval, i, &vStr);\n                sqlite3_stmt *pStmt = sEval.pPreStmt->pStmt;\n                int ptype = sqlite3_column_type(pStmt, i);\n                \n                azArg = Jsi_DSValue(&vStr);\n                const char *zSep = i>0 ? \",\": \"\";\n                if(apColType && apColType[i]==SQLITE_NULL) {\n                  Jsi_DSAppend(dStr, zSep, \"NULL\", NULL);\n                }else if( ptype ==SQLITE_TEXT ) {\n                  if( zSep[0] ) Jsi_DSAppend(dStr,zSep, NULL);\n                  dbOutputQuotedString(dStr, azArg);\n                }else if (ptype==SQLITE_INTEGER || ptype ==SQLITE_FLOAT) {\n                  Jsi_DSAppend(dStr, zSep, azArg, NULL);\n                }else if (ptype ==SQLITE_BLOB) {\n                  const void *pBlob = sqlite3_column_blob(pStmt, i );\n                  int nBlob = sqlite3_column_bytes(pStmt, i);\n                  if( zSep[0] ) Jsi_DSAppend(dStr,zSep, NULL);\n                  dbOutputHexBlob(dStr, pBlob, nBlob);\n                }else if( Jsi_GetDouble(interp, azArg, &dv) == JSI_OK ){\n                  Jsi_DSAppend(dStr, zSep, azArg, NULL);\n                }else{\n                  if( zSep[0] ) Jsi_DSAppend(dStr,zSep, NULL);\n                  dbOutputQuotedString(dStr, azArg);\n                }\n            }\n            Jsi_DSAppend(dStr, \");\\n\", NULL);\n            cnt++;\n            if (opts.limit && cnt>=opts.limit) break;\n        }\n        Jsi_DSFree(&vStr);\n    }\n\n    case _JSI_EF_TABS:\n    case _JSI_EF_CSV: {\n        Jsi_DString vStr = {};  \n        while( JSI_OK==(rc = dbEvalStep(&sEval)) ) {\n            int i;\n            int nCol;\n            dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n            if (cnt == 0 && opts.headers) {\n                for(i=0; i<nCol; i++) {\n                    if (i)\n                        Jsi_DSAppend(dStr, opts.separator, NULL);\n                    Jsi_DSAppend(dStr, apColName[i], NULL);\n                }\n            }\n\n            if (cnt || opts.headers)\n                Jsi_DSAppend(dStr, \"\\n\", NULL);\n            for(i=0; i<nCol; i++) {\n                if (i)\n                    Jsi_DSAppend(dStr, opts.separator, NULL);\n                Jsi_DSSetLength(&vStr, 0);\n                dbEvalSetColumn(&sEval, i, &vStr);\n                if (opts.mode == _JSI_EF_CSV)\n                    dbOutputCsv(&opts, Jsi_DSValue(&vStr), dStr, 0);\n                else\n                    Jsi_DSAppend(dStr, Jsi_DSValue(&vStr), NULL);\n            }\n            cnt++;\n            if (opts.limit && cnt>=opts.limit) break;\n        }\n        Jsi_DSFree(&vStr);\n        break;\n    }\n        \n    case _JSI_EF_LINE: {\n        int i, w = 5, ww;\n        int nCol;\n        Jsi_DString vStr = {};   \n        while( JSI_OK==(rc = dbEvalStep(&sEval)) ) {\n            dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n            if (cnt == 0) {\n                for(i=0; i<nCol; i++) {\n                    ww = Jsi_Strlen(apColName[i]);\n                    if (ww>w)\n                        w = ww;\n                }\n            }\n\n            for(i=0; i<nCol; i++) {\n                Jsi_DString eStr;\n                Jsi_DSInit(&eStr);\n                Jsi_DSSetLength(&vStr, 0);\n                dbEvalSetColumn(&sEval, i, &vStr);\n                Jsi_DSPrintf(&eStr, \"%*s = %s\", w, apColName[i], Jsi_DSValue(&vStr));\n                Jsi_DSAppend(dStr, (cnt?\"\\n\":\"\"), Jsi_DSValue(&eStr), NULL);\n                Jsi_DSFree(&eStr);\n            }\n            cnt++;\n            if (opts.limit && cnt>=opts.limit) break;\n        }\n        Jsi_DSFree(&vStr);\n        break;\n    }\n        \n    case _JSI_EF_HTML: {\n        Jsi_DString vStr = {};   \n        while( JSI_OK==(rc = dbEvalStep(&sEval)) ) {\n            int i;\n            int nCol;\n            dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n            if (cnt == 0 && opts.headers) {\n                Jsi_DSAppend(dStr, \"<TR>\", NULL);\n                for(i=0; i<nCol; i++) {\n                    Jsi_DSAppend(dStr, \"<TH>\", NULL);\n                    dbOutputHtmlString(&opts, apColName[i], dStr);\n                    Jsi_DSAppend(dStr, \"</TH>\", NULL);\n                }\n                Jsi_DSAppend(dStr, \"</TR>\", NULL);\n            }\n            if (cnt || opts.headers)\n                Jsi_DSAppend(dStr, \"\\n\", NULL);\n            Jsi_DSAppend(dStr, \"<TR>\", NULL);\n            for(i=0; i<nCol; i++) {\n                Jsi_DSAppend(dStr, \"<TD>\", NULL);\n                Jsi_DSSetLength(&vStr, 0);\n                dbEvalSetColumn(&sEval, i, &vStr);\n                dbOutputHtmlString(&opts, Jsi_DSValue(&vStr), dStr);\n                Jsi_DSAppend(dStr, \"</TD>\", NULL);\n            }\n            Jsi_DSAppend(dStr, \"</TR>\", NULL);\n            cnt++;\n            if (opts.limit && cnt>=opts.limit) break;\n        }\n        Jsi_DSFree(&vStr);\n        break;\n    }\n        \n    case _JSI_EF_ROWS:\n    {\n        Jsi_Value *vcur, *vrow;\n        int cnt = 0;\n        Jsi_Obj *oall, *ocur;\n        Jsi_ValueMakeArrayObject(interp, ret, oall = Jsi_ObjNewType(interp, JSI_OT_ARRAY));\n\n        while( JSI_OK==(rc = dbEvalStep(&sEval)) ) {\n            int i;\n            int nCol;\n            dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n            ocur = Jsi_ObjNewType(interp, JSI_OT_OBJECT);\n            vrow = Jsi_ValueMakeObject(interp, NULL, ocur);\n            for(i=0; i<nCol; i++) {\n                vcur = dbEvalSetColumnValue(&sEval, i, NULL);\n                Jsi_ObjInsert(interp, ocur, apColName[i], vcur, 0);\n            }\n            Jsi_ObjArrayAdd(interp, oall, vrow);\n            cnt++;\n            if (opts.limit && cnt>=opts.limit) break;\n        }\n        dbEvalFinalize(&sEval);\n        if (rc != JSI_ERROR)\n            rc = JSI_OK;\n        goto bail;\n        break;\n    }\n    case _JSI_EF_ARRAYS:\n    {\n        Jsi_Value *vcur, *vrow;\n        int cnt = 0;\n        Jsi_Obj *oall, *ocur;\n        Jsi_ValueMakeArrayObject(interp, ret, oall = Jsi_ObjNewType(interp, JSI_OT_ARRAY));\n\n        while( JSI_OK==(rc = dbEvalStep(&sEval)) ) {\n            int i;\n            int nCol;\n            dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n            if (cnt == 0 && opts.headers) {\n                vrow = Jsi_ValueMakeArrayObject(interp, NULL, ocur = Jsi_ObjNewType(interp, JSI_OT_ARRAY));\n                for(i=0; i<nCol; i++) {\n                    vcur = Jsi_ValueNewStringDup(interp, apColName[i]);\n                    Jsi_ObjArrayAdd(interp, ocur, vcur);\n                }\n                Jsi_ObjArrayAdd(interp, oall, vrow);\n            }\n            vrow = Jsi_ValueMakeArrayObject(interp, NULL, ocur = Jsi_ObjNewType(interp, JSI_OT_ARRAY));\n            for(i=0; i<nCol; i++) {\n                vcur = dbEvalSetColumnValue(&sEval, i, NULL);\n                Jsi_ObjArrayAdd(interp, ocur, vcur);\n            }\n            Jsi_ObjArrayAdd(interp, oall, vrow);\n            cnt++;\n            if (opts.limit && cnt>=opts.limit) break;\n        }\n        dbEvalFinalize(&sEval);\n        if (rc != JSI_ERROR)\n            rc = JSI_OK;\n        goto bail;\n        break;\n    }\n    case _JSI_EF_ARRAY1D:\n    {\n        Jsi_Value *vcur;\n        int cnt = 0;\n        Jsi_Obj *oall;\n        Jsi_ValueMakeArrayObject(interp, ret, oall = Jsi_ObjNewType(interp, JSI_OT_ARRAY));\n\n        while( JSI_OK==(rc = dbEvalStep(&sEval)) ) {\n            int i;\n            int nCol;\n            dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n            if (cnt == 0 && opts.headers) {\n                for(i=0; i<nCol; i++) {\n                    vcur = Jsi_ValueNewStringDup(interp, apColName[i]);\n                    Jsi_ObjArrayAdd(interp, oall, vcur);\n                }\n            }\n            for(i=0; i<nCol; i++) {\n                vcur = dbEvalSetColumnValue(&sEval, i, NULL);\n                Jsi_ObjArrayAdd(interp, oall, vcur);\n            }\n            cnt++;\n            if (opts.limit && cnt>=opts.limit) break;\n        }\n        dbEvalFinalize(&sEval);\n        if (rc != JSI_ERROR)\n            rc = JSI_OK;\n        goto bail;\n        break;\n    }\n    }\n    if (opts.retChanged)\n        Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)sqlite3_changes(jdb->db));\n    else\n        Jsi_ValueFromDS(interp, dStr, ret);\n    if( rc==JSI_BREAK )\n        rc = JSI_OK;\nbail:\n    dbEvalFinalize(&sEval);\n    if (isopts) {\n        Jsi_OptionsFree(interp, ExecFmtOptions, &opts, 0);\n    }\n    Jsi_DSFree(dStr);\n    Jsi_DSFree(&eStr);\n    jdb->optPtr = oEopt;\n    return rc;\n}\n\nstatic Jsi_RC SqliteOnecolumnCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                          Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_RC rc;\n    Jsi_Db *jdb;\n    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    Jsi_Value *vSql = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    Jsi_DString sStr;\n    Jsi_DSInit(&sStr);\n    DbEvalContext sEval = {};\n    const char *zSql = Jsi_ValueGetDString(interp, vSql, &dStr, 0);\n\n    sEval.nocache = jdb->queryOpts.nocache;\n    if ((rc = dbEvalInit(interp, &sEval, jdb, zSql, &sStr, 0, 0)) != JSI_OK)\n        return rc;\n    sEval.ret = *ret;\n    sEval.tocall = NULL;\n    int cnt = 0;\n\n\n    if( JSI_OK==(rc = dbEvalStep(&sEval)) ) {\n        sqlite3_stmt *pStmt = sEval.pPreStmt->pStmt;\n        int nCol = sqlite3_column_count(pStmt);\n        if (nCol>0)\n            dbEvalSetColumnValue(&sEval, 0, ret);\n        cnt++;\n    }\n    dbEvalFinalize(&sEval);\n    if( rc==JSI_BREAK ) {\n        rc = JSI_OK;\n    }\n    Jsi_DSFree(&dStr);\n    return rc;\n}\n\nstatic Jsi_RC SqliteExistsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                           Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_RC rc;\n    Jsi_Db *jdb;\n    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    Jsi_Value *vSql = Jsi_ValueArrayIndex(interp, args, 0);\n    const char *zSql;\n    Jsi_DString dStr = {};\n    DbEvalContext sEval = {};\n    zSql = Jsi_ValueGetDString(interp, vSql, &dStr, 0);\n\n    Jsi_DString sStr;\n    Jsi_DSInit(&sStr);\n    sEval.nocache = jdb->queryOpts.nocache;\n    if (dbEvalInit(interp, &sEval, jdb, zSql, &sStr, 0, 0) != JSI_OK)\n        return JSI_ERROR;\n    sEval.ret = *ret;\n    int cnt = 0;\n\n\n    if( JSI_OK==(rc = dbEvalStep(&sEval)) ) {\n        sqlite3_stmt *pStmt = sEval.pPreStmt->pStmt;\n        int nCol = sqlite3_column_count(pStmt);\n        if (nCol>0)\n            cnt++;\n    }\n    dbEvalFinalize(&sEval);\n    if( rc==JSI_BREAK ) {\n        rc = JSI_OK;\n    }\n    Jsi_DSFree(&dStr);\n    Jsi_ValueMakeBool(interp, ret, cnt);\n    return rc;\n}\n\nstatic Jsi_RC SqliteFilenameCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                             Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n#if (SQLITE_VERSION_NUMBER>3007009)\n    const char *zName = \"main\";\n    int argc = Jsi_ValueGetLength(interp, args);\n    Jsi_Db *jdb;\n\n    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    if (argc)\n        zName = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    zName = sqlite3_db_filename(jdb->db, zName);\n    if (zName)\n        Jsi_ValueMakeStringDup(interp, ret, zName);\n#endif\n    return JSI_OK;\n}\n\n/*\n** Find an SqlFunc structure with the given name.  Or create a new\n** one if an existing one cannot be found.  Return a pointer to the\n** structure.\n*/\nstatic SqlFunc *dbFindSqlFunc(Jsi_Db *jdb, const char *zName) {\n    SqlFunc *p, *pNew;\n    int i;\n    pNew = (SqlFunc*)Jsi_Calloc(1, sizeof(*pNew) + Jsi_Strlen(zName) + 1 );\n    pNew->sig = SQLITE_SIG_FUNC;\n    pNew->zName = (char*)&pNew[1];\n    for(i=0; zName[i]; i++) {\n        pNew->zName[i] = tolower(zName[i]);\n    }\n    pNew->zName[i] = 0;\n    for(p=jdb->pFunc; p; p=p->pNext) {\n        if( Jsi_Strcmp(p->zName, pNew->zName)==0 ) {\n            Jsi_Free((char*)pNew);\n            return p;\n        }\n    }\n    pNew->interp = jdb->interp;\n    pNew->pScript = 0;\n    Jsi_DSInit(&pNew->dScript);\n    pNew->pNext = jdb->pFunc;\n    jdb->pFunc = pNew;\n    return pNew;\n}\n\nstatic Jsi_RC SqliteFunctionCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                             Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    SqlFunc *pFunc;\n    Jsi_Value *tocall, *nVal;\n    char *zName;\n    int rc, nArg = -1, argc;\n    argc = Jsi_ValueGetLength(interp, args);\n    Jsi_Db *jdb;\n\n    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n\n    zName = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    tocall = Jsi_ValueArrayIndex(interp, args, 1);\n    if (zName == NULL) \n        return Jsi_LogError(\"expected name\");\n    if (!Jsi_ValueIsFunction(interp, tocall)) \n        return Jsi_LogError(\"expected function\");\n    if (argc == 3) {\n        nVal = Jsi_ValueArrayIndex(interp, args, 2);\n        if (Jsi_GetIntFromValue(interp, nVal, &nArg) != JSI_OK)\n            return JSI_ERROR;\n    } else {\n        Jsi_FunctionArguments(interp, tocall, &nArg);\n    }\n    if (nArg > SQLITE_LIMIT_FUNCTION_ARG) \n        return Jsi_LogError(\"to many args\");\n    /*  if( argc==6 ){\n        const char *z = Jsi_GetString(objv[3]);\n        int n = Jsi_Strlen(z);\n        if( n>2 && strncmp(z, \"-argcount\",n)==0 ){\n          if( Jsi_GetIntFromObj(interp, objv[4], &nArg) ) return JSI_ERROR;\n          if( nArg<0 )\n              return Jsi_LogError( \"number of arguments must be non-negative\");\n        }\n        pScript = objv[5];\n      }else if( argc!=4 ){\n        Jsi_WrongNumArgs(interp, 2, objv, \"NAME [-argcount N] SCRIPT\");\n        return JSI_ERROR;\n      }else{\n        pScript = objv[3];\n      }*/\n    pFunc = dbFindSqlFunc(jdb, zName);\n    if( pFunc==0 ) return JSI_ERROR;\n    SQLSIGASSERT(pFunc,FUNC);\n\n    pFunc->tocall = tocall;\n    Jsi_IncrRefCount(interp, pFunc->tocall);\n    rc = sqlite3_create_function(jdb->db, zName, nArg, SQLITE_UTF8,\n                                 pFunc, jsiSqlFunc, 0, 0);\n                                 \n    if( rc!=SQLITE_OK ) {\n        rc = JSI_ERROR;\n        Jsi_LogError(\"function create error: %s\", (char *)sqlite3_errmsg(jdb->db));\n    }\n    return JSI_OK;\n}\n\n\nstatic Jsi_RC SqliteInterruptCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                              Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Db *jdb;\n    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    sqlite3_interrupt(jdb->db);\n    return JSI_OK;\n}\n\n\nstatic Jsi_RC SqliteCompleteCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                             Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Db *jdb;\n    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    Jsi_Value *s = Jsi_ValueArrayIndex(interp, args, 0);\n    const char *str =  Jsi_ValueString(interp, s, NULL);\n    int isComplete = 0;\n    if (str)\n        isComplete = sqlite3_complete( str );\n    Jsi_ValueMakeBool(interp, ret, isComplete);\n    return JSI_OK;\n}\n\n#define FN_restore JSI_INFO(\"\\\n   db.restore(FILENAME, ?,DATABASE? ) \\\n\\n\\\nOpen a database file named FILENAME.  Transfer the content \\\nof FILENAME into the local database DATABASE (default: 'main').\")\n\nstatic Jsi_RC SqliteRestoreCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                            Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Db *jdb;\n    const char *zSrcFile;\n    const char *zDestDb;\n    sqlite3 *pSrc;\n    sqlite3_backup *pBackup;\n    int nTimeout = 0;\n    int rc;\n\n    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    Jsi_Value *vFile = Jsi_ValueArrayIndex(interp, args, 0);\n    int argc = Jsi_ValueGetLength(interp, args);\n    if( argc==1 ) {\n        zDestDb = \"main\";\n    } else {\n        zDestDb = Jsi_ValueArrayIndexToStr(interp, args, 1, NULL);\n    }\n    Jsi_DString dStr = {};\n    if (!vFile)\n        zSrcFile = \":memory:\";\n    else {\n        zSrcFile = Jsi_ValueNormalPath(interp, vFile, &dStr);\n        if (zSrcFile == NULL) \n            return Jsi_LogError(\"bad or missing file name\");\n    }\n    rc = sqlite3_open_v2(zSrcFile, &pSrc, SQLITE_OPEN_READONLY, 0);\n\n    if( rc!=SQLITE_OK ) {\n        Jsi_LogError(\"cannot open source database: %s\", sqlite3_errmsg(pSrc));\n        DbClose(pSrc);\n        Jsi_DSFree(&dStr);\n        return JSI_ERROR;\n    }\n    pBackup = sqlite3_backup_init(jdb->db, zDestDb, pSrc, \"main\");\n    if( pBackup==0 ) {\n        Jsi_LogError(\"restore failed: %s\", sqlite3_errmsg(jdb->db));\n        DbClose(pSrc);\n        Jsi_DSFree(&dStr);\n        return JSI_ERROR;\n    }\n    while( (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK\n            || rc==SQLITE_BUSY ) {\n        if( rc==SQLITE_BUSY ) {\n            if( nTimeout++ >= 3 ) break;\n            sqlite3_sleep(100);\n        }\n    }\n    sqlite3_backup_finish(pBackup);\n    Jsi_RC rv;\n    if( rc==SQLITE_DONE ) {\n        rv = JSI_OK;\n    } else if( rc==SQLITE_BUSY || rc==SQLITE_LOCKED ) {\n        Jsi_LogError(\"restore failed: source database busy\");\n        rv = JSI_ERROR;\n    } else {\n        Jsi_LogError(\"restore failed: %s\", sqlite3_errmsg(jdb->db));\n        rv = JSI_ERROR;\n    }\n    Jsi_DSFree(&dStr);\n    DbClose(pSrc);\n    return rv;\n}\n\n#define FN_transaction JSI_INFO(\"\\\nStart a new transaction (if we are not already in the midst of a \\\ntransaction) and execute the JS function FUNC.\\n\\\nAfter FUNC completes, either commit the transaction or roll it back if FUNC throws an exception.\\n\\\nOr if no new transation was started, do nothing. \\\npass the exception on up the stack.\")\nstatic Jsi_RC SqliteTransactionCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                                Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int rc;\n    Jsi_Db *jdb;\n\n    int argc = Jsi_ValueGetLength(interp, args);\n    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n\n    Jsi_Value *pScript;\n    const char *zBegin = \"SAVEPOINT _jsi_transaction\";\n\n    if( jdb->nTransaction==0 && argc==2 ) {\n        Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);\n        static const char *TTYPE_strs[] = {\n            \"deferred\",   \"exclusive\",  \"immediate\", 0\n        };\n        enum TTYPE_enum {\n            TTYPE_DEFERRED, TTYPE_EXCLUSIVE, TTYPE_IMMEDIATE\n        };\n        int ttype;\n        if( Jsi_ValueGetIndex(interp, arg, TTYPE_strs, \"transaction type\",\n                              0, &ttype) ) {\n            return JSI_ERROR;\n        }\n        switch( (enum TTYPE_enum)ttype ) {\n        case TTYPE_DEFERRED:    /* no-op */\n            ;\n            break;\n        case TTYPE_EXCLUSIVE:\n            zBegin = \"BEGIN EXCLUSIVE\";\n            break;\n        case TTYPE_IMMEDIATE:\n            zBegin = \"BEGIN IMMEDIATE\";\n            break;\n        }\n    }\n    pScript = Jsi_ValueArrayIndex(interp, args, argc-1);\n    if(!Jsi_ValueIsFunction(interp, pScript)) \n        return Jsi_LogError(\"expected function\");\n\n    /* Run the SQLite BEGIN command to open a transaction or savepoint. */\n    jdb->disableAuth++;\n    rc = sqlite3_exec(jdb->db, zBegin, 0, 0 ,0);\n    jdb->disableAuth--;\n    if( rc!=SQLITE_OK ) \n        return Jsi_LogError(\"%s\", sqlite3_errmsg(jdb->db));\n    jdb->nTransaction++;\n\n    /* Evaluate the function , then\n    ** call function dbTransPostCmd() to commit (or rollback) the transaction\n    ** or savepoint.  */\n    Jsi_RC rv = Jsi_FunctionInvoke(interp, pScript, NULL, NULL, NULL);\n    rv = dbTransPostCmd(jdb, interp, rv);\n    return rv;\n}\n\n#define FN_backup JSI_INFO(\"\\\nOpen or create a database file named FILENAME.\\n\\\nTransfer the content of local database DATABASE (default: 'main') into the \\\nFILENAME database.\")\n\nstatic Jsi_RC SqliteBackupCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                           Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Db *jdb;\n    Jsi_RC rv = JSI_OK;\n    int rc;\n    const char *zDestFile;\n    const char *zSrcDb;\n    sqlite3 *pDest;\n    sqlite3_backup *pBackup;\n\n    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    Jsi_Value *vFile = Jsi_ValueArrayIndex(interp, args, 0);\n    int argc = Jsi_ValueGetLength(interp, args);\n    if( argc==1 ) {\n        zSrcDb = \"main\";\n    } else {\n        zSrcDb = Jsi_ValueArrayIndexToStr(interp, args, 1, NULL);\n    }\n    Jsi_DString dStr = {};\n    if (!vFile)\n        zDestFile = \":memory:\";\n    else {\n        zDestFile = Jsi_ValueNormalPath(interp, vFile, &dStr);\n        if (zDestFile == NULL) \n            return Jsi_LogError(\"bad or missing file name\");\n    }\n    rc = sqlite3_open(zDestFile, &pDest);\n    if( rc!=SQLITE_OK ) {\n        Jsi_LogError(\"cannot open target database %s: %s\", zDestFile, sqlite3_errmsg(pDest));\n        DbClose(pDest);\n        Jsi_DSFree(&dStr);\n        return JSI_ERROR;\n    }\n    pBackup = sqlite3_backup_init(pDest, \"main\", jdb->db, zSrcDb);\n    if( pBackup==0 ) {\n        Jsi_LogError(\"backup failed: %s\", sqlite3_errmsg(pDest));\n        DbClose(pDest);\n        Jsi_DSFree(&dStr);\n        return JSI_ERROR;\n    }\n    while(  (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK ) {}\n    sqlite3_backup_finish(pBackup);\n    if( rc==SQLITE_DONE ) {\n        rv = JSI_OK;\n    } else {\n        Jsi_LogError(\"backup failed: %s\", sqlite3_errmsg(pDest));\n        rv = JSI_ERROR;\n    }\n    Jsi_DSFree(&dStr);\n    DbClose(pDest);\n    return rv;\n}\n\nvoid dbSetupCallbacks(Jsi_Db *jdb, Jsi_Db *ojdb)\n{\n    if (jdb->onAuth && (!ojdb || !ojdb->onAuth) )\n        sqlite3_set_authorizer(jdb->db, dbAuthCallback, jdb);\n    else\n        sqlite3_set_authorizer(jdb->db, 0, 0);\n\n    if (jdb->onCommit && (!ojdb || !ojdb->onCommit) )\n        sqlite3_commit_hook(jdb->db, dbCommitHandler, jdb);\n    else\n        sqlite3_commit_hook(jdb->db, 0, 0);\n\n    if (jdb->onBusy && (!ojdb || !ojdb->onBusy) )\n        sqlite3_busy_handler(jdb->db, dbBusyHandler, jdb);\n    else\n        sqlite3_busy_handler(jdb->db, 0, 0);\n    \n    if (jdb->onTrace && (!ojdb || !ojdb->onTrace) )\n        sqlite3_trace(jdb->db, dbTraceHandler, jdb);\n    else\n        sqlite3_trace(jdb->db, 0, 0);\n\n    if (jdb->onNeedCollate && (!ojdb || !ojdb->onNeedCollate) )\n        sqlite3_collation_needed(jdb->db, jdb, dbCollateNeeded);\n    else\n        sqlite3_collation_needed(jdb->db, 0, 0);\n\n    if (jdb->onUpdate && (!ojdb || !ojdb->onUpdate) )\n        sqlite3_update_hook(jdb->db, dbUpdateHandler, jdb);\n    else\n        sqlite3_update_hook(jdb->db, 0, 0);\n\n    if (jdb->onWalHook && (!ojdb || !ojdb->onWalHook) )\n        sqlite3_wal_hook(jdb->db, dbWalHandler, jdb);\n    else\n        sqlite3_wal_hook(jdb->db, 0, 0);\n\n    if (jdb->onRollback && (!ojdb || !ojdb->onRollback) )\n        sqlite3_rollback_hook(jdb->db, dbRollbackHandler, jdb);\n    else\n        sqlite3_rollback_hook(jdb->db, 0, 0);\n\n    if (jdb->onProfile && (!ojdb || !ojdb->onProfile) )\n        sqlite3_profile(jdb->db, dbProfileHandler, jdb);\n    else\n        sqlite3_profile(jdb->db, 0, 0);\n\n    if (jdb->onProgress && jdb->progressSteps && (!ojdb || !ojdb->onProgress || ojdb->progressSteps != jdb->progressSteps) )\n        sqlite3_progress_handler(jdb->db, jdb->progressSteps, dbProgressHandler, jdb);\n    else\n        sqlite3_progress_handler(jdb->db, 0, 0, 0);\n    \n    if (!ojdb || jdb->load != ojdb->load)\n        sqlite3_enable_load_extension(jdb->db, jdb->load);\n\n    if (!ojdb || jdb->timeout != ojdb->timeout)\n        sqlite3_busy_timeout( jdb->db, jdb->timeout );\n\n/*    if (jdb->onUnlock && (!ojdb || !ojdb->onUnlock) )\n        sqlite3_unlock_notify(jdb->db, dbUnlockNotify, (void*)jdb);\n    else\n        sqlite3_unlock_notify(jdb->db, 0, 0);\n        */\n}\n\n\nstatic Jsi_RC SqliteConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                         Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Db *jdb, ojdb;\n    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    Jsi_Value *opts = Jsi_ValueArrayIndex(interp, args, 0);\n    if (jdb->noConfig && opts && !Jsi_ValueIsString(interp, opts))\n        return Jsi_LogError(\"Socket conf() is disabled for set\");\n    ojdb = *jdb;\n    \n    jdb->lastInsertId = sqlite3_last_insert_rowid(jdb->db);\n    jdb->changeCnt = sqlite3_changes(jdb->db);\n    jdb->changeCntAll = sqlite3_total_changes(jdb->db);\n    jdb->errorCode = sqlite3_errcode(jdb->db);\n    \n    Jsi_RC rc = Jsi_OptionsConf(interp, SqlOptions, jdb, opts, ret, 0);\n    \n    if (jdb->stmtCacheMax<0 || jdb->stmtCacheMax>MAX_PREPARED_STMTS) {\n        JSI_DBQUERY_PRINTF( \"option stmtCacheMax value %d is not in range 0..%d\", jdb->stmtCacheMax, MAX_PREPARED_STMTS);\n        jdb->stmtCacheMax = ojdb.stmtCacheMax;\n        rc = JSI_ERROR;\n    }\n    dbSetupCallbacks(jdb, &ojdb);\n    dbPrepStmtLimit(jdb);\n    return rc;\n}\n\nstatic Jsi_CmdSpec sqliteCmds[] = {\n    { \"Sqlite\",         SqliteConstructor,      0,  2,  \"file:null|string=void, options:object=void\",\n        .help=\"Create a new db connection to the named file or :memory:\",\n        .retType=(uint)JSI_TT_USEROBJ, .flags=JSI_CMD_IS_CONSTRUCTOR, .info=0, .opts=SqlOptions },\n    { \"backup\",         SqliteBackupCmd,        1,  2, \"file:string, dbname:string='main'\", .help=\"Backup db to file\", .retType=(uint)JSI_TT_VOID, .flags=0, .info=FN_backup },\n    { \"collate\",        SqliteCollateCmd,       2,  2, \"name:string, callback:function\", .help=\"Create new SQL collation command\", .retType=(uint)JSI_TT_VOID },\n    { \"complete\",       SqliteCompleteCmd,      1,  1, \"sql:string\", .help=\"Return true if sql is complete\", .retType=(uint)JSI_TT_BOOLEAN },\n    { \"conf\",           SqliteConfCmd,          0,  1, \"options:string|object=void\", .help=\"Configure options\", .retType=(uint)JSI_TT_ANY, .flags=0, .info=0, .opts=SqlOptions },\n    { \"eval\",           SqliteEvalCmd,          1,  1, \"sql:string\", .help=\"Run sql commands without input/output\", .retType=(uint)JSI_TT_NUMBER, .flags=0, .info=FN_evaluate },\n    { \"exists\",         SqliteExistsCmd,        1,  1, \"sql:string\", .help=\"Execute sql, and return true if there is at least one result value\", .retType=(uint)JSI_TT_BOOLEAN },\n    { \"filename\",       SqliteFilenameCmd,      0,  1, \"name:string='main'\", .help=\"Return filename for named or all attached databases\", .retType=(uint)JSI_TT_STRING },\n    { \"func\",           SqliteFunctionCmd,      2,  3, \"name:string, callback:function, numArgs:number=void\", .help=\"Register a new function with database\", .retType=(uint)JSI_TT_VOID },\n    { \"import\",         SqliteImportCmd,        2,  3, \"table:string, file:string, options:object=void\", .help=\"Import data from file into table \", .retType=(uint)JSI_TT_NUMBER, .flags=0, .info=FN_import, .opts=ImportOptions },\n    { \"interrupt\",      SqliteInterruptCmd,     0,  0, \"\", .help=\"Interrupt in progress statement\", .retType=(uint)JSI_TT_VOID },\n    { \"onecolumn\",      SqliteOnecolumnCmd,     1,  1, \"sql:string\", .help=\"Execute sql, and return a single value\", .retType=(uint)JSI_TT_ANY },\n    { \"query\",          SqliteQueryCmd,         1,  2, \"sql:string, options:function|string|array|object=void\", .help=\"Evaluate an sql query with bindings\", .retType=(uint)JSI_TT_ANY, .flags=0, .info=FN_sqlexec, .opts=ExecFmtOptions },\n    { \"restore\",        SqliteRestoreCmd,       1,  2, \"file:string, dbname:string\", .help=\"Restore db from file (default db is 'main')\", .retType=(uint)JSI_TT_VOID, .flags=0, .info=FN_restore },\n    { \"transaction\",    SqliteTransactionCmd,   1,  2, \"callback:function, type:string=void\", .help=\"Call function inside db tranasaction. Type is: 'deferred', 'exclusive', 'immediate'\", .retType=(uint)JSI_TT_VOID, .flags=0, .info=FN_transaction },\n    { NULL, 0,0,0,0, .help=\"Commands for accessing sqlite databases\" }\n};\n\n//static Jsi_CmdSpec sqliteCmds[];\n\n\nstatic Jsi_UserObjReg sqliteobject = {\n    .name   = \"Sqlite\",\n    .spec   = sqliteCmds,\n    .freefun= sqliteObjFree,\n    .istrue = sqliteObjIsTrue,\n    .isequ  = sqliteObjEqual\n};\n\n/**   new Sqlite(FILENAME,?-vfs VFSNAME?,?-key KEY?,?-readonly BOOLEAN?,\n**                           ?-create BOOLEAN?,?-nomutex BOOLEAN?)\n**\n** This is the sqlite constructior called  using \"new Sqlite\".\n**\n** The first argument is the name of the database file.\n**\n*/\n\nstatic Jsi_RC SqliteConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                             Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_RC rc = JSI_ERROR;\n    /* void *cd = clientData; */\n    int  flags;\n    char *zErrMsg;\n    const char *zFile = NULL, *vfs = 0;\n    /* In normal use, each JSI interpreter runs in a single thread.  So\n    ** by default, we can turn of mutexing on SQLite database connections.\n    ** However, for testing purposes it is useful to have mutexes turned\n    ** on.  So, by default, mutexes default off.  But if compiled with\n    ** SQLITE_JSI_DEFAULT_FULLMUTEX then mutexes default on.\n    */\n    flags = SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE;\n#ifdef SQLITE_JSI_DEFAULT_FULLMUTEX\n    flags |= SQLITE_OPEN_FULLMUTEX;\n#else\n    flags |= SQLITE_OPEN_NOMUTEX;\n#endif\n\n    Jsi_Value *vFile = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 1);\n    Jsi_DString dStr = {};\n    int ismem = 0, create = 0;\n    Jsi_Obj *fobj;\n    Jsi_Value *toacc;\n    const char *vf;\n    const char *dbname = NULL;\n    \n    if (vFile==NULL || Jsi_ValueIsNull(interp, vFile) ||\n        ((vf = Jsi_ValueString(interp, vFile, NULL)) && !Jsi_Strcmp(vf,\":memory:\"))) {\n        zFile = \":memory:\";\n        ismem = 1;\n    } else {\n        zFile = Jsi_ValueNormalPath(interp, vFile, &dStr);\n        if (zFile == NULL) \n            return Jsi_LogError(\"bad or missing file name\");\n        Jsi_StatBuf st = {};\n        st.st_uid = -1;\n        create = (Jsi_Lstat(interp, vFile, &st) != 0);\n    }\n    zErrMsg = 0;\n    Jsi_Db *db = (Jsi_Db*)Jsi_Calloc(1, sizeof(*db) );\n    if( db==0 ) {\n        Jsi_DSFree(&dStr);\n        Jsi_LogError(\"malloc failed\");\n        return JSI_ERROR;\n    }\n    db->sig = SQLITE_SIG_DB;\n    db->_ = &dbObjCmd;\n    db->_->newCnt++;\n    db->_->activeCnt++;\n    db->stmtCacheMax = NUM_PREPARED_STMTS;\n    db->hasOpts = 1;\n    if ((arg != NULL && !Jsi_ValueIsNull(interp,arg))\n        && Jsi_OptionsProcess(interp, SqlOptions, db, arg, 0) < 0) {\n        rc = JSI_ERROR;\n        goto bail;\n    }\n    if (ismem == 0 &&\n        (Jsi_InterpAccess(interp, vFile, (db->readonly ? JSI_INTACCESS_READ : JSI_INTACCESS_WRITE)) != JSI_OK\n        || (create && Jsi_InterpAccess(interp, vFile, JSI_INTACCESS_CREATE) != JSI_OK))) {\n        Jsi_LogError(\"Safe accces denied\");\n        goto bail;\n    }\n\n    if (db->stmtCacheMax<0 || db->stmtCacheMax>MAX_PREPARED_STMTS) {\n        Jsi_LogError(\"option stmtCacheMax value %d is not in range 0..%d\", db->stmtCacheMax, MAX_PREPARED_STMTS);\n        goto bail;\n    }\n    if (!db->udata) {\n        db->udata = Jsi_ValueNewObj(interp, NULL);\n        Jsi_IncrRefCount(interp, db->udata);\n    }\n    if (db->readonly) {\n        flags &= ~(SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE);\n        flags |= SQLITE_OPEN_READONLY;\n    } else {\n        flags &= ~SQLITE_OPEN_READONLY;\n        flags |= SQLITE_OPEN_READWRITE;\n        if (db->noCreate) {\n            flags &= ~SQLITE_OPEN_CREATE;\n        }\n    }\n    if (db->vfs)\n        vfs = Jsi_ValueToString(interp, db->vfs, NULL);\n    if(db->mutex == MUTEX_NONE) {\n        flags |= SQLITE_OPEN_NOMUTEX;\n        flags &= ~SQLITE_OPEN_FULLMUTEX;\n    } else {\n        flags &= ~SQLITE_OPEN_NOMUTEX;\n    }\n    if(db->mutex ==MUTEX_FULL) {\n        flags |= SQLITE_OPEN_FULLMUTEX;\n        flags &= ~SQLITE_OPEN_NOMUTEX;\n    } else {\n        flags &= ~SQLITE_OPEN_FULLMUTEX;\n    }\n  \n    if (SQLITE_OK != sqlite3_open_v2(zFile, &db->db, flags, vfs)) {\n        Jsi_LogError(\"db open failed: %s\", zFile);\n        goto bail;\n    }\n    //Jsi_DSFree(&translatedFilename);\n\n    if( SQLITE_OK!=sqlite3_errcode(db->db) ) {\n        zErrMsg = sqlite3_mprintf(\"%s\", sqlite3_errmsg(db->db));\n        DbClose(db->db);\n        db->db = 0;\n    }\n    if( db->db==0 ) {\n        sqlite3_free(zErrMsg);\n        goto bail;\n    }\n;\n    toacc = NULL;\n    if (Jsi_FunctionIsConstructor(funcPtr)) {\n        toacc = _this;\n    } else {\n        Jsi_Obj *o = Jsi_ObjNew(interp);\n        Jsi_PrototypeObjSet(interp, \"Sqlite\", o);\n        Jsi_ValueMakeObject(interp, ret, o);\n        toacc = *ret;\n    }\n    sqlite3_create_function(db->db, \"unixtime\", -1, SQLITE_UTF8, db, jsiSqlFuncUnixTime, 0, 0);\n    \n    fobj = Jsi_ValueGetObj(interp, toacc /* constructor obj*/);\n    if ((db->objId = Jsi_UserObjNew(interp, &sqliteobject, fobj, db))<0)\n        goto bail;\n    db->stmtHash = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);\n    db->fobj = fobj;\n    //dbSys->cnt = Jsi_UserObjCreate(interp, sqliteobject.name /*dbSys*/, fobj, db);\n    db->interp = interp;\n    db->optPtr = &db->queryOpts;\n    db->stmtCache = Jsi_ListNew((Jsi_Interp*)db, 0, dbStmtFreeProc);\n    rc = JSI_OK;\n    dbname = Jsi_DSValue(&db->name);\n    if (dbname[0])\n        sqlite3_db_config(db->db, SQLITE_DBCONFIG_MAINDBNAME, dbname);\n    Jsi_JSONParseFmt(interp, &db->version, \"{libVer:\\\"%s\\\", hdrVer:\\\"%s\\\", hdrNum:%d, hdrSrcId:\\\"%s\\\", pkgVer:%d}\",\n        (char *)sqlite3_libversion(), SQLITE_VERSION, SQLITE_VERSION_NUMBER, SQLITE_SOURCE_ID, jsi_DbPkgVersion); \n    dbSetupCallbacks(db, NULL);\n    \nbail:\n    if (rc != JSI_OK) {\n        if (db->hasOpts)\n            Jsi_OptionsFree(interp, SqlOptions, db, 0);\n        db->_->activeCnt--;\n        Jsi_Free(db);\n    }\n    Jsi_DSFree(&dStr);\n    Jsi_ValueMakeUndef(interp, ret);\n    return rc;\n}\n\n#endif\n\ntypedef struct {\n    Jsi_CDataDb *binds;\n    Jsi_StructSpec *rowidPtr, *dirtyPtr;\n    int optLen;             /* Length of binds[0].binds */\n} OptionBind;\n\nconst char *jsi_DbOptionTypeStr(Jsi_OptionId typ, bool cname)\n{\n    const Jsi_OptionTypedef* ti = Jsi_OptionTypeInfo(typ);\n    if (ti)\n        return (cname?ti->cName:ti->idName);\n    return NULL;\n}\n\nstatic Jsi_RC dbBindOptionStmt(Jsi_Db *jdb, sqlite3_stmt *pStmt, OptionBind *obPtr,\n                            int dataIdx, int bindMax, Jsi_CDataDb *dbopts)\n{\n    Jsi_Interp *interp = jdb->interp;\n    int j, k, cnt = 0, idx, sidx = -1, rc = 0;\n    Jsi_StructSpec *specPtr, *specs;\n    void *rec;\n    Jsi_DString *eStr;\n    const char *bName;\n    int lastBind = sqlite3_bind_parameter_count(pStmt);\n    if (lastBind<=0)\n        return JSI_OK;\n    int structSize = 0;\n    Jsi_Wide flags = 0;\n    sqlite3_destructor_type statFlags = ((dbopts->noStatic)?SQLITE_TRANSIENT:SQLITE_STATIC);\n    specPtr = dbopts[0].sf;\n    structSize = specPtr[obPtr->optLen].size;\n    \n    for (j=1; j<=lastBind; j++) {\n        bName = sqlite3_bind_parameter_name(pStmt, j);\n        if (bName==NULL || bName[0]==0 || bName[1]==0)\n            continue;\n        idx = j;\n        if (dbopts[0].prefix==0)\n            k = 0;\n        else {\n            for (k=0; dbopts[k].sf; k++) {\n                if (bName[0] == dbopts[k].prefix)\n                    break;\n            }\n            if (bindMax>0 && k>=bindMax)\n                continue;\n            if (!dbopts[k].sf) {\n                Jsi_LogError(\"bad bind: %s\", bName);\n                continue;\n            }\n        }\n        specs = dbopts[k].sf;\n        rec = dbopts[k].data;\n        if (k==0) {\n            if (dbopts->isMap) {\n                Jsi_Map *map = *(typeof(map)*)rec;\n                rec = Jsi_MapEntryFind(map, (void*)(intptr_t)dataIdx);\n                if (!rec) return JSI_ERROR;\n            } else if (dbopts->isPtrs)\n                rec = ((void**)rec)[dataIdx];\n            else\n                rec = ((uchar*)rec)+ (dataIdx * structSize);\n        }\n        if (bName[0] == '?')\n            sidx = atoi(bName+1);\n        for (specPtr = specs, cnt=1; specPtr->id>=JSI_OPTION_BOOL && specPtr->id < JSI_OPTION_END; specPtr++, cnt++) {\n            if (specPtr->flags&JSI_OPT_DB_IGNORE)\n                continue;\n            if (bName[0] == '?') {\n                if (cnt == sidx)\n                    break;\n            } else {\n                const char *sName = specPtr->name;\n                if (bName[1] == sName[0] && !Jsi_Strcmp(bName+1, sName))\n                    break;\n            }\n        }\n        if (specPtr->id<JSI_OPTION_BOOL || specPtr->id>=JSI_OPTION_END) \n            return Jsi_LogError(\"unknown bind: %s\", bName);\n\n        char *ptr = (char *)rec + specPtr->offset;\n        switch (specPtr->id) {\n        case JSI_OPTION_BOOL:\n            rc = sqlite3_bind_int(pStmt, idx, *(int*)ptr);\n            break;\n        case JSI_OPTION_INT: rc = sqlite3_bind_int64(pStmt, idx, *(int*)ptr); break;\n        case JSI_OPTION_UINT:rc = sqlite3_bind_int64(pStmt, idx, *(uint*)ptr); break;\n        case JSI_OPTION_INT8: rc = sqlite3_bind_int64(pStmt, idx, *(int8_t*)ptr); break;\n        case JSI_OPTION_UINT8:rc = sqlite3_bind_int64(pStmt, idx, *(uint8_t*)ptr); break;\n        case JSI_OPTION_INT16: rc = sqlite3_bind_int64(pStmt, idx, *(int16_t*)ptr); break;\n        case JSI_OPTION_UINT16:rc = sqlite3_bind_int64(pStmt, idx, *(uint16_t*)ptr); break;\n        case JSI_OPTION_INT32: rc = sqlite3_bind_int64(pStmt, idx, *(int32_t*)ptr); break;\n        case JSI_OPTION_UINT32:rc = sqlite3_bind_int64(pStmt, idx, *(uint32_t*)ptr); break;\n        case JSI_OPTION_TIME_W:\n        case JSI_OPTION_INT64: rc = sqlite3_bind_int64(pStmt, idx, *(int64_t*)ptr); break;\n        case JSI_OPTION_UINT64:rc = sqlite3_bind_int64(pStmt, idx, *(uint64_t*)ptr); break;\n        case JSI_OPTION_USHORT:rc = sqlite3_bind_int64(pStmt, idx, *(ushort*)ptr); break;\n        case JSI_OPTION_SHORT:rc = sqlite3_bind_int64(pStmt, idx, *(short*)ptr); break;\n        case JSI_OPTION_LONG:rc = sqlite3_bind_int64(pStmt, idx, *(long*)ptr); break;\n        case JSI_OPTION_ULONG:rc = sqlite3_bind_int64(pStmt, idx, *(ulong*)ptr); break;\n        case JSI_OPTION_INTPTR_T:rc = sqlite3_bind_int64(pStmt, idx, *(intptr_t*)ptr); break;\n        case JSI_OPTION_UINTPTR_T:rc = sqlite3_bind_int64(pStmt, idx, *(uintptr_t*)ptr); break;\n        case JSI_OPTION_SIZE_T:rc = sqlite3_bind_int64(pStmt, idx, *(size_t*)ptr); break;\n        case JSI_OPTION_SSIZE_T:rc = sqlite3_bind_int64(pStmt, idx, *(ssize_t*)ptr); break;\n        case JSI_OPTION_LDOUBLE:rc = sqlite3_bind_int64(pStmt, idx, *(ldouble*)ptr); break;\n        case JSI_OPTION_FLOAT:rc = sqlite3_bind_int64(pStmt, idx, *(float*)ptr); break;\n        case JSI_OPTION_TIME_T:\n            rc = sqlite3_bind_int64(pStmt, idx, (Jsi_Wide)*(time_t*)ptr);\n            break;\n        case JSI_OPTION_NUMBER:\n            rc = sqlite3_bind_double(pStmt, idx, (double)*(Jsi_Number*)ptr);\n            break;\n        case JSI_OPTION_TIME_D:\n        case JSI_OPTION_DOUBLE:\n            rc = sqlite3_bind_double(pStmt, idx, (double)*(Jsi_Number*)ptr);\n            break;\n        case JSI_OPTION_CUSTOM: {\n            Jsi_OptionCustom* cust = Jsi_OptionCustomBuiltin(specPtr->custom);\n            if (cust && cust->formatProc) {\n                Jsi_DString dStr;\n                Jsi_DSInit(&dStr);\n                if ((*cust->formatProc)(interp, (Jsi_OptionSpec*)specPtr, NULL, &dStr, rec, flags) != JSI_OK) {\n                    Jsi_DSFree(&dStr);\n                    return JSI_ERROR;\n                }\n                rc = sqlite3_bind_text(pStmt, idx, Jsi_DSValue(&dStr), -1, SQLITE_TRANSIENT );\n                Jsi_DSFree(&dStr);\n            } else \n                return Jsi_LogError(\"missing or invalid custom for \\\"%s\\\"\", specPtr->name);\n            break;\n        }\n        case JSI_OPTION_DSTRING:\n            eStr = (Jsi_DString*)ptr;\n            if (jdb->optPtr->nullvalue && !Jsi_Strcmp(jdb->optPtr->nullvalue, Jsi_DSValue(eStr)))\n                rc = sqlite3_bind_text(pStmt, idx, NULL, -1, statFlags );\n            else\n                rc = sqlite3_bind_text(pStmt, idx, Jsi_DSValue(eStr), -1, statFlags );\n            break;\n        case JSI_OPTION_STRBUF:\n            if (jdb->optPtr->nullvalue && ptr && !Jsi_Strcmp(jdb->optPtr->nullvalue, (char*)ptr))\n                rc = sqlite3_bind_text(pStmt, idx, NULL, -1, statFlags );\n            else\n                rc = sqlite3_bind_text(pStmt, idx, (char*)ptr, -1, statFlags );\n            break;\n        case JSI_OPTION_STRKEY:\n            rc = sqlite3_bind_text(pStmt, idx, *(char**)ptr, -1, SQLITE_STATIC );\n            break;\n#ifndef JSI_LITE_ONLY\n        case JSI_OPTION_STRING:\n            rc = sqlite3_bind_text(pStmt, idx, Jsi_ValueString(interp, *((Jsi_Value **)ptr), NULL), -1, statFlags );\n            break;\n#else\n        case JSI_OPTION_STRING:\n#endif\n        case JSI_OPTION_VALUE: /* Unsupported. */\n        case JSI_OPTION_VAR:\n        case JSI_OPTION_OBJ:\n        case JSI_OPTION_ARRAY:\n        case JSI_OPTION_REGEXP:\n        case JSI_OPTION_FUNC:\n#ifdef __cplusplus\n        case JSI_OPTION_END:\n        case JSI_OPTION_USEROBJ:\n#else\n        default:\n#endif\n            Jsi_LogError(\"unsupported jdb option type \\\"%s\\\" for \\\"%s\\\"\", jsi_DbOptionTypeStr(specPtr->id, 0), specPtr->name);\n            return JSI_ERROR;\n\n        }\n        if (rc != SQLITE_OK)\n            Jsi_LogError(\"bind failure: %s\", sqlite3_errmsg(jdb->db));\n    }\n    cnt++;\n    return JSI_OK;\n}\n\n/* Prepare, bind, then step.\n * If there are results return JSI_OK. On error return JSI_ERROR;\n */\nstatic Jsi_RC dbEvalStepOption(DbEvalContext *p, OptionBind *obPtr, int *cntPtr, int dataIdx, int bindMax, Jsi_CDataDb *dbopts, int *erc) {\n    Jsi_Db *jdb = p->jdb;\n    int cnt = 0;\n    while( p->zSql[0] || p->pPreStmt ) {\n        Jsi_RC rc;\n        cnt++;\n        if( p->pPreStmt==0 ) {\n            rc = dbPrepareStmt(p->jdb, p->zSql, &p->zSql, &p->pPreStmt);\n            if( rc!=JSI_OK ) return rc;\n        }\n        if (bindMax!=0) {\n            rc = dbBindOptionStmt(jdb, p->pPreStmt->pStmt, obPtr, dataIdx, bindMax, dbopts);\n            if( rc!=JSI_OK ) return rc;\n        }\n        rc = dbEvalStepSub(p, 1, erc);\n        if (rc != JSI_BREAK)\n            return rc;\n        *cntPtr = cnt;\n    }\n    \n    /* Finished */\n    return JSI_BREAK;\n}\n\nstatic Jsi_StructSpec* dbLookupSpecFromName(Jsi_StructSpec *specs, const char *name) {\n    Jsi_StructSpec *specPtr = NULL;\n    for (specPtr = specs; specPtr->id>=JSI_OPTION_BOOL && specPtr->id < JSI_OPTION_END; specPtr++) {\n        if  (specPtr->flags&JSI_OPT_DB_IGNORE)\n            continue;\n        const char *cname = specPtr->name;\n        if (cname[0] == name[0] && !Jsi_Strncasecmp(cname, name, -1))\n            return specPtr;\n    }\n    return NULL;\n}\n\nconst char* Jsi_DbKeyAdd(Jsi_Db *jdb, const char *str)\n{\n#ifndef JSI_LITE_ONLY\n    if (jdb->interp)\n        return Jsi_KeyAdd(jdb->interp, str);\n#endif\n    Jsi_HashEntry *hPtr;\n    bool isNew;\n    hPtr = Jsi_HashEntryNew(jdb->strKeyTbl, str, &isNew);\n    assert(hPtr) ;\n    return (const char*)Jsi_HashKeyGet(hPtr);\n}\n\nstatic int dbOptSelect(Jsi_Db *jdb, const char *cmd, OptionBind *obPtr, Jsi_CDataDb *dbopts)\n{\n    void *rec = dbopts[0].data, **recPtrPtr = NULL;\n    Jsi_Interp *interp = jdb->interp;\n    Jsi_StructSpec *specPtr, *specs = dbopts[0].sf;\n    DbEvalContext sEval = {};\n    int ccnt = 0;\n    Jsi_Wide flags = 0;\n    const char *cPtr = Jsi_Strstr(cmd, \" %s\");\n    if (!cPtr) cPtr = Jsi_Strstr(cmd, \"\\t%s\");\n    Jsi_DString *eStr;\n#ifdef JSI_DB_DSTRING_SIZE\n    JSI_DSTRING_VAR(dStr, JSI_DB_DSTRING_SIZE);\n#else\n    Jsi_DString sStr, *dStr = &sStr;\n    Jsi_DSInit(dStr);\n#endif\n    dbEvalInit(interp, &sEval, jdb, NULL, dStr, 0, 0);\n    if (dbopts->noCache)\n        sEval.nocache = 1;\n    Jsi_DSAppendLen(dStr, cmd, cPtr?(cPtr-cmd):-1);\n    if (cPtr) {\n        Jsi_DSAppend(dStr, \" \", NULL);\n        for (specPtr = specs; specPtr->id>=JSI_OPTION_BOOL && specPtr->id < JSI_OPTION_END; specPtr++) {\n            if (specPtr == obPtr->dirtyPtr || (specPtr->flags&JSI_OPT_DB_IGNORE))\n                continue;\n            if (ccnt)\n                Jsi_DSAppendLen(dStr, \",\", 1);\n            Jsi_DSAppend(dStr, \"[\", specPtr->name, \"]\", NULL);\n            ccnt++; \n        }\n        Jsi_DSAppend(dStr, cPtr+3, NULL);\n    }\n    sEval.zSql = Jsi_DSValue(dStr);\n    sEval.nocache = jdb->optPtr->nocache;\n    int rc = JSI_ERROR, erc = -1, structSize = 0;\n    int cnt = 0, dataMax = (dbopts->isPtr2?0:1);\n    int multi = (dbopts->isPtr2!=0);\n    int dnum = dbopts[0].arrSize;\n    if (dnum<=0 && !dbopts->isPtr2) {\n        dataMax = dnum = 1;\n    }\n    if (dnum>1) {\n        multi = 1;\n        dataMax = dbopts[0].arrSize;\n    }\n    if (dbopts->isPtr2) {\n        recPtrPtr = (void**)rec; /* This is really a void***, but this gets recast below. */\n        rec = *recPtrPtr;\n    }\n    structSize = specs[obPtr->optLen].size;\n\n    cnt = 0;\n    int ncnt = 0, bindMax = -1, dataIdx = -1;\n    while(1) {\n        dataIdx++;\n        if (dataIdx>=dataMax) {\n            if (!dbopts->isPtr2)\n                break;\n            else {\n            /* Handle fully dynamic allocation of memory. */\n#ifndef JSI_DB_MAXDYN_SIZE\n#define JSI_DB_MAXDYN_SIZE 100000000\n#endif\n#ifndef JSI_DB_DYN_INCR\n#define JSI_DB_DYN_INCR 16\n#endif\n                int ddMax = (dbopts->maxSize>0?dbopts->maxSize:JSI_DB_MAXDYN_SIZE);\n                if (dataMax>=ddMax)\n                    break;\n                int olddm = dataMax;\n                dataMax += JSI_DB_DYN_INCR;\n                if (dataMax>ddMax)\n                    dataMax = ddMax;\n                if (!olddm)\n                    rec = Jsi_Calloc(dataMax+1, sizeof(void*));\n                else {\n                    rec = Jsi_Realloc(rec, (dataMax+1)*sizeof(void*));\n                    memset((char*)rec+olddm*sizeof(void*), 0, (dataMax-olddm+1)*sizeof(void*));\n                }\n                *recPtrPtr = rec;\n            }\n        }\n\n        rc = dbEvalStepOption(&sEval, obPtr, &ncnt, dataIdx, bindMax, dbopts, &erc);\n        if (rc == JSI_ERROR)\n            break;\n        if (rc != JSI_OK)\n            break;\n        cnt += ncnt;\n        sqlite3_stmt *pStmt = sEval.pPreStmt->pStmt;\n        int idx;\n        int nCol;\n        char **apColName;\n        const char *str;\n        int *apColType;\n        void *prec = rec;\n        bindMax = 0;\n\n        if (dbopts->isPtr2 || dbopts->isPtrs) {\n            prec = ((void**)rec)[dataIdx];\n            if (!prec)\n                ((void**)rec)[dataIdx] = prec = Jsi_Calloc(1, structSize);\n        } else\n                prec = (char*)rec + (dataIdx * structSize);\n        dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n        for (idx=0; idx<nCol; idx++) {\n            specPtr = dbLookupSpecFromName(specs, apColName[idx]);\n            if (!specPtr) {\n                Jsi_LogError(\"unknown column name: %s\", apColName[idx]);\n                goto bail;\n            }          \n            if (specPtr->id<JSI_OPTION_BOOL || specPtr->id>=JSI_OPTION_END) {\n                Jsi_LogError(\"unknown option type \\\"%d\\\" for \\\"%s\\\"\", specPtr->id, specPtr->name);\n                goto bail;\n            }\n            char *ptr = (char*)prec + specPtr->offset;\n\n            switch (specPtr->id) {\n                case JSI_OPTION_BOOL:\n                    *(int*)ptr = sqlite3_column_int(pStmt, idx);\n                    break;\n                case JSI_OPTION_INT: *(int*)ptr = (int)sqlite3_column_int64(pStmt, idx); break;\n                case JSI_OPTION_UINT: *(uint*)ptr = (uint)sqlite3_column_int64(pStmt, idx); break;\n                case JSI_OPTION_INTPTR_T: *(intptr_t*)ptr = (intptr_t)sqlite3_column_int64(pStmt, idx); break;\n                case JSI_OPTION_UINTPTR_T: *(uintptr_t*)ptr = (uintptr_t)sqlite3_column_int64(pStmt, idx); break;\n                case JSI_OPTION_SIZE_T: *(size_t*)ptr = (size_t)sqlite3_column_int64(pStmt, idx); break;\n                case JSI_OPTION_SSIZE_T: *(ssize_t*)ptr = (ssize_t)sqlite3_column_int64(pStmt, idx); break;\n                case JSI_OPTION_SHORT: *(short*)ptr = (int)sqlite3_column_int64(pStmt, idx); break;\n                case JSI_OPTION_USHORT: *(ushort*)ptr = (uint)sqlite3_column_int64(pStmt, idx); break;\n                case JSI_OPTION_LONG: *(long*)ptr = (int)sqlite3_column_int64(pStmt, idx); break;\n                case JSI_OPTION_ULONG: *(ulong*)ptr = (uint)sqlite3_column_int64(pStmt, idx); break;\n                case JSI_OPTION_INT8: *(int8_t*)ptr = (int)sqlite3_column_int64(pStmt, idx); break;\n                case JSI_OPTION_UINT8: *(uint8_t*)ptr = (uint)sqlite3_column_int64(pStmt, idx); break;\n                case JSI_OPTION_INT16: *(int16_t*)ptr = (int)sqlite3_column_int64(pStmt, idx); break;\n                case JSI_OPTION_UINT16: *(uint16_t*)ptr = (uint)sqlite3_column_int64(pStmt, idx); break;\n                case JSI_OPTION_INT32: *(int32_t*)ptr = (int)sqlite3_column_int64(pStmt, idx); break;\n                case JSI_OPTION_UINT32: *(uint32_t*)ptr = (uint)sqlite3_column_int64(pStmt, idx); break;\n                case JSI_OPTION_INT64: *(int64_t*)ptr = (int)sqlite3_column_int64(pStmt, idx); break;\n                case JSI_OPTION_TIME_W:\n                case JSI_OPTION_UINT64: *(uint64_t*)ptr = (uint)sqlite3_column_int64(pStmt, idx); break;\n                case JSI_OPTION_TIME_T:\n                    *(time_t*)ptr = (time_t)sqlite3_column_int64(pStmt, idx);\n                    break;\n                case JSI_OPTION_NUMBER:\n                    *(Jsi_Number*)ptr = (Jsi_Number)sqlite3_column_double(pStmt, idx);\n                    break;\n                case JSI_OPTION_TIME_D:\n                case JSI_OPTION_FLOAT:\n                    *(float*)ptr = (float)sqlite3_column_double(pStmt, idx);\n                    break;\n                case JSI_OPTION_DOUBLE:\n                    *(double*)ptr = (double)sqlite3_column_double(pStmt, idx);\n                    break;\n                case JSI_OPTION_LDOUBLE:\n                    *(ldouble*)ptr = (ldouble)sqlite3_column_double(pStmt, idx);\n                    break;\n                case JSI_OPTION_DSTRING:\n                    eStr = (Jsi_DString*)ptr;\n                    str = (char*)sqlite3_column_text(pStmt, idx );\n                    if (!str)\n                        str = jdb->optPtr->nullvalue;\n                    Jsi_DSSet(eStr, str?str:\"\");\n                    break;\n                case JSI_OPTION_STRBUF:\n                    str = (char*)sqlite3_column_text(pStmt, idx );\n                    if (!str)\n                        str = jdb->optPtr->nullvalue;\n                    strncpy((char*)ptr, str?str:\"\", specPtr->size);\n                    ((char*)ptr)[specPtr->size-1] = 0;\n                    break;\n                case JSI_OPTION_CUSTOM: {\n                    Jsi_OptionCustom* cust = Jsi_OptionCustomBuiltin(specPtr->custom);\n                    if (cust && cust->parseProc) {\n                        str = (char*)sqlite3_column_text(pStmt, idx );\n                        if ((*cust->parseProc)(interp, (Jsi_OptionSpec*)specPtr, NULL, str, prec, flags) != JSI_OK) {\n                            goto bail;\n                        }\n                    } else {\n                        Jsi_LogError(\"missing or invalid custom for \\\"%s\\\"\", specPtr->name);\n                        goto bail;\n                    }\n                    break;\n                }\n                case JSI_OPTION_STRKEY:\n                    str = (char*)sqlite3_column_text(pStmt, idx );\n                    if (!str)\n                        str = jdb->optPtr->nullvalue;\n                    *(char**)ptr = (str?(char*)Jsi_DbKeyAdd(jdb, str):NULL);\n                    break;\n#ifndef JSI_LITE_ONLY\n                case JSI_OPTION_STRING: {\n                    Jsi_Value *vPtr = *((Jsi_Value **)ptr);\n                    if (!(specPtr->flags&JSI_OPT_NO_DUPVALUE)) {\n                        if (vPtr) Jsi_DecrRefCount(interp, vPtr);\n                        *((Jsi_Value **)ptr) = NULL;\n                    }\n                    str = (char*)sqlite3_column_text(pStmt, idx );\n                    if (!str)\n                        str = jdb->optPtr->nullvalue;\n                    if (str) {\n                        vPtr = Jsi_ValueNewStringDup(interp, str);\n                        *((Jsi_Value **)ptr) = vPtr;\n                    }\n                    break;\n                }\n#else\n                case JSI_OPTION_STRING:        \n#endif\n                case JSI_OPTION_VALUE: /* The rest are unsupported. */\n                case JSI_OPTION_VAR:\n                case JSI_OPTION_OBJ:\n                case JSI_OPTION_ARRAY:\n                case JSI_OPTION_REGEXP:\n                case JSI_OPTION_FUNC:\n                \n#ifdef __cplusplus\n                case JSI_OPTION_USEROBJ:\n                case JSI_OPTION_END:\n#else\n                default:\n#endif\n                    JSI_DBQUERY_PRINTF( \"unsupported type: %d:%s\\n\", specPtr->id,\n                        jsi_DbOptionTypeStr(specPtr->id, 0));\n                    break;\n            }\n        }\n        if (dbopts[0].callback)\n            dbopts[0].callback(interp, dbopts, prec);\n        cnt++;\n        if (!multi)\n            break;\n    }\n    dbEvalFinalize(&sEval);\n    if( rc==JSI_BREAK ) {\n        rc = JSI_OK;\n    }\n    return (rc==JSI_OK?cnt:erc);\n\nbail:\n    dbEvalFinalize(&sEval);\n    return erc;\n}\n\nstatic int jsi_DbQuery(Jsi_Db *jdb, Jsi_CDataDb *dbopts, const char *query)\n{\n    int k, cnt, erc = -1;\n    Jsi_CDataDb statbinds[] = {{}, {}};\n    if (!dbopts) dbopts = statbinds;\n    OptionBind ob = {.binds = dbopts};\n    Jsi_StructSpec *specPtr, *specs;\n    Jsi_Interp *interp = jdb->interp;\n    if (!query) query=\"\";\n    if (query[0]==';') {\n        if (!dbExecCmd(jdb, query+1, &erc)) {\n            Jsi_LogError(\"EXEC ERROR=\\\"%s\\\", SQL=\\\"%s\\\"\", sqlite3_errmsg(jdb->db), query);\n            return erc;\n        }\n        return 0;\n    }\n    const char *cPtr = Jsi_Strstr(query, \" %s\");\n    if (!cPtr) cPtr = Jsi_Strstr(query, \"\\t%s\");\n    if (!dbopts) {\n        Jsi_LogError(\"dbopts may not be null\");\n        return -1;\n    }\n    if (!dbopts[0].data) {\n        Jsi_LogError(\"data may not be null\");\n        return -1;\n    }\n    if (!dbopts[0].sf) {\n        Jsi_LogError(\"specs may not be null\");\n        return -1;\n    }\n    for (k=0; dbopts[k].sf; k++) {\n        if (dbopts[k].arrSize>1 || k==0) {\n            int scnt = 0;\n            for (specPtr = dbopts[k].sf, scnt=0; specPtr->id>=JSI_OPTION_BOOL\n                && specPtr->id < JSI_OPTION_END; specPtr++, scnt++) {\n                if (specPtr->flags&JSI_OPT_DB_IGNORE)\n                    continue;\n                if (k==0) {\n                    if (specPtr->flags&JSI_OPT_DB_ROWID) {\n                        if (specPtr->id != JSI_OPTION_INT64) {\n                            Jsi_LogError(\"rowid flag must be a wide field: %s\", specPtr->name);\n                            return -1;\n                        }\n                        ob.rowidPtr = specPtr;\n                    }\n                    if (specPtr->flags&JSI_OPT_DB_DIRTY) {\n                        if (specPtr->id == JSI_OPTION_BOOL || specPtr->id == JSI_OPTION_INT) {\n                            ob.dirtyPtr = specPtr;\n                        } else {\n                            Jsi_LogError(\"dirty flag must be a int/bool field: %s\", specPtr->name);\n                            return -1;\n                        }\n                    }\n                            \n                }\n            }\n            if (k==0)\n                ob.optLen = scnt;\n            assert(specPtr->id == JSI_OPTION_END);\n        }\n        if (!dbopts[k].prefix) break;\n    }\n    specs = dbopts[0].sf;\n    int structSize = specs[ob.optLen].size;\n    if (dbopts->memClear || dbopts->memFree) {\n        cnt = dbopts[0].arrSize;\n        void *rec = dbopts[0].data, *prec = rec;\n        void **recPtrPtr = NULL;\n        if (dbopts->isPtr2) {\n            recPtrPtr = (void**)rec; /* This is really a void***, but this gets recast below. */\n            rec = *recPtrPtr;\n        }\n        if (cnt<=0 && rec && dbopts->isPtr2) {\n            for (cnt=0; ((void**)rec)[cnt]!=NULL; cnt++);\n        }\n        for (k=0; k<cnt; k++) {\n            if (dbopts->isPtr2 || dbopts->isPtrs)\n                prec = ((void**)rec)[k];\n            else\n                prec = (char*)rec + (k * structSize);\n            if (!prec)\n                continue;\n            Jsi_OptionsFree(interp, (Jsi_OptionSpec*)specs, prec, 0);\n            if (dbopts->isPtr2 || dbopts->isPtrs) {\n                Jsi_Free(prec);\n            }\n        }\n        if (recPtrPtr) {\n            Jsi_Free(*recPtrPtr);\n            *recPtrPtr = NULL;\n        }\n        if (query == NULL || query[0] == 0)\n            return 0;\n    }\n    \n    if (!Jsi_Strncasecmp(query, \"SELECT\", 6))\n        return dbOptSelect(jdb, query, &ob, dbopts);\n        \n    DbEvalContext sEval = {};\n    int insert = 0, replace = 0, update = 0;\n    char nbuf[100], *bPtr;\n#ifdef JSI_DB_DSTRING_SIZE\n    JSI_DSTRING_VAR(dStr, JSI_DB_DSTRING_SIZE);\n#else\n    Jsi_DString sStr, *dStr = &sStr;\n    Jsi_DSInit(dStr);\n#endif\n    if (dbopts->noCache)\n        sEval.nocache = 1;\n    if (dbEvalInit(interp, &sEval, jdb, NULL, dStr, 0, 0) != JSI_OK)\n        return -1;\n    int dataMax = dbopts[0].arrSize;\n    cnt = 0;\n    if (dataMax==0)\n        dataMax = 1;\n    char ch[2];\n\n    ch[0] = dbopts[0].prefix;\n    ch[1] = 0;\n    if (!ch[0])\n        ch[0] = ':';\n    if ((update=(Jsi_Strncasecmp(query, \"UPDATE\", 6)==0))) {\n        Jsi_DSAppendLen(dStr, query, cPtr?(cPtr-query):-1);\n        if (cPtr) {\n            Jsi_DSAppend(dStr, \" \", NULL);\n            int cidx = 0;\n            int killf = (JSI_OPT_DB_IGNORE|JSI_OPT_READ_ONLY|JSI_OPT_INIT_ONLY);\n            for (specPtr = specs; specPtr->id != JSI_OPTION_END; specPtr++, cidx++) {\n                if (specPtr == ob.rowidPtr || specPtr == ob.dirtyPtr || (specPtr->flags&killf))\n                    continue;\n                const char *fname = specPtr->name;\n                if (ch[0] == '?')\n                    snprintf(bPtr=nbuf, sizeof(nbuf), \"%d\", cidx+1);\n                else\n                    bPtr = (char*)specPtr->name;\n                Jsi_DSAppend(dStr, (cnt?\",\":\"\"), \"[\", fname, \"]=\",\n                    ch, bPtr, NULL);\n                cnt++;\n            }\n            Jsi_DSAppend(dStr, cPtr+3, NULL);\n        }\n    } else if ((insert=(Jsi_Strncasecmp(query, \"INSERT\", 6)==0))\n        || (replace=(Jsi_Strncasecmp(query, \"REPLACE\", 7)==0))) {\n        Jsi_DSAppendLen(dStr, query, cPtr?(cPtr-query):-1);\n        if (cPtr) {\n            Jsi_DSAppend(dStr, \" (\", NULL);\n            int killf = JSI_OPT_DB_IGNORE;\n            if (replace)\n                killf |= (JSI_OPT_READ_ONLY|JSI_OPT_INIT_ONLY);\n            for (specPtr = specs; specPtr->id != JSI_OPTION_END; specPtr++) {\n                if (specPtr == ob.rowidPtr || specPtr == ob.dirtyPtr || specPtr->flags&killf)\n                    continue;\n                const char *fname = specPtr->name;\n                Jsi_DSAppend(dStr, (cnt?\",\":\"\"), \"[\", fname, \"]\", NULL);\n                cnt++;\n            }\n            Jsi_DSAppendLen(dStr,\") VALUES(\", -1);\n            cnt = 0;\n            int cidx = 0;\n            for (specPtr = specs; specPtr->id != JSI_OPTION_END; specPtr++, cidx++) {\n                if (specPtr == ob.rowidPtr || specPtr == ob.dirtyPtr\n                    || specPtr->flags&killf)\n                    continue;\n                if (ch[0] == '?')\n                    snprintf(bPtr=nbuf, sizeof(nbuf), \"%d\", cidx+1);\n                else\n                    bPtr = (char*)specPtr->name;\n                Jsi_DSAppend(dStr, (cnt?\",\":\"\"), ch, bPtr, NULL);\n                cnt++;\n            }\n            Jsi_DSAppend(dStr,\")\", cPtr+3, NULL);\n        }\n    } else if (!Jsi_Strncasecmp(query, \"DELETE\", 6)) {\n        Jsi_DSAppend(dStr, query, NULL);\n    } else {\n        Jsi_LogError(\"unrecognized query \\\"%s\\\": expected one of: SELECT, UPDATE, INSERT, REPLACE or DELETE\", query);\n        return -1;\n    }\n    sEval.zSql = Jsi_DSValue(dStr);\n    if (jdb->echo && sEval.zSql)\n        Jsi_LogInfo(\"SQL-ECHO: %s\\n\", sEval.zSql); \n\n    int rc, bindMax = -1, dataIdx = 0;\n    cnt = 0;\n    int ismodify = (replace||insert||update);\n    int isnew = (replace||insert);\n    int didBegin = 0;\n    DbEvalContext *p = &sEval;\n    rc = dbPrepareStmt(p->jdb, p->zSql, &p->zSql, &p->pPreStmt);\n    if( rc!=JSI_OK ) return -1;\n    if (dataMax>1 && !dbopts->noBegin) {\n        didBegin = 1;\n        if (!dbExecCmd(jdb, JSI_DBQUERY_BEGIN_STR, &erc))\n            goto bail;\n    }\n    while (dataIdx<dataMax) {\n        if (ismodify && ob.dirtyPtr && (dbopts->dirtyOnly)) { /* Check to limit updates to dirty values only. */\n            void *rec = dbopts[0].data;\n            if (dbopts->isPtrs || dbopts->isPtr2)\n                rec = ((void**)rec)[dataIdx];\n            else\n                rec = (char*)rec + (dataIdx * structSize);\n            char *ptr = (char*)rec + ob.dirtyPtr->offset;\n            int isDirty = *(int*)ptr;\n            int bit = 0;\n            if (ob.dirtyPtr->id == JSI_OPTION_BOOL)\n                bit = (uintptr_t)ob.dirtyPtr->data;\n            if (!(isDirty&(1<<(bit)))) {\n                dataIdx++;\n                continue;\n            }\n            isDirty &= ~(1<<(bit));\n            *(int*)ptr = isDirty; /* Note that the dirty bit is cleared, even upon error.*/\n        }\n        rc = dbBindOptionStmt(jdb, p->pPreStmt->pStmt, &ob, dataIdx, bindMax, dbopts);\n        if( rc!=JSI_OK )\n            goto bail;\n        bindMax = 1;\n        rc = dbEvalStepSub(p, (dataIdx>=dataMax), &erc);\n        if (rc == JSI_ERROR)\n            goto bail;\n        cnt += sqlite3_changes(jdb->db);\n        if (rc != JSI_OK && rc != JSI_BREAK)\n            break;\n        if (ob.rowidPtr && isnew) {\n            void *rec = dbopts[0].data;\n            if (dbopts->isPtrs || dbopts->isPtr2)\n                rec = ((void**)rec)[dataIdx];\n            else\n                rec = (char*)rec + (dataIdx * structSize);\n            char *ptr = (char*)rec + ob.rowidPtr->offset;\n            *(Jsi_Wide*)ptr = sqlite3_last_insert_rowid(jdb->db);\n        }\n        dataIdx++;\n    }\n    if (didBegin && !dbExecCmd(jdb, JSI_DBQUERY_COMMIT_STR, &erc))\n        rc = JSI_ERROR;\n    dbEvalFinalize(&sEval);\n    if( rc==JSI_BREAK ) {\n        rc = JSI_OK;\n    }\n    return (rc==JSI_OK?cnt:erc);\n\nbail:\n    dbEvalFinalize(&sEval);\n    if (didBegin)\n        dbExecCmd(jdb, JSI_DBQUERY_ROLLBACK_STR, NULL);\n    return erc;\n}\n\n#ifdef Jsi_DbQuery\n#undef Jsi_DbQuery\n#undef Jsi_DbHandle\n#undef Jsi_DbNew\n#endif\nint\nJsi_DbQuery(Jsi_Db *jdb, Jsi_CDataDb *dbopts, const char *query)\n{\n    int rc = jsi_DbQuery(jdb, dbopts, query);\n#ifdef JSI_DBQUERY_ERRORCMD\n    if (rc<0)\n        rc = JSI_DBQUERY_ERRORCMD(jdb, specs, data, arrSize, query, dopts, rc);\n#endif\n    return rc;\n}\n\nvoid *Jsi_DbHandle(Jsi_Interp *interp, Jsi_Db* jdb)\n{\n    SQLSIGASSERT(jdb,DB);\n    return jdb->db;\n}\n\n/* This is the non-script, JSI_LITE_ONLY creator for Jsi_Db */\nJsi_Db* Jsi_DbNew(const char *zFile, int inFlags /* JSI_DBI_* */)\n{\n    char *zErrMsg;\n    int flags = SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE;\n#ifdef SQLITE_JSI_DEFAULT_FULLMUTEX\n    flags |= SQLITE_OPEN_FULLMUTEX;\n#else\n    flags |= SQLITE_OPEN_NOMUTEX;\n#endif\n    if (!zFile)\n        zFile = \":memory:\";\n    zErrMsg = 0;\n    Jsi_Db *db = (Jsi_Db*)Jsi_Calloc(1, sizeof(*db) );\n    if( db==0 ) {\n        JSI_DBQUERY_PRINTF( \"malloc failed\\n\");\n        return NULL;\n    }\n    db->sig = SQLITE_SIG_DB;\n    db->stmtCacheMax = NUM_PREPARED_STMTS;\n    db->optPtr = &db->queryOpts;\n\n    if (inFlags&JSI_DBI_READONLY) {\n        flags &= ~(SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE);\n        flags |= SQLITE_OPEN_READONLY;\n    } else {\n        flags &= ~SQLITE_OPEN_READONLY;\n        flags |= SQLITE_OPEN_READWRITE;\n        if (inFlags&JSI_DBI_NOCREATE) {\n            flags &= ~SQLITE_OPEN_CREATE;\n        }\n    }\n    if(inFlags&JSI_DBI_NO_MUTEX) {\n        flags |= SQLITE_OPEN_NOMUTEX;\n        flags &= ~SQLITE_OPEN_FULLMUTEX;\n    } else {\n        flags &= ~SQLITE_OPEN_NOMUTEX;\n    }\n    if(inFlags&JSI_DBI_FULL_MUTEX) {\n        flags |= SQLITE_OPEN_FULLMUTEX;\n        flags &= ~SQLITE_OPEN_NOMUTEX;\n    } else {\n        flags &= ~SQLITE_OPEN_FULLMUTEX;\n    }\n    char cpath[PATH_MAX];\n    char *npath = Jsi_FileRealpathStr(NULL, zFile, cpath);\n    \n    if (SQLITE_OK != sqlite3_open_v2(npath, &db->db, flags, NULL)) {\n        JSI_DBQUERY_PRINTF( \"db open failed: %s\\n\", npath);\n        goto bail;\n    }\n    //Jsi_DSFree(&translatedFilename);\n\n    if( SQLITE_OK!=sqlite3_errcode(db->db) ) {\n        zErrMsg = sqlite3_mprintf(\"%s\", sqlite3_errmsg(db->db));\n        DbClose(db->db);\n        db->db = 0;\n    }\n    if( db->db==0 ) {\n        JSI_DBQUERY_PRINTF( \"Db open failed %s\\n\", zErrMsg);\n        sqlite3_free(zErrMsg);\n        goto bail;\n    }\n    db->stmtHash = Jsi_HashNew(NULL, JSI_KEYS_STRING, NULL);\n    db->strKeyTbl = Jsi_HashNew(NULL, JSI_KEYS_STRING, NULL);\n    db->stmtCache = Jsi_ListNew((Jsi_Interp*)db, 0, dbStmtFreeProc);\n    return db;\n    \nbail:\n    return NULL;\n}\n\n#ifndef JSI_LITE_ONLY\n\nstatic Jsi_RC Jsi_DoneSqlite(Jsi_Interp *interp)\n{\n    Jsi_UserObjUnregister(interp, &sqliteobject);\n    const char *provide = \"Sqlite\";\n    Jsi_PkgProvide(interp, provide, -1, NULL);\n    return JSI_OK;\n}\n#ifdef JSI_DB_TEST\n#include \"c-demos/dbdemo.c\"\n#endif\n\nJsi_RC Jsi_InitSqlite(Jsi_Interp *interp, int release)\n{\n    if (release) return Jsi_DoneSqlite(interp);\n    Jsi_Hash* dbSys;\n#if JSI_USE_STUBS\n    if (Jsi_StubsInit(interp, 0) != JSI_OK)\n        return JSI_ERROR;\n#endif\n\n    if (!(dbSys = Jsi_UserObjRegister(interp, &sqliteobject))) \n        return Jsi_LogError(\"Failed to init sqlite extension\");\n\n    Jsi_Value *info = Jsi_ValueNew1(interp);\n    Jsi_JSONParseFmt(interp, &info, \"{libVer:\\\"%s\\\", hdrVer:\\\"%s\\\", hdrNum:%d, hdrSrcId:\\\"%s\\\", pkgVer:%d}\",\n        (char *)sqlite3_libversion(), SQLITE_VERSION, SQLITE_VERSION_NUMBER, SQLITE_SOURCE_ID, jsi_DbPkgVersion);\n    Jsi_PkgOpts dbPkgOpts = { db_ObjCmd_Specs, &dbObjCmd, sqliteCmds, info };\n    Jsi_RC rc = Jsi_PkgProvideEx(interp, \"Sqlite\", jsi_DbPkgVersion, Jsi_InitSqlite, &dbPkgOpts);\n    Jsi_DecrRefCount(interp, info);\n    if (rc != JSI_OK)\n        return JSI_ERROR;\n\n    if (!Jsi_CommandCreateSpecs(interp, sqliteobject.name, sqliteCmds, dbSys, JSI_CMDSPEC_ISOBJ))\n        return JSI_ERROR;        \n\n#ifdef JSI_DB_TEST\n    if (getenv(\"RUN_DB_TEST\"))\n        TestSqlite(interp);\n#endif\n    jsi_DbVfs **dbVfsPtrPtr = (jsi_DbVfs **)Jsi_InterpGetData(interp, JSI_SQLITE_DB_VFS, NULL);\n    if (dbVfsPtrPtr)\n        *dbVfsPtrPtr = &SqliteDbVfs;\n    return JSI_OK;\n}\n#endif //JSI_LITE_ONLY\n\n#else // !JSI__SQLITE\n/* Linking for when Sqlite is not compiled-in. */\n\nstatic jsi_DbVfs *jsi_dbVfsPtr = NULL;\n#ifndef JSI_LITE_ONLY\n\n\nJsi_RC Jsi_initSqlite(Jsi_Interp *interp, int release)\n{\n    if (!release) Jsi_InterpSetData(interp, JSI_SQLITE_DB_VFS, &jsi_dbVfsPtr, NULL);\n    return JSI_OK;\n}\n\nJsi_RC Jsi_doneSqlite(Jsi_Interp *interp)\n{\n    Jsi_InterpFreeData(interp, JSI_SQLITE_DB_VFS);\n    return JSI_OK;\n}\n#endif\n\nint\nJsi_DbQuery(Jsi_Db *jdb, Jsi_CDataDb *dPtr, const char *query)\n{\n    if (!jsi_dbVfsPtr) {\n        printf( \"Sqlite unsupported\\n\");\n        return -1;\n    }\n    return jsi_dbVfsPtr->dbcQuery(jdb, dPtr, query);\n}\n\nvoid *Jsi_DbHandle(Jsi_Interp *interp, Jsi_Db* jdb)\n{\n    if (!jsi_dbVfsPtr) {\n        printf( \"Sqlite unsupported\\n\");\n        return NULL;\n    }\n    return jsi_dbVfsPtr->dbHandle(interp, jdb);\n}\n\nJsi_Db* Jsi_DbNew(const char *zFile, int inFlags /* JSI_DBI_* */)\n{\n    if (!jsi_dbVfsPtr) {\n        printf( \"Sqlite unsupported\\n\");\n        return NULL;\n    }\n    return jsi_dbVfsPtr->dbNew(zFile, inFlags);\n}\n\n#endif\n", "#ifndef JSI_LITE_ONLY\n#ifndef JSI_AMALGAMATION\n#include \"jsiInt.h\"\n#endif\n    \n#define ChkString(_this, funcPtr, dest, lenPtr, bytePtr) \\\n    int skip __attribute__((unused)); skip = 0; \\\n    if (_this->vt != JSI_VT_OBJECT || _this->d.obj->ot != JSI_OT_STRING) { \\\n        Jsi_LogError(\"apply String.%s to a non-string object\", funcPtr->cmdSpec->name); \\\n        return JSI_ERROR; \\\n    } else  { \\\n        dest = Jsi_ValueString(interp, _this, bytePtr); \\\n        *lenPtr = Jsi_NumUtfChars(dest, -1); \\\n        if (!dest) dest = (char*)\"\"; \\\n    }\n\nstatic Jsi_RC StringConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (Jsi_FunctionIsConstructor(funcPtr)) {\n        const char *nv = \"\";\n        int len = -1;\n        if (Jsi_ValueGetLength(interp, args) > 0) {\n            Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n            if (v) {\n                \n                nv = Jsi_ValueToString(interp, v, &len);\n            }\n        }\n        if (_this->vt == JSI_VT_OBJECT && _this->d.obj->ot == JSI_OT_STRING) {\n            if (_this->d.obj->d.s.str)\n                if (!_this->d.obj->isstrkey)\n                    Jsi_Free(_this->d.obj->d.s.str);\n            _this->d.obj->isstrkey = 0;\n            _this->d.obj->d.s.str = Jsi_StrdupLen(nv, len);\n            _this->d.obj->d.s.len = len;\n        } else\n            jsi_ValueMakeBlobDup(interp, &_this, (uchar*)nv, len);\n        Jsi_ValueDup2(interp, ret, _this);\n        return JSI_OK;\n    }\n    if (Jsi_ValueGetLength(interp, args) > 0) {\n        Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n        if (v) {\n            Jsi_ValueDup2(interp, ret, v);\n            Jsi_ValueToString(interp, *ret, NULL);\n            return JSI_OK;\n        }\n    }\n    Jsi_ValueMakeStringDup(interp, ret, \"\");\n    return JSI_OK;\n}\n\n\nstatic Jsi_RC StringSplitCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, //TODO: UTF\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char **argv; int argc;\n    int sLen, bLen, spLen = 1, noEmpty=0;\n    Jsi_RC rc = JSI_OK;\n    const char *v, *split = \"\";\n    \n    ChkString(_this, funcPtr, v, &sLen, &bLen);\n\n    Jsi_Value *spliton = Jsi_ValueArrayIndex(interp, args, skip);\n    \n    if (spliton) {\n        if (Jsi_ValueIsNull(interp, spliton))\n            noEmpty = 1;\n        else if (Jsi_ValueIsString(interp, spliton))\n            split = Jsi_ValueString(interp, spliton, &spLen);\n    }\n\n    Jsi_DString sStr;\n    Jsi_DSInit(&sStr);\n    if (spLen)\n        Jsi_SplitStr(v, &argc, &argv, split, &sStr);\n    Jsi_Obj *obj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    int i, n = 0, siz = argc;\n    if (noEmpty) {\n        for (i=0, siz=0; i<argc; i++) if (argv[i][0]) siz++;\n    } else if (!spLen)\n        argc = siz = bLen;\n    if (Jsi_ObjArraySizer(interp, obj, siz) <= 0) {\n        rc = Jsi_LogError(\"index too large: %d\", siz);\n        Jsi_ObjFree(interp, obj);\n        goto bail;\n    }\n    Jsi_ValueMakeArrayObject(interp, ret, obj);\n    for (i = 0; i < argc; ++i) {\n        if (noEmpty && !argv[i][0]) continue;\n        char ctmp[2] = \" \",  *cst = ctmp;\n        if (!spLen)\n            ctmp[0] = v[i];\n        else\n            cst = argv[i];\n        Jsi_Value *v = Jsi_ValueNewStringDup(interp, cst);\n        Jsi_IncrRefCount(interp, v);\n        obj->arr[n++] = v;\n    }\n    Jsi_ObjSetLength(interp, obj, siz);\n    \nbail:\n    Jsi_DSFree(&sStr);\n    return rc;\n}\n\nstatic Jsi_RC StringSubstrCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int sLen, bLen;\n    const char *v;\n    ChkString(_this, funcPtr, v, &sLen, &bLen);\n\n    Jsi_Value *start = Jsi_ValueArrayIndex(interp, args, skip);\n    Jsi_Value *len = Jsi_ValueArrayIndex(interp, args, skip+1);\n    \n    Jsi_Number nstart, nlen;\n    if (!start || Jsi_GetNumberFromValue(interp,start, &nstart) != JSI_OK) {\n        jsi_ValueMakeBlobDup(interp, ret, (uchar*)v, bLen);\n        return JSI_OK;\n    }\n    int istart = (int)nstart, olen = -1;\n    Jsi_DString dStr;\n    char *ostr;\n    Jsi_DSInit(&dStr);\n    if (!len || Jsi_GetNumberFromValue(interp,len, &nlen) != JSI_OK) {\n        if (sLen == bLen) {\n            ostr = jsi_SubstrDup(v, bLen, istart, -1, &olen);\n            Jsi_ValueMakeBlob(interp, ret, (uchar*)ostr, olen);\n        } else {\n            Jsi_UtfSubstr(v, istart, -1, &dStr);\n            Jsi_ValueFromDS(interp, &dStr, ret);\n        }\n        return JSI_OK;\n    }\n    int ilen = (int)nlen;\n    if (ilen <= 0) {\n        Jsi_ValueMakeStringDup(interp, ret, \"\");\n    } else {\n        if (sLen == bLen) {\n            ostr = jsi_SubstrDup(v, bLen, istart, ilen, &olen);\n            Jsi_ValueMakeBlob(interp, ret, (uchar*)ostr, olen);\n        } else {\n            Jsi_UtfSubstr(v, istart, ilen, &dStr);\n            Jsi_ValueFromDS(interp, &dStr, ret);\n        }\n    }\n    return JSI_OK;\n}\n\nstatic Jsi_RC StringSubstringCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int sLen = 0, bLen;\n    const char *v;\n    ChkString(_this, funcPtr, v, &sLen, &bLen);\n\n    Jsi_Value *start = Jsi_ValueArrayIndex(interp, args, skip);\n    Jsi_Value *end = Jsi_ValueArrayIndex(interp, args, skip+1);\n    \n    Jsi_Number nstart, nend;\n    if (!start || Jsi_GetNumberFromValue(interp,start, &nstart) != JSI_OK) {\n        Jsi_ValueMakeStringDup(interp, ret, v);\n        return JSI_OK;\n    }\n    int istart = (int)nstart, olen = -1;\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    char *ostr;\n    if (!end || Jsi_GetNumberFromValue(interp,end, &nend) != JSI_OK) {\n        if (sLen == bLen) {\n            ostr = jsi_SubstrDup(v, bLen, istart, -1, &olen);\n            Jsi_ValueMakeBlob(interp, ret, (uchar*)ostr, olen);\n        } else {\n            Jsi_UtfSubstr(v, istart, -1, &dStr);\n            Jsi_ValueFromDS(interp, &dStr, ret);\n        }\n        return JSI_OK;\n    }\n    int iend = (int)nend;\n    if (iend>sLen)\n        iend = sLen;\n    if (iend < istart) {\n        Jsi_ValueMakeStringDup(interp, ret, \"\");\n    } else {\n        if (sLen == bLen) {\n            ostr = jsi_SubstrDup(v, bLen, istart, iend-istart+1, &olen);\n            Jsi_ValueMakeBlob(interp, ret, (uchar*)ostr, olen);\n        } else {\n            Jsi_UtfSubstr(v, istart, iend-istart+1, &dStr);\n            Jsi_ValueFromDS(interp, &dStr, ret);\n        }\n    }\n    return JSI_OK;\n}\n\n\nstatic Jsi_RC StringRepeatCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int sLen, bLen;\n    const char *v;\n    ChkString(_this, funcPtr, v, &sLen, &bLen);\n    \n    Jsi_Value *start = Jsi_ValueArrayIndex(interp, args, skip);\n    \n    Jsi_Number ncnt;\n    if (!start || Jsi_GetNumberFromValue(interp,start, &ncnt) != JSI_OK || ncnt>MAX_LOOP_COUNT || ncnt<0 || bLen<=0) {\n        return JSI_ERROR;\n    }\n    int cnt = (int)ncnt;\n    Jsi_DString dStr = {};\n    while (cnt-- > 0) {\n        Jsi_DSAppendLen(&dStr, v, bLen);\n        if (Jsi_DSLength(&dStr)>JSI_MAX_ALLOC_BUF) {\n            Jsi_DSFree(&dStr);\n            return Jsi_LogError(\"too long\");\n        }\n    }\n    Jsi_ValueFromDS(interp, &dStr, ret);\n    return JSI_OK;\n}\n\nstatic Jsi_RC StringIndexOfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int sLen, bLen;\n    const char *v;\n    ChkString(_this, funcPtr, v, &sLen, &bLen);\n\n    Jsi_Value *seq = Jsi_ValueArrayIndex(interp, args, skip);\n    Jsi_Value *start = Jsi_ValueArrayIndex(interp, args, skip+1);\n\n    if (!seq) {\n        Jsi_ValueMakeNumber(interp,ret, -1);\n        return JSI_OK;\n    }\n\n    const char *vseq = Jsi_ValueToString(interp, seq, NULL);\n    int istart = 0;\n    if (start) {\n        if (Jsi_GetIntFromValue(interp, start, &istart)) {\n            return JSI_ERROR;\n        }\n        if (istart < 0) istart = 0;\n    }\n\n    int r = Jsi_Strpos(v, istart, vseq, 0);\n    Jsi_ValueMakeNumber(interp, ret, r);\n\n    return JSI_OK;\n}\n\nstatic Jsi_RC StringMatchCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int sLen, bLen;\n    const char *source_str;\n    ChkString(_this, funcPtr, source_str, &sLen, &bLen);\n    const char *v = source_str;\n    Jsi_Value *seq = Jsi_ValueArrayIndex(interp, args, skip);\n\n    if (Jsi_ValueIsString(interp, seq)) {\n        char *cp = Jsi_ValueString(interp, seq, NULL);\n\n        if (jsi_RegExpValueNew(interp, cp, seq) != JSI_OK)\n            return JSI_ERROR;\n    }\n    /* TODO: differentiate from re.exec() */\n    return jsi_RegExpMatches(interp, seq, v, bLen, *ret, NULL, 1);\n}\n\nstatic Jsi_RC StringFromCharCodeCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (_this->vt != JSI_VT_OBJECT || _this->d.obj->ot == JSI_OT_STRING)\n        return Jsi_LogError(\"should be called via String.fromCharCode\");\n    \n    Jsi_DString dStr = {};\n    int n, i, len, argc = Jsi_ValueGetLength(interp, args);\n    for (i=0; i<argc; i++) {\n        Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, i);\n        if (!Jsi_ValueIsNumber(interp, v) || Jsi_GetIntFromValue(interp, v, &n) != JSI_OK) {\n            Jsi_DSFree(&dStr);\n            return Jsi_LogError(\"expected int value at arg %d\", i+1);\n        }\n        char dest[5];\n        len = Jsi_UniCharToUtf((Jsi_UniChar)n, dest);\n        Jsi_DSAppendLen(&dStr, dest, len);\n    }\n    \n    Jsi_ValueMakeDStringObject(interp, ret, &dStr);\n    return JSI_OK;\n}\n\nstatic Jsi_RC StringCharCodeAtCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int sLen, bLen;\n    const char *source_str;\n    ChkString(_this, funcPtr, source_str, &sLen, &bLen);\n    const char *v = source_str;\n\n    Jsi_Value *ttPtr = Jsi_ValueNew1(interp);\n    Jsi_ValueCopy(interp, ttPtr, _this);\n    \n    int pos = 0;\n    Jsi_Value *vpos;\n    if ((vpos = Jsi_ValueArrayIndex(interp, args, skip))) {\n        jsi_ValueToOInt32(interp, vpos);\n        pos = (int)vpos->d.num;\n    }\n\n#if JSI__UTF8\n    int m;\n    if (pos >= 0 && pos < sLen && ((m=Jsi_UtfIndexToOffset(v, pos))>=0)) {\n        int32_t n;\n        Jsi_UtfToUniChar(v+m, &n);\n        Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)n);\n    }\n#else\n    int slen = Jsi_Strlen(v);\n    if (pos >= 0 && pos < slen) {\n        Jsi_ValueMakeNumber(interp, ret, v[pos]);\n    }\n#endif\n    else\n        Jsi_ValueMakeNumber(interp, ret, Jsi_NumberNaN());\n    Jsi_DecrRefCount(interp, ttPtr);\n    return JSI_OK;\n}\n\n\nstatic Jsi_RC _StringTrimCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, // TODO: UTF\n    Jsi_Value **ret, Jsi_Func *funcPtr, int ends)\n{\n    const char *tstr = \" \\t\\n\\r\", *vstr;\n    int vend,  n, tlen = Jsi_Strlen(tstr), clen, bLen;\n    ChkString(_this, funcPtr, vstr, &clen, &bLen);\n    \n    Jsi_Value *tchars = Jsi_ValueArrayIndex(interp, args, skip);\n    \n    if (tchars) {\n        tstr = Jsi_ValueToString(interp, tchars, NULL);\n        tlen = Jsi_Strlen(tstr);\n    }\n    \n    if (ends&1) {\n        while (*vstr) {\n            for (n=0; n<tlen; n++)\n                if (tstr[n] == *vstr) break;\n            if (n>=tlen) break;\n            vstr++;\n            clen--;\n        }\n    }\n    vend = clen-1;\n    if (ends&2) {\n        for (; vend>=0; vend--) {\n            for (n=0; n<tlen; n++)\n                if (tstr[n] == vstr[vend]) break;\n            if (n>=tlen) break;\n        }\n    }\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    Jsi_UtfSubstr(vstr, 0, vend+1, &dStr);\n    Jsi_ValueFromDS(interp, &dStr, ret);\n    return JSI_OK;\n}\n\nstatic Jsi_RC StringTrimCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    return _StringTrimCmd(interp, args, _this, ret, funcPtr, 3);\n}\nstatic Jsi_RC StringTrimLeftCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    return _StringTrimCmd(interp, args, _this, ret, funcPtr, 1);\n}\n\nstatic Jsi_RC StringTrimRightCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    return _StringTrimCmd(interp, args, _this, ret, funcPtr, 2);\n}\n\n\nchar *jsi_utf_tocase(const char *cp, int upper, Jsi_DString *dsPtr)\n{\n    char unibuf[10];\n    while (*cp) {\n#if JSI__UTF8\n        if (*cp&0x80) {\n            int32_t c;\n            Jsi_UtfToUniChar(cp, &c);\n            int n = Jsi_UniCharToUtf(c, unibuf);\n            unibuf[n] = 0;\n            cp += n;\n        } else\n#endif\n        {\n            unibuf[0] = (upper?toupper(*cp):tolower(*cp));\n            unibuf[1] = 0;\n            cp++;\n        }\n        if (upper==2) //totile\n            upper = 0;\n        Jsi_DSAppend(dsPtr, unibuf, NULL);\n    }\n    return Jsi_DSValue(dsPtr);\n}\n\n\n\nstatic Jsi_RC StringToLowerCaseCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int sLen, bLen;\n    const char *vstr;\n    ChkString(_this, funcPtr, vstr, &sLen, &bLen);\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    jsi_utf_tocase(vstr, 0, &dStr);\n    Jsi_ValueFromDS(interp, &dStr, ret);\n    return JSI_OK;\n}\n\nstatic Jsi_RC StringToUpperCaseCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int sLen, bLen;\n    const char *vstr;\n    ChkString(_this, funcPtr, vstr, &sLen, &bLen);\n\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    jsi_utf_tocase(vstr, 1, &dStr);\n    Jsi_ValueFromDS(interp, &dStr, ret);\n    return JSI_OK;\n}\n\nstatic Jsi_RC StringToTitleCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int sLen, bLen;\n    const char *vstr;\n    ChkString(_this, funcPtr, vstr, &sLen, &bLen);\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    jsi_utf_tocase(vstr, 2, &dStr);\n    Jsi_ValueFromDS(interp, &dStr, ret);\n    return JSI_OK;\n}\n\nstatic Jsi_RC StringCharAtCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int pos = 0, len, bLen;\n    const char *vstr;\n    ChkString(_this, funcPtr, vstr, &len, &bLen);\n   \n    Jsi_Value *vpos = Jsi_ValueArrayIndex(interp, args, 0);\n    if (Jsi_GetIntFromValue(interp, vpos, &pos)) {\n        return JSI_ERROR;        \n    }\n    if (pos<0 || pos >=len)\n        Jsi_ValueMakeStringDup(interp, ret, \"\");\n    else {\n        Jsi_DString dStr;\n        Jsi_DSInit(&dStr);\n        Jsi_UtfSubstr(vstr, pos, 1, &dStr);\n        Jsi_ValueFromDS(interp, &dStr, ret);\n    }\n    return JSI_OK;\n}\n\nstatic Jsi_RC StringLastIndexOfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int sLen, bLen;\n    const char *v;\n    ChkString(_this, funcPtr, v, &sLen, &bLen);\n\n    Jsi_Value *seq = Jsi_ValueArrayIndex(interp, args, skip);\n    Jsi_Value *start = Jsi_ValueArrayIndex(interp, args, 1+skip);\n\n    if (!seq) {\n        Jsi_ValueMakeNumber(interp, ret, -1);\n        return JSI_OK;\n    }\n\n    const char *vseq = Jsi_ValueToString(interp, seq, NULL);\n    int istart = 0;\n    if (start) {\n        if (Jsi_GetIntFromValue(interp, start, &istart)) {\n            return JSI_ERROR;\n        }\n        if (istart < 0) istart = 0;\n    }\n\n    int r = Jsi_Strrpos(v, istart, vseq, 0);\n    Jsi_ValueMakeNumber(interp, ret, r);\n\n    return JSI_OK;;\n}\n\nstatic Jsi_RC StringConcatCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int sLen, bLen;\n    const char *vstr;\n    ChkString(_this, funcPtr, vstr, &sLen, &bLen);\n    \n    Jsi_DString dStr = {};\n    Jsi_DSAppend(&dStr, vstr, NULL);\n    int i, argc = Jsi_ValueGetLength(interp, args);\n    for (i=skip; i<argc; i++)\n    {\n        Jsi_Value *s = Jsi_ValueArrayIndex(interp, args, i);\n        if (Jsi_GetStringFromValue(interp, s, &vstr)) {\n            Jsi_LogError(\"String get failure\");\n            Jsi_DSFree(&dStr);\n            return JSI_ERROR;\n        }\n        Jsi_DSAppend(&dStr, vstr, NULL);\n    }\n\n    Jsi_ValueFromDS(interp, &dStr, ret);\n    return JSI_OK;\n    \n}\n\nstatic Jsi_RC StringSliceCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int sLen, bLen;\n    const char *vstr;\n    ChkString(_this, funcPtr, vstr, &sLen, &bLen);\n\n    Jsi_Value *start = Jsi_ValueArrayIndex(interp, args, skip);\n    Jsi_Value *end = Jsi_ValueArrayIndex(interp, args, 1+skip);\n    int istart, iend, len = Jsi_Strlen(vstr);\n\n    if (Jsi_GetIntFromValue(interp, start, &istart)) {\n        return JSI_ERROR;\n    }\n    if (istart < 0)\n        istart = len+istart;\n    if (istart < 0)\n        istart = 0;\n    if (istart>=len)\n        istart = len-1;\n    iend = len;\n    if (end) {\n        if (Jsi_GetIntFromValue(interp, end, &iend)) {\n            return JSI_ERROR;\n        }\n        if (iend < 0)\n            iend = len+iend;\n        if (iend>=len)\n            iend = len;\n        if (iend<istart)\n            iend = istart;\n    }\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    Jsi_UtfSubstr(vstr, istart, iend, &dStr);\n    Jsi_ValueFromDS(interp, &dStr, ret);\n    return JSI_OK;\n}\n\nstatic Jsi_RC StringMapCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    /* Now handles perl regex flag extensions.*/\n    const char *source_str;\n    const char *replace_str = NULL;\n    uint i, j;\n    int slen, source_len, replace_len, bLen;\n\n    const char *p;\n    bool nocase = 0;\n    /* Is a generic  String.replace if _this->d.obj is a function */\n    ChkString(_this, funcPtr, source_str, &source_len, &bLen);\n    int argc = Jsi_ValueGetLength(interp, args);\n    Jsi_Value *repVal = Jsi_ValueArrayIndex(interp, args, skip);\n    if (Jsi_ValueIsArray(interp, repVal)==0 || repVal->d.obj->arrCnt&1) \n        return Jsi_LogError(\"expected even length array\");\n    if (argc>(skip+1) && Jsi_ValueGetBoolean(interp, Jsi_ValueArrayIndex(interp, args, skip+1), &nocase) != JSI_OK) \n        return Jsi_LogError(\"expected boolean\");\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    Jsi_Obj *obj = repVal->d.obj;\n    p = source_str;\n    for (j=0; j<(uint)bLen; j++, p++) {\n        for (i=0; i<obj->arrCnt; i+=2) {\n            if (!obj->arr[i]) continue;\n            if (!obj->arr[i+1]) continue;\n            const char *cp = Jsi_ValueToString(interp, obj->arr[i], &slen);\n            if (!cp || !slen) {\n                Jsi_DSFree(&dStr);\n                return Jsi_LogError(\"map src can not be empty\");\n            }\n            int res = (nocase ? Jsi_Strncasecmp(cp, p, slen) : Jsi_Strncmp(cp, p, slen));\n            if (!res) {\n                replace_str = Jsi_ValueToString(interp, obj->arr[i+1], &replace_len);\n                Jsi_DSAppendLen(&dStr, replace_str, replace_len);\n                p += slen-1;\n                j += slen-1;\n                break;\n            }\n        }\n        if (i>=obj->arrCnt)\n            Jsi_DSAppendLen(&dStr, p, 1);\n    }\n\n    Jsi_ValueFromDS(interp, &dStr, ret);\n    return JSI_OK;\n}\n    \n#define FN_strreplace JSI_INFO(\"\\\nIf the replace argument is a function, it is called with match,p1,p2,...,offset,string.  \\\nIf called function is known to have 1 argument, it is called with just the match.\")\nstatic Jsi_RC StringReplaceCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    /* Now handles perl regex flag extensions.*/\n    const char *source_str;\n    int source_len, bLen;\n    const char *replace_str = NULL;\n    int replace_len;\n    int regexec_flags = 0;\n    Jsi_Value *seq, *strVal;\n    Jsi_DString dStr = {};\n    regex_t *regex;\n    Jsi_Regex *re;\n    const char *p;\n    int maxArgs = 1;\n\n    int offset = 0, n, j, isglob = 0, num_matches = 0;\n    /* Is a generic  String.replace if _this->d.obj is a function */\n    ChkString(_this, funcPtr, source_str, &source_len, &bLen);\n    source_len = bLen;\n    if (!skip)\n        strVal = _this;\n    else\n        strVal = Jsi_ValueArrayIndex(interp, args, 0);\n    seq = Jsi_ValueArrayIndex(interp, args, skip);\n    Jsi_Value *repVal = Jsi_ValueArrayIndex(interp, args, 1+skip);\n    if (!Jsi_ValueIsFunction(interp, repVal))\n        replace_str = Jsi_ValueToString(interp, repVal, &replace_len);\n    else\n        maxArgs = repVal->d.obj->d.fobj->func->argnames->argCnt;\n    Jsi_DSInit(&dStr);\n\n    if (Jsi_ValueIsString(interp, seq)) {\n        const char *ce, *cp = Jsi_ValueString(interp, seq, NULL);\n        if (!(ce = Jsi_Strstr(source_str, cp)))\n            Jsi_ValueMakeStringDup(interp, ret, source_str);\n        else {\n            int slen;\n            slen = (ce-source_str);\n            if (slen)\n                Jsi_DSAppendLen(&dStr, source_str, slen);\n            if (replace_str)\n                Jsi_DSAppendLen(&dStr, replace_str, replace_len);\n            else {\n                Jsi_Value *inStr = Jsi_ValueNewStringDup(interp, source_str);\n                Jsi_IncrRefCount(interp, inStr);\n                Jsi_RC rc = Jsi_FunctionInvokeString(interp, repVal, inStr, &dStr);\n                if (Jsi_InterpGone(interp))\n                    return JSI_ERROR;\n                if (rc != JSI_OK) {\n                    Jsi_DSFree(&dStr);\n                    Jsi_DecrRefCount(interp, inStr);\n                    return JSI_ERROR;\n                }\n                Jsi_DecrRefCount(interp, inStr);\n            }\n            Jsi_DSAppend(&dStr, ce+Jsi_Strlen(cp), NULL);\n            Jsi_ValueFromDS(interp, &dStr, ret);\n        }\n        return JSI_OK;\n    }\n    if (seq == NULL || seq->vt != JSI_VT_OBJECT || seq->d.obj->ot != JSI_OT_REGEXP) {\n        Jsi_ValueMakeNull(interp, ret);\n        return JSI_OK;\n    }\n\n    re = seq->d.obj->d.robj;\n    regex = &re->reg;\n    isglob = (re->eflags & JSI_REG_GLOB);\n    \n    regmatch_t pmatch[MAX_SUBREGEX] = {};\n    /* If an offset has been specified, adjust for that now.\n     * If it points past the end of the string, point to the terminating null\n     */\n    int eoffset=0;\n    if (offset) {\n        if (offset < 0) {\n            offset += source_len + 1;\n        }\n        if (offset > source_len) {\n            offset = source_len;\n        }\n        else if (offset < 0) {\n            offset = 0;\n        }\n    }\n\n    Jsi_DSAppendLen(&dStr, source_str, offset);\n    n = source_len - offset;\n    p = source_str + offset;\n    Jsi_RC rc = JSI_OK;\n    do {\n        if (num_matches > 10000000) {\n            Jsi_LogBug(\"regexp infinite loop\");\n            rc = JSI_ERROR;\n            break;\n        }\n        int match = regexec(regex, p, MAX_SUBREGEX, pmatch, regexec_flags);\n\n        if (match >= REG_BADPAT) {\n            char buf[100];\n\n            regerror(match, regex, buf, sizeof(buf));\n            Jsi_LogError(\"error while matching pattern: %s\", buf);\n            Jsi_DSFree(&dStr);\n            return JSI_ERROR;\n        }\n        if (match == REG_NOMATCH) {\n            break;\n        }\n        num_matches++;\n        Jsi_DSAppendLen(&dStr, p, pmatch[0].rm_so);\n\n        if (replace_str &&  !Jsi_Strchr(replace_str, '$'))\n            Jsi_DSAppend(&dStr, replace_str, NULL);\n        else if (replace_str) {\n            for (j = 0; j < replace_len; j++) {\n                int idx;\n                int c = replace_str[j];\n     \n                if (c == '$' && j < replace_len) {\n                    c = replace_str[++j];\n                    if ((c >= '0') && (c <= '9')) {\n                        idx = c - '0';\n                    } else if (c == '&') {\n                        idx = 0;\n                    } else if (c == '$') {\n                        Jsi_DSAppendLen(&dStr, replace_str + j, 1);\n                        continue;\n                    }\n                    else if (c == '\\'') {\n                        Jsi_DSAppendLen(&dStr, p + pmatch[0].rm_eo, pmatch[0].rm_eo-Jsi_Strlen(p));\n                        continue;\n                    }\n                    else if (c == '`') {\n                        Jsi_DSAppendLen(&dStr, p, pmatch[0].rm_so);\n                        continue;\n                    }\n                    else {\n                        Jsi_DSAppendLen(&dStr, replace_str + j - 1, 2);\n                        continue;\n                    }\n                } else {\n                     Jsi_DSAppendLen(&dStr, replace_str + j, 1);\n                     continue;\n                }\n                if ((idx < MAX_SUBREGEX) && pmatch[idx].rm_so != -1 && pmatch[idx].rm_eo != -1) {\n                    Jsi_DSAppendLen(&dStr, p + pmatch[idx].rm_so,\n                        pmatch[idx].rm_eo - pmatch[idx].rm_so);\n                }\n            }\n    \n        } else {\n            Jsi_DString sStr;\n            Jsi_DSInit(&sStr); \n            if (pmatch[0].rm_so <= 0 && pmatch[0].rm_eo <= 0)\n                break;\n            int olen = -1;\n            char *ostr = jsi_SubstrDup(p, -1, pmatch[0].rm_so, pmatch[0].rm_eo - pmatch[0].rm_so, &olen);\n            Jsi_Value *inStr = Jsi_ValueMakeBlob(interp, NULL, (uchar*)ostr, olen);\n            Jsi_DSFree(&sStr);\n            Jsi_IncrRefCount(interp, inStr);\n            if (maxArgs==1) {\n                Jsi_RC rc = Jsi_FunctionInvokeString(interp, repVal, inStr, &dStr);\n                if (Jsi_InterpGone(interp))\n                    return JSI_ERROR;\n                if (rc != JSI_OK) {\n                    Jsi_DSFree(&dStr);\n                    Jsi_DecrRefCount(interp, inStr);\n                    return JSI_ERROR;\n                }\n            } else {\n                Jsi_Value *vpargs, *items[MAX_SUBREGEX] = {}, *ret;\n                int i;\n                items[0] = inStr;\n                for (i=1; i<=(int)re->reg.re_nsub && i<(MAX_SUBREGEX-3); i++) {\n                    if (pmatch[i].rm_so<0)\n                        items[i] = interp->NullValue;\n                    else {\n                        ostr = jsi_SubstrDup(p, -1, pmatch[i].rm_so, pmatch[i].rm_eo - pmatch[i].rm_so, &olen);\n                        items[i] = Jsi_ValueMakeBlob(interp, NULL, (uchar*)ostr, olen);\n                    }\n                }\n                items[i++] = Jsi_ValueMakeNumber(interp, NULL, eoffset+pmatch[0].rm_so);\n                items[i++] = strVal;\n                vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, i, 0));\n                Jsi_IncrRefCount(interp, vpargs);\n                ret = Jsi_ValueNew1(interp);\n                rc = Jsi_FunctionInvoke(interp, repVal, vpargs, &ret, NULL);\n                if (Jsi_InterpGone(interp))\n                    return JSI_ERROR;\n                Jsi_DecrRefCount(interp, vpargs);\n                if (rc == JSI_OK)\n                    Jsi_DSAppend(&dStr, Jsi_ValueToString(interp, ret, NULL), NULL);\n                Jsi_DecrRefCount(interp, ret);\n                if (rc != JSI_OK) {\n                    Jsi_DSFree(&dStr);\n                    Jsi_DecrRefCount(interp, inStr);\n                    return JSI_ERROR;\n                }\n            }\n            Jsi_DecrRefCount(interp, inStr);\n        }\n        eoffset += pmatch[0].rm_eo;\n        p += pmatch[0].rm_eo;\n        n -= pmatch[0].rm_eo;\n        /* If -all is not specified, or there is no source left, we are done */\n        if (!isglob || n == 0 || pmatch[0].rm_eo == 0) {\n            break;\n        }\n        /* An anchored pattern without -line must be done */\n        if ((re->eflags & JSI_REG_NEWLINE) == 0 && re->pattern[0] == '^') {\n            break;\n        }\n        \n        /* If the pattern is empty, need to step forwards */\n        if (re->pattern[0] == '\\0' && n) {\n            /* Need to copy the char we are moving over */\n            Jsi_DSAppendLen(&dStr, p, 1);\n            p++;\n            n--;\n        }\n\n        regexec_flags |= REG_NOTBOL;\n    } while (n);\n\n    /*\n     * Copy the portion of the string after the last match to the\n     * result variable.\n     */\n    Jsi_DSAppend(&dStr, p, NULL);\n    Jsi_ValueFromDS(interp, &dStr, ret);\n    return rc;\n\n}\n\nstatic Jsi_RC StringSearchCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n\n    int sLen, bLen;\n    const char *source_str;\n    ChkString(_this, funcPtr, source_str, &sLen, &bLen);\n    \n    char *v = _this->d.obj->d.s.str;\n    Jsi_Value *seq = Jsi_ValueArrayIndex(interp, args, skip);\n\n    if (Jsi_ValueIsString(interp, seq)) {\n        char *ce, *cp = Jsi_ValueString(interp, seq, NULL);\n        int n = -1;\n        if ((ce = Jsi_Strstr(source_str, cp))) {\n            n = (ce-source_str);\n        }\n        Jsi_ValueMakeNumber(interp, ret, n);\n        return JSI_OK;\n    }\n    if (!seq || seq->vt != JSI_VT_OBJECT || seq->d.obj->ot != JSI_OT_REGEXP) {\n        Jsi_ValueMakeNumber(interp, ret, -1);\n        return JSI_OK;\n    }\n\n    regex_t *reg = &seq->d.obj->d.robj->reg;\n    \n    regmatch_t pos[MAX_SUBREGEX] = {};\n    int r;\n    if ((r = regexec(reg, v, MAX_SUBREGEX, pos, 0)) != 0) {\n        if (r == REG_NOMATCH) {\n            Jsi_ValueMakeNumber(interp, ret, -1.0);\n            return JSI_OK;\n        }\n        if (r >= REG_BADPAT) {\n            char buf[100];\n\n            regerror(r, reg, buf, sizeof(buf));\n            Jsi_LogError(\"error while matching pattern: %s\", buf);\n            return JSI_ERROR;\n        }\n\n    }\n    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)pos[0].rm_so);\n    return JSI_OK;\n}\n\n/* UNIMPL: 'toLocaleLowerCase', 'toLocaleUpperCase', 'localeCompare', */\n\nstatic Jsi_CmdSpec stringCmds[] = {\n    { \"String\",     StringConstructor,      0,  1,  \"str\", .help=\"String constructor\", .retType=(uint)JSI_TT_STRING, .flags=JSI_CMD_IS_CONSTRUCTOR },\n/*    { \"localeCompare\",StringLocaleCompareCmd,1, 1, \"pos\" },*/\n    { \"charAt\",     StringCharAtCmd,        1, 1, \"index:number\", .help=\"Return char at index\", .retType=(uint)JSI_TT_STRING},\n    { \"charCodeAt\", StringCharCodeAtCmd,    1, 1, \"index:number\", .help=\"Return char code at index\", .retType=(uint)JSI_TT_NUMBER },\n    { \"concat\",     StringConcatCmd,        0,-1, \"str:string, ...\", .help=\"Append one or more strings\", .retType=(uint)JSI_TT_STRING },\n    { \"fromCharCode\",StringFromCharCodeCmd, 0, -1, \"...\", .help=\"Return string for char codes\", .retType=(uint)JSI_TT_STRING },\n    { \"indexOf\",    StringIndexOfCmd,       1, 2, \"str:string, start:number\", .help=\"Return index of char\", .retType=(uint)JSI_TT_NUMBER },\n    { \"lastIndexOf\",StringLastIndexOfCmd,   1, 2, \"str:string, start:number\", .help=\"Return index of last char\", .retType=(uint)JSI_TT_NUMBER },\n    { \"match\",      StringMatchCmd,         1, 1, \"pattern:regexp|string\", .help=\"Return array of matches\", .retType=(uint)JSI_TT_ARRAY|JSI_TT_NULL },\n    { \"map\",        StringMapCmd,           1, 2, \"strMap:array, nocase:boolean=false\", .help=\"Replaces characters in string based on the key-value pairs in strMap\", .retType=(uint)JSI_TT_STRING },\n    { \"repeat\",     StringRepeatCmd,        1, 1, \"count:number\", .help=\"Return count copies of string\", .retType=(uint)JSI_TT_STRING, .flags=0, .info=0 },\n    { \"replace\",    StringReplaceCmd,       2, 2, \"pattern:regexp|string, replace:string|function\", .help=\"Regex/string replacement\", .retType=(uint)JSI_TT_STRING, .flags=0, .info=FN_strreplace },\n    { \"search\",     StringSearchCmd,        1, 1, \"pattern:regexp|string\", .help=\"Return index of first char matching pattern\", .retType=(uint)JSI_TT_NUMBER },\n    { \"slice\",      StringSliceCmd,         1, 2, \"start:number, end:number\", .help=\"Return section of string\", .retType=(uint)JSI_TT_STRING },\n    { \"split\",      StringSplitCmd,         0, 1, \"char:string|null=void\", .help=\"Split on char and return Array. When char is omitted splits on bytes.  When char==null splits on whitespace and removes empty elements\", .retType=(uint)JSI_TT_ARRAY },\n    { \"substr\",     StringSubstrCmd,        0, 2, \"start:number, length:number\", .help=\"Return substring\", .retType=(uint)JSI_TT_STRING },\n    { \"substring\",  StringSubstringCmd,     0, 2, \"start:number, end:number\", .help=\"Return substring\", .retType=(uint)JSI_TT_STRING },\n    { \"toLocaleLowerCase\",StringToLowerCaseCmd,0, 0, \"\",.help=\"Lower case\", .retType=(uint)JSI_TT_STRING },\n    { \"toLocaleUpperCase\",StringToUpperCaseCmd,0, 0, \"\",.help=\"Upper case\", .retType=(uint)JSI_TT_STRING },\n    { \"toLowerCase\",StringToLowerCaseCmd,   0, 0, \"\",.help=\"Return lower cased string\", .retType=(uint)JSI_TT_STRING },\n    { \"toUpperCase\",StringToUpperCaseCmd,   0, 0, \"\",.help=\"Return upper cased string\", .retType=(uint)JSI_TT_STRING },\n    { \"toTitle\",    StringToTitleCmd,       0, 1, \"chars:string\",.help=\"Make first char upper case\", .retType=(uint)JSI_TT_STRING },\n    { \"trim\",       StringTrimCmd,          0, 1, \"chars:string\",.help=\"Trim chars\", .retType=(uint)JSI_TT_STRING },\n    { \"trimLeft\",   StringTrimLeftCmd,      0, 1, \"chars:string\",.help=\"Trim chars from left\", .retType=(uint)JSI_TT_STRING },\n    { \"trimRight\",  StringTrimRightCmd,     0, 1, \"chars:string\",.help=\"Trim chars from right\", .retType=(uint)JSI_TT_STRING },\n    { NULL, 0,0,0,0, .help=\"Commands for accessing string objects.\" }\n};\n\nJsi_RC jsi_InitString(Jsi_Interp *interp, int release)\n{\n    if (!release)\n        interp->String_prototype = Jsi_CommandCreateSpecs(interp, \"String\", stringCmds, NULL, JSI_CMDSPEC_ISOBJ);\n    return JSI_OK;\n}\n\n#endif\n", "/* An implementation of Red-Black Trees with invariant node pointers. \n * Nodes are allocated using single malloc that includes the key. \n * This means that string/struct keys (which are of varying length) can not be copied between nodes.\n * So instead of swapping node key/values, positions are swapped when balancing the tree. */\n\n#ifndef JSI_AMALGAMATION\n#include \"jsiInt.h\"\n#endif\n\nenum {_JSI_TREE_RED=0, _JSI_TREE_BLACK=1};\n\n/********************** _JSI_TREE_RED/_JSI_TREE_BLACK HELPERS **************************/\n\nstatic Jsi_TreeEntry* grandparent(Jsi_TreeEntry* n) {\n    Assert (n != NULL);\n    Assert (n->parent != NULL);\n    Assert (n->parent->parent != NULL);\n    return n->parent->parent;\n}\n\nstatic Jsi_TreeEntry* sibling(Jsi_TreeEntry* n) {\n    Assert (n != NULL);\n    Assert (n->parent != NULL);\n    return (n == n->parent->left ? n->parent->right : n->parent->left);\n}\n\nstatic Jsi_TreeEntry* uncle(Jsi_TreeEntry* n) {\n    Assert (n != NULL);\n    Assert (n->parent != NULL);\n    Assert (n->parent->parent != NULL);\n    return sibling(n->parent);\n}\n\nstatic int node_color(Jsi_TreeEntry* n) {\n    return n == NULL ? _JSI_TREE_BLACK : n->f.bits.color;\n}\n\nstatic void set_color(Jsi_TreeEntry* n, int color) {\n    if (color == _JSI_TREE_BLACK && n == NULL) return;\n    n->f.bits.color = color;\n}\n\nstatic void replace_node(Jsi_TreeEntry* oldn, Jsi_TreeEntry* newn) {\n    Assert(oldn);\n    Jsi_Tree* t = oldn->treePtr;\n    if (oldn->parent == NULL) {\n        t->root = newn;\n    } else {\n        if (oldn == oldn->parent->left)\n            oldn->parent->left = newn;\n        else\n            oldn->parent->right = newn;\n    }\n    if (newn != NULL) {\n        newn->parent = oldn->parent;\n    }\n}\n\nstatic void rotate_left(Jsi_TreeEntry* n) {\n    Jsi_TreeEntry* r;\n    Assert(n);\n    r = n->right;\n    replace_node(n, r);\n    n->right = r->left;\n    if (r->left != NULL) {\n        r->left->parent = n;\n    }\n    r->left = n;\n    n->parent = r;\n}\n\nstatic void rotate_right(Jsi_TreeEntry* n) {\n    Jsi_TreeEntry* l;\n    Assert(n);\n    l = n->left;\n    replace_node(n, l);\n    n->left = l->right;\n    if (l->right != NULL) {\n        l->right->parent = n;\n    }\n    l->right = n;\n    n->parent = l;\n}\n\nstatic void insert_case5(Jsi_TreeEntry* n) {\n    Jsi_TreeEntry* g = grandparent(n);\n    set_color(n->parent, _JSI_TREE_BLACK);\n    set_color(g, _JSI_TREE_RED);\n    if (n == n->parent->left) {\n        rotate_right(g);\n    } else {\n        Assert (n == n->parent->right);\n        rotate_left(g);\n    }\n}\n\nstatic void insert_case4(Jsi_TreeEntry* n) {\n    Jsi_TreeEntry* g = grandparent(n);\n    if (n == n->parent->right && n->parent == g->left) {\n        rotate_left(n->parent);\n        n = n->left;\n    } else if (n == n->parent->left && n->parent == g->right) {\n        rotate_right(n->parent);\n        n = n->right;\n    }\n    insert_case5(n);\n}\n\nstatic void insert_case1(Jsi_TreeEntry* n);\n\nstatic void insert_case3(Jsi_TreeEntry* n) {\n    Jsi_TreeEntry *g, *u = uncle(n);\n    if (node_color(u) == _JSI_TREE_RED) {\n        set_color(n->parent, _JSI_TREE_BLACK);\n        set_color(u, _JSI_TREE_BLACK);\n        g = grandparent(n);\n        set_color(g, _JSI_TREE_RED);\n        insert_case1(g);\n    } else {\n        insert_case4(n);\n    }\n}\n\nstatic void insert_case2(Jsi_TreeEntry* n) {\n    if (node_color(n->parent) == _JSI_TREE_BLACK)\n        return;\n    insert_case3(n);\n}\n\nstatic void insert_case1(Jsi_TreeEntry* n) {\n    if (n->parent == NULL)\n        set_color(n, _JSI_TREE_BLACK);\n    else\n        insert_case2(n);\n}\n\nstatic Jsi_TreeEntry* maximum_node(Jsi_TreeEntry* n) {\n    Assert (n != NULL);\n    while (n->right != NULL) {\n        n = n->right;\n    }\n    return n;\n}\n\nstatic void delete_case6(Jsi_TreeEntry* n) {\n    Jsi_TreeEntry* s = sibling(n);\n    set_color(s, node_color(n->parent));\n    set_color(n->parent, _JSI_TREE_BLACK);\n    if (n == n->parent->left) {\n        Assert (node_color(s->right) == _JSI_TREE_RED);\n        set_color(s->right, _JSI_TREE_BLACK);\n        rotate_left(n->parent);\n    }\n    else\n    {\n        //Assert (node_color(s->left) == _JSI_TREE_RED);\n        set_color(s->left, _JSI_TREE_BLACK);\n        rotate_right(n->parent);\n    }\n}\n\nstatic void delete_case5(Jsi_TreeEntry* n) {\n    Jsi_TreeEntry* s = sibling(n);\n    if (node_color(s) == _JSI_TREE_BLACK ) {\n        if (n == n->parent->left &&\n                node_color(s->right) == _JSI_TREE_BLACK &&\n                node_color(s->left) == _JSI_TREE_RED)\n        {\n            set_color(s, _JSI_TREE_RED);\n            set_color(s->left, _JSI_TREE_BLACK);\n            rotate_right(s);\n        }\n        else if (n == n->parent->right &&\n                 node_color(s->right) == _JSI_TREE_RED &&\n                 node_color(s->left) == _JSI_TREE_BLACK)\n        {\n            set_color(s, _JSI_TREE_RED);\n            set_color(s->right, _JSI_TREE_BLACK);\n            rotate_left(s);\n        }\n    }\n    delete_case6(n);\n}\n\nstatic void delete_case4(Jsi_TreeEntry* n) {\n    Jsi_TreeEntry* s = sibling(n);\n    if (node_color(n->parent) == _JSI_TREE_RED &&\n            node_color(s) == _JSI_TREE_BLACK &&\n            node_color(s->left) == _JSI_TREE_BLACK &&\n            node_color(s->right) == _JSI_TREE_BLACK)\n    {\n        set_color(s, _JSI_TREE_RED);\n        set_color(n->parent, _JSI_TREE_BLACK);\n    }\n    else\n        delete_case5(n);\n}\n\nstatic void delete_case1(Jsi_TreeEntry* n);\n\nstatic void delete_case3(Jsi_TreeEntry* n) {\n    Jsi_TreeEntry* s  = sibling(n);\n    if (node_color(n->parent) == _JSI_TREE_BLACK &&\n        node_color(s) == _JSI_TREE_BLACK &&\n        node_color(s->left) == _JSI_TREE_BLACK &&\n        node_color(s->right) == _JSI_TREE_BLACK)\n    {\n        set_color(s, _JSI_TREE_RED);\n        delete_case1(n->parent);\n    } else\n        delete_case4(n);\n}\n\nstatic void delete_case2(Jsi_TreeEntry* n) {\n    Jsi_TreeEntry* s = sibling(n);\n    if (node_color(s) == _JSI_TREE_RED) {\n        set_color(n->parent, _JSI_TREE_RED);\n        set_color(s, _JSI_TREE_BLACK);\n        if (n == n->parent->left)\n            rotate_left(n->parent);\n        else\n            rotate_right(n->parent);\n    }\n    delete_case3(n);\n}\n\nstatic void delete_case1(Jsi_TreeEntry* n) {\n    if (n->parent != NULL)\n        delete_case2(n);\n}\n\n/***********************************************************/\n\nint jsi_treeHeight(Jsi_TreeEntry* hPtr, int n)\n{\n    int l = -1, r = -1;\n    if (hPtr->right == NULL && hPtr->right == NULL )\n        return n;\n    if (hPtr->left)\n        l = jsi_treeHeight(hPtr->left, n+1);\n    if (hPtr->right)\n        r = jsi_treeHeight(hPtr->right, n+1);\n    return (r > l ? r : l);\n}\n\nint jsi_nodeDepth(Jsi_TreeEntry* hPtr) {\n    int d = 0;\n    while (hPtr->parent != NULL) {\n        d++;\n        hPtr = hPtr->parent;\n    }\n    return d;\n}\n\n\nstatic int StringPtrCompare(Jsi_Tree *treePtr, const void *key1, const void *key2)\n{\n    //return (key1 - key2);\n    if (key1 == key2) return 0;\n    //return Jsi_DictionaryCompare((char*)key1, (char*)key2);\n    return Jsi_Strcmp((char*)key1, (char*)key2);\n}\n\n\nstatic int StringCompare(Jsi_Tree *treePtr, const void *key1, const void *key2)\n{\n    return Jsi_DictionaryCompare((char*)key1, (char*)key2);\n    //return Jsi_Strcmp((char*)key1, (char*)key2);\n}\n\nstatic int OneWordCompare(Jsi_Tree *treePtr, const void *key1, const void *key2)\n{\n    return ((uintptr_t )key1 - (uintptr_t)key2);\n}\n\nstatic int TreeArrayCompare(Jsi_Tree *treePtr, const void *key1, const void *key2)\n{\n    return memcmp(key1, key2, treePtr->keyType);\n}\n\n\nstatic Jsi_TreeEntry *TreeStringCreate( Jsi_Tree *treePtr, const void *key, bool *newPtr)\n{\n    Jsi_TreeEntry *hPtr;\n    size_t size;\n\n    if ((hPtr = Jsi_TreeEntryFind(treePtr, key))) {\n        if (newPtr)\n            *newPtr = 0;\n        return hPtr;\n    }\n    if (newPtr)\n        *newPtr = 1;\n    size = sizeof(Jsi_TreeEntry) + Jsi_Strlen((char*)key) /*- sizeof(jsi_TreeKey)*/ + 1;\n    hPtr = (Jsi_TreeEntry*)Jsi_Calloc(1,size);\n    SIGINIT(hPtr,TREEENTRY);\n    hPtr->typ = JSI_MAP_TREE;\n    hPtr->treePtr = treePtr;\n    hPtr->value = 0;\n    Jsi_Strcpy(hPtr->key.string, (char*)key);\n    treePtr->numEntries++;\n    return hPtr;\n}\n\nstatic Jsi_TreeEntry *TreeArrayCreate(Jsi_Tree *treePtr, const void *key, bool *newPtr)\n{\n    Jsi_TreeEntry *hPtr;\n    size_t size;\n\n    if ((hPtr = Jsi_TreeEntryFind(treePtr, key))) {\n        if (newPtr)\n            *newPtr = 0;\n        return hPtr;\n    }\n    if (newPtr)\n        *newPtr = 1;\n    size = sizeof(Jsi_TreeEntry) + treePtr->keyType; /*- sizeof(jsi_TreeKey);*/\n    hPtr = (Jsi_TreeEntry*)Jsi_Calloc(1,size);\n    SIGINIT(hPtr,TREEENTRY);\n    hPtr->typ = JSI_MAP_TREE;\n    hPtr->treePtr = treePtr;\n    hPtr->value = 0;\n    memcpy(hPtr->key.string, key, treePtr->keyType);\n    treePtr->numEntries++;\n    return hPtr;\n}\n\nstatic Jsi_TreeEntry *OneWordCreate( Jsi_Tree *treePtr, const void *key, bool *newPtr)\n{\n    Jsi_TreeEntry *hPtr;\n    size_t size;\n    if ((hPtr = Jsi_TreeEntryFind(treePtr, key))) {\n        if (newPtr)\n            *newPtr = 0;\n        return hPtr;\n    }\n    if (newPtr)\n        *newPtr = 1;\n    size = sizeof(Jsi_TreeEntry);\n    hPtr = (Jsi_TreeEntry*)Jsi_Calloc(1,size);\n    SIGINIT(hPtr,TREEENTRY);\n    hPtr->typ = JSI_MAP_TREE;\n    hPtr->treePtr = treePtr;\n    hPtr->value = 0;\n    hPtr->key.oneWordValue = (void *)key;\n    treePtr->numEntries++;\n    return hPtr;\n}\n\n\nstatic Jsi_TreeEntry *StringPtrCreate( Jsi_Tree *treePtr, const void *key, bool *newPtr)\n{\n    return OneWordCreate(treePtr, key, newPtr);\n}\n\nvoid *Jsi_TreeValueGet(Jsi_TreeEntry *hPtr)\n{\n    return hPtr->value;\n}\n\nvoid *Jsi_TreeKeyGet(Jsi_TreeEntry *hPtr)\n{\n    Jsi_Tree *t = hPtr->treePtr;\n    return (t->keyType == JSI_KEYS_ONEWORD || t->keyType == JSI_KEYS_STRINGKEY ? hPtr->key.oneWordValue : hPtr->key.string);\n}\n\n\nJsi_TreeEntry *Jsi_TreeEntryFind (Jsi_Tree *treePtr, const void *key)\n{\n    Jsi_TreeEntry* hPtr = treePtr->root;\n    int rc;\n    if (treePtr->flags.destroyed)\n        return NULL;\n    if (treePtr->opts.lockTreeProc && (*treePtr->opts.lockTreeProc)(treePtr, 1) != JSI_OK)\n        return NULL;\n    while (hPtr != NULL) {\n        rc = treePtr->opts.compareTreeProc(treePtr, Jsi_TreeKeyGet(hPtr), key);\n        if (rc == 0) {\n            break;\n        }\n        hPtr = (rc < 0 ? hPtr->left : hPtr->right);\n    }\n    if (treePtr->opts.lockTreeProc)\n        (*treePtr->opts.lockTreeProc)(treePtr, 0);\n    return hPtr;\n}\n\nJsi_TreeEntry *Jsi_TreeEntryNew(Jsi_Tree *treePtr, const void *key, bool *isNew)\n{\n    Jsi_TreeEntry* hPtr;\n    bool isn;\n    if (treePtr->flags.destroyed)\n        return NULL;\n    if (treePtr->opts.lockTreeProc && (*treePtr->opts.lockTreeProc)(treePtr, 1) != JSI_OK)\n        return NULL;\n    treePtr->flags.inserting=1;\n    if (treePtr->flags.internstr) {\n        Assert(treePtr->keyType == JSI_KEYS_STRINGKEY);\n        if (!treePtr->strHash)\n            treePtr->strHash = Jsi_HashNew(treePtr->opts.interp, JSI_KEYS_STRING, NULL);\n        key = Jsi_HashEntryNew(treePtr->strHash, key, NULL);\n    }\n    hPtr = treePtr->createProc(treePtr, key, &isn);\n    if (isNew)\n        *isNew = isn;\n    if (isn == 0 || treePtr->flags.nonredblack == 1 || !hPtr) {\n        treePtr->flags.inserting=0;\n        goto done;\n    }\n    treePtr->epoch++;\n    hPtr->f.bits.color = _JSI_TREE_RED;\n    if (treePtr->root == NULL) {\n        treePtr->root = hPtr;\n    } else {\n        Jsi_TreeEntry* n = treePtr->root;\n        while (1) {\n            int rc = treePtr->opts.compareTreeProc(treePtr, Jsi_TreeKeyGet(n) , key);\n            if (rc == 0) {\n                Assert(0);\n            } else if (rc < 0) {\n                if (n->left == NULL) {\n                    n->left = hPtr;\n                    break;\n                } else {\n                    n = n->left;\n                }\n            } else {\n                if (n->right == NULL) {\n                    n->right = hPtr;\n                    break;\n                } else {\n                    n = n->right;\n                }\n            }\n        }\n        hPtr->parent = n;\n    }\n    insert_case1(hPtr);\n    treePtr->flags.inserting = 0;\ndone:\n    if (treePtr->opts.lockTreeProc)\n        (*treePtr->opts.lockTreeProc)(treePtr, 0);\n    return hPtr;\n}\n\nJsi_Tree *Jsi_TreeNew(Jsi_Interp *interp, unsigned int keyType, Jsi_TreeDeleteProc *freeProc)\n{\n    Jsi_Tree* treePtr = (Jsi_Tree*)Jsi_Calloc(1,sizeof(Jsi_Tree));\n    SIGINIT(treePtr,TREE);\n    treePtr->opts.mapType = (Jsi_Map_Type)JSI_MAP_TREE;\n    treePtr->typ = (Jsi_Map_Type)JSI_MAP_TREE;\n    treePtr->root = NULL;\n    treePtr->opts.interp = interp;\n    treePtr->numEntries = 0;\n    treePtr->epoch = 0;\n    treePtr->opts.keyType = (Jsi_Key_Type)keyType;\n    treePtr->keyType = (Jsi_Key_Type)keyType;\n    treePtr->opts.freeTreeProc = freeProc;\n\n    switch (keyType) {\n    case JSI_KEYS_STRING:   /* NULL terminated string keys. */\n        treePtr->opts.compareTreeProc = StringCompare;\n        treePtr->createProc = TreeStringCreate;\n        break;\n\n    case JSI_KEYS_STRINGKEY: /*  */\n        treePtr->opts.compareTreeProc = StringPtrCompare;\n        treePtr->createProc = StringPtrCreate;\n        break;\n        \n    case JSI_KEYS_ONEWORD: /* 32 or 64 bit atomic keys. */\n        treePtr->opts.compareTreeProc = OneWordCompare;\n        treePtr->createProc = OneWordCreate;\n        break;\n\n\n    default:            /* Struct. */\n        if (keyType < JSI_KEYS_STRUCT_MINSIZE) {\n            Jsi_LogError(\"Jsi_TreeNew: Key size can't be %d, must be > %d\", keyType, JSI_KEYS_STRUCT_MINSIZE);\n            Jsi_Free(treePtr);\n            return NULL;\n        }\n        treePtr->opts.compareTreeProc = TreeArrayCompare;\n        treePtr->createProc = TreeArrayCreate;\n        break;\n    }\n    return treePtr;\n}\n\nstatic void destroy_node(Jsi_Interp *interp, Jsi_TreeEntry* n)\n{\n    if (n == NULL) return;\n    if (n->right != NULL) destroy_node(interp, n->right);\n    if (n->left != NULL) destroy_node(interp, n->left);\n    n->left = n->right = NULL;\n    Jsi_TreeEntryDelete(n);\n}\n\nvoid Jsi_TreeClear (Jsi_Tree *treePtr)\n{\n    SIGASSERTV(treePtr, TREE);\n    if (treePtr->opts.lockTreeProc && (*treePtr->opts.lockTreeProc)(treePtr, 1) != JSI_OK)\n        return;\n    destroy_node(treePtr->opts.interp, treePtr->root);\n    treePtr->root = NULL;\n    if (treePtr->opts.lockTreeProc)\n        (*treePtr->opts.lockTreeProc)(treePtr, 0);\n}\n\nvoid Jsi_TreeDelete (Jsi_Tree *treePtr)\n{\n    SIGASSERTV(treePtr, TREE);\n    if (treePtr->flags.destroyed)\n        return;\n    //Jsi_TreeClear(treePtr);\n    treePtr->flags.destroyed = 1;\n    destroy_node(treePtr->opts.interp, treePtr->root);\n    _JSI_MEMCLEAR(treePtr);\n    Jsi_Free(treePtr);\n}\n\n/* Swap positions of nodes in tree.  This avoids moving the value, which we can't do for strings/structs. */\nstatic void SwapNodes(Jsi_TreeEntry* n, Jsi_TreeEntry* m)\n{\n    Jsi_Tree* t = n->treePtr;\n    Jsi_TreeEntry *np, *nl, *nr, *mp, *ml, *mr;\n    int mpc = 0, npc = 0, col = n->f.bits.color;\n    n->f.bits.color = m->f.bits.color;  m->f.bits.color = col;\n    np = n->parent; nl = n->left; nr = n->right;\n    mp = m->parent; ml = m->left; mr = m->right;\n    if (mp) mpc = (mp->left == m ?1 : 2);\n    if (np) npc = (np->left == n ?1 : 2);\n\n    n->parent = mp; n->left = ml; n->right = mr;\n    m->parent = np; m->left = nl; m->right = nr;\n    \n    if (np == m) {\n        m->parent = n;\n        if (mr == n) n->right = m; else n->left = m;\n    } else if (mp == n) {\n        n->parent = m;\n        if (nr == m) m->right = n; else m->left = n;\n    }\n    /* Fixup back pointers. */\n    if (m->left)  m->left->parent  = m;\n    if (m->right) m->right->parent = m;\n    if (n->left)  n->left->parent  = n;\n    if (n->right) n->right->parent = n;\n    if (mpc) { if (mpc==1) n->parent->left = n; else  n->parent->right = n;}\n    if (npc) { if (npc==1) m->parent->left = m; else  m->parent->right = m; }\n    if (n->parent == NULL) {\n        t->root = n;\n    } else if (m->parent == NULL) {\n        t->root = m;\n    }\n}\n\nstatic void delete_one_child(Jsi_TreeEntry*n)\n{\n    Jsi_TreeEntry *child;\n    Assert(n->left == NULL || n->right == NULL);\n    child = n->right == NULL ? n->left  : n->right;\n#if 1\n    if (node_color(n) == _JSI_TREE_BLACK) {\n        set_color(n, node_color(child));\n        delete_case1(n);\n    }\n    replace_node(n, child);\n    if (n->parent == NULL && child != NULL)\n        set_color(child, _JSI_TREE_BLACK);\n    \n#else\n    replace_node(n, child);\n    if (node_color(n) == _JSI_TREE_BLACK) {\n        if (node_color(child) == _JSI_TREE_RED)\n            child->f.bits.color = _JSI_TREE_BLACK;\n        else\n            delete_case1(n);\n    }\n#endif\n}\n\nint Jsi_TreeEntryDelete (Jsi_TreeEntry *entryPtr)\n{\n    int cnt = 0;\n    Jsi_TreeEntry* n = entryPtr;\n    Jsi_Tree* treePtr = n->treePtr;\n\n    if (treePtr->flags.destroyed  || treePtr->flags.nonredblack == 1 /* || entryPtr->f.bits.deletesub */) {\n        goto dodel;\n    }\n    /*printf(\"DEL(tree=%p,root=%p): (%p)%s\\n\", treePtr, treePtr->root, entryPtr,(char*)entryPtr->key.string);*/\n    /*dumpTree(treePtr);*/\n    if (treePtr->opts.lockTreeProc && (*treePtr->opts.lockTreeProc)(treePtr, 1) != JSI_OK)\n        return -1;\n    entryPtr->treePtr->epoch++;\n    if (n->left != NULL && n->right != NULL) {\n        /* swap key/values delete pred instead */\n        Jsi_TreeEntry* pred = maximum_node(n->left);\n        switch (treePtr->keyType) {\n        case JSI_KEYS_STRINGKEY:\n        case JSI_KEYS_ONEWORD: {\n            void *nv = n->value;\n            n->value = pred->value;\n            pred->value = nv;\n            nv = n->key.oneWordValue;\n            n->key.oneWordValue = pred->key.oneWordValue;\n            pred->key.oneWordValue = nv;\n            n = pred;\n            break;\n        }\n        case JSI_KEYS_STRING:\n            SwapNodes(n,pred);\n            break;\n        default: { // Struct keys have the same length so we swap bytes.\n            uint i;\n            void *nv = n->value;\n            n->value = pred->value;\n            pred->value = nv;\n            char ct, *cs = (char*)(n->key.string), *cd = (char*)(pred->key.string);\n            for (i=0; i<treePtr->keyType; i++, cs++, cd++) {\n                ct = *cd;\n                *cd = *cs;\n                *cs = ct;\n            }\n        }\n                \n        }\n    }\n    delete_one_child(n);\n    cnt++;\n    /*dumpTree(treePtr);*/\ndodel:\n    treePtr->numEntries--;\n    n->treePtr = NULL;\n    if (treePtr->opts.freeTreeProc && n && n->value)\n        (treePtr->opts.freeTreeProc)(treePtr->opts.interp, n, n->value);\n    Jsi_Free(n);\n    if (treePtr->opts.lockTreeProc)\n        (*treePtr->opts.lockTreeProc)(treePtr, 0);\n    return cnt;\n}\n\nstatic void searchSpace(Jsi_TreeSearch *searchPtr, int n)\n{\n    if ((searchPtr->top+n) >= searchPtr->max) {\n        int i, cnt = (searchPtr->max *= 2);\n        if (searchPtr->Ptrs == searchPtr->staticPtrs)\n            searchPtr->Ptrs = (Jsi_TreeEntry**)Jsi_Calloc(cnt, sizeof(Jsi_TreeEntry*));\n        else\n            searchPtr->Ptrs = (Jsi_TreeEntry**)Jsi_Realloc(searchPtr->Ptrs, cnt* sizeof(Jsi_TreeEntry*));\n        for (i=0; i<cnt; i++)\n            SIGINIT((searchPtr->Ptrs[i]),TREEENTRY);\n\n    }\n}\n\nstatic Jsi_TreeEntry *searchAdd(Jsi_TreeSearch *searchPtr,  Jsi_TreeEntry *hPtr)\n{\n    int order = (searchPtr->flags & JSI_TREE_ORDER_MASK);\n    searchSpace(searchPtr, 2);\n    switch (order) {\n        case JSI_TREE_ORDER_LEVEL:\n            if (hPtr) {\n                if (hPtr->right)\n                    searchPtr->Ptrs[searchPtr->top++] = hPtr->right;\n                if (hPtr->left)\n                    searchPtr->Ptrs[searchPtr->top++] = hPtr->left;\n                return hPtr;\n            }\n            if (searchPtr->top<=0)\n                return NULL;\n            hPtr = searchPtr->Ptrs[0];\n            searchPtr->top--;\n            if (searchPtr->top > 0) {\n                /* Not very efficient way to implement a queue, but works for now. */\n                memmove(searchPtr->Ptrs, searchPtr->Ptrs+1, sizeof(Jsi_TreeEntry*)*searchPtr->top);\n            }\n            if (hPtr->right)\n                searchPtr->Ptrs[searchPtr->top++] = hPtr->right;\n            if (hPtr->left)\n                searchPtr->Ptrs[searchPtr->top++] = hPtr->left;\n            return hPtr;\n            break;\n            \n        case JSI_TREE_ORDER_POST:\n            if (hPtr)\n                searchPtr->Ptrs[searchPtr->top++] = searchPtr->current = hPtr;\n            while (searchPtr->top>0) {\n                hPtr = searchPtr->Ptrs[searchPtr->top-1];\n                if (hPtr->right == searchPtr->current || hPtr->left == searchPtr->current ||\n                    (hPtr->left == NULL && hPtr->right == NULL)) {\n                    searchPtr->top--;\n                    searchPtr->current = hPtr;\n                    return hPtr;\n                } else {\n                    searchSpace(searchPtr, 2);\n                    if (hPtr->left)\n                        searchPtr->Ptrs[searchPtr->top++] = hPtr->left;\n                    if (hPtr->right)\n                        searchPtr->Ptrs[searchPtr->top++] = hPtr->right;\n                }\n            }\n            return NULL;\n            break;\n            \n        case JSI_TREE_ORDER_PRE:\n            if (!hPtr) {\n                if (searchPtr->top<=0) return NULL;\n                hPtr = searchPtr->Ptrs[--searchPtr->top];\n            }\n            searchPtr->Ptrs[searchPtr->top++] = hPtr;\n            if (hPtr->left) searchPtr->Ptrs[searchPtr->top++] = hPtr->left;\n            if (hPtr->right) searchPtr->Ptrs[searchPtr->top++] = hPtr->right;\n            break;\n            \n        case JSI_TREE_ORDER_IN:\n            while (1) {\n                searchSpace(searchPtr, 2);\n                if (searchPtr->current) {\n                    searchPtr->Ptrs[searchPtr->top++] = searchPtr->current;\n                    searchPtr->current = searchPtr->current->right;\n                } else {\n                    if (searchPtr->top<=0)\n                        return NULL;\n                    hPtr = searchPtr->Ptrs[--searchPtr->top] ;\n                    searchPtr->current = hPtr->left;\n                    return hPtr;\n                }\n            }\n            break;\n            \n        default:\n            if (hPtr) {\n                Jsi_Interp *interp = hPtr->treePtr->opts.interp;\n                JSI_NOTUSED(interp);\n                Jsi_LogError(\"Invalid order: %d\", order);    \n            }    \n    }\n    return searchPtr->Ptrs[--searchPtr->top];\n}\n\nJsi_TreeEntry *Jsi_TreeSearchFirst (Jsi_Tree *treePtr, Jsi_TreeSearch *searchPtr, int flags, const void *startKey)\n{\n    Jsi_TreeEntry *hPtr = NULL, *hPtr2 = NULL;\n    if (!treePtr) return NULL;\n    memset(searchPtr, 0, sizeof(*searchPtr));\n    searchPtr->treePtr = treePtr;\n    searchPtr->flags = flags;\n    searchPtr->Ptrs = searchPtr->staticPtrs;\n    searchPtr->max = sizeof(searchPtr->staticPtrs)/sizeof(searchPtr->staticPtrs[0]);\n    searchPtr->epoch = treePtr->epoch;\n    if (startKey || (flags & JSI_TREE_SEARCH_KEY))\n        hPtr2 = Jsi_TreeEntryFind(treePtr, startKey);;\n    searchPtr->current = treePtr->root;\n    hPtr = searchAdd(searchPtr, treePtr->root);\n    if (hPtr2 && hPtr && hPtr2 != hPtr)\n        while (hPtr && hPtr2 != hPtr) // TODO: need a more efficient way to do this...\n            hPtr = Jsi_TreeSearchNext(searchPtr);\n    return hPtr;\n}\n\nvoid Jsi_TreeValueSet(Jsi_TreeEntry *hPtr, void *value)\n{\n    Jsi_Value *v = (Jsi_Value*)value;\n#if JSI__MEMDEBUG\n    SIGASSERTV(hPtr, TREEENTRY);\n    if (hPtr->treePtr->flags.valuesonly)\n        SIGASSERTV(v,VALUE);\n#endif\n    hPtr->value = v;\n}\n\n#ifndef JSI_LITE_ONLY\n\nJsi_Tree *Jsi_TreeFromValue(Jsi_Interp *interp, Jsi_Value *v)\n{\n    if (!Jsi_ValueIsObjType(interp, v, JSI_OT_OBJECT))\n        return NULL;\n    return v->d.obj->tree;\n}\n\n#endif \n\nJsi_TreeEntry *Jsi_TreeSearchNext(Jsi_TreeSearch *searchPtr)\n{\n    Jsi_TreeEntry *hPtr = NULL;\n    if (searchPtr->epoch == searchPtr->treePtr->epoch)\n        hPtr = searchAdd(searchPtr, NULL);\n    if (!hPtr)\n        Jsi_TreeSearchDone(searchPtr);\n    return hPtr;\n}\n\nvoid Jsi_TreeSearchDone(Jsi_TreeSearch *searchPtr)\n{\n    if (searchPtr->Ptrs != searchPtr->staticPtrs)\n        Jsi_Free(searchPtr->Ptrs);\n    searchPtr->Ptrs = searchPtr->staticPtrs;\n    searchPtr->top = 0;\n}\n\nJsi_TreeEntry *Jsi_TreeSet(Jsi_Tree *treePtr, const void *key, void *value)\n{\n    Jsi_TreeEntry *hPtr;\n    bool isNew;\n    hPtr = Jsi_TreeEntryNew(treePtr, key, &isNew);\n    if (!hPtr) return hPtr;\n    Jsi_TreeValueSet(hPtr, value);\n    return hPtr;\n}\n\nvoid *Jsi_TreeGet(Jsi_Tree *treePtr, void *key, int flags)\n{\n    Jsi_TreeEntry *hPtr = Jsi_TreeEntryFind(treePtr, key);\n    if (!hPtr)\n        return NULL;\n    return Jsi_TreeValueGet(hPtr);\n}\n\n// Delete entry, and invoke freeProc.\nbool Jsi_TreeUnset(Jsi_Tree *treePtr, void *key) {\n    Jsi_TreeEntry *hPtr = Jsi_TreeEntryFind(treePtr, key);\n    if (!hPtr)\n        return false;\n    Jsi_TreeEntryDelete(hPtr);\n    return true;\n}\n\nstatic int tree_inorder(Jsi_Tree *treePtr, Jsi_TreeEntry *hPtr, Jsi_TreeWalkProc *callback, void *data) {\n    uint epoch = treePtr->epoch;\n    if (hPtr == NULL) return JSI_OK;\n    if (hPtr->right != NULL) {\n        if (tree_inorder(treePtr, hPtr->right, callback, data) != JSI_OK || epoch != treePtr->epoch)\n            return JSI_ERROR;\n    }\n    if (callback(treePtr, hPtr, data) != JSI_OK || epoch != treePtr->epoch)\n        return JSI_ERROR;\n    Assert(hPtr->treePtr);\n    if (hPtr->left != NULL) {\n        if (tree_inorder(treePtr, hPtr->left, callback, data) != JSI_OK || epoch != treePtr->epoch)\n            return JSI_ERROR;\n    }\n    return JSI_OK;\n}\n\n\nstatic int tree_preorder(Jsi_Tree *treePtr, Jsi_TreeEntry *hPtr, Jsi_TreeWalkProc *callback, void *data) {\n    uint epoch = treePtr->epoch;\n    if (hPtr == NULL) return JSI_OK;\n    if (callback(treePtr, hPtr, data) != JSI_OK || epoch != treePtr->epoch)\n        return JSI_ERROR;\n    if (hPtr->right != NULL) {\n        if (tree_preorder(treePtr, hPtr->right, callback, data) != JSI_OK || epoch != treePtr->epoch)\n            return JSI_ERROR;\n    }\n    if (hPtr->left != NULL) {\n        if (tree_preorder(treePtr, hPtr->left, callback, data) != JSI_OK || epoch != treePtr->epoch)\n            return JSI_ERROR;\n    }\n    return JSI_OK;\n}\n\n\nstatic int tree_postorder(Jsi_Tree *treePtr, Jsi_TreeEntry *hPtr, Jsi_TreeWalkProc *callback, void *data) {\n    uint epoch = treePtr->epoch;\n    if (hPtr == NULL) return JSI_OK;\n    if (hPtr->right != NULL) {\n        if (tree_postorder(treePtr, hPtr->right, callback, data) != JSI_OK || epoch != treePtr->epoch)\n            return JSI_ERROR;\n    }\n    if (hPtr->left != NULL) {\n        if (tree_postorder(treePtr, hPtr->left, callback, data) != JSI_OK || epoch != treePtr->epoch)\n            return JSI_ERROR;\n    }\n    if (callback(treePtr, hPtr, data) != JSI_OK || epoch != treePtr->epoch)\n        return JSI_ERROR;\n    return JSI_OK;\n}\n\n\nstatic int tree_levelorder(Jsi_Tree *treePtr, Jsi_TreeEntry *hPtr, Jsi_TreeWalkProc *callback,\n    void *data, int curlev, int level, int *cnt) {\n    uint epoch = treePtr->epoch;\n    if (hPtr == NULL) return JSI_OK;\n    if (curlev > level) return JSI_OK;\n    if (curlev == level) {\n        if (callback(treePtr, hPtr, data) != JSI_OK || epoch != treePtr->epoch)\n            return JSI_ERROR;\n        (*cnt)++;\n    }\n    if (hPtr->right != NULL) {\n        if (tree_levelorder(treePtr, hPtr->right, callback, data, curlev+1, level, cnt) != JSI_OK || epoch != treePtr->epoch)\n            return JSI_ERROR;\n    }\n    if (hPtr->left != NULL) {\n        if (tree_levelorder(treePtr, hPtr->left, callback, data, curlev+1, level, cnt) != JSI_OK || epoch != treePtr->epoch)\n            return JSI_ERROR;\n    }\n    return JSI_OK;\n}\n\n\nint Jsi_TreeWalk(Jsi_Tree* treePtr, Jsi_TreeWalkProc* callback, void *data, int flags) {\n    Jsi_Interp *interp = treePtr->opts.interp;\n    JSI_NOTUSED(interp);\n    int n = 0, m = -1, lastm, order;\n    order = flags & JSI_TREE_ORDER_MASK;\n    switch (order) {\n    case JSI_TREE_ORDER_PRE:\n        return tree_preorder(treePtr, treePtr->root, callback, data);\n    case JSI_TREE_ORDER_POST:\n        return tree_postorder(treePtr, treePtr->root, callback, data);\n    case JSI_TREE_ORDER_IN:\n        return tree_inorder(treePtr, treePtr->root, callback, data);\n    case JSI_TREE_ORDER_LEVEL:\n        while (1) {\n            lastm = m;\n            if (tree_levelorder(treePtr, treePtr->root, callback, data, 0, n, &m) != JSI_OK)\n                return JSI_ERROR;\n            if (lastm == m)\n                return JSI_OK;\n            n++;\n        }\n            \n    default:\n        Jsi_LogError(\"Invalid order: %d\", order);\n    }\n    return JSI_ERROR;\n}\n\n#ifdef JSI_TEST_RBTREE\n\nJSI_RC mycall(Jsi_Tree* treePtr, Jsi_TreeEntry* hPtr, void *data)\n{\n    printf(\"CALL: %s(%d) : %d\\n\", (char*)Jsi_TreeKeyGet(hPtr), jsi_nodeDepth(hPtr), (int)Jsi_TreeValueGet(hPtr));\n    return JSI_OK;\n}\n\nstatic void TreeTest(Jsi_Interp* interp) {\n    Jsi_Tree *st, *wt, *mt;\n    Jsi_TreeEntry *hPtr, *hPtr2;\n    bool isNew, i;\n    Jsi_TreeSearch srch;\n    struct tdata {\n        int n;\n        int m;\n    } t1, t2;\n    char nbuf[100];\n    \n    wt = Jsi_TreeNew(interp, JSI_KEYS_ONEWORD, NULL);\n    mt = Jsi_TreeNew(interp, sizeof(struct tdata), NULL);\n\n    Jsi_TreeSet(wt, wt,(void*)0x88);\n    Jsi_TreeSet(wt, mt,(void*)0x99);\n    printf(\"WT: %p\\n\", Jsi_TreeGet(wt, mt));\n    printf(\"WT2: %p\\n\", Jsi_TreeGet(wt, wt));\n    Jsi_TreeDelete(wt);\n\n    t1.n = 0; t1.m = 1;\n    t2.n = 1; t2.m = 2;\n    Jsi_TreeSet(mt, &t1,(void*)0x88);\n    Jsi_TreeSet(mt, &t2,(void*)0x99);\n    Jsi_TreeSet(mt, &t2,(void*)0x98);\n    printf(\"CT: %p\\n\", Jsi_TreeGet(mt, &t1));\n    printf(\"CT2: %p\\n\", Jsi_TreeGet(mt, &t2));\n    Jsi_TreeDelete(mt);\n\n    st = Jsi_TreeNew(interp, JSI_KEYS_STRING, NULL);\n    hPtr = Jsi_TreeEntryNew(st, \"bob\", &isNew);\n    Jsi_TreeValueSet(hPtr, (void*)99);\n    Jsi_TreeSet(st, \"zoe\",(void*)77);\n    hPtr2 = Jsi_TreeSet(st, \"ted\",(void*)55);\n    Jsi_TreeSet(st, \"philip\",(void*)66);\n    Jsi_TreeSet(st, \"alice\",(void*)77);\n    puts(\"SRCH\");\n    for (hPtr=Jsi_TreeSearchFirst(st,&srch,  JSI_TREE_ORDER_IN, NULL); hPtr; hPtr=Jsi_TreeSearchNext(&srch))\n        mycall(st, hPtr, NULL);\n    Jsi_TreeSearchDone(&srch);\n    puts(\"IN\");\n    Jsi_TreeWalk(st, mycall, NULL, JSI_TREE_ORDER_IN);\n    puts(\"PRE\");\n    Jsi_TreeWalk(st, mycall, NULL, JSI_TREE_ORDER_PRE);\n    puts(\"POST\");\n    Jsi_TreeWalk(st, mycall, NULL, JSI_TREE_ORDER_POST);\n    puts(\"LEVEL\");\n    Jsi_TreeWalk(st, mycall, NULL, JSI_TREE_ORDER_LEVEL);\n    Jsi_TreeEntryDelete(hPtr2);\n    puts(\"INDEL\");\n    Jsi_TreeWalk(st, mycall, NULL, 0);\n\n    for (i=0; i<1000; i++) {\n        snprintf(nbuf, sizeof(nbuf), \"name%d\", i);\n        Jsi_TreeSet(st, nbuf,(void*)i);\n    }\n    Jsi_TreeWalk(st, mycall, NULL, 0);\n    for (i=0; i<1000; i++) {\n        Jsi_TreeEntryDelete(st->root);\n    }\n    puts(\"OK\");\n    Jsi_TreeWalk(st, mycall, NULL, 0);\n    Jsi_TreeDelete(st);\n\n}\n\nint jsi_InitTree(Jsi_Interp *interp, int release)\n{\n    if (release) return JSI_OK;\n    TreeTest(interp);\n    return JSI_OK;\n}\n\n#else\n\nJsi_RC jsi_InitTree(Jsi_Interp *interp, int release)\n{\n    if (release) return JSI_OK;\n    /* TODO: maintain hash table of trees created per interp? */\n    return JSI_OK;\n}\n#endif\nuint Jsi_TreeSize(Jsi_Tree *treePtr) { return treePtr->numEntries; }\n\nJsi_RC Jsi_TreeConf(Jsi_Tree *treePtr, Jsi_MapOpts *opts, bool set)\n{\n    if (set)\n        treePtr->opts = *opts;\n    else\n        *opts = treePtr->opts;\n    return JSI_OK;\n}\n\n#ifndef JSI_LITE_ONLY\n\nstatic Jsi_Value *jsi_treeFmtKey(Jsi_MapEntry* h, struct Jsi_MapOpts *opts, int flags)\n{\n    Jsi_TreeEntry* hPtr = (Jsi_TreeEntry*)h;\n    void *key = Jsi_TreeKeyGet(hPtr);\n    if (opts->keyType == JSI_KEYS_ONEWORD)\n        return Jsi_ValueNewNumber(opts->interp, (Jsi_Number)(intptr_t)key);\n    char nbuf[100];\n    snprintf(nbuf, sizeof(nbuf), \"%p\", key);\n    return Jsi_ValueNewStringDup(opts->interp, nbuf);\n}\n\nJsi_RC Jsi_TreeKeysDump(Jsi_Interp *interp, Jsi_Tree *tablePtr, Jsi_Value **ret, int flags) {\n    char *key;\n    int n = 0;\n    Jsi_TreeEntry *hPtr;\n    Jsi_TreeSearch search;\n    Jsi_Obj *nobj;\n    Jsi_MapFmtKeyProc* fmtKeyProc = tablePtr->opts.fmtKeyProc;\n    \n    if (!fmtKeyProc && tablePtr->keyType == JSI_KEYS_ONEWORD && flags!=JSI_KEYS_ONEWORD )\n        fmtKeyProc = jsi_treeFmtKey;\n        \n    if (!fmtKeyProc && tablePtr->keyType >= JSI_KEYS_STRUCT_MINSIZE) \n        return Jsi_LogError(\"Can not dump struct tree\");\n    nobj = Jsi_ObjNew(interp);\n    Jsi_ValueMakeArrayObject(interp, ret, nobj);\n    for (hPtr = Jsi_TreeSearchFirst(tablePtr, &search, flags, NULL);\n        hPtr != NULL; hPtr = Jsi_TreeSearchNext(&search)) {\n        key = (char*)Jsi_TreeKeyGet(hPtr);\n        Jsi_Value *val;\n        if (fmtKeyProc) {\n            val = (*fmtKeyProc)((Jsi_MapEntry*)hPtr, &tablePtr->opts, flags);\n            if (!val) {\n                Jsi_LogError(\"key format failed\");\n                Jsi_ValueMakeUndef(interp, ret);\n                return JSI_ERROR;\n            }\n        } else if (tablePtr->keyType == JSI_KEYS_ONEWORD)\n            val = Jsi_ValueNewNumber(interp, (Jsi_Number)(uintptr_t)key);\n        else\n            val = Jsi_ValueNewStringKey(interp, key);\n        Jsi_ObjArraySet(interp, nobj, val, n++);\n        if (fmtKeyProc && val->refCnt>1) //TODO: Hmmm. for StructKey Jsi_OptionsDump() returns refCnt=1\n            Jsi_DecrRefCount(interp, val);\n    }\n    Jsi_TreeSearchDone(&search);\n    return JSI_OK;\n}\n#endif\n\n", "#ifndef JSI_AMALGAMATION\n#include \"jsiInt.h\"\n#endif\n#include <errno.h>\n#include <sys/time.h>\n\n\n#if (defined(JSI__READLINE) && JSI__READLINE==1)\n#define JSI_HAS_READLINE 1\n//#define USE_GNU_READLINE\n#ifdef USE_GNU_READLINE\n# include <readline/readline.h>\n# include <readline/history.h>\n\n# define jsi_sh_add_history(X) add_history(X)\n# define jsi_sh_read_history(X) read_history(X)\n# define jsi_sh_write_history(X) write_history(X)\n# define jsi_sh_stifle_history(X) stifle_history(X)\n# define jsi_sh_readline(X) readline(X)\n#else\n#ifndef JSI_AMALGAMATION\n#include \"linenoise.h\"\n#endif\n# define jsi_sh_add_history(X) linenoiseHistoryAdd(X)\n# define jsi_sh_read_history(X) linenoiseHistoryLoad(X)\n# define jsi_sh_write_history(X) linenoiseHistorySave(X)\n# define jsi_sh_stifle_history(X) linenoiseHistorySetMaxLen(X)\n# define jsi_sh_readline(X) linenoise(X)\n#endif\n#else\n\n# define jsi_sh_read_history(X)\n# define jsi_sh_write_history(X)\n# define jsi_sh_stifle_history(X)\n\n# define JSI_SH_USE_LOCAL_GETLINE 1\n#endif\n#include <math.h>\n\n#ifdef Jsi_Free\n#undef Jsi_Free\n#undef Jsi_Malloc\n#undef Jsi_Calloc\n#undef Jsi_Realloc\n#endif\nvoid* Jsi_Realloc(void *m,unsigned int size) {\n    void *v = realloc(m,size);\n    Assert(v);\n    return v;\n}\nvoid* Jsi_Malloc(unsigned int size) {\n    void *v = malloc(size);\n    Assert(v);\n    return v;\n}\nvoid* Jsi_Calloc(unsigned int n,unsigned int size) {\n    void *v = calloc(n,size);\n    Assert(v);\n    return v;\n}\nvoid  Jsi_Free(void *n) { Assert(n); free(n); }\n\n#if JSI__SANITIZE\n#define Jsi_Malloc(sz) malloc(sz)\n#define Jsi_Calloc(nm, sz) calloc(nm,sz)\n#define Jsi_Realloc(ptr, sz) realloc(ptr,sz)\n#define Jsi_Free(ptr) free(ptr)\n#endif\n\nstatic const char *jsi_LogCodes[] = { \"bug\", \"error\", \"warn\", \"info\", \"unused\", \"parse\", \"test\", \"debug\", \"trace\", 0 };\njsi_IntData jsiIntData = {};\n\n#ifdef JSI_LITE_ONLY\nJsi_RC Jsi_LogMsg(Jsi_Interp *interp, uint code, const char *format,...) {\n    va_list va;\n    va_start (va, format);\n    const char *mt = (code <= JSI__LOGLAST ? jsi_LogCodes[code] : \"\");\n    fputs(mt, stderr);\n    vfprintf(stderr, format, va);\n    fputs(\"\\n\", stderr);\n    va_end(va);\n    return JSI_ERROR;\n}\n\n#else // JSI_LITE_ONLY\n\nint jsi_fatalexit = JSI_LOG_BUG;\nconst char *jsi_GetCurFile(Jsi_Interp *interp)\n{\n    const char *curFile = NULL;\n    if (!interp)\n        return NULL;\n    if (interp->inParse)\n        curFile = interp->curFile;\n    else\n        curFile = (interp->curIp && interp->curIp->fname? interp->curIp->fname:interp->curFile);\n    if (!curFile) curFile = interp->framePtr->fileName;\n    if (!curFile) curFile = \"\";\n    return curFile;\n}\nextern void jsi_TypeMismatch(Jsi_Interp* interp)\n{\n    interp->typeMismatchCnt++;\n    if (interp->typeWarnMax<=0)\n        return;\n    if (interp->typeMismatchCnt>=interp->typeWarnMax) {\n        memset(&interp->typeCheck, 0, sizeof(interp->typeCheck));\n        Jsi_LogWarn(\"Max warnings exceeded %d: typeCheck disabled\", interp->typeWarnMax);\n    }\n}\n\nstatic bool jsi_LogEnabled(Jsi_Interp *interp, uint code) {\n    if (!interp->activeFunc) return 0;\n    Jsi_CmdSpec *cs = interp->activeFunc->cmdSpec;\n    if (!cs)\n        return 0;\n    if (interp->activeFunc->parentSpec)\n        cs = interp->activeFunc->parentSpec;\n    int cofs = (code - JSI_LOG_TEST);\n    int ac = (cs->flags & (JSI_CMD_LOG_TEST<<cofs));\n    return (ac)!=0;\n}\n\nstatic void (*logHook)(const char *buf, va_list va) = NULL;\n\n// Format message: always returns JSI_ERROR.\nJsi_RC Jsi_LogMsg(Jsi_Interp *interp, uint code, const char *format,...) {\n    if (Jsi_InterpGone(interp))\n        return JSI_ERROR;\n    va_list va;\n    va_start (va, format);\n    char pbuf[JSI_BUFSIZ/8] = \"\";\n    char buf[JSI_BUFSIZ/2];\n    const char *term = \"\", *pterm=pbuf;\n    static char lastMsg[JSI_BUFSIZ/2] = \"\";\n    static int lastCnt = 0;\n    static Jsi_Interp *LastInterp = NULL;\n    Jsi_Interp *lastInterp = LastInterp;\n    const char *emsg = buf, *mt;\n    int islog, line = 0, lofs = 0, noDups=0;\n    bool isHelp = (format[0]=='.' && !Jsi_Strncmp(format, \"...\", 3));\n    Jsi_OptionSpec *oep = interp->parseMsgSpec;\n    const char *pps = \"\", *curFile = \"\";\n    char *ss = interp->lastPushStr;\n    \n    if (interp==NULL)\n        interp = jsiIntData.mainInterp;\n    LastInterp = interp;\n    if (lastInterp != interp)\n        noDups = 1;\n    \n    /* Filter out try/catch (TODO: and non-syntax errors??). */\n    if (interp == NULL) {\n//nullInterp:\n        if (logHook)\n            (*logHook)(format, va);\n        else {\n            vfprintf(stderr, format, va);\n            fputc('\\n', stderr);\n        }\n        va_end(va);\n        return JSI_ERROR;\n    }\n    curFile = jsi_GetCurFile(interp);\n    switch (code) {\n        case JSI_LOG_INFO:  if (!interp->logOpts.Info) goto bail; break;\n        case JSI_LOG_WARN:  if (!interp->logOpts.Warn) goto bail; break;\n        case JSI_LOG_DEBUG: if (!interp->logOpts.Debug && !jsi_LogEnabled(interp, code)) goto bail; break;\n        case JSI_LOG_TRACE: if (!interp->logOpts.Trace && !jsi_LogEnabled(interp, code)) goto bail; break;\n        case JSI_LOG_TEST:  if (!interp->logOpts.Test && !jsi_LogEnabled(interp, code)) goto bail; break;\n        case JSI_LOG_PARSE: break; //if (!interp->parent) goto nullInterp; break;\n        case JSI_LOG_ERROR: {\n            if (!interp->logOpts.Error) goto bail;\n            if ((interp->framePtr->tryDepth - interp->framePtr->withDepth)>0 && interp->inParse<=0 \n                && (!interp->tryList || !(interp->tryList->inCatch|interp->tryList->inFinal))) { \n                /* Should only do the first or traceback? */\n                if (!interp->errMsgBuf[0]) {\n                    vsnprintf(interp->errMsgBuf, sizeof(interp->errMsgBuf), format, va);\n                    //interp->errMsgBuf[sizeof(interp->errMsgBuf)-1] = 0;\n                    interp->errFile =  jsi_GetCurFile(interp);\n                    interp->errLine = (interp->curIp?interp->curIp->Line:0);\n                    emsg = interp->errMsgBuf;\n                }\n                goto done;\n            }\n            interp->logErrorCnt++;\n            break;\n        }\n    }\n    mt = (code <= JSI__LOGLAST ? jsi_LogCodes[code] : \"\");\n    if (isHelp) mt = \"help\";\n    assert((JSI__LOGLAST+2) == (sizeof(jsi_LogCodes)/sizeof(jsi_LogCodes[0])));\n    if (!Jsi_Strchr(format,'\\n')) term = \"\\n\";\n    if (interp->strict && interp->lastParseOpt)\n        ss = (char*)Jsi_ValueToString(interp, interp->lastParseOpt, NULL);\n    if (code != JSI_LOG_INFO && code < JSI_LOG_TEST && interp && ss && ss[0]) {\n        char psbuf[JSI_BUFSIZ/6];\n        if (Jsi_Strchr(ss,'%')) {\n            char *s = ss, *sd = psbuf;\n            int plen=0, llen = sizeof(psbuf)-2;\n            while (*s && plen<llen) {\n                if (*s == '%')\n                    sd[plen++] = '%';\n                sd[plen++] = *s;\n                s++;\n            }\n            sd[plen] = 0;\n            ss = psbuf;\n        }\n        while (*ss && isspace(*ss))\n            ss++;\n        if (*ss && !isHelp)\n            snprintf(pbuf, sizeof(pbuf), \"    (at or near \\\"%s\\\")\\n\", ss);\n    }\n    pbuf[sizeof(pbuf)-1] = 0;\n    if (interp->inParse && interp->parseLine) {\n        line = interp->parseLine->first_line;\n        lofs = interp->parseLine->first_column;\n    } else if (interp->inParse && interp->parsePs) {\n        line = interp->parsePs->lexer->cur_line;\n        lofs = interp->parsePs->lexer->cur_char;\n    } else if (interp->curIp) {\n        if (interp->callerErr && interp->framePtr && interp->framePtr->parent) {\n            jsi_Frame *fptr = interp->framePtr->parent;\n            line = fptr->line;\n            lofs = 0;\n            curFile = fptr->fileName;\n        } else {\n            line = interp->curIp->Line;\n            lofs = interp->curIp->Lofs;\n            if (line<=0)\n                line = interp->framePtr->line;\n        }\n    }\n    islog = (interp->parent && interp->debugOpts.msgCallback && code != JSI_LOG_BUG);\n    Jsi_DString pStr;\n    Jsi_DSInit(&pStr);\n    if (oep) {\n        if (oep->id != JSI_OPTION_CUSTOM || !oep->custom)\n            pps = Jsi_DSPrintf(&pStr, \"for option \\\"%s\\\": \", oep->name);\n        else {\n            Jsi_OptionCustom* cust = Jsi_OptionCustomBuiltin(oep->custom);\n            pps = Jsi_DSPrintf(&pStr, \"for %s option \\\"%s\\\": \", (cust?cust->name:\"\"), oep->name);\n        }\n    }\n    char *cpt;\n    if (curFile && interp->logOpts.ftail && (cpt =Jsi_Strrchr(curFile, '/')) && cpt[1])\n        curFile = cpt+1;\n    if (curFile && curFile[0] && Jsi_Strchr(curFile,'%')==0 && !islog) {\n        if (!interp->subOpts.logColNums)\n            snprintf(buf, sizeof(buf), \"%s:%d: %s: %s%s%s%s\",  curFile, line, mt, pps, format, pterm, term);\n        else\n            snprintf(buf, sizeof(buf), \"%s:%d.%d: %s: %s%s%s%s\",  curFile, line, lofs, pps, mt,format, pterm, term);\n    } else {\n        snprintf(buf, sizeof(buf), \"%s: %s%s%s%s\", mt, pps, format, pterm, term);\n    }\n    Jsi_DSFree(&pStr);\n    buf[sizeof(buf)-1]=0;\n\n    if (logHook)\n        (*logHook)(buf, va);\n    else if (interp->subOpts.logAllowDups)\n        vfprintf(stderr, buf, va);\n    else {\n        char buf1[JSI_BUFSIZ/2];\n        vsnprintf(buf1, sizeof(buf1), buf, va);\n        if (!isHelp && !noDups) {\n            if (buf1[0] && lastCnt && Jsi_Strcmp(buf1, lastMsg)==0) {\n                lastCnt++;\n                goto done;\n            } else if (lastMsg[0] && lastCnt>1 ) {\n                fprintf(stderr, \"REPEAT: Last msg repeated %d times...\\\"\\n\" ,lastCnt);\n            }\n            if (buf1[0] == 0 || (buf1[0] == '.' && buf1[1] == 0))\n                goto done;\n        }\n        lastCnt = 1;\n        Jsi_Strcpy(lastMsg, buf1);\n        if (!islog)\n            Jsi_Puts(interp, jsi_Stderr, buf1, -1);\n            //fputs(buf1, stderr);\n        else {\n            Jsi_DString jStr={}, kStr={};\n            Jsi_DSPrintf(&kStr, \"[%s, \\\"%s\\\", \\\"%s\\\", %d, %d ]\",\n                Jsi_JSONQuote(interp, buf1, -1, &jStr), mt, curFile, line, lofs);\n            if (Jsi_FunctionInvokeJSON(interp->parent, interp->debugOpts.msgCallback, Jsi_DSValue(&kStr), NULL) != JSI_OK)\n                code = 1;\n            Jsi_DSFree(&jStr);\n            Jsi_DSFree(&kStr);\n        }\n    }\ndone:\n    va_end(va);\n    if (interp->debugOpts.hook) {\n        static int inhook = 0;\n        if (!inhook) {\n            inhook = 1;\n            (*interp->debugOpts.hook)(interp, curFile, interp->curIp?interp->curIp->Line:0, interp->level, interp->curFunction, \"DEBUG\", NULL, emsg);\n        }\n        inhook = 0;\n    }\n    if ((code & jsi_fatalexit) && !interp->opts.no_exit)\n        jsi_DoExit(interp, 1);\n    return (code==JSI_LOG_ERROR?JSI_ERROR:JSI_OK);\nbail:\n    va_end(va);\n    return JSI_OK;\n}\n\nconst char* Jsi_KeyAdd(Jsi_Interp *interp, const char *str)\n{\n    Jsi_MapEntry *hPtr;\n    bool isNew;\n    hPtr = Jsi_MapEntryNew(interp->strKeyTbl, str, &isNew);\n    assert(hPtr) ;\n    return (const char*)Jsi_MapKeyGet(hPtr, 0);\n}\n\nconst char* Jsi_KeyLookup(Jsi_Interp *interp, const char *str)\n{\n    Jsi_MapEntry *hPtr;\n    hPtr = Jsi_MapEntryFind(interp->strKeyTbl, str);\n    if (!hPtr) {\n        return NULL;\n    }\n    return (const char*)Jsi_MapKeyGet(hPtr, 0);\n}\n\n\nJsi_Value *Jsi_VarLookup(Jsi_Interp *interp, const char *varname)\n{\n    Jsi_Value *v;\n    v = Jsi_ValueObjLookup(interp, interp->framePtr->incsc, (char*)varname, 0);\n    if (!v)\n        v = jsi_ScopeChainObjLookupUni(interp->framePtr->ingsc, (char*)varname);\n    return v;\n}\n\nstatic char *FindEndB(char *cp) {\n    \n    if (*cp == '\\\"'||*cp == '\\'') {\n        char endc = *cp;\n        cp++;\n        while (*cp && *cp != endc) {\n            if (*cp == '\\\\' && cp[1]) cp++;\n            cp++;\n        }\n        if (*cp == endc)\n            cp++;\n        if (*cp != ']')\n            return NULL;\n        return cp;\n    } else\n        return Jsi_Strchr(cp, ']');\n}\n\n\n/* Lookup \"name\" within object \"inObj\", ie.  \"inObj.name\"  */\nJsi_Value *Jsi_NameLookup2(Jsi_Interp *interp, const char *name, const char *inObj)\n{\n    Jsi_Value *v;\n    if (!name)\n        return NULL;\n    if (!inObj)\n        return Jsi_VarLookup(interp, name);\n    v = Jsi_VarLookup(interp, inObj);\n    if (!v)\n        return NULL;\n    if (Jsi_ValueIsArray(interp, v)) {\n        int n;\n        if (!isdigit(name[0]))\n            return NULL;\n        if (Jsi_GetInt(interp, name, &n, 0) != JSI_OK)\n            return NULL;\n        if (n>=0 && n<(int)v->d.obj->arrCnt)\n            return v->d.obj->arr[n];\n        return NULL;\n    }\n    if (v->vt != JSI_VT_OBJECT || (v->d.obj->ot != JSI_OT_OBJECT && v->d.obj->ot != JSI_OT_FUNCTION))\n        return NULL;\n    return Jsi_ValueObjLookup(interp, v, name, 0);\n}\n\n/* Lookup a name, eg.  \"a[b].c  a.b.c  a[b][c]  a.b[c]  a[\"b\"].c  a[1].c  */\nJsi_Value *Jsi_NameLookup(Jsi_Interp *interp, const char *name)\n{\n    uint cnt = 0, len, isq;\n    char *nam = (char*)name, *cp, *cp2, *ocp, *kstr;\n    //DECL_VALINIT(tv);\n    DECL_VALINIT(nv);\n    DECL_VALINIT(key);\n    Jsi_Value *v = NULL, *nvPtr = &nv;\n    Jsi_Value *kPtr = &key; // Note: a string key so no reset needed.\n    Jsi_DString dStr = {};\n    cp2 = Jsi_Strchr(nam,'[');\n    cp = Jsi_Strchr(nam, '.');\n    if (cp2 && (cp==0 || cp2<cp))\n        cp = cp2;\n    if (!cp)\n        return Jsi_VarLookup(interp, nam);\n    //fprintf(stderr, \"NAM: %s\\n\", nam);\n    Jsi_DSSetLength(&dStr, 0);\n    Jsi_DSAppendLen(&dStr, nam, cp-nam);\n    v = Jsi_VarLookup(interp, Jsi_DSValue(&dStr));\n    if (!v)\n        goto bail;\n    while (v && cnt++ < 1000) {\n        ocp = cp;\n        nam = cp+1;\n        isq = 0;\n        if (*cp == '[') {\n            cp = FindEndB(cp+1); /* handle [] in strings. */\n            if (!cp) goto bail;\n            len = cp-nam;\n            cp++;\n            if (len>=2 && ((nam[0] == '\\\"' && nam[len-1] == '\\\"') || (nam[0] == '\\'' && nam[len-1] == '\\''))) {\n                nam += 1;\n                len -= 2;\n                isq = 1;\n            }\n        } else if (*cp == '.') {\n            cp2 = Jsi_Strchr(nam,'[');\n            cp = Jsi_Strchr(nam, '.');\n            if (cp2 && (cp==0 || cp2<cp))\n                cp = cp2;\n            len = (cp ? (uint)(cp-nam) : Jsi_Strlen(nam));\n        } else {\n            goto bail;\n        }\n        Jsi_DSSetLength(&dStr, 0);\n        Jsi_DSAppendLen(&dStr, nam, len);\n        kstr = Jsi_DSValue(&dStr);\n        if (*ocp == '[' && isq == 0 && isdigit(kstr[0]) && Jsi_ValueIsArray(interp, v)) {\n            int nn;\n            if (Jsi_GetInt(interp, kstr, &nn, 0) != JSI_OK)\n                goto bail;\n            v = Jsi_ValueArrayIndex(interp, v, nn);\n            if (!v)\n                goto bail;\n        } else if (*ocp == '[' && isq == 0) {\n            Jsi_Value *kv = Jsi_VarLookup(interp, kstr);\n            if (!kv)\n                goto bail;\n            v = jsi_ValueSubscript(interp, v, kv, &nvPtr);\n            goto keyon;\n        } else {\n            Jsi_ValueMakeStringKey(interp, &kPtr, kstr);\n            v = jsi_ValueSubscript(interp, v, kPtr, &nvPtr);\nkeyon:\n            if (!v)\n                goto bail;\n        }\n        if (cp == 0 || *cp == 0) break;\n    }\n    //Jsi_ValueReset(interp, &ret);\n    Jsi_DSFree(&dStr);\n    if (v && v == nvPtr) {\n        v = Jsi_ValueNew(interp);\n        //Jsi_ValueMove(interp, v, &tv);\n#ifdef JSI_MEM_DEBUG\n        memcpy(v, &nv, sizeof(nv)-sizeof(nv.VD));\n        v->VD.label3 = nv.VD.func;\n        if (interp->memDebug>1)\n            v->VD.label2 = Jsi_KeyAdd(interp, name);\n#else\n        *v = nv;\n#endif\n    }\n    return v;\nbail:\n    Jsi_DSFree(&dStr);\n    return NULL;\n}\n\nJsi_Value *jsi_GlobalContext(Jsi_Interp *interp)\n{\n    return interp->csc;\n}\n\ntypedef struct {\n    Jsi_DString *dStr;\n    int quote; /* Set to JSI_OUTPUT_JSON, etc*/\n    int depth;\n} objwalker;\n\nbool Jsi_StrIsAlnum(const char *cp)\n{\n    if (!cp || !*cp) return 0;\n    while (*cp)\n        if (isalnum(*cp) || *cp == '_')\n            cp++;\n        else\n            return 0;\n    return 1;\n}\n\n/* Modify Sql to append bind fields for Object */\nJsi_RC Jsi_SqlObjBinds(Jsi_Interp* interp, Jsi_DString* zStr, const char *varName, bool addTypes, bool addDefaults, bool nullDefaults) {\n    Jsi_Value *v, *vnPtr = Jsi_VarLookup(interp, varName);\n    if (!vnPtr || !Jsi_ValueIsObjType(interp, vnPtr, JSI_OT_OBJECT))\n        return Jsi_LogError(\"varName must be an Object: %s\", varName);\n    char *cp, *zSql = Jsi_DSValue(zStr);\n    int create = !Jsi_Strncasecmp(zSql,\"create\",6);\n    int insert = !Jsi_Strncasecmp(zSql,\"insert\",6);\n    if (!create && !insert) return JSI_OK;\n    const char *cPtr = Jsi_Strstr(zSql, \" %s\");\n    if (!cPtr) cPtr = Jsi_Strstr(zSql, \"\\t%s\");\n    if (!cPtr)\n        return Jsi_LogError(\"Object varName must contain a ' %%s': %s\", varName);\n    Jsi_DString sStr = {}, vStr = {}, jStr = {};\n    Jsi_DSAppendLen(&sStr, zSql, cPtr?(cPtr-zSql):-1);\n    Jsi_DSAppend(&sStr, \" (\", NULL);\n\n    Jsi_IterObj *io = Jsi_IterObjNew(interp, NULL);\n    Jsi_IterGetKeys(interp, vnPtr, io, 0);\n    uint i;\n    const char *pre = \"\", *kstr;\n    if (!create)\n        Jsi_DSAppend(&vStr, \" VALUES(\", NULL);\n    for (i=0; i<io->count; i++) {\n        kstr = io->keys[i];\n        const char *qs = \"\", *qe = \"\";\n        if (!Jsi_StrIsAlnum(kstr) || Jsi_IsReserved(interp, kstr, 1)) {\n            qe = qs = \"'\";\n        }\n        Jsi_DSAppend(&sStr, pre, qs, kstr, qe, NULL);\n        if (create) {\n            const char *typ = NULL, *dflt=(nullDefaults?\"NULL\":NULL);\n            if (addTypes && ((v = Jsi_ValueObjLookup(interp, vnPtr, kstr, 1)))) {\n                if (Jsi_ValueIsBoolean(interp, v)) {\n                    typ = \"BOOLEAN\";\n                    if (!nullDefaults && addDefaults) {\n                        bool bv = 0;\n                        Jsi_ValueGetBoolean(interp, v, &bv);\n                        dflt = (bv?\"1\":\"0\");\n                    }\n                } else if (Jsi_ValueIsNumber(interp, v)) {\n                    typ = \"NUMERIC\";\n                    if (!Jsi_Strcmp(kstr,\"rowid\"))\n                        typ = \"INTEGER PRIMARY KEY\";\n                    else if (!nullDefaults && addDefaults) {\n                        Jsi_Number nv = 0;\n                        Jsi_DSFree(&jStr);\n                        Jsi_ValueGetNumber(interp, v, &nv);\n                        dflt = Jsi_DSPrintf(&jStr, \"%\" JSI_NUMGFMT, nv);\n                    }\n                } else if (Jsi_ValueIsArray(interp, v) || Jsi_ValueIsObjType(interp, v, JSI_OT_OBJECT)) {\n                    typ = \"CHARJSON\";\n                    if (!nullDefaults && addDefaults) {\n                        Jsi_DSFree(&jStr);\n                        Jsi_DSAppend(&jStr, \"'\", NULL);\n                        Jsi_ValueGetDString(interp, v, &jStr, JSI_OUTPUT_JSON|JSI_JSON_STRICT);\n                        Jsi_DSAppend(&jStr, \"'\", NULL);\n                        dflt = Jsi_DSValue(&jStr);\n                    }\n                } else {\n                    typ = \"TEXT\";\n                    if (!nullDefaults && addDefaults) {\n                        if ((cp=Jsi_ValueString(interp, v, NULL))) {\n                            Jsi_DSFree(&jStr);\n                            dflt = Jsi_DSAppend(&jStr, \"'\", cp, \"'\", NULL);\n                        } else\n                        dflt = \"NULL\";\n                    }\n                }\n            }\n            if (typ)\n                Jsi_DSAppend(&sStr, \" \", typ, (dflt?\" DEFAULT \":\"\"), dflt, NULL);\n        } else {\n            Jsi_DSAppend(&vStr, pre, \"$\", varName, \"(\", kstr, \")\", NULL);\n        }\n        pre = \",\";\n    }\n    if (!create)\n        Jsi_DSAppend(&vStr, \")\", NULL);\n    Jsi_IterObjFree(io);\n    Jsi_DSAppend(&sStr, \") \", Jsi_DSValue(&vStr), cPtr+3, NULL);\n    Jsi_DSFree(zStr);\n    Jsi_DSAppend(zStr, Jsi_DSValue(&sStr), NULL);\n    Jsi_DSFree(&sStr); Jsi_DSFree(&vStr); Jsi_DSFree(&jStr);\n    return JSI_OK;\n}\n\nchar *jsi_TrimStr(char *str) {\n    while (isspace(*str)) str++;\n    if (!str) return str;\n    int len = Jsi_Strlen(str);\n    while (--len>=0 && isspace(str[len]))\n        str[len] = 0;\n    return str;\n}\n\nstatic Jsi_RC jsiValueGetString(Jsi_Interp *interp, Jsi_Value* v, Jsi_DString *dStr, objwalker *owPtr);\n\nstatic Jsi_RC _object_get_callback(Jsi_Tree *tree, Jsi_TreeEntry *hPtr, void *data)\n{\n    Jsi_Value *v;\n    objwalker *ow = (objwalker *)data;\n    Jsi_DString *dStr = ow->dStr;\n    int len;\n    char *str;\n    if ((hPtr->f.bits.dontenum))\n        return JSI_OK;\n    v =(Jsi_Value*) Jsi_TreeValueGet(hPtr);\n    if ((ow->quote&JSI_OUTPUT_JSON) && v && v->vt == JSI_VT_UNDEF)\n        return JSI_OK;\n    str = (char*)Jsi_TreeKeyGet(hPtr);\n    char *cp = Jsi_DSValue(dStr);\n    len = Jsi_DSLength(dStr);\n    if (len>=2 && (cp[len-2] != '{' || cp[len-1] == '}'))\n        Jsi_DSAppend(dStr, \", \", NULL);\n    if (((ow->quote&JSI_OUTPUT_JSON) == 0 || (ow->quote&JSI_JSON_STRICT) == 0) && Jsi_StrIsAlnum(str)\n        && !Jsi_HashEntryFind(tree->opts.interp->lexkeyTbl, str))\n        Jsi_DSAppend(dStr, str, NULL);\n    else\n        /* JSON/spaces, etc requires quoting the name. */\n        Jsi_DSAppend(dStr, \"\\\"\", str, \"\\\"\", NULL);\n    Jsi_DSAppend(dStr, \":\", NULL);\n    ow->depth++;\n    Jsi_RC rc = jsiValueGetString(tree->opts.interp, v, dStr, ow);\n    ow->depth--;\n    return rc;\n}\n\n/* Format value into dStr.  Toplevel caller does init/free. */\nstatic Jsi_RC jsiValueGetString(Jsi_Interp *interp, Jsi_Value* v, Jsi_DString *dStr, objwalker *owPtr)\n{\n    char buf[100], *str;\n    Jsi_DString eStr;\n    Jsi_DSInit(&eStr);\n    if (interp->maxDepth>0 && owPtr->depth > interp->maxDepth)\n        return Jsi_LogError(\"recursive ToString\");\n    int quote = owPtr->quote;\n    int isjson = owPtr->quote&JSI_OUTPUT_JSON;\n    Jsi_Number num;\n    switch(v->vt) {\n        case JSI_VT_UNDEF:\n            Jsi_DSAppend(dStr, \"undefined\", NULL);\n            return JSI_OK;\n        case JSI_VT_NULL:\n            Jsi_DSAppend(dStr, \"null\", NULL);\n            return JSI_OK;\n        case JSI_VT_VARIABLE:\n            Jsi_DSAppend(dStr, \"variable\", NULL);\n            return JSI_OK;\n        case JSI_VT_BOOL:\n            Jsi_DSAppend(dStr, (v->d.val ? \"true\":\"false\"), NULL);\n            return JSI_OK;\n        case JSI_VT_NUMBER:\n            num = v->d.num;\noutnum:\n            if (isjson && !Jsi_NumberIsNormal(num)) {\n                Jsi_DSAppend(dStr, \"null\", NULL);\n            } else if (Jsi_NumberIsInteger(num)) {\n                Jsi_NumberItoA10((Jsi_Wide)num, buf, sizeof(buf));\n                Jsi_DSAppend(dStr, buf, NULL);\n            } else if (Jsi_NumberIsWide(num)) {\n                snprintf(buf, sizeof(buf), \"%\" PRId64, (Jsi_Wide)num);\n                Jsi_DSAppend(dStr, buf, NULL);\n            } else if (Jsi_NumberIsNormal(num) || Jsi_NumberIsSubnormal(num)) {\n                Jsi_NumberDtoA(interp, num, buf, sizeof(buf), 0);\n                Jsi_DSAppend(dStr, buf, NULL);\n            } else if (Jsi_NumberIsNaN(num)) {\n                Jsi_DSAppend(dStr, \"NaN\", NULL);\n            } else {\n                int s = Jsi_NumberIsInfinity(num);\n                if (s > 0) Jsi_DSAppend(dStr, \"+Infinity\", NULL);\n                else if (s < 0) Jsi_DSAppend(dStr, \"-Infinity\", NULL);\n                else Jsi_LogBug(\"Ieee function problem: %d\", fpclassify(num));\n            }\n            return JSI_OK;\n        case JSI_VT_STRING:\n            str = v->d.s.str;\noutstr:\n            if (!quote) {\n                Jsi_DSAppend(dStr, str, NULL);\n                return JSI_OK;\n            }\n            Jsi_DSAppend(dStr,\"\\\"\", NULL);\n            while (*str) {\n                if ((*str == '\\'' && (!isjson)) || *str == '\\\\'|| *str == '\\\"'|| (*str == '\\n'\n                    && (!(owPtr->quote&JSI_OUTPUT_NEWLINES)))\n                    || *str == '\\r' || *str == '\\t' || *str == '\\f' || *str == '\\b'  ) {\n                    char pcp[2];\n                    *pcp = *str;\n                    pcp[1] = 0;\n                    Jsi_DSAppendLen(dStr,\"\\\\\", 1);\n                    switch (*str) {\n                        case '\\r': *pcp = 'r'; break;\n                        case '\\n': *pcp = 'n'; break;\n                        case '\\t': *pcp = 't'; break;\n                        case '\\f': *pcp = 'f'; break;\n                        case '\\b': *pcp = 'b'; break;\n                    }\n                    Jsi_DSAppendLen(dStr,pcp, 1);\n                } else if (isprint(*str) || !isjson)\n                    Jsi_DSAppendLen(dStr,str, 1);\n                else {\n                    char ubuf[10];\n                    int l = Jsi_UtfEncode(str, ubuf);\n                    Jsi_DSAppend(dStr,ubuf, NULL);\n                    str += l-1;\n                }\n                str++;\n            }\n            Jsi_DSAppend(dStr,\"\\\"\", NULL);\n            Jsi_DSFree(&eStr);\n            return JSI_OK;\n        case JSI_VT_OBJECT: {\n            Jsi_Obj *o = v->d.obj;\n            switch(o->ot) {\n                case JSI_OT_BOOL:\n                    Jsi_DSAppend(dStr, (o->d.val ? \"true\":\"false\"), NULL);\n                    return JSI_OK;\n                case JSI_OT_NUMBER:\n                    num = o->d.num;\n                    goto outnum;\n                    return JSI_OK;\n                case JSI_OT_STRING:\n                    str = o->d.s.str;\n                    goto outstr;\n                case JSI_OT_FUNCTION:\n                    Jsi_FuncObjToString(interp, o->d.fobj->func, &eStr, 3 | ((owPtr->depth==0 && owPtr->quote)?8:0));\n                    str = Jsi_DSValue(&eStr);\n                    goto outstr;\n                case JSI_OT_REGEXP:\n                    str = o->d.robj->pattern;\n                    goto outstr;\n                case JSI_OT_USEROBJ:\n                    jsi_UserObjToName(interp, o->d.uobj, &eStr);\n                    str = Jsi_DSValue(&eStr);\n                    goto outstr;\n                case JSI_OT_ITER:\n                    Jsi_DSAppend(dStr, (isjson?\"null\":\"*ITER*\"), NULL);\n                    return JSI_OK;\n                default:\n                    break;\n            }\n                        \n            if (o->isarrlist)\n            {\n                Jsi_Value *nv;\n                int i, len = o->arrCnt;\n                \n                if (!o->arr)\n                    len = Jsi_ValueGetLength(interp, v);\n                Jsi_DSAppend(dStr,\"[\",len?\" \":\"\", NULL);\n                for (i = 0; i < len; ++i) {\n                    nv = Jsi_ValueArrayIndex(interp, v, i);\n                    if (i) Jsi_DSAppend(dStr,\", \", NULL);\n                    owPtr->depth++;\n                    if (nv) {\n                        if (jsiValueGetString(interp, nv, dStr, owPtr) != JSI_OK) {\n                            owPtr->depth--;\n                            return JSI_ERROR;\n                        }\n                    }\n                    else Jsi_DSAppend(dStr, \"undefined\", NULL);\n                    owPtr->depth--;\n                }\n                Jsi_DSAppend(dStr,len?\" \":\"\",\"]\", NULL);\n            } else {\n                int len = Jsi_TreeSize(o->tree);\n                Jsi_DSAppend(dStr,\"{\",len?\" \":\"\", NULL);\n                owPtr->depth++;\n                Jsi_TreeWalk(o->tree, _object_get_callback, owPtr, 0);\n                owPtr->depth--;\n                Jsi_DSAppend(dStr,len?\" \":\"\",\"}\", NULL);\n            }\n            return JSI_OK;\n        }\n#ifndef __cplusplus\n        default:\n            Jsi_LogBug(\"Unexpected value type: %d\", v->vt);\n#endif\n    }\n    return JSI_OK;\n}\n\n/* Format value into dStr.  Toplevel caller does init/free. */\nconst char* Jsi_ValueGetDString(Jsi_Interp *interp, Jsi_Value* v, Jsi_DString *dStr, int quote)\n{\n    objwalker ow;\n    ow.quote = quote;\n    ow.depth = 0;\n    ow.dStr = dStr;\n    jsiValueGetString(interp, v, dStr, &ow);\n    return Jsi_DSValue(dStr);\n}\n\nchar* jsi_KeyFind(Jsi_Interp *interp, const char *str, int nocreate, int *isKey)\n{\n    Jsi_MapEntry *hPtr;\n    if (isKey) *isKey = 0;\n    if (!nocreate) {\n        *isKey = 1;\n         if (isKey) *isKey = 1;\n        return (char*)Jsi_KeyAdd(interp, str);\n    }\n    hPtr = Jsi_MapEntryFind(interp->strKeyTbl, str);\n    if (!hPtr) {\n        return Jsi_Strdup(str);;\n    }\n    if (isKey) *isKey = 1;\n    *isKey = 1;\n    return (char*)Jsi_MapKeyGet(hPtr, 0);\n}\n\nbool jsi_StrIsBalanced(char *str) {\n    int cnt = 0, quote = 0;\n    char *cp = str;\n    while (*cp) {\n        switch (*cp) {\n        case '\\\\':\n            cp++;\n            break;\n        case '{': case '(': case '[':\n            cnt++;\n            break;\n        case '\\'': case '\\\"':\n            quote++;\n            break;\n        case '}': case ')': case ']':\n            cnt--;\n            break;\n        }\n        if (*cp == 0)\n            break;\n        cp++;\n    }\n    return ((quote%2) == 0 && cnt <= 0);\n}\n\nstatic char *get_inputline(Jsi_Interp *interp, int istty, const char *prompt)\n{\n    char *res;\n#ifdef JSI_HAS_READLINE\n    if (istty && interp->subOpts.noReadline==0) {\n        res = jsi_sh_readline(prompt);\n        if (res && *res) jsi_sh_add_history(res);\n        return res;\n    }\n#endif\n    int done = 0;\n    char bbuf[JSI_BUFSIZ];\n    Jsi_DString dStr = {};\n    if (istty)\n        fputs(prompt, stdout);\n    fflush(stdout);\n    while (!done) { /* Read a line. */\n        bbuf[0] = 0;\n        if (fgets(bbuf, sizeof(bbuf), stdin) == NULL)\n            return NULL;\n        Jsi_DSAppend(&dStr, bbuf, NULL);\n        if (Jsi_Strlen(bbuf) < (sizeof(bbuf)-1) || bbuf[sizeof(bbuf)-1] == '\\n')\n            break;\n    }\n    res = Jsi_Strdup(Jsi_DSValue(&dStr));\n    Jsi_DSFree(&dStr);\n    return res;\n}\n\nstatic Jsi_Interp* jsi_interactiveInterp = NULL;\n#ifdef JSI_HAS_READLINE\nstatic Jsi_Value *completeValues = NULL;\n\n#ifdef USE_GNU_READLINE\nstatic int jsiRlStart = 0;\n\nstatic char *jsiRlCmdMatches(const char *text, int state) {\n    static int idx, len;\n    const char *name;\n    Jsi_Interp* interp = jsi_interactiveInterp;\n    if (completeValues == NULL || !Jsi_ValueIsArray(interp, completeValues))\n        return NULL;\n    Jsi_Value **arr = completeValues->d.obj->arr;\n    int aLen = completeValues->d.obj->arrCnt;\n\n    if (!state)\n    {\n        idx = 0;\n        len = Jsi_Strlen(text)-jsiRlStart;\n    }\n    while (idx<aLen)\n    {\n        name = Jsi_ValueString(interp, arr[idx], NULL);\n        if (!name) name = \"\";\n        idx++;\n        if (Jsi_Strncmp(name, text+jsiRlStart, len) == 0)\n            return (Jsi_Strdup(name));\n    }\n    return NULL;\n}\n\nstatic char **jsiRlGetMatches(const char *cstr, int start, int end) {\n    char **matches = NULL;\n    char *str = rl_line_buffer;\n    jsiRlStart = start;\n    if (1 || start == 0 || !completeValues) {\n        int rc;\n        Jsi_Interp* interp = jsi_interactiveInterp;\n        if (!completeValues)\n            completeValues = Jsi_ValueNew1(interp);\n        Jsi_Value *func = interp->onComplete;\n        if (func == NULL || !Jsi_ValueIsFunction(interp, func))\n            func = Jsi_NameLookup(interp, \"Info.completions\");\n        if (func && Jsi_ValueIsFunction(interp, func)) {\n            Jsi_Value *items[3] = {};\n            items[0] = Jsi_ValueNewStringDup(interp, str);\n            items[1] = Jsi_ValueNewNumber(interp, (Jsi_Number)start);\n            items[2] = Jsi_ValueNewNumber(interp, (Jsi_Number)end);;\n            Jsi_Value *args = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, 3, 0));\n            Jsi_IncrRefCount(interp, args);\n            rc = Jsi_FunctionInvoke(interp, func, args, &completeValues, interp->csc);\n            Jsi_DecrRefCount(interp, args);\n            if (rc != JSI_OK)\n                fprintf(stderr, \"bad completion: %s %d %d\\n\", str?str:\"\", start, end);\n        }\n        matches = rl_completion_matches(str, jsiRlCmdMatches);\n    }\n    return matches;\n}\n#else\nstatic const char *jsiFilePreCmds[] = {\n    \"File.\", \"source\", \"load\", \"new Channel\", \"new Sqlite\", NULL\n};\n\nchar *jsiLNhints(const char *buf, int *color, int *bold) {\n    int i, len = Jsi_Strlen(buf);\n    for (i=0; jsiFilePreCmds[i]; i++)\n        if (!Jsi_Strncmp(buf, jsiFilePreCmds[i], Jsi_Strlen(jsiFilePreCmds[i]))) break;\n    if (jsiFilePreCmds[i]) {\n        const char *ce = buf+len-1, *cp = \"('<file>\";\n        if ((*ce =='\\'' || *ce =='\\\"') && buf[len-2]=='(') cp+=2;\n        else if (*ce=='(') cp++;\n        else return NULL;\n        \n        *color = 35;\n        *bold = 0;\n        return (char*)cp;\n    }\n    return NULL;\n}\n\nstatic void jsiLNGetMatches(const char *str, linenoiseCompletions *lc) {\n    char buf[1000], pre[1000], hpre[6] = {};\n    const char *cp, *fnam = \"Info.completions\";\n    int i = 0, len;\n    int rc, isfile = 0, start = 0, end = Jsi_Strlen(str);\n    Jsi_Interp* interp = jsi_interactiveInterp;\n    if (!Jsi_Strncmp(str, \"help \", 5)) {\n        Jsi_Strcpy(hpre, \"help \");\n        str += 5;\n        end -= 5;\n    }\n    if (end<=0) return;\n    Jsi_Strncpy(buf, str, sizeof(buf)-1);\n    buf[sizeof(buf)-1] = 0;\n    pre[0] = 0;\n    if (end<=3 && !Jsi_Strncmp(str, \"help\", end)) {\n        linenoiseAddCompletion(lc, \"help\");\n        return;\n    }\n    if (!completeValues)\n        completeValues = Jsi_ValueNew1(interp);\n    Jsi_Value *func = interp->onComplete;\n    if (func == NULL || !Jsi_ValueIsFunction(interp, func)) {\n        for (i=0; jsiFilePreCmds[i]; i++)\n            if (!Jsi_Strncmp(buf, jsiFilePreCmds[i], Jsi_Strlen(jsiFilePreCmds[i]))) break;\n        if (jsiFilePreCmds[i] && ((cp=Jsi_Strrchr(buf, '(')) && (cp[1]=='\\\"' || cp[1]=='\\''))) {\n            Jsi_Strcpy(pre, buf);\n            pre[cp-buf+2] = 0;\n            snprintf(buf, sizeof(buf), \"%s*%s\", cp+2, (buf[0]=='s'?\".js*\":\"\"));\n            isfile = 1;\n            fnam = \"File.glob\";\n        }\n    }\n    func = Jsi_NameLookup(interp, fnam);\n    if (func && Jsi_ValueIsFunction(interp, func)) {\n        //printf(\"PATTERN: %s\\n\", str);\n        Jsi_Value *items[3] = {};;\n        i = 0;\n        items[i++] = Jsi_ValueNewStringDup(interp, buf);\n        if (!isfile) {\n            items[i++] = Jsi_ValueNewNumber(interp, (Jsi_Number)start);\n            items[i++] = Jsi_ValueNewNumber(interp, (Jsi_Number)end);\n        }\n        Jsi_Value *args = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, i, 0));\n        Jsi_IncrRefCount(interp, args);\n        rc = Jsi_FunctionInvoke(interp, func, args, &completeValues, interp->csc);\n        Jsi_DecrRefCount(interp, args);\n        if (rc != JSI_OK) {\n            fprintf(stderr, \"bad completion: %s %d %d\\n\", str?str:\"\", start, end);\n            return;\n        }\n        const char *name;\n        Jsi_Interp* interp = jsi_interactiveInterp;\n        if (completeValues == NULL || !Jsi_ValueIsArray(interp, completeValues))\n            return;\n        Jsi_Value **arr = completeValues->d.obj->arr;\n        int aLen = completeValues->d.obj->arrCnt;\n        i = 0;\n        while (i<aLen)\n        {\n            name = Jsi_ValueString(interp, arr[i], &len);\n            if (name) {\n                if (!pre[0] && !hpre[0])\n                    linenoiseAddCompletion(lc, name);\n                else {\n                    snprintf(buf, sizeof(buf), \"%s%s%s\", hpre, pre, name);\n                    linenoiseAddCompletion(lc, buf);\n                }\n            }\n            i++;\n        }\n    }\n}\n#endif\n#endif\n#if JSI__SIGNAL\n#include <signal.h> //  our new library \n#endif\n\n#if JSI__SIGNAL\nstatic void jsi_InteractiveSignal(int sig){\n    if (jsi_interactiveInterp)\n        jsi_interactiveInterp->interrupted = 1;\n}\n#endif\n \n/* Collect and execute code from stdin.  The first byte of flags are passed to Jsi_ValueGetDString(). */\nJsi_RC Jsi_Interactive(Jsi_Interp* interp, int flags) \n{\n    Jsi_RC rc = JSI_OK;\n    int done = 0, len, quote = (flags & 0xff), istty = 1, chkHelp=0, hasHelp=0;\n    const char *prompt = interp->subOpts.prompt;\n    char *buf;\n    if (jsi_interactiveInterp) \n        return Jsi_LogError(\"multiple interactive not supported\");\n#if JSI__SIGNAL\n  signal(SIGINT, jsi_InteractiveSignal); \n#endif\n    interp->typeCheck.parse = interp->typeCheck.run = interp->typeCheck.all = 1;\n    interp->strict = 1;\n    interp->isInteractive = 1;\n    jsi_interactiveInterp = interp;\n    interp->subOpts.istty = 1;\n    interp->subOpts.logAllowDups = 1;\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n#ifndef __WIN32\n    istty = isatty(fileno(stdin));\n#else\n    istty = _isatty(_fileno(stdin));\n#endif\n#ifdef JSI_HAS_READLINE\n    Jsi_DString dHist = {}, sHist = {};\n    char *hist = NULL;\n#ifdef USE_GNU_READLINE\n    rl_attempted_completion_function = jsiRlGetMatches;\n#else\n    linenoiseSetCompletionCallback(jsiLNGetMatches);\n    linenoiseSetHintsCallback(jsiLNhints);\n#endif\n    if(interp->subOpts.noReadline == 0 && !interp->parent && !(interp->isSafe && interp->safeMode==jsi_safe_Lockdown))\n    {\n        const char *hfile = (interp->historyFile ? interp->historyFile : \"~/.jsish_history\");\n        hist = Jsi_NormalPath(interp, hfile, &dHist);\n        if (hist)\n            jsi_sh_read_history(hist);\n    }\n#endif\n    interp->level++;\n    if (!interp->iskips)\n        puts(\"Jsish interactive: see 'help [cmd]' or 'history'.  \\\\ cancels > input.\"\n#if JSI__SIGNAL\n        \"  ctrl-c aborts running script.\"\n#endif\n        );\n    while (done==0 && interp->exited==0) {\n        buf = get_inputline(interp, istty, (prompt?prompt:\"$ \"));\n        if (buf) {\n            if (buf[0] == '\\\\' && !buf[1]) {\n                 Jsi_DSSetLength(&dStr, 0);\n                 prompt = interp->subOpts.prompt;\n                 fprintf(stderr, \"abandoned input\");\n            } else\n                Jsi_DSAppend(&dStr, buf, NULL);\n            free(buf);\n        } else {\n            done = 1;\n        }\n        len = Jsi_DSLength(&dStr);\n        if (done && len == 0)\n            break;\n        if (!len) continue;\n        Jsi_DSAppendLen(&dStr, \" \", 1); // Allow for added space.\n        buf = Jsi_DSValue(&dStr);\n        if (done == 0 && (!jsi_StrIsBalanced(buf))) {\n            prompt = interp->subOpts.prompt2;\n            continue;\n        }\n        prompt = interp->subOpts.prompt;\n        while ((len = Jsi_Strlen(buf))>0 && (isspace(buf[len-1])))\n            buf[len-1] = 0;\n        if (buf[0] == 0) {\n            Jsi_DSSetLength(&dStr, 0);\n            continue;\n        }\n        bool wantHelp = 0;\n        if (interp->onEval == NULL) {\n            /* Convenience: add semicolon to \"var\" statements (required by parser). */\n#ifdef JSI_HAS_READLINE\n            if (!Jsi_Strncmp(buf, \"history\", 7) && buf[7] == 0) {\n                fputs(Jsi_DSValue(&sHist), stdout);\n                Jsi_DSSetLength(&dStr, 0);\n                continue;\n            }\n#endif\n            if (!Jsi_Strncmp(buf, \"help\", 4) && (buf[4] == 0 || isspace(buf[4]))) {\n                if (!chkHelp++)\n                    hasHelp = (Jsi_PkgRequire(interp, \"Help\", 0)>=0);\n                if (hasHelp) {\n                    wantHelp = 1;\n                    char tbuf[BUFSIZ];\n                    snprintf(tbuf, sizeof(tbuf), \"return runModule('Help', '%s'.trim().split(null));\", buf+4);\n                    rc = Jsi_EvalString(interp, tbuf, JSI_RETURN);\n                }\n            }\n            if (!wantHelp) {\n                if (!Jsi_Strncmp(buf,\"var \", 4) && Jsi_Strchr(buf, '\\n')==NULL && Jsi_Strchr(buf, ';')==NULL)\n                    Jsi_Strcpy(buf+Jsi_Strlen(buf), \";\"); // Added space above so strcat ok.\n                rc = Jsi_EvalString(interp, buf, JSI_EVAL_RETURN);\n                prompt = interp->subOpts.prompt;\n#ifdef JSI_HAS_READLINE\n                if (rc == JSI_OK)\n                    Jsi_DSAppend(&sHist, buf, \"\\n\", NULL);\n#endif\n            }\n        }\n        else\n        {\n            Jsi_Value *func = interp->onEval;\n            if (func && Jsi_ValueIsFunction(interp, func)) {\n                Jsi_Value *items[1] = {};\n                items[0] = Jsi_ValueNewStringDup(interp, buf);\n                Jsi_Value *args = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, 1, 0));\n                Jsi_IncrRefCount(interp, args);\n                rc = Jsi_FunctionInvoke(interp, func, args, &interp->retValue, interp->csc);\n                Jsi_DecrRefCount(interp, args);\n                if (rc != JSI_OK)\n                    fprintf(stderr, \"bad eval\");\n            }\n        }\n        if (interp->exited)\n            break;\n        jsi_interactiveInterp->interrupted = 0;\n        if (rc == JSI_OK) {\n             if (interp->retValue->vt != JSI_VT_UNDEF || interp->subOpts.outUndef) {\n                Jsi_DString eStr = {};\n                fputs(Jsi_ValueGetDString(interp, interp->retValue, &eStr, hasHelp?0:quote), stdout);\n                Jsi_DSFree(&eStr);\n                fputs(\"\\n\", stdout);\n             }\n        } else if (!interp->exited && !wantHelp) {\n            fputs(\"ERROR\\n\", stderr);\n        }\n        Jsi_DSSetLength(&dStr, 0);\n        len = 0;\n    }\n    interp->level--;\n#ifdef JSI_HAS_READLINE\n    if (hist && !interp->isSafe) {\n        jsi_sh_stifle_history(100);\n        jsi_sh_write_history(hist);\n    }\n    Jsi_DSFree(&dHist);\n    Jsi_DSFree(&sHist);\n#endif\n    Jsi_DSFree(&dStr);\n    if (interp->retValue) {\n        Jsi_DecrRefCount(interp, interp->retValue);\n        interp->retValue = NULL;\n    }\n    if (interp->exited && interp->level <= 0)\n    {\n        rc = JSI_EXIT;\n        Jsi_InterpDelete(interp);\n    }\n    jsi_interactiveInterp = NULL;\n    return rc;\n}\n\nJsi_RC Jsi_ThisDataSet(Jsi_Interp *interp, Jsi_Value *_this, void *value)\n{\n    bool isNew;\n    Jsi_HashEntry *hPtr = Jsi_HashEntryNew(interp->thisTbl, _this, &isNew);\n    if (!hPtr)\n        return JSI_ERROR;\n    Jsi_HashValueSet(hPtr, value);\n    return JSI_OK;\n}\n\nvoid *Jsi_ThisDataGet(Jsi_Interp *interp, Jsi_Value *_this)\n{\n    Jsi_HashEntry *hPtr;\n    hPtr = Jsi_HashEntryFind(interp->thisTbl, _this);\n    if (!hPtr)\n        return NULL;\n    return Jsi_HashValueGet(hPtr);\n}\n\nJsi_RC Jsi_PrototypeDefine(Jsi_Interp *interp, const char *key, Jsi_Value *value)\n{\n    bool isNew;\n    Jsi_HashEntry *hPtr = Jsi_HashEntryNew(interp->protoTbl, key, &isNew);\n    if (!hPtr)\n        return JSI_ERROR;\n    Jsi_HashValueSet(hPtr, value);\n    return JSI_OK;\n}\n\nvoid *Jsi_PrototypeGet(Jsi_Interp *interp, const char *key)\n{\n    Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->protoTbl, key);\n    if (!hPtr)\n        return NULL;\n    return Jsi_HashValueGet(hPtr);\n}\n\nJsi_RC Jsi_PrototypeObjSet(Jsi_Interp *interp, const char *key, Jsi_Obj *obj)\n{\n    Jsi_Value *val;\n    Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->protoTbl, key);\n    if (!hPtr)\n        return JSI_ERROR;\n    val = (Jsi_Value *)Jsi_HashValueGet(hPtr);\n    obj->__proto__ = val;\n    return JSI_OK;\n}\n\nconst char *Jsi_ObjTypeStr(Jsi_Interp *interp, Jsi_Obj *o)\n{\n     switch (o->ot) {\n        case JSI_OT_BOOL: return \"boolean\"; break;\n        case JSI_OT_FUNCTION: return \"function\"; break;\n        case JSI_OT_NUMBER: return \"number\"; break;\n        case JSI_OT_STRING: return \"string\"; break;  \n        case JSI_OT_REGEXP: return \"regexp\"; break;  \n        case JSI_OT_ITER: return \"iter\"; break;  \n        case JSI_OT_OBJECT: if (!o->isarrlist) return \"object\";\n        case JSI_OT_ARRAY: return \"array\"; break;  \n        case JSI_OT_USEROBJ:\n            if (o->__proto__) {\n                Jsi_HashEntry *hPtr;\n                Jsi_HashSearch search;\n                            \n                for (hPtr = Jsi_HashSearchFirst(interp->thisTbl,&search); hPtr != NULL;\n                    hPtr = Jsi_HashSearchNext(&search))\n                    if (Jsi_HashValueGet(hPtr) == o->__proto__)\n                        return (char*)Jsi_HashKeyGet(hPtr);\n            }\n            \n            return \"userobj\";\n            break;\n            //return Jsi_ObjGetType(interp, v->d.obj);\n        default:\n            break;\n     }\n     return \"\";\n}\n\nextern Jsi_otype Jsi_ObjTypeGet(Jsi_Obj *obj)\n{\n    return obj->ot;\n}\n\nconst char *Jsi_ValueTypeStr(Jsi_Interp *interp, Jsi_Value *v)\n{\n    switch (v->vt) {\n        case JSI_VT_BOOL: return \"boolean\"; break;\n        case JSI_VT_UNDEF: return \"undefined\"; break;\n        case JSI_VT_NULL: return \"null\"; break;\n        case JSI_VT_NUMBER: return \"number\"; break;\n        case JSI_VT_STRING: return \"string\"; break;  \n        case JSI_VT_VARIABLE: return \"variable\"; break;  \n        case JSI_VT_OBJECT: return Jsi_ObjTypeStr(interp, v->d.obj);\n    }\n    return \"\";\n}\n\n/* For user defined object  \"name\", invokes \"new\"  with \"arg\" + \"opts\".  Returns userobj data pointer for C use. */\nvoid *Jsi_CommandNewObj(Jsi_Interp *interp, const char *name, const char *arg1, const char *opts, const char *var) {\n    char buf[JSI_BUFSIZ];\n    if (arg1)\n        snprintf(buf, sizeof(buf), \"%s%snew %s('%s', %s);\", var?var:\"\", var?\"=\":\"return \", name, arg1, opts?opts:\"null\");\n    else\n        snprintf(buf, sizeof(buf), \"%s%snew %s(%s);\", var?var:\"\", var?\"=\":\"return \", name, opts?opts:\"null\");\n    int rc = Jsi_EvalString(interp, buf, 0);\n    if (rc != JSI_OK)\n        return NULL;\n    Jsi_Value *vObj = interp->retValue;\n    if (var)\n        vObj = Jsi_NameLookup(interp, var);\n    if (!vObj)\n        return NULL;\n    return Jsi_UserObjGetData(interp, vObj, NULL);\n}\n\n#endif\n\n// List\n\nJsi_List *Jsi_ListNew(Jsi_Interp *interp, Jsi_Wide flags, Jsi_HashDeleteProc *freeProc)\n{\n    Jsi_List *list = (Jsi_List *)Jsi_Calloc(1, sizeof(Jsi_List));\n    list->sig = JSI_SIG_LIST;\n    list->opts.flags = flags;\n    list->opts.freeHashProc = freeProc;\n    list->opts.interp = interp;\n    list->opts.mapType = JSI_MAP_LIST;\n    list->opts.keyType = (Jsi_Key_Type)-1;\n    return list;\n}\n\nJsi_RC Jsi_ListConf(Jsi_List *listPtr, Jsi_MapOpts *opts, bool set)\n{\n    if (set) {\n        listPtr->opts = *opts;\n    } else {\n        *opts = listPtr->opts;\n    }\n    return JSI_OK;\n}\n\nvoid Jsi_ListDelete(Jsi_List *list) {\n    Jsi_ListClear(list);\n    free(list);\n}\n\nvoid Jsi_ListClear(Jsi_List *list) {\n    Jsi_ListEntry *l;\n    while (list->head) {\n        l = list->head;\n        list->head = list->head->next;\n        l->next = l->prev = NULL;\n        if (list->opts.freeListProc && l->value)\n            (list->opts.freeListProc)(list->opts.interp, l, l->value);\n        Jsi_ListEntryDelete(l);\n    }\n    list->numEntries = 0;\n}\n \nJsi_ListEntry* Jsi_ListPush(Jsi_List *list, Jsi_ListEntry *item, Jsi_ListEntry *before)\n{\n    Assert(item && list);\n    if (item->list && (item->list->head == item || item->prev || item->next)) {\n        Assert(list->opts.freeListProc == item->list->opts.freeListProc);\n        Jsi_ListPop(item->list, item);\n    }\n        \n    if (!item->list)\n         item->list = list;\n    else if (list != item->list) {\n        Assert(list->opts.freeListProc == item->list->opts.freeListProc);\n        item->list = list;\n    }\n    if (!list->head) {\n        list->head = list->tail = item;\n    } else if (item == list->head) {\n        assert(0);\n    } else if (before == NULL) {\n        item->prev = list->tail;\n        list->tail->next = item;\n        list->tail = item;\n    } else if (before == list->head) {\n        item->next = list->head;\n        list->head->prev = item;\n        list->head = item;\n    } else {\n        item->next = before;\n        item->prev = before->prev;\n        before->prev->next = item;\n        before->prev = item;\n    }\n    list->numEntries++;\n    item->list = list;\n    return item;\n}\n \nJsi_ListEntry* Jsi_ListPop(Jsi_List *list, Jsi_ListEntry *item)\n{\n    Assert(item && list->head && list->tail && item->list);\n    SIGASSERT(list, LIST);\n    SIGASSERT(item, LISTENTRY);\n    if (item == list->head) {\n        if (list->head == list->tail)\n            list->head = list->tail = NULL;\n        else\n            list->head = list->head->next;\n    }\n    else if (item == list->tail) {\n        list->tail = list->tail->prev;\n        list->tail->next = NULL;\n    } else {\n        item->prev->next = item->next;\n        if (item->next)\n            item->next->prev = item->prev;\n    }\n    list->numEntries--;\n    item->next = item->prev = NULL;\n    return item;\n}\n\nJsi_ListEntry *Jsi_ListEntryNew(Jsi_List* list, const void *value, Jsi_ListEntry *before) {\n    SIGASSERT(list, LIST);\n    Jsi_ListEntry *l = (Jsi_ListEntry*)Jsi_Calloc(1, sizeof(Jsi_ListEntry));\n    l->sig = JSI_SIG_LISTENTRY;\n    l->typ = JSI_MAP_LIST;\n    l->list = list;\n    l->value = (void*)value;\n    Jsi_ListPush(list, l, before);\n    return l;\n}\n\nint Jsi_ListEntryDelete(Jsi_ListEntry *l) {\n    SIGASSERT(l, LISTENTRY);\n    if (l->next || l->prev)\n        Jsi_ListPop(l->list, l);\n    Jsi_Free(l);\n    return 1;\n}\n\nJsi_ListEntry* Jsi_ListSearchFirst (Jsi_List *list, Jsi_ListSearch *searchPtr, int flags)\n{\n    SIGASSERT(list, LIST);\n    searchPtr->flags = flags;\n    Jsi_ListEntry *lptr;\n    if (flags & JSI_LIST_REVERSE) {\n        lptr = Jsi_ListGetBack(list);\n        searchPtr->nextEntryPtr = (lptr?Jsi_ListEntryPrev(lptr):NULL);\n    } else {\n        lptr = Jsi_ListGetFront(list);\n        searchPtr->nextEntryPtr = (lptr?Jsi_ListEntryNext(lptr):NULL);\n    }\n    return lptr;\n}\n\nJsi_ListEntry* Jsi_ListSearchNext (Jsi_ListSearch *searchPtr)\n{\n    Jsi_ListEntry *lptr = searchPtr->nextEntryPtr;\n    searchPtr->nextEntryPtr = (lptr?(searchPtr->flags & JSI_LIST_REVERSE ? Jsi_ListEntryPrev(lptr): Jsi_ListEntryNext(lptr)):NULL);\n    return lptr;\n}\n\n\nuint Jsi_ListSize(Jsi_List *list) {\n    SIGASSERT(list, LIST);\n    return list->numEntries;\n}\n\nvoid* Jsi_ListValueGet(Jsi_ListEntry *l) {\n    SIGASSERT(l, LISTENTRY);\n    return l?l->value:NULL;\n}\nvoid Jsi_ListValueSet(Jsi_ListEntry *l, const void *value) {\n    SIGASSERTV(l, LISTENTRY);\n    l->value = (void*)value;\n}\n\n\n// Map\n\nJsi_Map* Jsi_MapNew (Jsi_Interp *interp, Jsi_Map_Type listType, Jsi_Key_Type keyType, Jsi_MapDeleteProc *freeProc)\n{\n    Jsi_Map *lPtr, lval = {.sig=JSI_SIG_MAP};\n    lval.typ = listType;\n    switch (listType) {\n        case JSI_MAP_HASH: lval.v.hash = Jsi_HashNew(interp, keyType, (Jsi_HashDeleteProc*)freeProc); break;\n        case JSI_MAP_TREE: lval.v.tree = Jsi_TreeNew(interp, keyType, (Jsi_TreeDeleteProc*)freeProc); break;\n        case JSI_MAP_LIST: lval.v.list = Jsi_ListNew(interp, keyType, (Jsi_HashDeleteProc*)freeProc); break;\n        default: return NULL;\n    }\n    if (!lval.v.hash) return NULL;\n    lPtr = (Jsi_Map*)Jsi_Malloc(sizeof(*lPtr));\n    *lPtr = lval;\n    return lPtr;\n}\n\nJsi_RC Jsi_MapConf(Jsi_Map *mapPtr, Jsi_MapOpts *opts, bool set)\n{\n    switch (mapPtr->typ) {\n        case JSI_MAP_HASH: return Jsi_HashConf(mapPtr->v.hash, opts, set);\n        case JSI_MAP_TREE: return Jsi_TreeConf(mapPtr->v.tree, opts, set);\n        case JSI_MAP_LIST: return Jsi_ListConf(mapPtr->v.list, opts, set);\n        case JSI_MAP_NONE: break;\n    }\n    return JSI_ERROR;\n}\n\nvoid Jsi_MapClear (Jsi_Map *mapPtr) {\n    SIGASSERTV(mapPtr, MAP);\n    switch (mapPtr->typ) {\n        case JSI_MAP_HASH: Jsi_HashClear(mapPtr->v.hash); break;\n        case JSI_MAP_TREE: Jsi_TreeClear(mapPtr->v.tree); break;\n        case JSI_MAP_LIST: Jsi_ListClear(mapPtr->v.list); break;\n        default: return;\n    }\n}\n\nvoid Jsi_MapDelete (Jsi_Map *mapPtr) {\n    SIGASSERTV(mapPtr, MAP);\n    switch (mapPtr->typ) {\n        case JSI_MAP_HASH: Jsi_HashDelete(mapPtr->v.hash); break;\n        case JSI_MAP_TREE: Jsi_TreeDelete(mapPtr->v.tree); break;\n        case JSI_MAP_LIST: Jsi_ListDelete(mapPtr->v.list); break;\n        default: return;\n    }\n    Jsi_Free(mapPtr);\n}\nJsi_MapEntry* Jsi_MapSet(Jsi_Map *mapPtr, const void *key, const void *value){\n    SIGASSERT(mapPtr, MAP);\n    Jsi_MapEntry* mptr = NULL;\n    switch (mapPtr->typ) {\n        case JSI_MAP_HASH: mptr = (Jsi_MapEntry*)Jsi_HashSet(mapPtr->v.hash, (void*)key, (void*)value); break;\n        case JSI_MAP_TREE: mptr = (Jsi_MapEntry*)Jsi_TreeSet(mapPtr->v.tree, (void*)key, (void*)value); break;\n        case JSI_MAP_LIST: {\n            mptr = Jsi_MapEntryNew(mapPtr, key, NULL);\n            Jsi_MapValueSet(mptr, (void*)value);\n            break;\n        }\n        case JSI_MAP_NONE: break;\n    }\n    return mptr;\n}\nvoid* Jsi_MapGet(Jsi_Map *mapPtr, const void *key, int flags){\n    SIGASSERT(mapPtr, MAP);\n    switch (mapPtr->typ) {\n        case JSI_MAP_HASH: return Jsi_HashGet(mapPtr->v.hash, (void*)key, flags);\n        case JSI_MAP_TREE: return Jsi_TreeGet(mapPtr->v.tree, (void*)key, flags);\n        case JSI_MAP_LIST: {\n            Jsi_ListEntry* lptr = (key == NULL? Jsi_ListGetFront(mapPtr->v.list) : Jsi_ListGetBack(mapPtr->v.list));\n            if (lptr)\n                return Jsi_ListValueGet(lptr);\n            break;\n        }\n        case JSI_MAP_NONE: break;\n    }\n    return NULL;\n}\nbool Jsi_MapUnset(Jsi_Map *mapPtr, const void *key){\n    SIGASSERT(mapPtr, MAP);\n    switch (mapPtr->typ) {\n        case JSI_MAP_HASH: return Jsi_HashUnset(mapPtr->v.hash, (void*)key);\n        case JSI_MAP_TREE: return Jsi_TreeUnset(mapPtr->v.tree, (void*)key);\n        case JSI_MAP_LIST: {\n            /*Jsi_ListEntry* lptr = (key == NULL? Jsi_ListGetFront(mapPtr->v.list) : Jsi_ListGetBack(mapPtr->v.list));\n            if (lptr)\n                return Jsi_ListUnset(lptr);*/\n            break;\n        }\n        case JSI_MAP_NONE: break;\n    }\n    return false;\n}\nstatic int jsi_GetListType(Jsi_MapEntry *h) {\n    Jsi_HashEntry *hPtr =(Jsi_HashEntry *)h;\n    return hPtr->typ;\n}\nvoid* Jsi_MapKeyGet(Jsi_MapEntry *h, int flags){\n    switch (jsi_GetListType(h)) {\n        case JSI_MAP_HASH: return Jsi_HashKeyGet((Jsi_HashEntry*)h);\n        case JSI_MAP_TREE: return Jsi_TreeKeyGet((Jsi_TreeEntry*)h);\n        case JSI_MAP_LIST: break;\n        case JSI_MAP_NONE: break;\n    }\n    return NULL;\n}\n#ifndef JSI_LITE_ONLY\nJsi_RC Jsi_MapKeysDump(Jsi_Interp *interp, Jsi_Map *mapPtr, Jsi_Value **ret, int flags){\n    SIGASSERT(mapPtr, MAP);\n    switch (mapPtr->typ) {\n        case JSI_MAP_HASH: return Jsi_HashKeysDump(interp, mapPtr->v.hash, ret, flags);\n        case JSI_MAP_TREE: return Jsi_TreeKeysDump(interp, mapPtr->v.tree, ret, flags);\n        case JSI_MAP_LIST: break; // TODO: dump numbers?\n        case JSI_MAP_NONE: break;\n    }\n    return JSI_ERROR;\n}\n#endif\nvoid* Jsi_MapValueGet(Jsi_MapEntry *h){\n    switch (jsi_GetListType(h)) {\n        case JSI_MAP_HASH: return Jsi_HashValueGet((Jsi_HashEntry*)h);\n        case JSI_MAP_TREE: return Jsi_TreeValueGet((Jsi_TreeEntry*)h);\n        case JSI_MAP_LIST: return Jsi_ListValueGet((Jsi_ListEntry*)h);\n        case JSI_MAP_NONE: break;\n    }\n    return NULL;\n}\nvoid Jsi_MapValueSet(Jsi_MapEntry *h, const void *value){\n    switch (jsi_GetListType(h)) {\n        case JSI_MAP_HASH: return Jsi_HashValueSet((Jsi_HashEntry*)h, (void*)value);\n        case JSI_MAP_TREE: return Jsi_TreeValueSet((Jsi_TreeEntry*)h, (void*)value);\n        case JSI_MAP_LIST: return Jsi_ListValueSet((Jsi_ListEntry*)h, (void*)value);\n        case JSI_MAP_NONE: break;\n    }\n}\nJsi_MapEntry* Jsi_MapEntryFind (Jsi_Map *mapPtr, const void *key){\n    SIGASSERT(mapPtr, MAP);\n    switch (mapPtr->typ) {\n        case JSI_MAP_HASH: return (Jsi_MapEntry*)Jsi_HashEntryFind(mapPtr->v.hash, key);\n        case JSI_MAP_TREE: return (Jsi_MapEntry*)Jsi_TreeEntryFind(mapPtr->v.tree, key);\n        case JSI_MAP_LIST:\n            return (Jsi_MapEntry*) (key == NULL? Jsi_ListGetFront(mapPtr->v.list) : Jsi_ListGetBack(mapPtr->v.list));\n        case JSI_MAP_NONE: break;\n    }\n    return NULL;\n}\nJsi_MapEntry* Jsi_MapEntryNew (Jsi_Map *mapPtr, const void *key, bool *isNew){\n    SIGASSERT(mapPtr, MAP);\n    switch (mapPtr->typ) {\n        case JSI_MAP_HASH: return (Jsi_MapEntry*)Jsi_HashEntryNew(mapPtr->v.hash, key, isNew);\n        case JSI_MAP_TREE: return (Jsi_MapEntry*)Jsi_TreeEntryNew(mapPtr->v.tree, key, isNew);\n        case JSI_MAP_LIST: {\n            Jsi_ListEntry *lptr = Jsi_ListEntryNew(mapPtr->v.list, NULL, (key?mapPtr->v.list->head:NULL));\n            if (isNew) *isNew = 1;\n            return (Jsi_MapEntry*)lptr;\n        }\n        break;\n        case JSI_MAP_NONE: break;\n    }\n    return NULL;\n}\nint Jsi_MapEntryDelete (Jsi_MapEntry *entryPtr){\n    switch (jsi_GetListType(entryPtr)) {\n        case JSI_MAP_HASH: return Jsi_HashEntryDelete((Jsi_HashEntry*)entryPtr);\n        case JSI_MAP_TREE: return Jsi_TreeEntryDelete((Jsi_TreeEntry*)entryPtr);\n        case JSI_MAP_LIST: {\n            Jsi_ListEntry *lptr = (Jsi_ListEntry*)entryPtr;\n            Jsi_ListPop(lptr->list, lptr);\n            Jsi_ListEntryDelete(lptr);\n            return 1;\n        }\n    }\n    return JSI_OK;\n}\nJsi_MapEntry* Jsi_MapSearchFirst (Jsi_Map *mapPtr, Jsi_MapSearch *searchPtr, int flags){\n    SIGASSERT(mapPtr, MAP);\n    searchPtr->typ = mapPtr->typ;\n    switch (mapPtr->typ) {\n        case JSI_MAP_HASH: return (Jsi_MapEntry*)Jsi_HashSearchFirst(mapPtr->v.hash, &searchPtr->v.hash);\n        case JSI_MAP_TREE: return (Jsi_MapEntry*)Jsi_TreeSearchFirst(mapPtr->v.tree, &searchPtr->v.tree, flags, NULL);\n        case JSI_MAP_LIST: return (Jsi_MapEntry*)Jsi_ListSearchFirst(mapPtr->v.list, &searchPtr->v.list, flags);\n        case JSI_MAP_NONE: break;\n    }\n    return NULL;\n}\nJsi_MapEntry* Jsi_MapSearchNext (Jsi_MapSearch *searchPtr){\n    switch (searchPtr->typ) {\n        case JSI_MAP_HASH: return (Jsi_MapEntry*)Jsi_HashSearchNext(&searchPtr->v.hash);\n        case JSI_MAP_TREE: return (Jsi_MapEntry*)Jsi_TreeSearchNext(&searchPtr->v.tree);\n        case JSI_MAP_LIST: return (Jsi_MapEntry*)Jsi_ListSearchNext(&searchPtr->v.list);\n        case JSI_MAP_NONE: break;\n    }\n    return NULL;\n}\nvoid Jsi_MapSearchDone (Jsi_MapSearch *searchPtr){\n    switch (searchPtr->typ) {\n        case JSI_MAP_HASH: break;\n        case JSI_MAP_TREE: Jsi_TreeSearchDone(&searchPtr->v.tree); break;\n        case JSI_MAP_LIST: break;\n        case JSI_MAP_NONE: break;\n    }\n}\nuint Jsi_MapSize(Jsi_Map *mapPtr) {\n    SIGASSERT(mapPtr, MAP);\n    switch (mapPtr->typ) {\n        case JSI_MAP_HASH: return Jsi_HashSize(mapPtr->v.hash);\n        case JSI_MAP_TREE: return Jsi_TreeSize(mapPtr->v.tree);\n        case JSI_MAP_LIST: return Jsi_ListSize(mapPtr->v.list);\n        case JSI_MAP_NONE: break;\n    }\n    return -1;\n}\n\n\n#ifndef JSI_OMIT_THREADS\n\n#ifdef __WIN32\n#include <windows.h>\n#else\n#include <pthread.h>\n#endif\n\ntypedef struct Jsi_Mutex {\n    int flags;\n    int lockTimeout;\n    int threadErrCnt;\n#ifdef __WIN32\n    CRITICAL_SECTION mtx;\n#else\n    pthread_mutex_t mtx;\n#endif\n} Jsi_Mutex;\n\n#ifdef __WIN32\n#include <windows.h>\n\nstatic Jsi_RC MutexLock(Jsi_Interp *interp, Jsi_Mutex* mtx) {\n    int timeout = mtx->lockTimeout;\n    if (interp && timeout<0)\n        timeout = interp->lockTimeout;\n    if (timeout<=0)\n        EnterCriticalSection(&mtx->mtx);\n    else {\n        int cnt = timeout;\n        while (cnt-- >= 0) {\n            if (TryEnterCriticalSection(&mtx->mtx))\n                return JSI_OK;\n            usleep(1000);\n        }\n        Jsi_LogError(\"lock timed out\");\n        if (interp)\n            interp->threadErrCnt++;\n        mtx->threadErrCnt++;\n        return JSI_ERROR;\n    }\n    return JSI_OK;\n}\nstatic void MutexUnlock(Jsi_Mutex* mtx) { LeaveCriticalSection(&mtx->mtx); }\nstatic void MutexInit(Jsi_Mutex *mtx) {  InitializeCriticalSection(&mtx->mtx); }\n\nstatic void MutexDone(Jsi_Mutex *mtx) { DeleteCriticalSection(&mtx->mtx); }\n#else /* ! __WIN32 */\n\n#include <pthread.h>\nstatic Jsi_RC MutexLock(Jsi_Interp *interp, Jsi_Mutex *mtx) {\n    int timeout = mtx->lockTimeout;\n    if (interp && timeout<0)\n        timeout = interp->lockTimeout;\n    if (timeout<=0)\n        pthread_mutex_lock(&mtx->mtx);\n    else {\n        struct timespec ts;\n        ts.tv_sec = timeout/1000;\n        ts.tv_nsec = 1000 * (timeout%1000);\n        int rc = pthread_mutex_timedlock(&mtx->mtx, &ts);\n        if (rc != 0) {\n            Jsi_LogError(\"lock timed out\");\n            if (interp)\n                interp->threadErrCnt++;\n            mtx->threadErrCnt++;\n            return JSI_ERROR;\n        }\n    }\n    return JSI_OK;\n}\nstatic void MutexUnlock(Jsi_Mutex *mtx) { pthread_mutex_unlock(&mtx->mtx); }\nstatic void MutexInit(Jsi_Mutex *mtx) {\n    pthread_mutexattr_t Attr;\n    pthread_mutexattr_init(&Attr);\n    if (mtx->flags & JSI_MUTEX_RECURSIVE)\n        pthread_mutexattr_settype(&Attr, PTHREAD_MUTEX_RECURSIVE);\n    pthread_mutex_init(&mtx->mtx, &Attr);\n}\n\nstatic void MutexDone(Jsi_Mutex *mtx) { pthread_mutex_destroy(&mtx->mtx); }\n#endif /* ! __WIN32 */\n\nJsi_RC Jsi_MutexLock(Jsi_Interp *interp, Jsi_Mutex *mtx) { if (interp) interp->lockRefCnt++; return MutexLock(interp, mtx);}\nvoid Jsi_MutexUnlock(Jsi_Interp *interp, Jsi_Mutex *mtx) { MutexUnlock(mtx); if (interp) interp->lockRefCnt--; }\nJsi_Mutex* Jsi_MutexNew(Jsi_Interp *interp, int timeout, int flags) {\n     Jsi_Mutex *mtx = (Jsi_Mutex *)Jsi_Calloc(1,sizeof(Jsi_Mutex));\n     mtx->lockTimeout = timeout;\n     mtx->flags = flags;\n     MutexInit(mtx);\n     return mtx;\n}\nvoid Jsi_MutexDelete(Jsi_Interp *interp, Jsi_Mutex *mtx) { MutexDone(mtx); Jsi_Free(mtx);}\n//void Jsi_MutexInit(Jsi_Interp *interp, Jsi_Mutex *mtx) { MutexInit(mtx); }\nvoid* Jsi_InterpThread(Jsi_Interp *interp) { return interp->threadId; }\nvoid* Jsi_CurrentThread(void) {\n#ifdef __WIN32\n    return (void*)(uintptr_t)GetCurrentThreadId();\n#else\n    return (void*)pthread_self();\n#endif\n}\n\n#else /* ! JSI_OMIT_THREADS */\nJsi_RC Jsi_MutexLock(Jsi_Interp *interp, Jsi_Mutex *mtx) { return JSI_OK; }\nvoid Jsi_MutexUnlock(Jsi_Interp *interp, Jsi_Mutex *mtx) { }\nJsi_Mutex* Jsi_MutexNew(Jsi_Interp *interp, int timeout, int flags) { return NULL; }\nvoid Jsi_MutexDelete(Jsi_Interp *interp, Jsi_Mutex *mtx) { }\nvoid* Jsi_CurrentThread(void) { return NULL; }\nvoid* Jsi_InterpThread(Jsi_Interp *interp) { return NULL; }\n#endif\n\nJsi_Number Jsi_Version(void) {\n    Jsi_Number d = JSI_VERSION;\n    return d;\n}\n\nstatic const char *JsiCharsetMatch(const char *pattern, int c, int flags)\n{\n    int inot = 0;\n    int pchar;\n    int match = 0;\n    int nocase = 0;\n\n    if (flags & JSI_CMP_NOCASE) {\n        nocase++;\n        c = toupper(c);\n    }\n\n    if (flags & JSI_CMP_CHARSET_SCAN) {\n        if (*pattern == '^') {\n            inot++;\n            pattern++;\n        }\n\n        /* Special case. If the first char is ']', it is part of the set */\n        if (*pattern == ']') {\n            goto first;\n        }\n    }\n\n    while (*pattern && *pattern != ']') {\n        /* Exact match */\n        if (pattern[0] == '\\\\') {\nfirst:\n            pattern += Jsi_UtfToUniCharCase(pattern, &pchar, nocase);\n        }\n        else {\n            /* Is this a range? a-z */\n            int start;\n            int end;\n            pattern += Jsi_UtfToUniCharCase(pattern, &start, nocase);\n            if (pattern[0] == '-' && pattern[1]) {\n                /* skip '-' */\n                pattern += Jsi_UtfToUniChar(pattern, &pchar);\n                pattern += Jsi_UtfToUniCharCase(pattern, &end, nocase);\n\n                /* Handle reversed range too */\n                if ((c >= start && c <= end) || (c >= end && c <= start)) {\n                    match = 1;\n                }\n                continue;\n            }\n            pchar = start;\n        }\n\n        if (pchar == c) {\n            match = 1;\n        }\n    }\n    if (inot) {\n        match = !match;\n    }\n\n    return match ? pattern : NULL;\n}\n\n\n/* Split on char, or whitespace if ch==0. */\nstatic void SplitChar(const char *str, int *argcPtr,\n              char ***argvPtr, char ch, Jsi_DString *dStr)\n{\n    char *cp, *ep, *p, **argv;\n    int cnt = 1, len, i;\n\n    len = Jsi_Strlen(str);\n    cp = (char*)str;\n    while (*cp) {\n        if (ch)\n            cp = Jsi_Strchr(cp,ch);\n        else {\n            while (*cp && !isspace(*cp))\n                cp++;\n        }\n        if (cp == NULL || *cp == 0) break;\n        cp++;\n        cnt++;\n    }\n    //argv = (char**)Jsi_Calloc(1,(sizeof(char*)*(cnt+3) + sizeof(char)*(len+6)));\n    Jsi_DSSetLength(dStr, (sizeof(char*)*(cnt+3) + sizeof(char)*(len+6)));\n    argv = (char**)Jsi_DSValue(dStr);\n    *argvPtr = argv;\n    *argcPtr = cnt;\n    p = (char*)&(argv[cnt+2]);\n    argv[cnt+1] = p;\n    Jsi_Strcpy(p, str);\n    cp = p;\n    i = 0;\n    argv[i++] = p;\n    while (*cp) {\n        if (ch)\n            ep = Jsi_Strchr(cp,ch);\n        else {\n            ep = cp;\n            while (*ep && !isspace(*ep))\n                ep++;\n        }\n        if (ep == NULL || *ep == 0) break;\n        *ep = 0;\n        cp = ep+1;\n        argv[i++] = cp;\n    }\n    argv[cnt] = NULL;\n}\n\nJsi_RC\nJsi_GetIndex( Jsi_Interp *interp, const char *str,\n    const char **tablePtr, const char *msg, int flags,\n    int *indexPtr)\n{\n  const char *msg2 = \"unknown \";\n  char **cp, *c;\n  int cond, index = -1, slen, i, dup = 0;\n  int exact = (flags & JSI_CMP_EXACT);\n  int nocase = (flags & JSI_CMP_NOCASE);\n  slen = Jsi_Strlen(str);\n /* if (slen==0) \n        return Jsi_LogError(\"empty option %s %s\", msg, str);*/\n  cp = (char**)tablePtr;\n  i = -1;\n  while (*cp != 0) {\n    i++;\n    c = *cp;\n    if (c[0] != str[0]) { cp++; continue; }\n    if (!nocase)\n        cond = (exact ? Jsi_Strcmp(c,str) : Jsi_Strncmp(c,str,slen));\n    else {\n        cond = (exact ? Jsi_Strncasecmp(c,str, -1) : Jsi_Strncasecmp(c,str,slen));\n    }\n    if (cond == 0) {\n      if (index<0) {\n        index = i;\n      } else {\n        dup = 1;\n        break;\n      }\n    }\n    cp++;\n  }\n  if (index >= 0 && dup == 0) {\n    *indexPtr = index;\n    return JSI_OK;\n  }\n  if (exact && (dup || index<=0)) {\n    if (interp != NULL) {\n      msg2 = (index>=0? \"unknown \":\"duplicate \");\n    }\n    goto err;\n  }\n  cp = (char**)tablePtr;\n  i = -1;\n  dup = 0;\n  index = -1;\n  while (*cp != 0) {\n    i++;\n    c = *cp;\n    if (c[0] == str[0] && Jsi_Strncmp(c,str, slen) == 0) {\n      if (index<0) {\n        index = i;\n        if (slen == (int)Jsi_Strlen(c))\n            break;\n      } else {\n        if (interp != NULL) {\n          msg2 = \"ambiguous \";\n        }\n        goto err;\n      }\n    }\n    cp++;\n  }\n  if (index >= 0 && dup == 0) {\n    *indexPtr = index;\n    return JSI_OK;\n  }\nerr:\n  if (interp != NULL) {\n    Jsi_DString dStr = {};\n    Jsi_DSAppend(&dStr, msg2, msg, \" \\\"\", str, \"\\\" not one of: \", NULL);\n    cp = (char**)tablePtr;\n    while (*cp != 0) {\n      c = *cp;\n      Jsi_DSAppend(&dStr, c, NULL);\n      Jsi_DSAppend(&dStr, \" \", NULL);\n      cp++;\n    }\n    Jsi_LogError(\"%s\", Jsi_DSValue(&dStr));\n    Jsi_DSFree(&dStr);\n  }\n  return JSI_ERROR;\n}\n\nbool Jsi_GlobMatch(const char *pattern, const char *string, int nocase)\n{\n    int c;\n    int pchar;\n    while (*pattern) {\n        switch (pattern[0]) {\n            case '*':\n                while (pattern[1] == '*') {\n                    pattern++;\n                }\n                pattern++;\n                if (!pattern[0]) {\n                    return 1;   /* match */\n                }\n                while (*string) {\n                    if (Jsi_GlobMatch(pattern, string, nocase))\n                        return 1;       /* match */\n                    string += Jsi_UtfToUniChar(string, &c);\n                }\n                return 0;       /* no match */\n\n            case '?':\n                string += Jsi_UtfToUniChar(string, &c);\n                break;\n\n            case '[': {\n                    string += Jsi_UtfToUniChar(string, &c);\n                    pattern = JsiCharsetMatch(pattern + 1, c, nocase ? JSI_CMP_NOCASE : 0);\n                    if (!pattern) {\n                        return 0;\n                    }\n                    if (!*pattern) {\n                        /* Ran out of pattern (no ']') */\n                        continue;\n                    }\n                    break;\n                }\n            case '\\\\':\n                if (pattern[1]) {\n                    pattern++;\n                }\n                /* fall through */\n            default:\n                string += Jsi_UtfToUniCharCase(string, &c, nocase);\n                Jsi_UtfToUniCharCase(pattern, &pchar, nocase);\n                if (pchar != c) {\n                    return 0;\n                }\n                break;\n        }\n        pattern += Jsi_UtfToUniCharCase(pattern, &pchar, nocase);\n        if (!*string) {\n            while (*pattern == '*') {\n                pattern++;\n            }\n            break;\n        }\n    }\n    if (!*pattern && !*string) {\n        return 1;\n    }\n    return 0;\n}\n\nJsi_Stack* Jsi_StackNew(void)\n{\n    Jsi_Stack *stack = (Jsi_Stack*)Jsi_Calloc(1, sizeof(Jsi_Stack));\n    return stack;\n}\n\nvoid Jsi_StackFree(Jsi_Stack *stack)\n{\n    Jsi_Free(stack->vector);\n    Jsi_Free(stack);\n}\n\nint Jsi_StackSize(Jsi_Stack *stack)\n{\n    return stack->len;\n}\n\nvoid Jsi_StackPush(Jsi_Stack *stack, void *element)\n{\n    int neededLen = stack->len + 1;\n\n    if (neededLen > stack->maxlen) {\n        stack->maxlen = neededLen < 20 ? 20 : neededLen * 2;\n        stack->vector = (void**)Jsi_Realloc(stack->vector, sizeof(void *) * stack->maxlen);\n    }\n    stack->vector[stack->len] = element;\n    stack->len++;\n}\n\nvoid *Jsi_StackPop(Jsi_Stack *stack)\n{\n    if (stack->len == 0)\n        return NULL;\n    stack->len--;\n    return stack->vector[stack->len];\n}\n\nvoid *Jsi_StackUnshift(Jsi_Stack *stack)\n{\n    if (stack->len == 0)\n        return NULL;\n    stack->len--;\n    void *rc = stack->vector[0];\n    memmove(stack->vector, stack->vector+1, sizeof(void*)*stack->len);\n    return rc;\n}\n\nvoid *Jsi_StackPeek(Jsi_Stack *stack)\n{\n    if (stack->len == 0)\n        return NULL;\n    return stack->vector[stack->len - 1];\n}\n\nvoid *Jsi_StackHead(Jsi_Stack *stack)\n{\n    if (stack->len == 0)\n        return NULL;\n    return stack->vector[0];\n}\n\nvoid Jsi_StackFreeElements(Jsi_Interp *interp, Jsi_Stack *stack, Jsi_DeleteProc *freeProc)\n{\n    int i;\n    for (i = 0; i < stack->len; i++)\n        freeProc(interp, stack->vector[i]);\n    stack->len = 0;\n}\n\ntypedef struct {\n    void *data;\n    Jsi_DeleteProc *delProc;\n} AssocData;\n\n/* Split on string. */\nvoid Jsi_SplitStr(const char *str, int *argcPtr,\n              char ***argvPtr, const char *ch, Jsi_DString *dStr)\n{\n    char *cp, *ep, *p, **argv;\n    int cnt = 1, len, i, clen;\n    if (!ch)\n        ch = \"\";\n    clen = Jsi_Strlen(ch);\n    if (clen<=0)\n        return SplitChar(str, argcPtr, argvPtr, *ch, dStr);\n    len = Jsi_Strlen(str);\n    cp = (char*)str;\n    while (*cp) {\n        cp = Jsi_Strstr(cp,ch);\n \n        if (cp == NULL || *cp == 0) break;\n        cp += clen;\n        cnt++;\n    }\n    //argv = (char**)Jsi_Calloc(1,(sizeof(char*)*(cnt+3) + sizeof(char)*(len+6)));\n    Jsi_DSSetLength(dStr, (sizeof(char*)*(cnt+3) + sizeof(char)*(len+6)));\n    argv = (char**)Jsi_DSValue(dStr);\n    *argvPtr = argv;\n    *argcPtr = cnt;\n    p = (char*)&(argv[cnt+2]);\n    argv[cnt+1] = p;\n    Jsi_Strcpy(p, str);\n    cp = p;\n    i = 0;\n    argv[i++] = p;\n    while (*cp) {\n        ep = Jsi_Strstr(cp,ch);\n        if (ep == NULL || *ep == 0) break;\n        *ep = 0;\n        cp = ep+clen;\n        argv[i++] = cp;\n    }\n    argv[cnt] = NULL;\n}\n\nstatic Jsi_RC JsiCheckConversion(const char *str, const char *endptr)\n{\n    if (str[0] == '\\0' || str == endptr) {\n        return JSI_ERROR;\n    }\n\n    if (endptr[0] != '\\0') {\n        while (*endptr) {\n            if (!isspace(UCHAR(*endptr))) {\n                return JSI_ERROR;\n            }\n            endptr++;\n        }\n    }\n    return JSI_OK;\n}\n\nstatic int JsiNumberBase(const char *str, int *base, int *sign)\n{\n    int i = 0;\n\n    *base = 10;\n\n    while (isspace(UCHAR(str[i]))) {\n        i++;\n    }\n\n    if (str[i] == '-') {\n        *sign = -1;\n        i++;\n    }\n    else {\n        if (str[i] == '+') {\n            i++;\n        }\n        *sign = 1;\n    }\n\n    if (str[i] != '0') {\n        /* base 10 */\n        return 0;\n    }\n\n    /* We have 0<x>, so see if we can convert it */\n    switch (str[i + 1]) {\n        case 'x': case 'X': *base = 16; break;\n        case 'o': case 'O': *base = 8; break;\n        case 'b': case 'B': *base = 2; break;\n        default: return 0;\n    }\n    i += 2;\n    /* Ensure that (e.g.) 0x-5 fails to parse */\n    if (str[i] != '-' && str[i] != '+' && !isspace(UCHAR(str[i]))) {\n        /* Parse according to this base */\n        return i;\n    }\n    /* Parse as base 10 */\n    return 10;\n}\n\n/* Converts a number as per strtoull(..., 0) except leading zeros do *not*\n * imply octal. Instead, decimal is assumed unless the number begins with 0x, 0o or 0b\n */\nstatic Jsi_Wide jsi_strtoull(const char *str, char **endptr)\n{\n#ifdef JSI__LONG_LONG\n    int sign;\n    int base;\n    int i = JsiNumberBase(str, &base, &sign);\n\n    if (base != 10) {\n        Jsi_Wide value = strtoull(str + i, endptr, base);\n        if (endptr == NULL || *endptr != str + i) {\n            return value * sign;\n        }\n    }\n\n    /* Can just do a regular base-10 conversion */\n    return strtoull(str, endptr, 10);\n#else\n    return (unsigned long)jsi_strtol(str, endptr);\n#endif\n}\n\nstatic Jsi_Wide jsi_strtoul(const char *str, char **endptr)\n{\n#ifdef JSI__LONG_LONG\n    int sign;\n    int base;\n    int i = JsiNumberBase(str, &base, &sign);\n\n    if (base != 10) {\n        Jsi_Wide value = strtoul(str + i, endptr, base);\n        if (endptr == NULL || *endptr != str + i) {\n            return value * sign;\n        }\n    }\n\n    /* Can just do a regular base-10 conversion */\n    return strtoul(str, endptr, 10);\n#else\n    return (unsigned long)jsi_strtol(str, endptr);\n#endif\n}\n\n\nJsi_RC Jsi_GetWide(Jsi_Interp* interp, const char *string, Jsi_Wide *widePtr, int base)\n{\n    char *endptr;\n\n    if (base) {\n        *widePtr = strtoull(string, &endptr, base);\n    }\n    else {\n        *widePtr = jsi_strtoull(string, &endptr);\n    }\n\n    return JsiCheckConversion(string, endptr);\n}\n\nJsi_RC Jsi_GetInt(Jsi_Interp* interp, const char *string, int *n, int base)\n{\n    char *endptr;\n    if (base) {\n        *n = strtoul(string, &endptr, base);\n    }\n    else {\n        *n = (int)jsi_strtoul(string, &endptr);\n    }\n    return JsiCheckConversion(string, endptr);\n}\n\nJsi_RC Jsi_GetDouble(Jsi_Interp* interp, const char *string, Jsi_Number *n)\n{\n    char *endptr;\n\n    /* Callers can check for underflow via ERANGE */\n    errno = 0;\n\n    *n = strtod(string, &endptr);\n\n    return JsiCheckConversion(string, endptr);\n}\n\nJsi_RC Jsi_GetBool(Jsi_Interp* interp, const char *string, bool *n)\n{\n    int len = Jsi_Strlen(string);\n    if (len && (Jsi_Strncasecmp(string, \"true\", len)==0 && len<=4)) {\n        *n = 1;\n        return JSI_OK;\n    }\n    if (len && (Jsi_Strncasecmp(string, \"false\", len)==0 && len<=5)) {\n        *n = 0;\n        return JSI_OK;\n    }\n    return JSI_ERROR;\n}\n\n/* Converts a hex character to its integer value */\nchar jsi_fromHexChar(char ch) {\n    return isdigit(ch) ? ch - '0' : tolower(ch) - 'a' + 10;\n}\n\n/* Converts an integer value to its hex character*/\nchar jsi_toHexChar(char code) {\n    static char hex[] = \"0123456789abcdef\";\n    return hex[code & 15];\n}\n\nvoid jsi_ToHexStr(const uchar *indata, int dlen, char *out) {\n    static char hex[] = \"0123456789abcdef\";\n    int i, n=0;\n    for (i=0; i<dlen; i++) {\n        int c = indata[i];\n        out[n++] = hex[(c>>4)&0xf];\n        out[n++] = hex[c&0xf];\n    }\n    out[n] = 0;\n}\n\nstatic int jsi_FromHexStr(const char *in, uchar *outdata) {\n    int n = 0;\n    while (in[0] && in[1]) {\n        if (!isxdigit(in[0]) || isxdigit(in[0]))\n            return -1;\n        outdata[n++] = jsi_fromHexChar(in[0]) << 4 | jsi_fromHexChar(in[1]);\n        in+=2;\n    }\n    return n;\n}\n\n\nint Jsi_HexStr(const uchar *data, int len, Jsi_DString *dStr, bool decode) {\n    int olen = (decode?(len/2+1):(len*2+1));\n    Jsi_DSSetLength(dStr, olen);\n    if (!decode)\n        return jsi_FromHexStr((const char*)data, (uchar*)Jsi_DSValue(dStr));\n    jsi_ToHexStr((const uchar*)data, len, Jsi_DSValue(dStr));\n    return olen-1;\n}\n#ifndef JSI_LITE_ONLY\n\nvoid *Jsi_InterpGetData(Jsi_Interp *interp, const char *key, Jsi_DeleteProc **proc)\n{\n    Jsi_HashEntry *hPtr;\n    AssocData *ptr;\n    hPtr = Jsi_HashEntryFind(interp->assocTbl, key);\n    if (!hPtr)\n        return NULL;\n    ptr = (AssocData *)Jsi_HashValueGet(hPtr);\n    if (!ptr)\n        return NULL;\n    if (proc)\n        *proc = ptr->delProc;\n    return ptr->data;\n}\nvoid Jsi_InterpSetData(Jsi_Interp *interp, const char *key, void *data, Jsi_DeleteProc *proc)\n{\n    bool isNew;\n    Jsi_HashEntry *hPtr;\n    AssocData *ptr;\n    hPtr = Jsi_HashEntryNew(interp->assocTbl, key, &isNew);\n    if (!hPtr)\n        return;\n    if (isNew) {\n        ptr = (AssocData *)Jsi_Calloc(1,sizeof(*ptr));\n        Jsi_HashValueSet(hPtr, ptr);\n    } else\n        ptr = (AssocData *)Jsi_HashValueGet(hPtr);\n    ptr->data = data;\n    ptr->delProc = proc;\n}\n\nvoid jsi_DelAssocData(Jsi_Interp *interp, void *data) {\n    AssocData *ptr = (AssocData *)data;\n    if (!ptr) return;\n    if (ptr->delProc)\n        ptr->delProc(interp, ptr->data);\n    Jsi_Free(ptr);\n}\n\nJsi_RC Jsi_DeleteData(Jsi_Interp* interp, void *m)\n{\n    Jsi_Free(m);\n    return JSI_OK;\n}\n\nvoid Jsi_InterpFreeData(Jsi_Interp *interp, const char *key)\n{\n    Jsi_HashEntry *hPtr;\n    hPtr = Jsi_HashEntryFind(interp->assocTbl, key);\n    if (!hPtr)\n        return;\n    Jsi_HashEntryDelete(hPtr);\n}\n\nJsi_RC Jsi_GetStringFromValue(Jsi_Interp* interp, Jsi_Value *value, const char **n)\n{\n    if (!value)\n        return JSI_ERROR;\n    if (value->vt == JSI_VT_STRING)\n    {\n        *n = (const char*)value->d.s.str;\n         return JSI_OK;\n    }\n    if (value->vt == JSI_VT_OBJECT && value->d.obj->ot == JSI_OT_STRING) {\n        *n = value->d.obj->d.s.str;\n        return JSI_OK;\n    }\n    Jsi_LogError(\"invalid string\");\n    return JSI_ERROR;\n}\n\nJsi_RC Jsi_GetBoolFromValue(Jsi_Interp* interp, Jsi_Value *value, bool *n)\n{\n    if (!value)\n        return JSI_ERROR;\n\n    if (value->vt == JSI_VT_BOOL) {\n        *n = value->d.val;\n        return JSI_OK;\n    }\n    if (value->vt == JSI_VT_OBJECT && value->d.obj->ot == JSI_OT_BOOL) {\n        *n = value->d.obj->d.val;\n        return JSI_OK;\n    }\n    Jsi_LogError(\"invalid bool\");\n    return JSI_ERROR;\n}\n\n\nJsi_RC Jsi_GetNumberFromValue(Jsi_Interp* interp, Jsi_Value *value, Jsi_Number *n)\n{\n    if (!value)\n        return JSI_ERROR;\n\n    if (value->vt == JSI_VT_NUMBER) {\n        *n = value->d.num;\n        return JSI_OK;\n    }\n    if (value->vt == JSI_VT_OBJECT && value->d.obj->ot == JSI_OT_NUMBER) {\n        *n = value->d.obj->d.num;\n        return JSI_OK;\n    }\n    if (interp)\n        Jsi_LogError(\"invalid number\");\n    return JSI_ERROR;\n}\n\nJsi_RC Jsi_GetIntFromValueBase(Jsi_Interp* interp, Jsi_Value *value, int *n, int base, int flags)\n{\n    int noMsg = (flags & JSI_NO_ERRMSG);\n    /* TODO: inefficient to convert to double then back. */\n    if (!value)\n        return JSI_ERROR;\n    Jsi_Number d = Jsi_ValueToNumberInt(interp, value, 1);\n    if (!Jsi_NumberIsFinite(d))\n    {\n        if (!noMsg)\n            Jsi_LogError(\"invalid number\");\n        return JSI_ERROR;\n    }\n    Jsi_ValueReset(interp,&value);\n    Jsi_ValueMakeNumber(interp, &value, d);\n    *n = (int)d;\n    return JSI_OK;\n}\n\nJsi_RC Jsi_GetIntFromValue(Jsi_Interp* interp, Jsi_Value *value, int *n)\n{\n    if (!Jsi_ValueIsNumber(interp, value)) \n        return Jsi_LogError(\"invalid number\");\n    return Jsi_GetIntFromValueBase(interp, value, n, 0, 0);\n}\n\nJsi_RC Jsi_GetLongFromValue(Jsi_Interp* interp, Jsi_Value *value, long *n)\n{\n    /* TODO: inefficient to convert to double then back. */\n    if (!value)\n        return JSI_ERROR;\n    if (!interp->strict)\n        jsi_ValueToOInt32(interp, value);\n    if (!Jsi_ValueIsNumber(interp, value))\n    \n        return Jsi_LogError(\"invalid number\");\n    *n = (long)(value->vt == JSI_VT_NUMBER ? value->d.num : value->d.obj->d.num);\n    return JSI_OK;\n}\n\nJsi_RC Jsi_GetWideFromValue(Jsi_Interp* interp, Jsi_Value *value, Jsi_Wide *n)\n{\n    if (!value)\n        return JSI_ERROR;\n    if (!interp->strict)\n        jsi_ValueToOInt32(interp, value);\n    if (!Jsi_ValueIsNumber(interp, value))\n    \n        return Jsi_LogError(\"invalid number\");\n    *n = (Jsi_Wide)(value->vt == JSI_VT_NUMBER ? value->d.num : value->d.obj->d.num);\n    return JSI_OK;\n\n}\n\nJsi_RC Jsi_GetDoubleFromValue(Jsi_Interp* interp, Jsi_Value *value, Jsi_Number *n)\n{\n    if (!value)\n        return JSI_ERROR;\n    if (!interp->strict)\n        Jsi_ValueToNumber(interp, value);\n    if (!Jsi_ValueIsNumber(interp, value))\n    \n        return Jsi_LogError(\"invalid number\");\n    *n = (value->vt == JSI_VT_NUMBER ? value->d.num : value->d.obj->d.num);\n    return JSI_OK;\n}\n\nJsi_RC\nJsi_ValueGetIndex( Jsi_Interp *interp, Jsi_Value *valPtr,\n    const char **tablePtr, const char *msg, int flags, int *indexPtr)\n{\n    char *val = Jsi_ValueString(interp, valPtr, NULL);\n    if (val == NULL) \n        return Jsi_LogError(\"expected string\");\n    return Jsi_GetIndex(interp, val, tablePtr, msg, flags, indexPtr);\n}\n\n#endif // JSI_LITE_ONLY\n", "#ifndef JSI_LITE_ONLY\n#ifndef JSI_AMALGAMATION\n#include \"jsiInt.h\"\n#endif\n\n#define bits_set(who, mask)     ((who) |= (mask))\n#define bits_unset(who, mask)   ((who) &= (~(mask)))\n#define bits_get(who, mask)     ((who) & (mask))\n\n#if  JSI__MEMDEBUG\nvoid jsi_VALCHK(Jsi_Value *val) {\n    SIGASSERTV(val,VALUE);\n    assert(val->vt <= JSI_VT__MAX);\n    if (val->vt == JSI_VT_OBJECT)\n        OBJCHK(val->d.obj);\n}\n\nvoid jsi_OBJCHK(Jsi_Obj *obj) {\n    SIGASSERTV(obj,OBJ);\n    assert(obj->ot <= JSI_OT__MAX);\n}\n#endif\n\n/*********************************************/\n\nbool Jsi_IsShared(Jsi_Interp* interp, Jsi_Value *v)\n{\n    SIGASSERT(v,VALUE);\n    return (v->refCnt > 1);\n}\n\nint Jsi_IncrRefCount(Jsi_Interp* interp, Jsi_Value *v)\n{\n    SIGASSERT(v,VALUE);\n    assert(v->refCnt>=0);\n    jsi_DebugValue(v,\"Incr\", jsi_DebugValueCallIdx(), interp);\n    return ++(v->refCnt);\n}\n\nint Jsi_DecrRefCount(Jsi_Interp* interp, Jsi_Value *v) {\n    SIGASSERT(v,VALUE);\n    if (v->refCnt<=0) {\n#ifdef JSI_MEM_DEBUG\n        fprintf(stderr, \"Value decr with ref %d: VD.Idx=%d\\n\", v->refCnt, v->VD.Idx);\n#endif\n        return -2;\n    }\n    int ref;\n    jsi_DebugValue(v,\"Decr\", jsi_DebugValueCallIdx(), interp);\n    if ((ref = --(v->refCnt)) <= 0) {\n        v->refCnt = -1;\n        Jsi_ValueFree(interp, v);\n    }\n    return ref;\n}\n\nstatic Jsi_Value *ValueNew(Jsi_Interp *interp)\n{\n    interp->dbPtr->valueCnt++;\n    interp->dbPtr->valueAllocCnt++;\n    Jsi_Value *v = (Jsi_Value *)Jsi_Calloc(1,sizeof(*v));\n    SIGINIT(v,VALUE)\n    v->vt = JSI_VT_UNDEF;\n    jsi_DebugValue(v,\"New\", jsi_DebugValueCallIdx(), interp);\n    return v;\n}\n\nstatic Jsi_Value *ValueNew1(Jsi_Interp *interp)\n{\n    Jsi_Value *v = ValueNew(interp);\n    Jsi_IncrRefCount(interp, v);\n    return v;\n}\n\nstatic Jsi_Value *ValueDup(Jsi_Interp *interp, Jsi_Value *v)\n{\n    Jsi_Value *r = ValueNew1(interp);\n    Jsi_ValueCopy(interp,r, v);\n#ifdef JSI_MEM_DEBUG\n    r->VD.label2 = \"ValueDup\";\n#endif\n    return r;\n}\n#ifndef JSI_MEM_DEBUG\nJsi_Value* Jsi_ValueNew(Jsi_Interp *interp) {\n    return ValueNew(interp);\n}\nJsi_Value* Jsi_ValueNew1(Jsi_Interp *interp) {\n    return ValueNew1(interp);\n}\nJsi_Value *Jsi_ValueDup(Jsi_Interp *interp, Jsi_Value *v) {\n    return ValueDup(interp, v);\n}\n#else\nstatic uint jsi_memDebugBreakIdx = 0;  // Debug memory by setting this, and adding BP on following func.\nvoid jsi_memDebugBreak() {\n}\n\n// Debugging functions: set breakpoint with \"cond B v == 0xNNN\"\nvoid jsi_DebugValue(Jsi_Value* v, const char *reason, uint cidx, Jsi_Interp *interp)\n{\n    if (jsi_memDebugBreakIdx && jsi_memDebugBreakIdx == v->VD.Idx)\n        jsi_memDebugBreak();\n    return;\n}\nvoid jsi_DebugObj(Jsi_Obj* o, const char *reason, uint cidx, Jsi_Interp *interp)\n{\n    if (jsi_memDebugBreakIdx && jsi_memDebugBreakIdx == o->VD.Idx)\n        jsi_memDebugBreak();\n    return;\n}\n\n\nvoid jsi_ValueDebugUpdate_(Jsi_Interp *interp, jsi_ValueDebug *vd, void *v, Jsi_Hash* tbl, const char *fname, int line, const char *func)\n{\n    vd->fname = fname;\n    vd->line = line;\n    vd->func = func;\n    if (!vd->Idx)\n        vd->Idx = interp->dbPtr->memDebugCallIdx;\n    vd->hPtr = Jsi_HashSet(tbl, v, 0);\n    vd->ip = interp->curIp;\n    if (vd->ip) {\n        vd->ipLine = vd->ip->Line;\n        vd->ipOp = vd->ip->op;\n        vd->ipFname = vd->ip->fname;\n    }\n    vd->interp = interp;\n    if (jsi_memDebugBreakIdx && jsi_memDebugBreakIdx == vd->Idx)\n        jsi_memDebugBreak();\n}\n\nvoid jsi_ValueDebugLabel_(jsi_ValueDebug *vd, const char *l1, const char *l2)\n{\n    if (l1)\n        vd->label = l1;\n    if (l2)\n        vd->label2 = l2;\n}\n\n\nJsi_Value * jsi_ValueNew(Jsi_Interp *interp, const char *fname, int line, const char *func) {\n    Jsi_Value *v = ValueNew(interp);\n    jsi_ValueDebugUpdate(interp, v, valueDebugTbl, fname, line, func);\n    return v;\n}\n\nJsi_Value * jsi_ValueNew1(Jsi_Interp *interp, const char *fname, int line, const char *func) {\n    Jsi_Value *v = ValueNew1(interp);\n    jsi_ValueDebugUpdate(interp, v, valueDebugTbl, fname, line, func);\n    return v;\n}\nJsi_Value * jsi_ValueDup(Jsi_Interp *interp, Jsi_Value *ov, const char *fname, int line, const char *func) {\n    Jsi_Value *v = ValueDup(interp, ov);\n    jsi_ValueDebugUpdate(interp, v, valueDebugTbl, fname, line, func);\n    return v;\n}\n\n#ifndef JSI_OMIT_STUBS\n#undef Jsi_ValueNew\n#undef Jsi_ValueNew1\nJsi_Value *Jsi_ValueNew(Jsi_Interp *interp) { return ValueNew(interp); }\nJsi_Value *Jsi_ValueNew1(Jsi_Interp *interp) { return ValueNew1(interp); }\n#define Jsi_ValueNew(interp) jsi_ValueNew(interp, __FILE__, __LINE__,__PRETTY_FUNCTION__)\n#define Jsi_ValueNew1(interp) jsi_ValueNew1(interp, __FILE__, __LINE__,__PRETTY_FUNCTION__)\n#endif\n\n#endif\n\nJsi_Hash *strDebug = NULL;\n\nstatic void ValueFree(Jsi_Interp *interp, Jsi_Value* v)\n{\n    SIGASSERTV(v,VALUE);\n    //printf(\"FREE: %d\\n\", interp->valueCnt);\n    switch (v->vt) {\n        case JSI_VT_OBJECT:\n            Jsi_ObjDecrRefCount(interp, v->d.obj);\n            break;\n        case JSI_VT_VARIABLE:\n            assert(v->d.lval != v);\n            Jsi_DecrRefCount(interp, v->d.lval);\n            break;\n        case JSI_VT_STRING:\n            if (v->d.s.str && !v->f.bits.isstrkey) {\n                Jsi_Free(v->d.s.str);\n                /*Jsi_HashEntry *hPtr;\n                if ((hPtr = Jsi_HashEntryFind(strDebug, v->d.s.str)))\n                    Jsi_HashEntryDelete(hPtr);*/\n            }\n            break;\n        default:\n            break;\n    }\n    v->vt = JSI_VT_UNDEF;\n}\n\nvoid Jsi_ValueFree(Jsi_Interp *interp, Jsi_Value* v)\n{\n    interp->dbPtr->valueCnt--;\n    jsi_DebugValue(v, \"Free\", jsi_DebugValueCallIdx(), interp);\n    ValueFree(interp, v);\n#ifdef JSI_MEM_DEBUG\n    //if (v->VD.interp != interp)  //TODO: InterpAliasCmd leaking Values.\n     //   fprintf(stderr, \"cross interp delete: %p\\n\", v);\n    if (v->VD.hPtr && !interp->cleanup) {\n        if (!Jsi_HashEntryDelete(v->VD.hPtr))\n            fprintf(stderr, \"Value not in hash\\n\");\n    }\n    memset(v, 0, (sizeof(*v)-sizeof(v->VD)));\n#endif\n    Jsi_Free(v);\n}\n\n/* Reset a value back to undefined, releasing string/obj if necessary. */\nvoid Jsi_ValueReset(Jsi_Interp *interp, Jsi_Value **vPtr) {\n    Jsi_Value *v = *vPtr;\n    SIGASSERTV(v,VALUE);\n    Assert(v->vt <= JSI_VT__MAX);\n    jsi_DebugValue(v, \"Reset\", jsi_DebugValueCallIdx(), interp);\n    Assert(v->refCnt>=0);\n    v->f.bits.lookupfailed = 0; // TODO: rework lookup-fail mechanism.\n    if (v->vt == JSI_VT_UNDEF)\n        return;\n    ValueFree(interp, v);\n    v->f.flag = 0;\n}\n\n// Assign value ptrs (to=from). Decr old to, and Incr from ref count.\nvoid Jsi_ValueReplace(Jsi_Interp *interp, Jsi_Value **to, Jsi_Value *from )  {\n    VALCHK(from);\n    if( *to == from) return;\n    if (*to)\n        Jsi_DecrRefCount(interp, *to);\n    *to = from;\n    if (from)\n        Jsi_IncrRefCount(interp, from);\n}\n\n\nstatic void jsi_ValueCopyMove(Jsi_Interp *interp, Jsi_Value *to, Jsi_Value *from, int isCopy )  {\n    if (!from) {\n        Jsi_ValueMakeUndef(interp, &to);\n        return;\n    }\n    VALCHK(from);\n    if( to == from) return;\n    int ocnt = to->refCnt;\n    Jsi_Value *ovt = NULL;\n    assert(ocnt>0);\n    int toVt = to->vt;\n    if (toVt == JSI_VT_VARIABLE) {\n        ovt = to->d.lval;\n        Jsi_IncrRefCount(interp, ovt);\n    }\n    Jsi_ValueMakeUndef(interp, &to);\n#ifdef JSI_MEM_DEBUG\n    memcpy(to, from, sizeof(*to)-sizeof(to->VD));\n    to->VD.label3 = from->VD.func;\n#else\n    *to = *from;\n#endif\n    if (isCopy) {\n        if (to->refCnt) {\n            switch (to->vt) {\n                case JSI_VT_STRING:\n                    if (!to->f.bits.isstrkey) {\n                        to->d.s.str = Jsi_StrdupLen(to->d.s.str, to->d.s.len);\n                    }\n                    break;\n                case JSI_VT_OBJECT:\n                    Jsi_ObjIncrRefCount(interp,to->d.obj);\n                    break;\n                case JSI_VT_VARIABLE:\n                    Jsi_IncrRefCount(interp,to->d.lval);\n                    break;\n                default:\n                    break;\n            }\n        }\n        to->refCnt = ocnt;\n        if (ovt)\n            Jsi_DecrRefCount(interp, ovt);\n    } else {\n        to->refCnt = ocnt;\n        if (ovt)\n            Jsi_DecrRefCount(interp, ovt);\n        ocnt = from->refCnt;\n#ifdef JSI_MEM_DEBUG\n        memset(from, 0, sizeof(*to)-sizeof(to->VD));\n#else\n        memset(from, 0, sizeof(*to));\n#endif\n        SIGINIT(from, VALUE);\n        from->refCnt = ocnt;\n    }\n}\n\nvoid Jsi_ValueMove(Jsi_Interp *interp, Jsi_Value *to, Jsi_Value *from )  {\n    return jsi_ValueCopyMove(interp, to, from, 0);\n}\n\nvoid Jsi_ValueCopy(Jsi_Interp *interp, Jsi_Value *to, Jsi_Value *from ) {\n    return jsi_ValueCopyMove(interp, to, from, 1);\n}\n\nvoid Jsi_ValueDup2(Jsi_Interp *interp, Jsi_Value **to, Jsi_Value *from )\n{\n    if (!*to)\n        *to = Jsi_ValueNew1(interp);\n#ifdef JSI_MEM_DEBUG\n    (*to)->VD.label3 = \"ValueDup2\";\n#endif\n    Jsi_ValueCopy(interp, *to, from);\n    (*to)->f.bits.readonly = 0;\n}\n\nJsi_Value *Jsi_ValueDupJSON(Jsi_Interp *interp, Jsi_Value *val)\n{\n    Jsi_DString pStr;\n    Jsi_DSInit(&pStr);\n    Jsi_ValueGetDString(interp, val, &pStr, JSI_OUTPUT_JSON);\n    Jsi_Value *valPtr = NULL;\n    if (Jsi_JSONParse(interp, Jsi_DSValue(&pStr), &valPtr, 0) != JSI_OK)\n        Jsi_LogBug(\"bad json parse\");\n    Jsi_DSFree(&pStr);\n    return valPtr;\n}\n\n#if 0\nvoid jsi_AllValueOp(Jsi_Interp *interp, Jsi_Value* val, int op) {\n    if (op==1) {\n        //printf(\"ADD: %p : %p : %d\\n\", interp, val, val->VD.Idx);\n        assert(interp->allValues!=val);\n        val->next = interp->allValues;\n        if (interp->allValues)\n            interp->allValues->prev = val;\n        interp->allValues = val;\n        return;\n    }\n    if (op==0) {\n        //printf(\"DEL: %p : %p\\n\", interp, val);\n        if (!val || !interp->allValues) return;\n        if (val == interp->allValues)\n            interp->allValues = val->next;\n        if (val->next)\n            val->next->prev = val->prev;\n        if (val->prev)  \n            val->prev->next = val->next; \n        return;\n    }\n    if (op == -1) {\n        while (interp->allValues) {\n            printf(\"NEED CLEANUP: %p\\n\", interp->allValues);\n            Jsi_ValueFree(interp, interp->allValues);\n        }\n        return;\n    }\n#if JSI__MEMDEBUG\n    assert(0);\n    abort();\n#endif\n}\n#endif\n\nJsi_Value *Jsi_ValueObjLookup(Jsi_Interp *interp, Jsi_Value *target, const char *key, int isstrkey)\n{\n    Jsi_Obj *obj;\n    Jsi_Value *v = NULL;\n    if (interp->subOpts.noproto && key) {\n        if (key[0] == 'p' && Jsi_Strcmp(key, \"prototype\")==0) {\n            Jsi_LogError(\"inheritance is disabled in interp\");\n            return NULL;\n        }\n    }\n    if (target->vt != JSI_VT_OBJECT) {\n        if (interp->strict)\n            Jsi_LogWarn(\"Target is not object: %d\", target->vt);\n        return NULL;\n    }\n    obj = target->d.obj;\n    \n#if (defined(JSI_HAS___PROTO__) && JSI_HAS___PROTO__==2)\n    if (*key == '_' && Jsi_Strcmp(key, \"__proto__\")==0 && interp->noproto==0)\n        return obj->__proto__;\n#endif\n\n    if (*key == 't' && Jsi_Strcmp(key, \"this\")==0)\n        return interp->framePtr->inthis;\n    if (obj->arr)\n        v = jsi_ObjArrayLookup(interp, obj, key);\n    if (!v)\n        v= Jsi_TreeObjGetValue(obj, key, isstrkey);\n    return v;  /* TODO: redo with copy */\n}\n\nJsi_Value *Jsi_ValueArrayIndex(Jsi_Interp *interp, Jsi_Value *args, int index)\n{\n    Jsi_Obj *obj = args->d.obj;\n    Jsi_Value *v;\n    assert(args->vt == JSI_VT_OBJECT);\n    if (obj->isarrlist && obj->arr)\n        return ((index < 0 || (uint)index >= obj->arrCnt) ? NULL : obj->arr[index]);\n    char unibuf[100];\n    Jsi_NumberItoA10(index, unibuf, sizeof(unibuf));\n    v = Jsi_TreeObjGetValue(args->d.obj, unibuf, 0);\n    return v;\n}\n\n/**************************************************/\n\nJsi_RC Jsi_ValueGetBoolean(Jsi_Interp *interp, Jsi_Value *pv, bool *val)\n{\n    if (!pv) return JSI_ERROR;\n    if (pv->vt == JSI_VT_BOOL)\n        *val = pv->d.val;\n    else if (pv->vt == JSI_VT_OBJECT && pv->d.obj->ot == JSI_OT_BOOL)\n        *val = pv->d.obj->d.val;\n    else \n        return JSI_ERROR;\n    return JSI_OK;\n}\n\nbool Jsi_ValueIsArray(Jsi_Interp *interp, Jsi_Value *v)  {\n    return (v->vt == JSI_VT_OBJECT && v->d.obj->ot == JSI_OT_OBJECT && v->d.obj->isarrlist);\n}\n\nbool Jsi_ValueIsBoolean(Jsi_Interp *interp, Jsi_Value *pv)\n{\n    return (pv->vt == JSI_VT_BOOL || (pv->vt == JSI_VT_OBJECT && pv->d.obj->ot == JSI_OT_BOOL));\n}\n\nbool Jsi_ValueIsNull(Jsi_Interp *interp, Jsi_Value *pv)\n{\n    return (pv->vt == JSI_VT_NULL);\n}\n\nbool Jsi_ValueIsUndef(Jsi_Interp *interp, Jsi_Value *pv)\n{\n    return (pv->vt == JSI_VT_UNDEF);\n}\n\nJsi_RC Jsi_ValueGetNumber(Jsi_Interp *interp, Jsi_Value *pv, Jsi_Number *val)\n{\n    if (!pv) return JSI_ERROR;\n    if (pv->vt == JSI_VT_NUMBER)\n        *val = pv->d.num;\n    else if (pv->vt == JSI_VT_OBJECT && pv->d.obj->ot == JSI_OT_NUMBER)\n        *val = pv->d.obj->d.num;\n    else \n        return JSI_ERROR;\n    return JSI_OK;\n}\nbool Jsi_ValueIsNumber(Jsi_Interp *interp, Jsi_Value *pv)\n{\n    return (pv->vt == JSI_VT_NUMBER || (pv->vt == JSI_VT_OBJECT && pv->d.obj->ot == JSI_OT_NUMBER));\n}\n\nbool Jsi_ValueIsStringKey(Jsi_Interp* interp, Jsi_Value *key)\n{\n    if (key->vt == JSI_VT_STRING && key->f.bits.isstrkey)\n        return 1;\n    if (key->vt == JSI_VT_OBJECT && key->d.obj->ot == JSI_OT_STRING && key->d.obj->isstrkey)\n        return 1;\n    return 0;\n}\n\nbool Jsi_ValueIsString(Jsi_Interp *interp, Jsi_Value *pv)\n{\n    return (pv->vt == JSI_VT_STRING || (pv->vt == JSI_VT_OBJECT && pv->d.obj->ot == JSI_OT_STRING));\n}\n\nbool Jsi_ValueIsFunction(Jsi_Interp *interp, Jsi_Value *v)\n{\n    int rc = (v!=NULL && v->vt == JSI_VT_OBJECT && v->d.obj->ot == JSI_OT_FUNCTION);\n    if (!rc) return rc;\n    if (interp == v->d.obj->d.fobj->interp)\n        return 1;\n    fprintf(stderr, \"OOPS: function in wrong interp %s: %s\\n\", \n        interp->parent?\"(string came in from parent interp?)\":\"\",\n        v->d.obj->d.fobj->func->name);\n    return 0;\n}\n\nbool Jsi_ValueIsType(Jsi_Interp *interp, Jsi_Value *pv, Jsi_vtype vtype) {\n    if (!pv) return 0;\n    return pv->vt == vtype;\n}\n\nJsi_vtype Jsi_ValueTypeGet(Jsi_Value *pv) { return pv->vt; }\n\n\nbool Jsi_ValueIsObjType(Jsi_Interp *interp, Jsi_Value *v, Jsi_otype otype)\n{\n    if (v == NULL || v->vt != JSI_VT_OBJECT)\n        return 0;\n    if (otype != JSI_OT_ARRAY)\n        return (v->d.obj->ot == otype);\n    if (v->d.obj->ot != JSI_OT_OBJECT || !v->d.obj->isarrlist)\n        return 0;\n    return 1;\n}\n\nchar* Jsi_NumberToString(Jsi_Interp *interp, Jsi_Number d, char *buf, int bsiz)\n{\n     if (Jsi_NumberIsInteger(d)) {\n        Jsi_NumberItoA10((Jsi_Wide)d, buf, bsiz);\n    } else if (Jsi_NumberIsNormal(d)) {\n        Jsi_NumberDtoA(interp, d, buf, bsiz, 0);\n    } else if (Jsi_NumberIsNaN(d)) {\n        Jsi_Strcpy(buf, \"NaN\");\n    } else {\n        int s = Jsi_NumberIsInfinity(d);\n        if (s > 0) Jsi_Strcpy(buf,  \"Infinity\");\n        else if (s < 0) Jsi_Strcpy(buf, \"-Infinity\");\n        else {\n            buf[0] = 0;\n        }\n    }\n    return buf;\n}\n\n/* Return the string value.  Coerce value to a string type. */\nconst char* Jsi_ValueToString(Jsi_Interp *interp, Jsi_Value *v, int *lenPtr)\n{\n    Jsi_Number d;\n    const char *ntxt = \"undefined\";\n    int kflag = 1;\n    int isKey = 0;\n    char *key = NULL;\n    if (!v)\n        goto done;\n    if (lenPtr) *lenPtr = 0;\n    char unibuf[200];\n    switch(v->vt) {\n        case JSI_VT_STRING:\n            ntxt = v->d.s.str;\n            goto done;\n        case JSI_VT_UNDEF:\n            break;\n        case JSI_VT_BOOL:\n            ntxt = v->d.val ? \"true\":\"false\";\n            break;\n        case JSI_VT_NULL:\n            ntxt = \"null\";\n            break;\n        case JSI_VT_NUMBER: {\n            d = v->d.num;\nfmtnum:\n            if (Jsi_NumberIsInteger(d)) {\n                Jsi_NumberItoA10((Jsi_Wide)d, unibuf, sizeof(unibuf));\n                kflag = 0;\n                ntxt = unibuf;\n            } else if (Jsi_NumberIsNormal(d)) {\n                Jsi_NumberDtoA(interp, d, unibuf, sizeof(unibuf), 0);\n                kflag = 0;\n                ntxt = unibuf;\n            } else if (Jsi_NumberIsNaN(v->d.num)) {\n                ntxt = \"NaN\";\n            } else {\n                int s = Jsi_NumberIsInfinity(d);\n                if (s > 0) ntxt = \"Infinity\";\n                else if (s < 0) ntxt = \"-Infinity\";\n                else Jsi_LogBug(\"Ieee function got problem\");\n            }\n            break;\n        }\n        case JSI_VT_OBJECT: {\n            Jsi_Obj *obj = v->d.obj;\n            switch(obj->ot) {\n                case JSI_OT_STRING:\n                    ntxt = obj->d.s.str;\n                    goto done;\n                case JSI_OT_BOOL:\n                    ntxt = obj->d.val ? \"true\":\"false\";\n                    break;\n                case JSI_OT_NUMBER:\n                    d = obj->d.num;\n                    goto fmtnum;\n                    break;\n                default:\n                    ntxt = \"[object Object]\";\n                    break;\n            }\n            break;\n        }\n        default:\n            Jsi_LogBug(\"Convert a unknown type: 0x%x to string\", v->vt);\n            break;\n    }\n    Jsi_ValueReset(interp, &v);\n    if (!kflag) {\n        Jsi_ValueMakeStringDup(interp, &v, ntxt);\n        return Jsi_ValueString(interp, v, lenPtr);\n    }\n    \n    key = jsi_KeyFind(interp, ntxt, 0, &isKey);\n    if (key)\n        Jsi_ValueMakeStringKey(interp, &v, key);\n    else\n        Jsi_ValueMakeString(interp, &v, ntxt);\n    ntxt = v->d.s.str;\n    \ndone:\n    if (lenPtr) *lenPtr = Jsi_Strlen(ntxt);\n    return ntxt;\n}\n\nJsi_Number Jsi_ValueToNumberInt(Jsi_Interp *interp, Jsi_Value *v, int isInt)\n{\n    char *endPtr = NULL, *sptr;\n    Jsi_Number a = 0;\n    switch(v->vt) {\n        case JSI_VT_BOOL:\n            a = (Jsi_Number)(v->d.val ? 1.0: 0);\n            break;\n        case JSI_VT_NULL:\n            a = 0;\n            break;\n        case JSI_VT_OBJECT: {\n            Jsi_Obj *obj = v->d.obj;\n            switch(obj->ot) {\n                case JSI_OT_BOOL:\n                    a = (Jsi_Number)(obj->d.val ? 1.0: 0);\n                    break;\n                case JSI_OT_NUMBER:\n                    a = obj->d.num;\n                    break;\n                case JSI_OT_STRING:\n                    sptr = obj->d.s.str;\n                    goto donum;\n                    break;\n                default:\n                    a = 0;\n                break;\n            }\n            break;\n        }\n        case JSI_VT_UNDEF:\n            a = Jsi_NumberNaN();\n            break;\n        case JSI_VT_NUMBER:\n            a = v->d.num;\n            break;\n        case JSI_VT_STRING:\n            sptr = v->d.s.str;\ndonum:\n            if (!isInt) {\n                a = strtod(sptr, &endPtr);\n                if (endPtr && *endPtr) {\n                    a = interp->NaNValue->d.num;\n                }\n            } else {\n                a = (Jsi_Number)strtol(sptr, &endPtr, 0);\n                if (!isdigit(*sptr))\n                    a = interp->NaNValue->d.num;\n            }\n            break;\n        default:\n            Jsi_LogBug(\"Convert a unknown type: 0x%x to number\", v->vt);\n            break;\n    }\n    if (isInt && Jsi_NumberIsNormal(a))\n        a = (Jsi_Number)((int64_t)(a));\n    return a;\n}\n\nJsi_RC Jsi_ValueToNumber(Jsi_Interp *interp, Jsi_Value *v)\n{\n    if (v->vt == JSI_VT_NUMBER) return JSI_OK;\n    Jsi_Number a = Jsi_ValueToNumberInt(interp, v, 0);\n    Jsi_ValueReset(interp, &v);\n    Jsi_ValueMakeNumber(interp, &v, a);\n    return JSI_OK;\n}\n\nJsi_RC Jsi_ValueToBool(Jsi_Interp *interp, Jsi_Value *v)\n{\n    Jsi_RC rc = JSI_OK;\n    bool a = 0;\n    switch(v->vt) {\n        case JSI_VT_BOOL:\n            a = v->d.val;\n            break;\n        case JSI_VT_NULL:\n            break;\n        case JSI_VT_UNDEF:\n            break;\n        case JSI_VT_NUMBER:\n            a = (v->d.num ? 1: 0);\n            break;\n        case JSI_VT_STRING:     /* TODO: NaN, and accept true/false string? */\n            a = atoi(v->d.s.str);\n            a = (a ? 1 : 0);\n            break;\n        case JSI_VT_OBJECT: {\n            Jsi_Obj *obj = v->d.obj;\n            switch(obj->ot) {\n                case JSI_OT_BOOL:\n                    a = (obj->d.val ? 1.0: 0);\n                    break;\n                case JSI_OT_NUMBER:\n                    a = obj->d.num;\n                    a = (a ? 1 : 0);\n                    break;\n                case JSI_OT_STRING:\n                    a = atoi(obj->d.s.str);\n                    a = (a ? 1 : 0);\n                    break;\n                default:\n                    break;\n            }\n            break;\n        }\n        default:\n            Jsi_LogBug(\"Convert a unknown type: 0x%x to number\", v->vt);\n            return JSI_ERROR;\n    }\n    Jsi_ValueReset(interp,&v);\n    Jsi_ValueMakeBool(interp, &v, a);\n    return rc;\n}\n\nint jsi_ValueToOInt32(Jsi_Interp *interp, Jsi_Value *v)\n{\n    Jsi_Number a = Jsi_ValueToNumberInt(interp, v, 1);\n    Jsi_ValueReset(interp,&v);\n    Jsi_ValueMakeNumber(interp, &v, a);\n    return (int)a;\n}\n\nJsi_RC Jsi_ValueToObject(Jsi_Interp *interp, Jsi_Value *v)\n{\n    Jsi_RC rc = JSI_OK;\n    if (v->vt == JSI_VT_OBJECT) return rc;\n    Jsi_Obj *o = Jsi_ObjNew(interp);\n    switch(v->vt) {\n        case JSI_VT_UNDEF:\n        case JSI_VT_NULL:\n            if (interp->strict) {\n                Jsi_LogError(\"converting a undefined/null value to object\");\n                rc = JSI_ERROR;\n            }\n            o->d.num = 0;\n            o->ot = JSI_OT_NUMBER;\n            o->__proto__ = interp->Number_prototype;\n            break;\n        case JSI_VT_BOOL: {\n            o->d.val = v->d.val;\n            o->ot = JSI_OT_BOOL;\n            o->__proto__ = interp->Boolean_prototype;\n            break;\n        }\n        case JSI_VT_NUMBER: {\n            o->d.num = v->d.num;\n            o->ot = JSI_OT_NUMBER;\n            o->__proto__ = interp->Number_prototype;\n            break;\n        }\n        case JSI_VT_STRING: {\n            o->d.s = v->d.s;\n            if (!v->f.bits.isstrkey)\n                o->d.s.str = (char*)Jsi_KeyAdd(interp, v->d.s.str);\n            o->isstrkey = 1;\n            o->ot = JSI_OT_STRING;\n            o->__proto__ = interp->String_prototype;\n            break;\n        }\n        default:\n            Jsi_LogBug(\"toobject, not suppose to reach here\");\n    }\n    Jsi_ValueReset(interp,&v);\n    Jsi_ValueMakeObject(interp, &v, o);\n    return rc;\n}\n\n/* also toBoolean here, in ecma */\nbool Jsi_ValueIsTrue(Jsi_Interp *interp, Jsi_Value *v)\n{\n    switch(v->vt) {\n        case JSI_VT_UNDEF:\n        case JSI_VT_NULL:   return 0;\n        case JSI_VT_BOOL:   return v->d.val ? 1:0;\n        case JSI_VT_NUMBER: \n            if (v->d.num == 0.0 || Jsi_NumberIsNaN(v->d.num)) return 0;\n            return 1;\n        case JSI_VT_STRING: return (Jsi_ValueStrlen(v)!=0);\n        case JSI_VT_OBJECT: {\n            Jsi_Obj *o = v->d.obj;\n            if (o->ot == JSI_OT_STRING)\n                return (Jsi_ValueStrlen(v)!=0);\n            if (o->ot == JSI_OT_NUMBER)\n                return (o->d.num != 0);\n            if (o->ot == JSI_OT_BOOL)\n                return (o->d.val != 0);\n            if (o->ot == JSI_OT_USEROBJ && o->d.uobj->interp == interp) {\n                return jsi_UserObjIsTrue(interp, o->d.uobj);\n            }\n            return 1;\n        }\n        default: Jsi_LogBug(\"TOP is type incorrect: %d\", v->vt);\n    }\n    return 0;\n}\n\nbool Jsi_ValueIsFalse(Jsi_Interp *interp, Jsi_Value *v)\n{\n    if (v->vt == JSI_VT_BOOL)  return v->d.val ? 0:1;\n    return 0;\n}\n\nbool Jsi_ValueIsEqual(Jsi_Interp* interp, Jsi_Value* v1, Jsi_Value* v2)\n{\n    int eq = 0;\n    if (v1->vt == JSI_VT_OBJECT && v2->vt == JSI_VT_OBJECT && v1->d.obj == v2->d.obj)\n        eq = 1;\n    else if (Jsi_ValueIsNull(interp, v1) && Jsi_ValueIsNull(interp, v2))\n        eq = 1;\n    else if (Jsi_ValueIsUndef(interp, v1) && Jsi_ValueIsUndef(interp, v2))\n        eq = 1;\n    else if (Jsi_ValueIsBoolean(interp, v1) && Jsi_ValueIsBoolean(interp, v2)) {\n        bool b1, b2;\n        eq = (Jsi_GetBoolFromValue(interp, v1, &b1) == JSI_OK\n            && Jsi_GetBoolFromValue(interp, v2, &b2) == JSI_OK\n            && b1 == b2);\n    } else if (Jsi_ValueIsNumber(interp, v1) && Jsi_ValueIsNumber(interp, v2)) {\n        Jsi_Number n1, n2;\n        eq = (Jsi_GetNumberFromValue(interp, v1, &n1) == JSI_OK\n            && Jsi_GetNumberFromValue(interp, v2, &n2) == JSI_OK\n            && n1 == n2);\n    } else if (Jsi_ValueIsString(interp, v1) && Jsi_ValueIsString(interp, v2)) {\n        const char *s1, *s2;\n        int l1, l2;\n        eq = (((s1=Jsi_ValueString(interp, v1, &l1)) && ((s2=Jsi_ValueString(interp, v2, &l2)))\n            && l1 == l2 && Jsi_Strcmp(s1, s2)==0));\n    }\n    return eq;\n}\n\nvoid jsi_ValueToPrimitive(Jsi_Interp *interp, Jsi_Value **vPtr)\n{\n    Jsi_Value *v = *vPtr;\n    if (v->vt != JSI_VT_OBJECT)\n        return;\n    DECL_VALINIT(res);\n    Jsi_Value *rPtr = &res;\n    Jsi_Obj *obj = v->d.obj;\n    //rPtr = v;\n    switch(obj->ot) {\n        case JSI_OT_BOOL:\n            Jsi_ValueMakeBool(interp,&rPtr, obj->d.val);\n            break;\n        case JSI_OT_NUMBER:\n            Jsi_ValueMakeNumber(interp,&rPtr, obj->d.num);\n            break;\n        case JSI_OT_STRING:\n            if (obj->isstrkey) {\n                res.d.s = obj->d.s;\n                res.f.bits.isstrkey = 1;\n                obj->d.s.str = NULL;\n            } else {\n                if (obj->refcnt==1) {\n                    Jsi_ValueMakeString(interp, &rPtr, obj->d.s.str);\n                    res.d.s = obj->d.s;\n                    obj->d.s.str = NULL;\n                } else if (obj->d.s.len >= 0) \n                {\n                    Assert(obj->refcnt>=1);\n                    obj->refcnt--;\n                    int bytes = obj->d.s.len;\n                    jsi_ValueMakeBlobDup(interp, &rPtr, (uchar*)obj->d.s.str, bytes);\n                } else\n                    Jsi_ValueMakeStringDup(interp, &rPtr, obj->d.s.str);\n            }\n            break;\n        case JSI_OT_FUNCTION: {\n            Jsi_DString dStr;\n            Jsi_DSInit(&dStr);\n            Jsi_FuncObjToString(interp, obj->d.fobj->func, &dStr, 3);\n            Jsi_ValueFromDS(interp, &dStr, &rPtr);\n            break;\n        }\n        case JSI_OT_USEROBJ: {\n            Jsi_DString dStr;\n            Jsi_DSInit(&dStr);\n            jsi_UserObjToName(interp, obj->d.uobj, &dStr);\n            Jsi_ValueFromDS(interp, &dStr, &rPtr);\n            break;\n        }\n        default:\n            Jsi_ValueMakeStringKey(interp,&rPtr, \"[object Object]\");\n            break;\n    }\n    Jsi_ValueReset(interp, vPtr);\n    res.refCnt = v->refCnt;\n#ifdef JSI_MEM_DEBUG\n    memcpy(v, &res, sizeof(res)-sizeof(res.VD));\n#else\n    *v = res;\n#endif\n}\n\nstatic void jsi_ValueToPrimitiveRes(Jsi_Interp *interp, Jsi_Value *v, Jsi_Value *rPtr)\n{\n    if (v->vt != JSI_VT_OBJECT) {\n#ifdef JSI_MEM_DEBUG\n    memcpy(rPtr, v, sizeof(*v)-sizeof(v->VD));\n#else\n    *rPtr = *v; //TODO: usde only by ValueCompare, so refCnt doesn't matter?\n#endif\n        return;\n    }\n    Jsi_Obj *obj = v->d.obj;\n    switch(obj->ot) {\n        case JSI_OT_BOOL:\n            Jsi_ValueMakeBool(interp, &rPtr, obj->d.val);\n            break;\n        case JSI_OT_NUMBER:\n            Jsi_ValueMakeNumber(interp, &rPtr, obj->d.num);\n            break;\n        case JSI_OT_STRING:\n            rPtr->vt = JSI_VT_STRING;\n            rPtr->d.s = obj->d.s;\n            rPtr->f.bits.isstrkey = 1;\n            break;\n        default:\n            break;\n    }\n}\n\nint Jsi_ValueCmp(Jsi_Interp *interp, Jsi_Value *v1, Jsi_Value* v2, int flags)\n{\n    DECL_VALINIT(res1);\n    DECL_VALINIT(res2);\n    int r = 1;\n    int nocase = (flags&JSI_SORT_NOCASE), dict = ((flags & JSI_SORT_DICT));\n    if (v1 == v2)\n        return 1;\n    if (v1->vt != v2->vt) {\n        jsi_ValueToPrimitiveRes(interp, v1, &res1);\n        jsi_ValueToPrimitiveRes(interp, v2, &res2);\n        v1 = &res1;\n        v2 = &res2;\n    }\n    if (v1->vt != v2->vt) {\n        if ((flags&JSI_CMP_EXACT))\n            return 1;\n        if ((v1->vt == JSI_VT_UNDEF || v1->vt == JSI_VT_NULL) && \n            (v2->vt == JSI_VT_UNDEF || v2->vt == JSI_VT_NULL)) {\n            r = 0;\n        } else {\n            Jsi_Number n1, n2;\n            n1 = Jsi_ValueToNumberInt(interp, v1, 0);\n            n2 = Jsi_ValueToNumberInt(interp, v2, 0);\n            r = (n2 - n1);\n        }\n    } else {\n        switch (v1->vt) {\n            case JSI_VT_NUMBER:\n                if (v2->d.num == v1->d.num) return 0;\n                r = (v2->d.num < v1->d.num ? -1 : 1);\n                break;\n            case JSI_VT_BOOL:\n                r = (v2->d.val - v1->d.val);\n                break;\n            case JSI_VT_STRING:\n                r = (Jsi_StrcmpDict(v2->d.s.str, v1->d.s.str, nocase, dict));\n                break;\n            case JSI_VT_OBJECT:\n                /* TODO: refer to objects joined to each other */\n                if (v2->vt != JSI_VT_OBJECT)\n                    r = 1;\n                else if (v1->d.obj->ot == JSI_OT_STRING && v2->d.obj->ot == JSI_OT_STRING)\n                    r = (Jsi_StrcmpDict(v2->d.obj->d.s.str, v1->d.obj->d.s.str, nocase, dict));\n                else\n                    r = (v2->d.obj - v1->d.obj);\n                break;\n            case JSI_VT_UNDEF:\n            case JSI_VT_NULL:\n                r = 0;\n                break;\n            default:\n                Jsi_LogBug(\"Unexpected value type\");\n        }\n    }\n    return r;\n}\n\n/**\n * @brief Split a string.\n * @param interp \n * @param str - input string to split\n * @param split - to split on\n * @returns an array of string values\n * \n * \n */\nJsi_Value *Jsi_StringSplit(Jsi_Interp *interp, const char *str, const char *spliton)\n{\n    char **argv; int argc;\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    Jsi_SplitStr(str, &argc, &argv, spliton, &dStr);\n    Jsi_Value *nret = Jsi_ValueNewArray(interp, NULL, 0);\n    Jsi_Obj *obj = nret->d.obj;\n    int i;\n    for (i = 0; i < argc; ++i) {\n        Jsi_ObjArraySet(interp, obj, Jsi_ValueNewStringDup(interp, argv[i]), i);\n    }\n    Jsi_ObjSetLength(interp, obj, argc);\n    Jsi_ValueMakeArrayObject(interp, &nret, obj);\n    Jsi_DSFree(&dStr);\n    return nret;\n}\n\nvoid jsi_ValueObjSet(Jsi_Interp *interp, Jsi_Value *target, const char *key, Jsi_Value *value, int flags, int isstrkey)\n{\n    Jsi_TreeEntry *hPtr;\n    if (target->vt != JSI_VT_OBJECT) {\n        if (interp->strict)\n            Jsi_LogWarn(\"Target is not object: %d\", target->vt);\n        return;\n    }\n    hPtr = Jsi_ObjInsert(interp, target->d.obj, key, value, (isstrkey?JSI_OM_ISSTRKEY:0));\n    if (!hPtr)\n        return;\n    hPtr->f.flags |= (flags&JSI_TREE_USERFLAG_MASK);\n}\n\nJsi_Value *jsi_ValueObjKeyAssign(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *keyval, Jsi_Value *value, int flag)\n{\n    int arrayindex = -1;\n\n    if (keyval->vt == JSI_VT_NUMBER && Jsi_NumberIsInteger(keyval->d.num) && keyval->d.num >= 0) {\n        arrayindex = (int)keyval->d.num;\n    }\n    /* TODO: array[\"1\"] also extern the length of array */\n    \n    if (arrayindex >= 0 && arrayindex < MAX_ARRAY_LIST &&\n        target->vt == JSI_VT_OBJECT && target->d.obj->arr) {\n        return jsi_ObjArraySetDup(interp, target->d.obj, value, arrayindex);\n    }\n    const char *kstr = Jsi_ValueToString(interp, keyval, NULL);\n    \n#if (defined(JSI_HAS___PROTO__) && JSI_HAS___PROTO__==2)\n    if (Jsi_Strcmp(kstr, \"__proto__\")==0) {\n        Jsi_Obj *obj = target->d.obj;\n        obj->__proto__ = Jsi_ValueDup(interp, value);\n        //obj->clearProto = 1;\n        return obj->__proto__;\n    }\n#endif\n    Jsi_Value *v = Jsi_ValueNew1(interp);\n    if (value)\n        Jsi_ValueCopy(interp, v, value);\n\n    jsi_ValueObjSet(interp, target, kstr, v, flag, (Jsi_ValueIsStringKey(interp, keyval)? JSI_OM_ISSTRKEY:0));\n    Jsi_DecrRefCount(interp, v);\n    return v;\n}\n\nstatic Jsi_Value *jsi_ValueLookupBase(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *key, Jsi_Value **ret)\n{\n    if (!target)\n        return NULL;\n    if (target->vt != JSI_VT_OBJECT) {\n        Jsi_LogError(\"subscript operand is not object\");\n        return NULL;\n    }\n    const char *keyStr = Jsi_ValueToString(interp, key, NULL);\n    if (!keyStr)\n        return NULL;\n    bool isStrKey = (key->vt == JSI_VT_STRING && key->f.bits.isstrkey);\n    Jsi_Value *v = Jsi_ValueObjLookup(interp, target, (char*)keyStr, isStrKey);\n    if (v)\n        return v;\n    if (target->d.obj->__proto__)\n        return jsi_ValueLookupBase(interp, target->d.obj->__proto__, key, ret);\n    return NULL;\n}\n\n\nJsi_Value* jsi_ValueSubscript(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *key, Jsi_Value **ret)\n{\n    int len;\n    Jsi_ValueReset(interp, ret);\n    Jsi_Value *v = jsi_ValueLookupBase(interp, target, key, ret);\n    if (v)\n        return v;\n    const char *keyStr = Jsi_ValueString(interp, key, NULL);\n    if (!keyStr)\n        return NULL;\n    // Special cases such as \"length\", \"constructor\", etc...\n    if (Jsi_Strcmp(keyStr,\"length\")==0) {\n        if (Jsi_ValueIsString(interp, target)) {\n            len = Jsi_ValueStrlen(target);\n        } else if (target->vt == JSI_VT_OBJECT && target->d.obj->isarrlist) {\n            len = target->d.obj->arrCnt;\n        } else if (target->vt == JSI_VT_OBJECT && target->d.obj->ot == JSI_OT_FUNCTION) {\n            Jsi_Func *fo = target->d.obj->d.fobj->func;\n            if (fo->type == FC_NORMAL)\n                len = fo->argnames->count;\n            else\n                len = fo->cmdSpec->maxArgs, len = (len>=0?len:fo->cmdSpec->minArgs);\n        } else if (target->vt == JSI_VT_OBJECT && target->d.obj->tree) {\n            len = target->d.obj->tree->numEntries;\n        } else {\n            return NULL;\n        }\n        (*ret)->vt = JSI_VT_NUMBER;\n        (*ret)->d.num = (Jsi_Number)len;\n        return *ret;\n    }\n\n    if (target->vt == JSI_VT_OBJECT && (interp->subOpts.noproto==0 && Jsi_Strcmp(keyStr,\"constructor\")==0)) {\n        const char *cp;\n        Jsi_Obj *o = target->d.obj->constructor;\n        if (o) {\n            if (o->ot == JSI_OT_FUNCTION) {\n                Jsi_Value *proto = Jsi_TreeObjGetValue(o, \"prototype\", 0);\n                if (proto && proto->vt == JSI_VT_OBJECT && proto->d.obj->constructor) {\n                    o = proto->d.obj->constructor;\n                }\n            }\n        } else {\n            switch(target->d.obj->ot) {\n                case JSI_OT_NUMBER:\n                    cp = \"Number\";\n                    break;\n                case JSI_OT_BOOL:\n                    cp = \"Boolean\";\n                    break;\n                case JSI_OT_STRING:\n                    cp = \"String\";\n                    break;\n                case JSI_OT_REGEXP:\n                    cp = \"RegExp\";\n                    break;\n                case JSI_OT_OBJECT:\n                    if (target->d.obj->isarrlist) {\n                        cp = \"Array\";\n                        break;\n                    }\n                    cp = \"Object\";\n                    break;\n                default:\n                    Jsi_ValueMakeUndef(interp, ret);\n                    return *ret;\n            }\n            v = Jsi_ValueObjLookup(interp, interp->csc, cp, 0);\n            if (v==NULL || v->vt != JSI_VT_OBJECT)\n                return NULL;\n            o = target->d.obj->constructor = v->d.obj;\n        }\n        Jsi_ValueMakeObject(interp, ret, o);\n        return *ret;\n    }\n\n    if (target->vt == JSI_VT_OBJECT && target->d.obj->ot == JSI_OT_FUNCTION) {\n        /* Looking up something like \"String.substr\" */\n        Jsi_Func* func = target->d.obj->d.fobj->func;\n        if (func->type == FC_BUILDIN) {\n            if (func->f.bits.iscons && func->name) {\n                Jsi_Value *v = Jsi_ValueObjLookup(interp, interp->csc, (char*)func->name, 0);\n                if (!v) {\n                } else {\n                    bool ooo = interp->subOpts.noproto;\n                    interp->subOpts.noproto = 0;\n                    v = Jsi_ValueObjLookup(interp, v, \"prototype\", 0);\n                    interp->subOpts.noproto = ooo;\n                    \n                    if (v && ((v = Jsi_ValueObjLookup(interp, v, (char*)keyStr, 0)))) {\n                        if (v->vt == JSI_VT_OBJECT && v->d.obj->ot == JSI_OT_FUNCTION && Jsi_Strcmp(func->name,\"Interp\")) {\n                            Jsi_Func* sfunc = v->d.obj->d.fobj->func;\n                            /* Handle \"Math.pow(2,3)\", \"String.fromCharCode(0x21)\", ... */\n                            sfunc->callflags.bits.addargs = 1;\n                        }\n                        return v;\n                    }\n                }\n            }\n            if (Jsi_ValueIsString(interp, key)) {\n                char *kstr = Jsi_ValueString(interp, key, NULL);\n                if (!Jsi_Strcmp(kstr,\"call\") || !Jsi_Strcmp(kstr,\"apply\") || !Jsi_Strcmp(kstr,\"bind\")) {\n                    char fbuf[100];\n                    snprintf(fbuf, sizeof(fbuf), \"Function.%s\", kstr);\n                    Jsi_Value *vv = Jsi_NameLookup(interp, fbuf);\n                    if (vv)\n                        return vv;\n                }\n            }\n        }\n    }\n    return NULL;\n}\n\nbool Jsi_ValueKeyPresent(Jsi_Interp *interp, Jsi_Value *target, const char *key, int isstrkey)\n{\n    SIGASSERT(interp,INTERP);\n    //SIGASSERT(target,VALUE);\n    if (Jsi_TreeObjGetValue(target->d.obj, key, isstrkey))\n        return 1;\n    if (target->d.obj->__proto__ == NULL || target->d.obj->__proto__ == target)\n        return 0;\n    return Jsi_ValueKeyPresent(interp, target->d.obj->__proto__, key, isstrkey);\n}\n\nvoid jsi_ValueObjGetKeys(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *ret, bool isof)\n{\n    Jsi_IterObj *io = Jsi_IterObjNew(interp, NULL);\n    Jsi_Obj *to = target->d.obj;\n    \n    if (target->vt != JSI_VT_UNDEF && target->vt != JSI_VT_NULL) {\n\n        if (target->vt == JSI_VT_OBJECT && to->arr) {\n            io->isArrayList = 1;\n            io->count = to->arrCnt;\n        } else {\n            if (isof &&interp->strict)\n                Jsi_LogWarn(\"non-array in 'for...of'\");\n            Jsi_IterGetKeys(interp, target, io, 0);\n        }\n    }\n    io->obj = to;\n    io->isof = isof;\n    Jsi_Obj *r = Jsi_ObjNew(interp);\n    r->ot = JSI_OT_ITER;\n    r->d.iobj = io;\n    Jsi_ValueMakeObject(interp, &ret, r);\n}\n\nJsi_RC Jsi_ValueGetKeys(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *ret)\n{\n    uint i, n = 0;\n    Jsi_IterObj *io;\n    if (target->vt != JSI_VT_OBJECT)\n        return JSI_ERROR;\n    Jsi_Obj *to = target->d.obj;\n    Jsi_Obj *r = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    Jsi_ValueMakeArrayObject(interp, &ret, r);\n    if (to->arr) {\n        for (i=0; i<to->arrCnt; i++)\n            if (to->arr[i]) n++;\n        if (Jsi_ObjArraySizer(interp, r, n) <= 0) {\n            Jsi_LogError(\"too long\");\n            Jsi_ValueMakeUndef(interp, &ret);\n            return JSI_ERROR;\n        }\n        for (i=0, n=0; i<to->arrCnt; i++) {\n            if (to->arr[i]) {\n                r->arr[n] = Jsi_ValueNewNumber(interp, (Jsi_Number)i);\n                Jsi_IncrRefCount(interp, r->arr[n]);\n                n++;\n            }\n        }\n        r->arrCnt = n;\n        return JSI_OK;\n    }\n    io = Jsi_IterObjNew(interp, NULL);\n    Jsi_IterGetKeys(interp, target, io, 0);\n    if (Jsi_ObjArraySizer(interp, r, io->count) <= 0) {\n        Jsi_LogError(\"too long\");\n        Jsi_ValueMakeUndef(interp, &ret);\n        return JSI_ERROR;\n    }\n    for (i=0; i<io->count; i++) {\n        r->arr[i] = (io->keys[i] ? Jsi_ValueNewStringKey(interp, io->keys[i]) : NULL);\n        Jsi_IncrRefCount(interp, r->arr[i]);\n    }\n    io->count = 0;\n    r->arrCnt = i;\n    Jsi_IterObjFree(io);\n    return JSI_OK;\n}\n\njsi_ScopeChain *jsi_ScopeChainNew(Jsi_Interp *interp, int cnt)\n{\n    jsi_ScopeChain *r = (jsi_ScopeChain *)Jsi_Calloc(1, sizeof(*r));\n    r->interp = interp;\n    SIGINIT(r,SCOPE);\n    r->chains = (Jsi_Value **)Jsi_Calloc(cnt, sizeof(r->chains[0]));\n    r->chains_cnt = cnt;\n    return r;\n}\n\nJsi_Value *jsi_ScopeChainObjLookupUni(jsi_ScopeChain *sc, char *key)\n{\n    int i;\n    Jsi_Value *ret;\n    for (i = sc->chains_cnt - 1; i >= 0; --i) {\n        if ((ret = Jsi_ValueObjLookup(sc->interp, sc->chains[i], key, 0))) {\n            return ret;\n        }\n    }\n    return NULL;\n}\n\njsi_ScopeChain *jsi_ScopeChainDupNext(Jsi_Interp *interp, jsi_ScopeChain *sc, Jsi_Value *next)\n{\n    if (!sc) {\n        jsi_ScopeChain *nr = jsi_ScopeChainNew(interp, 1);\n        nr->chains[0] = next;\n        Jsi_IncrRefCount(interp, next);\n        nr->chains_cnt = 1;\n        return nr;\n    }\n    jsi_ScopeChain *r = jsi_ScopeChainNew(interp, sc->chains_cnt + 1);\n    int i;\n    for (i = 0; i < sc->chains_cnt; ++i) {\n        r->chains[i] = sc->chains[i];\n        Jsi_IncrRefCount(interp, sc->chains[i]);\n    }\n    r->chains[i] =  next;\n    Jsi_IncrRefCount(interp, next);\n    r->chains_cnt = i + 1;\n    return r;\n}\n\nvoid jsi_ScopeChainFree(Jsi_Interp *interp, jsi_ScopeChain *sc)\n{\n    int i;\n    for (i = 0; i < sc->chains_cnt; ++i) {\n        Jsi_DecrRefCount(interp, sc->chains[i]);\n    }\n    Jsi_Free(sc->chains);\n    _JSI_MEMCLEAR(sc);\n    Jsi_Free(sc);\n}\n\nint Jsi_ValueGetLength(Jsi_Interp *interp, Jsi_Value *v) {\n    if (Jsi_ValueIsArray(interp, v))\n        return v->d.obj->arrCnt;\n    Jsi_LogWarn(\"expected array\");\n    return 0;\n}\n\nchar *Jsi_ValueArrayIndexToStr(Jsi_Interp *interp, Jsi_Value *args, int index, int *lenPtr)\n{\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, index);\n    if (!arg)\n        return NULL;\n    char *res = Jsi_ValueString(interp, arg, lenPtr);\n    if (res)\n        return res;\n    res = (char*)Jsi_ValueToString(interp, arg, NULL);\n    if (res && lenPtr)\n        *lenPtr = Jsi_Strlen(res);\n    return res;\n}\n\nJsi_RC Jsi_ValueInsert(Jsi_Interp *interp, Jsi_Value *target, const char *key, Jsi_Value *val, int flags)\n{\n    if (target == NULL)\n        target = interp->csc;\n    if (target->vt != JSI_VT_OBJECT) {\n        if (interp->strict)\n            Jsi_LogWarn(\"Target is not object\");\n        return JSI_ERROR;\n    }\n    target->f.flag |= flags;\n    if (Jsi_ObjInsert(interp, target->d.obj, key, val, flags))\n        return JSI_OK;\n    return JSI_ERROR;\n}\n\nJsi_RC Jsi_ValueInsertArray(Jsi_Interp *interp, Jsi_Value *target, int key, Jsi_Value *val, int flags)\n{\n    if (target->vt != JSI_VT_OBJECT) {\n        if (interp->strict)\n            Jsi_LogWarn(\"Target is not object\");\n        return JSI_ERROR;\n    }\n    Jsi_Obj *obj = target->d.obj;\n    \n    if (obj->isarrlist) {\n        if (key >= 0 && key < interp->maxArrayList) {\n            Jsi_ObjArraySet(interp, obj, val, key);\n            return JSI_OK;\n        }\n        return JSI_ERROR;\n    }\n    char unibuf[100];\n    Jsi_NumberItoA10(key, unibuf, sizeof(unibuf));\n    Jsi_ObjInsert(interp, obj, unibuf, val, flags);\n    return JSI_OK;\n}\n\n/* OBJ INTERFACE TO BTREE */\n\nstatic void IterObjInsertKey(Jsi_IterObj *io, const char *key)\n{\n    assert(!io->isArrayList);\n    if (io->depth) {\n        uint i;\n        for (i=0; i<io->count; i++) {\n            if (!Jsi_Strcmp(key, io->keys[i]))\n                return;\n        }\n    }\n\n    if (io->count >= io->size) {\n        io->size += 10;\n        io->keys = (const char**)Jsi_Realloc(io->keys, io->size * sizeof(io->keys[0]));\n    }\n    io->keys[io->count] = key;\n    io->count++;\n}\nstatic void IterObjInsert(Jsi_IterObj *io, Jsi_TreeEntry *hPtr)\n{\n    IterObjInsertKey(io, (const char*)Jsi_TreeKeyGet(hPtr));\n}\n\nJsi_TreeEntry * Jsi_ObjInsert(Jsi_Interp *interp, Jsi_Obj *obj, const char *key, Jsi_Value *val, int flags)\n{\n    Jsi_TreeEntry *hPtr;\n    SIGASSERT(val, VALUE);\n    /*if (val)\n        Jsi_IncrRefCount(interp, val);*/\n    hPtr = Jsi_TreeObjSetValue(obj, key, val, (flags&JSI_OM_ISSTRKEY));\n    if ((flags&JSI_OM_DONTDEL))\n        val->f.bits.dontdel = hPtr->f.bits.dontdel = 1;\n    if ((flags&JSI_OM_READONLY))\n        val->f.bits.readonly =hPtr->f.bits.readonly = 1;\n    if ((flags&JSI_OM_DONTENUM))\n        val->f.bits.dontenum =hPtr->f.bits.dontenum = 1;\n    return hPtr;\n}\n\nstatic Jsi_RC IterGetKeysCallback(Jsi_Tree* tree, Jsi_TreeEntry *hPtr, void *data)\n{\n    Jsi_IterObj *io = (Jsi_IterObj *)data;\n    if (!hPtr->f.bits.dontenum) {\n        IterObjInsert(io, hPtr);\n    }\n    return JSI_OK;\n}\n\nvoid Jsi_IterGetKeys(Jsi_Interp *interp, Jsi_Value *target, Jsi_IterObj *iterobj, int depth)\n{\n    if (!target) return;\n    if (target->vt != JSI_VT_OBJECT) {\n        if (interp->strict)\n            Jsi_LogWarn(\"operand is not a object\");\n        return;\n    }\n    Jsi_Obj *to = target->d.obj;\n    Jsi_CmdSpec *cs = NULL;\n    if (to->ot == JSI_OT_USEROBJ) {\n        Jsi_UserObj *uobj = to->d.uobj;\n        cs = uobj->reg->spec;\n    } else if (to->ot == JSI_OT_FUNCTION) {\n        Jsi_FuncObj *fobj = to->d.fobj;\n        if (fobj->func->type == FC_BUILDIN)\n            cs = fobj->func->cmdSpec;\n    }\n    if (cs) {\n        while (cs->name) {\n            IterObjInsertKey(iterobj, cs->name);\n            cs++;\n        }\n        return;\n    }\n    iterobj->depth = depth;\n    Jsi_TreeWalk(target->d.obj->tree, IterGetKeysCallback, iterobj, 0);\n    if (target->d.obj->__proto__ && target != target->d.obj->__proto__)\n        Jsi_IterGetKeys(interp, target->d.obj->__proto__, iterobj, depth+1);\n    iterobj->depth = depth;\n}\n\nJsi_Value* Jsi_ValueMakeDStringObject(Jsi_Interp *interp, Jsi_Value **vPtr, Jsi_DString *dsPtr)  {\n    Jsi_Value *v = (vPtr?*vPtr:NULL);\n    Jsi_Obj *obj;\n    if (!v)\n        v = Jsi_ValueNew(interp);\n    else {\n        assert(v->vt <= JSI_VT__MAX);\n        if (v->vt == JSI_VT_OBJECT && v->d.obj->ot == JSI_OT_STRING\n            && v->d.obj->refcnt == 1\n        ) {\n            Jsi_ObjFromDS(dsPtr, v->d.obj);\n            return v;\n        }\n        Jsi_ValueReset(interp, &v);\n    }\n    obj = Jsi_ObjNewType(interp, JSI_OT_STRING);\n    Jsi_ObjFromDS(dsPtr, obj);\n    Jsi_ValueMakeObject(interp, &v, obj);\n    return v;\n}\n\nJsi_Value* Jsi_ValueMakeObject(Jsi_Interp *interp, Jsi_Value **vPtr, Jsi_Obj *o)  {\n    Jsi_Value *v = (vPtr?*vPtr:NULL);\n    if (v && v->vt == JSI_VT_OBJECT && o == v->d.obj)\n        return v;\n    if (v)\n        Jsi_ValueReset(interp, vPtr);\n    else\n        v = Jsi_ValueNew(interp);\n    //Jsi_IncrRefCount(interp, v);\n    if (!o)\n        o = Jsi_ObjNewType(interp, JSI_OT_OBJECT);\n    v->vt = JSI_VT_OBJECT;\n    v->d.obj = o;\n    Jsi_ObjIncrRefCount(interp,v->d.obj);\n    return v;\n}\n\nJsi_Value* Jsi_ValueMakeArrayObject(Jsi_Interp *interp, Jsi_Value **vPtr, Jsi_Obj *o)  {\n    Jsi_Value *v = (vPtr?*vPtr:NULL);\n    if (!o)\n        o = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    if (!v)\n        v = Jsi_ValueNew(interp);\n    else {\n       if (v->vt == JSI_VT_OBJECT && o == v->d.obj) {\n            if (!o->isarrlist) {\n                if (o->tree)\n                    Jsi_TreeDelete( o->tree);\n                o->tree = NULL;\n                o->__proto__ = interp->Array_prototype;\n                o->isarrlist = 1;\n            }\n            return v;\n        }\n        Jsi_ValueReset(interp, vPtr);\n    }\n    v->vt = JSI_VT_OBJECT;\n    v->d.obj = o;\n    o->ot = JSI_OT_OBJECT;\n    o->__proto__ = interp->Array_prototype;\n    o->isarrlist = 1;\n    Jsi_ObjArraySizer(interp, o, 0);\n    Jsi_ObjIncrRefCount(interp,v->d.obj);\n    return v;\n}\n\nJsi_Value* Jsi_ValueMakeNumber(Jsi_Interp *interp, Jsi_Value **vPtr, Jsi_Number n) {\n    Jsi_Value *v = (vPtr?*vPtr:NULL);\n    if (!v)\n        v = Jsi_ValueNew(interp);\n    else\n        Jsi_ValueReset(interp, vPtr);\n    v->vt = JSI_VT_NUMBER;\n    v->d.num = n;\n    return v;\n}\n\nJsi_Value* Jsi_ValueMakeBool(Jsi_Interp *interp, Jsi_Value **vPtr, int b) {\n    Jsi_Value *v = (vPtr?*vPtr:NULL);\n    if (!v)\n        v = Jsi_ValueNew(interp);\n    else\n        Jsi_ValueReset(interp, vPtr);\n    v->vt = JSI_VT_BOOL;\n    v->d.val = b;\n    return v;\n}\n\nJsi_Value* Jsi_ValueMakeBlob(Jsi_Interp *interp, Jsi_Value **vPtr, unsigned char *s, int len) {\n    Jsi_Value *v = (vPtr?*vPtr:NULL);\n    if (!v)\n        v = Jsi_ValueNew(interp);\n    else\n        Jsi_ValueReset(interp, vPtr);\n    Jsi_Obj *obj = Jsi_ObjNewType(interp, JSI_OT_STRING);\n    Jsi_ValueMakeObject(interp, &v, obj);\n    obj->d.s.str = (char*)s;\n    obj->d.s.len = len;\n    obj->isBlob = 1;\n    return v;\n}\nJsi_Value* jsi_ValueMakeBlobDup(Jsi_Interp *interp, Jsi_Value **ret, unsigned char *s, int len) {\n    if (len<0) len = Jsi_Strlen((char*)s);\n    uchar *dp = (uchar*)Jsi_Malloc(len+1);\n    memcpy(dp, s, len);\n    dp[len] = 0;\n    return Jsi_ValueMakeBlob(interp, ret, dp, len);\n}\n\n\nJsi_Value* Jsi_ValueMakeString(Jsi_Interp *interp, Jsi_Value **vPtr, const char *s) {\n    return Jsi_ValueMakeBlob(interp, vPtr, (unsigned char *)s, Jsi_Strlen(s));\n}\n\nJsi_Value* Jsi_ValueMakeStringKey(Jsi_Interp *interp, Jsi_Value **vPtr, const char *s) {\n    Jsi_Value *v = (vPtr?*vPtr:NULL);\n    if (!v)\n        v = Jsi_ValueNew(interp);\n    else\n        Jsi_ValueReset(interp, vPtr);\n    v->vt = JSI_VT_STRING;\n    v->d.s.str = (char*)Jsi_KeyAdd(interp,s);\n    v->d.s.len = Jsi_Strlen(s);\n    v->f.bits.isstrkey = 1;\n    return v;\n}\n\nJsi_Value* Jsi_ValueMakeNull(Jsi_Interp *interp, Jsi_Value **vPtr) {\n    Jsi_Value *v = (vPtr?*vPtr:NULL);\n    if (!v)\n        v = Jsi_ValueNew(interp);\n    else\n        Jsi_ValueReset(interp, vPtr);\n    v->vt = JSI_VT_NULL;\n    return v;\n}\n\nJsi_Value* Jsi_ValueMakeUndef(Jsi_Interp *interp, Jsi_Value **vPtr) {\n    Jsi_Value *v = (vPtr?*vPtr:NULL);\n    if (!v)\n        v = Jsi_ValueNew(interp);\n    else {\n        if (v->vt == JSI_VT_UNDEF) return v;\n        Jsi_ValueReset(interp, vPtr);\n    }\n    return v;\n}\n\nJsi_Value* Jsi_ValueNewNumber(Jsi_Interp *interp, Jsi_Number n) {\n    Jsi_Value *v = Jsi_ValueNew(interp);\n    v->vt = JSI_VT_NUMBER;\n    v->d.num = n;\n    return v;\n}\n\nJsi_Value* Jsi_ValueNewObj(Jsi_Interp *interp, Jsi_Obj *o) {\n    Jsi_Value *v = Jsi_ValueNew(interp);\n    Jsi_ValueMakeObject(interp, &v, o);\n    return v;\n}\n\nJsi_Value* Jsi_ValueNewString(Jsi_Interp *interp, const char *s, int len) {\n    assert(s);\n    Jsi_Value *v = Jsi_ValueNew(interp);\n    Jsi_Obj *obj = Jsi_ObjNewType(interp, JSI_OT_STRING);\n    Jsi_ValueMakeObject(interp, &v, obj);\n    obj->d.s.str = (char*)s;\n    obj->d.s.len = (len<0?Jsi_Strlen(s):(uint)len);\n    return v;\n}\n\nJsi_Value* Jsi_ValueNewStringDup(Jsi_Interp *interp, const char *s) {\n    return Jsi_ValueNewString(interp, Jsi_Strdup(s), -1);\n}\n\nJsi_Value* Jsi_ValueNewStringKey(Jsi_Interp *interp, const char *s) {\n    Jsi_Value *v = Jsi_ValueNew(interp);\n    v->vt = JSI_VT_STRING;\n    v->d.s.str = (char*)Jsi_KeyAdd(interp,s);\n    v->d.s.len = Jsi_Strlen(s);\n    v->f.bits.isstrkey = 1;\n    return v;\n}\n\n\nJsi_Value* Jsi_ValueNewStringConst(Jsi_Interp *interp, const char *s, int len) {\n    Jsi_Value *v = Jsi_ValueNew(interp);\n    v->vt = JSI_VT_STRING;\n    v->d.s.str = (char*)s;\n    v->d.s.len = (len<0?Jsi_Strlen(s):(uint)len);\n    v->f.bits.isstrkey = 1;\n    return v;\n}\n\nJsi_Value* Jsi_ValueNewBlob(Jsi_Interp *interp, unsigned char *s, uint len) {\n    Jsi_Value *v = Jsi_ValueNew(interp);\n    Jsi_Obj *o = Jsi_ObjNewType(interp, JSI_OT_STRING);\n    Jsi_ValueMakeObject(interp, &v, o);\n    o->d.s.str = (char*)Jsi_Malloc(len+1);\n    memcpy(o->d.s.str, (char*)s, len);\n    o->d.s.str[len] = 0;\n    o->d.s.len = len;\n    o->isBlob = 1;\n    return v;\n}\n\nJsi_Value* Jsi_ValueNewBoolean(Jsi_Interp *interp, int bval) {\n    Jsi_Value *v = Jsi_ValueNew(interp);\n    v->vt = JSI_VT_BOOL;\n    v->d.val = bval;\n    return v;\n}\n\nJsi_Value* Jsi_ValueNewNull(Jsi_Interp *interp) {\n    Jsi_Value *v = Jsi_ValueNew(interp);\n    v->vt = JSI_VT_NULL;\n    return v;\n}\n\nJsi_Value *Jsi_ValueNewArray(Jsi_Interp *interp, const char **items, int count)\n{\n    Jsi_Obj *obj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    int i = 0;\n    if (count<0) {\n        count = 0;\n        while (items[count])\n            count++;\n    }\n    if (Jsi_ObjArraySizer(interp, obj, count) <= 0) {\n        Jsi_ObjFree(interp, obj);\n        return NULL;\n    }\n    for (i = 0; i < count; ++i) {\n        obj->arr[i] = Jsi_ValueNewStringDup(interp, items[i]);\n        Jsi_IncrRefCount(interp, obj->arr[i]);\n    }\n    obj->arrCnt = count;\n    assert(obj->arrCnt<=obj->arrMaxSize);\n    return Jsi_ValueMakeArrayObject(interp, NULL, obj);\n}\n\nJsi_Obj *Jsi_ValueGetObj(Jsi_Interp *interp, Jsi_Value* v)\n{\n    if (v->vt == JSI_VT_OBJECT) {\n        return v->d.obj;\n    }\n    return NULL;\n}\n\nint Jsi_ValueStrlen(Jsi_Value* v) {\n    //if (v->vt == JSI_VT_OBJECT && v->d.obj->ot == JSI_OT_STRING && v->d.obj->isBlob)\n    //    return v->d.obj->d.s.len;\n    Jsi_String *s = jsi_ValueString(v);\n    if (s == 0 || s->str == 0)\n        return 0;\n#if JSI__UTF8\n    return (int)Jsi_NumUtfChars(s->str, s->len);\n#else\n    if (s->len>=0) return s->len;\n    return (int)Jsi_NumUtfChars(s->str, s->len);\n#endif\n}\n\nchar *Jsi_ValueString(Jsi_Interp *interp, Jsi_Value* v, int *lenPtr)\n{\n    if (!v) return NULL;\n    Jsi_String *s = jsi_ValueString(v);\n    if (s) {\n        if (lenPtr)\n            *lenPtr = (s->len<0 ? (int)Jsi_Strlen(s->str) : s->len);\n        return s->str;\n    }\n    if (lenPtr)\n        *lenPtr = 0;\n    return NULL;\n}\n\nunsigned char *Jsi_ValueBlob(Jsi_Interp *interp, Jsi_Value* v, int *lenPtr)\n{\n    return (unsigned char*)Jsi_ValueString(interp, v, lenPtr);\n}\n\nchar* Jsi_ValueGetStringLen(Jsi_Interp *interp, Jsi_Value *pv, int *lenPtr)\n{\n    if (!pv)\n        return NULL;\n    Jsi_String *s = jsi_ValueString(pv);\n    if (!s)\n        return NULL;\n    if (lenPtr)\n        *lenPtr = (s->len<0 ? (int)Jsi_Strlen(s->str) : s->len);\n    return s->str;\n}\n\nint Jsi_ValueInstanceOf( Jsi_Interp *interp, Jsi_Value* v1, Jsi_Value* v2)\n{\n    Jsi_Value *proto, *sproto;\n    if (v1->vt != JSI_VT_OBJECT || v2->vt != JSI_VT_OBJECT  || v2->d.obj->ot != JSI_OT_FUNCTION)\n        return 0;\n    proto = Jsi_ValueObjLookup(interp, v2, \"prototype\", 0);\n    if (!proto)\n        return 0;\n    sproto = v1->d.obj->__proto__ ;\n    while (sproto) {\n        if (sproto == proto)\n            return 1;\n        if (sproto->vt != JSI_VT_OBJECT)\n            return 0;\n        sproto = sproto->d.obj->__proto__;\n    }\n    return 0;\n}\n\n\nJsi_RC jsi_InitValue(Jsi_Interp *interp, int release)\n{\n    return JSI_OK;\n}\n\nvoid  Jsi_ValueFromDS(Jsi_Interp *interp, Jsi_DString *dsPtr, Jsi_Value **ret)\n{\n    char *cp = NULL;\n    int len = Jsi_DSLength(dsPtr);\n    if (len && !(cp=(char*)dsPtr->strA)) \n        cp = Jsi_StrdupLen(dsPtr->Str, len);\n    dsPtr->strA = NULL;\n    dsPtr->Str[0] = 0;\n    dsPtr->len = 0;\n    dsPtr->spaceAvl = dsPtr->staticSize;\n    if (!cp)\n        Jsi_ValueMakeStringDup(interp, ret, \"\");\n    else\n        Jsi_ValueMakeBlob(interp, ret, (uchar*)cp, len);\n}\n\n#endif\n", "#ifndef JSI_LITE_ONLY\n#if JSI__WEBSOCKET==1\n#if JSI__MEMDEBUG\n#include \"jsiInt.h\"\n#else\n\n#ifndef JSI_AMALGAMATION\n#include \"jsi.h\"\n#ifdef JSI_WEBSOCKET_SHARED\nJSI_EXTENSION_INI\n#endif\n#endif\n\n#define jsi_Sig int\n\n#endif /* JSI__MEMDEBUG */\n\n#include <time.h>\n#include <sys/time.h>\n\n#include <ctype.h>\n\n#ifdef CMAKE_BUILD\n#include \"lws_config.h\"\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <getopt.h>\n#include <string.h>\n#include <assert.h>\n#include <limits.h>\n#include <fcntl.h>\n#ifdef WIN32\n#define _GET_TIME_OF_DAY_H\n#ifdef EXTERNAL_POLL\n    #ifndef WIN32_LEAN_AND_MEAN\n    #define WIN32_LEAN_AND_MEAN\n    #endif\n    #include <winsock2.h>\n    #include <ws2tcpip.h>\n    #include <stddef.h>\n\n    #include \"websock-w32.h\"\n#endif\n\n#else /* WIN32 */\n#include <syslog.h>\n#include <unistd.h>\n#endif /* WIN32 */\n\n#include <signal.h>\n\n#include <libwebsockets.h>\n\n//#define LWS_NO_EXTENSIONS\nstatic const int jsi_WsPkgVersion = 2;\n#ifdef EXTERNAL_POLL\nstatic int max_poll_elements;\nstatic struct pollfd *jsi_wspollfds;\nstatic int *fd_lookup;\nstatic int jsi_wsnum_pollfds;\nstatic int force_exit = 0;\n#endif /* EXTERNAL_POLL */\n\ntypedef enum {  PWS_DEAD, PWS_HTTP, PWS_CONNECTED, PWS_RECV, PWS_SENT, PWS_SENDERR } pws_state;\nenum { JWS_SIG_SYS=0xdeadf000, JWS_SIG_OBJ, JWS_SIG_PWS };\n\n#ifndef NDEBUG\n#ifndef _JSI_MEMCLEAR\n#define _JSI_MEMCLEAR(s) memset(s, 0, sizeof(*s));\n#endif\n#else\n#define _JSI_MEMCLEAR(s)\n#endif\n#define WSSIGASSERT(s,n) assert(s->sig == JWS_SIG_##n)\n\nenum {\n    /* always first */\n    JWS_PROTOCOL_HTTP = 0,\n    JWS_PROTOCOL_WEBSOCK,\n    /* always last */\n    JWS_PROTOCOL__MAX\n};\n\n#ifdef interface\n#undef interface\n#endif\n\ntypedef struct {\n  int activeCnt;  /* Count of active objects. */ \n  int newCnt;  /* Total number of new. */ \n} ws_ObjCmd;\n\nstatic ws_ObjCmd wsObjCmd = {};\n\nstatic Jsi_OptionSpec wsObjCmd_Specs[] =\n{\n    JSI_OPT(INT,   ws_ObjCmd, activeCnt, .help=\"Number of active objects\"),\n    JSI_OPT(INT,   ws_ObjCmd, newCnt,    .help=\"Number of new calls\"),\n    JSI_OPT_END(ws_ObjCmd, .help=\"Options for WebSocket module\")\n};\n\ntypedef struct {\n    int sentCnt, recvCnt, recvErrCnt, sentErrCnt, httpCnt, uploadCnt;\n    time_t sentLast, recvLast, recvErrLast, sentErrLast, httpLast,\n        createTime, uploadStart, uploadLast, uploadEnd, redirLast, eventLast;\n    int msgQLen;\n    int redirCnt;\n    int eventCnt;\n    int connectCnt;\n    bool isBinary, isFinal;\n} jsi_wsStatData;\n\ntypedef struct { /* Per server data (or client if client-mode). */\n    uint sig;\n    Jsi_Interp *interp;\n    ws_ObjCmd *_;\n    Jsi_Hash *pssTable, *handlers, *fileHash;\n    Jsi_Value *onAuth, *onCloseLast, *onClose, *onFilter, *onOpen, *onRecv,\n        *onUpload, *onGet, *onUnknown, *onModify, *pathAliases, *udata,\n        *rootdir, *interface, *address, *mimeTypes, *extOpts, *headers, *ssiExts;\n    bool client, noUpdate, noWebsock, noWarn, use_ssl, local, extHandlers, handlersPkg, inUpdate, noCompress, noConfig, echo;\n    Jsi_Value* version;\n    int idx;\n    int port;\n    uint modifySecs;\n    int maxUpload;\n    int maxDownload;\n    int bufferPwr2;\n    jsi_wsStatData stats;\n    char *iface;\n    const char* urlPrefix, *urlRedirect;\n    const char *localhostName;\n    const char *clientName;\n    const char *clientIP;\n    const char *useridPass, *server;\n    const char *realm, *includeFile, *jsiFnPattern, *jsishPathCache;\n    struct lws_context *instCtx;\n    Jsi_Value *getRegexp, *post;\n    unsigned int oldus;\n    int opts;\n    int hasOpts;\n    int debug;\n    int maxConnects;\n    int deleted;\n    int close_test;\n    int createCnt;\n    int redirAllCnt;\n    bool redirMax;\n    int redirDisable;\n    int recvBufMax;\n    int recvBufCnt;\n    int recvBufTimeout;\n    int lastRevCnt; // For update\n    time_t createLast;\n    time_t startTime;\n    time_t lastModifyCheck, lastModifyNotify;\n    char *cmdName;\n    struct lws *wsi_choked[20];\n    int num_wsi_choked;\n    struct lws *wsi;\n\n    struct lws_context *context;\n    struct lws_context_creation_info info;\n    Jsi_Event *event;\n    Jsi_Obj *fobj;\n    int objId;\n    const char *protocol;\n    struct lws_protocols protocols[JWS_PROTOCOL__MAX+1];\n    int ietf_version;\n    char *ssl_cert_filepath;\n    char *ssl_private_key_filepath;\n    int ws_uid;\n    int ws_gid;\n    const char *clientHost;\n    const char *clientOrigin;\n    const char *formParams;\n    const char *curRoot;\n    int sfd;        // File descriptor for http.\n    Jsi_DString cName;\n} jsi_wsCmdObj;\n\ntypedef struct { /* Per session connection (to each server) */\n    uint sig;\n    jsi_wsCmdObj *cmdPtr;\n    pws_state state;\n    jsi_wsStatData stats;\n    struct lws *wsi;\n    Jsi_HashEntry *hPtr;\n    Jsi_Value* username;\n    void *user;\n    int cnt;\n    //int fd;\n    lws_fop_fd_t fop_fd;\n    int wid;\n    //int sfd;\n    bool isWebsock, echo;\n    const char *clientName;\n    const char *clientIP;\n    int hdrSz[200]; // Space for up to 100 headers\n    int hdrNum;     // Num of above.\n    time_t deferDel; // TODO: defer delete if output via SSI echo ${#}.\n    // Pointers to reset.\n    Jsi_DString dHdrs; // Store header string here.\n    Jsi_Stack *stack;\n    Jsi_DString recvBuf; // To buffer recv when recvJSON is true.\n    Jsi_Value *onClose, *onFilter, *onRecv, *onUpload, *onGet, *onUnknown, *rootdir, *headers;\n    char *lastData;\n    char key[100]; // Lookup key.\n#if (LWS_LIBRARY_VERSION_MAJOR>1)\n    char filename[PATH_MAX];\n    long file_length;\n    struct lws_spa *spa;\n    Jsi_DString resultStr, paramDS, url;\n    Jsi_Value *udata, *query;\n    Jsi_Value *queryObj;\n    Jsi_RC resultCode;\n    char **paramv;\n    int paramc;\n#endif\n} jsi_wsPss;\n\ntypedef struct {\n    int unused;\n} jsi_wsUser;\n\ntypedef struct {\n    Jsi_Value *val, *objVar;\n    int triedLoad;\n    int flags;\n} jsi_wsHander;\n\ntypedef struct {\n    Jsi_Value *fileVal;\n    time_t loadLast, loadFirst;\n    int flags;\n} jsi_wsFile;\n\nstatic const char* const jsi_wsparam_names[] = { \"text\", \"send\", \"file\", \"upload\" };\nstatic const char* jsi_wsparam_str = \"text,send,file,upload\";\n\n#ifndef jsi_IIOF\n#define jsi_IIOF .flags=JSI_OPT_INIT_ONLY\n#define jsi_IIRO .flags=JSI_OPT_READ_ONLY\n#endif\n\nstatic Jsi_OptionSpec WPSStats[] =\n{\n    JSI_OPT(INT,        jsi_wsStatData, connectCnt,   .help=\"Number of active connections\", jsi_IIRO),\n    JSI_OPT(TIME_T,     jsi_wsStatData, createTime,   .help=\"Time created\"),\n    JSI_OPT(INT,        jsi_wsStatData, eventCnt,     .help=\"Number of events of any type\"),\n    JSI_OPT(TIME_T,     jsi_wsStatData, eventLast,    .help=\"Time of last event of any type\"),\n    JSI_OPT(INT,        jsi_wsStatData, httpCnt,      .help=\"Number of http reqs\"),\n    JSI_OPT(TIME_T,     jsi_wsStatData, httpLast,     .help=\"Time of last http reqs\"),\n    JSI_OPT(BOOL,       jsi_wsStatData, isBinary,     .help=\"Connection recv data is binary\", jsi_IIRO),\n    JSI_OPT(BOOL,       jsi_wsStatData, isFinal,      .help=\"Final data for current message was recieved\", jsi_IIRO),\n    JSI_OPT(INT,        jsi_wsStatData, msgQLen,      .help=\"Number of messages in input queue\", jsi_IIRO),\n    JSI_OPT(INT,        jsi_wsStatData, recvCnt,      .help=\"Number of recieves\", jsi_IIRO),\n    JSI_OPT(TIME_T,     jsi_wsStatData, recvLast,     .help=\"Time of last recv\", jsi_IIRO),\n    JSI_OPT(TIME_T,     jsi_wsStatData, redirLast,    .help=\"Time of last redirect\", jsi_IIRO),\n    JSI_OPT(INT,        jsi_wsStatData, redirCnt,     .help=\"Count of redirects\", jsi_IIRO),\n    JSI_OPT(INT,        jsi_wsStatData, sentCnt,      .help=\"Number of sends\", jsi_IIRO),\n    JSI_OPT(TIME_T,     jsi_wsStatData, sentLast,     .help=\"Time of last send\", jsi_IIRO),\n    JSI_OPT(INT,        jsi_wsStatData, sentErrCnt,   .help=\"Number of sends\", jsi_IIRO),\n    JSI_OPT(TIME_T,     jsi_wsStatData, sentErrLast,  .help=\"Time of last sendErr\", jsi_IIRO),\n    JSI_OPT(TIME_T,     jsi_wsStatData, sentErrLast,  .help=\"Time of last sendErr\", jsi_IIRO),\n    JSI_OPT(INT,        jsi_wsStatData, uploadCnt,    .help=\"Number of uploads\", jsi_IIRO),\n    JSI_OPT(TIME_T,     jsi_wsStatData, uploadEnd,    .help=\"Time of upload end\", jsi_IIRO),\n    JSI_OPT(TIME_T,     jsi_wsStatData, uploadLast,   .help=\"Time of last upload input\", jsi_IIRO),\n    JSI_OPT(TIME_T,     jsi_wsStatData, uploadStart,  .help=\"Time of upload start\", jsi_IIRO),\n    JSI_OPT_END(jsi_wsStatData, .help=\"Per-connection statistics\")\n};\n\nstatic Jsi_OptionSpec WPSOptions[] =\n{\n    JSI_OPT(STRKEY,     jsi_wsPss, clientIP,    .help=\"Client IP Address\", jsi_IIRO),\n    JSI_OPT(STRKEY,     jsi_wsPss, clientName,  .help=\"Client hostname\", jsi_IIRO),\n    JSI_OPT(BOOL,       jsi_wsPss, echo,        .help=\"LogInfo outputs all websock Send/Recv messages\"),\n    JSI_OPT(ARRAY,      jsi_wsPss, headers,     .help=\"Headers to send to browser on connection: name/value pairs\"),\n    JSI_OPT(BOOL,       jsi_wsPss, isWebsock,   .help=\"Is a websocket connection\" ),\n    JSI_OPT(STRBUF,     jsi_wsPss, key,         .help=\"String key lookup in ids command for SSI echo ${#}\", jsi_IIRO),\n    JSI_OPT(FUNC,       jsi_wsPss, onClose,     .help=\"Function to call when the websocket connection closes\", .flags=0, .custom=0, .data=(void*)\"ws:userobj|null, id:number\"),\n    JSI_OPT(FUNC,       jsi_wsPss, onGet,       .help=\"Function to call to server handle http-get\", .flags=0, .custom=0, .data=(void*)\"ws:userobj, id:number, url:string, query:array\"),\n    JSI_OPT(FUNC,       jsi_wsPss, onUnknown,   .help=\"Function to call to server out content when no file exists\", .flags=0, .custom=0, .data=(void*)\"ws:userobj, id:number, url:string, args:array\"),\n    JSI_OPT(FUNC,       jsi_wsPss, onRecv,      .help=\"Function to call when websock data recieved\", .flags=0, .custom=0, .data=(void*)\"ws:userobj, id:number, data:string\"),\n    JSI_OPT(FUNC,       jsi_wsPss, onUpload,    .help=\"Function to call handle http-post\", .flags=0, .custom=0, .data=(void*)\"ws:userobj, id:number, filename:string, data:string, startpos:number, complete:boolean\"),\n    JSI_OPT(STRING,     jsi_wsPss, rootdir,     .help=\"Directory to serve html from (\\\".\\\")\"),\n    JSI_OPT(CUSTOM,     jsi_wsPss, stats,       .help=\"Statistics for connection\", jsi_IIRO, .custom=Jsi_Opt_SwitchSuboption, .data=WPSStats),\n    JSI_OPT(ARRAY,      jsi_wsPss, query,       .help=\"Uri arg values for connection\"),\n    JSI_OPT(OBJ,        jsi_wsPss, queryObj,    .help=\"Uri arg values for connection as an object\"),\n    JSI_OPT(OBJ,        jsi_wsPss, udata,       .help=\"User data\"),\n    JSI_OPT(DSTRING,    jsi_wsPss, url,         .help=\"Url for connection\"),\n    JSI_OPT(STRING,     jsi_wsPss, username,    .help=\"The login userid for this connection\"),\n    JSI_OPT_END(jsi_wsPss, .help=\"Per-connection options\")\n};\n\nstatic Jsi_OptionSpec WSOptions[] =\n{\n    JSI_OPT(STRING, jsi_wsCmdObj, address,    .help=\"In client-mode the address to connect to (127.0.0.1)\" ),\n    JSI_OPT(INT,    jsi_wsCmdObj, bufferPwr2, .help=\"Tune the recv/send buffer: value is a power of 2 in [0-20] (16)\"),\n    JSI_OPT(BOOL,   jsi_wsCmdObj, client,     .help=\"Run in client mode\", jsi_IIOF),\n    JSI_OPT(STRKEY, jsi_wsCmdObj, clientHost, .help=\"Override host name for client\"),\n    JSI_OPT(STRKEY, jsi_wsCmdObj, clientOrigin,.help=\"Override client origin (origin)\"),\n    JSI_OPT(INT,    jsi_wsCmdObj, debug,      .help=\"Set debug level. Setting this to 512 will turn on max libwebsocket log levels\"),\n    JSI_OPT(BOOL,   jsi_wsCmdObj, echo,       .help=\"LogInfo outputs all websock Send/Recv messages\"),\n    JSI_OPT(STRKEY, jsi_wsCmdObj, formParams, .help=\"Comma seperated list of upload form param names ('text,send,file,upload')\", jsi_IIRO),\n    JSI_OPT(BOOL,   jsi_wsCmdObj, extHandlers,.help=\"Setup builtin extension-handlers, ie: .htmli, .cssi, .jsi, .mdi\", jsi_IIOF),\n    JSI_OPT(OBJ,    jsi_wsCmdObj, extOpts,    .help=\"Key/value store for extension-handlers options\", jsi_IIOF),\n    JSI_OPT(REGEXP, jsi_wsCmdObj, getRegexp,  .help=\"Call onGet() only if Url matches pattern\"),\n//    JSI_OPT(CUSTOM, jsi_wsCmdObj, handlersPkg,.help=\"Handlers use package() to upgrade string to function object\"),\n    JSI_OPT(ARRAY,  jsi_wsCmdObj, headers,    .help=\"Headers to send to browser: name/value pairs\", jsi_IIOF),\n    JSI_OPT(STRKEY, jsi_wsCmdObj, jsiFnPattern,.help=\"A glob-match pattern for files to which is appended 'window.jsiWebSocket=true;' (jsig*.js)\", jsi_IIRO),\n    JSI_OPT(STRING, jsi_wsCmdObj, interface,  .help=\"Interface for server to listen on, eg. 'eth0' or 'lo'\", jsi_IIOF),\n    JSI_OPT(BOOL,   jsi_wsCmdObj, local,      .help=\"Limit connections to localhost addresses on the 127 network\"),\n    JSI_OPT(STRKEY, jsi_wsCmdObj, localhostName,.help=\"Client name used by localhost connections ('localhost')\"),\n    JSI_OPT(INT,    jsi_wsCmdObj, maxConnects,.help=\"In server mode, max number of client connections accepted\"),\n    JSI_OPT(INT,    jsi_wsCmdObj, maxDownload,.help=\"Max size of file download\"),\n    JSI_OPT(INT,    jsi_wsCmdObj, maxUpload,  .help=\"Max size of file upload will accept\"),\n    JSI_OPT(OBJ,    jsi_wsCmdObj, mimeTypes,  .help=\"Object providing map of file extensions to mime types. eg. {txt:'text/plain', bb:'text/bb'}\", jsi_IIOF),\n    JSI_OPT(UINT,   jsi_wsCmdObj, modifySecs, .help=\"Seconds between checking for modified files with onModify (2)\"),\n    JSI_OPT(BOOL,   jsi_wsCmdObj, noConfig,   .help=\"Disable use of conf() to change options after options after create\", jsi_IIOF),\n    JSI_OPT(BOOL,   jsi_wsCmdObj, noCompress, .help=\"Disable per-message-deflate extension which can truncate large msgs\"),\n    JSI_OPT(BOOL,   jsi_wsCmdObj, noUpdate,   .help=\"Disable update event-processing (eg. to exit)\"),\n    JSI_OPT(BOOL,   jsi_wsCmdObj, noWebsock,  .help=\"Serve html, but disallow websocket upgrade\", jsi_IIOF),\n    JSI_OPT(BOOL,   jsi_wsCmdObj, noWarn,     .help=\"Quietly ignore file related errors\"),\n    JSI_OPT(FUNC,   jsi_wsCmdObj, onAuth,     .help=\"Function to call for http basic authentication\", .flags=0, .custom=0, .data=(void*)\"ws:userobj, id:number, url:string, userpass:string\"),\n    JSI_OPT(FUNC,   jsi_wsCmdObj, onClose,    .help=\"Function to call when the websocket connection closes\", .flags=0, .custom=0, .data=(void*)\"ws:userobj|null, id:number\"),\n    JSI_OPT(FUNC,   jsi_wsCmdObj, onCloseLast,.help=\"Function to call when last websock connection closes. On object delete arg is null\", .flags=0, .custom=0, .data=(void*)\"ws:userobj|null\"),\n    JSI_OPT(FUNC,   jsi_wsCmdObj, onFilter,   .help=\"Function to call on a new connection: return false to kill connection\", .flags=0, .custom=0, .data=(void*)\"ws:userobj, id:number, url:string, ishttp:boolean\"),\n    JSI_OPT(FUNC,   jsi_wsCmdObj, onGet,      .help=\"Function to call to server handle http-get\", .flags=0, .custom=0, .data=(void*)\"ws:userobj, id:number, url:string, query:array\"),\n    JSI_OPT(FUNC,   jsi_wsCmdObj, onModify,   .help=\"Function to call when a served-out-file is modified\", jsi_IIOF, .custom=0, .data=(void*)\"ws:userobj, file:string\"),\n    JSI_OPT(FUNC,   jsi_wsCmdObj, onOpen,     .help=\"Function to call when the websocket connection occurs\", .flags=0, .custom=0, .data=(void*)\"ws:userobj, id:number\"),\n    JSI_OPT(FUNC,   jsi_wsCmdObj, onUnknown,  .help=\"Function to call to server out content when no file exists\", .flags=0, .custom=0, .data=(void*)\"ws:userobj, id:number, url:string, query:array\"),\n    JSI_OPT(FUNC,   jsi_wsCmdObj, onUpload,   .help=\"Function to call handle http-post\", .flags=0, .custom=0, .data=(void*)\"ws:userobj, id:number, filename:string, data:string, startpos:number, complete:boolean\"),\n    JSI_OPT(FUNC,   jsi_wsCmdObj, onRecv,     .help=\"Function to call when websock data recieved\", .flags=0, .custom=0, .data=(void*)\"ws:userobj, id:number, data:string\"),\n    JSI_OPT(OBJ,    jsi_wsCmdObj, pathAliases,.help=\"Path alias lookups\", jsi_IIOF),\n    JSI_OPT(INT,    jsi_wsCmdObj, port,       .help=\"Port for server to listen on (8080)\", jsi_IIOF),\n    JSI_OPT(STRING, jsi_wsCmdObj, post,       .help=\"Post string to serve\", jsi_IIOF),\n    JSI_OPT(STRKEY, jsi_wsCmdObj, protocol,   .help=\"Name of protocol (ws/wss)\"),\n    JSI_OPT(STRKEY, jsi_wsCmdObj, realm,      .help=\"Realm for basic auth (jsish)\", ),\n    JSI_OPT(INT,    jsi_wsCmdObj, recvBufMax, .help=\"Size limit of a websocket message\", jsi_IIOF),\n    JSI_OPT(INT,    jsi_wsCmdObj, recvBufTimeout,.help=\"Timeout for recv of a websock msg\", jsi_IIOF),\n    JSI_OPT(BOOL,   jsi_wsCmdObj, redirMax,   .help=\"Temporarily disable redirects when see more than this in 10 minutes\"),\n    JSI_OPT(STRING, jsi_wsCmdObj, rootdir,    .help=\"Directory to serve html from (\\\".\\\")\"),\n    JSI_OPT(STRKEY, jsi_wsCmdObj, server,     .help=\"String to send out int the header SERVER (jsiWebSocket)\"),\n    JSI_OPT(OBJ,    jsi_wsCmdObj, ssiExts,    .help=\"Object map of file extensions to apply SSI.  eg. {myext:true, shtml:false} \", jsi_IIOF),\n    JSI_OPT(CUSTOM, jsi_wsCmdObj, stats,      .help=\"Statistical data\", jsi_IIRO, .custom=Jsi_Opt_SwitchSuboption, .data=WPSStats),\n    JSI_OPT(TIME_T, jsi_wsCmdObj, startTime,  .help=\"Time of websocket start\", jsi_IIRO),\n    JSI_OPT(STRKEY, jsi_wsCmdObj, includeFile,.help=\"Default file when no extension given (include.shtml)\"),\n    JSI_OPT(OBJ,    jsi_wsCmdObj, udata,      .help=\"User data\"),\n    JSI_OPT(STRKEY, jsi_wsCmdObj, urlPrefix,  .help=\"Prefix in url to strip from path; for reverse proxy\"),\n    JSI_OPT(STRKEY, jsi_wsCmdObj, urlRedirect,.help=\"Redirect when no url or / is given. Must match urlPrefix, if given\"),\n    JSI_OPT(BOOL,   jsi_wsCmdObj, use_ssl,    .help=\"Use https (for client)\", jsi_IIOF),\n    JSI_OPT(STRKEY, jsi_wsCmdObj, useridPass, .help=\"The USERID:PASSWORD to use for basic authentication\"),\n    JSI_OPT(OBJ,    jsi_wsCmdObj, version,    .help=\"WebSocket version info\", jsi_IIRO),\n    JSI_OPT_END(jsi_wsCmdObj, .help=\"Websocket options\")\n};\n\nstatic Jsi_RC jsi_wswebsocketObjFree(Jsi_Interp *interp, void *data);\nstatic bool jsi_wswebsocketObjIsTrue(void *data);\nstatic bool jsi_wswebsocketObjEqual(void *data1, void *data2);\nstatic void jsi_wswebsocketObjErase(jsi_wsCmdObj *cmdPtr);\n\n/* this protocol server (always the first one) just knows how to do HTTP */\n\nstatic int\njsi_wscallback_http(struct lws *wsi,\n      enum lws_callback_reasons reason,\n      void *user, void *in, size_t len);\nstatic int\njsi_wscallback_websock(struct lws *wsi,\n      enum lws_callback_reasons reason,\n      void *user, void *in, size_t len);\n      \nstatic Jsi_RC jsi_wsfreeFile(Jsi_Interp *interp, Jsi_HashEntry* hPtr, void *ptr);\nstatic bool jsi_wsAddHeader(Jsi_Interp *interp, jsi_wsCmdObj *cmdPtr, struct lws *wsi, Jsi_Value *hdrs,\n    Jsi_DString *hStr);\n    \n// Allocate per-connection data using file descriptor.\nstatic jsi_wsPss*\njsi_wsgetPss(jsi_wsCmdObj *cmdPtr, struct lws *wsi, void *user, int create, int ishttp)\n{\n    Jsi_HashEntry *hPtr;\n    bool isNew = 0;\n    jsi_wsPss *pss = NULL;\n    if (user==NULL)\n        return NULL;\n    int sfd = lws_get_socket_fd(wsi);\n    if (sfd<0) {\n        return NULL;\n    }\n    int sid = ((sfd<<1)|ishttp);\n    if (create)\n        hPtr = Jsi_HashEntryNew(cmdPtr->pssTable, (void*)(intptr_t)sid, &isNew);\n    else\n        hPtr = Jsi_HashEntryFind(cmdPtr->pssTable, (void*)(intptr_t)sid);\n\n    if (hPtr && !isNew)\n        pss = (typeof(pss))Jsi_HashValueGet(hPtr);\n\n    if (!pss) {\n        if (!create)\n            return NULL;\n        pss = (typeof(pss))Jsi_Calloc(1, sizeof(*pss));\n        Jsi_HashValueSet(hPtr, pss);\n        pss->sig = JWS_SIG_PWS;\n        pss->hPtr = hPtr;\n        Jsi_HashValueSet(hPtr, pss);\n        pss->cmdPtr = cmdPtr;\n        pss->wsi = wsi;\n        pss->user = user; /* unused. */\n        pss->state = PWS_CONNECTED;\n        pss->stats.createTime = time(NULL);\n        pss->cnt = cmdPtr->idx++;\n        pss->wid = sid;\n        //pss->sfd = sfd;\n        pss->udata = Jsi_ValueNewObj(cmdPtr->interp, NULL);\n        Jsi_IncrRefCount(cmdPtr->interp, pss->udata);\n\n        if (cmdPtr->debug>2)\n            fprintf(stderr, \"PSS CREATE: %p/%p/%p (http=%d) = %d\\n\", pss, user, wsi, ishttp, sid);\n        if (!ishttp) {\n            pss->isWebsock = 1;\n            cmdPtr->stats.connectCnt++;\n            cmdPtr->createCnt++;\n            cmdPtr->createLast = time(NULL);\n        }\n    }\n    if (pss) {\n        WSSIGASSERT(pss, PWS);\n        pss->stats.eventCnt++;\n        pss->stats.eventLast = time(NULL);\n        cmdPtr->stats.eventCnt++;\n        cmdPtr->stats.eventLast = time(NULL);\n    }\n    return pss;\n}\n\nstatic Jsi_RC jsi_wsDelPss(Jsi_Interp *interp, void *data) {\n    Jsi_Free(data);\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_wsrecv_flush(jsi_wsCmdObj *cmdPtr, jsi_wsPss *pss);\n\nstatic void\njsi_wsdeletePss(jsi_wsPss *pss)\n{\n    jsi_wsCmdObj*cmdPtr = pss->cmdPtr;\n    if (pss->sig == 0)\n        return;\n    WSSIGASSERT(pss, PWS);\n    if (pss->state == PWS_DEAD)\n        return;\n    if (cmdPtr && cmdPtr->debug>3)\n        fprintf(stderr, \"PSS DELETE: %p\\n\", pss);\n\n    jsi_wsrecv_flush(cmdPtr, pss);\n    if (pss->hPtr) {\n        Jsi_HashValueSet(pss->hPtr, NULL);\n        Jsi_HashEntryDelete(pss->hPtr);\n        pss->hPtr = NULL;\n    }\n    Jsi_Interp *interp = cmdPtr->interp;\n    if (pss->stack) {\n        Jsi_StackFreeElements(interp, pss->stack, jsi_wsDelPss);\n        Jsi_StackFree(pss->stack);\n    }\n    Jsi_DSFree(&pss->dHdrs);\n    if (pss->isWebsock)\n        pss->cmdPtr->stats.connectCnt--;\n    Jsi_OptionsFree(cmdPtr->interp, WPSOptions, pss, 0);\n    pss->state = PWS_DEAD;\n    Jsi_DSFree(&pss->resultStr);\n    Jsi_DSFree(&pss->paramDS);\n    if (pss->lastData)\n        Jsi_Free(pss->lastData);\n    pss->lastData = NULL;\n    if (pss->spa)\n        lws_spa_destroy(pss->spa);\n    Jsi_Free(pss);\n}\n\nstatic int jsi_wswrite(jsi_wsPss* pss, struct lws *wsi, unsigned char *buf, int len, enum lws_write_protocol proto)\n{\n    jsi_wsCmdObj *cmdPtr = pss->cmdPtr;\n    int m = lws_write(wsi, buf, len, proto);\n    if (m >= 0) {\n        cmdPtr->stats.sentCnt++;\n        cmdPtr->stats.sentLast = time(NULL);\n        pss->stats.sentCnt++;\n        pss->stats.sentLast = time(NULL);\n    } else {\n        pss->state = PWS_SENDERR;\n        pss->stats.sentErrCnt++;\n        pss->stats.sentErrLast = time(NULL);\n        cmdPtr->stats.sentErrCnt++;\n        cmdPtr->stats.sentErrLast = time(NULL);\n    }\n    return m;\n}\n\nstatic int jsi_wsServeHeader(jsi_wsPss *pss, struct lws *wsi, int strLen,\n    int code, const char *extra, const char *mime, Jsi_DString *jStr)\n{\n    uchar ubuf[JSI_BUFSIZ], *p=ubuf, *end = &ubuf[sizeof(ubuf)-1];\n    if (!mime) mime = \"text/html\";\n    if (code<=0) code = 200;\n    if (lws_add_http_header_status(wsi, code, &p, end))\n        return -1;\n    const char *srv = pss->cmdPtr->server;\n    if (!srv) srv = \"jsiWebSocket\";\n    if (srv[0] && lws_add_http_header_by_token(wsi, WSI_TOKEN_HTTP_SERVER, (uchar*)srv, Jsi_Strlen(srv), &p, end))\n        return -1;\n    if (lws_add_http_header_by_token(wsi, WSI_TOKEN_HTTP_CONTENT_TYPE, (uchar *)mime, Jsi_Strlen(mime), &p, end))\n        return -1;\n    if (lws_add_http_header_content_length(wsi, strLen, &p, end))\n        return -1;\n    *p = 0;\n    Jsi_DSAppend(jStr, (char*)ubuf, extra, NULL);\n    p = ubuf;\n    if (lws_finalize_http_header(wsi, &p, end))\n        return -1;\n    *p = 0;\n    Jsi_DSAppend(jStr, (char*)ubuf, NULL);\n    return 0;\n}\n\nstatic int jsi_wsServeString(jsi_wsPss *pss, struct lws *wsi,\n    const char *buf, int code, const char *extra, const char *mime)\n{\n    int strLen = Jsi_Strlen(buf);\n    Jsi_DString jStr = {};\n    int rc = jsi_wsServeHeader(pss, wsi, strLen, code, extra, mime, &jStr);\n    if (rc>=0) {\n        Jsi_DSAppend(&jStr, buf, NULL);\n        char *vStr = Jsi_DSValue(&jStr);\n        int vLen = Jsi_DSLength(&jStr);\n        rc = jsi_wswrite(pss, wsi, (unsigned char*)vStr, vLen, LWS_WRITE_HTTP);\n    }\n    Jsi_DSFree(&jStr);\n    return (rc>=0?1:0);\n}\n\nstatic const char*\njsi_wsHeader(jsi_wsPss *pss, const char *name, int *lenPtr)\n{\n    int i, nlen = Jsi_Strlen(name);\n    const char *ret = NULL, *cp = Jsi_DSValue(&pss->dHdrs);\n    for (i=0; i<pss->hdrNum; i+=2) {\n        int sz = pss->hdrSz[i];\n        int mat = (!Jsi_Strncasecmp(cp, name, nlen) && cp[nlen]=='=');\n        cp += 1 + sz;\n        if (mat) {\n            ret = cp;\n            if (lenPtr)\n                *lenPtr = pss->hdrSz[i+1];\n            break;\n        }\n        cp += (1 + pss->hdrSz[i+1]);\n    }\n    return ret;\n}\n\n\nstatic int\njsi_wsGetHeaders(jsi_wsPss *pss, struct lws *wsi, Jsi_DString* dStr, int lens[], int hmax)\n{\n    int n = 0, i = 0, nlen;\n    char buf[1000];\n    const char *cp;\n    while ((cp = (char*)lws_token_to_string((enum lws_token_indexes)n))) {\n        int len = lws_hdr_copy(wsi, buf, sizeof(buf), ( enum lws_token_indexes)n);\n        n++;\n        if (i>=(n*2+2)) break;\n        if (len<=0) continue;\n        buf[sizeof(buf)-1] = 0;\n        if (!buf[0]) continue;\n        nlen = Jsi_Strlen(cp);\n        if (nlen>0 && cp[nlen-1]==' ') nlen--;\n        if (nlen>0 && cp[nlen-1]==':') nlen--;\n        Jsi_DSAppendLen(dStr, cp, nlen);\n        Jsi_DSAppend(dStr, \"=\", buf, \"\\n\", NULL);\n        if (lens) {\n            lens[i++] = nlen;\n            lens[i++] = Jsi_Strlen(buf);\n        }\n    }\n    //printf(\"HEE: %d = %s\\n\", pss->wid, Jsi_DSValue(dStr) );\n    return i;\n}\n\nstatic void jsi_wsDumpHeaders(jsi_wsCmdObj *cmdPtr, jsi_wsPss *pss, const char *name, Jsi_Value **ret)\n{\n    Jsi_Interp *interp = cmdPtr->interp;\n    Jsi_Obj *nobj;\n    Jsi_Value *nv;\n    if (pss->hdrNum<=0)\n        return;\n    if (!name) {\n        nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n        Jsi_ValueMakeObject(interp, ret, nobj);\n        int nsiz = Jsi_ObjArraySizer(interp, nobj, pss->hdrNum);\n        if (nsiz < pss->hdrNum) {\n            printf(\"header failed, %d != %d\", nsiz, pss->hdrNum);\n            return;\n        }\n    }\n    Jsi_DString dStr = {}, vStr = {};\n    int i;\n    const char *nam, *val, *cp = Jsi_DSValue(&pss->dHdrs);\n    for (i=0; i<pss->hdrNum; i+=2) {\n        int sz = pss->hdrSz[i], sz2 = pss->hdrSz[i+1];\n        Jsi_DSSetLength(&dStr, 0);\n        Jsi_DSSetLength(&vStr, 0);\n        nam = Jsi_DSAppendLen(&dStr, cp, sz);\n        cp += 1 + sz;\n        val = Jsi_DSAppendLen(&vStr, cp, sz2);\n        if (name) {\n            if (!Jsi_Strcmp(nam, name)) {\n                Jsi_ValueMakeStringDup(interp, ret, val);\n                break;\n            }\n        } else {\n            nv = Jsi_ValueNewStringDup(interp, val);\n            Jsi_ObjArraySet(interp, nobj, Jsi_ValueNewStringDup(interp, nam), i);\n            Jsi_ObjArraySet(interp, nobj, nv, i+1);\n        }\n        cp += (1 + sz2);\n    }\n    Jsi_DSFree(&dStr);\n    Jsi_DSFree(&vStr);\n}\n\nstatic void jsi_wsDumpQuery(jsi_wsCmdObj *cmdPtr, jsi_wsPss *pss, const char *name, Jsi_Value **ret)\n{\n    int n = 0;\n    Jsi_Interp *interp = cmdPtr->interp;\n    Jsi_Obj *nobj;\n    Jsi_Value *nv;\n    if (!name) {\n        nobj = Jsi_ObjNewType(interp, JSI_OT_OBJECT);\n        Jsi_ValueMakeObject(interp, ret, nobj);\n    }\n    for (n = 0; n<pss->paramc; n++) {\n        const char *cp = lws_spa_get_string(pss->spa, n);\n        if (!cp) cp = \"\";\n        if (name) {\n            if (Jsi_Strcmp(name, pss->paramv[n])) { n++; continue; }\n            Jsi_ValueMakeStringDup(interp, ret, cp);\n            return;\n        }\n        nv = Jsi_ValueNewStringDup(interp, cp);\n        Jsi_ObjInsert(interp, nobj, pss->paramv[n], nv, 0);\n    }\n}\n\nstatic void jsi_wsgetUriArgValue(Jsi_Interp *interp, struct lws *wsi, Jsi_Value **vPtr, Jsi_Value **oPtr)\n{\n    int n = 0;\n    char buf[JSI_BUFSIZ*8];\n    while (lws_hdr_copy_fragment(wsi, buf, sizeof(buf), WSI_TOKEN_HTTP_URI_ARGS, n++) > 0) {\n        if (!*vPtr) {\n            *vPtr = Jsi_ValueNewArray(interp, NULL, 0);\n            Jsi_IncrRefCount(interp, *vPtr);\n        }\n        Jsi_ValueArraySet(interp, *vPtr, Jsi_ValueNewStringDup(interp, buf), n-1);\n        if (!*oPtr) {\n            *oPtr = Jsi_ValueNewObj(interp, NULL);\n            Jsi_IncrRefCount(interp, *oPtr);\n        }\n        char *cp = Jsi_Strchr(buf, '=');\n        if (cp) {\n            *cp = 0;\n            Jsi_ValueInsertFixed(interp, *oPtr, buf, Jsi_ValueNewStringDup(interp, cp+1));\n        } else {\n            Jsi_ValueInsertFixed(interp, *oPtr, buf, Jsi_ValueNewNull(interp));\n        }\n    }\n}\n\nstatic Jsi_RC jsi_wsGetCmd(Jsi_Interp *interp, jsi_wsCmdObj *cmdPtr, jsi_wsPss* pss, struct lws *wsi,\n    const char *inPtr, Jsi_Value *cmd, Jsi_DString *tStr)\n{\n    Jsi_RC jrc;\n    Jsi_Value *retStr = Jsi_ValueNew1(interp);\n    // 4 args: ws, id, url, query\n    Jsi_Value *vpargs, *vargs[10];\n    int n = 0;\n    if (cmdPtr->deleted) return JSI_ERROR;\n    vargs[n++] = Jsi_ValueNewObj(interp, cmdPtr->fobj);\n    vargs[n++] = Jsi_ValueNewNumber(interp, (Jsi_Number)(pss?pss->wid:0));\n    vargs[n++]  = Jsi_ValueNewStringDup(interp, inPtr);\n    vargs[n++]  = (pss->query?pss->query:Jsi_ValueNewArray(interp, NULL, 0));\n    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, vargs, n, 0));\n    Jsi_IncrRefCount(interp, vpargs);\n    jrc = Jsi_FunctionInvoke(interp, cmd, vpargs, &retStr, NULL);\n    Jsi_DecrRefCount(interp, vpargs);\n    if (Jsi_InterpGone(interp))\n        return JSI_ERROR;\n    Jsi_DString dStr = {};\n    const char *rstr = \"\";\n    if (jrc != JSI_OK)\n        rstr = \"Error\";\n    else if (Jsi_ValueIsFalse(interp, retStr)) {\n        rstr = \"Access denied\";\n        jrc = JSI_ERROR;\n    } else\n        rstr = Jsi_ValueString(interp, retStr, NULL);\n    if (rstr && tStr && Jsi_Strncmp(rstr, \"!!!\", 3)==0) {\n        Jsi_DSAppend(tStr, rstr+3, NULL);\n        jrc = JSI_CONTINUE;\n    } else if (rstr && tStr && Jsi_Strncmp(rstr, \">>>\", 3)==0) {\n        Jsi_DSAppend(tStr, rstr+3, NULL);\n        jrc = JSI_SIGNAL;\n    } else if (rstr && rstr[0] != 0)\n        jsi_wsServeString(pss, wsi, rstr, jrc==JSI_OK?0:404, NULL, NULL);\n    else\n        jrc = JSI_BREAK;\n    Jsi_DecrRefCount(interp, retStr);\n    Jsi_DSFree(&dStr);\n    return jrc;\n}\n\nstatic const char* jsw_getReasonStr(enum lws_callback_reasons reason) {\n    typedef struct { enum lws_callback_reasons r; const char *name; } ssType;\n    static ssType ss[] = {\n#define MKLCBS(n) { n, #n }\n    MKLCBS(LWS_CALLBACK_PROTOCOL_INIT),\n    MKLCBS(LWS_CALLBACK_PROTOCOL_DESTROY), MKLCBS(LWS_CALLBACK_WSI_CREATE),\n    MKLCBS(LWS_CALLBACK_WSI_DESTROY),MKLCBS(LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS),\n    MKLCBS(LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS),\n    MKLCBS(LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION),\n    MKLCBS(LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY),\n    MKLCBS(LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED), MKLCBS(LWS_CALLBACK_HTTP),\n    MKLCBS(LWS_CALLBACK_HTTP_BODY), MKLCBS(LWS_CALLBACK_HTTP_BODY_COMPLETION),\n    MKLCBS(LWS_CALLBACK_HTTP_FILE_COMPLETION), MKLCBS(LWS_CALLBACK_HTTP_WRITEABLE),\n    MKLCBS(LWS_CALLBACK_CLOSED_HTTP), MKLCBS(LWS_CALLBACK_FILTER_HTTP_CONNECTION),\n    MKLCBS(LWS_CALLBACK_ESTABLISHED),\n    MKLCBS(LWS_CALLBACK_CLOSED),\n    MKLCBS(LWS_CALLBACK_SERVER_WRITEABLE),\n    MKLCBS(LWS_CALLBACK_RECEIVE), MKLCBS(LWS_CALLBACK_RECEIVE_PONG),\n    MKLCBS(LWS_CALLBACK_WS_PEER_INITIATED_CLOSE), MKLCBS(LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION),\n    MKLCBS(LWS_CALLBACK_CONFIRM_EXTENSION_OKAY),\n    MKLCBS(LWS_CALLBACK_CLIENT_CONNECTION_ERROR),\n    MKLCBS(LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH), MKLCBS(LWS_CALLBACK_CLIENT_ESTABLISHED),\n    MKLCBS(LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER), MKLCBS(LWS_CALLBACK_CLIENT_RECEIVE),\n    MKLCBS(LWS_CALLBACK_CLIENT_RECEIVE_PONG),\n    MKLCBS(LWS_CALLBACK_CLIENT_WRITEABLE), MKLCBS(LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED),\n    MKLCBS(LWS_CALLBACK_WS_EXT_DEFAULTS), MKLCBS(LWS_CALLBACK_FILTER_NETWORK_CONNECTION),\n    MKLCBS(LWS_CALLBACK_GET_THREAD_ID), MKLCBS(LWS_CALLBACK_ADD_POLL_FD),\n    MKLCBS(LWS_CALLBACK_DEL_POLL_FD), MKLCBS(LWS_CALLBACK_CHANGE_MODE_POLL_FD), MKLCBS(LWS_CALLBACK_LOCK_POLL),\n    MKLCBS(LWS_CALLBACK_UNLOCK_POLL),\n#if (LWS_LIBRARY_VERSION_MAJOR>1)\n    MKLCBS(LWS_CALLBACK_CGI),\n    MKLCBS(LWS_CALLBACK_CGI_TERMINATED),\n    MKLCBS(LWS_CALLBACK_CGI_STDIN_DATA),\n    MKLCBS(LWS_CALLBACK_CGI_STDIN_COMPLETED),\n    MKLCBS(LWS_CALLBACK_SESSION_INFO),\n    MKLCBS(LWS_CALLBACK_GS_EVENT),\n    MKLCBS(LWS_CALLBACK_HTTP_PMO),\n    MKLCBS(LWS_CALLBACK_RAW_RX),\n    MKLCBS(LWS_CALLBACK_RAW_CLOSE),\n    MKLCBS(LWS_CALLBACK_RAW_WRITEABLE),\n    MKLCBS(LWS_CALLBACK_RAW_ADOPT),\n    MKLCBS(LWS_CALLBACK_RAW_ADOPT_FILE),\n    MKLCBS(LWS_CALLBACK_ADD_HEADERS),\n    MKLCBS(LWS_CALLBACK_CHECK_ACCESS_RIGHTS),\n    MKLCBS(LWS_CALLBACK_PROCESS_HTML),\n    MKLCBS(LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP),\n    MKLCBS(LWS_CALLBACK_CLOSED_CLIENT_HTTP),\n    MKLCBS(LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ),\n    MKLCBS(LWS_CALLBACK_RECEIVE_CLIENT_HTTP),\n    MKLCBS(LWS_CALLBACK_COMPLETED_CLIENT_HTTP),\n    MKLCBS(LWS_CALLBACK_CLIENT_HTTP_WRITEABLE),\n    MKLCBS(LWS_CALLBACK_HTTP_BIND_PROTOCOL),\n    MKLCBS(LWS_CALLBACK_HTTP_DROP_PROTOCOL),\n    MKLCBS(LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION),\n    MKLCBS(LWS_CALLBACK_RAW_RX_FILE),\n    MKLCBS(LWS_CALLBACK_RAW_WRITEABLE_FILE),\n    MKLCBS(LWS_CALLBACK_RAW_CLOSE_FILE),\n    MKLCBS(LWS_CALLBACK_USER),\n#endif\n#if (LWS_LIBRARY_VERSION_NUMBER>=3000000)\n    MKLCBS(LWS_CALLBACK_SSL_INFO),\n    MKLCBS(LWS_CALLBACK_CGI_PROCESS_ATTACH),\n    MKLCBS(LWS_CALLBACK_CLIENT_CLOSED),\n    MKLCBS(LWS_CALLBACK_TIMER),\n    MKLCBS(LWS_CALLBACK_EVENT_WAIT_CANCELLED),\n    MKLCBS(LWS_CALLBACK_CHILD_CLOSING),\n    MKLCBS(LWS_CALLBACK_CHILD_WRITE_VIA_PARENT),\n    MKLCBS(LWS_CALLBACK_VHOST_CERT_AGING),\n    MKLCBS(LWS_CALLBACK_VHOST_CERT_UPDATE),\n#endif\n    {(enum lws_callback_reasons)0, NULL }\n    };\n    int i = -1;\n    while (ss[++i].name)\n        if (ss[i].r == reason)\n            return ss[i].name;\n    return \"\";\n}\n\nstatic bool jsi_wsAddHeader(Jsi_Interp *interp, jsi_wsCmdObj *cmdPtr, struct lws *wsi, Jsi_Value *hdrs,\n    Jsi_DString *hStr) {\n    uchar buffer[JSI_BUFSIZ];\n    uchar *p = (unsigned char *)buffer, *end = p + sizeof(buffer);\n    int n = 0;\n    int i, hvl, argc = Jsi_ValueGetLength(interp, hdrs);\n    for (i=0; i<argc; i+=2) {\n        const char *hn = Jsi_ValueArrayIndexToStr(interp, hdrs, i, NULL),\n            *hv = Jsi_ValueArrayIndexToStr(interp, hdrs, i+1, &hvl);\n        if (hn && hv) {\n            if (lws_add_http_header_by_name(wsi, (const uchar *)hn, (const uchar *)hv, hvl, &p, end))\n                return false;\n            n = p - buffer;\n            if (n>0)\n                Jsi_DSAppendLen(hStr, (char*)buffer, n);\n            p = buffer;\n        }\n    }\n    return true;\n}\n\nstatic bool jsi_wsAddStdHeader(Jsi_Interp *interp, jsi_wsCmdObj *cmdPtr, struct lws *wsi,    Jsi_DString *hStr) {\n    uchar buffer[JSI_BUFSIZ];\n    uchar *p = (unsigned char *)buffer, *end = p + sizeof(buffer);\n    const char *srv = cmdPtr->server;\n    if (!srv) srv = \"jsiWebSocket\";\n    int n = 0;\n    if (srv[0] && lws_add_http_header_by_token(wsi, WSI_TOKEN_HTTP_SERVER, (uchar*)srv, Jsi_Strlen(srv), &p, end))\n        return false;\n    n = p - buffer;\n    if (n>0) {\n        Jsi_DSAppendLen(hStr, (char*)buffer, n);\n        p = buffer;\n    }\n    return true;\n}\n\nstatic Jsi_RC jsi_wsFileAdd(Jsi_Interp *interp, jsi_wsCmdObj *cmdPtr, Jsi_Value *name) {\n    const char *sname = Jsi_ValueString(interp, name, NULL);\n    if (cmdPtr->onModify && sname) {\n        bool isNew = 0;\n        Jsi_HashEntry *hPtr = Jsi_HashEntryNew(cmdPtr->fileHash, sname, &isNew);\n        if (hPtr) {\n            jsi_wsFile* fPtr;\n            if (!isNew)\n                fPtr = Jsi_HashValueGet(hPtr);\n            else {\n                fPtr = (jsi_wsFile *)Jsi_Calloc(1, sizeof(*fPtr));\n                fPtr->fileVal = name;\n                fPtr->loadFirst = time(NULL);\n                Jsi_IncrRefCount(interp, name);\n                fPtr->flags = 0;\n                Jsi_HashValueSet(hPtr, fPtr);\n            }\n            fPtr->loadLast = time(NULL);\n        }\n    }\n    return JSI_OK;\n}\n\n// Read only native files inside the rootdir.\nstatic Jsi_RC jsi_wsFileRead(Jsi_Interp *interp, Jsi_Value *name, Jsi_DString *dStr, jsi_wsCmdObj *cmdPtr, jsi_wsPss *pss) {\n    Jsi_StatBuf sb;\n    Jsi_RC rc = JSI_ERROR;\n    int n = Jsi_Stat(interp, name, &sb);\n    if (!n && sb.st_size>0) {\n        char fdir[PATH_MAX];\n        const char* cr = cmdPtr->curRoot, *fpath=NULL;\n        if (!Jsi_FSNative(interp, name) || ((fpath= Jsi_Realpath(interp, name, fdir))\n            && cr && !Jsi_Strncmp(fpath, cr, Jsi_Strlen(cr)))) {\n            rc = Jsi_FileRead(interp, name, dStr);\n            if (rc == JSI_OK && cmdPtr->onModify && Jsi_FSNative(interp, name))\n                jsi_wsFileAdd(interp, cmdPtr, name);\n        } else\n            fprintf(stderr, \"Skip read file %s in %s\\n\", Jsi_ValueString(interp, name, NULL), (cr?cr:\"\"));\n    }\n    if (cmdPtr->noWarn)\n        return JSI_OK;\n    return rc;\n}\n\nstatic bool jsi_wsIsSSIExt(Jsi_Interp *interp, jsi_wsCmdObj *cmdPtr, jsi_wsPss *pss, const char *ext) {\n    if (cmdPtr->ssiExts) {\n        Jsi_Value *mVal = Jsi_ValueObjLookup(interp, cmdPtr->ssiExts, ext, 1);\n        if (mVal) {\n            bool b = 0;\n            if (Jsi_ValueGetBoolean(interp, mVal, &b) != JSI_OK) {\n                Jsi_LogWarn(\"expected bool for ssiExts '%s': disabling all\\n\", ext);\n                Jsi_DecrRefCount(interp, cmdPtr->ssiExts);\n                cmdPtr->ssiExts = NULL;\n            }\n            return b;\n        }\n    }\n    if (ext[0]=='s'  && (!Jsi_Strcmp(ext, \"shtml\")\n        || !Jsi_Strcmp(ext, \"scss\") || !Jsi_Strcmp(ext, \"sjs\")))\n        return 1;\n\n    return 0;\n}\n\n// Support the limited nonstandard SSI: #include, #if, #elif#, #else, #endif\n// No expr, just var lookup from query/udata.  And can not nest #if in same file.\nstatic Jsi_RC jsi_wsEvalSSI(Jsi_Interp *interp, jsi_wsCmdObj *cmdPtr, Jsi_Value *fn, Jsi_DString *dStr,\n    int lvl, jsi_wsPss *pss) {\n    int flen, rlen;\n    char fbuf[PATH_MAX];\n    char *fs, *fname = Jsi_ValueString(interp, fn, &flen), *fend = fname;\n    if (lvl>10 || !fname || !pss)\n        return JSI_ERROR;\n    Jsi_Value *fval;\n    Jsi_RC rc = JSI_OK;\n    Jsi_DString tStr = {}, lStr = {};\n    const char *cs = NULL;\n    char *root = Jsi_ValueString(interp, cmdPtr->rootdir, &rlen);\n    if (!Jsi_Strncmp(root, fname, rlen))\n        fname = fname + rlen;\n    fs = Jsi_Strrchr(fname, '/');\n    if (fs) {\n        flen = fs-fname;\n        fend = fs+1;\n    }\n    if (lvl>0) {\n        rc = jsi_wsFileRead(interp, fn, &tStr, cmdPtr, pss);\n        cs = Jsi_DSValue(&tStr);\n    } else {\n        snprintf(fbuf, sizeof(fbuf), \"%s/%.*s/%s\", root, flen, fname, cmdPtr->includeFile);\n        fval = Jsi_ValueNewStringConst(interp, fbuf, -1);\n        Jsi_IncrRefCount(interp, fval);\n        rc = jsi_wsFileRead(interp, fval, &tStr, cmdPtr, pss);\n        if (rc == JSI_OK)\n            cs = Jsi_DSValue(&tStr);\n        Jsi_DecrRefCount(interp, fval);\n    }\n    \n    char *cp, *sp, *se, pref[] = \"<!--#\", suffix[] = \"-->\", *msg = NULL;\n    struct {\n        int inif, inelse, matched, elide;\n    } II[11] = {};\n    const int maxNest = 10;\n    int ii = 0;\n    int plen = 5, elen, llen;\n\n    while (rc == JSI_OK && cs) {\n        char *ext = NULL, *sfname = fname;\n        int sflen = flen;\n        sp = Jsi_Strstr(cs, pref);\n        if (!sp || !(se=Jsi_Strstr(sp+plen, suffix))) {\n            Jsi_DSAppend(dStr, cs, NULL);\n            break;\n        }\n        sp += plen-1;\n        llen = se-sp;\n        Jsi_DSSetLength(&lStr, 0);\n        cp = Jsi_DSAppendLen(&lStr, sp, llen);\n        if (Jsi_Strchr(cp, '\\n')) { rc = Jsi_LogError(\"unexpected newline in directive \\\"%.10s\\\"\", cp); break; }\n        if (!II[ii].elide)\n            Jsi_DSAppendLen(dStr, cs, sp-cs-4);\n        \n        if (!Jsi_Strncmp(cp, \"#include file=\\\"\", 12) || !Jsi_Strncmp(cp, \"#include virtual=\\\"\", 15)) {\n            if (cp[llen-1] != '\"' || cp[llen-2] == '=') { msg = \"missing end quote in\"; break; }\n            if (!II[ii].elide) {\n                Jsi_DSSetLength(&lStr, llen-1);\n                int isvirt = (cp[9]=='v');\n                cp += (isvirt ? 18 : 15);\n                if (cp[0] == '$' && lvl == 0) { // substitute file suffix\n                    char sfx[20] = {};\n                    uint i;\n                    for (i=0; i<sizeof(sfx); i++) {\n                        if ((sfx[i] = cp[i+1]) == '\"' || !sfx[i]) {\n                            sfx[i] = 0;\n                            break;\n                        }\n                    }\n                    snprintf(fbuf, sizeof(fbuf), \"%s/%.*s/%s/%s%s\", root, flen, fname, sfx, fend, sfx);\n                } else {\n                    snprintf(fbuf, sizeof(fbuf), \"%s/%.*s/%s\", root, sflen, sfname, cp);\n                    ext = Jsi_Strrchr(fbuf, '.');\n                }\n                fval = Jsi_ValueNewStringConst(interp, fbuf, -1);\n                Jsi_IncrRefCount(interp, fval);\n                if (!ext || ext[0] != '.' || !jsi_wsIsSSIExt(interp, cmdPtr, pss, ext+1))\n                    rc = jsi_wsFileRead(interp, fval, dStr, cmdPtr, pss);\n                else\n                    rc = jsi_wsEvalSSI(interp, cmdPtr, fval, dStr, lvl+1, pss);\n                if (cmdPtr->noWarn)\n                    rc = JSI_OK;\n                Jsi_DecrRefCount(interp, fval);\n            }\n        } else if (!Jsi_Strncmp(cp, \"#echo \\\"${\", 9)) {\n            if (cp[llen-1] != '\"' || cp[llen-2] != '}') { msg = \"missing end quote\"; break; }\n            Jsi_DSSetLength(&lStr, llen-2);\n            cp += 9;\n            llen -= 9;\n            if (!Jsi_Strcmp(cp, \"#\")) {\n                if (!pss->key[0])\n                    snprintf(pss->key, sizeof(pss->key), \"%d%p%d\", pss->wid, pss, (int)cmdPtr->startTime);\n                Jsi_DSPrintf(dStr, \"'%s'\", pss->key);\n            } else {\n                Jsi_Value *val = NULL;\n                if (!cmdPtr->udata) {\n                    val = Jsi_ValueObjLookup(interp, cmdPtr->udata, cp, 0);\n                    if (!val) { msg = \"udata lookup failure\"; break; }\n                    cp = Jsi_ValueString(interp, val, NULL);\n                    Jsi_DSPrintf(dStr, \"'%s'\", cp);\n                }\n            }\n\n        } else if (!Jsi_Strncmp(cp, \"#if expr=\\\"\", 10) || !Jsi_Strncmp(cp, \"#elif expr=\\\"\", 12)) {\n            if (llen<11 || cp[llen-1] != '\"' || cp[llen-2] == '=') { msg = \"missing end quote\"; break; }\n            Jsi_DSSetLength(&lStr, llen-1);\n            bool iselif = (cp[1]=='e');\n            cp += (iselif?12:10);\n            if (!iselif) {\n                if (II[ii].inif) {\n                    if ((ii+1)>=maxNest) { msg = \"nested \\\"#if\\\" too deep\"; break; }\n                    ii++;\n                    II[ii] = II[maxNest];\n                    II[ii].elide = II[ii-1].elide;\n                }\n                II[ii].inif = 1;\n            } else {\n                if (!II[ii].inif) { msg = \"unexpected \\\"#elif\\\"\"; break; }\n            }\n            elen = Jsi_Strlen(cp);\n            if (elen<4|| cp[0] != '$' || cp[1] != '{' || cp[elen-1] != '}') {\n                msg = \"expr must be of form ${X}\"; break;\n            }\n            Jsi_DSSetLength(&lStr, llen-2);\n            cp += 2;\n            // Extract modifiers before bool var name to lookup.\n            bool warn = 0, req = 0, nifval = 0, not = 0, isq=0, isu=0, qfirst=0;\n            while (*cp &&  !isalpha(*cp)) {\n                bool fail = 0;\n                switch (*cp) {\n                    case '~': qfirst = 1; break;\n                    case ':': isu = 1; break;\n                    case '?': isq = 1; break;\n                    case '@': warn = !II[ii].matched; break;\n                    case '*': req = !II[ii].matched; break;\n                    case '!': not = 1; break;\n                    default: fail=1; break;\n                }\n                if (fail) { msg = \"modifier must be one of: !:=?@*\"; break; }\n                cp++;\n            }\n            Jsi_Value *val = NULL;\n            if (!val && qfirst && pss->queryObj)\n                val = Jsi_ValueObjLookup(interp, pss->queryObj, cp, 0);\n            if (!val && !isq && cmdPtr->udata)\n                val = Jsi_ValueObjLookup(interp, cmdPtr->udata, cp, 0);\n            if (!val && !qfirst && !isu && pss->queryObj)\n                val = Jsi_ValueObjLookup(interp, pss->queryObj, cp, 0);\n            if (!val) {\n                if (req) { msg = \"symbol not found\"; break; }\n                if (warn) Jsi_LogWarn(\"symbol \\\"%s\\\" not found: %s\", cp, fbuf);\n            } else if (Jsi_ValueGetBoolean(interp, val, &nifval) != JSI_OK) {\n                const char *valStr = NULL;\n                if (val) valStr = Jsi_ValueString(interp, val, NULL);\n                if (!valStr || Jsi_GetBool(interp, valStr, &nifval) != JSI_OK) {\n                    if (!warn) { msg = \"symbol not a boolean\"; break; }\n                    Jsi_LogWarn(\"symbol \\\"%s\\\" should be a boolean: %s\", cp, fbuf);\n                }\n            }\n            if (not) nifval = !nifval;\n            if (!iselif) {\n                if (nifval)\n                    II[ii].matched = 1;\n                else\n                    II[ii].elide = 1;\n            } else {\n                if (II[ii].matched || !nifval)\n                    II[ii].elide = 1;\n                else if (nifval) {\n                    II[ii].matched = 1;\n                    II[ii].elide = (ii?II[ii-1].elide:0);\n                }\n            }\n        } else if (!Jsi_Strncmp(cp, \"#else\", 5)) {\n            if (!II[ii].inif || II[ii].inelse) { msg = \"unexpected \\\"#else\\\"\"; break; }\n            II[ii].inelse = 1;\n            II[ii].elide = (ii&&II[ii-1].elide?1:II[ii].matched);\n        } else if (!Jsi_Strncmp(cp, \"#endif\", 6)) {\n            if (!II[ii].inif) { msg = \"unexpected \\\"#endif\\\"\";  break; }\n            II[ii].inelse = II[ii].inif = II[ii].elide = II[ii].matched = 0;\n            if (ii>0)\n                ii--;\n        } else {\n            msg = \"expected directive #include/#if/#elif/#else/#endif\";\n            break;\n        }\n        cs = se + 3;\n        if (*cs == '\\n')\n            cs++;\n    }\n    if (rc == JSI_OK && II[ii].inif && !msg) {\n         msg = \"missing \\\"#endif\\\"\";\n         sp = \"\";\n    }\n    if (msg) {\n        while (*fname=='/') fname++;\n        rc = Jsi_LogError(\"SHTML Error in \\\"%s\\\": %s: at \\\"%.40s\\\" \", fname, msg, sp);\n    }\n    Jsi_DSFree(&tStr);\n    Jsi_DSFree(&lStr);\n    return rc;\n\n}\n\nstatic void jsi_wsPathAlias(Jsi_Interp *interp, jsi_wsCmdObj *cmdPtr, const char **inPtr, Jsi_DString *dStr) {\n    const char *ce, *cp = NULL;\n    char *lcp;\n    Jsi_Value *val;\n    if (cmdPtr->pathAliases) {\n        cp = *inPtr;\n        if (*cp == '/') cp++;\n        if ((ce = Jsi_Strchr(cp, '/'))) {\n            int len = ce-cp;\n            Jsi_DSSetLength(dStr, 0);\n            Jsi_DSAppendLen(dStr, cp, len);\n            cp = Jsi_DSValue(dStr);\n            if ((val = Jsi_ValueObjLookup(interp, cmdPtr->pathAliases, cp, 0)) &&\n                (cp = Jsi_ValueString(interp, val, NULL))) {\n                *inPtr += (len+2);\n                cmdPtr->curRoot = cp;\n                return;\n            }\n        }\n    }\n    if (!Jsi_Strncmp(*inPtr, \"/jsi/\", 5)) {\n        // Get/cache path for system load file, eg /zvfs/lib/Jsish.jsi.\n        if (!(cp = cmdPtr->jsishPathCache)) {\n            Jsi_PkgRequire(interp, \"Jsish\", 0);\n            if (Jsi_PkgVersion(interp, \"Jsish\", &cp)>=0)\n                cmdPtr->jsishPathCache = cp;\n        }\n        if (cp) {\n            Jsi_DSSetLength(dStr, 0);\n            Jsi_DSAppend(dStr, cp, NULL);\n            cp = Jsi_DSValue(dStr);\n            if ((lcp = Jsi_Strrchr(cp, '/'))) {\n                *lcp = 0;\n                *inPtr += 5;\n                cmdPtr->curRoot = cp;\n            }\n        }\n    }\n}\n\nstatic Jsi_RC WebSocketUnaliasCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    jsi_wsCmdObj *cmdPtr = (jsi_wsCmdObj*)Jsi_UserObjGetData(interp, _this, funcPtr);\n    if (!cmdPtr)\n        return Jsi_LogError(\"Apply to non-websock object\");\n    int vlen, nlen;\n    const char *kstr, *vstr, *nstr = Jsi_ValueArrayIndexToStr(interp, args, 0, &nlen);\n    if (!nstr)\n        return Jsi_LogError(\"arg 1: expected string\");\n    Jsi_Value *v, *a = cmdPtr->pathAliases;\n    if (!a|| !Jsi_ValueIsObjType(interp, a, JSI_OT_OBJECT)) return JSI_OK;\n    Jsi_IterObj *io = Jsi_IterObjNew(interp, NULL);\n    Jsi_IterGetKeys(interp, cmdPtr->pathAliases, io, 0);\n    uint i;\n    for (i=0; i<io->count; i++) {\n        kstr = io->keys[i];\n        v = Jsi_ValueObjLookup(interp, a, kstr, 1);\n        if (!v) continue;\n        vstr = Jsi_ValueToString(interp, v, &vlen);\n        if (!vstr) continue;\n        if (nlen<=vlen) continue;\n        if (Jsi_Strncmp(vstr, nstr, vlen)) continue;\n        Jsi_DString dStr = {};\n        Jsi_DSAppend(&dStr, \"/\", kstr, nstr+vlen, NULL);\n        Jsi_ValueFromDS(interp, &dStr, ret);\n        break;\n    }\n    Jsi_IterObjFree(io);\n    return JSI_OK;\n}\n\nint\njsi_ws_http_redirect(struct lws *wsi, int code, Jsi_DString *tStr, \n                  unsigned char **p, unsigned char *end)\n{\n    char *loc = Jsi_DSValue(tStr);\n    uchar *start = *p;\n    char* cookie = Jsi_Strchr(loc, '|');\n    if (cookie) { *cookie= 0; cookie++; }\n\n    if (lws_add_http_header_status(wsi, code, p, end)\n        || lws_add_http_header_by_token(wsi, WSI_TOKEN_HTTP_LOCATION, (uchar *)loc, Jsi_Strlen(loc), p, end)\n        || lws_add_http_header_by_token(wsi, WSI_TOKEN_HTTP_CONTENT_TYPE,(uchar *)\"text/html\", 9, p,end)\n        || lws_add_http_header_by_token(wsi, WSI_TOKEN_HTTP_CONTENT_LENGTH, (uchar *)\"0\", 1, p, end))\n        return -1;\n    if (cookie && lws_add_http_header_by_token(wsi, WSI_TOKEN_HTTP_SET_COOKIE, (uchar *)cookie, Jsi_Strlen(cookie), p, end))\n        return -1;\n    if (lws_finalize_http_header(wsi, p, end))\n        return -1;\n    return lws_write(wsi, start, *p - start, LWS_WRITE_HTTP_HEADERS);\n}\n\n// Handle http GET/POST\nstatic int jsi_wsHttp(Jsi_Interp *interp, jsi_wsCmdObj *cmdPtr, struct lws *wsi, void *user,\n    struct lws_context *context, const char* inPtr, Jsi_DString *tStr, jsi_wsPss *pss)\n{\n    const char *ext = NULL;\n    unsigned char buffer[JSI_BUFSIZ];\n    const char *mime = NULL;\n    time_t now = time(NULL);\n    char buf[JSI_BUFSIZ];\n    int rc = 0;\n    buf[0] = 0;\n    uchar *p = buffer, *end = &buffer[sizeof(buffer)-1];\n    int n;\n    Jsi_Value* fname = NULL;\n    bool isJsiWeb = 0, isSSI = 0;\n    cmdPtr->stats.httpLast = now;\n    \n    /* if a legal POST URL, let it continue and accept data */\n    if (lws_hdr_total_length(wsi, WSI_TOKEN_POST_URI))\n        return 0;\n    if (!pss)\n        pss = jsi_wsgetPss(cmdPtr, wsi, user, 1, 1);\n\n    int uplen=(cmdPtr->urlPrefix?Jsi_Strlen(cmdPtr->urlPrefix):0);\n\n    if (inPtr && cmdPtr->urlPrefix && !Jsi_Strncmp(inPtr, cmdPtr->urlPrefix, uplen))\n        inPtr += uplen;\n\n    if (cmdPtr->redirDisable) {// Try to defray redirect loops.\n        if (difftime(now, cmdPtr->stats.redirLast)>=600)\n            cmdPtr->redirDisable = 0;\n        else\n            cmdPtr->redirDisable--;\n    }\n\n    if ((cmdPtr->urlRedirect && (inPtr == 0 || *inPtr == 0 || !Jsi_Strcmp(inPtr, \"/\")) && !cmdPtr->redirDisable)\n        && (inPtr = cmdPtr->urlRedirect) && inPtr[0]) {\n        cmdPtr->stats.redirCnt++;\n        // TODO: system time change can disrupt the following.\n        if (cmdPtr->redirMax>0 && !cmdPtr->redirDisable && cmdPtr->redirMax>0 && cmdPtr->stats.redirLast\n            && difftime(now, cmdPtr->stats.redirLast)<600 && ++cmdPtr->redirAllCnt>cmdPtr->redirMax)\n            cmdPtr->redirDisable = 100;\n        cmdPtr->stats.redirLast = now;\n        rc = lws_http_redirect(wsi, 301, (uchar*)inPtr, Jsi_Strlen(inPtr), &p, end);\n        return (rc == 100 ? 0 : 1);\n    }\n    if (!inPtr || !*inPtr)\n        inPtr = \"/\";\n\n    if (cmdPtr->useridPass || cmdPtr->onAuth) {\n        int ok = 0;\n        int alen;\n        const char *auth = jsi_wsHeader(pss, \"authorization\", &alen);\n        if (auth && !Jsi_Strncasecmp(auth, \"basic \", 6) && !cmdPtr->deleted) {\n            auth += 6;\n            Jsi_DString eStr = {}, bStr = {};\n            Jsi_DSAppendLen(&eStr, auth, alen - 6);\n            Jsi_Base64(Jsi_DSValue(&eStr), -1, &bStr, 1);\n            const char *bp = Jsi_DSValue(&bStr);\n            if (bp && bp[0]) {\n                if (!cmdPtr->onAuth)\n                    ok = (!Jsi_Strcmp(cmdPtr->useridPass, bp));\n                else {\n                    /* Pass 4 args: ws, id, url and userid:pass . */\n                    Jsi_Obj *oarg1;\n                    Jsi_Value *vpargs, *vargs[10];\n                    int n = 0;\n                    vargs[n++] = Jsi_ValueNewObj(interp, cmdPtr->fobj);\n                    vargs[n++] = Jsi_ValueNewNumber(interp, (Jsi_Number)(pss->wid));\n                    vargs[n++] = Jsi_ValueNewStringDup(interp, inPtr);\n                    vargs[n++] = Jsi_ValueNewStringDup(interp, bp);\n                    vpargs = Jsi_ValueMakeObject(interp, NULL, oarg1 = Jsi_ObjNewArray(interp, vargs, n, 0));\n                    Jsi_IncrRefCount(interp, vpargs);\n                    Jsi_Value *ret = Jsi_ValueNew1(interp);\n                    bool rb = 0;\n                    rc = Jsi_FunctionInvoke(interp, cmdPtr->onAuth, vpargs, &ret, NULL);\n                    if (rc == JSI_OK)\n                        rb = !Jsi_ValueIsFalse(interp, ret);\n\n                    Jsi_DecrRefCount(interp, vpargs);\n                    Jsi_DecrRefCount(interp, ret);\n\n                    if (rc != JSI_OK) {\n                        Jsi_LogError(\"websock bad rcv eval\");\n                        return -1;\n                    }\n                    ok = rb;\n                }\n            }\n            Jsi_DSFree(&eStr);\n            Jsi_DSFree(&bStr);\n        }\n        if (!ok) {\n            const char *realm = (cmdPtr->realm?cmdPtr->realm:\"jsish\");\n            int n = snprintf(buf, sizeof(buf), \"Basic realm=\\\"%s\\\"\", realm);\n            if (lws_add_http_header_by_token(wsi, WSI_TOKEN_HTTP_WWW_AUTHENTICATE,\n                    (unsigned char *)buf, n, &p, end))\n                return -1;\n            if (jsi_wsServeString(pss, wsi, \"Password is required to access this page\", 401, (char*)buffer, NULL)<0)\n                return -1;\n            return lws_http_transaction_completed(wsi);\n        }\n    }\n\n    if (cmdPtr->onGet || pss->onGet) {\n        Jsi_RC jrc;\n        int rrv = 1;\n        if (cmdPtr->getRegexp) {\n            rrv = 0;\n            jrc = Jsi_RegExpMatch(interp, cmdPtr->getRegexp, inPtr, &rrv, NULL);\n            if (jrc != JSI_OK)\n                return -1; // Error in regexp.\n        }\n        if (rrv) {\n            jrc = jsi_wsGetCmd(interp, cmdPtr, pss, wsi, inPtr, pss->onGet?pss->onGet:cmdPtr->onGet, tStr);\n            switch (jrc) {\n                case JSI_ERROR: return -1;\n                case JSI_OK: return 0;\n                case JSI_SIGNAL:\n                    return jsi_ws_http_redirect(wsi, 302, tStr, &p, end);\n                case JSI_CONTINUE:\n                    inPtr = Jsi_DSValue(tStr); break;\n                case JSI_BREAK: break;\n                default: break;\n            }\n        }\n    }\n    ext = Jsi_Strrchr(inPtr, '.');\n\n    Jsi_Value *rdir = (pss->rootdir?pss->rootdir:cmdPtr->rootdir);\n    cmdPtr->curRoot = (rdir?Jsi_ValueString(cmdPtr->interp, rdir, NULL):\"./\");\n    Jsi_DString sStr;\n    Jsi_DSInit(&sStr);\n    jsi_wsPathAlias(interp, cmdPtr, &inPtr, &sStr);\n\n    snprintf(buf, sizeof(buf), \"%s/%s\", cmdPtr->curRoot, inPtr);\n    Jsi_DSFree(&sStr);\n    if (cmdPtr->debug>1)\n        fprintf(stderr, \"FILE: %s in %s | %s\\n\", buf, cmdPtr->curRoot, Jsi_ValueString(interp, cmdPtr->rootdir, NULL));\n    char extBuf[100], *cpde = Jsi_Strrchr(buf, '/');\n    isJsiWeb = (cpde && cmdPtr->jsiFnPattern && Jsi_GlobMatch(cmdPtr->jsiFnPattern, cpde+1, 0));\n    bool isgzip = 0;\n    if (!ext || !ext[1])\n        mime = \"text/html\";\n    else {\n        const char *eext = ext+1;\n        uint elen = Jsi_Strlen(ext);\n        if (elen>3 && elen<(sizeof(extBuf)-10) && !Jsi_Strcmp(ext+elen-3,\".gz\")) {\n            Jsi_Strcpy(extBuf, ext);\n            extBuf[elen-3] = 0;\n            char *ext2 = Jsi_Strrchr(extBuf, '.');\n            if (ext2) {\n                isgzip = 1;\n                ext = ext2;\n            }\n        }\n        Jsi_HashEntry *hPtr;\n\n        if (cmdPtr->mimeTypes) {\n            /* Lookup mime type in mimeTypes object. */\n            Jsi_Value *mVal = Jsi_ValueObjLookup(interp, cmdPtr->mimeTypes, ext+1, 1);\n            if (mVal)\n                mime = Jsi_ValueString(interp, mVal, NULL);\n        }\n        if (!mime) {\n            static const char* mtypes[] = {\n                \"html\", \"text/html\", \"js\", \"application/x-javascript\",\n                \"css\", \"text/css\", \"png\", \"image/png\", \"ico\", \"image/icon\",\n                \"gif\", \"image/gif\", \"jpeg\", \"image/jpeg\",\n                \"jpg\", \"image/jpeg\", \"svg\", \"image/svg+xml\",\n                \"json\", \"application/json\", \"txt\", \"text/plain\",\n                \"jsi\", \"application/x-javascript\", \"cssi\", \"text/css\",\n                \"shtml\", \"text/html\",  \"scss\", \"text/css\",\n                \"sjs\", \"application/x-javascript\",\n                0, 0\n            };\n            mime = \"text/html\";\n            int i;\n            for (i=0; mtypes[i]; i+=2)\n                if (tolower(*eext) == mtypes[i][0] && !Jsi_Strncasecmp(eext, mtypes[i], -1)) {\n                    mime = mtypes[i+1];\n                    break;\n                }\n        }\n\n        isSSI = jsi_wsIsSSIExt(interp, cmdPtr, pss, eext);\n\n        if ((hPtr = Jsi_HashEntryFind(cmdPtr->handlers, ext)) && !cmdPtr->deleted) {\n            /* Use interprete html eg. using jsi_wpp preprocessor */\n            Jsi_DString jStr = {};\n            Jsi_Value *vrc = NULL;\n            int hrc = 0, strLen, evrc, isalloc=0;\n            char *vStr, *hstr = NULL;\n            jsi_wsHander *hdlPtr = (jsi_wsHander*)Jsi_HashValueGet(hPtr);\n            Jsi_Value *hv = hdlPtr->val;\n\n            if (Jsi_Strchr(buf, '\\'') || Jsi_Strchr(buf, '\\\"')) {\n                jsi_wsServeString(pss, wsi, \"Can not handle quotes in url\", 404, NULL, NULL);\n                return -1;\n            }\n            cmdPtr->handlersPkg=1;\n\n            // Attempt to load package and get function.\n            if ((hdlPtr->flags&1) && cmdPtr->handlersPkg && Jsi_ValueIsString(interp, hv)\n                && ((hstr = Jsi_ValueString(interp, hv, NULL)))) {\n                vrc = Jsi_NameLookup(interp, hstr);\n                if (!vrc) {\n                    Jsi_Number pver = Jsi_PkgRequire(interp, hstr, 0);\n                    if (pver >= 0)\n                        vrc = Jsi_NameLookup(interp, hstr);\n                }\n                if (!vrc || !Jsi_ValueIsFunction(interp, vrc)) {\n                    if (vrc)\n                        Jsi_DecrRefCount(interp, vrc);\n                    Jsi_LogError(\"Failed to autoload handle: %s\", hstr);\n                    jsi_wsServeString(pss, wsi, \"Failed to autoload handler\", 404, NULL, NULL);\n                    return -1;\n                }\n                if (hdlPtr->val)\n                    Jsi_DecrRefCount(interp, hdlPtr->val);\n                hdlPtr->val = vrc;\n                Jsi_IncrRefCount(interp, vrc);\n                hv = vrc;\n            }\n\n            if ((hdlPtr->flags&2) && !hdlPtr->triedLoad && !hdlPtr->objVar && Jsi_ValueIsFunction(interp, hv)) {\n                // Run command and from returned object get the parse function.\n                hdlPtr->triedLoad = 1;\n                Jsi_DSAppend(&jStr, \"[null]\", NULL);\n                Jsi_DSAppend(&jStr, \"]\", NULL);\n                vrc = Jsi_ValueNew1(interp);\n                evrc = Jsi_FunctionInvokeJSON(interp, hv, Jsi_DSValue(&jStr), &vrc);\n                if (Jsi_InterpGone(interp))\n                    return -1;\n                if (evrc != JSI_OK || !vrc || !Jsi_ValueIsObjType(interp, vrc, JSI_OT_OBJECT)) {\n                    Jsi_LogError(\"Failed to load obj: %s\", hstr);\n                    jsi_wsServeString(pss, wsi, \"Failed to load obj\", 404, NULL, NULL);\n                    return -1;\n                }\n                Jsi_Value *fvrc = Jsi_ValueObjLookup(interp, vrc, \"parse\", 0);\n                if (!fvrc || !Jsi_ValueIsFunction(interp, fvrc)) {\n                    Jsi_LogError(\"Failed to find parse: %s\", hstr);\n                    jsi_wsServeString(pss, wsi, \"Failed to find parse\", 404, NULL, NULL);\n                    return -1;\n                }\n                hdlPtr->objVar = fvrc;\n                Jsi_IncrRefCount(interp, fvrc);\n                hv = vrc;\n\n            }\n\n            if (hdlPtr->objVar) {  // Call the obj.parse function.\n                Jsi_DSAppend(&jStr, \"[\\\"\", buf, \"\\\"]\", NULL); // TODO: JSON encode.\n                vrc = Jsi_ValueNew1(interp);\n                evrc = Jsi_FunctionInvokeJSON(interp, hdlPtr->objVar, Jsi_DSValue(&jStr), &vrc);\n                isalloc = 1;\n            }\n            else if (Jsi_ValueIsFunction(interp, hv)) {\n                //printf(\"CNCNN: %s\\n\", Jsi_DSValue(&cmdPtr->cName));\n                Jsi_DSAppend(&jStr, \"[\\\"\", buf, \"\\\", {wsName:\\\"\", Jsi_DSValue(&cmdPtr->cName), \"\\\"\", \"}]\", NULL); // TODO: JSON encode.\n                vrc = Jsi_ValueNew1(interp);\n                evrc = Jsi_FunctionInvokeJSON(interp, hv, Jsi_DSValue(&jStr), &vrc);\n                isalloc = 1;\n            } else {\n                // One shot invoke of string command.\n                hstr = Jsi_ValueString(interp, hv, NULL);\n                Jsi_DSAppend(&jStr, hstr, \"('\", buf, \"');\", NULL);\n                evrc = Jsi_EvalString(interp, Jsi_DSValue(&jStr), JSI_EVAL_RETURN);\n                if (evrc == JSI_OK)\n                    vrc = Jsi_InterpResult(interp);\n            }\n            // Take result from vrc and return it.\n            if (evrc != JSI_OK) {\n                Jsi_LogError(\"failure in websocket handler\");\n            } else if ((!vrc) ||\n                (!(vStr = Jsi_ValueString(interp, vrc, &strLen)))) {\n                Jsi_LogError(\"failed to get result\");\n            } else {\n                hrc = jsi_wsServeString(pss, wsi, vStr, 0, NULL, mime);\n            }\n            Jsi_DSFree(&jStr);\n            if (isalloc)\n                Jsi_DecrRefCount(interp, vrc);\n            if (hrc<=0)\n                return -1;\n            return 1;\n        }\n    }\n    if (!buf[0]) {\n        if (cmdPtr->debug)\n            fprintf(stderr, \"empty file: %s\\n\", inPtr);\n        return -1;\n    }\n    fname = Jsi_ValueNewStringDup(interp, buf);\n    Jsi_IncrRefCount(interp, fname);\n\n    Jsi_DString hStr = {};\n    Jsi_StatBuf jsb;\n    bool native = Jsi_FSNative(interp, fname);\n    if ((native && Jsi_InterpSafe(interp) && Jsi_InterpAccess(interp, fname, JSI_INTACCESS_READ) != JSI_OK) ||\n        (Jsi_Stat(interp, fname, &jsb) || jsb.st_size<=0)) {\nnofile:\n        if (cmdPtr->onUnknown || pss->onUnknown) {\n            Jsi_Value *uk = (pss->onUnknown?pss->onUnknown:cmdPtr->onUnknown);\n            Jsi_RC jrc = jsi_wsGetCmd(interp, cmdPtr, pss, wsi, inPtr, uk, NULL);\n            if (jrc == JSI_ERROR)\n                goto bail;\n            if (jrc == JSI_OK)\n                goto done;\n        }\n\n        if (0 && Jsi_Strstr(buf, \"favicon.ico\"))\n            rc = jsi_wsServeString(pss, wsi, \"data:;base64,iVBORw0KGgo=\", 200, NULL, \"image/icon\");\n        else {\n            const char *cp = Jsi_Strrchr(buf,'/');\n            if (cp && cp[1]) {\n                char statPath[PATH_MAX];\n                snprintf(statPath, sizeof(statPath), \"/zvfs/lib/web%s\", cp);\n                Jsi_DecrRefCount(interp, fname);\n                fname = Jsi_ValueNewStringDup(interp, statPath);\n                Jsi_IncrRefCount(interp, fname);\n                if (!Jsi_Stat(interp, fname, &jsb) && jsb.st_size>0) {\n                    native = 0;\n                    goto serve;\n                }\n            }\n            if (cmdPtr->noWarn==0 && !Jsi_Strstr(buf, \"favicon.ico\"))\n                fprintf(stderr, \"failed open file for read: %s\\n\", buf);\n            rc = jsi_wsServeString(pss, wsi, \"<b style='color:red'>ERROR: can not serve file!</b>\", 404, NULL, NULL);\n        }\n        Jsi_DecrRefCount(interp, fname);\n        goto done;\n    }\n    if (!ext || isSSI)\n        goto serve;\n    if (S_ISDIR(jsb.st_mode)) {\n        if (cmdPtr->noWarn==0)\n            fprintf(stderr, \"can not serve directory: %s\\n\", buf);\n        rc = jsi_wsServeString(pss, wsi, \"<b style='color:red'>ERROR: can not serve directory!</b>\", 404, NULL, NULL);\n        Jsi_DecrRefCount(interp, fname);\n        goto done;\n    }\n\nserve:\n    n = 0;\n    // TODO: add automatic cookie mgmt?\n/*\n    if (!strcmp((const char *)in, \"/\") &&\n       !lws_hdr_total_length(wsi, WSI_TOKEN_HTTP_COOKIE)) {\n        gettimeofday(&tv, NULL);\n        n = sprintf(b64, \"test=LWS_%u_%u_COOKIE;Max-Age=360000\",\n            (unsigned int)tv.tv_sec,\n            (unsigned int)tv.tv_usec);\n\n        if (lws_add_http_header_by_name(wsi,\n            (unsigned char *)\"set-cookie:\",\n            (unsigned char *)b64, n, &p,\n            (unsigned char *)buffer + sizeof(buffer)))\n            return 1;\n    }*/\n    static const char stsStr[] = \"max-age=15768000 ; includeSubDomains\";\n    if (lws_is_ssl(wsi) && lws_add_http_header_by_name(wsi,\n                    (uchar *) \"Strict-Transport-Security:\",\n                    (uchar *) stsStr,\n                    sizeof(stsStr)-1, &p, (uchar *)buffer + sizeof(buffer)))\n        goto bail;\n    n = p - buffer;\n    if (n>0)\n        Jsi_DSAppendLen(&hStr, (char*)buffer, n);\n    p = buffer;\n\n    if (isgzip) {\n        if (lws_add_http_header_by_token(wsi, WSI_TOKEN_HTTP_CONTENT_ENCODING,\n                    (unsigned char *)\"gzip\", n, &p, end))\n            goto bail;\n    }\n    if (cmdPtr->headers && !jsi_wsAddHeader(interp, cmdPtr, wsi, cmdPtr->headers, &hStr))\n        goto bail;\n\n    if (pss->headers && !jsi_wsAddHeader(interp, cmdPtr, wsi, pss->headers, &hStr))\n        goto bail;\n\n    n = Jsi_DSLength(&hStr);\n\n    if (native && !isSSI && !isJsiWeb) {\n\n        if (!jsi_wsAddStdHeader(interp, cmdPtr, wsi, &hStr)) {\n            Jsi_DecrRefCount(interp, fname);\n            goto bail;\n        }\n        int hrc = lws_serve_http_file(wsi, buf, mime, Jsi_DSValue(&hStr), Jsi_DSLength(&hStr));\n        if (hrc >= 0 && cmdPtr->onModify)\n            jsi_wsFileAdd(interp, cmdPtr, fname);\n        Jsi_DecrRefCount(interp, fname);\n        if (hrc<0) {\n            if (cmdPtr->noWarn==0)\n                fprintf(stderr, \"can not serve file (%d): %s\\n\", hrc, buf);\n            goto bail;\n        } else if (hrc > 0 && lws_http_transaction_completed(wsi))\n            goto bail;\n    } else {\n        // Need to read data for non-native files.\n        Jsi_DString dStr = {}, fStr = {};\n        if (isSSI)\n            rc = jsi_wsEvalSSI(interp, cmdPtr, fname, &fStr, 1, pss);\n        else {\n            rc = jsi_wsFileRead(interp, fname, &fStr, cmdPtr, pss);\n            if (isJsiWeb)\n                Jsi_DSAppend(&fStr, \"\\nwindow.jsiWebSocket=true;\", NULL);\n        }\n        if (rc != JSI_OK) {\n            Jsi_DSFree(&fStr);\n            goto nofile;\n        }\n        int hrc = jsi_wsServeHeader(pss, wsi, (int)Jsi_DSLength(&fStr), 200, Jsi_DSValue(&hStr), mime, &dStr);\n        if (hrc>=0) {\n            Jsi_DSAppendLen(&dStr, Jsi_DSValue(&fStr), Jsi_DSLength(&fStr));\n            char *strVal = Jsi_DSValue(&dStr);\n            int strLen = Jsi_DSLength(&dStr);\n            hrc = jsi_wswrite(pss, wsi, (unsigned char*)strVal, strLen, LWS_WRITE_HTTP);\n        }\n        Jsi_DecrRefCount(interp, fname);\n        Jsi_DSFree(&dStr);\n        Jsi_DSFree(&fStr);\n        if (hrc<0) {\n            if (cmdPtr->noWarn==0)\n                fprintf(stderr, \"can not serve data (%d): %s\\n\", hrc, buf);\n            goto bail;\n        } else if (hrc > 0 && lws_http_transaction_completed(wsi))\n            goto bail;\n\n    }\ndone:\n    Jsi_DSFree(&hStr);\n    return rc;\n\nbail:\n    rc = 1;\n    goto done;\n}\n\nstatic Jsi_RC jsi_wsrecv_callback(Jsi_Interp *interp, jsi_wsCmdObj *cmdPtr, jsi_wsPss *pss,\n    const char *inPtr, int nlen, bool isClose)\n{\n    Jsi_Value *vpargs, *vargs[10];\n    Jsi_Value* func = NULL;\n    if (Jsi_InterpGone(interp) || (cmdPtr->deleted && !isClose)) return JSI_ERROR;\n    int n = 0;\n    if (isClose)\n        func = ((pss && pss->onClose)?pss->onClose:cmdPtr->onClose);\n    else\n        func = ((pss && pss->onRecv)?pss->onRecv:cmdPtr->onRecv);\n    if (!func)\n        return JSI_OK;\n    vargs[n++] = (cmdPtr->deleted?Jsi_ValueNewNull(interp):Jsi_ValueNewObj(interp, cmdPtr->fobj));\n    vargs[n++] = Jsi_ValueNewNumber(interp, (Jsi_Number)(pss?pss->wid:0));\n    if (!isClose) {\n        if (nlen<=0)\n            return JSI_OK;\n        vargs[n++]  = Jsi_ValueNewBlob(interp, (uchar*)inPtr, nlen);\n        if ((cmdPtr->echo||(pss && pss->echo)) && inPtr)\n            Jsi_LogInfo(\"WS-RECV: %s\\n\", inPtr);\n    }\n    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, vargs, n, 0));\n    Jsi_IncrRefCount(interp, vpargs);\n\n    Jsi_Value *ret = Jsi_ValueNew1(interp);\n    Jsi_RC rc = Jsi_FunctionInvoke(interp, func, vpargs, &ret, NULL);\n    if (rc == JSI_OK && Jsi_ValueIsUndef(interp, ret)==0 && !isClose) {\n        /* TODO: should we handle callback return data??? */\n    }\n    Jsi_DecrRefCount(interp, vpargs);\n    Jsi_DecrRefCount(interp, ret);\n    return rc;\n}\n\n#if (LWS_LIBRARY_VERSION_MAJOR>1)\nstatic int\njsi_wsFileUploadCB(void *data, const char *name, const char *filename,\n                   char *buf, int len, enum lws_spa_fileupload_states state)\n{\n    jsi_wsPss *pss = (typeof(pss))data;\n    jsi_wsCmdObj *cmdPtr = pss->cmdPtr;\n    Jsi_Value* callPtr = (pss->onUpload?pss->onUpload:cmdPtr->onUpload);\n    Jsi_Interp *interp = cmdPtr->interp;\n    const char *str;\n    int slen, n = 0;\n    if (cmdPtr->deleted) return -1;\n\n    Jsi_Obj *oarg1;\n    Jsi_Value *vpargs, *vargs[10];\n    if (state == LWS_UFS_OPEN)\n        pss->file_length = 0;\n    //id:number, filename:string, data:string, startpos:number, complete:boolean\n    vargs[n++] = Jsi_ValueNewObj(interp, cmdPtr->fobj);\n    vargs[n++] = Jsi_ValueNewNumber(interp, (Jsi_Number)(pss->wid));\n    vargs[n++] = Jsi_ValueNewBlobString(interp, filename);\n    vargs[n++] = Jsi_ValueNewBlob(interp, (uchar*)buf, (uint)len);\n    vargs[n++] = Jsi_ValueNewNumber(interp, (Jsi_Number)pss->file_length);\n    vargs[n++] = Jsi_ValueNewBoolean(interp, (state==LWS_UFS_FINAL_CONTENT));\n    vpargs = Jsi_ValueMakeObject(interp, NULL, oarg1 = Jsi_ObjNewArray(interp, vargs, n, 0));\n    Jsi_IncrRefCount(interp, vpargs);\n    pss->file_length += len;\n\n    Jsi_Value *ret = Jsi_ValueNew1(interp);\n    Jsi_ValueMakeUndef(interp, &ret);\n    Jsi_RC rc = Jsi_FunctionInvoke(interp, callPtr, vpargs, &ret, NULL);\n\n    if ((state==LWS_UFS_FINAL_CONTENT || rc != JSI_OK) && (str=Jsi_ValueString(interp, ret, &slen))) {\n        Jsi_DSAppendLen(&pss->resultStr, str, slen);\n        pss->resultCode = rc;\n    }\n\n    Jsi_DecrRefCount(interp, vpargs);\n    Jsi_DecrRefCount(interp, ret);\n    if (rc != JSI_OK) {\n        Jsi_LogError(\"websock bad rcv eval\");\n        return -1;\n    }\n    return 0;\n}\n#endif\n\nstatic int jsi_wscallback_http(struct lws *wsi,\n                         enum lws_callback_reasons reason, void *user,\n                         void *in, size_t len)\n{\n    struct lws_context *context = lws_get_context(wsi);\n    const char *inPtr = (char*)in;\n    char client_name[128], client_ip[128];\n    const char *res = \"\";\n#ifdef EXTERNAL_POLL\n    int m;\n    int fd = (int)(long)user;\n#endif\n    jsi_wsCmdObj *cmdPtr = (jsi_wsCmdObj *)lws_context_user(context);\n    if (!cmdPtr) {\n        fprintf(stderr, \"bad ws context\\n\");\n        return -1;\n    }\n    jsi_wsPss *pss = NULL;\n    Jsi_Interp *interp = cmdPtr->interp;\n    Jsi_Value* callPtr = NULL;\n    int rc = 0, deflt = 0;\n\n    WSSIGASSERT(cmdPtr, OBJ);\n    if (Jsi_InterpGone(interp))\n        cmdPtr->deleted = 1;\n\n    if (cmdPtr->debug>=128)\n        fprintf(stderr, \"HTTP CALLBACK: len=%d, %p %d:%s\\n\", (int)len, user, reason, jsw_getReasonStr(reason));\n\n    switch (reason) {\n#ifndef EXTERNAL_POLL\n    case LWS_CALLBACK_GET_THREAD_ID:\n    case LWS_CALLBACK_UNLOCK_POLL:\n    case LWS_CALLBACK_PROTOCOL_INIT:\n    case LWS_CALLBACK_ADD_POLL_FD:\n    case LWS_CALLBACK_DEL_POLL_FD:\n    case LWS_CALLBACK_CHANGE_MODE_POLL_FD:\n    case LWS_CALLBACK_LOCK_POLL:\n        return rc;\n#else\n        /*\n         * callbacks for managing the external poll() array appear in\n         * protocol 0 callback\n         */\n\n    case LWS_CALLBACK_ADD_POLL_FD:\n\n        if (jsi_wsnum_pollfds >= max_poll_elements) {\n            lwsl_err(\"LWS_CALLBACK_ADD_POLL_FD: too many sockets to track\\n\");\n            return 1;\n        }\n\n        fd_lookup[fd] = jsi_wsnum_pollfds;\n        jsi_wspollfds[jsi_wsnum_pollfds].fd = fd;\n        jsi_wspollfds[jsi_wsnum_pollfds].events = (int)(long)len;\n        jsi_wspollfds[jsi_wsnum_pollfds++].revents = 0;\n        break;\n\n    case LWS_CALLBACK_DEL_POLL_FD:\n        if (!--jsi_wsnum_pollfds)\n            break;\n        m = fd_lookup[fd];\n        /* have the last guy take up the vacant slot */\n        jsi_wspollfds[m] = jsi_wspollfds[jsi_wsnum_pollfds];\n        fd_lookup[jsi_wspollfds[jsi_wsnum_pollfds].fd] = m;\n        break;\n\n#endif\n\n    default:\n        deflt = 1;\n        break;\n\n    }\n\n    if (deflt && cmdPtr->debug>16 && cmdPtr->debug<128) {\n        fprintf(stderr, \"HTTP CALLBACK: len=%d, %p %d:%s\\n\", (int)len, user, reason, jsw_getReasonStr(reason));\n    }\n\n    switch (reason) {\n    case LWS_CALLBACK_WSI_DESTROY:\n        break;\n\n#if (LWS_LIBRARY_VERSION_MAJOR>1)\n    // Handle GET file download in client mode.\n    case LWS_CALLBACK_RECEIVE_CLIENT_HTTP: {\n        char buffer[1024 + LWS_PRE];\n        char *px = buffer + LWS_PRE;\n        int lenx = sizeof(buffer) - LWS_PRE;\n\n        if (lws_http_client_read(wsi, &px, &lenx) < 0)\n            return -1;\n        break;\n    }\n    case LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ:\n        if (jsi_wsrecv_callback(interp, cmdPtr, pss, inPtr, len, 0) != JSI_OK)\n            rc = 1;\n        break;\n\n    case LWS_CALLBACK_COMPLETED_CLIENT_HTTP:\n        if (jsi_wsrecv_callback(interp, cmdPtr, pss, inPtr, len, 1) != JSI_OK)\n            rc = 1;\n        break;\n\n    case LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER:\n        if (cmdPtr->post) {\n            unsigned char **p = (unsigned char **)in, *end = (*p) + len;\n            int n = 0;\n            char buf[100];\n            Jsi_ValueString(interp, cmdPtr->post, &n);\n            snprintf(buf, sizeof(buf), \"%d\", n);\n\n            if (lws_add_http_header_by_token(wsi,\n                    WSI_TOKEN_HTTP_CONTENT_LENGTH,\n                    (unsigned char *)buf, 2, p, end))\n                return -1;\n            if (lws_add_http_header_by_token(wsi,\n                    WSI_TOKEN_HTTP_CONTENT_TYPE,\n                    (unsigned char *)\"application/x-www-form-urlencoded\", 33, p, end))\n                return -1;\n\n            /* inform lws we have http body to send */\n            lws_client_http_body_pending(wsi, 1);\n            lws_callback_on_writable(wsi);\n        }\n        break;\n\n    case LWS_CALLBACK_CLIENT_HTTP_WRITEABLE: {\n        int n = 0;\n        char *cps = Jsi_ValueString(interp, cmdPtr->post, &n);\n        char *buf = (char*)Jsi_Calloc(1, LWS_PRE + n + 1);\n        Jsi_Strcpy(buf + LWS_PRE, cps);\n        n = lws_write(wsi, (unsigned char *)&buf[LWS_PRE], strlen(&buf[LWS_PRE]), LWS_WRITE_HTTP);\n        Jsi_Free(buf);\n        if (n < 0)\n            return -1;\n        /* we only had one thing to send, so inform lws we are done\n         * if we had more to send, call lws_callback_on_writable(wsi);\n         * and just return 0 from callback.  On having sent the last\n         * part, call the below api instead.*/\n        lws_client_http_body_pending(wsi, 0);\n        break;\n    }\n#endif\n\n    case LWS_CALLBACK_FILTER_NETWORK_CONNECTION:\n        break;\n    case LWS_CALLBACK_PROTOCOL_INIT:\n        break;\n    case LWS_CALLBACK_CLOSED_HTTP:\n        if (cmdPtr->debug>2)\n            fprintf(stderr, \"CLOSED\\n\");\n        if (!pss)\n            pss = jsi_wsgetPss(cmdPtr, wsi, user, 0, 1);\n        if (pss)\n            jsi_wsdeletePss(pss);\n        break;\n    case LWS_CALLBACK_WSI_CREATE:\n        break;\n\n    case LWS_CALLBACK_CONFIRM_EXTENSION_OKAY:\n        break;\n\n    case LWS_CALLBACK_FILTER_HTTP_CONNECTION:\n        if (cmdPtr->debug>1)\n            fprintf(stderr, \"FILTER CONNECTION: %s\\n\", inPtr);\n        pss = jsi_wsgetPss(cmdPtr, wsi, user, 1, 1);\n        Jsi_DSSet(&pss->url, inPtr);\n        jsi_wsgetUriArgValue(interp, wsi, &pss->query, &pss->queryObj);\n\n        if (cmdPtr->instCtx == context && (cmdPtr->clientName[0] || cmdPtr->clientIP[0])) {\n            pss->clientName = cmdPtr->clientName;\n            pss->clientIP = cmdPtr->clientIP;\n        }\n\n        Jsi_DSSetLength(&pss->dHdrs, 0);\n        pss->hdrNum = jsi_wsGetHeaders(pss, wsi, &pss->dHdrs, pss->hdrSz, sizeof(pss->hdrSz)/sizeof(int));\n\n        if (cmdPtr->onFilter && !cmdPtr->deleted) {\n            // 4 args: ws, id, url, bool\n            int killcon = 0, n = 0;\n            Jsi_Obj *oarg1;\n            Jsi_Value *vpargs, *vargs[10], *ret = Jsi_ValueNew1(interp);\n            vargs[n++] = Jsi_ValueNewObj(interp, cmdPtr->fobj);\n            vargs[n++] = Jsi_ValueNewNumber(interp, (Jsi_Number)(pss->wid));\n            vargs[n++] = Jsi_ValueNewBlob(interp, (uchar*)in, len);\n            vargs[n++] = Jsi_ValueNewBoolean(interp, 1);\n            vpargs = Jsi_ValueMakeObject(interp, NULL, oarg1 = Jsi_ObjNewArray(interp, vargs, n, 0));\n            Jsi_IncrRefCount(interp, vpargs);\n            Jsi_ValueMakeUndef(interp, &ret);\n            rc = Jsi_FunctionInvoke(interp, cmdPtr->onFilter, vpargs, &ret, NULL);\n            if (rc == JSI_OK && Jsi_ValueIsFalse(interp, ret)) {\n                if (cmdPtr->debug>1)\n                    fprintf(stderr, \"WS:KILLING CONNECTION: %p\\n\", pss);\n                killcon = 1;\n            }\n\n            Jsi_DecrRefCount(interp, vpargs);\n            Jsi_DecrRefCount(interp, ret);\n            if (rc != JSI_OK) {\n                Jsi_LogError(\"websock bad rcv eval\");\n                return 1;\n            }\n            if (killcon)\n                return 1;\n        }\n        break;\n\n    case LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED:\n        client_name[0] = 0;\n        client_ip[0] = 0;\n        lws_get_peer_addresses(wsi, lws_get_socket_fd(wsi), client_name,\n                                         sizeof(client_name), client_ip, sizeof(client_ip));\n        if (client_name[0])\n            cmdPtr->clientName = Jsi_KeyAdd(interp, client_name);\n        if (client_ip[0])\n            cmdPtr->clientIP = Jsi_KeyAdd(interp, client_ip);\n\n        if (cmdPtr->clientName || cmdPtr->clientIP) {\n            const char *loname = cmdPtr->localhostName;\n            if (!loname) loname = \"localhost\";\n            cmdPtr->instCtx = context;\n            if (cmdPtr->debug>1)\n                fprintf(stderr,  \"Received network connect from %s (%s)\\n\",\n                     cmdPtr->clientName, cmdPtr->clientIP);\n#ifndef __WIN32\n            if (cmdPtr->local && (cmdPtr->clientName && Jsi_Strcmp(cmdPtr->clientName, loname))) {\n                if (cmdPtr->debug>1)\n                    fprintf(stderr,  \"Dropping non-localhost connection\\n\");\n                return 1;\n            }\n#endif\n        }\n\n        if (cmdPtr->maxConnects && cmdPtr->stats.connectCnt>=cmdPtr->maxConnects) {\n            if (cmdPtr->debug>1)\n                fprintf(stderr, \"maxConnects exceeded: rejecting connection <%p>\\n\", user);\n            rc = -1;\n        }\n        /* if we returned non-zero from here, we kill the connection */\n        break;\n\n    case LWS_CALLBACK_HTTP:\n    {\n        Jsi_DString dStr;\n        Jsi_DSInit(&dStr);\n        if (cmdPtr->debug)\n            fprintf(stderr, \"HTTP GET: %s\\n\", inPtr);\n        rc = jsi_wsHttp(interp, cmdPtr, wsi, user, context, inPtr, &dStr, pss);\n        Jsi_DSFree(&dStr);\n        if (rc<0)\n            return -1;\n        if (rc==1) {\n            goto try_to_reuse;\n        }\n        break;\n    }\n\n#if (LWS_LIBRARY_VERSION_MAJOR>1)\n    case LWS_CALLBACK_HTTP_BODY: {\n        if (!pss)\n            pss = jsi_wsgetPss(cmdPtr, wsi, user, 0, 1);\n        if (!pss) break;\n        callPtr = (pss->onUpload?pss->onUpload:cmdPtr->onUpload);\n        if (cmdPtr->maxUpload<=0 || !callPtr) {\n            if (cmdPtr->noWarn==0)\n                fprintf(stderr, \"Upload disabled: maxUpload=%d, onUpload=%p\\n\", cmdPtr->maxUpload, callPtr);\n            return -1;\n        }\n\n        if (!pss->spa) {\n            /* create the POST argument parser */\n            if (!pss->paramv) {\n                if (cmdPtr->formParams && cmdPtr->formParams != jsi_wsparam_str)\n                    Jsi_SplitStr(cmdPtr->formParams, &pss->paramc, &pss->paramv, \",\", &pss->paramDS);\n                else {\n                    pss->paramv = (typeof(pss->paramv))jsi_wsparam_names;\n                    pss->paramc = ARRAY_SIZE(jsi_wsparam_names);\n                }\n            }\n            pss->spa = lws_spa_create(wsi, (const char*const*)pss->paramv,\n                pss->paramc, 4096, jsi_wsFileUploadCB, pss);\n            if (!pss->spa)\n                    return -1;\n\n            pss->filename[0] = '\\0';\n            pss->file_length = 0;\n        }\n\n        cmdPtr->stats.uploadLast = pss->stats.uploadLast = time(NULL);\n\n        /* let it parse the POST data */\n        if (lws_spa_process(pss->spa, inPtr, len))\n                return -1;\n\n\n        if (!pss->stats.uploadStart) {\n            cmdPtr->stats.uploadEnd = pss->stats.uploadEnd = 0;\n            cmdPtr->stats.uploadStart = pss->stats.uploadStart = time(NULL);\n            cmdPtr->stats.uploadCnt++;\n            pss->stats.uploadCnt++;\n        }\n        break;\n    }\n\n    case LWS_CALLBACK_HTTP_BODY_COMPLETION:\n        if (!pss) {\n            pss = jsi_wsgetPss(cmdPtr, wsi, user, 0, 1);\n            callPtr = (pss&&pss->onUpload?pss->onUpload:cmdPtr->onUpload);\n        }\n        if (pss && pss->spa)\n            lws_spa_finalize(pss->spa);\n        res = Jsi_DSValue(&pss->resultStr);\n        if (!res[0]) {\n            if (!pss->resultCode)\n                res = \"<html><body>Upload complete</body></html>\";\n            else\n                res = \"<html><body>Upload error</body></html>\";\n        }\n        jsi_wsServeString(pss, wsi, res, pss->resultCode==JSI_OK?0:500, NULL, NULL);\n        if (cmdPtr->maxUpload<=0 || !callPtr) {\n            if (cmdPtr->noWarn==0)\n                fprintf(stderr, \"Upload disabled: maxUpload=%d, onUpload=%p\\n\", cmdPtr->maxUpload, callPtr);\n            return -1;\n        }\n        cmdPtr->stats.uploadEnd = pss->stats.uploadEnd = time(NULL);\n        lws_return_http_status(wsi, HTTP_STATUS_OK, NULL);\n        goto try_to_reuse;\n\n    case LWS_CALLBACK_HTTP_DROP_PROTOCOL:\n        pss = jsi_wsgetPss(cmdPtr, wsi, user, 0, 1);\n        if (pss && pss->spa) {\n            lws_spa_destroy(pss->spa);\n            pss->spa = NULL;\n        }\n        break;\n#endif\n\n    case LWS_CALLBACK_HTTP_FILE_COMPLETION:\n        goto try_to_reuse;\n\n    case LWS_CALLBACK_HTTP_WRITEABLE: {\n        lwsl_info(\"LWS_CALLBACK_HTTP_WRITEABLE\\n\");\n        if (!pss)\n            pss = jsi_wsgetPss(cmdPtr, wsi, user, 0, 1);\n\n        if (!pss || !pss->fop_fd)\n            goto try_to_reuse;\n\n        /*\n         * we can send more of whatever it is we were sending\n         */\n        int sent = 0;\n        unsigned char buffer[JSI_BUFSIZ*10 + LWS_PRE];\n        do {\n            int n = sizeof(buffer) - LWS_PRE;\n            int m = lws_get_peer_write_allowance(wsi);\n            if (m == 0)\n                goto later;\n\n            if (m != -1 && m < n)\n                n = m;\n\n            lws_filepos_t amount = 0;\n            n = lws_vfs_file_read(pss->fop_fd, &amount, buffer + LWS_PRE, n);\n            if (n < 0) {\n                lwsl_err(\"problem reading file\\n\");\n                goto bail;\n            }\n            n = (int)amount;\n            if (n == 0)\n                goto penultimate;\n            /*\n             * To support HTTP2, must take care about preamble space\n             *\n             * identification of when we send the last payload frame\n             * is handled by the library itself if you sent a\n             * content-length header\n             */\n            m = jsi_wswrite(pss, wsi, buffer + LWS_PRE, n, LWS_WRITE_HTTP);\n            if (m < 0) {\n                lwsl_err(\"write failed\\n\");\n                /* write failed, close conn */\n                goto bail;\n            }\n            if (m) /* while still active, extend timeout */\n                lws_set_timeout(wsi, PENDING_TIMEOUT_HTTP_CONTENT, 5);\n            sent += m;\n\n        } while (!lws_send_pipe_choked(wsi) && (sent < 500 * 1024 * 1024));\nlater:\n        lws_callback_on_writable(wsi);\n        break;\npenultimate:\n        lws_vfs_file_close(&pss->fop_fd);\n        goto try_to_reuse;\n\nbail:\n        lws_vfs_file_close(&pss->fop_fd);\n        rc = -1;\n        goto doret;\n    }\n\n    default:\n        break;\n    }\n\n    goto doret;\n\ntry_to_reuse:\n    if (lws_http_transaction_completed(wsi))\n         rc = -1;\n    else\n        rc = 0;\n    goto doret;\n\ndoret:\n    if (cmdPtr->debug>2)\n        fprintf(stderr, \"<---HTTP RET = %d\\n\", rc);\n    return rc;\n}\n\nstatic int\njsi_wscallback_websock(struct lws *wsi,\n      enum lws_callback_reasons reason,\n      void *user, void *in, size_t len)\n{\n    struct lws_context *context = lws_get_context(wsi);\n\n    jsi_wsPss *pss = NULL;\n    jsi_wsCmdObj *cmdPtr = (jsi_wsCmdObj *)lws_context_user(context);\n    if (!cmdPtr) {\n        fprintf(stderr, \"null ws context\\n\");\n        return -1;\n    }\n    Jsi_Interp *interp = cmdPtr->interp;\n    char *inPtr = (char*)in;\n    int sLen, n, rc =0;\n    WSSIGASSERT(cmdPtr, OBJ);\n    if (Jsi_InterpGone(interp))\n        cmdPtr->deleted = 1;\n\n    if (cmdPtr->debug>=32) {\n        switch (reason) {\n            case LWS_CALLBACK_SERVER_WRITEABLE:\n            case LWS_CALLBACK_CLIENT_WRITEABLE:\n                break;\n            default:\n                fprintf(stderr, \"WS CALLBACK: len=%d, %p %d:%s\\n\", (int)len, user, reason, jsw_getReasonStr(reason));\n        }\n    }\n\n    switch (reason) {\n    case LWS_CALLBACK_PROTOCOL_INIT:\n        if (cmdPtr->noWebsock)\n            return 1;\n        break;\n\n    case LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION:\n        pss = jsi_wsgetPss(cmdPtr, wsi, user, 1, 1);\n        Jsi_DSSet(&pss->url, inPtr);\n        if (cmdPtr->instCtx == context && (cmdPtr->clientName[0] || cmdPtr->clientIP[0])) {\n            pss->clientName = cmdPtr->clientName;\n            pss->clientIP = cmdPtr->clientIP;\n        }\n        if (cmdPtr->onFilter && !cmdPtr->deleted) {\n            if (!pss)\n                pss = jsi_wsgetPss(cmdPtr, wsi, user, 1, 0);\n            int killcon = 0, n = 0;\n            Jsi_Obj *oarg1;\n            Jsi_Value *vpargs, *vargs[10], *ret = Jsi_ValueNew1(interp);\n\n            vargs[n++] = Jsi_ValueNewObj(interp, cmdPtr->fobj);\n            vargs[n++] = Jsi_ValueNewNumber(interp, (Jsi_Number)(pss->wid));\n            vargs[n++] = Jsi_ValueNewBlob(interp, (uchar*)in, len);\n            vargs[n++] = Jsi_ValueNewBoolean(interp, 0);\n            vpargs = Jsi_ValueMakeObject(interp, NULL, oarg1 = Jsi_ObjNewArray(interp, vargs, n, 0));\n            Jsi_IncrRefCount(interp, vpargs);\n            Jsi_ValueMakeUndef(interp, &ret);\n            rc = Jsi_FunctionInvoke(interp, cmdPtr->onFilter, vpargs, &ret, NULL);\n            if (rc == JSI_OK && Jsi_ValueIsFalse(interp, ret)) {\n                if (cmdPtr->debug>1)\n                    fprintf(stderr, \"WS:KILLING CONNECTION: %p\\n\", user);\n                killcon = 1;\n            }\n\n            Jsi_DecrRefCount(interp, vpargs);\n            Jsi_DecrRefCount(interp, ret);\n            if (rc != JSI_OK) {\n                Jsi_LogError(\"websock bad rcv eval\");\n                return 1;\n            }\n            if (killcon)\n                return 1;\n        }\n        break;\n\n    case LWS_CALLBACK_CLIENT_ESTABLISHED:\n    case LWS_CALLBACK_ESTABLISHED:\n        if (cmdPtr->bufferPwr2>0) {\n            char nbuf[100];\n            snprintf(nbuf, sizeof(nbuf), \"%d\", cmdPtr->bufferPwr2);\n            lws_set_extension_option(wsi, \"permessage-deflate\", \"rx_buf_size\", nbuf);\n            lws_set_extension_option(wsi, \"permessage-deflate\", \"tx_buf_size\", nbuf);\n        }\n        if (!pss)\n            pss = jsi_wsgetPss(cmdPtr, wsi, user, 1, 0);\n        if (cmdPtr->onOpen && !cmdPtr->deleted) {\n            /* Pass 2 args: ws id. */\n            Jsi_Obj *oarg1;\n            Jsi_Value *vpargs, *vargs[10];\n            int n = 0;\n            vargs[n++] = Jsi_ValueNewObj(interp, cmdPtr->fobj);\n            vargs[n++] = Jsi_ValueNewNumber(interp, (Jsi_Number)(pss->wid));\n            vpargs = Jsi_ValueMakeObject(interp, NULL, oarg1 = Jsi_ObjNewArray(interp, vargs, n, 0));\n            Jsi_IncrRefCount(interp, vpargs);\n\n            Jsi_Value *ret = Jsi_ValueNew1(interp);\n            Jsi_ValueMakeUndef(interp, &ret);\n            rc = Jsi_FunctionInvoke(interp, cmdPtr->onOpen, vpargs, &ret, NULL);\n\n            Jsi_DecrRefCount(interp, vpargs);\n            Jsi_DecrRefCount(interp, ret);\n            if (rc != JSI_OK)\n                return Jsi_LogError(\"websock bad rcv eval\");\n        }\n        break;\n\n    case LWS_CALLBACK_WSI_DESTROY:\n        break;\n\n    case LWS_CALLBACK_CLOSED:\n    case LWS_CALLBACK_PROTOCOL_DESTROY:\n        pss = jsi_wsgetPss(cmdPtr, wsi, user, 0, 0);\n        if (!pss) break;\n        if (cmdPtr->onClose || pss->onClose) {\n            rc = jsi_wsrecv_callback(interp, cmdPtr, pss, inPtr, len, 1);\n            if (rc != JSI_OK)\n                return Jsi_LogError(\"websock bad rcv eval\");\n        }\n        jsi_wsdeletePss(pss);\n        if (cmdPtr->stats.connectCnt<=0 && cmdPtr->onCloseLast && !Jsi_InterpGone(interp)) {\n            Jsi_RC jrc;\n            Jsi_Value *retStr = Jsi_ValueNew1(interp);\n            // 1 args: ws\n            Jsi_Value *vpargs, *vargs[10];\n            int n = 0;\n            vargs[n++] = (cmdPtr->deleted?Jsi_ValueNewNull(interp):Jsi_ValueNewObj(interp, cmdPtr->fobj));\n            vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, vargs, n, 0));\n            Jsi_IncrRefCount(interp, vpargs);\n            jrc = Jsi_FunctionInvoke(interp, cmdPtr->onCloseLast, vpargs, &retStr, NULL);\n            Jsi_DecrRefCount(interp, vpargs);\n            Jsi_DecrRefCount(interp, retStr);\n            if (Jsi_InterpGone(interp))\n                return JSI_ERROR;\n            return jrc;\n        }\n        break;\n\n    case LWS_CALLBACK_CLIENT_WRITEABLE:\n    case LWS_CALLBACK_SERVER_WRITEABLE: {\n        pss = jsi_wsgetPss(cmdPtr, wsi, user, 0, 0);\n        if (!pss || !pss->stack) break;\n        if (pss->lastData)\n            Jsi_Free(pss->lastData);\n        n=0;\n        char *data = pss->lastData = (char*)Jsi_StackUnshift(pss->stack);\n        unsigned char *p;\n        if (data == NULL)\n            break;\n        pss->stats.msgQLen--;\n        pss->state = PWS_SENT;\n        p = (unsigned char *)data+LWS_PRE;\n        sLen = Jsi_Strlen((char*)p);\n        n = jsi_wswrite(pss, wsi, p, sLen, (pss->stats.isBinary?LWS_WRITE_BINARY:LWS_WRITE_TEXT));\n        if (cmdPtr->debug>=10)\n            fprintf(stderr, \"WS:CLIENT WRITE(%p): %d=>%d\\n\", pss, sLen, n);\n\n        if (n >= 0) {\n            cmdPtr->stats.sentCnt++;\n            cmdPtr->stats.sentLast = time(NULL);\n            pss->stats.sentCnt++;\n            pss->stats.sentLast = time(NULL);\n        } else {\n            lwsl_err(\"ERROR %d writing to socket\\n\", n);\n            pss->state = PWS_SENDERR;\n            pss->stats.sentErrCnt++;\n            pss->stats.sentErrLast = time(NULL);\n            cmdPtr->stats.sentErrCnt++;\n            cmdPtr->stats.sentErrLast = time(NULL);\n            rc = 1;\n        }\n        break;\n    }\n\n    case LWS_CALLBACK_CLIENT_RECEIVE:\n    case LWS_CALLBACK_RECEIVE:\n    {\n        pss = jsi_wsgetPss(cmdPtr, wsi, user, 0, 0);\n        if (!pss) break;\n\n        pss->stats.recvCnt++;\n        pss->stats.recvLast = time(NULL);\n        cmdPtr->stats.recvCnt++;\n        cmdPtr->stats.recvLast = time(NULL);\n\n        if (cmdPtr->onRecv || pss->onRecv) {\n            /* Pass 2 args: id and data. */\n            int nlen = len;\n            if (nlen<=0)\n                return 0;\n            int rblen = Jsi_DSLength(&pss->recvBuf),\n                bmax = cmdPtr->recvBufMax,\n                isfin = pss->stats.isFinal = lws_is_final_fragment(wsi);\n            pss->stats.isBinary = lws_frame_is_binary(wsi);\n            if (rblen) {\n                if (bmax && rblen>bmax) {\n                    fprintf(stderr, \"WS: Recv exceeds recvBufMax: %d>%d\\n\", rblen, bmax);\n                    rc = 1;\n                    break;\n                }\n                Jsi_DSAppendLen(&pss->recvBuf, inPtr, len);\n                if (!isfin) break;\n                cmdPtr->recvBufCnt--;\n                nlen = Jsi_DSLength(&pss->recvBuf);\n                inPtr = Jsi_DSFreeDup(&pss->recvBuf);\n            } else {\n                if (!isfin) {\n                    cmdPtr->recvBufCnt++;\n                    Jsi_DSAppendLen(&pss->recvBuf, inPtr, len);\n                    break;\n                }\n            }\n            rc = jsi_wsrecv_callback(interp, cmdPtr, pss, inPtr, nlen, 0);\n            if (inPtr != in)\n                Jsi_Free(inPtr);\n            if (rc != JSI_OK) {\n                Jsi_LogError(\"websock bad rcv eval\");\n                return 1;\n            }\n        }\n        lws_callback_on_writable_all_protocol(cmdPtr->context, lws_get_protocol(wsi));\n        break;\n\n    }\n    default:\n        break;\n    }\n    return rc;\n}\n\n\nstatic Jsi_RC WebSocketConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    jsi_wsCmdObj *cmdPtr = (jsi_wsCmdObj*)Jsi_UserObjGetData(interp, _this, funcPtr);\n\n    if (!cmdPtr)\n        return Jsi_LogError(\"Apply in a non-websock object\");\n    Jsi_Value *opts = Jsi_ValueArrayIndex(interp, args, 0);\n    if (cmdPtr->noConfig && opts && !Jsi_ValueIsString(interp, opts))\n        return Jsi_LogError(\"WebSocket conf() is disabled for set\");\n    return Jsi_OptionsConf(interp, WSOptions, cmdPtr, opts, ret, 0);\n\n}\n\nstatic Jsi_RC WebSocketIdCmdOp(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr, int op)\n{\n    Jsi_RC rc = JSI_OK;\n    jsi_wsCmdObj *cmdPtr = (jsi_wsCmdObj*)Jsi_UserObjGetData(interp, _this, funcPtr);\n    if (!cmdPtr)\n        return Jsi_LogError(\"Apply in a non-websock object\");\n    Jsi_Value *v, *valPtr = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_Number vid;\n    if (Jsi_ValueGetNumber(interp, valPtr, &vid) != JSI_OK || vid < 0)\n        return Jsi_LogError(\"Expected connection number id\");\n    int id = (int)vid;\n    jsi_wsPss *pss = NULL;\n    Jsi_HashEntry *hPtr;\n    Jsi_HashSearch cursor;\n    for (hPtr = Jsi_HashSearchFirst(cmdPtr->pssTable, &cursor);\n        hPtr != NULL; hPtr = Jsi_HashSearchNext(&cursor)) {\n        jsi_wsPss* tpss = (jsi_wsPss*)Jsi_HashValueGet(hPtr);\n        WSSIGASSERT(tpss, PWS);\n        if (tpss->wid == id && tpss->state != PWS_DEAD) {\n            pss = tpss;\n            break;\n        }\n    }\n\n    if (!pss)\n        return Jsi_LogError(\"No such id: %d\", id);\n    switch (op) {\n        case 0:\n            v = Jsi_ValueArrayIndex(interp, args, 1);\n            rc = Jsi_OptionsConf(interp, WPSOptions, pss, v, ret, 0);\n            break;\n        case 1:\n            jsi_wsDumpHeaders(cmdPtr, pss, Jsi_ValueArrayIndexToStr(interp, args, 1, NULL), ret);\n            break;\n        case 2:\n            if (!pss->spa) return JSI_OK;\n            jsi_wsDumpQuery(cmdPtr, pss, Jsi_ValueArrayIndexToStr(interp, args, 1, NULL), ret);\n            break;\n    }\n    return rc;\n}\n\nstatic Jsi_RC WebSocketIdConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    return WebSocketIdCmdOp(interp, args, _this, ret, funcPtr, 0);\n}\n\nstatic Jsi_RC WebSocketHeaderCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    return WebSocketIdCmdOp(interp, args, _this, ret, funcPtr, 1);\n}\n\nstatic Jsi_RC WebSocketQueryCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    return WebSocketIdCmdOp(interp, args, _this, ret, funcPtr, 2);\n}\n\n\nstatic Jsi_RC WebSocketIdsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    jsi_wsCmdObj *cmdPtr = (jsi_wsCmdObj*)Jsi_UserObjGetData(interp, _this, funcPtr);\n    if (!cmdPtr)\n        return Jsi_LogError(\"Apply in a non-websock object\");\n    const char *val = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    Jsi_DString dStr = {\"[\"};\n    jsi_wsPss *pss = NULL;\n    Jsi_HashEntry *hPtr;\n    Jsi_HashSearch cursor;\n    int cnt = 0;\n    for (hPtr = Jsi_HashSearchFirst(cmdPtr->pssTable, &cursor);\n        hPtr != NULL; hPtr = Jsi_HashSearchNext(&cursor)) {\n        pss = (jsi_wsPss*)Jsi_HashValueGet(hPtr);\n        WSSIGASSERT(pss, PWS);\n        if (pss->state == PWS_DEAD) continue;\n        if (val && Jsi_Strcmp(pss->key, val)) continue;\n        Jsi_DSPrintf(&dStr, \"%s%d\", (cnt++?\",\":\"\"), pss->wid);\n        if (val) break;\n    }\n    Jsi_DSAppend(&dStr, \"]\", NULL);\n    Jsi_RC rc = Jsi_JSONParse(interp, Jsi_DSValue(&dStr), ret, 0);\n    Jsi_DSFree(&dStr);\n    return rc;\n}\n\n\nstatic Jsi_RC jsi_wsHandlerAdd(Jsi_Interp *interp, jsi_wsCmdObj *cmdPtr, const char *ext, const char *cmd, int flags)\n{\n    Jsi_HashEntry *hPtr;\n    jsi_wsHander *hdlPtr;\n    Jsi_Value *valPtr = Jsi_ValueNewStringDup(interp, cmd);\n    hPtr = Jsi_HashEntryNew(cmdPtr->handlers, ext, NULL);\n    if (!hPtr)\n        return JSI_ERROR;\n    hdlPtr = (jsi_wsHander *)Jsi_Calloc(1, sizeof(*hdlPtr));\n    hdlPtr->val = valPtr;\n    hdlPtr->flags = flags;\n    Jsi_HashValueSet(hPtr, hdlPtr);\n    Jsi_IncrRefCount(interp, valPtr);\n    return JSI_OK;\n}\n\n#define FN_wshandler JSI_INFO(\"\\\nWith no args, returns list of handlers.  With one arg, returns value for that handler.\\n\\\nOtherwise, sets the handler. When cmd is a string, the call is via runModule([cmd], arg).\\n\\\nIf a cmd is a function, it is called with a single arg: the file name.\")\nstatic Jsi_RC WebSocketHandlerCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    jsi_wsCmdObj *cmdPtr = (jsi_wsCmdObj*)Jsi_UserObjGetData(interp, _this, funcPtr);\n    Jsi_HashEntry *hPtr;\n    jsi_wsHander *hdlPtr;\n    if (!cmdPtr)\n        return Jsi_LogError(\"Apply in a non-websock object\");\n    WSSIGASSERT(cmdPtr, OBJ);\n    int argc = Jsi_ValueGetLength(interp, args);\n    if (argc == 0) {\n        Jsi_HashSearch search;\n        Jsi_Obj* obj = Jsi_ObjNew(interp);\n        for (hPtr = Jsi_HashSearchFirst(cmdPtr->handlers, &search); hPtr; hPtr = Jsi_HashSearchNext(&search)) {\n            const char *key = (char*)Jsi_HashKeyGet(hPtr);\n            Jsi_Value *val = (Jsi_Value*)Jsi_HashValueGet(hPtr);\n            Jsi_ObjInsert(interp, obj, key, val, 0);\n        }\n        Jsi_ValueMakeObject(interp, ret, obj);\n        return JSI_OK;\n    }\n    if (argc == 1) {\n        hPtr = Jsi_HashEntryFind(cmdPtr->handlers, Jsi_ValueArrayIndexToStr(interp, args, 0, NULL));\n        if (!hPtr)\n            return JSI_OK;\n        hdlPtr = (jsi_wsHander*)Jsi_HashValueGet(hPtr);\n        Jsi_ValueReplace(interp, ret, hdlPtr->val);\n        return JSI_OK;\n    }\n    const char *key = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    Jsi_Value *valPtr = Jsi_ValueArrayIndex(interp, args, 1);\n    if (Jsi_ValueIsNull(interp, valPtr)) {\n        hPtr = Jsi_HashEntryFind(cmdPtr->handlers, key);\n        if (!hPtr)\n            return JSI_OK;\n        hdlPtr = (jsi_wsHander*)Jsi_HashValueGet(hPtr);\n        if (hdlPtr->val)\n            Jsi_DecrRefCount(interp, hdlPtr->val);\n        Jsi_HashValueSet(hPtr, NULL);\n        Jsi_HashEntryDelete(hPtr);\n        Jsi_Free(hdlPtr);\n        Jsi_ValueMakeStringDup(interp, ret, key);\n        return JSI_OK;\n    }\n    if (Jsi_ValueIsFunction(interp, valPtr)==0 && Jsi_ValueIsString(interp, valPtr)==0)\n        return Jsi_LogError(\"expected string, function or null\");\n    Jsi_Value *argPtr = Jsi_ValueArrayIndex(interp, args, 2);\n    if (argPtr) {\n        if (Jsi_ValueIsNull(interp, argPtr))\n            argPtr = NULL;\n        else if (!Jsi_ValueIsString(interp, argPtr))\n            return Jsi_LogError(\"expected a string\");\n    }\n    hPtr = Jsi_HashEntryNew(cmdPtr->handlers, key, NULL);\n    if (!hPtr)\n        return JSI_ERROR;\n    hdlPtr = (jsi_wsHander *)Jsi_Calloc(1, sizeof(*hdlPtr));\n    Jsi_Value *flagPtr = Jsi_ValueArrayIndex(interp, args, 1);\n    Jsi_Number fl = 0;\n    if (flagPtr && Jsi_ValueIsNumber(interp, flagPtr))\n        Jsi_ValueGetNumber(interp, flagPtr, &fl);\n    hdlPtr->val = valPtr;\n    hdlPtr->flags = fl;\n    Jsi_HashValueSet(hPtr, hdlPtr);\n    Jsi_IncrRefCount(interp, valPtr);\n    return JSI_OK;\n}\n\n#define FN_wssend JSI_INFO(\"\\\nSend a message to one (or all connections if -1). If not already a string, msg is formatted as JSON prior to the send.\")\n\nstatic Jsi_RC WebSocketSendCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    jsi_wsCmdObj *cmdPtr = (jsi_wsCmdObj*)Jsi_UserObjGetData(interp, _this, funcPtr);\n    if (!cmdPtr)\n        return Jsi_LogError(\"Apply in a non-websock object\");\n    WSSIGASSERT(cmdPtr, OBJ);\n    jsi_wsPss *pss;\n    Jsi_HashEntry *hPtr;\n    Jsi_HashSearch cursor;\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 1);\n    char *str = Jsi_ValueString(interp, arg, NULL);\n    int id = -1, argc = Jsi_ValueGetLength(interp, args);\n    Jsi_DString eStr = {};\n    if (argc!=2)\n        return Jsi_LogError(\"wrong args\");\n    Jsi_Number dnum;\n    Jsi_Value *darg = Jsi_ValueArrayIndex(interp, args, 0);\n    if (Jsi_ValueGetNumber(interp, darg, &dnum) != JSI_OK)\n        return Jsi_LogError(\"invalid id\");\n    id = (int)dnum;\n\n    if (!str)\n        str = (char*)Jsi_ValueGetDString(interp, arg, &eStr, JSI_OUTPUT_JSON);\n\n    if (cmdPtr->echo)\n        Jsi_LogInfo(\"WS-SEND: %s\\n\", str);\n\n    for (hPtr = Jsi_HashSearchFirst(cmdPtr->pssTable, &cursor);\n        hPtr != NULL; hPtr = Jsi_HashSearchNext(&cursor)) {\n        pss = (jsi_wsPss*)Jsi_HashValueGet(hPtr);\n        WSSIGASSERT(pss, PWS);\n        if ((id<0 || pss->wid == id) && pss->state != PWS_DEAD) {\n            if (!pss->stack)\n                pss->stack = Jsi_StackNew();\n            char *msg = (char*)Jsi_Malloc(LWS_PRE + Jsi_Strlen(str) + 1);\n            Jsi_Strcpy(msg + LWS_PRE, str);\n            Jsi_StackPush(pss->stack, msg);\n            pss->stats.msgQLen++;\n            if (!cmdPtr->echo && pss->echo)\n                Jsi_LogInfo(\"WS-SEND: %s\\n\", str);\n        }\n    }\n\n    Jsi_DSFree(&eStr);\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_wsrecv_flush(jsi_wsCmdObj *cmdPtr, jsi_wsPss *pss)\n{\n    int nlen = Jsi_DSLength(&pss->recvBuf);\n    if (nlen<=0)\n        return JSI_OK;\n    cmdPtr->recvBufCnt--;\n    const char *inPtr = Jsi_DSFreeDup(&pss->recvBuf);\n    Jsi_RC rc = jsi_wsrecv_callback(cmdPtr->interp, cmdPtr, pss, inPtr, nlen, 0);\n    if (rc != JSI_OK) {\n        pss->stats.recvErrCnt++;\n        pss->stats.recvErrLast = time(NULL);\n    }\n    return rc;\n}\n\nstatic void jsi_wsOnModify(jsi_wsCmdObj *cmdPtr) {\n    if (!cmdPtr->stats.httpLast) return;\n    time_t now = time(NULL);\n    double dt = (difftime(now, cmdPtr->lastModifyCheck));\n    if (dt<0) {\n        cmdPtr->lastModifyCheck = now;\n        return;\n    }\n    uint secs = cmdPtr->modifySecs;\n    if (!secs) secs = 2;\n    if (dt<secs) return;\n    cmdPtr->lastModifyCheck = now;\n    Jsi_Interp *interp = cmdPtr->interp;\n    Jsi_HashEntry *hPtr;\n    Jsi_HashSearch cursor;\n    Jsi_Value* changed = NULL;\n    time_t ll = cmdPtr->lastModifyNotify;\n    if (ll<cmdPtr->stats.httpLast)\n        ll = cmdPtr->stats.httpLast;\n    for (hPtr = Jsi_HashSearchFirst(cmdPtr->fileHash, &cursor);\n        hPtr != NULL; hPtr = Jsi_HashSearchNext(&cursor)) {\n        jsi_wsFile* fPtr = (jsi_wsFile*)Jsi_HashValueGet(hPtr);\n        if (fPtr && fPtr->fileVal) {\n            Jsi_StatBuf sb;\n            int n = Jsi_Stat(interp, fPtr->fileVal, &sb);\n            if (!n && sb.st_mtime > ll) {\n                changed = fPtr->fileVal;\n                break;\n            }\n        }\n    }\n    cmdPtr->lastModifyCheck = time(NULL);\n    if (!changed) return;\n    Jsi_Obj *oarg1;\n    Jsi_Value *vpargs, *vargs[10];\n    int n = 0;\n    vargs[n++] = Jsi_ValueNewObj(interp, cmdPtr->fobj);\n    vargs[n++] = changed;\n    vpargs = Jsi_ValueMakeObject(interp, NULL, oarg1 = Jsi_ObjNewArray(interp, vargs, n, 0));\n    Jsi_IncrRefCount(interp, vpargs);\n\n    Jsi_Value *ret = Jsi_ValueNew1(interp);\n    Jsi_ValueMakeUndef(interp, &ret);\n    Jsi_RC rc = Jsi_FunctionInvoke(interp, cmdPtr->onModify, vpargs, &ret, NULL);\n\n    Jsi_DecrRefCount(interp, vpargs);\n    Jsi_DecrRefCount(interp, ret);\n    if (rc != JSI_OK) {\n        Jsi_LogWarn(\"websock bad onModify eval: disabling\");\n        Jsi_DecrRefCount(interp, cmdPtr->onModify);\n        cmdPtr->onModify = NULL;\n    }\n    cmdPtr->lastModifyCheck = time(NULL);\n    cmdPtr->lastModifyNotify = time(NULL);\n}\n\nstatic int jsi_wsService(jsi_wsCmdObj *cmdPtr)\n{\n    int n = 0;\n    struct timeval tv;\n    if (cmdPtr->inUpdate) return 0;\n    cmdPtr->inUpdate = 1;\n\n    gettimeofday(&tv, NULL);\n    int to = cmdPtr->recvBufTimeout;\n    if (to>0 && cmdPtr->recvBufCnt) { // Flush buffered data.\n        jsi_wsPss *pss = NULL;\n        Jsi_HashEntry *hPtr;\n        Jsi_HashSearch cursor;\n        for (hPtr = Jsi_HashSearchFirst(cmdPtr->pssTable, &cursor);\n            hPtr != NULL; hPtr = Jsi_HashSearchNext(&cursor)) {\n            pss = (jsi_wsPss*)Jsi_HashValueGet(hPtr);\n            WSSIGASSERT(pss, PWS);\n            if (pss->state == PWS_DEAD) continue;\n            if (Jsi_DSLength(&pss->recvBuf)<=0) continue;\n            if (pss->stats.recvLast && difftime(time(NULL), pss->stats.recvLast)<(double)to) continue;\n            jsi_wsrecv_flush(cmdPtr, pss);\n        }\n    }\n\n    /*\n     * This provokes the LWS_CALLBACK_SERVER_WRITEABLE for every\n     * live websocket connection using the DUMB_INCREMENT protocol,\n     * as soon as it can take more packets (usually immediately)\n     */\n\n    if (((unsigned int)tv.tv_usec - cmdPtr->oldus) > 50000) {\n        lws_callback_on_writable_all_protocol(cmdPtr->context, &cmdPtr->protocols[JWS_PROTOCOL_WEBSOCK]);\n        cmdPtr->oldus = tv.tv_usec;\n    }\n\n#ifdef EXTERNAL_POLL\n\n    /*\n     * this represents an existing server's single poll action\n     * which also includes libwebsocket sockets\n     */\n\n    n = poll(jsi_wspollfds, jsi_wsnum_pollfds, 50);\n    if (n < 0) {\n        n = 0;\n        goto done;\n    }\n\n    if (n)\n        for (n = 0; n < jsi_wsnum_pollfds; n++)\n            if (jsi_wspollfds[n].revents)\n                /*\n                * returns immediately if the fd does not\n                * match anything under libwebsockets\n                * control\n                */\n                if (lws_service_fd(context, &jsi_wspollfds[n]) < 0) {\n                    n = -1;\n                    goto done;\n                }\ndone:\n#else\n    n = lws_service(cmdPtr->context, 50);\n#endif\n    if (cmdPtr->onModify) {\n        jsi_wsOnModify(cmdPtr);\n    }\n    cmdPtr->inUpdate = 0;\n    return n;\n}\n\nstatic Jsi_RC WebSocketUpdateCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    jsi_wsCmdObj *cmdPtr = (jsi_wsCmdObj*)Jsi_UserObjGetData(interp, _this, funcPtr);\n    if (!cmdPtr)\n        return Jsi_LogError(\"Apply to non-websock object\");\n    if (!cmdPtr->noUpdate)\n        jsi_wsService(cmdPtr);\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_wswebsockUpdate(Jsi_Interp *interp, void *data)\n{\n    jsi_wsCmdObj *cmdPtr = (jsi_wsCmdObj*)data;\n    WSSIGASSERT(cmdPtr,OBJ);\n    jsi_wsService(cmdPtr);\n    return JSI_OK;\n}\n\nstatic void jsi_wswebsocketObjErase(jsi_wsCmdObj *cmdPtr)\n{\n    if (cmdPtr->interp) {\n        if (cmdPtr->event)\n            Jsi_EventFree(cmdPtr->interp, cmdPtr->event);\n        cmdPtr->event = NULL;\n        if (cmdPtr->hasOpts)\n            Jsi_OptionsFree(cmdPtr->interp, WSOptions, cmdPtr, 0);\n        cmdPtr->hasOpts = 0;\n        if (cmdPtr->handlers)\n            Jsi_HashDelete(cmdPtr->handlers);\n        cmdPtr->handlers = NULL;\n        if (cmdPtr->pssTable)\n            Jsi_HashDelete(cmdPtr->pssTable);\n        cmdPtr->pssTable = NULL;\n        if (cmdPtr->fileHash)\n            Jsi_HashDelete(cmdPtr->fileHash);\n        cmdPtr->fileHash = NULL;\n    }\n    cmdPtr->interp = NULL;\n}\n\nstatic Jsi_RC jsi_wswebsocketObjFree(Jsi_Interp *interp, void *data)\n{\n    jsi_wsCmdObj *cmdPtr = (jsi_wsCmdObj*)data;\n    WSSIGASSERT(cmdPtr,OBJ);\n    cmdPtr->deleted = 1;\n    struct lws_context *ctx = cmdPtr->context;\n    if (ctx)\n        lws_context_destroy(ctx);\n    cmdPtr->context = NULL;\n    cmdPtr->_->activeCnt--;\n    jsi_wswebsocketObjErase(cmdPtr);\n    _JSI_MEMCLEAR(cmdPtr);\n    Jsi_Free(cmdPtr);\n    return JSI_OK;\n}\n\nstatic bool jsi_wswebsocketObjIsTrue(void *data)\n{\n    return 1;\n}\n\nstatic bool jsi_wswebsocketObjEqual(void *data1, void *data2)\n{\n    return (data1 == data2);\n}\n\nstatic Jsi_RC jsi_wsfreeHandlers(Jsi_Interp *interp, Jsi_HashEntry* hPtr, void *ptr) {\n    jsi_wsHander *h = (jsi_wsHander*)ptr;\n    if (!h)\n        return JSI_OK;\n    if (h->val)\n        Jsi_DecrRefCount(interp, h->val);\n    if (h->objVar)\n        Jsi_DecrRefCount(interp, h->objVar);\n    Jsi_Free(h);\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_wsfreePss(Jsi_Interp *interp, Jsi_HashEntry* hPtr, void *ptr) {\n    jsi_wsPss *pss = (jsi_wsPss*)ptr;\n    WSSIGASSERT(pss, PWS);\n    if (pss) {\n        pss->hPtr = NULL;\n        jsi_wsdeletePss(pss);\n    }\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_wsfreeFile(Jsi_Interp *interp, Jsi_HashEntry* hPtr, void *ptr) {\n    jsi_wsFile*h = (jsi_wsFile*)ptr;\n    if (!h)\n        return JSI_OK;\n    if (h->fileVal)\n        Jsi_DecrRefCount(interp, h->fileVal);\n    Jsi_Free(h);\n    return JSI_OK;\n}\n\nstatic Jsi_RC WebSocketVersionCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    const char *verStr = NULL;\n    verStr = lws_get_library_version();\n    if (verStr) {\n        char buf[100], *cp;\n        snprintf(buf, sizeof(buf), \"%s\", verStr);\n        cp = Jsi_Strchr(buf, ' ');\n        if (cp) *cp = 0;\n        Jsi_ValueMakeStringDup(interp, ret, buf);\n    }\n    return JSI_OK;\n}\n\nstatic Jsi_RC WebSocketFileCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    jsi_wsCmdObj *cmdPtr = (jsi_wsCmdObj*)Jsi_UserObjGetData(interp, _this, funcPtr);\n    if (!cmdPtr)\n        return Jsi_LogError(\"Apply to non-websock object\");\n    Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 0);\n    if (val)\n        return jsi_wsFileAdd(interp, cmdPtr, val);\n    if (cmdPtr->fileHash)\n        return Jsi_HashKeysDump(interp, cmdPtr->fileHash, ret, 0);\n    return JSI_OK;\n}\n\nstatic Jsi_RC WebSocketStatusCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    jsi_wsCmdObj *cmdPtr = (jsi_wsCmdObj*)Jsi_UserObjGetData(interp, _this, funcPtr);\n    if (!cmdPtr)\n        return Jsi_LogError(\"Apply to non-websock object\");\n#ifndef OMIT_LWS_WITH_SERVER_STATUS\n    char cbuf[JSI_BUFSIZ*2];\n    lws_json_dump_context(cmdPtr->context, cbuf, sizeof(cbuf), 0);\n    return Jsi_JSONParse(interp, cbuf, ret, 0);\n#else\n    return Jsi_LogError(\"unsupported\");\n#endif\n}\n\n#define FN_WebSocket JSI_INFO(\"\\\nCreate a websocket server/client object.  The server serves out pages to a web browser,\\n\\\nwhich can use javascript to upgrade connection to a bidirectional websocket.\")\nstatic Jsi_RC WebSocketConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr);\n\n\nstatic Jsi_CmdSpec websockCmds[] = {\n    { \"WebSocket\",  WebSocketConstructor, 0,  1, \"options:object=void\", .help=\"Create websocket server/client object\", .retType=(uint)JSI_TT_USEROBJ, .flags=JSI_CMD_IS_CONSTRUCTOR, .info=FN_WebSocket, .opts=WSOptions },\n    { \"conf\",       WebSocketConfCmd,     0,  1, \"options:string|object=void\",.help=\"Configure options\", .retType=(uint)JSI_TT_ANY, .flags=0, .info=0, .opts=WSOptions },\n    { \"handler\",    WebSocketHandlerCmd,  0,  3, \"extension:string=void, cmd:string|function=void, flags:number=0\",\n        .help=\"Get/Set handler command for an extension\", .retType=(uint)JSI_TT_FUNCTION|JSI_TT_ARRAY|JSI_TT_STRING|JSI_TT_VOID, .flags=0, .info=FN_wshandler },\n    { \"ids\",        WebSocketIdsCmd,      0,  1, \"name:string=void\", .help=\"Return list of ids, or lookup one id\", .retType=(uint)JSI_TT_ARRAY},\n    { \"idconf\",     WebSocketIdConfCmd,   1,  2, \"id:number, options:string|object=void\",.help=\"Configure options for connect id\", .retType=(uint)JSI_TT_ANY, .flags=0, .info=0, .opts=WPSOptions },\n    { \"header\",     WebSocketHeaderCmd,   1,  2, \"id:number, name:string=void\",.help=\"Get one or all input headers for connect id\", .retType=(uint)JSI_TT_STRING|JSI_TT_ARRAY|JSI_TT_VOID },\n    { \"file\",       WebSocketFileCmd,     0,  1, \"name:string=void\",.help=\"Add file to hash, or with no args return file hash\", .retType=(uint)JSI_TT_ARRAY|JSI_TT_VOID },\n    { \"query\",      WebSocketQueryCmd,    1,  2, \"id:number, name:string=void\",.help=\"Get one or all query values for connect id\", .retType=(uint)JSI_TT_STRING|JSI_TT_OBJECT|JSI_TT_VOID },\n    { \"send\",       WebSocketSendCmd,     2,  2, \"id:number, data:any\", .help=\"Send a websocket message to id\", .retType=(uint)JSI_TT_VOID, .flags=0, .info=FN_wssend },\n    { \"status\",     WebSocketStatusCmd,   0,  0, \"\", .help=\"Return libwebsocket server status\", .retType=(uint)JSI_TT_OBJECT|JSI_TT_VOID},\n    { \"unalias\",    WebSocketUnaliasCmd,  1,  1, \"path:string\", .help=\"Return alias reverse lookup\", .retType=(uint)JSI_TT_STRING|JSI_TT_VOID},\n    { \"update\",     WebSocketUpdateCmd,   0,  0, \"\", .help=\"Service events for just this websocket\", .retType=(uint)JSI_TT_VOID },\n    { \"version\",    WebSocketVersionCmd,  0,  0, \"\", .help=\"Runtime library version string\", .retType=(uint)JSI_TT_STRING },\n    { NULL, 0,0,0,0, .help=\"Commands for managing WebSocket server/client connections\"  }\n};\n\n\nstatic Jsi_UserObjReg websockobject = {\n    \"WebSocket\",\n    websockCmds,\n    jsi_wswebsocketObjFree,\n    jsi_wswebsocketObjIsTrue,\n    jsi_wswebsocketObjEqual\n};\n\nstatic const struct lws_extension jsi_lws_exts[] = {\n    {\n        \"permessage-deflate\",\n        lws_extension_callback_pm_deflate,\n        \"permessage-deflate\"\n    },\n    {\n        \"deflate-frame\",\n        lws_extension_callback_pm_deflate,\n        \"deflate_frame\"\n    },\n    { NULL, NULL, NULL /* terminator */ }\n};\n\nstatic Jsi_RC WebSocketConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (Jsi_InterpAccess(interp, NULL, JSI_INTACCESS_NETWORK ) != JSI_OK)\n        return Jsi_LogError(\"WebSocket disallowed by Interp.noNetwork option\");\n    jsi_wsCmdObj *cmdPtr;\n    Jsi_Value *toacc = NULL;\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);\n\n    cmdPtr = (jsi_wsCmdObj*)Jsi_Calloc(1, sizeof(*cmdPtr));\n    cmdPtr->sig = JWS_SIG_OBJ;\n    cmdPtr->_ = &wsObjCmd;\n    cmdPtr->_->newCnt++;\n    cmdPtr->_->activeCnt++;\n    cmdPtr->port = 8080;\n    cmdPtr->formParams = jsi_wsparam_str;\n    cmdPtr->maxUpload = 100000;\n    cmdPtr->interp = interp;\n    cmdPtr->ietf_version = -1;\n    cmdPtr->bufferPwr2 = 0;\n    cmdPtr->ws_gid = -1;\n    cmdPtr->ws_uid = -1;\n    cmdPtr->startTime = time(NULL);\n    cmdPtr->hasOpts = 1;\n    cmdPtr->includeFile = \"include.shtml\";\n    cmdPtr->jsiFnPattern = \"jsig*.js\";\n    if ((arg != NULL && !Jsi_ValueIsNull(interp,arg))\n        && Jsi_OptionsProcess(interp, WSOptions, cmdPtr, arg, 0) < 0) {\nbail:\n        jsi_wswebsocketObjFree(interp, cmdPtr);\n        return JSI_ERROR;\n    }\n    if (!cmdPtr->udata) {\n        cmdPtr->udata = Jsi_ValueNewObj(interp, NULL);\n        Jsi_IncrRefCount(interp, cmdPtr->udata);\n    }\n    Jsi_PathNormalize(interp, &cmdPtr->rootdir);\n\n    if (cmdPtr->headers && (Jsi_ValueGetLength(interp, cmdPtr->headers)%2)) {\n        Jsi_LogError(\"Odd header length\");\n        goto bail;\n    }\n    const char *up = cmdPtr->urlPrefix, *ur = cmdPtr->urlRedirect;\n    if (up && ur && Jsi_Strncmp(ur, up, Jsi_Strlen(up))) {\n        Jsi_LogError(\"urlRedirect does not start with urlPrefix\");\n        goto bail;\n    }\n    const char* subprot = (cmdPtr->protocol&&cmdPtr->protocol[0]?cmdPtr->protocol:\"ws\");\n    if (cmdPtr->protocol && !cmdPtr->protocol[0])\n        Jsi_LogWarn(\"empty protocol string: forcing to 'ws'\");\n    cmdPtr->protocols[JWS_PROTOCOL_HTTP].name=\"http-only\";\n    cmdPtr->protocols[JWS_PROTOCOL_HTTP].callback=jsi_wscallback_http;\n    cmdPtr->protocols[JWS_PROTOCOL_HTTP].per_session_data_size=sizeof(jsi_wsUser);\n    cmdPtr->protocols[JWS_PROTOCOL_WEBSOCK].name=subprot;\n    cmdPtr->protocols[JWS_PROTOCOL_WEBSOCK].callback=jsi_wscallback_websock;\n    cmdPtr->protocols[JWS_PROTOCOL_WEBSOCK].per_session_data_size=sizeof(jsi_wsUser);\n\n    if (cmdPtr->bufferPwr2 == 0)\n        cmdPtr->bufferPwr2 = 16;\n    if (cmdPtr->bufferPwr2>0) {\n        if (cmdPtr->bufferPwr2>20) {\n            Jsi_LogError(\"bufferPwr2 not in 0-20: %d\", cmdPtr->bufferPwr2);\n            goto bail;\n        }\n        cmdPtr->protocols[JWS_PROTOCOL_WEBSOCK].rx_buffer_size=(1<<cmdPtr->bufferPwr2);\n    }\n\n    cmdPtr->pssTable = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, jsi_wsfreePss);\n    if (cmdPtr->onModify)\n        cmdPtr->fileHash = Jsi_HashNew(interp, JSI_KEYS_STRING, jsi_wsfreeFile);\n\n    cmdPtr->info.port = (cmdPtr->client ? CONTEXT_PORT_NO_LISTEN : cmdPtr->port);\n    cmdPtr->info.user = cmdPtr;\n    cmdPtr->info.iface = cmdPtr->interface ? Jsi_ValueString(interp, cmdPtr->interface, NULL) : NULL;\n    if (cmdPtr->local && !cmdPtr->info.iface)\n        cmdPtr->info.iface = \"lo\";\n#ifdef __WIN32\n    cmdPtr->info.iface = NULL;\n#endif\n    cmdPtr->info.protocols = cmdPtr->protocols;\n    if (!cmdPtr->noCompress)\n        cmdPtr->info.extensions = jsi_lws_exts;\n\n    cmdPtr->info.ssl_cert_filepath = cmdPtr->ssl_cert_filepath;\n    cmdPtr->info.ssl_private_key_filepath = cmdPtr->ssl_private_key_filepath;\n    cmdPtr->info.gid = cmdPtr->ws_gid;\n    cmdPtr->info.uid = cmdPtr->ws_uid;\n    cmdPtr->opts = LWS_SERVER_OPTION_SKIP_SERVER_CANONICAL_NAME|LWS_SERVER_OPTION_VALIDATE_UTF8;\n    cmdPtr->info.options = cmdPtr->opts;\n    cmdPtr->info.max_http_header_pool = 16;\n    cmdPtr->info.timeout_secs = 5;\n    cmdPtr->info.ssl_cipher_list = \"ECDHE-ECDSA-AES256-GCM-SHA384:\"\n                   \"ECDHE-RSA-AES256-GCM-SHA384:\"\n                   \"DHE-RSA-AES256-GCM-SHA384:\"\n                   \"ECDHE-RSA-AES256-SHA384:\"\n                   \"HIGH:!aNULL:!eNULL:!EXPORT:\"\n                   \"!DES:!MD5:!PSK:!RC4:!HMAC_SHA1:\"\n                   \"!SHA1:!DHE-RSA-AES128-GCM-SHA256:\"\n                   \"!DHE-RSA-AES128-SHA256:\"\n                   \"!AES128-GCM-SHA256:\"\n                   \"!AES128-SHA256:\"\n                   \"!DHE-RSA-AES256-SHA256:\"\n                   \"!AES256-GCM-SHA384:\"\n                   \"!AES256-SHA256\";\n\n    lws_set_log_level(cmdPtr->debug>255?cmdPtr->debug/256:0, NULL);\n    // TODO: WS2.2 Still leaks a small amount if server port unavailable.\n    if (!cmdPtr->client)\n        cmdPtr->info.options |= LWS_SERVER_OPTION_EXPLICIT_VHOSTS;\n    cmdPtr->context = lws_create_context(&cmdPtr->info);\n    if (cmdPtr->context == NULL) {\nfail:\n        Jsi_LogError(\"libwebsocket init failed on port %d (try another port?)\", cmdPtr->info.port);\n        goto bail;\n    }\n    if (cmdPtr->info.options & LWS_SERVER_OPTION_EXPLICIT_VHOSTS) {\n        cmdPtr->info.options &= ~LWS_SERVER_OPTION_EXPLICIT_VHOSTS;\n        if (!lws_create_vhost(cmdPtr->context, &cmdPtr->info))\n            goto fail;\n    }\n\n    if (cmdPtr->client) {\n        struct lws_client_connect_info lci = {};\n        lci.context = cmdPtr->context;\n        lci.address = cmdPtr->address ? Jsi_ValueString(cmdPtr->interp, cmdPtr->address, NULL) : \"127.0.0.1\";\n        lci.port = cmdPtr->port;\n        lci.ssl_connection = cmdPtr->use_ssl;\n        lci.path = Jsi_ValueString(cmdPtr->interp, cmdPtr->rootdir, NULL);\n        lci.host = cmdPtr->clientHost?cmdPtr->clientHost:lws_canonical_hostname( cmdPtr->context );\n        lci.origin = cmdPtr->clientOrigin?cmdPtr->clientOrigin:\"origin\";\n        lci.protocol = cmdPtr->protocols[JWS_PROTOCOL_WEBSOCK].name;\n        lci.ietf_version_or_minus_one = cmdPtr->ietf_version;\n#if (LWS_LIBRARY_VERSION_MAJOR>1)\n        if (cmdPtr->post)\n            lci.method = \"POST\";\n        else if (!Jsi_Strcmp(subprot, \"get\"))\n            lci.method = \"GET\";\n#endif\n\n        if (NULL == lws_client_connect_via_info(&lci))\n        {\n            Jsi_LogError(\"websock connect failed\");\n            jsi_wswebsocketObjFree(interp, cmdPtr);\n            return JSI_ERROR;\n        }\n    } else if (cmdPtr->port == 0) {\n        // Extract actually used port.\n        char *cp, cbuf[JSI_BUFSIZ*2];\n        cbuf[0] = 0;\n        lws_json_dump_context(cmdPtr->context, cbuf, sizeof(cbuf), 0);\n        cp = Jsi_Strstr(cbuf, \"\\\"port\\\":\\\"\");\n        if (cp)\n            cmdPtr->port = atoi(cp+8);\n    }\n\n    cmdPtr->event = Jsi_EventNew(interp, jsi_wswebsockUpdate, cmdPtr);\n    if (Jsi_FunctionIsConstructor(funcPtr)) {\n        toacc = _this;\n    } else {\n        Jsi_Obj *o = Jsi_ObjNew(interp);\n        Jsi_PrototypeObjSet(interp, \"WebSocket\", o);\n        Jsi_ValueMakeObject(interp, ret, o);\n        toacc = *ret;\n    }\n\n    Jsi_Obj *fobj = Jsi_ValueGetObj(interp, toacc);\n    if ((cmdPtr->objId = Jsi_UserObjNew(interp, &websockobject, fobj, cmdPtr))<0) {\n        goto bail;\n    }\n    Jsi_UserObjName(interp, toacc, &cmdPtr->cName);\n\n    cmdPtr->handlers = Jsi_HashNew(interp, JSI_KEYS_STRING, jsi_wsfreeHandlers);\n    if (cmdPtr->extHandlers) {\n        jsi_wsHandlerAdd(interp, cmdPtr, \".jsi\",   \"Jspp\",     1);\n        jsi_wsHandlerAdd(interp, cmdPtr, \".htmli\", \"Htmlpp\",   1);\n        jsi_wsHandlerAdd(interp, cmdPtr, \".cssi\",  \"Csspp\",    1);\n    }\n    cmdPtr->fobj = fobj;\n#ifdef LWS_LIBRARY_VERSION_NUMBER\n    Jsi_JSONParseFmt(interp, &cmdPtr->version, \"{libVer:\\\"%s\\\", hdrVer:\\\"%s\\\", hdrNum:%d, pkgVer:%d}\",\n        (char *)lws_get_library_version(), LWS_LIBRARY_VERSION, LWS_LIBRARY_VERSION_NUMBER, jsi_WsPkgVersion);\n#endif\n    return JSI_OK;\n}\n\nstatic Jsi_RC Jsi_DoneWebSocket(Jsi_Interp *interp)\n{\n    Jsi_UserObjUnregister(interp, &websockobject);\n    Jsi_PkgProvide(interp, \"WebSocket\", -1, NULL);\n    return JSI_OK;\n}\n\nJsi_RC Jsi_InitWebSocket(Jsi_Interp *interp, int release)\n{\n    if (release)\n        return Jsi_DoneWebSocket(interp);\n#ifdef LWS_OPENSSL_SUPPORT\n    Jsi_InterpAccess(interp, NULL, JSI_INTACCESS_SETSSL );\n#endif\n    Jsi_Hash *wsys;\n    const char *libver = lws_get_library_version();\n    int lvlen = sizeof(LWS_LIBRARY_VERSION)-1;\n    if (Jsi_Strncmp(libver, LWS_LIBRARY_VERSION, lvlen) || !isspace(libver[lvlen]))\n        return Jsi_LogError(\"Library version mismatch: HDR:%s != LIB:%s\", LWS_LIBRARY_VERSION, libver);\n#if JSI_USE_STUBS\n  if (Jsi_StubsInit(interp, 0) != JSI_OK)\n    return JSI_ERROR;\n#endif\n    Jsi_Value *info = Jsi_ValueNew1(interp);\n    Jsi_JSONParseFmt(interp, &info, \"{libVer:\\\"%s\\\", hdrVer:\\\"%s\\\", pkgVer:%d}\",\n        libver, LWS_LIBRARY_VERSION, jsi_WsPkgVersion);\n    Jsi_PkgOpts wsPkgOpts = { wsObjCmd_Specs, &wsObjCmd, websockCmds, info };\n    Jsi_RC rc = Jsi_PkgProvideEx(interp, \"WebSocket\", jsi_WsPkgVersion, Jsi_InitWebSocket, &wsPkgOpts);\n    Jsi_DecrRefCount(interp, info);\n    if (rc != JSI_OK)\n        return JSI_ERROR;\n    if (!(wsys = Jsi_UserObjRegister(interp, &websockobject))) {\n        Jsi_LogBug(\"Can not init webSocket\");\n        return JSI_ERROR;\n    }\n\n    if (!Jsi_CommandCreateSpecs(interp, websockobject.name, websockCmds, wsys, JSI_CMDSPEC_ISOBJ))\n        return JSI_ERROR;\n    return JSI_OK;\n}\n\n#endif\n#endif\n"], "fixing_code": ["/* jsi.h : External API header file for Jsi. */\n#ifndef __JSI_H__\n#define __JSI_H__\n\n#define JSI_VERSION_MAJOR   3\n#define JSI_VERSION_MINOR   0\n#define JSI_VERSION_RELEASE 7\n\n#define JSI_VERSION (JSI_VERSION_MAJOR + ((Jsi_Number)JSI_VERSION_MINOR/100.0) + ((Jsi_Number)JSI_VERSION_RELEASE/10000.0))\n\n#ifndef JSI_EXTERN\n#define JSI_EXTERN extern\n#endif\n\n#ifdef offsetof\n#define Jsi_Offset(type, field) ((long) offsetof(type, field))\n#else\n#define Jsi_Offset(type, field) ((long) ((char *) &((type *) 0)->field))\n#endif\n\n#ifndef __GNUC__\n#define __attribute__(X)\n#endif\n\n#ifndef __USE_XOPEN\n#define __USE_XOPEN\n#endif\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n\n#ifdef __WIN32\n#define __USE_MINGW_ANSI_STDIO 1\n#endif\n\n#include <stdbool.h>\n#include <inttypes.h>\n#include <stdint.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <stdio.h> \n#include <dirent.h>\n\n/* --TYPEDEFS-- */\ntypedef int64_t Jsi_Wide;\ntypedef uint64_t Jsi_UWide;\ntypedef long double ldouble;\n#ifdef JSI_USE_LONG_DOUBLE\ntypedef ldouble Jsi_Number;\n#define JSI_NUMLMOD \"L\"\n#else\ntypedef double Jsi_Number;\n#define JSI_NUMLMOD\n#endif\ntypedef double time_d;\ntypedef int64_t time_w;\ntypedef uint32_t Jsi_Sig; // Signature field\n\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long ulong;\ntypedef unsigned short ushort;\n#define JSI_NUMGFMT JSI_NUMLMOD \"g\"\n#define JSI_NUMFFMT JSI_NUMLMOD \"f\"\n#define JSI_NUMEFMT JSI_NUMLMOD \"e\"\n/* -- */\n\n\n/* --ENUMS-- */\ntypedef enum {\n    /* Jsi Return Codes. */\n    JSI_OK=0, JSI_ERROR=1, JSI_RETURN=2, JSI_BREAK=3,\n    JSI_CONTINUE=4, JSI_SIGNAL=5, JSI_EXIT=6, JSI_EVAL=7,    \n} Jsi_RC;\n\ntypedef enum {\n    JSI_MAP_NONE, JSI_MAP_HASH, JSI_MAP_TREE, JSI_MAP_LIST /*, JSI_MAP_STACK */\n} Jsi_Map_Type;\n\ntypedef enum {\n    JSI_KEYS_STRING = 0,    // A string that gets stored in hash.\n    JSI_KEYS_STRINGKEY = 1, // A pointer to strings in another hash such as Jsi_KeyLookup()\n    JSI_KEYS_ONEWORD = 2,   // A pointer.\n    JSI_KEYS_RESERVED = 3,  // Unused.\n    JSI_KEYS_STRUCT_MINSIZE = 4 // Any number >= 4 is the number of bytes in a struct/key.\n} Jsi_Key_Type;\n\ntypedef enum {\n    JSI_OT_UNDEF,       /* Undefined */\n    JSI_OT_BOOL,        /* Boolean object, use d.val */\n    JSI_OT_NUMBER,      /* Number object, use d.num */\n    JSI_OT_STRING,      /* String object, use d.str */\n    JSI_OT_OBJECT,      /* Common object */\n    JSI_OT_ARRAY,       /* NOT A REAL TYPE: is just an JSI_OT_OBJECT with array elements */\n    JSI_OT_FUNCTION,    /* Function object, use d.fobj */\n    JSI_OT_REGEXP,      /* RegExp object, use d.robj */\n    JSI_OT_ITER,        /* Iter object, use d.iobj */\n    JSI_OT_USEROBJ,     /* UserDefined object, use d.uobj */\n    JSI_OT__MAX = JSI_OT_USEROBJ\n} Jsi_otype;\n\ntypedef enum {          /* TYPE         CONSTRUCTOR JSI_VALUE-DATA  IMPLICIT-PROTOTYPE  */\n    JSI_VT_UNDEF,       /* undefined    none        none            none                */\n    JSI_VT_BOOL,        /* boolean      Boolean     d.val           none                */\n    JSI_VT_NUMBER,      /* number       Number      d.num           Number.prototype    */\n    JSI_VT_STRING,      /* string       String      d.str           String.prototype    */\n    JSI_VT_OBJECT,      /* object       Jsi_Obj     d.obj           Jsi_Obj.prototype   */\n    JSI_VT_NULL,        /* null         none        none            none                */\n    JSI_VT_VARIABLE,    /* lvalue       none        d.lval          none                */\n    JSI_VT__MAX = JSI_VT_VARIABLE\n} Jsi_vtype;\n\ntypedef enum {\n    JSI_TT_UNDEFINED= (1<<JSI_OT_UNDEF),    //  0x1\n    JSI_TT_BOOLEAN  = (1<<JSI_OT_BOOL),     //  0x2\n    JSI_TT_NUMBER   = (1<<JSI_OT_NUMBER),   //  0x4\n    JSI_TT_STRING   = (1<<JSI_OT_STRING),   //  0x8\n    JSI_TT_OBJECT   = (1<<JSI_OT_OBJECT),   //  0x10\n    JSI_TT_ARRAY    = (1<<JSI_OT_ARRAY),    //  0x20\n    JSI_TT_FUNCTION = (1<<JSI_OT_FUNCTION), //  0x40\n    JSI_TT_REGEXP   = (1<<JSI_OT_REGEXP),   //  0x80\n    JSI_TT_ITEROBJ  = (1<<JSI_OT_ITER),     //  0x100\n    JSI_TT_USEROBJ  = (1<<JSI_OT_USEROBJ),  //  0x200\n    JSI_TT_NULL     = (1<<(JSI_OT_USEROBJ+1)),//0x400\n    JSI_TT_ANY      = (1<<(JSI_OT_USEROBJ+2)),//0x800\n    JSI_TT_VOID     = (1<<(JSI_OT_USEROBJ+3)) //0x1000\n} Jsi_ttype;\n\ntypedef enum {\n    /* General flags. */\n    JSI_NONE=0, JSI_NO_ERRMSG=1, \n    JSI_CMP_NOCASE=1, JSI_CMP_CHARSET_SCAN=2,\n    JSI_CMP_EXACT=0x4,\n    JSI_EVAL_ARGV0=0x1, JSI_EVAL_GLOBAL=0x2, JSI_EVAL_NOSKIPBANG=0x4, JSI_EVAL_AUTOINDEX=0x8,\n    JSI_EVAL_RETURN         =0x10, // Return top of stack as result\n    JSI_EVAL_ONCE           =0x20, // Source files only once.\n    JSI_EVAL_ISMAIN         =0x40, // Set isMain to true.\n    JSI_EVAL_EXISTS         =0x80, // Source if exists.\n    JSI_EVAL_ERRIGNORE      =0x100,// Source ignores errors.\n\n    /* Flags for Jsi_CmdProc */\n    JSI_CALL_CONSTRUCTOR    =0x1,\n    JSI_CALL_BUILTIN        =0x2,\n    \n    JSI_CMDSPEC_ISOBJ       = 0x1,\n    JSI_CMDSPEC_PROTO       = 0x2,\n    JSI_CMDSPEC_NONTHIS     = 0x4,\n    JSI_CMDSPEC_SUBCMDS     = 0x8,      // Has sub-commands.\n    \n    JSI_CMD_HAS_ATTR        = 0x100,\n    JSI_CMD_IS_CONSTRUCTOR  = 0x200,\n    JSI_CMD_IS_OBJ          = 0x400,\n    JSI_CMD_LOG_TEST        = 0x1000,\n    JSI_CMD_LOG_DEBUG       = 0x2000,\n    JSI_CMD_LOG_TRACE       = 0x4000,\n    JSI_CMD_MASK            = 0xffff,\n    \n    JSI_OM_READONLY         = 0x01,     /* ecma read-only */\n    JSI_OM_DONTENUM         = 0x02,     /* ecma emumerable */\n    JSI_OM_DONTDEL          = 0x04,     /* ecma configurable */\n    JSI_OM_INNERSHARED      = 0x08,\n    JSI_OM_ISARRAYLIST      = 0x10,\n    JSI_OM_ISSTRKEY         = 0x20,\n    JSI_OM_UNUSED           = 0x40,\n    JSI_OM_ISSTATIC         = 0x80,\n    \n    JSI_INTACCESS_READ      = 0x0,\n    JSI_INTACCESS_WRITE     = 0x1,\n    JSI_INTACCESS_NETWORK   = 0x2,\n    JSI_INTACCESS_SETSSL    = 0x3,\n    JSI_INTACCESS_MAININTERP= 0x4,\n    JSI_INTACCESS_CREATE    = 0x5,\n    \n    JSI_LOG_BUG=0,   JSI_LOG_ERROR,   JSI_LOG_WARN,\n    JSI_LOG_INFO,    JSI_LOG_UNUSED,  JSI_LOG_PARSE,\n    JSI_LOG_TEST,    JSI_LOG_DEBUG,   JSI_LOG_TRACE,\n    JSI__LOGLAST=JSI_LOG_TRACE,\n    \n    JSI_SORT_NOCASE = 0x1, JSI_SORT_DESCEND = 0x2, JSI_SORT_DICT = 0x4,\n    \n    JSI_NAME_FUNCTIONS = 0x1, JSI_NAME_DATA = 0x2,\n    \n    JSI_TREE_ORDER_IN=0, JSI_TREE_ORDER_PRE=0x10, JSI_TREE_ORDER_POST=0x20, // Jsi_TreeSearchFirst()\n    JSI_TREE_ORDER_LEVEL=0x30, JSI_TREE_ORDER_MASK=0x30,\n    JSI_TREE_SEARCH_KEY=0x10, // Use key even if NULL\n    JSI_TREE_USERFLAG_MASK=0x7f,\n    JSI_LIST_REVERSE=0x8, // Jsi_ListSearchFirst\n    JSI_MUTEX_RECURSIVE=2,\n    \n    JSI_FS_NOCLOSE=0x1, JSI_FS_READONLY=0x2, JSI_FS_WRITEONLY=0x4, JSI_FS_APPEND=0x8,\n    JSI_FS_COMPRESS=0x100,\n    JSI_FSMODESIZE=15,\n    JSI_FILE_TYPE_FILES=0x1, JSI_FILE_TYPE_DIRS=0x2,    JSI_FILE_TYPE_MOUNT=0x4,\n    JSI_FILE_TYPE_LINK=0x8,  JSI_FILE_TYPE_PIPE=0x10,   JSI_FILE_TYPE_BLOCK=0x20,\n    JSI_FILE_TYPE_CHAR=0x40, JSI_FILE_TYPE_SOCKET=0x80, JSI_FILE_TYPE_HIDDEN=0x100,\n    \n    JSI_OUTPUT_QUOTE = 0x1,\n    JSI_OUTPUT_JSON = 0x2,\n    JSI_OUTPUT_NEWLINES = 0x4,\n    JSI_OUTPUT_STDERR = 0x8,\n    JSI_JSON_STATIC_DEFAULT =100,\n    JSI_JSON_STRICT   = 0x101, /* property names must be quoted. */\n    JSI_STUBS_STRICT  = 0x1, JSI_STUBS_SIG = 0xdeadaa00, JSI_SIG_TYPEDEF,\n    JSI_SIG_OPTS = 0xdeadab00,\n    JSI_SIG_OPTS_STRUCT, JSI_SIG_OPTS_ENUM, JSI_SIG_OPTS_VARDEF, JSI_SIG_OPTS_FIELD,\n    JSI_SIG_OPTS_USER1=0xdeadab20,\n\n    JSI_EVENT_TIMER=0, JSI_EVENT_SIGNAL=1, JSI_EVENT_ALWAYS=2,\n    JSI_ZIP_MAIN=0x1,  JSI_ZIP_INDEX=0x2,\n\n    JSI_DBI_READONLY     =0x0001, /* Db is created readonly */\n    JSI_DBI_NOCREATE     =0x0002, /* Db must already exist. */\n    JSI_DBI_NO_MUTEX     =0x0004, /* Disable mutex. */\n    JSI_DBI_FULL_MUTEX   =0x0008, /* Use full mutex. */\n    \n    JSI_MAX_NUMBER_STRING=100,\n    JSI_BUFSIZ=8192\n\n} Jsi_Enums; /* Debugging is easier with enums than #define. */\n\n/* -- */\n\n\n/* --STRUCTS-- */\n\ntypedef struct Jsi_Interp Jsi_Interp;\ntypedef struct Jsi_Obj Jsi_Obj;\ntypedef struct Jsi_Value Jsi_Value;\ntypedef struct Jsi_Func Jsi_Func;\ntypedef struct Jsi_IterObj Jsi_IterObj;\ntypedef struct Jsi_FuncObj Jsi_FuncObj;\ntypedef struct Jsi_UserObjReg Jsi_UserObjReg;\ntypedef struct Jsi_UserObj Jsi_UserObj;\ntypedef struct Jsi_HashEntry Jsi_HashEntry;\ntypedef struct Jsi_Hash Jsi_Hash;\ntypedef struct Jsi_HashSearch Jsi_HashSearch;\ntypedef struct Jsi_TreeEntry Jsi_TreeEntry;\ntypedef struct Jsi_Tree Jsi_Tree;\ntypedef struct Jsi_TreeSearch Jsi_TreeSearch;\ntypedef struct Jsi_List Jsi_List;\ntypedef struct Jsi_ListEntry Jsi_ListEntry;\ntypedef struct Jsi_ListSearch Jsi_ListSearch;\ntypedef struct Jsi_Map Jsi_Map;\ntypedef struct Jsi_MapEntry Jsi_MapEntry;\ntypedef struct Jsi_MapSearch Jsi_MapSearch;\ntypedef struct Jsi_Regex_ Jsi_Regex;\ntypedef struct Jsi_Db Jsi_Db;\ntypedef struct Jsi_DbBinds Jsi_DbBinds;\ntypedef struct Jsi_Mutex Jsi_Mutex;\ntypedef struct Jsi_ScopeStrs Jsi_ScopeStrs;\ntypedef struct Jsi_OpCodes Jsi_OpCodes;\ntypedef struct Jsi_Chan* Jsi_Channel;\ntypedef struct Jsi_CS_Ctx Jsi_CS_Ctx;\ntypedef struct Jsi_OptionSpec Jsi_OptionSpec;\n\ntypedef struct Jsi_OptionSpec Jsi_StructSpec;\ntypedef struct Jsi_OptionSpec Jsi_FieldSpec;\ntypedef struct Jsi_OptionSpec Jsi_EnumSpec;\ntypedef struct Jsi_OptionSpec Jsi_VarSpec;\n\ntypedef Jsi_RC (Jsi_InitProc)(Jsi_Interp *interp, int release); // When release>1, the main interp is exiting.\ntypedef Jsi_RC (Jsi_DeleteProc)(Jsi_Interp *interp, void *data);\ntypedef Jsi_RC (Jsi_EventHandlerProc)(Jsi_Interp *interp, void *data);\ntypedef Jsi_RC (Jsi_ValueHandlerProc)(Jsi_Interp *interp, Jsi_Value *v, struct Jsi_OptionSpec* spec, void *record);\ntypedef void (Jsi_DeleteVoidProc)(void *data);\ntypedef Jsi_RC (Jsi_csgset)(Jsi_Interp *interp, void *data, Jsi_Wide *s, Jsi_OptionSpec *spec, int idx, bool isSet);\ntypedef int (Jsi_IterProc)(Jsi_IterObj *iterObj, Jsi_Value *val, Jsi_Value *var, int index);\n\n/* -- */\n\n\n/* --INTERP-- */\n\n/* Options and flags for Jsi_InterpNew/Jsi_Main */\ntypedef struct {\n    int argc;                   // Arguments from main().\n    char **argv;                // ...\n    Jsi_InitProc* initProc;     // Initialization proc\n    uint mem_debug:2;           // Memory debug level;\n    bool no_interactive:1;      // Jsi_Main: does not default to interactive mode when no script arg given.\n    bool auto_delete:1;         // Jsi_Main: auto delete interp upon return.\n    bool no_exit:1;             // Do not exit, even on error.\n    uint reserved:11;           // Reserved for future use.\n    int exitCode:16;            // Call exit with this code.\n    Jsi_Interp* interp;         // Jsi_InterpNew sets this to let Jsi_Main use this interp.\n    void *reserved2[8];         // Reserved for future\n} Jsi_InterpOpts;\n\nJSI_EXTERN Jsi_Interp* Jsi_InterpNew(Jsi_InterpOpts *opts); /*STUB = 1*/\nJSI_EXTERN void Jsi_InterpDelete( Jsi_Interp* interp); /*STUB = 2*/\nJSI_EXTERN void Jsi_InterpOnDelete(Jsi_Interp *interp, Jsi_DeleteProc *freeProc, void *ptr);  /*STUB = 3*/\nJSI_EXTERN Jsi_RC Jsi_Interactive(Jsi_Interp* interp, int flags); /*STUB = 4*/\nJSI_EXTERN bool Jsi_InterpGone( Jsi_Interp* interp); /*STUB = 5*/\nJSI_EXTERN Jsi_Value* Jsi_InterpResult(Jsi_Interp *interp); /*STUB = 6*/\nJSI_EXTERN const char* Jsi_InterpLastError(Jsi_Interp *interp, const char **errFilePtr, int *errLinePtr); /*STUB = 7*/\nJSI_EXTERN void* Jsi_InterpGetData(Jsi_Interp *interp, const char *key, Jsi_DeleteProc **proc); /*STUB = 8*/\nJSI_EXTERN void Jsi_InterpSetData(Jsi_Interp *interp, const char *key, void *data, Jsi_DeleteProc *proc); /*STUB = 9*/\nJSI_EXTERN void Jsi_InterpFreeData(Jsi_Interp *interp, const char *key); /*STUB = 10*/\nJSI_EXTERN bool Jsi_InterpSafe(Jsi_Interp *interp); /*STUB = 11*/\nJSI_EXTERN Jsi_RC Jsi_InterpAccess(Jsi_Interp *interp, Jsi_Value* resource, int aflag); /*STUB = 12*/\nJSI_EXTERN Jsi_Interp* Jsi_Main(Jsi_InterpOpts *opts); /*STUB = 13*/\n/* -- */\n\n\n/* --MEMORY-- */\nJSI_EXTERN void* Jsi_Malloc(uint size); /*STUB = 14*/\nJSI_EXTERN void* Jsi_Calloc(uint n, uint size); /*STUB = 15*/\nJSI_EXTERN void* Jsi_Realloc(void *m, uint size); /*STUB = 16*/\nJSI_EXTERN void  Jsi_Free(void *m); /*STUB = 17*/\nJSI_EXTERN int Jsi_ObjIncrRefCount(Jsi_Interp* interp, Jsi_Obj *obj); /*STUB = 18*/\nJSI_EXTERN int Jsi_ObjDecrRefCount(Jsi_Interp* interp, Jsi_Obj *obj); /*STUB = 19*/\nJSI_EXTERN int Jsi_IncrRefCount(Jsi_Interp* interp, Jsi_Value *v); /*STUB = 20*/\nJSI_EXTERN int Jsi_DecrRefCount(Jsi_Interp* interp, Jsi_Value *v); /*STUB = 21*/\nJSI_EXTERN bool Jsi_IsShared(Jsi_Interp* interp, Jsi_Value *v); /*STUB = 22*/\nJSI_EXTERN Jsi_RC Jsi_DeleteData(Jsi_Interp* interp, void *m); /*STUB = 23*/\n/* -- */\n\n\n/* --STRINGS-- */\nJSI_EXTERN uint Jsi_Strlen(const char *str); /*STUB = 24*/\nJSI_EXTERN uint Jsi_StrlenSet(const char *str, uint len); /*STUB = 25*/\nJSI_EXTERN int Jsi_Strcmp(const char *str1, const char *str2); /*STUB = 26*/\nJSI_EXTERN int Jsi_Strncmp(const char *str1, const char *str2, int n); /*STUB = 27*/\nJSI_EXTERN int Jsi_Strncasecmp(const char *str1, const char *str2, int n); /*STUB = 28*/\nJSI_EXTERN int Jsi_StrcmpDict(const char *str1, const char *str2, int nocase, int dict); /*STUB = 29*/\nJSI_EXTERN char* Jsi_Strcpy(char *dst, const char *src); /*STUB = 30*/\nJSI_EXTERN char* Jsi_Strncpy(char *dst, const char *src, int len); /*STUB = 31*/\nJSI_EXTERN char* Jsi_Strdup(const char *n); /*STUB = 32*/\nJSI_EXTERN char* Jsi_StrdupLen(const char *str, int len); /*STUB = 407*/\nJSI_EXTERN char* Jsi_Strrchr(const char *str, int c); /*STUB = 33*/\nJSI_EXTERN char* Jsi_Strstr(const char *str, const char *sub); /*STUB = 34*/\nJSI_EXTERN char* Jsi_Strrstr(const char *str, const char *sub); /*STUB = 233*/ \nJSI_EXTERN char* Jsi_Strchr(const char *str, int c); /*STUB = 36*/\nJSI_EXTERN int Jsi_Strpos(const char *str, int start, const char *nid, int nocase); /*STUB = 37*/\nJSI_EXTERN int Jsi_Strrpos(const char *str, int start, const char *nid, int nocase); /*STUB = 38*/\nJSI_EXTERN bool Jsi_StrIsAlnum(const char *cp); /*STUB = 416*/\n#define Jsi_Stzcpy(buf,src) Jsi_Strncpy(buf, src, sizeof(buf))\n\n/* Dynamic strings. */\n#ifndef JSI_DSTRING_STATIC_SIZE\n#define JSI_DSTRING_STATIC_SIZE 200\n#endif\n\ntypedef struct {\n#define JSI_DSTRING_DECL_FIELDS(siz) \\\n    const char *strA; /* Allocated string, or = {\"string\"}.*/ \\\n    uint len;       /* Length of string. */ \\\n    uint spaceAvl;  /* Amount of space available or allocated. */ \\\n    uint staticSize;/* The sizeof \"Str\", or 0 if used \"= {}\" */ \\\n    char Str[siz];  /* Static string */\n    JSI_DSTRING_DECL_FIELDS(JSI_DSTRING_STATIC_SIZE)\n} Jsi_DString;\n\n/* Declares a custom Jsi_DString* variable with other than default size... */\n#define JSI_DSTRING_VAR(namPtr, siz) \\\n    struct { JSI_DSTRING_DECL_FIELDS(siz) } _STATIC_##namPtr; \\\n    Jsi_DString *namPtr = (Jsi_DString *)&_STATIC_##namPtr; \\\n    namPtr->staticSize = siz; namPtr->strA=0; \\\n    namPtr->Str[0] = 0; namPtr->spaceAvl = namPtr->len = 0\n\nJSI_EXTERN char*   Jsi_DSAppendLen(Jsi_DString *dsPtr,const char *bytes, int length);  /*STUB = 39*/\nJSI_EXTERN char*   Jsi_DSAppend(Jsi_DString *dsPtr, const char *str, ...)  /*STUB = 40*/  __attribute__((sentinel));\nJSI_EXTERN void    Jsi_DSFree(Jsi_DString *dsPtr);  /*STUB = 41*/\nJSI_EXTERN char*   Jsi_DSFreeDup(Jsi_DString *dsPtr);  /*STUB = 42*/\nJSI_EXTERN void    Jsi_DSInit(Jsi_DString *dsPtr);  /*STUB = 43*/\nJSI_EXTERN uint    Jsi_DSLength(Jsi_DString *dsPtr);  /*STUB = 44*/\nJSI_EXTERN char*   Jsi_DSPrintf(Jsi_DString *dsPtr, const char *fmt, ...)  /*STUB = 45*/ __attribute__((format (printf,2,3)));\nJSI_EXTERN char*   Jsi_DSSet(Jsi_DString *dsPtr, const char *str);  /*STUB = 46*/\nJSI_EXTERN uint    Jsi_DSSetLength(Jsi_DString *dsPtr, uint length);  /*STUB = 47*/\nJSI_EXTERN char*   Jsi_DSValue(Jsi_DString *dsPtr);  /*STUB = 48*/\n/* -- */\n\n\n/* --FUNC/VAR/CMD-- */\ntypedef void (Jsi_DelCmdProc)(Jsi_Interp *interp, void *privData);\ntypedef Jsi_RC (Jsi_CmdProc)(Jsi_Interp *interp, Jsi_Value *args, \n    Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr);\n#define Jsi_CmdProcDecl(name,...) Jsi_RC name(Jsi_Interp *interp, Jsi_Value *args, \\\n    Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr, ##__VA_ARGS__)\n\ntypedef struct Jsi_CmdSpec {\n    const char *name;       /* Cmd name */\n    Jsi_CmdProc *proc;      /* Command handler */\n    int minArgs;\n    int maxArgs;            /* Max args or -1 */\n    const char *argStr;     /* Argument description */\n    const char *help;       /* Short help string. */\n    uint retType;           /* Return type(s) or'ed Jsi_otype. */\n    int flags;              /* JSI_CMD_* flags. */\n    const char *info;       /* Detailed description. Use JSI_DETAIL macro. */\n    Jsi_OptionSpec *opts;   /* Options for arg, default is first. */\n    Jsi_DelCmdProc *delProc;/* Callback to handle command delete. */\n    void *reserved[4];      /* Reserved for internal use. */\n} Jsi_CmdSpec;\n\ntypedef struct {\n    bool Test;\n    bool Debug;\n    bool Trace;\n    int traceCall;\n    bool coverage;\n    bool profile;\n} Jsi_ModuleConf;\n\ntypedef struct {\n    struct Jsi_OptionSpec *spec;\n    void *data;\n    Jsi_CmdSpec *cmdSpec;\n    Jsi_Value *info;\n    void *reserved[3]; // Reserved for future use.\n    Jsi_ModuleConf modConf;\n    void *reserved2[3]; // Reserved for future use.\n} Jsi_PkgOpts;\n\ntypedef struct {\n    char *str;\n    int32_t len;\n    uint32_t flags;\n} Jsi_String;\n\nJSI_EXTERN Jsi_Value* Jsi_CommandCreate(Jsi_Interp *interp, const char *name, Jsi_CmdProc *cmdProc, void *privData); /*STUB = 49*/\nJSI_EXTERN Jsi_Value* Jsi_CommandCreateSpecs(Jsi_Interp *interp, const char *name, Jsi_CmdSpec *cmdSpecs, void *privData, int flags); /*STUB = 50*/\nJSI_EXTERN void* Jsi_CommandNewObj(Jsi_Interp *interp, const char *name, const char *arg1, const char *opts, const char *var);  /*STUB = 51*/\nJSI_EXTERN Jsi_RC Jsi_CommandInvokeJSON(Jsi_Interp *interp, const char *cmd, const char *json, Jsi_Value **ret); /*STUB = 52*/\nJSI_EXTERN Jsi_RC Jsi_CommandInvoke(Jsi_Interp *interp, const char *cmdstr, Jsi_Value *args, Jsi_Value **ret); /*STUB = 53*/\nJSI_EXTERN Jsi_RC Jsi_CommandDelete(Jsi_Interp *interp, const char *name); /*STUB = 54*/\nJSI_EXTERN Jsi_CmdSpec* Jsi_FunctionGetSpecs(Jsi_Func *funcPtr); /*STUB = 55*/\nJSI_EXTERN bool Jsi_FunctionIsConstructor(Jsi_Func *funcPtr); /*STUB = 56*/\nJSI_EXTERN bool Jsi_FunctionReturnIgnored(Jsi_Interp *interp, Jsi_Func *funcPtr); /*STUB = 57*/\nJSI_EXTERN void* Jsi_FunctionPrivData(Jsi_Func *funcPtr); /*STUB = 58*/\nJSI_EXTERN Jsi_RC Jsi_FunctionArguments(Jsi_Interp *interp, Jsi_Value *func, int *argcPtr); /*STUB = 59*/\nJSI_EXTERN Jsi_RC Jsi_FunctionApply(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret); /*STUB = 60*/\nJSI_EXTERN Jsi_RC Jsi_FunctionInvoke(Jsi_Interp *interp, Jsi_Value *tocall, Jsi_Value *args, Jsi_Value **ret, Jsi_Value *_this); /*STUB = 61*/\nJSI_EXTERN Jsi_RC Jsi_FunctionInvokeJSON(Jsi_Interp *interp, Jsi_Value *tocall, const char *json, Jsi_Value **ret); /*STUB = 62*/\nJSI_EXTERN int Jsi_FunctionInvokeBool(Jsi_Interp *interp, Jsi_Value *func, Jsi_Value *arg); /*STUB = 63*/\nJSI_EXTERN Jsi_RC Jsi_FunctionInvokeString(Jsi_Interp *interp, Jsi_Value *func, Jsi_Value *arg, Jsi_DString *dStr); /*STUB = 64*/\nJSI_EXTERN Jsi_Value* Jsi_VarLookup(Jsi_Interp *interp, const char *varname); /*STUB = 65*/\nJSI_EXTERN Jsi_Value* Jsi_NameLookup(Jsi_Interp *interp, const char *varname); /*STUB = 66*/\nJSI_EXTERN Jsi_Value* Jsi_NameLookup2(Jsi_Interp *interp, const char *name, const char *inObj); /*STUB = 67*/\nJSI_EXTERN Jsi_RC Jsi_PkgProvideEx(Jsi_Interp *interp, const char *name, Jsi_Number version, Jsi_InitProc *initProc, Jsi_PkgOpts* popts); /*STUB = 68*/\nJSI_EXTERN Jsi_Number Jsi_PkgRequireEx(Jsi_Interp *interp, const char *name, Jsi_Number version, Jsi_PkgOpts **poptsPtr); /*STUB = 69*/\nJSI_EXTERN Jsi_Number Jsi_PkgVersion(Jsi_Interp *interp, const char *name, const char **filePtr); /*STUB = 70*/\n#define Jsi_PkgRequire(i,n,v) Jsi_PkgRequireEx(i,n,v,NULL)\n#define Jsi_PkgProvide(i,n,v,p) Jsi_PkgProvideEx(i,n,v,p,NULL)\n/* -- */\n\n/* UTF-8 and Unicode */\ntypedef int32_t Jsi_UniChar;\nJSI_EXTERN uint Jsi_NumUtfBytes(char c); /*STUB = 71*/\nJSI_EXTERN uint Jsi_NumUtfChars(const char *utf, int length); /*STUB = 72*/\nJSI_EXTERN uint Jsi_UtfGetIndex(const char *utf, int index, char outbuf[5]); /*STUB = 73*/\nJSI_EXTERN const char* Jsi_UtfAtIndex(const char *utf, int index); /*STUB = 74*/\nJSI_EXTERN uint Jsi_UniCharToUtf(Jsi_UniChar uc, char *dest); /*STUB = 75*/\nJSI_EXTERN uint Jsi_UtfToUniChar(const char *utf, Jsi_UniChar *ch); /*STUB = 76*/\nJSI_EXTERN uint Jsi_UtfToUniCharCase(const char *utf, Jsi_UniChar *ch, int upper); /*STUB = 77*/\nJSI_EXTERN uint Jsi_UtfDecode(const char *str, char* oututf); /*STUB = 78*/\nJSI_EXTERN uint Jsi_UtfEncode(const char *utf, char *outstr); /*STUB = 79*/\nJSI_EXTERN char* Jsi_UtfSubstr(const char *str, int n, int len, Jsi_DString *dStr); /*STUB = 80*/\nJSI_EXTERN int Jsi_UtfIndexToOffset(const char *utf, int index); /*STUB = 81*/\n/* -- */\n\n\n/* --OBJECT-- */\nJSI_EXTERN Jsi_Obj* Jsi_ObjNew(Jsi_Interp* interp); /*STUB = 82*/\nJSI_EXTERN Jsi_Obj* Jsi_ObjNewType(Jsi_Interp* interp, Jsi_otype type); /*STUB = 83*/\nJSI_EXTERN void Jsi_ObjFree(Jsi_Interp* interp, Jsi_Obj *obj); /*STUB = 84*/\nJSI_EXTERN Jsi_Obj* Jsi_ObjNewObj(Jsi_Interp *interp, Jsi_Value **items, int count); /*STUB = 85*/\nJSI_EXTERN Jsi_Obj* Jsi_ObjNewArray(Jsi_Interp *interp, Jsi_Value **items, int count, int copy); /*STUB = 86*/\n\nJSI_EXTERN bool      Jsi_ObjIsArray(Jsi_Interp *interp, Jsi_Obj *o); /*STUB = 87*/\nJSI_EXTERN void     Jsi_ObjSetLength(Jsi_Interp *interp, Jsi_Obj *obj, uint len); /*STUB = 88*/\nJSI_EXTERN int      Jsi_ObjGetLength(Jsi_Interp *interp, Jsi_Obj *obj); /*STUB = 89*/\nJSI_EXTERN const char* Jsi_ObjTypeStr(Jsi_Interp *interp, Jsi_Obj *obj); /*STUB = 90*/\nJSI_EXTERN Jsi_otype Jsi_ObjTypeGet(Jsi_Obj *obj); /*STUB = 91*/\nJSI_EXTERN void     Jsi_ObjListifyArray(Jsi_Interp *interp, Jsi_Obj *obj); /*STUB = 92*/\nJSI_EXTERN Jsi_RC      Jsi_ObjArraySet(Jsi_Interp *interp, Jsi_Obj *obj, Jsi_Value *value, int arrayindex); /*STUB = 93*/\nJSI_EXTERN Jsi_RC      Jsi_ObjArrayAdd(Jsi_Interp *interp, Jsi_Obj *o, Jsi_Value *v); /*STUB = 94*/\nJSI_EXTERN Jsi_TreeEntry* Jsi_ObjInsert(Jsi_Interp *interp, Jsi_Obj *obj, const char *key, Jsi_Value *nv, int flags); /*STUB = 95*/\nJSI_EXTERN void    Jsi_ObjFromDS(Jsi_DString *dsPtr, Jsi_Obj *obj);  /*STUB = 96*/\nJSI_EXTERN Jsi_IterObj* Jsi_IterObjNew(Jsi_Interp *interp, Jsi_IterProc *iterProc); /*STUB = 412*/\nJSI_EXTERN void Jsi_IterObjFree(Jsi_IterObj *iobj); /*STUB = 413*/\nJSI_EXTERN void Jsi_IterGetKeys(Jsi_Interp *interp, Jsi_Value *target, Jsi_IterObj *iterobj, int depth); /*STUB = 414*/\nJSI_EXTERN int Jsi_ObjArraySizer(Jsi_Interp *interp, Jsi_Obj *obj, uint n); /*STUB = 35*/\n\nstruct Jsi_IterObj {\n    Jsi_Interp *interp;\n    const char **keys;\n    uint size; \n    uint count;\n    uint iter;\n    bool isArrayList;            /* If an array list do not store keys. */\n    bool isof;\n    Jsi_Obj *obj;\n    uint cur;                    /* Current array cursor. */\n    int depth;                  /* Used to create list of keys. */\n    Jsi_IterProc *iterCmd;\n};\n\n/* -- */\n\n\n/* --VALUE-- */\nJSI_EXTERN Jsi_Value* Jsi_ValueNew(Jsi_Interp *interp); /*STUB = 97*/\nJSI_EXTERN Jsi_Value* Jsi_ValueNew1(Jsi_Interp *interp); /*STUB = 98*/\nJSI_EXTERN void Jsi_ValueFree(Jsi_Interp *interp, Jsi_Value* v); /*STUB = 99*/\n\nJSI_EXTERN Jsi_Value* Jsi_ValueNewNull(Jsi_Interp *interp); /*STUB = 100*/\nJSI_EXTERN Jsi_Value* Jsi_ValueNewBoolean(Jsi_Interp *interp, int bval); /*STUB = 101*/\nJSI_EXTERN Jsi_Value* Jsi_ValueNewNumber(Jsi_Interp *interp, Jsi_Number n); /*STUB = 102*/\nJSI_EXTERN Jsi_Value* Jsi_ValueNewBlob(Jsi_Interp *interp, uchar *s, uint len); /*STUB = 103*/\nJSI_EXTERN Jsi_Value* Jsi_ValueNewString(Jsi_Interp *interp, const char *s, int len); /*STUB = 104*/\nJSI_EXTERN Jsi_Value* Jsi_ValueNewStringKey(Jsi_Interp *interp, const char *s); /*STUB = 105*/\nJSI_EXTERN Jsi_Value* Jsi_ValueNewStringConst(Jsi_Interp *interp, const char *s, int len); /*STUB = 409*/\nJSI_EXTERN Jsi_Value* Jsi_ValueNewStringDup(Jsi_Interp *interp, const char *s); /*STUB = 106*/\nJSI_EXTERN Jsi_Value* Jsi_ValueNewArray(Jsi_Interp *interp, const char **items, int count); /*STUB = 107*/\nJSI_EXTERN Jsi_Value* Jsi_ValueNewObj(Jsi_Interp *interp, Jsi_Obj *o) ; /*STUB = 108*/\n#define Jsi_ValueNewBlobString(interp, s) Jsi_ValueNewBlob(interp, (uchar*)s, Jsi_Strlen(s))\n#define Jsi_ValueNewArrayObj(interp, items, count, copy) Jsi_ValueNewObj(interp, Jsi_ObjNewArray(interp, items, count, copy))\n\nJSI_EXTERN Jsi_RC Jsi_GetStringFromValue(Jsi_Interp* interp, Jsi_Value *value, const char **s); /*STUB = 109*/\nJSI_EXTERN Jsi_RC Jsi_GetNumberFromValue(Jsi_Interp* interp, Jsi_Value *value, Jsi_Number *n); /*STUB = 110*/\nJSI_EXTERN Jsi_RC Jsi_GetBoolFromValue(Jsi_Interp* interp, Jsi_Value *value, bool *n); /*STUB = 111*/\nJSI_EXTERN Jsi_RC Jsi_GetIntFromValue(Jsi_Interp* interp, Jsi_Value *value, int *n); /*STUB = 112*/\nJSI_EXTERN Jsi_RC Jsi_GetLongFromValue(Jsi_Interp* interp, Jsi_Value *value, long *n); /*STUB = 113*/\nJSI_EXTERN Jsi_RC Jsi_GetWideFromValue(Jsi_Interp* interp, Jsi_Value *value, Jsi_Wide *n); /*STUB = 114*/\nJSI_EXTERN Jsi_RC Jsi_GetDoubleFromValue(Jsi_Interp* interp, Jsi_Value *value, Jsi_Number *n); /*STUB = 115*/\nJSI_EXTERN Jsi_RC Jsi_GetIntFromValueBase(Jsi_Interp* interp, Jsi_Value *value, int *n, int base, int flags); /*STUB = 116*/\nJSI_EXTERN Jsi_RC Jsi_ValueGetBoolean(Jsi_Interp *interp, Jsi_Value *pv, bool *val); /*STUB = 117*/\nJSI_EXTERN Jsi_RC Jsi_ValueGetNumber(Jsi_Interp *interp, Jsi_Value *pv, Jsi_Number *val); /*STUB = 118*/\n\nJSI_EXTERN bool Jsi_ValueIsType(Jsi_Interp *interp, Jsi_Value *pv, Jsi_vtype vtype); /*STUB = 119*/\nJSI_EXTERN bool Jsi_ValueIsObjType(Jsi_Interp *interp, Jsi_Value *v, Jsi_otype otype); /*STUB = 120*/\nJSI_EXTERN bool Jsi_ValueIsTrue(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 121*/\nJSI_EXTERN bool Jsi_ValueIsFalse(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 122*/\nJSI_EXTERN bool Jsi_ValueIsNumber(Jsi_Interp *interp, Jsi_Value *pv); /*STUB = 123*/\nJSI_EXTERN bool Jsi_ValueIsArray(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 124*/\nJSI_EXTERN bool Jsi_ValueIsBoolean(Jsi_Interp *interp, Jsi_Value *pv); /*STUB = 125*/\nJSI_EXTERN bool Jsi_ValueIsNull(Jsi_Interp *interp, Jsi_Value *pv); /*STUB = 126*/\nJSI_EXTERN bool Jsi_ValueIsUndef(Jsi_Interp *interp, Jsi_Value *pv); /*STUB = 127*/\nJSI_EXTERN bool Jsi_ValueIsFunction(Jsi_Interp *interp, Jsi_Value *pv); /*STUB = 128*/\nJSI_EXTERN bool Jsi_ValueIsString(Jsi_Interp *interp, Jsi_Value *pv); /*STUB = 129*/\n\nJSI_EXTERN Jsi_Value* Jsi_ValueMakeObject(Jsi_Interp *interp, Jsi_Value **v, Jsi_Obj *o); /*STUB = 130*/\nJSI_EXTERN Jsi_Value* Jsi_ValueMakeArrayObject(Jsi_Interp *interp, Jsi_Value **v, Jsi_Obj *o); /*STUB = 131*/\nJSI_EXTERN Jsi_Value* Jsi_ValueMakeNumber(Jsi_Interp *interp, Jsi_Value **v, Jsi_Number n); /*STUB = 132*/\nJSI_EXTERN Jsi_Value* Jsi_ValueMakeBool(Jsi_Interp *interp, Jsi_Value **v, int b); /*STUB = 133*/\nJSI_EXTERN Jsi_Value* Jsi_ValueMakeString(Jsi_Interp *interp, Jsi_Value **v, const char *s); /*STUB = 134*/\nJSI_EXTERN Jsi_Value* Jsi_ValueMakeStringKey(Jsi_Interp *interp, Jsi_Value **v, const char *s); /*STUB = 135*/\nJSI_EXTERN Jsi_Value* Jsi_ValueMakeBlob(Jsi_Interp *interp, Jsi_Value **v, uchar *s, int len); /*STUB = 136*/\nJSI_EXTERN Jsi_Value* Jsi_ValueMakeNull(Jsi_Interp *interp, Jsi_Value **v); /*STUB = 137*/\nJSI_EXTERN Jsi_Value* Jsi_ValueMakeUndef(Jsi_Interp *interp, Jsi_Value **v); /*STUB = 138*/\nJSI_EXTERN Jsi_Value* Jsi_ValueMakeDStringObject(Jsi_Interp *interp, Jsi_Value **v, Jsi_DString *dsPtr); /*STUB = 139*/\nJSI_EXTERN bool Jsi_ValueIsStringKey(Jsi_Interp* interp, Jsi_Value *key); /*STUB = 140*/\n#define Jsi_ValueMakeStringDup(interp, v, s) Jsi_ValueMakeString(interp, v, Jsi_Strdup(s))\n\nJSI_EXTERN const char*  Jsi_ValueToString(Jsi_Interp *interp, Jsi_Value *v, int *lenPtr); /*STUB = 141*/\nJSI_EXTERN Jsi_RC       Jsi_ValueToBool(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 142*/\nJSI_EXTERN Jsi_RC       Jsi_ValueToNumber(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 143*/\nJSI_EXTERN Jsi_Number   Jsi_ValueToNumberInt(Jsi_Interp *interp, Jsi_Value *v, int isInt); /*STUB = 144*/\nJSI_EXTERN Jsi_RC       Jsi_ValueToObject(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 145*/\n\nJSI_EXTERN void     Jsi_ValueReset(Jsi_Interp *interp, Jsi_Value **v); /*STUB = 146*/\nJSI_EXTERN const char* Jsi_ValueGetDString(Jsi_Interp* interp, Jsi_Value* v, Jsi_DString *dStr, int quote); /*STUB = 147*/\nJSI_EXTERN char*    Jsi_ValueString(Jsi_Interp* interp, Jsi_Value* v, int *lenPtr); /*STUB = 148*/\nJSI_EXTERN uchar*   Jsi_ValueBlob(Jsi_Interp *interp, Jsi_Value* v, int *lenPtr); /*STUB = 149*/\nJSI_EXTERN char*    Jsi_ValueGetStringLen(Jsi_Interp *interp, Jsi_Value *pv, int *lenPtr); /*STUB = 150*/\nJSI_EXTERN int      Jsi_ValueStrlen(Jsi_Value* v); /*STUB = 151*/\nJSI_EXTERN void     Jsi_ValueFromDS(Jsi_Interp *interp, Jsi_DString *dsPtr, Jsi_Value **ret);  /*STUB = 152*/\nJSI_EXTERN int      Jsi_ValueInstanceOf( Jsi_Interp *interp, Jsi_Value* v1, Jsi_Value* v2); /*STUB = 153*/\nJSI_EXTERN Jsi_Obj* Jsi_ValueGetObj(Jsi_Interp* interp, Jsi_Value* v); /*STUB = 154*/\nJSI_EXTERN Jsi_vtype Jsi_ValueTypeGet(Jsi_Value *pv); /*STUB = 155*/\nJSI_EXTERN const char* Jsi_ValueTypeStr(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 156*/\nJSI_EXTERN int      Jsi_ValueCmp(Jsi_Interp *interp, Jsi_Value *v1, Jsi_Value* v2, int cmpFlags); /*STUB = 157*/\nJSI_EXTERN Jsi_RC Jsi_ValueGetIndex( Jsi_Interp *interp, Jsi_Value *valPtr, const char **tablePtr, const char *msg, int flags, int *indexPtr); /*STUB = 158*/\n\nJSI_EXTERN Jsi_RC Jsi_ValueArraySort(Jsi_Interp *interp, Jsi_Value *val, int sortFlags); /*STUB = 159*/\nJSI_EXTERN Jsi_Value* Jsi_ValueArrayConcat(Jsi_Interp *interp, Jsi_Value *arg1, Jsi_Value *arg2); /*STUB = 160*/\nJSI_EXTERN Jsi_RC Jsi_ValueArrayPush(Jsi_Interp *interp, Jsi_Value *arg1, Jsi_Value *arg2); /*STUB = 161*/\nJSI_EXTERN Jsi_Value* Jsi_ValueArrayPop(Jsi_Interp *interp, Jsi_Value *arg1); /*STUB = 162*/\nJSI_EXTERN void Jsi_ValueArrayShift(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 163*/\nJSI_EXTERN Jsi_Value* Jsi_ValueArrayUnshift(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 164*/\nJSI_EXTERN Jsi_Value* Jsi_ValueArrayIndex(Jsi_Interp *interp, Jsi_Value *args, int index); /*STUB = 165*/\nJSI_EXTERN char* Jsi_ValueArrayIndexToStr(Jsi_Interp *interp, Jsi_Value *args, int index, int *lenPtr); /*STUB = 166*/\n#define Jsi_ValueArraySet(interp, dest, value, index) Jsi_ObjArraySet(interp, Jsi_ValueGetObj(interp, dest), value, index)\n\n#define Jsi_ValueInsertFixed(i,t,k,v) Jsi_ValueInsert(i,t,k,v,JSI_OM_READONLY | JSI_OM_DONTDEL | JSI_OM_DONTENUM)\nJSI_EXTERN Jsi_RC Jsi_ValueInsert(Jsi_Interp *interp, Jsi_Value *target, const char *key, Jsi_Value *val, int flags); /*STUB = 167*/\nJSI_EXTERN Jsi_RC Jsi_ValueInsertArray(Jsi_Interp *interp, Jsi_Value *target, int index, Jsi_Value *val, int flags); /*STUB = 411*/\nJSI_EXTERN int Jsi_ValueGetLength(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 168*/\nJSI_EXTERN Jsi_Value* Jsi_ValueObjLookup(Jsi_Interp *interp, Jsi_Value *target, const char *key, int iskeystr); /*STUB = 169*/\nJSI_EXTERN bool Jsi_ValueKeyPresent(Jsi_Interp *interp, Jsi_Value *target, const char *k, int isstrkey); /*STUB = 170*/\nJSI_EXTERN Jsi_RC Jsi_ValueGetKeys(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *ret); /*STUB = 171*/\n\nJSI_EXTERN void Jsi_ValueCopy(Jsi_Interp *interp, Jsi_Value *to, Jsi_Value *from ); /*STUB = 172*/\nJSI_EXTERN void Jsi_ValueReplace(Jsi_Interp *interp, Jsi_Value **to, Jsi_Value *from ); /*STUB = 173*/\nJSI_EXTERN void Jsi_ValueDup2(Jsi_Interp *interp, Jsi_Value **to, Jsi_Value *from); /*STUB = 174*/\nJSI_EXTERN Jsi_Value* Jsi_ValueDupJSON(Jsi_Interp *interp, Jsi_Value *val); /*STUB = 175*/\nJSI_EXTERN void Jsi_ValueMove(Jsi_Interp *interp, Jsi_Value *to, Jsi_Value *from); /*STUB = 176*/\nJSI_EXTERN bool  Jsi_ValueIsEqual(Jsi_Interp *interp, Jsi_Value *v1, Jsi_Value* v2); /*STUB = 177*/\n/* -- */\n\n\n/* --USEROBJ-- */\ntypedef bool (Jsi_UserObjIsTrueProc)(void *data);\ntypedef bool (Jsi_UserObjIsEquProc)(void *data1, void *data2);\ntypedef Jsi_Obj* (Jsi_UserGetObjProc)(Jsi_Interp *interp, void *data);\n\ntypedef struct Jsi_UserObjReg {\n    const char *name;\n    Jsi_CmdSpec *spec;\n    Jsi_DeleteProc *freefun;\n    Jsi_UserObjIsTrueProc *istrue;\n    Jsi_UserObjIsEquProc *isequ;\n} Jsi_UserObjReg;\n\nJSI_EXTERN Jsi_Hash* Jsi_UserObjRegister    (Jsi_Interp *interp, Jsi_UserObjReg *reg); /*STUB = 178*/\nJSI_EXTERN Jsi_RC Jsi_UserObjUnregister  (Jsi_Interp *interp, Jsi_UserObjReg *reg); /*STUB = 179*/\nJSI_EXTERN int Jsi_UserObjNew    (Jsi_Interp *interp, Jsi_UserObjReg* reg, Jsi_Obj *obj, void *data); /*STUB = 180*/\nJSI_EXTERN void* Jsi_UserObjGetData(Jsi_Interp *interp, Jsi_Value* value, Jsi_Func *funcPtr); /*STUB = 181*/\nJSI_EXTERN Jsi_RC Jsi_UserObjName(Jsi_Interp *interp, Jsi_Value *v, Jsi_DString *dStr); /*STUB = 418*/ /*LAST*/\n/* -- */\n\n\n/* --UTILITY-- */\n#define JSI_NOTUSED(n) (void)n /* Eliminate annoying compiler warning. */\nJSI_EXTERN char* Jsi_NumberToString(Jsi_Interp *interp, Jsi_Number d, char *buf, int bsiz); /*STUB = 182*/\nJSI_EXTERN Jsi_Number Jsi_Version(void); /*STUB = 183*/\nJSI_EXTERN Jsi_Value* Jsi_ReturnValue(Jsi_Interp *interp); /*STUB = 184*/\nJSI_EXTERN Jsi_RC Jsi_Mount( Jsi_Interp *interp, Jsi_Value *archive, Jsi_Value *mount, Jsi_Value **ret); /*STUB = 185*/\nJSI_EXTERN Jsi_Value* Jsi_Executable(Jsi_Interp *interp); /*STUB = 186*/\nJSI_EXTERN Jsi_Regex* Jsi_RegExpNew(Jsi_Interp *interp, const char *regtxt, int flag); /*STUB = 187*/\nJSI_EXTERN void Jsi_RegExpFree(Jsi_Regex* re); /*STUB = 188*/\nJSI_EXTERN Jsi_RC Jsi_RegExpMatch( Jsi_Interp *interp,  Jsi_Value *pattern, const char *str, int *rc, Jsi_DString *dStr); /*STUB = 189*/\nJSI_EXTERN Jsi_RC Jsi_RegExpMatches(Jsi_Interp *interp, Jsi_Value *pattern, const char *str, int slen, Jsi_Value *ret); /*STUB = 190*/\nJSI_EXTERN bool Jsi_GlobMatch(const char *pattern, const char *string, int nocase); /*STUB = 191*/\nJSI_EXTERN char* Jsi_FileRealpath(Jsi_Interp *interp, Jsi_Value *path, char *newpath); /*STUB = 192*/\nJSI_EXTERN char* Jsi_FileRealpathStr(Jsi_Interp *interp, const char *path, char *newpath); /*STUB = 193*/\nJSI_EXTERN char* Jsi_NormalPath(Jsi_Interp *interp, const char *path, Jsi_DString *dStr); /*STUB = 194*/\nJSI_EXTERN char* Jsi_ValueNormalPath(Jsi_Interp *interp, Jsi_Value *path, Jsi_DString *dStr); /*STUB = 195*/\nJSI_EXTERN Jsi_RC Jsi_PathNormalize(Jsi_Interp *interp, Jsi_Value **pathPtr); /*STUB = 410*/\nJSI_EXTERN Jsi_RC Jsi_JSONParse(Jsi_Interp *interp, const char *js, Jsi_Value **ret, int flags); /*STUB = 196*/\nJSI_EXTERN Jsi_RC Jsi_JSONParseFmt(Jsi_Interp *interp, Jsi_Value **ret, const char *fmt, ...) /*STUB = 197*/ __attribute__((format (printf,3,4)));\nJSI_EXTERN char* Jsi_JSONQuote(Jsi_Interp *interp, const char *str, int len, Jsi_DString *dStr); /*STUB = 198*/\nJSI_EXTERN Jsi_RC Jsi_EvalString(Jsi_Interp* interp, const char *str, int flags); /*STUB = 199*/\nJSI_EXTERN Jsi_RC Jsi_EvalFile(Jsi_Interp* interp, Jsi_Value *fname, int flags); /*STUB = 200*/\nJSI_EXTERN Jsi_RC Jsi_EvalCmdJSON(Jsi_Interp *interp, const char *cmd, const char *jsonArgs, Jsi_DString *dStr, int flags); /*STUB = 201*/\nJSI_EXTERN Jsi_RC Jsi_EvalZip(Jsi_Interp *interp, const char *exeFile, const char *mntDir, int *jsFound); /*STUB = 202*/\nJSI_EXTERN int Jsi_DictionaryCompare(const char *left, const char *right); /*STUB = 203*/\nJSI_EXTERN Jsi_RC Jsi_GetBool(Jsi_Interp* interp, const char *string, bool *n); /*STUB = 204*/\nJSI_EXTERN Jsi_RC Jsi_GetInt(Jsi_Interp* interp, const char *string, int *n, int base); /*STUB = 205*/\nJSI_EXTERN Jsi_RC Jsi_GetWide(Jsi_Interp* interp, const char *string, Jsi_Wide *n, int base); /*STUB = 206*/\nJSI_EXTERN Jsi_RC Jsi_GetDouble(Jsi_Interp* interp, const char *string, Jsi_Number *n); /*STUB = 207*/\nJSI_EXTERN Jsi_RC Jsi_FormatString(Jsi_Interp *interp, Jsi_Value *args, Jsi_DString *dStr); /*STUB = 208*/\nJSI_EXTERN void Jsi_SplitStr(const char *str, int *argcPtr, char ***argvPtr,  const char *splitCh, Jsi_DString *dStr); /*STUB = 209*/\nJSI_EXTERN Jsi_RC Jsi_Sleep(Jsi_Interp *interp, Jsi_Number dtim); /*STUB = 210*/\nJSI_EXTERN void Jsi_Preserve(Jsi_Interp* interp, void *data); /*STUB = 211*/\nJSI_EXTERN void Jsi_Release(Jsi_Interp* interp, void *data); /*STUB = 212*/\nJSI_EXTERN void Jsi_EventuallyFree(Jsi_Interp* interp, void *data, Jsi_DeleteProc* proc); /*STUB = 213*/\nJSI_EXTERN void Jsi_ShiftArgs(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 214*/\nJSI_EXTERN Jsi_Value* Jsi_StringSplit(Jsi_Interp *interp, const char *str, const char *spliton); /*STUB = 215*/\nJSI_EXTERN Jsi_RC Jsi_GetIndex( Jsi_Interp *interp, const char *str, const char **tablePtr, const char *msg, int flags, int *indexPtr); /*STUB = 216*/\nJSI_EXTERN void* Jsi_PrototypeGet(Jsi_Interp *interp, const char *key); /*STUB = 217*/\nJSI_EXTERN Jsi_RC  Jsi_PrototypeDefine(Jsi_Interp *interp, const char *key, Jsi_Value *proto); /*STUB = 218*/\nJSI_EXTERN Jsi_RC Jsi_PrototypeObjSet(Jsi_Interp *interp, const char *key, Jsi_Obj *obj); /*STUB = 219*/\nJSI_EXTERN Jsi_RC Jsi_ThisDataSet(Jsi_Interp *interp, Jsi_Value *_this, void *value); /*STUB = 220*/\nJSI_EXTERN void* Jsi_ThisDataGet(Jsi_Interp *interp, Jsi_Value *_this); /*STUB = 221*/\nJSI_EXTERN Jsi_RC Jsi_FuncObjToString(Jsi_Interp *interp, Jsi_Func *f, Jsi_DString *dStr, int flags); /*STUB = 222*/\nJSI_EXTERN void* Jsi_UserObjDataFromVar(Jsi_Interp *interp, const char *var); /*STUB = 223*/\nJSI_EXTERN const char* Jsi_KeyAdd(Jsi_Interp *interp, const char *str); /*STUB = 224*/\nJSI_EXTERN const char* Jsi_KeyLookup(Jsi_Interp *interp, const char *str); /*STUB = 225*/\nJSI_EXTERN bool Jsi_IsReserved(Jsi_Interp *interp, const char* str, bool sql); /*STUB = 415*/\nJSI_EXTERN Jsi_RC Jsi_SqlObjBinds(Jsi_Interp* interp, Jsi_DString* zStr, const char *varName, bool addTypes, bool addDefaults, bool nullDefaults); /*STUB = 417*/\nJSI_EXTERN Jsi_RC Jsi_DatetimeFormat(Jsi_Interp *interp, Jsi_Number date, const char *fmt, int isUtc, Jsi_DString *dStr);  /*STUB = 226*/\nJSI_EXTERN Jsi_RC Jsi_DatetimeParse(Jsi_Interp *interp, const char *str, const char *fmt, int isUtc, Jsi_Number *datePtr, bool noMsg); /*STUB = 227*/\nJSI_EXTERN Jsi_Number Jsi_DateTime(void); /*STUB = 228*/\n#define JSI_DATE_JULIAN2UNIX(d)  (Jsi_Number)(((Jsi_Number)d - 2440587.5)*86400.0)\n#define JSI_DATE_UNIX2JULIAN(d)  (Jsi_Number)((Jsi_Number)d/86400.0+2440587.5)\n\ntypedef enum { Jsi_CHash_SHA2_256, Jsi_CHash_SHA1, Jsi_CHash_MD5, Jsi_CHash_SHA3_224, \n    Jsi_CHash_SHA3_384, Jsi_CHash_SHA3_512, Jsi_CHash_SHA3_256 } Jsi_CryptoHashType;\n\nJSI_EXTERN Jsi_RC Jsi_Encrypt(Jsi_Interp *interp, Jsi_DString *inout, const char *key, uint keyLen, bool decrypt); /*STUB = 229*/\nJSI_EXTERN Jsi_RC Jsi_CryptoHash(char *outbuf, const char *str, int len, Jsi_CryptoHashType type, uint strength, bool noHex, int *sizPtr); /*STUB = 230*/\nJSI_EXTERN Jsi_RC Jsi_Base64(const char *str, int len, Jsi_DString *buf, bool decode); /*STUB = 231*/\nJSI_EXTERN int Jsi_HexStr(const uchar *data, int len, Jsi_DString *dStr, bool decode); /*STUB = 232*/\nJSI_EXTERN uint32_t Jsi_Crc32(uint32_t crc, const void *ptr, size_t buf_len); /*STUB = 234*/\nJSI_EXTERN Jsi_RC Jsi_FileRead(Jsi_Interp *interp, Jsi_Value *name, Jsi_DString *dStr); /*STUB = 408*/\n\nJSI_EXTERN int Jsi_NumberIsInfinity(Jsi_Number a);  /*STUB = 235*/\nJSI_EXTERN bool Jsi_NumberIsEqual(Jsi_Number n1, Jsi_Number n2);  /*STUB = 236*/\nJSI_EXTERN bool Jsi_NumberIsFinite(Jsi_Number value);  /*STUB = 237*/\nJSI_EXTERN bool Jsi_NumberIsInteger(Jsi_Number n);  /*STUB = 238*/\nJSI_EXTERN bool Jsi_NumberIsNaN(Jsi_Number a);  /*STUB = 239*/\nJSI_EXTERN bool Jsi_NumberIsNormal(Jsi_Number a);  /*STUB = 240*/\nJSI_EXTERN bool Jsi_NumberIsSubnormal(Jsi_Number a);  /*STUB = 241*/\nJSI_EXTERN bool Jsi_NumberIsWide(Jsi_Number n);  /*STUB = 242*/\nJSI_EXTERN Jsi_Number Jsi_NumberInfinity(int i);  /*STUB = 243*/\nJSI_EXTERN Jsi_Number Jsi_NumberNaN(void);  /*STUB = 244*/\nJSI_EXTERN void Jsi_NumberDtoA(Jsi_Interp *interp, Jsi_Number value, char* buf, int bsiz, int prec);  /*STUB = 245*/\nJSI_EXTERN void Jsi_NumberItoA10(Jsi_Wide value, char* buf, int bsiz);  /*STUB = 246*/\nJSI_EXTERN void Jsi_NumberUtoA10(Jsi_UWide, char* buf, int bsiz);  /*STUB = 247*/\n\n/* -- */\n\n#define JSI_WORDKEY_CAST (void*)(uintptr_t)\n\nstruct Jsi_MapOpts;\n\ntypedef Jsi_RC (Jsi_HashDeleteProc)(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *data);\ntypedef Jsi_RC (Jsi_TreeDeleteProc)(Jsi_Interp *interp, Jsi_TreeEntry *hPtr, void *data);\ntypedef Jsi_RC (Jsi_MapDeleteProc)(Jsi_Interp *interp, Jsi_MapEntry *hPtr, void *data);\ntypedef Jsi_Value *(Jsi_MapFmtKeyProc)(Jsi_MapEntry* hPtr, struct Jsi_MapOpts *opts, int flags);\ntypedef Jsi_RC (Jsi_TreeWalkProc)(Jsi_Tree* treePtr, Jsi_TreeEntry* hPtr, void *data);\ntypedef int (Jsi_RBCompareProc)(Jsi_Tree *treePtr, const void *key1, const void *key2);\n\ntypedef struct Jsi_MapOpts {\n    Jsi_Map_Type mapType; // Read-only\n    Jsi_Key_Type keyType; // Read-only\n    Jsi_Interp *interp;\n    Jsi_Wide flags;\n    void *user, *user2;\n    Jsi_MapFmtKeyProc *fmtKeyProc;\n    Jsi_RBCompareProc *compareTreeProc;\n    union {\n        Jsi_RC (*freeHashProc)(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *data);\n        Jsi_RC (*freeTreeProc)(Jsi_Interp *interp, Jsi_TreeEntry *hPtr, void *data);\n        Jsi_RC (*freeListProc)(Jsi_Interp *interp, Jsi_ListEntry *hPtr, void *data);\n    };\n    union {\n        Jsi_RC (*lockHashProc) (Jsi_Hash *tablePtr, int lock);\n        Jsi_RC (*lockTreeProc) (Jsi_Tree *tablePtr, int lock);\n    };\n} Jsi_MapOpts;\n\n/* --HASH-- */\ntypedef struct Jsi_HashSearch {\n    Jsi_Hash *tablePtr;\n    unsigned long nextIndex; \n    Jsi_HashEntry *nextEntryPtr;\n} Jsi_HashSearch;\n\nJSI_EXTERN Jsi_Hash* Jsi_HashNew(Jsi_Interp *interp, uint keyType, Jsi_HashDeleteProc *freeProc); /*STUB = 248*/\nJSI_EXTERN Jsi_RC Jsi_HashConf(Jsi_Hash *hashPtr, Jsi_MapOpts *opts, bool set); /*STUB = 249*/\nJSI_EXTERN void Jsi_HashDelete(Jsi_Hash *hashPtr); /*STUB = 250*/\nJSI_EXTERN void Jsi_HashClear(Jsi_Hash *hashPtr); /*STUB = 251*/\nJSI_EXTERN Jsi_HashEntry* Jsi_HashSet(Jsi_Hash *hashPtr, const void *key, void *value); /*STUB = 252*/\nJSI_EXTERN void* Jsi_HashGet(Jsi_Hash *hashPtr, const void *key, int flags); /*STUB = 253*/\nJSI_EXTERN bool Jsi_HashUnset(Jsi_Hash *tbl, const void *key); /*STUB = 254*/\nJSI_EXTERN void* Jsi_HashKeyGet(Jsi_HashEntry *h); /*STUB = 255*/\nJSI_EXTERN Jsi_RC Jsi_HashKeysDump(Jsi_Interp *interp, Jsi_Hash *hashPtr, Jsi_Value **ret, int flags); /*STUB = 256*/\nJSI_EXTERN void* Jsi_HashValueGet(Jsi_HashEntry *h); /*STUB = 257*/\nJSI_EXTERN void Jsi_HashValueSet(Jsi_HashEntry *h, void *value); /*STUB = 258*/\nJSI_EXTERN Jsi_HashEntry* Jsi_HashEntryFind (Jsi_Hash *hashPtr, const void *key); /*STUB = 259*/\nJSI_EXTERN Jsi_HashEntry* Jsi_HashEntryNew (Jsi_Hash *hashPtr, const void *key, bool *isNew); /*STUB = 260*/\nJSI_EXTERN int Jsi_HashEntryDelete (Jsi_HashEntry *entryPtr); /*STUB = 261*/\nJSI_EXTERN Jsi_HashEntry* Jsi_HashSearchFirst (Jsi_Hash *hashPtr, Jsi_HashSearch *searchPtr); /*STUB = 262*/\nJSI_EXTERN Jsi_HashEntry* Jsi_HashSearchNext (Jsi_HashSearch *searchPtr); /*STUB = 263*/\nJSI_EXTERN uint Jsi_HashSize(Jsi_Hash *hashPtr); /*STUB = 264*/\n/* -- */\n\n\n/* --TREE-- */\n\ntypedef struct Jsi_TreeSearch {\n    Jsi_Tree *treePtr;\n    uint top, max, left, epoch; \n    int flags;\n    Jsi_TreeEntry *staticPtrs[200], *current;\n    Jsi_TreeEntry **Ptrs;\n} Jsi_TreeSearch;\n\nJSI_EXTERN Jsi_Tree* Jsi_TreeNew(Jsi_Interp *interp, uint keyType, Jsi_TreeDeleteProc *freeProc); /*STUB = 265*/\nJSI_EXTERN Jsi_RC Jsi_TreeConf(Jsi_Tree *treePtr, Jsi_MapOpts *opts, bool set); /*STUB = 266*/\nJSI_EXTERN void Jsi_TreeDelete(Jsi_Tree *treePtr); /*STUB = 267*/\nJSI_EXTERN void Jsi_TreeClear(Jsi_Tree *treePtr); /*STUB = 268*/\nJSI_EXTERN Jsi_TreeEntry* Jsi_TreeObjSetValue(Jsi_Obj* obj, const char *key, Jsi_Value *val, int isstrkey); /*STUB = 269*/\nJSI_EXTERN Jsi_Value*     Jsi_TreeObjGetValue(Jsi_Obj* obj, const char *key, int isstrkey); /*STUB = 270*/\nJSI_EXTERN void* Jsi_TreeValueGet(Jsi_TreeEntry *hPtr); /*STUB = 271*/\nJSI_EXTERN void Jsi_TreeValueSet(Jsi_TreeEntry *hPtr, void *value); /*STUB = 272*/\nJSI_EXTERN void* Jsi_TreeKeyGet(Jsi_TreeEntry *hPtr); /*STUB = 273*/\nJSI_EXTERN Jsi_TreeEntry* Jsi_TreeEntryFind(Jsi_Tree *treePtr, const void *key); /*STUB = 274*/\nJSI_EXTERN Jsi_TreeEntry* Jsi_TreeEntryNew(Jsi_Tree *treePtr, const void *key, bool *isNew); /*STUB = 275*/\nJSI_EXTERN int Jsi_TreeEntryDelete(Jsi_TreeEntry *entryPtr); /*STUB = 276*/\nJSI_EXTERN Jsi_TreeEntry* Jsi_TreeSearchFirst(Jsi_Tree *treePtr, Jsi_TreeSearch *searchPtr, int flags, const void *startKey); /*STUB = 277*/\nJSI_EXTERN Jsi_TreeEntry* Jsi_TreeSearchNext(Jsi_TreeSearch *searchPtr); /*STUB = 278*/\nJSI_EXTERN void Jsi_TreeSearchDone(Jsi_TreeSearch *searchPtr); /*STUB = 279*/\nJSI_EXTERN int Jsi_TreeWalk(Jsi_Tree* treePtr, Jsi_TreeWalkProc* callback, void *data, int flags); /*STUB = 280*/\nJSI_EXTERN Jsi_TreeEntry* Jsi_TreeSet(Jsi_Tree *treePtr, const void *key, void *value); /*STUB = 281*/\nJSI_EXTERN void* Jsi_TreeGet(Jsi_Tree *treePtr, void *key, int flags); /*STUB = 282*/\nJSI_EXTERN bool Jsi_TreeUnset(Jsi_Tree *treePtr, void *key); /*STUB = 283*/\nJSI_EXTERN uint Jsi_TreeSize(Jsi_Tree *treePtr); /*STUB = 284*/ \nJSI_EXTERN Jsi_Tree* Jsi_TreeFromValue(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 285*/\nJSI_EXTERN Jsi_RC Jsi_TreeKeysDump(Jsi_Interp *interp, Jsi_Tree *hashPtr, Jsi_Value **ret, int flags); /*STUB = 286*/\n/* -- */\n\n\n/* --LIST-- */\ntypedef struct Jsi_List {\n    uint sig;\n    int numEntries;\n    Jsi_ListEntry *head;\n    Jsi_ListEntry *tail;\n    Jsi_MapOpts opts;\n} Jsi_List;\n\ntypedef struct Jsi_ListEntry {\n    uint sig;\n    Jsi_Map_Type typ;    \n    struct Jsi_ListEntry *next;\n    struct Jsi_ListEntry *prev;\n    Jsi_List *list;\n    void *value;\n} Jsi_ListEntry;\n\ntypedef struct Jsi_ListSearch {\n    int flags;\n    Jsi_List *tablePtr;\n    unsigned long nextIndex; \n    Jsi_ListEntry *nextEntryPtr;\n} Jsi_ListSearch;\n\nJSI_EXTERN Jsi_List* Jsi_ListNew(Jsi_Interp *interp, Jsi_Wide flags, Jsi_HashDeleteProc *freeProc); /*STUB = 287*/\nJSI_EXTERN Jsi_RC Jsi_ListConf(Jsi_List *list, Jsi_MapOpts *opts, bool set); /*STUB = 288*/\nJSI_EXTERN void Jsi_ListDelete(Jsi_List *list); /*STUB = 289*/\nJSI_EXTERN void Jsi_ListClear(Jsi_List *list); /*STUB = 290*/\n//#define Jsi_ListSet(l, before, value) Jsi_ListPush(l, before, Jsi_ListEntryNew(l, value))\n//#define Jsi_ListGet(l, le) (le)->value \n//#define Jsi_ListKeyGet(le) (le)\n//#define Jsi_ListKeysDump(interp, list, ret, flags) JSI_ERROR\nJSI_EXTERN void* Jsi_ListValueGet(Jsi_ListEntry *list); /*STUB = 291*/\nJSI_EXTERN void Jsi_ListValueSet(Jsi_ListEntry *list, const void *value); /*STUB = 292*/\n//#define Jsi_ListEntryFind(l, le) (le)\nJSI_EXTERN Jsi_ListEntry* Jsi_ListEntryNew(Jsi_List *list, const void *value, Jsi_ListEntry *before); /*STUB = 293*/\nJSI_EXTERN int Jsi_ListEntryDelete(Jsi_ListEntry *entry); /*STUB = 294*/\nJSI_EXTERN Jsi_ListEntry* Jsi_ListSearchFirst (Jsi_List *list, Jsi_ListSearch *search, int flags); /*STUB = 295*/\nJSI_EXTERN Jsi_ListEntry* Jsi_ListSearchNext (Jsi_ListSearch *search); /*STUB = 296*/\nJSI_EXTERN uint Jsi_ListSize(Jsi_List *list); /*STUB = 297*/\n/* end of hash-compat functions. */\n\nJSI_EXTERN Jsi_ListEntry* Jsi_ListPush(Jsi_List *list, Jsi_ListEntry *entry, Jsi_ListEntry *before); /*STUB = 298*/\nJSI_EXTERN Jsi_ListEntry* Jsi_ListPop(Jsi_List *list, Jsi_ListEntry *entry); /*STUB = 299*/\n#define Jsi_ListPushFront(list,entry)   Jsi_ListPush(list, entry, list->head)\n#define Jsi_ListPushBack(list,entry)    Jsi_ListPush(list, entry, NULL)\n#define Jsi_ListPushFrontNew(list,v)    Jsi_ListEntryNew(list, v, list->head)\n#define Jsi_ListPushBackNew(list,v)     Jsi_ListEntryNew(list, v, NULL)\n#define Jsi_ListPopFront(list)          Jsi_ListPop(list, list->head)\n#define Jsi_ListPopBack(list)           Jsi_ListPop(list, list->tail)\n#define Jsi_ListEntryNext(entry)        (entry)->next \n#define Jsi_ListEntryPrev(entry)        (entry)->prev\n#define Jsi_ListGetFront(list)          (list)->head\n#define Jsi_ListGetBack(list)           (list)->tail\n\n/* -- */\n\n\n/* --STACK-- */\ntypedef struct {\n    int len;\n    int maxlen;\n    void **vector;\n} Jsi_Stack;\n\nJSI_EXTERN Jsi_Stack* Jsi_StackNew(void); /*STUB = 300*/\nJSI_EXTERN void Jsi_StackFree(Jsi_Stack *stack); /*STUB = 301*/\nJSI_EXTERN int Jsi_StackSize(Jsi_Stack *stack); /*STUB = 302*/\nJSI_EXTERN void Jsi_StackPush(Jsi_Stack *stack, void *element); /*STUB = 303*/\nJSI_EXTERN void* Jsi_StackPop(Jsi_Stack *stack); /*STUB = 304*/\nJSI_EXTERN void* Jsi_StackPeek(Jsi_Stack *stack); /*STUB = 305*/\nJSI_EXTERN void* Jsi_StackUnshift(Jsi_Stack *stack); /*STUB = 306*/\nJSI_EXTERN void* Jsi_StackHead(Jsi_Stack *stack); /*STUB = 307*/\nJSI_EXTERN void Jsi_StackFreeElements(Jsi_Interp *interp, Jsi_Stack *stack, Jsi_DeleteProc *freeFunc); /*STUB = 308*/\n/* -- */\n\n/* --MAP-- */\ntypedef struct Jsi_MapSearch {\n    Jsi_Map_Type typ;\n    union {\n        Jsi_TreeSearch tree;\n        Jsi_HashSearch hash;\n        Jsi_ListSearch list;\n    } v;\n} Jsi_MapSearch;\n\nJSI_EXTERN Jsi_Map* Jsi_MapNew(Jsi_Interp *interp, Jsi_Map_Type mapType, Jsi_Key_Type keyType, Jsi_MapDeleteProc *freeProc); /*STUB = 309*/\nJSI_EXTERN Jsi_RC Jsi_MapConf(Jsi_Map *mapPtr, Jsi_MapOpts *opts, bool set); /*STUB = 310*/\nJSI_EXTERN void Jsi_MapDelete (Jsi_Map *mapPtr); /*STUB = 311*/\nJSI_EXTERN void Jsi_MapClear (Jsi_Map *mapPtr); /*STUB = 312*/\nJSI_EXTERN Jsi_MapEntry* Jsi_MapSet(Jsi_Map *mapPtr, const void *key, const void *value); /*STUB = 313*/\nJSI_EXTERN void* Jsi_MapGet(Jsi_Map *mapPtr, const void *key, int flags); /*STUB = 314*/\nJSI_EXTERN void* Jsi_MapKeyGet(Jsi_MapEntry *h, int flags); /*STUB = 315*/\nJSI_EXTERN Jsi_RC Jsi_MapKeysDump(Jsi_Interp *interp, Jsi_Map *mapPtr, Jsi_Value **ret, int flags); /*STUB = 316*/\nJSI_EXTERN void* Jsi_MapValueGet(Jsi_MapEntry *h); /*STUB = 317*/\nJSI_EXTERN void Jsi_MapValueSet(Jsi_MapEntry *h, const void *value); /*STUB = 318*/\nJSI_EXTERN Jsi_MapEntry* Jsi_MapEntryFind (Jsi_Map *mapPtr, const void *key); /*STUB = 319*/\nJSI_EXTERN Jsi_MapEntry* Jsi_MapEntryNew (Jsi_Map *mapPtr, const void *key, bool *isNew); /*STUB = 320*/\nJSI_EXTERN int Jsi_MapEntryDelete (Jsi_MapEntry *entryPtr); /*STUB = 321*/\nJSI_EXTERN Jsi_MapEntry* Jsi_MapSearchFirst (Jsi_Map *mapPtr, Jsi_MapSearch *searchPtr, int flags); /*STUB = 322*/\nJSI_EXTERN Jsi_MapEntry* Jsi_MapSearchNext (Jsi_MapSearch *srchPtr); /*STUB = 323*/\nJSI_EXTERN void Jsi_MapSearchDone (Jsi_MapSearch *searchPtr);  /*STUB = 324*/\nJSI_EXTERN uint Jsi_MapSize(Jsi_Map *mapPtr); /*STUB = 325*/\n\n\n// Define typed wrappers for 5 main Map functions: Set, Get, KeyGet, EntryFind, EntryNew\n#define JSI_MAP_EXTN(Prefix, keyType, valType) \\\nJSI_EXTERN Jsi_MapEntry *Prefix ## _Set(Jsi_Map *mapPtr, keyType key, valType value); \\\nJSI_EXTERN valType Prefix ## _Get(Jsi_Map *mapPtr, keyType key); \\\nJSI_EXTERN keyType Prefix ## _KeyGet(Jsi_MapEntry *h); \\\nJSI_EXTERN Jsi_MapEntry* Prefix ## _EntryFind (Jsi_Map *mapPtr, keyType key); \\\nJSI_EXTERN Jsi_MapEntry* Prefix ## _EntryNew (Jsi_Map *mapPtr, keyType key, int *isNew);\n\n#define JSI_MAP_DEFN(Prefix, keyType, valType) \\\nJsi_MapEntry *Prefix ## _Set(Jsi_Map *mapPtr, keyType key, valType value) { return Jsi_MapSet(mapPtr, (void*)key, (void*)value); } \\\nvalType Prefix ## _Get(Jsi_Map *mapPtr, keyType key) { return (valType)Jsi_MapGet(mapPtr, (void*)key); } \\\nkeyType Prefix ## _KeyGet(Jsi_MapEntry *h) { return (keyType)Jsi_MapKeyGet(h); } \\\nJsi_MapEntry* Prefix ## _EntryFind (Jsi_Map *mapPtr, keyType key) { return  Jsi_MapEntryFind(mapPtr, (void*)key); } \\\nJsi_MapEntry* Prefix ## _EntryNew (Jsi_Map *mapPtr, keyType key, int *isNew) { return  Jsi_MapEntryNew(mapPtr, (void*)key, isNew); }\n   \n/* -- */\n\n\n/* --OPTIONS-- */\ntypedef Jsi_RC (Jsi_OptionParseProc) (\n    Jsi_Interp *interp, Jsi_OptionSpec *spec, Jsi_Value *value, const char *str, void *record, Jsi_Wide flags);\ntypedef Jsi_RC (Jsi_OptionFormatProc) (\n    Jsi_Interp *interp, Jsi_OptionSpec *spec, Jsi_Value **retValue, Jsi_DString *retStr, void *record, Jsi_Wide flags);\ntypedef Jsi_RC (Jsi_OptionFormatStringProc) (\n    Jsi_Interp *interp, Jsi_OptionSpec *spec, Jsi_DString **retValue, void *record);\ntypedef void (Jsi_OptionFreeProc) (Jsi_Interp *interp, Jsi_OptionSpec *spec, void *ptr);\n\ntypedef Jsi_RC (Jsi_OptionBitOp)(Jsi_Interp *interp, Jsi_OptionSpec *spec, void *data, Jsi_Wide *s, int isSet);\n\ntypedef struct {\n    const char *name;\n    Jsi_OptionParseProc *parseProc;\n    Jsi_OptionFormatProc *formatProc;\n    Jsi_OptionFreeProc *freeProc;\n    const char *help;\n    const char *info;\n    void* data;\n} Jsi_OptionCustom;\n\ntypedef enum {\n    JSI_OPTION_BOOL=1,\n    JSI_OPTION_INT8,  JSI_OPTION_INT16,  JSI_OPTION_INT32,  JSI_OPTION_INT64,\n    JSI_OPTION_UINT8, JSI_OPTION_UINT16, JSI_OPTION_UINT32, JSI_OPTION_UINT64,\n    JSI_OPTION_FLOAT,\n    JSI_OPTION_DOUBLE,    // Same as NUMBER when !JSI_USE_LONG_DOUBLE.\n    JSI_OPTION_LDOUBLE,   // A long double\n    JSI_OPTION_STRBUF,    // Fixed size string buffer.\n    JSI_OPTION_TIME_W,    // Jsi_Wide: milliseconds since Jan 1, 1970.\n    JSI_OPTION_TIME_D,    // double: milliseconds since Jan 1, 1970.\n    // Non-portable fields start here\n    JSI_OPTION_TIME_T,    // time_t: seconds since Jan 1, 1970. \n    JSI_OPTION_SIZE_T,\n    JSI_OPTION_SSIZE_T,\n    JSI_OPTION_INTPTR_T,  // Int big enough to store a pointer.\n    JSI_OPTION_UINTPTR_T, \n    JSI_OPTION_NUMBER,    // Same as DOUBLE when !JSI_USE_LONG_DOUBLE.\n    JSI_OPTION_INT, JSI_OPTION_UINT,\n    JSI_OPTION_LONG, JSI_OPTION_ULONG, JSI_OPTION_SHORT, JSI_OPTION_USHORT,\n    JSI_OPTION_STRING, JSI_OPTION_DSTRING, JSI_OPTION_STRKEY,\n    JSI_OPTION_VALUE, JSI_OPTION_VAR, JSI_OPTION_OBJ, JSI_OPTION_ARRAY, JSI_OPTION_REGEXP,\n    JSI_OPTION_FUNC,      // Note: .data can contain string args to check\n    JSI_OPTION_USEROBJ,   // Note: .data can contain string obj name to check\n    JSI_OPTION_CUSTOM,    // Note: set .custom, .data, etc.\n    JSI_OPTION_END\n} Jsi_OptionId;\n\ntypedef const char* Jsi_Strkey;\n#ifdef __cplusplus\ntypedef void* Jsi_Strbuf;\n#else\ntypedef char Jsi_Strbuf[];\n#endif\n\ntypedef union {\n    bool           BOOL;\n    int8_t         INT8;\n    int16_t        INT16;\n    int32_t        INT32;\n    int64_t        INT64;\n    uint8_t        UINT8;\n    uint16_t       UINT16;\n    uint32_t       UINT32;\n    uint64_t       UINT64;\n    float          FLOAT;\n    double         DOUBLE;\n    ldouble        LDOUBLE;\n    Jsi_Number     NUMBER;\n    char*          STRBUF;\n    time_d         TIME_D;\n    time_w         TIME_W;\n    time_t         TIME_T;\n    size_t         SIZE_T;\n    ssize_t        SSIZE_T;\n    intptr_t       INTPTR_T;\n    uintptr_t      UINTPTR_T;\n    int            INT;\n    uint           UINT;\n    long           LONG;\n    ulong          ULONG;\n    short          SHORT;\n    ushort         USHORT;\n    Jsi_DString    DSTRING;\n    const char*    STRKEY;\n    Jsi_Value*     STRING;\n    Jsi_Value*     VALUE;\n    Jsi_Value*     VAR;\n    Jsi_Value*     OBJ;\n    Jsi_Value*     ARRAY;\n    Jsi_Value*     REGEXP;\n    Jsi_Value*     FUNC;\n    Jsi_Value*     USEROBJ;\n    void*          CUSTOM;\n    Jsi_csgset*    OPT_BITS;\n    struct Jsi_OptionSpec* OPT_CARRAY;\n} Jsi_OptionValue;\n\ntypedef union { /* Field used at compile-time by JSI_OPT() to provide type checking for the var */\n    bool           *BOOL;\n    int8_t         *INT8;\n    int16_t        *INT16;\n    int32_t        *INT32;\n    int64_t        *INT64;\n    uint8_t        *UINT8;\n    uint16_t       *UINT16;\n    uint32_t       *UINT32;\n    uint64_t       *UINT64;\n    float          *FLOAT;\n    double         *DOUBLE;\n    ldouble        *LDOUBLE;\n    Jsi_Number     *NUMBER;\n#ifdef __cplusplus\n    Jsi_Strbuf      STRBUF;\n#else\n    Jsi_Strbuf      *STRBUF;\n#endif\n    time_t         *TIME_T;\n    time_w         *TIME_W;\n    time_d         *TIME_D;\n    size_t         *SIZE_T;\n    ssize_t        *SSIZE_T;\n    intptr_t       *INTPTR_T;\n    uintptr_t      *UINTPTR_T;\n    int            *INT;\n    uint           *UINT;\n    long           *LONG;\n    ulong          *ULONG;\n    short          *SHORT;\n    ushort         *USHORT;\n    Jsi_DString    *DSTRING;\n    const char*    *STRKEY;\n    Jsi_Value*     *VALUE;\n    Jsi_Value*     *STRING;\n    Jsi_Value*     *VAR;\n    Jsi_Value*     *OBJ;\n    Jsi_Value*     *ARRAY;\n    Jsi_Value*     *REGEXP;\n    Jsi_Value*     *FUNC;\n    Jsi_Value*     *USEROBJ;\n    void           *CUSTOM;\n    Jsi_csgset     *OPT_BITS;\n    struct Jsi_OptionSpec *OPT_CARRAY;\n} Jsi_OptionInitVal;\n\ntypedef struct {\n    Jsi_Sig sig;\n    Jsi_OptionId id;\n    const char *idName, *cName;\n    int size;\n    const char *fmt, *xfmt, *sfmt, *help;\n    Jsi_OptionInitVal init;\n    Jsi_Wide flags;\n    Jsi_Wide user;\n    const char *userData;       /* User data. */ \\\n    uchar *extData;             /* Extension data. */\n    uchar *extra;\n    Jsi_HashEntry *hPtr;\n} Jsi_OptionTypedef;\n\nstruct Jsi_OptionSpec {\n    Jsi_Sig sig;                /* Signature field. */\n    Jsi_OptionId id;\n    const char *name;           /* The field name. */\n    uint offset;                /* Jsi_Offset of field. */\n    uint size;                  /* The sizeof() of field. */\n    Jsi_OptionInitVal init;     /* Initialization value */\n    const char *help;           /* A short one-line help string, without newlines. */\n    Jsi_Wide flags;             /* Lower 32 bits: the JSI_OPTS_* flags below. Upper 32 for custom/other. */\n    Jsi_OptionCustom *custom;   /* Custom handler. */\n    void *data;                 /* User data for custom options: eg. the bit for BOOLBIT. */\n    const char *info;           /* Longer command description. Use JSI_DETAIL macro to allow compile-out.*/\n    const char *tname;          /* Type name for field or external name used by the DB interface. */\n    Jsi_Wide value;             /* Value field. */\n    uint32_t bits;              /* Size of bitfield */\n    uint32_t boffset;           /* Bit offset of field (or struct) */\n    uint32_t idx;               /* Index (of field) */\n    uint32_t ssig;              /* Signature (for struct) */\n    uint32_t crc;               /* Crc (for struct) */\n    uint32_t arrSize;           /* Size of array */\n    const char *userData;       /* User data. */\n    uchar *extData;             /* Extension data. */\n    uchar *extra;               /* Extra pointer (currently unused). */\n    const Jsi_OptionTypedef *type;\n};\n\n/* JSI_OPT is a macro used for option definitions, eg:\n * \n *      typedef struct { int debug; int bool; } MyStruct;\n * \n *      Jsi_OptionSpec MyOptions[] = {\n *          JSI_OPT(BOOL,  MyStruct,  debug ),\n *          JSI_OPT(INT,   MyStruct,  max,   .help=\"Max value\"),\n *          JSI_OPT_END(   MyStruct, .help=\"My first struct\" )\n *      }\n*/\n\n#define JSI_OPT_(s, typ, strct, nam, ...) \\\n    { .sig=s, .id=JSI_OPTION_##typ, .name=#nam, .offset=Jsi_Offset(strct, nam), .size=sizeof(((strct *) 0)->nam), \\\n      .init={.typ=(&((strct *) 0)->nam)}, ##__VA_ARGS__ }\n\n#define JSI_OPT_END_(s, strct, ...) { .sig=s, .id=JSI_OPTION_END, .name=#strct, .offset=__LINE__, .size=sizeof(strct), \\\n      .init={.CUSTOM=(void*)__FILE__}, ##__VA_ARGS__}\n\n#define JSI_OPT_BITS_(s, strct, nam, hlp, flgs, bsget, fidx, tnam, bdata) \\\n    { .sig=s, .id=JSI_OPTION_CUSTOM, .name=#nam, .offset=0, .size=0, \\\n        .init={.OPT_BITS=&bsget}, .help=hlp, .flags=flgs, .custom=Jsi_Opt_SwitchBitfield, .data=bdata,\\\n        .info=0, .tname=#nam, .value=0, .bits=0, .boffset=0, .idx=fidx }\n\n#define JSI_OPT_CARRAY_(s, strct, nam, hlp, flgs, aropt, asiz, tnam, sinit) \\\n    { .sig=s, .id=JSI_OPTION_CUSTOM, .name=#nam, .offset=Jsi_Offset(strct, nam), .size=sizeof(((strct *) 0)->nam), \\\n        .init={.OPT_CARRAY=aropt}, .help=hlp, .flags=flgs, .custom=Jsi_Opt_SwitchCArray, .data=0,\\\n        .info=0, .tname=tnam, .value=0, .bits=0, .boffset=0, .idx=0, .ssig=0, .crc=0, .arrSize=asiz, .extData=sinit, .extra=0 }\n\n#define JSI_OPT_CARRAY_ITEM_(s, typ, strct, nam, ...) \\\n    { .sig=s, .id=JSI_OPTION_##typ, .name=#nam, .offset=0, .size=sizeof(((strct *) 0)->nam), \\\n      .init={.typ=(&((strct *) 0)->nam[0])}, ##__VA_ARGS__ }\n\n#define JSI_OPT(typ, strct, nam, ...) JSI_OPT_(JSI_SIG_OPTS, typ, strct, nam, ##__VA_ARGS__) \n#define JSI_OPT_END(strct, ...) JSI_OPT_END_(JSI_SIG_OPTS, strct, ##__VA_ARGS__)\n#define JSI_OPT_BITS(strct, nam, hlp, flgs, bsget, fidx, tnam, bdata) JSI_OPT_BITS_(JSI_SIG_OPTS, strct, nam, hlp, flgs, bsget, fidx, tnam, bdata)\n#define JSI_OPT_CARRAY(strct, nam, hlp, flgs, aropt, asiz, tnam, sinit) JSI_OPT_CARRAY_(JSI_SIG_OPTS, strct, nam, hlp, flgs, aropt, asiz, tnam, sinit)\n#define JSI_OPT_CARRAY_ITEM(typ, strct, nam, ...) JSI_OPT_CARRAY_ITEM_(JSI_SIG_OPTS, typ, strct, nam, ##__VA_ARGS__)\n\n#define JSI_OPT_END_IDX(opt) ((sizeof(opt)/sizeof(opt[0]))-1)\n\n/* builtin handler for Custom. */\n#define Jsi_Opt_SwitchEnum          (Jsi_OptionCustom*)0x1 /* An Enum: choices are in .data=stringlist */\n#define Jsi_Opt_SwitchBitset        (Jsi_OptionCustom*)0x2 /* Bits in an int: choices are in .data=stringlist */\n#define Jsi_Opt_SwitchSuboption     (Jsi_OptionCustom*)0x3 /* Sub-structs: subspec is in .data={...} */\n#define Jsi_Opt_SwitchBitfield      (Jsi_OptionCustom*)0x4 /* Struct bitfields: used by \"jsish -c\" */\n#define Jsi_Opt_SwitchValueVerify   (Jsi_OptionCustom*)0x5 /* Callback to verify Jsi_Value* correctness in .data=func. */\n#define Jsi_Opt_SwitchCArray        (Jsi_OptionCustom*)0x6 /* C Array described in .data=type. */\n#define Jsi_Opt_SwitchNull          (Jsi_OptionCustom*)0x7 /* Set is ignored, and get returns null */\n#define Jsi_Opt_SwitchParentFunc    (Jsi_OptionCustom*)0x8 /* Name of a func in parent. Sig string is in .data*/\n\nenum {\n    /* Jsi_OptionsProcess() flags */\n    JSI_OPTS_PREFIX         =   (1<<27), /* Allow matching unique prefix of object members. */\n    JSI_OPTS_IS_UPDATE      =   (1<<28), /* This is an update/conf (do not reset the specified flags) */\n    JSI_OPTS_IGNORE_EXTRA   =   (1<<29), /* Ignore extra members not found in spec. */\n    JSI_OPTS_FORCE_STRICT   =   (1<<30), /* Override Interp->compat to disable JSI_OPTS_IGNORE_EXTRA. */\n    JSI_OPTS_VERBOSE        =   (1<<31), /* Dump verbose options */\n    JSI_OPTS_INCR           =   (1<<7),  /* Options is an increment. */\n\n    /* Jsi_OptionSpec flags. */\n    JSI_OPT_IS_SPECIFIED    =   (1<<0),   /* User set the option. */\n    JSI_OPT_INIT_ONLY       =   (1<<1),   /* Allow set only at init, disallowing update/conf. */\n    JSI_OPT_READ_ONLY       =   (1<<2),   /* Value can not be set. */\n    JSI_OPT_NO_DUPVALUE     =   (1<<3),   /* Values are not to be duped. */\n    JSI_OPT_NO_CLEAR        =   (1<<4),   /* Values are not to be cleared: watch for memory leaks */\n    JSI_OPT_REQUIRED        =   (1<<5),  /* Field must be specified (if not IS_UPDATE). */\n    JSI_OPT_PASS2           =   (1<<6),   /* Options to be processed only on pass2. */\n    JSI_OPT_DB_DIRTY        =   (1<<8),   /* Used to limit DB updates. */\n    JSI_OPT_DB_IGNORE       =   (1<<9),   /* Field is not to be used for DB. */\n    JSI_OPT_DB_ROWID        =   (1<<10),  /* Field used by DB to store rowid. */\n    JSI_OPT_CUST_NOCASE     =   (1<<11),  /* Ignore case (eg. for ENUM and BITSET). */\n    JSI_OPT_FORCE_INT       =   (1<<12),  /* Force int instead of text for enum/bitset. */\n    JSI_OPT_BITSET_ENUM     =   (1<<13),  /* Mark field as a bitset/enum map custom field. */\n    JSI_OPT_TIME_DATEONLY   =   (1<<14),  /* Time field is date only. */\n    JSI_OPT_TIME_TIMEONLY   =   (1<<15),  /* Time field is time only. */\n    JSI_OPT_IS_BITS         =   (1<<16),  /* Is a C bit-field. */\n    JSI_OPT_FMT_STRING      =   (1<<17),  /* Format value (eg. time) as string. */\n    JSI_OPT_FMT_NUMBER      =   (1<<18),  /* Format value (eg. enum) as number. */\n    JSI_OPT_FMT_HEX         =   (1<<19),  /* Format number in hex. */\n    JSI_OPT_STRICT          =   (1<<20),  /* Strict mode. */\n    JSI_OPT_LOCKSAFE        =   (1<<21),  /* Field may not be configured when isSafe. */\n    JSI_OPT_COERCE          =   (1<<22),  /* Coerce input value to required type. */\n    JSI_OPT_NO_SIG          =   (1<<23),  /* No signature. */\n    JSI_OPT_ENUM_SPEC       =   (1<<24),  /* Enum has spec rather than a list of strings. */\n    JSI_OPT_ENUM_UNSIGNED   =   (1<<25),  /* Enum value is unsigned. */\n    JSI_OPT_ENUM_EXACT      =   (1<<26),  /* Enum must be an exact match. */\n    JSI_OPTIONS_USER_FIRSTBIT  =   48,    /* First bit of user flags: the lower 48 bits are internal. */\n};\n\nJSI_EXTERN const Jsi_OptionTypedef* Jsi_OptionTypeInfo(Jsi_OptionId typ); /*STUB = 326*/\nJSI_EXTERN Jsi_OptionTypedef* Jsi_TypeLookup(Jsi_Interp* interp, const char *typ); /*STUB = 327*/\nJSI_EXTERN int Jsi_OptionsProcess(Jsi_Interp *interp, Jsi_OptionSpec *specs, void *data, Jsi_Value *value, Jsi_Wide flags); /*STUB = 328*/\nJSI_EXTERN int Jsi_OptionsProcessJSON(Jsi_Interp *interp, Jsi_OptionSpec *opts, void *data, const char *json, Jsi_Wide flags); /*STUB = 329*/\nJSI_EXTERN Jsi_RC Jsi_OptionsConf(Jsi_Interp *interp, Jsi_OptionSpec *specs, void *data, Jsi_Value *value, Jsi_Value **ret, Jsi_Wide flags); /*STUB = 330*/\nJSI_EXTERN void Jsi_OptionsFree(Jsi_Interp *interp, Jsi_OptionSpec *specs, void *data, Jsi_Wide flags); /*STUB = 331*/\nJSI_EXTERN Jsi_RC Jsi_OptionsGet(Jsi_Interp *interp, Jsi_OptionSpec *specs, void *data, const char *option, Jsi_Value** valuePtr, Jsi_Wide flags); /*STUB = 332*/\nJSI_EXTERN Jsi_RC Jsi_OptionsSet(Jsi_Interp *interp, Jsi_OptionSpec *specs, void* data, const char *option, Jsi_Value *valuePtr, Jsi_Wide flags); /*STUB = 333*/\nJSI_EXTERN Jsi_RC Jsi_OptionsDump(Jsi_Interp *interp, Jsi_OptionSpec *specs, void *data, Jsi_Value** ret, Jsi_Wide flags); /*STUB = 334*/\nJSI_EXTERN int Jsi_OptionsChanged(Jsi_Interp *interp, Jsi_OptionSpec *specs, const char *pattern, ...) /*STUB = 335*/ __attribute__((sentinel));\nJSI_EXTERN bool Jsi_OptionsValid(Jsi_Interp *interp, Jsi_OptionSpec* spec);  /*STUB = 336*/\nJSI_EXTERN const char* Jsi_OptionsData(Jsi_Interp *interp, Jsi_OptionSpec *specs, Jsi_DString *dStr, bool schema);\nJSI_EXTERN Jsi_OptionSpec* Jsi_OptionsFind(Jsi_Interp *interp, Jsi_OptionSpec *specs, const char *name, Jsi_Wide flags); /*STUB = 337*/\nJSI_EXTERN Jsi_Value* Jsi_OptionsCustomPrint(void* clientData, Jsi_Interp *interp, const char *optionName, void *data, int offset); /*STUB = 338*/\nJSI_EXTERN Jsi_OptionCustom* Jsi_OptionCustomBuiltin(Jsi_OptionCustom* cust); /*STUB = 339*/\n/* Create a duplicate of static specs.   Use this for threaded access to Jsi_OptionsChanged(). */\nJSI_EXTERN Jsi_OptionSpec* Jsi_OptionsDup(Jsi_Interp *interp, const Jsi_OptionSpec *staticSpecs); /*STUB = 340*/\nJSI_EXTERN const Jsi_OptionSpec* Jsi_OptionSpecsCached(Jsi_Interp *interp, const Jsi_OptionSpec *staticSpecs);  /*STUB = 341*/\n/* -- */\n\n\n/* --THREADS/MUTEX-- */\nJSI_EXTERN Jsi_RC Jsi_MutexLock(Jsi_Interp *interp, Jsi_Mutex *mtx); /*STUB = 342*/\nJSI_EXTERN void Jsi_MutexUnlock(Jsi_Interp *interp, Jsi_Mutex *mtx); /*STUB = 343*/\nJSI_EXTERN void Jsi_MutexDelete(Jsi_Interp *interp, Jsi_Mutex *mtx); /*STUB = 344*/\nJSI_EXTERN Jsi_Mutex* Jsi_MutexNew(Jsi_Interp *interp, int timeout, int flags); /*STUB = 345*/\nJSI_EXTERN void* Jsi_CurrentThread(void); /*STUB = 346*/\nJSI_EXTERN void* Jsi_InterpThread(Jsi_Interp *interp); /*STUB = 347*/\n/* -- */\n\n\n/* --LOGGING-- */\n#define Jsi_LogBug(fmt,...) Jsi_LogMsg(interp, JSI_LOG_BUG, fmt, ##__VA_ARGS__)\n#define Jsi_LogError(fmt,...) Jsi_LogMsg(interp, JSI_LOG_ERROR, fmt, ##__VA_ARGS__)\n#define Jsi_LogParse(fmt,...) Jsi_LogMsg(interp, JSI_LOG_PARSE, fmt, ##__VA_ARGS__)\n#define Jsi_LogWarn(fmt,...) Jsi_LogMsg(interp, JSI_LOG_WARN, fmt, ##__VA_ARGS__)\n#define Jsi_LogInfo(fmt,...) Jsi_LogMsg(interp, JSI_LOG_INFO, fmt, ##__VA_ARGS__)\n#define Jsi_LogDebug(fmt,...) Jsi_LogMsg(interp, JSI_LOG_DEBUG, fmt, ##__VA_ARGS__)\n#define Jsi_LogTrace(fmt,...) Jsi_LogMsg(interp, JSI_LOG_TRACE, fmt, ##__VA_ARGS__)\n#define Jsi_LogTest(fmt,...) Jsi_LogMsg(interp, JSI_LOG_TEST, fmt, ##__VA_ARGS__)\n\nJSI_EXTERN Jsi_RC Jsi_LogMsg(Jsi_Interp *interp, uint level, const char *format,...)  /*STUB = 348*/ __attribute__((format (printf,3,4)));\n\n\n/* --EVENTS-- */\ntypedef struct {\n    Jsi_Sig sig;\n    uint id;\n    int evType;                 /* Is signal handler. */\n    int sigNum;\n    int once;                   /* Execute once */\n    long initialms;             /* initial relative timer value */\n    long when_sec;              /* seconds */\n    long when_ms;               /* milliseconds */\n    bool busy;                  /* In event callback. */\n    uint count;                 /* Times executed */\n    Jsi_HashEntry *hPtr;\n    Jsi_Value *funcVal;         /* JS Function to call. */\n    Jsi_EventHandlerProc *handler;  /* C-function handler. */\n    void *data;\n} Jsi_Event;\n\nJSI_EXTERN Jsi_Event* Jsi_EventNew(Jsi_Interp *interp, Jsi_EventHandlerProc *callback, void* data); /*STUB = 349*/\nJSI_EXTERN void Jsi_EventFree(Jsi_Interp *interp, Jsi_Event* event); /*STUB = 350*/\nJSI_EXTERN int Jsi_EventProcess(Jsi_Interp *interp, int maxEvents); /*STUB = 351*/\n/* -- */\n\n\n/* --JSON-- */\n#define JSI_JSON_DECLARE(p, tokens, maxsz) \\\n    Jsi_JsonParser p = {0}; \\\n    Jsi_JsonTok tokens[maxsz>0?maxsz:JSI_JSON_STATIC_DEFAULT]; \\\n    Jsi_JsonInit(&p, tokens, maxsz>0?maxsz:JSI_JSON_STATIC_DEFAULT)\n\ntypedef enum {\n    JSI_JTYPE_PRIMITIVE = 0,\n    JSI_JTYPE_OBJECT = 1,\n    JSI_JTYPE_ARRAY = 2,\n    JSI_JTYPE_STRING = 3,\n    JSI_JTYPE_INVALID=-1\n} Jsi_JsonTypeEnum;\n\ntypedef enum {\n    JSI_JSON_ERR_NOMEM = -1,\n    JSI_JSON_ERR_INVAL = -2,\n    JSI_JSON_ERR_PART = -3,\n    JSI_JSON_ERR_NONE = 0\n} Jsi_JsonErrEnum;\n\ntypedef struct {\n    Jsi_JsonTypeEnum type;\n    int start;\n    int end;\n    uint size;\n    int parent;\n} Jsi_JsonTok;\n\ntypedef struct {\n    uint pos;           /* offset in the JSON string */\n    uint toknext;       /* next token to allocate */\n    int toksuper;       /* superior token node, e.g parent object or array */\n    Jsi_JsonTok *tokens, *static_tokens;\n    uint num_tokens;\n    int no_malloc;      /* Disable parser dynamic growth tokens array. */\n    bool strict;/* Strict parsing. */\n    Jsi_Wide flags;\n    const char *errStr;\n    void *reserved[4];     /* Reserved for future */\n} Jsi_JsonParser;\n\n\nJSI_EXTERN void Jsi_JsonInit(Jsi_JsonParser *parser, Jsi_JsonTok *static_tokens, uint num_tokens); /*STUB = 352*/\nJSI_EXTERN void Jsi_JsonReset(Jsi_JsonParser *parser); /*STUB = 353*/\nJSI_EXTERN void Jsi_JsonFree(Jsi_JsonParser *parser); /*STUB = 354*/\nJSI_EXTERN Jsi_JsonErrEnum Jsi_JsonParse(Jsi_JsonParser *parser, const char *js); /*STUB = 355*/\nJSI_EXTERN Jsi_JsonTok* Jsi_JsonGetToken(Jsi_JsonParser *parser, uint index); /*STUB = 356*/\nJSI_EXTERN Jsi_JsonTypeEnum Jsi_JsonGetType(Jsi_JsonParser *parser, uint index); /*STUB = 357*/\nJSI_EXTERN int Jsi_JsonTokLen(Jsi_JsonParser *parser, uint index); /*STUB = 358*/\nJSI_EXTERN const char* Jsi_JsonGetTokstr(Jsi_JsonParser *parser, const char *js, uint index, uint *len); /*STUB = 359*/\nJSI_EXTERN const char* Jsi_JsonGetTypename(int type); /*STUB = 360*/\nJSI_EXTERN const char* Jsi_JsonGetErrname(int code); /*STUB = 361*/\nJSI_EXTERN void Jsi_JsonDump(Jsi_JsonParser *parser, const char *js); /*STUB = 362*/\n/* -- */\n\n\n/* --VFS-- */\nstruct Jsi_LoadHandle; struct Jsi_LoadHandle;\n\ntypedef struct Jsi_LoadHandle Jsi_LoadHandle;\ntypedef struct stat Jsi_StatBuf;\ntypedef struct dirent Jsi_Dirent;\n\ntypedef int (Jsi_FSStatProc) (Jsi_Interp *interp, Jsi_Value* path, Jsi_StatBuf *buf);\ntypedef int (Jsi_FSAccessProc) (Jsi_Interp *interp, Jsi_Value* path, int mode);\ntypedef int (Jsi_FSChmodProc) (Jsi_Interp *interp, Jsi_Value* path, int mode);\ntypedef Jsi_Channel (Jsi_FSOpenProc) (Jsi_Interp *interp, Jsi_Value* path, const char* modes);\ntypedef int (Jsi_FSLstatProc) (Jsi_Interp *interp, Jsi_Value* path, Jsi_StatBuf *buf);\ntypedef int (Jsi_FSCreateDirectoryProc) (Jsi_Interp *interp, Jsi_Value* path);\ntypedef int (Jsi_FSRemoveProc) (Jsi_Interp *interp, Jsi_Value* path, int flags);\ntypedef int (Jsi_FSCopyDirectoryProc) (Jsi_Interp *interp, Jsi_Value *srcPathPtr, Jsi_Value *destPathPtr, Jsi_Value **errorPtr);\ntypedef int (Jsi_FSCopyFileProc) (Jsi_Interp *interp, Jsi_Value *srcPathPtr, Jsi_Value *destPathPtr);\ntypedef int (Jsi_FSRemoveDirectoryProc) (Jsi_Interp *interp, Jsi_Value* path, int recursive, Jsi_Value **errorPtr);\ntypedef int (Jsi_FSRenameProc) (Jsi_Interp *interp, Jsi_Value *srcPathPtr, Jsi_Value *destPathPtr);\ntypedef Jsi_Value * (Jsi_FSListVolumesProc) (Jsi_Interp *interp);\ntypedef char* (Jsi_FSRealPathProc) (Jsi_Interp *interp, Jsi_Value* path, char *newPath);\ntypedef int (Jsi_FSLinkProc) (Jsi_Interp *interp, Jsi_Value* path, Jsi_Value *toPath, int linkType);\ntypedef int (Jsi_FSReadlinkProc)(Jsi_Interp *interp, Jsi_Value *path, char *buf, int size);\ntypedef int (Jsi_FSReadProc)(Jsi_Channel chan, char *buf, int size);\ntypedef int (Jsi_FSGetcProc)(Jsi_Channel chan);\ntypedef int (Jsi_FSEofProc)(Jsi_Channel chan);\ntypedef int (Jsi_FSTruncateProc)(Jsi_Channel chan, uint len);\ntypedef int (Jsi_FSUngetcProc)(Jsi_Channel chan, int ch);\ntypedef char *(Jsi_FSGetsProc)(Jsi_Channel chan, char *s, int size);\ntypedef int (Jsi_FSPutsProc)(Jsi_Channel chan, const char* str);\ntypedef int (Jsi_FSWriteProc)(Jsi_Channel chan, const char *buf, int size);\ntypedef int (Jsi_FSFlushProc)(Jsi_Channel chan);\ntypedef int (Jsi_FSSeekProc)(Jsi_Channel chan, Jsi_Wide offset, int mode);\ntypedef int (Jsi_FSTellProc)(Jsi_Channel chan);\ntypedef int (Jsi_FSCloseProc)(Jsi_Channel chan);\ntypedef int (Jsi_FSRewindProc)(Jsi_Channel chan);\ntypedef bool (Jsi_FSPathInFilesystemProc) (Jsi_Interp *interp, Jsi_Value* path,void* *clientDataPtr);\ntypedef int (Jsi_FSScandirProc)(Jsi_Interp *interp, Jsi_Value *path, Jsi_Dirent ***namelist,\n  int (*filter)(const Jsi_Dirent *), int (*compar)(const Jsi_Dirent **, const Jsi_Dirent**));\n\ntypedef struct Jsi_Filesystem {\n    const char *typeName;\n    int structureLength;    \n    int version;\n    Jsi_FSPathInFilesystemProc *pathInFilesystemProc;\n    Jsi_FSRealPathProc *realpathProc;\n    Jsi_FSStatProc *statProc;\n    Jsi_FSLstatProc *lstatProc;\n    Jsi_FSAccessProc *accessProc;\n    Jsi_FSChmodProc *chmodProc;\n    Jsi_FSOpenProc *openProc;\n    Jsi_FSScandirProc *scandirProc;\n    Jsi_FSReadProc *readProc;\n    Jsi_FSWriteProc *writeProc;\n    Jsi_FSGetsProc *getsProc;\n    Jsi_FSGetcProc *getcProc;\n    Jsi_FSUngetcProc *ungetcProc;\n    Jsi_FSPutsProc *putsProc;\n    \n    Jsi_FSFlushProc *flushProc;\n    Jsi_FSSeekProc *seekProc;\n    Jsi_FSTellProc *tellProc;\n    Jsi_FSEofProc *eofProc;\n    Jsi_FSTruncateProc *truncateProc;\n    Jsi_FSRewindProc *rewindProc;\n    Jsi_FSCloseProc *closeProc;\n    Jsi_FSLinkProc *linkProc;\n    Jsi_FSReadlinkProc *readlinkProc;\n    Jsi_FSListVolumesProc *listVolumesProc;\n    Jsi_FSCreateDirectoryProc *createDirectoryProc;\n    Jsi_FSRemoveProc *removeProc;\n    Jsi_FSRenameProc *renameProc;\n    void *reserved[10];     /* Reserved for future */\n} Jsi_Filesystem;\n\ntypedef struct Jsi_Chan {\n    FILE *fp;\n    const char *fname;  /* May be set by fs or by source */\n    Jsi_Filesystem *fsPtr;\n    int isNative;\n    int flags;\n    char modes[JSI_FSMODESIZE];\n    void *data;\n    void *reserved[4];     /* Reserved for future */\n    ssize_t resInt[2];\n} Jsi_Chan;\n\nJSI_EXTERN Jsi_RC Jsi_FSRegister(Jsi_Filesystem *fsPtr, void *data); /*STUB = 363*/\nJSI_EXTERN Jsi_RC Jsi_FSUnregister(Jsi_Filesystem *fsPtr); /*STUB = 364*/\nJSI_EXTERN Jsi_Channel Jsi_FSNameToChannel(Jsi_Interp *interp, const char *name); /*STUB = 365*/\nJSI_EXTERN char* Jsi_GetCwd(Jsi_Interp *interp, Jsi_DString *cwdPtr); /*STUB = 366*/\nJSI_EXTERN int Jsi_Lstat(Jsi_Interp *interp, Jsi_Value* path, Jsi_StatBuf *buf); /*STUB = 367*/\nJSI_EXTERN int Jsi_Stat(Jsi_Interp *interp, Jsi_Value* path, Jsi_StatBuf *buf); /*STUB = 368*/\nJSI_EXTERN int Jsi_Access(Jsi_Interp *interp, Jsi_Value* path, int mode); /*STUB = 369*/\nJSI_EXTERN int Jsi_Remove(Jsi_Interp *interp, Jsi_Value* path, int flags); /*STUB = 370*/\nJSI_EXTERN int Jsi_Rename(Jsi_Interp *interp, Jsi_Value *src, Jsi_Value *dst); /*STUB = 371*/\nJSI_EXTERN int Jsi_Chdir(Jsi_Interp *interp, Jsi_Value* path); /*STUB = 372*/\nJSI_EXTERN Jsi_Channel Jsi_Open(Jsi_Interp *interp, Jsi_Value *file, const char *modeString); /*STUB = 373*/\nJSI_EXTERN int Jsi_Eof(Jsi_Interp *interp, Jsi_Channel chan); /*STUB = 374*/\nJSI_EXTERN int Jsi_Close(Jsi_Interp *interp, Jsi_Channel chan); /*STUB = 375*/\nJSI_EXTERN int Jsi_Read(Jsi_Interp *interp, Jsi_Channel chan, char *bufPtr, int toRead); /*STUB = 376*/\nJSI_EXTERN int Jsi_Write(Jsi_Interp *interp, Jsi_Channel chan, const char *bufPtr, int slen); /*STUB = 377*/\nJSI_EXTERN Jsi_Wide Jsi_Seek(Jsi_Interp *interp, Jsi_Channel chan, Jsi_Wide offset, int mode); /*STUB = 378*/\nJSI_EXTERN Jsi_Wide Jsi_Tell(Jsi_Interp *interp, Jsi_Channel chan); /*STUB = 379*/\nJSI_EXTERN int Jsi_Truncate(Jsi_Interp *interp, Jsi_Channel chan, uint len); /*STUB = 380*/\nJSI_EXTERN Jsi_Wide Jsi_Rewind(Jsi_Interp *interp, Jsi_Channel chan); /*STUB = 381*/\nJSI_EXTERN int Jsi_Flush(Jsi_Interp *interp, Jsi_Channel chan); /*STUB = 382*/\nJSI_EXTERN int Jsi_Getc(Jsi_Interp *interp, Jsi_Channel chan); /*STUB = 383*/\nJSI_EXTERN int Jsi_Printf(Jsi_Interp *interp, Jsi_Channel chan, const char *fmt, ...) /*STUB = 384*/ __attribute__((format (printf,3,4))); \nJSI_EXTERN int Jsi_Ungetc(Jsi_Interp *interp, Jsi_Channel chan, int ch); /*STUB = 385*/\nJSI_EXTERN char* Jsi_Gets(Jsi_Interp *interp, Jsi_Channel chan, char *s, int size); /*STUB = 386*/\nJSI_EXTERN int Jsi_Puts(Jsi_Interp *interp, Jsi_Channel chan, const char *str, int size); /*STUB = 387*/\n\ntypedef int (Jsi_ScandirFilter)(const Jsi_Dirent *);\ntypedef int (Jsi_ScandirCompare)(const Jsi_Dirent **, const Jsi_Dirent**);\nJSI_EXTERN int Jsi_Scandir(Jsi_Interp *interp, Jsi_Value *path, Jsi_Dirent ***namelist, Jsi_ScandirFilter *filter, Jsi_ScandirCompare *compare ); /*STUB = 388*/\nJSI_EXTERN int Jsi_SetChannelOption(Jsi_Interp *interp, Jsi_Channel chan, const char *optionName, const char *newValue); /*STUB = 389*/\nJSI_EXTERN char* Jsi_Realpath(Jsi_Interp *interp, Jsi_Value *path, char *newname); /*STUB = 390*/\nJSI_EXTERN int Jsi_Readlink(Jsi_Interp *interp, Jsi_Value* path, char *ret, int len); /*STUB = 391*/\nJSI_EXTERN Jsi_Channel Jsi_GetStdChannel(Jsi_Interp *interp, int id); /*STUB = 392*/\nJSI_EXTERN bool Jsi_FSNative(Jsi_Interp *interp, Jsi_Value* path); /*STUB = 393*/\nJSI_EXTERN int Jsi_Link(Jsi_Interp *interp, Jsi_Value* src, Jsi_Value *dest, int typ); /*STUB = 394*/\nJSI_EXTERN int Jsi_Chmod(Jsi_Interp *interp, Jsi_Value* path, int mode); /*STUB = 395*/\n\nJSI_EXTERN Jsi_RC Jsi_StubLookup(Jsi_Interp *interp, const char *name, void **ptr); /*STUB = 396*/\nJSI_EXTERN Jsi_RC Jsi_DllLookup(Jsi_Interp *interp, const char *module, const char *name, void **ptr); /*STUB = 404*/\nJSI_EXTERN Jsi_RC Jsi_LoadLibrary(Jsi_Interp *interp, const char *pathName, bool noInit); /*STUB = 405*/\nJSI_EXTERN int Jsi_AddAutoFiles(Jsi_Interp *interp, const char *dir);  /*STUB = 397*/\n\n/* -- */\n\n\n\n/* --DATABASE-- */\n\nJSI_EXTERN Jsi_Db* Jsi_DbNew(const char *zFile, int inFlags); /*STUB = 398*/\nJSI_EXTERN void* Jsi_DbHandle(Jsi_Interp *interp, Jsi_Db* db); /*STUB = 399*/\n\n/* -- */\n\n\n/* --CData-- */\n\n#define  JSI_CDATA_OPTION_CHANGED(name) \\\n        (vrPtr->spec && Jsi_OptionsChanged(interp, vrPtr->spec, #name, NULL))\n#define  JSI_CDATA_OPTION_RESET(name) \\\n        (cmdPtr->queryOpts.mode && !options->name && JSI_CDATA_OPTION_CHANGED(name))\n \ntypedef struct Jsi_CData_Static {\n    const char* name;\n    Jsi_StructSpec* structs;\n    Jsi_EnumSpec* enums;\n    Jsi_VarSpec *vars;\n    Jsi_OptionTypedef* types;\n    struct Jsi_CData_Static* nextPtr;\n} Jsi_CData_Static;\n\n/* Struct for Carray to bind Data/Option pairs to individual SQLite binding chars. */\ntypedef struct Jsi_CDataDb {\n#define JSI_DBDATA_FIELDS \\\n    Jsi_StructSpec *sf;     /* Struct fields for data. */ \\\n    void *data;             /* Data pointer for array/map */ \\\n    uint arrSize;           /* If an array, number of elements: 0 means 1. */ \\\n    char prefix;            /* Sqlite char bind prefix. One of: '@' '$' ':' '?' or 0 for any */ \\\n    Jsi_StructSpec* slKey;  /* Struct for key (for map using a struct key). */ \\\n    int (*callback)(Jsi_Interp *interp, struct Jsi_CDataDb* obPtr, void *data); /* C callback for select queries. */ \\\n    uint maxSize;           /* Limit size of array/map*/ \\\n    bool noAuto;            /* Do not auto-create map keys. */ \\\n    bool isPtrs;            /* \"data\" an array of pointers. */ \\\n    bool isPtr2;            /* \"data\" is pointer to pointers, which is updated. */ \\\n    bool isMap;             /* \"data\" is a map: use Jsi_MapConf() for details. */ \\\n    bool memClear;          /* Before query free and zero all data (eg. DStrings). */ \\\n    bool memFree;           /* Reset as per mem_clear, then free data items. Query may be empty. */ \\\n    bool dirtyOnly;         /* Sqlite dirty filter for UPDATE/INSERT/REPLACE. */ \\\n    bool noBegin;           /* Disable wrapping UPDATE in BEGIN/COMMIT. */ \\\n    bool noCache;           /* Disable Db caching statement. */ \\\n    bool noStatic;          /* Disable binding text with SQLITE_STATIC. */ \\\n    intptr_t reserved[4];   /* Internal use. */\nJSI_DBDATA_FIELDS\n} Jsi_CDataDb;\n\nJSI_EXTERN int Jsi_DbQuery(Jsi_Db *jdb, Jsi_CDataDb *cd, const char *query); /*STUB = 400*/\nJSI_EXTERN Jsi_CDataDb* Jsi_CDataLookup(Jsi_Interp *interp, const char *name); /*STUB = 401*/\nJSI_EXTERN Jsi_RC Jsi_CDataRegister(Jsi_Interp *interp, Jsi_CData_Static *statics); /*STUB = 402*/\nJSI_EXTERN Jsi_RC Jsi_CDataStructInit(Jsi_Interp *interp, uchar* data, const char *sname); /*STUB = 403*/\nJSI_EXTERN Jsi_StructSpec* Jsi_CDataStruct(Jsi_Interp *interp, const char *name); /*STUB = 406*/\n/* -- */\n\n\n/* String */\ntypedef char STRING1[(1<<0)+1]; // Include a char for the null byte.\ntypedef char STRING2[(1<<1)+1];\ntypedef char STRING4[(1<<2)+1];\ntypedef char STRING8[(1<<3)+1];\ntypedef char STRING16[(1<<4)+1];\ntypedef char STRING32[(1<<5)+1];\ntypedef char STRING64[(1<<6)+1];\ntypedef char STRING128[(1<<7)+1];\ntypedef char STRING256[(1<<8)+1];\ntypedef char STRING512[(1<<9)+1];\ntypedef char STRING1024[(1<<10)+1];\ntypedef char STRING2048[(1<<11)+1];\ntypedef char STRING4096[(1<<12)+1];\ntypedef char STRING8192[(1<<13)+1];\ntypedef char STRING16384[(1<<14)+1];\ntypedef char STRING32768[(1<<15)+1];\ntypedef char STRING65536[(1<<16)+1];\n\n/* -- */\n\n\n#define JSI_STUBS_STRUCTSIZES (sizeof(Jsi_MapSearch)+sizeof(Jsi_TreeSearch) \\\n    +sizeof(Jsi_HashSearch)+sizeof(Jsi_Filesystem)+sizeof(Jsi_Chan)+sizeof(Jsi_Event) \\\n    +sizeof(Jsi_CDataDb)+sizeof(Jsi_Stack)+sizeof(Jsi_OptionSpec)+sizeof(Jsi_CmdSpec) \\\n    +sizeof(Jsi_UserObjReg)+sizeof(Jsi_String) + sizeof(Jsi_PkgOpts))\n\n#ifndef JSI_OMIT_STUBS\n#ifdef JSI_USE_STUBS\n#ifndef JSISTUBCALL\n#define JSISTUBCALL(ptr,func) ptr->func\n#endif\n#include \"jsiStubs.h\"\n#else\n#define JSI_EXTENSION_INI\n#define Jsi_StubsInit(i,f) JSI_OK\n#endif\n#endif\n\n\n/* Optional compile-out commands/options string information. */\n#ifdef JSI_OMIT_INFO\n#define JSI_INFO(n) NULL\n#endif\n#ifndef JSI_INFO\n#define JSI_INFO(n) n\n#endif\n\n#endif /* __JSI_H__ */\n\n\n", "#ifndef JSI_LITE_ONLY\n#ifndef JSI_AMALGAMATION\n#include \"jsiInt.h\"\n#else\nchar *strptime(const char *buf, const char *fmt, struct tm *tm);\n#endif\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <signal.h>\n#include <limits.h>\n#ifndef __WIN32\n#include <sys/wait.h>\n#endif\n\nstatic Jsi_RC consoleInputCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[1024];\n    char *cp, *p = buf;\n    buf[0] = 0;\n    if (!interp->stdinStr)\n        p=fgets(buf, sizeof(buf), stdin);\n    else {\n        int ilen;\n        cp = Jsi_ValueString(interp, interp->stdinStr, &ilen);\n        if (!cp || ilen<=0)\n            p = NULL;\n        else {\n            Jsi_Strncpy(buf, cp, sizeof(buf));\n            buf[sizeof(buf)-1] = 0;\n            p = Jsi_Strchr(buf, '\\n');\n            if (p) { *p = 0;}\n            ilen = Jsi_Strlen(buf);\n            p = (cp + ilen + (p?1:0));\n            Jsi_ValueMakeStringDup(interp, &interp->stdinStr, p);\n            p = buf;\n        }\n    }\n    \n    if (p == NULL) {\n        Jsi_ValueMakeUndef(interp, ret);\n        return JSI_OK;\n    }\n    if ((p = Jsi_Strchr(buf, '\\r'))) *p = 0;\n    if ((p = Jsi_Strchr(buf, '\\n'))) *p = 0;\n    Jsi_ValueMakeStringDup(interp, ret, buf);\n    return JSI_OK;\n}\n\ntypedef struct {\n    bool trace;\n    bool once;\n    bool noError;\n    bool autoIndex;\n    bool isMain;\n    bool global;\n    bool exists;\n    uint level;\n} SourceData;\n\nstatic Jsi_OptionSpec SourceOptions[] = {\n    JSI_OPT(BOOL,   SourceData, autoIndex,  .help=\"Look for and load Jsi_Auto.jsi auto-index file\" ),\n    JSI_OPT(BOOL,   SourceData, exists, .help=\"Source file only if exists\" ),\n    JSI_OPT(BOOL,   SourceData, global, .help=\"File is to be sourced in global frame rather than local\" ),\n    JSI_OPT(BOOL,   SourceData, isMain, .help=\"Coerce to true the value of Info.isMain()\" ),\n    JSI_OPT(UINT,   SourceData, level,  .help=\"Frame to source file in\" ),\n    JSI_OPT(BOOL,   SourceData, noError,.help=\"Ignore errors in sourced file\" ),\n    JSI_OPT(BOOL,   SourceData, once,   .help=\"Source file only if not already sourced (Default: Interp.debugOpts.includeOnce)\" ),\n    JSI_OPT(BOOL,   SourceData, trace,  .help=\"Trace include statements (Default: Interp.debugOpts.includeTrace)\" ),\n    JSI_OPT_END(SourceData, .help=\"Options for source command\")\n};\n\n\nstatic Jsi_RC SysSourceCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    jsi_Pstate *ps = interp->ps;\n    Jsi_RC rc = JSI_OK;\n    int flags = 0;\n    int i, argc;\n    SourceData data = {.trace = interp->debugOpts.includeTrace, .once = interp->debugOpts.includeOnce};\n    Jsi_Value *v, *va = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_Value *vo = Jsi_ValueArrayIndex(interp, args, 1);\n    if (vo) {\n        if (!Jsi_ValueIsObjType(interp, vo, JSI_OT_OBJECT)) { /* Future options. */\n            Jsi_LogError(\"arg2: expected object 'options'\");\n            return JSI_ERROR;\n        }\n        if (Jsi_OptionsProcess(interp, SourceOptions, &data, vo, 0) < 0) {\n            return JSI_ERROR;\n        }\n        if (data.autoIndex)\n            flags |= JSI_EVAL_AUTOINDEX;\n    }\n    if ((interp->includeDepth+1) > interp->maxIncDepth) \n        return Jsi_LogError(\"max source depth exceeded\");\n    if (data.once)\n        flags|= JSI_EVAL_ONCE;\n    if (data.exists)\n        flags|= JSI_EVAL_EXISTS;\n    if (data.noError)\n        flags|= JSI_EVAL_ERRIGNORE;\n    if (data.global) {\n        flags|= JSI_EVAL_GLOBAL;\n        if (data.level)\n            return Jsi_LogError(\"invalid ot specify both global and level\");\n    } else if (!data.level)\n        data.level = interp->framePtr->level;\n    interp->includeCnt++;\n    interp->includeDepth++;\n    int oisi = interp->isMain;\n    interp->isMain = data.isMain;\n    const char *sop = (data.once?\" <ONCE>\":\"\");\n    if (!Jsi_ValueIsArray(interp, va)) {\n        v = va;\n        if (v && Jsi_ValueIsString(interp,v)) {\n            if (data.trace)\n                Jsi_LogInfo(\"sourcing: %s%s\", Jsi_ValueString(interp, v, 0), sop);\n            rc = jsi_evalStrFile(ps->interp, v, NULL, flags, data.level);\n        } else {\n            Jsi_LogError(\"expected string\");\n            rc = JSI_ERROR;\n        }\n        goto done;\n    }\n    argc = Jsi_ValueGetLength(interp, va);\n    for (i=0; i<argc && rc == JSI_OK; i++) {\n        v = Jsi_ValueArrayIndex(interp, va, i);\n        if (v && Jsi_ValueIsString(interp,v)) {\n            if (data.trace)\n                Jsi_LogInfo(\"sourcing: %s%s\", Jsi_ValueString(interp, v, 0), sop);\n            rc = jsi_evalStrFile(ps->interp, v, 0, flags, data.level);\n        } else {\n            Jsi_LogError(\"expected string\");\n            rc = JSI_ERROR;\n            break;\n        }\n    }\ndone:\n    if (rc == JSI_OK)\n        Jsi_ValueCopy(interp, *ret, interp->retValue);\n    interp->isMain = oisi;\n    interp->includeDepth--;\n    return rc;\n}\n\nstatic void jsiGetTime(long *seconds, long *milliseconds)\n{\n    struct timeval tv;\n\n    gettimeofday(&tv, NULL);\n    *seconds = tv.tv_sec;\n    *milliseconds = tv.tv_usec / 1000;\n}\n\nvoid Jsi_EventFree(Jsi_Interp *interp, Jsi_Event* event) {\n    SIGASSERTV(event,EVENT);\n    if (event->funcVal)\n        Jsi_DecrRefCount(interp, event->funcVal);\n    if (event->hPtr) {\n        Jsi_HashValueSet(event->hPtr, NULL);\n        Jsi_HashEntryDelete(event->hPtr);\n    }\n    _JSI_MEMCLEAR(event);\n    Jsi_Free(event);\n}\n\n/* Create an event and add to interp event table. */\nJsi_Event* Jsi_EventNew(Jsi_Interp *interp, Jsi_EventHandlerProc *callback, void* data)\n{\n    Jsi_Event *evPtr;\n    while (1) {\n        bool isNew;\n        uintptr_t id = ++interp->eventIdx;\n        Jsi_HashEntry *hPtr = Jsi_HashEntryNew(interp->eventTbl, (void*)id, &isNew);\n        if (!isNew)\n            continue;\n        evPtr = (Jsi_Event*)Jsi_Calloc(1, sizeof(*evPtr));\n        SIGINIT(evPtr,EVENT);\n        evPtr->id = id;\n        evPtr->handler = callback;\n        evPtr->data = data;\n        evPtr->hPtr = hPtr;\n        Jsi_HashValueSet(hPtr, evPtr);\n        break;\n    }\n    return evPtr;\n}\n\n/* Process events and return count. */\nint Jsi_EventProcess(Jsi_Interp *interp, int maxEvents)\n{\n    Jsi_Event *evPtr;\n    Jsi_HashEntry *hPtr;\n    Jsi_HashSearch search;\n    Jsi_Value* nret = NULL;\n    Jsi_RC rc;\n    int cnt = 0, newIdx = interp->eventIdx;\n    long cur_sec, cur_ms;\n    jsiGetTime(&cur_sec, &cur_ms);\n    Jsi_Value *vpargs = NULL;\n\n    /*if (Jsi_MutexLock(interp, interp->Mutex) != JSI_OK)\n        return JSI_ERROR;*/\n\n    for (hPtr = Jsi_HashSearchFirst(interp->eventTbl, &search);\n            hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {\n\n        if (!(evPtr = (Jsi_Event*)Jsi_HashValueGet(hPtr)))\n            continue;\n        SIGASSERT(evPtr,EVENT);\n        if ((int)evPtr->id > newIdx) /* Avoid infinite loop of event creating events. */\n            continue;\n        switch (evPtr->evType) {\n        case JSI_EVENT_SIGNAL:\n#ifndef JSI_OMIT_SIGNAL   /* TODO: win signals? */\n            if (!jsi_SignalIsSet(interp, evPtr->sigNum))\n                continue;\n            jsi_SignalClear(interp, evPtr->sigNum);\n#endif\n            break;\n        case JSI_EVENT_TIMER:\n            if (cur_sec <= evPtr->when_sec && (cur_sec != evPtr->when_sec || cur_ms < evPtr-> when_ms)) {\n                if (evPtr->when_sec && evPtr->when_ms)\n                    continue;\n            }\n            cnt++;\n            evPtr->count++;\n            break;\n        case JSI_EVENT_ALWAYS:\n            break;\n        default:\n            assert(0);\n        }\n        if (evPtr->busy)\n            continue;\n        evPtr->busy = 1;\n        if (evPtr->handler) {\n            rc = evPtr->handler(interp, evPtr->data);\n        } else {\n            if (vpargs == NULL) {\n                vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, NULL, 0, 0));\n                Jsi_IncrRefCount(interp, vpargs);\n            }\n            if (!nret)\n                nret = Jsi_ValueNew1(interp);\n            rc = Jsi_FunctionInvoke(interp, evPtr->funcVal, vpargs, &nret, NULL);\n        }\n        evPtr->busy = 0;\n        if (interp->deleting) {\n            cnt = -1;\n            goto bail;\n        }\n        if (rc != JSI_OK) {\n            if (interp->exited) {\n                cnt = rc;\n                goto bail;\n            }\n            Jsi_LogError(\"event function call failure\");\n        }\n        if (evPtr->once) {\n            Jsi_EventFree(interp, evPtr);\n        } else {\n            evPtr->when_sec = cur_sec + evPtr->initialms / 1000;\n            evPtr->when_ms = cur_ms + evPtr->initialms % 1000;\n            if (evPtr->when_ms >= 1000) {\n                evPtr->when_sec++;\n                evPtr->when_ms -= 1000;\n            }\n        }\n        if (maxEvents>=0 && cnt>=maxEvents)\n            break;\n    }\nbail:\n    if (vpargs)\n        Jsi_DecrRefCount(interp, vpargs);\n    if (nret)\n        Jsi_DecrRefCount(interp, nret);\n    /*Jsi_MutexUnlock(interp, interp->Mutex);*/\n\n    static int evCnt = 0;\n    evCnt++;\n    if (interp->parent && interp->busyCallback)\n        Jsi_EventProcess(interp->parent, maxEvents);\n    return cnt;\n}\n\n/*\n * \\brief: sleep for so many milliseconds with interp mutex unlocked.\n */\nJsi_RC Jsi_Sleep(Jsi_Interp *interp, Jsi_Number dtim) {\n    uint utim = 0;\n    if (dtim <= 0)\n        return JSI_OK;\n    Jsi_MutexUnlock(interp, interp->Mutex);\n    dtim = (dtim/1e3);\n    if (dtim>1) {\n        utim = 1e6*(dtim - (Jsi_Number)((int)dtim));\n        dtim = (int)dtim;\n    } else if (dtim<1) {\n        utim = 1e6 * dtim;\n        dtim = 0;\n    }\n    if (utim>0)\n        usleep(utim);\n    if (dtim>0)\n        sleep(dtim);\n    if (Jsi_MutexLock(interp, interp->Mutex) != JSI_OK) {\n        Jsi_LogBug(\"could not reget mutex\");\n        return JSI_ERROR;\n    }\n    return JSI_OK;\n}\n\n#ifndef JSI_OMIT_EVENT\ntypedef struct {\n    int minTime;\n    int maxEvents;\n    int maxPasses;\n    int sleep;\n} jsiUpdateData;\n\nstatic Jsi_OptionSpec jsiUpdateOptions[] = {\n    JSI_OPT(INT,    jsiUpdateData, maxEvents,  .help=\"Maximum number of events to process (or -1 for all)\" ),\n    JSI_OPT(INT,    jsiUpdateData, maxPasses,  .help=\"Maximum passes through event queue\" ),\n    JSI_OPT(INT,    jsiUpdateData, minTime,    .help=\"Minimum milliseconds before returning, or -1 to loop forever (default is 0)\" ),\n    JSI_OPT(INT,    jsiUpdateData, sleep,      .help=\"Time to sleep time (in milliseconds) between event checks. Default is 1\" ),\n    JSI_OPT_END(jsiUpdateData, .help=\"Options for update command\")\n};\n\n#define FN_update JSI_INFO(\"\\\nReturns the number of events processed. \\\nEvents are processed until minTime (in milliseconds) is exceeded, or forever if -1.\\n\\\nThe default minTime is 0, meaning return as soon as no events can be processed. \\\nA positive mintime will result in sleeps between event checks.\")\nstatic Jsi_RC SysUpdateCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int maxEvents = -1, hasopts = 0;\n    int cnt = 0, lcnt = 0;\n    Jsi_RC rc = JSI_OK;\n    Jsi_Value *opts = Jsi_ValueArrayIndex(interp, args, 0);\n    long cur_sec, cur_ms;\n    long start_sec, start_ms;\n    jsiGetTime(&start_sec, &start_ms);\n    jsiUpdateData udata = {};\n    udata.sleep = 1;\n       \n    if (opts != NULL) {\n        Jsi_Number dms = 0;\n        if (opts->vt == JSI_VT_OBJECT) {\n            hasopts = 1;\n            if (Jsi_OptionsProcess(interp, jsiUpdateOptions, &udata, opts, 0) < 0) {\n                return JSI_ERROR;\n            }\n        } else if (opts->vt != JSI_VT_NULL && Jsi_GetNumberFromValue(interp, opts, &dms) != JSI_OK)\n            return JSI_ERROR;\n        else\n            udata.minTime = (unsigned long)dms;\n    }\n  \n    while (1) {\n        long long diftime;\n        if (!interp->EventHdlId && (interp->interpStrEvents || Jsi_DSLength(&interp->interpEvalQ)))\n            jsi_AddEventHandler(interp); \n        int ne = Jsi_EventProcess(interp, maxEvents);\n        if (ne<0)\n            break;\n        cnt += ne;\n        if (Jsi_InterpGone(interp))\n            return JSI_ERROR;\n        if (udata.minTime==0)\n            break;\n        jsiGetTime(&cur_sec, &cur_ms);\n        if (cur_sec == start_sec)\n            diftime = (long long)(cur_ms-start_ms);\n        else\n            diftime = (cur_sec-start_sec)*1000LL + cur_ms + (1000-start_ms);\n        if (udata.minTime>0 && diftime >= (long long)udata.minTime)\n            break;\n        if (udata.maxPasses && ++lcnt >= udata.maxPasses)\n            break;\n        if ((rc = Jsi_Sleep(interp, udata.sleep)) != JSI_OK)\n            break;\n    }\n    if (hasopts)\n        Jsi_OptionsFree(interp, jsiUpdateOptions, &udata, 0);\n    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)cnt);\n    return rc;\n}\n\nstatic Jsi_RC intervalTimer(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr, int once)\n{\n    bool isNew;\n    Jsi_Event *evPtr;\n    uintptr_t id;\n    Jsi_Number milli;\n    long milliseconds, cur_sec, cur_ms;\n    Jsi_Value *fv = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_Value *tv = Jsi_ValueArrayIndex(interp, args, 1);\n    \n    if (!Jsi_ValueIsFunction(interp, fv)) \n        return Jsi_LogError(\"arg1: expected function 'callback'\");\n    if (Jsi_GetNumberFromValue(interp, tv, &milli) != JSI_OK) \n        return Jsi_LogError(\"arg2: expected number 'ms'\");\n    milliseconds = (long)milli;\n    if (milliseconds < 0)\n        milliseconds = 0;\n    while (1) {\n        id = ++interp->eventIdx;\n        Jsi_HashEntry *hPtr = Jsi_HashEntryNew(interp->eventTbl, (void*)id, &isNew);\n        if (!isNew)\n            continue;\n        evPtr = (Jsi_Event*)Jsi_Calloc(1, sizeof(*evPtr));\n        SIGINIT(evPtr,EVENT);\n        evPtr->id = id;\n        evPtr->funcVal = fv;\n        Jsi_IncrRefCount(interp, fv);\n        evPtr->hPtr = hPtr;\n        jsiGetTime(&cur_sec, &cur_ms);\n        evPtr->initialms = milliseconds;\n        evPtr->when_sec = cur_sec + milliseconds / 1000;\n        evPtr->when_ms = cur_ms + milliseconds % 1000;\n        if (evPtr->when_ms >= 1000) {\n            evPtr->when_sec++;\n            evPtr->when_ms -= 1000;\n        }\n        evPtr->once = once;\n        Jsi_HashValueSet(hPtr, evPtr);\n        break;\n    }\n    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)id);\n    return JSI_OK;\n}\n\nstatic Jsi_RC setIntervalCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    return intervalTimer(interp, args, _this, ret, funcPtr, 0);\n}\n\nstatic Jsi_RC clearIntervalCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Number nid;\n    uintptr_t id;\n    Jsi_Value *tv = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_HashEntry *hPtr;\n    if (Jsi_GetNumberFromValue(interp, tv, &nid) != JSI_OK) \n        return Jsi_LogError(\"arg1: expected number 'ms'\");\n    id = (uintptr_t)nid;\n    if (interp->EventHdlId && id==interp->EventHdlId)\n        return Jsi_LogError(\"can not clear internal handler\");\n    hPtr = Jsi_HashEntryFind(interp->eventTbl, (void*)id);\n    if (hPtr == NULL) \n        return Jsi_LogError(\"id not found: %\" PRId64, (Jsi_Wide)id);\n    Jsi_HashEntryDelete(hPtr);\n    return JSI_OK;\n}\n\nstatic Jsi_RC setTimeoutCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    return intervalTimer(interp, args, _this, ret, funcPtr, 1);\n}\n#endif\n\nstatic Jsi_RC SysExitCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int err = 0;\n    Jsi_Value *v = NULL;\n    Jsi_Number n;\n    if (Jsi_ValueGetLength(interp, args) > 0) {\n        v = Jsi_ValueArrayIndex(interp, args, 0);\n        if (v && Jsi_GetNumberFromValue(interp,v, &n) == JSI_OK)\n            err = (int)n;\n        else \n            return Jsi_LogError(\"arg1: expected number 'code'\");\n    }\n    if (interp->onExit && interp->parent) {\n        bool b = Jsi_FunctionInvokeBool(interp->parent, interp->onExit, v);\n        if (Jsi_InterpGone(interp))\n            return JSI_ERROR;\n        if (b)\n            return JSI_OK;\n    }\n    if (interp->parent == NULL && interp == interp->mainInterp && interp->debugOpts.isDebugger)\n        jsi_DoExit(interp, err); // In debugger, skip memory cleanup.\n    else {\n        interp->exited = 1;\n        interp->exitCode = err;\n        return JSI_ERROR;\n        /* TODO: cleanup events, etc. */\n    }\n    return JSI_OK;\n}\n\n\nstatic Jsi_RC parseIntCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Wide w = 0;\n    Jsi_Number d = 0;\n\n    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_Value *bv = Jsi_ValueArrayIndex(interp, args, 1);\n    if (!v)\n        return JSI_ERROR;\n    char *eptr, *str = Jsi_ValueString(interp, v, NULL);\n    int base = 0;\n    if (!str) {\n        if (Jsi_ValueIsNumber(interp, v))\n            Jsi_GetNumberFromValue(interp, v, &d);\n        else\n            goto nanval;\n    }\n    else if (str[0] == '0' && str[1] == 'x')\n        d = (Jsi_Number)strtoll(str, &eptr, 16);\n    else if (str[0] == '0' && !bv)\n        d = (Jsi_Number)strtoll(str, &eptr, 8);\n    else if (base == 0 && !bv)\n        d = Jsi_ValueToNumberInt(interp, v, 1);\n    else {\n        if (str == NULL || JSI_OK != Jsi_GetIntFromValue(interp, bv, &base) || base<2 || base>36)\n            return JSI_ERROR;\n        d = (Jsi_Number)strtoll(str, &eptr, base);\n    }\n    if (Jsi_NumberIsNaN(d) || (Jsi_NumberIsFinite(d)==0 && Jsi_GetDoubleFromValue(interp, v, &d) != JSI_OK))\nnanval:\n        Jsi_ValueDup2(interp, ret, interp->NaNValue);\n    else {\n        w = (Jsi_Wide)d;\n        Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)w);\n    }\n    return JSI_OK;\n}\n\nstatic Jsi_RC parseFloatCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Number n;\n    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_ValueToNumber(interp, v);\n    if (Jsi_GetDoubleFromValue(interp, v, &n) != JSI_OK)\n        Jsi_ValueDup2(interp, ret, interp->NaNValue);\n    else {\n        Jsi_ValueMakeNumber(interp, ret, n);\n    }\n    return JSI_OK;\n}\n\n// Return file path as a Jsi_Value, if it exists.\nJsi_Value * jsi_AccessFile(Jsi_Interp *interp, const char *name, int mode)\n{\n    //TODO: Optimize by not allocing Jsi_Value if access() fails and not in /zvfs with no other mounts.\n    if (0 && access(name, R_OK) <0) {\n        if (interp->mountCnt==0)\n            return NULL;\n        if (interp->selfZvfs && interp->mountCnt==1 && Jsi_Strncmp(name, JSI_ZVFS_DIR, Jsi_Strlen(JSI_ZVFS_DIR)))\n            return NULL;\n    }\n    Jsi_Value *fpath = Jsi_ValueNewStringDup(interp, name); \n    Jsi_IncrRefCount(interp, fpath);\n    if (Jsi_Access(interp, fpath, mode) >= 0)\n        return fpath;\n    Jsi_DecrRefCount(interp, fpath);\n    return NULL;\n}\n\nstatic jsi_PkgInfo* jsi_PkgGet(Jsi_Interp *interp, const char *name)\n{\n     return (jsi_PkgInfo*)Jsi_HashGet(interp->packageHash, name, 0);\n}\n\nJsi_Number Jsi_PkgVersion(Jsi_Interp *interp, const char *name, const char **filePtr)\n{\n    jsi_PkgInfo *ptr = jsi_PkgGet(interp, name);\n    if (ptr) {\n        if (filePtr)\n            *filePtr = ptr->loadFile;\n        return ptr->version;\n    }\n    return -1;\n}\n\n// Load one package. Note: Currently ver is ignored.\nstatic Jsi_RC jsi_PkgLoadOne(Jsi_Interp *interp, const char *name, const char *path, int len, Jsi_Value **fval, Jsi_Number ver)\n{\n    bool trace = interp->debugOpts.pkgTrace;\n    Jsi_RC rc = JSI_CONTINUE;\n    const char *fn;\n    const char *ext;\n    if (!path)\n        return JSI_CONTINUE;\n    if (len<0)\n        len = Jsi_Strlen(path);\n#ifdef __WIN32\n    ext = \".dll\";\n#else\n    ext = \".so\";\n#endif\n    Jsi_Value *fpath = NULL;\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    int i;\n    const char *sf = \"\";\n    if (trace)\n        sf = jsi_GetCurFile(interp);\n    for (i=0; i<4 && rc == JSI_CONTINUE; i++) {\n        const char *pref = (i%2 ? name : \"\"), *ps = (i%2 ? \"/\" : \"\");\n        if (i<2) {\n#ifdef JSI_OMIT_LOAD\n        continue;\n#endif\n            Jsi_DSSetLength(&dStr, 0);\n            Jsi_DSAppendLen(&dStr, path, len);\n            Jsi_DSAppend(&dStr, \"/\", pref, ps, name, ext, NULL);\n            fn = Jsi_DSValue(&dStr);\n            if ((fpath = jsi_AccessFile(interp, fn, R_OK))) {\n                if (trace)\n                    Jsi_Printf(interp, jsi_Stderr,\"Package-Trace: load('%s') from %s\\n\", fn, sf);\n                rc = Jsi_LoadLibrary(interp, fn, 0);\n            }\n        } else {\n            Jsi_DSSetLength(&dStr, 0);\n            Jsi_DSAppendLen(&dStr, path, len);\n            Jsi_DSAppend(&dStr, \"/\", pref, ps, name, \".jsi\", NULL);\n            fn = Jsi_DSValue(&dStr);\n            if ((fpath = jsi_AccessFile(interp, fn, R_OK))) {\n                if (trace)\n                    Jsi_Printf(interp, jsi_Stderr, \"Package-Trace: source('%s') from %s\\n\", fn, sf);\n                int oisi = interp->isMain;\n                interp->isMain = 0;\n                rc = Jsi_EvalFile(interp, fpath, JSI_EVAL_GLOBAL);\n                interp->isMain = oisi;\n            }\n        }\n    }\n    int needErr = 1;\n    if (rc == JSI_OK) {\n        ver = Jsi_PkgVersion(interp, name, NULL);\n        if (ver < 0) {\n            rc = Jsi_LogError(\"package missing provide('%s') in file: %s\", name, Jsi_DSValue(&dStr));\n            needErr = 0;\n        }\n    }\n    if (rc == JSI_OK) {\n        *fval = fpath;\n    }\n    else if (fpath)\n        Jsi_DecrRefCount(interp, fpath);\n    if (rc == JSI_ERROR && needErr)\n        Jsi_LogError(\"within require('%s') in file: %s\", name, Jsi_DSValue(&dStr));\n    Jsi_DSFree(&dStr);\n    return rc;\n}\n\n// Load package from pkgDirs or executable path.  Note. ver currently unused.\nstatic Jsi_RC jsi_PkgLoad(Jsi_Interp *interp, const char *name, Jsi_Number ver) {\n    Jsi_RC rc;\n    const char *cp = NULL, *path;\n    int len;\n    uint i = 0;\n    Jsi_Value *fval = NULL;\n    Jsi_Value *pval = interp->pkgDirs;\n    if (pval) {\n        Jsi_Obj* obj = pval->d.obj;\n        bool isJsish = !Jsi_Strcmp(name, \"Jsish\");\n        for (; i<obj->arrCnt; i++) {\n            const char *pnam = Jsi_ValueString(interp, obj->arr[i], NULL);\n            if (isJsish && interp->selfZvfs && Jsi_Strncmp(pnam, JSI_ZVFS_DIR, sizeof(JSI_ZVFS_DIR)-1))\n                continue;\n            rc = jsi_PkgLoadOne(interp, name, pnam, -1, &fval, ver);\n            if (rc != JSI_CONTINUE)\n                goto done;\n        }\n    }\n    // Check executable dir.\n    path = jsiIntData.execName;\n    if (path)\n        cp = Jsi_Strrchr(path, '/');\n    if (cp) {\n        len = cp-path;\n        rc = jsi_PkgLoadOne(interp, name, path, len, &fval, ver);\n        if (rc != JSI_CONTINUE)\n            goto done;\n    }\n    // Check script dir.\n    if ((path = interp->framePtr->fileName) || (interp->argv0 && (path = Jsi_ValueString(interp, interp->argv0, NULL)))) {\n        if ((cp = Jsi_Strrchr(path, '/'))) {\n            len = (cp-path);\n            rc = jsi_PkgLoadOne(interp, name, path, len, &fval, ver);\n            if (rc != JSI_CONTINUE)\n                goto done;\n        }\n    } else if (interp->curDir) { // Interactive mode \n        rc = jsi_PkgLoadOne(interp, name, interp->curDir, Jsi_Strlen(interp->curDir), &fval, ver);\n        if (rc != JSI_CONTINUE)\n            goto done;\n    }\n    return JSI_ERROR;\n    \ndone:\n    if (rc == JSI_CONTINUE)\n        rc = JSI_ERROR;\n    if (rc == JSI_OK) {\n        Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->packageHash, name);\n        if (!hPtr)\n            rc = JSI_ERROR;\n        else {\n            jsi_PkgInfo *ptr, *ptr2;\n            Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->packageHash, name);\n            if (hPtr) {\n                ptr = (jsi_PkgInfo*)Jsi_HashValueGet(hPtr);\n                if (ptr)\n                    if (fval) {\n                        char *fval2 = Jsi_Realpath(interp, fval, NULL);\n                        ptr->loadFile = Jsi_KeyAdd(interp, fval2);\n                        if (interp->parent && ptr->initProc) {\n                            if (interp->debugOpts.pkgTrace)\n                                Jsi_Printf(interp, jsi_Stderr , \"Package-Trace: load from topLevel: %s\\n\", name);\n                            ptr2 = jsi_PkgGet(interp->topInterp, name);\n                            if (ptr2)\n                                ptr2->loadFile = Jsi_KeyAdd(interp->topInterp, ptr->loadFile);\n                        }\n                        Jsi_DecrRefCount(interp, fval);\n                        free(fval2);\n                    }\n            }\n        }\n    }\n    if (rc != JSI_OK && fval)\n        Jsi_DecrRefCount(interp, fval);\n    return rc;\n}\n\nJsi_Number Jsi_PkgRequireEx(Jsi_Interp *interp, const char *name, Jsi_Number version, Jsi_PkgOpts **poptsPtr)\n{\n    jsi_PkgInfo *ptr = jsi_PkgGet(interp, name), *ptr2 = NULL;\n    if (ptr) {\n        if (version)\n            ptr->lastReq = version;\n        if (ptr->initProc && ptr->needInit) {\n            if ((*ptr->initProc)(interp, 0) != JSI_OK) \n                return -1;\n            ptr->needInit = 0;\n        }\n            if (poptsPtr)\n                *poptsPtr = &ptr->popts;\n        return ptr->version;\n    } else if ((ptr2 = jsi_PkgGet(interp->topInterp, name)) && ptr2->initProc) {\n        // C-extensions load from topInterp\n        if (interp->debugOpts.pkgTrace)\n            Jsi_Printf(interp, jsi_Stderr , \"Package-Trace: load from topLevel: %s\\n\", name);\n        ptr = (jsi_PkgInfo*)Jsi_Calloc(1, sizeof(*ptr));\n        *ptr = *ptr2;\n        if (ptr->loadFile)\n            ptr->loadFile = Jsi_KeyAdd(interp->topInterp, ptr->loadFile);\n        ptr->needInit = 1;\n        Jsi_HashSet(interp->packageHash, name, ptr);\n        if ((*ptr2->initProc)(interp, 0) == JSI_OK && (ptr = jsi_PkgGet(interp, name))) {\n            ptr->needInit = 0;\n            return ptr->version;\n            if (poptsPtr)\n                *poptsPtr = &ptr->popts;\n        }\n    }\n    if (interp->pkgReqDepth>interp->maxIncDepth) {\n        Jsi_LogError(\"recursive require('%s')\", name);\n        return -1;\n    }\n    \n    interp->pkgReqDepth++;\n    version = jsi_VersionNormalize(version, NULL, 0);\n    if (jsi_PkgLoad(interp, name, version) != JSI_OK) {\n        Jsi_LogError(\"failed require('%s')\", name);\n        interp->pkgReqDepth--;\n        return -1;\n    }\n    interp->pkgReqDepth--;\n    ptr = jsi_PkgGet(interp, name);\n    if (!ptr) {\n        Jsi_LogError(\"package not found for require('%s')\", name);\n        return -1;\n    }\n    if (poptsPtr)\n        *poptsPtr = &ptr->popts;\n    return ptr->version;\n}\n\nJsi_RC jsi_GetVerFromVal(Jsi_Interp *interp, Jsi_Value *val, Jsi_Number *nPtr, bool isProvide)\n{\n    Jsi_Number n = *nPtr;\n    if (!val)\n        return Jsi_LogError(\"missing version\");\n    if (Jsi_ValueIsNumber(interp, val)) {\n        if (Jsi_GetDoubleFromValue(interp, val, &n) != JSI_OK || Jsi_NumberIsNaN(n) || (isProvide?n<=0.0:n<0.0) || n>=100.0)\n            return Jsi_LogError(\"bad version: %.\" JSI_VERFMT_LEN JSI_NUMGFMT, n);\n        *nPtr = n;\n        return JSI_OK;\n    }\n    const char *vstr = Jsi_ValueString(interp, val, NULL), *vs = vstr;\n    if (!vstr)\n        return Jsi_LogError(\"bad version\");\n    uint v[3] = {};\n    while (*vs && (isdigit(*vs) || *vs=='.')) vs++;\n    if (*vs || sscanf(vstr, \"%u.%u.%u\", v, v+1, v+2) < 1 || v[0]>=100 || v[1]>=100 || v[2]>=100)\n        return Jsi_LogError(\"bad version string: %s\", vstr);\n    *nPtr = jsi_VersionNormalize((Jsi_Number)v[0] + ((Jsi_Number)v[1]/100.0) + ((Jsi_Number)v[2]/10000.0), NULL, 0);\n    return JSI_OK;\n}\n\nJsi_Number jsi_VersionNormalize(Jsi_Number ver, char *obuf, size_t osiz)\n{\n    ver = ((Jsi_Number)((uint)(0.5+ver*10000.0)))/10000.0;\n    if (obuf) {\n        uint n = (uint)(0.5+10000.0*ver);\n        uint v[3] = {n/10000};\n        n -= v[0]*10000; v[1] = n/100;\n        n -= v[1]*100; v[2] = n;\n        snprintf(obuf, osiz, \"%u.%u.%u\", v[0], v[1], v[2]);\n    }\n    return ver;\n}\n   \nstatic Jsi_OptionSpec jsiModuleOptions[] = {\n    JSI_OPT(BOOL,  Jsi_ModuleConf, Debug,   .help=\"Enable LogDebug messages for module\" ),\n    JSI_OPT(BOOL,  Jsi_ModuleConf, Test,    .help=\"Enable LogTest messages for module\" ),\n    JSI_OPT(BOOL,  Jsi_ModuleConf, Trace,   .help=\"Enable LogTrace messages for module\" ),\n    JSI_OPT(BOOL,  Jsi_ModuleConf, coverage,.help=\"On exit generate detailed code coverage for function calls (with profile)\" ),\n    JSI_OPT(BOOL,  Jsi_ModuleConf, profile, .help=\"On exit generate profile of function calls\" ),\n    JSI_OPT(CUSTOM,Jsi_ModuleConf, traceCall,.help=\"Trace commands\", .flags=0,  .custom=Jsi_Opt_SwitchBitset,  .data=jsi_callTraceStrs),\n    JSI_OPT_END(Jsi_ModuleConf, .help=\"Options for require command\")\n};\n\nJsi_RC jsi_PkgDumpInfo(Jsi_Interp *interp, const char *name, Jsi_Value **ret) {\n    jsi_PkgInfo *ptr;\n    Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->packageHash, name);\n    if (hPtr && ((ptr = (jsi_PkgInfo*)Jsi_HashValueGet(hPtr)))) {\n        Jsi_Obj *nobj = Jsi_ObjNew(interp);\n        Jsi_ValueMakeObject(interp, ret, nobj);\n        Jsi_ObjInsert(interp, nobj, \"name\", Jsi_ValueNewStringDup(interp, name), 0);\n        Jsi_ObjInsert(interp, nobj, \"version\", Jsi_ValueNewNumber(interp, ptr->version), 0);\n        Jsi_ObjInsert(interp, nobj, \"lastReq\", Jsi_ValueNewNumber(interp, ptr->lastReq), 0);\n        char buf[JSI_MAX_NUMBER_STRING*2];\n        jsi_VersionNormalize(ptr->version, buf, sizeof(buf));\n        Jsi_ObjInsert(interp, nobj, \"verStr\", Jsi_ValueNewStringDup(interp, buf), 0);\n        const char *cp = (ptr->loadFile?ptr->loadFile:\"\");\n        Jsi_ObjInsert(interp, nobj, \"loadFile\", Jsi_ValueNewStringDup(interp, cp), 0);\n        Jsi_Value *fval2, *fval = Jsi_NameLookup(interp, name);\n        if (!fval || !Jsi_ValueIsFunction(interp, fval))\n            fval = Jsi_ValueNewNull(interp);\n        Jsi_ObjInsert(interp, nobj, \"func\", fval, 0);\n        fval = ptr->popts.info;\n        if (!fval) fval = interp->NullValue;\n        if (!Jsi_ValueIsObjType(interp, fval, JSI_OT_FUNCTION))\n            Jsi_ObjInsert(interp, nobj, \"info\", fval, 0);\n        else {\n            fval2 = Jsi_ValueNew1(interp);\n            Jsi_RC rc = Jsi_FunctionInvoke(interp, fval, NULL, &fval2, NULL);\n            if (rc != JSI_OK)\n                Jsi_LogWarn(\"status call failed\");\n            Jsi_ObjInsert(interp, nobj, \"info\", fval2, 0);\n            Jsi_DecrRefCount(interp, fval2);\n        }\n        fval = interp->NullValue;\n        if (ptr->popts.spec && ptr->popts.data) {\n            fval = Jsi_ValueNew1(interp);\n            Jsi_OptionsConf(interp, ptr->popts.spec, ptr->popts.data, NULL, &fval, 0);\n        }\n        Jsi_ObjInsert(interp, nobj, \"status\", fval, 0);\n        if (fval != interp->NullValue)\n            Jsi_DecrRefCount(interp, fval);\n\n        fval = Jsi_ValueNew1(interp);\n        Jsi_OptionsConf(interp, jsiModuleOptions, &ptr->popts.modConf, NULL, &fval, 0);\n        Jsi_ObjInsert(interp, nobj, \"moduleOpts\", fval, 0);\n        Jsi_DecrRefCount(interp, fval);\n\n        return JSI_OK;\n    }\n    return JSI_ERROR;\n}\n\nstatic Jsi_RC InfoPackageCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    const char *name = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    if (!name || jsi_PkgDumpInfo(interp, name, ret) != JSI_OK)\n        Jsi_ValueMakeNull(interp, ret);\n    return JSI_OK;\n}\n\n#define FN_require JSI_INFO(\"\\\nWith no arguments, returns the list of all loaded packages.\\n\\\nWith one argument, loads the package (if necessary) and returns its version.\\n\\\nWith two arguments, returns object containing: version, loadFile, func.\\n\\\nA third argument sets options for package or module.\\n\\\nNote an error is thrown if requested version is greater than actual version.\")\nstatic Jsi_RC SysRequireCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Number n = 0;\n    int argc = Jsi_ValueGetLength(interp, args);\n    if (argc == 0)\n        return Jsi_HashKeysDump(interp, interp->packageHash, ret, 0);\n        \n    Jsi_Value *vname = Jsi_ValueArrayIndex(interp, args, 0);\n    const char *name = NULL;\n    if (Jsi_ValueIsString(interp, vname)) {\n        name = Jsi_ValueString(interp, vname, NULL);\n        if (!Jsi_StrIsAlnum(name))\n            name = NULL;\n    }\n    if (!name) \n        return Jsi_LogError(\"invalid or missing package name\");\n    if (argc>1) {\n        Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 1);\n        if (jsi_GetVerFromVal(interp, v, &n, 0) != JSI_OK)\n            return JSI_ERROR;\n        n = jsi_VersionNormalize(n, NULL, 0);\n    }\n    int isMain = interp->isMain;\n    interp->isMain = 0;\n    Jsi_Number ver = Jsi_PkgRequireEx(interp, name, n, NULL);\n    interp->isMain = isMain;\n    if (ver < 0)\n        return JSI_ERROR;\n    Jsi_RC rc = JSI_OK;\n    if (argc==2) {\n        if (ver < n) \n            rc = Jsi_LogType(\"package '%s' downlevel: %.\" JSI_NUMGFMT \" < %.\" JSI_VERFMT_LEN JSI_NUMGFMT, name, ver, n);\n        if (rc != JSI_OK)\n            return rc;\n        return jsi_PkgDumpInfo(interp, name, ret);\n    }\n    Jsi_Value *opts = Jsi_ValueArrayIndex(interp, args, 2);\n       \n    if (opts != NULL) {\n        jsi_PkgInfo *pkg = jsi_PkgGet(interp, name);\n        if (!pkg) return JSI_ERROR;\n        Jsi_ModuleConf *mptr = &pkg->popts.modConf;\n        if (Jsi_OptionsProcess(interp, jsiModuleOptions, mptr, opts, 0) < 0)\n            return JSI_ERROR;\n        if (pkg->popts.cmdSpec) {\n            int *fl = &pkg->popts.cmdSpec->flags;\n            if (mptr->Test) *fl |= JSI_CMD_LOG_TEST; else *fl &=  ~JSI_CMD_LOG_TEST;\n            if (mptr->Debug) *fl |= JSI_CMD_LOG_DEBUG; else *fl &=  ~JSI_CMD_LOG_DEBUG;\n            if (mptr->Trace) *fl |= JSI_CMD_LOG_TRACE; else *fl &=  ~JSI_CMD_LOG_TRACE;\n        }\n    }\n\n    Jsi_ValueMakeNumber(interp, ret, ver);\n    return rc;\n}\n\nJsi_RC Jsi_PkgProvideEx(Jsi_Interp *interp, const char *name, Jsi_Number version, \n    Jsi_InitProc *initProc, Jsi_PkgOpts* popts)\n{\n    jsi_PkgInfo *ptr;\n    Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->packageHash, name);\n    Jsi_Value *opts = (popts?popts->info:NULL);\n    if (version<0) {\n        if (hPtr) {\n            ptr = (jsi_PkgInfo*)Jsi_HashValueGet(hPtr);\n            Jsi_HashEntryDelete(hPtr);\n        }\n        return JSI_OK;\n    }\n    version = jsi_VersionNormalize(version, NULL, 0);\n    if (version == 0) \n        return Jsi_LogError(\"Version must be > 0\");\n    else {\n        if (hPtr) {\n            ptr = (jsi_PkgInfo*)Jsi_HashValueGet(hPtr);\n            if (ptr && ptr->needInit==0) \n                return Jsi_LogError(\"package %s already provided from: %s\", name, ptr->loadFile?ptr->loadFile:\"\");\n            return JSI_OK;\n        }\n        if (!Jsi_StrIsAlnum(name)) \n            return Jsi_LogError(\"invalid package name\");\n        if (opts && !Jsi_ValueIsObjType(interp, opts, JSI_OT_OBJECT) && !Jsi_ValueIsObjType(interp, opts, JSI_OT_FUNCTION))\n            return Jsi_LogError(\"opts must be function or object\");\n        ptr = (jsi_PkgInfo*)Jsi_Calloc(1, sizeof(*ptr));\n        ptr->version = version;\n        ptr->initProc = initProc;\n        if (popts) {\n            ptr->popts = *popts;\n            if (popts->info)\n                Jsi_IncrRefCount(interp, popts->info);\n        }\n        if (interp->framePtr->fileName && !initProc)\n            ptr->loadFile = Jsi_KeyAdd(interp->topInterp, interp->framePtr->fileName);\n        Jsi_HashSet(interp->packageHash, (void*)name, ptr);\n        if (initProc && interp->parent) { // Provide C extensions to topInterp.\n            ptr = jsi_PkgGet(interp->topInterp, name);\n            if (ptr == NULL) {\n                Jsi_PkgOpts po = {};\n                Jsi_Value *nopts = NULL;\n                if (opts) {\n                    nopts = Jsi_ValueNew(interp);\n                    Jsi_CleanValue(interp, interp->topInterp, po.info, &nopts);\n                    po.info = nopts;\n                }\n                Jsi_RC rc = Jsi_PkgProvideEx(interp->topInterp, name, version, initProc, &po);\n                if (rc != JSI_OK)\n                    return JSI_ERROR;\n                ptr = jsi_PkgGet(interp->topInterp, name);\n                if (!ptr)\n                    return JSI_ERROR;\n                ptr->needInit = 1;\n            }\n        }\n\n    }\n    return JSI_OK;\n}\n        \nstatic Jsi_RC SysProvideCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Number n = 1;\n    const char *name = NULL, *cp;\n    Jsi_Value *vname = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_RC rc = JSI_OK;\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    Jsi_Func *f = NULL;\n    if (!vname) {\n        name = jsi_GetCurFile(interp);\n        if (!name)\n            return JSI_ERROR;\n        if ((cp = strrchr(name, '/')))\n            name = cp+1;\n        if ((cp = strrchr(name, '.')))\n            Jsi_DSAppendLen(&dStr, name, (cp-name));\n        else\n            Jsi_DSAppend(&dStr, name, NULL);\n        name = Jsi_DSValue(&dStr);\n    } else if (Jsi_ValueIsString(interp, vname)) {\n        name = Jsi_ValueString(interp, vname, NULL);\n        if (!Jsi_StrIsAlnum(name))\n            name = NULL;\n    } else if (Jsi_ValueIsFunction(interp, vname)) {\n        f = vname->d.obj->d.fobj->func;\n        name = f->name;\n    }\n    if (!name) \n        rc = Jsi_LogError(\"invalid or missing package name\");\n    else {\n        Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 1);\n        if (v && jsi_GetVerFromVal(interp, v, &n, 1) != JSI_OK)\n            return JSI_ERROR;\n        if (rc == JSI_OK) {\n            Jsi_PkgOpts po = {};\n            po.info = Jsi_ValueArrayIndex(interp, args, 2);\n            rc = Jsi_PkgProvideEx(interp, name, n, NULL, &po);\n        }\n    }\n    Jsi_DSFree(&dStr);\n    if (rc == JSI_OK && f)\n        f->pkg = jsi_PkgGet(interp, name);\n    return rc;\n}\n\nJsi_RC jsi_NoOpCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    return JSI_OK;\n}\n\nstatic Jsi_RC isNaNCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Number n;\n    int rc = 0;\n    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n    if (Jsi_ValueIsBoolean(interp, v))\n        rc = 0;\n    else if (!Jsi_ValueIsNumber(interp, v) || Jsi_GetDoubleFromValue(interp, v, &n) != JSI_OK || Jsi_NumberIsNaN(n))\n        rc = 1;\n    Jsi_ValueMakeBool(interp, ret, rc);\n    return JSI_OK;\n}\nstatic Jsi_RC isFiniteCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Number n;\n    int rc = 1;\n    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n    if (!Jsi_ValueIsNumber(interp, v) || Jsi_GetDoubleFromValue(interp, v, &n) != JSI_OK || !Jsi_NumberIsFinite(n))\n        rc = 0;\n    Jsi_ValueMakeBool(interp, ret, rc);\n    return JSI_OK;\n}\n\n/* Returns a url-encoded version of str */\n/* IMPORTANT: be sure to free() the returned string after use */\nstatic char *url_encode(char *str) {\n  char *pstr = str, *buf = (char*)Jsi_Malloc(Jsi_Strlen(str) * 3 + 1), *pbuf = buf;\n  while (*pstr) {\n    if (isalnum(*pstr) || *pstr == '-' || *pstr == '_' || *pstr == '.' || *pstr == '~') \n      *pbuf++ = *pstr;\n    else if (*pstr == ' ') \n      *pbuf++ = '+';\n    else \n      *pbuf++ = '%', *pbuf++ = jsi_toHexChar(*pstr >> 4), *pbuf++ = jsi_toHexChar(*pstr & 15);\n    pstr++;\n  }\n  *pbuf = '\\0';\n  return buf;\n}\n\n/* Returns a url-decoded version of str */\n/* IMPORTANT: be sure to free() the returned string after use */\nstatic char *url_decode(char *str, int *len) {\n  char *pstr = str, *buf = (char*)Jsi_Malloc(Jsi_Strlen(str) + 1), *pbuf = buf;\n  while (*pstr) {\n    if (*pstr == '%') {\n      if (pstr[1] && pstr[2]) {\n        *pbuf++ = jsi_fromHexChar(pstr[1]) << 4 | jsi_fromHexChar(pstr[2]);\n        pstr += 2;\n      }\n    } else if (*pstr == '+') { \n      *pbuf++ = ' ';\n    } else {\n      *pbuf++ = *pstr;\n    }\n    pstr++;\n  }\n  *pbuf = '\\0';\n  *len = (pbuf-buf);\n  return buf;\n}\n\nstatic Jsi_RC EncodeURICmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char *cp, *str = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    cp = url_encode(str);\n    Jsi_ValueMakeString(interp, ret, cp);\n    return JSI_OK;\n}\n\nstatic Jsi_RC DecodeURICmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char *cp, *str = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    int len;\n    cp = url_decode(str, &len);\n    Jsi_ValueMakeBlob(interp, ret, (uchar*)cp, len);\n    return JSI_OK;\n}\n\nstatic Jsi_RC SysSleepCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Number dtim = 1;\n    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n    if (v) {\n        if (Jsi_GetDoubleFromValue(interp, v, &dtim) != JSI_OK) {\n            return JSI_ERROR;\n        }\n    }\n    return Jsi_Sleep(interp, dtim);\n}\n\n\nstatic Jsi_RC SysGetEnvCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    extern char **environ;\n    char *cp;\n    int i;\n    if (interp->isSafe)\n        return Jsi_LogError(\"no getenv in safe mode\");\n    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n    if (v != NULL) {\n        const char *fnam = Jsi_ValueString(interp, v, NULL);\n        if (!fnam) \n            return Jsi_LogError(\"arg1: expected string 'name'\");\n        cp = getenv(fnam);\n        if (cp != NULL) {\n            Jsi_ValueMakeStringDup(interp, ret, cp);\n        }\n        return JSI_OK;\n    }\n   /* Single object containing result members. */\n    Jsi_Value *vres;\n    Jsi_Obj  *ores = Jsi_ObjNew(interp);\n    Jsi_Value *nnv;\n    char *val, nam[JSI_BUFSIZ/2];\n    //Jsi_ObjIncrRefCount(interp, ores);\n    vres = Jsi_ValueMakeObject(interp, NULL, ores);\n    //Jsi_IncrRefCount(interp, vres);\n    \n    for (i=0; ; i++) {\n        int n;\n        cp = environ[i];\n        if (cp == 0 || ((val = Jsi_Strchr(cp, '='))==NULL))\n            break;\n        n = val-cp+1;\n        if (n>=(int)sizeof(nam))\n            n = sizeof(nam)-1;\n        Jsi_Strncpy(nam, cp, n);\n        val = val+1;\n        nnv = Jsi_ValueMakeStringDup(interp, NULL, val);\n        Jsi_ObjInsert(interp, ores, nam, nnv, 0);\n    }\n    Jsi_ValueReplace(interp, ret, vres);\n    return JSI_OK;\n}\n\nstatic Jsi_RC SysSetEnvCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                        Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n    const char *fnam = Jsi_ValueString(interp, v, NULL);\n    Jsi_Value *vv = Jsi_ValueArrayIndex(interp, args, 1);\n    const char *cp = NULL, *fval = (vv?Jsi_ValueString(interp, vv, NULL):NULL);\n    int rc = -1;\n    if (fnam == 0) \n        return Jsi_LogError(\"arg1: expected string 'name'\");\n    if (interp->isSafe)\n        return Jsi_LogError(\"no setenv in safe mode\");\n\n    if (fnam[0] != 0) {\n#ifndef __WIN32\n        if (fval)\n            rc = setenv(fnam, fval, 1);\n        else\n            cp = getenv(fnam);\n#else  /* TODO: win setenv */\n        if (!fval)\n            cp = getenv(fnam);\n        else {\n            char ebuf[JSI_BUFSIZ];\n            snprintf(ebuf, sizeof(ebuf), \"%s=%s\", fnam, fval);\n            rc = _putenv(ebuf);\n        }\n#endif\n    }\n    if (rc != 0) \n        return Jsi_LogError(\"setenv failure: %s = %s\", fnam, fval);\n    if (cp)\n        Jsi_ValueMakeStringDup(interp, ret, cp);\n    return JSI_OK;\n}\n\nstatic Jsi_RC SysGetPidCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                        Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n#ifdef __WIN32\n    return Jsi_LogError(\"unsupported\");\n#else\n    Jsi_Number pid = 0;\n    bool bv = 0;\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);\n    if (arg && Jsi_GetBoolFromValue(interp, arg, &bv) != JSI_OK)\n        return JSI_ERROR;\n    if (bv)\n        pid = (Jsi_Number)getppid();\n    else\n        pid = (Jsi_Number)getpid();\n    Jsi_ValueMakeNumber(interp, ret, pid);\n    return JSI_OK;\n#endif\n}\n\nstatic Jsi_RC SysGetUserCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                        Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[JSI_BUFSIZ];\n    const char* name, *cname;\n#ifdef __WIN32\n    cname = name = getenv(\"USERNAME\");\n#else\n    char tbuf[L_cuserid] = {}, cbuf[L_cuserid] = {};\n    cname = cuserid(cbuf);\n    getlogin_r(tbuf, sizeof(tbuf));\n    name = tbuf;\n#endif\n    if (!cname) cname = \"\";\n    if (!name || !name[0]) name = cname;\n    snprintf(buf, sizeof(buf),\n        \"{uid:%d, gid:%d, uid:%d, guid:%d, pid:%d, pidp:%d, user:\\\"%s\\\", cuserid:\\\"%s\\\"}\",\n#ifdef __WIN32\n        0, 0, 0, 0, 0, 0, name, name);\n#else\n        (int)getuid(), (int)getgid(), (int)geteuid(), getpid(), getppid(), (int)getegid(), name, cname);\n#endif\n    return Jsi_JSONParse(interp, buf, ret, 0);\n}\n\n// Replacement for popen when there is no /bin/sh.  It uses execvp.\nstatic FILE *jsi_popen(char **cmdv, const char *type, int *cpid)\n{\n#ifdef __WIN32\n    return NULL;\n#else\n    int fd[2], pid, find = (*type != 'w' ? 1 : 0);\n    if (!cmdv[0] || pipe(fd)<0)\n        return NULL;\n    pid = fork();\n    if (pid<0) {\n        close(fd[0]);\n        close(fd[1]);\n        return NULL;\n    }\n\n    if (pid) {\n        *cpid = pid;\n        close(fd[find]);\n        return fdopen(fd[1-find], type);\n    }\n    if (fd[find] != find) {\n        dup2(fd[find], find);\n        close(fd[find]);\n    }\n    close(fd[1-find]);\n    execvp(cmdv[0], cmdv);\n    //execlp(\"sh\", \"sh\", \"-c\", cmd, NULL);\n    _exit(127);\n#endif\n}\n\nstatic int jsi_pclose(FILE *fp, int cpid)\n{\n#ifdef __WIN32\n    return -1;\n#else\n    pid_t pid;\n    int pstat;\n    fclose(fp);\n    do {\n        pid = waitpid(cpid, &pstat, 0);\n    } while (pid == -1 && errno == EINTR);\n    return (pid == -1 ? -1 : pstat);\n#endif\n}\n\n\ntypedef struct {\n    Jsi_Value* inputStr;\n    Jsi_Value* chdir;\n    bool bg;\n    bool noError;\n    bool trim;\n    bool retCode;\n    bool retAll;\n    bool retval;\n    bool noRedir;\n    bool noShell;\n} ExecOpts;\n\nstatic Jsi_OptionSpec ExecOptions[] = {\n    JSI_OPT(BOOL,   ExecOpts, bg,       .help=\"Run command in background using system() and return OS code\" ),\n    JSI_OPT(STRING, ExecOpts, chdir,    .help=\"Change to directory\" ),\n    JSI_OPT(STRING, ExecOpts, inputStr, .help=\"Use string as input and return OS code\" ),\n    JSI_OPT(BOOL,   ExecOpts, noError,  .help=\"Suppress all OS errors\" ),\n    JSI_OPT(BOOL,   ExecOpts, noRedir,  .help=\"Disable redirect and shell escapes in command\" ),\n    JSI_OPT(BOOL,   ExecOpts, noShell,  .help=\"Do not use native popen which invokes via /bin/sh\" ),\n    JSI_OPT(BOOL,   ExecOpts, trim,     .help=\"Trim trailing whitespace from output\" ),\n    JSI_OPT(BOOL,   ExecOpts, retAll,   .help=\"Return the OS return code and data as an object\" ),\n    JSI_OPT(BOOL,   ExecOpts, retCode,  .help=\"Return only the OS return code\" ),\n    JSI_OPT_END(ExecOpts, .help=\"Exec options\")\n};\n\n#define FN_exec JSI_INFO(\"\\\nIf the command ends with '&', set the 'bg' option to true.\\n\\\nThe second argument can be a string, which is the same as setting the 'inputStr' option.\\n\\\nBy default, returns the string output, unless the 'bg', 'inputStr', 'retCode' or 'retAll' options are used\")\nJsi_RC jsi_SysExecCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr, bool restricted)\n{\n    int n, exitCode = 0, hasopts = 0, sLen, sLen2 = 0;\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);\n    const char *cp2=NULL, *cp = Jsi_ValueString(interp, arg, &sLen);\n    FILE *fp = NULL;\n    if (restricted && Jsi_ValueGetLength(interp, args)>1)\n        return Jsi_LogError(\"restricted may not have args\");\n    if (interp->isSafe) {\n        int rc =0, no = 1;\n        if (restricted)\n            no = 0;\n        else if (interp->safeExecPattern && cp) {\n            Jsi_Value *seq = Jsi_ValueNew1(interp);\n            Jsi_RC rrc = jsi_RegExpValueNew(interp, interp->safeExecPattern, seq);\n            if (rrc == JSI_OK && Jsi_RegExpMatch(interp, seq, cp, &rc, NULL)!=JSI_OK)\n                rrc = JSI_ERROR;\n            Jsi_DecrRefCount(interp, seq);\n            if (rrc != JSI_OK)\n                return Jsi_LogError(\"invalid regex\");\n            if (rc)\n                no = 0;\n            restricted = 1;\n        }\n        if (no)\n            return Jsi_LogError(\"no exec in safe mode\");\n    }\n    Jsi_RC rc = JSI_OK;\n    Jsi_Value *opt = Jsi_ValueArrayIndex(interp, args, 1);\n    Jsi_DString dStr = {}, cStr = {};\n    ExecOpts edata = {};\n    edata.retval = 1;\n    \n    if (opt != NULL) {\n        if (opt->vt == JSI_VT_OBJECT && opt->d.obj->ot == JSI_OT_OBJECT) {\n            hasopts = 1;\n            if (Jsi_OptionsProcess(interp, ExecOptions, &edata, opt, 0) < 0) {\n                return JSI_ERROR;\n            }\n            if (edata.retCode)\n                edata.retval = 0;\n        } else if (Jsi_ValueString(interp, opt, NULL)) {\n            edata.inputStr = opt;\n        } else \n            return Jsi_LogError(\"arg 2: expected options or string 'input'?\");\n    }\n    if (restricted || edata.noRedir) {\n        // Sanity check command string to disallow shell escapes, redirection, etc.\n        if (strcspn(cp, \"<>|;&$`=\") != strlen(cp))\n            return Jsi_LogError(\"restricted chars in exec string: %s\", cp);\n    }\n    int isbg = 0, ec = 0;\n    const char *ocd = NULL, *cd = (edata.chdir ? Jsi_ValueString(interp, edata.chdir, NULL) : NULL);\n    if (cd && interp->isSafe) {\n        cd = NULL;\n        rc = Jsi_LogError(\"no chdir in safe mode\");\n        goto done;        \n    }\n    if (cd) {\n        ocd = Jsi_GetCwd(interp, &cStr);\n        if (!Jsi_FSNative(interp, edata.chdir) || Jsi_Chdir(interp, edata.chdir)<0) {\n            cd = NULL;\n            rc = Jsi_LogError(\"chdir failed\");\n            goto done;        \n        }\n    }\n    if (edata.bg || (isbg=((sLen>1 && cp[sLen-1] == '&')))) {\n        if (edata.inputStr) {\n            rc = Jsi_LogError(\"input string may not used with bg\");\n            goto done;\n        }\n        if (edata.noShell) {\n            rc = Jsi_LogError(\"noShell may not used with bg\");\n            goto done;\n        }\n        if (!isbg) {\n            Jsi_DSAppend(&dStr, cp, \" &\", NULL);\n            cp = Jsi_DSValue(&dStr);\n        }\n        edata.bg = 1;\n        edata.retCode = 1;\n        edata.retval = 0;\n        exitCode = ((ec=system(cp))>>8);\n        Jsi_DSSetLength(&dStr, 0);\n    } else {\n        const char *type = (edata.inputStr?\"w\":\"r\");\n        bool native = !edata.noShell;\n#ifdef __WIN32\n        native = 1;\n#else\n        if (native)\n            native = (access(\"/bin/sh\", X_OK)==0);\n#endif\n        int cpid;\n        if (native)\n            fp = popen(cp, type);\n        else {\n            int argc;\n            char **argv;\n            Jsi_DString pStr = {};\n            Jsi_SplitStr(cp, &argc, &argv, NULL, &pStr);\n            fp = jsi_popen(argv, type, &cpid);\n            Jsi_DSFree(&pStr);\n        }\n        if (!fp) \n            exitCode = errno;\n        else {\n            if (edata.inputStr) {\n                edata.retCode = 1;\n                edata.retval = 0;\n                cp2 = Jsi_ValueString(interp, edata.inputStr, &sLen2);\n                while ((n=fwrite(cp2, 1, sLen2, fp))>0) {\n                    sLen2 -= n;\n                }\n            } else {\n                char buf[JSI_BUFSIZ];;\n                while ((n=fread(buf, 1, sizeof(buf), fp))>0)\n                    Jsi_DSAppendLen(&dStr, buf, n);\n            }\n            if (native)\n                exitCode = ((ec=pclose(fp))>>8);\n            else\n                exitCode = ((ec=jsi_pclose(fp, cpid))>>8);\n        }\n    }\n    if (exitCode && edata.noError==0 && edata.retCode==0 && edata.retAll==0) {\n        if (exitCode==ENOENT)\n            Jsi_LogError(\"command not found: %s\", cp);\n        else\n            Jsi_LogError(\"program exit code (%x)\", exitCode);\n        rc = JSI_ERROR;\n    }\n    if (edata.trim) {\n        char *cp = Jsi_DSValue(&dStr);\n        int iLen = Jsi_DSLength(&dStr);\n        while (iLen>0 && isspace(cp[iLen-1]))\n            iLen--;\n        cp[iLen] = 0;\n        Jsi_DSSetLength(&dStr, iLen);\n    }\n    if (edata.retAll) {\n        Jsi_Obj *nobj = Jsi_ObjNew(interp);\n        Jsi_ValueMakeObject(interp, ret, nobj);\n        Jsi_Value *cval = Jsi_ValueNewNumber(interp, (Jsi_Number)exitCode);\n        Jsi_ObjInsert(interp, nobj, \"code\", cval, 0);\n        cval = Jsi_ValueNewNumber(interp, (Jsi_Number)(ec&0xff));\n        Jsi_ObjInsert(interp, nobj, \"status\", cval, 0);\n        cval = Jsi_ValueNew(interp);\n        Jsi_ValueFromDS(interp, &dStr, &cval);\n        Jsi_ObjInsert(interp, nobj, \"data\", cval, 0);\n        \n    } else if (edata.retval)\n        Jsi_ValueFromDS(interp, &dStr, ret);\n    else {\n        Jsi_DSFree(&dStr);\n        Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)exitCode);\n    }\ndone:\n    if (cd && ocd) {\n        Jsi_Value *oc = Jsi_ValueNewStringDup(interp, ocd);\n        Jsi_IncrRefCount(interp, oc);\n        Jsi_Chdir(interp, oc);\n        Jsi_DecrRefCount(interp, oc);\n    }\n    Jsi_DSFree(&cStr);\n    if (hasopts)\n        Jsi_OptionsFree(interp, ExecOptions, &edata, 0);\n    return rc;\n}\n\nstatic Jsi_RC SysExecCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    return jsi_SysExecCmd(interp, args, _this, ret, funcPtr, false);\n}\n\nvoid jsi_SysPutsCmdPrefix(Jsi_Interp *interp, jsi_LogOptions *popts,Jsi_DString *dStr, int* quote, const char **fnPtr) {\n    int didx = 0;\n    const char *cp;\n    const char *fn = interp->curIp->fname;\n    if (fn && !popts->full && (cp=Jsi_Strrchr(fn, '/')))\n        fn = cp +1;\n    if (popts->time || (didx=popts->date)) {\n        if (popts->time && popts->date)\n            didx = 2;\n        const char *fmts[3] = { \"%H:%M:%S.%f\", \"%F\", \"%F %H:%M:%S.%f\" },\n            *fmt = (popts->timeFmt?popts->timeFmt:fmts[didx]);\n        Jsi_DatetimeFormat(interp, Jsi_DateTime(), fmt, popts->isUTC, dStr);\n        Jsi_DSAppend(dStr, \", \", NULL);\n    }\n    if (popts->file && popts->before) {\n        Jsi_DSPrintf(dStr, \"%s:%d: \", fn, interp->curIp->Line);\n        if (interp->curIp->Line<1000)\n            Jsi_DSAppend(dStr, (interp->curIp->Line<10?\"  \":\" \"), NULL);\n    }\n    if (Jsi_DSLength(dStr)) {\n        *quote = 1;\n    }\n    if (*quote)\n        Jsi_DSAppendLen(dStr, \"\\\"\", 1);\n    if (fnPtr)\n        *fnPtr = fn;\n\n}\n\nstatic Jsi_RC SysPutsCmd_(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret,\n    Jsi_Func *funcPtr, bool stdErr, jsi_LogOptions *popts, const char *argStr, bool conLog)\n{\n    int i, cnt = 0, quote = (popts->file);\n    const char *fn = NULL;\n    Jsi_DString dStr, oStr;\n    if (interp->noStderr)\n        stdErr = 0;\n    Jsi_Chan *chan = (stdErr ? jsi_Stderr : jsi_Stdout);\n    Jsi_DSInit(&dStr);\n    Jsi_DSInit(&oStr);\n    if (popts->chan && !stdErr) {\n        Jsi_UserObj *uobj = popts->chan->d.obj->d.uobj;\n        jsi_UserObjToName(interp, uobj, &dStr);\n        Jsi_Channel nchan = Jsi_FSNameToChannel(interp, Jsi_DSValue(&dStr));\n        if (nchan)\n            chan = nchan;\n        Jsi_DSSetLength(&dStr, 0);\n    }\n    if (interp->curIp)\n        jsi_SysPutsCmdPrefix(interp, popts, &dStr, &quote, &fn);\n    if (!args)\n        Jsi_DSAppend(&dStr, argStr?argStr:\"\", NULL);\n    else {\n        int argc = Jsi_ValueGetLength(interp, args);\n        if (conLog && argc>0 && (argStr=Jsi_ValueString(interp, Jsi_ValueArrayIndex(interp, args, 0), NULL))) {\n            if ((!interp->logOpts.Error && jsi_PrefixMatch(argStr, \"ERROR: \")) \n                || (!interp->logOpts.Warn && jsi_PrefixMatch(argStr, \"WARN: \")) \n                || (!interp->logOpts.Info && jsi_PrefixMatch(argStr, \"INFO: \")))\n                goto done;\n        }\n \n        for (i = 0; i < argc; ++i) {\n            Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, i);\n            if (!v) continue;\n            int len = 0;\n            if (cnt++)\n                Jsi_DSAppendLen(&dStr, \" \", 1);\n            const char *cp = Jsi_ValueString(interp, v, &len);\n            if (cp) {\n                Jsi_DSAppendLen(&dStr, cp, len);\n                continue;\n            }\n            Jsi_DSSetLength(&oStr, 0);\n            Jsi_ValueGetDString(interp, v, &oStr, 1);\n            Jsi_DSAppend(&dStr, Jsi_DSValue(&oStr), NULL);\n        }\n    }\n    if (quote)\n        Jsi_DSAppendLen(&dStr, \"\\\"\", 1);\n    if (popts->file && !popts->before) {\n        Jsi_DSPrintf(&dStr, \", %s:%d\", fn?fn:\"\", interp->curIp->Line);\n    }\n    if (popts->func) {\n        // Note: could have looked this up on the stackFrame.\n        if (!interp->prevActiveFunc || !((fn=interp->prevActiveFunc->name)))\n            fn = \"\";\n        Jsi_DSPrintf(&dStr, \", %s%s\", fn[0]?fn:\"\", fn[0]?\"()\":\"\");\n    }\n    Jsi_DSAppend(&dStr, \"\\n\", NULL);\n    Jsi_Puts(interp, chan, Jsi_DSValue(&dStr), Jsi_DSLength(&dStr));\ndone:\n    Jsi_DSFree(&dStr);\n    Jsi_DSFree(&oStr);\n    return JSI_OK;\n}\n\nstatic Jsi_RC SysPrintfCmd_(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret,\n    Jsi_Func *funcPtr, Jsi_Channel chan)\n{\n    Jsi_DString dStr;\n    Jsi_RC rc = Jsi_FormatString(interp, args, &dStr);\n    if (rc != JSI_OK)\n        return rc;\n    const char *cp;\n    int len = Jsi_DSLength(&dStr);\n    Jsi_Puts(interp, chan, cp = Jsi_DSValue(&dStr), len);\n    if (len>0 && cp[len-1]!='\\n')\n        Jsi_Flush(interp, chan);\n    Jsi_DSFree(&dStr);\n    return rc;\n}\n\nstatic Jsi_RC SysPrintfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret,\n    Jsi_Func *funcPtr)\n{\n    return SysPrintfCmd_(interp, args, _this, ret, funcPtr, jsi_Stdout);\n}\n\nstatic Jsi_RC consolePrintfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret,\n    Jsi_Func *funcPtr)\n{\n    return SysPrintfCmd_(interp, args, _this, ret, funcPtr, jsi_Stderr);\n}\n\nstatic Jsi_RC consoleLogCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret,\n    Jsi_Func *funcPtr)\n{\n    int conLog = ((!interp->logOpts.Error) || (!interp->logOpts.Warn) || (!interp->logOpts.Info));\n    return SysPutsCmd_(interp, args, _this, ret, funcPtr, 1, &interp->logOpts, NULL, conLog);\n}\n\nstatic Jsi_RC consolePutsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret,\n    Jsi_Func *funcPtr)\n{\n    jsi_LogOptions lo = {};\n    return SysPutsCmd_(interp, args, _this, ret, funcPtr, 1, (interp->tracePuts?&interp->logOpts:&lo), NULL, 0);\n}\n\n#define FN_puts JSI_INFO(\"\\\nEach argument is quoted.  Use Interp.logOpts to control source line and/or timestamps output.\")\nstatic Jsi_RC SysPutsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret,\n    Jsi_Func *funcPtr)\n{\n    jsi_LogOptions lo = {};\n    return SysPutsCmd_(interp, args, _this, ret, funcPtr, 0, (interp->tracePuts?&interp->logOpts:&lo), NULL, 0);\n}\n\nstatic Jsi_RC SysLogCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret,\n    Jsi_Func *funcPtr)\n{\n    return SysPutsCmd_(interp, args, _this, ret, funcPtr, 0, &interp->logOpts, NULL, 0);\n}\n\ntypedef struct {\n    jsi_AssertMode mode;\n    bool noStderr;\n} AssertData;\n\nstatic Jsi_OptionSpec AssertOptions[] = {\n    JSI_OPT(CUSTOM, AssertData, mode,     .help=\"Action when assertion fails. Default from Interp.assertMode\", .flags=0, .custom=Jsi_Opt_SwitchEnum, .data=jsi_AssertModeStrs ),\n    JSI_OPT(BOOL,   AssertData, noStderr, .help=\"Logged msg to stdout. Default from Interp.noStderr\" ),\n    JSI_OPT_END(AssertData, .help=\"Options for assert command\")\n};\n\nstatic char *jsi_GetCurPSLine(Jsi_Interp *interp) {\n    char *cp = NULL;\n    int line = interp->curIp->Line;\n    if (interp->framePtr->ps &&  (cp=interp->framePtr->ps->lexer->d.str))\n        while (line-- > 1)\n            if ((cp = Jsi_Strchr(cp, '\\n'))) cp++;\n    return cp;\n}\n    \n#define FN_assert JSI_INFO(\"\\\nAssert does nothing by default, but can be \\\nenabled with \\\"use assert\\\" or setting Interp.asserts.\")\nJsi_RC jsi_AssertCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (!interp->asserts)\n        return JSI_OK;\n    int rc = 0;\n    Jsi_RC rv = JSI_OK;\n    Jsi_Number d;\n    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n    const char *msg = Jsi_ValueArrayIndexToStr(interp, args, 1, NULL);\n    Jsi_Value *opts = Jsi_ValueArrayIndex(interp, args, 2);\n    //int hasopts = 0;\n    bool b;\n    AssertData udata = {\n        .mode=interp->assertMode,\n        .noStderr=interp->noStderr\n    };\n    \n    if (opts != NULL) {\n        if (opts->vt == JSI_VT_OBJECT) {\n            //hasopts = 1;\n            if (Jsi_OptionsProcess(interp, AssertOptions, &udata, opts, 0) < 0) {\n                return JSI_ERROR;\n            }\n        } else //if (opts->vt != JSI_VT_NULL)\n            return Jsi_LogError(\"arg 3: expected object 'options'\");\n    }\n\n    if (Jsi_ValueGetNumber(interp,v, &d) == JSI_OK)\n        rc = (int)d;\n    else if (Jsi_ValueGetBoolean(interp,v, &b) == JSI_OK)\n        rc = b;\n    else if (Jsi_ValueIsFunction(interp, v)) {\n        if (!msg) {\n        }\n        Jsi_Value *vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, NULL, 0, 0));\n        Jsi_IncrRefCount(interp, vpargs);\n        rc = Jsi_FunctionInvoke(interp, v, vpargs, ret, NULL);\n        Jsi_DecrRefCount(interp, vpargs);\n        if (rc != JSI_OK)\n            return JSI_OK;\n        bool b;\n        if (Jsi_ValueGetNumber(interp, *ret, &d) == JSI_OK)\n            rc = (int)d;\n        else if (Jsi_ValueGetBoolean(interp, *ret, &b) == JSI_OK)\n            rc = b;\n        else \n            return Jsi_LogError(\"invalid function assert\");\n    } else \n        return Jsi_LogError(\"invalid assert\");\n    if (rc == 0) {\n        char mbuf[1024];\n        mbuf[0] = 0;\n        if (!msg) {\n            char *ce, *cp = jsi_GetCurPSLine(interp);\n            if (cp) {\n                cp = Jsi_Strstr(cp, \"assert(\");\n                while (cp && *cp && isspace(*cp)) cp++;\n                if (cp) {\n                    Jsi_Strncpy(mbuf, cp, sizeof(mbuf)-1);\n                    mbuf[sizeof(mbuf)-1] = 0;\n                    ce=Jsi_Strstr(mbuf, \");\");\n                    if (ce) {\n                        ce[1] = 0;\n                        msg = mbuf;\n                    }\n                }\n            }\n            if (!msg)\n                msg = \"ASSERT\";\n        }\n        //Jsi_ValueDup2(interp, ret, v);\n        if (udata.mode != jsi_AssertModeThrow) {\n            Jsi_DString dStr;\n            jsi_LogOptions lo = {}, *loPtr = ((udata.mode==jsi_AssertModeLog || interp->tracePuts)?&interp->logOpts:&lo);\n            Jsi_DSInit(&dStr);\n            const char *imsg = Jsi_DSAppend(&dStr, msg, NULL);\n            SysPutsCmd_(interp, NULL, _this, ret, funcPtr, !udata.noStderr, loPtr, imsg, 0);\n            Jsi_DSFree(&dStr);\n        } else\n            rv = Jsi_LogError(\"%s\", msg);\n    }\n    Jsi_ValueMakeUndef(interp, ret);\n    return rv;\n}\n\ntypedef struct {\n    bool utc, secs, iso;\n    const char *fmt;\n} DateOpts;\n\nstatic Jsi_OptionSpec DateOptions[] = {\n    JSI_OPT(BOOL,   DateOpts, secs, .help=\"Time is seconds (out for parse, in for format)\" ),\n    JSI_OPT(STRKEY, DateOpts, fmt, .help=\"Format string for time\" ),\n    JSI_OPT(BOOL,   DateOpts, iso, .help=\"ISO fmt plus milliseconds ie: %FT%T.%f\" ),\n    JSI_OPT(BOOL,   DateOpts, utc, .help=\"Time is utc (in for parse, out for format)\" ),\n    JSI_OPT_END(DateOpts, .help=\"Date options\")\n};\n\nstatic const char *timeFmts[] = {\n    \"%Y-%m-%d %H:%M:%S\",\n    \"%Y-%m-%dT%H:%M:%S\",\n    \"%Y-%m-%d %H:%M\",\n    \"%Y-%m-%dT%H:%M\",\n    \"%Y-%m-%d\",\n    \"%H:%M:%S\",\n    \"%H:%M\",\n    \"%c\",\n    NULL\n};\n\nJsi_RC Jsi_DatetimeParse(Jsi_Interp *interp, const char *str, const char *fmt, int isUtc, Jsi_Number *datePtr, bool noMsg)\n{\n    char fmt1[JSI_BUFSIZ];\n    const char *rv = NULL;;\n    Jsi_Number n = -1;\n    int j = 0, tofs = 0;\n    Jsi_RC rc = JSI_OK;\n    Jsi_Number ms = 0;\n    struct tm tm = {};\n    tm.tm_isdst = -1;\n    time_t t;\n    if (!str || !Jsi_Strcmp(\"now\", str)) {\n        struct timeval tv;\n        gettimeofday(&tv, NULL);\n        n = tv.tv_sec*1000.0 + (tv.tv_usec)/1000.0;\n        if (isUtc) {\n            time_t t = time(NULL);\n            struct tm lt = {0};\n            lt.tm_isdst = -1;\n            localtime_r(&t, &lt);\n            \n#ifdef __WIN32\n            {\n                time_t tt = 0;\n                n += (int)time(&tt);\n            }\n#else\n            n += (lt.tm_gmtoff)*1000.0;\n#endif\n        }\n        if (datePtr)\n            *datePtr = n;\n        return rc;\n    }\n    if (fmt && fmt[0]) {\n        const char *efp = Jsi_Strstr(fmt, \"%f\");\n        if (efp && efp > fmt && efp[-1] != '%' && (Jsi_Strlen(fmt)+10)<(int)sizeof(fmt1)) {\n            snprintf(fmt1, sizeof(fmt1), \"%.*s:%%S.\", (int)(efp-fmt), fmt);\n            fmt = fmt1;\n        }\n        rv = strptime(str, fmt, &tm);\n    } else {\n        if (fmt) j++;\n        while (timeFmts[j]) {\n            rv = strptime(str, timeFmts[j], &tm);\n            if (rv != NULL)\n                break;\n            j++;\n        }\n    }\n    if (!rv) {\n        rc = JSI_ERROR;\n        if (!noMsg)\n            Jsi_LogError(\"datetime parse failed\");\n    } else {\n        if (*rv == '.' && isdigit(rv[1]) && isdigit(rv[2]) && isdigit(rv[3])) {\n            ms = atof(rv+1);\n            rv += 4;\n        }\n#if 0\n        if (!isUtc) {\n#ifdef __WIN32\n#ifdef JSI_IS64BIT\n            t = internal_timegm(&tm);\n#else\n            t = _mkgmtime(&tm); // TODO: undefined in mingw 64\n#endif\n#else\n            t = timegm(&tm);\n#endif\n        } else\n#endif\n        {\n            int th, ts;\n            char ss[3];\n            t = mktime(&tm);\n            if (rv[0] == ' ') rv++;\n            if (rv[0] && sscanf(rv, \"%[+-]%2d:%2d\", ss, &th, &ts) == 3) {\n                int sign = (rv[0] == '-' ? 1 : -1);\n                tofs = (3600*th+60*ts)*sign;\n            }\n            if (isUtc) {\n#ifdef __WIN32\n                time_t tt = 0;\n                tofs += (int)time(&tt);\n#else\n                tofs += tm.tm_gmtoff;\n#endif\n            }\n        }\n        if (t==-1) {\n            rc = JSI_ERROR;\n            if (!noMsg)\n                Jsi_LogError(\"mktime failed\");\n        }\n        n = (Jsi_Number)(t+tofs)*1000.0 + ms;\n    }\n    if (rc == JSI_OK && datePtr)\n        *datePtr = n;\n    return rc;\n}\n\nJsi_RC Jsi_DatetimeFormat(Jsi_Interp *interp, Jsi_Number num, const char *fmt, int isUtc, Jsi_DString *dStr)\n{\n    char buf[JSI_BUFSIZ], fmt1[JSI_BUFSIZ], fmt2[JSI_BUFSIZ];\n    time_t tt;\n    Jsi_RC rc = JSI_OK;\n    fmt2[0] = 0;\n    \n    tt = (time_t)(num/1000);\n    if (fmt==NULL)\n        fmt = timeFmts[0];\n    else if (*fmt == 0) {\n        if (!isUtc)\n            fmt = timeFmts[1];\n        else\n            fmt = timeFmts[2];\n    }\n    \n    const char *efp = Jsi_Strstr(fmt, \"%f\");\n    if (efp && efp > fmt && efp[-1] != '%' && ((efp-fmt)+10)<(int)sizeof(fmt1)) {\n        int elen = (efp-fmt)+1;\n        Jsi_Strncpy(fmt1, fmt, elen);\n        Jsi_Strcpy(fmt1+elen, \"%S.\");\n        Jsi_Strcpy(fmt2, efp+2);\n        fmt = fmt1;\n    } else\n        efp = NULL;\n    struct tm tm = {}, *tmp=&tm;\n    tm.tm_isdst = -1;\n#ifdef __WIN32\n    if (isUtc)\n        tmp = gmtime(&tt);\n    else\n        tmp = localtime(&tt);\n#else\n    if (isUtc)\n        gmtime_r(&tt, &tm);\n    else\n        localtime_r(&tt, &tm);\n#endif\n    buf[0] = 0;\n    int rr = strftime(buf, sizeof(buf), fmt, tmp);\n       \n    if (rr<=0)\n        rc = Jsi_LogError(\"time format error: %d\", (int)tt);\n    else {\n        Jsi_DSAppendLen(dStr, buf, -1);\n        if (efp) {\n            snprintf(buf, sizeof(buf), \"%3.3d\", (int)(((Jsi_Wide)num)%1000));\n            Jsi_DSAppendLen(dStr, buf[1]=='.'?buf+2:buf, -1);\n        }\n    }\n    if (rc == JSI_OK && fmt2[0]) {\n        buf[0] = 0;\n        int rr = strftime(buf, sizeof(buf), fmt2, tmp);\n           \n        if (rr<=0)\n            rc = Jsi_LogError(\"time format error\");\n        else\n            Jsi_DSAppendLen(dStr, buf, -1);\n    }\n    return rc;\n}\n\n/* Get time in milliseconds since Jan 1, 1970 */\nJsi_Number Jsi_DateTime(void)\n{\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    Jsi_Number num = ((Jsi_Number)tv.tv_sec*1000.0 + (Jsi_Number)tv.tv_usec/1000.0);\n    return num;\n}\n\ndouble jsi_GetTimestamp(void) {\n#ifdef __WIN32\n    return Jsi_DateTime()/1000;\n#else\n    struct timespec tv;\n    clock_gettime(CLOCK_MONOTONIC, &tv);\n    return (double)tv.tv_sec + (double)tv.tv_nsec/1000000000.0;\n#endif\n}\n\n\nstatic Jsi_RC DateStrptimeCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    const char *str = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    Jsi_Value *opt = Jsi_ValueArrayIndex(interp, args, 1);\n    Jsi_Number w = 0;\n    int isOpt = 0;\n    DateOpts opts = {};\n    const char *fmt = NULL;\n    if (opt != NULL && opt->vt != JSI_VT_NULL && !(fmt = Jsi_ValueString(interp, opt, NULL))) {\n        if (Jsi_OptionsProcess(interp, DateOptions, &opts, opt, 0) < 0) {\n            return JSI_ERROR;\n        }\n        isOpt = 1;\n        fmt = opts.fmt;\n    }\n    if (!str || !*str)\n        str = \"now\";\n    Jsi_RC rc = Jsi_DatetimeParse(interp, str, fmt, opts.utc, &w, true);\n    if (rc != JSI_OK) {\n        Jsi_ValueDup2(interp, ret, interp->NaNValue);\n        rc = JSI_OK;\n    } else {\n        if (opts.secs)\n            w = (Jsi_Number)((Jsi_Wide)(w/1000));\n        Jsi_ValueMakeNumber(interp, ret, w);\n    }\n    if (isOpt)\n        Jsi_OptionsFree(interp, DateOptions, &opts, 0);\n    return rc;\n}\n\n#define FN_strftime JSI_INFO(\"\\\nNull or no value will use current time.\")\nstatic Jsi_RC DateStrftimeCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Value* val = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_Value* opt = Jsi_ValueArrayIndex(interp, args, 1);\n    const char *fmt = NULL;//, *cp = NULL;\n    DateOpts opts = {};\n    Jsi_Number num;\n    int isOpt = 0;\n    Jsi_RC rc = JSI_OK;\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    \n    if (val==NULL || Jsi_ValueIsNull(interp, val)) {\n        //num = 1000.0 * (Jsi_Number)time(NULL);\n        struct timeval tv;\n        gettimeofday(&tv, NULL);\n        num = tv.tv_sec*1000LL + ((Jsi_Wide)tv.tv_usec)/1000LL;\n\n   /* } else if ((cp=Jsi_ValueString(interp, val, NULL))) {*/\n        /* Handle below */\n    } else if (Jsi_GetDoubleFromValue(interp, val, &num) != JSI_OK)\n        return JSI_ERROR;\n        \n    if (opt != NULL && opt->vt != JSI_VT_NULL && !(fmt = Jsi_ValueString(interp, opt, NULL))) {\n        if (Jsi_OptionsProcess(interp, DateOptions, &opts, opt, 0) < 0) {\n            return JSI_ERROR;\n        }\n        isOpt = 1;\n        fmt = opts.fmt;\n        if (opts.iso) {\n            if (fmt)\n                return Jsi_LogError(\"Do not use both iso and fmt\");\n            fmt = \"%FT%T.%f\";\n        }\n    }\n    const char *errMsg = \"time format error\";\n/*    if (cp) {\n        if (isdigit(*cp))\n            rc = Jsi_GetDouble(interp, cp, &num);\n        else {\n            if (Jsi_Strcmp(cp,\"now\")==0) {\n                num = Jsi_DateTime();\n            } else {\n                rc = JSI_ERROR;\n                errMsg = \"allowable strings are 'now' or digits\";\n            }\n        }\n    }*/\n    if (rc == JSI_OK) {\n        if (opts.secs)\n            num = (Jsi_Number)((Jsi_Wide)(num*1000));\n        rc = Jsi_DatetimeFormat(interp, num, fmt, opts.utc, &dStr);\n    }\n    if (rc != JSI_OK)\n        Jsi_LogError(\"%s\", errMsg);\n    else\n        Jsi_ValueFromDS(interp, &dStr, ret);\n    if (isOpt)\n        Jsi_OptionsFree(interp, DateOptions, &opts, 0);\n    Jsi_DSFree(&dStr);\n    return rc;\n}\n\n#define FN_infovars JSI_INFO(\"\\\nReturns all values, data or function.\")\nstatic Jsi_RC InfoVarsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char *key;\n    int n, curlen = 0, isreg = 0, isobj = 0;\n    Jsi_HashEntry *hPtr;\n    Jsi_HashSearch search;\n    Jsi_Value *v;\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);\n    const char *name = NULL;\n\n    if (arg) {\n        if (arg->vt == JSI_VT_STRING)\n            name = arg->d.s.str;\n        else if (arg->vt == JSI_VT_OBJECT) {\n            switch (arg->d.obj->ot) {\n                case JSI_OT_STRING: name = arg->d.obj->d.s.str; break;\n                case JSI_OT_REGEXP: isreg = 1; break;\n                case JSI_OT_FUNCTION:\n                case JSI_OT_OBJECT: isobj = 1; break;\n                default: return Jsi_LogError(\"bad type\");\n            }\n        } else\n            return Jsi_LogError(\"bad type\");;\n    }\n    Jsi_Obj *nobj = Jsi_ObjNew(interp);\n    if (name)\n        Jsi_ValueMakeObject(interp, ret, nobj);\n    else\n        Jsi_ValueMakeArrayObject(interp, ret, nobj);\n    if (isobj) {\n        Jsi_TreeEntry* tPtr;\n        Jsi_TreeSearch search;\n        for (tPtr = Jsi_TreeSearchFirst(arg->d.obj->tree, &search, 0, NULL);\n            tPtr; tPtr = Jsi_TreeSearchNext(&search)) {\n            v = (Jsi_Value*)Jsi_TreeValueGet(tPtr);\n            if (v==NULL || Jsi_ValueIsFunction(interp, v)) continue;\n    \n            n = curlen++;\n            key = (char*)Jsi_TreeKeyGet(tPtr);\n            Jsi_ObjArraySet(interp, nobj, Jsi_ValueNewStringKey(interp, key), n);\n        }\n        Jsi_TreeSearchDone(&search);\n        return JSI_OK;\n    }\n    for (hPtr = Jsi_HashSearchFirst(interp->varTbl, &search);\n        hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {\n        if (Jsi_HashValueGet(hPtr))\n            continue;\n        key = (char*)Jsi_HashKeyGet(hPtr);\n        if (name) {\n            if (Jsi_Strcmp(name,key))\n                continue;\n            v = Jsi_VarLookup(interp, key);\n            Jsi_ObjInsert(interp, nobj, \"type\", Jsi_ValueNewStringKey(interp,Jsi_ValueTypeStr(interp, v)),0);\n            return JSI_OK;\n        }\n        if (isreg) {\n            int ismat;\n            Jsi_RegExpMatch(interp, arg, key, &ismat, NULL);\n            if (!ismat)\n                continue;\n        }\n        n = curlen++;\n        Jsi_ObjArraySet(interp, nobj, Jsi_ValueNewStringKey(interp, key), n);\n    }\n    return JSI_OK;\n}\n\nstatic Jsi_Value *jsiNewConcatValue(Jsi_Interp *interp, const char *c1, const char *c2)\n{\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    Jsi_DSAppend(&dStr, c1, c2, NULL);\n    Jsi_Value *val = Jsi_ValueNewStringKey(interp, Jsi_DSValue(&dStr));\n    Jsi_DSFree(&dStr);\n    return val;\n}\n\nstatic Jsi_RC InfoFuncDataSub(Jsi_Interp *interp, Jsi_Value *arg, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr, int flags, Jsi_Obj *nobj)\n{\n    const char *key, *name = NULL, *ename;\n    int n, curlen = 0, isreg = 0, isobj = 0, isglob = 0, nLen = 0;\n    Jsi_HashEntry *hPtr;\n    Jsi_HashSearch search;\n    Jsi_FuncObj *fo;\n    Jsi_Func *func;\n    Jsi_Obj *fobj;\n    Jsi_Value *val, *nval;\n    int isfunc = (flags&1);\n    int isdata = (flags&2);\n    int addPre = (flags&4);\n    Jsi_DString dPre = {};\n    \n    if (!nobj) {\n        nobj = Jsi_ObjNew(interp);\n        Jsi_ValueMakeArrayObject(interp, ret, nobj);\n    }\n    \n    if (!arg)\n        name = \"*\";\n    else {\n        if (arg->vt == JSI_VT_STRING)\n            name = Jsi_ValueString(interp, arg, &nLen);\n        else if (arg->vt == JSI_VT_OBJECT) {\n            switch (arg->d.obj->ot) {\n                case JSI_OT_STRING: name = Jsi_ValueString(interp, arg, &nLen); break;\n                case JSI_OT_REGEXP: isreg = 1; break;\n                case JSI_OT_OBJECT: isobj = 1; break;\n                case JSI_OT_FUNCTION:\n                    fo = arg->d.obj->d.fobj;\n                    if (fo->func->type&FC_BUILDIN)\n                        return JSI_OK;\n                    goto dumpfunc;\n                break;\n                default: return JSI_OK;\n            }\n        } else\n            return JSI_OK;\n    }\n    ename = name;\n    if (isobj) {\n        Jsi_TreeEntry* tPtr;\n        Jsi_TreeSearch search;\n\ndumpobj:\n        for (tPtr = Jsi_TreeSearchFirst(arg->d.obj->tree, &search, 0, NULL);\n            tPtr; tPtr = Jsi_TreeSearchNext(&search)) {\n            Jsi_Value *v = (Jsi_Value*)Jsi_TreeValueGet(tPtr);\n            key = (char*)Jsi_TreeKeyGet(tPtr);\n            if (v==NULL) continue;\n            if (Jsi_ValueIsFunction(interp, v)) {\n                if (!isfunc) continue;\n            } else {\n                if (!isdata) continue;\n            }\n            if (isreg) {\n                int ismat;\n                Jsi_RegExpMatch(interp, arg, key, &ismat, NULL);\n                if (!ismat)\n                    continue;\n            } else if (ename) {\n                if (isglob) {\n                    if (!Jsi_GlobMatch(ename, key, 0))\n                        continue;\n                } else {\n                    if (Jsi_Strcmp(ename, key))\n                        continue;\n                }\n            }\n    \n            n = curlen++;\n            nval = jsiNewConcatValue(interp, (addPre?Jsi_DSValue(&dPre):\"\"), key);\n            Jsi_ObjArraySet(interp, nobj, nval, n);\n        }\n        Jsi_TreeSearchDone(&search);\n        Jsi_DSFree(&dPre);\n        return JSI_OK;\n    }\n    \n    Jsi_ScopeStrs *sstrs;            \n    const char *gs, *gb, *dotStr;\n    \n    if (name) {\n        val = Jsi_NameLookup(interp, name);\n        if (val)\n            goto dumpvar;\n        gs=Jsi_Strchr(name,'*');\n        gb=Jsi_Strchr(name,'[');\n        dotStr = Jsi_Strrchr(name, '.');\n        if (dotStr && ((gs && gs < dotStr) || (gb && gb < dotStr))) \n            return Jsi_LogError(\"glob must be after last dot\");\n        isglob = (gs || gb);\n        if (!isglob)\n            return JSI_OK;\n        if (dotStr) {\n            if (addPre)\n                Jsi_DSAppendLen(&dPre, name, dotStr-ename+1);\n            ename = dotStr+1;\n            Jsi_DString pStr = {};\n            Jsi_DSAppendLen(&pStr, name, dotStr-name);\n            val = Jsi_NameLookup(interp, Jsi_DSValue(&pStr));\n            Jsi_DSFree(&pStr);\n            if (!val)\n                return JSI_OK;\n            if (Jsi_ValueIsObjType(interp, val, JSI_OT_OBJECT)) {\n                arg = val;\n                goto dumpobj;\n            }\n            return JSI_OK;\n        } \n    }\n        \n    for (hPtr = Jsi_HashSearchFirst(interp->varTbl, &search);\n        hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {\n        key = (char*)Jsi_HashKeyGet(hPtr);\n        if (!isfunc)\n            goto doreg;\n        if (!(fobj = (Jsi_Obj*)Jsi_HashValueGet(hPtr)))\n            continue;\n        if (isfunc && name && isreg==0 && isglob==0) {\n\n            if (Jsi_Strcmp(key, name))\n                continue;\n            /* Fill object with args and locals of func. */\n            fo = fobj->d.fobj; \n            goto dumpfunc;\n        }\ndoreg:\n        if (isreg) {\n            int ismat;\n            Jsi_RegExpMatch(interp, arg, key, &ismat, NULL);\n            if (!ismat)\n                continue;\n        } else if (name) {\n            if (isglob) {\n                if (!Jsi_GlobMatch(name, key, 0))\n                    continue;\n            } else {\n                if (Jsi_Strcmp(name, key))\n                    continue;\n            }\n        }\n        n = curlen++;\n        nval = jsiNewConcatValue(interp, (addPre?Jsi_DSValue(&dPre):\"\"), key);\n        Jsi_ObjArraySet(interp, nobj, nval, n);\n    }\n    Jsi_DSFree(&dPre);\n    return JSI_OK;\n\ndumpfunc:\n{\n    nobj = Jsi_ObjNew(interp);\n    Jsi_ValueMakeObject(interp, ret, nobj);\n    func = fo->func;\n    sstrs = func->argnames;\n    int sscnt = (sstrs?sstrs->count:0);\n    const char *strs[sscnt+1];\n    int i;\n    for (i=0; i<sscnt; i++)\n        strs[i] = sstrs->args[i].name;\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    Jsi_Value *aval = Jsi_ValueNewArray(interp, strs, sscnt);\n    Jsi_ObjInsert(interp, nobj, \"argList\", aval, 0);\n    sstrs = func->localnames;\n    Jsi_Value *lval = Jsi_ValueNewArray(interp, strs, sscnt);\n    Jsi_ObjInsert(interp, nobj, \"locals\", lval, 0);\n    jsi_FuncArgsToString(interp, func, &dStr, 1);\n    lval = Jsi_ValueNewStringDup(interp, Jsi_DSValue(&dStr));\n    Jsi_ObjInsert(interp, nobj, \"args\", lval, 0);\n    Jsi_DSFree(&dStr);\n    if (func->retType)\n        Jsi_ObjInsert(interp, nobj, \"retType\", Jsi_ValueNewStringKey(interp, jsi_typeName(interp, func->retType, &dStr)), 0);\n    Jsi_DSFree(&dStr);\n    if (func->script) {\n        lval = Jsi_ValueNewStringKey(interp, func->script);\n        Jsi_ObjInsert(interp, nobj, \"script\", lval, 0);\n        const char *ftype = (func->scriptFile?\"script\":\"eval\");\n        if (!func->opcodes) {\n            ftype = (func->callback == jsi_AliasInvoke ? \"alias\" : \"builtin\");\n        } else {\n            int l1 = func->opcodes->codes->Line;\n            int l2 = func->bodyline.last_line;\n            if (l1>l2) { int lt = l1; l1 = l2; l2 = lt; }\n            lval = Jsi_ValueNewNumber(interp, (Jsi_Number)l1);\n            Jsi_ObjInsert(interp, nobj, \"lineStart\", lval, 0);\n            lval = Jsi_ValueNewNumber(interp, (Jsi_Number)l2);\n            Jsi_ObjInsert(interp, nobj, \"lineEnd\", lval, 0);\n            int len;\n            const char *cp = jsi_FuncGetCode(interp, func, &len);\n            if (cp) {\n                lval = Jsi_ValueNewBlob(interp, (uchar*)cp, len);\n                Jsi_ObjInsert(interp, nobj, \"code\", lval, 0);\n            }\n        }\n        Jsi_ObjInsert(interp, nobj, \"ftype\", Jsi_ValueNewStringKey(interp, ftype), 0);\n    }\n    return JSI_OK;\n}\ndumpvar:\n    if (isfunc && Jsi_ValueIsFunction(interp, val)) {\n        fo = val->d.obj->d.fobj;\n        goto dumpfunc;\n    }\n    nobj = Jsi_ObjNew(interp);\n    Jsi_ValueMakeObject(interp, ret, nobj);\n    Jsi_Value *aval = Jsi_ValueNewStringDup(interp, ename);\n    Jsi_ObjInsert(interp, nobj, \"name\", aval, 0);\n    aval = Jsi_ValueNewStringDup(interp, jsi_ValueTypeName(interp, val));\n    Jsi_ObjInsert(interp, nobj, \"type\", aval, 0);\n    return JSI_OK;\n}\n\nstatic Jsi_RC InfoLookupCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char *str = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    if (!str)\n        return JSI_OK;\n    Jsi_Value *val = Jsi_NameLookup(interp, str);\n    if (!val)\n        return JSI_OK;\n    Jsi_ValueDup2(interp, ret, val);\n    return JSI_OK;\n}\n\n\n#define FN_infolevel JSI_INFO(\"\\\nWith no arg, returns the number of the current stack frame level.\\n\\\nOtherwise returns details on the specified level.\\n\\\nThe topmost level is 1, and 0 is the current level, \\\nand a negative level translates as relative to the current level.\")\nstatic Jsi_RC InfoLevelCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    uint argc =  Jsi_ValueGetLength(interp, args);\n    if (argc<=0) {\n        Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)interp->framePtr->level);\n        return JSI_OK;\n    }\n    Jsi_Number num = 0;\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);\n    jsi_Frame *f = interp->framePtr;\n    if (Jsi_GetNumberFromValue(interp, arg, &num) != JSI_OK)\n        return JSI_ERROR;\n    int lev = (int)num;\n    if (lev <= 0)\n        lev = f->level+lev;\n    if (lev <= 0 || lev > f->level) \n        return Jsi_LogError(\"level %d not between 1 and %d\", (int)num, f->level);\n    while (f->level != lev  && f->parent)\n        f = f->parent;\n    char buf[JSI_BUFSIZ];\n    //int line = (f != interp->framePtr ? f->line : (interp->curIp ? interp->curIp->Line : 0));\n    int line = (f->line ? f->line : (interp->curIp ? interp->curIp->Line : 0));\n    snprintf(buf, sizeof(buf), \"{funcName:\\\"%s\\\", fileName:\\\"%s\\\", line:%d, level:%d, tryDepth:%d, withDepth:%d}\",\n        f->funcName?f->funcName:\"\", f->fileName?f->fileName:\"\", line, f->level, f->tryDepth, f->withDepth\n        );\n    \n    Jsi_RC rc = Jsi_JSONParse(interp, buf, ret, 0);\n    if (rc != JSI_OK)\n        return rc;\n    Jsi_Func *who = f->evalFuncPtr;\n    Jsi_Obj *obj = Jsi_ObjNewArray(interp, NULL, 0, 0);\n    Jsi_Value *val = Jsi_ValueMakeArrayObject(interp, NULL, obj);\n    if (who && who->localnames) {\n        int i;\n        for (i = 0; i < who->localnames->count; ++i) {\n            const char *argkey = jsi_ScopeStrsGet(who->localnames, i);\n            Jsi_Value *v = Jsi_ValueMakeStringKey(interp, NULL, argkey);\n            Jsi_ObjArrayAdd(interp, obj, v);\n\n        }\n    }\n    Jsi_ValueInsert(interp, *ret, \"locals\", val, 0);\n    Jsi_ValueInsert(interp, *ret, \"scope\", f->incsc, 0);\n    Jsi_ValueInsert(interp, *ret, \"inthis\", f->inthis, 0);\n    return rc;\n}\n\nstatic Jsi_RC InfoFilesCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    return Jsi_HashKeysDump(interp, interp->fileTbl, ret, 0);\n}\n\nstatic Jsi_RC InfoFuncsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);\n    return InfoFuncDataSub(interp, arg, _this, ret, funcPtr, 1, NULL);\n}\n\n#define FN_infodata JSI_INFO(\"\\\nLike info.vars(), but does not return function values.\")\nstatic Jsi_RC InfoDataCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);\n    return InfoFuncDataSub(interp, arg, _this, ret, funcPtr, 2, NULL);\n}\n\nstatic const char* jsi_SqlKeysWords =\n    \",ABORT,ACTION,ADD,AFTER,ALL,ALTER,ANALYZE,AND,\" \n    \"AS,ASC,ATTACH,AUTOINCREMENT,BEFORE,BEGIN,\" \n    \"BETWEEN,BY,CASCADE,CASE,CAST,CHECK,COLLATE,\" \n    \"COLUMN,COMMIT,CONFLICT,CONSTRAINT,CREATE,CROSS,\" \n    \"CURRENT,CURRENT_DATE,CURRENT_TIME,CURRENT_TIMESTAMP,\" \n    \"DATABASE,DEFAULT,DEFERRABLE,DEFERRED,DELETE,DESC,\" \n    \"DETACH,DISTINCT,DO,DROP,EACH,ELSE,END,\" \n    \"ESCAPE,EXCEPT,EXCLUDE,EXCLUSIVE,EXISTS,EXPLAIN,\" \n    \"FAIL,FILTER,FIRST,FOLLOWING,FOR,FOREIGN,FROM,\" \n    \"FULL,GLOB,GROUP,GROUPS,HAVING,IF,IGNORE,\" \n    \"IMMEDIATE,IN,INDEX,INDEXED,INITIALLY,INNER,\" \n    \"INSERT,INSTEAD,INTERSECT,INTO,IS,ISNULL,JOIN,\" \n    \"KEY,LAST,LEFT,LIKE,LIMIT,MATCH,NATURAL,NO,\" \n    \"NOT,NOTHING,NOTNULL,NULL,NULLS,OF,OFFSET,ON,\" \n    \"OR,ORDER,OTHERS,OUTER,OVER,PARTITION,PLAN,\" \n    \"PRAGMA,PRECEDING,PRIMARY,QUERY,RAISE,RANGE,\" \n    \"RECURSIVE,REFERENCES,REGEXP,REINDEX,RELEASE,\" \n    \"RENAME,REPLACE,RESTRICT,RIGHT,ROLLBACK,ROW,\" \n    \"ROWS,SAVEPOINT,SELECT,SET,TABLE,TEMP,TEMPORARY,\" \n    \"THEN,TIES,TO,TRANSACTION,TRIGGER,UNBOUNDED,\" \n    \"UNION,UNIQUE,UPDATE,USING,VACUUM,VALUES,VIEW,\" \n    \"VIRTUAL,WHEN,WHERE,WINDOW,WITH,WITHOUT,\";\n\nstatic int jsi_SqlIsKeyword(const char *str) {\n    char kbuf[25];\n    int i;\n    if (!str[0] || !isalpha(str[0])) return 0;\n    kbuf[0]=',';\n    for (i=0; str[i]; i++) {\n        if (i>20) return 0;\n        if (!isalpha(str[i])) return 0;\n        kbuf[i+1] = toupper(str[i]);\n    }\n    kbuf[++i] = ',';\n    kbuf[++i] = 0;\n    return (Jsi_Strstr(jsi_SqlKeysWords, kbuf)!=NULL);\n}\n\nbool Jsi_IsReserved(Jsi_Interp *interp, const char* str, bool sql) {\n    if (sql)\n        return jsi_SqlIsKeyword(str);\n    return (Jsi_HashEntryFind(interp->lexkeyTbl, str)!=NULL);\n}\n\nstatic Jsi_RC InfoKeywordsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    bool isSql = 0;\n    Jsi_Value* vsql = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_Value* val = Jsi_ValueArrayIndex(interp, args, 1);\n    const char *str = NULL;\n    if (vsql && Jsi_ValueGetBoolean(interp, vsql, &isSql) != JSI_OK)\n            return Jsi_LogError(\"arg1: expected bool 'isSql'\");\n    if (val) {\n        str = Jsi_ValueString(interp, val, NULL);\n        if (!str)\n            return Jsi_LogError(\"arg2: expected string 'name'\");\n    }\n\n    if (!str) {\n        if (!isSql) {\n            if (interp->lexkeyTbl) {\n                Jsi_HashKeysDump(interp, interp->lexkeyTbl, ret, 0);\n                Jsi_ValueArraySort(interp, *ret, 0);\n            }\n        } else {\n            Jsi_DString dStr = {};\n            int vargc; char **vargv;\n            Jsi_SplitStr(jsi_SqlKeysWords+1, &vargc, &vargv, \",\", &dStr);\n            Jsi_ValueMakeArrayObject(interp, ret, NULL);\n            Jsi_Obj *obj = (*ret)->d.obj;\n            int i;\n            for (i = 0; i < (vargc-1); ++i)\n                Jsi_ObjArraySet(interp, obj, Jsi_ValueNewStringDup(interp, vargv[i]), i);\n            Jsi_DSFree(&dStr);\n        }\n        return JSI_OK;\n    }\n    Jsi_ValueMakeBool(interp, ret, Jsi_IsReserved(interp, str, isSql));\n    return JSI_OK;\n}\n\nstatic Jsi_RC InfoOptionsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    uint i, argc =  Jsi_ValueGetLength(interp, args);\n    Jsi_DString dStr = {};\n    const char *str;\n    bool bv = 0;\n    if (argc && Jsi_GetBoolFromValue(interp, Jsi_ValueArrayIndex(interp, args, 0), &bv) != JSI_OK)\n        return JSI_ERROR;\n    Jsi_DSAppend(&dStr, \"[\", NULL);\n    for (i=1; (str = jsi_OptionTypeStr((Jsi_OptionId)i, bv)); i++)\n        Jsi_DSAppend(&dStr, (i>1?\", \":\"\"), \"\\\"\", str, \"\\\"\", NULL);\n    Jsi_DSAppend(&dStr, \"]\", NULL);\n    Jsi_JSONParse(interp, Jsi_DSValue(&dStr), ret, 0);\n    Jsi_DSFree(&dStr);\n    return JSI_OK;\n}\nstatic Jsi_RC InfoVersionCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Value *full = Jsi_ValueArrayIndex(interp, args, 0);\n    if (!full)\n        Jsi_ValueMakeNumber(interp, ret, Jsi_Version());\n    else if (!Jsi_ValueIsBoolean(interp, full))\n        return Jsi_LogError(\"arg1: expected bool 'full'\");\n    else if (!Jsi_ValueIsTrue(interp, full))\n        Jsi_ValueMakeNumber(interp, ret, Jsi_Version());\n    else {\n        char buf[JSI_BUFSIZ];\n        snprintf(buf, sizeof(buf),\n            \"{major:%d, minor:%d, release:%d, verStr:\\\"%d.%d.%d\\\"}\",\n            JSI_VERSION_MAJOR, JSI_VERSION_MINOR, JSI_VERSION_RELEASE,\n            JSI_VERSION_MAJOR, JSI_VERSION_MINOR, JSI_VERSION_RELEASE);\n        return Jsi_JSONParse(interp, buf, ret, 0);\n    }\n    return JSI_OK;\n}\n\n\nstatic bool jsi_isMain(Jsi_Interp *interp) {\n    int isi = (interp->isMain);\n    if (isi == 0) {\n        const char *c2 = interp->curFile;\n        Jsi_Value *v1 = interp->argv0;\n        if (c2 && v1 && Jsi_ValueIsString(interp, v1)) {\n            char *c1 = Jsi_ValueString(interp, v1, NULL);\n            isi = (c1 && !Jsi_Strcmp(c1,c2));\n        }\n    }\n    return isi;\n}\n\nstatic Jsi_RC InfoIsMainCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_ValueMakeBool(interp, ret, jsi_isMain(interp));\n    return JSI_OK;\n}\n\nstatic Jsi_RC InfoArgv0Cmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (interp->argv0)\n        Jsi_ValueDup2(interp, ret, interp->argv0);\n     return JSI_OK;\n}\n\nstatic Jsi_RC InfoExecZipCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (interp->execZip)\n        Jsi_ValueDup2(interp, ret, interp->execZip);\n     return JSI_OK;\n}\n\n#ifndef JSI_OMIT_DEBUG\nstatic Jsi_RC DebugAddCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (!interp->breakpointHash)\n        interp->breakpointHash = Jsi_HashNew(interp, JSI_KEYS_STRING, jsi_HashFree);\n    int argc = Jsi_ValueGetLength(interp, args);\n    jsi_BreakPoint *bptr, bp = {};\n    Jsi_Number vnum;\n    if (argc>1 && Jsi_ValueGetBoolean(interp, Jsi_ValueArrayIndex(interp, args, 1), &bp.temp) != JSI_OK) \n        return Jsi_LogError(\"bad boolean\");\n    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n    if (Jsi_ValueGetNumber(interp, v, &vnum) == JSI_OK) {\n        bp.line = (int)vnum;\n        bp.file = interp->curFile;\n    } else {\n        const char *val = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n        const char *cp;\n        \n        if (isdigit(val[0])) {\n            if (Jsi_GetInt(interp, val, &bp.line, 0) != JSI_OK) \n                return Jsi_LogError(\"bad number\");\n            bp.file = interp->curFile;\n        } else if ((cp = Jsi_Strchr(val, ':'))) {\n            if (Jsi_GetInt(interp, cp+1, &bp.line, 0) != JSI_OK) \n                return Jsi_LogError(\"bad number\");\n            Jsi_DString dStr = {};\n            Jsi_DSAppendLen(&dStr, val, cp-val);\n            bp.file = Jsi_KeyAdd(interp, Jsi_DSValue(&dStr));\n            Jsi_DSFree(&dStr);\n        } else {\n            bp.func = Jsi_KeyAdd(interp, val);\n        }\n    }\n    if (bp.line<=0 && !bp.func) \n        return Jsi_LogError(\"bad number\");\n    char nbuf[JSI_MAX_NUMBER_STRING];\n    bp.id = ++interp->debugOpts.breakIdx;\n    bp.enabled = 1;\n    snprintf(nbuf, sizeof(nbuf), \"%d\", bp.id);\n    bptr = (jsi_BreakPoint*)Jsi_Malloc(sizeof(*bptr));\n    *bptr = bp;\n    Jsi_HashSet(interp->breakpointHash, (void*)nbuf, bptr);\n    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)bp.id);\n    return JSI_OK;\n}\n\nstatic Jsi_RC DebugRemoveCmd_(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr, int op)\n{\n    Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 0);\n    if (interp->breakpointHash)\n    {\n        int num;\n        char nbuf[JSI_MAX_NUMBER_STRING];\n        if (Jsi_GetIntFromValue(interp, val, &num) != JSI_OK) \n            return Jsi_LogError(\"bad number\");\n        \n        snprintf(nbuf, sizeof(nbuf), \"%d\", num);\n        Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->breakpointHash, nbuf);\n        jsi_BreakPoint* bptr;\n        if (hPtr && (bptr = (jsi_BreakPoint*)Jsi_HashValueGet(hPtr))) {\n            switch (op) {\n                case 1: bptr->enabled = 0; break;\n                case 2: bptr->enabled = 1; break;\n                default:\n                    Jsi_HashEntryDelete(hPtr);\n            }\n            return JSI_OK;\n        }\n    }\n    return Jsi_LogError(\"unknown breakpoint\");\n}\n\nstatic Jsi_RC DebugRemoveCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    return DebugRemoveCmd_(interp, args, _this, ret, funcPtr, 0);\n}\n\nstatic Jsi_RC DebugEnableCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 1);\n    bool bval;\n    if (Jsi_ValueGetBoolean(interp, val, &bval) != JSI_OK)\n        return JSI_ERROR;\n    return DebugRemoveCmd_(interp, args, _this, ret, funcPtr, bval ? 2 : 1);\n}\n\nstatic Jsi_RC DebugInfoCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (!interp->breakpointHash) {\n        Jsi_ValueMakeArrayObject(interp, ret, NULL);\n        return JSI_OK;\n    }\n    int argc = Jsi_ValueGetLength(interp, args);\n    if (argc == 0)\n        return Jsi_HashKeysDump(interp, interp->breakpointHash, ret, 0);\n    Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 0);\n    int num;\n    char nbuf[JSI_MAX_NUMBER_STRING];\n    if (Jsi_GetIntFromValue(interp, val, &num) != JSI_OK) \n        return Jsi_LogError(\"bad number\");\n    \n    snprintf(nbuf, sizeof(nbuf), \"%d\", num);\n    Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->breakpointHash, nbuf);\n    if (!hPtr) \n        return Jsi_LogError(\"unknown breakpoint\");\n    jsi_BreakPoint* bp = (jsi_BreakPoint*)Jsi_HashValueGet(hPtr);\n    if (!bp) return JSI_ERROR;\n    Jsi_DString dStr = {};\n    if (bp->func)\n        Jsi_DSPrintf(&dStr, \"{id:%d, type:\\\"func\\\", func:\\\"%s\\\", hits:%d, enabled:%s, temporary:%s}\",\n         bp->id, bp->func, bp->hits, bp->enabled?\"true\":\"false\", bp->temp?\"true\":\"false\");\n    else\n        Jsi_DSPrintf(&dStr, \"{id:%d, type:\\\"line\\\", file:\\\"%s\\\", line:%d, hits:%d, enabled:%s}\",\n            bp->id, bp->file?bp->file:\"\", bp->line, bp->hits, bp->enabled?\"true\":\"false\");\n    Jsi_RC rc = Jsi_JSONParse(interp, Jsi_DSValue(&dStr), ret, 0);\n    Jsi_DSFree(&dStr);\n    return rc;\n}\n#endif\n\nstatic Jsi_RC InfoScriptCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);\n    int isreg = 0;\n    const char *name = NULL;\n\n    if (!arg) {\n        name = jsi_GetCurFile(interp);\n    } else {\n        if (arg->vt == JSI_VT_OBJECT) {\n            switch (arg->d.obj->ot) {\n                case JSI_OT_FUNCTION: name = arg->d.obj->d.fobj->func->script; break;\n                case JSI_OT_REGEXP: isreg = 1; break;\n                default: break;\n            }\n        } else\n            return JSI_OK;\n    }\n    if (isreg) {\n        Jsi_HashEntry *hPtr;\n        Jsi_HashSearch search;\n        int curlen = 0, n;\n        const char *key;\n        Jsi_Obj *nobj = Jsi_ObjNew(interp);\n        Jsi_ValueMakeArrayObject(interp, ret, nobj);\n        for (hPtr = Jsi_HashSearchFirst(interp->fileTbl, &search);\n            hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {\n            key = (const char*)Jsi_HashKeyGet(hPtr);\n            if (isreg) {\n                int ismat;\n                Jsi_RegExpMatch(interp, arg, key, &ismat, NULL);\n                if (!ismat)\n                    continue;\n            }\n            n = curlen++;\n            Jsi_ObjArraySet(interp, nobj, Jsi_ValueNewStringKey(interp, key), n);\n        }\n        return JSI_OK;\n    }\n    if (name)\n        Jsi_ValueMakeStringDup(interp, ret, name);\n    return JSI_OK;\n}\n\nstatic Jsi_RC InfoScriptDirCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    const char *path = interp->curDir;\n    if (path)\n        Jsi_ValueMakeStringDup(interp, ret, path);\n    return JSI_OK;\n}\n\nstatic int isBigEndian()\n{\n    union { unsigned short s; unsigned char c[2]; } uval = {0x0102};\n    return uval.c[0] == 1;\n}\n\nstatic Jsi_RC InfoPlatformCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[JSI_BUFSIZ];\n    size_t crcSizes[] = { sizeof(int), sizeof(void*), sizeof(time_t), sizeof(Jsi_Number), (size_t)isBigEndian() };\n#ifdef __WIN32\n    const char *os=\"win\", *platform = \"win\";\n#elif defined(__FreeBSD__)\n    const char *os=\"freebsd\", *platform = \"unix\";\n#else\n    const char *os=\"linux\", *platform = \"unix\";\n#endif\n#ifndef JSI_OMIT_THREADS\n    int thrd = 1;\n#else\n    int thrd = 0;\n#endif\n    if (Jsi_FunctionReturnIgnored(interp, funcPtr))\n        return JSI_OK;\n    snprintf(buf, sizeof(buf),\n        \"{exeExt:\\\"%s\\\", dllExt:\\\"%s\\\", os:\\\"%s\\\", platform:\\\"%s\\\", hasThreads:%s, pointerSize:%zu, timeSize:%zu \"\n        \"intSize:%zu, wideSize:%zu, numberSize:%zu, crc:%x, isBigEndian:%s, confArgs:\\\"%s\\\"}\",\n#ifdef __WIN32\n        \".exe\", \".dll\",\n#else\n        \"\", \".so\",\n#endif\n        os, platform, thrd?\"true\":\"false\", sizeof(void*), sizeof(time_t), sizeof(int),\n        sizeof(Jsi_Wide), sizeof(Jsi_Number), Jsi_Crc32(0, (uchar*)crcSizes, sizeof(crcSizes)),\n        isBigEndian()? \"true\" : \"false\", interp->confArgs);\n        \n    return Jsi_JSONParse(interp, buf, ret, 0);\n}\n\nstatic Jsi_RC InfoNamedCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Obj *nobj;\n    char *argStr = NULL;\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);\n    if (arg  && (argStr = (char*)Jsi_ValueString(interp, arg, NULL)) == NULL) \n        return Jsi_LogError(\"arg1: expected string 'name'\");\n    if (argStr && argStr[0] == '#') {\n        Jsi_Obj *obj = jsi_UserObjFromName(interp, argStr);\n        if (!obj) \n            return Jsi_LogError(\"Unknown object: %s\", argStr);\n        Jsi_ValueMakeObject(interp, ret, obj);\n        return JSI_OK;\n    }\n    nobj = Jsi_ObjNew(interp);\n    Jsi_ValueMakeArrayObject(interp, ret, nobj);\n    return jsi_UserObjDump(interp, argStr, nobj);\n}\n\n\nconst char* Jsi_OptionsData(Jsi_Interp *interp, Jsi_OptionSpec *specs, Jsi_DString *dStr, bool schema) {\n    const Jsi_OptionSpec *send;\n    for (send = specs; send->id>=JSI_OPTION_BOOL && send->id<JSI_OPTION_END; send++) ;\n    if (!send)\n        return NULL;\n    if (schema) {\n        char tbuf[100];\n        int i = 0;\n        if (send->name)\n            Jsi_DSAppend(dStr, \"  -- '\", send->name, \"\\': \", NULL);\n        if (send->help)\n            Jsi_DSAppend(dStr,  send->help, NULL);\n        Jsi_DSAppend(dStr, \"\\n\", NULL);\n        for (; specs->id>=JSI_OPTION_BOOL && specs->id<JSI_OPTION_END; specs++) {\n            const char *tstr = NULL;\n            if (specs->flags&JSI_OPT_DB_DIRTY)\n                continue;\n            if (!Jsi_Strcmp(specs->name, \"rowid\"))\n                continue;\n            switch(specs->id) {\n            case JSI_OPTION_BOOL: tstr = \"BOOLEAN\"; break;\n            case JSI_OPTION_TIME_T: tstr = \"TIMESTAMP\"; break;\n            case JSI_OPTION_TIME_D:\n            case JSI_OPTION_TIME_W:\n                if (specs->flags & JSI_OPT_TIME_TIMEONLY)\n                    tstr = \"TIME\";\n                else if (specs->flags & JSI_OPT_TIME_TIMEONLY)\n                    tstr = \"DATE\";\n                else\n                    tstr = \"DATETIME\";\n                break;\n            case JSI_OPTION_SIZE_T:\n            case JSI_OPTION_SSIZE_T:\n            case JSI_OPTION_INTPTR_T:\n            case JSI_OPTION_UINTPTR_T:\n            case JSI_OPTION_UINT:\n            case JSI_OPTION_INT:\n            case JSI_OPTION_ULONG:\n            case JSI_OPTION_LONG:\n            case JSI_OPTION_USHORT:\n            case JSI_OPTION_SHORT:\n            case JSI_OPTION_UINT8:\n            case JSI_OPTION_UINT16:\n            case JSI_OPTION_UINT32:\n            case JSI_OPTION_UINT64:\n            case JSI_OPTION_INT8:\n            case JSI_OPTION_INT16:\n            case JSI_OPTION_INT32:\n            case JSI_OPTION_INT64: tstr = \"INT\"; break;\n            case JSI_OPTION_FLOAT:\n            case JSI_OPTION_NUMBER:\n            case JSI_OPTION_LDOUBLE:\n            case JSI_OPTION_DOUBLE: tstr = \"FLOAT\"; break;\n            \n            case JSI_OPTION_STRBUF:\n                tstr = tbuf;\n                snprintf(tbuf, sizeof(tbuf), \"VARCHAR(%d)\", specs->size);;\n                break;\n            case JSI_OPTION_DSTRING: \n            case JSI_OPTION_STRKEY:\n            case JSI_OPTION_STRING:\n                tstr = \"TEXT\";\n                break;\n            case JSI_OPTION_CUSTOM:\n                if (specs->custom == Jsi_Opt_SwitchEnum || specs->custom == Jsi_Opt_SwitchBitset) {\n                    if (specs->flags&JSI_OPT_FORCE_INT)\n                        tstr = \"INT\";\n                    else\n                        tstr = \"TEXT\";\n                } else\n                    tstr = \"\";\n                break;\n            case JSI_OPTION_VALUE: /* Unsupported. */\n            case JSI_OPTION_VAR:\n            case JSI_OPTION_OBJ:\n            case JSI_OPTION_ARRAY:\n            case JSI_OPTION_FUNC:\n            case JSI_OPTION_USEROBJ:\n            case JSI_OPTION_REGEXP:\n                break;\n#ifdef __cplusplus\n            case JSI_OPTION_END:\n#else\n            default:\n#endif\n                Jsi_LogBug(\"invalid option type: %d\", specs->id);\n            }\n            \n            if (!tstr) continue;\n            Jsi_DSAppend(dStr, (i?\"\\n ,\":\"  \"), specs->name, \" \", (tstr[0]?tstr:specs->tname), NULL);\n\n            const char *cp;\n            if ((cp=specs->userData)) {\n                const char *udrest = NULL;\n                if (!Jsi_Strcmp(cp, \"DEFAULT\")) {\n                    if ((specs->id == JSI_OPTION_TIME_D || specs->id <= JSI_OPTION_TIME_T)) {\n                        if (specs->flags & JSI_OPT_TIME_DATEONLY)\n                            udrest = \"(round((julianday('now') - 2440587.5)*86400000))\";\n                        else if (specs->flags & JSI_OPT_TIME_TIMEONLY)\n                            udrest = \"(round((julianday('now')-julianday('now','start of day') - 2440587.5)*86400000))\";\n                        else\n                            udrest = \"(round((julianday('now') - 2440587.5)*86400000.0))\";\n                    } else if (specs->id <= JSI_OPTION_TIME_T) {\n                        if (specs->flags & JSI_OPT_TIME_DATEONLY)\n                            udrest = \"(round((julianday('now') - 2440587.5)*86400))\";\n                        else if (specs->flags & JSI_OPT_TIME_TIMEONLY)\n                            udrest = \"(round((julianday('now')-julianday('now','start of day') - 2440587.5)*86400))\";\n                        else\n                            udrest = \"(round((julianday('now') - 2440587.5)*86400.0))\";\n                    }\n                }\n                Jsi_DSAppend(dStr, \" \", cp, udrest, NULL);\n            }\n            if (specs->help)\n                Jsi_DSAppend(dStr, \" -- \", specs->help, NULL);\n            if (specs->id==JSI_OPTION_END)\n                break;\n            i++;\n        }\n        if (send->userData)\n            Jsi_DSAppend(dStr,  send->userData, NULL);\n        Jsi_DSAppend(dStr, \"\\n  -- MD5=\", NULL);\n\n    } else {\n        int i = 0;\n        Jsi_DSAppend(dStr, \"\\n/* \", send->name, \": \", NULL);\n        if (send->help)\n            Jsi_DSAppend(dStr,  send->help, NULL);\n        Jsi_DSAppend(dStr, \" */\\ntypedef struct \",  send->name, \" {\", NULL);\n        for (; specs->id>=JSI_OPTION_BOOL && specs->id<JSI_OPTION_END; specs++) {\n            int nsz = 0;\n            const char *tstr = NULL;\n            switch(specs->id) {\n            case JSI_OPTION_STRBUF: nsz=1;\n            case JSI_OPTION_BOOL:\n            case JSI_OPTION_TIME_T:\n            case JSI_OPTION_TIME_W:\n            case JSI_OPTION_TIME_D:;\n            case JSI_OPTION_SIZE_T:\n            case JSI_OPTION_SSIZE_T:\n            case JSI_OPTION_INTPTR_T:\n            case JSI_OPTION_UINTPTR_T:\n            case JSI_OPTION_INT:\n            case JSI_OPTION_UINT:\n            case JSI_OPTION_LONG:\n            case JSI_OPTION_ULONG:\n            case JSI_OPTION_SHORT:\n            case JSI_OPTION_USHORT:\n            case JSI_OPTION_UINT8:\n            case JSI_OPTION_UINT16:\n            case JSI_OPTION_UINT32:\n            case JSI_OPTION_UINT64:\n            case JSI_OPTION_INT8:\n            case JSI_OPTION_INT16:\n            case JSI_OPTION_INT32:\n            case JSI_OPTION_INT64:\n            case JSI_OPTION_FLOAT:\n            case JSI_OPTION_DOUBLE:\n            case JSI_OPTION_LDOUBLE:\n            case JSI_OPTION_NUMBER:\n            case JSI_OPTION_DSTRING:\n            case JSI_OPTION_STRKEY: \n            case JSI_OPTION_STRING:\n                tstr = jsi_OptionTypeStr(specs->id, 1); \n                break;\n            case JSI_OPTION_CUSTOM:\n                if (specs->custom == Jsi_Opt_SwitchEnum || specs->custom == Jsi_Opt_SwitchBitset) {\n                    tstr = \"int\";\n                } else {\n                    tstr = \"char\";\n                    nsz = 1;\n                }\n                break;\n            case JSI_OPTION_VALUE: /* Unsupported. */\n            case JSI_OPTION_VAR:\n            case JSI_OPTION_OBJ:\n            case JSI_OPTION_ARRAY:\n            case JSI_OPTION_REGEXP:\n            case JSI_OPTION_FUNC:\n            case JSI_OPTION_USEROBJ:\n                break;\n#ifdef __cplusplus\n            case JSI_OPTION_END:\n#else\n            default:\n#endif\n                Jsi_LogBug(\"invalid option type: %d\", specs->id);\n            }\n            \n            if (!tstr) continue;\n            Jsi_DSAppend(dStr, \"\\n    \", tstr, \" \", specs->name, NULL);\n            if (nsz) {\n                Jsi_DSPrintf(dStr, \"[%d]\", specs->size);\n            }\n            Jsi_DSAppend(dStr, \";\", NULL);\n            if (specs->help)\n                Jsi_DSAppend(dStr, \" /* \", specs->help, \" */\", NULL);\n            if (specs->id==JSI_OPTION_END)\n                break;\n            i++;\n        }\n        Jsi_DSAppend(dStr, \"\\n};\\n// MD5=\", NULL);\n\n    }\n    char buf[33];\n    Jsi_CryptoHash(buf, Jsi_DSValue(dStr), Jsi_DSLength(dStr), Jsi_CHash_MD5, 0, 0, NULL);\n    //Jsi_Md5Str(buf, Jsi_DSValue(dStr), -1);\n    Jsi_DSAppend(dStr, buf, NULL);\n\n    return Jsi_DSValue(dStr);\n}\n\nstatic Jsi_RC InfoExecutableCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (jsiIntData.execName == NULL)\n        Jsi_ValueMakeNull(interp, ret);\n    else\n        Jsi_ValueMakeStringKey(interp, ret, jsiIntData.execName);\n    return JSI_OK;\n}\n\n#define FN_infoevent JSI_INFO(\"\\\nWith no args, returns list of all outstanding events.  With one arg, returns info\\\nfor the given event id.\")\n\n#ifndef JSI_OMIT_EVENT\nstatic Jsi_RC InfoEventCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    uint n = 0;\n    int nid;\n    Jsi_HashEntry *hPtr;\n    Jsi_HashSearch search;\n    Jsi_Obj *nobj;\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);\n    \n    if (arg && Jsi_GetIntFromValue(interp, arg, &nid) != JSI_OK)\n        return JSI_ERROR;\n    if (!arg) {\n        nobj = Jsi_ObjNew(interp);\n        Jsi_ValueMakeArrayObject(interp, ret, nobj);\n    }\n\n    for (hPtr = Jsi_HashSearchFirst(interp->eventTbl, &search);\n        hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {\n        uintptr_t id;\n        id = (uintptr_t)Jsi_HashKeyGet(hPtr);\n        if (!arg) {\n            Jsi_ObjArraySet(interp, nobj, Jsi_ValueNewNumber(interp, (Jsi_Number)id), n);\n            n++;\n        } else if (id == (uint)nid) {\n            Jsi_Event *evPtr = (Jsi_Event *)Jsi_HashValueGet(hPtr);\n            Jsi_DString dStr;\n            if (!evPtr) return JSI_ERROR;\n            Jsi_DSInit(&dStr);\n            switch (evPtr->evType) {\n                case JSI_EVENT_SIGNAL:\n                    Jsi_DSPrintf(&dStr, \"{ type:\\\"signal\\\", sigNum:%d, count:%u, builtin:%s, busy:%s }\", \n                        evPtr->sigNum, evPtr->count, (evPtr->handler?\"true\":\"false\"),\n                        (evPtr->busy?\"true\":\"false\") );\n                    break;\n                case JSI_EVENT_TIMER: {\n             \n                    long cur_sec, cur_ms;\n                    uint64_t ms;\n                    jsiGetTime(&cur_sec, &cur_ms);\n                    ms = (evPtr->when_sec*1000LL + evPtr->when_ms) - (cur_sec * 1000LL + cur_ms);\n                    Jsi_DSPrintf(&dStr, \"{ type:\\\"timer\\\", once:%s, when:%\" PRId64 \", count:%u, initial:%\" PRId64 \", builtin:%s, busy:%s }\",\n                        evPtr->once?\"true\":\"false\", (Jsi_Wide)ms, evPtr->count, (Jsi_Wide)evPtr->initialms, (evPtr->handler?\"true\":\"false\"),\n                        (evPtr->busy?\"true\":\"false\") );\n                    break;\n                }\n                case JSI_EVENT_ALWAYS:\n                    Jsi_DSPrintf(&dStr, \"{ type:\\\"always\\\", count:%u, builtin:%s, busy:%s }\", \n                        evPtr->count, (evPtr->handler?\"true\":\"false\"), (evPtr->busy?\"true\":\"false\") );\n                    break;\n            }\n            Jsi_RC rc = Jsi_JSONParse(interp, Jsi_DSValue(&dStr), ret, 0);\n            Jsi_DSFree(&dStr);\n            return rc;\n        }\n    }\n    return JSI_OK;\n}\n\nstatic Jsi_RC eventInfoCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    return InfoEventCmd(interp, args, _this, ret, funcPtr);\n}\n#endif\n\nstatic Jsi_RC InfoErrorCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Obj *nobj = Jsi_ObjNew(interp);\n    Jsi_ValueMakeObject(interp, ret, nobj);\n    Jsi_ValueInsert( interp, *ret, \"file\", Jsi_ValueNewStringKey(interp, interp->errFile?interp->errFile:\"\"), 0);\n    Jsi_ValueInsert(interp, *ret, \"line\", Jsi_ValueNewNumber(interp, interp->errLine), 0);\n    return JSI_OK;\n}\n\nvoid jsi_DumpCmdSpec(Jsi_Interp *interp, Jsi_Obj *nobj, Jsi_CmdSpec* spec, const char *name)\n{\n    Jsi_ObjInsert(interp, nobj, \"minArgs\", Jsi_ValueNewNumber(interp, spec->minArgs),0);\n    Jsi_ObjInsert(interp, nobj, \"maxArgs\", Jsi_ValueNewNumber(interp, spec->maxArgs),0);\n    if (spec->help)\n        Jsi_ObjInsert(interp, nobj, \"help\", Jsi_ValueNewStringKey(interp, spec->help),0);\n    if (spec->info)\n        Jsi_ObjInsert(interp, nobj, \"info\", Jsi_ValueNewStringKey(interp, spec->info),0);\n    Jsi_ObjInsert(interp, nobj, \"args\", Jsi_ValueNewStringKey(interp, spec->argStr?spec->argStr:\"\"),0);\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    Jsi_ObjInsert(interp, nobj, \"retType\", Jsi_ValueNewStringKey(interp, jsi_typeName(interp, spec->retType, &dStr)), 0);\n    Jsi_DSFree(&dStr);\n    Jsi_ObjInsert(interp, nobj, \"name\", Jsi_ValueNewStringKey(interp, name?name:spec->name),0);\n    Jsi_ObjInsert(interp, nobj, \"type\", Jsi_ValueNewStringKey(interp, \"command\"),0);\n    Jsi_ObjInsert(interp, nobj, \"flags\", Jsi_ValueNewNumber(interp, spec->flags),0);\n    if (spec->opts) {\n        Jsi_Obj *sobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n        Jsi_Value *svalue = Jsi_ValueMakeObject(interp, NULL, sobj);\n        Jsi_OptionSpec *os = spec->opts;\n        jsi_DumpOptionSpecs(interp, sobj, os);\n        Jsi_ObjInsert(interp, nobj, \"options\", svalue, 0);\n        while (os->id != JSI_OPTION_END) os++;\n        Jsi_ObjInsert(interp, nobj, \"optHelp\", Jsi_ValueNewStringKey(interp, (os->help?os->help:\"\")), 0);\n\n    }\n}\nvoid jsi_DumpCmdItem(Jsi_Interp *interp, Jsi_Obj *nobj, Jsi_CmdSpecItem* csi, const char *name)\n{\n    Jsi_ObjInsert(interp, nobj, \"name\", Jsi_ValueNewStringKey(interp, name), 0);\n    Jsi_ObjInsert(interp, nobj, \"type\", Jsi_ValueNewStringKey(interp, \"object\"),0);\n    Jsi_ObjInsert(interp, nobj, \"constructor\", Jsi_ValueNewBoolean(interp, csi && csi->isCons), 0);\n    if (csi && csi->help)\n        Jsi_ObjInsert(interp, nobj, \"help\", Jsi_ValueNewStringDup(interp, csi->help),0);\n    if (csi && csi->info)\n        Jsi_ObjInsert(interp, nobj, \"info\", Jsi_ValueNewStringDup(interp, csi->info),0);\n    if (csi && csi->isCons && csi->spec->argStr)\n        Jsi_ObjInsert(interp, nobj, \"args\", Jsi_ValueNewStringDup(interp, csi->spec->argStr),0);\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    Jsi_ObjInsert(interp, nobj, \"retType\", Jsi_ValueNewStringKey(interp, jsi_typeName(interp, csi->spec->retType, &dStr)), 0);\n    Jsi_DSFree(&dStr);\n    if (csi && csi->isCons && csi->spec->opts) {\n        Jsi_Obj *sobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n        Jsi_Value *svalue = Jsi_ValueMakeObject(interp, NULL, sobj);\n        Jsi_OptionSpec *os = csi->spec->opts;\n        jsi_DumpOptionSpecs(interp, sobj, os);\n        Jsi_ObjInsert(interp, nobj, \"options\", svalue, 0);\n        while (os->id != JSI_OPTION_END) os++;\n        Jsi_ObjInsert(interp, nobj, \"optHelp\", Jsi_ValueNewStringKey(interp, (os->help?os->help:\"\")), 0);\n    }\n}\n\n\ntypedef struct {\n    bool full;\n    bool constructor;\n} InfoCmdsData;\n\nstatic Jsi_OptionSpec InfoCmdsOptions[] = {\n    JSI_OPT(BOOL,   InfoCmdsData, full,  .help=\"Return full path\" ),\n    JSI_OPT(BOOL,   InfoCmdsData, constructor, .help=\"Do not exclude constructor\" ),\n    JSI_OPT_END(InfoCmdsData, .help=\"Options for Info.cmds\")\n};\n\nstatic Jsi_RC InfoCmdsCmdSub(Jsi_Interp *interp, Jsi_Value *arg, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr, int all, int sort, Jsi_Obj *nobj, int add)\n{\n    const char *key, *name = NULL, *cp;\n    int tail = (add&2);\n    int curlen = 0, icnt = 0, isglob = 0, dots = 0, gotFirst = 0, ninc;\n    Jsi_MapEntry *hPtr = NULL;\n    Jsi_MapSearch search;\n    Jsi_CmdSpecItem *csi = NULL;\n    Jsi_DString dStr;\n    const char *skey;\n    Jsi_CmdSpec *spec = NULL;\n    \n    Jsi_DSInit(&dStr);\n    int isreg = 0;\n\n    if (!arg)\n        name = \"*\";\n    else {\n        if (arg->vt == JSI_VT_STRING)\n            name = arg->d.s.str;\n        else if (arg->vt == JSI_VT_OBJECT) {\n            switch (arg->d.obj->ot) {\n                case JSI_OT_STRING: name = arg->d.obj->d.s.str; break;\n                case JSI_OT_REGEXP: isreg = 1; break;\n                case JSI_OT_FUNCTION:\n                    spec = arg->d.obj->d.fobj->func->cmdSpec;\n                    if (!spec)\n                        return JSI_OK;\n                    skey = spec->name;\n                    goto dumpfunc;\n                    break;\n                default: return JSI_OK;\n            }\n        } else\n            return JSI_OK;\n    }\n    ninc = 0;\n    isglob = (isreg == 0 && name && (Jsi_Strchr(name,'*') || Jsi_Strchr(name,'[')));\n    if (isglob) {\n        cp = name;\n        while (*cp) { if (*cp == '.') dots++; cp++; }\n    }\n    while (1) {\n        if (++icnt == 1) {\n           /* if (0 && name)\n                hPtr = Jsi_MapEntryFind(interp->cmdSpecTbl, \"\");\n            else */ {\n                hPtr = Jsi_MapSearchFirst(interp->cmdSpecTbl, &search, 0);\n                gotFirst = 1;\n            }\n        } else if (icnt == 2 && name && !gotFirst)\n            hPtr = Jsi_MapSearchFirst(interp->cmdSpecTbl, &search, 0);\n        else\n            hPtr = Jsi_MapSearchNext(&search);\n        if (!hPtr)\n            break;\n        csi = (Jsi_CmdSpecItem*)Jsi_MapValueGet(hPtr);\n        key = (const char *)Jsi_MapKeyGet(hPtr, 0);\n        if (isglob && dots == 0 && *key && Jsi_GlobMatch(name, key, 0) && !Jsi_Strchr(key, '.')) {\n                Jsi_ObjArraySet(interp, nobj, Jsi_ValueNewStringKey(interp, key), curlen++);\n                ninc++;\n        }\n        if (isglob == 0 && name && key[0] && Jsi_Strcmp(name, key)==0) {\n            skey = (char*)name;\n            spec = NULL;\n            goto dumpfunc;\n        }\n        assert(csi);\n        do {\n            int i;\n            for (i=0; csi->spec[i].name; i++) {\n                Jsi_DSSetLength(&dStr, 0);\n                spec = csi->spec+i;\n                if (i==0 && spec->flags&JSI_CMD_IS_CONSTRUCTOR && !all) /* ignore constructor name. */\n                    continue;\n                if (key[0])\n                    Jsi_DSAppend(&dStr, key, \".\", NULL);\n                Jsi_DSAppend(&dStr, spec->name, NULL);\n                skey = Jsi_DSValue(&dStr);\n                if (isglob) {\n                    if (!(((key[0]==0 && dots == 0) || (key[0] && dots == 1)) &&\n                        Jsi_GlobMatch(name, skey, 0)))\n                    continue;\n                }\n                if (name && isglob == 0 && Jsi_Strcmp(name,skey) == 0) {\ndumpfunc:\n                    nobj = Jsi_ObjNew(interp);\n                    Jsi_ValueMakeObject(interp, ret, nobj);\n                    if (spec == NULL)\n                        jsi_DumpCmdItem(interp, nobj, csi, skey);\n                    else\n                        jsi_DumpCmdSpec(interp, nobj, spec, skey);\n                    Jsi_DSFree(&dStr);\n                    return JSI_OK;\n                    \n                } else if (isglob == 0 && isreg == 0)\n                    continue;\n                if (isreg) {\n                    int ismat;\n                    Jsi_RegExpMatch(interp, arg, skey, &ismat, NULL);\n                    if (!ismat)\n                        continue;\n                }\n                Jsi_ObjArraySet(interp, nobj, Jsi_ValueNewStringKey(interp, tail?spec->name:skey), curlen++);\n                ninc++;\n            }\n            csi = csi->next;\n        } while (csi);\n    }\n    Jsi_DSFree(&dStr);\n    if (sort && (*ret)->vt != JSI_VT_UNDEF)\n        Jsi_ValueArraySort(interp, *ret, 0);\n    return JSI_OK;    \n}\n\n// TODO: does not show loaded commands.\nstatic Jsi_RC InfoCmdsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    InfoCmdsData data = {};\n    Jsi_Value *vo = Jsi_ValueArrayIndex(interp, args, 1);\n    if (vo) {\n        if (!Jsi_ValueIsObjType(interp, vo, JSI_OT_OBJECT)) /* Future options. */\n            return Jsi_LogError(\"arg2: expected object 'options'\");\n        if (Jsi_OptionsProcess(interp, InfoCmdsOptions, &data, vo, 0) < 0) {\n            return JSI_ERROR;\n        }\n    }\n\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_Obj *nobj = Jsi_ObjNew(interp);\n    Jsi_ValueMakeArrayObject(interp, ret, nobj);\n    int ff = (data.full ? 0 : 2);\n    return InfoCmdsCmdSub(interp, arg, _this, ret, funcPtr, data.constructor, 1, nobj, ff);\n}\n\n\nstatic Jsi_RC InfoMethodsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_RC rc = InfoFuncDataSub(interp, arg, _this, ret, funcPtr, 1, NULL);\n    if (rc == JSI_OK && Jsi_ValueIsArray(interp, *ret)) {\n        Jsi_Obj *nobj = (*ret)->d.obj;\n        InfoCmdsCmdSub(interp, arg, _this, ret, funcPtr, 0, 1, nobj, 3);\n    }\n    return rc;\n}\n\nstatic Jsi_RC InfoLocalsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n   // if (!interp->framePtr->funcName)\n   //     return Jsi_LogError(\"Not in function\");\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);\n    bool varsOnly = 0;\n    if (arg)\n        Jsi_ValueGetBoolean(interp, arg, &varsOnly);\n    Jsi_ValueMakeObject(interp, ret, NULL);\n    Jsi_Value *cs = interp->framePtr->incsc;\n    Jsi_Obj *nobj = (*ret)->d.obj;\n    Jsi_TreeEntry* tPtr;\n    Jsi_TreeSearch search;\n    for (tPtr = Jsi_TreeSearchFirst(cs->d.obj->tree, &search, 0, NULL);\n        tPtr; tPtr = Jsi_TreeSearchNext(&search)) {\n        Jsi_Value *v = (Jsi_Value*)Jsi_TreeValueGet(tPtr);\n        if (v==NULL) continue;\n        if (Jsi_ValueIsFunction(interp, v)) {\n            if (varsOnly) continue;\n        } else {\n            if (arg && !varsOnly) continue;\n        }\n\n        const char* key = (char*)Jsi_TreeKeyGet(tPtr);\n        Jsi_ObjInsert(interp, nobj, key, v, 0);\n    }\n    Jsi_TreeSearchDone(&search);\n\n    return JSI_OK;\n}\n\nstatic Jsi_RC InfoCompletionsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int slen, argc = Jsi_ValueGetLength(interp, args);\n    Jsi_Value *arg1 = Jsi_ValueArrayIndex(interp, args, 0);\n    char *key, *substr, *str = Jsi_ValueString(interp, arg1, &slen);\n    int start = 0, end = slen-1;\n    if (!str)\n        return JSI_ERROR;\n    if (argc>1) {\n        Jsi_Number n1;\n        if (Jsi_GetNumberFromValue(interp, Jsi_ValueArrayIndex(interp, args, 1), &n1) != JSI_OK)\n            return JSI_ERROR;\n        start = (int)n1;\n        if (start<0) start = 0;\n        if (start>=slen) start=slen-1;\n    }\n    if (argc>2) {\n        Jsi_Number n2;\n        if (Jsi_GetNumberFromValue(interp, Jsi_ValueArrayIndex(interp, args, 2), &n2) != JSI_OK)\n            return JSI_ERROR;\n        end = (int)n2;\n        if (end<0) end = slen-1;\n        if (end>=slen) end=slen-1;\n    }\n\n    Jsi_DString dStr = {};\n    Jsi_DSAppendLen(&dStr, str?str+start:\"\", end-start+1);\n    Jsi_DSAppend(&dStr, \"*\", NULL);\n    substr = Jsi_DSValue(&dStr);\n    Jsi_Value *arg = Jsi_ValueNewStringDup(interp, substr);\n    Jsi_IncrRefCount(interp, arg);\n    \n    Jsi_Obj *nobj = Jsi_ObjNew(interp);\n    Jsi_ValueMakeArrayObject(interp, ret, nobj);\n\n    Jsi_RC rc = InfoCmdsCmdSub(interp, arg, _this, ret, funcPtr, 0, 0, nobj, 0);\n    if (rc != JSI_OK || (Jsi_ValueIsArray(interp, *ret) && (*ret)->d.obj->arrCnt>0))\n        goto done;\n    rc = InfoFuncDataSub(interp, arg, _this, ret, funcPtr, 0x7, nobj);\n    if (rc != JSI_OK || (Jsi_ValueIsArray(interp, *ret) && (*ret)->d.obj->arrCnt>0))\n        goto done;\n    if (str) {\n        substr[end-start+1] = 0;\n        slen = Jsi_Strlen(substr);\n    }\n    if (str == NULL || !Jsi_Strchr(substr, '.')) {\n        Jsi_HashEntry *hPtr;\n        Jsi_HashSearch search;\n        int n = Jsi_ValueGetLength(interp, *ret);\n        for (hPtr = Jsi_HashSearchFirst(interp->lexkeyTbl, &search);\n            hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {\n            key = (char*)Jsi_HashKeyGet(hPtr);\n            if (str == NULL || !Jsi_Strncmp(substr, key, slen))\n                Jsi_ValueArraySet(interp, *ret, Jsi_ValueNewStringKey(interp, key), n++);\n        }\n    }\n    Jsi_ValueArraySort(interp, *ret, 0);\ndone:\n    Jsi_DSFree(&dStr);\n    Jsi_DecrRefCount(interp, arg);\n    return rc;\n}\n\nJsi_Value * Jsi_LookupCS(Jsi_Interp *interp, const char *name, int *ofs)\n{\n    const char *csdot = Jsi_Strrchr(name, '.');\n    int len;\n    *ofs = 0;\n    if (csdot == name)\n        return NULL;\n    if (!csdot)\n        return interp->csc;\n    if (!csdot[1])\n        return NULL;\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    Jsi_DSAppendLen(&dStr, name, len=csdot-name);\n    Jsi_Value *cs = Jsi_NameLookup(interp, Jsi_DSValue(&dStr));\n    Jsi_DSFree(&dStr);\n    *ofs = len+1;\n    return cs;\n}\n\nstatic void ValueObjDeleteStr(Jsi_Interp *interp, Jsi_Value *target, const char *key, int force)\n{\n    const char *kstr = key;\n    if (target->vt != JSI_VT_OBJECT) return;\n\n    Jsi_TreeEntry *hPtr;\n    Jsi_MapEntry *hePtr = Jsi_MapEntryFind(target->d.obj->tree->opts.interp->strKeyTbl, key);\n    if (hePtr)\n        kstr = (const char*)Jsi_MapKeyGet(hePtr, 0);\n    hPtr = Jsi_TreeEntryFind(target->d.obj->tree, kstr);\n    if (hPtr == NULL || ( hPtr->f.bits.dontdel && !force))\n        return;\n    Jsi_TreeEntryDelete(hPtr);\n}\n\nJsi_RC Jsi_CommandDelete(Jsi_Interp *interp, const char *name) {\n    int ofs;\n    Jsi_Value *fv = Jsi_NameLookup(interp, name);\n    Jsi_Value *cs = Jsi_LookupCS(interp, name, &ofs);\n    if (cs) {\n        const char *key = name + ofs;\n        ValueObjDeleteStr(interp, cs, key, 1);\n    }\n    if (fv)\n        Jsi_DecrRefCount(interp, fv);\n    return JSI_OK;\n}\n\n\nJsi_Value * jsi_CommandCreate(Jsi_Interp *interp, const char *name, Jsi_CmdProc *cmdProc, void *privData, int flags, Jsi_CmdSpec *cspec)\n{\n    Jsi_Value *n = NULL;\n    const char *csdot = Jsi_Strrchr(name, '.');\n    if (0 && csdot) {\n        Jsi_LogBug(\"commands with dot unsupported: %s\", name);\n        return NULL;\n    }\n    if (csdot == name) {\n        name = csdot+1;\n        csdot = NULL;\n    }\n    if (!csdot) {\n        n = jsi_MakeFuncValue(interp, cmdProc, name, NULL, cspec);\n        Jsi_IncrRefCount(interp, n);\n        Jsi_ObjDecrRefCount(interp, n->d.obj);\n        Jsi_Func *f = n->d.obj->d.fobj->func;\n        f->privData = privData;\n        f->name = Jsi_KeyAdd(interp, name);\n        Jsi_ValueInsertFixed(interp, interp->csc, f->name, n);\n        return n;\n    }\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    Jsi_DSAppendLen(&dStr, name, csdot-name);\n    Jsi_Value *cs = Jsi_NameLookup(interp, Jsi_DSValue(&dStr));\n    Jsi_DSFree(&dStr);\n    if (cs) {\n    \n        n = jsi_MakeFuncValue(interp, cmdProc, csdot+1, NULL, cspec);\n        Jsi_IncrRefCount(interp, n);\n        Jsi_ObjDecrRefCount(interp, n->d.obj);\n        Jsi_Func *f = n->d.obj->d.fobj->func;\n        \n        f->name = Jsi_KeyAdd(interp, csdot+1);\n        f->privData = privData;\n        Jsi_ValueInsertFixed(interp, cs, f->name, n);\n        //Jsi_ObjDecrRefCount(interp, n->d.obj);\n    }\n    return n;\n}\n\nJsi_Value * Jsi_CommandCreate(Jsi_Interp *interp, const char *name, Jsi_CmdProc *cmdProc, void *privData)\n{\n    Jsi_Value *v = jsi_CommandCreate(interp, name, cmdProc, privData, 1, 0);\n    if (v)\n        Jsi_HashSet(interp->genValueTbl, v, v);\n    return v;\n}\n\n// Sanity check builtin args signature.\nbool jsi_CommandArgCheck(Jsi_Interp *interp, Jsi_CmdSpec *cmdSpec, Jsi_Func *f, const char *parent)\n{\n    bool rc = 1;\n    Jsi_DString dStr = {};\n    Jsi_DSAppend(&dStr, cmdSpec->argStr, NULL);\n    const char *elips = Jsi_Strstr(cmdSpec->argStr, \"...\");\n    if (cmdSpec->maxArgs<0 && !elips)\n        Jsi_DSAppend(&dStr, \", ...\", NULL);\n    int aCnt = 0, i = -1;\n    char *cp = Jsi_DSValue(&dStr);\n    while (cp[++i]) if (cp[i]==',') aCnt++;\n    \n    if (cmdSpec->maxArgs>=0) {\n        aCnt++;\n        if (cmdSpec->minArgs<0 || cmdSpec->minArgs>cmdSpec->maxArgs || \n            cmdSpec->minArgs>aCnt || cmdSpec->maxArgs>aCnt || elips) {\n            rc = 0;\n        }                    \n    } else {\n        if (cmdSpec->minArgs<0 || cmdSpec->minArgs>aCnt) {\n            rc = 0;\n        }                    \n    }\n    Jsi_DSFree(&dStr);\n    if (!rc) {\n        jsi_TypeMismatch(interp);\n        Jsi_LogWarn(\"inconsistent arg string for \\\"%s.%s(%s)\\\" [%d,%d]\",\n            parent, cmdSpec->name, cmdSpec->argStr, cmdSpec->minArgs, cmdSpec->maxArgs);\n    }\n    if (f->argnames==NULL && cmdSpec->argStr) {\n        // At least give a clue where the problem is.\n        const char *ocfile = interp->curFile;\n        jsi_Pline *opl = interp->parseLine, pline;\n        interp->parseLine = &pline;\n        pline.first_line = 1;\n        interp->curFile = cmdSpec->name;\n        f->argnames = jsi_ParseArgStr(interp, cmdSpec->argStr);\n        interp->curFile = ocfile;\n        interp->parseLine = opl;\n    }\n    return rc;\n}\n\nstatic Jsi_Value *CommandCreateWithSpec(Jsi_Interp *interp, Jsi_CmdSpec *cSpec, int idx, Jsi_Value *proto, void *privData,\n    const char *parentName, jsi_PkgInfo *pkg)\n{\n    Jsi_CmdSpec *cmdSpec = cSpec+idx;\n    int iscons = (cmdSpec->flags&JSI_CMD_IS_CONSTRUCTOR);\n    Jsi_Value *func = NULL;\n    Jsi_Func *f;\n    if (cmdSpec->name)\n        Jsi_KeyAdd(interp, cmdSpec->name);\n    if (cmdSpec->proc == NULL)\n    {\n        func = jsi_ProtoObjValueNew1(interp, cmdSpec->name);\n        Jsi_ValueInsertFixed(interp, NULL, cmdSpec->name, func);\n        f = func->d.obj->d.fobj->func;\n    } else {\n    \n        func = jsi_MakeFuncValueSpec(interp, cmdSpec, privData);\n    #ifdef JSI_MEM_DEBUG\n        func->VD.label = \"CMDspec\";\n        func->VD.label2 = cmdSpec->name;\n    #endif\n        //Jsi_IncrRefCount(interp, func);\n        //Jsi_HashSet(interp->genValueTbl, func, func);\n        Jsi_ValueInsertFixed(interp, (iscons?NULL:proto), cmdSpec->name, func);\n        f = func->d.obj->d.fobj->func;\n    \n        if (cmdSpec->name)\n            f->name = cmdSpec->name;\n        f->f.flags = (cmdSpec->flags & JSI_CMD_MASK);\n        f->f.bits.hasattr = 1;\n        if (iscons) {\n            f->f.bits.iscons = 1;\n            Jsi_ValueInsertFixed(interp, func, \"prototype\", proto);\n            Jsi_PrototypeObjSet(interp, \"Function\", Jsi_ValueGetObj(interp, func));\n        }\n    }\n    func->d.obj->d.fobj->func->parentName = parentName;\n    func->d.obj->d.fobj->func->pkg = pkg;\n    func->d.obj->d.fobj->func->parentSpec = cSpec;\n    if (cmdSpec->argStr && interp->typeCheck.all)\n        jsi_CommandArgCheck(interp, cmdSpec, f, parentName);\n\n    f->retType = cmdSpec->retType;\n    if (f->retType & JSI_TT_UNDEFINED)\n        Jsi_LogBug(\"illegal use of 'undefined' in a return type: %s\", cmdSpec->name);\n    return func;\n}\n\n\nJsi_Value *Jsi_CommandCreateSpecs(Jsi_Interp *interp, const char *name, Jsi_CmdSpec *cmdSpecs,\n    void *privData, int flags)\n{\n    int i = 0;\n    Jsi_Value *proto = NULL;\n    Jsi_CmdProc *cmdProc = NULL;\n    if (!cmdSpecs[0].name)\n        return NULL;\n    if (!name)\n        name = cmdSpecs[0].name;\n    name = Jsi_KeyAdd(interp, name);\n    if (flags & JSI_CMDSPEC_PROTO) {\n        proto = (Jsi_Value*)privData;\n        privData = NULL;\n        i++;\n    /*} else if (!Jsi_Strcmp(name, cmdSpecs[0].name)) {\n        cmdProc = cmdSpecs[0].proc;\n        i++;*/\n    } else if (!*name)\n        proto = NULL;\n    else {\n        if (!(flags & JSI_CMDSPEC_ISOBJ)) {\n            cmdProc = cmdSpecs[0].proc;\n            proto = jsi_CommandCreate(interp, name, cmdProc, privData, 0, cmdSpecs);\n        } else {\n            proto = jsi_ProtoValueNew(interp, name, NULL);\n        }\n    }\n    jsi_PkgInfo *pkg = jsi_PkgGet(interp, name);\n    for (; cmdSpecs[i].name; i++)\n        CommandCreateWithSpec(interp,  cmdSpecs, i, proto, privData, name, pkg);\n\n    bool isNew;\n    Jsi_MapEntry *hPtr = Jsi_MapEntryNew(interp->cmdSpecTbl, name, &isNew);\n    if (!hPtr || !isNew) {\n        Jsi_LogBug(\"failed cmdspec register: %s\", name);\n        return NULL;\n    }\n    Jsi_CmdSpecItem *op, *p = (Jsi_CmdSpecItem*)Jsi_Calloc(1,sizeof(*p));\n    SIGINIT(p,CMDSPECITEM);\n    p->spec = cmdSpecs;\n    p->flags = flags;\n    p->proto = proto;\n    p->privData = privData;\n    p->name = (const char*)Jsi_MapKeyGet(hPtr, 0);\n    p->hPtr = hPtr;\n    Jsi_CmdSpec *csi = cmdSpecs;\n    p->isCons = (csi && csi->flags&JSI_CMD_IS_CONSTRUCTOR);\n    while (csi->name)\n        csi++;\n    p->help = csi->help;\n    p->info = csi->info;\n    if (!isNew) {\n        op = (Jsi_CmdSpecItem*)Jsi_MapValueGet(hPtr);\n        p->next = op;\n    }\n    Jsi_MapValueSet(hPtr, p);\n    return proto;\n}\n\nvoid jsi_CmdSpecDelete(Jsi_Interp *interp, void *ptr)\n{\n    Jsi_CmdSpecItem *cs = (Jsi_CmdSpecItem*)ptr;\n    Jsi_CmdSpec *p;\n    SIGASSERTV(cs,CMDSPECITEM);\n    //return;\n    while (cs) {\n        p = cs->spec;\n        Jsi_Value *proto = cs->proto;\n        if (proto)\n            Jsi_DecrRefCount(interp, proto);\n        while (0 && p && p->name) {\n            /*Jsi_Value *proto = p->proto;\n            if (proto)\n                Jsi_DecrRefCount(interp, proto);*/\n            p++;\n        }\n        ptr = cs;\n        cs = cs->next;\n        Jsi_Free(ptr);\n    }\n}\n\nstatic Jsi_RC SysVerConvertCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_Value *flag = Jsi_ValueArrayIndex(interp, args, 1);\n    if (!val) goto bail;\n    if (Jsi_ValueIsNumber(interp, val)) {\n        char buf[JSI_MAX_NUMBER_STRING*2];\n        Jsi_Number n;\n        if (Jsi_GetNumberFromValue(interp, val, &n) != JSI_OK)\n            goto bail;\n        jsi_VersionNormalize(n, buf, sizeof(buf));\n        int trunc = 0;\n        if (flag && (Jsi_GetIntFromValue(interp, flag, &trunc) != JSI_OK\n            || trunc<0 || trunc>2))\n            return Jsi_LogError(\"arg2: bad trunc: expected int between 0 and 2\");\n        if (trunc) {\n            int len = Jsi_Strlen(buf)-1;\n            while (trunc>0 && len>1) {\n                if (buf[len] == '0' && buf[len-1] == '.')\n                    buf[len-1] = 0;\n                len -= 2;\n                trunc--;\n            }\n        }\n        Jsi_ValueMakeStringDup(interp, ret, buf);\n        return JSI_OK;\n    }\n    if (Jsi_ValueIsString(interp, val)) {\n        Jsi_Number n;\n        if (jsi_GetVerFromVal(interp, val, &n, 0) == JSI_OK) {\n            Jsi_ValueMakeNumber(interp, ret, n);\n            return JSI_OK;\n        }\n    }\nbail:\n    Jsi_ValueMakeNull(interp, ret);\n    return JSI_OK;\n}\n\nstatic void jsi_sysTypeGet(Jsi_Interp *interp, Jsi_Value *arg, Jsi_DString *dStr) {\n    Jsi_DSFree(dStr);\n    if (!Jsi_ValueIsObjType(interp, arg, JSI_OT_OBJECT)) {\n        Jsi_DSAppend(dStr, jsi_ValueTypeName(interp, arg), NULL);\n        return;\n    }\n    uint i;\n    const char *pre = \"\";\n    Jsi_DSAppend(dStr, \"{\", NULL);\n    Jsi_IterObj *io = Jsi_IterObjNew(interp, NULL);\n    Jsi_IterGetKeys(interp, arg, io, 0);\n    for (i=0; i<io->count; i++) {\n        Jsi_Value *targ = Jsi_ValueObjLookup(interp, arg, io->keys[i], true);\n        Jsi_DSAppend(dStr, pre, io->keys[i], \":\", jsi_ValueTypeName(interp, targ), NULL);\n        pre = \",\";\n    }\n    Jsi_DSAppend(dStr, \"}\", NULL);\n    Jsi_IterObjFree(io);\n}\n\nstatic Jsi_RC SysMatchObjCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char *sp, *cp, *cs, *ss, *ce, *cc;\n    bool ok = 1, partial=0, noerror;\n    Jsi_Value *arg1 = Jsi_ValueArrayIndex(interp, args, 0);\n    if (!arg1 || !Jsi_ValueIsObjType(interp, arg1, JSI_OT_OBJECT))\n        return Jsi_LogError(\"arg 1: exected object\");\n    Jsi_Value *arg2 = Jsi_ValueArrayIndex(interp, args, 1),\n        *arg3 = Jsi_ValueArrayIndex(interp, args, 2),\n        *arg4 = Jsi_ValueArrayIndex(interp, args, 3);\n    \n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    Jsi_RC rc = JSI_OK;\n    if (!arg2) {\n        jsi_sysTypeGet(interp, arg1, &dStr);\n        Jsi_ValueMakeStringDup(interp, ret, Jsi_DSValue(&dStr));\n        Jsi_ValueFromDS(interp, &dStr, ret);\n        return JSI_OK;\n    }\n    sp = Jsi_ValueString(interp, arg2, NULL);\n    if (!sp) {\n        rc = Jsi_LogError(\"arg 2: exected string\");\n        goto done;\n    }\n    if (arg3 && Jsi_GetBoolFromValue(interp, arg3, &partial) != JSI_OK) {\n        rc = Jsi_LogError(\"expected bool 'partial'\");\n        goto done;\n    }\n    if (arg3 && Jsi_GetBoolFromValue(interp, arg4, &noerror) != JSI_OK) {\n        rc = Jsi_LogError(\"expected bool 'noerror'\");\n        goto done;\n    }\n    jsi_sysTypeGet(interp, arg1, &dStr);\n    cp = Jsi_DSValue(&dStr);\n    if (sp) {\n        if (Jsi_Strcmp(cp, sp)) {\n            if (partial && *cp && *sp) {\n                /*Jsi_DString eStr = {}, fStr = {};\n                char *ss = Jsi_AppendLen(&eStr, sp+1, Jsi_Strlen(sp)-2);\n                int vargc; char **vargv;\n                Jsi_SplitStr(Jsi_DSValue(&eStr), &vargc, &vargv, \",\", &fStr);*/\n                cs=cp+1; ss=sp;\n                while (*cs) {\n                    Jsi_DString eStr = {};\n                    ce=Jsi_Strchr(cs,','); \n                    if (!ce) ce = cs+Jsi_Strlen(cs);\n                    Jsi_DSAppend(&eStr, \",\", NULL);\n                    int elen = ce-cs;\n                    cc = Jsi_DSAppendLen(&eStr, cs, elen); // obj key.\n                    int dlen = Jsi_Strlen(cc);\n                    if (dlen>1 && cc[dlen-1]=='}')\n                        cc[--dlen] = 0;\n                    if (*ss=='{' && !Jsi_Strncmp(ss+1, cc+1, dlen-1))\n                        ss = ss+dlen;\n                    else\n                        ss = Jsi_Strstr(ss, cc);\n                    Jsi_DSFree(&eStr);\n                    if (!ss) goto mismatch;\n                    cs=(*ce?ce+1:ce);\n                }\n                goto done;\n            }\nmismatch:\n            ok = 0;\n            if (interp->asserts && !noerror)\n                rc = Jsi_LogError(\"matchobj failed: expected '%s' not '%s'\", cp, sp); \n            else\n                Jsi_LogWarn(\"matchobj failed: expected '%s' not '%s'\", cp, sp);\n        }\n        //goto done;\n    }\ndone:\n    Jsi_DSFree(&dStr);\n    if (rc == JSI_OK)\n        Jsi_ValueMakeBool(interp, ret, ok);\n    return rc;\n    \n/*badstr:\n    Jsi_DSFree(&dStr);\n    return Jsi_LogError(\"array elements must be a string\");*/\n\n}\n\nstatic Jsi_RC SysTimesCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_RC rc = JSI_OK;\n    int i, n=1, argc = Jsi_ValueGetLength(interp, args);\n    Jsi_Value *func = Jsi_ValueArrayIndex(interp, args, 0);\n    if (Jsi_ValueIsBoolean(interp, func)) {\n        bool bv;\n        if (argc != 1)\n            return Jsi_LogError(\"bool must be only arg\");\n        Jsi_GetBoolFromValue(interp, func, &bv);\n        double now = jsi_GetTimestamp();\n        if (bv)\n            interp->timesStart = now;\n        else {\n            char buf[JSI_MAX_NUMBER_STRING];\n            snprintf(buf, sizeof(buf), \" (times = %.6f sec)\\n\", (now-interp->timesStart));\n            Jsi_Puts(interp, jsi_Stderr, buf, -1);\n        }\n        Jsi_ValueMakeNumber(interp, ret, 0);\n        return JSI_OK;\n    }\n    Jsi_Wide diff, start, end;\n    if (!Jsi_ValueIsFunction(interp, func))\n        return Jsi_LogError(\"arg1: expected function|bool\");\n    if (argc > 1 && Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, 1), &n) != JSI_OK)\n        return JSI_ERROR;\n    if (n<=0) \n        return Jsi_LogError(\"count not > 0: %d\", n);\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    start = (Jsi_Wide) tv.tv_sec * 1000000 + tv.tv_usec;\n    for (i=0; i<n && rc == JSI_OK; i++) {\n        rc = Jsi_FunctionInvoke(interp, func, NULL, ret, NULL);\n    }\n    gettimeofday(&tv, NULL);\n    end = (Jsi_Wide) tv.tv_sec * 1000000 + tv.tv_usec;\n    diff = (end - start);\n    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)diff);\n    return rc;\n}\n\nstatic Jsi_RC SysFormatCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_DString dStr;\n    Jsi_RC rc = Jsi_FormatString(interp, args, &dStr);\n    if (rc != JSI_OK)\n        return rc;\n    Jsi_ValueFromDS(interp, &dStr, ret);\n    return JSI_OK;\n}\n\nstatic Jsi_RC SysQuoteCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_DString dStr = {};\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);\n    const char *str = Jsi_ValueGetDString(interp, arg, &dStr, 1);\n    Jsi_ValueMakeStringDup(interp, ret, str);\n    Jsi_DSFree(&dStr);\n    return JSI_OK;\n}\n// Karl Malbrain's compact CRC-32. See \"A compact CCITT crc16 and crc32 C implementation that balances processor cache usage against speed\": http://www.geocities.com/malbrain/\nuint32_t Jsi_Crc32(uint32_t crc, const void *ptr, size_t buf_len)\n{\n    static const uint32_t s_crc32[16] = {\n        0x00000000, 0x1db71064, 0x3b6e20c8, 0x26d930ac, 0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c,\n        0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c, 0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c\n    };\n    uint32_t crcu32 = (uint32_t)crc;\n    uchar *uptr = (uchar *)ptr;\n    if (!uptr) return 0;\n    crcu32 = ~crcu32;\n    while (buf_len--) {\n        uchar b = *uptr++;\n        crcu32 = (crcu32 >> 4) ^ s_crc32[(crcu32 & 0xF) ^ (b & 0xF)];\n        crcu32 = (crcu32 >> 4) ^ s_crc32[(crcu32 & 0xF) ^ (b >> 4)];\n    }\n    return ~crcu32;\n}\n\nstatic Jsi_RC SysCrc32Cmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int ilen;\n    char *inbuffer = Jsi_ValueArrayIndexToStr(interp, args, 0, &ilen);\n    Jsi_Number crc = 0;\n    int argc = Jsi_ValueGetLength(interp, args);\n    if (argc>1)\n        Jsi_ValueGetNumber(interp, Jsi_ValueArrayIndex(interp, args, 1), &crc);\n    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)Jsi_Crc32((uint32_t)crc, (uchar*)inbuffer, ilen));\n    return JSI_OK;\n}\n\n#ifndef JSI_OMIT_BASE64\nstatic const char b64ev[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\nstatic int atend;\n\nstatic int\nb64getidx(const char *buffer, int len, int *posn) {\n    char c;\n    char *idx;\n    if (atend) return -1;\n    do {\n    if ((*posn)>=len) {\n        atend = 1;\n        return -1;\n    }\n    c = buffer[(*posn)++];\n    if (c<0 || c=='=') {\n        atend = 1;\n        return -1;\n    }\n    idx = Jsi_Strchr(b64ev, c);\n    } while (!idx);\n    return idx - b64ev; \n} \n\nstatic void B64DecodeDStr(const char *inbuffer, int ilen, Jsi_DString *dStr)\n{\n    int olen, pos;\n    char outbuffer[3];\n    int c[4];\n    \n    pos = 0; \n    atend = 0;\n    while (!atend) {\n        if (inbuffer[pos]=='\\n' ||inbuffer[pos]=='\\r') { pos++; continue; }\n        c[0] = b64getidx(inbuffer, ilen, &pos);\n        c[1] = b64getidx(inbuffer, ilen, &pos);\n        c[2] = b64getidx(inbuffer, ilen, &pos);\n        c[3] = b64getidx(inbuffer, ilen, &pos);\n\n        olen = 0;\n        if (c[0]>=0 && c[1]>=0) {\n            outbuffer[0] = ((c[0]<<2)&0xfc)|((c[1]>>4)&0x03);\n            olen++;\n            if (c[2]>=0) {\n                outbuffer[1] = ((c[1]<<4)&0xf0)|((c[2]>>2)&0x0f);\n                olen++;\n                if (c[3]>=0) {\n                    outbuffer[2] = ((c[2]<<6)&0xc0)|((c[3])&0x3f);\n                    olen++;\n                }\n            }\n        }\n\n        if (olen>0)\n            Jsi_DSAppendLen(dStr, outbuffer, olen);\n        olen = 0;\n    }\n    if (olen>0)\n        Jsi_DSAppendLen(dStr, outbuffer, olen);\n}\n\nstatic Jsi_RC B64Decode(Jsi_Interp *interp, char *inbuffer, int ilen, Jsi_Value **ret)\n{\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    B64DecodeDStr(inbuffer, ilen, &dStr);\n    Jsi_ValueFromDS(interp, &dStr, ret);\n    return JSI_OK;\n}\n\nstatic Jsi_RC\nB64EncodeDStr(const char *ib, int ilen, Jsi_DString *dStr)\n{\n    int i=0, pos=0;\n    char c[74];\n    \n    while (pos<ilen) {\n#define PPDCS(n,s) ((pos+n)>ilen?'=':b64ev[s])\n        c[i++]=b64ev[(ib[pos]>>2)&0x3f];\n        c[i++]=PPDCS(1,((ib[pos]<<4)&0x30)|((ib[pos+1]>>4)&0x0f));\n        c[i++]=PPDCS(2,((ib[pos+1]<<2)&0x3c)|((ib[pos+2]>>6)&0x03));\n        c[i++]=PPDCS(3,ib[pos+2]&0x3f);\n        if (i>=72) {\n            c[i++]='\\n';\n            c[i]=0;\n            Jsi_DSAppendLen(dStr, c, i);\n            i=0;\n        }\n        pos+=3;\n    }\n    if (i) {\n        /*    c[i++]='\\n';*/\n        c[i]=0;\n        Jsi_DSAppendLen(dStr, c, i);\n        i=0;\n    }\n    return JSI_OK;\n}\n\nstatic Jsi_RC\nB64Encode(Jsi_Interp *interp, char *ib, int ilen, Jsi_Value **ret)\n{\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    B64EncodeDStr(ib, ilen, &dStr);\n    Jsi_ValueFromDS(interp, &dStr, ret);\n    return JSI_OK;\n}\n\nJsi_RC Jsi_Base64(const char *str, int len, Jsi_DString *dStr, bool decode)\n{\n    if (len<0)\n        len = Jsi_Strlen(str);\n    if (decode)\n        B64DecodeDStr(str, len, dStr);\n    else\n        B64EncodeDStr(str, len, dStr);\n    return JSI_OK;\n}\n\nstatic Jsi_RC B64DecodeCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int ilen;\n    char *inbuffer = Jsi_ValueArrayIndexToStr(interp, args, 0, &ilen);\n    return B64Decode(interp, inbuffer, ilen, ret);\n}\n\nstatic Jsi_RC B64EncodeCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int ilen;\n    char *inbuffer = Jsi_ValueArrayIndexToStr(interp, args, 0, &ilen);\n    return B64Encode(interp, inbuffer, ilen, ret);\n}\n\nstatic Jsi_RC SysBase64Cmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 1);\n    bool dec = 0;\n    if (arg && Jsi_GetBoolFromValue(interp, arg, &dec) != JSI_OK) \n        return Jsi_LogError(\"arg2: expected bool 'decode'\");\n    if (dec)\n        return B64DecodeCmd(interp, args, _this, ret, funcPtr);\n    else\n        return B64EncodeCmd(interp, args, _this, ret, funcPtr);\n}\n\nstatic Jsi_RC SysArgArrayCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);\n    if (!arg)\n        Jsi_ValueMakeNull(interp, ret);\n    else if (Jsi_ValueIsArray(interp, arg) || Jsi_ValueIsNull(interp, arg))\n        Jsi_ValueCopy(interp, *ret, arg);\n    else\n        Jsi_ValueMakeArrayObject(interp, ret, Jsi_ObjNewArray(interp, &arg, 1, 1));\n    return JSI_OK;\n}\n\nstatic Jsi_RC SysCompleteCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    bool bal = 0;\n    char *arg = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    if (arg)\n        bal = jsi_StrIsBalanced(arg);\n    Jsi_ValueMakeBool(interp, ret, bal);\n    return JSI_OK;\n}\n\nstatic Jsi_RC SysHexStrCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 1);\n    bool dec = 0;\n    if (arg && Jsi_GetBoolFromValue(interp, arg, &dec) != JSI_OK) \n        return Jsi_LogError(\"arg2: expected bool 'decode'\");\n    int len;\n    const char *str = Jsi_ValueArrayIndexToStr(interp, args, 0, &len);\n    if (!str || len<=0)\n        return Jsi_LogError(\"expected string\");\n    Jsi_DString dStr = {};\n    if (Jsi_HexStr((const uchar*)str, len, &dStr, dec)<0) {\n        Jsi_DSFree(&dStr);\n        return Jsi_LogError(\"invalid hex string\");\n    }\n    Jsi_ValueFromDS(interp, &dStr, ret);\n    return JSI_OK;\n}\n#endif\n\n\nstatic const char *hashTypeStrs[] = { \"sha256\", \"sha1\", \"md5\", \"sha3_224\", \"sha3_384\", \"sha3_512\", \"sha3_256\", NULL };\n\ntypedef struct {\n    uint hashcash;\n    Jsi_Value *file;\n    Jsi_CryptoHashType type;\n    bool noHex;\n} HashOpts;\n\n\nstatic Jsi_OptionSpec HashOptions[] = {\n    JSI_OPT(STRING,  HashOpts, file,      .help=\"Read data from file and append to str\" ),\n    JSI_OPT(UINT,    HashOpts, hashcash,  .help=\"Search for a hash with this many leading zero bits by appending :nonce (Proof-Of-Work)\" ),\n    JSI_OPT(BOOL,    HashOpts, noHex,     .help=\"Return binary digest, without conversion to hex chars\" ),\n    JSI_OPT(CUSTOM,  HashOpts, type,      .help=\"Type of hash\", .flags=0, .custom=Jsi_Opt_SwitchEnum, .data=hashTypeStrs ),\n    JSI_OPT_END(HashOpts, .help=\"Options for hash\")\n};\n\nstatic Jsi_RC SysHashCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int n, hasopts = 0, olen;\n    const char *cp = NULL;\n    Jsi_RC rc = JSI_OK;\n    Jsi_DString dStr = {};\n    HashOpts edata = {};\n    char zbuf[1024];\n    \n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);\n    if (!arg || !Jsi_ValueIsString(interp, arg))\n        return Jsi_LogError(\"arg 1: expected string\");\n        \n    cp=Jsi_ValueString(interp, arg, &n);\n    Jsi_DSAppendLen(&dStr, cp, n);\n    Jsi_Value *opt = Jsi_ValueArrayIndex(interp, args, 1);\n    if (opt) {\n        if (opt->vt != JSI_VT_OBJECT || opt->d.obj->ot != JSI_OT_OBJECT)\n            return Jsi_LogError(\"arg1: expected object 'options'\");\n        if (Jsi_OptionsProcess(interp, HashOptions, &edata, opt, 0) < 0)\n            return JSI_ERROR;\n        hasopts = 1;\n    }\n    \n    if (edata.file) {\n        Jsi_Channel in = Jsi_Open(interp, edata.file, \"rb\");\n        \n        if( in==0 ) {\n            rc = Jsi_LogError(\"unable to open file\");\n            goto done;\n        }\n        for(;;) {\n            int n;\n            n = Jsi_Read(interp, in, zbuf, sizeof(zbuf));\n            if( n<=0 ) break;\n            Jsi_DSAppendLen(&dStr, zbuf, n);;\n        }\n        Jsi_Close(interp, in);\n    }\n    cp = Jsi_DSValue(&dStr);\n    n = Jsi_DSLength(&dStr);\n    memset(zbuf, 0, sizeof(zbuf));\n    Jsi_CryptoHash(zbuf, cp, n, edata.type, edata.hashcash, edata.noHex, &olen);\n        \ndone:\n    Jsi_DSFree(&dStr);\n    if (hasopts)\n        Jsi_OptionsFree(interp, HashOptions, &edata, 0);\n    if (rc == JSI_OK) {\n        jsi_ValueMakeBlobDup(interp, ret, (uchar*)zbuf, olen);\n    }\n    return rc;\n\n}\n\n\n#ifndef JSI_OMIT_ENCRYPT\n\n#define FN_encrypt JSI_INFO(\"\\\nKeys that are not 16 bytes use the MD5 hash of the key.\")\nstatic Jsi_RC SysEncryptCmd_(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr, bool decrypt)\n{\n    int ilen, klen;\n    Jsi_RC rc = JSI_OK;\n    const char *key, *str = Jsi_ValueArrayIndexToStr(interp, args, 0, &ilen);\n    Jsi_DString dStr = {};\n    if (!str || !ilen) \n        return Jsi_LogError(\"data must be a non-empty string\");\n    if (decrypt && (ilen%4) != 1) {\n        rc = Jsi_LogError(\"data length incorrect and can not be decrypted\");\n        goto done;\n    }\n    key = Jsi_ValueArrayIndexToStr(interp, args, 1, &klen);\n    Jsi_DSAppendLen(&dStr, str, ilen);\n    rc = Jsi_Encrypt(interp, &dStr, key, klen, decrypt);\n\n    if (rc == JSI_OK)\n        Jsi_ValueMakeDStringObject(interp, ret, &dStr);\n    else\n        Jsi_DSFree(&dStr);\ndone:\n    return rc;\n}\nstatic Jsi_RC SysEncryptCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    return SysEncryptCmd_(interp, args, _this, ret, funcPtr, 0);\n}\nstatic Jsi_RC SysDecryptCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    return SysEncryptCmd_(interp, args, _this, ret, funcPtr, 1);\n}\n#endif\n\nstatic Jsi_RC SysFromCharCodeCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char unibuf[JSI_BUFSIZ+1];\n    int i = 1;    \n    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n    if (!v) return Jsi_LogError(\"arg1: expected number\");\n\n    Jsi_ValueToNumber(interp, v);\n#if JSI_UTF8\n    i = Jsi_UniCharToUtf(v->d.num, unibuf);\n#else\n    unibuf[0] = (char) v->d.num;\n#endif\n    unibuf[i] = 0;\n    Jsi_ValueMakeStringDup(interp, ret, unibuf);\n    return JSI_OK;\n}\n/* Commands visible at the toplevel. */\n\nstatic Jsi_vtype jsi_getValType(Jsi_Value* val) {\n    switch (val->vt) {\n        case JSI_VT_BOOL:\n        case JSI_VT_NUMBER:\n        case JSI_VT_STRING:\n            return val->vt;\n        case JSI_VT_OBJECT:\n            switch (val->d.obj->ot) {\n                case JSI_OT_BOOL: return JSI_VT_BOOL;\n                case JSI_OT_NUMBER: return JSI_VT_NUMBER;\n                case JSI_OT_STRING: return JSI_VT_STRING;\n                default: break;\n            }\n            break;\n        default:\n            break;\n    }\n    return JSI_VT_UNDEF;\n}\n\nstatic Jsi_RC SysRunModuleCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Value *v1 = Jsi_ValueArrayIndex(interp, args, 0),\n    *v2 = Jsi_ValueArrayIndex(interp, args, 1);\n    const char *cp, *mod = NULL;\n    Jsi_RC rc = JSI_OK;\n    Jsi_DString dStr = {}, nStr = {};\n    Jsi_Value *cmd = NULL;\n    Jsi_Value *vpargs, *vargs[2] = {};\n    uint i, n = 0, siz, anum = 0, acnt=0;\n    Jsi_Value **arr;\n    Jsi_Obj *obj;\n    const char *anam;\n    bool isMain = jsi_isMain(interp);\n    if (interp->isMain)\n        interp->isMain = 0;\n    \n    if (v2 && !Jsi_ValueIsObjType(interp, v2, JSI_OT_ARRAY))\n        return Jsi_LogError(\"arg 2: expected array|undefined\");\n    if (!v1 || Jsi_ValueIsNull(interp, v1)) {\n        mod = interp->framePtr->fileName;\n        if (mod) mod = Jsi_Strrchr(mod, '/');\n        if (!mod) return JSI_ERROR;\n        mod++;\n        cp = Jsi_Strrchr(mod, '.');\n        int len = (cp?(cp-mod):(int)Jsi_Strlen(mod));\n        mod = Jsi_DSAppendLen(&dStr, mod, len);\n    } else {\n        mod = Jsi_ValueString(interp, v1, NULL);\n        if (!mod) {\n            if (Jsi_ValueIsObjType(interp, v1, JSI_OT_FUNCTION))\n                cmd = v1;\n            else\n                return Jsi_LogError(\"arg 1: expected string|function|undefined\");\n        }\n    }\n    if (!v2 && isMain)\n        v2 = interp->args;\n\n    if (!cmd && mod) {\n        cmd = Jsi_NameLookup(interp, mod);\n        if (!cmd)\n            cmd = jsi_LoadFunction(interp, mod, NULL);\n    }\n    if (!cmd || !Jsi_ValueIsObjType(interp, cmd, JSI_OT_FUNCTION)) {\n        rc = Jsi_LogError(\"unknown command: %s\", (mod?mod:\"\"));\n        goto done;\n    }\n    \n    if (!v2) {\n        obj = Jsi_ObjNewArray(interp, NULL, 0, 0);\n        vargs[n++] = Jsi_ValueNewObj(interp, obj);\n        vargs[n++] = Jsi_ValueNewObj(interp, obj=Jsi_ObjNew(interp));\n    } else {\n        arr = v2->d.obj->arr;\n        siz = v2->d.obj->arrCnt;\n        for (i=0; i<siz; i+=2) {\n            anam = Jsi_ValueToString(interp, arr[i], NULL);\n            if (i==0 && siz==1 && !Jsi_Strcmp(anam, \"-h\")) { anum=1; break; }\n            if (anam[0] != '-') break;\n            if (anam[0] == '-' && anam[1] == '-' && !anam[2]) {acnt++; break;}\n            anum += 2;\n        }\n        if (anum != 1 && (anum>siz)) {\n            if (anam)\n                interp->lastPushStr = (char*)anam;\n            rc = Jsi_LogError(\"missing argument\");\n            goto done;\n        }\n        obj = Jsi_ObjNewArray(interp, arr+anum+acnt, siz-anum-acnt, 0);\n        vargs[n++] = Jsi_ValueNewObj(interp, obj);\n        vargs[n++] = Jsi_ValueNewObj(interp, obj=Jsi_ObjNew(interp));\n        bool isLong = 0;\n        for (i=0; i<anum; i+=2) {\n            int anLen;\n            const char *astr, *anam = Jsi_ValueToString(interp, arr[i], &anLen);\n            if (anum<=1 && !Jsi_Strcmp(anam,\"-h\") ) anam = \"help\";\n            else if (anam && anam[0] == '-') anam++;\n            else {\n                rc = Jsi_LogError(\"bad option: %d\", i);\n                goto done;\n            }\n                \n            Jsi_Value *aval;\n            if  (anum==1)\n                aval = Jsi_ValueNewBoolean(interp, isLong);\n            else {\n                bool bv;\n                Jsi_Number nv;\n                astr = Jsi_ValueToString(interp, arr[i+1], NULL);\n                if (Jsi_GetBool(interp, astr, &bv) == JSI_OK) aval = Jsi_ValueNewBoolean(interp, bv);\n                else if (Jsi_GetDouble(interp, astr, &nv) == JSI_OK) aval = Jsi_ValueNewNumber(interp, nv);\n                else if (!Jsi_Strcmp(astr, \"null\"))  aval = Jsi_ValueNewNull(interp);\n                else aval = arr[i+1];\n            }\n            Jsi_ObjInsert(interp, obj, anam, aval, 0);\n        }\n    }\n    \n    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, vargs, n, 0));\n    \n    Jsi_IncrRefCount(interp, cmd);\n    Jsi_IncrRefCount(interp, vpargs);\n    for (i=0; i<n; i++)\n        Jsi_IncrRefCount(interp, vargs[i]);\n    rc = Jsi_FunctionInvoke(interp, cmd, vpargs, ret, NULL);\n    Jsi_DecrRefCount(interp, cmd);\n    for (i=0; i<n; i++)\n        Jsi_DecrRefCount(interp, vargs[i]);\n    Jsi_DecrRefCount(interp, vpargs);\n    if (rc == JSI_OK && !Jsi_ValueIsUndef(interp, *ret) && isMain && funcPtr && funcPtr->callflags.bits.isdiscard) {\n        Jsi_DSSetLength(&dStr, 0);\n        cp = Jsi_ValueGetDString(interp, *ret, &dStr, 0);\n        if (cp && (!(cp=Jsi_Strrchr(cp, '\\n')) || cp[1]))\n            Jsi_DSAppend(&dStr, \"\\n\", NULL);\n        Jsi_Puts(interp, jsi_Stdout, Jsi_DSValue(&dStr), -1);\n    }\n\ndone:\n    Jsi_DSFree(&dStr);\n    Jsi_DSFree(&nStr);\n    return rc;\n}\n\nstatic Jsi_RC SysRunMainCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (jsi_isMain(interp))\n        return SysRunModuleCmd(interp, args, _this, ret, funcPtr);\n    return JSI_OK;\n}\n\nstatic const char *jsi_FindHelpStr(const char *fstr, const char *key, Jsi_DString *dPtr) {\n    if (!fstr) return \"\";\n    Jsi_DSSetLength(dPtr, 0);\n    const char *cp, *ce;\n    int len = Jsi_Strlen(key);\n    while (fstr) {\n        while (isspace(*fstr)) fstr++;\n        cp = fstr;\n        if (!Jsi_Strncmp(cp, key, len) && isspace(cp[-1]) && (cp[len]==':' || isspace(cp[len]))) {\n            ce = NULL;\n            cp = Jsi_Strstr(cp, \"// \");\n            if (cp)\n                ce = Jsi_Strchr(cp, '\\n');\n            if (cp && ce)\n                return Jsi_DSAppendLen(dPtr, cp, ce-cp);\n            fstr = ce;\n        } else {\n            fstr = Jsi_Strchr(cp, '\\n');\n            if (fstr == cp) break;\n        }\n    }\n    return \"\";\n}\n\nstatic bool jsi_ModLogEnabled(Jsi_Interp *interp, Jsi_Value *v1, const char *name) {\n    jsi_Frame *fptr = interp->framePtr;\n    Jsi_Value *v2 = Jsi_ValueObjLookup(interp, v1, name, 0);\n    if (v2 && Jsi_ValueIsTrue(interp, v2)) return true;\n#ifndef JSI_OMIT_INTERP_ENV\n    const char *fname = fptr->funcName;\n    if (!fname) return false;\n    const char *cp;\n    static int isinit = 0;\n    static const char *ce = NULL;\n    if (!isinit) {\n        isinit = 1;\n        ce = getenv(\"JSI_PARSEOPTS\");\n    }\n    if (!ce) return false;\n    int len = Jsi_Strlen(fname);\n    cp = Jsi_Strstr(ce, fname);\n    if (!cp || cp[len]!='=') return false;\n    char buf[JSI_BUFSIZ];\n    snprintf(buf, sizeof(buf), \"%s=%s\", fname, name);\n    return (Jsi_Strstr(ce, buf) != NULL);\n#endif\n    return false;\n}\n\nstatic Jsi_RC SysParseOptsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Value *v1 = Jsi_ValueArrayIndex(interp, args, 0),\n    *v2 = Jsi_ValueArrayIndex(interp, args, 1),\n    *v3 = Jsi_ValueArrayIndex(interp, args, 2);\n    if (!v1 || !Jsi_ValueIsObjType(interp, v1, JSI_OT_OBJECT))\n        return Jsi_LogError(\"arg 1: expected object 'self'\");\n    if (!v2 || !Jsi_ValueIsObjType(interp, v2, JSI_OT_OBJECT))\n        return Jsi_LogError(\"arg 2: expected object 'options'\");\n\n    Jsi_TreeEntry *tPtr, *tPtr2;\n    Jsi_TreeSearch search;\n    for (tPtr = Jsi_TreeSearchFirst(v2->d.obj->tree, &search, 0, NULL);\n        tPtr; tPtr = Jsi_TreeSearchNext(&search)) {\n        Jsi_Value *v = (Jsi_Value*)Jsi_TreeValueGet(tPtr);\n        if (v==NULL) continue;\n        const char *key = (char*)Jsi_TreeKeyGet(tPtr);\n        if (!Jsi_ValueObjLookup(interp, v1, key, 1))\n            Jsi_ObjInsert(interp, v1->d.obj, key, v, 0);\n    }\n    Jsi_TreeSearchDone(&search);\n    Jsi_RC rc = JSI_OK;\n\n    if (!v3 || Jsi_ValueIsNull(interp, v3) || Jsi_ValueIsUndef(interp, v3)) {\n        //return JSI_OK;\n    } else {\n        //bool isArr = Jsi_ValueIsObjType(interp, v3, JSI_OT_ARRAY);\n        if (!Jsi_ValueIsObjType(interp, v3, JSI_OT_OBJECT))\n            return Jsi_LogError(\"arg 3: expected object|null\");\n    \n        Jsi_Value *oVal;\n        int cnt = 0;\n        for (tPtr = Jsi_TreeSearchFirst(v3->d.obj->tree, &search, 0, NULL);\n            tPtr && rc == JSI_OK; tPtr = Jsi_TreeSearchNext(&search)) {\n            Jsi_Value *val;\n            const char *key;\n            cnt++;\n            val = (Jsi_Value*)Jsi_TreeValueGet(tPtr);\n            key = (char*)Jsi_TreeKeyGet(tPtr);\n            if (!val || !key) continue;\n            if (Jsi_ValueIsUndef(interp, val)) {\n                rc = Jsi_LogError(\"value undefined for arg: '%s'\", key);\n                break;\n            }\n\n            if (cnt == 1 && !Jsi_Strcmp(key, \"help\") && v3->d.obj->tree->numEntries==1) {\n                int isLong = 1;//Jsi_ValueIsTrue(interp, val);\n                const char *help = \"\", *es = NULL, *fstr = NULL, *fname = interp->framePtr->ip->fname;\n                Jsi_TreeSearchDone(&search);\n                if (fname) {\n                    jsi_FileInfo  *fi = (typeof(fi))Jsi_HashGet(interp->fileTbl, fname, 0);\n                    fstr = fi->str;\n                }\n                if (!fstr)\n                    fstr = interp->framePtr->ps->lexer->d.str;\n                Jsi_DString dStr = {}, hStr = {}, vStr = {};\n                if (fstr) fstr = Jsi_Strstr(fstr, \"var options = \");\n                if (fstr) fstr = Jsi_Strchr(fstr, '{');\n                if (fstr) es = Jsi_Strchr(fstr, '\\n');\n                if (es) {\n                    help = Jsi_DSAppendLen(&hStr, fstr+1, es-fstr-1);\n                    fstr = es;\n                }\n                const char *mod = (fname?fname:interp->framePtr->fileName);\n                if (mod && (mod = Jsi_Strrchr(mod, '/')))\n                    mod++;\n                while (help && isspace(help[0])) help++;\n                while (help && help[0] == '/') help++;\n                while (help && isspace(help[0])) help++;\n                if (isLong)\n                    Jsi_DSPrintf(&dStr, \"\\n%s.  Options are:\\n\", help);\n                else\n                    Jsi_DSPrintf(&dStr, \"\\n%s.  Options are:\\n    \", help);\n                for (tPtr = Jsi_TreeSearchFirst(v2->d.obj->tree, &search, 0, NULL);\n                    tPtr; tPtr = Jsi_TreeSearchNext(&search)) {\n                    Jsi_Value *v = (Jsi_Value*)Jsi_TreeValueGet(tPtr);\n                    const char *vstr, *key = (char*)Jsi_TreeKeyGet(tPtr);\n                    if (!v || !key) continue;\n                    help = jsi_FindHelpStr(fstr, key, &hStr);\n                    int vlen, klen = Jsi_Strlen(key);\n                    Jsi_DSSetLength(&vStr, 0);\n                    vstr = Jsi_ValueGetDString(interp, v, &vStr, 1);\n                    vlen = Jsi_Strlen(vstr);\n                    if (!isLong)\n                        Jsi_DSPrintf(&dStr, \" -%s\", key);\n                    else\n                        Jsi_DSPrintf(&dStr, \"\\t-%s%s\\t%s\\t%s%s\\n\", key, (klen<7?\"\\t\":\"\"), vstr, (vlen<7?\"\\t\":\"\"), help);\n                }\n                if (isLong)\n                    Jsi_DSAppend(&dStr, \"\\nAccepted by all .jsi modules: -Debug, -Trace, -Test.\", NULL);\n                else\n                    Jsi_DSAppend(&dStr, \"\\nUse -help for long help.\", NULL);\n                rc = JSI_BREAK;\n                Jsi_ValueFromDS(interp, &dStr, ret);\n                Jsi_DSFree(&hStr);\n                Jsi_DSFree(&vStr);\n                break;\n            }\n            Jsi_vtype oTyp, vTyp = jsi_getValType(val);\n            if (!Jsi_Strcmp(key, \"Debug\") || !Jsi_Strcmp(key, \"Test\") || !Jsi_Strcmp(key, \"Trace\")) {\n                oTyp = JSI_VT_BOOL; // Accept these 3 as builtin options.\n                oVal = NULL;\n            } else if (!(tPtr2=Jsi_TreeEntryFind(v2->d.obj->tree, key)) || !(oVal = (Jsi_Value*)Jsi_TreeValueGet(tPtr2))) {\n                Jsi_TreeSearchDone(&search);\n                Jsi_DString dStr = {};\n                int cnt = 0;\n                for (tPtr = Jsi_TreeSearchFirst(v2->d.obj->tree, &search, 0, NULL);\n                    tPtr; tPtr = Jsi_TreeSearchNext(&search)) {\n                    const char *key = (char*)Jsi_TreeKeyGet(tPtr);\n                    if (!key) continue;\n                    cnt++;\n                    Jsi_DSAppend(&dStr, (cnt>1?\", \":\"\"), key, NULL);\n                }\n                Jsi_LogType(\"\\nUnknown option: \\\"%s\\\" is not one of:\\n  %s\\n\\n\", key, Jsi_DSValue(&dStr));\n                rc = JSI_BREAK;\n                Jsi_DSFree(&dStr);\n                break;\n            } else {\n                oTyp = jsi_getValType(oVal);\n            }\n            switch (oTyp) {\n                case JSI_VT_UNDEF:\n                case JSI_VT_NULL:\n                    break;\n                default:\n                    if (oTyp != vTyp) {\n                        rc = Jsi_LogError(\"type mismatch for '%s': '%s' is not a %s\",\n                            key, jsi_ValueTypeName(interp, val), (oVal?jsi_ValueTypeName(interp, oVal):\"boolean\"));\n                    }\n            }\n            if (rc == JSI_OK)\n                Jsi_ObjInsert(interp, v1->d.obj, key, val, 0);\n        }\n        Jsi_TreeSearchDone(&search);\n    }\n    if (rc == JSI_OK) {\n        jsi_Frame *fptr = interp->framePtr;\n        Jsi_Func *pf = interp->prevActiveFunc;\n        Jsi_ModuleConf *mo = NULL;\n        if (pf && pf->pkg)\n            mo = &pf->pkg->popts.modConf;\n        if (jsi_ModLogEnabled(interp, v1, \"Debug\") || (mo && mo->Debug)) {\n            jsi_evalStrFile(interp, NULL, \"this.LogDebug = console.log.bind(null, 'DEBUG:');\", 0, fptr->level);\n            fptr->logflag |= (1<<jsi_Oplf_debug);\n        }\n        if (jsi_ModLogEnabled(interp, v1, \"Trace\") || (mo && mo->Trace)) {\n            jsi_evalStrFile(interp, NULL, \"this.LogTrace = console.log.bind(null, 'TRACE:');\", 0, fptr->level);\n            fptr->logflag |= (1<<jsi_Oplf_trace);\n        }\n        if (jsi_ModLogEnabled(interp, v1, \"Test\") || (mo && mo->Test)) {\n            jsi_evalStrFile(interp, NULL, \"this.LogTest = console.log.bind(null, 'TEST: ');\", 0, fptr->level);\n            fptr->logflag |= (1<<jsi_Oplf_test);\n        }\n    }\n    return rc;\n}\n\nstatic Jsi_CmdSpec consoleCmds[] = {\n    { \"assert\", jsi_AssertCmd,      1,  3, \"expr:boolean|number|function, msg:string=void, options:object=void\",  .help=\"Same as System.assert()\", .retType=(uint)JSI_TT_VOID, .flags=0, .info=0, .opts=AssertOptions},\n    { \"error\",  consoleLogCmd,      1, -1, \"val, ...\", .help=\"Same as log\", .retType=(uint)JSI_TT_VOID, .flags=0 },\n    { \"input\",  consoleInputCmd,    0,  0, \"\", .help=\"Read input from the console\", .retType=(uint)JSI_TT_STRING|JSI_TT_VOID },\n    { \"log\",    consoleLogCmd,      1, -1, \"val, ...\", .help=\"Same as System.puts, but goes to stderr and includes file:line\", .retType=(uint)JSI_TT_VOID, .flags=0 },\n    { \"printf\", consolePrintfCmd,   1, -1, \"format:string, ...\", .help=\"Same as System.printf but goes to stderr\", .retType=(uint)JSI_TT_VOID, .flags=0 },\n    { \"puts\",   consolePutsCmd,     1, -1, \"val, ...\", .help=\"Same as System.puts, but goes to stderr\", .retType=(uint)JSI_TT_VOID, .flags=0 },\n    { \"warn\",   consoleLogCmd,      1, -1, \"val, ...\", .help=\"Same as log\", .retType=(uint)JSI_TT_VOID, .flags=0 },\n    { NULL, 0,0,0,0,  .help=\"Console input and output to stderr\" }\n};\n\n#ifndef JSI_OMIT_EVENT\nstatic Jsi_CmdSpec eventCmds[] = {\n    { \"clearInterval\",clearIntervalCmd, 1,  1, \"id:number\", .help=\"Delete an event (created with setInterval/setTimeout)\", .retType=(uint)JSI_TT_VOID },\n    { \"info\",       eventInfoCmd,       1,  1, \"id:number\", .help=\"Return info for the given event id\", .retType=(uint)JSI_TT_OBJECT },\n    { \"names\",      eventInfoCmd,       0,  0, \"\", .help=\"Return list event ids (created with setTimeout/setInterval)\", .retType=(uint)JSI_TT_ARRAY },\n    { \"setInterval\",setIntervalCmd,     2,  2, \"callback:function, millisecs:number\", .help=\"Setup recurring function to run every given millisecs\", .retType=(uint)JSI_TT_NUMBER },\n    { \"setTimeout\", setTimeoutCmd,      2,  2, \"callback:function, millisecs:number\", .help=\"Setup function to run after given millisecs\", .retType=(uint)JSI_TT_NUMBER },\n    { \"update\",     SysUpdateCmd,       0,  1, \"options:number|object=void\", .help=\"Service all events, eg. setInterval/setTimeout\", .retType=(uint)JSI_TT_NUMBER, .flags=0, .info=FN_update, .opts=jsiUpdateOptions },\n    { NULL, 0,0,0,0,  .help=\"Event management\" }\n};\n#endif\n\n#ifndef JSI_OMIT_DEBUG\nstatic Jsi_CmdSpec debugCmds[] = {\n    { \"add\",        DebugAddCmd,    1,  2, \"val:string|number, temp:boolean=false\", .help=\"Add a breakpoint for line, file:line or func\", .retType=(uint)JSI_TT_NUMBER },\n    { \"remove\",     DebugRemoveCmd, 1,  1, \"id:number\", .help=\"Remove breakpoint\", .retType=(uint)JSI_TT_VOID },\n    { \"enable\",     DebugEnableCmd, 2,  2, \"id:number, on:boolean\", .help=\"Enable/disable breakpoint\", .retType=(uint)JSI_TT_VOID },\n    { \"info\",       DebugInfoCmd,   0,  1, \"id:number=void\", .help=\"Return info about one breakpoint, or list of bp numbers\", .retType=(uint)JSI_TT_OBJECT|JSI_TT_ARRAY },\n    { NULL, 0,0,0,0,  .help=\"Debugger breakpoint management\" }\n};\n#endif\n\nstatic Jsi_CmdSpec infoCmds[] = {\n    { \"argv0\",      InfoArgv0Cmd,       0,  0, \"\", .help=\"Return initial start script file name\", .retType=(uint)JSI_TT_STRING|JSI_TT_VOID },\n    { \"cmds\",       InfoCmdsCmd,        0,  2, \"val:string|regexp='*', options:object=void\", .help=\"Return details or list of matching commands\", .retType=(uint)JSI_TT_ARRAY|JSI_TT_OBJECT, .flags=0, .info=0, .opts=InfoCmdsOptions },\n    { \"completions\",InfoCompletionsCmd, 1,  3, \"str:string, start:number=0, end:number=void\", .help=\"Return command completions on portion of string from start to end\", .retType=(uint)JSI_TT_ARRAY },\n    { \"data\",       InfoDataCmd,        0,  1, \"val:string|regexp|object=void\", .help=\"Return list of matching data (non-functions)\", .retType=(uint)JSI_TT_ARRAY|JSI_TT_OBJECT, .flags=0, .info=FN_infodata },\n    { \"error\",      InfoErrorCmd,       0,  0, \"\", .help=\"Return file and line number of error (used inside catch)\", .retType=(uint)JSI_TT_OBJECT },\n#ifndef JSI_OMIT_EVENT\n    { \"event\",      InfoEventCmd,       0,  1, \"id:number=void\", .help=\"List events or info for 1 event (setTimeout/setInterval)\", .retType=(uint)JSI_TT_ARRAY|JSI_TT_OBJECT, .flags=0, .info=FN_infoevent },\n#endif\n    { \"executable\", InfoExecutableCmd,  0,  0, \"\", .help=\"Return name of executable\", .retType=(uint)JSI_TT_STRING },\n    { \"execZip\",    InfoExecZipCmd,     0,  0, \"\", .help=\"If executing a .zip file, return file name\", .retType=(uint)JSI_TT_STRING|JSI_TT_VOID },\n    { \"files\",      InfoFilesCmd,       0,  0, \"\", .help=\"Return list of all sourced files\", .retType=(uint)JSI_TT_ARRAY },\n    { \"funcs\",      InfoFuncsCmd,       0,  1, \"string|regexp|object=void\", .help=\"Return details or list of matching functions\", .retType=(uint)JSI_TT_ARRAY|JSI_TT_OBJECT },\n    { \"locals\",     InfoLocalsCmd,      0,  1, \"filter:boolean=void\", .help=\"Return locals; use filter=true/false just vars/functions\", .retType=(uint)JSI_TT_OBJECT },\n    { \"interp\",     jsi_InterpInfo,     0,  1, \"interp:userobj=void\", .help=\"Return info on given or current interp\", .retType=(uint)JSI_TT_OBJECT },\n    { \"isMain\",     InfoIsMainCmd,      0,  0, \"\", .help=\"Return true if current script was the main script invoked from command-line\", .retType=(uint)JSI_TT_BOOLEAN },\n    { \"keywords\",   InfoKeywordsCmd,    0,  2, \"isSql=false, name:string=void\", .help=\"Return/lookup reserved keyword\", .retType=(uint)JSI_TT_ARRAY|JSI_TT_BOOLEAN },\n    { \"level\",      InfoLevelCmd,       0,  1, \"level:number=void\", .help=\"Return current level or details of a call-stack frame\", .retType=(uint)JSI_TT_ARRAY|JSI_TT_OBJECT|JSI_TT_NUMBER, .flags=0, .info=FN_infolevel },\n    { \"lookup\",     InfoLookupCmd,      1,  1, \"name:string\", .help=\"Given string name, lookup and return value, eg: function\", .retType=(uint)JSI_TT_ANY },\n    { \"methods\",    InfoMethodsCmd,     1,  1, \"val:string|regexp\", .help=\"Return functions and commands\", .retType=(uint)JSI_TT_ARRAY|JSI_TT_OBJECT },\n    { \"named\",      InfoNamedCmd,       0,  1, \"name:string=void\", .help=\"Returns command names for builtin Objects, eg: 'File', 'Interp', sub-Object names, or the named object\", .retType=(uint)JSI_TT_ARRAY|JSI_TT_USEROBJ },\n    { \"options\",    InfoOptionsCmd,     0,  1, \"ctype:boolean=false\", .help=\"Return Option type name, or with true the C type\", .retType=(uint)JSI_TT_ARRAY },\n    { \"package\",    InfoPackageCmd,     1,  1, \"pkgName:string\", .help=\"Return info about provided package if exists, else null\", .retType=(uint)JSI_TT_OBJECT|JSI_TT_NULL },\n    { \"platform\",   InfoPlatformCmd,    0,  0, \"\", .help=\"N/A. Returns general platform information for JSI\", .retType=(uint)JSI_TT_OBJECT  },\n    { \"script\",     InfoScriptCmd,      0,  1, \"func:function|regexp=void\", .help=\"Get current script file name, or file containing function\", .retType=(uint)JSI_TT_STRING|JSI_TT_ARRAY|JSI_TT_VOID },\n    { \"scriptDir\",  InfoScriptDirCmd,   0,  0, \"\", .help=\"Get directory of current script\", .retType=(uint)JSI_TT_STRING|JSI_TT_VOID },\n    { \"vars\",       InfoVarsCmd,        0,  1, \"val:string|regexp|object=void\", .help=\"Return details or list of matching variables\", .retType=(uint)JSI_TT_ARRAY|JSI_TT_OBJECT, .flags=0, .info=FN_infovars },\n    { \"version\",    InfoVersionCmd,     0,  1, \"full:boolean=false\", .help=\"JSI version: returns object when full=true\", .retType=(uint)JSI_TT_NUMBER|JSI_TT_OBJECT  },\n    { NULL, 0,0,0,0, .help=\"Commands for inspecting internal state information in JSI\"  }\n};\nstatic Jsi_RC SysSqlValuesCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                         Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    const char *name = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    if (!name) return Jsi_LogError(\"expected name\");\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 1);\n    if (!arg)\n        arg = Jsi_VarLookup(interp, name);\n    if (!arg || !Jsi_ValueIsObjType(interp, arg, JSI_OT_OBJECT))\n        return Jsi_LogError(\"expected object 'values'\");\n    Jsi_DString dStr = {};\n    Jsi_DSAppend(&dStr, \"(\", NULL);\n    Jsi_IterObj *io = Jsi_IterObjNew(interp, NULL);\n    Jsi_IterGetKeys(interp, arg, io, 0);\n    uint i;\n    const char *pre = \"\";\n    for (i=0; i<io->count; i++) {\n        Jsi_DSAppend(&dStr, pre, io->keys[i], NULL);\n        pre = \",\";\n    }\n    pre = \"\";\n    Jsi_DSAppend(&dStr, \") VALUES(\", NULL);\n    for (i=0; i<io->count; i++) {\n        Jsi_DSAppend(&dStr, pre, \"$\", name, \"(\", io->keys[i], \")\", NULL);\n        pre = \",\";\n    }\n    Jsi_IterObjFree(io);\n\n    Jsi_DSAppend(&dStr, \")\", NULL);\n    Jsi_ValueFromDS(interp, &dStr, ret);\n    return JSI_OK;\n}\n\nstatic Jsi_CmdSpec utilCmds[] = {\n#ifndef JSI_OMIT_BASE64\n    { \"argArray\",   SysArgArrayCmd,  1,  1, \"arg:any|undefined\", .help=\"Coerces non-null to an array, if necessary\", .retType=(uint)JSI_TT_ARRAY|JSI_TT_NULL },\n    { \"complete\",   SysCompleteCmd,  1,  1, \"val:string\",.help=\"Return true if string is complete command with balanced braces, etc\", .retType=(uint)JSI_TT_BOOLEAN },\n    { \"base64\",     SysBase64Cmd,    1,  2, \"val:string, decode:boolean=false\",.help=\"Base64 encode/decode a string\", .retType=(uint)JSI_TT_STRING },\n    { \"hexStr\",     SysHexStrCmd,    1,  2, \"val:string, decode:boolean=false\",.help=\"Hex encode/decode a string\", .retType=(uint)JSI_TT_STRING },\n#endif\n    { \"crc32\",      SysCrc32Cmd,     1,  2, \"val:string, crcSeed=0\",.help=\"Calculate 32-bit CRC\", .retType=(uint)JSI_TT_NUMBER },\n#ifndef JSI_OMIT_ENCRYPT\n    { \"decrypt\",    SysDecryptCmd,   2,  2, \"val:string, key:string\", .help=\"Decrypt data using BTEA encryption\", .retType=(uint)JSI_TT_STRING, .flags=0, .info=FN_encrypt },\n    { \"encrypt\",    SysEncryptCmd,   2,  2, \"val:string, key:string\", .help=\"Encrypt data using BTEA encryption\", .retType=(uint)JSI_TT_STRING, .flags=0, .info=FN_encrypt },\n#endif\n    { \"fromCharCode\",SysFromCharCodeCmd, 1, 1, \"code:number\", .help=\"Return char with given character code\", .retType=(uint)JSI_TT_STRING, .flags=JSI_CMDSPEC_NONTHIS},\n    { \"getenv\",     SysGetEnvCmd,    0,  1, \"name:string=void\", .help=\"Get one or all environment\", .retType=(uint)JSI_TT_STRING|JSI_TT_OBJECT|JSI_TT_VOID  },\n    { \"getpid\",     SysGetPidCmd,    0,  1, \"parent:boolean=false\", .help=\"Get process/parent id\", .retType=(uint)JSI_TT_NUMBER },\n    { \"getuser\",    SysGetUserCmd,   0,  0, \"\", .help=\"Get userid info\", .retType=(uint)JSI_TT_OBJECT },\n    { \"hash\",       SysHashCmd,      1,  2, \"val:string, options|object=void\", .help=\"Return hash (default SHA256) of string/file\", .retType=(uint)JSI_TT_STRING, .flags=0, .info=0, .opts=HashOptions},\n    { \"setenv\",     SysSetEnvCmd,    1,  2, \"name:string, value:string=void\", .help=\"Set/get an environment var\"  },\n    { \"sqlValues\",  SysSqlValuesCmd, 1,  2, \"name:string, var:object=void\", .help=\"Get object values for SQL\"  },\n    { \"times\",      SysTimesCmd,     1,  2, \"callback:function|boolean, count:number=1\", .help=\"Call function count times and return execution time in microseconds\", .retType=(uint)JSI_TT_NUMBER },\n    { \"verConvert\", SysVerConvertCmd,1,  2, \"ver:string|number, zeroTrim:number=0\", .help=\"Convert a version to/from a string/number, or return null if not a version. For string output zeroTrim says how many trailing .0 to trim (0-2)\", .retType=(uint)JSI_TT_NUMBER|JSI_TT_STRING|JSI_TT_NULL },\n    { NULL, 0,0,0,0, .help=\"Utilities commands\"  }\n};\n\nstatic Jsi_CmdSpec sysCmds[] = {\n    { \"assert\", jsi_AssertCmd,       1,  3, \"expr:boolean|number|function, msg:string=void, options:object=void\",  .help=\"Throw or output msg if expr is false\", .retType=(uint)JSI_TT_VOID, .flags=0, .info=FN_assert, .opts=AssertOptions },\n#ifndef JSI_OMIT_EVENT\n    { \"clearInterval\",clearIntervalCmd,1,1, \"id:number\", .help=\"Delete event id returned from setInterval/setTimeout/info.events()\", .retType=(uint)JSI_TT_VOID },\n#endif\n    { \"decodeURI\",  DecodeURICmd,    1,  1, \"val:string\", .help=\"Decode an HTTP URL\", .retType=(uint)JSI_TT_STRING },\n    { \"encodeURI\",  EncodeURICmd,    1,  1, \"val:string\", .help=\"Encode an HTTP URL\", .retType=(uint)JSI_TT_STRING },\n    { \"exec\",       SysExecCmd,      1,  2, \"val:string, options:string|object=void\", .help=\"Execute an OS command\", .retType=(uint)JSI_TT_ANY, .flags=0, .info=FN_exec, .opts=ExecOptions},\n    { \"exit\",       SysExitCmd,      0,  1, \"code:number=0\", .help=\"Exit the current interpreter\", .retType=(uint)JSI_TT_VOID },\n    { \"format\",     SysFormatCmd,    1, -1, \"format:string, ...\", .help=\"Printf style formatting: adds %q and %S\", .retType=(uint)JSI_TT_STRING },\n    { \"isFinite\",   isFiniteCmd,     1,  1, \"val\", .help=\"Return true if is a finite number\", .retType=(uint)JSI_TT_BOOLEAN },\n    { \"isMain\",     InfoIsMainCmd,   0,  0, \"\", .help=\"Return true if current script was the main script invoked from command-line\", .retType=(uint)JSI_TT_BOOLEAN },\n    { \"isNaN\",      isNaNCmd,        1,  1, \"val\", .help=\"Return true if not a number\", .retType=(uint)JSI_TT_BOOLEAN },\n#ifndef JSI_OMIT_LOAD\n    { \"load\",       jsi_LoadLoadCmd, 1,  1, \"shlib:string\", .help=\"Load a shared executable and invoke its _Init call\", .retType=(uint)JSI_TT_VOID },\n#endif\n    { \"log\",        SysLogCmd,       1, -1, \"val, ...\", .help=\"Same as puts, but includes file:line\", .retType=(uint)JSI_TT_VOID, .flags=0 },\n    { \"matchObj\",   SysMatchObjCmd,  1,  4, \"obj:object, match:string=void, partial=false, noerror=false\", .help=\"Object field names/types matching. Single arg generates string\", .retType=(uint)JSI_TT_BOOLEAN|JSI_TT_STRING },\n    { \"noOp\",       jsi_NoOpCmd,     0, -1, \"\", .help=\"A No-Op. A zero overhead command call that is useful for debugging\" },\n    { \"parseInt\",   parseIntCmd,     1,  2, \"val:any, base:number=10\", .help=\"Convert string to an integer\", .retType=(uint)JSI_TT_NUMBER },\n    { \"parseFloat\", parseFloatCmd,   1,  1, \"val\", .help=\"Convert string to a double\", .retType=(uint)JSI_TT_NUMBER },\n    { \"parseOpts\",  SysParseOptsCmd, 2,  3, \"self:object|userobj, options:object, conf:object|null|undefined\", .help=\"Parse options\", .retType=(uint)JSI_TT_ANY, .flags=0},\n    { \"printf\",     SysPrintfCmd,    1, -1, \"format:string, ...\", .help=\"Formatted output to stdout\", .retType=(uint)JSI_TT_VOID, .flags=0 },\n    { \"provide\",    SysProvideCmd,   0,  3, \"name:string|function=void, version:number|string=1.0, opts:object|function=void\", .help=\"Provide a package for use with require. Default is the file tail-rootname\", .retType=(uint)JSI_TT_VOID },\n    { \"puts\",       SysPutsCmd,      1, -1, \"val, ...\", .help=\"Output one or more values to stdout\", .retType=(uint)JSI_TT_VOID, .flags=0, .info=FN_puts },\n    { \"quote\",      SysQuoteCmd,     1,  1, \"val:string\", .help=\"Return quoted string\", .retType=(uint)JSI_TT_STRING },\n    { \"require\",    SysRequireCmd,   0,  3, \"name:string=void, version:number|string=1, options:object=void\", .help=\"Load/query packages\", .retType=(uint)JSI_TT_NUMBER|JSI_TT_OBJECT|JSI_TT_ARRAY, .flags=0, .info=FN_require, .opts=jsiModuleOptions },\n    { \"runMain\",    SysRunMainCmd,   0,  2, \"cmd:string|null|function=void, conf:array=undefined\", .help=\"If isMain invokes runModule\", .retType=(uint)JSI_TT_ANY, .flags=0},\n    { \"runModule\",  SysRunModuleCmd, 0,  2, \"cmd:string|null|function=void, conf:array=undefined\", .help=\"Invoke named module. If name is empty, uses file basename. If isMain and no args givine parses console.args\", .retType=(uint)JSI_TT_ANY, .flags=0},\n    { \"sleep\",      SysSleepCmd,     0,  1, \"secs:number=1.0\",  .help=\"sleep for N milliseconds, minimum .001\", .retType=(uint)JSI_TT_VOID },\n#ifndef JSI_OMIT_EVENT\n    { \"setInterval\",setIntervalCmd,  2,  2, \"callback:function, ms:number\", .help=\"Setup recurring function to run every given millisecs\", .retType=(uint)JSI_TT_NUMBER },\n    { \"setTimeout\", setTimeoutCmd,   2,  2, \"callback:function, ms:number\", .help=\"Setup function to run after given millisecs\", .retType=(uint)JSI_TT_NUMBER },\n#endif\n    { \"source\",     SysSourceCmd,    1,  2, \"val:string|array, options:object=void\",  .help=\"Load and evaluate source files: trailing '/' appends PARENTDIR.jsi\", .retType=(uint)JSI_TT_ANY, .flags=0, .info=0, .opts=SourceOptions},\n    { \"strftime\",   DateStrftimeCmd, 0,  2, \"num:number=null, options:string|object=void\",  .help=\"Format numeric time (in ms) to a string\", .retType=(uint)JSI_TT_STRING, .flags=0, .info=FN_strftime, .opts=DateOptions },\n    { \"strptime\",   DateStrptimeCmd, 0,  2, \"val:string=void, options:string|object=void\",  .help=\"Parse time from string and return ms time since 1970-01-01 in UTC, or NaN\", .retType=(uint)JSI_TT_NUMBER, .flags=0, .info=0, .opts=DateOptions },\n    { \"times\",      SysTimesCmd,     1,  2, \"callback:function|boolean, count:number=1\", .help=\"Call function count times and return execution time in microseconds\", .retType=(uint)JSI_TT_NUMBER },\n#ifndef JSI_OMIT_LOAD\n    { \"unload\",     jsi_LoadUnloadCmd,1, 1,  \"shlib:string\", .help=\"Unload a shared executable and invoke its _Done call\", .retType=(uint)JSI_TT_VOID },\n#endif\n#ifndef JSI_OMIT_EVENT\n    { \"update\",     SysUpdateCmd,    0,  1, \"options:number|object=void\", .help=\"Service all events, eg. setInterval/setTimeout\", .retType=(uint)JSI_TT_NUMBER, .flags=0, .info=FN_update, .opts=jsiUpdateOptions },\n#endif\n    { NULL, 0,0,0,0, .help=\"Builtin system commands. All methods are exported as global\" }\n};\n\nJsi_RC jsi_InitCmds(Jsi_Interp *interp, int release)\n{\n    if (release) return JSI_OK;\n    interp->console = Jsi_CommandCreateSpecs(interp, \"console\", consoleCmds, NULL, 0);\n    Jsi_IncrRefCount(interp, interp->console);\n    Jsi_ValueInsertFixed(interp, interp->console, \"args\", interp->args);\n        \n    Jsi_CommandCreateSpecs(interp, \"\",       sysCmds,    NULL, 0);\n    Jsi_CommandCreateSpecs(interp, \"System\", sysCmds,    NULL, 0);\n    Jsi_CommandCreateSpecs(interp, \"Info\",   infoCmds,   NULL, 0);\n    Jsi_CommandCreateSpecs(interp, \"Util\",   utilCmds,   NULL, 0);\n#ifndef JSI_OMIT_EVENT\n    Jsi_CommandCreateSpecs(interp, \"Event\",  eventCmds,  NULL, 0);\n#endif\n#ifndef JSI_OMIT_DEBUG\n    Jsi_CommandCreateSpecs(interp, \"Debugger\",  debugCmds,  NULL, 0);\n#endif\n    return JSI_OK;\n}\n#endif\n", "#ifndef JSI_LITE_ONLY\n#ifndef _JSI_CODE_C_\n#define _JSI_CODE_C_\n#ifndef JSI_AMALGAMATION\n#include \"jsiInt.h\"\n#endif\n\n/* replace continue/break(coded as OP_RESERVED) jmp\n * |------------------| \\\n * |                  | \\\\ where 'continue' jmp (jmp to step code)\n * |       ops        |  / \n * |                  | / \\\n * |------------------|    \\ where 'break' jmp (jmp after step code)\n * |                  |    /\n * |       step       |   /\n * |                  |  /\n * |------------------| /\n * 1. break_only used only in switch\n * 2. desire_label, only replace if current iter statement has the same label with opcode\n * 3. topop, if not replace in current iter statment, make sure when jmp out of this loop/switch\n *    corrent stack elems poped(for in always has 2 elem, while switch has 1)\n */\n\nstatic const char *jsi_op_names[OP_LASTOP] = {\n    \"NOP\",\n    \"PUSHNUM\",\n    \"PUSHSTR\",\n    \"PUSHVSTR\",\n    \"PUSHVAR\",\n    \"PUSHUND\",\n    \"PUSHNULL\",\n    \"PUSHBOO\",\n    \"PUSHFUN\",\n    \"PUSHREG\",\n    \"PUSHARG\",\n    \"PUSHTHS\",\n    \"PUSHTOP\",\n    \"PUSHTOP2\",\n    \"UNREF\",\n    \"POP\",\n    \"LOCAL\",\n    \"NEG\",\n    \"POS\",\n    \"NOT\",\n    \"BNOT\",\n    \"ADD\",\n    \"SUB\",\n    \"MUL\",\n    \"DIV\",\n    \"MOD\",\n    \"LESS\",\n    \"GREATER\",\n    \"LESSEQU\",\n    \"GREATEREQU\",\n    \"EQUAL\",\n    \"NOTEQUAL\",\n    \"STRICTEQU\",\n    \"STRICTNEQ\",\n    \"BAND\",\n    \"BOR\",\n    \"BXOR\",\n    \"SHF\",\n    \"INSTANCEOF\",\n    \"ASSIGN\",\n    \"SUBSCRIPT\",\n    \"INC\",\n    \"TYPEOF\",\n    \"IN\",\n    \"DEC\",\n    \"KEY\",\n    \"NEXT\",\n    \"JTRUE\",\n    \"JFALSE\",\n    \"JTRUE_NP\",\n    \"JFALSE_NP\",\n    \"JMP\",\n    \"JMPPOP\",\n    \"FCALL\",\n    \"NEWFCALL\",\n    \"RET\",\n    \"DELETE\",\n    \"CHTHIS\",\n    \"OBJECT\",\n    \"ARRAY\",\n    \"EVAL\",\n    \"STRY\",\n    \"ETRY\",\n    \"SCATCH\",\n    \"ECATCH\",\n    \"SFINAL\",\n    \"EFINAL\",\n    \"THROW\",\n    \"WITH\",\n    \"EWITH\",\n    \"RESERVED\",\n    \"DEBUG\"\n};\n\nstatic int jsiOpCodesCnt[3] = {0,0,0};\n\nvoid jsi_FreeOpcodes(Jsi_OpCodes *ops) {\n    int i;\n    if (!ops) return;\n    for (i=0; i<ops->code_len; i++) {\n        jsi_OpCode *op = ops->codes+i;\n        if (op->data && op->alloc)\n            Jsi_Free(op->data);\n        _JSI_MEMCLEAR(op);\n    }\n    jsiOpCodesCnt[1]++;\n    jsiOpCodesCnt[2]--;\n#ifdef JSI_MEM_DEBUG\n    if (ops->hPtr)\n        Jsi_HashEntryDelete(ops->hPtr);\n#endif\n    Jsi_Free(ops->codes);\n    Jsi_Free(ops);\n}\n\nstatic Jsi_OpCodes *codes_new(int size)\n{\n    Jsi_OpCodes *ops = (Jsi_OpCodes *)Jsi_Calloc(1, sizeof(*ops));\n    jsiOpCodesCnt[0]++;\n    jsiOpCodesCnt[2]++;\n    ops->codes = (jsi_OpCode *)Jsi_Calloc(size, sizeof(jsi_OpCode));\n    ops->code_size = size;\n#ifdef JSI_MEM_DEBUG\n    static int idNum = 0;\n    ops->hPtr = Jsi_HashSet(jsiIntData.mainInterp->codesTbl, ops, ops);\n    ops->id = idNum++;\n#endif\n    return ops;\n}\n\nstatic int codes_insert(Jsi_OpCodes *c, jsi_Eopcode code, void *extra, int doalloc)\n{\n    if (c->code_size - c->code_len <= 0) {\n        c->code_size += 100;\n        c->codes = (jsi_OpCode *)Jsi_Realloc(c->codes, c->code_size * sizeof(jsi_OpCode));\n    }\n    c->codes[c->code_len].op = code;\n    c->codes[c->code_len].data = extra;\n    c->codes[c->code_len].alloc = doalloc;\n    c->code_len ++;\n    return 0;\n}\n\nstatic int codes_insertln(Jsi_OpCodes *c, jsi_Eopcode code, void *extra, jsi_Pstate *pstate, jsi_Pline *line, int doalloc)\n{\n    if (c->code_size - c->code_len <= 0) {\n        c->code_size += 100;\n        c->codes = (jsi_OpCode *)Jsi_Realloc(c->codes, c->code_size * sizeof(jsi_OpCode));\n    }\n    c->codes[c->code_len].op = code;\n    c->codes[c->code_len].data = extra;\n    c->codes[c->code_len].Line = line->first_line;\n    c->codes[c->code_len].Lofs = line->first_column;\n    c->codes[c->code_len].fname = jsi_PstateGetFilename(pstate);\n    c->codes[c->code_len].alloc = doalloc;\n    c->code_len ++;\n    return 0;\n}\n\n\nstatic Jsi_OpCodes *codes_join(Jsi_OpCodes *a, Jsi_OpCodes *b)\n{\n    Jsi_OpCodes *ret = codes_new(a->code_len + b->code_len);\n    memcpy(ret->codes, a->codes, a->code_len * sizeof(jsi_OpCode));\n    memcpy(&ret->codes[a->code_len], b->codes, b->code_len * sizeof(jsi_OpCode));\n    ret->code_size = a->code_len + b->code_len;\n    ret->code_len = ret->code_size;\n    ret->expr_counter = a->expr_counter + b->expr_counter;\n#if 0\n    a->code_len=0;\n    jsi_FreeOpcodes(a);\n    b->code_len=0;\n    jsi_FreeOpcodes(b);\n#else\n    Jsi_Free(a->codes);\n    Jsi_Free(b->codes);\n#ifdef JSI_MEM_DEBUG\n    if (a->hPtr)\n        Jsi_HashEntryDelete(a->hPtr);\n    if (b->hPtr)\n        Jsi_HashEntryDelete(b->hPtr);\n#endif\n    Jsi_Free(a);\n    Jsi_Free(b);\n#endif\n    jsiOpCodesCnt[1]++;\n    jsiOpCodesCnt[2]-=2;\n    return ret;\n}\n\nstatic Jsi_OpCodes *codes_join3(Jsi_OpCodes *a, Jsi_OpCodes *b, Jsi_OpCodes *c)\n{\n    return codes_join(codes_join(a, b), c);\n}\n\nstatic Jsi_OpCodes *codes_join4(Jsi_OpCodes *a, Jsi_OpCodes *b, Jsi_OpCodes *c, Jsi_OpCodes *d)\n{\n    return codes_join(codes_join(a, b), codes_join(c, d));\n}\n\n#define JSI_NEW_CODES(doalloc,code, extra) do {                 \\\n        Jsi_OpCodes *r = codes_new(3);                  \\\n        codes_insert(r, (code), (void *)(uintptr_t)(extra), doalloc);   \\\n        return r;                                   \\\n    } while(0)\n\n#define JSI_NEW_CODESLN(doalloc,code, extra) do {                 \\\n        Jsi_OpCodes *r = codes_new(3);                  \\\n        codes_insertln(r, (code), (void *)(uintptr_t)(extra), p, line, doalloc);   \\\n        return r;                                   \\\n    } while(0)\n\nstatic Jsi_OpCodes *code_push_undef() { JSI_NEW_CODES(0,OP_PUSHUND, 0); }\nstatic Jsi_OpCodes *code_push_null() { JSI_NEW_CODES(0,OP_PUSHNULL, 0); }\nstatic Jsi_OpCodes *code_push_bool(int v) { JSI_NEW_CODES(0,OP_PUSHBOO, v); }\nstatic Jsi_OpCodes *code_push_num(Jsi_Number *v) { JSI_NEW_CODES(1,OP_PUSHNUM, v); }\nstatic Jsi_OpCodes *code_push_string(jsi_Pstate *p, jsi_Pline *line, const char *str) {\n    if (*str == 'c' && !Jsi_Strcmp(str,\"callee\"))\n        p->interp->hasCallee = 1;\n    JSI_NEW_CODESLN(0,OP_PUSHSTR, str);\n}\n\nstatic Jsi_OpCodes *code_push_vstring(jsi_Pstate *p, jsi_Pline *line, Jsi_String *s) {\n    JSI_NEW_CODESLN(0,OP_PUSHVSTR, s);\n}\n\nstatic Jsi_OpCodes *code_push_index(jsi_Pstate *p, jsi_Pline *line, const char *varname, int local)\n{\n    jsi_FastVar *n = (typeof(n))Jsi_Calloc(1, sizeof(*n));\n    n->sig = JSI_SIG_FASTVAR;\n    n->ps = p;\n    n->context_id = -1;\n    n->local = local;\n    n->varname = (char*)Jsi_KeyAdd(p->interp, varname);\n    Jsi_HashSet(p->fastVarTbl, n, n);\n    JSI_NEW_CODESLN(1,OP_PUSHVAR, n);\n}\n\nstatic Jsi_OpCodes *code_push_this(jsi_Pstate *p, jsi_Pline *line) { JSI_NEW_CODESLN(0,OP_PUSHTHS, 0); }\nstatic Jsi_OpCodes *code_push_top() { JSI_NEW_CODES(0,OP_PUSHTOP, 0); }\nstatic Jsi_OpCodes *code_push_top2() { JSI_NEW_CODES(0,OP_PUSHTOP2, 0); }\nstatic Jsi_OpCodes *code_unref() { JSI_NEW_CODES(0,OP_UNREF, 0); }\nstatic Jsi_OpCodes *code_push_args() { JSI_NEW_CODES(0,OP_PUSHARG, 0); }\nstatic Jsi_OpCodes *code_push_func_sub(jsi_Pstate *p, jsi_Pline *line, Jsi_Func *fun) { p->funcDefs++; JSI_NEW_CODESLN(0,OP_PUSHFUN, fun); }\nstatic Jsi_OpCodes *code_push_func(jsi_Pstate *p, jsi_Pline *line, Jsi_Func *fun) {\n    Jsi_OpCodes* codes = code_push_func_sub(p, line, fun);\n    if (codes && fun && fun->name)\n        codes->codes[0].local = 1;\n    return codes;\n}\nstatic Jsi_OpCodes *code_push_regex(jsi_Pstate *p, jsi_Pline *line, Jsi_Regex *reg) { JSI_NEW_CODESLN(0,OP_PUSHREG, reg); }\n\nstatic Jsi_OpCodes *code_local(jsi_Pstate *p, jsi_Pline *line, const char *varname) { JSI_NEW_CODESLN(0,OP_LOCAL, varname); }\n\nstatic Jsi_OpCodes *code_nop() { JSI_NEW_CODES(0,OP_NOP, 0); }\nstatic Jsi_OpCodes *code_neg() { JSI_NEW_CODES(0,OP_NEG, 0); }\nstatic Jsi_OpCodes *code_pos() { JSI_NEW_CODES(0,OP_POS, 0); }\nstatic Jsi_OpCodes *code_bnot() { JSI_NEW_CODES(0,OP_BNOT, 0); }\nstatic Jsi_OpCodes *code_not() { JSI_NEW_CODES(0,OP_NOT, 0); }\nstatic Jsi_OpCodes *code_mul() { JSI_NEW_CODES(0,OP_MUL, 0); }\nstatic Jsi_OpCodes *code_div() { JSI_NEW_CODES(0,OP_DIV, 0); }\nstatic Jsi_OpCodes *code_mod() { JSI_NEW_CODES(0,OP_MOD, 0); }\nstatic Jsi_OpCodes *code_add() { JSI_NEW_CODES(0,OP_ADD, 0); }\nstatic Jsi_OpCodes *code_sub() { JSI_NEW_CODES(0,OP_SUB, 0); }\nstatic Jsi_OpCodes *code_in() { JSI_NEW_CODES(0,OP_IN, 0); }\nstatic Jsi_OpCodes *code_less() { JSI_NEW_CODES(0,OP_LESS, 0); }\nstatic Jsi_OpCodes *code_greater() { JSI_NEW_CODES(0,OP_GREATER, 0); }\nstatic Jsi_OpCodes *code_lessequ() { JSI_NEW_CODES(0,OP_LESSEQU, 0); }\nstatic Jsi_OpCodes *code_greaterequ() { JSI_NEW_CODES(0,OP_GREATEREQU, 0); }\nstatic Jsi_OpCodes *code_equal() { JSI_NEW_CODES(0,OP_EQUAL, 0); } \nstatic Jsi_OpCodes *code_notequal() { JSI_NEW_CODES(0,OP_NOTEQUAL, 0); }\nstatic Jsi_OpCodes *code_eequ() { JSI_NEW_CODES(0,OP_STRICTEQU, 0); }\nstatic Jsi_OpCodes *code_nneq() { JSI_NEW_CODES(0,OP_STRICTNEQ, 0); }\nstatic Jsi_OpCodes *code_band() { JSI_NEW_CODES(0,OP_BAND, 0); }\nstatic Jsi_OpCodes *code_bor() { JSI_NEW_CODES(0,OP_BOR, 0); }\nstatic Jsi_OpCodes *code_bxor() { JSI_NEW_CODES(0,OP_BXOR, 0); }\nstatic Jsi_OpCodes *code_shf(int right) { JSI_NEW_CODES(0,OP_SHF, right); }\nstatic Jsi_OpCodes *code_instanceof() { JSI_NEW_CODES(0,OP_INSTANCEOF, 0); }\nstatic Jsi_OpCodes *code_assign(jsi_Pstate *p, jsi_Pline *line, int h) { JSI_NEW_CODESLN(0,OP_ASSIGN, h); }\nstatic Jsi_OpCodes *code_subscript(jsi_Pstate *p, jsi_Pline *line, int right_val) { JSI_NEW_CODESLN(0,OP_SUBSCRIPT, right_val); }\nstatic Jsi_OpCodes *code_inc(jsi_Pstate *p, jsi_Pline *line, int e) { JSI_NEW_CODESLN(0,OP_INC, e); }\nstatic Jsi_OpCodes *code_dec(jsi_Pstate *p, jsi_Pline *line, int e) { JSI_NEW_CODESLN(0,OP_DEC, e); }\nstatic Jsi_OpCodes *code_typeof(jsi_Pstate *p, jsi_Pline *line, int e) { JSI_NEW_CODESLN(0,OP_TYPEOF, e); }\n\nstatic Jsi_OpCodes *code__fcall(jsi_Pstate *p, jsi_Pline *line, int argc, const char *name, const char *namePre, Jsi_OpCodes *argCodes) {\n    jsi_FuncCallCheck(p,line,argc,1, name, namePre, argCodes);JSI_NEW_CODESLN(0,OP_FCALL, argc);\n}\nstatic Jsi_OpCodes *code_fcall(jsi_Pstate *p, jsi_Pline *line, int argc, const char *name, const char *namePre, Jsi_OpCodes *argCodes, Jsi_OpCodes* pref) {\n    Jsi_OpCodes *codes = code__fcall(p, line, argc, name, namePre, argCodes);\n    int i;\n    if (!name || !codes || !pref)\n        return codes;\n    jsi_OpLogFlags logflag = jsi_Oplf_none;\n    if (name[0] == 'a' && !Jsi_Strcmp(name, \"assert\"))\n        logflag = jsi_Oplf_assert;\n    else if (name[0] == 'L' && name[1] == 'o') {\n        if (!Jsi_Strcmp(name, \"LogDebug\"))\n            logflag = jsi_Oplf_debug;\n        else if (!Jsi_Strcmp(name, \"LogTrace\"))\n            logflag = jsi_Oplf_trace;\n        else if (!Jsi_Strcmp(name, \"LogTest\"))\n            logflag = jsi_Oplf_test;\n    }\n    if (logflag) {\n        codes->codes[0].logflag = logflag;\n        if (argCodes)\n            for (i=0; i<argCodes->code_len; i++)\n                argCodes->codes[i].logflag = logflag;\n        for (i=0; i<pref->code_len; i++)\n            pref->codes[i].logflag = logflag;\n    }\n    return codes;\n}\nstatic Jsi_OpCodes *code_newfcall(jsi_Pstate *p, jsi_Pline *line, int argc, const char *name, Jsi_OpCodes *argCodes) {\n    jsi_FuncCallCheck(p,line,argc,1, name, NULL, argCodes); JSI_NEW_CODESLN(0,OP_NEWFCALL, argc);\n}\nstatic Jsi_OpCodes *code_ret(jsi_Pstate *p, jsi_Pline *line, int n) { JSI_NEW_CODESLN(0,OP_RET, n); }\nstatic Jsi_OpCodes *code_delete(int n) { JSI_NEW_CODES(0,OP_DELETE, n); }\nstatic Jsi_OpCodes *code_chthis(jsi_Pstate *p, jsi_Pline *line, int n) { JSI_NEW_CODESLN(0,OP_CHTHIS, n); }\nstatic Jsi_OpCodes *code_pop(int n) { JSI_NEW_CODES(0,OP_POP, n); }\nstatic Jsi_OpCodes *code_jfalse(int off) { JSI_NEW_CODES(0,OP_JFALSE, off); }\nstatic Jsi_OpCodes *code_jtrue(int off) { JSI_NEW_CODES(0,OP_JTRUE, off); }\nstatic Jsi_OpCodes *code_jfalse_np(int off) { JSI_NEW_CODES(0,OP_JFALSE_NP, off); }\nstatic Jsi_OpCodes *code_jtrue_np(int off) { JSI_NEW_CODES(0,OP_JTRUE_NP, off); }\nstatic Jsi_OpCodes *code_jmp(int off) { JSI_NEW_CODES(0,OP_JMP, off); }\nstatic Jsi_OpCodes *code_object(jsi_Pstate *p, jsi_Pline *line, int c) { JSI_NEW_CODESLN(0,OP_OBJECT, c); }\nstatic Jsi_OpCodes *code_array(jsi_Pstate *p, jsi_Pline *line, int c) { JSI_NEW_CODESLN(0,OP_ARRAY, c); }\nstatic Jsi_OpCodes *code_key() { JSI_NEW_CODES(0,OP_KEY, 0); }\nstatic Jsi_OpCodes *code_next() { JSI_NEW_CODES(0,OP_NEXT, 0); }\n\nstatic Jsi_OpCodes *code_eval(jsi_Pstate *p, jsi_Pline *line, int argc, Jsi_OpCodes *c) {\n    jsi_FreeOpcodes(c); // Eliminate leak of unused opcodes.\n    JSI_NEW_CODESLN(0,OP_EVAL, argc);\n}\n\nstatic Jsi_OpCodes *code_stry(jsi_Pstate *p, jsi_Pline *line, int trylen, int catchlen, int finlen)\n{ \n    jsi_TryInfo *ti = (jsi_TryInfo *)Jsi_Calloc(1,sizeof(*ti));\n    ti->trylen = trylen;\n    ti->catchlen = catchlen;\n    ti->finallen = finlen;\n    JSI_NEW_CODESLN(1,OP_STRY, ti); \n}\nstatic Jsi_OpCodes *code_etry(jsi_Pstate *p, jsi_Pline *line) { JSI_NEW_CODESLN(0,OP_ETRY, 0); }\nstatic Jsi_OpCodes *code_scatch(jsi_Pstate *p, jsi_Pline *line, const char *var) { JSI_NEW_CODESLN(0,OP_SCATCH, var); }\nstatic Jsi_OpCodes *code_ecatch(jsi_Pstate *p, jsi_Pline *line) { JSI_NEW_CODESLN(0,OP_ECATCH, 0); }\nstatic Jsi_OpCodes *code_sfinal(jsi_Pstate *p, jsi_Pline *line) { JSI_NEW_CODESLN(0,OP_SFINAL, 0); }\nstatic Jsi_OpCodes *code_efinal(jsi_Pstate *p, jsi_Pline *line) { JSI_NEW_CODESLN(0,OP_EFINAL, 0); }\nstatic Jsi_OpCodes *code_throw(jsi_Pstate *p, jsi_Pline *line) { JSI_NEW_CODESLN(0,OP_THROW, 0); }\nstatic Jsi_OpCodes *code_with(jsi_Pstate *p, jsi_Pline *line, int withlen) { JSI_NEW_CODESLN(0,OP_WITH, withlen); }\nstatic Jsi_OpCodes *code_ewith(jsi_Pstate *p, jsi_Pline *line) { JSI_NEW_CODESLN(0,OP_EWITH, 0); }\n\nstatic Jsi_OpCodes *code_debug(jsi_Pstate *p, jsi_Pline *line) { JSI_NEW_CODESLN(0,OP_DEBUG, 0); }\nstatic Jsi_OpCodes *code_reserved(jsi_Pstate *p, jsi_Pline *line, int type, const char *id)\n{\n    jsi_ReservedInfo *ri = (jsi_ReservedInfo*)Jsi_Calloc(1, sizeof(*ri));\n    ri->type = type;\n    ri->label = id;\n    ri->topop = 0;\n    JSI_NEW_CODESLN(1,OP_RESERVED, ri);\n}\n\nstatic jsi_JmpPopInfo *jpinfo_new(int off, int topop)\n{\n    jsi_JmpPopInfo *r = (jsi_JmpPopInfo *)Jsi_Calloc(1, sizeof(*r));\n    r->off = off;\n    r->topop = topop;\n    return r;\n}\n\nstatic void code_reserved_replace(Jsi_OpCodes *ops, int step_len, int break_only,\n                           const char *desire_label, int topop)\n{\n    int i;\n    for (i = 0; i < ops->code_len; ++i) {\n        if (ops->codes[i].op != OP_RESERVED) continue;\n        jsi_ReservedInfo *ri = (jsi_ReservedInfo *)ops->codes[i].data;\n\n        if (ri->label) {\n            if (!desire_label || Jsi_Strcmp(ri->label, desire_label) != 0) {\n                ri->topop += topop;\n                continue;\n            }\n        }\n        \n        if (ri->type == RES_CONTINUE) {\n            if (break_only) {\n                ri->topop += topop;\n                continue;\n            } else {\n                int topop = ri->topop;\n                Jsi_Free(ri);       /* kill reserved Warn, replace with other opcode */\n /*               if (ops->codes[i].data && ops->codes[i].alloc) //TODO: memory leak?\n                    Jsi_Free(ops->codes[i].data);*/\n                if (topop) {\n                    ops->codes[i].data = jpinfo_new(ops->code_len - i, topop);\n                    ops->codes[i].op = OP_JMPPOP;\n                    ops->codes[i].alloc = 1;\n                } else {\n                    ops->codes[i].data = (void *)(uintptr_t)(ops->code_len - i);\n                    ops->codes[i].op = OP_JMP;\n                    ops->codes[i].alloc = 0;\n                }\n            }\n        } else if (ri->type == RES_BREAK) {\n            int topop = ri->topop;\n            Jsi_Free(ri);\n/*           if (ops->codes[i].data && ops->codes[i].alloc)\n                Jsi_Free(ops->codes[i].data); */\n            if (topop) {\n                ops->codes[i].data = jpinfo_new(step_len + ops->code_len - i, topop);\n                ops->codes[i].op = OP_JMPPOP;\n                ops->codes[i].alloc = 1;\n            } else {\n                ops->codes[i].data = (void *)(uintptr_t)(step_len + ops->code_len - i);\n                ops->codes[i].op = OP_JMP;\n                ops->codes[i].alloc = 0;\n            }\n        }\n    }\n}\n\nconst char* jsi_opcode_string(uint opCode)\n{\n    if (opCode >= (sizeof(jsi_op_names)/sizeof(jsi_op_names[0])))\n        return \"NULL\";\n    return jsi_op_names[opCode];\n}\n\nvoid jsi_code_decode(Jsi_Interp *interp, jsi_OpCode *op, int currentip, char *buf, int bsiz)\n{\n    if (_JSICASTINT(op->op) < 0 || op->op >= OP_LASTOP) {\n        snprintf(buf, bsiz, \"Bad opcode[%d] at %d\", op->op, currentip);\n    }\n    char nbuf[JSI_MAX_NUMBER_STRING];\n    snprintf(nbuf, sizeof(nbuf), \"%d#%d\", currentip, op->Line);\n    snprintf(buf, bsiz, \"%-8s %s \", nbuf, jsi_op_names[op->op]);\n\n    int sl = Jsi_Strlen(buf);\n    char *bp = buf + sl;\n    bsiz -= sl;\n    if (op->op == OP_PUSHBOO || op->op == OP_FCALL || op->op == OP_EVAL ||\n        op->op == OP_POP || op->op == OP_ASSIGN ||\n        op->op == OP_RET || op->op == OP_NEWFCALL ||\n        op->op == OP_DELETE || op->op == OP_CHTHIS ||\n        op->op == OP_OBJECT || op->op == OP_ARRAY ||\n        op->op == OP_SHF ||\n        op->op == OP_INC || op->op == OP_DEC) snprintf(bp, bsiz, \"%\" PRId64, (Jsi_Wide)(uintptr_t)op->data);\n    else if (op->op == OP_PUSHNUM) Jsi_NumberDtoA(interp, *((Jsi_Number *)op->data), bp, bsiz, 0);\n    else if (op->op == OP_PUSHVSTR) {\n        Jsi_String *ss = (Jsi_String*)op->data;\n        snprintf(bp, bsiz, \"\\\"%s\\\"\", ss->str);\n    } else if (op->op == OP_PUSHSTR || op->op == OP_LOCAL ||\n             op->op == OP_SCATCH) snprintf(bp, bsiz, \"\\\"%s\\\"\", op->data ? (char*)op->data:\"(NoCatch)\");\n    else if (op->op == OP_PUSHVAR) snprintf(bp, bsiz, \"var: \\\"%s\\\"\", ((jsi_FastVar *)op->data)->varname);\n    else if (op->op == OP_PUSHFUN) snprintf(bp, bsiz, \"func: 0x%\" PRIx64, (Jsi_Wide)(uintptr_t)op->data);\n    else if (op->op == OP_JTRUE || op->op == OP_JFALSE ||\n             op->op == OP_JTRUE_NP || op->op == OP_JFALSE_NP ||\n             op->op == OP_JMP) snprintf(bp, bsiz, \"{%\" PRIu64 \"}\\t#%\" PRIu64 \"\", (Jsi_Wide)(uintptr_t)op->data, (Jsi_Wide)((uintptr_t)currentip + (uintptr_t)op->data));\n    else if (op->op == OP_JMPPOP) {\n        jsi_JmpPopInfo *jp = (jsi_JmpPopInfo*)op->data;\n        snprintf(bp, bsiz, \"{%d},%d\\t#%d\", jp->off, jp->topop, currentip + jp->off);\n    }\n    else if (op->op == OP_STRY) {\n        jsi_TryInfo *t = (jsi_TryInfo *)op->data;\n        snprintf(bp, bsiz, \"{try:%d, catch:%d, final:%d}\", t->trylen, t->catchlen, t->finallen);\n    }\n}\n\nvoid jsi_mark_local(Jsi_OpCodes *ops) // Mark variables as declared with \"var\"\n{\n    return;\n    int i = 0;\n    if (ops == NULL || ops->codes == NULL)\n        return;\n    while (i < ops->code_len) {\n        if (ops->codes[i].op == OP_PUSHVAR)\n            ops->codes[i].local = 1;\n        i++;\n    }\n}\n\nstatic jsi_ForinVar *forinvar_new(jsi_Pstate *pstate, const char *varname, Jsi_OpCodes *local, Jsi_OpCodes *lval)\n{\n    jsi_ForinVar *r = (jsi_ForinVar*)Jsi_Calloc(1,sizeof(*r));\n    r->sig = JSI_SIG_FORINVAR;\n    r->varname = varname;\n    r->local = local;\n    r->lval = lval;\n    return r;\n}\n\nstatic Jsi_OpCodes *make_forin(Jsi_OpCodes *lval, jsi_Pline *line, Jsi_OpCodes *expr, Jsi_OpCodes *stat, const char *label, int isof)\n{\n    Jsi_OpCodes *keycode = code_key();\n    keycode->codes[0].isof = isof;\n    keycode->codes[0].Line = line->first_line;\n    Jsi_OpCodes *init = codes_join(expr, keycode);\n    Jsi_OpCodes *cond = codes_join3(lval, code_next(),\n                                   code_jfalse(stat->code_len + 2));\n    Jsi_OpCodes *stat_jmp = code_jmp(-(cond->code_len + stat->code_len));\n    code_reserved_replace(stat, 1, 0, label, 2);\n    return codes_join3(codes_join(init, cond), \n                          codes_join(stat, stat_jmp), code_pop(2));\n}\n\nstatic jsi_CaseExprStat *exprstat_new(jsi_Pstate *pstate, Jsi_OpCodes *expr, Jsi_OpCodes *stat, int isdef)\n{\n    jsi_CaseExprStat *r = (jsi_CaseExprStat*)Jsi_Calloc(1,sizeof(*r));\n    r->sig = JSI_SIG_CASESTAT;\n    r->expr = expr;\n    r->stat = stat;\n    r->isdefault = isdef;\n    return r;\n}\n\nstatic jsi_CaseList *caselist_new(jsi_Pstate *pstate, jsi_CaseExprStat *es)\n{\n    jsi_CaseList *a = (jsi_CaseList*)Jsi_Calloc(1,sizeof(*a));\n    a->sig = JSI_SIG_CASELIST;\n    a->es = es;\n    a->tail = a;\n    return a;\n}\n\nstatic jsi_CaseList *caselist_insert(jsi_Pstate *pstate, jsi_CaseList *a, jsi_CaseExprStat *es)\n{\n    jsi_CaseList *b = (jsi_CaseList*)Jsi_Calloc(1,sizeof(*b));\n    a->sig = JSI_SIG_CASELIST;\n    b->es = es;\n    a->tail->next = b;\n    a->tail = b;\n    return a;\n}\n\nstatic void caselist_free(jsi_CaseList *c)\n{\n    jsi_CaseList *a = c;\n    while (a) {\n        a = c->next;\n        if (c->es) Jsi_Free(c->es);\n        Jsi_Free(c);\n        c = a;\n    }\n}\n\nstatic Jsi_OpCodes *opassign(jsi_Pstate *pstate, jsi_Pline *line, Jsi_OpCodes *lval, Jsi_OpCodes *oprand, Jsi_OpCodes *op)\n{\n    Jsi_OpCodes *ret;\n    if ((lval)->lvalue_flag == 1) {\n        ret = codes_join3(lval, \n                             codes_join3(code_push_top(), oprand, op),\n                             code_assign(pstate, line, 1));\n    } else {\n        ret = codes_join3(lval,\n                             codes_join4(code_push_top2(), code_subscript(pstate, line, 1), oprand, op),\n                             code_assign(pstate, line, 2));\n    }\n    return ret;\n}\n\n#endif\n#endif\n", "/* The interpreter evaluation engine for jsi. */\n#ifndef JSI_LITE_ONLY\n#ifndef JSI_AMALGAMATION\n#include \"jsiInt.h\"\n#endif\n#include <math.h>\n\n#define _jsi_STACK (interp->Stack)\n#define _jsi_STACKIDX(s) interp->Stack[s]\n#define _jsi_TOP (interp->Stack[interp->framePtr->Sp-1])\n#define _jsi_TOQ (interp->Stack[interp->framePtr->Sp-2])\n#define _jsi_THIS (interp->Obj_this)\n#define _jsi_THISIDX(s) interp->Obj_this[s]\n\nstatic Jsi_RC jsi_EvalLogErr(Jsi_Interp *interp, const char *str) { Jsi_LogMsg(interp, JSI_ERROR, \"%s\", str); return JSI_ERROR; }\n\n#define _jsi_StrictChk(v) ((strict==0 || !Jsi_NumberIsNaN(v->d.num)) ? JSI_OK : jsi_EvalLogErr(interp, \"value is NaN\"))\n#define _jsi_StrictChk2(v1,v2)  ((strict==0  || (Jsi_NumberIsNaN(v1->d.num)==0 && Jsi_NumberIsNaN(v2->d.num)==0))  ? JSI_OK : jsi_EvalLogErr(interp, \"value is NaN\"))\n#define _jsi_StrictUChk(v) ((strict==0 || v->vt != JSI_VT_UNDEF) ? JSI_OK : jsi_EvalLogErr(interp, \"value is undefined\"))\n#define _jsi_StrictUChk2(v1,v2)  ((strict==0  || (v1->vt != JSI_VT_UNDEF && v2->vt != JSI_VT_UNDEF))  ? JSI_OK : jsi_EvalLogErr(interp, \"value is undefined\"))\n#define _jsi_StrictUChk3(v1,v2)  ((strict==0  || (v1->vt != JSI_VT_UNDEF || v2->vt == JSI_VT_UNDEF))  ? JSI_OK : jsi_EvalLogErr(interp, \"lhs value undefined in ===/!==\") )\n\nstatic jsi_Pstate* jsiNewParser(Jsi_Interp* interp, const char *codeStr, Jsi_Channel fp, int iseval)\n{\n    bool isNew;\n    Jsi_HashEntry *hPtr = NULL;\n    hPtr = Jsi_HashEntryNew(interp->codeTbl, (void*)codeStr, &isNew);\n    if (!hPtr) return NULL;\n    jsi_Pstate *ps, *topPs;\n\n    if (isNew==0 && ((ps = (jsi_Pstate *)Jsi_HashValueGet(hPtr)))) {\n        interp->codeCacheHit++;\n        return ps;\n    }\n    ps = jsi_PstateNew(interp);\n    ps->eval_flag = iseval;\n    if (codeStr)\n        jsi_PstateSetString(ps, codeStr);\n    else\n        jsi_PstateSetFile(ps, fp, 1);\n        \n    interp->inParse++;\n    topPs = interp->parsePs;\n    interp->parsePs = ps;\n    yyparse(ps);\n    interp->parsePs = topPs;\n    interp->inParse--;\n    \n    if (ps->err_count) {\n        Jsi_HashEntryDelete(hPtr);\n        jsi_PstateFree(ps);\n        return NULL;\n    }\n    if (isNew) {\n        Jsi_HashValueSet(hPtr, ps);\n        ps->hPtr = hPtr;\n    }\n    return ps;\n}\n\n/* eval here is diff from Jsi_CmdProc, current scope Jsi_LogWarn should be past to eval */\n/* make evaling script execute in the same context */\nstatic Jsi_RC jsiEvalOp(Jsi_Interp* interp, jsi_Pstate *ps, char *program,\n                       jsi_ScopeChain *scope, Jsi_Value *currentScope, Jsi_Value *_this, Jsi_Value **ret)\n{\n    Jsi_RC r = JSI_OK;\n    jsi_Pstate *newps = jsiNewParser(interp, program, NULL, 1);\n    if (newps) {\n        int oef = newps->eval_flag;\n        newps->eval_flag = 1;\n        interp->ps = newps;\n        r = jsi_evalcode(newps, NULL, newps->opcodes, scope, currentScope, _this, ret);\n        if (r) {\n            Jsi_ValueDup2(interp, &ps->last_exception, newps->last_exception);\n        }\n        newps->eval_flag = oef;\n        interp->ps = ps;\n    } else  {\n        //Jsi_ValueMakeStringKey(interp, &ps->last_exception, \"Syntax Error\");\n        r = JSI_ERROR;\n    }\n    return r;\n}\n                     \nstatic Jsi_Value** jsi_ValuesAlloc(Jsi_Interp *interp, int cnt, Jsi_Value**old, int oldsz) {\n    int i;\n    Jsi_Value **v = (Jsi_Value **)Jsi_Realloc(old, cnt* sizeof(Jsi_Value*));\n    for (i=oldsz; i<cnt; i++)\n        v[i] = NULL;\n    return v;\n}\n\nstatic void jsiSetupStack(Jsi_Interp *interp)\n{\n    int oldsz = interp->maxStack;\n    if (interp->maxStack)\n        interp->maxStack += STACK_INCR_SIZE;\n    else\n        interp->maxStack = STACK_INIT_SIZE;\n    _jsi_STACK = jsi_ValuesAlloc(interp, interp->maxStack, _jsi_STACK, oldsz);\n    _jsi_THIS = jsi_ValuesAlloc(interp, interp->maxStack, _jsi_THIS, oldsz); //TODO:!!! use interp->framePtr for this.\n}\n\nstatic void jsiPush(Jsi_Interp* interp, int n) {\n    int i = 0;\n    do {\n        if (!_jsi_STACKIDX(interp->framePtr->Sp))\n            _jsi_STACKIDX(interp->framePtr->Sp) = Jsi_ValueNew1(interp);\n        if (!_jsi_THISIDX(interp->framePtr->Sp))\n            _jsi_THISIDX(interp->framePtr->Sp) = Jsi_ValueNew1(interp);\n        if (i++ >= n) break;\n        interp->framePtr->Sp++;\n    } while (1);\n}\n\n/* Before setting a value in the _jsi_STACK/obj, unlink any reference to it. */\n\nstatic void jsiClearStack(Jsi_Interp *interp, int ofs) {\n    Jsi_Value **vPtr = &_jsi_STACKIDX(interp->framePtr->Sp-ofs), *v = *vPtr;\n    if (!v) return;\n#ifndef XX_NEWSTACK\n    Jsi_ValueReset(interp, vPtr);\n#else\n    if (v->refCnt<=1)\n        Jsi_ValueReset(interp, vPtr);\n    else {\n        Jsi_DecrRefCount(interp, v);\n        _jsi_STACKIDX(interp->framePtr->Sp-ofs) = Jsi_ValueNew1(interp);\n    }\n#endif\n}\n\nstatic void jsiClearThis(Jsi_Interp *interp, int ofs) {\n    Jsi_Value **vPtr = &_jsi_THISIDX(ofs), *v = *vPtr;\n    if (!v) return;\n#ifndef XX_NEWSTACK\n    Jsi_ValueReset(interp, vPtr);\n#else\n    if (v->refCnt<=1)\n        Jsi_ValueReset(interp, vPtr);\n    else {\n        Jsi_DecrRefCount(interp, v);\n        _jsi_THISIDX(ofs) = Jsi_ValueNew1(interp);\n    }\n#endif\n}\n\n\nstatic Jsi_RC inline jsi_ValueAssign(Jsi_Interp *interp, Jsi_Value *dst, Jsi_Value* src, int lop)\n{\n    Jsi_Value *v;\n    if (dst->vt != JSI_VT_VARIABLE) {\n        if (interp->strict) \n            return Jsi_LogError(\"operand not a left value\");\n    } else {\n        v = dst->d.lval;\n        SIGASSERT(v, VALUE);\n        int strict = interp->strict;\n        if (strict && lop == OP_PUSHFUN && interp->curIp[-1].local)\n            dst->f.bits.local = 1;\n        if (strict && dst->f.bits.local==0) {\n            const char *varname = \"\";\n            if (v->f.bits.lookupfailed)\n                varname = v->d.lookupFail;\n            Jsi_RC rc = Jsi_LogType(\"function created global: \\\"%s\\\"\", varname);\n            dst->f.bits.local=1;\n            if (rc != JSI_OK)\n                return rc;\n        }\n        if (v == src)\n            return JSI_OK;\n        if (v->f.bits.readonly) {\n            if (interp->strict) \n                return Jsi_LogError(\"assign to readonly variable\");\n            return JSI_OK;\n        }\n        if (Jsi_ValueIsFunction(interp, src))\n            Jsi_ValueMove(interp,v, src);\n        else\n            Jsi_ValueCopy(interp,v, src);\n        SIGASSERT(v, VALUE);\n        v->f.bits.readonly = 0;\n#ifdef JSI_MEM_DEBUG\n    if (!v->VD.label2)\n        v->VD.label2 = \"ValueAssign\";\n#endif\n    }\n    return JSI_OK;\n}\n\n/* pop n values from _jsi_STACK */\nstatic void jsiPop(Jsi_Interp* interp, int n) {\n    int t = n;\n    while (t > 0) {\n        Assert((interp->framePtr->Sp-t)>=0);\n/*        Jsi_Value *v = _jsi_STACKIDX(interp->framePtr->Sp-t);\n         if (v->refCnt>1) puts(\"OO\");*/\n        jsiClearStack(interp,t);\n        --t;\n    }\n    interp->framePtr->Sp -= n;\n}\n\n/* Convert preceding _jsi_STACK variable(s) into value(s). */\nstatic void jsiVarDeref(Jsi_Interp* interp, int n) {\n    while(interp->framePtr->Sp<n) // Assert and Log may map-out Ops.\n        jsiPush(interp, 1);\n    int i;\n    for (i=1; i<=n; i++) {\n        Jsi_Value *vb = _jsi_STACKIDX(interp->framePtr->Sp - i);\n        if (vb->vt == JSI_VT_VARIABLE) {\n            SIGASSERTV(vb->d.lval, VALUE);\n            Jsi_ValueCopy(interp, vb, vb->d.lval);\n        }\n    }\n}\n\n#define common_math_opr(opr) {                      \\\n    jsiVarDeref(interp,2);                                     \\\n    Jsi_ValueToNumber(interp, _jsi_TOP);     \\\n    Jsi_ValueToNumber(interp, _jsi_TOQ);     \\\n    rc = _jsi_StrictChk2(_jsi_TOP, _jsi_TOQ); \\\n    _jsi_TOQ->d.num = _jsi_TOQ->d.num opr _jsi_TOP->d.num;            \\\n    jsiPop(interp, 1);                                          \\\n}\n\n#define common_bitwise_opr(opr) {                       \\\n    Jsi_UWide a, b;                                       \\\n    jsiVarDeref(interp,2);                                     \\\n    Jsi_ValueToNumber(interp, _jsi_TOP);     \\\n    Jsi_ValueToNumber(interp, _jsi_TOQ);     \\\n    rc = _jsi_StrictChk2(_jsi_TOP, _jsi_TOQ); \\\n    a = _jsi_TOQ->d.num; b = _jsi_TOP->d.num;                   \\\n    _jsi_TOQ->d.num = (Jsi_Number)(a opr b);                  \\\n    jsiPop(interp, 1);                                          \\\n}\n\nstatic Jsi_RC jsi_logic_less(Jsi_Interp* interp, int i1, int i2) {\n    Jsi_Value *v, *v1 = _jsi_STACK[interp->framePtr->Sp-i1], *v2 = _jsi_STACK[interp->framePtr->Sp-i2], *res = _jsi_TOQ;\n    int val = 0, l1 = 0, l2 = 0; \n    bool strict = interp->strict;\n    Jsi_RC rc = JSI_OK;\n    rc = _jsi_StrictUChk2(v1, v2);\n    if (rc != JSI_OK)\n        return JSI_ERROR;\n    char *s1 = Jsi_ValueString(interp, v1, &l1);\n    char *s2 = Jsi_ValueString(interp, v2, &l2);\n    Jsi_Number n1, n2;\n\n    if (s1 || s2) {\n        char *str;\n        if (!(s1 && s2)) {\n            v = (s1 ? v2 : v1);\n            jsi_ValueToPrimitive(interp, &v);\n            Jsi_ValueToString(interp, v, NULL);\n            str = Jsi_ValueString(interp, v, (s1?&l2:&l1));\n            if (s1) s2 = str; else s1 = str;\n        }\n        Assert(l1>=0 && l1<=JSI_MAX_ALLOC_BUF);\n        Assert(l2>=0 && l2<=JSI_MAX_ALLOC_BUF);\n        //int mlen = (l1>l2?l1:l2);\n        val = Jsi_Strcmp(s1, s2);\n  \n        if (val > 0) val = 0;\n        else if (val < 0) val = 1;\n        else val = (l1 < l2);\n        jsiClearStack(interp,2);\n        Jsi_ValueMakeBool(interp, &res, val);\n    } else {\n        Jsi_ValueToNumber(interp, v1);\n        Jsi_ValueToNumber(interp, v2);\n        rc = _jsi_StrictChk2(v1,v2);\n        if (rc != JSI_OK)\n            return JSI_ERROR;\n        n1 = v1->d.num; n2 = v2->d.num;\n        if (Jsi_NumberIsNaN(n1) || Jsi_NumberIsNaN(n2)) {\n            jsiClearStack(interp,2);\n            Jsi_ValueMakeUndef(interp, &res);\n        } else {\n            val = (n1 < n2);\n            jsiClearStack(interp,2);\n            Jsi_ValueMakeBool(interp, &res, val);\n        }\n    }\n    return JSI_OK;\n}\n\nstatic const char *jsi_evalprint(Jsi_Value *v)\n{\n    static char buf[JSI_MAX_NUMBER_STRING];\n    if (!v)\n        return \"nil\";\n    if (v->vt == JSI_VT_NUMBER) {\n        snprintf(buf, sizeof(buf), \"NUM:%\" JSI_NUMGFMT \" \", v->d.num);\n    } else if (v->vt == JSI_VT_BOOL) {\n        snprintf(buf, sizeof(buf), \"BOO:%d\", v->d.val);\n    } else if (v->vt == JSI_VT_STRING) {\n        snprintf(buf, sizeof(buf), \"STR:'%s'\", v->d.s.str);\n    } else if (v->vt == JSI_VT_VARIABLE) {\n        snprintf(buf, sizeof(buf), \"VAR:%p\", v->d.lval);\n    } else if (v->vt == JSI_VT_NULL) {\n        snprintf(buf, sizeof(buf), \"NULL\");\n    } else if (v->vt == JSI_VT_OBJECT) {\n        snprintf(buf, sizeof(buf), \"OBJ:%p\", v->d.obj);\n    } else if (v->vt == JSI_VT_UNDEF) {\n        snprintf(buf, sizeof(buf), \"UNDEFINED\");\n    }\n    return buf;\n}\n/* destroy top of trylist */\n#define pop_try(head) jsi_pop_try(interp, &head)\nstatic void jsi_pop_try(Jsi_Interp* interp, jsi_TryList **head)\n{\n    interp->framePtr->tryDepth--;\n    jsi_TryList *t = (*head)->next;\n    Jsi_Free(*head);\n    *head = t;\n    interp->tryList = t;\n}\n\nstatic void jsi_push_try(Jsi_Interp* interp, jsi_TryList **head, jsi_TryList *n)\n{\n    interp->tryList = n;\n    interp->framePtr->tryDepth++;\n    n->next = *head;\n    *head = n;\n}\n\n/* restore scope chain */\n#define JSI_RESTORE_SCOPE() jsi_restore_scope(interp, ps, trylist, \\\n    &scope, &currentScope, &context_id)\nstatic void jsi_restore_scope(Jsi_Interp* interp, jsi_Pstate *ps, jsi_TryList* trylist,\n  jsi_ScopeChain **scope, Jsi_Value **currentScope, int *context_id) {\n\n/* JSI_RESTORE_SCOPE(scope_save, curscope_save)*/\n    if (*scope != (trylist->scope_save)) {\n        jsi_ScopeChainFree(interp, *scope);\n        *scope = (trylist->scope_save);\n        interp->framePtr->ingsc = *scope;\n    }\n    if (*currentScope != (trylist->curscope_save)) {\n        Jsi_DecrRefCount(interp, *currentScope);\n        *currentScope = (trylist->curscope_save); \n        interp->framePtr->incsc = *currentScope;\n    }\n    *context_id = ps->_context_id++; \n}\n\n#define JSI_DO_THROW(nam) if (jsi_do_throw(interp, ps, &ip, &trylist,&scope, &currentScope, &context_id, (interp->framePtr->Sp?_jsi_TOP:NULL), nam) != JSI_OK) { rc = JSI_ERROR; break; }\n\nstatic int jsi_do_throw(Jsi_Interp *interp, jsi_Pstate *ps, jsi_OpCode **ipp, jsi_TryList **tlp,\n     jsi_ScopeChain **scope, Jsi_Value **currentScope, int *context_id, Jsi_Value *top, const char *nam) {\n    if (Jsi_InterpGone(interp))\n        return JSI_ERROR;\n    jsi_TryList *trylist = *tlp;\n    while (1) {\n        if (trylist == NULL) {\n            const char *str = (top?Jsi_ValueString(interp, top, NULL):\"\");\n            if (str) {\n                if (!Jsi_Strcmp(nam, \"help\"))\n                    Jsi_LogError(\"...%s\", str);\n                else\n                    Jsi_LogError(\"%s: %s\", nam, str);\n            }\n            return JSI_ERROR;\n        }\n        if (trylist->type == jsi_TL_TRY) {\n            int n = interp->framePtr->Sp - trylist->d.td.tsp;\n            jsiPop(interp, n);\n            if (*ipp >= trylist->d.td.tstart && *ipp < trylist->d.td.tend) {\n                *ipp = trylist->d.td.cstart - 1;\n                break;\n            } else if (*ipp >= trylist->d.td.cstart && *ipp < trylist->d.td.cend) {\n                trylist->d.td.last_op = jsi_LOP_THROW;\n                *ipp = trylist->d.td.fstart - 1;\n                break;\n            } else if (*ipp >= trylist->d.td.fstart && *ipp < trylist->d.td.fend) {\n                jsi_pop_try(interp, tlp);\n                trylist = *tlp;\n            } else Jsi_LogBug(\"Throw within a try, but not in its scope?\");\n        } else {\n            jsi_restore_scope(interp, ps, trylist, scope, currentScope, context_id);\n            jsi_pop_try(interp, tlp);\n            trylist = *tlp;\n        }\n    }\n    return JSI_OK;\n}\n\nstatic jsi_TryList *jsi_trylist_new(jsi_try_op_type t, jsi_ScopeChain *scope_save, Jsi_Value *curscope_save)\n{\n    jsi_TryList *n = (jsi_TryList *)Jsi_Calloc(1,sizeof(*n));\n    \n    n->type = t;\n    n->curscope_save = curscope_save;\n    /*Jsi_IncrRefCount(interp, curscope_save);*/\n    n->scope_save = scope_save;\n    \n    return n;\n}\n\nstatic void jsiDumpInstr(Jsi_Interp *interp, jsi_Pstate *ps, Jsi_Value *_this,\n    jsi_TryList *trylist, jsi_OpCode *ip, Jsi_OpCodes *opcodes)\n{\n    int i;\n    char buf[JSI_MAX_NUMBER_STRING*2];\n    jsi_code_decode(interp, ip, ip - opcodes->codes, buf, sizeof(buf));\n    Jsi_Printf(interp, jsi_Stderr, \"%p: %-30.200s : THIS=%s, STACK=[\", ip, buf, jsi_evalprint(_this));\n    for (i = 0; i < interp->framePtr->Sp; ++i) {\n        Jsi_Printf(interp, jsi_Stderr, \"%s%s\", (i>0?\", \":\"\"), jsi_evalprint(_jsi_STACKIDX(i)));\n    }\n    Jsi_Printf(interp, jsi_Stderr, \"]\");\n    if (ip->fname) {\n        const char *fn = ip->fname,  *cp = Jsi_Strrchr(fn, '/');\n        if (cp) fn = cp+1;\n        Jsi_Printf(interp, jsi_Stderr, \", %s:%d\", fn, ip->Line);\n    }\n    Jsi_Printf(interp, jsi_Stderr, \"\\n\");\n    jsi_TryList *tlt = trylist;\n    for (i = 0; tlt; tlt = tlt->next) i++;\n    if (ps->last_exception)\n        Jsi_Printf(interp, jsi_Stderr, \"TL: %d, excpt: %s\\n\", i, jsi_evalprint(ps->last_exception));\n}\n\nstatic int jsi_cmpstringp(const void *p1, const void *p2)\n{\n   return Jsi_Strcmp(* (char * const *) p1, * (char * const *) p2);\n}\n\nvoid jsi_SortDString(Jsi_Interp *interp, Jsi_DString *dStr, const char *sep) {\n    int argc, i;\n    char **argv;\n    Jsi_DString sStr;\n    Jsi_DSInit(&sStr);\n    Jsi_SplitStr(Jsi_DSValue(dStr), &argc, &argv, sep, &sStr);\n    qsort(argv, argc, sizeof(char*), jsi_cmpstringp);\n    Jsi_DSSetLength(dStr, 0);\n    for (i=0; i<argc; i++)\n        Jsi_DSAppend(dStr, (i?\" \":\"\"), argv[i], NULL);\n    Jsi_DSFree(&sStr);\n}\n\nstatic void jsi_ValueObjDelete(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *key, int force)\n{\n    if (target->vt != JSI_VT_OBJECT) return;\n    const char *kstr = Jsi_ValueToString(interp, key, NULL);\n    Jsi_TreeEntry *hPtr;\n    if (!Jsi_ValueIsStringKey(interp, key)) {\n        Jsi_MapEntry *hePtr = Jsi_MapEntryFind(target->d.obj->tree->opts.interp->strKeyTbl, kstr);\n        if (hePtr)\n            kstr = (char*)Jsi_MapKeyGet(hePtr, 0);\n    }\n    hPtr = Jsi_TreeEntryFind(target->d.obj->tree, kstr);\n    if (hPtr == NULL || (hPtr->f.bits.dontdel && !force))\n        return;\n    Jsi_TreeEntryDelete(hPtr);\n}\n\nstatic void jsiObjGetNames(Jsi_Interp *interp, Jsi_Obj *obj, Jsi_DString* dStr, int flags) {\n    Jsi_TreeEntry *hPtr;\n    Jsi_TreeSearch srch;\n    Jsi_Value *v;\n    int m = 0;\n    Jsi_DSInit(dStr);\n    if (obj->isarrlist)\n        obj = interp->Array_prototype->d.obj;\n    else if (!obj->tree->numEntries && obj->__proto__)\n        obj = obj->__proto__->d.obj;\n    for (hPtr=Jsi_TreeSearchFirst(obj->tree, &srch,  JSI_TREE_ORDER_IN, NULL); hPtr; hPtr=Jsi_TreeSearchNext(&srch)) {\n        v = (Jsi_Value*)Jsi_TreeValueGet(hPtr);\n        if (!v) continue;\n        if ((flags&JSI_NAME_FUNCTIONS) && !Jsi_ValueIsFunction(interp,v)) {\n            continue;\n        }\n        if ((flags&JSI_NAME_DATA) && Jsi_ValueIsFunction(interp,v)) {\n            continue;\n        }\n\n        Jsi_DSAppend(dStr, (m++?\" \":\"\"), Jsi_TreeKeyGet(hPtr), NULL);\n    }\n    Jsi_TreeSearchDone(&srch);\n}\n\nstatic void jsi_DumpFunctions(Jsi_Interp *interp, const char *spnam) {\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    Jsi_MapEntry *hPtr;\n    Jsi_MapSearch search;\n    Jsi_CmdSpecItem *csi = NULL;\n    Jsi_CmdSpec *cs;\n    Jsi_Value *lsf = interp->lastSubscriptFail;\n    Jsi_Obj *lso = ((lsf && lsf->vt == JSI_VT_OBJECT)?lsf->d.obj:0);\n    const char *varname = NULL;\n    int m = 0;\n    \n    if (lso) {\n        spnam = interp->lastSubscriptFailStr;\n        if (!spnam) spnam = interp->lastPushStr;\n        if (!spnam) spnam = \"\";\n        if (lso->ot == JSI_OT_USEROBJ && lso->d.uobj->reg && lso->d.uobj->interp == interp) {\n            cs = lso->d.uobj->reg->spec;\n            if (cs)\n                goto dumpspec;\n        } else if (lso->ot == JSI_OT_FUNCTION) {\n            cs = lso->d.fobj->func->cmdSpec;\n            if (cs)\n                goto dumpspec;\n        } else if (lso->ot == JSI_OT_OBJECT) {\n            jsiObjGetNames(interp, lso, &dStr, JSI_NAME_FUNCTIONS);\n            Jsi_LogError(\"'%s', functions are: %s.\",\n                spnam, Jsi_DSValue(&dStr));\n            Jsi_DSFree(&dStr);\n            return;\n        } else {\n            const char *sustr = NULL;\n            switch (lso->ot) {\n                case JSI_OT_STRING: sustr = \"String\"; break;\n                case JSI_OT_NUMBER: sustr = \"Number\"; break;\n                case JSI_OT_BOOL: sustr = \"Boolean\"; break;\n                default: break;\n            }\n            if (sustr) {\n                hPtr = Jsi_MapEntryFind(interp->cmdSpecTbl, sustr);\n                csi = (Jsi_CmdSpecItem*)Jsi_MapValueGet(hPtr);\n                cs = csi->spec;\n                if (!spnam[0])\n                    spnam = sustr;\n                goto dumpspec;\n            }\n        }\n    }\n    if (!spnam) spnam = \"\";\n    if (!*spnam) {\n        for (hPtr = Jsi_MapSearchFirst(interp->cmdSpecTbl, &search, 0);\n            hPtr; hPtr = Jsi_MapSearchNext(&search)) {\n            csi = (Jsi_CmdSpecItem*)Jsi_MapValueGet(hPtr);\n            if (csi->name && csi->name[0])\n                Jsi_DSAppend(&dStr, (m++?\" \":\"\"), csi->name, NULL);\n        }\n        Jsi_MapSearchDone(&search);\n    }\n    \n    varname = spnam;\n    if ((hPtr = Jsi_MapEntryFind(interp->cmdSpecTbl, spnam))) {\n        csi = (Jsi_CmdSpecItem*)Jsi_MapValueGet(hPtr);\n        while (csi) {\n            int n;\n            cs = csi->spec;\ndumpspec:\n            n = 0;\n            while (cs->name) {\n                if (n != 0 || !(cs->flags & JSI_CMD_IS_CONSTRUCTOR)) {\n                    if (!*cs->name) continue;\n                    Jsi_DSAppend(&dStr, (m?\" \":\"\"), cs->name, NULL);\n                    n++; m++;\n                }\n                cs++;\n            }\n            csi = (csi?csi->next:NULL);\n        }\n        jsi_SortDString(interp, &dStr, \" \");\n        if (varname)\n            spnam = varname;\n        else if (interp->lastPushStr && !spnam[0])\n            spnam = interp->lastPushStr;\n        Jsi_LogError(\"'%s' sub-commands are: %s.\",\n            spnam, Jsi_DSValue(&dStr));\n        Jsi_DSFree(&dStr);\n    } else {\n        Jsi_LogError(\"can not execute expression: '%s' not a function\",\n            varname ? varname : \"\");\n    }\n}\n\n/* Attempt to dynamically load function XX by doing an eval of Jsi_Auto.XX */\n/* TODO: prevent infinite loop/recursion. */\nJsi_Value *jsi_LoadFunction(Jsi_Interp *interp, const char *str, Jsi_Value *tret) {\n    Jsi_DString dStr = {};\n    Jsi_Value *v;\n    int i;\n    const char *curFile = interp->curFile;\n    interp->curFile = \"<jsiLoadFunction>\";\n    for (i=0; i<2; i++) {\n        Jsi_DSAppend(&dStr, \"Jsi_Auto.\", str, NULL);\n        Jsi_VarLookup(interp, Jsi_DSValue(&dStr));\n        v = Jsi_NameLookup(interp, Jsi_DSValue(&dStr));\n        if (v)\n            jsi_ValueDebugLabel(v, \"jsiLoadFunction\",\"f1\");\n        Jsi_DSFree(&dStr);\n        if (v) {\n            const char *cp = Jsi_ValueGetDString(interp, v, &dStr, 0);\n            v = NULL;\n            if (Jsi_EvalString(interp, cp, 0) == JSI_OK) {\n                v = Jsi_NameLookup(interp, str);\n                if (v)\n                    jsi_ValueDebugLabel(v, \"jsiLoadFunction\",\"f2\");\n            }\n            Jsi_DSFree(&dStr);\n            if (v) {\n                tret = v;\n                break;\n            }\n        }\n        if (interp->autoLoaded++ || i>0)\n            break;\n        /*  Index not in memory, so try loading Jsi_Auto from the autoload.jsi file. */\n        if (interp->autoFiles == NULL)\n            return tret;\n        Jsi_Value **ifs = &interp->autoFiles;\n        int i, ifn = 1;\n        if (Jsi_ValueIsArray(interp, interp->autoFiles)) {\n            ifs = interp->autoFiles->d.obj->arr;\n            ifn = interp->autoFiles->d.obj->arrCnt;\n        }\n        for (i=0; i<ifn; i++) {  \n            if (Jsi_EvalFile(interp, ifs[i], 0) != JSI_OK)\n                break;\n            interp->autoLoaded++;\n        }\n    }\n    interp->curFile = curFile;\n    return tret;\n}\n\nvoid jsi_TraceFuncCall(Jsi_Interp *interp, Jsi_Func *fstatic, jsi_OpCode *iPtr,\n    Jsi_Value *_this, Jsi_Value* args, Jsi_Value *ret, int tc)\n{\n    jsi_OpCode *ip = (iPtr ? iPtr : interp->curIp);\n    if (!ip)\n        return;\n    const char *ff, *fname = ip->fname?ip->fname:\"\";\n    if ((tc&jsi_callTraceFullPath)==0 && ((ff=Jsi_Strrchr(fname,'/'))))\n        fname = ff+1;\n    if (interp->traceHook)\n        (*interp->traceHook)(interp, fstatic->name, ip->fname, ip->Line, fstatic->cmdSpec, _this, args, ret);\n    else {\n        const char *fp = ((tc&jsi_callTraceNoParent)?NULL:fstatic->parentName);\n        if (fp && !*fp)\n            fp = NULL;\n        Jsi_DString aStr;\n        Jsi_DSInit(&aStr);\n        Jsi_DString dStr;\n        Jsi_DSInit(&dStr);\n        Jsi_DString pStr;\n        Jsi_DSInit(&pStr);\n        Jsi_DString *sPtr = NULL;\n        int plen = 0;\n        if (ret) {\n            sPtr = &dStr;\n            Jsi_DSAppend(sPtr, \" <-- \", NULL);\n            plen = Jsi_DSLength(sPtr);\n            Jsi_ValueGetDString(interp, ret, sPtr, 0);\n        } else if ((tc&jsi_callTraceArgs)) {\n            sPtr = &aStr;\n            Jsi_ValueGetDString(interp, args, sPtr, JSI_OUTPUT_JSON);\n        }\n        if (sPtr) {\n            if (!(tc&jsi_callTraceNoTrunc)) {\n                const char *cp0 = Jsi_DSValue(sPtr), *cp1 = Jsi_Strchr(cp0, '\\n');\n                int nlen = 0, clen = Jsi_DSLength(sPtr);\n                if (cp1) {\n                    nlen = (cp1-cp0);\n                    if (nlen>60) nlen = 60;\n                }  else if (clen>60)\n                    nlen = 60;\n                else nlen = clen;\n                if (nlen != clen && clen>plen) {\n                    Jsi_DSSetLength(sPtr, nlen);\n                    Jsi_DSAppend(sPtr, \"...\", NULL);\n                }\n            }\n        }\n        if (interp->parent && interp->debugOpts.traceCallback) {\n            Jsi_DString jStr={}, kStr={}, lStr={};\n            Jsi_DSPrintf(&kStr, \"[\\\"%s%s%s\\\", %s, %s, \\\"%s\\\", %d, %d ]\",\n                (fp?fp:\"\"), (fp?\".\":\"\"), fstatic->name, \n                (ret?\"null\":Jsi_JSONQuote(interp, Jsi_DSValue(&aStr),-1, &jStr)),\n                (ret?Jsi_JSONQuote(interp, Jsi_DSValue(&dStr),-1, &lStr):\"null\"),\n                 fname, ip->Line, ip->Lofs);\n            if (Jsi_FunctionInvokeJSON(interp->parent, interp->debugOpts.traceCallback, Jsi_DSValue(&kStr), NULL) != JSI_OK)\n                Jsi_DSPrintf(&pStr, \"failed trace call\\n\");\n            Jsi_DSFree(&jStr);\n            Jsi_DSFree(&kStr);\n            Jsi_DSFree(&lStr);\n        } else if ((tc&jsi_callTraceBefore))\n            Jsi_DSPrintf(&pStr, \"%s:%d %*s#%d: %c %s%s%s(%s) %s\\n\",\n                fname, ip->Line,\n                (interp->level-1)*2, \"\", interp->level,\n                (ret?'<':'>'), (fp?fp:\"\"), (fp?\".\":\"\"), fstatic->name, Jsi_DSValue(&aStr), Jsi_DSValue(&dStr));\n        else {\n            if (!interp->curIp || !interp->logOpts.before) {\n                Jsi_DSPrintf(&pStr, \"%*s#%d: %c %s%s%s(%s) in %s:%d%s\\n\", (interp->level-1)*2, \"\", interp->level,\n                    (ret?'<':'>'), (fp?fp:\"\"), (fp?\".\":\"\"), fstatic->name, Jsi_DSValue(&aStr),\n                fname, ip->Line, Jsi_DSValue(&dStr));\n            } else {\n                int quote = 0;\n                jsi_SysPutsCmdPrefix(interp, &interp->logOpts, &pStr, &quote, NULL);\n                Jsi_DSPrintf(&pStr, \"%*s#%d: %c %s%s%s(%s) \\n\", (interp->level-1)*2, \"\", interp->level,\n                    (ret?'<':'>'), (fp?fp:\"\"), (fp?\".\":\"\"), fstatic->name, Jsi_DSValue(&aStr));\n                Jsi_DSAppend(&pStr, Jsi_DSValue(&dStr), NULL);\n            }\n        }\n        if (Jsi_DSLength(&pStr))\n            Jsi_Puts(interp, jsi_Stderr, Jsi_DSValue(&pStr), -1);\n        Jsi_DSFree(&pStr);\n        Jsi_DSFree(&dStr);\n        Jsi_DSFree(&aStr);\n    }\n}\n\nJsi_RC jsi_FunctionSubCall(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Value *tocall, int discard)\n{\n    Jsi_RC rc = JSI_OK;\n    const char *oldCurFunc = interp->curFunction, *spnam = \"\";\n    jsi_OpCode *ip = interp->curIp;\n    int adds, as_constructor = (ip->op == OP_NEWFCALL);\n    double timStart = 0;\n    int docall;\n    int calltrc = 0, profile = interp->profile, coverage = interp->coverage;\n    jsi_PkgInfo *pkg;\n    int tc;\n    \n    //char *lpv = interp->lastPushStr;\n    if (tocall->vt == JSI_VT_UNDEF && tocall->f.bits.lookupfailed && tocall->d.lookupFail && !interp->noAutoLoad) {\n        spnam = tocall->d.lookupFail;\n        tocall->f.bits.lookupfailed = 0;\n        tocall = jsi_LoadFunction(interp, spnam, tocall);\n        interp->lastPushStr = (char*)spnam;\n        interp->curIp = ip;\n    }\n    if (!Jsi_ValueIsFunction(interp, tocall)) {\n       // if (tocall->f.bits.subscriptfailed && tocall->d.lookupFail)\n       //     spnam = tocall->d.lookupFail;\n        jsi_DumpFunctions(interp, spnam);\n        rc = JSI_ERROR;\n        goto empty_func;\n    }\n\n    if (tocall->d.obj->d.fobj==NULL || tocall->d.obj->d.fobj->func==NULL) {   /* empty function */\nempty_func:\n        //jsiPop(interp, stackargc);\n        //jsiClearStack(interp,1);\n        //Jsi_ValueMakeUndef(interp, &_jsi_TOP);\n        interp->curFunction = oldCurFunc;\n        Jsi_DecrRefCount(interp, _this);\n        if (rc==JSI_OK)\n            rc = JSI_CONTINUE;\n        return rc;\n        //goto done;\n    }\n    \n    Jsi_FuncObj *fobj = tocall->d.obj->d.fobj;\n    Jsi_Func *funcPtr = fobj->func;\n    if (funcPtr->callback == jsi_NoOpCmd || tocall->d.obj->isNoOp) {\n        jsi_NoOpCmd(interp, NULL, NULL, NULL, NULL);\n        goto empty_func;\n    }\n    if (!interp->asserts && funcPtr->callback == jsi_AssertCmd)\n        goto empty_func;\n    const char *onam = funcPtr->name;\n//        if (!onam) // Override blank name with last index.\n//            funcPtr->name = lpv;\n    if (funcPtr->name && funcPtr->name[0] && funcPtr->type == FC_NORMAL)\n        interp->curFunction = funcPtr->name;\n    adds = funcPtr->callflags.bits.addargs;\n    Jsi_CmdSpec *cs  = funcPtr->cmdSpec;\n    if (adds && (cs->flags&JSI_CMDSPEC_NONTHIS))\n        adds = 0;\n\n    Jsi_Func *pprevActive = interp->prevActiveFunc, *prevActive = interp->prevActiveFunc = interp->activeFunc;\n    interp->activeFunc = funcPtr;\n\n    rc = jsi_SharedArgs(interp, args, funcPtr, 1); /* make arg vars to share arguments */\n    if (rc != JSI_OK)\n        goto bail;\n    funcPtr->callflags.bits.addargs = 0;\n    jsi_InitLocalVar(interp, args, funcPtr);\n    jsi_SetCallee(interp, args, tocall);\n    \n    pkg = funcPtr->pkg;\n    tc = interp->traceCall;\n    if (pkg) {\n        tc |= pkg->popts.modConf.traceCall;\n        profile |= pkg->popts.modConf.profile;\n        coverage |= pkg->popts.modConf.coverage;\n    }\n\n    if (as_constructor) {                       /* new Constructor */\n        Jsi_Obj *newobj = Jsi_ObjNewType(interp, JSI_OT_OBJECT);\n        Jsi_Value *proto = NULL;\n        if (!interp->subOpts.noproto)\n            proto = Jsi_ValueObjLookup(interp, tocall, \"prototype\", 0);\n        if (proto && proto->vt == JSI_VT_OBJECT) {\n            newobj->__proto__ = proto;\n            newobj->clearProto = 1;\n            Jsi_IncrRefCount(interp, proto);\n        }\n        Jsi_ValueReset(interp, &_this);\n        Jsi_ValueMakeObject(interp, &_this, newobj);            \n        /* TODO: constructor specifics??? */\n        calltrc = (tc&jsi_callTraceNew);\n    }\n    if (funcPtr->type == FC_NORMAL)\n        calltrc = (tc&jsi_callTraceFuncs);\n    else\n        calltrc = (tc&jsi_callTraceCmds);\n    if (calltrc && funcPtr->name)\n        jsi_TraceFuncCall(interp, funcPtr, ip, _this, args, 0, tc);\n\n    //Jsi_Value *spretPtr = *ret;\n \n    interp->activeFunc = funcPtr;\n    docall = (rc==JSI_OK);\n    if (profile || coverage) {\n        interp->profileCnt++;\n        timStart = jsi_GetTimestamp();\n    }\n    if (funcPtr->type == FC_NORMAL) {\n        if (docall) {\n            rc = jsi_evalcode(interp->ps, funcPtr, funcPtr->opcodes, tocall->d.obj->d.fobj->scope, \n                args, _this, ret);\n        }\n        interp->funcCallCnt++;\n    } else if (!funcPtr->callback) {\n        Jsi_LogError(\"can not call:\\\"%s()\\\"\", funcPtr->name);\n    } else {\n        int oldcf = funcPtr->callflags.i;\n        funcPtr->callflags.bits.iscons = (as_constructor?JSI_CALL_CONSTRUCTOR:0);\n        if (funcPtr->f.bits.hasattr)\n        {\n#define SPTR(s) (s?s:\"\")\n            if ((funcPtr->f.bits.isobj) && _this->vt != JSI_VT_OBJECT) {\n                rc = JSI_ERROR;\n                docall = 0;\n                Jsi_LogError(\"'this' is not object: \\\"%s()\\\"\", funcPtr->name);\n            } else if ((!(funcPtr->f.bits.iscons)) && as_constructor) {\n                rc = JSI_ERROR;\n                docall = 0;\n                Jsi_LogError(\"can not call as constructor: \\\"%s()\\\"\", funcPtr->name);\n            } else {\n                int aCnt = Jsi_ValueGetLength(interp, args);\n                if (aCnt<(cs->minArgs+adds)) {\n                    Jsi_LogError(\"missing args, expected \\\"%s(%s)\\\" \", cs->name, SPTR(cs->argStr));\n                    rc = JSI_ERROR;\n                    docall = 0;\n                } else if (cs->maxArgs>=0 && (aCnt>cs->maxArgs+adds)) {\n                    Jsi_LogError(\"extra args, expected \\\"%s(%s)\\\" \", cs->name, SPTR(cs->argStr));\n                    rc = JSI_ERROR;\n                    docall = 0;\n                }\n            }\n        }\n        if (docall) {\n            funcPtr->fobj = fobj; // Backlink for bind.\n            funcPtr->callflags.bits.isdiscard = discard;\n            rc = funcPtr->callback(interp, args, \n                _this, ret, funcPtr);\n            interp->cmdCallCnt++;\n        }\n        funcPtr->callflags.i = oldcf;\n    }\n    if (profile || coverage) {\n        double timEnd = jsi_GetTimestamp(), timUsed = (timEnd - timStart);;\n        assert(timUsed>=0);\n        funcPtr->allTime += timUsed;\n        if (interp->framePtr->evalFuncPtr)\n            interp->framePtr->evalFuncPtr->subTime += timUsed;\n        else\n            interp->subTime += timUsed;\n    }\n    if (calltrc && (tc&jsi_callTraceReturn) && funcPtr->name)\n        jsi_TraceFuncCall(interp, funcPtr, ip, _this, NULL, *ret, tc);\n    if (!onam)\n        funcPtr->name = NULL;\n    if (docall) {\n        funcPtr->callCnt++;\n        if (rc == JSI_OK && !as_constructor && funcPtr->retType && (interp->typeCheck.all || interp->typeCheck.run))\n            rc = jsi_ArgTypeCheck(interp, funcPtr->retType, *ret, \"returned from\", funcPtr->name, 0, funcPtr, 0);\n    }\n    interp->prevActiveFunc = pprevActive;\n    interp->activeFunc = prevActive;\n\n    if (as_constructor) {\n        if (_this->vt == JSI_VT_OBJECT)\n            _this->d.obj->constructor = tocall->d.obj;\n        if ((*ret)->vt != JSI_VT_OBJECT) {\n            Jsi_ValueReset(interp, ret);\n            Jsi_ValueCopy(interp, *ret, _this);\n        }\n    }\n\nbail:\n    jsi_SharedArgs(interp, args, funcPtr, 0); /* make arg vars to shared arguments */\n    Jsi_DecrRefCount(interp, _this);\n    interp->curFunction = oldCurFunc;\n\n    return rc;\n}\n\nJsi_RC jsiEvalFunction(jsi_Pstate *ps, jsi_OpCode *ip, int discard) {\n    Jsi_Interp *interp = ps->interp;\n    int stackargc = (int)(uintptr_t)ip->data;\n    jsiVarDeref(interp, stackargc + 1);\n    int tocall_index = interp->framePtr->Sp - stackargc - 1;\n    Jsi_Value *_this = _jsi_THISIDX(tocall_index),\n        *tocall = _jsi_STACKIDX(tocall_index), **spargs = _jsi_STACK+(interp->framePtr->Sp - stackargc),   \n        *spretPtr = Jsi_ValueNew1(interp), *spretPtrOld = spretPtr,\n        *args = Jsi_ValueNewArrayObj(interp, spargs, stackargc, 1);\n        \n    Jsi_IncrRefCount(interp, args);\n    if (_this->vt != JSI_VT_OBJECT)\n        _this = Jsi_ValueDup(interp, interp->Top_object);\n    else {\n        _this = Jsi_ValueDup(interp, _this);\n        jsiClearThis(interp, tocall_index);\n    }   \n    Jsi_RC rc = jsi_FunctionSubCall(interp, args, _this, &spretPtr, tocall, discard);\n    \n    jsiPop(interp, stackargc);\n    jsiClearStack(interp,1);\n    if (rc == JSI_CONTINUE) {\n        Jsi_ValueMakeUndef(interp, &_jsi_TOP);\n        rc = JSI_OK;\n    }\n    if (spretPtr == spretPtrOld) {\n        Jsi_ValueMove(interp, _jsi_TOP, spretPtr);\n        Jsi_DecrRefCount(interp, spretPtr);\n    } else {\n        /*  returning a (non-copied) value reference */\n        Jsi_DecrRefCount(interp, _jsi_TOP);\n        _jsi_TOP = spretPtr;\n    }\n    Jsi_DecrRefCount(interp, args);\n    return rc;\n}\n\nstatic Jsi_RC jsi_PushVar(jsi_Pstate *ps, jsi_OpCode *ip, jsi_ScopeChain *scope, Jsi_Value *currentScope, int context_id) {\n    Jsi_Interp *interp = ps->interp;\n    jsi_FastVar *fvar = (typeof(fvar))ip->data;\n    SIGASSERT(fvar,FASTVAR);\n    Jsi_Value **dvPtr = &_jsi_STACKIDX(interp->framePtr->Sp), *dv = *dvPtr, *v = NULL;\n    if (fvar->context_id == context_id && fvar->ps == ps) {\n        v = fvar->lval;\n    } else {\n        char *varname = fvar->varname;\n        v = Jsi_ValueObjLookup(interp, currentScope, varname, 1);\n        if (v) {\n            fvar->local = 1;\n            if (v->vt == JSI_VT_UNDEF) {\n                v->d.lookupFail = varname;\n                v->f.bits.lookupfailed = 1;\n            }\n        } else {\n            v = jsi_ScopeChainObjLookupUni(scope, varname);\n            if (v) \n                fvar->local = 1;\n            else {\n                /* add to global scope.  TODO: do not define if a right_val??? */\n                Jsi_Value *global_scope = scope->chains_cnt > 0 ? scope->chains[0]:currentScope;\n                Jsi_Value key = VALINIT, *kPtr = &key; // Note: a string key so no reset needed.\n                Jsi_ValueMakeStringKey(interp, &kPtr, varname);\n                v = jsi_ValueObjKeyAssign(interp, global_scope, &key, NULL, JSI_OM_DONTENUM);\n                if (v->vt == JSI_VT_UNDEF) {\n                    v->d.lookupFail = varname;\n                    v->f.bits.lookupfailed = 1;\n                }\n                jsi_ValueDebugLabel(v, \"var\", varname);\n                bool isNew;\n                Jsi_HashEntry *hPtr = Jsi_HashEntryNew(interp->varTbl, varname, &isNew);\n                if (hPtr && isNew)\n                    Jsi_HashValueSet(hPtr, 0);\n            }\n        }\n        \n        Jsi_IncrRefCount(interp, v);\n\n    }\n    if (dv != v && (dv->vt != JSI_VT_VARIABLE || dv->d.lval != v)) {\n        Jsi_ValueReset(interp, dvPtr);\n        dv->vt = JSI_VT_VARIABLE;\n        SIGASSERT(v, VALUE);\n        dv->d.lval = v;\n        dv->f.bits.local = (fvar->local);\n    }\n    SIGASSERT(v, VALUE);\n    jsiPush(interp,1);\n    return JSI_OK;\n}\n\nstatic void jsi_PushFunc(jsi_Pstate *ps, jsi_OpCode *ip, jsi_ScopeChain *scope, Jsi_Value *currentScope) {\n    /* TODO: now that we're caching ps, may need to reference function ps for context_id??? */\n    Jsi_Interp *interp = ps->interp;\n    Jsi_FuncObj *fo = jsi_FuncObjNew(interp, (Jsi_Func *)ip->data);\n    fo->scope = jsi_ScopeChainDupNext(interp, scope, currentScope);\n    Jsi_Obj *obj = Jsi_ObjNewType(interp, JSI_OT_FUNCTION);\n    obj->d.fobj = fo;\n    \n    Jsi_Value *v = _jsi_STACKIDX(interp->framePtr->Sp), *fun_prototype = jsi_ObjValueNew(interp);\n    fun_prototype->d.obj->__proto__ = interp->Object_prototype;                \n    Jsi_ValueMakeObject(interp, &v, obj);\n    Jsi_ValueInsert(interp, v, \"prototype\", fun_prototype, JSI_OM_DONTDEL|JSI_OM_DONTENUM);\n    /* TODO: make own prototype and prototype.constructor */\n    \n    bool isNew;\n    Jsi_HashEntry *hPtr;  Jsi_Value *vv;\n    if (interp->framePtr->Sp == 1 && (vv=_jsi_STACKIDX(0))->vt == JSI_VT_VARIABLE) {\n        const char *varname = NULL;\n        vv = vv->d.lval;\n        if (vv && vv->f.bits.lookupfailed && vv->d.lookupFail) {\n            varname = vv->d.lookupFail;\n            vv->f.bits.lookupfailed = 0;\n        }\n        if (varname) {\n            if (!fo->func->name)\n                fo->func->name = varname;\n            hPtr = Jsi_HashEntryNew(interp->varTbl, varname, &isNew);\n            if (hPtr)\n                Jsi_HashValueSet(hPtr, obj);\n        }\n    }\n    hPtr = Jsi_HashEntryNew(interp->funcObjTbl, fo, &isNew);\n    if (hPtr && isNew) {\n        Jsi_ObjIncrRefCount(interp, obj);\n        Jsi_HashValueSet(hPtr, obj);\n    }\n    jsiPush(interp,1);\n}\n\nstatic Jsi_RC jsi_evalSubscript(Jsi_Interp *interp, Jsi_Value *src, Jsi_Value *idx, jsi_OpCode *ip,  jsi_OpCode *end,\n    Jsi_Value *currentScope)\n{\n    Jsi_RC rc = JSI_OK;\n    jsiVarDeref(interp,2);\n    int isnull;\n    if ((isnull=Jsi_ValueIsNull(interp, src)) || Jsi_ValueIsUndef(interp, src)) {\n        Jsi_LogError(\"invalid subscript of %s\", (isnull?\"null\":\"undefined\"));\n        jsiPop(interp, 1);\n        return JSI_ERROR;\n    }\n    Jsi_String *str = jsi_ValueString(src);\n    if (str && Jsi_ValueIsNumber(interp, idx)) {\n        int bLen, cLen;\n        char bbuf[10], *cp = Jsi_ValueString(interp, src, &bLen);\n        int n = (int)idx->d.num;\n        cLen = bLen;\n#if JSI__UTF8\n        if (str->flags&JSI_IS_UTF || !(str->flags&JSI_UTF_CHECKED)) {\n            cLen = Jsi_NumUtfChars(cp, bLen);\n            str->flags |= JSI_UTF_CHECKED;\n            if (cLen != bLen)\n                str->flags |= JSI_IS_UTF;\n        }\n#endif\n        if (n<0 || n>=cLen) {\n            Jsi_ValueMakeUndef(interp, &src);\n        } else {\n            if (cLen != bLen)\n                Jsi_UtfGetIndex(cp, n, bbuf);\n            else {\n                bbuf[0] = cp[n];\n                bbuf[1] = 0;\n            }\n            Jsi_ValueMakeStringDup(interp, &src, bbuf);\n        }\n        jsiPop(interp, 1);\n        return rc;\n    }\n    Jsi_ValueToObject(interp, src);\n    if (interp->hasCallee && (src->d.obj == currentScope->d.obj || (interp->framePtr->arguments && src->d.obj == interp->framePtr->arguments->d.obj))) {\n        if (idx->vt == JSI_VT_STRING && Jsi_Strcmp(idx->d.s.str, \"callee\") == 0) {\n            jsiClearStack(interp,1);\n            Jsi_ValueMakeStringKey(interp, &idx, \"\\1callee\\1\");\n        }\n    }\n    int bsc = Jsi_ValueIsObjType(interp, src, JSI_OT_NUMBER); // Previous bad subscript.\n    if (bsc == 0 && interp->lastSubscriptFail && interp->lastSubscriptFail->vt != JSI_VT_UNDEF)\n        Jsi_ValueReset(interp, &interp->lastSubscriptFail);\n\n    if (src->vt != JSI_VT_UNDEF) {\n        int right_val = (uintptr_t)ip->data;\n        Jsi_Value res = VALINIT, \n            *resPtr = &res,\n            *vp = jsi_ValueSubscript(interp, src, idx, &resPtr);\n        if (!vp && bsc == 0) {\n            /* eg. so we can list available commands for  \"db.xx()\" */\n            if (idx->vt == JSI_VT_STRING)\n                interp->lastSubscriptFailStr = idx->d.s.str;\n            Jsi_ValueDup2(interp, &interp->lastSubscriptFail, src);\n        }\n        if (vp)\n            Jsi_IncrRefCount(interp, vp);\n        jsiClearStack(interp,2);\n        if (!vp)\n            Jsi_ValueMakeUndef(interp, &src);\n        else {\n            //printf(\"IDX(%p): %s\\n\", idx, Jsi_ValueString(interp, idx, NULL));\n            if (right_val || vp->f.bits.readonly) {\n                if (vp == resPtr && (res.vt == JSI_VT_OBJECT || res.vt == JSI_VT_STRING))  // TODO:*** Undo using ValueCopy. ***\n                    Jsi_ValueMove(interp, src, vp);\n                else\n                    Jsi_ValueCopy(interp, src, vp);\n            } else {\n                assert(vp != resPtr);\n                res.vt = JSI_VT_VARIABLE;\n                res.d.lval = vp;\n                Jsi_ValueCopy(interp, src, resPtr);\n            }\n            Jsi_DecrRefCount(interp, vp);\n        }\n    }\n    jsiPop(interp, 1);\n    return rc;\n}\n\nvoid jsi_DebuggerStmt(void) {\n    // Called for \"debugger\" statement.\n}\n\nstatic Jsi_RC jsi_ValueAssignCheck(Jsi_Interp *interp, Jsi_Value *val, int lop) {\n    if (lop == OP_FCALL || lop == OP_NEWFCALL)\n        return JSI_OK;\n    if (val->f.bits.lookupfailed && val->d.lookupFail)\n        return Jsi_LogType(\"assign from undef var: %s\", val->d.lookupFail);\n    return JSI_OK;\n}\n\nJsi_RC jsi_evalcode_sub(jsi_Pstate *ps, Jsi_OpCodes *opcodes, \n     jsi_ScopeChain *scope, Jsi_Value *currentScope,\n     Jsi_Value *_this, Jsi_Value *vret)\n{\n    Jsi_Interp* interp = ps->interp;\n    jsi_OpCode *ip = &opcodes->codes[0];\n    Jsi_RC rc = JSI_OK;\n    int curLine = 0;\n    int context_id = ps->_context_id++, lop = -1;\n    jsi_OpCode *end = &opcodes->codes[opcodes->code_len];\n    jsi_TryList  *trylist = NULL;\n    bool strict = interp->strict;\n    const char *curFile = NULL;\n    \n    if (currentScope->vt != JSI_VT_OBJECT) {\n        Jsi_LogBug(\"Eval: current scope is not a object\");\n        return JSI_ERROR;\n    }\n    if (interp->maxDepth>0 && interp->level > interp->maxDepth)\n        rc = Jsi_LogError(\"Exceeded call depth: %d\", interp->level);\n    \n    while(ip < end && rc == JSI_OK) {\n        int plop = ip->op;\n\n        if (ip->logflag) { // Mask out LogDebug, etc if not enabled.\n            interp->curIp = ip;\n            switch (ip->logflag) {\n                case jsi_Oplf_assert:\n                    if (!interp->asserts) {\n                        ip++;\n                        if (ip->logflag != jsi_Oplf_assert && (ip->op == OP_POP || ip->op == OP_RET))\n                            ip++;\n                        continue;\n                    }\n                    break;\n                case jsi_Oplf_debug:\n                    if (!interp->logOpts.Debug && !(interp->framePtr->logflag &(1<<jsi_Oplf_debug))) {\n                        ip++;\n                        if (ip->logflag != jsi_Oplf_debug && (ip->op == OP_POP || ip->op == OP_RET))\n                            ip++;\n                        continue;\n                    }\n                    break;\n                case jsi_Oplf_test:\n                    if (!interp->logOpts.Test && !(interp->framePtr->logflag &(1<<jsi_Oplf_test))) {\n                        ip++;\n                        if (ip->logflag != jsi_Oplf_test && (ip->op == OP_POP || ip->op == OP_RET))\n                            ip++;\n                        continue;\n                    }\n                    break;\n                case jsi_Oplf_trace:\n                    if (!interp->logOpts.Trace && !(interp->framePtr->logflag &(1<<jsi_Oplf_trace))) {\n                        ip++;\n                        if (ip->logflag != jsi_Oplf_trace && (ip->op == OP_POP || ip->op == OP_RET))\n                            ip++;\n                        continue;\n                    }\n                    break;\n                default:\n                    break;\n            }\n        }\n        if (interp->interrupted) {\n            if (!interp->framePtr->tryDepth) {\n                Jsi_LogError(\"program interrupted: function=%s\", interp->framePtr->funcName);\n                interp->interrupted = 0;\n            } else {\n                interp->interrupted++;\n            }\n            rc = JSI_ERROR;\n            break;\n        }\n        if (interp->exited) {\n            rc = JSI_ERROR;\n            break;\n        }\n        interp->opCnt++;\n        if (interp->maxOpCnt && interp->opCnt > interp->maxOpCnt) {\n            puts(\"EXEC CAP EXCEED\");\n            interp->maxOpCnt += 1000;\n            rc = Jsi_LogError(\"Exceeded execution cap: %d\", interp->opCnt);\n            interp->exited = 1;\n            interp->exitCode = 99;\n            break;\n        }\n        if (interp->traceOp) {\n            jsiDumpInstr(interp, ps, _this, trylist, ip, opcodes);\n        }\n        if (interp->parent && interp->busyCallback && (interp->opCnt%(interp->busyInterval<=0?100000:interp->busyInterval))==0) {\n            // Handle parent interp events.\n            if (jsi_FuncIsNoop(interp, interp->busyCallback))\n                Jsi_EventProcess(interp->parent, -1);\n            else {\n                Jsi_DString nStr;\n                Jsi_DSInit(&nStr);\n                Jsi_DSPrintf(&nStr, \"[\\\"#Interp_%d\\\", %d]\", interp->objId, interp->opCnt);//TODO: use actual time interval rather than opCnt.\n                if (Jsi_FunctionInvokeJSON(interp->parent, interp->busyCallback, Jsi_DSValue(&nStr), NULL) != JSI_OK)\n                    rc = JSI_ERROR;\n                Jsi_DSFree(&nStr);\n            }\n        }\n        ip->hit=1;\n#ifndef USE_STATIC_STACK\n        if ((interp->maxStack-interp->framePtr->Sp)<STACK_MIN_PAD)\n            jsiSetupStack(interp);\n#endif\n        jsiPush(interp,0);\n        interp->curIp = ip;\n        // Carry forward line/file info from previous OPs.\n        if (!ip->Line)\n            ip->Line = curLine;\n        else\n            curLine = ip->Line;\n        if (!ip->fname)\n            ip->fname = curFile;\n        else\n            curFile = ip->fname;\n        if (interp->debugOpts.hook) {\n            interp->framePtr->fileName = curFile;\n            interp->framePtr->line = curLine;\n            if ((rc = (*interp->debugOpts.hook)(interp, curFile, curLine, interp->framePtr->level, interp->curFunction, jsi_opcode_string(ip->op), ip, NULL)) != JSI_OK)\n                break;\n        }\n\n        switch(ip->op) {\n            case OP_NOP:\n            case OP_LASTOP:\n                break;\n            case OP_PUSHUND:\n                Jsi_ValueMakeUndef(interp, &_jsi_STACKIDX(interp->framePtr->Sp));\n                jsiPush(interp,1);\n                break;\n            case OP_PUSHNULL:\n                Jsi_ValueMakeNull(interp, &_jsi_STACKIDX(interp->framePtr->Sp));\n                jsiPush(interp,1);\n                break;\n            case OP_PUSHBOO:\n                Jsi_ValueMakeBool(interp, &_jsi_STACKIDX(interp->framePtr->Sp), (uintptr_t)ip->data);\n                jsiPush(interp,1);\n                break;\n            case OP_PUSHNUM:\n                Jsi_ValueMakeNumber(interp, &_jsi_STACKIDX(interp->framePtr->Sp), (*((Jsi_Number *)ip->data)));\n                jsiPush(interp,1);\n                break;\n            case OP_PUSHSTR: {\n                Jsi_Value **v = &_jsi_STACKIDX(interp->framePtr->Sp);\n                Jsi_ValueMakeStringKey(interp, v, (char*)ip->data);\n                interp->lastPushStr = Jsi_ValueString(interp, *v, NULL);\n                jsiPush(interp,1);\n                break;\n            }\n            case OP_PUSHVSTR: {\n                Jsi_String *s = (Jsi_String *)ip->data;\n                Jsi_Value **v = &_jsi_STACKIDX(interp->framePtr->Sp);\n                if (s->flags&1)\n                    jsi_ValueMakeBlobDup(interp,v, (uchar*)s->str, s->len);\n                else {\n                    Jsi_ValueMakeStringKey(interp, v, s->str);\n                    interp->lastPushStr = s->str;\n                }\n                jsiPush(interp,1);\n                break;\n            }\n            case OP_PUSHVAR: {\n                rc = jsi_PushVar(ps, ip, scope, currentScope, context_id);      \n                break;\n            }\n            case OP_PUSHFUN: {\n                jsi_PushFunc(ps, ip, scope, currentScope);\n                break;\n            }\n            case OP_NEWFCALL:\n                if (interp->maxUserObjs && interp->userObjCnt > interp->maxUserObjs) {\n                    rc = Jsi_LogError(\"Max 'new' count exceeded\");\n                    break;\n                }\n            case OP_FCALL: {\n                /* TODO: need reliable way to capture func string name to handle unknown functions.*/\n                int discard = ((ip+1)<end && ip[1].op == OP_POP);\n                switch (jsiEvalFunction(ps, ip, discard)) {        /* throw an execption */\n                    case JSI_OK: break;\n                    case JSI_BREAK:\n                        if (interp->framePtr->tryDepth<=0)\n                            interp->isHelp = 1;\n                        JSI_DO_THROW(\"help\");\n                        break;\n                    default:  \n                        JSI_DO_THROW(\"fcall\");\n                }\n                strict = interp->strict;\n                /* TODO: new Function return a function without scopechain, add here */\n                break;\n            }\n            case OP_SUBSCRIPT: {\n                rc = jsi_evalSubscript(interp, _jsi_TOQ, _jsi_TOP, ip, end, currentScope);\n                break;\n            }\n            case OP_ASSIGN: {\n                Jsi_Value *sval = _jsi_TOP, *dval = _jsi_TOQ;\n                bool globThis = (sval->vt == JSI_VT_OBJECT && sval->d.obj == interp->csc->d.obj);\n                if ((uintptr_t)ip->data == 1) {\n                    jsiVarDeref(interp,1);\n                    rc = jsi_ValueAssign(interp, dval, sval, lop);                    \n                    if (strict && sval->vt == JSI_VT_UNDEF)\n                        rc = jsi_ValueAssignCheck(interp, sval, lop);\n                    jsiPop(interp,1);\n                } else {\n                    jsiVarDeref(interp, 3);\n                    Jsi_Value *v3 = _jsi_STACKIDX(interp->framePtr->Sp-3);\n                    if (v3->vt == JSI_VT_OBJECT) {\n                        if (strict && sval->vt == JSI_VT_UNDEF)\n                            rc = jsi_ValueAssignCheck(interp, sval, lop);\n                        jsi_ValueObjKeyAssign(interp, v3, dval, sval, 0);\n                        jsi_ValueDebugLabel(sval, \"assign\", NULL);\n                    } else if (strict)\n                        rc = Jsi_LogError(\"assign to a non-exist object\");\n                    jsiClearStack(interp,3);\n                    Jsi_ValueCopy(interp,v3, sval);\n                    dval = v3;\n                    jsiPop(interp, 2);\n                }\n                if (interp->framePtr->level<=1 && globThis && rc == JSI_OK && dval && dval->vt == JSI_VT_VARIABLE) {\n                    dval = dval->d.lval;\n                    //printf(\"GLOBAL THIS: %p\\n\", dval);\n                    Jsi_HashSet(interp->genValueTbl, dval, dval);\n                }\n                break;\n            }\n            case OP_PUSHREG: {\n                Jsi_Obj *obj = Jsi_ObjNewType(interp, JSI_OT_REGEXP);\n                obj->d.robj = (Jsi_Regex *)ip->data;\n                Jsi_ValueMakeObject(interp, &_jsi_STACKIDX(interp->framePtr->Sp), obj);\n                jsiPush(interp,1);\n                break;\n            }\n            case OP_PUSHARG:\n                //Jsi_ValueCopy(interp,_jsi_STACKIDX(interp->framePtr->Sp), currentScope);\n                \n                if (!interp->framePtr->arguments) {\n                    interp->framePtr->arguments = Jsi_ValueNewObj(interp,\n                        Jsi_ObjNewArray(interp, currentScope->d.obj->arr, currentScope->d.obj->arrCnt, 0));\n                    Jsi_IncrRefCount(interp, interp->framePtr->arguments);\n                    if (interp->hasCallee) {\n                        Jsi_Value *callee = Jsi_ValueObjLookup(interp, currentScope, \"\\1callee\\1\", 0);\n                        if (callee)\n                            Jsi_ValueInsert(interp, interp->framePtr->arguments, \"\\1callee\\1\", callee, JSI_OM_DONTENUM);\n                    }\n                    // interp->framePtr->arguments->d.obj->__proto__ = interp->Object_prototype; // ecma\n                }\n                Jsi_ValueCopy(interp,_jsi_STACKIDX(interp->framePtr->Sp), interp->framePtr->arguments);\n                jsiPush(interp,1);\n                break;\n            case OP_PUSHTHS: { //TODO: Value copy can cause memory leak!\n                Jsi_Value *tval = _jsi_STACKIDX(interp->framePtr->Sp);\n                Jsi_ValueCopy(interp, tval, _this);\n                /*if (interp->csc == _this)\n                    Jsi_ValueDup2(interp, &tval, _this);\n                else\n                    Jsi_ValueCopy(interp, tval, _this);*/\n                jsiPush(interp,1);\n                break;\n            }\n            case OP_PUSHTOP:\n                Jsi_ValueCopy(interp,_jsi_STACKIDX(interp->framePtr->Sp), _jsi_TOP);\n                jsiPush(interp,1);\n                break;\n            case OP_UNREF:\n                jsiVarDeref(interp,1);\n                break;\n            case OP_PUSHTOP2: {\n                Jsi_Value *vp1 = _jsi_STACKIDX(interp->framePtr->Sp);\n                Jsi_Value *vp2 = _jsi_STACKIDX(interp->framePtr->Sp+1);\n                if (!vp1 || !vp2)\n                    rc = Jsi_LogError(\"Invalid lookup/push\");\n                else {\n                    Jsi_ValueCopy(interp, vp1, _jsi_TOQ);\n                    Jsi_ValueCopy(interp, vp2, _jsi_TOP);\n                    jsiPush(interp, 2);\n                }\n                break;\n            }\n            case OP_CHTHIS: {\n                if (ip->data) {\n                    int t = interp->framePtr->Sp - 2;\n                    Assert(t>=0);\n                    Jsi_Value *v = _jsi_THISIDX(t);\n                    jsiClearThis(interp, t);\n                    Jsi_ValueCopy(interp, v, _jsi_TOQ);\n                    if (v->vt == JSI_VT_VARIABLE) {\n                        Jsi_ValueCopy(interp, v, v->d.lval);\n                    }\n                    Jsi_ValueToObject(interp, v);\n                }\n                break;\n            }\n            case OP_LOCAL: {\n                Jsi_Value key = VALINIT, *kPtr = &key; // Note we use a string key so no reset needed.\n                Jsi_ValueMakeStringKey(interp, &kPtr, (char*)ip->data);\n                jsi_ValueObjKeyAssign(interp, currentScope, kPtr, NULL, JSI_OM_DONTENUM);\n                context_id = ps->_context_id++;\n                break;\n            }\n            case OP_POP: {\n                Jsi_Value *tval = _jsi_TOP;\n                if ((interp->evalFlags&JSI_EVAL_RETURN) && (ip+1) >= end && \n                (Jsi_ValueIsObjType(interp, tval, JSI_OT_ITER)==0 &&\n                Jsi_ValueIsObjType(interp, tval, JSI_OT_FUNCTION)==0)) {\n                    /* Interactive and last instruction is a pop: save result. */\n                    Jsi_ValueMove(interp, vret, tval); /*TODO***: correct ***/\n                    tval->vt = JSI_VT_UNDEF;\n                }\n                jsiPop(interp, (uintptr_t)ip->data);\n                break;\n            }\n            case OP_NEG:\n                jsiVarDeref(interp,1);\n                Jsi_ValueToNumber(interp, _jsi_TOP);\n                rc = _jsi_StrictChk(_jsi_TOP);\n                _jsi_TOP->d.num = -(_jsi_TOP->d.num);\n                break;\n            case OP_POS:\n                jsiVarDeref(interp,1);\n                Jsi_ValueToNumber(interp, _jsi_TOP);\n                rc = _jsi_StrictChk(_jsi_TOP);\n                break;\n            case OP_NOT: {\n                int val = 0;\n                jsiVarDeref(interp,1);\n                \n                val = Jsi_ValueIsTrue(interp, _jsi_TOP);\n                \n                jsiClearStack(interp,1);\n                Jsi_ValueMakeBool(interp, &_jsi_TOP, !val);\n                break;\n            }\n            case OP_BNOT: {\n                jsiVarDeref(interp,1);\n                jsi_ValueToOInt32(interp, _jsi_TOP);\n                rc = _jsi_StrictChk(_jsi_TOP);\n                _jsi_TOP->d.num = (Jsi_Number)(~((int)_jsi_TOP->d.num));\n                break;\n            }\n            case OP_ADD: {\n                jsiVarDeref(interp,2);\n                Jsi_Value *v, *v1 = _jsi_TOP, *v2 = _jsi_TOQ;\n                int l1, l2;\n                if (strict)\n                    if (Jsi_ValueIsUndef(interp, v1) || Jsi_ValueIsUndef(interp, v2)) {\n                        rc = Jsi_LogError(\"operand value to + is undefined\");\n                        break;\n                    }\n                char *s1 = Jsi_ValueString(interp, v1, &l1);\n                char *s2 = Jsi_ValueString(interp, v2, &l2);\n                if (s1 || s2) {\n                    char *str;\n                    if (!(s1 && s2)) {\n                        v = (s1 ? v2 : v1);\n                        jsi_ValueToPrimitive(interp, &v);\n                        Jsi_ValueToString(interp, v, NULL);\n                        str = Jsi_ValueString(interp, v, (s1?&l2:&l1));\n                        if (s1) s2 = str; else s1 = str;\n                    }\n                    Assert(l1>=0 && l1<=JSI_MAX_ALLOC_BUF);\n                    Assert(l2>=0 && l2<=JSI_MAX_ALLOC_BUF);\n                    str = (char*)Jsi_Malloc(l1+l2+1);\n                    memcpy(str, s2, l2);\n                    memcpy(str+l2, s1, l1);\n                    str[l1+l2] = 0;\n                    jsiClearStack(interp,2);\n                    Jsi_ValueMakeBlob(interp, &v2, (uchar*)str, l1+l2);\n                } else {\n                    Jsi_ValueToNumber(interp, v1);\n                    Jsi_ValueToNumber(interp, v2);\n                    rc = _jsi_StrictChk2(v1, v2);\n                    Jsi_Number n = v1->d.num + v2->d.num;\n                    jsiClearStack(interp,2);\n                    Jsi_ValueMakeNumber(interp, &v2, n);\n                }\n                jsiPop(interp,1);\n                break;\n            }\n            case OP_IN: {\n                Jsi_Value *v, *vl;\n                const char *cp = NULL;\n                Jsi_Number nval;\n                jsiVarDeref(interp,2);\n                vl = _jsi_TOQ;\n                v = _jsi_TOP;\n                if (Jsi_ValueIsString(interp,vl))\n                    cp = Jsi_ValueGetStringLen(interp, vl, NULL);\n                else if (Jsi_ValueIsNumber(interp,vl))\n                    Jsi_ValueGetNumber(interp, vl, &nval);\n                else {\n                    if (strict)\n                        Jsi_LogWarn(\"expected string or number before IN\");\n                    Jsi_ValueMakeBool(interp, &_jsi_TOQ, 0);\n                    jsiPop(interp,1);\n                    break;\n                }\n                \n                if (v->vt == JSI_VT_VARIABLE) {\n                    v = v->d.lval;\n                    SIGASSERT(v, VALUE);\n                }\n                if (v->vt != JSI_VT_OBJECT || v->d.obj->ot != JSI_OT_OBJECT) {\n                    if (strict)\n                        Jsi_LogWarn(\"expected object after IN\");\n                    Jsi_ValueMakeBool(interp, &_jsi_TOQ, 0);\n                    jsiPop(interp,1);\n                    break;\n                }\n                int bval = 0;\n                char nbuf[JSI_MAX_NUMBER_STRING];\n                Jsi_Value *vv;\n                Jsi_Obj *obj = v->d.obj;\n                if (!cp) {\n                    snprintf(nbuf, sizeof(nbuf), \"%d\", (int)nval);\n                    cp = nbuf;\n                }\n                if (obj->arr) {\n                    vv = jsi_ObjArrayLookup(interp, obj, (char*)cp);\n                } else {\n                    vv = Jsi_TreeObjGetValue(obj, (char*)cp, 1);\n                }\n                bval = (vv != 0);\n                Jsi_ValueMakeBool(interp, &_jsi_TOQ, bval);\n                jsiPop(interp,1);\n                break;\n            }\n            case OP_SUB: \n                common_math_opr(-); break;\n            case OP_MUL:\n                common_math_opr(*); break;\n            case OP_DIV:\n                common_math_opr(/); break;\n            case OP_MOD: {\n                jsiVarDeref(interp,2);\n                if (!Jsi_ValueIsType(interp,_jsi_TOP, JSI_VT_NUMBER))\n                    Jsi_ValueToNumber(interp, _jsi_TOP);\n                if (!Jsi_ValueIsType(interp,_jsi_TOQ, JSI_VT_NUMBER))\n                    Jsi_ValueToNumber(interp, _jsi_TOQ);\n                rc = _jsi_StrictChk2(_jsi_TOP,_jsi_TOQ);\n                if (rc == JSI_OK)\n                    _jsi_TOQ->d.num = fmod(_jsi_TOQ->d.num, _jsi_TOP->d.num);\n                jsiPop(interp,1);\n                break;\n            }\n            case OP_LESS:\n                jsiVarDeref(interp,2);\n                rc = jsi_logic_less(interp,2,1);\n                jsiPop(interp,1);\n                break;\n            case OP_GREATER:\n                jsiVarDeref(interp,2);\n                rc = jsi_logic_less(interp,1,2);\n                jsiPop(interp,1);\n                break;\n            case OP_LESSEQU:\n                jsiVarDeref(interp,2);\n                rc = jsi_logic_less(interp,1,2);\n                if (rc == JSI_OK)\n                    _jsi_TOQ->d.val = !_jsi_TOQ->d.val;\n                jsiPop(interp,1);\n                break;\n            case OP_GREATEREQU:\n                jsiVarDeref(interp,2);\n                rc = jsi_logic_less(interp,2,1);\n                if (rc == JSI_OK)\n                    _jsi_TOQ->d.val = !_jsi_TOQ->d.val;\n                jsiPop(interp,1);\n                break;\n            case OP_EQUAL:\n            case OP_NOTEQUAL: {\n                jsiVarDeref(interp,2);\n                int r = Jsi_ValueCmp(interp, _jsi_TOP, _jsi_TOQ, 0);\n                r = (ip->op == OP_EQUAL ? !r : r);\n                jsiClearStack(interp,2);\n                Jsi_ValueMakeBool(interp, &_jsi_TOQ, r);\n                jsiPop(interp,1);\n                break;\n            }\n            case OP_STRICTEQU:\n            case OP_STRICTNEQ: {\n                int r = 0;\n                jsiVarDeref(interp,2);\n                rc = _jsi_StrictUChk3(_jsi_TOQ, _jsi_TOP);\n                r = !Jsi_ValueIsEqual(interp, _jsi_TOP, _jsi_TOQ);\n                r = (ip->op == OP_STRICTEQU ? !r : r);\n                jsiClearStack(interp,2);\n                Jsi_ValueMakeBool(interp, &_jsi_TOQ, r);\n                jsiPop(interp,1);\n                break;\n            }\n            case OP_BAND: \n                common_bitwise_opr(&); break;\n            case OP_BOR:\n                common_bitwise_opr(|); break;\n            case OP_BXOR:\n                common_bitwise_opr(^); break;\n            case OP_SHF: {\n                jsiVarDeref(interp,2);\n                jsi_ValueToOInt32(interp, _jsi_TOQ);\n                jsi_ValueToOInt32(interp, _jsi_TOP);\n                int t1 = (int)_jsi_TOQ->d.num;\n                int t2 = ((unsigned int)_jsi_TOP->d.num) & 0x1f;\n                if (ip->data) {                 /* shift right */\n                    if ((uintptr_t)ip->data == 2) {   /* unsigned shift */\n                        unsigned int t3 = (unsigned int)t1;\n                        t3 >>= t2;\n                        Jsi_ValueMakeNumber(interp, &_jsi_TOQ, t3);\n                    } else {\n                        t1 >>= t2;\n                        Jsi_ValueMakeNumber(interp, &_jsi_TOQ, t1);\n                    }\n                } else {\n                    t1 <<= t2;\n                    Jsi_ValueMakeNumber(interp, &_jsi_TOQ, t1);\n                }\n                jsiPop(interp,1);\n                break;\n            }\n            case OP_KEY: {\n                jsiVarDeref(interp,1);\n                if (ip->isof && !Jsi_ValueIsArray(interp, _jsi_TOP)) {\n                    rc = Jsi_LogError(\"operand not an array\");\n                    break;\n                }\n                if (_jsi_TOP->vt != JSI_VT_UNDEF && _jsi_TOP->vt != JSI_VT_NULL)\n                    Jsi_ValueToObject(interp, _jsi_TOP);\n                Jsi_Value *spret = Jsi_ValueNew1(interp);\n                jsi_ValueObjGetKeys(interp, _jsi_TOP, spret, ip->isof);\n                Jsi_ValueReplace(interp, _jsi_STACK+interp->framePtr->Sp, spret);  \n                Jsi_DecrRefCount(interp, spret);  \n                jsiPush(interp,1);\n                break;\n            }\n            case OP_NEXT: {\n                Jsi_Value *toq = _jsi_TOQ, *top = _jsi_TOP;\n                if (toq->vt != JSI_VT_OBJECT || toq->d.obj->ot != JSI_OT_ITER) Jsi_LogBug(\"next: toq not a iter\\n\");\n                if (top->vt != JSI_VT_VARIABLE) {\n                    rc = Jsi_LogError (\"invalid for/in left hand-side\");\n                    break;\n                }\n                if (strict && top->f.bits.local==0) {\n                    const char *varname = \"\";\n                    Jsi_Value *v = top->d.lval;\n                    if (v->f.bits.lookupfailed)\n                        varname = v->d.lookupFail;\n\n                    rc = Jsi_LogError(\"function created global: \\\"%s\\\"\", varname);\n                    break;\n                }\n                \n                Jsi_IterObj *io = toq->d.obj->d.iobj;\n                if (io->iterCmd) {\n                    io->iterCmd(io, top, _jsi_STACKIDX(interp->framePtr->Sp-3), io->iter++);\n                } else {\n                    while (io->iter < io->count) {\n                        if (!io->isArrayList) {\n                            if (Jsi_ValueKeyPresent(interp, _jsi_STACKIDX(interp->framePtr->Sp-3), io->keys[io->iter],1)) \n                                break;\n                        } else {\n                            while (io->cur < io->obj->arrCnt) {\n                                if (io->obj->arr[io->cur]) break;\n                                io->cur++;\n                            }\n                            if (io->cur >= io->obj->arrCnt) {\n                                /* TODO: Is this really a bug??? */\n                                /* Jsi_LogBug(\"NOT FOUND LIST ARRAY\");*/\n                                io->iter = io->count;\n                                break;\n                            } else if (io->obj->arr[io->cur]) {\n                                io->cur++;\n                                break;\n                            }\n                        }\n                        io->iter++;\n                    }\n                    if (io->iter >= io->count) {\n                        jsiClearStack(interp,1);\n                        Jsi_ValueMakeNumber(interp, &_jsi_TOP, 0);\n                    } else {\n                        Jsi_Value **vPtr = &_jsi_TOP->d.lval, *v = *vPtr;\n                        SIGASSERT(v, VALUE);\n                        Jsi_ValueReset(interp, vPtr);\n                        if (io->isArrayList) {\n                            if (!io->isof)\n                                Jsi_ValueMakeNumber(interp, &v, io->cur-1);\n                            else if (!io->obj->arr[io->cur-1])\n                                Jsi_ValueMakeNull(interp, &v);\n                            else\n                                Jsi_ValueCopy(interp, v, io->obj->arr[io->cur-1]);\n                        } else\n                            Jsi_ValueMakeStringKey(interp, &v, io->keys[io->iter]);\n                        io->iter++;\n                        \n                        jsiClearStack(interp,1);\n                        Jsi_ValueMakeNumber(interp, &_jsi_TOP, 1);\n                    }\n                    break;\n                }\n            }\n            case OP_INC:\n            case OP_DEC: {\n                int inc = ip->op == OP_INC ? 1 : -1;\n                \n                if (_jsi_TOP->vt != JSI_VT_VARIABLE) {\n                    rc = Jsi_LogError(\"operand not left value\");\n                    break;\n                }\n                Jsi_Value *v = _jsi_TOP->d.lval;\n                SIGASSERT(v, VALUE);\n                Jsi_ValueToNumber(interp, v);\n                rc = _jsi_StrictChk(v);\n                v->d.num += inc;\n                    \n                jsiVarDeref(interp,1);\n                if (ip->data) {\n                    _jsi_TOP->d.num -= inc;\n                }\n                break;\n            }\n            case OP_TYPEOF: {\n                const char *typ;\n                Jsi_Value *v = _jsi_TOP;\n                if (v->vt == JSI_VT_VARIABLE) {\n                    v = v->d.lval;\n                    SIGASSERT(v, VALUE);\n                }\n                typ = Jsi_ValueTypeStr(interp, v);\n                jsiVarDeref(interp,1);\n                Jsi_ValueMakeStringKey(interp, &_jsi_TOP, (char*)typ);\n                break;\n            }\n            case OP_INSTANCEOF: {\n\n                jsiVarDeref(interp,2);\n                int bval = Jsi_ValueInstanceOf(interp, _jsi_TOQ, _jsi_TOP);\n                jsiPop(interp,1);\n                Jsi_ValueMakeBool(interp, &_jsi_TOP, bval);\n                break;\n            }\n            case OP_JTRUE:\n            case OP_JFALSE: \n            case OP_JTRUE_NP:\n            case OP_JFALSE_NP: {\n                jsiVarDeref(interp,1);\n                int off = (uintptr_t)ip->data - 1; \n                int r = Jsi_ValueIsTrue(interp, _jsi_TOP);\n                \n                if (ip->op == OP_JTRUE || ip->op == OP_JFALSE) jsiPop(interp,1);\n                ip += ((ip->op == OP_JTRUE || ip->op == OP_JTRUE_NP) ^ r) ? 0 : off;\n                break;\n            }\n            case OP_JMPPOP: \n                jsiPop(interp, ((jsi_JmpPopInfo *)ip->data)->topop);\n            case OP_JMP: {\n                int off = (ip->op == OP_JMP ? (uintptr_t)ip->data - 1\n                            : (uintptr_t)((jsi_JmpPopInfo *)ip->data)->off - 1);\n\n                while (1) {\n                    if (trylist == NULL) break;\n                    jsi_OpCode *tojmp = ip + off;\n\n                    /* jmp out of a try block, should execute the finally block */\n                    /* while jmp out a 'with' block, restore the scope */\n\n                    if (trylist->type == jsi_TL_TRY) { \n                        if (tojmp >= trylist->d.td.tstart && tojmp < trylist->d.td.fend) break;\n                        \n                        if (ip >= trylist->d.td.tstart && ip < trylist->d.td.cend) {\n                            trylist->d.td.last_op = jsi_LOP_JMP;\n                            trylist->d.td.ld.tojmp = tojmp;\n                            \n                            ip = trylist->d.td.fstart - 1;\n                            off = 0;\n                            break;\n                        } else if (ip >= trylist->d.td.fstart && ip < trylist->d.td.fend) {\n                            pop_try(trylist);\n                        } else Jsi_LogBug(\"jmp within a try, but not in its scope?\");\n                    } else {\n                        /* with block */\n                        \n                        if (tojmp >= trylist->d.wd.wstart && tojmp < trylist->d.wd.wend) break;\n                        \n                        JSI_RESTORE_SCOPE();\n                        pop_try(trylist);\n                    }\n                }\n                \n                ip += off;\n                break;\n            }\n            case OP_EVAL: {\n                int stackargc = (uintptr_t)ip->data;\n                jsiVarDeref(interp, stackargc);\n\n                int r = 0;\n                Jsi_Value *spPtr = Jsi_ValueNew1(interp);\n                if (stackargc > 0) {\n                    if (_jsi_STACKIDX(interp->framePtr->Sp - stackargc)->vt == JSI_VT_UNDEF) {\n                        Jsi_LogError(\"undefined value to eval()\");\n                        goto undef_eval;\n                    }\n                    int plen;\n                    char *pro = Jsi_ValueString(interp, _jsi_STACKIDX(interp->framePtr->Sp - stackargc), &plen);\n                    if (pro) {\n                        pro = Jsi_StrdupLen(pro, plen);\n                        r = jsiEvalOp(interp, ps, pro, scope, currentScope, _this, &spPtr);\n                        Jsi_Free(pro);\n                    } else {\n                        Jsi_ValueCopy(interp, spPtr, _jsi_STACKIDX(interp->framePtr->Sp - stackargc));\n                    }\n                }\nundef_eval:\n                jsiPop(interp, stackargc);\n                Jsi_ValueCopy(interp, _jsi_STACK[interp->framePtr->Sp], spPtr); /*TODO: is this correct?*/\n                Jsi_DecrRefCount(interp, spPtr);\n                jsiPush(interp,1);\n\n                if (r) {\n                    JSI_DO_THROW(\"eval\");\n                }\n                break;\n            }\n            case OP_RET: {\n                if (interp->framePtr->Sp>=1 && ip->data) {\n                    jsiVarDeref(interp,1);\n                    Jsi_ValueMove(interp, vret, _jsi_TOP);\n                }\n                jsiPop(interp, (uintptr_t)ip->data);\n                interp->didReturn = 1;\n                if (trylist) {\n                    while (trylist) {\n                        if (trylist->type == jsi_TL_TRY && trylist->inCatch)\n                            JSI_RESTORE_SCOPE();\n                        pop_try(trylist);\n                    }\n                    goto done;\n                }\n                ip = end;\n                break;\n            }\n            case OP_DELETE: {\n                int count = (uintptr_t)ip->data;\n                if (count == 1) { // Non-standard.\n                    if (_jsi_TOP->vt != JSI_VT_VARIABLE)\n                        rc = Jsi_LogError(\"delete a right value\");\n                    else {\n                        Jsi_Value **vPtr = &_jsi_TOP->d.lval, *v = *vPtr;\n                        SIGASSERT(v, VALUE);\n                        if (v->f.bits.dontdel) {\n                            if (strict) rc = Jsi_LogWarn(\"delete not allowed\");\n                        } else if (v != currentScope) {\n                            Jsi_ValueReset(interp,vPtr);     /* not allow to delete arguments */\n                        }\n                        else if (strict)\n                            Jsi_LogWarn(\"Delete arguments\");\n                    }\n                    jsiPop(interp,1);\n                } else if (count == 2) {\n                    jsiVarDeref(interp,2);\n                    assert(interp->framePtr->Sp>=2);\n                    if (strict) {\n                        if (_jsi_TOQ->vt != JSI_VT_OBJECT) Jsi_LogWarn(\"delete non-object key, ignore\");\n                        if (_jsi_TOQ->d.obj == currentScope->d.obj) Jsi_LogWarn(\"Delete arguments\");\n                    }\n                    jsi_ValueObjDelete(interp, _jsi_TOQ, _jsi_TOP, 0);\n                    \n                    jsiPop(interp,2);\n                } else Jsi_LogBug(\"delete\");\n                break;\n            }\n            case OP_OBJECT: {\n                int itemcount = (uintptr_t)ip->data;\n                Assert(itemcount>=0);\n                jsiVarDeref(interp, itemcount * 2);\n                Jsi_Obj *obj = Jsi_ObjNewObj(interp, _jsi_STACK+(interp->framePtr->Sp-itemcount*2), itemcount*2);\n                jsiPop(interp, itemcount * 2 - 1);       /* one left */\n                jsiClearStack(interp,1);\n                Jsi_ValueMakeObject(interp, &_jsi_TOP, obj);\n                break;\n            }\n            case OP_ARRAY: {\n                int itemcount = (uintptr_t)ip->data;\n                Assert(itemcount>=0);\n                jsiVarDeref(interp, itemcount);\n                Jsi_Obj *obj = Jsi_ObjNewArray(interp, _jsi_STACK+(interp->framePtr->Sp-itemcount), itemcount, 1);\n                jsiPop(interp, itemcount - 1);\n                jsiClearStack(interp,1);\n                Jsi_ValueMakeObject(interp, &_jsi_TOP, obj);\n                break;\n            }\n            case OP_STRY: {\n                jsi_TryInfo *ti = (jsi_TryInfo *)ip->data;\n                jsi_TryList *n = jsi_trylist_new(jsi_TL_TRY, scope, currentScope);\n                \n                n->d.td.tstart = ip;                            /* make every thing pointed to right pos */\n                n->d.td.tend = n->d.td.tstart + ti->trylen;\n                n->d.td.cstart = n->d.td.tend + 1;\n                n->d.td.cend = n->d.td.tend + ti->catchlen;\n                n->d.td.fstart = n->d.td.cend + 1;\n                n->d.td.fend = n->d.td.cend + ti->finallen;\n                n->d.td.tsp = interp->framePtr->Sp;\n                n->inCatch=0;\n                n->inFinal=0;\n\n                jsi_push_try(interp, &trylist, n);\n                break;\n            }\n            case OP_ETRY: {             /* means nothing happen go to final */\n                if (trylist == NULL || trylist->type != jsi_TL_TRY)\n                    Jsi_LogBug(\"Unexpected ETRY opcode??\");\n\n                ip = trylist->d.td.fstart - 1;\n                break;\n            }\n            case OP_SCATCH: {\n                if (trylist == NULL || trylist->type != jsi_TL_TRY) \n                    Jsi_LogBug(\"Unexpected SCATCH opcode??\");\n\n                if (!ip->data) {\n                    JSI_DO_THROW(\"catch\");\n                } else {\n                    trylist->inCatch=1;\n                    /* new scope and make var */\n                    scope = jsi_ScopeChainDupNext(interp, scope, currentScope);\n                    currentScope = jsi_ObjValueNew(interp);\n                    interp->framePtr->ingsc = scope;  //TODO: changing frame\n                    interp->framePtr->incsc = currentScope;\n                    Jsi_IncrRefCount(interp, currentScope);\n                    Jsi_Value *excpt = Jsi_ValueNew1(interp);\n                    if (ps->last_exception && ps->last_exception->vt != JSI_VT_UNDEF) {\n                        //TODO: fix test262 crash in freeValueTbl@jsiInterp.c:565 for last_exception which is\n                        // freed in jsi_PstateFree@jsiPstate.c:251. Is this code the problem?\n                        Jsi_Value *ple = ps->last_exception;\n                        Jsi_ValueCopy(interp, excpt, ple);\n                        Jsi_ValueReset(interp, &ps->last_exception);\n                    } else if (interp->errMsgBuf[0]) {\n                        Jsi_ValueMakeStringDup(interp, &excpt, interp->errMsgBuf);\n                        interp->errMsgBuf[0] = 0;\n                    }\n                    Jsi_ValueInsert(interp, currentScope, (char*)ip->data, excpt, JSI_OM_DONTENUM);\n                    Jsi_DecrRefCount(interp, excpt);\n                    context_id = ps->_context_id++;\n                }\n                break;\n            }\n            case OP_ECATCH: {\n                if (trylist == NULL || trylist->type != jsi_TL_TRY)\n                    Jsi_LogBug(\"Unexpected ECATCH opcode??\");\n\n                trylist->inCatch=0;\n                ip = trylist->d.td.fstart - 1;\n                break;\n            }\n            case OP_SFINAL: {\n                if (trylist == NULL || trylist->type != jsi_TL_TRY)\n                    Jsi_LogBug(\"Unexpected SFINAL opcode??\");\n\n                /* restore scatch scope chain */\n                trylist->inFinal = 1;\n                JSI_RESTORE_SCOPE();\n                break;\n            }\n            case OP_EFINAL: {\n                if (trylist == NULL || trylist->type != jsi_TL_TRY)\n                    Jsi_LogBug(\"Unexpected EFINAL opcode??\");\n\n                trylist->inFinal = 0;\n                int last_op = trylist->d.td.last_op;\n                jsi_OpCode *tojmp = (last_op == jsi_LOP_JMP ? trylist->d.td.ld.tojmp : 0);\n                \n                pop_try(trylist);\n\n                if (last_op == jsi_LOP_THROW) {\n                    JSI_DO_THROW(\"finally\");\n                } else if (last_op == jsi_LOP_JMP) {\n                    while (1) {\n                        if (trylist == NULL) {\n                            ip = tojmp;\n                            break;\n                        }\n                        /* same as jmp opcode, see above */\n                        if (trylist->type == jsi_TL_TRY) {\n                            if (tojmp >= trylist->d.td.tstart && tojmp < trylist->d.td.fend) {\n                                ip = tojmp;\n                                break;\n                            }\n                            \n                            if (ip >= trylist->d.td.tstart && ip < trylist->d.td.cend) {\n                                trylist->d.td.last_op = jsi_LOP_JMP;\n                                trylist->d.td.ld.tojmp = tojmp;\n                                \n                                ip = trylist->d.td.fstart - 1;\n                                break;\n                            } else if (ip >= trylist->d.td.fstart && ip < trylist->d.td.fend) {\n                                pop_try(trylist);\n                            } else Jsi_LogBug(\"jmp within a try, but not in its scope?\");\n                        } else {        /* 'with' block */\n                            if (tojmp >= trylist->d.wd.wstart && tojmp < trylist->d.wd.wend) {\n                                ip = tojmp;\n                                break;\n                            }\n                            JSI_RESTORE_SCOPE();\n                            pop_try(trylist);\n                        }\n                    }\n                }\n                break;\n            }\n            case OP_THROW: {\n                jsiVarDeref(interp,1);\n                Jsi_ValueDup2(interp,&ps->last_exception, _jsi_TOP);\n                interp->didReturn = 1; /* TODO: could possibly hide _jsi_STACK problem */\n                JSI_DO_THROW(\"throw\");\n                break;\n            }\n            case OP_WITH: {\n                static int warnwith = 1;\n                if (strict && warnwith && interp->typeCheck.nowith) {\n                    warnwith = 0;\n                    rc = Jsi_LogError(\"use of with is illegal due to \\\"use nowith\\\"\");\n                    break;\n                }\n                jsiVarDeref(interp,1);\n                Jsi_ValueToObject(interp, _jsi_TOP);\n                \n                jsi_TryList *n = jsi_trylist_new(jsi_TL_WITH, scope, currentScope);\n                \n                n->d.wd.wstart = ip;\n                n->d.wd.wend = n->d.wd.wstart + (uintptr_t)ip->data;\n\n                jsi_push_try(interp, &trylist, n);\n                interp->framePtr->withDepth++;\n                \n                /* make expr to top of scope chain */\n                scope = jsi_ScopeChainDupNext(interp, scope, currentScope);\n                currentScope = Jsi_ValueNew1(interp);\n                interp->framePtr->ingsc = scope;\n                interp->framePtr->incsc = currentScope;\n                Jsi_ValueCopy(interp, currentScope, _jsi_TOP);\n                jsiPop(interp,1);\n                \n                context_id = ps->_context_id++;\n                break;\n            }\n            case OP_EWITH: {\n                if (trylist == NULL || trylist->type != jsi_TL_WITH)\n                    Jsi_LogBug(\"Unexpected EWITH opcode??\");\n\n                JSI_RESTORE_SCOPE();\n                \n                pop_try(trylist);\n                interp->framePtr->withDepth--;\n                break;\n            }\n            case OP_DEBUG: {\n                jsi_DebuggerStmt();\n                jsiPush(interp,1);\n                break;\n            }\n            case OP_RESERVED: {\n                jsi_ReservedInfo *ri = (jsi_ReservedInfo *)ip->data;\n                const char *cmd = ri->type == RES_CONTINUE ? \"continue\" : \"break\";\n                /* TODO: continue/break out of labeled scope: see tests/prob/break.jsi. */\n                if (ri->label) {\n                    Jsi_LogError(\"%s: label(%s) not found\", cmd, ri->label);\n                } else {\n                    Jsi_LogError(\"%s must be inside loop(or switch)\", cmd);\n                }\n                rc = JSI_ERROR;\n                break;\n            }\n#ifndef __cplusplus\n            default:\n                Jsi_LogBug(\"invalid op ceod: %d\", ip->op);\n#endif\n        }\n        lop = plop;\n        ip++;\n    }\ndone:\n    while (trylist) {\n        JSI_RESTORE_SCOPE();\n        pop_try(trylist);\n    }\n    return rc;\n}\n\n// Bottom-most eval() routine creates stack frame.\nJsi_RC jsi_evalcode(jsi_Pstate *ps, Jsi_Func *func, Jsi_OpCodes *opcodes, \n         jsi_ScopeChain *scope, Jsi_Value *fargs,\n         Jsi_Value *_this,\n         Jsi_Value **vret)\n{\n    Jsi_Interp *interp = ps->interp;\n    if (interp->exited)\n        return JSI_ERROR;\n    Jsi_RC rc;\n    jsi_Frame frame = *interp->framePtr;\n    frame.parent = interp->framePtr;\n    interp->framePtr = &frame;\n    frame.parent->child = interp->framePtr = &frame;\n    frame.ps = ps;\n    frame.ingsc = scope;\n    frame.incsc = fargs;\n    frame.inthis = _this;\n    frame.opcodes = opcodes;\n    frame.fileName = ((func && func->script)?func->script:interp->curFile);\n    frame.funcName = interp->curFunction;\n    frame.dirName = interp->curDir;\n    if (frame.fileName && frame.fileName == frame.parent->fileName)\n        frame.logflag = frame.parent->logflag;\n    else\n        frame.logflag = 0;\n    frame.level = frame.parent->level+1;\n    frame.evalFuncPtr = func;\n    frame.arguments = NULL;\n   // if (func && func->strict)\n    //    frame.strict = 1;\n    if (interp->curIp)\n        frame.parent->line = interp->curIp->Line;\n    frame.ip = interp->curIp;\n    interp->refCount++;\n    interp->level++;\n    Jsi_IncrRefCount(interp, fargs);\n    rc = jsi_evalcode_sub(ps, opcodes, scope, fargs, _this, *vret);\n    Jsi_DecrRefCount(interp, fargs);\n    if (interp->didReturn == 0 && !interp->exited && rc == JSI_OK) {\n        if ((interp->evalFlags&JSI_EVAL_RETURN)==0)\n            Jsi_ValueMakeUndef(interp, vret);\n        /*if (interp->framePtr->Sp != oldSp) //TODO: at some point after memory refs???\n            Jsi_LogBug(\"Stack not balance after execute script\");*/\n    }\n    if (frame.arguments)\n        Jsi_DecrRefCount(interp, frame.arguments);\n    interp->didReturn = 0;\n    interp->refCount--;\n    interp->level--;\n    interp->framePtr = frame.parent;\n    interp->framePtr->child = NULL;\n    interp->curIp = frame.ip;\n    if (interp->exited)\n        rc = JSI_ERROR;\n    return rc;\n}\n\nJsi_RC jsi_JsPreprocessLine(Jsi_Interp* interp, char *buf, size_t bsiz, uint ilen, int jOpts[4], int lineNo) {\n    if (buf[0]==';' && buf[1] && buf[2]) {\n        // Wrap \";XXX;\" in a puts(\"XXX ==> \", XXX)\n        if (!jOpts[0]) {\n            if (!Jsi_Strcmp(buf, \"=!EXPECTSTART!=\\n\") || !Jsi_Strcmp(buf, \"=!INPUTSTART!=\\n\") ) {\n                return JSI_OK;\n            }\n        } else {\n            if (!Jsi_Strcmp(buf, \"=!EXPECTEND!=\\n\") || !Jsi_Strcmp(buf, \"=!INPUTEND!=\\n\")) {\n                jOpts[0] = 0;\n                return JSI_OK;\n            }\n        }\n        if (buf[ilen-1]=='\\n' && buf[ilen-2]==';' && (2*ilen+12)<bsiz) {\n            if (Jsi_Strchr(buf, '`')) {\n                return Jsi_LogError(\"back-tick is illegal in unitTest on line %d: %s\", lineNo, buf);\n            }\n            char ubuf[bsiz], *ucp = ubuf;\n            buf[ilen-=2] = 0;\n            Jsi_Strcpy(ubuf, buf+1);\n            while (*ucp && isspace(*ucp)) ucp++;\n            if (ilen>2 && ucp[0]=='\\'' && ubuf[ilen-2]=='\\'')\n                snprintf(buf, bsiz, \"puts(`%s`);\\n\", ucp); //output a 'Comment'\n                \n            else if (interp->debugOpts.testFmtCallback) {\n                Jsi_DString kStr={};\n                Jsi_Value *vrc = Jsi_ValueNew1(interp);\n                Jsi_DSPrintf(&kStr, \"[\\\"%s\\\", %d ]\", ucp, lineNo);\n                Jsi_RC rcs = Jsi_FunctionInvokeJSON(interp->parent, interp->debugOpts.testFmtCallback, Jsi_DSValue(&kStr), &vrc);\n                if (rcs == JSI_OK) {\n                    const char *cps = Jsi_ValueString(interp, vrc, NULL);\n                    if (!cps)\n                        rcs = JSI_ERROR;\n                    else\n                        snprintf(buf, bsiz, \"%s\", cps);\n                }\n                Jsi_DecrRefCount(interp, vrc);\n                Jsi_DSFree(&kStr);\n                if (rcs != JSI_OK)\n                    return Jsi_LogError(\"failure in debugOpts.testFmtCallback\");\n            } else if (ilen>3 && ubuf[0]=='/' && ubuf[0]=='/') {\n                char *ecp = ubuf+2;\n                while (*ecp && isspace(*ecp)) ecp++;\n                snprintf(buf, bsiz, \"printf(`%%s ==>`, \\\"%s\\\"); try { %s; puts('\\\\nFAIL!\\\\n'); } \"\n                    \"catch(err) { puts('\\\\nPASS!: err =',err); }\\n\", ecp, ecp);\n            } else {\n                snprintf(buf, bsiz, \"printf(`%%s ==> `,`%s`),puts(%s);\\n\", ucp, ucp);\n            }\n        }\n    }\n    return JSI_OK;\n}\n\nJsi_RC jsi_JsPreprocessLineCB(Jsi_Interp* interp, char *buf, size_t bsiz, uint ilen, int jOpts[4], int lineNo) {\n    const char *jpp = interp->jsppChars;\n    if (!jpp[0] || !jpp[1])\n        return JSI_OK;\n    if (buf[0] && jpp[0] == buf[0] && ilen>2 && buf[ilen-2]==jpp[1]) {\n        Jsi_DString dStr = {};\n        buf[ilen-2] = 0; // Remove last char and newline.\n        Jsi_Value *inStr = Jsi_ValueNewStringDup(interp, buf+1);\n        Jsi_IncrRefCount(interp, inStr);\n        Jsi_RC rc = Jsi_FunctionInvokeString(interp, interp->jsppCallback, inStr, &dStr);\n        if (Jsi_InterpGone(interp))\n            return JSI_ERROR;\n        if (rc != JSI_OK) {\n            Jsi_DSFree(&dStr);\n            Jsi_DecrRefCount(interp, inStr);\n            return JSI_ERROR;\n        }\n        Jsi_DecrRefCount(interp, inStr);\n        Jsi_DSAppendLen(&dStr, \"\\n\", 1);\n        Jsi_Strncpy(buf, Jsi_DSValue(&dStr), bsiz);\n        buf[bsiz-1] = 0;\n        Jsi_DSFree(&dStr);\n    }\n    return JSI_OK;\n}\n\nJsi_RC jsi_evalStrFile(Jsi_Interp* interp, Jsi_Value *path, const char *str, int flags, int level)\n{\n    Jsi_Channel tinput = NULL, input = Jsi_GetStdChannel(interp, 0);\n    Jsi_Value *npath = path;\n    Jsi_RC rc = JSI_ERROR;\n    const char *ustr = NULL, *ostr = str;\n    if (Jsi_MutexLock(interp, interp->Mutex) != JSI_OK)\n        return rc;\n    int oldSp, uskip = 0, fncOfs = 0, fnLen;\n    int oldef = interp->evalFlags;\n    jsi_Pstate *oldps = interp->ps;\n    const char *oldFile = interp->curFile;\n    char *origFile = Jsi_ValueString(interp, path, &fnLen);\n    const char *fname = origFile;\n    char *oldDir = interp->curDir, *cp;\n    char dirBuf[PATH_MAX];\n    jsi_Pstate *ps = NULL;\n    jsi_FileInfo *fi = NULL;\n    int exists = (flags&JSI_EVAL_EXISTS);\n    int ignore = (flags&JSI_EVAL_ERRIGNORE);\n    if (flags & JSI_EVAL_GLOBAL)\n        level = 1;\n    int oisi = interp->isMain;\n    if (flags & JSI_EVAL_ISMAIN)\n        interp->isMain = 1;\n    \n    oldSp = interp->framePtr->Sp;\n    dirBuf[0] = 0;\n    Jsi_DString dStr, fStr;\n    Jsi_DSInit(&dStr);\n    Jsi_DSInit(&fStr);\n\n    if (str == NULL) {\n        if (fname != NULL) {\n            if (fnLen>2 && fname[fnLen-1]=='/') {\n                Jsi_DSAppendLen(&fStr, fname, fnLen-1);\n                const char *fcp = Jsi_DSValue(&fStr), *fce = strrchr(fcp,'/');\n                if (fce) {\n                    fname = Jsi_DSAppend(&fStr, fce, \".jsi\", NULL);\n                    npath = Jsi_ValueNewStringDup(interp, fname);\n                    Jsi_IncrRefCount(interp, npath);\n                }\n            }\n            if (!Jsi_Strcmp(fname,\"-\"))\n                input = Jsi_GetStdChannel(interp, 0);\n            else {\n                /* Use translated FileName. */\n                if (interp->curDir && fname[0] != '/' && fname[0] != '~') {\n                    char dirBuf2[PATH_MAX], *np;\n                    snprintf(dirBuf, sizeof(dirBuf), \"%s/%s\", interp->curDir, fname);\n                    if ((np=Jsi_FileRealpathStr(interp, dirBuf, dirBuf2)) == NULL) {\n                        Jsi_LogError(\"Can not open '%s'\", fname);\n                        goto bail;\n                    }\n                    if (npath != path)\n                        Jsi_IncrRefCount(interp, npath);\n                    npath = Jsi_ValueNewStringDup(interp, np);\n                    Jsi_IncrRefCount(interp, npath);\n                    fname = Jsi_ValueString(interp, npath, NULL);\n                }\n                if (flags&JSI_EVAL_ARGV0) {\n                    if (interp->argv0)\n                        Jsi_DecrRefCount(interp, interp->argv0);\n                    interp->argv0 = Jsi_ValueNewStringDup(interp, fname);\n                    Jsi_IncrRefCount(interp, interp->argv0);\n                }\n                \n                bool osafe = interp->isSafe;\n                if (interp->startSafe  && flags&JSI_EVAL_ARGV0) {\n                    if (interp->safeReadDirs || interp->safeMode == jsi_safe_None)\n                        interp->isSafe = 0;\n                    else {\n                        char vds[PATH_MAX], *cp;\n                        const char *vda[2] = {vds};\n                        Jsi_Strncpy(vds, Jsi_ValueString(interp, npath, NULL), sizeof(vds)-1);\n                        vds[sizeof(vds)-1] = 0;\n                        cp = Jsi_Strrchr(vds, '/');\n                        if (cp)\n                            cp[1] = 0;\n                        Jsi_DString pStr = {};\n                        vda[1] = Jsi_GetCwd(interp, &pStr);\n                        interp->safeReadDirs = Jsi_ValueNewArray(interp, vda, 2);\n                        Jsi_IncrRefCount(interp, interp->safeReadDirs);\n                        if (interp->safeMode == jsi_safe_WriteRead || interp->safeMode == jsi_safe_Lockdown) {\n                            if (!interp->safeWriteDirs) {\n                                interp->safeWriteDirs = interp->safeReadDirs;\n                                Jsi_IncrRefCount(interp, interp->safeWriteDirs);\n                            }\n                        } else if (interp->safeMode == jsi_safe_Write) {\n                            interp->safeWriteDirs = Jsi_ValueNewArray(interp, vda+1, 1);\n                            Jsi_IncrRefCount(interp, interp->safeWriteDirs);\n                        }\n                        Jsi_DSFree(&pStr);\n                    }\n                }\n                tinput = input = Jsi_Open(interp, npath, (exists?\"-r\":\"r\"));\n                interp->isSafe = osafe;\n                if (!input) {\n                    if (exists)\n                        rc = JSI_OK;\n                    //Jsi_LogError(\"Can not open '%s'\", fname);\n                    goto bail;\n                }\n            }\n            cp = Jsi_Strrchr(fname, '.');\n            if (cp && !Jsi_Strcmp(cp, \".jsi\") && interp->isMain) {\n                interp->typeCheck.parse = interp->typeCheck.run = interp->typeCheck.all = 1;\n                interp->strict = 1;\n            }\n            bool isNew;\n            Jsi_HashEntry *hPtr;\n            hPtr = Jsi_HashEntryNew(interp->fileTbl, fname, &isNew);\n            if (isNew == 0 && hPtr) {\n                if ((flags & JSI_EVAL_ONCE)) {\n                    rc = JSI_OK;\n                    goto bail;\n                }\n                fi = (jsi_FileInfo *)Jsi_HashValueGet(hPtr);\n                if (!fi) goto bail;\n                interp->curFile = fi->fileName;\n                interp->curDir = fi->dirName;\n                \n            } else {\n                fi = (jsi_FileInfo *)Jsi_Calloc(1,sizeof(*fi));\n                if (!fi) goto bail;\n                Jsi_HashValueSet(hPtr, fi);\n                fi->origFile = (char*)Jsi_KeyAdd(interp, origFile);\n                interp->curFile = fi->fileName = (char*)Jsi_KeyAdd(interp, fname);\n                char *dfname = Jsi_Strdup(fname);\n                if ((cp = Jsi_Strrchr(dfname,'/')))\n                    *cp = 0;\n                interp->curDir = fi->dirName = (char*)Jsi_KeyAdd(interp, dfname);\n                Jsi_Free(dfname);\n            }\n            if (!input->fname)\n                input->fname = interp->curFile;\n\n            int cnt = 0, noncmt = 0, jppOpts[4]={};\n            uint ilen;\n            char buf[JSI_BUFSIZ*2];\n            const char *jpp;\n            while (cnt<MAX_LOOP_COUNT) {\n                if (!Jsi_Gets(interp, input, buf, sizeof(buf)))\n                    break;\n                if (++cnt==1 && (!(flags&JSI_EVAL_NOSKIPBANG)) && (buf[0] == '#' && buf[1] == '!')) {\n                    Jsi_DSAppend(&dStr, \"\\n\", NULL);\n                    uskip=1;\n                    continue;\n                }\n                if (!noncmt) {\n                    int bi;\n                    if (!buf[0] || (buf[0] == '/' && buf[1] == '/'))\n                        goto cont;\n                    for (bi=0; buf[bi]; bi++) if (!isspace(buf[bi])) break;\n                    if (!buf[bi])\n                        goto cont;\n                }\n                if (!noncmt++)\n                    fncOfs = Jsi_DSLength(&dStr)-uskip;\n                jpp = interp->jsppChars;\n                if (jpp || interp->unitTest)\n                    ilen = Jsi_Strlen(buf);\n                if (interp->unitTest && buf[0]==';' && buf[1] && buf[2]) {\n                    if (interp->unitTest&1 && jsi_JsPreprocessLine(interp, buf, sizeof(buf), ilen, jppOpts, cnt) != JSI_OK)\n                        goto bail;\n                } else if (interp->jsppCallback && interp->jsppChars) {\n                    if (jsi_JsPreprocessLineCB(interp, buf, sizeof(buf), ilen, jppOpts, cnt) != JSI_OK)\n                        goto bail;\n                }\ncont:\n                Jsi_DSAppend(&dStr, buf,  NULL);\n            }\n            if (cnt>=MAX_LOOP_COUNT)\n                Jsi_LogError(\"source file too large\");\n            str = Jsi_DSValue(&dStr);\n\n        }\n        if (interp->curDir && (flags&JSI_EVAL_AUTOINDEX))\n            Jsi_AddAutoFiles(interp, interp->curDir);\n    }\n    ustr = str + fncOfs;\n    // See if \"use XXX\" is on first non // or empty line (or second if there is a #! on first line)\n    if (ustr && *ustr && !Jsi_Strncmp(ustr+uskip, \"\\\"use \", 5)) {\n        ustr += 5+uskip;\n        const char *cpe = ustr;\n        while (*cpe && *cpe != '\\\"' && *cpe != '\\n' && (isalpha(*cpe) || *cpe ==',' || *cpe =='!')) cpe++;\n        if (*cpe == '\\\"') {\n            Jsi_DString cStr;\n            Jsi_DSInit(&cStr);\n            cpe = Jsi_DSAppendLen(&cStr, ustr, (cpe-ustr));\n            rc = jsi_ParseTypeCheckStr(interp, cpe);\n            Jsi_DSFree(&cStr);\n            if (rc != JSI_OK)\n                goto bail;\n        }\n    }\n\n    /* TODO: cleanup interp->framePtr->Sp stuff. */\n    oldSp = interp->framePtr->Sp;\n    // Evaluate code.\n    rc = JSI_OK;\n    ps = jsiNewParser(interp, str, input, 0);\n    interp->evalFlags = flags;\n    if (!ps)\n        rc = JSI_ERROR;\n    else {\n        Jsi_ValueMakeUndef(interp, &interp->retValue);\n        interp->ps = ps;\n        Jsi_Value *retValue = interp->retValue;\n        if (!interp->strict)\n            interp->strict = (jsi_GetDirective(interp, ps->opcodes, \"use strict\")!=NULL);\n        const char *curFile = interp->curFile;\n\n        if (level <= 0)\n            rc = jsi_evalcode(ps, NULL, ps->opcodes, interp->gsc, interp->csc, interp->csc, &retValue);\n        else {\n            jsi_Frame *fptr = interp->framePtr;\n            while (fptr && fptr->level > level)\n                fptr = fptr->parent;\n            if (!fptr)\n                rc = JSI_ERROR;\n            else\n                rc = jsi_evalcode(ps, NULL, ps->opcodes, fptr->ingsc, fptr->incsc, fptr->inthis, &retValue);\n        }\n        interp->curFile = curFile;\n        if (rc != JSI_OK)\n            rc = (ignore?JSI_OK:JSI_ERROR);\n        else if (ps->last_exception || oldps->last_exception)\n            Jsi_ValueDup2(interp, &oldps->last_exception, ps->last_exception); //TODO: dup even if null?\n        interp->ps = oldps;\n        interp->evalFlags = oldef;\n        if (rc == JSI_OK && ps && !ostr)\n            fi->str = ps->lexer->d.str;\n    }\n    \nbail:\n    interp->curFile = oldFile;\n    interp->curDir = oldDir;\n    interp->framePtr->Sp = oldSp;\n    interp->isMain = oisi;\n    if (path != npath)\n        Jsi_DecrRefCount(interp, npath);\n    Jsi_DSFree(&dStr);\n    Jsi_DSFree(&fStr);\n    if (tinput)\n        Jsi_Close(interp, tinput);\n    Jsi_MutexUnlock(interp, interp->Mutex);\n    if (interp->exited && interp->level <= 0)\n    {\n        rc = JSI_EXIT;\n        if (!interp->parent)\n            Jsi_InterpDelete(interp);\n    }\n\n    return rc;\n}\n\nJsi_RC Jsi_EvalFile(Jsi_Interp* interp, Jsi_Value *fname, int flags)\n{\n    int isnull;\n    if ((isnull=Jsi_ValueIsNull(interp, fname)) || Jsi_ValueIsUndef(interp, fname)) \n        return Jsi_LogError(\"invalid file eval %s\", (isnull?\"null\":\"undefined\"));\n    int lev = interp->framePtr->level;\n    return jsi_evalStrFile(interp, fname, NULL, flags, lev);\n}\n\nJsi_RC Jsi_EvalString(Jsi_Interp* interp, const char *str, int flags)\n{\n    int lev = interp->framePtr->level;\n    return jsi_evalStrFile(interp, NULL, (char*)str, flags, lev);\n}\n\n#undef _jsi_THIS\n#undef _jsi_STACK\n#undef _jsi_STACKIDX\n#undef _jsi_THISIDX\n#undef _jsi_TOP\n#undef _jsi_TOQ\n\n#endif\n", "#ifndef JSI_AMALGAMATION\n#include \"jsiInt.h\"\n#endif\n#include <stdio.h>\n#include <string.h>\n#include <fcntl.h>\n#include <assert.h>\n#include <dirent.h>\n\n#ifndef __WIN32\n#include <pwd.h>\n#include <unistd.h>\n#else\n#include <windef.h>\n#endif\n#include <limits.h>\n\n#ifndef JSI_LITE_ONLY\n\n#define _JSI_GETFP(ch,in) (ch && ch->fp ? ch->fp : (in?stdin:stdout))\n\n//static Jsi_CmdSpec filesysCmds[];\n\nstatic char* jsi_FSRealPathProc(Jsi_Interp *interp, Jsi_Value *path, char *newPath);\n\n\ntypedef struct FileObj {\n#ifdef JSI_HAS_SIG\n    jsi_Sig sig;\n#endif\n    Jsi_Interp *interp;\n    Jsi_Channel chan;\n    Jsi_Value *fname;\n    char *filename;\n    char *mode;\n    Jsi_Obj *fobj;\n    int objId;\n} FileObj;\n\nstatic void fileObjErase(FileObj *fo);\nstatic Jsi_RC fileObjFree(Jsi_Interp *interp, void *data);\nstatic bool fileObjIsTrue(void *data);\nstatic bool fileObjEqual(void *data1, void *data2);\n\n#ifdef __WIN32\nchar *get_current_dir_name() {\n    static char buf[MAX_PATH] = \".\";\n    getcwd(buf, sizeof(buf));\n    return buf;\n}\n#endif\n\nstatic const char *jsi_TildePath(Jsi_Interp *interp, const char* path, Jsi_DString *dStr) {\n    if (*path != '~')\n        return path;\n    const char *homedir = jsi_GetHomeDir(interp);\n    if (!homedir)\n        return path;\n    Jsi_DSAppend(dStr, homedir, path[1] == '/' ? \"\" : \"/\", path+1, NULL);\n    return Jsi_DSValue(dStr);\n}\n\nint jsi_FSScandirProc(Jsi_Interp *interp, Jsi_Value *path, Jsi_Dirent ***namelist,\n   int (*filter)(const Jsi_Dirent *), int (*compar)(const Jsi_Dirent **, const Jsi_Dirent**))\n{\n    const char *dirname = Jsi_ValueToString(interp, path, NULL);\n    Jsi_DString dStr = {};\n    if (*dirname == '~')\n        dirname = jsi_TildePath(interp, dirname, &dStr);\n    int rc = scandir(dirname, namelist, filter, compar);\n    Jsi_DSFree(&dStr);\n    return rc;\n}\n\nstatic int jsi_FSCreateDirectoryProc(Jsi_Interp *interp, Jsi_Value* path) {\n    const char *pathPtr = Jsi_ValueToString(interp, path, NULL);\n    Jsi_DString dStr = {};\n    int rc;\n    if (*pathPtr == '~')\n        pathPtr = jsi_TildePath(interp, pathPtr, &dStr);\n\n#ifdef __WIN32\n    rc = mkdir(pathPtr);\n#else\n    rc = mkdir(pathPtr, 0666);\n#endif\n    Jsi_DSFree(&dStr);\n    return rc;\n}\n\nstatic int jsi_FSRenameProc(Jsi_Interp *interp, Jsi_Value *src, Jsi_Value *dest) {\n    const char *zSrc = Jsi_ValueToString(interp, src, NULL);\n    const char *zDest = Jsi_ValueToString(interp, dest, NULL);\n    Jsi_DString dStr = {}, eStr = {};\n    if (*zSrc == '~')\n        zSrc = jsi_TildePath(interp, zSrc, &dStr);\n    if (*zDest == '~')\n        zDest = jsi_TildePath(interp, zDest, &eStr);\n    int rc = rename(zSrc, zDest);\n    Jsi_DSFree(&dStr);\n    Jsi_DSFree(&eStr);\n    return rc;\n}\n\nstatic Jsi_Value * jsi_FSListVolumesProc(Jsi_Interp *interp) {return 0;}\n\nstatic int jsi_FSRemoveProc(Jsi_Interp *interp, Jsi_Value* path, int flags) {\n    const char *pathPtr = Jsi_ValueToString(interp, path, NULL);\n    Jsi_DString dStr = {};\n    if (*pathPtr == '~')\n        pathPtr = jsi_TildePath(interp, pathPtr, &dStr);\n    int rc = remove(pathPtr);\n    Jsi_DSFree(&dStr);\n    return rc;\n}\n\nstatic bool jsi_FSPathInFilesystemProc(Jsi_Interp *interp, Jsi_Value* path,void **clientDataPtr) {return 1;}\n\nstatic int jsi_FSAccessProc(Jsi_Interp *interp, Jsi_Value* path, int mode) {\n    const char *pathPtr = Jsi_ValueToString(interp, path, NULL);\n    Jsi_DString dStr = {};\n    if (*pathPtr == '~')\n        pathPtr = jsi_TildePath(interp, pathPtr, &dStr);\n    int rc = access(pathPtr, mode);\n    Jsi_DSFree(&dStr);\n    return rc;\n}\n\nstatic int jsi_FSChmodProc(Jsi_Interp *interp, Jsi_Value* path, int mode) {\n#ifdef __WIN32\n    return -1;\n#else\n    const char *pathPtr = Jsi_ValueToString(interp, path, NULL);\n    Jsi_DString dStr = {};\n    if (*pathPtr == '~')\n        pathPtr = jsi_TildePath(interp, pathPtr, &dStr);\n    int rc = chmod(pathPtr, mode);\n    Jsi_DSFree(&dStr);\n    return rc;\n#endif\n}\n\nstatic int jsi_FSStatProc(Jsi_Interp *interp, Jsi_Value* path, Jsi_StatBuf *buf) {\n    const char *pathPtr = Jsi_ValueToString(interp, path, NULL);\n    Jsi_DString dStr = {};\n    if (*pathPtr == '~')\n        pathPtr = jsi_TildePath(interp, pathPtr, &dStr);\n    int rc = stat(pathPtr, buf);\n    Jsi_DSFree(&dStr);\n    return rc;\n}\n\nstatic int jsi_FSLstatProc(Jsi_Interp *interp, Jsi_Value* path, Jsi_StatBuf *buf) {\n#ifdef __WIN32\n    return jsi_FSStatProc(interp, path, buf);\n#else\n    const char *pathPtr = Jsi_ValueToString(interp, path, NULL);\n    Jsi_DString dStr = {};\n    if (*pathPtr == '~')\n        pathPtr = jsi_TildePath(interp, pathPtr, &dStr);\n    int rc = lstat(pathPtr, buf);\n    Jsi_DSFree(&dStr);\n    return rc;\n#endif\n}\nstatic int jsi_FSFlushProc(Jsi_Channel chan) { return fflush(_JSI_GETFP(chan,0));}\nstatic int jsi_FSTellProc(Jsi_Channel chan) { return ftell(_JSI_GETFP(chan,1));}\nstatic int jsi_FSEofProc(Jsi_Channel chan) { return feof(_JSI_GETFP(chan,1));}\nstatic int jsi_FSTruncateProc(Jsi_Channel chan, unsigned int len) { return ftruncate(fileno(_JSI_GETFP(chan,1)), len);}\nstatic int jsi_FSRewindProc(Jsi_Channel chan) { rewind(_JSI_GETFP(chan,1)); return 0;}\nstatic int jsi_FSCloseProc(Jsi_Channel chan) { return fclose(_JSI_GETFP(chan,1));}\nstatic int jsi_FSSeekProc(Jsi_Channel chan, Jsi_Wide offset, int mode) { return fseek(_JSI_GETFP(chan,1), offset, mode);}\n\nstatic int jsi_FSWriteProc(Jsi_Channel chan, const char *buf, int size) {\n    return fwrite(buf, 1, size, _JSI_GETFP(chan,0));\n}\n\nstatic int jsi_FSReadProc(Jsi_Channel chan, char *buf, int size) {\n    return fread(buf, 1, size, _JSI_GETFP(chan,0));\n}\n\n#ifdef __WIN32\n#define jsi_FSLinkProc NULL\n#define jsi_FSReadlinkProc NULL\n#else //__WIN32\nstatic int jsi_FSLinkProc(Jsi_Interp *interp, Jsi_Value* path, Jsi_Value *toPath, int linkType) {\n    const char *pathPtr = Jsi_ValueToString(interp, path, NULL);\n    const char *toPtr = Jsi_ValueToString(interp, toPath, NULL);\n    Jsi_DString dStr = {}, eStr = {};\n    int rc;\n    if (*pathPtr == '~')\n        pathPtr = jsi_TildePath(interp, pathPtr, &dStr);\n    if (*toPtr == '~')\n        toPtr = jsi_TildePath(interp, toPtr, &eStr);\n    if (linkType != 0)\n        rc = link(pathPtr, toPtr);\n    else\n        rc = symlink(pathPtr, toPtr);\n    Jsi_DSFree(&dStr);\n    Jsi_DSFree(&eStr);\n    return rc;\n}\n\nstatic int jsi_FSReadlinkProc(Jsi_Interp *interp, Jsi_Value *path, char *buf, int size) {\n    const char *pathPtr = Jsi_ValueToString(interp, path, NULL);\n    Jsi_DString dStr = {};\n    if (*pathPtr == '~')\n        pathPtr = jsi_TildePath(interp, pathPtr, &dStr);\n    int rc = readlink(pathPtr, buf, size);\n    Jsi_DSFree(&dStr);\n    return rc;\n}\n#endif // __WIN32\n\nstatic int jsi_FSGetcProc(Jsi_Channel chan) {\n    return fgetc(_JSI_GETFP(chan,1));\n}\n\nstatic int jsi_FSUngetcProc(Jsi_Channel chan, int ch) {\n    return ungetc(ch, _JSI_GETFP(chan,1));\n}\n\nstatic char * jsi_FSGetsProc(Jsi_Channel chan, char *s, int size) {\n    return fgets(s, size, _JSI_GETFP(chan,1));\n}\n\nstatic int jsi_FSPutsProc(Jsi_Channel chan, const char *s) {\n    return fputs(s, _JSI_GETFP(chan,0));\n}\n\n/* Not used as Jsi_Open already handles native. */\nJsi_Channel jsi_FSOpenProc(Jsi_Interp *interp, Jsi_Value *file, const char *modeString)\n{\n    return Jsi_Open(interp, file, modeString);\n}\n\ntypedef struct FSList {\n    Jsi_Filesystem* fsPtr;\n    void *data;\n    struct FSList *next;\n} FSList;\n\nstatic FSList *jsiFSList = NULL;\n\nstatic Jsi_Filesystem jsiFilesystem = {\n    .typeName=\"native\",\n    .structureLength=sizeof(Jsi_Filesystem),\n    .version=1,\n    .pathInFilesystemProc=jsi_FSPathInFilesystemProc,\n    .realpathProc=jsi_FSRealPathProc,\n    .statProc=jsi_FSStatProc,\n    .lstatProc=jsi_FSLstatProc,\n    .accessProc=jsi_FSAccessProc,\n    .chmodProc=jsi_FSChmodProc,\n    .openProc=jsi_FSOpenProc,\n    .scandirProc=jsi_FSScandirProc,\n    .readProc=jsi_FSReadProc,\n    .writeProc=jsi_FSWriteProc,\n    .getsProc=jsi_FSGetsProc,\n    .getcProc=jsi_FSGetcProc,\n    .ungetcProc=jsi_FSUngetcProc,\n    .putsProc=jsi_FSPutsProc,\n    .flushProc=jsi_FSFlushProc,\n    .seekProc=jsi_FSSeekProc,\n    .tellProc=jsi_FSTellProc,\n    .eofProc=jsi_FSEofProc,\n    .truncateProc=jsi_FSTruncateProc,\n    .rewindProc=jsi_FSRewindProc,\n    .closeProc=jsi_FSCloseProc,\n    .linkProc=jsi_FSLinkProc,\n    .readlinkProc=jsi_FSReadlinkProc,\n    .listVolumesProc=jsi_FSListVolumesProc,\n    .createDirectoryProc=jsi_FSCreateDirectoryProc,\n    .removeProc=jsi_FSRemoveProc,\n    .renameProc=jsi_FSRenameProc,\n};\n\nJsi_Channel Jsi_GetStdChannel(Jsi_Interp *interp, int id) {\n    if (id<0 || id>2)\n        return NULL;\n    return jsiIntData.stdChans+id;\n}\n\nJsi_RC Jsi_FSRegister(Jsi_Filesystem *fsPtr, void *data) {\n    FSList *fsl = (FSList *)Jsi_Calloc(1, sizeof(*fsl));\n    fsl->fsPtr = fsPtr;\n    fsl->data = data;\n    fsl->next = jsiFSList;\n    jsiFSList = fsl;\n    return JSI_OK;\n}\n\nJsi_RC Jsi_FSUnregister(Jsi_Filesystem *fsPtr) {\n    FSList *fsl = jsiFSList, *flast = NULL;\n    while (fsl) {\n        if (fsl->fsPtr == fsPtr) {\n            if (flast)\n                flast->next = fsl->next;\n            else\n                jsiFSList = fsl->next;\n            Jsi_Free(fsl);\n            break;\n        }\n        flast = fsl;\n        fsl = fsl->next;\n    }\n    return JSI_OK;\n}\n\nJsi_Filesystem* Jsi_FilesystemForPath(Jsi_Interp *interp, Jsi_Value* path, void**clientDataPtr) {\n    FSList *fsl = jsiFSList;\n    if (!fsl) return NULL;\n    clientDataPtr = NULL;\n    const char *pathStr = Jsi_ValueToString(interp, path, NULL);\n    if (!pathStr || pathStr[0] == '~')\n        return &jsiFilesystem;\n    if (pathStr[0] == '.' && pathStr[1] == 0)\n        return (jsiIntData.cwdFsPtr ? jsiIntData.cwdFsPtr : &jsiFilesystem);\n    Jsi_Value *tpath = NULL;\n    if (Jsi_Strstr(pathStr, \"..\")) {\n        Jsi_DString dStr;\n        Jsi_DSInit(&dStr);\n        pathStr = Jsi_ValueNormalPath(interp, path, &dStr);\n        tpath = path = Jsi_ValueNewStringDup(interp, pathStr);\n        Jsi_IncrRefCount(interp, tpath);\n        Jsi_DSFree(&dStr);\n    }\n    while (1) {\n        if (fsl->fsPtr->pathInFilesystemProc && fsl->fsPtr->pathInFilesystemProc(interp, path, clientDataPtr))\n            break;\n        if (!fsl->next)\n            break;\n        fsl = fsl->next;\n    }\n    if (tpath)\n        Jsi_DecrRefCount(interp, tpath);\n    return (fsl ? fsl->fsPtr : &jsiFilesystem);\n}\n\nint Jsi_Readlink(Jsi_Interp *interp, Jsi_Value* path, char *ret, int len) {\n#ifdef __WIN32\n    return -1;\n#else\n    void *data;\n    Jsi_Filesystem *fsPtr = Jsi_FilesystemForPath(interp, path, &data);\n    if (fsPtr == NULL || !fsPtr->readlinkProc) return -1;\n    return fsPtr->readlinkProc(interp, path, ret, len);\n#endif\n}\n\nint Jsi_Stat(Jsi_Interp *interp, Jsi_Value* path, Jsi_StatBuf *buf) {\n    void *data;\n    Jsi_Filesystem *fsPtr = Jsi_FilesystemForPath(interp, path, &data);\n    if (fsPtr == NULL || !fsPtr->statProc) return -1;\n    return fsPtr->statProc(interp, path, buf);\n}\n\nint Jsi_Link(Jsi_Interp *interp, Jsi_Value* src, Jsi_Value *dest, int typ) {\n    void *data;\n    Jsi_Filesystem *fsPtr = Jsi_FilesystemForPath(interp, src, &data);\n    if (fsPtr == NULL || !fsPtr->linkProc) return -1;\n    return fsPtr->linkProc(interp, src, dest, typ);\n}\n\nint Jsi_Lstat(Jsi_Interp *interp, Jsi_Value* path, Jsi_StatBuf *buf) {\n    void *data;\n    Jsi_Filesystem *fsPtr = Jsi_FilesystemForPath(interp, path, &data);\n    if (fsPtr == NULL || !fsPtr->lstatProc) return -1;\n    return fsPtr->lstatProc(interp, path, buf);\n}\n\nint Jsi_Chmod(Jsi_Interp *interp, Jsi_Value* path, int mode) {\n    void *data;\n    Jsi_Filesystem *fsPtr = Jsi_FilesystemForPath(interp, path, &data);\n    if (fsPtr == NULL || !fsPtr->chmodProc) return -1;\n    return fsPtr->chmodProc(interp, path, mode);\n}\nint Jsi_Access(Jsi_Interp *interp, Jsi_Value* path, int mode) {\n    void *data;\n    Jsi_Filesystem *fsPtr = Jsi_FilesystemForPath(interp, path, &data);\n    if (fsPtr == NULL || !fsPtr->accessProc) return -1;\n    if (interp->isSafe && fsPtr && fsPtr == &jsiFilesystem) {\n        int aflag = (mode&W_OK ? JSI_INTACCESS_WRITE : JSI_INTACCESS_READ);\n        if (Jsi_InterpAccess(interp, path, aflag) != JSI_OK)\n            return -1;\n    }\n    return fsPtr->accessProc(interp, path, mode);\n}\nint Jsi_Remove(Jsi_Interp *interp, Jsi_Value* path, int flags) {\n    void *data;\n    Jsi_Filesystem *fsPtr = Jsi_FilesystemForPath(interp, path, &data);\n    if (fsPtr == NULL || !fsPtr->removeProc) return -1;\n    return fsPtr->removeProc(interp, path, flags);\n}\nint Jsi_Rename(Jsi_Interp *interp, Jsi_Value *src, Jsi_Value *dst) {\n    void *data;\n    Jsi_Filesystem *fsPtr = Jsi_FilesystemForPath(interp, src, &data);\n    if (fsPtr != Jsi_FilesystemForPath(interp, src, &data)) return -1;\n    if (fsPtr == NULL || !fsPtr->renameProc) return -1;\n    return fsPtr->renameProc(interp, src,dst);\n}\n\nint Jsi_Scandir(Jsi_Interp *interp, Jsi_Value* path, Jsi_Dirent ***namelist,\n int (*filter)(const Jsi_Dirent *), int (*compar)(const Jsi_Dirent **, const Jsi_Dirent**)) \n {\n    void *data;\n    Jsi_Filesystem *fsPtr = Jsi_FilesystemForPath(interp, path, &data);\n    if (fsPtr == NULL || !fsPtr->scandirProc) return -1;\n    return fsPtr->scandirProc(interp, path, namelist, filter, compar);\n}\n\nbool Jsi_FSNative(Jsi_Interp *interp, Jsi_Value *file) {\n    void *data;\n    Jsi_Filesystem *fsPtr = Jsi_FilesystemForPath(interp, file, &data);\n    if (fsPtr && fsPtr == &jsiFilesystem)\n        return 1;\n    else\n        return 0;\n}\n\nstatic Jsi_Filesystem *jsi_FilesysFind(const char *name)\n{\n    FSList *fsPtr = jsiFSList;\n    while (fsPtr != NULL) {\n        if (!Jsi_Strcmp(fsPtr->fsPtr->typeName, name))\n            return fsPtr->fsPtr;\n        fsPtr = fsPtr->next;\n    }\n    return NULL;\n}\n\nJsi_Channel Jsi_Open(Jsi_Interp *interp, Jsi_Value *file, const char *modeString)\n{\n    /* Find fsys, and use open there. */\n    Jsi_Filesystem *fsPtr;\n    Jsi_Chan *ch = NULL;\n    void *data;\n    int fnl = 0;\n    const char *fileName = Jsi_ValueString(interp, file, &fnl), *oldFN = fileName;\n    if (!fileName || !fnl) {\n        Jsi_LogError(\"expected string filename\");\n        return NULL;\n    }\n    if (!Jsi_Strcmp(fileName, \"stdin\")) return jsiIntData.stdChans;\n    if (!Jsi_Strcmp(fileName, \"stdout\")) return jsiIntData.stdChans+1;\n    if (!Jsi_Strcmp(fileName, \"stderr\")) return jsiIntData.stdChans+2;\n    const char *s = modeString;\n    bool quiet = 0;\n    if (s[0]=='-') {\n        quiet = true;\n        s++;\n    }\n    char Mode[sizeof(ch->modes)];\n    Jsi_StatBuf sb;\n    Jsi_Value *path = NULL;\n    int n, i, mode = 0, rc, writ, aflag;\n    if (!s)\n        s = \"r\";\n    if (Jsi_Strlen(s) >= sizeof(ch->modes)) {\n        Jsi_LogError(\"mode too long: %s\", s);\n        return NULL;\n    }\n    if (Jsi_Strchr(s, 'z') || Jsi_Strchr(s, 'Z')) {\n        Jsi_Filesystem *fsPtr = jsi_FilesysFind(\"jfz\");\n        if (!fsPtr) {\n            Jsi_LogError(\"compressed files unsupported\");\n            return NULL;\n        }\n        ch = fsPtr->openProc(interp, file, s);\n        if (!ch) {\n            if (!quiet)\n                Jsi_LogError(\"File open failed '%s'\", fileName);\n            return NULL;\n        }\n        Jsi_Chan *nch = (Jsi_Chan *)Jsi_Calloc(1,sizeof(*nch));\n        *nch = *ch;\n        nch->fsPtr = fsPtr;\n        return nch;\n    }\n    for (i=0, n = 0; s[i]; i++) {\n        switch (s[i]) {\n            case '+': break;\n            case 'b': break;\n            case 'r': if (!Jsi_Strchr(s,'+')) mode |= JSI_FS_READONLY; break;\n            case 'a':\n            case 'w': if (!Jsi_Strchr(s,'+')) mode |= JSI_FS_WRITEONLY; break;\n            default: Jsi_LogError(\"unknown mode char: %c\", s[i]); return NULL;\n        }\n        Mode[n++] = s[i];\n    }\n    Mode[n] = 0;\n    /* Fixup files in the ~ dir */\n    rc = Jsi_Stat(interp, file,&sb);\n    if ((rc != 0 || *fileName == '~') && (fileName = Jsi_FileRealpath(interp, file, NULL))) {\n        path = Jsi_ValueNewString(interp, fileName, -1);\n        Jsi_IncrRefCount(interp, path);\n        rc = Jsi_Stat(interp, path, &sb);\n        if (rc == 0)\n            file = path;\n    }\n    if (!fileName) {\n        Jsi_LogError(\"file error: %s\", oldFN);\n        return NULL;\n    }\n\n    if (rc == 0 &&  sb.st_mode & S_IFDIR )\n    {\n        Jsi_LogError(\"can not open directory: %s\", fileName);\n        goto done;\n    }\n    fsPtr = Jsi_FilesystemForPath(interp, file, &data);\n    writ = (Jsi_Strchr(s,'w') || Jsi_Strchr(s,'a') || Jsi_Strchr(s,'+'));\n    aflag = (writ ? JSI_INTACCESS_WRITE : JSI_INTACCESS_READ);\n    if (fsPtr && fsPtr != &jsiFilesystem) {\n        ch = fsPtr->openProc(interp, file, Mode);\n        if (ch)\n            ch->isNative = 0;\n        else\n            Jsi_LogError(\"File open failed '%s'\", fileName);\n    } else {\n        if (interp->isSafe && ((rc && Jsi_InterpAccess(interp, file, JSI_INTACCESS_CREATE) != JSI_OK)\n        || Jsi_InterpAccess(interp, file, aflag) != JSI_OK)) {\n            Jsi_LogError(\"%s access denied: %s\", writ?\"write\":\"read\", fileName);\n            goto done;\n        }\n        FILE *fp = fopen(fileName, Mode);\n        fsPtr = &jsiFilesystem;\n        if (!fp) {\n            if (!quiet)\n                Jsi_LogError(\"File open failed '%s'\", fileName);\n            goto done;\n        }\n        ch = (Jsi_Chan *)Jsi_Calloc(1,sizeof(*ch));\n        ch->fp = fp;\n        ch->isNative = 1;\n    }\n    if (ch) {\n        ch->flags |= mode; // + (zLevel<<24);\n        Jsi_Strcpy(ch->modes, s);\n        ch->fsPtr = fsPtr;\n        ch->fname = fileName;\n    }\ndone:\n    if (path)\n        Jsi_DecrRefCount(interp, path);\n    return ch;\n}\n\nint Jsi_SetChannelOption(Jsi_Interp *interp, Jsi_Channel chan, const char *optionName,\n    const char *newValue) {return JSI_OK;}\n    \nJsi_Wide Jsi_Seek(Jsi_Interp *interp, Jsi_Channel chan, Jsi_Wide offset, int mode) {\n    if (chan->fsPtr==0 || !chan->fsPtr->seekProc) return -1;\n    return chan->fsPtr->seekProc(chan, offset, mode);\n}\nJsi_Wide Jsi_Tell(Jsi_Interp *interp, Jsi_Channel chan) {\n    if (chan->fsPtr==0 || !chan->fsPtr->tellProc) return -1;\n    return chan->fsPtr->tellProc(chan);\n}\nint Jsi_Eof(Jsi_Interp *interp, Jsi_Channel chan) {\n    if (chan->fsPtr==0 || !chan->fsPtr->eofProc) return -1;\n    return chan->fsPtr->eofProc(chan);\n}\nJsi_Wide Jsi_Rewind(Jsi_Interp *interp, Jsi_Channel chan) {\n    if (chan->fsPtr==0 || !chan->fsPtr->rewindProc) return -1;\n    return chan->fsPtr->rewindProc(chan);\n}\n\n/*Jsi_StatBuf* Jsi_AllocStatBuf(void) {return 0;}*/\n\nint Jsi_Read(Jsi_Interp *interp, Jsi_Channel chan, char *bufPtr, int toRead) {\n    if (chan->fsPtr==0 || !chan->fsPtr->readProc) return -1;\n    return chan->fsPtr->readProc(chan, bufPtr, toRead);\n}\nint Jsi_Write(Jsi_Interp *interp, Jsi_Channel chan, const char *bufPtr, int slen) {\n    if (chan->fsPtr==0 || !chan->fsPtr->writeProc) return -1;\n    return chan->fsPtr->writeProc(chan, bufPtr, slen);\n}\nint Jsi_Truncate(Jsi_Interp *interp, Jsi_Channel chan, unsigned int len) {\n    if (chan->fsPtr==0 || !chan->fsPtr->truncateProc) return -1;\n    return chan->fsPtr->truncateProc(chan, len);\n}\n\nint Jsi_Close(Jsi_Interp *interp, Jsi_Channel chan) {\n    if (chan->fsPtr==0 || !chan->fsPtr->closeProc) return -1;\n    if (chan->flags&JSI_FS_NOCLOSE) return -1;\n    int rc = chan->fsPtr->closeProc(chan);\n    if (rc == 0)\n        Jsi_Free(chan);\n    return rc;\n}\nint Jsi_Flush(Jsi_Interp *interp, Jsi_Channel chan) {\n    if (chan->fsPtr==0 || !chan->fsPtr->flushProc) return -1;\n    return chan->fsPtr->flushProc(chan);\n}\n\nint Jsi_Getc(Jsi_Interp *interp, Jsi_Channel chan) {\n    if (chan->fsPtr==0 || !chan->fsPtr->getcProc) return -1;\n    return chan->fsPtr->getcProc(chan);\n}\n\nint Jsi_Ungetc(Jsi_Interp *interp, Jsi_Channel chan, int ch) {\n    if (chan->fsPtr==0 || !chan->fsPtr->ungetcProc) return -1;\n    return chan->fsPtr->ungetcProc(chan, ch);\n}\n\nchar * Jsi_Gets(Jsi_Interp *interp, Jsi_Channel chan, char *s, int size) {\n    if (chan->fsPtr==0 || !chan->fsPtr->getsProc) return NULL;\n    return chan->fsPtr->getsProc(chan, s, size);\n}\n\nint Jsi_Chdir(Jsi_Interp *interp, Jsi_Value* path) {\n    void *data;\n    int rc = 0;\n    const char *pathPtr = Jsi_ValueToString(interp, path, NULL);\n    if (interp->isSafe && Jsi_InterpAccess(interp, path, JSI_INTACCESS_READ) != JSI_OK) \n        return Jsi_LogError(\"read access denied\");\n    Jsi_Filesystem *fsPtr = Jsi_FilesystemForPath(interp, path, &data);\n    if (fsPtr == &jsiFilesystem) {\n        rc = chdir(pathPtr);\n        if (rc < 0)\n            return -1;\n        /* If change out of native fs, GetCwd will use pwdStr */\n        fsPtr = NULL;\n    }\n    Jsi_DSSetLength(&jsiIntData.pwdStr, 0);\n    Jsi_DSAppendLen(&jsiIntData.pwdStr, pathPtr, -1);\n    jsiIntData.cwdFsPtr = fsPtr;\n    jsiIntData.pwd = fsPtr ? Jsi_DSValue(&jsiIntData.pwdStr) : NULL;\n    return rc;\n}\n\nchar* Jsi_ValueNormalPath(Jsi_Interp *interp, Jsi_Value *file, Jsi_DString *dStr) {\n    return Jsi_NormalPath(interp, Jsi_ValueString(interp, file, NULL), dStr);\n}\n\nchar *Jsi_FileRealpath(Jsi_Interp *interp, Jsi_Value *spath, char *newname)\n{\n    char *path = Jsi_ValueString(interp, spath, 0);\n    if (!path) return NULL;\n    return Jsi_FileRealpathStr(interp, path, newname);\n}\n\nstatic char* jsi_FSRealPathProc(Jsi_Interp *interp, Jsi_Value *src, char *newPath) {\n    return Jsi_FileRealpath(interp, src, newPath);\n}\n\nJsi_RC Jsi_PathNormalize(Jsi_Interp *interp, Jsi_Value **pathPtr) {\n    Jsi_Value *path = *pathPtr;\n    if (!path) {\n        Jsi_DString dStr = {};\n        *pathPtr = Jsi_ValueNewStringDup(interp, Jsi_GetCwd(interp, &dStr));\n        Jsi_IncrRefCount(interp, *pathPtr);\n        Jsi_DSFree(&dStr);\n    } else {\n        const char *rn = Jsi_Realpath(interp, path, NULL);\n        if (!rn) return JSI_ERROR;\n        Jsi_DecrRefCount(interp, *pathPtr);\n        *pathPtr = Jsi_ValueNewString(interp, rn, -1);\n        Jsi_IncrRefCount(interp, *pathPtr);\n    }\n    return JSI_OK;\n}\n\nchar *Jsi_Realpath(Jsi_Interp *interp, Jsi_Value *src, char *newname)\n{\n    /* TODO: resolve pwd first. */\n    void *data;\n    const char *cp = NULL;\n    Jsi_Filesystem *fsPtr;\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    const char *npath = Jsi_ValueNormalPath(interp, src, &dStr);\n    if (!npath) return NULL;\n    Jsi_Value *tPtr = Jsi_ValueNew1(interp);\n    Jsi_ValueMakeStringDup(interp, &tPtr, npath);\n    fsPtr = Jsi_FilesystemForPath(interp, tPtr, &data);\n    if (fsPtr) {\n        if (fsPtr->realpathProc)\n            cp = fsPtr->realpathProc(interp, src, newname);\n        else if (!newname)\n            cp = Jsi_Strdup(npath);\n        else {\n            Jsi_Strncpy(newname, npath, PATH_MAX);\n            if (Jsi_Strlen(npath)>=PATH_MAX)\n                newname[PATH_MAX-1] = 0;\n        }\n    }\n    Jsi_DSFree(&dStr);\n    Jsi_DecrRefCount(interp, tPtr);\n    return (char*)cp;\n}\n\n\nstatic void fileObjErase(FileObj *fo)\n{\n    if (fo->filename) {\n        Jsi_Close(fo->interp, fo->chan);\n        Jsi_Free(fo->filename);\n        Jsi_DecrRefCount(fo->interp, fo->fname);\n        Jsi_Free(fo->mode);\n    }\n    fo->filename = NULL;\n}\n\nstatic Jsi_RC fileObjFree(Jsi_Interp *interp, void *data)\n{\n    FileObj *fo = (FileObj *)data;\n    SIGASSERT(fo,FILEOBJ);\n    fileObjErase(fo);\n    Jsi_Free(fo);\n    return JSI_OK;\n}\n\nstatic bool fileObjIsTrue(void *data)\n{\n    FileObj *fo = (FileObj *)data;\n    SIGASSERT(fo,FILEOBJ);\n    if (!fo->filename) return JSI_OK;\n    else return 1;\n}\n\nstatic bool fileObjEqual(void *data1, void *data2)\n{\n    return (data1 == data2);\n}\n\nstatic int try_open_file(Jsi_Interp *interp, FileObj *udf, Jsi_Value *args)\n{\n    int ret = JSI_ERROR;\n    fileObjErase(udf);\n    // TODO: stdin, stdout, stderr, etc.\n    Jsi_Value *fname = Jsi_ValueArrayIndex(interp, args, 0);\n    if (fname && Jsi_ValueIsString(interp, fname)) {\n        Jsi_Value *vmode = Jsi_ValueArrayIndex(interp, args, 1);\n        const char *mode = NULL;\n        const char *fstr = Jsi_ValueString(interp, fname, NULL);\n        if (vmode && Jsi_ValueIsString(interp,vmode)) {\n            mode = Jsi_ValueString(interp, vmode, NULL);\n        }\n        int writ = (mode && (Jsi_Strchr(mode,'w')||Jsi_Strchr(mode,'+')));\n        int aflag = (writ ? JSI_INTACCESS_WRITE : JSI_INTACCESS_READ);\n        if (interp->isSafe && Jsi_InterpAccess(interp, fname, aflag) != JSI_OK)\n            return Jsi_LogError(\"Safe open failed\");\n        char *rmode = Jsi_Strdup(mode ? mode : \"r\");\n        Jsi_Channel chan = Jsi_Open(interp, fname, rmode);\n        if (chan) {\n            udf->chan = chan;\n            udf->fname = fname;\n            udf->interp = interp;\n            Jsi_IncrRefCount(interp, fname);\n            udf->filename = Jsi_Strdup(fstr);\n            udf->mode = Jsi_Strdup(rmode);\n            ret = JSI_OK;\n        }\n        Jsi_Free(rmode);\n    }\n    return ret;\n}\n\n#define UdfGet(udf, _this, funcPtr) \\\n   FileObj *udf = (FileObj *)Jsi_UserObjGetData(interp, _this, funcPtr); \\\n    if (!udf) \\\n        return Jsi_LogError(\"Channel.%s called with non-file object\", funcPtr->cmdSpec->name);\n\nstatic Jsi_RC FilesysOpenCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    UdfGet(udf, _this, funcPtr);\n    if (try_open_file(interp, udf, args) != JSI_OK) {\n        Jsi_ValueMakeBool(interp, ret, 0);\n    }\n    Jsi_ValueMakeBool(interp, ret, 1);\n    return JSI_OK;\n}\n\nstatic Jsi_RC FilesysCloseCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    UdfGet(udf, _this, funcPtr);\n    fileObjErase(udf);\n    Jsi_ValueMakeBool(interp, ret, 1);\n    return JSI_OK;\n}\n\nstatic Jsi_RC FilesysGetsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int len;\n    UdfGet(udf, _this, funcPtr);\n    if (!udf->filename) {\n        Jsi_ValueMakeUndef(interp, ret);\n        return JSI_OK;\n    }\n    char buf[JSI_BUFSIZ];\n    if (!Jsi_Gets(interp, udf->chan, buf, sizeof(buf))) {\n        Jsi_ValueMakeUndef(interp, ret);\n        return JSI_OK;\n    }\n    buf[sizeof(buf)-1] = 0;\n    len = Jsi_Strlen(buf);\n    if (len > 0 && buf[len-1] == '\\n')\n        buf[len-1] = 0;\n    Jsi_ValueMakeStringDup(interp, ret, buf);\n    return JSI_OK;\n}\n\n\nstatic Jsi_RC FilesysModeCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    UdfGet(udf, _this, funcPtr);\n    if (udf->mode)\n        Jsi_ValueMakeStringKey(interp, ret, udf->mode);\n    return JSI_OK;\n}\n\nstatic Jsi_RC FilesysFilenameCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    UdfGet(udf, _this, funcPtr);\n    if (udf->filename)\n        Jsi_ValueMakeStringDup(interp, ret, udf->filename);\n    return JSI_OK;\n}\n\nstatic Jsi_RC FilesysReadCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int  sum = 0, n;\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    UdfGet(udf, _this, funcPtr);\n    char buf[JSI_BUFSIZ];\n    int argc = Jsi_ValueGetLength(interp, args);\n    int nsiz = -1, cnt = 0, rsiz;\n    \n    if (!udf->filename) {\n        goto bail;\n    }\n    if (argc>0 && Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, 0), &nsiz) != JSI_OK)\n        goto bail;\n    while (cnt++ < MAX_LOOP_COUNT) {\n        rsiz = sizeof(buf);\n        if (nsiz>0 && ((sum+rsiz)>nsiz))\n            rsiz = (nsiz-sum);\n        if ((n = Jsi_Read(interp, udf->chan, buf, rsiz)) <= 0)\n            break;\n        Jsi_DSAppendLen(&dStr, buf, n);\n        sum += n;\n        if (nsiz>=0 && sum >=nsiz)\n            break;\n    }\n    if (Jsi_DSLength(&dStr)>0)\n        Jsi_ValueMakeDStringObject(interp, ret, &dStr);\n    return JSI_OK;\n    \nbail:\n    Jsi_DSFree(&dStr);\n    Jsi_ValueMakeUndef(interp, ret);\n    return JSI_OK;\n}\n\n\nstatic Jsi_RC FilesysSeekCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    static const char *posStr[] = { \"set\", \"cur\", \"end\", NULL };\n    enum { W_SET, W_CUR, W_END };\n    UdfGet(udf, _this, funcPtr);\n    Jsi_Value *vPos = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_Value *vWhence = Jsi_ValueArrayIndex(interp, args, 1);\n    int mode = 0, p;\n    Jsi_Wide pos;\n    Jsi_Number num;\n    if (Jsi_ValueGetNumber(interp, vPos, &num) != JSI_OK)\n        return JSI_ERROR;\n    if (Jsi_ValueGetIndex(interp, vWhence, posStr, \"position\", 0, &p) != JSI_OK)\n        return JSI_ERROR;\n    switch (p) {\n        case W_SET: mode = SEEK_SET; break;\n        case W_CUR: mode = SEEK_CUR; break;\n        case W_END: mode = SEEK_END; break;\n    }\n    pos = (Jsi_Wide)num;\n    pos = Jsi_Seek(interp, udf->chan, pos, mode);\n    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)pos);\n    return JSI_OK;\n}\n\nstatic Jsi_RC FilesysTruncateCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    UdfGet(udf, _this, funcPtr);\n    Jsi_Value *vPos = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_Number num;\n    if (Jsi_ValueGetNumber(interp, vPos, &num) != JSI_OK)\n        return JSI_ERROR;\n    num = (Jsi_Number)Jsi_Truncate(interp, udf->chan, (unsigned int)num);\n    Jsi_ValueMakeNumber(interp, ret, num);\n    return JSI_OK;\n}\n\nstatic Jsi_RC FilesysStatCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    UdfGet(udf, _this, funcPtr);\n#if JSI__FILESYS==1\n    return jsi_FileStatCmd(interp, udf->fname, _this, ret, funcPtr, 0);\n#else\n    return JSI_ERROR;\n#endif\n}\n\nstatic Jsi_RC FilesysLstatCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    UdfGet(udf, _this, funcPtr);\n#if JSI__FILESYS==1\n    return jsi_FileStatCmd(interp, udf->fname, _this, ret, funcPtr, 1);\n#else\n    return JSI_ERROR;\n#endif\n}\n\nstatic Jsi_RC FilesysTellCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    UdfGet(udf, _this, funcPtr);\n    Jsi_Wide pos = Jsi_Tell(interp, udf->chan);\n    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)pos);\n    return JSI_OK;\n}\n\nstatic Jsi_RC FilesysFlushCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    UdfGet(udf, _this, funcPtr);\n    int pos = Jsi_Flush(interp, udf->chan);\n    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)pos);\n    return JSI_OK;\n}\n\nstatic Jsi_RC FilesysWriteCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int  sum = 0, n, m;\n    UdfGet(udf, _this, funcPtr);\n    char *buf = Jsi_ValueArrayIndexToStr(interp, args, 0, &m);\n\n    if (!udf->filename) {\n        goto bail;\n    }\n    while (m > 0 && sum < MAX_LOOP_COUNT && (n = Jsi_Write(interp, udf->chan, buf, m)) > 0) {\n        /* TODO: limit max size. */\n        sum += n;\n        m -= n;\n    }\nbail:\n    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)sum);\n    return JSI_OK;\n}\n\nstatic Jsi_RC FilesysPutsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n   \n    UdfGet(udf, _this, funcPtr);\n    if (!udf->filename) {\n        Jsi_ValueMakeBool(interp, ret, 0);\n        return JSI_OK;\n    }\n    Jsi_Value *toput = Jsi_ValueArrayIndex(interp, args, 0);\n    if (!toput) {\n        Jsi_ValueMakeBool(interp, ret, 0);\n        return JSI_OK;\n    }\n    const char * cp = Jsi_ValueToString(interp, toput, NULL);\n\n    if (Jsi_Printf(interp, udf->chan, \"%s\\n\", cp?cp:\"\") < 0) {\n        Jsi_ValueMakeBool(interp, ret, 0);\n        return JSI_OK;\n    }\n    Jsi_ValueMakeBool(interp, ret, 1);\n    return JSI_OK;\n}\n\nstatic Jsi_RC FilesysEofCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    UdfGet(udf, _this, funcPtr);\n    Jsi_ValueMakeBool(interp, ret, Jsi_Eof(interp, udf->chan));\n    return JSI_OK;\n}\n\nint Jsi_Printf(Jsi_Interp *interp, Jsi_Channel chan, const char *fmt, ...)\n{\n    va_list va;\n    int n;\n    FILE *fp = (chan && chan->fp ? chan->fp : stdout);\n    va_start(va,fmt);\n    n = vfprintf(fp, fmt, va);\n    va_end(va);\n    return n;\n}\n\nint Jsi_Puts(Jsi_Interp *interp, Jsi_Channel chan, const char *str, int size)\n{\n    int code = 0, len = Jsi_Strlen(str);\n    if (chan->fsPtr==0 || !chan->fsPtr->putsProc) {\n        FILE *fp = (chan && chan->fp ? chan->fp : stdout);\n        code = fputs(str, fp);\n    } else {\n        if (interp && interp->debugOpts.putsCallback && interp->parent) {\n            int code = 0;\n            Jsi_DString jStr={}, kStr={};\n            Jsi_DSPrintf(&kStr, \"[%s, %d]\",\n                Jsi_JSONQuote(interp, str, size, &jStr), (chan->fp == stderr?1:0));\n            if (Jsi_FunctionInvokeJSON(interp->parent, interp->debugOpts.putsCallback, Jsi_DSValue(&kStr), NULL) != JSI_OK)\n                code = 1;\n            Jsi_DSFree(&jStr);\n            Jsi_DSFree(&kStr);\n            return code;\n        } else if (interp && interp->stdoutStr) {\n            Jsi_DString dStr = {};\n            Jsi_DSAppend(&dStr, Jsi_ValueString(interp, interp->stdoutStr, NULL), NULL);\n            Jsi_DSAppend(&dStr, str, NULL);\n            Jsi_ValueFromDS(interp, &dStr, &interp->stdoutStr);\n        } else\n\n            code = chan->fsPtr->putsProc(chan, str);\n    }\n    if (size>=0 && len < size) {\n        Jsi_Puts(interp, chan, \"\\\\0\", -1);\n        Jsi_Puts(interp, chan, str+len+1, size-len-1);\n    }\n    return code;\n}\n\nstatic Jsi_RC FilesysConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr);\n    \n\nstatic Jsi_CmdSpec filesysCmds[] = {\n    { \"Channel\",   FilesysConstructor,1,  2,  \"file:string, mode:string='r'\", .help=\"A file input/output object. The mode string is r or w and an optional +\", .retType=(uint)JSI_TT_USEROBJ, .flags=JSI_CMD_IS_CONSTRUCTOR },\n    { \"close\",  FilesysCloseCmd,   0,  0, \"\", .help=\"Close the file\", .retType=(uint)JSI_TT_BOOLEAN },\n    { \"eof\",    FilesysEofCmd,     0,  0, \"\", .help=\"Return true if read to end-of-file\", .retType=(uint)JSI_TT_BOOLEAN },\n    { \"filename\", FilesysFilenameCmd, 0,  0, \"\", .help=\"Get file name\", .retType=(uint)(uint)JSI_TT_STRING },\n    { \"flush\",  FilesysFlushCmd,   0,  0, \"\", .help=\"Flush file output\", .retType=(uint)JSI_TT_NUMBER },\n    { \"gets\",   FilesysGetsCmd,    0,  0, \"\", .help=\"Get one line of input\", .retType=(uint)JSI_TT_STRING|JSI_TT_VOID },\n    { \"lstat\",  FilesysLstatCmd,   0,  0, \"\", .help=\"Return status for file\", .retType=(uint)JSI_TT_OBJECT },\n    { \"mode\",   FilesysModeCmd,    0,  0, \"\", .help=\"Get file mode used with open\", .retType=(uint)JSI_TT_STRING },\n    { \"open\",   FilesysOpenCmd,    1, -1, \"file:string, mode:string='r'\", .help=\"Open the file (after close)\", .retType=(uint)JSI_TT_BOOLEAN },\n    { \"puts\",   FilesysPutsCmd,    1,  1, \"str\", .help=\"Write one line of output\", .retType=(uint)JSI_TT_BOOLEAN },\n    { \"read\",   FilesysReadCmd,    0,  1, \"size:number=-1\", .help=\"Read some or all of file\", .retType=(uint)JSI_TT_STRING|JSI_TT_VOID },\n    { \"seek\",   FilesysSeekCmd,    2,  2, \"pos:number, whence:string\", .help=\"Seek to position. Return 0 if ok\", .retType=(uint)JSI_TT_NUMBER },\n    { \"stat\",   FilesysStatCmd,    0,  0, \"\", .help=\"Return status for file\", .retType=(uint)JSI_TT_OBJECT },\n    { \"truncate\",FilesysTruncateCmd,    1,  1, \"pos:number\", .help=\"Truncate file\", .retType=(uint)JSI_TT_NUMBER },\n    { \"tell\",   FilesysTellCmd,    0,  0, \"\", .help=\"Return current position\", .retType=(uint)JSI_TT_NUMBER },\n    { \"write\",  FilesysWriteCmd,   1,  1, \"data\", .help=\"Write data to file\", .retType=(uint)JSI_TT_NUMBER },\n    { NULL, 0,0,0,0, .help=\"Commands for accessing Channel objects for file IO\" }\n};\n\n\nstatic Jsi_UserObjReg fileobject = {\n    \"Channel\",\n    filesysCmds,\n    fileObjFree,\n    fileObjIsTrue,\n    fileObjEqual\n};\n\nstatic Jsi_RC FilesysConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Value *that = _this;\n    if (!Jsi_FunctionIsConstructor(funcPtr)) {\n        Jsi_Obj *o = Jsi_ObjNew(interp);\n        Jsi_PrototypeObjSet(interp, \"File\", o);\n        Jsi_ValueMakeObject(interp, ret, o);\n        that = *ret;\n    }\n\n    FileObj *fobj = (FileObj *)Jsi_Calloc(1,sizeof(*fobj));\n    SIGINIT(fobj, FILEOBJ);\n    if (try_open_file(interp, fobj, args) != JSI_OK) { /* Error out on open fail */\n        Jsi_Free(fobj);\n        return JSI_ERROR;\n    }\n    Jsi_Obj *nobj = (Jsi_Obj*)Jsi_ValueGetObj(interp, that);\n    fobj->objId = Jsi_UserObjNew(interp, &fileobject, nobj, fobj);\n    if (fobj->objId<0) {\n        Jsi_Free(fobj); // TODO: finish cleanup\n        return JSI_ERROR;\n    }\n    fobj->fobj = nobj;\n    return JSI_OK;\n}\n\nstatic void SetupStdChan(Jsi_Chan* ch, FILE *fp, Jsi_Filesystem *fsPtr, int flags) {\n    memset(ch, 0, sizeof(*ch));\n    ch->fp = fp;\n    ch->fsPtr = fsPtr;\n    ch->flags = flags|JSI_FS_NOCLOSE;\n}\n\nJsi_Channel Jsi_FSNameToChannel(Jsi_Interp *interp, const char *name)\n{\n    if (Jsi_Strlen(name)==1) {\n        switch (name[0]) {\n            case '0' : return jsiIntData.stdChans;\n            case '1' : return jsiIntData.stdChans+1;\n            case '2' : return jsiIntData.stdChans+2;\n        }\n    }\n    if (!Jsi_Strcmp(name, \"stdin\")) return jsiIntData.stdChans;\n    if (!Jsi_Strcmp(name, \"stdout\")) return jsiIntData.stdChans+1;\n    if (!Jsi_Strcmp(name, \"stderr\")) return jsiIntData.stdChans+2;\n    Jsi_Obj *obj = jsi_UserObjFromName(interp, name);\n    if (!obj)\n        return NULL;\n    Jsi_UserObj *uobj = obj->d.uobj;\n    if (uobj->reg != &fileobject)\n        return NULL;\n    FileObj *fobj = (FileObj *)uobj->data;\n    return fobj->chan;\n}\n\nvoid jsi_FilesysDone(Jsi_Interp *interp)\n{\n    Jsi_UserObjUnregister(interp, &fileobject);\n    Jsi_InitZvfs(interp, 1);\n    while (jsiFSList != NULL) {\n        FSList *fsPtr = jsiFSList;\n        jsiFSList = fsPtr->next;\n        if (fsPtr)\n            Jsi_Free(fsPtr);\n    }\n}\n\nJsi_RC jsi_InitFilesys(Jsi_Interp *interp, int release)\n{\n    if (release) {\n        jsi_FilesysDone(interp);\n        return JSI_OK;\n    }\n    Jsi_DSInit(&jsiIntData.pwdStr);\n    Jsi_Hash *fsys = Jsi_UserObjRegister(interp, &fileobject);\n    if (!fsys)\n        return Jsi_LogBug(\"Can not init file system\");\n    Jsi_CommandCreateSpecs(interp, fileobject.name, filesysCmds, fsys, JSI_CMDSPEC_ISOBJ);\n    if (jsiFSList == NULL) {\n        Jsi_FSRegister(&jsiFilesystem, NULL);\n        SetupStdChan(jsiIntData.stdChans, stdin, &jsiFilesystem, JSI_FS_READONLY);\n        SetupStdChan(jsiIntData.stdChans+1, stdout, &jsiFilesystem, JSI_FS_WRITEONLY);\n        SetupStdChan(jsiIntData.stdChans+2, stderr, &jsiFilesystem, JSI_FS_WRITEONLY);\n    }\n#if JSI__ZVFS==1\n    Jsi_InitZvfs(interp, 0);\n#endif\n#ifndef JSI_OMIT_VFS\n    jsi_InitVfs(interp, 0);\n#endif\n    return JSI_OK;\n}\n\n#endif // JSI_LITE_ONLY\n\n\nconst char *jsi_GetHomeDir(Jsi_Interp *interp) {\n    const char *str = NULL;\n    if (interp->homeDir)\n        return interp->homeDir;\n#ifdef __WIN32\n    str = getenv(\"USERPROFILE\"); /* TODO: windows home dir. */\n#else\n        \n    if ((str = getenv(\"HOME\")) == NULL) {\n        struct passwd pwd, *pw;\n        char buf[JSI_BUFSIZ*3];\n        if (getpwuid_r(getuid(), &pwd, buf, sizeof(buf), &pw) == 0 && pw->pw_dir)        \n            str = pw->pw_dir;\n    }\n#endif\n    if (!str) {\n        Jsi_LogBug(\"no home dir\");\n        str = \"/\";\n    }\n#ifdef JSI_LITE_ONLY\n    return str;\n#else\n    return (interp->homeDir = Jsi_KeyAdd(interp, str));\n#endif\n}\n\n/* TODO: reconcile with NormalizeUnixPath */\nchar* Jsi_NormalPath(Jsi_Interp *interp, const char *path, Jsi_DString *dStr) {\n    char prefix[3] = \"\";\n    char cdbuf[PATH_MAX];\n    Jsi_DSInit(dStr);\n    if (!path || !path[0]) return NULL;\n    if (*path == '/')\n        Jsi_DSAppend(dStr, path, NULL);\n#ifdef __WIN32  /* TODO: add proper handling for windows paths. */\n    else if (*path && path[1] == ':') {\n        Jsi_DSAppend(dStr, path, NULL);\n        return Jsi_DSValue(dStr);\n    }\n#endif\n    else if (path[0] == '~') {\n        Jsi_DSAppend(dStr, jsi_GetHomeDir(interp), (path[1] == '/' ? \"\" : \"/\"), path+1, NULL);\n    } else if (path[0] == '.' && path[1] == 0) {\n        if (jsiIntData.pwd) {\n            Jsi_DSAppend(dStr, jsiIntData.pwd, NULL);\n        } else {\n            Jsi_DSAppend(dStr, getcwd(cdbuf, sizeof(cdbuf)), NULL);\n        }\n    } else {\n        if (jsiIntData.pwd) {\n            Jsi_DSAppend(dStr, jsiIntData.pwd, \"/\", path, NULL);\n        } else {\n            Jsi_DSAppend(dStr, getcwd(cdbuf, sizeof(cdbuf)), \"/\", path, NULL);\n        }\n    }\n    Jsi_DString sStr = {};\n    char *cp = Jsi_DSValue(dStr);\n#ifdef __WIN32\n    if (*cp && cp[1] == ':') {\n        prefix[0] = *cp;\n        prefix[1] = cp[1];\n        prefix[2] = 0;\n        cp += 2;\n    }\n#endif\n    int i=0, n=0, m, nmax, unclean=0, slens[PATH_MAX];\n    char *sp = cp, *ss;\n    char *sptrs[PATH_MAX];\n    while (*cp && n<PATH_MAX) {\n        while (*cp && *cp == '/') {\n            cp++;\n            if (*cp == '/')\n                unclean = 1;\n        }\n        sptrs[n] = cp;\n        if (cp[0] == '.' && (cp[1] == '.' || cp[1] == '/'))\n            unclean = 1;\n        ss = cp++;\n        while (*ss && *ss != '/')\n            ss++;\n        slens[n++] = (ss-cp) + 1;\n        cp = ss;\n    }\n    if (!unclean)\n        return sp;\n    /* Need to remove //, /./, /../ */\n    nmax = n--;\n    while (n>0) {\n        if (slens[n]<=0) {\n            n--;\n            continue;\n        }\n        if (Jsi_Strncmp(sptrs[n],\".\",slens[n])==0)\n            slens[n] = 0;\n        else if (Jsi_Strncmp(ss,\"..\",slens[n])==0) {\n            int cnt = 0;\n            m = n-1;\n            while (m>=0 && cnt<1) {\n                if (slens[m])\n                    cnt++;\n                slens[m] = 0;\n                m--;\n            }\n            if (cnt<1)\n                return sp;  /* Can't fix it */\n        }\n        n--;\n    }\n    /* TODO: prefix for windows. */\n    Jsi_DSAppend(&sStr, prefix, NULL);\n    for (i=0; i<nmax; i++) {\n        if (slens[i]) {\n#ifdef __WIN32\n            Jsi_DSAppend(&sStr, \"/\" /*\"\\\\\"*/, NULL);\n#else\n            Jsi_DSAppend(&sStr, \"/\", NULL);\n#endif\n            Jsi_DSAppendLen(&sStr, sptrs[i], slens[i]);\n        }\n    }\n    Jsi_DSSetLength(dStr, 0);\n    Jsi_DSAppend(dStr, Jsi_DSValue(&sStr), NULL);\n    Jsi_DSFree(&sStr);\n    return Jsi_DSValue(dStr);\n}\n\n#ifdef __WIN32\n#define realpath(R,N) _fullpath(N,R, _MAX_PATH)\n\n/* For ridding backslashes from env vars */\nstatic void DeBackSlashify(char *cp) {\n    char *dp = cp;\n    while (*cp) {\n        if (*cp == '\\\\') {\n            *dp = '/';\n        } else\n            *dp = *cp;\n        cp++; dp++;\n    }\n    *dp = 0;\n}\n\n#else\n\nstatic void NormalizeUnixPath(Jsi_Interp *interp, char *path) {\n    char **argv; int argc, i;\n    if (!Jsi_Strstr(path, \"./\")) return;\n    Jsi_DString dStr = {}, eStr = {};\n    if (path[0] != '/' && Jsi_Strstr(path, \"..\")) {\n        char *npath = Jsi_GetCwd(interp, &eStr);\n        if (npath && Jsi_Strcmp(npath,\"/\")) {\n            Jsi_DSAppend(&eStr, \"/\", path, NULL);\n            path = Jsi_DSValue(&eStr);\n        }\n    }\n    Jsi_DString sStr;\n    Jsi_DSInit(&sStr);\n    Jsi_SplitStr(path, &argc, &argv, \"/\", &sStr);\n    char *cp = path;\n    *cp = 0;\n    for (i=0; i<argc; i++) {\n        if (i == 0 && argv[0][0] == 0) {\n            continue;\n        } else if (argv[i][0] == 0) {\n            continue;\n        } else if (i && !Jsi_Strcmp(argv[i],\".\")) {\n            continue;\n        } else if (!Jsi_Strcmp(argv[i],\"..\")) {\n            char *pcp = Jsi_DSValue(&dStr), *lcp = pcp;\n            pcp = Jsi_Strrchr(pcp, '/');\n            if (pcp && pcp != Jsi_DSValue(&dStr)) {\n                *pcp = 0;\n                Jsi_DSSetLength(&dStr, Jsi_Strlen(lcp));\n            }\n            continue;\n        } else {\n            Jsi_DSAppend(&dStr, (i>0?\"/\":\"\"), argv[i], NULL);\n        }\n    }\n    Jsi_DSFree(&sStr);\n    Jsi_Strcpy(path, Jsi_DSValue(&dStr));\n    Jsi_DSFree(&dStr);\n    Jsi_DSFree(&eStr);\n}\n#endif\n\nchar * Jsi_GetCwd(Jsi_Interp *interp, Jsi_DString *cwdPtr) {\n    char cdbuf[PATH_MAX];\n    Jsi_DSInit(cwdPtr);\n    if (jsiIntData.cwdFsPtr)\n        Jsi_DSAppend(cwdPtr, Jsi_DSValue(&jsiIntData.pwdStr), NULL);\n    else\n        Jsi_DSAppend(cwdPtr, getcwd(cdbuf, sizeof(cdbuf)), NULL);\n#ifdef __WIN32\n    DeBackSlashify(Jsi_DSValue(cwdPtr));\n#endif\n    return Jsi_DSValue(cwdPtr);\n}\n\nchar *Jsi_FileRealpathStr(Jsi_Interp *interp, const char *path, char *newname)\n{\n    if (!path || !path[0]) return NULL;\n    Jsi_DString dStr, eStr;\n    char *npath = (char*)path, *apath;\n    Jsi_DSInit(&dStr); Jsi_DSInit(&eStr);\n    if (*path == '~') {\n#ifndef __WIN32\n        struct passwd pw, *pwp; /* TODO: could fallback to using env HOME. */\n        char buf[JSI_BUFSIZ];\n        int n = getpwuid_r(getuid(), &pw, buf, sizeof(buf), &pwp);\n        const char *homedir = (n == 0 ? pwp->pw_dir : \"\");\n        Jsi_DSAppend(&dStr, homedir, path[1] == '/' ? \"\" : \"/\", path+1, NULL);\n#else\n        const char *homedir = getenv(\"HOMEPATH\");\n        if (!homedir) homedir = \"/\";\n        const char *homedrv = getenv(\"HOMEDRIVE\");\n        if (!homedrv) homedrv = \"\";\n        Jsi_DSAppend(&dStr, homedrv, homedir, path[1] == '/' ? \"\" : \"/\", path+1, NULL);\n#endif\n        npath = Jsi_DSValue(&dStr);\n    }\n#ifdef __WIN32\n    if (Jsi_Strncmp(path, JSI_ZVFS_DIR, sizeof(JSI_ZVFS_DIR)-1)==0 || Jsi_Strncmp(path, JSI_VFS_DIR, sizeof(JSI_VFS_DIR)-1)==0)\n        apath = NULL;\n    else\n#endif\n    apath = realpath(npath, newname);\n    if (!apath) {\n        if ((path[0] == '.' && path[1] == '/') || (path[0] != '/' && \n        !(path[0] == '.' && path[1] == '.') && path[1] != ':')) {\n            Jsi_GetCwd(interp, &eStr);\n            Jsi_DSAppend(&eStr, \"/\", path, NULL);\n            npath = Jsi_DSValue(&eStr);\n            apath = realpath(npath, newname);\n            //npath = (char*)path;\n        }\n    }\n    if (!apath) {\n        if (newname)\n            Jsi_Strcpy(apath=newname, npath);\n        else\n            apath = Jsi_Strdup(npath);\n#ifndef __WIN32\n        /* If path not exists on unix we try to eliminate ../ and /./ etc.*/\n        NormalizeUnixPath(interp, apath);\n#endif\n    }\n#ifdef __WIN32\n    DeBackSlashify(apath);\n#endif\n    Jsi_DSFree(&dStr); Jsi_DSFree(&eStr);\n    return apath;\n}\n\n", "#ifndef JSI_LITE_ONLY\n#ifndef JSI_AMALGAMATION\n#include \"jsiInt.h\"\n#endif\n\n/* Return value from call to function will is not used. */\nbool Jsi_FunctionReturnIgnored(Jsi_Interp *interp, Jsi_Func *funcPtr) {\n    return funcPtr->callflags.bits.isdiscard;\n}\n\nbool Jsi_FunctionIsConstructor(Jsi_Func *funcPtr)\n{\n    return (funcPtr->f.bits.iscons);\n}\n\nJsi_CmdSpec *Jsi_FunctionGetSpecs(Jsi_Func *funcPtr)\n{\n    return funcPtr->cmdSpec;\n}\n\nvoid *Jsi_FunctionPrivData(Jsi_Func *funcPtr)\n{\n    return funcPtr->privData;\n}\n\nconst char *jsi_TypeName(Jsi_Interp *interp, Jsi_ttype otyp)\n{\n    switch (otyp) {\n        case JSI_TT_NUMBER:     return \"number\"; \n        case JSI_TT_STRING:     return \"string\"; \n        case JSI_TT_BOOLEAN:    return \"boolean\"; \n        case JSI_TT_ARRAY:      return \"array\"; \n        case JSI_TT_FUNCTION:   return \"function\"; \n        case JSI_TT_OBJECT:     return \"object\"; \n        case JSI_TT_REGEXP:     return \"regexp\"; \n        case JSI_TT_ANY:        return \"any\"; \n        case JSI_TT_USEROBJ:    return \"userobj\"; \n        case JSI_TT_ITEROBJ:    return \"iterobj\"; \n        case JSI_TT_UNDEFINED:      return \"undefined\";\n        case JSI_TT_VOID:       return \"void\";\n        case JSI_TT_NULL:       return \"null\"; \n    }\n    return \"undefined\";\n}\nconst char *jsi_ObjectTypeName(Jsi_Interp *interp, Jsi_otype otyp)\n{\n    switch (otyp) {\n        case JSI_OT_NUMBER:     return \"number\"; \n        case JSI_OT_STRING:     return \"string\"; \n        case JSI_OT_BOOL:       return \"boolean\"; \n        case JSI_OT_ARRAY:      return \"array\"; \n        case JSI_OT_FUNCTION:   return \"function\"; \n        case JSI_OT_OBJECT:     return \"object\"; \n        case JSI_OT_REGEXP:     return \"regexp\"; \n        case JSI_OT_ITER:       return \"iter\"; \n        case JSI_OT_USEROBJ:    return \"userobj\"; \n        case JSI_OT_UNDEF:      return \"any\";\n    }\n    return \"undefined\";\n}\n\nconst char *jsi_ValueTypeName(Jsi_Interp *interp, Jsi_Value *val)\n{\n    switch (val->vt) {\n        case JSI_VT_NUMBER:     return \"number\"; \n        case JSI_VT_STRING:     return \"string\"; \n        case JSI_VT_BOOL:       return \"boolean\"; \n        case JSI_VT_OBJECT:     if (val->d.obj->ot == JSI_OT_OBJECT && val->d.obj->isarrlist) return \"array\"; return jsi_ObjectTypeName(interp, val->d.obj->ot); \n        case JSI_VT_VARIABLE:   return \"variable\"; \n        case JSI_VT_NULL:       return \"null\"; \n        case JSI_VT_UNDEF:      break;\n    }\n    return \"undefined\";\n}\n\nint jsi_typeGet(Jsi_Interp *interp, const char *tname) {\n    if (!tname)\n        return 0;\n    if (Jsi_Strchr(tname, '|')) {\n        int argc, i, rc, val = 0;\n        char **argv;\n        Jsi_DString dStr;\n        Jsi_DSInit(&dStr);\n        Jsi_SplitStr(tname, &argc, &argv, \"|\", &dStr);\n        for (i=0; i<argc; i++) {\n            rc = jsi_typeGet(interp, argv[i]);\n            if (rc < 0)\n                break;\n            val |= rc;\n        }\n        Jsi_DSFree(&dStr);\n        if (i<argc)\n            return -1;\n        return val;\n    }\n    switch (tname[0]) {\n        case 'b': if (Jsi_Strcmp(tname, \"boolean\")==0) return JSI_TT_BOOLEAN; break;\n        case 's': if (Jsi_Strcmp(tname, \"string\")==0) return JSI_TT_STRING; break;\n        case 'n': if (Jsi_Strcmp(tname, \"null\")==0) return JSI_TT_NULL;\n                  if (Jsi_Strcmp(tname, \"number\")==0) return JSI_TT_NUMBER; break;\n        case 'o': if (Jsi_Strcmp(tname, \"object\")==0) return JSI_TT_OBJECT; break;\n        case 'r': if (Jsi_Strcmp(tname, \"regexp\")==0) return JSI_TT_REGEXP; break;\n        case 'f': if (Jsi_Strcmp(tname, \"function\")==0) return JSI_TT_FUNCTION; break;\n        case 'i': if (Jsi_Strcmp(tname, \"iterobj\")==0) return JSI_TT_ITEROBJ;\n        case 'u': if (Jsi_Strcmp(tname, \"userobj\")==0) return JSI_TT_USEROBJ;\n                  if (Jsi_Strcmp(tname, \"undefined\")==0) return JSI_TT_UNDEFINED; break;\n        case 'a': if (Jsi_Strcmp(tname, \"array\")==0) return JSI_TT_ARRAY;\n                  if (Jsi_Strcmp(tname, \"any\")==0) return JSI_TT_ANY; break;\n        case 'v': if (Jsi_Strcmp(tname, \"void\")==0) return JSI_TT_VOID; break;\n    }\n    Jsi_LogWarn(\"Type \\\"%s\\\" is not one of boolean, string, number, function, array, object, regexp, userobj, null, undefined, void or any\", tname);\n    return 0;\n}\n\nconst char *jsi_typeName(Jsi_Interp *interp, int typ, Jsi_DString *dStr) {\n    if (typ<=0 || (typ&JSI_TT_ANY)) {\n        Jsi_DSAppend(dStr, \"any\", NULL);\n        return Jsi_DSValue(dStr);\n    }\n    int i = 0;\n    if (typ&JSI_TT_NUMBER) Jsi_DSAppend(dStr, (i++?\"|\":\"\"), \"number\", NULL);\n    if (typ&JSI_TT_STRING) Jsi_DSAppend(dStr, (i++?\"|\":\"\"), \"string\", NULL);\n    if (typ&JSI_TT_BOOLEAN)  Jsi_DSAppend(dStr, (i++?\"|\":\"\"), \"boolean\", NULL);\n    if (typ&JSI_TT_ARRAY)   Jsi_DSAppend(dStr, (i++?\"|\":\"\"), \"array\", NULL);\n    if (typ&JSI_TT_FUNCTION) Jsi_DSAppend(dStr, (i++?\"|\":\"\"), \"function\", NULL);\n    if (typ&JSI_TT_OBJECT) Jsi_DSAppend(dStr, (i++?\"|\":\"\"), \"object\", NULL);\n    if (typ&JSI_TT_REGEXP) Jsi_DSAppend(dStr, (i++?\"|\":\"\"), \"regexp\", NULL);\n    if (typ&JSI_TT_USEROBJ) Jsi_DSAppend(dStr, (i++?\"|\":\"\"), \"userobj\", NULL);\n    if (typ&JSI_TT_ITEROBJ) Jsi_DSAppend(dStr, (i++?\"|\":\"\"), \"iterobj\", NULL);\n    if (typ&JSI_TT_NULL) Jsi_DSAppend(dStr, (i++?\"|\":\"\"), \"null\", NULL);\n    if (typ&JSI_TT_UNDEFINED) Jsi_DSAppend(dStr, (i++?\"|\":\"\"), \"undefined\", NULL);\n    if (typ&JSI_TT_VOID) Jsi_DSAppend(dStr, (i++?\"|\":\"\"), \"void\", NULL);\n    return Jsi_DSValue(dStr);\n}\n\nconst char* jsi_FuncGetCode(Jsi_Interp *interp, Jsi_Func *func, int *lenPtr) {\n    if (interp->subOpts.noFuncString || !func->bodyStr)\n        return NULL;\n    const char *cp, *cp2;\n    if (func->startPos == -1) {\n        cp = func->bodyStr;\n        int cplin = func->bodyline.last_line-1;\n        while (*cp && cplin>0) {\n            if (*cp=='\\n' && --cplin<=0)\n                break;\n            cp++;\n        }\n        while (*cp && isspace(*cp))\n            cp++;\n        func->startPos = (*cp?(cp - func->bodyStr):-2);\n    }\n    if (func->startPos >= 0) {\n        int len = func->endPos - func->startPos;\n        cp = func->bodyStr + func->startPos;\n        while (len>0 && (isspace(cp[len-1]) || cp[len-1]==';')) len--;\n        if (*cp != 'f' && Jsi_Strncmp(cp, \"function\", 8) && (cp2=Jsi_Strstr(cp, \"function\"))) {\n            len -= (cp2-cp);\n            cp = cp2;\n        }\n        *lenPtr = len;\n        return cp;\n    }\n    return NULL;\n}\n\nconst char *jsiFuncInfo(Jsi_Interp *interp, Jsi_DString *dStr, Jsi_Func* func, Jsi_Value *arg) {\n    if (!func) return \"\";\n    if (func->name)\n        Jsi_DSPrintf(dStr, \", in call to '%s'\", func->name);\n    else\n        Jsi_DSPrintf(dStr, \", in call to function\");\n    if (func->script) {\n        const char *cp = Jsi_Strrchr(func->script, '/');\n        if (cp)\n            cp++;\n        else\n            cp = func->script;\n        Jsi_DSPrintf(dStr, \" declared at %s:%d.%d\", cp, func->bodyline.first_line, func->bodyline.first_column);\n    }\n        if (arg) {\n        Jsi_DSAppend(dStr, \" <\", NULL);\n        Jsi_ValueGetDString(interp, arg, dStr, 0);\n        Jsi_DSAppend(dStr, \">.\", NULL);\n    }\n    return Jsi_DSValue(dStr);\n}\n\n// Check argument matches type.  If func is null, this is a parse. An index of 0 is the return value.\nJsi_RC jsi_ArgTypeCheck(Jsi_Interp *interp, int typ,  Jsi_Value *arg, const char *p1,\n    const char *p2, int index, Jsi_Func *func, bool isdefault) {\n    Jsi_RC rc = JSI_OK;\n    char idxBuf[JSI_MAX_NUMBER_STRING*2];\n    idxBuf[0] = 0;\n    if (func && arg->vt == JSI_VT_UNDEF && !interp->typeCheck.noundef && index>0 && !isdefault && !(typ&JSI_TT_UNDEFINED)) {\n        snprintf(idxBuf, sizeof(idxBuf), \" arg %d\", index);\n        jsi_TypeMismatch(interp);\n       \n        Jsi_DString fStr = {};\n        rc = Jsi_LogType(\"call with undefined var %s%s '%s'%s\", p1, idxBuf, p2, jsiFuncInfo(interp, &fStr, func, arg));\n        Jsi_DSFree(&fStr);\n        return rc;\n    }\n    if (typ <= 0)\n        return JSI_OK;\n    //if (typ&JSI_TT_VOID)\n    //    return JSI_OK;\n    if (interp->typeCheck.all==0) {\n        if (func ? (interp->typeCheck.run==0) : (interp->typeCheck.parse==0))\n            return JSI_OK;\n    }\n    if (index == 0 && func && func->type == FC_BUILDIN && \n        interp->typeCheck.all == 0) // Normally do not check return types for builtins.\n        return JSI_OK; \n    if ((typ&JSI_TT_ANY)) return JSI_OK;\n    if (index == 0 && arg->vt == JSI_VT_UNDEF) {\n        if (!(typ&JSI_TT_VOID)) \n            goto done;\n        return JSI_OK;\n    }\n    if (isdefault && index && typ&JSI_TT_VOID && arg->vt == JSI_VT_UNDEF)\n        return JSI_OK;\n    if (typ&JSI_TT_UNDEFINED && Jsi_ValueIsUndef(interp, arg)) return rc;\n    if (typ&JSI_TT_NUMBER && Jsi_ValueIsNumber(interp, arg)) return rc;\n    if (typ&JSI_TT_STRING && Jsi_ValueIsString(interp, arg)) return rc;\n    if (typ&JSI_TT_BOOLEAN && Jsi_ValueIsBoolean(interp, arg))  return rc;\n    if (typ&JSI_TT_ARRAY && Jsi_ValueIsArray(interp, arg))   return rc;\n    if (typ&JSI_TT_FUNCTION && Jsi_ValueIsFunction(interp, arg)) return rc;\n    if (typ&JSI_TT_REGEXP && Jsi_ValueIsObjType(interp, arg, JSI_OT_REGEXP)) return rc;\n    if (typ&JSI_TT_USEROBJ && Jsi_ValueIsObjType(interp, arg, JSI_OT_USEROBJ)) return rc;\n    if (typ&JSI_TT_ITEROBJ && Jsi_ValueIsObjType(interp, arg, JSI_OT_ITER)) return rc;\n    if (typ&JSI_TT_OBJECT && (\n        Jsi_ValueIsObjType(interp, arg, JSI_OT_OBJECT) && Jsi_ValueIsArray(interp, arg)==0))\n        return rc;\n    if (typ&JSI_TT_NULL && Jsi_ValueIsNull(interp, arg)) return rc;\ndone:\n    {\n        Jsi_DString dStr = {};\n        const char *exp = jsi_typeName(interp, typ, &dStr);\n        const char *vtyp = jsi_ValueTypeName(interp, arg);\n        if (index>0)\n            snprintf(idxBuf, sizeof(idxBuf), \" arg %d\", index);\n        if (interp->typeCheck.error)\n            rc = JSI_ERROR;\n        jsi_TypeMismatch(interp);\n        Jsi_DString fStr = {};\n        rc = Jsi_LogType(\"type mismatch %s%s '%s': expected \\\"%s\\\" but got \\\"%s\\\"%s\",\n            p1, idxBuf, p2, exp, vtyp, jsiFuncInfo(interp, &fStr, func, arg));\n        Jsi_DSFree(&fStr);\n        Jsi_DSFree(&dStr);\n    }\n    return rc;\n}\n\nJsi_RC jsi_StaticArgTypeCheck(Jsi_Interp *interp, int atyp, const char *p1, const char *p2, int index, Jsi_Func *func, jsi_Pline *line) {\n    Assert(index>0);\n    Jsi_RC rc;\n    if (interp->typeCheck.parse==0 && interp->typeCheck.all==0)\n        return JSI_OK;\n    int ai = index-1+func->callflags.bits.addargs;\n    if (func->argnames == NULL || ai>=func->argnames->count || ai<0)\n        return JSI_OK;\n    int typ = func->argnames->args[ai].type;\n    if (typ <= 0)\n        return JSI_OK;\n    if (index == 0 && func && func->type == FC_BUILDIN && \n        interp->typeCheck.all==0) // Normally do not check return types for builtins.\n        return JSI_OK; \n    if ((typ&JSI_TT_ANY)) return JSI_OK;\n    if (index == 0 && atyp == JSI_VT_UNDEF) {\n        if (!(typ&JSI_TT_VOID)) \n            goto done;\n        return JSI_OK;\n    }\n/*    if (index == 0 && (typ&JSI_TT_VOID)) {\n        if (atyp != JSI_VT_UNDEF && !(typ&JSI_TT_UNDEFINED))\n            goto done;\n        return JSI_OK;\n    }*/\n    if (atyp == JSI_VT_UNDEF)\n        return JSI_OK;\n    rc = JSI_OK;\n    if (typ&JSI_TT_UNDEFINED && atyp == JSI_TT_UNDEFINED) return rc;\n    if (typ&JSI_TT_NUMBER && atyp==JSI_TT_NUMBER) return rc;\n    if (typ&JSI_TT_STRING && atyp==JSI_TT_STRING) return rc;\n    if (typ&JSI_TT_BOOLEAN && atyp==JSI_TT_BOOLEAN)  return rc;\n    if (typ&JSI_TT_ARRAY && atyp==JSI_TT_ARRAY)   return rc;\n    if (typ&JSI_TT_FUNCTION && atyp==JSI_TT_FUNCTION) return rc;\n    if (typ&JSI_TT_REGEXP && atyp==JSI_TT_REGEXP) return rc;\n    if (typ&JSI_TT_USEROBJ && atyp==JSI_TT_USEROBJ) return rc;\n    if (typ&JSI_TT_ITEROBJ && atyp==JSI_TT_ITEROBJ) return rc;\n    if (typ&JSI_TT_OBJECT && atyp==JSI_TT_OBJECT) return rc;\n    if (typ&JSI_TT_NULL && atyp==JSI_TT_NULL) return rc;\ndone:\n    {\n        Jsi_DString dStr = {};\n        const char *exp = jsi_typeName(interp, typ, &dStr);\n        const char *vtyp = jsi_TypeName(interp, (Jsi_ttype)atyp);\n        char idxBuf[JSI_MAX_NUMBER_STRING*2];\n        idxBuf[0] = 0;\n        if (index>0)\n            snprintf(idxBuf, sizeof(idxBuf), \" arg %d\", index);\n        if (line)\n            interp->parseLine = line;\n        if (interp->typeCheck.error)\n            rc = JSI_ERROR;\n        jsi_TypeMismatch(interp);\n        Jsi_DString fStr = {};\n        rc = Jsi_LogType(\"type mismatch %s%s '%s': expected \\\"%s\\\" but got \\\"%s\\\"%s\",\n            p1, idxBuf, p2, exp, vtyp, jsiFuncInfo(interp, &fStr, func, NULL));\n        Jsi_DSFree(&fStr);\n        Jsi_DSFree(&dStr);\n    }\n    return rc;\n}\n\nint jsiPopArgs(Jsi_OpCodes *argCodes, int i)\n{\n    int m=i-1, n = (uintptr_t)argCodes->codes[i].data, cnt = 0;\n    if (argCodes->codes[i].op == OP_OBJECT)\n        n *= 2;\n    for (; m>=0 && cnt<n; m--, cnt++) {\n        int op = argCodes->codes[m].op;\n        if (op == OP_ARRAY || op == OP_OBJECT)\n            m = jsiPopArgs(argCodes, m);\n    }\n    return m+1;\n}\n\nJsi_RC jsi_RunFuncCallCheck(Jsi_Interp *interp, Jsi_Func *func, int argc, const char *name, jsi_Pline *line, Jsi_OpCodes *argCodes, bool isParse)\n{\n    Jsi_RC rc = JSI_OK;\n    if (interp->typeCheck.all==0) {\n        if (!argCodes ? (interp->typeCheck.run==0) : (interp->typeCheck.parse==0))\n            return JSI_OK;\n    }\n\n    Jsi_CmdSpec *spec = func->cmdSpec;\n    Jsi_ScopeStrs *ss = func->argnames;\n    if (ss==NULL && spec == NULL)\n        return JSI_OK;\n    int i, minArgs, maxArgs, mis = 0, varargs = 0;\n    char nbuf[JSI_MAX_NUMBER_STRING];\n    if (func->type == FC_BUILDIN) {\n        varargs =  (spec->maxArgs<0);\n        maxArgs = spec->maxArgs + func->callflags.bits.addargs;\n        minArgs = spec->minArgs + func->callflags.bits.addargs;\n    } else {\n        varargs = ss->varargs;\n        minArgs = (ss->firstDef>0 ? ss->firstDef-1 : ss->count);\n        maxArgs = ss->count;\n        mis = (argc != ss->count);\n        if (func->retType == 0 && ss && ss->typeCnt == 0 && interp->typeCheck.all==0)\n            return JSI_OK;\n    }\n    if (varargs) {\n        if (argc >= minArgs)\n            return JSI_OK;\n        mis = (argc<minArgs);\n    } else \n        mis = (argc<minArgs || argc>maxArgs);\n    if (mis) {\n        if (varargs)\n            snprintf(nbuf, sizeof(nbuf), \"%d or more\", minArgs);\n        else if (maxArgs > minArgs)\n            snprintf(nbuf, sizeof(nbuf), \"%d-%d\", minArgs, maxArgs);\n        else\n            snprintf(nbuf, sizeof(nbuf), \"%d\", maxArgs);\n        if (line)\n            interp->parseLine = line;\n        if (interp->typeCheck.error)\n            rc = JSI_ERROR;\n        Jsi_DString dStr = {};\n        Jsi_FuncObjToString(interp, func, &dStr, 2);\n        if (isParse)\n            Jsi_LogWarn(\"got %d args, expected %s, calling %s\", argc, nbuf, Jsi_DSValue(&dStr));\n        else\n            rc = Jsi_LogType(\"got %d args, expected %s, calling %s\", argc, nbuf, Jsi_DSValue(&dStr));\n        jsi_TypeMismatch(interp);\n        Jsi_DSFree(&dStr);\n        if (line)\n            interp->parseLine = NULL;\n        return rc;\n    }\n    if (argCodes && argCodes->code_len>=argc) {\n        int cl = argCodes->code_len;\n        int aind=argc-1;\n        for (i=cl-1; rc == JSI_OK && i>=0 && aind>=0; i--,aind--) {\n            Jsi_ttype atyp = JSI_TT_ANY;\n            switch (argCodes->codes[i].op) {\n                case OP_PUSHSTR: atyp=JSI_TT_STRING; break;\n                case OP_PUSHNUM: atyp=JSI_TT_NUMBER; break;\n                case OP_PUSHBOO: atyp=JSI_TT_BOOLEAN; break;\n                case OP_PUSHFUN: atyp=JSI_TT_FUNCTION; break;\n                case OP_PUSHTHS: atyp=JSI_TT_OBJECT; break;\n                case OP_PUSHREG: atyp=JSI_TT_REGEXP; break;\n                case OP_PUSHUND: atyp=JSI_TT_VOID; break;\n                case OP_PUSHNULL: atyp=JSI_TT_NULL; break;\n                case OP_PUSHARG: atyp=JSI_TT_ARRAY; break;\n                case OP_SUBSCRIPT: i++; break;\n                case OP_ARRAY: atyp=JSI_TT_ARRAY; i=jsiPopArgs(argCodes, i); break;\n                case OP_OBJECT: atyp=JSI_TT_OBJECT; i=jsiPopArgs(argCodes, i); break;\n                default: break;\n            }\n            if (atyp == JSI_TT_ANY) continue;\n            rc = jsi_StaticArgTypeCheck(interp, atyp, \"for argument\", name, aind+1, func, line);  \n        }\n    }\n    return rc;\n}\n\nint jsi_BuiltinCmd(Jsi_Interp *interp, const char *name)\n{\n    Jsi_Value *val = Jsi_NameLookup(interp, name);\n    if (!name)\n        return 0;\n    if (!Jsi_ValueIsFunction(interp, val))\n        return 0;\n    Jsi_Func *f = val->d.obj->d.fobj->func;\n    return (f->type == FC_BUILDIN);\n}\n\n// Parse time function call checker.\nvoid jsi_FuncCallCheck(jsi_Pstate *p, jsi_Pline *line, int argc, bool isNew, const char *name, const char *namePre, Jsi_OpCodes *argCodes)\n{\n    Jsi_Interp *interp = p->interp;\n    if (name == NULL || !(interp->typeCheck.funcsig|interp->typeCheck.all|interp->typeCheck.parse))\n        return;\n    if (name && isdigit(name[0]))\n        return;\n    Jsi_Value *val;\n    val = Jsi_NameLookup2(interp, name, namePre);\n    Jsi_Func *f = NULL;\n    if (val != NULL) {\n        if (Jsi_ValueIsFunction(interp, val))\n            f = val->d.obj->d.fobj->func;\n    } else if (interp->staticFuncsTbl) {\n        f = (Jsi_Func*)Jsi_HashGet(interp->staticFuncsTbl, (void*)name, 0);\n    }\n    if (f)\n        jsi_RunFuncCallCheck(interp, f, argc, name, line, argCodes, 1);\n    else if (interp->typeCheck.funcsig && (namePre==NULL || jsi_BuiltinCmd(interp, namePre))) {\n        if (line)\n            interp->parseLine = line;\n        Jsi_LogWarn(\"called function '%s' with no previous definition\", name);\n        jsi_TypeMismatch(interp);\n        if (line)\n            interp->parseLine = NULL;\n    }\n}\n\nint jsi_FuncSigsMatch(jsi_Pstate *pstate, Jsi_Func *f1, Jsi_Func *f2)\n{\n    // Skip where both functions have no types.\n    if (f1->retType==0 && f1->argnames->typeCnt==0 && f1->argnames->varargs==0 &&\n        f2->retType==0 && f2->argnames->typeCnt==0 && f2->argnames->varargs==0 &&\n        pstate->interp->typeCheck.all==0)\n        return 1;\n    if (f1->retType != f2->retType)\n        return 0;\n    if (f1->argnames->count != f2->argnames->count)\n        return 0;\n    if (f1->argnames->typeCnt != f2->argnames->typeCnt)\n        return 0;\n    if (f1->argnames->varargs != f2->argnames->varargs)\n        return 0;\n    int i;\n    for (i=0; i<f1->argnames->count; i++) {\n        Jsi_ScopeStrs *a1 = f1->argnames, *a2 = f2->argnames;\n        if (a1->args[i].type != a2->args[i].type)\n            return 0;\n        Jsi_Value *v1, *v2;\n        v1 = a1->args[i].defValue;\n        v2 = a2->args[i].defValue;\n        if (v1==NULL && v2 == NULL)\n            continue;\n        if (v1==NULL || v2 == NULL)\n            return 0;\n        if (v1->vt != v2->vt)\n            return 0;\n        if (Jsi_ValueCmp(pstate->interp, v1, v2, 0))\n            return 0;\n    }\n    return 1;\n}\n\n// Return directive from first instruction.\nconst char* jsi_GetDirective(Jsi_Interp *interp, Jsi_OpCodes *ops, const char *str) {\n    if (!ops) return NULL;\n    if (!ops->code_len) return NULL;\n    if (ops->codes[0].op != OP_PUSHSTR || !ops->codes[0].data) return NULL;\n    if (Jsi_Strncmp((char*)ops->codes[0].data, str, Jsi_Strlen(str))) return NULL;\n    return (char*)ops->codes[0].data;\n}\n\n/* TODO: if not in a file (an eval) save copy of body string from pstate->lexer??? */\nJsi_Func *jsi_FuncMake(jsi_Pstate *pstate, Jsi_ScopeStrs *args, Jsi_OpCodes *ops, jsi_Pline* line, const char *name, int isArrow)\n{\n    Jsi_Interp *interp = pstate->interp;\n    Jsi_ScopeStrs *localvar = jsi_ScopeGetVarlist(pstate);\n    Jsi_Func *f = jsi_FuncNew(interp);\n    jsi_Lexer *l = pstate->lexer;\n    if (isArrow)\n        f->isArrow = isArrow;\n    f->type = FC_NORMAL;\n    f->opcodes = ops;\n    f->argnames = args;\n    f->localnames = localvar;\n    f->script = interp->curFile;\n    f->bodyline = *line;\n    f->retType = (Jsi_otype)args->retType;\n    if (!pstate->eval_flag) {\n        f->scriptFile = f->script;\n    }\n    if (l->ltype == LT_STRING)\n        f->bodyStr = l->d.str;\n    f->endPos = l->cur;\n    f->startPos = -1; // Have to get these from newline count.\n    if (f->retType & JSI_TT_UNDEFINED)\n        Jsi_LogWarn(\"illegal use of 'undefined' in a return type: %s\", name?name:\"\");\n    \n    //f->strict = (jsi_GetDirective(interp, ops, \"use strict\") != NULL);\n    pstate->argType = 0;\n    if (localvar && args && (interp->strict)) {\n        int i, j;\n        for (i=0; i<args->count; i++) {\n            for (j=0; j<args->count; j++) {\n                if (i != j && !Jsi_Strcmp(args->args[i].name, args->args[j].name)) {\n                        if (line)\n                            interp->parseLine = line;\n                        Jsi_LogWarn(\"function %s():  duplicate parameter name '%s'\", name?name:\"\", args->args[i].name);\n                        if (line)\n                            interp->parseLine = NULL;\n                        jsi_TypeMismatch(interp);\n                        if (interp->typeCheck.error)\n                            pstate->err_count++;\n                }\n            }\n            for (j=0; j<localvar->count; j++) {\n                if (!Jsi_Strcmp(localvar->args[j].name, args->args[i].name)) {\n                        if (line)\n                            interp->parseLine = line;\n                        Jsi_LogWarn(\"function %s():  parameter name conflicts with 'var %s'\", name?name:\"\", localvar->args[j].name);\n                        if (line)\n                            interp->parseLine = NULL;\n                        jsi_TypeMismatch(interp);\n                        if (interp->typeCheck.error)\n                            pstate->err_count++;\n                }\n            }\n        }\n    }\n    if (name) {\n        f->name = Jsi_KeyAdd(interp, name);\n        if ((interp->typeCheck.run|interp->typeCheck.parse|interp->typeCheck.all|interp->typeCheck.funcsig)) {\n            \n            if (f->retType && !(f->retType&JSI_TT_VOID) && ops && ops->code_len && ops->codes[ops->code_len-1].op != OP_RET) {\n                if (line)\n                    interp->parseLine = line;\n                Jsi_LogWarn(\"missing return at end of function '%s'\", name);\n                if (line)\n                    interp->parseLine = NULL;\n                //if (interp->typeCheck.error)\n                 //   pstate->err_count++;\n            }\n             \n            if (interp->staticFuncsTbl) {\n                Jsi_Func *fo = (Jsi_Func*)Jsi_HashGet(interp->staticFuncsTbl, (void*)name, 0);\n                \n                // Forward declaration signature compare (indicated by an empty body).\n                if (interp->typeCheck.funcsig && fo && fo->opcodes && fo->opcodes->code_len == 1 && fo->opcodes->codes->op == OP_NOP) {\n                    if (!jsi_FuncSigsMatch(pstate, f, fo)) {\n                        if (line)\n                            interp->parseLine = line;\n                        Jsi_LogWarn(\"possible signature mismatch for function '%s' at %.120s:%d\", name, fo->script, fo->bodyline.first_line);\n                        if (line)\n                            interp->parseLine = NULL;\n                        jsi_TypeMismatch(interp);\n                    }\n                    //printf(\"OLD: %s\\n\", name);\n                }\n                Jsi_HashSet(interp->staticFuncsTbl, name, f);\n            }\n        }\n    }\n    return f;\n}\n\nJsi_RC Jsi_FunctionArguments(Jsi_Interp *interp, Jsi_Value *func, int *argcPtr)\n{\n    Jsi_FuncObj *funcPtr;\n    Jsi_Func *f;\n    if (!Jsi_ValueIsFunction(interp, func))\n        return JSI_ERROR;\n    funcPtr = func->d.obj->d.fobj;\n    f = funcPtr->func;\n    SIGASSERT(f, FUNC);\n    *argcPtr = f->argnames->count;\n    return JSI_OK;\n}\n\nbool jsi_FuncIsNoop(Jsi_Interp* interp, Jsi_Value *func) {\n    Jsi_FuncObj *funcPtr;\n    Jsi_Func *f;\n    if (func->vt != JSI_VT_OBJECT || func->d.obj->ot != JSI_OT_FUNCTION)\n        return 0;\n    funcPtr = func->d.obj->d.fobj;\n    f = funcPtr->func;\n    return (f->callback == jsi_NoOpCmd);\n}\n\nvoid jsi_InitLocalVar(Jsi_Interp *interp, Jsi_Value *arguments, Jsi_Func *who)\n{\n    SIGASSERTV(who, FUNC);\n    if (who->localnames) {\n        int i;\n        for (i = 0; i < who->localnames->count; ++i) {\n            const char *argkey = jsi_ScopeStrsGet(who->localnames, i);\n            if (argkey) {\n                DECL_VALINIT(key);// = VALINIT;\n                Jsi_Value *v __attribute__((unused));\n                Jsi_Value *kPtr = &key; // Note: a string key so no reset needed.\n                Jsi_ValueMakeStringKey(interp, &kPtr, argkey);\n                v = jsi_ValueObjKeyAssign(interp, arguments, kPtr, NULL, JSI_OM_DONTENUM);\n                jsi_ValueDebugLabel(v, \"locals\", who->name);\n            }\n        }\n    }\n}\n\nJsi_RC jsi_FuncArgsToString(Jsi_Interp *interp, Jsi_Func *f, Jsi_DString *dStr, int withTypes)\n{\n    if (f->type == FC_NORMAL) {\n        int i;\n        for (i = 0; i < f->argnames->count; ++i) {\n            jsi_ArgValue *av = f->argnames->args+i;\n            if (i) Jsi_DSAppend(dStr, \", \", NULL);\n            Jsi_DSAppend(dStr,  jsi_ScopeStrsGet(f->argnames, i), NULL);\n            if (withTypes && av) {\n                Jsi_DString tStr = {};\n                int atyp = av->type;\n                if (av->defValue)\n                    atyp &= ~(av->defValue->vt==JSI_VT_NULL?JSI_TT_NULL:(1<<av->defValue->vt));\n                if (atyp) {\n                    Jsi_DSAppend(dStr, \":\", jsi_typeName(interp, atyp, &tStr), NULL);\n                }\n                Jsi_DSSetLength(&tStr, 0);\n                if (av->defValue)\n                    Jsi_DSAppend(dStr, \"=\", Jsi_ValueGetDString(interp, av->defValue, &tStr, 1), NULL);\n                Jsi_DSFree(&tStr);\n            }\n        }\n    } else if (f->cmdSpec && f->cmdSpec->argStr)\n        Jsi_DSAppend(dStr, f->cmdSpec->argStr, NULL);\n    return JSI_OK;\n}\n\nJsi_RC Jsi_FuncObjToString(Jsi_Interp *interp, Jsi_Func *f, Jsi_DString *dStr, int flags)\n{\n    int withBody = flags&1;\n    int withTypes = flags&2;\n    int withJSON = flags&4;\n    int withFull = (flags&8 && !withJSON);\n    if (withFull && f->type == FC_NORMAL && f->opcodes) {\n        int len;\n        const char *cp = jsi_FuncGetCode(interp, f, &len);\n        if (cp) {\n            Jsi_DSAppendLen(dStr,cp, len);\n            return JSI_OK;\n        }\n    }\n    Jsi_CmdSpec *spec = f->cmdSpec;\n    if (withJSON)\n        Jsi_DSAppend(dStr, \"\\\"\", NULL);\n    if (f->type == FC_NORMAL) {\n        Jsi_DSAppend(dStr, \"function \", f->name?f->name:\"\", \"(\", NULL);\n        jsi_FuncArgsToString(interp, f, dStr, withTypes);\n        Jsi_DSAppend(dStr, \")\", NULL);\n        if (withTypes && f->retType) {\n            Jsi_DString tStr;\n            Jsi_DSInit(&tStr);\n            Jsi_DSAppend(dStr, \":\", jsi_typeName(interp, f->retType, &tStr), NULL);\n            Jsi_DSFree(&tStr);\n        }\n        if (withBody)\n            Jsi_DSAppend(dStr, \" {...}\", NULL);\n    } else {\n        Jsi_DSAppend(dStr, \"function \", f->name?f->name:\"\", \"(\",\n            (spec&&spec->argStr)?spec->argStr:\"\", \")\", NULL);\n        if (withBody)\n            Jsi_DSAppend(dStr, \" { [native code] }\", NULL);\n    }\n    if (withJSON)\n        Jsi_DSAppend(dStr, \"\\\"\", NULL);\n    return JSI_OK;\n}\n\nJsi_Value *jsi_MakeFuncValue(Jsi_Interp *interp, Jsi_CmdProc *callback, const char *name, Jsi_Value** toVal, Jsi_CmdSpec *cspec)\n{\n    Jsi_Obj *o = Jsi_ObjNew(interp);\n    Jsi_Func *f = jsi_FuncNew(interp);\n    Jsi_ObjIncrRefCount(interp, o);\n    o->ot = JSI_OT_FUNCTION;\n    f->type = FC_BUILDIN;\n    f->callback = callback;\n    f->privData = NULL;\n    o->d.fobj = jsi_FuncObjNew(interp, f);\n    f->cmdSpec = cspec;\n    if (!cspec) {\n        f->cmdSpec = (Jsi_CmdSpec*)Jsi_Calloc(2,sizeof(Jsi_CmdSpec));\n        f->cmdSpec->reserved[3] = (void*)0x1;\n        f->cmdSpec->maxArgs = -1;\n        if (name)\n            f->cmdSpec->name = (char*)Jsi_KeyAdd(interp, name);\n    }\n    f->script = interp->curFile;\n    f->callback = callback;\n    return Jsi_ValueMakeObject(interp, toVal, o);\n}\n\nJsi_Value *jsi_MakeFuncValueSpec(Jsi_Interp *interp, Jsi_CmdSpec *cmdSpec, void *privData)\n{\n    Jsi_Obj *o = Jsi_ObjNew(interp);\n    Jsi_Func *f = jsi_FuncNew(interp);\n    o->ot = JSI_OT_FUNCTION;\n    f->type = FC_BUILDIN;\n    f->cmdSpec = cmdSpec;\n    f->callback = cmdSpec->proc;\n    f->privData = privData;\n    f->f.flags = (cmdSpec->flags & JSI_CMD_MASK);\n    f->script = interp->curFile;\n    o->d.fobj = jsi_FuncObjNew(interp, f);\n    return Jsi_ValueMakeObject(interp, NULL, o);\n}\n\n\n/* Call a function with args: args and/or ret can be NULL. */\nstatic Jsi_RC jsi_FunctionInvoke(Jsi_Interp *interp, Jsi_Value *tocall, Jsi_Value *args, Jsi_Value **ret, Jsi_Value *_this)\n{\n    if (interp->maxDepth>0 && interp->maxDepth && interp->callDepth>=interp->maxDepth)\n        return Jsi_LogError(\"max call depth exceeded\");\n    if (interp->deleting)\n        return JSI_ERROR;\n    if (!Jsi_ValueIsFunction(interp, tocall)) \n        return Jsi_LogError(\"can not execute expression, expression is not a function\");\n    if (!tocall->d.obj->d.fobj) {   /* empty function */\n        return JSI_OK;\n    }\n    if (!ret) {\n        if (!interp->nullFuncRet) {\n            interp->nullFuncRet = Jsi_ValueNew(interp);\n            Jsi_IncrRefCount(interp, interp->nullFuncRet);\n        }\n        ret = &interp->nullFuncRet;\n        Jsi_ValueMakeUndef(interp, ret);\n    }\n    if (!args) {\n        if (!interp->nullFuncArg) {\n            interp->nullFuncArg = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, NULL, 0, 0));\n            Jsi_IncrRefCount(interp, interp->nullFuncArg);\n        }\n        args = interp->nullFuncArg;\n    }\n    /* func to call */\n    Jsi_Func *funcPtr = tocall->d.obj->d.fobj->func;\n    SIGASSERT(funcPtr, FUNC);\n    \n    /* prepare args */\n    if (args->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, args->d.obj)) \n        return Jsi_LogError(\"argument must be an array\");\n    /* new this */\n    Jsi_Value *fthis = Jsi_ValueDup(interp, _this ? _this : tocall);\n    Jsi_Func *prevActive = interp->activeFunc;\n    Jsi_RC res = jsi_SharedArgs(interp, args, funcPtr, 1);\n    bool isalloc = 0;\n    int calltrc = 0;\n    int tc = interp->traceCall | (funcPtr->pkg?funcPtr->pkg->popts.modConf.traceCall:0);\n    interp->callDepth++;\n    if (res == JSI_OK) {\n        jsi_InitLocalVar(interp, args, funcPtr);\n        jsi_SetCallee(interp, args, tocall);\n        isalloc = 1;\n        Jsi_IncrRefCount(interp, args);\n        if (funcPtr->type == FC_NORMAL) {\n            if ((tc&jsi_callTraceFuncs) && funcPtr->name)\n                calltrc = 1;\n        } else {\n            if ((tc&jsi_callTraceCmds) && funcPtr->name)\n                calltrc = 1;\n        }\n        interp->activeFunc = funcPtr;\n        if (funcPtr->type == FC_NORMAL) {\n            if (calltrc)\n                jsi_TraceFuncCall(interp, funcPtr, NULL, fthis, args, NULL, tc);\n            res = jsi_evalcode(interp->ps, funcPtr, funcPtr->opcodes, tocall->d.obj->d.fobj->scope, \n                args, fthis, ret);\n        } else {\n            if (calltrc)\n                jsi_TraceFuncCall(interp, funcPtr, NULL, fthis, args, NULL, tc);\n            res = funcPtr->callback(interp, args, fthis, ret, funcPtr);\n        }\n        funcPtr->callCnt++;\n    }\n    interp->callDepth--;\n    if (res == JSI_OK && funcPtr->retType)\n        res = jsi_ArgTypeCheck(interp, funcPtr->retType, *ret, \"returned from\", funcPtr->name, 0, funcPtr, 0);\n    if (calltrc && (tc&jsi_callTraceReturn))\n        jsi_TraceFuncCall(interp, funcPtr, NULL, fthis, NULL, *ret, tc);\n    interp->activeFunc = prevActive;\n    jsi_SharedArgs(interp, args, funcPtr, 0);\n    if (isalloc) \n        Jsi_DecrRefCount(interp, args);\n    Jsi_DecrRefCount(interp, fthis);\n    return res;\n}\n\nJsi_RC Jsi_FunctionInvoke(Jsi_Interp *interp, Jsi_Value *func, Jsi_Value *args, Jsi_Value **ret, Jsi_Value *_this)\n{\n    // Arrange for error reporting to point to called function.\n    Jsi_Func *fstatic = func->d.obj->d.fobj->func;\n    jsi_OpCode *oldops = interp->curIp;\n    if (fstatic->opcodes)\n        interp->curIp = fstatic->opcodes->codes;\n    Jsi_RC rc = jsi_FunctionInvoke(interp, func, args, ret, _this);\n    interp->curIp = oldops;\n    if (Jsi_InterpGone(interp))\n        return JSI_ERROR;\n    return rc;\n}\n\n// Do typechecking for callback using argStr from .data in builtin Jsi_Options: may not use = or ...\nbool jsi_FuncArgCheck(Jsi_Interp *interp, Jsi_Func *f, const char *argStr)\n{\n    int i, atyp, ftyp, rc = 0, acnt;\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    int argc = 0;\n    char **argv, *sname, *stype, *cp;\n    if (!argStr)\n        goto done;\n    if (f->type == FC_BUILDIN) {\n        // Check builtin cmd\n        jsi_CommandArgCheck(interp, f->cmdSpec, f, f->parentName);\n        goto done;\n    }\n    if ((cp=Jsi_Strchr(argStr, '='))) {\n        Jsi_LogWarn(\"may not have default value in option, expected: %s\", argStr);\n        goto done;\n    }\n    if (Jsi_Strstr(argStr, \"...\")) {\n        Jsi_LogWarn(\"may not have ... in args, expected: %s\", argStr);\n        goto done;\n    }\n    if (argStr[0]) {\n        Jsi_SplitStr(argStr, &argc, &argv, \",\", &dStr);\n        if (argc<=0)\n            goto done;\n    }\n    if (!f->argnames) {\n        if (argStr[0])\n            Jsi_LogWarn(\"function has no args, expected: %s\", argStr);\n        else\n            rc = 1;\n        goto done;\n    } else {\n        if (f->argnames->varargs) { // TODO: could allow varargs...\n            if (argc < f->argnames->argCnt) {\n                Jsi_LogWarn(\"vararg argument mismatch, expected: %s\", argStr);\n                goto done;\n            }\n        }\n        else if (f->argnames->argCnt != argc) {\n            if (argc)\n                Jsi_LogWarn(\"argument mismatch, expected: %s\", argStr);\n            else\n                Jsi_LogWarn(\"function should have no arguments\");\n            goto done;\n        }\n\n    }\n    acnt = f->argnames->argCnt;\n    for (i=0; i<argc && i<acnt; i++) {\n        sname = argv[i];\n        stype = NULL;\n        while (sname && *sname && isspace(*sname)) { sname++; }\n        if ((cp=Jsi_Strchr(sname, ':')))\n        {\n            stype = cp+1;\n            *cp = 0;\n            while (*stype && isspace(*stype)) { stype++; }\n            if (*stype) {\n                cp = stype+Jsi_Strlen(stype)-1;\n                while (cp>=stype && isspace(*cp)) { *cp = 0; cp--; }\n            }\n        }\n        if (sname && *sname) {\n            cp = sname+Jsi_Strlen(sname)-1;\n            while (cp>=sname && isspace(*cp)) { *cp = 0; cp--; }\n        }\n        ftyp = f->argnames->args[i].type;\n        if (ftyp<=0 || (ftyp&JSI_TT_ANY))\n            continue;\n        atyp = jsi_typeGet(interp, stype);\n        if (ftyp != atyp && atyp) {\n            Jsi_LogWarn(\"argument %d of function \\\"%s\\\" does not match \\\"func(%s)\\\"\" ,\n                i+1, f->name, argStr);\n            goto done;\n        }\n    }\n    rc = 1;\ndone:\n    Jsi_DSFree(&dStr);\n    if (!rc)\n        jsi_TypeMismatch(interp);\n    return rc;\n}\n\n/* Call function that returns a bool with a single argument. Returns -1, else 0/1 for false/true,  */\nint Jsi_FunctionInvokeBool(Jsi_Interp *interp, Jsi_Value *func, Jsi_Value *arg)\n{\n    if (interp->deleting)\n        return JSI_ERROR;\n    Jsi_Value *vpargs, *frPtr = Jsi_ValueNew1(interp);\n    Jsi_RC rc;\n    int bres = 0;\n    if (!arg) {\n        if (!interp->nullFuncArg) {\n            interp->nullFuncArg = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, NULL, 0, 0));\n            Jsi_IncrRefCount(interp, interp->nullFuncArg);\n        }\n        vpargs = interp->nullFuncArg;\n    } else {\n        vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, &arg, 1, 1));\n    }\n    Jsi_IncrRefCount(interp, vpargs);\n    rc = Jsi_FunctionInvoke(interp, func, vpargs, &frPtr, NULL);\n    Jsi_DecrRefCount(interp, vpargs);\n    if (rc == JSI_OK)\n        bres = Jsi_ValueIsTrue(interp, frPtr);\n    else {\n        bres = 2;\n        Jsi_LogError(\"function call failed\");\n    }\n    Jsi_DecrRefCount(interp, frPtr);\n    if (Jsi_InterpGone(interp))\n        return JSI_ERROR;\n    return bres;\n}\n\n// Invoke function with one string argument.\nJsi_RC Jsi_FunctionInvokeString(Jsi_Interp *interp, Jsi_Value *func, Jsi_Value *arg, Jsi_DString *dStr)\n{\n    if (interp->deleting)\n        return JSI_ERROR;\n    Jsi_Value *vpargs, *frPtr = Jsi_ValueNew1(interp);\n    Jsi_RC rc;\n    if (!arg) {\n        if (!interp->nullFuncArg) {\n            interp->nullFuncArg = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, NULL, 0, 0));\n            Jsi_IncrRefCount(interp, interp->nullFuncArg);\n        }\n        vpargs = interp->nullFuncArg;\n    } else {\n        vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, &arg, 1, 1));\n    }\n    Jsi_IncrRefCount(interp, vpargs);\n    rc = Jsi_FunctionInvoke(interp, func, vpargs, &frPtr, NULL);\n    Jsi_DecrRefCount(interp, vpargs);\n    if (rc != JSI_OK)\n        Jsi_LogError(\"function call failed\");\n    else\n        Jsi_ValueGetDString(interp, frPtr, dStr, 0);\n    Jsi_DecrRefCount(interp, frPtr);\n    return rc;\n}\n       \n\nJsi_FuncObj *jsi_FuncObjNew(Jsi_Interp *interp, Jsi_Func *func)\n{\n    Jsi_FuncObj *f = (Jsi_FuncObj*)Jsi_Calloc(1,sizeof(Jsi_FuncObj));\n    f->interp = interp;\n    SIGINIT(f,FUNCOBJ);\n    f->func = func;\n    func->refCnt++;\n    return f;\n}\n\nvoid jsi_FuncFree(Jsi_Interp *interp, Jsi_Func *func)\n{\n    if (--func->refCnt > 0)\n        return;\n    jsi_PkgInfo *pkg = func->pkg;\n    bool profile = (interp->profile || (pkg?pkg->popts.modConf.profile:0)), \n        cover = (interp->coverage || (pkg?pkg->popts.modConf.coverage:0));\n    if (profile || cover) {\n        Jsi_DString dStr;\n        Jsi_DSInit(&dStr);\n        const char *file = func->script;\n        if (!file)\n            file = \"\";\n        int line = func->bodyline.last_line;\n        if (!func->callCnt) {\n            if (cover && func->type == FC_NORMAL && func->name)\n                Jsi_DSPrintf(&dStr, \"COVERAGE: func=%s  file=%s:%d  cover=0%%\\n\", func->name, file, line );\n        } else {\n            char buf[JSI_BUFSIZ];\n            if (func->type == FC_BUILDIN) {\n                const char *fnam = func->parentName;\n                snprintf(buf, sizeof(buf), \"cmd=%s%s%s\", fnam, fnam[0]?\".\":\"\", func->name);\n                interp->cmdSelfTime += (func->allTime-func->subTime);\n            } else {\n                \n                double coverage = 0; // Calculate hits/all.\n                if (func->opcodes && func->opcodes->code_len>0) {\n                    int i, cchit=0, ccall=0, ccline=0, cchitline=0;\n                    Jsi_OpCodes *oc = func->opcodes;\n                    for (i=0; i<oc->code_len; i++) {\n                        if (oc->codes[i].Line<=0) continue;\n                        if (ccline != oc->codes[i].Line) {\n                            ccline = oc->codes[i].Line;\n                            ccall++;\n                            interp->coverAll++;\n                        }\n                        if (cchitline != oc->codes[i].Line && oc->codes[i].hit) {\n                            cchitline = oc->codes[i].Line;\n                            cchit++;\n                            interp->coverHit++;\n                        }\n                    }\n                    if (ccall)\n                        coverage = (int)(100.0*cchit/ccall);\n                        \n                    if (cover && cchit<ccall) { // Generate the misses list.\n                        char cbuf[JSI_BUFSIZ];\n                        int lastout = 0, lastpos=0, dupcnt=0, cccnt=0;\n                        cbuf[0] = 0;\n                        ccline=cchitline=0;\n                        for (i=0; i<oc->code_len; i++) {\n                            int ismiss = 0;\n                            if (i==oc->code_len) {\n                                ismiss = (ccline>0 && cchitline != ccline);\n                            } else {\n                                if (oc->codes[i].Line<=0) continue;\n                                ismiss = (ccline>0 && ccline != oc->codes[i].Line && cchitline != ccline);\n                            }\n                            if (ismiss) {\n                                cccnt++;\n                                const char *sep = (cccnt>1?\",\":\"\");\n                                if (lastout && (lastout+1)==ccline) {\n                                    sep = \"-\";\n                                    dupcnt++;\n                                    if (dupcnt>1)\n                                        cbuf[lastpos]=0; // Inefficient, but reliable.\n                                    else\n                                        lastpos = Jsi_Strlen(cbuf);\n                                } else \n                                    dupcnt = 0;\n                                int cbl = Jsi_Strlen(cbuf);\n                                snprintf(cbuf+cbl, sizeof(cbuf)-cbl, \"%s%d\", sep, ccline);\n                                lastout = ccline;\n                            }\n                            ccline = oc->codes[i].Line;\n                            if (oc->codes[i].hit)\n                                cchitline = ccline;\n                        }\n                        Jsi_DSPrintf(&dStr, \"COVERAGE: func=%s  file=%s:%d  cover=%2.1f%%  hits=%d,  all=%d,  misses=%s\\n\", \n                            func->name, file, line, coverage, cchit, ccall, cbuf);\n                    }\n                }\n                snprintf(buf, sizeof(buf), \"cover=%#5.1f%%  func=%s file=%s:%d\", coverage, func->name, file, line);\n                interp->funcSelfTime += (func->allTime-func->subTime);\n            }\n            if (profile)\n                Jsi_DSPrintf(&dStr, \"PROFILE:  self=%6.6f  all=%6.6f  #calls=%-8d  self/call=%6.6f  all/call=%6.6f  %s %s%s\\n\",\n                    (func->allTime-func->subTime), (double)(func->allTime), func->callCnt, \n                    (double)(func->allTime-func->subTime)/func->callCnt,  (double)(func->allTime)/func->callCnt, \n                    buf, interp->parent?\" ::\":\"\", (interp->parent&&interp->name?interp->name:\"\"));\n        }\n        if (Jsi_DSLength(&dStr))\n            Jsi_Puts(interp, jsi_Stderr, Jsi_DSValue(&dStr), -1);\n        Jsi_DSFree(&dStr);\n    }\n\n    if (func->opcodes)\n        jsi_FreeOpcodes(func->opcodes);\n    if (func->hPtr)\n        Jsi_HashEntryDelete(func->hPtr);\n    if (func->localnames)\n        jsi_ScopeStrsFree(interp, func->localnames);\n    if (func->argnames)\n        jsi_ScopeStrsFree(interp, func->argnames);\n    if (func->cmdSpec && (intptr_t)func->cmdSpec->reserved[3]& 0x1)\n        Jsi_Free(func->cmdSpec);\n    _JSI_MEMCLEAR(func);\n    Jsi_Free(func);\n    interp->funcCnt--;\n}\n\nJsi_Func *jsi_FuncNew(Jsi_Interp *interp)\n{\n     Jsi_Func *func = (Jsi_Func*)Jsi_Calloc(1, sizeof(Jsi_Func));\n     SIGINIT(func, FUNC);\n     func->hPtr = Jsi_HashSet(interp->funcsTbl, func, func);\n     func->refCnt = 1;\n     interp->funcCnt++;\n     return func;\n}\n\nvoid jsi_FuncObjFree(Jsi_FuncObj *fobj)\n{\n    if (fobj->scope)\n        jsi_ScopeChainFree(fobj->interp, fobj->scope);\n    if (fobj->bindArgs)\n        Jsi_DecrRefCount(fobj->interp, fobj->bindArgs);\n    if (fobj->bindFunc)\n        Jsi_DecrRefCount(fobj->interp, fobj->bindFunc);\n    if (fobj->func)\n        jsi_FuncFree(fobj->interp, fobj->func);\n    _JSI_MEMCLEAR(fobj);\n    Jsi_Free(fobj);\n}\n\n#endif\n", "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <stdint.h>\n#ifndef JSI_AMALGAMATION\n#include \"jsiInt.h\"\n#endif\n\n#define REBUILD_MULTIPLIER  3\n\n#if JSI_IS64BIT\n#define RANDOM_INDEX        HashOneWord\n#define DOWNSHIFT_START     62\n#else \n#define RANDOM_INDEX(tablePtr, i) \\\n    (((((uintptr_t) (i))*1103515245) >> (tablePtr)->downShift) & (tablePtr)->mask)\n#define DOWNSHIFT_START 28\n#endif\n\nstatic jsi_Hash jsi_HashArray (const void *key, size_t length);\nstatic Jsi_HashEntry *jsi_HashArrayFind (Jsi_Hash *tablePtr, const void \n*key);\nstatic Jsi_HashEntry *jsi_HashArrayCreate (Jsi_Hash *tablePtr,\n    const void *key, bool *newPtr);\nstatic jsi_Hash HashString (const char *string);\nstatic void RebuildTable (Jsi_Hash *tablePtr);\nstatic Jsi_HashEntry *HashStringFind (Jsi_Hash *tablePtr,\n    const void *key);\nstatic Jsi_HashEntry *HashStringCreate (Jsi_Hash *tablePtr,\n    const void *key, bool *newPtr);\nstatic Jsi_HashEntry *HashOneWordFind (Jsi_Hash *tablePtr,\n    const void *key);\nstatic Jsi_HashEntry *HashOneWordCreate (Jsi_Hash *tablePtr,\n    const void *key, bool *newPtr);\n\n#if JSI_IS64BIT\nstatic jsi_Hash HashOneWord (Jsi_Hash *tablePtr,\n    const void *key));\n\n#endif /* JSI_IS64BIT */\n\nstatic jsi_Hash\nHashString( const char *string)\n{\n    jsi_Hash result = 0;\n    jsi_Hash c;\n    while ((c = *string++) != 0)\n        result += (result << 3) + c;\n\n    return (jsi_Hash)result;\n}\nstatic Jsi_HashEntry *\nHashStringFind( Jsi_Hash *tablePtr, const void *key)\n{\n    jsi_Hash hval;\n    Jsi_HashEntry *hPtr;\n    size_t hindex;\n\n    hval = HashString((char *)key);\n    hindex = hval & tablePtr->mask;\n\n    /*\n     * Search all of the entries in the appropriate bucket.\n     */\n\n    for (hPtr = tablePtr->buckets[hindex]; hPtr != NULL;\n            hPtr = hPtr->nextPtr) {\n        if (hPtr->hval == hval) {\n            const char *p1, *p2;\n\n            for (p1 = (char*)key, p2 = hPtr->key.string; ; p1++, p2++) {\n                if (*p1 != *p2) {\n                    break;\n                }\n                if (*p1 == '\\0') {\n                    return hPtr;\n                }\n            }\n        }\n    }\n    return NULL;\n}\n\nstatic Jsi_HashEntry *\nHashStringCreate( Jsi_Hash *tablePtr, const void *key, bool *newPtr)\n{\n    jsi_Hash hval;\n    Jsi_HashEntry **bucketPtr;\n    Jsi_HashEntry *hPtr;\n    size_t size, hindex;\n\n    hval = HashString((const char*)key);\n    hindex = hval & tablePtr->mask;\n\n    for (hPtr = tablePtr->buckets[hindex]; hPtr != NULL;\n            hPtr = hPtr->nextPtr) {\n        if (hPtr->hval == hval) {\n            const char *p1, *p2;\n\n            for (p1 = (const char*)key, p2 = hPtr->key.string; ; p1++, p2++) {\n                if (*p1 != *p2) {\n                    break;\n                }\n                if (*p1 == '\\0') {\n                    if (newPtr)\n                        *newPtr = 0;\n                    return hPtr;\n                }\n            }\n        }\n    }\n\n    if (newPtr)\n        *newPtr = 1;\n    size = sizeof(Jsi_HashEntry) + Jsi_Strlen((char*)key) - sizeof(jsi_HashKey) + 1;\n    hPtr = (Jsi_HashEntry*)Jsi_Calloc(1, size);\n    hPtr->typ = JSI_MAP_HASH;\n    bucketPtr = tablePtr->buckets + hindex;\n    hPtr->tablePtr = tablePtr;\n    hPtr->nextPtr = *bucketPtr;\n    hPtr->hval = hval;\n    hPtr->clientData = 0;\n    Jsi_Strcpy(hPtr->key.string, (char*)key);\n    *bucketPtr = hPtr;\n    tablePtr->numEntries++;\n\n    if (tablePtr->numEntries >= tablePtr->rebuildSize)\n        RebuildTable(tablePtr);\n        \n    return hPtr;\n}\n\n#if JSI_IS64BIT\n/*\n *----------------------------------------------------------------------\n *\n * HashOneWord --\n *\n *  Compute a one-word hash value of a 64-bit word, which then can\n *  be used to generate a hash index.\n *\n *  From Knuth, it's a multiplicative hash.  Multiplies an unsigned\n *  64-bit value with the golden ratio (sqrt(5) - 1) / 2.  The\n *  downshift value is 64 - n, when n is the log2 of the size of\n *  the hash table.\n *      \n * Results:\n *  The return value is a one-word summary of the information in\n *  64 bit word.\n *\n * Side effects:\n *  None.\n *\n *----------------------------------------------------------------------\n */\nstatic jsi_Hash\nHashOneWord(\n    Jsi_Hash *tablePtr,\n    const void *key)\n{\n    uint64_t a0, a1;\n    uint64_t y0, y1;\n    uint64_t y2, y3;\n    uint64_t p1, p2;\n    uint64_t result;\n    /* Compute key * GOLDEN_RATIO in 128-bit arithmetic */\n    a0 = (uint64_t)key & 0x00000000FFFFFFFF;\n    a1 = (uint64_t)key >> 32;\n\n    y0 = a0 * 0x000000007f4a7c13;\n    y1 = a0 * 0x000000009e3779b9;\n    y2 = a1 * 0x000000007f4a7c13;\n    y3 = a1 * 0x000000009e3779b9;\n    y1 += y0 >> 32;     /* Can't carry */\n    y1 += y2;           /* Might carry */\n    if (y1 < y2) {\n        y3 += (1LL << 32);  /* Propagate */\n    }\n\n    /* 128-bit product: p1 = loword, p2 = hiword */\n    p1 = ((y1 & 0x00000000FFFFFFFF) << 32) + (y0 & 0x00000000FFFFFFFF);\n    p2 = y3 + (y1 >> 32);\n\n    /* Left shift the value downward by the size of the table */\n    if (tablePtr->downShift > 0) {\n        if (tablePtr->downShift < 64) {\n            result = ((p2 << (64 - tablePtr->downShift)) |\n                      (p1 >> (tablePtr->downShift & 63)));\n        } else {\n            result = p2 >> (tablePtr->downShift & 63);\n        }\n    } else {\n        result = p1;\n    }\n    /* Finally mask off the high bits */\n    return (jsi_Hash)(result & tablePtr->mask);\n}\n\n#endif /* JSI_IS64BIT */\n\nstatic Jsi_HashEntry *\nHashOneWordFind( Jsi_Hash *tablePtr,  const void *key)\n{\n     Jsi_HashEntry *hPtr;\n    size_t hindex;\n\n    hindex = RANDOM_INDEX(tablePtr, key);\n\n    /*\n     * Search all of the entries in the appropriate bucket.\n     */\n    for (hPtr = tablePtr->buckets[hindex]; hPtr != NULL;\n        hPtr = hPtr->nextPtr) {\n    if (hPtr->key.oneWordValue == key) {\n        return hPtr;\n    }\n    }\n    return NULL;\n}\n\nstatic Jsi_HashEntry *\nHashOneWordCreate( Jsi_Hash *tablePtr, const void *key, bool *newPtr)\n{\n    Jsi_HashEntry **bucketPtr;\n     Jsi_HashEntry *hPtr;\n    size_t hindex;\n\n    hindex = RANDOM_INDEX(tablePtr, key);\n\n\n    for (hPtr = tablePtr->buckets[hindex]; hPtr != NULL;\n        hPtr = hPtr->nextPtr) {\n        if (hPtr->key.oneWordValue == key) {\n            if (newPtr)\n                *newPtr = 0;\n            return hPtr;\n        }\n    }\n\n    if (newPtr)\n        *newPtr = 1;\n    hPtr = (Jsi_HashEntry*)Jsi_Calloc(1, sizeof(*hPtr));\n    hPtr->typ = JSI_MAP_HASH;\n    bucketPtr = tablePtr->buckets + hindex;\n    hPtr->tablePtr = tablePtr;\n    hPtr->nextPtr = *bucketPtr;\n    hPtr->hval = (jsi_Hash)key;\n    hPtr->clientData = 0;\n    hPtr->key.oneWordValue = (void *)key; \n    *bucketPtr = hPtr;\n    tablePtr->numEntries++;\n\n\n    if (tablePtr->numEntries >= tablePtr->rebuildSize)\n        RebuildTable(tablePtr);\n\n    return hPtr;\n}\n\nstatic jsi_Hash\njsi_HashArray(const void *key, size_t length )\n{\n    const uchar *string = (const uchar *) key;\n    unsigned int result = 0;\n    int i;\n\n     for (i=0 ; i<(int)length; i++) {\n        result += (result<<3) + string[i];\n    }\n    return (jsi_Hash)result;\n}\n\nstatic Jsi_HashEntry *\njsi_HashArrayFind( Jsi_Hash *tablePtr, const void *key)\n{\n    jsi_Hash hval = jsi_HashArray(key, tablePtr->keyType);\n    size_t hindex = hval & tablePtr->mask;\n    Jsi_HashEntry *hPtr = tablePtr->buckets[hindex];\n\n    for (; hPtr != NULL; hPtr = hPtr->nextPtr)\n        if (hPtr->hval == hval && !memcmp(hPtr->key.string, key, tablePtr->keyType))\n            return hPtr;\n\n    return NULL;\n}\n\nstatic Jsi_HashEntry *\njsi_HashArrayCreate( Jsi_Hash *tablePtr,  const void *key, bool *newPtr)\n{\n    jsi_Hash hval = jsi_HashArray(key, tablePtr->keyType);\n    size_t size, hindex = hval & tablePtr->mask;\n    Jsi_HashEntry *hPtr = tablePtr->buckets[hindex];\n\n    for (; hPtr != NULL; hPtr = hPtr->nextPtr)\n        if (hPtr->hval == hval && !memcmp(hPtr->key.string, key, tablePtr->keyType)) {\n            if (newPtr)\n                *newPtr = 0;\n            return hPtr;\n        }\n\n    /* Entry not found.  Add a new one to the bucket. */\n    if (newPtr)\n        *newPtr = 1;\n    assert(tablePtr->keyType >= JSI_KEYS_STRUCT_MINSIZE);\n    size = sizeof(Jsi_HashEntry) + tablePtr->keyType;\n    if ((uint)tablePtr->keyType > sizeof(jsi_HashKey)) // Avoid memory checker problems by not truncating struct.\n        size -= sizeof(jsi_HashKey);\n    hPtr = (Jsi_HashEntry*)Jsi_Calloc(1, size);\n    Jsi_HashEntry **bucketPtr = tablePtr->buckets + hindex;\n    hPtr->typ = JSI_MAP_HASH;\n    hPtr->tablePtr = tablePtr;\n    hPtr->nextPtr = *bucketPtr;\n    hPtr->hval = hval;\n    hPtr->clientData = 0;\n    memcpy(hPtr->key.string, key, tablePtr->keyType);\n    *bucketPtr = hPtr;\n    tablePtr->numEntries++;\n\n    /*\n     * If the table has exceeded a decent size, rebuild it with many\n     * more buckets.\n     */\n    if (tablePtr->numEntries >= tablePtr->rebuildSize)\n        RebuildTable(tablePtr);\n\n    return hPtr;\n}\n\n\nJsi_HashEntry *\nJsi_HashEntryFind( Jsi_Hash *tablePtr, const void *key)\n{\n    if (tablePtr->opts.lockHashProc && (*tablePtr->opts.lockHashProc)(tablePtr, 1) != JSI_OK)\n        return NULL;\n    Jsi_HashEntry *hPtr = (*((tablePtr)->findProc))(tablePtr, key);\n    if (tablePtr->opts.lockHashProc)\n        (*tablePtr->opts.lockHashProc)(tablePtr, 0);\n    return hPtr;\n}\n\nJsi_HashEntry *\nJsi_HashEntryNew(Jsi_Hash *tablePtr, const void *key, bool *newPtr)\n{\n    if (tablePtr->opts.lockHashProc && (*tablePtr->opts.lockHashProc)(tablePtr, 1) != JSI_OK)\n        return NULL;\n    Jsi_HashEntry *hPtr =  (*((tablePtr)->createProc))(tablePtr, key, newPtr);\n#ifdef JSI_HAS_SIG_HASHENTRY\n    SIGINIT(hPtr, HASHENTRY);\n#endif\n    if (tablePtr->opts.lockHashProc)\n        (*tablePtr->opts.lockHashProc)(tablePtr, 0);\n    return hPtr;\n}\n\nstatic void\nRebuildTable(Jsi_Hash *tablePtr)\n{\n    Jsi_HashEntry **bucketPtr, **oldBuckets;\n    Jsi_HashEntry **oldChainPtr, **endPtr;\n    Jsi_HashEntry *hPtr, *nextPtr;\n    size_t hindex;\n\n    oldBuckets = tablePtr->buckets;\n    endPtr = tablePtr->buckets + tablePtr->numBuckets;\n    tablePtr->numBuckets <<= 2;\n    tablePtr->buckets = (Jsi_HashEntry**)Jsi_Calloc(tablePtr->numBuckets, \n                   sizeof(Jsi_HashEntry *));\n    tablePtr->rebuildSize <<= 2;\n    tablePtr->downShift -= 2;\n    tablePtr->mask = tablePtr->numBuckets - 1;\n\n \n    if (tablePtr->keyType == JSI_KEYS_ONEWORD) {\n\n        for (oldChainPtr = oldBuckets; oldChainPtr < endPtr; oldChainPtr++) {\n            for (hPtr = *oldChainPtr; hPtr != NULL; hPtr = nextPtr) {\n            nextPtr = hPtr->nextPtr;\n            hindex = RANDOM_INDEX(tablePtr, hPtr->key.oneWordValue);\n            bucketPtr = tablePtr->buckets + hindex;\n            hPtr->nextPtr = *bucketPtr;\n            *bucketPtr = hPtr;\n            }\n        }\n    } else {\n        for (oldChainPtr = oldBuckets; oldChainPtr < endPtr; oldChainPtr++) {\n            for (hPtr = *oldChainPtr; hPtr != NULL; hPtr = nextPtr) {\n            nextPtr = hPtr->nextPtr;\n            hindex = hPtr->hval & tablePtr->mask;\n            bucketPtr = tablePtr->buckets + hindex;\n            hPtr->nextPtr = *bucketPtr;\n            *bucketPtr = hPtr;\n            }\n        }\n    }\n\n    if (oldBuckets != tablePtr->staticBuckets) {\n        Jsi_Free(oldBuckets);\n    }\n}\n\nJsi_Hash *\nJsi_HashNew(Jsi_Interp *interp, unsigned int keyType, Jsi_HashDeleteProc freeProc)\n{\n    Jsi_Hash *tablePtr = (Jsi_Hash*)Jsi_Calloc(1,sizeof(*tablePtr));\n    SIGINIT(tablePtr, HASH);\n    tablePtr->opts.mapType = (Jsi_Map_Type)JSI_MAP_HASH;\n    tablePtr->typ = JSI_MAP_HASH;\n    tablePtr->opts.interp = interp;\n    tablePtr->buckets = tablePtr->staticBuckets;\n#if !(JSI_SMALL_HASH_TABLE && !(JSI_SMALL_HASH_TABLE & (JSI_SMALL_HASH_TABLE - 1)))\n#error \"small hash must be a power of two\"\n#endif\n    tablePtr->numBuckets = JSI_SMALL_HASH_TABLE;\n    tablePtr->rebuildSize = JSI_SMALL_HASH_TABLE * REBUILD_MULTIPLIER;\n    tablePtr->downShift = DOWNSHIFT_START;\n    tablePtr->opts.freeHashProc = freeProc;\n    tablePtr->mask = (jsi_Hash)(tablePtr->numBuckets - 1);\n    tablePtr->opts.keyType = (Jsi_Key_Type)keyType;\n    tablePtr->keyType = (Jsi_Key_Type)keyType;\n\n    switch (keyType) {\n    case JSI_KEYS_STRING:   /* NUL terminated string keys. */\n        tablePtr->findProc = HashStringFind;\n        tablePtr->createProc = HashStringCreate;\n        break;\n\n    case JSI_KEYS_STRINGKEY: /* Lookup from another String hash, eg. Jsi_KeyAdd() */\n    case JSI_KEYS_ONEWORD: /* A pointer. */\n        tablePtr->findProc = HashOneWordFind;\n        tablePtr->createProc = HashOneWordCreate;\n        break;\n\n    default:            /* Structs. */\n        if (keyType < JSI_KEYS_STRUCT_MINSIZE) {\n            Jsi_LogError(\"Jsi_HashNew: Key size can't be %d, must be >= %d\", keyType, JSI_KEYS_STRUCT_MINSIZE);\n            Jsi_Free(tablePtr);\n            return NULL;\n        }\n        tablePtr->findProc = jsi_HashArrayFind;\n        tablePtr->createProc = jsi_HashArrayCreate;\n        break;\n    }\n    return tablePtr;\n}\n\nint\nJsi_HashEntryDelete(Jsi_HashEntry *entryPtr)\n{\n    Jsi_HashEntry *prevPtr;\n    Jsi_HashEntry **bucketPtr;\n    size_t hindex;\n    Jsi_Hash *tablePtr = entryPtr->tablePtr;\n    Jsi_Interp *interp = tablePtr->opts.interp;\n    JSI_NOTUSED(interp);\n    int cnt = 0;\n#ifdef JSI_HAS_SIG_HASHENTRY\n    SIGASSERT(entryPtr, HASHENTRY);\n#endif\n    if (tablePtr->opts.lockHashProc && (*tablePtr->opts.lockHashProc)(tablePtr, 1) != JSI_OK)\n        return 0;\n    if (tablePtr->keyType == JSI_KEYS_ONEWORD) {\n        hindex = RANDOM_INDEX(tablePtr, (const void *)entryPtr->hval);\n    } else {\n        hindex = (entryPtr->hval & tablePtr->mask);\n    }\n    bucketPtr = tablePtr->buckets + hindex;\n    if (*bucketPtr == entryPtr) {\n        *bucketPtr = entryPtr->nextPtr;\n        cnt++;\n    } else {\n        for (prevPtr = *bucketPtr; /*empty*/; prevPtr = prevPtr->nextPtr) {\n            if (prevPtr == NULL) {\n                Jsi_LogBug(\"malformed bucket chain in Jsi_HashEntryDelete\");\n            }\n            if (prevPtr->nextPtr == entryPtr) {\n                prevPtr->nextPtr = entryPtr->nextPtr;\n                cnt++;\n                break;\n            }\n        }\n    }\n    if (tablePtr->opts.freeHashProc && entryPtr->clientData)\n        (tablePtr->opts.freeHashProc)(tablePtr->opts.interp, entryPtr, entryPtr->clientData);\n\n    if (tablePtr->opts.lockHashProc)\n        (*tablePtr->opts.lockHashProc)(tablePtr, 0);\n    tablePtr->numEntries--;\n    Jsi_Free(entryPtr);\n    return cnt;\n}\n\nvoid\nJsi_HashClear(Jsi_Hash *tablePtr)\n{\n    Jsi_HashEntry *hPtr, *nextPtr;\n    size_t i;\n    if (!tablePtr)\n        return;\n    if (tablePtr->opts.lockHashProc && (*tablePtr->opts.lockHashProc)(tablePtr, 1) != JSI_OK)\n        return;\n    for (i = 0; i < (size_t)tablePtr->numBuckets; i++) {\n        hPtr = tablePtr->buckets[i];\n        while (hPtr != NULL) {\n            nextPtr = hPtr->nextPtr;\n            if (tablePtr->opts.freeHashProc && hPtr->clientData)\n                (tablePtr->opts.freeHashProc)(tablePtr->opts.interp, hPtr, hPtr->clientData);\n            Jsi_Free(hPtr);\n            hPtr = nextPtr;\n            tablePtr->buckets[i] = hPtr;\n        }\n    }\n    \n    if (tablePtr->buckets != tablePtr->staticBuckets) {\n        Jsi_Free(tablePtr->buckets);\n    }\n    if (tablePtr->opts.lockHashProc)\n        (*tablePtr->opts.lockHashProc)(tablePtr, 0);\n}\n\n\nvoid\nJsi_HashDelete(Jsi_Hash *tablePtr)\n{\n    Jsi_HashClear(tablePtr);\n    Jsi_Free(tablePtr);\n}\n\nJsi_HashEntry *\nJsi_HashSearchFirst(Jsi_Hash *tablePtr, Jsi_HashSearch *searchPtr) \n{\n    searchPtr->tablePtr = tablePtr;\n    searchPtr->nextIndex = 0;\n    searchPtr->nextEntryPtr = NULL;\n    return Jsi_HashSearchNext(searchPtr);\n}\n\n\nvoid *Jsi_HashValueGet(Jsi_HashEntry *h)\n{\n    return h->clientData;\n}\n\nvoid Jsi_HashValueSet(Jsi_HashEntry *h, void *value)\n{\n    h->clientData = value;\n}\n\nvoid *Jsi_HashKeyGet(Jsi_HashEntry *hPtr)\n{\n    Jsi_Hash *t = hPtr->tablePtr;\n    return (t->keyType == JSI_KEYS_ONEWORD || t->keyType == JSI_KEYS_STRINGKEY ? hPtr->key.oneWordValue : hPtr->key.string);\n}\n\nJsi_HashEntry *\nJsi_HashSearchNext(Jsi_HashSearch *searchPtr)\n{\n    Jsi_HashEntry *hPtr;\n    Jsi_Hash *tablePtr = searchPtr->tablePtr;\n    int locked = 0;\n    \n    while (searchPtr->nextEntryPtr == NULL) {\n        if (searchPtr->nextIndex >= (size_t)tablePtr->numBuckets) {\n            if (tablePtr->opts.lockHashProc && locked)\n                (*tablePtr->opts.lockHashProc)(tablePtr, 0);\n            return NULL;\n        }\n        if (tablePtr->opts.lockHashProc && locked == 0 && (*tablePtr->opts.lockHashProc)(tablePtr, locked++) != JSI_OK)\n            return NULL;\n        searchPtr->nextEntryPtr =\n            tablePtr->buckets[searchPtr->nextIndex];\n        searchPtr->nextIndex++;\n    }\n    if (tablePtr->opts.lockHashProc && locked)\n        (*tablePtr->opts.lockHashProc)(tablePtr, 0);\n    hPtr = searchPtr->nextEntryPtr;\n    searchPtr->nextEntryPtr = hPtr->nextPtr;\n    return hPtr;\n}\n\n\nJsi_HashEntry* Jsi_HashSet(Jsi_Hash *tbl, const void *key, void *value) {\n    Jsi_HashEntry *hPtr;\n    bool isNew;\n    hPtr = Jsi_HashEntryNew(tbl, key, &isNew);\n    if (!hPtr) return hPtr;\n    Jsi_HashValueSet(hPtr, value);\n    return hPtr;\n}\n\nvoid *Jsi_HashGet(Jsi_Hash *tbl, const void *key, int flags) {\n    Jsi_HashEntry *hPtr;\n    hPtr = Jsi_HashEntryFind(tbl, key);\n    if (!hPtr)\n        return NULL;\n    return Jsi_HashValueGet(hPtr);\n}\n\n// Delete entry, invoking the freeProc.\nbool Jsi_HashUnset(Jsi_Hash *tbl, const void *key) {\n    Jsi_HashEntry *hPtr;\n    hPtr = Jsi_HashEntryFind(tbl, key);\n    if (!hPtr)\n        return false;\n    Jsi_HashEntryDelete(hPtr);\n    return true;\n}\n\nJsi_RC Jsi_HashConf(Jsi_Hash *hashPtr, Jsi_MapOpts *opts, bool set)\n{\n    if (set)\n        hashPtr->opts = *opts;\n    else\n        *opts = hashPtr->opts;\n    return JSI_OK;\n}\n\n#ifndef JSI_LITE_ONLY\n\nstatic Jsi_Value *jsi_hashFmtKey(Jsi_MapEntry* h, struct Jsi_MapOpts *opts, int flags)\n{\n    Jsi_HashEntry* hPtr = (Jsi_HashEntry*)h;\n    void *key = Jsi_HashKeyGet(hPtr);\n    if (opts->keyType == JSI_KEYS_ONEWORD)\n        return Jsi_ValueNewNumber(opts->interp, (Jsi_Number)(intptr_t)key);\n    char nbuf[JSI_MAX_NUMBER_STRING];\n    snprintf(nbuf, sizeof(nbuf), \"%p\", key);\n    return Jsi_ValueNewStringDup(opts->interp, nbuf);\n}\n\nJsi_RC Jsi_HashKeysDump(Jsi_Interp *interp, Jsi_Hash *tablePtr, Jsi_Value **ret, int flags) {\n    char *key;\n    int n = 0;\n    Jsi_HashEntry *hPtr;\n    Jsi_HashSearch search;\n    Jsi_Obj *nobj;\n    Jsi_MapFmtKeyProc* fmtKeyProc = (Jsi_MapFmtKeyProc*)tablePtr->opts.fmtKeyProc;\n    \n    if (!fmtKeyProc && tablePtr->keyType == JSI_KEYS_ONEWORD && flags!=JSI_KEYS_ONEWORD )\n        fmtKeyProc = jsi_hashFmtKey;\n    \n    if (!fmtKeyProc && tablePtr->keyType >= JSI_KEYS_STRUCT_MINSIZE) \n        return Jsi_LogError(\"Can not dump struct hash\");\n    nobj = Jsi_ObjNew(interp);\n    Jsi_ValueMakeArrayObject(interp, ret, nobj);\n    for (hPtr = Jsi_HashSearchFirst(tablePtr, &search);\n        hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {\n        key = (char*)Jsi_HashKeyGet(hPtr);\n        Jsi_Value *val;\n        if (fmtKeyProc) {\n            val = (*fmtKeyProc)((Jsi_MapEntry*)hPtr, &tablePtr->opts, flags);\n            if (!val) {\n                Jsi_LogError(\"key format failed\");\n                Jsi_ValueMakeUndef(interp, ret);\n                return JSI_ERROR;\n            }\n        } else if (tablePtr->keyType == JSI_KEYS_ONEWORD)\n            val = Jsi_ValueNewNumber(interp, (Jsi_Number)(uintptr_t)key);\n        else\n            val = Jsi_ValueNewStringKey(interp, key);\n        Jsi_ObjArraySet(interp, nobj, val, n++);\n        if (fmtKeyProc && val->refCnt>1) //TODO: Hmmm. for StructKey Jsi_OptionsDump() returns refCnt=1\n            Jsi_DecrRefCount(interp, val);\n\n    }\n    return JSI_OK;\n}\n#endif\n\nuint Jsi_HashSize(Jsi_Hash *hashPtr) { return hashPtr->numEntries; }\n", "#ifndef JSI_LITE_ONLY\n#define __JSIINT_C__\n#ifndef JSI_AMALGAMATION\n#include \"jsiInt.h\"\n#endif\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n#include <assert.h>\n\n#ifdef __WIN32\n#include <windows.h>\n#include <shlwapi.h>\n#ifndef JSI_OMIT_THREADS\n#include <process.h>\n#endif\n#else\n#ifndef JSI_OMIT_THREADS\n#include <pthread.h>\n#endif\n#endif\n\n#if (JSI_VERSION_MINOR<0 || JSI_VERSION_MINOR>99 || JSI_VERSION_RELEASE<0 || JSI_VERSION_RELEASE>99)\n#error \"VERSION MINOR/RELEASE not between 0-99 inclusive\"\n#endif\n\nstatic Jsi_OptionSpec InterpDebugOptions[] = {\n    JSI_OPT(CUSTOM,Jsi_DebugInterp, debugCallback,  .help=\"Command in parent interp for handling debugging\", .flags=0, .custom=Jsi_Opt_SwitchParentFunc, .data=(void*)\"file:string, line:number, level:number, func:string, opstr:string, bpId:number, emsg:string\" ),\n    JSI_OPT(BOOL,  Jsi_DebugInterp, doContinue,     .help=\"Continue execution until breakpoint\" ),\n    JSI_OPT(BOOL,  Jsi_DebugInterp, forceBreak,     .help=\"Force debugger to break\" ),\n    JSI_OPT(BOOL,  Jsi_DebugInterp, includeOnce,    .help=\"Source the file only if not already sourced\" ),\n    JSI_OPT(BOOL,  Jsi_DebugInterp, includeTrace,   .help=\"Trace includes\" ),\n    JSI_OPT(INT,   Jsi_DebugInterp, minLevel,       .help=\"Disable eval callback for level higher than this\" ),\n    JSI_OPT(CUSTOM,Jsi_DebugInterp, msgCallback,    .help=\"Comand in parent interp to handle Jsi_LogError/Jsi_LogWarn,..\", .flags=0, .custom=Jsi_Opt_SwitchParentFunc, .data=(void*)\"msg:string, type:string, file:string, line:number, col:number\" ),\n    JSI_OPT(BOOL,  Jsi_DebugInterp, pkgTrace,       .help=\"Trace package loads\" ),\n    JSI_OPT(CUSTOM,Jsi_DebugInterp, putsCallback,   .help=\"Comand in parent interp to handle puts output\", .flags=0, .custom=Jsi_Opt_SwitchParentFunc, .data=(void*)\"msg:string, isStderr:number\" ),\n    JSI_OPT(CUSTOM,Jsi_DebugInterp, traceCallback,  .help=\"Comand in parent interp to handle traceCall\", .flags=0, .custom=Jsi_Opt_SwitchParentFunc, .data=(void*)\"cmd:string, args:string, ret:string, file:string, line:number, col:number\" ),\n    JSI_OPT(CUSTOM,Jsi_DebugInterp, testFmtCallback,.help=\"Comand in parent interp to format unittest string\", .flags=0, .custom=Jsi_Opt_SwitchParentFunc, .data=(void*)\"cmd:string, line:number\" ),\n    JSI_OPT_END(Jsi_DebugInterp, .help=\"Interp options for debugging\")\n};\n\nJsi_OptionSpec jsi_InterpLogOptions[] = {\n    JSI_OPT(BOOL,   jsi_LogOptions, Test,    .help=\"Enable LogTest messages\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, Debug,   .help=\"Enable LogDebug messages\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, Trace,   .help=\"Enable LogTrace messages\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, Info,    .help=\"Enable LogInfo messages\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, Warn,    .help=\"Enable LogWarn messages\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, Error,   .help=\"Enable LogError messages\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, time,    .help=\"Prefix with time\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, date,    .help=\"Prefix with date\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, file,    .help=\"Ouptut contains file:line\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, func,    .help=\"Output function\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, full,    .help=\"Show full file path\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, ftail,   .help=\"Show tail of file only, even in LogWarn, etc\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, before,  .help=\"Output file:line before message string\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, isUTC,   .help=\"Time is to be UTC\" ),\n    JSI_OPT(STRKEY, jsi_LogOptions, timeFmt, .help=\"A format string to use with strftime\" ),\n    JSI_OPT(USEROBJ,jsi_LogOptions, chan,    .help=\"Channel to send output to\", .flags=0, .custom=0, .data=(void*)\"Channel\" ),\n    JSI_OPT_END(jsi_LogOptions, .help=\"Interp options for logging\")\n};\nstatic Jsi_OptionSpec InterpSubOptions[] = {\n    JSI_OPT(STRKEY,jsi_SubOptions, blacklist,   .help=\"Comma separated modules to disable loading for\", jsi_IIOF ),\n    JSI_OPT(BOOL,  jsi_SubOptions, compat,      .help=\"Ignore unknown options via JSI_OPTS_IGNORE_EXTRA in option parser\" ),\n    JSI_OPT(INT,   jsi_SubOptions, dblPrec,     .help=\"Format precision of double where 0=max, -1=max-1, ... (max-1)\" ),\n    JSI_OPT(BOOL,  jsi_SubOptions, istty,       .help=\"Indicates interp is in interactive mode\", jsi_IIRO),\n    JSI_OPT(BOOL,  jsi_SubOptions, logColNums,  .help=\"Display column numbers in error messages\"),\n    JSI_OPT(BOOL,  jsi_SubOptions, logAllowDups,.help=\"Log should not filter out duplicate messages\"),\n    JSI_OPT(BOOL,  jsi_SubOptions, mutexUnlock, .help=\"Unlock own mutex when evaling in other interps (true)\", jsi_IIOF),\n    JSI_OPT(BOOL,  jsi_SubOptions, noproto,     .help=\"Disable support of the OOP symbols:  __proto__, prototype, constructor, etc\"),\n    JSI_OPT(BOOL,  jsi_SubOptions, noFuncString,.help=\"Disable viewing code body for functions\", jsi_IIOF),\n    JSI_OPT(BOOL,  jsi_SubOptions, noRegex,     .help=\"Disable viewing code for functions\", jsi_IIOF),\n    JSI_OPT(BOOL,  jsi_SubOptions, noReadline,  .help=\"In interactive mode disable use of readline\" ),\n    JSI_OPT(BOOL,  jsi_SubOptions, outUndef,    .help=\"In interactive mode output result values that are undefined\"),\n    JSI_OPT(STRKEY,jsi_SubOptions, prompt,      .help=\"Prompt for interactive mode ('$ ')\" ),\n    JSI_OPT(STRKEY,jsi_SubOptions, prompt2,     .help=\"Prompt for interactive mode line continue ('> ')\" ),\n    JSI_OPT_END(jsi_SubOptions, .help=\"Lesser sub-feature options\")\n};\n\nstatic const char *jsi_SafeModeStrs[] = { \"none\", \"read\", \"write\", \"writeRead\", \"lockdown\", NULL };\nstatic const char *jsi_TypeChkStrs[] = { \"parse\", \"run\", \"all\", \"error\", \"strict\", \"noundef\", \"nowith\", \"funcsig\", NULL };\nconst char *jsi_callTraceStrs[] = { \"funcs\", \"cmds\", \"new\", \"return\", \"args\", \"notrunc\", \"noparent\", \"full\", \"before\", NULL};\nconst char *jsi_AssertModeStrs[] = { \"throw\", \"log\", \"puts\", NULL};\n\nstatic Jsi_OptionSpec InterpOptions[] = {\n    JSI_OPT(ARRAY, Jsi_Interp, args,        .help=\"The console.arguments for interp\", jsi_IIOF),\n    JSI_OPT(BOOL,  Jsi_Interp, asserts,     .help=\"Enable assert\" ),\n    JSI_OPT(CUSTOM,Jsi_Interp, assertMode,  .help=\"Action upon assert failure\", .flags=0, .custom=Jsi_Opt_SwitchEnum, .data=jsi_AssertModeStrs ),\n    JSI_OPT(ARRAY, Jsi_Interp, autoFiles,   .help=\"File(s) to source for loading Jsi_Auto to handle unknown commands\"),\n    JSI_OPT(CUSTOM,Jsi_Interp, busyCallback,.help=\"Command in parent interp (or noOp) to periodically call\", .flags=0, .custom=Jsi_Opt_SwitchParentFunc, .data=(void*)\"interpName:string, opCnt:number\"),\n    JSI_OPT(INT   ,Jsi_Interp, busyInterval,.help=\"Call busyCallback command after this many op-code evals (100000)\"),\n    JSI_OPT(STRKEY,Jsi_Interp, confFile,    .help=\"Config file of options in non-strict JSON form\", jsi_IIOF|JSI_OPT_LOCKSAFE),\n    JSI_OPT(BOOL,  Jsi_Interp, coverage,    .help=\"On exit generate detailed code coverage for function calls (with profile)\"),\n    JSI_OPT(CUSTOM,Jsi_Interp, debugOpts,   .help=\"Options for debugging\", .flags=0, .custom=Jsi_Opt_SwitchSuboption, .data=InterpDebugOptions),\n    JSI_OPT(BOOL,  Jsi_Interp, interactive, .help=\"Force interactive mode. ie. ignore no_interactive flag\", jsi_IIOF),\n    JSI_OPT(BOOL,  Jsi_Interp, hasOpenSSL,  .help=\"Is SSL available in WebSocket\", jsi_IIOF),\n    JSI_OPT(STRKEY,Jsi_Interp, historyFile, .help=\"In interactive mode, file to use for history (~/.jsish_history)\", jsi_IIOF),\n    JSI_OPT(BOOL,  Jsi_Interp, isSafe,      .help=\"Is this a safe interp (ie. with limited or no file access)\", jsi_IIOF),\n    JSI_OPT(STRKEY,Jsi_Interp, jsppChars,   .help=\"Line preprocessor when sourcing files. Line starts with first char, and either ends with it, or matches string\"),\n    JSI_OPT(FUNC,  Jsi_Interp, jsppCallback,.help=\"Command to preprocess lines that match jsppChars. Call func(interpName:string, opCnt:number)\"),\n    JSI_OPT(INT,   Jsi_Interp, lockTimeout, .help=\"Thread time-out for mutex lock acquires (milliseconds)\" ),\n    JSI_OPT(CUSTOM,Jsi_Interp, logOpts,     .help=\"Options for log output to add file/line/time\", .flags=0, .custom=Jsi_Opt_SwitchSuboption, .data=jsi_InterpLogOptions),\n    JSI_OPT(INT,   Jsi_Interp, maxDepth,    .help=\"Depth limit of recursive function calls (1000)\", .flags=JSI_OPT_LOCKSAFE),\n    JSI_OPT(INT,   Jsi_Interp, maxArrayList,.help=\"Maximum array convertable to list (100000)\", .flags=JSI_OPT_LOCKSAFE),\n    JSI_OPT(INT,   Jsi_Interp, maxIncDepth, .help=\"Maximum allowed source/require nesting depth (50)\", .flags=JSI_OPT_LOCKSAFE),\n    JSI_OPT(INT,   Jsi_Interp, maxInterpDepth,.help=\"Maximum nested subinterp create depth (10)\", .flags=JSI_OPT_LOCKSAFE),\n    JSI_OPT(INT,   Jsi_Interp, maxUserObjs, .help=\"Maximum number of 'new' object calls, eg. File, RegExp, etc\", .flags=JSI_OPT_LOCKSAFE ),\n    JSI_OPT(INT,   Jsi_Interp, maxOpCnt,    .help=\"Execution limit for op-code evaluation\", jsi_IIOF|JSI_OPT_LOCKSAFE ),\n    JSI_OPT(INT,   Jsi_Interp, memDebug,    .help=\"Memory debugging level: 1=summary, 2=detail\", .flags=JSI_OPT_NO_CLEAR),\n    JSI_OPT(STRKEY,Jsi_Interp, name,        .help=\"Optional text name for this interp\"),\n    JSI_OPT(BOOL,  Jsi_Interp, noAutoLoad,  .help=\"Disable autoload\", .flags=JSI_OPT_LOCKSAFE ),\n    JSI_OPT(BOOL,  Jsi_Interp, noConfig,    .help=\"Disable use of Interp.conf to change options after create\", jsi_IIOF),\n    JSI_OPT(BOOL,  Jsi_Interp, noInput,     .help=\"Disable use of console.input()\" ),\n    JSI_OPT(BOOL,  Jsi_Interp, noLoad,      .help=\"Disable load of shared libs\", .flags=JSI_OPT_LOCKSAFE),\n    JSI_OPT(BOOL,  Jsi_Interp, noNetwork,   .help=\"Disable new Socket/WebSocket, or load of builtin MySql\" ),\n    JSI_OPT(BOOL,  Jsi_Interp, noStderr,    .help=\"Make puts, log, assert, etc use stdout\" ),\n    JSI_OPT(BOOL,  Jsi_Interp, noSubInterps,.help=\"Disallow sub-interp creation\"),\n    JSI_OPT(FUNC,  Jsi_Interp, onComplete,  .help=\"Function to return commands completions for interactive mode.  Default uses Info.completions \", .flags=0, .custom=0, .data=(void*)\"prefix:string, start:number, end:number\" ),\n    JSI_OPT(FUNC,  Jsi_Interp, onEval,      .help=\"Function to get control for interactive evals\", .flags=0, .custom=0, .data=(void*)\"cmd:string\" ),\n    JSI_OPT(FUNC,  Jsi_Interp, onExit,      .help=\"Command to call in parent on exit, returns true to continue\", jsi_IIOF , .custom=0, .data=(void*)\"\"),\n    JSI_OPT(ARRAY, Jsi_Interp, pkgDirs,     .help=\"list of library directories for require() to search\" ),\n    JSI_OPT(BOOL,  Jsi_Interp, profile,     .help=\"On exit generate profile of function calls\"),\n    JSI_OPT(VALUE, Jsi_Interp, retValue,    .help=\"Return value from last eval\", jsi_IIRO),\n    JSI_OPT(CUSTOM,Jsi_Interp, safeMode,    .help=\"In safe mode source() support for pwd and script-dir \", jsi_IIOF, .custom=Jsi_Opt_SwitchEnum, .data=jsi_SafeModeStrs ),\n    JSI_OPT(ARRAY, Jsi_Interp, safeReadDirs,.help=\"In safe mode, files/dirs to allow reads to\", jsi_IIOF),\n    JSI_OPT(ARRAY, Jsi_Interp, safeWriteDirs,.help=\"In safe mode, files/dirs to allow writes to\", jsi_IIOF),\n    JSI_OPT(STRKEY, Jsi_Interp,safeExecPattern,.help=\"In safe mode, regexp pattern allow exec of commands\", jsi_IIOF),\n    JSI_OPT(STRKEY,Jsi_Interp, scriptStr,   .help=\"Interp init script string\", jsi_IIOF),\n    JSI_OPT(STRING,Jsi_Interp, scriptFile,  .help=\"Interp init script file\"),\n    JSI_OPT(STRING,Jsi_Interp, stdinStr,    .help=\"String to use as stdin for console.input()\"),\n    JSI_OPT(STRING,Jsi_Interp, stdoutStr,   .help=\"String to collect stdout for puts()\"),\n    JSI_OPT(BOOL,  Jsi_Interp, strict,      .help=\"Globally enable strict: same as 'use strict' in main program\"),\n    JSI_OPT(CUSTOM,Jsi_Interp, subOpts,     .help=\"Infrequently used sub-options\", .flags=0, .custom=Jsi_Opt_SwitchSuboption, .data=InterpSubOptions),\n    JSI_OPT(BOOL,  Jsi_Interp, subthread,   .help=\"Create a threaded Interp\", jsi_IIOF|JSI_OPT_LOCKSAFE),\n    JSI_OPT(CUSTOM,Jsi_Interp, traceCall,   .help=\"Trace commands\", .flags=0,  .custom=Jsi_Opt_SwitchBitset,  .data=jsi_callTraceStrs),\n    JSI_OPT(INT,   Jsi_Interp, traceOp,     .help=\"Set debugging level for OPCODE execution\"),\n    JSI_OPT(BOOL,  Jsi_Interp, tracePuts,   .help=\"Trace puts by making it use logOpts\" ),\n    JSI_OPT(CUSTOM,Jsi_Interp, typeCheck,   .help=\"Type-check control options\", .flags=0, .custom=Jsi_Opt_SwitchBitset, .data=jsi_TypeChkStrs),\n    JSI_OPT(INT,   Jsi_Interp, typeWarnMax, .help=\"Type checking is silently disabled after this many warnings (50)\" ),\n    JSI_OPT(OBJ,   Jsi_Interp, udata,       .help=\"User data\"),\n    JSI_OPT(UINT,  Jsi_Interp, unitTest,    .help=\"Unit test control bits: 1=subst, 2=Puts with file:line prefix\" ),\n    JSI_OPT_END(Jsi_Interp, .help=\"Options for the Jsi interpreter\")\n};\n\n/* Object for each interp created. */\ntypedef struct InterpObj {\n#ifdef JSI_HAS_SIG\n    jsi_Sig sig;\n#endif\n    Jsi_Interp *subinterp;\n    Jsi_Interp *parent;\n    //char *interpname;\n    char *mode;\n    Jsi_Obj *fobj;\n    int objId;\n    int deleting;\n} InterpObj;\n\n/* Global state of interps. */\n\ntypedef struct {\n#ifdef JSI_HAS_SIG\n    jsi_Sig sig;\n#endif\n    int refCount;\n    const char *cmdName;\n    Jsi_Value *args;\n    Jsi_Value *func;\n    Jsi_Value *cmdVal;\n    InterpObj *intobj;\n    Jsi_Interp *dinterp; // Dest interp.\n    Jsi_Interp *subinterp;\n} AliasCmd;\n\n\nstatic void interpObjErase(InterpObj *fo);\nstatic Jsi_RC interpObjFree(Jsi_Interp *interp, void *data);\nstatic bool interpObjIsTrue(void *data);\nstatic bool interpObjEqual(void *data1, void *data2);\n\nstatic Jsi_RC jsi_InterpConfFiles(Jsi_Interp *interp);\n\n/* Call a command with JSON args.  Returned string by using Jsi_ValueGetDString(..., flags). */\nJsi_RC Jsi_EvalCmdJSON(Jsi_Interp *interp, const char *cmd, const char *jsonArgs, Jsi_DString *dStr, int flags)\n{\n    if (Jsi_MutexLock(interp, interp->Mutex) != JSI_OK)\n        return JSI_ERROR;\n    Jsi_Value *nrPtr = Jsi_ValueNew1(interp);\n    Jsi_RC rc = Jsi_CommandInvokeJSON(interp, cmd, jsonArgs, &nrPtr);\n    Jsi_DSInit(dStr);\n    Jsi_ValueGetDString(interp, nrPtr, dStr, flags /*JSI_OUTPUT_JSON*/);\n    Jsi_DecrRefCount(interp, nrPtr);\n    Jsi_MutexUnlock(interp, interp->Mutex);\n    return rc;\n}\n\n/* Call a function with JSON args.  Return a primative. */\nJsi_RC Jsi_FunctionInvokeJSON(Jsi_Interp *interp, Jsi_Value *func, const char *json, Jsi_Value **ret)\n{\n    if (!Jsi_ValueIsFunction(interp, func))\n        return JSI_ERROR;\n    Jsi_Value *aPtr = Jsi_ValueNew1(interp);\n    Jsi_RC rc = Jsi_JSONParse(interp, json, &aPtr, 0);\n    if (rc == JSI_OK)\n        rc = Jsi_FunctionInvoke(interp, func, aPtr, ret, NULL);\n    Jsi_DecrRefCount(interp, aPtr);\n    return rc;\n}\n/* Lookup cmd from cmdstr and invoke with JSON args. */\n/*\n *   Jsi_CommandInvokeJSON(interp, \"info.cmds\", \"[\\\"*\\\",true]\", ret);\n */\nJsi_RC Jsi_CommandInvokeJSON(Jsi_Interp *interp, const char *cmdstr, const char *json, Jsi_Value **ret)\n{\n    Jsi_Value *func = Jsi_NameLookup(interp, cmdstr);\n    if (func)\n        return Jsi_FunctionInvokeJSON(interp, func, json, ret);\n    return Jsi_LogError(\"can not find cmd: %s\", cmdstr);\n}\n\n/* Clean-copying of value between interps: uses JSON parse if needed. */\nJsi_RC Jsi_CleanValue(Jsi_Interp *interp, Jsi_Interp *tointerp, Jsi_Value *val, Jsi_Value **ret)\n{\n    Jsi_RC rc = JSI_OK;\n    const char *cp;\n    int len, iskey;\n    Jsi_Obj *obj;\n    switch (val->vt) {\n        case JSI_VT_UNDEF: Jsi_ValueMakeUndef(interp, ret); return rc;\n        case JSI_VT_NULL: Jsi_ValueMakeNull(tointerp, ret); return rc;\n        case JSI_VT_BOOL: Jsi_ValueMakeBool(tointerp, ret, val->d.val); return rc;\n        case JSI_VT_NUMBER: Jsi_ValueMakeNumber(tointerp, ret, val->d.num); return rc;\n        case JSI_VT_STRING:\n            iskey = val->f.bits.isstrkey;\n            cp = val->d.s.str;\n            len = val->d.s.len;\nmakestr:\n            if (iskey) {\n                Jsi_ValueMakeStringKey(interp, ret, cp);\n                return rc;\n            }\n            jsi_ValueMakeBlobDup(tointerp, ret, (uchar*)cp, len);\n            return rc;\n        case JSI_VT_OBJECT:\n            obj = val->d.obj;\n            switch (obj->ot) {\n                case JSI_OT_BOOL: Jsi_ValueMakeBool(tointerp, ret, obj->d.val); return rc;\n                case JSI_OT_NUMBER: Jsi_ValueMakeNumber(tointerp, ret, obj->d.num); return rc;\n                case JSI_OT_STRING:\n                    cp = obj->d.s.str;\n                    len = obj->d.s.len;\n                    iskey = obj->isstrkey;\n                    goto makestr;\n                default: break;\n            }\n            break;\n        default:\n            break;\n    }\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    cp = Jsi_ValueGetDString(interp, val, &dStr, JSI_OUTPUT_JSON);\n    if (Jsi_JSONParse(tointerp, cp, ret, 0) != JSI_OK) {\n        Jsi_DSFree(&dStr);\n        return Jsi_LogWarn(\"bad JSON parse in subinterp\");\n    }\n    Jsi_DSFree(&dStr);\n    return rc;\n}\n\n/* Invoke command in target interp. */\nJsi_RC jsi_AliasInvoke(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    AliasCmd *ac = (AliasCmd *)funcPtr->cmdSpec->reserved[2];\n    Jsi_Interp *dinterp = ac->dinterp;\n    Jsi_Value *nargs = NULL;\n    int inc=0, argc = Jsi_ValueGetLength(interp, args);\n    if (!ac) {\n        Jsi_LogBug(\"BAD ALIAS INVOKE OF DELETED\");\n        return JSI_ERROR;\n    }\n    SIGASSERT(ac,ALIASCMD);\n    bool isthrd = (interp != dinterp && interp->threadId != dinterp->threadId);\n    Jsi_Value *nrPtr = Jsi_ValueNew1(dinterp);\n\n     if (argc == 0 && ac->args)\n        nargs = ac->args;\n     else if (argc) {\n        if (dinterp == interp)\n            Jsi_ValueCopy(interp, nrPtr, args);\n        else if (Jsi_CleanValue(interp, dinterp, args, &nrPtr) != JSI_OK)\n            return JSI_ERROR;\n        if (ac->args && Jsi_ValueGetLength(dinterp, ac->args)) {\n            nargs = Jsi_ValueArrayConcat(dinterp, ac->args, nrPtr);\n            Jsi_IncrRefCount(dinterp, nargs);\n            inc=1;\n        } else {\n            nargs = nrPtr;\n        }\n    }\n\n    if (isthrd) {\n        /* Post to thread event in sub-interps queue. */\n        if (Jsi_MutexLock(interp, dinterp->QMutex) != JSI_OK)\n            return JSI_ERROR;\n\n       /* Is an async call. */\n        InterpStrEvent *se, *s = (InterpStrEvent *)Jsi_Calloc(1, sizeof(*s));\n        // TODO: is s->data inited?\n        Jsi_DSInit(&s->data);\n        Jsi_ValueGetDString(interp, nargs, &s->data, JSI_OUTPUT_JSON);\n        if (inc)\n            Jsi_DecrRefCount(dinterp, nargs);\n        Jsi_DecrRefCount(dinterp, nrPtr);\n        s->acfunc = ac->func;\n        Jsi_IncrRefCount(dinterp, ac->func);\n        se = dinterp->interpStrEvents;\n        if (!se)\n            dinterp->interpStrEvents = s;\n        else {\n            while (se->next)\n                se = se->next;\n            se->next = s;\n        }\n\n        Jsi_MutexUnlock(interp, dinterp->QMutex);\n        return JSI_OK;\n    }\n\n    if (dinterp != interp) {\n        if (interp->subOpts.mutexUnlock) Jsi_MutexUnlock(interp, interp->Mutex);\n        if (Jsi_MutexLock(interp, dinterp->Mutex) != JSI_OK) {\n            if (interp->subOpts.mutexUnlock) Jsi_MutexLock(interp, interp->Mutex);\n            return JSI_ERROR;\n        }\n    }\n    ac->refCount++;\n    Jsi_Value *srPtr, **srpPtr = ret;\n    if (dinterp != interp) {\n        srPtr = Jsi_ValueNew1(dinterp);\n        srpPtr = &srPtr;\n    }\n    Jsi_RC rc = Jsi_FunctionInvoke(dinterp, ac->func, nargs, srpPtr, NULL);\n    ac->refCount--;\n    if (inc)\n        Jsi_DecrRefCount(dinterp, nargs);\n    Jsi_DecrRefCount(dinterp, nrPtr);\n    if (dinterp != interp) {\n        Jsi_MutexUnlock(interp, dinterp->Mutex);\n        if (interp->subOpts.mutexUnlock && Jsi_MutexLock(interp, interp->Mutex) != JSI_OK) {\n            return JSI_ERROR;\n        }\n    }\n    if (dinterp != interp) {\n        Jsi_CleanValue(dinterp, interp, *srpPtr, ret);\n        Jsi_DecrRefCount(dinterp, srPtr);\n        if (rc != JSI_OK && dinterp->errMsgBuf[0] && interp != dinterp) {\n            Jsi_Strcpy(interp->errMsgBuf, dinterp->errMsgBuf);\n            interp->errLine = dinterp->errLine;\n            interp->errFile = dinterp->errFile;\n            dinterp->errMsgBuf[0] = 0;\n        }\n    }\n    return rc;\n}\n\n\nstatic Jsi_RC jsi_AliasFree(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *data) {\n    /* TODO: deal with other copies of func may be floating around (refCount). */\n    AliasCmd *ac = (AliasCmd *)data;\n    if (!ac) return JSI_ERROR;\n    SIGASSERT(ac,ALIASCMD);\n    if (ac->func)\n        Jsi_DecrRefCount(ac->dinterp, ac->func);\n    if (ac->args)\n        Jsi_DecrRefCount(ac->dinterp, ac->args);\n    if (!ac->cmdVal)\n        return JSI_OK;\n    Jsi_Func *fobj = ac->cmdVal->d.obj->d.fobj->func;\n    fobj->cmdSpec->reserved[2] = NULL;\n    fobj->cmdSpec->proc = NULL;\n    if (ac->intobj && ac->intobj->subinterp) {\n        Jsi_CommandDelete(ac->intobj->subinterp, ac->cmdName);\n        //if (Jsi_Strchr(ac->cmdName, '.'))\n        //    Jsi_LogBug(\"alias free with X.Y dot name leaks memory: %s\", ac->cmdName);\n    } else\n        Jsi_DecrRefCount(ac->subinterp, ac->cmdVal);\n    _JSI_MEMCLEAR(ac);\n    Jsi_Free(ac);\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_AliasCreateCmd(Jsi_Interp* interp, const char* key, AliasCmd* ac) {\n    if (Jsi_InterpGone(interp))\n        return JSI_ERROR;\n    key = Jsi_KeyAdd(interp, key);\n    Jsi_Value *cmd = jsi_CommandCreate(interp, key, jsi_AliasInvoke, NULL, 0, 0);\n    if (!cmd)\n        return Jsi_LogBug(\"command create failure\");\n    ac->cmdVal = cmd;\n    Jsi_Func *fobj = cmd->d.obj->d.fobj->func;\n    fobj->cmdSpec->reserved[2] = ac;\n    cmd->d.obj->isNoOp = (ac->func->d.obj->d.fobj->func->callback == jsi_NoOpCmd);\n    return JSI_OK;\n}\n\n#define FN_intalias JSI_INFO(\"With 0 args, returns list of all aliases in interp.\\n\\\nWith 1 arg returns func for given alias name.\\n\\\nWith 2 args where arg2 == null, returns args for given alias name .\\n\\\nWith 3 args, create/update an alias for func and args. \\n\\\nDelete an alias by creating it with null for both func and args.\")\nstatic Jsi_RC InterpAliasCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    InterpObj *udf = (InterpObj *)Jsi_UserObjGetData(interp, _this, funcPtr);\n    Jsi_Interp *sinterp = (udf ? udf->subinterp : interp );\n    Jsi_Hash *aliases = sinterp->aliasHash;\n    if (!aliases)\n        return Jsi_LogError(\"Sub-interp gone\");\n    int argc = Jsi_ValueGetLength(interp, args);\n    if (argc == 0)\n        return Jsi_HashKeysDump(interp, aliases, ret, 0);\n    Jsi_HashEntry *hPtr;\n    char *key = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    if (!key)\n        return Jsi_LogError(\"expected string\");\n    AliasCmd* ac;\n    if (argc == 1) {\n        hPtr = Jsi_HashEntryFind(aliases, (void*)key);\n        if (!hPtr)\n            return JSI_OK;\n        ac = (AliasCmd*)Jsi_HashValueGet(hPtr);\n        if (!ac) return JSI_ERROR;\n        SIGASSERT(ac,ALIASCMD);\n        Jsi_ValueDup2(interp, ret, ac->func);\n        return JSI_OK;\n    }\n    Jsi_Value *afunc = Jsi_ValueArrayIndex(interp, args, 1);\n    if (argc == 2) {\n        hPtr = Jsi_HashEntryFind(aliases, (void*)key);\n        if (!hPtr)\n            return JSI_OK;\n        ac = (AliasCmd*)Jsi_HashValueGet(hPtr);\n        if (!Jsi_ValueIsNull(interp, afunc))\n            return Jsi_LogError(\"arg 2: expected null to query args\");\n        if (!ac) return JSI_ERROR;\n        SIGASSERT(ac,ALIASCMD);\n        Jsi_ValueDup2(interp, ret, ac->args); //TODO: JSON??\n        return JSI_OK;\n    }\n    \n    if (argc < 3)\n        return JSI_ERROR;\n    bool isthrd = (interp->threadId != sinterp->threadId);\n    //if (isthrd)\n        //return Jsi_LogError(\"alias not supported with threads\");\n    bool isNew;\n    Jsi_Value *aargs = Jsi_ValueArrayIndex(interp, args, 2);\n    if (Jsi_ValueIsNull(interp, afunc) && Jsi_ValueIsNull(interp, aargs)) {\n        hPtr = Jsi_HashEntryFind(aliases, (void*)key);\n        if (hPtr == NULL)\n            return JSI_OK;\n        ac = (AliasCmd*)Jsi_HashValueGet(hPtr);\n        if (!ac) return JSI_ERROR;\n        if (0 && ac->cmdVal)\n            Jsi_DecrRefCount(interp, ac->cmdVal);\n        jsi_AliasFree(interp, NULL, ac);\n        Jsi_HashValueSet(hPtr, NULL);\n        Jsi_HashEntryDelete(hPtr);\n        return JSI_OK;\n    }\n    hPtr = Jsi_HashEntryNew(aliases, (void*)key, &isNew);\n    if (!hPtr)\n        return Jsi_LogError(\"create failed: %s\", key);\n    if (!Jsi_ValueIsFunction(interp, afunc))\n        return Jsi_LogError(\"arg 2: expected function\");\n    if (Jsi_ValueIsNull(interp, aargs) == 0 && Jsi_ValueIsArray(interp, aargs) == 0)\n        return Jsi_LogError(\"arg 3: expected array or null\");\n    if (!isNew) {\n        jsi_AliasFree(interp, NULL, Jsi_HashValueGet(hPtr));\n    }\n    ac = (AliasCmd*)Jsi_Calloc(1, sizeof(AliasCmd));\n    SIGINIT(ac, ALIASCMD);\n    ac->cmdName = (const char*)Jsi_HashKeyGet(hPtr);\n    ac->func = afunc;\n    Jsi_IncrRefCount(interp, afunc);\n    if (!Jsi_ValueIsNull(interp, aargs)) {\n        ac->args = aargs;\n        Jsi_IncrRefCount(interp, aargs);\n    }\n    ac->intobj = udf;\n    ac->dinterp = interp;\n    ac->subinterp = sinterp;\n    Jsi_HashValueSet(hPtr, ac);\n    if (!isthrd)\n        return jsi_AliasCreateCmd(sinterp, key, ac);\n\n    Jsi_Value *vasync = Jsi_ValueArrayIndex(interp, args, 3);\n    bool async = 0;\n    if (vasync && Jsi_GetBoolFromValue(interp, vasync, &async))\n        return JSI_ERROR;\n        \n    if (!async) {\n        if (Jsi_MutexLock(interp, sinterp->Mutex) != JSI_OK)\n            return JSI_ERROR;\n        Jsi_RC rc = jsi_AliasCreateCmd(sinterp, key, ac);\n        Jsi_MutexUnlock(interp, sinterp->Mutex);\n        return rc;\n    }\n\n    /* Post to thread event in sub-interps queue. */\n    if (Jsi_MutexLock(interp, sinterp->QMutex) != JSI_OK)\n        return JSI_ERROR;\n\n    /* Is an async call. */\n    InterpStrEvent *se, *s = (InterpStrEvent *)Jsi_Calloc(1, sizeof(*s));\n    // TODO: is s->data inited?\n    s->acdata = ac;\n    Jsi_DSInit(&s->func);\n    Jsi_DSAppend(&s->func, ac->cmdName, NULL);\n    se = sinterp->interpStrEvents;\n    if (!se)\n        sinterp->interpStrEvents = s;\n    else {\n        while (se->next)\n            se = se->next;\n        se->next = s;\n    }\n\n    Jsi_MutexUnlock(interp, sinterp->QMutex);\n    return JSI_OK;\n}\n\nstatic Jsi_RC freeCodeTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    jsi_Pstate *ps = (jsi_Pstate *)ptr;\n    if (!ps) return JSI_OK;\n    ps->hPtr = NULL;\n    jsi_PstateFree(ps);\n    return JSI_OK;\n}\n\nstatic Jsi_RC freeOnDeleteTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    if (!ptr) return JSI_OK;\n    Jsi_DeleteProc *proc = (Jsi_DeleteProc *)ptr;\n    proc(interp, NULL);\n    return JSI_OK;\n}\n\nstatic Jsi_RC freeAssocTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    if (!ptr) return JSI_OK;\n    jsi_DelAssocData(interp, ptr);\n    return JSI_OK;\n}\n\nstatic Jsi_RC freeEventTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    Jsi_Event *event = (Jsi_Event *)ptr;\n    SIGASSERT(event,EVENT);\n    if (!ptr) return JSI_OK;\n    Jsi_HashValueSet(event->hPtr, NULL);\n    event->hPtr = NULL;\n    Jsi_EventFree(interp, event);\n    return JSI_OK;\n}\nJsi_RC jsi_HashFree(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    Jsi_Free(ptr);\n    return JSI_OK;\n}\n\n\nstatic Jsi_RC packageHashFree(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    jsi_PkgInfo *p = (jsi_PkgInfo*)ptr;\n    if (p->popts.info) Jsi_DecrRefCount(interp, p->popts.info);\n    Jsi_Free(p);\n    return JSI_OK;\n}\n\nstatic Jsi_RC regExpFree(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    Jsi_RegExpFree((Jsi_Regex*)ptr);\n    return JSI_OK;\n}\n\nstatic Jsi_RC freeCmdSpecTbl(Jsi_Interp *interp, Jsi_MapEntry *hPtr, void *ptr) {\n    if (!ptr) return JSI_OK;\n    jsi_CmdSpecDelete(interp, ptr);\n    return JSI_OK;\n}\n\nstatic Jsi_RC freeGenObjTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    Jsi_Obj *obj = (Jsi_Obj *)ptr;\n    SIGASSERT(obj,OBJ);\n    if (!obj) return JSI_OK;\n    Jsi_ObjDecrRefCount(interp, obj);\n    return JSI_OK;\n}\n\n\nstatic Jsi_RC freeFuncsTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    Jsi_Func *func = (Jsi_Func *)ptr;\n    if (!func) return JSI_OK;\n    SIGASSERT(func,FUNC);\n    func->hPtr = NULL;\n    jsi_FuncFree(interp, func);\n    return JSI_OK;\n}\n\nstatic Jsi_RC freeFuncObjTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    Jsi_Obj *v = (Jsi_Obj *)ptr;\n    if (!v) return JSI_OK;\n    SIGASSERT(v,OBJ);\n    if (v->ot != JSI_OT_FUNCTION)\n        fprintf(stderr, \"invalid func obj\\n\");\n    else if (v->d.fobj) {\n        if (v->d.fobj->scope) {\n            jsi_ScopeChain *scope = v->d.fobj->scope;\n            v->d.fobj->scope = NULL;\n            jsi_ScopeChainFree(interp, scope);\n        }\n    }\n    Jsi_ObjDecrRefCount(interp, v);\n    return JSI_OK;\n}\n\nstatic Jsi_RC freeBindObjTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    Jsi_Obj *v = (Jsi_Obj *)ptr;\n    if (!v) return JSI_OK;\n    SIGASSERT(v,OBJ);\n    if (v->ot != JSI_OT_FUNCTION)\n        fprintf(stderr, \"invalid func obj\\n\");\n    else if (v->d.fobj && v->d.fobj->scope) {\n        v->d.fobj->scope = NULL;\n    }\n    Jsi_ObjDecrRefCount(interp, v);\n    return JSI_OK;\n}\n\n/* TODO: incr ref before add then just decr till done. */\nstatic Jsi_RC freeValueTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    Jsi_Value *val = (Jsi_Value *)ptr;\n    if (!val) return JSI_OK;\n    SIGASSERT(val,VALUE);\n    //printf(\"GEN: %p\\n\", val);\n   /* if (val->refCnt>1)\n        Jsi_DecrRefCount(interp, val);*/\n    Jsi_DecrRefCount(interp, val);\n    return JSI_OK;\n}\n\nstatic Jsi_RC freeUserdataTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    if (ptr)\n        jsi_UserObjDelete(interp, ptr);\n    return JSI_OK;\n}\n\nvoid Jsi_ShiftArgs(Jsi_Interp *interp, Jsi_Value *v) {\n    if (!v)\n        v = interp->args;\n    if (v==NULL || v->vt != JSI_VT_OBJECT || v->d.obj->arr == NULL || v->d.obj->arrCnt <= 0)\n        return;\n    Jsi_Obj *obj = v->d.obj;\n    int n = v->d.obj->arrCnt;\n    n--;\n    v = obj->arr[0];\n    if (v)\n        Jsi_DecrRefCount(interp, v);\n    if (n>0)\n        memmove(obj->arr, obj->arr+1, n*sizeof(Jsi_Value*));\n    obj->arr[n] = NULL;\n    Jsi_ObjSetLength(interp, obj, n);\n}\n\nJsi_Value *Jsi_Executable(Jsi_Interp *interp)\n{\n    return jsiIntData.execValue;\n}\n\nstatic Jsi_RC KeyLocker(Jsi_Hash* tbl, int lock)\n{\n    if (!lock)\n        Jsi_MutexUnlock(jsiIntData.mainInterp, jsiIntData.mainInterp->Mutex);\n    else\n        return Jsi_MutexLock(jsiIntData.mainInterp, jsiIntData.mainInterp->Mutex);\n    return JSI_OK;\n}\n\n#ifdef JSI_USE_MANY_STRKEY\nstatic Jsi_RC KeyLockerTree(Jsi_Tree* tree, int lock) { return KeyLocker((Jsi_Hash*)tree, lock); }\n#endif\n\nstatic int jsi_deleted = 0, jsi_exitCode = 0; // TODO: move to jsiIntData\nstatic Jsi_Value *jsi_vf = NULL;\n\nstatic Jsi_RC jsi_InterpDelete(Jsi_Interp *interp, void *ptr) {\n    if (jsi_vf)\n        Jsi_DecrRefCount(interp, jsi_vf);\n    jsi_vf = NULL;\n    jsi_exitCode = interp->exitCode;\n    jsi_deleted = 1;\n    return JSI_OK;\n}\n\nJsi_Interp* Jsi_Main(Jsi_InterpOpts *opts)\n{\n    Jsi_RC rc = JSI_OK;\n    Jsi_Interp* interp = NULL;\n    int argc = 0, first = 1;\n    char **argv = NULL;\n    if (opts) {\n        interp = opts->interp;\n        argc = opts->argc;\n        argv = opts->argv;\n    }\n    if (!interp)\n        interp = Jsi_InterpNew(opts);\n    if (!interp)\n        return NULL;\n    Jsi_InterpOnDelete(interp, &jsi_InterpDelete, (void*)&jsi_InterpDelete);\n    argc -= interp->iskips;\n    argv += interp->iskips;\n\n#ifndef NO_JAZ\n    /* Mount zip at end of executable */\n    Jsi_Value *v = Jsi_Executable(interp);\n    const char *exeFile = (v?Jsi_ValueString(interp, v, NULL):NULL);\n    int jsFound = 0;\n    if (v && (argc != 2 || Jsi_Strcmp(argv[1], \"--nozvfs\"))) {\n        rc = Jsi_EvalZip(interp, exeFile, JSI_ZVFS_DIR, &jsFound);\n        if (rc == JSI_OK) {\n            interp->selfZvfs = 1;\n            if (!jsFound) {\n#if (JSI__FILESYS && JSI__ZVFS)\n                fprintf(stderr, \"warning: no main.jsi or autoload.jsi\\n\");\n#endif\n            }\n            if (jsi_deleted)\n                return jsi_DoExit(interp, jsi_exitCode);\n            else if (rc != 0) {\n                fprintf(stderr, \"Error\\n\");\n                return jsi_DoExit(interp, 1);\n            }\n        }\n    }\n#endif\n    const char *ext = NULL, *ai1, *iext = (argc<=1?NULL:Jsi_Strrchr(argv[1], '.'));\n    if (interp->selfZvfs && iext && Jsi_Strcmp(iext,\".fossil\")==0) {\n        rc = Jsi_EvalString(interp, \"runModule('Archive');\", JSI_EVAL_ISMAIN);\n        goto done;\n    }\n    Jsi_ShiftArgs(interp, NULL);\n    if (argc <= 1) {\n        if (interp->opts.no_interactive && !interp->interactive)\n            return interp;\n        rc = Jsi_Interactive(interp, JSI_OUTPUT_QUOTE|JSI_OUTPUT_NEWLINES);\n        goto done;\n    }\n    ai1 = argv[1];\n    if ((!Jsi_Strcmp(ai1, \"-help\") || !Jsi_Strcmp(ai1, \"-h\")) && argc<=3) {\n        if (argc>2) {\n            if (Jsi_PkgRequire(interp, \"Help\", 0)>=0) {\n                char tbuf[BUFSIZ];\n                snprintf(tbuf, sizeof(tbuf), \"return runModule('Help', '%s'.trim().split(null));\", argv[2]);\n                Jsi_RC rc = Jsi_EvalString(interp, tbuf, 0);\n                const char *hstr = Jsi_ValueToString(interp, interp->retValue, NULL);\n                if (rc == JSI_OK)\n                    puts(hstr);\n                return jsi_DoExit(interp, 1);\n            }\n        }\n        dohelp:\n        puts(\"USAGE:\\n  jsish [PREFIX-OPTS] [COMMAND-OPTS|FILE] ...\\n\"\n          \"\\nPREFIX-OPTS:\\n\"\n          \"  --C FILE\\tOption file of config options.\\n\"\n          \"  --F\\t\\tTrace all function calls and returns.\\n\"\n          \"  --I OPT:VAL\\tInterp option: equivalent to Interp.conf({OPT:VAL}).\\n\"\n          \"  --L PATH\\tSet safeMode to \\\"lockdown\\\" using PATH for safe(Read/Write)Dirs.\\n\"\n          \"  --T OPT\\tTypecheck option: equivalent to \\\"use OPT\\\".\\n\"\n          \"  --U\\t\\tDisplay unittest output, minus pass/fail compare.\\n\"\n          \"  --V\\t\\tSame as --U, but adds file and line number to output.\\n\"\n          \"\\nCOMMAND-OPTS:\\n\"\n          \"  -a\\t\\tArchive: mount an archive (zip, sqlar or fossil repo) and run module.\\n\"\n          \"  -c\\t\\tCData: generate .c or JSON output from a .jsc description.\\n\"\n          \"  -d\\t\\tDebug: console script debugger.\\n\"\n          \"  -e CODE ...\\tEvaluate javascript CODE.\\n\"\n          \"  -g\\t\\tGendeep: generate html output from markdeep source.\\n\"\n          \"  -h ?CMD?\\tHelp: show help for jsish or its commands.\\n\"\n          \"  -m\\t\\tModule: utility create/manage/invoke a Module.\\n\"\n          \"  -s\\t\\tSafe: runs script in safe sub-interp.\\n\"\n          \"  -u\\t\\tUnitTest: test script file(s) or directories .js/.jsi files.\\n\"\n          \"  -w\\t\\tWget: web client to download file from url.\\n\"\n          \"  -v\\t\\tVersion: show version detail: add an arg to show only X.Y.Z\\n\"\n          \"  -z\\t\\tZip: append/manage zip files at end of executable.\\n\"\n          \"  -D\\t\\tDebugUI: web-gui script debugger.\\n\"\n          \"  -J\\t\\tJSpp: preprocess javascript for web.\\n\"\n          \"  -S\\t\\tSqliteUI: web-gui for sqlite database file.\\n\"\n          \"  -W\\t\\tWebsrv: web server to serve out content.\\n\"\n          \"\\nInterp options may also be set via the confFile.'\\n\"\n           );\n        return jsi_DoExit(interp, 1);\n    }\n    if (!Jsi_Strcmp(ai1, \"-version\"))\n        ai1 = \"-v\";\n    if (ai1[0] == '-') {\n        switch (ai1[1]) {\n            case 'a':\n                rc = Jsi_EvalString(interp, \"runModule('Archive');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'c':\n                rc = Jsi_EvalString(interp, \"runModule('Cdata');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'd':\n                interp->debugOpts.isDebugger = 1;\n                rc = Jsi_EvalString(interp, \"runModule('Debug');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'D':\n                interp->debugOpts.isDebugger = 1;\n                rc = Jsi_EvalString(interp, \"runModule('DebugUI');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'e':\n                if (argc < 3)\n                    rc = Jsi_LogError(\"missing argument\");\n                else {\n                    rc = Jsi_EvalString(interp, argv[2], JSI_EVAL_ISMAIN|JSI_EVAL_NOSKIPBANG);\n                    if (rc == JSI_OK && argc>3) {\n                        first += 2;\n                        Jsi_ShiftArgs(interp, NULL);\n                        Jsi_ShiftArgs(interp, NULL);\n                        goto dofile;\n                    }\n                }\n                break;\n            case 'g':\n                rc = Jsi_EvalString(interp, \"runModule('GenDeep');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'h':\n                goto dohelp;\n            case 'J':\n                rc = Jsi_EvalString(interp, \"runModule('Jspp');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'm':\n                if (argc <= 2 || argv[2][0] == '-')\n                    rc = Jsi_EvalString(interp, \"runModule('Module');\", JSI_EVAL_ISMAIN);\n                else {\n                    Jsi_DString dStr = {}, eStr = {};\n                    const char *cps, *cpe;\n                    cps = Jsi_Strrchr(argv[2], '/');\n                    if (cps) cps++; else cps = argv[2];\n                    cpe = Jsi_Strrchr(cps, '.');\n                    int len = (cpe?cpe-cps:(int)Jsi_Strlen(cps));\n                    if (cpe)\n                        Jsi_DSPrintf(&dStr, \"source(\\\"%s\\\");\", argv[2]);\n                    else\n                        Jsi_DSPrintf(&dStr, \"require(\\\"%s\\\");\", argv[2]);\n                    Jsi_DSPrintf(&dStr, \"puts(runModule(\\\"%.*s\\\",console.args.slice(1)));\", len, cps);\n                    rc = Jsi_EvalString(interp, Jsi_DSValue(&dStr), JSI_EVAL_NOSKIPBANG);\n                    Jsi_DSFree(&dStr);\n                    Jsi_DSFree(&eStr);\n                }\n                break;\n            case 's':\n                rc = Jsi_EvalString(interp, \"runModule('Safe');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'S':\n                rc = Jsi_EvalString(interp, \"runModule('SqliteUI');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'u':\n                rc = Jsi_EvalString(interp, \"exit(runModule('UnitTest'));\", JSI_EVAL_ISMAIN);\n                break;\n            case 'v': {\n                char str[200] = \"\\n\";\n                    \n                Jsi_Value* fval = Jsi_ValueNewStringKey(interp, \"/zvfs/lib/sourceid.txt\");\n                if (!Jsi_Access(interp, fval, R_OK)) {\n                    Jsi_Channel chan = Jsi_Open(interp, fval, \"r\");\n                    if (chan)\n                        Jsi_Read(interp, chan, str, sizeof(str));\n                }\n                if (argc>2)\n                    printf(\"%u.%u.%u\\n\", JSI_VERSION_MAJOR, JSI_VERSION_MINOR, JSI_VERSION_RELEASE);\n                else \n                    printf(\"%u.%u.%u %.\" JSI_VERFMT_LEN JSI_NUMGFMT \" %s\", JSI_VERSION_MAJOR, JSI_VERSION_MINOR, JSI_VERSION_RELEASE, Jsi_Version(), str);\n                return jsi_DoExit(interp, 1);\n            }\n            case 'w':\n                rc = Jsi_EvalString(interp, \"runModule('Wget');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'W':\n                rc = Jsi_EvalString(interp, \"runModule('Websrv');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'z':\n                rc = Jsi_EvalString(interp, \"runModule('Zip');\", JSI_EVAL_ISMAIN);\n                break;\n            default:\n                puts(\"usage: jsish [  --C FILE | --I OPT:VAL | --L PATH | --T OPT | --U | --V | --F ] | -e STRING |\\n\\t\"\n                \"| -a | -c | -d | -D | -h | -m | -s | -S | -u | -v | -w | -W | -z | FILE ...\\nUse -help for long help.\");\n                return jsi_DoExit(interp, 1);\n        }\n    } else {\ndofile:\n        ext = Jsi_Strrchr(argv[first], '.');\n\n        /* Support running \"main.jsi\" from a zip file. */\n        if (ext && (Jsi_Strcmp(ext,\".zip\")==0 ||Jsi_Strcmp(ext,\".jsz\")==0 ) ) {\n            rc = Jsi_EvalZip(interp, argv[first], NULL, &jsFound);\n            if (rc<0) {\n                fprintf(stderr, \"zip mount failed\\n\");\n                return jsi_DoExit(interp, 1);\n            }\n            if (!(jsFound&JSI_ZIP_MAIN)) {\n                fprintf(stderr, \"main.jsi not found\\n\");\n                return jsi_DoExit(interp, 1);\n            }\n        } else if (ext && !Jsi_Strcmp(ext,\".jsc\")) {\n            Jsi_DString dStr = {};\n            Jsi_DSPrintf(&dStr, \"console.args.unshift('%s'); runModule('CData');\", argv[first]);\n            rc = Jsi_EvalString(interp, Jsi_DSValue(&dStr), JSI_EVAL_ISMAIN|JSI_EVAL_NOSKIPBANG);\n            Jsi_DSFree(&dStr);\n\n        } else {\n            if (argc>1) {\n                jsi_vf = Jsi_ValueNewStringKey(interp, argv[first]);\n                Jsi_IncrRefCount(interp, jsi_vf);\n            }\n            rc = Jsi_EvalFile(interp, jsi_vf, JSI_EVAL_ARGV0|JSI_EVAL_AUTOINDEX|JSI_EVAL_ISMAIN);\n            if (jsi_vf) {\n                Jsi_DecrRefCount(interp, jsi_vf);\n                jsi_vf = NULL;\n            }\n\n        }\n    }\n    if (jsi_deleted) //TODO: rationalize jsi_deleted, jsi_exitCode, etc\n        return jsi_DoExit(rc==JSI_EXIT?NULL:interp, jsi_exitCode);\n    if (rc == JSI_OK) {\n        /* Skip output from an ending semicolon which evaluates to undefined */\n        Jsi_Value *ret = Jsi_ReturnValue(interp);\n        if (!Jsi_ValueIsType(interp, ret, JSI_VT_UNDEF)) {\n            Jsi_DString dStr = {};\n            fputs(Jsi_ValueGetDString(interp, ret, &dStr, 0), stdout);\n            Jsi_DSFree(&dStr);\n            fputs(\"\\n\", stdout);\n        }\n    } else {\n        if (!interp->parent && !interp->isHelp)\n            fprintf(stderr, \"ERROR: %s\\n\", interp->errMsgBuf);\n        return jsi_DoExit(interp, 1);\n    }\n\ndone:\n    if (rc == JSI_EXIT) {\n        if (opts)\n            opts->exitCode = jsi_exitCode;\n        return NULL;\n    }\n    if (jsi_deleted == 0 && interp->opts.auto_delete) {\n        Jsi_InterpDelete(interp);\n        return NULL;\n    }\n    return interp;\n}\n\nbool jsi_ModBlacklisted(Jsi_Interp *interp, const char *mod) {\n    if (!interp->subOpts.blacklist) return false;\n    const char *blstr =Jsi_Strstr(interp->subOpts.blacklist, mod);\n    if (!blstr) return false;\n    if ((blstr==interp->subOpts.blacklist || !isalnum(blstr[-1])) && !isalnum(blstr[Jsi_Strlen(mod)]))\n        return false;\n    return true;\n}\n\n// Get control during script evaluation to support debugging.\nstatic Jsi_RC jsi_InterpDebugHook(struct Jsi_Interp* interp, const char *curFile,\n    int curLine, int curLevel, const char *curFunc, const char *opCode, jsi_OpCode *op, const char *emsg)\n{\n    // TODO: when code is run in debugger, parser.y should attribute op for case stmt to skip str compares, etc.\n    int isfun=0;\n    if (interp->isInCallback || curLine<=0)\n        return JSI_OK;\n    if (op && op->nodebug)\n        return JSI_OK;\n    int isbp = 0, bpId = 0, cont = interp->debugOpts.doContinue,\n        stop = (interp->debugOpts.noFilter || interp->debugOpts.forceBreak);\n    if (!curFunc)\n        curFunc = \"\";\n\n    if (interp->parent && interp->parent->sigmask) {\n        interp->parent->sigmask = 0;\n        opCode = \"SIGINT\";\n\n    } else if (Jsi_Strcmp(opCode, \"DEBUG\") || !interp->parent) {\n\n        // Avoid overhead of multiple ops on same line of code.\n        int sameLine = (interp->debugOpts.lastLine == curLine && interp->debugOpts.lastLevel == curLevel\n            && interp->debugOpts.lastFile == curFile);\n\n        if (sameLine && stop==0 && (interp->debugOpts.bpLast==0\n            || (interp->debugOpts.bpOpCnt+10) >= interp->opCnt)) //TODO: need better way to detect bp dups.\n            goto done;\n\n        if (!interp->debugOpts.debugCallback || !interp->parent) {\n            fprintf(stderr, \"FILE %s:%d (%d) %s %s\\n\", curFile, curLine, curLevel, curFunc, opCode);\n            return JSI_OK;\n        }\n\n        // Check for breakpoints.\n        if (interp->breakpointHash) {\n            Jsi_HashEntry *hPtr;\n            Jsi_HashSearch search;\n            for (hPtr = Jsi_HashSearchFirst(interp->breakpointHash, &search);\n                hPtr != NULL && stop == 0; hPtr = Jsi_HashSearchNext(&search)) {\n                jsi_BreakPoint* bptr = (jsi_BreakPoint*)Jsi_HashValueGet(hPtr);\n                if (bptr == NULL || bptr->enabled == 0) continue;\n                if (bptr->func)\n                    stop = (!Jsi_Strcmp(bptr->func, curFunc));\n                else\n                    stop = (bptr->line == curLine && !Jsi_Strcmp(bptr->file, curFile));\n                if (stop) {\n                    isbp = 1;\n                    bpId = bptr->id;\n                    bptr->hits++;\n                    if (bptr->temp)\n                        bptr->enabled = 0;\n                }\n            }\n        }\n\n        if (stop == 0) { // No breakpoint.\n            if (cont  // Cmd is \"continue\"\n                // Handle \"next\" by skipping calls into functions.\n                || (interp->debugOpts.minLevel>0 && curLevel>interp->debugOpts.minLevel)\n                || (isfun=(Jsi_Strcmp(opCode, \"PUSHVAR\")==0 && op[1].op == OP_PUSHFUN)))\n            {\n                if (isfun) {\n                    interp->debugOpts.lastLine = curLine;\n                    interp->debugOpts.lastLevel = curLevel;\n                    interp->debugOpts.lastFile = curFile;\n                }\ndone:\n                return JSI_OK;\n            }\n        }\n    }\n    interp->debugOpts.bpLast = isbp;\n    interp->debugOpts.bpOpCnt = interp->opCnt;\n    interp->debugOpts.lastLine = curLine;\n    interp->debugOpts.lastLevel = curLevel;\n    interp->debugOpts.lastFile = curFile;\n    interp->debugOpts.forceBreak = 0;\n\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    if (emsg && Jsi_Strchr(emsg,'\\\"'))\n        emsg = 0;\n    Jsi_DSPrintf(&dStr, \"[\\\"%s\\\", %d, %d, \\\"%s\\\", \\\"%s\\\", %d, \\\"%s\\\"]\", curFile?curFile:\"\", curLine, curLevel, curFunc, opCode, bpId, emsg?emsg:\"\");\n    interp->isInCallback = 1;\n    Jsi_RC rc = JSI_ERROR;\n    if (interp->debugOpts.debugCallback)\n        rc = Jsi_FunctionInvokeJSON(interp->parent, interp->debugOpts.debugCallback, Jsi_DSValue(&dStr), &interp->retValue);\n    interp->isInCallback = 0;\n    if (interp->parent->exited == 0 && rc != JSI_OK)\n        Jsi_LogError(\"debugger failure\");\n    return rc;\n}\n\nJsi_RC jsi_ParseTypeCheckStr(Jsi_Interp *interp, const char *str) {\n    uint *iptr = (uint*)&interp->typeCheck;\n    const char *wcp = str, *wcn = wcp;\n    while (wcn && wcp) {\n        int isnot = 0;\n        if (*wcp == '!') { isnot = 1; wcp++; }\n        wcn = Jsi_Strchr(wcp, ',');\n        int ti, wlen = (wcn?(wcn-wcp):(int)Jsi_Strlen(wcp));\n#define _JSIPARSETYPES(nam, field) \\\n        if (wlen == (sizeof(#nam)-1) && !Jsi_Strncmp(#nam, wcp, (sizeof(#nam)-1))) { \\\n            interp->field = (1-isnot); \\\n            wcp = (wcn?wcn+1:NULL); \\\n            continue; \\\n        }\n        _JSIPARSETYPES(Debug, logOpts.Debug)\n        _JSIPARSETYPES(Trace, logOpts.Trace)\n        _JSIPARSETYPES(Test,  logOpts.Test)\n        _JSIPARSETYPES(Info, logOpts.Info)\n        _JSIPARSETYPES(Warn, logOpts.Warn)\n        _JSIPARSETYPES(Error,  logOpts.Error)\n        _JSIPARSETYPES(full,  logOpts.full)\n        _JSIPARSETYPES(before,  logOpts.before)\n        _JSIPARSETYPES(time,  logOpts.time)\n        _JSIPARSETYPES(date,  logOpts.date)\n        _JSIPARSETYPES(asserts, asserts)\n        _JSIPARSETYPES(assert, asserts)\n        _JSIPARSETYPES(noproto, subOpts.noproto)\n\n        const char **tstrs = jsi_TypeChkStrs;\n        for (ti=0; tstrs[ti]; ti++) {\n            wlen = Jsi_Strlen(tstrs[ti]);\n            if (!Jsi_Strncmp(tstrs[ti], wcp, wlen) && (!tstrs[ti][wlen] || tstrs[ti][wlen] == ',')) break;\n        }\n        if (tstrs[ti]) {\n            if (isnot)\n                *iptr &= ~(1<<ti);\n            else {\n                *iptr |= (1<<ti);\n                if (!Jsi_Strcmp(tstrs[ti], \"all\"))\n                    interp->typeCheck.parse = interp->typeCheck.run = 1;\n                if (!Jsi_Strcmp(tstrs[ti], \"strict\")) {\n                    interp->typeCheck.parse = interp->typeCheck.run = interp->typeCheck.all = 1;\n                    if (interp->framePtr->level<=0 || interp->isMain)\n                        interp->strict = 1;\n                }\n            }\n        } else {\n            Jsi_DString wStr = {};\n            int i;\n            tstrs = jsi_TypeChkStrs;\n            for (i=0; tstrs[i]; i++) Jsi_DSAppend(&wStr, i?\", \":\"\", tstrs[i], NULL);\n            Jsi_LogWarn(\"unknown typeCheck warn option(s) \\\"%s\\\" not in: Debug, Trace, Test, Info, Warn, Error, assert, %s, noproto, full, before, time, date\", str, Jsi_DSValue(&wStr));\n            Jsi_DSFree(&wStr);\n        }\n        wcp = (wcn?wcn+1:NULL);\n    }\n    return JSI_OK;\n}\n\nstatic Jsi_Interp* jsi_InterpNew(Jsi_Interp *parent, Jsi_Value *opts, Jsi_InterpOpts *iopts)\n{\n    Jsi_Interp* interp;\n    if (parent && parent->noSubInterps) {\n        interp = parent;\n        Jsi_LogError(\"subinterps disallowed\");\n        return NULL;\n    }\n    if (opts && parent && (Jsi_ValueIsObjType(parent, opts, JSI_OT_OBJECT)==0 ||\n        Jsi_TreeSize(opts->d.obj->tree)<=0))\n        opts = NULL;\n    interp = (Jsi_Interp *)Jsi_Calloc(1,sizeof(*interp) + sizeof(jsi_Frame));\n    interp->framePtr = (jsi_Frame*)(((uchar*)interp)+sizeof(*interp));\n    if (!parent)\n        interp->maxInterpDepth = JSI_MAX_SUBINTERP_DEPTH;\n    else {\n        interp->maxInterpDepth = parent->maxInterpDepth;\n        interp->interpDepth = parent->interpDepth+1;\n        if (interp->interpDepth > interp->maxInterpDepth) {\n            Jsi_Free(interp);\n            interp = parent;\n            Jsi_LogError(\"exceeded max subinterp depth\");\n            return NULL;\n        }\n    }\n    interp->maxDepth = JSI_MAX_EVAL_DEPTH;\n    interp->maxIncDepth = JSI_MAX_INCLUDE_DEPTH;\n    interp->typeWarnMax = 50;\n    interp->subOpts.dblPrec = __DBL_DECIMAL_DIG__-1;\n    interp->subOpts.prompt = \"$ \";\n    interp->subOpts.prompt2 = \"> \";\n\n    int iocnt;\n    if (iopts) {\n        iopts->interp = interp;\n        interp->opts = *iopts;\n    }\n    interp->logOpts.file = 1;\n    interp->logOpts.func = 1;\n    interp->logOpts.Info = 1;\n    interp->logOpts.Warn = 1;\n    interp->logOpts.Error = 1;\n    int argc = interp->opts.argc;\n    char **argv = interp->opts.argv;\n    char *argv0 = (argv?argv[0]:NULL);\n    interp->parent = parent;\n    interp->topInterp = (parent == NULL ? interp: parent->topInterp);\n    if (jsiIntData.mainInterp == NULL)\n        jsiIntData.mainInterp = interp->topInterp;\n    interp->mainInterp = jsiIntData.mainInterp; // The first interps handles exit.\n    interp->memDebug = interp->opts.mem_debug;\n    if (parent) {\n        interp->dbPtr = parent->dbPtr;\n    } else {\n        interp->dbPtr = &interp->dbStatic;\n    }\n#ifdef JSI_MEM_DEBUG\n    if (!interp->dbPtr->valueDebugTbl) {\n        interp->dbPtr->valueDebugTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, NULL);\n        interp->dbPtr->objDebugTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, NULL);\n    }\n#endif\n    if (parent) {\n        if (parent->pkgDirs)\n            interp->pkgDirs = Jsi_ValueDupJSON(interp, parent->pkgDirs);\n    } else {\n#ifdef JSI_PKG_DIRS\n        interp->pkgDirs = Jsi_StringSplit(interp, JSI_PKG_DIRS, \",\");\n        Jsi_IncrRefCount(interp, interp->pkgDirs);\n#endif\n    }\n#ifdef JSI_USE_COMPAT\n    interp->compat = JSI_USE_COMPAT;\n#endif\n#ifndef JSI_CONF_ARGS\n#define JSI_CONF_ARGS \"\"\n#endif\n    interp->confArgs = JSI_CONF_ARGS;\n    for (iocnt = 1; (iocnt+1)<argc; iocnt+=2)\n    {\n        const char *aio = argv[iocnt];\n        if (Jsi_Strcmp(aio, \"--T\") == 0 || Jsi_Strcmp(aio, \"--C\") == 0 || Jsi_Strcmp(aio, \"--L\") == 0) {\n            continue;\n        }\n        if (Jsi_Strcmp(aio, \"--F\") == 0 || Jsi_Strcmp(aio, \"--U\") == 0 || Jsi_Strcmp(aio, \"--V\") == 0) {\n            iocnt--;\n            continue;\n        }\n        if (!Jsi_Strcmp(aio, \"--I\")) {\n            const char *aio2 = argv[iocnt+1];\n            if (!Jsi_Strncmp(\"memDebug:\", aio2, sizeof(\"memDebug\")))\n                interp->memDebug=strtol(aio2+sizeof(\"memDebug\"), NULL, 0);\n            else if (!Jsi_Strncmp(\"compat\", aio2, sizeof(\"compat\")))\n                interp->subOpts.compat=strtol(aio2+sizeof(\"compat\"), NULL, 0);\n            continue;\n        }\n        break;\n    }\n    SIGINIT(interp,INTERP);\n    interp->NullValue = Jsi_ValueNewNull(interp);\n    Jsi_IncrRefCount(interp, interp->NullValue);\n#ifdef __WIN32\n    Jsi_DString cwdStr;\n    Jsi_DSInit(&cwdStr);\n    interp->curDir = Jsi_Strdup(Jsi_GetCwd(interp, &cwdStr));\n    Jsi_DSFree(&cwdStr);\n#else\n    char buf[JSI_BUFSIZ];\n    interp->curDir = getcwd(buf, sizeof(buf));\n    interp->curDir = Jsi_Strdup(interp->curDir?interp->curDir:\".\");\n#endif\n    interp->onDeleteTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeOnDeleteTbl);\n    interp->assocTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, freeAssocTbl);\n    interp->cmdSpecTbl = Jsi_MapNew(interp, JSI_MAP_TREE, JSI_KEYS_STRING, freeCmdSpecTbl);\n    interp->eventTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeEventTbl);\n    interp->fileTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, jsi_HashFree);\n    interp->funcObjTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeFuncObjTbl);\n    interp->funcsTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeFuncsTbl);\n    interp->bindTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeBindObjTbl);\n    interp->protoTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL/*freeValueTbl*/);\n    interp->regexpTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, regExpFree);\n    interp->preserveTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, jsi_HashFree);\n    interp->loadTbl = (parent?parent->loadTbl:Jsi_HashNew(interp, JSI_KEYS_STRING, jsi_FreeOneLoadHandle));\n    interp->packageHash = Jsi_HashNew(interp, JSI_KEYS_STRING, packageHashFree);\n    interp->aliasHash = Jsi_HashNew(interp, JSI_KEYS_STRING, jsi_AliasFree);\n\n    interp->lockTimeout = -1;\n#ifdef JSI_LOCK_TIMEOUT\n    interp->lockTimeout JSI_LOCK_TIMEOUT;\n#endif\n#ifndef JSI_DO_UNLOCK\n#define JSI_DO_UNLOCK 1\n#endif\n    interp->subOpts.mutexUnlock = JSI_DO_UNLOCK;\n    Jsi_Map_Type mapType = JSI_MAP_HASH;\n#ifdef JSI_USE_MANY_STRKEY\n    mapType = JSI_MAP_TREE;\n#endif\n\n    if (interp == jsiIntData.mainInterp || interp->threadId != jsiIntData.mainInterp->threadId) {\n        interp->strKeyTbl = Jsi_MapNew(interp,  mapType, JSI_KEYS_STRING, NULL);\n        interp->subOpts.privKeys = 1;\n    }\n    // Handle interp options: -T value and -Ixxx value\n    for (iocnt = 1; (iocnt+1)<argc && !interp->parent; iocnt+=2)\n    {\n        const char *aio = argv[iocnt];\n        if (Jsi_Strcmp(aio, \"--F\") == 0) {\n            interp->traceCall |= (jsi_callTraceFuncs |jsi_callTraceArgs |jsi_callTraceReturn | jsi_callTraceBefore | jsi_callTraceFullPath);\n            iocnt--;\n            interp->iskips++;\n            continue;\n        }\n        if (Jsi_Strcmp(aio, \"--U\") == 0) {\n            interp->asserts = 1;\n            interp->unitTest = 1;\n            iocnt--;\n            interp->iskips++;\n            continue;\n        }\n        if (Jsi_Strcmp(aio, \"--V\") == 0) {\n            interp->asserts = 1;\n            interp->unitTest = 5;\n            interp->tracePuts = 1;\n            iocnt--;\n            interp->iskips++;\n            continue;\n        }\n        if (Jsi_Strcmp(aio, \"--C\") == 0) {\n            if (interp->confFile)\n               Jsi_LogWarn(\"overriding confFile: %s\", interp->confFile);\n            interp->confFile = argv[iocnt+1];\n            interp->iskips+=2;\n            continue;\n        }\n        if (Jsi_Strcmp(aio, \"--L\") == 0) {\n            struct stat sb;\n            const char* path = argv[iocnt+1]; //TODO: convert to Jsi_Value first?\n            if (!path || stat(path, &sb)\n                || !((S_ISREG(sb.st_mode) && !access(path, W_OK)) || (S_ISDIR(sb.st_mode) && !access(path, X_OK)))) {\n                Jsi_LogError(\"Lockdown path must exist and be a writable file or executable dir: %s\", path);\n                Jsi_InterpDelete(interp);\n                return NULL;\n            }\n            interp->isSafe = true;\n            interp->safeMode = jsi_safe_Lockdown;\n            if (interp->safeWriteDirs) {\n                Jsi_LogWarn(\"Overriding safeWriteDirs\");\n                Jsi_DecrRefCount(interp, interp->safeWriteDirs);\n            }\n            const char *vda[2] = {};\n            char npath[PATH_MAX];\n            vda[0] = Jsi_FileRealpathStr(interp, path, npath);\n            interp->safeWriteDirs = Jsi_ValueNewArray(interp, vda, 1);\n            Jsi_IncrRefCount(interp, interp->safeWriteDirs);\n            if (!interp->safeReadDirs) {\n                interp->safeReadDirs = interp->safeWriteDirs;\n                Jsi_IncrRefCount(interp, interp->safeReadDirs);\n            }\n            interp->iskips+=2;\n            continue;\n        }\n        if (Jsi_Strcmp(aio, \"--T\") == 0) {\n            if (jsi_ParseTypeCheckStr(interp, argv[iocnt+1]) != JSI_OK) {\n                Jsi_InterpDelete(interp);\n                return NULL;\n            }\n            interp->iskips+=2;\n            continue;\n        }\n        if (!Jsi_Strcmp(aio, \"--I\"))  {\n            bool bv = 1;\n            char *aio2 = argv[iocnt+1], *aioc = Jsi_Strchr(aio2, ':'),\n                argNamS[50], *argNam = aio2;\n            const char *argVal;\n            if (!Jsi_Strcmp(\"traceCall\", aio2))\n                interp->traceCall |= (jsi_callTraceFuncs |jsi_callTraceArgs |jsi_callTraceReturn | jsi_callTraceBefore | jsi_callTraceFullPath);\n            else {\n                if (aioc) {\n                    argNam = argNamS;\n                    argVal = aioc+1;\n                    snprintf(argNamS, sizeof(argNamS), \"%.*s\", (int)(aioc-aio2), aio2);\n                }\n                \n                DECL_VALINIT(argV);\n                Jsi_Value *argValue = &argV;\n                Jsi_Number dv;\n                if (!aioc || Jsi_GetBool(interp, argVal, &bv) == JSI_OK) {\n                    Jsi_ValueMakeBool(interp, &argValue, bv);\n                } else if (!Jsi_Strcmp(\"null\", argVal)) {\n                    Jsi_ValueMakeNull(interp, &argValue);\n                } else if (Jsi_GetDouble(interp, argVal, &dv) == JSI_OK) {\n                    Jsi_ValueMakeNumber(interp, &argValue, dv);\n                } else {\n                    Jsi_ValueMakeStringKey(interp, &argValue, argVal);\n                }\n                if (JSI_OK != Jsi_OptionsSet(interp, InterpOptions, interp, argNam, argValue, 0)) {\n                    Jsi_InterpDelete(interp);\n                    return NULL;\n                }\n            }\n            interp->iskips+=2;\n            continue;\n        }\n        break;\n    }\n    if (!interp->strKeyTbl)\n        interp->strKeyTbl = jsiIntData.mainInterp->strKeyTbl;\n    if (opts) {\n        interp->inopts = opts = Jsi_ValueDupJSON(interp, opts);\n        if (Jsi_OptionsProcess(interp, InterpOptions, interp, opts, 0) < 0) {\n            Jsi_DecrRefCount(interp, opts);\n            interp->inopts = NULL;\n            Jsi_InterpDelete(interp);\n            return NULL;\n        }\n    }\n    if (interp == jsiIntData.mainInterp) {\n        interp->subthread = 0;\n    } else {\n        if (opts) {\n            if (interp->subOpts.privKeys && interp->strKeyTbl == jsiIntData.mainInterp->strKeyTbl) {\n                //Jsi_HashDelete(interp->strKeyTbl);\n                Jsi_OptionsFree(interp, InterpOptions, interp, 0); /* Reparse options to populate new key table. */\n                interp->strKeyTbl = Jsi_MapNew(interp, mapType, JSI_KEYS_STRING, NULL);\n                if (opts->vt != JSI_VT_NULL) Jsi_OptionsProcess(interp, InterpOptions, interp, opts, 0);\n            } else if (interp->subOpts.privKeys == 0 && interp->strKeyTbl != jsiIntData.mainInterp->strKeyTbl) {\n                Jsi_OptionsFree(interp, InterpOptions, interp, 0); /* Reparse options to populate new key table. */\n                Jsi_MapDelete(interp->strKeyTbl);\n                interp->strKeyTbl = jsiIntData.mainInterp->strKeyTbl;\n                if (opts->vt != JSI_VT_NULL) Jsi_OptionsProcess(interp, InterpOptions, interp, opts, 0);\n            }\n        }\n        if (parent && parent->isSafe) {\n            interp->isSafe = 1;\n            interp->safeMode = parent->safeMode;\n        }\n        if (interp->subthread && interp->isSafe) {\n            interp->subthread = 0;\n            Jsi_LogError(\"threading disallowed in safe mode\");\n            Jsi_InterpDelete(interp);\n            return NULL;\n        }\n        if (interp->subthread)\n            jsiIntData.mainInterp->threadCnt++;\n        if (interp->subthread && interp->strKeyTbl == jsiIntData.mainInterp->strKeyTbl)\n            jsiIntData.mainInterp->threadShrCnt++;\n        if (jsiIntData.mainInterp->threadShrCnt)\n#ifdef JSI_USE_MANY_STRKEY\n            jsiIntData.mainInterp->strKeyTbl->v.tree->opts.lockTreeProc = KeyLockerTree;\n#else\n            jsiIntData.mainInterp->strKeyTbl->v.hash->opts.lockHashProc = KeyLocker;\n#endif\n    }\n    if (parent && parent->isSafe) {\n        interp->isSafe = 1;\n        interp->safeMode = parent->safeMode;\n        interp->maxOpCnt = parent->maxOpCnt;\n        if (interp->safeWriteDirs || interp->safeReadDirs || interp->safeExecPattern) {\n            Jsi_LogWarn(\"ignoring safe* options in safe sub-sub-interp\");\n            if (interp->safeWriteDirs) Jsi_DecrRefCount(interp, interp->safeWriteDirs);\n            if (interp->safeReadDirs) Jsi_DecrRefCount(interp, interp->safeReadDirs);\n            interp->safeWriteDirs = interp->safeReadDirs = NULL;\n            interp->safeExecPattern = NULL;\n        }\n    }\n\n    jsi_InterpConfFiles(interp);\n    if (!interp->udata) {\n        interp->udata = Jsi_ValueNewObj(interp, NULL);\n        Jsi_IncrRefCount(interp, interp->udata);\n    }\n    if (interp->subthread && !interp->scriptStr && !interp->scriptFile) {\n        Jsi_LogError(\"subthread interp must be specify either scriptFile or scriptStr\");\n        Jsi_InterpDelete(interp);\n        return NULL;\n    }\n#ifndef JSI_MEM_DEBUG\n    static int warnNoDebug = 0;\n    if (interp->memDebug && warnNoDebug == 0) {\n        Jsi_LogWarn(\"ignoring memDebug as jsi was compiled without memory debugging\");\n        warnNoDebug = 1;\n    }\n#endif\n    interp->threadId = Jsi_CurrentThread();\n    if (interp->parent && interp->subthread==0 && interp->threadId != interp->parent->threadId) {\n        interp->threadId = interp->parent->threadId;\n#ifndef JSI_MEM_DEBUG\n        Jsi_LogWarn(\"non-threaded sub-interp created by different thread than parent\");\n#endif\n    }\n    if (interp->safeMode != jsi_safe_None)\n        interp->isSafe = interp->startSafe = 1;\n    if (!interp->parent) {\n        if (interp->isSafe)\n            interp->startSafe = 1;\n        if (interp->debugOpts.msgCallback)\n            Jsi_LogWarn(\"ignoring msgCallback\");\n        if (interp->debugOpts.putsCallback)\n            Jsi_LogWarn(\"ignoring putsCallback\");\n        if (interp->busyCallback)\n            Jsi_LogWarn(\"ignoring busyCallback\");\n        if (interp->debugOpts.traceCallback)\n            Jsi_LogWarn(\"ignoring traceCallback\");\n    } else if (interp->busyCallback && interp->threadId != interp->parent->threadId) {\n        Jsi_LogWarn(\"disabling busyCallback due to threads\");\n        interp->busyCallback = NULL;\n    }\n    if (interp == jsiIntData.mainInterp)\n        interp->lexkeyTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);\n    else\n        interp->lexkeyTbl = jsiIntData.mainInterp->lexkeyTbl;\n    interp->thisTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeValueTbl);\n    interp->userdataTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, freeUserdataTbl);\n    interp->varTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);\n    interp->codeTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, freeCodeTbl);\n    interp->genValueTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD,freeValueTbl);\n    interp->genObjTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeGenObjTbl);\n#ifdef JSI_MEM_DEBUG\n    interp->codesTbl = (interp == jsiIntData.mainInterp ? Jsi_HashNew(interp, JSI_KEYS_ONEWORD, NULL) : jsiIntData.mainInterp->codesTbl);\n#endif\n    if (interp->typeCheck.all|interp->typeCheck.parse|interp->typeCheck.funcsig)\n        interp->staticFuncsTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);\n    interp->maxArrayList = MAX_ARRAY_LIST;\n    if (!jsiIntData.isInit) {\n        jsiIntData.isInit = 1;\n        jsi_InitValue(interp, 0);\n        jsiIntData.interpsTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, 0);\n    }\n\n    /* current scope, also global */\n    interp->csc = Jsi_ValueNew1(interp);\n    Jsi_ValueMakeObject(interp, &interp->csc, Jsi_ObjNew(interp));\n    interp->framePtr->incsc = interp->csc;\n\n#define JSIDOINIT(nam) if (!jsi_ModBlacklisted(interp,#nam)) { if (jsi_Init##nam(interp, 0) != JSI_OK) { Jsi_LogBug(\"Init failure in %s\", #nam); } }\n#define JSIDOINIT2(nam) if (!jsi_ModBlacklisted(interp,#nam)) { if (Jsi_Init##nam(interp, 0) != JSI_OK) { Jsi_LogBug(\"Init failure in %s\", #nam); } }\n\n    JSIDOINIT(Proto);\n\n    if (interp->pkgDirs) // Fix-up because above, array was not yet initialized.\n        interp->pkgDirs->d.obj->__proto__ = interp->Array_prototype;\n\n    Jsi_Value *modObj = Jsi_ValueNewObj(interp, Jsi_ObjNewType(interp, JSI_OT_OBJECT));\n    Jsi_ValueInsert(interp, interp->csc, \"Jsi_Auto\", modObj, JSI_OM_DONTDEL);\n\n    /* initial scope chain, nothing */\n    interp->framePtr->ingsc = interp->gsc = jsi_ScopeChainNew(interp, 0);\n\n    interp->ps = jsi_PstateNew(interp); /* Default parser. */\n    if (interp->unitTest&2) {\n        interp->logOpts.before = 1;\n        interp->logOpts.full = 1;\n        interp->tracePuts = 1;\n        interp->noStderr = 1;\n    }\n    if (interp->args && argc) {\n        Jsi_LogBug(\"args may not be specified both as options and parameter\");\n        Jsi_InterpDelete(interp);\n        return NULL;\n    }\n    if (interp->maxDepth>JSI_MAX_EVAL_DEPTH)\n        interp->maxDepth = JSI_MAX_EVAL_DEPTH;\n\n    // Create the args array.\n    if (argc >= 0 && !interp->args) {\n        Jsi_Value *iargs = Jsi_ValueNew1(interp);\n        iargs->f.bits.dontdel = 1;\n        iargs->f.bits.readonly = 1;\n        Jsi_Obj *iobj = Jsi_ObjNew(interp);\n        Jsi_ValueMakeArrayObject(interp, &iargs, iobj);\n        int i = 1, ii = (iocnt>1 ? iocnt : 1);\n        int msiz = (argc?argc-iocnt:0);\n        Jsi_ObjArraySizer(interp, iobj, msiz);\n        iobj->arrMaxSize = msiz;\n        iocnt--;\n        iobj->arrCnt = argc-iocnt;\n        for (i = 1; ii < argc; ++ii, i++) {\n            iobj->arr[i-1] = Jsi_ValueNewStringKey(interp, argv[ii]);\n            Jsi_IncrRefCount(interp, iobj->arr[i-1]);\n            jsi_ValueDebugLabel(iobj->arr[i-1], \"InterpCreate\", \"args\");\n        }\n        Jsi_ObjSetLength(interp, iobj, msiz);\n        interp->args = iargs;\n    } else if (interp->parent && interp->args) {\n        // Avoid strings from sneeking in with options from parent...\n        Jsi_Value *nar = Jsi_ValueDupJSON(interp, interp->args);\n        Jsi_DecrRefCount(interp, interp->args);\n        interp->args = nar;\n    }\n    JSIDOINIT(Options);\n    JSIDOINIT(Cmds);\n    JSIDOINIT(Interp);\n    JSIDOINIT(JSON);\n\n    interp->retValue = Jsi_ValueNew1(interp);\n    interp->Mutex = Jsi_MutexNew(interp, -1, JSI_MUTEX_RECURSIVE);\n    if (1 || interp->subthread) {\n        interp->QMutex = Jsi_MutexNew(interp, -1, JSI_MUTEX_RECURSIVE);\n        //Jsi_DSInit(&interp->interpEvalQ);\n    }\n    JSIDOINIT(Lexer);\n    if (interp != jsiIntData.mainInterp && !parent)\n        Jsi_HashSet(jsiIntData.interpsTbl, interp, NULL);\n\n    if (!interp->isSafe) {\n        JSIDOINIT(Load);\n#if JSI__SIGNAL==1\n        JSIDOINIT(Signal);\n#endif\n    }\n    if (interp->isSafe == 0 || interp->startSafe || interp->safeWriteDirs!=NULL || interp->safeReadDirs!=NULL) {\n#if JSI__FILESYS==1\n        JSIDOINIT(FileCmds);\n        JSIDOINIT(Filesys);\n#endif\n    }\n#if JSI__SQLITE==1\n    JSIDOINIT2(Sqlite);\n#else\n    Jsi_initSqlite(interp, 0);\n#endif\n#if JSI__MYSQL==1\n    if (!interp->noNetwork) {\n        JSIDOINIT2(MySql);\n    }\n#endif\n#if JSI__SOCKET==1\n    JSIDOINIT2(Socket);\n#endif\n#if JSI__WEBSOCKET==1\n    JSIDOINIT2(WebSocket);\n#endif\n\n#if JSI__CDATA==1\n    JSIDOINIT(CData);\n#endif\n\n#ifdef JSI_USER_EXTENSION\n    extern int JSI_USER_EXTENSION(Jsi_Interp *interp, int release);\n    if (JSI_USER_EXTENSION (interp, 0) != JSI_OK) {\n        fprintf(stderr, \"extension load failed\");\n        return jsi_DoExit(interp, 1);\n    }\n#endif\n    Jsi_PkgProvide(interp, \"Jsi\", JSI_VERSION, NULL);\n    if (argc > 0) {\n        char *ss = argv0;\n        char epath[PATH_MAX] = \"\"; // Path of executable\n#ifdef __WIN32\n\n        if (GetModuleFileName(NULL, epath, sizeof(epath))>0)\n            ss = epath;\n#else\n#ifndef PROC_SELF_DIR\n#define PROC_SELF_DIR \"/proc/self/exe\"\n#endif\n        if (ss && *ss != '/' && readlink(PROC_SELF_DIR, epath, sizeof(epath)) && epath[0])\n            ss = epath;\n#endif\n        Jsi_Value *src = Jsi_ValueNewStringDup(interp, ss);\n        Jsi_IncrRefCount(interp, src);\n        jsiIntData.execName = Jsi_Realpath(interp, src, NULL);\n        Jsi_DecrRefCount(interp, src);\n        if (!jsiIntData.execName) jsiIntData.execName = Jsi_Strdup(\"\");\n        jsiIntData.execValue = Jsi_ValueNewString(interp, jsiIntData.execName, -1);\n        Jsi_IncrRefCount(interp, jsiIntData.execValue);\n        Jsi_HashSet(interp->genValueTbl, jsiIntData.execValue, jsiIntData.execValue);\n    }\n\n    //interp->nocacheOpCodes = 1;\n    if (interp->debugOpts.debugCallback && !interp->debugOpts.hook) {\n        interp->debugOpts.hook = jsi_InterpDebugHook;\n    }\n    interp->startTime = jsi_GetTimestamp();\n#ifdef JSI_INTERP_EXTENSION_CODE // For extending interp from jsi.c\n    JSI_INTERP_EXTENSION_CODE\n#endif\n    if (interp->opts.initProc && (*interp->opts.initProc)(interp, 0) != JSI_OK)\n        Jsi_LogBug(\"Init failure in initProc\");\n\n    return interp;\n}\n\nJsi_Interp* Jsi_InterpNew(Jsi_InterpOpts *opts)\n{\n    return jsi_InterpNew(NULL, NULL, opts);\n}\n\nbool Jsi_InterpGone( Jsi_Interp* interp)\n{\n    return (interp == NULL || interp->deleting || interp->destroying || interp->exited);\n}\n\nstatic void DeleteAllInterps() { /* Delete toplevel interps. */\n    Jsi_HashEntry *hPtr;\n    Jsi_HashSearch search;\n    if (!jsiIntData.interpsTbl)\n        return;\n    for (hPtr = Jsi_HashSearchFirst(jsiIntData.interpsTbl, &search); hPtr; hPtr = Jsi_HashSearchNext(&search)) {\n        Jsi_Interp *interp = (Jsi_Interp *)Jsi_HashKeyGet(hPtr);\n        Jsi_HashEntryDelete(hPtr);\n        interp->destroying = 1;\n        Jsi_InterpDelete(interp);\n    }\n    Jsi_HashDelete(jsiIntData.interpsTbl);\n    jsiIntData.interpsTbl = NULL;\n    jsiIntData.isInit = 0;\n}\n\n#ifdef JSI_MEM_DEBUG\n\ntypedef enum { MDB_INOBJ=1, MDB_VISITED=2 } jsi_MDB;\n\nvoid jsiFlagDebugValues(Jsi_Interp *interp, Jsi_Obj *obj)\n{\n    Jsi_Value *v;\n    int oflags;\n    if (obj->ot != JSI_OT_OBJECT && obj->ot != JSI_OT_ARRAY)\n        return;\n    if (obj->tree) {\n        Jsi_TreeEntry *hPtr;\n        Jsi_TreeSearch srch;\n        for (hPtr=Jsi_TreeSearchFirst(obj->tree, &srch,  JSI_TREE_ORDER_IN, NULL); hPtr;\n            hPtr=Jsi_TreeSearchNext(&srch)) {\n            v = (Jsi_Value*)Jsi_TreeValueGet(hPtr);\n            if (v == NULL || v->sig != JSI_SIG_VALUE) continue;\n            oflags = v->VD.flags;\n            v->VD.flags |= (MDB_VISITED|MDB_INOBJ);\n            if (oflags&MDB_VISITED || v->vt != JSI_VT_OBJECT)\n                continue;\n            jsiFlagDebugValues(interp, v->d.obj);\n        }\n    }\n    if (obj->arr) {\n        uint i;\n        for (i=0; i<obj->arrCnt; i++) {\n            v = obj->arr[i];\n            if (v == NULL || v->sig != JSI_SIG_VALUE) continue;\n            oflags = v->VD.flags;\n            v->VD.flags |= (MDB_VISITED|MDB_INOBJ);\n            if (oflags&MDB_VISITED || v->vt != JSI_VT_OBJECT)\n                continue;\n            jsiFlagDebugValues(interp, v->d.obj);\n        }\n    }\n}\n\nvoid jsi_DebugDumpValues(Jsi_Interp *interp)\n{\n    if (jsiIntData.mainInterp != interp) return;\n    int vdLev = interp->memDebug;\n    int have = (interp->dbPtr->valueDebugTbl->numEntries || interp->dbPtr->objDebugTbl->numEntries);\n    if ((have && vdLev>0) || vdLev>=3) {\n        // First traverse all Object trees/arrays and mark all values contained therein.\n        Jsi_HashSearch search;\n        Jsi_HashEntry *hPtr;\n        for (hPtr = Jsi_HashSearchFirst(interp->dbPtr->objDebugTbl, &search);\n            hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {\n            Jsi_Obj *vp = (Jsi_Obj *)Jsi_HashKeyGet(hPtr);\n            if (vp!=NULL && vp->sig == JSI_SIG_OBJ) {\n                jsiFlagDebugValues(interp, vp);\n            }\n        }\n        if (interp->dbPtr->valueDebugTbl->numEntries != interp->dbPtr->valueCnt)\n            fprintf(stderr, \"\\n\\nValues table/alloc mismatch: table=%d, alloc=%d\\n\",\n                interp->dbPtr->valueDebugTbl->numEntries, interp->dbPtr->valueCnt);\n        // Dump unfreed values and objs.\n        int refSum=0, refsum=0;\n        int bcnt[4] = {};\n        if (vdLev>1 && interp->dbPtr->valueDebugTbl->numEntries)\n            fprintf(stderr, \"\\n\\nUNFREED VALUES \\\"[*ptr,#refCnt,type,idx:label,label2]: @file:line in func() ...\\\"\\n\");\n        for (hPtr = Jsi_HashSearchFirst(interp->dbPtr->valueDebugTbl, &search);\n            hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {\n            Jsi_Value *vp = (Jsi_Value *)Jsi_HashKeyGet(hPtr);\n            if (vp==NULL || vp->sig != JSI_SIG_VALUE) {\n                bcnt[0]++;\n                if (vdLev>1)\n                    fprintf(stderr, \"BAD VALUE: %p\\n\", vp);\n            } else {\n                bcnt[1]++;\n                refSum += vp->refCnt;\n                if (vdLev>1) {\n                    char ebuf[JSI_BUFSIZ], ebuf2[JSI_MAX_NUMBER_STRING];\n                    ebuf[0] = 0;\n                    if (vp->vt==JSI_VT_OBJECT)\n                        snprintf(ebuf, sizeof(ebuf), \" {obj=%p, otype=%s}\", vp->d.obj, Jsi_ObjTypeStr(interp, vp->d.obj));\n                    else if (vp->vt==JSI_VT_NUMBER)\n                        snprintf(ebuf, sizeof(ebuf), \" {num=%s}\", Jsi_NumberToString(interp, vp->d.num, ebuf2, sizeof(ebuf2)));\n                    else if (vp->vt==JSI_VT_BOOL)\n                        snprintf(ebuf, sizeof(ebuf), \" {bool=%s}\", vp->d.val?\"true\":\"false\");\n                    else if (vp->vt==JSI_VT_STRING) {\n                        const char *sbuf = ((vp->d.s.str && Jsi_Strlen(vp->d.s.str)>40)?\"...\":\"\");\n                        snprintf(ebuf, sizeof(ebuf), \" {string=\\\"%.40s%s\\\"}\", (vp->d.s.str?vp->d.s.str:\"\"), sbuf);\n                    }\n                    const char *pfx = \"\";\n                    if (!(vp->VD.flags&MDB_INOBJ))\n                        pfx = \"!\"; // Value is not contained in an object.\n                    fprintf(stderr, \"[%s*%p,#%d,%s,%d:%s%s%s]:%s @%s:%d in %s()%s\\n\", pfx,\n                        vp, vp->refCnt, Jsi_ValueTypeStr(interp, vp), vp->VD.Idx,\n                        (vp->VD.label?vp->VD.label:\"\"), (vp->VD.label2?\":\":\"\"),\n                        (vp->VD.label2?vp->VD.label2:\"\"), vp->VD.interp==jsiIntData.mainInterp?\"\":\"!\",\n                        vp->VD.fname, vp->VD.line, vp->VD.func, ebuf);\n                }\n            }\n        }\n        if (interp->dbPtr->objDebugTbl->numEntries != interp->dbPtr->objCnt)\n            fprintf(stderr, \"\\n\\nObject table/alloc mismatch: table=%d, alloc=%d\\n\",\n                interp->dbPtr->objDebugTbl->numEntries, interp->dbPtr->objCnt);\n        if (vdLev>1 && interp->dbPtr->objDebugTbl->numEntries)\n            fprintf(stderr, \"\\n\\nUNFREED OBJECTS \\\"[*ptr,#refCnt,type,idx:label,label2]: @file:line in func() ...\\\"\\n\");\n        for (hPtr = Jsi_HashSearchFirst(interp->dbPtr->objDebugTbl, &search);\n            hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {\n            Jsi_Obj *vp = (Jsi_Obj *)Jsi_HashKeyGet(hPtr);\n            if (vp==NULL || vp->sig != JSI_SIG_OBJ) {\n                bcnt[2]++;\n                fprintf(stderr, \"BAD OBJ: %p\\n\", vp);\n            } else {\n                bcnt[3]++;\n                refsum += vp->refcnt;\n                if (vdLev>1) {\n                    char ebuf[JSI_BUFSIZ], ebuf2[JSI_MAX_NUMBER_STRING];\n                    ebuf[0] = 0;\n                    if (vp->ot==JSI_OT_OBJECT) {\n                        if (vp->isarrlist)\n                            snprintf(ebuf, sizeof(ebuf), \"tree#%d, array#%d\", (vp->tree?vp->tree->numEntries:0), vp->arrCnt);\n                        else\n                            snprintf(ebuf, sizeof(ebuf), \"tree#%d\", (vp->tree?vp->tree->numEntries:0));\n                    } else if (vp->ot==JSI_OT_NUMBER)\n                        snprintf(ebuf, sizeof(ebuf), \"num=%s\", Jsi_NumberToString(interp, vp->d.num, ebuf2, sizeof(ebuf2)));\n                    else if (vp->ot==JSI_OT_BOOL)\n                        snprintf(ebuf, sizeof(ebuf), \"bool=%s\", vp->d.val?\"true\":\"false\");\n                    else if (vp->ot==JSI_OT_STRING) {\n                        const char *sbuf = ((vp->d.s.str && Jsi_Strlen(vp->d.s.str)>40)?\"...\":\"\");\n                        snprintf(ebuf, sizeof(ebuf), \"string=\\\"%.40s%s\\\"\", (vp->d.s.str?vp->d.s.str:\"\"), sbuf);\n                    }\n                    fprintf(stderr, \"[*%p,#%d,%s,%d:%s%s%s]:%s @%s:%d in %s() {%s}\\n\",\n                        vp, vp->refcnt, Jsi_ObjTypeStr(interp, vp), vp->VD.Idx, vp->VD.label?vp->VD.label:\"\",\n                        vp->VD.label2?\":\":\"\",vp->VD.label2?vp->VD.label2:\"\", vp->VD.interp==jsiIntData.mainInterp?\"\":\"!\",\n                        vp->VD.fname, vp->VD.line,\n                        vp->VD.func, ebuf);\n                }\n            }\n        }\n        fprintf(stderr, \"\\nVALUES: bad=%d,unfreed=%d,allocs=%d,refsum=%d  | OBJECTS: bad=%d,unfreed=%d,allocs=%d,refsum=%d  interp=%p\\n\",\n            bcnt[0], bcnt[1], interp->dbPtr->valueAllocCnt, refSum, bcnt[2], bcnt[3], interp->dbPtr->objAllocCnt, refsum, interp);\n\n        if (interp->codesTbl)\n            for (hPtr = Jsi_HashSearchFirst(interp->codesTbl, &search);\n                hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {\n                Jsi_OpCodes *vp = (Jsi_OpCodes *)Jsi_HashKeyGet(hPtr);\n                fprintf(stderr, \"unfreed opcodes: %d\\n\", vp->id);\n            }\n    }\n    Jsi_HashDelete(interp->dbPtr->valueDebugTbl);\n    Jsi_HashDelete(interp->dbPtr->objDebugTbl);\n    Jsi_HashDelete(interp->codesTbl);\n    bool isMainInt = (interp == jsiIntData.mainInterp);\n    if (isMainInt && vdLev>3)\n        _exit(1); // Avoid sanitize output.\n}\n#endif\n\nstatic Jsi_RC jsiInterpDelete(Jsi_Interp* interp, void *unused)\n{\n    SIGASSERT(interp,INTERP);\n    bool isMainInt = (interp == jsiIntData.mainInterp);\n    int mainFlag = (isMainInt ? 2 : 1);\n    if (isMainInt)\n        DeleteAllInterps();\n    if (interp->opts.initProc)\n        (*interp->opts.initProc)(interp, mainFlag);\n    jsiIntData.delInterp = interp;\n    if (interp->gsc) jsi_ScopeChainFree(interp, interp->gsc);\n    if (interp->csc) Jsi_DecrRefCount(interp, interp->csc);\n    if (interp->ps) jsi_PstateFree(interp->ps);\n    int i;\n    for (i=0; i<interp->maxStack; i++) {\n        if (interp->Stack[i]) Jsi_DecrRefCount(interp, interp->Stack[i]);\n        if (interp->Obj_this[i]) Jsi_DecrRefCount(interp, interp->Obj_this[i]);\n    }\n    if (interp->Stack) {\n        Jsi_Free(interp->Stack);\n        Jsi_Free(interp->Obj_this);\n    }\n\n    if (interp->argv0)\n        Jsi_DecrRefCount(interp, interp->argv0);\n    if (interp->console)\n        Jsi_DecrRefCount(interp, interp->console);\n    if (interp->lastSubscriptFail)\n        Jsi_DecrRefCount(interp, interp->lastSubscriptFail);\n    if (interp->nullFuncRet)\n        Jsi_DecrRefCount(interp, interp->nullFuncRet);\n    Jsi_HashDelete(interp->codeTbl);\n    Jsi_MapDelete(interp->cmdSpecTbl);\n    Jsi_HashDelete(interp->fileTbl);\n    Jsi_HashDelete(interp->funcObjTbl);\n    Jsi_HashDelete(interp->funcsTbl);\n    if (interp->profileCnt) { // TODO: resolve some values from dbPtr, others not.\n        double endTime = jsi_GetTimestamp();\n        double coverage = (int)(100.0*interp->coverHit/interp->coverAll);\n        Jsi_DString dStr;\n        Jsi_DSInit(&dStr);\n        Jsi_DSPrintf(&dStr, \"PROFILE: TOTAL: time=%.6f, func=%.6f, cmd=%.6f, #funcs=%d, #cmds=%d, cover=%2.1f%%, #values=%d, #objs=%d %s%s\\n\",\n            endTime-interp->startTime, interp->funcSelfTime, interp->cmdSelfTime, interp->funcCallCnt, interp->cmdCallCnt,\n            coverage, interp->dbPtr->valueAllocCnt,  interp->dbPtr->objAllocCnt,\n            interp->parent?\" ::\":\"\", (interp->parent&&interp->name?interp->name:\"\"));\n        Jsi_Puts(interp, jsi_Stderr, Jsi_DSValue(&dStr), -1);\n        Jsi_DSFree(&dStr);\n    }\n    if (isMainInt)\n        Jsi_HashDelete(interp->lexkeyTbl);\n    Jsi_HashDelete(interp->protoTbl);\n    if (interp->subthread)\n        jsiIntData.mainInterp->threadCnt--;\n    if (interp->subthread && interp->strKeyTbl == jsiIntData.mainInterp->strKeyTbl)\n        jsiIntData.mainInterp->threadShrCnt--;\n    if (!jsiIntData.mainInterp->threadShrCnt)\n#ifdef JSI_USE_MANY_STRKEY\n        jsiIntData.mainInterp->strKeyTbl->v.tree->opts.lockTreeProc = NULL;\n#else\n        jsiIntData.mainInterp->strKeyTbl->v.hash->opts.lockHashProc = NULL;\n#endif\n    //Jsi_ValueMakeUndef(interp, &interp->ret);\n    Jsi_HashDelete(interp->thisTbl);\n    Jsi_HashDelete(interp->varTbl);\n    Jsi_HashDelete(interp->genValueTbl);\n    Jsi_HashDelete(interp->genObjTbl);\n    Jsi_HashDelete(interp->aliasHash);\n    if (interp->staticFuncsTbl)\n        Jsi_HashDelete(interp->staticFuncsTbl);\n    if (interp->breakpointHash)\n        Jsi_HashDelete(interp->breakpointHash);\n    if (interp->preserveTbl->numEntries!=0)\n        Jsi_LogBug(\"Preserves unbalanced\");\n    Jsi_HashDelete(interp->preserveTbl);\n    if (interp->curDir)\n        Jsi_Free(interp->curDir);\n    if (isMainInt) {\n        jsi_InitFilesys(interp, mainFlag);\n    }\n#ifndef JSI_OMIT_VFS\n    jsi_InitVfs(interp, 1);\n#endif\n#ifndef JSI_OMIT_CDATA\n        jsi_InitCData(interp, mainFlag);\n#endif\n#if JSI__MYSQL==1\n        Jsi_InitMySql(interp, mainFlag);\n#endif\n    while (interp->interpStrEvents) {\n        InterpStrEvent *se = interp->interpStrEvents;\n        interp->interpStrEvents = se->next;\n        if (se->acfunc)\n            Jsi_DecrRefCount(interp, se->acfunc);\n        if (se->acdata)\n            Jsi_Free(se->acdata);\n        Jsi_Free(se);\n    }\n\n    if (interp->Mutex)\n        Jsi_MutexDelete(interp, interp->Mutex);\n    if (interp->QMutex) {\n        Jsi_MutexDelete(interp, interp->QMutex);\n        Jsi_DSFree(&interp->interpEvalQ);\n    }\n    if (interp->nullFuncArg)\n        Jsi_DecrRefCount(interp, interp->nullFuncArg);\n    if (interp->NullValue)\n        Jsi_DecrRefCount(interp, interp->NullValue);\n    if (interp->Function_prototype_prototype) {\n        if (interp->Function_prototype_prototype->refCnt>1)\n            Jsi_DecrRefCount(interp, interp->Function_prototype_prototype);\n        Jsi_DecrRefCount(interp, interp->Function_prototype_prototype);\n    }\n    if (interp->Object_prototype) {\n        Jsi_DecrRefCount(interp, interp->Object_prototype);\n    }\n    Jsi_HashDelete(interp->regexpTbl);\n    Jsi_OptionsFree(interp, InterpOptions, interp, 0);\n    Jsi_HashDelete(interp->userdataTbl);\n    Jsi_HashDelete(interp->eventTbl);\n    if (interp->inopts)\n        Jsi_DecrRefCount(interp, interp->inopts);\n    if (interp->safeWriteDirs)\n        Jsi_DecrRefCount(interp, interp->safeWriteDirs);\n    if (interp->safeReadDirs)\n        Jsi_DecrRefCount(interp, interp->safeReadDirs);\n    if (interp->pkgDirs)\n        Jsi_DecrRefCount(interp, interp->pkgDirs);\n    for (i=0; interp->cleanObjs[i]; i++) {\n        interp->cleanObjs[i]->tree->opts.freeHashProc = 0;\n        Jsi_ObjFree(interp, interp->cleanObjs[i]);\n    }\n    Jsi_HashDelete(interp->bindTbl);\n    for (i = 0; i <= interp->cur_scope; i++)\n        jsi_ScopeStrsFree(interp, interp->scopes[i]);\n#if JSI__ZVFS==1\n    Jsi_InitZvfs(interp, mainFlag);\n#endif\n    if (!interp->parent)\n        Jsi_HashDelete(interp->loadTbl);\n    if (interp->packageHash)\n        Jsi_HashDelete(interp->packageHash);\n    Jsi_HashDelete(interp->assocTbl);\n    interp->cleanup = 1;\n    jsi_AllObjOp(interp, NULL, -1);\n#ifdef JSI_MEM_DEBUG\n    jsi_DebugDumpValues(interp);\n#endif\n    if (isMainInt || interp->strKeyTbl != jsiIntData.mainInterp->strKeyTbl)\n        Jsi_MapDelete(interp->strKeyTbl);\n\n    if (isMainInt)\n        jsiIntData.mainInterp = NULL;\n    _JSI_MEMCLEAR(interp);\n    jsiIntData.delInterp = NULL;\n    Jsi_Free(interp);\n    return JSI_OK;\n}\n\nvoid Jsi_InterpDelete(Jsi_Interp* interp)\n{\n    if (interp->deleting || interp->level > 0 || !interp->onDeleteTbl)\n        return;\n    interp->deleting = 1;\n    Jsi_HashDelete(interp->onDeleteTbl);\n    interp->onDeleteTbl = NULL;\n    Jsi_EventuallyFree(interp, interp, jsiInterpDelete);\n}\n\ntypedef struct {\n    void *data;\n    Jsi_Interp *interp;\n    int refCnt;\n    Jsi_DeleteProc* proc;\n} PreserveData;\n\nvoid Jsi_Preserve(Jsi_Interp* interp, void *data) {\n    bool isNew;\n    PreserveData *ptr;\n    Jsi_HashEntry *hPtr = Jsi_HashEntryNew(interp->preserveTbl, data, &isNew);\n    assert(hPtr);\n    if (!isNew) {\n        ptr = (PreserveData*)Jsi_HashValueGet(hPtr);\n        if (ptr) {\n            assert(interp == ptr->interp);\n            ptr->refCnt++;\n        }\n    } else {\n        ptr = (PreserveData*)Jsi_Calloc(1,sizeof(*ptr));\n        Jsi_HashValueSet(hPtr, ptr);\n        ptr->interp = interp;\n        ptr->data = data;\n        ptr->refCnt = 1;\n    }\n}\n\nvoid Jsi_Release(Jsi_Interp* interp, void *data) {\n    Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->preserveTbl, data);\n    if (!hPtr) return;\n    PreserveData *ptr = (PreserveData*)Jsi_HashValueGet(hPtr);\n    if (!ptr) return;\n    assert(ptr->interp == interp);\n    if (--ptr->refCnt > 0) return;\n    if (ptr->proc)\n        (*ptr->proc)(interp, data);\n    Jsi_Free(ptr);\n    Jsi_HashEntryDelete(hPtr);\n}\n\nvoid Jsi_EventuallyFree(Jsi_Interp* interp, void *data, Jsi_DeleteProc* proc) {\n    Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->preserveTbl, data);\n    if (!hPtr) {\n        (*proc)(interp, data);\n        return;\n    }\n    PreserveData *ptr = (PreserveData*)Jsi_HashValueGet(hPtr);\n    assert(ptr && ptr->interp == interp);\n    JSI_NOWARN(ptr);\n    Jsi_HashEntryDelete(hPtr);\n}\n\nvoid Jsi_InterpOnDelete(Jsi_Interp *interp, Jsi_DeleteProc *freeProc, void *ptr)\n{\n    if (freeProc)\n        Jsi_HashSet(interp->onDeleteTbl, ptr, (void*)freeProc);\n    else {\n        Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->onDeleteTbl, ptr);\n        if (hPtr)\n            Jsi_HashEntryDelete(hPtr);\n    }\n}\n\nstatic void interpObjErase(InterpObj *fo)\n{\n    SIGASSERTV(fo,INTERPOBJ);\n    if (fo->subinterp) {\n        Jsi_Interp *interp = fo->subinterp;\n        fo->subinterp = NULL;\n        Jsi_InterpDelete(interp);\n        /*fclose(fo->fp);\n        Jsi_Free(fo->interpname);\n        Jsi_Free(fo->mode);*/\n    }\n    fo->subinterp = NULL;\n}\n\nstatic Jsi_RC interpObjFree(Jsi_Interp *interp, void *data)\n{\n    InterpObj *fo = (InterpObj *)data;\n    SIGASSERT(fo,INTERPOBJ);\n    if (fo->deleting) return JSI_OK;\n    fo->deleting = 1;\n    interpObjErase(fo);\n    Jsi_Free(fo);\n    return JSI_OK;\n}\n\nstatic bool interpObjIsTrue(void *data)\n{\n    InterpObj *fo = (InterpObj *)data;\n    SIGASSERT(fo,INTERPOBJ);\n    if (!fo->subinterp) return 0;\n    else return 1;\n}\n\nstatic bool interpObjEqual(void *data1, void *data2)\n{\n    return (data1 == data2);\n}\n\n/* TODO: possibly support async func-callback.  Also for call/send. */\nstatic Jsi_RC InterpEvalCmd_(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr, int flags)\n{\n    int isFile = flags&2;\n    int isUplevel = flags&1;\n    int lev = 0;\n    bool async = 0;\n    Jsi_RC rc = JSI_OK;\n    int isthrd;\n    Jsi_Interp *sinterp = interp;\n    Jsi_ValueMakeUndef(interp, ret);\n    InterpObj *udf = (InterpObj *)Jsi_UserObjGetData(interp, _this, funcPtr);\n    if (udf)\n        sinterp = udf->subinterp;\n    if (Jsi_InterpGone(interp) || Jsi_InterpGone(sinterp))\n        return Jsi_LogError(\"Sub-interp gone\");\n    isthrd = (interp->threadId != sinterp->threadId);\n    jsi_Frame *f = sinterp->framePtr;\n    Jsi_Value *nw = Jsi_ValueArrayIndex(interp, args, 1);\n    if (!isUplevel) {\n        if (nw && Jsi_GetBoolFromValue(interp, nw, &async))\n            return JSI_ERROR;\n    } else {\n        if (isthrd)\n            return Jsi_LogError(\"can not use uplevel() with threaded interp\");\n        Jsi_Number nlev = sinterp->framePtr->level;\n        if (nw && Jsi_GetNumberFromValue(interp, nw, &nlev)!=JSI_OK)\n            return Jsi_LogError(\"expected number\");\n        lev = (int)nlev;\n        if (lev <= 0)\n            lev = f->level+lev;\n        if (lev <= 0 || lev > f->level)\n            return Jsi_LogError(\"level %d not between 1 and %d\", (int)nlev, f->level);\n    }\n\n    char *cp = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    if (cp==NULL || *cp == 0)\n        return JSI_OK;\n    if (async && isthrd) {\n        /* Post to thread event in sub-interps queue. TODO: could just use event like below... */\n        if (Jsi_MutexLock(interp, sinterp->QMutex) != JSI_OK)\n            return JSI_ERROR;\n        Jsi_DSAppend(&sinterp->interpEvalQ, Jsi_Strlen(Jsi_DSValue(&sinterp->interpEvalQ))?\";\":\"\", cp, NULL);\n        Jsi_MutexUnlock(interp, sinterp->QMutex);\n        return JSI_OK;\n    }\n    if (interp->subOpts.mutexUnlock) Jsi_MutexUnlock(interp, interp->Mutex);\n    if (!isthrd) {\n        int ostrict = sinterp->strict;\n        sinterp->strict = 0;\n        sinterp->level++;\n        if (interp->framePtr->tryDepth)\n            sinterp->framePtr->tryDepth++;\n        if (isFile) {\n            int sflags = 0;\n            if (!sinterp->includeCnt) {\n                sflags = JSI_EVAL_ARGV0|JSI_EVAL_AUTOINDEX;\n                sinterp->isMain = 1;\n            }\n            if (sinterp->debugOpts.debugCallback && !sinterp->includeCnt)  // TODO: safe debugging can't use \"source\"\n                // TODO: we do this in debugger, even though it is illegal for interps to share objects.\n                sinterp->autoFiles = Jsi_ValueDup(sinterp, interp->autoFiles);\n            sinterp->includeCnt++;\n            rc = Jsi_EvalFile(sinterp, Jsi_ValueArrayIndex(interp, args, 0), sflags);\n        } else if (isUplevel == 0 || lev <= 1)\n            rc = (Jsi_EvalString(sinterp, cp, 0) == 0 ? JSI_OK : JSI_ERROR);\n        else {\n            rc = (jsi_evalStrFile(sinterp, NULL, cp, 0, lev) == 0 ? JSI_OK : JSI_ERROR);\n        }\n        sinterp->strict = ostrict;\n        if (interp->framePtr->tryDepth) {\n            sinterp->framePtr->tryDepth--;\n            if (rc != JSI_OK && interp != sinterp) {\n                Jsi_Strcpy(interp->errMsgBuf, sinterp->errMsgBuf);\n                interp->errLine = sinterp->errLine;\n                interp->errFile = sinterp->errFile;\n                sinterp->errMsgBuf[0] = 0;\n            }\n        }\n        sinterp->level--;\n    } else {\n        if (Jsi_MutexLock(interp, sinterp->QMutex) != JSI_OK)\n            return JSI_ERROR;\n        InterpStrEvent *se, *s = (InterpStrEvent *)Jsi_Calloc(1, sizeof(*s));\n        SIGINIT(s,INTERPSTREVENT);\n        s->isExec = 1;\n        s->tryDepth = interp->framePtr->tryDepth;\n        Jsi_DSInit(&s->data);\n        Jsi_DSAppend(&s->data, cp, NULL);\n        Jsi_DSInit(&s->func);\n        //s->mutex = Jsi_MutexNew(interp, -1, JSI_MUTEX_RECURSIVE);\n        //Jsi_MutexLock(s->mutex);\n        se = sinterp->interpStrEvents;\n        if (!se)\n            sinterp->interpStrEvents = s;\n        else {\n            while (se->next)\n                se = se->next;\n            se->next = s;\n        }\n\n        Jsi_MutexUnlock(interp, sinterp->QMutex);\n        while (s->isExec)      /* Wait until done. TODO: timeout??? */\n            Jsi_Sleep(interp, 1);\n        rc = (s->rc == 0 ? JSI_OK : JSI_ERROR);\n        if (rc != JSI_OK)\n            Jsi_LogError(\"eval failed: %s\", Jsi_DSValue(&s->data));\n        Jsi_DSFree(&s->func);\n        Jsi_DSFree(&s->data);\n        Jsi_Free(s);\n    }\n\n    if (interp->subOpts.mutexUnlock && Jsi_MutexLock(interp, interp->Mutex) != JSI_OK) {\n        return JSI_ERROR;\n    }\n\n    if (Jsi_InterpGone(sinterp))\n    {\n        /* TODO: perhaps exit() be able to delete. */\n        //Jsi_InterpDelete(sinterp);\n        return JSI_OK;\n    }\n    /*if (rc != JSI_OK && !async)\n        return rc;*/\n    if (sinterp->retValue->vt != JSI_VT_UNDEF) {\n        if (sinterp == interp)\n            Jsi_ValueCopy(interp, *ret, sinterp->retValue);\n        else\n            Jsi_CleanValue(sinterp, interp, sinterp->retValue, ret);\n    }\n    return rc;\n}\n\nJsi_Interp *jsi_DoExit(Jsi_Interp *interp, int rc)\n{\n    if (rc<0 || rc>127) rc = 127;\n    if (!interp || !interp->opts.no_exit) {\n        if (rc) {\n            Jsi_Flush(interp, jsi_Stdout);\n            Jsi_Flush(interp, jsi_Stderr);\n        }\n        exit(rc);\n    }\n    fprintf(stderr, \"ignoring attempted exit: may cause a crash\\n\");\n    if (interp) interp->deleting = 1;\n    return NULL;\n}\n\n#define FN_interpeval JSI_INFO(\"\\\nWhen the 'async' option is used on a threaded interp, the script is queued as an Event.\")\n\nstatic Jsi_RC InterpEvalCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    return InterpEvalCmd_(interp, args, _this, ret, funcPtr, 0);\n}\n\n\n#define FN_interpuplevel JSI_INFO(\"\\\nThe level argument is as returned by Info.level().  Not supported with threads.\")\nstatic Jsi_RC InterpUplevelCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    return InterpEvalCmd_(interp, args, _this, ret, funcPtr, 1);\n}\n\nstatic Jsi_RC InterpSourceCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    return InterpEvalCmd_(interp, args, _this, ret, funcPtr, 2);\n}\n\nstatic Jsi_RC InterpValueCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    InterpObj *udf = (InterpObj *)Jsi_UserObjGetData(interp, _this, funcPtr);\n    Jsi_Interp *sinterp = interp;\n    if (udf) {\n        if (!udf->subinterp)\n        return Jsi_LogError(\"Sub-interp gone\");\n        sinterp = udf->subinterp;\n        if (interp->threadId != udf->subinterp->threadId)\n            return Jsi_LogError(\"value not supported with threads\");\n    }\n    Jsi_Value *nw = Jsi_ValueArrayIndex(interp, args, 1);\n    jsi_Frame *f = sinterp->framePtr;\n    Jsi_Number nlev = sinterp->framePtr->level;\n    if (nw && Jsi_GetNumberFromValue(interp, nw, &nlev))\n        return JSI_ERROR;\n    int lev = (int)nlev;\n    if (lev <= 0)\n        lev = f->level+lev;\n    if (lev <= 0 || lev > f->level)\n        return Jsi_LogError(\"level %d not between 1 and %d\", (int)nlev, f->level);\n    while (f->level != lev  && f->parent)\n        f = f->parent;\n\n    const char* arg = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    Jsi_Value *val = NULL;\n    if (arg) {\n        if (f == sinterp->framePtr)\n            val = Jsi_NameLookup(sinterp, arg);\n        else {\n            jsi_Frame *of = sinterp->framePtr;\n            sinterp->framePtr = f;\n            val = Jsi_NameLookup(sinterp, arg);\n            sinterp->framePtr = of;\n        }\n    }\n    if (!val)\n        return Jsi_LogError(\"unknown var: %s\", arg);\n    if (sinterp == interp) {\n        Jsi_ValueCopy(interp, *ret, val);\n        return JSI_OK;\n    }\n    Jsi_CleanValue(sinterp, interp, val, ret);\n    return JSI_OK;\n}\n\nstatic Jsi_RC InterpInfoCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    InterpObj *udf = (InterpObj *)Jsi_UserObjGetData(interp, _this, funcPtr);\n    Jsi_Interp *subinterp = interp;\n    if (udf) {\n        if (!udf->subinterp)\n            return Jsi_LogError(\"Sub-interp gone\");\n        subinterp = udf->subinterp;\n    }\n    return jsi_InterpInfo(subinterp, args, _this, ret, funcPtr);\n}\n\nJsi_RC jsi_InterpInfo(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Interp *sinterp = interp;\n    Jsi_DString dStr = {}, cStr = {};\n    char tbuf[1024];\n    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n    tbuf[0] = 0;\n    if (v) {\n        InterpObj *udf = NULL;\n        if (v && v->vt == JSI_VT_OBJECT && v->d.obj->ot == JSI_OT_USEROBJ)\n            udf = (InterpObj *)v->d.obj->d.uobj->data;\n        if (udf && udf->subinterp) {\n            SIGASSERT(udf, INTERPOBJ);\n            sinterp = udf->subinterp;\n        } else\n            return Jsi_LogError(\"unknown interp\");\n    }\n    if (sinterp->subthread)\n        snprintf(tbuf, sizeof(tbuf), \", thread:{errorCnt:%u, evalCnt:%u, msgCnt:%u }\",\n            sinterp->threadErrCnt, sinterp->threadEvalCnt, sinterp->threadMsgCnt );\n    const char *funcstr = sinterp->framePtr->funcName;\n    if (!funcstr)\n        funcstr = \"\";\n    int curLine = (sinterp->curIp?sinterp->curIp->Line:0);\n    Jsi_DSPrintf(&dStr, \"{curLevel:%d, curLine:%d, curFile:\\\"%s\\\", curFunc:\\\"%s\\\", hasExited:%d, \"\n        \"opCnt:%d, isSafe:%s, depth:%d, codeCacheHits: %d, typeMismatchCnt:%d, \"\n        \"funcCallCnt:%d, cmdCallCnt:%d, includeCnt:%d, includeDepth:%d, pkgReqDepth:%d, \"\n        \"cwd:\\\"%s\\\", lockTimeout: %d, name, \\\"%s\\\" %s%s};\",\n        sinterp->level, curLine, jsi_GetCurFile(sinterp), funcstr?funcstr:\"\",\n        sinterp->exited, sinterp->opCnt, sinterp->isSafe?\"true\":\"false\",\n        sinterp->interpDepth, sinterp->codeCacheHit, sinterp->typeMismatchCnt,\n        sinterp->funcCallCnt, sinterp->cmdCallCnt, sinterp->includeCnt, sinterp->includeDepth, sinterp->pkgReqDepth,\n        (sinterp->curDir?sinterp->curDir:Jsi_GetCwd(sinterp,&cStr)),\n        sinterp->lockTimeout, sinterp->name?sinterp->name:\"\", tbuf[0]?\",\":\"\", tbuf);\n    Jsi_RC rc = Jsi_JSONParse(interp, Jsi_DSValue(&dStr), ret, 0);\n    if (rc != JSI_OK)\n        puts(Jsi_DSValue(&dStr));\n    Jsi_DSFree(&dStr);\n    Jsi_DSFree(&cStr);\n    return rc;\n}\n\nstatic Jsi_RC SubInterpEvalCallback(Jsi_Interp *interp, void* data)\n{\n    Jsi_RC rc = JSI_OK;\n    Jsi_DString dStr = {};\n    if (Jsi_MutexLock(interp, interp->QMutex) != JSI_OK)\n        return JSI_ERROR;\n    char *cp = Jsi_DSValue(&interp->interpEvalQ);\n    if (*cp) {\n        Jsi_DSAppend(&dStr, cp, NULL);\n        Jsi_DSSetLength(&interp->interpEvalQ, 0);\n        interp->threadEvalCnt++;\n        Jsi_MutexUnlock(interp, interp->QMutex);\n        if (Jsi_EvalString(interp, Jsi_DSValue(&dStr), 0) != JSI_OK)\n            rc = JSI_ERROR;\n        Jsi_DSSetLength(&dStr, 0);\n        if (Jsi_MutexLock(interp, interp->QMutex) != JSI_OK)\n            return JSI_ERROR;\n    }\n    Jsi_MutexUnlock(interp, interp->QMutex);\n    Jsi_DSFree(&dStr);\n    if (Jsi_MutexLock(interp, interp->QMutex) != JSI_OK)\n        return JSI_ERROR;\n\n    /* Process subevents. */\n    InterpStrEvent *oldse, *se = interp->interpStrEvents;\n    Jsi_MutexUnlock(interp, interp->QMutex);\n    while (se) {\n        oldse = se;\n        int isExec = se->isExec;\n        if (se->acdata) {\n            jsi_AliasCreateCmd(interp, Jsi_DSValue(&se->func), se->acdata);\n        }\n        else if (se->acfunc) {\n            if (JSI_OK != Jsi_FunctionInvokeJSON(interp, se->acfunc, Jsi_DSValue(&se->data), NULL))\n                rc = JSI_ERROR;\n            Jsi_DecrRefCount(interp, se->acfunc);\n        }\n        else if (isExec) {\n            if (se->tryDepth)\n                interp->framePtr->tryDepth++;\n            se->rc = Jsi_EvalString(interp, Jsi_DSValue(&se->data), 0);\n            Jsi_DSSetLength(&se->data, 0);\n            if (se->rc != JSI_OK && se->tryDepth) {\n                Jsi_DSAppend(&se->data, interp->errMsgBuf, NULL);\n                se->errLine = interp->errLine;\n                se->errFile = interp->errFile;\n            } else {\n                Jsi_ValueGetDString(interp, interp->retValue, &se->data, JSI_OUTPUT_JSON);\n            }\n            if (se->tryDepth)\n                interp->framePtr->tryDepth--;\n\n        /* Otherwise, async calls. */\n        /*} else if (se->objData) {\n            if (JSI_OK != Jsi_CommandInvoke(interp, Jsi_DSValue(&se->func), se->objData, NULL))\n                rc = JSI_ERROR;*/\n        } else {\n            const char *scp = Jsi_DSValue(&se->data);\n            if (JSI_OK != Jsi_CommandInvokeJSON(interp, Jsi_DSValue(&se->func), scp, NULL))\n                rc = JSI_ERROR;\n        }\n        if (!isExec) {\n            Jsi_DSFree(&se->func);\n            Jsi_DSFree(&se->data);\n        }\n        if (Jsi_MutexLock(interp, interp->QMutex) != JSI_OK)\n            return JSI_ERROR;\n        interp->interpStrEvents = se->next;\n        if (!isExec) Jsi_Free(se);\n        se = interp->interpStrEvents;\n        Jsi_MutexUnlock(interp, interp->QMutex);\n        if (isExec)\n            oldse->isExec = 0;\n    }\n\n    return rc;\n}\n\n\nstatic Jsi_RC ThreadEvalCallback(Jsi_Interp *interp, void* data) {\n    Jsi_RC rc;\n\n    if ((rc=SubInterpEvalCallback(interp, data)) != JSI_OK)\n        interp->threadErrCnt++;\n    return rc;\n}\n\n/* Create an event handler in interp to handle call/eval/send asyncronously via 'Sys.update()'. */\nvoid jsi_AddEventHandler(Jsi_Interp *interp)\n{\n    Jsi_Event *ev;\n    while (!interp->EventHdlId) { /* Find an empty event slot. */\n        bool isNew;\n        uintptr_t id = ++interp->eventIdx;\n        Jsi_HashEntry *hPtr = Jsi_HashEntryNew(interp->eventTbl, (void*)id, &isNew);\n        if (!isNew)\n            continue;\n        ev = (Jsi_Event*)Jsi_Calloc(1, sizeof(*ev));\n        SIGINIT(ev,EVENT);\n        ev->id = id;\n        ev->handler = ThreadEvalCallback;\n        ev->hPtr = hPtr;\n        ev->evType = JSI_EVENT_ALWAYS;\n        Jsi_HashValueSet(hPtr, ev);\n        interp->EventHdlId = id;\n    }\n}\n\n#define FN_call JSI_INFO(\"\\\nInvoke function in sub-interp with arguments.\\n\\\nSince interps are not allowed to share objects, \\\ndata is automatically cleansed by encoding/decoding to/from JSON if required.\\n\\\nUnless an 'async' parameter is true call is acyncronous.\\n\\\nOtherwise waits until the sub-interp is idle, \\\nto make call and return result.\")\n\nstatic Jsi_RC InterpCallCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    InterpObj *udf = (InterpObj *)Jsi_UserObjGetData(interp, _this, funcPtr);\n    int isthrd;\n    Jsi_Interp *sinterp;\n    if (udf)\n        sinterp = udf->subinterp;\n    else\n        return Jsi_LogError(\"Apply Interp.call in a non-subinterp\");\n    if (Jsi_InterpGone(sinterp))\n        return Jsi_LogError(\"Sub-interp gone\");\n    isthrd = (interp->threadId != sinterp->threadId);\n\n    Jsi_Value *func = NULL;\n    char *fname = NULL;\n    func = Jsi_ValueArrayIndex(interp, args, 0);\n    fname = Jsi_ValueString(interp, func, NULL);\n    if (!fname)\n        return Jsi_LogError(\"function name must be a string\");\n    if (Jsi_MutexLock(interp, sinterp->Mutex) != JSI_OK)\n        return JSI_ERROR;\n    Jsi_Value *namLU = Jsi_NameLookup(sinterp, fname);\n    Jsi_MutexUnlock(interp, sinterp->Mutex);\n    if (namLU == NULL)\n        return Jsi_LogError(\"unknown function: %s\", fname);\n\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 1);\n    char *cp = Jsi_ValueString(interp, arg, NULL);\n\n    if (cp == NULL && !Jsi_ValueIsArray(interp, arg))\n        return Jsi_LogError(\"expected string or array\");\n\n    Jsi_Value *vwait = Jsi_ValueArrayIndex(interp, args, 2);\n    Jsi_RC rc = JSI_OK;\n    bool wait = 0;\n    if (vwait && Jsi_GetBoolFromValue(interp, vwait, &wait))\n        return JSI_ERROR;\n\n    if (wait) {\n        Jsi_DString dStr = {};\n        if (cp == NULL)\n            cp = (char*)Jsi_ValueGetDString(interp, arg, &dStr, JSI_OUTPUT_JSON);\n        if (interp->subOpts.mutexUnlock) Jsi_MutexUnlock(interp, interp->Mutex);\n        if (Jsi_MutexLock(interp, sinterp->Mutex) != JSI_OK) {\n            if (interp->subOpts.mutexUnlock) Jsi_MutexLock(interp, interp->Mutex);\n            return JSI_ERROR;\n        }\n        Jsi_Value *srPtr = Jsi_ValueNew1(sinterp);\n        /* TODO: call from this interp may not be safe if threaded.\n         * Could instead use async code below then wait for unlock on se->mutex. */\n        rc = Jsi_CommandInvokeJSON(sinterp, fname, cp, &srPtr);\n        Jsi_DSSetLength(&dStr, 0);\n        Jsi_CleanValue(sinterp, interp, srPtr, ret);\n        //Jsi_ValueCopy(interp, *ret, srPtr);\n        Jsi_DecrRefCount(sinterp, srPtr);\n        Jsi_DSFree(&dStr);\n        Jsi_MutexUnlock(interp, sinterp->Mutex);\n        if (interp->subOpts.mutexUnlock && Jsi_MutexLock(interp, interp->Mutex) != JSI_OK) {\n            Jsi_LogBug(\"mutex re-get failed\");\n            return JSI_ERROR;\n        }\n        return rc;\n    }\n\n    /* Post to thread event in sub-interps queue. */\n    if (Jsi_MutexLock(interp, sinterp->QMutex) != JSI_OK)\n        return JSI_ERROR;\n\n    /* Is an async call. */\n    InterpStrEvent *se, *s = (InterpStrEvent *)Jsi_Calloc(1, sizeof(*s));\n    // TODO: is s->data inited?\n    Jsi_DSInit(&s->data);\n    if (!cp) {\n        Jsi_ValueGetDString(interp, arg, &s->data, JSI_OUTPUT_JSON);\n    } else {\n        Jsi_DSSetLength(&s->data, 0);\n        Jsi_DSAppend(&s->data, cp, NULL);\n    }\n    Jsi_DSInit(&s->func);\n    Jsi_DSAppend(&s->func, fname, NULL);\n    se = sinterp->interpStrEvents;\n    if (!se)\n        sinterp->interpStrEvents = s;\n    else {\n        while (se->next)\n            se = se->next;\n        se->next = s;\n    }\n\n    Jsi_MutexUnlock(interp, sinterp->QMutex);\n    if (!isthrd) {\n        if (SubInterpEvalCallback(sinterp, NULL) != JSI_OK)\n            sinterp->threadErrCnt++;\n    }\n    return JSI_OK;\n}\n\nJsi_RC Jsi_Mount( Jsi_Interp *interp, Jsi_Value *archive, Jsi_Value *mount, Jsi_Value **ret)\n{\n#if JSI__ZVFS==1\n    return Zvfs_Mount(interp, archive, mount, ret);\n#else\n    return JSI_ERROR;\n#endif\n}\n\n/* Looks in dir for autoload.jsi or lib/autoload.jsi to add to autoFiles list. */\nint Jsi_AddAutoFiles(Jsi_Interp *interp, const char *dir) {\n    Jsi_DString dStr = {};\n    Jsi_StatBuf stat;\n    int i, cnt = 0;\n    for (i=0; i<2; i++) {\n        Jsi_DSAppend(&dStr, dir, (i==0?\"/lib\":\"\"),\"/autoload.jsi\", NULL);\n        Jsi_Value *v = Jsi_ValueNewStringKey(interp, Jsi_DSValue(&dStr));\n        if (Jsi_Stat(interp, v, &stat) != 0)\n            Jsi_ValueFree(interp, v);\n        else {\n            if (!interp->autoFiles) {\n                interp->autoFiles = Jsi_ValueNewArray(interp, 0, 0);\n                Jsi_IncrRefCount(interp, interp->autoFiles);\n            }\n            Jsi_ObjArrayAdd(interp, interp->autoFiles->d.obj, v);\n            cnt++;\n            interp->autoLoaded = 0;\n        }\n        Jsi_DSSetLength(&dStr, 0);\n    }\n    Jsi_DSFree(&dStr);\n    return cnt;\n}\n\nJsi_RC Jsi_EvalZip(Jsi_Interp *interp, const char *exeFile, const char *mntDir, int *jsFound)\n{\n#if JSI__ZVFS==1\n    Jsi_StatBuf stat;\n    Jsi_Value *vinit, *linit, *vmnt = NULL;\n    Jsi_Value *vexe = Jsi_ValueNewStringKey(interp, exeFile);\n    Jsi_Value *ret = NULL;\n    Jsi_RC rc;\n    const char *omntDir = mntDir;\n    int pass = 0;\n    Jsi_IncrRefCount(interp, vexe);\n    Jsi_HashSet(interp->genValueTbl, vexe, vexe);\n    if (jsFound)\n        *jsFound = 0;\n    if (!mntDir)\n        ret = Jsi_ValueNew(interp);\n    else {\n        vmnt = Jsi_ValueNewStringKey(interp, mntDir);\n        Jsi_IncrRefCount(interp, vmnt);\n        Jsi_HashSet(interp->genValueTbl, vmnt, vmnt);\n    }\n    bool osafe = interp->isSafe;\n    if (interp->startSafe)\n        interp->isSafe = 0;\n    rc =Jsi_Mount(interp, vexe, vmnt, &ret);\n    interp->isSafe = osafe;\n    if (rc != JSI_OK)\n        return rc;\n    Jsi_DString dStr, bStr;\n    Jsi_DSInit(&dStr);\n    Jsi_DSInit(&bStr);\n    if (!mntDir) {\n        mntDir = Jsi_KeyAdd(interp, Jsi_ValueString(interp, ret, NULL));\n        Jsi_DecrRefCount(interp, ret);\n    }\ndochk:\n    Jsi_DSAppend(&dStr, mntDir, \"/main.jsi\", NULL);\n    if (interp->pkgDirs)\n        Jsi_ValueArrayPush(interp, interp->pkgDirs, Jsi_ValueNewStringKey(interp, mntDir));\n    else {\n        interp->pkgDirs = Jsi_ValueNewArray(interp, &mntDir, 1);\n        Jsi_IncrRefCount(interp, interp->pkgDirs);\n    }\n    vinit = Jsi_ValueNewStringKey(interp,  Jsi_DSValue(&dStr));\n    Jsi_IncrRefCount(interp, vinit);\n    Jsi_HashSet(interp->genValueTbl, vinit, vinit);\n    Jsi_DSFree(&dStr);\n    Jsi_DSAppend(&dStr, mntDir, \"/lib\", NULL);\n    const char *str = Jsi_DSValue(&dStr);\n    linit = Jsi_ValueNewStringKey(interp, str);\n    Jsi_IncrRefCount(interp, linit);\n    if (Jsi_Stat(interp, linit, &stat) == 0)\n        Jsi_ValueArrayPush(interp, interp->pkgDirs, linit);\n    Jsi_DecrRefCount(interp, linit);\n    Jsi_DSFree(&dStr);\n    Jsi_DSFree(&bStr);\n    if (Jsi_Stat(interp, vinit, &stat) == 0) {\n        if (jsFound)\n            *jsFound |= JSI_ZIP_MAIN;\n        interp->execZip = vexe;\n        return Jsi_EvalFile(interp, vinit, JSI_EVAL_ARGV0|JSI_EVAL_AUTOINDEX);\n    }\n    if (Jsi_AddAutoFiles(interp, mntDir) && omntDir)\n        *jsFound = JSI_ZIP_INDEX;\n    if (!pass++) {\n        str = Jsi_Strrchr(exeFile, '/');\n        if (str) str++;\n        else str = exeFile;\n        char *bn = Jsi_DSAppend(&bStr, mntDir, \"/\", str, NULL);\n        bn = Jsi_Strrchr(bn, '.');\n        if (bn) *bn = 0;\n        mntDir = Jsi_DSValue(&bStr);\n        linit = Jsi_ValueNewStringKey(interp, mntDir);\n        Jsi_IncrRefCount(interp, linit);\n        int bsi = Jsi_Stat(interp, linit, &stat);\n        Jsi_DecrRefCount(interp, linit);\n        if (bsi == 0)\n            goto dochk;\n        Jsi_DSFree(&bStr);\n    }\n#endif\n    return JSI_OK;\n}\n\n#ifndef JSI_OMIT_THREADS\n\n#ifdef __WIN32\n#define JSITHREADRET void\n#else\n#define JSITHREADRET void*\n#endif\n\nstatic JSITHREADRET NewInterpThread(void* iPtr)\n{\n    int rc = JSI_OK;\n    InterpObj *udf = (InterpObj *)iPtr;\n    Jsi_Interp *interp = udf->subinterp;\n    interp->threadId = Jsi_CurrentThread();\n    if (interp->scriptStr)\n        rc = Jsi_EvalString(interp, interp->scriptStr, 0);\n    else if (interp->scriptFile) {\n        if (!interp->debugOpts.debugCallback) // Debug will use Interp.source() instead.\n            Jsi_EvalFile(interp, interp->scriptFile, 0);\n    } else {\n        Jsi_LogBug(\"no eval\");\n    }\n    if (rc != JSI_OK) {\n        Jsi_LogError(\"eval failure\");\n        interp->threadErrCnt++;\n        if (Jsi_MutexLock(interp, interp->Mutex) != JSI_OK)\n            return NULL;\n        Jsi_MutexUnlock(interp, interp->Mutex);\n    }\n    interpObjErase(udf);\n#ifndef __WIN32\n    /* TODO: should we wait/notify parent??? */\n    pthread_detach(pthread_self());\n    return NULL;\n#endif\n}\n#endif\n\nstatic Jsi_RC InterpConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr);\nstatic Jsi_RC InterpConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr);\n\nstatic Jsi_CmdSpec interpCmds[] = {\n    { \"Interp\", InterpConstructor,0,  1, \"options:object=void\", .help=\"Create a new interp\", .retType=(uint)JSI_TT_USEROBJ, .flags=JSI_CMD_IS_CONSTRUCTOR, .info=0, .opts=InterpOptions},\n    { \"alias\",  InterpAliasCmd,   0,  4, \"name:string=void, func:function|null=void, args:array|null=void, async=false\",.help=\"Set/get global alias bindings for command in an interp\", .retType=(uint)JSI_TT_ANY, .flags=0, .info=FN_intalias },\n    { \"call\",   InterpCallCmd,    2,  3, \"funcName:string, args:array, wait:boolean=false\", .help=\"Call named function in subinterp\", .retType=(uint)JSI_TT_ANY, .flags=0, .info=FN_call },\n    { \"conf\",   InterpConfCmd,    0,  1, \"options:string|object=void\",.help=\"Configure option(s)\" , .retType=(uint)JSI_TT_ANY,.flags=0,.info=0,.opts=InterpOptions},\n    { \"eval\",   InterpEvalCmd,    1,  2, \"js:string, async:boolean=false\", .help=\"Interpret script within sub-interp\", .retType=(uint)JSI_TT_ANY, .flags=0, .info=FN_interpeval },\n    { \"info\",   InterpInfoCmd,    0,  0, \"\", .help=\"Returns internal statistics about interp\", .retType=(uint)JSI_TT_OBJECT },\n    { \"source\", InterpSourceCmd,  1,  2, \"file:string, async:boolean=false\", .help=\"Interpret file within sub-interp\", .retType=(uint)JSI_TT_ANY, .flags=0, .info=FN_interpeval },\n    { \"uplevel\",InterpUplevelCmd, 2,  2, \"js:string, level:number=0\", .help=\"Interpret code at the given stack level\", .retType=(uint)JSI_TT_ANY, .flags=0, .info=FN_interpuplevel },\n    { \"value\",  InterpValueCmd,   1,  2, \"var:string, level:number=0\", .help=\"Lookup value of variable at stack level\", .retType=(uint)JSI_TT_ANY },\n    { NULL,     0,0,0,0, .help=\"Commands for accessing interps\" }\n};\n\nstatic Jsi_UserObjReg interpobject = {\n    \"Interp\",\n    interpCmds,\n    interpObjFree,\n    interpObjIsTrue,\n    interpObjEqual\n};\n\n\nstatic Jsi_RC InterpConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Obj *fobj;\n    Jsi_Value *toacc;\n    InterpObj *cmdPtr = (InterpObj *)Jsi_Calloc(1,sizeof(*cmdPtr));\n    int rc = JSI_OK;\n    SIGINIT(cmdPtr,INTERPOBJ);\n    cmdPtr->parent = interp;\n\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);\n\n    if (!(cmdPtr->subinterp = jsi_InterpNew(interp, arg, NULL))) {\n        Jsi_Free(cmdPtr);\n        return JSI_ERROR;\n    }\n    Jsi_Interp *sinterp = cmdPtr->subinterp;\n    sinterp->opts.no_exit = interp->opts.no_exit;\n    toacc = NULL;\n    if (Jsi_FunctionIsConstructor(funcPtr)) {\n        toacc = _this;\n    } else {\n        Jsi_Obj *o = Jsi_ObjNew(interp);\n        Jsi_PrototypeObjSet(interp, \"Interp\", o);\n        Jsi_ValueMakeObject(interp, ret, o);\n        toacc = *ret;\n    }\n\n    fobj = Jsi_ValueGetObj(interp, toacc);\n    if ((cmdPtr->objId = Jsi_UserObjNew(interp, &interpobject, fobj, cmdPtr))<0)\n        goto bail;\n    sinterp->objId = cmdPtr->objId;\n    cmdPtr->fobj = fobj;\n#ifndef JSI_OMIT_THREADS\n    if (sinterp->subthread) {\n#ifdef __WIN32\n        if (!_beginthread( NewInterpThread, 0, cmdPtr )) {\n            Jsi_LogError(\"thread create failed\");\n            goto bail;\n        }\n#else\n        pthread_t nthread;\n        if (pthread_create(&nthread, NULL, NewInterpThread, cmdPtr) != 0) {\n            Jsi_LogError(\"thread create failed\");\n            goto bail;\n        }\n#endif //__WIN32\n#else\n    if (0) {\n#endif //JSI_OMIT_THREADS\n    } else {\n        //sinterp->framePtr->tryDepth++;\n        if (sinterp->scriptStr != 0) {\n            if (sinterp->scriptFile && !interp->curFile)\n                sinterp->curFile = Jsi_ValueString(sinterp, sinterp->scriptFile, NULL);\n            rc = Jsi_EvalString(sinterp, sinterp->scriptStr, JSI_EVAL_ISMAIN);\n        } else if (sinterp->scriptFile && !sinterp->debugOpts.debugCallback) {\n            int len;\n            if (Jsi_ValueString(interp, sinterp->scriptFile, &len) && len==0)\n                Jsi_Interactive(sinterp, JSI_OUTPUT_QUOTE|JSI_OUTPUT_NEWLINES);\n            else\n                rc = Jsi_EvalFile(sinterp, sinterp->scriptFile, JSI_EVAL_ISMAIN);\n        }\n        //sinterp->framePtr->tryDepth--;\n        if (rc == JSI_EXIT)\n            return JSI_OK;\n        if (rc != JSI_OK) {\n            /*Jsi_Strcpy(interp->errMsgBuf, sinterp->errMsgBuf);\n            interp->errLine = sinterp->errLine;\n            interp->errFile = sinterp->errFile;\n            sinterp->errMsgBuf[0] = 0;*/\n            goto bail;\n        }\n    }\n    return JSI_OK;\n\nbail:\n    interpObjErase(cmdPtr);\n    Jsi_ValueMakeUndef(interp, ret);\n    return JSI_ERROR;\n}\n\nstatic Jsi_RC Jsi_DoneInterp(Jsi_Interp *interp)\n{\n    Jsi_UserObjUnregister(interp, &interpobject);\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_InterpConfFile(Jsi_Interp *interp, const char *fname, bool etc)\n{\n    Jsi_RC rc;\n    Jsi_DString dStr = {};\n    Jsi_Value *opts = NULL, *fn = Jsi_ValueNewStringConst(interp, fname, -1);\n    Jsi_IncrRefCount(interp, fn);\n    bool isSafe = interp->isSafe;\n    if (etc)\n        interp->isSafe = 0;\n    rc = Jsi_FileRead(interp, fn, &dStr);\n    if (rc != JSI_OK)\n        goto done;\n    opts = Jsi_ValueNew1(interp);\n    if (rc == JSI_OK)\n        rc = Jsi_JSONParse(interp, Jsi_DSValue(&dStr), &opts, 0);\n    if (rc == JSI_OK\n        && Jsi_OptionsProcess(interp, InterpOptions, interp, opts, 0) < 0)\n        rc = JSI_ERROR;\ndone:\n    if (etc && isSafe)\n        interp->isSafe = 1;\n    if (opts)\n        Jsi_DecrRefCount(interp, opts);\n    Jsi_DecrRefCount(interp, fn);\n    Jsi_DSFree(&dStr);\n    return rc;\n}\n\nstatic Jsi_RC jsi_InterpConfFiles(Jsi_Interp *interp)\n{\n    Jsi_RC rc = JSI_OK;\n#ifndef JSI__CONFFILE\n#define JSI__CONFFILE \"/etc/jsish.conf\"\n#endif\n    const char *fn = JSI__CONFFILE;\n    if (!fn || !fn[0])\n        return JSI_OK;\n    if (interp->confFile)\n        rc = jsi_InterpConfFile(interp, interp->confFile, 0);\n    if (rc == JSI_OK && access(fn, R_OK)==0)\n        rc = jsi_InterpConfFile(interp, fn, 1);\n    if (rc != JSI_OK)\n        Jsi_LogWarn(\"parse failure: %s\", fn);\n    if (interp->jsppChars && Jsi_Strlen(interp->jsppChars)!=2) {\n        Jsi_LogWarn(\"jsppChars ignored: length not 2: %s\", interp->jsppChars);\n        interp->jsppChars = NULL;\n    }\n    return rc;\n}\n\nstatic Jsi_RC InterpConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    InterpObj *udf = (typeof(udf))Jsi_UserObjGetData(interp, _this, funcPtr);\n    Jsi_RC rc;\n    Jsi_Value *opts = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_Interp *sinterp = interp;\n    if (!udf || udf->subinterp == interp) {\n        if (interp->noConfig && opts && !Jsi_ValueIsString(interp, opts))\n            return Jsi_LogError(\"Interp conf() is disabled for set\");\n        rc = Jsi_OptionsConf(interp, InterpOptions, interp, opts, ret, 0);\n    } else {\n        sinterp = udf->subinterp;\n        Jsi_Value *popts = opts;\n        if (opts && opts->vt != JSI_VT_NULL && !Jsi_ValueString(interp, opts, NULL) && opts->vt == JSI_VT_OBJECT) {\n            popts = Jsi_ValueNew1(sinterp);\n            Jsi_CleanValue(interp, sinterp, opts, &popts);\n        }\n        rc = Jsi_OptionsConf(sinterp, InterpOptions, sinterp, popts, ret, 0);\n        if (popts && popts != opts)\n            Jsi_DecrRefCount(sinterp, popts);\n        Jsi_CleanValue(sinterp, interp, *ret, ret);\n    }\n    return rc;\n}\n\nJsi_Value *Jsi_ReturnValue(Jsi_Interp *interp) {\n    return interp->retValue;\n}\n\nJsi_RC jsi_InitInterp(Jsi_Interp *interp, int release)\n{\n    if (release) return Jsi_DoneInterp(interp);\n    Jsi_Hash *isys;\n    if (!(isys = Jsi_UserObjRegister(interp, &interpobject)))\n        Jsi_LogBug(\"Can not init interp\");\n\n    Jsi_CommandCreateSpecs(interp, interpobject.name, interpCmds, isys, JSI_CMDSPEC_ISOBJ);\n    return JSI_OK;\n}\n\nbool Jsi_InterpSafe(Jsi_Interp *interp)\n{\n    return interp->isSafe;\n}\n\nJsi_RC Jsi_InterpAccess(Jsi_Interp *interp, Jsi_Value* resource, int aflag)\n{\n    switch (aflag) {\n        case JSI_INTACCESS_NETWORK:\n            return (interp->noNetwork?JSI_ERROR:JSI_OK);\n        case JSI_INTACCESS_MAININTERP:\n            return (interp->parent?JSI_ERROR:JSI_OK);\n        case JSI_INTACCESS_SETSSL:\n            interp->hasOpenSSL = 1;\n            return JSI_OK;\n        case JSI_INTACCESS_CREATE:\n            return (interp->isSafe && interp->safeMode==jsi_safe_Lockdown?JSI_ERROR: JSI_OK);\n        case JSI_INTACCESS_WRITE:\n        case JSI_INTACCESS_READ:\n            break;\n        default:\n            return JSI_ERROR;\n    }\n    if (!resource)\n        return JSI_ERROR;\n    Jsi_Value *v, *dirs = ((aflag==JSI_INTACCESS_WRITE) ? interp->safeWriteDirs : interp->safeReadDirs);\n    if (!interp->isSafe)\n        return JSI_OK;\n    if (!dirs)\n        return JSI_ERROR;\n    char pbuf[PATH_MAX];\n    int i, m, argc = Jsi_ValueGetLength(interp, dirs);\n    char *str, *dstr = Jsi_Realpath(interp, resource, pbuf);\n    if (!dstr)\n        return JSI_ERROR;\n    for (i=0; i<argc; i++) {\n        v = Jsi_ValueArrayIndex(interp, dirs, i);\n        if (!v) continue;\n        str = Jsi_ValueString(interp, v, &m);\n        if (!str || m<=0) continue;\n        if (!Jsi_Strcmp(str, dstr)) // Exact match.\n            return JSI_OK;\n        if (Jsi_Strncmp(str, dstr, m))\n            continue;\n        if (m>1 && str[m-1]=='/')\n            return JSI_OK;\n        if (dstr[m] == '/')\n            return JSI_OK;\n    }\n    return JSI_ERROR;\n}\n\nJsi_Value *Jsi_InterpResult(Jsi_Interp *interp)\n{\n    return interp->retValue;\n}\n\nconst char *Jsi_InterpLastError(Jsi_Interp *interp, const char **errFilePtr, int *errLinePtr)\n{\n    if (errFilePtr)\n        *errFilePtr = interp->errFile;\n    if (errLinePtr)\n        *errLinePtr = interp->errLine;\n    return interp->errMsgBuf;\n}\n\n#ifdef __WIN32\nvoid bzero(void *s, size_t n) {\n    memset(s, 0, n);\n}\n#endif\n#endif\n", "#ifndef JSI_LITE_ONLY\n\n#ifndef JSI_AMALGAMATION\n#include \"jsiInt.h\"\n#endif\n\nstatic void jsonNewDString(Jsi_Interp *interp, Jsi_DString *dStr, const char* str, int len)\n{\n    char buf[JSI_MAX_NUMBER_STRING], *dp = buf;\n    const char *cp = str;\n    int ulen;\n    \n    while ((cp-str)<len) {\n        if (*cp == '\\\\') {\n            switch (cp[1]) {\n                case 'b': *dp++ = '\\b'; break;\n                case 'n': *dp++ = '\\n'; break;\n                case 'r': *dp++ = '\\r'; break;\n                case 'f': *dp++ = '\\f'; break;\n                case 't': *dp++ = '\\t'; break;\n                case '\\\"': *dp++ = '\\\"'; break;\n                case '\\\\': *dp++ = '\\\\'; break;\n                case 'u': \n                    if ((ulen=Jsi_UtfDecode(cp+2, dp))) {\n                        dp += ulen;\n                        cp += 4;\n                    } else {                    \n                        *dp++ = '\\\\';\n                        *dp++ = 'u';\n                    }\n                    break;\n            }\n            cp+=2;\n        } else {\n            *dp++ = *cp++;\n        }\n        if ((dp-buf)>90) {\n            *dp = 0;\n            Jsi_DSAppendLen(dStr, buf, dp-buf);\n            dp = buf;\n        }\n    }\n    *dp = 0;\n    Jsi_DSAppendLen(dStr, buf, dp-buf);\n}\n\nstatic Jsi_Value *jsonNewStringObj(Jsi_Interp *interp, const char* str, int len)\n{\n    Jsi_Value *v = NULL;\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    jsonNewDString(interp, &dStr, str, len);\n    v = Jsi_ValueNew(interp);\n    Jsi_ValueFromDS(interp, &dStr, &v);\n    //Jsi_DSFree(&dStr);\n    return v;\n}\n\nstatic Jsi_Value* jsonGenObject(Jsi_Interp *interp, Jsi_JsonParser *p, const char *js, uint pos, uint *endPos);\nstatic Jsi_Value* jsonGenArray(Jsi_Interp *interp, Jsi_JsonParser *p, const char *js, uint pos, uint *endPos);\n\nstatic Jsi_Value*\njsonGen1Value(Jsi_Interp *interp, Jsi_JsonParser *p, const char *js, uint i, uint *endPos, int incr)\n{\n    uint len;\n    const char *t;\n    Jsi_Value *v = NULL;\n    \n    switch (p->tokens[i].type) {\n        case JSI_JTYPE_PRIMITIVE:\n            t = Jsi_JsonGetTokstr(p, js, i, &len);\n            if (len == 4 && Jsi_Strncmp(t, \"true\", len)==0)\n                v = Jsi_ValueMakeBool(interp, NULL, 1);\n            else if (len == 5 && Jsi_Strncmp(t, \"false\", len)==0)\n                v = Jsi_ValueMakeBool(interp, NULL, 0);\n            else if (len == 4 && Jsi_Strncmp(t, \"null\", len)==0)\n                v = Jsi_ValueMakeNull(interp, NULL);\n            else if (len == 9 && Jsi_Strncmp(t, \"undefined\", len)==0)\n                v = Jsi_ValueMakeNull(interp, NULL);\n            else {\n                char *ep;\n                Jsi_Number d;\n                d = strtod(t,&ep);\n                if (ep>(t+len))\n                    Jsi_LogWarn(\"bad number %*s\", len, t);\n                v = Jsi_ValueMakeNumber(interp, NULL, d);\n            }\n            break;\n        case JSI_JTYPE_STRING:\n            t = Jsi_JsonGetTokstr(p, js, i, &len);\n            v = jsonNewStringObj(interp, t, len);\n            break;\n        case JSI_JTYPE_ARRAY:\n            v = jsonGenArray(interp, p, js, i, &i);\n            i--;\n            break;\n        case JSI_JTYPE_OBJECT:\n            v = jsonGenObject(interp, p, js, i, &i);\n            i--;\n            break;\n        default:\n            break;\n    }\n    if (endPos)\n        *endPos = i;\n    if (v == NULL)\n        v = Jsi_ValueMakeUndef(interp, NULL);\n    if (incr)\n        Jsi_IncrRefCount(interp, v);\n    return v;\n}\n\nstatic Jsi_Value*\njsonGenObject(Jsi_Interp *interp, Jsi_JsonParser *p, const char *js, uint pos, uint *endPos)\n{\n    Jsi_Obj *obj = Jsi_ObjNewType(interp, JSI_OT_OBJECT);\n    Jsi_Value *nv, *v = Jsi_ValueMakeObject(interp, NULL, obj);\n    uint i, n, len;\n    Jsi_JsonTok *tok;\n    const char *t;\n    tok = p->tokens+pos;\n    for (i=pos+1, n=0; i<p->toknext && n<tok->size; i++, n++) {\n\n        Jsi_DString dStr;\n        t = Jsi_JsonGetTokstr(p, js, i, &len);\n        i++; n++;\n        if (n>=tok->size)\n            nv = Jsi_ValueMakeUndef(interp, NULL);\n        else\n            nv = jsonGen1Value(interp, p, js, i, &i, 0);\n        Jsi_DSInit(&dStr);\n        Jsi_DSAppendLen(&dStr, t, len);\n        Jsi_ObjInsert(interp, obj, Jsi_DSValue(&dStr), nv, 0);\n        Jsi_DSFree(&dStr);\n    }\n    if (endPos)\n        *endPos = i;\n    return v;\n}\n\nstatic Jsi_Value*\njsonGenArray(Jsi_Interp *interp, Jsi_JsonParser *p, const char *js, uint pos, uint *endPos)\n{\n    if (js==NULL || !js[0])\n        return NULL;\n    Jsi_Value *v = Jsi_ValueNewArray(interp, 0, 0);\n    Jsi_Obj *nobj = v->d.obj;\n    uint i, n;\n    Jsi_JsonTok *tok;\n    \n    tok = p->tokens+pos;\n    Jsi_ValueMakeArrayObject(interp, &v, nobj);\n    for (i=pos+1, n=0; i<p->toknext && n<tok->size; i++, n++) {\n        if (n >= nobj->arrMaxSize) {\n            if (Jsi_ObjArraySizer(interp, nobj, n+1)<=0) {\n                break;\n            }\n        }\n        nobj->arr[n] = jsonGen1Value(interp, p, js, i, &i, 1);\n    }\n    Jsi_ObjSetLength(interp, nobj, n);\n    if (endPos)\n        *endPos = i;\n    return v;\n}\n\nJsi_RC Jsi_JSONParse(Jsi_Interp *interp, const char *js, Jsi_Value **ret, int flags)\n{\n    uint i = 0, r;\n    Jsi_RC result = JSI_OK;\n    int strict = (flags & JSI_JSON_STRICT);\n    Jsi_JsonTok *tok;\n    Jsi_Value *v;\n    const char *err;\n    Jsi_Number d;\n    if (js == NULL)\n        return JSI_OK;\n    while (isspace(*js))\n        js++;\n    if (js[0] == 0)\n        return JSI_OK;\n    switch (js[0]) {\n        case 't': if (Jsi_Strcmp(js,\"true\")==0) { if (ret) Jsi_ValueMakeBool(interp, ret, 1); return JSI_OK; } break;\n        case 'f': if (Jsi_Strcmp(js,\"false\")==0) { if (ret) Jsi_ValueMakeBool(interp, ret, 0); return JSI_OK; } break;\n        case 'n': if (Jsi_Strcmp(js,\"null\")==0) { if (ret) Jsi_ValueMakeNull(interp, ret); return JSI_OK; } break;\n        case '0': case '1': case '2': case '3': case '4': case '5': \n        case '6': case '7': case '8': case '9': case '-':\n            if (Jsi_GetDouble(interp, js, &d) == JSI_OK) { if (ret) Jsi_ValueMakeNumber(interp, ret, d); return JSI_OK; } break;\n    }\n    JSI_JSON_DECLARE(pp, tokens, 0);\n    Jsi_JsonParser *p = &pp;\n    pp.strict = strict;\n    pp.flags = flags;\n\n    r = Jsi_JsonParse(p, js);\n    if (r != JSI_JSON_ERR_NONE) {\n        int ofs = pp.pos, len = Jsi_Strlen(js);\n        if (ofs<0 || ofs>len)\n            ofs = 0;\n        err = p->errStr;\n        if (!err)\n            err = Jsi_JsonGetErrname(r);\n        if (interp)\n            Jsi_LogError(\"JSON parse error (%s) at offset %d \\\"%.30s\\\"\", err, ofs, js+ofs);\n        result = JSI_ERROR;\n        goto done;\n    }\n    if (!ret)\n        goto done;\n    tok = p->tokens;\n    if (tok->size<=0) {\n        if (!*ret)\n            *ret = Jsi_ValueNew1(interp);\n        if (tok->type == JSI_JTYPE_OBJECT)\n            Jsi_ValueMakeObject(interp, ret, Jsi_ObjNewObj(interp, NULL, 0));\n        else if (tok->type == JSI_JTYPE_ARRAY)\n            Jsi_ValueMakeArrayObject(interp, ret, Jsi_ObjNew(interp));\n        else\n            Jsi_ValueMakeUndef(interp, ret);\n        goto done;\n    }\n    v = jsonGen1Value(interp, p, js, i, &i, 1);\n    Jsi_ValueReplace(interp, ret, v);\n    Jsi_DecrRefCount(interp, v);\ndone:\n    Jsi_JsonFree(&pp);\n    return result;\n}\n\n// Perform an sprintf format, then return the JSON parsed results.\nJsi_RC Jsi_JSONParseFmt(Jsi_Interp *interp, Jsi_Value **ret, const char *fmt, ...) \n{\n    va_list argList;\n    uint n;\n    char buf[JSI_BUFSIZ], *cp = buf;\n    Jsi_DString dStr = {};\n    va_start(argList, fmt);\n    n = vsnprintf(buf, sizeof(buf), fmt, argList);\n    if (n>JSI_MAX_ALLOC_BUF) {\n        Jsi_LogError(\"Jsi_JSONParseFmt error: rc = %d\", n);\n        va_end(argList);\n        return JSI_ERROR;\n    }\n    if (n >= sizeof(buf)) {\n        uint m;\n        Jsi_DSSetLength(&dStr, n+1);\n        m = vsnprintf(Jsi_DSValue(&dStr), n+1, fmt, argList);\n        assert(m == n);\n        JSI_NOWARN(m);\n        cp = Jsi_DSValue(&dStr);\n    }\n    va_end(argList);\n    return Jsi_JSONParse(interp, cp, ret, 0);\n}\n\n// Process options from json string. Handles only primatives and string. Returns number of fields parsed.\nint Jsi_OptionsProcessJSON(Jsi_Interp *interp, Jsi_OptionSpec *opts, void *data, const char *json, Jsi_Wide flags)\n{\n    uint i = 0, r, len;\n    Jsi_RC rc = JSI_OK;\n    int result = 0;\n    int strict = (flags & JSI_JSON_STRICT);\n    Jsi_JsonTok *tok;\n    const char *err;\n    Jsi_Value *v = NULL;\n    Jsi_DString nStr;\n    const char *t, *name = NULL;\n    if (json == NULL)\n        return 0;\n    while (isspace(*json))\n        json++;\n    if (json[0] == 0)\n        return 0;\n        \n    JSI_JSON_DECLARE(pp, tokens, 0);\n    Jsi_JsonParser *p = &pp;\n    pp.strict = strict;\n    pp.flags = flags;\n\n    r = Jsi_JsonParse(p, json);\n    if (r != JSI_JSON_ERR_NONE) {\n        int ofs = pp.pos, len = Jsi_Strlen(json);\n        if (ofs<0 || ofs>len)\n            ofs = 0;\n        err = p->errStr;\n        if (!err)\n            err = Jsi_JsonGetErrname(r);\n        Jsi_LogError(\"JSON parse error (%s) at offset %d \\\"%.30s\\\"\", err, ofs, json+ofs);\n        result = -1;\n        goto done;\n    }\n    tok = p->tokens;\n    Jsi_DSInit(&nStr);\n    if (tok->size%2 || tok->type != JSI_JTYPE_OBJECT) {\n        result = -1;\n        goto done;\n    }\n    v = Jsi_ValueNew1(interp);\n    for (i=1; i<p->toknext && i<tok->size; i++) {\n        if (p->tokens[i].type != JSI_JTYPE_STRING) {\n            result = Jsi_LogError(\"expected string at %d\", i-1);\n            goto bail;\n        }\n        name = Jsi_JsonGetTokstr(p, json, i, &len);\n        Jsi_DSSetLength(&nStr, 0);\n        Jsi_DSAppendLen(&nStr, name, len);\n        name = Jsi_DSValue(&nStr);\n        i++;\n        switch (p->tokens[i].type) {\n            case JSI_JTYPE_PRIMITIVE:\n                t = Jsi_JsonGetTokstr(p, json, i, &len);\n                if ((len == 4 && Jsi_Strncmp(t, \"true\", len)==0) || (len == 5 && Jsi_Strncmp(t, \"false\", len)==0)) {\n                    Jsi_ValueMakeBool(interp, &v, (bool)(len==4?1:0));\n                } else if (len == 4 && Jsi_Strncmp(t, \"null\", len)==0) {\n                    Jsi_ValueMakeNull(interp, &v);\n                } else {\n                    char *ep;\n                    Jsi_Number d = strtod(t,&ep);\n                    if (ep>(t+len)) {\n                        result = Jsi_LogError(\"bad number %*s\", len, t);\n                        goto bail;\n                    }\n                    Jsi_ValueMakeNumber(interp, &v, d);\n                }\n                break;\n            case JSI_JTYPE_STRING:\n                t = Jsi_JsonGetTokstr(p, json, i, &len);\n                Jsi_DString dStr;\n                Jsi_DSInit(&dStr);\n                jsonNewDString(interp, &dStr, t, len);\n                Jsi_ValueMakeStringKey(interp, &v, Jsi_DSValue(&dStr));\n                Jsi_DSFree(&dStr);\n                break;\n            case JSI_JTYPE_ARRAY:\n            case JSI_JTYPE_OBJECT:\n            default:\n                result = -1;\n                goto bail;\n                break;\n        }\n        result++;\n        rc = Jsi_OptionsSet(interp, opts, data, name, v, 0);\n        if (rc == JSI_OK)\n            continue;\n\nbail:\n        Jsi_LogError(\"bad at field: %s\", name);\n        result = -1;\n        break;\n    }\n\ndone:\n    Jsi_DSFree(&nStr);\n    if (v)\n        Jsi_DecrRefCount(interp, v);\n    Jsi_JsonFree(&pp);\n    return result;\n}\n\nstatic Jsi_RC JSONParseCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    bool strict = 1;\n    Jsi_Value *jsv = Jsi_ValueArrayIndex(interp, args, 1);\n    if (jsv && Jsi_ValueGetBoolean(interp, jsv, &strict) != JSI_OK) \n        return Jsi_LogError(\"Expected boolean\");\n    jsv = Jsi_ValueArrayIndex(interp, args, 0); \n    const char *js = Jsi_ValueToString(interp, jsv, NULL);\n    return Jsi_JSONParse(interp, js, ret, strict);\n}\n\n\n\nstatic Jsi_RC JSONCheckCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n\n    int r;\n    Jsi_RC result = JSI_OK;\n    bool strict = 1;\n    const char *cp;\n    JSI_JSON_DECLARE(p, tokens, 0);\n    Jsi_Value *jsv = Jsi_ValueArrayIndex(interp, args, 1);\n    if (jsv && Jsi_ValueGetBoolean(interp, jsv, &strict) != JSI_OK) \n        return Jsi_LogError(\"Expected boolean\");\n    p.strict = strict;\n    jsv = Jsi_ValueArrayIndex(interp, args, 0);\n    cp = Jsi_ValueToString(interp, jsv, NULL);\n    \n    r = Jsi_JsonParse(&p, cp);\n    Jsi_ValueMakeBool(interp, ret, r == JSI_JSON_ERR_NONE);\n    Jsi_JsonFree(&p);\n    return result;\n}\n\n// Apply JSON quoting to str and append result to dsPtr.\nchar *\nJsi_JSONQuote(Jsi_Interp *interp, const char *str, int len, Jsi_DString *dsPtr)\n{\n    const char *cp = str;\n    int i = 0;\n    if (len<0)\n        len = Jsi_Strlen(str);\n    char cbuf[10];\n    Jsi_DSAppend(dsPtr,\"\\\"\",NULL);\n    while (*cp && i++<len) {\n        if (*cp == '\\\\' /* || *cp == '/' */ || *cp == '\\\"') {\n            cbuf[0] = '\\\\';\n            cbuf[1] = *cp;\n            cbuf[2] = 0;\n            Jsi_DSAppend(dsPtr,cbuf,NULL);\n        } else if (!isprint(*cp)) {\n            int ilen;\n            switch (*cp) {\n                case '\\b': Jsi_DSAppend(dsPtr,\"\\\\b\",NULL); break;\n                case '\\n': Jsi_DSAppend(dsPtr,\"\\\\n\",NULL); break;\n                case '\\r': Jsi_DSAppend(dsPtr,\"\\\\r\",NULL); break;\n                case '\\f': Jsi_DSAppend(dsPtr,\"\\\\f\",NULL); break;\n                case '\\t': Jsi_DSAppend(dsPtr,\"\\\\t\",NULL); break;\n                default:\n                    if ((ilen = Jsi_UtfEncode(cp, cbuf))) {\n                        Jsi_DSAppend(dsPtr,cbuf,NULL);\n                        cp += (ilen-1);\n                    }\n            }\n        } else {\n            cbuf[0] = *cp;\n            cbuf[1] = 0;\n            Jsi_DSAppend(dsPtr,cbuf,NULL);\n        }\n        cp++;\n    }\n    \n    Jsi_DSAppend(dsPtr,\"\\\"\", NULL);\n    return Jsi_DSValue(dsPtr);;\n}\n\nstatic Jsi_RC JSONStringifyCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    bool strict = 1;\n    Jsi_Value *jsv = Jsi_ValueArrayIndex(interp, args, 1);\n    if (jsv && Jsi_ValueGetBoolean(interp, jsv, &strict) != JSI_OK) \n        return Jsi_LogError(\"Expected boolean\");\n    int quote = JSI_OUTPUT_JSON;\n    if (strict) quote|=JSI_JSON_STRICT;\n    Jsi_DString dStr = {};\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_ValueGetDString(interp, arg, &dStr, quote);\n    Jsi_ValueFromDS(interp, &dStr, ret);\n    return JSI_OK;\n}\n\nJsi_RC Jsi_CommandInvoke(Jsi_Interp *interp, const char *cmdstr, Jsi_Value *args, Jsi_Value **ret)\n{\n    Jsi_Value *func = Jsi_NameLookup(interp, cmdstr);\n    if (func)\n        return Jsi_FunctionInvoke(interp, func, args, ret, NULL);\n    return Jsi_LogError(\"can not find cmd: %s\", cmdstr);\n}\n\nstatic Jsi_CmdSpec jsonCmds[] = {\n    { \"check\",      JSONCheckCmd,       1, 2, \"str:string, strict:boolean=true\", .help=\"Return true if str is JSON\", .retType=(uint)JSI_TT_BOOLEAN },\n    { \"parse\",      JSONParseCmd,       1, 2, \"str:string, strict:boolean=true\", .help=\"Parse JSON and return js\", .retType=(uint)JSI_TT_ANY },\n    { \"stringify\",  JSONStringifyCmd,   1, 2, \"value:any,  strict:boolean=true\", .help=\"Return JSON from a js object\", .retType=(uint)JSI_TT_STRING },\n    { NULL, 0,0,0,0, .help=\"Commands for handling JSON data\" }\n};\n\nJsi_RC jsi_InitJSON(Jsi_Interp *interp, int release) {\n    if (release) return JSI_OK;\n    Jsi_CommandCreateSpecs(interp, \"JSON\", jsonCmds, NULL, 0);\n#ifdef TEST_JSON_INVOKE\n    Jsi_Value *ret = Jsi_ValueNew1(interp);\n    Jsi_CommandInvokeJSON(interp, \"Info.cmds\", \"[\\\"*\\\", true]\", ret);\n    Jsi_DString dStr = {};\n    Jsi_Puts(NULL, Jsi_ValueGetDString(interp, ret, &dStr, 1), -1);\n    Jsi_DSFree(&dStr);\n    Jsi_DecrRefCount(interp, ret);\n#endif\n    return JSI_OK;\n}\n#endif\n", "#if JSI__MYSQL==1\n/* JSI Javascript Interface to MySql. */\n\ntypedef enum { MYSQL_SIG_DB = 0xbeefdeaa, MYSQL_SIG_FUNC, MYSQL_SIG_EXEC, MYSQL_SIG_STMT } MySql_Sig;\n\n#define SQLSIGASSERT(s,n) assert(s->sig == MYSQL_SIG_##n)\n#define SQLSIGINIT(s,n) s->sig = MYSQL_SIG_##n\n\n#ifndef NDEBUG\n#ifndef _JSI_MEMCLEAR\n#define _JSI_MEMCLEAR(s) memset(s, 0, sizeof(*s));\n#endif\n#else\n#define _JSI_MEMCLEAR(s)\n#endif\n#ifndef JSI_DB_DSTRING_SIZE\n#define JSI_DB_DSTRING_SIZE 2000\n#endif\n\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <mysql/mysql.h>\n#include <mysql/my_config.h>\n\n#if JSI__MEMDEBUG\n#include \"jsiInt.h\"\n#else\n#include \"jsi.h\"\nJSI_EXTENSION_INI\n#endif\n\n#ifndef NUM_PREPARED_STMTS\n#define NUM_PREPARED_STMTS 100\n#endif\n#ifndef MAX_PREPARED_STMTS\n#define MAX_PREPARED_STMTS 10000\n#endif\n\n#ifndef JSI_DBQUERY_PRINTF\n#define JSI_DBQUERY_PRINTF(fmt, ...) fprintf(stderr, fmt, ##__VA_ARGS__)\n#endif\n\ntypedef struct mydb_ObjCmd {\n    int init;\n    int activeCnt;  /* Count of active objects. */ \n    int newCnt;  /* Total number of new. */ \n} mydb_ObjCmd;\n\nstatic mydb_ObjCmd mydbObjCmd = {};\n\nstatic Jsi_OptionSpec mydb_ObjCmd_Specs[] =\n{\n    JSI_OPT(INT,   mydb_ObjCmd, init, .help=\"Init counter\"),\n    JSI_OPT(INT,   mydb_ObjCmd, activeCnt, .help=\"Number of active objects\"),\n    JSI_OPT(INT,   mydb_ObjCmd, newCnt,    .help=\"Number of new calls\"),\n    JSI_OPT_END(mydb_ObjCmd, .help=\"Options for Sqlite module\")\n};\n\n/*\n** New SQL functions can be created as JSI scripts.  Each such function\n** is described by an instance of the following structure.\n*/\ntypedef struct SqlFunc SqlFunc;\nstruct SqlFunc {\n    MySql_Sig sig;\n    Jsi_Interp  *interp;    /* The JSI interpret to execute the function */\n    Jsi_Value   *tocall;    /* Callee */\n    char        *pScript;   /* The char* representation of the script */\n    Jsi_DString dScript;\n    char        *zName;     /* Name of this function */\n    SqlFunc     *pNext;     /* Next function on the list of them all */\n};\n\n/*\n** New collation sequences function can be created as JSI scripts.  Each such\n** function is described by an instance of the following structure.\n*/\ntypedef struct SqlCollate SqlCollate;\nstruct SqlCollate {\n    MySql_Sig sig;\n    Jsi_Interp  *interp;   /* The JSI interpret to execute the function */\n    Jsi_Value   *zScript;  /* The function to be run */\n    SqlCollate  *pNext;    /* Next function on the list of them all */\n};\n\ntypedef struct SqlFieldResults {\n    MYSQL_FIELD *field;\n    my_bool isnull;\n    unsigned long len;\n    int vsize;\n    enum enum_field_types mapType; // Maps to one of DOUBLE, BOOL, VARCHAR or TIMESTAMP\n    Jsi_OptionId jsiTypeMap;  // Type of data for Jsi.\n    union { // Space for data.\n        char vchar;\n        double vdouble;  // Must convert if Jsi_Number is a long double.\n        long long vlonglong;\n        my_bool vbool;\n        char *vstring;\n        MYSQL_TIME timestamp;\n    } buffer;\n} SqlFieldResults;\n\n/*\n    result_bind[0].buffer_type = MYSQL_TYPE_LONG;\n    result_bind[0].buffer = &result_int;\n    result_bind[0].buffer_length = sizeof(result_int);\n    result_bind[0].length = &result_len;\n    result_bind[0].is_null = &result_is_null[0];\n*/\n\n/*\n** Prepared statements are cached for faster execution.  Each prepared\n** statement is described by an instance of the following structure.\n*/\ntypedef struct MysqlPrep MysqlPrep;\nstruct MysqlPrep {\n    MySql_Sig sig;\n    int deleting;\n    MysqlPrep *pNext;  /* Next in linked list */\n    MysqlPrep *pPrev;  /* Previous on the list */\n    MYSQL_STMT    *myStmt;  /* The prepared statement */\n    MYSQL_RES     *resultMetaData;\n    MYSQL_RES     *paramMetaData;\n    MYSQL_BIND    *bindParam;\n    MYSQL_BIND    *bindResult;\n    SqlFieldResults *fieldResult;\n    SqlFieldResults *fieldParam;\n    //int resultColumns, paramCount;\n    uint nSql;                /* chars in zSql[] */\n    char *zSql;        /* Text of the SQL statement */\n    const char *zRawSql;     /* SQL before named params extracted. */\n    \n    int numParam; // Count of input params.\n    int numCol; // Count of columns in results\n    Jsi_HashEntry *entry;\n    Jsi_ListEntry *elPtr;\n    char **colNames;       /* List of column names. */\n    Jsi_OptionId *colTypes;\n    // Following used by named params.\n    char *origSql;\n    char **paramNames;       /* List of param names. */\n    int *paramMyTypes;\n    int paramCnt;\n    Jsi_DString *naStr;\n};\n\nstatic const char *myexecFmtStrs[] = {\n    \"rows\", \"arrays\", \"array1d\", \"list\", \"column\", \"json\",\n    \"json2\", \"html\", \"csv\", \"insert\", \"line\", \"tabs\", \"none\", NULL\n};\n\ntypedef enum {\n    _mdb_EF_ROWS, _mdb_EF_ARRAYS, _mdb_EF_ARRAY1D, _mdb_EF_LIST, _mdb_EF_COLUMN, _mdb_EF_JSON,\n    _mdb_EF_JSON2, _mdb_EF_HTML, _mdb_EF_CSV, _mdb_EF_INSERT, _mdb_EF_LINE, _mdb_EF_TABS, _mdb_EF_NONE\n} mdbOutput_Mode;\n\n\nconst char *mdbTypeChkStrs[] = { \"convert\", \"error\", \"warn\", \"disable\", NULL };\n\ntypedef enum { mdbTypeCheck_Cast, mdbTypeCheck_Error, mdbTypeCheck_Warn,  mdbTypeCheck_None } mdbTypeCheck_Mode;\n\ntypedef struct QueryOpts {\n    MySql_Sig sig;\n    Jsi_Value *callback, *values;\n    Jsi_Value *paramVar;\n    int limit, objOpts;\n    mdbOutput_Mode mode;\n    mdbTypeCheck_Mode typeCheck;\n    bool mapundef, nocache, headers, noNamedParams, prefetch;\n    const char *separator;\n    const char *nullvalue;\n    const char *table;\n    //const char *CData; // Name of cdata to use for query.\n    const char* objName;\n    Jsi_Value *width;\n    int maxString;\n} QueryOpts;\n\nstatic const char *trcModeStrs[] = {\"eval\", \"delete\", \"prepare\", \"step\", NULL}; // Bit-set packed into an int.\nstatic const char *objSqlModeStrs[] = { \"getSql\", \"noTypes\", \"noDefaults\", \"nullDefaults\", NULL };\nenum {mdbTMODE_EVAL=0x1, mdbTMODE_DELETE=0x2, mdbTMODE_PREPARE=0x4, mdbTMODE_STEP=0x4};\nenum {OBJMODE_SQLONLY=0x1, OBJMODE_NOTYPES=0x2, OBJMODE_NODEFAULTS=0x4, OBJMODE_NULLDEFAULTS=0x8};\n\n\ntypedef struct MySqlObj {\n    MySql_Sig sig;\n    MYSQL  *db;               /* The \"real\" database structure. MUST BE FIRST */\n    Jsi_Interp *interp;        /* The interpreter used for this database */\n    mydb_ObjCmd *_;\n    Jsi_Value *host;\n    const char *user;\n    const char *password;\n    const char *database;\n    int port;\n    char *zNull;               /* Text to substitute for an SQL NULL value */\n    SqlFunc *pFunc;            /* List of SQL functions */\n    int rc;                    /* Return code of most recent mysql_exec() */\n    Jsi_List *stmtCache;\n//    MysqlPrep *stmtList; /* List of prepared statements*/\n//    MysqlPrep *stmtLast; /* Last statement in the list */\n    Jsi_Hash *stmtHash;        /* Hash table for statements. */\n    int maxStmts;               /* The next maximum number of stmtList */\n    int numStmts;                 /* Number of statements in stmtList */\n    bool bindWarn, forceInt, reconnect, enableMulti;\n    int nStep, nSort;          /* Statistics for most recent operation */\n    int nTransaction;          /* Number of nested [transaction] methods */\n    int errorCnt;               /* Count of errors. */\n    Jsi_Value *key;             /* Key, for codec. */\n    int hasOpts;\n    Jsi_Obj *userObjPtr;\n    QueryOpts queryOpts, *optPtr;\n    int objId;\n    int debug;\n    int deleted;\n    Jsi_Event *event;\n    //int trace;\n    Jsi_DString name;\n    int last_errno;\n    Jsi_Number version;\n    int dbflags;\n    Jsi_Value* udata;\n    Jsi_Value *sslKey, *sslCert, *sslCA, *sslCAPath, *sslCipher;\n    Jsi_Hash *typeNameHash;\n} MySqlObj;\n\ntypedef struct MyDbEvalContext {\n    MySqlObj *jdb;                /* Database handle */\n    Jsi_DString *dzSql;               /* Object holding string zSql */\n    const char *zSql;               /* Remaining SQL to execute */\n    MysqlPrep *prep;      /* Current statement */\n    int nCol;                       /* Number of columns returned by pStmt */\n    Jsi_Value *tocall;\n    Jsi_Value *ret;\n    /*OBS */\n    Jsi_Value *pArray;              /* Name of array variable */\n    Jsi_Value *pValVar;             /* Name of list for values. */\n    int nocache;\n    int namedParams;\n} MyDbEvalContext;\n\nstatic Jsi_RC mdbIsNumArray(Jsi_Interp *interp, Jsi_Value *value);\nstatic Jsi_RC mdbPrepareAndBind(MyDbEvalContext *p );\nstatic void mdbReleaseStmt( MySqlObj *jdb, MysqlPrep *prep, int discard );\n\nvoid mdbTypeNameHashInit(MySqlObj *jdb) {\n    Jsi_Interp *interp = jdb->interp;\n    Jsi_Hash *hPtr = jdb->typeNameHash = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);\n    Jsi_HashSet(hPtr, (void*)\"string\", (void*)MYSQL_TYPE_STRING);\n    Jsi_HashSet(hPtr, (void*)\"double\", (void*)MYSQL_TYPE_DOUBLE);\n    Jsi_HashSet(hPtr, (void*)\"integer\", (void*)MYSQL_TYPE_LONGLONG);\n    Jsi_HashSet(hPtr, (void*)\"bool\", (void*)MYSQL_TYPE_TINY);\n    Jsi_HashSet(hPtr, (void*)\"blob\", (void*)MYSQL_TYPE_BLOB);\n    Jsi_HashSet(hPtr, (void*)\"date\", (void*)MYSQL_TYPE_DATE);\n    Jsi_HashSet(hPtr, (void*)\"time\", (void*)MYSQL_TYPE_TIME);\n    Jsi_HashSet(hPtr, (void*)\"timestamp\", (void*)MYSQL_TYPE_TIMESTAMP);\n    Jsi_HashSet(hPtr, (void*)\"datetime\", (void*)MYSQL_TYPE_DATETIME);\n}\n\nstatic Jsi_OptionSpec QueryFmtOptions[] =\n{\n    JSI_OPT(FUNC,   QueryOpts, callback, .help=\"Function to call with each row result\", .flags=0, .custom=0, .data=(void*)\"values:object\" ),\n    JSI_OPT(BOOL,   QueryOpts, headers, .help=\"First row returned contains column labels\"),\n    JSI_OPT(INT,    QueryOpts, limit, .help=\"Maximum number of returned values\"),\n    JSI_OPT(BOOL,   QueryOpts, mapundef, .help=\"In variable binds, map an 'undefined' var to null\"),\n    JSI_OPT(INT,    QueryOpts, maxString, .help=\"If not using prefetch, the maximum string value size (0=8K)\"),\n    JSI_OPT(CUSTOM, QueryOpts, mode, .help=\"Set output mode of returned data\", .flags=0, .custom=Jsi_Opt_SwitchEnum,  .data=myexecFmtStrs),\n    JSI_OPT(BOOL,   QueryOpts, nocache, .help=\"Disable query cache\"),\n    JSI_OPT(BOOL,   QueryOpts, noNamedParams, .help=\"Disable translating sql to support named params\"),\n    JSI_OPT(STRKEY, QueryOpts, nullvalue, .help=\"Null string output (for non-json mode)\"),\n    JSI_OPT(STRKEY, QueryOpts, objName,  .help=\"Object var name for CREATE/INSERT: replaces %s with fields in query\" ),\n    JSI_OPT(CUSTOM, QueryOpts, objOpts,     .help=\"Options for objName\", .flags=0,  .custom=Jsi_Opt_SwitchBitset,  .data=objSqlModeStrs),\n    JSI_OPT(ARRAY,  QueryOpts, paramVar, .help=\"Array var to use for parameters\" ),\n    JSI_OPT(BOOL,   QueryOpts, prefetch, .help=\"Let client library cache entire results\"),\n    JSI_OPT(STRKEY, QueryOpts, separator, .help=\"Separator string (for csv and text mode)\"),\n    //JSI_OPT(STRKEY, QueryOpts, CData, .help=\"Name of CData object to use\"),\n    JSI_OPT(STRKEY, QueryOpts, table, .help=\"Table name for mode=insert\"),\n    JSI_OPT(CUSTOM, QueryOpts, typeCheck,   .help=\"Type check mode (error)\", .flags=0, .custom=Jsi_Opt_SwitchEnum, .data=mdbTypeChkStrs),\n    JSI_OPT(ARRAY,  QueryOpts, values, .help=\"Values for ? bind parameters\" ),\n    JSI_OPT(CUSTOM, QueryOpts, width, .help=\"In column mode, set column widths\", .flags=0, .custom=Jsi_Opt_SwitchValueVerify, .data=(void*)mdbIsNumArray),\n    JSI_OPT_END(QueryOpts, .help=\"MySql query options\")\n};\n\n\n#ifndef jsi_IIOF\n#define jsi_IIOF .flags=JSI_OPT_INIT_ONLY\n#define jsi_IIRO .flags=JSI_OPT_READ_ONLY\n#endif\nstatic Jsi_OptionSpec SqlOptions[] =\n{\n    JSI_OPT(BOOL,   MySqlObj, bindWarn, .help=\"Treat failed variable binds as a warning\", jsi_IIOF),\n    JSI_OPT(STRKEY, MySqlObj, database, .help=\"Database to use\", jsi_IIOF ),\n    JSI_OPT(CUSTOM, MySqlObj, debug,    .help=\"Enable debug trace for various operations\", .flags=0, .custom=Jsi_Opt_SwitchBitset,  .data=trcModeStrs),\n    JSI_OPT(BOOL,   MySqlObj, enableMulti,.help=\"Accept muiltiple semi-colon separated statements in eval()\", jsi_IIOF),\n    JSI_OPT(INT,    MySqlObj, errorCnt, .help=\"Count of errors\", .flags=JSI_OPT_READ_ONLY),\n    JSI_OPT(CUSTOM, MySqlObj, queryOpts, .help=\"Default options for exec\", .flags=0, .custom=Jsi_Opt_SwitchSuboption, .data=QueryFmtOptions),\n    JSI_OPT(BOOL,   MySqlObj, forceInt, .help=\"Bind float as int if possible\"),\n    JSI_OPT(STRING, MySqlObj, host,     .help=\"IP address or host name for mysqld (default is 127.0.0.1)\"),\n    JSI_OPT(INT,    MySqlObj, maxStmts, .help=\"Max cache size for compiled statements\"),\n    JSI_OPT(DSTRING,MySqlObj, name,     .help=\"Name for this db handle\"),\n    JSI_OPT(INT,    MySqlObj, numStmts, .help=\"Current size of compiled statement cache\", .flags=JSI_OPT_READ_ONLY),\n    JSI_OPT(STRKEY, MySqlObj, password, .help=\"Database password.\", jsi_IIOF ),\n    JSI_OPT(INT,    MySqlObj, port,     .help=\"IP port for mysqld\", jsi_IIOF),\n    JSI_OPT(BOOL,   MySqlObj, reconnect, .help=\"Reconnect\"),\n    JSI_OPT(STRING, MySqlObj, sslKey, .help=\"SSL key\"),\n    JSI_OPT(STRING, MySqlObj, sslCert, .help=\"SSL Cert\"),\n    JSI_OPT(STRING, MySqlObj, sslCA, .help=\"SSL CA\"),\n    JSI_OPT(STRING, MySqlObj, sslCAPath, .help=\"SSL CA path\"),\n    JSI_OPT(STRING, MySqlObj, sslCipher, .help=\"SSL Cipher\"),\n    JSI_OPT(OBJ,    MySqlObj, udata,    .help=\"User data.\" ),\n    JSI_OPT(STRKEY, MySqlObj, user,     .help=\"Database user name. Default is current user-name.\", jsi_IIOF ),\n    JSI_OPT(DOUBLE, MySqlObj, version,  .help=\"Mysql version number\", .flags=JSI_OPT_READ_ONLY),\n    JSI_OPT_END(MySqlObj, .help=\"MySql options\")\n};\n\n/* Start of code. */\n\n// Convert MySql time to JS unix time in ms. TODO: handle \"neg\" and years outside of unix time.\nstatic Jsi_Number mdbMyTimeToJS(MYSQL_TIME* mtm)\n{\n    struct tm tm;\n    tm.tm_sec = mtm->second;\n    tm.tm_min = mtm->minute;\n    tm.tm_hour = mtm->hour;\n    tm.tm_mday = mtm->day;\n    tm.tm_mon = mtm->month-1;\n    tm.tm_year = mtm->year - 1900;\n    time_t tim = mktime(&tm);\n    if (tim == (time_t)-1)\n        return -1;\n    return (Jsi_Number)tim*1000 + (Jsi_Number)mtm->second_part/1000000.0;\n}\n\nstatic void mdbJsToMyTime(Jsi_Number time, MYSQL_TIME* mtm, int utc)\n{\n    struct tm tm;\n    time_t tim = (time_t)(time/1000);\n    if (utc)\n        gmtime_r(&tim, &tm);\n    else\n        localtime_r(&tim, &tm);\n    mtm->second = tm.tm_sec;\n    mtm->minute = tm.tm_min;\n    mtm->hour = tm.tm_hour;\n    mtm->day = tm.tm_mday;\n    mtm->month = tm.tm_mon+1;\n    mtm->year = tm.tm_year + 1900;\n    Jsi_Number secs = (tim/1000.0);\n    mtm->second_part = (int)((secs-(int)secs)*1000000);\n}\n\nstatic Jsi_RC mdbEvalInit(\n    Jsi_Interp *interp,\n    MyDbEvalContext *p,               /* Pointer to structure to initialize */\n    MySqlObj *jdb,                  /* Database handle */\n    const char* zSql,                /* Value containing SQL script */\n    Jsi_DString *dStr,\n    Jsi_Obj *pArray,                /* Name of Jsi array to set (*) element of */\n    Jsi_Obj *pValVar                  /* Name element in array for list. */\n) {\n    p->dzSql = dStr;\n    p->zSql = Jsi_DSAppend(p->dzSql, zSql?zSql:\"\", NULL);\n    p->jdb = jdb;\n    return JSI_OK;\n}\n\nstatic void mdbEvalFinalize(MyDbEvalContext *p) {\n    if( p->prep) {\n        mdbReleaseStmt(p->jdb, p->prep, p->nocache);\n        p->prep = 0;\n    }\n    Jsi_DSFree(p->dzSql);\n}\n\nstatic void mdbEvalRowInfo( MyDbEvalContext *eval, int *pnCol, char ***papColName, Jsi_OptionId **papColType) {\n    if (!papColName) {\n        //TODO: Array ???\n    }\n    *papColName = eval->prep->colNames;\n    *papColType = eval->prep->colTypes;\n    *pnCol = eval->prep->numCol;\n}\n\n/* Step statement. Return JSI_OK if there is a ROW result, JSI_BREAK if done, else JSI_ERROR. */\nstatic Jsi_RC mdbEvalStepSub(MyDbEvalContext *eval, int release, int *erc) {\n    MySqlObj *jdb = eval->jdb;\n    Jsi_Interp *interp = jdb->interp;\n    MysqlPrep *prep = eval->prep;\n    SQLSIGASSERT(prep, STMT);\n    MYSQL_STMT *myStmt = prep->myStmt;\n\n    if (jdb->debug & mdbTMODE_STEP)\n        JSI_DBQUERY_PRINTF( \"DEBUG: step: %s\\n\", prep->zSql);\n    int m = mysql_stmt_fetch(myStmt);\n    if (m == MYSQL_NO_DATA)\n        return JSI_BREAK;\n    if (m) \n        return Jsi_LogError(\"fetch failed: %s\", mysql_error(jdb->db));\n    return JSI_OK;\n#if 0\n    if( eval->pArray ) {\n        mdbEvalRowInfo(eval, 0, 0, 0);\n    }\n    if (release==0)\n        return JSI_BREAK;\n    eval->prep = 0;\n    return JSI_OK;\n#endif\n}\n\nstatic void mdbRelease1Stmt( MySqlObj *jdb, MysqlPrep *prep ) {\n    // TODO: split out parts reusable by cached query.\n    int i;\n    if (prep->deleting)\n        return;\n    prep->deleting = 1;\n    if (prep->myStmt)\n        mysql_stmt_close(prep->myStmt);\n    if (prep->resultMetaData)\n        mysql_free_result(prep->resultMetaData);\n    if (prep->paramMetaData)\n        mysql_free_result(prep->paramMetaData);\n    if (prep->bindParam)\n        Jsi_Free(prep->bindParam);\n    if (prep->fieldParam)\n        Jsi_Free(prep->fieldParam);\n    if (prep->bindResult) {\n        for (i=0; i<prep->numCol; i++) {\n            MYSQL_BIND *bind = prep->bindResult+i;\n            if (bind->buffer_type == MYSQL_TYPE_STRING && bind->buffer)\n                Jsi_Free(bind->buffer);\n        }\n        Jsi_Free(prep->bindResult);\n    }\n    if (prep->fieldResult)\n        Jsi_Free(prep->fieldResult);\n    if (prep->colTypes)\n        Jsi_Free(prep->colTypes);\n    if (prep->colNames)\n        Jsi_Free(prep->colNames);\n    if (prep->zSql)\n        Jsi_Free(prep->zSql);\n    if (prep->naStr) {\n        Jsi_Free(prep->origSql);\n        Jsi_DSFree(prep->naStr);\n        Jsi_Free(prep->naStr);\n    }\n    if (prep->entry)\n        Jsi_HashEntryDelete(prep->entry);\n    if (prep->elPtr) {\n        Jsi_ListEntry *pPtr = prep->elPtr;\n        prep->elPtr = NULL;\n        Jsi_ListEntryDelete(pPtr);\n    }\n    Jsi_Free(prep);\n    jdb->numStmts--;\n}\n\n\nstatic Jsi_RC mdbStmtFreeProc(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *value) {\n    MySqlObj *jdb = (MySqlObj*)interp;\n    Jsi_ListEntry *l = (Jsi_ListEntry*)hPtr;\n    mdbRelease1Stmt(jdb, (MysqlPrep*)Jsi_ListValueGet(l));\n    return JSI_OK;\n}\n\nstatic void mdbStmtLimit( MySqlObj *jdb)\n{\n    while(jdb->numStmts>jdb->maxStmts ) {\n        Jsi_ListEntry *l = Jsi_ListPopBack(jdb->stmtCache);\n        mdbRelease1Stmt(jdb, (MysqlPrep*)Jsi_ListValueGet(l));\n        jdb->numStmts = Jsi_ListSize(jdb->stmtCache);\n    }\n}\n\n/*\n** Finalize and free a list of prepared statements\n*/\nstatic void mdbFlushStmtCache( MySqlObj *jdb ) {\n    Jsi_ListClear(jdb->stmtCache);\n    jdb->numStmts = 0;\n}\n\n/*\n** Release a statement reference obtained by calling mdbPrepareAndBind().\n** There should be exactly one call to this function for each call to\n** mdbPrepareAndBind().\n**\n** If the discard parameter is non-zero, then the statement is deleted\n** immediately. Otherwise it is added to the LRU list and may be returned\n** by a subsequent call to mdbPrepareAndBind().\n*/\nstatic void mdbReleaseStmt( MySqlObj *jdb, MysqlPrep *prep, int discard ) {\n    if( jdb->maxStmts<=0 || discard ) {\n        /* If the cache is turned off, deallocated the statement */\n        mdbRelease1Stmt(jdb, prep);\n    } else {\n        /* Add the prepared statement to the beginning of the cache list. */\n        if (!prep->elPtr)\n            prep->elPtr = Jsi_ListPushFrontNew(jdb->stmtCache, prep);\n        else\n            Jsi_ListPushFront(jdb->stmtCache, prep->elPtr);\n        mdbStmtLimit(jdb);\n    }\n}\n\nlong long mdbLastInsertRowid(MySqlObj* jdb)\n{\n    return mysql_insert_id(jdb->db);\n}\n\n\nstatic const char *mdbFindEndStr(const char *cp) {\n    const char endc = *cp;\n    cp++;\n    while (*cp && *cp != endc) {\n        if (*cp == '\\\\' && cp[1]) cp++;\n        cp++;\n    }\n    if (*cp != endc)\n        return NULL;\n    return ++cp;\n}\n// Collect named parameters and translate Sql to use ?\nstatic Jsi_RC MySqlExtractParmNames(MySqlObj* jdb, const char *sql, Jsi_DString *sStr, Jsi_DString *nStr) {\n    const char *ocp, *cp = sql;\n    int cnt = 0;\n    while (*cp) {\n        if (*cp == '\\\"'||*cp == '\\'') {\n            ocp = cp;\n            cp = mdbFindEndStr(cp);\n            if (!cp)\n                return JSI_ERROR;\n            Jsi_DSAppendLen(sStr, ocp, cp-ocp+1);\n        } else if ((*cp == '@' || *cp == ':' || *cp == '$' ) && (isalpha(cp[1]) || cp[1] == '_')) {\n            ocp = cp;\n            cp+=2;\n            while (*cp && (isalnum(*cp) || *cp == '_'))\n                cp++;\n            if (*ocp == '$' && *cp == '(') {\n                const char *ttp = NULL, *ttb = NULL, *eq = NULL;\n                cp++;\n                if (*cp == '[')\n                    eq = cp++;\n                while (*cp && (isalnum(*cp) || *cp == '_' || *cp == ':' || *cp == '.' || *cp == ']')) {\n                    if (*cp == ':') {\n                        if (ttp)\n                            return JSI_ERROR;\n                        ttp = cp;\n                    }\n                    if (*cp == ']') {\n                        if (ttb)\n                            return JSI_ERROR;\n                        ttb = cp;\n                        if (cp[1] != ')' && cp[1] != ':' && cp[1] != '.')\n                            return JSI_ERROR;\n                    }\n                    cp++;\n                }\n                if (*cp != ')')\n                    return JSI_ERROR;\n                if (eq && !ttb)\n                    return JSI_ERROR;\n                if (ttp) {\n                    Jsi_DString tStr = {};\n                    Jsi_DSAppendLen(&tStr, ttp+1, (cp - ttp - 1));\n                    if (!jdb->typeNameHash) mdbTypeNameHashInit(jdb);\n                    int rc = (Jsi_HashEntryFind(jdb->typeNameHash, Jsi_DSValue(&tStr)) != NULL);\n                    if (!rc) {\n                        Jsi_DString eStr = {};\n                        Jsi_HashEntry *hPtr;\n                        Jsi_HashSearch search;\n                        Jsi_Interp *interp = jdb->interp;\n                        int n = 0;\n                        for (hPtr = Jsi_HashSearchFirst(jdb->typeNameHash, &search);\n                            hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {\n                            const char *key = (char*)Jsi_HashKeyGet(hPtr);\n                            Jsi_DSAppend(&eStr, (n++?\", \":\"\"), key, NULL);\n                        }\n                        Jsi_LogWarn(\"bind type \\\"%s\\\" is not one of: %s\", Jsi_DSValue(&tStr), Jsi_DSValue(&eStr));\n                        Jsi_DSFree(&eStr);\n                    }\n                    Jsi_DSFree(&tStr);\n                    if (!rc)\n                        return JSI_ERROR;\n                }\n            } else\n                cp--;\n            if (cnt++)\n                Jsi_DSAppendLen(nStr, \" \", 1);\n            Jsi_DSAppendLen(nStr, ocp, cp-ocp+1);\n            Jsi_DSAppendLen(sStr, \"?\", 1);\n        } else if (*cp == '\\\\' && cp[1]) {\n            Jsi_DSAppendLen(sStr, cp, 2);\n            cp++;\n        } else {\n            Jsi_DSAppendLen(sStr, cp, 1);\n        }\n        cp++;\n    }\n    return JSI_OK;\n}\n\n/*\n** Search the cache for a prepared-statement object that implements the\n** first SQL statement in the buffer pointed to by parameter zIn. If\n** no such prepared-statement can be found, allocate and prepare a new\n** one. In either case, bind the current values of the relevant Jsi\n** variables to any $var, :var or @var variables in the statement. Before\n** returning, set *ppPreStmt to point to the prepared-statement object.\n**\n** Output parameter *pzOut is set to point to the next SQL statement in\n** buffer zIn, or to the '\\0' byte at the end of zIn if there is no\n** next statement.\n**\n** If successful, JSI_OK is returned. Otherwise, JSI_ERROR is returned\n** and an error message loaded into interpreter jdb->interp.\n*/\nstatic Jsi_RC mdbPrepareStmt(MyDbEvalContext *p)\n{\n    MySqlObj *jdb = p->jdb;\n    //int namedParams = !jdb->optPtr->noNamedParams;\n    const char *zSql = p->zSql;         /* Pointer to first SQL statement in zIn */\n    MYSQL_STMT *myStmt;            /* Prepared statement object */\n    MysqlPrep *prep = 0;  /* Pointer to cached statement */\n    Jsi_RC rc = JSI_OK;\n    Jsi_Interp *interp = jdb->interp;\n\n\n    Jsi_HashEntry *entry = Jsi_HashEntryFind(jdb->stmtHash, zSql);\n    if (entry && ((prep = (MysqlPrep*)Jsi_HashValueGet(entry)))) {\n        \n        if (jdb->debug & mdbTMODE_PREPARE)\n            JSI_DBQUERY_PRINTF( \"DEBUG: prepare cache-hit: %s\\n\", zSql);\n        myStmt = prep->myStmt;\n\n        /* When a prepared statement is found, unlink it from the\n        ** cache list.  It will later be added back to the beginning\n        ** of the cache list in order to implement LRU replacement.\n        */\n        Jsi_ListPop(jdb->stmtCache, prep->elPtr);\n        jdb->numStmts = Jsi_ListSize(jdb->stmtCache);\n        \n        // Sanity check for schema check: right now we just use number of columns\n        if (prep->numCol != (int)mysql_stmt_field_count(prep->myStmt)) {\n            mdbRelease1Stmt(jdb, prep);\n            prep = NULL;\n        }\n    }\n    \n    /* If no prepared statement was found. Compile the SQL text. Also allocate\n    ** a new MysqlPrep structure.  */\n    if (!prep) {\n        myStmt = mysql_stmt_init(jdb->db);\n        if (!myStmt) \n            return Jsi_LogError(\"can't get statement: %s\", mysql_error(jdb->db));\n        char **paramNames;\n        int paramCnt;\n        int namedParams = 0;\n        Jsi_DString *naStr = NULL;\n        if (p->namedParams)\n        {\n            Jsi_RC rc = JSI_OK;\n            Jsi_DString nsStr, nnStr;\n            Jsi_DSInit(&nsStr);\n            Jsi_DSInit(&nnStr);\n            if (MySqlExtractParmNames(jdb, zSql, &nsStr, &nnStr) != JSI_OK)\n                rc = Jsi_LogError(\"parsing names from query: %s\", zSql);\n            else if (Jsi_DSLength(&nnStr)) {\n                namedParams = 1;\n                zSql = Jsi_DSFreeDup(&nsStr);\n                naStr = (Jsi_DString*)Jsi_Calloc(1, sizeof(*naStr));\n                Jsi_SplitStr(Jsi_DSValue(&nnStr), &paramCnt, &paramNames, \" \", naStr);\n            }\n            Jsi_DSFree(&nsStr);\n            Jsi_DSFree(&nnStr);\n            if (rc != JSI_OK)\n                return rc;\n        }\n\n        if (mysql_stmt_prepare(myStmt, zSql, Jsi_Strlen(zSql)) )\n        {\n            Jsi_LogError(\"error in sql: %s\", mysql_error(jdb->db));\n            mysql_stmt_close(myStmt);\n            if (namedParams) {\n                Jsi_DSFree(naStr);\n                Jsi_Free(naStr);\n                Jsi_Free((char*)zSql);\n            }\n            return JSI_ERROR;\n        }\n\n        if (jdb->debug & mdbTMODE_PREPARE)\n            JSI_DBQUERY_PRINTF( \"DEBUG: prepare new: %s\\n\", zSql);\n        assert( prep==0 );\n        prep = (MysqlPrep*)Jsi_Calloc(1, sizeof(MysqlPrep));\n        jdb->numStmts++;\n        prep->sig = MYSQL_SIG_STMT;\n        prep->myStmt = myStmt;\n        if (!namedParams)\n            prep->zSql = Jsi_Strdup(zSql);\n        else {\n            prep->zSql = (char*)zSql;\n            prep->origSql = Jsi_Strdup(p->zSql);\n            prep->naStr = naStr;\n            prep->paramCnt = paramCnt;\n            prep->paramNames = paramNames;\n        }\n        prep->paramMetaData = mysql_stmt_param_metadata(myStmt);\n        prep->resultMetaData = mysql_stmt_result_metadata(myStmt);\n        prep->numCol = mysql_stmt_field_count(myStmt);\n        if (prep->numCol>0)\n            prep->bindResult = (MYSQL_BIND *)Jsi_Calloc(prep->numCol, sizeof(MYSQL_BIND));\n        prep->numParam = mysql_stmt_param_count(myStmt);\n        if (prep->numParam>0 && !prep->bindParam) {\n            prep->bindParam = (MYSQL_BIND *)Jsi_Calloc(prep->numParam, sizeof(MYSQL_BIND));\n            prep->fieldParam = (SqlFieldResults*)Jsi_Calloc(prep->numParam, sizeof(*prep->fieldParam));\n        }\n        bool isNew = 0;\n        prep->entry = Jsi_HashEntryNew(jdb->stmtHash, p->zSql, &isNew);\n        if (!isNew)\n            JSI_DBQUERY_PRINTF( \"mysql dup stmt entry\");\n        Jsi_HashValueSet(prep->entry, prep);\n    }\n    p->prep = prep;\n    return rc;\n}\n\n/*\n** Return one of JSI_OK, JSI_BREAK or JSI_ERROR. If JSI_ERROR is\n** returned, then an error message is stored in the interpreter before\n** returning.\n**\n** A return value of JSI_OK means there is a row of data available. The\n** data may be accessed using mdbEvalRowInfo() and dbEvalColumnValue(). This\n** is analogous to a return of _MYSQLN_(ROW) from mysql_step(). If JSI_BREAK\n** is returned, then the SQL script has finished executing and there are\n** no further rows available. This is similar to _MYSQLN_(DONE).\n*/\nstatic Jsi_RC mdbEvalPrep(MyDbEvalContext *p) {\n    MysqlPrep *prep = p->prep;\n    Jsi_Interp *interp = p->jdb->interp;\n    Jsi_RC rc = JSI_OK;\n    if( p->prep==0 ) {\n        rc = mdbPrepareAndBind(p); //p->jdb, p->zSql, &p->zSql, &p->prep);\n        if( rc!=JSI_OK )\n            return rc;\n        prep = p->prep;\n        if (p->jdb->optPtr->prefetch) {\n            my_bool aBool = 1;\n            mysql_stmt_attr_set(prep->myStmt, STMT_ATTR_UPDATE_MAX_LENGTH, &aBool);\n        }\n        if (mysql_stmt_execute(prep->myStmt)) {\n            Jsi_Interp *interp = p->jdb->interp;\n            rc = Jsi_LogError(\"execute failed: %s\", mysql_error(p->jdb->db));\n        }\n        if (p->jdb->optPtr->prefetch && mysql_stmt_store_result(prep->myStmt)) {\n            Jsi_LogWarn(\"prefetch failed, disabling: %s\", mysql_error(p->jdb->db));\n            p->jdb->optPtr->prefetch = 0;\n        }\n        MYSQL_RES *res = mysql_stmt_result_metadata(prep->myStmt);\n        MYSQL_FIELD *field;\n        if (res) {\n            // Setup field mappings to/from Jsi.\n            prep->fieldResult = (SqlFieldResults*)Jsi_Calloc(res->field_count, sizeof(*prep->fieldResult));\n            prep->colNames = (char**)Jsi_Calloc(res->field_count, sizeof(char*));\n            prep->colTypes = (Jsi_OptionId*)Jsi_Calloc(res->field_count, sizeof(int));\n            int iCnt = 0;\n            while((field = mysql_fetch_field(res)))\n            {\n                assert(iCnt<prep->numCol);\n                SqlFieldResults *fres = prep->fieldResult+iCnt;\n                MYSQL_BIND *bindResult = prep->bindResult+iCnt;\n                \n                bindResult->buffer = &fres->buffer.vchar;\n                fres->field = field;\n                prep->colNames[iCnt] = field->name;\n                switch (field->type) {\n                    case MYSQL_TYPE_TINY:\n                    case MYSQL_TYPE_BIT:\n                        if (field->length == 1) {\n                            fres->jsiTypeMap = JSI_OPTION_BOOL;\n                            fres->mapType = MYSQL_TYPE_DOUBLE;\n                            fres->vsize = 1;\n                            break;\n                            \n                        }\n                    case MYSQL_TYPE_SHORT:\n                    case MYSQL_TYPE_LONG:\n                    case MYSQL_TYPE_DECIMAL:\n                        fres->jsiTypeMap = JSI_OPTION_INT64;\n                        fres->mapType = MYSQL_TYPE_LONG;\n                        fres->vsize = sizeof(long long);\n                        break;\n                    case MYSQL_TYPE_LONGLONG:\n                        fres->jsiTypeMap = JSI_OPTION_INT64;\n                        fres->mapType = MYSQL_TYPE_LONGLONG;\n                        fres->vsize = sizeof(long long);\n                        break;\n                    \n                    case MYSQL_TYPE_FLOAT:\n                    case MYSQL_TYPE_DOUBLE:\n                        fres->jsiTypeMap = JSI_OPTION_DOUBLE;\n                        fres->mapType = MYSQL_TYPE_DOUBLE;\n                        fres->vsize = sizeof(double);\n                        break;\n                    case MYSQL_TYPE_TIME:\n                    case MYSQL_TYPE_DATE:\n                    case MYSQL_TYPE_DATETIME:\n                    case MYSQL_TYPE_TIMESTAMP:\n                        fres->jsiTypeMap = JSI_OPTION_TIME_D; //TODO: time\n                        fres->mapType = MYSQL_TYPE_DATETIME;\n                        fres->vsize = sizeof(MYSQL_TIME);\n                        break;\n                    case MYSQL_TYPE_STRING:\n                    default:\n                        if (IS_NUM(field->type)) {\n                            fres->mapType = MYSQL_TYPE_LONGLONG;\n                            fres->jsiTypeMap = JSI_OPTION_DOUBLE;\n                            fres->vsize = sizeof(double);\n                        } else {\n                            fres->jsiTypeMap = JSI_OPTION_STRING;\n                            fres->mapType = MYSQL_TYPE_STRING;\n                            if (p->jdb->optPtr->prefetch)\n                                fres->vsize = field->max_length;\n                            else\n                                fres->vsize = p->jdb->optPtr->maxString;\n                            if (fres->vsize <= 0)\n                                fres->vsize = JSI_BUFSIZ;\n                            bindResult->buffer = fres->buffer.vstring = (char*)Jsi_Malloc(fres->vsize);\n                            fres->buffer.vstring[0] = 0;\n                        }\n                        break;\n                }\n                prep->colTypes[iCnt] = fres->jsiTypeMap;\n                bindResult->buffer_type = fres->mapType;\n                bindResult->buffer_length = fres->vsize;\n                bindResult->length = &fres->len;\n                bindResult->is_null = &fres->isnull;\n                iCnt++;\n            }\n        }\n        else return JSI_BREAK;\n        if (mysql_stmt_bind_result(prep->myStmt, prep->bindResult)) {\n            fprintf(stderr, \"mysql_stmt_bind_Result(), failed. Error:%s\\n\", mysql_stmt_error(prep->myStmt));\n            return JSI_ERROR;\n        }\n        mysql_free_result(res);\n    }\n    return rc;\n}\n\nstatic Jsi_RC mdbEvalStep(MyDbEvalContext *p) {\n    Jsi_RC rc = JSI_OK;\n    if( p->prep==0)\n        rc = mdbEvalPrep(p);\n    if (rc == JSI_BREAK)\n        return JSI_BREAK;\n    if (rc == JSI_OK)\n        rc = mdbEvalStepSub(p, 1, NULL);\n    return rc;\n}\n\nconst char *mysqlGetbindParamName(MysqlPrep* pStmt, int n) {\n    if (n>=1 && n<=pStmt->paramCnt)\n        return pStmt->paramNames[n-1];\n    return NULL;\n}\n  \n/*\nenum enum_field_types { MYSQL_TYPE_DECIMAL, MYSQL_TYPE_TINY,\n                        MYSQL_TYPE_SHORT,  MYSQL_TYPE_LONG,\n                        MYSQL_TYPE_FLOAT,  MYSQL_TYPE_DOUBLE,\n                        MYSQL_TYPE_NULL,   MYSQL_TYPE_TIMESTAMP,\n                        MYSQL_TYPE_LONGLONG,MYSQL_TYPE_INT24,\n                        MYSQL_TYPE_DATE,   MYSQL_TYPE_TIME,\n                        MYSQL_TYPE_DATETIME, MYSQL_TYPE_YEAR,\n                        MYSQL_TYPE_NEWDATE, MYSQL_TYPE_VARCHAR,\n                        MYSQL_TYPE_BIT,\n                        MYSQL_TYPE_NEWDECIMAL=246,\n                        MYSQL_TYPE_ENUM=247,\n                        MYSQL_TYPE_SET=248,\n                        MYSQL_TYPE_TINY_BLOB=249,\n                        MYSQL_TYPE_MEDIUM_BLOB=250,\n                        MYSQL_TYPE_LONG_BLOB=251,\n                        MYSQL_TYPE_BLOB=252,\n                        MYSQL_TYPE_VAR_STRING=253,\n                        MYSQL_TYPE_STRING=254,\n                        MYSQL_TYPE_GEOMETRY=255\n\n};\n*/\n/*\n * MYSQL_TYPE_TINY  1\nMYSQL_TYPE_SHORT    2\nMYSQL_TYPE_LONG 4\nMYSQL_TYPE_LONGLONG 8\nMYSQL_TYPE_FLOAT    4\nMYSQL_TYPE_DOUBLE   8\nMYSQL_TYPE_TIME sizeof(MYSQL_TIME)\nMYSQL_TYPE_DATE sizeof(MYSQL_TIME)\nMYSQL_TYPE_DATETIME sizeof(MYSQL_TIME)\nMYSQL_TYPE_STRING   data length\nMYSQL_TYPE_BLOB data_length\n*/\n\n\nstatic Jsi_RC mdbPrepareAndBind(MyDbEvalContext *p)\n{\n    if (mdbPrepareStmt(p) != JSI_OK)\n        return JSI_ERROR;\n    MysqlPrep *prep = p->prep;\n    MySqlObj *jdb = p->jdb;\n    Jsi_Interp *interp = jdb->interp;\n    Jsi_Value *pv = NULL, *apv = NULL;\n    char tname[50];\n\n    Jsi_RC rc = JSI_OK;\n    int i, n, nVar = prep->numParam;\n\n    if (nVar<=0)\n        return rc;\n    if (!prep->bindParam)\n        prep->bindParam = (MYSQL_BIND*)Jsi_Calloc(nVar, sizeof(MYSQL_BIND));\n    else\n        memset(prep->bindParam, 0, (nVar * sizeof(MYSQL_BIND)));\n    for(i=1; i<=nVar; i++) {\n        int btype = 0;\n        int isInt = 0;\n        int isBlob = 0;\n        const char *zVar = mysqlGetbindParamName(prep, i);\n        tname[0] = 0;\n        if (zVar == NULL) {\n            if (!jdb->optPtr || !(apv=jdb->optPtr->values))\n                return Jsi_LogError(\"? bind without values for param %d\", i);\n            if (!(pv =Jsi_ValueArrayIndex(interp, apv, i-1))) \n                return Jsi_LogError(\"array element %d missing\", nVar);\n        }\n        else if ((zVar[0]!='$' && zVar[0]!=':' && zVar[0]!='@') ) \n            return Jsi_LogError(\"can not find bind var %s\", zVar); else {\n           \n            int zvLen = Jsi_Strlen(zVar);\n            char *zcp;\n            if (zVar[0] =='$' && ((zcp = Jsi_Strchr(zVar,'('))) && zVar[zvLen-1] == ')')\n            {\n                Jsi_DString vStr;\n                Jsi_DSInit(&vStr);\n                Jsi_DSAppendLen(&vStr, zVar+1, (zcp-zVar-1));\n                int slen = Jsi_Strlen(zcp);\n                const char *ttp;\n                if (jdb->optPtr->typeCheck!=mdbTypeCheck_None && (ttp = Jsi_Strchr(zVar,':'))) {\n                    // Extract bind-type.\n                    Jsi_DString tStr = {};\n                    int tlen = Jsi_Strlen(ttp+1);\n                    Jsi_DSAppendLen(&tStr, ttp+1, tlen-1);\n                    snprintf(tname, sizeof(tname), \"%s\", Jsi_DSValue(&tStr));\n                    Jsi_HashEntry *hPtr = Jsi_HashEntryFind(jdb->typeNameHash, tname);\n                    assert(hPtr);\n                    btype = (long)Jsi_HashValueGet(hPtr);\n                    Jsi_DSFree(&tStr);\n                    slen -= tlen;\n                }\n\n                if (isdigit(zcp[1])) {\n                    Jsi_DSAppendLen(&vStr, \"[\", 1);\n                    Jsi_DSAppendLen(&vStr, zcp+1, slen-2);\n                    Jsi_DSAppendLen(&vStr, \"]\", 1);\n                } else {\n                    if (zcp[1] != '[')\n                        Jsi_DSAppendLen(&vStr, \".\", 1);\n                    Jsi_DSAppendLen(&vStr, zcp+1, slen-2);\n                }\n                pv = Jsi_NameLookup(interp, Jsi_DSValue(&vStr));\n                Jsi_DSFree(&vStr);\n            } else\n                pv = Jsi_VarLookup(interp, &zVar[1]);\n        }\n        Jsi_Number r;\n        SqlFieldResults *fres = prep->fieldParam+i-1;\n        MYSQL_BIND *bind = prep->bindParam+i-1;\n        memset(bind, 0, sizeof(*bind));\n        // Now create binding.\n        if(!pv ) {\n            if (!jdb->bindWarn) {\n                rc = Jsi_LogError(\"unknown bind param: %s\", zVar);\n                break;\n            } else\n                Jsi_LogWarn(\"unknown bind param: %s\", zVar);\n        } else {\n            if (btype && !Jsi_ValueIsUndef(interp, pv)) {\n                int done = 0, match = 1, cast = (jdb->optPtr->typeCheck==mdbTypeCheck_Cast);\n                switch (btype) {\n                    case MYSQL_TYPE_BLOB:\n                        isBlob = 1;\n                    case MYSQL_TYPE_STRING:\n                        if (cast)\n                            Jsi_ValueToString(interp, pv, &n);\n                        else\n                            match = Jsi_ValueIsString(interp, pv); \n                        break;\n                    case MYSQL_TYPE_DOUBLE:\n                        if (cast)\n                            Jsi_ValueToNumber(interp, pv);\n                        else\n                            match = Jsi_ValueIsNumber(interp, pv); \n                        break;\n                    case MYSQL_TYPE_LONGLONG:\n                        isInt = 1;\n                        if (cast)\n                            Jsi_ValueToNumber(interp, pv);\n                        else\n                            match = Jsi_ValueIsNumber(interp, pv); \n                        break;\n                    case MYSQL_TYPE_TINY:\n                        if (cast)\n                            Jsi_ValueToBool(interp, pv);\n                        else\n                            match = Jsi_ValueIsBoolean(interp, pv); \n                        break;\n                    case MYSQL_TYPE_TIME:\n                    case MYSQL_TYPE_DATE:\n                    case MYSQL_TYPE_DATETIME:\n                    case MYSQL_TYPE_TIMESTAMP:\n                        if (cast)\n                            Jsi_ValueToNumber(interp, pv);\n                        else if (!Jsi_ValueIsNumber(interp, pv))\n                            goto errout;\n                        Jsi_GetNumberFromValue(interp, pv, &r);\n                        bind->buffer_type = (enum enum_field_types)btype;\n                        bind->buffer=&fres->buffer.timestamp;\n                        bind->buffer_length = sizeof(fres->buffer.timestamp);\n                        bind->length = NULL;\n                        mdbJsToMyTime(r, &fres->buffer.timestamp, 1);\n                        done = 1;\n                        break;\n                    default:\n                        Jsi_LogBug(\"Unhandled bind type: %s = %d\", tname, btype);\n                }\n                if (done)\n                    continue;\n                 if (cast == 0 && match == 0) \nerrout:\n                 {\n                    int ltyp = (jdb->optPtr->typeCheck==mdbTypeCheck_Error?JSI_LOG_ERROR:JSI_LOG_WARN);\n                    Jsi_LogMsg(interp, ltyp, \"bind param \\\"%s\\\" type is not \\\"%s\\\"\", zVar, tname);\n                    if (ltyp == JSI_LOG_ERROR)\n                        return JSI_ERROR;\n                }\n            }\n            \n            if (Jsi_ValueIsBoolean(interp, pv)) {\n                bool nb;\n                Jsi_GetBoolFromValue(interp, pv, &nb);\n                n = nb;\n                bind->buffer_type = MYSQL_TYPE_TINY;\n                bind->buffer = &fres->buffer.vchar;\n                bind->buffer_length = sizeof(fres->buffer.vchar);\n                bind->length = &fres->len;\n                //bind->is_null = &fres->isnull;\n                fres->buffer.vchar = n;\n                \n            } else if (Jsi_ValueIsNumber(interp, pv)) {\n                Jsi_Number r;\n                Jsi_Wide wv;\n                Jsi_GetNumberFromValue(interp, pv, &r);\n                wv = (Jsi_Wide)r;\n                bind->buffer_type = MYSQL_TYPE_DOUBLE;\n                bind->buffer = &fres->buffer.vdouble;\n                bind->buffer_length = sizeof(fres->buffer.vdouble);\n                bind->length = &fres->len;\n                fres->buffer.vdouble = (double)r;\n                if (isInt || (jdb->forceInt && (((Jsi_Number)wv)-r)==0)) {\n                    bind->buffer = &fres->buffer.vlonglong;\n                    bind->buffer_type = MYSQL_TYPE_LONGLONG;\n                    bind->buffer_length = sizeof(fres->buffer.vlonglong);\n                    fres->buffer.vlonglong = wv;\n                }\n            } else if (Jsi_ValueIsNull(interp, pv) || (Jsi_ValueIsUndef(interp, pv) && jdb->optPtr->mapundef)) {\nbindnull:\n                bind->buffer_type = MYSQL_TYPE_NULL;\n                bind->buffer = &fres->buffer.vchar;\n                bind->buffer_length = sizeof(fres->buffer.vchar);\n                bind->length = &fres->len;\n                fres->buffer.vchar = 0;\n\n            } else if (Jsi_ValueIsString(interp, pv)) {\n                char *sstr = Jsi_ValueGetStringLen(interp, pv, &n);\n                bind->buffer_type = MYSQL_TYPE_STRING;\n                bind->buffer=sstr;\n                bind->buffer_length = n;\n                bind->length = NULL;\n                if (isBlob)\n                    bind->buffer_type = MYSQL_TYPE_BLOB;\n            } else {\n                if (!jdb->bindWarn) {\n                    rc = Jsi_LogError(\"bind param must be string/number/bool/null: %s\", zVar);\n                    break;\n                } else {\n                    Jsi_LogWarn(\"bind param must be string/number/bool/null: %s\", zVar);\n                    goto bindnull;\n                }\n            }\n        }\n    }\n    if (mysql_stmt_bind_param(prep->myStmt, prep->bindParam))\n        rc = Jsi_LogError(\"bind failed: %s\", mysql_error(jdb->db));\n    return rc;\n}\n\n\nstatic void mdbClose(MYSQL  *db) {\n        mysql_close(db);\n}\n\nstatic Jsi_RC mdbIsNumArray(Jsi_Interp *interp, Jsi_Value *value)\n{\n    if (!Jsi_ValueIsArray(interp, value)) \n        return Jsi_LogError(\"expected array of numbers\");\n    int i, argc = Jsi_ValueGetLength(interp, value);\n    for (i=0; i<argc; i++) {\n        Jsi_Value *v = Jsi_ValueArrayIndex(interp, value, i);\n        if (!Jsi_ValueIsNumber(interp, v)) \n            return Jsi_LogError(\"expected array of numbers\");\n    }\n    return JSI_OK;\n}\n\n/*\n** JSI calls this procedure when an MYSQL  database command is\n** deleted.\n*/\nstatic void mdbDeleteCmd(MySqlObj *jdb)\n{\n    Jsi_Interp *interp = jdb->interp;\n    if (jdb->debug & mdbTMODE_DELETE)\n        JSI_DBQUERY_PRINTF( \"DEBUG: delete\\n\");\n    if (jdb->stmtCache)\n        mdbFlushStmtCache(jdb);\n    if (jdb->stmtHash)\n        Jsi_HashDelete(jdb->stmtHash);\n    //closeIncrblobChannels(jdb);\n    if (jdb->db) {\n        mdbClose(jdb->db);\n    }\n    while( jdb->pFunc ) {\n        SqlFunc *pFunc = jdb->pFunc;\n        jdb->pFunc = pFunc->pNext;\n        Jsi_DSFree(&pFunc->dScript);\n        Jsi_DecrRefCount(interp, pFunc->tocall);\n        Jsi_Free((char*)pFunc);\n    }\n    if( jdb->zNull ) {\n        Jsi_Free(jdb->zNull);\n    }\n    if (jdb->typeNameHash)\n        Jsi_HashDelete(jdb->typeNameHash);\n    Jsi_OptionsFree(interp, SqlOptions, jdb, 0);\n    if (jdb->stmtCache)\n        Jsi_ListDelete(jdb->stmtCache);\n}\n\n/*\n** Return a JSON formatted value for the iCol'th column of the row currently pointed to by\n** the MyDbEvalContext structure passed as the first argument.\n*/\nstatic void mdbEvalSetColumnJSON(MyDbEvalContext *p, int iCol, Jsi_DString *dStr) {\n    Jsi_Interp *interp = p->jdb->interp;\n    char nbuf[JSI_MAX_NUMBER_STRING];\n    MysqlPrep *prep = p->prep;\n    SqlFieldResults *field = prep->fieldResult+iCol;\n    if (field->isnull) {\n        Jsi_DSAppend(dStr, \"null\", NULL);\n        return;\n    }\n    const char *zBlob = \"\";\n    int bytes = 0;\n\n    switch(field->jsiTypeMap) {\n        case JSI_OPTION_BOOL: {\n            snprintf(nbuf, sizeof(nbuf), \"%s\", field->buffer.vchar?\"true\":\"false\");\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        case JSI_OPTION_INT64: {\n            snprintf(nbuf, sizeof(nbuf), \"%lld\", field->buffer.vlonglong);\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        case JSI_OPTION_DOUBLE: {\n            Jsi_NumberToString(interp, field->buffer.vdouble, nbuf, sizeof(nbuf));\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        //case JSI_OPTION_TIME_T:\n        case JSI_OPTION_TIME_D:\n        case JSI_OPTION_TIME_W: {\n            Jsi_Number jtime = mdbMyTimeToJS(&field->buffer.timestamp);\n            Jsi_NumberToString(interp, jtime, nbuf, sizeof(nbuf));\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        case JSI_OPTION_STRING:\n            zBlob = field->buffer.vstring;\n        default:\n        {\n            if( !zBlob ) {\n                Jsi_DSAppend(dStr, \"null\", NULL);\n                return;\n            }\n            Jsi_JSONQuote(interp, zBlob, bytes, dStr);\n            return;\n        }\n    }\n}\n\nstatic void mdbEvalSetColumn(MyDbEvalContext *p, int iCol, Jsi_DString *dStr) {\n    //Jsi_Interp *interp = p->jdb->interp;\n    char nbuf[JSI_MAX_NUMBER_STRING];\n    MysqlPrep *prep = p->prep;\n    SqlFieldResults *field = prep->fieldResult+iCol;\n    Jsi_Interp *interp = p->jdb->interp;\n    if (field->isnull)\n        return;\n        \n    switch(field->jsiTypeMap) {\n        case JSI_OPTION_STRING: {\n            int bytes = field->len;\n            const char *zBlob = field->buffer.vstring;\n    \n            if( !zBlob ) {\n                const char *nv = p->jdb->optPtr->nullvalue;\n                Jsi_DSAppend(dStr, nv?nv:\"null\", NULL);\n                return;\n            }\n            Jsi_DSAppendLen(dStr, zBlob, bytes);\n            return;\n        }\n        case JSI_OPTION_BOOL: {\n            snprintf(nbuf, sizeof(nbuf), \"%s\", field->buffer.vchar?\"true\":\"false\");\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        case JSI_OPTION_INT64: {\n            snprintf(nbuf, sizeof(nbuf), \"%lld\", field->buffer.vlonglong);\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        //case JSI_OPTION_TIME_T:\n        case JSI_OPTION_TIME_D:\n        case JSI_OPTION_TIME_W: {\n            Jsi_Number jtime = mdbMyTimeToJS(&field->buffer.timestamp);\n            Jsi_NumberToString(interp, jtime, nbuf, sizeof(nbuf));\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        case JSI_OPTION_DOUBLE: {\n            Jsi_NumberToString(interp, field->buffer.vdouble, nbuf, sizeof(nbuf));\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        default:\n            Jsi_LogWarn(\"unknown type: %d\", field->jsiTypeMap);\n    \n    }\n}\n\n\nstatic Jsi_Value* mdbEvalSetColumnValue(MyDbEvalContext *p, int iCol, Jsi_Value **val) {\n    Jsi_Interp *interp = p->jdb->interp;\n    MysqlPrep *prep = p->prep;\n    SqlFieldResults *field = prep->fieldResult+iCol;\n    if (field->isnull)\n        return Jsi_ValueMakeNull(interp, val);\n        \n    switch(field->jsiTypeMap) {\n        case JSI_OPTION_STRING: {\n            int bytes = field->len;\n            char *zBlob = field->buffer.vstring;\n            if( !zBlob ) {\n                return Jsi_ValueMakeNull(interp, val);\n            }\n            zBlob = (char*)Jsi_Malloc(bytes+1);\n            memcpy(zBlob, field->buffer.vstring, bytes);\n            zBlob[bytes] = 0;\n            return Jsi_ValueMakeBlob(interp, val, (unsigned char*)zBlob, bytes+1);\n        }\n        case JSI_OPTION_BOOL:\n            return Jsi_ValueMakeBool(interp, val, field->buffer.vchar);\n        case JSI_OPTION_INT64:\n             return Jsi_ValueMakeNumber(interp, val, (Jsi_Number)field->buffer.vlonglong);\n        //case JSI_OPTION_TIME_T:\n        case JSI_OPTION_TIME_D:\n        case JSI_OPTION_TIME_W: {\n            Jsi_Number jtime = mdbMyTimeToJS(&field->buffer.timestamp);\n            return Jsi_ValueMakeNumber(interp, val, jtime);\n        }\n        case JSI_OPTION_DOUBLE:\n             return Jsi_ValueMakeNumber(interp, val, (Jsi_Number)field->buffer.vdouble);\n        default:\n            Jsi_LogWarn(\"unknown type: %d\", field->jsiTypeMap);\n    }\n    return Jsi_ValueNew1(interp);\n}\n\nstatic Jsi_RC mdbEvalCallCmd( MyDbEvalContext *p, Jsi_Interp *interp, Jsi_RC result)\n{\n    int cnt = 0;\n    Jsi_RC rc = result;\n    Jsi_Value *varg1;\n    Jsi_Obj *argso;\n    char **apColName = NULL;\n    Jsi_OptionId *apColType = NULL;\n    if (p->jdb->debug & mdbTMODE_EVAL)\n        JSI_DBQUERY_PRINTF( \"DEBUG: eval\\n\");\n\n    while( (rc==JSI_OK) && JSI_OK==(rc = mdbEvalStep(p)) ) {\n        int i;\n        int nCol;\n\n        cnt++;\n        mdbEvalRowInfo(p, &nCol, &apColName, &apColType);\n        if (nCol<=0)\n            continue;\n        if (Jsi_ValueIsNull(interp,p->tocall))\n            continue;\n        /* Single object containing sql result members. */\n        varg1 = Jsi_ValueMakeObject(interp, NULL, argso = Jsi_ObjNew(interp));\n        for(i=0; i<nCol; i++) {\n            Jsi_Value *nnv = mdbEvalSetColumnValue(p, i, NULL);\n            Jsi_ObjInsert(interp, argso, apColName[i], nnv, 0);\n        }\n        Jsi_IncrRefCount(interp, varg1);\n        bool rb = Jsi_FunctionInvokeBool(interp, p->tocall, varg1);\n        if (Jsi_InterpGone(interp))\n            return JSI_ERROR;\n        Jsi_DecrRefCount(interp, varg1);\n        if (rb)\n            break;\n    }\n    //mdbEvalFinalize(p);\n\n    if( rc==JSI_OK || rc==JSI_BREAK ) {\n        //Jsi_ResetResult(interp);\n        rc = JSI_OK;\n    }\n    return rc;\n}\n\nstatic MySqlObj *_mysql_getDbHandle(Jsi_Interp *interp, Jsi_Value *_this, Jsi_Func *funcPtr)\n{\n    MySqlObj *jdb = (MySqlObj*)Jsi_UserObjGetData(interp, _this, funcPtr);\n    if (!jdb) {\n        Jsi_LogError(\"MySql call to a non-mysql object\");\n        return NULL;\n    }\n    if (!jdb->db)\n    {\n        Jsi_LogError(\"MySql db is closed\");\n        return NULL;\n    }\n    return jdb;\n}\n\nstatic void mysqlObjErase(MySqlObj *jdb)\n{\n    mdbDeleteCmd(jdb);\n    jdb->db = NULL;\n}\n\nstatic Jsi_RC mysqlObjFree(Jsi_Interp *interp, void *data)\n{\n    MySqlObj *jdb = (MySqlObj*)data;\n    SQLSIGASSERT(jdb,DB);\n    jdb->_->activeCnt--;\n    mysqlObjErase(jdb);\n    _JSI_MEMCLEAR(jdb);\n    Jsi_Free(jdb);\n    return JSI_OK;\n}\n\nstatic bool mysqlObjIsTrue(void *data)\n{\n    MySqlObj *jdb = (MySqlObj*)data;\n    SQLSIGASSERT(jdb,DB);\n    if (!jdb->db) return 0;\n    else return 1;\n}\n\nstatic bool mysqlObjEqual(void *data1, void *data2)\n{\n    //SQLSIGASSERT(data1,DB);\n    //SQLSIGASSERT(data2,DB);\n    return (data1 == data2);\n}\nstatic MYSQL* mdbConnect(Jsi_Interp *interp, MySqlObj* jdb)\n{\n    return mysql_real_connect(jdb->db,\n        jdb->host?Jsi_ValueString(interp, jdb->host, NULL):NULL,\n        jdb->user, jdb->password, jdb->database,\n        jdb->port, 0, jdb->dbflags);\n}\n\n#define FN_MySql JSI_INFO(\"\\\nCreate a mysql client.\")\nstatic Jsi_RC MySqlConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr);\n\nstatic Jsi_RC MySqlReconnectCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                         Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    MySqlObj *jdb  = _mysql_getDbHandle(interp, _this, funcPtr);\n    if (!jdb) return JSI_ERROR;\n    int oldMax = jdb->maxStmts;\n    jdb->maxStmts = 0;\n    mdbStmtLimit(jdb);\n    jdb->maxStmts = oldMax;\n    mysql_close(jdb->db);\n    jdb->db = mysql_init(NULL);\n    if (!mdbConnect(interp, jdb)) \n        return Jsi_LogError(\"reconnect failed: %s\", mysql_error(jdb->db));\n    return JSI_OK;\n}\n\n#define FN_evaluate JSI_INFO(\"\\\nVariable binding is NOT performed.  \\\nReturns number of modified fields\")\nstatic Jsi_RC MySqlEvalCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                         Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    MySqlObj *jdb  = _mysql_getDbHandle(interp, _this, funcPtr);\n    if (!jdb) return JSI_ERROR;\n    int zLen, cnt = 0;\n    Jsi_RC rc = JSI_OK;\n    const char *zSql = Jsi_ValueArrayIndexToStr(interp, args, 0, &zLen);\n\n    if (mysql_real_query(jdb->db, zSql, zLen))\n        rc = Jsi_LogError(\"mysql error: %s\", mysql_error(jdb->db));\n    else if (jdb->enableMulti) {\n        MYSQL_RES *results;\n        int sr = mysql_next_result(jdb->db);\n        while (sr == 0 && (results = mysql_store_result(jdb->db)))\n            mysql_free_result(results);\n        cnt = mysql_field_count(jdb->db);\n    }\n        \n    if (rc == JSI_OK)\n        Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)cnt);\n    return rc;\n}\n\n/*\n** If a field contains any character identified by a 1 in the following\n** array, then the string must be quoted for CSV.\n*/\nstatic const char needCsvQuote[] = {\n  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   \n  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   \n  1, 0, 1, 0, 0, 0, 0, 1,   0, 0, 0, 0, 0, 0, 0, 0, \n  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, \n  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, \n  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, \n  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, \n  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 1, \n  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   \n  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   \n  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   \n  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   \n  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   \n  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   \n  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   \n  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   \n};\n\n/*\n** Output a single term of CSV.  Actually, p->separator is used for\n** the separator, which may or may not be a comma.  p->nullvalue is\n** the null value.  Strings are quoted if necessary.\n*/\nstatic void mdbOutputCsv(QueryOpts *p, const char *z, Jsi_DString *dStr, int bSep)\n{\n    if( z==0 ) {\n        Jsi_DSAppend(dStr,  p->nullvalue?p->nullvalue:\"\", NULL);\n    } else {\n        int i;\n        int nSep = Jsi_Strlen(p->separator);\n        for(i=0; z[i]; i++) {\n            if( needCsvQuote[((unsigned char*)z)[i]] || \n                (z[i]==p->separator[0] && (nSep==1 || memcmp(z, p->separator, nSep)==0)) ) {\n                i = 0;\n                break;\n            }\n        }\n        if( i==0 ) {\n            Jsi_DSAppend(dStr, \"\\\"\", NULL);\n            for(i=0; z[i]; i++) {\n                if( z[i]=='\"' ) Jsi_DSAppend(dStr, \"\\\"\", NULL);\n                Jsi_DSAppendLen(dStr, z+i, 1);\n            }\n            Jsi_DSAppend(dStr, \"\\\"\", NULL);\n        } else {\n            Jsi_DSAppend(dStr, z, NULL);\n        }\n    }\n    if( bSep ) {\n        Jsi_DSAppend(dStr, p->separator, NULL);\n    }\n}\n\nstatic void mdbOutputHtmlString(QueryOpts *p, const char *z, Jsi_DString *dStr)\n{\n    while( *z ) {\n        switch (*z) {\n        case '<':\n            Jsi_DSAppend(dStr, \"&lt;\", NULL);\n            break;\n        case '>':\n            Jsi_DSAppend(dStr, \"&gt;\", NULL);\n            break;\n        case '&':\n            Jsi_DSAppend(dStr, \"&amp;\", NULL);\n            break;\n        case '\\\"':\n            Jsi_DSAppend(dStr, \"&quot;\", NULL);\n            break;\n        case '\\'':\n            Jsi_DSAppend(dStr, \"&#39;\", NULL);\n            break;\n        default:\n            Jsi_DSAppendLen(dStr, z, 1);\n            break;\n        }\n        z++;\n    }\n}\n/*\n** Output the given string as a quoted string using SQL quoting conventions.\n*/\nstatic void mdbOutputQuotedString(Jsi_DString *dStr, const char *z) {\n    int i;\n    int nSingle = 0;\n    for(i=0; z[i]; i++) {\n        if( z[i]=='\\'' ) nSingle++;\n    }\n    if( nSingle==0 ) {\n        Jsi_DSAppend(dStr,\"'\", z, \"'\", NULL);\n    } else {\n        Jsi_DSAppend(dStr,\"'\", NULL);\n        while( *z ) {\n            for(i=0; z[i] && z[i]!='\\''; i++) {}\n            if( i==0 ) {\n                Jsi_DSAppend(dStr,\"''\", NULL);\n                z++;\n            } else if( z[i]=='\\'' ) {\n                Jsi_DSAppendLen(dStr,z, i);\n                Jsi_DSAppend(dStr,\"''\", NULL);\n                z += i+1;\n            } else {\n                Jsi_DSAppend(dStr, z, NULL);\n                break;\n            }\n        }\n        Jsi_DSAppend(dStr,\"'\", NULL);\n    }\n}\n\nstatic Jsi_RC MySqlQueryCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                             Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_RC rc = JSI_OK;\n    MySqlObj *jdb;\n    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    Jsi_Value *vSql = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_DString eStr = {};\n    JSI_DSTRING_VAR(dStr, JSI_DB_DSTRING_SIZE);\n    const char *zSql = Jsi_ValueGetDString(interp, vSql, &eStr, 0);\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 1);\n    int cnt = 0;\n    char **apColName = NULL;\n    Jsi_OptionId *apColType = NULL;\n    int isopts = 0;\n    MyDbEvalContext sEval = {};\n    QueryOpts opts, *oEopt = NULL;\n    opts = jdb->queryOpts;\n    opts.callback = NULL;\n    opts.width = NULL;\n    Jsi_Value *callback = NULL, *width = NULL;\n            \n    if (arg) {\n        if (Jsi_ValueIsFunction(interp,arg))\n            callback = opts.callback = arg;\n        else if (Jsi_ValueIsString(interp, arg))\n            opts.objName = Jsi_ValueString(interp, arg, NULL);\n        else if (Jsi_ValueIsObjType(interp, arg, JSI_OT_ARRAY))\n            opts.values = arg;\n        else if (Jsi_ValueIsObjType(interp, arg, JSI_OT_OBJECT))\n            isopts = 1;\n        else  {\n            rc = Jsi_LogError(\"argument must be null, a function, string, array or options\");\n            goto bail;\n        }\n    }\n\n    if (isopts) {\n        if (Jsi_OptionsProcess(interp, QueryFmtOptions, &opts, arg, 0) < 0) {\n            rc = JSI_ERROR;\n            goto bail;\n        }\n        callback = (opts.callback ? opts.callback : jdb->queryOpts.callback);\n        width = (opts.width ? opts.width : jdb->queryOpts.width);\n    }\n/*    if (jdb->queryOpts.CData) {\n        char *cdata = (char*)jdb->queryOpts.CData;\n        MySqlObjMultipleBind* copts = Jsi_CarrayLookup(interp, cdata);\n        if (!copts) \n            return Jsi_LogError(\"unknown CData option: %s\", jdb->queryOpts.CData);\n        int n = MySqlObjQuery(jdb, copts->opts, copts->data, copts->numData, zSql, copts->flags);\n        Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)n);\n        return JSI_OK;\n    } */\n    if (opts.objName) {\n        if (Jsi_SqlObjBinds(interp, &eStr, opts.objName,  !(opts.objOpts&OBJMODE_NOTYPES), \n        !(opts.objOpts&OBJMODE_NODEFAULTS), (opts.objOpts&OBJMODE_NULLDEFAULTS)!=0) != JSI_OK)\n            goto bail;\n        zSql = Jsi_DSValue(&eStr);\n    }\n    if (!opts.separator) {\n        switch (opts.mode) {\n            case _mdb_EF_LIST: opts.separator = \"|\"; break;\n            case _mdb_EF_COLUMN: opts.separator = \" \"; break;\n            case _mdb_EF_TABS: opts.separator = \"\\t\"; break;\n            default: opts.separator = \",\";\n        }\n    }\n    Jsi_DString sStr;\n    Jsi_DSInit(&sStr);\n    sEval.nocache = opts.nocache;\n    if (mdbEvalInit(interp, &sEval, jdb, zSql, &sStr, 0, 0) != JSI_OK) {\n        rc = JSI_ERROR;\n        goto bail;\n    }\n    sEval.namedParams = (opts.noNamedParams==0 && !opts.values);\n    sEval.ret = *ret;\n    oEopt = jdb->optPtr;\n    jdb->optPtr = &opts;\n    \n    if (sEval.namedParams) {\n        rc = mdbEvalPrep(&sEval);\n        if (rc == JSI_ERROR)\n            goto bail;\n        if (rc == JSI_BREAK) {\n            rc = JSI_OK;\n            goto bail;\n        }\n    }\n    if (opts.mode == _mdb_EF_NONE)\n        goto bail;\n    if (callback) {\n        sEval.tocall = callback;\n        if (opts.mode != _mdb_EF_ROWS)\n            rc = Jsi_LogError(\"'mode' must be 'rows' with 'callback'\");\n        else \n            rc = mdbEvalCallCmd(&sEval, interp, JSI_OK);\n        goto bail;\n    }\n    switch (opts.mode) {\n        case _mdb_EF_NONE:\n            while(JSI_OK==(rc = mdbEvalStep(&sEval)) ) {\n                cnt++;\n                if (opts.limit && cnt>=opts.limit) break;\n            }\n            goto bail;\n            break;\n        case _mdb_EF_JSON:\n            if (opts.headers) {\n                Jsi_DSAppend(dStr, \"[ \", NULL);\n                while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {\n                    int i;\n                    int nCol;\n                    mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n                    if (cnt == 0) {\n                        Jsi_DSAppend(dStr, \"[\", NULL);\n                        for(i=0; i<nCol; i++) {\n                            if (i)\n                                Jsi_DSAppend(dStr, \", \", NULL);\n                            Jsi_JSONQuote(interp, apColName[i], -1, dStr);\n                        }\n                        Jsi_DSAppend(dStr, \"]\", NULL);\n                        cnt++;\n                    }\n                    if (cnt)\n                        Jsi_DSAppend(dStr, \", \", NULL);\n                    Jsi_DSAppend(dStr, \"[\", NULL);\n                    for(i=0; i<nCol; i++) {\n                        if (i)\n                            Jsi_DSAppend(dStr, \", \", NULL);\n                        mdbEvalSetColumnJSON(&sEval, i, dStr);\n                    }\n                    Jsi_DSAppend(dStr, \"]\", NULL);\n                    cnt++;\n                    if (opts.limit && cnt>opts.limit) break;\n                }\n                Jsi_DSAppend(dStr, \" ]\", NULL);\n                \n            } else {\n                Jsi_DSAppend(dStr, \"[ \", NULL);\n                while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {\n                    int i;\n                    int nCol;\n                    mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n                    if (cnt)\n                        Jsi_DSAppend(dStr, \", \", NULL);\n                    Jsi_DSAppend(dStr, \"{\", NULL);\n                    for(i=0; i<nCol; i++) {\n                        if (i)\n                            Jsi_DSAppend(dStr, \", \", NULL);\n                        Jsi_JSONQuote(interp, apColName[i], -1, dStr);\n                        Jsi_DSAppend(dStr, \":\", NULL);\n                        mdbEvalSetColumnJSON(&sEval, i, dStr);\n                    }\n                    Jsi_DSAppend(dStr, \"}\", NULL);\n                    cnt++;\n                    if (opts.limit && cnt>=opts.limit) break;\n                }\n                Jsi_DSAppend(dStr, \" ]\", NULL);\n            }\n            break;\n            \n        case _mdb_EF_JSON2: {\n                while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {\n                    int i;\n                    int nCol;\n                    mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n                    if (cnt == 0 && 1) {\n                        Jsi_DSAppend(dStr, \"{ \\\"names\\\": [ \", NULL);\n                        for(i=0; i<nCol; i++) {\n                            if (i)\n                                Jsi_DSAppend(dStr, \", \", NULL);\n                            Jsi_JSONQuote(interp, apColName[i], -1, dStr);\n                        }\n                        Jsi_DSAppend(dStr, \" ], \\\"values\\\": [ \", NULL);\n                    }\n                    if (cnt)\n                        Jsi_DSAppend(dStr, \", \", NULL);\n                    Jsi_DSAppend(dStr, \"[\", NULL);\n                    for(i=0; i<nCol; i++) {\n                        if (i)\n                            Jsi_DSAppend(dStr, \", \", NULL);\n                        mdbEvalSetColumnJSON(&sEval, i, dStr);\n                    }\n                    Jsi_DSAppend(dStr, \" ]\", NULL);\n                    cnt++;\n                    if (opts.limit && cnt>=opts.limit) break;\n                }\n                if (cnt)\n                    Jsi_DSAppend(dStr, \" ] } \", NULL);\n            }\n            break;\n            \n        case _mdb_EF_LIST:\n            while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {\n                int i;\n                int nCol;\n                mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n                if (cnt == 0 && opts.headers) {\n                    for(i=0; i<nCol; i++) {\n                        if (i)\n                            Jsi_DSAppend(dStr, opts.separator, NULL);\n                        Jsi_DSAppend(dStr, apColName[i], NULL);\n                    }\n                }\n    \n                if (cnt || opts.headers)\n                    Jsi_DSAppend(dStr, \"\\n\", NULL);\n                for(i=0; i<nCol; i++) {\n                    if (i)\n                        Jsi_DSAppend(dStr, opts.separator, NULL);\n                    mdbEvalSetColumn(&sEval, i, dStr);\n                }\n                cnt++;\n                if (opts.limit && cnt>=opts.limit) break;\n            }\n            break;\n            \n        case _mdb_EF_COLUMN: {\n            int *wids = NULL;\n            Jsi_DString vStr = {};\n            while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {\n                int i, w;\n                int nCol;\n                \n                mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n                if (cnt == 0 && nCol>0) {\n                    Jsi_DString sStr;\n                    wids = (int*)Jsi_Calloc(nCol, sizeof(int));\n                    Jsi_DSInit(&sStr);\n                    for(i=0; i<nCol; i++) {\n                        int j = Jsi_Strlen(apColName[i]);\n                        wids[i] = (j<10?10:j);\n                        if (width) {\n                            Jsi_Value *wv = Jsi_ValueArrayIndex(interp, width, i);\n                            if (wv) {\n                                Jsi_Number dv;\n                                Jsi_ValueGetNumber(interp, wv, &dv);\n                                if (dv>0)\n                                    wids[i] = (int)dv;\n                            }\n                        }\n                        w = (j<wids[i] ? j : wids[i]);\n                        Jsi_DSAppendLen(dStr, apColName[i], w);\n                        w = (j<wids[i] ? wids[i]-j+1 : 0);\n                        while (w-- > 0)\n                            Jsi_DSAppend(dStr, \" \", NULL);\n                    }\n                    for(i=0; i<nCol && opts.headers; i++) {\n                        w = wids[i];\n                        w -= Jsi_Strlen(apColName[i]);\n                        if (i) {\n                            Jsi_DSAppend(dStr, opts.separator, NULL);\n                            Jsi_DSAppend(&sStr, opts.separator, NULL);\n                        }\n                        w = wids[i];\n                        while (w-- > 0)\n                            Jsi_DSAppend(&sStr, \"-\", NULL);\n                    }\n                    if (opts.headers)\n                        Jsi_DSAppend(dStr, \"\\n\", Jsi_DSValue(&sStr), \"\\n\", NULL);\n                    Jsi_DSFree(&sStr);\n                }\n    \n                if (cnt)\n                    Jsi_DSAppend(dStr, \"\\n\", NULL);\n                for(i=0; i<nCol; i++) {\n                    if (i)\n                        Jsi_DSAppend(dStr, opts.separator, NULL);\n                    Jsi_DSSetLength(&vStr, 0);\n                    mdbEvalSetColumn(&sEval, i, &vStr);\n                    int nl = Jsi_DSLength(&vStr);\n                    if (nl > wids[i]) {\n                        Jsi_DSSetLength(&vStr, wids[i]);\n                        w = 0;\n                    } else {\n                        w = wids[i]-nl;\n                    }\n                    Jsi_DSAppend(dStr, Jsi_DSValue(&vStr), NULL);\n                    while (w-- > 0)\n                        Jsi_DSAppend(dStr, \" \", NULL);\n                }\n                cnt++;\n                if (opts.limit && cnt>=opts.limit) break;\n            }\n            Jsi_DSFree(&vStr);\n            if (wids)\n                Jsi_Free(wids);\n            break;\n        }\n        \n        case _mdb_EF_INSERT: {\n            Jsi_DString vStr = {};    \n            while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {\n                int i;\n                int nCol;\n                const char *tbl = (opts.table ? opts.table : \"table\");\n                if (cnt)\n                    Jsi_DSAppend(dStr, \"\\n\", NULL);\n                Jsi_DSAppend(dStr, \"INSERT INTO \", tbl, \" VALUES(\", NULL);\n                mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n                for(i=0; i<nCol; i++) {\n                    Jsi_Number dv;\n                    const char *azArg;\n                    Jsi_DSSetLength(&vStr, 0);\n                    mdbEvalSetColumn(&sEval, i, &vStr);\n                    \n                    MysqlPrep *prep = sEval.prep;\n                    Jsi_OptionId ptype = prep->fieldResult[i].jsiTypeMap;\n                    \n                    azArg = Jsi_DSValue(&vStr);\n                    const char *zSep = i>0 ? \",\": \"\";\n                    if (azArg[i]==0 && ptype != JSI_OPTION_STRING) {\n                      Jsi_DSAppend(dStr, zSep, \"NULL\", NULL);\n                    } else if( ptype ==JSI_OPTION_STRING) {\n                      if( zSep[0] ) Jsi_DSAppend(dStr,zSep, NULL);\n                      mdbOutputQuotedString(dStr, azArg);\n                    } else if (ptype==JSI_OPTION_BOOL || ptype ==JSI_OPTION_DOUBLE) {\n                      Jsi_DSAppend(dStr, zSep, azArg, NULL);\n                    } else if( Jsi_GetDouble(interp, azArg, &dv) == JSI_OK ) {\n                      Jsi_DSAppend(dStr, zSep, azArg, NULL);\n                    } else {\n                      if( zSep[0] ) Jsi_DSAppend(dStr,zSep, NULL);\n                      mdbOutputQuotedString(dStr, azArg);\n                    }\n                }\n                Jsi_DSAppend(dStr, \");\", NULL);\n                cnt++;\n                if (opts.limit && cnt>=opts.limit) break;\n            }\n            Jsi_DSFree(&vStr);\n        }\n    \n        case _mdb_EF_TABS:\n        case _mdb_EF_CSV: {\n            Jsi_DString vStr = {};  \n            while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {\n                int i;\n                int nCol;\n                mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n                if (cnt == 0 && opts.headers) {\n                    for(i=0; i<nCol; i++) {\n                        if (i)\n                            Jsi_DSAppend(dStr, opts.separator, NULL);\n                        Jsi_DSAppend(dStr, apColName[i], NULL);\n                    }\n                }\n    \n                if (cnt || opts.headers)\n                    Jsi_DSAppend(dStr, \"\\n\", NULL);\n                for(i=0; i<nCol; i++) {\n                    if (i)\n                        Jsi_DSAppend(dStr, opts.separator, NULL);\n                    Jsi_DSSetLength(&vStr, 0);\n                    mdbEvalSetColumn(&sEval, i, &vStr);\n                    if (opts.mode == _mdb_EF_CSV)\n                        mdbOutputCsv(&opts, Jsi_DSValue(&vStr), dStr, 0);\n                    else\n                        Jsi_DSAppend(dStr, Jsi_DSValue(&vStr), NULL);\n                }\n                cnt++;\n                if (opts.limit && cnt>=opts.limit) break;\n            }\n            Jsi_DSFree(&vStr);\n            break;\n        }\n            \n        case _mdb_EF_LINE: {\n            int i, w = 5, ww;\n            int nCol;\n            Jsi_DString vStr = {};   \n            while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {\n                mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n                if (cnt == 0) {\n                    for(i=0; i<nCol; i++) {\n                        ww = Jsi_Strlen(apColName[i]);\n                        if (ww>w)\n                            w = ww;\n                    }\n                }\n    \n                for(i=0; i<nCol; i++) {\n                    Jsi_DString eStr;\n                    Jsi_DSInit(&eStr);\n                    Jsi_DSSetLength(&vStr, 0);\n                    mdbEvalSetColumn(&sEval, i, &vStr);\n                    Jsi_DSPrintf(&eStr, \"%*s = %s\", w, apColName[i], Jsi_DSValue(&vStr));\n                    Jsi_DSAppend(dStr, (cnt?\"\\n\":\"\"), Jsi_DSValue(&eStr), NULL);\n                    Jsi_DSFree(&eStr);\n                }\n                cnt++;\n                if (opts.limit && cnt>=opts.limit) break;\n            }\n            Jsi_DSFree(&vStr);\n            break;\n        }\n            \n        case _mdb_EF_HTML: {\n            Jsi_DString vStr = {};   \n            while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {\n                int i;\n                int nCol;\n                mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n                if (cnt == 0 && opts.headers) {\n                    Jsi_DSAppend(dStr, \"<TR>\", NULL);\n                    for(i=0; i<nCol; i++) {\n                        Jsi_DSAppend(dStr, \"<TH>\", NULL);\n                        mdbOutputHtmlString(&opts, apColName[i], dStr);\n                        Jsi_DSAppend(dStr, \"</TH>\", NULL);\n                    }\n                    Jsi_DSAppend(dStr, \"</TR>\", NULL);\n                }\n                if (cnt || opts.headers)\n                    Jsi_DSAppend(dStr, \"\\n\", NULL);\n                Jsi_DSAppend(dStr, \"<TR>\", NULL);\n                for(i=0; i<nCol; i++) {\n                    Jsi_DSAppend(dStr, \"<TD>\", NULL);\n                    Jsi_DSSetLength(&vStr, 0);\n                    mdbEvalSetColumn(&sEval, i, &vStr);\n                    mdbOutputHtmlString(&opts, Jsi_DSValue(&vStr), dStr);\n                    Jsi_DSAppend(dStr, \"</TD>\", NULL);\n                }\n                Jsi_DSAppend(dStr, \"</TR>\", NULL);\n                cnt++;\n                if (opts.limit && cnt>=opts.limit) break;\n            }\n            Jsi_DSFree(&vStr);\n            break;\n        }\n            \n        case _mdb_EF_ROWS:\n        {\n            Jsi_Value *vcur, *vrow;\n            int cnt = 0;\n            Jsi_Obj *oall, *ocur;\n            Jsi_ValueMakeArrayObject(interp, ret, oall = Jsi_ObjNewType(interp, JSI_OT_ARRAY));\n    \n            while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {\n                int i;\n                int nCol;\n                mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n                ocur = Jsi_ObjNewType(interp, JSI_OT_OBJECT);\n                vrow = Jsi_ValueMakeObject(interp, NULL, ocur);\n                for(i=0; i<nCol; i++) {\n                    vcur = mdbEvalSetColumnValue(&sEval, i, NULL);\n                    Jsi_ObjInsert(interp, ocur, apColName[i], vcur, 0);\n                }\n                Jsi_ObjArrayAdd(interp, oall, vrow);\n                cnt++;\n                if (opts.limit && cnt>=opts.limit) break;\n            }\n            mdbEvalFinalize(&sEval);\n            if (rc != JSI_ERROR)\n                rc = JSI_OK;\n            goto bail;\n            break;\n        }\n        case _mdb_EF_ARRAYS:\n        {\n            Jsi_Value *vcur, *vrow;\n            int cnt = 0;\n            Jsi_Obj *oall, *ocur;\n            Jsi_ValueMakeArrayObject(interp, ret, oall = Jsi_ObjNewType(interp, JSI_OT_ARRAY));\n    \n            while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {\n                int i;\n                int nCol;\n                mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n                if (cnt == 0 && opts.headers) {\n                    vrow = Jsi_ValueMakeArrayObject(interp, NULL, ocur = Jsi_ObjNewType(interp, JSI_OT_ARRAY));\n                    for(i=0; i<nCol; i++) {\n                        vcur = Jsi_ValueNewStringDup(interp, apColName[i]);\n                        Jsi_ObjArrayAdd(interp, ocur, vcur);\n                    }\n                    Jsi_ObjArrayAdd(interp, oall, vrow);\n                }\n                vrow = Jsi_ValueMakeArrayObject(interp, NULL, ocur = Jsi_ObjNewType(interp, JSI_OT_ARRAY));\n                for(i=0; i<nCol; i++) {\n                    vcur = mdbEvalSetColumnValue(&sEval, i, NULL);\n                    Jsi_ObjArrayAdd(interp, ocur, vcur);\n                }\n                Jsi_ObjArrayAdd(interp, oall, vrow);\n                cnt++;\n                if (opts.limit && cnt>=opts.limit) break;\n            }\n            mdbEvalFinalize(&sEval);\n            if (rc != JSI_ERROR)\n                rc = JSI_OK;\n            goto bail;\n            break;\n        }\n        case _mdb_EF_ARRAY1D:\n        {\n            Jsi_Value *vcur;\n            int cnt = 0;\n            Jsi_Obj *oall;\n            Jsi_ValueMakeArrayObject(interp, ret, oall = Jsi_ObjNewType(interp, JSI_OT_ARRAY));\n    \n            while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {\n                int i;\n                int nCol;\n                mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n                if (cnt == 0 && opts.headers) {\n                    for(i=0; i<nCol; i++) {\n                        vcur = Jsi_ValueNewStringDup(interp, apColName[i]);\n                        Jsi_ObjArrayAdd(interp, oall, vcur);\n                    }\n                }\n                for(i=0; i<nCol; i++) {\n                    vcur = mdbEvalSetColumnValue(&sEval, i, NULL);\n                    Jsi_ObjArrayAdd(interp, oall, vcur);\n                }\n                cnt++;\n                if (opts.limit && cnt>=opts.limit) break;\n            }\n            mdbEvalFinalize(&sEval);\n            if (rc != JSI_ERROR)\n                rc = JSI_OK;\n            goto bail;\n            break;\n        }\n    }\n    if( rc==JSI_BREAK ) {\n        rc = JSI_OK;\n    }\n    Jsi_ValueMakeStringDup(interp, ret, Jsi_DSValue(dStr));\nbail:\n    mdbEvalFinalize(&sEval);\n    if (isopts) {\n        Jsi_OptionsFree(interp, QueryFmtOptions, &opts, 0);\n    }\n    Jsi_DSFree(dStr);\n    Jsi_DSFree(&eStr);\n    jdb->optPtr = oEopt;\n\n    return rc;\n}\n\nstatic Jsi_RC MySqlOnecolumnCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                          Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_RC rc;\n    MySqlObj *jdb;\n    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    Jsi_Value *vSql = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    Jsi_DString sStr;\n    Jsi_DSInit(&sStr);\n    MyDbEvalContext sEval = {};\n    const char *zSql = Jsi_ValueGetDString(interp, vSql, &dStr, 0);\n\n    sEval.nocache = jdb->queryOpts.nocache;\n    if (mdbEvalInit(interp, &sEval, jdb, zSql, &sStr, 0, 0) != JSI_OK)\n        return JSI_ERROR;\n    sEval.ret = *ret;\n    sEval.tocall = NULL;\n    int cnt = 0;\n\n\n    if( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {\n        int nCol = sEval.prep->numCol;\n        if (nCol>0)\n            mdbEvalSetColumnValue(&sEval, 0, ret);\n        cnt++;\n    }\n    mdbEvalFinalize(&sEval);\n    if( rc==JSI_BREAK ) {\n        rc = JSI_OK;\n    }\n    Jsi_DSFree(&dStr);\n    return rc;\n}\n\nstatic Jsi_RC MySqlExistsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                           Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_RC rc;\n    MySqlObj *jdb;\n    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    Jsi_Value *vSql = Jsi_ValueArrayIndex(interp, args, 0);\n    const char *zSql;\n    Jsi_DString dStr = {};\n    MyDbEvalContext sEval = {};\n    zSql = Jsi_ValueGetDString(interp, vSql, &dStr, 0);\n\n    Jsi_DString sStr;\n    Jsi_DSInit(&sStr);\n    sEval.nocache = jdb->queryOpts.nocache;\n    if (mdbEvalInit(interp, &sEval, jdb, zSql, &sStr, 0, 0) != JSI_OK)\n        return JSI_ERROR;\n    sEval.ret = *ret;\n    int cnt = 0;\n\n\n    if( JSI_OK==(rc = mdbEvalStep(&sEval)) ) {\n        int nCol = sEval.prep->numCol;\n        if (nCol>0)\n            cnt++;\n    }\n    mdbEvalFinalize(&sEval);\n    if( rc==JSI_BREAK ) {\n        rc = JSI_OK;\n    }\n    Jsi_DSFree(&dStr);\n    Jsi_ValueMakeBool(interp, ret, cnt);\n    return rc;\n}\n\nstatic Jsi_RC MySqlLastRowidCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                                    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Wide rowid;\n    MySqlObj *jdb;\n    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    rowid = mdbLastInsertRowid(jdb);\n    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)rowid);\n    return JSI_OK;\n}\n\n/*\nstatic Jsi_RC MySqlInterruptCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                              Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    MySqlObj *jdb;\n    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    _SQL_LITE_N_(_interrupt)(jdb->db);\n    return JSI_OK;\n} */\n\n\nstatic Jsi_RC MySqlCompleteCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                             Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    MySqlObj *jdb;\n    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    Jsi_Value *s = Jsi_ValueArrayIndex(interp, args, 0);\n    const char *str =  Jsi_ValueString(interp, s, NULL);\n    int isComplete = 0;\n    if (str)\n        isComplete = 0; // sqlite3_complete( str );\n    Jsi_ValueMakeBool(interp, ret, isComplete);\n    return JSI_OK;\n}\n\nstatic Jsi_RC MySqlErrorNoCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                              Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    MySqlObj *jdb;\n    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    int n = mysql_errno(jdb->db);\n    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)n);\n    return JSI_OK;\n}\n\nstatic Jsi_RC MySqlErrorStateCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                              Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    MySqlObj *jdb;\n    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    const char *str = mysql_sqlstate(jdb->db);\n    if (str)\n        Jsi_ValueMakeStringDup(interp, ret, str);\n    return JSI_OK;\n}\n\nstatic Jsi_RC MySqlLastQueryCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                              Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    MySqlObj *jdb;\n    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    const char *str = mysql_info(jdb->db);\n    if (str)\n        Jsi_ValueMakeStringDup(interp, ret, str);\n    return JSI_OK;\n}\n\nstatic Jsi_RC MySqlResetCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                              Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    MySqlObj *jdb;\n    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n#if (MYSQL_VERSION_ID >= 50703 && !defined(JSI_NO_MYSQL_RESET))\n    int oldMax = jdb->maxStmts;\n    jdb->maxStmts = 0;\n    mdbStmtLimit(jdb);\n    jdb->maxStmts = oldMax;\n    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)mysql_reset_connection(jdb->db));\n#else\n    Jsi_LogWarn(\"mysql reset unavailable: requires version 5.7.3+\");\n#endif\n    return JSI_OK;    \n}\n\n\nstatic Jsi_RC MySqlPingCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                              Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    MySqlObj *jdb;\n    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    int n = mysql_ping(jdb->db);\n    bool noErr = 0;\n    Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 0);\n    if (val)\n        Jsi_ValueGetBoolean(interp, val, &noErr);\n    if (n && noErr==0) \n        return Jsi_LogError(\"ping failed: (%d) %s\", n, mysql_error(jdb->db));\n    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)n);\n\n    return JSI_OK;    \n}\n\nstatic Jsi_RC MySqlAffectedRowsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                              Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    MySqlObj *jdb;\n    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)mysql_affected_rows(jdb->db));\n    return JSI_OK;\n}\nstatic Jsi_RC MySqlInfoCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                              Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    MySqlObj *jdb;\n    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    Jsi_Obj *nobj = Jsi_ObjNew(interp);\n    Jsi_ValueMakeObject(interp, ret, nobj);\n    const char *str, *svals[20];\n    int i = 0;\n    svals[i++] = \"clientInfo\";\n    svals[i++] = mysql_get_client_info();\n    svals[i++] = \"hostInfo\";\n    svals[i++] = mysql_get_host_info(jdb->db);\n    svals[i++] = \"serverInfo\";\n    svals[i++] = mysql_get_server_info(jdb->db);\n    svals[i++] = \"stat\";\n    svals[i++] = mysql_stat(jdb->db);\n    svals[i++] = 0;\n    i = 0;\n    while (svals[i]) {\n        str = svals[i+1];\n        Jsi_ObjInsert(interp, nobj, svals[i], str?Jsi_ValueNewStringDup(interp, str):Jsi_ValueNewNull(interp), 0);\n    }\n    Jsi_ObjInsert(interp, nobj, \"threadId\", Jsi_ValueNewNumber(interp, (Jsi_Number)mysql_thread_id(jdb->db)), 0);\n    Jsi_ObjInsert(interp, nobj, \"protocolVersion\", Jsi_ValueNewNumber(interp, (Jsi_Number)mysql_get_proto_info(jdb->db)), 0);\n    Jsi_ObjInsert(interp, nobj, \"clientVersion\", Jsi_ValueNewNumber(interp, (Jsi_Number)mysql_get_client_version()), 0);\n    Jsi_ObjInsert(interp, nobj, \"serverVersion\", Jsi_ValueNewNumber(interp, (Jsi_Number)mysql_get_server_version(jdb->db)), 0);\n    Jsi_ObjInsert(interp, nobj, \"warningCount\", Jsi_ValueNewNumber(interp, (Jsi_Number)mysql_warning_count(jdb->db)), 0);\n    return JSI_OK;\n}\n\nstatic Jsi_RC MySqlConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                         Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    MySqlObj *jdb;\n    if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    int oms = jdb->maxStmts;\n    const char *oldu = jdb->user, *oldpw = jdb->password, *olddb = jdb->database;\n    Jsi_RC rc = Jsi_OptionsConf(interp, SqlOptions, jdb, Jsi_ValueArrayIndex(interp, args, 0), ret, 0);\n    if (jdb->maxStmts<0 || jdb->maxStmts>MAX_PREPARED_STMTS) {\n        JSI_DBQUERY_PRINTF( \"option maxStmts value %d is not in range 0..%d\", jdb->maxStmts, MAX_PREPARED_STMTS);\n        jdb->maxStmts = oms;\n        rc = JSI_ERROR;\n    }\n    if (oldu != jdb->user || oldpw != jdb->password || olddb != jdb->database)\n        if (!mysql_change_user(jdb->db, jdb->user, jdb->password, jdb->database)) {\n            rc = JSI_ERROR;\n            jdb->user = oldu;\n            jdb->password = oldpw;\n            jdb->database = olddb;\n        }\n    mdbStmtLimit(jdb);\n    return rc;\n}\n\nstatic Jsi_CmdSpec mysqlCmds[] = {\n    { \"MySql\",          MySqlConstructor,    0,  1,  \"options:object=void\",  \n        .help=\"Create a new db connection to a MySql database:\", .retType=(uint)JSI_TT_USEROBJ, .flags=JSI_CMD_IS_CONSTRUCTOR, .info=0, .opts=SqlOptions },\n    { \"affectedRows\",   MySqlAffectedRowsCmd,0, 0, \"\", .help=\"Return affected rows\", .retType=(uint)JSI_TT_NUMBER },\n    { \"complete\",       MySqlCompleteCmd,   1,  1, \"sql:string\", .help=\"Return true if sql is complete\", .retType=(uint)JSI_TT_BOOLEAN },\n    { \"conf\",           MySqlConfCmd,       0,  1, \"options:string|object=void\", .help=\"Configure options\", .retType=(uint)JSI_TT_ANY, .flags=0, .info=0, .opts=SqlOptions },\n    { \"errorNo\",        MySqlErrorNoCmd,    0,  0, \"\", .help = \"Return error code returned by most recent call to mysql3_exec()\", .retType=(uint)JSI_TT_NUMBER },\n    { \"errorState\",     MySqlErrorStateCmd, 0,  0, \"\", .help = \"Return the mysql error state str\" , .retType=(uint)JSI_TT_STRING},\n    { \"eval\",           MySqlEvalCmd,       1,  1, \"sql:string\", .help=\"Run sql commands without input/output\", .retType=(uint)JSI_TT_NUMBER },\n    { \"exists\",         MySqlExistsCmd,     1,  1, \"sql:string\", .help=\"Execute sql, and return true if there is at least one result value\", .retType=(uint)JSI_TT_BOOLEAN },\n    { \"info\",           MySqlInfoCmd,       0,  0, \"\", .help=\"Return info about last query\", .retType=(uint)JSI_TT_OBJECT },\n    { \"lastQuery\",      MySqlLastQueryCmd,  0,  0, \"\", .help=\"Return info string about most recently executed statement\", .retType=(uint)JSI_TT_STRING },\n    { \"lastRowid\",      MySqlLastRowidCmd,  0,  0, \"\", .help=\"Return rowid of last insert\", .retType=(uint)JSI_TT_NUMBER },\n    { \"onecolumn\",      MySqlOnecolumnCmd,  1,  1, \"sql:string\", .help=\"Execute sql, and return a single value\", .retType=(uint)JSI_TT_ANY },\n    { \"ping\",           MySqlPingCmd,       0,  1, \"noError:boolean=false\", .help=\"Ping connection\", .retType=(uint)JSI_TT_NUMBER },\n    { \"query\",          MySqlQueryCmd,      1,  2, \"sql:string, options:function|string|array|object=void\", .help=\"Run sql query with input and/or outputs.\", .retType=(uint)JSI_TT_ANY, .flags=0, .info=0, .opts=QueryFmtOptions },\n    { \"reconnect\",      MySqlReconnectCmd,  0,  0, \"\", .help=\"Reconnect with current settings\", .retType=(uint)JSI_TT_VOID },\n    { \"reset\",          MySqlResetCmd,      0,  0, \"\", .help=\"Reset connection\", .retType=(uint)JSI_TT_NUMBER },\n    { NULL, 0,0,0,0, .help=\"Commands for accessing mysql databases\" }\n};\n\n    \nstatic Jsi_RC mysqlObjFree(Jsi_Interp *interp, void *data);\nstatic bool  mysqlObjEqual(void *data1, void *data2);\nstatic bool  mysqlObjIsTrue(void *data);\n\nstatic Jsi_UserObjReg mysqlobject = {\n    .name   = \"MySql\",\n    .spec   = mysqlCmds,\n    .freefun= mysqlObjFree,\n    .istrue = mysqlObjIsTrue,\n    .isequ  = mysqlObjEqual\n};\n\nstatic Jsi_RC MySqlConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    MySqlObj *jdb;\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_LogTest(\"Creating new MySql\");\n        \n    jdb = (MySqlObj*)Jsi_Calloc(1, sizeof(*jdb));\n    SQLSIGINIT(jdb, DB);\n    const char *groupname = \"mysqljsi\";\n    jdb->_ = &mydbObjCmd;\n    jdb->_->newCnt++;\n    jdb->_->activeCnt++;\n\n    jdb->maxStmts = NUM_PREPARED_STMTS;\n    jdb->forceInt = 1;\n    jdb->interp = interp;\n    jdb->hasOpts = (arg != NULL && !Jsi_ValueIsNull(interp,arg));\n    if (jdb->hasOpts && Jsi_OptionsProcess(interp, SqlOptions, jdb, arg, 0) < 0) {\n        jdb->deleted = 1;\n        mysqlObjFree(interp, jdb);\n        return JSI_ERROR;\n    }\n    if (!jdb->udata) {\n        jdb->udata = Jsi_ValueNewObj(interp, NULL);\n        Jsi_IncrRefCount(interp, jdb->udata);\n    }\n    jdb->db = mysql_init(NULL);\n    jdb->version = (MYSQL_VERSION_MAJOR + ((Jsi_Number)MYSQL_VERSION_MINOR/100.0) + ((Jsi_Number)MYSQL_VERSION_PATCH/10000.0));\n\n#if (MYSQL_VERSION_ID>=32350)\n    if (jdb->reconnect)\n    {\n      my_bool reconnect = 1;\n      mysql_options(jdb->db, MYSQL_OPT_RECONNECT, &reconnect);\n    }\n    mysql_options(jdb->db, MYSQL_READ_DEFAULT_GROUP, groupname);\n#endif\n\n#if (MYSQL_VERSION_ID >= 40107)\n    if (jdb->sslKey) {\n        const char *sslcert = Jsi_ValueString(interp, jdb->sslCert, NULL),\n            *sslca = Jsi_ValueString(interp, jdb->sslCA, NULL),\n            *sslcapath = Jsi_ValueString(interp, jdb->sslCAPath, NULL),\n            *sslcipher = Jsi_ValueString(interp, jdb->sslCipher, NULL),\n            *sslkey = Jsi_ValueString(interp, jdb->sslKey, NULL);\n        mysql_ssl_set(jdb->db, sslkey, sslcert, sslca, sslcapath, sslcipher);\n        jdb->dbflags |= CLIENT_SSL;\n    }\n#endif\n\n    if (!mdbConnect(interp, jdb)) {\n        Jsi_LogError(\"connect failed %s\", mysql_error(jdb->db));\n        mysqlObjFree(interp, jdb);\n        return JSI_ERROR;\n    }\n\n    if (jdb->enableMulti) {\n        if (mysql_set_server_option(jdb->db, MYSQL_OPTION_MULTI_STATEMENTS_ON))\n            Jsi_LogWarn(\"multi on failed %s\", mysql_error(jdb->db));\n    }\n    //jdb->event = Jsi_EventNew(interp, mysqlUpdate, jdb); //TODO: events\n    Jsi_Value *toacc = NULL;\n    if (Jsi_FunctionIsConstructor(funcPtr)) {\n        toacc = _this;\n    } else {\n        Jsi_Obj *o = Jsi_ObjNew(interp);\n        Jsi_PrototypeObjSet(interp, \"MySql\", o);\n        Jsi_ValueMakeObject(interp, ret, o);\n        toacc = *ret;\n    }\n\n    Jsi_Obj *fobj = Jsi_ValueGetObj(interp, toacc);\n    if ((jdb->objId = Jsi_UserObjNew(interp, &mysqlobject, fobj, jdb))<0) {\n        mysqlObjFree(interp, jdb);\n        Jsi_ValueMakeUndef(interp, ret);\n        return JSI_ERROR;\n    }\n    jdb->stmtHash = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);\n    jdb->userObjPtr = fobj;\n    jdb->optPtr = &jdb->queryOpts;\n    jdb->stmtCache = Jsi_ListNew((Jsi_Interp*)jdb, 0, mdbStmtFreeProc);\n    return JSI_OK;\n}\n\n\nstatic Jsi_RC Jsi_DoneMySql(Jsi_Interp *interp)\n{\n    if (Jsi_UserObjUnregister(interp, &mysqlobject) != JSI_OK)\n        return JSI_ERROR;\n    Jsi_PkgProvide(interp, \"MySql\", -1, NULL);\n    return JSI_OK;\n}\n\nJsi_RC Jsi_InitMySql(Jsi_Interp *interp, int release)\n{\n    if (release) {\n        if (!--mydbObjCmd.init)\n            mysql_library_end();\n        return Jsi_DoneMySql(interp);\n    }\n    Jsi_Hash* dbSys;\n#if JSI_USE_STUBS\n  if (Jsi_StubsInit(interp, 0) != JSI_OK)\n    return JSI_ERROR;\n#endif\n#ifndef JSI_OMIT_THREADS\n    if (mydbObjCmd.init == 0 && mysql_library_init(0, NULL, NULL))\n        return Jsi_LogError(\"failed to initialize MySQL library\\n\");\n#else\n    return Jsi_LogError(\"Threads required for mysql\");\n#endif\n\n    Jsi_Value *info = Jsi_ValueNew1(interp);\n    Jsi_JSONParseFmt(interp, &info, \"{pkgVer:%d}\", MYSQL_VERSION_ID);\n    Jsi_PkgOpts dbPkgOpts = { mydb_ObjCmd_Specs, &mydbObjCmd, mysqlCmds, info};\n    Jsi_RC rc = Jsi_PkgProvideEx(interp, \"MySql\", 1.1, Jsi_InitMySql, &dbPkgOpts);\n    Jsi_DecrRefCount(interp, info);\n    if (rc != JSI_OK)\n        rc = JSI_ERROR;\n    else if (!(dbSys = Jsi_UserObjRegister(interp, &mysqlobject))) \n        rc = Jsi_LogError(\"Failed to init mysql extension\");\n    else if (!Jsi_CommandCreateSpecs(interp, mysqlobject.name, mysqlCmds, dbSys, JSI_CMDSPEC_ISOBJ))\n        rc = JSI_ERROR;\n    if (rc == JSI_OK)\n        mydbObjCmd.init++;\n    else\n        mysql_library_end();\n    return rc;\n}\n\n#endif\n", "#include <math.h>\n#ifndef JSI_AMALGAMATION\n#include \"jsiInt.h\"\n#endif\n\nbool Jsi_NumberIsSubnormal(Jsi_Number a) { return fpclassify(a) == FP_SUBNORMAL; }\n\nbool Jsi_NumberIsNormal(Jsi_Number a) { return (fpclassify(a) == FP_ZERO || isnormal(a)); }\n\nbool Jsi_NumberIsNaN(Jsi_Number n)\n{\n    return isnan(n);\n}\n\nint Jsi_NumberIsInfinity(Jsi_Number a) {\n#if JSI__MUSL==1 || defined(__FreeBSD__) || defined(__WIN32)\n    if (!isinf(a))\n        return 0;\n    return (a<0 ? -1 : 1);\n#else\n    return isinf(a);\n#endif\n}\nbool Jsi_NumberIsInteger(Jsi_Number n) { return (isnormal(n) ? (Jsi_Number)((Jsi_Wide)(n)) == (n) : n==0.0); }\n\nbool Jsi_NumberIsSafeInteger(Jsi_Number n) {\n    Jsi_Number n1 = fabsl(n),\n    n2 = 9007199254740991LL;\n    return (Jsi_NumberIsInteger(n) && n1<=n2);\n}\n\nbool Jsi_NumberIsWide(Jsi_Number n) { return (isnormal(n) && (Jsi_Number)((Jsi_Wide)(n)) == (n)); }\n\nJsi_Number Jsi_NumberInfinity(int i)\n{\n    Jsi_Number r = INFINITY;\n    if (i < 0) r = -r;\n    return r;\n}\n\nJsi_Number Jsi_NumberNaN(void)\n{\n    return NAN;\n}\n\nvoid Jsi_NumberItoA10(Jsi_Wide value, char* buf, int bsiz)\n{\n    snprintf(buf, bsiz, \"%\" PRId64, value);\n}\n\nvoid Jsi_NumberUtoA10(Jsi_UWide value, char* buf, int bsiz)\n{\n    snprintf(buf, bsiz, \"%\" PRIu64, value);\n}\n\nbool Jsi_NumberIsFinite(Jsi_Number value)\n{\n    Jsi_Number r = INFINITY;\n    return (Jsi_NumberIsNaN(value)==0 && value != r && r != -value);\n}\n\nvoid Jsi_NumberDtoA(Jsi_Interp *interp, Jsi_Number value, char* buf, int bsiz, int prec)\n{\n    int dp = interp->subOpts.dblPrec-1, dm = __DBL_DECIMAL_DIG__;\n    if (prec==0)\n        prec = (dp<=0?dm+dp:dp);\n    else if (prec<0)\n            prec = dm+prec;\n    if (prec<=0)\n        prec = dm-1;\n    if (Jsi_NumberIsNaN(value))\n        Jsi_Strcpy(buf,\"NaN\");\n    else\n        snprintf(buf, bsiz, \"%.*\" JSI_NUMGFMT, prec, value);\n}\n\nbool Jsi_NumberIsEqual(Jsi_Number n1, Jsi_Number n2)\n{\n    return (n1 == n2); // TODO: Do we need more than this?\n}\n\n#ifndef JSI_LITE_ONLY\nstatic Jsi_RC NumberConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (Jsi_FunctionIsConstructor(funcPtr)) {\n        Jsi_Number nv = 0.0;\n        Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n        if (v) {\n            Jsi_ValueToNumber(interp, v);\n            nv = v->d.num;\n        }\n        _this->d.obj->ot = JSI_OT_NUMBER;\n        _this->d.obj->d.num = nv;\n        Jsi_ValueToObject(interp, _this);\n        Jsi_ValueMakeNumber(interp, ret, nv);\n        return JSI_OK;\n    }\n    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n    if (v) {\n        Jsi_ValueToNumber(interp, v);\n        Jsi_ValueDup2(interp, ret, v);\n        Jsi_ValueToObject(interp, *ret);\n        return JSI_OK;\n    }\n    Jsi_ValueMakeNumber(interp, ret, 0.0);\n    return JSI_OK;\n}\n\n   \n#define ChkStringN(_this, funcPtr, dest) \\\n    if (_this->vt == JSI_VT_OBJECT && _this->d.obj->ot == JSI_OT_FUNCTION &&  \\\n       _this->d.obj->__proto__ == interp->Number_prototype->d.obj->__proto__ ) { \\\n        skip = 1; \\\n        dest = Jsi_ValueArrayIndex(interp, args, 0); \\\n    } else if (_this->vt != JSI_VT_OBJECT || _this->d.obj->ot != JSI_OT_NUMBER) { \\\n        Jsi_LogError(\"apply Number.%s to a non-number object\", funcPtr->cmdSpec->name); \\\n        return JSI_ERROR; \\\n    } else  { \\\n        dest = _this; \\\n    }\n    \nstatic Jsi_RC NumberToFixedCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[JSI_MAX_NUMBER_STRING+1];\n    int prec = 0, skip = 0;\n    Jsi_Number num;\n    Jsi_Value *v;\n    ChkStringN(_this, funcPtr, v);\n    Jsi_Value *pa = Jsi_ValueArrayIndex(interp, args, skip);\n    if (pa && Jsi_GetIntFromValue(interp, pa, &prec) != JSI_OK)\n        return JSI_ERROR;\n    if (prec<0) prec = 0;\n    Jsi_GetDoubleFromValue(interp, v, &num);\n    snprintf(buf, sizeof(buf), \"%.*\" JSI_NUMFFMT, prec, num);\n    Jsi_ValueMakeStringDup(interp, ret, buf);\n    return JSI_OK;\n}\n\nstatic Jsi_RC NumberToPrecisionCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[JSI_MAX_NUMBER_STRING*2];\n    int prec = 0, skip = 0;\n    Jsi_Number num;\n    Jsi_Value *v;\n    ChkStringN(_this, funcPtr, v);\n    if (Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, skip), &prec) != JSI_OK)\n        return JSI_ERROR;\n    if (prec<=0 || prec>JSI_MAX_NUMBER_STRING) return Jsi_LogError(\"precision must be between 1 and %d\", JSI_MAX_NUMBER_STRING);\n    Jsi_GetDoubleFromValue(interp, v, &num);\n    snprintf(buf, sizeof(buf),\"%.*\" JSI_NUMFFMT, prec, num);\n    if (num<0)\n        prec++;\n    buf[prec+1] = 0;\n    if (buf[prec] == '.')\n        buf[prec] = 0;\n    Jsi_ValueMakeStringDup(interp, ret, buf);\n    return JSI_OK;\n}\n\nstatic Jsi_RC NumberToExponentialCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[JSI_MAX_NUMBER_STRING+1];\n    int prec = 0, skip = 0;\n    Jsi_Number num;\n    Jsi_Value *v;\n    ChkStringN(_this, funcPtr, v);\n    if (Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, skip), &prec) != JSI_OK)\n        return JSI_ERROR;\n    if (prec<0) prec = 0;\n    Jsi_GetDoubleFromValue(interp, v, &num);\n    snprintf(buf, sizeof(buf), \"%.*\" JSI_NUMEFMT, prec, num);\n#ifdef __WIN32\n    char *e = strrchr(buf, 'e');\n    if (e && (e[1]=='+' || e[1]=='-')) {\n        e++;\n        int eNum = atoi(e);\n        if (e[0]=='-')\n            eNum = -eNum;\n        e++;\n        snprintf(e, (e-buf), \"%02d\", eNum);\n    }\n#endif\n    Jsi_ValueMakeStringDup(interp, ret, buf);\n    return JSI_OK;\n}\n\nstatic Jsi_RC NumberToStringCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[JSI_MAX_NUMBER_STRING+1];\n    int radix = 10, skip = 0, argc = Jsi_ValueGetLength(interp, args);\n    Jsi_Number num;\n    Jsi_Value *v;\n    ChkStringN(_this, funcPtr, v);\n    Jsi_GetDoubleFromValue(interp, v, &num);\n    if (argc>skip && (Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, skip), &radix) != JSI_OK\n        || radix<2))\n        return JSI_ERROR;\n    if (argc==skip)\n        return jsi_ObjectToStringCmd(interp, args, _this, ret, funcPtr);\n    switch (radix) {\n        case 16: snprintf(buf, sizeof(buf), \"%\" PRIx64, (Jsi_Wide)num); break;\n        case 8: snprintf(buf, sizeof(buf), \"%\" PRIo64, (Jsi_Wide)num); break;\n        case 10: snprintf(buf, sizeof(buf), \"%\" PRId64, (Jsi_Wide)num); break;\n        default: return jsi_ObjectToStringCmd(interp, args, _this, ret, funcPtr);\n    }\n    Jsi_ValueMakeStringDup(interp, ret, buf);\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_NumberIsFiniteCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr, int op)\n{\n    Jsi_Number num;\n    Jsi_Value *v;\n    bool b = 0;\n    int skip = 0;\n    ChkStringN(_this, funcPtr, v);\n    if (Jsi_GetNumberFromValue(interp, v, &num) != JSI_OK)\n        return JSI_ERROR;\n    switch (op) {\n        case 1: b = Jsi_NumberIsFinite(num); break;\n        case 2: b = Jsi_NumberIsInteger(num); break;\n        case 3: b = Jsi_NumberIsNaN(num); break;\n        case 4: b = Jsi_NumberIsSafeInteger(num); break;\n    }\n    Jsi_ValueMakeBool(interp, ret, b);\n    skip++;\n    return JSI_OK;\n}\n\nstatic Jsi_RC NumberIsFiniteCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr) {\n    return jsi_NumberIsFiniteCmd(interp, args, _this, ret, funcPtr, 1);\n}\nstatic Jsi_RC NumberIsIntegerCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr) {\n    return jsi_NumberIsFiniteCmd(interp, args, _this, ret, funcPtr, 2);\n}\nstatic Jsi_RC NumberIsNaNCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr) {\n    return jsi_NumberIsFiniteCmd(interp, args, _this, ret, funcPtr, 3);\n}\nstatic Jsi_RC NumberIsSafeIntegerCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr) {\n    return jsi_NumberIsFiniteCmd(interp, args, _this, ret, funcPtr, 4);\n}\nstatic Jsi_CmdSpec numberCmds[] = {\n    { \"Number\",         NumberConstructor,      0, 1, \"num:string=0\", .help=\"Number constructor\", .retType=(uint)JSI_TT_NUMBER, .flags=JSI_CMD_IS_CONSTRUCTOR },\n    { \"isFinite\",       NumberIsFiniteCmd,      0, 0, \"\", .help=\"Return true if is finite\", .retType=(uint)JSI_TT_BOOLEAN },\n    { \"isInteger\",      NumberIsIntegerCmd,     0, 0, \"\", .help=\"Return true if is an integer\", .retType=(uint)JSI_TT_BOOLEAN },\n    { \"isNaN\",          NumberIsNaNCmd,         0, 0, \"\", .help=\"Return true if is NaN\", .retType=(uint)JSI_TT_BOOLEAN },\n    { \"isSafeInteger\",  NumberIsSafeIntegerCmd, 0, 0, \"\", .help=\"Return true if is a safe integer\", .retType=(uint)JSI_TT_BOOLEAN },\n    { \"toFixed\",        NumberToFixedCmd,       0, 1, \"num:number=0\", .help=\"Formats a number with x numbers of digits after the decimal point\", .retType=(uint)JSI_TT_STRING },\n    { \"toExponential\",  NumberToExponentialCmd, 1, 1, \"num:number\", .help=\"Converts a number into an exponential notation\", .retType=(uint)JSI_TT_STRING },\n    { \"toPrecision\",    NumberToPrecisionCmd,   1, 1, \"num:number\", .help=\"Formats a number to x length\", .retType=(uint)JSI_TT_STRING },\n    { \"toString\",       NumberToStringCmd,      0, 1, \"radix:number=10\", .help=\"Convert to string\", .retType=(uint)JSI_TT_STRING }, \n    { NULL, 0,0,0,0, .help=\"Commands for accessing number objects\" }\n};\n\nJsi_RC jsi_InitNumber(Jsi_Interp *interp, int release)\n{\n    if (release) return JSI_OK;\n    Jsi_Value *val, *global = interp->csc;\n    val = interp->Number_prototype = Jsi_CommandCreateSpecs(interp, \"Number\", numberCmds, NULL, JSI_CMDSPEC_ISOBJ);\n\n    Jsi_Value *NaN = Jsi_ValueMakeNumber(interp, NULL, Jsi_NumberNaN());\n\n    Jsi_Value *Inf = Jsi_ValueMakeNumber(interp, NULL, Jsi_NumberInfinity(1));\n    \n    Jsi_ValueInsertFixed(interp, global, \"NaN\", NaN);\n    Jsi_ValueInsertFixed(interp, global, \"Infinity\", Inf);\n    interp->NaNValue = NaN;\n    interp->InfValue = Inf;\n#define MCONST(name,v) Jsi_ValueInsert(interp, val, name, Jsi_ValueNewNumber(interp, v), JSI_OM_READONLY)\n    MCONST(\"MAX_VALUE\", DBL_MAX);\n    MCONST(\"MIN_VALUE\", DBL_MIN);\n    MCONST(\"NEGATIVE_INFINITY\", Jsi_NumberInfinity(-1));\n    Jsi_ValueInsertFixed(interp, val, \"POSITIVE_INFINITY\", Inf);\n    Jsi_ValueInsertFixed(interp, val, \"NaN\", NaN);\n    return JSI_OK;\n}\n#endif\n", "#ifndef JSI_AMALGAMATION\n#include \"jsiInt.h\"\n#endif\n\n#define _JSI_OPNM(nam) .sig=JSI_SIG_TYPEDEF, .id=JSI_OPTION_##nam, .idName=#nam\n// Note: these need to be in the same order as JSI_OPT_* in jsi.h \nstatic Jsi_OptionTypedef jsi_OptTypeInfo[] = {\n    {.sig=JSI_SIG_TYPEDEF, .id=JSI_OPTION_END,.idName=\"NONE\", },\n    {_JSI_OPNM(BOOL),    .cName=\"bool\",     .size=sizeof(bool),       .fmt=PRIu8,  .xfmt=\"\"  PRIu8,    .sfmt=SCNu8, .help=\"Boolean value: true or false\" },\n    {_JSI_OPNM(INT8),    .cName=\"int8_t\",   .size=sizeof(int8_t),     .fmt=PRId8,  .xfmt=\"#\" PRIx8,    .sfmt=SCNd8, .help=\"An 8-bit integer\" },\n    {_JSI_OPNM(INT16),   .cName=\"int16_t\",  .size=sizeof(int16_t),    .fmt=PRId16, .xfmt=\"#\" PRIx16,   .sfmt=SCNd16, .help=\"An 16-bit integer\" },\n    {_JSI_OPNM(INT32),   .cName=\"int32_t\",  .size=sizeof(int32_t),    .fmt=PRId32, .xfmt=\"#\" PRIx32,   .sfmt=SCNd32, .help=\"An 32-bit integer\" },\n    {_JSI_OPNM(INT64),   .cName=\"int64_t\",  .size=sizeof(int64_t),    .fmt=PRId64, .xfmt=\"#\" PRIx64,   .sfmt=SCNd64, .help=\"An 64-bit integer\" },\n    {_JSI_OPNM(UINT8),   .cName=\"uint8_t\",  .size=sizeof(uint8_t),    .fmt=PRIu8,  .xfmt=\"#\" PRIx8,    .sfmt=SCNu8, .help=\"Unsigned 8-bit integer\" },\n    {_JSI_OPNM(UINT16),  .cName=\"uint16_t\", .size=sizeof(uint16_t),   .fmt=PRIu16, .xfmt=\"#\" PRIx16,   .sfmt=SCNu16, .help=\"Unsigned 16-bit integer\" },\n    {_JSI_OPNM(UINT32),  .cName=\"uint32_t\", .size=sizeof(uint32_t),   .fmt=PRIu32, .xfmt=\"#\" PRIx32,   .sfmt=SCNu32, .help=\"Unsigned 32-bit integer\" },\n    {_JSI_OPNM(UINT64),  .cName=\"uint64_t\", .size=sizeof(uint64_t),   .fmt=PRIu64, .xfmt=\"#\" PRIx64,   .sfmt=SCNu64, .help=\"Unsigned 64-bit integer\" },\n    {_JSI_OPNM(FLOAT),   .cName=\"float\",    .size=sizeof(float),      .fmt=\"g\",    .xfmt=\"#\" \"g\",      .sfmt=\"g\", .help=\"Floating point\" },\n    {_JSI_OPNM(DOUBLE),  .cName=\"double\",   .size=sizeof(double),     .fmt=\"lg\",   .xfmt=\"#\" \"lg\",     .sfmt=\"lg\", .help=\"Floating point double\" },\n    {_JSI_OPNM(LDOUBLE),  .cName=\"ldouble\", .size=sizeof(ldouble),    .fmt=\"Lg\",   .xfmt=\"#\" \"Lg\",     .sfmt=\"Lg\", .help=\"Floating point long double\" },\n    {_JSI_OPNM(STRBUF),  .cName=\"Jsi_Strbuf\",.size=0,                 .fmt=\"s\",    .xfmt=\"s\",    .sfmt=0 /*\"s\"*/, .help=\"A fixed size string buffer\" },\n    {_JSI_OPNM(TIME_W),  .cName=\"time_w\",   .size=sizeof(time_w),     .fmt=PRId64, .xfmt=\"#\" PRIx64,   .sfmt=SCNd64, .help=\"A time value in milliseconds stored as a 64 bit integer\" },\n    {_JSI_OPNM(TIME_D),  .cName=\"time_d\",   .size=sizeof(time_d),     .fmt=\"g\",    .xfmt=\"#\" \"g\",      .sfmt=\"g\", .help=\"A time value in milliseconds stored as a double\" },\n    {_JSI_OPNM(TIME_T),  .cName=\"time_t\",   .size=sizeof(time_t),     .fmt=\"ld\",   .xfmt=\"#lx\",  .sfmt=\"ld\", .help=\"A time value stored in a unix time_t\" },\n    {_JSI_OPNM(SIZE_T),  .cName=\"size_t\",   .size=sizeof(size_t),     .fmt=\"zd\",   .xfmt=\"#zx\",  .sfmt=\"z\", .help=\"Size unsigned\" },\n    {_JSI_OPNM(SSIZE_T), .cName=\"ssize_t\",  .size=sizeof(ssize_t),    .fmt=\"zu\",   .xfmt=\"#zx\",  .sfmt=\"zu\", .help=\"Size integer\" },\n    {_JSI_OPNM(INTPTR_T),.cName=\"intptr_t\", .size=sizeof(intptr_t),   .fmt=\"d\",    .xfmt=\"#x\",   .sfmt=\"d\", .help=\"Integer large enough to store pointer\" },\n    {_JSI_OPNM(UINTPTR_T),.cName=\"uintptr_t\",.size=sizeof(uintptr_t), .fmt=\"u\",    .xfmt=\"#x\",   .sfmt=\"u\", .help=\"Unsigned large enough to store pointer\" },\n    {_JSI_OPNM(NUMBER),  .cName=\"Jsi_Number\",.size=sizeof(Jsi_Number),.fmt=JSI_NUMGFMT,.xfmt=\"#\" JSI_NUMGFMT,.sfmt=JSI_NUMGFMT, .help=\"Double or long double\" },\n    {_JSI_OPNM(INT),     .cName=\"int\",      .size=sizeof(int),        .fmt=\"d\",    .xfmt=\"#x\",   .sfmt=\"d\", .help=\"Integer\" },\n    {_JSI_OPNM(UINT),    .cName=\"uint\",     .size=sizeof(uint),       .fmt=\"u\",    .xfmt=\"#x\",   .sfmt=\"u\", .help=\"Unsigned\" },\n    {_JSI_OPNM(LONG),    .cName=\"long\",     .size=sizeof(long),       .fmt=\"ld\",   .xfmt=\"#lx\",  .sfmt=\"ld\", .help=\"Long\" },\n    {_JSI_OPNM(ULONG),   .cName=\"ulong\",    .size=sizeof(ulong),      .fmt=\"lu\",   .xfmt=\"#lx\",  .sfmt=\"lu\", .help=\"Unsigned long\" },\n    {_JSI_OPNM(SHORT),   .cName=\"short\",    .size=sizeof(short),      .fmt=\"hd\",   .xfmt=\"#hx\",  .sfmt=\"hd\", .help=\"Short\" },\n    {_JSI_OPNM(USHORT),  .cName=\"ushort\",   .size=sizeof(ushort),     .fmt=\"hu\",   .xfmt=\"#hx\",  .sfmt=\"hu\", .help=\"Unsigned short\" },\n    {_JSI_OPNM(STRING),  .cName=\"Jsi_Value*\",.size=sizeof(Jsi_Value*),.fmt=\"s\",    .xfmt=\"s\", .sfmt=0, .help=\"A string Value\"},\n    {_JSI_OPNM(DSTRING), .cName=\"Jsi_DString\",.size=sizeof(Jsi_DString), .fmt=0,    .xfmt=0, .sfmt=0, .help=\"A dynamic string\"},\n    {_JSI_OPNM(STRKEY),  .cName=\"const char*\",.size=sizeof(const char *), .fmt=0,    .xfmt=0, .sfmt=0, .help=\"Const string\"},\n    {_JSI_OPNM(VALUE),   .cName=\"Jsi_Value*\",.size=sizeof(Jsi_Value*), .fmt=0,    .xfmt=0, .sfmt=0, .help=\"A Value\"},\n    {_JSI_OPNM(VAR),     .cName=\"Jsi_Value*\",.size=sizeof(Jsi_Value*), .fmt=0,    .xfmt=0, .sfmt=0, .help=\"A Var Value\"},\n    {_JSI_OPNM(OBJ),     .cName=\"Jsi_Value*\",.size=sizeof(Jsi_Value*), .fmt=0,    .xfmt=0, .sfmt=0, .help=\"An Object Value\"},\n    {_JSI_OPNM(ARRAY),   .cName=\"Jsi_Value*\",.size=sizeof(Jsi_Value*), .fmt=0,    .xfmt=0, .sfmt=0, .help=\"An Array Value\"},\n    {_JSI_OPNM(REGEXP),  .cName=\"Jsi_Value*\",.size=sizeof(Jsi_Value*), .fmt=0,    .xfmt=0, .sfmt=0, .help=\"A Regex Value\"},\n    {_JSI_OPNM(FUNC),    .cName=\"Jsi_Value*\",.size=sizeof(Jsi_Value*), .fmt=0,    .xfmt=0, .sfmt=0, .help=\"A Func Value\"}, \n    {_JSI_OPNM(USEROBJ), .cName=\"Jsi_Value*\",.size=sizeof(Jsi_Value*), .fmt=0,    .xfmt=0, .sfmt=0, .help=\"A User-define Object Value\"}, \n    {_JSI_OPNM(CUSTOM),  .cName=\"\", .size=0, .fmt=0,    .xfmt=0, .sfmt=0, .help=\"A Custom value\"},\n    {_JSI_OPNM(END)}\n};\n\nconst Jsi_OptionTypedef* Jsi_OptionsStr2Type(const char *str, bool cName) {\n    int typ;\n    for (typ=JSI_OPTION_BOOL; typ < JSI_OPTION_END; typ++) {\n        const char *snam = (cName?jsi_OptTypeInfo[typ].cName:jsi_OptTypeInfo[typ].idName);\n        if (snam && snam[0] && !Jsi_Strcmp(str, snam))\n            return jsi_OptTypeInfo+typ;\n    }\n    return NULL;\n}\n\nconst Jsi_OptionTypedef* Jsi_OptionTypeInfo(Jsi_OptionId typ) {\n    if (typ>=JSI_OPTION_BOOL && typ < JSI_OPTION_END)\n        return jsi_OptTypeInfo+typ;\n    return NULL;\n}\n\nconst char *jsi_OptionTypeStr(Jsi_OptionId typ, bool cName)\n{\n    const Jsi_OptionTypedef* ti = Jsi_OptionTypeInfo(typ);\n    if (ti)\n        return (cName?ti->cName:ti->idName);\n    return NULL;\n}\n\nbool Jsi_OptionsValid(Jsi_Interp *interp,  Jsi_OptionSpec* spec)\n{\n    int i = 0;\n    while (spec[i].id>=JSI_OPTION_BOOL && spec[i].id < JSI_OPTION_END) {\n        SIGASSERTMASK(spec+i, OPTS, 0xff);\n        if (spec[i].help && Jsi_Strchr(spec[i].help, '\\n')) {\n            if (interp)\n                Jsi_LogError(\"item \\\"%s\\\": help contains newline\", spec[i].name);\n            return 0;\n        }\n        i++;\n    }\n    return (i>0);\n}\n\n#ifndef JSI_LITE_ONLY\n\nstatic void jsi_DumpOptionSpec(Jsi_Interp *interp, Jsi_Obj *nobj, Jsi_OptionSpec* spec, int addName);\n\nstatic Jsi_RC jsi_DeleteSpecCacheTable(Jsi_Interp *interp, void *clientData)\n{\n  Jsi_Hash *tablePtr = (Jsi_Hash *) clientData;\n  Jsi_HashEntry *entryPtr;\n  Jsi_HashSearch search;\n\n  for (entryPtr = Jsi_HashSearchFirst(tablePtr,&search); entryPtr != NULL;\n      entryPtr = Jsi_HashSearchNext(&search)) {\n\n    Jsi_Free(Jsi_HashValueGet(entryPtr));\n  }\n  Jsi_HashDelete(tablePtr);\n  return JSI_OK;\n}\n\nstatic Jsi_OptionSpec * jsi_GetCachedOptionSpecs(Jsi_Interp *interp, const Jsi_OptionSpec *staticSpecs)\n{\n    Jsi_OptionSpec *cachedSpecs;\n    Jsi_Hash *specCacheTablePtr;\n    Jsi_HashEntry *entryPtr;\n    bool isNew;\n\n    specCacheTablePtr = (Jsi_Hash*)Jsi_InterpGetData(interp, \"jsi:OptionSpec\", NULL);\n    if (specCacheTablePtr == NULL) {\n        specCacheTablePtr = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, 0);\n        Jsi_InterpSetData(interp, \"jsi:OptionSpec\", specCacheTablePtr, jsi_DeleteSpecCacheTable);\n    }\n    \n    entryPtr = Jsi_HashEntryNew(specCacheTablePtr, (char *) staticSpecs, &isNew);\n    if (isNew) {\n        unsigned int entrySpace = sizeof(Jsi_OptionSpec);\n        const Jsi_OptionSpec *staticSpecPtr;\n\n        for (staticSpecPtr=staticSpecs; staticSpecPtr->id>=JSI_OPTION_BOOL && staticSpecPtr->id!=JSI_OPTION_END; staticSpecPtr++)\n            entrySpace += sizeof(Jsi_OptionSpec);\n        assert(staticSpecPtr->id==JSI_OPTION_END);\n\n        cachedSpecs = (Jsi_OptionSpec *) Jsi_Malloc(entrySpace);\n        memcpy((void *) cachedSpecs, (void *) staticSpecs, entrySpace);\n        Jsi_HashValueSet(entryPtr, cachedSpecs);\n\n    } else {\n        cachedSpecs = (Jsi_OptionSpec *) Jsi_HashValueGet(entryPtr);\n    }\n\n    return cachedSpecs;\n}\n\nconst Jsi_OptionSpec *\nJsi_OptionSpecsCached(Jsi_Interp *interp, const Jsi_OptionSpec *staticSpecs)\n{\n#ifdef NO_CACHED_SPECS\n    return (Jsi_OptionSpec*)staticSpecs;\n#else\n    /* If we aren't master interp, need to cache due to init and modified flags if Jsi_OptionsChanged is called. */\n    if (interp->mainInterp == NULL) {\n        interp->mainInterp = interp;\n    }\n    if (interp == interp->mainInterp) {\n        return staticSpecs;\n    }\n    return jsi_GetCachedOptionSpecs(interp, staticSpecs);\n#endif\n}\n\n/**********************************/\nJsi_OptionSpec *\nJsi_OptionsFind(Jsi_Interp *interp, Jsi_OptionSpec *specs, const char *name, Jsi_Wide flags)\n{\n    Jsi_OptionSpec *specPtr;\n    char c;      /* First character of current argument. */\n    Jsi_OptionSpec *matchPtr; /* Matching spec, or NULL. */\n    size_t length;\n    const char *matStr = NULL;\n    \n    if (name == NULL) {\n        Jsi_LogError(\"Null name for option\");\n        return NULL;\n    }\n    c = name[0];\n    length = Jsi_Strlen(name);\n    matchPtr = NULL;\n    for (specPtr = specs; specPtr->id>=JSI_OPTION_BOOL && specPtr->id < JSI_OPTION_END && specPtr->name; specPtr++) {\n\n        if ((specPtr->name[0] != c)\n                || (Jsi_Strncmp(specPtr->name, name, length) != 0)) {\n            continue;\n        }\n        if (specPtr->name[length] == 0) {\n            return specPtr;   /* Stop on a perfect match. */\n        }\n        if (matchPtr != NULL) {\n            Jsi_LogError(\"ambiguous option \\\"%s\\\" matches both \\\"%s\\\" and \\\"%s\\\"\", name, matStr, specPtr->name);\n            return (Jsi_OptionSpec *) NULL;\n        }\n        matchPtr = specPtr;\n        matStr = specPtr->name;\n    }\n\n    if (matchPtr == NULL) {\n        Jsi_DString dStr = {};\n        Jsi_DSAppend(&dStr, \"unknown option \\\"\", name, \"\\\" not one of: \", NULL);\n    \n        for (specPtr = specs; specPtr->id>=JSI_OPTION_BOOL && specPtr->id < JSI_OPTION_END && specPtr->name; specPtr++) {\n            if (specPtr->name == NULL) {\n                break;\n            }\n            if (name[0] != '?' || _JSICASTINT(specPtr->id) < 0 || specPtr->id >= JSI_OPTION_END) {\n                Jsi_DSAppend(&dStr, specPtr->name, \" \", NULL);\n            } else {\n\n                Jsi_DSAppend(&dStr, \"?\", specPtr->name, \" <\", jsi_OptTypeInfo[specPtr->id].idName, \">? \", NULL);\n            }\n        }\n        assert(specPtr->id == JSI_OPTION_END);\n        Jsi_LogError(\"%s\", Jsi_DSValue(&dStr));\n        Jsi_DSFree(&dStr);\n        return (Jsi_OptionSpec *) NULL;\n    }\n    return matchPtr;\n}\n\n\nJsi_RC\njsi_SetOption_(Jsi_Interp *interp, Jsi_OptionSpec *specPtr, const char *string /*UNUSED*/, void* rec, Jsi_Value *argValue, Jsi_Wide flags, bool isSafe)\n{\n    Jsi_Wide wcount = 0;\n    bool bn;\n    Jsi_Number nv;\n    bool isIncr = (flags & JSI_OPTS_INCR);\n    const char *expType = NULL;\n    char *record = (char*)rec, *ptr = record + specPtr->offset;\n    Jsi_OptionCustom* cust = NULL;\n    const char *emsg = NULL, *epre = \"\";\n\n    if (specPtr->id<JSI_OPTION_BOOL || specPtr->id>=JSI_OPTION_END) \n        return Jsi_LogBug(\"unknown option id \\\"%d\\\" for \\\"%s\\\"\", specPtr->id, specPtr->name);\n    if (specPtr->custom  && specPtr->id == JSI_OPTION_CUSTOM) {\n        cust = Jsi_OptionCustomBuiltin(specPtr->custom);\n        if (cust && cust->parseProc) {\n            int lastErrCnt = interp->logErrorCnt;\n            Jsi_OptionSpec *oep = interp->parseMsgSpec;\n            interp->parseMsgSpec = specPtr;\n            Jsi_RC rc = (*cust->parseProc)(interp, specPtr, argValue, NULL, record, flags);\n            if (rc != JSI_OK) {\n                if (!interp->csc || lastErrCnt == interp->logErrorCnt)\n                    Jsi_LogError(\"invalid value\");\n                interp->parseMsgSpec = oep;\n                return JSI_ERROR;\n            }\n            interp->parseMsgSpec = oep;\n        } else \n            return Jsi_LogBug(\"missing or bad custom for \\\"%s\\\"\", specPtr->name);\n        goto done;\n    }\n\n    switch (specPtr->id) {\n    case JSI_OPTION_CUSTOM:\n        if (!specPtr->custom) \n            return Jsi_LogBug(\"missing or custom for \\\"%s\\\"\", specPtr->name);\n\n    case JSI_OPTION_BOOL: {\n        if (!argValue)\n            *(char*)ptr = 0;\n        else if (!Jsi_ValueIsBoolean(interp, argValue))\n            goto bail;\n        Jsi_GetBoolFromValue(interp, argValue, &bn);\n        *(char*)ptr = bn;\n        break;\n    }\n\n    case JSI_OPTION_INT:\n    case JSI_OPTION_UINT:\n    case JSI_OPTION_LONG:\n    case JSI_OPTION_INTPTR_T:\n    case JSI_OPTION_UINTPTR_T:\n    case JSI_OPTION_SIZE_T:\n    case JSI_OPTION_SSIZE_T:\n    case JSI_OPTION_ULONG:\n    case JSI_OPTION_SHORT:\n    case JSI_OPTION_USHORT:\n    case JSI_OPTION_UINT64:\n    case JSI_OPTION_INT64:\n    case JSI_OPTION_INT8:\n    case JSI_OPTION_UINT8:\n    case JSI_OPTION_INT16:\n    case JSI_OPTION_UINT16:\n    case JSI_OPTION_INT32:\n    case JSI_OPTION_UINT32:\n        wcount = 0;\n        if (argValue) {\n            if (!Jsi_ValueIsNumber(interp, argValue))\n                goto bail;\n\n            if (Jsi_GetWideFromValue(interp, argValue, &wcount) != JSI_OK) {\n                return JSI_ERROR;\n            }\n            \n        }\n        switch (specPtr->id) {\n#define _JSI_OPTSETTYP(typ, n, ptr) if (isIncr) n += *((typ *)ptr); \\\n    if (isIncr || ((Jsi_Wide)(typ)(n)) == (n)) interp->cdataIncrVal = *((typ *)ptr) = (typ)(n); else expType = #typ;\n            case JSI_OPTION_INT:    _JSI_OPTSETTYP(int, wcount, ptr); break;\n            case JSI_OPTION_UINT:   _JSI_OPTSETTYP(uint, wcount, ptr); break;\n            case JSI_OPTION_INTPTR_T: _JSI_OPTSETTYP(intptr_t, wcount, ptr); break;\n            case JSI_OPTION_UINTPTR_T:_JSI_OPTSETTYP(uintptr_t, wcount, ptr); break;\n            case JSI_OPTION_SIZE_T:   _JSI_OPTSETTYP(size_t, wcount, ptr); break;\n            case JSI_OPTION_SSIZE_T:  _JSI_OPTSETTYP(ssize_t, wcount, ptr); break;\n            case JSI_OPTION_LONG:   _JSI_OPTSETTYP(long, wcount, ptr); break;\n            case JSI_OPTION_ULONG:  _JSI_OPTSETTYP(ulong, wcount, ptr); break;\n            case JSI_OPTION_SHORT:  _JSI_OPTSETTYP(short, wcount, ptr); break;\n            case JSI_OPTION_USHORT: _JSI_OPTSETTYP(ushort, wcount, ptr); break;\n            case JSI_OPTION_INT8:   _JSI_OPTSETTYP(int8_t, wcount, ptr); break;\n            case JSI_OPTION_UINT8:  _JSI_OPTSETTYP(uint8_t, wcount, ptr) break;\n            case JSI_OPTION_INT16:  _JSI_OPTSETTYP(int16_t, wcount, ptr); break;\n            case JSI_OPTION_UINT16: _JSI_OPTSETTYP(uint16_t, wcount, ptr); break;\n            case JSI_OPTION_INT32:  _JSI_OPTSETTYP(int32_t, wcount, ptr); break;\n            case JSI_OPTION_UINT32: _JSI_OPTSETTYP(uint32_t, wcount, ptr); break;\n            case JSI_OPTION_INT64:  _JSI_OPTSETTYP(int64_t, wcount, ptr); break;\n            case JSI_OPTION_UINT64: _JSI_OPTSETTYP(uint64_t, wcount, ptr); break; // TODO: might loose top sign bit...\n            default: break;\n        }\n        if (expType)\n            return Jsi_LogType(\"not a %s\", expType);\n        isIncr = 0;\n        break;\n\n    case JSI_OPTION_NUMBER:\n    case JSI_OPTION_DOUBLE:\n    case JSI_OPTION_LDOUBLE:\n    case JSI_OPTION_FLOAT:\n        nv = 0;\n        if (argValue) {\n            if (!Jsi_ValueIsNumber(interp, argValue))\n                goto bail;\n            if (Jsi_GetNumberFromValue(interp, argValue, &nv) != JSI_OK) {\n                return JSI_ERROR;\n            }\n        }\n            \n        switch (specPtr->id) {\n#define _JSI_OPTSETNTYP(typ, n, ptr) if (!argValue) *(typ*)ptr = 0; else { if (isIncr) n += *((typ *)ptr); \\\n            interp->cdataIncrVal = *((typ *)ptr) = (typ)(n); \\\n            if (interp->strict && Jsi_NumberIsNaN((Jsi_Number)(*((typ *)ptr)))) return Jsi_LogError(\"not a number\"); }\n\n            case JSI_OPTION_NUMBER: _JSI_OPTSETNTYP(Jsi_Number, nv, ptr); break;\n            case JSI_OPTION_LDOUBLE: _JSI_OPTSETNTYP(ldouble, nv, ptr); break;\n            case JSI_OPTION_FLOAT: _JSI_OPTSETNTYP(float, nv, ptr); break;\n            case JSI_OPTION_DOUBLE: _JSI_OPTSETNTYP(double, nv, ptr); break;\n            default: break;\n        }\n        isIncr = 0;\n        break;\n    case JSI_OPTION_STRKEY:\n    {\n        if (argValue == NULL || Jsi_ValueIsNull(interp, argValue))\n            *(const char**)ptr = NULL;\n        else {\n            const char *scp;\n            if (Jsi_GetStringFromValue(interp, argValue, &scp) != JSI_OK) {\n                return JSI_ERROR;\n            }\n            *(const char**)ptr = Jsi_KeyAdd(interp,scp);\n        }\n    }\n    break;\n    case JSI_OPTION_STRBUF:\n    {\n        if (argValue == NULL || Jsi_ValueIsNull(interp, argValue))\n            *(char*)ptr = 0;\n        else {\n            int sLen;\n            const char *scp = Jsi_ValueString(interp, argValue, &sLen);\n            if (!scp)\n                goto bail;\n            if (sLen>(int)(specPtr->size-1)) {\n                return Jsi_LogError(\"String too long\");\n                //sLen = specPtr->size-1;\n            }\n            memcpy((char*)ptr, scp, sLen);\n            ((char*)ptr)[sLen] = 0;\n        }\n    }\n    break;\n    \n#define _JSI_OPT_CHECKNULL(argValue) if (!argValue || Jsi_ValueIsNull(interp, argValue)) { \\\n         if (*((Jsi_Value **)ptr)) \\\n            Jsi_DecrRefCount(interp, *((Jsi_Value **)ptr)); \\\n        *((Jsi_Value **)ptr) = NULL; \\\n        break; \\\n    }\n\n#define _JSI_OPT_ARGSET(argValue, ptr) \\\n    if (!(specPtr->flags&JSI_OPT_NO_DUPVALUE)) {\\\n        Jsi_IncrRefCount(interp, argValue); \\\n        if (*((Jsi_Value **)ptr)) Jsi_DecrRefCount(interp, *((Jsi_Value **)ptr)); \\\n    }\\\n    *((Jsi_Value **)ptr) = argValue;\n    \n    case JSI_OPTION_STRING:\n        if (argValue == *((Jsi_Value **)ptr))\n            break;\n        _JSI_OPT_CHECKNULL(argValue);\n        if (!Jsi_ValueIsString(interp, argValue))\n            goto bail;\n        _JSI_OPT_ARGSET(argValue, ptr);\n        break;\n        \n    case JSI_OPTION_DSTRING:\n        Jsi_DSInit((Jsi_DString *)ptr);\n        if (argValue && !Jsi_ValueIsNull(interp, argValue))\n        {\n            int sLen;\n            const char *scp = Jsi_ValueString(interp, argValue, &sLen);\n            if (!scp)\n                goto bail;\n            Jsi_DSAppendLen((Jsi_DString *)ptr, scp, sLen);\n        }\n        break;\n    \n    case JSI_OPTION_TIME_D: {\n       if (argValue)\n        {\n            Jsi_Number nv = 0;\n            if (Jsi_ValueIsNumber(interp, argValue)) {\n                Jsi_GetNumberFromValue(interp, argValue, &nv);\n                *(double*)ptr = nv;\n            } else {\n                const char *scp;\n                if (Jsi_GetStringFromValue(interp, argValue, &scp) != JSI_OK) {\n                    return JSI_ERROR;\n                }\n                if (JSI_OK != Jsi_DatetimeParse(interp, scp, \"\", 0, &nv, false))\n                    return JSI_ERROR;\n                *(double*)ptr = nv;\n            }\n        } else {\n            *(double*)ptr = 0;\n        }\n        break;\n    }\n    case JSI_OPTION_TIME_W: {\n       if (argValue)\n        {\n            if (Jsi_ValueIsNumber(interp, argValue)) {\n                Jsi_GetNumberFromValue(interp, argValue, (Jsi_Number*)ptr);\n            } else {\n                const char *scp;\n                Jsi_Number num;\n                if (Jsi_GetStringFromValue(interp, argValue, &scp) != JSI_OK) {\n                    return JSI_ERROR;\n                }\n                if (JSI_OK != Jsi_DatetimeParse(interp, scp, \"\", 0, &num, false))\n                    return JSI_ERROR;\n                *(Jsi_Wide*)ptr = (Jsi_Wide)num;\n            }\n        } else {\n            *(Jsi_Wide*)ptr = 0;\n        }\n        break;\n    }\n    case JSI_OPTION_TIME_T: {\n       if (argValue)\n        {\n            if (Jsi_ValueIsNumber(interp, argValue)) {\n                Jsi_Number num;\n                Jsi_GetNumberFromValue(interp, argValue, &num);\n                *(time_t*)ptr = (time_t)num;\n            } else {\n                const char *scp;\n                if (Jsi_GetStringFromValue(interp, argValue, &scp) != JSI_OK) {\n                    return JSI_ERROR;\n                }\n                Jsi_Number nval;\n                if (JSI_OK != Jsi_DatetimeParse(interp, scp, \"\", 0, &nval, false))\n                    return JSI_ERROR;\n                *(time_t*)ptr = nval/1000LL;\n            }\n        } else {\n            *(time_t*)ptr = 0;\n        }\n        break;\n    }\n    case JSI_OPTION_VAR:\n        _JSI_OPT_CHECKNULL(argValue);\n        if (argValue->vt != JSI_VT_NULL && argValue->vt != JSI_VT_VARIABLE) \n            goto bail;\n        _JSI_OPT_ARGSET(argValue, ptr);\n        break;\n\n    case JSI_OPTION_FUNC:\n        _JSI_OPT_CHECKNULL(argValue);\n        if (argValue->vt != JSI_VT_OBJECT || argValue->d.obj->ot != JSI_OT_FUNCTION) \n            goto bail;\n        if (specPtr->data && (interp->typeCheck.run|interp->typeCheck.all))\n            if (!jsi_FuncArgCheck(interp, argValue->d.obj->d.fobj->func, (char*)specPtr->data)) \n                return Jsi_LogError(\"failed setting func pointer for %s\", specPtr->name);\n\n        _JSI_OPT_ARGSET(argValue, ptr);\n        break;\n        \n    case JSI_OPTION_USEROBJ:\n        _JSI_OPT_CHECKNULL(argValue);\n        if (argValue->vt != JSI_VT_OBJECT || argValue->d.obj->ot != JSI_OT_USEROBJ) \n            goto bail;\n        if (specPtr->data && Jsi_Strcmp((char*)specPtr->data, argValue->d.obj->d.uobj->reg->name)) \n            return Jsi_LogError(\"expected id %s for %s\",(char*)specPtr->data,  specPtr->name);\n        _JSI_OPT_ARGSET(argValue, ptr);\n        break;\n\n    case JSI_OPTION_REGEXP:\n        _JSI_OPT_CHECKNULL(argValue);\n        if (argValue->vt != JSI_VT_OBJECT || argValue->d.obj->ot != JSI_OT_REGEXP)\n            goto bail;\n        _JSI_OPT_ARGSET(argValue, ptr);\n        break;\n\n    case JSI_OPTION_OBJ:\n        _JSI_OPT_CHECKNULL(argValue);\n        if (argValue->vt != JSI_VT_OBJECT)\n            goto bail;\n\n    case JSI_OPTION_VALUE:\n         _JSI_OPT_CHECKNULL(argValue);\n         _JSI_OPT_ARGSET(argValue, ptr);\n        break;\n    case JSI_OPTION_ARRAY:\n        _JSI_OPT_CHECKNULL(argValue);\n        if (argValue->vt != JSI_VT_OBJECT || !argValue->d.obj->isarrlist)\n            goto bail;\n        _JSI_OPT_ARGSET(argValue, ptr);\n        break;\n#ifdef __cplusplus\n    case JSI_OPTION_END:\n#else\n    default:\n#endif\n        Jsi_LogBug(\"invalid option id: %d\", specPtr->id);\n    }\ndone:\n    specPtr->flags |= JSI_OPT_IS_SPECIFIED;\n    if (isIncr)\n        return Jsi_LogError(\"incr invalid for %s\", specPtr->name);\n    return JSI_OK;\n\nbail:\n    if (!emsg) {\n        emsg = jsi_OptTypeInfo[specPtr->id].cName;\n        epre = \"expected \";\n    }\n    return Jsi_LogError(\"%s%s: for %s option \\\"%.40s\\\"\", epre, emsg, (cust?cust->name:\"\"), specPtr->name);\n}\n\nJsi_RC\njsi_SetOption(Jsi_Interp *interp, Jsi_OptionSpec *specPtr, const char *string /*UNUSED*/, void* rec, Jsi_Value *argValue, Jsi_Wide flags, bool isSafe)\n{\n    Jsi_Value *oa = interp->lastParseOpt;\n    interp->lastParseOpt = argValue;\n    Jsi_RC rc = jsi_SetOption_(interp, specPtr, string, rec, argValue, flags, isSafe);\n    interp->lastParseOpt = oa;\n    return rc;\n}\n\nJsi_RC\nJsi_OptionsSet(Jsi_Interp *interp, Jsi_OptionSpec *specs, void* rec, const char *option, Jsi_Value *valuePtr, Jsi_Wide flags)\n{\n    char *record = (char*)rec;\n    Jsi_OptionSpec *specPtr;\n    specs = jsi_GetCachedOptionSpecs(interp, specs);\n    const char *cp = NULL, *cb = NULL;\n    bool isSafe = interp->isSafe;\n    if (option) {\n        cp = Jsi_Strchr(option, '.');\n        cb = Jsi_Strchr(option, '[');\n    }\n    if (cp && (!cb || cp<cb) ) {\n        Jsi_DString dStr;\n        int len = (cp-option);\n        Jsi_DSInit(&dStr);\n        cp = Jsi_DSAppendLen(&dStr, option, len);\n        specPtr = Jsi_OptionsFind(interp, specs, cp, flags);\n        Jsi_DSFree(&dStr);\n        if (!specPtr || !specPtr->data|| specPtr->id != JSI_OPTION_CUSTOM || specPtr->custom != Jsi_Opt_SwitchSuboption) \n            return Jsi_LogError(\"unknown or bad sub-config option: %s\", option);\n        cp = option+len+1;\n        return Jsi_OptionsSet(interp, (Jsi_OptionSpec *)(specPtr->data), (void*)(((char*)rec)+specPtr->offset), cp, valuePtr, flags);\n    }\n    if (cb && cb != option) {\n        char *ce = Jsi_Strchr(option, ']');\n        Jsi_Wide ul;\n        Jsi_DString dStr;\n        Jsi_DSInit(&dStr);\n        int len = 0;\n        if (ce && ce>cb) {\n            len = (ce-cb-1);\n            cp = Jsi_DSAppendLen(&dStr, cb+1, len);\n        }\n        if (len <= 0 || Jsi_GetWide(interp, cp, &ul, 0) != JSI_OK || ul<0) \n            return Jsi_LogError(\"bad sub-array option: %s\", option);\n        len = (cb-option);\n        Jsi_DSSetLength(&dStr, 0);\n        cp = Jsi_DSAppendLen(&dStr, option, len);\n        specPtr = Jsi_OptionsFind(interp, specs, cp, flags);\n        Jsi_DSFree(&dStr);\n        if (!specPtr || !specPtr->init.OPT_CARRAY|| specPtr->id != JSI_OPTION_CUSTOM || specPtr->custom != Jsi_Opt_SwitchCArray) {\nbail:\n            return Jsi_LogError(\"unknown or bad array option: %s\", option);\n        }\n        cp = cb+1;\n        Jsi_OptionSpec *subSpec = specPtr->init.OPT_CARRAY;\n        int isize, size = specPtr->arrSize;\n        if (!subSpec || size<=0 || (isize=subSpec->size)<=0)\n            goto bail;\n        isize = isize/size;\n        uchar *s = (((uchar*)rec)+specPtr->offset + isize*ul);\n        if (ce[1] != '.' || !subSpec->data) {\n            if (Jsi_OptionsSet(interp, subSpec, (void*)s, subSpec->name, valuePtr, flags) != JSI_OK)\n                return JSI_ERROR;\n        } else {\n            if (Jsi_OptionsSet(interp, (Jsi_OptionSpec *)subSpec->data, (void*)s, ce+2, valuePtr, flags) != JSI_OK)\n                return JSI_ERROR;\n        }\n        return JSI_OK;\n    }\n    specPtr = Jsi_OptionsFind(interp, specs, option, flags);\n    if (!specPtr)\n        return JSI_ERROR;\n    return jsi_SetOption(interp, specPtr, option, record, valuePtr, flags, isSafe);\n}\n\nJsi_RC\njsi_GetOption(Jsi_Interp *interp, Jsi_OptionSpec *specPtr, void* record, const char *option, Jsi_Value **valuePtr, Jsi_Wide flags)\n{\n    char *ptr;\n    \n    if (specPtr == NULL) \n        return Jsi_LogError(\"no such option: %s\", option);\n    //isNull = ((*string == '\\0') && (specPtr->flags & JSI_OPTION_NULL_OK));\n    \n    ptr = (char *)record + specPtr->offset;\n    if (_JSICASTINT(specPtr->id)<0 || specPtr->id>=JSI_OPTION_END) \n        return Jsi_LogError(\"no such option: %s\", option);\n    if (specPtr->custom) {\n        Jsi_OptionCustom* cust = Jsi_OptionCustomBuiltin(specPtr->custom);\n        if (cust->formatProc)\n            return (*cust->formatProc) (interp, specPtr, valuePtr, NULL, record, flags);\n    }\n\n    switch (specPtr->id) {\n    case JSI_OPTION_BOOL:\n        Jsi_ValueMakeBool(interp, valuePtr,*(bool*)ptr );\n        break;\n    case JSI_OPTION_INT:\n        Jsi_ValueMakeNumber(interp, valuePtr, (Jsi_Number)(*(int *)ptr));\n        break;\n    case JSI_OPTION_UINT:\n        Jsi_ValueMakeNumber(interp, valuePtr, (Jsi_Number)(*(uint *)ptr));\n        break;\n    case JSI_OPTION_INT8:\n        Jsi_ValueMakeNumber(interp, valuePtr, (Jsi_Number)(*(int8_t *)ptr));\n        break;\n    case JSI_OPTION_INT16:\n        Jsi_ValueMakeNumber(interp, valuePtr, (Jsi_Number)(*(int16_t *)ptr));\n        break;\n    case JSI_OPTION_INT32:\n        Jsi_ValueMakeNumber(interp, valuePtr, (Jsi_Number)(*(int32_t *)ptr));\n        break;\n    case JSI_OPTION_INT64:\n        Jsi_ValueMakeNumber(interp, valuePtr, (Jsi_Number)(*(Jsi_Wide *)ptr));\n        break;\n    case JSI_OPTION_UINT8:\n        Jsi_ValueMakeNumber(interp, valuePtr, (Jsi_Number)(*(uint8_t *)ptr));\n        break;\n    case JSI_OPTION_UINT16:\n        Jsi_ValueMakeNumber(interp, valuePtr, (Jsi_Number)(*(uint16_t *)ptr));\n        break;\n    case JSI_OPTION_UINT32:\n        Jsi_ValueMakeNumber(interp, valuePtr, (Jsi_Number)(*(uint32_t *)ptr));\n        break;\n    case JSI_OPTION_UINT64:\n        Jsi_ValueMakeNumber(interp, valuePtr, (Jsi_Number)(*(uint64_t *)ptr));\n        break;\n    case JSI_OPTION_FLOAT:\n        Jsi_ValueMakeNumber(interp, valuePtr, (Jsi_Number)*(float *)ptr);\n        break;\n    case JSI_OPTION_DOUBLE:\n        Jsi_ValueMakeNumber(interp, valuePtr, (Jsi_Number)*(double *)ptr);\n        break;\n    case JSI_OPTION_LDOUBLE:\n        Jsi_ValueMakeNumber(interp, valuePtr, (Jsi_Number)*(ldouble *)ptr);\n        break;\n    case JSI_OPTION_NUMBER:\n        Jsi_ValueMakeNumber(interp, valuePtr, *(Jsi_Number *)ptr);\n        break;\n    case JSI_OPTION_SIZE_T:\n        Jsi_ValueMakeNumber(interp, valuePtr, *(size_t *)ptr);\n        break;\n    case JSI_OPTION_SSIZE_T:\n        Jsi_ValueMakeNumber(interp, valuePtr, *(ssize_t *)ptr);\n        break;\n    case JSI_OPTION_INTPTR_T:\n        Jsi_ValueMakeNumber(interp, valuePtr, *(intptr_t *)ptr);\n        break;\n    case JSI_OPTION_UINTPTR_T:\n        Jsi_ValueMakeNumber(interp, valuePtr, *(uintptr_t *)ptr);\n        break;\n    case JSI_OPTION_LONG:\n        Jsi_ValueMakeNumber(interp, valuePtr, *(long *)ptr);\n        break;\n    case JSI_OPTION_ULONG:\n        Jsi_ValueMakeNumber(interp, valuePtr, *(ulong *)ptr);\n        break;\n    case JSI_OPTION_SHORT:\n        Jsi_ValueMakeNumber(interp, valuePtr, *(short *)ptr);\n        break;\n    case JSI_OPTION_USHORT:\n        Jsi_ValueMakeNumber(interp, valuePtr, *(ushort *)ptr);\n        break;\n        \n    case JSI_OPTION_DSTRING:\n        Jsi_ValueFromDS(interp, (Jsi_DString*)ptr, valuePtr);\n        break;\n    \n    case JSI_OPTION_TIME_W: {\n        Jsi_DString dStr = {};\n        Jsi_DatetimeFormat(interp, (Jsi_Number)(*(Jsi_Wide*)ptr), \"\", 0, &dStr);\n        Jsi_ValueFromDS(interp, &dStr, valuePtr);\n        break;\n    }\n    case JSI_OPTION_TIME_D: {\n        Jsi_DString dStr = {};\n        Jsi_DatetimeFormat(interp, (Jsi_Number)(*(double*)ptr), \"\", 0, &dStr);\n        Jsi_ValueFromDS(interp, &dStr, valuePtr);\n        break;\n    }\n    case JSI_OPTION_TIME_T: {\n        Jsi_DString dStr = {};\n        Jsi_DatetimeFormat(interp, 1000LL* (Jsi_Number)*(time_t*)ptr, \"%Y-%m-%d %H:%M:%S\", 0, &dStr);\n        Jsi_ValueFromDS(interp, &dStr, valuePtr);\n        break;\n    }\n    case JSI_OPTION_STRBUF:\n        if (ptr)\n            Jsi_ValueMakeStringDup(interp, valuePtr, ptr);\n        else\n            Jsi_ValueMakeNull(interp, valuePtr);\n        break;\n\n    case JSI_OPTION_STRKEY:\n        ptr = *(char **)ptr;\n        if (ptr)\n            Jsi_ValueMakeStringDup(interp, valuePtr, ptr);\n        else\n            Jsi_ValueMakeNull(interp, valuePtr);\n        break;\n\n    case JSI_OPTION_STRING:\n    case JSI_OPTION_VAR:\n    case JSI_OPTION_FUNC:\n    case JSI_OPTION_USEROBJ:\n    case JSI_OPTION_OBJ:\n    case JSI_OPTION_VALUE:\n    case JSI_OPTION_REGEXP:\n    case JSI_OPTION_ARRAY:\n        if (*(Jsi_Value **)ptr)\n            Jsi_ValueCopy(interp, *valuePtr, *(Jsi_Value **)ptr);\n        else\n            Jsi_ValueMakeNull(interp, valuePtr);\n        break;\n\n    case JSI_OPTION_CUSTOM:\n        break;\n\n#ifdef __cplusplus\n    case JSI_OPTION_END:\n#else\n    default:\n#endif\n        Jsi_LogBug(\"invalid option id %d\", specPtr->id);\n        return JSI_ERROR;\n    }\n\n    return JSI_OK;\n}\n\nJsi_Value *\nJsi_OptionsCustomPrint(void* clientData, Jsi_Interp *interp, const char *name, void *rec, int offset)\n{\n    char *record = (char*)rec;\n    Jsi_Value *valuePtr;\n    valuePtr = *(Jsi_Value **)(record + offset);\n    return valuePtr;\n}\n\n\nJsi_RC\nJsi_OptionsGet(Jsi_Interp *interp, Jsi_OptionSpec *specs, void *rec, const char *option, Jsi_Value** valuePtr, Jsi_Wide flags)\n{\n    char *record = (char*)rec;\n    Jsi_OptionSpec *specPtr;\n    const char *cp = NULL, *cb = NULL;\n    if (option) {\n        cp = Jsi_Strchr(option, '.');\n        cb = Jsi_Strchr(option, '[');\n    }\n    if (cp && (!cb || cp<cb) ) {\n        Jsi_DString dStr;\n        int len = (cp-option);\n        Jsi_DSInit(&dStr);\n        cp = Jsi_DSAppendLen(&dStr, option, len);\n        specPtr = Jsi_OptionsFind(interp, specs, cp, flags);\n        Jsi_DSFree(&dStr);\n        if (!specPtr || !specPtr->data || specPtr->id != JSI_OPTION_CUSTOM || specPtr->custom != Jsi_Opt_SwitchSuboption) \n            return Jsi_LogError(\"unknown or bad sub-config option: %s\", option);\n        cp = option+len+1;\n        return Jsi_OptionsGet(interp, (Jsi_OptionSpec *)(specPtr->data), (void*)(((char*)rec)+specPtr->offset), cp, valuePtr, flags);\n    }\n    if (cb && cb != option) {\n        char *ce = Jsi_Strchr(option, ']');\n        Jsi_Wide ul;\n        Jsi_DString dStr;\n        Jsi_DSInit(&dStr);\n        int len = 0;\n        if (ce && ce>cb) {\n            len = (ce-cb-1);\n            cp = Jsi_DSAppendLen(&dStr, cb+1, len);\n        }\n        if (len <= 0 || Jsi_GetWide(interp, cp, &ul, 0) != JSI_OK || ul<0) \n            return Jsi_LogError(\"bad sub-array option: %s\", option);\n        len = (cb-option);\n        Jsi_DSSetLength(&dStr, 0);\n        cp = Jsi_DSAppendLen(&dStr, option, len);\n        specPtr = Jsi_OptionsFind(interp, specs, cp, flags);\n        Jsi_DSFree(&dStr);\n        if (!specPtr || !specPtr->init.OPT_CARRAY|| specPtr->id != JSI_OPTION_CUSTOM || specPtr->custom != Jsi_Opt_SwitchCArray) {\nbail:\n            return Jsi_LogError(\"unknown or bad array option: %s\", option);\n        }\n        cp = cb+1;\n        Jsi_OptionSpec *subSpec = specPtr->init.OPT_CARRAY;\n        int isize, size = specPtr->arrSize;\n        if (!subSpec || size<=0 || (isize=subSpec->size)<=0)\n            goto bail;\n        isize = isize/size;\n        uchar *s = (((uchar*)rec)+specPtr->offset + isize*ul);\n        if (ce[1] != '.' || !subSpec->data) {\n            if (Jsi_OptionsGet(interp, subSpec, (void*)s, subSpec->name, valuePtr, flags) != JSI_OK)\n                return JSI_ERROR;\n        } else {\n            if (Jsi_OptionsGet(interp, (Jsi_OptionSpec *)subSpec->data, (void*)s, ce+2, valuePtr, flags) != JSI_OK)\n                return JSI_ERROR;\n        }\n        return JSI_OK;\n    }\n\n    specPtr = Jsi_OptionsFind(interp, specs, option, flags);\n    if (specPtr == NULL || jsi_GetOption(interp, specPtr, record, option, valuePtr, flags) != JSI_OK) {\n        return JSI_ERROR;\n    }\n\n    return JSI_OK;\n\n}\n\nJsi_RC\nJsi_OptionsDump(Jsi_Interp *interp, Jsi_OptionSpec *specs, void *rec, Jsi_Value **ret, Jsi_Wide flags)\n{\n    char *record = (char*)rec;\n    Jsi_OptionSpec *specPtr = specs;\n    int len = 0, i = 0, count = 0;\n    if (!Jsi_OptionsValid(interp, specs))\n        return Jsi_LogError(\"invalid options\");\n    \n    while (specPtr->id>=JSI_OPTION_BOOL && specPtr->id < JSI_OPTION_END && specPtr->name) {\n        specPtr++;\n        len+=2;\n    }\n    if (!len)\n        return JSI_OK;\n    Jsi_Value *rv = Jsi_ValueMakeObject(interp, NULL, NULL);\n    Jsi_IncrRefCount(interp, rv);\n    Jsi_Obj *obj = rv->d.obj;\n    specPtr = specs;\n    while (specPtr->id>=JSI_OPTION_BOOL && specPtr->id < JSI_OPTION_END && specPtr->name) {\n        Jsi_Value  *vv = Jsi_ValueNew1(interp);\n        if (jsi_GetOption(interp, specPtr, record, NULL, &vv, flags) != JSI_OK) {\n            Jsi_DecrRefCount(interp, vv);\n            Jsi_DecrRefCount(interp, rv);\n            return JSI_ERROR;\n        }\n        if (flags&JSI_OPTS_VERBOSE) {\n            // dump: id,value,help,info,init\n            Jsi_Value *vrv = Jsi_ValueMakeObject(interp, NULL, NULL);\n            Jsi_IncrRefCount(interp, vrv);\n            Jsi_Obj *vobj = vrv->d.obj;\n            Jsi_ObjInsert(interp, vobj, \"value\", vv, 0);\n            Jsi_DecrRefCount(interp, vv);\n            vv = vrv;\n            jsi_DumpOptionSpec(interp, vobj, specPtr, 0);\n        }\n        Jsi_ObjInsert(interp, obj, specPtr->name, vv, 0);\n        Jsi_DecrRefCount(interp, vv);\n        count++;\n        i++;\n        specPtr++;\n    }\n    assert(specPtr->id == JSI_OPTION_END);\n    Jsi_ValueReplace(interp, ret, rv);\n    Jsi_DecrRefCount(interp, rv);\n    return JSI_OK;\n}\n\nint\nJsi_OptionsProcess(Jsi_Interp *interp, Jsi_OptionSpec *specs,  void *rec, Jsi_Value *args, Jsi_Wide flags)\n{\n    Jsi_OptionSpec *specPtr;\n    int count = 0;\n    char *record = (char*)rec;\n    Jsi_TreeEntry *tPtr;\n    Jsi_TreeSearch search;\n    Jsi_Obj *to;\n    bool isSafe = interp->isSafe;\n    if (!Jsi_OptionsValid(interp, specs))\n        return -1;\n\n    if (interp->subOpts.compat && !(flags&JSI_OPTS_FORCE_STRICT))\n        flags |=  JSI_OPTS_IGNORE_EXTRA;\n    specs = jsi_GetCachedOptionSpecs(interp, specs);\n    \n    if (args == NULL || args->vt == JSI_VT_NULL) {\n        for (specPtr = specs; specPtr->id>=JSI_OPTION_BOOL && specPtr->id < JSI_OPTION_END && specPtr->name; specPtr++) {\n            specPtr->flags &= ~JSI_OPT_IS_SPECIFIED;\n            if (jsi_SetOption(interp, specPtr, (char*)specPtr->name, record, NULL, flags, isSafe) != JSI_OK)\n                return -1;\n        }\n        assert(specPtr->id == JSI_OPTION_END);\n        return 0;\n    }\n    if (args->vt != JSI_VT_OBJECT || args->d.obj->ot != JSI_OT_OBJECT || args->d.obj->arr) {\n        Jsi_LogError(\"expected object\");\n        return -1;\n    }\n    to = args->d.obj;\n    int reqCnt = 0;\n    if ((JSI_OPTS_IS_UPDATE&flags)==0 && !(JSI_OPT_PASS2&flags)) {\n        for (specPtr = specs; specPtr->id>=JSI_OPTION_BOOL && specPtr->id < JSI_OPTION_END && specPtr->name; specPtr++) {\n            specPtr->flags &= ~JSI_OPT_IS_SPECIFIED;\n            if (specPtr->flags &  JSI_OPT_REQUIRED)\n                reqCnt++;\n        }\n        assert(specPtr->id == JSI_OPTION_END);\n    }\n        \n    for (tPtr = Jsi_TreeSearchFirst(to->tree, &search, 0, NULL);\n        tPtr != NULL; tPtr = Jsi_TreeSearchNext(&search)) {\n        \n        const char *arg;\n        Jsi_Value *optval;\n        count++;\n        arg =(char*) Jsi_TreeKeyGet(tPtr);\n        optval = (Jsi_Value*)Jsi_TreeValueGet(tPtr);\n\n        specPtr = Jsi_OptionsFind(interp, specs, arg, flags);\n        if (specPtr == NULL) {\n            if (flags&JSI_OPTS_IGNORE_EXTRA)\n                continue;\n            count = -1;\n            goto done;\n        }\n        if (((JSI_OPT_PASS2&flags) && !(JSI_OPT_PASS2&specPtr->flags))\n            || ((JSI_OPT_PASS2&specPtr->flags) && !(JSI_OPT_PASS2&flags)))\n            continue;\n            \n        if ((JSI_OPT_READ_ONLY&specPtr->flags)) {\n            Jsi_LogError(\"Error option is readonly: \\\"%.40s\\\"\", specPtr->name);\n            count = -1;\n            goto done;\n        }\n        if ((JSI_OPTS_IS_UPDATE&flags) && (JSI_OPT_INIT_ONLY&specPtr->flags)) {\n            Jsi_LogError(\"Error can not update option: \\\"%.40s\\\"\", specPtr->name);\n            count = -1;\n            goto done;\n        }\n        if (isSafe && (JSI_OPTS_IS_UPDATE&flags) && (JSI_OPT_LOCKSAFE&specPtr->flags)) {\n            Jsi_LogError(\"Error isSafe disallows updating option: \\\"%.40s\\\"\", specPtr->name);\n            count = -1;\n            goto done;\n        }\n\n        if (jsi_SetOption(interp, specPtr, (char*)arg, record, optval, flags, isSafe) != JSI_OK) {\n            count = -1;\n            goto done;\n        }\n \n        specPtr->flags |= JSI_OPT_IS_SPECIFIED;\n    }\n    if (reqCnt) {\n        for (specPtr = specs; specPtr->id>=JSI_OPTION_BOOL && specPtr->id < JSI_OPTION_END && specPtr->name; specPtr++) {\n            if (specPtr->flags &  JSI_OPT_REQUIRED &&\n                !(specPtr->flags&JSI_OPT_IS_SPECIFIED)) {\n\n                Jsi_LogError(\"Error required field not specified: \\\"%.40s\\\"\", specPtr->name);\n                count = -1;\n            }\n        }\n    }\n\ndone:\n    Jsi_TreeSearchDone(&search);\n    if (count<0 && !(JSI_OPTS_IS_UPDATE&flags))\n        Jsi_OptionsFree(interp, specs, rec, flags);\n    return count;\n}\n\nJsi_RC\nJsi_OptionsConf(Jsi_Interp *interp, Jsi_OptionSpec *specs,  void *rec, Jsi_Value *val, Jsi_Value **ret, Jsi_Wide flags)\n{\n    flags |= JSI_OPTS_IS_UPDATE;\n    if (!Jsi_OptionsValid(interp, specs))\n        return Jsi_LogError(\"invalid options\");\n    \n    if (!val)\n        return Jsi_OptionsDump(interp, specs, rec, ret, flags);\n    if (val->vt == JSI_VT_NULL)\n        return Jsi_OptionsDump(interp, specs, rec, ret, flags|JSI_OPTS_VERBOSE);\n    if (Jsi_ValueIsString(interp, val)) {\n        const char *cp = Jsi_ValueString(interp, val, NULL);\n        if (cp && *cp)\n            return Jsi_OptionsGet(interp, specs, rec, cp, ret, flags);\n        Jsi_Obj *sobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n        Jsi_Value *svalue = Jsi_ValueMakeObject(interp, NULL, sobj);\n        jsi_DumpOptionSpecs(interp, sobj, specs);\n        Jsi_ValueReplace(interp, ret, svalue);\n        return JSI_OK;\n    }\n    if (val->vt != JSI_VT_OBJECT) \n        return Jsi_LogError(\"expected string, object, or null\");\n    if (Jsi_OptionsProcess(interp, specs, rec, val, JSI_OPTS_IS_UPDATE|flags) < 0)\n        return JSI_ERROR;\n    return JSI_OK;\n}\n\nstatic const char **jsi_OptGetEnumList(Jsi_OptionSpec* spec) {\n    const char **list = (const char**)spec->data;\n    Jsi_OptionSpec* es=NULL;\n    int fflags = (spec->flags);\n    if (spec->id != JSI_OPTION_CUSTOM || spec->custom != Jsi_Opt_SwitchEnum)\n        return list;\n    if (list && (fflags & JSI_OPT_ENUM_SPEC)) {\n        es = (typeof(es))list;\n        while (es->id != JSI_OPTION_END)\n            es++;\n        list = es->init.STRKEY;\n    }\n    return list;\n}\n\nstatic void jsi_DumpCustomSpec(Jsi_Interp *interp, Jsi_Obj *nobj, Jsi_OptionSpec* spec)\n{\n    Jsi_OptionCustom* cspec = Jsi_OptionCustomBuiltin(spec->custom);\n    void *data = spec->data;\n    if (cspec->help) {\n        if (Jsi_Strchr(cspec->help, '\\n'))\n            Jsi_LogError(\"%s .help contains newline: %s\", cspec->name, cspec->help);\n        Jsi_ObjInsert(interp, nobj, \"help\", Jsi_ValueNewStringKey(interp, cspec->help),0);\n    }\n    if (cspec->info)\n        Jsi_ObjInsert(interp, nobj, \"info\", Jsi_ValueNewStringKey(interp, cspec->info),0);\n    Jsi_ObjInsert(interp, nobj, \"name\", Jsi_ValueNewStringKey(interp, cspec->name),0);\n\n    if (data && (spec->custom == Jsi_Opt_SwitchEnum || spec->custom == Jsi_Opt_SwitchBitset)) {\n        Jsi_Obj *sobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n        Jsi_Value *svalue = Jsi_ValueMakeObject(interp, NULL, sobj);\n        const char **lst = jsi_OptGetEnumList(spec);\n        int i = 0;\n        while (lst[i]) {\n            Jsi_ObjArrayAdd(interp, sobj, Jsi_ValueNewStringKey(interp, lst[i]));\n            i++;\n        }\n        Jsi_ObjInsert(interp, nobj, (spec->custom == Jsi_Opt_SwitchBitset?\"bitSet\":\"enumList\"), svalue, 0);\n    } else if (spec->custom == Jsi_Opt_SwitchSuboption) {\n        Jsi_OptionSpec* subSpec = (Jsi_OptionSpec*)data;\n        Jsi_Obj *sobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n        Jsi_Value *svalue = Jsi_ValueMakeObject(interp, NULL, sobj);\n        jsi_DumpOptionSpecs(interp, sobj, subSpec);\n        Jsi_ObjInsert(interp, nobj, \"subSpec\", svalue, 0);\n    }\n}\n\nstatic void jsi_DumpOptionSpec(Jsi_Interp *interp, Jsi_Obj *nobj, Jsi_OptionSpec* spec, int addName)\n{\n    if (addName)\n        Jsi_ObjInsert(interp, nobj, \"name\", Jsi_ValueNewStringKey(interp, spec->name),0);\n    if (spec->help) {\n        if (Jsi_Strchr(spec->help, '\\n'))\n            Jsi_LogError(\"%s .help contains newline: %s\", spec->name, spec->help);\n        Jsi_ObjInsert(interp, nobj, \"help\", Jsi_ValueNewStringKey(interp, spec->help),0);\n    }\n    if (spec->info)\n        Jsi_ObjInsert(interp, nobj, \"info\", Jsi_ValueNewStringKey(interp, spec->info),0);\n    Jsi_ObjInsert(interp, nobj, \"type\", Jsi_ValueNewStringKey(interp, jsi_OptionTypeStr(spec->id,0)),0);\n    Jsi_ObjInsert(interp, nobj, \"cName\", Jsi_ValueNewStringKey(interp, jsi_OptionTypeStr(spec->id,1)),0);\n    Jsi_ObjInsert(interp, nobj, \"initOnly\", Jsi_ValueNewBoolean(interp, (spec->flags & JSI_OPT_INIT_ONLY)!=0), 0);\n    Jsi_ObjInsert(interp, nobj, \"readOnly\", Jsi_ValueNewBoolean(interp, (spec->flags & JSI_OPT_READ_ONLY)!=0), 0);\n    Jsi_ObjInsert(interp, nobj, \"required\", Jsi_ValueNewBoolean(interp, (spec->flags & JSI_OPT_REQUIRED)!=0), 0);\n    Jsi_ObjInsert(interp, nobj, \"noCase\", Jsi_ValueNewBoolean(interp, (spec->flags & JSI_OPT_CUST_NOCASE)!=0), 0);\n    Jsi_ObjInsert(interp, nobj, \"size\", Jsi_ValueNewNumber(interp, (Jsi_Number)spec->size), 0);\n    if (spec->flags)\n        Jsi_ObjInsert(interp, nobj, \"flags\", Jsi_ValueNewNumber(interp, (Jsi_Number)spec->flags), 0);\n    if (spec->data) {\n        if (spec->id == JSI_OPTION_FUNC && spec->data) \n            Jsi_ObjInsert(interp, nobj, \"args\", Jsi_ValueNewStringDup(interp, (char*)spec->data), 0);\n        else if (spec->id == JSI_OPTION_CUSTOM && (spec->custom == Jsi_Opt_SwitchBitset ||\n            spec->custom == Jsi_Opt_SwitchEnum)) {\n            const char **list = jsi_OptGetEnumList(spec);\n            if (list)\n                Jsi_ObjInsert(interp, nobj, \"data\", Jsi_ValueNewArray(interp, list, -1), 0);\n        }\n    }\n    if (spec->id == JSI_OPTION_CUSTOM && spec->custom) {\n        Jsi_Obj *sobj = Jsi_ObjNewType(interp, JSI_OT_OBJECT);\n        Jsi_Value *cvalue = Jsi_ValueMakeObject(interp, NULL, sobj);\n        jsi_DumpCustomSpec(interp, sobj,  spec);\n        Jsi_ObjInsert(interp, nobj, \"customArg\", cvalue,0);\n        Jsi_OptionSpec *os = spec;\n        while (os->id != JSI_OPTION_END) os++;\n        Jsi_ObjInsert(interp, nobj, \"customArgHelp\", Jsi_ValueNewStringKey(interp, (os->help?os->help:\"\")), 0);\n        \n    }\n}\n\nvoid jsi_DumpOptionSpecs(Jsi_Interp *interp, Jsi_Obj *nobj, Jsi_OptionSpec* spec)\n{\n    int i = 0;\n    while (spec[i].id>=JSI_OPTION_BOOL && spec[i].id < JSI_OPTION_END) {\n        Jsi_Obj *sobj = Jsi_ObjNewType(interp, JSI_OT_OBJECT);\n        Jsi_Value *svalue = Jsi_ValueMakeObject(interp, NULL, sobj);\n        jsi_DumpOptionSpec(interp, sobj, spec+i, 1);\n        Jsi_ObjArrayAdd(interp, nobj, svalue);\n        i++;\n    }\n}\n\nstatic Jsi_RC jsi_ValueToVerify(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value *inValue, const char *inStr, void *record, Jsi_Wide flags)\n{\n    if (inStr)\n        return JSI_ERROR;\n    Jsi_Value **s = (Jsi_Value**)((char*)record) + spec->offset;\n    Jsi_ValueHandlerProc *vfunc = (Jsi_ValueHandlerProc*)spec->data;\n    if (!vfunc) \n        return Jsi_LogError(\"custom value spec did not set data: %s\", spec->name);\n    if (!inValue) {\n        if (*s)\n            Jsi_DecrRefCount(interp, *s);\n        *s = NULL;\n        return JSI_OK;\n    }\n    if (vfunc(interp, inValue, spec, record) != JSI_OK)\n        return JSI_ERROR;\n    *s = inValue;\n    if (*s)\n        Jsi_IncrRefCount(interp, *s);\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_VerifyToValue(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value **outValue, Jsi_DString *dStr, void *record, Jsi_Wide flags)\n{\n    if (dStr)\n        return JSI_ERROR;\n    Jsi_Value **s = (Jsi_Value**)(((char*)record) + spec->offset);\n    if (*s)\n        Jsi_ValueReplace(interp, outValue, *s);\n    return JSI_OK;\n}\n\nstatic void jsi_VerifyFree(Jsi_Interp *interp, Jsi_OptionSpec* spec, void *ptr)\n{\n    Jsi_Value **v = (Jsi_Value**)ptr;\n    if (v && *v)\n        Jsi_DecrRefCount(interp, *v);\n}\n\nstatic Jsi_OptionCustom jsi_OptSwitchValueVerify = {\n    .name=\"verify\", .parseProc=jsi_ValueToVerify, .formatProc=jsi_VerifyToValue, .freeProc=jsi_VerifyFree, .help=\"Verify that a value id is correct\"\n};\n\n\nstatic Jsi_RC ValueToCArray(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value *inValue, const char *inStr, void *record, Jsi_Wide flags)\n{\n    if (inStr)\n        return JSI_ERROR;\n    uchar *s = (uchar*)((char*)record) + spec->offset;\n    Jsi_OptionSpec *subSpec = spec->init.OPT_CARRAY;\n    int argc, i, isize, size = spec->arrSize;\n    if (!subSpec || size<=0 || (isize=subSpec->size)<=0)\n        goto bail;\n    isize = isize/size;\n    if (!Jsi_ValueIsArray(interp, inValue)) \n        return Jsi_LogError(\"expected array\");\n    argc = Jsi_ValueGetLength(interp, inValue);\n    if (argc != size) \n        return Jsi_LogError(\"array length %d was not %d\", argc, size);\n    for (i = 0; i<size; i++) {\n        Jsi_Value *v = Jsi_ValueArrayIndex(interp, inValue, i);\n        if (Jsi_OptionsSet(interp, subSpec, (void*)s, subSpec->name, v, 0) != JSI_OK)\n            return JSI_ERROR;\n        s += isize;\n    }\n    return JSI_OK;\nbail:\n    return Jsi_LogError(\"bad config\");\n}\n\nstatic Jsi_RC jsi_CArrayToValue(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value **outValue, Jsi_DString *dStr, void *record, Jsi_Wide flags)\n{\n    Jsi_Obj *obj = NULL;\n    if (dStr)\n        return JSI_ERROR;\n    uchar *s = (uchar*)((char*)record) + spec->offset;\n    Jsi_OptionSpec *subSpec = spec->init.OPT_CARRAY;\n    int i, cnt, isize, size = spec->arrSize;\n    if (!subSpec || size<=0 || (isize=subSpec->size)<=0)\n        goto bail;\n    isize = isize/size;\n#ifndef JSI_LITE_ONLY //TODO: already in lite #ifdef\n    obj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    cnt = 0;\n    for (i=0; i<size; i++) {\n        Jsi_Value *v = Jsi_ValueNew1(interp);\n        cnt++;\n        Jsi_RC rc = Jsi_OptionsGet(interp, subSpec, s, spec->name, &v, 0);\n        Jsi_ObjArrayAdd(interp, obj, v);\n        Jsi_DecrRefCount(interp, v);\n        if (JSI_OK != rc)\n            goto bail;\n        s += isize;\n    }\n    Jsi_ValueMakeArrayObject(interp, outValue, obj);\n#endif\n    return JSI_OK;\nbail:\n    if (obj)\n        Jsi_ObjFree(interp, obj);\n    Jsi_LogError(\"bad config\");\n    return JSI_ERROR;\n}\n\nstatic void jsi_CArrayFree(Jsi_Interp *interp, Jsi_OptionSpec* spec, void *ptr)\n{\n    /*Jsi_OptionSpec *subSpec = spec->init.ini.OPT_CARRAY; // TODO: ???\n    if (!subSpec) {\n        Jsi_Value **v = (Jsi_Value**)ptr;\n        if (v)\n            Jsi_DecrRefCount(interp, *v);\n    }\n    int i, isize, size = spec->asize;\n    if ((isize=subSpec->size)<=0)\n        return;\n    isize = isize/size;\n    uchar *s = (uchar*)ptr;\n    for (i=0; i<size; i++) {\n        Jsi_OptionsFree(interp, subSpec, s, 0);\n        s += isize;\n    }*/\n}\n\nstatic Jsi_OptionCustom jsi_OptSwitchCArray = {\n    .name=\"array\", .parseProc=ValueToCArray, .formatProc=jsi_CArrayToValue, .freeProc=jsi_CArrayFree, .help=\"Array of OPT types\"\n};\n#else\n\nstatic Jsi_OptionSpec * jsi_GetCachedOptionSpecs(Jsi_Interp *interp, const Jsi_OptionSpec *staticSpecs)\n{\n    return (Jsi_OptionSpec *)staticSpecs;\n}\n\n#endif\n\n\n/*\n *----------------------------------------------------------------------\n * Given the configuration specifications and one or more option\n * patterns (terminated by a NULL), indicate if any of the matching\n * configuration options has been reset.\n *\n * Results:\n *      Returns count of each options that has changed, 0 otherwise.\n *\n *----------------------------------------------------------------------\n */\nint Jsi_OptionsChanged(Jsi_Interp *interp, Jsi_OptionSpec *spec, const char *pattern, ...)\n{\n    va_list argList;\n    Jsi_OptionSpec *specPtr;\n    const char *option = pattern;\n    int cnt = 0;\n    \n    va_start(argList, pattern);\n    spec = jsi_GetCachedOptionSpecs(interp, spec);\n    do  {\n        for (specPtr = spec; specPtr->id>=JSI_OPTION_BOOL && specPtr->id < JSI_OPTION_END; specPtr++) {\n            if ((Jsi_GlobMatch(option, specPtr->name, 0)) &&\n                    (specPtr->flags & JSI_OPT_IS_SPECIFIED)) {\n                cnt++;\n            }\n        }\n        assert(specPtr->id == JSI_OPTION_END);\n\n    } while ((option = va_arg(argList, char *)) != NULL);\n    va_end(argList);\n    return cnt;\n}\n\nJsi_OptionSpec *\nJsi_OptionsDup(Jsi_Interp *interp, const Jsi_OptionSpec *staticSpecs)\n{\n    unsigned int entrySpace = sizeof(Jsi_OptionSpec);\n    const Jsi_OptionSpec *staticSpecPtr;\n    Jsi_OptionSpec *newSpecs;\n\n    for (staticSpecPtr=staticSpecs; staticSpecPtr->id>=JSI_OPTION_BOOL && staticSpecPtr->id<JSI_OPTION_END && staticSpecPtr->name;\n            staticSpecPtr++) {\n        entrySpace += sizeof(Jsi_OptionSpec);\n    }\n\n    newSpecs = (Jsi_OptionSpec *) Jsi_Malloc(entrySpace);\n    memcpy((void *) newSpecs, (void *) staticSpecs, entrySpace);\n    return newSpecs;\n}\n\n/* Free data items and reset values back to 0. */\nvoid\nJsi_OptionsFree(Jsi_Interp *interp, Jsi_OptionSpec *specs, void *rec, Jsi_Wide flags /*unused*/)\n{\n    Jsi_OptionSpec *specPtr;\n    char *record = (char*)rec;\n    for (specPtr = specs; specPtr->id>=JSI_OPTION_BOOL && specPtr->id < JSI_OPTION_END && specPtr->name; specPtr++) {\n        char *ptr = record + specPtr->offset;\n        if (specPtr->flags&JSI_OPT_NO_CLEAR)\n            continue;\n        if (specPtr->custom) {\n            Jsi_OptionCustom* cust = Jsi_OptionCustomBuiltin(specPtr->custom);\n            if (cust->freeProc != NULL) {\n                (*cust->freeProc)(interp, specPtr, (char **)ptr);\n                continue;\n            }\n        }\n\n        switch (specPtr->id) {\n#ifndef JSI_LITE_ONLY\n        case JSI_OPTION_VALUE:\n        case JSI_OPTION_STRING:\n        case JSI_OPTION_OBJ:\n        case JSI_OPTION_REGEXP:\n        case JSI_OPTION_ARRAY:\n        case JSI_OPTION_FUNC:\n        case JSI_OPTION_USEROBJ:\n        case JSI_OPTION_VAR:\n        {\n            Jsi_Value **vpp = (Jsi_Value**)ptr, *vPtr = *vpp;\n            if (vPtr && (!(specPtr->flags&JSI_OPT_NO_DUPVALUE)))\n                Jsi_DecrRefCount(interp, vPtr);\n            *vpp = 0;\n            break;\n        }\n#endif\n        case JSI_OPTION_STRKEY:\n            *(char**)ptr = 0;\n            break;\n        case JSI_OPTION_STRBUF:\n            *(char*)ptr = 0;\n            break;\n        case JSI_OPTION_DSTRING:\n            Jsi_DSFree((Jsi_DString *)ptr);\n            break;\n        case JSI_OPTION_TIME_T:\n            *(time_t*)ptr = 0;\n            break;\n        case JSI_OPTION_NUMBER:\n            *(Jsi_Number*)ptr = 0;\n            break;\n        case JSI_OPTION_FLOAT:\n            *(float*)ptr = 0;\n            break;\n        case JSI_OPTION_LDOUBLE:\n            *(ldouble*)ptr = 0;\n            break;\n        case JSI_OPTION_DOUBLE:\n        case JSI_OPTION_TIME_D:\n            *(double*)ptr = 0;\n            break;\n        case JSI_OPTION_TIME_W:\n            *(Jsi_Wide*)ptr = 0;\n            break;\n        case JSI_OPTION_INT8:  *(int8_t*)ptr = 0; break;\n        case JSI_OPTION_INT16: *(int16_t*)ptr = 0; break;\n        case JSI_OPTION_INT32: *(int32_t*)ptr = 0; break;\n        case JSI_OPTION_INT64: *(int64_t*)ptr = 0; break;\n        case JSI_OPTION_UINT8: *(uint8_t*)ptr = 0; break;\n        case JSI_OPTION_UINT16:*(uint16_t*)ptr = 0; break;\n        case JSI_OPTION_UINT32:*(uint32_t*)ptr = 0; break;\n        case JSI_OPTION_UINT64:*(uint64_t*)ptr = 0; break;\n        case JSI_OPTION_INT: *(int*)ptr = 0; break;\n        case JSI_OPTION_UINT: *(uint*)ptr = 0; break;\n        case JSI_OPTION_BOOL: *(bool*)ptr = 0; break;\n        case JSI_OPTION_CUSTOM:\n            break;\n        default:\n            if (specPtr->size>0)\n                memset(ptr, 0, specPtr->size);\n            break;\n        }\n    }\n}\n\nstatic Jsi_RC jsi_ValueToEnum(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value *inValue, const char *inStr, void *record, Jsi_Wide flags)\n{\n    int n = 0;\n    char *s = (char*)(((char*)record) + spec->offset);\n    const char **list = (const char **)spec->data;\n    Jsi_OptionSpec* es=NULL;\n    int fflags = (flags|spec->flags);\n    int cflags = (fflags&JSI_OPT_CUST_NOCASE?JSI_CMP_NOCASE:0);\n    if (fflags&JSI_OPT_ENUM_EXACT)\n        cflags |= JSI_CMP_EXACT;\n    if (list && (fflags & JSI_OPT_ENUM_SPEC)) {\n        es = (typeof(es))list;\n        while (es->id != JSI_OPTION_END) es++;\n        list = es->init.STRKEY;\n        es = (typeof(es))spec->data;\n    }\n    if (!list) \n        return Jsi_LogError(\"custom enum spec did not set data: %s\", spec->name);\n    if (inStr) {\n        if (JSI_OK != Jsi_GetIndex(interp, (char*)inStr, list, \"enum\", cflags, &n))\n            return JSI_ERROR;\n    } else\n#ifndef JSI_LITE_ONLY\n    if (JSI_OK != Jsi_ValueGetIndex(interp, inValue, list, \"enum\", cflags, &n))\n        return JSI_ERROR;\n\n#endif\n    if (fflags&JSI_OPT_ENUM_UNSIGNED) {\n        uint64_t u = (uint64_t)n;\n        if (es)\n            u = es[n].value;\n        switch (spec->size) {\n            case 1: *(uint8_t*)s = (uint8_t)u; break;\n            case 2: *(uint16_t*)s = (uint16_t)u; break;\n            case 4: *(uint32_t*)s = (uint32_t)u; break;\n            case 8: *(uint64_t*)s = (uint64_t)u; break;\n            default:\n                return Jsi_LogError(\"enum size must be 1, 2, 4, or 8: %s\", spec->name);\n        }\n    } else {\n        int64_t m = n;\n        if (es)\n            m = es[n].value;\n        switch (spec->size) {\n            case 1: *(int8_t*)s = (int8_t)m; break;\n            case 2: *(int16_t*)s = (int16_t)m; break;\n            case 4: *(int32_t*)s = (int32_t)m; break;\n            case 8: *(int64_t*)s = (int64_t)m; break;\n            default: \n                return Jsi_LogError(\"enum size must be 1, 2, 4, or 8: %s\", spec->name);\n        }\n    }\n    \n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_EnumToValue(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value **outValue, Jsi_DString *outStr, void *record, Jsi_Wide flags)\n{\n    uint i = 0, j, esiz = 0;\n    int64_t n;\n    char *s = (char*)(((char*)record) + spec->offset);\n    const char **list = (const char**)spec->data;\n    Jsi_OptionSpec* es=NULL, *esp = NULL;\n    int fflags = (flags|spec->flags);\n    int uflag = (fflags&JSI_OPT_ENUM_UNSIGNED);\n    if (list && (fflags & JSI_OPT_ENUM_SPEC)) {\n        esp = es = (typeof(es))list;\n        while (es->id != JSI_OPTION_END) es++;\n        list = es->init.STRKEY;\n        esiz = es->size;\n        es = (typeof(es))spec->data;\n    }\n    if (!list) \n        return Jsi_LogError(\"custom enum spec did not set data: %s\", spec->name);\n    if (outStr) {\n        if (uflag) {\n            switch (spec->size) {\n                case 1: n = *(uint8_t*)s; break;\n                case 2: n = *(uint16_t*)s; break;\n                case 4: n = *(uint32_t*)s; break;\n                case 8: n = *(uint64_t*)s; break;\n                default: \n                    return Jsi_LogError(\"enum size %d must be 1, 2, 4, or 8: %s\", spec->size, spec->name);\n            }\n        } else {\n            switch (spec->size) {\n                case 1: n = *(int8_t*)s; break;\n                case 2: n = *(int16_t*)s; break;\n                case 4: n = *(int32_t*)s; break;\n                case 8: n = *(int64_t*)s; break;\n                default: \n                    return Jsi_LogError(\"enum size %d must be 1, 2, 4, or 8: %s\", spec->size, spec->name);\n            }\n        }\n        if (spec->flags&JSI_OPT_FMT_NUMBER) {\n            Jsi_DSPrintf(outStr, \"%\" PRIu64, (uint64_t)n);\n            return JSI_OK;\n        }\n        \n        if (es) {\n            for (j=0; j<esiz && list[j]; j++) {\n                if (n == esp[j].value) {\n                    i = j;\n                    break;\n                }\n                if (j>=esiz)\n                    i = esiz;\n            }\n        } else\n            for (i=0; i<n && list[i]; i++) ; /* Look forward til n */\n        if (list[i])\n            Jsi_DSAppendLen(outStr, list[i], -1);\n        else if ((spec->flags&JSI_OPT_COERCE)) {\n            Jsi_DSPrintf(outStr, \"%\" PRIu64, (uint64_t)n);\n            return JSI_OK;\n        } else\n            return Jsi_LogError(\"enum has unknown value: %d\", *s);\n        return JSI_OK;\n    }\n#ifndef JSI_LITE_ONLY\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    Jsi_RC rc = jsi_EnumToValue(interp, spec, NULL, &dStr, record, flags);\n    if (rc == JSI_OK)\n        Jsi_ValueMakeStringKey(interp, outValue, Jsi_DSValue(&dStr));\n    Jsi_DSFree(&dStr);\n    return rc;\n#endif\n    return JSI_ERROR;\n}\n\nstatic Jsi_OptionCustom jsi_OptSwitchEnum = {\n    .name=\"enum\", .parseProc=jsi_ValueToEnum, .formatProc=jsi_EnumToValue, .freeProc=0, .help=\"one value from list\"\n};\n\n\nstatic Jsi_RC jsi_ValueToBitset(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value *inValue, const char *inStr, void *record, Jsi_Wide flags)\n{\n    // TODO: change this to not use byte instead of int...\n    int i, argc, n;\n    char *s =(((char*)record) + spec->offset);\n    char **argv;\n    const char *cp, **list = (const char**)spec->data;\n    uint64_t m = 0, im = 0;\n    int fflags = ((flags|spec->flags)&JSI_OPT_CUST_NOCASE?JSI_CMP_NOCASE:0);\n    if (!list) \n        return Jsi_LogError(\"custom enum spec did not set data: %s\", spec->name);\n    switch (spec->size) {\n        case 1: im = *(uint8_t*)s; break;\n        case 2: im = *(uint16_t*)s; break;\n        case 4: im = *(uint32_t*)s; break;\n        case 8: im = *(uint64_t*)s; break;\n        default: \n            return Jsi_LogError(\"bitset size must be 1, 2, 4, or 8: %s\", spec->name);\n    }\n\n#ifndef JSI_LITE_ONLY\n    if (!inStr && Jsi_ValueIsString(interp, inValue))\n        inStr = Jsi_ValueString(interp, inValue, NULL);\n#endif\n    if (inStr) {\n        if (*inStr == '+') {\n            inStr++;\n            m = im;\n        }\n        if (*inStr) {\n            Jsi_DString sStr;\n            Jsi_DSInit(&sStr);\n            Jsi_SplitStr(inStr, &argc, &argv, \",\", &sStr);\n            \n            for (i=0; i<argc; i++) {\n                int isnot = 0;\n                cp = argv[i];\n                if (*cp == '!') { isnot = 1; cp++; }\n                if (JSI_OK != Jsi_GetIndex(interp, cp, list, \"enum\", fflags, &n))\n                    return JSI_ERROR;\n                if (n >= (int)(spec->size*8)) \n                    return Jsi_LogError(\"list larger than field size: %s\", spec->name);\n                if (isnot)\n                    m &= ~(1<<n);\n                else\n                    m |= (1<<n);\n            }\n            Jsi_DSFree(&sStr);\n        }\n    } else {\n#ifndef JSI_LITE_ONLY\n        if (!inValue) {\n            *s = 0;\n            return JSI_OK;\n        }\n        if (Jsi_ValueIsObjType(interp, inValue, JSI_OT_OBJECT) && !Jsi_ValueIsArray(interp, inValue)) {\n            Jsi_TreeEntry *tPtr;\n            Jsi_TreeSearch search;\n            Jsi_Tree *tp = Jsi_TreeFromValue(interp, inValue);\n            \n            m = im;\n            for (tPtr = (tp?Jsi_TreeSearchFirst(tp, &search, 0, NULL):NULL);\n                tPtr != NULL; tPtr = Jsi_TreeSearchNext(&search)) {\n                cp =(char*) Jsi_TreeKeyGet(tPtr);\n                Jsi_Value *optval = (Jsi_Value*)Jsi_TreeValueGet(tPtr);\n                \n                if (JSI_OK != Jsi_GetIndex(interp, cp, list, \"bitset\", fflags, &n)) {\n                    Jsi_TreeSearchDone(&search);\n                    return JSI_ERROR;\n                }\n                if (!Jsi_ValueIsBoolean(interp, optval)) {\n                    Jsi_TreeSearchDone(&search);\n                    return Jsi_LogError(\"object member is not a bool: %s\", cp);\n                }\n                bool vb;\n                Jsi_ValueGetBoolean(interp, optval, &vb);\n                if (!vb)\n                    m &= ~(1<<n);\n                else\n                    m |= (1<<n);\n            }\n            if (tp)\n                Jsi_TreeSearchDone(&search);\n            *s = m;\n            return JSI_OK;\n        }\n        \n        if (!Jsi_ValueIsArray(interp, inValue)) \n            return Jsi_LogError(\"expected array or object\");\n        argc = Jsi_ValueGetLength(interp, inValue);\n        for (i=0; i<argc; i++) {\n            int isnot = 0;\n            Jsi_Value *v = Jsi_ValueArrayIndex(interp, inValue, i);\n            const char *cp = (v?Jsi_ValueString(interp, v, NULL):\"\");\n            if (!cp) \n                return Jsi_LogError(\"expected string\");\n            if (i == 0) {\n                if (*cp == '+' && !cp[1]) {\n                    m = im;\n                    continue;\n                }\n            }\n            if (*cp == '!') { isnot = 1; cp++; }\n            if (JSI_OK != Jsi_GetIndex(interp, cp, list, \"bitset\", fflags, &n))\n                return JSI_ERROR;\n            if (isnot)\n                m &= ~(1<<n);\n            else\n                m |= (1<<n);\n        }\n        *s = m;\n#endif\n    }\n    switch (spec->size) {\n        case 1: *(uint8_t*)s = (uint8_t)m; break;\n        case 2: *(uint16_t*)s = (uint16_t)m; break;\n        case 4: *(uint32_t*)s = (uint32_t)m; break;\n        case 8: *(uint64_t*)s = (uint64_t)m; break;\n    }\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_BitsetToValue(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value **outValue, Jsi_DString *outStr, void *record, Jsi_Wide flags)\n{\n    int i, n, cnt = 0, *s = (int*)(((char*)record) + spec->offset);\n    const char **list = (const char**)spec->data;\n    if (!list) \n        return Jsi_LogError(\"custom enum spec did not set data: %s\", spec->name);\n    if (outStr) {\n        n = *s;\n        for (i=0; list[i]; i++) {\n            if (i >= (int)(spec->size*8)) \n                return Jsi_LogError(\"list larger than field size: %s\", spec->name);\n            if (!(n & (1<<i)))\n                continue;\n            if (cnt++)\n                Jsi_DSAppendLen(outStr, \", \", 1);\n            Jsi_DSAppendLen(outStr, list[i], -1);\n        }\n        return JSI_OK;\n    }\n#ifndef JSI_LITE_ONLY\n    Jsi_Obj *obj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    n = *s;\n    for (i=0; list[i]; i++) {\n        Jsi_Value *v;\n        if (!(n&(1<<i))) continue;\n        cnt++;\n        v = Jsi_ValueMakeStringKey(interp, NULL, list[i]);\n        Jsi_ObjArrayAdd(interp, obj, v);\n    }\n    Jsi_ValueMakeArrayObject(interp, outValue, obj);\n#endif\n    return JSI_OK;\n}\n\nstatic Jsi_OptionCustom jsi_OptSwitchBitset = {\n    .name=\"bitset\", .parseProc=jsi_ValueToBitset, .formatProc=jsi_BitsetToValue, .freeProc=0, .help=\"An int field accessed a bit at a time\"\n};\n\n#ifndef JSI_LITE_ONLY\n/* Scanning function */\nstatic Jsi_RC jsi_ValueToSubopt(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value *inValue, const char *inStr, void *record, Jsi_Wide flags)\n{\n    if (inStr)\n        return JSI_ERROR;\n    char *s = ((char*)record) + spec->offset;\n    Jsi_OptionSpec *subspec = (Jsi_OptionSpec *)spec->data;\n  \n    if (spec == subspec) \n        return Jsi_LogError(\"subspec was recursive\");\n    if (!subspec) \n        return Jsi_LogError(\"custom suboption spec did not set data: %s\", spec->name);\n    if (inValue && Jsi_ValueIsNull(interp, inValue) == 0 &&\n        (Jsi_ValueIsObjType(interp, inValue, JSI_OT_OBJECT)==0 || inValue->d.obj->isarrlist)) \n        return Jsi_LogError(\"expected object\");\n    return (Jsi_OptionsProcess(interp, subspec, s, inValue, flags)<0 ? JSI_ERROR : JSI_OK);\n}\n\n/* Printing function. */\nstatic Jsi_RC jsi_SuboptToValue(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value **outValue, Jsi_DString *outStr, void *record, Jsi_Wide flags)\n{\n    if (outStr)\n        return JSI_ERROR;\n    char *s = ((char*)record) + spec->offset;\n    Jsi_OptionSpec *subspec = (Jsi_OptionSpec *)spec->data;\n    if (spec == subspec) \n        return Jsi_LogError(\"recursive subspec not allowed\");\n    if (!subspec) \n        return Jsi_LogError(\"custom suboption spec did not set data: %s\", spec->name);\n    return Jsi_OptionsDump(interp, subspec, s, outValue, flags);\n}\n\nstatic void jsi_SuboptFree(Jsi_Interp *interp, Jsi_OptionSpec* spec, void *ptr)\n{\n    Jsi_OptionSpec *subspec = (Jsi_OptionSpec *)spec->data;\n    Jsi_OptionsFree(interp, subspec, ptr, 0);\n}\n\nstatic Jsi_OptionCustom jsi_OptSwitchSuboption = {\n    .name=\"suboption\", .parseProc=jsi_ValueToSubopt, .formatProc=jsi_SuboptToValue, .freeProc=jsi_SuboptFree,\n};\n\n/* Parent Function: Scanning function */\nstatic Jsi_RC jsi_ValueToParentFunc(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value *inValue, const char *inStr, void *record, Jsi_Wide flags)\n{\n    if (inStr)\n        return JSI_ERROR;\n    Jsi_Value *val;\n    Jsi_Value **v = (Jsi_Value **)(((char*)record) + spec->offset);\n    const char *s, *subspec = (const char *)spec->data;\n    Jsi_Interp *pinterp = interp->parent;\n    if (!pinterp)\n        return Jsi_LogError(\"no parent interp\");\n    if (!subspec) \n        return Jsi_LogError(\"custom parentfunc spec did not set data: %s\", spec->name);\n    if (!inValue || Jsi_ValueIsNull(interp, inValue)) {\n        if (*v) Jsi_DecrRefCount(pinterp, *v);\n        *v = NULL;\n        return JSI_OK;\n    }\n    if (!(s=Jsi_ValueString(interp, inValue, NULL))) {\n        return Jsi_LogError(\"expected string or null\");\n    }\n    val = Jsi_NameLookup(pinterp, s);\n    if (!val)\n        return Jsi_LogError(\"value not found in parent: %s\", s);\n    if (!Jsi_ValueIsFunction(pinterp, val))\n        return Jsi_LogError(\"expected a func value\");\n    if (spec->data && (interp->strict || pinterp->strict))\n        if (!jsi_FuncIsNoop(pinterp, val)\n            && !jsi_FuncArgCheck(pinterp, val->d.obj->d.fobj->func, (char*)spec->data)) \n            return Jsi_LogError(\"failed setting func pointer for %s\", spec->name);\n\n    *v = val;\n    Jsi_IncrRefCount(pinterp, val);\n    return JSI_OK;\n}\n\n/* Printing function. */\nstatic Jsi_RC jsi_ParentFuncToValue(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value **outValue, Jsi_DString *outStr, void *record, Jsi_Wide flags)\n{\n    if (outStr)\n        return JSI_ERROR;\n    Jsi_Value **v = (Jsi_Value **)(((char*)record) + spec->offset);\n    //const char *s, *subspec = (const char *)spec->data;\n    if (!*v) {\n        Jsi_ValueMakeNull(interp, outValue);\n        return JSI_OK;\n    }\n    if (!interp->parent)\n        return Jsi_LogError(\"no parent interp\");\n    if (spec->data) {\n        Jsi_DString dStr = {};\n        Jsi_DSPrintf(&dStr, \"func(%s)\", (char*)spec->data);\n        Jsi_ValueFromDS(interp, &dStr, outValue);\n    }\n    return JSI_OK;\n}\n\nstatic void jsi_ParentFuncFree(Jsi_Interp *interp, Jsi_OptionSpec* spec, void *ptr)\n{\n    Jsi_Value **v = (Jsi_Value **)(((char*)ptr));\n    if (!interp->parent) return;\n    if (*v)\n        Jsi_DecrRefCount(interp->parent, *v);\n    *v = NULL;\n}\n\nstatic Jsi_OptionCustom jsi_OptSwitchParentFunc = {\n    .name=\"funcinparent\", .parseProc=jsi_ValueToParentFunc, .formatProc=jsi_ParentFuncToValue, .freeProc=jsi_ParentFuncFree,\n};\n\n/* Scanning function */\nstatic Jsi_RC jsi_ValueToBitfield(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value *inValue,\n    const char *inStr, void *record, Jsi_Wide flags)\n{\n    Jsi_csgset *bsget = spec->init.OPT_BITS;\n    Jsi_Interp *d = interp;\n    int idx = spec->idx;\n    uchar *data = (uchar*)record;\n    Jsi_Number num;\n    Jsi_OptionSpec* enumSpec = (typeof(enumSpec))spec->data;\n\n    if (!d || !bsget || idx<0) \n        return Jsi_LogBug(\"invalid bitfield\");\n    if (enumSpec) {\n        struct numStruct { int64_t numVal; } nval = {};\n        Jsi_OptionSpec eSpec[] = {\n            JSI_OPT(CUSTOM, typeof(nval), numVal, .help=spec->help, .flags=JSI_OPT_ENUM_SPEC,\n                .custom=Jsi_Opt_SwitchEnum, .data=(void*)enumSpec, .info=0, .tname=spec->tname, .value=0, .bits=0, .boffset=8*sizeof(int64_t) ),\n            JSI_OPT_END(typeof(nval))\n        };\n        if (JSI_OK != jsi_ValueToEnum(interp, eSpec, inValue, inStr, (void*)&nval, flags))\n            return JSI_ERROR;\n        num = (Jsi_Number)nval.numVal;\n    } else if (inStr) {\n        if (Jsi_GetDouble(interp, inStr, &num) != JSI_OK)\n            return JSI_ERROR;\n    } else {\n        if (inValue && !Jsi_ValueIsNumber(interp, inValue)) \n            return JSI_ERROR;\n        Jsi_ValueGetNumber(interp, inValue, &num);\n    }\n    int64_t inum = (int64_t)num;\n    return (*bsget)(interp, data, &inum, spec, idx, 1);\n}\n\n/* Printing function. */\nstatic Jsi_RC jsi_BitfieldToValue(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value **outValue,\n    Jsi_DString *outStr, void *record, Jsi_Wide flags)\n{\n    Jsi_csgset *bsget = spec->init.OPT_BITS;\n    Jsi_Interp *d = interp;\n    int idx = spec->idx;\n    uchar *data = (uchar*)record;\n    int64_t inum;\n    Jsi_OptionSpec* enumSpec = (typeof(enumSpec))spec->data;\n\n    if (!d || !bsget || idx<0) \n        return Jsi_LogBug(\"invalid bitfield\");\n    Jsi_RC rc = (*bsget)(interp, data, &inum, spec, idx, 0);\n    if (rc != JSI_OK)\n        return JSI_ERROR;\n\n    if (enumSpec) {\n        struct numStruct { int64_t numVal; } nval = { inum };\n        Jsi_OptionSpec eSpec[] = {\n            JSI_OPT(CUSTOM, struct numStruct, numVal, .help=spec->help, .flags=JSI_OPT_ENUM_SPEC, .custom=Jsi_Opt_SwitchEnum,\n            .data=(void*)enumSpec, .info=0, .tname=spec->tname, .value=0, .bits=0, .boffset=8*sizeof(int64_t) ), //TODO: extra\n            JSI_OPT_END(struct numStruct)\n        };\n        if (JSI_OK != jsi_EnumToValue(interp, eSpec, outValue, outStr, (void*)&nval, flags))\n            return JSI_ERROR;\n    } else if (outStr) {\n        char obuf[JSI_MAX_NUMBER_STRING];\n        snprintf(obuf, sizeof(obuf), \"%\" PRId64, inum);\n        Jsi_DSAppend(outStr, obuf, NULL);\n    } else {\n        Jsi_Number num = (Jsi_Number)inum;\n        Jsi_ValueMakeNumber(interp, outValue, num);\n    }\n    return JSI_OK;\n}\n\nstatic Jsi_OptionCustom jsi_OptSwitchBitfield = {\n    .name=\"bitfield\", .parseProc=jsi_ValueToBitfield, .formatProc=jsi_BitfieldToValue\n};\n\n/* Scanning function */\nstatic Jsi_RC jsi_ValueToNull(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value *inValue, const char *inStr, void *record, Jsi_Wide flags)\n{\n    return JSI_OK;\n}\n\n/* Printing function. */\nstatic Jsi_RC jsi_NullToValue(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value **outValue, Jsi_DString *outStr, void *record, Jsi_Wide flags)\n{\n    Jsi_ValueMakeNull(interp, outValue);\n    return JSI_OK;\n}\n\nstatic Jsi_OptionCustom jsi_OptSwitchNull = {\n    .name=\"null\", .parseProc=jsi_ValueToNull, .formatProc=jsi_NullToValue\n};\n\n#endif\n\ntypedef struct {\n    Jsi_OptionInitVal init;\n} jsi_IniValStruct;\n\nstatic Jsi_OptionCustom* custOpts[] = { NULL,\n    &jsi_OptSwitchEnum, \n    &jsi_OptSwitchBitset,\n#ifndef JSI_LITE_ONLY\n    &jsi_OptSwitchSuboption, \n    &jsi_OptSwitchBitfield,\n    &jsi_OptSwitchValueVerify,\n    &jsi_OptSwitchCArray,\n    &jsi_OptSwitchNull,\n    &jsi_OptSwitchParentFunc\n#else\n    NULL,\n    NULL,\n    NULL,\n    NULL,\n    NULL,\n    NULL\n#endif\n};\n\nJsi_OptionCustom* Jsi_OptionCustomBuiltin(Jsi_OptionCustom* cust) {\n    if ((uintptr_t)cust < (uintptr_t)(sizeof(custOpts)/sizeof(custOpts[0])))\n        return custOpts[(uintptr_t)cust];\n    return cust;\n}\n\nJsi_RC jsi_InitOptions(Jsi_Interp *interp, int release) {\n    if (release) return JSI_OK;\n    assert((sizeof(jsi_OptTypeInfo)/sizeof(jsi_OptTypeInfo[0])) == (JSI_OPTION_END+1));\n    int i;\n    for (i=JSI_OPTION_BOOL; i<JSI_OPTION_END; i++)\n        assert(jsi_OptTypeInfo[i].id == (Jsi_OptionId)i);\n    return JSI_OK;\n}\n", "#ifndef JSI_LITE_ONLY\n#ifndef JSI_AMALGAMATION\n#include \"jsiInt.h\"\n#endif\n\n// SCOPESTRS\n\nJsi_ScopeStrs *jsi_ScopeStrsNew()\n{\n    Jsi_ScopeStrs *ret = (Jsi_ScopeStrs *)Jsi_Calloc(1, sizeof(*ret));\n    return ret;\n}\n\nvoid jsi_ScopeStrsFree(Jsi_Interp *interp, Jsi_ScopeStrs *ss)\n{\n    if (!ss) return;\n    int i;\n    for (i=0; i<ss->count; i++)\n        if (ss->args[i].defValue)\n            Jsi_DecrRefCount(interp, ss->args[i].defValue);\n    if (ss->args)\n        Jsi_Free(ss->args);\n    Jsi_Free(ss);\n}\n\nvoid jsi_ScopeStrsPush(Jsi_Interp *interp, Jsi_ScopeStrs *ss, const char *string, int argType)\n{\n    if (ss->count >= ss->_size) {\n        int osz = ss->_size, isold = (ss->args!=NULL);\n        ss->_size += ALLOC_MOD_SIZE;\n        if (!isold)\n            ss->args = (jsi_ArgValue*)Jsi_Calloc(ss->_size,  sizeof(ss->args[0]));\n        else {\n            ss->args = (jsi_ArgValue*)Jsi_Realloc(ss->args, (ss->_size) * sizeof(ss->args[0]));\n            memset(ss->args+osz, 0, (ss->_size-osz)* sizeof(ss->args[0]));\n        }\n    }\n    ss->args[ss->count].name = (char*)Jsi_KeyAdd(interp, string);\n    ss->args[ss->count].type = argType;\n    if (argType)\n        ss->typeCnt++;\n    ss->count++;\n}\n\nstatic Jsi_ScopeStrs *jsi_ScopeStrsDup(jsi_Pstate *ps, Jsi_ScopeStrs *ss)\n{\n    Jsi_ScopeStrs *n = jsi_ScopeStrsNew();\n    int i;\n    if (!ss) return n;\n    *n = *ss;\n    if (!ss->args) return n;\n    n->args = (jsi_ArgValue*)Jsi_Calloc(n->count, sizeof(ss->args[0]));\n    n->_size = n->count;\n    memcpy(n->args, ss->args, (n->count *  sizeof(ss->args[0])));\n    for (i = 0; i < ss->count; ++i) {\n        if (ss->args[i].defValue)\n            Jsi_IncrRefCount(ps->interp, ss->args[i].defValue);\n    }\n    return n;\n}\n\nconst char *jsi_ScopeStrsGet(Jsi_ScopeStrs *ss, int i)\n{\n    if (i < 0 || i >= ss->count)\n        return NULL;\n    return ss->args[i].name;\n}\n\nJsi_ScopeStrs *jsi_ArgsOptAdd(jsi_Pstate *pstate, Jsi_ScopeStrs *a)\n{\n    jsi_PstatePush(pstate);\n    return a;\n}\n\nJsi_ScopeStrs *jsi_argInsert(jsi_Pstate *pstate, Jsi_ScopeStrs *a, const char *name, Jsi_Value *defValue, jsi_Pline *lPtr, bool prepend)\n{\n    Jsi_Interp *interp = pstate->interp;\n    if (!a)\n        a = jsi_ScopeStrsNew();\n    pstate->args = a;\n    int atyp = pstate->argType;\n    if (defValue) {\n        int vt = defValue->vt;\n        if (vt == JSI_VT_NULL)\n            vt = JSI_TT_NULL;\n        else if (vt == JSI_VT_UNDEF && defValue->d.num==1)\n            vt = JSI_TT_VOID;\n        else if (vt == JSI_VT_OBJECT && defValue->d.obj->ot==JSI_OT_STRING)\n            vt = JSI_TT_STRING;\n        else\n            vt = (1<<defValue->vt);\n        atyp |= vt;\n    }\n    jsi_ScopeStrsPush(interp, a, name, atyp);\n    pstate->argType = 0;\n    a->args[a->count-1].defValue = defValue;\n    a->argCnt++;\n    if (prepend) {\n        jsi_ArgValue t;\n        int i, end = a->argCnt-1;\n        t = a->args[end];\n        for (i=end-1; i>=0; i--)\n            a->args[i+1]=a->args[i];\n        a->args[0] = t;\n    }\n    jsi_Pline *opl = interp->parseLine;\n    interp->parseLine = lPtr;\n    if (defValue) {\n        Jsi_IncrRefCount(interp, defValue);\n        if (a->firstDef==0)\n            a->firstDef = a->argCnt;\n            if (atyp)\n                jsi_ArgTypeCheck(interp, atyp, defValue, \"default value\", name, a->argCnt, NULL, 1);\n    } else {\n        if (a->firstDef && (interp->typeCheck.run || interp->typeCheck.all) )\n            Jsi_LogWarn(\"expected default value in argument list: \\\"%s\\\"\", name);\n    }\n    interp->parseLine = opl;\n    return a;\n}\n\n\n// PSTATE \n\nvoid jsi_PstatePush(jsi_Pstate *ps)\n{\n    Jsi_Interp *interp = ps->interp;\n    if (interp->cur_scope >= (int)(JSI_MAX_SCOPE - 1)) {\n        Jsi_LogBug(\"Scope chain too short\");\n        return;\n    }\n    interp->cur_scope++;\n}\n\nvoid jsi_PstatePop(jsi_Pstate *ps)\n{\n    Jsi_Interp *interp = ps->interp;\n    if (interp->cur_scope <= 0) {\n        Jsi_LogBug(\"No more scope to pop\");\n        return;\n    }\n    jsi_ScopeStrsFree(interp, interp->scopes[interp->cur_scope]);\n    interp->scopes[interp->cur_scope] = NULL;\n    interp->cur_scope--;\n}\n\nvoid jsi_PstateAddVar(jsi_Pstate *ps, jsi_Pline *line, const char *str)\n{\n    Jsi_Interp *interp = ps->interp;\n    int i;\n    if (interp->scopes[interp->cur_scope] == NULL)\n        interp->scopes[interp->cur_scope] = (Jsi_ScopeStrs *)jsi_ScopeStrsNew();\n    \n    for (i = 0; i < interp->scopes[interp->cur_scope]->count; ++i) {\n        if (Jsi_Strcmp(str, interp->scopes[interp->cur_scope]->args[i].name) == 0) {\n            Jsi_Interp *interp = ps->interp;\n            if (interp && interp->strict) {\n                interp->parseLine = line;\n                Jsi_LogWarn(\"duplicate var: %s\", str);\n                interp->parseLine = NULL;\n            }\n            return;\n        }\n    }\n    jsi_ScopeStrsPush(ps->interp, interp->scopes[interp->cur_scope], str, JSI_VT_UNDEF);\n}\n\nJsi_ScopeStrs *jsi_ScopeGetVarlist(jsi_Pstate *ps)\n{\n    Jsi_Interp *interp = ps->interp;\n    return jsi_ScopeStrsDup(ps, interp->scopes[interp->cur_scope]);\n}\n\n#if 0\nstatic int fastVarFree(Jsi_Interp *interp, void *ptr) {\n    FastVar *fv = ptr;\n    Jsi_Value *v = fv->var.lval;\n    if (v) {\n        //printf(\"FV FREE: %p (%d/%d)\\n\", fv, v->refCnt, v->vt == JSI_VT_OBJECT?v->d.obj->refcnt:-99);\n        //Jsi_DecrRefCount(interp, v);\n    }\n    return JSI_OK;\n}\n#endif\n\n\nstatic Jsi_RC jsi_StringFree(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *d) {\n    Jsi_String *s = (Jsi_String *)d;\n    if (s->flags&1)\n        Jsi_Free(s->str);\n    Jsi_Free(s);\n    return JSI_OK;\n}\n\njsi_Pstate *jsi_PstateNew(Jsi_Interp *interp)\n{\n    jsi_Pstate *ps = (jsi_Pstate *)Jsi_Calloc(1,sizeof(*ps));\n    SIGINIT(ps,PARSER);\n    ps->lexer = (jsi_Lexer*)Jsi_Calloc(1,sizeof(*ps->lexer));\n    ps->lexer->pstate = ps;\n    ps->interp = interp;\n    ps->fastVarTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, NULL /*fastVarFree*/);\n    ps->strTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, jsi_StringFree);\n    return ps;\n}\n\nconst char *jsi_PstateGetFilename(jsi_Pstate *ps)\n{\n    Jsi_Interp *interp = ps->interp;\n    return interp->curFile;\n}\n\nvoid jsi_PstateClear(jsi_Pstate *ps)\n{\n    jsi_Lexer* l = ps->lexer;\n    if (l->ltype == LT_FILE)\n    {\n        if (l->d.fp)\n            Jsi_Close(ps->interp, l->d.fp);\n        l->d.fp = NULL;\n    }\n    if (l->ltype == LT_STRING)\n    {\n        l->d.str = NULL;\n    }\n    l->ltype = LT_NONE;\n    l->last_token = 0;\n    l->cur_line = 1;\n    l->cur_char = 0;\n    l->cur = 0;\n    ps->err_count = 0;\n}\n\nint jsi_PstateSetFile(jsi_Pstate *ps, Jsi_Channel fp, int skipbang)\n{\n    jsi_Lexer *l = ps->lexer;\n    jsi_PstateClear(ps);\n    l->ltype = LT_FILE;\n    l->d.fp = fp;\n    Jsi_Rewind(ps->interp, fp);\n    if (skipbang) {\n        char buf[JSI_BUFSIZ];\n        if (Jsi_Gets(ps->interp, fp, buf, sizeof(buf)) && (buf[0] != '#' || buf[1] != '!')) {\n            Jsi_Rewind(ps->interp, fp);\n        }\n    }\n            \n    return JSI_OK;\n}\n\n\nint jsi_PstateSetString(jsi_Pstate *ps, const char *str)\n{\n    Jsi_Interp *interp = ps->interp;\n    jsi_Lexer *l = ps->lexer;\n    jsi_PstateClear(ps);\n    l->ltype = LT_STRING;\n    Jsi_HashEntry *hPtr = Jsi_HashEntryNew(interp->codeTbl, (void*)str, NULL);\n    assert(hPtr);\n    l->d.str = (char*)Jsi_HashKeyGet(hPtr);\n    return JSI_OK;\n}\n\nvoid jsi_PstateFree(jsi_Pstate *ps)\n{\n    /* TODO: when do we free opcodes */\n    jsi_PstateClear(ps);\n    Jsi_Free(ps->lexer);\n    if (ps->opcodes)\n        jsi_FreeOpcodes(ps->opcodes);\n    if (ps->hPtr)\n        Jsi_HashEntryDelete(ps->hPtr);\n    if (ps->argsTbl)\n        Jsi_HashDelete(ps->argsTbl);\n    if (ps->fastVarTbl)\n        Jsi_HashDelete(ps->fastVarTbl);\n    if (ps->strTbl)\n        Jsi_HashDelete(ps->strTbl);\n    if (ps->last_exception)\n        Jsi_DecrRefCount(ps->interp, ps->last_exception);\n    _JSI_MEMCLEAR(ps);\n    Jsi_Free(ps);\n}\n\n#endif\n", "#ifndef JSI_LITE_ONLY\n#ifndef JSI_AMALGAMATION\n#include \"jsiInt.h\"\n#endif\n/* TODO: handle delete */\n\n#define ChkRegexp(_this, funcPtr, dest) \\\n    if (_this->vt == JSI_VT_OBJECT && _this->d.obj->ot == JSI_OT_FUNCTION &&  \\\n       _this->d.obj->__proto__ == interp->RegExp_prototype->d.obj->__proto__ ) { \\\n        skip = 1; \\\n        dest = Jsi_ValueArrayIndex(interp, args, 0); \\\n    } else if (_this->vt != JSI_VT_OBJECT || _this->d.obj->ot != JSI_OT_REGEXP) { \\\n        return Jsi_LogError(\"apply Regexp.%s to a non-regex object\", funcPtr->cmdSpec->name); \\\n    } else  { \\\n        dest = _this; \\\n    }\n\nvoid Jsi_RegExpFree(Jsi_Regex* re) {\n    regfree(&re->reg);\n    _JSI_MEMCLEAR(re);\n    Jsi_Free(re);\n}\n\nJsi_Regex* Jsi_RegExpNew(Jsi_Interp *interp, const char *regtxt, int eflag)\n{\n    bool isNew;\n    Jsi_HashEntry *hPtr;\n    int flag = REG_EXTENDED;\n    char c, *cm, *ce;\n    const char *cp;\n    Jsi_Regex *re;\n    if (interp->subOpts.noRegex) {\n        Jsi_LogError(\"regex disabled for interp\");\n        return NULL;\n    }\n\n    eflag |= JSI_REG_STATIC;\n    if (!regtxt[0])\n        return NULL;\n    hPtr = Jsi_HashEntryFind(interp->regexpTbl, regtxt);\n    if (hPtr) {\n        re = (Jsi_Regex*)Jsi_HashValueGet(hPtr);\n        if (JSI_REG_STATIC & eflag)\n            re->eflags |= JSI_REG_STATIC;\n        return re;\n    }\n    cp = regtxt+1;\n    if (regtxt[0] != '/')\n        return NULL;\n    ce = (char*)Jsi_Strrchr(cp, '/');\n    if (ce == cp || !ce)\n        return NULL;\n    cm = ce + 1;    \n    while (*cm) {\n        c = *cm++;\n        if (c == 'i') flag |= REG_ICASE;\n        else if (c == 'g') eflag |= JSI_REG_GLOB;\n        else if (c == 'm') { /* PERL NON-STANDARD */\n            eflag |= JSI_REG_NEWLINE;\n            flag |= REG_NEWLINE;\n        }\n#ifdef RE_DOT_NEWLINE\n        else if (c == 's') { /* PERL NON-STANDARD */\n            eflag |= JSI_REG_DOT_NEWLINE;\n            flag |= RE_DOT_NEWLINE;\n        }\n#endif\n    }\n    *ce = 0;\n    regex_t reg;\n    if (regcomp(&reg, cp, flag)) {\n        *ce++ = '/';\n        Jsi_LogError(\"Invalid regex string '%s'\", cp);\n        return NULL;\n    }\n    *ce++ = '/';\n    re = (Jsi_Regex*)Jsi_Calloc(1, sizeof(Jsi_Regex));\n    SIGINIT(re, REGEXP);\n    assert (re);\n    re->reg = reg;\n    re->eflags = eflag;\n    re->flags = flag;\n    hPtr = Jsi_HashEntryNew(interp->regexpTbl, regtxt, &isNew);\n    assert(hPtr);\n    Jsi_HashValueSet(hPtr, re);\n    re->pattern = (char*)Jsi_HashKeyGet(hPtr);\n    return re;\n\n}\n\nJsi_RC jsi_RegExpValueNew(Jsi_Interp *interp, const char *regtxt, Jsi_Value *ret)\n{\n    \n    Jsi_DString dStr = {};\n    Jsi_DSAppend(&dStr, \"/\", regtxt, \"/\", NULL);\n    Jsi_Regex *re = Jsi_RegExpNew(interp, Jsi_DSValue(&dStr), 0);\n    Jsi_DSFree(&dStr);\n    if (re == NULL)\n        return JSI_ERROR;\n    Jsi_Obj *o = Jsi_ObjNewType(interp, JSI_OT_REGEXP);\n    Jsi_ValueMakeObject(interp, &ret, o);\n    ret->d.obj->d.robj = re;\n    ret->d.obj->ot = JSI_OT_REGEXP;\n    return JSI_OK;\n}\n\n\nstatic Jsi_RC RegExp_constructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Value *target;\n    \n    if (Jsi_FunctionIsConstructor(funcPtr))\n        target = _this;\n    else {\n        Jsi_Obj *o = Jsi_ObjNewType(interp, JSI_OT_REGEXP);\n        Jsi_ValueMakeObject(interp, ret, o);\n        target = *ret;\n    }\n    \n    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n    const char *regtxt = \"\";\n    const char *mods = NULL;\n    if (v) {\n        if (v->vt == JSI_VT_OBJECT && v->d.obj->ot == JSI_OT_REGEXP) {\n            Jsi_ValueCopy(interp,target, v);\n            return JSI_OK;\n        } else if (!(regtxt = Jsi_ValueString(interp, v, NULL))) {\n            return JSI_ERROR;\n        }\n    }\n    Jsi_Value *f = Jsi_ValueArrayIndex(interp, args, 1);\n    if (f)\n        mods = Jsi_ValueString(interp, f, NULL);\n    Jsi_DString dStr = {};\n    Jsi_DSAppend(&dStr, \"/\", regtxt, \"/\", mods, NULL);\n    Jsi_Regex *re = Jsi_RegExpNew(interp, Jsi_DSValue(&dStr), 0);\n    Jsi_DSFree(&dStr);\n    if (re == NULL)\n        return JSI_ERROR;\n    target->d.obj->d.robj = re;\n    target->d.obj->ot = JSI_OT_REGEXP;\n    return JSI_OK;\n}\n\n// Preform regexc setting *rc to 1 if match occurs.  If dStr != NULL, it is used to return matching strings.\nJsi_RC Jsi_RegExpMatch(Jsi_Interp *interp, Jsi_Value *pattern, const char *v, int *rc, Jsi_DString *dStr)\n{\n    Jsi_Regex *re;\n    int regexec_flags = 0;\n    if (rc)\n        *rc = 0;\n    if (pattern == NULL || pattern->vt != JSI_VT_OBJECT || pattern->d.obj->ot != JSI_OT_REGEXP) \n        return Jsi_LogError(\"expected pattern\");\n    re = pattern->d.obj->d.robj;\n    regex_t *reg = &re->reg;\n    \n    regmatch_t pos = {};\n    if (dStr)\n        Jsi_DSInit(dStr);\n        \n    int r  = regexec(reg, v, 1, &pos, regexec_flags);\n\n    if (r >= REG_BADPAT) {\n        char buf[JSI_MAX_NUMBER_STRING];\n\n        regerror(r, reg, buf, sizeof(buf));\n        return Jsi_LogError(\"error while matching pattern: %s\", buf);\n    }\n    if (r != REG_NOMATCH) {\n        if (rc) *rc = 1;\n        if (dStr && pos.rm_so >= 0 && pos.rm_eo >= 0 &&  pos.rm_eo >= pos.rm_so)\n            Jsi_DSAppendLen(dStr, v + pos.rm_so, pos.rm_eo - pos.rm_so);\n    }\n    \n    return JSI_OK;\n}\n\n\n\nJsi_RC jsi_RegExpMatches(Jsi_Interp *interp, Jsi_Value *pattern, const char *str, int n, Jsi_Value *ret, int *ofs, bool match)\n{\n    Jsi_Regex *re;\n    int regexec_flags = 0;\n    Jsi_Value *seq = pattern;\n\n    if (seq == NULL || seq->vt != JSI_VT_OBJECT || seq->d.obj->ot != JSI_OT_REGEXP) {\n        Jsi_ValueMakeNull(interp, &ret);\n        return JSI_OK;\n    }\n    re = seq->d.obj->d.robj;\n    regex_t *reg = &re->reg;\n    \n    regmatch_t pos[MAX_SUBREGEX] = {};\n    int num_matches = 0, r;\n    int isglob = (re->eflags&JSI_REG_GLOB);\n    Jsi_Obj *obj;\n    \n    do {\n        r = regexec(reg, str, MAX_SUBREGEX, pos, regexec_flags);\n\n        if (r >= REG_BADPAT) {\n            char buf[JSI_BUFSIZ];\n\n            regerror(r, reg, buf, sizeof(buf));\n            return Jsi_LogError(\"error while matching pattern: %s\", buf);\n        }\n        if (r == REG_NOMATCH) {\n            if (num_matches == 0) {\n                Jsi_ValueMakeNull(interp, &ret);\n                return JSI_OK;\n            }\n            break;\n        }\n\n        if (num_matches == 0) {\n            obj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n            obj->__proto__ = interp->Array_prototype;\n            Jsi_ValueMakeObject(interp, &ret, obj);\n            Jsi_ObjSetLength(interp, ret->d.obj, 0);\n        }\n    \n        int i;\n        for (i = 0; i < MAX_SUBREGEX; ++i) {\n            if (pos[i].rm_so <= 0 && pos[i].rm_eo <= 0)\n                break;\n            if (i && pos[i].rm_so == pos[i-1].rm_so && pos[i].rm_eo == pos[i-1].rm_eo)\n                continue;\n    \n            int olen = -1;\n            char *ostr = jsi_SubstrDup(str, -1, pos[i].rm_so, pos[i].rm_eo - pos[i].rm_so, &olen);\n            Jsi_Value *val = Jsi_ValueMakeBlob(interp, NULL, (uchar*)ostr, olen);\n            if (ofs)\n                *ofs = pos[i].rm_eo;\n            Jsi_ValueInsertArray(interp, ret, num_matches, val, 0);\n            num_matches++;\n            if ( match && isglob)\n                break;\n        }\n        if (num_matches && match && !isglob)\n            return JSI_OK;\n        if (num_matches == 1 && (ofs || !isglob))\n            break;\n        \n        str += pos[0].rm_eo;\n        n -= pos[0].rm_eo;\n\n        regexec_flags |= REG_NOTBOL;\n    } while (n && pos[0].rm_eo>0);\n    \n    return JSI_OK;\n}\n\nJsi_RC Jsi_RegExpMatches(Jsi_Interp *interp, Jsi_Value *pattern, const char *str, int slen, Jsi_Value *ret)\n{\n    return jsi_RegExpMatches(interp, pattern, str, slen, ret, NULL, 0);\n}\n\n\n#define FN_regexec JSI_INFO(\"\\\nPerform regexp match checking.  Returns the array of matches.\\\nWith the global flag g, sets lastIndex and returns next match.\")\nstatic Jsi_RC RegexpExecCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int skip = 0;\n    Jsi_Value *v;\n    ChkRegexp(_this, funcPtr, v);\n    /* TODO: add lastIndex support. */\n    int slen;\n    char *str = Jsi_ValueString(interp,Jsi_ValueArrayIndex(interp, args, skip), &slen);\n    if (!str) \n        return Jsi_LogError(\"expected string\");\n    if (v == NULL || v->vt != JSI_VT_OBJECT || v->d.obj->ot != JSI_OT_REGEXP) \n        return Jsi_LogError(\"expected pattern\");\n    Jsi_Regex *re = v->d.obj->d.robj;\n    int isglob = (re->eflags&JSI_REG_GLOB);\n    Jsi_Value *l = NULL;\n    Jsi_Number lv = 0;\n    if (isglob) {\n        l = Jsi_ValueObjLookup(interp, v, \"lastIndex\", 0);\n        if (l && Jsi_ValueGetNumber(interp, l, &lv) != JSI_OK) \n            return Jsi_LogError(\"lastIndex not a number\");\n        if (l)\n            re->lastIndex = (int)lv;\n    }\n    int ofs = 0;\n    Jsi_RC rc = jsi_RegExpMatches(interp, v, re->lastIndex<slen?str+re->lastIndex:\"\", -1, *ret, isglob?&ofs:NULL, 0);\n    if (isglob) {\n        if (rc != JSI_OK)\n            return rc;\n        re->lastIndex += ofs;\n        if (Jsi_ValueIsNull(interp, *ret))\n            re->lastIndex = 0;\n        lv = (Jsi_Number)re->lastIndex;\n        if (!l)\n            Jsi_ValueInsert(interp, v, \"lastIndex\", Jsi_ValueNewNumber(interp, lv), JSI_OM_DONTDEL);\n        else if (l->vt == JSI_VT_NUMBER)\n            l->d.num = lv;\n        else if (l->vt == JSI_VT_OBJECT && l->d.obj->ot == JSI_OT_NUMBER)\n            l->d.obj->d.num = lv;\n    }\n    return rc;\n}\n\nstatic Jsi_RC RegexpTestCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int skip = 0, rc = 0;\n    Jsi_Value *v;\n    ChkRegexp(_this, funcPtr, v);\n    char *str = Jsi_ValueString(interp,Jsi_ValueArrayIndex(interp, args, skip), NULL);\n    if (!str) \n        return Jsi_LogError(\"expected string\");\n    if (Jsi_RegExpMatch(interp, v, str, &rc, NULL) != JSI_OK)\n        return JSI_ERROR;    \n    Jsi_ValueMakeBool(interp, ret, rc != 0);\n    return JSI_OK;\n}\n\nstatic Jsi_CmdSpec regexpCmds[] = {\n    { \"RegExp\",  RegExp_constructor,    1, 2, \"val:regexp|string, flags:string\", .help=\"Create a regexp object\", .retType=(uint)JSI_TT_REGEXP, .flags=JSI_CMD_IS_CONSTRUCTOR  },\n    { \"exec\",    RegexpExecCmd,         1, 1, \"val:string\", .help=\"return matching string\", .retType=(uint)JSI_TT_ARRAY|JSI_TT_OBJECT|JSI_TT_NULL, 0, .info=FN_regexec  },\n    { \"test\",    RegexpTestCmd,         1, 1, \"val:string\", .help=\"test if a string matches\", .retType=(uint)JSI_TT_BOOLEAN },\n    { NULL, 0,0,0,0,.help=\"Commands for managing reqular expression objects\" }\n};\n\nJsi_RC jsi_InitRegexp(Jsi_Interp *interp, int release)\n{\n    if (!release)\n        interp->RegExp_prototype = Jsi_CommandCreateSpecs(interp, \"RegExp\", regexpCmds, NULL, JSI_CMDSPEC_ISOBJ);\n    return JSI_OK;\n}\n\n#endif\n", "#define JSI_SQLITE_DB_VFS \"SQLITE_DB_VFS\"\n\n#ifndef JSI_AMALGAMATION\n#ifdef JSI_MEM_DEBUG\n#include \"jsiInt.h\"\n#else\n#include \"jsi.h\"\n#ifdef JSI_SQLITE_SHARED\nJSI_EXTENSION_INI\n#endif\n#endif\n#endif\n\ntypedef struct jsi_DbVfs {\n    int sig; \n    int (*dbcQuery)(Jsi_Db *jdb, Jsi_CDataDb *dbc, const char *query);\n    void *(*dbHandle)(Jsi_Interp *interp, Jsi_Db* jdb);\n    Jsi_Db* (*dbNew)(const char *zFile, int inFlags /* JSI_DBI_* */);\n} jsi_DbVfs;\n\njsi_DbVfs SqliteDbVfs = {\n    0x1234, &Jsi_DbQuery, &Jsi_DbHandle, Jsi_DbNew\n};\n\n\n#if JSI__SQLITE==1\n/*\n** 2001 September 15\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** A JSI (Javascript) Interface to SQLite.\n*/\n\ntypedef enum { SQLITE_SIG_DB = 0xbeefdead, SQLITE_SIG_FUNC, SQLITE_SIG_EXEC, SQLITE_SIG_STMT } Sqlite_Sig;\n\n#define SQLSIGASSERT(s,n) assert(s->sig == SQLITE_SIG_##n)\n#ifndef _JSI_MEMCLEAR\n#ifndef NDEBUG\n#define _JSI_MEMCLEAR(s) memset(s, 0, sizeof(*s));\n#else\n#define _JSI_MEMCLEAR(s)\n#endif\n#endif\n#ifndef JSI_DB_DSTRING_SIZE\n#define JSI_DB_DSTRING_SIZE 2000\n#endif\n\n#ifndef JSI_DBQUERY_BEGIN_STR\n#define JSI_DBQUERY_BEGIN_STR \"BEGIN;\"\n#endif\n#ifndef JSI_DBQUERY_ROLLBACK_STR\n#define JSI_DBQUERY_ROLLBACK_STR \"ROLLBACK;\"\n#endif\n#ifndef JSI_DBQUERY_COMMIT_STR\n#define JSI_DBQUERY_COMMIT_STR \"COMMIT;\"\n#endif\n\n#include <errno.h>\n\n/*\n** Some additional include files are needed if this file is not\n** appended to the amalgamation.\n*/\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n#include <limits.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <inttypes.h>\n\n#ifndef SQLITE_AMALGAMATION\n#include \"sqlite3.h\"\n#endif\n\n\n#ifndef NUM_PREPARED_STMTS\n#define NUM_PREPARED_STMTS 100\n#endif\n#ifndef MAX_PREPARED_STMTS\n#define MAX_PREPARED_STMTS 10000\n#endif\n\n#ifndef JSI_DBQUERY_PRINTF\n#define JSI_DBQUERY_PRINTF(fmt, ...) fprintf(stderr, fmt, ##__VA_ARGS__)\n#endif\n/*\n** When JSI uses UTF-8 and SQLite is configured to use iso8859, then we\n** have to do a translation when going between the two.  Set the\n** UTF_TRANSLATION_NEEDED macro to indicate that we need to do\n** this translation.\n*/\n#if defined(JSI_UTF_MAX) && !defined(SQLITE_UTF8)\n# define UTF_TRANSLATION_NEEDED 1\n#endif\n\ntypedef struct db_ObjCmd {\n  int activeCnt;  /* Count of active objects. */ \n  int newCnt;  /* Total number of new. */ \n} db_ObjCmd;\n\n#ifndef JSI_LITE_ONLY\nstatic db_ObjCmd dbObjCmd = {};\n\nstatic Jsi_OptionSpec db_ObjCmd_Specs[] =\n{\n    JSI_OPT(INT,   db_ObjCmd, activeCnt, .help=\"Number of active objects\"),\n    JSI_OPT(INT,   db_ObjCmd, newCnt,    .help=\"Number of new calls\"),\n    JSI_OPT_END(db_ObjCmd, .help=\"Options for Sqlite module\")\n};\n#endif\n\n/*\n** New SQL functions can be created as JSI scripts.  Each such function\n** is described by an instance of the following structure.\n*/\ntypedef struct SqlFunc SqlFunc;\nstruct SqlFunc {\n    Sqlite_Sig sig;\n    Jsi_Interp  *interp;    /* The JSI interpret to execute the function */\n    Jsi_Value   *tocall;    /* Callee */\n    char        *pScript;   /* The char* representation of the script */\n    Jsi_DString dScript;\n    char        *zName;     /* Name of this function */\n    SqlFunc     *pNext;     /* Next function on the list of them all */\n};\n\n/*\n** New collation sequences function can be created as JSI scripts.  Each such\n** function is described by an instance of the following structure.\n*/\ntypedef struct SqlCollate SqlCollate;\nstruct SqlCollate {\n    Sqlite_Sig sig;\n    Jsi_Interp  *interp;   /* The JSI interpret to execute the function */\n    Jsi_Value   *zScript;  /* The function to be run */\n    Jsi_Db      *jdb;\n    SqlCollate  *pNext;    /* Next function on the list of them all */\n};\n\n/*\n** Prepared statements are cached for faster execution.  Each prepared\n** statement is described by an instance of the following structure.\n*/\ntypedef struct SqlPreparedStmt SqlPreparedStmt;\nstruct SqlPreparedStmt {\n    Sqlite_Sig sig;\n    int deleting;\n    SqlPreparedStmt *pNext;  /* Next in linked list */\n    SqlPreparedStmt *pPrev;  /* Previous on the list */\n    sqlite3_stmt    *pStmt;  /* The prepared statement */\n    uint nSql;                /* chars in zSql[] */\n    const char *zSql;        /* Text of the SQL statement */\n    Jsi_HashEntry *entry;\n    Jsi_ListEntry *elPtr;\n    //int nParm;               /* Size of apParm array */\n    //Jsi_Value **apParm;      /* Array of referenced object pointers */\n};\n\n#ifndef JSI_LITE_ONLY\nstatic const char *sqexecFmtStrs[] = {\n    \"rows\", \"arrays\", \"array1d\", \"list\", \"column\", \"json\",\n    \"json2\", \"html\", \"csv\", \"insert\", \"line\", \"tabs\", \"none\", NULL\n};\nstatic const char *mtxStrs[] = { \"default\", \"none\", \"full\", NULL };\nstatic const char *trcModeStrs[] = {\"eval\", \"delete\", \"prepare\", \"step\", NULL}; // Bit-set packed into an int.\nstatic const char *dbTypeChkStrs[] = { \"convert\", \"warn\", \"error\", \"disable\", NULL };\nstatic const char *objSqlModeStrs[] = { \"getSql\", \"noTypes\", \"noDefaults\", \"nullDefaults\", NULL };\n#endif\n\nenum {OBJMODE_SQLONLY=0x1, OBJMODE_NOTYPES=0x2, OBJMODE_NODEFAULTS=0x4, OBJMODE_NULLDEFAULTS=0x8};\nenum {TMODE_EVAL=0x1, TMODE_DELETE=0x2, TMODE_PREPARE=0x4, TMODE_STEP=0x4};\ntypedef enum { MUTEX_DEFAULT, MUTEX_NONE, MUTEX_FULL } Mutex_Type;\ntypedef enum { dbTypeCheck_Cast, dbTypeCheck_Warn, dbTypeCheck_Error, dbTypeCheck_None } dbTypeCheck_Mode;\ntypedef enum {\n    _JSI_EF_ROWS, _JSI_EF_ARRAYS, _JSI_EF_ARRAY1D, _JSI_EF_LIST, _JSI_EF_COLUMN, _JSI_EF_JSON,\n    _JSI_EF_JSON2, _JSI_EF_HTML, _JSI_EF_CSV, _JSI_EF_INSERT, _JSI_EF_LINE, _JSI_EF_TABS, _JSI_EF_NONE\n} Output_Mode;\n\ntypedef struct QueryOpts {\n    Sqlite_Sig sig;\n    Jsi_Value *callback, *values;\n    int limit, objOpts;\n    Output_Mode mode;\n    dbTypeCheck_Mode typeCheck;\n    bool mapundef, nocache, headers, retChanged, echo;\n    const char *separator;\n    const char *nullvalue;\n    const char *table;\n    const char *cdata; // Name of C data array to use for query.\n    const char *objName;\n    Jsi_Value *width;\n} QueryOpts;\n\n\n/*\n** There is one instance of this structure for each SQLite database\n** that has been opened by the SQLite JSI interface.\n*/\ntypedef struct Jsi_Db {\n    Sqlite_Sig sig;\n    sqlite3 *db;               /* The \"real\" database structure. MUST BE FIRST */\n    Jsi_Interp *interp;        /* The interpreter used for this database */\n    db_ObjCmd *_;              // Module data.\n    Jsi_Value *onBusy;               /* The busy callback routine */\n    Jsi_Value *onCommit;             /* The commit hook callback routine */\n    Jsi_Value *onTrace;              /* The trace callback routine */\n    Jsi_Value *onProfile;            /* The profile callback routine */\n    Jsi_Value *onProgress;           /* The progress callback routine */\n    Jsi_Value *onAuth;               /* The authorization callback routine */\n    Jsi_Value *onUpdate;      /* Update hook script (if any) */\n    Jsi_Value *onRollback;    /* Rollback hook script (if any) */\n    Jsi_Value *onWalHook;        /* Wal hook script (if any) */\n    Jsi_Value *onNeedCollate;   /* Collation needed script */\n    Jsi_Value *onUnlock;    /* Unlock notify script (if any) */\n    Jsi_Value *udata;\n    int disableAuth;           /* Disable the authorizer if it exists */\n    uint progressSteps;\n    SqlFunc *pFunc;            /* List of SQL functions */\n    SqlCollate *pCollate;      /* List of SQL collation functions */\n    int rc;                    /* Return code of most recent sqlite3_exec() */\n    Jsi_Hash *stmtHash;        /* Hash table for statements. */\n    Jsi_List *stmtCache;\n    int stmtCacheMax;               /* The next maximum number of stmtList */\n    int stmtCacheCnt;                 /* Number of statements in stmtList */\n    /*IncrblobChannel *pIncrblob; * Linked list of open incrblob channels */\n    Jsi_Hash *strKeyTbl;       /* Used with JSI_LITE_ONLY */\n    bool noJsonConv;\n    bool bindWarn;\n    bool forceInt;\n    bool readonly;\n    bool noCreate;\n    bool noConfig;\n    bool load;\n    bool echo;\n    int timeout;\n    int stepCnt, sortCnt;          /* Statistics for most recent operation */\n    int nTransaction;          /* Number of nested [transaction] methods */\n    int errCnt;               /* Count of errors. */\n    Jsi_Value *vfs;\n    int hasOpts;\n    Jsi_Obj *fobj;\n    QueryOpts queryOpts, *optPtr;\n    int objId;\n    Mutex_Type mutex;\n    uint64_t lastInsertId;\n    int debug, changeCnt, changeCntAll, errorCode;\n    Jsi_Value *version;\n    Jsi_DString name;\n    Jsi_Hash *typeNameHash;\n} Jsi_Db;\n\nstatic const int jsi_DbPkgVersion = 2;\n/*\n** Structure used with dbEvalXXX() functions:\n**\n**   dbEvalInit(interp,)\n**   dbEvalStep()\n**   dbEvalFinalize()\n**   dbEvalRowInfo()\n**   dbEvalColumnValue()\n*/\n#define SQL_MAX_STATIC_TYPES 100\ntypedef struct DbEvalContext {\n    Jsi_Db *jdb;                /* Database handle */\n    Jsi_DString *dSql;               /* Object holding string zSql */\n    const char *zSql;               /* Remaining SQL to execute */\n    SqlPreparedStmt *pPreStmt;      /* Current statement */\n    int nCol;                       /* Number of columns returned by pStmt */\n    char **apColName;             /* Array of column names */\n    int *apColType;\n    char staticColNames[JSI_BUFSIZ];  /* Attempt to avoid mallocing space for name storage. */\n    int staticColTypes[SQL_MAX_STATIC_TYPES];\n    Jsi_Value *tocall;\n    Jsi_Value *ret;\n    /*OBS */\n    Jsi_Value *pArray;              /* Name of array variable */\n    Jsi_Value *pValVar;             /* Name of list for values. */\n    int nocache;\n} DbEvalContext;\n\n#ifndef JSI_LITE_ONLY\n\nstatic Jsi_RC dbIsNumArray(Jsi_Interp *interp, Jsi_Value *value, Jsi_OptionSpec* spec, void *record);\n\n\nstatic Jsi_OptionSpec ExecFmtOptions[] =\n{\n    JSI_OPT(FUNC,   QueryOpts, callback,    .help=\"Function to call with each row result\", .flags=0, .custom=0, .data=(void*)\"values:object\" ),\n    JSI_OPT(STRKEY, QueryOpts, cdata,       .help=\"Name of Cdata array object to use\"),\n    JSI_OPT(BOOL,   QueryOpts, echo,        .help=\"Output query string to log\"),\n    JSI_OPT(BOOL,   QueryOpts, headers,     .help=\"First row returned contains column labels\"),\n    JSI_OPT(INT,    QueryOpts, limit,       .help=\"Maximum number of returned values\"),\n    JSI_OPT(BOOL,   QueryOpts, mapundef,    .help=\"In variable bind, map an 'undefined' var to null\"),\n    JSI_OPT(CUSTOM, QueryOpts, mode,        .help=\"Set output mode of returned data\", .flags=0, .custom=Jsi_Opt_SwitchEnum,  .data=(void*)sqexecFmtStrs),\n    JSI_OPT(BOOL,   QueryOpts, nocache,     .help=\"Disable query cache\"),\n    JSI_OPT(STRKEY, QueryOpts, nullvalue,   .help=\"Null string output (for non js/json mode)\"),\n    JSI_OPT(STRKEY, QueryOpts, objName,     .help=\"Object var name for CREATE/INSERT: replaces %s with fields in query\" ),\n    JSI_OPT(CUSTOM, QueryOpts, objOpts,     .help=\"Options for objName\", .flags=0,  .custom=Jsi_Opt_SwitchBitset,  .data=objSqlModeStrs),\n    JSI_OPT(BOOL,   QueryOpts, retChanged,  .help=\"Query returns value of sqlite3_changed()\"),\n    JSI_OPT(STRKEY, QueryOpts, separator,   .help=\"Separator string (for csv and text mode)\"),\n    JSI_OPT(CUSTOM, QueryOpts, typeCheck,   .help=\"Type check mode (warn)\", .flags=0, .custom=Jsi_Opt_SwitchEnum, .data=(void*)dbTypeChkStrs),\n    JSI_OPT(STRKEY, QueryOpts, table,       .help=\"Table name for mode=insert\"),\n    JSI_OPT(ARRAY,  QueryOpts, values,      .help=\"Values for ? bind parameters\" ),\n    JSI_OPT(CUSTOM, QueryOpts, width,       .help=\"In column mode, set column widths\", .flags=0, .custom=Jsi_Opt_SwitchValueVerify, .data=(void*)dbIsNumArray),\n    JSI_OPT_END(QueryOpts, .help=\"Options for query()\")\n};\n\n#ifndef jsi_IIOF\n#define jsi_IIOF .flags=JSI_OPT_INIT_ONLY\n#define jsi_IIRO .flags=JSI_OPT_READ_ONLY\n#endif\nstatic Jsi_OptionSpec SqlOptions[] =\n{\n    JSI_OPT(BOOL,   Jsi_Db, bindWarn,   .help=\"Treat failed variable binds as a warning\", jsi_IIOF),\n    JSI_OPT(INT,    Jsi_Db, changeCnt,  .help=\"The number of rows modified, inserted, or deleted by last command\"),\n    JSI_OPT(INT,    Jsi_Db, changeCntAll,.help=\"Total number of rows modified, inserted, or deleted since db opened\"),\n    JSI_OPT(CUSTOM, Jsi_Db, debug,      .help=\"Enable debug trace for various operations\", .flags=0,  .custom=Jsi_Opt_SwitchBitset,  .data=trcModeStrs),\n    JSI_OPT(BOOL,   Jsi_Db, echo,       .help=\"Output query/eval string to log\"),\n    JSI_OPT(INT,    Jsi_Db, errCnt,     .help=\"Count of errors in script callbacks\", jsi_IIRO),\n    JSI_OPT(INT,    Jsi_Db, errorCode,  .help=\"Numeric error code returned by the most recent call to sqlite3_exec\"),\n    JSI_OPT(BOOL,   Jsi_Db, forceInt,   .help=\"Bind float as int if possible\"),\n    JSI_OPT(BOOL,   Jsi_Db, noJsonConv, .help=\"Do not JSON auto-convert array and object in CHARJSON columns\" ),\n    JSI_OPT(UINT64, Jsi_Db, lastInsertId,.help=\"The rowid of last insert\"),\n    JSI_OPT(BOOL,   Jsi_Db, load,       .help=\"Extensions can be loaded\" ),\n    JSI_OPT(CUSTOM, Jsi_Db, mutex,      .help=\"Mutex type to use\", jsi_IIOF, .custom=Jsi_Opt_SwitchEnum, .data=mtxStrs),\n    JSI_OPT(DSTRING,Jsi_Db, name,       .help=\"The dbname to use instead of 'main'\", jsi_IIOF),\n    JSI_OPT(BOOL,   Jsi_Db, noConfig,   .help=\"Disable use of Sqlite.conf to change options after create\", jsi_IIOF),\n    JSI_OPT(BOOL,   Jsi_Db, noCreate,   .help=\"Database is must already exist (false)\", jsi_IIOF),\n    JSI_OPT(FUNC,   Jsi_Db, onAuth,     .help=\"Function to call for auth\", .flags=0, .custom=0, .data=(void*)\"db:userobj, code:string, descr1:string, decr2:string, dbname:string, trigname:string\"),\n    JSI_OPT(FUNC,   Jsi_Db, onBusy,     .help=\"Function to call when busy\", .flags=0, .custom=0, .data=(void*)\"db:userobj, tries:number\"),\n    JSI_OPT(FUNC,   Jsi_Db, onCommit,   .help=\"Function to call on commit\", .flags=0, .custom=0, .data=(void*)\"db:userobj\"),\n    JSI_OPT(FUNC,   Jsi_Db, onNeedCollate,.help=\"Function to call for collation\", .flags=0, .custom=0, .data=(void*)\"db:userobj, name:string\"),\n    JSI_OPT(FUNC,   Jsi_Db, onProfile,  .help=\"Function to call for profile\", .flags=0, .custom=0, .data=(void*)\"db:userobj, sql:string, time:number\"),\n    JSI_OPT(FUNC,   Jsi_Db, onProgress, .help=\"Function to call for progress: progressSteps must be >0\", .flags=0, .custom=0, .data=(void*)\"db:userobj\"),\n    JSI_OPT(FUNC,   Jsi_Db, onRollback, .help=\"Function to call for rollback\", .flags=0, .custom=0, .data=(void*)\"db:userobj\"),\n    JSI_OPT(FUNC,   Jsi_Db, onTrace,    .help=\"Function to call for trace\", .flags=0, .custom=0, .data=(void*)\"db:userobj, sql:string\"),\n    JSI_OPT(FUNC,   Jsi_Db, onUpdate,   .help=\"Function to call for update\", .flags=0, .custom=0, .data=(void*)\"db:userobj, op:string, dbname:string, table:string, rowid:number\"),\n    JSI_OPT(FUNC,   Jsi_Db, onWalHook,  .help=\"Function to call for WAL\", .flags=0, .custom=0, .data=(void*)\"db:userobj, dbname:string, entry:number\"),\n    JSI_OPT(UINT,   Jsi_Db, progressSteps,.help=\"Number of steps between calling onProgress: 0 is disabled\", ),\n    JSI_OPT(CUSTOM, Jsi_Db, queryOpts,  .help=\"Default options for to use with query()\", .flags=0, .custom=Jsi_Opt_SwitchSuboption, .data=ExecFmtOptions),\n    JSI_OPT(BOOL,   Jsi_Db, readonly,   .help=\"Database opened in readonly mode\", jsi_IIOF),\n    JSI_OPT(INT,    Jsi_Db, sortCnt,    .help=\"Number of sorts in most recent operation\", jsi_IIRO),\n    JSI_OPT(INT,    Jsi_Db, stepCnt,    .help=\"Number of steps in most recent operation\", jsi_IIRO),\n    JSI_OPT(INT,    Jsi_Db, stmtCacheCnt,.help=\"Current size of compiled statement cache\", jsi_IIRO),\n    JSI_OPT(INT,    Jsi_Db, stmtCacheMax,.help=\"Max cache size for compiled statements\"),\n    JSI_OPT(INT,    Jsi_Db, timeout,    .help=\"Amount of time to wait when file is locked, in ms\"),\n    JSI_OPT(OBJ,    Jsi_Db, udata,      .help=\"User data\" ),\n    JSI_OPT(OBJ,    Jsi_Db, version,    .help=\"Sqlite version info\"),\n    JSI_OPT(INT,    Jsi_Db, timeout,    .help=\"Amount of time to wait when file is locked, in ms\"),\n    JSI_OPT(STRING, Jsi_Db, vfs,        .help=\"VFS to use\", jsi_IIOF),\n    JSI_OPT_END(Jsi_Db, .help=\"Options for source command\")\n};\n\n\n#endif\n\nvoid dbTypeNameHashInit(Jsi_Db *jdb) {\n    Jsi_Interp *interp = jdb->interp;\n    Jsi_Hash *hPtr = jdb->typeNameHash = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);\n    Jsi_HashSet(hPtr, (void*)\"blob\", (void*)JSI_OPTION_STRBUF);\n    Jsi_HashSet(hPtr, (void*)\"string\", (void*)JSI_OPTION_STRING);\n    Jsi_HashSet(hPtr, (void*)\"double\", (void*)JSI_OPTION_DOUBLE);\n    Jsi_HashSet(hPtr, (void*)\"integer\", (void*)JSI_OPTION_INT64);\n    Jsi_HashSet(hPtr, (void*)\"bool\", (void*)JSI_OPTION_BOOL);\n    Jsi_HashSet(hPtr, (void*)\"time_d\", (void*)JSI_OPTION_TIME_D);\n    Jsi_HashSet(hPtr, (void*)\"time_w\", (void*)JSI_OPTION_TIME_W);\n    Jsi_HashSet(hPtr, (void*)\"time_t\", (void*)JSI_OPTION_TIME_T);\n    Jsi_HashSet(hPtr, (void*)\"date\", (void*)JSI_OPTION_TIME_W);\n    Jsi_HashSet(hPtr, (void*)\"time\", (void*)JSI_OPTION_TIME_W);\n    Jsi_HashSet(hPtr, (void*)\"datetime\", (void*)JSI_OPTION_TIME_W);\n}\n\n#define SQLITE_OMIT_INCRBLOB\n\n// Return 1 if ok, else return 0 and set erc to -1 or -2 for timeout.\nstatic int dbExecCmd(Jsi_Db *jdb, const char *zQuery, int *erc)\n{\n    int rc = sqlite3_exec(jdb->db, zQuery, 0, 0, 0);\n    if (rc == SQLITE_BUSY) {\n        if (erc) *erc = -2;\n    } else if (rc != SQLITE_OK) {\n        if (erc) *erc = -1;\n    } else\n        return 1;\n    return 0;\n}\n\nstatic void dbEvalRowInfo(\n    DbEvalContext *p,               /* Evaluation context */\n    int *pnCol,                     /* OUT: Number of column names */\n    char ***papColName,           /* OUT: Array of column names */\n    int **papColType\n) {\n    /* Compute column names */\n    // Jsi_Interp *interp = p->jdb->interp;\n\n    if( 0==p->apColName ) {\n        sqlite3_stmt *pStmt = p->pPreStmt->pStmt;\n        uint i;                        /* Iterator variable */\n        uint nCol;                     /* Number of columns returned by pStmt */\n        char **apColName = 0;      /* Array of column names */\n        int *apColType = 0;\n        const char *zColName;         /* Column name */\n        int numRid = 0;               /* Number of times rowid seen. */\n\n        p->nCol = nCol = sqlite3_column_count(pStmt);\n        if( nCol>0 && (papColName || p->pArray) ) {\n            uint cnLen = sizeof(char*)*nCol, cnStart = cnLen;\n            for(i=0; i<nCol && cnLen<sizeof(p->staticColNames); i++)\n                cnLen += Jsi_Strlen(sqlite3_column_name(pStmt,i))+1;\n            if (cnLen>=sizeof(p->staticColNames)) {\n                apColName = (char**)Jsi_Calloc(nCol, sizeof(char*) );\n                cnStart = 0;\n            } else {\n                apColName = (char**)p->staticColNames;\n            }\n            if (papColType) {\n                if (nCol < SQL_MAX_STATIC_TYPES)\n                    apColType = p->staticColTypes;\n                else\n                    apColType = (int*)Jsi_Calloc(nCol, sizeof(int));\n            }\n            for(i=0; i<nCol; i++) {\n                zColName = sqlite3_column_name(pStmt,i);\n                if (cnStart==0)\n                    apColName[i] = Jsi_Strdup(zColName);\n                else {\n                    apColName[i] = p->staticColNames+cnStart;\n                    Jsi_Strcpy(apColName[i], zColName);\n                    cnStart += Jsi_Strlen(zColName)+1;\n                }\n                if (apColType)\n                    apColType[i] = sqlite3_column_type(pStmt,i);\n                /* Check if rowid appears first, and more than once. */\n                if ((i == 0 || numRid>0) &&\n                        (zColName[0] == 'r' && Jsi_Strcmp(zColName,\"rowid\") == 0)) {\n                    numRid++;\n                }\n            }\n            /* Change first rowid to oid. */\n            if (numRid > 1) {\n                if (apColName != (char**)p->staticColNames) {\n                    Jsi_Free(apColName[0]);\n                    apColName[0] = Jsi_Strdup(\"oid\");\n                } else {\n                    Jsi_Strcpy(apColName[0], \"oid\");\n                }\n            }\n            p->apColName = apColName;\n            p->apColType = apColType;\n        }\n    }\n    if( papColName ) {\n        *papColName = p->apColName;\n    }\n    if( papColType ) {\n        *papColType = p->apColType;\n    }\n    if( pnCol ) {\n        *pnCol = p->nCol;\n    }\n}\n\n#ifndef JSI_LITE_ONLY\nstatic Jsi_RC dbPrepareAndBind( Jsi_Db *jdb, char const *zIn, char const **pzOut,  SqlPreparedStmt **ppPreStmt );\n#endif\nstatic void dbReleaseColumnNames(DbEvalContext *p);\nstatic void dbReleaseStmt( Jsi_Db *jdb, SqlPreparedStmt *pPreStmt, int discard );\n\n\n/* Step statement. Return JSI_OK if there is a ROW result, JSI_BREAK if done, else JSI_ERROR. */\nstatic Jsi_RC dbEvalStepSub(DbEvalContext *p, int release, int *erc) {\n    int rcs;\n    Jsi_Db *jdb = p->jdb;\n    Jsi_Interp *interp = jdb->interp;\n    JSI_NOTUSED(interp);\n    SqlPreparedStmt *pPreStmt = p->pPreStmt;\n    SQLSIGASSERT(pPreStmt, STMT);\n    sqlite3_stmt *pStmt = pPreStmt->pStmt;\n\n    if (jdb->debug & TMODE_STEP)\n        JSI_DBQUERY_PRINTF( \"DEBUG: step: %s\\n\", pPreStmt->zSql);\n    rcs = sqlite3_step(pStmt);\n    if( rcs==SQLITE_BUSY ) {\n        if (erc) *erc = -2;\n        return JSI_ERROR;\n    }\n    if( rcs==SQLITE_ROW ) {\n        return JSI_OK;\n    }\n    if( p->pArray ) {\n        dbEvalRowInfo(p, 0, 0, 0);\n    }\n    rcs = sqlite3_reset(pStmt);\n\n    jdb->stepCnt = sqlite3_stmt_status(pStmt,SQLITE_STMTSTATUS_FULLSCAN_STEP,1);\n    jdb->sortCnt = sqlite3_stmt_status(pStmt,SQLITE_STMTSTATUS_SORT,1);\n    if (release==0 && rcs==SQLITE_OK)\n        return JSI_BREAK;\n    dbReleaseColumnNames(p);\n    p->pPreStmt = 0;\n\n    if( rcs!=SQLITE_OK ) {\n        /* If a run-time error occurs, report the error and stop reading\n        ** the SQL.  */\n        Jsi_LogError(\"%s\", sqlite3_errmsg(jdb->db));\n        dbReleaseStmt(jdb, pPreStmt, 1);\n        return JSI_ERROR;\n    } else {\n        dbReleaseStmt(jdb, pPreStmt, p->nocache);\n    }\n    return JSI_BREAK;\n}\n\nstatic Jsi_RC dbEvalInit(\n    Jsi_Interp *interp,\n    DbEvalContext *p,               /* Pointer to structure to initialize */\n    Jsi_Db *jdb,                  /* Database handle */\n    const char* zSql,                /* Value containing SQL script */\n    Jsi_DString *dStr,\n    Jsi_Obj *pArray,                /* Name of Jsi array to set (*) element of */\n    Jsi_Obj *pValVar                  /* Name element in array for list. */\n) {\n    p->dSql = dStr;\n    p->zSql = Jsi_DSAppend(p->dSql, zSql?zSql:\"\", NULL);\n    p->jdb = jdb;\n    return JSI_OK;\n}\n\nstatic void dbPrepStmtFree( Jsi_Db *jdb, SqlPreparedStmt *prep)\n{\n    if (prep->deleting)\n        return;\n    prep->deleting = 1;\n    if (prep->pStmt)\n        sqlite3_finalize( prep->pStmt );\n    if (prep->entry) {\n        Jsi_HashEntry *hPtr = prep->entry;\n        prep->entry = NULL;\n        Jsi_HashEntryDelete(hPtr);\n    }\n    if (prep->elPtr)\n        Jsi_ListEntryDelete(prep->elPtr);\n    Jsi_Free( (char*)prep );\n    jdb->stmtCacheCnt--;\n}\n\n/*\n** Finalize and free a list of prepared statements\n*/\n\nstatic void dbPrepStmtLimit( Jsi_Db *jdb)\n{\n    while(jdb->stmtCacheCnt>jdb->stmtCacheMax ) {\n        Jsi_ListEntry *l = Jsi_ListPopBack(jdb->stmtCache);\n        dbPrepStmtFree(jdb, (SqlPreparedStmt*)Jsi_ListValueGet(l));\n        jdb->stmtCacheCnt = Jsi_ListSize(jdb->stmtCache);\n    }\n}\n\n\nstatic Jsi_RC dbStmtFreeProc(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *value) {\n    Jsi_Db *jdb = (Jsi_Db*)interp;\n    Jsi_ListEntry *l = (Jsi_ListEntry*)hPtr;\n    SqlPreparedStmt *prep = (SqlPreparedStmt *)Jsi_ListValueGet(l);\n    prep->elPtr = NULL;\n    dbPrepStmtFree(jdb, prep);\n    return JSI_OK;\n}\n\n#ifndef JSI_LITE_ONLY\n\n/*\n** Finalize and free a list of prepared statements\n*/\nstatic void dbFlushStmtCache( Jsi_Db *jdb ) {\n    Jsi_ListClear(jdb->stmtCache);\n    jdb->stmtCacheCnt = 0;\n}\n\n#endif\n\n/*\n** Release a statement reference obtained by calling dbPrepareAndBind().\n** There should be exactly one call to this function for each call to\n** dbPrepareAndBind().\n**\n** If the discard parameter is non-zero, then the statement is deleted\n** immediately. Otherwise it is added to the LRU list and may be returned\n** by a subsequent call to dbPrepareAndBind().\n*/\nstatic void dbReleaseStmt(\n    Jsi_Db *jdb,                  /* Database handle */\n    SqlPreparedStmt *pPreStmt,      /* Prepared statement handle to release */\n    int discard                     /* True to delete (not cache) the pPreStmt */\n) {\n    //int i;\n    //Jsi_Interp *interp = jdb->interp;\n\n    /* Free the bound string and blob parameters */\n    /*for(i=0; i<pPreStmt->nParm; i++) {\n        Jsi_DecrRefCount(interp, pPreStmt->apParm[i]);\n    }*/\n    //pPreStmt->nParm = 0;\n\n    if( jdb->stmtCacheMax<=0 || discard ) {\n        /* If the cache is turned off, deallocated the statement */\n        dbPrepStmtFree(jdb, pPreStmt);\n    } else {\n        /* Add the prepared statement to the beginning of the cache list, then limit. */\n        if (!pPreStmt->elPtr)\n            pPreStmt->elPtr = Jsi_ListPushFrontNew(jdb->stmtCache, pPreStmt);\n        else\n            Jsi_ListPushFront(jdb->stmtCache, pPreStmt->elPtr);\n        dbPrepStmtLimit(jdb);\n        jdb->stmtCacheCnt = Jsi_ListSize(jdb->stmtCache);\n    }\n}\n\n/*\n** Release any cache of column names currently held as part of\n** the DbEvalContext structure passed as the first argument.\n*/\nstatic void dbReleaseColumnNames(DbEvalContext *p) {\n    //Jsi_Interp *interp = p->jdb->interp;\n\n    if( p->apColName && p->apColName != (char**)p->staticColNames) {\n        int i;\n        for(i=0; i<p->nCol; i++) {\n            Jsi_Free(p->apColName[i]);\n        }\n        Jsi_Free((char *)p->apColName);\n    }\n    if( p->apColType && p->apColType != p->staticColTypes) {\n        Jsi_Free((char *)p->apColType);\n    }\n    p->apColName = NULL;\n    p->apColType = NULL;\n    p->nCol = 0;\n}\n\n/*\n** Search the cache for a prepared-statement object that implements the\n** first SQL statement in the buffer pointed to by parameter zIn. If\n** no such prepared-statement can be found, allocate and prepare a new\n** one. In either case, bind the current values of the relevant Jsi\n** variables to any $var, :var or @var variables in the statement. Before\n** returning, set *ppPreStmt to point to the prepared-statement object.\n**\n** Output parameter *pzOut is set to point to the next SQL statement in\n** buffer zIn, or to the '\\0' byte at the end of zIn if there is no\n** next statement.\n**\n** If successful, JSI_OK is returned. Otherwise, JSI_ERROR is returned\n** and an error message loaded into interpreter jdb->interp.\n*/\nstatic Jsi_RC dbPrepareStmt(\n    Jsi_Db *jdb,                  /* Database object */\n    char const *zIn,                /* SQL to compile */\n    char const **pzOut,             /* OUT: Pointer to next SQL statement */\n    SqlPreparedStmt **ppPreStmt     /* OUT: Object used to cache statement */\n) {\n    const char *zSql = zIn;         /* Pointer to first SQL statement in zIn */\n    sqlite3_stmt *pStmt;            /* Prepared statement object */\n    SqlPreparedStmt *pPreStmt = 0;  /* Pointer to cached statement */\n   // int nSql;                       /* Length of zSql in bytes */\n    //int nVar;                       /* Number of variables in statement */\n    //int iParm = 0;                  /* Next free entry in apParm */\n    Jsi_RC rc = JSI_OK;\n    Jsi_Interp *interp = jdb->interp;\n    JSI_NOTUSED(interp);\n\n    *ppPreStmt = 0;\n\n    /* Trim spaces from the start of zSql and calculate the remaining length. */\n    while( isspace(zSql[0]) ) {\n        zSql++;\n    }\n    //nSql = Jsi_Strlen(zSql);\n    Jsi_HashEntry *entry = Jsi_HashEntryFind(jdb->stmtHash, zSql);\n    if (entry && ((pPreStmt = (SqlPreparedStmt*)Jsi_HashValueGet(entry)))) {\n        \n        if (jdb->debug & TMODE_PREPARE)\n            JSI_DBQUERY_PRINTF( \"DEBUG: prepare cache-hit: %s\\n\", zSql);\n        pStmt = pPreStmt->pStmt;\n        *pzOut = &zSql[pPreStmt->nSql];\n\n        /* When a prepared statement is found, unlink it from the\n        ** cache list.  It will later be added back to the beginning\n        ** of the cache list in order to implement LRU replacement.\n        */\n        Jsi_ListPop(jdb->stmtCache, pPreStmt->elPtr);\n        jdb->stmtCacheCnt = Jsi_ListSize(jdb->stmtCache);\n\n    }\n\n    /* If no prepared statement was found. Compile the SQL text. Also allocate\n    ** a new SqlPreparedStmt structure.  */\n    if( pPreStmt==0 ) {\n        int nByte;\n\n        if( SQLITE_OK!=sqlite3_prepare_v2(jdb->db, zSql, -1, &pStmt, pzOut) )\n        \n            return Jsi_LogError(\"PREPARE: %s\", sqlite3_errmsg(jdb->db));\n        if( pStmt==0 ) {\n            if( SQLITE_OK!=sqlite3_errcode(jdb->db) ) {\n                /* A compile-time error in the statement. */\n                Jsi_LogError(\"PREP: %s\", sqlite3_errmsg(jdb->db));\n                return JSI_ERROR;\n            } else {\n                /* The statement was a no-op.  Continue to the next statement\n                ** in the SQL string.\n                */\n                return JSI_OK;\n            }\n        }\n\n        if (jdb->debug & TMODE_PREPARE)\n            JSI_DBQUERY_PRINTF( \"DEBUG: prepare new: %s\\n\", zSql);\n        assert( pPreStmt==0 );\n        //nVar = sqlite3_bind_parameter_count(pStmt);\n        jdb->stmtCacheCnt++;\n        nByte = sizeof(SqlPreparedStmt); // + nVar*sizeof(Jsi_Obj *);\n        pPreStmt = (SqlPreparedStmt*)Jsi_Calloc(1, nByte);\n        pPreStmt->sig = SQLITE_SIG_STMT;\n\n        pPreStmt->pStmt = pStmt;\n        pPreStmt->nSql = (*pzOut - zSql);\n        pPreStmt->zSql = sqlite3_sql(pStmt);\n        bool isNew = 0;\n        pPreStmt->entry = Jsi_HashEntryNew(jdb->stmtHash, zSql, &isNew);\n        if (!isNew)\n            JSI_DBQUERY_PRINTF( \"sqlite dup stmt entry\");\n        Jsi_HashValueSet(pPreStmt->entry, pPreStmt);\n            \n        //pPreStmt->apParm = (Jsi_Value **)&pPreStmt[1];\n    }\n    assert( pPreStmt );\n    assert( Jsi_Strlen(pPreStmt->zSql)==pPreStmt->nSql );\n    assert( 0==memcmp(pPreStmt->zSql, zSql, pPreStmt->nSql) );\n    *ppPreStmt = pPreStmt;\n    //pPreStmt->nParm = iParm; \n    return rc;\n}\n\n\n#ifndef JSI_LITE_ONLY\n\n/*\n** Return one of JSI_OK, JSI_BREAK or JSI_ERROR. If JSI_ERROR is\n** returned, then an error message is stored in the interpreter before\n** returning.\n**\n** A return value of JSI_OK means there is a row of data available. The\n** data may be accessed using dbEvalRowInfo() and dbEvalColumnValue(). This\n** is analogous to a return of SQLITE_ROW from sqlite3_step(). If JSI_BREAK\n** is returned, then the SQL script has finished executing and there are\n** no further rows available. This is similar to SQLITE_DONE.\n*/\nstatic Jsi_RC dbEvalStep(DbEvalContext *p) {\n    while( p->zSql[0] || p->pPreStmt ) {\n        Jsi_RC rc;\n        if( p->pPreStmt==0 ) {\n            rc = dbPrepareAndBind(p->jdb, p->zSql, &p->zSql, &p->pPreStmt);\n            if( rc!=JSI_OK ) return rc;\n        }\n        rc = dbEvalStepSub(p, 1, NULL);\n        if (rc != JSI_BREAK)\n            return rc;\n    }\n    \n    /* Finished */\n    return JSI_BREAK;\n}\n\nstatic Jsi_RC dbBindStmt(Jsi_Db *jdb, SqlPreparedStmt *prep)\n{\n    sqlite3_stmt *pStmt = prep->pStmt;    /* Object used to cache statement */\n    Jsi_Interp *interp = jdb->interp;\n    int i, btype = 0, bindArr=0, n;\n    Jsi_RC rc = JSI_OK;\n    Jsi_Number r;\n    Jsi_Wide wv;\n \n    Jsi_Value *pv = NULL, *apv = NULL;\n    int nVar = sqlite3_bind_parameter_count(pStmt);\n    char tname[50];\n    \n   /* Bind values to parameters that begin with @, $, :, or ? */\n    for(i=1; i<=nVar; i++) {\n        tname[0] = 0;\n        int isInt = 0, isBlob = 0;\n        const char *zVar = sqlite3_bind_parameter_name(pStmt, i);\n        if (zVar == NULL) {\n            if (!jdb->optPtr || !(apv=jdb->optPtr->values)) \n                return Jsi_LogError(\"? bind without values for param %d\", i);\n            if (!(pv =Jsi_ValueArrayIndex(interp, apv, i-1))) \n                return Jsi_LogError(\"array element %d missing\", nVar);\n        }\n        else if((zVar[0]=='$' || zVar[0]==':' || zVar[0]=='@') ) {\n            int zvLen = Jsi_Strlen(zVar);\n            char *zcp;\n            if (zVar[0] =='$' && ((zcp = (char*)Jsi_Strchr(zVar,'('))) && zVar[zvLen-1] == ')')\n            {\n                bindArr = 1;\n                Jsi_DString vStr;\n                Jsi_DSInit(&vStr);\n                Jsi_DSAppendLen(&vStr, zVar+1, (zcp-zVar-1));\n                int slen = Jsi_Strlen(zcp);\n                const char *ttp;\n                if ((ttp = Jsi_Strchr(zVar,':'))) { // Extract bind-type.\n                    Jsi_DString tStr = {};\n                    int tlen = Jsi_Strlen(ttp+1);\n                    Jsi_DSAppendLen(&tStr, ttp+1, tlen-1);\n                    if (!jdb->typeNameHash)\n                        dbTypeNameHashInit(jdb);\n                    Jsi_HashEntry *htPtr = Jsi_HashEntryFind(jdb->typeNameHash, Jsi_DSValue(&tStr));\n                    int rc = ( htPtr != NULL);\n                    if (!htPtr) {\n                        Jsi_DString eStr = {};\n                        Jsi_HashSearch search;\n                        Jsi_Interp *interp = jdb->interp;\n                        int n = 0;\n                        Jsi_HashEntry *hPtr;\n                        for (hPtr = Jsi_HashSearchFirst(jdb->typeNameHash, &search);\n                            hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {\n                            const char *key = (char*)Jsi_HashKeyGet(hPtr);\n                            Jsi_DSAppend(&eStr, (n++?\", \":\"\"), key, NULL);\n                        }\n                        Jsi_LogWarn(\"bind type \\\"%s\\\" is not one of: %s\", Jsi_DSValue(&tStr), Jsi_DSValue(&eStr));\n                        Jsi_DSFree(&eStr);\n                    }\n                    Jsi_Strcpy(tname, Jsi_DSValue(&tStr));\n                    Jsi_DSFree(&tStr);\n                    if (!rc)\n                        return JSI_ERROR;\n\n                    btype = (uintptr_t)Jsi_HashValueGet(htPtr);\n                    Jsi_DSFree(&tStr);\n                    slen -= tlen;\n                }\n\n                if (isdigit(zcp[1])) {\n                    Jsi_DSAppendLen(&vStr, \"[\", 1);\n                    Jsi_DSAppendLen(&vStr, zcp+1, slen-2);\n                    Jsi_DSAppendLen(&vStr, \"]\", 1);\n                } else {\n                    if (zcp[1] != '[')\n                        Jsi_DSAppendLen(&vStr, \".\", 1);\n                    Jsi_DSAppendLen(&vStr, zcp+1, slen-2);\n                }\n                pv = Jsi_NameLookup(interp, Jsi_DSValue(&vStr));\n                Jsi_DSFree(&vStr);\n            } else\n                pv = Jsi_VarLookup(interp, &zVar[1]);\n        } else \n            return Jsi_LogError(\"can not find bind var %s\", zVar);\n            \n        if(!pv ) {\n            if (!jdb->bindWarn) {\n                Jsi_LogError(\"unknown bind param: %s\", zVar);\n                rc = JSI_ERROR;\n                break;\n            } else\n                Jsi_LogWarn(\"unknown bind param: %s\", zVar);\n        } else {\n            int match = 1, cast = (jdb->optPtr->typeCheck==dbTypeCheck_Cast);\n            if (btype && !Jsi_ValueIsUndef(interp, pv)) {\n                switch (btype) {\n                    case JSI_OPTION_STRBUF:\n                        isBlob = 1;\n                    case JSI_OPTION_STRING:\n                        if (cast)\n                            Jsi_ValueToString(interp, pv, &n);\n                        else\n                            match = Jsi_ValueIsString(interp, pv);\n                        break;\n                    case JSI_OPTION_NUMBER:\n                    case JSI_OPTION_DOUBLE:\n                        if (cast)\n                            Jsi_ValueToNumber(interp, pv);\n                        else\n                            match = Jsi_ValueIsNumber(interp, pv);\n                        break;\n                    case JSI_OPTION_TIME_W:\n                    case JSI_OPTION_TIME_T:\n                    case JSI_OPTION_INT64:\n                        isInt = 1;\n                        if (cast)\n                            Jsi_ValueToNumber(interp, pv);\n                        else\n                            match = Jsi_ValueIsNumber(interp, pv);\n                        break;\n                    case JSI_OPTION_BOOL:\n                        if (cast)\n                            Jsi_ValueToBool(interp, pv);\n                        else\n                            match = Jsi_ValueIsNumber(interp, pv);\n                        break;\n                    case JSI_OPTION_TIME_D:\n                        if (cast)\n                            Jsi_ValueToNumber(interp, pv); //TODO: do something more for dates?\n                        else\n                            match = Jsi_ValueIsNumber(interp, pv);\n                        break;\n                    default:\n                        Jsi_LogBug(\"Unhandled bind type: %s = %d\", tname, btype);\n                }\n                if (cast == 0 && match == 0) {\n                    int ltyp = (jdb->optPtr->typeCheck==dbTypeCheck_Error?JSI_LOG_ERROR:JSI_LOG_WARN);\n                    Jsi_LogMsg(interp, ltyp, \"bind param \\\"%s\\\" type is not \\\"%s\\\"\", zVar, tname);\n                    if (ltyp == JSI_LOG_ERROR)\n                        return JSI_ERROR;\n                }\n            }\n            bool bn, isArr;\n            const char *dectyp;\n            if (Jsi_ValueIsBoolean(interp, pv)) {\n                Jsi_GetBoolFromValue(interp, pv, &bn);\n                sqlite3_bind_int(pStmt, i, bn);\n            } else if (Jsi_ValueIsNumber(interp, pv)) {\n                Jsi_GetNumberFromValue(interp, pv, &r);\n                wv = (Jsi_Wide)r;\n                if (isInt || (jdb->forceInt && (((Jsi_Number)wv)-r)==0))\n                    sqlite3_bind_int64(pStmt, i,wv);\n                else\n                    sqlite3_bind_double(pStmt, i,(double)r);\n            } else if (Jsi_ValueIsNull(interp, pv) || (Jsi_ValueIsUndef(interp, pv) && jdb->queryOpts.mapundef)) {\n                sqlite3_bind_null(pStmt, i);\n            } else if (Jsi_ValueIsString(interp, pv)) {\n                const char *sstr = Jsi_ValueGetStringLen(interp, pv, &n);\n                if (!sstr) sstr = \"\";\n                if (isBlob)\n                    sqlite3_bind_blob(pStmt, i, (char *)sstr, n, SQLITE_TRANSIENT );\n                else\n                    sqlite3_bind_text(pStmt, i, (char *)sstr, n, SQLITE_TRANSIENT );\n            } else if (!jdb->noJsonConv && bindArr && ((isArr=Jsi_ValueIsArray(interp, pv))\n                || Jsi_ValueIsObjType(interp, pv, JSI_OT_OBJECT))\n                && (((dectyp = sqlite3_column_decltype(pStmt, i))==NULL) || \n                    !Jsi_Strncasecmp(dectyp,\"charjson\",8))) {\n                    // Limitation: on INSERT can not access decltype.\n                    Jsi_DString jStr = {};\n                    Jsi_ValueGetDString(interp, pv, &jStr, JSI_OUTPUT_JSON|JSI_JSON_STRICT);\n                    n = Jsi_DSLength(&jStr);\n                    sqlite3_bind_text(pStmt, i, Jsi_DSValue(&jStr), n, SQLITE_TRANSIENT );\n                    Jsi_DSFree(&jStr);\n            } else {\n                if (!jdb->bindWarn) {\n                    Jsi_LogError(\"bind param must be string/number/bool/null: %s\", zVar);\n                    rc = JSI_ERROR;\n                    break;\n                } else\n                    Jsi_LogWarn(\"bind param must be string/number/bool/null: %s\", zVar);\n                sqlite3_bind_null(pStmt, i);\n            }\n\n        }\n    }\n    return rc;\n}\n\nstatic Jsi_RC dbPrepareAndBind(\n    Jsi_Db *jdb,                  /* Database object */\n    char const *zIn,                /* SQL to compile */\n    char const **pzOut,             /* OUT: Pointer to next SQL statement */\n    SqlPreparedStmt **ppPreStmt     /* OUT: Object used to cache statement */\n) {\n    if (dbPrepareStmt(jdb, zIn, pzOut, ppPreStmt) != JSI_OK)\n        return JSI_ERROR;\n    return dbBindStmt(jdb, *ppPreStmt);\n}\n#endif\n\n/*\n** Free all resources currently held by the DbEvalContext structure passed\n** as the first argument. There should be exactly one call to this function\n** for each call to dbEvalInit(interp,).\n*/\nstatic void dbEvalFinalize(DbEvalContext *p) {\n//  Jsi_Interp *interp = p->jdb->interp;\n\n    if( p->pPreStmt ) {\n        sqlite3_reset(p->pPreStmt->pStmt);\n        dbReleaseStmt(p->jdb, p->pPreStmt, p->nocache);\n        p->pPreStmt = 0;\n    }\n    if (p->dSql)\n        Jsi_DSFree(p->dSql);\n    dbReleaseColumnNames(p);\n}\n\nstatic void DbClose(sqlite3 *db) {\n        sqlite3_close(db);\n}\n\n#ifndef JSI_LITE_ONLY\n\nstatic Jsi_RC sqliteObjFree(Jsi_Interp *interp, void *data);\nstatic bool  sqliteObjEqual(void *data1, void *data2);\nstatic bool  sqliteObjIsTrue(void *data);\n\nstatic Jsi_RC dbIsNumArray(Jsi_Interp *interp, Jsi_Value *value, Jsi_OptionSpec* spec, void *record)\n{\n    if (!Jsi_ValueIsArray(interp, value)) \n        return Jsi_LogError(\"expected array of numbers\");\n    int i, argc = Jsi_ValueGetLength(interp, value);\n    for (i=0; i<argc; i++) {\n        Jsi_Value *v = Jsi_ValueArrayIndex(interp, value, i);\n        if (!Jsi_ValueIsNumber(interp, v)) \n            return Jsi_LogError(\"expected array of numbers\");\n    }\n    return JSI_OK;\n}\n\n\n/*\n** JSI calls this procedure when an sqlite3 database command is\n** deleted.\n*/\nstatic void dbDeleteCmd(Jsi_Db *jdb)\n{\n    Jsi_Interp *interp = jdb->interp;\n    if (jdb->debug & TMODE_DELETE)\n        JSI_DBQUERY_PRINTF( \"DEBUG: delete\\n\");\n    dbFlushStmtCache(jdb);\n    if (jdb->stmtHash)\n        Jsi_HashDelete(jdb->stmtHash);\n    //closeIncrblobChannels(jdb);\n    if (jdb->db) {\n        DbClose(jdb->db);\n    }\n    while( jdb->pFunc ) {\n        SqlFunc *pFunc = jdb->pFunc;\n        jdb->pFunc = pFunc->pNext;\n        Jsi_DSFree(&pFunc->dScript);\n        Jsi_DecrRefCount(interp, pFunc->tocall);\n        Jsi_Free((char*)pFunc);\n    }\n    while( jdb->pCollate ) {\n        SqlCollate *pCollate = jdb->pCollate;\n        jdb->pCollate = pCollate->pNext;\n        Jsi_Free((char*)pCollate);\n    }\n\n    Jsi_OptionsFree(interp, SqlOptions, jdb, 0);\n    if (jdb->stmtCache)\n        Jsi_ListDelete(jdb->stmtCache);\n}\n\nstatic int dbGetIntBool(Jsi_Interp *interp, Jsi_Value* v)\n{\n    if (Jsi_ValueIsNumber(interp, v)) {\n        Jsi_Number d;\n        Jsi_ValueGetNumber(interp, v, &d);\n        return (int)d;\n    }\n    if (Jsi_ValueIsBoolean(interp, v)) {\n        bool n;\n        Jsi_ValueGetBoolean(interp, v, &n);\n        return n;\n    }\n    return 0;\n}\n\n\n/*\n** This routine is called when a database file is locked while trying\n** to execute SQL.\n*/\nstatic int dbBusyHandler(void *cd, int nTries) {\n    int rc;\n    Jsi_Db *jdb = (Jsi_Db*)cd;\n    Jsi_Value *vpargs, *items[3] = {}, *ret;\n    Jsi_Interp *interp = jdb->interp;\n\n    items[0] = Jsi_ValueNewObj(interp, jdb->fobj);\n    items[1] = Jsi_ValueMakeNumber(interp, NULL, (Jsi_Number)nTries);\n    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, 2, 0));\n    Jsi_IncrRefCount(interp, vpargs);\n    ret = Jsi_ValueNew1(interp);\n    rc = Jsi_FunctionInvoke(interp, jdb->onBusy, vpargs, &ret, NULL);\n    if( JSI_OK!=rc ) {\n        jdb->errCnt++;\n        rc = 1;\n    } else\n        rc = dbGetIntBool(interp, ret);\n    Jsi_DecrRefCount(interp, vpargs);\n    Jsi_DecrRefCount(interp, ret);\n    return rc;\n}\n\n/*\n** This routine is invoked as the 'progress callback' for the database.\n*/\nstatic int dbProgressHandler(void *cd) {\n    Jsi_Db *jdb = (Jsi_Db*)cd;\n    Jsi_Value *vpargs, *items[3] = {}, *ret;\n    Jsi_Interp *interp = jdb->interp;\n\n    items[0] = Jsi_ValueNewObj(interp, jdb->fobj);\n    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, 1, 0));\n    Jsi_IncrRefCount(interp, vpargs);\n    ret = Jsi_ValueNew1(interp);\n    int rc = Jsi_FunctionInvoke(interp, jdb->onProgress, vpargs, &ret, NULL);\n    if( JSI_OK!=rc ) {\n        jdb->errCnt++;\n        rc = 1;\n    } else\n        rc = dbGetIntBool(interp, ret);\n    Jsi_DecrRefCount(interp, vpargs);\n    Jsi_DecrRefCount(interp, ret);\n    return rc;\n}\n\n/*\n** This routine is called by the SQLite trace handler whenever a new\n** block of SQL is executed.  The JSI script in jdb->onTrace is executed.\n*/\nstatic void dbTraceHandler(void *cd, const char *zSql)\n{\n    int rc;\n    Jsi_Db *jdb = (Jsi_Db*)cd;\n    Jsi_Value *vpargs, *items[2] = {}, *ret;\n    Jsi_Interp *interp = jdb->interp;\n    items[0] = Jsi_ValueNewObj(interp, jdb->fobj);\n    items[1] = Jsi_ValueMakeStringDup(interp, NULL, zSql);\n    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, 2, 0));\n    Jsi_IncrRefCount(interp, vpargs);\n    ret = Jsi_ValueNew1(interp);\n    rc = Jsi_FunctionInvoke(interp, jdb->onTrace, vpargs, &ret, NULL);\n    Jsi_DecrRefCount(interp, vpargs);\n    Jsi_DecrRefCount(interp, ret);\n    if (rc != JSI_OK)\n        jdb->errCnt++;\n}\n\n/*\n** This routine is called by the SQLite profile handler after a statement\n** SQL has executed.  The JSI script in jdb->onProfile is evaluated.\n*/\nstatic void dbProfileHandler(void *cd, const char *zSql, sqlite_uint64 tm) {\n    int rc;\n    Jsi_Db *jdb = (Jsi_Db*)cd;\n    Jsi_Interp *interp = jdb->interp;\n    Jsi_Value *vpargs, *items[3] = {}, *ret;\n\n    items[0] = Jsi_ValueNewObj(interp, jdb->fobj);\n    items[1] = Jsi_ValueMakeStringDup(interp, NULL, zSql);\n    items[2] = Jsi_ValueMakeNumber(interp, NULL, (Jsi_Number)tm);\n    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, 3, 0));\n    Jsi_IncrRefCount(interp, vpargs);\n    ret = Jsi_ValueNew1(interp);\n    rc = Jsi_FunctionInvoke(interp, jdb->onProfile, vpargs, &ret, NULL);\n    Jsi_DecrRefCount(interp, vpargs);\n    Jsi_DecrRefCount(interp, ret);\n    if (rc != JSI_OK)\n        jdb->errCnt++;\n}\n\n/*\n** This routine is called when a transaction is committed.  The\n** JSI script in jdb->onCommit is executed.  If it returns non-zero or\n** if it throws an exception, the transaction is rolled back instead\n** of being committed.\n*/\nstatic int dbCommitHandler(void *cd) {\n    int rc = 0;\n    Jsi_Db *jdb = (Jsi_Db*)cd;\n    Jsi_Interp *interp = jdb->interp;\n    Jsi_Value *vpargs, *items[2] = {}, *ret = Jsi_ValueNew1(interp);\n    \n    items[0] = Jsi_ValueNewObj(interp, jdb->fobj);\n    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, 1, 0));\n    Jsi_IncrRefCount(interp, vpargs);\n    if( JSI_OK!=Jsi_FunctionInvoke(interp, jdb->onCommit, NULL, &ret, NULL) ) {\n        jdb->errCnt++;\n        rc = 1;\n    } else\n        rc = dbGetIntBool(interp, ret);\n    Jsi_DecrRefCount(interp, vpargs);\n    Jsi_DecrRefCount(interp, ret);\n    return rc;\n}\n\n/*\n** This procedure handles wal_hook callbacks.\n*/\nstatic int dbWalHandler( void *cd, sqlite3 *db, const char *zDb, int nEntry ){\n    int rc;\n    Jsi_Db *jdb = (Jsi_Db*)cd;\n    Jsi_Interp *interp = jdb->interp;\n    Jsi_Value *vpargs, *items[3] = {}, *ret;\n\n    items[0] = Jsi_ValueNewObj(interp, jdb->fobj);\n    items[1] = Jsi_ValueMakeStringDup(interp, NULL, zDb);\n    items[2] = Jsi_ValueMakeNumber(interp, NULL, (Jsi_Number)nEntry);\n    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, 3, 0));\n    Jsi_IncrRefCount(interp, vpargs);\n    ret = Jsi_ValueNew(interp);\n    rc = Jsi_FunctionInvoke(interp, jdb->onWalHook, vpargs, &ret, NULL);\n    Jsi_DecrRefCount(interp, vpargs);\n    if (rc != JSI_OK) {\n        jdb->errCnt++;\n        rc = 1;\n    } else\n        rc = dbGetIntBool(jdb->interp, ret);\n    Jsi_DecrRefCount(interp, ret);\n    return rc;\n}\n \nstatic void dbRollbackHandler(void *cd) {\n    Jsi_Db *jdb = (Jsi_Db*)cd;\n    Jsi_Interp *interp = jdb->interp;\n    Jsi_Value *vpargs, *items[2] = {}, *ret = Jsi_ValueNew1(interp);\n    \n    items[0] = Jsi_ValueNewObj(interp, jdb->fobj);\n    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, 1, 0));\n    Jsi_IncrRefCount(interp, vpargs);\n    Jsi_FunctionInvoke(interp, jdb->onRollback, NULL, &ret, NULL);\n    Jsi_DecrRefCount(interp, vpargs);\n    Jsi_DecrRefCount(interp, ret);\n}\n\n\nstatic void dbUpdateHandler(\n    void *p,\n    int op,\n    const char *zDb,\n    const char *zTbl,\n    sqlite_int64 rowid\n) {\n    Jsi_Db *jdb = (Jsi_Db *)p;\n    Jsi_Interp *interp = jdb->interp;\n    int rc, i = 0;\n    Jsi_Value *vpargs, *items[10] = {}, *ret;\n    \n    assert( op==SQLITE_INSERT || op==SQLITE_UPDATE || op==SQLITE_DELETE );\n    items[i++] = Jsi_ValueNewObj(interp, jdb->fobj);\n    items[i++] = Jsi_ValueMakeStringDup(interp, NULL, (op==SQLITE_INSERT)?\"INSERT\":(op==SQLITE_UPDATE)?\"UPDATE\":\"DELETE\");\n    items[i++] = Jsi_ValueMakeStringDup(interp, NULL, zDb);\n    items[i++] = Jsi_ValueMakeStringDup(interp, NULL, zTbl);\n    items[i++] = Jsi_ValueMakeNumber(interp, NULL, (Jsi_Number)rowid);\n    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, i, 0));\n    Jsi_IncrRefCount(interp, vpargs);\n    ret = Jsi_ValueNew1(interp);\n    rc = Jsi_FunctionInvoke(interp, jdb->onUpdate, vpargs, &ret, NULL);\n    Jsi_DecrRefCount(interp, vpargs);\n    Jsi_DecrRefCount(interp, ret);\n    if (rc != JSI_OK)\n        jdb->errCnt++;\n}\n\nstatic void dbCollateNeeded(\n    void *cd,\n    sqlite3 *db,\n    int enc,\n    const char *zName\n) {\n    int rc;\n    Jsi_Db *jdb = (Jsi_Db*)cd;\n    Jsi_Interp *interp = jdb->interp;\n    Jsi_Value *vpargs, *items[2], *ret;\n    items[0] = Jsi_ValueNewObj(interp, jdb->fobj);\n    items[1] = Jsi_ValueMakeStringDup(interp, NULL, zName);\n    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, 2, 0));\n    Jsi_IncrRefCount(interp, vpargs);\n    ret = Jsi_ValueNew1(interp);\n    rc = Jsi_FunctionInvoke(interp, jdb->onNeedCollate, vpargs,& ret, NULL);\n    Jsi_DecrRefCount(interp, vpargs);\n    Jsi_DecrRefCount(interp, ret);\n    if (rc != JSI_OK)\n        jdb->errCnt++;\n\n}\n\n/*\n** This routine is called to evaluate an SQL collation function implemented\n** using JSI script.\n*/\nstatic int dbSqlCollate(\n    void *pCtx,\n    int nA,\n    const void *zA,\n    int nB,\n    const void *zB\n) {\n    SqlCollate *p = (SqlCollate *)pCtx;\n    Jsi_Interp *interp = p->interp;\n\n    int rc;\n    //Jsi_Db *jdb = (Jsi_Db*)cd;\n    Jsi_Value *vpargs, *items[3], *ret;\n\n    items[0] = Jsi_ValueNewObj(interp, p->jdb->fobj);\n    items[1] = Jsi_ValueMakeStringDup(interp, NULL, (char*)zA);\n    items[2] = Jsi_ValueMakeStringDup(interp, NULL, (char*)zB);\n    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, 3, 0));\n    ret = Jsi_ValueNew1(interp);\n    rc = Jsi_FunctionInvoke(interp, p->zScript, vpargs, &ret, NULL);\n    if( JSI_OK!=rc ) {\n        //jdb->errCnt++;\n        rc = 0;\n    } else\n        rc = dbGetIntBool(interp, ret);\n    Jsi_DecrRefCount(interp, vpargs);\n    Jsi_DecrRefCount(interp, ret);\n    return rc;\n}\n\nstatic Jsi_Value* dbGetValueGet(Jsi_Interp *interp, sqlite3_value *pIn)\n{\n    Jsi_Value *v = Jsi_ValueNew(interp);\n    switch (sqlite3_value_type(pIn)) {\n    case SQLITE_BLOB: {\n        int bytes;\n        bytes = sqlite3_value_bytes(pIn);\n        const char *zBlob = (char*) sqlite3_value_blob(pIn);\n        if(!zBlob ) {\n            return Jsi_ValueMakeNull(interp, &v);\n        }\n        unsigned char *uptr = (unsigned char*)Jsi_Malloc(bytes+1);\n        memcpy(uptr, zBlob, bytes);\n        uptr[bytes] = 0;\n        return Jsi_ValueMakeBlob(interp, &v, uptr, bytes);\n    }\n    case SQLITE_INTEGER: {\n        sqlite_int64 n = sqlite3_value_int64(pIn);\n        if( n>=-2147483647 && n<=2147483647 ) {\n            return Jsi_ValueMakeNumber(interp, &v, n);\n        } else {\n            return Jsi_ValueMakeNumber(interp, &v, n);\n        }\n    }\n    case SQLITE_FLOAT: {\n        return Jsi_ValueMakeNumber(interp, &v, (Jsi_Number)sqlite3_value_double(pIn));\n    }\n    case SQLITE_NULL: {\n        return Jsi_ValueMakeNull(interp, &v);\n    }\n    default:\n        return Jsi_ValueMakeStringDup(interp, &v, (char *)sqlite3_value_text(pIn));\n    }\n    return v;\n}\n\nstatic void jsiSqlFuncUnixTime(sqlite3_context *context, int argc, sqlite3_value**argv) {\n    Jsi_Db *jdb = (Jsi_Db*)sqlite3_user_data(context);\n    SQLSIGASSERT(jdb,DB);\n    Jsi_Interp *interp = jdb->interp;\n    if (argc>3) {\n        Jsi_LogWarn(\"sqlite unixtime, expected: str fmt isutc\");\n        return;\n    }\n    const char *str = NULL, *fmt = NULL;\n    bool isUtc = 0;\n    if (argc>=1)\n        str = (char *)sqlite3_value_text(argv[0]);\n    if (argc>=2)\n        fmt = (char *)sqlite3_value_text(argv[1]);\n    if (argc>=3)\n        isUtc = (bool)sqlite3_value_int64(argv[2]);\n    Jsi_Number d = 0;\n    Jsi_DatetimeParse(interp, str, fmt, isUtc, &d, 0);\n    sqlite3_result_double(context, (double)d);\n}\n\nstatic void jsiSqlFunc(sqlite3_context *context, int argc, sqlite3_value**argv) {\n    SqlFunc *p = (SqlFunc*)sqlite3_user_data(context);\n    int i;\n    int rc;\n    Jsi_Interp *interp = p->interp;\n    Jsi_Value *vpargs, *itemsStatic[100], **items = itemsStatic, *ret;\n    if (argc>100)\n        items = (Jsi_Value**)Jsi_Calloc(argc, sizeof(Jsi_Value*));\n\n    for(i=0; i<argc; i++) {\n        items[i] = dbGetValueGet(interp, argv[i]);\n    }\n    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, argc, 0));\n    Jsi_IncrRefCount(interp, vpargs);\n    ret = Jsi_ValueNew1(interp);\n    rc = Jsi_FunctionInvoke(interp, p->tocall, vpargs, &ret, NULL);\n    Jsi_DecrRefCount(interp, vpargs);\n    if (items != itemsStatic)\n        Jsi_Free(items);\n\n    bool b;\n    if( rc != JSI_OK) {\n        char buf[JSI_BUFSIZ];\n        snprintf(buf, sizeof(buf), \"error in function: %.200s\", p->zName);\n        sqlite3_result_error(context, buf, -1);\n\n    } else if (Jsi_ValueIsBoolean(interp, ret)) {\n        Jsi_GetBoolFromValue(interp, ret, &b);\n        sqlite3_result_int(context, b);\n    } else if (Jsi_ValueIsNumber(interp, ret)) {\n        Jsi_Number d;\n        // if (Jsi_GetIntFromValueBase(interp, ret, &i, 0, JSI_NO_ERRMSG);\n        // sqlite3_result_int64(context, v);\n        Jsi_GetNumberFromValue(interp, ret, &d);\n        sqlite3_result_double(context, (double)d);\n    } else {\n        const char * data;\n        if (!(data = Jsi_ValueGetStringLen(interp, ret, &i))) {\n            //TODO: handle objects???\n            data = Jsi_ValueToString(interp, ret, NULL);\n            i = Jsi_Strlen(data);\n        }\n        sqlite3_result_text(context, (char *)data, i, SQLITE_TRANSIENT );\n    }\n    Jsi_DecrRefCount(interp, ret);\n}\n\n/*\n** This is the authentication function.  It appends the authentication\n** type code and the two arguments to zCmd[] then invokes the result\n** on the interpreter.  The reply is examined to determine if the\n** authentication fails or succeeds.\n*/\nstatic int dbAuthCallback(\n    void *pArg,\n    int code,\n    const char *zArg1,\n    const char *zArg2,\n    const char *zArg3,\n    const char *zArg4\n) {\n    const char *zCode;\n    int rc;\n    const char *zReply;\n    Jsi_Db *jdb = (Jsi_Db*)pArg;\n    Jsi_Interp *interp = jdb->interp;\n    if( jdb->disableAuth ) return SQLITE_OK;\n\n    switch( code ) {\n    case SQLITE_COPY              :\n        zCode=\"SQLITE_COPY\";\n        break;\n    case SQLITE_CREATE_INDEX      :\n        zCode=\"SQLITE_CREATE_INDEX\";\n        break;\n    case SQLITE_CREATE_TABLE      :\n        zCode=\"SQLITE_CREATE_TABLE\";\n        break;\n    case SQLITE_CREATE_TEMP_INDEX :\n        zCode=\"SQLITE_CREATE_TEMP_INDEX\";\n        break;\n    case SQLITE_CREATE_TEMP_TABLE :\n        zCode=\"SQLITE_CREATE_TEMP_TABLE\";\n        break;\n    case SQLITE_CREATE_TEMP_TRIGGER:\n        zCode=\"SQLITE_CREATE_TEMP_TRIGGER\";\n        break;\n    case SQLITE_CREATE_TEMP_VIEW  :\n        zCode=\"SQLITE_CREATE_TEMP_VIEW\";\n        break;\n    case SQLITE_CREATE_TRIGGER    :\n        zCode=\"SQLITE_CREATE_TRIGGER\";\n        break;\n    case SQLITE_CREATE_VIEW       :\n        zCode=\"SQLITE_CREATE_VIEW\";\n        break;\n    case SQLITE_DELETE            :\n        zCode=\"SQLITE_DELETE\";\n        break;\n    case SQLITE_DROP_INDEX        :\n        zCode=\"SQLITE_DROP_INDEX\";\n        break;\n    case SQLITE_DROP_TABLE        :\n        zCode=\"SQLITE_DROP_TABLE\";\n        break;\n    case SQLITE_DROP_TEMP_INDEX   :\n        zCode=\"SQLITE_DROP_TEMP_INDEX\";\n        break;\n    case SQLITE_DROP_TEMP_TABLE   :\n        zCode=\"SQLITE_DROP_TEMP_TABLE\";\n        break;\n    case SQLITE_DROP_TEMP_TRIGGER :\n        zCode=\"SQLITE_DROP_TEMP_TRIGGER\";\n        break;\n    case SQLITE_DROP_TEMP_VIEW    :\n        zCode=\"SQLITE_DROP_TEMP_VIEW\";\n        break;\n    case SQLITE_DROP_TRIGGER      :\n        zCode=\"SQLITE_DROP_TRIGGER\";\n        break;\n    case SQLITE_DROP_VIEW         :\n        zCode=\"SQLITE_DROP_VIEW\";\n        break;\n    case SQLITE_INSERT            :\n        zCode=\"SQLITE_INSERT\";\n        break;\n    case SQLITE_PRAGMA            :\n        zCode=\"SQLITE_PRAGMA\";\n        break;\n    case SQLITE_READ              :\n        zCode=\"SQLITE_READ\";\n        break;\n    case SQLITE_SELECT            :\n        zCode=\"SQLITE_SELECT\";\n        break;\n    case SQLITE_TRANSACTION       :\n        zCode=\"SQLITE_TRANSACTION\";\n        break;\n    case SQLITE_UPDATE            :\n        zCode=\"SQLITE_UPDATE\";\n        break;\n    case SQLITE_ATTACH            :\n        zCode=\"SQLITE_ATTACH\";\n        break;\n    case SQLITE_DETACH            :\n        zCode=\"SQLITE_DETACH\";\n        break;\n    case SQLITE_ALTER_TABLE       :\n        zCode=\"SQLITE_ALTER_TABLE\";\n        break;\n    case SQLITE_REINDEX           :\n        zCode=\"SQLITE_REINDEX\";\n        break;\n    case SQLITE_ANALYZE           :\n        zCode=\"SQLITE_ANALYZE\";\n        break;\n    case SQLITE_CREATE_VTABLE     :\n        zCode=\"SQLITE_CREATE_VTABLE\";\n        break;\n    case SQLITE_DROP_VTABLE       :\n        zCode=\"SQLITE_DROP_VTABLE\";\n        break;\n    case SQLITE_FUNCTION          :\n        zCode=\"SQLITE_FUNCTION\";\n        break;\n    case SQLITE_SAVEPOINT         :\n        zCode=\"SQLITE_SAVEPOINT\";\n        break;\n    default                       :\n        zCode=\"????\";\n        break;\n    }\n    int i = 0;\n    Jsi_Value *vpargs, *items[10] = {}, *ret;\n    items[i++] = Jsi_ValueNewObj(interp, jdb->fobj);\n    items[i++] = Jsi_ValueMakeStringDup(interp, NULL, zCode);\n    items[i++] = Jsi_ValueMakeStringDup(interp, NULL, zArg1 ? zArg1 : \"\");\n    items[i++] = Jsi_ValueMakeStringDup(interp, NULL, zArg2 ? zArg2 : \"\");\n    items[i++] = Jsi_ValueMakeStringDup(interp, NULL, zArg3 ? zArg3 : \"\");\n    items[i++] = Jsi_ValueMakeStringDup(interp, NULL, zArg4 ? zArg4 : \"\");\n    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, i, 0));\n    Jsi_IncrRefCount(interp, vpargs);\n    ret = Jsi_ValueNew(interp);\n    rc = Jsi_FunctionInvoke(interp, jdb->onAuth, vpargs, &ret, NULL);\n    Jsi_DecrRefCount(interp, vpargs);\n\n    if (rc == JSI_OK && (zReply = Jsi_ValueGetStringLen(interp, ret, NULL)))\n    {\n        if( Jsi_Strcmp(zReply,\"SQLITE_OK\")==0 ) {\n            rc = SQLITE_OK;\n        } else if( Jsi_Strcmp(zReply,\"SQLITE_DENY\")==0 ) {\n            rc = SQLITE_DENY;\n        } else if( Jsi_Strcmp(zReply,\"SQLITE_IGNORE\")==0 ) {\n            rc = SQLITE_IGNORE;\n        } else {\n            rc = 999;\n        }\n    }\n    Jsi_DecrRefCount(interp, ret);\n    return rc;\n}\n\n/*\n** This routine reads a line of text from FILE in, stores\n** the text in memory obtained from malloc() and returns a pointer\n** to the text.  NULL is returned at end of file, or if malloc()\n** fails.\n**\n** The interface is like \"readline\" but no command-line editing\n** is done.\n**\n** copied from shell.c from '.import' command\n*/\nstatic char *dbLocalGetline(Jsi_Interp *interp, char *zPrompt, Jsi_Channel in) {\n    char *zLine;\n    int nLine;\n    int n;\n    int eol;\n\n    nLine = 100;\n    zLine = (char*)Jsi_Malloc( nLine );\n    if( zLine==0 ) return 0;\n    n = 0;\n    eol = 0;\n    while( !eol ) {\n        if( n+100>nLine ) {\n            nLine = nLine*2 + 100;\n            zLine = (char*)Jsi_Realloc(zLine, nLine);\n            if( zLine==0 ) return 0;\n        }\n        if( Jsi_Gets(interp, in, &zLine[n], nLine - n)==0 ) {\n            if( n==0 ) {\n                Jsi_Free(zLine);\n                return 0;\n            }\n            zLine[n] = 0;\n            eol = 1;\n            break;\n        }\n        while( zLine[n] ) {\n            n++;\n        }\n        if( n>0 && zLine[n-1]=='\\n' ) {\n            n--;\n            zLine[n] = 0;\n            eol = 1;\n        }\n    }\n    zLine = (char*)Jsi_Realloc( zLine, n+1 );\n    return zLine;\n}\n\n\n/*\n** This function is part of the implementation of the command:\n**\n**   $db transaction [-deferred|-immediate|-exclusive] SCRIPT\n**\n** It is invoked after evaluating the script SCRIPT to commit or rollback\n** the transaction or savepoint opened by the [transaction] command.\n*/\nstatic Jsi_RC dbTransPostCmd(\n    Jsi_Db *jdb,                       /* Sqlite3Db for $db */\n    Jsi_Interp *interp,                  /* Jsi interpreter */\n    Jsi_RC result                           /* Result of evaluating SCRIPT */\n) {\n    static const char *azEnd[] = {\n        \"RELEASE _jsi_transaction\",        /* rc==JSI_ERROR, nTransaction!=0 */\n        \"COMMIT\",                          /* rc!=JSI_ERROR, nTransaction==0 */\n        \"ROLLBACK TO _jsi_transaction ; RELEASE _jsi_transaction\",\n        \"ROLLBACK\"                         /* rc==JSI_ERROR, nTransaction==0 */\n    };\n    Jsi_RC rc = result;\n    const char *zEnd;\n\n    jdb->nTransaction--;\n    zEnd = azEnd[(rc==JSI_ERROR)*2 + (jdb->nTransaction==0)];\n\n    jdb->disableAuth++;\n    if( sqlite3_exec(jdb->db, zEnd, 0, 0, 0)) {\n        /* This is a tricky scenario to handle. The most likely cause of an\n        ** error is that the exec() above was an attempt to commit the\n        ** top-level transaction that returned SQLITE_BUSY. Or, less likely,\n        ** that an IO-error has occured. In either case, throw a Jsi exception\n        ** and try to rollback the transaction.\n        **\n        ** But it could also be that the user executed one or more BEGIN,\n        ** COMMIT, SAVEPOINT, RELEASE or ROLLBACK commands that are confusing\n        ** this method's logic. Not clear how this would be best handled.\n        */\n        if( rc!=JSI_ERROR ) {\n            Jsi_LogError(\"%s\", sqlite3_errmsg(jdb->db));\n            rc = JSI_ERROR;\n        }\n        sqlite3_exec(jdb->db, \"ROLLBACK\", 0, 0, 0);\n    }\n    jdb->disableAuth--;\n\n    return rc;\n}\n\n\n\n#if 0\nstatic void dbEvalRowInfo(\n    DbEvalContext *p,               /* Evaluation context */\n    int *pnCol,                     /* OUT: Number of column names */\n    char ***papColName,           /* OUT: Array of column names */\n    int **papColType\n) {\n    /* Compute column names */\n    // Jsi_Interp *interp = p->jdb->interp;\n\n    if( 0==p->apColName ) {\n        sqlite3_stmt *pStmt = p->pPreStmt->pStmt;\n        int i;                        /* Iterator variable */\n        int nCol;                     /* Number of columns returned by pStmt */\n        char **apColName = 0;      /* Array of column names */\n        int *apColType = 0;\n        const char *zColName;         /* Column name */\n        int numRid = 0;               /* Number of times rowid seen. */\n\n        p->nCol = nCol = sqlite3_column_count(pStmt);\n        if( nCol>0 && (papColName || p->pArray) ) {\n            int cnLen = sizeof(char*)*nCol, cnStart = cnLen;\n            for(i=0; i<nCol && cnLen<sizeof(p->staticColNames); i++)\n                cnLen += Jsi_Strlen(sqlite3_column_name(pStmt,i))+1;\n            if (cnLen>=sizeof(p->staticColNames)) {\n                apColName = (char**)Jsi_Calloc(nCol, sizeof(char*) );\n                cnStart = 0;\n            } else {\n                apColName = (char**)p->staticColNames;\n            }\n            if (papColType) {\n                if (nCol < SQL_MAX_STATIC_TYPES)\n                    apColType = p->staticColTypes;\n                else\n                    apColType = (int*)Jsi_Calloc(nCol, sizeof(int));\n            }\n            for(i=0; i<nCol; i++) {\n                zColName = sqlite3_column_name(pStmt,i);\n                if (cnStart==0)\n                    apColName[i] = Jsi_Strdup(zColName);\n                else {\n                    apColName[i] = p->staticColNames+cnStart;\n                    Jsi_Strcpy(apColName[i], zColName);\n                    cnStart += Jsi_Strlen(zColName)+1;\n                }\n                if (apColType)\n                    apColType[i] = sqlite3_column_type(pStmt,i);\n                /* Check if rowid appears first, and more than once. */\n                if ((i == 0 || numRid>0) &&\n                        (zColName[0] == 'r' && Jsi_Strcmp(zColName,\"rowid\") == 0)) {\n                    numRid++;\n                }\n            }\n            /* Change first rowid to oid. */\n            if (numRid > 1) {\n                if (apColName != (char**)p->staticColNames) {\n                    Jsi_Free(apColName[0]);\n                    apColName[0] = Jsi_Strdup(\"oid\");\n                } else {\n                    Jsi_Strcpy(apColName[0], \"oid\");\n                }\n            }\n            p->apColName = apColName;\n            p->apColType = apColType;\n        }\n    }\n    if( papColName ) {\n        *papColName = p->apColName;\n    }\n    if( papColType ) {\n        *papColType = p->apColType;\n    }\n    if( pnCol ) {\n        *pnCol = p->nCol;\n    }\n}\n#endif\n\n/*\n** Return a JSON formatted value for the iCol'th column of the row currently pointed to by\n** the DbEvalContext structure passed as the first argument.\n*/\nstatic void dbEvalSetColumnJSON(DbEvalContext *p, int iCol, Jsi_DString *dStr) {\n    Jsi_Interp *interp = p->jdb->interp;\n    char nbuf[JSI_MAX_NUMBER_STRING];\n\n    sqlite3_stmt *pStmt = p->pPreStmt->pStmt;\n\n    switch( sqlite3_column_type(pStmt, iCol) ) {\n    case SQLITE_BLOB: {\n        int bytes = sqlite3_column_bytes(pStmt, iCol);\n        const char *zBlob = (char*)sqlite3_column_blob(pStmt, iCol);\n        if( !zBlob ) {\n            Jsi_DSAppend(dStr, \"null\", NULL);\n            return;\n        }\n        Jsi_JSONQuote(interp, zBlob, bytes, dStr);\n        return;\n    }\n    case SQLITE_INTEGER: {\n        sqlite_int64 v = sqlite3_column_int64(pStmt, iCol);\n        if (v==0 || v==1) {\n            const char *dectyp = sqlite3_column_decltype(pStmt, iCol);\n            if (dectyp && !Jsi_Strncasecmp(dectyp,\"bool\", 4)) {\n                Jsi_DSAppend(dStr, (v?\"true\":\"false\"), NULL);\n                return;\n            }\n        }\n#ifdef __WIN32\n        snprintf(nbuf, sizeof(nbuf), \"%\" PRId64, (Jsi_Wide)v);\n#else\n        snprintf(nbuf, sizeof(nbuf), \"%lld\", v);\n#endif\n        Jsi_DSAppend(dStr, nbuf, NULL);\n        return;\n    }\n    case SQLITE_FLOAT: {\n        Jsi_NumberToString(interp, sqlite3_column_double(pStmt, iCol), nbuf, sizeof(nbuf));\n        Jsi_DSAppend(dStr, nbuf, NULL);\n        return;\n    }\n    case SQLITE_NULL: {\n        Jsi_DSAppend(dStr, \"null\", NULL);\n        return;\n    }\n    }\n    const char *str = (char*)sqlite3_column_text(pStmt, iCol );\n    if (!str)\n        str = p->jdb->optPtr->nullvalue;\n    Jsi_JSONQuote(interp, str?str:\"\", -1, dStr);\n}\n\nstatic void dbEvalSetColumn(DbEvalContext *p, int iCol, Jsi_DString *dStr) {\n    Jsi_Interp *interp = p->jdb->interp;\n    char nbuf[JSI_MAX_NUMBER_STRING];\n\n    sqlite3_stmt *pStmt = p->pPreStmt->pStmt;\n\n    switch( sqlite3_column_type(pStmt, iCol) ) {\n    case SQLITE_BLOB: {\n        int bytes = sqlite3_column_bytes(pStmt, iCol);\n        const char *zBlob = (char*)sqlite3_column_blob(pStmt, iCol);\n        if( !zBlob ) {\n            return;\n        }\n        Jsi_DSAppendLen(dStr, zBlob, bytes);\n        return;\n    }\n    case SQLITE_INTEGER: {\n        sqlite_int64 v = sqlite3_column_int64(pStmt, iCol);\n        if (v==0 || v==1) {\n            const char *dectyp = sqlite3_column_decltype(pStmt, iCol);\n            if (dectyp && !Jsi_Strncasecmp(dectyp,\"bool\", 4)) {\n                Jsi_DSAppend(dStr, (v?\"true\":\"false\"), NULL);\n                return;\n            }\n        }\n#ifdef __WIN32\n        snprintf(nbuf, sizeof(nbuf), \"%\" PRId64, (Jsi_Wide)v);\n#else\n        snprintf(nbuf, sizeof(nbuf), \"%lld\", v);\n#endif\n        Jsi_DSAppend(dStr, nbuf, NULL);\n        return;\n    }\n    case SQLITE_FLOAT: {\n        Jsi_NumberToString(interp, sqlite3_column_double(pStmt, iCol), nbuf, sizeof(nbuf));\n        Jsi_DSAppend(dStr, nbuf, NULL);\n        return;\n    }\n    case SQLITE_NULL: {\n        return;\n    }\n    }\n    const char *str = (char*)sqlite3_column_text(pStmt, iCol );\n    if (!str)\n        str = p->jdb->optPtr->nullvalue;\n    Jsi_DSAppend(dStr, str?str:\"\", NULL);\n}\n\n\nstatic Jsi_Value* dbEvalSetColumnValue(DbEvalContext *p, int iCol, Jsi_Value **val) {\n    Jsi_Interp *interp = p->jdb->interp;\n\n    sqlite3_stmt *pStmt = p->pPreStmt->pStmt;\n    const char *str;\n    \n    switch( sqlite3_column_type(pStmt, iCol) ) {\n    case SQLITE_BLOB: {\n        int bytes = sqlite3_column_bytes(pStmt, iCol);\n        const char *zBlob = (char*)sqlite3_column_blob(pStmt, iCol);\n        if( !zBlob )\n            return Jsi_ValueMakeNull(interp, val);\n        unsigned char *uptr = (unsigned char*)Jsi_Malloc(bytes+1);\n        memcpy(uptr, zBlob, bytes);\n        uptr[bytes] = 0;\n        return Jsi_ValueMakeBlob(interp, val, uptr, bytes);\n        break;\n    }\n    case SQLITE_INTEGER: {\n        sqlite_int64 v = sqlite3_column_int64(pStmt, iCol);\n        if (v==0 ||v==1) {\n            const char *dectyp = sqlite3_column_decltype(pStmt, iCol);\n            if (dectyp && !Jsi_Strncasecmp(dectyp,\"bool\", 4)) {\n                return Jsi_ValueMakeBool(interp, val, v);\n            }\n        }\n        if( v>=-2147483647 && v<=2147483647 ) {\n            return Jsi_ValueMakeNumber(interp, val, v);\n        } else {\n            return Jsi_ValueMakeNumber(interp, val, v);\n        }\n        break;\n    }\n    case SQLITE_FLOAT: {\n        return Jsi_ValueMakeNumber(interp, val, (Jsi_Number)sqlite3_column_double(pStmt, iCol));\n        break;\n    }\n    case SQLITE_NULL: {\n        return Jsi_ValueMakeNull(interp, val);\n        break;;\n    }\n    case SQLITE_TEXT: {\n        if (!p->jdb->noJsonConv) {\n            const char *dectyp = sqlite3_column_decltype(pStmt, iCol);\n            if (dectyp && !Jsi_Strncasecmp(dectyp, \"charjson\", 8)) {\n                Jsi_Value *v = Jsi_ValueNew(interp);// NULL; //Jsi_ValueNew1(interp);\n                str = (char*)sqlite3_column_text(pStmt, iCol );\n                if (JSI_OK != Jsi_JSONParse(interp, str, &v, 0))\n                    Jsi_LogWarn(\"JSON parse failure for CHARJSON column\");\n                return v;\n            }\n        }\n    }\n    default:\n        str = (char*)sqlite3_column_text(pStmt, iCol );\n        if (!str)\n            str = p->jdb->optPtr->nullvalue;\n        return Jsi_ValueMakeStringDup(interp, val, str?str:\"\");\n    }\n    return Jsi_ValueNew1(interp);\n}\n\n\n# define SQLITE_JSI_NRE 0\n# define DbUseNre() 0\n# define Jsi_NRAddCallback(a,b,c,d,e,f) 0\n# define Jsi_NREvalObj(a,b,c) 0\n# define Jsi_NRCreateCommand(a,b,c,d,e,f) 0\n\n#include <stdio.h>\n\nstatic Jsi_RC dbEvalCallCmd( DbEvalContext *p, Jsi_Interp *interp, Jsi_RC result)\n{\n    int cnt = 0;\n    Jsi_RC rc = result;\n    Jsi_Value *varg1;\n    Jsi_Obj *argso;\n    char **apColName = NULL;\n    int *apColType = NULL;\n    if (p->jdb->debug & TMODE_EVAL)\n        JSI_DBQUERY_PRINTF( \"DEBUG: eval\\n\");\n\n    while( (rc==JSI_OK) && JSI_OK==(rc = dbEvalStep(p)) ) {\n        int i;\n        int nCol;\n\n        cnt++;\n        dbEvalRowInfo(p, &nCol, &apColName, &apColType);\n        if (nCol<=0)\n            continue;\n        if (Jsi_ValueIsNull(interp,p->tocall))\n            continue;\n        /* Single object containing sql result members. */\n        varg1 = Jsi_ValueMakeObject(interp, NULL, argso = Jsi_ObjNew(interp));\n        for(i=0; i<nCol; i++) {\n            Jsi_Value *nnv = dbEvalSetColumnValue(p, i, NULL);\n            Jsi_ObjInsert(interp, argso, apColName[i], nnv, 0);\n        }\n        Jsi_IncrRefCount(interp, varg1);\n        bool rb = Jsi_FunctionInvokeBool(interp, p->tocall, varg1);\n        Jsi_DecrRefCount(interp, varg1);\n        if (Jsi_InterpGone(interp))\n            return JSI_ERROR;\n        if (rb)\n            break;\n    }\n    //dbEvalFinalize(p);\n\n    if( rc==JSI_OK || rc==JSI_BREAK ) {\n        //Jsi_ResetResult(interp);\n        rc = JSI_OK;\n    }\n    return rc;\n}\n\nstatic Jsi_Db *dbGetDbHandle(Jsi_Interp *interp, Jsi_Value *_this, Jsi_Func *funcPtr)\n{\n    Jsi_Db *jdb = (Jsi_Db*)Jsi_UserObjGetData(interp, _this, funcPtr);\n    if (!jdb) {\n        Jsi_LogError(\"Sqlite call to a non-sqlite object\");\n        return NULL;\n    }\n    if (!jdb->db)\n    {\n        Jsi_LogError(\"Sqlite db closed\");\n        return NULL;\n    }\n    return jdb;\n}\n\nstatic void sqliteObjErase(Jsi_Db *jdb)\n{\n    dbDeleteCmd(jdb);\n    jdb->db = NULL;\n}\n\nstatic Jsi_RC sqliteObjFree(Jsi_Interp *interp, void *data)\n{\n    Jsi_Db *db = (Jsi_Db*)data;\n    SQLSIGASSERT(db,DB);\n    db->_->activeCnt--;\n    sqliteObjErase(db);\n    _JSI_MEMCLEAR(db);\n    Jsi_Free(db);\n    return JSI_OK;\n}\n\nstatic bool sqliteObjIsTrue(void *data)\n{\n    Jsi_Db *db = (Jsi_Db*)data;\n    SQLSIGASSERT(db,DB);\n    if (!db->db) return 0;\n    else return 1;\n}\n\nstatic bool sqliteObjEqual(void *data1, void *data2)\n{\n    //SQLSIGASSERT(data1,DB);\n    //SQLSIGASSERT(data2,DB);\n    return (data1 == data2);\n}\n\nstatic Jsi_RC dbStmtFreeProc(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *value);\n\nstatic Jsi_RC SqliteConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                             Jsi_Value **ret, Jsi_Func *funcPtr);\n\nstatic Jsi_RC SqliteCollateCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                            Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Db *jdb;\n    Jsi_Value *func;\n\n    SqlCollate *pCollate;\n    char *zName;\n    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n\n    zName = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    func = Jsi_ValueArrayIndex(interp, args, 1);\n    pCollate = (SqlCollate*)Jsi_Calloc(1, sizeof(*pCollate));\n    if( pCollate==0 ) return JSI_ERROR;\n    pCollate->jdb = jdb;\n    pCollate->interp = interp;\n    pCollate->pNext = jdb->pCollate;\n    pCollate->zScript = func; /*(char*)&pCollate[1];*/\n    jdb->pCollate = pCollate;\n\n    if( sqlite3_create_collation(jdb->db, zName, SQLITE_UTF8, pCollate, dbSqlCollate) )\n    \n        return Jsi_LogError(\"%s\", (char *)sqlite3_errmsg(jdb->db));\n    return JSI_OK;\n}\n\nstatic const char *copyConflictStrs[] = {\n    \"ROLLBACK\", \"ABORT\", \"FAIL\", \"IGNORE\", \"REPLACE\", 0\n};\nenum { CC_ROLLBACK, CC_ABORT, CC_FAIL, CC_IGNORE, CC_REPLACE, CC__MAX };\n\ntypedef struct ImportData {\n    int limit;\n    int conflict;\n    bool csv;\n    bool headers;\n    const char *separator;\n    const char *nullvalue;\n} ImportData;\n\nstatic Jsi_OptionSpec ImportOptions[] =\n{\n    JSI_OPT(BOOL,   ImportData, headers, .help=\"First row contains column labels\"),\n    JSI_OPT(BOOL,   ImportData, csv, .help=\"Treat input values as CSV\"),\n    JSI_OPT(CUSTOM, ImportData, conflict, .help=\"Set conflict resolution\", .flags=0, .custom=Jsi_Opt_SwitchEnum,  .data=copyConflictStrs),\n    JSI_OPT(INT,    ImportData, limit, .help=\"Maximum number of lines to load\"),\n    JSI_OPT(STRKEY, ImportData, nullvalue, .help=\"Null string\"),\n    JSI_OPT(STRKEY, ImportData, separator, .help=\"Separator string; default is comma if csv, else tabs\"),\n    JSI_OPT_END(ImportData, .help=\"Options for the Sqlite import command\")\n};\n\n#define FN_import JSI_INFO(\"\\\nImport data from a file into table. SqlOptions include the 'separator' \\\nto use, which defaults to commas for csv, or tabs otherwise.\\n\\\nIf a column contains a null string, or the \\\nvalue of 'nullvalue', a null is inserted for the column.\\n\\\nA 'conflict' is one of the sqlite conflict algorithms: \\\n   rollback, abort, fail, ignore, replace\\n\\\nOn success, return the number of lines processed, not necessarily same \\\nas 'changeCnt' due to the conflict algorithm selected. \\\n\")\n\nstatic Jsi_RC SqliteImportCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                         Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Db *jdb;\n    Jsi_RC rv = JSI_OK;\n    int rc;\n    char *zTable;               /* Insert data into this table */\n    char *zFile;                /* The file from which to extract data */\n    const char *zConflict;            /* The conflict algorithm to use */\n    sqlite3_stmt *pStmt;        /* A statement */\n    int nCol;                   /* Number of columns in the table */\n    int nByte;                  /* Number of bytes in an SQL string */\n    int i, j;                   /* Loop counters */\n    int nSep;                   /* Number of bytes in zSep[] */\n    int nNull;                  /* Number of bytes in zNull[] */\n    char *zSql;                 /* An SQL statement */\n    char *zLine;                /* A single line of input from the file */\n    char **azCol;               /* zLine[] broken up into columns */\n    const char *onCommit;              /* How to commit changes */\n    Jsi_Channel in;                   /* The input file */\n    int lineno = 0;             /* Line number of input file */\n    int created = 0;\n    const char *zSep;\n    const char *zNull;\n\n    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 2);\n    ImportData opts = {};\n\n    if (arg) {\n        if (Jsi_OptionsProcess(interp, ImportOptions, &opts, arg, 0) < 0)\n            return JSI_ERROR;\n    }\n    zConflict = copyConflictStrs[opts.conflict];\n    \n    if(opts.separator ) {\n        zSep = opts.separator;\n    } else {\n        zSep = (opts.csv ? \",\" : \"\\t\");\n    }\n    if(opts.nullvalue ) {\n        zNull = opts.nullvalue;\n    } else {\n        zNull = \"\";\n    }\n    zTable = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    Jsi_Value *fname = Jsi_ValueArrayIndex(interp, args, 1);\n    zFile = Jsi_ValueArrayIndexToStr(interp, args, 1, NULL);\n    nSep = Jsi_Strlen(zSep);\n    nNull = Jsi_Strlen(zNull);\n    if( nSep==0 ) \n        return Jsi_LogError(\"Error: non-null separator required for copy\");\n\n\n    zSql = sqlite3_mprintf(\"SELECT * FROM '%q'\", zTable);\n    if (zSql==0) \n        return Jsi_LogError(\"Error: bad table: %s\", zTable);\n    \n    if (opts.headers) {\n        in = Jsi_Open(interp, fname, \"rb\");\n        if( in==0 ) \n            return Jsi_LogError(\"Error: cannot open file: %s\", zFile);\n        if ((zLine = dbLocalGetline(interp, 0, in))==0 ) {\n            Jsi_Close(interp, in);\n            return JSI_ERROR;\n        }\n        Jsi_Close(interp, in);\n        char *zn, *ze, *z = zLine;\n        Jsi_DString cStr = {};\n        int zlen = 0, icnt = 0;\n        Jsi_DSAppend(&cStr, \"CREATE TABLE IF NOT EXISTS '\", zTable, \"' (\", NULL);\n        while (1) {\n            zn = Jsi_Strstr(z, zSep);\n            if (!zn) zlen = Jsi_Strlen(z);\n            else zlen = zn-z;\n            if (zlen<=0) break;\n            ze = z+zlen-1;\n            Jsi_DSAppend(&cStr, (icnt?\",\":\"\"), \"'\", NULL);\n            icnt++;\n            if (opts.csv && *z=='\"' && zn>z && *ze == '\"')\n                Jsi_DSAppendLen(&cStr, z+1, zlen-2);\n            else\n                Jsi_DSAppendLen(&cStr, z, zlen);\n            Jsi_DSAppend(&cStr, \"'\", NULL);\n            if (!zn) break;\n            z = zn+nSep;\n        }\n        Jsi_DSAppend(&cStr, \");\", NULL);\n        Jsi_Free(zLine);\n        if (zlen<=0) {\n            Jsi_DSFree(&cStr);\n            Jsi_LogError(\"null header problem\");\n            return JSI_ERROR;\n        }\n        rc = sqlite3_exec(jdb->db, Jsi_DSValue(&cStr), 0, 0, 0);\n        Jsi_DSFree(&cStr);\n        if (rc) \n            return Jsi_LogError(\"%s\", sqlite3_errmsg(jdb->db));\n        created = 1;\n    }\n    \n    nByte = Jsi_Strlen(zSql);\n    rc = sqlite3_prepare(jdb->db, zSql, -1, &pStmt, 0);\n        sqlite3_free(zSql);\n    if( rc ) {\n        Jsi_LogError(\"%s\", sqlite3_errmsg(jdb->db));\n        nCol = 0;\n    } else {\n        nCol = sqlite3_column_count(pStmt);\n    }\n    sqlite3_finalize(pStmt);\n    if( nCol==0 ) {\n        rc = JSI_ERROR;\n        goto bail;\n    }\n    zSql = (char*)Jsi_Malloc( nByte + 50 + nCol*2 );\n    if( zSql==0 ) {\n        Jsi_LogError(\"Error: can't malloc()\");\n        rc = JSI_ERROR;\n        goto bail;\n    }\n    sqlite3_snprintf(nByte+50, zSql, \"INSERT OR %q INTO '%q' VALUES(?\",\n                     zConflict, zTable);\n    j = Jsi_Strlen(zSql);\n    for(i=1; i<nCol; i++) {\n        zSql[j++] = ',';\n        zSql[j++] = '?';\n    }\n    zSql[j++] = ')';\n    zSql[j] = 0;\n    rc = sqlite3_prepare(jdb->db, zSql, -1, &pStmt, 0);\n    Jsi_Free(zSql);\n    if( rc ) {\n        Jsi_LogError(\"Error: %s\", sqlite3_errmsg(jdb->db));\n        sqlite3_finalize(pStmt);\n        return JSI_ERROR;\n    }\n    in = Jsi_Open(interp, fname, \"rb\");\n    if( in==0 ) {\n        Jsi_LogError(\"Error: cannot open file: %s\", zFile);\n        sqlite3_finalize(pStmt);\n        return JSI_ERROR;\n    }\n    azCol = (char**)Jsi_Malloc( sizeof(azCol[0])*(nCol+1) );\n    if( azCol==0 ) {\n        Jsi_LogError(\"Error: can't malloc()\");\n        Jsi_Close(interp, in);\n        rc = JSI_ERROR;\n        goto bail;\n    }\n    (void)sqlite3_exec(jdb->db, \"BEGIN\", 0, 0, 0);\n    onCommit = \"COMMIT\";\n    while ((zLine = dbLocalGetline(interp, 0, in))!=0 ) {\n        char *z;\n        i = 0;\n        lineno++;\n        if (opts.limit>0 && lineno > opts.limit) {\n            Jsi_Free(zLine);\n            break;\n        }\n        if (lineno == 1 && opts.headers) {\n            Jsi_Free(zLine);\n            continue;\n        }\n        if (opts.csv && Jsi_Strchr(zLine,'\"')) \n        {\n            char *zn, *z = zLine;\n            Jsi_DString sStr = {};\n            int qcnt = 0;\n            i = -1;\n            while (*z) if (*z++ == '\"') qcnt++;\n            z = zLine;\n            if (qcnt%2) { /* aggregate quote spanning newlines */\n                Jsi_DSAppend(&sStr, zLine, NULL);\n                do {\n                    lineno++;\n                    Jsi_DSAppend(&sStr, \"\\n\", NULL);\n                    Jsi_Free(zLine);\n                    if (((zLine = dbLocalGetline(interp, 0, in)))==0)\n                        break;\n                    Jsi_DSAppend(&sStr, zLine, NULL);\n                    z = zLine;\n                    while (*z) if (*z++ == '\"') qcnt++;\n                } while (qcnt%2);\n                z = Jsi_DSValue(&sStr);\n            }\n            if (qcnt%2) {\n                Jsi_DSFree(&sStr);\n                Jsi_Free(zLine);\n                Jsi_Close(interp, in);\n                Jsi_LogError(\"unterminated string at line: %d\", lineno);\n                break;\n            }\n            while (z) {\n                if (*z != '\\\"') { /* Handle un-quoted value */\n                    zn = Jsi_Strstr(z, zSep);\n                    azCol[++i] = z;\n                    if (!zn)\n                        break;\n                    *zn = 0;\n                    z = zn+nSep;\n                    continue;\n                }\n                /* Handle quoted value */\n                zn = ++z;\n                Jsi_DString cStr = {};\n                while (1) {\n                    if (!zn)\n                        break;\n                    if (*zn != '\"')\n                        Jsi_DSAppendLen(&cStr, zn, 1);\n                    else {\n                        if (zn[1] == '\"') {\n                            zn++;\n                            Jsi_DSAppendLen(&cStr, \"\\\"\", 1);\n                        } else if (zn[1] == 0) {\n                            break;\n                        } else if (Jsi_Strncmp(zn+1,zSep, nSep)==0) {\n                            *zn = 0;\n                            zn += (nSep + 1);\n                            break;\n                        } else {\n                            /* Invalid, comma should be right after close quote, so just eat quote. */\n                            Jsi_DSAppendLen(&cStr, zn, 1);\n                        }\n                    }\n                    zn++;\n                }\n                Jsi_Strcpy(z, Jsi_DSValue(&cStr));\n                Jsi_DSFree(&cStr);\n                azCol[++i] = z;\n                z = zn;\n            }\n        } else {\n            azCol[0] = zLine;\n            for(i=0, z=zLine; *z; z++) {\n                if( *z==zSep[0] && Jsi_Strncmp(z, zSep, nSep)==0 ) {\n                    *z = 0;\n                    i++;\n                    if( i<nCol ) {\n                        azCol[i] = &z[nSep];\n                        z += nSep-1;\n                    }\n                }\n            }\n        }\n        if( i+1!=nCol ) {\n            Jsi_LogError(\"%s line %d: expected %d columns of data but found %d\",\n                 zFile, lineno, nCol, i+1);\n            onCommit = \"ROLLBACK\";\n            break;\n        }\n        for(i=0; i<nCol; i++) {\n            /* check for null data, if so, bind as null */\n            if( (nNull>0 && Jsi_Strcmp(azCol[i], zNull)==0)\n                    || Jsi_Strlen(azCol[i])==0\n              ) {\n                sqlite3_bind_null(pStmt, i+1);\n            } else {\n                sqlite3_bind_text(pStmt, i+1, azCol[i], -1, SQLITE_STATIC );\n            }\n        }\n        sqlite3_step(pStmt);\n        rc = sqlite3_reset(pStmt);\n        if (zLine)\n            Jsi_Free(zLine);\n        if( rc!=SQLITE_OK ) {\n            Jsi_LogError(\"%s at line: %d\", sqlite3_errmsg(jdb->db), lineno);\n            onCommit = \"ROLLBACK\";\n            break;\n        }\n    }\n    Jsi_Free(azCol);\n    Jsi_Close(interp, in);\n    sqlite3_finalize(pStmt);\n    (void)sqlite3_exec(jdb->db, onCommit, 0, 0, 0);\n\n    if( onCommit[0] == 'C' ) {\n        /* success, set result as number of lines processed */\n        Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)lineno);\n        rv = JSI_OK;\n    } else {\n        rv = JSI_ERROR;\n    }\n    \nbail:\n    if (rc != JSI_OK && created && opts.conflict == CC_ROLLBACK) {\n        Jsi_DString cStr = {};\n        Jsi_DSAppend(&cStr, \"DROP TABLE IF EXISTS '\", zTable, \"';\", NULL);\n        (void)sqlite3_exec(jdb->db, Jsi_DSValue(&cStr), 0, 0, 0);\n        Jsi_DSFree(&cStr);\n    }\n    return rv;\n}\n\n#define FN_evaluate JSI_INFO(\"\\\nSupports multiple semicolon seperated commands.\\n\\\nVariable binding is NOT performed, results are discarded, and  \\\nreturns sqlite3_changes()\")\nstatic Jsi_RC SqliteEvalCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                         Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int rc = SQLITE_OK, rc2;\n    Jsi_Db *jdb;\n    sqlite3_stmt *pStmt = NULL;\n\n    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    sqlite3 *db = jdb->db;\n    const char *zSql = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    const char *zStart = zSql, *zLeftover = NULL, *zErrMsg = NULL;\n    int lnum = 1;\n    if (jdb->echo && zSql)\n        Jsi_LogInfo(\"SQL-EVAL: %s\\n\", zSql); \n\n    while( zSql && zSql[0] && (SQLITE_OK == rc) ) {\n        rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, &zLeftover);\n\n        if( SQLITE_OK != rc ) {\n            break;\n        } else {\n            if( !pStmt ) {\n                /* this happens for a comment or white-space */\n                zSql = zLeftover;\n                while( isspace(zSql[0]) ) zSql++;\n                continue;\n            }\n\n            do {\n                if (jdb->debug & TMODE_STEP)\n                    JSI_DBQUERY_PRINTF( \"DEBUG: step: %s\\n\", zSql);\n                rc = sqlite3_step(pStmt);\n            } while( rc == SQLITE_ROW );\n            rc2 = sqlite3_finalize(pStmt);\n            if( rc!=SQLITE_NOMEM ) rc = rc2;\n            if( rc==SQLITE_OK ) {\n                zSql = zLeftover;\n                while( isspace(zSql[0]) ) zSql++;\n            } else {\n            }\n        }\n    }\n \n    if (rc == SQLITE_OK) {\n        Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)sqlite3_changes(jdb->db));\n        return JSI_OK;\n    }\n    while (zSql && zStart<zSql) {\n        if (zStart[0] == '\\n') lnum++;\n        zStart++;\n    }\n    zErrMsg = sqlite3_errmsg(db);\n    Jsi_LogError(\"sqlite error: %s in statement at line %d\", (zErrMsg ? zErrMsg : \"\"), lnum);\n    return JSI_ERROR;\n}\n\n/*\n** If a field contains any character identified by a 1 in the following\n** array, then the string must be quoted for CSV.\n*/\nstatic const char needCsvQuote[] = {\n  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   \n  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   \n  1, 0, 1, 0, 0, 0, 0, 1,   0, 0, 0, 0, 0, 0, 0, 0, \n  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, \n  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, \n  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, \n  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, \n  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 1, \n  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   \n  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   \n  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   \n  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   \n  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   \n  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   \n  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   \n  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   \n};\n\n/*\n** Output a single term of CSV.  Actually, p->separator is used for\n** the separator, which may or may not be a comma.  p->nullvalue is\n** the null value.  Strings are quoted if necessary.\n*/\nstatic void dbOutputCsv(QueryOpts *p, const char *z, Jsi_DString *dStr, int bSep)\n{\n    if( z==0 ) {\n        Jsi_DSAppend(dStr,  p->nullvalue?p->nullvalue:\"\", NULL);\n    } else {\n        int i;\n        int nSep = Jsi_Strlen(p->separator);\n        for(i=0; z[i]; i++) {\n            if( needCsvQuote[((unsigned char*)z)[i]] || \n                (z[i]==p->separator[0] && (nSep==1 || memcmp(z, p->separator, nSep)==0)) ) {\n                i = 0;\n                break;\n            }\n        }\n        if( i==0 ) {\n            Jsi_DSAppend(dStr, \"\\\"\", NULL);\n            for(i=0; z[i]; i++) {\n                if( z[i]=='\"' ) Jsi_DSAppend(dStr, \"\\\"\", NULL);\n                Jsi_DSAppendLen(dStr, z+i, 1);\n            }\n            Jsi_DSAppend(dStr, \"\\\"\", NULL);\n        } else {\n            Jsi_DSAppend(dStr, z, NULL);\n        }\n    }\n    if( bSep ) {\n        Jsi_DSAppend(dStr, p->separator, NULL);\n    }\n}\n\nstatic void dbOutputHtmlString(QueryOpts *p, const char *z, Jsi_DString *dStr)\n{\n    while( *z ) {\n        switch (*z) {\n        case '<':\n            Jsi_DSAppend(dStr, \"&lt;\", NULL);\n            break;\n        case '>':\n            Jsi_DSAppend(dStr, \"&gt;\", NULL);\n            break;\n        case '&':\n            Jsi_DSAppend(dStr, \"&amp;\", NULL);\n            break;\n        case '\\\"':\n            Jsi_DSAppend(dStr, \"&quot;\", NULL);\n            break;\n        case '\\'':\n            Jsi_DSAppend(dStr, \"&#39;\", NULL);\n            break;\n        default:\n            Jsi_DSAppendLen(dStr, z, 1);\n            break;\n        }\n        z++;\n    }\n}\n/*\n** Output the given string as a quoted string using SQL quoting conventions.\n*/\nstatic void dbOutputQuotedString(Jsi_DString *dStr, const char *z) {\n    int i;\n    int nSingle = 0;\n    for(i=0; z[i]; i++) {\n        if( z[i]=='\\'' ) nSingle++;\n    }\n    if( nSingle==0 ) {\n        Jsi_DSAppend(dStr,\"'\", z, \"'\", NULL);\n    } else {\n        Jsi_DSAppend(dStr,\"'\", NULL);\n        while( *z ) {\n            for(i=0; z[i] && z[i]!='\\''; i++) {}\n            if( i==0 ) {\n                Jsi_DSAppend(dStr,\"''\", NULL);\n                z++;\n            } else if( z[i]=='\\'' ) {\n                Jsi_DSAppendLen(dStr,z, i);\n                Jsi_DSAppend(dStr,\"''\", NULL);\n                z += i+1;\n            } else {\n                Jsi_DSAppend(dStr, z, NULL);\n                break;\n            }\n        }\n        Jsi_DSAppend(dStr,\"'\", NULL);\n    }\n}\n/*\n** Output the given string as a hex-encoded blob (eg. X'1234' )\n*/\nstatic void dbOutputHexBlob(Jsi_DString *dStr, const void *pBlob, int nBlob){\n  int i;\n  char out[JSI_MAX_NUMBER_STRING], *zBlob = (char *)pBlob;\n  Jsi_DSAppend(dStr, \"X'\", NULL);\n  for(i=0; i<nBlob; i++){ snprintf(out, sizeof(out),\"%02x\",zBlob[i]&0xff);Jsi_DSAppend(dStr, out, NULL); }\n  Jsi_DSAppend(dStr, \"'\", NULL);\n}\n\nbool dbIsAlnumStr(const char *cp)\n{\n    if (!cp || !*cp) return 0;\n    while (*cp)\n        if (isalnum(*cp) || *cp == '_')\n            cp++;\n        else\n            return 0;\n    return 1;\n}\n\n#define FN_sqlexec JSI_INFO(\"\\\nReturn values in formatted as JSON, HTML, etc. , optionally calling function with a result object\")\nstatic Jsi_RC SqliteQueryCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                             Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_RC rc = JSI_OK;\n    Jsi_Db *jdb;\n    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    Jsi_Value *vSql = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_DString eStr = {};\n#ifdef JSI_DB_DSTRING_SIZE\n    JSI_DSTRING_VAR(dStr, JSI_DB_DSTRING_SIZE);\n#else\n    Jsi_DString ddStr, *dStr = &ddStr;\n    Jsi_DSInit(dStr);\n#endif\n    const char *zSql = Jsi_ValueGetDString(interp, vSql, &eStr, 0);\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 1);\n    int cnt = 0;\n    char **apColName = NULL;\n    int *apColType = NULL, isopts = 0;\n    DbEvalContext sEval = {};\n    QueryOpts opts, *oEopt = jdb->optPtr;\n    opts = jdb->queryOpts;\n    opts.callback = NULL;\n    opts.width = NULL;\n    Jsi_Value *callback = NULL, *width = NULL;\n            \n    if (arg) {\n        if (Jsi_ValueIsFunction(interp,arg))\n            callback = opts.callback = arg;\n        else if (Jsi_ValueIsString(interp, arg))\n            opts.objName = Jsi_ValueString(interp, arg, NULL);\n        else if (Jsi_ValueIsObjType(interp, arg, JSI_OT_ARRAY))\n            opts.values = arg;\n        else if (Jsi_ValueIsObjType(interp, arg, JSI_OT_OBJECT))\n            isopts = 1;\n        else {\n            rc = Jsi_LogError(\"arg 2: expected function, string, array or options\");\n            goto bail;\n        }\n    }\n\n    if (isopts) {\n        if (Jsi_OptionsProcess(interp, ExecFmtOptions, &opts, arg, 0) < 0) {\n            rc = JSI_ERROR;\n            goto bail;\n        }\n        callback = (opts.callback ? opts.callback : jdb->queryOpts.callback);\n        width = (opts.width ? opts.width : jdb->queryOpts.width);\n    }\n    if (opts.retChanged) {\n        if (opts.callback) {\n            rc = Jsi_LogError(\"can not use retChanged with callback\");\n            goto bail;\n        }\n        opts.mode = _JSI_EF_NONE;\n        opts.headers = 0;\n    }\n    if (opts.cdata) {\n        Jsi_CDataDb* copts = Jsi_CDataLookup(interp, opts.cdata);\n        if (!copts)\n            rc = Jsi_LogError(\"unknown cdata name: %s\", opts.cdata);\n        else {\n            int n = Jsi_DbQuery(jdb, copts, zSql);\n            Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)n);\n        }\n        goto bail;\n    }\n    if (opts.objName) {\n        if (Jsi_SqlObjBinds(interp, &eStr, opts.objName, !(opts.objOpts&OBJMODE_NOTYPES), \n            !(opts.objOpts&OBJMODE_NODEFAULTS), (opts.objOpts&OBJMODE_NULLDEFAULTS)!=0) != JSI_OK)\n            goto bail;\n        zSql = Jsi_DSValue(&eStr);\n    }\n    if ((jdb->echo || opts.echo) && zSql)\n        Jsi_LogInfo(\"SQL-ECHO: %s\\n\", zSql); \n    if ((opts.objOpts&OBJMODE_SQLONLY)) {\n        if (opts.objName)\n            Jsi_ValueMakeStringDup(interp, ret, zSql);\n        else\n            rc = Jsi_LogError(\"'objOpts.sqlOnly' can only be used with 'objName'\");\n        goto bail;\n    }\n    if (!opts.separator) {\n        switch (opts.mode) {\n            case _JSI_EF_LIST: opts.separator = \"|\"; break;\n            case _JSI_EF_COLUMN: opts.separator = \" \"; break;\n            case _JSI_EF_TABS: opts.separator = \"\\t\"; break;\n            default: opts.separator = \",\";\n        }\n    }\n    Jsi_DString sStr;\n    Jsi_DSInit(&sStr);\n    sEval.nocache = opts.nocache;\n    if ((rc = dbEvalInit(interp, &sEval, jdb, zSql, &sStr, 0, 0)) != JSI_OK)\n        goto bail;\n    sEval.ret = *ret;\n    jdb->optPtr = &opts;\n    if (callback) {\n        sEval.tocall = callback;\n        if (opts.mode != _JSI_EF_ROWS) {\n            Jsi_LogError(\"'mode' must be 'rows' with 'callback'\");\n            rc = JSI_ERROR;\n            goto bail;\n        }\n        rc = dbEvalCallCmd(&sEval, interp, JSI_OK);\n        goto bail;\n    } else\n    switch (opts.mode) {\n    case _JSI_EF_NONE:\n        while(JSI_OK==(rc = dbEvalStep(&sEval)) ) {\n            cnt++;\n            if (opts.limit && cnt>=opts.limit) break;\n        }\n        if (opts.retChanged)\n            Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)sqlite3_changes(jdb->db));\n        if (rc == JSI_BREAK)\n            rc = JSI_OK;\n        goto bail;\n        break;\n    case _JSI_EF_JSON:\n        if (opts.headers) {\n            Jsi_DSAppend(dStr, \"[ \", NULL);\n            while( JSI_OK==(rc = dbEvalStep(&sEval)) ) {\n                int i;\n                int nCol;\n                dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n                if (cnt == 0) {\n                    Jsi_DSAppend(dStr, \"[\", NULL);\n                    for(i=0; i<nCol; i++) {\n                        if (i)\n                            Jsi_DSAppend(dStr, \", \", NULL);\n                        Jsi_JSONQuote(interp, apColName[i], -1, dStr);\n                    }\n                    Jsi_DSAppend(dStr, \"]\", NULL);\n                    cnt++;\n                }\n                if (cnt)\n                    Jsi_DSAppend(dStr, \", \", NULL);\n                Jsi_DSAppend(dStr, \"[\", NULL);\n                for(i=0; i<nCol; i++) {\n                    if (i)\n                        Jsi_DSAppend(dStr, \", \", NULL);\n                    dbEvalSetColumnJSON(&sEval, i, dStr);\n                }\n                Jsi_DSAppend(dStr, \"]\", NULL);\n                cnt++;\n                if (opts.limit && cnt>opts.limit) break;\n            }\n            Jsi_DSAppend(dStr, \" ]\", NULL);\n            \n        } else {\n            Jsi_DSAppend(dStr, \"[ \", NULL);\n            while( JSI_OK==(rc = dbEvalStep(&sEval)) ) {\n                int i;\n                int nCol;\n                dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n                if (cnt)\n                    Jsi_DSAppend(dStr, \", \", NULL);\n                Jsi_DSAppend(dStr, \"{\", NULL);\n                for(i=0; i<nCol; i++) {\n                    if (i)\n                        Jsi_DSAppend(dStr, \", \", NULL);\n                    Jsi_JSONQuote(interp, apColName[i], -1, dStr);\n                    Jsi_DSAppend(dStr, \":\", NULL);\n                    dbEvalSetColumnJSON(&sEval, i, dStr);\n                }\n                Jsi_DSAppend(dStr, \"}\", NULL);\n                cnt++;\n                if (opts.limit && cnt>=opts.limit) break;\n            }\n            Jsi_DSAppend(dStr, \" ]\", NULL);\n        }\n        break;\n        \n    case _JSI_EF_JSON2: {\n            while( JSI_OK==(rc = dbEvalStep(&sEval)) ) {\n                int i;\n                int nCol;\n                dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n                if (cnt == 0 && 1) {\n                    Jsi_DSAppend(dStr, \"{ \\\"names\\\": [ \", NULL);\n                    for(i=0; i<nCol; i++) {\n                        if (i)\n                            Jsi_DSAppend(dStr, \", \", NULL);\n                        Jsi_JSONQuote(interp, apColName[i], -1, dStr);\n                    }\n                    Jsi_DSAppend(dStr, \" ], \\\"values\\\": [ \", NULL);\n                }\n                if (cnt)\n                    Jsi_DSAppend(dStr, \", \", NULL);\n                Jsi_DSAppend(dStr, \"[\", NULL);\n                for(i=0; i<nCol; i++) {\n                    if (i)\n                        Jsi_DSAppend(dStr, \", \", NULL);\n                    dbEvalSetColumnJSON(&sEval, i, dStr);\n                }\n                Jsi_DSAppend(dStr, \" ]\", NULL);\n                cnt++;\n                if (opts.limit && cnt>=opts.limit) break;\n            }\n            if (cnt)\n                Jsi_DSAppend(dStr, \" ] } \", NULL);\n        }\n        break;\n        \n    case _JSI_EF_LIST:\n        while( JSI_OK==(rc = dbEvalStep(&sEval)) ) {\n            int i;\n            int nCol;\n            dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n            if (cnt == 0 && opts.headers) {\n                for(i=0; i<nCol; i++) {\n                    if (i)\n                        Jsi_DSAppend(dStr, opts.separator, NULL);\n                    Jsi_DSAppend(dStr, apColName[i], NULL);\n                }\n            }\n\n            if (cnt || opts.headers)\n                Jsi_DSAppend(dStr, \"\\n\", NULL);\n            for(i=0; i<nCol; i++) {\n                if (i)\n                    Jsi_DSAppend(dStr, opts.separator, NULL);\n                dbEvalSetColumn(&sEval, i, dStr);\n            }\n            cnt++;\n            if (opts.limit && cnt>=opts.limit) break;\n        }\n        break;\n        \n    case _JSI_EF_COLUMN: {\n        int *wids = NULL;\n        Jsi_DString vStr = {};\n        while( JSI_OK==(rc = dbEvalStep(&sEval)) ) {\n            int i, w;\n            int nCol;\n            \n            dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n            if (cnt == 0 && nCol>0) {\n                Jsi_DString sStr;\n                wids = (int*)Jsi_Calloc(nCol, sizeof(int));\n                Jsi_DSInit(&sStr);\n                for(i=0; i<nCol; i++) {\n                    int j = Jsi_Strlen(apColName[i]);\n                    wids[i] = (j<10?10:j);\n                    if (width) {\n                        Jsi_Value *wv = Jsi_ValueArrayIndex(interp, width, i);\n                        if (wv) {\n                            Jsi_Number dv;\n                            Jsi_ValueGetNumber(interp, wv, &dv);\n                            if (dv>0)\n                                wids[i] = (int)dv;\n                        }\n                    }\n                    w = (j<wids[i] ? j : wids[i]);\n                    Jsi_DSAppendLen(dStr, apColName[i], w);\n                    w = (j<wids[i] ? wids[i]-j+1 : 0);\n                    while (w-- > 0)\n                        Jsi_DSAppend(dStr, \" \", NULL);\n                }\n                for(i=0; i<nCol && opts.headers; i++) {\n                    w = wids[i];\n                    w -= Jsi_Strlen(apColName[i]);\n                    if (i) {\n                        Jsi_DSAppend(dStr, opts.separator, NULL);\n                        Jsi_DSAppend(&sStr, opts.separator, NULL);\n                    }\n                    w = wids[i];\n                    while (w-- > 0)\n                        Jsi_DSAppend(&sStr, \"-\", NULL);\n                }\n                if (opts.headers)\n                    Jsi_DSAppend(dStr, \"\\n\", Jsi_DSValue(&sStr), \"\\n\", NULL);\n                Jsi_DSFree(&sStr);\n            }\n\n            if (cnt)\n                Jsi_DSAppend(dStr, \"\\n\", NULL);\n            for(i=0; i<nCol; i++) {\n                if (i)\n                    Jsi_DSAppend(dStr, opts.separator, NULL);\n                Jsi_DSSetLength(&vStr, 0);\n                dbEvalSetColumn(&sEval, i, &vStr);\n                int nl = Jsi_DSLength(&vStr);\n                if (nl > wids[i]) {\n                    Jsi_DSSetLength(&vStr, wids[i]);\n                    w = 0;\n                } else {\n                    w = wids[i]-nl;\n                }\n                Jsi_DSAppend(dStr, Jsi_DSValue(&vStr), NULL);\n                while (w-- > 0)\n                    Jsi_DSAppend(dStr, \" \", NULL);\n            }\n            cnt++;\n            if (opts.limit && cnt>=opts.limit) break;\n        }\n        Jsi_DSFree(&vStr);\n        if (wids)\n            Jsi_Free(wids);\n        break;\n    }\n    \n    case _JSI_EF_INSERT: {\n        Jsi_DString vStr = {};    \n        while( JSI_OK==(rc = dbEvalStep(&sEval)) ) {\n            int i;\n            int nCol;\n            const char *tbl = (opts.table ? opts.table : \"table\");\n            Jsi_DSAppend(dStr, \"INSERT INTO \\\"\", tbl, \"\\\" VALUES(\", NULL);\n            dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n            for(i=0; i<nCol; i++) {\n                Jsi_Number dv;\n                const char *azArg;\n                Jsi_DSSetLength(&vStr, 0);\n                dbEvalSetColumn(&sEval, i, &vStr);\n                sqlite3_stmt *pStmt = sEval.pPreStmt->pStmt;\n                int ptype = sqlite3_column_type(pStmt, i);\n                \n                azArg = Jsi_DSValue(&vStr);\n                const char *zSep = i>0 ? \",\": \"\";\n                if(apColType && apColType[i]==SQLITE_NULL) {\n                  Jsi_DSAppend(dStr, zSep, \"NULL\", NULL);\n                }else if( ptype ==SQLITE_TEXT ) {\n                  if( zSep[0] ) Jsi_DSAppend(dStr,zSep, NULL);\n                  dbOutputQuotedString(dStr, azArg);\n                }else if (ptype==SQLITE_INTEGER || ptype ==SQLITE_FLOAT) {\n                  Jsi_DSAppend(dStr, zSep, azArg, NULL);\n                }else if (ptype ==SQLITE_BLOB) {\n                  const void *pBlob = sqlite3_column_blob(pStmt, i );\n                  int nBlob = sqlite3_column_bytes(pStmt, i);\n                  if( zSep[0] ) Jsi_DSAppend(dStr,zSep, NULL);\n                  dbOutputHexBlob(dStr, pBlob, nBlob);\n                }else if( Jsi_GetDouble(interp, azArg, &dv) == JSI_OK ){\n                  Jsi_DSAppend(dStr, zSep, azArg, NULL);\n                }else{\n                  if( zSep[0] ) Jsi_DSAppend(dStr,zSep, NULL);\n                  dbOutputQuotedString(dStr, azArg);\n                }\n            }\n            Jsi_DSAppend(dStr, \");\\n\", NULL);\n            cnt++;\n            if (opts.limit && cnt>=opts.limit) break;\n        }\n        Jsi_DSFree(&vStr);\n    }\n\n    case _JSI_EF_TABS:\n    case _JSI_EF_CSV: {\n        Jsi_DString vStr = {};  \n        while( JSI_OK==(rc = dbEvalStep(&sEval)) ) {\n            int i;\n            int nCol;\n            dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n            if (cnt == 0 && opts.headers) {\n                for(i=0; i<nCol; i++) {\n                    if (i)\n                        Jsi_DSAppend(dStr, opts.separator, NULL);\n                    Jsi_DSAppend(dStr, apColName[i], NULL);\n                }\n            }\n\n            if (cnt || opts.headers)\n                Jsi_DSAppend(dStr, \"\\n\", NULL);\n            for(i=0; i<nCol; i++) {\n                if (i)\n                    Jsi_DSAppend(dStr, opts.separator, NULL);\n                Jsi_DSSetLength(&vStr, 0);\n                dbEvalSetColumn(&sEval, i, &vStr);\n                if (opts.mode == _JSI_EF_CSV)\n                    dbOutputCsv(&opts, Jsi_DSValue(&vStr), dStr, 0);\n                else\n                    Jsi_DSAppend(dStr, Jsi_DSValue(&vStr), NULL);\n            }\n            cnt++;\n            if (opts.limit && cnt>=opts.limit) break;\n        }\n        Jsi_DSFree(&vStr);\n        break;\n    }\n        \n    case _JSI_EF_LINE: {\n        int i, w = 5, ww;\n        int nCol;\n        Jsi_DString vStr = {};   \n        while( JSI_OK==(rc = dbEvalStep(&sEval)) ) {\n            dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n            if (cnt == 0) {\n                for(i=0; i<nCol; i++) {\n                    ww = Jsi_Strlen(apColName[i]);\n                    if (ww>w)\n                        w = ww;\n                }\n            }\n\n            for(i=0; i<nCol; i++) {\n                Jsi_DString eStr;\n                Jsi_DSInit(&eStr);\n                Jsi_DSSetLength(&vStr, 0);\n                dbEvalSetColumn(&sEval, i, &vStr);\n                Jsi_DSPrintf(&eStr, \"%*s = %s\", w, apColName[i], Jsi_DSValue(&vStr));\n                Jsi_DSAppend(dStr, (cnt?\"\\n\":\"\"), Jsi_DSValue(&eStr), NULL);\n                Jsi_DSFree(&eStr);\n            }\n            cnt++;\n            if (opts.limit && cnt>=opts.limit) break;\n        }\n        Jsi_DSFree(&vStr);\n        break;\n    }\n        \n    case _JSI_EF_HTML: {\n        Jsi_DString vStr = {};   \n        while( JSI_OK==(rc = dbEvalStep(&sEval)) ) {\n            int i;\n            int nCol;\n            dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n            if (cnt == 0 && opts.headers) {\n                Jsi_DSAppend(dStr, \"<TR>\", NULL);\n                for(i=0; i<nCol; i++) {\n                    Jsi_DSAppend(dStr, \"<TH>\", NULL);\n                    dbOutputHtmlString(&opts, apColName[i], dStr);\n                    Jsi_DSAppend(dStr, \"</TH>\", NULL);\n                }\n                Jsi_DSAppend(dStr, \"</TR>\", NULL);\n            }\n            if (cnt || opts.headers)\n                Jsi_DSAppend(dStr, \"\\n\", NULL);\n            Jsi_DSAppend(dStr, \"<TR>\", NULL);\n            for(i=0; i<nCol; i++) {\n                Jsi_DSAppend(dStr, \"<TD>\", NULL);\n                Jsi_DSSetLength(&vStr, 0);\n                dbEvalSetColumn(&sEval, i, &vStr);\n                dbOutputHtmlString(&opts, Jsi_DSValue(&vStr), dStr);\n                Jsi_DSAppend(dStr, \"</TD>\", NULL);\n            }\n            Jsi_DSAppend(dStr, \"</TR>\", NULL);\n            cnt++;\n            if (opts.limit && cnt>=opts.limit) break;\n        }\n        Jsi_DSFree(&vStr);\n        break;\n    }\n        \n    case _JSI_EF_ROWS:\n    {\n        Jsi_Value *vcur, *vrow;\n        int cnt = 0;\n        Jsi_Obj *oall, *ocur;\n        Jsi_ValueMakeArrayObject(interp, ret, oall = Jsi_ObjNewType(interp, JSI_OT_ARRAY));\n\n        while( JSI_OK==(rc = dbEvalStep(&sEval)) ) {\n            int i;\n            int nCol;\n            dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n            ocur = Jsi_ObjNewType(interp, JSI_OT_OBJECT);\n            vrow = Jsi_ValueMakeObject(interp, NULL, ocur);\n            for(i=0; i<nCol; i++) {\n                vcur = dbEvalSetColumnValue(&sEval, i, NULL);\n                Jsi_ObjInsert(interp, ocur, apColName[i], vcur, 0);\n            }\n            Jsi_ObjArrayAdd(interp, oall, vrow);\n            cnt++;\n            if (opts.limit && cnt>=opts.limit) break;\n        }\n        dbEvalFinalize(&sEval);\n        if (rc != JSI_ERROR)\n            rc = JSI_OK;\n        goto bail;\n        break;\n    }\n    case _JSI_EF_ARRAYS:\n    {\n        Jsi_Value *vcur, *vrow;\n        int cnt = 0;\n        Jsi_Obj *oall, *ocur;\n        Jsi_ValueMakeArrayObject(interp, ret, oall = Jsi_ObjNewType(interp, JSI_OT_ARRAY));\n\n        while( JSI_OK==(rc = dbEvalStep(&sEval)) ) {\n            int i;\n            int nCol;\n            dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n            if (cnt == 0 && opts.headers) {\n                vrow = Jsi_ValueMakeArrayObject(interp, NULL, ocur = Jsi_ObjNewType(interp, JSI_OT_ARRAY));\n                for(i=0; i<nCol; i++) {\n                    vcur = Jsi_ValueNewStringDup(interp, apColName[i]);\n                    Jsi_ObjArrayAdd(interp, ocur, vcur);\n                }\n                Jsi_ObjArrayAdd(interp, oall, vrow);\n            }\n            vrow = Jsi_ValueMakeArrayObject(interp, NULL, ocur = Jsi_ObjNewType(interp, JSI_OT_ARRAY));\n            for(i=0; i<nCol; i++) {\n                vcur = dbEvalSetColumnValue(&sEval, i, NULL);\n                Jsi_ObjArrayAdd(interp, ocur, vcur);\n            }\n            Jsi_ObjArrayAdd(interp, oall, vrow);\n            cnt++;\n            if (opts.limit && cnt>=opts.limit) break;\n        }\n        dbEvalFinalize(&sEval);\n        if (rc != JSI_ERROR)\n            rc = JSI_OK;\n        goto bail;\n        break;\n    }\n    case _JSI_EF_ARRAY1D:\n    {\n        Jsi_Value *vcur;\n        int cnt = 0;\n        Jsi_Obj *oall;\n        Jsi_ValueMakeArrayObject(interp, ret, oall = Jsi_ObjNewType(interp, JSI_OT_ARRAY));\n\n        while( JSI_OK==(rc = dbEvalStep(&sEval)) ) {\n            int i;\n            int nCol;\n            dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n            if (cnt == 0 && opts.headers) {\n                for(i=0; i<nCol; i++) {\n                    vcur = Jsi_ValueNewStringDup(interp, apColName[i]);\n                    Jsi_ObjArrayAdd(interp, oall, vcur);\n                }\n            }\n            for(i=0; i<nCol; i++) {\n                vcur = dbEvalSetColumnValue(&sEval, i, NULL);\n                Jsi_ObjArrayAdd(interp, oall, vcur);\n            }\n            cnt++;\n            if (opts.limit && cnt>=opts.limit) break;\n        }\n        dbEvalFinalize(&sEval);\n        if (rc != JSI_ERROR)\n            rc = JSI_OK;\n        goto bail;\n        break;\n    }\n    }\n    if (opts.retChanged)\n        Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)sqlite3_changes(jdb->db));\n    else\n        Jsi_ValueFromDS(interp, dStr, ret);\n    if( rc==JSI_BREAK )\n        rc = JSI_OK;\nbail:\n    dbEvalFinalize(&sEval);\n    if (isopts) {\n        Jsi_OptionsFree(interp, ExecFmtOptions, &opts, 0);\n    }\n    Jsi_DSFree(dStr);\n    Jsi_DSFree(&eStr);\n    jdb->optPtr = oEopt;\n    return rc;\n}\n\nstatic Jsi_RC SqliteOnecolumnCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                          Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_RC rc;\n    Jsi_Db *jdb;\n    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    Jsi_Value *vSql = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    Jsi_DString sStr;\n    Jsi_DSInit(&sStr);\n    DbEvalContext sEval = {};\n    const char *zSql = Jsi_ValueGetDString(interp, vSql, &dStr, 0);\n\n    sEval.nocache = jdb->queryOpts.nocache;\n    if ((rc = dbEvalInit(interp, &sEval, jdb, zSql, &sStr, 0, 0)) != JSI_OK)\n        return rc;\n    sEval.ret = *ret;\n    sEval.tocall = NULL;\n    int cnt = 0;\n\n\n    if( JSI_OK==(rc = dbEvalStep(&sEval)) ) {\n        sqlite3_stmt *pStmt = sEval.pPreStmt->pStmt;\n        int nCol = sqlite3_column_count(pStmt);\n        if (nCol>0)\n            dbEvalSetColumnValue(&sEval, 0, ret);\n        cnt++;\n    }\n    dbEvalFinalize(&sEval);\n    if( rc==JSI_BREAK ) {\n        rc = JSI_OK;\n    }\n    Jsi_DSFree(&dStr);\n    return rc;\n}\n\nstatic Jsi_RC SqliteExistsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                           Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_RC rc;\n    Jsi_Db *jdb;\n    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    Jsi_Value *vSql = Jsi_ValueArrayIndex(interp, args, 0);\n    const char *zSql;\n    Jsi_DString dStr = {};\n    DbEvalContext sEval = {};\n    zSql = Jsi_ValueGetDString(interp, vSql, &dStr, 0);\n\n    Jsi_DString sStr;\n    Jsi_DSInit(&sStr);\n    sEval.nocache = jdb->queryOpts.nocache;\n    if (dbEvalInit(interp, &sEval, jdb, zSql, &sStr, 0, 0) != JSI_OK)\n        return JSI_ERROR;\n    sEval.ret = *ret;\n    int cnt = 0;\n\n\n    if( JSI_OK==(rc = dbEvalStep(&sEval)) ) {\n        sqlite3_stmt *pStmt = sEval.pPreStmt->pStmt;\n        int nCol = sqlite3_column_count(pStmt);\n        if (nCol>0)\n            cnt++;\n    }\n    dbEvalFinalize(&sEval);\n    if( rc==JSI_BREAK ) {\n        rc = JSI_OK;\n    }\n    Jsi_DSFree(&dStr);\n    Jsi_ValueMakeBool(interp, ret, cnt);\n    return rc;\n}\n\nstatic Jsi_RC SqliteFilenameCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                             Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n#if (SQLITE_VERSION_NUMBER>3007009)\n    const char *zName = \"main\";\n    int argc = Jsi_ValueGetLength(interp, args);\n    Jsi_Db *jdb;\n\n    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    if (argc)\n        zName = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    zName = sqlite3_db_filename(jdb->db, zName);\n    if (zName)\n        Jsi_ValueMakeStringDup(interp, ret, zName);\n#endif\n    return JSI_OK;\n}\n\n/*\n** Find an SqlFunc structure with the given name.  Or create a new\n** one if an existing one cannot be found.  Return a pointer to the\n** structure.\n*/\nstatic SqlFunc *dbFindSqlFunc(Jsi_Db *jdb, const char *zName) {\n    SqlFunc *p, *pNew;\n    int i;\n    pNew = (SqlFunc*)Jsi_Calloc(1, sizeof(*pNew) + Jsi_Strlen(zName) + 1 );\n    pNew->sig = SQLITE_SIG_FUNC;\n    pNew->zName = (char*)&pNew[1];\n    for(i=0; zName[i]; i++) {\n        pNew->zName[i] = tolower(zName[i]);\n    }\n    pNew->zName[i] = 0;\n    for(p=jdb->pFunc; p; p=p->pNext) {\n        if( Jsi_Strcmp(p->zName, pNew->zName)==0 ) {\n            Jsi_Free((char*)pNew);\n            return p;\n        }\n    }\n    pNew->interp = jdb->interp;\n    pNew->pScript = 0;\n    Jsi_DSInit(&pNew->dScript);\n    pNew->pNext = jdb->pFunc;\n    jdb->pFunc = pNew;\n    return pNew;\n}\n\nstatic Jsi_RC SqliteFunctionCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                             Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    SqlFunc *pFunc;\n    Jsi_Value *tocall, *nVal;\n    char *zName;\n    int rc, nArg = -1, argc;\n    argc = Jsi_ValueGetLength(interp, args);\n    Jsi_Db *jdb;\n\n    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n\n    zName = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    tocall = Jsi_ValueArrayIndex(interp, args, 1);\n    if (zName == NULL) \n        return Jsi_LogError(\"expected name\");\n    if (!Jsi_ValueIsFunction(interp, tocall)) \n        return Jsi_LogError(\"expected function\");\n    if (argc == 3) {\n        nVal = Jsi_ValueArrayIndex(interp, args, 2);\n        if (Jsi_GetIntFromValue(interp, nVal, &nArg) != JSI_OK)\n            return JSI_ERROR;\n    } else {\n        Jsi_FunctionArguments(interp, tocall, &nArg);\n    }\n    if (nArg > SQLITE_LIMIT_FUNCTION_ARG) \n        return Jsi_LogError(\"to many args\");\n    /*  if( argc==6 ){\n        const char *z = Jsi_GetString(objv[3]);\n        int n = Jsi_Strlen(z);\n        if( n>2 && strncmp(z, \"-argcount\",n)==0 ){\n          if( Jsi_GetIntFromObj(interp, objv[4], &nArg) ) return JSI_ERROR;\n          if( nArg<0 )\n              return Jsi_LogError( \"number of arguments must be non-negative\");\n        }\n        pScript = objv[5];\n      }else if( argc!=4 ){\n        Jsi_WrongNumArgs(interp, 2, objv, \"NAME [-argcount N] SCRIPT\");\n        return JSI_ERROR;\n      }else{\n        pScript = objv[3];\n      }*/\n    pFunc = dbFindSqlFunc(jdb, zName);\n    if( pFunc==0 ) return JSI_ERROR;\n    SQLSIGASSERT(pFunc,FUNC);\n\n    pFunc->tocall = tocall;\n    Jsi_IncrRefCount(interp, pFunc->tocall);\n    rc = sqlite3_create_function(jdb->db, zName, nArg, SQLITE_UTF8,\n                                 pFunc, jsiSqlFunc, 0, 0);\n                                 \n    if( rc!=SQLITE_OK ) {\n        rc = JSI_ERROR;\n        Jsi_LogError(\"function create error: %s\", (char *)sqlite3_errmsg(jdb->db));\n    }\n    return JSI_OK;\n}\n\n\nstatic Jsi_RC SqliteInterruptCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                              Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Db *jdb;\n    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    sqlite3_interrupt(jdb->db);\n    return JSI_OK;\n}\n\n\nstatic Jsi_RC SqliteCompleteCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                             Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Db *jdb;\n    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    Jsi_Value *s = Jsi_ValueArrayIndex(interp, args, 0);\n    const char *str =  Jsi_ValueString(interp, s, NULL);\n    int isComplete = 0;\n    if (str)\n        isComplete = sqlite3_complete( str );\n    Jsi_ValueMakeBool(interp, ret, isComplete);\n    return JSI_OK;\n}\n\n#define FN_restore JSI_INFO(\"\\\n   db.restore(FILENAME, ?,DATABASE? ) \\\n\\n\\\nOpen a database file named FILENAME.  Transfer the content \\\nof FILENAME into the local database DATABASE (default: 'main').\")\n\nstatic Jsi_RC SqliteRestoreCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                            Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Db *jdb;\n    const char *zSrcFile;\n    const char *zDestDb;\n    sqlite3 *pSrc;\n    sqlite3_backup *pBackup;\n    int nTimeout = 0;\n    int rc;\n\n    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    Jsi_Value *vFile = Jsi_ValueArrayIndex(interp, args, 0);\n    int argc = Jsi_ValueGetLength(interp, args);\n    if( argc==1 ) {\n        zDestDb = \"main\";\n    } else {\n        zDestDb = Jsi_ValueArrayIndexToStr(interp, args, 1, NULL);\n    }\n    Jsi_DString dStr = {};\n    if (!vFile)\n        zSrcFile = \":memory:\";\n    else {\n        zSrcFile = Jsi_ValueNormalPath(interp, vFile, &dStr);\n        if (zSrcFile == NULL) \n            return Jsi_LogError(\"bad or missing file name\");\n    }\n    rc = sqlite3_open_v2(zSrcFile, &pSrc, SQLITE_OPEN_READONLY, 0);\n\n    if( rc!=SQLITE_OK ) {\n        Jsi_LogError(\"cannot open source database: %s\", sqlite3_errmsg(pSrc));\n        DbClose(pSrc);\n        Jsi_DSFree(&dStr);\n        return JSI_ERROR;\n    }\n    pBackup = sqlite3_backup_init(jdb->db, zDestDb, pSrc, \"main\");\n    if( pBackup==0 ) {\n        Jsi_LogError(\"restore failed: %s\", sqlite3_errmsg(jdb->db));\n        DbClose(pSrc);\n        Jsi_DSFree(&dStr);\n        return JSI_ERROR;\n    }\n    while( (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK\n            || rc==SQLITE_BUSY ) {\n        if( rc==SQLITE_BUSY ) {\n            if( nTimeout++ >= 3 ) break;\n            sqlite3_sleep(100);\n        }\n    }\n    sqlite3_backup_finish(pBackup);\n    Jsi_RC rv;\n    if( rc==SQLITE_DONE ) {\n        rv = JSI_OK;\n    } else if( rc==SQLITE_BUSY || rc==SQLITE_LOCKED ) {\n        Jsi_LogError(\"restore failed: source database busy\");\n        rv = JSI_ERROR;\n    } else {\n        Jsi_LogError(\"restore failed: %s\", sqlite3_errmsg(jdb->db));\n        rv = JSI_ERROR;\n    }\n    Jsi_DSFree(&dStr);\n    DbClose(pSrc);\n    return rv;\n}\n\n#define FN_transaction JSI_INFO(\"\\\nStart a new transaction (if we are not already in the midst of a \\\ntransaction) and execute the JS function FUNC.\\n\\\nAfter FUNC completes, either commit the transaction or roll it back if FUNC throws an exception.\\n\\\nOr if no new transation was started, do nothing. \\\npass the exception on up the stack.\")\nstatic Jsi_RC SqliteTransactionCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                                Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int rc;\n    Jsi_Db *jdb;\n\n    int argc = Jsi_ValueGetLength(interp, args);\n    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n\n    Jsi_Value *pScript;\n    const char *zBegin = \"SAVEPOINT _jsi_transaction\";\n\n    if( jdb->nTransaction==0 && argc==2 ) {\n        Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);\n        static const char *TTYPE_strs[] = {\n            \"deferred\",   \"exclusive\",  \"immediate\", 0\n        };\n        enum TTYPE_enum {\n            TTYPE_DEFERRED, TTYPE_EXCLUSIVE, TTYPE_IMMEDIATE\n        };\n        int ttype;\n        if( Jsi_ValueGetIndex(interp, arg, TTYPE_strs, \"transaction type\",\n                              0, &ttype) ) {\n            return JSI_ERROR;\n        }\n        switch( (enum TTYPE_enum)ttype ) {\n        case TTYPE_DEFERRED:    /* no-op */\n            ;\n            break;\n        case TTYPE_EXCLUSIVE:\n            zBegin = \"BEGIN EXCLUSIVE\";\n            break;\n        case TTYPE_IMMEDIATE:\n            zBegin = \"BEGIN IMMEDIATE\";\n            break;\n        }\n    }\n    pScript = Jsi_ValueArrayIndex(interp, args, argc-1);\n    if(!Jsi_ValueIsFunction(interp, pScript)) \n        return Jsi_LogError(\"expected function\");\n\n    /* Run the SQLite BEGIN command to open a transaction or savepoint. */\n    jdb->disableAuth++;\n    rc = sqlite3_exec(jdb->db, zBegin, 0, 0 ,0);\n    jdb->disableAuth--;\n    if( rc!=SQLITE_OK ) \n        return Jsi_LogError(\"%s\", sqlite3_errmsg(jdb->db));\n    jdb->nTransaction++;\n\n    /* Evaluate the function , then\n    ** call function dbTransPostCmd() to commit (or rollback) the transaction\n    ** or savepoint.  */\n    Jsi_RC rv = Jsi_FunctionInvoke(interp, pScript, NULL, NULL, NULL);\n    rv = dbTransPostCmd(jdb, interp, rv);\n    return rv;\n}\n\n#define FN_backup JSI_INFO(\"\\\nOpen or create a database file named FILENAME.\\n\\\nTransfer the content of local database DATABASE (default: 'main') into the \\\nFILENAME database.\")\n\nstatic Jsi_RC SqliteBackupCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                           Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Db *jdb;\n    Jsi_RC rv = JSI_OK;\n    int rc;\n    const char *zDestFile;\n    const char *zSrcDb;\n    sqlite3 *pDest;\n    sqlite3_backup *pBackup;\n\n    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    Jsi_Value *vFile = Jsi_ValueArrayIndex(interp, args, 0);\n    int argc = Jsi_ValueGetLength(interp, args);\n    if( argc==1 ) {\n        zSrcDb = \"main\";\n    } else {\n        zSrcDb = Jsi_ValueArrayIndexToStr(interp, args, 1, NULL);\n    }\n    Jsi_DString dStr = {};\n    if (!vFile)\n        zDestFile = \":memory:\";\n    else {\n        zDestFile = Jsi_ValueNormalPath(interp, vFile, &dStr);\n        if (zDestFile == NULL) \n            return Jsi_LogError(\"bad or missing file name\");\n    }\n    rc = sqlite3_open(zDestFile, &pDest);\n    if( rc!=SQLITE_OK ) {\n        Jsi_LogError(\"cannot open target database %s: %s\", zDestFile, sqlite3_errmsg(pDest));\n        DbClose(pDest);\n        Jsi_DSFree(&dStr);\n        return JSI_ERROR;\n    }\n    pBackup = sqlite3_backup_init(pDest, \"main\", jdb->db, zSrcDb);\n    if( pBackup==0 ) {\n        Jsi_LogError(\"backup failed: %s\", sqlite3_errmsg(pDest));\n        DbClose(pDest);\n        Jsi_DSFree(&dStr);\n        return JSI_ERROR;\n    }\n    while(  (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK ) {}\n    sqlite3_backup_finish(pBackup);\n    if( rc==SQLITE_DONE ) {\n        rv = JSI_OK;\n    } else {\n        Jsi_LogError(\"backup failed: %s\", sqlite3_errmsg(pDest));\n        rv = JSI_ERROR;\n    }\n    Jsi_DSFree(&dStr);\n    DbClose(pDest);\n    return rv;\n}\n\nvoid dbSetupCallbacks(Jsi_Db *jdb, Jsi_Db *ojdb)\n{\n    if (jdb->onAuth && (!ojdb || !ojdb->onAuth) )\n        sqlite3_set_authorizer(jdb->db, dbAuthCallback, jdb);\n    else\n        sqlite3_set_authorizer(jdb->db, 0, 0);\n\n    if (jdb->onCommit && (!ojdb || !ojdb->onCommit) )\n        sqlite3_commit_hook(jdb->db, dbCommitHandler, jdb);\n    else\n        sqlite3_commit_hook(jdb->db, 0, 0);\n\n    if (jdb->onBusy && (!ojdb || !ojdb->onBusy) )\n        sqlite3_busy_handler(jdb->db, dbBusyHandler, jdb);\n    else\n        sqlite3_busy_handler(jdb->db, 0, 0);\n    \n    if (jdb->onTrace && (!ojdb || !ojdb->onTrace) )\n        sqlite3_trace(jdb->db, dbTraceHandler, jdb);\n    else\n        sqlite3_trace(jdb->db, 0, 0);\n\n    if (jdb->onNeedCollate && (!ojdb || !ojdb->onNeedCollate) )\n        sqlite3_collation_needed(jdb->db, jdb, dbCollateNeeded);\n    else\n        sqlite3_collation_needed(jdb->db, 0, 0);\n\n    if (jdb->onUpdate && (!ojdb || !ojdb->onUpdate) )\n        sqlite3_update_hook(jdb->db, dbUpdateHandler, jdb);\n    else\n        sqlite3_update_hook(jdb->db, 0, 0);\n\n    if (jdb->onWalHook && (!ojdb || !ojdb->onWalHook) )\n        sqlite3_wal_hook(jdb->db, dbWalHandler, jdb);\n    else\n        sqlite3_wal_hook(jdb->db, 0, 0);\n\n    if (jdb->onRollback && (!ojdb || !ojdb->onRollback) )\n        sqlite3_rollback_hook(jdb->db, dbRollbackHandler, jdb);\n    else\n        sqlite3_rollback_hook(jdb->db, 0, 0);\n\n    if (jdb->onProfile && (!ojdb || !ojdb->onProfile) )\n        sqlite3_profile(jdb->db, dbProfileHandler, jdb);\n    else\n        sqlite3_profile(jdb->db, 0, 0);\n\n    if (jdb->onProgress && jdb->progressSteps && (!ojdb || !ojdb->onProgress || ojdb->progressSteps != jdb->progressSteps) )\n        sqlite3_progress_handler(jdb->db, jdb->progressSteps, dbProgressHandler, jdb);\n    else\n        sqlite3_progress_handler(jdb->db, 0, 0, 0);\n    \n    if (!ojdb || jdb->load != ojdb->load)\n        sqlite3_enable_load_extension(jdb->db, jdb->load);\n\n    if (!ojdb || jdb->timeout != ojdb->timeout)\n        sqlite3_busy_timeout( jdb->db, jdb->timeout );\n\n/*    if (jdb->onUnlock && (!ojdb || !ojdb->onUnlock) )\n        sqlite3_unlock_notify(jdb->db, dbUnlockNotify, (void*)jdb);\n    else\n        sqlite3_unlock_notify(jdb->db, 0, 0);\n        */\n}\n\n\nstatic Jsi_RC SqliteConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                         Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Db *jdb, ojdb;\n    if (!(jdb = dbGetDbHandle(interp, _this, funcPtr))) return JSI_ERROR;\n    Jsi_Value *opts = Jsi_ValueArrayIndex(interp, args, 0);\n    if (jdb->noConfig && opts && !Jsi_ValueIsString(interp, opts))\n        return Jsi_LogError(\"Socket conf() is disabled for set\");\n    ojdb = *jdb;\n    \n    jdb->lastInsertId = sqlite3_last_insert_rowid(jdb->db);\n    jdb->changeCnt = sqlite3_changes(jdb->db);\n    jdb->changeCntAll = sqlite3_total_changes(jdb->db);\n    jdb->errorCode = sqlite3_errcode(jdb->db);\n    \n    Jsi_RC rc = Jsi_OptionsConf(interp, SqlOptions, jdb, opts, ret, 0);\n    \n    if (jdb->stmtCacheMax<0 || jdb->stmtCacheMax>MAX_PREPARED_STMTS) {\n        JSI_DBQUERY_PRINTF( \"option stmtCacheMax value %d is not in range 0..%d\", jdb->stmtCacheMax, MAX_PREPARED_STMTS);\n        jdb->stmtCacheMax = ojdb.stmtCacheMax;\n        rc = JSI_ERROR;\n    }\n    dbSetupCallbacks(jdb, &ojdb);\n    dbPrepStmtLimit(jdb);\n    return rc;\n}\n\nstatic Jsi_CmdSpec sqliteCmds[] = {\n    { \"Sqlite\",         SqliteConstructor,      0,  2,  \"file:null|string=void, options:object=void\",\n        .help=\"Create a new db connection to the named file or :memory:\",\n        .retType=(uint)JSI_TT_USEROBJ, .flags=JSI_CMD_IS_CONSTRUCTOR, .info=0, .opts=SqlOptions },\n    { \"backup\",         SqliteBackupCmd,        1,  2, \"file:string, dbname:string='main'\", .help=\"Backup db to file\", .retType=(uint)JSI_TT_VOID, .flags=0, .info=FN_backup },\n    { \"collate\",        SqliteCollateCmd,       2,  2, \"name:string, callback:function\", .help=\"Create new SQL collation command\", .retType=(uint)JSI_TT_VOID },\n    { \"complete\",       SqliteCompleteCmd,      1,  1, \"sql:string\", .help=\"Return true if sql is complete\", .retType=(uint)JSI_TT_BOOLEAN },\n    { \"conf\",           SqliteConfCmd,          0,  1, \"options:string|object=void\", .help=\"Configure options\", .retType=(uint)JSI_TT_ANY, .flags=0, .info=0, .opts=SqlOptions },\n    { \"eval\",           SqliteEvalCmd,          1,  1, \"sql:string\", .help=\"Run sql commands without input/output\", .retType=(uint)JSI_TT_NUMBER, .flags=0, .info=FN_evaluate },\n    { \"exists\",         SqliteExistsCmd,        1,  1, \"sql:string\", .help=\"Execute sql, and return true if there is at least one result value\", .retType=(uint)JSI_TT_BOOLEAN },\n    { \"filename\",       SqliteFilenameCmd,      0,  1, \"name:string='main'\", .help=\"Return filename for named or all attached databases\", .retType=(uint)JSI_TT_STRING },\n    { \"func\",           SqliteFunctionCmd,      2,  3, \"name:string, callback:function, numArgs:number=void\", .help=\"Register a new function with database\", .retType=(uint)JSI_TT_VOID },\n    { \"import\",         SqliteImportCmd,        2,  3, \"table:string, file:string, options:object=void\", .help=\"Import data from file into table \", .retType=(uint)JSI_TT_NUMBER, .flags=0, .info=FN_import, .opts=ImportOptions },\n    { \"interrupt\",      SqliteInterruptCmd,     0,  0, \"\", .help=\"Interrupt in progress statement\", .retType=(uint)JSI_TT_VOID },\n    { \"onecolumn\",      SqliteOnecolumnCmd,     1,  1, \"sql:string\", .help=\"Execute sql, and return a single value\", .retType=(uint)JSI_TT_ANY },\n    { \"query\",          SqliteQueryCmd,         1,  2, \"sql:string, options:function|string|array|object=void\", .help=\"Evaluate an sql query with bindings\", .retType=(uint)JSI_TT_ANY, .flags=0, .info=FN_sqlexec, .opts=ExecFmtOptions },\n    { \"restore\",        SqliteRestoreCmd,       1,  2, \"file:string, dbname:string\", .help=\"Restore db from file (default db is 'main')\", .retType=(uint)JSI_TT_VOID, .flags=0, .info=FN_restore },\n    { \"transaction\",    SqliteTransactionCmd,   1,  2, \"callback:function, type:string=void\", .help=\"Call function inside db tranasaction. Type is: 'deferred', 'exclusive', 'immediate'\", .retType=(uint)JSI_TT_VOID, .flags=0, .info=FN_transaction },\n    { NULL, 0,0,0,0, .help=\"Commands for accessing sqlite databases\" }\n};\n\n//static Jsi_CmdSpec sqliteCmds[];\n\n\nstatic Jsi_UserObjReg sqliteobject = {\n    .name   = \"Sqlite\",\n    .spec   = sqliteCmds,\n    .freefun= sqliteObjFree,\n    .istrue = sqliteObjIsTrue,\n    .isequ  = sqliteObjEqual\n};\n\n/**   new Sqlite(FILENAME,?-vfs VFSNAME?,?-key KEY?,?-readonly BOOLEAN?,\n**                           ?-create BOOLEAN?,?-nomutex BOOLEAN?)\n**\n** This is the sqlite constructior called  using \"new Sqlite\".\n**\n** The first argument is the name of the database file.\n**\n*/\n\nstatic Jsi_RC SqliteConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                             Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_RC rc = JSI_ERROR;\n    /* void *cd = clientData; */\n    int  flags;\n    char *zErrMsg;\n    const char *zFile = NULL, *vfs = 0;\n    /* In normal use, each JSI interpreter runs in a single thread.  So\n    ** by default, we can turn of mutexing on SQLite database connections.\n    ** However, for testing purposes it is useful to have mutexes turned\n    ** on.  So, by default, mutexes default off.  But if compiled with\n    ** SQLITE_JSI_DEFAULT_FULLMUTEX then mutexes default on.\n    */\n    flags = SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE;\n#ifdef SQLITE_JSI_DEFAULT_FULLMUTEX\n    flags |= SQLITE_OPEN_FULLMUTEX;\n#else\n    flags |= SQLITE_OPEN_NOMUTEX;\n#endif\n\n    Jsi_Value *vFile = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 1);\n    Jsi_DString dStr = {};\n    int ismem = 0, create = 0;\n    Jsi_Obj *fobj;\n    Jsi_Value *toacc;\n    const char *vf;\n    const char *dbname = NULL;\n    \n    if (vFile==NULL || Jsi_ValueIsNull(interp, vFile) ||\n        ((vf = Jsi_ValueString(interp, vFile, NULL)) && !Jsi_Strcmp(vf,\":memory:\"))) {\n        zFile = \":memory:\";\n        ismem = 1;\n    } else {\n        zFile = Jsi_ValueNormalPath(interp, vFile, &dStr);\n        if (zFile == NULL) \n            return Jsi_LogError(\"bad or missing file name\");\n        Jsi_StatBuf st = {};\n        st.st_uid = -1;\n        create = (Jsi_Lstat(interp, vFile, &st) != 0);\n    }\n    zErrMsg = 0;\n    Jsi_Db *db = (Jsi_Db*)Jsi_Calloc(1, sizeof(*db) );\n    if( db==0 ) {\n        Jsi_DSFree(&dStr);\n        Jsi_LogError(\"malloc failed\");\n        return JSI_ERROR;\n    }\n    db->sig = SQLITE_SIG_DB;\n    db->_ = &dbObjCmd;\n    db->_->newCnt++;\n    db->_->activeCnt++;\n    db->stmtCacheMax = NUM_PREPARED_STMTS;\n    db->hasOpts = 1;\n    if ((arg != NULL && !Jsi_ValueIsNull(interp,arg))\n        && Jsi_OptionsProcess(interp, SqlOptions, db, arg, 0) < 0) {\n        rc = JSI_ERROR;\n        goto bail;\n    }\n    if (ismem == 0 &&\n        (Jsi_InterpAccess(interp, vFile, (db->readonly ? JSI_INTACCESS_READ : JSI_INTACCESS_WRITE)) != JSI_OK\n        || (create && Jsi_InterpAccess(interp, vFile, JSI_INTACCESS_CREATE) != JSI_OK))) {\n        Jsi_LogError(\"Safe accces denied\");\n        goto bail;\n    }\n\n    if (db->stmtCacheMax<0 || db->stmtCacheMax>MAX_PREPARED_STMTS) {\n        Jsi_LogError(\"option stmtCacheMax value %d is not in range 0..%d\", db->stmtCacheMax, MAX_PREPARED_STMTS);\n        goto bail;\n    }\n    if (!db->udata) {\n        db->udata = Jsi_ValueNewObj(interp, NULL);\n        Jsi_IncrRefCount(interp, db->udata);\n    }\n    if (db->readonly) {\n        flags &= ~(SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE);\n        flags |= SQLITE_OPEN_READONLY;\n    } else {\n        flags &= ~SQLITE_OPEN_READONLY;\n        flags |= SQLITE_OPEN_READWRITE;\n        if (db->noCreate) {\n            flags &= ~SQLITE_OPEN_CREATE;\n        }\n    }\n    if (db->vfs)\n        vfs = Jsi_ValueToString(interp, db->vfs, NULL);\n    if(db->mutex == MUTEX_NONE) {\n        flags |= SQLITE_OPEN_NOMUTEX;\n        flags &= ~SQLITE_OPEN_FULLMUTEX;\n    } else {\n        flags &= ~SQLITE_OPEN_NOMUTEX;\n    }\n    if(db->mutex ==MUTEX_FULL) {\n        flags |= SQLITE_OPEN_FULLMUTEX;\n        flags &= ~SQLITE_OPEN_NOMUTEX;\n    } else {\n        flags &= ~SQLITE_OPEN_FULLMUTEX;\n    }\n  \n    if (SQLITE_OK != sqlite3_open_v2(zFile, &db->db, flags, vfs)) {\n        Jsi_LogError(\"db open failed: %s\", zFile);\n        goto bail;\n    }\n    //Jsi_DSFree(&translatedFilename);\n\n    if( SQLITE_OK!=sqlite3_errcode(db->db) ) {\n        zErrMsg = sqlite3_mprintf(\"%s\", sqlite3_errmsg(db->db));\n        DbClose(db->db);\n        db->db = 0;\n    }\n    if( db->db==0 ) {\n        sqlite3_free(zErrMsg);\n        goto bail;\n    }\n;\n    toacc = NULL;\n    if (Jsi_FunctionIsConstructor(funcPtr)) {\n        toacc = _this;\n    } else {\n        Jsi_Obj *o = Jsi_ObjNew(interp);\n        Jsi_PrototypeObjSet(interp, \"Sqlite\", o);\n        Jsi_ValueMakeObject(interp, ret, o);\n        toacc = *ret;\n    }\n    sqlite3_create_function(db->db, \"unixtime\", -1, SQLITE_UTF8, db, jsiSqlFuncUnixTime, 0, 0);\n    \n    fobj = Jsi_ValueGetObj(interp, toacc /* constructor obj*/);\n    if ((db->objId = Jsi_UserObjNew(interp, &sqliteobject, fobj, db))<0)\n        goto bail;\n    db->stmtHash = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);\n    db->fobj = fobj;\n    //dbSys->cnt = Jsi_UserObjCreate(interp, sqliteobject.name /*dbSys*/, fobj, db);\n    db->interp = interp;\n    db->optPtr = &db->queryOpts;\n    db->stmtCache = Jsi_ListNew((Jsi_Interp*)db, 0, dbStmtFreeProc);\n    rc = JSI_OK;\n    dbname = Jsi_DSValue(&db->name);\n    if (dbname[0])\n        sqlite3_db_config(db->db, SQLITE_DBCONFIG_MAINDBNAME, dbname);\n    Jsi_JSONParseFmt(interp, &db->version, \"{libVer:\\\"%s\\\", hdrVer:\\\"%s\\\", hdrNum:%d, hdrSrcId:\\\"%s\\\", pkgVer:%d}\",\n        (char *)sqlite3_libversion(), SQLITE_VERSION, SQLITE_VERSION_NUMBER, SQLITE_SOURCE_ID, jsi_DbPkgVersion); \n    dbSetupCallbacks(db, NULL);\n    \nbail:\n    if (rc != JSI_OK) {\n        if (db->hasOpts)\n            Jsi_OptionsFree(interp, SqlOptions, db, 0);\n        db->_->activeCnt--;\n        Jsi_Free(db);\n    }\n    Jsi_DSFree(&dStr);\n    Jsi_ValueMakeUndef(interp, ret);\n    return rc;\n}\n\n#endif\n\ntypedef struct {\n    Jsi_CDataDb *binds;\n    Jsi_StructSpec *rowidPtr, *dirtyPtr;\n    int optLen;             /* Length of binds[0].binds */\n} OptionBind;\n\nconst char *jsi_DbOptionTypeStr(Jsi_OptionId typ, bool cname)\n{\n    const Jsi_OptionTypedef* ti = Jsi_OptionTypeInfo(typ);\n    if (ti)\n        return (cname?ti->cName:ti->idName);\n    return NULL;\n}\n\nstatic Jsi_RC dbBindOptionStmt(Jsi_Db *jdb, sqlite3_stmt *pStmt, OptionBind *obPtr,\n                            int dataIdx, int bindMax, Jsi_CDataDb *dbopts)\n{\n    Jsi_Interp *interp = jdb->interp;\n    int j, k, cnt = 0, idx, sidx = -1, rc = 0;\n    Jsi_StructSpec *specPtr, *specs;\n    void *rec;\n    Jsi_DString *eStr;\n    const char *bName;\n    int lastBind = sqlite3_bind_parameter_count(pStmt);\n    if (lastBind<=0)\n        return JSI_OK;\n    int structSize = 0;\n    Jsi_Wide flags = 0;\n    sqlite3_destructor_type statFlags = ((dbopts->noStatic)?SQLITE_TRANSIENT:SQLITE_STATIC);\n    specPtr = dbopts[0].sf;\n    structSize = specPtr[obPtr->optLen].size;\n    \n    for (j=1; j<=lastBind; j++) {\n        bName = sqlite3_bind_parameter_name(pStmt, j);\n        if (bName==NULL || bName[0]==0 || bName[1]==0)\n            continue;\n        idx = j;\n        if (dbopts[0].prefix==0)\n            k = 0;\n        else {\n            for (k=0; dbopts[k].sf; k++) {\n                if (bName[0] == dbopts[k].prefix)\n                    break;\n            }\n            if (bindMax>0 && k>=bindMax)\n                continue;\n            if (!dbopts[k].sf) {\n                Jsi_LogError(\"bad bind: %s\", bName);\n                continue;\n            }\n        }\n        specs = dbopts[k].sf;\n        rec = dbopts[k].data;\n        if (k==0) {\n            if (dbopts->isMap) {\n                Jsi_Map *map = *(typeof(map)*)rec;\n                rec = Jsi_MapEntryFind(map, (void*)(intptr_t)dataIdx);\n                if (!rec) return JSI_ERROR;\n            } else if (dbopts->isPtrs)\n                rec = ((void**)rec)[dataIdx];\n            else\n                rec = ((uchar*)rec)+ (dataIdx * structSize);\n        }\n        if (bName[0] == '?')\n            sidx = atoi(bName+1);\n        for (specPtr = specs, cnt=1; specPtr->id>=JSI_OPTION_BOOL && specPtr->id < JSI_OPTION_END; specPtr++, cnt++) {\n            if (specPtr->flags&JSI_OPT_DB_IGNORE)\n                continue;\n            if (bName[0] == '?') {\n                if (cnt == sidx)\n                    break;\n            } else {\n                const char *sName = specPtr->name;\n                if (bName[1] == sName[0] && !Jsi_Strcmp(bName+1, sName))\n                    break;\n            }\n        }\n        if (specPtr->id<JSI_OPTION_BOOL || specPtr->id>=JSI_OPTION_END) \n            return Jsi_LogError(\"unknown bind: %s\", bName);\n\n        char *ptr = (char *)rec + specPtr->offset;\n        switch (specPtr->id) {\n        case JSI_OPTION_BOOL:\n            rc = sqlite3_bind_int(pStmt, idx, *(int*)ptr);\n            break;\n        case JSI_OPTION_INT: rc = sqlite3_bind_int64(pStmt, idx, *(int*)ptr); break;\n        case JSI_OPTION_UINT:rc = sqlite3_bind_int64(pStmt, idx, *(uint*)ptr); break;\n        case JSI_OPTION_INT8: rc = sqlite3_bind_int64(pStmt, idx, *(int8_t*)ptr); break;\n        case JSI_OPTION_UINT8:rc = sqlite3_bind_int64(pStmt, idx, *(uint8_t*)ptr); break;\n        case JSI_OPTION_INT16: rc = sqlite3_bind_int64(pStmt, idx, *(int16_t*)ptr); break;\n        case JSI_OPTION_UINT16:rc = sqlite3_bind_int64(pStmt, idx, *(uint16_t*)ptr); break;\n        case JSI_OPTION_INT32: rc = sqlite3_bind_int64(pStmt, idx, *(int32_t*)ptr); break;\n        case JSI_OPTION_UINT32:rc = sqlite3_bind_int64(pStmt, idx, *(uint32_t*)ptr); break;\n        case JSI_OPTION_TIME_W:\n        case JSI_OPTION_INT64: rc = sqlite3_bind_int64(pStmt, idx, *(int64_t*)ptr); break;\n        case JSI_OPTION_UINT64:rc = sqlite3_bind_int64(pStmt, idx, *(uint64_t*)ptr); break;\n        case JSI_OPTION_USHORT:rc = sqlite3_bind_int64(pStmt, idx, *(ushort*)ptr); break;\n        case JSI_OPTION_SHORT:rc = sqlite3_bind_int64(pStmt, idx, *(short*)ptr); break;\n        case JSI_OPTION_LONG:rc = sqlite3_bind_int64(pStmt, idx, *(long*)ptr); break;\n        case JSI_OPTION_ULONG:rc = sqlite3_bind_int64(pStmt, idx, *(ulong*)ptr); break;\n        case JSI_OPTION_INTPTR_T:rc = sqlite3_bind_int64(pStmt, idx, *(intptr_t*)ptr); break;\n        case JSI_OPTION_UINTPTR_T:rc = sqlite3_bind_int64(pStmt, idx, *(uintptr_t*)ptr); break;\n        case JSI_OPTION_SIZE_T:rc = sqlite3_bind_int64(pStmt, idx, *(size_t*)ptr); break;\n        case JSI_OPTION_SSIZE_T:rc = sqlite3_bind_int64(pStmt, idx, *(ssize_t*)ptr); break;\n        case JSI_OPTION_LDOUBLE:rc = sqlite3_bind_int64(pStmt, idx, *(ldouble*)ptr); break;\n        case JSI_OPTION_FLOAT:rc = sqlite3_bind_int64(pStmt, idx, *(float*)ptr); break;\n        case JSI_OPTION_TIME_T:\n            rc = sqlite3_bind_int64(pStmt, idx, (Jsi_Wide)*(time_t*)ptr);\n            break;\n        case JSI_OPTION_NUMBER:\n            rc = sqlite3_bind_double(pStmt, idx, (double)*(Jsi_Number*)ptr);\n            break;\n        case JSI_OPTION_TIME_D:\n        case JSI_OPTION_DOUBLE:\n            rc = sqlite3_bind_double(pStmt, idx, (double)*(Jsi_Number*)ptr);\n            break;\n        case JSI_OPTION_CUSTOM: {\n            Jsi_OptionCustom* cust = Jsi_OptionCustomBuiltin(specPtr->custom);\n            if (cust && cust->formatProc) {\n                Jsi_DString dStr;\n                Jsi_DSInit(&dStr);\n                if ((*cust->formatProc)(interp, (Jsi_OptionSpec*)specPtr, NULL, &dStr, rec, flags) != JSI_OK) {\n                    Jsi_DSFree(&dStr);\n                    return JSI_ERROR;\n                }\n                rc = sqlite3_bind_text(pStmt, idx, Jsi_DSValue(&dStr), -1, SQLITE_TRANSIENT );\n                Jsi_DSFree(&dStr);\n            } else \n                return Jsi_LogError(\"missing or invalid custom for \\\"%s\\\"\", specPtr->name);\n            break;\n        }\n        case JSI_OPTION_DSTRING:\n            eStr = (Jsi_DString*)ptr;\n            if (jdb->optPtr->nullvalue && !Jsi_Strcmp(jdb->optPtr->nullvalue, Jsi_DSValue(eStr)))\n                rc = sqlite3_bind_text(pStmt, idx, NULL, -1, statFlags );\n            else\n                rc = sqlite3_bind_text(pStmt, idx, Jsi_DSValue(eStr), -1, statFlags );\n            break;\n        case JSI_OPTION_STRBUF:\n            if (jdb->optPtr->nullvalue && ptr && !Jsi_Strcmp(jdb->optPtr->nullvalue, (char*)ptr))\n                rc = sqlite3_bind_text(pStmt, idx, NULL, -1, statFlags );\n            else\n                rc = sqlite3_bind_text(pStmt, idx, (char*)ptr, -1, statFlags );\n            break;\n        case JSI_OPTION_STRKEY:\n            rc = sqlite3_bind_text(pStmt, idx, *(char**)ptr, -1, SQLITE_STATIC );\n            break;\n#ifndef JSI_LITE_ONLY\n        case JSI_OPTION_STRING:\n            rc = sqlite3_bind_text(pStmt, idx, Jsi_ValueString(interp, *((Jsi_Value **)ptr), NULL), -1, statFlags );\n            break;\n#else\n        case JSI_OPTION_STRING:\n#endif\n        case JSI_OPTION_VALUE: /* Unsupported. */\n        case JSI_OPTION_VAR:\n        case JSI_OPTION_OBJ:\n        case JSI_OPTION_ARRAY:\n        case JSI_OPTION_REGEXP:\n        case JSI_OPTION_FUNC:\n#ifdef __cplusplus\n        case JSI_OPTION_END:\n        case JSI_OPTION_USEROBJ:\n#else\n        default:\n#endif\n            Jsi_LogError(\"unsupported jdb option type \\\"%s\\\" for \\\"%s\\\"\", jsi_DbOptionTypeStr(specPtr->id, 0), specPtr->name);\n            return JSI_ERROR;\n\n        }\n        if (rc != SQLITE_OK)\n            Jsi_LogError(\"bind failure: %s\", sqlite3_errmsg(jdb->db));\n    }\n    cnt++;\n    return JSI_OK;\n}\n\n/* Prepare, bind, then step.\n * If there are results return JSI_OK. On error return JSI_ERROR;\n */\nstatic Jsi_RC dbEvalStepOption(DbEvalContext *p, OptionBind *obPtr, int *cntPtr, int dataIdx, int bindMax, Jsi_CDataDb *dbopts, int *erc) {\n    Jsi_Db *jdb = p->jdb;\n    int cnt = 0;\n    while( p->zSql[0] || p->pPreStmt ) {\n        Jsi_RC rc;\n        cnt++;\n        if( p->pPreStmt==0 ) {\n            rc = dbPrepareStmt(p->jdb, p->zSql, &p->zSql, &p->pPreStmt);\n            if( rc!=JSI_OK ) return rc;\n        }\n        if (bindMax!=0) {\n            rc = dbBindOptionStmt(jdb, p->pPreStmt->pStmt, obPtr, dataIdx, bindMax, dbopts);\n            if( rc!=JSI_OK ) return rc;\n        }\n        rc = dbEvalStepSub(p, 1, erc);\n        if (rc != JSI_BREAK)\n            return rc;\n        *cntPtr = cnt;\n    }\n    \n    /* Finished */\n    return JSI_BREAK;\n}\n\nstatic Jsi_StructSpec* dbLookupSpecFromName(Jsi_StructSpec *specs, const char *name) {\n    Jsi_StructSpec *specPtr = NULL;\n    for (specPtr = specs; specPtr->id>=JSI_OPTION_BOOL && specPtr->id < JSI_OPTION_END; specPtr++) {\n        if  (specPtr->flags&JSI_OPT_DB_IGNORE)\n            continue;\n        const char *cname = specPtr->name;\n        if (cname[0] == name[0] && !Jsi_Strncasecmp(cname, name, -1))\n            return specPtr;\n    }\n    return NULL;\n}\n\nconst char* Jsi_DbKeyAdd(Jsi_Db *jdb, const char *str)\n{\n#ifndef JSI_LITE_ONLY\n    if (jdb->interp)\n        return Jsi_KeyAdd(jdb->interp, str);\n#endif\n    Jsi_HashEntry *hPtr;\n    bool isNew;\n    hPtr = Jsi_HashEntryNew(jdb->strKeyTbl, str, &isNew);\n    assert(hPtr) ;\n    return (const char*)Jsi_HashKeyGet(hPtr);\n}\n\nstatic int dbOptSelect(Jsi_Db *jdb, const char *cmd, OptionBind *obPtr, Jsi_CDataDb *dbopts)\n{\n    void *rec = dbopts[0].data, **recPtrPtr = NULL;\n    Jsi_Interp *interp = jdb->interp;\n    Jsi_StructSpec *specPtr, *specs = dbopts[0].sf;\n    DbEvalContext sEval = {};\n    int ccnt = 0;\n    Jsi_Wide flags = 0;\n    const char *cPtr = Jsi_Strstr(cmd, \" %s\");\n    if (!cPtr) cPtr = Jsi_Strstr(cmd, \"\\t%s\");\n    Jsi_DString *eStr;\n#ifdef JSI_DB_DSTRING_SIZE\n    JSI_DSTRING_VAR(dStr, JSI_DB_DSTRING_SIZE);\n#else\n    Jsi_DString sStr, *dStr = &sStr;\n    Jsi_DSInit(dStr);\n#endif\n    dbEvalInit(interp, &sEval, jdb, NULL, dStr, 0, 0);\n    if (dbopts->noCache)\n        sEval.nocache = 1;\n    Jsi_DSAppendLen(dStr, cmd, cPtr?(cPtr-cmd):-1);\n    if (cPtr) {\n        Jsi_DSAppend(dStr, \" \", NULL);\n        for (specPtr = specs; specPtr->id>=JSI_OPTION_BOOL && specPtr->id < JSI_OPTION_END; specPtr++) {\n            if (specPtr == obPtr->dirtyPtr || (specPtr->flags&JSI_OPT_DB_IGNORE))\n                continue;\n            if (ccnt)\n                Jsi_DSAppendLen(dStr, \",\", 1);\n            Jsi_DSAppend(dStr, \"[\", specPtr->name, \"]\", NULL);\n            ccnt++; \n        }\n        Jsi_DSAppend(dStr, cPtr+3, NULL);\n    }\n    sEval.zSql = Jsi_DSValue(dStr);\n    sEval.nocache = jdb->optPtr->nocache;\n    int rc = JSI_ERROR, erc = -1, structSize = 0;\n    int cnt = 0, dataMax = (dbopts->isPtr2?0:1);\n    int multi = (dbopts->isPtr2!=0);\n    int dnum = dbopts[0].arrSize;\n    if (dnum<=0 && !dbopts->isPtr2) {\n        dataMax = dnum = 1;\n    }\n    if (dnum>1) {\n        multi = 1;\n        dataMax = dbopts[0].arrSize;\n    }\n    if (dbopts->isPtr2) {\n        recPtrPtr = (void**)rec; /* This is really a void***, but this gets recast below. */\n        rec = *recPtrPtr;\n    }\n    structSize = specs[obPtr->optLen].size;\n\n    cnt = 0;\n    int ncnt = 0, bindMax = -1, dataIdx = -1;\n    while(1) {\n        dataIdx++;\n        if (dataIdx>=dataMax) {\n            if (!dbopts->isPtr2)\n                break;\n            else {\n            /* Handle fully dynamic allocation of memory. */\n#ifndef JSI_DB_MAXDYN_SIZE\n#define JSI_DB_MAXDYN_SIZE 100000000\n#endif\n#ifndef JSI_DB_DYN_INCR\n#define JSI_DB_DYN_INCR 16\n#endif\n                int ddMax = (dbopts->maxSize>0?dbopts->maxSize:JSI_DB_MAXDYN_SIZE);\n                if (dataMax>=ddMax)\n                    break;\n                int olddm = dataMax;\n                dataMax += JSI_DB_DYN_INCR;\n                if (dataMax>ddMax)\n                    dataMax = ddMax;\n                if (!olddm)\n                    rec = Jsi_Calloc(dataMax+1, sizeof(void*));\n                else {\n                    rec = Jsi_Realloc(rec, (dataMax+1)*sizeof(void*));\n                    memset((char*)rec+olddm*sizeof(void*), 0, (dataMax-olddm+1)*sizeof(void*));\n                }\n                *recPtrPtr = rec;\n            }\n        }\n\n        rc = dbEvalStepOption(&sEval, obPtr, &ncnt, dataIdx, bindMax, dbopts, &erc);\n        if (rc == JSI_ERROR)\n            break;\n        if (rc != JSI_OK)\n            break;\n        cnt += ncnt;\n        sqlite3_stmt *pStmt = sEval.pPreStmt->pStmt;\n        int idx;\n        int nCol;\n        char **apColName;\n        const char *str;\n        int *apColType;\n        void *prec = rec;\n        bindMax = 0;\n\n        if (dbopts->isPtr2 || dbopts->isPtrs) {\n            prec = ((void**)rec)[dataIdx];\n            if (!prec)\n                ((void**)rec)[dataIdx] = prec = Jsi_Calloc(1, structSize);\n        } else\n                prec = (char*)rec + (dataIdx * structSize);\n        dbEvalRowInfo(&sEval, &nCol, &apColName, &apColType);\n        for (idx=0; idx<nCol; idx++) {\n            specPtr = dbLookupSpecFromName(specs, apColName[idx]);\n            if (!specPtr) {\n                Jsi_LogError(\"unknown column name: %s\", apColName[idx]);\n                goto bail;\n            }          \n            if (specPtr->id<JSI_OPTION_BOOL || specPtr->id>=JSI_OPTION_END) {\n                Jsi_LogError(\"unknown option type \\\"%d\\\" for \\\"%s\\\"\", specPtr->id, specPtr->name);\n                goto bail;\n            }\n            char *ptr = (char*)prec + specPtr->offset;\n\n            switch (specPtr->id) {\n                case JSI_OPTION_BOOL:\n                    *(int*)ptr = sqlite3_column_int(pStmt, idx);\n                    break;\n                case JSI_OPTION_INT: *(int*)ptr = (int)sqlite3_column_int64(pStmt, idx); break;\n                case JSI_OPTION_UINT: *(uint*)ptr = (uint)sqlite3_column_int64(pStmt, idx); break;\n                case JSI_OPTION_INTPTR_T: *(intptr_t*)ptr = (intptr_t)sqlite3_column_int64(pStmt, idx); break;\n                case JSI_OPTION_UINTPTR_T: *(uintptr_t*)ptr = (uintptr_t)sqlite3_column_int64(pStmt, idx); break;\n                case JSI_OPTION_SIZE_T: *(size_t*)ptr = (size_t)sqlite3_column_int64(pStmt, idx); break;\n                case JSI_OPTION_SSIZE_T: *(ssize_t*)ptr = (ssize_t)sqlite3_column_int64(pStmt, idx); break;\n                case JSI_OPTION_SHORT: *(short*)ptr = (int)sqlite3_column_int64(pStmt, idx); break;\n                case JSI_OPTION_USHORT: *(ushort*)ptr = (uint)sqlite3_column_int64(pStmt, idx); break;\n                case JSI_OPTION_LONG: *(long*)ptr = (int)sqlite3_column_int64(pStmt, idx); break;\n                case JSI_OPTION_ULONG: *(ulong*)ptr = (uint)sqlite3_column_int64(pStmt, idx); break;\n                case JSI_OPTION_INT8: *(int8_t*)ptr = (int)sqlite3_column_int64(pStmt, idx); break;\n                case JSI_OPTION_UINT8: *(uint8_t*)ptr = (uint)sqlite3_column_int64(pStmt, idx); break;\n                case JSI_OPTION_INT16: *(int16_t*)ptr = (int)sqlite3_column_int64(pStmt, idx); break;\n                case JSI_OPTION_UINT16: *(uint16_t*)ptr = (uint)sqlite3_column_int64(pStmt, idx); break;\n                case JSI_OPTION_INT32: *(int32_t*)ptr = (int)sqlite3_column_int64(pStmt, idx); break;\n                case JSI_OPTION_UINT32: *(uint32_t*)ptr = (uint)sqlite3_column_int64(pStmt, idx); break;\n                case JSI_OPTION_INT64: *(int64_t*)ptr = (int)sqlite3_column_int64(pStmt, idx); break;\n                case JSI_OPTION_TIME_W:\n                case JSI_OPTION_UINT64: *(uint64_t*)ptr = (uint)sqlite3_column_int64(pStmt, idx); break;\n                case JSI_OPTION_TIME_T:\n                    *(time_t*)ptr = (time_t)sqlite3_column_int64(pStmt, idx);\n                    break;\n                case JSI_OPTION_NUMBER:\n                    *(Jsi_Number*)ptr = (Jsi_Number)sqlite3_column_double(pStmt, idx);\n                    break;\n                case JSI_OPTION_TIME_D:\n                case JSI_OPTION_FLOAT:\n                    *(float*)ptr = (float)sqlite3_column_double(pStmt, idx);\n                    break;\n                case JSI_OPTION_DOUBLE:\n                    *(double*)ptr = (double)sqlite3_column_double(pStmt, idx);\n                    break;\n                case JSI_OPTION_LDOUBLE:\n                    *(ldouble*)ptr = (ldouble)sqlite3_column_double(pStmt, idx);\n                    break;\n                case JSI_OPTION_DSTRING:\n                    eStr = (Jsi_DString*)ptr;\n                    str = (char*)sqlite3_column_text(pStmt, idx );\n                    if (!str)\n                        str = jdb->optPtr->nullvalue;\n                    Jsi_DSSet(eStr, str?str:\"\");\n                    break;\n                case JSI_OPTION_STRBUF:\n                    str = (char*)sqlite3_column_text(pStmt, idx );\n                    if (!str)\n                        str = jdb->optPtr->nullvalue;\n                    strncpy((char*)ptr, str?str:\"\", specPtr->size);\n                    ((char*)ptr)[specPtr->size-1] = 0;\n                    break;\n                case JSI_OPTION_CUSTOM: {\n                    Jsi_OptionCustom* cust = Jsi_OptionCustomBuiltin(specPtr->custom);\n                    if (cust && cust->parseProc) {\n                        str = (char*)sqlite3_column_text(pStmt, idx );\n                        if ((*cust->parseProc)(interp, (Jsi_OptionSpec*)specPtr, NULL, str, prec, flags) != JSI_OK) {\n                            goto bail;\n                        }\n                    } else {\n                        Jsi_LogError(\"missing or invalid custom for \\\"%s\\\"\", specPtr->name);\n                        goto bail;\n                    }\n                    break;\n                }\n                case JSI_OPTION_STRKEY:\n                    str = (char*)sqlite3_column_text(pStmt, idx );\n                    if (!str)\n                        str = jdb->optPtr->nullvalue;\n                    *(char**)ptr = (str?(char*)Jsi_DbKeyAdd(jdb, str):NULL);\n                    break;\n#ifndef JSI_LITE_ONLY\n                case JSI_OPTION_STRING: {\n                    Jsi_Value *vPtr = *((Jsi_Value **)ptr);\n                    if (!(specPtr->flags&JSI_OPT_NO_DUPVALUE)) {\n                        if (vPtr) Jsi_DecrRefCount(interp, vPtr);\n                        *((Jsi_Value **)ptr) = NULL;\n                    }\n                    str = (char*)sqlite3_column_text(pStmt, idx );\n                    if (!str)\n                        str = jdb->optPtr->nullvalue;\n                    if (str) {\n                        vPtr = Jsi_ValueNewStringDup(interp, str);\n                        *((Jsi_Value **)ptr) = vPtr;\n                    }\n                    break;\n                }\n#else\n                case JSI_OPTION_STRING:        \n#endif\n                case JSI_OPTION_VALUE: /* The rest are unsupported. */\n                case JSI_OPTION_VAR:\n                case JSI_OPTION_OBJ:\n                case JSI_OPTION_ARRAY:\n                case JSI_OPTION_REGEXP:\n                case JSI_OPTION_FUNC:\n                \n#ifdef __cplusplus\n                case JSI_OPTION_USEROBJ:\n                case JSI_OPTION_END:\n#else\n                default:\n#endif\n                    JSI_DBQUERY_PRINTF( \"unsupported type: %d:%s\\n\", specPtr->id,\n                        jsi_DbOptionTypeStr(specPtr->id, 0));\n                    break;\n            }\n        }\n        if (dbopts[0].callback)\n            dbopts[0].callback(interp, dbopts, prec);\n        cnt++;\n        if (!multi)\n            break;\n    }\n    dbEvalFinalize(&sEval);\n    if( rc==JSI_BREAK ) {\n        rc = JSI_OK;\n    }\n    return (rc==JSI_OK?cnt:erc);\n\nbail:\n    dbEvalFinalize(&sEval);\n    return erc;\n}\n\nstatic int jsi_DbQuery(Jsi_Db *jdb, Jsi_CDataDb *dbopts, const char *query)\n{\n    int k, cnt, erc = -1;\n    Jsi_CDataDb statbinds[] = {{}, {}};\n    if (!dbopts) dbopts = statbinds;\n    OptionBind ob = {.binds = dbopts};\n    Jsi_StructSpec *specPtr, *specs;\n    Jsi_Interp *interp = jdb->interp;\n    if (!query) query=\"\";\n    if (query[0]==';') {\n        if (!dbExecCmd(jdb, query+1, &erc)) {\n            Jsi_LogError(\"EXEC ERROR=\\\"%s\\\", SQL=\\\"%s\\\"\", sqlite3_errmsg(jdb->db), query);\n            return erc;\n        }\n        return 0;\n    }\n    const char *cPtr = Jsi_Strstr(query, \" %s\");\n    if (!cPtr) cPtr = Jsi_Strstr(query, \"\\t%s\");\n    if (!dbopts) {\n        Jsi_LogError(\"dbopts may not be null\");\n        return -1;\n    }\n    if (!dbopts[0].data) {\n        Jsi_LogError(\"data may not be null\");\n        return -1;\n    }\n    if (!dbopts[0].sf) {\n        Jsi_LogError(\"specs may not be null\");\n        return -1;\n    }\n    for (k=0; dbopts[k].sf; k++) {\n        if (dbopts[k].arrSize>1 || k==0) {\n            int scnt = 0;\n            for (specPtr = dbopts[k].sf, scnt=0; specPtr->id>=JSI_OPTION_BOOL\n                && specPtr->id < JSI_OPTION_END; specPtr++, scnt++) {\n                if (specPtr->flags&JSI_OPT_DB_IGNORE)\n                    continue;\n                if (k==0) {\n                    if (specPtr->flags&JSI_OPT_DB_ROWID) {\n                        if (specPtr->id != JSI_OPTION_INT64) {\n                            Jsi_LogError(\"rowid flag must be a wide field: %s\", specPtr->name);\n                            return -1;\n                        }\n                        ob.rowidPtr = specPtr;\n                    }\n                    if (specPtr->flags&JSI_OPT_DB_DIRTY) {\n                        if (specPtr->id == JSI_OPTION_BOOL || specPtr->id == JSI_OPTION_INT) {\n                            ob.dirtyPtr = specPtr;\n                        } else {\n                            Jsi_LogError(\"dirty flag must be a int/bool field: %s\", specPtr->name);\n                            return -1;\n                        }\n                    }\n                            \n                }\n            }\n            if (k==0)\n                ob.optLen = scnt;\n            assert(specPtr->id == JSI_OPTION_END);\n        }\n        if (!dbopts[k].prefix) break;\n    }\n    specs = dbopts[0].sf;\n    int structSize = specs[ob.optLen].size;\n    if (dbopts->memClear || dbopts->memFree) {\n        cnt = dbopts[0].arrSize;\n        void *rec = dbopts[0].data, *prec = rec;\n        void **recPtrPtr = NULL;\n        if (dbopts->isPtr2) {\n            recPtrPtr = (void**)rec; /* This is really a void***, but this gets recast below. */\n            rec = *recPtrPtr;\n        }\n        if (cnt<=0 && rec && dbopts->isPtr2) {\n            for (cnt=0; ((void**)rec)[cnt]!=NULL; cnt++);\n        }\n        for (k=0; k<cnt; k++) {\n            if (dbopts->isPtr2 || dbopts->isPtrs)\n                prec = ((void**)rec)[k];\n            else\n                prec = (char*)rec + (k * structSize);\n            if (!prec)\n                continue;\n            Jsi_OptionsFree(interp, (Jsi_OptionSpec*)specs, prec, 0);\n            if (dbopts->isPtr2 || dbopts->isPtrs) {\n                Jsi_Free(prec);\n            }\n        }\n        if (recPtrPtr) {\n            Jsi_Free(*recPtrPtr);\n            *recPtrPtr = NULL;\n        }\n        if (query == NULL || query[0] == 0)\n            return 0;\n    }\n    \n    if (!Jsi_Strncasecmp(query, \"SELECT\", 6))\n        return dbOptSelect(jdb, query, &ob, dbopts);\n        \n    DbEvalContext sEval = {};\n    int insert = 0, replace = 0, update = 0;\n    char nbuf[JSI_MAX_NUMBER_STRING], *bPtr;\n#ifdef JSI_DB_DSTRING_SIZE\n    JSI_DSTRING_VAR(dStr, JSI_DB_DSTRING_SIZE);\n#else\n    Jsi_DString sStr, *dStr = &sStr;\n    Jsi_DSInit(dStr);\n#endif\n    if (dbopts->noCache)\n        sEval.nocache = 1;\n    if (dbEvalInit(interp, &sEval, jdb, NULL, dStr, 0, 0) != JSI_OK)\n        return -1;\n    int dataMax = dbopts[0].arrSize;\n    cnt = 0;\n    if (dataMax==0)\n        dataMax = 1;\n    char ch[2];\n\n    ch[0] = dbopts[0].prefix;\n    ch[1] = 0;\n    if (!ch[0])\n        ch[0] = ':';\n    if ((update=(Jsi_Strncasecmp(query, \"UPDATE\", 6)==0))) {\n        Jsi_DSAppendLen(dStr, query, cPtr?(cPtr-query):-1);\n        if (cPtr) {\n            Jsi_DSAppend(dStr, \" \", NULL);\n            int cidx = 0;\n            int killf = (JSI_OPT_DB_IGNORE|JSI_OPT_READ_ONLY|JSI_OPT_INIT_ONLY);\n            for (specPtr = specs; specPtr->id != JSI_OPTION_END; specPtr++, cidx++) {\n                if (specPtr == ob.rowidPtr || specPtr == ob.dirtyPtr || (specPtr->flags&killf))\n                    continue;\n                const char *fname = specPtr->name;\n                if (ch[0] == '?')\n                    snprintf(bPtr=nbuf, sizeof(nbuf), \"%d\", cidx+1);\n                else\n                    bPtr = (char*)specPtr->name;\n                Jsi_DSAppend(dStr, (cnt?\",\":\"\"), \"[\", fname, \"]=\",\n                    ch, bPtr, NULL);\n                cnt++;\n            }\n            Jsi_DSAppend(dStr, cPtr+3, NULL);\n        }\n    } else if ((insert=(Jsi_Strncasecmp(query, \"INSERT\", 6)==0))\n        || (replace=(Jsi_Strncasecmp(query, \"REPLACE\", 7)==0))) {\n        Jsi_DSAppendLen(dStr, query, cPtr?(cPtr-query):-1);\n        if (cPtr) {\n            Jsi_DSAppend(dStr, \" (\", NULL);\n            int killf = JSI_OPT_DB_IGNORE;\n            if (replace)\n                killf |= (JSI_OPT_READ_ONLY|JSI_OPT_INIT_ONLY);\n            for (specPtr = specs; specPtr->id != JSI_OPTION_END; specPtr++) {\n                if (specPtr == ob.rowidPtr || specPtr == ob.dirtyPtr || specPtr->flags&killf)\n                    continue;\n                const char *fname = specPtr->name;\n                Jsi_DSAppend(dStr, (cnt?\",\":\"\"), \"[\", fname, \"]\", NULL);\n                cnt++;\n            }\n            Jsi_DSAppendLen(dStr,\") VALUES(\", -1);\n            cnt = 0;\n            int cidx = 0;\n            for (specPtr = specs; specPtr->id != JSI_OPTION_END; specPtr++, cidx++) {\n                if (specPtr == ob.rowidPtr || specPtr == ob.dirtyPtr\n                    || specPtr->flags&killf)\n                    continue;\n                if (ch[0] == '?')\n                    snprintf(bPtr=nbuf, sizeof(nbuf), \"%d\", cidx+1);\n                else\n                    bPtr = (char*)specPtr->name;\n                Jsi_DSAppend(dStr, (cnt?\",\":\"\"), ch, bPtr, NULL);\n                cnt++;\n            }\n            Jsi_DSAppend(dStr,\")\", cPtr+3, NULL);\n        }\n    } else if (!Jsi_Strncasecmp(query, \"DELETE\", 6)) {\n        Jsi_DSAppend(dStr, query, NULL);\n    } else {\n        Jsi_LogError(\"unrecognized query \\\"%s\\\": expected one of: SELECT, UPDATE, INSERT, REPLACE or DELETE\", query);\n        return -1;\n    }\n    sEval.zSql = Jsi_DSValue(dStr);\n    if (jdb->echo && sEval.zSql)\n        Jsi_LogInfo(\"SQL-ECHO: %s\\n\", sEval.zSql); \n\n    int rc, bindMax = -1, dataIdx = 0;\n    cnt = 0;\n    int ismodify = (replace||insert||update);\n    int isnew = (replace||insert);\n    int didBegin = 0;\n    DbEvalContext *p = &sEval;\n    rc = dbPrepareStmt(p->jdb, p->zSql, &p->zSql, &p->pPreStmt);\n    if( rc!=JSI_OK ) return -1;\n    if (dataMax>1 && !dbopts->noBegin) {\n        didBegin = 1;\n        if (!dbExecCmd(jdb, JSI_DBQUERY_BEGIN_STR, &erc))\n            goto bail;\n    }\n    while (dataIdx<dataMax) {\n        if (ismodify && ob.dirtyPtr && (dbopts->dirtyOnly)) { /* Check to limit updates to dirty values only. */\n            void *rec = dbopts[0].data;\n            if (dbopts->isPtrs || dbopts->isPtr2)\n                rec = ((void**)rec)[dataIdx];\n            else\n                rec = (char*)rec + (dataIdx * structSize);\n            char *ptr = (char*)rec + ob.dirtyPtr->offset;\n            int isDirty = *(int*)ptr;\n            int bit = 0;\n            if (ob.dirtyPtr->id == JSI_OPTION_BOOL)\n                bit = (uintptr_t)ob.dirtyPtr->data;\n            if (!(isDirty&(1<<(bit)))) {\n                dataIdx++;\n                continue;\n            }\n            isDirty &= ~(1<<(bit));\n            *(int*)ptr = isDirty; /* Note that the dirty bit is cleared, even upon error.*/\n        }\n        rc = dbBindOptionStmt(jdb, p->pPreStmt->pStmt, &ob, dataIdx, bindMax, dbopts);\n        if( rc!=JSI_OK )\n            goto bail;\n        bindMax = 1;\n        rc = dbEvalStepSub(p, (dataIdx>=dataMax), &erc);\n        if (rc == JSI_ERROR)\n            goto bail;\n        cnt += sqlite3_changes(jdb->db);\n        if (rc != JSI_OK && rc != JSI_BREAK)\n            break;\n        if (ob.rowidPtr && isnew) {\n            void *rec = dbopts[0].data;\n            if (dbopts->isPtrs || dbopts->isPtr2)\n                rec = ((void**)rec)[dataIdx];\n            else\n                rec = (char*)rec + (dataIdx * structSize);\n            char *ptr = (char*)rec + ob.rowidPtr->offset;\n            *(Jsi_Wide*)ptr = sqlite3_last_insert_rowid(jdb->db);\n        }\n        dataIdx++;\n    }\n    if (didBegin && !dbExecCmd(jdb, JSI_DBQUERY_COMMIT_STR, &erc))\n        rc = JSI_ERROR;\n    dbEvalFinalize(&sEval);\n    if( rc==JSI_BREAK ) {\n        rc = JSI_OK;\n    }\n    return (rc==JSI_OK?cnt:erc);\n\nbail:\n    dbEvalFinalize(&sEval);\n    if (didBegin)\n        dbExecCmd(jdb, JSI_DBQUERY_ROLLBACK_STR, NULL);\n    return erc;\n}\n\n#ifdef Jsi_DbQuery\n#undef Jsi_DbQuery\n#undef Jsi_DbHandle\n#undef Jsi_DbNew\n#endif\nint\nJsi_DbQuery(Jsi_Db *jdb, Jsi_CDataDb *dbopts, const char *query)\n{\n    int rc = jsi_DbQuery(jdb, dbopts, query);\n#ifdef JSI_DBQUERY_ERRORCMD\n    if (rc<0)\n        rc = JSI_DBQUERY_ERRORCMD(jdb, specs, data, arrSize, query, dopts, rc);\n#endif\n    return rc;\n}\n\nvoid *Jsi_DbHandle(Jsi_Interp *interp, Jsi_Db* jdb)\n{\n    SQLSIGASSERT(jdb,DB);\n    return jdb->db;\n}\n\n/* This is the non-script, JSI_LITE_ONLY creator for Jsi_Db */\nJsi_Db* Jsi_DbNew(const char *zFile, int inFlags /* JSI_DBI_* */)\n{\n    char *zErrMsg;\n    int flags = SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE;\n#ifdef SQLITE_JSI_DEFAULT_FULLMUTEX\n    flags |= SQLITE_OPEN_FULLMUTEX;\n#else\n    flags |= SQLITE_OPEN_NOMUTEX;\n#endif\n    if (!zFile)\n        zFile = \":memory:\";\n    zErrMsg = 0;\n    Jsi_Db *db = (Jsi_Db*)Jsi_Calloc(1, sizeof(*db) );\n    if( db==0 ) {\n        JSI_DBQUERY_PRINTF( \"malloc failed\\n\");\n        return NULL;\n    }\n    db->sig = SQLITE_SIG_DB;\n    db->stmtCacheMax = NUM_PREPARED_STMTS;\n    db->optPtr = &db->queryOpts;\n\n    if (inFlags&JSI_DBI_READONLY) {\n        flags &= ~(SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE);\n        flags |= SQLITE_OPEN_READONLY;\n    } else {\n        flags &= ~SQLITE_OPEN_READONLY;\n        flags |= SQLITE_OPEN_READWRITE;\n        if (inFlags&JSI_DBI_NOCREATE) {\n            flags &= ~SQLITE_OPEN_CREATE;\n        }\n    }\n    if(inFlags&JSI_DBI_NO_MUTEX) {\n        flags |= SQLITE_OPEN_NOMUTEX;\n        flags &= ~SQLITE_OPEN_FULLMUTEX;\n    } else {\n        flags &= ~SQLITE_OPEN_NOMUTEX;\n    }\n    if(inFlags&JSI_DBI_FULL_MUTEX) {\n        flags |= SQLITE_OPEN_FULLMUTEX;\n        flags &= ~SQLITE_OPEN_NOMUTEX;\n    } else {\n        flags &= ~SQLITE_OPEN_FULLMUTEX;\n    }\n    char cpath[PATH_MAX];\n    char *npath = Jsi_FileRealpathStr(NULL, zFile, cpath);\n    \n    if (SQLITE_OK != sqlite3_open_v2(npath, &db->db, flags, NULL)) {\n        JSI_DBQUERY_PRINTF( \"db open failed: %s\\n\", npath);\n        goto bail;\n    }\n    //Jsi_DSFree(&translatedFilename);\n\n    if( SQLITE_OK!=sqlite3_errcode(db->db) ) {\n        zErrMsg = sqlite3_mprintf(\"%s\", sqlite3_errmsg(db->db));\n        DbClose(db->db);\n        db->db = 0;\n    }\n    if( db->db==0 ) {\n        JSI_DBQUERY_PRINTF( \"Db open failed %s\\n\", zErrMsg);\n        sqlite3_free(zErrMsg);\n        goto bail;\n    }\n    db->stmtHash = Jsi_HashNew(NULL, JSI_KEYS_STRING, NULL);\n    db->strKeyTbl = Jsi_HashNew(NULL, JSI_KEYS_STRING, NULL);\n    db->stmtCache = Jsi_ListNew((Jsi_Interp*)db, 0, dbStmtFreeProc);\n    return db;\n    \nbail:\n    return NULL;\n}\n\n#ifndef JSI_LITE_ONLY\n\nstatic Jsi_RC Jsi_DoneSqlite(Jsi_Interp *interp)\n{\n    Jsi_UserObjUnregister(interp, &sqliteobject);\n    const char *provide = \"Sqlite\";\n    Jsi_PkgProvide(interp, provide, -1, NULL);\n    return JSI_OK;\n}\n#ifdef JSI_DB_TEST\n#include \"c-demos/dbdemo.c\"\n#endif\n\nJsi_RC Jsi_InitSqlite(Jsi_Interp *interp, int release)\n{\n    if (release) return Jsi_DoneSqlite(interp);\n    Jsi_Hash* dbSys;\n#if JSI_USE_STUBS\n    if (Jsi_StubsInit(interp, 0) != JSI_OK)\n        return JSI_ERROR;\n#endif\n\n    if (!(dbSys = Jsi_UserObjRegister(interp, &sqliteobject))) \n        return Jsi_LogError(\"Failed to init sqlite extension\");\n\n    Jsi_Value *info = Jsi_ValueNew1(interp);\n    Jsi_JSONParseFmt(interp, &info, \"{libVer:\\\"%s\\\", hdrVer:\\\"%s\\\", hdrNum:%d, hdrSrcId:\\\"%s\\\", pkgVer:%d}\",\n        (char *)sqlite3_libversion(), SQLITE_VERSION, SQLITE_VERSION_NUMBER, SQLITE_SOURCE_ID, jsi_DbPkgVersion);\n    Jsi_PkgOpts dbPkgOpts = { db_ObjCmd_Specs, &dbObjCmd, sqliteCmds, info };\n    Jsi_RC rc = Jsi_PkgProvideEx(interp, \"Sqlite\", jsi_DbPkgVersion, Jsi_InitSqlite, &dbPkgOpts);\n    Jsi_DecrRefCount(interp, info);\n    if (rc != JSI_OK)\n        return JSI_ERROR;\n\n    if (!Jsi_CommandCreateSpecs(interp, sqliteobject.name, sqliteCmds, dbSys, JSI_CMDSPEC_ISOBJ))\n        return JSI_ERROR;        \n\n#ifdef JSI_DB_TEST\n    if (getenv(\"RUN_DB_TEST\"))\n        TestSqlite(interp);\n#endif\n    jsi_DbVfs **dbVfsPtrPtr = (jsi_DbVfs **)Jsi_InterpGetData(interp, JSI_SQLITE_DB_VFS, NULL);\n    if (dbVfsPtrPtr)\n        *dbVfsPtrPtr = &SqliteDbVfs;\n    return JSI_OK;\n}\n#endif //JSI_LITE_ONLY\n\n#else // !JSI__SQLITE\n/* Linking for when Sqlite is not compiled-in. */\n\nstatic jsi_DbVfs *jsi_dbVfsPtr = NULL;\n#ifndef JSI_LITE_ONLY\n\n\nJsi_RC Jsi_initSqlite(Jsi_Interp *interp, int release)\n{\n    if (!release) Jsi_InterpSetData(interp, JSI_SQLITE_DB_VFS, &jsi_dbVfsPtr, NULL);\n    return JSI_OK;\n}\n\nJsi_RC Jsi_doneSqlite(Jsi_Interp *interp)\n{\n    Jsi_InterpFreeData(interp, JSI_SQLITE_DB_VFS);\n    return JSI_OK;\n}\n#endif\n\nint\nJsi_DbQuery(Jsi_Db *jdb, Jsi_CDataDb *dPtr, const char *query)\n{\n    if (!jsi_dbVfsPtr) {\n        printf( \"Sqlite unsupported\\n\");\n        return -1;\n    }\n    return jsi_dbVfsPtr->dbcQuery(jdb, dPtr, query);\n}\n\nvoid *Jsi_DbHandle(Jsi_Interp *interp, Jsi_Db* jdb)\n{\n    if (!jsi_dbVfsPtr) {\n        printf( \"Sqlite unsupported\\n\");\n        return NULL;\n    }\n    return jsi_dbVfsPtr->dbHandle(interp, jdb);\n}\n\nJsi_Db* Jsi_DbNew(const char *zFile, int inFlags /* JSI_DBI_* */)\n{\n    if (!jsi_dbVfsPtr) {\n        printf( \"Sqlite unsupported\\n\");\n        return NULL;\n    }\n    return jsi_dbVfsPtr->dbNew(zFile, inFlags);\n}\n\n#endif\n", "#ifndef JSI_LITE_ONLY\n#ifndef JSI_AMALGAMATION\n#include \"jsiInt.h\"\n#endif\n    \n#define ChkString(_this, funcPtr, dest, lenPtr, bytePtr) \\\n    int skip __attribute__((unused)); skip = 0; \\\n    if (_this->vt != JSI_VT_OBJECT || _this->d.obj->ot != JSI_OT_STRING) { \\\n        Jsi_LogError(\"apply String.%s to a non-string object\", funcPtr->cmdSpec->name); \\\n        return JSI_ERROR; \\\n    } else  { \\\n        dest = Jsi_ValueString(interp, _this, bytePtr); \\\n        *lenPtr = Jsi_NumUtfChars(dest, -1); \\\n        if (!dest) dest = (char*)\"\"; \\\n    }\n\nstatic Jsi_RC StringConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (Jsi_FunctionIsConstructor(funcPtr)) {\n        const char *nv = \"\";\n        int len = -1;\n        if (Jsi_ValueGetLength(interp, args) > 0) {\n            Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n            if (v) {\n                \n                nv = Jsi_ValueToString(interp, v, &len);\n            }\n        }\n        if (_this->vt == JSI_VT_OBJECT && _this->d.obj->ot == JSI_OT_STRING) {\n            if (_this->d.obj->d.s.str)\n                if (!_this->d.obj->isstrkey)\n                    Jsi_Free(_this->d.obj->d.s.str);\n            _this->d.obj->isstrkey = 0;\n            _this->d.obj->d.s.str = Jsi_StrdupLen(nv, len);\n            _this->d.obj->d.s.len = len;\n        } else\n            jsi_ValueMakeBlobDup(interp, &_this, (uchar*)nv, len);\n        Jsi_ValueDup2(interp, ret, _this);\n        return JSI_OK;\n    }\n    if (Jsi_ValueGetLength(interp, args) > 0) {\n        Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n        if (v) {\n            Jsi_ValueDup2(interp, ret, v);\n            Jsi_ValueToString(interp, *ret, NULL);\n            return JSI_OK;\n        }\n    }\n    Jsi_ValueMakeStringDup(interp, ret, \"\");\n    return JSI_OK;\n}\n\n\nstatic Jsi_RC StringSplitCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, //TODO: UTF\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char **argv; int argc;\n    int sLen, bLen, spLen = 1, noEmpty=0;\n    Jsi_RC rc = JSI_OK;\n    const char *v, *split = \"\";\n    \n    ChkString(_this, funcPtr, v, &sLen, &bLen);\n\n    Jsi_Value *spliton = Jsi_ValueArrayIndex(interp, args, skip);\n    \n    if (spliton) {\n        if (Jsi_ValueIsNull(interp, spliton))\n            noEmpty = 1;\n        else if (Jsi_ValueIsString(interp, spliton))\n            split = Jsi_ValueString(interp, spliton, &spLen);\n    }\n\n    Jsi_DString sStr;\n    Jsi_DSInit(&sStr);\n    if (spLen)\n        Jsi_SplitStr(v, &argc, &argv, split, &sStr);\n    Jsi_Obj *obj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    int i, n = 0, siz = argc;\n    if (noEmpty) {\n        for (i=0, siz=0; i<argc; i++) if (argv[i][0]) siz++;\n    } else if (!spLen)\n        argc = siz = bLen;\n    if (Jsi_ObjArraySizer(interp, obj, siz) <= 0) {\n        rc = Jsi_LogError(\"index too large: %d\", siz);\n        Jsi_ObjFree(interp, obj);\n        goto bail;\n    }\n    Jsi_ValueMakeArrayObject(interp, ret, obj);\n    for (i = 0; i < argc; ++i) {\n        if (noEmpty && !argv[i][0]) continue;\n        char ctmp[2] = \" \",  *cst = ctmp;\n        if (!spLen)\n            ctmp[0] = v[i];\n        else\n            cst = argv[i];\n        Jsi_Value *v = Jsi_ValueNewStringDup(interp, cst);\n        Jsi_IncrRefCount(interp, v);\n        obj->arr[n++] = v;\n    }\n    Jsi_ObjSetLength(interp, obj, siz);\n    \nbail:\n    Jsi_DSFree(&sStr);\n    return rc;\n}\n\nstatic Jsi_RC StringSubstrCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int sLen, bLen;\n    const char *v;\n    ChkString(_this, funcPtr, v, &sLen, &bLen);\n\n    Jsi_Value *start = Jsi_ValueArrayIndex(interp, args, skip);\n    Jsi_Value *len = Jsi_ValueArrayIndex(interp, args, skip+1);\n    \n    Jsi_Number nstart, nlen;\n    if (!start || Jsi_GetNumberFromValue(interp,start, &nstart) != JSI_OK) {\n        jsi_ValueMakeBlobDup(interp, ret, (uchar*)v, bLen);\n        return JSI_OK;\n    }\n    int istart = (int)nstart, olen = -1;\n    Jsi_DString dStr;\n    char *ostr;\n    Jsi_DSInit(&dStr);\n    if (!len || Jsi_GetNumberFromValue(interp,len, &nlen) != JSI_OK) {\n        if (sLen == bLen) {\n            ostr = jsi_SubstrDup(v, bLen, istart, -1, &olen);\n            Jsi_ValueMakeBlob(interp, ret, (uchar*)ostr, olen);\n        } else {\n            Jsi_UtfSubstr(v, istart, -1, &dStr);\n            Jsi_ValueFromDS(interp, &dStr, ret);\n        }\n        return JSI_OK;\n    }\n    int ilen = (int)nlen;\n    if (ilen <= 0) {\n        Jsi_ValueMakeStringDup(interp, ret, \"\");\n    } else {\n        if (sLen == bLen) {\n            ostr = jsi_SubstrDup(v, bLen, istart, ilen, &olen);\n            Jsi_ValueMakeBlob(interp, ret, (uchar*)ostr, olen);\n        } else {\n            Jsi_UtfSubstr(v, istart, ilen, &dStr);\n            Jsi_ValueFromDS(interp, &dStr, ret);\n        }\n    }\n    return JSI_OK;\n}\n\nstatic Jsi_RC StringSubstringCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int sLen = 0, bLen;\n    const char *v;\n    ChkString(_this, funcPtr, v, &sLen, &bLen);\n\n    Jsi_Value *start = Jsi_ValueArrayIndex(interp, args, skip);\n    Jsi_Value *end = Jsi_ValueArrayIndex(interp, args, skip+1);\n    \n    Jsi_Number nstart, nend;\n    if (!start || Jsi_GetNumberFromValue(interp,start, &nstart) != JSI_OK) {\n        Jsi_ValueMakeStringDup(interp, ret, v);\n        return JSI_OK;\n    }\n    int istart = (int)nstart, olen = -1;\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    char *ostr;\n    if (!end || Jsi_GetNumberFromValue(interp,end, &nend) != JSI_OK) {\n        if (sLen == bLen) {\n            ostr = jsi_SubstrDup(v, bLen, istart, -1, &olen);\n            Jsi_ValueMakeBlob(interp, ret, (uchar*)ostr, olen);\n        } else {\n            Jsi_UtfSubstr(v, istart, -1, &dStr);\n            Jsi_ValueFromDS(interp, &dStr, ret);\n        }\n        return JSI_OK;\n    }\n    int iend = (int)nend;\n    if (iend>sLen)\n        iend = sLen;\n    if (iend < istart) {\n        Jsi_ValueMakeStringDup(interp, ret, \"\");\n    } else {\n        if (sLen == bLen) {\n            ostr = jsi_SubstrDup(v, bLen, istart, iend-istart+1, &olen);\n            Jsi_ValueMakeBlob(interp, ret, (uchar*)ostr, olen);\n        } else {\n            Jsi_UtfSubstr(v, istart, iend-istart+1, &dStr);\n            Jsi_ValueFromDS(interp, &dStr, ret);\n        }\n    }\n    return JSI_OK;\n}\n\n\nstatic Jsi_RC StringRepeatCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int sLen, bLen;\n    const char *v;\n    ChkString(_this, funcPtr, v, &sLen, &bLen);\n    \n    Jsi_Value *start = Jsi_ValueArrayIndex(interp, args, skip);\n    \n    Jsi_Number ncnt;\n    if (!start || Jsi_GetNumberFromValue(interp,start, &ncnt) != JSI_OK || ncnt>MAX_LOOP_COUNT || ncnt<0 || bLen<=0) {\n        return JSI_ERROR;\n    }\n    int cnt = (int)ncnt;\n    Jsi_DString dStr = {};\n    while (cnt-- > 0) {\n        Jsi_DSAppendLen(&dStr, v, bLen);\n        if (Jsi_DSLength(&dStr)>JSI_MAX_ALLOC_BUF) {\n            Jsi_DSFree(&dStr);\n            return Jsi_LogError(\"too long\");\n        }\n    }\n    Jsi_ValueFromDS(interp, &dStr, ret);\n    return JSI_OK;\n}\n\nstatic Jsi_RC StringIndexOfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int sLen, bLen;\n    const char *v;\n    ChkString(_this, funcPtr, v, &sLen, &bLen);\n\n    Jsi_Value *seq = Jsi_ValueArrayIndex(interp, args, skip);\n    Jsi_Value *start = Jsi_ValueArrayIndex(interp, args, skip+1);\n\n    if (!seq) {\n        Jsi_ValueMakeNumber(interp,ret, -1);\n        return JSI_OK;\n    }\n\n    const char *vseq = Jsi_ValueToString(interp, seq, NULL);\n    int istart = 0;\n    if (start) {\n        if (Jsi_GetIntFromValue(interp, start, &istart)) {\n            return JSI_ERROR;\n        }\n        if (istart < 0) istart = 0;\n    }\n\n    int r = Jsi_Strpos(v, istart, vseq, 0);\n    Jsi_ValueMakeNumber(interp, ret, r);\n\n    return JSI_OK;\n}\n\nstatic Jsi_RC StringMatchCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int sLen, bLen;\n    const char *source_str;\n    ChkString(_this, funcPtr, source_str, &sLen, &bLen);\n    const char *v = source_str;\n    Jsi_Value *seq = Jsi_ValueArrayIndex(interp, args, skip);\n\n    if (Jsi_ValueIsString(interp, seq)) {\n        char *cp = Jsi_ValueString(interp, seq, NULL);\n\n        if (jsi_RegExpValueNew(interp, cp, seq) != JSI_OK)\n            return JSI_ERROR;\n    }\n    /* TODO: differentiate from re.exec() */\n    return jsi_RegExpMatches(interp, seq, v, bLen, *ret, NULL, 1);\n}\n\nstatic Jsi_RC StringFromCharCodeCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (_this->vt != JSI_VT_OBJECT || _this->d.obj->ot == JSI_OT_STRING)\n        return Jsi_LogError(\"should be called via String.fromCharCode\");\n    \n    Jsi_DString dStr = {};\n    int n, i, len, argc = Jsi_ValueGetLength(interp, args);\n    for (i=0; i<argc; i++) {\n        Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, i);\n        if (!Jsi_ValueIsNumber(interp, v) || Jsi_GetIntFromValue(interp, v, &n) != JSI_OK) {\n            Jsi_DSFree(&dStr);\n            return Jsi_LogError(\"expected int value at arg %d\", i+1);\n        }\n        char dest[5];\n        len = Jsi_UniCharToUtf((Jsi_UniChar)n, dest);\n        Jsi_DSAppendLen(&dStr, dest, len);\n    }\n    \n    Jsi_ValueMakeDStringObject(interp, ret, &dStr);\n    return JSI_OK;\n}\n\nstatic Jsi_RC StringCharCodeAtCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int sLen, bLen;\n    const char *source_str;\n    ChkString(_this, funcPtr, source_str, &sLen, &bLen);\n    const char *v = source_str;\n\n    Jsi_Value *ttPtr = Jsi_ValueNew1(interp);\n    Jsi_ValueCopy(interp, ttPtr, _this);\n    \n    int pos = 0;\n    Jsi_Value *vpos;\n    if ((vpos = Jsi_ValueArrayIndex(interp, args, skip))) {\n        jsi_ValueToOInt32(interp, vpos);\n        pos = (int)vpos->d.num;\n    }\n\n#if JSI__UTF8\n    int m;\n    if (pos >= 0 && pos < sLen && ((m=Jsi_UtfIndexToOffset(v, pos))>=0)) {\n        int32_t n;\n        Jsi_UtfToUniChar(v+m, &n);\n        Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)n);\n    }\n#else\n    int slen = Jsi_Strlen(v);\n    if (pos >= 0 && pos < slen) {\n        Jsi_ValueMakeNumber(interp, ret, v[pos]);\n    }\n#endif\n    else\n        Jsi_ValueMakeNumber(interp, ret, Jsi_NumberNaN());\n    Jsi_DecrRefCount(interp, ttPtr);\n    return JSI_OK;\n}\n\n\nstatic Jsi_RC _StringTrimCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, // TODO: UTF\n    Jsi_Value **ret, Jsi_Func *funcPtr, int ends)\n{\n    const char *tstr = \" \\t\\n\\r\", *vstr;\n    int vend,  n, tlen = Jsi_Strlen(tstr), clen, bLen;\n    ChkString(_this, funcPtr, vstr, &clen, &bLen);\n    \n    Jsi_Value *tchars = Jsi_ValueArrayIndex(interp, args, skip);\n    \n    if (tchars) {\n        tstr = Jsi_ValueToString(interp, tchars, NULL);\n        tlen = Jsi_Strlen(tstr);\n    }\n    \n    if (ends&1) {\n        while (*vstr) {\n            for (n=0; n<tlen; n++)\n                if (tstr[n] == *vstr) break;\n            if (n>=tlen) break;\n            vstr++;\n            clen--;\n        }\n    }\n    vend = clen-1;\n    if (ends&2) {\n        for (; vend>=0; vend--) {\n            for (n=0; n<tlen; n++)\n                if (tstr[n] == vstr[vend]) break;\n            if (n>=tlen) break;\n        }\n    }\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    Jsi_UtfSubstr(vstr, 0, vend+1, &dStr);\n    Jsi_ValueFromDS(interp, &dStr, ret);\n    return JSI_OK;\n}\n\nstatic Jsi_RC StringTrimCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    return _StringTrimCmd(interp, args, _this, ret, funcPtr, 3);\n}\nstatic Jsi_RC StringTrimLeftCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    return _StringTrimCmd(interp, args, _this, ret, funcPtr, 1);\n}\n\nstatic Jsi_RC StringTrimRightCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    return _StringTrimCmd(interp, args, _this, ret, funcPtr, 2);\n}\n\n\nchar *jsi_utf_tocase(const char *cp, int upper, Jsi_DString *dsPtr)\n{\n    char unibuf[10];\n    while (*cp) {\n#if JSI__UTF8\n        if (*cp&0x80) {\n            int32_t c;\n            Jsi_UtfToUniChar(cp, &c);\n            int n = Jsi_UniCharToUtf(c, unibuf);\n            unibuf[n] = 0;\n            cp += n;\n        } else\n#endif\n        {\n            unibuf[0] = (upper?toupper(*cp):tolower(*cp));\n            unibuf[1] = 0;\n            cp++;\n        }\n        if (upper==2) //totile\n            upper = 0;\n        Jsi_DSAppend(dsPtr, unibuf, NULL);\n    }\n    return Jsi_DSValue(dsPtr);\n}\n\n\n\nstatic Jsi_RC StringToLowerCaseCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int sLen, bLen;\n    const char *vstr;\n    ChkString(_this, funcPtr, vstr, &sLen, &bLen);\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    jsi_utf_tocase(vstr, 0, &dStr);\n    Jsi_ValueFromDS(interp, &dStr, ret);\n    return JSI_OK;\n}\n\nstatic Jsi_RC StringToUpperCaseCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int sLen, bLen;\n    const char *vstr;\n    ChkString(_this, funcPtr, vstr, &sLen, &bLen);\n\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    jsi_utf_tocase(vstr, 1, &dStr);\n    Jsi_ValueFromDS(interp, &dStr, ret);\n    return JSI_OK;\n}\n\nstatic Jsi_RC StringToTitleCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int sLen, bLen;\n    const char *vstr;\n    ChkString(_this, funcPtr, vstr, &sLen, &bLen);\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    jsi_utf_tocase(vstr, 2, &dStr);\n    Jsi_ValueFromDS(interp, &dStr, ret);\n    return JSI_OK;\n}\n\nstatic Jsi_RC StringCharAtCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int pos = 0, len, bLen;\n    const char *vstr;\n    ChkString(_this, funcPtr, vstr, &len, &bLen);\n   \n    Jsi_Value *vpos = Jsi_ValueArrayIndex(interp, args, 0);\n    if (Jsi_GetIntFromValue(interp, vpos, &pos)) {\n        return JSI_ERROR;        \n    }\n    if (pos<0 || pos >=len)\n        Jsi_ValueMakeStringDup(interp, ret, \"\");\n    else {\n        Jsi_DString dStr;\n        Jsi_DSInit(&dStr);\n        Jsi_UtfSubstr(vstr, pos, 1, &dStr);\n        Jsi_ValueFromDS(interp, &dStr, ret);\n    }\n    return JSI_OK;\n}\n\nstatic Jsi_RC StringLastIndexOfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int sLen, bLen;\n    const char *v;\n    ChkString(_this, funcPtr, v, &sLen, &bLen);\n\n    Jsi_Value *seq = Jsi_ValueArrayIndex(interp, args, skip);\n    Jsi_Value *start = Jsi_ValueArrayIndex(interp, args, 1+skip);\n\n    if (!seq) {\n        Jsi_ValueMakeNumber(interp, ret, -1);\n        return JSI_OK;\n    }\n\n    const char *vseq = Jsi_ValueToString(interp, seq, NULL);\n    int istart = 0;\n    if (start) {\n        if (Jsi_GetIntFromValue(interp, start, &istart)) {\n            return JSI_ERROR;\n        }\n        if (istart < 0) istart = 0;\n    }\n\n    int r = Jsi_Strrpos(v, istart, vseq, 0);\n    Jsi_ValueMakeNumber(interp, ret, r);\n\n    return JSI_OK;;\n}\n\nstatic Jsi_RC StringConcatCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int sLen, bLen;\n    const char *vstr;\n    ChkString(_this, funcPtr, vstr, &sLen, &bLen);\n    \n    Jsi_DString dStr = {};\n    Jsi_DSAppend(&dStr, vstr, NULL);\n    int i, argc = Jsi_ValueGetLength(interp, args);\n    for (i=skip; i<argc; i++)\n    {\n        Jsi_Value *s = Jsi_ValueArrayIndex(interp, args, i);\n        if (Jsi_GetStringFromValue(interp, s, &vstr)) {\n            Jsi_LogError(\"String get failure\");\n            Jsi_DSFree(&dStr);\n            return JSI_ERROR;\n        }\n        Jsi_DSAppend(&dStr, vstr, NULL);\n    }\n\n    Jsi_ValueFromDS(interp, &dStr, ret);\n    return JSI_OK;\n    \n}\n\nstatic Jsi_RC StringSliceCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int sLen, bLen;\n    const char *vstr;\n    ChkString(_this, funcPtr, vstr, &sLen, &bLen);\n\n    Jsi_Value *start = Jsi_ValueArrayIndex(interp, args, skip);\n    Jsi_Value *end = Jsi_ValueArrayIndex(interp, args, 1+skip);\n    int istart, iend, len = Jsi_Strlen(vstr);\n\n    if (Jsi_GetIntFromValue(interp, start, &istart)) {\n        return JSI_ERROR;\n    }\n    if (istart < 0)\n        istart = len+istart;\n    if (istart < 0)\n        istart = 0;\n    if (istart>=len)\n        istart = len-1;\n    iend = len;\n    if (end) {\n        if (Jsi_GetIntFromValue(interp, end, &iend)) {\n            return JSI_ERROR;\n        }\n        if (iend < 0)\n            iend = len+iend;\n        if (iend>=len)\n            iend = len;\n        if (iend<istart)\n            iend = istart;\n    }\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    Jsi_UtfSubstr(vstr, istart, iend, &dStr);\n    Jsi_ValueFromDS(interp, &dStr, ret);\n    return JSI_OK;\n}\n\nstatic Jsi_RC StringMapCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    /* Now handles perl regex flag extensions.*/\n    const char *source_str;\n    const char *replace_str = NULL;\n    uint i, j;\n    int slen, source_len, replace_len, bLen;\n\n    const char *p;\n    bool nocase = 0;\n    /* Is a generic  String.replace if _this->d.obj is a function */\n    ChkString(_this, funcPtr, source_str, &source_len, &bLen);\n    int argc = Jsi_ValueGetLength(interp, args);\n    Jsi_Value *repVal = Jsi_ValueArrayIndex(interp, args, skip);\n    if (Jsi_ValueIsArray(interp, repVal)==0 || repVal->d.obj->arrCnt&1) \n        return Jsi_LogError(\"expected even length array\");\n    if (argc>(skip+1) && Jsi_ValueGetBoolean(interp, Jsi_ValueArrayIndex(interp, args, skip+1), &nocase) != JSI_OK) \n        return Jsi_LogError(\"expected boolean\");\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    Jsi_Obj *obj = repVal->d.obj;\n    p = source_str;\n    for (j=0; j<(uint)bLen; j++, p++) {\n        for (i=0; i<obj->arrCnt; i+=2) {\n            if (!obj->arr[i]) continue;\n            if (!obj->arr[i+1]) continue;\n            const char *cp = Jsi_ValueToString(interp, obj->arr[i], &slen);\n            if (!cp || !slen) {\n                Jsi_DSFree(&dStr);\n                return Jsi_LogError(\"map src can not be empty\");\n            }\n            int res = (nocase ? Jsi_Strncasecmp(cp, p, slen) : Jsi_Strncmp(cp, p, slen));\n            if (!res) {\n                replace_str = Jsi_ValueToString(interp, obj->arr[i+1], &replace_len);\n                Jsi_DSAppendLen(&dStr, replace_str, replace_len);\n                p += slen-1;\n                j += slen-1;\n                break;\n            }\n        }\n        if (i>=obj->arrCnt)\n            Jsi_DSAppendLen(&dStr, p, 1);\n    }\n\n    Jsi_ValueFromDS(interp, &dStr, ret);\n    return JSI_OK;\n}\n    \n#define FN_strreplace JSI_INFO(\"\\\nIf the replace argument is a function, it is called with match,p1,p2,...,offset,string.  \\\nIf called function is known to have 1 argument, it is called with just the match.\")\nstatic Jsi_RC StringReplaceCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    /* Now handles perl regex flag extensions.*/\n    const char *source_str;\n    int source_len, bLen;\n    const char *replace_str = NULL;\n    int replace_len;\n    int regexec_flags = 0;\n    Jsi_Value *seq, *strVal;\n    Jsi_DString dStr = {};\n    regex_t *regex;\n    Jsi_Regex *re;\n    const char *p;\n    int maxArgs = 1;\n\n    int offset = 0, n, j, isglob = 0, num_matches = 0;\n    /* Is a generic  String.replace if _this->d.obj is a function */\n    ChkString(_this, funcPtr, source_str, &source_len, &bLen);\n    source_len = bLen;\n    if (!skip)\n        strVal = _this;\n    else\n        strVal = Jsi_ValueArrayIndex(interp, args, 0);\n    seq = Jsi_ValueArrayIndex(interp, args, skip);\n    Jsi_Value *repVal = Jsi_ValueArrayIndex(interp, args, 1+skip);\n    if (!Jsi_ValueIsFunction(interp, repVal))\n        replace_str = Jsi_ValueToString(interp, repVal, &replace_len);\n    else\n        maxArgs = repVal->d.obj->d.fobj->func->argnames->argCnt;\n    Jsi_DSInit(&dStr);\n\n    if (Jsi_ValueIsString(interp, seq)) {\n        const char *ce, *cp = Jsi_ValueString(interp, seq, NULL);\n        if (!(ce = Jsi_Strstr(source_str, cp)))\n            Jsi_ValueMakeStringDup(interp, ret, source_str);\n        else {\n            int slen;\n            slen = (ce-source_str);\n            if (slen)\n                Jsi_DSAppendLen(&dStr, source_str, slen);\n            if (replace_str)\n                Jsi_DSAppendLen(&dStr, replace_str, replace_len);\n            else {\n                Jsi_Value *inStr = Jsi_ValueNewStringDup(interp, source_str);\n                Jsi_IncrRefCount(interp, inStr);\n                Jsi_RC rc = Jsi_FunctionInvokeString(interp, repVal, inStr, &dStr);\n                if (Jsi_InterpGone(interp))\n                    return JSI_ERROR;\n                if (rc != JSI_OK) {\n                    Jsi_DSFree(&dStr);\n                    Jsi_DecrRefCount(interp, inStr);\n                    return JSI_ERROR;\n                }\n                Jsi_DecrRefCount(interp, inStr);\n            }\n            Jsi_DSAppend(&dStr, ce+Jsi_Strlen(cp), NULL);\n            Jsi_ValueFromDS(interp, &dStr, ret);\n        }\n        return JSI_OK;\n    }\n    if (seq == NULL || seq->vt != JSI_VT_OBJECT || seq->d.obj->ot != JSI_OT_REGEXP) {\n        Jsi_ValueMakeNull(interp, ret);\n        return JSI_OK;\n    }\n\n    re = seq->d.obj->d.robj;\n    regex = &re->reg;\n    isglob = (re->eflags & JSI_REG_GLOB);\n    \n    regmatch_t pmatch[MAX_SUBREGEX] = {};\n    /* If an offset has been specified, adjust for that now.\n     * If it points past the end of the string, point to the terminating null\n     */\n    int eoffset=0;\n    if (offset) {\n        if (offset < 0) {\n            offset += source_len + 1;\n        }\n        if (offset > source_len) {\n            offset = source_len;\n        }\n        else if (offset < 0) {\n            offset = 0;\n        }\n    }\n\n    Jsi_DSAppendLen(&dStr, source_str, offset);\n    n = source_len - offset;\n    p = source_str + offset;\n    Jsi_RC rc = JSI_OK;\n    do {\n        if (num_matches > 10000000) {\n            Jsi_LogBug(\"regexp infinite loop\");\n            rc = JSI_ERROR;\n            break;\n        }\n        int match = regexec(regex, p, MAX_SUBREGEX, pmatch, regexec_flags);\n\n        if (match >= REG_BADPAT) {\n            char buf[JSI_MAX_NUMBER_STRING];\n\n            regerror(match, regex, buf, sizeof(buf));\n            Jsi_LogError(\"error while matching pattern: %s\", buf);\n            Jsi_DSFree(&dStr);\n            return JSI_ERROR;\n        }\n        if (match == REG_NOMATCH) {\n            break;\n        }\n        num_matches++;\n        Jsi_DSAppendLen(&dStr, p, pmatch[0].rm_so);\n\n        if (replace_str &&  !Jsi_Strchr(replace_str, '$'))\n            Jsi_DSAppend(&dStr, replace_str, NULL);\n        else if (replace_str) {\n            for (j = 0; j < replace_len; j++) {\n                int idx;\n                int c = replace_str[j];\n     \n                if (c == '$' && j < replace_len) {\n                    c = replace_str[++j];\n                    if ((c >= '0') && (c <= '9')) {\n                        idx = c - '0';\n                    } else if (c == '&') {\n                        idx = 0;\n                    } else if (c == '$') {\n                        Jsi_DSAppendLen(&dStr, replace_str + j, 1);\n                        continue;\n                    }\n                    else if (c == '\\'') {\n                        Jsi_DSAppendLen(&dStr, p + pmatch[0].rm_eo, pmatch[0].rm_eo-Jsi_Strlen(p));\n                        continue;\n                    }\n                    else if (c == '`') {\n                        Jsi_DSAppendLen(&dStr, p, pmatch[0].rm_so);\n                        continue;\n                    }\n                    else {\n                        Jsi_DSAppendLen(&dStr, replace_str + j - 1, 2);\n                        continue;\n                    }\n                } else {\n                     Jsi_DSAppendLen(&dStr, replace_str + j, 1);\n                     continue;\n                }\n                if ((idx < MAX_SUBREGEX) && pmatch[idx].rm_so != -1 && pmatch[idx].rm_eo != -1) {\n                    Jsi_DSAppendLen(&dStr, p + pmatch[idx].rm_so,\n                        pmatch[idx].rm_eo - pmatch[idx].rm_so);\n                }\n            }\n    \n        } else {\n            Jsi_DString sStr;\n            Jsi_DSInit(&sStr); \n            if (pmatch[0].rm_so <= 0 && pmatch[0].rm_eo <= 0)\n                break;\n            int olen = -1;\n            char *ostr = jsi_SubstrDup(p, -1, pmatch[0].rm_so, pmatch[0].rm_eo - pmatch[0].rm_so, &olen);\n            Jsi_Value *inStr = Jsi_ValueMakeBlob(interp, NULL, (uchar*)ostr, olen);\n            Jsi_DSFree(&sStr);\n            Jsi_IncrRefCount(interp, inStr);\n            if (maxArgs==1) {\n                Jsi_RC rc = Jsi_FunctionInvokeString(interp, repVal, inStr, &dStr);\n                if (Jsi_InterpGone(interp))\n                    return JSI_ERROR;\n                if (rc != JSI_OK) {\n                    Jsi_DSFree(&dStr);\n                    Jsi_DecrRefCount(interp, inStr);\n                    return JSI_ERROR;\n                }\n            } else {\n                Jsi_Value *vpargs, *items[MAX_SUBREGEX] = {}, *ret;\n                int i;\n                items[0] = inStr;\n                for (i=1; i<=(int)re->reg.re_nsub && i<(MAX_SUBREGEX-3); i++) {\n                    if (pmatch[i].rm_so<0)\n                        items[i] = interp->NullValue;\n                    else {\n                        ostr = jsi_SubstrDup(p, -1, pmatch[i].rm_so, pmatch[i].rm_eo - pmatch[i].rm_so, &olen);\n                        items[i] = Jsi_ValueMakeBlob(interp, NULL, (uchar*)ostr, olen);\n                    }\n                }\n                items[i++] = Jsi_ValueMakeNumber(interp, NULL, eoffset+pmatch[0].rm_so);\n                items[i++] = strVal;\n                vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, i, 0));\n                Jsi_IncrRefCount(interp, vpargs);\n                ret = Jsi_ValueNew1(interp);\n                rc = Jsi_FunctionInvoke(interp, repVal, vpargs, &ret, NULL);\n                if (Jsi_InterpGone(interp))\n                    return JSI_ERROR;\n                Jsi_DecrRefCount(interp, vpargs);\n                if (rc == JSI_OK)\n                    Jsi_DSAppend(&dStr, Jsi_ValueToString(interp, ret, NULL), NULL);\n                Jsi_DecrRefCount(interp, ret);\n                if (rc != JSI_OK) {\n                    Jsi_DSFree(&dStr);\n                    Jsi_DecrRefCount(interp, inStr);\n                    return JSI_ERROR;\n                }\n            }\n            Jsi_DecrRefCount(interp, inStr);\n        }\n        eoffset += pmatch[0].rm_eo;\n        p += pmatch[0].rm_eo;\n        n -= pmatch[0].rm_eo;\n        /* If -all is not specified, or there is no source left, we are done */\n        if (!isglob || n == 0 || pmatch[0].rm_eo == 0) {\n            break;\n        }\n        /* An anchored pattern without -line must be done */\n        if ((re->eflags & JSI_REG_NEWLINE) == 0 && re->pattern[0] == '^') {\n            break;\n        }\n        \n        /* If the pattern is empty, need to step forwards */\n        if (re->pattern[0] == '\\0' && n) {\n            /* Need to copy the char we are moving over */\n            Jsi_DSAppendLen(&dStr, p, 1);\n            p++;\n            n--;\n        }\n\n        regexec_flags |= REG_NOTBOL;\n    } while (n);\n\n    /*\n     * Copy the portion of the string after the last match to the\n     * result variable.\n     */\n    Jsi_DSAppend(&dStr, p, NULL);\n    Jsi_ValueFromDS(interp, &dStr, ret);\n    return rc;\n\n}\n\nstatic Jsi_RC StringSearchCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n\n    int sLen, bLen;\n    const char *source_str;\n    ChkString(_this, funcPtr, source_str, &sLen, &bLen);\n    \n    char *v = _this->d.obj->d.s.str;\n    Jsi_Value *seq = Jsi_ValueArrayIndex(interp, args, skip);\n\n    if (Jsi_ValueIsString(interp, seq)) {\n        char *ce, *cp = Jsi_ValueString(interp, seq, NULL);\n        int n = -1;\n        if ((ce = Jsi_Strstr(source_str, cp))) {\n            n = (ce-source_str);\n        }\n        Jsi_ValueMakeNumber(interp, ret, n);\n        return JSI_OK;\n    }\n    if (!seq || seq->vt != JSI_VT_OBJECT || seq->d.obj->ot != JSI_OT_REGEXP) {\n        Jsi_ValueMakeNumber(interp, ret, -1);\n        return JSI_OK;\n    }\n\n    regex_t *reg = &seq->d.obj->d.robj->reg;\n    \n    regmatch_t pos[MAX_SUBREGEX] = {};\n    int r;\n    if ((r = regexec(reg, v, MAX_SUBREGEX, pos, 0)) != 0) {\n        if (r == REG_NOMATCH) {\n            Jsi_ValueMakeNumber(interp, ret, -1.0);\n            return JSI_OK;\n        }\n        if (r >= REG_BADPAT) {\n            char buf[JSI_MAX_NUMBER_STRING];\n\n            regerror(r, reg, buf, sizeof(buf));\n            Jsi_LogError(\"error while matching pattern: %s\", buf);\n            return JSI_ERROR;\n        }\n\n    }\n    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)pos[0].rm_so);\n    return JSI_OK;\n}\n\n/* UNIMPL: 'toLocaleLowerCase', 'toLocaleUpperCase', 'localeCompare', */\n\nstatic Jsi_CmdSpec stringCmds[] = {\n    { \"String\",     StringConstructor,      0,  1,  \"str\", .help=\"String constructor\", .retType=(uint)JSI_TT_STRING, .flags=JSI_CMD_IS_CONSTRUCTOR },\n/*    { \"localeCompare\",StringLocaleCompareCmd,1, 1, \"pos\" },*/\n    { \"charAt\",     StringCharAtCmd,        1, 1, \"index:number\", .help=\"Return char at index\", .retType=(uint)JSI_TT_STRING},\n    { \"charCodeAt\", StringCharCodeAtCmd,    1, 1, \"index:number\", .help=\"Return char code at index\", .retType=(uint)JSI_TT_NUMBER },\n    { \"concat\",     StringConcatCmd,        0,-1, \"str:string, ...\", .help=\"Append one or more strings\", .retType=(uint)JSI_TT_STRING },\n    { \"fromCharCode\",StringFromCharCodeCmd, 0, -1, \"...\", .help=\"Return string for char codes\", .retType=(uint)JSI_TT_STRING },\n    { \"indexOf\",    StringIndexOfCmd,       1, 2, \"str:string, start:number\", .help=\"Return index of char\", .retType=(uint)JSI_TT_NUMBER },\n    { \"lastIndexOf\",StringLastIndexOfCmd,   1, 2, \"str:string, start:number\", .help=\"Return index of last char\", .retType=(uint)JSI_TT_NUMBER },\n    { \"match\",      StringMatchCmd,         1, 1, \"pattern:regexp|string\", .help=\"Return array of matches\", .retType=(uint)JSI_TT_ARRAY|JSI_TT_NULL },\n    { \"map\",        StringMapCmd,           1, 2, \"strMap:array, nocase:boolean=false\", .help=\"Replaces characters in string based on the key-value pairs in strMap\", .retType=(uint)JSI_TT_STRING },\n    { \"repeat\",     StringRepeatCmd,        1, 1, \"count:number\", .help=\"Return count copies of string\", .retType=(uint)JSI_TT_STRING, .flags=0, .info=0 },\n    { \"replace\",    StringReplaceCmd,       2, 2, \"pattern:regexp|string, replace:string|function\", .help=\"Regex/string replacement\", .retType=(uint)JSI_TT_STRING, .flags=0, .info=FN_strreplace },\n    { \"search\",     StringSearchCmd,        1, 1, \"pattern:regexp|string\", .help=\"Return index of first char matching pattern\", .retType=(uint)JSI_TT_NUMBER },\n    { \"slice\",      StringSliceCmd,         1, 2, \"start:number, end:number\", .help=\"Return section of string\", .retType=(uint)JSI_TT_STRING },\n    { \"split\",      StringSplitCmd,         0, 1, \"char:string|null=void\", .help=\"Split on char and return Array. When char is omitted splits on bytes.  When char==null splits on whitespace and removes empty elements\", .retType=(uint)JSI_TT_ARRAY },\n    { \"substr\",     StringSubstrCmd,        0, 2, \"start:number, length:number\", .help=\"Return substring\", .retType=(uint)JSI_TT_STRING },\n    { \"substring\",  StringSubstringCmd,     0, 2, \"start:number, end:number\", .help=\"Return substring\", .retType=(uint)JSI_TT_STRING },\n    { \"toLocaleLowerCase\",StringToLowerCaseCmd,0, 0, \"\",.help=\"Lower case\", .retType=(uint)JSI_TT_STRING },\n    { \"toLocaleUpperCase\",StringToUpperCaseCmd,0, 0, \"\",.help=\"Upper case\", .retType=(uint)JSI_TT_STRING },\n    { \"toLowerCase\",StringToLowerCaseCmd,   0, 0, \"\",.help=\"Return lower cased string\", .retType=(uint)JSI_TT_STRING },\n    { \"toUpperCase\",StringToUpperCaseCmd,   0, 0, \"\",.help=\"Return upper cased string\", .retType=(uint)JSI_TT_STRING },\n    { \"toTitle\",    StringToTitleCmd,       0, 1, \"chars:string\",.help=\"Make first char upper case\", .retType=(uint)JSI_TT_STRING },\n    { \"trim\",       StringTrimCmd,          0, 1, \"chars:string\",.help=\"Trim chars\", .retType=(uint)JSI_TT_STRING },\n    { \"trimLeft\",   StringTrimLeftCmd,      0, 1, \"chars:string\",.help=\"Trim chars from left\", .retType=(uint)JSI_TT_STRING },\n    { \"trimRight\",  StringTrimRightCmd,     0, 1, \"chars:string\",.help=\"Trim chars from right\", .retType=(uint)JSI_TT_STRING },\n    { NULL, 0,0,0,0, .help=\"Commands for accessing string objects.\" }\n};\n\nJsi_RC jsi_InitString(Jsi_Interp *interp, int release)\n{\n    if (!release)\n        interp->String_prototype = Jsi_CommandCreateSpecs(interp, \"String\", stringCmds, NULL, JSI_CMDSPEC_ISOBJ);\n    return JSI_OK;\n}\n\n#endif\n", "/* An implementation of Red-Black Trees with invariant node pointers. \n * Nodes are allocated using single malloc that includes the key. \n * This means that string/struct keys (which are of varying length) can not be copied between nodes.\n * So instead of swapping node key/values, positions are swapped when balancing the tree. */\n\n#ifndef JSI_AMALGAMATION\n#include \"jsiInt.h\"\n#endif\n\nenum {_JSI_TREE_RED=0, _JSI_TREE_BLACK=1};\n\n/********************** _JSI_TREE_RED/_JSI_TREE_BLACK HELPERS **************************/\n\nstatic Jsi_TreeEntry* grandparent(Jsi_TreeEntry* n) {\n    Assert (n != NULL);\n    Assert (n->parent != NULL);\n    Assert (n->parent->parent != NULL);\n    return n->parent->parent;\n}\n\nstatic Jsi_TreeEntry* sibling(Jsi_TreeEntry* n) {\n    Assert (n != NULL);\n    Assert (n->parent != NULL);\n    return (n == n->parent->left ? n->parent->right : n->parent->left);\n}\n\nstatic Jsi_TreeEntry* uncle(Jsi_TreeEntry* n) {\n    Assert (n != NULL);\n    Assert (n->parent != NULL);\n    Assert (n->parent->parent != NULL);\n    return sibling(n->parent);\n}\n\nstatic int node_color(Jsi_TreeEntry* n) {\n    return n == NULL ? _JSI_TREE_BLACK : n->f.bits.color;\n}\n\nstatic void set_color(Jsi_TreeEntry* n, int color) {\n    if (color == _JSI_TREE_BLACK && n == NULL) return;\n    n->f.bits.color = color;\n}\n\nstatic void replace_node(Jsi_TreeEntry* oldn, Jsi_TreeEntry* newn) {\n    Assert(oldn);\n    Jsi_Tree* t = oldn->treePtr;\n    if (oldn->parent == NULL) {\n        t->root = newn;\n    } else {\n        if (oldn == oldn->parent->left)\n            oldn->parent->left = newn;\n        else\n            oldn->parent->right = newn;\n    }\n    if (newn != NULL) {\n        newn->parent = oldn->parent;\n    }\n}\n\nstatic void rotate_left(Jsi_TreeEntry* n) {\n    Jsi_TreeEntry* r;\n    Assert(n);\n    r = n->right;\n    replace_node(n, r);\n    n->right = r->left;\n    if (r->left != NULL) {\n        r->left->parent = n;\n    }\n    r->left = n;\n    n->parent = r;\n}\n\nstatic void rotate_right(Jsi_TreeEntry* n) {\n    Jsi_TreeEntry* l;\n    Assert(n);\n    l = n->left;\n    replace_node(n, l);\n    n->left = l->right;\n    if (l->right != NULL) {\n        l->right->parent = n;\n    }\n    l->right = n;\n    n->parent = l;\n}\n\nstatic void insert_case5(Jsi_TreeEntry* n) {\n    Jsi_TreeEntry* g = grandparent(n);\n    set_color(n->parent, _JSI_TREE_BLACK);\n    set_color(g, _JSI_TREE_RED);\n    if (n == n->parent->left) {\n        rotate_right(g);\n    } else {\n        Assert (n == n->parent->right);\n        rotate_left(g);\n    }\n}\n\nstatic void insert_case4(Jsi_TreeEntry* n) {\n    Jsi_TreeEntry* g = grandparent(n);\n    if (n == n->parent->right && n->parent == g->left) {\n        rotate_left(n->parent);\n        n = n->left;\n    } else if (n == n->parent->left && n->parent == g->right) {\n        rotate_right(n->parent);\n        n = n->right;\n    }\n    insert_case5(n);\n}\n\nstatic void insert_case1(Jsi_TreeEntry* n);\n\nstatic void insert_case3(Jsi_TreeEntry* n) {\n    Jsi_TreeEntry *g, *u = uncle(n);\n    if (node_color(u) == _JSI_TREE_RED) {\n        set_color(n->parent, _JSI_TREE_BLACK);\n        set_color(u, _JSI_TREE_BLACK);\n        g = grandparent(n);\n        set_color(g, _JSI_TREE_RED);\n        insert_case1(g);\n    } else {\n        insert_case4(n);\n    }\n}\n\nstatic void insert_case2(Jsi_TreeEntry* n) {\n    if (node_color(n->parent) == _JSI_TREE_BLACK)\n        return;\n    insert_case3(n);\n}\n\nstatic void insert_case1(Jsi_TreeEntry* n) {\n    if (n->parent == NULL)\n        set_color(n, _JSI_TREE_BLACK);\n    else\n        insert_case2(n);\n}\n\nstatic Jsi_TreeEntry* maximum_node(Jsi_TreeEntry* n) {\n    Assert (n != NULL);\n    while (n->right != NULL) {\n        n = n->right;\n    }\n    return n;\n}\n\nstatic void delete_case6(Jsi_TreeEntry* n) {\n    Jsi_TreeEntry* s = sibling(n);\n    set_color(s, node_color(n->parent));\n    set_color(n->parent, _JSI_TREE_BLACK);\n    if (n == n->parent->left) {\n        Assert (node_color(s->right) == _JSI_TREE_RED);\n        set_color(s->right, _JSI_TREE_BLACK);\n        rotate_left(n->parent);\n    }\n    else\n    {\n        //Assert (node_color(s->left) == _JSI_TREE_RED);\n        set_color(s->left, _JSI_TREE_BLACK);\n        rotate_right(n->parent);\n    }\n}\n\nstatic void delete_case5(Jsi_TreeEntry* n) {\n    Jsi_TreeEntry* s = sibling(n);\n    if (node_color(s) == _JSI_TREE_BLACK ) {\n        if (n == n->parent->left &&\n                node_color(s->right) == _JSI_TREE_BLACK &&\n                node_color(s->left) == _JSI_TREE_RED)\n        {\n            set_color(s, _JSI_TREE_RED);\n            set_color(s->left, _JSI_TREE_BLACK);\n            rotate_right(s);\n        }\n        else if (n == n->parent->right &&\n                 node_color(s->right) == _JSI_TREE_RED &&\n                 node_color(s->left) == _JSI_TREE_BLACK)\n        {\n            set_color(s, _JSI_TREE_RED);\n            set_color(s->right, _JSI_TREE_BLACK);\n            rotate_left(s);\n        }\n    }\n    delete_case6(n);\n}\n\nstatic void delete_case4(Jsi_TreeEntry* n) {\n    Jsi_TreeEntry* s = sibling(n);\n    if (node_color(n->parent) == _JSI_TREE_RED &&\n            node_color(s) == _JSI_TREE_BLACK &&\n            node_color(s->left) == _JSI_TREE_BLACK &&\n            node_color(s->right) == _JSI_TREE_BLACK)\n    {\n        set_color(s, _JSI_TREE_RED);\n        set_color(n->parent, _JSI_TREE_BLACK);\n    }\n    else\n        delete_case5(n);\n}\n\nstatic void delete_case1(Jsi_TreeEntry* n);\n\nstatic void delete_case3(Jsi_TreeEntry* n) {\n    Jsi_TreeEntry* s  = sibling(n);\n    if (node_color(n->parent) == _JSI_TREE_BLACK &&\n        node_color(s) == _JSI_TREE_BLACK &&\n        node_color(s->left) == _JSI_TREE_BLACK &&\n        node_color(s->right) == _JSI_TREE_BLACK)\n    {\n        set_color(s, _JSI_TREE_RED);\n        delete_case1(n->parent);\n    } else\n        delete_case4(n);\n}\n\nstatic void delete_case2(Jsi_TreeEntry* n) {\n    Jsi_TreeEntry* s = sibling(n);\n    if (node_color(s) == _JSI_TREE_RED) {\n        set_color(n->parent, _JSI_TREE_RED);\n        set_color(s, _JSI_TREE_BLACK);\n        if (n == n->parent->left)\n            rotate_left(n->parent);\n        else\n            rotate_right(n->parent);\n    }\n    delete_case3(n);\n}\n\nstatic void delete_case1(Jsi_TreeEntry* n) {\n    if (n->parent != NULL)\n        delete_case2(n);\n}\n\n/***********************************************************/\n\nint jsi_treeHeight(Jsi_TreeEntry* hPtr, int n)\n{\n    int l = -1, r = -1;\n    if (hPtr->right == NULL && hPtr->right == NULL )\n        return n;\n    if (hPtr->left)\n        l = jsi_treeHeight(hPtr->left, n+1);\n    if (hPtr->right)\n        r = jsi_treeHeight(hPtr->right, n+1);\n    return (r > l ? r : l);\n}\n\nint jsi_nodeDepth(Jsi_TreeEntry* hPtr) {\n    int d = 0;\n    while (hPtr->parent != NULL) {\n        d++;\n        hPtr = hPtr->parent;\n    }\n    return d;\n}\n\n\nstatic int StringPtrCompare(Jsi_Tree *treePtr, const void *key1, const void *key2)\n{\n    //return (key1 - key2);\n    if (key1 == key2) return 0;\n    //return Jsi_DictionaryCompare((char*)key1, (char*)key2);\n    return Jsi_Strcmp((char*)key1, (char*)key2);\n}\n\n\nstatic int StringCompare(Jsi_Tree *treePtr, const void *key1, const void *key2)\n{\n    return Jsi_DictionaryCompare((char*)key1, (char*)key2);\n    //return Jsi_Strcmp((char*)key1, (char*)key2);\n}\n\nstatic int OneWordCompare(Jsi_Tree *treePtr, const void *key1, const void *key2)\n{\n    return ((uintptr_t )key1 - (uintptr_t)key2);\n}\n\nstatic int TreeArrayCompare(Jsi_Tree *treePtr, const void *key1, const void *key2)\n{\n    return memcmp(key1, key2, treePtr->keyType);\n}\n\n\nstatic Jsi_TreeEntry *TreeStringCreate( Jsi_Tree *treePtr, const void *key, bool *newPtr)\n{\n    Jsi_TreeEntry *hPtr;\n    size_t size;\n\n    if ((hPtr = Jsi_TreeEntryFind(treePtr, key))) {\n        if (newPtr)\n            *newPtr = 0;\n        return hPtr;\n    }\n    if (newPtr)\n        *newPtr = 1;\n    size = sizeof(Jsi_TreeEntry) + Jsi_Strlen((char*)key) /*- sizeof(jsi_TreeKey)*/ + 1;\n    hPtr = (Jsi_TreeEntry*)Jsi_Calloc(1,size);\n    SIGINIT(hPtr,TREEENTRY);\n    hPtr->typ = JSI_MAP_TREE;\n    hPtr->treePtr = treePtr;\n    hPtr->value = 0;\n    Jsi_Strcpy(hPtr->key.string, (char*)key);\n    treePtr->numEntries++;\n    return hPtr;\n}\n\nstatic Jsi_TreeEntry *TreeArrayCreate(Jsi_Tree *treePtr, const void *key, bool *newPtr)\n{\n    Jsi_TreeEntry *hPtr;\n    size_t size;\n\n    if ((hPtr = Jsi_TreeEntryFind(treePtr, key))) {\n        if (newPtr)\n            *newPtr = 0;\n        return hPtr;\n    }\n    if (newPtr)\n        *newPtr = 1;\n    size = sizeof(Jsi_TreeEntry) + treePtr->keyType; /*- sizeof(jsi_TreeKey);*/\n    hPtr = (Jsi_TreeEntry*)Jsi_Calloc(1,size);\n    SIGINIT(hPtr,TREEENTRY);\n    hPtr->typ = JSI_MAP_TREE;\n    hPtr->treePtr = treePtr;\n    hPtr->value = 0;\n    memcpy(hPtr->key.string, key, treePtr->keyType);\n    treePtr->numEntries++;\n    return hPtr;\n}\n\nstatic Jsi_TreeEntry *OneWordCreate( Jsi_Tree *treePtr, const void *key, bool *newPtr)\n{\n    Jsi_TreeEntry *hPtr;\n    size_t size;\n    if ((hPtr = Jsi_TreeEntryFind(treePtr, key))) {\n        if (newPtr)\n            *newPtr = 0;\n        return hPtr;\n    }\n    if (newPtr)\n        *newPtr = 1;\n    size = sizeof(Jsi_TreeEntry);\n    hPtr = (Jsi_TreeEntry*)Jsi_Calloc(1,size);\n    SIGINIT(hPtr,TREEENTRY);\n    hPtr->typ = JSI_MAP_TREE;\n    hPtr->treePtr = treePtr;\n    hPtr->value = 0;\n    hPtr->key.oneWordValue = (void *)key;\n    treePtr->numEntries++;\n    return hPtr;\n}\n\n\nstatic Jsi_TreeEntry *StringPtrCreate( Jsi_Tree *treePtr, const void *key, bool *newPtr)\n{\n    return OneWordCreate(treePtr, key, newPtr);\n}\n\nvoid *Jsi_TreeValueGet(Jsi_TreeEntry *hPtr)\n{\n    return hPtr->value;\n}\n\nvoid *Jsi_TreeKeyGet(Jsi_TreeEntry *hPtr)\n{\n    Jsi_Tree *t = hPtr->treePtr;\n    return (t->keyType == JSI_KEYS_ONEWORD || t->keyType == JSI_KEYS_STRINGKEY ? hPtr->key.oneWordValue : hPtr->key.string);\n}\n\n\nJsi_TreeEntry *Jsi_TreeEntryFind (Jsi_Tree *treePtr, const void *key)\n{\n    Jsi_TreeEntry* hPtr = treePtr->root;\n    int rc;\n    if (treePtr->flags.destroyed)\n        return NULL;\n    if (treePtr->opts.lockTreeProc && (*treePtr->opts.lockTreeProc)(treePtr, 1) != JSI_OK)\n        return NULL;\n    while (hPtr != NULL) {\n        rc = treePtr->opts.compareTreeProc(treePtr, Jsi_TreeKeyGet(hPtr), key);\n        if (rc == 0) {\n            break;\n        }\n        hPtr = (rc < 0 ? hPtr->left : hPtr->right);\n    }\n    if (treePtr->opts.lockTreeProc)\n        (*treePtr->opts.lockTreeProc)(treePtr, 0);\n    return hPtr;\n}\n\nJsi_TreeEntry *Jsi_TreeEntryNew(Jsi_Tree *treePtr, const void *key, bool *isNew)\n{\n    Jsi_TreeEntry* hPtr;\n    bool isn;\n    if (treePtr->flags.destroyed)\n        return NULL;\n    if (treePtr->opts.lockTreeProc && (*treePtr->opts.lockTreeProc)(treePtr, 1) != JSI_OK)\n        return NULL;\n    treePtr->flags.inserting=1;\n    if (treePtr->flags.internstr) {\n        Assert(treePtr->keyType == JSI_KEYS_STRINGKEY);\n        if (!treePtr->strHash)\n            treePtr->strHash = Jsi_HashNew(treePtr->opts.interp, JSI_KEYS_STRING, NULL);\n        key = Jsi_HashEntryNew(treePtr->strHash, key, NULL);\n    }\n    hPtr = treePtr->createProc(treePtr, key, &isn);\n    if (isNew)\n        *isNew = isn;\n    if (isn == 0 || treePtr->flags.nonredblack == 1 || !hPtr) {\n        treePtr->flags.inserting=0;\n        goto done;\n    }\n    treePtr->epoch++;\n    hPtr->f.bits.color = _JSI_TREE_RED;\n    if (treePtr->root == NULL) {\n        treePtr->root = hPtr;\n    } else {\n        Jsi_TreeEntry* n = treePtr->root;\n        while (1) {\n            int rc = treePtr->opts.compareTreeProc(treePtr, Jsi_TreeKeyGet(n) , key);\n            if (rc == 0) {\n                Assert(0);\n            } else if (rc < 0) {\n                if (n->left == NULL) {\n                    n->left = hPtr;\n                    break;\n                } else {\n                    n = n->left;\n                }\n            } else {\n                if (n->right == NULL) {\n                    n->right = hPtr;\n                    break;\n                } else {\n                    n = n->right;\n                }\n            }\n        }\n        hPtr->parent = n;\n    }\n    insert_case1(hPtr);\n    treePtr->flags.inserting = 0;\ndone:\n    if (treePtr->opts.lockTreeProc)\n        (*treePtr->opts.lockTreeProc)(treePtr, 0);\n    return hPtr;\n}\n\nJsi_Tree *Jsi_TreeNew(Jsi_Interp *interp, unsigned int keyType, Jsi_TreeDeleteProc *freeProc)\n{\n    Jsi_Tree* treePtr = (Jsi_Tree*)Jsi_Calloc(1,sizeof(Jsi_Tree));\n    SIGINIT(treePtr,TREE);\n    treePtr->opts.mapType = (Jsi_Map_Type)JSI_MAP_TREE;\n    treePtr->typ = (Jsi_Map_Type)JSI_MAP_TREE;\n    treePtr->root = NULL;\n    treePtr->opts.interp = interp;\n    treePtr->numEntries = 0;\n    treePtr->epoch = 0;\n    treePtr->opts.keyType = (Jsi_Key_Type)keyType;\n    treePtr->keyType = (Jsi_Key_Type)keyType;\n    treePtr->opts.freeTreeProc = freeProc;\n\n    switch (keyType) {\n    case JSI_KEYS_STRING:   /* NULL terminated string keys. */\n        treePtr->opts.compareTreeProc = StringCompare;\n        treePtr->createProc = TreeStringCreate;\n        break;\n\n    case JSI_KEYS_STRINGKEY: /*  */\n        treePtr->opts.compareTreeProc = StringPtrCompare;\n        treePtr->createProc = StringPtrCreate;\n        break;\n        \n    case JSI_KEYS_ONEWORD: /* 32 or 64 bit atomic keys. */\n        treePtr->opts.compareTreeProc = OneWordCompare;\n        treePtr->createProc = OneWordCreate;\n        break;\n\n\n    default:            /* Struct. */\n        if (keyType < JSI_KEYS_STRUCT_MINSIZE) {\n            Jsi_LogError(\"Jsi_TreeNew: Key size can't be %d, must be > %d\", keyType, JSI_KEYS_STRUCT_MINSIZE);\n            Jsi_Free(treePtr);\n            return NULL;\n        }\n        treePtr->opts.compareTreeProc = TreeArrayCompare;\n        treePtr->createProc = TreeArrayCreate;\n        break;\n    }\n    return treePtr;\n}\n\nstatic void destroy_node(Jsi_Interp *interp, Jsi_TreeEntry* n)\n{\n    if (n == NULL) return;\n    if (n->right != NULL) destroy_node(interp, n->right);\n    if (n->left != NULL) destroy_node(interp, n->left);\n    n->left = n->right = NULL;\n    Jsi_TreeEntryDelete(n);\n}\n\nvoid Jsi_TreeClear (Jsi_Tree *treePtr)\n{\n    SIGASSERTV(treePtr, TREE);\n    if (treePtr->opts.lockTreeProc && (*treePtr->opts.lockTreeProc)(treePtr, 1) != JSI_OK)\n        return;\n    destroy_node(treePtr->opts.interp, treePtr->root);\n    treePtr->root = NULL;\n    if (treePtr->opts.lockTreeProc)\n        (*treePtr->opts.lockTreeProc)(treePtr, 0);\n}\n\nvoid Jsi_TreeDelete (Jsi_Tree *treePtr)\n{\n    SIGASSERTV(treePtr, TREE);\n    if (treePtr->flags.destroyed)\n        return;\n    //Jsi_TreeClear(treePtr);\n    treePtr->flags.destroyed = 1;\n    destroy_node(treePtr->opts.interp, treePtr->root);\n    _JSI_MEMCLEAR(treePtr);\n    Jsi_Free(treePtr);\n}\n\n/* Swap positions of nodes in tree.  This avoids moving the value, which we can't do for strings/structs. */\nstatic void SwapNodes(Jsi_TreeEntry* n, Jsi_TreeEntry* m)\n{\n    Jsi_Tree* t = n->treePtr;\n    Jsi_TreeEntry *np, *nl, *nr, *mp, *ml, *mr;\n    int mpc = 0, npc = 0, col = n->f.bits.color;\n    n->f.bits.color = m->f.bits.color;  m->f.bits.color = col;\n    np = n->parent; nl = n->left; nr = n->right;\n    mp = m->parent; ml = m->left; mr = m->right;\n    if (mp) mpc = (mp->left == m ?1 : 2);\n    if (np) npc = (np->left == n ?1 : 2);\n\n    n->parent = mp; n->left = ml; n->right = mr;\n    m->parent = np; m->left = nl; m->right = nr;\n    \n    if (np == m) {\n        m->parent = n;\n        if (mr == n) n->right = m; else n->left = m;\n    } else if (mp == n) {\n        n->parent = m;\n        if (nr == m) m->right = n; else m->left = n;\n    }\n    /* Fixup back pointers. */\n    if (m->left)  m->left->parent  = m;\n    if (m->right) m->right->parent = m;\n    if (n->left)  n->left->parent  = n;\n    if (n->right) n->right->parent = n;\n    if (mpc) { if (mpc==1) n->parent->left = n; else  n->parent->right = n;}\n    if (npc) { if (npc==1) m->parent->left = m; else  m->parent->right = m; }\n    if (n->parent == NULL) {\n        t->root = n;\n    } else if (m->parent == NULL) {\n        t->root = m;\n    }\n}\n\nstatic void delete_one_child(Jsi_TreeEntry*n)\n{\n    Jsi_TreeEntry *child;\n    Assert(n->left == NULL || n->right == NULL);\n    child = n->right == NULL ? n->left  : n->right;\n#if 1\n    if (node_color(n) == _JSI_TREE_BLACK) {\n        set_color(n, node_color(child));\n        delete_case1(n);\n    }\n    replace_node(n, child);\n    if (n->parent == NULL && child != NULL)\n        set_color(child, _JSI_TREE_BLACK);\n    \n#else\n    replace_node(n, child);\n    if (node_color(n) == _JSI_TREE_BLACK) {\n        if (node_color(child) == _JSI_TREE_RED)\n            child->f.bits.color = _JSI_TREE_BLACK;\n        else\n            delete_case1(n);\n    }\n#endif\n}\n\nint Jsi_TreeEntryDelete (Jsi_TreeEntry *entryPtr)\n{\n    int cnt = 0;\n    Jsi_TreeEntry* n = entryPtr;\n    Jsi_Tree* treePtr = n->treePtr;\n\n    if (treePtr->flags.destroyed  || treePtr->flags.nonredblack == 1 /* || entryPtr->f.bits.deletesub */) {\n        goto dodel;\n    }\n    /*printf(\"DEL(tree=%p,root=%p): (%p)%s\\n\", treePtr, treePtr->root, entryPtr,(char*)entryPtr->key.string);*/\n    /*dumpTree(treePtr);*/\n    if (treePtr->opts.lockTreeProc && (*treePtr->opts.lockTreeProc)(treePtr, 1) != JSI_OK)\n        return -1;\n    entryPtr->treePtr->epoch++;\n    if (n->left != NULL && n->right != NULL) {\n        /* swap key/values delete pred instead */\n        Jsi_TreeEntry* pred = maximum_node(n->left);\n        switch (treePtr->keyType) {\n        case JSI_KEYS_STRINGKEY:\n        case JSI_KEYS_ONEWORD: {\n            void *nv = n->value;\n            n->value = pred->value;\n            pred->value = nv;\n            nv = n->key.oneWordValue;\n            n->key.oneWordValue = pred->key.oneWordValue;\n            pred->key.oneWordValue = nv;\n            n = pred;\n            break;\n        }\n        case JSI_KEYS_STRING:\n            SwapNodes(n,pred);\n            break;\n        default: { // Struct keys have the same length so we swap bytes.\n            uint i;\n            void *nv = n->value;\n            n->value = pred->value;\n            pred->value = nv;\n            char ct, *cs = (char*)(n->key.string), *cd = (char*)(pred->key.string);\n            for (i=0; i<treePtr->keyType; i++, cs++, cd++) {\n                ct = *cd;\n                *cd = *cs;\n                *cs = ct;\n            }\n        }\n                \n        }\n    }\n    delete_one_child(n);\n    cnt++;\n    /*dumpTree(treePtr);*/\ndodel:\n    treePtr->numEntries--;\n    n->treePtr = NULL;\n    if (treePtr->opts.freeTreeProc && n && n->value)\n        (treePtr->opts.freeTreeProc)(treePtr->opts.interp, n, n->value);\n    Jsi_Free(n);\n    if (treePtr->opts.lockTreeProc)\n        (*treePtr->opts.lockTreeProc)(treePtr, 0);\n    return cnt;\n}\n\nstatic void searchSpace(Jsi_TreeSearch *searchPtr, int n)\n{\n    if ((searchPtr->top+n) >= searchPtr->max) {\n        int i, cnt = (searchPtr->max *= 2);\n        if (searchPtr->Ptrs == searchPtr->staticPtrs)\n            searchPtr->Ptrs = (Jsi_TreeEntry**)Jsi_Calloc(cnt, sizeof(Jsi_TreeEntry*));\n        else\n            searchPtr->Ptrs = (Jsi_TreeEntry**)Jsi_Realloc(searchPtr->Ptrs, cnt* sizeof(Jsi_TreeEntry*));\n        for (i=0; i<cnt; i++)\n            SIGINIT((searchPtr->Ptrs[i]),TREEENTRY);\n\n    }\n}\n\nstatic Jsi_TreeEntry *searchAdd(Jsi_TreeSearch *searchPtr,  Jsi_TreeEntry *hPtr)\n{\n    int order = (searchPtr->flags & JSI_TREE_ORDER_MASK);\n    searchSpace(searchPtr, 2);\n    switch (order) {\n        case JSI_TREE_ORDER_LEVEL:\n            if (hPtr) {\n                if (hPtr->right)\n                    searchPtr->Ptrs[searchPtr->top++] = hPtr->right;\n                if (hPtr->left)\n                    searchPtr->Ptrs[searchPtr->top++] = hPtr->left;\n                return hPtr;\n            }\n            if (searchPtr->top<=0)\n                return NULL;\n            hPtr = searchPtr->Ptrs[0];\n            searchPtr->top--;\n            if (searchPtr->top > 0) {\n                /* Not very efficient way to implement a queue, but works for now. */\n                memmove(searchPtr->Ptrs, searchPtr->Ptrs+1, sizeof(Jsi_TreeEntry*)*searchPtr->top);\n            }\n            if (hPtr->right)\n                searchPtr->Ptrs[searchPtr->top++] = hPtr->right;\n            if (hPtr->left)\n                searchPtr->Ptrs[searchPtr->top++] = hPtr->left;\n            return hPtr;\n            break;\n            \n        case JSI_TREE_ORDER_POST:\n            if (hPtr)\n                searchPtr->Ptrs[searchPtr->top++] = searchPtr->current = hPtr;\n            while (searchPtr->top>0) {\n                hPtr = searchPtr->Ptrs[searchPtr->top-1];\n                if (hPtr->right == searchPtr->current || hPtr->left == searchPtr->current ||\n                    (hPtr->left == NULL && hPtr->right == NULL)) {\n                    searchPtr->top--;\n                    searchPtr->current = hPtr;\n                    return hPtr;\n                } else {\n                    searchSpace(searchPtr, 2);\n                    if (hPtr->left)\n                        searchPtr->Ptrs[searchPtr->top++] = hPtr->left;\n                    if (hPtr->right)\n                        searchPtr->Ptrs[searchPtr->top++] = hPtr->right;\n                }\n            }\n            return NULL;\n            break;\n            \n        case JSI_TREE_ORDER_PRE:\n            if (!hPtr) {\n                if (searchPtr->top<=0) return NULL;\n                hPtr = searchPtr->Ptrs[--searchPtr->top];\n            }\n            searchPtr->Ptrs[searchPtr->top++] = hPtr;\n            if (hPtr->left) searchPtr->Ptrs[searchPtr->top++] = hPtr->left;\n            if (hPtr->right) searchPtr->Ptrs[searchPtr->top++] = hPtr->right;\n            break;\n            \n        case JSI_TREE_ORDER_IN:\n            while (1) {\n                searchSpace(searchPtr, 2);\n                if (searchPtr->current) {\n                    searchPtr->Ptrs[searchPtr->top++] = searchPtr->current;\n                    searchPtr->current = searchPtr->current->right;\n                } else {\n                    if (searchPtr->top<=0)\n                        return NULL;\n                    hPtr = searchPtr->Ptrs[--searchPtr->top] ;\n                    searchPtr->current = hPtr->left;\n                    return hPtr;\n                }\n            }\n            break;\n            \n        default:\n            if (hPtr) {\n                Jsi_Interp *interp = hPtr->treePtr->opts.interp;\n                JSI_NOTUSED(interp);\n                Jsi_LogError(\"Invalid order: %d\", order);    \n            }    \n    }\n    return searchPtr->Ptrs[--searchPtr->top];\n}\n\nJsi_TreeEntry *Jsi_TreeSearchFirst (Jsi_Tree *treePtr, Jsi_TreeSearch *searchPtr, int flags, const void *startKey)\n{\n    Jsi_TreeEntry *hPtr = NULL, *hPtr2 = NULL;\n    if (!treePtr) return NULL;\n    memset(searchPtr, 0, sizeof(*searchPtr));\n    searchPtr->treePtr = treePtr;\n    searchPtr->flags = flags;\n    searchPtr->Ptrs = searchPtr->staticPtrs;\n    searchPtr->max = sizeof(searchPtr->staticPtrs)/sizeof(searchPtr->staticPtrs[0]);\n    searchPtr->epoch = treePtr->epoch;\n    if (startKey || (flags & JSI_TREE_SEARCH_KEY))\n        hPtr2 = Jsi_TreeEntryFind(treePtr, startKey);;\n    searchPtr->current = treePtr->root;\n    hPtr = searchAdd(searchPtr, treePtr->root);\n    if (hPtr2 && hPtr && hPtr2 != hPtr)\n        while (hPtr && hPtr2 != hPtr) // TODO: need a more efficient way to do this...\n            hPtr = Jsi_TreeSearchNext(searchPtr);\n    return hPtr;\n}\n\nvoid Jsi_TreeValueSet(Jsi_TreeEntry *hPtr, void *value)\n{\n    Jsi_Value *v = (Jsi_Value*)value;\n#if JSI__MEMDEBUG\n    SIGASSERTV(hPtr, TREEENTRY);\n    if (hPtr->treePtr->flags.valuesonly)\n        SIGASSERTV(v,VALUE);\n#endif\n    hPtr->value = v;\n}\n\n#ifndef JSI_LITE_ONLY\n\nJsi_Tree *Jsi_TreeFromValue(Jsi_Interp *interp, Jsi_Value *v)\n{\n    if (!Jsi_ValueIsObjType(interp, v, JSI_OT_OBJECT))\n        return NULL;\n    return v->d.obj->tree;\n}\n\n#endif \n\nJsi_TreeEntry *Jsi_TreeSearchNext(Jsi_TreeSearch *searchPtr)\n{\n    Jsi_TreeEntry *hPtr = NULL;\n    if (searchPtr->epoch == searchPtr->treePtr->epoch)\n        hPtr = searchAdd(searchPtr, NULL);\n    if (!hPtr)\n        Jsi_TreeSearchDone(searchPtr);\n    return hPtr;\n}\n\nvoid Jsi_TreeSearchDone(Jsi_TreeSearch *searchPtr)\n{\n    if (searchPtr->Ptrs != searchPtr->staticPtrs)\n        Jsi_Free(searchPtr->Ptrs);\n    searchPtr->Ptrs = searchPtr->staticPtrs;\n    searchPtr->top = 0;\n}\n\nJsi_TreeEntry *Jsi_TreeSet(Jsi_Tree *treePtr, const void *key, void *value)\n{\n    Jsi_TreeEntry *hPtr;\n    bool isNew;\n    hPtr = Jsi_TreeEntryNew(treePtr, key, &isNew);\n    if (!hPtr) return hPtr;\n    Jsi_TreeValueSet(hPtr, value);\n    return hPtr;\n}\n\nvoid *Jsi_TreeGet(Jsi_Tree *treePtr, void *key, int flags)\n{\n    Jsi_TreeEntry *hPtr = Jsi_TreeEntryFind(treePtr, key);\n    if (!hPtr)\n        return NULL;\n    return Jsi_TreeValueGet(hPtr);\n}\n\n// Delete entry, and invoke freeProc.\nbool Jsi_TreeUnset(Jsi_Tree *treePtr, void *key) {\n    Jsi_TreeEntry *hPtr = Jsi_TreeEntryFind(treePtr, key);\n    if (!hPtr)\n        return false;\n    Jsi_TreeEntryDelete(hPtr);\n    return true;\n}\n\nstatic int tree_inorder(Jsi_Tree *treePtr, Jsi_TreeEntry *hPtr, Jsi_TreeWalkProc *callback, void *data) {\n    uint epoch = treePtr->epoch;\n    if (hPtr == NULL) return JSI_OK;\n    if (hPtr->right != NULL) {\n        if (tree_inorder(treePtr, hPtr->right, callback, data) != JSI_OK || epoch != treePtr->epoch)\n            return JSI_ERROR;\n    }\n    if (callback(treePtr, hPtr, data) != JSI_OK || epoch != treePtr->epoch)\n        return JSI_ERROR;\n    Assert(hPtr->treePtr);\n    if (hPtr->left != NULL) {\n        if (tree_inorder(treePtr, hPtr->left, callback, data) != JSI_OK || epoch != treePtr->epoch)\n            return JSI_ERROR;\n    }\n    return JSI_OK;\n}\n\n\nstatic int tree_preorder(Jsi_Tree *treePtr, Jsi_TreeEntry *hPtr, Jsi_TreeWalkProc *callback, void *data) {\n    uint epoch = treePtr->epoch;\n    if (hPtr == NULL) return JSI_OK;\n    if (callback(treePtr, hPtr, data) != JSI_OK || epoch != treePtr->epoch)\n        return JSI_ERROR;\n    if (hPtr->right != NULL) {\n        if (tree_preorder(treePtr, hPtr->right, callback, data) != JSI_OK || epoch != treePtr->epoch)\n            return JSI_ERROR;\n    }\n    if (hPtr->left != NULL) {\n        if (tree_preorder(treePtr, hPtr->left, callback, data) != JSI_OK || epoch != treePtr->epoch)\n            return JSI_ERROR;\n    }\n    return JSI_OK;\n}\n\n\nstatic int tree_postorder(Jsi_Tree *treePtr, Jsi_TreeEntry *hPtr, Jsi_TreeWalkProc *callback, void *data) {\n    uint epoch = treePtr->epoch;\n    if (hPtr == NULL) return JSI_OK;\n    if (hPtr->right != NULL) {\n        if (tree_postorder(treePtr, hPtr->right, callback, data) != JSI_OK || epoch != treePtr->epoch)\n            return JSI_ERROR;\n    }\n    if (hPtr->left != NULL) {\n        if (tree_postorder(treePtr, hPtr->left, callback, data) != JSI_OK || epoch != treePtr->epoch)\n            return JSI_ERROR;\n    }\n    if (callback(treePtr, hPtr, data) != JSI_OK || epoch != treePtr->epoch)\n        return JSI_ERROR;\n    return JSI_OK;\n}\n\n\nstatic int tree_levelorder(Jsi_Tree *treePtr, Jsi_TreeEntry *hPtr, Jsi_TreeWalkProc *callback,\n    void *data, int curlev, int level, int *cnt) {\n    uint epoch = treePtr->epoch;\n    if (hPtr == NULL) return JSI_OK;\n    if (curlev > level) return JSI_OK;\n    if (curlev == level) {\n        if (callback(treePtr, hPtr, data) != JSI_OK || epoch != treePtr->epoch)\n            return JSI_ERROR;\n        (*cnt)++;\n    }\n    if (hPtr->right != NULL) {\n        if (tree_levelorder(treePtr, hPtr->right, callback, data, curlev+1, level, cnt) != JSI_OK || epoch != treePtr->epoch)\n            return JSI_ERROR;\n    }\n    if (hPtr->left != NULL) {\n        if (tree_levelorder(treePtr, hPtr->left, callback, data, curlev+1, level, cnt) != JSI_OK || epoch != treePtr->epoch)\n            return JSI_ERROR;\n    }\n    return JSI_OK;\n}\n\n\nint Jsi_TreeWalk(Jsi_Tree* treePtr, Jsi_TreeWalkProc* callback, void *data, int flags) {\n    Jsi_Interp *interp = treePtr->opts.interp;\n    JSI_NOTUSED(interp);\n    int n = 0, m = -1, lastm, order;\n    order = flags & JSI_TREE_ORDER_MASK;\n    switch (order) {\n    case JSI_TREE_ORDER_PRE:\n        return tree_preorder(treePtr, treePtr->root, callback, data);\n    case JSI_TREE_ORDER_POST:\n        return tree_postorder(treePtr, treePtr->root, callback, data);\n    case JSI_TREE_ORDER_IN:\n        return tree_inorder(treePtr, treePtr->root, callback, data);\n    case JSI_TREE_ORDER_LEVEL:\n        while (1) {\n            lastm = m;\n            if (tree_levelorder(treePtr, treePtr->root, callback, data, 0, n, &m) != JSI_OK)\n                return JSI_ERROR;\n            if (lastm == m)\n                return JSI_OK;\n            n++;\n        }\n            \n    default:\n        Jsi_LogError(\"Invalid order: %d\", order);\n    }\n    return JSI_ERROR;\n}\n\n#ifdef JSI_TEST_RBTREE\n\nJSI_RC mycall(Jsi_Tree* treePtr, Jsi_TreeEntry* hPtr, void *data)\n{\n    printf(\"CALL: %s(%d) : %d\\n\", (char*)Jsi_TreeKeyGet(hPtr), jsi_nodeDepth(hPtr), (int)Jsi_TreeValueGet(hPtr));\n    return JSI_OK;\n}\n\nstatic void TreeTest(Jsi_Interp* interp) {\n    Jsi_Tree *st, *wt, *mt;\n    Jsi_TreeEntry *hPtr, *hPtr2;\n    bool isNew, i;\n    Jsi_TreeSearch srch;\n    struct tdata {\n        int n;\n        int m;\n    } t1, t2;\n    char nbuf[JSI_MAX_NUMBER_STRING];\n    \n    wt = Jsi_TreeNew(interp, JSI_KEYS_ONEWORD, NULL);\n    mt = Jsi_TreeNew(interp, sizeof(struct tdata), NULL);\n\n    Jsi_TreeSet(wt, wt,(void*)0x88);\n    Jsi_TreeSet(wt, mt,(void*)0x99);\n    printf(\"WT: %p\\n\", Jsi_TreeGet(wt, mt));\n    printf(\"WT2: %p\\n\", Jsi_TreeGet(wt, wt));\n    Jsi_TreeDelete(wt);\n\n    t1.n = 0; t1.m = 1;\n    t2.n = 1; t2.m = 2;\n    Jsi_TreeSet(mt, &t1,(void*)0x88);\n    Jsi_TreeSet(mt, &t2,(void*)0x99);\n    Jsi_TreeSet(mt, &t2,(void*)0x98);\n    printf(\"CT: %p\\n\", Jsi_TreeGet(mt, &t1));\n    printf(\"CT2: %p\\n\", Jsi_TreeGet(mt, &t2));\n    Jsi_TreeDelete(mt);\n\n    st = Jsi_TreeNew(interp, JSI_KEYS_STRING, NULL);\n    hPtr = Jsi_TreeEntryNew(st, \"bob\", &isNew);\n    Jsi_TreeValueSet(hPtr, (void*)99);\n    Jsi_TreeSet(st, \"zoe\",(void*)77);\n    hPtr2 = Jsi_TreeSet(st, \"ted\",(void*)55);\n    Jsi_TreeSet(st, \"philip\",(void*)66);\n    Jsi_TreeSet(st, \"alice\",(void*)77);\n    puts(\"SRCH\");\n    for (hPtr=Jsi_TreeSearchFirst(st,&srch,  JSI_TREE_ORDER_IN, NULL); hPtr; hPtr=Jsi_TreeSearchNext(&srch))\n        mycall(st, hPtr, NULL);\n    Jsi_TreeSearchDone(&srch);\n    puts(\"IN\");\n    Jsi_TreeWalk(st, mycall, NULL, JSI_TREE_ORDER_IN);\n    puts(\"PRE\");\n    Jsi_TreeWalk(st, mycall, NULL, JSI_TREE_ORDER_PRE);\n    puts(\"POST\");\n    Jsi_TreeWalk(st, mycall, NULL, JSI_TREE_ORDER_POST);\n    puts(\"LEVEL\");\n    Jsi_TreeWalk(st, mycall, NULL, JSI_TREE_ORDER_LEVEL);\n    Jsi_TreeEntryDelete(hPtr2);\n    puts(\"INDEL\");\n    Jsi_TreeWalk(st, mycall, NULL, 0);\n\n    for (i=0; i<1000; i++) {\n        snprintf(nbuf, sizeof(nbuf), \"name%d\", i);\n        Jsi_TreeSet(st, nbuf,(void*)i);\n    }\n    Jsi_TreeWalk(st, mycall, NULL, 0);\n    for (i=0; i<1000; i++) {\n        Jsi_TreeEntryDelete(st->root);\n    }\n    puts(\"OK\");\n    Jsi_TreeWalk(st, mycall, NULL, 0);\n    Jsi_TreeDelete(st);\n\n}\n\nint jsi_InitTree(Jsi_Interp *interp, int release)\n{\n    if (release) return JSI_OK;\n    TreeTest(interp);\n    return JSI_OK;\n}\n\n#else\n\nJsi_RC jsi_InitTree(Jsi_Interp *interp, int release)\n{\n    if (release) return JSI_OK;\n    /* TODO: maintain hash table of trees created per interp? */\n    return JSI_OK;\n}\n#endif\nuint Jsi_TreeSize(Jsi_Tree *treePtr) { return treePtr->numEntries; }\n\nJsi_RC Jsi_TreeConf(Jsi_Tree *treePtr, Jsi_MapOpts *opts, bool set)\n{\n    if (set)\n        treePtr->opts = *opts;\n    else\n        *opts = treePtr->opts;\n    return JSI_OK;\n}\n\n#ifndef JSI_LITE_ONLY\n\nstatic Jsi_Value *jsi_treeFmtKey(Jsi_MapEntry* h, struct Jsi_MapOpts *opts, int flags)\n{\n    Jsi_TreeEntry* hPtr = (Jsi_TreeEntry*)h;\n    void *key = Jsi_TreeKeyGet(hPtr);\n    if (opts->keyType == JSI_KEYS_ONEWORD)\n        return Jsi_ValueNewNumber(opts->interp, (Jsi_Number)(intptr_t)key);\n    char nbuf[JSI_MAX_NUMBER_STRING];\n    snprintf(nbuf, sizeof(nbuf), \"%p\", key);\n    return Jsi_ValueNewStringDup(opts->interp, nbuf);\n}\n\nJsi_RC Jsi_TreeKeysDump(Jsi_Interp *interp, Jsi_Tree *tablePtr, Jsi_Value **ret, int flags) {\n    char *key;\n    int n = 0;\n    Jsi_TreeEntry *hPtr;\n    Jsi_TreeSearch search;\n    Jsi_Obj *nobj;\n    Jsi_MapFmtKeyProc* fmtKeyProc = tablePtr->opts.fmtKeyProc;\n    \n    if (!fmtKeyProc && tablePtr->keyType == JSI_KEYS_ONEWORD && flags!=JSI_KEYS_ONEWORD )\n        fmtKeyProc = jsi_treeFmtKey;\n        \n    if (!fmtKeyProc && tablePtr->keyType >= JSI_KEYS_STRUCT_MINSIZE) \n        return Jsi_LogError(\"Can not dump struct tree\");\n    nobj = Jsi_ObjNew(interp);\n    Jsi_ValueMakeArrayObject(interp, ret, nobj);\n    for (hPtr = Jsi_TreeSearchFirst(tablePtr, &search, flags, NULL);\n        hPtr != NULL; hPtr = Jsi_TreeSearchNext(&search)) {\n        key = (char*)Jsi_TreeKeyGet(hPtr);\n        Jsi_Value *val;\n        if (fmtKeyProc) {\n            val = (*fmtKeyProc)((Jsi_MapEntry*)hPtr, &tablePtr->opts, flags);\n            if (!val) {\n                Jsi_LogError(\"key format failed\");\n                Jsi_ValueMakeUndef(interp, ret);\n                return JSI_ERROR;\n            }\n        } else if (tablePtr->keyType == JSI_KEYS_ONEWORD)\n            val = Jsi_ValueNewNumber(interp, (Jsi_Number)(uintptr_t)key);\n        else\n            val = Jsi_ValueNewStringKey(interp, key);\n        Jsi_ObjArraySet(interp, nobj, val, n++);\n        if (fmtKeyProc && val->refCnt>1) //TODO: Hmmm. for StructKey Jsi_OptionsDump() returns refCnt=1\n            Jsi_DecrRefCount(interp, val);\n    }\n    Jsi_TreeSearchDone(&search);\n    return JSI_OK;\n}\n#endif\n\n", "#ifndef JSI_AMALGAMATION\n#include \"jsiInt.h\"\n#endif\n#include <errno.h>\n#include <sys/time.h>\n\n\n#if (defined(JSI__READLINE) && JSI__READLINE==1)\n#define JSI_HAS_READLINE 1\n//#define USE_GNU_READLINE\n#ifdef USE_GNU_READLINE\n# include <readline/readline.h>\n# include <readline/history.h>\n\n# define jsi_sh_add_history(X) add_history(X)\n# define jsi_sh_read_history(X) read_history(X)\n# define jsi_sh_write_history(X) write_history(X)\n# define jsi_sh_stifle_history(X) stifle_history(X)\n# define jsi_sh_readline(X) readline(X)\n#else\n#ifndef JSI_AMALGAMATION\n#include \"linenoise.h\"\n#endif\n# define jsi_sh_add_history(X) linenoiseHistoryAdd(X)\n# define jsi_sh_read_history(X) linenoiseHistoryLoad(X)\n# define jsi_sh_write_history(X) linenoiseHistorySave(X)\n# define jsi_sh_stifle_history(X) linenoiseHistorySetMaxLen(X)\n# define jsi_sh_readline(X) linenoise(X)\n#endif\n#else\n\n# define jsi_sh_read_history(X)\n# define jsi_sh_write_history(X)\n# define jsi_sh_stifle_history(X)\n\n# define JSI_SH_USE_LOCAL_GETLINE 1\n#endif\n#include <math.h>\n\n#ifdef Jsi_Free\n#undef Jsi_Free\n#undef Jsi_Malloc\n#undef Jsi_Calloc\n#undef Jsi_Realloc\n#endif\nvoid* Jsi_Realloc(void *m,unsigned int size) {\n    void *v = realloc(m,size);\n    Assert(v);\n    return v;\n}\nvoid* Jsi_Malloc(unsigned int size) {\n    void *v = malloc(size);\n    Assert(v);\n    return v;\n}\nvoid* Jsi_Calloc(unsigned int n,unsigned int size) {\n    void *v = calloc(n,size);\n    Assert(v);\n    return v;\n}\nvoid  Jsi_Free(void *n) { Assert(n); free(n); }\n\n#if JSI__SANITIZE\n#define Jsi_Malloc(sz) malloc(sz)\n#define Jsi_Calloc(nm, sz) calloc(nm,sz)\n#define Jsi_Realloc(ptr, sz) realloc(ptr,sz)\n#define Jsi_Free(ptr) free(ptr)\n#endif\n\nstatic const char *jsi_LogCodes[] = { \"bug\", \"error\", \"warn\", \"info\", \"unused\", \"parse\", \"test\", \"debug\", \"trace\", 0 };\njsi_IntData jsiIntData = {};\n\n#ifdef JSI_LITE_ONLY\nJsi_RC Jsi_LogMsg(Jsi_Interp *interp, uint code, const char *format,...) {\n    va_list va;\n    va_start (va, format);\n    const char *mt = (code <= JSI__LOGLAST ? jsi_LogCodes[code] : \"\");\n    fputs(mt, stderr);\n    vfprintf(stderr, format, va);\n    fputs(\"\\n\", stderr);\n    va_end(va);\n    return JSI_ERROR;\n}\n\n#else // JSI_LITE_ONLY\n\nint jsi_fatalexit = JSI_LOG_BUG;\nconst char *jsi_GetCurFile(Jsi_Interp *interp)\n{\n    const char *curFile = NULL;\n    if (!interp)\n        return NULL;\n    if (interp->inParse)\n        curFile = interp->curFile;\n    else\n        curFile = (interp->curIp && interp->curIp->fname? interp->curIp->fname:interp->curFile);\n    if (!curFile) curFile = interp->framePtr->fileName;\n    if (!curFile) curFile = \"\";\n    return curFile;\n}\nextern void jsi_TypeMismatch(Jsi_Interp* interp)\n{\n    interp->typeMismatchCnt++;\n    if (interp->typeWarnMax<=0)\n        return;\n    if (interp->typeMismatchCnt>=interp->typeWarnMax) {\n        memset(&interp->typeCheck, 0, sizeof(interp->typeCheck));\n        Jsi_LogWarn(\"Max warnings exceeded %d: typeCheck disabled\", interp->typeWarnMax);\n    }\n}\n\nstatic bool jsi_LogEnabled(Jsi_Interp *interp, uint code) {\n    if (!interp->activeFunc) return 0;\n    Jsi_CmdSpec *cs = interp->activeFunc->cmdSpec;\n    if (!cs)\n        return 0;\n    if (interp->activeFunc->parentSpec)\n        cs = interp->activeFunc->parentSpec;\n    int cofs = (code - JSI_LOG_TEST);\n    int ac = (cs->flags & (JSI_CMD_LOG_TEST<<cofs));\n    return (ac)!=0;\n}\n\nstatic void (*logHook)(const char *buf, va_list va) = NULL;\n\n// Format message: always returns JSI_ERROR.\nJsi_RC Jsi_LogMsg(Jsi_Interp *interp, uint code, const char *format,...) {\n    if (Jsi_InterpGone(interp))\n        return JSI_ERROR;\n    va_list va;\n    va_start (va, format);\n    char pbuf[JSI_BUFSIZ/8] = \"\";\n    char buf[JSI_BUFSIZ/2];\n    const char *term = \"\", *pterm=pbuf;\n    static char lastMsg[JSI_BUFSIZ/2] = \"\";\n    static int lastCnt = 0;\n    static Jsi_Interp *LastInterp = NULL;\n    Jsi_Interp *lastInterp = LastInterp;\n    const char *emsg = buf, *mt;\n    int islog, line = 0, lofs = 0, noDups=0;\n    bool isHelp = (format[0]=='.' && !Jsi_Strncmp(format, \"...\", 3));\n    Jsi_OptionSpec *oep = interp->parseMsgSpec;\n    const char *pps = \"\", *curFile = \"\";\n    char *ss = interp->lastPushStr;\n    \n    if (interp==NULL)\n        interp = jsiIntData.mainInterp;\n    LastInterp = interp;\n    if (lastInterp != interp)\n        noDups = 1;\n    \n    /* Filter out try/catch (TODO: and non-syntax errors??). */\n    if (interp == NULL) {\n//nullInterp:\n        if (logHook)\n            (*logHook)(format, va);\n        else {\n            vfprintf(stderr, format, va);\n            fputc('\\n', stderr);\n        }\n        va_end(va);\n        return JSI_ERROR;\n    }\n    curFile = jsi_GetCurFile(interp);\n    switch (code) {\n        case JSI_LOG_INFO:  if (!interp->logOpts.Info) goto bail; break;\n        case JSI_LOG_WARN:  if (!interp->logOpts.Warn) goto bail; break;\n        case JSI_LOG_DEBUG: if (!interp->logOpts.Debug && !jsi_LogEnabled(interp, code)) goto bail; break;\n        case JSI_LOG_TRACE: if (!interp->logOpts.Trace && !jsi_LogEnabled(interp, code)) goto bail; break;\n        case JSI_LOG_TEST:  if (!interp->logOpts.Test && !jsi_LogEnabled(interp, code)) goto bail; break;\n        case JSI_LOG_PARSE: break; //if (!interp->parent) goto nullInterp; break;\n        case JSI_LOG_ERROR: {\n            if (!interp->logOpts.Error) goto bail;\n            if ((interp->framePtr->tryDepth - interp->framePtr->withDepth)>0 && interp->inParse<=0 \n                && (!interp->tryList || !(interp->tryList->inCatch|interp->tryList->inFinal))) { \n                /* Should only do the first or traceback? */\n                if (!interp->errMsgBuf[0]) {\n                    vsnprintf(interp->errMsgBuf, sizeof(interp->errMsgBuf), format, va);\n                    //interp->errMsgBuf[sizeof(interp->errMsgBuf)-1] = 0;\n                    interp->errFile =  jsi_GetCurFile(interp);\n                    interp->errLine = (interp->curIp?interp->curIp->Line:0);\n                    emsg = interp->errMsgBuf;\n                }\n                goto done;\n            }\n            interp->logErrorCnt++;\n            break;\n        }\n    }\n    mt = (code <= JSI__LOGLAST ? jsi_LogCodes[code] : \"\");\n    if (isHelp) mt = \"help\";\n    assert((JSI__LOGLAST+2) == (sizeof(jsi_LogCodes)/sizeof(jsi_LogCodes[0])));\n    if (!Jsi_Strchr(format,'\\n')) term = \"\\n\";\n    if (interp->strict && interp->lastParseOpt)\n        ss = (char*)Jsi_ValueToString(interp, interp->lastParseOpt, NULL);\n    if (code != JSI_LOG_INFO && code < JSI_LOG_TEST && interp && ss && ss[0]) {\n        char psbuf[JSI_BUFSIZ/6];\n        if (Jsi_Strchr(ss,'%')) {\n            char *s = ss, *sd = psbuf;\n            int plen=0, llen = sizeof(psbuf)-2;\n            while (*s && plen<llen) {\n                if (*s == '%')\n                    sd[plen++] = '%';\n                sd[plen++] = *s;\n                s++;\n            }\n            sd[plen] = 0;\n            ss = psbuf;\n        }\n        while (*ss && isspace(*ss))\n            ss++;\n        if (*ss && !isHelp)\n            snprintf(pbuf, sizeof(pbuf), \"    (at or near \\\"%s\\\")\\n\", ss);\n    }\n    pbuf[sizeof(pbuf)-1] = 0;\n    if (interp->inParse && interp->parseLine) {\n        line = interp->parseLine->first_line;\n        lofs = interp->parseLine->first_column;\n    } else if (interp->inParse && interp->parsePs) {\n        line = interp->parsePs->lexer->cur_line;\n        lofs = interp->parsePs->lexer->cur_char;\n    } else if (interp->curIp) {\n        if (interp->callerErr && interp->framePtr && interp->framePtr->parent) {\n            jsi_Frame *fptr = interp->framePtr->parent;\n            line = fptr->line;\n            lofs = 0;\n            curFile = fptr->fileName;\n        } else {\n            line = interp->curIp->Line;\n            lofs = interp->curIp->Lofs;\n            if (line<=0)\n                line = interp->framePtr->line;\n        }\n    }\n    islog = (interp->parent && interp->debugOpts.msgCallback && code != JSI_LOG_BUG);\n    Jsi_DString pStr;\n    Jsi_DSInit(&pStr);\n    if (oep) {\n        if (oep->id != JSI_OPTION_CUSTOM || !oep->custom)\n            pps = Jsi_DSPrintf(&pStr, \"for option \\\"%s\\\": \", oep->name);\n        else {\n            Jsi_OptionCustom* cust = Jsi_OptionCustomBuiltin(oep->custom);\n            pps = Jsi_DSPrintf(&pStr, \"for %s option \\\"%s\\\": \", (cust?cust->name:\"\"), oep->name);\n        }\n    }\n    char *cpt;\n    if (curFile && interp->logOpts.ftail && (cpt =Jsi_Strrchr(curFile, '/')) && cpt[1])\n        curFile = cpt+1;\n    if (curFile && curFile[0] && Jsi_Strchr(curFile,'%')==0 && !islog) {\n        if (!interp->subOpts.logColNums)\n            snprintf(buf, sizeof(buf), \"%s:%d: %s: %s%s%s%s\",  curFile, line, mt, pps, format, pterm, term);\n        else\n            snprintf(buf, sizeof(buf), \"%s:%d.%d: %s: %s%s%s%s\",  curFile, line, lofs, pps, mt,format, pterm, term);\n    } else {\n        snprintf(buf, sizeof(buf), \"%s: %s%s%s%s\", mt, pps, format, pterm, term);\n    }\n    Jsi_DSFree(&pStr);\n    buf[sizeof(buf)-1]=0;\n\n    if (logHook)\n        (*logHook)(buf, va);\n    else if (interp->subOpts.logAllowDups)\n        vfprintf(stderr, buf, va);\n    else {\n        char buf1[JSI_BUFSIZ/2];\n        vsnprintf(buf1, sizeof(buf1), buf, va);\n        if (!isHelp && !noDups) {\n            if (buf1[0] && lastCnt && Jsi_Strcmp(buf1, lastMsg)==0) {\n                lastCnt++;\n                goto done;\n            } else if (lastMsg[0] && lastCnt>1 ) {\n                fprintf(stderr, \"REPEAT: Last msg repeated %d times...\\\"\\n\" ,lastCnt);\n            }\n            if (buf1[0] == 0 || (buf1[0] == '.' && buf1[1] == 0))\n                goto done;\n        }\n        lastCnt = 1;\n        Jsi_Strcpy(lastMsg, buf1);\n        if (!islog)\n            Jsi_Puts(interp, jsi_Stderr, buf1, -1);\n            //fputs(buf1, stderr);\n        else {\n            Jsi_DString jStr={}, kStr={};\n            Jsi_DSPrintf(&kStr, \"[%s, \\\"%s\\\", \\\"%s\\\", %d, %d ]\",\n                Jsi_JSONQuote(interp, buf1, -1, &jStr), mt, curFile, line, lofs);\n            if (Jsi_FunctionInvokeJSON(interp->parent, interp->debugOpts.msgCallback, Jsi_DSValue(&kStr), NULL) != JSI_OK)\n                code = 1;\n            Jsi_DSFree(&jStr);\n            Jsi_DSFree(&kStr);\n        }\n    }\ndone:\n    va_end(va);\n    if (interp->debugOpts.hook) {\n        static int inhook = 0;\n        if (!inhook) {\n            inhook = 1;\n            (*interp->debugOpts.hook)(interp, curFile, interp->curIp?interp->curIp->Line:0, interp->level, interp->curFunction, \"DEBUG\", NULL, emsg);\n        }\n        inhook = 0;\n    }\n    if ((code & jsi_fatalexit) && !interp->opts.no_exit)\n        jsi_DoExit(interp, 1);\n    return (code==JSI_LOG_ERROR?JSI_ERROR:JSI_OK);\nbail:\n    va_end(va);\n    return JSI_OK;\n}\n\nconst char* Jsi_KeyAdd(Jsi_Interp *interp, const char *str)\n{\n    Jsi_MapEntry *hPtr;\n    bool isNew;\n    hPtr = Jsi_MapEntryNew(interp->strKeyTbl, str, &isNew);\n    assert(hPtr) ;\n    return (const char*)Jsi_MapKeyGet(hPtr, 0);\n}\n\nconst char* Jsi_KeyLookup(Jsi_Interp *interp, const char *str)\n{\n    Jsi_MapEntry *hPtr;\n    hPtr = Jsi_MapEntryFind(interp->strKeyTbl, str);\n    if (!hPtr) {\n        return NULL;\n    }\n    return (const char*)Jsi_MapKeyGet(hPtr, 0);\n}\n\n\nJsi_Value *Jsi_VarLookup(Jsi_Interp *interp, const char *varname)\n{\n    Jsi_Value *v;\n    v = Jsi_ValueObjLookup(interp, interp->framePtr->incsc, (char*)varname, 0);\n    if (!v)\n        v = jsi_ScopeChainObjLookupUni(interp->framePtr->ingsc, (char*)varname);\n    return v;\n}\n\nstatic char *FindEndB(char *cp) {\n    \n    if (*cp == '\\\"'||*cp == '\\'') {\n        char endc = *cp;\n        cp++;\n        while (*cp && *cp != endc) {\n            if (*cp == '\\\\' && cp[1]) cp++;\n            cp++;\n        }\n        if (*cp == endc)\n            cp++;\n        if (*cp != ']')\n            return NULL;\n        return cp;\n    } else\n        return Jsi_Strchr(cp, ']');\n}\n\n\n/* Lookup \"name\" within object \"inObj\", ie.  \"inObj.name\"  */\nJsi_Value *Jsi_NameLookup2(Jsi_Interp *interp, const char *name, const char *inObj)\n{\n    Jsi_Value *v;\n    if (!name)\n        return NULL;\n    if (!inObj)\n        return Jsi_VarLookup(interp, name);\n    v = Jsi_VarLookup(interp, inObj);\n    if (!v)\n        return NULL;\n    if (Jsi_ValueIsArray(interp, v)) {\n        int n;\n        if (!isdigit(name[0]))\n            return NULL;\n        if (Jsi_GetInt(interp, name, &n, 0) != JSI_OK)\n            return NULL;\n        if (n>=0 && n<(int)v->d.obj->arrCnt)\n            return v->d.obj->arr[n];\n        return NULL;\n    }\n    if (v->vt != JSI_VT_OBJECT || (v->d.obj->ot != JSI_OT_OBJECT && v->d.obj->ot != JSI_OT_FUNCTION))\n        return NULL;\n    return Jsi_ValueObjLookup(interp, v, name, 0);\n}\n\n/* Lookup a name, eg.  \"a[b].c  a.b.c  a[b][c]  a.b[c]  a[\"b\"].c  a[1].c  */\nJsi_Value *Jsi_NameLookup(Jsi_Interp *interp, const char *name)\n{\n    uint cnt = 0, len, isq;\n    char *nam = (char*)name, *cp, *cp2, *ocp, *kstr;\n    //DECL_VALINIT(tv);\n    DECL_VALINIT(nv);\n    DECL_VALINIT(key);\n    Jsi_Value *v = NULL, *nvPtr = &nv;\n    Jsi_Value *kPtr = &key; // Note: a string key so no reset needed.\n    Jsi_DString dStr = {};\n    cp2 = Jsi_Strchr(nam,'[');\n    cp = Jsi_Strchr(nam, '.');\n    if (cp2 && (cp==0 || cp2<cp))\n        cp = cp2;\n    if (!cp)\n        return Jsi_VarLookup(interp, nam);\n    //fprintf(stderr, \"NAM: %s\\n\", nam);\n    Jsi_DSSetLength(&dStr, 0);\n    Jsi_DSAppendLen(&dStr, nam, cp-nam);\n    v = Jsi_VarLookup(interp, Jsi_DSValue(&dStr));\n    if (!v)\n        goto bail;\n    while (v && cnt++ < 1000) {\n        ocp = cp;\n        nam = cp+1;\n        isq = 0;\n        if (*cp == '[') {\n            cp = FindEndB(cp+1); /* handle [] in strings. */\n            if (!cp) goto bail;\n            len = cp-nam;\n            cp++;\n            if (len>=2 && ((nam[0] == '\\\"' && nam[len-1] == '\\\"') || (nam[0] == '\\'' && nam[len-1] == '\\''))) {\n                nam += 1;\n                len -= 2;\n                isq = 1;\n            }\n        } else if (*cp == '.') {\n            cp2 = Jsi_Strchr(nam,'[');\n            cp = Jsi_Strchr(nam, '.');\n            if (cp2 && (cp==0 || cp2<cp))\n                cp = cp2;\n            len = (cp ? (uint)(cp-nam) : Jsi_Strlen(nam));\n        } else {\n            goto bail;\n        }\n        Jsi_DSSetLength(&dStr, 0);\n        Jsi_DSAppendLen(&dStr, nam, len);\n        kstr = Jsi_DSValue(&dStr);\n        if (*ocp == '[' && isq == 0 && isdigit(kstr[0]) && Jsi_ValueIsArray(interp, v)) {\n            int nn;\n            if (Jsi_GetInt(interp, kstr, &nn, 0) != JSI_OK)\n                goto bail;\n            v = Jsi_ValueArrayIndex(interp, v, nn);\n            if (!v)\n                goto bail;\n        } else if (*ocp == '[' && isq == 0) {\n            Jsi_Value *kv = Jsi_VarLookup(interp, kstr);\n            if (!kv)\n                goto bail;\n            v = jsi_ValueSubscript(interp, v, kv, &nvPtr);\n            goto keyon;\n        } else {\n            Jsi_ValueMakeStringKey(interp, &kPtr, kstr);\n            v = jsi_ValueSubscript(interp, v, kPtr, &nvPtr);\nkeyon:\n            if (!v)\n                goto bail;\n        }\n        if (cp == 0 || *cp == 0) break;\n    }\n    //Jsi_ValueReset(interp, &ret);\n    Jsi_DSFree(&dStr);\n    if (v && v == nvPtr) {\n        v = Jsi_ValueNew(interp);\n        //Jsi_ValueMove(interp, v, &tv);\n#ifdef JSI_MEM_DEBUG\n        memcpy(v, &nv, sizeof(nv)-sizeof(nv.VD));\n        v->VD.label3 = nv.VD.func;\n        if (interp->memDebug>1)\n            v->VD.label2 = Jsi_KeyAdd(interp, name);\n#else\n        *v = nv;\n#endif\n    }\n    return v;\nbail:\n    Jsi_DSFree(&dStr);\n    return NULL;\n}\n\nJsi_Value *jsi_GlobalContext(Jsi_Interp *interp)\n{\n    return interp->csc;\n}\n\ntypedef struct {\n    Jsi_DString *dStr;\n    int quote; /* Set to JSI_OUTPUT_JSON, etc*/\n    int depth;\n} objwalker;\n\nbool Jsi_StrIsAlnum(const char *cp)\n{\n    if (!cp || !*cp) return 0;\n    while (*cp)\n        if (isalnum(*cp) || *cp == '_')\n            cp++;\n        else\n            return 0;\n    return 1;\n}\n\n/* Modify Sql to append bind fields for Object */\nJsi_RC Jsi_SqlObjBinds(Jsi_Interp* interp, Jsi_DString* zStr, const char *varName, bool addTypes, bool addDefaults, bool nullDefaults) {\n    Jsi_Value *v, *vnPtr = Jsi_VarLookup(interp, varName);\n    if (!vnPtr || !Jsi_ValueIsObjType(interp, vnPtr, JSI_OT_OBJECT))\n        return Jsi_LogError(\"varName must be an Object: %s\", varName);\n    char *cp, *zSql = Jsi_DSValue(zStr);\n    int create = !Jsi_Strncasecmp(zSql,\"create\",6);\n    int insert = !Jsi_Strncasecmp(zSql,\"insert\",6);\n    if (!create && !insert) return JSI_OK;\n    const char *cPtr = Jsi_Strstr(zSql, \" %s\");\n    if (!cPtr) cPtr = Jsi_Strstr(zSql, \"\\t%s\");\n    if (!cPtr)\n        return Jsi_LogError(\"Object varName must contain a ' %%s': %s\", varName);\n    Jsi_DString sStr = {}, vStr = {}, jStr = {};\n    Jsi_DSAppendLen(&sStr, zSql, cPtr?(cPtr-zSql):-1);\n    Jsi_DSAppend(&sStr, \" (\", NULL);\n\n    Jsi_IterObj *io = Jsi_IterObjNew(interp, NULL);\n    Jsi_IterGetKeys(interp, vnPtr, io, 0);\n    uint i;\n    const char *pre = \"\", *kstr;\n    if (!create)\n        Jsi_DSAppend(&vStr, \" VALUES(\", NULL);\n    for (i=0; i<io->count; i++) {\n        kstr = io->keys[i];\n        const char *qs = \"\", *qe = \"\";\n        if (!Jsi_StrIsAlnum(kstr) || Jsi_IsReserved(interp, kstr, 1)) {\n            qe = qs = \"'\";\n        }\n        Jsi_DSAppend(&sStr, pre, qs, kstr, qe, NULL);\n        if (create) {\n            const char *typ = NULL, *dflt=(nullDefaults?\"NULL\":NULL);\n            if (addTypes && ((v = Jsi_ValueObjLookup(interp, vnPtr, kstr, 1)))) {\n                if (Jsi_ValueIsBoolean(interp, v)) {\n                    typ = \"BOOLEAN\";\n                    if (!nullDefaults && addDefaults) {\n                        bool bv = 0;\n                        Jsi_ValueGetBoolean(interp, v, &bv);\n                        dflt = (bv?\"1\":\"0\");\n                    }\n                } else if (Jsi_ValueIsNumber(interp, v)) {\n                    typ = \"NUMERIC\";\n                    if (!Jsi_Strcmp(kstr,\"rowid\"))\n                        typ = \"INTEGER PRIMARY KEY\";\n                    else if (!nullDefaults && addDefaults) {\n                        Jsi_Number nv = 0;\n                        Jsi_DSFree(&jStr);\n                        Jsi_ValueGetNumber(interp, v, &nv);\n                        dflt = Jsi_DSPrintf(&jStr, \"%\" JSI_NUMGFMT, nv);\n                    }\n                } else if (Jsi_ValueIsArray(interp, v) || Jsi_ValueIsObjType(interp, v, JSI_OT_OBJECT)) {\n                    typ = \"CHARJSON\";\n                    if (!nullDefaults && addDefaults) {\n                        Jsi_DSFree(&jStr);\n                        Jsi_DSAppend(&jStr, \"'\", NULL);\n                        Jsi_ValueGetDString(interp, v, &jStr, JSI_OUTPUT_JSON|JSI_JSON_STRICT);\n                        Jsi_DSAppend(&jStr, \"'\", NULL);\n                        dflt = Jsi_DSValue(&jStr);\n                    }\n                } else {\n                    typ = \"TEXT\";\n                    if (!nullDefaults && addDefaults) {\n                        if ((cp=Jsi_ValueString(interp, v, NULL))) {\n                            Jsi_DSFree(&jStr);\n                            dflt = Jsi_DSAppend(&jStr, \"'\", cp, \"'\", NULL);\n                        } else\n                        dflt = \"NULL\";\n                    }\n                }\n            }\n            if (typ)\n                Jsi_DSAppend(&sStr, \" \", typ, (dflt?\" DEFAULT \":\"\"), dflt, NULL);\n        } else {\n            Jsi_DSAppend(&vStr, pre, \"$\", varName, \"(\", kstr, \")\", NULL);\n        }\n        pre = \",\";\n    }\n    if (!create)\n        Jsi_DSAppend(&vStr, \")\", NULL);\n    Jsi_IterObjFree(io);\n    Jsi_DSAppend(&sStr, \") \", Jsi_DSValue(&vStr), cPtr+3, NULL);\n    Jsi_DSFree(zStr);\n    Jsi_DSAppend(zStr, Jsi_DSValue(&sStr), NULL);\n    Jsi_DSFree(&sStr); Jsi_DSFree(&vStr); Jsi_DSFree(&jStr);\n    return JSI_OK;\n}\n\nchar *jsi_TrimStr(char *str) {\n    while (isspace(*str)) str++;\n    if (!str) return str;\n    int len = Jsi_Strlen(str);\n    while (--len>=0 && isspace(str[len]))\n        str[len] = 0;\n    return str;\n}\n\nstatic Jsi_RC jsiValueGetString(Jsi_Interp *interp, Jsi_Value* v, Jsi_DString *dStr, objwalker *owPtr);\n\nstatic Jsi_RC _object_get_callback(Jsi_Tree *tree, Jsi_TreeEntry *hPtr, void *data)\n{\n    Jsi_Value *v;\n    objwalker *ow = (objwalker *)data;\n    Jsi_DString *dStr = ow->dStr;\n    int len;\n    char *str;\n    if ((hPtr->f.bits.dontenum))\n        return JSI_OK;\n    v =(Jsi_Value*) Jsi_TreeValueGet(hPtr);\n    if ((ow->quote&JSI_OUTPUT_JSON) && v && v->vt == JSI_VT_UNDEF)\n        return JSI_OK;\n    str = (char*)Jsi_TreeKeyGet(hPtr);\n    char *cp = Jsi_DSValue(dStr);\n    len = Jsi_DSLength(dStr);\n    if (len>=2 && (cp[len-2] != '{' || cp[len-1] == '}'))\n        Jsi_DSAppend(dStr, \", \", NULL);\n    if (((ow->quote&JSI_OUTPUT_JSON) == 0 || (ow->quote&JSI_JSON_STRICT) == 0) && Jsi_StrIsAlnum(str)\n        && !Jsi_HashEntryFind(tree->opts.interp->lexkeyTbl, str))\n        Jsi_DSAppend(dStr, str, NULL);\n    else\n        /* JSON/spaces, etc requires quoting the name. */\n        Jsi_DSAppend(dStr, \"\\\"\", str, \"\\\"\", NULL);\n    Jsi_DSAppend(dStr, \":\", NULL);\n    ow->depth++;\n    Jsi_RC rc = jsiValueGetString(tree->opts.interp, v, dStr, ow);\n    ow->depth--;\n    return rc;\n}\n\n/* Format value into dStr.  Toplevel caller does init/free. */\nstatic Jsi_RC jsiValueGetString(Jsi_Interp *interp, Jsi_Value* v, Jsi_DString *dStr, objwalker *owPtr)\n{\n    char buf[JSI_MAX_NUMBER_STRING], *str;\n    Jsi_DString eStr;\n    Jsi_DSInit(&eStr);\n    if (interp->maxDepth>0 && owPtr->depth > interp->maxDepth)\n        return Jsi_LogError(\"recursive ToString\");\n    int quote = owPtr->quote;\n    int isjson = owPtr->quote&JSI_OUTPUT_JSON;\n    Jsi_Number num;\n    switch(v->vt) {\n        case JSI_VT_UNDEF:\n            Jsi_DSAppend(dStr, \"undefined\", NULL);\n            return JSI_OK;\n        case JSI_VT_NULL:\n            Jsi_DSAppend(dStr, \"null\", NULL);\n            return JSI_OK;\n        case JSI_VT_VARIABLE:\n            Jsi_DSAppend(dStr, \"variable\", NULL);\n            return JSI_OK;\n        case JSI_VT_BOOL:\n            Jsi_DSAppend(dStr, (v->d.val ? \"true\":\"false\"), NULL);\n            return JSI_OK;\n        case JSI_VT_NUMBER:\n            num = v->d.num;\noutnum:\n            if (isjson && !Jsi_NumberIsNormal(num)) {\n                Jsi_DSAppend(dStr, \"null\", NULL);\n            } else if (Jsi_NumberIsInteger(num)) {\n                Jsi_NumberItoA10((Jsi_Wide)num, buf, sizeof(buf));\n                Jsi_DSAppend(dStr, buf, NULL);\n            } else if (Jsi_NumberIsWide(num)) {\n                snprintf(buf, sizeof(buf), \"%\" PRId64, (Jsi_Wide)num);\n                Jsi_DSAppend(dStr, buf, NULL);\n            } else if (Jsi_NumberIsNormal(num) || Jsi_NumberIsSubnormal(num)) {\n                Jsi_NumberDtoA(interp, num, buf, sizeof(buf), 0);\n                Jsi_DSAppend(dStr, buf, NULL);\n            } else if (Jsi_NumberIsNaN(num)) {\n                Jsi_DSAppend(dStr, \"NaN\", NULL);\n            } else {\n                int s = Jsi_NumberIsInfinity(num);\n                if (s > 0) Jsi_DSAppend(dStr, \"+Infinity\", NULL);\n                else if (s < 0) Jsi_DSAppend(dStr, \"-Infinity\", NULL);\n                else Jsi_LogBug(\"Ieee function problem: %d\", fpclassify(num));\n            }\n            return JSI_OK;\n        case JSI_VT_STRING:\n            str = v->d.s.str;\noutstr:\n            if (!quote) {\n                Jsi_DSAppend(dStr, str, NULL);\n                return JSI_OK;\n            }\n            Jsi_DSAppend(dStr,\"\\\"\", NULL);\n            while (*str) {\n                if ((*str == '\\'' && (!isjson)) || *str == '\\\\'|| *str == '\\\"'|| (*str == '\\n'\n                    && (!(owPtr->quote&JSI_OUTPUT_NEWLINES)))\n                    || *str == '\\r' || *str == '\\t' || *str == '\\f' || *str == '\\b'  ) {\n                    char pcp[2];\n                    *pcp = *str;\n                    pcp[1] = 0;\n                    Jsi_DSAppendLen(dStr,\"\\\\\", 1);\n                    switch (*str) {\n                        case '\\r': *pcp = 'r'; break;\n                        case '\\n': *pcp = 'n'; break;\n                        case '\\t': *pcp = 't'; break;\n                        case '\\f': *pcp = 'f'; break;\n                        case '\\b': *pcp = 'b'; break;\n                    }\n                    Jsi_DSAppendLen(dStr,pcp, 1);\n                } else if (isprint(*str) || !isjson)\n                    Jsi_DSAppendLen(dStr,str, 1);\n                else {\n                    char ubuf[10];\n                    int l = Jsi_UtfEncode(str, ubuf);\n                    Jsi_DSAppend(dStr,ubuf, NULL);\n                    str += l-1;\n                }\n                str++;\n            }\n            Jsi_DSAppend(dStr,\"\\\"\", NULL);\n            Jsi_DSFree(&eStr);\n            return JSI_OK;\n        case JSI_VT_OBJECT: {\n            Jsi_Obj *o = v->d.obj;\n            switch(o->ot) {\n                case JSI_OT_BOOL:\n                    Jsi_DSAppend(dStr, (o->d.val ? \"true\":\"false\"), NULL);\n                    return JSI_OK;\n                case JSI_OT_NUMBER:\n                    num = o->d.num;\n                    goto outnum;\n                    return JSI_OK;\n                case JSI_OT_STRING:\n                    str = o->d.s.str;\n                    goto outstr;\n                case JSI_OT_FUNCTION:\n                    Jsi_FuncObjToString(interp, o->d.fobj->func, &eStr, 3 | ((owPtr->depth==0 && owPtr->quote)?8:0));\n                    str = Jsi_DSValue(&eStr);\n                    goto outstr;\n                case JSI_OT_REGEXP:\n                    str = o->d.robj->pattern;\n                    goto outstr;\n                case JSI_OT_USEROBJ:\n                    jsi_UserObjToName(interp, o->d.uobj, &eStr);\n                    str = Jsi_DSValue(&eStr);\n                    goto outstr;\n                case JSI_OT_ITER:\n                    Jsi_DSAppend(dStr, (isjson?\"null\":\"*ITER*\"), NULL);\n                    return JSI_OK;\n                default:\n                    break;\n            }\n                        \n            if (o->isarrlist)\n            {\n                Jsi_Value *nv;\n                int i, len = o->arrCnt;\n                \n                if (!o->arr)\n                    len = Jsi_ValueGetLength(interp, v);\n                Jsi_DSAppend(dStr,\"[\",len?\" \":\"\", NULL);\n                for (i = 0; i < len; ++i) {\n                    nv = Jsi_ValueArrayIndex(interp, v, i);\n                    if (i) Jsi_DSAppend(dStr,\", \", NULL);\n                    owPtr->depth++;\n                    if (nv) {\n                        if (jsiValueGetString(interp, nv, dStr, owPtr) != JSI_OK) {\n                            owPtr->depth--;\n                            return JSI_ERROR;\n                        }\n                    }\n                    else Jsi_DSAppend(dStr, \"undefined\", NULL);\n                    owPtr->depth--;\n                }\n                Jsi_DSAppend(dStr,len?\" \":\"\",\"]\", NULL);\n            } else {\n                int len = Jsi_TreeSize(o->tree);\n                Jsi_DSAppend(dStr,\"{\",len?\" \":\"\", NULL);\n                owPtr->depth++;\n                Jsi_TreeWalk(o->tree, _object_get_callback, owPtr, 0);\n                owPtr->depth--;\n                Jsi_DSAppend(dStr,len?\" \":\"\",\"}\", NULL);\n            }\n            return JSI_OK;\n        }\n#ifndef __cplusplus\n        default:\n            Jsi_LogBug(\"Unexpected value type: %d\", v->vt);\n#endif\n    }\n    return JSI_OK;\n}\n\n/* Format value into dStr.  Toplevel caller does init/free. */\nconst char* Jsi_ValueGetDString(Jsi_Interp *interp, Jsi_Value* v, Jsi_DString *dStr, int quote)\n{\n    objwalker ow;\n    ow.quote = quote;\n    ow.depth = 0;\n    ow.dStr = dStr;\n    jsiValueGetString(interp, v, dStr, &ow);\n    return Jsi_DSValue(dStr);\n}\n\nchar* jsi_KeyFind(Jsi_Interp *interp, const char *str, int nocreate, int *isKey)\n{\n    Jsi_MapEntry *hPtr;\n    if (isKey) *isKey = 0;\n    if (!nocreate) {\n        *isKey = 1;\n         if (isKey) *isKey = 1;\n        return (char*)Jsi_KeyAdd(interp, str);\n    }\n    hPtr = Jsi_MapEntryFind(interp->strKeyTbl, str);\n    if (!hPtr) {\n        return Jsi_Strdup(str);;\n    }\n    if (isKey) *isKey = 1;\n    *isKey = 1;\n    return (char*)Jsi_MapKeyGet(hPtr, 0);\n}\n\nbool jsi_StrIsBalanced(char *str) {\n    int cnt = 0, quote = 0;\n    char *cp = str;\n    while (*cp) {\n        switch (*cp) {\n        case '\\\\':\n            cp++;\n            break;\n        case '{': case '(': case '[':\n            cnt++;\n            break;\n        case '\\'': case '\\\"':\n            quote++;\n            break;\n        case '}': case ')': case ']':\n            cnt--;\n            break;\n        }\n        if (*cp == 0)\n            break;\n        cp++;\n    }\n    return ((quote%2) == 0 && cnt <= 0);\n}\n\nstatic char *get_inputline(Jsi_Interp *interp, int istty, const char *prompt)\n{\n    char *res;\n#ifdef JSI_HAS_READLINE\n    if (istty && interp->subOpts.noReadline==0) {\n        res = jsi_sh_readline(prompt);\n        if (res && *res) jsi_sh_add_history(res);\n        return res;\n    }\n#endif\n    int done = 0;\n    char bbuf[JSI_BUFSIZ];\n    Jsi_DString dStr = {};\n    if (istty)\n        fputs(prompt, stdout);\n    fflush(stdout);\n    while (!done) { /* Read a line. */\n        bbuf[0] = 0;\n        if (fgets(bbuf, sizeof(bbuf), stdin) == NULL)\n            return NULL;\n        Jsi_DSAppend(&dStr, bbuf, NULL);\n        if (Jsi_Strlen(bbuf) < (sizeof(bbuf)-1) || bbuf[sizeof(bbuf)-1] == '\\n')\n            break;\n    }\n    res = Jsi_Strdup(Jsi_DSValue(&dStr));\n    Jsi_DSFree(&dStr);\n    return res;\n}\n\nstatic Jsi_Interp* jsi_interactiveInterp = NULL;\n#ifdef JSI_HAS_READLINE\nstatic Jsi_Value *completeValues = NULL;\n\n#ifdef USE_GNU_READLINE\nstatic int jsiRlStart = 0;\n\nstatic char *jsiRlCmdMatches(const char *text, int state) {\n    static int idx, len;\n    const char *name;\n    Jsi_Interp* interp = jsi_interactiveInterp;\n    if (completeValues == NULL || !Jsi_ValueIsArray(interp, completeValues))\n        return NULL;\n    Jsi_Value **arr = completeValues->d.obj->arr;\n    int aLen = completeValues->d.obj->arrCnt;\n\n    if (!state)\n    {\n        idx = 0;\n        len = Jsi_Strlen(text)-jsiRlStart;\n    }\n    while (idx<aLen)\n    {\n        name = Jsi_ValueString(interp, arr[idx], NULL);\n        if (!name) name = \"\";\n        idx++;\n        if (Jsi_Strncmp(name, text+jsiRlStart, len) == 0)\n            return (Jsi_Strdup(name));\n    }\n    return NULL;\n}\n\nstatic char **jsiRlGetMatches(const char *cstr, int start, int end) {\n    char **matches = NULL;\n    char *str = rl_line_buffer;\n    jsiRlStart = start;\n    if (1 || start == 0 || !completeValues) {\n        int rc;\n        Jsi_Interp* interp = jsi_interactiveInterp;\n        if (!completeValues)\n            completeValues = Jsi_ValueNew1(interp);\n        Jsi_Value *func = interp->onComplete;\n        if (func == NULL || !Jsi_ValueIsFunction(interp, func))\n            func = Jsi_NameLookup(interp, \"Info.completions\");\n        if (func && Jsi_ValueIsFunction(interp, func)) {\n            Jsi_Value *items[3] = {};\n            items[0] = Jsi_ValueNewStringDup(interp, str);\n            items[1] = Jsi_ValueNewNumber(interp, (Jsi_Number)start);\n            items[2] = Jsi_ValueNewNumber(interp, (Jsi_Number)end);;\n            Jsi_Value *args = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, 3, 0));\n            Jsi_IncrRefCount(interp, args);\n            rc = Jsi_FunctionInvoke(interp, func, args, &completeValues, interp->csc);\n            Jsi_DecrRefCount(interp, args);\n            if (rc != JSI_OK)\n                fprintf(stderr, \"bad completion: %s %d %d\\n\", str?str:\"\", start, end);\n        }\n        matches = rl_completion_matches(str, jsiRlCmdMatches);\n    }\n    return matches;\n}\n#else\nstatic const char *jsiFilePreCmds[] = {\n    \"File.\", \"source\", \"load\", \"new Channel\", \"new Sqlite\", NULL\n};\n\nchar *jsiLNhints(const char *buf, int *color, int *bold) {\n    int i, len = Jsi_Strlen(buf);\n    for (i=0; jsiFilePreCmds[i]; i++)\n        if (!Jsi_Strncmp(buf, jsiFilePreCmds[i], Jsi_Strlen(jsiFilePreCmds[i]))) break;\n    if (jsiFilePreCmds[i]) {\n        const char *ce = buf+len-1, *cp = \"('<file>\";\n        if ((*ce =='\\'' || *ce =='\\\"') && buf[len-2]=='(') cp+=2;\n        else if (*ce=='(') cp++;\n        else return NULL;\n        \n        *color = 35;\n        *bold = 0;\n        return (char*)cp;\n    }\n    return NULL;\n}\n\nstatic void jsiLNGetMatches(const char *str, linenoiseCompletions *lc) {\n    char buf[JSI_BUFSIZ], pre[JSI_BUFSIZ], hpre[6] = {};\n    const char *cp, *fnam = \"Info.completions\";\n    int i = 0, len;\n    int rc, isfile = 0, start = 0, end = Jsi_Strlen(str);\n    Jsi_Interp* interp = jsi_interactiveInterp;\n    if (!Jsi_Strncmp(str, \"help \", 5)) {\n        Jsi_Strcpy(hpre, \"help \");\n        str += 5;\n        end -= 5;\n    }\n    if (end<=0) return;\n    Jsi_Strncpy(buf, str, sizeof(buf)-1);\n    buf[sizeof(buf)-1] = 0;\n    pre[0] = 0;\n    if (end<=3 && !Jsi_Strncmp(str, \"help\", end)) {\n        linenoiseAddCompletion(lc, \"help\");\n        return;\n    }\n    if (!completeValues)\n        completeValues = Jsi_ValueNew1(interp);\n    Jsi_Value *func = interp->onComplete;\n    if (func == NULL || !Jsi_ValueIsFunction(interp, func)) {\n        for (i=0; jsiFilePreCmds[i]; i++)\n            if (!Jsi_Strncmp(buf, jsiFilePreCmds[i], Jsi_Strlen(jsiFilePreCmds[i]))) break;\n        if (jsiFilePreCmds[i] && ((cp=Jsi_Strrchr(buf, '(')) && (cp[1]=='\\\"' || cp[1]=='\\''))) {\n            Jsi_Strcpy(pre, buf);\n            pre[cp-buf+2] = 0;\n            snprintf(buf, sizeof(buf), \"%s*%s\", cp+2, (buf[0]=='s'?\".js*\":\"\"));\n            isfile = 1;\n            fnam = \"File.glob\";\n        }\n    }\n    func = Jsi_NameLookup(interp, fnam);\n    if (func && Jsi_ValueIsFunction(interp, func)) {\n        //printf(\"PATTERN: %s\\n\", str);\n        Jsi_Value *items[3] = {};;\n        i = 0;\n        items[i++] = Jsi_ValueNewStringDup(interp, buf);\n        if (!isfile) {\n            items[i++] = Jsi_ValueNewNumber(interp, (Jsi_Number)start);\n            items[i++] = Jsi_ValueNewNumber(interp, (Jsi_Number)end);\n        }\n        Jsi_Value *args = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, i, 0));\n        Jsi_IncrRefCount(interp, args);\n        rc = Jsi_FunctionInvoke(interp, func, args, &completeValues, interp->csc);\n        Jsi_DecrRefCount(interp, args);\n        if (rc != JSI_OK) {\n            fprintf(stderr, \"bad completion: %s %d %d\\n\", str?str:\"\", start, end);\n            return;\n        }\n        const char *name;\n        Jsi_Interp* interp = jsi_interactiveInterp;\n        if (completeValues == NULL || !Jsi_ValueIsArray(interp, completeValues))\n            return;\n        Jsi_Value **arr = completeValues->d.obj->arr;\n        int aLen = completeValues->d.obj->arrCnt;\n        i = 0;\n        while (i<aLen)\n        {\n            name = Jsi_ValueString(interp, arr[i], &len);\n            if (name) {\n                if (!pre[0] && !hpre[0])\n                    linenoiseAddCompletion(lc, name);\n                else {\n                    snprintf(buf, sizeof(buf), \"%s%s%s\", hpre, pre, name);\n                    linenoiseAddCompletion(lc, buf);\n                }\n            }\n            i++;\n        }\n    }\n}\n#endif\n#endif\n#if JSI__SIGNAL\n#include <signal.h> //  our new library \n#endif\n\n#if JSI__SIGNAL\nstatic void jsi_InteractiveSignal(int sig){\n    if (jsi_interactiveInterp)\n        jsi_interactiveInterp->interrupted = 1;\n}\n#endif\n \n/* Collect and execute code from stdin.  The first byte of flags are passed to Jsi_ValueGetDString(). */\nJsi_RC Jsi_Interactive(Jsi_Interp* interp, int flags) \n{\n    Jsi_RC rc = JSI_OK;\n    int done = 0, len, quote = (flags & 0xff), istty = 1, chkHelp=0, hasHelp=0;\n    const char *prompt = interp->subOpts.prompt;\n    char *buf;\n    if (jsi_interactiveInterp) \n        return Jsi_LogError(\"multiple interactive not supported\");\n#if JSI__SIGNAL\n  signal(SIGINT, jsi_InteractiveSignal); \n#endif\n    interp->typeCheck.parse = interp->typeCheck.run = interp->typeCheck.all = 1;\n    interp->strict = 1;\n    interp->isInteractive = 1;\n    jsi_interactiveInterp = interp;\n    interp->subOpts.istty = 1;\n    interp->subOpts.logAllowDups = 1;\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n#ifndef __WIN32\n    istty = isatty(fileno(stdin));\n#else\n    istty = _isatty(_fileno(stdin));\n#endif\n#ifdef JSI_HAS_READLINE\n    Jsi_DString dHist = {}, sHist = {};\n    char *hist = NULL;\n#ifdef USE_GNU_READLINE\n    rl_attempted_completion_function = jsiRlGetMatches;\n#else\n    linenoiseSetCompletionCallback(jsiLNGetMatches);\n    linenoiseSetHintsCallback(jsiLNhints);\n#endif\n    if(interp->subOpts.noReadline == 0 && !interp->parent && !(interp->isSafe && interp->safeMode==jsi_safe_Lockdown))\n    {\n        const char *hfile = (interp->historyFile ? interp->historyFile : \"~/.jsish_history\");\n        hist = Jsi_NormalPath(interp, hfile, &dHist);\n        if (hist)\n            jsi_sh_read_history(hist);\n    }\n#endif\n    interp->level++;\n    if (!interp->iskips)\n        puts(\"Jsish interactive: see 'help [cmd]' or 'history'.  \\\\ cancels > input.\"\n#if JSI__SIGNAL\n        \"  ctrl-c aborts running script.\"\n#endif\n        );\n    while (done==0 && interp->exited==0) {\n        buf = get_inputline(interp, istty, (prompt?prompt:\"$ \"));\n        if (buf) {\n            if (buf[0] == '\\\\' && !buf[1]) {\n                 Jsi_DSSetLength(&dStr, 0);\n                 prompt = interp->subOpts.prompt;\n                 fprintf(stderr, \"abandoned input\");\n            } else\n                Jsi_DSAppend(&dStr, buf, NULL);\n            free(buf);\n        } else {\n            done = 1;\n        }\n        len = Jsi_DSLength(&dStr);\n        if (done && len == 0)\n            break;\n        if (!len) continue;\n        Jsi_DSAppendLen(&dStr, \" \", 1); // Allow for added space.\n        buf = Jsi_DSValue(&dStr);\n        if (done == 0 && (!jsi_StrIsBalanced(buf))) {\n            prompt = interp->subOpts.prompt2;\n            continue;\n        }\n        prompt = interp->subOpts.prompt;\n        while ((len = Jsi_Strlen(buf))>0 && (isspace(buf[len-1])))\n            buf[len-1] = 0;\n        if (buf[0] == 0) {\n            Jsi_DSSetLength(&dStr, 0);\n            continue;\n        }\n        bool wantHelp = 0;\n        if (interp->onEval == NULL) {\n            /* Convenience: add semicolon to \"var\" statements (required by parser). */\n#ifdef JSI_HAS_READLINE\n            if (!Jsi_Strncmp(buf, \"history\", 7) && buf[7] == 0) {\n                fputs(Jsi_DSValue(&sHist), stdout);\n                Jsi_DSSetLength(&dStr, 0);\n                continue;\n            }\n#endif\n            if (!Jsi_Strncmp(buf, \"help\", 4) && (buf[4] == 0 || isspace(buf[4]))) {\n                if (!chkHelp++)\n                    hasHelp = (Jsi_PkgRequire(interp, \"Help\", 0)>=0);\n                if (hasHelp) {\n                    wantHelp = 1;\n                    char tbuf[BUFSIZ];\n                    snprintf(tbuf, sizeof(tbuf), \"return runModule('Help', '%s'.trim().split(null));\", buf+4);\n                    rc = Jsi_EvalString(interp, tbuf, JSI_RETURN);\n                }\n            }\n            if (!wantHelp) {\n                if (!Jsi_Strncmp(buf,\"var \", 4) && Jsi_Strchr(buf, '\\n')==NULL && Jsi_Strchr(buf, ';')==NULL)\n                    Jsi_Strcpy(buf+Jsi_Strlen(buf), \";\"); // Added space above so strcat ok.\n                rc = Jsi_EvalString(interp, buf, JSI_EVAL_RETURN);\n                prompt = interp->subOpts.prompt;\n#ifdef JSI_HAS_READLINE\n                if (rc == JSI_OK)\n                    Jsi_DSAppend(&sHist, buf, \"\\n\", NULL);\n#endif\n            }\n        }\n        else\n        {\n            Jsi_Value *func = interp->onEval;\n            if (func && Jsi_ValueIsFunction(interp, func)) {\n                Jsi_Value *items[1] = {};\n                items[0] = Jsi_ValueNewStringDup(interp, buf);\n                Jsi_Value *args = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, 1, 0));\n                Jsi_IncrRefCount(interp, args);\n                rc = Jsi_FunctionInvoke(interp, func, args, &interp->retValue, interp->csc);\n                Jsi_DecrRefCount(interp, args);\n                if (rc != JSI_OK)\n                    fprintf(stderr, \"bad eval\");\n            }\n        }\n        if (interp->exited)\n            break;\n        jsi_interactiveInterp->interrupted = 0;\n        if (rc == JSI_OK) {\n             if (interp->retValue->vt != JSI_VT_UNDEF || interp->subOpts.outUndef) {\n                Jsi_DString eStr = {};\n                fputs(Jsi_ValueGetDString(interp, interp->retValue, &eStr, hasHelp?0:quote), stdout);\n                Jsi_DSFree(&eStr);\n                fputs(\"\\n\", stdout);\n             }\n        } else if (!interp->exited && !wantHelp) {\n            fputs(\"ERROR\\n\", stderr);\n        }\n        Jsi_DSSetLength(&dStr, 0);\n        len = 0;\n    }\n    interp->level--;\n#ifdef JSI_HAS_READLINE\n    if (hist && !interp->isSafe) {\n        jsi_sh_stifle_history(100);\n        jsi_sh_write_history(hist);\n    }\n    Jsi_DSFree(&dHist);\n    Jsi_DSFree(&sHist);\n#endif\n    Jsi_DSFree(&dStr);\n    if (interp->retValue) {\n        Jsi_DecrRefCount(interp, interp->retValue);\n        interp->retValue = NULL;\n    }\n    if (interp->exited && interp->level <= 0)\n    {\n        rc = JSI_EXIT;\n        Jsi_InterpDelete(interp);\n    }\n    jsi_interactiveInterp = NULL;\n    return rc;\n}\n\nJsi_RC Jsi_ThisDataSet(Jsi_Interp *interp, Jsi_Value *_this, void *value)\n{\n    bool isNew;\n    Jsi_HashEntry *hPtr = Jsi_HashEntryNew(interp->thisTbl, _this, &isNew);\n    if (!hPtr)\n        return JSI_ERROR;\n    Jsi_HashValueSet(hPtr, value);\n    return JSI_OK;\n}\n\nvoid *Jsi_ThisDataGet(Jsi_Interp *interp, Jsi_Value *_this)\n{\n    Jsi_HashEntry *hPtr;\n    hPtr = Jsi_HashEntryFind(interp->thisTbl, _this);\n    if (!hPtr)\n        return NULL;\n    return Jsi_HashValueGet(hPtr);\n}\n\nJsi_RC Jsi_PrototypeDefine(Jsi_Interp *interp, const char *key, Jsi_Value *value)\n{\n    bool isNew;\n    Jsi_HashEntry *hPtr = Jsi_HashEntryNew(interp->protoTbl, key, &isNew);\n    if (!hPtr)\n        return JSI_ERROR;\n    Jsi_HashValueSet(hPtr, value);\n    return JSI_OK;\n}\n\nvoid *Jsi_PrototypeGet(Jsi_Interp *interp, const char *key)\n{\n    Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->protoTbl, key);\n    if (!hPtr)\n        return NULL;\n    return Jsi_HashValueGet(hPtr);\n}\n\nJsi_RC Jsi_PrototypeObjSet(Jsi_Interp *interp, const char *key, Jsi_Obj *obj)\n{\n    Jsi_Value *val;\n    Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->protoTbl, key);\n    if (!hPtr)\n        return JSI_ERROR;\n    val = (Jsi_Value *)Jsi_HashValueGet(hPtr);\n    obj->__proto__ = val;\n    return JSI_OK;\n}\n\nconst char *Jsi_ObjTypeStr(Jsi_Interp *interp, Jsi_Obj *o)\n{\n     switch (o->ot) {\n        case JSI_OT_BOOL: return \"boolean\"; break;\n        case JSI_OT_FUNCTION: return \"function\"; break;\n        case JSI_OT_NUMBER: return \"number\"; break;\n        case JSI_OT_STRING: return \"string\"; break;  \n        case JSI_OT_REGEXP: return \"regexp\"; break;  \n        case JSI_OT_ITER: return \"iter\"; break;  \n        case JSI_OT_OBJECT: if (!o->isarrlist) return \"object\";\n        case JSI_OT_ARRAY: return \"array\"; break;  \n        case JSI_OT_USEROBJ:\n            if (o->__proto__) {\n                Jsi_HashEntry *hPtr;\n                Jsi_HashSearch search;\n                            \n                for (hPtr = Jsi_HashSearchFirst(interp->thisTbl,&search); hPtr != NULL;\n                    hPtr = Jsi_HashSearchNext(&search))\n                    if (Jsi_HashValueGet(hPtr) == o->__proto__)\n                        return (char*)Jsi_HashKeyGet(hPtr);\n            }\n            \n            return \"userobj\";\n            break;\n            //return Jsi_ObjGetType(interp, v->d.obj);\n        default:\n            break;\n     }\n     return \"\";\n}\n\nextern Jsi_otype Jsi_ObjTypeGet(Jsi_Obj *obj)\n{\n    return obj->ot;\n}\n\nconst char *Jsi_ValueTypeStr(Jsi_Interp *interp, Jsi_Value *v)\n{\n    switch (v->vt) {\n        case JSI_VT_BOOL: return \"boolean\"; break;\n        case JSI_VT_UNDEF: return \"undefined\"; break;\n        case JSI_VT_NULL: return \"null\"; break;\n        case JSI_VT_NUMBER: return \"number\"; break;\n        case JSI_VT_STRING: return \"string\"; break;  \n        case JSI_VT_VARIABLE: return \"variable\"; break;  \n        case JSI_VT_OBJECT: return Jsi_ObjTypeStr(interp, v->d.obj);\n    }\n    return \"\";\n}\n\n/* For user defined object  \"name\", invokes \"new\"  with \"arg\" + \"opts\".  Returns userobj data pointer for C use. */\nvoid *Jsi_CommandNewObj(Jsi_Interp *interp, const char *name, const char *arg1, const char *opts, const char *var) {\n    char buf[JSI_BUFSIZ];\n    if (arg1)\n        snprintf(buf, sizeof(buf), \"%s%snew %s('%s', %s);\", var?var:\"\", var?\"=\":\"return \", name, arg1, opts?opts:\"null\");\n    else\n        snprintf(buf, sizeof(buf), \"%s%snew %s(%s);\", var?var:\"\", var?\"=\":\"return \", name, opts?opts:\"null\");\n    int rc = Jsi_EvalString(interp, buf, 0);\n    if (rc != JSI_OK)\n        return NULL;\n    Jsi_Value *vObj = interp->retValue;\n    if (var)\n        vObj = Jsi_NameLookup(interp, var);\n    if (!vObj)\n        return NULL;\n    return Jsi_UserObjGetData(interp, vObj, NULL);\n}\n\n#endif\n\n// List\n\nJsi_List *Jsi_ListNew(Jsi_Interp *interp, Jsi_Wide flags, Jsi_HashDeleteProc *freeProc)\n{\n    Jsi_List *list = (Jsi_List *)Jsi_Calloc(1, sizeof(Jsi_List));\n    list->sig = JSI_SIG_LIST;\n    list->opts.flags = flags;\n    list->opts.freeHashProc = freeProc;\n    list->opts.interp = interp;\n    list->opts.mapType = JSI_MAP_LIST;\n    list->opts.keyType = (Jsi_Key_Type)-1;\n    return list;\n}\n\nJsi_RC Jsi_ListConf(Jsi_List *listPtr, Jsi_MapOpts *opts, bool set)\n{\n    if (set) {\n        listPtr->opts = *opts;\n    } else {\n        *opts = listPtr->opts;\n    }\n    return JSI_OK;\n}\n\nvoid Jsi_ListDelete(Jsi_List *list) {\n    Jsi_ListClear(list);\n    free(list);\n}\n\nvoid Jsi_ListClear(Jsi_List *list) {\n    Jsi_ListEntry *l;\n    while (list->head) {\n        l = list->head;\n        list->head = list->head->next;\n        l->next = l->prev = NULL;\n        if (list->opts.freeListProc && l->value)\n            (list->opts.freeListProc)(list->opts.interp, l, l->value);\n        Jsi_ListEntryDelete(l);\n    }\n    list->numEntries = 0;\n}\n \nJsi_ListEntry* Jsi_ListPush(Jsi_List *list, Jsi_ListEntry *item, Jsi_ListEntry *before)\n{\n    Assert(item && list);\n    if (item->list && (item->list->head == item || item->prev || item->next)) {\n        Assert(list->opts.freeListProc == item->list->opts.freeListProc);\n        Jsi_ListPop(item->list, item);\n    }\n        \n    if (!item->list)\n         item->list = list;\n    else if (list != item->list) {\n        Assert(list->opts.freeListProc == item->list->opts.freeListProc);\n        item->list = list;\n    }\n    if (!list->head) {\n        list->head = list->tail = item;\n    } else if (item == list->head) {\n        assert(0);\n    } else if (before == NULL) {\n        item->prev = list->tail;\n        list->tail->next = item;\n        list->tail = item;\n    } else if (before == list->head) {\n        item->next = list->head;\n        list->head->prev = item;\n        list->head = item;\n    } else {\n        item->next = before;\n        item->prev = before->prev;\n        before->prev->next = item;\n        before->prev = item;\n    }\n    list->numEntries++;\n    item->list = list;\n    return item;\n}\n \nJsi_ListEntry* Jsi_ListPop(Jsi_List *list, Jsi_ListEntry *item)\n{\n    Assert(item && list->head && list->tail && item->list);\n    SIGASSERT(list, LIST);\n    SIGASSERT(item, LISTENTRY);\n    if (item == list->head) {\n        if (list->head == list->tail)\n            list->head = list->tail = NULL;\n        else\n            list->head = list->head->next;\n    }\n    else if (item == list->tail) {\n        list->tail = list->tail->prev;\n        list->tail->next = NULL;\n    } else {\n        item->prev->next = item->next;\n        if (item->next)\n            item->next->prev = item->prev;\n    }\n    list->numEntries--;\n    item->next = item->prev = NULL;\n    return item;\n}\n\nJsi_ListEntry *Jsi_ListEntryNew(Jsi_List* list, const void *value, Jsi_ListEntry *before) {\n    SIGASSERT(list, LIST);\n    Jsi_ListEntry *l = (Jsi_ListEntry*)Jsi_Calloc(1, sizeof(Jsi_ListEntry));\n    l->sig = JSI_SIG_LISTENTRY;\n    l->typ = JSI_MAP_LIST;\n    l->list = list;\n    l->value = (void*)value;\n    Jsi_ListPush(list, l, before);\n    return l;\n}\n\nint Jsi_ListEntryDelete(Jsi_ListEntry *l) {\n    SIGASSERT(l, LISTENTRY);\n    if (l->next || l->prev)\n        Jsi_ListPop(l->list, l);\n    Jsi_Free(l);\n    return 1;\n}\n\nJsi_ListEntry* Jsi_ListSearchFirst (Jsi_List *list, Jsi_ListSearch *searchPtr, int flags)\n{\n    SIGASSERT(list, LIST);\n    searchPtr->flags = flags;\n    Jsi_ListEntry *lptr;\n    if (flags & JSI_LIST_REVERSE) {\n        lptr = Jsi_ListGetBack(list);\n        searchPtr->nextEntryPtr = (lptr?Jsi_ListEntryPrev(lptr):NULL);\n    } else {\n        lptr = Jsi_ListGetFront(list);\n        searchPtr->nextEntryPtr = (lptr?Jsi_ListEntryNext(lptr):NULL);\n    }\n    return lptr;\n}\n\nJsi_ListEntry* Jsi_ListSearchNext (Jsi_ListSearch *searchPtr)\n{\n    Jsi_ListEntry *lptr = searchPtr->nextEntryPtr;\n    searchPtr->nextEntryPtr = (lptr?(searchPtr->flags & JSI_LIST_REVERSE ? Jsi_ListEntryPrev(lptr): Jsi_ListEntryNext(lptr)):NULL);\n    return lptr;\n}\n\n\nuint Jsi_ListSize(Jsi_List *list) {\n    SIGASSERT(list, LIST);\n    return list->numEntries;\n}\n\nvoid* Jsi_ListValueGet(Jsi_ListEntry *l) {\n    SIGASSERT(l, LISTENTRY);\n    return l?l->value:NULL;\n}\nvoid Jsi_ListValueSet(Jsi_ListEntry *l, const void *value) {\n    SIGASSERTV(l, LISTENTRY);\n    l->value = (void*)value;\n}\n\n\n// Map\n\nJsi_Map* Jsi_MapNew (Jsi_Interp *interp, Jsi_Map_Type listType, Jsi_Key_Type keyType, Jsi_MapDeleteProc *freeProc)\n{\n    Jsi_Map *lPtr, lval = {.sig=JSI_SIG_MAP};\n    lval.typ = listType;\n    switch (listType) {\n        case JSI_MAP_HASH: lval.v.hash = Jsi_HashNew(interp, keyType, (Jsi_HashDeleteProc*)freeProc); break;\n        case JSI_MAP_TREE: lval.v.tree = Jsi_TreeNew(interp, keyType, (Jsi_TreeDeleteProc*)freeProc); break;\n        case JSI_MAP_LIST: lval.v.list = Jsi_ListNew(interp, keyType, (Jsi_HashDeleteProc*)freeProc); break;\n        default: return NULL;\n    }\n    if (!lval.v.hash) return NULL;\n    lPtr = (Jsi_Map*)Jsi_Malloc(sizeof(*lPtr));\n    *lPtr = lval;\n    return lPtr;\n}\n\nJsi_RC Jsi_MapConf(Jsi_Map *mapPtr, Jsi_MapOpts *opts, bool set)\n{\n    switch (mapPtr->typ) {\n        case JSI_MAP_HASH: return Jsi_HashConf(mapPtr->v.hash, opts, set);\n        case JSI_MAP_TREE: return Jsi_TreeConf(mapPtr->v.tree, opts, set);\n        case JSI_MAP_LIST: return Jsi_ListConf(mapPtr->v.list, opts, set);\n        case JSI_MAP_NONE: break;\n    }\n    return JSI_ERROR;\n}\n\nvoid Jsi_MapClear (Jsi_Map *mapPtr) {\n    SIGASSERTV(mapPtr, MAP);\n    switch (mapPtr->typ) {\n        case JSI_MAP_HASH: Jsi_HashClear(mapPtr->v.hash); break;\n        case JSI_MAP_TREE: Jsi_TreeClear(mapPtr->v.tree); break;\n        case JSI_MAP_LIST: Jsi_ListClear(mapPtr->v.list); break;\n        default: return;\n    }\n}\n\nvoid Jsi_MapDelete (Jsi_Map *mapPtr) {\n    SIGASSERTV(mapPtr, MAP);\n    switch (mapPtr->typ) {\n        case JSI_MAP_HASH: Jsi_HashDelete(mapPtr->v.hash); break;\n        case JSI_MAP_TREE: Jsi_TreeDelete(mapPtr->v.tree); break;\n        case JSI_MAP_LIST: Jsi_ListDelete(mapPtr->v.list); break;\n        default: return;\n    }\n    Jsi_Free(mapPtr);\n}\nJsi_MapEntry* Jsi_MapSet(Jsi_Map *mapPtr, const void *key, const void *value){\n    SIGASSERT(mapPtr, MAP);\n    Jsi_MapEntry* mptr = NULL;\n    switch (mapPtr->typ) {\n        case JSI_MAP_HASH: mptr = (Jsi_MapEntry*)Jsi_HashSet(mapPtr->v.hash, (void*)key, (void*)value); break;\n        case JSI_MAP_TREE: mptr = (Jsi_MapEntry*)Jsi_TreeSet(mapPtr->v.tree, (void*)key, (void*)value); break;\n        case JSI_MAP_LIST: {\n            mptr = Jsi_MapEntryNew(mapPtr, key, NULL);\n            Jsi_MapValueSet(mptr, (void*)value);\n            break;\n        }\n        case JSI_MAP_NONE: break;\n    }\n    return mptr;\n}\nvoid* Jsi_MapGet(Jsi_Map *mapPtr, const void *key, int flags){\n    SIGASSERT(mapPtr, MAP);\n    switch (mapPtr->typ) {\n        case JSI_MAP_HASH: return Jsi_HashGet(mapPtr->v.hash, (void*)key, flags);\n        case JSI_MAP_TREE: return Jsi_TreeGet(mapPtr->v.tree, (void*)key, flags);\n        case JSI_MAP_LIST: {\n            Jsi_ListEntry* lptr = (key == NULL? Jsi_ListGetFront(mapPtr->v.list) : Jsi_ListGetBack(mapPtr->v.list));\n            if (lptr)\n                return Jsi_ListValueGet(lptr);\n            break;\n        }\n        case JSI_MAP_NONE: break;\n    }\n    return NULL;\n}\nbool Jsi_MapUnset(Jsi_Map *mapPtr, const void *key){\n    SIGASSERT(mapPtr, MAP);\n    switch (mapPtr->typ) {\n        case JSI_MAP_HASH: return Jsi_HashUnset(mapPtr->v.hash, (void*)key);\n        case JSI_MAP_TREE: return Jsi_TreeUnset(mapPtr->v.tree, (void*)key);\n        case JSI_MAP_LIST: {\n            /*Jsi_ListEntry* lptr = (key == NULL? Jsi_ListGetFront(mapPtr->v.list) : Jsi_ListGetBack(mapPtr->v.list));\n            if (lptr)\n                return Jsi_ListUnset(lptr);*/\n            break;\n        }\n        case JSI_MAP_NONE: break;\n    }\n    return false;\n}\nstatic int jsi_GetListType(Jsi_MapEntry *h) {\n    Jsi_HashEntry *hPtr =(Jsi_HashEntry *)h;\n    return hPtr->typ;\n}\nvoid* Jsi_MapKeyGet(Jsi_MapEntry *h, int flags){\n    switch (jsi_GetListType(h)) {\n        case JSI_MAP_HASH: return Jsi_HashKeyGet((Jsi_HashEntry*)h);\n        case JSI_MAP_TREE: return Jsi_TreeKeyGet((Jsi_TreeEntry*)h);\n        case JSI_MAP_LIST: break;\n        case JSI_MAP_NONE: break;\n    }\n    return NULL;\n}\n#ifndef JSI_LITE_ONLY\nJsi_RC Jsi_MapKeysDump(Jsi_Interp *interp, Jsi_Map *mapPtr, Jsi_Value **ret, int flags){\n    SIGASSERT(mapPtr, MAP);\n    switch (mapPtr->typ) {\n        case JSI_MAP_HASH: return Jsi_HashKeysDump(interp, mapPtr->v.hash, ret, flags);\n        case JSI_MAP_TREE: return Jsi_TreeKeysDump(interp, mapPtr->v.tree, ret, flags);\n        case JSI_MAP_LIST: break; // TODO: dump numbers?\n        case JSI_MAP_NONE: break;\n    }\n    return JSI_ERROR;\n}\n#endif\nvoid* Jsi_MapValueGet(Jsi_MapEntry *h){\n    switch (jsi_GetListType(h)) {\n        case JSI_MAP_HASH: return Jsi_HashValueGet((Jsi_HashEntry*)h);\n        case JSI_MAP_TREE: return Jsi_TreeValueGet((Jsi_TreeEntry*)h);\n        case JSI_MAP_LIST: return Jsi_ListValueGet((Jsi_ListEntry*)h);\n        case JSI_MAP_NONE: break;\n    }\n    return NULL;\n}\nvoid Jsi_MapValueSet(Jsi_MapEntry *h, const void *value){\n    switch (jsi_GetListType(h)) {\n        case JSI_MAP_HASH: return Jsi_HashValueSet((Jsi_HashEntry*)h, (void*)value);\n        case JSI_MAP_TREE: return Jsi_TreeValueSet((Jsi_TreeEntry*)h, (void*)value);\n        case JSI_MAP_LIST: return Jsi_ListValueSet((Jsi_ListEntry*)h, (void*)value);\n        case JSI_MAP_NONE: break;\n    }\n}\nJsi_MapEntry* Jsi_MapEntryFind (Jsi_Map *mapPtr, const void *key){\n    SIGASSERT(mapPtr, MAP);\n    switch (mapPtr->typ) {\n        case JSI_MAP_HASH: return (Jsi_MapEntry*)Jsi_HashEntryFind(mapPtr->v.hash, key);\n        case JSI_MAP_TREE: return (Jsi_MapEntry*)Jsi_TreeEntryFind(mapPtr->v.tree, key);\n        case JSI_MAP_LIST:\n            return (Jsi_MapEntry*) (key == NULL? Jsi_ListGetFront(mapPtr->v.list) : Jsi_ListGetBack(mapPtr->v.list));\n        case JSI_MAP_NONE: break;\n    }\n    return NULL;\n}\nJsi_MapEntry* Jsi_MapEntryNew (Jsi_Map *mapPtr, const void *key, bool *isNew){\n    SIGASSERT(mapPtr, MAP);\n    switch (mapPtr->typ) {\n        case JSI_MAP_HASH: return (Jsi_MapEntry*)Jsi_HashEntryNew(mapPtr->v.hash, key, isNew);\n        case JSI_MAP_TREE: return (Jsi_MapEntry*)Jsi_TreeEntryNew(mapPtr->v.tree, key, isNew);\n        case JSI_MAP_LIST: {\n            Jsi_ListEntry *lptr = Jsi_ListEntryNew(mapPtr->v.list, NULL, (key?mapPtr->v.list->head:NULL));\n            if (isNew) *isNew = 1;\n            return (Jsi_MapEntry*)lptr;\n        }\n        break;\n        case JSI_MAP_NONE: break;\n    }\n    return NULL;\n}\nint Jsi_MapEntryDelete (Jsi_MapEntry *entryPtr){\n    switch (jsi_GetListType(entryPtr)) {\n        case JSI_MAP_HASH: return Jsi_HashEntryDelete((Jsi_HashEntry*)entryPtr);\n        case JSI_MAP_TREE: return Jsi_TreeEntryDelete((Jsi_TreeEntry*)entryPtr);\n        case JSI_MAP_LIST: {\n            Jsi_ListEntry *lptr = (Jsi_ListEntry*)entryPtr;\n            Jsi_ListPop(lptr->list, lptr);\n            Jsi_ListEntryDelete(lptr);\n            return 1;\n        }\n    }\n    return JSI_OK;\n}\nJsi_MapEntry* Jsi_MapSearchFirst (Jsi_Map *mapPtr, Jsi_MapSearch *searchPtr, int flags){\n    SIGASSERT(mapPtr, MAP);\n    searchPtr->typ = mapPtr->typ;\n    switch (mapPtr->typ) {\n        case JSI_MAP_HASH: return (Jsi_MapEntry*)Jsi_HashSearchFirst(mapPtr->v.hash, &searchPtr->v.hash);\n        case JSI_MAP_TREE: return (Jsi_MapEntry*)Jsi_TreeSearchFirst(mapPtr->v.tree, &searchPtr->v.tree, flags, NULL);\n        case JSI_MAP_LIST: return (Jsi_MapEntry*)Jsi_ListSearchFirst(mapPtr->v.list, &searchPtr->v.list, flags);\n        case JSI_MAP_NONE: break;\n    }\n    return NULL;\n}\nJsi_MapEntry* Jsi_MapSearchNext (Jsi_MapSearch *searchPtr){\n    switch (searchPtr->typ) {\n        case JSI_MAP_HASH: return (Jsi_MapEntry*)Jsi_HashSearchNext(&searchPtr->v.hash);\n        case JSI_MAP_TREE: return (Jsi_MapEntry*)Jsi_TreeSearchNext(&searchPtr->v.tree);\n        case JSI_MAP_LIST: return (Jsi_MapEntry*)Jsi_ListSearchNext(&searchPtr->v.list);\n        case JSI_MAP_NONE: break;\n    }\n    return NULL;\n}\nvoid Jsi_MapSearchDone (Jsi_MapSearch *searchPtr){\n    switch (searchPtr->typ) {\n        case JSI_MAP_HASH: break;\n        case JSI_MAP_TREE: Jsi_TreeSearchDone(&searchPtr->v.tree); break;\n        case JSI_MAP_LIST: break;\n        case JSI_MAP_NONE: break;\n    }\n}\nuint Jsi_MapSize(Jsi_Map *mapPtr) {\n    SIGASSERT(mapPtr, MAP);\n    switch (mapPtr->typ) {\n        case JSI_MAP_HASH: return Jsi_HashSize(mapPtr->v.hash);\n        case JSI_MAP_TREE: return Jsi_TreeSize(mapPtr->v.tree);\n        case JSI_MAP_LIST: return Jsi_ListSize(mapPtr->v.list);\n        case JSI_MAP_NONE: break;\n    }\n    return -1;\n}\n\n\n#ifndef JSI_OMIT_THREADS\n\n#ifdef __WIN32\n#include <windows.h>\n#else\n#include <pthread.h>\n#endif\n\ntypedef struct Jsi_Mutex {\n    int flags;\n    int lockTimeout;\n    int threadErrCnt;\n#ifdef __WIN32\n    CRITICAL_SECTION mtx;\n#else\n    pthread_mutex_t mtx;\n#endif\n} Jsi_Mutex;\n\n#ifdef __WIN32\n#include <windows.h>\n\nstatic Jsi_RC MutexLock(Jsi_Interp *interp, Jsi_Mutex* mtx) {\n    int timeout = mtx->lockTimeout;\n    if (interp && timeout<0)\n        timeout = interp->lockTimeout;\n    if (timeout<=0)\n        EnterCriticalSection(&mtx->mtx);\n    else {\n        int cnt = timeout;\n        while (cnt-- >= 0) {\n            if (TryEnterCriticalSection(&mtx->mtx))\n                return JSI_OK;\n            usleep(1000);\n        }\n        Jsi_LogError(\"lock timed out\");\n        if (interp)\n            interp->threadErrCnt++;\n        mtx->threadErrCnt++;\n        return JSI_ERROR;\n    }\n    return JSI_OK;\n}\nstatic void MutexUnlock(Jsi_Mutex* mtx) { LeaveCriticalSection(&mtx->mtx); }\nstatic void MutexInit(Jsi_Mutex *mtx) {  InitializeCriticalSection(&mtx->mtx); }\n\nstatic void MutexDone(Jsi_Mutex *mtx) { DeleteCriticalSection(&mtx->mtx); }\n#else /* ! __WIN32 */\n\n#include <pthread.h>\nstatic Jsi_RC MutexLock(Jsi_Interp *interp, Jsi_Mutex *mtx) {\n    int timeout = mtx->lockTimeout;\n    if (interp && timeout<0)\n        timeout = interp->lockTimeout;\n    if (timeout<=0)\n        pthread_mutex_lock(&mtx->mtx);\n    else {\n        struct timespec ts;\n        ts.tv_sec = timeout/1000;\n        ts.tv_nsec = 1000 * (timeout%1000);\n        int rc = pthread_mutex_timedlock(&mtx->mtx, &ts);\n        if (rc != 0) {\n            Jsi_LogError(\"lock timed out\");\n            if (interp)\n                interp->threadErrCnt++;\n            mtx->threadErrCnt++;\n            return JSI_ERROR;\n        }\n    }\n    return JSI_OK;\n}\nstatic void MutexUnlock(Jsi_Mutex *mtx) { pthread_mutex_unlock(&mtx->mtx); }\nstatic void MutexInit(Jsi_Mutex *mtx) {\n    pthread_mutexattr_t Attr;\n    pthread_mutexattr_init(&Attr);\n    if (mtx->flags & JSI_MUTEX_RECURSIVE)\n        pthread_mutexattr_settype(&Attr, PTHREAD_MUTEX_RECURSIVE);\n    pthread_mutex_init(&mtx->mtx, &Attr);\n}\n\nstatic void MutexDone(Jsi_Mutex *mtx) { pthread_mutex_destroy(&mtx->mtx); }\n#endif /* ! __WIN32 */\n\nJsi_RC Jsi_MutexLock(Jsi_Interp *interp, Jsi_Mutex *mtx) { if (interp) interp->lockRefCnt++; return MutexLock(interp, mtx);}\nvoid Jsi_MutexUnlock(Jsi_Interp *interp, Jsi_Mutex *mtx) { MutexUnlock(mtx); if (interp) interp->lockRefCnt--; }\nJsi_Mutex* Jsi_MutexNew(Jsi_Interp *interp, int timeout, int flags) {\n     Jsi_Mutex *mtx = (Jsi_Mutex *)Jsi_Calloc(1,sizeof(Jsi_Mutex));\n     mtx->lockTimeout = timeout;\n     mtx->flags = flags;\n     MutexInit(mtx);\n     return mtx;\n}\nvoid Jsi_MutexDelete(Jsi_Interp *interp, Jsi_Mutex *mtx) { MutexDone(mtx); Jsi_Free(mtx);}\n//void Jsi_MutexInit(Jsi_Interp *interp, Jsi_Mutex *mtx) { MutexInit(mtx); }\nvoid* Jsi_InterpThread(Jsi_Interp *interp) { return interp->threadId; }\nvoid* Jsi_CurrentThread(void) {\n#ifdef __WIN32\n    return (void*)(uintptr_t)GetCurrentThreadId();\n#else\n    return (void*)pthread_self();\n#endif\n}\n\n#else /* ! JSI_OMIT_THREADS */\nJsi_RC Jsi_MutexLock(Jsi_Interp *interp, Jsi_Mutex *mtx) { return JSI_OK; }\nvoid Jsi_MutexUnlock(Jsi_Interp *interp, Jsi_Mutex *mtx) { }\nJsi_Mutex* Jsi_MutexNew(Jsi_Interp *interp, int timeout, int flags) { return NULL; }\nvoid Jsi_MutexDelete(Jsi_Interp *interp, Jsi_Mutex *mtx) { }\nvoid* Jsi_CurrentThread(void) { return NULL; }\nvoid* Jsi_InterpThread(Jsi_Interp *interp) { return NULL; }\n#endif\n\nJsi_Number Jsi_Version(void) {\n    Jsi_Number d = JSI_VERSION;\n    return d;\n}\n\nstatic const char *JsiCharsetMatch(const char *pattern, int c, int flags)\n{\n    int inot = 0;\n    int pchar;\n    int match = 0;\n    int nocase = 0;\n\n    if (flags & JSI_CMP_NOCASE) {\n        nocase++;\n        c = toupper(c);\n    }\n\n    if (flags & JSI_CMP_CHARSET_SCAN) {\n        if (*pattern == '^') {\n            inot++;\n            pattern++;\n        }\n\n        /* Special case. If the first char is ']', it is part of the set */\n        if (*pattern == ']') {\n            goto first;\n        }\n    }\n\n    while (*pattern && *pattern != ']') {\n        /* Exact match */\n        if (pattern[0] == '\\\\') {\nfirst:\n            pattern += Jsi_UtfToUniCharCase(pattern, &pchar, nocase);\n        }\n        else {\n            /* Is this a range? a-z */\n            int start;\n            int end;\n            pattern += Jsi_UtfToUniCharCase(pattern, &start, nocase);\n            if (pattern[0] == '-' && pattern[1]) {\n                /* skip '-' */\n                pattern += Jsi_UtfToUniChar(pattern, &pchar);\n                pattern += Jsi_UtfToUniCharCase(pattern, &end, nocase);\n\n                /* Handle reversed range too */\n                if ((c >= start && c <= end) || (c >= end && c <= start)) {\n                    match = 1;\n                }\n                continue;\n            }\n            pchar = start;\n        }\n\n        if (pchar == c) {\n            match = 1;\n        }\n    }\n    if (inot) {\n        match = !match;\n    }\n\n    return match ? pattern : NULL;\n}\n\n\n/* Split on char, or whitespace if ch==0. */\nstatic void SplitChar(const char *str, int *argcPtr,\n              char ***argvPtr, char ch, Jsi_DString *dStr)\n{\n    char *cp, *ep, *p, **argv;\n    int cnt = 1, len, i;\n\n    len = Jsi_Strlen(str);\n    cp = (char*)str;\n    while (*cp) {\n        if (ch)\n            cp = Jsi_Strchr(cp,ch);\n        else {\n            while (*cp && !isspace(*cp))\n                cp++;\n        }\n        if (cp == NULL || *cp == 0) break;\n        cp++;\n        cnt++;\n    }\n    //argv = (char**)Jsi_Calloc(1,(sizeof(char*)*(cnt+3) + sizeof(char)*(len+6)));\n    Jsi_DSSetLength(dStr, (sizeof(char*)*(cnt+3) + sizeof(char)*(len+6)));\n    argv = (char**)Jsi_DSValue(dStr);\n    *argvPtr = argv;\n    *argcPtr = cnt;\n    p = (char*)&(argv[cnt+2]);\n    argv[cnt+1] = p;\n    Jsi_Strcpy(p, str);\n    cp = p;\n    i = 0;\n    argv[i++] = p;\n    while (*cp) {\n        if (ch)\n            ep = Jsi_Strchr(cp,ch);\n        else {\n            ep = cp;\n            while (*ep && !isspace(*ep))\n                ep++;\n        }\n        if (ep == NULL || *ep == 0) break;\n        *ep = 0;\n        cp = ep+1;\n        argv[i++] = cp;\n    }\n    argv[cnt] = NULL;\n}\n\nJsi_RC\nJsi_GetIndex( Jsi_Interp *interp, const char *str,\n    const char **tablePtr, const char *msg, int flags,\n    int *indexPtr)\n{\n  const char *msg2 = \"unknown \";\n  char **cp, *c;\n  int cond, index = -1, slen, i, dup = 0;\n  int exact = (flags & JSI_CMP_EXACT);\n  int nocase = (flags & JSI_CMP_NOCASE);\n  slen = Jsi_Strlen(str);\n /* if (slen==0) \n        return Jsi_LogError(\"empty option %s %s\", msg, str);*/\n  cp = (char**)tablePtr;\n  i = -1;\n  while (*cp != 0) {\n    i++;\n    c = *cp;\n    if (c[0] != str[0]) { cp++; continue; }\n    if (!nocase)\n        cond = (exact ? Jsi_Strcmp(c,str) : Jsi_Strncmp(c,str,slen));\n    else {\n        cond = (exact ? Jsi_Strncasecmp(c,str, -1) : Jsi_Strncasecmp(c,str,slen));\n    }\n    if (cond == 0) {\n      if (index<0) {\n        index = i;\n      } else {\n        dup = 1;\n        break;\n      }\n    }\n    cp++;\n  }\n  if (index >= 0 && dup == 0) {\n    *indexPtr = index;\n    return JSI_OK;\n  }\n  if (exact && (dup || index<=0)) {\n    if (interp != NULL) {\n      msg2 = (index>=0? \"unknown \":\"duplicate \");\n    }\n    goto err;\n  }\n  cp = (char**)tablePtr;\n  i = -1;\n  dup = 0;\n  index = -1;\n  while (*cp != 0) {\n    i++;\n    c = *cp;\n    if (c[0] == str[0] && Jsi_Strncmp(c,str, slen) == 0) {\n      if (index<0) {\n        index = i;\n        if (slen == (int)Jsi_Strlen(c))\n            break;\n      } else {\n        if (interp != NULL) {\n          msg2 = \"ambiguous \";\n        }\n        goto err;\n      }\n    }\n    cp++;\n  }\n  if (index >= 0 && dup == 0) {\n    *indexPtr = index;\n    return JSI_OK;\n  }\nerr:\n  if (interp != NULL) {\n    Jsi_DString dStr = {};\n    Jsi_DSAppend(&dStr, msg2, msg, \" \\\"\", str, \"\\\" not one of: \", NULL);\n    cp = (char**)tablePtr;\n    while (*cp != 0) {\n      c = *cp;\n      Jsi_DSAppend(&dStr, c, NULL);\n      Jsi_DSAppend(&dStr, \" \", NULL);\n      cp++;\n    }\n    Jsi_LogError(\"%s\", Jsi_DSValue(&dStr));\n    Jsi_DSFree(&dStr);\n  }\n  return JSI_ERROR;\n}\n\nbool Jsi_GlobMatch(const char *pattern, const char *string, int nocase)\n{\n    int c;\n    int pchar;\n    while (*pattern) {\n        switch (pattern[0]) {\n            case '*':\n                while (pattern[1] == '*') {\n                    pattern++;\n                }\n                pattern++;\n                if (!pattern[0]) {\n                    return 1;   /* match */\n                }\n                while (*string) {\n                    if (Jsi_GlobMatch(pattern, string, nocase))\n                        return 1;       /* match */\n                    string += Jsi_UtfToUniChar(string, &c);\n                }\n                return 0;       /* no match */\n\n            case '?':\n                string += Jsi_UtfToUniChar(string, &c);\n                break;\n\n            case '[': {\n                    string += Jsi_UtfToUniChar(string, &c);\n                    pattern = JsiCharsetMatch(pattern + 1, c, nocase ? JSI_CMP_NOCASE : 0);\n                    if (!pattern) {\n                        return 0;\n                    }\n                    if (!*pattern) {\n                        /* Ran out of pattern (no ']') */\n                        continue;\n                    }\n                    break;\n                }\n            case '\\\\':\n                if (pattern[1]) {\n                    pattern++;\n                }\n                /* fall through */\n            default:\n                string += Jsi_UtfToUniCharCase(string, &c, nocase);\n                Jsi_UtfToUniCharCase(pattern, &pchar, nocase);\n                if (pchar != c) {\n                    return 0;\n                }\n                break;\n        }\n        pattern += Jsi_UtfToUniCharCase(pattern, &pchar, nocase);\n        if (!*string) {\n            while (*pattern == '*') {\n                pattern++;\n            }\n            break;\n        }\n    }\n    if (!*pattern && !*string) {\n        return 1;\n    }\n    return 0;\n}\n\nJsi_Stack* Jsi_StackNew(void)\n{\n    Jsi_Stack *stack = (Jsi_Stack*)Jsi_Calloc(1, sizeof(Jsi_Stack));\n    return stack;\n}\n\nvoid Jsi_StackFree(Jsi_Stack *stack)\n{\n    Jsi_Free(stack->vector);\n    Jsi_Free(stack);\n}\n\nint Jsi_StackSize(Jsi_Stack *stack)\n{\n    return stack->len;\n}\n\nvoid Jsi_StackPush(Jsi_Stack *stack, void *element)\n{\n    int neededLen = stack->len + 1;\n\n    if (neededLen > stack->maxlen) {\n        stack->maxlen = neededLen < 20 ? 20 : neededLen * 2;\n        stack->vector = (void**)Jsi_Realloc(stack->vector, sizeof(void *) * stack->maxlen);\n    }\n    stack->vector[stack->len] = element;\n    stack->len++;\n}\n\nvoid *Jsi_StackPop(Jsi_Stack *stack)\n{\n    if (stack->len == 0)\n        return NULL;\n    stack->len--;\n    return stack->vector[stack->len];\n}\n\nvoid *Jsi_StackUnshift(Jsi_Stack *stack)\n{\n    if (stack->len == 0)\n        return NULL;\n    stack->len--;\n    void *rc = stack->vector[0];\n    memmove(stack->vector, stack->vector+1, sizeof(void*)*stack->len);\n    return rc;\n}\n\nvoid *Jsi_StackPeek(Jsi_Stack *stack)\n{\n    if (stack->len == 0)\n        return NULL;\n    return stack->vector[stack->len - 1];\n}\n\nvoid *Jsi_StackHead(Jsi_Stack *stack)\n{\n    if (stack->len == 0)\n        return NULL;\n    return stack->vector[0];\n}\n\nvoid Jsi_StackFreeElements(Jsi_Interp *interp, Jsi_Stack *stack, Jsi_DeleteProc *freeProc)\n{\n    int i;\n    for (i = 0; i < stack->len; i++)\n        freeProc(interp, stack->vector[i]);\n    stack->len = 0;\n}\n\ntypedef struct {\n    void *data;\n    Jsi_DeleteProc *delProc;\n} AssocData;\n\n/* Split on string. */\nvoid Jsi_SplitStr(const char *str, int *argcPtr,\n              char ***argvPtr, const char *ch, Jsi_DString *dStr)\n{\n    char *cp, *ep, *p, **argv;\n    int cnt = 1, len, i, clen;\n    if (!ch)\n        ch = \"\";\n    clen = Jsi_Strlen(ch);\n    if (clen<=0)\n        return SplitChar(str, argcPtr, argvPtr, *ch, dStr);\n    len = Jsi_Strlen(str);\n    cp = (char*)str;\n    while (*cp) {\n        cp = Jsi_Strstr(cp,ch);\n \n        if (cp == NULL || *cp == 0) break;\n        cp += clen;\n        cnt++;\n    }\n    //argv = (char**)Jsi_Calloc(1,(sizeof(char*)*(cnt+3) + sizeof(char)*(len+6)));\n    Jsi_DSSetLength(dStr, (sizeof(char*)*(cnt+3) + sizeof(char)*(len+6)));\n    argv = (char**)Jsi_DSValue(dStr);\n    *argvPtr = argv;\n    *argcPtr = cnt;\n    p = (char*)&(argv[cnt+2]);\n    argv[cnt+1] = p;\n    Jsi_Strcpy(p, str);\n    cp = p;\n    i = 0;\n    argv[i++] = p;\n    while (*cp) {\n        ep = Jsi_Strstr(cp,ch);\n        if (ep == NULL || *ep == 0) break;\n        *ep = 0;\n        cp = ep+clen;\n        argv[i++] = cp;\n    }\n    argv[cnt] = NULL;\n}\n\nstatic Jsi_RC JsiCheckConversion(const char *str, const char *endptr)\n{\n    if (str[0] == '\\0' || str == endptr) {\n        return JSI_ERROR;\n    }\n\n    if (endptr[0] != '\\0') {\n        while (*endptr) {\n            if (!isspace(UCHAR(*endptr))) {\n                return JSI_ERROR;\n            }\n            endptr++;\n        }\n    }\n    return JSI_OK;\n}\n\nstatic int JsiNumberBase(const char *str, int *base, int *sign)\n{\n    int i = 0;\n\n    *base = 10;\n\n    while (isspace(UCHAR(str[i]))) {\n        i++;\n    }\n\n    if (str[i] == '-') {\n        *sign = -1;\n        i++;\n    }\n    else {\n        if (str[i] == '+') {\n            i++;\n        }\n        *sign = 1;\n    }\n\n    if (str[i] != '0') {\n        /* base 10 */\n        return 0;\n    }\n\n    /* We have 0<x>, so see if we can convert it */\n    switch (str[i + 1]) {\n        case 'x': case 'X': *base = 16; break;\n        case 'o': case 'O': *base = 8; break;\n        case 'b': case 'B': *base = 2; break;\n        default: return 0;\n    }\n    i += 2;\n    /* Ensure that (e.g.) 0x-5 fails to parse */\n    if (str[i] != '-' && str[i] != '+' && !isspace(UCHAR(str[i]))) {\n        /* Parse according to this base */\n        return i;\n    }\n    /* Parse as base 10 */\n    return 10;\n}\n\n/* Converts a number as per strtoull(..., 0) except leading zeros do *not*\n * imply octal. Instead, decimal is assumed unless the number begins with 0x, 0o or 0b\n */\nstatic Jsi_Wide jsi_strtoull(const char *str, char **endptr)\n{\n#ifdef JSI__LONG_LONG\n    int sign;\n    int base;\n    int i = JsiNumberBase(str, &base, &sign);\n\n    if (base != 10) {\n        Jsi_Wide value = strtoull(str + i, endptr, base);\n        if (endptr == NULL || *endptr != str + i) {\n            return value * sign;\n        }\n    }\n\n    /* Can just do a regular base-10 conversion */\n    return strtoull(str, endptr, 10);\n#else\n    return (unsigned long)jsi_strtol(str, endptr);\n#endif\n}\n\nstatic Jsi_Wide jsi_strtoul(const char *str, char **endptr)\n{\n#ifdef JSI__LONG_LONG\n    int sign;\n    int base;\n    int i = JsiNumberBase(str, &base, &sign);\n\n    if (base != 10) {\n        Jsi_Wide value = strtoul(str + i, endptr, base);\n        if (endptr == NULL || *endptr != str + i) {\n            return value * sign;\n        }\n    }\n\n    /* Can just do a regular base-10 conversion */\n    return strtoul(str, endptr, 10);\n#else\n    return (unsigned long)jsi_strtol(str, endptr);\n#endif\n}\n\n\nJsi_RC Jsi_GetWide(Jsi_Interp* interp, const char *string, Jsi_Wide *widePtr, int base)\n{\n    char *endptr;\n\n    if (base) {\n        *widePtr = strtoull(string, &endptr, base);\n    }\n    else {\n        *widePtr = jsi_strtoull(string, &endptr);\n    }\n\n    return JsiCheckConversion(string, endptr);\n}\n\nJsi_RC Jsi_GetInt(Jsi_Interp* interp, const char *string, int *n, int base)\n{\n    char *endptr;\n    if (base) {\n        *n = strtoul(string, &endptr, base);\n    }\n    else {\n        *n = (int)jsi_strtoul(string, &endptr);\n    }\n    return JsiCheckConversion(string, endptr);\n}\n\nJsi_RC Jsi_GetDouble(Jsi_Interp* interp, const char *string, Jsi_Number *n)\n{\n    char *endptr;\n\n    /* Callers can check for underflow via ERANGE */\n    errno = 0;\n\n    *n = strtod(string, &endptr);\n\n    return JsiCheckConversion(string, endptr);\n}\n\nJsi_RC Jsi_GetBool(Jsi_Interp* interp, const char *string, bool *n)\n{\n    int len = Jsi_Strlen(string);\n    if (len && (Jsi_Strncasecmp(string, \"true\", len)==0 && len<=4)) {\n        *n = 1;\n        return JSI_OK;\n    }\n    if (len && (Jsi_Strncasecmp(string, \"false\", len)==0 && len<=5)) {\n        *n = 0;\n        return JSI_OK;\n    }\n    return JSI_ERROR;\n}\n\n/* Converts a hex character to its integer value */\nchar jsi_fromHexChar(char ch) {\n    return isdigit(ch) ? ch - '0' : tolower(ch) - 'a' + 10;\n}\n\n/* Converts an integer value to its hex character*/\nchar jsi_toHexChar(char code) {\n    static char hex[] = \"0123456789abcdef\";\n    return hex[code & 15];\n}\n\nvoid jsi_ToHexStr(const uchar *indata, int dlen, char *out) {\n    static char hex[] = \"0123456789abcdef\";\n    int i, n=0;\n    for (i=0; i<dlen; i++) {\n        int c = indata[i];\n        out[n++] = hex[(c>>4)&0xf];\n        out[n++] = hex[c&0xf];\n    }\n    out[n] = 0;\n}\n\nstatic int jsi_FromHexStr(const char *in, uchar *outdata) {\n    int n = 0;\n    while (in[0] && in[1]) {\n        if (!isxdigit(in[0]) || isxdigit(in[0]))\n            return -1;\n        outdata[n++] = jsi_fromHexChar(in[0]) << 4 | jsi_fromHexChar(in[1]);\n        in+=2;\n    }\n    return n;\n}\n\n\nint Jsi_HexStr(const uchar *data, int len, Jsi_DString *dStr, bool decode) {\n    int olen = (decode?(len/2+1):(len*2+1));\n    Jsi_DSSetLength(dStr, olen);\n    if (!decode)\n        return jsi_FromHexStr((const char*)data, (uchar*)Jsi_DSValue(dStr));\n    jsi_ToHexStr((const uchar*)data, len, Jsi_DSValue(dStr));\n    return olen-1;\n}\n#ifndef JSI_LITE_ONLY\n\nvoid *Jsi_InterpGetData(Jsi_Interp *interp, const char *key, Jsi_DeleteProc **proc)\n{\n    Jsi_HashEntry *hPtr;\n    AssocData *ptr;\n    hPtr = Jsi_HashEntryFind(interp->assocTbl, key);\n    if (!hPtr)\n        return NULL;\n    ptr = (AssocData *)Jsi_HashValueGet(hPtr);\n    if (!ptr)\n        return NULL;\n    if (proc)\n        *proc = ptr->delProc;\n    return ptr->data;\n}\nvoid Jsi_InterpSetData(Jsi_Interp *interp, const char *key, void *data, Jsi_DeleteProc *proc)\n{\n    bool isNew;\n    Jsi_HashEntry *hPtr;\n    AssocData *ptr;\n    hPtr = Jsi_HashEntryNew(interp->assocTbl, key, &isNew);\n    if (!hPtr)\n        return;\n    if (isNew) {\n        ptr = (AssocData *)Jsi_Calloc(1,sizeof(*ptr));\n        Jsi_HashValueSet(hPtr, ptr);\n    } else\n        ptr = (AssocData *)Jsi_HashValueGet(hPtr);\n    ptr->data = data;\n    ptr->delProc = proc;\n}\n\nvoid jsi_DelAssocData(Jsi_Interp *interp, void *data) {\n    AssocData *ptr = (AssocData *)data;\n    if (!ptr) return;\n    if (ptr->delProc)\n        ptr->delProc(interp, ptr->data);\n    Jsi_Free(ptr);\n}\n\nJsi_RC Jsi_DeleteData(Jsi_Interp* interp, void *m)\n{\n    Jsi_Free(m);\n    return JSI_OK;\n}\n\nvoid Jsi_InterpFreeData(Jsi_Interp *interp, const char *key)\n{\n    Jsi_HashEntry *hPtr;\n    hPtr = Jsi_HashEntryFind(interp->assocTbl, key);\n    if (!hPtr)\n        return;\n    Jsi_HashEntryDelete(hPtr);\n}\n\nJsi_RC Jsi_GetStringFromValue(Jsi_Interp* interp, Jsi_Value *value, const char **n)\n{\n    if (!value)\n        return JSI_ERROR;\n    if (value->vt == JSI_VT_STRING)\n    {\n        *n = (const char*)value->d.s.str;\n         return JSI_OK;\n    }\n    if (value->vt == JSI_VT_OBJECT && value->d.obj->ot == JSI_OT_STRING) {\n        *n = value->d.obj->d.s.str;\n        return JSI_OK;\n    }\n    Jsi_LogError(\"invalid string\");\n    return JSI_ERROR;\n}\n\nJsi_RC Jsi_GetBoolFromValue(Jsi_Interp* interp, Jsi_Value *value, bool *n)\n{\n    if (!value)\n        return JSI_ERROR;\n\n    if (value->vt == JSI_VT_BOOL) {\n        *n = value->d.val;\n        return JSI_OK;\n    }\n    if (value->vt == JSI_VT_OBJECT && value->d.obj->ot == JSI_OT_BOOL) {\n        *n = value->d.obj->d.val;\n        return JSI_OK;\n    }\n    Jsi_LogError(\"invalid bool\");\n    return JSI_ERROR;\n}\n\n\nJsi_RC Jsi_GetNumberFromValue(Jsi_Interp* interp, Jsi_Value *value, Jsi_Number *n)\n{\n    if (!value)\n        return JSI_ERROR;\n\n    if (value->vt == JSI_VT_NUMBER) {\n        *n = value->d.num;\n        return JSI_OK;\n    }\n    if (value->vt == JSI_VT_OBJECT && value->d.obj->ot == JSI_OT_NUMBER) {\n        *n = value->d.obj->d.num;\n        return JSI_OK;\n    }\n    if (interp)\n        Jsi_LogError(\"invalid number\");\n    return JSI_ERROR;\n}\n\nJsi_RC Jsi_GetIntFromValueBase(Jsi_Interp* interp, Jsi_Value *value, int *n, int base, int flags)\n{\n    int noMsg = (flags & JSI_NO_ERRMSG);\n    /* TODO: inefficient to convert to double then back. */\n    if (!value)\n        return JSI_ERROR;\n    Jsi_Number d = Jsi_ValueToNumberInt(interp, value, 1);\n    if (!Jsi_NumberIsFinite(d))\n    {\n        if (!noMsg)\n            Jsi_LogError(\"invalid number\");\n        return JSI_ERROR;\n    }\n    Jsi_ValueReset(interp,&value);\n    Jsi_ValueMakeNumber(interp, &value, d);\n    *n = (int)d;\n    return JSI_OK;\n}\n\nJsi_RC Jsi_GetIntFromValue(Jsi_Interp* interp, Jsi_Value *value, int *n)\n{\n    if (!Jsi_ValueIsNumber(interp, value)) \n        return Jsi_LogError(\"invalid number\");\n    return Jsi_GetIntFromValueBase(interp, value, n, 0, 0);\n}\n\nJsi_RC Jsi_GetLongFromValue(Jsi_Interp* interp, Jsi_Value *value, long *n)\n{\n    /* TODO: inefficient to convert to double then back. */\n    if (!value)\n        return JSI_ERROR;\n    if (!interp->strict)\n        jsi_ValueToOInt32(interp, value);\n    if (!Jsi_ValueIsNumber(interp, value))\n    \n        return Jsi_LogError(\"invalid number\");\n    *n = (long)(value->vt == JSI_VT_NUMBER ? value->d.num : value->d.obj->d.num);\n    return JSI_OK;\n}\n\nJsi_RC Jsi_GetWideFromValue(Jsi_Interp* interp, Jsi_Value *value, Jsi_Wide *n)\n{\n    if (!value)\n        return JSI_ERROR;\n    if (!interp->strict)\n        jsi_ValueToOInt32(interp, value);\n    if (!Jsi_ValueIsNumber(interp, value))\n    \n        return Jsi_LogError(\"invalid number\");\n    *n = (Jsi_Wide)(value->vt == JSI_VT_NUMBER ? value->d.num : value->d.obj->d.num);\n    return JSI_OK;\n\n}\n\nJsi_RC Jsi_GetDoubleFromValue(Jsi_Interp* interp, Jsi_Value *value, Jsi_Number *n)\n{\n    if (!value)\n        return JSI_ERROR;\n    if (!interp->strict)\n        Jsi_ValueToNumber(interp, value);\n    if (!Jsi_ValueIsNumber(interp, value))\n    \n        return Jsi_LogError(\"invalid number\");\n    *n = (value->vt == JSI_VT_NUMBER ? value->d.num : value->d.obj->d.num);\n    return JSI_OK;\n}\n\nJsi_RC\nJsi_ValueGetIndex( Jsi_Interp *interp, Jsi_Value *valPtr,\n    const char **tablePtr, const char *msg, int flags, int *indexPtr)\n{\n    char *val = Jsi_ValueString(interp, valPtr, NULL);\n    if (val == NULL) \n        return Jsi_LogError(\"expected string\");\n    return Jsi_GetIndex(interp, val, tablePtr, msg, flags, indexPtr);\n}\n\n#endif // JSI_LITE_ONLY\n", "#ifndef JSI_LITE_ONLY\n#ifndef JSI_AMALGAMATION\n#include \"jsiInt.h\"\n#endif\n\n#define bits_set(who, mask)     ((who) |= (mask))\n#define bits_unset(who, mask)   ((who) &= (~(mask)))\n#define bits_get(who, mask)     ((who) & (mask))\n\n#if  JSI__MEMDEBUG\nvoid jsi_VALCHK(Jsi_Value *val) {\n    SIGASSERTV(val,VALUE);\n    assert(val->vt <= JSI_VT__MAX);\n    if (val->vt == JSI_VT_OBJECT)\n        OBJCHK(val->d.obj);\n}\n\nvoid jsi_OBJCHK(Jsi_Obj *obj) {\n    SIGASSERTV(obj,OBJ);\n    assert(obj->ot <= JSI_OT__MAX);\n}\n#endif\n\n/*********************************************/\n\nbool Jsi_IsShared(Jsi_Interp* interp, Jsi_Value *v)\n{\n    SIGASSERT(v,VALUE);\n    return (v->refCnt > 1);\n}\n\nint Jsi_IncrRefCount(Jsi_Interp* interp, Jsi_Value *v)\n{\n    SIGASSERT(v,VALUE);\n    assert(v->refCnt>=0);\n    jsi_DebugValue(v,\"Incr\", jsi_DebugValueCallIdx(), interp);\n    return ++(v->refCnt);\n}\n\nint Jsi_DecrRefCount(Jsi_Interp* interp, Jsi_Value *v) {\n    SIGASSERT(v,VALUE);\n    if (v->refCnt<=0) {\n#ifdef JSI_MEM_DEBUG\n        fprintf(stderr, \"Value decr with ref %d: VD.Idx=%d\\n\", v->refCnt, v->VD.Idx);\n#endif\n        return -2;\n    }\n    int ref;\n    jsi_DebugValue(v,\"Decr\", jsi_DebugValueCallIdx(), interp);\n    if ((ref = --(v->refCnt)) <= 0) {\n        v->refCnt = -1;\n        Jsi_ValueFree(interp, v);\n    }\n    return ref;\n}\n\nstatic Jsi_Value *ValueNew(Jsi_Interp *interp)\n{\n    interp->dbPtr->valueCnt++;\n    interp->dbPtr->valueAllocCnt++;\n    Jsi_Value *v = (Jsi_Value *)Jsi_Calloc(1,sizeof(*v));\n    SIGINIT(v,VALUE)\n    v->vt = JSI_VT_UNDEF;\n    jsi_DebugValue(v,\"New\", jsi_DebugValueCallIdx(), interp);\n    return v;\n}\n\nstatic Jsi_Value *ValueNew1(Jsi_Interp *interp)\n{\n    Jsi_Value *v = ValueNew(interp);\n    Jsi_IncrRefCount(interp, v);\n    return v;\n}\n\nstatic Jsi_Value *ValueDup(Jsi_Interp *interp, Jsi_Value *v)\n{\n    Jsi_Value *r = ValueNew1(interp);\n    Jsi_ValueCopy(interp,r, v);\n#ifdef JSI_MEM_DEBUG\n    r->VD.label2 = \"ValueDup\";\n#endif\n    return r;\n}\n#ifndef JSI_MEM_DEBUG\nJsi_Value* Jsi_ValueNew(Jsi_Interp *interp) {\n    return ValueNew(interp);\n}\nJsi_Value* Jsi_ValueNew1(Jsi_Interp *interp) {\n    return ValueNew1(interp);\n}\nJsi_Value *Jsi_ValueDup(Jsi_Interp *interp, Jsi_Value *v) {\n    return ValueDup(interp, v);\n}\n#else\nstatic uint jsi_memDebugBreakIdx = 0;  // Debug memory by setting this, and adding BP on following func.\nvoid jsi_memDebugBreak() {\n}\n\n// Debugging functions: set breakpoint with \"cond B v == 0xNNN\"\nvoid jsi_DebugValue(Jsi_Value* v, const char *reason, uint cidx, Jsi_Interp *interp)\n{\n    if (jsi_memDebugBreakIdx && jsi_memDebugBreakIdx == v->VD.Idx)\n        jsi_memDebugBreak();\n    return;\n}\nvoid jsi_DebugObj(Jsi_Obj* o, const char *reason, uint cidx, Jsi_Interp *interp)\n{\n    if (jsi_memDebugBreakIdx && jsi_memDebugBreakIdx == o->VD.Idx)\n        jsi_memDebugBreak();\n    return;\n}\n\n\nvoid jsi_ValueDebugUpdate_(Jsi_Interp *interp, jsi_ValueDebug *vd, void *v, Jsi_Hash* tbl, const char *fname, int line, const char *func)\n{\n    vd->fname = fname;\n    vd->line = line;\n    vd->func = func;\n    if (!vd->Idx)\n        vd->Idx = interp->dbPtr->memDebugCallIdx;\n    vd->hPtr = Jsi_HashSet(tbl, v, 0);\n    vd->ip = interp->curIp;\n    if (vd->ip) {\n        vd->ipLine = vd->ip->Line;\n        vd->ipOp = vd->ip->op;\n        vd->ipFname = vd->ip->fname;\n    }\n    vd->interp = interp;\n    if (jsi_memDebugBreakIdx && jsi_memDebugBreakIdx == vd->Idx)\n        jsi_memDebugBreak();\n}\n\nvoid jsi_ValueDebugLabel_(jsi_ValueDebug *vd, const char *l1, const char *l2)\n{\n    if (l1)\n        vd->label = l1;\n    if (l2)\n        vd->label2 = l2;\n}\n\n\nJsi_Value * jsi_ValueNew(Jsi_Interp *interp, const char *fname, int line, const char *func) {\n    Jsi_Value *v = ValueNew(interp);\n    jsi_ValueDebugUpdate(interp, v, valueDebugTbl, fname, line, func);\n    return v;\n}\n\nJsi_Value * jsi_ValueNew1(Jsi_Interp *interp, const char *fname, int line, const char *func) {\n    Jsi_Value *v = ValueNew1(interp);\n    jsi_ValueDebugUpdate(interp, v, valueDebugTbl, fname, line, func);\n    return v;\n}\nJsi_Value * jsi_ValueDup(Jsi_Interp *interp, Jsi_Value *ov, const char *fname, int line, const char *func) {\n    Jsi_Value *v = ValueDup(interp, ov);\n    jsi_ValueDebugUpdate(interp, v, valueDebugTbl, fname, line, func);\n    return v;\n}\n\n#ifndef JSI_OMIT_STUBS\n#undef Jsi_ValueNew\n#undef Jsi_ValueNew1\nJsi_Value *Jsi_ValueNew(Jsi_Interp *interp) { return ValueNew(interp); }\nJsi_Value *Jsi_ValueNew1(Jsi_Interp *interp) { return ValueNew1(interp); }\n#define Jsi_ValueNew(interp) jsi_ValueNew(interp, __FILE__, __LINE__,__PRETTY_FUNCTION__)\n#define Jsi_ValueNew1(interp) jsi_ValueNew1(interp, __FILE__, __LINE__,__PRETTY_FUNCTION__)\n#endif\n\n#endif\n\nJsi_Hash *strDebug = NULL;\n\nstatic void ValueFree(Jsi_Interp *interp, Jsi_Value* v)\n{\n    SIGASSERTV(v,VALUE);\n    //printf(\"FREE: %d\\n\", interp->valueCnt);\n    switch (v->vt) {\n        case JSI_VT_OBJECT:\n            Jsi_ObjDecrRefCount(interp, v->d.obj);\n            break;\n        case JSI_VT_VARIABLE:\n            assert(v->d.lval != v);\n            Jsi_DecrRefCount(interp, v->d.lval);\n            break;\n        case JSI_VT_STRING:\n            if (v->d.s.str && !v->f.bits.isstrkey) {\n                Jsi_Free(v->d.s.str);\n                /*Jsi_HashEntry *hPtr;\n                if ((hPtr = Jsi_HashEntryFind(strDebug, v->d.s.str)))\n                    Jsi_HashEntryDelete(hPtr);*/\n            }\n            break;\n        default:\n            break;\n    }\n    v->vt = JSI_VT_UNDEF;\n}\n\nvoid Jsi_ValueFree(Jsi_Interp *interp, Jsi_Value* v)\n{\n    interp->dbPtr->valueCnt--;\n    jsi_DebugValue(v, \"Free\", jsi_DebugValueCallIdx(), interp);\n    ValueFree(interp, v);\n#ifdef JSI_MEM_DEBUG\n    //if (v->VD.interp != interp)  //TODO: InterpAliasCmd leaking Values.\n     //   fprintf(stderr, \"cross interp delete: %p\\n\", v);\n    if (v->VD.hPtr && !interp->cleanup) {\n        if (!Jsi_HashEntryDelete(v->VD.hPtr))\n            fprintf(stderr, \"Value not in hash\\n\");\n    }\n    memset(v, 0, (sizeof(*v)-sizeof(v->VD)));\n#endif\n    Jsi_Free(v);\n}\n\n/* Reset a value back to undefined, releasing string/obj if necessary. */\nvoid Jsi_ValueReset(Jsi_Interp *interp, Jsi_Value **vPtr) {\n    Jsi_Value *v = *vPtr;\n    SIGASSERTV(v,VALUE);\n    Assert(v->vt <= JSI_VT__MAX);\n    jsi_DebugValue(v, \"Reset\", jsi_DebugValueCallIdx(), interp);\n    Assert(v->refCnt>=0);\n    v->f.bits.lookupfailed = 0; // TODO: rework lookup-fail mechanism.\n    if (v->vt == JSI_VT_UNDEF)\n        return;\n    ValueFree(interp, v);\n    v->f.flag = 0;\n}\n\n// Assign value ptrs (to=from). Decr old to, and Incr from ref count.\nvoid Jsi_ValueReplace(Jsi_Interp *interp, Jsi_Value **to, Jsi_Value *from )  {\n    VALCHK(from);\n    if( *to == from) return;\n    if (*to)\n        Jsi_DecrRefCount(interp, *to);\n    *to = from;\n    if (from)\n        Jsi_IncrRefCount(interp, from);\n}\n\n\nstatic void jsi_ValueCopyMove(Jsi_Interp *interp, Jsi_Value *to, Jsi_Value *from, int isCopy )  {\n    if (!from) {\n        Jsi_ValueMakeUndef(interp, &to);\n        return;\n    }\n    VALCHK(from);\n    if( to == from) return;\n    int ocnt = to->refCnt;\n    Jsi_Value *ovt = NULL;\n    assert(ocnt>0);\n    int toVt = to->vt;\n    if (toVt == JSI_VT_VARIABLE) {\n        ovt = to->d.lval;\n        Jsi_IncrRefCount(interp, ovt);\n    }\n    Jsi_ValueMakeUndef(interp, &to);\n#ifdef JSI_MEM_DEBUG\n    memcpy(to, from, sizeof(*to)-sizeof(to->VD));\n    to->VD.label3 = from->VD.func;\n#else\n    *to = *from;\n#endif\n    if (isCopy) {\n        if (to->refCnt) {\n            switch (to->vt) {\n                case JSI_VT_STRING:\n                    if (!to->f.bits.isstrkey) {\n                        to->d.s.str = Jsi_StrdupLen(to->d.s.str, to->d.s.len);\n                    }\n                    break;\n                case JSI_VT_OBJECT:\n                    Jsi_ObjIncrRefCount(interp,to->d.obj);\n                    break;\n                case JSI_VT_VARIABLE:\n                    Jsi_IncrRefCount(interp,to->d.lval);\n                    break;\n                default:\n                    break;\n            }\n        }\n        to->refCnt = ocnt;\n        if (ovt)\n            Jsi_DecrRefCount(interp, ovt);\n    } else {\n        to->refCnt = ocnt;\n        if (ovt)\n            Jsi_DecrRefCount(interp, ovt);\n        ocnt = from->refCnt;\n#ifdef JSI_MEM_DEBUG\n        memset(from, 0, sizeof(*to)-sizeof(to->VD));\n#else\n        memset(from, 0, sizeof(*to));\n#endif\n        SIGINIT(from, VALUE);\n        from->refCnt = ocnt;\n    }\n}\n\nvoid Jsi_ValueMove(Jsi_Interp *interp, Jsi_Value *to, Jsi_Value *from )  {\n    return jsi_ValueCopyMove(interp, to, from, 0);\n}\n\nvoid Jsi_ValueCopy(Jsi_Interp *interp, Jsi_Value *to, Jsi_Value *from ) {\n    return jsi_ValueCopyMove(interp, to, from, 1);\n}\n\nvoid Jsi_ValueDup2(Jsi_Interp *interp, Jsi_Value **to, Jsi_Value *from )\n{\n    if (!*to)\n        *to = Jsi_ValueNew1(interp);\n#ifdef JSI_MEM_DEBUG\n    (*to)->VD.label3 = \"ValueDup2\";\n#endif\n    Jsi_ValueCopy(interp, *to, from);\n    (*to)->f.bits.readonly = 0;\n}\n\nJsi_Value *Jsi_ValueDupJSON(Jsi_Interp *interp, Jsi_Value *val)\n{\n    Jsi_DString pStr;\n    Jsi_DSInit(&pStr);\n    Jsi_ValueGetDString(interp, val, &pStr, JSI_OUTPUT_JSON);\n    Jsi_Value *valPtr = NULL;\n    if (Jsi_JSONParse(interp, Jsi_DSValue(&pStr), &valPtr, 0) != JSI_OK)\n        Jsi_LogBug(\"bad json parse\");\n    Jsi_DSFree(&pStr);\n    return valPtr;\n}\n\n#if 0\nvoid jsi_AllValueOp(Jsi_Interp *interp, Jsi_Value* val, int op) {\n    if (op==1) {\n        //printf(\"ADD: %p : %p : %d\\n\", interp, val, val->VD.Idx);\n        assert(interp->allValues!=val);\n        val->next = interp->allValues;\n        if (interp->allValues)\n            interp->allValues->prev = val;\n        interp->allValues = val;\n        return;\n    }\n    if (op==0) {\n        //printf(\"DEL: %p : %p\\n\", interp, val);\n        if (!val || !interp->allValues) return;\n        if (val == interp->allValues)\n            interp->allValues = val->next;\n        if (val->next)\n            val->next->prev = val->prev;\n        if (val->prev)  \n            val->prev->next = val->next; \n        return;\n    }\n    if (op == -1) {\n        while (interp->allValues) {\n            printf(\"NEED CLEANUP: %p\\n\", interp->allValues);\n            Jsi_ValueFree(interp, interp->allValues);\n        }\n        return;\n    }\n#if JSI__MEMDEBUG\n    assert(0);\n    abort();\n#endif\n}\n#endif\n\nJsi_Value *Jsi_ValueObjLookup(Jsi_Interp *interp, Jsi_Value *target, const char *key, int isstrkey)\n{\n    Jsi_Obj *obj;\n    Jsi_Value *v = NULL;\n    if (interp->subOpts.noproto && key) {\n        if (key[0] == 'p' && Jsi_Strcmp(key, \"prototype\")==0) {\n            Jsi_LogError(\"inheritance is disabled in interp\");\n            return NULL;\n        }\n    }\n    if (target->vt != JSI_VT_OBJECT) {\n        if (interp->strict)\n            Jsi_LogWarn(\"Target is not object: %d\", target->vt);\n        return NULL;\n    }\n    obj = target->d.obj;\n    \n#if (defined(JSI_HAS___PROTO__) && JSI_HAS___PROTO__==2)\n    if (*key == '_' && Jsi_Strcmp(key, \"__proto__\")==0 && interp->noproto==0)\n        return obj->__proto__;\n#endif\n\n    if (*key == 't' && Jsi_Strcmp(key, \"this\")==0)\n        return interp->framePtr->inthis;\n    if (obj->arr)\n        v = jsi_ObjArrayLookup(interp, obj, key);\n    if (!v)\n        v= Jsi_TreeObjGetValue(obj, key, isstrkey);\n    return v;  /* TODO: redo with copy */\n}\n\nJsi_Value *Jsi_ValueArrayIndex(Jsi_Interp *interp, Jsi_Value *args, int index)\n{\n    Jsi_Obj *obj = args->d.obj;\n    Jsi_Value *v;\n    assert(args->vt == JSI_VT_OBJECT);\n    if (obj->isarrlist && obj->arr)\n        return ((index < 0 || (uint)index >= obj->arrCnt) ? NULL : obj->arr[index]);\n    char unibuf[JSI_MAX_NUMBER_STRING];\n    Jsi_NumberItoA10(index, unibuf, sizeof(unibuf));\n    v = Jsi_TreeObjGetValue(args->d.obj, unibuf, 0);\n    return v;\n}\n\n/**************************************************/\n\nJsi_RC Jsi_ValueGetBoolean(Jsi_Interp *interp, Jsi_Value *pv, bool *val)\n{\n    if (!pv) return JSI_ERROR;\n    if (pv->vt == JSI_VT_BOOL)\n        *val = pv->d.val;\n    else if (pv->vt == JSI_VT_OBJECT && pv->d.obj->ot == JSI_OT_BOOL)\n        *val = pv->d.obj->d.val;\n    else \n        return JSI_ERROR;\n    return JSI_OK;\n}\n\nbool Jsi_ValueIsArray(Jsi_Interp *interp, Jsi_Value *v)  {\n    return (v->vt == JSI_VT_OBJECT && v->d.obj->ot == JSI_OT_OBJECT && v->d.obj->isarrlist);\n}\n\nbool Jsi_ValueIsBoolean(Jsi_Interp *interp, Jsi_Value *pv)\n{\n    return (pv->vt == JSI_VT_BOOL || (pv->vt == JSI_VT_OBJECT && pv->d.obj->ot == JSI_OT_BOOL));\n}\n\nbool Jsi_ValueIsNull(Jsi_Interp *interp, Jsi_Value *pv)\n{\n    return (pv->vt == JSI_VT_NULL);\n}\n\nbool Jsi_ValueIsUndef(Jsi_Interp *interp, Jsi_Value *pv)\n{\n    return (pv->vt == JSI_VT_UNDEF);\n}\n\nJsi_RC Jsi_ValueGetNumber(Jsi_Interp *interp, Jsi_Value *pv, Jsi_Number *val)\n{\n    if (!pv) return JSI_ERROR;\n    if (pv->vt == JSI_VT_NUMBER)\n        *val = pv->d.num;\n    else if (pv->vt == JSI_VT_OBJECT && pv->d.obj->ot == JSI_OT_NUMBER)\n        *val = pv->d.obj->d.num;\n    else \n        return JSI_ERROR;\n    return JSI_OK;\n}\nbool Jsi_ValueIsNumber(Jsi_Interp *interp, Jsi_Value *pv)\n{\n    return (pv->vt == JSI_VT_NUMBER || (pv->vt == JSI_VT_OBJECT && pv->d.obj->ot == JSI_OT_NUMBER));\n}\n\nbool Jsi_ValueIsStringKey(Jsi_Interp* interp, Jsi_Value *key)\n{\n    if (key->vt == JSI_VT_STRING && key->f.bits.isstrkey)\n        return 1;\n    if (key->vt == JSI_VT_OBJECT && key->d.obj->ot == JSI_OT_STRING && key->d.obj->isstrkey)\n        return 1;\n    return 0;\n}\n\nbool Jsi_ValueIsString(Jsi_Interp *interp, Jsi_Value *pv)\n{\n    return (pv->vt == JSI_VT_STRING || (pv->vt == JSI_VT_OBJECT && pv->d.obj->ot == JSI_OT_STRING));\n}\n\nbool Jsi_ValueIsFunction(Jsi_Interp *interp, Jsi_Value *v)\n{\n    int rc = (v!=NULL && v->vt == JSI_VT_OBJECT && v->d.obj->ot == JSI_OT_FUNCTION);\n    if (!rc) return rc;\n    if (interp == v->d.obj->d.fobj->interp)\n        return 1;\n    fprintf(stderr, \"OOPS: function in wrong interp %s: %s\\n\", \n        interp->parent?\"(string came in from parent interp?)\":\"\",\n        v->d.obj->d.fobj->func->name);\n    return 0;\n}\n\nbool Jsi_ValueIsType(Jsi_Interp *interp, Jsi_Value *pv, Jsi_vtype vtype) {\n    if (!pv) return 0;\n    return pv->vt == vtype;\n}\n\nJsi_vtype Jsi_ValueTypeGet(Jsi_Value *pv) { return pv->vt; }\n\n\nbool Jsi_ValueIsObjType(Jsi_Interp *interp, Jsi_Value *v, Jsi_otype otype)\n{\n    if (v == NULL || v->vt != JSI_VT_OBJECT)\n        return 0;\n    if (otype != JSI_OT_ARRAY)\n        return (v->d.obj->ot == otype);\n    if (v->d.obj->ot != JSI_OT_OBJECT || !v->d.obj->isarrlist)\n        return 0;\n    return 1;\n}\n\nchar* Jsi_NumberToString(Jsi_Interp *interp, Jsi_Number d, char *buf, int bsiz)\n{\n     if (Jsi_NumberIsInteger(d)) {\n        Jsi_NumberItoA10((Jsi_Wide)d, buf, bsiz);\n    } else if (Jsi_NumberIsNormal(d)) {\n        Jsi_NumberDtoA(interp, d, buf, bsiz, 0);\n    } else if (Jsi_NumberIsNaN(d)) {\n        Jsi_Strcpy(buf, \"NaN\");\n    } else {\n        int s = Jsi_NumberIsInfinity(d);\n        if (s > 0) Jsi_Strcpy(buf,  \"Infinity\");\n        else if (s < 0) Jsi_Strcpy(buf, \"-Infinity\");\n        else {\n            buf[0] = 0;\n        }\n    }\n    return buf;\n}\n\n/* Return the string value.  Coerce value to a string type. */\nconst char* Jsi_ValueToString(Jsi_Interp *interp, Jsi_Value *v, int *lenPtr)\n{\n    Jsi_Number d;\n    const char *ntxt = \"undefined\";\n    int kflag = 1;\n    int isKey = 0;\n    char *key = NULL;\n    if (!v)\n        goto done;\n    if (lenPtr) *lenPtr = 0;\n    char unibuf[JSI_MAX_NUMBER_STRING*2];\n    switch(v->vt) {\n        case JSI_VT_STRING:\n            ntxt = v->d.s.str;\n            goto done;\n        case JSI_VT_UNDEF:\n            break;\n        case JSI_VT_BOOL:\n            ntxt = v->d.val ? \"true\":\"false\";\n            break;\n        case JSI_VT_NULL:\n            ntxt = \"null\";\n            break;\n        case JSI_VT_NUMBER: {\n            d = v->d.num;\nfmtnum:\n            if (Jsi_NumberIsInteger(d)) {\n                Jsi_NumberItoA10((Jsi_Wide)d, unibuf, sizeof(unibuf));\n                kflag = 0;\n                ntxt = unibuf;\n            } else if (Jsi_NumberIsNormal(d)) {\n                Jsi_NumberDtoA(interp, d, unibuf, sizeof(unibuf), 0);\n                kflag = 0;\n                ntxt = unibuf;\n            } else if (Jsi_NumberIsNaN(v->d.num)) {\n                ntxt = \"NaN\";\n            } else {\n                int s = Jsi_NumberIsInfinity(d);\n                if (s > 0) ntxt = \"Infinity\";\n                else if (s < 0) ntxt = \"-Infinity\";\n                else Jsi_LogBug(\"Ieee function got problem\");\n            }\n            break;\n        }\n        case JSI_VT_OBJECT: {\n            Jsi_Obj *obj = v->d.obj;\n            switch(obj->ot) {\n                case JSI_OT_STRING:\n                    ntxt = obj->d.s.str;\n                    goto done;\n                case JSI_OT_BOOL:\n                    ntxt = obj->d.val ? \"true\":\"false\";\n                    break;\n                case JSI_OT_NUMBER:\n                    d = obj->d.num;\n                    goto fmtnum;\n                    break;\n                default:\n                    ntxt = \"[object Object]\";\n                    break;\n            }\n            break;\n        }\n        default:\n            Jsi_LogBug(\"Convert a unknown type: 0x%x to string\", v->vt);\n            break;\n    }\n    Jsi_ValueReset(interp, &v);\n    if (!kflag) {\n        Jsi_ValueMakeStringDup(interp, &v, ntxt);\n        return Jsi_ValueString(interp, v, lenPtr);\n    }\n    \n    key = jsi_KeyFind(interp, ntxt, 0, &isKey);\n    if (key)\n        Jsi_ValueMakeStringKey(interp, &v, key);\n    else\n        Jsi_ValueMakeString(interp, &v, ntxt);\n    ntxt = v->d.s.str;\n    \ndone:\n    if (lenPtr) *lenPtr = Jsi_Strlen(ntxt);\n    return ntxt;\n}\n\nJsi_Number Jsi_ValueToNumberInt(Jsi_Interp *interp, Jsi_Value *v, int isInt)\n{\n    char *endPtr = NULL, *sptr;\n    Jsi_Number a = 0;\n    switch(v->vt) {\n        case JSI_VT_BOOL:\n            a = (Jsi_Number)(v->d.val ? 1.0: 0);\n            break;\n        case JSI_VT_NULL:\n            a = 0;\n            break;\n        case JSI_VT_OBJECT: {\n            Jsi_Obj *obj = v->d.obj;\n            switch(obj->ot) {\n                case JSI_OT_BOOL:\n                    a = (Jsi_Number)(obj->d.val ? 1.0: 0);\n                    break;\n                case JSI_OT_NUMBER:\n                    a = obj->d.num;\n                    break;\n                case JSI_OT_STRING:\n                    sptr = obj->d.s.str;\n                    goto donum;\n                    break;\n                default:\n                    a = 0;\n                break;\n            }\n            break;\n        }\n        case JSI_VT_UNDEF:\n            a = Jsi_NumberNaN();\n            break;\n        case JSI_VT_NUMBER:\n            a = v->d.num;\n            break;\n        case JSI_VT_STRING:\n            sptr = v->d.s.str;\ndonum:\n            if (!isInt) {\n                a = strtod(sptr, &endPtr);\n                if (endPtr && *endPtr) {\n                    a = interp->NaNValue->d.num;\n                }\n            } else {\n                a = (Jsi_Number)strtol(sptr, &endPtr, 0);\n                if (!isdigit(*sptr))\n                    a = interp->NaNValue->d.num;\n            }\n            break;\n        default:\n            Jsi_LogBug(\"Convert a unknown type: 0x%x to number\", v->vt);\n            break;\n    }\n    if (isInt && Jsi_NumberIsNormal(a))\n        a = (Jsi_Number)((int64_t)(a));\n    return a;\n}\n\nJsi_RC Jsi_ValueToNumber(Jsi_Interp *interp, Jsi_Value *v)\n{\n    if (v->vt == JSI_VT_NUMBER) return JSI_OK;\n    Jsi_Number a = Jsi_ValueToNumberInt(interp, v, 0);\n    Jsi_ValueReset(interp, &v);\n    Jsi_ValueMakeNumber(interp, &v, a);\n    return JSI_OK;\n}\n\nJsi_RC Jsi_ValueToBool(Jsi_Interp *interp, Jsi_Value *v)\n{\n    Jsi_RC rc = JSI_OK;\n    bool a = 0;\n    switch(v->vt) {\n        case JSI_VT_BOOL:\n            a = v->d.val;\n            break;\n        case JSI_VT_NULL:\n            break;\n        case JSI_VT_UNDEF:\n            break;\n        case JSI_VT_NUMBER:\n            a = (v->d.num ? 1: 0);\n            break;\n        case JSI_VT_STRING:     /* TODO: NaN, and accept true/false string? */\n            a = atoi(v->d.s.str);\n            a = (a ? 1 : 0);\n            break;\n        case JSI_VT_OBJECT: {\n            Jsi_Obj *obj = v->d.obj;\n            switch(obj->ot) {\n                case JSI_OT_BOOL:\n                    a = (obj->d.val ? 1.0: 0);\n                    break;\n                case JSI_OT_NUMBER:\n                    a = obj->d.num;\n                    a = (a ? 1 : 0);\n                    break;\n                case JSI_OT_STRING:\n                    a = atoi(obj->d.s.str);\n                    a = (a ? 1 : 0);\n                    break;\n                default:\n                    break;\n            }\n            break;\n        }\n        default:\n            Jsi_LogBug(\"Convert a unknown type: 0x%x to number\", v->vt);\n            return JSI_ERROR;\n    }\n    Jsi_ValueReset(interp,&v);\n    Jsi_ValueMakeBool(interp, &v, a);\n    return rc;\n}\n\nint jsi_ValueToOInt32(Jsi_Interp *interp, Jsi_Value *v)\n{\n    Jsi_Number a = Jsi_ValueToNumberInt(interp, v, 1);\n    Jsi_ValueReset(interp,&v);\n    Jsi_ValueMakeNumber(interp, &v, a);\n    return (int)a;\n}\n\nJsi_RC Jsi_ValueToObject(Jsi_Interp *interp, Jsi_Value *v)\n{\n    Jsi_RC rc = JSI_OK;\n    if (v->vt == JSI_VT_OBJECT) return rc;\n    Jsi_Obj *o = Jsi_ObjNew(interp);\n    switch(v->vt) {\n        case JSI_VT_UNDEF:\n        case JSI_VT_NULL:\n            if (interp->strict) {\n                Jsi_LogError(\"converting a undefined/null value to object\");\n                rc = JSI_ERROR;\n            }\n            o->d.num = 0;\n            o->ot = JSI_OT_NUMBER;\n            o->__proto__ = interp->Number_prototype;\n            break;\n        case JSI_VT_BOOL: {\n            o->d.val = v->d.val;\n            o->ot = JSI_OT_BOOL;\n            o->__proto__ = interp->Boolean_prototype;\n            break;\n        }\n        case JSI_VT_NUMBER: {\n            o->d.num = v->d.num;\n            o->ot = JSI_OT_NUMBER;\n            o->__proto__ = interp->Number_prototype;\n            break;\n        }\n        case JSI_VT_STRING: {\n            o->d.s = v->d.s;\n            if (!v->f.bits.isstrkey)\n                o->d.s.str = (char*)Jsi_KeyAdd(interp, v->d.s.str);\n            o->isstrkey = 1;\n            o->ot = JSI_OT_STRING;\n            o->__proto__ = interp->String_prototype;\n            break;\n        }\n        default:\n            Jsi_LogBug(\"toobject, not suppose to reach here\");\n    }\n    Jsi_ValueReset(interp,&v);\n    Jsi_ValueMakeObject(interp, &v, o);\n    return rc;\n}\n\n/* also toBoolean here, in ecma */\nbool Jsi_ValueIsTrue(Jsi_Interp *interp, Jsi_Value *v)\n{\n    switch(v->vt) {\n        case JSI_VT_UNDEF:\n        case JSI_VT_NULL:   return 0;\n        case JSI_VT_BOOL:   return v->d.val ? 1:0;\n        case JSI_VT_NUMBER: \n            if (v->d.num == 0.0 || Jsi_NumberIsNaN(v->d.num)) return 0;\n            return 1;\n        case JSI_VT_STRING: return (Jsi_ValueStrlen(v)!=0);\n        case JSI_VT_OBJECT: {\n            Jsi_Obj *o = v->d.obj;\n            if (o->ot == JSI_OT_STRING)\n                return (Jsi_ValueStrlen(v)!=0);\n            if (o->ot == JSI_OT_NUMBER)\n                return (o->d.num != 0);\n            if (o->ot == JSI_OT_BOOL)\n                return (o->d.val != 0);\n            if (o->ot == JSI_OT_USEROBJ && o->d.uobj->interp == interp) {\n                return jsi_UserObjIsTrue(interp, o->d.uobj);\n            }\n            return 1;\n        }\n        default: Jsi_LogBug(\"TOP is type incorrect: %d\", v->vt);\n    }\n    return 0;\n}\n\nbool Jsi_ValueIsFalse(Jsi_Interp *interp, Jsi_Value *v)\n{\n    if (v->vt == JSI_VT_BOOL)  return v->d.val ? 0:1;\n    return 0;\n}\n\nbool Jsi_ValueIsEqual(Jsi_Interp* interp, Jsi_Value* v1, Jsi_Value* v2)\n{\n    int eq = 0;\n    if (v1->vt == JSI_VT_OBJECT && v2->vt == JSI_VT_OBJECT && v1->d.obj == v2->d.obj)\n        eq = 1;\n    else if (Jsi_ValueIsNull(interp, v1) && Jsi_ValueIsNull(interp, v2))\n        eq = 1;\n    else if (Jsi_ValueIsUndef(interp, v1) && Jsi_ValueIsUndef(interp, v2))\n        eq = 1;\n    else if (Jsi_ValueIsBoolean(interp, v1) && Jsi_ValueIsBoolean(interp, v2)) {\n        bool b1, b2;\n        eq = (Jsi_GetBoolFromValue(interp, v1, &b1) == JSI_OK\n            && Jsi_GetBoolFromValue(interp, v2, &b2) == JSI_OK\n            && b1 == b2);\n    } else if (Jsi_ValueIsNumber(interp, v1) && Jsi_ValueIsNumber(interp, v2)) {\n        Jsi_Number n1, n2;\n        eq = (Jsi_GetNumberFromValue(interp, v1, &n1) == JSI_OK\n            && Jsi_GetNumberFromValue(interp, v2, &n2) == JSI_OK\n            && n1 == n2);\n    } else if (Jsi_ValueIsString(interp, v1) && Jsi_ValueIsString(interp, v2)) {\n        const char *s1, *s2;\n        int l1, l2;\n        eq = (((s1=Jsi_ValueString(interp, v1, &l1)) && ((s2=Jsi_ValueString(interp, v2, &l2)))\n            && l1 == l2 && Jsi_Strcmp(s1, s2)==0));\n    }\n    return eq;\n}\n\nvoid jsi_ValueToPrimitive(Jsi_Interp *interp, Jsi_Value **vPtr)\n{\n    Jsi_Value *v = *vPtr;\n    if (v->vt != JSI_VT_OBJECT)\n        return;\n    DECL_VALINIT(res);\n    Jsi_Value *rPtr = &res;\n    Jsi_Obj *obj = v->d.obj;\n    //rPtr = v;\n    switch(obj->ot) {\n        case JSI_OT_BOOL:\n            Jsi_ValueMakeBool(interp,&rPtr, obj->d.val);\n            break;\n        case JSI_OT_NUMBER:\n            Jsi_ValueMakeNumber(interp,&rPtr, obj->d.num);\n            break;\n        case JSI_OT_STRING:\n            if (obj->isstrkey) {\n                res.d.s = obj->d.s;\n                res.f.bits.isstrkey = 1;\n                obj->d.s.str = NULL;\n            } else {\n                if (obj->refcnt==1) {\n                    Jsi_ValueMakeString(interp, &rPtr, obj->d.s.str);\n                    res.d.s = obj->d.s;\n                    obj->d.s.str = NULL;\n                } else if (obj->d.s.len >= 0) \n                {\n                    Assert(obj->refcnt>=1);\n                    obj->refcnt--;\n                    int bytes = obj->d.s.len;\n                    jsi_ValueMakeBlobDup(interp, &rPtr, (uchar*)obj->d.s.str, bytes);\n                } else\n                    Jsi_ValueMakeStringDup(interp, &rPtr, obj->d.s.str);\n            }\n            break;\n        case JSI_OT_FUNCTION: {\n            Jsi_DString dStr;\n            Jsi_DSInit(&dStr);\n            Jsi_FuncObjToString(interp, obj->d.fobj->func, &dStr, 3);\n            Jsi_ValueFromDS(interp, &dStr, &rPtr);\n            break;\n        }\n        case JSI_OT_USEROBJ: {\n            Jsi_DString dStr;\n            Jsi_DSInit(&dStr);\n            jsi_UserObjToName(interp, obj->d.uobj, &dStr);\n            Jsi_ValueFromDS(interp, &dStr, &rPtr);\n            break;\n        }\n        default:\n            Jsi_ValueMakeStringKey(interp,&rPtr, \"[object Object]\");\n            break;\n    }\n    Jsi_ValueReset(interp, vPtr);\n    res.refCnt = v->refCnt;\n#ifdef JSI_MEM_DEBUG\n    memcpy(v, &res, sizeof(res)-sizeof(res.VD));\n#else\n    *v = res;\n#endif\n}\n\nstatic void jsi_ValueToPrimitiveRes(Jsi_Interp *interp, Jsi_Value *v, Jsi_Value *rPtr)\n{\n    if (v->vt != JSI_VT_OBJECT) {\n#ifdef JSI_MEM_DEBUG\n    memcpy(rPtr, v, sizeof(*v)-sizeof(v->VD));\n#else\n    *rPtr = *v; //TODO: usde only by ValueCompare, so refCnt doesn't matter?\n#endif\n        return;\n    }\n    Jsi_Obj *obj = v->d.obj;\n    switch(obj->ot) {\n        case JSI_OT_BOOL:\n            Jsi_ValueMakeBool(interp, &rPtr, obj->d.val);\n            break;\n        case JSI_OT_NUMBER:\n            Jsi_ValueMakeNumber(interp, &rPtr, obj->d.num);\n            break;\n        case JSI_OT_STRING:\n            rPtr->vt = JSI_VT_STRING;\n            rPtr->d.s = obj->d.s;\n            rPtr->f.bits.isstrkey = 1;\n            break;\n        default:\n            break;\n    }\n}\n\nint Jsi_ValueCmp(Jsi_Interp *interp, Jsi_Value *v1, Jsi_Value* v2, int flags)\n{\n    DECL_VALINIT(res1);\n    DECL_VALINIT(res2);\n    int r = 1;\n    int nocase = (flags&JSI_SORT_NOCASE), dict = ((flags & JSI_SORT_DICT));\n    if (v1 == v2)\n        return 1;\n    if (v1->vt != v2->vt) {\n        jsi_ValueToPrimitiveRes(interp, v1, &res1);\n        jsi_ValueToPrimitiveRes(interp, v2, &res2);\n        v1 = &res1;\n        v2 = &res2;\n    }\n    if (v1->vt != v2->vt) {\n        if ((flags&JSI_CMP_EXACT))\n            return 1;\n        if ((v1->vt == JSI_VT_UNDEF || v1->vt == JSI_VT_NULL) && \n            (v2->vt == JSI_VT_UNDEF || v2->vt == JSI_VT_NULL)) {\n            r = 0;\n        } else {\n            Jsi_Number n1, n2;\n            n1 = Jsi_ValueToNumberInt(interp, v1, 0);\n            n2 = Jsi_ValueToNumberInt(interp, v2, 0);\n            r = (n2 - n1);\n        }\n    } else {\n        switch (v1->vt) {\n            case JSI_VT_NUMBER:\n                if (v2->d.num == v1->d.num) return 0;\n                r = (v2->d.num < v1->d.num ? -1 : 1);\n                break;\n            case JSI_VT_BOOL:\n                r = (v2->d.val - v1->d.val);\n                break;\n            case JSI_VT_STRING:\n                r = (Jsi_StrcmpDict(v2->d.s.str, v1->d.s.str, nocase, dict));\n                break;\n            case JSI_VT_OBJECT:\n                /* TODO: refer to objects joined to each other */\n                if (v2->vt != JSI_VT_OBJECT)\n                    r = 1;\n                else if (v1->d.obj->ot == JSI_OT_STRING && v2->d.obj->ot == JSI_OT_STRING)\n                    r = (Jsi_StrcmpDict(v2->d.obj->d.s.str, v1->d.obj->d.s.str, nocase, dict));\n                else\n                    r = (v2->d.obj - v1->d.obj);\n                break;\n            case JSI_VT_UNDEF:\n            case JSI_VT_NULL:\n                r = 0;\n                break;\n            default:\n                Jsi_LogBug(\"Unexpected value type\");\n        }\n    }\n    return r;\n}\n\n/**\n * @brief Split a string.\n * @param interp \n * @param str - input string to split\n * @param split - to split on\n * @returns an array of string values\n * \n * \n */\nJsi_Value *Jsi_StringSplit(Jsi_Interp *interp, const char *str, const char *spliton)\n{\n    char **argv; int argc;\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    Jsi_SplitStr(str, &argc, &argv, spliton, &dStr);\n    Jsi_Value *nret = Jsi_ValueNewArray(interp, NULL, 0);\n    Jsi_Obj *obj = nret->d.obj;\n    int i;\n    for (i = 0; i < argc; ++i) {\n        Jsi_ObjArraySet(interp, obj, Jsi_ValueNewStringDup(interp, argv[i]), i);\n    }\n    Jsi_ObjSetLength(interp, obj, argc);\n    Jsi_ValueMakeArrayObject(interp, &nret, obj);\n    Jsi_DSFree(&dStr);\n    return nret;\n}\n\nvoid jsi_ValueObjSet(Jsi_Interp *interp, Jsi_Value *target, const char *key, Jsi_Value *value, int flags, int isstrkey)\n{\n    Jsi_TreeEntry *hPtr;\n    if (target->vt != JSI_VT_OBJECT) {\n        if (interp->strict)\n            Jsi_LogWarn(\"Target is not object: %d\", target->vt);\n        return;\n    }\n    hPtr = Jsi_ObjInsert(interp, target->d.obj, key, value, (isstrkey?JSI_OM_ISSTRKEY:0));\n    if (!hPtr)\n        return;\n    hPtr->f.flags |= (flags&JSI_TREE_USERFLAG_MASK);\n}\n\nJsi_Value *jsi_ValueObjKeyAssign(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *keyval, Jsi_Value *value, int flag)\n{\n    int arrayindex = -1;\n\n    if (keyval->vt == JSI_VT_NUMBER && Jsi_NumberIsInteger(keyval->d.num) && keyval->d.num >= 0) {\n        arrayindex = (int)keyval->d.num;\n    }\n    /* TODO: array[\"1\"] also extern the length of array */\n    \n    if (arrayindex >= 0 && arrayindex < MAX_ARRAY_LIST &&\n        target->vt == JSI_VT_OBJECT && target->d.obj->arr) {\n        return jsi_ObjArraySetDup(interp, target->d.obj, value, arrayindex);\n    }\n    const char *kstr = Jsi_ValueToString(interp, keyval, NULL);\n    \n#if (defined(JSI_HAS___PROTO__) && JSI_HAS___PROTO__==2)\n    if (Jsi_Strcmp(kstr, \"__proto__\")==0) {\n        Jsi_Obj *obj = target->d.obj;\n        obj->__proto__ = Jsi_ValueDup(interp, value);\n        //obj->clearProto = 1;\n        return obj->__proto__;\n    }\n#endif\n    Jsi_Value *v = Jsi_ValueNew1(interp);\n    if (value)\n        Jsi_ValueCopy(interp, v, value);\n\n    jsi_ValueObjSet(interp, target, kstr, v, flag, (Jsi_ValueIsStringKey(interp, keyval)? JSI_OM_ISSTRKEY:0));\n    Jsi_DecrRefCount(interp, v);\n    return v;\n}\n\nstatic Jsi_Value *jsi_ValueLookupBase(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *key, Jsi_Value **ret)\n{\n    if (!target)\n        return NULL;\n    if (target->vt != JSI_VT_OBJECT) {\n        Jsi_LogError(\"subscript operand is not object\");\n        return NULL;\n    }\n    const char *keyStr = Jsi_ValueToString(interp, key, NULL);\n    if (!keyStr)\n        return NULL;\n    bool isStrKey = (key->vt == JSI_VT_STRING && key->f.bits.isstrkey);\n    Jsi_Value *v = Jsi_ValueObjLookup(interp, target, (char*)keyStr, isStrKey);\n    if (v)\n        return v;\n    if (target->d.obj->__proto__)\n        return jsi_ValueLookupBase(interp, target->d.obj->__proto__, key, ret);\n    return NULL;\n}\n\n\nJsi_Value* jsi_ValueSubscript(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *key, Jsi_Value **ret)\n{\n    int len;\n    Jsi_ValueReset(interp, ret);\n    Jsi_Value *v = jsi_ValueLookupBase(interp, target, key, ret);\n    if (v)\n        return v;\n    const char *keyStr = Jsi_ValueString(interp, key, NULL);\n    if (!keyStr)\n        return NULL;\n    // Special cases such as \"length\", \"constructor\", etc...\n    if (Jsi_Strcmp(keyStr,\"length\")==0) {\n        if (Jsi_ValueIsString(interp, target)) {\n            len = Jsi_ValueStrlen(target);\n        } else if (target->vt == JSI_VT_OBJECT && target->d.obj->isarrlist) {\n            len = target->d.obj->arrCnt;\n        } else if (target->vt == JSI_VT_OBJECT && target->d.obj->ot == JSI_OT_FUNCTION) {\n            Jsi_Func *fo = target->d.obj->d.fobj->func;\n            if (fo->type == FC_NORMAL)\n                len = fo->argnames->count;\n            else\n                len = fo->cmdSpec->maxArgs, len = (len>=0?len:fo->cmdSpec->minArgs);\n        } else if (target->vt == JSI_VT_OBJECT && target->d.obj->tree) {\n            len = target->d.obj->tree->numEntries;\n        } else {\n            return NULL;\n        }\n        (*ret)->vt = JSI_VT_NUMBER;\n        (*ret)->d.num = (Jsi_Number)len;\n        return *ret;\n    }\n\n    if (target->vt == JSI_VT_OBJECT && (interp->subOpts.noproto==0 && Jsi_Strcmp(keyStr,\"constructor\")==0)) {\n        const char *cp;\n        Jsi_Obj *o = target->d.obj->constructor;\n        if (o) {\n            if (o->ot == JSI_OT_FUNCTION) {\n                Jsi_Value *proto = Jsi_TreeObjGetValue(o, \"prototype\", 0);\n                if (proto && proto->vt == JSI_VT_OBJECT && proto->d.obj->constructor) {\n                    o = proto->d.obj->constructor;\n                }\n            }\n        } else {\n            switch(target->d.obj->ot) {\n                case JSI_OT_NUMBER:\n                    cp = \"Number\";\n                    break;\n                case JSI_OT_BOOL:\n                    cp = \"Boolean\";\n                    break;\n                case JSI_OT_STRING:\n                    cp = \"String\";\n                    break;\n                case JSI_OT_REGEXP:\n                    cp = \"RegExp\";\n                    break;\n                case JSI_OT_OBJECT:\n                    if (target->d.obj->isarrlist) {\n                        cp = \"Array\";\n                        break;\n                    }\n                    cp = \"Object\";\n                    break;\n                default:\n                    Jsi_ValueMakeUndef(interp, ret);\n                    return *ret;\n            }\n            v = Jsi_ValueObjLookup(interp, interp->csc, cp, 0);\n            if (v==NULL || v->vt != JSI_VT_OBJECT)\n                return NULL;\n            o = target->d.obj->constructor = v->d.obj;\n        }\n        Jsi_ValueMakeObject(interp, ret, o);\n        return *ret;\n    }\n\n    if (target->vt == JSI_VT_OBJECT && target->d.obj->ot == JSI_OT_FUNCTION) {\n        /* Looking up something like \"String.substr\" */\n        Jsi_Func* func = target->d.obj->d.fobj->func;\n        if (func->type == FC_BUILDIN) {\n            if (func->f.bits.iscons && func->name) {\n                Jsi_Value *v = Jsi_ValueObjLookup(interp, interp->csc, (char*)func->name, 0);\n                if (!v) {\n                } else {\n                    bool ooo = interp->subOpts.noproto;\n                    interp->subOpts.noproto = 0;\n                    v = Jsi_ValueObjLookup(interp, v, \"prototype\", 0);\n                    interp->subOpts.noproto = ooo;\n                    \n                    if (v && ((v = Jsi_ValueObjLookup(interp, v, (char*)keyStr, 0)))) {\n                        if (v->vt == JSI_VT_OBJECT && v->d.obj->ot == JSI_OT_FUNCTION && Jsi_Strcmp(func->name,\"Interp\")) {\n                            Jsi_Func* sfunc = v->d.obj->d.fobj->func;\n                            /* Handle \"Math.pow(2,3)\", \"String.fromCharCode(0x21)\", ... */\n                            sfunc->callflags.bits.addargs = 1;\n                        }\n                        return v;\n                    }\n                }\n            }\n            if (Jsi_ValueIsString(interp, key)) {\n                char *kstr = Jsi_ValueString(interp, key, NULL);\n                if (!Jsi_Strcmp(kstr,\"call\") || !Jsi_Strcmp(kstr,\"apply\") || !Jsi_Strcmp(kstr,\"bind\")) {\n                    char fbuf[JSI_MAX_NUMBER_STRING];\n                    snprintf(fbuf, sizeof(fbuf), \"Function.%s\", kstr);\n                    Jsi_Value *vv = Jsi_NameLookup(interp, fbuf);\n                    if (vv)\n                        return vv;\n                }\n            }\n        }\n    }\n    return NULL;\n}\n\nbool Jsi_ValueKeyPresent(Jsi_Interp *interp, Jsi_Value *target, const char *key, int isstrkey)\n{\n    SIGASSERT(interp,INTERP);\n    //SIGASSERT(target,VALUE);\n    if (Jsi_TreeObjGetValue(target->d.obj, key, isstrkey))\n        return 1;\n    if (target->d.obj->__proto__ == NULL || target->d.obj->__proto__ == target)\n        return 0;\n    return Jsi_ValueKeyPresent(interp, target->d.obj->__proto__, key, isstrkey);\n}\n\nvoid jsi_ValueObjGetKeys(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *ret, bool isof)\n{\n    Jsi_IterObj *io = Jsi_IterObjNew(interp, NULL);\n    Jsi_Obj *to = target->d.obj;\n    \n    if (target->vt != JSI_VT_UNDEF && target->vt != JSI_VT_NULL) {\n\n        if (target->vt == JSI_VT_OBJECT && to->arr) {\n            io->isArrayList = 1;\n            io->count = to->arrCnt;\n        } else {\n            if (isof &&interp->strict)\n                Jsi_LogWarn(\"non-array in 'for...of'\");\n            Jsi_IterGetKeys(interp, target, io, 0);\n        }\n    }\n    io->obj = to;\n    io->isof = isof;\n    Jsi_Obj *r = Jsi_ObjNew(interp);\n    r->ot = JSI_OT_ITER;\n    r->d.iobj = io;\n    Jsi_ValueMakeObject(interp, &ret, r);\n}\n\nJsi_RC Jsi_ValueGetKeys(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *ret)\n{\n    uint i, n = 0;\n    Jsi_IterObj *io;\n    if (target->vt != JSI_VT_OBJECT)\n        return JSI_ERROR;\n    Jsi_Obj *to = target->d.obj;\n    Jsi_Obj *r = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    Jsi_ValueMakeArrayObject(interp, &ret, r);\n    if (to->arr) {\n        for (i=0; i<to->arrCnt; i++)\n            if (to->arr[i]) n++;\n        if (Jsi_ObjArraySizer(interp, r, n) <= 0) {\n            Jsi_LogError(\"too long\");\n            Jsi_ValueMakeUndef(interp, &ret);\n            return JSI_ERROR;\n        }\n        for (i=0, n=0; i<to->arrCnt; i++) {\n            if (to->arr[i]) {\n                r->arr[n] = Jsi_ValueNewNumber(interp, (Jsi_Number)i);\n                Jsi_IncrRefCount(interp, r->arr[n]);\n                n++;\n            }\n        }\n        r->arrCnt = n;\n        return JSI_OK;\n    }\n    io = Jsi_IterObjNew(interp, NULL);\n    Jsi_IterGetKeys(interp, target, io, 0);\n    if (Jsi_ObjArraySizer(interp, r, io->count) <= 0) {\n        Jsi_LogError(\"too long\");\n        Jsi_ValueMakeUndef(interp, &ret);\n        return JSI_ERROR;\n    }\n    for (i=0; i<io->count; i++) {\n        r->arr[i] = (io->keys[i] ? Jsi_ValueNewStringKey(interp, io->keys[i]) : NULL);\n        Jsi_IncrRefCount(interp, r->arr[i]);\n    }\n    io->count = 0;\n    r->arrCnt = i;\n    Jsi_IterObjFree(io);\n    return JSI_OK;\n}\n\njsi_ScopeChain *jsi_ScopeChainNew(Jsi_Interp *interp, int cnt)\n{\n    jsi_ScopeChain *r = (jsi_ScopeChain *)Jsi_Calloc(1, sizeof(*r));\n    r->interp = interp;\n    SIGINIT(r,SCOPE);\n    r->chains = (Jsi_Value **)Jsi_Calloc(cnt, sizeof(r->chains[0]));\n    r->chains_cnt = cnt;\n    return r;\n}\n\nJsi_Value *jsi_ScopeChainObjLookupUni(jsi_ScopeChain *sc, char *key)\n{\n    int i;\n    Jsi_Value *ret;\n    for (i = sc->chains_cnt - 1; i >= 0; --i) {\n        if ((ret = Jsi_ValueObjLookup(sc->interp, sc->chains[i], key, 0))) {\n            return ret;\n        }\n    }\n    return NULL;\n}\n\njsi_ScopeChain *jsi_ScopeChainDupNext(Jsi_Interp *interp, jsi_ScopeChain *sc, Jsi_Value *next)\n{\n    if (!sc) {\n        jsi_ScopeChain *nr = jsi_ScopeChainNew(interp, 1);\n        nr->chains[0] = next;\n        Jsi_IncrRefCount(interp, next);\n        nr->chains_cnt = 1;\n        return nr;\n    }\n    jsi_ScopeChain *r = jsi_ScopeChainNew(interp, sc->chains_cnt + 1);\n    int i;\n    for (i = 0; i < sc->chains_cnt; ++i) {\n        r->chains[i] = sc->chains[i];\n        Jsi_IncrRefCount(interp, sc->chains[i]);\n    }\n    r->chains[i] =  next;\n    Jsi_IncrRefCount(interp, next);\n    r->chains_cnt = i + 1;\n    return r;\n}\n\nvoid jsi_ScopeChainFree(Jsi_Interp *interp, jsi_ScopeChain *sc)\n{\n    int i;\n    for (i = 0; i < sc->chains_cnt; ++i) {\n        Jsi_DecrRefCount(interp, sc->chains[i]);\n    }\n    Jsi_Free(sc->chains);\n    _JSI_MEMCLEAR(sc);\n    Jsi_Free(sc);\n}\n\nint Jsi_ValueGetLength(Jsi_Interp *interp, Jsi_Value *v) {\n    if (Jsi_ValueIsArray(interp, v))\n        return v->d.obj->arrCnt;\n    Jsi_LogWarn(\"expected array\");\n    return 0;\n}\n\nchar *Jsi_ValueArrayIndexToStr(Jsi_Interp *interp, Jsi_Value *args, int index, int *lenPtr)\n{\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, index);\n    if (!arg)\n        return NULL;\n    char *res = Jsi_ValueString(interp, arg, lenPtr);\n    if (res)\n        return res;\n    res = (char*)Jsi_ValueToString(interp, arg, NULL);\n    if (res && lenPtr)\n        *lenPtr = Jsi_Strlen(res);\n    return res;\n}\n\nJsi_RC Jsi_ValueInsert(Jsi_Interp *interp, Jsi_Value *target, const char *key, Jsi_Value *val, int flags)\n{\n    if (target == NULL)\n        target = interp->csc;\n    if (target->vt != JSI_VT_OBJECT) {\n        if (interp->strict)\n            Jsi_LogWarn(\"Target is not object\");\n        return JSI_ERROR;\n    }\n    target->f.flag |= flags;\n    if (Jsi_ObjInsert(interp, target->d.obj, key, val, flags))\n        return JSI_OK;\n    return JSI_ERROR;\n}\n\nJsi_RC Jsi_ValueInsertArray(Jsi_Interp *interp, Jsi_Value *target, int key, Jsi_Value *val, int flags)\n{\n    if (target->vt != JSI_VT_OBJECT) {\n        if (interp->strict)\n            Jsi_LogWarn(\"Target is not object\");\n        return JSI_ERROR;\n    }\n    Jsi_Obj *obj = target->d.obj;\n    \n    if (obj->isarrlist) {\n        if (key >= 0 && key < interp->maxArrayList) {\n            Jsi_ObjArraySet(interp, obj, val, key);\n            return JSI_OK;\n        }\n        return JSI_ERROR;\n    }\n    char unibuf[JSI_MAX_NUMBER_STRING];\n    Jsi_NumberItoA10(key, unibuf, sizeof(unibuf));\n    Jsi_ObjInsert(interp, obj, unibuf, val, flags);\n    return JSI_OK;\n}\n\n/* OBJ INTERFACE TO BTREE */\n\nstatic void IterObjInsertKey(Jsi_IterObj *io, const char *key)\n{\n    assert(!io->isArrayList);\n    if (io->depth) {\n        uint i;\n        for (i=0; i<io->count; i++) {\n            if (!Jsi_Strcmp(key, io->keys[i]))\n                return;\n        }\n    }\n\n    if (io->count >= io->size) {\n        io->size += 10;\n        io->keys = (const char**)Jsi_Realloc(io->keys, io->size * sizeof(io->keys[0]));\n    }\n    io->keys[io->count] = key;\n    io->count++;\n}\nstatic void IterObjInsert(Jsi_IterObj *io, Jsi_TreeEntry *hPtr)\n{\n    IterObjInsertKey(io, (const char*)Jsi_TreeKeyGet(hPtr));\n}\n\nJsi_TreeEntry * Jsi_ObjInsert(Jsi_Interp *interp, Jsi_Obj *obj, const char *key, Jsi_Value *val, int flags)\n{\n    Jsi_TreeEntry *hPtr;\n    SIGASSERT(val, VALUE);\n    /*if (val)\n        Jsi_IncrRefCount(interp, val);*/\n    hPtr = Jsi_TreeObjSetValue(obj, key, val, (flags&JSI_OM_ISSTRKEY));\n    if ((flags&JSI_OM_DONTDEL))\n        val->f.bits.dontdel = hPtr->f.bits.dontdel = 1;\n    if ((flags&JSI_OM_READONLY))\n        val->f.bits.readonly =hPtr->f.bits.readonly = 1;\n    if ((flags&JSI_OM_DONTENUM))\n        val->f.bits.dontenum =hPtr->f.bits.dontenum = 1;\n    return hPtr;\n}\n\nstatic Jsi_RC IterGetKeysCallback(Jsi_Tree* tree, Jsi_TreeEntry *hPtr, void *data)\n{\n    Jsi_IterObj *io = (Jsi_IterObj *)data;\n    if (!hPtr->f.bits.dontenum) {\n        IterObjInsert(io, hPtr);\n    }\n    return JSI_OK;\n}\n\nvoid Jsi_IterGetKeys(Jsi_Interp *interp, Jsi_Value *target, Jsi_IterObj *iterobj, int depth)\n{\n    if (!target) return;\n    if (target->vt != JSI_VT_OBJECT) {\n        if (interp->strict)\n            Jsi_LogWarn(\"operand is not a object\");\n        return;\n    }\n    Jsi_Obj *to = target->d.obj;\n    Jsi_CmdSpec *cs = NULL;\n    if (to->ot == JSI_OT_USEROBJ) {\n        Jsi_UserObj *uobj = to->d.uobj;\n        cs = uobj->reg->spec;\n    } else if (to->ot == JSI_OT_FUNCTION) {\n        Jsi_FuncObj *fobj = to->d.fobj;\n        if (fobj->func->type == FC_BUILDIN)\n            cs = fobj->func->cmdSpec;\n    }\n    if (cs) {\n        while (cs->name) {\n            IterObjInsertKey(iterobj, cs->name);\n            cs++;\n        }\n        return;\n    }\n    iterobj->depth = depth;\n    Jsi_TreeWalk(target->d.obj->tree, IterGetKeysCallback, iterobj, 0);\n    if (target->d.obj->__proto__ && target != target->d.obj->__proto__)\n        Jsi_IterGetKeys(interp, target->d.obj->__proto__, iterobj, depth+1);\n    iterobj->depth = depth;\n}\n\nJsi_Value* Jsi_ValueMakeDStringObject(Jsi_Interp *interp, Jsi_Value **vPtr, Jsi_DString *dsPtr)  {\n    Jsi_Value *v = (vPtr?*vPtr:NULL);\n    Jsi_Obj *obj;\n    if (!v)\n        v = Jsi_ValueNew(interp);\n    else {\n        assert(v->vt <= JSI_VT__MAX);\n        if (v->vt == JSI_VT_OBJECT && v->d.obj->ot == JSI_OT_STRING\n            && v->d.obj->refcnt == 1\n        ) {\n            Jsi_ObjFromDS(dsPtr, v->d.obj);\n            return v;\n        }\n        Jsi_ValueReset(interp, &v);\n    }\n    obj = Jsi_ObjNewType(interp, JSI_OT_STRING);\n    Jsi_ObjFromDS(dsPtr, obj);\n    Jsi_ValueMakeObject(interp, &v, obj);\n    return v;\n}\n\nJsi_Value* Jsi_ValueMakeObject(Jsi_Interp *interp, Jsi_Value **vPtr, Jsi_Obj *o)  {\n    Jsi_Value *v = (vPtr?*vPtr:NULL);\n    if (v && v->vt == JSI_VT_OBJECT && o == v->d.obj)\n        return v;\n    if (v)\n        Jsi_ValueReset(interp, vPtr);\n    else\n        v = Jsi_ValueNew(interp);\n    //Jsi_IncrRefCount(interp, v);\n    if (!o)\n        o = Jsi_ObjNewType(interp, JSI_OT_OBJECT);\n    v->vt = JSI_VT_OBJECT;\n    v->d.obj = o;\n    Jsi_ObjIncrRefCount(interp,v->d.obj);\n    return v;\n}\n\nJsi_Value* Jsi_ValueMakeArrayObject(Jsi_Interp *interp, Jsi_Value **vPtr, Jsi_Obj *o)  {\n    Jsi_Value *v = (vPtr?*vPtr:NULL);\n    if (!o)\n        o = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    if (!v)\n        v = Jsi_ValueNew(interp);\n    else {\n       if (v->vt == JSI_VT_OBJECT && o == v->d.obj) {\n            if (!o->isarrlist) {\n                if (o->tree)\n                    Jsi_TreeDelete( o->tree);\n                o->tree = NULL;\n                o->__proto__ = interp->Array_prototype;\n                o->isarrlist = 1;\n            }\n            return v;\n        }\n        Jsi_ValueReset(interp, vPtr);\n    }\n    v->vt = JSI_VT_OBJECT;\n    v->d.obj = o;\n    o->ot = JSI_OT_OBJECT;\n    o->__proto__ = interp->Array_prototype;\n    o->isarrlist = 1;\n    Jsi_ObjArraySizer(interp, o, 0);\n    Jsi_ObjIncrRefCount(interp,v->d.obj);\n    return v;\n}\n\nJsi_Value* Jsi_ValueMakeNumber(Jsi_Interp *interp, Jsi_Value **vPtr, Jsi_Number n) {\n    Jsi_Value *v = (vPtr?*vPtr:NULL);\n    if (!v)\n        v = Jsi_ValueNew(interp);\n    else\n        Jsi_ValueReset(interp, vPtr);\n    v->vt = JSI_VT_NUMBER;\n    v->d.num = n;\n    return v;\n}\n\nJsi_Value* Jsi_ValueMakeBool(Jsi_Interp *interp, Jsi_Value **vPtr, int b) {\n    Jsi_Value *v = (vPtr?*vPtr:NULL);\n    if (!v)\n        v = Jsi_ValueNew(interp);\n    else\n        Jsi_ValueReset(interp, vPtr);\n    v->vt = JSI_VT_BOOL;\n    v->d.val = b;\n    return v;\n}\n\nJsi_Value* Jsi_ValueMakeBlob(Jsi_Interp *interp, Jsi_Value **vPtr, unsigned char *s, int len) {\n    Jsi_Value *v = (vPtr?*vPtr:NULL);\n    if (!v)\n        v = Jsi_ValueNew(interp);\n    else\n        Jsi_ValueReset(interp, vPtr);\n    Jsi_Obj *obj = Jsi_ObjNewType(interp, JSI_OT_STRING);\n    Jsi_ValueMakeObject(interp, &v, obj);\n    obj->d.s.str = (char*)s;\n    obj->d.s.len = len;\n    obj->isBlob = 1;\n    return v;\n}\nJsi_Value* jsi_ValueMakeBlobDup(Jsi_Interp *interp, Jsi_Value **ret, unsigned char *s, int len) {\n    if (len<0) len = Jsi_Strlen((char*)s);\n    uchar *dp = (uchar*)Jsi_Malloc(len+1);\n    memcpy(dp, s, len);\n    dp[len] = 0;\n    return Jsi_ValueMakeBlob(interp, ret, dp, len);\n}\n\n\nJsi_Value* Jsi_ValueMakeString(Jsi_Interp *interp, Jsi_Value **vPtr, const char *s) {\n    return Jsi_ValueMakeBlob(interp, vPtr, (unsigned char *)s, Jsi_Strlen(s));\n}\n\nJsi_Value* Jsi_ValueMakeStringKey(Jsi_Interp *interp, Jsi_Value **vPtr, const char *s) {\n    Jsi_Value *v = (vPtr?*vPtr:NULL);\n    if (!v)\n        v = Jsi_ValueNew(interp);\n    else\n        Jsi_ValueReset(interp, vPtr);\n    v->vt = JSI_VT_STRING;\n    v->d.s.str = (char*)Jsi_KeyAdd(interp,s);\n    v->d.s.len = Jsi_Strlen(s);\n    v->f.bits.isstrkey = 1;\n    return v;\n}\n\nJsi_Value* Jsi_ValueMakeNull(Jsi_Interp *interp, Jsi_Value **vPtr) {\n    Jsi_Value *v = (vPtr?*vPtr:NULL);\n    if (!v)\n        v = Jsi_ValueNew(interp);\n    else\n        Jsi_ValueReset(interp, vPtr);\n    v->vt = JSI_VT_NULL;\n    return v;\n}\n\nJsi_Value* Jsi_ValueMakeUndef(Jsi_Interp *interp, Jsi_Value **vPtr) {\n    Jsi_Value *v = (vPtr?*vPtr:NULL);\n    if (!v)\n        v = Jsi_ValueNew(interp);\n    else {\n        if (v->vt == JSI_VT_UNDEF) return v;\n        Jsi_ValueReset(interp, vPtr);\n    }\n    return v;\n}\n\nJsi_Value* Jsi_ValueNewNumber(Jsi_Interp *interp, Jsi_Number n) {\n    Jsi_Value *v = Jsi_ValueNew(interp);\n    v->vt = JSI_VT_NUMBER;\n    v->d.num = n;\n    return v;\n}\n\nJsi_Value* Jsi_ValueNewObj(Jsi_Interp *interp, Jsi_Obj *o) {\n    Jsi_Value *v = Jsi_ValueNew(interp);\n    Jsi_ValueMakeObject(interp, &v, o);\n    return v;\n}\n\nJsi_Value* Jsi_ValueNewString(Jsi_Interp *interp, const char *s, int len) {\n    assert(s);\n    Jsi_Value *v = Jsi_ValueNew(interp);\n    Jsi_Obj *obj = Jsi_ObjNewType(interp, JSI_OT_STRING);\n    Jsi_ValueMakeObject(interp, &v, obj);\n    obj->d.s.str = (char*)s;\n    obj->d.s.len = (len<0?Jsi_Strlen(s):(uint)len);\n    return v;\n}\n\nJsi_Value* Jsi_ValueNewStringDup(Jsi_Interp *interp, const char *s) {\n    return Jsi_ValueNewString(interp, Jsi_Strdup(s), -1);\n}\n\nJsi_Value* Jsi_ValueNewStringKey(Jsi_Interp *interp, const char *s) {\n    Jsi_Value *v = Jsi_ValueNew(interp);\n    v->vt = JSI_VT_STRING;\n    v->d.s.str = (char*)Jsi_KeyAdd(interp,s);\n    v->d.s.len = Jsi_Strlen(s);\n    v->f.bits.isstrkey = 1;\n    return v;\n}\n\n\nJsi_Value* Jsi_ValueNewStringConst(Jsi_Interp *interp, const char *s, int len) {\n    Jsi_Value *v = Jsi_ValueNew(interp);\n    v->vt = JSI_VT_STRING;\n    v->d.s.str = (char*)s;\n    v->d.s.len = (len<0?Jsi_Strlen(s):(uint)len);\n    v->f.bits.isstrkey = 1;\n    return v;\n}\n\nJsi_Value* Jsi_ValueNewBlob(Jsi_Interp *interp, unsigned char *s, uint len) {\n    Jsi_Value *v = Jsi_ValueNew(interp);\n    Jsi_Obj *o = Jsi_ObjNewType(interp, JSI_OT_STRING);\n    Jsi_ValueMakeObject(interp, &v, o);\n    o->d.s.str = (char*)Jsi_Malloc(len+1);\n    memcpy(o->d.s.str, (char*)s, len);\n    o->d.s.str[len] = 0;\n    o->d.s.len = len;\n    o->isBlob = 1;\n    return v;\n}\n\nJsi_Value* Jsi_ValueNewBoolean(Jsi_Interp *interp, int bval) {\n    Jsi_Value *v = Jsi_ValueNew(interp);\n    v->vt = JSI_VT_BOOL;\n    v->d.val = bval;\n    return v;\n}\n\nJsi_Value* Jsi_ValueNewNull(Jsi_Interp *interp) {\n    Jsi_Value *v = Jsi_ValueNew(interp);\n    v->vt = JSI_VT_NULL;\n    return v;\n}\n\nJsi_Value *Jsi_ValueNewArray(Jsi_Interp *interp, const char **items, int count)\n{\n    Jsi_Obj *obj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    int i = 0;\n    if (count<0) {\n        count = 0;\n        while (items[count])\n            count++;\n    }\n    if (Jsi_ObjArraySizer(interp, obj, count) <= 0) {\n        Jsi_ObjFree(interp, obj);\n        return NULL;\n    }\n    for (i = 0; i < count; ++i) {\n        obj->arr[i] = Jsi_ValueNewStringDup(interp, items[i]);\n        Jsi_IncrRefCount(interp, obj->arr[i]);\n    }\n    obj->arrCnt = count;\n    assert(obj->arrCnt<=obj->arrMaxSize);\n    return Jsi_ValueMakeArrayObject(interp, NULL, obj);\n}\n\nJsi_Obj *Jsi_ValueGetObj(Jsi_Interp *interp, Jsi_Value* v)\n{\n    if (v->vt == JSI_VT_OBJECT) {\n        return v->d.obj;\n    }\n    return NULL;\n}\n\nint Jsi_ValueStrlen(Jsi_Value* v) {\n    //if (v->vt == JSI_VT_OBJECT && v->d.obj->ot == JSI_OT_STRING && v->d.obj->isBlob)\n    //    return v->d.obj->d.s.len;\n    Jsi_String *s = jsi_ValueString(v);\n    if (s == 0 || s->str == 0)\n        return 0;\n#if JSI__UTF8\n    return (int)Jsi_NumUtfChars(s->str, s->len);\n#else\n    if (s->len>=0) return s->len;\n    return (int)Jsi_NumUtfChars(s->str, s->len);\n#endif\n}\n\nchar *Jsi_ValueString(Jsi_Interp *interp, Jsi_Value* v, int *lenPtr)\n{\n    if (!v) return NULL;\n    Jsi_String *s = jsi_ValueString(v);\n    if (s) {\n        if (lenPtr)\n            *lenPtr = (s->len<0 ? (int)Jsi_Strlen(s->str) : s->len);\n        return s->str;\n    }\n    if (lenPtr)\n        *lenPtr = 0;\n    return NULL;\n}\n\nunsigned char *Jsi_ValueBlob(Jsi_Interp *interp, Jsi_Value* v, int *lenPtr)\n{\n    return (unsigned char*)Jsi_ValueString(interp, v, lenPtr);\n}\n\nchar* Jsi_ValueGetStringLen(Jsi_Interp *interp, Jsi_Value *pv, int *lenPtr)\n{\n    if (!pv)\n        return NULL;\n    Jsi_String *s = jsi_ValueString(pv);\n    if (!s)\n        return NULL;\n    if (lenPtr)\n        *lenPtr = (s->len<0 ? (int)Jsi_Strlen(s->str) : s->len);\n    return s->str;\n}\n\nint Jsi_ValueInstanceOf( Jsi_Interp *interp, Jsi_Value* v1, Jsi_Value* v2)\n{\n    Jsi_Value *proto, *sproto;\n    if (v1->vt != JSI_VT_OBJECT || v2->vt != JSI_VT_OBJECT  || v2->d.obj->ot != JSI_OT_FUNCTION)\n        return 0;\n    proto = Jsi_ValueObjLookup(interp, v2, \"prototype\", 0);\n    if (!proto)\n        return 0;\n    sproto = v1->d.obj->__proto__ ;\n    while (sproto) {\n        if (sproto == proto)\n            return 1;\n        if (sproto->vt != JSI_VT_OBJECT)\n            return 0;\n        sproto = sproto->d.obj->__proto__;\n    }\n    return 0;\n}\n\n\nJsi_RC jsi_InitValue(Jsi_Interp *interp, int release)\n{\n    return JSI_OK;\n}\n\nvoid  Jsi_ValueFromDS(Jsi_Interp *interp, Jsi_DString *dsPtr, Jsi_Value **ret)\n{\n    char *cp = NULL;\n    int len = Jsi_DSLength(dsPtr);\n    if (len && !(cp=(char*)dsPtr->strA)) \n        cp = Jsi_StrdupLen(dsPtr->Str, len);\n    dsPtr->strA = NULL;\n    dsPtr->Str[0] = 0;\n    dsPtr->len = 0;\n    dsPtr->spaceAvl = dsPtr->staticSize;\n    if (!cp)\n        Jsi_ValueMakeStringDup(interp, ret, \"\");\n    else\n        Jsi_ValueMakeBlob(interp, ret, (uchar*)cp, len);\n}\n\n#endif\n", "#ifndef JSI_LITE_ONLY\n#if JSI__WEBSOCKET==1\n#if JSI__MEMDEBUG\n#include \"jsiInt.h\"\n#else\n\n#ifndef JSI_AMALGAMATION\n#include \"jsi.h\"\n#ifdef JSI_WEBSOCKET_SHARED\nJSI_EXTENSION_INI\n#endif\n#endif\n\n#define jsi_Sig int\n\n#endif /* JSI__MEMDEBUG */\n\n#include <time.h>\n#include <sys/time.h>\n\n#include <ctype.h>\n\n#ifdef CMAKE_BUILD\n#include \"lws_config.h\"\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <getopt.h>\n#include <string.h>\n#include <assert.h>\n#include <limits.h>\n#include <fcntl.h>\n#ifdef WIN32\n#define _GET_TIME_OF_DAY_H\n#ifdef EXTERNAL_POLL\n    #ifndef WIN32_LEAN_AND_MEAN\n    #define WIN32_LEAN_AND_MEAN\n    #endif\n    #include <winsock2.h>\n    #include <ws2tcpip.h>\n    #include <stddef.h>\n\n    #include \"websock-w32.h\"\n#endif\n\n#else /* WIN32 */\n#include <syslog.h>\n#include <unistd.h>\n#endif /* WIN32 */\n\n#include <signal.h>\n\n#include <libwebsockets.h>\n\n//#define LWS_NO_EXTENSIONS\nstatic const int jsi_WsPkgVersion = 2;\n#ifdef EXTERNAL_POLL\nstatic int max_poll_elements;\nstatic struct pollfd *jsi_wspollfds;\nstatic int *fd_lookup;\nstatic int jsi_wsnum_pollfds;\nstatic int force_exit = 0;\n#endif /* EXTERNAL_POLL */\n\ntypedef enum {  PWS_DEAD, PWS_HTTP, PWS_CONNECTED, PWS_RECV, PWS_SENT, PWS_SENDERR } pws_state;\nenum { JWS_SIG_SYS=0xdeadf000, JWS_SIG_OBJ, JWS_SIG_PWS };\n\n#ifndef NDEBUG\n#ifndef _JSI_MEMCLEAR\n#define _JSI_MEMCLEAR(s) memset(s, 0, sizeof(*s));\n#endif\n#else\n#define _JSI_MEMCLEAR(s)\n#endif\n#define WSSIGASSERT(s,n) assert(s->sig == JWS_SIG_##n)\n\nenum {\n    /* always first */\n    JWS_PROTOCOL_HTTP = 0,\n    JWS_PROTOCOL_WEBSOCK,\n    /* always last */\n    JWS_PROTOCOL__MAX\n};\n\n#ifdef interface\n#undef interface\n#endif\n\ntypedef struct {\n  int activeCnt;  /* Count of active objects. */ \n  int newCnt;  /* Total number of new. */ \n} ws_ObjCmd;\n\nstatic ws_ObjCmd wsObjCmd = {};\n\nstatic Jsi_OptionSpec wsObjCmd_Specs[] =\n{\n    JSI_OPT(INT,   ws_ObjCmd, activeCnt, .help=\"Number of active objects\"),\n    JSI_OPT(INT,   ws_ObjCmd, newCnt,    .help=\"Number of new calls\"),\n    JSI_OPT_END(ws_ObjCmd, .help=\"Options for WebSocket module\")\n};\n\ntypedef struct {\n    int sentCnt, recvCnt, recvErrCnt, sentErrCnt, httpCnt, uploadCnt;\n    time_t sentLast, recvLast, recvErrLast, sentErrLast, httpLast,\n        createTime, uploadStart, uploadLast, uploadEnd, redirLast, eventLast;\n    int msgQLen;\n    int redirCnt;\n    int eventCnt;\n    int connectCnt;\n    bool isBinary, isFinal;\n} jsi_wsStatData;\n\ntypedef struct { /* Per server data (or client if client-mode). */\n    uint sig;\n    Jsi_Interp *interp;\n    ws_ObjCmd *_;\n    Jsi_Hash *pssTable, *handlers, *fileHash;\n    Jsi_Value *onAuth, *onCloseLast, *onClose, *onFilter, *onOpen, *onRecv,\n        *onUpload, *onGet, *onUnknown, *onModify, *pathAliases, *udata,\n        *rootdir, *interface, *address, *mimeTypes, *extOpts, *headers, *ssiExts;\n    bool client, noUpdate, noWebsock, noWarn, use_ssl, local, extHandlers, handlersPkg, inUpdate, noCompress, noConfig, echo;\n    Jsi_Value* version;\n    int idx;\n    int port;\n    uint modifySecs;\n    int maxUpload;\n    int maxDownload;\n    int bufferPwr2;\n    jsi_wsStatData stats;\n    char *iface;\n    const char* urlPrefix, *urlRedirect;\n    const char *localhostName;\n    const char *clientName;\n    const char *clientIP;\n    const char *useridPass, *server;\n    const char *realm, *includeFile, *jsiFnPattern, *jsishPathCache;\n    struct lws_context *instCtx;\n    Jsi_Value *getRegexp, *post;\n    unsigned int oldus;\n    int opts;\n    int hasOpts;\n    int debug;\n    int maxConnects;\n    int deleted;\n    int close_test;\n    int createCnt;\n    int redirAllCnt;\n    bool redirMax;\n    int redirDisable;\n    int recvBufMax;\n    int recvBufCnt;\n    int recvBufTimeout;\n    int lastRevCnt; // For update\n    time_t createLast;\n    time_t startTime;\n    time_t lastModifyCheck, lastModifyNotify;\n    char *cmdName;\n    struct lws *wsi_choked[20];\n    int num_wsi_choked;\n    struct lws *wsi;\n\n    struct lws_context *context;\n    struct lws_context_creation_info info;\n    Jsi_Event *event;\n    Jsi_Obj *fobj;\n    int objId;\n    const char *protocol;\n    struct lws_protocols protocols[JWS_PROTOCOL__MAX+1];\n    int ietf_version;\n    char *ssl_cert_filepath;\n    char *ssl_private_key_filepath;\n    int ws_uid;\n    int ws_gid;\n    const char *clientHost;\n    const char *clientOrigin;\n    const char *formParams;\n    const char *curRoot;\n    int sfd;        // File descriptor for http.\n    Jsi_DString cName;\n} jsi_wsCmdObj;\n\ntypedef struct { /* Per session connection (to each server) */\n    uint sig;\n    jsi_wsCmdObj *cmdPtr;\n    pws_state state;\n    jsi_wsStatData stats;\n    struct lws *wsi;\n    Jsi_HashEntry *hPtr;\n    Jsi_Value* username;\n    void *user;\n    int cnt;\n    //int fd;\n    lws_fop_fd_t fop_fd;\n    int wid;\n    //int sfd;\n    bool isWebsock, echo;\n    const char *clientName;\n    const char *clientIP;\n    int hdrSz[200]; // Space for up to 100 headers\n    int hdrNum;     // Num of above.\n    time_t deferDel; // TODO: defer delete if output via SSI echo ${#}.\n    // Pointers to reset.\n    Jsi_DString dHdrs; // Store header string here.\n    Jsi_Stack *stack;\n    Jsi_DString recvBuf; // To buffer recv when recvJSON is true.\n    Jsi_Value *onClose, *onFilter, *onRecv, *onUpload, *onGet, *onUnknown, *rootdir, *headers;\n    char *lastData;\n    char key[JSI_MAX_NUMBER_STRING]; // Lookup key.\n#if (LWS_LIBRARY_VERSION_MAJOR>1)\n    char filename[PATH_MAX];\n    long file_length;\n    struct lws_spa *spa;\n    Jsi_DString resultStr, paramDS, url;\n    Jsi_Value *udata, *query;\n    Jsi_Value *queryObj;\n    Jsi_RC resultCode;\n    char **paramv;\n    int paramc;\n#endif\n} jsi_wsPss;\n\ntypedef struct {\n    int unused;\n} jsi_wsUser;\n\ntypedef struct {\n    Jsi_Value *val, *objVar;\n    int triedLoad;\n    int flags;\n} jsi_wsHander;\n\ntypedef struct {\n    Jsi_Value *fileVal;\n    time_t loadLast, loadFirst;\n    int flags;\n} jsi_wsFile;\n\nstatic const char* const jsi_wsparam_names[] = { \"text\", \"send\", \"file\", \"upload\" };\nstatic const char* jsi_wsparam_str = \"text,send,file,upload\";\n\n#ifndef jsi_IIOF\n#define jsi_IIOF .flags=JSI_OPT_INIT_ONLY\n#define jsi_IIRO .flags=JSI_OPT_READ_ONLY\n#endif\n\nstatic Jsi_OptionSpec WPSStats[] =\n{\n    JSI_OPT(INT,        jsi_wsStatData, connectCnt,   .help=\"Number of active connections\", jsi_IIRO),\n    JSI_OPT(TIME_T,     jsi_wsStatData, createTime,   .help=\"Time created\"),\n    JSI_OPT(INT,        jsi_wsStatData, eventCnt,     .help=\"Number of events of any type\"),\n    JSI_OPT(TIME_T,     jsi_wsStatData, eventLast,    .help=\"Time of last event of any type\"),\n    JSI_OPT(INT,        jsi_wsStatData, httpCnt,      .help=\"Number of http reqs\"),\n    JSI_OPT(TIME_T,     jsi_wsStatData, httpLast,     .help=\"Time of last http reqs\"),\n    JSI_OPT(BOOL,       jsi_wsStatData, isBinary,     .help=\"Connection recv data is binary\", jsi_IIRO),\n    JSI_OPT(BOOL,       jsi_wsStatData, isFinal,      .help=\"Final data for current message was recieved\", jsi_IIRO),\n    JSI_OPT(INT,        jsi_wsStatData, msgQLen,      .help=\"Number of messages in input queue\", jsi_IIRO),\n    JSI_OPT(INT,        jsi_wsStatData, recvCnt,      .help=\"Number of recieves\", jsi_IIRO),\n    JSI_OPT(TIME_T,     jsi_wsStatData, recvLast,     .help=\"Time of last recv\", jsi_IIRO),\n    JSI_OPT(TIME_T,     jsi_wsStatData, redirLast,    .help=\"Time of last redirect\", jsi_IIRO),\n    JSI_OPT(INT,        jsi_wsStatData, redirCnt,     .help=\"Count of redirects\", jsi_IIRO),\n    JSI_OPT(INT,        jsi_wsStatData, sentCnt,      .help=\"Number of sends\", jsi_IIRO),\n    JSI_OPT(TIME_T,     jsi_wsStatData, sentLast,     .help=\"Time of last send\", jsi_IIRO),\n    JSI_OPT(INT,        jsi_wsStatData, sentErrCnt,   .help=\"Number of sends\", jsi_IIRO),\n    JSI_OPT(TIME_T,     jsi_wsStatData, sentErrLast,  .help=\"Time of last sendErr\", jsi_IIRO),\n    JSI_OPT(TIME_T,     jsi_wsStatData, sentErrLast,  .help=\"Time of last sendErr\", jsi_IIRO),\n    JSI_OPT(INT,        jsi_wsStatData, uploadCnt,    .help=\"Number of uploads\", jsi_IIRO),\n    JSI_OPT(TIME_T,     jsi_wsStatData, uploadEnd,    .help=\"Time of upload end\", jsi_IIRO),\n    JSI_OPT(TIME_T,     jsi_wsStatData, uploadLast,   .help=\"Time of last upload input\", jsi_IIRO),\n    JSI_OPT(TIME_T,     jsi_wsStatData, uploadStart,  .help=\"Time of upload start\", jsi_IIRO),\n    JSI_OPT_END(jsi_wsStatData, .help=\"Per-connection statistics\")\n};\n\nstatic Jsi_OptionSpec WPSOptions[] =\n{\n    JSI_OPT(STRKEY,     jsi_wsPss, clientIP,    .help=\"Client IP Address\", jsi_IIRO),\n    JSI_OPT(STRKEY,     jsi_wsPss, clientName,  .help=\"Client hostname\", jsi_IIRO),\n    JSI_OPT(BOOL,       jsi_wsPss, echo,        .help=\"LogInfo outputs all websock Send/Recv messages\"),\n    JSI_OPT(ARRAY,      jsi_wsPss, headers,     .help=\"Headers to send to browser on connection: name/value pairs\"),\n    JSI_OPT(BOOL,       jsi_wsPss, isWebsock,   .help=\"Is a websocket connection\" ),\n    JSI_OPT(STRBUF,     jsi_wsPss, key,         .help=\"String key lookup in ids command for SSI echo ${#}\", jsi_IIRO),\n    JSI_OPT(FUNC,       jsi_wsPss, onClose,     .help=\"Function to call when the websocket connection closes\", .flags=0, .custom=0, .data=(void*)\"ws:userobj|null, id:number\"),\n    JSI_OPT(FUNC,       jsi_wsPss, onGet,       .help=\"Function to call to server handle http-get\", .flags=0, .custom=0, .data=(void*)\"ws:userobj, id:number, url:string, query:array\"),\n    JSI_OPT(FUNC,       jsi_wsPss, onUnknown,   .help=\"Function to call to server out content when no file exists\", .flags=0, .custom=0, .data=(void*)\"ws:userobj, id:number, url:string, args:array\"),\n    JSI_OPT(FUNC,       jsi_wsPss, onRecv,      .help=\"Function to call when websock data recieved\", .flags=0, .custom=0, .data=(void*)\"ws:userobj, id:number, data:string\"),\n    JSI_OPT(FUNC,       jsi_wsPss, onUpload,    .help=\"Function to call handle http-post\", .flags=0, .custom=0, .data=(void*)\"ws:userobj, id:number, filename:string, data:string, startpos:number, complete:boolean\"),\n    JSI_OPT(STRING,     jsi_wsPss, rootdir,     .help=\"Directory to serve html from (\\\".\\\")\"),\n    JSI_OPT(CUSTOM,     jsi_wsPss, stats,       .help=\"Statistics for connection\", jsi_IIRO, .custom=Jsi_Opt_SwitchSuboption, .data=WPSStats),\n    JSI_OPT(ARRAY,      jsi_wsPss, query,       .help=\"Uri arg values for connection\"),\n    JSI_OPT(OBJ,        jsi_wsPss, queryObj,    .help=\"Uri arg values for connection as an object\"),\n    JSI_OPT(OBJ,        jsi_wsPss, udata,       .help=\"User data\"),\n    JSI_OPT(DSTRING,    jsi_wsPss, url,         .help=\"Url for connection\"),\n    JSI_OPT(STRING,     jsi_wsPss, username,    .help=\"The login userid for this connection\"),\n    JSI_OPT_END(jsi_wsPss, .help=\"Per-connection options\")\n};\n\nstatic Jsi_OptionSpec WSOptions[] =\n{\n    JSI_OPT(STRING, jsi_wsCmdObj, address,    .help=\"In client-mode the address to connect to (127.0.0.1)\" ),\n    JSI_OPT(INT,    jsi_wsCmdObj, bufferPwr2, .help=\"Tune the recv/send buffer: value is a power of 2 in [0-20] (16)\"),\n    JSI_OPT(BOOL,   jsi_wsCmdObj, client,     .help=\"Run in client mode\", jsi_IIOF),\n    JSI_OPT(STRKEY, jsi_wsCmdObj, clientHost, .help=\"Override host name for client\"),\n    JSI_OPT(STRKEY, jsi_wsCmdObj, clientOrigin,.help=\"Override client origin (origin)\"),\n    JSI_OPT(INT,    jsi_wsCmdObj, debug,      .help=\"Set debug level. Setting this to 512 will turn on max libwebsocket log levels\"),\n    JSI_OPT(BOOL,   jsi_wsCmdObj, echo,       .help=\"LogInfo outputs all websock Send/Recv messages\"),\n    JSI_OPT(STRKEY, jsi_wsCmdObj, formParams, .help=\"Comma seperated list of upload form param names ('text,send,file,upload')\", jsi_IIRO),\n    JSI_OPT(BOOL,   jsi_wsCmdObj, extHandlers,.help=\"Setup builtin extension-handlers, ie: .htmli, .cssi, .jsi, .mdi\", jsi_IIOF),\n    JSI_OPT(OBJ,    jsi_wsCmdObj, extOpts,    .help=\"Key/value store for extension-handlers options\", jsi_IIOF),\n    JSI_OPT(REGEXP, jsi_wsCmdObj, getRegexp,  .help=\"Call onGet() only if Url matches pattern\"),\n//    JSI_OPT(CUSTOM, jsi_wsCmdObj, handlersPkg,.help=\"Handlers use package() to upgrade string to function object\"),\n    JSI_OPT(ARRAY,  jsi_wsCmdObj, headers,    .help=\"Headers to send to browser: name/value pairs\", jsi_IIOF),\n    JSI_OPT(STRKEY, jsi_wsCmdObj, jsiFnPattern,.help=\"A glob-match pattern for files to which is appended 'window.jsiWebSocket=true;' (jsig*.js)\", jsi_IIRO),\n    JSI_OPT(STRING, jsi_wsCmdObj, interface,  .help=\"Interface for server to listen on, eg. 'eth0' or 'lo'\", jsi_IIOF),\n    JSI_OPT(BOOL,   jsi_wsCmdObj, local,      .help=\"Limit connections to localhost addresses on the 127 network\"),\n    JSI_OPT(STRKEY, jsi_wsCmdObj, localhostName,.help=\"Client name used by localhost connections ('localhost')\"),\n    JSI_OPT(INT,    jsi_wsCmdObj, maxConnects,.help=\"In server mode, max number of client connections accepted\"),\n    JSI_OPT(INT,    jsi_wsCmdObj, maxDownload,.help=\"Max size of file download\"),\n    JSI_OPT(INT,    jsi_wsCmdObj, maxUpload,  .help=\"Max size of file upload will accept\"),\n    JSI_OPT(OBJ,    jsi_wsCmdObj, mimeTypes,  .help=\"Object providing map of file extensions to mime types. eg. {txt:'text/plain', bb:'text/bb'}\", jsi_IIOF),\n    JSI_OPT(UINT,   jsi_wsCmdObj, modifySecs, .help=\"Seconds between checking for modified files with onModify (2)\"),\n    JSI_OPT(BOOL,   jsi_wsCmdObj, noConfig,   .help=\"Disable use of conf() to change options after options after create\", jsi_IIOF),\n    JSI_OPT(BOOL,   jsi_wsCmdObj, noCompress, .help=\"Disable per-message-deflate extension which can truncate large msgs\"),\n    JSI_OPT(BOOL,   jsi_wsCmdObj, noUpdate,   .help=\"Disable update event-processing (eg. to exit)\"),\n    JSI_OPT(BOOL,   jsi_wsCmdObj, noWebsock,  .help=\"Serve html, but disallow websocket upgrade\", jsi_IIOF),\n    JSI_OPT(BOOL,   jsi_wsCmdObj, noWarn,     .help=\"Quietly ignore file related errors\"),\n    JSI_OPT(FUNC,   jsi_wsCmdObj, onAuth,     .help=\"Function to call for http basic authentication\", .flags=0, .custom=0, .data=(void*)\"ws:userobj, id:number, url:string, userpass:string\"),\n    JSI_OPT(FUNC,   jsi_wsCmdObj, onClose,    .help=\"Function to call when the websocket connection closes\", .flags=0, .custom=0, .data=(void*)\"ws:userobj|null, id:number\"),\n    JSI_OPT(FUNC,   jsi_wsCmdObj, onCloseLast,.help=\"Function to call when last websock connection closes. On object delete arg is null\", .flags=0, .custom=0, .data=(void*)\"ws:userobj|null\"),\n    JSI_OPT(FUNC,   jsi_wsCmdObj, onFilter,   .help=\"Function to call on a new connection: return false to kill connection\", .flags=0, .custom=0, .data=(void*)\"ws:userobj, id:number, url:string, ishttp:boolean\"),\n    JSI_OPT(FUNC,   jsi_wsCmdObj, onGet,      .help=\"Function to call to server handle http-get\", .flags=0, .custom=0, .data=(void*)\"ws:userobj, id:number, url:string, query:array\"),\n    JSI_OPT(FUNC,   jsi_wsCmdObj, onModify,   .help=\"Function to call when a served-out-file is modified\", jsi_IIOF, .custom=0, .data=(void*)\"ws:userobj, file:string\"),\n    JSI_OPT(FUNC,   jsi_wsCmdObj, onOpen,     .help=\"Function to call when the websocket connection occurs\", .flags=0, .custom=0, .data=(void*)\"ws:userobj, id:number\"),\n    JSI_OPT(FUNC,   jsi_wsCmdObj, onUnknown,  .help=\"Function to call to server out content when no file exists\", .flags=0, .custom=0, .data=(void*)\"ws:userobj, id:number, url:string, query:array\"),\n    JSI_OPT(FUNC,   jsi_wsCmdObj, onUpload,   .help=\"Function to call handle http-post\", .flags=0, .custom=0, .data=(void*)\"ws:userobj, id:number, filename:string, data:string, startpos:number, complete:boolean\"),\n    JSI_OPT(FUNC,   jsi_wsCmdObj, onRecv,     .help=\"Function to call when websock data recieved\", .flags=0, .custom=0, .data=(void*)\"ws:userobj, id:number, data:string\"),\n    JSI_OPT(OBJ,    jsi_wsCmdObj, pathAliases,.help=\"Path alias lookups\", jsi_IIOF),\n    JSI_OPT(INT,    jsi_wsCmdObj, port,       .help=\"Port for server to listen on (8080)\", jsi_IIOF),\n    JSI_OPT(STRING, jsi_wsCmdObj, post,       .help=\"Post string to serve\", jsi_IIOF),\n    JSI_OPT(STRKEY, jsi_wsCmdObj, protocol,   .help=\"Name of protocol (ws/wss)\"),\n    JSI_OPT(STRKEY, jsi_wsCmdObj, realm,      .help=\"Realm for basic auth (jsish)\", ),\n    JSI_OPT(INT,    jsi_wsCmdObj, recvBufMax, .help=\"Size limit of a websocket message\", jsi_IIOF),\n    JSI_OPT(INT,    jsi_wsCmdObj, recvBufTimeout,.help=\"Timeout for recv of a websock msg\", jsi_IIOF),\n    JSI_OPT(BOOL,   jsi_wsCmdObj, redirMax,   .help=\"Temporarily disable redirects when see more than this in 10 minutes\"),\n    JSI_OPT(STRING, jsi_wsCmdObj, rootdir,    .help=\"Directory to serve html from (\\\".\\\")\"),\n    JSI_OPT(STRKEY, jsi_wsCmdObj, server,     .help=\"String to send out int the header SERVER (jsiWebSocket)\"),\n    JSI_OPT(OBJ,    jsi_wsCmdObj, ssiExts,    .help=\"Object map of file extensions to apply SSI.  eg. {myext:true, shtml:false} \", jsi_IIOF),\n    JSI_OPT(CUSTOM, jsi_wsCmdObj, stats,      .help=\"Statistical data\", jsi_IIRO, .custom=Jsi_Opt_SwitchSuboption, .data=WPSStats),\n    JSI_OPT(TIME_T, jsi_wsCmdObj, startTime,  .help=\"Time of websocket start\", jsi_IIRO),\n    JSI_OPT(STRKEY, jsi_wsCmdObj, includeFile,.help=\"Default file when no extension given (include.shtml)\"),\n    JSI_OPT(OBJ,    jsi_wsCmdObj, udata,      .help=\"User data\"),\n    JSI_OPT(STRKEY, jsi_wsCmdObj, urlPrefix,  .help=\"Prefix in url to strip from path; for reverse proxy\"),\n    JSI_OPT(STRKEY, jsi_wsCmdObj, urlRedirect,.help=\"Redirect when no url or / is given. Must match urlPrefix, if given\"),\n    JSI_OPT(BOOL,   jsi_wsCmdObj, use_ssl,    .help=\"Use https (for client)\", jsi_IIOF),\n    JSI_OPT(STRKEY, jsi_wsCmdObj, useridPass, .help=\"The USERID:PASSWORD to use for basic authentication\"),\n    JSI_OPT(OBJ,    jsi_wsCmdObj, version,    .help=\"WebSocket version info\", jsi_IIRO),\n    JSI_OPT_END(jsi_wsCmdObj, .help=\"Websocket options\")\n};\n\nstatic Jsi_RC jsi_wswebsocketObjFree(Jsi_Interp *interp, void *data);\nstatic bool jsi_wswebsocketObjIsTrue(void *data);\nstatic bool jsi_wswebsocketObjEqual(void *data1, void *data2);\nstatic void jsi_wswebsocketObjErase(jsi_wsCmdObj *cmdPtr);\n\n/* this protocol server (always the first one) just knows how to do HTTP */\n\nstatic int\njsi_wscallback_http(struct lws *wsi,\n      enum lws_callback_reasons reason,\n      void *user, void *in, size_t len);\nstatic int\njsi_wscallback_websock(struct lws *wsi,\n      enum lws_callback_reasons reason,\n      void *user, void *in, size_t len);\n      \nstatic Jsi_RC jsi_wsfreeFile(Jsi_Interp *interp, Jsi_HashEntry* hPtr, void *ptr);\nstatic bool jsi_wsAddHeader(Jsi_Interp *interp, jsi_wsCmdObj *cmdPtr, struct lws *wsi, Jsi_Value *hdrs,\n    Jsi_DString *hStr);\n    \n// Allocate per-connection data using file descriptor.\nstatic jsi_wsPss*\njsi_wsgetPss(jsi_wsCmdObj *cmdPtr, struct lws *wsi, void *user, int create, int ishttp)\n{\n    Jsi_HashEntry *hPtr;\n    bool isNew = 0;\n    jsi_wsPss *pss = NULL;\n    if (user==NULL)\n        return NULL;\n    int sfd = lws_get_socket_fd(wsi);\n    if (sfd<0) {\n        return NULL;\n    }\n    int sid = ((sfd<<1)|ishttp);\n    if (create)\n        hPtr = Jsi_HashEntryNew(cmdPtr->pssTable, (void*)(intptr_t)sid, &isNew);\n    else\n        hPtr = Jsi_HashEntryFind(cmdPtr->pssTable, (void*)(intptr_t)sid);\n\n    if (hPtr && !isNew)\n        pss = (typeof(pss))Jsi_HashValueGet(hPtr);\n\n    if (!pss) {\n        if (!create)\n            return NULL;\n        pss = (typeof(pss))Jsi_Calloc(1, sizeof(*pss));\n        Jsi_HashValueSet(hPtr, pss);\n        pss->sig = JWS_SIG_PWS;\n        pss->hPtr = hPtr;\n        Jsi_HashValueSet(hPtr, pss);\n        pss->cmdPtr = cmdPtr;\n        pss->wsi = wsi;\n        pss->user = user; /* unused. */\n        pss->state = PWS_CONNECTED;\n        pss->stats.createTime = time(NULL);\n        pss->cnt = cmdPtr->idx++;\n        pss->wid = sid;\n        //pss->sfd = sfd;\n        pss->udata = Jsi_ValueNewObj(cmdPtr->interp, NULL);\n        Jsi_IncrRefCount(cmdPtr->interp, pss->udata);\n\n        if (cmdPtr->debug>2)\n            fprintf(stderr, \"PSS CREATE: %p/%p/%p (http=%d) = %d\\n\", pss, user, wsi, ishttp, sid);\n        if (!ishttp) {\n            pss->isWebsock = 1;\n            cmdPtr->stats.connectCnt++;\n            cmdPtr->createCnt++;\n            cmdPtr->createLast = time(NULL);\n        }\n    }\n    if (pss) {\n        WSSIGASSERT(pss, PWS);\n        pss->stats.eventCnt++;\n        pss->stats.eventLast = time(NULL);\n        cmdPtr->stats.eventCnt++;\n        cmdPtr->stats.eventLast = time(NULL);\n    }\n    return pss;\n}\n\nstatic Jsi_RC jsi_wsDelPss(Jsi_Interp *interp, void *data) {\n    Jsi_Free(data);\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_wsrecv_flush(jsi_wsCmdObj *cmdPtr, jsi_wsPss *pss);\n\nstatic void\njsi_wsdeletePss(jsi_wsPss *pss)\n{\n    jsi_wsCmdObj*cmdPtr = pss->cmdPtr;\n    if (pss->sig == 0)\n        return;\n    WSSIGASSERT(pss, PWS);\n    if (pss->state == PWS_DEAD)\n        return;\n    if (cmdPtr && cmdPtr->debug>3)\n        fprintf(stderr, \"PSS DELETE: %p\\n\", pss);\n\n    jsi_wsrecv_flush(cmdPtr, pss);\n    if (pss->hPtr) {\n        Jsi_HashValueSet(pss->hPtr, NULL);\n        Jsi_HashEntryDelete(pss->hPtr);\n        pss->hPtr = NULL;\n    }\n    Jsi_Interp *interp = cmdPtr->interp;\n    if (pss->stack) {\n        Jsi_StackFreeElements(interp, pss->stack, jsi_wsDelPss);\n        Jsi_StackFree(pss->stack);\n    }\n    Jsi_DSFree(&pss->dHdrs);\n    if (pss->isWebsock)\n        pss->cmdPtr->stats.connectCnt--;\n    Jsi_OptionsFree(cmdPtr->interp, WPSOptions, pss, 0);\n    pss->state = PWS_DEAD;\n    Jsi_DSFree(&pss->resultStr);\n    Jsi_DSFree(&pss->paramDS);\n    if (pss->lastData)\n        Jsi_Free(pss->lastData);\n    pss->lastData = NULL;\n    if (pss->spa)\n        lws_spa_destroy(pss->spa);\n    Jsi_Free(pss);\n}\n\nstatic int jsi_wswrite(jsi_wsPss* pss, struct lws *wsi, unsigned char *buf, int len, enum lws_write_protocol proto)\n{\n    jsi_wsCmdObj *cmdPtr = pss->cmdPtr;\n    int m = lws_write(wsi, buf, len, proto);\n    if (m >= 0) {\n        cmdPtr->stats.sentCnt++;\n        cmdPtr->stats.sentLast = time(NULL);\n        pss->stats.sentCnt++;\n        pss->stats.sentLast = time(NULL);\n    } else {\n        pss->state = PWS_SENDERR;\n        pss->stats.sentErrCnt++;\n        pss->stats.sentErrLast = time(NULL);\n        cmdPtr->stats.sentErrCnt++;\n        cmdPtr->stats.sentErrLast = time(NULL);\n    }\n    return m;\n}\n\nstatic int jsi_wsServeHeader(jsi_wsPss *pss, struct lws *wsi, int strLen,\n    int code, const char *extra, const char *mime, Jsi_DString *jStr)\n{\n    uchar ubuf[JSI_BUFSIZ], *p=ubuf, *end = &ubuf[sizeof(ubuf)-1];\n    if (!mime) mime = \"text/html\";\n    if (code<=0) code = 200;\n    if (lws_add_http_header_status(wsi, code, &p, end))\n        return -1;\n    const char *srv = pss->cmdPtr->server;\n    if (!srv) srv = \"jsiWebSocket\";\n    if (srv[0] && lws_add_http_header_by_token(wsi, WSI_TOKEN_HTTP_SERVER, (uchar*)srv, Jsi_Strlen(srv), &p, end))\n        return -1;\n    if (lws_add_http_header_by_token(wsi, WSI_TOKEN_HTTP_CONTENT_TYPE, (uchar *)mime, Jsi_Strlen(mime), &p, end))\n        return -1;\n    if (lws_add_http_header_content_length(wsi, strLen, &p, end))\n        return -1;\n    *p = 0;\n    Jsi_DSAppend(jStr, (char*)ubuf, extra, NULL);\n    p = ubuf;\n    if (lws_finalize_http_header(wsi, &p, end))\n        return -1;\n    *p = 0;\n    Jsi_DSAppend(jStr, (char*)ubuf, NULL);\n    return 0;\n}\n\nstatic int jsi_wsServeString(jsi_wsPss *pss, struct lws *wsi,\n    const char *buf, int code, const char *extra, const char *mime)\n{\n    int strLen = Jsi_Strlen(buf);\n    Jsi_DString jStr = {};\n    int rc = jsi_wsServeHeader(pss, wsi, strLen, code, extra, mime, &jStr);\n    if (rc>=0) {\n        Jsi_DSAppend(&jStr, buf, NULL);\n        char *vStr = Jsi_DSValue(&jStr);\n        int vLen = Jsi_DSLength(&jStr);\n        rc = jsi_wswrite(pss, wsi, (unsigned char*)vStr, vLen, LWS_WRITE_HTTP);\n    }\n    Jsi_DSFree(&jStr);\n    return (rc>=0?1:0);\n}\n\nstatic const char*\njsi_wsHeader(jsi_wsPss *pss, const char *name, int *lenPtr)\n{\n    int i, nlen = Jsi_Strlen(name);\n    const char *ret = NULL, *cp = Jsi_DSValue(&pss->dHdrs);\n    for (i=0; i<pss->hdrNum; i+=2) {\n        int sz = pss->hdrSz[i];\n        int mat = (!Jsi_Strncasecmp(cp, name, nlen) && cp[nlen]=='=');\n        cp += 1 + sz;\n        if (mat) {\n            ret = cp;\n            if (lenPtr)\n                *lenPtr = pss->hdrSz[i+1];\n            break;\n        }\n        cp += (1 + pss->hdrSz[i+1]);\n    }\n    return ret;\n}\n\n\nstatic int\njsi_wsGetHeaders(jsi_wsPss *pss, struct lws *wsi, Jsi_DString* dStr, int lens[], int hmax)\n{\n    int n = 0, i = 0, nlen;\n    char buf[JSI_BUFSIZ];\n    const char *cp;\n    while ((cp = (char*)lws_token_to_string((enum lws_token_indexes)n))) {\n        int len = lws_hdr_copy(wsi, buf, sizeof(buf), ( enum lws_token_indexes)n);\n        n++;\n        if (i>=(n*2+2)) break;\n        if (len<=0) continue;\n        buf[sizeof(buf)-1] = 0;\n        if (!buf[0]) continue;\n        nlen = Jsi_Strlen(cp);\n        if (nlen>0 && cp[nlen-1]==' ') nlen--;\n        if (nlen>0 && cp[nlen-1]==':') nlen--;\n        Jsi_DSAppendLen(dStr, cp, nlen);\n        Jsi_DSAppend(dStr, \"=\", buf, \"\\n\", NULL);\n        if (lens) {\n            lens[i++] = nlen;\n            lens[i++] = Jsi_Strlen(buf);\n        }\n    }\n    //printf(\"HEE: %d = %s\\n\", pss->wid, Jsi_DSValue(dStr) );\n    return i;\n}\n\nstatic void jsi_wsDumpHeaders(jsi_wsCmdObj *cmdPtr, jsi_wsPss *pss, const char *name, Jsi_Value **ret)\n{\n    Jsi_Interp *interp = cmdPtr->interp;\n    Jsi_Obj *nobj;\n    Jsi_Value *nv;\n    if (pss->hdrNum<=0)\n        return;\n    if (!name) {\n        nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n        Jsi_ValueMakeObject(interp, ret, nobj);\n        int nsiz = Jsi_ObjArraySizer(interp, nobj, pss->hdrNum);\n        if (nsiz < pss->hdrNum) {\n            printf(\"header failed, %d != %d\", nsiz, pss->hdrNum);\n            return;\n        }\n    }\n    Jsi_DString dStr = {}, vStr = {};\n    int i;\n    const char *nam, *val, *cp = Jsi_DSValue(&pss->dHdrs);\n    for (i=0; i<pss->hdrNum; i+=2) {\n        int sz = pss->hdrSz[i], sz2 = pss->hdrSz[i+1];\n        Jsi_DSSetLength(&dStr, 0);\n        Jsi_DSSetLength(&vStr, 0);\n        nam = Jsi_DSAppendLen(&dStr, cp, sz);\n        cp += 1 + sz;\n        val = Jsi_DSAppendLen(&vStr, cp, sz2);\n        if (name) {\n            if (!Jsi_Strcmp(nam, name)) {\n                Jsi_ValueMakeStringDup(interp, ret, val);\n                break;\n            }\n        } else {\n            nv = Jsi_ValueNewStringDup(interp, val);\n            Jsi_ObjArraySet(interp, nobj, Jsi_ValueNewStringDup(interp, nam), i);\n            Jsi_ObjArraySet(interp, nobj, nv, i+1);\n        }\n        cp += (1 + sz2);\n    }\n    Jsi_DSFree(&dStr);\n    Jsi_DSFree(&vStr);\n}\n\nstatic void jsi_wsDumpQuery(jsi_wsCmdObj *cmdPtr, jsi_wsPss *pss, const char *name, Jsi_Value **ret)\n{\n    int n = 0;\n    Jsi_Interp *interp = cmdPtr->interp;\n    Jsi_Obj *nobj;\n    Jsi_Value *nv;\n    if (!name) {\n        nobj = Jsi_ObjNewType(interp, JSI_OT_OBJECT);\n        Jsi_ValueMakeObject(interp, ret, nobj);\n    }\n    for (n = 0; n<pss->paramc; n++) {\n        const char *cp = lws_spa_get_string(pss->spa, n);\n        if (!cp) cp = \"\";\n        if (name) {\n            if (Jsi_Strcmp(name, pss->paramv[n])) { n++; continue; }\n            Jsi_ValueMakeStringDup(interp, ret, cp);\n            return;\n        }\n        nv = Jsi_ValueNewStringDup(interp, cp);\n        Jsi_ObjInsert(interp, nobj, pss->paramv[n], nv, 0);\n    }\n}\n\nstatic void jsi_wsgetUriArgValue(Jsi_Interp *interp, struct lws *wsi, Jsi_Value **vPtr, Jsi_Value **oPtr)\n{\n    int n = 0;\n    char buf[JSI_BUFSIZ*8];\n    while (lws_hdr_copy_fragment(wsi, buf, sizeof(buf), WSI_TOKEN_HTTP_URI_ARGS, n++) > 0) {\n        if (!*vPtr) {\n            *vPtr = Jsi_ValueNewArray(interp, NULL, 0);\n            Jsi_IncrRefCount(interp, *vPtr);\n        }\n        Jsi_ValueArraySet(interp, *vPtr, Jsi_ValueNewStringDup(interp, buf), n-1);\n        if (!*oPtr) {\n            *oPtr = Jsi_ValueNewObj(interp, NULL);\n            Jsi_IncrRefCount(interp, *oPtr);\n        }\n        char *cp = Jsi_Strchr(buf, '=');\n        if (cp) {\n            *cp = 0;\n            Jsi_ValueInsertFixed(interp, *oPtr, buf, Jsi_ValueNewStringDup(interp, cp+1));\n        } else {\n            Jsi_ValueInsertFixed(interp, *oPtr, buf, Jsi_ValueNewNull(interp));\n        }\n    }\n}\n\nstatic Jsi_RC jsi_wsGetCmd(Jsi_Interp *interp, jsi_wsCmdObj *cmdPtr, jsi_wsPss* pss, struct lws *wsi,\n    const char *inPtr, Jsi_Value *cmd, Jsi_DString *tStr)\n{\n    Jsi_RC jrc;\n    Jsi_Value *retStr = Jsi_ValueNew1(interp);\n    // 4 args: ws, id, url, query\n    Jsi_Value *vpargs, *vargs[10];\n    int n = 0;\n    if (cmdPtr->deleted) return JSI_ERROR;\n    vargs[n++] = Jsi_ValueNewObj(interp, cmdPtr->fobj);\n    vargs[n++] = Jsi_ValueNewNumber(interp, (Jsi_Number)(pss?pss->wid:0));\n    vargs[n++]  = Jsi_ValueNewStringDup(interp, inPtr);\n    vargs[n++]  = (pss->query?pss->query:Jsi_ValueNewArray(interp, NULL, 0));\n    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, vargs, n, 0));\n    Jsi_IncrRefCount(interp, vpargs);\n    jrc = Jsi_FunctionInvoke(interp, cmd, vpargs, &retStr, NULL);\n    Jsi_DecrRefCount(interp, vpargs);\n    if (Jsi_InterpGone(interp))\n        return JSI_ERROR;\n    Jsi_DString dStr = {};\n    const char *rstr = \"\";\n    if (jrc != JSI_OK)\n        rstr = \"Error\";\n    else if (Jsi_ValueIsFalse(interp, retStr)) {\n        rstr = \"Access denied\";\n        jrc = JSI_ERROR;\n    } else\n        rstr = Jsi_ValueString(interp, retStr, NULL);\n    if (rstr && tStr && Jsi_Strncmp(rstr, \"!!!\", 3)==0) {\n        Jsi_DSAppend(tStr, rstr+3, NULL);\n        jrc = JSI_CONTINUE;\n    } else if (rstr && tStr && Jsi_Strncmp(rstr, \">>>\", 3)==0) {\n        Jsi_DSAppend(tStr, rstr+3, NULL);\n        jrc = JSI_SIGNAL;\n    } else if (rstr && rstr[0] != 0)\n        jsi_wsServeString(pss, wsi, rstr, jrc==JSI_OK?0:404, NULL, NULL);\n    else\n        jrc = JSI_BREAK;\n    Jsi_DecrRefCount(interp, retStr);\n    Jsi_DSFree(&dStr);\n    return jrc;\n}\n\nstatic const char* jsw_getReasonStr(enum lws_callback_reasons reason) {\n    typedef struct { enum lws_callback_reasons r; const char *name; } ssType;\n    static ssType ss[] = {\n#define MKLCBS(n) { n, #n }\n    MKLCBS(LWS_CALLBACK_PROTOCOL_INIT),\n    MKLCBS(LWS_CALLBACK_PROTOCOL_DESTROY), MKLCBS(LWS_CALLBACK_WSI_CREATE),\n    MKLCBS(LWS_CALLBACK_WSI_DESTROY),MKLCBS(LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS),\n    MKLCBS(LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS),\n    MKLCBS(LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION),\n    MKLCBS(LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY),\n    MKLCBS(LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED), MKLCBS(LWS_CALLBACK_HTTP),\n    MKLCBS(LWS_CALLBACK_HTTP_BODY), MKLCBS(LWS_CALLBACK_HTTP_BODY_COMPLETION),\n    MKLCBS(LWS_CALLBACK_HTTP_FILE_COMPLETION), MKLCBS(LWS_CALLBACK_HTTP_WRITEABLE),\n    MKLCBS(LWS_CALLBACK_CLOSED_HTTP), MKLCBS(LWS_CALLBACK_FILTER_HTTP_CONNECTION),\n    MKLCBS(LWS_CALLBACK_ESTABLISHED),\n    MKLCBS(LWS_CALLBACK_CLOSED),\n    MKLCBS(LWS_CALLBACK_SERVER_WRITEABLE),\n    MKLCBS(LWS_CALLBACK_RECEIVE), MKLCBS(LWS_CALLBACK_RECEIVE_PONG),\n    MKLCBS(LWS_CALLBACK_WS_PEER_INITIATED_CLOSE), MKLCBS(LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION),\n    MKLCBS(LWS_CALLBACK_CONFIRM_EXTENSION_OKAY),\n    MKLCBS(LWS_CALLBACK_CLIENT_CONNECTION_ERROR),\n    MKLCBS(LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH), MKLCBS(LWS_CALLBACK_CLIENT_ESTABLISHED),\n    MKLCBS(LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER), MKLCBS(LWS_CALLBACK_CLIENT_RECEIVE),\n    MKLCBS(LWS_CALLBACK_CLIENT_RECEIVE_PONG),\n    MKLCBS(LWS_CALLBACK_CLIENT_WRITEABLE), MKLCBS(LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED),\n    MKLCBS(LWS_CALLBACK_WS_EXT_DEFAULTS), MKLCBS(LWS_CALLBACK_FILTER_NETWORK_CONNECTION),\n    MKLCBS(LWS_CALLBACK_GET_THREAD_ID), MKLCBS(LWS_CALLBACK_ADD_POLL_FD),\n    MKLCBS(LWS_CALLBACK_DEL_POLL_FD), MKLCBS(LWS_CALLBACK_CHANGE_MODE_POLL_FD), MKLCBS(LWS_CALLBACK_LOCK_POLL),\n    MKLCBS(LWS_CALLBACK_UNLOCK_POLL),\n#if (LWS_LIBRARY_VERSION_MAJOR>1)\n    MKLCBS(LWS_CALLBACK_CGI),\n    MKLCBS(LWS_CALLBACK_CGI_TERMINATED),\n    MKLCBS(LWS_CALLBACK_CGI_STDIN_DATA),\n    MKLCBS(LWS_CALLBACK_CGI_STDIN_COMPLETED),\n    MKLCBS(LWS_CALLBACK_SESSION_INFO),\n    MKLCBS(LWS_CALLBACK_GS_EVENT),\n    MKLCBS(LWS_CALLBACK_HTTP_PMO),\n    MKLCBS(LWS_CALLBACK_RAW_RX),\n    MKLCBS(LWS_CALLBACK_RAW_CLOSE),\n    MKLCBS(LWS_CALLBACK_RAW_WRITEABLE),\n    MKLCBS(LWS_CALLBACK_RAW_ADOPT),\n    MKLCBS(LWS_CALLBACK_RAW_ADOPT_FILE),\n    MKLCBS(LWS_CALLBACK_ADD_HEADERS),\n    MKLCBS(LWS_CALLBACK_CHECK_ACCESS_RIGHTS),\n    MKLCBS(LWS_CALLBACK_PROCESS_HTML),\n    MKLCBS(LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP),\n    MKLCBS(LWS_CALLBACK_CLOSED_CLIENT_HTTP),\n    MKLCBS(LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ),\n    MKLCBS(LWS_CALLBACK_RECEIVE_CLIENT_HTTP),\n    MKLCBS(LWS_CALLBACK_COMPLETED_CLIENT_HTTP),\n    MKLCBS(LWS_CALLBACK_CLIENT_HTTP_WRITEABLE),\n    MKLCBS(LWS_CALLBACK_HTTP_BIND_PROTOCOL),\n    MKLCBS(LWS_CALLBACK_HTTP_DROP_PROTOCOL),\n    MKLCBS(LWS_CALLBACK_OPENSSL_PERFORM_SERVER_CERT_VERIFICATION),\n    MKLCBS(LWS_CALLBACK_RAW_RX_FILE),\n    MKLCBS(LWS_CALLBACK_RAW_WRITEABLE_FILE),\n    MKLCBS(LWS_CALLBACK_RAW_CLOSE_FILE),\n    MKLCBS(LWS_CALLBACK_USER),\n#endif\n#if (LWS_LIBRARY_VERSION_NUMBER>=3000000)\n    MKLCBS(LWS_CALLBACK_SSL_INFO),\n    MKLCBS(LWS_CALLBACK_CGI_PROCESS_ATTACH),\n    MKLCBS(LWS_CALLBACK_CLIENT_CLOSED),\n    MKLCBS(LWS_CALLBACK_TIMER),\n    MKLCBS(LWS_CALLBACK_EVENT_WAIT_CANCELLED),\n    MKLCBS(LWS_CALLBACK_CHILD_CLOSING),\n    MKLCBS(LWS_CALLBACK_CHILD_WRITE_VIA_PARENT),\n    MKLCBS(LWS_CALLBACK_VHOST_CERT_AGING),\n    MKLCBS(LWS_CALLBACK_VHOST_CERT_UPDATE),\n#endif\n    {(enum lws_callback_reasons)0, NULL }\n    };\n    int i = -1;\n    while (ss[++i].name)\n        if (ss[i].r == reason)\n            return ss[i].name;\n    return \"\";\n}\n\nstatic bool jsi_wsAddHeader(Jsi_Interp *interp, jsi_wsCmdObj *cmdPtr, struct lws *wsi, Jsi_Value *hdrs,\n    Jsi_DString *hStr) {\n    uchar buffer[JSI_BUFSIZ];\n    uchar *p = (unsigned char *)buffer, *end = p + sizeof(buffer);\n    int n = 0;\n    int i, hvl, argc = Jsi_ValueGetLength(interp, hdrs);\n    for (i=0; i<argc; i+=2) {\n        const char *hn = Jsi_ValueArrayIndexToStr(interp, hdrs, i, NULL),\n            *hv = Jsi_ValueArrayIndexToStr(interp, hdrs, i+1, &hvl);\n        if (hn && hv) {\n            if (lws_add_http_header_by_name(wsi, (const uchar *)hn, (const uchar *)hv, hvl, &p, end))\n                return false;\n            n = p - buffer;\n            if (n>0)\n                Jsi_DSAppendLen(hStr, (char*)buffer, n);\n            p = buffer;\n        }\n    }\n    return true;\n}\n\nstatic bool jsi_wsAddStdHeader(Jsi_Interp *interp, jsi_wsCmdObj *cmdPtr, struct lws *wsi,    Jsi_DString *hStr) {\n    uchar buffer[JSI_BUFSIZ];\n    uchar *p = (unsigned char *)buffer, *end = p + sizeof(buffer);\n    const char *srv = cmdPtr->server;\n    if (!srv) srv = \"jsiWebSocket\";\n    int n = 0;\n    if (srv[0] && lws_add_http_header_by_token(wsi, WSI_TOKEN_HTTP_SERVER, (uchar*)srv, Jsi_Strlen(srv), &p, end))\n        return false;\n    n = p - buffer;\n    if (n>0) {\n        Jsi_DSAppendLen(hStr, (char*)buffer, n);\n        p = buffer;\n    }\n    return true;\n}\n\nstatic Jsi_RC jsi_wsFileAdd(Jsi_Interp *interp, jsi_wsCmdObj *cmdPtr, Jsi_Value *name) {\n    const char *sname = Jsi_ValueString(interp, name, NULL);\n    if (cmdPtr->onModify && sname) {\n        bool isNew = 0;\n        Jsi_HashEntry *hPtr = Jsi_HashEntryNew(cmdPtr->fileHash, sname, &isNew);\n        if (hPtr) {\n            jsi_wsFile* fPtr;\n            if (!isNew)\n                fPtr = Jsi_HashValueGet(hPtr);\n            else {\n                fPtr = (jsi_wsFile *)Jsi_Calloc(1, sizeof(*fPtr));\n                fPtr->fileVal = name;\n                fPtr->loadFirst = time(NULL);\n                Jsi_IncrRefCount(interp, name);\n                fPtr->flags = 0;\n                Jsi_HashValueSet(hPtr, fPtr);\n            }\n            fPtr->loadLast = time(NULL);\n        }\n    }\n    return JSI_OK;\n}\n\n// Read only native files inside the rootdir.\nstatic Jsi_RC jsi_wsFileRead(Jsi_Interp *interp, Jsi_Value *name, Jsi_DString *dStr, jsi_wsCmdObj *cmdPtr, jsi_wsPss *pss) {\n    Jsi_StatBuf sb;\n    Jsi_RC rc = JSI_ERROR;\n    int n = Jsi_Stat(interp, name, &sb);\n    if (!n && sb.st_size>0) {\n        char fdir[PATH_MAX];\n        const char* cr = cmdPtr->curRoot, *fpath=NULL;\n        if (!Jsi_FSNative(interp, name) || ((fpath= Jsi_Realpath(interp, name, fdir))\n            && cr && !Jsi_Strncmp(fpath, cr, Jsi_Strlen(cr)))) {\n            rc = Jsi_FileRead(interp, name, dStr);\n            if (rc == JSI_OK && cmdPtr->onModify && Jsi_FSNative(interp, name))\n                jsi_wsFileAdd(interp, cmdPtr, name);\n        } else\n            fprintf(stderr, \"Skip read file %s in %s\\n\", Jsi_ValueString(interp, name, NULL), (cr?cr:\"\"));\n    }\n    if (cmdPtr->noWarn)\n        return JSI_OK;\n    return rc;\n}\n\nstatic bool jsi_wsIsSSIExt(Jsi_Interp *interp, jsi_wsCmdObj *cmdPtr, jsi_wsPss *pss, const char *ext) {\n    if (cmdPtr->ssiExts) {\n        Jsi_Value *mVal = Jsi_ValueObjLookup(interp, cmdPtr->ssiExts, ext, 1);\n        if (mVal) {\n            bool b = 0;\n            if (Jsi_ValueGetBoolean(interp, mVal, &b) != JSI_OK) {\n                Jsi_LogWarn(\"expected bool for ssiExts '%s': disabling all\\n\", ext);\n                Jsi_DecrRefCount(interp, cmdPtr->ssiExts);\n                cmdPtr->ssiExts = NULL;\n            }\n            return b;\n        }\n    }\n    if (ext[0]=='s'  && (!Jsi_Strcmp(ext, \"shtml\")\n        || !Jsi_Strcmp(ext, \"scss\") || !Jsi_Strcmp(ext, \"sjs\")))\n        return 1;\n\n    return 0;\n}\n\n// Support the limited nonstandard SSI: #include, #if, #elif#, #else, #endif\n// No expr, just var lookup from query/udata.  And can not nest #if in same file.\nstatic Jsi_RC jsi_wsEvalSSI(Jsi_Interp *interp, jsi_wsCmdObj *cmdPtr, Jsi_Value *fn, Jsi_DString *dStr,\n    int lvl, jsi_wsPss *pss) {\n    int flen, rlen;\n    char fbuf[PATH_MAX];\n    char *fs, *fname = Jsi_ValueString(interp, fn, &flen), *fend = fname;\n    if (lvl>10 || !fname || !pss)\n        return JSI_ERROR;\n    Jsi_Value *fval;\n    Jsi_RC rc = JSI_OK;\n    Jsi_DString tStr = {}, lStr = {};\n    const char *cs = NULL;\n    char *root = Jsi_ValueString(interp, cmdPtr->rootdir, &rlen);\n    if (!Jsi_Strncmp(root, fname, rlen))\n        fname = fname + rlen;\n    fs = Jsi_Strrchr(fname, '/');\n    if (fs) {\n        flen = fs-fname;\n        fend = fs+1;\n    }\n    if (lvl>0) {\n        rc = jsi_wsFileRead(interp, fn, &tStr, cmdPtr, pss);\n        cs = Jsi_DSValue(&tStr);\n    } else {\n        snprintf(fbuf, sizeof(fbuf), \"%s/%.*s/%s\", root, flen, fname, cmdPtr->includeFile);\n        fval = Jsi_ValueNewStringConst(interp, fbuf, -1);\n        Jsi_IncrRefCount(interp, fval);\n        rc = jsi_wsFileRead(interp, fval, &tStr, cmdPtr, pss);\n        if (rc == JSI_OK)\n            cs = Jsi_DSValue(&tStr);\n        Jsi_DecrRefCount(interp, fval);\n    }\n    \n    char *cp, *sp, *se, pref[] = \"<!--#\", suffix[] = \"-->\", *msg = NULL;\n    struct {\n        int inif, inelse, matched, elide;\n    } II[11] = {};\n    const int maxNest = 10;\n    int ii = 0;\n    int plen = 5, elen, llen;\n\n    while (rc == JSI_OK && cs) {\n        char *ext = NULL, *sfname = fname;\n        int sflen = flen;\n        sp = Jsi_Strstr(cs, pref);\n        if (!sp || !(se=Jsi_Strstr(sp+plen, suffix))) {\n            Jsi_DSAppend(dStr, cs, NULL);\n            break;\n        }\n        sp += plen-1;\n        llen = se-sp;\n        Jsi_DSSetLength(&lStr, 0);\n        cp = Jsi_DSAppendLen(&lStr, sp, llen);\n        if (Jsi_Strchr(cp, '\\n')) { rc = Jsi_LogError(\"unexpected newline in directive \\\"%.10s\\\"\", cp); break; }\n        if (!II[ii].elide)\n            Jsi_DSAppendLen(dStr, cs, sp-cs-4);\n        \n        if (!Jsi_Strncmp(cp, \"#include file=\\\"\", 12) || !Jsi_Strncmp(cp, \"#include virtual=\\\"\", 15)) {\n            if (cp[llen-1] != '\"' || cp[llen-2] == '=') { msg = \"missing end quote in\"; break; }\n            if (!II[ii].elide) {\n                Jsi_DSSetLength(&lStr, llen-1);\n                int isvirt = (cp[9]=='v');\n                cp += (isvirt ? 18 : 15);\n                if (cp[0] == '$' && lvl == 0) { // substitute file suffix\n                    char sfx[20] = {};\n                    uint i;\n                    for (i=0; i<sizeof(sfx); i++) {\n                        if ((sfx[i] = cp[i+1]) == '\"' || !sfx[i]) {\n                            sfx[i] = 0;\n                            break;\n                        }\n                    }\n                    snprintf(fbuf, sizeof(fbuf), \"%s/%.*s/%s/%s%s\", root, flen, fname, sfx, fend, sfx);\n                } else {\n                    snprintf(fbuf, sizeof(fbuf), \"%s/%.*s/%s\", root, sflen, sfname, cp);\n                    ext = Jsi_Strrchr(fbuf, '.');\n                }\n                fval = Jsi_ValueNewStringConst(interp, fbuf, -1);\n                Jsi_IncrRefCount(interp, fval);\n                if (!ext || ext[0] != '.' || !jsi_wsIsSSIExt(interp, cmdPtr, pss, ext+1))\n                    rc = jsi_wsFileRead(interp, fval, dStr, cmdPtr, pss);\n                else\n                    rc = jsi_wsEvalSSI(interp, cmdPtr, fval, dStr, lvl+1, pss);\n                if (cmdPtr->noWarn)\n                    rc = JSI_OK;\n                Jsi_DecrRefCount(interp, fval);\n            }\n        } else if (!Jsi_Strncmp(cp, \"#echo \\\"${\", 9)) {\n            if (cp[llen-1] != '\"' || cp[llen-2] != '}') { msg = \"missing end quote\"; break; }\n            Jsi_DSSetLength(&lStr, llen-2);\n            cp += 9;\n            llen -= 9;\n            if (!Jsi_Strcmp(cp, \"#\")) {\n                if (!pss->key[0])\n                    snprintf(pss->key, sizeof(pss->key), \"%d%p%d\", pss->wid, pss, (int)cmdPtr->startTime);\n                Jsi_DSPrintf(dStr, \"'%s'\", pss->key);\n            } else {\n                Jsi_Value *val = NULL;\n                if (!cmdPtr->udata) {\n                    val = Jsi_ValueObjLookup(interp, cmdPtr->udata, cp, 0);\n                    if (!val) { msg = \"udata lookup failure\"; break; }\n                    cp = Jsi_ValueString(interp, val, NULL);\n                    Jsi_DSPrintf(dStr, \"'%s'\", cp);\n                }\n            }\n\n        } else if (!Jsi_Strncmp(cp, \"#if expr=\\\"\", 10) || !Jsi_Strncmp(cp, \"#elif expr=\\\"\", 12)) {\n            if (llen<11 || cp[llen-1] != '\"' || cp[llen-2] == '=') { msg = \"missing end quote\"; break; }\n            Jsi_DSSetLength(&lStr, llen-1);\n            bool iselif = (cp[1]=='e');\n            cp += (iselif?12:10);\n            if (!iselif) {\n                if (II[ii].inif) {\n                    if ((ii+1)>=maxNest) { msg = \"nested \\\"#if\\\" too deep\"; break; }\n                    ii++;\n                    II[ii] = II[maxNest];\n                    II[ii].elide = II[ii-1].elide;\n                }\n                II[ii].inif = 1;\n            } else {\n                if (!II[ii].inif) { msg = \"unexpected \\\"#elif\\\"\"; break; }\n            }\n            elen = Jsi_Strlen(cp);\n            if (elen<4|| cp[0] != '$' || cp[1] != '{' || cp[elen-1] != '}') {\n                msg = \"expr must be of form ${X}\"; break;\n            }\n            Jsi_DSSetLength(&lStr, llen-2);\n            cp += 2;\n            // Extract modifiers before bool var name to lookup.\n            bool warn = 0, req = 0, nifval = 0, not = 0, isq=0, isu=0, qfirst=0;\n            while (*cp &&  !isalpha(*cp)) {\n                bool fail = 0;\n                switch (*cp) {\n                    case '~': qfirst = 1; break;\n                    case ':': isu = 1; break;\n                    case '?': isq = 1; break;\n                    case '@': warn = !II[ii].matched; break;\n                    case '*': req = !II[ii].matched; break;\n                    case '!': not = 1; break;\n                    default: fail=1; break;\n                }\n                if (fail) { msg = \"modifier must be one of: !:=?@*\"; break; }\n                cp++;\n            }\n            Jsi_Value *val = NULL;\n            if (!val && qfirst && pss->queryObj)\n                val = Jsi_ValueObjLookup(interp, pss->queryObj, cp, 0);\n            if (!val && !isq && cmdPtr->udata)\n                val = Jsi_ValueObjLookup(interp, cmdPtr->udata, cp, 0);\n            if (!val && !qfirst && !isu && pss->queryObj)\n                val = Jsi_ValueObjLookup(interp, pss->queryObj, cp, 0);\n            if (!val) {\n                if (req) { msg = \"symbol not found\"; break; }\n                if (warn) Jsi_LogWarn(\"symbol \\\"%s\\\" not found: %s\", cp, fbuf);\n            } else if (Jsi_ValueGetBoolean(interp, val, &nifval) != JSI_OK) {\n                const char *valStr = NULL;\n                if (val) valStr = Jsi_ValueString(interp, val, NULL);\n                if (!valStr || Jsi_GetBool(interp, valStr, &nifval) != JSI_OK) {\n                    if (!warn) { msg = \"symbol not a boolean\"; break; }\n                    Jsi_LogWarn(\"symbol \\\"%s\\\" should be a boolean: %s\", cp, fbuf);\n                }\n            }\n            if (not) nifval = !nifval;\n            if (!iselif) {\n                if (nifval)\n                    II[ii].matched = 1;\n                else\n                    II[ii].elide = 1;\n            } else {\n                if (II[ii].matched || !nifval)\n                    II[ii].elide = 1;\n                else if (nifval) {\n                    II[ii].matched = 1;\n                    II[ii].elide = (ii?II[ii-1].elide:0);\n                }\n            }\n        } else if (!Jsi_Strncmp(cp, \"#else\", 5)) {\n            if (!II[ii].inif || II[ii].inelse) { msg = \"unexpected \\\"#else\\\"\"; break; }\n            II[ii].inelse = 1;\n            II[ii].elide = (ii&&II[ii-1].elide?1:II[ii].matched);\n        } else if (!Jsi_Strncmp(cp, \"#endif\", 6)) {\n            if (!II[ii].inif) { msg = \"unexpected \\\"#endif\\\"\";  break; }\n            II[ii].inelse = II[ii].inif = II[ii].elide = II[ii].matched = 0;\n            if (ii>0)\n                ii--;\n        } else {\n            msg = \"expected directive #include/#if/#elif/#else/#endif\";\n            break;\n        }\n        cs = se + 3;\n        if (*cs == '\\n')\n            cs++;\n    }\n    if (rc == JSI_OK && II[ii].inif && !msg) {\n         msg = \"missing \\\"#endif\\\"\";\n         sp = \"\";\n    }\n    if (msg) {\n        while (*fname=='/') fname++;\n        rc = Jsi_LogError(\"SHTML Error in \\\"%s\\\": %s: at \\\"%.40s\\\" \", fname, msg, sp);\n    }\n    Jsi_DSFree(&tStr);\n    Jsi_DSFree(&lStr);\n    return rc;\n\n}\n\nstatic void jsi_wsPathAlias(Jsi_Interp *interp, jsi_wsCmdObj *cmdPtr, const char **inPtr, Jsi_DString *dStr) {\n    const char *ce, *cp = NULL;\n    char *lcp;\n    Jsi_Value *val;\n    if (cmdPtr->pathAliases) {\n        cp = *inPtr;\n        if (*cp == '/') cp++;\n        if ((ce = Jsi_Strchr(cp, '/'))) {\n            int len = ce-cp;\n            Jsi_DSSetLength(dStr, 0);\n            Jsi_DSAppendLen(dStr, cp, len);\n            cp = Jsi_DSValue(dStr);\n            if ((val = Jsi_ValueObjLookup(interp, cmdPtr->pathAliases, cp, 0)) &&\n                (cp = Jsi_ValueString(interp, val, NULL))) {\n                *inPtr += (len+2);\n                cmdPtr->curRoot = cp;\n                return;\n            }\n        }\n    }\n    if (!Jsi_Strncmp(*inPtr, \"/jsi/\", 5)) {\n        // Get/cache path for system load file, eg /zvfs/lib/Jsish.jsi.\n        if (!(cp = cmdPtr->jsishPathCache)) {\n            Jsi_PkgRequire(interp, \"Jsish\", 0);\n            if (Jsi_PkgVersion(interp, \"Jsish\", &cp)>=0)\n                cmdPtr->jsishPathCache = cp;\n        }\n        if (cp) {\n            Jsi_DSSetLength(dStr, 0);\n            Jsi_DSAppend(dStr, cp, NULL);\n            cp = Jsi_DSValue(dStr);\n            if ((lcp = Jsi_Strrchr(cp, '/'))) {\n                *lcp = 0;\n                *inPtr += 5;\n                cmdPtr->curRoot = cp;\n            }\n        }\n    }\n}\n\nstatic Jsi_RC WebSocketUnaliasCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    jsi_wsCmdObj *cmdPtr = (jsi_wsCmdObj*)Jsi_UserObjGetData(interp, _this, funcPtr);\n    if (!cmdPtr)\n        return Jsi_LogError(\"Apply to non-websock object\");\n    int vlen, nlen;\n    const char *kstr, *vstr, *nstr = Jsi_ValueArrayIndexToStr(interp, args, 0, &nlen);\n    if (!nstr)\n        return Jsi_LogError(\"arg 1: expected string\");\n    Jsi_Value *v, *a = cmdPtr->pathAliases;\n    if (!a|| !Jsi_ValueIsObjType(interp, a, JSI_OT_OBJECT)) return JSI_OK;\n    Jsi_IterObj *io = Jsi_IterObjNew(interp, NULL);\n    Jsi_IterGetKeys(interp, cmdPtr->pathAliases, io, 0);\n    uint i;\n    for (i=0; i<io->count; i++) {\n        kstr = io->keys[i];\n        v = Jsi_ValueObjLookup(interp, a, kstr, 1);\n        if (!v) continue;\n        vstr = Jsi_ValueToString(interp, v, &vlen);\n        if (!vstr) continue;\n        if (nlen<=vlen) continue;\n        if (Jsi_Strncmp(vstr, nstr, vlen)) continue;\n        Jsi_DString dStr = {};\n        Jsi_DSAppend(&dStr, \"/\", kstr, nstr+vlen, NULL);\n        Jsi_ValueFromDS(interp, &dStr, ret);\n        break;\n    }\n    Jsi_IterObjFree(io);\n    return JSI_OK;\n}\n\nint\njsi_ws_http_redirect(struct lws *wsi, int code, Jsi_DString *tStr, \n                  unsigned char **p, unsigned char *end)\n{\n    char *loc = Jsi_DSValue(tStr);\n    uchar *start = *p;\n    char* cookie = Jsi_Strchr(loc, '|');\n    if (cookie) { *cookie= 0; cookie++; }\n\n    if (lws_add_http_header_status(wsi, code, p, end)\n        || lws_add_http_header_by_token(wsi, WSI_TOKEN_HTTP_LOCATION, (uchar *)loc, Jsi_Strlen(loc), p, end)\n        || lws_add_http_header_by_token(wsi, WSI_TOKEN_HTTP_CONTENT_TYPE,(uchar *)\"text/html\", 9, p,end)\n        || lws_add_http_header_by_token(wsi, WSI_TOKEN_HTTP_CONTENT_LENGTH, (uchar *)\"0\", 1, p, end))\n        return -1;\n    if (cookie && lws_add_http_header_by_token(wsi, WSI_TOKEN_HTTP_SET_COOKIE, (uchar *)cookie, Jsi_Strlen(cookie), p, end))\n        return -1;\n    if (lws_finalize_http_header(wsi, p, end))\n        return -1;\n    return lws_write(wsi, start, *p - start, LWS_WRITE_HTTP_HEADERS);\n}\n\n// Handle http GET/POST\nstatic int jsi_wsHttp(Jsi_Interp *interp, jsi_wsCmdObj *cmdPtr, struct lws *wsi, void *user,\n    struct lws_context *context, const char* inPtr, Jsi_DString *tStr, jsi_wsPss *pss)\n{\n    const char *ext = NULL;\n    unsigned char buffer[JSI_BUFSIZ];\n    const char *mime = NULL;\n    time_t now = time(NULL);\n    char buf[JSI_BUFSIZ];\n    int rc = 0;\n    buf[0] = 0;\n    uchar *p = buffer, *end = &buffer[sizeof(buffer)-1];\n    int n;\n    Jsi_Value* fname = NULL;\n    bool isJsiWeb = 0, isSSI = 0;\n    cmdPtr->stats.httpLast = now;\n    \n    /* if a legal POST URL, let it continue and accept data */\n    if (lws_hdr_total_length(wsi, WSI_TOKEN_POST_URI))\n        return 0;\n    if (!pss)\n        pss = jsi_wsgetPss(cmdPtr, wsi, user, 1, 1);\n\n    int uplen=(cmdPtr->urlPrefix?Jsi_Strlen(cmdPtr->urlPrefix):0);\n\n    if (inPtr && cmdPtr->urlPrefix && !Jsi_Strncmp(inPtr, cmdPtr->urlPrefix, uplen))\n        inPtr += uplen;\n\n    if (cmdPtr->redirDisable) {// Try to defray redirect loops.\n        if (difftime(now, cmdPtr->stats.redirLast)>=600)\n            cmdPtr->redirDisable = 0;\n        else\n            cmdPtr->redirDisable--;\n    }\n\n    if ((cmdPtr->urlRedirect && (inPtr == 0 || *inPtr == 0 || !Jsi_Strcmp(inPtr, \"/\")) && !cmdPtr->redirDisable)\n        && (inPtr = cmdPtr->urlRedirect) && inPtr[0]) {\n        cmdPtr->stats.redirCnt++;\n        // TODO: system time change can disrupt the following.\n        if (cmdPtr->redirMax>0 && !cmdPtr->redirDisable && cmdPtr->redirMax>0 && cmdPtr->stats.redirLast\n            && difftime(now, cmdPtr->stats.redirLast)<600 && ++cmdPtr->redirAllCnt>cmdPtr->redirMax)\n            cmdPtr->redirDisable = 100;\n        cmdPtr->stats.redirLast = now;\n        rc = lws_http_redirect(wsi, 301, (uchar*)inPtr, Jsi_Strlen(inPtr), &p, end);\n        return (rc == 100 ? 0 : 1);\n    }\n    if (!inPtr || !*inPtr)\n        inPtr = \"/\";\n\n    if (cmdPtr->useridPass || cmdPtr->onAuth) {\n        int ok = 0;\n        int alen;\n        const char *auth = jsi_wsHeader(pss, \"authorization\", &alen);\n        if (auth && !Jsi_Strncasecmp(auth, \"basic \", 6) && !cmdPtr->deleted) {\n            auth += 6;\n            Jsi_DString eStr = {}, bStr = {};\n            Jsi_DSAppendLen(&eStr, auth, alen - 6);\n            Jsi_Base64(Jsi_DSValue(&eStr), -1, &bStr, 1);\n            const char *bp = Jsi_DSValue(&bStr);\n            if (bp && bp[0]) {\n                if (!cmdPtr->onAuth)\n                    ok = (!Jsi_Strcmp(cmdPtr->useridPass, bp));\n                else {\n                    /* Pass 4 args: ws, id, url and userid:pass . */\n                    Jsi_Obj *oarg1;\n                    Jsi_Value *vpargs, *vargs[10];\n                    int n = 0;\n                    vargs[n++] = Jsi_ValueNewObj(interp, cmdPtr->fobj);\n                    vargs[n++] = Jsi_ValueNewNumber(interp, (Jsi_Number)(pss->wid));\n                    vargs[n++] = Jsi_ValueNewStringDup(interp, inPtr);\n                    vargs[n++] = Jsi_ValueNewStringDup(interp, bp);\n                    vpargs = Jsi_ValueMakeObject(interp, NULL, oarg1 = Jsi_ObjNewArray(interp, vargs, n, 0));\n                    Jsi_IncrRefCount(interp, vpargs);\n                    Jsi_Value *ret = Jsi_ValueNew1(interp);\n                    bool rb = 0;\n                    rc = Jsi_FunctionInvoke(interp, cmdPtr->onAuth, vpargs, &ret, NULL);\n                    if (rc == JSI_OK)\n                        rb = !Jsi_ValueIsFalse(interp, ret);\n\n                    Jsi_DecrRefCount(interp, vpargs);\n                    Jsi_DecrRefCount(interp, ret);\n\n                    if (rc != JSI_OK) {\n                        Jsi_LogError(\"websock bad rcv eval\");\n                        return -1;\n                    }\n                    ok = rb;\n                }\n            }\n            Jsi_DSFree(&eStr);\n            Jsi_DSFree(&bStr);\n        }\n        if (!ok) {\n            const char *realm = (cmdPtr->realm?cmdPtr->realm:\"jsish\");\n            int n = snprintf(buf, sizeof(buf), \"Basic realm=\\\"%s\\\"\", realm);\n            if (lws_add_http_header_by_token(wsi, WSI_TOKEN_HTTP_WWW_AUTHENTICATE,\n                    (unsigned char *)buf, n, &p, end))\n                return -1;\n            if (jsi_wsServeString(pss, wsi, \"Password is required to access this page\", 401, (char*)buffer, NULL)<0)\n                return -1;\n            return lws_http_transaction_completed(wsi);\n        }\n    }\n\n    if (cmdPtr->onGet || pss->onGet) {\n        Jsi_RC jrc;\n        int rrv = 1;\n        if (cmdPtr->getRegexp) {\n            rrv = 0;\n            jrc = Jsi_RegExpMatch(interp, cmdPtr->getRegexp, inPtr, &rrv, NULL);\n            if (jrc != JSI_OK)\n                return -1; // Error in regexp.\n        }\n        if (rrv) {\n            jrc = jsi_wsGetCmd(interp, cmdPtr, pss, wsi, inPtr, pss->onGet?pss->onGet:cmdPtr->onGet, tStr);\n            switch (jrc) {\n                case JSI_ERROR: return -1;\n                case JSI_OK: return 0;\n                case JSI_SIGNAL:\n                    return jsi_ws_http_redirect(wsi, 302, tStr, &p, end);\n                case JSI_CONTINUE:\n                    inPtr = Jsi_DSValue(tStr); break;\n                case JSI_BREAK: break;\n                default: break;\n            }\n        }\n    }\n    ext = Jsi_Strrchr(inPtr, '.');\n\n    Jsi_Value *rdir = (pss->rootdir?pss->rootdir:cmdPtr->rootdir);\n    cmdPtr->curRoot = (rdir?Jsi_ValueString(cmdPtr->interp, rdir, NULL):\"./\");\n    Jsi_DString sStr;\n    Jsi_DSInit(&sStr);\n    jsi_wsPathAlias(interp, cmdPtr, &inPtr, &sStr);\n\n    snprintf(buf, sizeof(buf), \"%s/%s\", cmdPtr->curRoot, inPtr);\n    Jsi_DSFree(&sStr);\n    if (cmdPtr->debug>1)\n        fprintf(stderr, \"FILE: %s in %s | %s\\n\", buf, cmdPtr->curRoot, Jsi_ValueString(interp, cmdPtr->rootdir, NULL));\n    char extBuf[JSI_BUFSIZ], *cpde = Jsi_Strrchr(buf, '/');\n    isJsiWeb = (cpde && cmdPtr->jsiFnPattern && Jsi_GlobMatch(cmdPtr->jsiFnPattern, cpde+1, 0));\n    bool isgzip = 0;\n    if (!ext || !ext[1])\n        mime = \"text/html\";\n    else {\n        const char *eext = ext+1;\n        uint elen = Jsi_Strlen(ext);\n        if (elen>3 && elen<(sizeof(extBuf)-10) && !Jsi_Strcmp(ext+elen-3,\".gz\")) {\n            Jsi_Strcpy(extBuf, ext);\n            extBuf[elen-3] = 0;\n            char *ext2 = Jsi_Strrchr(extBuf, '.');\n            if (ext2) {\n                isgzip = 1;\n                ext = ext2;\n            }\n        }\n        Jsi_HashEntry *hPtr;\n\n        if (cmdPtr->mimeTypes) {\n            /* Lookup mime type in mimeTypes object. */\n            Jsi_Value *mVal = Jsi_ValueObjLookup(interp, cmdPtr->mimeTypes, ext+1, 1);\n            if (mVal)\n                mime = Jsi_ValueString(interp, mVal, NULL);\n        }\n        if (!mime) {\n            static const char* mtypes[] = {\n                \"html\", \"text/html\", \"js\", \"application/x-javascript\",\n                \"css\", \"text/css\", \"png\", \"image/png\", \"ico\", \"image/icon\",\n                \"gif\", \"image/gif\", \"jpeg\", \"image/jpeg\",\n                \"jpg\", \"image/jpeg\", \"svg\", \"image/svg+xml\",\n                \"json\", \"application/json\", \"txt\", \"text/plain\",\n                \"jsi\", \"application/x-javascript\", \"cssi\", \"text/css\",\n                \"shtml\", \"text/html\",  \"scss\", \"text/css\",\n                \"sjs\", \"application/x-javascript\",\n                0, 0\n            };\n            mime = \"text/html\";\n            int i;\n            for (i=0; mtypes[i]; i+=2)\n                if (tolower(*eext) == mtypes[i][0] && !Jsi_Strncasecmp(eext, mtypes[i], -1)) {\n                    mime = mtypes[i+1];\n                    break;\n                }\n        }\n\n        isSSI = jsi_wsIsSSIExt(interp, cmdPtr, pss, eext);\n\n        if ((hPtr = Jsi_HashEntryFind(cmdPtr->handlers, ext)) && !cmdPtr->deleted) {\n            /* Use interprete html eg. using jsi_wpp preprocessor */\n            Jsi_DString jStr = {};\n            Jsi_Value *vrc = NULL;\n            int hrc = 0, strLen, evrc, isalloc=0;\n            char *vStr, *hstr = NULL;\n            jsi_wsHander *hdlPtr = (jsi_wsHander*)Jsi_HashValueGet(hPtr);\n            Jsi_Value *hv = hdlPtr->val;\n\n            if (Jsi_Strchr(buf, '\\'') || Jsi_Strchr(buf, '\\\"')) {\n                jsi_wsServeString(pss, wsi, \"Can not handle quotes in url\", 404, NULL, NULL);\n                return -1;\n            }\n            cmdPtr->handlersPkg=1;\n\n            // Attempt to load package and get function.\n            if ((hdlPtr->flags&1) && cmdPtr->handlersPkg && Jsi_ValueIsString(interp, hv)\n                && ((hstr = Jsi_ValueString(interp, hv, NULL)))) {\n                vrc = Jsi_NameLookup(interp, hstr);\n                if (!vrc) {\n                    Jsi_Number pver = Jsi_PkgRequire(interp, hstr, 0);\n                    if (pver >= 0)\n                        vrc = Jsi_NameLookup(interp, hstr);\n                }\n                if (!vrc || !Jsi_ValueIsFunction(interp, vrc)) {\n                    if (vrc)\n                        Jsi_DecrRefCount(interp, vrc);\n                    Jsi_LogError(\"Failed to autoload handle: %s\", hstr);\n                    jsi_wsServeString(pss, wsi, \"Failed to autoload handler\", 404, NULL, NULL);\n                    return -1;\n                }\n                if (hdlPtr->val)\n                    Jsi_DecrRefCount(interp, hdlPtr->val);\n                hdlPtr->val = vrc;\n                Jsi_IncrRefCount(interp, vrc);\n                hv = vrc;\n            }\n\n            if ((hdlPtr->flags&2) && !hdlPtr->triedLoad && !hdlPtr->objVar && Jsi_ValueIsFunction(interp, hv)) {\n                // Run command and from returned object get the parse function.\n                hdlPtr->triedLoad = 1;\n                Jsi_DSAppend(&jStr, \"[null]\", NULL);\n                Jsi_DSAppend(&jStr, \"]\", NULL);\n                vrc = Jsi_ValueNew1(interp);\n                evrc = Jsi_FunctionInvokeJSON(interp, hv, Jsi_DSValue(&jStr), &vrc);\n                if (Jsi_InterpGone(interp))\n                    return -1;\n                if (evrc != JSI_OK || !vrc || !Jsi_ValueIsObjType(interp, vrc, JSI_OT_OBJECT)) {\n                    Jsi_LogError(\"Failed to load obj: %s\", hstr);\n                    jsi_wsServeString(pss, wsi, \"Failed to load obj\", 404, NULL, NULL);\n                    return -1;\n                }\n                Jsi_Value *fvrc = Jsi_ValueObjLookup(interp, vrc, \"parse\", 0);\n                if (!fvrc || !Jsi_ValueIsFunction(interp, fvrc)) {\n                    Jsi_LogError(\"Failed to find parse: %s\", hstr);\n                    jsi_wsServeString(pss, wsi, \"Failed to find parse\", 404, NULL, NULL);\n                    return -1;\n                }\n                hdlPtr->objVar = fvrc;\n                Jsi_IncrRefCount(interp, fvrc);\n                hv = vrc;\n\n            }\n\n            if (hdlPtr->objVar) {  // Call the obj.parse function.\n                Jsi_DSAppend(&jStr, \"[\\\"\", buf, \"\\\"]\", NULL); // TODO: JSON encode.\n                vrc = Jsi_ValueNew1(interp);\n                evrc = Jsi_FunctionInvokeJSON(interp, hdlPtr->objVar, Jsi_DSValue(&jStr), &vrc);\n                isalloc = 1;\n            }\n            else if (Jsi_ValueIsFunction(interp, hv)) {\n                //printf(\"CNCNN: %s\\n\", Jsi_DSValue(&cmdPtr->cName));\n                Jsi_DSAppend(&jStr, \"[\\\"\", buf, \"\\\", {wsName:\\\"\", Jsi_DSValue(&cmdPtr->cName), \"\\\"\", \"}]\", NULL); // TODO: JSON encode.\n                vrc = Jsi_ValueNew1(interp);\n                evrc = Jsi_FunctionInvokeJSON(interp, hv, Jsi_DSValue(&jStr), &vrc);\n                isalloc = 1;\n            } else {\n                // One shot invoke of string command.\n                hstr = Jsi_ValueString(interp, hv, NULL);\n                Jsi_DSAppend(&jStr, hstr, \"('\", buf, \"');\", NULL);\n                evrc = Jsi_EvalString(interp, Jsi_DSValue(&jStr), JSI_EVAL_RETURN);\n                if (evrc == JSI_OK)\n                    vrc = Jsi_InterpResult(interp);\n            }\n            // Take result from vrc and return it.\n            if (evrc != JSI_OK) {\n                Jsi_LogError(\"failure in websocket handler\");\n            } else if ((!vrc) ||\n                (!(vStr = Jsi_ValueString(interp, vrc, &strLen)))) {\n                Jsi_LogError(\"failed to get result\");\n            } else {\n                hrc = jsi_wsServeString(pss, wsi, vStr, 0, NULL, mime);\n            }\n            Jsi_DSFree(&jStr);\n            if (isalloc)\n                Jsi_DecrRefCount(interp, vrc);\n            if (hrc<=0)\n                return -1;\n            return 1;\n        }\n    }\n    if (!buf[0]) {\n        if (cmdPtr->debug)\n            fprintf(stderr, \"empty file: %s\\n\", inPtr);\n        return -1;\n    }\n    fname = Jsi_ValueNewStringDup(interp, buf);\n    Jsi_IncrRefCount(interp, fname);\n\n    Jsi_DString hStr = {};\n    Jsi_StatBuf jsb;\n    bool native = Jsi_FSNative(interp, fname);\n    if ((native && Jsi_InterpSafe(interp) && Jsi_InterpAccess(interp, fname, JSI_INTACCESS_READ) != JSI_OK) ||\n        (Jsi_Stat(interp, fname, &jsb) || jsb.st_size<=0)) {\nnofile:\n        if (cmdPtr->onUnknown || pss->onUnknown) {\n            Jsi_Value *uk = (pss->onUnknown?pss->onUnknown:cmdPtr->onUnknown);\n            Jsi_RC jrc = jsi_wsGetCmd(interp, cmdPtr, pss, wsi, inPtr, uk, NULL);\n            if (jrc == JSI_ERROR)\n                goto bail;\n            if (jrc == JSI_OK)\n                goto done;\n        }\n\n        if (0 && Jsi_Strstr(buf, \"favicon.ico\"))\n            rc = jsi_wsServeString(pss, wsi, \"data:;base64,iVBORw0KGgo=\", 200, NULL, \"image/icon\");\n        else {\n            const char *cp = Jsi_Strrchr(buf,'/');\n            if (cp && cp[1]) {\n                char statPath[PATH_MAX];\n                snprintf(statPath, sizeof(statPath), \"/zvfs/lib/web%s\", cp);\n                Jsi_DecrRefCount(interp, fname);\n                fname = Jsi_ValueNewStringDup(interp, statPath);\n                Jsi_IncrRefCount(interp, fname);\n                if (!Jsi_Stat(interp, fname, &jsb) && jsb.st_size>0) {\n                    native = 0;\n                    goto serve;\n                }\n            }\n            if (cmdPtr->noWarn==0 && !Jsi_Strstr(buf, \"favicon.ico\"))\n                fprintf(stderr, \"failed open file for read: %s\\n\", buf);\n            rc = jsi_wsServeString(pss, wsi, \"<b style='color:red'>ERROR: can not serve file!</b>\", 404, NULL, NULL);\n        }\n        Jsi_DecrRefCount(interp, fname);\n        goto done;\n    }\n    if (!ext || isSSI)\n        goto serve;\n    if (S_ISDIR(jsb.st_mode)) {\n        if (cmdPtr->noWarn==0)\n            fprintf(stderr, \"can not serve directory: %s\\n\", buf);\n        rc = jsi_wsServeString(pss, wsi, \"<b style='color:red'>ERROR: can not serve directory!</b>\", 404, NULL, NULL);\n        Jsi_DecrRefCount(interp, fname);\n        goto done;\n    }\n\nserve:\n    n = 0;\n    // TODO: add automatic cookie mgmt?\n/*\n    if (!strcmp((const char *)in, \"/\") &&\n       !lws_hdr_total_length(wsi, WSI_TOKEN_HTTP_COOKIE)) {\n        gettimeofday(&tv, NULL);\n        n = sprintf(b64, \"test=LWS_%u_%u_COOKIE;Max-Age=360000\",\n            (unsigned int)tv.tv_sec,\n            (unsigned int)tv.tv_usec);\n\n        if (lws_add_http_header_by_name(wsi,\n            (unsigned char *)\"set-cookie:\",\n            (unsigned char *)b64, n, &p,\n            (unsigned char *)buffer + sizeof(buffer)))\n            return 1;\n    }*/\n    static const char stsStr[] = \"max-age=15768000 ; includeSubDomains\";\n    if (lws_is_ssl(wsi) && lws_add_http_header_by_name(wsi,\n                    (uchar *) \"Strict-Transport-Security:\",\n                    (uchar *) stsStr,\n                    sizeof(stsStr)-1, &p, (uchar *)buffer + sizeof(buffer)))\n        goto bail;\n    n = p - buffer;\n    if (n>0)\n        Jsi_DSAppendLen(&hStr, (char*)buffer, n);\n    p = buffer;\n\n    if (isgzip) {\n        if (lws_add_http_header_by_token(wsi, WSI_TOKEN_HTTP_CONTENT_ENCODING,\n                    (unsigned char *)\"gzip\", n, &p, end))\n            goto bail;\n    }\n    if (cmdPtr->headers && !jsi_wsAddHeader(interp, cmdPtr, wsi, cmdPtr->headers, &hStr))\n        goto bail;\n\n    if (pss->headers && !jsi_wsAddHeader(interp, cmdPtr, wsi, pss->headers, &hStr))\n        goto bail;\n\n    n = Jsi_DSLength(&hStr);\n\n    if (native && !isSSI && !isJsiWeb) {\n\n        if (!jsi_wsAddStdHeader(interp, cmdPtr, wsi, &hStr)) {\n            Jsi_DecrRefCount(interp, fname);\n            goto bail;\n        }\n        int hrc = lws_serve_http_file(wsi, buf, mime, Jsi_DSValue(&hStr), Jsi_DSLength(&hStr));\n        if (hrc >= 0 && cmdPtr->onModify)\n            jsi_wsFileAdd(interp, cmdPtr, fname);\n        Jsi_DecrRefCount(interp, fname);\n        if (hrc<0) {\n            if (cmdPtr->noWarn==0)\n                fprintf(stderr, \"can not serve file (%d): %s\\n\", hrc, buf);\n            goto bail;\n        } else if (hrc > 0 && lws_http_transaction_completed(wsi))\n            goto bail;\n    } else {\n        // Need to read data for non-native files.\n        Jsi_DString dStr = {}, fStr = {};\n        if (isSSI)\n            rc = jsi_wsEvalSSI(interp, cmdPtr, fname, &fStr, 1, pss);\n        else {\n            rc = jsi_wsFileRead(interp, fname, &fStr, cmdPtr, pss);\n            if (isJsiWeb)\n                Jsi_DSAppend(&fStr, \"\\nwindow.jsiWebSocket=true;\", NULL);\n        }\n        if (rc != JSI_OK) {\n            Jsi_DSFree(&fStr);\n            goto nofile;\n        }\n        int hrc = jsi_wsServeHeader(pss, wsi, (int)Jsi_DSLength(&fStr), 200, Jsi_DSValue(&hStr), mime, &dStr);\n        if (hrc>=0) {\n            Jsi_DSAppendLen(&dStr, Jsi_DSValue(&fStr), Jsi_DSLength(&fStr));\n            char *strVal = Jsi_DSValue(&dStr);\n            int strLen = Jsi_DSLength(&dStr);\n            hrc = jsi_wswrite(pss, wsi, (unsigned char*)strVal, strLen, LWS_WRITE_HTTP);\n        }\n        Jsi_DecrRefCount(interp, fname);\n        Jsi_DSFree(&dStr);\n        Jsi_DSFree(&fStr);\n        if (hrc<0) {\n            if (cmdPtr->noWarn==0)\n                fprintf(stderr, \"can not serve data (%d): %s\\n\", hrc, buf);\n            goto bail;\n        } else if (hrc > 0 && lws_http_transaction_completed(wsi))\n            goto bail;\n\n    }\ndone:\n    Jsi_DSFree(&hStr);\n    return rc;\n\nbail:\n    rc = 1;\n    goto done;\n}\n\nstatic Jsi_RC jsi_wsrecv_callback(Jsi_Interp *interp, jsi_wsCmdObj *cmdPtr, jsi_wsPss *pss,\n    const char *inPtr, int nlen, bool isClose)\n{\n    Jsi_Value *vpargs, *vargs[10];\n    Jsi_Value* func = NULL;\n    if (Jsi_InterpGone(interp) || (cmdPtr->deleted && !isClose)) return JSI_ERROR;\n    int n = 0;\n    if (isClose)\n        func = ((pss && pss->onClose)?pss->onClose:cmdPtr->onClose);\n    else\n        func = ((pss && pss->onRecv)?pss->onRecv:cmdPtr->onRecv);\n    if (!func)\n        return JSI_OK;\n    vargs[n++] = (cmdPtr->deleted?Jsi_ValueNewNull(interp):Jsi_ValueNewObj(interp, cmdPtr->fobj));\n    vargs[n++] = Jsi_ValueNewNumber(interp, (Jsi_Number)(pss?pss->wid:0));\n    if (!isClose) {\n        if (nlen<=0)\n            return JSI_OK;\n        vargs[n++]  = Jsi_ValueNewBlob(interp, (uchar*)inPtr, nlen);\n        if ((cmdPtr->echo||(pss && pss->echo)) && inPtr)\n            Jsi_LogInfo(\"WS-RECV: %s\\n\", inPtr);\n    }\n    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, vargs, n, 0));\n    Jsi_IncrRefCount(interp, vpargs);\n\n    Jsi_Value *ret = Jsi_ValueNew1(interp);\n    Jsi_RC rc = Jsi_FunctionInvoke(interp, func, vpargs, &ret, NULL);\n    if (rc == JSI_OK && Jsi_ValueIsUndef(interp, ret)==0 && !isClose) {\n        /* TODO: should we handle callback return data??? */\n    }\n    Jsi_DecrRefCount(interp, vpargs);\n    Jsi_DecrRefCount(interp, ret);\n    return rc;\n}\n\n#if (LWS_LIBRARY_VERSION_MAJOR>1)\nstatic int\njsi_wsFileUploadCB(void *data, const char *name, const char *filename,\n                   char *buf, int len, enum lws_spa_fileupload_states state)\n{\n    jsi_wsPss *pss = (typeof(pss))data;\n    jsi_wsCmdObj *cmdPtr = pss->cmdPtr;\n    Jsi_Value* callPtr = (pss->onUpload?pss->onUpload:cmdPtr->onUpload);\n    Jsi_Interp *interp = cmdPtr->interp;\n    const char *str;\n    int slen, n = 0;\n    if (cmdPtr->deleted) return -1;\n\n    Jsi_Obj *oarg1;\n    Jsi_Value *vpargs, *vargs[10];\n    if (state == LWS_UFS_OPEN)\n        pss->file_length = 0;\n    //id:number, filename:string, data:string, startpos:number, complete:boolean\n    vargs[n++] = Jsi_ValueNewObj(interp, cmdPtr->fobj);\n    vargs[n++] = Jsi_ValueNewNumber(interp, (Jsi_Number)(pss->wid));\n    vargs[n++] = Jsi_ValueNewBlobString(interp, filename);\n    vargs[n++] = Jsi_ValueNewBlob(interp, (uchar*)buf, (uint)len);\n    vargs[n++] = Jsi_ValueNewNumber(interp, (Jsi_Number)pss->file_length);\n    vargs[n++] = Jsi_ValueNewBoolean(interp, (state==LWS_UFS_FINAL_CONTENT));\n    vpargs = Jsi_ValueMakeObject(interp, NULL, oarg1 = Jsi_ObjNewArray(interp, vargs, n, 0));\n    Jsi_IncrRefCount(interp, vpargs);\n    pss->file_length += len;\n\n    Jsi_Value *ret = Jsi_ValueNew1(interp);\n    Jsi_ValueMakeUndef(interp, &ret);\n    Jsi_RC rc = Jsi_FunctionInvoke(interp, callPtr, vpargs, &ret, NULL);\n\n    if ((state==LWS_UFS_FINAL_CONTENT || rc != JSI_OK) && (str=Jsi_ValueString(interp, ret, &slen))) {\n        Jsi_DSAppendLen(&pss->resultStr, str, slen);\n        pss->resultCode = rc;\n    }\n\n    Jsi_DecrRefCount(interp, vpargs);\n    Jsi_DecrRefCount(interp, ret);\n    if (rc != JSI_OK) {\n        Jsi_LogError(\"websock bad rcv eval\");\n        return -1;\n    }\n    return 0;\n}\n#endif\n\nstatic int jsi_wscallback_http(struct lws *wsi,\n                         enum lws_callback_reasons reason, void *user,\n                         void *in, size_t len)\n{\n    struct lws_context *context = lws_get_context(wsi);\n    const char *inPtr = (char*)in;\n    char client_name[128], client_ip[128];\n    const char *res = \"\";\n#ifdef EXTERNAL_POLL\n    int m;\n    int fd = (int)(long)user;\n#endif\n    jsi_wsCmdObj *cmdPtr = (jsi_wsCmdObj *)lws_context_user(context);\n    if (!cmdPtr) {\n        fprintf(stderr, \"bad ws context\\n\");\n        return -1;\n    }\n    jsi_wsPss *pss = NULL;\n    Jsi_Interp *interp = cmdPtr->interp;\n    Jsi_Value* callPtr = NULL;\n    int rc = 0, deflt = 0;\n\n    WSSIGASSERT(cmdPtr, OBJ);\n    if (Jsi_InterpGone(interp))\n        cmdPtr->deleted = 1;\n\n    if (cmdPtr->debug>=128)\n        fprintf(stderr, \"HTTP CALLBACK: len=%d, %p %d:%s\\n\", (int)len, user, reason, jsw_getReasonStr(reason));\n\n    switch (reason) {\n#ifndef EXTERNAL_POLL\n    case LWS_CALLBACK_GET_THREAD_ID:\n    case LWS_CALLBACK_UNLOCK_POLL:\n    case LWS_CALLBACK_PROTOCOL_INIT:\n    case LWS_CALLBACK_ADD_POLL_FD:\n    case LWS_CALLBACK_DEL_POLL_FD:\n    case LWS_CALLBACK_CHANGE_MODE_POLL_FD:\n    case LWS_CALLBACK_LOCK_POLL:\n        return rc;\n#else\n        /*\n         * callbacks for managing the external poll() array appear in\n         * protocol 0 callback\n         */\n\n    case LWS_CALLBACK_ADD_POLL_FD:\n\n        if (jsi_wsnum_pollfds >= max_poll_elements) {\n            lwsl_err(\"LWS_CALLBACK_ADD_POLL_FD: too many sockets to track\\n\");\n            return 1;\n        }\n\n        fd_lookup[fd] = jsi_wsnum_pollfds;\n        jsi_wspollfds[jsi_wsnum_pollfds].fd = fd;\n        jsi_wspollfds[jsi_wsnum_pollfds].events = (int)(long)len;\n        jsi_wspollfds[jsi_wsnum_pollfds++].revents = 0;\n        break;\n\n    case LWS_CALLBACK_DEL_POLL_FD:\n        if (!--jsi_wsnum_pollfds)\n            break;\n        m = fd_lookup[fd];\n        /* have the last guy take up the vacant slot */\n        jsi_wspollfds[m] = jsi_wspollfds[jsi_wsnum_pollfds];\n        fd_lookup[jsi_wspollfds[jsi_wsnum_pollfds].fd] = m;\n        break;\n\n#endif\n\n    default:\n        deflt = 1;\n        break;\n\n    }\n\n    if (deflt && cmdPtr->debug>16 && cmdPtr->debug<128) {\n        fprintf(stderr, \"HTTP CALLBACK: len=%d, %p %d:%s\\n\", (int)len, user, reason, jsw_getReasonStr(reason));\n    }\n\n    switch (reason) {\n    case LWS_CALLBACK_WSI_DESTROY:\n        break;\n\n#if (LWS_LIBRARY_VERSION_MAJOR>1)\n    // Handle GET file download in client mode.\n    case LWS_CALLBACK_RECEIVE_CLIENT_HTTP: {\n        char buffer[1024 + LWS_PRE];\n        char *px = buffer + LWS_PRE;\n        int lenx = sizeof(buffer) - LWS_PRE;\n\n        if (lws_http_client_read(wsi, &px, &lenx) < 0)\n            return -1;\n        break;\n    }\n    case LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ:\n        if (jsi_wsrecv_callback(interp, cmdPtr, pss, inPtr, len, 0) != JSI_OK)\n            rc = 1;\n        break;\n\n    case LWS_CALLBACK_COMPLETED_CLIENT_HTTP:\n        if (jsi_wsrecv_callback(interp, cmdPtr, pss, inPtr, len, 1) != JSI_OK)\n            rc = 1;\n        break;\n\n    case LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER:\n        if (cmdPtr->post) {\n            unsigned char **p = (unsigned char **)in, *end = (*p) + len;\n            int n = 0;\n            char buf[JSI_MAX_NUMBER_STRING];\n            Jsi_ValueString(interp, cmdPtr->post, &n);\n            snprintf(buf, sizeof(buf), \"%d\", n);\n\n            if (lws_add_http_header_by_token(wsi,\n                    WSI_TOKEN_HTTP_CONTENT_LENGTH,\n                    (unsigned char *)buf, 2, p, end))\n                return -1;\n            if (lws_add_http_header_by_token(wsi,\n                    WSI_TOKEN_HTTP_CONTENT_TYPE,\n                    (unsigned char *)\"application/x-www-form-urlencoded\", 33, p, end))\n                return -1;\n\n            /* inform lws we have http body to send */\n            lws_client_http_body_pending(wsi, 1);\n            lws_callback_on_writable(wsi);\n        }\n        break;\n\n    case LWS_CALLBACK_CLIENT_HTTP_WRITEABLE: {\n        int n = 0;\n        char *cps = Jsi_ValueString(interp, cmdPtr->post, &n);\n        char *buf = (char*)Jsi_Calloc(1, LWS_PRE + n + 1);\n        Jsi_Strcpy(buf + LWS_PRE, cps);\n        n = lws_write(wsi, (unsigned char *)&buf[LWS_PRE], strlen(&buf[LWS_PRE]), LWS_WRITE_HTTP);\n        Jsi_Free(buf);\n        if (n < 0)\n            return -1;\n        /* we only had one thing to send, so inform lws we are done\n         * if we had more to send, call lws_callback_on_writable(wsi);\n         * and just return 0 from callback.  On having sent the last\n         * part, call the below api instead.*/\n        lws_client_http_body_pending(wsi, 0);\n        break;\n    }\n#endif\n\n    case LWS_CALLBACK_FILTER_NETWORK_CONNECTION:\n        break;\n    case LWS_CALLBACK_PROTOCOL_INIT:\n        break;\n    case LWS_CALLBACK_CLOSED_HTTP:\n        if (cmdPtr->debug>2)\n            fprintf(stderr, \"CLOSED\\n\");\n        if (!pss)\n            pss = jsi_wsgetPss(cmdPtr, wsi, user, 0, 1);\n        if (pss)\n            jsi_wsdeletePss(pss);\n        break;\n    case LWS_CALLBACK_WSI_CREATE:\n        break;\n\n    case LWS_CALLBACK_CONFIRM_EXTENSION_OKAY:\n        break;\n\n    case LWS_CALLBACK_FILTER_HTTP_CONNECTION:\n        if (cmdPtr->debug>1)\n            fprintf(stderr, \"FILTER CONNECTION: %s\\n\", inPtr);\n        pss = jsi_wsgetPss(cmdPtr, wsi, user, 1, 1);\n        Jsi_DSSet(&pss->url, inPtr);\n        jsi_wsgetUriArgValue(interp, wsi, &pss->query, &pss->queryObj);\n\n        if (cmdPtr->instCtx == context && (cmdPtr->clientName[0] || cmdPtr->clientIP[0])) {\n            pss->clientName = cmdPtr->clientName;\n            pss->clientIP = cmdPtr->clientIP;\n        }\n\n        Jsi_DSSetLength(&pss->dHdrs, 0);\n        pss->hdrNum = jsi_wsGetHeaders(pss, wsi, &pss->dHdrs, pss->hdrSz, sizeof(pss->hdrSz)/sizeof(int));\n\n        if (cmdPtr->onFilter && !cmdPtr->deleted) {\n            // 4 args: ws, id, url, bool\n            int killcon = 0, n = 0;\n            Jsi_Obj *oarg1;\n            Jsi_Value *vpargs, *vargs[10], *ret = Jsi_ValueNew1(interp);\n            vargs[n++] = Jsi_ValueNewObj(interp, cmdPtr->fobj);\n            vargs[n++] = Jsi_ValueNewNumber(interp, (Jsi_Number)(pss->wid));\n            vargs[n++] = Jsi_ValueNewBlob(interp, (uchar*)in, len);\n            vargs[n++] = Jsi_ValueNewBoolean(interp, 1);\n            vpargs = Jsi_ValueMakeObject(interp, NULL, oarg1 = Jsi_ObjNewArray(interp, vargs, n, 0));\n            Jsi_IncrRefCount(interp, vpargs);\n            Jsi_ValueMakeUndef(interp, &ret);\n            rc = Jsi_FunctionInvoke(interp, cmdPtr->onFilter, vpargs, &ret, NULL);\n            if (rc == JSI_OK && Jsi_ValueIsFalse(interp, ret)) {\n                if (cmdPtr->debug>1)\n                    fprintf(stderr, \"WS:KILLING CONNECTION: %p\\n\", pss);\n                killcon = 1;\n            }\n\n            Jsi_DecrRefCount(interp, vpargs);\n            Jsi_DecrRefCount(interp, ret);\n            if (rc != JSI_OK) {\n                Jsi_LogError(\"websock bad rcv eval\");\n                return 1;\n            }\n            if (killcon)\n                return 1;\n        }\n        break;\n\n    case LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED:\n        client_name[0] = 0;\n        client_ip[0] = 0;\n        lws_get_peer_addresses(wsi, lws_get_socket_fd(wsi), client_name,\n                                         sizeof(client_name), client_ip, sizeof(client_ip));\n        if (client_name[0])\n            cmdPtr->clientName = Jsi_KeyAdd(interp, client_name);\n        if (client_ip[0])\n            cmdPtr->clientIP = Jsi_KeyAdd(interp, client_ip);\n\n        if (cmdPtr->clientName || cmdPtr->clientIP) {\n            const char *loname = cmdPtr->localhostName;\n            if (!loname) loname = \"localhost\";\n            cmdPtr->instCtx = context;\n            if (cmdPtr->debug>1)\n                fprintf(stderr,  \"Received network connect from %s (%s)\\n\",\n                     cmdPtr->clientName, cmdPtr->clientIP);\n#ifndef __WIN32\n            if (cmdPtr->local && (cmdPtr->clientName && Jsi_Strcmp(cmdPtr->clientName, loname))) {\n                if (cmdPtr->debug>1)\n                    fprintf(stderr,  \"Dropping non-localhost connection\\n\");\n                return 1;\n            }\n#endif\n        }\n\n        if (cmdPtr->maxConnects && cmdPtr->stats.connectCnt>=cmdPtr->maxConnects) {\n            if (cmdPtr->debug>1)\n                fprintf(stderr, \"maxConnects exceeded: rejecting connection <%p>\\n\", user);\n            rc = -1;\n        }\n        /* if we returned non-zero from here, we kill the connection */\n        break;\n\n    case LWS_CALLBACK_HTTP:\n    {\n        Jsi_DString dStr;\n        Jsi_DSInit(&dStr);\n        if (cmdPtr->debug)\n            fprintf(stderr, \"HTTP GET: %s\\n\", inPtr);\n        rc = jsi_wsHttp(interp, cmdPtr, wsi, user, context, inPtr, &dStr, pss);\n        Jsi_DSFree(&dStr);\n        if (rc<0)\n            return -1;\n        if (rc==1) {\n            goto try_to_reuse;\n        }\n        break;\n    }\n\n#if (LWS_LIBRARY_VERSION_MAJOR>1)\n    case LWS_CALLBACK_HTTP_BODY: {\n        if (!pss)\n            pss = jsi_wsgetPss(cmdPtr, wsi, user, 0, 1);\n        if (!pss) break;\n        callPtr = (pss->onUpload?pss->onUpload:cmdPtr->onUpload);\n        if (cmdPtr->maxUpload<=0 || !callPtr) {\n            if (cmdPtr->noWarn==0)\n                fprintf(stderr, \"Upload disabled: maxUpload=%d, onUpload=%p\\n\", cmdPtr->maxUpload, callPtr);\n            return -1;\n        }\n\n        if (!pss->spa) {\n            /* create the POST argument parser */\n            if (!pss->paramv) {\n                if (cmdPtr->formParams && cmdPtr->formParams != jsi_wsparam_str)\n                    Jsi_SplitStr(cmdPtr->formParams, &pss->paramc, &pss->paramv, \",\", &pss->paramDS);\n                else {\n                    pss->paramv = (typeof(pss->paramv))jsi_wsparam_names;\n                    pss->paramc = ARRAY_SIZE(jsi_wsparam_names);\n                }\n            }\n            pss->spa = lws_spa_create(wsi, (const char*const*)pss->paramv,\n                pss->paramc, 4096, jsi_wsFileUploadCB, pss);\n            if (!pss->spa)\n                    return -1;\n\n            pss->filename[0] = '\\0';\n            pss->file_length = 0;\n        }\n\n        cmdPtr->stats.uploadLast = pss->stats.uploadLast = time(NULL);\n\n        /* let it parse the POST data */\n        if (lws_spa_process(pss->spa, inPtr, len))\n                return -1;\n\n\n        if (!pss->stats.uploadStart) {\n            cmdPtr->stats.uploadEnd = pss->stats.uploadEnd = 0;\n            cmdPtr->stats.uploadStart = pss->stats.uploadStart = time(NULL);\n            cmdPtr->stats.uploadCnt++;\n            pss->stats.uploadCnt++;\n        }\n        break;\n    }\n\n    case LWS_CALLBACK_HTTP_BODY_COMPLETION:\n        if (!pss) {\n            pss = jsi_wsgetPss(cmdPtr, wsi, user, 0, 1);\n            callPtr = (pss&&pss->onUpload?pss->onUpload:cmdPtr->onUpload);\n        }\n        if (pss && pss->spa)\n            lws_spa_finalize(pss->spa);\n        res = Jsi_DSValue(&pss->resultStr);\n        if (!res[0]) {\n            if (!pss->resultCode)\n                res = \"<html><body>Upload complete</body></html>\";\n            else\n                res = \"<html><body>Upload error</body></html>\";\n        }\n        jsi_wsServeString(pss, wsi, res, pss->resultCode==JSI_OK?0:500, NULL, NULL);\n        if (cmdPtr->maxUpload<=0 || !callPtr) {\n            if (cmdPtr->noWarn==0)\n                fprintf(stderr, \"Upload disabled: maxUpload=%d, onUpload=%p\\n\", cmdPtr->maxUpload, callPtr);\n            return -1;\n        }\n        cmdPtr->stats.uploadEnd = pss->stats.uploadEnd = time(NULL);\n        lws_return_http_status(wsi, HTTP_STATUS_OK, NULL);\n        goto try_to_reuse;\n\n    case LWS_CALLBACK_HTTP_DROP_PROTOCOL:\n        pss = jsi_wsgetPss(cmdPtr, wsi, user, 0, 1);\n        if (pss && pss->spa) {\n            lws_spa_destroy(pss->spa);\n            pss->spa = NULL;\n        }\n        break;\n#endif\n\n    case LWS_CALLBACK_HTTP_FILE_COMPLETION:\n        goto try_to_reuse;\n\n    case LWS_CALLBACK_HTTP_WRITEABLE: {\n        lwsl_info(\"LWS_CALLBACK_HTTP_WRITEABLE\\n\");\n        if (!pss)\n            pss = jsi_wsgetPss(cmdPtr, wsi, user, 0, 1);\n\n        if (!pss || !pss->fop_fd)\n            goto try_to_reuse;\n\n        /*\n         * we can send more of whatever it is we were sending\n         */\n        int sent = 0;\n        unsigned char buffer[JSI_BUFSIZ*10 + LWS_PRE];\n        do {\n            int n = sizeof(buffer) - LWS_PRE;\n            int m = lws_get_peer_write_allowance(wsi);\n            if (m == 0)\n                goto later;\n\n            if (m != -1 && m < n)\n                n = m;\n\n            lws_filepos_t amount = 0;\n            n = lws_vfs_file_read(pss->fop_fd, &amount, buffer + LWS_PRE, n);\n            if (n < 0) {\n                lwsl_err(\"problem reading file\\n\");\n                goto bail;\n            }\n            n = (int)amount;\n            if (n == 0)\n                goto penultimate;\n            /*\n             * To support HTTP2, must take care about preamble space\n             *\n             * identification of when we send the last payload frame\n             * is handled by the library itself if you sent a\n             * content-length header\n             */\n            m = jsi_wswrite(pss, wsi, buffer + LWS_PRE, n, LWS_WRITE_HTTP);\n            if (m < 0) {\n                lwsl_err(\"write failed\\n\");\n                /* write failed, close conn */\n                goto bail;\n            }\n            if (m) /* while still active, extend timeout */\n                lws_set_timeout(wsi, PENDING_TIMEOUT_HTTP_CONTENT, 5);\n            sent += m;\n\n        } while (!lws_send_pipe_choked(wsi) && (sent < 500 * 1024 * 1024));\nlater:\n        lws_callback_on_writable(wsi);\n        break;\npenultimate:\n        lws_vfs_file_close(&pss->fop_fd);\n        goto try_to_reuse;\n\nbail:\n        lws_vfs_file_close(&pss->fop_fd);\n        rc = -1;\n        goto doret;\n    }\n\n    default:\n        break;\n    }\n\n    goto doret;\n\ntry_to_reuse:\n    if (lws_http_transaction_completed(wsi))\n         rc = -1;\n    else\n        rc = 0;\n    goto doret;\n\ndoret:\n    if (cmdPtr->debug>2)\n        fprintf(stderr, \"<---HTTP RET = %d\\n\", rc);\n    return rc;\n}\n\nstatic int\njsi_wscallback_websock(struct lws *wsi,\n      enum lws_callback_reasons reason,\n      void *user, void *in, size_t len)\n{\n    struct lws_context *context = lws_get_context(wsi);\n\n    jsi_wsPss *pss = NULL;\n    jsi_wsCmdObj *cmdPtr = (jsi_wsCmdObj *)lws_context_user(context);\n    if (!cmdPtr) {\n        fprintf(stderr, \"null ws context\\n\");\n        return -1;\n    }\n    Jsi_Interp *interp = cmdPtr->interp;\n    char *inPtr = (char*)in;\n    int sLen, n, rc =0;\n    WSSIGASSERT(cmdPtr, OBJ);\n    if (Jsi_InterpGone(interp))\n        cmdPtr->deleted = 1;\n\n    if (cmdPtr->debug>=32) {\n        switch (reason) {\n            case LWS_CALLBACK_SERVER_WRITEABLE:\n            case LWS_CALLBACK_CLIENT_WRITEABLE:\n                break;\n            default:\n                fprintf(stderr, \"WS CALLBACK: len=%d, %p %d:%s\\n\", (int)len, user, reason, jsw_getReasonStr(reason));\n        }\n    }\n\n    switch (reason) {\n    case LWS_CALLBACK_PROTOCOL_INIT:\n        if (cmdPtr->noWebsock)\n            return 1;\n        break;\n\n    case LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION:\n        pss = jsi_wsgetPss(cmdPtr, wsi, user, 1, 1);\n        Jsi_DSSet(&pss->url, inPtr);\n        if (cmdPtr->instCtx == context && (cmdPtr->clientName[0] || cmdPtr->clientIP[0])) {\n            pss->clientName = cmdPtr->clientName;\n            pss->clientIP = cmdPtr->clientIP;\n        }\n        if (cmdPtr->onFilter && !cmdPtr->deleted) {\n            if (!pss)\n                pss = jsi_wsgetPss(cmdPtr, wsi, user, 1, 0);\n            int killcon = 0, n = 0;\n            Jsi_Obj *oarg1;\n            Jsi_Value *vpargs, *vargs[10], *ret = Jsi_ValueNew1(interp);\n\n            vargs[n++] = Jsi_ValueNewObj(interp, cmdPtr->fobj);\n            vargs[n++] = Jsi_ValueNewNumber(interp, (Jsi_Number)(pss->wid));\n            vargs[n++] = Jsi_ValueNewBlob(interp, (uchar*)in, len);\n            vargs[n++] = Jsi_ValueNewBoolean(interp, 0);\n            vpargs = Jsi_ValueMakeObject(interp, NULL, oarg1 = Jsi_ObjNewArray(interp, vargs, n, 0));\n            Jsi_IncrRefCount(interp, vpargs);\n            Jsi_ValueMakeUndef(interp, &ret);\n            rc = Jsi_FunctionInvoke(interp, cmdPtr->onFilter, vpargs, &ret, NULL);\n            if (rc == JSI_OK && Jsi_ValueIsFalse(interp, ret)) {\n                if (cmdPtr->debug>1)\n                    fprintf(stderr, \"WS:KILLING CONNECTION: %p\\n\", user);\n                killcon = 1;\n            }\n\n            Jsi_DecrRefCount(interp, vpargs);\n            Jsi_DecrRefCount(interp, ret);\n            if (rc != JSI_OK) {\n                Jsi_LogError(\"websock bad rcv eval\");\n                return 1;\n            }\n            if (killcon)\n                return 1;\n        }\n        break;\n\n    case LWS_CALLBACK_CLIENT_ESTABLISHED:\n    case LWS_CALLBACK_ESTABLISHED:\n        if (cmdPtr->bufferPwr2>0) {\n            char nbuf[JSI_MAX_NUMBER_STRING];\n            snprintf(nbuf, sizeof(nbuf), \"%d\", cmdPtr->bufferPwr2);\n            lws_set_extension_option(wsi, \"permessage-deflate\", \"rx_buf_size\", nbuf);\n            lws_set_extension_option(wsi, \"permessage-deflate\", \"tx_buf_size\", nbuf);\n        }\n        if (!pss)\n            pss = jsi_wsgetPss(cmdPtr, wsi, user, 1, 0);\n        if (cmdPtr->onOpen && !cmdPtr->deleted) {\n            /* Pass 2 args: ws id. */\n            Jsi_Obj *oarg1;\n            Jsi_Value *vpargs, *vargs[10];\n            int n = 0;\n            vargs[n++] = Jsi_ValueNewObj(interp, cmdPtr->fobj);\n            vargs[n++] = Jsi_ValueNewNumber(interp, (Jsi_Number)(pss->wid));\n            vpargs = Jsi_ValueMakeObject(interp, NULL, oarg1 = Jsi_ObjNewArray(interp, vargs, n, 0));\n            Jsi_IncrRefCount(interp, vpargs);\n\n            Jsi_Value *ret = Jsi_ValueNew1(interp);\n            Jsi_ValueMakeUndef(interp, &ret);\n            rc = Jsi_FunctionInvoke(interp, cmdPtr->onOpen, vpargs, &ret, NULL);\n\n            Jsi_DecrRefCount(interp, vpargs);\n            Jsi_DecrRefCount(interp, ret);\n            if (rc != JSI_OK)\n                return Jsi_LogError(\"websock bad rcv eval\");\n        }\n        break;\n\n    case LWS_CALLBACK_WSI_DESTROY:\n        break;\n\n    case LWS_CALLBACK_CLOSED:\n    case LWS_CALLBACK_PROTOCOL_DESTROY:\n        pss = jsi_wsgetPss(cmdPtr, wsi, user, 0, 0);\n        if (!pss) break;\n        if (cmdPtr->onClose || pss->onClose) {\n            rc = jsi_wsrecv_callback(interp, cmdPtr, pss, inPtr, len, 1);\n            if (rc != JSI_OK)\n                return Jsi_LogError(\"websock bad rcv eval\");\n        }\n        jsi_wsdeletePss(pss);\n        if (cmdPtr->stats.connectCnt<=0 && cmdPtr->onCloseLast && !Jsi_InterpGone(interp)) {\n            Jsi_RC jrc;\n            Jsi_Value *retStr = Jsi_ValueNew1(interp);\n            // 1 args: ws\n            Jsi_Value *vpargs, *vargs[10];\n            int n = 0;\n            vargs[n++] = (cmdPtr->deleted?Jsi_ValueNewNull(interp):Jsi_ValueNewObj(interp, cmdPtr->fobj));\n            vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, vargs, n, 0));\n            Jsi_IncrRefCount(interp, vpargs);\n            jrc = Jsi_FunctionInvoke(interp, cmdPtr->onCloseLast, vpargs, &retStr, NULL);\n            Jsi_DecrRefCount(interp, vpargs);\n            Jsi_DecrRefCount(interp, retStr);\n            if (Jsi_InterpGone(interp))\n                return JSI_ERROR;\n            return jrc;\n        }\n        break;\n\n    case LWS_CALLBACK_CLIENT_WRITEABLE:\n    case LWS_CALLBACK_SERVER_WRITEABLE: {\n        pss = jsi_wsgetPss(cmdPtr, wsi, user, 0, 0);\n        if (!pss || !pss->stack) break;\n        if (pss->lastData)\n            Jsi_Free(pss->lastData);\n        n=0;\n        char *data = pss->lastData = (char*)Jsi_StackUnshift(pss->stack);\n        unsigned char *p;\n        if (data == NULL)\n            break;\n        pss->stats.msgQLen--;\n        pss->state = PWS_SENT;\n        p = (unsigned char *)data+LWS_PRE;\n        sLen = Jsi_Strlen((char*)p);\n        n = jsi_wswrite(pss, wsi, p, sLen, (pss->stats.isBinary?LWS_WRITE_BINARY:LWS_WRITE_TEXT));\n        if (cmdPtr->debug>=10)\n            fprintf(stderr, \"WS:CLIENT WRITE(%p): %d=>%d\\n\", pss, sLen, n);\n\n        if (n >= 0) {\n            cmdPtr->stats.sentCnt++;\n            cmdPtr->stats.sentLast = time(NULL);\n            pss->stats.sentCnt++;\n            pss->stats.sentLast = time(NULL);\n        } else {\n            lwsl_err(\"ERROR %d writing to socket\\n\", n);\n            pss->state = PWS_SENDERR;\n            pss->stats.sentErrCnt++;\n            pss->stats.sentErrLast = time(NULL);\n            cmdPtr->stats.sentErrCnt++;\n            cmdPtr->stats.sentErrLast = time(NULL);\n            rc = 1;\n        }\n        break;\n    }\n\n    case LWS_CALLBACK_CLIENT_RECEIVE:\n    case LWS_CALLBACK_RECEIVE:\n    {\n        pss = jsi_wsgetPss(cmdPtr, wsi, user, 0, 0);\n        if (!pss) break;\n\n        pss->stats.recvCnt++;\n        pss->stats.recvLast = time(NULL);\n        cmdPtr->stats.recvCnt++;\n        cmdPtr->stats.recvLast = time(NULL);\n\n        if (cmdPtr->onRecv || pss->onRecv) {\n            /* Pass 2 args: id and data. */\n            int nlen = len;\n            if (nlen<=0)\n                return 0;\n            int rblen = Jsi_DSLength(&pss->recvBuf),\n                bmax = cmdPtr->recvBufMax,\n                isfin = pss->stats.isFinal = lws_is_final_fragment(wsi);\n            pss->stats.isBinary = lws_frame_is_binary(wsi);\n            if (rblen) {\n                if (bmax && rblen>bmax) {\n                    fprintf(stderr, \"WS: Recv exceeds recvBufMax: %d>%d\\n\", rblen, bmax);\n                    rc = 1;\n                    break;\n                }\n                Jsi_DSAppendLen(&pss->recvBuf, inPtr, len);\n                if (!isfin) break;\n                cmdPtr->recvBufCnt--;\n                nlen = Jsi_DSLength(&pss->recvBuf);\n                inPtr = Jsi_DSFreeDup(&pss->recvBuf);\n            } else {\n                if (!isfin) {\n                    cmdPtr->recvBufCnt++;\n                    Jsi_DSAppendLen(&pss->recvBuf, inPtr, len);\n                    break;\n                }\n            }\n            rc = jsi_wsrecv_callback(interp, cmdPtr, pss, inPtr, nlen, 0);\n            if (inPtr != in)\n                Jsi_Free(inPtr);\n            if (rc != JSI_OK) {\n                Jsi_LogError(\"websock bad rcv eval\");\n                return 1;\n            }\n        }\n        lws_callback_on_writable_all_protocol(cmdPtr->context, lws_get_protocol(wsi));\n        break;\n\n    }\n    default:\n        break;\n    }\n    return rc;\n}\n\n\nstatic Jsi_RC WebSocketConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    jsi_wsCmdObj *cmdPtr = (jsi_wsCmdObj*)Jsi_UserObjGetData(interp, _this, funcPtr);\n\n    if (!cmdPtr)\n        return Jsi_LogError(\"Apply in a non-websock object\");\n    Jsi_Value *opts = Jsi_ValueArrayIndex(interp, args, 0);\n    if (cmdPtr->noConfig && opts && !Jsi_ValueIsString(interp, opts))\n        return Jsi_LogError(\"WebSocket conf() is disabled for set\");\n    return Jsi_OptionsConf(interp, WSOptions, cmdPtr, opts, ret, 0);\n\n}\n\nstatic Jsi_RC WebSocketIdCmdOp(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr, int op)\n{\n    Jsi_RC rc = JSI_OK;\n    jsi_wsCmdObj *cmdPtr = (jsi_wsCmdObj*)Jsi_UserObjGetData(interp, _this, funcPtr);\n    if (!cmdPtr)\n        return Jsi_LogError(\"Apply in a non-websock object\");\n    Jsi_Value *v, *valPtr = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_Number vid;\n    if (Jsi_ValueGetNumber(interp, valPtr, &vid) != JSI_OK || vid < 0)\n        return Jsi_LogError(\"Expected connection number id\");\n    int id = (int)vid;\n    jsi_wsPss *pss = NULL;\n    Jsi_HashEntry *hPtr;\n    Jsi_HashSearch cursor;\n    for (hPtr = Jsi_HashSearchFirst(cmdPtr->pssTable, &cursor);\n        hPtr != NULL; hPtr = Jsi_HashSearchNext(&cursor)) {\n        jsi_wsPss* tpss = (jsi_wsPss*)Jsi_HashValueGet(hPtr);\n        WSSIGASSERT(tpss, PWS);\n        if (tpss->wid == id && tpss->state != PWS_DEAD) {\n            pss = tpss;\n            break;\n        }\n    }\n\n    if (!pss)\n        return Jsi_LogError(\"No such id: %d\", id);\n    switch (op) {\n        case 0:\n            v = Jsi_ValueArrayIndex(interp, args, 1);\n            rc = Jsi_OptionsConf(interp, WPSOptions, pss, v, ret, 0);\n            break;\n        case 1:\n            jsi_wsDumpHeaders(cmdPtr, pss, Jsi_ValueArrayIndexToStr(interp, args, 1, NULL), ret);\n            break;\n        case 2:\n            if (!pss->spa) return JSI_OK;\n            jsi_wsDumpQuery(cmdPtr, pss, Jsi_ValueArrayIndexToStr(interp, args, 1, NULL), ret);\n            break;\n    }\n    return rc;\n}\n\nstatic Jsi_RC WebSocketIdConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    return WebSocketIdCmdOp(interp, args, _this, ret, funcPtr, 0);\n}\n\nstatic Jsi_RC WebSocketHeaderCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    return WebSocketIdCmdOp(interp, args, _this, ret, funcPtr, 1);\n}\n\nstatic Jsi_RC WebSocketQueryCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    return WebSocketIdCmdOp(interp, args, _this, ret, funcPtr, 2);\n}\n\n\nstatic Jsi_RC WebSocketIdsCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    jsi_wsCmdObj *cmdPtr = (jsi_wsCmdObj*)Jsi_UserObjGetData(interp, _this, funcPtr);\n    if (!cmdPtr)\n        return Jsi_LogError(\"Apply in a non-websock object\");\n    const char *val = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    Jsi_DString dStr = {\"[\"};\n    jsi_wsPss *pss = NULL;\n    Jsi_HashEntry *hPtr;\n    Jsi_HashSearch cursor;\n    int cnt = 0;\n    for (hPtr = Jsi_HashSearchFirst(cmdPtr->pssTable, &cursor);\n        hPtr != NULL; hPtr = Jsi_HashSearchNext(&cursor)) {\n        pss = (jsi_wsPss*)Jsi_HashValueGet(hPtr);\n        WSSIGASSERT(pss, PWS);\n        if (pss->state == PWS_DEAD) continue;\n        if (val && Jsi_Strcmp(pss->key, val)) continue;\n        Jsi_DSPrintf(&dStr, \"%s%d\", (cnt++?\",\":\"\"), pss->wid);\n        if (val) break;\n    }\n    Jsi_DSAppend(&dStr, \"]\", NULL);\n    Jsi_RC rc = Jsi_JSONParse(interp, Jsi_DSValue(&dStr), ret, 0);\n    Jsi_DSFree(&dStr);\n    return rc;\n}\n\n\nstatic Jsi_RC jsi_wsHandlerAdd(Jsi_Interp *interp, jsi_wsCmdObj *cmdPtr, const char *ext, const char *cmd, int flags)\n{\n    Jsi_HashEntry *hPtr;\n    jsi_wsHander *hdlPtr;\n    Jsi_Value *valPtr = Jsi_ValueNewStringDup(interp, cmd);\n    hPtr = Jsi_HashEntryNew(cmdPtr->handlers, ext, NULL);\n    if (!hPtr)\n        return JSI_ERROR;\n    hdlPtr = (jsi_wsHander *)Jsi_Calloc(1, sizeof(*hdlPtr));\n    hdlPtr->val = valPtr;\n    hdlPtr->flags = flags;\n    Jsi_HashValueSet(hPtr, hdlPtr);\n    Jsi_IncrRefCount(interp, valPtr);\n    return JSI_OK;\n}\n\n#define FN_wshandler JSI_INFO(\"\\\nWith no args, returns list of handlers.  With one arg, returns value for that handler.\\n\\\nOtherwise, sets the handler. When cmd is a string, the call is via runModule([cmd], arg).\\n\\\nIf a cmd is a function, it is called with a single arg: the file name.\")\nstatic Jsi_RC WebSocketHandlerCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    jsi_wsCmdObj *cmdPtr = (jsi_wsCmdObj*)Jsi_UserObjGetData(interp, _this, funcPtr);\n    Jsi_HashEntry *hPtr;\n    jsi_wsHander *hdlPtr;\n    if (!cmdPtr)\n        return Jsi_LogError(\"Apply in a non-websock object\");\n    WSSIGASSERT(cmdPtr, OBJ);\n    int argc = Jsi_ValueGetLength(interp, args);\n    if (argc == 0) {\n        Jsi_HashSearch search;\n        Jsi_Obj* obj = Jsi_ObjNew(interp);\n        for (hPtr = Jsi_HashSearchFirst(cmdPtr->handlers, &search); hPtr; hPtr = Jsi_HashSearchNext(&search)) {\n            const char *key = (char*)Jsi_HashKeyGet(hPtr);\n            Jsi_Value *val = (Jsi_Value*)Jsi_HashValueGet(hPtr);\n            Jsi_ObjInsert(interp, obj, key, val, 0);\n        }\n        Jsi_ValueMakeObject(interp, ret, obj);\n        return JSI_OK;\n    }\n    if (argc == 1) {\n        hPtr = Jsi_HashEntryFind(cmdPtr->handlers, Jsi_ValueArrayIndexToStr(interp, args, 0, NULL));\n        if (!hPtr)\n            return JSI_OK;\n        hdlPtr = (jsi_wsHander*)Jsi_HashValueGet(hPtr);\n        Jsi_ValueReplace(interp, ret, hdlPtr->val);\n        return JSI_OK;\n    }\n    const char *key = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    Jsi_Value *valPtr = Jsi_ValueArrayIndex(interp, args, 1);\n    if (Jsi_ValueIsNull(interp, valPtr)) {\n        hPtr = Jsi_HashEntryFind(cmdPtr->handlers, key);\n        if (!hPtr)\n            return JSI_OK;\n        hdlPtr = (jsi_wsHander*)Jsi_HashValueGet(hPtr);\n        if (hdlPtr->val)\n            Jsi_DecrRefCount(interp, hdlPtr->val);\n        Jsi_HashValueSet(hPtr, NULL);\n        Jsi_HashEntryDelete(hPtr);\n        Jsi_Free(hdlPtr);\n        Jsi_ValueMakeStringDup(interp, ret, key);\n        return JSI_OK;\n    }\n    if (Jsi_ValueIsFunction(interp, valPtr)==0 && Jsi_ValueIsString(interp, valPtr)==0)\n        return Jsi_LogError(\"expected string, function or null\");\n    Jsi_Value *argPtr = Jsi_ValueArrayIndex(interp, args, 2);\n    if (argPtr) {\n        if (Jsi_ValueIsNull(interp, argPtr))\n            argPtr = NULL;\n        else if (!Jsi_ValueIsString(interp, argPtr))\n            return Jsi_LogError(\"expected a string\");\n    }\n    hPtr = Jsi_HashEntryNew(cmdPtr->handlers, key, NULL);\n    if (!hPtr)\n        return JSI_ERROR;\n    hdlPtr = (jsi_wsHander *)Jsi_Calloc(1, sizeof(*hdlPtr));\n    Jsi_Value *flagPtr = Jsi_ValueArrayIndex(interp, args, 1);\n    Jsi_Number fl = 0;\n    if (flagPtr && Jsi_ValueIsNumber(interp, flagPtr))\n        Jsi_ValueGetNumber(interp, flagPtr, &fl);\n    hdlPtr->val = valPtr;\n    hdlPtr->flags = fl;\n    Jsi_HashValueSet(hPtr, hdlPtr);\n    Jsi_IncrRefCount(interp, valPtr);\n    return JSI_OK;\n}\n\n#define FN_wssend JSI_INFO(\"\\\nSend a message to one (or all connections if -1). If not already a string, msg is formatted as JSON prior to the send.\")\n\nstatic Jsi_RC WebSocketSendCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    jsi_wsCmdObj *cmdPtr = (jsi_wsCmdObj*)Jsi_UserObjGetData(interp, _this, funcPtr);\n    if (!cmdPtr)\n        return Jsi_LogError(\"Apply in a non-websock object\");\n    WSSIGASSERT(cmdPtr, OBJ);\n    jsi_wsPss *pss;\n    Jsi_HashEntry *hPtr;\n    Jsi_HashSearch cursor;\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 1);\n    char *str = Jsi_ValueString(interp, arg, NULL);\n    int id = -1, argc = Jsi_ValueGetLength(interp, args);\n    Jsi_DString eStr = {};\n    if (argc!=2)\n        return Jsi_LogError(\"wrong args\");\n    Jsi_Number dnum;\n    Jsi_Value *darg = Jsi_ValueArrayIndex(interp, args, 0);\n    if (Jsi_ValueGetNumber(interp, darg, &dnum) != JSI_OK)\n        return Jsi_LogError(\"invalid id\");\n    id = (int)dnum;\n\n    if (!str)\n        str = (char*)Jsi_ValueGetDString(interp, arg, &eStr, JSI_OUTPUT_JSON);\n\n    if (cmdPtr->echo)\n        Jsi_LogInfo(\"WS-SEND: %s\\n\", str);\n\n    for (hPtr = Jsi_HashSearchFirst(cmdPtr->pssTable, &cursor);\n        hPtr != NULL; hPtr = Jsi_HashSearchNext(&cursor)) {\n        pss = (jsi_wsPss*)Jsi_HashValueGet(hPtr);\n        WSSIGASSERT(pss, PWS);\n        if ((id<0 || pss->wid == id) && pss->state != PWS_DEAD) {\n            if (!pss->stack)\n                pss->stack = Jsi_StackNew();\n            char *msg = (char*)Jsi_Malloc(LWS_PRE + Jsi_Strlen(str) + 1);\n            Jsi_Strcpy(msg + LWS_PRE, str);\n            Jsi_StackPush(pss->stack, msg);\n            pss->stats.msgQLen++;\n            if (!cmdPtr->echo && pss->echo)\n                Jsi_LogInfo(\"WS-SEND: %s\\n\", str);\n        }\n    }\n\n    Jsi_DSFree(&eStr);\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_wsrecv_flush(jsi_wsCmdObj *cmdPtr, jsi_wsPss *pss)\n{\n    int nlen = Jsi_DSLength(&pss->recvBuf);\n    if (nlen<=0)\n        return JSI_OK;\n    cmdPtr->recvBufCnt--;\n    const char *inPtr = Jsi_DSFreeDup(&pss->recvBuf);\n    Jsi_RC rc = jsi_wsrecv_callback(cmdPtr->interp, cmdPtr, pss, inPtr, nlen, 0);\n    if (rc != JSI_OK) {\n        pss->stats.recvErrCnt++;\n        pss->stats.recvErrLast = time(NULL);\n    }\n    return rc;\n}\n\nstatic void jsi_wsOnModify(jsi_wsCmdObj *cmdPtr) {\n    if (!cmdPtr->stats.httpLast) return;\n    time_t now = time(NULL);\n    double dt = (difftime(now, cmdPtr->lastModifyCheck));\n    if (dt<0) {\n        cmdPtr->lastModifyCheck = now;\n        return;\n    }\n    uint secs = cmdPtr->modifySecs;\n    if (!secs) secs = 2;\n    if (dt<secs) return;\n    cmdPtr->lastModifyCheck = now;\n    Jsi_Interp *interp = cmdPtr->interp;\n    Jsi_HashEntry *hPtr;\n    Jsi_HashSearch cursor;\n    Jsi_Value* changed = NULL;\n    time_t ll = cmdPtr->lastModifyNotify;\n    if (ll<cmdPtr->stats.httpLast)\n        ll = cmdPtr->stats.httpLast;\n    for (hPtr = Jsi_HashSearchFirst(cmdPtr->fileHash, &cursor);\n        hPtr != NULL; hPtr = Jsi_HashSearchNext(&cursor)) {\n        jsi_wsFile* fPtr = (jsi_wsFile*)Jsi_HashValueGet(hPtr);\n        if (fPtr && fPtr->fileVal) {\n            Jsi_StatBuf sb;\n            int n = Jsi_Stat(interp, fPtr->fileVal, &sb);\n            if (!n && sb.st_mtime > ll) {\n                changed = fPtr->fileVal;\n                break;\n            }\n        }\n    }\n    cmdPtr->lastModifyCheck = time(NULL);\n    if (!changed) return;\n    Jsi_Obj *oarg1;\n    Jsi_Value *vpargs, *vargs[10];\n    int n = 0;\n    vargs[n++] = Jsi_ValueNewObj(interp, cmdPtr->fobj);\n    vargs[n++] = changed;\n    vpargs = Jsi_ValueMakeObject(interp, NULL, oarg1 = Jsi_ObjNewArray(interp, vargs, n, 0));\n    Jsi_IncrRefCount(interp, vpargs);\n\n    Jsi_Value *ret = Jsi_ValueNew1(interp);\n    Jsi_ValueMakeUndef(interp, &ret);\n    Jsi_RC rc = Jsi_FunctionInvoke(interp, cmdPtr->onModify, vpargs, &ret, NULL);\n\n    Jsi_DecrRefCount(interp, vpargs);\n    Jsi_DecrRefCount(interp, ret);\n    if (rc != JSI_OK) {\n        Jsi_LogWarn(\"websock bad onModify eval: disabling\");\n        Jsi_DecrRefCount(interp, cmdPtr->onModify);\n        cmdPtr->onModify = NULL;\n    }\n    cmdPtr->lastModifyCheck = time(NULL);\n    cmdPtr->lastModifyNotify = time(NULL);\n}\n\nstatic int jsi_wsService(jsi_wsCmdObj *cmdPtr)\n{\n    int n = 0;\n    struct timeval tv;\n    if (cmdPtr->inUpdate) return 0;\n    cmdPtr->inUpdate = 1;\n\n    gettimeofday(&tv, NULL);\n    int to = cmdPtr->recvBufTimeout;\n    if (to>0 && cmdPtr->recvBufCnt) { // Flush buffered data.\n        jsi_wsPss *pss = NULL;\n        Jsi_HashEntry *hPtr;\n        Jsi_HashSearch cursor;\n        for (hPtr = Jsi_HashSearchFirst(cmdPtr->pssTable, &cursor);\n            hPtr != NULL; hPtr = Jsi_HashSearchNext(&cursor)) {\n            pss = (jsi_wsPss*)Jsi_HashValueGet(hPtr);\n            WSSIGASSERT(pss, PWS);\n            if (pss->state == PWS_DEAD) continue;\n            if (Jsi_DSLength(&pss->recvBuf)<=0) continue;\n            if (pss->stats.recvLast && difftime(time(NULL), pss->stats.recvLast)<(double)to) continue;\n            jsi_wsrecv_flush(cmdPtr, pss);\n        }\n    }\n\n    /*\n     * This provokes the LWS_CALLBACK_SERVER_WRITEABLE for every\n     * live websocket connection using the DUMB_INCREMENT protocol,\n     * as soon as it can take more packets (usually immediately)\n     */\n\n    if (((unsigned int)tv.tv_usec - cmdPtr->oldus) > 50000) {\n        lws_callback_on_writable_all_protocol(cmdPtr->context, &cmdPtr->protocols[JWS_PROTOCOL_WEBSOCK]);\n        cmdPtr->oldus = tv.tv_usec;\n    }\n\n#ifdef EXTERNAL_POLL\n\n    /*\n     * this represents an existing server's single poll action\n     * which also includes libwebsocket sockets\n     */\n\n    n = poll(jsi_wspollfds, jsi_wsnum_pollfds, 50);\n    if (n < 0) {\n        n = 0;\n        goto done;\n    }\n\n    if (n)\n        for (n = 0; n < jsi_wsnum_pollfds; n++)\n            if (jsi_wspollfds[n].revents)\n                /*\n                * returns immediately if the fd does not\n                * match anything under libwebsockets\n                * control\n                */\n                if (lws_service_fd(context, &jsi_wspollfds[n]) < 0) {\n                    n = -1;\n                    goto done;\n                }\ndone:\n#else\n    n = lws_service(cmdPtr->context, 50);\n#endif\n    if (cmdPtr->onModify) {\n        jsi_wsOnModify(cmdPtr);\n    }\n    cmdPtr->inUpdate = 0;\n    return n;\n}\n\nstatic Jsi_RC WebSocketUpdateCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    jsi_wsCmdObj *cmdPtr = (jsi_wsCmdObj*)Jsi_UserObjGetData(interp, _this, funcPtr);\n    if (!cmdPtr)\n        return Jsi_LogError(\"Apply to non-websock object\");\n    if (!cmdPtr->noUpdate)\n        jsi_wsService(cmdPtr);\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_wswebsockUpdate(Jsi_Interp *interp, void *data)\n{\n    jsi_wsCmdObj *cmdPtr = (jsi_wsCmdObj*)data;\n    WSSIGASSERT(cmdPtr,OBJ);\n    jsi_wsService(cmdPtr);\n    return JSI_OK;\n}\n\nstatic void jsi_wswebsocketObjErase(jsi_wsCmdObj *cmdPtr)\n{\n    if (cmdPtr->interp) {\n        if (cmdPtr->event)\n            Jsi_EventFree(cmdPtr->interp, cmdPtr->event);\n        cmdPtr->event = NULL;\n        if (cmdPtr->hasOpts)\n            Jsi_OptionsFree(cmdPtr->interp, WSOptions, cmdPtr, 0);\n        cmdPtr->hasOpts = 0;\n        if (cmdPtr->handlers)\n            Jsi_HashDelete(cmdPtr->handlers);\n        cmdPtr->handlers = NULL;\n        if (cmdPtr->pssTable)\n            Jsi_HashDelete(cmdPtr->pssTable);\n        cmdPtr->pssTable = NULL;\n        if (cmdPtr->fileHash)\n            Jsi_HashDelete(cmdPtr->fileHash);\n        cmdPtr->fileHash = NULL;\n    }\n    cmdPtr->interp = NULL;\n}\n\nstatic Jsi_RC jsi_wswebsocketObjFree(Jsi_Interp *interp, void *data)\n{\n    jsi_wsCmdObj *cmdPtr = (jsi_wsCmdObj*)data;\n    WSSIGASSERT(cmdPtr,OBJ);\n    cmdPtr->deleted = 1;\n    struct lws_context *ctx = cmdPtr->context;\n    if (ctx)\n        lws_context_destroy(ctx);\n    cmdPtr->context = NULL;\n    cmdPtr->_->activeCnt--;\n    jsi_wswebsocketObjErase(cmdPtr);\n    _JSI_MEMCLEAR(cmdPtr);\n    Jsi_Free(cmdPtr);\n    return JSI_OK;\n}\n\nstatic bool jsi_wswebsocketObjIsTrue(void *data)\n{\n    return 1;\n}\n\nstatic bool jsi_wswebsocketObjEqual(void *data1, void *data2)\n{\n    return (data1 == data2);\n}\n\nstatic Jsi_RC jsi_wsfreeHandlers(Jsi_Interp *interp, Jsi_HashEntry* hPtr, void *ptr) {\n    jsi_wsHander *h = (jsi_wsHander*)ptr;\n    if (!h)\n        return JSI_OK;\n    if (h->val)\n        Jsi_DecrRefCount(interp, h->val);\n    if (h->objVar)\n        Jsi_DecrRefCount(interp, h->objVar);\n    Jsi_Free(h);\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_wsfreePss(Jsi_Interp *interp, Jsi_HashEntry* hPtr, void *ptr) {\n    jsi_wsPss *pss = (jsi_wsPss*)ptr;\n    WSSIGASSERT(pss, PWS);\n    if (pss) {\n        pss->hPtr = NULL;\n        jsi_wsdeletePss(pss);\n    }\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_wsfreeFile(Jsi_Interp *interp, Jsi_HashEntry* hPtr, void *ptr) {\n    jsi_wsFile*h = (jsi_wsFile*)ptr;\n    if (!h)\n        return JSI_OK;\n    if (h->fileVal)\n        Jsi_DecrRefCount(interp, h->fileVal);\n    Jsi_Free(h);\n    return JSI_OK;\n}\n\nstatic Jsi_RC WebSocketVersionCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    const char *verStr = NULL;\n    verStr = lws_get_library_version();\n    if (verStr) {\n        char buf[JSI_MAX_NUMBER_STRING], *cp;\n        snprintf(buf, sizeof(buf), \"%s\", verStr);\n        cp = Jsi_Strchr(buf, ' ');\n        if (cp) *cp = 0;\n        Jsi_ValueMakeStringDup(interp, ret, buf);\n    }\n    return JSI_OK;\n}\n\nstatic Jsi_RC WebSocketFileCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    jsi_wsCmdObj *cmdPtr = (jsi_wsCmdObj*)Jsi_UserObjGetData(interp, _this, funcPtr);\n    if (!cmdPtr)\n        return Jsi_LogError(\"Apply to non-websock object\");\n    Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 0);\n    if (val)\n        return jsi_wsFileAdd(interp, cmdPtr, val);\n    if (cmdPtr->fileHash)\n        return Jsi_HashKeysDump(interp, cmdPtr->fileHash, ret, 0);\n    return JSI_OK;\n}\n\nstatic Jsi_RC WebSocketStatusCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    jsi_wsCmdObj *cmdPtr = (jsi_wsCmdObj*)Jsi_UserObjGetData(interp, _this, funcPtr);\n    if (!cmdPtr)\n        return Jsi_LogError(\"Apply to non-websock object\");\n#ifndef OMIT_LWS_WITH_SERVER_STATUS\n    char cbuf[JSI_BUFSIZ*2];\n    lws_json_dump_context(cmdPtr->context, cbuf, sizeof(cbuf), 0);\n    return Jsi_JSONParse(interp, cbuf, ret, 0);\n#else\n    return Jsi_LogError(\"unsupported\");\n#endif\n}\n\n#define FN_WebSocket JSI_INFO(\"\\\nCreate a websocket server/client object.  The server serves out pages to a web browser,\\n\\\nwhich can use javascript to upgrade connection to a bidirectional websocket.\")\nstatic Jsi_RC WebSocketConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr);\n\n\nstatic Jsi_CmdSpec websockCmds[] = {\n    { \"WebSocket\",  WebSocketConstructor, 0,  1, \"options:object=void\", .help=\"Create websocket server/client object\", .retType=(uint)JSI_TT_USEROBJ, .flags=JSI_CMD_IS_CONSTRUCTOR, .info=FN_WebSocket, .opts=WSOptions },\n    { \"conf\",       WebSocketConfCmd,     0,  1, \"options:string|object=void\",.help=\"Configure options\", .retType=(uint)JSI_TT_ANY, .flags=0, .info=0, .opts=WSOptions },\n    { \"handler\",    WebSocketHandlerCmd,  0,  3, \"extension:string=void, cmd:string|function=void, flags:number=0\",\n        .help=\"Get/Set handler command for an extension\", .retType=(uint)JSI_TT_FUNCTION|JSI_TT_ARRAY|JSI_TT_STRING|JSI_TT_VOID, .flags=0, .info=FN_wshandler },\n    { \"ids\",        WebSocketIdsCmd,      0,  1, \"name:string=void\", .help=\"Return list of ids, or lookup one id\", .retType=(uint)JSI_TT_ARRAY},\n    { \"idconf\",     WebSocketIdConfCmd,   1,  2, \"id:number, options:string|object=void\",.help=\"Configure options for connect id\", .retType=(uint)JSI_TT_ANY, .flags=0, .info=0, .opts=WPSOptions },\n    { \"header\",     WebSocketHeaderCmd,   1,  2, \"id:number, name:string=void\",.help=\"Get one or all input headers for connect id\", .retType=(uint)JSI_TT_STRING|JSI_TT_ARRAY|JSI_TT_VOID },\n    { \"file\",       WebSocketFileCmd,     0,  1, \"name:string=void\",.help=\"Add file to hash, or with no args return file hash\", .retType=(uint)JSI_TT_ARRAY|JSI_TT_VOID },\n    { \"query\",      WebSocketQueryCmd,    1,  2, \"id:number, name:string=void\",.help=\"Get one or all query values for connect id\", .retType=(uint)JSI_TT_STRING|JSI_TT_OBJECT|JSI_TT_VOID },\n    { \"send\",       WebSocketSendCmd,     2,  2, \"id:number, data:any\", .help=\"Send a websocket message to id\", .retType=(uint)JSI_TT_VOID, .flags=0, .info=FN_wssend },\n    { \"status\",     WebSocketStatusCmd,   0,  0, \"\", .help=\"Return libwebsocket server status\", .retType=(uint)JSI_TT_OBJECT|JSI_TT_VOID},\n    { \"unalias\",    WebSocketUnaliasCmd,  1,  1, \"path:string\", .help=\"Return alias reverse lookup\", .retType=(uint)JSI_TT_STRING|JSI_TT_VOID},\n    { \"update\",     WebSocketUpdateCmd,   0,  0, \"\", .help=\"Service events for just this websocket\", .retType=(uint)JSI_TT_VOID },\n    { \"version\",    WebSocketVersionCmd,  0,  0, \"\", .help=\"Runtime library version string\", .retType=(uint)JSI_TT_STRING },\n    { NULL, 0,0,0,0, .help=\"Commands for managing WebSocket server/client connections\"  }\n};\n\n\nstatic Jsi_UserObjReg websockobject = {\n    \"WebSocket\",\n    websockCmds,\n    jsi_wswebsocketObjFree,\n    jsi_wswebsocketObjIsTrue,\n    jsi_wswebsocketObjEqual\n};\n\nstatic const struct lws_extension jsi_lws_exts[] = {\n    {\n        \"permessage-deflate\",\n        lws_extension_callback_pm_deflate,\n        \"permessage-deflate\"\n    },\n    {\n        \"deflate-frame\",\n        lws_extension_callback_pm_deflate,\n        \"deflate_frame\"\n    },\n    { NULL, NULL, NULL /* terminator */ }\n};\n\nstatic Jsi_RC WebSocketConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (Jsi_InterpAccess(interp, NULL, JSI_INTACCESS_NETWORK ) != JSI_OK)\n        return Jsi_LogError(\"WebSocket disallowed by Interp.noNetwork option\");\n    jsi_wsCmdObj *cmdPtr;\n    Jsi_Value *toacc = NULL;\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);\n\n    cmdPtr = (jsi_wsCmdObj*)Jsi_Calloc(1, sizeof(*cmdPtr));\n    cmdPtr->sig = JWS_SIG_OBJ;\n    cmdPtr->_ = &wsObjCmd;\n    cmdPtr->_->newCnt++;\n    cmdPtr->_->activeCnt++;\n    cmdPtr->port = 8080;\n    cmdPtr->formParams = jsi_wsparam_str;\n    cmdPtr->maxUpload = 100000;\n    cmdPtr->interp = interp;\n    cmdPtr->ietf_version = -1;\n    cmdPtr->bufferPwr2 = 0;\n    cmdPtr->ws_gid = -1;\n    cmdPtr->ws_uid = -1;\n    cmdPtr->startTime = time(NULL);\n    cmdPtr->hasOpts = 1;\n    cmdPtr->includeFile = \"include.shtml\";\n    cmdPtr->jsiFnPattern = \"jsig*.js\";\n    if ((arg != NULL && !Jsi_ValueIsNull(interp,arg))\n        && Jsi_OptionsProcess(interp, WSOptions, cmdPtr, arg, 0) < 0) {\nbail:\n        jsi_wswebsocketObjFree(interp, cmdPtr);\n        return JSI_ERROR;\n    }\n    if (!cmdPtr->udata) {\n        cmdPtr->udata = Jsi_ValueNewObj(interp, NULL);\n        Jsi_IncrRefCount(interp, cmdPtr->udata);\n    }\n    Jsi_PathNormalize(interp, &cmdPtr->rootdir);\n\n    if (cmdPtr->headers && (Jsi_ValueGetLength(interp, cmdPtr->headers)%2)) {\n        Jsi_LogError(\"Odd header length\");\n        goto bail;\n    }\n    const char *up = cmdPtr->urlPrefix, *ur = cmdPtr->urlRedirect;\n    if (up && ur && Jsi_Strncmp(ur, up, Jsi_Strlen(up))) {\n        Jsi_LogError(\"urlRedirect does not start with urlPrefix\");\n        goto bail;\n    }\n    const char* subprot = (cmdPtr->protocol&&cmdPtr->protocol[0]?cmdPtr->protocol:\"ws\");\n    if (cmdPtr->protocol && !cmdPtr->protocol[0])\n        Jsi_LogWarn(\"empty protocol string: forcing to 'ws'\");\n    cmdPtr->protocols[JWS_PROTOCOL_HTTP].name=\"http-only\";\n    cmdPtr->protocols[JWS_PROTOCOL_HTTP].callback=jsi_wscallback_http;\n    cmdPtr->protocols[JWS_PROTOCOL_HTTP].per_session_data_size=sizeof(jsi_wsUser);\n    cmdPtr->protocols[JWS_PROTOCOL_WEBSOCK].name=subprot;\n    cmdPtr->protocols[JWS_PROTOCOL_WEBSOCK].callback=jsi_wscallback_websock;\n    cmdPtr->protocols[JWS_PROTOCOL_WEBSOCK].per_session_data_size=sizeof(jsi_wsUser);\n\n    if (cmdPtr->bufferPwr2 == 0)\n        cmdPtr->bufferPwr2 = 16;\n    if (cmdPtr->bufferPwr2>0) {\n        if (cmdPtr->bufferPwr2>20) {\n            Jsi_LogError(\"bufferPwr2 not in 0-20: %d\", cmdPtr->bufferPwr2);\n            goto bail;\n        }\n        cmdPtr->protocols[JWS_PROTOCOL_WEBSOCK].rx_buffer_size=(1<<cmdPtr->bufferPwr2);\n    }\n\n    cmdPtr->pssTable = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, jsi_wsfreePss);\n    if (cmdPtr->onModify)\n        cmdPtr->fileHash = Jsi_HashNew(interp, JSI_KEYS_STRING, jsi_wsfreeFile);\n\n    cmdPtr->info.port = (cmdPtr->client ? CONTEXT_PORT_NO_LISTEN : cmdPtr->port);\n    cmdPtr->info.user = cmdPtr;\n    cmdPtr->info.iface = cmdPtr->interface ? Jsi_ValueString(interp, cmdPtr->interface, NULL) : NULL;\n    if (cmdPtr->local && !cmdPtr->info.iface)\n        cmdPtr->info.iface = \"lo\";\n#ifdef __WIN32\n    cmdPtr->info.iface = NULL;\n#endif\n    cmdPtr->info.protocols = cmdPtr->protocols;\n    if (!cmdPtr->noCompress)\n        cmdPtr->info.extensions = jsi_lws_exts;\n\n    cmdPtr->info.ssl_cert_filepath = cmdPtr->ssl_cert_filepath;\n    cmdPtr->info.ssl_private_key_filepath = cmdPtr->ssl_private_key_filepath;\n    cmdPtr->info.gid = cmdPtr->ws_gid;\n    cmdPtr->info.uid = cmdPtr->ws_uid;\n    cmdPtr->opts = LWS_SERVER_OPTION_SKIP_SERVER_CANONICAL_NAME|LWS_SERVER_OPTION_VALIDATE_UTF8;\n    cmdPtr->info.options = cmdPtr->opts;\n    cmdPtr->info.max_http_header_pool = 16;\n    cmdPtr->info.timeout_secs = 5;\n    cmdPtr->info.ssl_cipher_list = \"ECDHE-ECDSA-AES256-GCM-SHA384:\"\n                   \"ECDHE-RSA-AES256-GCM-SHA384:\"\n                   \"DHE-RSA-AES256-GCM-SHA384:\"\n                   \"ECDHE-RSA-AES256-SHA384:\"\n                   \"HIGH:!aNULL:!eNULL:!EXPORT:\"\n                   \"!DES:!MD5:!PSK:!RC4:!HMAC_SHA1:\"\n                   \"!SHA1:!DHE-RSA-AES128-GCM-SHA256:\"\n                   \"!DHE-RSA-AES128-SHA256:\"\n                   \"!AES128-GCM-SHA256:\"\n                   \"!AES128-SHA256:\"\n                   \"!DHE-RSA-AES256-SHA256:\"\n                   \"!AES256-GCM-SHA384:\"\n                   \"!AES256-SHA256\";\n\n    lws_set_log_level(cmdPtr->debug>255?cmdPtr->debug/256:0, NULL);\n    // TODO: WS2.2 Still leaks a small amount if server port unavailable.\n    if (!cmdPtr->client)\n        cmdPtr->info.options |= LWS_SERVER_OPTION_EXPLICIT_VHOSTS;\n    cmdPtr->context = lws_create_context(&cmdPtr->info);\n    if (cmdPtr->context == NULL) {\nfail:\n        Jsi_LogError(\"libwebsocket init failed on port %d (try another port?)\", cmdPtr->info.port);\n        goto bail;\n    }\n    if (cmdPtr->info.options & LWS_SERVER_OPTION_EXPLICIT_VHOSTS) {\n        cmdPtr->info.options &= ~LWS_SERVER_OPTION_EXPLICIT_VHOSTS;\n        if (!lws_create_vhost(cmdPtr->context, &cmdPtr->info))\n            goto fail;\n    }\n\n    if (cmdPtr->client) {\n        struct lws_client_connect_info lci = {};\n        lci.context = cmdPtr->context;\n        lci.address = cmdPtr->address ? Jsi_ValueString(cmdPtr->interp, cmdPtr->address, NULL) : \"127.0.0.1\";\n        lci.port = cmdPtr->port;\n        lci.ssl_connection = cmdPtr->use_ssl;\n        lci.path = Jsi_ValueString(cmdPtr->interp, cmdPtr->rootdir, NULL);\n        lci.host = cmdPtr->clientHost?cmdPtr->clientHost:lws_canonical_hostname( cmdPtr->context );\n        lci.origin = cmdPtr->clientOrigin?cmdPtr->clientOrigin:\"origin\";\n        lci.protocol = cmdPtr->protocols[JWS_PROTOCOL_WEBSOCK].name;\n        lci.ietf_version_or_minus_one = cmdPtr->ietf_version;\n#if (LWS_LIBRARY_VERSION_MAJOR>1)\n        if (cmdPtr->post)\n            lci.method = \"POST\";\n        else if (!Jsi_Strcmp(subprot, \"get\"))\n            lci.method = \"GET\";\n#endif\n\n        if (NULL == lws_client_connect_via_info(&lci))\n        {\n            Jsi_LogError(\"websock connect failed\");\n            jsi_wswebsocketObjFree(interp, cmdPtr);\n            return JSI_ERROR;\n        }\n    } else if (cmdPtr->port == 0) {\n        // Extract actually used port.\n        char *cp, cbuf[JSI_BUFSIZ*2];\n        cbuf[0] = 0;\n        lws_json_dump_context(cmdPtr->context, cbuf, sizeof(cbuf), 0);\n        cp = Jsi_Strstr(cbuf, \"\\\"port\\\":\\\"\");\n        if (cp)\n            cmdPtr->port = atoi(cp+8);\n    }\n\n    cmdPtr->event = Jsi_EventNew(interp, jsi_wswebsockUpdate, cmdPtr);\n    if (Jsi_FunctionIsConstructor(funcPtr)) {\n        toacc = _this;\n    } else {\n        Jsi_Obj *o = Jsi_ObjNew(interp);\n        Jsi_PrototypeObjSet(interp, \"WebSocket\", o);\n        Jsi_ValueMakeObject(interp, ret, o);\n        toacc = *ret;\n    }\n\n    Jsi_Obj *fobj = Jsi_ValueGetObj(interp, toacc);\n    if ((cmdPtr->objId = Jsi_UserObjNew(interp, &websockobject, fobj, cmdPtr))<0) {\n        goto bail;\n    }\n    Jsi_UserObjName(interp, toacc, &cmdPtr->cName);\n\n    cmdPtr->handlers = Jsi_HashNew(interp, JSI_KEYS_STRING, jsi_wsfreeHandlers);\n    if (cmdPtr->extHandlers) {\n        jsi_wsHandlerAdd(interp, cmdPtr, \".jsi\",   \"Jspp\",     1);\n        jsi_wsHandlerAdd(interp, cmdPtr, \".htmli\", \"Htmlpp\",   1);\n        jsi_wsHandlerAdd(interp, cmdPtr, \".cssi\",  \"Csspp\",    1);\n    }\n    cmdPtr->fobj = fobj;\n#ifdef LWS_LIBRARY_VERSION_NUMBER\n    Jsi_JSONParseFmt(interp, &cmdPtr->version, \"{libVer:\\\"%s\\\", hdrVer:\\\"%s\\\", hdrNum:%d, pkgVer:%d}\",\n        (char *)lws_get_library_version(), LWS_LIBRARY_VERSION, LWS_LIBRARY_VERSION_NUMBER, jsi_WsPkgVersion);\n#endif\n    return JSI_OK;\n}\n\nstatic Jsi_RC Jsi_DoneWebSocket(Jsi_Interp *interp)\n{\n    Jsi_UserObjUnregister(interp, &websockobject);\n    Jsi_PkgProvide(interp, \"WebSocket\", -1, NULL);\n    return JSI_OK;\n}\n\nJsi_RC Jsi_InitWebSocket(Jsi_Interp *interp, int release)\n{\n    if (release)\n        return Jsi_DoneWebSocket(interp);\n#ifdef LWS_OPENSSL_SUPPORT\n    Jsi_InterpAccess(interp, NULL, JSI_INTACCESS_SETSSL );\n#endif\n    Jsi_Hash *wsys;\n    const char *libver = lws_get_library_version();\n    int lvlen = sizeof(LWS_LIBRARY_VERSION)-1;\n    if (Jsi_Strncmp(libver, LWS_LIBRARY_VERSION, lvlen) || !isspace(libver[lvlen]))\n        return Jsi_LogError(\"Library version mismatch: HDR:%s != LIB:%s\", LWS_LIBRARY_VERSION, libver);\n#if JSI_USE_STUBS\n  if (Jsi_StubsInit(interp, 0) != JSI_OK)\n    return JSI_ERROR;\n#endif\n    Jsi_Value *info = Jsi_ValueNew1(interp);\n    Jsi_JSONParseFmt(interp, &info, \"{libVer:\\\"%s\\\", hdrVer:\\\"%s\\\", pkgVer:%d}\",\n        libver, LWS_LIBRARY_VERSION, jsi_WsPkgVersion);\n    Jsi_PkgOpts wsPkgOpts = { wsObjCmd_Specs, &wsObjCmd, websockCmds, info };\n    Jsi_RC rc = Jsi_PkgProvideEx(interp, \"WebSocket\", jsi_WsPkgVersion, Jsi_InitWebSocket, &wsPkgOpts);\n    Jsi_DecrRefCount(interp, info);\n    if (rc != JSI_OK)\n        return JSI_ERROR;\n    if (!(wsys = Jsi_UserObjRegister(interp, &websockobject))) {\n        Jsi_LogBug(\"Can not init webSocket\");\n        return JSI_ERROR;\n    }\n\n    if (!Jsi_CommandCreateSpecs(interp, websockobject.name, websockCmds, wsys, JSI_CMDSPEC_ISOBJ))\n        return JSI_ERROR;\n    return JSI_OK;\n}\n\n#endif\n#endif\n"], "filenames": ["src/jsi.h", "src/jsiCmds.c", "src/jsiCode.c", "src/jsiEval.c", "src/jsiFilesys.c", "src/jsiFunc.c", "src/jsiHash.c", "src/jsiInterp.c", "src/jsiJSON.c", "src/jsiMySql.c", "src/jsiNumber.c", "src/jsiOptions.c", "src/jsiPstate.c", "src/jsiRegexp.c", "src/jsiSqlite.c", "src/jsiString.c", "src/jsiTree.c", "src/jsiUtils.c", "src/jsiValue.c", "src/jsiWebSocket.c"], "buggy_code_start_loc": [7, 848, 439, 290, 1180, 192, 626, 703, 9, 1172, 126, 1879, 242, 165, 1398, 727, 949, 628, 404, 211], "buggy_code_end_loc": [217, 3957, 440, 2159, 1181, 343, 627, 944, 10, 1223, 195, 1880, 244, 166, 4397, 899, 1042, 947, 1383, 2874], "fixing_code_start_loc": [7, 848, 439, 290, 1180, 192, 626, 703, 9, 1172, 126, 1879, 242, 165, 1398, 727, 949, 628, 404, 211], "fixing_code_end_loc": [217, 3957, 440, 2159, 1181, 343, 627, 944, 10, 1223, 195, 1880, 244, 166, 4397, 899, 1042, 947, 1383, 2874], "type": "CWE-120", "message": "Buffer overflow vulnerability in function NumberToPrecisionCmd in jsish before 3.0.7, allows remote attackers to execute arbitrary code.", "other": {"cve": {"id": "CVE-2020-22873", "sourceIdentifier": "cve@mitre.org", "published": "2021-07-13T15:15:08.423", "lastModified": "2021-07-15T12:55:43.063", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Buffer overflow vulnerability in function NumberToPrecisionCmd in jsish before 3.0.7, allows remote attackers to execute arbitrary code."}, {"lang": "es", "value": "Una vulnerabilidad de desbordamiento de b\u00fafer en la funci\u00f3n NumberToPrecisionCmd en jsish versiones anteriores a 3.0.7, permite a atacantes remotos ejecutar c\u00f3digo arbitrario"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jsish:jsish:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.0.7", "matchCriteriaId": "B11C6466-F2B2-4958-B9C6-A002003C8E4D"}]}]}], "references": [{"url": "https://github.com/pcmacdon/jsish/commit/430ea27accd4d4ffddc946c9402e7c9064835a18", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pcmacdon/jsish/commit/430ea27accd4d4ffddc946c9402e7c9064835a18"}}