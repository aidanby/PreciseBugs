{"buggy_code": ["/*\n * Copyright 2013-2022 Erudika. https://erudika.com\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * For issues and patches go to: https://github.com/erudika\n */\npackage com.erudika.para.core;\n\nimport com.erudika.para.core.annotations.Email;\nimport com.erudika.para.core.annotations.Locked;\nimport com.erudika.para.core.annotations.Stored;\nimport com.erudika.para.core.i18n.CurrencyUtils;\nimport com.erudika.para.core.utils.Config;\nimport com.erudika.para.core.utils.CoreUtils;\nimport com.erudika.para.core.utils.Pager;\nimport com.erudika.para.core.utils.Para;\nimport com.erudika.para.core.utils.ParaObjectUtils;\nimport com.erudika.para.core.utils.Utils;\nimport com.fasterxml.jackson.annotation.JsonIgnore;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Objects;\nimport javax.validation.constraints.Max;\nimport javax.validation.constraints.NotBlank;\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * The core user object. Stores information about users.\n * @author Alex Bogdanovski [alex@erudika.com]\n */\npublic class User implements ParaObject {\n\tprivate static final long serialVersionUID = 1L;\n\tprivate static Logger logger = LoggerFactory.getLogger(User.class);\n\n\t/**\n\t * Maximum password length.\n\t */\n\tpublic static final int MAX_PASSWORD_LENGTH = 5000;\n\n\t@Stored @Locked private String id;\n\t@Stored @Locked private Long timestamp;\n\t@Stored @Locked private String type;\n\t@Stored @Locked private String appid;\n\t@Stored @Locked private String parentid;\n\t@Stored @Locked private String creatorid;\n\t@Stored private Long updated;\n\t@Stored private String name;\n\t@Stored private List<String> tags;\n\t@Stored private Integer votes;\n\t@Stored private Long version;\n\t@Stored private Boolean stored;\n\t@Stored private Boolean indexed;\n\t@Stored private Boolean cached;\n\n\t@Stored @NotBlank private String identifier;\n\t@Stored @Locked @NotBlank private String groups;\n\t@Stored private Boolean active;\n\t@Stored private Boolean twoFA;\n\t@Stored private String twoFAkey;\n\t@Stored private String twoFAbackupKeyHash;\n\t@Stored @NotBlank @Email private String email;\n\t@Stored private String currency;\n\t@Stored private String picture;\n\t@Stored @Locked private String tokenSecret;\n\t@Stored private String idpIdToken;\n\t@Stored private String idpAccessToken;\n\t@Stored private String idpRefreshToken;\n\n\tprivate transient @Max(MAX_PASSWORD_LENGTH) String password;\n\n\t/**\n\t * No-args constructor.\n\t */\n\tpublic User() {\n\t\tthis(null);\n\t}\n\n\t/**\n\t * Default constructor.\n\t * @param id the id\n\t */\n\tpublic User(String id) {\n\t\tsetId(id);\n\t\tsetName(getName());\n\t\tthis.groups = Groups.USERS.toString();\n\t}\n\n\t/**\n\t * Token secret - used for generating JWT tokens.\n\t * Changing this secret would invalidate all existing user tokens.\n\t * A kind of global \"logout\".\n\t * @return a random string\n\t */\n\t@JsonIgnore\n\tpublic String getTokenSecret() {\n\t\tif (tokenSecret == null) {\n\t\t\tresetTokenSecret();\n\t\t}\n\t\treturn tokenSecret;\n\t}\n\n\t/**\n\t * Sets the token secret.\n\t * @param tokenSecret a random string\n\t */\n\tpublic void setTokenSecret(String tokenSecret) {\n\t\tthis.tokenSecret = tokenSecret;\n\t}\n\n\t/**\n\t * The profile picture URL.\n\t * @return a URL or null\n\t */\n\tpublic String getPicture() {\n\t\treturn StringUtils.isBlank(picture) ?\n\t\t\t\t\"https://www.gravatar.com/avatar?d=mm&size=400\" : picture;\n\t}\n\n\t/**\n\t * Sets the profile picture URL.\n\t * @param picture the picture URL.\n\t */\n\tpublic void setPicture(String picture) {\n\t\tthis.picture = picture;\n\t}\n\n\t/**\n\t * Returns true if this account is active.\n\t * @return true if active\n\t */\n\tpublic Boolean getActive() {\n\t\tif (active == null) {\n\t\t\tactive = false;\n\t\t}\n\t\treturn active;\n\t}\n\n\t/**\n\t * Sets the account active.\n\t * @param active true if active\n\t */\n\tpublic void setActive(Boolean active) {\n\t\tthis.active = active;\n\t}\n\n\t/**\n\t * @return true if 2FA is enabled\n\t */\n\tpublic Boolean getTwoFA() {\n\t\tif (twoFA == null) {\n\t\t\ttwoFA = false;\n\t\t}\n\t\treturn twoFA;\n\t}\n\n\t/**\n\t * Sets 2FA enabled/disabled.\n\t * @param twoFA true if 2FA is enabled\n\t */\n\tpublic void setTwoFA(Boolean twoFA) {\n\t\tthis.twoFA = twoFA;\n\t}\n\n\t/**\n\t * @return the 2FA secret key. Used for checking the TOTP code.\n\t */\n\t@JsonIgnore\n\tpublic String getTwoFAkey() {\n\t\treturn twoFAkey;\n\t}\n\n\t/**\n\t * Sets the 2FA secret key.\n\t * @param twoFAkey secret key\n\t */\n\tpublic void setTwoFAkey(String twoFAkey) {\n\t\tthis.twoFAkey = twoFAkey;\n\t}\n\n\t/**\n\t * @return the hashed backup key (shown only once). Used for disabling 2FA.\n\t */\n\t@JsonIgnore\n\tpublic String getTwoFAbackupKeyHash() {\n\t\treturn twoFAbackupKeyHash;\n\t}\n\n\t/**\n\t * Sets the 2FA backup key hash.\n\t * @param twoFAbackupKeyHash bcrypt hash\n\t */\n\tpublic void setTwoFAbackupKeyHash(String twoFAbackupKeyHash) {\n\t\tthis.twoFAbackupKeyHash = twoFAbackupKeyHash;\n\t}\n\n\t/**\n\t * Returns the security groups for this user.\n\t * @return the groups string\n\t */\n\tpublic String getGroups() {\n\t\treturn groups;\n\t}\n\n\t/**\n\t * Sets the security groups for this user.\n\t * @param groups the groups string\n\t */\n\tpublic void setGroups(String groups) {\n\t\tthis.groups = groups;\n\t}\n\n\t/**\n\t * Returns the main identifier for this user.\n\t * An identifier is basically a unique username that identifies a user.\n\t * @return the main identifier\n\t */\n\tpublic String getIdentifier() {\n\t\treturn identifier;\n\t}\n\n\t/**\n\t * Sets the main identifier.\n\t * @param identifier the main identifier\n\t */\n\tpublic void setIdentifier(String identifier) {\n\t\tthis.identifier = identifier;\n\t}\n\n\t/**\n\t * The user's email.\n\t * @return email\n\t */\n\tpublic String getEmail() {\n\t\treturn StringUtils.lowerCase(email);\n\t}\n\n\t/**\n\t * Sets the email.\n\t * @param email email\n\t */\n\tpublic void setEmail(String email) {\n\t\tthis.email = email;\n\t}\n\n\t/**\n\t * The user's currency preference.\n\t * @return a currency 3-letter code in uppercase\n\t */\n\tpublic String getCurrency() {\n\t\treturn currency;\n\t}\n\n\t/**\n\t * Sets a preferred currency. Default is \"EUR\".\n\t * @param currency a 3-letter currency code\n\t */\n\tpublic void setCurrency(String currency) {\n\t\tcurrency = StringUtils.upperCase(currency);\n\t\tif (!CurrencyUtils.getInstance().isValidCurrency(currency)) {\n\t\t\tcurrency = \"EUR\";\n\t\t}\n\t\tthis.currency = currency;\n\t}\n\n\t/**\n\t * Generates a new token secret.\n\t * This is whould be equivalent to \"logout everywhere\".\n\t */\n\tpublic void resetTokenSecret() {\n\t\ttokenSecret = Utils.generateSecurityToken();\n\t}\n\n\t/**\n\t * Note: this method assumes that child objects can be modified by their parents.\n\t * This might not work for special cases where a parent has no rights over a child.\n\t * @param obj an object\n\t * @return true if the user is the creator or parent of this object or an admin user\n\t */\n\tpublic boolean canModify(ParaObject obj) {\n\t\tif (obj == null || id == null) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\tboolean isCreatedByMe = obj.getCreatorid() != null &&\n\t\t\t\t\t(obj.getCreatorid().startsWith(id + Para.getConfig().separator()) || id.equals(obj.getCreatorid()));\n\t\t\tboolean mine = isCreatedByMe || id.equals(obj.getId()) || id.equals(obj.getParentid());\n\t\t\treturn (mine || isAdmin());\n\t\t}\n\t}\n\n\t@Override\n\tpublic String create() {\n\t\tif (StringUtils.isBlank(getIdentifier())) {\n\t\t\tlogger.warn(\"Failed to create user - identifier not set.\");\n\t\t\treturn null;\n\t\t}\n\t\tif (!StringUtils.isBlank(getPassword()) && getPassword().length() < Para.getConfig().minPasswordLength()) {\n\t\t\tlogger.warn(\"Failed to create user - password too short.\");\n\t\t\treturn null;\n\t\t}\n\t\tif (readUserForIdentifier(this) != null) {\n\t\t\tlogger.warn(\"Failed to create user - user with identifier '{}' already exists.\", getIdentifier());\n\t\t\treturn null;\n\t\t}\n\n\t\t// admin detected\n\t\tif (!Para.getConfig().adminIdentifier().isEmpty() && Para.getConfig().adminIdentifier().equals(getIdentifier())) {\n\t\t\tlogger.info(\"Creating new user '{}' ({}) with admin privileges.\", getName(), getIdentifier());\n\t\t\tsetGroups(User.Groups.ADMINS.toString());\n\t\t}\n\n\t\tif (StringUtils.isBlank(getGroups())) {\n\t\t\tsetGroups(User.Groups.USERS.toString());\n\t\t}\n\n\t\tsetGravatarPicture();\n\n\t\tif (StringUtils.isBlank(tokenSecret)) {\n\t\t\tresetTokenSecret();\n\t\t}\n\n\t\tif (CoreUtils.getInstance().getDao().create(getAppid(), this) != null) {\n\t\t\tcreateIdentifier(getIdentifier(), getPassword());\n\t\t} else {\n\t\t\tlogger.warn(\"Failed to create user - dao.create() returned null.\");\n\t\t}\n\n\t\treturn getId();\n\t}\n\n\t@Override\n\tpublic void delete() {\n\t\tif (getId() != null) {\n\t\t\tCoreUtils.getInstance().getDao().deleteAll(getAppid(), getIdentifiers());\n\t\t\tCoreUtils.getInstance().getDao().delete(getAppid(), this);\n\t\t}\n\t}\n\n\t/**\n\t * Returns a list of identifiers for this user (can have many).\n\t * @return a list of {@link Sysprop} objects\n\t */\n\tprivate List<Sysprop> getIdentifiers() {\n\t\treturn CoreUtils.getInstance().getSearch().findTerms(getAppid(), Utils.type(Sysprop.class),\n\t\t\t\tCollections.singletonMap(Config._CREATORID, getId()), true);\n\t}\n\n\t/**\n\t * Attaches a new identifier to this user.\n\t * @param identifier a new identifier\n\t */\n\tpublic void attachIdentifier(String identifier) {\n\t\tif (this.exists()) {\n\t\t\tcreateIdentifier(identifier, Utils.generateSecurityToken());\n\t\t}\n\t}\n\n\t/**\n\t * Detaches a secondary identifier which is not already used by this user.\n\t * @param identifier an attached identifier\n\t */\n\tpublic void detachIdentifier(String identifier) {\n\t\tif (!StringUtils.equals(identifier, getIdentifier())) {\n\t\t\tSysprop s = CoreUtils.getInstance().getDao().read(getAppid(), identifier);\n\t\t\tif (s != null && StringUtils.equals(getId(), s.getCreatorid())) {\n\t\t\t\tdeleteIdentifier(identifier);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Is the main identifier a Facebook id.\n\t * @return true if user is signed in with Facebook\n\t */\n\t@JsonIgnore\n\tpublic boolean isFacebookUser() {\n\t\treturn StringUtils.startsWithIgnoreCase(identifier, Config.FB_PREFIX);\n\t}\n\n\t/**\n\t * Is the main identifier a Google+ id.\n\t * @return true if user is signed in with Google+\n\t */\n\t@JsonIgnore\n\tpublic boolean isGooglePlusUser() {\n\t\treturn StringUtils.startsWithIgnoreCase(identifier, Config.GPLUS_PREFIX);\n\t}\n\n\t/**\n\t * Is the main identifier a LinkedIn id.\n\t * @return true if user is signed in with LinkedIn\n\t */\n\t@JsonIgnore\n\tpublic boolean isLinkedInUser() {\n\t\treturn StringUtils.startsWithIgnoreCase(identifier, Config.LINKEDIN_PREFIX);\n\t}\n\n\t/**\n\t * Is the main identifier a Twitter id.\n\t * @return true if user is signed in with Twitter\n\t */\n\t@JsonIgnore\n\tpublic boolean isTwitterUser() {\n\t\treturn StringUtils.startsWithIgnoreCase(identifier, Config.TWITTER_PREFIX);\n\t}\n\n\t/**\n\t * Is the main identifier a GitHub id.\n\t * @return true if user is signed in with GitHub\n\t */\n\t@JsonIgnore\n\tpublic boolean isGitHubUser() {\n\t\treturn StringUtils.startsWithIgnoreCase(identifier, Config.GITHUB_PREFIX);\n\t}\n\n\t/**\n\t * Is the main identifier a Microsoft/Windows account id.\n\t * @return true if user is signed in with a Microsoft account\n\t */\n\t@JsonIgnore\n\tpublic boolean isMicrosoftUser() {\n\t\treturn StringUtils.startsWithIgnoreCase(identifier, Config.MICROSOFT_PREFIX);\n\t}\n\n\t/**\n\t * Is the main identifier a Slack account id.\n\t * @return true if user is signed in with a Slack account\n\t */\n\t@JsonIgnore\n\tpublic boolean isSlackUser() {\n\t\treturn StringUtils.startsWithIgnoreCase(identifier, Config.SLACK_PREFIX);\n\t}\n\n\t/**\n\t * Is the main identifier a Mattermost account id.\n\t * @return true if user is signed in with a Mattermost account\n\t */\n\t@JsonIgnore\n\tpublic boolean isMattermostUser() {\n\t\treturn StringUtils.startsWithIgnoreCase(identifier, Config.MATTERMOST_PREFIX);\n\t}\n\n\t/**\n\t * Is the main identifier a Amazon account id.\n\t * @return true if user is signed in with a Amazon account\n\t */\n\t@JsonIgnore\n\tpublic boolean isAmazonUser() {\n\t\treturn StringUtils.startsWithIgnoreCase(identifier, Config.AMAZON_PREFIX);\n\t}\n\n\t/**\n\t * Is the main identifier a LDAP account.\n\t * @return true if user is signed in with a LDAP account\n\t */\n\t@JsonIgnore\n\tpublic boolean isLDAPUser() {\n\t\treturn StringUtils.startsWithIgnoreCase(identifier, Config.LDAP_PREFIX);\n\t}\n\n\t/**\n\t * Is the main identifier a SAML account.\n\t * @return true if user is signed in with a SAML account\n\t */\n\t@JsonIgnore\n\tpublic boolean isSAMLUser() {\n\t\treturn StringUtils.startsWithIgnoreCase(identifier, Config.SAML_PREFIX);\n\t}\n\n\t/**\n\t * Is the main identifier from a generic OAuth 2.0/OpenID Connect provider.\n\t * @return true if user is signed in with a generic OAauth 2.0 account\n\t */\n\t@JsonIgnore\n\tpublic boolean isOAuth2User() {\n\t\treturn StringUtils.startsWithIgnoreCase(identifier, Config.OAUTH2_PREFIX) ||\n\t\t\t\tStringUtils.startsWithIgnoreCase(identifier, Config.OAUTH2_SECOND_PREFIX) ||\n\t\t\t\tStringUtils.startsWithIgnoreCase(identifier, Config.OAUTH2_THIRD_PREFIX);\n\t}\n\n\t/**\n\t * Checks for admin rights.\n\t * @return true if user has admin rights\n\t */\n\t@JsonIgnore\n\tpublic boolean isAdmin() {\n\t\treturn StringUtils.equalsIgnoreCase(this.groups, Groups.ADMINS.toString());\n\t}\n\n\t/**\n\t * Checks for moderator rights.\n\t * @return true if user has mod rights\n\t */\n\t@JsonIgnore\n\tpublic boolean isModerator() {\n\t\treturn isAdmin() ? true : StringUtils.equalsIgnoreCase(this.groups, Groups.MODS.toString());\n\t}\n\n\t/**\n\t * Returns the name of the identity provider.\n\t * @return \"facebook\", \"google\"... etc.\n\t */\n\tpublic String getIdentityProvider() {\n\t\tif (isFacebookUser()) {\n\t\t\treturn \"facebook\";\n\t\t} else if (isGooglePlusUser()) {\n\t\t\treturn \"google\";\n\t\t} else if (isGitHubUser()) {\n\t\t\treturn \"github\";\n\t\t} else if (isTwitterUser()) {\n\t\t\treturn \"twitter\";\n\t\t} else if (isLinkedInUser()) {\n\t\t\treturn \"linkedin\";\n\t\t} else if (isMicrosoftUser()) {\n\t\t\treturn \"microsoft\";\n\t\t} else if (isSlackUser()) {\n\t\t\treturn \"slack\";\n\t\t} else if (isMattermostUser()) {\n\t\t\treturn \"mattermost\";\n\t\t} else if (isAmazonUser()) {\n\t\t\treturn \"amazon\";\n\t\t} else if (isLDAPUser()) {\n\t\t\treturn \"ldap\";\n\t\t} else if (isSAMLUser()) {\n\t\t\treturn \"saml\";\n\t\t} else if (isOAuth2User()) {\n\t\t\treturn \"oauth2\";\n\t\t} else {\n\t\t\treturn \"generic\";\n\t\t}\n\t}\n\n\t/**\n\t * The password. A transient field used for validation.\n\t * @return the password.\n\t */\n\t@JsonIgnore\n\tpublic String getPassword() {\n\t\treturn password;\n\t}\n\n\t/**\n\t * Sets a password.\n\t * @param password a password\n\t */\n\tpublic void setPassword(String password) {\n\t\tthis.password = password;\n\t}\n\n\t/**\n\t * Used for storing the ID token from an OpenID Connect/OAuth 2.0 identity provider.\n\t * @return an ID token (JWT is always assumed to be the format)\n\t */\n\tpublic String getIdpIdToken() {\n\t\treturn idpIdToken;\n\t}\n\n\t/**\n\t * Sets the IDP ID token.\n\t * @param idpIdToken a token\n\t */\n\tpublic void setIdpIdToken(String idpIdToken) {\n\t\tthis.idpIdToken = idpIdToken;\n\t}\n\n\t/**\n\t * Used for storing the access token from an OpenID Connect/OAuth 2.0 identity provider.\n\t * @return a JWT access token (JWT is always assumed to be the format)\n\t */\n\tpublic String getIdpAccessToken() {\n\t\treturn idpAccessToken;\n\t}\n\n\t/**\n\t * Sets the IDP access token.\n\t * @param idpAccessToken a token\n\t */\n\tpublic void setIdpAccessToken(String idpAccessToken) {\n\t\tthis.idpAccessToken = idpAccessToken;\n\t}\n\n\t/**\n\t * Stores the refresh token from the identity provider.\n\t * @return a JWT refresh token\n\t */\n\tpublic String getIdpRefreshToken() {\n\t\treturn idpRefreshToken;\n\t}\n\n\t/**\n\t * Sets the refresh token.\n\t * @param idpRefreshToken a refresh token\n\t */\n\tpublic void setIdpRefreshToken(String idpRefreshToken) {\n\t\tthis.idpRefreshToken = idpRefreshToken;\n\t}\n\n\t/**\n\t * Returns the JWT payload for the ID token coming from the IDP.\n\t * Used for delegating user attributes data to clients. This must be a Base64-encoded JSON string.\n\t * @return the payload part in Base64\n\t */\n\t@JsonIgnore\n\tpublic String getIdpIdTokenPayload() {\n\t\treturn StringUtils.substringBetween(idpIdToken, \".\");\n\t}\n\n\t/**\n\t * Returns the JWT payload for the access token coming from the IDP.\n\t * Used for delegating user attributes data to clients. This must be a Base64-encoded JSON string.\n\t * @return the payload part in Base64\n\t */\n\t@JsonIgnore\n\tpublic String getIdpAccessTokenPayload() {\n\t\treturn StringUtils.substringBetween(idpAccessToken, \".\");\n\t}\n\n\t/**\n\t * Returns a user object for a given identifier.\n\t * @param u a user having a valid identifier set.\n\t * @return a user or null if no user is found for this identifier\n\t */\n\tpublic static final User readUserForIdentifier(final User u) {\n\t\tif (u == null || StringUtils.isBlank(u.getIdentifier())) {\n\t\t\treturn null;\n\t\t}\n\t\tUser user = null;\n\t\tString password = null;\n\t\tString identifier = u.getIdentifier();\n\t\t// Try to read the identifier object first, then read the user object linked to it.\n\t\tSysprop s = CoreUtils.getInstance().getDao().read(u.getAppid(), identifier);\n\t\tif (s != null && s.getCreatorid() != null) {\n\t\t\tuser = CoreUtils.getInstance().getDao().read(u.getAppid(), s.getCreatorid());\n\t\t\tpassword = (String) s.getProperty(Config._PASSWORD);\n\t\t}\n\t\t// Try to find the user by email if already created, but with a different identifier.\n\t\t// This prevents users with identical emails to have separate accounts by signing in through\n\t\t// different identity providers.\n\t\tif (user == null && !StringUtils.isBlank(u.getEmail())) {\n\t\t\tHashMap<String, Object> terms = new HashMap<>(2);\n\t\t\tterms.put(Config._EMAIL, u.getEmail());\n\t\t\tterms.put(Config._APPID, u.getAppid());\n\t\t\tPager p = new Pager(1);\n\t\t\tList<User> users = CoreUtils.getInstance().getSearch().findTerms(u.getAppid(), u.getType(), terms, true, p);\n\t\t\tif (!users.isEmpty()) {\n\t\t\t\tuser = users.get(0);\n\t\t\t\t// keep this random! dangerous to set it to user.getPassword()\n\t\t\t\tpassword = Utils.generateSecurityToken();\n\t\t\t\tuser.createIdentifier(u.getIdentifier(), password);\n\t\t\t\tif (p.getCount() > 1) {\n\t\t\t\t\tlogger.warn(\"{} user objects exist with the same email {}\", p.getCount(), user.getEmail());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (user != null) {\n\t\t\tif (password != null) {\n\t\t\t\t// used for remember me token signature calculations\n\t\t\t\tuser.setPassword(password);\n\t\t\t}\n\t\t\tif (!identifier.equals(user.getIdentifier())) {\n\t\t\t\tlogger.info(\"Identifier changed for user '{}', from {} to {}.\",\n\t\t\t\t\t\tuser.getId(), user.getIdentifier(), identifier);\n\t\t\t\t// the main identifier was changed - update\n\t\t\t\tuser.setIdentifier(identifier);\n\t\t\t\tCoreUtils.getInstance().getDao().update(user.getAppid(), user);\n\t\t\t}\n\t\t\treturn user;\n\t\t}\n\t\tlogger.debug(\"User not found for identifier {}/{}, {}.\", u.getAppid(), identifier, u.getId());\n\t\treturn null;\n\t}\n\n\t/**\n\t * Checks if a user has entered the correct password.\n\t * Compares password hashes.\n\t * @param u a user with a set password\n\t * @return true if password matches the one in the data store\n\t */\n\tpublic static final boolean passwordMatches(User u) {\n\t\tif (u == null) {\n\t\t\treturn false;\n\t\t}\n\t\tString password = u.getPassword();\n\t\tString identifier = u.getIdentifier();\n\t\tif (StringUtils.isBlank(password) || StringUtils.isBlank(identifier)) {\n\t\t\treturn false;\n\t\t}\n\t\tParaObject s = CoreUtils.getInstance().getDao().read(u.getAppid(), identifier);\n\t\tif (s != null) {\n\t\t\tif (s instanceof Sysprop) {\n\t\t\t\tString storedHash = (String) ((Sysprop) s).getProperty(Config._PASSWORD);\n\t\t\t\treturn Utils.bcryptMatches(password, storedHash);\n\t\t\t} else {\n\t\t\t\tLoggerFactory.getLogger(User.class).\n\t\t\t\t\t\twarn(Utils.formatMessage(\"Failed to read auth object for user '{}' using identifier '{}'.\",\n\t\t\t\t\t\t\t\tu.getId(), identifier));\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Generates a new password reset token. Sent via email for pass reset.\n\t * @return the pass reset token\n\t */\n\tpublic final String generatePasswordResetToken() {\n\t\tif (StringUtils.isBlank(identifier)) {\n\t\t\treturn \"\";\n\t\t}\n\t\tSysprop s = CoreUtils.getInstance().getDao().read(getAppid(), identifier);\n\t\tif (s != null) {\n\t\t\tString token = Utils.generateSecurityToken(42, true);\n\t\t\ts.addProperty(Config._RESET_TOKEN, token);\n\t\t\tCoreUtils.getInstance().getDao().update(getAppid(), s);\n\t\t\treturn token;\n\t\t}\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Changes the user password permanently.\n\t * @param token the reset token. see {@link #generatePasswordResetToken()}\n\t * @param newpass the new password\n\t * @return true if successful\n\t */\n\tpublic final boolean resetPassword(String token, String newpass) {\n\t\tif (StringUtils.isBlank(newpass) || StringUtils.isBlank(token) || newpass.length() < Para.getConfig().minPasswordLength()) {\n\t\t\treturn false;\n\t\t}\n\t\tSysprop s = CoreUtils.getInstance().getDao().read(getAppid(), identifier);\n\t\tif (isValidToken(s, Config._RESET_TOKEN, token)) {\n\t\t\ts.removeProperty(Config._RESET_TOKEN);\n\t\t\tString hashed = Utils.bcrypt(newpass);\n\t\t\ts.addProperty(Config._PASSWORD, hashed);\n\t\t\tsetPassword(hashed);\n\t\t\tCoreUtils.getInstance().getDao().update(getAppid(), s);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Creates a new identifier object using {@link Sysprop}.\n\t * Used for identifying a user when signing in.\n\t * @param newIdent a new identifier\n\t * @param password a password for the user (optional)\n\t * @return true if successful\n\t */\n\tprivate boolean createIdentifier(String newIdent, String password) {\n\t\tif (StringUtils.isBlank(getId()) || StringUtils.isBlank(newIdent)) {\n\t\t\treturn false;\n\t\t}\n\t\tSysprop s = new Sysprop();\n\t\ts.setId(newIdent);\n\t\ts.setName(Config._IDENTIFIER);\n\t\ts.setCreatorid(getId());\n\t\tif (!StringUtils.isBlank(password)) {\n\t\t\tString hashed = Utils.bcrypt(password);\n\t\t\ts.addProperty(Config._PASSWORD, hashed);\n\t\t\tsetPassword(hashed);\n\t\t}\n\t\treturn CoreUtils.getInstance().getDao().create(getAppid(), s) != null;\n\t}\n\n\t/**\n\t * Deletes the identifier and the user can no longer sign in with it.\n\t * @param ident the attached identifier\n\t */\n\tprivate void deleteIdentifier(String ident) {\n\t\tif (!StringUtils.isBlank(ident)) {\n\t\t\tCoreUtils.getInstance().getDao().delete(getAppid(), new Sysprop(ident));\n\t\t}\n\t}\n\n\t/**\n\t * Generates a new email confirmation token. Sent via email for user activation.\n\t * @return a Base64 encoded UUID\n\t */\n\tpublic String generateEmailConfirmationToken() {\n\t\tif (StringUtils.isBlank(identifier)) {\n\t\t\treturn \"\";\n\t\t}\n\t\tSysprop s = CoreUtils.getInstance().getDao().read(getAppid(), identifier);\n\t\tif (s != null) {\n\t\t\tString token = Utils.base64encURL(Utils.generateSecurityToken().getBytes());\n\t\t\ts.addProperty(Config._EMAIL_TOKEN, token);\n\t\t\tCoreUtils.getInstance().getDao().update(getAppid(), s);\n\t\t\treturn token;\n\t\t}\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Activates a user if a given token matches the one stored.\n\t * @param token the email confirmation token. see {@link #generateEmailConfirmationToken() }\n\t * @return true if successful\n\t */\n\tpublic final boolean activateWithEmailToken(String token) {\n\t\tSysprop s = CoreUtils.getInstance().getDao().read(getAppid(), identifier);\n\t\tif (isValidToken(s, Config._EMAIL_TOKEN, token)) {\n\t\t\ts.removeProperty(Config._EMAIL_TOKEN);\n\t\t\tCoreUtils.getInstance().getDao().update(getAppid(), s);\n\t\t\tsetActive(true);\n\t\t\tupdate();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Validates a token sent via email for password reset.\n\t * @param token a token\n\t * @return true if valid\n\t */\n\tpublic final boolean isValidPasswordResetToken(String token) {\n\t\tSysprop s = CoreUtils.getInstance().getDao().read(getAppid(), identifier);\n\t\treturn isValidToken(s, Config._RESET_TOKEN, token);\n\t}\n\n\t/**\n\t * Validates a token sent for email confirmation.\n\t * @param token a token\n\t * @return true if valid\n\t */\n\tpublic final boolean isValidEmailConfirmationToken(String token) {\n\t\tSysprop s = CoreUtils.getInstance().getDao().read(getAppid(), identifier);\n\t\treturn isValidToken(s, Config._EMAIL_TOKEN, token);\n\t}\n\n\tprivate boolean isValidToken(Sysprop s, String key, String token) {\n\t\tif (StringUtils.isBlank(token)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (s != null && s.hasProperty(key)) {\n\t\t\tString storedToken = (String) s.getProperty(key);\n\t\t\t// tokens expire afer a reasonably short period ~ 30 mins\n\t\t\tlong timeout = (long) Para.getConfig().passwordResetTimeoutSec() * 1000L;\n\t\t\tif (StringUtils.equals(storedToken, token) && (s.getUpdated() + timeout) > Utils.timestamp()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Sets the profile picture using the Gravatar service.\n\t */\n\tprivate void setGravatarPicture() {\n\t\tif (StringUtils.isBlank(picture)) {\n\t\t\tif (email != null) {\n\t\t\t\tString emailHash = Utils.md5(email.toLowerCase());\n\t\t\t\tsetPicture(\"https://www.gravatar.com/avatar/\" + emailHash + \"?size=400&d=mm&r=pg\");\n\t\t\t} else {\n\t\t\t\tsetPicture(\"https://www.gravatar.com/avatar?d=mm&size=400\");\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Simple groups enum.\n\t */\n\tpublic enum Groups {\n\t\t/**\n\t\t * The standard user group.\n\t\t */\n\t\tUSERS,\n\t\t/**\n\t\t * Moderators group.\n\t\t */\n\t\tMODS,\n\t\t/**\n\t\t * Administrators group.\n\t\t */\n\t\tADMINS;\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn this.name().toLowerCase();\n\t\t}\n\t}\n\n\t/**\n\t * Simple user roles enum.\n\t */\n\tpublic enum Roles {\n\t\t/**\n\t\t * The standard role.\n\t\t */\n\t\tUSER,\n\t\t/**\n\t\t * The moderator role.\n\t\t */\n\t\tMOD,\n\t\t/**\n\t\t * The administrator role.\n\t\t */\n\t\tADMIN;\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"ROLE_\".concat(this.name());\n\t\t}\n\t}\n\n\t////////////////////////////////////////////////////////\n\n\t@Override\n\tpublic final String getId() {\n\t\treturn id;\n\t}\n\n\t@Override\n\tpublic final void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n\t@Override\n\tpublic final String getType() {\n\t\ttype = (type == null) ? Utils.type(this.getClass()) : type;\n\t\treturn type;\n\t}\n\n\t@Override\n\tpublic final void setType(String type) {\n\t\tthis.type = type;\n\t}\n\n\t@Override\n\tpublic String getAppid() {\n\t\tappid = (appid == null) ? Para.getConfig().getRootAppIdentifier() : appid;\n\t\treturn appid;\n\t}\n\n\t@Override\n\tpublic void setAppid(String appid) {\n\t\tthis.appid = appid;\n\t}\n\n\t@Override\n\tpublic String getObjectURI() {\n\t\treturn CoreUtils.getInstance().getObjectURI(this);\n\t}\n\n\t@Override\n\tpublic List<String> getTags() {\n\t\treturn tags;\n\t}\n\n\t@Override\n\tpublic void setTags(List<String> tags) {\n\t\tthis.tags = tags;\n\t}\n\n\t@Override\n\tpublic Boolean getStored() {\n\t\tif (stored == null) {\n\t\t\tstored = true;\n\t\t}\n\t\treturn stored;\n\t}\n\n\t@Override\n\tpublic void setStored(Boolean stored) {\n\t\tthis.stored = stored;\n\t}\n\n\t@Override\n\tpublic Boolean getIndexed() {\n\t\tif (indexed == null) {\n\t\t\tindexed = true;\n\t\t}\n\t\treturn indexed;\n\t}\n\n\t@Override\n\tpublic void setIndexed(Boolean indexed) {\n\t\tthis.indexed = indexed;\n\t}\n\n\t@Override\n\tpublic Boolean getCached() {\n\t\tif (cached == null) {\n\t\t\tcached = true;\n\t\t}\n\t\treturn cached;\n\t}\n\n\t@Override\n\tpublic void setCached(Boolean cached) {\n\t\tthis.cached = cached;\n\t}\n\n\t@Override\n\tpublic Long getTimestamp() {\n\t\treturn (timestamp != null && timestamp != 0) ? timestamp : null;\n\t}\n\n\t@Override\n\tpublic void setTimestamp(Long timestamp) {\n\t\tthis.timestamp = timestamp;\n\t}\n\n\t@Override\n\tpublic String getCreatorid() {\n\t\treturn creatorid;\n\t}\n\n\t@Override\n\tpublic void setCreatorid(String creatorid) {\n\t\tthis.creatorid = creatorid;\n\t}\n\n\t@Override\n\tpublic final String getName() {\n\t\treturn CoreUtils.getInstance().getName(name, id);\n\t}\n\n\t@Override\n\tpublic final void setName(String name) {\n\t\tthis.name = (name == null || !name.isEmpty()) ? name : this.name;\n\t}\n\n\t@Override\n\tpublic String getPlural() {\n\t\treturn Utils.singularToPlural(getType());\n\t}\n\n\t@Override\n\tpublic String getParentid() {\n\t\treturn parentid;\n\t}\n\n\t@Override\n\tpublic void setParentid(String parentid) {\n\t\tthis.parentid = parentid;\n\t}\n\n\t@Override\n\tpublic Long getUpdated() {\n\t\treturn (updated != null && updated != 0) ? updated : null;\n\t}\n\n\t@Override\n\tpublic void setUpdated(Long updated) {\n\t\tthis.updated = updated;\n\t}\n\n\t@Override\n\tpublic void update() {\n\t\tCoreUtils.getInstance().getDao().update(getAppid(), this);\n\t}\n\n\t@Override\n\tpublic boolean exists() {\n\t\treturn CoreUtils.getInstance().getDao().read(getAppid(), getId()) != null;\n\t}\n\n\t@Override\n\tpublic boolean voteUp(String userid) {\n\t\treturn CoreUtils.getInstance().vote(this, userid, VoteValue.UP);\n\t}\n\n\t@Override\n\tpublic boolean voteDown(String userid) {\n\t\treturn CoreUtils.getInstance().vote(this, userid, VoteValue.DOWN);\n\t}\n\n\t@Override\n\tpublic Integer getVotes() {\n\t\treturn (votes == null) ? 0 : votes;\n\t}\n\n\t@Override\n\tpublic void setVotes(Integer votes) {\n\t\tthis.votes = votes;\n\t}\n\n\t@Override\n\tpublic Long getVersion() {\n\t\treturn (version == null) ? 0 : version;\n\t}\n\n\t@Override\n\tpublic void setVersion(Long version) {\n\t\tthis.version = version;\n\t}\n\n\t@Override\n\tpublic Long countLinks(String type2) {\n\t\treturn CoreUtils.getInstance().countLinks(this, type2);\n\t}\n\n\t@Override\n\tpublic List<Linker> getLinks(String type2, Pager... pager) {\n\t\treturn CoreUtils.getInstance().getLinks(this, type2, pager);\n\t}\n\n\t@Override\n\tpublic <P extends ParaObject> List<P> getLinkedObjects(String type, Pager... pager) {\n\t\treturn CoreUtils.getInstance().getLinkedObjects(this, type, pager);\n\t}\n\n\t@Override\n\tpublic <P extends ParaObject> List<P> findLinkedObjects(String type, String field, String query, Pager... pager) {\n\t\treturn CoreUtils.getInstance().findLinkedObjects(this, type, field, query, pager);\n\t}\n\n\t@Override\n\tpublic boolean isLinked(String type2, String id2) {\n\t\treturn CoreUtils.getInstance().isLinked(this, type2, id2);\n\t}\n\n\t@Override\n\tpublic boolean isLinked(ParaObject toObj) {\n\t\treturn CoreUtils.getInstance().isLinked(this, toObj);\n\t}\n\n\t@Override\n\tpublic String link(String id2) {\n\t\treturn CoreUtils.getInstance().link(this, id2);\n\t}\n\n\t@Override\n\tpublic void unlink(String type, String id2) {\n\t\tCoreUtils.getInstance().unlink(this, type, id2);\n\t}\n\n\t@Override\n\tpublic void unlinkAll() {\n\t\tCoreUtils.getInstance().unlinkAll(this);\n\t}\n\n\t@Override\n\tpublic Long countChildren(String type) {\n\t\treturn CoreUtils.getInstance().countChildren(this, type);\n\t}\n\n\t@Override\n\tpublic <P extends ParaObject> List<P> getChildren(String type, Pager... pager) {\n\t\treturn CoreUtils.getInstance().getChildren(this, type, pager);\n\t}\n\n\t@Override\n\tpublic <P extends ParaObject> List<P> getChildren(String type, String field, String term, Pager... pager) {\n\t\treturn CoreUtils.getInstance().getChildren(this, type, field, term, pager);\n\t}\n\n\t@Override\n\tpublic <P extends ParaObject> List<P> findChildren(String type, String query, Pager... pager) {\n\t\treturn CoreUtils.getInstance().findChildren(this, type, query, pager);\n\t}\n\n\t@Override\n\tpublic void deleteChildren(String type) {\n\t\tCoreUtils.getInstance().deleteChildren(this, type);\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tint hash = 7;\n\t\thash = 67 * hash + Objects.hashCode(this.id) + Objects.hashCode(this.name);\n\t\treturn hash;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (obj == null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (getClass() != obj.getClass()) {\n\t\t\treturn false;\n\t\t}\n\t\tfinal ParaObject other = (ParaObject) obj;\n\t\tif (!Objects.equals(this.id, other.getId())) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn ParaObjectUtils.toJSON(this);\n\t}\n}\n", "/*\n * Copyright 2013-2022 Erudika. https://erudika.com\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * For issues and patches go to: https://github.com/erudika\n */\npackage com.erudika.para.core.validation;\n\nimport com.erudika.para.core.App;\nimport com.erudika.para.core.ParaObject;\nimport com.erudika.para.core.Sysprop;\nimport com.erudika.para.core.User;\nimport com.erudika.para.core.annotations.Email;\nimport com.erudika.para.core.utils.Config;\nimport com.erudika.para.core.utils.ParaObjectUtils;\nimport com.erudika.para.core.utils.Utils;\nimport static com.erudika.para.core.validation.Constraint.digits;\nimport static com.erudika.para.core.validation.Constraint.email;\nimport static com.erudika.para.core.validation.Constraint.falsy;\nimport static com.erudika.para.core.validation.Constraint.fromAnnotation;\nimport static com.erudika.para.core.validation.Constraint.future;\nimport static com.erudika.para.core.validation.Constraint.isValidConstraintType;\nimport static com.erudika.para.core.validation.Constraint.matches;\nimport static com.erudika.para.core.validation.Constraint.max;\nimport static com.erudika.para.core.validation.Constraint.min;\nimport static com.erudika.para.core.validation.Constraint.past;\nimport static com.erudika.para.core.validation.Constraint.pattern;\nimport static com.erudika.para.core.validation.Constraint.required;\nimport static com.erudika.para.core.validation.Constraint.size;\nimport static com.erudika.para.core.validation.Constraint.truthy;\nimport static com.erudika.para.core.validation.Constraint.url;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Field;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport javax.validation.ConstraintViolation;\nimport javax.validation.Validation;\nimport javax.validation.Validator;\nimport javax.validation.constraints.AssertFalse;\nimport javax.validation.constraints.AssertTrue;\nimport javax.validation.constraints.Digits;\nimport javax.validation.constraints.Future;\nimport javax.validation.constraints.Max;\nimport javax.validation.constraints.Min;\nimport javax.validation.constraints.Past;\nimport javax.validation.constraints.Pattern;\nimport javax.validation.constraints.Size;\nimport org.apache.commons.beanutils.PropertyUtils;\nimport org.apache.commons.lang3.math.NumberUtils;\nimport org.hibernate.validator.constraints.URL;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Helper methods for validating objects and generating JSON schemas.\n *\n * @author Alex Bogdanovski [alex@erudika.com]\n */\npublic final class ValidationUtils {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(ValidationUtils.class);\n\tprivate static final Map<String, Map<String, Map<String, Map<String, ?>>>> CORE_CONSTRAINTS =\n\t\t\tnew HashMap<String, Map<String, Map<String, Map<String, ?>>>>();\n\tprivate static Validator validator;\n\n\tprivate ValidationUtils() {\n\t}\n\n\t/**\n\t * A Hibernate Validator.\n\t * @return a validator object\n\t */\n\tpublic static Validator getValidator() {\n\t\tif (validator == null) {\n\t\t\tvalidator = Validation.buildDefaultValidatorFactory().getValidator();\n\t\t}\n\t\treturn validator;\n\t}\n\n\t/**\n\t * Validates objects using Hibernate Validator. Used for basic validation.\n\t * @param obj an object to be validated\n\t * @return true if the object is valid (all fields are populated properly)\n\t */\n\tpublic static boolean isValidObject(ParaObject obj) {\n\t\treturn validateObject(obj).length == 0;\n\t}\n\n\t/**\n\t * Validates objects using Hibernate Validator. Used for full object validation.\n\t * @param app the current app\n\t * @param obj an object to be validated\n\t * @return true if the object is valid (all fields are populated properly)\n\t */\n\tpublic static boolean isValidObject(App app, ParaObject obj) {\n\t\treturn validateObject(app, obj).length == 0;\n\t}\n\n\t/**\n\t * Validates objects using Hibernate Validator.\n\t * @param content an object to be validated\n\t * @return a list of error messages or empty if object is valid\n\t */\n\tpublic static String[] validateObject(ParaObject content) {\n\t\tif (content == null) {\n\t\t\treturn new String[]{\"Object cannot be null.\"};\n\t\t}\n\t\tLinkedList<String> list = new LinkedList<>();\n\t\ttry {\n\t\t\tfor (ConstraintViolation<ParaObject> constraintViolation : getValidator().validate(content)) {\n\t\t\t\tString prop = \"'\".concat(constraintViolation.getPropertyPath().toString()).concat(\"'\");\n\t\t\t\tlist.add(prop.concat(\" \").concat(constraintViolation.getMessage()));\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tlogger.error(null, e);\n\t\t}\n\t\treturn list.toArray(new String[]{});\n\t}\n\n\t/**\n\t * Validates objects.\n\t * @param content an object to be validated\n\t * @param app the current app\n\t * @return a list of error messages or empty if object is valid\n\t */\n\tpublic static String[] validateObject(App app, ParaObject content) {\n\t\tif (content == null || app == null) {\n\t\t\treturn new String[]{\"Object cannot be null.\"};\n\t\t}\n\t\ttry {\n\t\t\tString type = content.getType();\n\t\t\tboolean isCustomType = (content instanceof Sysprop) && !type.equals(Utils.type(Sysprop.class));\n\t\t\t// Validate custom types and user-defined properties\n\t\t\tif (!app.getValidationConstraints().isEmpty() && isCustomType) {\n\t\t\t\tMap<String, Map<String, Map<String, ?>>> fieldsMap = app.getValidationConstraints().get(type);\n\t\t\t\tif (fieldsMap != null && !fieldsMap.isEmpty()) {\n\t\t\t\t\tLinkedList<String> errors = new LinkedList<>();\n\t\t\t\t\tfor (Map.Entry<String, Map<String, Map<String, ?>>> e : fieldsMap.entrySet()) {\n\t\t\t\t\t\tString field = e.getKey();\n\t\t\t\t\t\tObject actualValue = ((Sysprop) content).getProperty(field);\n\t\t\t\t\t\t// overriding core property validation rules is allowed\n\t\t\t\t\t\tif (actualValue == null && PropertyUtils.isReadable(content, field)) {\n\t\t\t\t\t\t\tactualValue = PropertyUtils.getProperty(content, field);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tMap<String, Map<String, ?>> consMap = e.getValue();\n\t\t\t\t\t\tfor (Map.Entry<String, Map<String, ?>> constraint : consMap.entrySet()) {\n\t\t\t\t\t\t\tbuildAndValidateConstraint(constraint, field, actualValue, errors);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!errors.isEmpty()) {\n\t\t\t\t\t\treturn errors.toArray(new String[0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception ex) {\n\t\t\tlogger.error(null, ex);\n\t\t}\n\t\treturn validateObject(content);\n\t}\n\n\tprivate static void buildAndValidateConstraint(Map.Entry<String, Map<String, ?>> constraint, String field,\n\t\t\tObject actualValue, LinkedList<String> errors) {\n\t\tif (constraint == null) {\n\t\t\treturn;\n\t\t}\n\t\tString consName = constraint.getKey();\n\t\tMap<String, ?> vals = constraint.getValue();\n\t\tif (vals == null) {\n\t\t\tvals = Collections.emptyMap();\n\t\t}\n\n\t\tObject val = vals.get(\"value\");\n\t\tlong min = NumberUtils.toLong(vals.get(\"min\") + \"\", 0);\n\t\tlong max = NumberUtils.toLong(vals.get(\"max\") + \"\", Config.DEFAULT_LIMIT);\n\n\t\tif (isValidSimpleConstraint(consName, field, actualValue, errors)) {\n\t\t\tif (matches(Min.class, consName) && !min(NumberUtils.toLong(val + \"\", 0)).isValid(actualValue)) {\n\t\t\t\terrors.add(Utils.formatMessage(\"{0} must be a number larger than {1}.\", field, val));\n\t\t\t} else if (matches(Max.class, consName) && !max(NumberUtils.toLong(val + \"\",\n\t\t\t\t\tConfig.DEFAULT_LIMIT)).isValid(actualValue)) {\n\t\t\t\terrors.add(Utils.formatMessage(\"{0} must be a number smaller than {1}.\", field, val));\n\t\t\t} else if (matches(Size.class, consName) && !size(min, max).isValid(actualValue)) {\n\t\t\t\terrors.add(Utils.formatMessage(\"{0} must be between {1} and {2}.\", field, min, max));\n\t\t\t} else if (matches(Digits.class, consName) && !digits(NumberUtils.toLong(vals.get(\"integer\") + \"\", 0),\n\t\t\t\t\tNumberUtils.toLong(vals.get(\"fraction\") + \"\", 0)).isValid(actualValue)) {\n\t\t\t\terrors.add(Utils.formatMessage(\"{0} is not a valid number or within range.\", field));\n\t\t\t} else if (matches(Pattern.class, consName) && !pattern(val).isValid(actualValue)) {\n\t\t\t\terrors.add(Utils.formatMessage(\"{0} doesn't match the pattern {1}.\", field, val));\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static boolean isValidSimpleConstraint(String cName, String field, Object actual, LinkedList<String> err) {\n\t\tif (\"required\".equals(cName) && !required().isValid(actual)) {\n\t\t\terr.add(Utils.formatMessage(\"{0} is required.\", field));\n\t\t\treturn false;\n\t\t} else if (matches(AssertFalse.class, cName) && !falsy().isValid(actual)) {\n\t\t\terr.add(Utils.formatMessage(\"{0} must be false.\", field));\n\t\t\treturn false;\n\t\t} else if (matches(AssertTrue.class, cName) && !truthy().isValid(actual)) {\n\t\t\terr.add(Utils.formatMessage(\"{0} must be true.\", field));\n\t\t\treturn false;\n\t\t} else if (matches(Future.class, cName) && !future().isValid(actual)) {\n\t\t\terr.add(Utils.formatMessage(\"{0} must be in the future.\", field));\n\t\t\treturn false;\n\t\t} else if (matches(Past.class, cName) && !past().isValid(actual)) {\n\t\t\terr.add(Utils.formatMessage(\"{0} must be in the past.\", field));\n\t\t\treturn false;\n\t\t} else if (matches(URL.class, cName) && !url().isValid(actual)) {\n\t\t\terr.add(Utils.formatMessage(\"{0} is not a valid URL.\", field));\n\t\t\treturn false;\n\t\t} else if (matches(Email.class, cName) && !email().isValid(actual)) {\n\t\t\terr.add(Utils.formatMessage(\"{0} is not a valid email.\", field));\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Returns all validation constraints that are defined by Java annotation in the core classes.\n\t *\n\t * @return a map of all core types to all core annotated constraints. See JSR-303.\n\t */\n\tpublic static Map<String, Map<String, Map<String, Map<String, ?>>>> getCoreValidationConstraints() {\n\t\tif (CORE_CONSTRAINTS.isEmpty()) {\n\t\t\tfor (Map.Entry<String, Class<? extends ParaObject>> e : ParaObjectUtils.getCoreClassesMap().entrySet()) {\n\t\t\t\tString type = e.getKey();\n\t\t\t\tList<Field> fieldlist = Utils.getAllDeclaredFields(e.getValue());\n\t\t\t\tfor (Field field : fieldlist) {\n\t\t\t\t\tAnnotation[] annos = field.getAnnotations();\n\t\t\t\t\tif (annos.length > 1) {\n\t\t\t\t\t\tMap<String, Map<String, ?>> constrMap = new HashMap<>();\n\t\t\t\t\t\tfor (Annotation anno : annos) {\n\t\t\t\t\t\t\tif (isValidConstraintType(anno.annotationType())) {\n\t\t\t\t\t\t\t\tConstraint c = fromAnnotation(anno);\n\t\t\t\t\t\t\t\tif (c != null) {\n\t\t\t\t\t\t\t\t\tconstrMap.put(c.getName(), c.getPayload());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!constrMap.isEmpty()) {\n\t\t\t\t\t\t\tif (!CORE_CONSTRAINTS.containsKey(type)) {\n\t\t\t\t\t\t\t\tCORE_CONSTRAINTS.put(type, new HashMap<>());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tCORE_CONSTRAINTS.get(type).put(field.getName(), constrMap);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tCORE_CONSTRAINTS.get(Utils.type(User.class)).put(\"password\",\n\t\t\t\t\tCollections.singletonMap(\"max\", Constraint.max(User.MAX_PASSWORD_LENGTH).getPayload()));\n\t\t}\n\t\treturn Collections.unmodifiableMap(CORE_CONSTRAINTS);\n\t}\n}\n", "/*\n * Copyright 2013-2022 Erudika. https://erudika.com\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * For issues and patches go to: https://github.com/erudika\n */\npackage com.erudika.para.core.utils;\n\nimport com.erudika.para.core.utils.Config;\nimport com.erudika.para.core.App;\nimport com.erudika.para.core.Sysprop;\nimport com.erudika.para.core.Tag;\nimport com.erudika.para.core.User;\nimport static com.erudika.para.core.validation.ValidationUtils.*;\nimport static com.erudika.para.core.validation.Constraint.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport static org.junit.Assert.*;\nimport org.junit.Test;\n\n/**\n *\n * @author Alex Bogdanovski [alex@erudika.com]\n */\npublic class ValidationUtilsTest {\n\n\n\t@Test\n\tpublic void testGetValidator() {\n\t\tassertNotNull(getValidator());\n\t}\n\n\t@Test\n\tpublic void testIsValidObject() {\n\t\tassertFalse(isValidObject(null));\n\t\tassertFalse(isValidObject(new Tag()));\n\t\tassertTrue(isValidObject(new Tag(\"tag1\")));\n\t\tTag t = new Tag(\"\");\n\t\tt.setName(\"\");\n\t\tassertFalse(isValidObject(t));\n\t\tassertFalse(isValidObject(new User()));\n\n\t\tUser u = new User();\n\t\tu.setId(\"123\");\n\t\tu.setName(\"asd\");\n\t\tassertFalse(isValidObject(u));\n\t}\n\n\t@Test\n\tpublic void testValidateObject() {\n\t\tassertTrue(validateObject(null).length > 0);\n\t\tassertEquals(0, validateObject(new Tag(\"test\")).length);\n\n\t\tApp app = new App(Config.PARA);\n\t\tassertTrue(validateObject(app).length == 0);\n\t\tapp.resetSecret();\n\t\tassertTrue(validateObject(app).length == 0);\n\n\t\tSysprop s1 = new Sysprop(\"s1\");\n\t\tassertTrue(validateObject(s1).length == 0);\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\n\t\ts1.setType(\"cat\");\n\t\tassertTrue(validateObject(s1).length == 0);\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\n\t\tassertTrue(app.getValidationConstraints().isEmpty());\n\t\tapp.addValidationConstraint(null, null, null);\n\t\tassertTrue(app.getValidationConstraints().isEmpty());\n\n\t\t// required\n\t\tapp.addValidationConstraint(s1.getType(), \"paws\", required());\n\t\tassertFalse(app.getValidationConstraints().get(s1.getType()).isEmpty());\n\t\tassertFalse(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"paws\", 2);\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\n\t\t// min\n\t\tapp.addValidationConstraint(s1.getType(), \"paws\", min(4L));\n\t\tassertFalse(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"paws\", 4);\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\n\t\t// max\n\t\tapp.addValidationConstraint(s1.getType(), \"paws\", max(5L));\n\t\ts1.addProperty(\"paws\", 6);\n\t\tassertFalse(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"paws\", 5);\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\n\t\t// size\n\t\tapp.addValidationConstraint(s1.getType(), \"name\", size(2, 3));\n\t\tassertFalse(validateObject(app, s1).length == 0);\n\t\ts1.setName(\"Bob\");\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\t\ts1.setName(\"Bobsy\");\n\t\tassertFalse(validateObject(app, s1).length == 0);\n\t\ts1.setName(\"Bob\");\n\t\t// null values are allowed and treated as valid\n\t\tapp.addValidationConstraint(s1.getType(), \"fur\", size(2, 3));\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\t\t// ints are a wrong type - not valid\n\t\ts1.addProperty(\"fur\", 3);\n\t\tassertFalse(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"fur\", \"yes\");\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"fur\", new ArrayList <String>(0));\n\t\tassertFalse(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"fur\", Arrays.asList(new String[]{\"one\", \"two\", \"three\"}));\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"fur\", new HashMap<String, String>(0));\n\t\tassertFalse(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"fur\", new HashMap<String, String>() {{\n\t\t\tput(\"1\", \"1\");\n\t\t\tput(\"2\", \"2\");\n\t\t\tput(\"3\", \"3\");\n\t\t}});\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"fur\", new String[0]);\n\t\tassertFalse(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"fur\", new String[]{\"one\", \"two\", \"three\"});\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\n\t\t// email\n\t\tapp.addValidationConstraint(s1.getType(), \"eemail\", email());\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"eemail\", 2);\n\t\tassertFalse(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"eemail\", \"a@..\");\n\t\tassertFalse(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"eemail\", \"a@bob.com\");\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\n\t\t// digits\n\t\tapp.addValidationConstraint(s1.getType(), \"specialnum\", digits(4, 2));\n\t\ts1.addProperty(\"specialnum\", \"??\");\n\t\tassertFalse(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"specialnum\", 12.34);\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"specialnum\", 1234.567);\n\t\tassertFalse(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"specialnum\", 12345.67);\n\t\tassertFalse(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"specialnum\", \"1234.5\");\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\n\t\t// pattern\n\t\tapp.addValidationConstraint(s1.getType(), \"regex\", pattern(\"^test\\\\sok=$\"));\n\t\ts1.addProperty(\"regex\", \"??\");\n\t\tassertFalse(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"regex\", \"test ok=\");\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\n\t\t// false\n\t\tapp.addValidationConstraint(s1.getType(), \"fals\", falsy());\n\t\ts1.addProperty(\"fals\", \"test\");\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"fals\", \"false\");\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"fals\", \"NO\");\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"fals\", \"0\");\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"fals\", 0);\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"fals\", false);\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"fals\", \"true\");\n\t\tassertFalse(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"fals\", true);\n\t\tassertFalse(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"fals\", false);\n\n\t\t// true\n\t\tapp.addValidationConstraint(s1.getType(), \"tru\", truthy());\n\t\ts1.addProperty(\"tru\", \"test\");\n\t\tassertFalse(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"tru\", \"false\");\n\t\tassertFalse(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"tru\", true);\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"tru\", \"true\");\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\n\t\t// future\n\t\tapp.addValidationConstraint(s1.getType(), \"future\", future());\n\t\ts1.addProperty(\"future\", 1234);\n\t\tassertFalse(validateObject(app, s1).length == 0);\n//\t\ts1.addProperty(\"future\", System.currentTimeMillis());\n//\t\tassertFalse(validateObject(app, s1).length == 0);\t// might fail on some machines\n\t\ts1.addProperty(\"future\", System.currentTimeMillis() + 10000);\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"future\", new Date(System.currentTimeMillis() + 10000));\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\n\t\t// past\n\t\tapp.addValidationConstraint(s1.getType(), \"past\", past());\n\t\ts1.addProperty(\"past\", System.currentTimeMillis() + 10000);\n\t\tassertFalse(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"past\", 1234);\n\t\tassertTrue(validateObject(app, s1).length == 0);\n//\t\ts1.addProperty(\"past\", System.currentTimeMillis());\n//\t\tassertFalse(validateObject(app, s1).length == 0);\t// might fail on some machines\n\t\ts1.addProperty(\"past\", new Date(System.currentTimeMillis()-1));\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\n\t\t// url\n\t\tapp.addValidationConstraint(s1.getType(), \"url\", url());\n\t\ts1.addProperty(\"url\", 1234);\n\t\tassertFalse(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"url\", \"http\");\n\t\tassertFalse(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"url\", \"http://www.a.com\");\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\t}\n\n\t@Test\n\tpublic void testGetCoreValidationConstraints() {\n\t\tassertTrue(getCoreValidationConstraints().containsKey(\"app\"));\n\t}\n\n\t@Test\n\tpublic void testAllConstraints() {\n\t\t// null is ok, because value might not be required\n\t\tassertTrue(email().isValid(null));\n\t\tassertTrue(email().isValid(\"abc@de.com\"));\n\t\tassertFalse(email().isValid(\"abc@de.\"));\n\t\tassertFalse(email().isValid(\"abc@.c\"));\n\t\tassertFalse(email().isValid(123));\n\t\tassertFalse(email().isValid(\" \"));\n\n\t\tassertTrue(falsy().isValid(null));\n\t\tassertTrue(falsy().isValid(\"false\"));\n\t\tassertTrue(falsy().isValid(\"FALSE\"));\n\t\tassertTrue(falsy().isValid(false));\n\t\tassertTrue(falsy().isValid(\"fals\"));\n\t\tassertTrue(falsy().isValid(\" \"));\n\t\tassertFalse(falsy().isValid(\"true\"));\n\t\tassertFalse(falsy().isValid(true));\n\n\t\tassertTrue(truthy().isValid(null));\n\t\tassertTrue(truthy().isValid(\"true\"));\n\t\tassertTrue(truthy().isValid(\"True\"));\n\t\tassertTrue(truthy().isValid(true));\n\t\tassertFalse(truthy().isValid(false));\n\t\tassertFalse(truthy().isValid(\"a\"));\n\t\tassertFalse(truthy().isValid(\" \"));\n\n\t\tassertFalse(required().isValid(null));\n\t\tassertFalse(required().isValid(\" \"));\n\t\tassertTrue(required().isValid(\"text\"));\n\t\tassertTrue(required().isValid(1));\n\t\tassertTrue(required().isValid(true));\n\n\t\tlong now = System.currentTimeMillis();\n\t\tassertTrue(future().isValid(null));\n\t\tassertTrue(future().isValid(new Date(now + 1000)));\n\t\tassertFalse(future().isValid(new Date(now - 1000)));\n\n\t\tassertTrue(past().isValid(null));\n\t\tassertTrue(past().isValid(new Date(now - 1000)));\n\t\tassertFalse(past().isValid(new Date(now + 1000)));\n\n\t\tassertTrue(url().isValid(null));\n\t\tassertTrue(url().isValid(\"http://abc.co\"));\n\t\tassertFalse(url().isValid(\"htp://abc.co\"));\n\t\tassertFalse(url().isValid(\"abc.com\"));\n\t\tassertFalse(url().isValid(\" \"));\n\t\tassertFalse(url().isValid(false));\n\n\t\tassertTrue(min(3).isValid(null));\n\t\tassertTrue(min(3).isValid(3));\n\t\tassertTrue(min(3).isValid(4));\n\t\tassertFalse(min(4).isValid(3));\n\t\tassertFalse(min(2).isValid(\"3\"));\n\t\tassertFalse(min(4).isValid(true));\n\t\tassertFalse(min(null).isValid(\" \"));\n\t\tassertFalse(min(null).isValid(3));\n\n\t\tassertTrue(max(3).isValid(null));\n\t\tassertTrue(max(3).isValid(3));\n\t\tassertTrue(max(4).isValid(3));\n\t\tassertFalse(max(3).isValid(4));\n\t\tassertFalse(max(2).isValid(\"3\"));\n\t\tassertFalse(max(4).isValid(true));\n\t\tassertFalse(max(null).isValid(\" \"));\n\t\tassertFalse(max(null).isValid(3));\n\n\t\tassertTrue(size(2, 3).isValid(null));\n\t\tassertTrue(size(2, 3).isValid(\"xx\"));\n\t\tassertFalse(size(3, 2).isValid(\"xx\"));\n\t\tassertFalse(size(2, 3).isValid(\"xxxx\"));\n\t\tassertFalse(size(2, 3).isValid(\"x\"));\n\t\tassertTrue(size(0, 0).isValid(\"\"));\n\t\tassertTrue(size(0, 0).isValid(new String[0]));\n\t\tassertTrue(size(1, 2).isValid(new String[]{\"a\", \"b\"}));\n\t\tassertTrue(size(1, 2).isValid(Arrays.asList(new String[]{\"a\", \"b\"})));\n\t\tassertTrue(size(1, 2).isValid(Collections.singletonMap(\"a\", \"b\")));\n\n\t\tassertTrue(digits(2, 2).isValid(null));\n\t\tassertTrue(digits(2, 2).isValid(\"22.22\"));\n\t\tassertFalse(digits(2, 2).isValid(\"22.222\"));\n\t\tassertFalse(digits(1, 2).isValid(\"2.222\"));\n\t\tassertTrue(digits(1, 2).isValid(\"2.22\"));\n\t\tassertTrue(digits(1, 2).isValid(2.22));\n\t\tassertTrue(digits(1, 2).isValid(0));\n\t\tassertFalse(digits(1, 2).isValid(12));\n\t\tassertFalse(digits(0, 2).isValid(1));\n\n\t\tassertTrue(pattern(null).isValid(null));\n\t\tassertTrue(pattern(\"\").isValid(\"\"));\n\t\tassertTrue(pattern(\"[ab]+\").isValid(\"bababa\"));\n\t\tassertTrue(pattern(\"\\\\.[ab]+\").isValid(\".babababa\"));\n\t\tassertFalse(pattern(\"\").isValid(\" \"));\n\t}\n}\n"], "fixing_code": ["/*\n * Copyright 2013-2022 Erudika. https://erudika.com\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * For issues and patches go to: https://github.com/erudika\n */\npackage com.erudika.para.core;\n\nimport com.erudika.para.core.annotations.Email;\nimport com.erudika.para.core.annotations.Locked;\nimport com.erudika.para.core.annotations.Stored;\nimport com.erudika.para.core.i18n.CurrencyUtils;\nimport com.erudika.para.core.utils.Config;\nimport com.erudika.para.core.utils.CoreUtils;\nimport com.erudika.para.core.utils.Pager;\nimport com.erudika.para.core.utils.Para;\nimport com.erudika.para.core.utils.ParaObjectUtils;\nimport com.erudika.para.core.utils.Utils;\nimport com.fasterxml.jackson.annotation.JsonIgnore;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Objects;\nimport javax.validation.constraints.NotBlank;\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * The core user object. Stores information about users.\n * @author Alex Bogdanovski [alex@erudika.com]\n */\npublic class User implements ParaObject {\n\tprivate static final long serialVersionUID = 1L;\n\tprivate static Logger logger = LoggerFactory.getLogger(User.class);\n\n\t/**\n\t * Maximum password length.\n\t */\n\tpublic static final int MAX_PASSWORD_LENGTH = 5000;\n\n\t@Stored @Locked private String id;\n\t@Stored @Locked private Long timestamp;\n\t@Stored @Locked private String type;\n\t@Stored @Locked private String appid;\n\t@Stored @Locked private String parentid;\n\t@Stored @Locked private String creatorid;\n\t@Stored private Long updated;\n\t@Stored private String name;\n\t@Stored private List<String> tags;\n\t@Stored private Integer votes;\n\t@Stored private Long version;\n\t@Stored private Boolean stored;\n\t@Stored private Boolean indexed;\n\t@Stored private Boolean cached;\n\n\t@Stored @NotBlank private String identifier;\n\t@Stored @Locked @NotBlank private String groups;\n\t@Stored private Boolean active;\n\t@Stored private Boolean twoFA;\n\t@Stored private String twoFAkey;\n\t@Stored private String twoFAbackupKeyHash;\n\t@Stored @NotBlank @Email private String email;\n\t@Stored private String currency;\n\t@Stored private String picture;\n\t@Stored @Locked private String tokenSecret;\n\t@Stored private String idpIdToken;\n\t@Stored private String idpAccessToken;\n\t@Stored private String idpRefreshToken;\n\n\tprivate transient String password;\n\n\t/**\n\t * No-args constructor.\n\t */\n\tpublic User() {\n\t\tthis(null);\n\t}\n\n\t/**\n\t * Default constructor.\n\t * @param id the id\n\t */\n\tpublic User(String id) {\n\t\tsetId(id);\n\t\tsetName(getName());\n\t\tthis.groups = Groups.USERS.toString();\n\t}\n\n\t/**\n\t * Token secret - used for generating JWT tokens.\n\t * Changing this secret would invalidate all existing user tokens.\n\t * A kind of global \"logout\".\n\t * @return a random string\n\t */\n\t@JsonIgnore\n\tpublic String getTokenSecret() {\n\t\tif (tokenSecret == null) {\n\t\t\tresetTokenSecret();\n\t\t}\n\t\treturn tokenSecret;\n\t}\n\n\t/**\n\t * Sets the token secret.\n\t * @param tokenSecret a random string\n\t */\n\tpublic void setTokenSecret(String tokenSecret) {\n\t\tthis.tokenSecret = tokenSecret;\n\t}\n\n\t/**\n\t * The profile picture URL.\n\t * @return a URL or null\n\t */\n\tpublic String getPicture() {\n\t\treturn StringUtils.isBlank(picture) ?\n\t\t\t\t\"https://www.gravatar.com/avatar?d=mm&size=400\" : picture;\n\t}\n\n\t/**\n\t * Sets the profile picture URL.\n\t * @param picture the picture URL.\n\t */\n\tpublic void setPicture(String picture) {\n\t\tthis.picture = picture;\n\t}\n\n\t/**\n\t * Returns true if this account is active.\n\t * @return true if active\n\t */\n\tpublic Boolean getActive() {\n\t\tif (active == null) {\n\t\t\tactive = false;\n\t\t}\n\t\treturn active;\n\t}\n\n\t/**\n\t * Sets the account active.\n\t * @param active true if active\n\t */\n\tpublic void setActive(Boolean active) {\n\t\tthis.active = active;\n\t}\n\n\t/**\n\t * @return true if 2FA is enabled\n\t */\n\tpublic Boolean getTwoFA() {\n\t\tif (twoFA == null) {\n\t\t\ttwoFA = false;\n\t\t}\n\t\treturn twoFA;\n\t}\n\n\t/**\n\t * Sets 2FA enabled/disabled.\n\t * @param twoFA true if 2FA is enabled\n\t */\n\tpublic void setTwoFA(Boolean twoFA) {\n\t\tthis.twoFA = twoFA;\n\t}\n\n\t/**\n\t * @return the 2FA secret key. Used for checking the TOTP code.\n\t */\n\t@JsonIgnore\n\tpublic String getTwoFAkey() {\n\t\treturn twoFAkey;\n\t}\n\n\t/**\n\t * Sets the 2FA secret key.\n\t * @param twoFAkey secret key\n\t */\n\tpublic void setTwoFAkey(String twoFAkey) {\n\t\tthis.twoFAkey = twoFAkey;\n\t}\n\n\t/**\n\t * @return the hashed backup key (shown only once). Used for disabling 2FA.\n\t */\n\t@JsonIgnore\n\tpublic String getTwoFAbackupKeyHash() {\n\t\treturn twoFAbackupKeyHash;\n\t}\n\n\t/**\n\t * Sets the 2FA backup key hash.\n\t * @param twoFAbackupKeyHash bcrypt hash\n\t */\n\tpublic void setTwoFAbackupKeyHash(String twoFAbackupKeyHash) {\n\t\tthis.twoFAbackupKeyHash = twoFAbackupKeyHash;\n\t}\n\n\t/**\n\t * Returns the security groups for this user.\n\t * @return the groups string\n\t */\n\tpublic String getGroups() {\n\t\treturn groups;\n\t}\n\n\t/**\n\t * Sets the security groups for this user.\n\t * @param groups the groups string\n\t */\n\tpublic void setGroups(String groups) {\n\t\tthis.groups = groups;\n\t}\n\n\t/**\n\t * Returns the main identifier for this user.\n\t * An identifier is basically a unique username that identifies a user.\n\t * @return the main identifier\n\t */\n\tpublic String getIdentifier() {\n\t\treturn identifier;\n\t}\n\n\t/**\n\t * Sets the main identifier.\n\t * @param identifier the main identifier\n\t */\n\tpublic void setIdentifier(String identifier) {\n\t\tthis.identifier = identifier;\n\t}\n\n\t/**\n\t * The user's email.\n\t * @return email\n\t */\n\tpublic String getEmail() {\n\t\treturn StringUtils.lowerCase(email);\n\t}\n\n\t/**\n\t * Sets the email.\n\t * @param email email\n\t */\n\tpublic void setEmail(String email) {\n\t\tthis.email = email;\n\t}\n\n\t/**\n\t * The user's currency preference.\n\t * @return a currency 3-letter code in uppercase\n\t */\n\tpublic String getCurrency() {\n\t\treturn currency;\n\t}\n\n\t/**\n\t * Sets a preferred currency. Default is \"EUR\".\n\t * @param currency a 3-letter currency code\n\t */\n\tpublic void setCurrency(String currency) {\n\t\tcurrency = StringUtils.upperCase(currency);\n\t\tif (!CurrencyUtils.getInstance().isValidCurrency(currency)) {\n\t\t\tcurrency = \"EUR\";\n\t\t}\n\t\tthis.currency = currency;\n\t}\n\n\t/**\n\t * Generates a new token secret.\n\t * This is whould be equivalent to \"logout everywhere\".\n\t */\n\tpublic void resetTokenSecret() {\n\t\ttokenSecret = Utils.generateSecurityToken();\n\t}\n\n\t/**\n\t * Note: this method assumes that child objects can be modified by their parents.\n\t * This might not work for special cases where a parent has no rights over a child.\n\t * @param obj an object\n\t * @return true if the user is the creator or parent of this object or an admin user\n\t */\n\tpublic boolean canModify(ParaObject obj) {\n\t\tif (obj == null || id == null) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\tboolean isCreatedByMe = obj.getCreatorid() != null &&\n\t\t\t\t\t(obj.getCreatorid().startsWith(id + Para.getConfig().separator()) || id.equals(obj.getCreatorid()));\n\t\t\tboolean mine = isCreatedByMe || id.equals(obj.getId()) || id.equals(obj.getParentid());\n\t\t\treturn (mine || isAdmin());\n\t\t}\n\t}\n\n\t@Override\n\tpublic String create() {\n\t\tif (StringUtils.isBlank(getIdentifier())) {\n\t\t\tlogger.warn(\"Failed to create user - identifier not set.\");\n\t\t\treturn null;\n\t\t}\n\t\tif (!StringUtils.isBlank(getPassword()) && getPassword().length() < Para.getConfig().minPasswordLength()) {\n\t\t\tlogger.warn(\"Failed to create user - password too short.\");\n\t\t\treturn null;\n\t\t}\n\t\tif (readUserForIdentifier(this) != null) {\n\t\t\tlogger.warn(\"Failed to create user - user with identifier '{}' already exists.\", getIdentifier());\n\t\t\treturn null;\n\t\t}\n\n\t\t// admin detected\n\t\tif (!Para.getConfig().adminIdentifier().isEmpty() && Para.getConfig().adminIdentifier().equals(getIdentifier())) {\n\t\t\tlogger.info(\"Creating new user '{}' ({}) with admin privileges.\", getName(), getIdentifier());\n\t\t\tsetGroups(User.Groups.ADMINS.toString());\n\t\t}\n\n\t\tif (StringUtils.isBlank(getGroups())) {\n\t\t\tsetGroups(User.Groups.USERS.toString());\n\t\t}\n\n\t\tsetGravatarPicture();\n\n\t\tif (StringUtils.isBlank(tokenSecret)) {\n\t\t\tresetTokenSecret();\n\t\t}\n\n\t\tif (CoreUtils.getInstance().getDao().create(getAppid(), this) != null) {\n\t\t\tcreateIdentifier(getIdentifier(), getPassword());\n\t\t} else {\n\t\t\tlogger.warn(\"Failed to create user - dao.create() returned null.\");\n\t\t}\n\n\t\treturn getId();\n\t}\n\n\t@Override\n\tpublic void delete() {\n\t\tif (getId() != null) {\n\t\t\tCoreUtils.getInstance().getDao().deleteAll(getAppid(), getIdentifiers());\n\t\t\tCoreUtils.getInstance().getDao().delete(getAppid(), this);\n\t\t}\n\t}\n\n\t/**\n\t * Returns a list of identifiers for this user (can have many).\n\t * @return a list of {@link Sysprop} objects\n\t */\n\tprivate List<Sysprop> getIdentifiers() {\n\t\treturn CoreUtils.getInstance().getSearch().findTerms(getAppid(), Utils.type(Sysprop.class),\n\t\t\t\tCollections.singletonMap(Config._CREATORID, getId()), true);\n\t}\n\n\t/**\n\t * Attaches a new identifier to this user.\n\t * @param identifier a new identifier\n\t */\n\tpublic void attachIdentifier(String identifier) {\n\t\tif (this.exists()) {\n\t\t\tcreateIdentifier(identifier, Utils.generateSecurityToken());\n\t\t}\n\t}\n\n\t/**\n\t * Detaches a secondary identifier which is not already used by this user.\n\t * @param identifier an attached identifier\n\t */\n\tpublic void detachIdentifier(String identifier) {\n\t\tif (!StringUtils.equals(identifier, getIdentifier())) {\n\t\t\tSysprop s = CoreUtils.getInstance().getDao().read(getAppid(), identifier);\n\t\t\tif (s != null && StringUtils.equals(getId(), s.getCreatorid())) {\n\t\t\t\tdeleteIdentifier(identifier);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Is the main identifier a Facebook id.\n\t * @return true if user is signed in with Facebook\n\t */\n\t@JsonIgnore\n\tpublic boolean isFacebookUser() {\n\t\treturn StringUtils.startsWithIgnoreCase(identifier, Config.FB_PREFIX);\n\t}\n\n\t/**\n\t * Is the main identifier a Google+ id.\n\t * @return true if user is signed in with Google+\n\t */\n\t@JsonIgnore\n\tpublic boolean isGooglePlusUser() {\n\t\treturn StringUtils.startsWithIgnoreCase(identifier, Config.GPLUS_PREFIX);\n\t}\n\n\t/**\n\t * Is the main identifier a LinkedIn id.\n\t * @return true if user is signed in with LinkedIn\n\t */\n\t@JsonIgnore\n\tpublic boolean isLinkedInUser() {\n\t\treturn StringUtils.startsWithIgnoreCase(identifier, Config.LINKEDIN_PREFIX);\n\t}\n\n\t/**\n\t * Is the main identifier a Twitter id.\n\t * @return true if user is signed in with Twitter\n\t */\n\t@JsonIgnore\n\tpublic boolean isTwitterUser() {\n\t\treturn StringUtils.startsWithIgnoreCase(identifier, Config.TWITTER_PREFIX);\n\t}\n\n\t/**\n\t * Is the main identifier a GitHub id.\n\t * @return true if user is signed in with GitHub\n\t */\n\t@JsonIgnore\n\tpublic boolean isGitHubUser() {\n\t\treturn StringUtils.startsWithIgnoreCase(identifier, Config.GITHUB_PREFIX);\n\t}\n\n\t/**\n\t * Is the main identifier a Microsoft/Windows account id.\n\t * @return true if user is signed in with a Microsoft account\n\t */\n\t@JsonIgnore\n\tpublic boolean isMicrosoftUser() {\n\t\treturn StringUtils.startsWithIgnoreCase(identifier, Config.MICROSOFT_PREFIX);\n\t}\n\n\t/**\n\t * Is the main identifier a Slack account id.\n\t * @return true if user is signed in with a Slack account\n\t */\n\t@JsonIgnore\n\tpublic boolean isSlackUser() {\n\t\treturn StringUtils.startsWithIgnoreCase(identifier, Config.SLACK_PREFIX);\n\t}\n\n\t/**\n\t * Is the main identifier a Mattermost account id.\n\t * @return true if user is signed in with a Mattermost account\n\t */\n\t@JsonIgnore\n\tpublic boolean isMattermostUser() {\n\t\treturn StringUtils.startsWithIgnoreCase(identifier, Config.MATTERMOST_PREFIX);\n\t}\n\n\t/**\n\t * Is the main identifier a Amazon account id.\n\t * @return true if user is signed in with a Amazon account\n\t */\n\t@JsonIgnore\n\tpublic boolean isAmazonUser() {\n\t\treturn StringUtils.startsWithIgnoreCase(identifier, Config.AMAZON_PREFIX);\n\t}\n\n\t/**\n\t * Is the main identifier a LDAP account.\n\t * @return true if user is signed in with a LDAP account\n\t */\n\t@JsonIgnore\n\tpublic boolean isLDAPUser() {\n\t\treturn StringUtils.startsWithIgnoreCase(identifier, Config.LDAP_PREFIX);\n\t}\n\n\t/**\n\t * Is the main identifier a SAML account.\n\t * @return true if user is signed in with a SAML account\n\t */\n\t@JsonIgnore\n\tpublic boolean isSAMLUser() {\n\t\treturn StringUtils.startsWithIgnoreCase(identifier, Config.SAML_PREFIX);\n\t}\n\n\t/**\n\t * Is the main identifier from a generic OAuth 2.0/OpenID Connect provider.\n\t * @return true if user is signed in with a generic OAauth 2.0 account\n\t */\n\t@JsonIgnore\n\tpublic boolean isOAuth2User() {\n\t\treturn StringUtils.startsWithIgnoreCase(identifier, Config.OAUTH2_PREFIX) ||\n\t\t\t\tStringUtils.startsWithIgnoreCase(identifier, Config.OAUTH2_SECOND_PREFIX) ||\n\t\t\t\tStringUtils.startsWithIgnoreCase(identifier, Config.OAUTH2_THIRD_PREFIX);\n\t}\n\n\t/**\n\t * Checks for admin rights.\n\t * @return true if user has admin rights\n\t */\n\t@JsonIgnore\n\tpublic boolean isAdmin() {\n\t\treturn StringUtils.equalsIgnoreCase(this.groups, Groups.ADMINS.toString());\n\t}\n\n\t/**\n\t * Checks for moderator rights.\n\t * @return true if user has mod rights\n\t */\n\t@JsonIgnore\n\tpublic boolean isModerator() {\n\t\treturn isAdmin() ? true : StringUtils.equalsIgnoreCase(this.groups, Groups.MODS.toString());\n\t}\n\n\t/**\n\t * Returns the name of the identity provider.\n\t * @return \"facebook\", \"google\"... etc.\n\t */\n\tpublic String getIdentityProvider() {\n\t\tif (isFacebookUser()) {\n\t\t\treturn \"facebook\";\n\t\t} else if (isGooglePlusUser()) {\n\t\t\treturn \"google\";\n\t\t} else if (isGitHubUser()) {\n\t\t\treturn \"github\";\n\t\t} else if (isTwitterUser()) {\n\t\t\treturn \"twitter\";\n\t\t} else if (isLinkedInUser()) {\n\t\t\treturn \"linkedin\";\n\t\t} else if (isMicrosoftUser()) {\n\t\t\treturn \"microsoft\";\n\t\t} else if (isSlackUser()) {\n\t\t\treturn \"slack\";\n\t\t} else if (isMattermostUser()) {\n\t\t\treturn \"mattermost\";\n\t\t} else if (isAmazonUser()) {\n\t\t\treturn \"amazon\";\n\t\t} else if (isLDAPUser()) {\n\t\t\treturn \"ldap\";\n\t\t} else if (isSAMLUser()) {\n\t\t\treturn \"saml\";\n\t\t} else if (isOAuth2User()) {\n\t\t\treturn \"oauth2\";\n\t\t} else {\n\t\t\treturn \"generic\";\n\t\t}\n\t}\n\n\t/**\n\t * The password. A transient field used for validation.\n\t * @return the password.\n\t */\n\t@JsonIgnore\n\tpublic String getPassword() {\n\t\treturn password;\n\t}\n\n\t/**\n\t * Sets a password.\n\t * @param password a password\n\t */\n\tpublic void setPassword(String password) {\n\t\tthis.password = password;\n\t}\n\n\t/**\n\t * Used for storing the ID token from an OpenID Connect/OAuth 2.0 identity provider.\n\t * @return an ID token (JWT is always assumed to be the format)\n\t */\n\tpublic String getIdpIdToken() {\n\t\treturn idpIdToken;\n\t}\n\n\t/**\n\t * Sets the IDP ID token.\n\t * @param idpIdToken a token\n\t */\n\tpublic void setIdpIdToken(String idpIdToken) {\n\t\tthis.idpIdToken = idpIdToken;\n\t}\n\n\t/**\n\t * Used for storing the access token from an OpenID Connect/OAuth 2.0 identity provider.\n\t * @return a JWT access token (JWT is always assumed to be the format)\n\t */\n\tpublic String getIdpAccessToken() {\n\t\treturn idpAccessToken;\n\t}\n\n\t/**\n\t * Sets the IDP access token.\n\t * @param idpAccessToken a token\n\t */\n\tpublic void setIdpAccessToken(String idpAccessToken) {\n\t\tthis.idpAccessToken = idpAccessToken;\n\t}\n\n\t/**\n\t * Stores the refresh token from the identity provider.\n\t * @return a JWT refresh token\n\t */\n\tpublic String getIdpRefreshToken() {\n\t\treturn idpRefreshToken;\n\t}\n\n\t/**\n\t * Sets the refresh token.\n\t * @param idpRefreshToken a refresh token\n\t */\n\tpublic void setIdpRefreshToken(String idpRefreshToken) {\n\t\tthis.idpRefreshToken = idpRefreshToken;\n\t}\n\n\t/**\n\t * Returns the JWT payload for the ID token coming from the IDP.\n\t * Used for delegating user attributes data to clients. This must be a Base64-encoded JSON string.\n\t * @return the payload part in Base64\n\t */\n\t@JsonIgnore\n\tpublic String getIdpIdTokenPayload() {\n\t\treturn StringUtils.substringBetween(idpIdToken, \".\");\n\t}\n\n\t/**\n\t * Returns the JWT payload for the access token coming from the IDP.\n\t * Used for delegating user attributes data to clients. This must be a Base64-encoded JSON string.\n\t * @return the payload part in Base64\n\t */\n\t@JsonIgnore\n\tpublic String getIdpAccessTokenPayload() {\n\t\treturn StringUtils.substringBetween(idpAccessToken, \".\");\n\t}\n\n\t/**\n\t * Returns a user object for a given identifier.\n\t * @param u a user having a valid identifier set.\n\t * @return a user or null if no user is found for this identifier\n\t */\n\tpublic static final User readUserForIdentifier(final User u) {\n\t\tif (u == null || StringUtils.isBlank(u.getIdentifier())) {\n\t\t\treturn null;\n\t\t}\n\t\tUser user = null;\n\t\tString password = null;\n\t\tString identifier = u.getIdentifier();\n\t\t// Try to read the identifier object first, then read the user object linked to it.\n\t\tSysprop s = CoreUtils.getInstance().getDao().read(u.getAppid(), identifier);\n\t\tif (s != null && s.getCreatorid() != null) {\n\t\t\tuser = CoreUtils.getInstance().getDao().read(u.getAppid(), s.getCreatorid());\n\t\t\tpassword = (String) s.getProperty(Config._PASSWORD);\n\t\t}\n\t\t// Try to find the user by email if already created, but with a different identifier.\n\t\t// This prevents users with identical emails to have separate accounts by signing in through\n\t\t// different identity providers.\n\t\tif (user == null && !StringUtils.isBlank(u.getEmail())) {\n\t\t\tHashMap<String, Object> terms = new HashMap<>(2);\n\t\t\tterms.put(Config._EMAIL, u.getEmail());\n\t\t\tterms.put(Config._APPID, u.getAppid());\n\t\t\tPager p = new Pager(1);\n\t\t\tList<User> users = CoreUtils.getInstance().getSearch().findTerms(u.getAppid(), u.getType(), terms, true, p);\n\t\t\tif (!users.isEmpty()) {\n\t\t\t\tuser = users.get(0);\n\t\t\t\t// keep this random! dangerous to set it to user.getPassword()\n\t\t\t\tpassword = Utils.generateSecurityToken();\n\t\t\t\tuser.createIdentifier(u.getIdentifier(), password);\n\t\t\t\tif (p.getCount() > 1) {\n\t\t\t\t\tlogger.warn(\"{} user objects exist with the same email {}\", p.getCount(), user.getEmail());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (user != null) {\n\t\t\tif (password != null) {\n\t\t\t\t// used for remember me token signature calculations\n\t\t\t\tuser.setPassword(password);\n\t\t\t}\n\t\t\tif (!identifier.equals(user.getIdentifier())) {\n\t\t\t\tlogger.info(\"Identifier changed for user '{}', from {} to {}.\",\n\t\t\t\t\t\tuser.getId(), user.getIdentifier(), identifier);\n\t\t\t\t// the main identifier was changed - update\n\t\t\t\tuser.setIdentifier(identifier);\n\t\t\t\tCoreUtils.getInstance().getDao().update(user.getAppid(), user);\n\t\t\t}\n\t\t\treturn user;\n\t\t}\n\t\tlogger.debug(\"User not found for identifier {}/{}, {}.\", u.getAppid(), identifier, u.getId());\n\t\treturn null;\n\t}\n\n\t/**\n\t * Checks if a user has entered the correct password.\n\t * Compares password hashes.\n\t * @param u a user with a set password\n\t * @return true if password matches the one in the data store\n\t */\n\tpublic static final boolean passwordMatches(User u) {\n\t\tif (u == null) {\n\t\t\treturn false;\n\t\t}\n\t\tString password = u.getPassword();\n\t\tString identifier = u.getIdentifier();\n\t\tif (StringUtils.isBlank(password) || StringUtils.isBlank(identifier)) {\n\t\t\treturn false;\n\t\t}\n\t\tParaObject s = CoreUtils.getInstance().getDao().read(u.getAppid(), identifier);\n\t\tif (s != null) {\n\t\t\tif (s instanceof Sysprop) {\n\t\t\t\tString storedHash = (String) ((Sysprop) s).getProperty(Config._PASSWORD);\n\t\t\t\treturn Utils.bcryptMatches(password, storedHash);\n\t\t\t} else {\n\t\t\t\tLoggerFactory.getLogger(User.class).\n\t\t\t\t\t\twarn(Utils.formatMessage(\"Failed to read auth object for user '{}' using identifier '{}'.\",\n\t\t\t\t\t\t\t\tu.getId(), identifier));\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Generates a new password reset token. Sent via email for pass reset.\n\t * @return the pass reset token\n\t */\n\tpublic final String generatePasswordResetToken() {\n\t\tif (StringUtils.isBlank(identifier)) {\n\t\t\treturn \"\";\n\t\t}\n\t\tSysprop s = CoreUtils.getInstance().getDao().read(getAppid(), identifier);\n\t\tif (s != null) {\n\t\t\tString token = Utils.generateSecurityToken(42, true);\n\t\t\ts.addProperty(Config._RESET_TOKEN, token);\n\t\t\tCoreUtils.getInstance().getDao().update(getAppid(), s);\n\t\t\treturn token;\n\t\t}\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Changes the user password permanently.\n\t * @param token the reset token. see {@link #generatePasswordResetToken()}\n\t * @param newpass the new password\n\t * @return true if successful\n\t */\n\tpublic final boolean resetPassword(String token, String newpass) {\n\t\tif (StringUtils.isBlank(newpass) || StringUtils.isBlank(token) || newpass.length() < Para.getConfig().minPasswordLength()) {\n\t\t\treturn false;\n\t\t}\n\t\tSysprop s = CoreUtils.getInstance().getDao().read(getAppid(), identifier);\n\t\tif (isValidToken(s, Config._RESET_TOKEN, token)) {\n\t\t\ts.removeProperty(Config._RESET_TOKEN);\n\t\t\tString hashed = Utils.bcrypt(newpass);\n\t\t\ts.addProperty(Config._PASSWORD, hashed);\n\t\t\tsetPassword(hashed);\n\t\t\tCoreUtils.getInstance().getDao().update(getAppid(), s);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Creates a new identifier object using {@link Sysprop}.\n\t * Used for identifying a user when signing in.\n\t * @param newIdent a new identifier\n\t * @param password a password for the user (optional)\n\t * @return true if successful\n\t */\n\tprivate boolean createIdentifier(String newIdent, String password) {\n\t\tif (StringUtils.isBlank(getId()) || StringUtils.isBlank(newIdent)) {\n\t\t\treturn false;\n\t\t}\n\t\tSysprop s = new Sysprop();\n\t\ts.setId(newIdent);\n\t\ts.setName(Config._IDENTIFIER);\n\t\ts.setCreatorid(getId());\n\t\tif (!StringUtils.isBlank(password)) {\n\t\t\tString hashed = Utils.bcrypt(password);\n\t\t\ts.addProperty(Config._PASSWORD, hashed);\n\t\t\tsetPassword(hashed);\n\t\t}\n\t\treturn CoreUtils.getInstance().getDao().create(getAppid(), s) != null;\n\t}\n\n\t/**\n\t * Deletes the identifier and the user can no longer sign in with it.\n\t * @param ident the attached identifier\n\t */\n\tprivate void deleteIdentifier(String ident) {\n\t\tif (!StringUtils.isBlank(ident)) {\n\t\t\tCoreUtils.getInstance().getDao().delete(getAppid(), new Sysprop(ident));\n\t\t}\n\t}\n\n\t/**\n\t * Generates a new email confirmation token. Sent via email for user activation.\n\t * @return a Base64 encoded UUID\n\t */\n\tpublic String generateEmailConfirmationToken() {\n\t\tif (StringUtils.isBlank(identifier)) {\n\t\t\treturn \"\";\n\t\t}\n\t\tSysprop s = CoreUtils.getInstance().getDao().read(getAppid(), identifier);\n\t\tif (s != null) {\n\t\t\tString token = Utils.base64encURL(Utils.generateSecurityToken().getBytes());\n\t\t\ts.addProperty(Config._EMAIL_TOKEN, token);\n\t\t\tCoreUtils.getInstance().getDao().update(getAppid(), s);\n\t\t\treturn token;\n\t\t}\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Activates a user if a given token matches the one stored.\n\t * @param token the email confirmation token. see {@link #generateEmailConfirmationToken() }\n\t * @return true if successful\n\t */\n\tpublic final boolean activateWithEmailToken(String token) {\n\t\tSysprop s = CoreUtils.getInstance().getDao().read(getAppid(), identifier);\n\t\tif (isValidToken(s, Config._EMAIL_TOKEN, token)) {\n\t\t\ts.removeProperty(Config._EMAIL_TOKEN);\n\t\t\tCoreUtils.getInstance().getDao().update(getAppid(), s);\n\t\t\tsetActive(true);\n\t\t\tupdate();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Validates a token sent via email for password reset.\n\t * @param token a token\n\t * @return true if valid\n\t */\n\tpublic final boolean isValidPasswordResetToken(String token) {\n\t\tSysprop s = CoreUtils.getInstance().getDao().read(getAppid(), identifier);\n\t\treturn isValidToken(s, Config._RESET_TOKEN, token);\n\t}\n\n\t/**\n\t * Validates a token sent for email confirmation.\n\t * @param token a token\n\t * @return true if valid\n\t */\n\tpublic final boolean isValidEmailConfirmationToken(String token) {\n\t\tSysprop s = CoreUtils.getInstance().getDao().read(getAppid(), identifier);\n\t\treturn isValidToken(s, Config._EMAIL_TOKEN, token);\n\t}\n\n\tprivate boolean isValidToken(Sysprop s, String key, String token) {\n\t\tif (StringUtils.isBlank(token)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (s != null && s.hasProperty(key)) {\n\t\t\tString storedToken = (String) s.getProperty(key);\n\t\t\t// tokens expire afer a reasonably short period ~ 30 mins\n\t\t\tlong timeout = (long) Para.getConfig().passwordResetTimeoutSec() * 1000L;\n\t\t\tif (StringUtils.equals(storedToken, token) && (s.getUpdated() + timeout) > Utils.timestamp()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Sets the profile picture using the Gravatar service.\n\t */\n\tprivate void setGravatarPicture() {\n\t\tif (StringUtils.isBlank(picture)) {\n\t\t\tif (email != null) {\n\t\t\t\tString emailHash = Utils.md5(email.toLowerCase());\n\t\t\t\tsetPicture(\"https://www.gravatar.com/avatar/\" + emailHash + \"?size=400&d=mm&r=pg\");\n\t\t\t} else {\n\t\t\t\tsetPicture(\"https://www.gravatar.com/avatar?d=mm&size=400\");\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Simple groups enum.\n\t */\n\tpublic enum Groups {\n\t\t/**\n\t\t * The standard user group.\n\t\t */\n\t\tUSERS,\n\t\t/**\n\t\t * Moderators group.\n\t\t */\n\t\tMODS,\n\t\t/**\n\t\t * Administrators group.\n\t\t */\n\t\tADMINS;\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn this.name().toLowerCase();\n\t\t}\n\t}\n\n\t/**\n\t * Simple user roles enum.\n\t */\n\tpublic enum Roles {\n\t\t/**\n\t\t * The standard role.\n\t\t */\n\t\tUSER,\n\t\t/**\n\t\t * The moderator role.\n\t\t */\n\t\tMOD,\n\t\t/**\n\t\t * The administrator role.\n\t\t */\n\t\tADMIN;\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"ROLE_\".concat(this.name());\n\t\t}\n\t}\n\n\t////////////////////////////////////////////////////////\n\n\t@Override\n\tpublic final String getId() {\n\t\treturn id;\n\t}\n\n\t@Override\n\tpublic final void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n\t@Override\n\tpublic final String getType() {\n\t\ttype = (type == null) ? Utils.type(this.getClass()) : type;\n\t\treturn type;\n\t}\n\n\t@Override\n\tpublic final void setType(String type) {\n\t\tthis.type = type;\n\t}\n\n\t@Override\n\tpublic String getAppid() {\n\t\tappid = (appid == null) ? Para.getConfig().getRootAppIdentifier() : appid;\n\t\treturn appid;\n\t}\n\n\t@Override\n\tpublic void setAppid(String appid) {\n\t\tthis.appid = appid;\n\t}\n\n\t@Override\n\tpublic String getObjectURI() {\n\t\treturn CoreUtils.getInstance().getObjectURI(this);\n\t}\n\n\t@Override\n\tpublic List<String> getTags() {\n\t\treturn tags;\n\t}\n\n\t@Override\n\tpublic void setTags(List<String> tags) {\n\t\tthis.tags = tags;\n\t}\n\n\t@Override\n\tpublic Boolean getStored() {\n\t\tif (stored == null) {\n\t\t\tstored = true;\n\t\t}\n\t\treturn stored;\n\t}\n\n\t@Override\n\tpublic void setStored(Boolean stored) {\n\t\tthis.stored = stored;\n\t}\n\n\t@Override\n\tpublic Boolean getIndexed() {\n\t\tif (indexed == null) {\n\t\t\tindexed = true;\n\t\t}\n\t\treturn indexed;\n\t}\n\n\t@Override\n\tpublic void setIndexed(Boolean indexed) {\n\t\tthis.indexed = indexed;\n\t}\n\n\t@Override\n\tpublic Boolean getCached() {\n\t\tif (cached == null) {\n\t\t\tcached = true;\n\t\t}\n\t\treturn cached;\n\t}\n\n\t@Override\n\tpublic void setCached(Boolean cached) {\n\t\tthis.cached = cached;\n\t}\n\n\t@Override\n\tpublic Long getTimestamp() {\n\t\treturn (timestamp != null && timestamp != 0) ? timestamp : null;\n\t}\n\n\t@Override\n\tpublic void setTimestamp(Long timestamp) {\n\t\tthis.timestamp = timestamp;\n\t}\n\n\t@Override\n\tpublic String getCreatorid() {\n\t\treturn creatorid;\n\t}\n\n\t@Override\n\tpublic void setCreatorid(String creatorid) {\n\t\tthis.creatorid = creatorid;\n\t}\n\n\t@Override\n\tpublic final String getName() {\n\t\treturn CoreUtils.getInstance().getName(name, id);\n\t}\n\n\t@Override\n\tpublic final void setName(String name) {\n\t\tthis.name = (name == null || !name.isEmpty()) ? name : this.name;\n\t}\n\n\t@Override\n\tpublic String getPlural() {\n\t\treturn Utils.singularToPlural(getType());\n\t}\n\n\t@Override\n\tpublic String getParentid() {\n\t\treturn parentid;\n\t}\n\n\t@Override\n\tpublic void setParentid(String parentid) {\n\t\tthis.parentid = parentid;\n\t}\n\n\t@Override\n\tpublic Long getUpdated() {\n\t\treturn (updated != null && updated != 0) ? updated : null;\n\t}\n\n\t@Override\n\tpublic void setUpdated(Long updated) {\n\t\tthis.updated = updated;\n\t}\n\n\t@Override\n\tpublic void update() {\n\t\tCoreUtils.getInstance().getDao().update(getAppid(), this);\n\t}\n\n\t@Override\n\tpublic boolean exists() {\n\t\treturn CoreUtils.getInstance().getDao().read(getAppid(), getId()) != null;\n\t}\n\n\t@Override\n\tpublic boolean voteUp(String userid) {\n\t\treturn CoreUtils.getInstance().vote(this, userid, VoteValue.UP);\n\t}\n\n\t@Override\n\tpublic boolean voteDown(String userid) {\n\t\treturn CoreUtils.getInstance().vote(this, userid, VoteValue.DOWN);\n\t}\n\n\t@Override\n\tpublic Integer getVotes() {\n\t\treturn (votes == null) ? 0 : votes;\n\t}\n\n\t@Override\n\tpublic void setVotes(Integer votes) {\n\t\tthis.votes = votes;\n\t}\n\n\t@Override\n\tpublic Long getVersion() {\n\t\treturn (version == null) ? 0 : version;\n\t}\n\n\t@Override\n\tpublic void setVersion(Long version) {\n\t\tthis.version = version;\n\t}\n\n\t@Override\n\tpublic Long countLinks(String type2) {\n\t\treturn CoreUtils.getInstance().countLinks(this, type2);\n\t}\n\n\t@Override\n\tpublic List<Linker> getLinks(String type2, Pager... pager) {\n\t\treturn CoreUtils.getInstance().getLinks(this, type2, pager);\n\t}\n\n\t@Override\n\tpublic <P extends ParaObject> List<P> getLinkedObjects(String type, Pager... pager) {\n\t\treturn CoreUtils.getInstance().getLinkedObjects(this, type, pager);\n\t}\n\n\t@Override\n\tpublic <P extends ParaObject> List<P> findLinkedObjects(String type, String field, String query, Pager... pager) {\n\t\treturn CoreUtils.getInstance().findLinkedObjects(this, type, field, query, pager);\n\t}\n\n\t@Override\n\tpublic boolean isLinked(String type2, String id2) {\n\t\treturn CoreUtils.getInstance().isLinked(this, type2, id2);\n\t}\n\n\t@Override\n\tpublic boolean isLinked(ParaObject toObj) {\n\t\treturn CoreUtils.getInstance().isLinked(this, toObj);\n\t}\n\n\t@Override\n\tpublic String link(String id2) {\n\t\treturn CoreUtils.getInstance().link(this, id2);\n\t}\n\n\t@Override\n\tpublic void unlink(String type, String id2) {\n\t\tCoreUtils.getInstance().unlink(this, type, id2);\n\t}\n\n\t@Override\n\tpublic void unlinkAll() {\n\t\tCoreUtils.getInstance().unlinkAll(this);\n\t}\n\n\t@Override\n\tpublic Long countChildren(String type) {\n\t\treturn CoreUtils.getInstance().countChildren(this, type);\n\t}\n\n\t@Override\n\tpublic <P extends ParaObject> List<P> getChildren(String type, Pager... pager) {\n\t\treturn CoreUtils.getInstance().getChildren(this, type, pager);\n\t}\n\n\t@Override\n\tpublic <P extends ParaObject> List<P> getChildren(String type, String field, String term, Pager... pager) {\n\t\treturn CoreUtils.getInstance().getChildren(this, type, field, term, pager);\n\t}\n\n\t@Override\n\tpublic <P extends ParaObject> List<P> findChildren(String type, String query, Pager... pager) {\n\t\treturn CoreUtils.getInstance().findChildren(this, type, query, pager);\n\t}\n\n\t@Override\n\tpublic void deleteChildren(String type) {\n\t\tCoreUtils.getInstance().deleteChildren(this, type);\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tint hash = 7;\n\t\thash = 67 * hash + Objects.hashCode(this.id) + Objects.hashCode(this.name);\n\t\treturn hash;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (obj == null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (getClass() != obj.getClass()) {\n\t\t\treturn false;\n\t\t}\n\t\tfinal ParaObject other = (ParaObject) obj;\n\t\tif (!Objects.equals(this.id, other.getId())) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn ParaObjectUtils.toJSON(this);\n\t}\n}\n", "/*\n * Copyright 2013-2022 Erudika. https://erudika.com\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * For issues and patches go to: https://github.com/erudika\n */\npackage com.erudika.para.core.validation;\n\nimport com.erudika.para.core.App;\nimport com.erudika.para.core.ParaObject;\nimport com.erudika.para.core.Sysprop;\nimport com.erudika.para.core.User;\nimport com.erudika.para.core.annotations.Email;\nimport com.erudika.para.core.utils.Config;\nimport com.erudika.para.core.utils.ParaObjectUtils;\nimport com.erudika.para.core.utils.Utils;\nimport static com.erudika.para.core.validation.Constraint.digits;\nimport static com.erudika.para.core.validation.Constraint.email;\nimport static com.erudika.para.core.validation.Constraint.falsy;\nimport static com.erudika.para.core.validation.Constraint.fromAnnotation;\nimport static com.erudika.para.core.validation.Constraint.future;\nimport static com.erudika.para.core.validation.Constraint.isValidConstraintType;\nimport static com.erudika.para.core.validation.Constraint.matches;\nimport static com.erudika.para.core.validation.Constraint.max;\nimport static com.erudika.para.core.validation.Constraint.min;\nimport static com.erudika.para.core.validation.Constraint.past;\nimport static com.erudika.para.core.validation.Constraint.pattern;\nimport static com.erudika.para.core.validation.Constraint.required;\nimport static com.erudika.para.core.validation.Constraint.size;\nimport static com.erudika.para.core.validation.Constraint.truthy;\nimport static com.erudika.para.core.validation.Constraint.url;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Field;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport javax.validation.ConstraintViolation;\nimport javax.validation.Validation;\nimport javax.validation.Validator;\nimport javax.validation.constraints.AssertFalse;\nimport javax.validation.constraints.AssertTrue;\nimport javax.validation.constraints.Digits;\nimport javax.validation.constraints.Future;\nimport javax.validation.constraints.Max;\nimport javax.validation.constraints.Min;\nimport javax.validation.constraints.Past;\nimport javax.validation.constraints.Pattern;\nimport javax.validation.constraints.Size;\nimport org.apache.commons.beanutils.PropertyUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.math.NumberUtils;\nimport org.hibernate.validator.constraints.URL;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Helper methods for validating objects and generating JSON schemas.\n *\n * @author Alex Bogdanovski [alex@erudika.com]\n */\npublic final class ValidationUtils {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(ValidationUtils.class);\n\tprivate static final Map<String, Map<String, Map<String, Map<String, ?>>>> CORE_CONSTRAINTS =\n\t\t\tnew HashMap<String, Map<String, Map<String, Map<String, ?>>>>();\n\tprivate static Validator validator;\n\n\tprivate ValidationUtils() {\n\t}\n\n\t/**\n\t * A Hibernate Validator.\n\t * @return a validator object\n\t */\n\tpublic static Validator getValidator() {\n\t\tif (validator == null) {\n\t\t\tvalidator = Validation.buildDefaultValidatorFactory().getValidator();\n\t\t}\n\t\treturn validator;\n\t}\n\n\t/**\n\t * Validates objects using Hibernate Validator. Used for basic validation.\n\t * @param obj an object to be validated\n\t * @return true if the object is valid (all fields are populated properly)\n\t */\n\tpublic static boolean isValidObject(ParaObject obj) {\n\t\treturn validateObject(obj).length == 0;\n\t}\n\n\t/**\n\t * Validates objects using Hibernate Validator. Used for full object validation.\n\t * @param app the current app\n\t * @param obj an object to be validated\n\t * @return true if the object is valid (all fields are populated properly)\n\t */\n\tpublic static boolean isValidObject(App app, ParaObject obj) {\n\t\treturn validateObject(app, obj).length == 0;\n\t}\n\n\t/**\n\t * Validates objects using Hibernate Validator.\n\t * @param content an object to be validated\n\t * @return a list of error messages or empty if object is valid\n\t */\n\tpublic static String[] validateObject(ParaObject content) {\n\t\tif (content == null) {\n\t\t\treturn new String[]{\"Object cannot be null.\"};\n\t\t}\n\t\tLinkedList<String> list = new LinkedList<>();\n\t\ttry {\n\t\t\tfor (ConstraintViolation<ParaObject> constraintViolation : getValidator().validate(content)) {\n\t\t\t\tString prop = \"'\".concat(constraintViolation.getPropertyPath().toString()).concat(\"'\");\n\t\t\t\tlist.add(prop.concat(\" \").concat(constraintViolation.getMessage()));\n\t\t\t}\n\t\t\tif (content instanceof User && StringUtils.length(((User) content).getPassword()) > User.MAX_PASSWORD_LENGTH) {\n\t\t\t\tlist.add(Utils.formatMessage(\"{0} must not be longer than {1}.\", Config._PASSWORD, User.MAX_PASSWORD_LENGTH));\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tlogger.error(null, e);\n\t\t}\n\t\treturn list.toArray(new String[]{});\n\t}\n\n\t/**\n\t * Validates objects.\n\t * @param content an object to be validated\n\t * @param app the current app\n\t * @return a list of error messages or empty if object is valid\n\t */\n\tpublic static String[] validateObject(App app, ParaObject content) {\n\t\tif (content == null || app == null) {\n\t\t\treturn new String[]{\"Object cannot be null.\"};\n\t\t}\n\t\ttry {\n\t\t\tString type = content.getType();\n\t\t\tboolean isCustomType = (content instanceof Sysprop) && !type.equals(Utils.type(Sysprop.class));\n\t\t\t// Validate custom types and user-defined properties\n\t\t\tif (!app.getValidationConstraints().isEmpty() && isCustomType) {\n\t\t\t\tMap<String, Map<String, Map<String, ?>>> fieldsMap = app.getValidationConstraints().get(type);\n\t\t\t\tif (fieldsMap != null && !fieldsMap.isEmpty()) {\n\t\t\t\t\tLinkedList<String> errors = new LinkedList<>();\n\t\t\t\t\tfor (Map.Entry<String, Map<String, Map<String, ?>>> e : fieldsMap.entrySet()) {\n\t\t\t\t\t\tString field = e.getKey();\n\t\t\t\t\t\tObject actualValue = ((Sysprop) content).getProperty(field);\n\t\t\t\t\t\t// overriding core property validation rules is allowed\n\t\t\t\t\t\tif (actualValue == null && PropertyUtils.isReadable(content, field)) {\n\t\t\t\t\t\t\tactualValue = PropertyUtils.getProperty(content, field);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tMap<String, Map<String, ?>> consMap = e.getValue();\n\t\t\t\t\t\tfor (Map.Entry<String, Map<String, ?>> constraint : consMap.entrySet()) {\n\t\t\t\t\t\t\tbuildAndValidateConstraint(constraint, field, actualValue, errors);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!errors.isEmpty()) {\n\t\t\t\t\t\treturn errors.toArray(new String[0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception ex) {\n\t\t\tlogger.error(null, ex);\n\t\t}\n\t\treturn validateObject(content);\n\t}\n\n\tprivate static void buildAndValidateConstraint(Map.Entry<String, Map<String, ?>> constraint, String field,\n\t\t\tObject actualValue, LinkedList<String> errors) {\n\t\tif (constraint == null) {\n\t\t\treturn;\n\t\t}\n\t\tString consName = constraint.getKey();\n\t\tMap<String, ?> vals = constraint.getValue();\n\t\tif (vals == null) {\n\t\t\tvals = Collections.emptyMap();\n\t\t}\n\n\t\tObject val = vals.get(\"value\");\n\t\tlong min = NumberUtils.toLong(vals.get(\"min\") + \"\", 0);\n\t\tlong max = NumberUtils.toLong(vals.get(\"max\") + \"\", Config.DEFAULT_LIMIT);\n\n\t\tif (isValidSimpleConstraint(consName, field, actualValue, errors)) {\n\t\t\tif (matches(Min.class, consName) && !min(NumberUtils.toLong(val + \"\", 0)).isValid(actualValue)) {\n\t\t\t\terrors.add(Utils.formatMessage(\"{0} must be a number larger than {1}.\", field, val));\n\t\t\t} else if (matches(Max.class, consName) && !max(NumberUtils.toLong(val + \"\",\n\t\t\t\t\tConfig.DEFAULT_LIMIT)).isValid(actualValue)) {\n\t\t\t\terrors.add(Utils.formatMessage(\"{0} must be a number smaller than {1}.\", field, val));\n\t\t\t} else if (matches(Size.class, consName) && !size(min, max).isValid(actualValue)) {\n\t\t\t\terrors.add(Utils.formatMessage(\"{0} must be between {1} and {2}.\", field, min, max));\n\t\t\t} else if (matches(Digits.class, consName) && !digits(NumberUtils.toLong(vals.get(\"integer\") + \"\", 0),\n\t\t\t\t\tNumberUtils.toLong(vals.get(\"fraction\") + \"\", 0)).isValid(actualValue)) {\n\t\t\t\terrors.add(Utils.formatMessage(\"{0} is not a valid number or within range.\", field));\n\t\t\t} else if (matches(Pattern.class, consName) && !pattern(val).isValid(actualValue)) {\n\t\t\t\terrors.add(Utils.formatMessage(\"{0} doesn't match the pattern {1}.\", field, val));\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static boolean isValidSimpleConstraint(String cName, String field, Object actual, LinkedList<String> err) {\n\t\tif (\"required\".equals(cName) && !required().isValid(actual)) {\n\t\t\terr.add(Utils.formatMessage(\"{0} is required.\", field));\n\t\t\treturn false;\n\t\t} else if (matches(AssertFalse.class, cName) && !falsy().isValid(actual)) {\n\t\t\terr.add(Utils.formatMessage(\"{0} must be false.\", field));\n\t\t\treturn false;\n\t\t} else if (matches(AssertTrue.class, cName) && !truthy().isValid(actual)) {\n\t\t\terr.add(Utils.formatMessage(\"{0} must be true.\", field));\n\t\t\treturn false;\n\t\t} else if (matches(Future.class, cName) && !future().isValid(actual)) {\n\t\t\terr.add(Utils.formatMessage(\"{0} must be in the future.\", field));\n\t\t\treturn false;\n\t\t} else if (matches(Past.class, cName) && !past().isValid(actual)) {\n\t\t\terr.add(Utils.formatMessage(\"{0} must be in the past.\", field));\n\t\t\treturn false;\n\t\t} else if (matches(URL.class, cName) && !url().isValid(actual)) {\n\t\t\terr.add(Utils.formatMessage(\"{0} is not a valid URL.\", field));\n\t\t\treturn false;\n\t\t} else if (matches(Email.class, cName) && !email().isValid(actual)) {\n\t\t\terr.add(Utils.formatMessage(\"{0} is not a valid email.\", field));\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Returns all validation constraints that are defined by Java annotation in the core classes.\n\t *\n\t * @return a map of all core types to all core annotated constraints. See JSR-303.\n\t */\n\tpublic static Map<String, Map<String, Map<String, Map<String, ?>>>> getCoreValidationConstraints() {\n\t\tif (CORE_CONSTRAINTS.isEmpty()) {\n\t\t\tfor (Map.Entry<String, Class<? extends ParaObject>> e : ParaObjectUtils.getCoreClassesMap().entrySet()) {\n\t\t\t\tString type = e.getKey();\n\t\t\t\tList<Field> fieldlist = Utils.getAllDeclaredFields(e.getValue());\n\t\t\t\tfor (Field field : fieldlist) {\n\t\t\t\t\tAnnotation[] annos = field.getAnnotations();\n\t\t\t\t\tif (annos.length > 1) {\n\t\t\t\t\t\tMap<String, Map<String, ?>> constrMap = new HashMap<>();\n\t\t\t\t\t\tfor (Annotation anno : annos) {\n\t\t\t\t\t\t\tif (isValidConstraintType(anno.annotationType())) {\n\t\t\t\t\t\t\t\tConstraint c = fromAnnotation(anno);\n\t\t\t\t\t\t\t\tif (c != null) {\n\t\t\t\t\t\t\t\t\tconstrMap.put(c.getName(), c.getPayload());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!constrMap.isEmpty()) {\n\t\t\t\t\t\t\tif (!CORE_CONSTRAINTS.containsKey(type)) {\n\t\t\t\t\t\t\t\tCORE_CONSTRAINTS.put(type, new HashMap<>());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tCORE_CONSTRAINTS.get(type).put(field.getName(), constrMap);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tCORE_CONSTRAINTS.get(Utils.type(User.class)).put(\"password\",\n\t\t\t\t\tCollections.singletonMap(\"max\", Constraint.max(User.MAX_PASSWORD_LENGTH).getPayload()));\n\t\t}\n\t\treturn Collections.unmodifiableMap(CORE_CONSTRAINTS);\n\t}\n}\n", "/*\n * Copyright 2013-2022 Erudika. https://erudika.com\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * For issues and patches go to: https://github.com/erudika\n */\npackage com.erudika.para.core.utils;\n\nimport com.erudika.para.core.App;\nimport com.erudika.para.core.Sysprop;\nimport com.erudika.para.core.Tag;\nimport com.erudika.para.core.User;\nimport static com.erudika.para.core.validation.Constraint.*;\nimport static com.erudika.para.core.validation.ValidationUtils.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport static org.junit.Assert.*;\nimport org.junit.Test;\n\n/**\n *\n * @author Alex Bogdanovski [alex@erudika.com]\n */\npublic class ValidationUtilsTest {\n\n\n\t@Test\n\tpublic void testGetValidator() {\n\t\tassertNotNull(getValidator());\n\t}\n\n\t@Test\n\tpublic void testIsValidObject() {\n\t\tassertFalse(isValidObject(null));\n\t\tassertFalse(isValidObject(new Tag()));\n\t\tassertTrue(isValidObject(new Tag(\"tag1\")));\n\t\tTag t = new Tag(\"\");\n\t\tt.setName(\"\");\n\t\tassertFalse(isValidObject(t));\n\t\tassertFalse(isValidObject(new User()));\n\n\t\tUser u = new User();\n\t\tu.setId(\"123\");\n\t\tu.setName(\"asd\");\n\t\tassertFalse(isValidObject(u));\n\t}\n\n\t@Test\n\tpublic void testValidateObject() {\n\t\tassertTrue(validateObject(null).length > 0);\n\t\tassertEquals(0, validateObject(new Tag(\"test\")).length);\n\n\t\tApp app = new App(Config.PARA);\n\t\tassertTrue(validateObject(app).length == 0);\n\t\tapp.resetSecret();\n\t\tassertTrue(validateObject(app).length == 0);\n\n\t\tSysprop s1 = new Sysprop(\"s1\");\n\t\tassertTrue(validateObject(s1).length == 0);\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\n\t\ts1.setType(\"cat\");\n\t\tassertTrue(validateObject(s1).length == 0);\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\n\t\tassertTrue(app.getValidationConstraints().isEmpty());\n\t\tapp.addValidationConstraint(null, null, null);\n\t\tassertTrue(app.getValidationConstraints().isEmpty());\n\n\t\t// required\n\t\tapp.addValidationConstraint(s1.getType(), \"paws\", required());\n\t\tassertFalse(app.getValidationConstraints().get(s1.getType()).isEmpty());\n\t\tassertFalse(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"paws\", 2);\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\n\t\t// min\n\t\tapp.addValidationConstraint(s1.getType(), \"paws\", min(4L));\n\t\tassertFalse(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"paws\", 4);\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\n\t\t// max\n\t\tapp.addValidationConstraint(s1.getType(), \"paws\", max(5L));\n\t\ts1.addProperty(\"paws\", 6);\n\t\tassertFalse(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"paws\", 5);\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\n\t\t// size\n\t\tapp.addValidationConstraint(s1.getType(), \"name\", size(2, 3));\n\t\tassertFalse(validateObject(app, s1).length == 0);\n\t\ts1.setName(\"Bob\");\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\t\ts1.setName(\"Bobsy\");\n\t\tassertFalse(validateObject(app, s1).length == 0);\n\t\ts1.setName(\"Bob\");\n\t\t// null values are allowed and treated as valid\n\t\tapp.addValidationConstraint(s1.getType(), \"fur\", size(2, 3));\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\t\t// ints are a wrong type - not valid\n\t\ts1.addProperty(\"fur\", 3);\n\t\tassertFalse(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"fur\", \"yes\");\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"fur\", new ArrayList <String>(0));\n\t\tassertFalse(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"fur\", Arrays.asList(new String[]{\"one\", \"two\", \"three\"}));\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"fur\", new HashMap<String, String>(0));\n\t\tassertFalse(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"fur\", new HashMap<String, String>() {{\n\t\t\tput(\"1\", \"1\");\n\t\t\tput(\"2\", \"2\");\n\t\t\tput(\"3\", \"3\");\n\t\t}});\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"fur\", new String[0]);\n\t\tassertFalse(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"fur\", new String[]{\"one\", \"two\", \"three\"});\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\n\t\t// email\n\t\tapp.addValidationConstraint(s1.getType(), \"eemail\", email());\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"eemail\", 2);\n\t\tassertFalse(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"eemail\", \"a@..\");\n\t\tassertFalse(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"eemail\", \"a@bob.com\");\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\n\t\t// digits\n\t\tapp.addValidationConstraint(s1.getType(), \"specialnum\", digits(4, 2));\n\t\ts1.addProperty(\"specialnum\", \"??\");\n\t\tassertFalse(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"specialnum\", 12.34);\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"specialnum\", 1234.567);\n\t\tassertFalse(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"specialnum\", 12345.67);\n\t\tassertFalse(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"specialnum\", \"1234.5\");\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\n\t\t// pattern\n\t\tapp.addValidationConstraint(s1.getType(), \"regex\", pattern(\"^test\\\\sok=$\"));\n\t\ts1.addProperty(\"regex\", \"??\");\n\t\tassertFalse(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"regex\", \"test ok=\");\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\n\t\t// false\n\t\tapp.addValidationConstraint(s1.getType(), \"fals\", falsy());\n\t\ts1.addProperty(\"fals\", \"test\");\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"fals\", \"false\");\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"fals\", \"NO\");\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"fals\", \"0\");\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"fals\", 0);\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"fals\", false);\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"fals\", \"true\");\n\t\tassertFalse(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"fals\", true);\n\t\tassertFalse(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"fals\", false);\n\n\t\t// true\n\t\tapp.addValidationConstraint(s1.getType(), \"tru\", truthy());\n\t\ts1.addProperty(\"tru\", \"test\");\n\t\tassertFalse(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"tru\", \"false\");\n\t\tassertFalse(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"tru\", true);\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"tru\", \"true\");\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\n\t\t// future\n\t\tapp.addValidationConstraint(s1.getType(), \"future\", future());\n\t\ts1.addProperty(\"future\", 1234);\n\t\tassertFalse(validateObject(app, s1).length == 0);\n//\t\ts1.addProperty(\"future\", System.currentTimeMillis());\n//\t\tassertFalse(validateObject(app, s1).length == 0);\t// might fail on some machines\n\t\ts1.addProperty(\"future\", System.currentTimeMillis() + 10000);\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"future\", new Date(System.currentTimeMillis() + 10000));\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\n\t\t// past\n\t\tapp.addValidationConstraint(s1.getType(), \"past\", past());\n\t\ts1.addProperty(\"past\", System.currentTimeMillis() + 10000);\n\t\tassertFalse(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"past\", 1234);\n\t\tassertTrue(validateObject(app, s1).length == 0);\n//\t\ts1.addProperty(\"past\", System.currentTimeMillis());\n//\t\tassertFalse(validateObject(app, s1).length == 0);\t// might fail on some machines\n\t\ts1.addProperty(\"past\", new Date(System.currentTimeMillis()-1));\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\n\t\t// url\n\t\tapp.addValidationConstraint(s1.getType(), \"url\", url());\n\t\ts1.addProperty(\"url\", 1234);\n\t\tassertFalse(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"url\", \"http\");\n\t\tassertFalse(validateObject(app, s1).length == 0);\n\t\ts1.addProperty(\"url\", \"http://www.a.com\");\n\t\tassertTrue(validateObject(app, s1).length == 0);\n\t}\n\n\t@Test\n\tpublic void testPasswordConstraint() {\n\t\tUser u = new User();\n\t\tu.setName(\"test\");\n\t\tu.setEmail(\"ab@cd.com\");\n\t\tu.setIdentifier(\"ab@cd.com\");\n\t\tassertTrue(validateObject(u).length == 0);\n\t\tu.setPassword(\"T123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456\"\n\t\t\t\t+ \"78912345678912345678912345678912345678912345678912345678912345678912345678912345678912345678912345670\"\n\t\t\t\t+ \"89123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789\"\n\t\t\t\t+ \"12345678912345678912345678912345678912345678912345678912345678912345678912345678912345678912345678912\"\n\t\t\t\t+ \"34567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234\"\n\t\t\t\t+ \"56789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456\"\n\t\t\t\t+ \"78912345678912345678912345678912345678912345678912345678912345678912345678912345678912345678912345678\"\n\t\t\t\t+ \"91234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891\"\n\t\t\t\t+ \"23456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123\"\n\t\t\t\t+ \"45678912345678912345678912345678912345678912345678912345678912345678912345678912345678912345678912345\"\n\t\t\t\t+ \"67891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567\"\n\t\t\t\t+ \"89123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789\"\n\t\t\t\t+ \"12345678912345678912345678912345678912345678912345678912345678912345678912345678912345678912345678912\"\n\t\t\t\t+ \"34567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234\"\n\t\t\t\t+ \"56789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456\"\n\t\t\t\t+ \"78912345678912345678912345678912345678912345678912345678912345678912345678912345678912345678912345678\"\n\t\t\t\t+ \"91234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891\"\n\t\t\t\t+ \"23456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123\"\n\t\t\t\t+ \"45678912345678912345678912345678912345678912345678912345678912345678912345678912345678912345678912345\"\n\t\t\t\t+ \"67891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567\"\n\t\t\t\t+ \"89123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789\"\n\t\t\t\t+ \"12345678912345678912345678912345678912345678912345678912345678912345678912345678912345678912345678912\"\n\t\t\t\t+ \"34567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234\"\n\t\t\t\t+ \"56789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456\"\n\t\t\t\t+ \"78912345678912345678912345678912345678912345678912345678912345678912345678912345678912345678912345678\"\n\t\t\t\t+ \"91234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891\"\n\t\t\t\t+ \"23456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123\"\n\t\t\t\t+ \"45678912345678912345678912345678912345678912345678912345678912345678912345678912345678912345678912345\"\n\t\t\t\t+ \"67891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567\"\n\t\t\t\t+ \"89123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789\"\n\t\t\t\t+ \"12345678912345678912345678912345678912345678912345678912345678912345678912345678912345678912345678912\"\n\t\t\t\t+ \"34567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234\"\n\t\t\t\t+ \"56789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456\"\n\t\t\t\t+ \"78912345678912345678912345678912345678912345678912345678912345678912345678912345678912345678912345678\"\n\t\t\t\t+ \"91234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891\"\n\t\t\t\t+ \"23456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123\"\n\t\t\t\t+ \"45678912345678912345678912345678912345678912345678912345678912345678912345678912345678912345678912345\"\n\t\t\t\t+ \"67891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567\"\n\t\t\t\t+ \"89123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789\"\n\t\t\t\t+ \"12345678912345678912345678912345678912345678912345678912345678912345678912345678912345678912345678912\"\n\t\t\t\t+ \"34567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234\"\n\t\t\t\t+ \"56789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456\"\n\t\t\t\t+ \"78912345678912345678912345678912345678912345678912345678912345678912345678912345678912345678912345678\"\n\t\t\t\t+ \"91234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891\"\n\t\t\t\t+ \"23456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123\"\n\t\t\t\t+ \"45678912345678912345678912345678912345678912345678912345678912345678912345678912345678912345678912345\"\n\t\t\t\t+ \"67891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567\"\n\t\t\t\t+ \"89123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789\"\n\t\t\t\t+ \"12345678912345678912345678912345678912345678912345678912345678912345678912345678912345678912345678912\"\n\t\t\t\t+ \"34567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234567891234\"\n\t\t\t\t+ \"56789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456\"\n\t\t\t\t+ \"789hellohellohellohello\");\n\t\tassertFalse(validateObject(u).length == 0);\n\t}\n\n\t@Test\n\tpublic void testGetCoreValidationConstraints() {\n\t\tassertTrue(getCoreValidationConstraints().containsKey(\"app\"));\n\t}\n\n\t@Test\n\tpublic void testAllConstraints() {\n\t\t// null is ok, because value might not be required\n\t\tassertTrue(email().isValid(null));\n\t\tassertTrue(email().isValid(\"abc@de.com\"));\n\t\tassertFalse(email().isValid(\"abc@de.\"));\n\t\tassertFalse(email().isValid(\"abc@.c\"));\n\t\tassertFalse(email().isValid(123));\n\t\tassertFalse(email().isValid(\" \"));\n\n\t\tassertTrue(falsy().isValid(null));\n\t\tassertTrue(falsy().isValid(\"false\"));\n\t\tassertTrue(falsy().isValid(\"FALSE\"));\n\t\tassertTrue(falsy().isValid(false));\n\t\tassertTrue(falsy().isValid(\"fals\"));\n\t\tassertTrue(falsy().isValid(\" \"));\n\t\tassertFalse(falsy().isValid(\"true\"));\n\t\tassertFalse(falsy().isValid(true));\n\n\t\tassertTrue(truthy().isValid(null));\n\t\tassertTrue(truthy().isValid(\"true\"));\n\t\tassertTrue(truthy().isValid(\"True\"));\n\t\tassertTrue(truthy().isValid(true));\n\t\tassertFalse(truthy().isValid(false));\n\t\tassertFalse(truthy().isValid(\"a\"));\n\t\tassertFalse(truthy().isValid(\" \"));\n\n\t\tassertFalse(required().isValid(null));\n\t\tassertFalse(required().isValid(\" \"));\n\t\tassertTrue(required().isValid(\"text\"));\n\t\tassertTrue(required().isValid(1));\n\t\tassertTrue(required().isValid(true));\n\n\t\tlong now = System.currentTimeMillis();\n\t\tassertTrue(future().isValid(null));\n\t\tassertTrue(future().isValid(new Date(now + 1000)));\n\t\tassertFalse(future().isValid(new Date(now - 1000)));\n\n\t\tassertTrue(past().isValid(null));\n\t\tassertTrue(past().isValid(new Date(now - 1000)));\n\t\tassertFalse(past().isValid(new Date(now + 1000)));\n\n\t\tassertTrue(url().isValid(null));\n\t\tassertTrue(url().isValid(\"http://abc.co\"));\n\t\tassertFalse(url().isValid(\"htp://abc.co\"));\n\t\tassertFalse(url().isValid(\"abc.com\"));\n\t\tassertFalse(url().isValid(\" \"));\n\t\tassertFalse(url().isValid(false));\n\n\t\tassertTrue(min(3).isValid(null));\n\t\tassertTrue(min(3).isValid(3));\n\t\tassertTrue(min(3).isValid(4));\n\t\tassertFalse(min(4).isValid(3));\n\t\tassertFalse(min(2).isValid(\"3\"));\n\t\tassertFalse(min(4).isValid(true));\n\t\tassertFalse(min(null).isValid(\" \"));\n\t\tassertFalse(min(null).isValid(3));\n\n\t\tassertTrue(max(3).isValid(null));\n\t\tassertTrue(max(3).isValid(3));\n\t\tassertTrue(max(4).isValid(3));\n\t\tassertFalse(max(3).isValid(4));\n\t\tassertFalse(max(2).isValid(\"3\"));\n\t\tassertFalse(max(4).isValid(true));\n\t\tassertFalse(max(null).isValid(\" \"));\n\t\tassertFalse(max(null).isValid(3));\n\n\t\tassertTrue(size(2, 3).isValid(null));\n\t\tassertTrue(size(2, 3).isValid(\"xx\"));\n\t\tassertFalse(size(3, 2).isValid(\"xx\"));\n\t\tassertFalse(size(2, 3).isValid(\"xxxx\"));\n\t\tassertFalse(size(2, 3).isValid(\"x\"));\n\t\tassertTrue(size(0, 0).isValid(\"\"));\n\t\tassertTrue(size(0, 0).isValid(new String[0]));\n\t\tassertTrue(size(1, 2).isValid(new String[]{\"a\", \"b\"}));\n\t\tassertTrue(size(1, 2).isValid(Arrays.asList(new String[]{\"a\", \"b\"})));\n\t\tassertTrue(size(1, 2).isValid(Collections.singletonMap(\"a\", \"b\")));\n\n\t\tassertTrue(digits(2, 2).isValid(null));\n\t\tassertTrue(digits(2, 2).isValid(\"22.22\"));\n\t\tassertFalse(digits(2, 2).isValid(\"22.222\"));\n\t\tassertFalse(digits(1, 2).isValid(\"2.222\"));\n\t\tassertTrue(digits(1, 2).isValid(\"2.22\"));\n\t\tassertTrue(digits(1, 2).isValid(2.22));\n\t\tassertTrue(digits(1, 2).isValid(0));\n\t\tassertFalse(digits(1, 2).isValid(12));\n\t\tassertFalse(digits(0, 2).isValid(1));\n\n\t\tassertTrue(pattern(null).isValid(null));\n\t\tassertTrue(pattern(\"\").isValid(\"\"));\n\t\tassertTrue(pattern(\"[ab]+\").isValid(\"bababa\"));\n\t\tassertTrue(pattern(\"\\\\.[ab]+\").isValid(\".babababa\"));\n\t\tassertFalse(pattern(\"\").isValid(\" \"));\n\t}\n}\n"], "filenames": ["para-core/src/main/java/com/erudika/para/core/User.java", "para-core/src/main/java/com/erudika/para/core/validation/ValidationUtils.java", "para-server/src/test/java/com/erudika/para/core/utils/ValidationUtilsTest.java"], "buggy_code_start_loc": [35, 62, 20], "buggy_code_end_loc": [84, 126, 228], "fixing_code_start_loc": [34, 63, 19], "fixing_code_end_loc": [83, 131, 290], "type": "NVD-CWE-noinfo", "message": "Business Logic Errors in GitHub repository erudika/para prior to 1.45.11.", "other": {"cve": {"id": "CVE-2022-1848", "sourceIdentifier": "security@huntr.dev", "published": "2022-05-24T13:15:07.683", "lastModified": "2022-06-03T14:02:01.267", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Business Logic Errors in GitHub repository erudika/para prior to 1.45.11."}, {"lang": "es", "value": "Unos Errores de L\u00f3gica de Negocio en el repositorio GitHub erudika/para versiones anteriores a 1.45.11"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.0, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.3, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-840"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:erudika:para:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.45.11", "matchCriteriaId": "9681E6A4-3CDB-4FE4-958A-136719A981BE"}]}]}], "references": [{"url": "https://github.com/erudika/para/commit/fa677c629842df60099daa9c23bd802bc41b48d1", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/8dfe0877-e44b-4a1a-8eee-5c03c93ae90a", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/erudika/para/commit/fa677c629842df60099daa9c23bd802bc41b48d1"}}