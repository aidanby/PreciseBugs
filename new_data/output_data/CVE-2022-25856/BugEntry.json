{"buggy_code": ["/*\nCopyright 2018 BlackRock, Inc.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n\thttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage artifacts\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\n\t\"github.com/go-git/go-git/v5\"\n\t\"github.com/go-git/go-git/v5/config\"\n\t\"github.com/go-git/go-git/v5/plumbing\"\n\t\"github.com/go-git/go-git/v5/plumbing/transport\"\n\t\"github.com/go-git/go-git/v5/plumbing/transport/http\"\n\tgo_git_ssh \"github.com/go-git/go-git/v5/plumbing/transport/ssh\"\n\t\"github.com/pkg/errors\"\n\t\"golang.org/x/crypto/ssh\"\n\n\t\"github.com/argoproj/argo-events/common\"\n\t\"github.com/argoproj/argo-events/pkg/apis/sensor/v1alpha1\"\n)\n\nconst (\n\tDefaultRemote = \"origin\"\n\tDefaultBranch = \"master\"\n)\n\nvar (\n\tfetchRefSpec = []config.RefSpec{\n\t\t\"refs/*:refs/*\",\n\t\t\"HEAD:refs/heads/HEAD\",\n\t}\n)\n\ntype GitArtifactReader struct {\n\tartifact *v1alpha1.GitArtifact\n}\n\n// NewGitReader returns a new git reader\nfunc NewGitReader(gitArtifact *v1alpha1.GitArtifact) (*GitArtifactReader, error) {\n\treturn &GitArtifactReader{\n\t\tartifact: gitArtifact,\n\t}, nil\n}\n\nfunc (g *GitArtifactReader) getRemote() string {\n\tif g.artifact.Remote != nil {\n\t\treturn g.artifact.Remote.Name\n\t}\n\treturn DefaultRemote\n}\n\nfunc getSSHKeyAuth(sshKeyFile string) (transport.AuthMethod, error) {\n\tsshKey, err := ioutil.ReadFile(sshKeyFile)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to read ssh key file. err: %+v\", err)\n\t}\n\tsigner, err := ssh.ParsePrivateKey(sshKey)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to parse ssh key. err: %+v\", err)\n\t}\n\tauth := &go_git_ssh.PublicKeys{User: \"git\", Signer: signer}\n\tauth.HostKeyCallback = ssh.InsecureIgnoreHostKey()\n\treturn auth, nil\n}\n\nfunc (g *GitArtifactReader) getGitAuth() (transport.AuthMethod, error) {\n\tif g.artifact.Creds != nil {\n\t\tusername, err := common.GetSecretFromVolume(g.artifact.Creds.Username)\n\t\tif err != nil {\n\t\t\treturn nil, errors.Wrap(err, \"failed to retrieve username\")\n\t\t}\n\t\tpassword, err := common.GetSecretFromVolume(g.artifact.Creds.Password)\n\t\tif err != nil {\n\t\t\treturn nil, errors.Wrap(err, \"failed to retrieve password\")\n\t\t}\n\t\treturn &http.BasicAuth{\n\t\t\tUsername: username,\n\t\t\tPassword: password,\n\t\t}, nil\n\t}\n\tif g.artifact.SSHKeySecret != nil {\n\t\tsshKeyPath, err := common.GetSecretVolumePath(g.artifact.SSHKeySecret)\n\t\tif err != nil {\n\t\t\treturn nil, errors.Wrap(err, \"failed to get SSH key from mounted volume\")\n\t\t}\n\t\treturn getSSHKeyAuth(sshKeyPath)\n\t}\n\treturn nil, nil\n}\n\nfunc (g *GitArtifactReader) readFromRepository(r *git.Repository, dir string) ([]byte, error) {\n\tauth, err := g.getGitAuth()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif g.artifact.Remote != nil {\n\t\t_, err := r.CreateRemote(&config.RemoteConfig{\n\t\t\tName: g.artifact.Remote.Name,\n\t\t\tURLs: g.artifact.Remote.URLS,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to create remote. err: %+v\", err)\n\t\t}\n\n\t\tfetchOptions := &git.FetchOptions{\n\t\t\tRemoteName: g.artifact.Remote.Name,\n\t\t\tRefSpecs:   fetchRefSpec,\n\t\t\tForce:      true,\n\t\t}\n\t\tif auth != nil {\n\t\t\tfetchOptions.Auth = auth\n\t\t}\n\n\t\tif err := r.Fetch(fetchOptions); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to fetch remote %s. err: %+v\", g.artifact.Remote.Name, err)\n\t\t}\n\t}\n\n\tw, err := r.Worktree()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get working tree. err: %+v\", err)\n\t}\n\n\tfetchOptions := &git.FetchOptions{\n\t\tRemoteName: g.getRemote(),\n\t\tRefSpecs:   fetchRefSpec,\n\t\tForce:      true,\n\t}\n\tif auth != nil {\n\t\tfetchOptions.Auth = auth\n\t}\n\n\t// In the case of a specific given ref, it isn't necessary to fetch anything\n\t// but the single ref\n\tif g.artifact.Ref != \"\" {\n\t\tfetchOptions.Depth = 1\n\t\tfetchOptions.RefSpecs = []config.RefSpec{config.RefSpec(g.artifact.Ref + \":\" + g.artifact.Ref)}\n\t}\n\n\tif err := r.Fetch(fetchOptions); err != nil && err != git.NoErrAlreadyUpToDate {\n\t\treturn nil, fmt.Errorf(\"failed to fetch. err: %v\", err)\n\t}\n\n\tif err := w.Checkout(g.getBranchOrTag()); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to checkout. err: %+v\", err)\n\t}\n\n\t// In the case of a specific given ref, it shouldn't be necessary to pull\n\tif g.artifact.Ref != \"\" {\n\t\tpullOpts := &git.PullOptions{\n\t\t\tRecurseSubmodules: git.DefaultSubmoduleRecursionDepth,\n\t\t\tReferenceName:     g.getBranchOrTag().Branch,\n\t\t\tForce:             true,\n\t\t}\n\t\tif auth != nil {\n\t\t\tpullOpts.Auth = auth\n\t\t}\n\n\t\tif err := w.Pull(pullOpts); err != nil && err != git.NoErrAlreadyUpToDate {\n\t\t\treturn nil, fmt.Errorf(\"failed to pull latest updates. err: %+v\", err)\n\t\t}\n\t}\n\n\treturn ioutil.ReadFile(fmt.Sprintf(\"%s/%s\", dir, g.artifact.FilePath))\n}\n\nfunc (g *GitArtifactReader) getBranchOrTag() *git.CheckoutOptions {\n\topts := &git.CheckoutOptions{}\n\n\topts.Branch = plumbing.NewBranchReferenceName(DefaultBranch)\n\n\tif g.artifact.Branch != \"\" {\n\t\topts.Branch = plumbing.NewBranchReferenceName(g.artifact.Branch)\n\t}\n\tif g.artifact.Tag != \"\" {\n\t\topts.Branch = plumbing.NewTagReferenceName(g.artifact.Tag)\n\t}\n\tif g.artifact.Ref != \"\" {\n\t\topts.Branch = plumbing.ReferenceName(g.artifact.Ref)\n\t}\n\n\treturn opts\n}\n\nfunc (g *GitArtifactReader) Read() ([]byte, error) {\n\tcloneDir := g.artifact.CloneDirectory\n\tif cloneDir == \"\" {\n\t\ttempDir, err := ioutil.TempDir(\"\", \"git-tmp\")\n\t\tif err != nil {\n\t\t\treturn nil, errors.Wrap(err, \"failed to create a temp file to clone the repository\")\n\t\t}\n\t\tdefer os.Remove(tempDir)\n\t\tcloneDir = tempDir\n\t}\n\n\tr, err := git.PlainOpen(cloneDir)\n\tif err != nil {\n\t\tif err != git.ErrRepositoryNotExists {\n\t\t\treturn nil, fmt.Errorf(\"failed to open repository. err: %+v\", err)\n\t\t}\n\n\t\tcloneOpt := &git.CloneOptions{\n\t\t\tURL:               g.artifact.URL,\n\t\t\tRecurseSubmodules: git.DefaultSubmoduleRecursionDepth,\n\t\t}\n\n\t\tauth, err := g.getGitAuth()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif auth != nil {\n\t\t\tcloneOpt.Auth = auth\n\t\t}\n\n\t\t// In the case of a specific given ref, it isn't necessary to have branch\n\t\t// histories\n\t\tif g.artifact.Ref != \"\" {\n\t\t\tcloneOpt.Depth = 1\n\t\t}\n\n\t\tr, err = git.PlainClone(cloneDir, false, cloneOpt)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to clone repository. err: %+v\", err)\n\t\t}\n\t}\n\treturn g.readFromRepository(r, cloneDir)\n}\n"], "fixing_code": ["/*\nCopyright 2018 BlackRock, Inc.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n\thttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage artifacts\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path\"\n\t\"strings\"\n\n\t\"github.com/go-git/go-git/v5\"\n\t\"github.com/go-git/go-git/v5/config\"\n\t\"github.com/go-git/go-git/v5/plumbing\"\n\t\"github.com/go-git/go-git/v5/plumbing/transport\"\n\t\"github.com/go-git/go-git/v5/plumbing/transport/http\"\n\tgo_git_ssh \"github.com/go-git/go-git/v5/plumbing/transport/ssh\"\n\t\"github.com/pkg/errors\"\n\t\"golang.org/x/crypto/ssh\"\n\n\t\"github.com/argoproj/argo-events/common\"\n\t\"github.com/argoproj/argo-events/pkg/apis/sensor/v1alpha1\"\n)\n\nconst (\n\tDefaultRemote = \"origin\"\n\tDefaultBranch = \"master\"\n)\n\nvar (\n\tfetchRefSpec = []config.RefSpec{\n\t\t\"refs/*:refs/*\",\n\t\t\"HEAD:refs/heads/HEAD\",\n\t}\n\n\tnotAllowedInPath = []string{\"..\", \"~\", \"\\\\\"}\n)\n\ntype GitArtifactReader struct {\n\tartifact *v1alpha1.GitArtifact\n}\n\n// NewGitReader returns a new git reader\nfunc NewGitReader(gitArtifact *v1alpha1.GitArtifact) (*GitArtifactReader, error) {\n\tif gitArtifact == nil {\n\t\treturn nil, fmt.Errorf(\"nil git artifact\")\n\t}\n\tfor _, na := range notAllowedInPath {\n\t\tif strings.Contains(gitArtifact.FilePath, na) {\n\t\t\treturn nil, fmt.Errorf(\"%q is not allowed in the filepath\", na)\n\t\t}\n\t}\n\n\treturn &GitArtifactReader{\n\t\tartifact: gitArtifact,\n\t}, nil\n}\n\nfunc (g *GitArtifactReader) getRemote() string {\n\tif g.artifact.Remote != nil {\n\t\treturn g.artifact.Remote.Name\n\t}\n\treturn DefaultRemote\n}\n\nfunc getSSHKeyAuth(sshKeyFile string) (transport.AuthMethod, error) {\n\tsshKey, err := ioutil.ReadFile(sshKeyFile)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to read ssh key file. err: %+v\", err)\n\t}\n\tsigner, err := ssh.ParsePrivateKey(sshKey)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to parse ssh key. err: %+v\", err)\n\t}\n\tauth := &go_git_ssh.PublicKeys{User: \"git\", Signer: signer}\n\tauth.HostKeyCallback = ssh.InsecureIgnoreHostKey()\n\treturn auth, nil\n}\n\nfunc (g *GitArtifactReader) getGitAuth() (transport.AuthMethod, error) {\n\tif g.artifact.Creds != nil {\n\t\tusername, err := common.GetSecretFromVolume(g.artifact.Creds.Username)\n\t\tif err != nil {\n\t\t\treturn nil, errors.Wrap(err, \"failed to retrieve username\")\n\t\t}\n\t\tpassword, err := common.GetSecretFromVolume(g.artifact.Creds.Password)\n\t\tif err != nil {\n\t\t\treturn nil, errors.Wrap(err, \"failed to retrieve password\")\n\t\t}\n\t\treturn &http.BasicAuth{\n\t\t\tUsername: username,\n\t\t\tPassword: password,\n\t\t}, nil\n\t}\n\tif g.artifact.SSHKeySecret != nil {\n\t\tsshKeyPath, err := common.GetSecretVolumePath(g.artifact.SSHKeySecret)\n\t\tif err != nil {\n\t\t\treturn nil, errors.Wrap(err, \"failed to get SSH key from mounted volume\")\n\t\t}\n\t\treturn getSSHKeyAuth(sshKeyPath)\n\t}\n\treturn nil, nil\n}\n\nfunc (g *GitArtifactReader) readFromRepository(r *git.Repository, dir string) ([]byte, error) {\n\tauth, err := g.getGitAuth()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif g.artifact.Remote != nil {\n\t\t_, err := r.CreateRemote(&config.RemoteConfig{\n\t\t\tName: g.artifact.Remote.Name,\n\t\t\tURLs: g.artifact.Remote.URLS,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to create remote. err: %+v\", err)\n\t\t}\n\n\t\tfetchOptions := &git.FetchOptions{\n\t\t\tRemoteName: g.artifact.Remote.Name,\n\t\t\tRefSpecs:   fetchRefSpec,\n\t\t\tForce:      true,\n\t\t}\n\t\tif auth != nil {\n\t\t\tfetchOptions.Auth = auth\n\t\t}\n\n\t\tif err := r.Fetch(fetchOptions); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to fetch remote %s. err: %+v\", g.artifact.Remote.Name, err)\n\t\t}\n\t}\n\n\tw, err := r.Worktree()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get working tree. err: %+v\", err)\n\t}\n\n\tfetchOptions := &git.FetchOptions{\n\t\tRemoteName: g.getRemote(),\n\t\tRefSpecs:   fetchRefSpec,\n\t\tForce:      true,\n\t}\n\tif auth != nil {\n\t\tfetchOptions.Auth = auth\n\t}\n\n\t// In the case of a specific given ref, it isn't necessary to fetch anything\n\t// but the single ref\n\tif g.artifact.Ref != \"\" {\n\t\tfetchOptions.Depth = 1\n\t\tfetchOptions.RefSpecs = []config.RefSpec{config.RefSpec(g.artifact.Ref + \":\" + g.artifact.Ref)}\n\t}\n\n\tif err := r.Fetch(fetchOptions); err != nil && err != git.NoErrAlreadyUpToDate {\n\t\treturn nil, fmt.Errorf(\"failed to fetch. err: %v\", err)\n\t}\n\n\tif err := w.Checkout(g.getBranchOrTag()); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to checkout. err: %+v\", err)\n\t}\n\n\t// In the case of a specific given ref, it shouldn't be necessary to pull\n\tif g.artifact.Ref != \"\" {\n\t\tpullOpts := &git.PullOptions{\n\t\t\tRecurseSubmodules: git.DefaultSubmoduleRecursionDepth,\n\t\t\tReferenceName:     g.getBranchOrTag().Branch,\n\t\t\tForce:             true,\n\t\t}\n\t\tif auth != nil {\n\t\t\tpullOpts.Auth = auth\n\t\t}\n\n\t\tif err := w.Pull(pullOpts); err != nil && err != git.NoErrAlreadyUpToDate {\n\t\t\treturn nil, fmt.Errorf(\"failed to pull latest updates. err: %+v\", err)\n\t\t}\n\t}\n\tfilePath := fmt.Sprintf(\"%s/%s\", dir, g.artifact.FilePath)\n\t// symbol link is not allowed due to security concern\n\tisSymbolLink, err := isSymbolLink(filePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif isSymbolLink {\n\t\treturn nil, fmt.Errorf(\"%q is a symbol link which is not allowed\", g.artifact.FilePath)\n\t}\n\treturn ioutil.ReadFile(filePath)\n}\n\nfunc (g *GitArtifactReader) getBranchOrTag() *git.CheckoutOptions {\n\topts := &git.CheckoutOptions{}\n\n\topts.Branch = plumbing.NewBranchReferenceName(DefaultBranch)\n\n\tif g.artifact.Branch != \"\" {\n\t\topts.Branch = plumbing.NewBranchReferenceName(g.artifact.Branch)\n\t}\n\tif g.artifact.Tag != \"\" {\n\t\topts.Branch = plumbing.NewTagReferenceName(g.artifact.Tag)\n\t}\n\tif g.artifact.Ref != \"\" {\n\t\topts.Branch = plumbing.ReferenceName(g.artifact.Ref)\n\t}\n\n\treturn opts\n}\n\nfunc (g *GitArtifactReader) Read() ([]byte, error) {\n\tcloneDir := g.artifact.CloneDirectory\n\tif cloneDir == \"\" {\n\t\ttempDir, err := ioutil.TempDir(\"\", \"git-tmp\")\n\t\tif err != nil {\n\t\t\treturn nil, errors.Wrap(err, \"failed to create a temp file to clone the repository\")\n\t\t}\n\t\tdefer os.Remove(tempDir)\n\t\tcloneDir = tempDir\n\t}\n\n\tr, err := git.PlainOpen(cloneDir)\n\tif err != nil {\n\t\tif err != git.ErrRepositoryNotExists {\n\t\t\treturn nil, fmt.Errorf(\"failed to open repository. err: %+v\", err)\n\t\t}\n\n\t\tcloneOpt := &git.CloneOptions{\n\t\t\tURL:               g.artifact.URL,\n\t\t\tRecurseSubmodules: git.DefaultSubmoduleRecursionDepth,\n\t\t}\n\n\t\tauth, err := g.getGitAuth()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif auth != nil {\n\t\t\tcloneOpt.Auth = auth\n\t\t}\n\n\t\t// In the case of a specific given ref, it isn't necessary to have branch\n\t\t// histories\n\t\tif g.artifact.Ref != \"\" {\n\t\t\tcloneOpt.Depth = 1\n\t\t}\n\n\t\tr, err = git.PlainClone(cloneDir, false, cloneOpt)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to clone repository. err: %+v\", err)\n\t\t}\n\t}\n\treturn g.readFromRepository(r, cloneDir)\n}\n\nfunc isSymbolLink(filepath string) (bool, error) {\n\tfi, err := os.Lstat(path.Clean(filepath))\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tif fi.Mode()&os.ModeSymlink != 0 {\n\t\treturn true, nil\n\t}\n\treturn false, nil\n}\n"], "filenames": ["sensors/artifacts/git.go"], "buggy_code_start_loc": [22], "buggy_code_end_loc": [243], "fixing_code_start_loc": [23], "fixing_code_end_loc": [276], "type": "CWE-22", "message": "The package github.com/argoproj/argo-events/sensors/artifacts before 1.7.1 are vulnerable to Directory Traversal in the (g *GitArtifactReader).Read() API in git.go. This could allow arbitrary file reads if the GitArtifactReader is provided a pathname containing a symbolic link or an implicit directory name such as ...", "other": {"cve": {"id": "CVE-2022-25856", "sourceIdentifier": "report@snyk.io", "published": "2022-06-17T20:15:10.607", "lastModified": "2022-06-28T14:54:56.283", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The package github.com/argoproj/argo-events/sensors/artifacts before 1.7.1 are vulnerable to Directory Traversal in the (g *GitArtifactReader).Read() API in git.go. This could allow arbitrary file reads if the GitArtifactReader is provided a pathname containing a symbolic link or an implicit directory name such as ..."}, {"lang": "es", "value": "El paquete github.com/argoproj/argo-events/sensors/artifacts versiones anteriores a 1.7.1, es vulnerable a un Salto de Directorio en la API (g *GitArtifactReader).Read() en git.go. Esto podr\u00eda permitir la lectura arbitraria de archivos si al GitArtifactReader le es proporcionada una ruta que contenga un enlace simb\u00f3lico o un nombre de directorio impl\u00edcito como ..."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:argo_events_project:argo_events:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.7.1", "matchCriteriaId": "A667F219-0024-441E-9D44-0336D782C472"}]}]}], "references": [{"url": "https://github.com/argoproj/argo-events/commit/d0f66dbce78bc31923ca057b20fc722aa24ca961", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/argoproj/argo-events/issues/1947", "source": "report@snyk.io", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-GOLANG-GITHUBCOMARGOPROJARGOEVENTSSENSORSARTIFACTS-2864522", "source": "report@snyk.io", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/argoproj/argo-events/commit/d0f66dbce78bc31923ca057b20fc722aa24ca961"}}