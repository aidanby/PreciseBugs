{"buggy_code": ["# frozen_string_literal: true\nrequire 'tempfile'\nrequire 'net/ntlm'\nrequire 'webrobots'\n\n##\n# An HTTP (and local disk access) user agent.  This class is an implementation\n# detail and is subject to change at any time.\n\nclass Mechanize::HTTP::Agent\n\n  CREDENTIAL_HEADERS = ['Authorization', 'Cookie']\n  POST_HEADERS = ['Content-Length', 'Content-MD5', 'Content-Type']\n\n  # :section: Headers\n\n  # Disables If-Modified-Since conditional requests (enabled by default)\n  attr_accessor :conditional_requests\n\n  # Is gzip compression of requests enabled?\n  attr_accessor :gzip_enabled\n\n  # A hash of request headers to be used for every request\n  attr_accessor :request_headers\n\n  # The User-Agent header to send\n  attr_reader :user_agent\n\n  # :section: History\n\n  # history of requests made\n  attr_accessor :history\n\n  # :section: Hooks\n\n  # A list of hooks to call after retrieving a response.  Hooks are called with\n  # the agent and the response returned.\n  attr_reader :post_connect_hooks\n\n  # A list of hooks to call before making a request.  Hooks are called with\n  # the agent and the request to be performed.\n  attr_reader :pre_connect_hooks\n\n  # A list of hooks to call to handle the content-encoding of a request.\n  attr_reader :content_encoding_hooks\n\n  # :section: HTTP Authentication\n\n  attr_reader :auth_store # :nodoc:\n  attr_reader :authenticate_methods # :nodoc:\n  attr_reader :digest_challenges # :nodoc:\n\n  # :section: Redirection\n\n  # Follow HTML meta refresh and HTTP Refresh.  If set to +:anywhere+ meta\n  # refresh tags outside of the head element will be followed.\n  attr_accessor :follow_meta_refresh\n\n  # Follow an HTML meta refresh that has no \"url=\" in the content attribute.\n  #\n  # Defaults to false to prevent infinite refresh loops.\n  attr_accessor :follow_meta_refresh_self\n\n  # Controls how this agent deals with redirects.  The following values are\n  # allowed:\n  #\n  # :all, true:: All 3xx redirects are followed (default)\n  # :permanent:: Only 301 Moved Permanantly redirects are followed\n  # false:: No redirects are followed\n  attr_accessor :redirect_ok\n\n  # Maximum number of redirects to follow\n  attr_accessor :redirection_limit\n\n  # :section: Allowed error codes\n\n  # List of error codes (in String or Integer) to handle without\n  # raising Mechanize::ResponseCodeError, defaulted to an empty array.\n  # Note that 2xx, 3xx and 401 status codes will be handled without\n  # checking this list.\n\n  attr_accessor :allowed_error_codes\n\n  # :section: Robots\n\n  # When true, this agent will consult the site's robots.txt for each access.\n  attr_reader :robots\n\n  # Mutex used when fetching robots.txt\n  attr_reader :robots_mutex\n\n  # :section: SSL\n\n  # OpenSSL key password\n  attr_accessor :pass\n\n  # :section: Timeouts\n\n  # Set to false to disable HTTP/1.1 keep-alive requests\n  attr_accessor :keep_alive\n\n  # Length of time to wait until a connection is opened in seconds\n  attr_accessor :open_timeout\n\n  # Length of time to attempt to read data from the server\n  attr_accessor  :read_timeout\n\n  # :section:\n\n  # The cookies for this agent\n  attr_accessor :cookie_jar\n\n  # Responses larger than this will be written to a Tempfile instead of stored\n  # in memory.  Setting this to nil disables creation of Tempfiles.\n  attr_accessor :max_file_buffer\n\n  # :section: Utility\n\n  # The context parses responses into pages\n  attr_accessor :context\n\n  attr_reader :http # :nodoc:\n\n  # When set to true mechanize will ignore an EOF during chunked transfer\n  # encoding so long as at least one byte was received.  Be careful when\n  # enabling this as it may cause data loss.\n  attr_accessor :ignore_bad_chunking\n\n  # Handlers for various URI schemes\n  attr_accessor :scheme_handlers\n\n  # :section:\n\n  # Creates a new Mechanize HTTP user agent.  The user agent is an\n  # implementation detail of mechanize and its API may change at any time.\n\n  # The connection_name can be used to segregate SSL connections.\n  # Agents with different names will not share the same persistent connection.\n  def initialize(connection_name = 'mechanize')\n    @allowed_error_codes      = []\n    @conditional_requests     = true\n    @context                  = nil\n    @content_encoding_hooks   = []\n    @cookie_jar               = Mechanize::CookieJar.new\n    @follow_meta_refresh      = false\n    @follow_meta_refresh_self = false\n    @gzip_enabled             = true\n    @history                  = Mechanize::History.new\n    @ignore_bad_chunking      = false\n    @keep_alive               = true\n    @max_file_buffer          = 100_000 # 5MB for response bodies\n    @open_timeout             = nil\n    @post_connect_hooks       = []\n    @pre_connect_hooks        = []\n    @read_timeout             = nil\n    @redirect_ok              = true\n    @redirection_limit        = 20\n    @request_headers          = {}\n    @robots                   = false\n    @robots_mutex             = Mutex.new\n    @user_agent               = nil\n    @webrobots                = nil\n\n    # HTTP Authentication\n    @auth_store           = Mechanize::HTTP::AuthStore.new\n    @authenticate_parser  = Mechanize::HTTP::WWWAuthenticateParser.new\n    @authenticate_methods = Hash.new do |methods, uri|\n      methods[uri] = Hash.new do |realms, auth_scheme|\n        realms[auth_scheme] = []\n      end\n    end\n    @digest_auth          = Net::HTTP::DigestAuth.new\n    @digest_challenges    = {}\n\n    # SSL\n    @pass = nil\n\n    @scheme_handlers = Hash.new { |h, scheme|\n      h[scheme] = lambda { |link, page|\n        raise Mechanize::UnsupportedSchemeError.new(scheme, link)\n      }\n    }\n\n    @scheme_handlers['http']      = lambda { |link, page| link }\n    @scheme_handlers['https']     = @scheme_handlers['http']\n    @scheme_handlers['relative']  = @scheme_handlers['http']\n    @scheme_handlers['file']      = @scheme_handlers['http']\n\n    @http =\n      if defined?(Net::HTTP::Persistent::DEFAULT_POOL_SIZE)\n        Net::HTTP::Persistent.new(name: connection_name)\n      else\n        # net-http-persistent < 3.0\n        Net::HTTP::Persistent.new(connection_name)\n      end\n    @http.idle_timeout = 5\n    @http.keep_alive   = 300\n  end\n\n  ##\n  # Adds credentials +user+, +pass+ for +uri+.  If +realm+ is set the\n  # credentials are used only for that realm.  If +realm+ is not set the\n  # credentials become the default for any realm on that URI.\n  #\n  # +domain+ and +realm+ are exclusive as NTLM does not follow RFC 2617.  If\n  # +domain+ is given it is only used for NTLM authentication.\n\n  def add_auth uri, user, password, realm = nil, domain = nil\n    @auth_store.add_auth uri, user, password, realm, domain\n  end\n\n  ##\n  # USE OF add_default_auth IS NOT RECOMMENDED AS IT MAY EXPOSE PASSWORDS TO\n  # THIRD PARTIES\n  #\n  # Adds credentials +user+, +pass+ as the default authentication credentials.\n  # If no other credentials are available  these will be returned from\n  # credentials_for.\n  #\n  # If +domain+ is given it is only used for NTLM authentication.\n\n  def add_default_auth user, password, domain = nil # :nodoc:\n    @auth_store.add_default_auth user, password, domain\n  end\n\n  ##\n  # Retrieves +uri+ and parses it into a page or other object according to\n  # PluggableParser.  If the URI is an HTTP or HTTPS scheme URI the given HTTP\n  # +method+ is used to retrieve it, along with the HTTP +headers+, request\n  # +params+ and HTTP +referer+.\n  #\n  # The final URI to access is built with +uri+ and +params+, the\n  # latter of which is formatted into a string using\n  # Mechanize::Util.build_query_string, which see.\n  #\n  # +redirects+ tracks the number of redirects experienced when retrieving the\n  # page.  If it is over the redirection_limit an error will be raised.\n\n  def fetch uri, method = :get, headers = {}, params = [],\n            referer = current_page, redirects = 0\n\n    referer_uri = referer ? referer.uri : nil\n    uri         = resolve uri, referer\n    uri, params = resolve_parameters uri, method, params\n    request     = http_request uri, method, params\n    connection  = connection_for uri\n\n    request_auth             request, uri\n    disable_keep_alive       request\n    enable_gzip              request\n    request_language_charset request\n    request_cookies          request, uri\n    request_host             request, uri\n    request_referer          request, uri, referer_uri\n    request_user_agent       request\n    request_add_headers      request, headers\n    pre_connect              request\n\n    # Consult robots.txt\n    if robots && uri.is_a?(URI::HTTP)\n      robots_allowed?(uri) or raise Mechanize::RobotsDisallowedError.new(uri)\n    end\n\n    # Add If-Modified-Since if page is in history\n    if page = visited_page(uri) and last_modified = page.response['Last-Modified']\n      request['If-Modified-Since'] = last_modified\n    end if @conditional_requests\n\n    # Specify timeouts if supplied and our connection supports them\n    if @open_timeout && connection.respond_to?(:open_timeout=)\n      connection.open_timeout = @open_timeout\n    end\n    if @read_timeout && connection.respond_to?(:read_timeout=)\n      connection.read_timeout = @read_timeout\n    end\n\n    request_log request\n\n    response_body_io = nil\n\n    # Send the request\n    begin\n      response = connection.request(uri, request) { |res|\n        response_log res\n\n        response_body_io = response_read res, request, uri\n\n        res\n      }\n    rescue Mechanize::ChunkedTerminationError => e\n      raise unless @ignore_bad_chunking\n\n      response = e.response\n      response_body_io = e.body_io\n    end\n\n    hook_content_encoding response, uri, response_body_io\n\n    response_body_io = response_content_encoding response, response_body_io if\n      request.response_body_permitted?\n\n    post_connect uri, response, response_body_io\n\n    page = response_parse response, response_body_io, uri\n\n    response_cookies response, uri, page\n\n    meta = response_follow_meta_refresh response, uri, page, redirects\n    return meta if meta\n\n    if robots && page.is_a?(Mechanize::Page)\n      page.parser.noindex? and raise Mechanize::RobotsDisallowedError.new(uri)\n    end\n\n    case response\n    when Net::HTTPSuccess\n      page\n    when Mechanize::FileResponse\n      page\n    when Net::HTTPNotModified\n      log.debug(\"Got cached page\") if log\n      visited_page(uri) || page\n    when Net::HTTPRedirection\n      response_redirect response, method, page, redirects, headers, referer\n    when Net::HTTPUnauthorized\n      response_authenticate(response, page, uri, request, headers, params,\n                            referer)\n    else\n      if @allowed_error_codes.any? {|code| code.to_s == page.code} then\n        page\n      else\n        raise Mechanize::ResponseCodeError.new(page, 'unhandled response')\n      end\n    end\n  end\n\n  # URI for a proxy connection\n\n  def proxy_uri\n    @http.proxy_uri\n  end\n\n  # Retry non-idempotent requests?\n  def retry_change_requests\n    @http.retry_change_requests\n  end\n\n  # Retry non-idempotent requests\n\n  def retry_change_requests= retri\n    @http.retry_change_requests = retri\n  end\n\n  # :section: Headers\n\n  def user_agent= user_agent\n    @webrobots = nil if user_agent != @user_agent\n    @user_agent = user_agent\n  end\n\n  # :section: History\n\n  # Equivalent to the browser back button.  Returns the most recent page\n  # visited.\n  def back\n    @history.pop\n  end\n\n  ##\n  # Returns the latest page loaded by the agent\n\n  def current_page\n    @history.last\n  end\n\n  # Returns the maximum size for the history stack.\n  def max_history\n    @history.max_size\n  end\n\n  # Set the maximum size for the history stack.\n  def max_history=(length)\n    @history.max_size = length\n  end\n\n  # Returns a visited page for the url passed in, otherwise nil\n  def visited_page url\n    @history.visited_page resolve url\n  end\n\n  # :section: Hooks\n\n  def hook_content_encoding response, uri, response_body_io\n    @content_encoding_hooks.each do |hook|\n      hook.call self, uri, response, response_body_io\n    end\n  end\n\n  ##\n  # Invokes hooks added to post_connect_hooks after a +response+ is returned\n  # and the response +body+ is handled.\n  #\n  # Yields the +context+, the +uri+ for the request, the +response+ and the\n  # response +body+.\n\n  def post_connect uri, response, body_io # :yields: agent, uri, response, body\n    @post_connect_hooks.each do |hook|\n      begin\n        hook.call self, uri, response, body_io.read\n      ensure\n        body_io.rewind\n      end\n    end\n  end\n\n  ##\n  # Invokes hooks added to pre_connect_hooks before a +request+ is made.\n  # Yields the +agent+ and the +request+ that will be performed to each hook.\n\n  def pre_connect request # :yields: agent, request\n    @pre_connect_hooks.each do |hook|\n      hook.call self, request\n    end\n  end\n\n  # :section: Request\n\n  def connection_for uri\n    case uri.scheme.downcase\n    when 'http', 'https' then\n      return @http\n    when 'file' then\n      return Mechanize::FileConnection.new\n    end\n  end\n\n  # Closes all open connections for this agent.\n  def shutdown\n    http.shutdown\n  end\n\n  ##\n  # Decodes a gzip-encoded +body_io+.  If it cannot be decoded, inflate is\n  # tried followed by raising an error.\n\n  def content_encoding_gunzip body_io\n    log.debug('gzip response') if log\n\n    zio = Zlib::GzipReader.new body_io\n    out_io = auto_io 'mechanize-gunzip', 16384, zio\n    zio.finish\n\n    return out_io\n  rescue Zlib::Error => gz_error\n    log.warn \"unable to gunzip response: #{gz_error} (#{gz_error.class})\" if\n      log\n\n    body_io.rewind\n    body_io.read 10\n\n    begin\n      log.warn \"trying raw inflate on response\" if log\n      return inflate body_io, -Zlib::MAX_WBITS\n    rescue Zlib::Error => e\n      log.error \"unable to inflate response: #{e} (#{e.class})\" if log\n      raise\n    end\n  ensure\n    # do not close a second time if we failed the first time\n    zio.close if zio and !(zio.closed? or gz_error)\n    body_io.close unless body_io.closed?\n  end\n\n  ##\n  # Decodes a deflate-encoded +body_io+.  If it cannot be decoded, raw inflate\n  # is tried followed by raising an error.\n\n  def content_encoding_inflate body_io\n    log.debug('deflate body') if log\n\n    return inflate body_io\n  rescue Zlib::Error\n    log.error('unable to inflate response, trying raw deflate') if log\n\n    body_io.rewind\n\n    begin\n      return inflate body_io, -Zlib::MAX_WBITS\n    rescue Zlib::Error => e\n      log.error(\"unable to inflate response: #{e}\") if log\n      raise\n    end\n  ensure\n    body_io.close\n  end\n\n  def disable_keep_alive request\n    request['connection'] = 'close' unless @keep_alive\n  end\n\n  def enable_gzip request\n    request['accept-encoding'] = if @gzip_enabled\n                                   'gzip,deflate,identity'\n                                 else\n                                   'identity'\n                                 end\n  end\n\n  def http_request uri, method, params = nil\n    case uri.scheme.downcase\n    when 'http', 'https' then\n      klass = Net::HTTP.const_get(method.to_s.capitalize)\n\n      request ||= klass.new(uri.request_uri)\n      request.body = params.first if params\n\n      request\n    when 'file' then\n      Mechanize::FileRequest.new uri\n    end\n  end\n\n  def request_add_headers request, headers = {}\n    @request_headers.each do |k,v|\n      request[k] = v\n    end\n\n    headers.each do |field, value|\n      case field\n      when :etag              then request[\"ETag\"] = value\n      when :if_modified_since then request[\"If-Modified-Since\"] = value\n      when Symbol then\n        raise ArgumentError, \"unknown header symbol #{field}\"\n      else\n        request[field] = value\n      end\n    end\n  end\n\n  def request_auth request, uri\n    base_uri = uri + '/'\n    base_uri.user     &&= nil\n    base_uri.password &&= nil\n    schemes = @authenticate_methods[base_uri]\n\n    if realm = schemes[:digest].find { |r| r.uri == base_uri } then\n      request_auth_digest request, uri, realm, base_uri, false\n    elsif realm = schemes[:iis_digest].find { |r| r.uri == base_uri } then\n      request_auth_digest request, uri, realm, base_uri, true\n    elsif realm = schemes[:basic].find { |r| r.uri == base_uri } then\n      user, password, = @auth_store.credentials_for uri, realm.realm\n      request.basic_auth user, password\n    end\n  end\n\n  def request_auth_digest request, uri, realm, base_uri, iis\n    challenge = @digest_challenges[realm]\n\n    uri.user, uri.password, = @auth_store.credentials_for uri, realm.realm\n\n    auth = @digest_auth.auth_header uri, challenge.to_s, request.method, iis\n    request['Authorization'] = auth\n  end\n\n  def request_cookies request, uri\n    return if @cookie_jar.empty? uri\n\n    cookies = @cookie_jar.cookies uri\n\n    return if cookies.empty?\n\n    request.add_field 'Cookie', cookies.join('; ')\n  end\n\n  def request_host request, uri\n    port = [80, 443].include?(uri.port.to_i) ? nil : uri.port\n    host = uri.host\n\n    request['Host'] = [host, port].compact.join ':'\n  end\n\n  def request_language_charset request\n    request['accept-charset']  = 'ISO-8859-1,utf-8;q=0.7,*;q=0.7'\n    request['accept-language'] = 'en-us,en;q=0.5'\n  end\n\n  # Log specified headers for the request\n  def request_log request\n    return unless log\n\n    log.info(\"#{request.class}: #{request.path}\")\n\n    request.each_header do |k, v|\n      log.debug(\"request-header: #{k} => #{v}\")\n    end\n  end\n\n  # Sets a Referer header.  Fragment part is removed as demanded by\n  # RFC 2616 14.36, and user information part is removed just like\n  # major browsers do.\n  def request_referer request, uri, referer\n    return unless referer\n    return if 'https'.casecmp(referer.scheme) == 0 and\n              'https'.casecmp(uri.scheme) != 0\n    if referer.fragment || referer.user || referer.password\n      referer = referer.dup\n      referer.fragment = referer.user = referer.password = nil\n    end\n    request['Referer'] = referer\n  end\n\n  def request_user_agent request\n    request['User-Agent'] = @user_agent if @user_agent\n  end\n\n  def resolve(uri, referer = current_page)\n    referer_uri = referer && referer.uri\n    if uri.is_a?(URI)\n      uri = uri.dup\n    elsif uri.nil?\n      if referer_uri\n        return referer_uri\n      end\n      raise ArgumentError, \"absolute URL needed (not nil)\"\n    else\n      url = uri.to_s.strip\n      if url.empty?\n        if referer_uri\n          return referer_uri.dup.tap { |u| u.fragment = nil }\n        end\n        raise ArgumentError, \"absolute URL needed (not #{uri.inspect})\"\n      end\n\n      url.gsub!(/[^#{0.chr}-#{126.chr}]/o) { |match|\n        Mechanize::Util.uri_escape(match)\n      }\n\n      escaped_url = Mechanize::Util.html_unescape(\n        url.split(/((?:%[0-9A-Fa-f]{2})+|#)/).each_slice(2).map { |x, y|\n          \"#{WEBrick::HTTPUtils.escape(x)}#{y}\"\n        }.join('')\n      )\n\n      begin\n        uri = URI.parse(escaped_url)\n      rescue\n        uri = URI.parse(WEBrick::HTTPUtils.escape(escaped_url))\n      end\n    end\n\n    uri.host = referer_uri.host if referer_uri && URI::HTTP === uri && uri.host.nil?\n\n    scheme = uri.relative? ? 'relative' : uri.scheme.downcase\n    uri = @scheme_handlers[scheme].call(uri, referer)\n\n    if uri.relative?\n      raise ArgumentError, \"absolute URL needed (not #{uri})\" unless\n        referer_uri\n\n      if referer.respond_to?(:bases) && referer.parser &&\n          (lbase = referer.bases.last) && lbase.uri && lbase.uri.absolute?\n        base = lbase\n      else\n        base = nil\n      end\n\n      base = referer_uri + (base ? base.uri : referer_uri)\n\n      # Workaround for URI's bug in that it squashes consecutive\n      # slashes.  See #304.\n      if uri.path.match(%r{\\A(.*?/)(?!/\\.\\.?(?!/))(/.*)\\z}i)\n        uri = URI((base + $1).to_s + $2)\n      else\n        uri = base + uri\n      end\n\n      # Strip initial \"/..\" bits from the path\n      uri.path.sub!(/^(\\/\\.\\.)+(?=\\/)/, '')\n    end\n\n    unless ['http', 'https', 'file'].include?(uri.scheme.downcase)\n      raise ArgumentError, \"unsupported scheme: #{uri.scheme}\"\n    end\n\n    case uri.path\n    when nil\n      raise ArgumentError, \"hierarchical URL needed (not #{uri})\"\n    when ''.freeze\n      uri.path = '/'\n    end\n\n    uri\n  end\n\n  def secure_resolve!(uri, referer = current_page)\n    new_uri = resolve(uri, referer)\n\n    if (referer_uri = referer && referer.uri) &&\n       referer_uri.scheme != 'file'.freeze &&\n       new_uri.scheme == 'file'.freeze\n      raise Mechanize::Error, \"insecure redirect to a file URI\"\n    end\n\n    new_uri\n  end\n\n  def resolve_parameters uri, method, parameters\n    case method\n    when :head, :get, :delete, :trace then\n      if parameters and parameters.length > 0\n        uri.query ||= ''\n        uri.query << '&' if uri.query.length > 0\n        uri.query << Mechanize::Util.build_query_string(parameters)\n      end\n\n      return uri, nil\n    end\n\n    return uri, parameters\n  end\n\n  # :section: Response\n\n  def get_meta_refresh response, uri, page\n    return nil unless @follow_meta_refresh\n\n    if page.respond_to?(:meta_refresh) and\n       (redirect = page.meta_refresh.first) then\n      [redirect.delay, redirect.href] unless\n        not @follow_meta_refresh_self and redirect.link_self\n    elsif refresh = response['refresh']\n      delay, href, link_self = Mechanize::Page::MetaRefresh.parse refresh, uri\n      raise Mechanize::Error, 'Invalid refresh http header' unless delay\n      [delay.to_f, href] unless\n        not @follow_meta_refresh_self and link_self\n    end\n  end\n\n  def response_authenticate(response, page, uri, request, headers, params,\n                            referer)\n    www_authenticate = response['www-authenticate']\n\n    unless www_authenticate = response['www-authenticate'] then\n      message = 'WWW-Authenticate header missing in response'\n      raise Mechanize::UnauthorizedError.new(page, nil, message)\n    end\n\n    challenges = @authenticate_parser.parse www_authenticate\n\n    unless @auth_store.credentials? uri, challenges then\n      message = \"no credentials found, provide some with #add_auth\"\n      raise Mechanize::UnauthorizedError.new(page, challenges, message)\n    end\n\n    if challenge = challenges.find { |c| c.scheme =~ /^Digest$/i } then\n      realm = challenge.realm uri\n\n      auth_scheme = if response['server'] =~ /Microsoft-IIS/ then\n                      :iis_digest\n                    else\n                      :digest\n                    end\n\n      existing_realms = @authenticate_methods[realm.uri][auth_scheme]\n\n      if existing_realms.include? realm\n        message = 'Digest authentication failed'\n        raise Mechanize::UnauthorizedError.new(page, challenges, message)\n      end\n\n      existing_realms << realm\n      @digest_challenges[realm] = challenge\n    elsif challenge = challenges.find { |c| c.scheme == 'NTLM' } then\n      existing_realms = @authenticate_methods[uri + '/'][:ntlm]\n\n      if existing_realms.include?(realm) and not challenge.params then\n        message = 'NTLM authentication failed'\n        raise Mechanize::UnauthorizedError.new(page, challenges, message)\n      end\n\n      existing_realms << realm\n\n      if challenge.params then\n        type_2 = Net::NTLM::Message.decode64 challenge.params\n\n        user, password, domain = @auth_store.credentials_for uri, nil\n\n        type_3 = type_2.response({ :user => user, :password => password,\n                                   :domain => domain },\n                                 { :ntlmv2 => true }).encode64\n\n        headers['Authorization'] = \"NTLM #{type_3}\"\n      else\n        type_1 = Net::NTLM::Message::Type1.new.encode64\n        headers['Authorization'] = \"NTLM #{type_1}\"\n      end\n    elsif challenge = challenges.find { |c| c.scheme == 'Basic' } then\n      realm = challenge.realm uri\n\n      existing_realms = @authenticate_methods[realm.uri][:basic]\n\n      if existing_realms.include? realm then\n        message = 'Basic authentication failed'\n        raise Mechanize::UnauthorizedError.new(page, challenges, message)\n      end\n\n      existing_realms << realm\n    else\n      message = 'unsupported authentication scheme'\n      raise Mechanize::UnauthorizedError.new(page, challenges, message)\n    end\n\n    fetch uri, request.method.downcase.to_sym, headers, params, referer\n  end\n\n  def response_content_encoding response, body_io\n    length = response.content_length ||\n      case body_io\n      when Tempfile, IO then\n        body_io.stat.size\n      else\n        body_io.length\n      end\n\n    return body_io if length.zero?\n\n    out_io = case response['Content-Encoding']\n             when nil, 'none', '7bit', 'identity', \"\" then\n               body_io\n             when 'deflate' then\n               content_encoding_inflate body_io\n             when 'gzip', 'x-gzip' then\n               content_encoding_gunzip body_io\n             else\n               raise Mechanize::Error,\n                 \"unsupported content-encoding: #{response['Content-Encoding']}\"\n             end\n\n    out_io.flush\n    out_io.rewind\n\n    out_io\n  rescue Zlib::Error => e\n    message = String.new(\"error handling content-encoding #{response['Content-Encoding']}:\")\n    message << \" #{e.message} (#{e.class})\"\n    raise Mechanize::Error, message\n  ensure\n    begin\n      if Tempfile === body_io and\n         (StringIO === out_io or (out_io and out_io.path != body_io.path)) then\n        body_io.close!\n      end\n    rescue IOError\n      # HACK ruby 1.8 raises IOError when closing the stream\n    end\n  end\n\n  def response_cookies response, uri, page\n    if Mechanize::Page === page and page.body =~ /Set-Cookie/n\n      page.search('//head/meta[@http-equiv=\"Set-Cookie\"]').each do |meta|\n        save_cookies(uri, meta['content'])\n      end\n    end\n\n    header_cookies = response.get_fields 'Set-Cookie'\n\n    return unless header_cookies\n\n    header_cookies.each do |set_cookie|\n      save_cookies(uri, set_cookie)\n    end\n  end\n\n  def save_cookies(uri, set_cookie)\n    return [] if set_cookie.nil?\n    if log = log()\t # reduce method calls\n      @cookie_jar.parse(set_cookie, uri, :logger => log) { |c|\n        log.debug(\"saved cookie: #{c}\")\n        true\n      }\n    else\n      @cookie_jar.parse(set_cookie, uri)\n    end\n  end\n\n  def response_follow_meta_refresh response, uri, page, redirects\n    delay, new_url = get_meta_refresh(response, uri, page)\n    return nil unless delay\n    new_url = new_url ? secure_resolve!(new_url, page) : uri\n\n    raise Mechanize::RedirectLimitReachedError.new(page, redirects) if\n      redirects + 1 > @redirection_limit\n\n    sleep delay\n    @history.push(page, page.uri)\n    fetch new_url, :get, {}, [],\n          Mechanize::Page.new, redirects + 1\n  end\n\n  def response_log response\n    return unless log\n\n    log.info(\"status: #{response.class} #{response.http_version} \" \\\n             \"#{response.code} #{response.message}\")\n\n    response.each_header do |k, v|\n      log.debug(\"response-header: #{k} => #{v}\")\n    end\n  end\n\n  def response_parse response, body_io, uri\n    @context.parse uri, response, body_io\n  end\n\n  def response_read response, request, uri\n    content_length = response.content_length\n\n    if use_tempfile? content_length then\n      body_io = make_tempfile 'mechanize-raw'\n    else\n      body_io = StringIO.new.set_encoding(Encoding::BINARY)\n    end\n\n    total = 0\n\n    begin\n      response.read_body { |part|\n        total += part.length\n\n        if StringIO === body_io and use_tempfile? total then\n          new_io = make_tempfile 'mechanize-raw'\n\n          new_io.write body_io.string\n\n          body_io = new_io\n        end\n\n        body_io.write(part)\n        log.debug(\"Read #{part.length} bytes (#{total} total)\") if log\n      }\n    rescue EOFError => e\n      # terminating CRLF might be missing, let the user check the document\n      raise unless response.chunked? and total.nonzero?\n\n      body_io.rewind\n      raise Mechanize::ChunkedTerminationError.new(e, response, body_io, uri,\n                                                   @context)\n    rescue Net::HTTP::Persistent::Error, Errno::ECONNRESET => e\n      body_io.rewind\n      raise Mechanize::ResponseReadError.new(e, response, body_io, uri,\n                                             @context)\n    end\n\n    body_io.flush\n    body_io.rewind\n\n    raise Mechanize::ResponseCodeError.new(response, uri) if\n      Net::HTTPUnknownResponse === response\n\n    content_length = response.content_length\n\n    unless Net::HTTP::Head === request or Net::HTTPRedirection === response then\n      if content_length and content_length != body_io.length\n        err = EOFError.new(\"Content-Length (#{content_length}) does not \" \\\n                      \"match response body length (#{body_io.length})\")\n        raise Mechanize::ResponseReadError.new(err, response, body_io, uri,\n                                                @context)\n      end\n    end\n\n    body_io\n  end\n\n  def response_redirect(response, method, page, redirects, headers,\n                        referer = current_page)\n    case @redirect_ok\n    when true, :all\n      # shortcut\n    when false, nil\n      return page\n    when :permanent\n      return page unless Net::HTTPMovedPermanently === response\n    end\n\n    log.info(\"follow redirect to: #{response['Location']}\") if log\n\n    raise Mechanize::RedirectLimitReachedError.new(page, redirects) if\n      redirects + 1 > @redirection_limit\n\n    redirect_method = method == :head ? :head : :get\n\n    new_uri = secure_resolve!(response['Location'].to_s, page)\n    @history.push(page, page.uri)\n\n    # Make sure we are not copying over the POST headers from the original request\n    POST_HEADERS.each do |key|\n      headers.delete_if { |h| h.casecmp?(key) }\n    end\n\n    # Make sure we clear credential headers if being redirected to another site\n    if new_uri.host != page.uri.host\n      CREDENTIAL_HEADERS.each do |ch|\n        headers.delete_if { |h| h.casecmp?(ch) }\n      end\n    end\n\n    fetch new_uri, redirect_method, headers, [], referer, redirects + 1\n  end\n\n  # :section: Robots\n\n  RobotsKey = :__mechanize_get_robots__\n\n  def get_robots(uri) # :nodoc:\n    robots_mutex.synchronize do\n      Thread.current[RobotsKey] = true\n      begin\n        fetch(uri).body\n      rescue Mechanize::ResponseCodeError => e\n        case e.response_code\n        when /\\A4\\d\\d\\z/\n          ''\n        else\n          raise e\n        end\n      rescue Mechanize::RedirectLimitReachedError\n        ''\n      ensure\n        Thread.current[RobotsKey] = false\n      end\n    end\n  end\n\n  def robots= value\n    require 'webrobots' if value\n    @webrobots = nil if value != @robots\n    @robots = value\n  end\n\n  ##\n  # Tests if this agent is allowed to access +url+, consulting the site's\n  # robots.txt.\n\n  def robots_allowed? uri\n    return true if Thread.current[RobotsKey]\n\n    webrobots.allowed? uri\n  end\n\n  # Opposite of robots_allowed?\n\n  def robots_disallowed? url\n    !robots_allowed? url\n  end\n\n  # Returns an error object if there is an error in fetching or parsing\n  # robots.txt of the site +url+.\n  def robots_error(url)\n    webrobots.error(url)\n  end\n\n  # Raises the error if there is an error in fetching or parsing robots.txt of\n  # the site +url+.\n  def robots_error!(url)\n    webrobots.error!(url)\n  end\n\n  # Removes robots.txt cache for the site +url+.\n  def robots_reset(url)\n    webrobots.reset(url)\n  end\n\n  def webrobots\n    @webrobots ||= WebRobots.new(@user_agent, :http_get => method(:get_robots))\n  end\n\n  # :section: SSL\n\n  # Path to an OpenSSL CA certificate file\n  def ca_file\n    @http.ca_file\n  end\n\n  # Sets the path to an OpenSSL CA certificate file\n  def ca_file= ca_file\n    @http.ca_file = ca_file\n  end\n\n  # The SSL certificate store used for validating connections\n  def cert_store\n    @http.cert_store\n  end\n\n  # Sets the SSL certificate store used for validating connections\n  def cert_store= cert_store\n    @http.cert_store = cert_store\n  end\n\n  # The client X509 certificate\n  def certificate\n    @http.certificate\n  end\n\n  # Sets the client certificate to given X509 certificate.  If a path is given\n  # the certificate will be loaded and set.\n  def certificate= certificate\n    certificate = if OpenSSL::X509::Certificate === certificate then\n                    certificate\n                  else\n                    OpenSSL::X509::Certificate.new File.read certificate\n                  end\n\n    @http.certificate = certificate\n  end\n\n  # An OpenSSL private key or the path to a private key\n  def private_key\n    @http.private_key\n  end\n\n  # Sets the client's private key\n  def private_key= private_key\n    private_key = if OpenSSL::PKey::PKey === private_key then\n                    private_key\n                  else\n                    OpenSSL::PKey::RSA.new File.read(private_key), @pass\n                  end\n\n    @http.private_key = private_key\n  end\n\n  # SSL version to use\n  def ssl_version\n    @http.ssl_version\n  end\n\n  # Sets the SSL version to use\n  def ssl_version= ssl_version\n    @http.ssl_version = ssl_version\n  end\n\n  # A callback for additional certificate verification.  See\n  # OpenSSL::SSL::SSLContext#verify_callback\n  #\n  # The callback can be used for debugging or to ignore errors by always\n  # returning +true+.  Specifying nil uses the default method that was valid\n  # when the SSLContext was created\n  def verify_callback\n    @http.verify_callback\n  end\n\n  # Sets the certificate verify callback\n  def verify_callback= verify_callback\n    @http.verify_callback = verify_callback\n  end\n\n  # How to verify SSL connections.  Defaults to VERIFY_PEER\n  def verify_mode\n    @http.verify_mode\n  end\n\n  # Sets the mode for verifying SSL connections\n  def verify_mode= verify_mode\n    @http.verify_mode = verify_mode\n  end\n\n  # :section: Timeouts\n\n  # Reset connections that have not been used in this many seconds\n  def idle_timeout\n    @http.idle_timeout\n  end\n\n  # Sets the connection idle timeout for persistent connections\n  def idle_timeout= timeout\n    @http.idle_timeout = timeout\n  end\n\n  # :section: Utility\n\n  ##\n  # Creates a new output IO by reading +input_io+ in +read_size+ chunks.  If\n  # the output is over the max_file_buffer size a Tempfile with +name+ is\n  # created.\n  #\n  # If a block is provided, each chunk of +input_io+ is yielded for further\n  # processing.\n\n  def auto_io name, read_size, input_io\n    out_io = StringIO.new.set_encoding(Encoding::BINARY)\n\n    until input_io.eof? do\n      if StringIO === out_io and use_tempfile? out_io.size then\n        new_io = make_tempfile name\n        new_io.write out_io.string\n        out_io = new_io\n      end\n\n      chunk = input_io.read read_size\n      chunk = yield chunk if block_given?\n\n      out_io.write chunk\n    end\n\n    out_io.rewind\n\n    out_io\n  end\n\n  def inflate compressed, window_bits = nil\n    inflate = Zlib::Inflate.new window_bits\n\n    out_io = auto_io 'mechanize-inflate', 1024, compressed do |chunk|\n      inflate.inflate chunk\n    end\n\n    inflate.finish\n\n    out_io\n  ensure\n    inflate.close if inflate.finished?\n  end\n\n  def log\n    @context.log\n  end\n\n  ##\n  # Sets the proxy address, port, user, and password. +addr+ may be\n  # an HTTP URL/URI or a host name, +port+ may be a port number, service\n  # name or port number string.\n\n  def set_proxy addr, port = nil, user = nil, pass = nil\n    case addr\n    when URI::HTTP\n      proxy_uri = addr.dup\n    when %r{\\Ahttps?://}i\n      proxy_uri = URI addr\n    when String\n      proxy_uri = URI \"http://#{addr}\"\n    when nil\n      @http.proxy = nil\n      return\n    end\n\n    case port\n    when Integer\n      proxy_uri.port = port\n    when nil\n    else\n      begin\n        proxy_uri.port = Socket.getservbyname port\n      rescue SocketError\n        begin\n          proxy_uri.port = Integer port\n        rescue ArgumentError\n          raise ArgumentError, \"invalid value for port: #{port.inspect}\"\n        end\n      end\n    end\n\n    proxy_uri.user     = user if user\n    proxy_uri.password = pass if pass\n\n    @http.proxy = proxy_uri\n  end\n\n  def make_tempfile name\n    io = Tempfile.new name\n    io.unlink\n    io.binmode\n    io\n  end\n\n  def use_tempfile? size\n    return false unless @max_file_buffer\n    return false unless size\n\n    size >= @max_file_buffer\n  end\n\n  def reset\n    @cookie_jar.clear\n    @history.clear\n  end\n\nend\n\nrequire 'mechanize/http/auth_store'\n", "# coding: utf-8\n\nrequire 'mechanize/test_case'\n\nclass TestMechanizeHttpAgent < Mechanize::TestCase\n\n  def setup\n    super\n\n    @agent = @mech.agent\n\n    @uri = URI.parse 'http://example/'\n\n    @req = Net::HTTP::Get.new '/'\n    @res = Net::HTTPOK.allocate\n    @res.instance_variable_set :@code, 200\n    @res.instance_variable_set :@header, {}\n\n    @headers = %w[accept accept-encoding user-agent]\n  end\n\n  def auth_realm uri, scheme, type\n    base_uri = uri + '/'\n    realm = Mechanize::HTTP::AuthRealm.new scheme, base_uri, 'r'\n    @agent.authenticate_methods[base_uri][type] << realm\n\n    realm\n  end\n\n  def jruby_zlib?\n    if RUBY_ENGINE == 'jruby'\n      meth = caller[0][/`(\\w+)/, 1]\n      warn \"#{meth}: skipped because how Zlib handles error is different in JRuby\"\n      true\n    else\n      false\n    end\n  end\n\n  def test_agent_is_named\n    assert_equal 'mechanize', Mechanize::HTTP::Agent.new.http.name\n    assert_equal 'unique', Mechanize::HTTP::Agent.new('unique').http.name\n  end\n\n  def test_auto_io\n    Tempfile.open 'input' do |input_io|\n      input_io.binmode\n      input_io.write '12345'\n      input_io.rewind\n\n      out_io = @agent.auto_io @NAME, 1024, input_io\n\n      assert_equal '12345', out_io.string\n\n      assert_equal Encoding::BINARY, out_io.string.encoding if\n        Object.const_defined? :Encoding\n    end\n  end\n\n  def test_auto_io_chunk\n    Tempfile.open 'input' do |input_io|\n      chunks = []\n\n      input_io.binmode\n      input_io.write '12345'\n      input_io.rewind\n\n      @agent.auto_io @NAME, 1, input_io do |chunk|\n        chunks << chunk\n      end\n\n      assert_equal %w[1 2 3 4 5], chunks\n    end\n  end\n\n  def test_auto_io_tempfile\n    @agent.max_file_buffer = 3\n\n    Tempfile.open 'input' do |input_io|\n      input_io.binmode\n      input_io.write '12345'\n      input_io.rewind\n\n      out_io = @agent.auto_io @NAME, 1, input_io\n\n      result = out_io.read\n      assert_equal '12345', result\n\n      assert_equal Encoding::BINARY, result.encoding if\n        Object.const_defined? :Encoding\n    end\n  end\n\n  def test_auto_io_yield\n    Tempfile.open 'input' do |input_io|\n      input_io.binmode\n      input_io.write '12345'\n      input_io.rewind\n\n      out_io = @agent.auto_io @NAME, 1024, input_io do |chunk|\n        \"x#{chunk}\"\n      end\n\n      assert_equal 'x12345', out_io.string\n    end\n  end\n\n  def test_certificate_equals\n    cert_path = File.expand_path '../data/server.crt', __FILE__\n    cert = OpenSSL::X509::Certificate.new File.read cert_path\n\n    @agent.certificate = cert\n\n    assert_equal cert.to_pem, @agent.certificate.to_pem\n  end\n\n  def test_certificate_equals_file\n    cert_path = File.expand_path '../data/server.crt', __FILE__\n\n    cert = OpenSSL::X509::Certificate.new File.read cert_path\n\n    @agent.certificate = cert_path\n\n    assert_equal cert.to_pem, @agent.certificate.to_pem\n  end\n\n  def test_connection_for_file\n    uri = URI.parse 'file:///nonexistent'\n    conn = @agent.connection_for uri\n\n    assert_equal Mechanize::FileConnection.new, conn\n  end\n\n  def test_connection_for_http\n    conn = @agent.connection_for @uri\n\n    assert_equal @agent.http, conn\n  end\n\n  def test_disable_keep_alive\n    @agent.disable_keep_alive @req\n\n    refute @req['connection']\n  end\n\n  def test_disable_keep_alive_no\n    @agent.keep_alive = false\n\n    @agent.disable_keep_alive @req\n\n    assert_equal 'close', @req['connection']\n  end\n\n  def test_enable_gzip\n    @agent.enable_gzip @req\n\n    assert_equal 'gzip,deflate,identity', @req['accept-encoding']\n  end\n\n  def test_enable_gzip_no\n    @agent.gzip_enabled = false\n\n    @agent.enable_gzip @req\n\n    assert_equal 'identity', @req['accept-encoding']\n  end\n\n  def test_fetch_file_nonexistent\n    in_tmpdir do\n      nonexistent = File.join Dir.pwd, 'nonexistent'\n\n      uri = URI.parse \"file:///#{nonexistent}\"\n\n      e = assert_raises Mechanize::ResponseCodeError do\n        @agent.fetch uri\n      end\n\n      assert_match \"404 => Net::HTTPNotFound for #{uri}\", e.message\n    end\n  end\n\n  def test_fetch_file_plus\n    Tempfile.open '++plus++' do |io|\n      content = 'plusses +++'\n      io.write content\n      io.rewind\n\n      uri = URI.parse \"file://#{Mechanize::Util.uri_escape io.path}\"\n\n      page = @agent.fetch uri\n\n      assert_equal content, page.body\n      assert_kind_of Mechanize::File, page\n    end\n  end\n\n  def test_fetch_file_space\n    foo = File.expand_path(\"../htdocs/dir with spaces/foo.html\", __FILE__)\n\n    uri = URI.parse \"file://#{Mechanize::Util.uri_escape foo}\"\n\n    page = @agent.fetch uri\n\n    assert_equal File.read(foo), page.body.gsub(/\\r\\n/, \"\\n\")\n    assert_kind_of Mechanize::Page, page\n  end\n\n  def test_fetch_head_gzip\n    uri = @uri + '/gzip?file=index.html'\n\n    page = @agent.fetch uri, :head\n\n    assert_kind_of Mechanize::Page, page\n  end\n\n  def test_fetch_hooks\n    @agent.pre_connect_hooks << proc do |agent, request|\n      assert_equal '/index.html', request.path\n      assert_equal @agent, agent\n    end\n\n    @agent.post_connect_hooks << proc do |agent, uri, response, body|\n      assert_equal @agent, agent\n      assert_equal URI('http://example/index.html'), uri\n      assert_equal '200', response.code\n      assert_kind_of String, body\n    end\n\n    @agent.fetch URI 'http://example/index.html'\n  end\n\n  def test_fetch_ignore_bad_chunking\n    @agent.ignore_bad_chunking = true\n\n    file = @agent.fetch 'http://example/bad_chunking'\n\n    assert_equal '0123456789', file.content\n  end\n\n  def test_fetch_post_connect_hook\n    response = nil\n    @agent.post_connect_hooks << lambda { |_, _, res, _| response = res }\n\n    @agent.fetch 'http://localhost/'\n\n    assert response\n  end\n\n  def test_fetch_redirect_header\n    page = @agent.fetch('http://example/redirect', :get,\n                        'X-Location' => '/http_headers',\n                        'Range' => 'bytes=0-99999')\n\n    assert_match 'range|bytes=0-999', page.body\n  end\n\n  def test_fetch_server_error\n    e = assert_raises Mechanize::ResponseCodeError do\n      @mech.get 'http://localhost/response_code?code=500'\n    end\n\n    assert_equal '500', e.response_code\n  end\n\n  def test_fetch_allowed_error_codes\n    @agent.allowed_error_codes = ['500']\n\n    page = @mech.get 'http://localhost/response_code?code=500'\n\n    assert_equal '500', page.code\n  end\n\n  def test_fetch_allowed_error_codes_int\n    @agent.allowed_error_codes = [500]\n\n    page = @mech.get 'http://localhost/response_code?code=500'\n\n    assert_equal '500', page.code\n  end\n\n  def test_get_meta_refresh_header_follow_self\n    @agent.follow_meta_refresh = true\n    @agent.follow_meta_refresh_self = true\n\n    page = Mechanize::Page.new(@uri, nil, '', 200, @mech)\n    @res.instance_variable_set :@header, 'refresh' => ['0']\n\n    refresh = @agent.get_meta_refresh @res, @uri, page\n\n    assert_equal [0.0, URI('http://example/')], refresh\n  end\n\n  def test_get_meta_refresh_header_no_follow\n    page = Mechanize::Page.new(@uri, nil, '', 200, @mech)\n    @res.instance_variable_set :@header, 'refresh' => ['0']\n\n    refresh = @agent.get_meta_refresh @res, @uri, page\n\n    assert_nil refresh\n  end\n\n  def test_get_meta_refresh_header_no_follow_self\n    @agent.follow_meta_refresh = true\n\n    page = Mechanize::Page.new(@uri, nil, '', 200, @mech)\n    @res.instance_variable_set :@header, 'refresh' => ['0']\n\n    refresh = @agent.get_meta_refresh @res, @uri, page\n\n    assert_nil refresh\n  end\n\n  def test_get_meta_refresh_meta_follow_self\n    @agent.follow_meta_refresh = true\n    @agent.follow_meta_refresh_self = true\n\n    body = <<-BODY\n<title></title>\n<meta http-equiv=\"refresh\" content=\"0\">\n    BODY\n\n    page = Mechanize::Page.new(@uri, nil, body, 200, @mech)\n\n    refresh = @agent.get_meta_refresh @res, @uri, page\n\n    assert_equal [0, nil], refresh\n  end\n\n  def test_get_meta_refresh_meta_no_follow\n    body = <<-BODY\n<title></title>\n<meta http-equiv=\"refresh\" content=\"0\">\n    BODY\n\n    page = Mechanize::Page.new(@uri, nil, body, 200, @mech)\n\n    refresh = @agent.get_meta_refresh @res, @uri, page\n\n    assert_nil refresh\n  end\n\n  def test_get_meta_refresh_meta_no_follow_self\n    @agent.follow_meta_refresh = true\n\n    body = <<-BODY\n<title></title>\n<meta http-equiv=\"refresh\" content=\"0\">\n    BODY\n\n    page = Mechanize::Page.new(@uri, nil, body, 200, @mech)\n\n    refresh = @agent.get_meta_refresh @res, @uri, page\n\n    assert_nil refresh\n  end\n\n  def test_get_robots\n    robotstxt = @agent.get_robots 'http://localhost/robots.txt'\n    refute_equal '', robotstxt\n\n    robotstxt = @agent.get_robots 'http://localhost/response_code?code=404'\n    assert_equal '', robotstxt\n  end\n\n  def test_hook_content_encoding_response\n    @mech.content_encoding_hooks << lambda{|agent, uri, response, response_body_io|\n      response['content-encoding'] = 'gzip' if response['content-encoding'] == 'agzip'}\n\n    @res.instance_variable_set :@header, 'content-encoding' => %w[agzip]\n    body_io = StringIO.new 'part'\n    @agent.hook_content_encoding @res, @uri, body_io\n\n    assert_equal 'gzip', @res['content-encoding']\n  end\n\n  def test_http_request_file\n    uri = URI.parse 'file:///nonexistent'\n    request = @agent.http_request uri, :get\n\n    assert_kind_of Mechanize::FileRequest, request\n    assert_equal '/nonexistent', request.path\n  end\n\n  def test_http_request_get\n    request = @agent.http_request @uri, :get\n\n    assert_kind_of Net::HTTP::Get, request\n    assert_equal '/', request.path\n  end\n\n  def test_http_request_post\n    request = @agent.http_request @uri, :post\n\n    assert_kind_of Net::HTTP::Post, request\n    assert_equal '/', request.path\n  end\n\n  def test_idle_timeout_equals\n    @agent.idle_timeout = 1\n\n    assert_equal 1, @agent.http.idle_timeout\n  end\n\n  def test_inflate\n    body_io = StringIO.new \"x\\x9C+H,*\\x01\\x00\\x04?\\x01\\xB8\"\n\n    result = @agent.inflate body_io\n\n    assert_equal 'part', result.read\n  end\n\n  def test_post_connect\n    @agent.post_connect_hooks << proc { |agent, uri, response, body|\n      assert_equal @agent, agent\n      assert_equal @res, response\n      assert_equal 'body', body\n      throw :called\n    }\n\n    io = StringIO.new 'body'\n\n    assert_throws :called do\n      @agent.post_connect @uri, @res, io\n    end\n\n    assert_equal 0, io.pos\n  end\n\n  def test_pre_connect\n    @agent.pre_connect_hooks << proc { |agent, request|\n      assert_equal @agent, agent\n      assert_equal @req, request\n      throw :called\n    }\n\n    assert_throws :called do\n      @agent.pre_connect @req\n    end\n  end\n\n  def test_request_add_headers\n    @agent.request_add_headers @req, 'Content-Length' => 300\n\n    assert_equal '300', @req['content-length']\n  end\n\n  def test_request_add_headers_etag\n    @agent.request_add_headers @req, :etag => '300'\n\n    assert_equal '300', @req['etag']\n  end\n\n  def test_request_add_headers_if_modified_since\n    @agent.request_add_headers @req, :if_modified_since => 'some_date'\n\n    assert_equal 'some_date', @req['if-modified-since']\n  end\n\n  def test_request_add_headers_none\n    @agent.request_add_headers @req\n\n    assert_equal @headers, @req.to_hash.keys.sort\n  end\n\n  def test_request_add_headers_request_headers\n    @agent.request_headers['X-Foo'] = 'bar'\n\n    @agent.request_add_headers @req\n\n    assert_equal @headers + %w[x-foo], @req.to_hash.keys.sort\n  end\n\n  def test_request_add_headers_symbol\n    e = assert_raises ArgumentError do\n      @agent.request_add_headers @req, :content_length => 300\n    end\n\n    assert_equal 'unknown header symbol content_length', e.message\n  end\n\n  def test_request_auth_basic\n    @agent.add_auth @uri, 'user', 'password'\n\n    auth_realm @uri, 'Basic', :basic\n\n    @agent.request_auth @req, @uri\n\n    assert_match %r%^Basic %, @req['Authorization']\n  end\n\n  def test_request_auth_digest\n    @agent.add_auth @uri, 'user', 'password'\n\n    realm = auth_realm @uri, 'Digest', :digest\n    @agent.digest_challenges[realm] = 'Digest realm=r, qop=\"auth\"'\n\n    @agent.request_auth @req, @uri\n\n    assert_match %r%^Digest %, @req['Authorization']\n    assert_match %r%qop=auth%, @req['Authorization']\n\n    @req['Authorization'] = nil\n    @agent.request_auth @req, @uri\n\n    assert_match %r%^Digest %, @req['Authorization']\n    assert_match %r%qop=auth%, @req['Authorization']\n  end\n\n  def test_request_auth_iis_digest\n    @agent.add_auth @uri, 'user', 'password'\n\n    realm = auth_realm @uri, 'Digest', :digest\n    @agent.digest_challenges[realm] = 'Digest realm=r, qop=\"auth\"'\n\n    @agent.request_auth @req, @uri\n\n    assert_match %r%^Digest %, @req['Authorization']\n    assert_match %r%qop=auth%, @req['Authorization']\n  end\n\n  def test_request_auth_none\n    @agent.request_auth @req, @uri\n\n    assert_nil @req['Authorization']\n  end\n\n  def test_request_cookies\n    uri = URI.parse 'http://host.example.com'\n    @agent.cookie_jar.parse 'hello=world domain=.example.com', uri\n\n    @agent.request_cookies @req, uri\n\n    assert_equal 'hello=\"world domain=.example.com\"', @req['Cookie']\n  end\n\n  def test_request_cookies_many\n    uri = URI.parse 'http://host.example.com'\n    cookie_str = 'a=b domain=.example.com, c=d domain=.example.com'\n    @agent.cookie_jar.parse cookie_str, uri\n\n    @agent.request_cookies @req, uri\n\n    expected_variant1 = /a=\"b domain=\\.example\\.com\"; c=\"d domain=\\.example\\.com\"/\n    expected_variant2 = /c=\"d domain=\\.example\\.com\"; a=\"b domain=\\.example\\.com\"/\n\n    assert_match(/^(#{expected_variant1}|#{expected_variant2})$/, @req['Cookie'])\n  end\n\n  def test_request_cookies_none\n    @agent.request_cookies @req, @uri\n\n    assert_nil @req['Cookie']\n  end\n\n  def test_request_cookies_wrong_domain\n    uri = URI.parse 'http://host.example.com'\n    @agent.cookie_jar.parse 'hello=world domain=.example.com', uri\n\n    @agent.request_cookies @req, @uri\n\n    assert_nil @req['Cookie']\n  end\n\n  def test_request_host\n    @agent.request_host @req, @uri\n\n    assert_equal 'example', @req['host']\n  end\n\n  def test_request_host_nonstandard\n    @uri.port = 81\n\n    @agent.request_host @req, @uri\n\n    assert_equal 'example:81', @req['host']\n  end\n\n  def test_request_language_charset\n    @agent.request_language_charset @req\n\n    assert_equal 'en-us,en;q=0.5', @req['accept-language']\n    assert_equal 'ISO-8859-1,utf-8;q=0.7,*;q=0.7', @req['accept-charset']\n  end\n\n  def test_request_referer\n    referer = URI.parse 'http://old.example'\n\n    @agent.request_referer @req, @uri, referer\n\n    assert_equal 'http://old.example', @req['referer']\n  end\n\n  def test_request_referer_https\n    uri = URI.parse 'https://example'\n    referer = URI.parse 'https://old.example'\n\n    @agent.request_referer @req, uri, referer\n\n    assert_equal 'https://old.example', @req['referer']\n  end\n\n  def test_request_referer_https_downgrade\n    referer = URI.parse 'https://old.example'\n\n    @agent.request_referer @req, @uri, referer\n\n    assert_nil @req['referer']\n  end\n\n  def test_request_referer_https_downgrade_case\n    uri = URI.parse 'http://example'\n    referer = URI.parse 'httpS://old.example'\n\n    @agent.request_referer @req, uri, referer\n\n    assert_nil @req['referer']\n  end\n\n  def test_request_referer_https_upgrade\n    uri = URI.parse 'https://example'\n    referer = URI.parse 'http://old.example'\n\n    @agent.request_referer @req, uri, referer\n\n    assert_equal 'http://old.example', @req['referer']\n  end\n\n  def test_request_referer_none\n    @agent.request_referer @req, @uri, nil\n\n    assert_nil @req['referer']\n  end\n\n  def test_request_referer_strip\n    uri = URI.parse 'http://example.com/index.html'\n\n    host_path = \"old.example/page.html?q=x\"\n    referer = \"http://#{host_path}\"\n\n    [\n      \"\",\n      \"@\",\n      \"user1@\",\n      \":@\",\n      \"user1:@\",\n      \":password1@\",\n      \"user1:password1@\",\n    ].each { |userinfo|\n      ['', '#frag'].each { |frag|\n        url = URI.parse \"http://#{userinfo}#{host_path}#{frag}\"\n\n        @agent.request_referer @req, uri, url\n\n        assert_equal referer, @req['referer'], url\n      }\n    }\n  end\n\n  def test_request_user_agent\n    @agent.request_user_agent @req\n\n    assert_match %r%^Mechanize/#{Mechanize::VERSION}%, @req['user-agent']\n\n    ruby_version = if RUBY_PATCHLEVEL >= 0 then\n                     \"#{RUBY_VERSION}p#{RUBY_PATCHLEVEL}\"\n                   else\n                     \"#{RUBY_VERSION}dev#{RUBY_REVISION}\"\n                   end\n\n    assert_match %r%Ruby/#{ruby_version}%, @req['user-agent']\n  end\n\n  def test_resolve_bad_uri\n    e = assert_raises ArgumentError do\n      @agent.resolve 'google'\n    end\n\n    assert_equal 'absolute URL needed (not google)', e.message\n  end\n\n  def test_resolve_uri_without_path\n    e = assert_raises ArgumentError do\n      @agent.resolve 'http:%5C%5Cfoo'\n    end\n\n    assert_equal 'hierarchical URL needed (not http:%5C%5Cfoo)', e.message\n  end\n\n  def test_resolve_utf8\n    uri = 'http://example?q=\u00fc'\n\n    resolved = @agent.resolve uri\n\n    assert_equal '/?q=%C3%BC', resolved.request_uri\n  end\n\n  def test_resolve_parameters_body\n    input_params = { :q => 'hello' }\n\n    uri, params = @agent.resolve_parameters @uri, :post, input_params\n\n    assert_equal 'http://example/', uri.to_s\n    assert_equal input_params, params\n  end\n\n  def test_resolve_parameters_query\n    uri, params = @agent.resolve_parameters @uri, :get, :q => 'hello'\n\n    assert_equal 'http://example/?q=hello', uri.to_s\n    assert_nil params\n  end\n\n  def test_resolve_parameters_query_append\n    input_params = { :q => 'hello' }\n    @uri.query = 'a=b'\n\n    uri, params = @agent.resolve_parameters @uri, :get, input_params\n\n    assert_equal 'http://example/?a=b&q=hello', uri.to_s\n    assert_nil params\n  end\n\n  def test_resolve_slashes\n    page = Mechanize::Page.new URI('http://example/foo/'), nil, '', 200, @mech\n    uri = '/bar/http://example/test/'\n\n    resolved = @agent.resolve uri, page\n\n    assert_equal 'http://example/bar/http://example/test/', resolved.to_s\n  end\n\n  def test_response_authenticate\n    @agent.add_auth @uri, 'user', 'password'\n\n    @res.instance_variable_set :@header, 'www-authenticate' => ['Basic realm=r']\n\n    @agent.response_authenticate @res, nil, @uri, @req, {}, nil, nil\n\n    base_uri = @uri + '/'\n    realm = Mechanize::HTTP::AuthRealm.new 'Basic', base_uri, 'r'\n    assert_equal [realm], @agent.authenticate_methods[base_uri][:basic]\n  end\n\n  def test_response_authenticate_digest\n    @agent.add_auth @uri, 'user', 'password'\n\n    @res.instance_variable_set(:@header,\n                               'www-authenticate' => ['Digest realm=r'])\n\n    @agent.response_authenticate @res, nil, @uri, @req, {}, nil, nil\n\n    base_uri = @uri + '/'\n    realm = Mechanize::HTTP::AuthRealm.new 'Digest', base_uri, 'r'\n    assert_equal [realm], @agent.authenticate_methods[base_uri][:digest]\n\n    challenge = Mechanize::HTTP::AuthChallenge.new('Digest',\n                                                   { 'realm' => 'r' },\n                                                   'Digest realm=r')\n\n    assert_equal challenge, @agent.digest_challenges[realm]\n  end\n\n  def test_response_authenticate_digest_iis\n    @agent.add_auth @uri, 'user', 'password'\n\n    @res.instance_variable_set(:@header,\n                               'www-authenticate' => ['Digest realm=r'],\n                               'server'           => ['Microsoft-IIS'])\n    @agent.response_authenticate @res, nil, @uri, @req, {}, nil, nil\n\n    base_uri = @uri + '/'\n    realm = Mechanize::HTTP::AuthRealm.new 'Digest', base_uri, 'r'\n    assert_equal [realm], @agent.authenticate_methods[base_uri][:iis_digest]\n  end\n\n  def test_response_authenticate_multiple\n    @agent.add_auth @uri, 'user', 'password'\n\n    @res.instance_variable_set(:@header,\n                               'www-authenticate' =>\n                                 ['Basic realm=r, Digest realm=r'])\n\n    @agent.response_authenticate @res, nil, @uri, @req, {}, nil, nil\n\n    base_uri = @uri + '/'\n    realm = Mechanize::HTTP::AuthRealm.new 'Digest', base_uri, 'r'\n    assert_equal [realm], @agent.authenticate_methods[base_uri][:digest]\n\n    assert_empty @agent.authenticate_methods[base_uri][:basic]\n  end\n\n  def test_response_authenticate_no_credentials\n    @res.instance_variable_set :@header, 'www-authenticate' => ['Basic realm=r']\n\n    e = assert_raises Mechanize::UnauthorizedError do\n      @agent.response_authenticate @res, fake_page, @uri, @req, {}, nil, nil\n    end\n\n    assert_match 'no credentials', e.message\n    assert_match 'available realms: r', e.message\n  end\n\n  def test_response_authenticate_no_www_authenticate\n    @agent.add_auth @uri, 'user', 'password'\n\n    denied_uri = URI('http://example/denied')\n\n    denied = page denied_uri, 'text/html', '', 401\n\n    e = assert_raises Mechanize::UnauthorizedError do\n      @agent.response_authenticate @res, denied, @uri, @req, {}, nil, nil\n    end\n\n    assert_equal \"401 => Net::HTTPUnauthorized for #{denied_uri} -- \" \\\n                 \"WWW-Authenticate header missing in response\",\n                 e.message\n  end\n\n  def test_response_authenticate_ntlm\n    @uri += '/ntlm'\n    @agent.add_auth @uri, 'user', 'password'\n\n    @res.instance_variable_set(:@header,\n                               'www-authenticate' => ['Negotiate, NTLM'])\n\n    page = @agent.response_authenticate @res, nil, @uri, @req, {}, nil, nil\n\n    assert_equal 'ok', page.body # lame test\n  end\n\n  def test_response_authenticate_unknown\n    @agent.add_auth @uri, 'user', 'password'\n\n    page = Mechanize::File.new nil, nil, nil, 401\n    @res.instance_variable_set(:@header,\n                               'www-authenticate' => ['Unknown realm=r'])\n\n    assert_raises Mechanize::UnauthorizedError do\n      @agent.response_authenticate @res, page, @uri, @req, nil, nil, nil\n    end\n  end\n\n  def test_response_content_encoding_7_bit\n    @res.instance_variable_set :@header, 'content-encoding' => %w[7bit]\n\n    body = @agent.response_content_encoding @res, StringIO.new('part')\n\n    assert_equal 'part', body.read\n  end\n\n  def test_response_content_encoding_deflate\n    @res.instance_variable_set :@header, 'content-encoding' => %w[deflate]\n    body_io = StringIO.new \"x\\x9C+H,*\\x01\\x00\\x04?\\x01\\xB8\"\n\n    body = @agent.response_content_encoding @res, body_io\n\n    assert_equal 'part', body.read\n\n    assert body_io.closed?\n  end\n\n  def test_response_content_encoding_deflate_chunked\n    @res.instance_variable_set :@header, 'content-encoding' => %w[deflate]\n    body_io = StringIO.new \"x\\x9C+H,*\\x01\\x00\\x04?\\x01\\xB8\"\n\n    body = @agent.response_content_encoding @res, body_io\n\n    assert_equal 'part', body.read\n  end\n\n  def test_response_content_encoding_deflate_corrupt\n    @res.instance_variable_set :@header, 'content-encoding' => %w[deflate]\n    body_io = StringIO.new \"x\\x9C+H,*\\x01\\x00\\x04?\\x01\" # missing 1 byte\n\n    e = assert_raises Mechanize::Error do\n      @agent.response_content_encoding @res, body_io\n    end\n\n    assert_match %r%error handling content-encoding deflate:%, e.message\n    assert_match %r%Zlib%, e.message\n\n    assert body_io.closed?\n  end\n\n  def test_response_content_encoding_deflate_empty\n    @res.instance_variable_set :@header, 'content-encoding' => %w[deflate]\n\n    body = @agent.response_content_encoding @res, StringIO.new\n\n    assert_equal '', body.read\n  end\n\n  # IIS/6.0 ASP.NET/2.0.50727 does not wrap deflate with zlib, WTF?\n  def test_response_content_encoding_deflate_no_zlib\n    @res.instance_variable_set :@header, 'content-encoding' => %w[deflate]\n\n    body = @agent.response_content_encoding @res, StringIO.new(\"+H,*\\001\\000\")\n\n    assert_equal 'part', body.read\n  end\n\n  def test_response_content_encoding_gzip\n    @res.instance_variable_set :@header, 'content-encoding' => %w[gzip]\n    body_io = StringIO.new \\\n      \"\\037\\213\\b\\0002\\002\\225M\\000\\003+H,*\\001\\000\\306p\\017I\\004\\000\\000\\000\"\n\n    body = @agent.response_content_encoding @res, body_io\n\n    assert_equal 'part', body.read\n\n    assert body_io.closed?\n  end\n\n  def test_response_content_encoding_gzip_chunked\n    def @res.content_length() nil end\n    @res.instance_variable_set :@header, 'content-encoding' => %w[gzip]\n    body_io = StringIO.new \\\n      \"\\037\\213\\b\\0002\\002\\225M\\000\\003+H,*\\001\\000\\306p\\017I\\004\\000\\000\\000\"\n\n    body = @agent.response_content_encoding @res, body_io\n\n    assert_equal 'part', body.read\n  end\n\n  def test_response_content_encoding_gzip_corrupt\n    log = StringIO.new\n    logger = Logger.new log\n    @agent.context.log = logger\n\n    @res.instance_variable_set :@header, 'content-encoding' => %w[gzip]\n    body_io = StringIO.new \\\n      \"\\037\\213\\b\\0002\\002\\225M\\000\\003+H,*\\001\"\n\n    skip if jruby_zlib?\n\n    e = assert_raises Mechanize::Error do\n      @agent.response_content_encoding @res, body_io\n    end\n\n    assert_match %r%error handling content-encoding gzip:%, e.message\n    assert_match %r%Zlib%, e.message\n\n    assert_match %r%unable to gunzip response: unexpected end of file%,\n                 log.string\n    assert_match %r%unable to inflate response: buffer error%,\n                 log.string\n\n    assert body_io.closed?\n  end\n\n  def test_response_content_encoding_gzip_checksum_corrupt_crc\n    log = StringIO.new\n    logger = Logger.new log\n    @agent.context.log = logger\n\n    @res.instance_variable_set :@header, 'content-encoding' => %w[gzip]\n    body_io = StringIO.new \\\n      \"\\037\\213\\b\\0002\\002\\225M\\000\\003+H,*\\001\\000\\306p\\017J\\004\\000\\000\\000\"\n\n    body = @agent.response_content_encoding @res, body_io\n\n    assert_equal 'part', body.read\n\n    assert body_io.closed?\n\n    assert_match %r%invalid compressed data -- crc error%, log.string\n  rescue IOError\n    raise unless jruby_zlib?\n  end\n\n  def test_response_content_encoding_gzip_checksum_corrupt_length\n    log = StringIO.new\n    logger = Logger.new log\n    @agent.context.log = logger\n\n    @res.instance_variable_set :@header, 'content-encoding' => %w[gzip]\n    body_io = StringIO.new \\\n      \"\\037\\213\\b\\0002\\002\\225M\\000\\003+H,*\\001\\000\\306p\\017I\\005\\000\\000\\000\"\n\n    @agent.response_content_encoding @res, body_io\n\n    assert body_io.closed?\n\n    assert_match %r%invalid compressed data -- length error%, log.string\n  rescue IOError\n    raise unless jruby_zlib?\n  end\n\n  def test_response_content_encoding_gzip_checksum_truncated\n    log = StringIO.new\n    logger = Logger.new log\n    @agent.context.log = logger\n\n    @res.instance_variable_set :@header, 'content-encoding' => %w[gzip]\n    body_io = StringIO.new \\\n      \"\\037\\213\\b\\0002\\002\\225M\\000\\003+H,*\\001\\000\\306p\\017I\\004\\000\\000\"\n\n    @agent.response_content_encoding @res, body_io\n\n    assert body_io.closed?\n\n    assert_match %r%unable to gunzip response: footer is not found%, log.string\n  rescue IOError\n    raise unless jruby_zlib?\n  end\n\n  def test_response_content_encoding_gzip_empty\n    @res.instance_variable_set :@header, 'content-encoding' => %w[gzip]\n\n    body = @agent.response_content_encoding @res, StringIO.new\n\n    assert_equal '', body.read\n  end\n\n  def test_response_content_encoding_gzip_encoding_bad\n    @res.instance_variable_set(:@header,\n                               'content-encoding' => %w[gzip],\n                               'content-type' => 'text/html; charset=UTF-8')\n\n    # \"test\\xB2\"\n    body_io = StringIO.new \\\n      \"\\037\\213\\b\\000*+\\314N\\000\\003+I-.\\331\\004\\000x\\016\\003\\376\\005\\000\\000\\000\"\n\n    body = @agent.response_content_encoding @res, body_io\n\n    expected = \"test\\xB2\"\n    expected.force_encoding Encoding::BINARY if have_encoding?\n\n    content = body.read\n    assert_equal expected, content\n    assert_equal Encoding::BINARY, content.encoding if have_encoding?\n  end\n\n  def test_response_content_encoding_gzip_no_footer\n    @res.instance_variable_set :@header, 'content-encoding' => %w[gzip]\n    body_io = StringIO.new \\\n      \"\\037\\213\\b\\0002\\002\\225M\\000\\003+H,*\\001\\000\"\n\n    body = @agent.response_content_encoding @res, body_io\n\n    assert_equal 'part', body.read\n\n    assert body_io.closed?\n  rescue IOError\n    raise unless jruby_zlib?\n  end\n\n  def test_response_content_encoding_none\n    @res.instance_variable_set :@header, 'content-encoding' => %w[none]\n\n    body = @agent.response_content_encoding @res, StringIO.new('part')\n\n    assert_equal 'part', body.read\n  end\n\n  def test_response_content_encoding_empty_string\n    @res.instance_variable_set :@header, 'content-encoding' => %w[]\n\n    body = @agent.response_content_encoding @res, StringIO.new('part')\n\n    assert_equal 'part', body.read\n  end\n\n  def test_response_content_encoding_identity\n    @res.instance_variable_set :@header, 'content-encoding' => %w[identity]\n\n    body = @agent.response_content_encoding @res, StringIO.new('part')\n\n    assert_equal 'part', body.read\n  end\n\n  def test_response_content_encoding_tempfile_7_bit\n    body_io = tempfile 'part'\n\n    @res.instance_variable_set :@header, 'content-encoding' => %w[7bit]\n\n    body = @agent.response_content_encoding @res, body_io\n\n    assert_equal 'part', body.read\n    refute body_io.closed?\n  ensure\n    begin\n      body_io.close! if body_io and not body_io.closed?\n    rescue IOError\n      # HACK for ruby 1.8\n    end\n  end\n\n  def test_response_content_encoding_tempfile_gzip\n    body_io = tempfile \"x\\x9C+H,*\\x01\\x00\\x04?\\x01\\xB8\"\n    @res.instance_variable_set :@header, 'content-encoding' => %w[deflate]\n\n    body = @agent.response_content_encoding @res, body_io\n\n    assert_equal 'part', body.read\n    assert body_io.closed?\n  ensure\n    body_io.close! if body_io and not body_io.closed?\n  end\n\n  def test_response_content_encoding_unknown\n    @res.instance_variable_set :@header, 'content-encoding' => %w[unknown]\n    body = StringIO.new 'part'\n\n    e = assert_raises Mechanize::Error do\n      @agent.response_content_encoding @res, body\n    end\n\n    assert_equal 'unsupported content-encoding: unknown', e.message\n  end\n\n  def test_response_content_encoding_x_gzip\n    @res.instance_variable_set :@header, 'content-encoding' => %w[x-gzip]\n    body_io = StringIO.new \\\n      \"\\037\\213\\b\\0002\\002\\225M\\000\\003+H,*\\001\\000\\306p\\017I\\004\\000\\000\\000\"\n\n    body = @agent.response_content_encoding @res, body_io\n\n    assert_equal 'part', body.read\n  end\n\n  def test_response_cookies\n    uri = URI.parse 'http://host.example.com'\n    cookie_str = 'a=b domain=.example.com'\n    @res.instance_variable_set(:@header,\n                               'set-cookie' => [cookie_str],\n                               'content-type' => %w[text/html])\n    page = Mechanize::Page.new uri, @res, '', 200, @mech\n\n    @agent.response_cookies @res, uri, page\n\n    assert_equal ['a=\"b domain=.example.com\"'],\n                 @agent.cookie_jar.cookies(uri).map { |c| c.to_s }\n  end\n\n  def test_response_cookies_many\n    uri = URI.parse 'http://host.example.com'\n    cookie1 = 'a=b domain=.example.com'\n    cookie2 = 'c=d domain=.example.com'\n    cookies = [cookie1, cookie2]\n    @res.instance_variable_set(:@header,\n                               'set-cookie' => cookies,\n                               'content-type' => %w[text/html])\n    page = Mechanize::Page.new uri, @res, '', 200, @mech\n\n    @agent.response_cookies @res, uri, page\n\n    cookies_from_jar = @agent.cookie_jar.cookies(uri)\n\n    assert_equal 2, cookies_from_jar.length\n    assert_equal [\n      'a=\"b domain=.example.com\"',\n      'c=\"d domain=.example.com\"',\n    ], cookies_from_jar.sort_by { |c| c.name }.map(&:to_s)\n  end\n\n  def test_response_cookies_meta\n    uri = URI.parse 'http://host.example.com'\n    cookie_str = 'a=b domain=.example.com'\n\n    body = <<-BODY\n<head>\n  <meta http-equiv=\"Set-Cookie\" content=\"#{cookie_str}\">\n</head>\"\n    BODY\n\n    @res.instance_variable_set(:@header,\n                               'content-type' => %w[text/html])\n    page = Mechanize::Page.new uri, @res, body, 200, @mech\n\n    @agent.response_cookies @res, uri, page\n\n    assert_equal ['a=\"b domain=.example.com\"'],\n                 @agent.cookie_jar.cookies(uri).map { |c| c.to_s }\n  end\n\n  def test_response_cookies_meta_bogus\n    uri = URI.parse 'http://host.example.com'\n\n    body = <<-BODY\n<head>\n  <meta http-equiv=\"Set-Cookie\">\n</head>\"\n    BODY\n\n    @res.instance_variable_set(:@header,\n                               'content-type' => %w[text/html])\n    page = Mechanize::Page.new uri, @res, body, 200, @mech\n\n    @agent.response_cookies @res, uri, page\n\n    assert_empty @agent.cookie_jar.cookies(uri)\n  end\n\n  def test_response_follow_meta_refresh\n    uri = URI.parse 'http://example/#id+1'\n\n    body = <<-BODY\n<title></title>\n<meta http-equiv=\"refresh\" content=\"0\">\n    BODY\n\n    page = Mechanize::Page.new(uri, nil, body, 200, @mech)\n\n    @agent.follow_meta_refresh = true\n    @agent.follow_meta_refresh_self = true\n\n    page = @agent.response_follow_meta_refresh @res, uri, page, 0\n\n    assert_equal uri, page.uri\n  end\n\n  def test_response_follow_meta_refresh_limit\n    uri = URI.parse 'http://example/#id+1'\n\n    body = <<-BODY\n<title></title>\n<meta http-equiv=\"refresh\" content=\"0\">\n    BODY\n\n    page = Mechanize::Page.new(uri, nil, body, 200, @mech)\n\n    @agent.follow_meta_refresh = true\n    @agent.follow_meta_refresh_self = true\n\n    assert_raises Mechanize::RedirectLimitReachedError do\n      @agent.response_follow_meta_refresh(@res, uri, page,\n                                          @agent.redirection_limit)\n    end\n  end\n\n  def test_response_meta_refresh_with_insecure_url\n    uri = URI.parse 'http://example/#id+1'\n\n    body = <<-BODY\n<title></title>\n<meta http-equiv=\"refresh\" content=\"0; url=file:///dev/zero\">\n    BODY\n\n    page = Mechanize::Page.new(uri, nil, body, 200, @mech)\n\n    @agent.follow_meta_refresh = true\n\n    assert_raises Mechanize::Error do\n      @agent.response_follow_meta_refresh(@res, uri, page,\n                                          @agent.redirection_limit)\n    end\n  end\n\n  def test_response_parse\n    body = '<title>hi</title>'\n    @res.instance_variable_set :@header, 'content-type' => %w[text/html]\n\n    page = @agent.response_parse @res, body, @uri\n\n    assert_instance_of Mechanize::Page, page\n    assert_equal @mech, page.mech\n  end\n\n  def test_response_parse_content_type_case\n    body = '<title>hi</title>'\n    @res.instance_variable_set(:@header, 'content-type' => %w[text/HTML])\n\n    page = @agent.response_parse @res, body, @uri\n\n    assert_instance_of Mechanize::Page, page\n\n    assert_equal 'text/HTML', page.content_type\n  end\n\n  def test_response_parse_content_type_encoding\n    body = '<title>hi</title>'\n    @res.instance_variable_set(:@header,\n                               'content-type' =>\n                                 %w[text/html;charset=ISO-8859-1])\n\n    page = @agent.response_parse @res, body, @uri\n\n    assert_instance_of Mechanize::Page, page\n    assert_equal @mech, page.mech\n\n    assert_equal 'ISO-8859-1', page.encoding\n    assert_equal 'ISO-8859-1', page.parser.encoding\n  end\n\n  def test_response_parse_content_type_encoding_broken_iso_8859_1\n    body = '<title>hi</title>'\n    @res.instance_variable_set(:@header,\n                               'content-type' =>\n                                 %w[text/html; charset=ISO_8859-1])\n\n    page = @agent.response_parse @res, body, @uri\n\n    assert_instance_of Mechanize::Page, page\n    assert_equal 'ISO_8859-1', page.encoding\n  end\n\n  def test_response_parse_content_type_encoding_broken_utf_8\n    body = '<title>hi</title>'\n    @res.instance_variable_set(:@header,\n                               'content-type' =>\n                                 %w[text/html; charset=UTF8])\n\n    page = @agent.response_parse @res, body, @uri\n\n    assert_instance_of Mechanize::Page, page\n    assert_equal 'UTF8', page.encoding\n    assert_equal 'UTF8', page.parser.encoding\n  end\n\n  def test_response_parse_content_type_encoding_garbage\n    body = '<title>hi</title>'\n    @res.instance_variable_set(:@header,\n                               'content-type' =>\n                                 %w[text/html; charset=garbage_charset])\n\n    page = @agent.response_parse @res, body, @uri\n\n    assert_instance_of Mechanize::Page, page\n    assert_equal @mech, page.mech\n  end\n\n  def test_response_parse_content_type_encoding_semicolon\n    body = '<title>hi</title>'\n    @res.instance_variable_set(:@header,\n                               'content-type' =>\n                                 %w[text/html;charset=UTF-8;])\n\n    page = @agent.response_parse @res, body, @uri\n\n    assert_instance_of Mechanize::Page, page\n\n    assert_equal 'UTF-8', page.encoding\n  end\n\n  def test_response_read\n    def @res.read_body() yield 'part' end\n    def @res.content_length() 4 end\n\n    io = @agent.response_read @res, @req, @uri\n\n    body = io.read\n\n    assert_equal 'part', body\n    assert_equal Encoding::BINARY, body.encoding\n  end\n\n  def test_response_read_chunked_no_trailer\n    @res['Transfer-Encoding'] = 'chunked'\n    def @res.content_length() end\n    def @res.read_body\n      yield 'a' * 10\n      raise EOFError\n    end\n\n    e = assert_raises Mechanize::ChunkedTerminationError do\n      @agent.response_read @res, @req, @uri\n    end\n\n    assert_equal 'aaaaaaaaaa', e.body_io.read\n  end\n\n  def test_response_read_content_length_head\n    req = Net::HTTP::Head.new '/'\n\n    def @res.content_length() end\n    def @res.read_body() end\n\n    io = @agent.response_read @res, req, @uri\n\n    assert_equal '', io.read\n  end\n\n  def test_response_read_content_length_mismatch\n    def @res.content_length() 5 end\n    def @res.read_body() yield 'part' end\n\n    e = assert_raises Mechanize::ResponseReadError do\n      @agent.response_read @res, @req, @uri\n    end\n\n    assert_equal 'Content-Length (5) does not match response body length (4)' \\\n      ' (Mechanize::ResponseReadError)', e.message\n  end\n\n  def test_response_read_content_length_redirect\n    res = Net::HTTPFound.allocate\n    def res.content_length() 5 end\n    def res.code() 302 end\n    def res.read_body() yield 'part' end\n    res.instance_variable_set :@header, {}\n\n    io = @agent.response_read res, @req, @uri\n\n    assert_equal 'part', io.read\n  end\n\n  def test_response_read_error\n    def @res.read_body()\n      yield 'part'\n      raise Net::HTTP::Persistent::Error\n    end\n\n    e = assert_raises Mechanize::ResponseReadError do\n      @agent.response_read @res, @req, @uri\n    end\n\n    assert_equal @res, e.response\n    assert_equal 'part', e.body_io.read\n    assert_kind_of Net::HTTP::Persistent::Error, e.error\n  end\n\n  def test_response_read_file\n    Tempfile.open 'pi.txt' do |tempfile|\n      tempfile.write \"\u03c0\\n\"\n      tempfile.flush\n      tempfile.rewind\n\n      uri = URI.parse \"file://#{tempfile.path}\"\n      req = Mechanize::FileRequest.new uri\n      res = Mechanize::FileResponse.new tempfile.path\n\n      io = @agent.response_read res, req, uri\n\n      expected = \"\u03c0\\n\".force_encoding(Encoding::BINARY)\n\n      # Ruby 1.8.7 doesn't let us set the write mode of the tempfile to binary,\n      # so we should expect an inserted carriage return on some platforms\n      expected_with_carriage_return = \"\u03c0\\r\\n\".force_encoding(Encoding::BINARY)\n\n      body = io.read\n      assert_match(/^(#{expected}|#{expected_with_carriage_return})$/m, body)\n      assert_equal Encoding::BINARY, body.encoding\n    end\n  end\n\n  def test_response_read_large\n    @agent.max_file_buffer = 10240\n\n    def @res.read_body() yield 'a' * 10241 end\n    def @res.content_length() 10241 end\n\n    io = @agent.response_read @res, @req, @uri\n\n    assert_kind_of Tempfile, io\n    assert_equal 10241, io.stat.size\n  end\n\n  def test_response_read_large_chunked\n    @agent.max_file_buffer = 10240\n\n    def @res.read_body\n      11.times do yield 'a' * 1024 end\n    end\n    def @res.content_length() end\n\n    io = @agent.response_read @res, @req, @uri\n\n    assert_kind_of Tempfile, io\n    assert_equal 11264, io.stat.size\n  end\n\n  def test_response_read_no_body\n    req = Net::HTTP::Options.new '/'\n\n    def @res.content_length() end\n    def @res.read_body() end\n\n    io = @agent.response_read @res, req, @uri\n\n    assert_equal '', io.read\n  end\n\n  def test_response_read_unknown_code\n    res = Net::HTTPUnknownResponse.allocate\n    res.instance_variable_set :@code, 9999\n    res.instance_variable_set :@header, {}\n    def res.read_body() yield 'part' end\n\n    e = assert_raises Mechanize::ResponseCodeError do\n      @agent.response_read res, @req, @uri\n    end\n\n    assert_equal res, e.page\n  end\n\n  def test_response_redirect\n    @agent.redirect_ok = true\n    referer = page 'http://example/referer'\n\n    page = fake_page\n    page = @agent.response_redirect({ 'Location' => '/index.html' }, :get,\n                                    page, 0, {}, referer)\n\n    assert_equal URI('http://fake.example/index.html'), page.uri\n\n    assert_equal 'http://example/referer', requests.first['Referer']\n  end\n\n  def test_response_redirect_header\n    @agent.redirect_ok = true\n    referer = page 'http://example/referer'\n\n    headers = {\n      'Range' => 'bytes=0-9999',\n      'Content-Type' => 'application/x-www-form-urlencoded',\n      'CONTENT-LENGTH' => '9999',\n      'content-md5' => '14758f1afd44c09b7992073ccf00b43d',\n    }\n\n    page = fake_page\n    page = @agent.response_redirect({ 'Location' => '/http_headers' }, :get,\n                                    page, 0, headers, referer)\n\n    assert_equal URI('http://fake.example/http_headers'), page.uri\n\n    assert_match 'range|bytes=0-9999', page.body\n    refute_match 'content-type|application/x-www-form-urlencoded', page.body\n    refute_match 'content-length|9999', page.body\n    refute_match 'content-md5|14758f1afd44c09b7992073ccf00b43d', page.body\n  end\n\n  def test_response_redirect_malformed\n    @agent.redirect_ok = true\n    referer = page 'http://example/referer'\n\n    page = fake_page\n    page = @agent.response_redirect({ 'Location' => '/index.html?q=\u3042' }, :get,\n                                    page, 0, {}, referer)\n\n    assert_equal URI('http://fake.example/index.html?q=%E3%81%82'), page.uri\n\n    assert_equal 'http://example/referer', requests.first['Referer']\n  end\n\n  def test_response_redirect_insecure\n    @agent.redirect_ok = true\n    referer = page 'http://example/referer'\n\n    assert_raises Mechanize::Error do\n      @agent.response_redirect({ 'Location' => 'file:///etc/passwd' }, :get,\n                               fake_page, 0, {}, referer)\n    end\n  end\n\n  def test_response_redirect_limit\n    @agent.redirect_ok = true\n    referer = page 'http://example/referer'\n\n    assert_raises Mechanize::RedirectLimitReachedError do\n      @agent.response_redirect({ 'Location' => '/index.html' }, :get,\n                               fake_page, @agent.redirection_limit, {}, referer)\n    end\n  end\n\n  def test_response_redirect_to_cross_site_with_credential\n    @agent.redirect_ok = true\n\n    headers = {\n      'Range' => 'bytes=0-9999',\n      'AUTHORIZATION' => 'Basic xxx',\n      'cookie' => 'name=value',\n    }\n\n    page = html_page ''\n    page = @agent.response_redirect({ 'Location' => 'http://trap/http_headers' }, :get,\n                                    page, 0, headers)\n\n    refute_includes(headers.keys, \"AUTHORIZATION\")\n    refute_includes(headers.keys, \"cookie\")\n\n    assert_match 'range|bytes=0-9999', page.body\n    refute_match(\"authorization|Basic xxx\", page.body)\n    refute_match(\"cookie|name=value\", page.body)\n  end\n\n  def test_response_redirect_to_same_site_with_credential\n    @agent.redirect_ok = true\n\n    headers = {\n      'Range' => 'bytes=0-9999',\n      'AUTHORIZATION' => 'Basic xxx',\n      'cookie' => 'name=value',\n    }\n\n    page = html_page ''\n    page = @agent.response_redirect({ 'Location' => '/http_headers' }, :get,\n                                    page, 0, headers)\n\n    assert_includes(headers.keys, \"AUTHORIZATION\")\n    assert_includes(headers.keys, \"cookie\")\n\n    assert_match 'range|bytes=0-9999', page.body\n    assert_match(\"authorization|Basic xxx\", page.body)\n    assert_match(\"cookie|name=value\", page.body)\n  end\n\n  def test_response_redirect_not_ok\n    @agent.redirect_ok = false\n\n    page = fake_page\n    page = @agent.response_redirect({ 'Location' => '/other' }, :get, page, 0,\n                                    {}, page)\n\n    assert_equal URI('http://fake.example'), page.uri\n  end\n\n  def test_response_redirect_permanent\n    @agent.redirect_ok = :permanent\n\n    response = Net::HTTPMovedPermanently.allocate\n    response.instance_variable_set :@header, { 'location' => %w[/index.html] }\n\n    page = fake_page\n    page = @agent.response_redirect response, :get, page, 0, {}, page\n\n    assert_equal URI('http://fake.example/index.html'), page.uri\n  end\n\n  def test_response_redirect_permanent_temporary\n    @agent.redirect_ok = :permanent\n\n    response = Net::HTTPMovedTemporarily.allocate\n    response.instance_variable_set :@header, { 'location' => %w[/index.html] }\n\n    page = fake_page\n    page = @agent.response_redirect response, :get, page, 0, {}, page\n\n    assert_equal URI('http://fake.example/'), page.uri\n  end\n\n  def test_retry_change_request_equals\n    unless Gem::Requirement.new(\"< 4.0.0\").satisfied_by?(Gem::Version.new(Net::HTTP::Persistent::VERSION))\n      # see https://github.com/drbrain/net-http-persistent/pull/100\n      skip(\"net-http-persistent 4.0.0 and later does not support retry_change_requests\")\n    end\n\n    refute @agent.http.retry_change_requests\n\n    @agent.retry_change_requests = true\n\n    assert @agent.http.retry_change_requests\n  end\n\n  def test_robots_allowed_eh\n    allowed    = URI 'http://localhost/index.html'\n    disallowed = URI 'http://localhost/norobots.html'\n\n    assert @agent.robots_allowed? allowed\n    refute @agent.robots_allowed? disallowed\n\n    refute @agent.robots_disallowed? allowed\n    assert @agent.robots_disallowed? disallowed\n  end\n\n  def test_robots_allowed_eh_noindex\n    @agent.robots = true\n\n    noindex = URI 'http://localhost/noindex.html'\n\n    assert @agent.robots_allowed? noindex\n\n    assert_raises Mechanize::RobotsDisallowedError do\n      @agent.fetch noindex\n    end\n  end\n\n  def test_robots_infinite_loop\n    @agent.robots = true\n    @agent.redirect_ok = true\n\n    assert_raises Mechanize::RobotsDisallowedError do\n      @agent.fetch URI('http://301/norobots.html')\n    end\n\n    @agent.fetch URI('http://301/robots.html')\n  end\n\n  def test_set_proxy\n    @agent.set_proxy 'www.example.com', 9001, 'joe', 'lol'\n\n    assert_equal @agent.proxy_uri.host,     'www.example.com'\n    assert_equal @agent.proxy_uri.port,     9001\n    assert_equal @agent.proxy_uri.user,     'joe'\n    assert_equal @agent.proxy_uri.password, 'lol'\n  end\n\n  def test_set_proxy_port_string\n    @agent.set_proxy 'www.example.com', '9001', 'joe', 'lol'\n\n    assert_equal @agent.proxy_uri.host,     'www.example.com'\n    assert_equal @agent.proxy_uri.port,     9001\n    assert_equal @agent.proxy_uri.user,     'joe'\n    assert_equal @agent.proxy_uri.password, 'lol'\n  end\n\n  def test_set_proxy_service_name\n    @agent.set_proxy 'www.example.com', 'http', 'joe', 'lol'\n\n    assert_equal @agent.proxy_uri.host,     'www.example.com'\n    assert_equal @agent.proxy_uri.port,     80\n    assert_equal @agent.proxy_uri.user,     'joe'\n    assert_equal @agent.proxy_uri.password, 'lol'\n  end\n\n  def test_set_proxy_service_name_bad\n    e = assert_raises ArgumentError do\n      @agent.set_proxy 'www.example.com', 'nonexistent service', 'joe', 'lol'\n    end\n\n    assert_equal 'invalid value for port: \"nonexistent service\"', e.message\n  end\n\n  def test_set_proxy_with_scheme\n    @agent.set_proxy 'http://www.example.com', 9001, 'joe', 'lol'\n\n    assert_equal @agent.proxy_uri.host,     'www.example.com'\n    assert_equal @agent.proxy_uri.port,     9001\n    assert_equal @agent.proxy_uri.user,     'joe'\n    assert_equal @agent.proxy_uri.password, 'lol'\n  end\n\n  def test_set_proxy_url\n    @agent.set_proxy 'http://joe:lol@www.example.com:9001'\n\n    assert_equal @agent.proxy_uri.host,     'www.example.com'\n    assert_equal @agent.proxy_uri.port,     9001\n    assert_equal @agent.proxy_uri.user,     'joe'\n    assert_equal @agent.proxy_uri.password, 'lol'\n  end\n\n  def test_set_proxy_uri\n    @agent.set_proxy URI('http://joe:lol@www.example.com:9001')\n\n    assert_equal @agent.proxy_uri.host,     'www.example.com'\n    assert_equal @agent.proxy_uri.port,     9001\n    assert_equal @agent.proxy_uri.user,     'joe'\n    assert_equal @agent.proxy_uri.password, 'lol'\n  end\n\n  def test_set_proxy_url_and_credentials\n    @agent.set_proxy 'http://www.example.com:9001', nil, 'joe', 'lol'\n\n    assert_equal @agent.proxy_uri.host,     'www.example.com'\n    assert_equal @agent.proxy_uri.port,     9001\n    assert_equal @agent.proxy_uri.user,     'joe'\n    assert_equal @agent.proxy_uri.password, 'lol'\n  end\n\n  def test_setting_agent_name\n    mech = Mechanize.new 'user-set-name'\n    assert_equal 'user-set-name', mech.agent.http.name\n  end\n\n  def test_ssl\n    in_tmpdir do\n      store = OpenSSL::X509::Store.new\n      @agent.ca_file = '.'\n      @agent.cert_store = store\n      @agent.certificate = ssl_certificate\n      @agent.private_key = ssl_private_key\n      @agent.ssl_version = 'SSLv3'\n      @agent.verify_callback = proc { |ok, context| }\n\n      http = @agent.http\n\n      assert_equal '.',                       http.ca_file\n      assert_equal store,                     http.cert_store\n      assert_equal ssl_certificate,           http.certificate\n      assert_equal ssl_private_key,           http.private_key\n      assert_equal 'SSLv3',                   http.ssl_version\n      assert_equal OpenSSL::SSL::VERIFY_PEER, http.verify_mode\n      assert http.verify_callback\n    end\n  end\n\n  def test_use_tempfile_eh\n    refute @agent.use_tempfile? nil\n\n    @agent.max_file_buffer = 1\n\n    refute @agent.use_tempfile? 0\n    assert @agent.use_tempfile? 1\n\n    @agent.max_file_buffer = nil\n\n    refute @agent.use_tempfile? 1\n  end\n\n  def test_verify_none_equals\n    @agent.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\n    http = @agent.http\n\n    assert_equal OpenSSL::SSL::VERIFY_NONE, http.verify_mode\n  end\n\nend\n\n"], "fixing_code": ["# frozen_string_literal: true\nrequire 'tempfile'\nrequire 'net/ntlm'\nrequire 'webrobots'\n\n##\n# An HTTP (and local disk access) user agent.  This class is an implementation\n# detail and is subject to change at any time.\n\nclass Mechanize::HTTP::Agent\n\n  CREDENTIAL_HEADERS = ['Authorization']\n  COOKIE_HEADERS = ['Cookie']\n  POST_HEADERS = ['Content-Length', 'Content-MD5', 'Content-Type']\n\n  # :section: Headers\n\n  # Disables If-Modified-Since conditional requests (enabled by default)\n  attr_accessor :conditional_requests\n\n  # Is gzip compression of requests enabled?\n  attr_accessor :gzip_enabled\n\n  # A hash of request headers to be used for every request\n  attr_accessor :request_headers\n\n  # The User-Agent header to send\n  attr_reader :user_agent\n\n  # :section: History\n\n  # history of requests made\n  attr_accessor :history\n\n  # :section: Hooks\n\n  # A list of hooks to call after retrieving a response.  Hooks are called with\n  # the agent and the response returned.\n  attr_reader :post_connect_hooks\n\n  # A list of hooks to call before making a request.  Hooks are called with\n  # the agent and the request to be performed.\n  attr_reader :pre_connect_hooks\n\n  # A list of hooks to call to handle the content-encoding of a request.\n  attr_reader :content_encoding_hooks\n\n  # :section: HTTP Authentication\n\n  attr_reader :auth_store # :nodoc:\n  attr_reader :authenticate_methods # :nodoc:\n  attr_reader :digest_challenges # :nodoc:\n\n  # :section: Redirection\n\n  # Follow HTML meta refresh and HTTP Refresh.  If set to +:anywhere+ meta\n  # refresh tags outside of the head element will be followed.\n  attr_accessor :follow_meta_refresh\n\n  # Follow an HTML meta refresh that has no \"url=\" in the content attribute.\n  #\n  # Defaults to false to prevent infinite refresh loops.\n  attr_accessor :follow_meta_refresh_self\n\n  # Controls how this agent deals with redirects.  The following values are\n  # allowed:\n  #\n  # :all, true:: All 3xx redirects are followed (default)\n  # :permanent:: Only 301 Moved Permanantly redirects are followed\n  # false:: No redirects are followed\n  attr_accessor :redirect_ok\n\n  # Maximum number of redirects to follow\n  attr_accessor :redirection_limit\n\n  # :section: Allowed error codes\n\n  # List of error codes (in String or Integer) to handle without\n  # raising Mechanize::ResponseCodeError, defaulted to an empty array.\n  # Note that 2xx, 3xx and 401 status codes will be handled without\n  # checking this list.\n\n  attr_accessor :allowed_error_codes\n\n  # :section: Robots\n\n  # When true, this agent will consult the site's robots.txt for each access.\n  attr_reader :robots\n\n  # Mutex used when fetching robots.txt\n  attr_reader :robots_mutex\n\n  # :section: SSL\n\n  # OpenSSL key password\n  attr_accessor :pass\n\n  # :section: Timeouts\n\n  # Set to false to disable HTTP/1.1 keep-alive requests\n  attr_accessor :keep_alive\n\n  # Length of time to wait until a connection is opened in seconds\n  attr_accessor :open_timeout\n\n  # Length of time to attempt to read data from the server\n  attr_accessor  :read_timeout\n\n  # :section:\n\n  # The cookies for this agent\n  attr_accessor :cookie_jar\n\n  # Responses larger than this will be written to a Tempfile instead of stored\n  # in memory.  Setting this to nil disables creation of Tempfiles.\n  attr_accessor :max_file_buffer\n\n  # :section: Utility\n\n  # The context parses responses into pages\n  attr_accessor :context\n\n  attr_reader :http # :nodoc:\n\n  # When set to true mechanize will ignore an EOF during chunked transfer\n  # encoding so long as at least one byte was received.  Be careful when\n  # enabling this as it may cause data loss.\n  attr_accessor :ignore_bad_chunking\n\n  # Handlers for various URI schemes\n  attr_accessor :scheme_handlers\n\n  # :section:\n\n  # Creates a new Mechanize HTTP user agent.  The user agent is an\n  # implementation detail of mechanize and its API may change at any time.\n\n  # The connection_name can be used to segregate SSL connections.\n  # Agents with different names will not share the same persistent connection.\n  def initialize(connection_name = 'mechanize')\n    @allowed_error_codes      = []\n    @conditional_requests     = true\n    @context                  = nil\n    @content_encoding_hooks   = []\n    @cookie_jar               = Mechanize::CookieJar.new\n    @follow_meta_refresh      = false\n    @follow_meta_refresh_self = false\n    @gzip_enabled             = true\n    @history                  = Mechanize::History.new\n    @ignore_bad_chunking      = false\n    @keep_alive               = true\n    @max_file_buffer          = 100_000 # 5MB for response bodies\n    @open_timeout             = nil\n    @post_connect_hooks       = []\n    @pre_connect_hooks        = []\n    @read_timeout             = nil\n    @redirect_ok              = true\n    @redirection_limit        = 20\n    @request_headers          = {}\n    @robots                   = false\n    @robots_mutex             = Mutex.new\n    @user_agent               = nil\n    @webrobots                = nil\n\n    # HTTP Authentication\n    @auth_store           = Mechanize::HTTP::AuthStore.new\n    @authenticate_parser  = Mechanize::HTTP::WWWAuthenticateParser.new\n    @authenticate_methods = Hash.new do |methods, uri|\n      methods[uri] = Hash.new do |realms, auth_scheme|\n        realms[auth_scheme] = []\n      end\n    end\n    @digest_auth          = Net::HTTP::DigestAuth.new\n    @digest_challenges    = {}\n\n    # SSL\n    @pass = nil\n\n    @scheme_handlers = Hash.new { |h, scheme|\n      h[scheme] = lambda { |link, page|\n        raise Mechanize::UnsupportedSchemeError.new(scheme, link)\n      }\n    }\n\n    @scheme_handlers['http']      = lambda { |link, page| link }\n    @scheme_handlers['https']     = @scheme_handlers['http']\n    @scheme_handlers['relative']  = @scheme_handlers['http']\n    @scheme_handlers['file']      = @scheme_handlers['http']\n\n    @http =\n      if defined?(Net::HTTP::Persistent::DEFAULT_POOL_SIZE)\n        Net::HTTP::Persistent.new(name: connection_name)\n      else\n        # net-http-persistent < 3.0\n        Net::HTTP::Persistent.new(connection_name)\n      end\n    @http.idle_timeout = 5\n    @http.keep_alive   = 300\n  end\n\n  ##\n  # Adds credentials +user+, +pass+ for +uri+.  If +realm+ is set the\n  # credentials are used only for that realm.  If +realm+ is not set the\n  # credentials become the default for any realm on that URI.\n  #\n  # +domain+ and +realm+ are exclusive as NTLM does not follow RFC 2617.  If\n  # +domain+ is given it is only used for NTLM authentication.\n\n  def add_auth uri, user, password, realm = nil, domain = nil\n    @auth_store.add_auth uri, user, password, realm, domain\n  end\n\n  ##\n  # USE OF add_default_auth IS NOT RECOMMENDED AS IT MAY EXPOSE PASSWORDS TO\n  # THIRD PARTIES\n  #\n  # Adds credentials +user+, +pass+ as the default authentication credentials.\n  # If no other credentials are available  these will be returned from\n  # credentials_for.\n  #\n  # If +domain+ is given it is only used for NTLM authentication.\n\n  def add_default_auth user, password, domain = nil # :nodoc:\n    @auth_store.add_default_auth user, password, domain\n  end\n\n  ##\n  # Retrieves +uri+ and parses it into a page or other object according to\n  # PluggableParser.  If the URI is an HTTP or HTTPS scheme URI the given HTTP\n  # +method+ is used to retrieve it, along with the HTTP +headers+, request\n  # +params+ and HTTP +referer+.\n  #\n  # The final URI to access is built with +uri+ and +params+, the\n  # latter of which is formatted into a string using\n  # Mechanize::Util.build_query_string, which see.\n  #\n  # +redirects+ tracks the number of redirects experienced when retrieving the\n  # page.  If it is over the redirection_limit an error will be raised.\n\n  def fetch uri, method = :get, headers = {}, params = [],\n            referer = current_page, redirects = 0\n\n    referer_uri = referer ? referer.uri : nil\n    uri         = resolve uri, referer\n    uri, params = resolve_parameters uri, method, params\n    request     = http_request uri, method, params\n    connection  = connection_for uri\n\n    request_auth             request, uri\n    disable_keep_alive       request\n    enable_gzip              request\n    request_language_charset request\n    request_cookies          request, uri\n    request_host             request, uri\n    request_referer          request, uri, referer_uri\n    request_user_agent       request\n    request_add_headers      request, headers\n    pre_connect              request\n\n    # Consult robots.txt\n    if robots && uri.is_a?(URI::HTTP)\n      robots_allowed?(uri) or raise Mechanize::RobotsDisallowedError.new(uri)\n    end\n\n    # Add If-Modified-Since if page is in history\n    if page = visited_page(uri) and last_modified = page.response['Last-Modified']\n      request['If-Modified-Since'] = last_modified\n    end if @conditional_requests\n\n    # Specify timeouts if supplied and our connection supports them\n    if @open_timeout && connection.respond_to?(:open_timeout=)\n      connection.open_timeout = @open_timeout\n    end\n    if @read_timeout && connection.respond_to?(:read_timeout=)\n      connection.read_timeout = @read_timeout\n    end\n\n    request_log request\n\n    response_body_io = nil\n\n    # Send the request\n    begin\n      response = connection.request(uri, request) { |res|\n        response_log res\n\n        response_body_io = response_read res, request, uri\n\n        res\n      }\n    rescue Mechanize::ChunkedTerminationError => e\n      raise unless @ignore_bad_chunking\n\n      response = e.response\n      response_body_io = e.body_io\n    end\n\n    hook_content_encoding response, uri, response_body_io\n\n    response_body_io = response_content_encoding response, response_body_io if\n      request.response_body_permitted?\n\n    post_connect uri, response, response_body_io\n\n    page = response_parse response, response_body_io, uri\n\n    response_cookies response, uri, page\n\n    meta = response_follow_meta_refresh response, uri, page, redirects\n    return meta if meta\n\n    if robots && page.is_a?(Mechanize::Page)\n      page.parser.noindex? and raise Mechanize::RobotsDisallowedError.new(uri)\n    end\n\n    case response\n    when Net::HTTPSuccess\n      page\n    when Mechanize::FileResponse\n      page\n    when Net::HTTPNotModified\n      log.debug(\"Got cached page\") if log\n      visited_page(uri) || page\n    when Net::HTTPRedirection\n      response_redirect response, method, page, redirects, headers, referer\n    when Net::HTTPUnauthorized\n      response_authenticate(response, page, uri, request, headers, params,\n                            referer)\n    else\n      if @allowed_error_codes.any? {|code| code.to_s == page.code} then\n        page\n      else\n        raise Mechanize::ResponseCodeError.new(page, 'unhandled response')\n      end\n    end\n  end\n\n  # URI for a proxy connection\n\n  def proxy_uri\n    @http.proxy_uri\n  end\n\n  # Retry non-idempotent requests?\n  def retry_change_requests\n    @http.retry_change_requests\n  end\n\n  # Retry non-idempotent requests\n\n  def retry_change_requests= retri\n    @http.retry_change_requests = retri\n  end\n\n  # :section: Headers\n\n  def user_agent= user_agent\n    @webrobots = nil if user_agent != @user_agent\n    @user_agent = user_agent\n  end\n\n  # :section: History\n\n  # Equivalent to the browser back button.  Returns the most recent page\n  # visited.\n  def back\n    @history.pop\n  end\n\n  ##\n  # Returns the latest page loaded by the agent\n\n  def current_page\n    @history.last\n  end\n\n  # Returns the maximum size for the history stack.\n  def max_history\n    @history.max_size\n  end\n\n  # Set the maximum size for the history stack.\n  def max_history=(length)\n    @history.max_size = length\n  end\n\n  # Returns a visited page for the url passed in, otherwise nil\n  def visited_page url\n    @history.visited_page resolve url\n  end\n\n  # :section: Hooks\n\n  def hook_content_encoding response, uri, response_body_io\n    @content_encoding_hooks.each do |hook|\n      hook.call self, uri, response, response_body_io\n    end\n  end\n\n  ##\n  # Invokes hooks added to post_connect_hooks after a +response+ is returned\n  # and the response +body+ is handled.\n  #\n  # Yields the +context+, the +uri+ for the request, the +response+ and the\n  # response +body+.\n\n  def post_connect uri, response, body_io # :yields: agent, uri, response, body\n    @post_connect_hooks.each do |hook|\n      begin\n        hook.call self, uri, response, body_io.read\n      ensure\n        body_io.rewind\n      end\n    end\n  end\n\n  ##\n  # Invokes hooks added to pre_connect_hooks before a +request+ is made.\n  # Yields the +agent+ and the +request+ that will be performed to each hook.\n\n  def pre_connect request # :yields: agent, request\n    @pre_connect_hooks.each do |hook|\n      hook.call self, request\n    end\n  end\n\n  # :section: Request\n\n  def connection_for uri\n    case uri.scheme.downcase\n    when 'http', 'https' then\n      return @http\n    when 'file' then\n      return Mechanize::FileConnection.new\n    end\n  end\n\n  # Closes all open connections for this agent.\n  def shutdown\n    http.shutdown\n  end\n\n  ##\n  # Decodes a gzip-encoded +body_io+.  If it cannot be decoded, inflate is\n  # tried followed by raising an error.\n\n  def content_encoding_gunzip body_io\n    log.debug('gzip response') if log\n\n    zio = Zlib::GzipReader.new body_io\n    out_io = auto_io 'mechanize-gunzip', 16384, zio\n    zio.finish\n\n    return out_io\n  rescue Zlib::Error => gz_error\n    log.warn \"unable to gunzip response: #{gz_error} (#{gz_error.class})\" if\n      log\n\n    body_io.rewind\n    body_io.read 10\n\n    begin\n      log.warn \"trying raw inflate on response\" if log\n      return inflate body_io, -Zlib::MAX_WBITS\n    rescue Zlib::Error => e\n      log.error \"unable to inflate response: #{e} (#{e.class})\" if log\n      raise\n    end\n  ensure\n    # do not close a second time if we failed the first time\n    zio.close if zio and !(zio.closed? or gz_error)\n    body_io.close unless body_io.closed?\n  end\n\n  ##\n  # Decodes a deflate-encoded +body_io+.  If it cannot be decoded, raw inflate\n  # is tried followed by raising an error.\n\n  def content_encoding_inflate body_io\n    log.debug('deflate body') if log\n\n    return inflate body_io\n  rescue Zlib::Error\n    log.error('unable to inflate response, trying raw deflate') if log\n\n    body_io.rewind\n\n    begin\n      return inflate body_io, -Zlib::MAX_WBITS\n    rescue Zlib::Error => e\n      log.error(\"unable to inflate response: #{e}\") if log\n      raise\n    end\n  ensure\n    body_io.close\n  end\n\n  def disable_keep_alive request\n    request['connection'] = 'close' unless @keep_alive\n  end\n\n  def enable_gzip request\n    request['accept-encoding'] = if @gzip_enabled\n                                   'gzip,deflate,identity'\n                                 else\n                                   'identity'\n                                 end\n  end\n\n  def http_request uri, method, params = nil\n    case uri.scheme.downcase\n    when 'http', 'https' then\n      klass = Net::HTTP.const_get(method.to_s.capitalize)\n\n      request ||= klass.new(uri.request_uri)\n      request.body = params.first if params\n\n      request\n    when 'file' then\n      Mechanize::FileRequest.new uri\n    end\n  end\n\n  def request_add_headers request, headers = {}\n    @request_headers.each do |k,v|\n      request[k] = v\n    end\n\n    headers.each do |field, value|\n      case field\n      when :etag              then request[\"ETag\"] = value\n      when :if_modified_since then request[\"If-Modified-Since\"] = value\n      when Symbol then\n        raise ArgumentError, \"unknown header symbol #{field}\"\n      else\n        request[field] = value\n      end\n    end\n  end\n\n  def request_auth request, uri\n    base_uri = uri + '/'\n    base_uri.user     &&= nil\n    base_uri.password &&= nil\n    schemes = @authenticate_methods[base_uri]\n\n    if realm = schemes[:digest].find { |r| r.uri == base_uri } then\n      request_auth_digest request, uri, realm, base_uri, false\n    elsif realm = schemes[:iis_digest].find { |r| r.uri == base_uri } then\n      request_auth_digest request, uri, realm, base_uri, true\n    elsif realm = schemes[:basic].find { |r| r.uri == base_uri } then\n      user, password, = @auth_store.credentials_for uri, realm.realm\n      request.basic_auth user, password\n    end\n  end\n\n  def request_auth_digest request, uri, realm, base_uri, iis\n    challenge = @digest_challenges[realm]\n\n    uri.user, uri.password, = @auth_store.credentials_for uri, realm.realm\n\n    auth = @digest_auth.auth_header uri, challenge.to_s, request.method, iis\n    request['Authorization'] = auth\n  end\n\n  def request_cookies request, uri\n    return if @cookie_jar.empty? uri\n\n    cookies = @cookie_jar.cookies uri\n\n    return if cookies.empty?\n\n    request.add_field 'Cookie', cookies.join('; ')\n  end\n\n  def request_host request, uri\n    port = [80, 443].include?(uri.port.to_i) ? nil : uri.port\n    host = uri.host\n\n    request['Host'] = [host, port].compact.join ':'\n  end\n\n  def request_language_charset request\n    request['accept-charset']  = 'ISO-8859-1,utf-8;q=0.7,*;q=0.7'\n    request['accept-language'] = 'en-us,en;q=0.5'\n  end\n\n  # Log specified headers for the request\n  def request_log request\n    return unless log\n\n    log.info(\"#{request.class}: #{request.path}\")\n\n    request.each_header do |k, v|\n      log.debug(\"request-header: #{k} => #{v}\")\n    end\n  end\n\n  # Sets a Referer header.  Fragment part is removed as demanded by\n  # RFC 2616 14.36, and user information part is removed just like\n  # major browsers do.\n  def request_referer request, uri, referer\n    return unless referer\n    return if 'https'.casecmp(referer.scheme) == 0 and\n              'https'.casecmp(uri.scheme) != 0\n    if referer.fragment || referer.user || referer.password\n      referer = referer.dup\n      referer.fragment = referer.user = referer.password = nil\n    end\n    request['Referer'] = referer\n  end\n\n  def request_user_agent request\n    request['User-Agent'] = @user_agent if @user_agent\n  end\n\n  def resolve(uri, referer = current_page)\n    referer_uri = referer && referer.uri\n    if uri.is_a?(URI)\n      uri = uri.dup\n    elsif uri.nil?\n      if referer_uri\n        return referer_uri\n      end\n      raise ArgumentError, \"absolute URL needed (not nil)\"\n    else\n      url = uri.to_s.strip\n      if url.empty?\n        if referer_uri\n          return referer_uri.dup.tap { |u| u.fragment = nil }\n        end\n        raise ArgumentError, \"absolute URL needed (not #{uri.inspect})\"\n      end\n\n      url.gsub!(/[^#{0.chr}-#{126.chr}]/o) { |match|\n        Mechanize::Util.uri_escape(match)\n      }\n\n      escaped_url = Mechanize::Util.html_unescape(\n        url.split(/((?:%[0-9A-Fa-f]{2})+|#)/).each_slice(2).map { |x, y|\n          \"#{WEBrick::HTTPUtils.escape(x)}#{y}\"\n        }.join('')\n      )\n\n      begin\n        uri = URI.parse(escaped_url)\n      rescue\n        uri = URI.parse(WEBrick::HTTPUtils.escape(escaped_url))\n      end\n    end\n\n    uri.host = referer_uri.host if referer_uri && URI::HTTP === uri && uri.host.nil?\n\n    scheme = uri.relative? ? 'relative' : uri.scheme.downcase\n    uri = @scheme_handlers[scheme].call(uri, referer)\n\n    if uri.relative?\n      raise ArgumentError, \"absolute URL needed (not #{uri})\" unless\n        referer_uri\n\n      if referer.respond_to?(:bases) && referer.parser &&\n          (lbase = referer.bases.last) && lbase.uri && lbase.uri.absolute?\n        base = lbase\n      else\n        base = nil\n      end\n\n      base = referer_uri + (base ? base.uri : referer_uri)\n\n      # Workaround for URI's bug in that it squashes consecutive\n      # slashes.  See #304.\n      if uri.path.match(%r{\\A(.*?/)(?!/\\.\\.?(?!/))(/.*)\\z}i)\n        uri = URI((base + $1).to_s + $2)\n      else\n        uri = base + uri\n      end\n\n      # Strip initial \"/..\" bits from the path\n      uri.path.sub!(/^(\\/\\.\\.)+(?=\\/)/, '')\n    end\n\n    unless ['http', 'https', 'file'].include?(uri.scheme.downcase)\n      raise ArgumentError, \"unsupported scheme: #{uri.scheme}\"\n    end\n\n    case uri.path\n    when nil\n      raise ArgumentError, \"hierarchical URL needed (not #{uri})\"\n    when ''.freeze\n      uri.path = '/'\n    end\n\n    uri\n  end\n\n  def secure_resolve!(uri, referer = current_page)\n    new_uri = resolve(uri, referer)\n\n    if (referer_uri = referer && referer.uri) &&\n       referer_uri.scheme != 'file'.freeze &&\n       new_uri.scheme == 'file'.freeze\n      raise Mechanize::Error, \"insecure redirect to a file URI\"\n    end\n\n    new_uri\n  end\n\n  def resolve_parameters uri, method, parameters\n    case method\n    when :head, :get, :delete, :trace then\n      if parameters and parameters.length > 0\n        uri.query ||= ''\n        uri.query << '&' if uri.query.length > 0\n        uri.query << Mechanize::Util.build_query_string(parameters)\n      end\n\n      return uri, nil\n    end\n\n    return uri, parameters\n  end\n\n  # :section: Response\n\n  def get_meta_refresh response, uri, page\n    return nil unless @follow_meta_refresh\n\n    if page.respond_to?(:meta_refresh) and\n       (redirect = page.meta_refresh.first) then\n      [redirect.delay, redirect.href] unless\n        not @follow_meta_refresh_self and redirect.link_self\n    elsif refresh = response['refresh']\n      delay, href, link_self = Mechanize::Page::MetaRefresh.parse refresh, uri\n      raise Mechanize::Error, 'Invalid refresh http header' unless delay\n      [delay.to_f, href] unless\n        not @follow_meta_refresh_self and link_self\n    end\n  end\n\n  def response_authenticate(response, page, uri, request, headers, params,\n                            referer)\n    www_authenticate = response['www-authenticate']\n\n    unless www_authenticate = response['www-authenticate'] then\n      message = 'WWW-Authenticate header missing in response'\n      raise Mechanize::UnauthorizedError.new(page, nil, message)\n    end\n\n    challenges = @authenticate_parser.parse www_authenticate\n\n    unless @auth_store.credentials? uri, challenges then\n      message = \"no credentials found, provide some with #add_auth\"\n      raise Mechanize::UnauthorizedError.new(page, challenges, message)\n    end\n\n    if challenge = challenges.find { |c| c.scheme =~ /^Digest$/i } then\n      realm = challenge.realm uri\n\n      auth_scheme = if response['server'] =~ /Microsoft-IIS/ then\n                      :iis_digest\n                    else\n                      :digest\n                    end\n\n      existing_realms = @authenticate_methods[realm.uri][auth_scheme]\n\n      if existing_realms.include? realm\n        message = 'Digest authentication failed'\n        raise Mechanize::UnauthorizedError.new(page, challenges, message)\n      end\n\n      existing_realms << realm\n      @digest_challenges[realm] = challenge\n    elsif challenge = challenges.find { |c| c.scheme == 'NTLM' } then\n      existing_realms = @authenticate_methods[uri + '/'][:ntlm]\n\n      if existing_realms.include?(realm) and not challenge.params then\n        message = 'NTLM authentication failed'\n        raise Mechanize::UnauthorizedError.new(page, challenges, message)\n      end\n\n      existing_realms << realm\n\n      if challenge.params then\n        type_2 = Net::NTLM::Message.decode64 challenge.params\n\n        user, password, domain = @auth_store.credentials_for uri, nil\n\n        type_3 = type_2.response({ :user => user, :password => password,\n                                   :domain => domain },\n                                 { :ntlmv2 => true }).encode64\n\n        headers['Authorization'] = \"NTLM #{type_3}\"\n      else\n        type_1 = Net::NTLM::Message::Type1.new.encode64\n        headers['Authorization'] = \"NTLM #{type_1}\"\n      end\n    elsif challenge = challenges.find { |c| c.scheme == 'Basic' } then\n      realm = challenge.realm uri\n\n      existing_realms = @authenticate_methods[realm.uri][:basic]\n\n      if existing_realms.include? realm then\n        message = 'Basic authentication failed'\n        raise Mechanize::UnauthorizedError.new(page, challenges, message)\n      end\n\n      existing_realms << realm\n    else\n      message = 'unsupported authentication scheme'\n      raise Mechanize::UnauthorizedError.new(page, challenges, message)\n    end\n\n    fetch uri, request.method.downcase.to_sym, headers, params, referer\n  end\n\n  def response_content_encoding response, body_io\n    length = response.content_length ||\n      case body_io\n      when Tempfile, IO then\n        body_io.stat.size\n      else\n        body_io.length\n      end\n\n    return body_io if length.zero?\n\n    out_io = case response['Content-Encoding']\n             when nil, 'none', '7bit', 'identity', \"\" then\n               body_io\n             when 'deflate' then\n               content_encoding_inflate body_io\n             when 'gzip', 'x-gzip' then\n               content_encoding_gunzip body_io\n             else\n               raise Mechanize::Error,\n                 \"unsupported content-encoding: #{response['Content-Encoding']}\"\n             end\n\n    out_io.flush\n    out_io.rewind\n\n    out_io\n  rescue Zlib::Error => e\n    message = String.new(\"error handling content-encoding #{response['Content-Encoding']}:\")\n    message << \" #{e.message} (#{e.class})\"\n    raise Mechanize::Error, message\n  ensure\n    begin\n      if Tempfile === body_io and\n         (StringIO === out_io or (out_io and out_io.path != body_io.path)) then\n        body_io.close!\n      end\n    rescue IOError\n      # HACK ruby 1.8 raises IOError when closing the stream\n    end\n  end\n\n  def response_cookies response, uri, page\n    if Mechanize::Page === page and page.body =~ /Set-Cookie/n\n      page.search('//head/meta[@http-equiv=\"Set-Cookie\"]').each do |meta|\n        save_cookies(uri, meta['content'])\n      end\n    end\n\n    header_cookies = response.get_fields 'Set-Cookie'\n\n    return unless header_cookies\n\n    header_cookies.each do |set_cookie|\n      save_cookies(uri, set_cookie)\n    end\n  end\n\n  def save_cookies(uri, set_cookie)\n    return [] if set_cookie.nil?\n    if log = log()\t # reduce method calls\n      @cookie_jar.parse(set_cookie, uri, :logger => log) { |c|\n        log.debug(\"saved cookie: #{c}\")\n        true\n      }\n    else\n      @cookie_jar.parse(set_cookie, uri)\n    end\n  end\n\n  def response_follow_meta_refresh response, uri, page, redirects\n    delay, new_url = get_meta_refresh(response, uri, page)\n    return nil unless delay\n    new_url = new_url ? secure_resolve!(new_url, page) : uri\n\n    raise Mechanize::RedirectLimitReachedError.new(page, redirects) if\n      redirects + 1 > @redirection_limit\n\n    sleep delay\n    @history.push(page, page.uri)\n    fetch new_url, :get, {}, [],\n          Mechanize::Page.new, redirects + 1\n  end\n\n  def response_log response\n    return unless log\n\n    log.info(\"status: #{response.class} #{response.http_version} \" \\\n             \"#{response.code} #{response.message}\")\n\n    response.each_header do |k, v|\n      log.debug(\"response-header: #{k} => #{v}\")\n    end\n  end\n\n  def response_parse response, body_io, uri\n    @context.parse uri, response, body_io\n  end\n\n  def response_read response, request, uri\n    content_length = response.content_length\n\n    if use_tempfile? content_length then\n      body_io = make_tempfile 'mechanize-raw'\n    else\n      body_io = StringIO.new.set_encoding(Encoding::BINARY)\n    end\n\n    total = 0\n\n    begin\n      response.read_body { |part|\n        total += part.length\n\n        if StringIO === body_io and use_tempfile? total then\n          new_io = make_tempfile 'mechanize-raw'\n\n          new_io.write body_io.string\n\n          body_io = new_io\n        end\n\n        body_io.write(part)\n        log.debug(\"Read #{part.length} bytes (#{total} total)\") if log\n      }\n    rescue EOFError => e\n      # terminating CRLF might be missing, let the user check the document\n      raise unless response.chunked? and total.nonzero?\n\n      body_io.rewind\n      raise Mechanize::ChunkedTerminationError.new(e, response, body_io, uri,\n                                                   @context)\n    rescue Net::HTTP::Persistent::Error, Errno::ECONNRESET => e\n      body_io.rewind\n      raise Mechanize::ResponseReadError.new(e, response, body_io, uri,\n                                             @context)\n    end\n\n    body_io.flush\n    body_io.rewind\n\n    raise Mechanize::ResponseCodeError.new(response, uri) if\n      Net::HTTPUnknownResponse === response\n\n    content_length = response.content_length\n\n    unless Net::HTTP::Head === request or Net::HTTPRedirection === response then\n      if content_length and content_length != body_io.length\n        err = EOFError.new(\"Content-Length (#{content_length}) does not \" \\\n                      \"match response body length (#{body_io.length})\")\n        raise Mechanize::ResponseReadError.new(err, response, body_io, uri,\n                                                @context)\n      end\n    end\n\n    body_io\n  end\n\n  def response_redirect(response, method, page, redirects, headers,\n                        referer = current_page)\n    case @redirect_ok\n    when true, :all\n      # shortcut\n    when false, nil\n      return page\n    when :permanent\n      return page unless Net::HTTPMovedPermanently === response\n    end\n\n    log.info(\"follow redirect to: #{response['Location']}\") if log\n\n    raise Mechanize::RedirectLimitReachedError.new(page, redirects) if\n      redirects + 1 > @redirection_limit\n\n    redirect_method = method == :head ? :head : :get\n\n    new_uri = secure_resolve!(response['Location'].to_s, page)\n    @history.push(page, page.uri)\n\n    # Make sure we are not copying over the POST headers from the original request\n    POST_HEADERS.each do |key|\n      headers.delete_if { |h| h.casecmp?(key) }\n    end\n\n    # Make sure we clear credential headers if being redirected to another site\n    if new_uri.host == page.uri.host\n      if new_uri.port != page.uri.port\n        # https://datatracker.ietf.org/doc/html/rfc6265#section-8.5\n        # cookies are OK to be shared across ports on the same host\n        CREDENTIAL_HEADERS.each { |ch| headers.delete_if { |h| h.casecmp?(ch) } }\n      end\n    else\n      (COOKIE_HEADERS + CREDENTIAL_HEADERS).each { |ch| headers.delete_if { |h| h.casecmp?(ch) } }\n    end\n\n    fetch new_uri, redirect_method, headers, [], referer, redirects + 1\n  end\n\n  # :section: Robots\n\n  RobotsKey = :__mechanize_get_robots__\n\n  def get_robots(uri) # :nodoc:\n    robots_mutex.synchronize do\n      Thread.current[RobotsKey] = true\n      begin\n        fetch(uri).body\n      rescue Mechanize::ResponseCodeError => e\n        case e.response_code\n        when /\\A4\\d\\d\\z/\n          ''\n        else\n          raise e\n        end\n      rescue Mechanize::RedirectLimitReachedError\n        ''\n      ensure\n        Thread.current[RobotsKey] = false\n      end\n    end\n  end\n\n  def robots= value\n    require 'webrobots' if value\n    @webrobots = nil if value != @robots\n    @robots = value\n  end\n\n  ##\n  # Tests if this agent is allowed to access +url+, consulting the site's\n  # robots.txt.\n\n  def robots_allowed? uri\n    return true if Thread.current[RobotsKey]\n\n    webrobots.allowed? uri\n  end\n\n  # Opposite of robots_allowed?\n\n  def robots_disallowed? url\n    !robots_allowed? url\n  end\n\n  # Returns an error object if there is an error in fetching or parsing\n  # robots.txt of the site +url+.\n  def robots_error(url)\n    webrobots.error(url)\n  end\n\n  # Raises the error if there is an error in fetching or parsing robots.txt of\n  # the site +url+.\n  def robots_error!(url)\n    webrobots.error!(url)\n  end\n\n  # Removes robots.txt cache for the site +url+.\n  def robots_reset(url)\n    webrobots.reset(url)\n  end\n\n  def webrobots\n    @webrobots ||= WebRobots.new(@user_agent, :http_get => method(:get_robots))\n  end\n\n  # :section: SSL\n\n  # Path to an OpenSSL CA certificate file\n  def ca_file\n    @http.ca_file\n  end\n\n  # Sets the path to an OpenSSL CA certificate file\n  def ca_file= ca_file\n    @http.ca_file = ca_file\n  end\n\n  # The SSL certificate store used for validating connections\n  def cert_store\n    @http.cert_store\n  end\n\n  # Sets the SSL certificate store used for validating connections\n  def cert_store= cert_store\n    @http.cert_store = cert_store\n  end\n\n  # The client X509 certificate\n  def certificate\n    @http.certificate\n  end\n\n  # Sets the client certificate to given X509 certificate.  If a path is given\n  # the certificate will be loaded and set.\n  def certificate= certificate\n    certificate = if OpenSSL::X509::Certificate === certificate then\n                    certificate\n                  else\n                    OpenSSL::X509::Certificate.new File.read certificate\n                  end\n\n    @http.certificate = certificate\n  end\n\n  # An OpenSSL private key or the path to a private key\n  def private_key\n    @http.private_key\n  end\n\n  # Sets the client's private key\n  def private_key= private_key\n    private_key = if OpenSSL::PKey::PKey === private_key then\n                    private_key\n                  else\n                    OpenSSL::PKey::RSA.new File.read(private_key), @pass\n                  end\n\n    @http.private_key = private_key\n  end\n\n  # SSL version to use\n  def ssl_version\n    @http.ssl_version\n  end\n\n  # Sets the SSL version to use\n  def ssl_version= ssl_version\n    @http.ssl_version = ssl_version\n  end\n\n  # A callback for additional certificate verification.  See\n  # OpenSSL::SSL::SSLContext#verify_callback\n  #\n  # The callback can be used for debugging or to ignore errors by always\n  # returning +true+.  Specifying nil uses the default method that was valid\n  # when the SSLContext was created\n  def verify_callback\n    @http.verify_callback\n  end\n\n  # Sets the certificate verify callback\n  def verify_callback= verify_callback\n    @http.verify_callback = verify_callback\n  end\n\n  # How to verify SSL connections.  Defaults to VERIFY_PEER\n  def verify_mode\n    @http.verify_mode\n  end\n\n  # Sets the mode for verifying SSL connections\n  def verify_mode= verify_mode\n    @http.verify_mode = verify_mode\n  end\n\n  # :section: Timeouts\n\n  # Reset connections that have not been used in this many seconds\n  def idle_timeout\n    @http.idle_timeout\n  end\n\n  # Sets the connection idle timeout for persistent connections\n  def idle_timeout= timeout\n    @http.idle_timeout = timeout\n  end\n\n  # :section: Utility\n\n  ##\n  # Creates a new output IO by reading +input_io+ in +read_size+ chunks.  If\n  # the output is over the max_file_buffer size a Tempfile with +name+ is\n  # created.\n  #\n  # If a block is provided, each chunk of +input_io+ is yielded for further\n  # processing.\n\n  def auto_io name, read_size, input_io\n    out_io = StringIO.new.set_encoding(Encoding::BINARY)\n\n    until input_io.eof? do\n      if StringIO === out_io and use_tempfile? out_io.size then\n        new_io = make_tempfile name\n        new_io.write out_io.string\n        out_io = new_io\n      end\n\n      chunk = input_io.read read_size\n      chunk = yield chunk if block_given?\n\n      out_io.write chunk\n    end\n\n    out_io.rewind\n\n    out_io\n  end\n\n  def inflate compressed, window_bits = nil\n    inflate = Zlib::Inflate.new window_bits\n\n    out_io = auto_io 'mechanize-inflate', 1024, compressed do |chunk|\n      inflate.inflate chunk\n    end\n\n    inflate.finish\n\n    out_io\n  ensure\n    inflate.close if inflate.finished?\n  end\n\n  def log\n    @context.log\n  end\n\n  ##\n  # Sets the proxy address, port, user, and password. +addr+ may be\n  # an HTTP URL/URI or a host name, +port+ may be a port number, service\n  # name or port number string.\n\n  def set_proxy addr, port = nil, user = nil, pass = nil\n    case addr\n    when URI::HTTP\n      proxy_uri = addr.dup\n    when %r{\\Ahttps?://}i\n      proxy_uri = URI addr\n    when String\n      proxy_uri = URI \"http://#{addr}\"\n    when nil\n      @http.proxy = nil\n      return\n    end\n\n    case port\n    when Integer\n      proxy_uri.port = port\n    when nil\n    else\n      begin\n        proxy_uri.port = Socket.getservbyname port\n      rescue SocketError\n        begin\n          proxy_uri.port = Integer port\n        rescue ArgumentError\n          raise ArgumentError, \"invalid value for port: #{port.inspect}\"\n        end\n      end\n    end\n\n    proxy_uri.user     = user if user\n    proxy_uri.password = pass if pass\n\n    @http.proxy = proxy_uri\n  end\n\n  def make_tempfile name\n    io = Tempfile.new name\n    io.unlink\n    io.binmode\n    io\n  end\n\n  def use_tempfile? size\n    return false unless @max_file_buffer\n    return false unless size\n\n    size >= @max_file_buffer\n  end\n\n  def reset\n    @cookie_jar.clear\n    @history.clear\n  end\n\nend\n\nrequire 'mechanize/http/auth_store'\n", "# coding: utf-8\n\nrequire 'mechanize/test_case'\n\nclass TestMechanizeHttpAgent < Mechanize::TestCase\n\n  def setup\n    super\n\n    @agent = @mech.agent\n\n    @uri = URI.parse 'http://example/'\n\n    @req = Net::HTTP::Get.new '/'\n    @res = Net::HTTPOK.allocate\n    @res.instance_variable_set :@code, 200\n    @res.instance_variable_set :@header, {}\n\n    @headers = %w[accept accept-encoding user-agent]\n  end\n\n  def auth_realm uri, scheme, type\n    base_uri = uri + '/'\n    realm = Mechanize::HTTP::AuthRealm.new scheme, base_uri, 'r'\n    @agent.authenticate_methods[base_uri][type] << realm\n\n    realm\n  end\n\n  def jruby_zlib?\n    if RUBY_ENGINE == 'jruby'\n      meth = caller[0][/`(\\w+)/, 1]\n      warn \"#{meth}: skipped because how Zlib handles error is different in JRuby\"\n      true\n    else\n      false\n    end\n  end\n\n  def test_agent_is_named\n    assert_equal 'mechanize', Mechanize::HTTP::Agent.new.http.name\n    assert_equal 'unique', Mechanize::HTTP::Agent.new('unique').http.name\n  end\n\n  def test_auto_io\n    Tempfile.open 'input' do |input_io|\n      input_io.binmode\n      input_io.write '12345'\n      input_io.rewind\n\n      out_io = @agent.auto_io @NAME, 1024, input_io\n\n      assert_equal '12345', out_io.string\n\n      assert_equal Encoding::BINARY, out_io.string.encoding if\n        Object.const_defined? :Encoding\n    end\n  end\n\n  def test_auto_io_chunk\n    Tempfile.open 'input' do |input_io|\n      chunks = []\n\n      input_io.binmode\n      input_io.write '12345'\n      input_io.rewind\n\n      @agent.auto_io @NAME, 1, input_io do |chunk|\n        chunks << chunk\n      end\n\n      assert_equal %w[1 2 3 4 5], chunks\n    end\n  end\n\n  def test_auto_io_tempfile\n    @agent.max_file_buffer = 3\n\n    Tempfile.open 'input' do |input_io|\n      input_io.binmode\n      input_io.write '12345'\n      input_io.rewind\n\n      out_io = @agent.auto_io @NAME, 1, input_io\n\n      result = out_io.read\n      assert_equal '12345', result\n\n      assert_equal Encoding::BINARY, result.encoding if\n        Object.const_defined? :Encoding\n    end\n  end\n\n  def test_auto_io_yield\n    Tempfile.open 'input' do |input_io|\n      input_io.binmode\n      input_io.write '12345'\n      input_io.rewind\n\n      out_io = @agent.auto_io @NAME, 1024, input_io do |chunk|\n        \"x#{chunk}\"\n      end\n\n      assert_equal 'x12345', out_io.string\n    end\n  end\n\n  def test_certificate_equals\n    cert_path = File.expand_path '../data/server.crt', __FILE__\n    cert = OpenSSL::X509::Certificate.new File.read cert_path\n\n    @agent.certificate = cert\n\n    assert_equal cert.to_pem, @agent.certificate.to_pem\n  end\n\n  def test_certificate_equals_file\n    cert_path = File.expand_path '../data/server.crt', __FILE__\n\n    cert = OpenSSL::X509::Certificate.new File.read cert_path\n\n    @agent.certificate = cert_path\n\n    assert_equal cert.to_pem, @agent.certificate.to_pem\n  end\n\n  def test_connection_for_file\n    uri = URI.parse 'file:///nonexistent'\n    conn = @agent.connection_for uri\n\n    assert_equal Mechanize::FileConnection.new, conn\n  end\n\n  def test_connection_for_http\n    conn = @agent.connection_for @uri\n\n    assert_equal @agent.http, conn\n  end\n\n  def test_disable_keep_alive\n    @agent.disable_keep_alive @req\n\n    refute @req['connection']\n  end\n\n  def test_disable_keep_alive_no\n    @agent.keep_alive = false\n\n    @agent.disable_keep_alive @req\n\n    assert_equal 'close', @req['connection']\n  end\n\n  def test_enable_gzip\n    @agent.enable_gzip @req\n\n    assert_equal 'gzip,deflate,identity', @req['accept-encoding']\n  end\n\n  def test_enable_gzip_no\n    @agent.gzip_enabled = false\n\n    @agent.enable_gzip @req\n\n    assert_equal 'identity', @req['accept-encoding']\n  end\n\n  def test_fetch_file_nonexistent\n    in_tmpdir do\n      nonexistent = File.join Dir.pwd, 'nonexistent'\n\n      uri = URI.parse \"file:///#{nonexistent}\"\n\n      e = assert_raises Mechanize::ResponseCodeError do\n        @agent.fetch uri\n      end\n\n      assert_match \"404 => Net::HTTPNotFound for #{uri}\", e.message\n    end\n  end\n\n  def test_fetch_file_plus\n    Tempfile.open '++plus++' do |io|\n      content = 'plusses +++'\n      io.write content\n      io.rewind\n\n      uri = URI.parse \"file://#{Mechanize::Util.uri_escape io.path}\"\n\n      page = @agent.fetch uri\n\n      assert_equal content, page.body\n      assert_kind_of Mechanize::File, page\n    end\n  end\n\n  def test_fetch_file_space\n    foo = File.expand_path(\"../htdocs/dir with spaces/foo.html\", __FILE__)\n\n    uri = URI.parse \"file://#{Mechanize::Util.uri_escape foo}\"\n\n    page = @agent.fetch uri\n\n    assert_equal File.read(foo), page.body.gsub(/\\r\\n/, \"\\n\")\n    assert_kind_of Mechanize::Page, page\n  end\n\n  def test_fetch_head_gzip\n    uri = @uri + '/gzip?file=index.html'\n\n    page = @agent.fetch uri, :head\n\n    assert_kind_of Mechanize::Page, page\n  end\n\n  def test_fetch_hooks\n    @agent.pre_connect_hooks << proc do |agent, request|\n      assert_equal '/index.html', request.path\n      assert_equal @agent, agent\n    end\n\n    @agent.post_connect_hooks << proc do |agent, uri, response, body|\n      assert_equal @agent, agent\n      assert_equal URI('http://example/index.html'), uri\n      assert_equal '200', response.code\n      assert_kind_of String, body\n    end\n\n    @agent.fetch URI 'http://example/index.html'\n  end\n\n  def test_fetch_ignore_bad_chunking\n    @agent.ignore_bad_chunking = true\n\n    file = @agent.fetch 'http://example/bad_chunking'\n\n    assert_equal '0123456789', file.content\n  end\n\n  def test_fetch_post_connect_hook\n    response = nil\n    @agent.post_connect_hooks << lambda { |_, _, res, _| response = res }\n\n    @agent.fetch 'http://localhost/'\n\n    assert response\n  end\n\n  def test_fetch_redirect_header\n    page = @agent.fetch('http://example/redirect', :get,\n                        'X-Location' => '/http_headers',\n                        'Range' => 'bytes=0-99999')\n\n    assert_match 'range|bytes=0-999', page.body\n  end\n\n  def test_fetch_server_error\n    e = assert_raises Mechanize::ResponseCodeError do\n      @mech.get 'http://localhost/response_code?code=500'\n    end\n\n    assert_equal '500', e.response_code\n  end\n\n  def test_fetch_allowed_error_codes\n    @agent.allowed_error_codes = ['500']\n\n    page = @mech.get 'http://localhost/response_code?code=500'\n\n    assert_equal '500', page.code\n  end\n\n  def test_fetch_allowed_error_codes_int\n    @agent.allowed_error_codes = [500]\n\n    page = @mech.get 'http://localhost/response_code?code=500'\n\n    assert_equal '500', page.code\n  end\n\n  def test_get_meta_refresh_header_follow_self\n    @agent.follow_meta_refresh = true\n    @agent.follow_meta_refresh_self = true\n\n    page = Mechanize::Page.new(@uri, nil, '', 200, @mech)\n    @res.instance_variable_set :@header, 'refresh' => ['0']\n\n    refresh = @agent.get_meta_refresh @res, @uri, page\n\n    assert_equal [0.0, URI('http://example/')], refresh\n  end\n\n  def test_get_meta_refresh_header_no_follow\n    page = Mechanize::Page.new(@uri, nil, '', 200, @mech)\n    @res.instance_variable_set :@header, 'refresh' => ['0']\n\n    refresh = @agent.get_meta_refresh @res, @uri, page\n\n    assert_nil refresh\n  end\n\n  def test_get_meta_refresh_header_no_follow_self\n    @agent.follow_meta_refresh = true\n\n    page = Mechanize::Page.new(@uri, nil, '', 200, @mech)\n    @res.instance_variable_set :@header, 'refresh' => ['0']\n\n    refresh = @agent.get_meta_refresh @res, @uri, page\n\n    assert_nil refresh\n  end\n\n  def test_get_meta_refresh_meta_follow_self\n    @agent.follow_meta_refresh = true\n    @agent.follow_meta_refresh_self = true\n\n    body = <<-BODY\n<title></title>\n<meta http-equiv=\"refresh\" content=\"0\">\n    BODY\n\n    page = Mechanize::Page.new(@uri, nil, body, 200, @mech)\n\n    refresh = @agent.get_meta_refresh @res, @uri, page\n\n    assert_equal [0, nil], refresh\n  end\n\n  def test_get_meta_refresh_meta_no_follow\n    body = <<-BODY\n<title></title>\n<meta http-equiv=\"refresh\" content=\"0\">\n    BODY\n\n    page = Mechanize::Page.new(@uri, nil, body, 200, @mech)\n\n    refresh = @agent.get_meta_refresh @res, @uri, page\n\n    assert_nil refresh\n  end\n\n  def test_get_meta_refresh_meta_no_follow_self\n    @agent.follow_meta_refresh = true\n\n    body = <<-BODY\n<title></title>\n<meta http-equiv=\"refresh\" content=\"0\">\n    BODY\n\n    page = Mechanize::Page.new(@uri, nil, body, 200, @mech)\n\n    refresh = @agent.get_meta_refresh @res, @uri, page\n\n    assert_nil refresh\n  end\n\n  def test_get_robots\n    robotstxt = @agent.get_robots 'http://localhost/robots.txt'\n    refute_equal '', robotstxt\n\n    robotstxt = @agent.get_robots 'http://localhost/response_code?code=404'\n    assert_equal '', robotstxt\n  end\n\n  def test_hook_content_encoding_response\n    @mech.content_encoding_hooks << lambda{|agent, uri, response, response_body_io|\n      response['content-encoding'] = 'gzip' if response['content-encoding'] == 'agzip'}\n\n    @res.instance_variable_set :@header, 'content-encoding' => %w[agzip]\n    body_io = StringIO.new 'part'\n    @agent.hook_content_encoding @res, @uri, body_io\n\n    assert_equal 'gzip', @res['content-encoding']\n  end\n\n  def test_http_request_file\n    uri = URI.parse 'file:///nonexistent'\n    request = @agent.http_request uri, :get\n\n    assert_kind_of Mechanize::FileRequest, request\n    assert_equal '/nonexistent', request.path\n  end\n\n  def test_http_request_get\n    request = @agent.http_request @uri, :get\n\n    assert_kind_of Net::HTTP::Get, request\n    assert_equal '/', request.path\n  end\n\n  def test_http_request_post\n    request = @agent.http_request @uri, :post\n\n    assert_kind_of Net::HTTP::Post, request\n    assert_equal '/', request.path\n  end\n\n  def test_idle_timeout_equals\n    @agent.idle_timeout = 1\n\n    assert_equal 1, @agent.http.idle_timeout\n  end\n\n  def test_inflate\n    body_io = StringIO.new \"x\\x9C+H,*\\x01\\x00\\x04?\\x01\\xB8\"\n\n    result = @agent.inflate body_io\n\n    assert_equal 'part', result.read\n  end\n\n  def test_post_connect\n    @agent.post_connect_hooks << proc { |agent, uri, response, body|\n      assert_equal @agent, agent\n      assert_equal @res, response\n      assert_equal 'body', body\n      throw :called\n    }\n\n    io = StringIO.new 'body'\n\n    assert_throws :called do\n      @agent.post_connect @uri, @res, io\n    end\n\n    assert_equal 0, io.pos\n  end\n\n  def test_pre_connect\n    @agent.pre_connect_hooks << proc { |agent, request|\n      assert_equal @agent, agent\n      assert_equal @req, request\n      throw :called\n    }\n\n    assert_throws :called do\n      @agent.pre_connect @req\n    end\n  end\n\n  def test_request_add_headers\n    @agent.request_add_headers @req, 'Content-Length' => 300\n\n    assert_equal '300', @req['content-length']\n  end\n\n  def test_request_add_headers_etag\n    @agent.request_add_headers @req, :etag => '300'\n\n    assert_equal '300', @req['etag']\n  end\n\n  def test_request_add_headers_if_modified_since\n    @agent.request_add_headers @req, :if_modified_since => 'some_date'\n\n    assert_equal 'some_date', @req['if-modified-since']\n  end\n\n  def test_request_add_headers_none\n    @agent.request_add_headers @req\n\n    assert_equal @headers, @req.to_hash.keys.sort\n  end\n\n  def test_request_add_headers_request_headers\n    @agent.request_headers['X-Foo'] = 'bar'\n\n    @agent.request_add_headers @req\n\n    assert_equal @headers + %w[x-foo], @req.to_hash.keys.sort\n  end\n\n  def test_request_add_headers_symbol\n    e = assert_raises ArgumentError do\n      @agent.request_add_headers @req, :content_length => 300\n    end\n\n    assert_equal 'unknown header symbol content_length', e.message\n  end\n\n  def test_request_auth_basic\n    @agent.add_auth @uri, 'user', 'password'\n\n    auth_realm @uri, 'Basic', :basic\n\n    @agent.request_auth @req, @uri\n\n    assert_match %r%^Basic %, @req['Authorization']\n  end\n\n  def test_request_auth_digest\n    @agent.add_auth @uri, 'user', 'password'\n\n    realm = auth_realm @uri, 'Digest', :digest\n    @agent.digest_challenges[realm] = 'Digest realm=r, qop=\"auth\"'\n\n    @agent.request_auth @req, @uri\n\n    assert_match %r%^Digest %, @req['Authorization']\n    assert_match %r%qop=auth%, @req['Authorization']\n\n    @req['Authorization'] = nil\n    @agent.request_auth @req, @uri\n\n    assert_match %r%^Digest %, @req['Authorization']\n    assert_match %r%qop=auth%, @req['Authorization']\n  end\n\n  def test_request_auth_iis_digest\n    @agent.add_auth @uri, 'user', 'password'\n\n    realm = auth_realm @uri, 'Digest', :digest\n    @agent.digest_challenges[realm] = 'Digest realm=r, qop=\"auth\"'\n\n    @agent.request_auth @req, @uri\n\n    assert_match %r%^Digest %, @req['Authorization']\n    assert_match %r%qop=auth%, @req['Authorization']\n  end\n\n  def test_request_auth_none\n    @agent.request_auth @req, @uri\n\n    assert_nil @req['Authorization']\n  end\n\n  def test_request_cookies\n    uri = URI.parse 'http://host.example.com'\n    @agent.cookie_jar.parse 'hello=world domain=.example.com', uri\n\n    @agent.request_cookies @req, uri\n\n    assert_equal 'hello=\"world domain=.example.com\"', @req['Cookie']\n  end\n\n  def test_request_cookies_many\n    uri = URI.parse 'http://host.example.com'\n    cookie_str = 'a=b domain=.example.com, c=d domain=.example.com'\n    @agent.cookie_jar.parse cookie_str, uri\n\n    @agent.request_cookies @req, uri\n\n    expected_variant1 = /a=\"b domain=\\.example\\.com\"; c=\"d domain=\\.example\\.com\"/\n    expected_variant2 = /c=\"d domain=\\.example\\.com\"; a=\"b domain=\\.example\\.com\"/\n\n    assert_match(/^(#{expected_variant1}|#{expected_variant2})$/, @req['Cookie'])\n  end\n\n  def test_request_cookies_none\n    @agent.request_cookies @req, @uri\n\n    assert_nil @req['Cookie']\n  end\n\n  def test_request_cookies_wrong_domain\n    uri = URI.parse 'http://host.example.com'\n    @agent.cookie_jar.parse 'hello=world domain=.example.com', uri\n\n    @agent.request_cookies @req, @uri\n\n    assert_nil @req['Cookie']\n  end\n\n  def test_request_host\n    @agent.request_host @req, @uri\n\n    assert_equal 'example', @req['host']\n  end\n\n  def test_request_host_nonstandard\n    @uri.port = 81\n\n    @agent.request_host @req, @uri\n\n    assert_equal 'example:81', @req['host']\n  end\n\n  def test_request_language_charset\n    @agent.request_language_charset @req\n\n    assert_equal 'en-us,en;q=0.5', @req['accept-language']\n    assert_equal 'ISO-8859-1,utf-8;q=0.7,*;q=0.7', @req['accept-charset']\n  end\n\n  def test_request_referer\n    referer = URI.parse 'http://old.example'\n\n    @agent.request_referer @req, @uri, referer\n\n    assert_equal 'http://old.example', @req['referer']\n  end\n\n  def test_request_referer_https\n    uri = URI.parse 'https://example'\n    referer = URI.parse 'https://old.example'\n\n    @agent.request_referer @req, uri, referer\n\n    assert_equal 'https://old.example', @req['referer']\n  end\n\n  def test_request_referer_https_downgrade\n    referer = URI.parse 'https://old.example'\n\n    @agent.request_referer @req, @uri, referer\n\n    assert_nil @req['referer']\n  end\n\n  def test_request_referer_https_downgrade_case\n    uri = URI.parse 'http://example'\n    referer = URI.parse 'httpS://old.example'\n\n    @agent.request_referer @req, uri, referer\n\n    assert_nil @req['referer']\n  end\n\n  def test_request_referer_https_upgrade\n    uri = URI.parse 'https://example'\n    referer = URI.parse 'http://old.example'\n\n    @agent.request_referer @req, uri, referer\n\n    assert_equal 'http://old.example', @req['referer']\n  end\n\n  def test_request_referer_none\n    @agent.request_referer @req, @uri, nil\n\n    assert_nil @req['referer']\n  end\n\n  def test_request_referer_strip\n    uri = URI.parse 'http://example.com/index.html'\n\n    host_path = \"old.example/page.html?q=x\"\n    referer = \"http://#{host_path}\"\n\n    [\n      \"\",\n      \"@\",\n      \"user1@\",\n      \":@\",\n      \"user1:@\",\n      \":password1@\",\n      \"user1:password1@\",\n    ].each { |userinfo|\n      ['', '#frag'].each { |frag|\n        url = URI.parse \"http://#{userinfo}#{host_path}#{frag}\"\n\n        @agent.request_referer @req, uri, url\n\n        assert_equal referer, @req['referer'], url\n      }\n    }\n  end\n\n  def test_request_user_agent\n    @agent.request_user_agent @req\n\n    assert_match %r%^Mechanize/#{Mechanize::VERSION}%, @req['user-agent']\n\n    ruby_version = if RUBY_PATCHLEVEL >= 0 then\n                     \"#{RUBY_VERSION}p#{RUBY_PATCHLEVEL}\"\n                   else\n                     \"#{RUBY_VERSION}dev#{RUBY_REVISION}\"\n                   end\n\n    assert_match %r%Ruby/#{ruby_version}%, @req['user-agent']\n  end\n\n  def test_resolve_bad_uri\n    e = assert_raises ArgumentError do\n      @agent.resolve 'google'\n    end\n\n    assert_equal 'absolute URL needed (not google)', e.message\n  end\n\n  def test_resolve_uri_without_path\n    e = assert_raises ArgumentError do\n      @agent.resolve 'http:%5C%5Cfoo'\n    end\n\n    assert_equal 'hierarchical URL needed (not http:%5C%5Cfoo)', e.message\n  end\n\n  def test_resolve_utf8\n    uri = 'http://example?q=\u00fc'\n\n    resolved = @agent.resolve uri\n\n    assert_equal '/?q=%C3%BC', resolved.request_uri\n  end\n\n  def test_resolve_parameters_body\n    input_params = { :q => 'hello' }\n\n    uri, params = @agent.resolve_parameters @uri, :post, input_params\n\n    assert_equal 'http://example/', uri.to_s\n    assert_equal input_params, params\n  end\n\n  def test_resolve_parameters_query\n    uri, params = @agent.resolve_parameters @uri, :get, :q => 'hello'\n\n    assert_equal 'http://example/?q=hello', uri.to_s\n    assert_nil params\n  end\n\n  def test_resolve_parameters_query_append\n    input_params = { :q => 'hello' }\n    @uri.query = 'a=b'\n\n    uri, params = @agent.resolve_parameters @uri, :get, input_params\n\n    assert_equal 'http://example/?a=b&q=hello', uri.to_s\n    assert_nil params\n  end\n\n  def test_resolve_slashes\n    page = Mechanize::Page.new URI('http://example/foo/'), nil, '', 200, @mech\n    uri = '/bar/http://example/test/'\n\n    resolved = @agent.resolve uri, page\n\n    assert_equal 'http://example/bar/http://example/test/', resolved.to_s\n  end\n\n  def test_response_authenticate\n    @agent.add_auth @uri, 'user', 'password'\n\n    @res.instance_variable_set :@header, 'www-authenticate' => ['Basic realm=r']\n\n    @agent.response_authenticate @res, nil, @uri, @req, {}, nil, nil\n\n    base_uri = @uri + '/'\n    realm = Mechanize::HTTP::AuthRealm.new 'Basic', base_uri, 'r'\n    assert_equal [realm], @agent.authenticate_methods[base_uri][:basic]\n  end\n\n  def test_response_authenticate_digest\n    @agent.add_auth @uri, 'user', 'password'\n\n    @res.instance_variable_set(:@header,\n                               'www-authenticate' => ['Digest realm=r'])\n\n    @agent.response_authenticate @res, nil, @uri, @req, {}, nil, nil\n\n    base_uri = @uri + '/'\n    realm = Mechanize::HTTP::AuthRealm.new 'Digest', base_uri, 'r'\n    assert_equal [realm], @agent.authenticate_methods[base_uri][:digest]\n\n    challenge = Mechanize::HTTP::AuthChallenge.new('Digest',\n                                                   { 'realm' => 'r' },\n                                                   'Digest realm=r')\n\n    assert_equal challenge, @agent.digest_challenges[realm]\n  end\n\n  def test_response_authenticate_digest_iis\n    @agent.add_auth @uri, 'user', 'password'\n\n    @res.instance_variable_set(:@header,\n                               'www-authenticate' => ['Digest realm=r'],\n                               'server'           => ['Microsoft-IIS'])\n    @agent.response_authenticate @res, nil, @uri, @req, {}, nil, nil\n\n    base_uri = @uri + '/'\n    realm = Mechanize::HTTP::AuthRealm.new 'Digest', base_uri, 'r'\n    assert_equal [realm], @agent.authenticate_methods[base_uri][:iis_digest]\n  end\n\n  def test_response_authenticate_multiple\n    @agent.add_auth @uri, 'user', 'password'\n\n    @res.instance_variable_set(:@header,\n                               'www-authenticate' =>\n                                 ['Basic realm=r, Digest realm=r'])\n\n    @agent.response_authenticate @res, nil, @uri, @req, {}, nil, nil\n\n    base_uri = @uri + '/'\n    realm = Mechanize::HTTP::AuthRealm.new 'Digest', base_uri, 'r'\n    assert_equal [realm], @agent.authenticate_methods[base_uri][:digest]\n\n    assert_empty @agent.authenticate_methods[base_uri][:basic]\n  end\n\n  def test_response_authenticate_no_credentials\n    @res.instance_variable_set :@header, 'www-authenticate' => ['Basic realm=r']\n\n    e = assert_raises Mechanize::UnauthorizedError do\n      @agent.response_authenticate @res, fake_page, @uri, @req, {}, nil, nil\n    end\n\n    assert_match 'no credentials', e.message\n    assert_match 'available realms: r', e.message\n  end\n\n  def test_response_authenticate_no_www_authenticate\n    @agent.add_auth @uri, 'user', 'password'\n\n    denied_uri = URI('http://example/denied')\n\n    denied = page denied_uri, 'text/html', '', 401\n\n    e = assert_raises Mechanize::UnauthorizedError do\n      @agent.response_authenticate @res, denied, @uri, @req, {}, nil, nil\n    end\n\n    assert_equal \"401 => Net::HTTPUnauthorized for #{denied_uri} -- \" \\\n                 \"WWW-Authenticate header missing in response\",\n                 e.message\n  end\n\n  def test_response_authenticate_ntlm\n    @uri += '/ntlm'\n    @agent.add_auth @uri, 'user', 'password'\n\n    @res.instance_variable_set(:@header,\n                               'www-authenticate' => ['Negotiate, NTLM'])\n\n    page = @agent.response_authenticate @res, nil, @uri, @req, {}, nil, nil\n\n    assert_equal 'ok', page.body # lame test\n  end\n\n  def test_response_authenticate_unknown\n    @agent.add_auth @uri, 'user', 'password'\n\n    page = Mechanize::File.new nil, nil, nil, 401\n    @res.instance_variable_set(:@header,\n                               'www-authenticate' => ['Unknown realm=r'])\n\n    assert_raises Mechanize::UnauthorizedError do\n      @agent.response_authenticate @res, page, @uri, @req, nil, nil, nil\n    end\n  end\n\n  def test_response_content_encoding_7_bit\n    @res.instance_variable_set :@header, 'content-encoding' => %w[7bit]\n\n    body = @agent.response_content_encoding @res, StringIO.new('part')\n\n    assert_equal 'part', body.read\n  end\n\n  def test_response_content_encoding_deflate\n    @res.instance_variable_set :@header, 'content-encoding' => %w[deflate]\n    body_io = StringIO.new \"x\\x9C+H,*\\x01\\x00\\x04?\\x01\\xB8\"\n\n    body = @agent.response_content_encoding @res, body_io\n\n    assert_equal 'part', body.read\n\n    assert body_io.closed?\n  end\n\n  def test_response_content_encoding_deflate_chunked\n    @res.instance_variable_set :@header, 'content-encoding' => %w[deflate]\n    body_io = StringIO.new \"x\\x9C+H,*\\x01\\x00\\x04?\\x01\\xB8\"\n\n    body = @agent.response_content_encoding @res, body_io\n\n    assert_equal 'part', body.read\n  end\n\n  def test_response_content_encoding_deflate_corrupt\n    @res.instance_variable_set :@header, 'content-encoding' => %w[deflate]\n    body_io = StringIO.new \"x\\x9C+H,*\\x01\\x00\\x04?\\x01\" # missing 1 byte\n\n    e = assert_raises Mechanize::Error do\n      @agent.response_content_encoding @res, body_io\n    end\n\n    assert_match %r%error handling content-encoding deflate:%, e.message\n    assert_match %r%Zlib%, e.message\n\n    assert body_io.closed?\n  end\n\n  def test_response_content_encoding_deflate_empty\n    @res.instance_variable_set :@header, 'content-encoding' => %w[deflate]\n\n    body = @agent.response_content_encoding @res, StringIO.new\n\n    assert_equal '', body.read\n  end\n\n  # IIS/6.0 ASP.NET/2.0.50727 does not wrap deflate with zlib, WTF?\n  def test_response_content_encoding_deflate_no_zlib\n    @res.instance_variable_set :@header, 'content-encoding' => %w[deflate]\n\n    body = @agent.response_content_encoding @res, StringIO.new(\"+H,*\\001\\000\")\n\n    assert_equal 'part', body.read\n  end\n\n  def test_response_content_encoding_gzip\n    @res.instance_variable_set :@header, 'content-encoding' => %w[gzip]\n    body_io = StringIO.new \\\n      \"\\037\\213\\b\\0002\\002\\225M\\000\\003+H,*\\001\\000\\306p\\017I\\004\\000\\000\\000\"\n\n    body = @agent.response_content_encoding @res, body_io\n\n    assert_equal 'part', body.read\n\n    assert body_io.closed?\n  end\n\n  def test_response_content_encoding_gzip_chunked\n    def @res.content_length() nil end\n    @res.instance_variable_set :@header, 'content-encoding' => %w[gzip]\n    body_io = StringIO.new \\\n      \"\\037\\213\\b\\0002\\002\\225M\\000\\003+H,*\\001\\000\\306p\\017I\\004\\000\\000\\000\"\n\n    body = @agent.response_content_encoding @res, body_io\n\n    assert_equal 'part', body.read\n  end\n\n  def test_response_content_encoding_gzip_corrupt\n    log = StringIO.new\n    logger = Logger.new log\n    @agent.context.log = logger\n\n    @res.instance_variable_set :@header, 'content-encoding' => %w[gzip]\n    body_io = StringIO.new \\\n      \"\\037\\213\\b\\0002\\002\\225M\\000\\003+H,*\\001\"\n\n    skip if jruby_zlib?\n\n    e = assert_raises Mechanize::Error do\n      @agent.response_content_encoding @res, body_io\n    end\n\n    assert_match %r%error handling content-encoding gzip:%, e.message\n    assert_match %r%Zlib%, e.message\n\n    assert_match %r%unable to gunzip response: unexpected end of file%,\n                 log.string\n    assert_match %r%unable to inflate response: buffer error%,\n                 log.string\n\n    assert body_io.closed?\n  end\n\n  def test_response_content_encoding_gzip_checksum_corrupt_crc\n    log = StringIO.new\n    logger = Logger.new log\n    @agent.context.log = logger\n\n    @res.instance_variable_set :@header, 'content-encoding' => %w[gzip]\n    body_io = StringIO.new \\\n      \"\\037\\213\\b\\0002\\002\\225M\\000\\003+H,*\\001\\000\\306p\\017J\\004\\000\\000\\000\"\n\n    body = @agent.response_content_encoding @res, body_io\n\n    assert_equal 'part', body.read\n\n    assert body_io.closed?\n\n    assert_match %r%invalid compressed data -- crc error%, log.string\n  rescue IOError\n    raise unless jruby_zlib?\n  end\n\n  def test_response_content_encoding_gzip_checksum_corrupt_length\n    log = StringIO.new\n    logger = Logger.new log\n    @agent.context.log = logger\n\n    @res.instance_variable_set :@header, 'content-encoding' => %w[gzip]\n    body_io = StringIO.new \\\n      \"\\037\\213\\b\\0002\\002\\225M\\000\\003+H,*\\001\\000\\306p\\017I\\005\\000\\000\\000\"\n\n    @agent.response_content_encoding @res, body_io\n\n    assert body_io.closed?\n\n    assert_match %r%invalid compressed data -- length error%, log.string\n  rescue IOError\n    raise unless jruby_zlib?\n  end\n\n  def test_response_content_encoding_gzip_checksum_truncated\n    log = StringIO.new\n    logger = Logger.new log\n    @agent.context.log = logger\n\n    @res.instance_variable_set :@header, 'content-encoding' => %w[gzip]\n    body_io = StringIO.new \\\n      \"\\037\\213\\b\\0002\\002\\225M\\000\\003+H,*\\001\\000\\306p\\017I\\004\\000\\000\"\n\n    @agent.response_content_encoding @res, body_io\n\n    assert body_io.closed?\n\n    assert_match %r%unable to gunzip response: footer is not found%, log.string\n  rescue IOError\n    raise unless jruby_zlib?\n  end\n\n  def test_response_content_encoding_gzip_empty\n    @res.instance_variable_set :@header, 'content-encoding' => %w[gzip]\n\n    body = @agent.response_content_encoding @res, StringIO.new\n\n    assert_equal '', body.read\n  end\n\n  def test_response_content_encoding_gzip_encoding_bad\n    @res.instance_variable_set(:@header,\n                               'content-encoding' => %w[gzip],\n                               'content-type' => 'text/html; charset=UTF-8')\n\n    # \"test\\xB2\"\n    body_io = StringIO.new \\\n      \"\\037\\213\\b\\000*+\\314N\\000\\003+I-.\\331\\004\\000x\\016\\003\\376\\005\\000\\000\\000\"\n\n    body = @agent.response_content_encoding @res, body_io\n\n    expected = \"test\\xB2\"\n    expected.force_encoding Encoding::BINARY if have_encoding?\n\n    content = body.read\n    assert_equal expected, content\n    assert_equal Encoding::BINARY, content.encoding if have_encoding?\n  end\n\n  def test_response_content_encoding_gzip_no_footer\n    @res.instance_variable_set :@header, 'content-encoding' => %w[gzip]\n    body_io = StringIO.new \\\n      \"\\037\\213\\b\\0002\\002\\225M\\000\\003+H,*\\001\\000\"\n\n    body = @agent.response_content_encoding @res, body_io\n\n    assert_equal 'part', body.read\n\n    assert body_io.closed?\n  rescue IOError\n    raise unless jruby_zlib?\n  end\n\n  def test_response_content_encoding_none\n    @res.instance_variable_set :@header, 'content-encoding' => %w[none]\n\n    body = @agent.response_content_encoding @res, StringIO.new('part')\n\n    assert_equal 'part', body.read\n  end\n\n  def test_response_content_encoding_empty_string\n    @res.instance_variable_set :@header, 'content-encoding' => %w[]\n\n    body = @agent.response_content_encoding @res, StringIO.new('part')\n\n    assert_equal 'part', body.read\n  end\n\n  def test_response_content_encoding_identity\n    @res.instance_variable_set :@header, 'content-encoding' => %w[identity]\n\n    body = @agent.response_content_encoding @res, StringIO.new('part')\n\n    assert_equal 'part', body.read\n  end\n\n  def test_response_content_encoding_tempfile_7_bit\n    body_io = tempfile 'part'\n\n    @res.instance_variable_set :@header, 'content-encoding' => %w[7bit]\n\n    body = @agent.response_content_encoding @res, body_io\n\n    assert_equal 'part', body.read\n    refute body_io.closed?\n  ensure\n    begin\n      body_io.close! if body_io and not body_io.closed?\n    rescue IOError\n      # HACK for ruby 1.8\n    end\n  end\n\n  def test_response_content_encoding_tempfile_gzip\n    body_io = tempfile \"x\\x9C+H,*\\x01\\x00\\x04?\\x01\\xB8\"\n    @res.instance_variable_set :@header, 'content-encoding' => %w[deflate]\n\n    body = @agent.response_content_encoding @res, body_io\n\n    assert_equal 'part', body.read\n    assert body_io.closed?\n  ensure\n    body_io.close! if body_io and not body_io.closed?\n  end\n\n  def test_response_content_encoding_unknown\n    @res.instance_variable_set :@header, 'content-encoding' => %w[unknown]\n    body = StringIO.new 'part'\n\n    e = assert_raises Mechanize::Error do\n      @agent.response_content_encoding @res, body\n    end\n\n    assert_equal 'unsupported content-encoding: unknown', e.message\n  end\n\n  def test_response_content_encoding_x_gzip\n    @res.instance_variable_set :@header, 'content-encoding' => %w[x-gzip]\n    body_io = StringIO.new \\\n      \"\\037\\213\\b\\0002\\002\\225M\\000\\003+H,*\\001\\000\\306p\\017I\\004\\000\\000\\000\"\n\n    body = @agent.response_content_encoding @res, body_io\n\n    assert_equal 'part', body.read\n  end\n\n  def test_response_cookies\n    uri = URI.parse 'http://host.example.com'\n    cookie_str = 'a=b domain=.example.com'\n    @res.instance_variable_set(:@header,\n                               'set-cookie' => [cookie_str],\n                               'content-type' => %w[text/html])\n    page = Mechanize::Page.new uri, @res, '', 200, @mech\n\n    @agent.response_cookies @res, uri, page\n\n    assert_equal ['a=\"b domain=.example.com\"'],\n                 @agent.cookie_jar.cookies(uri).map { |c| c.to_s }\n  end\n\n  def test_response_cookies_many\n    uri = URI.parse 'http://host.example.com'\n    cookie1 = 'a=b domain=.example.com'\n    cookie2 = 'c=d domain=.example.com'\n    cookies = [cookie1, cookie2]\n    @res.instance_variable_set(:@header,\n                               'set-cookie' => cookies,\n                               'content-type' => %w[text/html])\n    page = Mechanize::Page.new uri, @res, '', 200, @mech\n\n    @agent.response_cookies @res, uri, page\n\n    cookies_from_jar = @agent.cookie_jar.cookies(uri)\n\n    assert_equal 2, cookies_from_jar.length\n    assert_equal [\n      'a=\"b domain=.example.com\"',\n      'c=\"d domain=.example.com\"',\n    ], cookies_from_jar.sort_by { |c| c.name }.map(&:to_s)\n  end\n\n  def test_response_cookies_meta\n    uri = URI.parse 'http://host.example.com'\n    cookie_str = 'a=b domain=.example.com'\n\n    body = <<-BODY\n<head>\n  <meta http-equiv=\"Set-Cookie\" content=\"#{cookie_str}\">\n</head>\"\n    BODY\n\n    @res.instance_variable_set(:@header,\n                               'content-type' => %w[text/html])\n    page = Mechanize::Page.new uri, @res, body, 200, @mech\n\n    @agent.response_cookies @res, uri, page\n\n    assert_equal ['a=\"b domain=.example.com\"'],\n                 @agent.cookie_jar.cookies(uri).map { |c| c.to_s }\n  end\n\n  def test_response_cookies_meta_bogus\n    uri = URI.parse 'http://host.example.com'\n\n    body = <<-BODY\n<head>\n  <meta http-equiv=\"Set-Cookie\">\n</head>\"\n    BODY\n\n    @res.instance_variable_set(:@header,\n                               'content-type' => %w[text/html])\n    page = Mechanize::Page.new uri, @res, body, 200, @mech\n\n    @agent.response_cookies @res, uri, page\n\n    assert_empty @agent.cookie_jar.cookies(uri)\n  end\n\n  def test_response_follow_meta_refresh\n    uri = URI.parse 'http://example/#id+1'\n\n    body = <<-BODY\n<title></title>\n<meta http-equiv=\"refresh\" content=\"0\">\n    BODY\n\n    page = Mechanize::Page.new(uri, nil, body, 200, @mech)\n\n    @agent.follow_meta_refresh = true\n    @agent.follow_meta_refresh_self = true\n\n    page = @agent.response_follow_meta_refresh @res, uri, page, 0\n\n    assert_equal uri, page.uri\n  end\n\n  def test_response_follow_meta_refresh_limit\n    uri = URI.parse 'http://example/#id+1'\n\n    body = <<-BODY\n<title></title>\n<meta http-equiv=\"refresh\" content=\"0\">\n    BODY\n\n    page = Mechanize::Page.new(uri, nil, body, 200, @mech)\n\n    @agent.follow_meta_refresh = true\n    @agent.follow_meta_refresh_self = true\n\n    assert_raises Mechanize::RedirectLimitReachedError do\n      @agent.response_follow_meta_refresh(@res, uri, page,\n                                          @agent.redirection_limit)\n    end\n  end\n\n  def test_response_meta_refresh_with_insecure_url\n    uri = URI.parse 'http://example/#id+1'\n\n    body = <<-BODY\n<title></title>\n<meta http-equiv=\"refresh\" content=\"0; url=file:///dev/zero\">\n    BODY\n\n    page = Mechanize::Page.new(uri, nil, body, 200, @mech)\n\n    @agent.follow_meta_refresh = true\n\n    assert_raises Mechanize::Error do\n      @agent.response_follow_meta_refresh(@res, uri, page,\n                                          @agent.redirection_limit)\n    end\n  end\n\n  def test_response_parse\n    body = '<title>hi</title>'\n    @res.instance_variable_set :@header, 'content-type' => %w[text/html]\n\n    page = @agent.response_parse @res, body, @uri\n\n    assert_instance_of Mechanize::Page, page\n    assert_equal @mech, page.mech\n  end\n\n  def test_response_parse_content_type_case\n    body = '<title>hi</title>'\n    @res.instance_variable_set(:@header, 'content-type' => %w[text/HTML])\n\n    page = @agent.response_parse @res, body, @uri\n\n    assert_instance_of Mechanize::Page, page\n\n    assert_equal 'text/HTML', page.content_type\n  end\n\n  def test_response_parse_content_type_encoding\n    body = '<title>hi</title>'\n    @res.instance_variable_set(:@header,\n                               'content-type' =>\n                                 %w[text/html;charset=ISO-8859-1])\n\n    page = @agent.response_parse @res, body, @uri\n\n    assert_instance_of Mechanize::Page, page\n    assert_equal @mech, page.mech\n\n    assert_equal 'ISO-8859-1', page.encoding\n    assert_equal 'ISO-8859-1', page.parser.encoding\n  end\n\n  def test_response_parse_content_type_encoding_broken_iso_8859_1\n    body = '<title>hi</title>'\n    @res.instance_variable_set(:@header,\n                               'content-type' =>\n                                 %w[text/html; charset=ISO_8859-1])\n\n    page = @agent.response_parse @res, body, @uri\n\n    assert_instance_of Mechanize::Page, page\n    assert_equal 'ISO_8859-1', page.encoding\n  end\n\n  def test_response_parse_content_type_encoding_broken_utf_8\n    body = '<title>hi</title>'\n    @res.instance_variable_set(:@header,\n                               'content-type' =>\n                                 %w[text/html; charset=UTF8])\n\n    page = @agent.response_parse @res, body, @uri\n\n    assert_instance_of Mechanize::Page, page\n    assert_equal 'UTF8', page.encoding\n    assert_equal 'UTF8', page.parser.encoding\n  end\n\n  def test_response_parse_content_type_encoding_garbage\n    body = '<title>hi</title>'\n    @res.instance_variable_set(:@header,\n                               'content-type' =>\n                                 %w[text/html; charset=garbage_charset])\n\n    page = @agent.response_parse @res, body, @uri\n\n    assert_instance_of Mechanize::Page, page\n    assert_equal @mech, page.mech\n  end\n\n  def test_response_parse_content_type_encoding_semicolon\n    body = '<title>hi</title>'\n    @res.instance_variable_set(:@header,\n                               'content-type' =>\n                                 %w[text/html;charset=UTF-8;])\n\n    page = @agent.response_parse @res, body, @uri\n\n    assert_instance_of Mechanize::Page, page\n\n    assert_equal 'UTF-8', page.encoding\n  end\n\n  def test_response_read\n    def @res.read_body() yield 'part' end\n    def @res.content_length() 4 end\n\n    io = @agent.response_read @res, @req, @uri\n\n    body = io.read\n\n    assert_equal 'part', body\n    assert_equal Encoding::BINARY, body.encoding\n  end\n\n  def test_response_read_chunked_no_trailer\n    @res['Transfer-Encoding'] = 'chunked'\n    def @res.content_length() end\n    def @res.read_body\n      yield 'a' * 10\n      raise EOFError\n    end\n\n    e = assert_raises Mechanize::ChunkedTerminationError do\n      @agent.response_read @res, @req, @uri\n    end\n\n    assert_equal 'aaaaaaaaaa', e.body_io.read\n  end\n\n  def test_response_read_content_length_head\n    req = Net::HTTP::Head.new '/'\n\n    def @res.content_length() end\n    def @res.read_body() end\n\n    io = @agent.response_read @res, req, @uri\n\n    assert_equal '', io.read\n  end\n\n  def test_response_read_content_length_mismatch\n    def @res.content_length() 5 end\n    def @res.read_body() yield 'part' end\n\n    e = assert_raises Mechanize::ResponseReadError do\n      @agent.response_read @res, @req, @uri\n    end\n\n    assert_equal 'Content-Length (5) does not match response body length (4)' \\\n      ' (Mechanize::ResponseReadError)', e.message\n  end\n\n  def test_response_read_content_length_redirect\n    res = Net::HTTPFound.allocate\n    def res.content_length() 5 end\n    def res.code() 302 end\n    def res.read_body() yield 'part' end\n    res.instance_variable_set :@header, {}\n\n    io = @agent.response_read res, @req, @uri\n\n    assert_equal 'part', io.read\n  end\n\n  def test_response_read_error\n    def @res.read_body()\n      yield 'part'\n      raise Net::HTTP::Persistent::Error\n    end\n\n    e = assert_raises Mechanize::ResponseReadError do\n      @agent.response_read @res, @req, @uri\n    end\n\n    assert_equal @res, e.response\n    assert_equal 'part', e.body_io.read\n    assert_kind_of Net::HTTP::Persistent::Error, e.error\n  end\n\n  def test_response_read_file\n    Tempfile.open 'pi.txt' do |tempfile|\n      tempfile.write \"\u03c0\\n\"\n      tempfile.flush\n      tempfile.rewind\n\n      uri = URI.parse \"file://#{tempfile.path}\"\n      req = Mechanize::FileRequest.new uri\n      res = Mechanize::FileResponse.new tempfile.path\n\n      io = @agent.response_read res, req, uri\n\n      expected = \"\u03c0\\n\".force_encoding(Encoding::BINARY)\n\n      # Ruby 1.8.7 doesn't let us set the write mode of the tempfile to binary,\n      # so we should expect an inserted carriage return on some platforms\n      expected_with_carriage_return = \"\u03c0\\r\\n\".force_encoding(Encoding::BINARY)\n\n      body = io.read\n      assert_match(/^(#{expected}|#{expected_with_carriage_return})$/m, body)\n      assert_equal Encoding::BINARY, body.encoding\n    end\n  end\n\n  def test_response_read_large\n    @agent.max_file_buffer = 10240\n\n    def @res.read_body() yield 'a' * 10241 end\n    def @res.content_length() 10241 end\n\n    io = @agent.response_read @res, @req, @uri\n\n    assert_kind_of Tempfile, io\n    assert_equal 10241, io.stat.size\n  end\n\n  def test_response_read_large_chunked\n    @agent.max_file_buffer = 10240\n\n    def @res.read_body\n      11.times do yield 'a' * 1024 end\n    end\n    def @res.content_length() end\n\n    io = @agent.response_read @res, @req, @uri\n\n    assert_kind_of Tempfile, io\n    assert_equal 11264, io.stat.size\n  end\n\n  def test_response_read_no_body\n    req = Net::HTTP::Options.new '/'\n\n    def @res.content_length() end\n    def @res.read_body() end\n\n    io = @agent.response_read @res, req, @uri\n\n    assert_equal '', io.read\n  end\n\n  def test_response_read_unknown_code\n    res = Net::HTTPUnknownResponse.allocate\n    res.instance_variable_set :@code, 9999\n    res.instance_variable_set :@header, {}\n    def res.read_body() yield 'part' end\n\n    e = assert_raises Mechanize::ResponseCodeError do\n      @agent.response_read res, @req, @uri\n    end\n\n    assert_equal res, e.page\n  end\n\n  def test_response_redirect\n    @agent.redirect_ok = true\n    referer = page 'http://example/referer'\n\n    page = fake_page\n    page = @agent.response_redirect({ 'Location' => '/index.html' }, :get,\n                                    page, 0, {}, referer)\n\n    assert_equal URI('http://fake.example/index.html'), page.uri\n\n    assert_equal 'http://example/referer', requests.first['Referer']\n  end\n\n  def test_response_redirect_header\n    @agent.redirect_ok = true\n    referer = page 'http://example/referer'\n\n    headers = {\n      'Range' => 'bytes=0-9999',\n      'Content-Type' => 'application/x-www-form-urlencoded',\n      'CONTENT-LENGTH' => '9999',\n      'content-md5' => '14758f1afd44c09b7992073ccf00b43d',\n    }\n\n    page = fake_page\n    page = @agent.response_redirect({ 'Location' => '/http_headers' }, :get,\n                                    page, 0, headers, referer)\n\n    assert_equal URI('http://fake.example/http_headers'), page.uri\n\n    assert_match 'range|bytes=0-9999', page.body\n    refute_match 'content-type|application/x-www-form-urlencoded', page.body\n    refute_match 'content-length|9999', page.body\n    refute_match 'content-md5|14758f1afd44c09b7992073ccf00b43d', page.body\n  end\n\n  def test_response_redirect_malformed\n    @agent.redirect_ok = true\n    referer = page 'http://example/referer'\n\n    page = fake_page\n    page = @agent.response_redirect({ 'Location' => '/index.html?q=\u3042' }, :get,\n                                    page, 0, {}, referer)\n\n    assert_equal URI('http://fake.example/index.html?q=%E3%81%82'), page.uri\n\n    assert_equal 'http://example/referer', requests.first['Referer']\n  end\n\n  def test_response_redirect_insecure\n    @agent.redirect_ok = true\n    referer = page 'http://example/referer'\n\n    assert_raises Mechanize::Error do\n      @agent.response_redirect({ 'Location' => 'file:///etc/passwd' }, :get,\n                               fake_page, 0, {}, referer)\n    end\n  end\n\n  def test_response_redirect_limit\n    @agent.redirect_ok = true\n    referer = page 'http://example/referer'\n\n    assert_raises Mechanize::RedirectLimitReachedError do\n      @agent.response_redirect({ 'Location' => '/index.html' }, :get,\n                               fake_page, @agent.redirection_limit, {}, referer)\n    end\n  end\n\n  def test_response_redirect_to_cross_site_with_credential\n    @agent.redirect_ok = true\n\n    headers = {\n      'Range' => 'bytes=0-9999',\n      'AUTHORIZATION' => 'Basic xxx',\n      'cookie' => 'name=value',\n    }\n\n    page = html_page ''\n    page = @agent.response_redirect({ 'Location' => 'http://trap/http_headers' }, :get,\n                                    page, 0, headers)\n\n    refute_includes(headers.keys, \"AUTHORIZATION\")\n    refute_includes(headers.keys, \"cookie\")\n\n    assert_match(\"range|bytes=0-9999\", page.body)\n    refute_match(\"authorization|Basic xxx\", page.body)\n    refute_match(\"cookie|name=value\", page.body)\n  end\n\n  def test_response_redirect_to_same_site_with_credential\n    @agent.redirect_ok = true\n\n    headers = {\n      'Range' => 'bytes=0-9999',\n      'AUTHORIZATION' => 'Basic xxx',\n      'cookie' => 'name=value',\n    }\n\n    page = html_page ''\n    page = @agent.response_redirect({ 'Location' => '/http_headers' }, :get,\n                                    page, 0, headers)\n\n    assert_includes(headers.keys, \"AUTHORIZATION\")\n    assert_includes(headers.keys, \"cookie\")\n\n    assert_match(\"range|bytes=0-9999\", page.body)\n    assert_match(\"authorization|Basic xxx\", page.body)\n    assert_match(\"cookie|name=value\", page.body)\n  end\n\n  def test_response_redirect_to_same_site_diff_port_with_credential\n    @agent.redirect_ok = true\n\n    headers = {\n      'Range' => 'bytes=0-9999',\n      'AUTHORIZATION' => 'Basic xxx',\n      'cookie' => 'name=value',\n    }\n\n    page = html_page ''\n    page = @agent.response_redirect({ 'Location' => 'http://example:81/http_headers' }, :get,\n                                    page, 0, headers)\n\n    refute_includes(headers.keys, \"AUTHORIZATION\")\n    assert_includes(headers.keys, \"cookie\")\n\n    assert_match(\"range|bytes=0-9999\", page.body)\n    refute_match(\"authorization|Basic xxx\", page.body)\n    assert_match(\"cookie|name=value\", page.body)\n  end\n\n  def test_response_redirect_not_ok\n    @agent.redirect_ok = false\n\n    page = fake_page\n    page = @agent.response_redirect({ 'Location' => '/other' }, :get, page, 0,\n                                    {}, page)\n\n    assert_equal URI('http://fake.example'), page.uri\n  end\n\n  def test_response_redirect_permanent\n    @agent.redirect_ok = :permanent\n\n    response = Net::HTTPMovedPermanently.allocate\n    response.instance_variable_set :@header, { 'location' => %w[/index.html] }\n\n    page = fake_page\n    page = @agent.response_redirect response, :get, page, 0, {}, page\n\n    assert_equal URI('http://fake.example/index.html'), page.uri\n  end\n\n  def test_response_redirect_permanent_temporary\n    @agent.redirect_ok = :permanent\n\n    response = Net::HTTPMovedTemporarily.allocate\n    response.instance_variable_set :@header, { 'location' => %w[/index.html] }\n\n    page = fake_page\n    page = @agent.response_redirect response, :get, page, 0, {}, page\n\n    assert_equal URI('http://fake.example/'), page.uri\n  end\n\n  def test_retry_change_request_equals\n    unless Gem::Requirement.new(\"< 4.0.0\").satisfied_by?(Gem::Version.new(Net::HTTP::Persistent::VERSION))\n      # see https://github.com/drbrain/net-http-persistent/pull/100\n      skip(\"net-http-persistent 4.0.0 and later does not support retry_change_requests\")\n    end\n\n    refute @agent.http.retry_change_requests\n\n    @agent.retry_change_requests = true\n\n    assert @agent.http.retry_change_requests\n  end\n\n  def test_robots_allowed_eh\n    allowed    = URI 'http://localhost/index.html'\n    disallowed = URI 'http://localhost/norobots.html'\n\n    assert @agent.robots_allowed? allowed\n    refute @agent.robots_allowed? disallowed\n\n    refute @agent.robots_disallowed? allowed\n    assert @agent.robots_disallowed? disallowed\n  end\n\n  def test_robots_allowed_eh_noindex\n    @agent.robots = true\n\n    noindex = URI 'http://localhost/noindex.html'\n\n    assert @agent.robots_allowed? noindex\n\n    assert_raises Mechanize::RobotsDisallowedError do\n      @agent.fetch noindex\n    end\n  end\n\n  def test_robots_infinite_loop\n    @agent.robots = true\n    @agent.redirect_ok = true\n\n    assert_raises Mechanize::RobotsDisallowedError do\n      @agent.fetch URI('http://301/norobots.html')\n    end\n\n    @agent.fetch URI('http://301/robots.html')\n  end\n\n  def test_set_proxy\n    @agent.set_proxy 'www.example.com', 9001, 'joe', 'lol'\n\n    assert_equal @agent.proxy_uri.host,     'www.example.com'\n    assert_equal @agent.proxy_uri.port,     9001\n    assert_equal @agent.proxy_uri.user,     'joe'\n    assert_equal @agent.proxy_uri.password, 'lol'\n  end\n\n  def test_set_proxy_port_string\n    @agent.set_proxy 'www.example.com', '9001', 'joe', 'lol'\n\n    assert_equal @agent.proxy_uri.host,     'www.example.com'\n    assert_equal @agent.proxy_uri.port,     9001\n    assert_equal @agent.proxy_uri.user,     'joe'\n    assert_equal @agent.proxy_uri.password, 'lol'\n  end\n\n  def test_set_proxy_service_name\n    @agent.set_proxy 'www.example.com', 'http', 'joe', 'lol'\n\n    assert_equal @agent.proxy_uri.host,     'www.example.com'\n    assert_equal @agent.proxy_uri.port,     80\n    assert_equal @agent.proxy_uri.user,     'joe'\n    assert_equal @agent.proxy_uri.password, 'lol'\n  end\n\n  def test_set_proxy_service_name_bad\n    e = assert_raises ArgumentError do\n      @agent.set_proxy 'www.example.com', 'nonexistent service', 'joe', 'lol'\n    end\n\n    assert_equal 'invalid value for port: \"nonexistent service\"', e.message\n  end\n\n  def test_set_proxy_with_scheme\n    @agent.set_proxy 'http://www.example.com', 9001, 'joe', 'lol'\n\n    assert_equal @agent.proxy_uri.host,     'www.example.com'\n    assert_equal @agent.proxy_uri.port,     9001\n    assert_equal @agent.proxy_uri.user,     'joe'\n    assert_equal @agent.proxy_uri.password, 'lol'\n  end\n\n  def test_set_proxy_url\n    @agent.set_proxy 'http://joe:lol@www.example.com:9001'\n\n    assert_equal @agent.proxy_uri.host,     'www.example.com'\n    assert_equal @agent.proxy_uri.port,     9001\n    assert_equal @agent.proxy_uri.user,     'joe'\n    assert_equal @agent.proxy_uri.password, 'lol'\n  end\n\n  def test_set_proxy_uri\n    @agent.set_proxy URI('http://joe:lol@www.example.com:9001')\n\n    assert_equal @agent.proxy_uri.host,     'www.example.com'\n    assert_equal @agent.proxy_uri.port,     9001\n    assert_equal @agent.proxy_uri.user,     'joe'\n    assert_equal @agent.proxy_uri.password, 'lol'\n  end\n\n  def test_set_proxy_url_and_credentials\n    @agent.set_proxy 'http://www.example.com:9001', nil, 'joe', 'lol'\n\n    assert_equal @agent.proxy_uri.host,     'www.example.com'\n    assert_equal @agent.proxy_uri.port,     9001\n    assert_equal @agent.proxy_uri.user,     'joe'\n    assert_equal @agent.proxy_uri.password, 'lol'\n  end\n\n  def test_setting_agent_name\n    mech = Mechanize.new 'user-set-name'\n    assert_equal 'user-set-name', mech.agent.http.name\n  end\n\n  def test_ssl\n    in_tmpdir do\n      store = OpenSSL::X509::Store.new\n      @agent.ca_file = '.'\n      @agent.cert_store = store\n      @agent.certificate = ssl_certificate\n      @agent.private_key = ssl_private_key\n      @agent.ssl_version = 'SSLv3'\n      @agent.verify_callback = proc { |ok, context| }\n\n      http = @agent.http\n\n      assert_equal '.',                       http.ca_file\n      assert_equal store,                     http.cert_store\n      assert_equal ssl_certificate,           http.certificate\n      assert_equal ssl_private_key,           http.private_key\n      assert_equal 'SSLv3',                   http.ssl_version\n      assert_equal OpenSSL::SSL::VERIFY_PEER, http.verify_mode\n      assert http.verify_callback\n    end\n  end\n\n  def test_use_tempfile_eh\n    refute @agent.use_tempfile? nil\n\n    @agent.max_file_buffer = 1\n\n    refute @agent.use_tempfile? 0\n    assert @agent.use_tempfile? 1\n\n    @agent.max_file_buffer = nil\n\n    refute @agent.use_tempfile? 1\n  end\n\n  def test_verify_none_equals\n    @agent.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\n    http = @agent.http\n\n    assert_equal OpenSSL::SSL::VERIFY_NONE, http.verify_mode\n  end\n\nend\n\n"], "filenames": ["lib/mechanize/http/agent.rb", "test/test_mechanize_http_agent.rb"], "buggy_code_start_loc": [12, 1572], "buggy_code_end_loc": [1005, 1594], "fixing_code_start_loc": [12, 1572], "fixing_code_end_loc": [1010, 1616], "type": "CWE-200", "message": "The Mechanize library is used for automating interaction with websites. Mechanize automatically stores and sends cookies, follows redirects, and can follow links and submit forms. In versions prior to 2.8.5 the Authorization header is leaked after a redirect to a different port on the same site. Users are advised to upgrade to Mechanize v2.8.5 or later. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-31033", "sourceIdentifier": "security-advisories@github.com", "published": "2022-06-09T20:15:08.343", "lastModified": "2022-11-29T16:55:05.550", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The Mechanize library is used for automating interaction with websites. Mechanize automatically stores and sends cookies, follows redirects, and can follow links and submit forms. In versions prior to 2.8.5 the Authorization header is leaked after a redirect to a different port on the same site. Users are advised to upgrade to Mechanize v2.8.5 or later. There are no known workarounds for this issue."}, {"lang": "es", "value": "La biblioteca Mechanize es usada para automatizar la interacci\u00f3n con los sitios web. Mechanize almacena y env\u00eda autom\u00e1ticamente cookies, sigue redireccionamientos y puede seguir enlaces y enviar formularios. En versiones anteriores a 2.8.5, el encabezado de autorizaci\u00f3n es filtrado despu\u00e9s de un redireccionamiento a un puerto diferente en el mismo sitio. Es recomendado a usuarios actualizar a Mechanize versi\u00f3n v2.8.5 o posteriores. No se presentan mitigaciones conocidas para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mechanize_project:mechanize:*:*:*:*:*:ruby:*:*", "versionEndExcluding": "2.8.5", "matchCriteriaId": "CD1B1186-F461-44B3-8F5E-C89967EC8109"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}], "references": [{"url": "https://github.com/sparklemotion/mechanize/commit/c7fe6996a5b95f9880653ba3bc548a8d4ef72317", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/sparklemotion/mechanize/security/advisories/GHSA-64qm-hrgp-pgr9", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/7OKZMR5O3T5HQ2V737TC7IU4WZRT2LGX/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/OA2FJROTX2U6EBWDPKRQ2VAM67A5TQXF/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/sparklemotion/mechanize/commit/c7fe6996a5b95f9880653ba3bc548a8d4ef72317"}}