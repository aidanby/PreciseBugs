{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            PPPP    CCCC  X   X                              %\n%                            P   P  C       X X                               %\n%                            PPPP   C        X                                %\n%                            P      C       X X                               %\n%                            P       CCCC  X   X                              %\n%                                                                             %\n%                                                                             %\n%                Read/Write ZSoft IBM PC Paintbrush Image Format              %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2017 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://www.imagemagick.org/script/license.php                           %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/memory-private.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n\f\n/*\n  Typedef declarations.\n*/\ntypedef struct _PCXInfo\n{\n  unsigned char\n    identifier,\n    version,\n    encoding,\n    bits_per_pixel;\n\n  unsigned short\n    left,\n    top,\n    right,\n    bottom,\n    horizontal_resolution,\n    vertical_resolution;\n\n  unsigned char\n    reserved,\n    planes;\n\n  unsigned short\n    bytes_per_line,\n    palette_info,\n    horizontal_screensize,\n    vertical_screensize;\n\n  unsigned char\n    colormap_signature;\n} PCXInfo;\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WritePCXImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s D C X                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsDCX() returns MagickTrue if the image format type, identified by the\n%  magick string, is DCX.\n%\n%  The format of the IsDCX method is:\n%\n%      MagickBooleanType IsDCX(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsDCX(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\261\\150\\336\\72\",4) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s P C X                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsPCX() returns MagickTrue if the image format type, identified by the\n%  magick string, is PCX.\n%\n%  The format of the IsPCX method is:\n%\n%      MagickBooleanType IsPCX(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsPCX(const unsigned char *magick,const size_t length)\n{\n  if (length < 2)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\012\\002\",2) == 0)\n    return(MagickTrue);\n  if (memcmp(magick,\"\\012\\005\",2) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d P C X I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadPCXImage() reads a ZSoft IBM PC Paintbrush file and returns it.\n%  It allocates the memory necessary for the new Image structure and returns\n%  a pointer to the new image.\n%\n%  The format of the ReadPCXImage method is:\n%\n%      Image *ReadPCXImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadPCXImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define ThrowPCXException(severity,tag) \\\n{ \\\n  if (scanline != (unsigned char *) NULL) \\\n    scanline=(unsigned char *) RelinquishMagickMemory(scanline); \\\n  if (pixel_info != (MemoryInfo *) NULL) \\\n    pixel_info=RelinquishVirtualMemory(pixel_info); \\\n  if (page_table != (MagickOffsetType *) NULL) \\\n    page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table); \\\n  ThrowReaderException(severity,tag); \\\n}\n\n  Image\n    *image;\n\n  int\n    bits,\n    id,\n    mask;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset,\n    *page_table;\n\n  MemoryInfo\n    *pixel_info;\n\n  PCXInfo\n    pcx_info;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p,\n    *r;\n\n  size_t\n    one,\n    pcx_packets;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    packet,\n    pcx_colormap[768],\n    *pixels,\n    *scanline;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Determine if this a PCX file.\n  */\n  page_table=(MagickOffsetType *) NULL;\n  scanline=(unsigned char *) NULL;\n  pixel_info=(MemoryInfo *) NULL;\n  if (LocaleCompare(image_info->magick,\"DCX\") == 0)\n    {\n      size_t\n        magic;\n\n      /*\n        Read the DCX page table.\n      */\n      magic=ReadBlobLSBLong(image);\n      if (magic != 987654321)\n        ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n      page_table=(MagickOffsetType *) AcquireQuantumMemory(1024UL,\n        sizeof(*page_table));\n      if (page_table == (MagickOffsetType *) NULL)\n        ThrowPCXException(ResourceLimitError,\"MemoryAllocationFailed\");\n      for (id=0; id < 1024; id++)\n      {\n        page_table[id]=(MagickOffsetType) ReadBlobLSBLong(image);\n        if (page_table[id] == 0)\n          break;\n      }\n    }\n  if (page_table != (MagickOffsetType *) NULL)\n    {\n      offset=SeekBlob(image,(MagickOffsetType) page_table[0],SEEK_SET);\n      if (offset < 0)\n        ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  count=ReadBlob(image,1,&pcx_info.identifier);\n  for (id=1; id < 1024; id++)\n  {\n    int\n      bits_per_pixel;\n\n    /*\n      Verify PCX identifier.\n    */\n    pcx_info.version=(unsigned char) ReadBlobByte(image);\n    if ((count != 1) || (pcx_info.identifier != 0x0a))\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    pcx_info.encoding=(unsigned char) ReadBlobByte(image);\n    bits_per_pixel=ReadBlobByte(image);\n    if (bits_per_pixel == -1)\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    pcx_info.bits_per_pixel=(unsigned char) bits_per_pixel;\n    pcx_info.left=ReadBlobLSBShort(image);\n    pcx_info.top=ReadBlobLSBShort(image);\n    pcx_info.right=ReadBlobLSBShort(image);\n    pcx_info.bottom=ReadBlobLSBShort(image);\n    pcx_info.horizontal_resolution=ReadBlobLSBShort(image);\n    pcx_info.vertical_resolution=ReadBlobLSBShort(image);\n    /*\n      Read PCX raster colormap.\n    */\n    image->columns=(size_t) MagickAbsoluteValue((ssize_t) pcx_info.right-\n      pcx_info.left)+1UL;\n    image->rows=(size_t) MagickAbsoluteValue((ssize_t) pcx_info.bottom-\n      pcx_info.top)+1UL;\n    if ((image->columns == 0) || (image->rows == 0) ||\n        ((pcx_info.bits_per_pixel != 1) && (pcx_info.bits_per_pixel != 2) &&\n         (pcx_info.bits_per_pixel != 4) && (pcx_info.bits_per_pixel != 8)))\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    image->depth=pcx_info.bits_per_pixel;\n    image->units=PixelsPerInchResolution;\n    image->resolution.x=(double) pcx_info.horizontal_resolution;\n    image->resolution.y=(double) pcx_info.vertical_resolution;\n    image->colors=16;\n    count=ReadBlob(image,3*image->colors,pcx_colormap);\n    if (count != (ssize_t) (3*image->colors))\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    pcx_info.reserved=(unsigned char) ReadBlobByte(image);\n    pcx_info.planes=(unsigned char) ReadBlobByte(image);\n    if (pcx_info.planes == 0)\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    if (pcx_info.planes > 6)\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    if ((pcx_info.bits_per_pixel*pcx_info.planes) >= 64)\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    one=1;\n    if ((pcx_info.bits_per_pixel != 8) || (pcx_info.planes == 1))\n      if ((pcx_info.version == 3) || (pcx_info.version == 5) ||\n          ((pcx_info.bits_per_pixel*pcx_info.planes) == 1))\n        image->colors=(size_t) MagickMin(one << (1UL*\n          (pcx_info.bits_per_pixel*pcx_info.planes)),256UL);\n    if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n      ThrowPCXException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if ((pcx_info.bits_per_pixel >= 8) && (pcx_info.planes != 1))\n      image->storage_class=DirectClass;\n    p=pcx_colormap;\n    for (i=0; i < (ssize_t) image->colors; i++)\n    {\n      image->colormap[i].red=ScaleCharToQuantum(*p++);\n      image->colormap[i].green=ScaleCharToQuantum(*p++);\n      image->colormap[i].blue=ScaleCharToQuantum(*p++);\n    }\n    pcx_info.bytes_per_line=ReadBlobLSBShort(image);\n    pcx_info.palette_info=ReadBlobLSBShort(image);\n    pcx_info.horizontal_screensize=ReadBlobLSBShort(image);\n    pcx_info.vertical_screensize=ReadBlobLSBShort(image);\n    for (i=0; i < 54; i++)\n      (void) ReadBlobByte(image);\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    /*\n      Read image data.\n    */\n    if (HeapOverflowSanityCheck(image->rows, (size_t) pcx_info.bytes_per_line) != MagickFalse)\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    pcx_packets=(size_t) image->rows*pcx_info.bytes_per_line;\n    if (HeapOverflowSanityCheck(pcx_packets, (size_t) pcx_info.planes) != MagickFalse)\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    pcx_packets=(size_t) pcx_packets*pcx_info.planes;\n    if ((size_t) (pcx_info.bits_per_pixel*pcx_info.planes*image->columns) >\n        (pcx_packets*8U))\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    scanline=(unsigned char *) AcquireQuantumMemory(MagickMax(image->columns,\n      pcx_info.bytes_per_line),MagickMax(8,pcx_info.planes)*sizeof(*scanline));\n    pixel_info=AcquireVirtualMemory(pcx_packets,2*sizeof(*pixels));\n    if ((scanline == (unsigned char *) NULL) ||\n        (pixel_info == (MemoryInfo *) NULL))\n      {\n        if (scanline != (unsigned char *) NULL)\n          scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n        if (pixel_info != (MemoryInfo *) NULL)\n          pixel_info=RelinquishVirtualMemory(pixel_info);\n        ThrowPCXException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    /*\n      Uncompress image data.\n    */\n    p=pixels;\n    if (pcx_info.encoding == 0)\n      while (pcx_packets != 0)\n      {\n        packet=(unsigned char) ReadBlobByte(image);\n        if (EOFBlob(image) != MagickFalse)\n          ThrowPCXException(CorruptImageError,\"UnexpectedEndOfFile\");\n        *p++=packet;\n        pcx_packets--;\n      }\n    else\n      while (pcx_packets != 0)\n      {\n        packet=(unsigned char) ReadBlobByte(image);\n        if (EOFBlob(image) != MagickFalse)\n          ThrowPCXException(CorruptImageError,\"UnexpectedEndOfFile\");\n        if ((packet & 0xc0) != 0xc0)\n          {\n            *p++=packet;\n            pcx_packets--;\n            continue;\n          }\n        count=(ssize_t) (packet & 0x3f);\n        packet=(unsigned char) ReadBlobByte(image);\n        if (EOFBlob(image) != MagickFalse)\n          ThrowPCXException(CorruptImageError,\"UnexpectedEndOfFile\");\n        for ( ; count != 0; count--)\n        {\n          *p++=packet;\n          pcx_packets--;\n          if (pcx_packets == 0)\n            break;\n        }\n      }\n    if (image->storage_class == DirectClass)\n      image->alpha_trait=pcx_info.planes > 3 ? BlendPixelTrait :\n        UndefinedPixelTrait;\n    else\n      if ((pcx_info.version == 5) ||\n          ((pcx_info.bits_per_pixel*pcx_info.planes) == 1))\n        {\n          /*\n            Initialize image colormap.\n          */\n          if (image->colors > 256)\n            ThrowPCXException(CorruptImageError,\"ColormapExceeds256Colors\");\n          if ((pcx_info.bits_per_pixel*pcx_info.planes) == 1)\n            {\n              /*\n                Monochrome colormap.\n              */\n              image->colormap[0].red=(Quantum) 0;\n              image->colormap[0].green=(Quantum) 0;\n              image->colormap[0].blue=(Quantum) 0;\n              image->colormap[1].red=QuantumRange;\n              image->colormap[1].green=QuantumRange;\n              image->colormap[1].blue=QuantumRange;\n            }\n          else\n            if (image->colors > 16)\n              {\n                /*\n                  256 color images have their color map at the end of the file.\n                */\n                pcx_info.colormap_signature=(unsigned char) ReadBlobByte(image);\n                count=ReadBlob(image,3*image->colors,pcx_colormap);\n                p=pcx_colormap;\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  image->colormap[i].red=ScaleCharToQuantum(*p++);\n                  image->colormap[i].green=ScaleCharToQuantum(*p++);\n                  image->colormap[i].blue=ScaleCharToQuantum(*p++);\n                }\n            }\n        }\n    /*\n      Convert PCX raster image to pixel packets.\n    */\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      p=pixels+(y*pcx_info.bytes_per_line*pcx_info.planes);\n      q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n      if (q == (Quantum *) NULL)\n        break;\n      r=scanline;\n      if (image->storage_class == DirectClass)\n        for (i=0; i < pcx_info.planes; i++)\n        {\n          r=scanline+i;\n          for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n          {\n            switch (i)\n            {\n              case 0:\n              {\n                *r=(*p++);\n                break;\n              }\n              case 1:\n              {\n                *r=(*p++);\n                break;\n              }\n              case 2:\n              {\n                *r=(*p++);\n                break;\n              }\n              case 3:\n              default:\n              {\n                *r=(*p++);\n                break;\n              }\n            }\n            r+=pcx_info.planes;\n          }\n        }\n      else\n        if (pcx_info.planes > 1)\n          {\n            for (x=0; x < (ssize_t) image->columns; x++)\n              *r++=0;\n            for (i=0; i < pcx_info.planes; i++)\n            {\n              r=scanline;\n              for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n              {\n                 bits=(*p++);\n                 for (mask=0x80; mask != 0; mask>>=1)\n                 {\n                   if (bits & mask)\n                     *r|=1 << i;\n                   r++;\n                 }\n               }\n            }\n          }\n        else\n          switch (pcx_info.bits_per_pixel)\n          {\n            case 1:\n            {\n              register ssize_t\n                bit;\n\n              for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n              {\n                for (bit=7; bit >= 0; bit--)\n                  *r++=(unsigned char) ((*p) & (0x01 << bit) ? 0x01 : 0x00);\n                p++;\n              }\n              if ((image->columns % 8) != 0)\n                {\n                  for (bit=7; bit >= (ssize_t) (8-(image->columns % 8)); bit--)\n                    *r++=(unsigned char) ((*p) & (0x01 << bit) ? 0x01 : 0x00);\n                  p++;\n                }\n              break;\n            }\n            case 2:\n            {\n              for (x=0; x < ((ssize_t) image->columns-3); x+=4)\n              {\n                *r++=(*p >> 6) & 0x3;\n                *r++=(*p >> 4) & 0x3;\n                *r++=(*p >> 2) & 0x3;\n                *r++=(*p) & 0x3;\n                p++;\n              }\n              if ((image->columns % 4) != 0)\n                {\n                  for (i=3; i >= (ssize_t) (4-(image->columns % 4)); i--)\n                    *r++=(unsigned char) ((*p >> (i*2)) & 0x03);\n                  p++;\n                }\n              break;\n            }\n            case 4:\n            {\n              for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n              {\n                *r++=(*p >> 4) & 0xf;\n                *r++=(*p) & 0xf;\n                p++;\n              }\n              if ((image->columns % 2) != 0)\n                *r++=(*p++ >> 4) & 0xf;\n              break;\n            }\n            case 8:\n            {\n              (void) CopyMagickMemory(r,p,image->columns);\n              break;\n            }\n            default:\n              break;\n          }\n      /*\n        Transfer image scanline.\n      */\n      r=scanline;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        if (image->storage_class == PseudoClass)\n          SetPixelIndex(image,*r++,q);\n        else\n          {\n            SetPixelRed(image,ScaleCharToQuantum(*r++),q);\n            SetPixelGreen(image,ScaleCharToQuantum(*r++),q);\n            SetPixelBlue(image,ScaleCharToQuantum(*r++),q);\n            if (image->alpha_trait != UndefinedPixelTrait)\n              SetPixelAlpha(image,ScaleCharToQuantum(*r++),q);\n          }\n        q+=GetPixelChannels(image);\n      }\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    if (image->storage_class == PseudoClass)\n      (void) SyncImage(image,exception);\n    scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if (page_table == (MagickOffsetType *) NULL)\n      break;\n    if (page_table[id] == 0)\n      break;\n    offset=SeekBlob(image,(MagickOffsetType) page_table[id],SEEK_SET);\n    if (offset < 0)\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    count=ReadBlob(image,1,&pcx_info.identifier);\n    if ((count != 0) && (pcx_info.identifier == 0x0a))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  if (page_table != (MagickOffsetType *) NULL)\n    page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r P C X I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterPCXImage() adds attributes for the PCX image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterPCXImage method is:\n%\n%      size_t RegisterPCXImage(void)\n%\n*/\nModuleExport size_t RegisterPCXImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"PCX\",\"DCX\",\"ZSoft IBM PC multi-page Paintbrush\");\n  entry->decoder=(DecodeImageHandler *) ReadPCXImage;\n  entry->encoder=(EncodeImageHandler *) WritePCXImage;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags|=CoderEncoderSeekableStreamFlag;\n  entry->magick=(IsImageFormatHandler *) IsDCX;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PCX\",\"PCX\",\"ZSoft IBM PC Paintbrush\");\n  entry->decoder=(DecodeImageHandler *) ReadPCXImage;\n  entry->encoder=(EncodeImageHandler *) WritePCXImage;\n  entry->magick=(IsImageFormatHandler *) IsPCX;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags|=CoderEncoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r P C X I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterPCXImage() removes format registrations made by the\n%  PCX module from the list of supported formats.\n%\n%  The format of the UnregisterPCXImage method is:\n%\n%      UnregisterPCXImage(void)\n%\n*/\nModuleExport void UnregisterPCXImage(void)\n{\n  (void) UnregisterMagickInfo(\"DCX\");\n  (void) UnregisterMagickInfo(\"PCX\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e P C X I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WritePCXImage() writes an image in the ZSoft IBM PC Paintbrush file\n%  format.\n%\n%  The format of the WritePCXImage method is:\n%\n%      MagickBooleanType WritePCXImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic MagickBooleanType PCXWritePixels(PCXInfo *pcx_info,\n  const unsigned char *pixels,Image *image)\n{\n  register const unsigned char\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  ssize_t\n    count;\n\n  unsigned char\n    packet,\n    previous;\n\n  q=pixels;\n  for (i=0; i < (ssize_t) pcx_info->planes; i++)\n  {\n    if (pcx_info->encoding == 0)\n      {\n        for (x=0; x < (ssize_t) pcx_info->bytes_per_line; x++)\n          (void) WriteBlobByte(image,(unsigned char) (*q++));\n      }\n    else\n      {\n        previous=(*q++);\n        count=1;\n        for (x=0; x < (ssize_t) (pcx_info->bytes_per_line-1); x++)\n        {\n          packet=(*q++);\n          if ((packet == previous) && (count < 63))\n            {\n              count++;\n              continue;\n            }\n          if ((count > 1) || ((previous & 0xc0) == 0xc0))\n            {\n              count|=0xc0;\n              (void) WriteBlobByte(image,(unsigned char) count);\n            }\n          (void) WriteBlobByte(image,previous);\n          previous=packet;\n          count=1;\n        }\n        if ((count > 1) || ((previous & 0xc0) == 0xc0))\n          {\n            count|=0xc0;\n            (void) WriteBlobByte(image,(unsigned char) count);\n          }\n        (void) WriteBlobByte(image,previous);\n      }\n  }\n  return (MagickTrue);\n}\n\nstatic MagickBooleanType WritePCXImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset,\n    *page_table,\n    scene;\n\n  MemoryInfo\n    *pixel_info;\n\n  PCXInfo\n    pcx_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *q;\n\n  size_t\n    length;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *pcx_colormap,\n    *pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) TransformImageColorspace(image,sRGBColorspace,exception);\n  page_table=(MagickOffsetType *) NULL;\n  if ((LocaleCompare(image_info->magick,\"DCX\") == 0) ||\n      ((GetNextImageInList(image) != (Image *) NULL) &&\n       (image_info->adjoin != MagickFalse)))\n    {\n      /*\n        Write the DCX page table.\n      */\n      (void) WriteBlobLSBLong(image,0x3ADE68B1L);\n      page_table=(MagickOffsetType *) AcquireQuantumMemory(1024UL,\n        sizeof(*page_table));\n      if (page_table == (MagickOffsetType *) NULL)\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      for (scene=0; scene < 1024; scene++)\n        (void) WriteBlobLSBLong(image,0x00000000L);\n    }\n  scene=0;\n  do\n  {\n    if (page_table != (MagickOffsetType *) NULL)\n      page_table[scene]=TellBlob(image);\n    /*\n      Initialize PCX raster file header.\n    */\n    pcx_info.identifier=0x0a;\n    pcx_info.version=5;\n    pcx_info.encoding=image_info->compression == NoCompression ? 0 : 1;\n    pcx_info.bits_per_pixel=8;\n    if ((image->storage_class == PseudoClass) &&\n        (SetImageMonochrome(image,exception) != MagickFalse))\n      pcx_info.bits_per_pixel=1;\n    pcx_info.left=0;\n    pcx_info.top=0;\n    pcx_info.right=(unsigned short) (image->columns-1);\n    pcx_info.bottom=(unsigned short) (image->rows-1);\n    switch (image->units)\n    {\n      case UndefinedResolution:\n      case PixelsPerInchResolution:\n      default:\n      {\n        pcx_info.horizontal_resolution=(unsigned short) image->resolution.x;\n        pcx_info.vertical_resolution=(unsigned short) image->resolution.y;\n        break;\n      }\n      case PixelsPerCentimeterResolution:\n      {\n        pcx_info.horizontal_resolution=(unsigned short)\n          (2.54*image->resolution.x+0.5);\n        pcx_info.vertical_resolution=(unsigned short)\n          (2.54*image->resolution.y+0.5);\n        break;\n      }\n    }\n    pcx_info.reserved=0;\n    pcx_info.planes=1;\n    if ((image->storage_class == DirectClass) || (image->colors > 256))\n      {\n        pcx_info.planes=3;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          pcx_info.planes++;\n      }\n    pcx_info.bytes_per_line=(unsigned short) (((size_t) image->columns*\n      pcx_info.bits_per_pixel+7)/8);\n    pcx_info.palette_info=1;\n    pcx_info.colormap_signature=0x0c;\n    /*\n      Write PCX header.\n    */\n    (void) WriteBlobByte(image,pcx_info.identifier);\n    (void) WriteBlobByte(image,pcx_info.version);\n    (void) WriteBlobByte(image,pcx_info.encoding);\n    (void) WriteBlobByte(image,pcx_info.bits_per_pixel);\n    (void) WriteBlobLSBShort(image,pcx_info.left);\n    (void) WriteBlobLSBShort(image,pcx_info.top);\n    (void) WriteBlobLSBShort(image,pcx_info.right);\n    (void) WriteBlobLSBShort(image,pcx_info.bottom);\n    (void) WriteBlobLSBShort(image,pcx_info.horizontal_resolution);\n    (void) WriteBlobLSBShort(image,pcx_info.vertical_resolution);\n    /*\n      Dump colormap to file.\n    */\n    pcx_colormap=(unsigned char *) AcquireQuantumMemory(256UL,\n      3*sizeof(*pcx_colormap));\n    if (pcx_colormap == (unsigned char *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) memset(pcx_colormap,0,3*256*sizeof(*pcx_colormap));\n    q=pcx_colormap;\n    if ((image->storage_class == PseudoClass) && (image->colors <= 256))\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        *q++=ScaleQuantumToChar(image->colormap[i].red);\n        *q++=ScaleQuantumToChar(image->colormap[i].green);\n        *q++=ScaleQuantumToChar(image->colormap[i].blue);\n      }\n    (void) WriteBlob(image,3*16,(const unsigned char *) pcx_colormap);\n    (void) WriteBlobByte(image,pcx_info.reserved);\n    (void) WriteBlobByte(image,pcx_info.planes);\n    (void) WriteBlobLSBShort(image,pcx_info.bytes_per_line);\n    (void) WriteBlobLSBShort(image,pcx_info.palette_info);\n    for (i=0; i < 58; i++)\n      (void) WriteBlobByte(image,'\\0');\n    length=(size_t) pcx_info.bytes_per_line;\n    pixel_info=AcquireVirtualMemory(length,pcx_info.planes*sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    q=pixels;\n    if ((image->storage_class == DirectClass) || (image->colors > 256))\n      {\n        /*\n          Convert DirectClass image to PCX raster pixels.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=pixels;\n          for (i=0; i < pcx_info.planes; i++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n            if (p == (const Quantum *) NULL)\n              break;\n            switch ((int) i)\n            {\n              case 0:\n              {\n                for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n                {\n                  *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n                  p+=GetPixelChannels(image);\n                }\n                break;\n              }\n              case 1:\n              {\n                for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n                {\n                  *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n                  p+=GetPixelChannels(image);\n                }\n                break;\n              }\n              case 2:\n              {\n                for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n                {\n                  *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n                  p+=GetPixelChannels(image);\n                }\n                break;\n              }\n              case 3:\n              default:\n              {\n                for (x=(ssize_t) pcx_info.bytes_per_line; x != 0; x--)\n                {\n                  *q++=ScaleQuantumToChar((Quantum) (GetPixelAlpha(image,p)));\n                  p+=GetPixelChannels(image);\n                }\n                break;\n              }\n            }\n          }\n          if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      {\n        if (pcx_info.bits_per_pixel > 1)\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n            if (p == (const Quantum *) NULL)\n              break;\n            q=pixels;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              *q++=(unsigned char) GetPixelIndex(image,p);\n              p+=GetPixelChannels(image);\n            }\n            if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        else\n          {\n            register unsigned char\n              bit,\n              byte;\n\n            /*\n              Convert PseudoClass image to a PCX monochrome image.\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              bit=0;\n              byte=0;\n              q=pixels;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                byte<<=1;\n                if (GetPixelLuma(image,p) >= (QuantumRange/2.0))\n                  byte|=0x01;\n                bit++;\n                if (bit == 8)\n                  {\n                    *q++=byte;\n                    bit=0;\n                    byte=0;\n                  }\n                p+=GetPixelChannels(image);\n              }\n              if (bit != 0)\n                *q++=byte << (8-bit);\n              if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        (void) WriteBlobByte(image,pcx_info.colormap_signature);\n        (void) WriteBlob(image,3*256,pcx_colormap);\n      }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    pcx_colormap=(unsigned char *) RelinquishMagickMemory(pcx_colormap);\n    if (page_table == (MagickOffsetType *) NULL)\n      break;\n    if (scene >= 1023)\n      break;\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  if (page_table != (MagickOffsetType *) NULL)\n    {\n      /*\n        Write the DCX page table.\n      */\n      page_table[scene+1]=0;\n      offset=SeekBlob(image,0L,SEEK_SET);\n      if (offset < 0)\n        ThrowWriterException(CorruptImageError,\"ImproperImageHeader\");\n      (void) WriteBlobLSBLong(image,0x3ADE68B1L);\n      for (i=0; i <= (ssize_t) scene; i++)\n        (void) WriteBlobLSBLong(image,(unsigned int) page_table[i]);\n      page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table);\n    }\n  if (status == MagickFalse)\n    {\n      char\n        *message;\n\n      message=GetExceptionMessage(errno);\n      (void) ThrowMagickException(exception,GetMagickModule(),FileOpenError,\n        \"UnableToWriteFile\",\"`%s': %s\",image->filename,message);\n      message=DestroyString(message);\n    }\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            PPPP    CCCC  X   X                              %\n%                            P   P  C       X X                               %\n%                            PPPP   C        X                                %\n%                            P      C       X X                               %\n%                            P       CCCC  X   X                              %\n%                                                                             %\n%                                                                             %\n%                Read/Write ZSoft IBM PC Paintbrush Image Format              %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2017 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://www.imagemagick.org/script/license.php                           %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/memory-private.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n\f\n/*\n  Typedef declarations.\n*/\ntypedef struct _PCXInfo\n{\n  unsigned char\n    identifier,\n    version,\n    encoding,\n    bits_per_pixel;\n\n  unsigned short\n    left,\n    top,\n    right,\n    bottom,\n    horizontal_resolution,\n    vertical_resolution;\n\n  unsigned char\n    reserved,\n    planes;\n\n  unsigned short\n    bytes_per_line,\n    palette_info,\n    horizontal_screensize,\n    vertical_screensize;\n\n  unsigned char\n    colormap_signature;\n} PCXInfo;\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WritePCXImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s D C X                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsDCX() returns MagickTrue if the image format type, identified by the\n%  magick string, is DCX.\n%\n%  The format of the IsDCX method is:\n%\n%      MagickBooleanType IsDCX(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsDCX(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\261\\150\\336\\72\",4) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s P C X                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsPCX() returns MagickTrue if the image format type, identified by the\n%  magick string, is PCX.\n%\n%  The format of the IsPCX method is:\n%\n%      MagickBooleanType IsPCX(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsPCX(const unsigned char *magick,const size_t length)\n{\n  if (length < 2)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\012\\002\",2) == 0)\n    return(MagickTrue);\n  if (memcmp(magick,\"\\012\\005\",2) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d P C X I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadPCXImage() reads a ZSoft IBM PC Paintbrush file and returns it.\n%  It allocates the memory necessary for the new Image structure and returns\n%  a pointer to the new image.\n%\n%  The format of the ReadPCXImage method is:\n%\n%      Image *ReadPCXImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadPCXImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define ThrowPCXException(severity,tag) \\\n{ \\\n  if (scanline != (unsigned char *) NULL) \\\n    scanline=(unsigned char *) RelinquishMagickMemory(scanline); \\\n  if (pixel_info != (MemoryInfo *) NULL) \\\n    pixel_info=RelinquishVirtualMemory(pixel_info); \\\n  if (page_table != (MagickOffsetType *) NULL) \\\n    page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table); \\\n  ThrowReaderException(severity,tag); \\\n}\n\n  Image\n    *image;\n\n  int\n    bits,\n    id,\n    mask;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset,\n    *page_table;\n\n  MemoryInfo\n    *pixel_info;\n\n  PCXInfo\n    pcx_info;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p,\n    *r;\n\n  size_t\n    one,\n    pcx_packets;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    packet,\n    pcx_colormap[768],\n    *pixels,\n    *scanline;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Determine if this a PCX file.\n  */\n  page_table=(MagickOffsetType *) NULL;\n  scanline=(unsigned char *) NULL;\n  pixel_info=(MemoryInfo *) NULL;\n  if (LocaleCompare(image_info->magick,\"DCX\") == 0)\n    {\n      size_t\n        magic;\n\n      /*\n        Read the DCX page table.\n      */\n      magic=ReadBlobLSBLong(image);\n      if (magic != 987654321)\n        ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n      page_table=(MagickOffsetType *) AcquireQuantumMemory(1024UL,\n        sizeof(*page_table));\n      if (page_table == (MagickOffsetType *) NULL)\n        ThrowPCXException(ResourceLimitError,\"MemoryAllocationFailed\");\n      for (id=0; id < 1024; id++)\n      {\n        page_table[id]=(MagickOffsetType) ReadBlobLSBLong(image);\n        if (page_table[id] == 0)\n          break;\n      }\n    }\n  if (page_table != (MagickOffsetType *) NULL)\n    {\n      offset=SeekBlob(image,(MagickOffsetType) page_table[0],SEEK_SET);\n      if (offset < 0)\n        ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  count=ReadBlob(image,1,&pcx_info.identifier);\n  for (id=1; id < 1024; id++)\n  {\n    int\n      bits_per_pixel;\n\n    /*\n      Verify PCX identifier.\n    */\n    pcx_info.version=(unsigned char) ReadBlobByte(image);\n    if ((count != 1) || (pcx_info.identifier != 0x0a))\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    pcx_info.encoding=(unsigned char) ReadBlobByte(image);\n    bits_per_pixel=ReadBlobByte(image);\n    if (bits_per_pixel == -1)\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    pcx_info.bits_per_pixel=(unsigned char) bits_per_pixel;\n    pcx_info.left=ReadBlobLSBShort(image);\n    pcx_info.top=ReadBlobLSBShort(image);\n    pcx_info.right=ReadBlobLSBShort(image);\n    pcx_info.bottom=ReadBlobLSBShort(image);\n    pcx_info.horizontal_resolution=ReadBlobLSBShort(image);\n    pcx_info.vertical_resolution=ReadBlobLSBShort(image);\n    /*\n      Read PCX raster colormap.\n    */\n    image->columns=(size_t) MagickAbsoluteValue((ssize_t) pcx_info.right-\n      pcx_info.left)+1UL;\n    image->rows=(size_t) MagickAbsoluteValue((ssize_t) pcx_info.bottom-\n      pcx_info.top)+1UL;\n    if ((image->columns == 0) || (image->rows == 0) ||\n        ((pcx_info.bits_per_pixel != 1) && (pcx_info.bits_per_pixel != 2) &&\n         (pcx_info.bits_per_pixel != 4) && (pcx_info.bits_per_pixel != 8)))\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    image->depth=pcx_info.bits_per_pixel;\n    image->units=PixelsPerInchResolution;\n    image->resolution.x=(double) pcx_info.horizontal_resolution;\n    image->resolution.y=(double) pcx_info.vertical_resolution;\n    image->colors=16;\n    count=ReadBlob(image,3*image->colors,pcx_colormap);\n    if (count != (ssize_t) (3*image->colors))\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    pcx_info.reserved=(unsigned char) ReadBlobByte(image);\n    pcx_info.planes=(unsigned char) ReadBlobByte(image);\n    if (pcx_info.planes == 0)\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    if (pcx_info.planes > 6)\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    if ((pcx_info.bits_per_pixel*pcx_info.planes) >= 64)\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    one=1;\n    if ((pcx_info.bits_per_pixel != 8) || (pcx_info.planes == 1))\n      if ((pcx_info.version == 3) || (pcx_info.version == 5) ||\n          ((pcx_info.bits_per_pixel*pcx_info.planes) == 1))\n        image->colors=(size_t) MagickMin(one << (1UL*\n          (pcx_info.bits_per_pixel*pcx_info.planes)),256UL);\n    if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n      ThrowPCXException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if ((pcx_info.bits_per_pixel >= 8) && (pcx_info.planes != 1))\n      image->storage_class=DirectClass;\n    p=pcx_colormap;\n    for (i=0; i < (ssize_t) image->colors; i++)\n    {\n      image->colormap[i].red=ScaleCharToQuantum(*p++);\n      image->colormap[i].green=ScaleCharToQuantum(*p++);\n      image->colormap[i].blue=ScaleCharToQuantum(*p++);\n    }\n    pcx_info.bytes_per_line=ReadBlobLSBShort(image);\n    pcx_info.palette_info=ReadBlobLSBShort(image);\n    pcx_info.horizontal_screensize=ReadBlobLSBShort(image);\n    pcx_info.vertical_screensize=ReadBlobLSBShort(image);\n    for (i=0; i < 54; i++)\n      (void) ReadBlobByte(image);\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    /*\n      Read image data.\n    */\n    if (HeapOverflowSanityCheck(image->rows, (size_t) pcx_info.bytes_per_line) != MagickFalse)\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    pcx_packets=(size_t) image->rows*pcx_info.bytes_per_line;\n    if (HeapOverflowSanityCheck(pcx_packets, (size_t) pcx_info.planes) != MagickFalse)\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    pcx_packets=(size_t) pcx_packets*pcx_info.planes;\n    if ((size_t) (pcx_info.bits_per_pixel*pcx_info.planes*image->columns) >\n        (pcx_packets*8U))\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    scanline=(unsigned char *) AcquireQuantumMemory(MagickMax(image->columns,\n      pcx_info.bytes_per_line),MagickMax(8,pcx_info.planes)*sizeof(*scanline));\n    pixel_info=AcquireVirtualMemory(pcx_packets,2*sizeof(*pixels));\n    if ((scanline == (unsigned char *) NULL) ||\n        (pixel_info == (MemoryInfo *) NULL))\n      {\n        if (scanline != (unsigned char *) NULL)\n          scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n        if (pixel_info != (MemoryInfo *) NULL)\n          pixel_info=RelinquishVirtualMemory(pixel_info);\n        ThrowPCXException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    /*\n      Uncompress image data.\n    */\n    p=pixels;\n    if (pcx_info.encoding == 0)\n      while (pcx_packets != 0)\n      {\n        packet=(unsigned char) ReadBlobByte(image);\n        if (EOFBlob(image) != MagickFalse)\n          ThrowPCXException(CorruptImageError,\"UnexpectedEndOfFile\");\n        *p++=packet;\n        pcx_packets--;\n      }\n    else\n      while (pcx_packets != 0)\n      {\n        packet=(unsigned char) ReadBlobByte(image);\n        if (EOFBlob(image) != MagickFalse)\n          ThrowPCXException(CorruptImageError,\"UnexpectedEndOfFile\");\n        if ((packet & 0xc0) != 0xc0)\n          {\n            *p++=packet;\n            pcx_packets--;\n            continue;\n          }\n        count=(ssize_t) (packet & 0x3f);\n        packet=(unsigned char) ReadBlobByte(image);\n        if (EOFBlob(image) != MagickFalse)\n          ThrowPCXException(CorruptImageError,\"UnexpectedEndOfFile\");\n        for ( ; count != 0; count--)\n        {\n          *p++=packet;\n          pcx_packets--;\n          if (pcx_packets == 0)\n            break;\n        }\n      }\n    if (image->storage_class == DirectClass)\n      image->alpha_trait=pcx_info.planes > 3 ? BlendPixelTrait :\n        UndefinedPixelTrait;\n    else\n      if ((pcx_info.version == 5) ||\n          ((pcx_info.bits_per_pixel*pcx_info.planes) == 1))\n        {\n          /*\n            Initialize image colormap.\n          */\n          if (image->colors > 256)\n            ThrowPCXException(CorruptImageError,\"ColormapExceeds256Colors\");\n          if ((pcx_info.bits_per_pixel*pcx_info.planes) == 1)\n            {\n              /*\n                Monochrome colormap.\n              */\n              image->colormap[0].red=(Quantum) 0;\n              image->colormap[0].green=(Quantum) 0;\n              image->colormap[0].blue=(Quantum) 0;\n              image->colormap[1].red=QuantumRange;\n              image->colormap[1].green=QuantumRange;\n              image->colormap[1].blue=QuantumRange;\n            }\n          else\n            if (image->colors > 16)\n              {\n                /*\n                  256 color images have their color map at the end of the file.\n                */\n                pcx_info.colormap_signature=(unsigned char) ReadBlobByte(image);\n                count=ReadBlob(image,3*image->colors,pcx_colormap);\n                p=pcx_colormap;\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  image->colormap[i].red=ScaleCharToQuantum(*p++);\n                  image->colormap[i].green=ScaleCharToQuantum(*p++);\n                  image->colormap[i].blue=ScaleCharToQuantum(*p++);\n                }\n            }\n        }\n    /*\n      Convert PCX raster image to pixel packets.\n    */\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      p=pixels+(y*pcx_info.bytes_per_line*pcx_info.planes);\n      q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n      if (q == (Quantum *) NULL)\n        break;\n      r=scanline;\n      if (image->storage_class == DirectClass)\n        for (i=0; i < pcx_info.planes; i++)\n        {\n          r=scanline+i;\n          for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n          {\n            switch (i)\n            {\n              case 0:\n              {\n                *r=(*p++);\n                break;\n              }\n              case 1:\n              {\n                *r=(*p++);\n                break;\n              }\n              case 2:\n              {\n                *r=(*p++);\n                break;\n              }\n              case 3:\n              default:\n              {\n                *r=(*p++);\n                break;\n              }\n            }\n            r+=pcx_info.planes;\n          }\n        }\n      else\n        if (pcx_info.planes > 1)\n          {\n            for (x=0; x < (ssize_t) image->columns; x++)\n              *r++=0;\n            for (i=0; i < pcx_info.planes; i++)\n            {\n              r=scanline;\n              for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n              {\n                 bits=(*p++);\n                 for (mask=0x80; mask != 0; mask>>=1)\n                 {\n                   if (bits & mask)\n                     *r|=1 << i;\n                   r++;\n                 }\n               }\n            }\n          }\n        else\n          switch (pcx_info.bits_per_pixel)\n          {\n            case 1:\n            {\n              register ssize_t\n                bit;\n\n              for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n              {\n                for (bit=7; bit >= 0; bit--)\n                  *r++=(unsigned char) ((*p) & (0x01 << bit) ? 0x01 : 0x00);\n                p++;\n              }\n              if ((image->columns % 8) != 0)\n                {\n                  for (bit=7; bit >= (ssize_t) (8-(image->columns % 8)); bit--)\n                    *r++=(unsigned char) ((*p) & (0x01 << bit) ? 0x01 : 0x00);\n                  p++;\n                }\n              break;\n            }\n            case 2:\n            {\n              for (x=0; x < ((ssize_t) image->columns-3); x+=4)\n              {\n                *r++=(*p >> 6) & 0x3;\n                *r++=(*p >> 4) & 0x3;\n                *r++=(*p >> 2) & 0x3;\n                *r++=(*p) & 0x3;\n                p++;\n              }\n              if ((image->columns % 4) != 0)\n                {\n                  for (i=3; i >= (ssize_t) (4-(image->columns % 4)); i--)\n                    *r++=(unsigned char) ((*p >> (i*2)) & 0x03);\n                  p++;\n                }\n              break;\n            }\n            case 4:\n            {\n              for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n              {\n                *r++=(*p >> 4) & 0xf;\n                *r++=(*p) & 0xf;\n                p++;\n              }\n              if ((image->columns % 2) != 0)\n                *r++=(*p++ >> 4) & 0xf;\n              break;\n            }\n            case 8:\n            {\n              (void) CopyMagickMemory(r,p,image->columns);\n              break;\n            }\n            default:\n              break;\n          }\n      /*\n        Transfer image scanline.\n      */\n      r=scanline;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        if (image->storage_class == PseudoClass)\n          SetPixelIndex(image,*r++,q);\n        else\n          {\n            SetPixelRed(image,ScaleCharToQuantum(*r++),q);\n            SetPixelGreen(image,ScaleCharToQuantum(*r++),q);\n            SetPixelBlue(image,ScaleCharToQuantum(*r++),q);\n            if (image->alpha_trait != UndefinedPixelTrait)\n              SetPixelAlpha(image,ScaleCharToQuantum(*r++),q);\n          }\n        q+=GetPixelChannels(image);\n      }\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    if (image->storage_class == PseudoClass)\n      (void) SyncImage(image,exception);\n    scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if (page_table == (MagickOffsetType *) NULL)\n      break;\n    if (page_table[id] == 0)\n      break;\n    offset=SeekBlob(image,(MagickOffsetType) page_table[id],SEEK_SET);\n    if (offset < 0)\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    count=ReadBlob(image,1,&pcx_info.identifier);\n    if ((count != 0) && (pcx_info.identifier == 0x0a))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  if (page_table != (MagickOffsetType *) NULL)\n    page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r P C X I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterPCXImage() adds attributes for the PCX image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterPCXImage method is:\n%\n%      size_t RegisterPCXImage(void)\n%\n*/\nModuleExport size_t RegisterPCXImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"PCX\",\"DCX\",\"ZSoft IBM PC multi-page Paintbrush\");\n  entry->decoder=(DecodeImageHandler *) ReadPCXImage;\n  entry->encoder=(EncodeImageHandler *) WritePCXImage;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags|=CoderEncoderSeekableStreamFlag;\n  entry->magick=(IsImageFormatHandler *) IsDCX;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PCX\",\"PCX\",\"ZSoft IBM PC Paintbrush\");\n  entry->decoder=(DecodeImageHandler *) ReadPCXImage;\n  entry->encoder=(EncodeImageHandler *) WritePCXImage;\n  entry->magick=(IsImageFormatHandler *) IsPCX;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags|=CoderEncoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r P C X I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterPCXImage() removes format registrations made by the\n%  PCX module from the list of supported formats.\n%\n%  The format of the UnregisterPCXImage method is:\n%\n%      UnregisterPCXImage(void)\n%\n*/\nModuleExport void UnregisterPCXImage(void)\n{\n  (void) UnregisterMagickInfo(\"DCX\");\n  (void) UnregisterMagickInfo(\"PCX\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e P C X I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WritePCXImage() writes an image in the ZSoft IBM PC Paintbrush file\n%  format.\n%\n%  The format of the WritePCXImage method is:\n%\n%      MagickBooleanType WritePCXImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic MagickBooleanType PCXWritePixels(PCXInfo *pcx_info,\n  const unsigned char *pixels,Image *image)\n{\n  register const unsigned char\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  ssize_t\n    count;\n\n  unsigned char\n    packet,\n    previous;\n\n  q=pixels;\n  for (i=0; i < (ssize_t) pcx_info->planes; i++)\n  {\n    if (pcx_info->encoding == 0)\n      {\n        for (x=0; x < (ssize_t) pcx_info->bytes_per_line; x++)\n          (void) WriteBlobByte(image,(unsigned char) (*q++));\n      }\n    else\n      {\n        previous=(*q++);\n        count=1;\n        for (x=0; x < (ssize_t) (pcx_info->bytes_per_line-1); x++)\n        {\n          packet=(*q++);\n          if ((packet == previous) && (count < 63))\n            {\n              count++;\n              continue;\n            }\n          if ((count > 1) || ((previous & 0xc0) == 0xc0))\n            {\n              count|=0xc0;\n              (void) WriteBlobByte(image,(unsigned char) count);\n            }\n          (void) WriteBlobByte(image,previous);\n          previous=packet;\n          count=1;\n        }\n        if ((count > 1) || ((previous & 0xc0) == 0xc0))\n          {\n            count|=0xc0;\n            (void) WriteBlobByte(image,(unsigned char) count);\n          }\n        (void) WriteBlobByte(image,previous);\n      }\n  }\n  return (MagickTrue);\n}\n\nstatic MagickBooleanType WritePCXImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset,\n    *page_table,\n    scene;\n\n  MemoryInfo\n    *pixel_info;\n\n  PCXInfo\n    pcx_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *q;\n\n  size_t\n    length;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *pcx_colormap,\n    *pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) TransformImageColorspace(image,sRGBColorspace,exception);\n  page_table=(MagickOffsetType *) NULL;\n  if ((LocaleCompare(image_info->magick,\"DCX\") == 0) ||\n      ((GetNextImageInList(image) != (Image *) NULL) &&\n       (image_info->adjoin != MagickFalse)))\n    {\n      /*\n        Write the DCX page table.\n      */\n      (void) WriteBlobLSBLong(image,0x3ADE68B1L);\n      page_table=(MagickOffsetType *) AcquireQuantumMemory(1024UL,\n        sizeof(*page_table));\n      if (page_table == (MagickOffsetType *) NULL)\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      for (scene=0; scene < 1024; scene++)\n        (void) WriteBlobLSBLong(image,0x00000000L);\n    }\n  scene=0;\n  do\n  {\n    if (page_table != (MagickOffsetType *) NULL)\n      page_table[scene]=TellBlob(image);\n    /*\n      Initialize PCX raster file header.\n    */\n    pcx_info.identifier=0x0a;\n    pcx_info.version=5;\n    pcx_info.encoding=image_info->compression == NoCompression ? 0 : 1;\n    pcx_info.bits_per_pixel=8;\n    if ((image->storage_class == PseudoClass) &&\n        (SetImageMonochrome(image,exception) != MagickFalse))\n      pcx_info.bits_per_pixel=1;\n    pcx_info.left=0;\n    pcx_info.top=0;\n    pcx_info.right=(unsigned short) (image->columns-1);\n    pcx_info.bottom=(unsigned short) (image->rows-1);\n    switch (image->units)\n    {\n      case UndefinedResolution:\n      case PixelsPerInchResolution:\n      default:\n      {\n        pcx_info.horizontal_resolution=(unsigned short) image->resolution.x;\n        pcx_info.vertical_resolution=(unsigned short) image->resolution.y;\n        break;\n      }\n      case PixelsPerCentimeterResolution:\n      {\n        pcx_info.horizontal_resolution=(unsigned short)\n          (2.54*image->resolution.x+0.5);\n        pcx_info.vertical_resolution=(unsigned short)\n          (2.54*image->resolution.y+0.5);\n        break;\n      }\n    }\n    pcx_info.reserved=0;\n    pcx_info.planes=1;\n    if ((image->storage_class == DirectClass) || (image->colors > 256))\n      {\n        pcx_info.planes=3;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          pcx_info.planes++;\n      }\n    pcx_info.bytes_per_line=(unsigned short) (((size_t) image->columns*\n      pcx_info.bits_per_pixel+7)/8);\n    pcx_info.palette_info=1;\n    pcx_info.colormap_signature=0x0c;\n    /*\n      Write PCX header.\n    */\n    (void) WriteBlobByte(image,pcx_info.identifier);\n    (void) WriteBlobByte(image,pcx_info.version);\n    (void) WriteBlobByte(image,pcx_info.encoding);\n    (void) WriteBlobByte(image,pcx_info.bits_per_pixel);\n    (void) WriteBlobLSBShort(image,pcx_info.left);\n    (void) WriteBlobLSBShort(image,pcx_info.top);\n    (void) WriteBlobLSBShort(image,pcx_info.right);\n    (void) WriteBlobLSBShort(image,pcx_info.bottom);\n    (void) WriteBlobLSBShort(image,pcx_info.horizontal_resolution);\n    (void) WriteBlobLSBShort(image,pcx_info.vertical_resolution);\n    /*\n      Dump colormap to file.\n    */\n    pcx_colormap=(unsigned char *) AcquireQuantumMemory(256UL,\n      3*sizeof(*pcx_colormap));\n    if (pcx_colormap == (unsigned char *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) memset(pcx_colormap,0,3*256*sizeof(*pcx_colormap));\n    q=pcx_colormap;\n    if ((image->storage_class == PseudoClass) && (image->colors <= 256))\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        *q++=ScaleQuantumToChar(image->colormap[i].red);\n        *q++=ScaleQuantumToChar(image->colormap[i].green);\n        *q++=ScaleQuantumToChar(image->colormap[i].blue);\n      }\n    (void) WriteBlob(image,3*16,(const unsigned char *) pcx_colormap);\n    (void) WriteBlobByte(image,pcx_info.reserved);\n    (void) WriteBlobByte(image,pcx_info.planes);\n    (void) WriteBlobLSBShort(image,pcx_info.bytes_per_line);\n    (void) WriteBlobLSBShort(image,pcx_info.palette_info);\n    for (i=0; i < 58; i++)\n      (void) WriteBlobByte(image,'\\0');\n    length=(size_t) pcx_info.bytes_per_line;\n    pixel_info=AcquireVirtualMemory(length,pcx_info.planes*sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      {\n        pcx_colormap=(unsigned char *) RelinquishMagickMemory(pcx_colormap);\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    q=pixels;\n    if ((image->storage_class == DirectClass) || (image->colors > 256))\n      {\n        /*\n          Convert DirectClass image to PCX raster pixels.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=pixels;\n          for (i=0; i < pcx_info.planes; i++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n            if (p == (const Quantum *) NULL)\n              break;\n            switch ((int) i)\n            {\n              case 0:\n              {\n                for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n                {\n                  *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n                  p+=GetPixelChannels(image);\n                }\n                break;\n              }\n              case 1:\n              {\n                for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n                {\n                  *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n                  p+=GetPixelChannels(image);\n                }\n                break;\n              }\n              case 2:\n              {\n                for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n                {\n                  *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n                  p+=GetPixelChannels(image);\n                }\n                break;\n              }\n              case 3:\n              default:\n              {\n                for (x=(ssize_t) pcx_info.bytes_per_line; x != 0; x--)\n                {\n                  *q++=ScaleQuantumToChar((Quantum) (GetPixelAlpha(image,p)));\n                  p+=GetPixelChannels(image);\n                }\n                break;\n              }\n            }\n          }\n          if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      {\n        if (pcx_info.bits_per_pixel > 1)\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n            if (p == (const Quantum *) NULL)\n              break;\n            q=pixels;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              *q++=(unsigned char) GetPixelIndex(image,p);\n              p+=GetPixelChannels(image);\n            }\n            if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        else\n          {\n            register unsigned char\n              bit,\n              byte;\n\n            /*\n              Convert PseudoClass image to a PCX monochrome image.\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              bit=0;\n              byte=0;\n              q=pixels;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                byte<<=1;\n                if (GetPixelLuma(image,p) >= (QuantumRange/2.0))\n                  byte|=0x01;\n                bit++;\n                if (bit == 8)\n                  {\n                    *q++=byte;\n                    bit=0;\n                    byte=0;\n                  }\n                p+=GetPixelChannels(image);\n              }\n              if (bit != 0)\n                *q++=byte << (8-bit);\n              if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        (void) WriteBlobByte(image,pcx_info.colormap_signature);\n        (void) WriteBlob(image,3*256,pcx_colormap);\n      }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    pcx_colormap=(unsigned char *) RelinquishMagickMemory(pcx_colormap);\n    if (page_table == (MagickOffsetType *) NULL)\n      break;\n    if (scene >= 1023)\n      break;\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  if (page_table != (MagickOffsetType *) NULL)\n    {\n      /*\n        Write the DCX page table.\n      */\n      page_table[scene+1]=0;\n      offset=SeekBlob(image,0L,SEEK_SET);\n      if (offset < 0)\n        ThrowWriterException(CorruptImageError,\"ImproperImageHeader\");\n      (void) WriteBlobLSBLong(image,0x3ADE68B1L);\n      for (i=0; i <= (ssize_t) scene; i++)\n        (void) WriteBlobLSBLong(image,(unsigned int) page_table[i]);\n      page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table);\n    }\n  if (status == MagickFalse)\n    {\n      char\n        *message;\n\n      message=GetExceptionMessage(errno);\n      (void) ThrowMagickException(exception,GetMagickModule(),FileOpenError,\n        \"UnableToWriteFile\",\"`%s': %s\",image->filename,message);\n      message=DestroyString(message);\n    }\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "filenames": ["coders/pcx.c"], "buggy_code_start_loc": [1019], "buggy_code_end_loc": [1020], "fixing_code_start_loc": [1019], "fixing_code_end_loc": [1023], "type": "CWE-772", "message": "ImageMagick 7.0.6-2 has a memory leak vulnerability in WritePCXImage in coders/pcx.c.", "other": {"cve": {"id": "CVE-2017-12668", "sourceIdentifier": "cve@mitre.org", "published": "2017-08-07T21:29:00.393", "lastModified": "2020-10-14T18:50:40.867", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ImageMagick 7.0.6-2 has a memory leak vulnerability in WritePCXImage in coders/pcx.c."}, {"lang": "es", "value": "ImageMagick 7.0.6-2 tiene una vulnerabilidad de filtrado de memoria en WritePCXImage en coders/pcx.c."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-772"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.6-2:*:*:*:*:*:*:*", "matchCriteriaId": "7E47D35D-B2EB-4957-A0C8-7DE54233997F"}]}]}], "references": [{"url": "https://github.com/ImageMagick/ImageMagick/commit/2ba8f335fa06daf1165e0878462686028e633a74", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/575", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/2ba8f335fa06daf1165e0878462686028e633a74"}}