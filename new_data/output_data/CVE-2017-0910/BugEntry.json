{"buggy_code": ["{% extends \"zerver/portico.html\" %}\n\n{% block portico_content %}\n\n<div class=\"pitch\">\n    <hr/>\n    <p class=\"lead\">Whoops. The confirmation link has expired.</p>\n\n    <p>\n        If you're not sure how to generate a new one, shoot us a line at\n        <a href=\"mailto:{{ support_email }}\">{{ support_email }}</a>\n        and we'll get this resolved shortly.\n    </p>\n\n</div>\n\n{% endblock %}\n", "# -*- coding: utf-8 -*-\nfrom django.conf import settings\nfrom django.core import mail\nfrom django.http import HttpResponse\nfrom django.test import override_settings\nfrom django_auth_ldap.backend import _LDAPUser\nfrom django.contrib.auth import authenticate\nfrom django.test.client import RequestFactory\nfrom typing import Any, Callable, Dict, List, Optional, Text\nfrom builtins import object\nfrom oauth2client.crypt import AppIdentityError\nfrom django.core import signing\nfrom django.core.urlresolvers import reverse\n\nimport jwt\nimport mock\nimport re\n\nfrom zerver.forms import HomepageForm\nfrom zerver.lib.actions import (\n    do_deactivate_realm,\n    do_deactivate_user,\n    do_reactivate_realm,\n    do_reactivate_user,\n    do_set_realm_authentication_methods,\n    create_stream_if_needed,\n)\nfrom zerver.lib.mobile_auth_otp import otp_decrypt_api_key\nfrom zerver.lib.validator import validate_login_email, \\\n    check_bool, check_dict_only, check_string\nfrom zerver.lib.request import JsonableError\nfrom zerver.lib.initial_password import initial_password\nfrom zerver.lib.sessions import get_session_dict_user\nfrom zerver.lib.test_classes import (\n    ZulipTestCase,\n)\nfrom zerver.lib.test_helpers import POSTRequestMock\nfrom zerver.models import \\\n    get_realm, email_to_username, UserProfile, \\\n    PreregistrationUser, Realm, get_user, MultiuseInvite\n\nfrom confirmation.models import Confirmation, confirmation_url, create_confirmation_link\n\nfrom zproject.backends import ZulipDummyBackend, EmailAuthBackend, \\\n    GoogleMobileOauth2Backend, ZulipRemoteUserBackend, ZulipLDAPAuthBackend, \\\n    ZulipLDAPUserPopulator, DevAuthBackend, GitHubAuthBackend, ZulipAuthMixin, \\\n    dev_auth_enabled, password_auth_enabled, github_auth_enabled, \\\n    require_email_format_usernames, SocialAuthMixin, AUTH_BACKEND_NAME_MAP, \\\n    ZulipLDAPConfigurationError\n\nfrom zerver.views.auth import (maybe_send_to_registration,\n                               login_or_register_remote_user)\nfrom version import ZULIP_VERSION\n\nfrom social_core.exceptions import AuthFailed, AuthStateForbidden\nfrom social_django.strategy import DjangoStrategy\nfrom social_django.storage import BaseDjangoStorage\nfrom social_core.backends.github import GithubOrganizationOAuth2, GithubTeamOAuth2, \\\n    GithubOAuth2\n\nfrom six.moves import urllib\nfrom six.moves.http_cookies import SimpleCookie\nimport ujson\nfrom zerver.lib.test_helpers import MockLDAP, unsign_subdomain_cookie\n\nclass AuthBackendTest(ZulipTestCase):\n    def get_username(self, email_to_username=None):\n        # type: (Optional[Callable[[Text], Text]]) -> Text\n        username = self.example_email('hamlet')\n        if email_to_username is not None:\n            username = email_to_username(self.example_email('hamlet'))\n\n        return username\n\n    def verify_backend(self, backend, good_kwargs=None, bad_kwargs=None):\n        # type: (Any, Optional[Dict[str, Any]], Optional[Dict[str, Any]]) -> None\n\n        user_profile = self.example_user('hamlet')\n\n        assert good_kwargs is not None\n\n        # If bad_kwargs was specified, verify auth fails in that case\n        if bad_kwargs is not None:\n            self.assertIsNone(backend.authenticate(**bad_kwargs))\n\n        # Verify auth works\n        result = backend.authenticate(**good_kwargs)\n        self.assertEqual(user_profile, result)\n\n        # Verify auth fails with a deactivated user\n        do_deactivate_user(user_profile)\n        self.assertIsNone(backend.authenticate(**good_kwargs))\n\n        # Reactivate the user and verify auth works again\n        do_reactivate_user(user_profile)\n        result = backend.authenticate(**good_kwargs)\n        self.assertEqual(user_profile, result)\n\n        # Verify auth fails with a deactivated realm\n        do_deactivate_realm(user_profile.realm)\n        self.assertIsNone(backend.authenticate(**good_kwargs))\n\n        # Verify auth works again after reactivating the realm\n        do_reactivate_realm(user_profile.realm)\n        result = backend.authenticate(**good_kwargs)\n        self.assertEqual(user_profile, result)\n\n        # ZulipDummyBackend isn't a real backend so the remainder\n        # doesn't make sense for it\n        if isinstance(backend, ZulipDummyBackend):\n            return\n\n        # Verify auth fails if the auth backend is disabled on server\n        with self.settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipDummyBackend',)):\n            self.assertIsNone(backend.authenticate(**good_kwargs))\n\n        # Verify auth fails if the auth backend is disabled for the realm\n        for backend_name in AUTH_BACKEND_NAME_MAP.keys():\n            if isinstance(backend, AUTH_BACKEND_NAME_MAP[backend_name]):\n                break\n\n        index = getattr(user_profile.realm.authentication_methods, backend_name).number\n        user_profile.realm.authentication_methods.set_bit(index, False)\n        user_profile.realm.save()\n        self.assertIsNone(backend.authenticate(**good_kwargs))\n        user_profile.realm.authentication_methods.set_bit(index, True)\n        user_profile.realm.save()\n\n    def test_dummy_backend(self):\n        # type: () -> None\n        username = self.get_username()\n        self.verify_backend(ZulipDummyBackend(),\n                            good_kwargs=dict(username=username,\n                                             use_dummy_backend=True),\n                            bad_kwargs=dict(username=username,\n                                            use_dummy_backend=False))\n\n    def setup_subdomain(self, user_profile):\n        # type: (UserProfile) -> None\n        realm = user_profile.realm\n        realm.string_id = 'zulip'\n        realm.save()\n\n    def test_email_auth_backend(self):\n        # type: () -> None\n        username = self.get_username()\n        user_profile = self.example_user('hamlet')\n        password = \"testpassword\"\n        user_profile.set_password(password)\n        user_profile.save()\n\n        with mock.patch('zproject.backends.email_auth_enabled',\n                        return_value=False), \\\n                mock.patch('zproject.backends.password_auth_enabled',\n                           return_value=True):\n            return_data = {}  # type: Dict[str, bool]\n            user = EmailAuthBackend().authenticate(self.example_email('hamlet'),\n                                                   password=password,\n                                                   return_data=return_data)\n            self.assertEqual(user, None)\n            self.assertTrue(return_data['email_auth_disabled'])\n\n        self.verify_backend(EmailAuthBackend(),\n                            good_kwargs=dict(password=password,\n                                             username=username,\n                                             realm_subdomain='zulip',\n                                             return_data=dict()),\n                            bad_kwargs=dict(password=password,\n                                            username=username,\n                                            realm_subdomain='acme',\n                                            return_data=dict()))\n\n    def test_email_auth_backend_disabled_password_auth(self):\n        # type: () -> None\n        user_profile = self.example_user('hamlet')\n        password = \"testpassword\"\n        user_profile.set_password(password)\n        user_profile.save()\n        # Verify if a realm has password auth disabled, correct password is rejected\n        with mock.patch('zproject.backends.password_auth_enabled', return_value=False):\n            self.assertIsNone(EmailAuthBackend().authenticate(self.example_email('hamlet'), password))\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipDummyBackend',))\n    def test_no_backend_enabled(self):\n        # type: () -> None\n        result = self.client_get('/login/')\n        self.assert_in_success_response([\"No authentication backends are enabled\"], result)\n\n        result = self.client_get('/register/')\n        self.assert_in_success_response([\"No authentication backends are enabled\"], result)\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.GoogleMobileOauth2Backend',))\n    def test_any_backend_enabled(self):\n        # type: () -> None\n\n        # testing to avoid false error messages.\n        result = self.client_get('/login/')\n        self.assert_not_in_success_response([\"No Authentication Backend is enabled.\"], result)\n\n        result = self.client_get('/register/')\n        self.assert_not_in_success_response([\"No Authentication Backend is enabled.\"], result)\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.GoogleMobileOauth2Backend',))\n    def test_google_backend(self):\n        # type: () -> None\n        user_profile = self.example_user('hamlet')\n        email = user_profile.email\n        backend = GoogleMobileOauth2Backend()\n        payload = dict(email_verified=True,\n                       email=email)\n\n        with mock.patch('apiclient.sample_tools.client.verify_id_token', return_value=payload):\n            self.verify_backend(backend,\n                                good_kwargs=dict(realm_subdomain=\"zulip\"),\n                                bad_kwargs=dict(realm_subdomain='acme'))\n\n        # Verify valid_attestation parameter is set correctly\n        unverified_payload = dict(email_verified=False)\n        with mock.patch('apiclient.sample_tools.client.verify_id_token', return_value=unverified_payload):\n            ret = dict()  # type: Dict[str, str]\n            result = backend.authenticate(return_data=ret)\n            self.assertIsNone(result)\n            self.assertFalse(ret[\"valid_attestation\"])\n\n        nonexistent_user_payload = dict(email_verified=True, email=\"invalid@zulip.com\")\n        with mock.patch('apiclient.sample_tools.client.verify_id_token',\n                        return_value=nonexistent_user_payload):\n            ret = dict()\n            result = backend.authenticate(return_data=ret)\n            self.assertIsNone(result)\n            self.assertTrue(ret[\"valid_attestation\"])\n        with mock.patch('apiclient.sample_tools.client.verify_id_token',\n                        side_effect=AppIdentityError):\n            ret = dict()\n            result = backend.authenticate(return_data=ret)\n            self.assertIsNone(result)\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',))\n    def test_ldap_backend(self):\n        # type: () -> None\n        user_profile = self.example_user('hamlet')\n        email = user_profile.email\n        password = \"test_password\"\n        self.setup_subdomain(user_profile)\n\n        username = self.get_username()\n        backend = ZulipLDAPAuthBackend()\n\n        # Test LDAP auth fails when LDAP server rejects password\n        with mock.patch('django_auth_ldap.backend._LDAPUser._authenticate_user_dn',\n                        side_effect=_LDAPUser.AuthenticationFailed(\"Failed\")), (\n            mock.patch('django_auth_ldap.backend._LDAPUser._check_requirements')), (\n            mock.patch('django_auth_ldap.backend._LDAPUser._get_user_attrs',\n                       return_value=dict(full_name=['Hamlet']))):\n            self.assertIsNone(backend.authenticate(email, password))\n\n        with mock.patch('django_auth_ldap.backend._LDAPUser._authenticate_user_dn'), (\n            mock.patch('django_auth_ldap.backend._LDAPUser._check_requirements')), (\n            mock.patch('django_auth_ldap.backend._LDAPUser._get_user_attrs',\n                       return_value=dict(full_name=['Hamlet']))):\n            self.verify_backend(backend,\n                                bad_kwargs=dict(username=username,\n                                                password=password,\n                                                realm_subdomain='acme'),\n                                good_kwargs=dict(username=username,\n                                                 password=password,\n                                                 realm_subdomain='zulip'))\n\n    def test_devauth_backend(self):\n        # type: () -> None\n        self.verify_backend(DevAuthBackend(),\n                            good_kwargs=dict(username=self.get_username()))\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipRemoteUserBackend',))\n    def test_remote_user_backend(self):\n        # type: () -> None\n        username = self.get_username()\n        self.verify_backend(ZulipRemoteUserBackend(),\n                            good_kwargs=dict(remote_user=username,\n                                             realm_subdomain='zulip'),\n                            bad_kwargs=dict(remote_user=username,\n                                            realm_subdomain='acme'))\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipRemoteUserBackend',))\n    @override_settings(SSO_APPEND_DOMAIN='zulip.com')\n    def test_remote_user_backend_sso_append_domain(self):\n        # type: () -> None\n        username = self.get_username(email_to_username)\n        self.verify_backend(ZulipRemoteUserBackend(),\n                            good_kwargs=dict(remote_user=username,\n                                             realm_subdomain='zulip'),\n                            bad_kwargs=dict(remote_user=username,\n                                            realm_subdomain='acme'))\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.GitHubAuthBackend',))\n    def test_github_backend(self):\n        # type: () -> None\n        user = self.example_user('hamlet')\n        email = user.email\n        good_kwargs = dict(response=dict(email=email), return_data=dict(),\n                           realm_subdomain='zulip')\n        bad_kwargs = dict(response=dict(email=email), return_data=dict(),\n                          realm_subdomain='acme')\n        self.verify_backend(GitHubAuthBackend(),\n                            good_kwargs=good_kwargs,\n                            bad_kwargs=bad_kwargs)\n\nclass SocialAuthMixinTest(ZulipTestCase):\n    def test_social_auth_mixing(self):\n        # type: () -> None\n        mixin = SocialAuthMixin()\n        with self.assertRaises(NotImplementedError):\n            mixin.get_email_address()\n        with self.assertRaises(NotImplementedError):\n            mixin.get_full_name()\n\nclass GitHubAuthBackendTest(ZulipTestCase):\n    def setUp(self):\n        # type: () -> None\n        self.user_profile = self.example_user('hamlet')\n        self.email = self.user_profile.email\n        self.name = 'Hamlet'\n        self.backend = GitHubAuthBackend()\n        self.backend.strategy = DjangoStrategy(storage=BaseDjangoStorage())\n        self.user_profile.backend = self.backend\n\n        rf = RequestFactory()\n        request = rf.get('/complete')\n        request.session = {}\n        request.get_host = lambda: 'zulip.testserver'\n        request.user = self.user_profile\n        self.backend.strategy.request = request\n\n    def do_auth(self, *args, **kwargs):\n        # type: (*Any, **Any) -> UserProfile\n        with self.settings(AUTHENTICATION_BACKENDS=('zproject.backends.GitHubAuthBackend',)):\n            return authenticate(**kwargs)\n\n    def test_github_auth_enabled(self):\n        # type: () -> None\n        with self.settings(AUTHENTICATION_BACKENDS=('zproject.backends.GitHubAuthBackend',)):\n            self.assertTrue(github_auth_enabled())\n\n    def test_full_name_with_missing_key(self):\n        # type: () -> None\n        self.assertEqual(self.backend.get_full_name(), '')\n        self.assertEqual(self.backend.get_full_name(response={'name': None}), '')\n\n    def test_full_name_with_none(self):\n        # type: () -> None\n        self.assertEqual(self.backend.get_full_name(response={'email': None}), '')\n\n    def test_github_backend_do_auth_with_non_existing_subdomain(self):\n        # type: () -> None\n        with mock.patch('social_core.backends.github.GithubOAuth2.do_auth',\n                        side_effect=self.do_auth):\n            self.backend.strategy.session_set('subdomain', 'test')\n            response = dict(email=self.email, name=self.name)\n            result = self.backend.do_auth(response=response)\n            assert(result is not None)\n            self.assertIn('subdomain=1', result.url)\n\n    def test_github_backend_do_auth_with_subdomains(self):\n        # type: () -> None\n        with mock.patch('social_core.backends.github.GithubOAuth2.do_auth',\n                        side_effect=self.do_auth):\n            self.backend.strategy.session_set('subdomain', 'zulip')\n            response = dict(email=self.email, name=self.name)\n            result = self.backend.do_auth(response=response)\n            assert(result is not None)\n            self.assertEqual('http://zulip.testserver/accounts/login/subdomain/', result.url)\n\n    def test_github_backend_do_auth_for_default(self):\n        # type: () -> None\n        with mock.patch('social_core.backends.github.GithubOAuth2.do_auth',\n                        side_effect=self.do_auth), \\\n                mock.patch('zproject.backends.SocialAuthMixin.process_do_auth') as result:\n            response = dict(email=self.email, name=self.name)\n            self.backend.do_auth('fake-access-token', response=response)\n\n            kwargs = {'realm_subdomain': 'zulip',\n                      'response': response,\n                      'return_data': {}}\n            result.assert_called_with(self.user_profile, 'fake-access-token', **kwargs)\n\n    def test_github_backend_do_auth_for_default_auth_failed(self):\n        # type: () -> None\n        with mock.patch('social_core.backends.github.GithubOAuth2.do_auth',\n                        side_effect=AuthFailed('Not found')), \\\n                mock.patch('logging.info'), \\\n                mock.patch('zproject.backends.SocialAuthMixin.process_do_auth') as result:\n            response = dict(email=self.email, name=self.name)\n\n            self.backend.do_auth('fake-access-token', response=response)\n            kwargs = {'realm_subdomain': 'zulip',\n                      'response': response,\n                      'return_data': {}}\n            result.assert_called_with(None, 'fake-access-token', **kwargs)\n\n    def test_github_backend_do_auth_for_team(self):\n        # type: () -> None\n        with mock.patch('social_core.backends.github.GithubTeamOAuth2.do_auth',\n                        side_effect=self.do_auth), \\\n                mock.patch('zproject.backends.SocialAuthMixin.process_do_auth') as result:\n            self.backend.strategy.session_set('subdomain', 'zulip')\n            response = dict(email=self.email, name=self.name)\n            with self.settings(SOCIAL_AUTH_GITHUB_TEAM_ID='zulip-webapp'):\n                self.backend.do_auth('fake-access-token', response=response)\n\n                kwargs = {'realm_subdomain': 'zulip',\n                          'response': response,\n                          'return_data': {}}\n                result.assert_called_with(self.user_profile, 'fake-access-token', **kwargs)\n\n    def test_github_backend_do_auth_for_team_auth_failed(self):\n        # type: () -> None\n        with mock.patch('social_core.backends.github.GithubTeamOAuth2.do_auth',\n                        side_effect=AuthFailed('Not found')), \\\n                mock.patch('logging.info'), \\\n                mock.patch('zproject.backends.SocialAuthMixin.process_do_auth') as result:\n            self.backend.strategy.session_set('subdomain', 'zulip')\n            response = dict(email=self.email, name=self.name)\n            with self.settings(SOCIAL_AUTH_GITHUB_TEAM_ID='zulip-webapp'):\n                self.backend.do_auth('fake-access-token', response=response)\n                kwargs = {'realm_subdomain': 'zulip',\n                          'response': response,\n                          'return_data': {}}\n                result.assert_called_with(None, 'fake-access-token', **kwargs)\n\n    def test_github_backend_do_auth_for_org(self):\n        # type: () -> None\n        with mock.patch('social_core.backends.github.GithubOrganizationOAuth2.do_auth',\n                        side_effect=self.do_auth), \\\n                mock.patch('zproject.backends.SocialAuthMixin.process_do_auth') as result:\n            self.backend.strategy.session_set('subdomain', 'zulip')\n            response = dict(email=self.email, name=self.name)\n            with self.settings(SOCIAL_AUTH_GITHUB_ORG_NAME='Zulip'):\n                self.backend.do_auth('fake-access-token', response=response)\n\n                kwargs = {'realm_subdomain': 'zulip',\n                          'response': response,\n                          'return_data': {}}\n                result.assert_called_with(self.user_profile, 'fake-access-token', **kwargs)\n\n    def test_github_backend_do_auth_for_org_auth_failed(self):\n        # type: () -> None\n        with mock.patch('social_core.backends.github.GithubOrganizationOAuth2.do_auth',\n                        side_effect=AuthFailed('Not found')), \\\n                mock.patch('logging.info'), \\\n                mock.patch('zproject.backends.SocialAuthMixin.process_do_auth') as result:\n            self.backend.strategy.session_set('subdomain', 'zulip')\n            response = dict(email=self.email, name=self.name)\n            with self.settings(SOCIAL_AUTH_GITHUB_ORG_NAME='Zulip'):\n                self.backend.do_auth('fake-access-token', response=response)\n                kwargs = {'realm_subdomain': 'zulip',\n                          'response': response,\n                          'return_data': {}}\n                result.assert_called_with(None, 'fake-access-token', **kwargs)\n\n    def test_github_backend_authenticate_nonexisting_user(self):\n        # type: () -> None\n        with mock.patch('zproject.backends.get_user_profile_by_email',\n                        side_effect=UserProfile.DoesNotExist(\"Do not exist\")):\n            response = dict(email=self.email, name=self.name)\n            return_data = dict()  # type: Dict[str, Any]\n            user = self.backend.authenticate(return_data=return_data, response=response)\n            self.assertIs(user, None)\n            self.assertTrue(return_data['valid_attestation'])\n\n    def test_github_backend_authenticate_invalid_email(self):\n        # type: () -> None\n        response = dict(email=None, name=self.name)\n        return_data = dict()  # type: Dict[str, Any]\n        user = self.backend.authenticate(return_data=return_data, response=response)\n        self.assertIs(user, None)\n        self.assertTrue(return_data['invalid_email'])\n\n    def test_github_backend_inactive_user(self):\n        # type: () -> None\n        def do_auth_inactive(*args, **kwargs):\n            # type: (*Any, **Any) -> UserProfile\n            return_data = kwargs['return_data']\n            return_data['inactive_user'] = True\n            return self.user_profile\n\n        with mock.patch('zerver.views.auth.login_or_register_remote_user') as result, \\\n                mock.patch('social_core.backends.github.GithubOAuth2.do_auth',\n                           side_effect=do_auth_inactive):\n            response = dict(email=self.email, name=self.name)\n            user = self.backend.do_auth(response=response)\n            result.assert_not_called()\n            self.assertIs(user, None)\n\n    def test_github_backend_new_user_wrong_domain(self):\n        # type: () -> None\n        rf = RequestFactory()\n        request = rf.get('/complete')\n        request.session = {}\n        request.user = self.user_profile\n        self.backend.strategy.request = request\n        session_data = {'subdomain': False, 'is_signup': '1'}\n        self.backend.strategy.session_get = lambda k: session_data.get(k)\n\n        def do_auth(*args, **kwargs):\n            # type: (*Any, **Any) -> None\n            return_data = kwargs['return_data']\n            return_data['valid_attestation'] = True\n            return None\n\n        with mock.patch('social_core.backends.github.GithubOAuth2.do_auth',\n                        side_effect=do_auth):\n            email = 'nonexisting@phantom.com'\n            response = dict(email=email, name='Ghost')\n            result = self.backend.do_auth(response=response)\n            self.assert_in_response('action=\"/register/\"', result)\n            self.assert_in_response('Your email address, {}, is not '\n                                    'in one of the domains that are allowed to register '\n                                    'for accounts in this organization.'.format(email), result)\n\n    def test_github_backend_new_user(self):\n        # type: () -> None\n        rf = RequestFactory()\n        request = rf.get('/complete')\n        request.session = {}\n        request.user = self.user_profile\n        self.backend.strategy.request = request\n        session_data = {'subdomain': False, 'is_signup': '1'}\n        self.backend.strategy.session_get = lambda k: session_data.get(k)\n\n        def do_auth(*args, **kwargs):\n            # type: (*Any, **Any) -> None\n            return_data = kwargs['return_data']\n            return_data['valid_attestation'] = True\n            return None\n\n        with mock.patch('social_core.backends.github.GithubOAuth2.do_auth',\n                        side_effect=do_auth):\n            email = self.nonreg_email('newuser')\n            name = \"Ghost\"\n            response = dict(email=email, name=name)\n            result = self.backend.do_auth(response=response)\n            confirmation = Confirmation.objects.all().first()\n            confirmation_key = confirmation.confirmation_key\n            self.assertIn('do_confirm/' + confirmation_key, result.url)\n            result = self.client_get(result.url)\n            self.assert_in_response('action=\"/accounts/register/\"', result)\n            data = {\"from_confirmation\": \"1\",\n                    \"full_name\": name,\n                    \"key\": confirmation_key}\n            result = self.client_post('/accounts/register/', data)\n            self.assert_in_response(\"You're almost there\", result)\n            # Verify that the user is asked for name but not password\n            self.assert_not_in_success_response(['id_password'], result)\n            self.assert_in_success_response(['id_full_name'], result)\n\n            result = self.client_post(\n                '/accounts/register/',\n                {'full_name': name,\n                 'key': confirmation_key,\n                 'terms': True})\n\n        self.assertEqual(result.status_code, 302)\n        user_profile = self.nonreg_user('newuser')\n        self.assertEqual(get_session_dict_user(self.client.session), user_profile.id)\n\n    def test_github_backend_existing_user(self):\n        # type: () -> None\n        rf = RequestFactory()\n        request = rf.get('/complete')\n        request.session = {}\n        request.user = self.user_profile\n        self.backend.strategy.request = request\n        session_data = {'subdomain': False, 'is_signup': '1'}\n        self.backend.strategy.session_get = lambda k: session_data.get(k)\n\n        def do_auth(*args, **kwargs):\n            # type: (*Any, **Any) -> None\n            return_data = kwargs['return_data']\n            return_data['valid_attestation'] = True\n            return None\n\n        with mock.patch('social_core.backends.github.GithubOAuth2.do_auth',\n                        side_effect=do_auth):\n            email = self.example_email(\"hamlet\")\n            response = dict(email=email, name='Hamlet')\n            result = self.backend.do_auth(response=response)\n            self.assert_in_response('action=\"/register/\"', result)\n            self.assert_in_response('hamlet@zulip.com already has an account',\n                                    result)\n\n    def test_github_backend_new_user_when_is_signup_is_false(self):\n        # type: () -> None\n        rf = RequestFactory()\n        request = rf.get('/complete')\n        request.session = {}\n        request.user = self.user_profile\n        self.backend.strategy.request = request\n        session_data = {'subdomain': False, 'is_signup': '0'}\n        self.backend.strategy.session_get = lambda k: session_data.get(k)\n\n        def do_auth(*args, **kwargs):\n            # type: (*Any, **Any) -> None\n            return_data = kwargs['return_data']\n            return_data['valid_attestation'] = True\n            return None\n\n        with mock.patch('social_core.backends.github.GithubOAuth2.do_auth',\n                        side_effect=do_auth):\n            email = 'nonexisting@phantom.com'\n            response = dict(email=email, name='Ghost')\n            result = self.backend.do_auth(response=response)\n            self.assert_in_response(\n                'action=\"/register/\"', result)\n            self.assert_in_response('No account found for',\n                                    result)\n            self.assert_in_response('nonexisting@phantom.com. Would you like to register instead?',\n                                    result)\n\n    def test_login_url(self):\n        # type: () -> None\n        result = self.client_get('/accounts/login/social/github')\n        self.assertIn(reverse('social:begin', args=['github']), result.url)\n        self.assertIn('is_signup=0', result.url)\n\n    def test_signup_url(self):\n        # type: () -> None\n        result = self.client_get('/accounts/register/social/github')\n        self.assertIn(reverse('social:begin', args=['github']), result.url)\n        self.assertIn('is_signup=1', result.url)\n\n    def test_github_complete(self):\n        # type: () -> None\n        from social_django import utils\n        utils.BACKENDS = ('zproject.backends.GitHubAuthBackend',)\n        with mock.patch('social_core.backends.oauth.BaseOAuth2.process_error',\n                        side_effect=AuthFailed('Not found')):\n            result = self.client_get(reverse('social:complete', args=['github']))\n            self.assertEqual(result.status_code, 302)\n            self.assertIn('login', result.url)\n\n        utils.BACKENDS = settings.AUTHENTICATION_BACKENDS\n\n    def test_github_complete_when_base_exc_is_raised(self):\n        # type: () -> None\n        from social_django import utils\n        utils.BACKENDS = ('zproject.backends.GitHubAuthBackend',)\n        with mock.patch('social_core.backends.oauth.BaseOAuth2.auth_complete',\n                        side_effect=AuthStateForbidden('State forbidden')), \\\n                mock.patch('zproject.backends.logging.warning'):\n            result = self.client_get(reverse('social:complete', args=['github']))\n            self.assertEqual(result.status_code, 302)\n            self.assertIn('login', result.url)\n\n        utils.BACKENDS = settings.AUTHENTICATION_BACKENDS\n\n    def test_github_complete_when_email_is_invalid(self):\n        # type: () -> None\n        from social_django import utils\n        utils.BACKENDS = ('zproject.backends.GitHubAuthBackend',)\n        with mock.patch('zproject.backends.GitHubAuthBackend.get_email_address',\n                        return_value=None) as mock_get_email_address, \\\n                mock.patch('social_core.backends.oauth.OAuthAuth.validate_state',\n                           return_value='state'), \\\n                mock.patch('social_core.backends.oauth.BaseOAuth2.request_access_token',\n                           return_value={'access_token': 'token'}), \\\n                mock.patch('social_core.backends.github.GithubOAuth2.do_auth',\n                           side_effect=self.do_auth), \\\n                mock.patch('zproject.backends.logging.warning'):\n            result = self.client_get(reverse('social:complete', args=['github']),\n                                     info={'state': 'state'})\n            self.assertEqual(result.status_code, 200)\n            self.assert_in_response(\"Please click the following button \"\n                                    \"if you wish to register.\", result)\n            self.assertEqual(mock_get_email_address.call_count, 2)\n\n        utils.BACKENDS = settings.AUTHENTICATION_BACKENDS\n\n\nclass ResponseMock(object):\n    def __init__(self, status_code, data):\n        # type: (int, Any) -> None\n        self.status_code = status_code\n        self.data = data\n\n    def json(self):\n        # type: () -> str\n        return self.data\n\n    @property\n    def text(self):\n        # type: () -> str\n        return \"Response text\"\n\nclass GoogleOAuthTest(ZulipTestCase):\n    def google_oauth2_test(self, token_response, account_response, *, subdomain=None,\n                           mobile_flow_otp=None, is_signup=None):\n        # type: (ResponseMock, ResponseMock, Optional[str], Optional[str], Optional[str]) -> HttpResponse\n        url = \"/accounts/login/google/\"\n        params = {}\n        headers = {}\n        if subdomain is not None:\n            headers['HTTP_HOST'] = subdomain + \".testserver\"\n        if mobile_flow_otp is not None:\n            params['mobile_flow_otp'] = mobile_flow_otp\n            headers['HTTP_USER_AGENT'] = \"ZulipAndroid\"\n        if is_signup is not None:\n            params['is_signup'] = is_signup\n        if len(params) > 0:\n            url += \"?%s\" % (urllib.parse.urlencode(params))\n\n        result = self.client_get(url, **headers)\n        if result.status_code != 302 or '/accounts/login/google/send/' not in result.url:\n            return result\n\n        # Now do the /google/send/ request\n        result = self.client_get(result.url, **headers)\n        self.assertEqual(result.status_code, 302)\n        if 'google' not in result.url:\n            return result\n\n        self.client.cookies = result.cookies\n        # Now extract the CSRF token from the redirect URL\n        parsed_url = urllib.parse.urlparse(result.url)\n        csrf_state = urllib.parse.parse_qs(parsed_url.query)['state']\n\n        with mock.patch(\"requests.post\", return_value=token_response), (\n                mock.patch(\"requests.get\", return_value=account_response)):\n            result = self.client_get(\"/accounts/login/google/done/\",\n                                     dict(state=csrf_state), **headers)\n        return result\n\nclass GoogleSubdomainLoginTest(GoogleOAuthTest):\n    def get_signed_subdomain_cookie(self, data):\n        # type: (Dict[str, Any]) -> Dict[str, str]\n        key = 'subdomain.signature'\n        salt = key + 'zerver.views.auth'\n        value = ujson.dumps(data)\n        return {key: signing.get_cookie_signer(salt=salt).sign(value)}\n\n    def test_google_oauth2_start(self):\n        # type: () -> None\n        result = self.client_get('/accounts/login/google/', subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 302)\n        parsed_url = urllib.parse.urlparse(result.url)\n        subdomain = urllib.parse.parse_qs(parsed_url.query)['subdomain']\n        self.assertEqual(subdomain, ['zulip'])\n\n    def test_google_oauth2_success(self):\n        # type: () -> None\n        token_response = ResponseMock(200, {'access_token': \"unique_token\"})\n        account_data = dict(name=dict(formatted=\"Full Name\"),\n                            emails=[dict(type=\"account\",\n                                         value=self.example_email(\"hamlet\"))])\n        account_response = ResponseMock(200, account_data)\n        result = self.google_oauth2_test(token_response, account_response, subdomain='zulip')\n\n        data = unsign_subdomain_cookie(result)\n        self.assertEqual(data['email'], self.example_email(\"hamlet\"))\n        self.assertEqual(data['name'], 'Full Name')\n        self.assertEqual(data['subdomain'], 'zulip')\n        self.assertEqual(result.status_code, 302)\n        parsed_url = urllib.parse.urlparse(result.url)\n        uri = \"{}://{}{}\".format(parsed_url.scheme, parsed_url.netloc,\n                                 parsed_url.path)\n        self.assertEqual(uri, 'http://zulip.testserver/accounts/login/subdomain/')\n\n    def test_google_oauth2_no_fullname(self):\n        # type: () -> None\n        token_response = ResponseMock(200, {'access_token': \"unique_token\"})\n        account_data = dict(name=dict(givenName=\"Test\", familyName=\"User\"),\n                            emails=[dict(type=\"account\",\n                                         value=self.example_email(\"hamlet\"))])\n        account_response = ResponseMock(200, account_data)\n        result = self.google_oauth2_test(token_response, account_response, subdomain='zulip')\n\n        data = unsign_subdomain_cookie(result)\n        self.assertEqual(data['email'], self.example_email(\"hamlet\"))\n        self.assertEqual(data['name'], 'Test User')\n        self.assertEqual(data['subdomain'], 'zulip')\n        self.assertEqual(result.status_code, 302)\n        parsed_url = urllib.parse.urlparse(result.url)\n        uri = \"{}://{}{}\".format(parsed_url.scheme, parsed_url.netloc,\n                                 parsed_url.path)\n        self.assertEqual(uri, 'http://zulip.testserver/accounts/login/subdomain/')\n\n    def test_google_oauth2_mobile_success(self):\n        # type: () -> None\n        mobile_flow_otp = '1234abcd' * 8\n        token_response = ResponseMock(200, {'access_token': \"unique_token\"})\n        account_data = dict(name=dict(formatted=\"Full Name\"),\n                            emails=[dict(type=\"account\",\n                                         value=self.example_email(\"hamlet\"))])\n        account_response = ResponseMock(200, account_data)\n        self.assertEqual(len(mail.outbox), 0)\n        with self.settings(SEND_LOGIN_EMAILS=True):\n            # Verify that the right thing happens with an invalid-format OTP\n            result = self.google_oauth2_test(token_response, account_response, subdomain='zulip',\n                                             mobile_flow_otp=\"1234\")\n            self.assert_json_error(result, \"Invalid OTP\")\n            result = self.google_oauth2_test(token_response, account_response, subdomain='zulip',\n                                             mobile_flow_otp=\"invalido\" * 8)\n            self.assert_json_error(result, \"Invalid OTP\")\n\n            # Now do it correctly\n            result = self.google_oauth2_test(token_response, account_response, subdomain='zulip',\n                                             mobile_flow_otp=mobile_flow_otp)\n        self.assertEqual(result.status_code, 302)\n        redirect_url = result['Location']\n        parsed_url = urllib.parse.urlparse(redirect_url)\n        query_params = urllib.parse.parse_qs(parsed_url.query)\n        self.assertEqual(parsed_url.scheme, 'zulip')\n        self.assertEqual(query_params[\"realm\"], ['http://zulip.testserver'])\n        self.assertEqual(query_params[\"email\"], [self.example_email(\"hamlet\")])\n        encrypted_api_key = query_params[\"otp_encrypted_api_key\"][0]\n        self.assertEqual(self.example_user('hamlet').api_key,\n                         otp_decrypt_api_key(encrypted_api_key, mobile_flow_otp))\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertIn('Zulip on Android', mail.outbox[0].body)\n\n    def test_log_into_subdomain(self):\n        # type: () -> None\n        data = {'name': 'Full Name',\n                'email': self.example_email(\"hamlet\"),\n                'subdomain': 'zulip',\n                'is_signup': False}\n\n        self.client.cookies = SimpleCookie(self.get_signed_subdomain_cookie(data))\n        result = self.client_get('/accounts/login/subdomain/', subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 302)\n        user_profile = self.example_user('hamlet')\n        self.assertEqual(get_session_dict_user(self.client.session), user_profile.id)\n\n        # If authenticate_remote_user detects a subdomain mismatch, then\n        # the result should redirect to the login page.\n        with mock.patch(\n                'zerver.views.auth.authenticate_remote_user',\n                return_value=(None, {'invalid_subdomain': True})):\n            result = self.client_get('/accounts/login/subdomain/', subdomain=\"zulip\")\n            self.assertEqual(result.status_code, 302)\n            self.assertTrue(result['Location'].endswith, '?subdomain=1')\n\n    def test_log_into_subdomain_when_is_signup_is_true(self):\n        # type: () -> None\n        data = {'name': 'Full Name',\n                'email': self.example_email(\"hamlet\"),\n                'subdomain': 'zulip',\n                'is_signup': True}\n\n        self.client.cookies = SimpleCookie(self.get_signed_subdomain_cookie(data))\n        result = self.client_get('/accounts/login/subdomain/', subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response('hamlet@zulip.com already has an account', result)\n\n    def test_log_into_subdomain_when_is_signup_is_true_and_new_user(self):\n        # type: () -> None\n        data = {'name': 'New User Name',\n                'email': 'new@zulip.com',\n                'subdomain': 'zulip',\n                'is_signup': True}\n\n        self.client.cookies = SimpleCookie(self.get_signed_subdomain_cookie(data))\n        result = self.client_get('/accounts/login/subdomain/', subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 302)\n        confirmation = Confirmation.objects.all().first()\n        confirmation_key = confirmation.confirmation_key\n        self.assertIn('do_confirm/' + confirmation_key, result.url)\n        result = self.client_get(result.url)\n        self.assert_in_response('action=\"/accounts/register/\"', result)\n        data = {\"from_confirmation\": \"1\",\n                \"full_name\": data['name'],\n                \"key\": confirmation_key}\n        result = self.client_post('/accounts/register/', data, subdomain=\"zulip\")\n        self.assert_in_response(\"You're almost there\", result)\n\n        # Verify that the user is asked for name but not password\n        self.assert_not_in_success_response(['id_password'], result)\n        self.assert_in_success_response(['id_full_name'], result)\n\n    def test_log_into_subdomain_when_using_invite_link(self):\n        # type: () -> None\n        data = {'name': 'New User Name',\n                'email': 'new@zulip.com',\n                'subdomain': 'zulip',\n                'is_signup': True}\n\n        realm = get_realm(\"zulip\")\n        realm.invite_required = True\n        realm.save()\n\n        stream_names = [\"new_stream_1\", \"new_stream_2\"]\n        streams = []\n        for stream_name in set(stream_names):\n            stream, _ = create_stream_if_needed(realm, stream_name)\n            streams.append(stream)\n\n        self.client.cookies = SimpleCookie(self.get_signed_subdomain_cookie(data))\n\n        # Without the invite link, we can't create an account due to invite_required\n        result = self.client_get('/accounts/login/subdomain/', subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_success_response(['Sign up for Zulip'], result)\n\n        # Now confirm an invitation link works\n        referrer = self.example_user(\"hamlet\")\n        multiuse_obj = MultiuseInvite.objects.create(realm=realm, referred_by=referrer)\n        multiuse_obj.streams = streams\n        multiuse_obj.save()\n        invite_link = create_confirmation_link(multiuse_obj, realm.host,\n                                               Confirmation.MULTIUSE_INVITE)\n\n        result = self.client_get(invite_link, subdomain=\"zulip\")\n        self.assert_in_success_response(['Sign up for Zulip'], result)\n\n        result = self.client_get('/accounts/login/subdomain/', subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 302)\n\n        confirmation = Confirmation.objects.all().last()\n        confirmation_key = confirmation.confirmation_key\n        self.assertIn('do_confirm/' + confirmation_key, result.url)\n        result = self.client_get(result.url)\n        self.assert_in_response('action=\"/accounts/register/\"', result)\n        data2 = {\"from_confirmation\": \"1\",\n                 \"full_name\": data['name'],\n                 \"key\": confirmation_key}\n        result = self.client_post('/accounts/register/', data2, subdomain=\"zulip\")\n        self.assert_in_response(\"You're almost there\", result)\n\n        # Verify that the user is asked for name but not password\n        self.assert_not_in_success_response(['id_password'], result)\n        self.assert_in_success_response(['id_full_name'], result)\n\n        # Click confirm registration button.\n        result = self.client_post(\n            '/accounts/register/',\n            {'full_name': 'New User Name',\n             'key': confirmation_key,\n             'terms': True})\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(sorted(self.get_streams('new@zulip.com', realm)), stream_names)\n\n    def test_log_into_subdomain_when_email_is_none(self):\n        # type: () -> None\n        data = {'name': None,\n                'email': None,\n                'subdomain': 'zulip',\n                'is_signup': False}\n\n        self.client.cookies = SimpleCookie(self.get_signed_subdomain_cookie(data))\n        with mock.patch('logging.warning'):\n            result = self.client_get('/accounts/login/subdomain/', subdomain=\"zulip\")\n            self.assertEqual(result.status_code, 200)\n            self.assert_in_response(\"Please click the following button if you \"\n                                    \"wish to register\", result)\n\n    def test_user_cannot_log_into_nonexisting_realm(self):\n        # type: () -> None\n        token_response = ResponseMock(200, {'access_token': \"unique_token\"})\n        account_data = dict(name=dict(formatted=\"Full Name\"),\n                            emails=[dict(type=\"account\",\n                                         value=self.example_email(\"hamlet\"))])\n        account_response = ResponseMock(200, account_data)\n        result = self.google_oauth2_test(token_response, account_response,\n                                         subdomain='nonexistent')\n        self.assert_in_success_response([\"There is no Zulip organization hosted at this subdomain.\"],\n                                        result)\n\n    def test_user_cannot_log_into_wrong_subdomain(self):\n        # type: () -> None\n        token_response = ResponseMock(200, {'access_token': \"unique_token\"})\n        account_data = dict(name=dict(formatted=\"Full Name\"),\n                            emails=[dict(type=\"account\",\n                                         value=self.example_email(\"hamlet\"))])\n        account_response = ResponseMock(200, account_data)\n        result = self.google_oauth2_test(token_response, account_response,\n                                         subdomain='zephyr')\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"http://zephyr.testserver/accounts/login/subdomain/\")\n        result = self.client_get('/accounts/login/subdomain/', subdomain=\"zephyr\")\n        self.assertEqual(result.status_code, 302)\n        result = self.client_get('/accounts/login/?subdomain=1', subdomain=\"zephyr\")\n        self.assert_in_success_response([\"Your Zulip account is not a member of the organization associated with this subdomain.\"],\n                                        result)\n\n    def test_user_cannot_log_into_wrong_subdomain_with_cookie(self):\n        # type: () -> None\n        data = {'name': 'Full Name',\n                'email': self.example_email(\"hamlet\"),\n                'subdomain': 'zephyr'}\n\n        self.client.cookies = SimpleCookie(self.get_signed_subdomain_cookie(data))\n        result = self.client_get('/accounts/login/subdomain/', subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 400)\n\n    def test_log_into_subdomain_when_signature_is_bad(self):\n        # type: () -> None\n        self.client.cookies = SimpleCookie({'subdomain.signature': 'invlaid'})\n        result = self.client_get('/accounts/login/subdomain/', subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 400)\n\n    def test_log_into_subdomain_when_state_is_not_passed(self):\n        # type: () -> None\n        result = self.client_get('/accounts/login/subdomain/', subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 400)\n\n    def test_google_oauth2_registration(self):\n        # type: () -> None\n        \"\"\"If the user doesn't exist yet, Google auth can be used to register an account\"\"\"\n        email = \"newuser@zulip.com\"\n        realm = get_realm(\"zulip\")\n        token_response = ResponseMock(200, {'access_token': \"unique_token\"})\n        account_data = dict(name=dict(formatted=\"Full Name\"),\n                            emails=[dict(type=\"account\",\n                                         value=email)])\n        account_response = ResponseMock(200, account_data)\n        result = self.google_oauth2_test(token_response, account_response, subdomain='zulip',\n                                         is_signup='1')\n\n        data = unsign_subdomain_cookie(result)\n        name = 'Full Name'\n        self.assertEqual(data['email'], email)\n        self.assertEqual(data['name'], name)\n        self.assertEqual(data['subdomain'], 'zulip')\n        self.assertEqual(result.status_code, 302)\n        parsed_url = urllib.parse.urlparse(result.url)\n        uri = \"{}://{}{}\".format(parsed_url.scheme, parsed_url.netloc,\n                                 parsed_url.path)\n        self.assertEqual(uri, 'http://zulip.testserver/accounts/login/subdomain/')\n\n        result = self.client_get(result.url)\n        self.assertEqual(result.status_code, 302)\n        confirmation = Confirmation.objects.all().first()\n        confirmation_key = confirmation.confirmation_key\n        self.assertIn('do_confirm/' + confirmation_key, result.url)\n        result = self.client_get(result.url)\n        self.assert_in_response('action=\"/accounts/register/\"', result)\n        data = {\"from_confirmation\": \"1\",\n                \"full_name\": name,\n                \"key\": confirmation_key}\n        result = self.client_post('/accounts/register/', data)\n        self.assert_in_response(\"You're almost there\", result)\n\n        # Verify that the user is asked for name but not password\n        self.assert_not_in_success_response(['id_password'], result)\n        self.assert_in_success_response(['id_full_name'], result)\n\n        # Click confirm registration button.\n        result = self.client_post(\n            '/accounts/register/',\n            {'full_name': name,\n             'key': confirmation_key,\n             'terms': True})\n\n        self.assertEqual(result.status_code, 302)\n        user_profile = get_user(email, realm)\n        self.assertEqual(get_session_dict_user(self.client.session), user_profile.id)\n\nclass GoogleLoginTest(GoogleOAuthTest):\n    @override_settings(ROOT_DOMAIN_LANDING_PAGE=True)\n    def test_google_oauth2_subdomains_homepage(self):\n        # type: () -> None\n        token_response = ResponseMock(200, {'access_token': \"unique_token\"})\n        account_data = dict(name=dict(formatted=\"Full Name\"),\n                            emails=[dict(type=\"account\",\n                                         value=self.example_email(\"hamlet\"))])\n        account_response = ResponseMock(200, account_data)\n        result = self.google_oauth2_test(token_response, account_response, subdomain=\"\")\n        self.assertEqual(result.status_code, 302)\n        self.assertIn('subdomain=1', result.url)\n\n    def test_google_oauth2_400_token_response(self):\n        # type: () -> None\n        token_response = ResponseMock(400, {})\n        with mock.patch(\"logging.warning\") as m:\n            result = self.google_oauth2_test(token_response, ResponseMock(500, {}))\n        self.assertEqual(result.status_code, 400)\n        self.assertEqual(m.call_args_list[0][0][0],\n                         \"User error converting Google oauth2 login to token: Response text\")\n\n    def test_google_oauth2_500_token_response(self):\n        # type: () -> None\n        token_response = ResponseMock(500, {})\n        with mock.patch(\"logging.error\") as m:\n            result = self.google_oauth2_test(token_response, ResponseMock(500, {}))\n        self.assertEqual(result.status_code, 400)\n        self.assertEqual(m.call_args_list[0][0][0],\n                         \"Could not convert google oauth2 code to access_token: Response text\")\n\n    def test_google_oauth2_400_account_response(self):\n        # type: () -> None\n        token_response = ResponseMock(200, {'access_token': \"unique_token\"})\n        account_response = ResponseMock(400, {})\n        with mock.patch(\"logging.warning\") as m:\n            result = self.google_oauth2_test(token_response, account_response)\n        self.assertEqual(result.status_code, 400)\n        self.assertEqual(m.call_args_list[0][0][0],\n                         \"Google login failed making info API call: Response text\")\n\n    def test_google_oauth2_500_account_response(self):\n        # type: () -> None\n        token_response = ResponseMock(200, {'access_token': \"unique_token\"})\n        account_response = ResponseMock(500, {})\n        with mock.patch(\"logging.error\") as m:\n            result = self.google_oauth2_test(token_response, account_response)\n        self.assertEqual(result.status_code, 400)\n        self.assertEqual(m.call_args_list[0][0][0],\n                         \"Google login failed making API call: Response text\")\n\n    def test_google_oauth2_account_response_no_email(self):\n        # type: () -> None\n        token_response = ResponseMock(200, {'access_token': \"unique_token\"})\n        account_data = dict(name=dict(formatted=\"Full Name\"),\n                            emails=[])\n        account_response = ResponseMock(200, account_data)\n        with mock.patch(\"logging.error\") as m:\n            result = self.google_oauth2_test(token_response, account_response,\n                                             subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 400)\n        self.assertIn(\"Google oauth2 account email not found:\", m.call_args_list[0][0][0])\n\n    def test_google_oauth2_error_access_denied(self):\n        # type: () -> None\n        result = self.client_get(\"/accounts/login/google/done/?error=access_denied\")\n        self.assertEqual(result.status_code, 302)\n        path = urllib.parse.urlparse(result.url).path\n        self.assertEqual(path, \"/\")\n\n    def test_google_oauth2_error_other(self):\n        # type: () -> None\n        with mock.patch(\"logging.warning\") as m:\n            result = self.client_get(\"/accounts/login/google/done/?error=some_other_error\")\n        self.assertEqual(result.status_code, 400)\n        self.assertEqual(m.call_args_list[0][0][0],\n                         \"Error from google oauth2 login: some_other_error\")\n\n    def test_google_oauth2_missing_csrf(self):\n        # type: () -> None\n        with mock.patch(\"logging.warning\") as m:\n            result = self.client_get(\"/accounts/login/google/done/\")\n        self.assertEqual(result.status_code, 400)\n        self.assertEqual(m.call_args_list[0][0][0],\n                         'Missing Google oauth2 CSRF state')\n\n    def test_google_oauth2_csrf_malformed(self):\n        # type: () -> None\n        with mock.patch(\"logging.warning\") as m:\n            result = self.client_get(\"/accounts/login/google/done/?state=badstate\")\n        self.assertEqual(result.status_code, 400)\n        self.assertEqual(m.call_args_list[0][0][0],\n                         'Missing Google oauth2 CSRF state')\n\n    def test_google_oauth2_csrf_badstate(self):\n        # type: () -> None\n        with mock.patch(\"logging.warning\") as m:\n            result = self.client_get(\"/accounts/login/google/done/?state=badstate:otherbadstate:more::\")\n        self.assertEqual(result.status_code, 400)\n        self.assertEqual(m.call_args_list[0][0][0],\n                         'Google oauth2 CSRF error')\n\nclass FetchAPIKeyTest(ZulipTestCase):\n    def setUp(self):\n        # type: () -> None\n        self.user_profile = self.example_user('hamlet')\n        self.email = self.user_profile.email\n\n    def test_success(self):\n        # type: () -> None\n        result = self.client_post(\"/api/v1/fetch_api_key\",\n                                  dict(username=self.email,\n                                       password=initial_password(self.email)))\n        self.assert_json_success(result)\n\n    def test_invalid_email(self):\n        # type: () -> None\n        result = self.client_post(\"/api/v1/fetch_api_key\",\n                                  dict(username='hamlet',\n                                       password=initial_password(self.email)))\n        self.assert_json_error(result, \"Enter a valid email address.\", 400)\n\n    def test_wrong_password(self):\n        # type: () -> None\n        result = self.client_post(\"/api/v1/fetch_api_key\",\n                                  dict(username=self.email,\n                                       password=\"wrong\"))\n        self.assert_json_error(result, \"Your username or password is incorrect.\", 403)\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.GoogleMobileOauth2Backend',),\n                       SEND_LOGIN_EMAILS=True)\n    def test_google_oauth2_token_success(self):\n        # type: () -> None\n        self.assertEqual(len(mail.outbox), 0)\n        with mock.patch(\n                'apiclient.sample_tools.client.verify_id_token',\n                return_value={\n                    \"email_verified\": True,\n                    \"email\": self.example_email(\"hamlet\"),\n                }):\n            result = self.client_post(\"/api/v1/fetch_api_key\",\n                                      dict(username=\"google-oauth2-token\",\n                                           password=\"token\"))\n        self.assert_json_success(result)\n        self.assertEqual(len(mail.outbox), 1)\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.GoogleMobileOauth2Backend',))\n    def test_google_oauth2_token_failure(self):\n        # type: () -> None\n        payload = dict(email_verified=False)\n        with mock.patch('apiclient.sample_tools.client.verify_id_token', return_value=payload):\n            result = self.client_post(\"/api/v1/fetch_api_key\",\n                                      dict(username=\"google-oauth2-token\",\n                                           password=\"token\"))\n            self.assert_json_error(result, \"Your username or password is incorrect.\", 403)\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.GoogleMobileOauth2Backend',))\n    def test_google_oauth2_token_unregistered(self):\n        # type: () -> None\n        with mock.patch(\n                'apiclient.sample_tools.client.verify_id_token',\n                return_value={\n                    \"email_verified\": True,\n                    \"email\": \"nobody@zulip.com\",\n                }):\n            result = self.client_post(\"/api/v1/fetch_api_key\",\n                                      dict(username=\"google-oauth2-token\",\n                                           password=\"token\"))\n        self.assert_json_error(\n            result,\n            \"This user is not registered; do so from a browser.\",\n            403)\n\n    def test_password_auth_disabled(self):\n        # type: () -> None\n        with mock.patch('zproject.backends.password_auth_enabled', return_value=False):\n            result = self.client_post(\"/api/v1/fetch_api_key\",\n                                      dict(username=self.email,\n                                           password=initial_password(self.email)))\n            self.assert_json_error_contains(result, \"Password auth is disabled\", 403)\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',))\n    def test_ldap_auth_email_auth_disabled_success(self):\n        # type: () -> None\n        ldap_patcher = mock.patch('django_auth_ldap.config.ldap.initialize')\n        self.mock_initialize = ldap_patcher.start()\n        self.mock_ldap = MockLDAP()\n        self.mock_initialize.return_value = self.mock_ldap\n        self.backend = ZulipLDAPAuthBackend()\n\n        self.mock_ldap.directory = {\n            'uid=hamlet,ou=users,dc=zulip,dc=com': {\n                'userPassword': 'testing'\n            }\n        }\n        with self.settings(\n                LDAP_APPEND_DOMAIN='zulip.com',\n                AUTH_LDAP_BIND_PASSWORD='',\n                AUTH_LDAP_USER_DN_TEMPLATE='uid=%(user)s,ou=users,dc=zulip,dc=com'):\n            result = self.client_post(\"/api/v1/fetch_api_key\",\n                                      dict(username=self.email,\n                                           password=\"testing\"))\n        self.assert_json_success(result)\n        self.mock_ldap.reset()\n        self.mock_initialize.stop()\n\n    def test_inactive_user(self):\n        # type: () -> None\n        do_deactivate_user(self.user_profile)\n        result = self.client_post(\"/api/v1/fetch_api_key\",\n                                  dict(username=self.email,\n                                       password=initial_password(self.email)))\n        self.assert_json_error_contains(result, \"Your account has been disabled\", 403)\n\n    def test_deactivated_realm(self):\n        # type: () -> None\n        do_deactivate_realm(self.user_profile.realm)\n        result = self.client_post(\"/api/v1/fetch_api_key\",\n                                  dict(username=self.email,\n                                       password=initial_password(self.email)))\n        self.assert_json_error_contains(result, \"Your realm has been deactivated\", 403)\n\nclass DevFetchAPIKeyTest(ZulipTestCase):\n    def setUp(self):\n        # type: () -> None\n        self.user_profile = self.example_user('hamlet')\n        self.email = self.user_profile.email\n\n    def test_success(self):\n        # type: () -> None\n        result = self.client_post(\"/api/v1/dev_fetch_api_key\",\n                                  dict(username=self.email))\n        self.assert_json_success(result)\n        data = result.json()\n        self.assertEqual(data[\"email\"], self.email)\n        self.assertEqual(data['api_key'], self.user_profile.api_key)\n\n    def test_invalid_email(self):\n        # type: () -> None\n        email = 'hamlet'\n        result = self.client_post(\"/api/v1/dev_fetch_api_key\",\n                                  dict(username=email))\n        self.assert_json_error_contains(result, \"Enter a valid email address.\", 400)\n\n    def test_unregistered_user(self):\n        # type: () -> None\n        email = 'foo@zulip.com'\n        result = self.client_post(\"/api/v1/dev_fetch_api_key\",\n                                  dict(username=email))\n        self.assert_json_error_contains(result, \"This user is not registered.\", 403)\n\n    def test_inactive_user(self):\n        # type: () -> None\n        do_deactivate_user(self.user_profile)\n        result = self.client_post(\"/api/v1/dev_fetch_api_key\",\n                                  dict(username=self.email))\n        self.assert_json_error_contains(result, \"Your account has been disabled\", 403)\n\n    def test_deactivated_realm(self):\n        # type: () -> None\n        do_deactivate_realm(self.user_profile.realm)\n        result = self.client_post(\"/api/v1/dev_fetch_api_key\",\n                                  dict(username=self.email))\n        self.assert_json_error_contains(result, \"Your realm has been deactivated\", 403)\n\n    def test_dev_auth_disabled(self):\n        # type: () -> None\n        with mock.patch('zerver.views.auth.dev_auth_enabled', return_value=False):\n            result = self.client_post(\"/api/v1/dev_fetch_api_key\",\n                                      dict(username=self.email))\n            self.assert_json_error_contains(result, \"Dev environment not enabled.\", 400)\n\nclass DevGetEmailsTest(ZulipTestCase):\n    def test_success(self):\n        # type: () -> None\n        result = self.client_get(\"/api/v1/dev_get_emails\")\n        self.assert_json_success(result)\n        self.assert_in_response(\"direct_admins\", result)\n        self.assert_in_response(\"direct_users\", result)\n\n    def test_dev_auth_disabled(self):\n        # type: () -> None\n        with mock.patch('zerver.views.auth.dev_auth_enabled', return_value=False):\n            result = self.client_get(\"/api/v1/dev_get_emails\")\n            self.assert_json_error_contains(result, \"Dev environment not enabled.\", 400)\n\nclass FetchAuthBackends(ZulipTestCase):\n    def assert_on_error(self, error):\n        # type: (Optional[str]) -> None\n        if error:\n            raise AssertionError(error)\n\n    def test_get_server_settings(self):\n        # type: () -> None\n        result = self.client_get(\"/api/v1/server_settings\",\n                                 subdomain=\"\")\n        self.assert_json_success(result)\n        data = result.json()\n        schema_checker = check_dict_only([\n            ('authentication_methods', check_dict_only([\n                ('google', check_bool),\n                ('github', check_bool),\n                ('email', check_bool),\n                ('ldap', check_bool),\n                ('dev', check_bool),\n                ('password', check_bool),\n            ])),\n            ('email_auth_enabled', check_bool),\n            ('require_email_format_usernames', check_bool),\n            ('realm_uri', check_string),\n            ('zulip_version', check_string),\n            ('msg', check_string),\n            ('result', check_string),\n        ])\n        self.assert_on_error(schema_checker(\"data\", data))\n\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=False):\n            result = self.client_get(\"/api/v1/server_settings\",\n                                     subdomain=\"\")\n            self.assert_json_success(result)\n            data = result.json()\n            schema_checker = check_dict_only([\n                ('authentication_methods', check_dict_only([\n                    ('google', check_bool),\n                    ('github', check_bool),\n                    ('dev', check_bool),\n                    ('email', check_bool),\n                    ('ldap', check_bool),\n                    ('password', check_bool),\n                ])),\n                ('email_auth_enabled', check_bool),\n                ('require_email_format_usernames', check_bool),\n                ('realm_uri', check_string),\n                ('zulip_version', check_string),\n                ('msg', check_string),\n                ('result', check_string),\n            ])\n            self.assert_on_error(schema_checker(\"data\", data))\n\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=False):\n            result = self.client_get(\"/api/v1/server_settings\",\n                                     subdomain=\"zulip\")\n        self.assert_json_success(result)\n        data = result.json()\n        with_realm_schema_checker = check_dict_only([\n            ('zulip_version', check_string),\n            ('realm_uri', check_string),\n            ('realm_name', check_string),\n            ('realm_description', check_string),\n            ('realm_icon', check_string),\n            ('email_auth_enabled', check_bool),\n            ('require_email_format_usernames', check_bool),\n            ('authentication_methods', check_dict_only([\n                ('google', check_bool),\n                ('github', check_bool),\n                ('dev', check_bool),\n                ('email', check_bool),\n                ('ldap', check_bool),\n                ('password', check_bool),\n            ])),\n            ('msg', check_string),\n            ('result', check_string),\n        ])\n        self.assert_on_error(with_realm_schema_checker(\"data\", data))\n\n    def test_fetch_auth_backend_format(self):\n        # type: () -> None\n        result = self.client_get(\"/api/v1/get_auth_backends\")\n        self.assert_json_success(result)\n        data = result.json()\n        self.assertEqual(set(data.keys()),\n                         {'msg', 'password', 'github', 'google', 'email', 'ldap',\n                          'dev', 'result', 'zulip_version'})\n        for backend in set(data.keys()) - {'msg', 'result', 'zulip_version'}:\n            self.assertTrue(isinstance(data[backend], bool))\n\n    def test_fetch_auth_backend(self):\n        # type: () -> None\n        backends = [GoogleMobileOauth2Backend(), DevAuthBackend()]\n        with mock.patch('django.contrib.auth.get_backends', return_value=backends):\n            result = self.client_get(\"/api/v1/get_auth_backends\")\n            self.assert_json_success(result)\n            data = result.json()\n            self.assertEqual(data, {\n                'msg': '',\n                'password': False,\n                'github': False,\n                'google': True,\n                'dev': True,\n                'email': False,\n                'ldap': False,\n                'result': 'success',\n                'zulip_version': ZULIP_VERSION,\n            })\n\n            # Test subdomains cases\n            with self.settings(ROOT_DOMAIN_LANDING_PAGE=False):\n                result = self.client_get(\"/api/v1/get_auth_backends\")\n                self.assert_json_success(result)\n                data = result.json()\n                self.assertEqual(data, {\n                    'msg': '',\n                    'password': False,\n                    'github': False,\n                    'google': True,\n                    'email': False,\n                    'ldap': False,\n                    'dev': True,\n                    'result': 'success',\n                    'zulip_version': ZULIP_VERSION,\n                })\n\n                # Verify invalid subdomain\n                result = self.client_get(\"/api/v1/get_auth_backends\",\n                                         subdomain=\"invalid\")\n                self.assert_json_error_contains(result, \"Invalid subdomain\", 400)\n\n                # Verify correct behavior with a valid subdomain with\n                # some backends disabled for the realm\n                realm = get_realm(\"zulip\")\n                do_set_realm_authentication_methods(realm, dict(Google=False, Email=False, Dev=True))\n                result = self.client_get(\"/api/v1/get_auth_backends\",\n                                         subdomain=\"zulip\")\n                self.assert_json_success(result)\n                data = result.json()\n                self.assertEqual(data, {\n                    'msg': '',\n                    'password': False,\n                    'github': False,\n                    'google': False,\n                    'email': False,\n                    'ldap': False,\n                    'dev': True,\n                    'result': 'success',\n                    'zulip_version': ZULIP_VERSION,\n                })\n            with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n                # With ROOT_DOMAIN_LANDING_PAGE, homepage fails\n                result = self.client_get(\"/api/v1/get_auth_backends\",\n                                         subdomain=\"\")\n                self.assert_json_error_contains(result, \"Subdomain required\", 400)\n\n                # With ROOT_DOMAIN_LANDING_PAGE, subdomain pages succeed\n                result = self.client_get(\"/api/v1/get_auth_backends\",\n                                         subdomain=\"zulip\")\n                self.assert_json_success(result)\n                data = result.json()\n                self.assertEqual(data, {\n                    'msg': '',\n                    'password': False,\n                    'github': False,\n                    'google': False,\n                    'email': False,\n                    'ldap': False,\n                    'dev': True,\n                    'result': 'success',\n                    'zulip_version': ZULIP_VERSION,\n                })\n\nclass TestDevAuthBackend(ZulipTestCase):\n    def test_login_success(self):\n        # type: () -> None\n        user_profile = self.example_user('hamlet')\n        email = user_profile.email\n        data = {'direct_email': email}\n        result = self.client_post('/accounts/login/local/', data)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(get_session_dict_user(self.client.session), user_profile.id)\n\n    def test_login_with_subdomain(self):\n        # type: () -> None\n        user_profile = self.example_user('hamlet')\n        email = user_profile.email\n        data = {'direct_email': email}\n\n        result = self.client_post('/accounts/login/local/', data)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(get_session_dict_user(self.client.session), user_profile.id)\n\n    def test_choose_realm(self):\n        # type: () -> None\n        result = self.client_post('/devlogin/', subdomain=\"zulip\")\n        self.assert_in_success_response([\"Click on a user to log in to Zulip Dev!\"], result)\n        self.assert_in_success_response([\"iago@zulip.com\", \"hamlet@zulip.com\"], result)\n\n        result = self.client_post('/devlogin/', subdomain=\"\")\n        self.assert_in_success_response([\"Click on a user to log in!\"], result)\n        self.assert_in_success_response([\"iago@zulip.com\", \"hamlet@zulip.com\"], result)\n        self.assert_in_success_response([\"starnine@mit.edu\", \"espuser@mit.edu\"], result)\n\n        data = {'new_realm': 'zephyr'}\n        result = self.client_post('/devlogin/', data, subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"http://zephyr.testserver\")\n        result = self.client_get('/devlogin/', subdomain=\"zephyr\")\n        self.assert_in_success_response([\"starnine@mit.edu\", \"espuser@mit.edu\"], result)\n        self.assert_in_success_response([\"Click on a user to log in to MIT!\"], result)\n        self.assert_not_in_success_response([\"iago@zulip.com\", \"hamlet@zulip.com\"], result)\n\n    def test_choose_realm_with_subdomains_enabled(self):\n        # type: () -> None\n        with mock.patch('zerver.views.auth.is_subdomain_root_or_alias', return_value=False):\n            with mock.patch('zerver.views.auth.get_realm_from_request', return_value=get_realm('zulip')):\n                result = self.client_get(\"http://zulip.testserver/devlogin/\")\n                self.assert_in_success_response([\"iago@zulip.com\", \"hamlet@zulip.com\"], result)\n                self.assert_not_in_success_response([\"starnine@mit.edu\", \"espuser@mit.edu\"], result)\n                self.assert_in_success_response([\"Click on a user to log in to Zulip Dev!\"], result)\n\n            with mock.patch('zerver.views.auth.get_realm_from_request', return_value=get_realm('zephyr')):\n                result = self.client_post(\"http://zulip.testserver/devlogin/\", {'new_realm': 'zephyr'})\n                self.assertEqual(result[\"Location\"], \"http://zephyr.testserver\")\n\n                result = self.client_get(\"http://zephyr.testserver/devlogin/\")\n                self.assert_not_in_success_response([\"iago@zulip.com\", \"hamlet@zulip.com\"], result)\n                self.assert_in_success_response([\"starnine@mit.edu\", \"espuser@mit.edu\"], result)\n                self.assert_in_success_response([\"Click on a user to log in to MIT!\"], result)\n\n    def test_login_failure(self):\n        # type: () -> None\n        email = self.example_email(\"hamlet\")\n        data = {'direct_email': email}\n        with self.settings(AUTHENTICATION_BACKENDS=('zproject.backends.EmailAuthBackend',)):\n            with self.assertRaisesRegex(Exception, 'Direct login not supported.'):\n                with mock.patch('django.core.handlers.exception.logger'):\n                    self.client_post('/accounts/login/local/', data)\n\n    def test_login_failure_due_to_nonexistent_user(self):\n        # type: () -> None\n        email = 'nonexisting@zulip.com'\n        data = {'direct_email': email}\n        with self.assertRaisesRegex(Exception, 'User cannot login'):\n            with mock.patch('django.core.handlers.exception.logger'):\n                self.client_post('/accounts/login/local/', data)\n\nclass TestZulipRemoteUserBackend(ZulipTestCase):\n    def test_login_success(self):\n        # type: () -> None\n        user_profile = self.example_user('hamlet')\n        email = user_profile.email\n        with self.settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipRemoteUserBackend',)):\n            result = self.client_post('/accounts/login/sso/', REMOTE_USER=email)\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(get_session_dict_user(self.client.session), user_profile.id)\n\n    def test_authenticate_with_missing_user(self):\n        # type: () -> None\n        backend = ZulipRemoteUserBackend()\n        self.assertIs(backend.authenticate(None), None)\n\n    def test_login_success_with_sso_append_domain(self):\n        # type: () -> None\n        username = 'hamlet'\n        user_profile = self.example_user('hamlet')\n        with self.settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipRemoteUserBackend',),\n                           SSO_APPEND_DOMAIN='zulip.com'):\n            result = self.client_post('/accounts/login/sso/', REMOTE_USER=username)\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(get_session_dict_user(self.client.session), user_profile.id)\n\n    def test_login_failure(self):\n        # type: () -> None\n        email = self.example_email(\"hamlet\")\n        result = self.client_post('/accounts/login/sso/', REMOTE_USER=email)\n        self.assertEqual(result.status_code, 200)  # This should ideally be not 200.\n        self.assertIs(get_session_dict_user(self.client.session), None)\n\n    def test_login_failure_due_to_nonexisting_user(self):\n        # type: () -> None\n        email = 'nonexisting@zulip.com'\n        with self.settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipRemoteUserBackend',)):\n            result = self.client_post('/accounts/login/sso/', REMOTE_USER=email)\n            self.assertEqual(result.status_code, 200)\n            self.assertIs(get_session_dict_user(self.client.session), None)\n            self.assert_in_response(\"No account found for\", result)\n\n    def test_login_failure_due_to_invalid_email(self):\n        # type: () -> None\n        email = 'hamlet'\n        with self.settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipRemoteUserBackend',)):\n            result = self.client_post('/accounts/login/sso/', REMOTE_USER=email)\n            self.assert_json_error_contains(result, \"Enter a valid email address.\", 400)\n\n    def test_login_failure_due_to_missing_field(self):\n        # type: () -> None\n        with self.settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipRemoteUserBackend',)):\n            result = self.client_post('/accounts/login/sso/')\n            self.assert_json_error_contains(result, \"No REMOTE_USER set.\", 400)\n\n    def test_login_failure_due_to_wrong_subdomain(self):\n        # type: () -> None\n        email = self.example_email(\"hamlet\")\n        with self.settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipRemoteUserBackend',)):\n            with mock.patch('zerver.views.auth.get_subdomain', return_value='acme'):\n                result = self.client_post('http://testserver:9080/accounts/login/sso/',\n                                          REMOTE_USER=email)\n                self.assertEqual(result.status_code, 200)\n                self.assertIs(get_session_dict_user(self.client.session), None)\n                self.assert_in_response(\"No account found for\", result)\n\n    def test_login_failure_due_to_empty_subdomain(self):\n        # type: () -> None\n        email = self.example_email(\"hamlet\")\n        with self.settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipRemoteUserBackend',)):\n            with mock.patch('zerver.views.auth.get_subdomain', return_value=''):\n                result = self.client_post('http://testserver:9080/accounts/login/sso/',\n                                          REMOTE_USER=email)\n                self.assertEqual(result.status_code, 200)\n                self.assertIs(get_session_dict_user(self.client.session), None)\n                self.assert_in_response(\"No account found for\", result)\n\n    def test_login_success_under_subdomains(self):\n        # type: () -> None\n        user_profile = self.example_user('hamlet')\n        email = user_profile.email\n        with mock.patch('zerver.views.auth.get_subdomain', return_value='zulip'):\n            with self.settings(\n                    AUTHENTICATION_BACKENDS=('zproject.backends.ZulipRemoteUserBackend',)):\n                result = self.client_post('/accounts/login/sso/', REMOTE_USER=email)\n                self.assertEqual(result.status_code, 302)\n                self.assertIs(get_session_dict_user(self.client.session), user_profile.id)\n\nclass TestJWTLogin(ZulipTestCase):\n    \"\"\"\n    JWT uses ZulipDummyBackend.\n    \"\"\"\n\n    def test_login_success(self):\n        # type: () -> None\n        payload = {'user': 'hamlet', 'realm': 'zulip.com'}\n        with self.settings(JWT_AUTH_KEYS={'zulip': 'key'}):\n            email = self.example_email(\"hamlet\")\n            realm = get_realm('zulip')\n            auth_key = settings.JWT_AUTH_KEYS['zulip']\n            web_token = jwt.encode(payload, auth_key).decode('utf8')\n\n            user_profile = get_user(email, realm)\n            data = {'json_web_token': web_token}\n            result = self.client_post('/accounts/login/jwt/', data)\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(get_session_dict_user(self.client.session), user_profile.id)\n\n    def test_login_failure_when_user_is_missing(self):\n        # type: () -> None\n        payload = {'realm': 'zulip.com'}\n        with self.settings(JWT_AUTH_KEYS={'zulip': 'key'}):\n            auth_key = settings.JWT_AUTH_KEYS['zulip']\n            web_token = jwt.encode(payload, auth_key).decode('utf8')\n            data = {'json_web_token': web_token}\n            result = self.client_post('/accounts/login/jwt/', data)\n            self.assert_json_error_contains(result, \"No user specified in JSON web token claims\", 400)\n\n    def test_login_failure_when_realm_is_missing(self):\n        # type: () -> None\n        payload = {'user': 'hamlet'}\n        with self.settings(JWT_AUTH_KEYS={'zulip': 'key'}):\n            auth_key = settings.JWT_AUTH_KEYS['zulip']\n            web_token = jwt.encode(payload, auth_key).decode('utf8')\n            data = {'json_web_token': web_token}\n            result = self.client_post('/accounts/login/jwt/', data)\n            self.assert_json_error_contains(result, \"No realm specified in JSON web token claims\", 400)\n\n    def test_login_failure_when_key_does_not_exist(self):\n        # type: () -> None\n        data = {'json_web_token': 'not relevant'}\n        result = self.client_post('/accounts/login/jwt/', data)\n        self.assert_json_error_contains(result, \"Auth key for this subdomain not found.\", 400)\n\n    def test_login_failure_when_key_is_missing(self):\n        # type: () -> None\n        with self.settings(JWT_AUTH_KEYS={'zulip': 'key'}):\n            result = self.client_post('/accounts/login/jwt/')\n            self.assert_json_error_contains(result, \"No JSON web token passed in request\", 400)\n\n    def test_login_failure_when_bad_token_is_passed(self):\n        # type: () -> None\n        with self.settings(JWT_AUTH_KEYS={'zulip': 'key'}):\n            result = self.client_post('/accounts/login/jwt/')\n            self.assert_json_error_contains(result, \"No JSON web token passed in request\", 400)\n            data = {'json_web_token': 'bad token'}\n            result = self.client_post('/accounts/login/jwt/', data)\n            self.assert_json_error_contains(result, \"Bad JSON web token\", 400)\n\n    def test_login_failure_when_user_does_not_exist(self):\n        # type: () -> None\n        payload = {'user': 'nonexisting', 'realm': 'zulip.com'}\n        with self.settings(JWT_AUTH_KEYS={'zulip': 'key'}):\n            auth_key = settings.JWT_AUTH_KEYS['zulip']\n            web_token = jwt.encode(payload, auth_key).decode('utf8')\n            data = {'json_web_token': web_token}\n            result = self.client_post('/accounts/login/jwt/', data)\n            self.assertEqual(result.status_code, 200)  # This should ideally be not 200.\n            self.assertIs(get_session_dict_user(self.client.session), None)\n\n            # The /accounts/login/jwt/ endpoint should also handle the case\n            # where the authentication attempt throws UserProfile.DoesNotExist.\n            with mock.patch(\n                    'zerver.views.auth.authenticate',\n                    side_effect=UserProfile.DoesNotExist(\"Do not exist\")):\n                result = self.client_post('/accounts/login/jwt/', data)\n            self.assertEqual(result.status_code, 200)  # This should ideally be not 200.\n            self.assertIs(get_session_dict_user(self.client.session), None)\n\n    def test_login_failure_due_to_wrong_subdomain(self):\n        # type: () -> None\n        payload = {'user': 'hamlet', 'realm': 'zulip.com'}\n        with self.settings(JWT_AUTH_KEYS={'acme': 'key'}):\n            with mock.patch('zerver.views.auth.get_subdomain', return_value='acme'):\n                auth_key = settings.JWT_AUTH_KEYS['acme']\n                web_token = jwt.encode(payload, auth_key).decode('utf8')\n\n                data = {'json_web_token': web_token}\n                result = self.client_post('/accounts/login/jwt/', data)\n                self.assert_json_error_contains(result, \"Wrong subdomain\", 400)\n                self.assertEqual(get_session_dict_user(self.client.session), None)\n\n    def test_login_failure_due_to_empty_subdomain(self):\n        # type: () -> None\n        payload = {'user': 'hamlet', 'realm': 'zulip.com'}\n        with self.settings(JWT_AUTH_KEYS={'': 'key'}):\n            with mock.patch('zerver.views.auth.get_subdomain', return_value=''):\n                auth_key = settings.JWT_AUTH_KEYS['']\n                web_token = jwt.encode(payload, auth_key).decode('utf8')\n\n                data = {'json_web_token': web_token}\n                result = self.client_post('/accounts/login/jwt/', data)\n                self.assert_json_error_contains(result, \"Wrong subdomain\", 400)\n                self.assertEqual(get_session_dict_user(self.client.session), None)\n\n    def test_login_success_under_subdomains(self):\n        # type: () -> None\n        payload = {'user': 'hamlet', 'realm': 'zulip.com'}\n        with self.settings(JWT_AUTH_KEYS={'zulip': 'key'}):\n            with mock.patch('zerver.views.auth.get_subdomain', return_value='zulip'):\n                auth_key = settings.JWT_AUTH_KEYS['zulip']\n                web_token = jwt.encode(payload, auth_key).decode('utf8')\n\n                data = {'json_web_token': web_token}\n                result = self.client_post('/accounts/login/jwt/', data)\n                self.assertEqual(result.status_code, 302)\n                user_profile = self.example_user('hamlet')\n                self.assertEqual(get_session_dict_user(self.client.session), user_profile.id)\n\nclass TestLDAP(ZulipTestCase):\n    def setUp(self):\n        # type: () -> None\n        user_profile = self.example_user('hamlet')\n        self.setup_subdomain(user_profile)\n\n        ldap_patcher = mock.patch('django_auth_ldap.config.ldap.initialize')\n        self.mock_initialize = ldap_patcher.start()\n        self.mock_ldap = MockLDAP()\n        self.mock_initialize.return_value = self.mock_ldap\n        self.backend = ZulipLDAPAuthBackend()\n        # Internally `_realm` attribute is automatically set by the\n        # `authenticate()` method. But for testing the `get_or_create_user()`\n        # method separately, we need to set it manually.\n        self.backend._realm = get_realm('zulip')\n\n    def tearDown(self):\n        # type: () -> None\n        self.mock_ldap.reset()\n        self.mock_initialize.stop()\n\n    def setup_subdomain(self, user_profile):\n        # type: (UserProfile) -> None\n        realm = user_profile.realm\n        realm.string_id = 'zulip'\n        realm.save()\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',))\n    def test_login_success(self):\n        # type: () -> None\n        self.mock_ldap.directory = {\n            'uid=hamlet,ou=users,dc=zulip,dc=com': {\n                'userPassword': 'testing'\n            }\n        }\n        with self.settings(\n                LDAP_APPEND_DOMAIN='zulip.com',\n                AUTH_LDAP_BIND_PASSWORD='',\n                AUTH_LDAP_USER_DN_TEMPLATE='uid=%(user)s,ou=users,dc=zulip,dc=com'):\n            user_profile = self.backend.authenticate(self.example_email(\"hamlet\"), 'testing')\n\n            assert(user_profile is not None)\n            self.assertEqual(user_profile.email, self.example_email(\"hamlet\"))\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',))\n    def test_login_success_with_email_attr(self):\n        # type: () -> None\n        self.mock_ldap.directory = {\n            'uid=letham,ou=users,dc=zulip,dc=com': {\n                'userPassword': 'testing',\n                'email': ['hamlet@zulip.com'],\n            }\n        }\n        with self.settings(LDAP_EMAIL_ATTR='email',\n                           AUTH_LDAP_BIND_PASSWORD='',\n                           AUTH_LDAP_USER_DN_TEMPLATE='uid=%(user)s,ou=users,dc=zulip,dc=com'):\n            user_profile = self.backend.authenticate(\"letham\", 'testing')\n\n            assert (user_profile is not None)\n            self.assertEqual(user_profile.email, self.example_email(\"hamlet\"))\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',))\n    def test_login_failure_due_to_wrong_password(self):\n        # type: () -> None\n        self.mock_ldap.directory = {\n            'uid=hamlet,ou=users,dc=zulip,dc=com': {\n                'userPassword': 'testing'\n            }\n        }\n        with self.settings(\n                LDAP_APPEND_DOMAIN='zulip.com',\n                AUTH_LDAP_BIND_PASSWORD='',\n                AUTH_LDAP_USER_DN_TEMPLATE='uid=%(user)s,ou=users,dc=zulip,dc=com'):\n            user = self.backend.authenticate(self.example_email(\"hamlet\"), 'wrong')\n            self.assertIs(user, None)\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',))\n    def test_login_failure_due_to_nonexistent_user(self):\n        # type: () -> None\n        self.mock_ldap.directory = {\n            'uid=hamlet,ou=users,dc=zulip,dc=com': {\n                'userPassword': 'testing'\n            }\n        }\n        with self.settings(\n                LDAP_APPEND_DOMAIN='zulip.com',\n                AUTH_LDAP_BIND_PASSWORD='',\n                AUTH_LDAP_USER_DN_TEMPLATE='uid=%(user)s,ou=users,dc=zulip,dc=com'):\n            user = self.backend.authenticate('nonexistent@zulip.com', 'testing')\n            self.assertIs(user, None)\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',))\n    def test_ldap_permissions(self):\n        # type: () -> None\n        backend = self.backend\n        self.assertFalse(backend.has_perm(None, None))\n        self.assertFalse(backend.has_module_perms(None, None))\n        self.assertTrue(backend.get_all_permissions(None, None) == set())\n        self.assertTrue(backend.get_group_permissions(None, None) == set())\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',))\n    def test_django_to_ldap_username(self):\n        # type: () -> None\n        backend = self.backend\n        with self.settings(LDAP_APPEND_DOMAIN='zulip.com'):\n            username = backend.django_to_ldap_username('\"hamlet@test\"@zulip.com')\n            self.assertEqual(username, '\"hamlet@test\"')\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',))\n    def test_ldap_to_django_username(self):\n        # type: () -> None\n        backend = self.backend\n        with self.settings(LDAP_APPEND_DOMAIN='zulip.com'):\n            username = backend.ldap_to_django_username('\"hamlet@test\"')\n            self.assertEqual(username, '\"hamlet@test\"@zulip.com')\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',))\n    def test_get_or_create_user_when_user_exists(self):\n        # type: () -> None\n        class _LDAPUser(object):\n            attrs = {'fn': ['Full Name'], 'sn': ['Short Name']}\n\n        backend = self.backend\n        email = self.example_email(\"hamlet\")\n        user_profile, created = backend.get_or_create_user(str(email), _LDAPUser())\n        self.assertFalse(created)\n        self.assertEqual(user_profile.email, email)\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',))\n    def test_get_or_create_user_when_user_does_not_exist(self):\n        # type: () -> None\n        class _LDAPUser(object):\n            attrs = {'fn': ['Full Name'], 'sn': ['Short Name']}\n\n        ldap_user_attr_map = {'full_name': 'fn', 'short_name': 'sn'}\n\n        with self.settings(AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map):\n            backend = self.backend\n            email = 'nonexisting@zulip.com'\n            user_profile, created = backend.get_or_create_user(email, _LDAPUser())\n            self.assertTrue(created)\n            self.assertEqual(user_profile.email, email)\n            self.assertEqual(user_profile.full_name, 'Full Name')\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',))\n    def test_get_or_create_user_when_user_has_invalid_name(self):\n        # type: () -> None\n        class _LDAPUser(object):\n            attrs = {'fn': ['<invalid name>'], 'sn': ['Short Name']}\n\n        ldap_user_attr_map = {'full_name': 'fn', 'short_name': 'sn'}\n\n        with self.settings(AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map):\n            backend = self.backend\n            email = 'nonexisting@zulip.com'\n            with self.assertRaisesRegex(Exception, \"Invalid characters in name!\"):\n                backend.get_or_create_user(email, _LDAPUser())\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',))\n    def test_get_or_create_user_when_realm_is_deactivated(self):\n        # type: () -> None\n        class _LDAPUser(object):\n            attrs = {'fn': ['Full Name'], 'sn': ['Short Name']}\n\n        ldap_user_attr_map = {'full_name': 'fn', 'short_name': 'sn'}\n\n        with self.settings(AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map):\n            backend = self.backend\n            email = 'nonexisting@zulip.com'\n            do_deactivate_realm(backend._realm)\n            with self.assertRaisesRegex(Exception, 'Realm has been deactivated'):\n                backend.get_or_create_user(email, _LDAPUser())\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',))\n    def test_get_or_create_user_when_realm_is_none(self):\n        # type: () -> None\n        class _LDAPUser(object):\n            attrs = {'fn': ['Full Name'], 'sn': ['Short Name']}\n\n        ldap_user_attr_map = {'full_name': 'fn', 'short_name': 'sn'}\n\n        with self.settings(AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map):\n            backend = self.backend\n            email = 'nonexisting@zulip.com'\n            backend._realm = None\n            with self.assertRaisesRegex(Exception, 'Realm is None'):\n                backend.get_or_create_user(email, _LDAPUser())\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',))\n    def test_get_or_create_user_when_ldap_has_no_email_attr(self):\n        # type: () -> None\n        class _LDAPUser(object):\n            attrs = {'fn': ['Full Name'], 'sn': ['Short Name']}\n\n        nonexisting_attr = 'email'\n        with self.settings(LDAP_EMAIL_ATTR=nonexisting_attr):\n            backend = self.backend\n            email = 'nonexisting@zulip.com'\n            with self.assertRaisesRegex(Exception, 'LDAP user doesn\\'t have the needed email attribute'):\n                backend.get_or_create_user(email, _LDAPUser())\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',))\n    def test_django_to_ldap_username_when_domain_does_not_match(self):\n        # type: () -> None\n        backend = self.backend\n        email = self.example_email(\"hamlet\")\n        with self.assertRaisesRegex(Exception, 'Username does not match LDAP domain.'):\n            with self.settings(LDAP_APPEND_DOMAIN='acme.com'):\n                backend.django_to_ldap_username(email)\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',))\n    def test_login_failure_when_domain_does_not_match(self):\n        # type: () -> None\n        with self.settings(LDAP_APPEND_DOMAIN='acme.com'):\n            user_profile = self.backend.authenticate(self.example_email(\"hamlet\"), 'pass')\n            self.assertIs(user_profile, None)\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',))\n    def test_login_failure_due_to_wrong_subdomain(self):\n        # type: () -> None\n        self.mock_ldap.directory = {\n            'uid=hamlet,ou=users,dc=zulip,dc=com': {\n                'userPassword': 'testing'\n            }\n        }\n        with self.settings(\n                LDAP_APPEND_DOMAIN='zulip.com',\n                AUTH_LDAP_BIND_PASSWORD='',\n                AUTH_LDAP_USER_DN_TEMPLATE='uid=%(user)s,ou=users,dc=zulip,dc=com'):\n            user_profile = self.backend.authenticate(self.example_email(\"hamlet\"), 'testing',\n                                                     realm_subdomain='acme')\n            self.assertIs(user_profile, None)\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',))\n    def test_login_failure_due_to_empty_subdomain(self):\n        # type: () -> None\n        self.mock_ldap.directory = {\n            'uid=hamlet,ou=users,dc=zulip,dc=com': {\n                'userPassword': 'testing'\n            }\n        }\n        with self.settings(\n                LDAP_APPEND_DOMAIN='zulip.com',\n                AUTH_LDAP_BIND_PASSWORD='',\n                AUTH_LDAP_USER_DN_TEMPLATE='uid=%(user)s,ou=users,dc=zulip,dc=com'):\n            user_profile = self.backend.authenticate(self.example_email(\"hamlet\"), 'testing',\n                                                     realm_subdomain='')\n            self.assertIs(user_profile, None)\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',))\n    def test_login_success_when_subdomain_is_none(self):\n        # type: () -> None\n        self.mock_ldap.directory = {\n            'uid=hamlet,ou=users,dc=zulip,dc=com': {\n                'userPassword': 'testing'\n            }\n        }\n        with self.settings(\n                LDAP_APPEND_DOMAIN='zulip.com',\n                AUTH_LDAP_BIND_PASSWORD='',\n                AUTH_LDAP_USER_DN_TEMPLATE='uid=%(user)s,ou=users,dc=zulip,dc=com'):\n            user_profile = self.backend.authenticate(self.example_email(\"hamlet\"), 'testing',\n                                                     realm_subdomain=None)\n            assert(user_profile is not None)\n            self.assertEqual(user_profile.email, self.example_email(\"hamlet\"))\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',))\n    def test_login_success_with_valid_subdomain(self):\n        # type: () -> None\n        self.mock_ldap.directory = {\n            'uid=hamlet,ou=users,dc=zulip,dc=com': {\n                'userPassword': 'testing'\n            }\n        }\n        with self.settings(\n                LDAP_APPEND_DOMAIN='zulip.com',\n                AUTH_LDAP_BIND_PASSWORD='',\n                AUTH_LDAP_USER_DN_TEMPLATE='uid=%(user)s,ou=users,dc=zulip,dc=com'):\n            user_profile = self.backend.authenticate(self.example_email(\"hamlet\"), 'testing',\n                                                     realm_subdomain='zulip')\n            assert(user_profile is not None)\n            self.assertEqual(user_profile.email, self.example_email(\"hamlet\"))\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',))\n    def test_login_success_when_user_does_not_exist_with_valid_subdomain(self):\n        # type: () -> None\n        self.mock_ldap.directory = {\n            'uid=nonexisting,ou=users,dc=acme,dc=com': {\n                'cn': ['NonExisting', ],\n                'userPassword': 'testing'\n            }\n        }\n        with self.settings(\n                LDAP_APPEND_DOMAIN='acme.com',\n                AUTH_LDAP_BIND_PASSWORD='',\n                AUTH_LDAP_USER_DN_TEMPLATE='uid=%(user)s,ou=users,dc=acme,dc=com'):\n            user_profile = self.backend.authenticate('nonexisting@acme.com', 'testing',\n                                                     realm_subdomain='zulip')\n            assert(user_profile is not None)\n            self.assertEqual(user_profile.email, 'nonexisting@acme.com')\n            self.assertEqual(user_profile.full_name, 'NonExisting')\n            self.assertEqual(user_profile.realm.string_id, 'zulip')\n\nclass TestZulipLDAPUserPopulator(ZulipTestCase):\n    def test_authenticate(self):\n        # type: () -> None\n        backend = ZulipLDAPUserPopulator()\n        result = backend.authenticate(self.example_email(\"hamlet\"), 'testing')  # type: ignore # complains that the function does not return any value!\n        self.assertIs(result, None)\n\nclass TestZulipAuthMixin(ZulipTestCase):\n    def test_get_user(self):\n        # type: () -> None\n        backend = ZulipAuthMixin()\n        result = backend.get_user(11111)\n        self.assertIs(result, None)\n\nclass TestPasswordAuthEnabled(ZulipTestCase):\n    def test_password_auth_enabled_for_ldap(self):\n        # type: () -> None\n        with self.settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',)):\n            realm = Realm.objects.get(string_id='zulip')\n            self.assertTrue(password_auth_enabled(realm))\n\nclass TestRequireEmailFormatUsernames(ZulipTestCase):\n    def test_require_email_format_usernames_for_ldap_with_append_domain(self):\n        # type: () -> None\n        with self.settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',),\n                           LDAP_APPEND_DOMAIN=\"zulip.com\"):\n            realm = Realm.objects.get(string_id='zulip')\n            self.assertFalse(require_email_format_usernames(realm))\n\n    def test_require_email_format_usernames_for_ldap_with_email_attr(self):\n        # type: () -> None\n        with self.settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',),\n                           LDAP_EMAIL_ATTR=\"email\"):\n            realm = Realm.objects.get(string_id='zulip')\n            self.assertFalse(require_email_format_usernames(realm))\n\n    def test_require_email_format_usernames_for_email_only(self):\n        # type: () -> None\n        with self.settings(AUTHENTICATION_BACKENDS=('zproject.backends.EmailAuthBackend',)):\n            realm = Realm.objects.get(string_id='zulip')\n            self.assertTrue(require_email_format_usernames(realm))\n\n    def test_require_email_format_usernames_for_email_and_ldap_with_email_attr(self):\n        # type: () -> None\n        with self.settings(AUTHENTICATION_BACKENDS=('zproject.backends.EmailAuthBackend',\n                                                    'zproject.backends.ZulipLDAPAuthBackend'),\n                           LDAP_EMAIL_ATTR=\"email\"):\n            realm = Realm.objects.get(string_id='zulip')\n            self.assertFalse(require_email_format_usernames(realm))\n\n    def test_require_email_format_usernames_for_email_and_ldap_with_append_email(self):\n        # type: () -> None\n        with self.settings(AUTHENTICATION_BACKENDS=('zproject.backends.EmailAuthBackend',\n                                                    'zproject.backends.ZulipLDAPAuthBackend'),\n                           LDAP_APPEND_DOMAIN=\"zulip.com\"):\n            realm = Realm.objects.get(string_id='zulip')\n            self.assertFalse(require_email_format_usernames(realm))\n\nclass TestMaybeSendToRegistration(ZulipTestCase):\n    def test_sso_only_when_preregistration_user_does_not_exist(self):\n        # type: () -> None\n        rf = RequestFactory()\n        request = rf.get('/')\n        request.session = {}\n        request.user = None\n\n        # Creating a mock Django form in order to keep the test simple.\n        # This form will be returned by the create_hompage_form function\n        # and will always be valid so that the code that we want to test\n        # actually runs.\n        class Form(object):\n            def is_valid(self):\n                # type: () -> bool\n                return True\n\n        with self.settings(ONLY_SSO=True):\n            with mock.patch('zerver.views.auth.HomepageForm', return_value=Form()):\n                self.assertEqual(PreregistrationUser.objects.all().count(), 0)\n                result = maybe_send_to_registration(request, self.example_email(\"hamlet\"))\n                self.assertEqual(result.status_code, 302)\n                confirmation = Confirmation.objects.all().first()\n                confirmation_key = confirmation.confirmation_key\n                self.assertIn('do_confirm/' + confirmation_key, result.url)\n                self.assertEqual(PreregistrationUser.objects.all().count(), 1)\n\n        result = self.client_get(result.url)\n        self.assert_in_response('action=\"/accounts/register/\"', result)\n        self.assert_in_response('value=\"{0}\" name=\"key\"'.format(confirmation_key), result)\n\n    def test_sso_only_when_preregistration_user_exists(self):\n        # type: () -> None\n        rf = RequestFactory()\n        request = rf.get('/')\n        request.session = {}\n        request.user = None\n\n        # Creating a mock Django form in order to keep the test simple.\n        # This form will be returned by the create_hompage_form function\n        # and will always be valid so that the code that we want to test\n        # actually runs.\n        class Form(object):\n            def is_valid(self):\n                # type: () -> bool\n                return True\n\n        email = self.example_email(\"hamlet\")\n        user = PreregistrationUser(email=email)\n        user.save()\n\n        with self.settings(ONLY_SSO=True):\n            with mock.patch('zerver.views.auth.HomepageForm', return_value=Form()):\n                self.assertEqual(PreregistrationUser.objects.all().count(), 1)\n                result = maybe_send_to_registration(request, email)\n                self.assertEqual(result.status_code, 302)\n                confirmation = Confirmation.objects.all().first()\n                confirmation_key = confirmation.confirmation_key\n                self.assertIn('do_confirm/' + confirmation_key, result.url)\n                self.assertEqual(PreregistrationUser.objects.all().count(), 1)\n\nclass TestAdminSetBackends(ZulipTestCase):\n\n    def test_change_enabled_backends(self):\n        # type: () -> None\n        # Log in as admin\n        self.login(self.example_email(\"iago\"))\n        result = self.client_patch(\"/json/realm\", {\n            'authentication_methods': ujson.dumps({u'Email': False, u'Dev': True})})\n        self.assert_json_success(result)\n        realm = get_realm('zulip')\n        self.assertFalse(password_auth_enabled(realm))\n        self.assertTrue(dev_auth_enabled(realm))\n\n    def test_disable_all_backends(self):\n        # type: () -> None\n        # Log in as admin\n        self.login(self.example_email(\"iago\"))\n        result = self.client_patch(\"/json/realm\", {\n            'authentication_methods': ujson.dumps({u'Email': False, u'Dev': False})})\n        self.assert_json_error(result, 'At least one authentication method must be enabled.')\n        realm = get_realm('zulip')\n        self.assertTrue(password_auth_enabled(realm))\n        self.assertTrue(dev_auth_enabled(realm))\n\n    def test_supported_backends_only_updated(self):\n        # type: () -> None\n        # Log in as admin\n        self.login(self.example_email(\"iago\"))\n        # Set some supported and unsupported backends\n        result = self.client_patch(\"/json/realm\", {\n            'authentication_methods': ujson.dumps({u'Email': False, u'Dev': True, u'GitHub': False})})\n        self.assert_json_success(result)\n        realm = get_realm('zulip')\n        # Check that unsupported backend is not enabled\n        self.assertFalse(github_auth_enabled(realm))\n        self.assertTrue(dev_auth_enabled(realm))\n        self.assertFalse(password_auth_enabled(realm))\n\nclass LoginEmailValidatorTestCase(ZulipTestCase):\n    def test_valid_email(self):\n        # type: () -> None\n        validate_login_email(self.example_email(\"hamlet\"))\n\n    def test_invalid_email(self):\n        # type: () -> None\n        with self.assertRaises(JsonableError):\n            validate_login_email(u'hamlet')\n\nclass LoginOrRegisterRemoteUserTestCase(ZulipTestCase):\n    def test_invalid_subdomain(self):\n        # type: () -> None\n        full_name = 'Hamlet'\n        invalid_subdomain = True\n        user_profile = self.example_user('hamlet')\n        request = POSTRequestMock({}, user_profile)\n        response = login_or_register_remote_user(\n            request,\n            self.example_email('hamlet'),\n            user_profile,\n            full_name=full_name,\n            invalid_subdomain=invalid_subdomain)\n        self.assertIn('/accounts/login/?subdomain=1', response.url)\n\nclass LDAPBackendTest(ZulipTestCase):\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',))\n    def test_non_existing_realm(self):\n        # type: () -> None\n        email = self.example_email('hamlet')\n        data = {'username': email, 'password': initial_password(email)}\n        error_type = ZulipLDAPAuthBackend.REALM_IS_NONE_ERROR\n        error = ZulipLDAPConfigurationError('Realm is None', error_type)\n        with mock.patch('zproject.backends.ZulipLDAPAuthBackend.get_or_create_user',\n                        side_effect=error), \\\n                mock.patch('django_auth_ldap.backend._LDAPUser._authenticate_user_dn'):\n            response = self.client_post('/login/', data)\n            self.assertEqual(response.status_code, 302)\n            self.assertEqual(response.url, reverse('ldap_error_realm_is_none'))\n            response = self.client_get(response.url)\n            self.assert_in_response('You are trying to login using LDAP '\n                                    'without creating an',\n                                    response)\n", "# -*- coding: utf-8 -*-\n\nimport datetime\nfrom typing import Any\n\nimport django\nimport mock\nfrom django.conf import settings\nfrom django.core import mail\nfrom django.http import HttpResponse\nfrom django.urls import reverse\nfrom django.utils.timezone import now\n\nfrom confirmation.models import Confirmation, generate_key, confirmation_url\nfrom zerver.lib.actions import do_start_email_change_process, do_set_realm_property\nfrom zerver.lib.test_classes import (\n    ZulipTestCase,\n)\nfrom zerver.lib.send_email import FromAddress\nfrom zerver.models import get_user, EmailChangeStatus, Realm, get_realm\n\n\nclass EmailChangeTestCase(ZulipTestCase):\n    def test_confirm_email_change_with_non_existent_key(self):\n        # type: () -> None\n        self.login(self.example_email(\"hamlet\"))\n        key = generate_key()\n        url = confirmation_url(key, 'testserver', Confirmation.EMAIL_CHANGE)\n        response = self.client_get(url)\n        self.assert_in_success_response([\"Whoops. We couldn't find your confirmation link in the system.\"], response)\n\n    def test_confirm_email_change_with_invalid_key(self):\n        # type: () -> None\n        self.login(self.example_email(\"hamlet\"))\n        key = 'invalid key'\n        url = confirmation_url(key, 'testserver', Confirmation.EMAIL_CHANGE)\n        response = self.client_get(url)\n        self.assert_in_success_response([\"Whoops. The confirmation link is malformed.\"], response)\n\n    def test_email_change_when_not_logging_in(self):\n        # type: () -> None\n        key = generate_key()\n        url = confirmation_url(key, 'testserver', Confirmation.EMAIL_CHANGE)\n        response = self.client_get(url)\n        self.assertEqual(response.status_code, 302)\n\n    def test_confirm_email_change_when_time_exceeded(self):\n        # type: () -> None\n        user_profile = self.example_user('hamlet')\n        old_email = user_profile.email\n        new_email = 'hamlet-new@zulip.com'\n        self.login(self.example_email(\"hamlet\"))\n        obj = EmailChangeStatus.objects.create(new_email=new_email,\n                                               old_email=old_email,\n                                               user_profile=user_profile,\n                                               realm=user_profile.realm)\n        key = generate_key()\n        date_sent = now() - datetime.timedelta(days=2)\n        Confirmation.objects.create(content_object=obj,\n                                    date_sent=date_sent,\n                                    confirmation_key=key,\n                                    type=Confirmation.EMAIL_CHANGE)\n        url = confirmation_url(key, user_profile.realm.host, Confirmation.EMAIL_CHANGE)\n        response = self.client_get(url)\n        self.assert_in_success_response([\"Whoops. The confirmation link has expired.\"], response)\n\n    def test_confirm_email_change(self):\n        # type: () -> None\n        user_profile = self.example_user('hamlet')\n        old_email = user_profile.email\n        new_email = 'hamlet-new@zulip.com'\n        new_realm = get_realm('zulip')\n        self.login(self.example_email('hamlet'))\n        obj = EmailChangeStatus.objects.create(new_email=new_email,\n                                               old_email=old_email,\n                                               user_profile=user_profile,\n                                               realm=user_profile.realm)\n        key = generate_key()\n        Confirmation.objects.create(content_object=obj,\n                                    date_sent=now(),\n                                    confirmation_key=key,\n                                    type=Confirmation.EMAIL_CHANGE)\n        url = confirmation_url(key, user_profile.realm.host, Confirmation.EMAIL_CHANGE)\n        response = self.client_get(url)\n\n        self.assertEqual(response.status_code, 200)\n        self.assert_in_success_response([\"This confirms that the email address for your Zulip\"],\n                                        response)\n        user_profile = get_user(new_email, new_realm)\n        self.assertTrue(bool(user_profile))\n        obj.refresh_from_db()\n        self.assertEqual(obj.status, 1)\n\n    def test_start_email_change_process(self):\n        # type: () -> None\n        user_profile = self.example_user('hamlet')\n        do_start_email_change_process(user_profile, 'hamlet-new@zulip.com')\n        self.assertEqual(EmailChangeStatus.objects.count(), 1)\n\n    def test_end_to_end_flow(self):\n        # type: () -> None\n        data = {'email': 'hamlet-new@zulip.com'}\n        email = self.example_email(\"hamlet\")\n        self.login(email)\n        url = '/json/settings'\n        self.assertEqual(len(mail.outbox), 0)\n        result = self.client_patch(url, data)\n        self.assertEqual(len(mail.outbox), 1)\n        self.assert_in_success_response(['Check your email for a confirmation link.'], result)\n        email_message = mail.outbox[0]\n        self.assertEqual(\n            email_message.subject,\n            'Verify your new email address'\n        )\n        body = email_message.body\n        from_email = email_message.from_email\n        self.assertIn('We received a request to change the email', body)\n        self.assertIn('Zulip Account Security', from_email)\n        self.assertIn(FromAddress.NOREPLY, email_message.from_email)\n\n        activation_url = [s for s in body.split('\\n') if s][4]\n        response = self.client_get(activation_url)\n\n        self.assert_in_success_response([\"This confirms that the email address\"],\n                                        response)\n\n        # Now confirm trying to change your email back doesn't throw an immediate error\n        result = self.client_patch(url, {\"email\": \"hamlet@zulip.com\"})\n        self.assert_in_success_response(['Check your email for a confirmation link.'], result)\n\n    def test_unauthorized_email_change(self):\n        # type: () -> None\n        data = {'email': 'hamlet-new@zulip.com'}\n        user_profile = self.example_user('hamlet')\n        email = user_profile.email\n        self.login(email)\n        do_set_realm_property(user_profile.realm, 'email_changes_disabled', True)\n        url = '/json/settings'\n        result = self.client_patch(url, data)\n        self.assertEqual(len(mail.outbox), 0)\n        self.assertEqual(result.status_code, 400)\n        self.assert_in_response(\"Email address changes are disabled in this organization.\",\n                                result)\n\n    def test_email_change_already_taken(self):\n        # type: () -> None\n        data = {'email': 'cordelia@zulip.com'}\n        user_profile = self.example_user('hamlet')\n        email = user_profile.email\n        self.login(email)\n\n        url = '/json/settings'\n        result = self.client_patch(url, data)\n        self.assertEqual(len(mail.outbox), 0)\n        self.assertEqual(result.status_code, 400)\n        self.assert_in_response(\"Already has an account\",\n                                result)\n\n    def test_unauthorized_email_change_from_email_confirmation_link(self):\n        # type: () -> None\n        data = {'email': 'hamlet-new@zulip.com'}\n        user_profile = self.example_user('hamlet')\n        email = user_profile.email\n        self.login(email)\n        url = '/json/settings'\n        self.assertEqual(len(mail.outbox), 0)\n        result = self.client_patch(url, data)\n        self.assertEqual(len(mail.outbox), 1)\n        self.assert_in_success_response(['Check your email for a confirmation link.'], result)\n        email_message = mail.outbox[0]\n        self.assertEqual(\n            email_message.subject,\n            'Verify your new email address'\n        )\n        body = email_message.body\n        self.assertIn('We received a request to change the email', body)\n\n        do_set_realm_property(user_profile.realm, 'email_changes_disabled', True)\n\n        activation_url = [s for s in body.split('\\n') if s][4]\n        response = self.client_get(activation_url)\n\n        self.assertEqual(response.status_code, 400)\n        self.assert_in_response(\"Email address changes are disabled in this organization.\",\n                                response)\n\n    def test_post_invalid_email(self):\n        # type: () -> None\n        data = {'email': 'hamlet-new'}\n        email = self.example_email(\"hamlet\")\n        self.login(email)\n        url = '/json/settings'\n        result = self.client_patch(url, data)\n        self.assert_in_response('Invalid address', result)\n\n    def test_post_same_email(self):\n        # type: () -> None\n        data = {'email': self.example_email(\"hamlet\")}\n        email = self.example_email(\"hamlet\")\n        self.login(email)\n        url = '/json/settings'\n        result = self.client_patch(url, data)\n        self.assertEqual('success', result.json()['result'])\n        self.assertEqual('', result.json()['msg'])\n", "# -*- coding: utf-8 -*-\nimport datetime\nfrom django.conf import settings\nfrom django.contrib.contenttypes.models import ContentType\nfrom django.contrib.sites.models import Site\nfrom django.http import HttpResponse\nfrom django.test import TestCase, override_settings\nfrom django.utils.timezone import now as timezone_now\n\nfrom mock import patch, MagicMock\nfrom zerver.lib.test_helpers import MockLDAP\n\nfrom confirmation.models import Confirmation, create_confirmation_link, MultiuseInvite, \\\n    generate_key, confirmation_url\n\nfrom zerver.forms import HomepageForm, WRONG_SUBDOMAIN_ERROR\nfrom zerver.lib.actions import do_change_password, gather_subscriptions\nfrom zerver.views.auth import login_or_register_remote_user\nfrom zerver.views.invite import get_invitee_emails_set\nfrom zerver.views.registration import confirmation_key, \\\n    redirect_and_log_into_subdomain, send_registration_completion_email\n\nfrom zerver.models import (\n    get_realm, get_prereg_user_by_email, get_user, get_recipient,\n    PreregistrationUser, Realm, RealmDomain, Recipient, Message,\n    ScheduledEmail, UserProfile, UserMessage,\n    Stream, Subscription, flush_per_request_caches\n)\nfrom zerver.lib.actions import (\n    set_default_streams,\n    do_change_is_admin,\n    get_stream,\n    do_create_realm,\n)\nfrom zerver.lib.send_email import send_email, send_future_email, FromAddress\nfrom zerver.lib.initial_password import initial_password\nfrom zerver.lib.actions import (\n    do_deactivate_realm,\n    do_deactivate_user,\n    do_set_realm_property,\n    add_new_user_history,\n)\nfrom zerver.lib.mobile_auth_otp import xor_hex_strings, ascii_to_hex, \\\n    otp_encrypt_api_key, is_valid_otp, hex_to_ascii, otp_decrypt_api_key\nfrom zerver.lib.notifications import enqueue_welcome_emails, \\\n    one_click_unsubscribe_link\nfrom zerver.lib.subdomains import is_root_domain_available\nfrom zerver.lib.test_helpers import find_pattern_in_email, find_key_by_email, queries_captured, \\\n    HostRequestMock, unsign_subdomain_cookie\nfrom zerver.lib.test_classes import (\n    ZulipTestCase,\n)\nfrom zerver.lib.test_runner import slow\nfrom zerver.lib.sessions import get_session_dict_user\nfrom zerver.context_processors import common_context\n\nfrom collections import defaultdict\nimport re\nimport smtplib\nimport ujson\n\nfrom typing import Any, Dict, List, Optional, Set, Text\n\nfrom six.moves import urllib, range, zip\nimport os\n\nclass RedirectAndLogIntoSubdomainTestCase(ZulipTestCase):\n    def test_cookie_data(self):\n        # type: () -> None\n        realm = Realm.objects.all().first()\n        name = 'Hamlet'\n        email = self.example_email(\"hamlet\")\n        response = redirect_and_log_into_subdomain(realm, name, email)\n        data = unsign_subdomain_cookie(response)\n        self.assertDictEqual(data, {'name': name, 'email': email,\n                                    'subdomain': realm.subdomain,\n                                    'is_signup': False})\n\n        response = redirect_and_log_into_subdomain(realm, name, email,\n                                                   is_signup=True)\n        data = unsign_subdomain_cookie(response)\n        self.assertDictEqual(data, {'name': name, 'email': email,\n                                    'subdomain': realm.subdomain,\n                                    'is_signup': True})\n\nclass DeactivationNoticeTestCase(ZulipTestCase):\n    def test_redirection_for_deactivated_realm(self):\n        # type: () -> None\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.save(update_fields=[\"deactivated\"])\n\n        for url in ('/register/', '/login/'):\n            result = self.client_get(url)\n            self.assertEqual(result.status_code, 302)\n            self.assertIn('deactivated', result.url)\n\n    def test_redirection_for_active_realm(self):\n        # type: () -> None\n        for url in ('/register/', '/login/'):\n            result = self.client_get(url)\n            self.assertEqual(result.status_code, 200)\n\n    def test_deactivation_notice_when_realm_is_active(self):\n        # type: () -> None\n        result = self.client_get('/accounts/deactivated/')\n        self.assertEqual(result.status_code, 302)\n        self.assertIn('login', result.url)\n\n    def test_deactivation_notice_when_deactivated(self):\n        # type: () -> None\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.save(update_fields=[\"deactivated\"])\n\n        result = self.client_get('/accounts/deactivated/')\n        self.assertIn(\"Zulip Dev, has been deactivated.\", result.content.decode())\n\nclass AddNewUserHistoryTest(ZulipTestCase):\n    def test_add_new_user_history_race(self):\n        # type: () -> None\n        \"\"\"Sends a message during user creation\"\"\"\n        # Create a user who hasn't had historical messages added\n        stream_dict = {\n            \"Denmark\": {\"description\": \"A Scandinavian country\", \"invite_only\": False},\n            \"Verona\": {\"description\": \"A city in Italy\", \"invite_only\": False}\n        }  # type: Dict[Text, Dict[Text, Any]]\n        realm = get_realm('zulip')\n        set_default_streams(realm, stream_dict)\n        with patch(\"zerver.lib.actions.add_new_user_history\"):\n            self.register(self.nonreg_email('test'), \"test\")\n        user_profile = self.nonreg_user('test')\n\n        subs = Subscription.objects.select_related(\"recipient\").filter(\n            user_profile=user_profile, recipient__type=Recipient.STREAM)\n        streams = Stream.objects.filter(id__in=[sub.recipient.type_id for sub in subs])\n        self.send_message(self.example_email('hamlet'), streams[0].name, Recipient.STREAM, \"test\")\n        add_new_user_history(user_profile, streams)\n\nclass PasswordResetTest(ZulipTestCase):\n    \"\"\"\n    Log in, reset password, log out, log in with new password.\n    \"\"\"\n\n    def test_password_reset(self):\n        # type: () -> None\n        email = self.example_email(\"hamlet\")\n        old_password = initial_password(email)\n\n        self.login(email)\n\n        # test password reset template\n        result = self.client_get('/accounts/password/reset/')\n        self.assert_in_response('Reset your password', result)\n\n        # start the password reset process by supplying an email address\n        result = self.client_post('/accounts/password/reset/', {'email': email})\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email to finish the process.\", result)\n\n        # Check that the password reset email is from a noreply address.\n        from django.core.mail import outbox\n        from_email = outbox[0].from_email\n        self.assertIn(\"Zulip Account Security\", from_email)\n        self.assertIn(FromAddress.NOREPLY, from_email)\n\n        # Visit the password reset link.\n        password_reset_url = self.get_confirmation_url_from_outbox(email, \"(\\S+)\")\n        result = self.client_get(password_reset_url)\n        self.assertEqual(result.status_code, 200)\n\n        # Reset your password\n        result = self.client_post(password_reset_url,\n                                  {'new_password1': 'new_password',\n                                   'new_password2': 'new_password'})\n\n        # password reset succeeded\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\"/password/done/\"))\n\n        # log back in with new password\n        self.login(email, password='new_password')\n        user_profile = self.example_user('hamlet')\n        self.assertEqual(get_session_dict_user(self.client.session), user_profile.id)\n\n        # make sure old password no longer works\n        self.login(email, password=old_password, fails=True)\n\n    def test_invalid_subdomain(self):\n        # type: () -> None\n        email = self.example_email(\"hamlet\")\n        string_id = 'hamlet'\n        name = 'Hamlet'\n        do_create_realm(\n            string_id,\n            name,\n            restricted_to_domain=False,\n            invite_required=False\n        )\n\n        with patch('zerver.forms.get_subdomain', return_value=string_id):\n            # start the password reset process by supplying an email address\n            result = self.client_post(\n                '/accounts/password/reset/', {'email': email})\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email to finish the process.\", result)\n\n        from django.core.mail import outbox\n        self.assertEqual(len(outbox), 1)\n        message = outbox.pop()\n        self.assertIn(FromAddress.NOREPLY, message.from_email)\n        self.assertIn(\"hamlet@zulip.com does not\\nhave an active account in http://\",\n                      message.body)\n\n    def test_correct_subdomain(self):\n        # type: () -> None\n        email = self.example_email(\"hamlet\")\n        string_id = 'zulip'\n\n        with patch('zerver.forms.get_subdomain', return_value=string_id):\n            # start the password reset process by supplying an email address\n            result = self.client_post(\n                '/accounts/password/reset/', {'email': email})\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email to finish the process.\", result)\n\n        from django.core.mail import outbox\n        self.assertEqual(len(outbox), 1)\n        message = outbox.pop()\n        self.assertIn(\"Zulip Account Security\", message.from_email)\n        self.assertIn(FromAddress.NOREPLY, message.from_email)\n        self.assertIn(\"Psst. Word on the street is that you\",\n                      message.body)\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',\n                                                'zproject.backends.ZulipDummyBackend'))\n    def test_ldap_auth_only(self):\n        # type: () -> None\n        \"\"\"If the email auth backend is not enabled, password reset should do nothing\"\"\"\n        email = self.example_email(\"hamlet\")\n        result = self.client_post('/accounts/password/reset/', {'email': email})\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email to finish the process.\", result)\n\n        from django.core.mail import outbox\n        self.assertEqual(len(outbox), 0)\n\n    def test_redirect_endpoints(self):\n        # type: () -> None\n        '''\n        These tests are mostly designed to give us 100% URL coverage\n        in our URL coverage reports.  Our mechanism for finding URL\n        coverage doesn't handle redirects, so we just have a few quick\n        tests here.\n        '''\n        result = self.client_get('/accounts/password/reset/done/')\n        self.assert_in_success_response([\"Check your email\"], result)\n\n        result = self.client_get('/accounts/password/done/')\n        self.assert_in_success_response([\"We've reset your password!\"], result)\n\n        result = self.client_get('/accounts/send_confirm/alice@example.com')\n        self.assert_in_success_response([\"Still no email?\"], result)\n\nclass LoginTest(ZulipTestCase):\n    \"\"\"\n    Logging in, registration, and logging out.\n    \"\"\"\n\n    def test_login(self):\n        # type: () -> None\n        self.login(self.example_email(\"hamlet\"))\n        user_profile = self.example_user('hamlet')\n        self.assertEqual(get_session_dict_user(self.client.session), user_profile.id)\n\n    def test_login_bad_password(self):\n        # type: () -> None\n        self.login(self.example_email(\"hamlet\"), password=\"wrongpassword\", fails=True)\n        self.assertIsNone(get_session_dict_user(self.client.session))\n\n    def test_login_nonexist_user(self):\n        # type: () -> None\n        result = self.login_with_return(\"xxx@zulip.com\", \"xxx\")\n        self.assert_in_response(\"Please enter a correct email and password\", result)\n\n    def test_register(self):\n        # type: () -> None\n        realm = get_realm(\"zulip\")\n        stream_dict = {\"stream_\"+str(i): {\"description\": \"stream_%s_description\" % i, \"invite_only\": False}\n                       for i in range(40)}  # type: Dict[Text, Dict[Text, Any]]\n        for stream_name in stream_dict.keys():\n            self.make_stream(stream_name, realm=realm)\n\n        set_default_streams(realm, stream_dict)\n        # Clear all the caches.\n        flush_per_request_caches()\n        ContentType.objects.clear_cache()\n        Site.objects.clear_cache()\n\n        with queries_captured() as queries:\n            self.register(self.nonreg_email('test'), \"test\")\n        # Ensure the number of queries we make is not O(streams)\n        self.assert_length(queries, 70)\n        user_profile = self.nonreg_user('test')\n        self.assertEqual(get_session_dict_user(self.client.session), user_profile.id)\n        self.assertFalse(user_profile.enable_stream_desktop_notifications)\n\n    def test_register_deactivated(self):\n        # type: () -> None\n        \"\"\"\n        If you try to register for a deactivated realm, you get a clear error\n        page.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.save(update_fields=[\"deactivated\"])\n\n        result = self.client_post('/accounts/home/', {'email': self.nonreg_email('test')},\n                                  subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual('/accounts/deactivated/', result.url)\n\n        with self.assertRaises(UserProfile.DoesNotExist):\n            self.nonreg_user('test')\n\n    def test_register_deactivated_partway_through(self):\n        # type: () -> None\n        \"\"\"\n        If you try to register for a deactivated realm, you get a clear error\n        page.\n        \"\"\"\n        email = self.nonreg_email('test')\n        result = self.client_post('/accounts/home/', {'email': email},\n                                  subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 302)\n        print(result.url)\n        self.assertNotIn('deactivated', result.url)\n\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.save(update_fields=[\"deactivated\"])\n\n        result = self.submit_reg_form_for_user(email, \"abcd1234\", subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual('/accounts/deactivated/', result.url)\n\n        with self.assertRaises(UserProfile.DoesNotExist):\n            self.nonreg_user('test')\n\n    def test_login_deactivated(self):\n        # type: () -> None\n        \"\"\"\n        If you try to log in to a deactivated realm, you get a clear error page.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.save(update_fields=[\"deactivated\"])\n\n        result = self.login_with_return(self.example_email(\"hamlet\"), subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual('/accounts/deactivated/', result.url)\n\n    def test_logout(self):\n        # type: () -> None\n        self.login(self.example_email(\"hamlet\"))\n        # We use the logout API, not self.logout, to make sure we test\n        # the actual logout code path.\n        self.client_post('/accounts/logout/')\n        self.assertIsNone(get_session_dict_user(self.client.session))\n\n    def test_non_ascii_login(self):\n        # type: () -> None\n        \"\"\"\n        You can log in even if your password contain non-ASCII characters.\n        \"\"\"\n        email = self.nonreg_email('test')\n        password = u\"h\u00c3\u00bcmb\u00c3\u00bc\u00c7\u00b5\"\n\n        # Registering succeeds.\n        self.register(email, password)\n        user_profile = self.nonreg_user('test')\n        self.assertEqual(get_session_dict_user(self.client.session), user_profile.id)\n        self.logout()\n        self.assertIsNone(get_session_dict_user(self.client.session))\n\n        # Logging in succeeds.\n        self.logout()\n        self.login(email, password)\n        self.assertEqual(get_session_dict_user(self.client.session), user_profile.id)\n\n    def test_login_page_redirects_logged_in_user(self):\n        # type: () -> None\n        \"\"\"You will be redirected to the app's main page if you land on the\n        login page when already logged in.\n        \"\"\"\n        self.login(self.example_email(\"cordelia\"))\n        response = self.client_get(\"/login/\")\n        self.assertEqual(response[\"Location\"], \"http://zulip.testserver\")\n\nclass InviteUserTest(ZulipTestCase):\n\n    def invite(self, users, streams, body=''):\n        # type: (Text, List[Text], str) -> HttpResponse\n        \"\"\"\n        Invites the specified users to Zulip with the specified streams.\n\n        users should be a string containing the users to invite, comma or\n            newline separated.\n\n        streams should be a list of strings.\n        \"\"\"\n\n        return self.client_post(\"/json/invites\",\n                                {\"invitee_emails\": users,\n                                 \"stream\": streams,\n                                 \"custom_body\": body})\n\n    def check_sent_emails(self, correct_recipients, custom_body=None, custom_from_name=None):\n        # type: (List[Text], Optional[str], Optional[str]) -> None\n        from django.core.mail import outbox\n        self.assertEqual(len(outbox), len(correct_recipients))\n        email_recipients = [email.recipients()[0] for email in outbox]\n        self.assertEqual(sorted(email_recipients), sorted(correct_recipients))\n        if len(outbox) == 0:\n            return\n\n        if custom_body is None:\n            self.assertNotIn(\"Message from\", outbox[0].body)\n        else:\n            self.assertIn(\"Message from \", outbox[0].body)\n            self.assertIn(custom_body, outbox[0].body)\n\n        if custom_from_name is not None:\n            self.assertIn(custom_from_name, outbox[0].from_email)\n\n        self.assertIn(FromAddress.NOREPLY, outbox[0].from_email)\n\n    def test_successful_invite_user(self):\n        # type: () -> None\n        \"\"\"\n        A call to /json/invites with valid parameters causes an invitation\n        email to be sent.\n        \"\"\"\n        self.login(self.example_email(\"hamlet\"))\n        invitee = \"alice-test@zulip.com\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(invitee))\n        self.check_sent_emails([invitee], custom_from_name=\"Hamlet\")\n\n    def test_successful_invite_user_with_custom_body(self):\n        # type: () -> None\n        \"\"\"\n        A call to /json/invites with valid parameters causes an invitation\n        email to be sent.\n        \"\"\"\n        self.login(self.example_email(\"hamlet\"))\n        invitee = \"alice-test@zulip.com\"\n        body = \"Custom Text.\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"], body))\n        self.assertTrue(find_pattern_in_email(invitee, body))\n        self.check_sent_emails([invitee], custom_body=body, custom_from_name=\"Hamlet\")\n\n    def test_successful_invite_user_with_name(self):\n        # type: () -> None\n        \"\"\"\n        A call to /json/invites with valid parameters causes an invitation\n        email to be sent.\n        \"\"\"\n        self.login(self.example_email(\"hamlet\"))\n        email = \"alice-test@zulip.com\"\n        invitee = \"Alice Test <{}>\".format(email)\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.check_sent_emails([email], custom_from_name=\"Hamlet\")\n\n    def test_successful_invite_user_with_name_and_normal_one(self):\n        # type: () -> None\n        \"\"\"\n        A call to /json/invites with valid parameters causes an invitation\n        email to be sent.\n        \"\"\"\n        self.login(self.example_email(\"hamlet\"))\n        email = \"alice-test@zulip.com\"\n        email2 = \"bob-test@zulip.com\"\n        invitee = \"Alice Test <{}>, {}\".format(email, email2)\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.assertTrue(find_key_by_email(email2))\n        self.check_sent_emails([email, email2], custom_from_name=\"Hamlet\")\n\n    def test_require_realm_admin(self):\n        # type: () -> None\n        \"\"\"\n        The invite_by_admins_only realm setting works properly.\n        \"\"\"\n        realm = get_realm('zulip')\n        realm.invite_by_admins_only = True\n        realm.save()\n\n        self.login(\"hamlet@zulip.com\")\n        email = \"alice-test@zulip.com\"\n        email2 = \"bob-test@zulip.com\"\n        invitee = \"Alice Test <{}>, {}\".format(email, email2)\n        self.assert_json_error(self.invite(invitee, [\"Denmark\"]),\n                               \"Must be a realm administrator\")\n\n        # Now verify an administrator can do it\n        self.login(\"iago@zulip.com\")\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.assertTrue(find_key_by_email(email2))\n        self.check_sent_emails([email, email2])\n\n    def test_successful_invite_user_with_notifications_stream(self):\n        # type: () -> None\n        \"\"\"\n        A call to /json/invites with valid parameters unconditionally\n        subscribes the invitee to the notifications stream if it exists and is\n        public.\n        \"\"\"\n        realm = get_realm('zulip')\n        notifications_stream = get_stream('Verona', realm)\n        realm.notifications_stream_id = notifications_stream.id\n        realm.save()\n\n        self.login(self.example_email(\"hamlet\"))\n        invitee = 'alice-test@zulip.com'\n        self.assert_json_success(self.invite(invitee, ['Denmark']))\n        self.assertTrue(find_key_by_email(invitee))\n        self.check_sent_emails([invitee])\n\n        prereg_user = get_prereg_user_by_email(invitee)\n        stream_ids = [stream.id for stream in prereg_user.streams.all()]\n        self.assertTrue(notifications_stream.id in stream_ids)\n\n    def test_invite_user_signup_initial_history(self):\n        # type: () -> None\n        \"\"\"\n        Test that a new user invited to a stream receives some initial\n        history but only from public streams.\n        \"\"\"\n        self.login(self.example_email('hamlet'))\n        user_profile = self.example_user('hamlet')\n        private_stream_name = \"Secret\"\n        self.make_stream(private_stream_name, invite_only=True)\n        self.subscribe(user_profile, private_stream_name)\n        public_msg_id = self.send_message(self.example_email(\"hamlet\"), \"Denmark\", Recipient.STREAM,\n                                          \"Public topic\", \"Public message\")\n        secret_msg_id = self.send_message(self.example_email(\"hamlet\"), private_stream_name, Recipient.STREAM,\n                                          \"Secret topic\", \"Secret message\")\n        invitee = self.nonreg_email('alice')\n        self.assert_json_success(self.invite(invitee, [private_stream_name, \"Denmark\"]))\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user('alice')\n        invitee_msg_ids = [um.message_id for um in\n                           UserMessage.objects.filter(user_profile=invitee_profile)]\n        self.assertTrue(public_msg_id in invitee_msg_ids)\n        self.assertFalse(secret_msg_id in invitee_msg_ids)\n\n        # Test that exactly 2 new Zulip messages were sent, both notifications.\n        last_3_messages = list(reversed(list(Message.objects.all().order_by(\"-id\")[0:3])))\n        first_msg = last_3_messages[0]\n        self.assertEqual(first_msg.id, secret_msg_id)\n\n        # The first, from notification-bot to the user who invited the new user.\n        second_msg = last_3_messages[1]\n        self.assertEqual(second_msg.sender.email, \"notification-bot@zulip.com\")\n        self.assertTrue(second_msg.content.startswith(\"alice_zulip.com <`alice@zulip.com`> accepted your\"))\n\n        # The second, from welcome-bot to the user who was invited.\n        third_msg = last_3_messages[2]\n        self.assertEqual(third_msg.sender.email, \"welcome-bot@zulip.com\")\n        self.assertTrue(third_msg.content.startswith(\"Hello, and welcome to Zulip!\"))\n\n    def test_multi_user_invite(self):\n        # type: () -> None\n        \"\"\"\n        Invites multiple users with a variety of delimiters.\n        \"\"\"\n        self.login(self.example_email(\"hamlet\"))\n        # Intentionally use a weird string.\n        self.assert_json_success(self.invite(\n            \"\"\"bob-test@zulip.com,     carol-test@zulip.com,\n            dave-test@zulip.com\n\n\nearl-test@zulip.com\"\"\", [\"Denmark\"]))\n        for user in (\"bob\", \"carol\", \"dave\", \"earl\"):\n            self.assertTrue(find_key_by_email(\"%s-test@zulip.com\" % (user,)))\n        self.check_sent_emails([\"bob-test@zulip.com\", \"carol-test@zulip.com\",\n                                \"dave-test@zulip.com\", \"earl-test@zulip.com\"])\n\n    def test_missing_or_invalid_params(self):\n        # type: () -> None\n        \"\"\"\n        Tests inviting with various missing or invalid parameters.\n        \"\"\"\n        self.login(self.example_email(\"hamlet\"))\n        self.assert_json_error(\n            self.client_post(\"/json/invites\",\n                             {\"invitee_emails\": \"foo@zulip.com\",\n                              \"custom_body\": ''}),\n            \"You must specify at least one stream for invitees to join.\")\n\n        for address in (\"noatsign.com\", \"outsideyourdomain@example.net\"):\n            self.assert_json_error(\n                self.invite(address, [\"Denmark\"]),\n                \"Some emails did not validate, so we didn't send any invitations.\")\n        self.check_sent_emails([])\n\n        self.assert_json_error(\n            self.invite(\"\", [\"Denmark\"]),\n            \"You must specify at least one email address.\")\n        self.check_sent_emails([])\n\n    def test_invalid_stream(self):\n        # type: () -> None\n        \"\"\"\n        Tests inviting to a non-existent stream.\n        \"\"\"\n        self.login(self.example_email(\"hamlet\"))\n        self.assert_json_error(self.invite(\"iago-test@zulip.com\", [\"NotARealStream\"]),\n                               \"Stream does not exist: NotARealStream. No invites were sent.\")\n        self.check_sent_emails([])\n\n    def test_invite_existing_user(self):\n        # type: () -> None\n        \"\"\"\n        If you invite an address already using Zulip, no invitation is sent.\n        \"\"\"\n        self.login(self.example_email(\"hamlet\"))\n        self.assert_json_error(\n            self.client_post(\"/json/invites\",\n                             {\"invitee_emails\": self.example_email(\"hamlet\"),\n                              \"stream\": [\"Denmark\"],\n                              \"custom_body\": ''}),\n            \"We weren't able to invite anyone.\")\n        self.assertRaises(PreregistrationUser.DoesNotExist,\n                          lambda: PreregistrationUser.objects.get(\n                              email=self.example_email(\"hamlet\")))\n        self.check_sent_emails([])\n\n    def test_invite_some_existing_some_new(self):\n        # type: () -> None\n        \"\"\"\n        If you invite a mix of already existing and new users, invitations are\n        only sent to the new users.\n        \"\"\"\n        self.login(self.example_email(\"hamlet\"))\n        existing = [self.example_email(\"hamlet\"), u\"othello@zulip.com\"]\n        new = [u\"foo-test@zulip.com\", u\"bar-test@zulip.com\"]\n\n        result = self.client_post(\"/json/invites\",\n                                  {\"invitee_emails\": \"\\n\".join(existing + new),\n                                   \"stream\": [\"Denmark\"],\n                                   \"custom_body\": ''})\n        self.assert_json_error(result,\n                               \"Some of those addresses are already using Zulip, \\\nso we didn't send them an invitation. We did send invitations to everyone else!\")\n\n        # We only created accounts for the new users.\n        for email in existing:\n            self.assertRaises(PreregistrationUser.DoesNotExist,\n                              lambda: PreregistrationUser.objects.get(\n                                  email=email))\n        for email in new:\n            self.assertTrue(PreregistrationUser.objects.get(email=email))\n\n        # We only sent emails to the new users.\n        self.check_sent_emails(new)\n\n        prereg_user = get_prereg_user_by_email('foo-test@zulip.com')\n        self.assertEqual(prereg_user.email, 'foo-test@zulip.com')\n\n    def test_invite_outside_domain_in_closed_realm(self):\n        # type: () -> None\n        \"\"\"\n        In a realm with `restricted_to_domain = True`, you can't invite people\n        with a different domain from that of the realm or your e-mail address.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.restricted_to_domain = True\n        zulip_realm.save()\n\n        self.login(self.example_email(\"hamlet\"))\n        external_address = \"foo@example.com\"\n\n        self.assert_json_error(\n            self.invite(external_address, [\"Denmark\"]),\n            \"Some emails did not validate, so we didn't send any invitations.\")\n\n    def test_invite_outside_domain_in_open_realm(self):\n        # type: () -> None\n        \"\"\"\n        In a realm with `restricted_to_domain = False`, you can invite people\n        with a different domain from that of the realm or your e-mail address.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.restricted_to_domain = False\n        zulip_realm.save()\n\n        self.login(self.example_email(\"hamlet\"))\n        external_address = \"foo@example.com\"\n\n        self.assert_json_success(self.invite(external_address, [\"Denmark\"]))\n        self.check_sent_emails([external_address])\n\n    def test_invite_outside_domain_before_closing(self):\n        # type: () -> None\n        \"\"\"\n        If you invite someone with a different domain from that of the realm\n        when `restricted_to_domain = False`, but `restricted_to_domain` later\n        changes to true, the invitation should succeed but the invitee's signup\n        attempt should fail.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.restricted_to_domain = False\n        zulip_realm.save()\n\n        self.login(self.example_email(\"hamlet\"))\n        external_address = \"foo@example.com\"\n\n        self.assert_json_success(self.invite(external_address, [\"Denmark\"]))\n        self.check_sent_emails([external_address])\n\n        zulip_realm.restricted_to_domain = True\n        zulip_realm.save()\n\n        result = self.submit_reg_form_for_user(\"foo@example.com\", \"password\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\"only allows users with e-mail\", result)\n\n    def test_invite_with_non_ascii_streams(self):\n        # type: () -> None\n        \"\"\"\n        Inviting someone to streams with non-ASCII characters succeeds.\n        \"\"\"\n        self.login(self.example_email(\"hamlet\"))\n        invitee = \"alice-test@zulip.com\"\n\n        stream_name = u\"h\u00c3\u00bcmb\u00c3\u00bc\u00c7\u00b5\"\n\n        # Make sure we're subscribed before inviting someone.\n        self.subscribe(self.example_user(\"hamlet\"), stream_name)\n\n        self.assert_json_success(self.invite(invitee, [stream_name]))\n\n    def test_invitation_reminder_email(self):\n        # type: () -> None\n        from django.core.mail import outbox\n\n        # All users belong to zulip realm\n        referrer_user = 'hamlet'\n        current_user_email = self.example_email(referrer_user)\n        self.login(current_user_email)\n        invitee_email = self.nonreg_email('alice')\n        self.assert_json_success(self.invite(invitee_email, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(invitee_email))\n        self.check_sent_emails([invitee_email])\n\n        data = {\"email\": invitee_email, \"referrer_email\": current_user_email}\n        invitee = get_prereg_user_by_email(data[\"email\"])\n        referrer = self.example_user(referrer_user)\n        link = create_confirmation_link(invitee, referrer.realm.host, Confirmation.INVITATION)\n        context = common_context(referrer)\n        context.update({\n            'activate_url': link,\n            'referrer_name': referrer.full_name,\n            'referrer_email': referrer.email,\n            'referrer_realm_name': referrer.realm.name,\n        })\n        with self.settings(EMAIL_BACKEND='django.core.mail.backends.console.EmailBackend'):\n            send_future_email(\n                \"zerver/emails/invitation_reminder\", to_email=data[\"email\"],\n                from_address=FromAddress.NOREPLY, context=context)\n        email_jobs_to_deliver = ScheduledEmail.objects.filter(\n            scheduled_timestamp__lte=timezone_now())\n        self.assertEqual(len(email_jobs_to_deliver), 1)\n        email_count = len(outbox)\n        for job in email_jobs_to_deliver:\n            send_email(**ujson.loads(job.data))\n        self.assertEqual(len(outbox), email_count + 1)\n        self.assertIn(FromAddress.NOREPLY, outbox[-1].from_email)\n\n        # Now verify that signing up clears invite_reminder emails\n        email_jobs_to_deliver = ScheduledEmail.objects.filter(\n            scheduled_timestamp__lte=timezone_now(), type=ScheduledEmail.INVITATION_REMINDER)\n        self.assertEqual(len(email_jobs_to_deliver), 1)\n\n        self.register(invitee_email, \"test\")\n        email_jobs_to_deliver = ScheduledEmail.objects.filter(\n            scheduled_timestamp__lte=timezone_now(), type=ScheduledEmail.INVITATION_REMINDER)\n        self.assertEqual(len(email_jobs_to_deliver), 0)\n\nclass InviteeEmailsParserTests(TestCase):\n    def setUp(self):\n        # type: () -> None\n        self.email1 = \"email1@zulip.com\"\n        self.email2 = \"email2@zulip.com\"\n        self.email3 = \"email3@zulip.com\"\n\n    def test_if_emails_separated_by_commas_are_parsed_and_striped_correctly(self):\n        # type: () -> None\n        emails_raw = \"{} ,{}, {}\".format(self.email1, self.email2, self.email3)\n        expected_set = {self.email1, self.email2, self.email3}\n        self.assertEqual(get_invitee_emails_set(emails_raw), expected_set)\n\n    def test_if_emails_separated_by_newlines_are_parsed_and_striped_correctly(self):\n        # type: () -> None\n        emails_raw = \"{}\\n {}\\n {} \".format(self.email1, self.email2, self.email3)\n        expected_set = {self.email1, self.email2, self.email3}\n        self.assertEqual(get_invitee_emails_set(emails_raw), expected_set)\n\n    def test_if_emails_from_email_client_separated_by_newlines_are_parsed_correctly(self):\n        # type: () -> None\n        emails_raw = \"Email One <{}>\\nEmailTwo<{}>\\nEmail Three<{}>\".format(self.email1, self.email2, self.email3)\n        expected_set = {self.email1, self.email2, self.email3}\n        self.assertEqual(get_invitee_emails_set(emails_raw), expected_set)\n\n    def test_if_emails_in_mixed_style_are_parsed_correctly(self):\n        # type: () -> None\n        emails_raw = \"Email One <{}>,EmailTwo<{}>\\n{}\".format(self.email1, self.email2, self.email3)\n        expected_set = {self.email1, self.email2, self.email3}\n        self.assertEqual(get_invitee_emails_set(emails_raw), expected_set)\n\nclass MultiuseInviteTest(ZulipTestCase):\n    def setUp(self):\n        # type: () -> None\n        self.realm = get_realm('zulip')\n        self.realm.invite_required = True\n        self.realm.save()\n\n    def generate_multiuse_invite_link(self, streams=None, date_sent=None):\n        # type: (List[Stream], Optional[datetime.datetime]) -> Text\n        invite = MultiuseInvite(realm=self.realm, referred_by=self.example_user(\"iago\"))\n        invite.save()\n\n        if streams is not None:\n            invite.streams = streams\n            invite.save()\n\n        if date_sent is None:\n            date_sent = timezone_now()\n        key = generate_key()\n        Confirmation.objects.create(content_object=invite, date_sent=date_sent,\n                                    confirmation_key=key, type=Confirmation.MULTIUSE_INVITE)\n\n        return confirmation_url(key, self.realm.host, Confirmation.MULTIUSE_INVITE)\n\n    def check_user_able_to_register(self, email, invite_link):\n        # type: (Text, Text) -> None\n        password = \"password\"\n\n        result = self.client_post(invite_link, {'email': email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/send_confirm/%s\" % (email,)))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(email, password)\n        self.assertEqual(result.status_code, 302)\n\n        from django.core.mail import outbox\n        outbox.pop()\n\n    def check_user_subscribed_only_to_streams(self, user_name, streams):\n        # type: (str, List[Stream]) -> None\n        sorted(streams, key=lambda x: x.name)\n        subscribed_streams = gather_subscriptions(self.nonreg_user(user_name))[0]\n\n        self.assertEqual(len(subscribed_streams), len(streams))\n\n        for x, y in zip(subscribed_streams, streams):\n            self.assertEqual(x[\"name\"], y.name)\n\n    def test_valid_multiuse_link(self):\n        # type: () -> None\n        email1 = self.nonreg_email(\"test\")\n        email2 = self.nonreg_email(\"test1\")\n        email3 = self.nonreg_email(\"alice\")\n\n        date_sent = timezone_now() - datetime.timedelta(days=settings.INVITATION_LINK_VALIDITY_DAYS - 1)\n        invite_link = self.generate_multiuse_invite_link(date_sent=date_sent)\n\n        self.check_user_able_to_register(email1, invite_link)\n        self.check_user_able_to_register(email2, invite_link)\n        self.check_user_able_to_register(email3, invite_link)\n\n    def test_expired_multiuse_link(self):\n        # type: () -> None\n        email = self.nonreg_email('newuser')\n        date_sent = timezone_now() - datetime.timedelta(days=settings.INVITATION_LINK_VALIDITY_DAYS)\n        invite_link = self.generate_multiuse_invite_link(date_sent=date_sent)\n        result = self.client_post(invite_link, {'email': email})\n\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\"Whoops. The confirmation link has expired.\", result)\n\n    def test_invalid_multiuse_link(self):\n        # type: () -> None\n        email = self.nonreg_email('newuser')\n        invite_link = \"/join/invalid_key/\"\n        result = self.client_post(invite_link, {'email': email})\n\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\"Whoops. The confirmation link is malformed.\", result)\n\n    def test_invalid_multiuse_link_in_open_realm(self):\n        # type: () -> None\n        self.realm.invite_required = False\n        self.realm.save()\n\n        email = self.nonreg_email('newuser')\n        invite_link = \"/join/invalid_key/\"\n\n        with patch('zerver.views.registration.get_realm_from_request', return_value=self.realm):\n            with patch('zerver.views.registration.get_realm', return_value=self.realm):\n                self.check_user_able_to_register(email, invite_link)\n\n    def test_multiuse_link_with_specified_streams(self):\n        # type: () -> None\n        name1 = \"newuser\"\n        name2 = \"bob\"\n        email1 = self.nonreg_email(name1)\n        email2 = self.nonreg_email(name2)\n\n        stream_names = [\"Rome\", \"Scotland\", \"Venice\"]\n        streams = [get_stream(stream_name, self.realm) for stream_name in stream_names]\n        invite_link = self.generate_multiuse_invite_link(streams=streams)\n        self.check_user_able_to_register(email1, invite_link)\n        self.check_user_subscribed_only_to_streams(name1, streams)\n\n        stream_names = [\"Rome\", \"Verona\"]\n        streams = [get_stream(stream_name, self.realm) for stream_name in stream_names]\n        invite_link = self.generate_multiuse_invite_link(streams=streams)\n        self.check_user_able_to_register(email2, invite_link)\n        self.check_user_subscribed_only_to_streams(name2, streams)\n\nclass EmailUnsubscribeTests(ZulipTestCase):\n    def test_error_unsubscribe(self):\n        # type: () -> None\n\n        # An invalid insubscribe token \"test123\" produces an error.\n        result = self.client_get('/accounts/unsubscribe/missed_messages/test123')\n        self.assert_in_response('Unknown email unsubscribe request', result)\n\n        # An unknown message type \"fake\" produces an error.\n        user_profile = self.example_user('hamlet')\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"fake\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n        self.assert_in_response('Unknown email unsubscribe request', result)\n\n    def test_missedmessage_unsubscribe(self):\n        # type: () -> None\n        \"\"\"\n        We provide one-click unsubscribe links in missed message\n        e-mails that you can click even when logged out to update your\n        email notification settings.\n        \"\"\"\n        user_profile = self.example_user('hamlet')\n        user_profile.enable_offline_email_notifications = True\n        user_profile.save()\n\n        unsubscribe_link = one_click_unsubscribe_link(user_profile,\n                                                      \"missed_messages\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n\n        self.assertEqual(result.status_code, 200)\n\n        user_profile.refresh_from_db()\n        self.assertFalse(user_profile.enable_offline_email_notifications)\n\n    def test_welcome_unsubscribe(self):\n        # type: () -> None\n        \"\"\"\n        We provide one-click unsubscribe links in welcome e-mails that you can\n        click even when logged out to stop receiving them.\n        \"\"\"\n        user_profile = self.example_user('hamlet')\n        # Simulate a new user signing up, which enqueues 2 welcome e-mails.\n        enqueue_welcome_emails(user_profile)\n        self.assertEqual(2, ScheduledEmail.objects.filter(user=user_profile).count())\n\n        # Simulate unsubscribing from the welcome e-mails.\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"welcome\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n\n        # The welcome email jobs are no longer scheduled.\n        self.assertEqual(result.status_code, 200)\n        self.assertEqual(0, ScheduledEmail.objects.filter(user=user_profile).count())\n\n    def test_digest_unsubscribe(self):\n        # type: () -> None\n        \"\"\"\n        We provide one-click unsubscribe links in digest e-mails that you can\n        click even when logged out to stop receiving them.\n\n        Unsubscribing from these emails also dequeues any digest email jobs that\n        have been queued.\n        \"\"\"\n        user_profile = self.example_user('hamlet')\n        self.assertTrue(user_profile.enable_digest_emails)\n\n        # Enqueue a fake digest email.\n        context = {'name': '', 'realm_uri': '', 'unread_pms': [], 'hot_conversations': [],\n                   'new_users': [], 'new_streams': {'plain': []}, 'unsubscribe_link': ''}\n        send_future_email('zerver/emails/digest', to_user_id=user_profile.id, context=context)\n\n        self.assertEqual(1, ScheduledEmail.objects.filter(user=user_profile).count())\n\n        # Simulate unsubscribing from digest e-mails.\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"digest\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n\n        # The setting is toggled off, and scheduled jobs have been removed.\n        self.assertEqual(result.status_code, 200)\n        # Circumvent user_profile caching.\n\n        user_profile.refresh_from_db()\n        self.assertFalse(user_profile.enable_digest_emails)\n        self.assertEqual(0, ScheduledEmail.objects.filter(user=user_profile).count())\n\nclass RealmCreationTest(ZulipTestCase):\n    def test_create_realm(self):\n        # type: () -> None\n        password = \"test\"\n        string_id = \"zuliptest\"\n        email = \"user1@test.com\"\n        realm = get_realm('test')\n\n        # Make sure the realm does not exist\n        self.assertIsNone(realm)\n\n        with self.settings(OPEN_REALM_CREATION=True):\n            # Create new realm with the email\n            result = self.client_post('/create_realm/', {'email': email})\n            self.assertEqual(result.status_code, 302)\n            self.assertTrue(result[\"Location\"].endswith(\n                \"/accounts/send_confirm/%s\" % (email,)))\n            result = self.client_get(result[\"Location\"])\n            self.assert_in_response(\"Check your email so we can get started.\", result)\n\n            # Visit the confirmation link.\n            confirmation_url = self.get_confirmation_url_from_outbox(email)\n            result = self.client_get(confirmation_url)\n            self.assertEqual(result.status_code, 200)\n\n            result = self.submit_reg_form_for_user(email, password, realm_subdomain=string_id)\n            self.assertEqual(result.status_code, 302)\n\n            # Make sure the realm is created\n            realm = get_realm(string_id)\n            self.assertIsNotNone(realm)\n            self.assertEqual(realm.string_id, string_id)\n            self.assertEqual(get_user(email, realm).realm, realm)\n\n            # Check defaults\n            self.assertEqual(realm.org_type, Realm.CORPORATE)\n            self.assertEqual(realm.restricted_to_domain, False)\n            self.assertEqual(realm.invite_required, True)\n\n            self.assertTrue(result[\"Location\"].endswith(\"/\"))\n\n            # Check welcome messages\n            for stream_name, text, message_count in [\n                    ('announce', 'This is', 1),\n                    ('core team', 'This is', 1),\n                    ('general', 'Welcome to', 1),\n                    ('new members', 'stream is', 1),\n                    ('zulip', 'Here is', 3)]:\n                stream = get_stream(stream_name, realm)\n                recipient = get_recipient(Recipient.STREAM, stream.id)\n                messages = Message.objects.filter(recipient=recipient).order_by('pub_date')\n                self.assertEqual(len(messages), message_count)\n                self.assertIn(text, messages[0].content)\n\n    def test_create_realm_existing_email(self):\n        # type: () -> None\n        \"\"\"\n        Trying to create a realm with an existing email should just redirect to\n        a login page.\n        \"\"\"\n        with self.settings(OPEN_REALM_CREATION=True):\n            email = self.example_email(\"hamlet\")\n            result = self.client_post('/create_realm/', {'email': email})\n            self.assertEqual(result.status_code, 302)\n            self.assertIn('login', result['Location'])\n\n    def test_create_realm_no_creation_key(self):\n        # type: () -> None\n        \"\"\"\n        Trying to create a realm without a creation_key should fail when\n        OPEN_REALM_CREATION is false.\n        \"\"\"\n        email = \"user1@test.com\"\n        realm = get_realm('test')\n\n        # Make sure the realm does not exist\n        self.assertIsNone(realm)\n\n        with self.settings(OPEN_REALM_CREATION=False):\n            # Create new realm with the email, but no creation key.\n            result = self.client_post('/create_realm/', {'email': email})\n            self.assertEqual(result.status_code, 200)\n            self.assert_in_response('New organization creation disabled.', result)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_create_realm_with_subdomain(self):\n        # type: () -> None\n        password = \"test\"\n        string_id = \"zuliptest\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        # Make sure the realm does not exist\n        self.assertIsNone(get_realm('test'))\n\n        # Create new realm with the email\n        result = self.client_post('/create_realm/', {'email': email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/send_confirm/%s\" % (email,)))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(email, password,\n                                               realm_subdomain = string_id,\n                                               realm_name=realm_name,\n                                               # Pass HTTP_HOST for the target subdomain\n                                               HTTP_HOST=string_id + \".testserver\")\n        self.assertEqual(result.status_code, 302)\n\n        # Make sure the realm is created\n        realm = get_realm(string_id)\n        self.assertIsNotNone(realm)\n        self.assertEqual(realm.string_id, string_id)\n        self.assertEqual(get_user(email, realm).realm, realm)\n\n        self.assertEqual(realm.name, realm_name)\n        self.assertEqual(realm.subdomain, string_id)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_mailinator_signup(self):\n        # type: () -> None\n        result = self.client_post('/create_realm/', {'email': \"hi@mailinator.com\"})\n        self.assert_in_response('Please use your real email address.', result)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_subdomain_restrictions(self):\n        # type: () -> None\n        password = \"test\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        result = self.client_post('/create_realm/', {'email': email})\n        self.client_get(result[\"Location\"])\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        self.client_get(confirmation_url)\n\n        errors = {'id': \"length 3 or greater\",\n                  '-id': \"cannot start or end with a\",\n                  'string-ID': \"lowercase letters\",\n                  'string_id': \"lowercase letters\",\n                  'stream': \"unavailable\",\n                  'streams': \"unavailable\",\n                  'about': \"unavailable\",\n                  'abouts': \"unavailable\",\n                  'zephyr': \"unavailable\"}\n        for string_id, error_msg in errors.items():\n            result = self.submit_reg_form_for_user(email, password,\n                                                   realm_subdomain = string_id,\n                                                   realm_name = realm_name)\n            self.assert_in_response(error_msg, result)\n\n        # test valid subdomain\n        result = self.submit_reg_form_for_user(email, password,\n                                               realm_subdomain = 'a-0',\n                                               realm_name = realm_name)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, 'http://a-0.testserver/accounts/login/subdomain/')\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_subdomain_restrictions_root_domain(self):\n        # type: () -> None\n        password = \"test\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        result = self.client_post('/create_realm/', {'email': email})\n        self.client_get(result[\"Location\"])\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        self.client_get(confirmation_url)\n\n        # test root domain will fail with ROOT_DOMAIN_LANDING_PAGE\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            result = self.submit_reg_form_for_user(email, password,\n                                                   realm_subdomain = '',\n                                                   realm_name = realm_name)\n            self.assert_in_response('unavailable', result)\n\n        # test valid use of root domain\n        result = self.submit_reg_form_for_user(email, password,\n                                               realm_subdomain = '',\n                                               realm_name = realm_name)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, 'http://testserver/accounts/login/subdomain/')\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_subdomain_restrictions_root_domain_option(self):\n        # type: () -> None\n        password = \"test\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        result = self.client_post('/create_realm/', {'email': email})\n        self.client_get(result[\"Location\"])\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        self.client_get(confirmation_url)\n\n        # test root domain will fail with ROOT_DOMAIN_LANDING_PAGE\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            result = self.submit_reg_form_for_user(email, password,\n                                                   realm_subdomain = 'abcdef',\n                                                   realm_in_root_domain = 'true',\n                                                   realm_name = realm_name)\n            self.assert_in_response('unavailable', result)\n\n        # test valid use of root domain\n        result = self.submit_reg_form_for_user(email, password,\n                                               realm_subdomain = 'abcdef',\n                                               realm_in_root_domain = 'true',\n                                               realm_name = realm_name)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, 'http://testserver/accounts/login/subdomain/')\n\n    def test_is_root_domain_available(self):\n        # type: () -> None\n        self.assertTrue(is_root_domain_available())\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            self.assertFalse(is_root_domain_available())\n        realm = get_realm(\"zulip\")\n        realm.string_id = Realm.SUBDOMAIN_FOR_ROOT_DOMAIN\n        realm.save()\n        self.assertFalse(is_root_domain_available())\n\nclass UserSignUpTest(ZulipTestCase):\n\n    def _assert_redirected_to(self, result, url):\n        # type: (HttpResponse, Text) -> None\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result['LOCATION'], url)\n\n    def test_bad_email_configuration_for_accounts_home(self):\n        # type: () -> None\n        \"\"\"\n        Make sure we redirect for SMTP errors.\n        \"\"\"\n        email = self.nonreg_email('newguy')\n\n        smtp_mock = patch(\n            'zerver.views.registration.send_registration_completion_email',\n            side_effect=smtplib.SMTPException('uh oh')\n        )\n\n        error_mock = patch('logging.error')\n\n        with smtp_mock, error_mock as err:\n            result = self.client_post('/accounts/home/', {'email': email})\n\n        self._assert_redirected_to(result, '/config-error/smtp')\n\n        self.assertEqual(\n            err.call_args_list[0][0][0],\n            'Error in accounts_home: uh oh'\n        )\n\n    def test_bad_email_configuration_for_create_realm(self):\n        # type: () -> None\n        \"\"\"\n        Make sure we redirect for SMTP errors.\n        \"\"\"\n        email = self.nonreg_email('newguy')\n\n        smtp_mock = patch(\n            'zerver.views.registration.send_registration_completion_email',\n            side_effect=smtplib.SMTPException('uh oh')\n        )\n\n        error_mock = patch('logging.error')\n\n        with smtp_mock, error_mock as err:\n            result = self.client_post('/create_realm/', {'email': email})\n\n        self._assert_redirected_to(result, '/config-error/smtp')\n\n        self.assertEqual(\n            err.call_args_list[0][0][0],\n            'Error in create_realm: uh oh'\n        )\n\n    def test_user_default_language_and_timezone(self):\n        # type: () -> None\n        \"\"\"\n        Check if the default language of new user is the default language\n        of the realm.\n        \"\"\"\n        email = self.nonreg_email('newguy')\n        password = \"newpassword\"\n        timezone = \"US/Mountain\"\n        realm = get_realm('zulip')\n        do_set_realm_property(realm, 'default_language', u\"de\")\n\n        result = self.client_post('/accounts/home/', {'email': email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/send_confirm/%s\" % (email,)))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        # Pick a password and agree to the ToS.\n        result = self.submit_reg_form_for_user(email, password, timezone=timezone)\n        self.assertEqual(result.status_code, 302)\n\n        user_profile = self.nonreg_user('newguy')\n        self.assertEqual(user_profile.default_language, realm.default_language)\n        self.assertEqual(user_profile.timezone, timezone)\n        from django.core.mail import outbox\n        outbox.pop()\n\n    def test_signup_already_active(self):\n        # type: () -> None\n        \"\"\"\n        Check if signing up with an active email redirects to a login page.\n        \"\"\"\n        email = self.example_email(\"hamlet\")\n        result = self.client_post('/accounts/home/', {'email': email})\n        self.assertEqual(result.status_code, 302)\n        self.assertIn('login', result['Location'])\n        result = self.client_get(result.url)\n        self.assert_in_response(\"You've already registered\", result)\n\n    def test_signup_invalid_name(self):\n        # type: () -> None\n        \"\"\"\n        Check if an invalid name during signup is handled properly.\n        \"\"\"\n        email = \"newguy@zulip.com\"\n        password = \"newpassword\"\n\n        result = self.client_post('/accounts/home/', {'email': email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/send_confirm/%s\" % (email,)))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        # Pick a password and agree to the ToS.\n        result = self.submit_reg_form_for_user(email, password, full_name=\"<invalid>\")\n        self.assert_in_success_response([\"Invalid characters in name!\"], result)\n\n        # Verify that the user is asked for name and password\n        self.assert_in_success_response(['id_password', 'id_full_name'], result)\n\n    def test_signup_without_password(self):\n        # type: () -> None\n        \"\"\"\n        Check if signing up without a password works properly when\n        password_auth_enabled is False.\n        \"\"\"\n\n        email = self.nonreg_email('newuser')\n\n        result = self.client_post('/accounts/home/', {'email': email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/send_confirm/%s\" % (email,)))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        with patch('zerver.views.registration.password_auth_enabled', return_value=False):\n            result = self.client_post(\n                '/accounts/register/',\n                {'full_name': 'New User',\n                 'key': find_key_by_email(email),\n                 'terms': True})\n\n        # User should now be logged in.\n        self.assertEqual(result.status_code, 302)\n        user_profile = self.nonreg_user('newuser')\n        self.assertEqual(get_session_dict_user(self.client.session), user_profile.id)\n\n    def test_signup_without_full_name(self):\n        # type: () -> None\n        \"\"\"\n        Check if signing up without a full name redirects to a registration\n        form.\n        \"\"\"\n        email = \"newguy@zulip.com\"\n        password = \"newpassword\"\n\n        result = self.client_post('/accounts/home/', {'email': email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/send_confirm/%s\" % (email,)))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.client_post(\n            '/accounts/register/',\n            {'password': password,\n             'key': find_key_by_email(email),\n             'terms': True,\n             'from_confirmation': '1'})\n        self.assert_in_success_response([\"You're almost there.\"], result)\n\n        # Verify that the user is asked for name and password\n        self.assert_in_success_response(['id_password', 'id_full_name'], result)\n\n    def test_signup_with_full_name(self):\n        # type: () -> None\n        \"\"\"\n        Check if signing up without a full name redirects to a registration\n        form.\n        \"\"\"\n        email = \"newguy@zulip.com\"\n        password = \"newpassword\"\n\n        result = self.client_post('/accounts/home/', {'email': email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/send_confirm/%s\" % (email,)))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.client_post(\n            '/accounts/register/',\n            {'password': password,\n             'key': find_key_by_email(email),\n             'terms': True,\n             'full_name': \"New Guy\",\n             'from_confirmation': '1'})\n        self.assert_in_success_response([\"You're almost there.\"], result)\n\n    def test_signup_invalid_subdomain(self):\n        # type: () -> None\n        \"\"\"\n        Check if attempting to authenticate to the wrong subdomain logs an\n        error and redirects.\n        \"\"\"\n        email = \"newuser@zulip.com\"\n        password = \"newpassword\"\n\n        result = self.client_post('/accounts/home/', {'email': email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/send_confirm/%s\" % (email,)))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        def invalid_subdomain(**kwargs):\n            # type: (**Any) -> Any\n            return_data = kwargs.get('return_data', {})\n            return_data['invalid_subdomain'] = True\n\n        with patch('zerver.views.registration.authenticate', side_effect=invalid_subdomain):\n            with patch('logging.error') as mock_error:\n                result = self.client_post(\n                    '/accounts/register/',\n                    {'password': password,\n                     'full_name': 'New User',\n                     'key': find_key_by_email(email),\n                     'terms': True})\n        mock_error.assert_called_once()\n        self.assertEqual(result.status_code, 302)\n\n    def test_replace_subdomain_in_confirmation_link(self) -> None:\n        \"\"\"\n        Check that manually changing the subdomain in a registration\n        confirmation link doesn't allow you to register to a different realm.\n        \"\"\"\n        email = \"newuser@zulip.com\"\n        self.client_post('/accounts/home/', {'email': email})\n        result = self.client_post(\n            '/accounts/register/',\n            {'password': \"password\",\n             'key': find_key_by_email(email),\n             'terms': True,\n             'full_name': \"New User\",\n             'from_confirmation': '1'},  subdomain=\"zephyr\")\n        self.assert_in_success_response([\"We couldn't find your confirmation link\"], result)\n\n    def test_failed_signup_due_to_restricted_domain(self):\n        # type: () -> None\n        realm = get_realm('zulip')\n        realm.invite_required = False\n        realm.save()\n\n        request = HostRequestMock(host = realm.host)\n        request.session = {}  # type: ignore\n        email = 'user@acme.com'\n        form = HomepageForm({'email': email}, realm=realm)\n        self.assertIn(\"Your email address, {}, is not in one of the domains\".format(email),\n                      form.errors['email'][0])\n\n    def test_failed_signup_due_to_invite_required(self):\n        # type: () -> None\n        realm = get_realm('zulip')\n        realm.invite_required = True\n        realm.save()\n        request = HostRequestMock(host = realm.host)\n        request.session = {}  # type: ignore\n        email = 'user@zulip.com'\n        form = HomepageForm({'email': email}, realm=realm)\n        self.assertIn(\"Please request an invite for {} from\".format(email),\n                      form.errors['email'][0])\n\n    def test_failed_signup_due_to_nonexistent_realm(self):\n        # type: () -> None\n        request = HostRequestMock(host = 'acme.' + settings.EXTERNAL_HOST)\n        request.session = {}  # type: ignore\n        email = 'user@acme.com'\n        form = HomepageForm({'email': email}, realm=None)\n        self.assertIn(\"organization you are trying to join using {} does \"\n                      \"not exist\".format(email), form.errors['email'][0])\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',\n                                                'zproject.backends.ZulipDummyBackend'))\n    def test_ldap_registration_from_confirmation(self):\n        # type: () -> None\n        password = \"testing\"\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n        ldap_user_attr_map = {'full_name': 'fn', 'short_name': 'sn'}\n\n        ldap_patcher = patch('django_auth_ldap.config.ldap.initialize')\n        mock_initialize = ldap_patcher.start()\n        mock_ldap = MockLDAP()\n        mock_initialize.return_value = mock_ldap\n\n        mock_ldap.directory = {\n            'uid=newuser,ou=users,dc=zulip,dc=com': {\n                'userPassword': 'testing',\n                'fn': ['New LDAP fullname']\n            }\n        }\n\n        with patch('zerver.views.registration.get_subdomain', return_value=subdomain):\n            result = self.client_post('/register/', {'email': email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/send_confirm/%s\" % (email,)))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        # Visit the confirmation link.\n        from django.core.mail import outbox\n        for message in reversed(outbox):\n            if email in message.to:\n                confirmation_link_pattern = re.compile(settings.EXTERNAL_HOST + \"(\\S+)>\")\n                confirmation_url = confirmation_link_pattern.search(\n                    message.body).groups()[0]\n                break\n        else:\n            raise AssertionError(\"Couldn't find a confirmation email.\")\n\n        with self.settings(\n                POPULATE_PROFILE_VIA_LDAP=True,\n                LDAP_APPEND_DOMAIN='zulip.com',\n                AUTH_LDAP_BIND_PASSWORD='',\n                AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n                AUTH_LDAP_USER_DN_TEMPLATE='uid=%(user)s,ou=users,dc=zulip,dc=com'):\n            result = self.client_get(confirmation_url)\n            self.assertEqual(result.status_code, 200)\n\n            # Full name should be set from LDAP\n            result = self.submit_reg_form_for_user(email,\n                                                   password,\n                                                   full_name=\"Ignore\",\n                                                   from_confirmation=\"1\",\n                                                   # Pass HTTP_HOST for the target subdomain\n                                                   HTTP_HOST=subdomain + \".testserver\")\n\n            self.assert_in_success_response([\"You're almost there.\",\n                                             \"New LDAP fullname\",\n                                             \"newuser@zulip.com\"],\n                                            result)\n\n            # Verify that the user is asked for name\n            self.assert_in_success_response(['id_full_name'], result)\n            # TODO: Ideally, we wouldn't ask for a password if LDAP is\n            # enabled, in which case this assert should be invertedq.\n            self.assert_in_success_response(['id_password'], result)\n\n            # Test the TypeError exception handler\n            mock_ldap.directory = {\n                'uid=newuser,ou=users,dc=zulip,dc=com': {\n                    'userPassword': 'testing',\n                    'fn': None  # This will raise TypeError\n                }\n            }\n            result = self.submit_reg_form_for_user(email,\n                                                   password,\n                                                   from_confirmation='1',\n                                                   # Pass HTTP_HOST for the target subdomain\n                                                   HTTP_HOST=subdomain + \".testserver\")\n            self.assert_in_success_response([\"You're almost there.\",\n                                             \"newuser@zulip.com\"],\n                                            result)\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',\n                                                'zproject.backends.ZulipDummyBackend'))\n    def test_ldap_registration_end_to_end(self):\n        # type: () -> None\n        password = \"testing\"\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n\n        ldap_user_attr_map = {'full_name': 'fn', 'short_name': 'sn'}\n\n        ldap_patcher = patch('django_auth_ldap.config.ldap.initialize')\n        mock_initialize = ldap_patcher.start()\n        mock_ldap = MockLDAP()\n        mock_initialize.return_value = mock_ldap\n\n        full_name = 'New LDAP fullname'\n        mock_ldap.directory = {\n            'uid=newuser,ou=users,dc=zulip,dc=com': {\n                'userPassword': 'testing',\n                'fn': [full_name],\n                'sn': ['shortname'],\n            }\n        }\n\n        with patch('zerver.views.registration.get_subdomain', return_value=subdomain):\n            result = self.client_post('/register/', {'email': email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/send_confirm/%s\" % (email,)))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        with self.settings(\n                POPULATE_PROFILE_VIA_LDAP=True,\n                LDAP_APPEND_DOMAIN='zulip.com',\n                AUTH_LDAP_BIND_PASSWORD='',\n                AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n                AUTH_LDAP_USER_DN_TEMPLATE='uid=%(user)s,ou=users,dc=zulip,dc=com'):\n\n            # Click confirmation link\n            result = self.submit_reg_form_for_user(email,\n                                                   password,\n                                                   full_name=\"Ignore\",\n                                                   from_confirmation=\"1\",\n                                                   # Pass HTTP_HOST for the target subdomain\n                                                   HTTP_HOST=subdomain + \".testserver\")\n\n            # Full name should be set from LDAP\n            self.assert_in_success_response([\"You're almost there.\",\n                                             full_name,\n                                             \"newuser@zulip.com\"],\n                                            result)\n\n            # Submit the final form with the wrong password.\n            result = self.submit_reg_form_for_user(email,\n                                                   'wrongpassword',\n                                                   full_name=full_name,\n                                                   # Pass HTTP_HOST for the target subdomain\n                                                   HTTP_HOST=subdomain + \".testserver\")\n            # Didn't create an account\n            with self.assertRaises(UserProfile.DoesNotExist):\n                user_profile = UserProfile.objects.get(email=email)\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"/accounts/login/?email=newuser%40zulip.com\")\n\n            # Submit the final form with the wrong password.\n            result = self.submit_reg_form_for_user(email,\n                                                   password,\n                                                   full_name=full_name,\n                                                   # Pass HTTP_HOST for the target subdomain\n                                                   HTTP_HOST=subdomain + \".testserver\")\n            user_profile = UserProfile.objects.get(email=email)\n            # Name comes from form which was set by LDAP.\n            self.assertEqual(user_profile.full_name, full_name)\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',\n                                                'zproject.backends.ZulipDummyBackend'))\n    def test_ldap_auto_registration_on_login(self):\n        # type: () -> None\n        \"\"\"The most common way for LDAP authentication to be used is with a\n        server that doesn't have a terms-of-service required, in which\n        case we offer a complete single-sign-on experience (where the\n        user just enters their LDAP username and password, and their\n        account is created if it doesn't already exist).\n\n        This test verifies that flow.\n        \"\"\"\n        password = \"testing\"\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n\n        ldap_user_attr_map = {'full_name': 'fn', 'short_name': 'sn'}\n\n        ldap_patcher = patch('django_auth_ldap.config.ldap.initialize')\n        mock_initialize = ldap_patcher.start()\n        mock_ldap = MockLDAP()\n        mock_initialize.return_value = mock_ldap\n\n        full_name = 'New LDAP fullname'\n        mock_ldap.directory = {\n            'uid=newuser,ou=users,dc=zulip,dc=com': {\n                'userPassword': 'testing',\n                'fn': [full_name],\n                'sn': ['shortname'],\n            }\n        }\n\n        with self.settings(\n                POPULATE_PROFILE_VIA_LDAP=True,\n                LDAP_APPEND_DOMAIN='zulip.com',\n                AUTH_LDAP_BIND_PASSWORD='',\n                AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n                AUTH_LDAP_USER_DN_TEMPLATE='uid=%(user)s,ou=users,dc=zulip,dc=com'):\n\n            self.login_with_return(email, password,\n                                   HTTP_HOST=subdomain + \".testserver\")\n\n            user_profile = UserProfile.objects.get(email=email)\n            # Name comes from form which was set by LDAP.\n            self.assertEqual(user_profile.full_name, full_name)\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',\n                                                'zproject.backends.ZulipDummyBackend'))\n    def test_ldap_registration_when_names_changes_are_disabled(self):\n        # type: () -> None\n        password = \"testing\"\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n\n        ldap_user_attr_map = {'full_name': 'fn', 'short_name': 'sn'}\n\n        ldap_patcher = patch('django_auth_ldap.config.ldap.initialize')\n        mock_initialize = ldap_patcher.start()\n        mock_ldap = MockLDAP()\n        mock_initialize.return_value = mock_ldap\n\n        mock_ldap.directory = {\n            'uid=newuser,ou=users,dc=zulip,dc=com': {\n                'userPassword': 'testing',\n                'fn': ['New LDAP fullname'],\n                'sn': ['New LDAP shortname'],\n            }\n        }\n\n        with patch('zerver.views.registration.get_subdomain', return_value=subdomain):\n            result = self.client_post('/register/', {'email': email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/send_confirm/%s\" % (email,)))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        with self.settings(\n                POPULATE_PROFILE_VIA_LDAP=True,\n                LDAP_APPEND_DOMAIN='zulip.com',\n                AUTH_LDAP_BIND_PASSWORD='',\n                AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n                AUTH_LDAP_USER_DN_TEMPLATE='uid=%(user)s,ou=users,dc=zulip,dc=com'):\n\n            # Click confirmation link. This will 'authenticated_full_name'\n            # session variable which will be used to set the fullname of\n            # the user.\n            result = self.submit_reg_form_for_user(email,\n                                                   password,\n                                                   full_name=\"Ignore\",\n                                                   from_confirmation=\"1\",\n                                                   # Pass HTTP_HOST for the target subdomain\n                                                   HTTP_HOST=subdomain + \".testserver\")\n\n            with patch('zerver.views.registration.name_changes_disabled', return_value=True):\n                result = self.submit_reg_form_for_user(email,\n                                                       password,\n                                                       # Pass HTTP_HOST for the target subdomain\n                                                       HTTP_HOST=subdomain + \".testserver\")\n            user_profile = UserProfile.objects.get(email=email)\n            # Name comes from LDAP session.\n            self.assertEqual(user_profile.full_name, 'New LDAP fullname')\n\n    def test_registration_when_name_changes_are_disabled(self):\n        # type: () -> None\n        \"\"\"\n        Test `name_changes_disabled` when we are not running under LDAP.\n        \"\"\"\n        password = \"testing\"\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n\n        with patch('zerver.views.registration.get_subdomain', return_value=subdomain):\n            result = self.client_post('/register/', {'email': email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/send_confirm/%s\" % (email,)))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        with patch('zerver.views.registration.name_changes_disabled', return_value=True):\n            result = self.submit_reg_form_for_user(email,\n                                                   password,\n                                                   full_name=\"New Name\",\n                                                   # Pass HTTP_HOST for the target subdomain\n                                                   HTTP_HOST=subdomain + \".testserver\")\n            user_profile = UserProfile.objects.get(email=email)\n            # 'New Name' comes from POST data; not from LDAP session.\n            self.assertEqual(user_profile.full_name, 'New Name')\n\n    def test_realm_creation_through_ldap(self):\n        # type: () -> None\n        password = \"testing\"\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n        realm_name = \"Zulip\"\n        ldap_user_attr_map = {'full_name': 'fn', 'short_name': 'sn'}\n\n        ldap_patcher = patch('django_auth_ldap.config.ldap.initialize')\n        mock_initialize = ldap_patcher.start()\n        mock_ldap = MockLDAP()\n        mock_initialize.return_value = mock_ldap\n\n        mock_ldap.directory = {\n            'uid=newuser,ou=users,dc=zulip,dc=com': {\n                'userPassword': 'testing',\n                'fn': ['New User Name']\n            }\n        }\n\n        with patch('zerver.views.registration.get_subdomain', return_value=subdomain):\n            result = self.client_post('/register/', {'email': email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/send_confirm/%s\" % (email,)))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        # Visit the confirmation link.\n        from django.core.mail import outbox\n        for message in reversed(outbox):\n            if email in message.to:\n                confirmation_link_pattern = re.compile(settings.EXTERNAL_HOST + \"(\\S+)>\")\n                confirmation_url = confirmation_link_pattern.search(\n                    message.body).groups()[0]\n                break\n        else:\n            raise AssertionError(\"Couldn't find a confirmation email.\")\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN='zulip.com',\n            AUTH_LDAP_BIND_PASSWORD='',\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n            AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',),\n            AUTH_LDAP_USER_DN_TEMPLATE='uid=%(user)s,ou=users,dc=zulip,dc=com',\n            TERMS_OF_SERVICE=False,\n        ):\n            result = self.client_get(confirmation_url)\n            self.assertEqual(result.status_code, 200)\n\n            key = find_key_by_email(email),\n            confirmation = Confirmation.objects.get(confirmation_key=key[0])\n            prereg_user = confirmation.content_object\n            prereg_user.realm_creation = True\n            prereg_user.save()\n\n            result = self.submit_reg_form_for_user(email,\n                                                   password,\n                                                   realm_name=realm_name,\n                                                   realm_subdomain=subdomain,\n                                                   from_confirmation='1',\n                                                   # Pass HTTP_HOST for the target subdomain\n                                                   HTTP_HOST=subdomain + \".testserver\")\n            self.assert_in_success_response([\"You're almost there.\",\n                                             \"newuser@zulip.com\"],\n                                            result)\n\n        mock_ldap.reset()\n        mock_initialize.stop()\n\n    @patch('DNS.dnslookup', return_value=[['sipbtest:*:20922:101:Fred Sipb,,,:/mit/sipbtest:/bin/athena/tcsh']])\n    def test_registration_of_mirror_dummy_user(self, ignored):\n        # type: (Any) -> None\n        password = \"test\"\n        subdomain = \"zephyr\"\n        user_profile = self.mit_user(\"sipbtest\")\n        email = user_profile.email\n        user_profile.is_mirror_dummy = True\n        user_profile.is_active = False\n        user_profile.save()\n\n        result = self.client_post('/register/', {'email': email}, subdomain=\"zephyr\")\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/send_confirm/%s\" % (email,)))\n        result = self.client_get(result[\"Location\"], subdomain=\"zephyr\")\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        # Visit the confirmation link.\n        from django.core.mail import outbox\n        for message in reversed(outbox):\n            if email in message.to:\n                confirmation_link_pattern = re.compile(settings.EXTERNAL_HOST + \"(\\S+)>\")\n                confirmation_url = confirmation_link_pattern.search(\n                    message.body).groups()[0]\n                break\n        else:\n            raise AssertionError(\"Couldn't find a confirmation email.\")\n\n        result = self.client_get(confirmation_url, subdomain=\"zephyr\")\n        self.assertEqual(result.status_code, 200)\n\n        # If the mirror dummy user is already active, attempting to submit the\n        # registration form should just redirect to a login page.\n        user_profile.is_active = True\n        user_profile.save()\n        result = self.submit_reg_form_for_user(email,\n                                               password,\n                                               from_confirmation='1',\n                                               # Pass HTTP_HOST for the target subdomain\n                                               HTTP_HOST=subdomain + \".testserver\")\n\n        self.assertEqual(result.status_code, 302)\n        self.assertIn('login', result['Location'])\n        user_profile.is_active = False\n        user_profile.save()\n\n        result = self.submit_reg_form_for_user(email,\n                                               password,\n                                               from_confirmation='1',\n                                               # Pass HTTP_HOST for the target subdomain\n                                               HTTP_HOST=subdomain + \".testserver\")\n        self.assertEqual(result.status_code, 200)\n        result = self.submit_reg_form_for_user(email,\n                                               password,\n                                               # Pass HTTP_HOST for the target subdomain\n                                               HTTP_HOST=subdomain + \".testserver\")\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(get_session_dict_user(self.client.session), user_profile.id)\n\n    def test_registration_of_active_mirror_dummy_user(self):\n        # type: (Any) -> None\n        \"\"\"\n        Trying to activate an already-active mirror dummy user should just\n        redirect to a login page.\n        \"\"\"\n        user_profile = self.mit_user(\"sipbtest\")\n        email = user_profile.email\n        user_profile.is_mirror_dummy = True\n        user_profile.is_active = True\n        user_profile.save()\n\n        result = self.client_post('/register/', {'email': email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertIn('login', result['Location'])\n\nclass DeactivateUserTest(ZulipTestCase):\n\n    def test_deactivate_user(self):\n        # type: () -> None\n        email = self.example_email(\"hamlet\")\n        self.login(email)\n        user = self.example_user('hamlet')\n        self.assertTrue(user.is_active)\n        result = self.client_delete('/json/users/me')\n        self.assert_json_success(result)\n        user = self.example_user('hamlet')\n        self.assertFalse(user.is_active)\n        self.login(email, fails=True)\n\n    def test_do_not_deactivate_final_admin(self):\n        # type: () -> None\n        email = self.example_email(\"iago\")\n        self.login(email)\n        user = self.example_user('iago')\n        self.assertTrue(user.is_active)\n        result = self.client_delete('/json/users/me')\n        self.assert_json_error(result, \"Cannot deactivate the only organization administrator\")\n        user = self.example_user('iago')\n        self.assertTrue(user.is_active)\n        self.assertTrue(user.is_realm_admin)\n        email = self.example_email(\"hamlet\")\n        user_2 = self.example_user('hamlet')\n        do_change_is_admin(user_2, True)\n        self.assertTrue(user_2.is_realm_admin)\n        result = self.client_delete('/json/users/me')\n        self.assert_json_success(result)\n        do_change_is_admin(user, True)\n\nclass TestLoginPage(ZulipTestCase):\n    def test_login_page_wrong_subdomain_error(self):\n        # type: () -> None\n        result = self.client_get(\"/login/?subdomain=1\")\n        self.assertIn(WRONG_SUBDOMAIN_ERROR, result.content.decode('utf8'))\n\n    @patch('django.http.HttpRequest.get_host')\n    def test_login_page_redirects_for_root_alias(self, mock_get_host):\n        # type: (MagicMock) -> None\n        mock_get_host.return_value = 'www.testserver'\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, '/accounts/find/')\n\n    @patch('django.http.HttpRequest.get_host')\n    def test_login_page_redirects_for_root_domain(self, mock_get_host):\n        # type: (MagicMock) -> None\n        mock_get_host.return_value = 'testserver'\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, '/accounts/find/')\n\n        mock_get_host.return_value = 'www.testserver.com'\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True,\n                           EXTERNAL_HOST='www.testserver.com',\n                           ROOT_SUBDOMAIN_ALIASES=['test']):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, '/accounts/find/')\n\n    @patch('django.http.HttpRequest.get_host')\n    def test_login_page_works_without_subdomains(self, mock_get_host):\n        # type: (MagicMock) -> None\n        mock_get_host.return_value = 'www.testserver'\n        with self.settings(ROOT_SUBDOMAIN_ALIASES=['www']):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 200)\n\n        mock_get_host.return_value = 'testserver'\n        with self.settings(ROOT_SUBDOMAIN_ALIASES=['www']):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 200)\n\nclass TestFindMyTeam(ZulipTestCase):\n    def test_template(self):\n        # type: () -> None\n        result = self.client_get('/accounts/find/')\n        self.assertIn(\"Find your Zulip accounts\", result.content.decode('utf8'))\n\n    def test_result(self):\n        # type: () -> None\n        result = self.client_post('/accounts/find/',\n                                  dict(emails=\"iago@zulip.com,cordelia@zulip.com\"))\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"/accounts/find/?emails=iago%40zulip.com%2Ccordelia%40zulip.com\")\n        result = self.client_get(result.url)\n        content = result.content.decode('utf8')\n        self.assertIn(\"Emails sent! You will only receive emails\", content)\n        self.assertIn(self.example_email(\"iago\"), content)\n        self.assertIn(self.example_email(\"cordelia\"), content)\n        from django.core.mail import outbox\n        self.assertEqual(len(outbox), 2)\n\n    def test_find_team_ignore_invalid_email(self):\n        # type: () -> None\n        result = self.client_post('/accounts/find/',\n                                  dict(emails=\"iago@zulip.com,invalid_email@zulip.com\"))\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"/accounts/find/?emails=iago%40zulip.com%2Cinvalid_email%40zulip.com\")\n        result = self.client_get(result.url)\n        content = result.content.decode('utf8')\n        self.assertIn(\"Emails sent! You will only receive emails\", content)\n        self.assertIn(self.example_email(\"iago\"), content)\n        self.assertIn(\"invalid_email@\", content)\n        from django.core.mail import outbox\n        self.assertEqual(len(outbox), 1)\n\n    def test_find_team_reject_invalid_email(self):\n        # type: () -> None\n        result = self.client_post('/accounts/find/',\n                                  dict(emails=\"invalid_string\"))\n        self.assertEqual(result.status_code, 200)\n        self.assertIn(b\"Enter a valid email\", result.content)\n        from django.core.mail import outbox\n        self.assertEqual(len(outbox), 0)\n\n        # Just for coverage on perhaps-unnecessary validation code.\n        result = self.client_get('/accounts/find/?emails=invalid')\n        self.assertEqual(result.status_code, 200)\n\n    def test_find_team_zero_emails(self):\n        # type: () -> None\n        data = {'emails': ''}\n        result = self.client_post('/accounts/find/', data)\n        self.assertIn('This field is required', result.content.decode('utf8'))\n        self.assertEqual(result.status_code, 200)\n        from django.core.mail import outbox\n        self.assertEqual(len(outbox), 0)\n\n    def test_find_team_one_email(self):\n        # type: () -> None\n        data = {'emails': self.example_email(\"hamlet\")}\n        result = self.client_post('/accounts/find/', data)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, '/accounts/find/?emails=hamlet%40zulip.com')\n        from django.core.mail import outbox\n        self.assertEqual(len(outbox), 1)\n\n    def test_find_team_deactivated_user(self):\n        # type: () -> None\n        do_deactivate_user(self.example_user(\"hamlet\"))\n        data = {'emails': self.example_email(\"hamlet\")}\n        result = self.client_post('/accounts/find/', data)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, '/accounts/find/?emails=hamlet%40zulip.com')\n        from django.core.mail import outbox\n        self.assertEqual(len(outbox), 0)\n\n    def test_find_team_deactivated_realm(self):\n        # type: () -> None\n        do_deactivate_realm(get_realm(\"zulip\"))\n        data = {'emails': self.example_email(\"hamlet\")}\n        result = self.client_post('/accounts/find/', data)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, '/accounts/find/?emails=hamlet%40zulip.com')\n        from django.core.mail import outbox\n        self.assertEqual(len(outbox), 0)\n\n    def test_find_team_bot_email(self):\n        # type: () -> None\n        data = {'emails': self.example_email(\"webhook_bot\")}\n        result = self.client_post('/accounts/find/', data)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, '/accounts/find/?emails=webhook-bot%40zulip.com')\n        from django.core.mail import outbox\n        self.assertEqual(len(outbox), 0)\n\n    def test_find_team_more_than_ten_emails(self):\n        # type: () -> None\n        data = {'emails': ','.join(['hamlet-{}@zulip.com'.format(i) for i in range(11)])}\n        result = self.client_post('/accounts/find/', data)\n        self.assertEqual(result.status_code, 200)\n        self.assertIn(\"Please enter at most 10\", result.content.decode('utf8'))\n        from django.core.mail import outbox\n        self.assertEqual(len(outbox), 0)\n\nclass ConfirmationKeyTest(ZulipTestCase):\n    def test_confirmation_key(self):\n        # type: () -> None\n        request = MagicMock()\n        request.session = {\n            'confirmation_key': {'confirmation_key': 'xyzzy'}\n        }\n        result = confirmation_key(request)\n        self.assert_json_success(result)\n        self.assert_in_response('xyzzy', result)\n\nclass MobileAuthOTPTest(ZulipTestCase):\n    def test_xor_hex_strings(self):\n        # type: () -> None\n        self.assertEqual(xor_hex_strings('1237c81ab', '18989fd12'), '0aaf57cb9')\n        with self.assertRaises(AssertionError):\n            xor_hex_strings('1', '31')\n\n    def test_is_valid_otp(self):\n        # type: () -> None\n        self.assertEqual(is_valid_otp('1234'), False)\n        self.assertEqual(is_valid_otp('1234abcd' * 8), True)\n        self.assertEqual(is_valid_otp('1234abcZ' * 8), False)\n\n    def test_ascii_to_hex(self):\n        # type: () -> None\n        self.assertEqual(ascii_to_hex('ZcdR1234'), '5a63645231323334')\n        self.assertEqual(hex_to_ascii('5a63645231323334'), 'ZcdR1234')\n\n    def test_otp_encrypt_api_key(self):\n        # type: () -> None\n        hamlet = self.example_user('hamlet')\n        hamlet.api_key = '12ac' * 8\n        otp = '7be38894' * 8\n        result = otp_encrypt_api_key(hamlet, otp)\n        self.assertEqual(result, '4ad1e9f7' * 8)\n\n        decryped = otp_decrypt_api_key(result, otp)\n        self.assertEqual(decryped, hamlet.api_key)\n\nclass LoginOrAskForRegistrationTestCase(ZulipTestCase):\n    def test_confirm(self):\n        # type: () -> None\n        request = HostRequestMock()\n        email = 'new@zulip.com'\n        user_profile = None  # type: Optional[UserProfile]\n        full_name = 'New User'\n        invalid_subdomain = False\n        result = login_or_register_remote_user(\n            request,\n            email,\n            user_profile,\n            full_name=full_name,\n            invalid_subdomain=invalid_subdomain)\n        self.assert_in_response('No account found for',\n                                result)\n        self.assert_in_response('new@zulip.com. Would you like to register instead?',\n                                result)\n\n    def test_invalid_subdomain(self):\n        # type: () -> None\n        request = HostRequestMock()\n        email = 'new@zulip.com'\n        user_profile = None  # type: Optional[UserProfile]\n        full_name = 'New User'\n        invalid_subdomain = True\n        response = login_or_register_remote_user(\n            request,\n            email,\n            user_profile,\n            full_name=full_name,\n            invalid_subdomain=invalid_subdomain)\n        self.assertEqual(response.status_code, 302)\n        self.assertIn('/accounts/login/?subdomain=1', response.url)\n\n    def test_invalid_email(self):\n        # type: () -> None\n        request = HostRequestMock()\n        email = None  # type: Optional[Text]\n        user_profile = None  # type: Optional[UserProfile]\n        full_name = 'New User'\n        invalid_subdomain = False\n        response = login_or_register_remote_user(\n            request,\n            email,\n            user_profile,\n            full_name=full_name,\n            invalid_subdomain=invalid_subdomain)\n        self.assert_in_response('Please click the following button if '\n                                'you wish to register', response)\n\n    def test_login_under_subdomains(self):\n        # type: () -> None\n        request = HostRequestMock()\n        setattr(request, 'session', self.client.session)\n        user_profile = self.example_user('hamlet')\n        user_profile.backend = 'zproject.backends.GitHubAuthBackend'\n        full_name = 'Hamlet'\n        invalid_subdomain = False\n\n        response = login_or_register_remote_user(\n            request,\n            user_profile.email,\n            user_profile,\n            full_name=full_name,\n            invalid_subdomain=invalid_subdomain)\n        user_id = get_session_dict_user(getattr(request, 'session'))\n        self.assertEqual(user_id, user_profile.id)\n        self.assertEqual(response.status_code, 302)\n        self.assertIn('http://zulip.testserver', response.url)\n", "# -*- coding: utf-8 -*-\nfrom typing import Any, List, Dict, Mapping, Optional, Text\n\nfrom django.utils.translation import ugettext as _\nfrom django.conf import settings\nfrom django.contrib.auth import authenticate, get_backends\nfrom django.core.urlresolvers import reverse\nfrom django.http import HttpResponseRedirect, HttpResponseForbidden, HttpResponse, HttpRequest\nfrom django.shortcuts import redirect, render\nfrom django.template import RequestContext, loader\nfrom django.utils.timezone import now\nfrom django.core.exceptions import ValidationError\nfrom django.core import validators\nfrom zerver.context_processors import get_realm_from_request\nfrom zerver.models import UserProfile, Realm, Stream, PreregistrationUser, MultiuseInvite, \\\n    name_changes_disabled, email_to_username, email_allowed_for_realm, \\\n    get_realm, get_user_profile_by_email\nfrom zerver.lib.send_email import send_email, FromAddress\nfrom zerver.lib.events import do_events_register\nfrom zerver.lib.actions import do_change_password, do_change_full_name, do_change_is_admin, \\\n    do_activate_user, do_create_user, do_create_realm, \\\n    user_email_is_unique, compute_mit_user_fullname, validate_email_for_realm, \\\n    do_set_user_display_setting\nfrom zerver.forms import RegistrationForm, HomepageForm, RealmCreationForm, \\\n    CreateUserForm, FindMyTeamForm\nfrom django_auth_ldap.backend import LDAPBackend, _LDAPUser\nfrom zerver.decorator import require_post, has_request_variables, \\\n    JsonableError, REQ, do_login\nfrom zerver.lib.onboarding import send_initial_pms, setup_initial_streams, \\\n    setup_initial_private_stream, send_initial_realm_messages\nfrom zerver.lib.response import json_success\nfrom zerver.lib.subdomains import get_subdomain, is_root_domain_available\nfrom zerver.lib.timezone import get_all_timezones\nfrom zproject.backends import ldap_auth_enabled, password_auth_enabled, ZulipLDAPAuthBackend\n\nfrom confirmation.models import Confirmation, RealmCreationKey, ConfirmationKeyException, \\\n    check_key_is_valid, create_confirmation_link, get_object_from_key, \\\n    render_confirmation_key_error\n\nimport logging\nimport requests\nimport smtplib\nimport ujson\n\nfrom six.moves import urllib\n\ndef redirect_and_log_into_subdomain(realm, full_name, email_address,\n                                    is_signup=False):\n    # type: (Realm, Text, Text, bool) -> HttpResponse\n    subdomain_login_uri = ''.join([\n        realm.uri,\n        reverse('zerver.views.auth.log_into_subdomain')\n    ])\n\n    domain = settings.EXTERNAL_HOST.split(':')[0]\n    response = redirect(subdomain_login_uri)\n\n    data = {'name': full_name, 'email': email_address, 'subdomain': realm.subdomain,\n            'is_signup': is_signup}\n    # Creating a singed cookie so that it cannot be tampered with.\n    # Cookie and the signature expire in 15 seconds.\n    response.set_signed_cookie('subdomain.signature',\n                               ujson.dumps(data),\n                               expires=15,\n                               domain=domain,\n                               salt='zerver.views.auth')\n    return response\n\n@require_post\ndef accounts_register(request):\n    # type: (HttpRequest) -> HttpResponse\n    key = request.POST['key']\n    confirmation = Confirmation.objects.get(confirmation_key=key)\n    prereg_user = confirmation.content_object\n    email = prereg_user.email\n    realm_creation = prereg_user.realm_creation\n    password_required = prereg_user.password_required\n\n    validators.validate_email(email)\n    if realm_creation:\n        # For creating a new realm, there is no existing realm or domain\n        realm = None\n    else:\n        realm = get_realm(get_subdomain(request))\n        if prereg_user.realm is not None and prereg_user.realm != realm:\n            return render(request, 'confirmation/link_does_not_exist.html')\n\n    if realm and not email_allowed_for_realm(email, realm):\n        return render(request, \"zerver/closed_realm.html\",\n                      context={\"closed_domain_name\": realm.name})\n\n    if realm and realm.deactivated:\n        # The user is trying to register for a deactivated realm. Advise them to\n        # contact support.\n        return redirect_to_deactivation_notice()\n\n    try:\n        validate_email_for_realm(realm, email)\n    except ValidationError:\n        return HttpResponseRedirect(reverse('django.contrib.auth.views.login') + '?email=' +\n                                    urllib.parse.quote_plus(email))\n\n    name_validated = False\n    full_name = None\n\n    if request.POST.get('from_confirmation'):\n        try:\n            del request.session['authenticated_full_name']\n        except KeyError:\n            pass\n        if realm is not None and realm.is_zephyr_mirror_realm:\n            # For MIT users, we can get an authoritative name from Hesiod.\n            # Technically we should check that this is actually an MIT\n            # realm, but we can cross that bridge if we ever get a non-MIT\n            # zephyr mirroring realm.\n            hesiod_name = compute_mit_user_fullname(email)\n            form = RegistrationForm(\n                initial={'full_name': hesiod_name if \"@\" not in hesiod_name else \"\"},\n                realm_creation=realm_creation)\n            name_validated = True\n        elif settings.POPULATE_PROFILE_VIA_LDAP:\n            for backend in get_backends():\n                if isinstance(backend, LDAPBackend):\n                    ldap_attrs = _LDAPUser(backend, backend.django_to_ldap_username(email)).attrs\n                    try:\n                        ldap_full_name = ldap_attrs[settings.AUTH_LDAP_USER_ATTR_MAP['full_name']][0]\n                        request.session['authenticated_full_name'] = ldap_full_name\n                        name_validated = True\n                        # We don't use initial= here, because if the form is\n                        # complete (that is, no additional fields need to be\n                        # filled out by the user) we want the form to validate,\n                        # so they can be directly registered without having to\n                        # go through this interstitial.\n                        form = RegistrationForm({'full_name': ldap_full_name},\n                                                realm_creation=realm_creation)\n                        # FIXME: This will result in the user getting\n                        # validation errors if they have to enter a password.\n                        # Not relevant for ONLY_SSO, though.\n                        break\n                    except TypeError:\n                        # Let the user fill out a name and/or try another backend\n                        form = RegistrationForm(realm_creation=realm_creation)\n        elif 'full_name' in request.POST:\n            form = RegistrationForm(\n                initial={'full_name': request.POST.get('full_name')},\n                realm_creation=realm_creation\n            )\n        else:\n            form = RegistrationForm(realm_creation=realm_creation)\n    else:\n        postdata = request.POST.copy()\n        if name_changes_disabled(realm):\n            # If we populate profile information via LDAP and we have a\n            # verified name from you on file, use that. Otherwise, fall\n            # back to the full name in the request.\n            try:\n                postdata.update({'full_name': request.session['authenticated_full_name']})\n                name_validated = True\n            except KeyError:\n                pass\n        form = RegistrationForm(postdata, realm_creation=realm_creation)\n        if not (password_auth_enabled(realm) and password_required):\n            form['password'].field.required = False\n\n    if form.is_valid():\n        if password_auth_enabled(realm):\n            password = form.cleaned_data['password']\n        else:\n            # SSO users don't need no passwords\n            password = None\n\n        if realm_creation:\n            string_id = form.cleaned_data['realm_subdomain']\n            realm_name = form.cleaned_data['realm_name']\n            realm = do_create_realm(string_id, realm_name)\n            setup_initial_streams(realm)\n        assert(realm is not None)\n\n        full_name = form.cleaned_data['full_name']\n        short_name = email_to_username(email)\n\n        timezone = u\"\"\n        if 'timezone' in request.POST and request.POST['timezone'] in get_all_timezones():\n            timezone = request.POST['timezone']\n\n        try:\n            existing_user_profile = get_user_profile_by_email(email)\n        except UserProfile.DoesNotExist:\n            existing_user_profile = None\n\n        return_data = {}  # type: Dict[str, bool]\n        if ldap_auth_enabled(realm):\n            # If the user was authenticated using an external SSO\n            # mechanism like Google or GitHub auth, then authentication\n            # will have already been done before creating the\n            # PreregistrationUser object with password_required=False, and\n            # so we don't need to worry about passwords.\n            #\n            # If instead the realm is using EmailAuthBackend, we will\n            # set their password above.\n            #\n            # But if the realm is using LDAPAuthBackend, we need to verify\n            # their LDAP password (which will, as a side effect, create\n            # the user account) here using authenticate.\n            auth_result = authenticate(request,\n                                       username=email,\n                                       password=password,\n                                       realm_subdomain=realm.subdomain,\n                                       return_data=return_data)\n            if auth_result is None:\n                # TODO: This probably isn't going to give a\n                # user-friendly error message, but it doesn't\n                # particularly matter, because the registration form\n                # is hidden for most users.\n                return HttpResponseRedirect(reverse('django.contrib.auth.views.login') + '?email=' +\n                                            urllib.parse.quote_plus(email))\n\n            # Since we'll have created a user, we now just log them in.\n            return login_and_go_to_home(request, auth_result)\n        elif existing_user_profile is not None and existing_user_profile.is_mirror_dummy:\n            user_profile = existing_user_profile\n            do_activate_user(user_profile)\n            do_change_password(user_profile, password)\n            do_change_full_name(user_profile, full_name, user_profile)\n            do_set_user_display_setting(user_profile, 'timezone', timezone)\n        else:\n            user_profile = do_create_user(email, password, realm, full_name, short_name,\n                                          prereg_user=prereg_user, is_realm_admin=realm_creation,\n                                          tos_version=settings.TOS_VERSION,\n                                          timezone=timezone,\n                                          newsletter_data={\"IP\": request.META['REMOTE_ADDR']})\n\n        # Note: Any logic like this must also be replicated in\n        # ZulipLDAPAuthBackend and zerver/views/users.py.  This is\n        # ripe for a refactoring, though care is required to avoid\n        # import loops with zerver/lib/actions.py and zerver/lib/onboarding.py.\n        send_initial_pms(user_profile)\n\n        if realm_creation:\n            setup_initial_private_stream(user_profile)\n            send_initial_realm_messages(realm)\n\n        if realm_creation:\n            # Because for realm creation, registration happens on the\n            # root domain, we need to log them into the subdomain for\n            # their new realm.\n            return redirect_and_log_into_subdomain(realm, full_name, email)\n\n        # This dummy_backend check below confirms the user is\n        # authenticating to the correct subdomain.\n        auth_result = authenticate(username=user_profile.email,\n                                   realm_subdomain=realm.subdomain,\n                                   return_data=return_data,\n                                   use_dummy_backend=True)\n        if return_data.get('invalid_subdomain'):\n            # By construction, this should never happen.\n            logging.error(\"Subdomain mismatch in registration %s: %s\" % (\n                realm.subdomain, user_profile.email,))\n            return redirect('/')\n\n        return login_and_go_to_home(request, auth_result)\n\n    return render(\n        request,\n        'zerver/register.html',\n        context={'form': form,\n                 'email': email,\n                 'key': key,\n                 'full_name': request.session.get('authenticated_full_name', None),\n                 'lock_name': name_validated and name_changes_disabled(realm),\n                 # password_auth_enabled is normally set via our context processor,\n                 # but for the registration form, there is no logged in user yet, so\n                 # we have to set it here.\n                 'creating_new_team': realm_creation,\n                 'password_required': password_auth_enabled(realm) and password_required,\n                 'password_auth_enabled': password_auth_enabled(realm),\n                 'root_domain_available': is_root_domain_available(),\n                 'MAX_REALM_NAME_LENGTH': str(Realm.MAX_REALM_NAME_LENGTH),\n                 'MAX_NAME_LENGTH': str(UserProfile.MAX_NAME_LENGTH),\n                 'MAX_PASSWORD_LENGTH': str(form.MAX_PASSWORD_LENGTH),\n                 'MAX_REALM_SUBDOMAIN_LENGTH': str(Realm.MAX_REALM_SUBDOMAIN_LENGTH)\n                 }\n    )\n\ndef login_and_go_to_home(request, user_profile):\n    # type: (HttpRequest, UserProfile) -> HttpResponse\n\n    # Mark the user as having been just created, so no \"new login\" email is sent\n    user_profile.just_registered = True\n    do_login(request, user_profile)\n    return HttpResponseRedirect(user_profile.realm.uri + reverse('zerver.views.home.home'))\n\ndef create_preregistration_user(email, request, realm_creation=False,\n                                password_required=True):\n    # type: (Text, HttpRequest, bool, bool) -> HttpResponse\n    realm = None\n    if not realm_creation:\n        realm = get_realm(get_subdomain(request))\n    return PreregistrationUser.objects.create(email=email,\n                                              realm_creation=realm_creation,\n                                              password_required=password_required,\n                                              realm=realm)\n\ndef send_registration_completion_email(email, request, realm_creation=False, streams=None):\n    # type: (str, HttpRequest, bool, Optional[List[Stream]]) -> None\n    \"\"\"\n    Send an email with a confirmation link to the provided e-mail so the user\n    can complete their registration.\n    \"\"\"\n    prereg_user = create_preregistration_user(email, request, realm_creation)\n\n    if streams is not None:\n        prereg_user.streams = streams\n        prereg_user.save()\n\n    activation_url = create_confirmation_link(prereg_user, request.get_host(), Confirmation.USER_REGISTRATION)\n    send_email('zerver/emails/confirm_registration', to_email=email, from_address=FromAddress.NOREPLY,\n               context={'activate_url': activation_url})\n    if settings.DEVELOPMENT and realm_creation:\n        request.session['confirmation_key'] = {'confirmation_key': activation_url.split('/')[-1]}\n\ndef redirect_to_email_login_url(email):\n    # type: (str) -> HttpResponseRedirect\n    login_url = reverse('django.contrib.auth.views.login')\n    email = urllib.parse.quote_plus(email)\n    redirect_url = login_url + '?already_registered=' + email\n    return HttpResponseRedirect(redirect_url)\n\ndef create_realm(request, creation_key=None):\n    # type: (HttpRequest, Optional[Text]) -> HttpResponse\n    if not settings.OPEN_REALM_CREATION:\n        if creation_key is None:\n            return render(request, \"zerver/realm_creation_failed.html\",\n                          context={'message': _('New organization creation disabled.')})\n        elif not check_key_is_valid(creation_key):\n            return render(request, \"zerver/realm_creation_failed.html\",\n                          context={'message': _('The organization creation link has expired'\n                                                ' or is not valid.')})\n\n    # When settings.OPEN_REALM_CREATION is enabled, anyone can create a new realm,\n    # subject to a few restrictions on their email address.\n    if request.method == 'POST':\n        form = RealmCreationForm(request.POST)\n        if form.is_valid():\n            email = form.cleaned_data['email']\n            try:\n                send_registration_completion_email(email, request, realm_creation=True)\n            except smtplib.SMTPException as e:\n                logging.error('Error in create_realm: %s' % (str(e),))\n                return HttpResponseRedirect(\"/config-error/smtp\")\n\n            if (creation_key is not None and check_key_is_valid(creation_key)):\n                RealmCreationKey.objects.get(creation_key=creation_key).delete()\n            return HttpResponseRedirect(reverse('send_confirm', kwargs={'email': email}))\n        try:\n            email = request.POST['email']\n            user_email_is_unique(email)\n        except ValidationError:\n            # Maybe the user is trying to log in\n            return redirect_to_email_login_url(email)\n    else:\n        form = RealmCreationForm()\n    return render(request,\n                  'zerver/create_realm.html',\n                  context={'form': form, 'current_url': request.get_full_path},\n                  )\n\ndef confirmation_key(request):\n    # type: (HttpRequest) -> HttpResponse\n    return json_success(request.session.get('confirmation_key'))\n\n\ndef show_deactivation_notice(request):\n    # type: (HttpRequest) -> HttpResponse\n    realm = get_realm_from_request(request)\n    if realm and realm.deactivated:\n        return render(request, \"zerver/deactivated.html\",\n                      context={\"deactivated_domain_name\": realm.name})\n\n    return HttpResponseRedirect(reverse('zerver.views.auth.login_page'))\n\ndef redirect_to_deactivation_notice():\n    # type: () -> HttpResponse\n    return HttpResponseRedirect(reverse('zerver.views.registration.show_deactivation_notice'))\n\ndef accounts_home(request, multiuse_object=None):\n    # type: (HttpRequest, Optional[MultiuseInvite]) -> HttpResponse\n    realm = get_realm(get_subdomain(request))\n    if realm and realm.deactivated:\n        return redirect_to_deactivation_notice()\n\n    from_multiuse_invite = False\n    streams_to_subscribe = None\n\n    if multiuse_object:\n        realm = multiuse_object.realm\n        streams_to_subscribe = multiuse_object.streams.all()\n        from_multiuse_invite = True\n\n    if request.method == 'POST':\n        form = HomepageForm(request.POST, realm=realm, from_multiuse_invite=from_multiuse_invite)\n        if form.is_valid():\n            email = form.cleaned_data['email']\n            try:\n                send_registration_completion_email(email, request, streams=streams_to_subscribe)\n            except smtplib.SMTPException as e:\n                logging.error('Error in accounts_home: %s' % (str(e),))\n                return HttpResponseRedirect(\"/config-error/smtp\")\n\n            return HttpResponseRedirect(reverse('send_confirm', kwargs={'email': email}))\n\n        email = request.POST['email']\n        try:\n            validate_email_for_realm(realm, email)\n        except ValidationError:\n            return redirect_to_email_login_url(email)\n    else:\n        form = HomepageForm(realm=realm)\n    return render(request,\n                  'zerver/accounts_home.html',\n                  context={'form': form, 'current_url': request.get_full_path,\n                           'from_multiuse_invite': from_multiuse_invite},\n                  )\n\ndef accounts_home_from_multiuse_invite(request, confirmation_key):\n    # type: (HttpRequest, str) -> HttpResponse\n    multiuse_object = None\n    try:\n        multiuse_object = get_object_from_key(confirmation_key)\n        # Required for oAuth2\n        request.session[\"multiuse_object_key\"] = confirmation_key\n    except ConfirmationKeyException as exception:\n        realm = get_realm_from_request(request)\n        if realm is None or realm.invite_required:\n            return render_confirmation_key_error(request, exception)\n    return accounts_home(request, multiuse_object=multiuse_object)\n\ndef generate_204(request):\n    # type: (HttpRequest) -> HttpResponse\n    return HttpResponse(content=None, status=204)\n\ndef find_account(request):\n    # type: (HttpRequest) -> HttpResponse\n    url = reverse('zerver.views.registration.find_account')\n\n    emails = []  # type: List[Text]\n    if request.method == 'POST':\n        form = FindMyTeamForm(request.POST)\n        if form.is_valid():\n            emails = form.cleaned_data['emails']\n            for user_profile in UserProfile.objects.filter(\n                    email__in=emails, is_active=True, is_bot=False, realm__deactivated=False):\n                send_email('zerver/emails/find_team', to_user_id=user_profile.id,\n                           context={'user_profile': user_profile})\n\n            # Note: Show all the emails in the result otherwise this\n            # feature can be used to ascertain which email addresses\n            # are associated with Zulip.\n            data = urllib.parse.urlencode({'emails': ','.join(emails)})\n            return redirect(url + \"?\" + data)\n    else:\n        form = FindMyTeamForm()\n        result = request.GET.get('emails')\n        # The below validation is perhaps unnecessary, in that we\n        # shouldn't get able to get here with an invalid email unless\n        # the user hand-edits the URLs.\n        if result:\n            for email in result.split(','):\n                try:\n                    validators.validate_email(email)\n                    emails.append(email)\n                except ValidationError:\n                    pass\n\n    return render(request,\n                  'zerver/find_account.html',\n                  context={'form': form, 'current_url': lambda: url,\n                           'emails': emails},)\n"], "fixing_code": ["{% extends \"zerver/portico.html\" %}\n\n{% block portico_content %}\n\n<div class=\"pitch\">\n    <hr/>\n    <p class=\"lead\">Whoops. The confirmation link has expired or been deactivated.</p>\n\n    <p>\n        Please contact your organization administrator for a new one.\n    </p>\n\n</div>\n\n{% endblock %}\n", "# -*- coding: utf-8 -*-\nfrom django.conf import settings\nfrom django.core import mail\nfrom django.http import HttpResponse\nfrom django.test import override_settings\nfrom django_auth_ldap.backend import _LDAPUser\nfrom django.contrib.auth import authenticate\nfrom django.test.client import RequestFactory\nfrom typing import Any, Callable, Dict, List, Optional, Text\nfrom builtins import object\nfrom oauth2client.crypt import AppIdentityError\nfrom django.core import signing\nfrom django.core.urlresolvers import reverse\n\nimport jwt\nimport mock\nimport re\n\nfrom zerver.forms import HomepageForm\nfrom zerver.lib.actions import (\n    do_deactivate_realm,\n    do_deactivate_user,\n    do_reactivate_realm,\n    do_reactivate_user,\n    do_set_realm_authentication_methods,\n    create_stream_if_needed,\n)\nfrom zerver.lib.mobile_auth_otp import otp_decrypt_api_key\nfrom zerver.lib.validator import validate_login_email, \\\n    check_bool, check_dict_only, check_string\nfrom zerver.lib.request import JsonableError\nfrom zerver.lib.initial_password import initial_password\nfrom zerver.lib.sessions import get_session_dict_user\nfrom zerver.lib.test_classes import (\n    ZulipTestCase,\n)\nfrom zerver.lib.test_helpers import POSTRequestMock\nfrom zerver.models import \\\n    get_realm, email_to_username, UserProfile, \\\n    PreregistrationUser, Realm, get_user, MultiuseInvite\n\nfrom confirmation.models import Confirmation, confirmation_url, create_confirmation_link\n\nfrom zproject.backends import ZulipDummyBackend, EmailAuthBackend, \\\n    GoogleMobileOauth2Backend, ZulipRemoteUserBackend, ZulipLDAPAuthBackend, \\\n    ZulipLDAPUserPopulator, DevAuthBackend, GitHubAuthBackend, ZulipAuthMixin, \\\n    dev_auth_enabled, password_auth_enabled, github_auth_enabled, \\\n    require_email_format_usernames, SocialAuthMixin, AUTH_BACKEND_NAME_MAP, \\\n    ZulipLDAPConfigurationError\n\nfrom zerver.views.auth import (maybe_send_to_registration,\n                               login_or_register_remote_user)\nfrom version import ZULIP_VERSION\n\nfrom social_core.exceptions import AuthFailed, AuthStateForbidden\nfrom social_django.strategy import DjangoStrategy\nfrom social_django.storage import BaseDjangoStorage\nfrom social_core.backends.github import GithubOrganizationOAuth2, GithubTeamOAuth2, \\\n    GithubOAuth2\n\nfrom six.moves import urllib\nfrom six.moves.http_cookies import SimpleCookie\nimport ujson\nfrom zerver.lib.test_helpers import MockLDAP, unsign_subdomain_cookie\n\nclass AuthBackendTest(ZulipTestCase):\n    def get_username(self, email_to_username=None):\n        # type: (Optional[Callable[[Text], Text]]) -> Text\n        username = self.example_email('hamlet')\n        if email_to_username is not None:\n            username = email_to_username(self.example_email('hamlet'))\n\n        return username\n\n    def verify_backend(self, backend, good_kwargs=None, bad_kwargs=None):\n        # type: (Any, Optional[Dict[str, Any]], Optional[Dict[str, Any]]) -> None\n\n        user_profile = self.example_user('hamlet')\n\n        assert good_kwargs is not None\n\n        # If bad_kwargs was specified, verify auth fails in that case\n        if bad_kwargs is not None:\n            self.assertIsNone(backend.authenticate(**bad_kwargs))\n\n        # Verify auth works\n        result = backend.authenticate(**good_kwargs)\n        self.assertEqual(user_profile, result)\n\n        # Verify auth fails with a deactivated user\n        do_deactivate_user(user_profile)\n        self.assertIsNone(backend.authenticate(**good_kwargs))\n\n        # Reactivate the user and verify auth works again\n        do_reactivate_user(user_profile)\n        result = backend.authenticate(**good_kwargs)\n        self.assertEqual(user_profile, result)\n\n        # Verify auth fails with a deactivated realm\n        do_deactivate_realm(user_profile.realm)\n        self.assertIsNone(backend.authenticate(**good_kwargs))\n\n        # Verify auth works again after reactivating the realm\n        do_reactivate_realm(user_profile.realm)\n        result = backend.authenticate(**good_kwargs)\n        self.assertEqual(user_profile, result)\n\n        # ZulipDummyBackend isn't a real backend so the remainder\n        # doesn't make sense for it\n        if isinstance(backend, ZulipDummyBackend):\n            return\n\n        # Verify auth fails if the auth backend is disabled on server\n        with self.settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipDummyBackend',)):\n            self.assertIsNone(backend.authenticate(**good_kwargs))\n\n        # Verify auth fails if the auth backend is disabled for the realm\n        for backend_name in AUTH_BACKEND_NAME_MAP.keys():\n            if isinstance(backend, AUTH_BACKEND_NAME_MAP[backend_name]):\n                break\n\n        index = getattr(user_profile.realm.authentication_methods, backend_name).number\n        user_profile.realm.authentication_methods.set_bit(index, False)\n        user_profile.realm.save()\n        self.assertIsNone(backend.authenticate(**good_kwargs))\n        user_profile.realm.authentication_methods.set_bit(index, True)\n        user_profile.realm.save()\n\n    def test_dummy_backend(self):\n        # type: () -> None\n        username = self.get_username()\n        self.verify_backend(ZulipDummyBackend(),\n                            good_kwargs=dict(username=username,\n                                             use_dummy_backend=True),\n                            bad_kwargs=dict(username=username,\n                                            use_dummy_backend=False))\n\n    def setup_subdomain(self, user_profile):\n        # type: (UserProfile) -> None\n        realm = user_profile.realm\n        realm.string_id = 'zulip'\n        realm.save()\n\n    def test_email_auth_backend(self):\n        # type: () -> None\n        username = self.get_username()\n        user_profile = self.example_user('hamlet')\n        password = \"testpassword\"\n        user_profile.set_password(password)\n        user_profile.save()\n\n        with mock.patch('zproject.backends.email_auth_enabled',\n                        return_value=False), \\\n                mock.patch('zproject.backends.password_auth_enabled',\n                           return_value=True):\n            return_data = {}  # type: Dict[str, bool]\n            user = EmailAuthBackend().authenticate(self.example_email('hamlet'),\n                                                   password=password,\n                                                   return_data=return_data)\n            self.assertEqual(user, None)\n            self.assertTrue(return_data['email_auth_disabled'])\n\n        self.verify_backend(EmailAuthBackend(),\n                            good_kwargs=dict(password=password,\n                                             username=username,\n                                             realm_subdomain='zulip',\n                                             return_data=dict()),\n                            bad_kwargs=dict(password=password,\n                                            username=username,\n                                            realm_subdomain='acme',\n                                            return_data=dict()))\n\n    def test_email_auth_backend_disabled_password_auth(self):\n        # type: () -> None\n        user_profile = self.example_user('hamlet')\n        password = \"testpassword\"\n        user_profile.set_password(password)\n        user_profile.save()\n        # Verify if a realm has password auth disabled, correct password is rejected\n        with mock.patch('zproject.backends.password_auth_enabled', return_value=False):\n            self.assertIsNone(EmailAuthBackend().authenticate(self.example_email('hamlet'), password))\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipDummyBackend',))\n    def test_no_backend_enabled(self):\n        # type: () -> None\n        result = self.client_get('/login/')\n        self.assert_in_success_response([\"No authentication backends are enabled\"], result)\n\n        result = self.client_get('/register/')\n        self.assert_in_success_response([\"No authentication backends are enabled\"], result)\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.GoogleMobileOauth2Backend',))\n    def test_any_backend_enabled(self):\n        # type: () -> None\n\n        # testing to avoid false error messages.\n        result = self.client_get('/login/')\n        self.assert_not_in_success_response([\"No Authentication Backend is enabled.\"], result)\n\n        result = self.client_get('/register/')\n        self.assert_not_in_success_response([\"No Authentication Backend is enabled.\"], result)\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.GoogleMobileOauth2Backend',))\n    def test_google_backend(self):\n        # type: () -> None\n        user_profile = self.example_user('hamlet')\n        email = user_profile.email\n        backend = GoogleMobileOauth2Backend()\n        payload = dict(email_verified=True,\n                       email=email)\n\n        with mock.patch('apiclient.sample_tools.client.verify_id_token', return_value=payload):\n            self.verify_backend(backend,\n                                good_kwargs=dict(realm_subdomain=\"zulip\"),\n                                bad_kwargs=dict(realm_subdomain='acme'))\n\n        # Verify valid_attestation parameter is set correctly\n        unverified_payload = dict(email_verified=False)\n        with mock.patch('apiclient.sample_tools.client.verify_id_token', return_value=unverified_payload):\n            ret = dict()  # type: Dict[str, str]\n            result = backend.authenticate(return_data=ret)\n            self.assertIsNone(result)\n            self.assertFalse(ret[\"valid_attestation\"])\n\n        nonexistent_user_payload = dict(email_verified=True, email=\"invalid@zulip.com\")\n        with mock.patch('apiclient.sample_tools.client.verify_id_token',\n                        return_value=nonexistent_user_payload):\n            ret = dict()\n            result = backend.authenticate(return_data=ret)\n            self.assertIsNone(result)\n            self.assertTrue(ret[\"valid_attestation\"])\n        with mock.patch('apiclient.sample_tools.client.verify_id_token',\n                        side_effect=AppIdentityError):\n            ret = dict()\n            result = backend.authenticate(return_data=ret)\n            self.assertIsNone(result)\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',))\n    def test_ldap_backend(self):\n        # type: () -> None\n        user_profile = self.example_user('hamlet')\n        email = user_profile.email\n        password = \"test_password\"\n        self.setup_subdomain(user_profile)\n\n        username = self.get_username()\n        backend = ZulipLDAPAuthBackend()\n\n        # Test LDAP auth fails when LDAP server rejects password\n        with mock.patch('django_auth_ldap.backend._LDAPUser._authenticate_user_dn',\n                        side_effect=_LDAPUser.AuthenticationFailed(\"Failed\")), (\n            mock.patch('django_auth_ldap.backend._LDAPUser._check_requirements')), (\n            mock.patch('django_auth_ldap.backend._LDAPUser._get_user_attrs',\n                       return_value=dict(full_name=['Hamlet']))):\n            self.assertIsNone(backend.authenticate(email, password))\n\n        with mock.patch('django_auth_ldap.backend._LDAPUser._authenticate_user_dn'), (\n            mock.patch('django_auth_ldap.backend._LDAPUser._check_requirements')), (\n            mock.patch('django_auth_ldap.backend._LDAPUser._get_user_attrs',\n                       return_value=dict(full_name=['Hamlet']))):\n            self.verify_backend(backend,\n                                bad_kwargs=dict(username=username,\n                                                password=password,\n                                                realm_subdomain='acme'),\n                                good_kwargs=dict(username=username,\n                                                 password=password,\n                                                 realm_subdomain='zulip'))\n\n    def test_devauth_backend(self):\n        # type: () -> None\n        self.verify_backend(DevAuthBackend(),\n                            good_kwargs=dict(username=self.get_username()))\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipRemoteUserBackend',))\n    def test_remote_user_backend(self):\n        # type: () -> None\n        username = self.get_username()\n        self.verify_backend(ZulipRemoteUserBackend(),\n                            good_kwargs=dict(remote_user=username,\n                                             realm_subdomain='zulip'),\n                            bad_kwargs=dict(remote_user=username,\n                                            realm_subdomain='acme'))\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipRemoteUserBackend',))\n    @override_settings(SSO_APPEND_DOMAIN='zulip.com')\n    def test_remote_user_backend_sso_append_domain(self):\n        # type: () -> None\n        username = self.get_username(email_to_username)\n        self.verify_backend(ZulipRemoteUserBackend(),\n                            good_kwargs=dict(remote_user=username,\n                                             realm_subdomain='zulip'),\n                            bad_kwargs=dict(remote_user=username,\n                                            realm_subdomain='acme'))\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.GitHubAuthBackend',))\n    def test_github_backend(self):\n        # type: () -> None\n        user = self.example_user('hamlet')\n        email = user.email\n        good_kwargs = dict(response=dict(email=email), return_data=dict(),\n                           realm_subdomain='zulip')\n        bad_kwargs = dict(response=dict(email=email), return_data=dict(),\n                          realm_subdomain='acme')\n        self.verify_backend(GitHubAuthBackend(),\n                            good_kwargs=good_kwargs,\n                            bad_kwargs=bad_kwargs)\n\nclass SocialAuthMixinTest(ZulipTestCase):\n    def test_social_auth_mixing(self):\n        # type: () -> None\n        mixin = SocialAuthMixin()\n        with self.assertRaises(NotImplementedError):\n            mixin.get_email_address()\n        with self.assertRaises(NotImplementedError):\n            mixin.get_full_name()\n\nclass GitHubAuthBackendTest(ZulipTestCase):\n    def setUp(self):\n        # type: () -> None\n        self.user_profile = self.example_user('hamlet')\n        self.email = self.user_profile.email\n        self.name = 'Hamlet'\n        self.backend = GitHubAuthBackend()\n        self.backend.strategy = DjangoStrategy(storage=BaseDjangoStorage())\n        self.user_profile.backend = self.backend\n\n        rf = RequestFactory()\n        request = rf.get('/complete')\n        request.session = {}\n        request.get_host = lambda: 'zulip.testserver'\n        request.user = self.user_profile\n        self.backend.strategy.request = request\n\n    def do_auth(self, *args, **kwargs):\n        # type: (*Any, **Any) -> UserProfile\n        with self.settings(AUTHENTICATION_BACKENDS=('zproject.backends.GitHubAuthBackend',)):\n            return authenticate(**kwargs)\n\n    def test_github_auth_enabled(self):\n        # type: () -> None\n        with self.settings(AUTHENTICATION_BACKENDS=('zproject.backends.GitHubAuthBackend',)):\n            self.assertTrue(github_auth_enabled())\n\n    def test_full_name_with_missing_key(self):\n        # type: () -> None\n        self.assertEqual(self.backend.get_full_name(), '')\n        self.assertEqual(self.backend.get_full_name(response={'name': None}), '')\n\n    def test_full_name_with_none(self):\n        # type: () -> None\n        self.assertEqual(self.backend.get_full_name(response={'email': None}), '')\n\n    def test_github_backend_do_auth_with_non_existing_subdomain(self):\n        # type: () -> None\n        with mock.patch('social_core.backends.github.GithubOAuth2.do_auth',\n                        side_effect=self.do_auth):\n            self.backend.strategy.session_set('subdomain', 'test')\n            response = dict(email=self.email, name=self.name)\n            result = self.backend.do_auth(response=response)\n            assert(result is not None)\n            self.assertIn('subdomain=1', result.url)\n\n    def test_github_backend_do_auth_with_subdomains(self):\n        # type: () -> None\n        with mock.patch('social_core.backends.github.GithubOAuth2.do_auth',\n                        side_effect=self.do_auth):\n            self.backend.strategy.session_set('subdomain', 'zulip')\n            response = dict(email=self.email, name=self.name)\n            result = self.backend.do_auth(response=response)\n            assert(result is not None)\n            self.assertEqual('http://zulip.testserver/accounts/login/subdomain/', result.url)\n\n    def test_github_backend_do_auth_for_default(self):\n        # type: () -> None\n        with mock.patch('social_core.backends.github.GithubOAuth2.do_auth',\n                        side_effect=self.do_auth), \\\n                mock.patch('zproject.backends.SocialAuthMixin.process_do_auth') as result:\n            response = dict(email=self.email, name=self.name)\n            self.backend.do_auth('fake-access-token', response=response)\n\n            kwargs = {'realm_subdomain': 'zulip',\n                      'response': response,\n                      'return_data': {}}\n            result.assert_called_with(self.user_profile, 'fake-access-token', **kwargs)\n\n    def test_github_backend_do_auth_for_default_auth_failed(self):\n        # type: () -> None\n        with mock.patch('social_core.backends.github.GithubOAuth2.do_auth',\n                        side_effect=AuthFailed('Not found')), \\\n                mock.patch('logging.info'), \\\n                mock.patch('zproject.backends.SocialAuthMixin.process_do_auth') as result:\n            response = dict(email=self.email, name=self.name)\n\n            self.backend.do_auth('fake-access-token', response=response)\n            kwargs = {'realm_subdomain': 'zulip',\n                      'response': response,\n                      'return_data': {}}\n            result.assert_called_with(None, 'fake-access-token', **kwargs)\n\n    def test_github_backend_do_auth_for_team(self):\n        # type: () -> None\n        with mock.patch('social_core.backends.github.GithubTeamOAuth2.do_auth',\n                        side_effect=self.do_auth), \\\n                mock.patch('zproject.backends.SocialAuthMixin.process_do_auth') as result:\n            self.backend.strategy.session_set('subdomain', 'zulip')\n            response = dict(email=self.email, name=self.name)\n            with self.settings(SOCIAL_AUTH_GITHUB_TEAM_ID='zulip-webapp'):\n                self.backend.do_auth('fake-access-token', response=response)\n\n                kwargs = {'realm_subdomain': 'zulip',\n                          'response': response,\n                          'return_data': {}}\n                result.assert_called_with(self.user_profile, 'fake-access-token', **kwargs)\n\n    def test_github_backend_do_auth_for_team_auth_failed(self):\n        # type: () -> None\n        with mock.patch('social_core.backends.github.GithubTeamOAuth2.do_auth',\n                        side_effect=AuthFailed('Not found')), \\\n                mock.patch('logging.info'), \\\n                mock.patch('zproject.backends.SocialAuthMixin.process_do_auth') as result:\n            self.backend.strategy.session_set('subdomain', 'zulip')\n            response = dict(email=self.email, name=self.name)\n            with self.settings(SOCIAL_AUTH_GITHUB_TEAM_ID='zulip-webapp'):\n                self.backend.do_auth('fake-access-token', response=response)\n                kwargs = {'realm_subdomain': 'zulip',\n                          'response': response,\n                          'return_data': {}}\n                result.assert_called_with(None, 'fake-access-token', **kwargs)\n\n    def test_github_backend_do_auth_for_org(self):\n        # type: () -> None\n        with mock.patch('social_core.backends.github.GithubOrganizationOAuth2.do_auth',\n                        side_effect=self.do_auth), \\\n                mock.patch('zproject.backends.SocialAuthMixin.process_do_auth') as result:\n            self.backend.strategy.session_set('subdomain', 'zulip')\n            response = dict(email=self.email, name=self.name)\n            with self.settings(SOCIAL_AUTH_GITHUB_ORG_NAME='Zulip'):\n                self.backend.do_auth('fake-access-token', response=response)\n\n                kwargs = {'realm_subdomain': 'zulip',\n                          'response': response,\n                          'return_data': {}}\n                result.assert_called_with(self.user_profile, 'fake-access-token', **kwargs)\n\n    def test_github_backend_do_auth_for_org_auth_failed(self):\n        # type: () -> None\n        with mock.patch('social_core.backends.github.GithubOrganizationOAuth2.do_auth',\n                        side_effect=AuthFailed('Not found')), \\\n                mock.patch('logging.info'), \\\n                mock.patch('zproject.backends.SocialAuthMixin.process_do_auth') as result:\n            self.backend.strategy.session_set('subdomain', 'zulip')\n            response = dict(email=self.email, name=self.name)\n            with self.settings(SOCIAL_AUTH_GITHUB_ORG_NAME='Zulip'):\n                self.backend.do_auth('fake-access-token', response=response)\n                kwargs = {'realm_subdomain': 'zulip',\n                          'response': response,\n                          'return_data': {}}\n                result.assert_called_with(None, 'fake-access-token', **kwargs)\n\n    def test_github_backend_authenticate_nonexisting_user(self):\n        # type: () -> None\n        with mock.patch('zproject.backends.get_user_profile_by_email',\n                        side_effect=UserProfile.DoesNotExist(\"Do not exist\")):\n            response = dict(email=self.email, name=self.name)\n            return_data = dict()  # type: Dict[str, Any]\n            user = self.backend.authenticate(return_data=return_data, response=response)\n            self.assertIs(user, None)\n            self.assertTrue(return_data['valid_attestation'])\n\n    def test_github_backend_authenticate_invalid_email(self):\n        # type: () -> None\n        response = dict(email=None, name=self.name)\n        return_data = dict()  # type: Dict[str, Any]\n        user = self.backend.authenticate(return_data=return_data, response=response)\n        self.assertIs(user, None)\n        self.assertTrue(return_data['invalid_email'])\n\n    def test_github_backend_inactive_user(self):\n        # type: () -> None\n        def do_auth_inactive(*args, **kwargs):\n            # type: (*Any, **Any) -> UserProfile\n            return_data = kwargs['return_data']\n            return_data['inactive_user'] = True\n            return self.user_profile\n\n        with mock.patch('zerver.views.auth.login_or_register_remote_user') as result, \\\n                mock.patch('social_core.backends.github.GithubOAuth2.do_auth',\n                           side_effect=do_auth_inactive):\n            response = dict(email=self.email, name=self.name)\n            user = self.backend.do_auth(response=response)\n            result.assert_not_called()\n            self.assertIs(user, None)\n\n    def test_github_backend_new_user_wrong_domain(self):\n        # type: () -> None\n        rf = RequestFactory()\n        request = rf.get('/complete')\n        request.session = {}\n        request.user = self.user_profile\n        self.backend.strategy.request = request\n        session_data = {'subdomain': False, 'is_signup': '1'}\n        self.backend.strategy.session_get = lambda k: session_data.get(k)\n\n        def do_auth(*args, **kwargs):\n            # type: (*Any, **Any) -> None\n            return_data = kwargs['return_data']\n            return_data['valid_attestation'] = True\n            return None\n\n        with mock.patch('social_core.backends.github.GithubOAuth2.do_auth',\n                        side_effect=do_auth):\n            email = 'nonexisting@phantom.com'\n            response = dict(email=email, name='Ghost')\n            result = self.backend.do_auth(response=response)\n            self.assert_in_response('action=\"/register/\"', result)\n            self.assert_in_response('Your email address, {}, is not '\n                                    'in one of the domains that are allowed to register '\n                                    'for accounts in this organization.'.format(email), result)\n\n    def test_github_backend_new_user(self):\n        # type: () -> None\n        rf = RequestFactory()\n        request = rf.get('/complete', HTTP_HOST=self.user_profile.realm.host)\n        request.session = {}\n        request.user = self.user_profile\n        self.backend.strategy.request = request\n        session_data = {'subdomain': False, 'is_signup': '1'}\n        self.backend.strategy.session_get = lambda k: session_data.get(k)\n\n        def do_auth(*args, **kwargs):\n            # type: (*Any, **Any) -> None\n            return_data = kwargs['return_data']\n            return_data['valid_attestation'] = True\n            return None\n\n        with mock.patch('social_core.backends.github.GithubOAuth2.do_auth',\n                        side_effect=do_auth):\n            email = self.nonreg_email('newuser')\n            name = \"Ghost\"\n            response = dict(email=email, name=name)\n            result = self.backend.do_auth(response=response)\n            confirmation = Confirmation.objects.all().first()\n            confirmation_key = confirmation.confirmation_key\n            self.assertIn('do_confirm/' + confirmation_key, result.url)\n            result = self.client_get(result.url)\n            self.assert_in_response('action=\"/accounts/register/\"', result)\n            data = {\"from_confirmation\": \"1\",\n                    \"full_name\": name,\n                    \"key\": confirmation_key}\n            result = self.client_post('/accounts/register/', data)\n            self.assert_in_response(\"You're almost there\", result)\n            # Verify that the user is asked for name but not password\n            self.assert_not_in_success_response(['id_password'], result)\n            self.assert_in_success_response(['id_full_name'], result)\n\n            result = self.client_post(\n                '/accounts/register/',\n                {'full_name': name,\n                 'key': confirmation_key,\n                 'terms': True})\n\n        self.assertEqual(result.status_code, 302)\n        user_profile = self.nonreg_user('newuser')\n        self.assertEqual(get_session_dict_user(self.client.session), user_profile.id)\n\n    def test_github_backend_existing_user(self):\n        # type: () -> None\n        rf = RequestFactory()\n        request = rf.get('/complete')\n        request.session = {}\n        request.user = self.user_profile\n        self.backend.strategy.request = request\n        session_data = {'subdomain': False, 'is_signup': '1'}\n        self.backend.strategy.session_get = lambda k: session_data.get(k)\n\n        def do_auth(*args, **kwargs):\n            # type: (*Any, **Any) -> None\n            return_data = kwargs['return_data']\n            return_data['valid_attestation'] = True\n            return None\n\n        with mock.patch('social_core.backends.github.GithubOAuth2.do_auth',\n                        side_effect=do_auth):\n            email = self.example_email(\"hamlet\")\n            response = dict(email=email, name='Hamlet')\n            result = self.backend.do_auth(response=response)\n            self.assert_in_response('action=\"/register/\"', result)\n            self.assert_in_response('hamlet@zulip.com already has an account',\n                                    result)\n\n    def test_github_backend_new_user_when_is_signup_is_false(self):\n        # type: () -> None\n        rf = RequestFactory()\n        request = rf.get('/complete')\n        request.session = {}\n        request.user = self.user_profile\n        self.backend.strategy.request = request\n        session_data = {'subdomain': False, 'is_signup': '0'}\n        self.backend.strategy.session_get = lambda k: session_data.get(k)\n\n        def do_auth(*args, **kwargs):\n            # type: (*Any, **Any) -> None\n            return_data = kwargs['return_data']\n            return_data['valid_attestation'] = True\n            return None\n\n        with mock.patch('social_core.backends.github.GithubOAuth2.do_auth',\n                        side_effect=do_auth):\n            email = 'nonexisting@phantom.com'\n            response = dict(email=email, name='Ghost')\n            result = self.backend.do_auth(response=response)\n            self.assert_in_response(\n                'action=\"/register/\"', result)\n            self.assert_in_response('No account found for',\n                                    result)\n            self.assert_in_response('nonexisting@phantom.com. Would you like to register instead?',\n                                    result)\n\n    def test_login_url(self):\n        # type: () -> None\n        result = self.client_get('/accounts/login/social/github')\n        self.assertIn(reverse('social:begin', args=['github']), result.url)\n        self.assertIn('is_signup=0', result.url)\n\n    def test_signup_url(self):\n        # type: () -> None\n        result = self.client_get('/accounts/register/social/github')\n        self.assertIn(reverse('social:begin', args=['github']), result.url)\n        self.assertIn('is_signup=1', result.url)\n\n    def test_github_complete(self):\n        # type: () -> None\n        from social_django import utils\n        utils.BACKENDS = ('zproject.backends.GitHubAuthBackend',)\n        with mock.patch('social_core.backends.oauth.BaseOAuth2.process_error',\n                        side_effect=AuthFailed('Not found')):\n            result = self.client_get(reverse('social:complete', args=['github']))\n            self.assertEqual(result.status_code, 302)\n            self.assertIn('login', result.url)\n\n        utils.BACKENDS = settings.AUTHENTICATION_BACKENDS\n\n    def test_github_complete_when_base_exc_is_raised(self):\n        # type: () -> None\n        from social_django import utils\n        utils.BACKENDS = ('zproject.backends.GitHubAuthBackend',)\n        with mock.patch('social_core.backends.oauth.BaseOAuth2.auth_complete',\n                        side_effect=AuthStateForbidden('State forbidden')), \\\n                mock.patch('zproject.backends.logging.warning'):\n            result = self.client_get(reverse('social:complete', args=['github']))\n            self.assertEqual(result.status_code, 302)\n            self.assertIn('login', result.url)\n\n        utils.BACKENDS = settings.AUTHENTICATION_BACKENDS\n\n    def test_github_complete_when_email_is_invalid(self):\n        # type: () -> None\n        from social_django import utils\n        utils.BACKENDS = ('zproject.backends.GitHubAuthBackend',)\n        with mock.patch('zproject.backends.GitHubAuthBackend.get_email_address',\n                        return_value=None) as mock_get_email_address, \\\n                mock.patch('social_core.backends.oauth.OAuthAuth.validate_state',\n                           return_value='state'), \\\n                mock.patch('social_core.backends.oauth.BaseOAuth2.request_access_token',\n                           return_value={'access_token': 'token'}), \\\n                mock.patch('social_core.backends.github.GithubOAuth2.do_auth',\n                           side_effect=self.do_auth), \\\n                mock.patch('zproject.backends.logging.warning'):\n            result = self.client_get(reverse('social:complete', args=['github']),\n                                     info={'state': 'state'})\n            self.assertEqual(result.status_code, 200)\n            self.assert_in_response(\"Please click the following button \"\n                                    \"if you wish to register.\", result)\n            self.assertEqual(mock_get_email_address.call_count, 2)\n\n        utils.BACKENDS = settings.AUTHENTICATION_BACKENDS\n\n\nclass ResponseMock(object):\n    def __init__(self, status_code, data):\n        # type: (int, Any) -> None\n        self.status_code = status_code\n        self.data = data\n\n    def json(self):\n        # type: () -> str\n        return self.data\n\n    @property\n    def text(self):\n        # type: () -> str\n        return \"Response text\"\n\nclass GoogleOAuthTest(ZulipTestCase):\n    def google_oauth2_test(self, token_response, account_response, *, subdomain=None,\n                           mobile_flow_otp=None, is_signup=None):\n        # type: (ResponseMock, ResponseMock, Optional[str], Optional[str], Optional[str]) -> HttpResponse\n        url = \"/accounts/login/google/\"\n        params = {}\n        headers = {}\n        if subdomain is not None:\n            headers['HTTP_HOST'] = subdomain + \".testserver\"\n        if mobile_flow_otp is not None:\n            params['mobile_flow_otp'] = mobile_flow_otp\n            headers['HTTP_USER_AGENT'] = \"ZulipAndroid\"\n        if is_signup is not None:\n            params['is_signup'] = is_signup\n        if len(params) > 0:\n            url += \"?%s\" % (urllib.parse.urlencode(params))\n\n        result = self.client_get(url, **headers)\n        if result.status_code != 302 or '/accounts/login/google/send/' not in result.url:\n            return result\n\n        # Now do the /google/send/ request\n        result = self.client_get(result.url, **headers)\n        self.assertEqual(result.status_code, 302)\n        if 'google' not in result.url:\n            return result\n\n        self.client.cookies = result.cookies\n        # Now extract the CSRF token from the redirect URL\n        parsed_url = urllib.parse.urlparse(result.url)\n        csrf_state = urllib.parse.parse_qs(parsed_url.query)['state']\n\n        with mock.patch(\"requests.post\", return_value=token_response), (\n                mock.patch(\"requests.get\", return_value=account_response)):\n            result = self.client_get(\"/accounts/login/google/done/\",\n                                     dict(state=csrf_state), **headers)\n        return result\n\nclass GoogleSubdomainLoginTest(GoogleOAuthTest):\n    def get_signed_subdomain_cookie(self, data):\n        # type: (Dict[str, Any]) -> Dict[str, str]\n        key = 'subdomain.signature'\n        salt = key + 'zerver.views.auth'\n        value = ujson.dumps(data)\n        return {key: signing.get_cookie_signer(salt=salt).sign(value)}\n\n    def test_google_oauth2_start(self):\n        # type: () -> None\n        result = self.client_get('/accounts/login/google/', subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 302)\n        parsed_url = urllib.parse.urlparse(result.url)\n        subdomain = urllib.parse.parse_qs(parsed_url.query)['subdomain']\n        self.assertEqual(subdomain, ['zulip'])\n\n    def test_google_oauth2_success(self):\n        # type: () -> None\n        token_response = ResponseMock(200, {'access_token': \"unique_token\"})\n        account_data = dict(name=dict(formatted=\"Full Name\"),\n                            emails=[dict(type=\"account\",\n                                         value=self.example_email(\"hamlet\"))])\n        account_response = ResponseMock(200, account_data)\n        result = self.google_oauth2_test(token_response, account_response, subdomain='zulip')\n\n        data = unsign_subdomain_cookie(result)\n        self.assertEqual(data['email'], self.example_email(\"hamlet\"))\n        self.assertEqual(data['name'], 'Full Name')\n        self.assertEqual(data['subdomain'], 'zulip')\n        self.assertEqual(result.status_code, 302)\n        parsed_url = urllib.parse.urlparse(result.url)\n        uri = \"{}://{}{}\".format(parsed_url.scheme, parsed_url.netloc,\n                                 parsed_url.path)\n        self.assertEqual(uri, 'http://zulip.testserver/accounts/login/subdomain/')\n\n    def test_google_oauth2_no_fullname(self):\n        # type: () -> None\n        token_response = ResponseMock(200, {'access_token': \"unique_token\"})\n        account_data = dict(name=dict(givenName=\"Test\", familyName=\"User\"),\n                            emails=[dict(type=\"account\",\n                                         value=self.example_email(\"hamlet\"))])\n        account_response = ResponseMock(200, account_data)\n        result = self.google_oauth2_test(token_response, account_response, subdomain='zulip')\n\n        data = unsign_subdomain_cookie(result)\n        self.assertEqual(data['email'], self.example_email(\"hamlet\"))\n        self.assertEqual(data['name'], 'Test User')\n        self.assertEqual(data['subdomain'], 'zulip')\n        self.assertEqual(result.status_code, 302)\n        parsed_url = urllib.parse.urlparse(result.url)\n        uri = \"{}://{}{}\".format(parsed_url.scheme, parsed_url.netloc,\n                                 parsed_url.path)\n        self.assertEqual(uri, 'http://zulip.testserver/accounts/login/subdomain/')\n\n    def test_google_oauth2_mobile_success(self):\n        # type: () -> None\n        mobile_flow_otp = '1234abcd' * 8\n        token_response = ResponseMock(200, {'access_token': \"unique_token\"})\n        account_data = dict(name=dict(formatted=\"Full Name\"),\n                            emails=[dict(type=\"account\",\n                                         value=self.example_email(\"hamlet\"))])\n        account_response = ResponseMock(200, account_data)\n        self.assertEqual(len(mail.outbox), 0)\n        with self.settings(SEND_LOGIN_EMAILS=True):\n            # Verify that the right thing happens with an invalid-format OTP\n            result = self.google_oauth2_test(token_response, account_response, subdomain='zulip',\n                                             mobile_flow_otp=\"1234\")\n            self.assert_json_error(result, \"Invalid OTP\")\n            result = self.google_oauth2_test(token_response, account_response, subdomain='zulip',\n                                             mobile_flow_otp=\"invalido\" * 8)\n            self.assert_json_error(result, \"Invalid OTP\")\n\n            # Now do it correctly\n            result = self.google_oauth2_test(token_response, account_response, subdomain='zulip',\n                                             mobile_flow_otp=mobile_flow_otp)\n        self.assertEqual(result.status_code, 302)\n        redirect_url = result['Location']\n        parsed_url = urllib.parse.urlparse(redirect_url)\n        query_params = urllib.parse.parse_qs(parsed_url.query)\n        self.assertEqual(parsed_url.scheme, 'zulip')\n        self.assertEqual(query_params[\"realm\"], ['http://zulip.testserver'])\n        self.assertEqual(query_params[\"email\"], [self.example_email(\"hamlet\")])\n        encrypted_api_key = query_params[\"otp_encrypted_api_key\"][0]\n        self.assertEqual(self.example_user('hamlet').api_key,\n                         otp_decrypt_api_key(encrypted_api_key, mobile_flow_otp))\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertIn('Zulip on Android', mail.outbox[0].body)\n\n    def test_log_into_subdomain(self):\n        # type: () -> None\n        data = {'name': 'Full Name',\n                'email': self.example_email(\"hamlet\"),\n                'subdomain': 'zulip',\n                'is_signup': False}\n\n        self.client.cookies = SimpleCookie(self.get_signed_subdomain_cookie(data))\n        result = self.client_get('/accounts/login/subdomain/', subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 302)\n        user_profile = self.example_user('hamlet')\n        self.assertEqual(get_session_dict_user(self.client.session), user_profile.id)\n\n        # If authenticate_remote_user detects a subdomain mismatch, then\n        # the result should redirect to the login page.\n        with mock.patch(\n                'zerver.views.auth.authenticate_remote_user',\n                return_value=(None, {'invalid_subdomain': True})):\n            result = self.client_get('/accounts/login/subdomain/', subdomain=\"zulip\")\n            self.assertEqual(result.status_code, 302)\n            self.assertTrue(result['Location'].endswith, '?subdomain=1')\n\n    def test_log_into_subdomain_when_is_signup_is_true(self):\n        # type: () -> None\n        data = {'name': 'Full Name',\n                'email': self.example_email(\"hamlet\"),\n                'subdomain': 'zulip',\n                'is_signup': True}\n\n        self.client.cookies = SimpleCookie(self.get_signed_subdomain_cookie(data))\n        result = self.client_get('/accounts/login/subdomain/', subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response('hamlet@zulip.com already has an account', result)\n\n    def test_log_into_subdomain_when_is_signup_is_true_and_new_user(self):\n        # type: () -> None\n        data = {'name': 'New User Name',\n                'email': 'new@zulip.com',\n                'subdomain': 'zulip',\n                'is_signup': True}\n\n        self.client.cookies = SimpleCookie(self.get_signed_subdomain_cookie(data))\n        result = self.client_get('/accounts/login/subdomain/', subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 302)\n        confirmation = Confirmation.objects.all().first()\n        confirmation_key = confirmation.confirmation_key\n        self.assertIn('do_confirm/' + confirmation_key, result.url)\n        result = self.client_get(result.url)\n        self.assert_in_response('action=\"/accounts/register/\"', result)\n        data = {\"from_confirmation\": \"1\",\n                \"full_name\": data['name'],\n                \"key\": confirmation_key}\n        result = self.client_post('/accounts/register/', data, subdomain=\"zulip\")\n        self.assert_in_response(\"You're almost there\", result)\n\n        # Verify that the user is asked for name but not password\n        self.assert_not_in_success_response(['id_password'], result)\n        self.assert_in_success_response(['id_full_name'], result)\n\n    def test_log_into_subdomain_when_using_invite_link(self):\n        # type: () -> None\n        data = {'name': 'New User Name',\n                'email': 'new@zulip.com',\n                'subdomain': 'zulip',\n                'is_signup': True}\n\n        realm = get_realm(\"zulip\")\n        realm.invite_required = True\n        realm.save()\n\n        stream_names = [\"new_stream_1\", \"new_stream_2\"]\n        streams = []\n        for stream_name in set(stream_names):\n            stream, _ = create_stream_if_needed(realm, stream_name)\n            streams.append(stream)\n\n        self.client.cookies = SimpleCookie(self.get_signed_subdomain_cookie(data))\n\n        # Without the invite link, we can't create an account due to invite_required\n        result = self.client_get('/accounts/login/subdomain/', subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_success_response(['Sign up for Zulip'], result)\n\n        # Now confirm an invitation link works\n        referrer = self.example_user(\"hamlet\")\n        multiuse_obj = MultiuseInvite.objects.create(realm=realm, referred_by=referrer)\n        multiuse_obj.streams = streams\n        multiuse_obj.save()\n        invite_link = create_confirmation_link(multiuse_obj, realm.host,\n                                               Confirmation.MULTIUSE_INVITE)\n\n        result = self.client_get(invite_link, subdomain=\"zulip\")\n        self.assert_in_success_response(['Sign up for Zulip'], result)\n\n        result = self.client_get('/accounts/login/subdomain/', subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 302)\n\n        confirmation = Confirmation.objects.all().last()\n        confirmation_key = confirmation.confirmation_key\n        self.assertIn('do_confirm/' + confirmation_key, result.url)\n        result = self.client_get(result.url)\n        self.assert_in_response('action=\"/accounts/register/\"', result)\n        data2 = {\"from_confirmation\": \"1\",\n                 \"full_name\": data['name'],\n                 \"key\": confirmation_key}\n        result = self.client_post('/accounts/register/', data2, subdomain=\"zulip\")\n        self.assert_in_response(\"You're almost there\", result)\n\n        # Verify that the user is asked for name but not password\n        self.assert_not_in_success_response(['id_password'], result)\n        self.assert_in_success_response(['id_full_name'], result)\n\n        # Click confirm registration button.\n        result = self.client_post(\n            '/accounts/register/',\n            {'full_name': 'New User Name',\n             'key': confirmation_key,\n             'terms': True})\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(sorted(self.get_streams('new@zulip.com', realm)), stream_names)\n\n    def test_log_into_subdomain_when_email_is_none(self):\n        # type: () -> None\n        data = {'name': None,\n                'email': None,\n                'subdomain': 'zulip',\n                'is_signup': False}\n\n        self.client.cookies = SimpleCookie(self.get_signed_subdomain_cookie(data))\n        with mock.patch('logging.warning'):\n            result = self.client_get('/accounts/login/subdomain/', subdomain=\"zulip\")\n            self.assertEqual(result.status_code, 200)\n            self.assert_in_response(\"Please click the following button if you \"\n                                    \"wish to register\", result)\n\n    def test_user_cannot_log_into_nonexisting_realm(self):\n        # type: () -> None\n        token_response = ResponseMock(200, {'access_token': \"unique_token\"})\n        account_data = dict(name=dict(formatted=\"Full Name\"),\n                            emails=[dict(type=\"account\",\n                                         value=self.example_email(\"hamlet\"))])\n        account_response = ResponseMock(200, account_data)\n        result = self.google_oauth2_test(token_response, account_response,\n                                         subdomain='nonexistent')\n        self.assert_in_success_response([\"There is no Zulip organization hosted at this subdomain.\"],\n                                        result)\n\n    def test_user_cannot_log_into_wrong_subdomain(self):\n        # type: () -> None\n        token_response = ResponseMock(200, {'access_token': \"unique_token\"})\n        account_data = dict(name=dict(formatted=\"Full Name\"),\n                            emails=[dict(type=\"account\",\n                                         value=self.example_email(\"hamlet\"))])\n        account_response = ResponseMock(200, account_data)\n        result = self.google_oauth2_test(token_response, account_response,\n                                         subdomain='zephyr')\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"http://zephyr.testserver/accounts/login/subdomain/\")\n        result = self.client_get('/accounts/login/subdomain/', subdomain=\"zephyr\")\n        self.assertEqual(result.status_code, 302)\n        result = self.client_get('/accounts/login/?subdomain=1', subdomain=\"zephyr\")\n        self.assert_in_success_response([\"Your Zulip account is not a member of the organization associated with this subdomain.\"],\n                                        result)\n\n    def test_user_cannot_log_into_wrong_subdomain_with_cookie(self):\n        # type: () -> None\n        data = {'name': 'Full Name',\n                'email': self.example_email(\"hamlet\"),\n                'subdomain': 'zephyr'}\n\n        self.client.cookies = SimpleCookie(self.get_signed_subdomain_cookie(data))\n        result = self.client_get('/accounts/login/subdomain/', subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 400)\n\n    def test_log_into_subdomain_when_signature_is_bad(self):\n        # type: () -> None\n        self.client.cookies = SimpleCookie({'subdomain.signature': 'invlaid'})\n        result = self.client_get('/accounts/login/subdomain/', subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 400)\n\n    def test_log_into_subdomain_when_state_is_not_passed(self):\n        # type: () -> None\n        result = self.client_get('/accounts/login/subdomain/', subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 400)\n\n    def test_google_oauth2_registration(self):\n        # type: () -> None\n        \"\"\"If the user doesn't exist yet, Google auth can be used to register an account\"\"\"\n        email = \"newuser@zulip.com\"\n        realm = get_realm(\"zulip\")\n        token_response = ResponseMock(200, {'access_token': \"unique_token\"})\n        account_data = dict(name=dict(formatted=\"Full Name\"),\n                            emails=[dict(type=\"account\",\n                                         value=email)])\n        account_response = ResponseMock(200, account_data)\n        result = self.google_oauth2_test(token_response, account_response, subdomain='zulip',\n                                         is_signup='1')\n\n        data = unsign_subdomain_cookie(result)\n        name = 'Full Name'\n        self.assertEqual(data['email'], email)\n        self.assertEqual(data['name'], name)\n        self.assertEqual(data['subdomain'], 'zulip')\n        self.assertEqual(result.status_code, 302)\n        parsed_url = urllib.parse.urlparse(result.url)\n        uri = \"{}://{}{}\".format(parsed_url.scheme, parsed_url.netloc,\n                                 parsed_url.path)\n        self.assertEqual(uri, 'http://zulip.testserver/accounts/login/subdomain/')\n\n        result = self.client_get(result.url)\n        self.assertEqual(result.status_code, 302)\n        confirmation = Confirmation.objects.all().first()\n        confirmation_key = confirmation.confirmation_key\n        self.assertIn('do_confirm/' + confirmation_key, result.url)\n        result = self.client_get(result.url)\n        self.assert_in_response('action=\"/accounts/register/\"', result)\n        data = {\"from_confirmation\": \"1\",\n                \"full_name\": name,\n                \"key\": confirmation_key}\n        result = self.client_post('/accounts/register/', data)\n        self.assert_in_response(\"You're almost there\", result)\n\n        # Verify that the user is asked for name but not password\n        self.assert_not_in_success_response(['id_password'], result)\n        self.assert_in_success_response(['id_full_name'], result)\n\n        # Click confirm registration button.\n        result = self.client_post(\n            '/accounts/register/',\n            {'full_name': name,\n             'key': confirmation_key,\n             'terms': True})\n\n        self.assertEqual(result.status_code, 302)\n        user_profile = get_user(email, realm)\n        self.assertEqual(get_session_dict_user(self.client.session), user_profile.id)\n\nclass GoogleLoginTest(GoogleOAuthTest):\n    @override_settings(ROOT_DOMAIN_LANDING_PAGE=True)\n    def test_google_oauth2_subdomains_homepage(self):\n        # type: () -> None\n        token_response = ResponseMock(200, {'access_token': \"unique_token\"})\n        account_data = dict(name=dict(formatted=\"Full Name\"),\n                            emails=[dict(type=\"account\",\n                                         value=self.example_email(\"hamlet\"))])\n        account_response = ResponseMock(200, account_data)\n        result = self.google_oauth2_test(token_response, account_response, subdomain=\"\")\n        self.assertEqual(result.status_code, 302)\n        self.assertIn('subdomain=1', result.url)\n\n    def test_google_oauth2_400_token_response(self):\n        # type: () -> None\n        token_response = ResponseMock(400, {})\n        with mock.patch(\"logging.warning\") as m:\n            result = self.google_oauth2_test(token_response, ResponseMock(500, {}))\n        self.assertEqual(result.status_code, 400)\n        self.assertEqual(m.call_args_list[0][0][0],\n                         \"User error converting Google oauth2 login to token: Response text\")\n\n    def test_google_oauth2_500_token_response(self):\n        # type: () -> None\n        token_response = ResponseMock(500, {})\n        with mock.patch(\"logging.error\") as m:\n            result = self.google_oauth2_test(token_response, ResponseMock(500, {}))\n        self.assertEqual(result.status_code, 400)\n        self.assertEqual(m.call_args_list[0][0][0],\n                         \"Could not convert google oauth2 code to access_token: Response text\")\n\n    def test_google_oauth2_400_account_response(self):\n        # type: () -> None\n        token_response = ResponseMock(200, {'access_token': \"unique_token\"})\n        account_response = ResponseMock(400, {})\n        with mock.patch(\"logging.warning\") as m:\n            result = self.google_oauth2_test(token_response, account_response)\n        self.assertEqual(result.status_code, 400)\n        self.assertEqual(m.call_args_list[0][0][0],\n                         \"Google login failed making info API call: Response text\")\n\n    def test_google_oauth2_500_account_response(self):\n        # type: () -> None\n        token_response = ResponseMock(200, {'access_token': \"unique_token\"})\n        account_response = ResponseMock(500, {})\n        with mock.patch(\"logging.error\") as m:\n            result = self.google_oauth2_test(token_response, account_response)\n        self.assertEqual(result.status_code, 400)\n        self.assertEqual(m.call_args_list[0][0][0],\n                         \"Google login failed making API call: Response text\")\n\n    def test_google_oauth2_account_response_no_email(self):\n        # type: () -> None\n        token_response = ResponseMock(200, {'access_token': \"unique_token\"})\n        account_data = dict(name=dict(formatted=\"Full Name\"),\n                            emails=[])\n        account_response = ResponseMock(200, account_data)\n        with mock.patch(\"logging.error\") as m:\n            result = self.google_oauth2_test(token_response, account_response,\n                                             subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 400)\n        self.assertIn(\"Google oauth2 account email not found:\", m.call_args_list[0][0][0])\n\n    def test_google_oauth2_error_access_denied(self):\n        # type: () -> None\n        result = self.client_get(\"/accounts/login/google/done/?error=access_denied\")\n        self.assertEqual(result.status_code, 302)\n        path = urllib.parse.urlparse(result.url).path\n        self.assertEqual(path, \"/\")\n\n    def test_google_oauth2_error_other(self):\n        # type: () -> None\n        with mock.patch(\"logging.warning\") as m:\n            result = self.client_get(\"/accounts/login/google/done/?error=some_other_error\")\n        self.assertEqual(result.status_code, 400)\n        self.assertEqual(m.call_args_list[0][0][0],\n                         \"Error from google oauth2 login: some_other_error\")\n\n    def test_google_oauth2_missing_csrf(self):\n        # type: () -> None\n        with mock.patch(\"logging.warning\") as m:\n            result = self.client_get(\"/accounts/login/google/done/\")\n        self.assertEqual(result.status_code, 400)\n        self.assertEqual(m.call_args_list[0][0][0],\n                         'Missing Google oauth2 CSRF state')\n\n    def test_google_oauth2_csrf_malformed(self):\n        # type: () -> None\n        with mock.patch(\"logging.warning\") as m:\n            result = self.client_get(\"/accounts/login/google/done/?state=badstate\")\n        self.assertEqual(result.status_code, 400)\n        self.assertEqual(m.call_args_list[0][0][0],\n                         'Missing Google oauth2 CSRF state')\n\n    def test_google_oauth2_csrf_badstate(self):\n        # type: () -> None\n        with mock.patch(\"logging.warning\") as m:\n            result = self.client_get(\"/accounts/login/google/done/?state=badstate:otherbadstate:more::\")\n        self.assertEqual(result.status_code, 400)\n        self.assertEqual(m.call_args_list[0][0][0],\n                         'Google oauth2 CSRF error')\n\nclass FetchAPIKeyTest(ZulipTestCase):\n    def setUp(self):\n        # type: () -> None\n        self.user_profile = self.example_user('hamlet')\n        self.email = self.user_profile.email\n\n    def test_success(self):\n        # type: () -> None\n        result = self.client_post(\"/api/v1/fetch_api_key\",\n                                  dict(username=self.email,\n                                       password=initial_password(self.email)))\n        self.assert_json_success(result)\n\n    def test_invalid_email(self):\n        # type: () -> None\n        result = self.client_post(\"/api/v1/fetch_api_key\",\n                                  dict(username='hamlet',\n                                       password=initial_password(self.email)))\n        self.assert_json_error(result, \"Enter a valid email address.\", 400)\n\n    def test_wrong_password(self):\n        # type: () -> None\n        result = self.client_post(\"/api/v1/fetch_api_key\",\n                                  dict(username=self.email,\n                                       password=\"wrong\"))\n        self.assert_json_error(result, \"Your username or password is incorrect.\", 403)\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.GoogleMobileOauth2Backend',),\n                       SEND_LOGIN_EMAILS=True)\n    def test_google_oauth2_token_success(self):\n        # type: () -> None\n        self.assertEqual(len(mail.outbox), 0)\n        with mock.patch(\n                'apiclient.sample_tools.client.verify_id_token',\n                return_value={\n                    \"email_verified\": True,\n                    \"email\": self.example_email(\"hamlet\"),\n                }):\n            result = self.client_post(\"/api/v1/fetch_api_key\",\n                                      dict(username=\"google-oauth2-token\",\n                                           password=\"token\"))\n        self.assert_json_success(result)\n        self.assertEqual(len(mail.outbox), 1)\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.GoogleMobileOauth2Backend',))\n    def test_google_oauth2_token_failure(self):\n        # type: () -> None\n        payload = dict(email_verified=False)\n        with mock.patch('apiclient.sample_tools.client.verify_id_token', return_value=payload):\n            result = self.client_post(\"/api/v1/fetch_api_key\",\n                                      dict(username=\"google-oauth2-token\",\n                                           password=\"token\"))\n            self.assert_json_error(result, \"Your username or password is incorrect.\", 403)\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.GoogleMobileOauth2Backend',))\n    def test_google_oauth2_token_unregistered(self):\n        # type: () -> None\n        with mock.patch(\n                'apiclient.sample_tools.client.verify_id_token',\n                return_value={\n                    \"email_verified\": True,\n                    \"email\": \"nobody@zulip.com\",\n                }):\n            result = self.client_post(\"/api/v1/fetch_api_key\",\n                                      dict(username=\"google-oauth2-token\",\n                                           password=\"token\"))\n        self.assert_json_error(\n            result,\n            \"This user is not registered; do so from a browser.\",\n            403)\n\n    def test_password_auth_disabled(self):\n        # type: () -> None\n        with mock.patch('zproject.backends.password_auth_enabled', return_value=False):\n            result = self.client_post(\"/api/v1/fetch_api_key\",\n                                      dict(username=self.email,\n                                           password=initial_password(self.email)))\n            self.assert_json_error_contains(result, \"Password auth is disabled\", 403)\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',))\n    def test_ldap_auth_email_auth_disabled_success(self):\n        # type: () -> None\n        ldap_patcher = mock.patch('django_auth_ldap.config.ldap.initialize')\n        self.mock_initialize = ldap_patcher.start()\n        self.mock_ldap = MockLDAP()\n        self.mock_initialize.return_value = self.mock_ldap\n        self.backend = ZulipLDAPAuthBackend()\n\n        self.mock_ldap.directory = {\n            'uid=hamlet,ou=users,dc=zulip,dc=com': {\n                'userPassword': 'testing'\n            }\n        }\n        with self.settings(\n                LDAP_APPEND_DOMAIN='zulip.com',\n                AUTH_LDAP_BIND_PASSWORD='',\n                AUTH_LDAP_USER_DN_TEMPLATE='uid=%(user)s,ou=users,dc=zulip,dc=com'):\n            result = self.client_post(\"/api/v1/fetch_api_key\",\n                                      dict(username=self.email,\n                                           password=\"testing\"))\n        self.assert_json_success(result)\n        self.mock_ldap.reset()\n        self.mock_initialize.stop()\n\n    def test_inactive_user(self):\n        # type: () -> None\n        do_deactivate_user(self.user_profile)\n        result = self.client_post(\"/api/v1/fetch_api_key\",\n                                  dict(username=self.email,\n                                       password=initial_password(self.email)))\n        self.assert_json_error_contains(result, \"Your account has been disabled\", 403)\n\n    def test_deactivated_realm(self):\n        # type: () -> None\n        do_deactivate_realm(self.user_profile.realm)\n        result = self.client_post(\"/api/v1/fetch_api_key\",\n                                  dict(username=self.email,\n                                       password=initial_password(self.email)))\n        self.assert_json_error_contains(result, \"Your realm has been deactivated\", 403)\n\nclass DevFetchAPIKeyTest(ZulipTestCase):\n    def setUp(self):\n        # type: () -> None\n        self.user_profile = self.example_user('hamlet')\n        self.email = self.user_profile.email\n\n    def test_success(self):\n        # type: () -> None\n        result = self.client_post(\"/api/v1/dev_fetch_api_key\",\n                                  dict(username=self.email))\n        self.assert_json_success(result)\n        data = result.json()\n        self.assertEqual(data[\"email\"], self.email)\n        self.assertEqual(data['api_key'], self.user_profile.api_key)\n\n    def test_invalid_email(self):\n        # type: () -> None\n        email = 'hamlet'\n        result = self.client_post(\"/api/v1/dev_fetch_api_key\",\n                                  dict(username=email))\n        self.assert_json_error_contains(result, \"Enter a valid email address.\", 400)\n\n    def test_unregistered_user(self):\n        # type: () -> None\n        email = 'foo@zulip.com'\n        result = self.client_post(\"/api/v1/dev_fetch_api_key\",\n                                  dict(username=email))\n        self.assert_json_error_contains(result, \"This user is not registered.\", 403)\n\n    def test_inactive_user(self):\n        # type: () -> None\n        do_deactivate_user(self.user_profile)\n        result = self.client_post(\"/api/v1/dev_fetch_api_key\",\n                                  dict(username=self.email))\n        self.assert_json_error_contains(result, \"Your account has been disabled\", 403)\n\n    def test_deactivated_realm(self):\n        # type: () -> None\n        do_deactivate_realm(self.user_profile.realm)\n        result = self.client_post(\"/api/v1/dev_fetch_api_key\",\n                                  dict(username=self.email))\n        self.assert_json_error_contains(result, \"Your realm has been deactivated\", 403)\n\n    def test_dev_auth_disabled(self):\n        # type: () -> None\n        with mock.patch('zerver.views.auth.dev_auth_enabled', return_value=False):\n            result = self.client_post(\"/api/v1/dev_fetch_api_key\",\n                                      dict(username=self.email))\n            self.assert_json_error_contains(result, \"Dev environment not enabled.\", 400)\n\nclass DevGetEmailsTest(ZulipTestCase):\n    def test_success(self):\n        # type: () -> None\n        result = self.client_get(\"/api/v1/dev_get_emails\")\n        self.assert_json_success(result)\n        self.assert_in_response(\"direct_admins\", result)\n        self.assert_in_response(\"direct_users\", result)\n\n    def test_dev_auth_disabled(self):\n        # type: () -> None\n        with mock.patch('zerver.views.auth.dev_auth_enabled', return_value=False):\n            result = self.client_get(\"/api/v1/dev_get_emails\")\n            self.assert_json_error_contains(result, \"Dev environment not enabled.\", 400)\n\nclass FetchAuthBackends(ZulipTestCase):\n    def assert_on_error(self, error):\n        # type: (Optional[str]) -> None\n        if error:\n            raise AssertionError(error)\n\n    def test_get_server_settings(self):\n        # type: () -> None\n        result = self.client_get(\"/api/v1/server_settings\",\n                                 subdomain=\"\")\n        self.assert_json_success(result)\n        data = result.json()\n        schema_checker = check_dict_only([\n            ('authentication_methods', check_dict_only([\n                ('google', check_bool),\n                ('github', check_bool),\n                ('email', check_bool),\n                ('ldap', check_bool),\n                ('dev', check_bool),\n                ('password', check_bool),\n            ])),\n            ('email_auth_enabled', check_bool),\n            ('require_email_format_usernames', check_bool),\n            ('realm_uri', check_string),\n            ('zulip_version', check_string),\n            ('msg', check_string),\n            ('result', check_string),\n        ])\n        self.assert_on_error(schema_checker(\"data\", data))\n\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=False):\n            result = self.client_get(\"/api/v1/server_settings\",\n                                     subdomain=\"\")\n            self.assert_json_success(result)\n            data = result.json()\n            schema_checker = check_dict_only([\n                ('authentication_methods', check_dict_only([\n                    ('google', check_bool),\n                    ('github', check_bool),\n                    ('dev', check_bool),\n                    ('email', check_bool),\n                    ('ldap', check_bool),\n                    ('password', check_bool),\n                ])),\n                ('email_auth_enabled', check_bool),\n                ('require_email_format_usernames', check_bool),\n                ('realm_uri', check_string),\n                ('zulip_version', check_string),\n                ('msg', check_string),\n                ('result', check_string),\n            ])\n            self.assert_on_error(schema_checker(\"data\", data))\n\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=False):\n            result = self.client_get(\"/api/v1/server_settings\",\n                                     subdomain=\"zulip\")\n        self.assert_json_success(result)\n        data = result.json()\n        with_realm_schema_checker = check_dict_only([\n            ('zulip_version', check_string),\n            ('realm_uri', check_string),\n            ('realm_name', check_string),\n            ('realm_description', check_string),\n            ('realm_icon', check_string),\n            ('email_auth_enabled', check_bool),\n            ('require_email_format_usernames', check_bool),\n            ('authentication_methods', check_dict_only([\n                ('google', check_bool),\n                ('github', check_bool),\n                ('dev', check_bool),\n                ('email', check_bool),\n                ('ldap', check_bool),\n                ('password', check_bool),\n            ])),\n            ('msg', check_string),\n            ('result', check_string),\n        ])\n        self.assert_on_error(with_realm_schema_checker(\"data\", data))\n\n    def test_fetch_auth_backend_format(self):\n        # type: () -> None\n        result = self.client_get(\"/api/v1/get_auth_backends\")\n        self.assert_json_success(result)\n        data = result.json()\n        self.assertEqual(set(data.keys()),\n                         {'msg', 'password', 'github', 'google', 'email', 'ldap',\n                          'dev', 'result', 'zulip_version'})\n        for backend in set(data.keys()) - {'msg', 'result', 'zulip_version'}:\n            self.assertTrue(isinstance(data[backend], bool))\n\n    def test_fetch_auth_backend(self):\n        # type: () -> None\n        backends = [GoogleMobileOauth2Backend(), DevAuthBackend()]\n        with mock.patch('django.contrib.auth.get_backends', return_value=backends):\n            result = self.client_get(\"/api/v1/get_auth_backends\")\n            self.assert_json_success(result)\n            data = result.json()\n            self.assertEqual(data, {\n                'msg': '',\n                'password': False,\n                'github': False,\n                'google': True,\n                'dev': True,\n                'email': False,\n                'ldap': False,\n                'result': 'success',\n                'zulip_version': ZULIP_VERSION,\n            })\n\n            # Test subdomains cases\n            with self.settings(ROOT_DOMAIN_LANDING_PAGE=False):\n                result = self.client_get(\"/api/v1/get_auth_backends\")\n                self.assert_json_success(result)\n                data = result.json()\n                self.assertEqual(data, {\n                    'msg': '',\n                    'password': False,\n                    'github': False,\n                    'google': True,\n                    'email': False,\n                    'ldap': False,\n                    'dev': True,\n                    'result': 'success',\n                    'zulip_version': ZULIP_VERSION,\n                })\n\n                # Verify invalid subdomain\n                result = self.client_get(\"/api/v1/get_auth_backends\",\n                                         subdomain=\"invalid\")\n                self.assert_json_error_contains(result, \"Invalid subdomain\", 400)\n\n                # Verify correct behavior with a valid subdomain with\n                # some backends disabled for the realm\n                realm = get_realm(\"zulip\")\n                do_set_realm_authentication_methods(realm, dict(Google=False, Email=False, Dev=True))\n                result = self.client_get(\"/api/v1/get_auth_backends\",\n                                         subdomain=\"zulip\")\n                self.assert_json_success(result)\n                data = result.json()\n                self.assertEqual(data, {\n                    'msg': '',\n                    'password': False,\n                    'github': False,\n                    'google': False,\n                    'email': False,\n                    'ldap': False,\n                    'dev': True,\n                    'result': 'success',\n                    'zulip_version': ZULIP_VERSION,\n                })\n            with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n                # With ROOT_DOMAIN_LANDING_PAGE, homepage fails\n                result = self.client_get(\"/api/v1/get_auth_backends\",\n                                         subdomain=\"\")\n                self.assert_json_error_contains(result, \"Subdomain required\", 400)\n\n                # With ROOT_DOMAIN_LANDING_PAGE, subdomain pages succeed\n                result = self.client_get(\"/api/v1/get_auth_backends\",\n                                         subdomain=\"zulip\")\n                self.assert_json_success(result)\n                data = result.json()\n                self.assertEqual(data, {\n                    'msg': '',\n                    'password': False,\n                    'github': False,\n                    'google': False,\n                    'email': False,\n                    'ldap': False,\n                    'dev': True,\n                    'result': 'success',\n                    'zulip_version': ZULIP_VERSION,\n                })\n\nclass TestDevAuthBackend(ZulipTestCase):\n    def test_login_success(self):\n        # type: () -> None\n        user_profile = self.example_user('hamlet')\n        email = user_profile.email\n        data = {'direct_email': email}\n        result = self.client_post('/accounts/login/local/', data)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(get_session_dict_user(self.client.session), user_profile.id)\n\n    def test_login_with_subdomain(self):\n        # type: () -> None\n        user_profile = self.example_user('hamlet')\n        email = user_profile.email\n        data = {'direct_email': email}\n\n        result = self.client_post('/accounts/login/local/', data)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(get_session_dict_user(self.client.session), user_profile.id)\n\n    def test_choose_realm(self):\n        # type: () -> None\n        result = self.client_post('/devlogin/', subdomain=\"zulip\")\n        self.assert_in_success_response([\"Click on a user to log in to Zulip Dev!\"], result)\n        self.assert_in_success_response([\"iago@zulip.com\", \"hamlet@zulip.com\"], result)\n\n        result = self.client_post('/devlogin/', subdomain=\"\")\n        self.assert_in_success_response([\"Click on a user to log in!\"], result)\n        self.assert_in_success_response([\"iago@zulip.com\", \"hamlet@zulip.com\"], result)\n        self.assert_in_success_response([\"starnine@mit.edu\", \"espuser@mit.edu\"], result)\n\n        data = {'new_realm': 'zephyr'}\n        result = self.client_post('/devlogin/', data, subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"http://zephyr.testserver\")\n        result = self.client_get('/devlogin/', subdomain=\"zephyr\")\n        self.assert_in_success_response([\"starnine@mit.edu\", \"espuser@mit.edu\"], result)\n        self.assert_in_success_response([\"Click on a user to log in to MIT!\"], result)\n        self.assert_not_in_success_response([\"iago@zulip.com\", \"hamlet@zulip.com\"], result)\n\n    def test_choose_realm_with_subdomains_enabled(self):\n        # type: () -> None\n        with mock.patch('zerver.views.auth.is_subdomain_root_or_alias', return_value=False):\n            with mock.patch('zerver.views.auth.get_realm_from_request', return_value=get_realm('zulip')):\n                result = self.client_get(\"http://zulip.testserver/devlogin/\")\n                self.assert_in_success_response([\"iago@zulip.com\", \"hamlet@zulip.com\"], result)\n                self.assert_not_in_success_response([\"starnine@mit.edu\", \"espuser@mit.edu\"], result)\n                self.assert_in_success_response([\"Click on a user to log in to Zulip Dev!\"], result)\n\n            with mock.patch('zerver.views.auth.get_realm_from_request', return_value=get_realm('zephyr')):\n                result = self.client_post(\"http://zulip.testserver/devlogin/\", {'new_realm': 'zephyr'})\n                self.assertEqual(result[\"Location\"], \"http://zephyr.testserver\")\n\n                result = self.client_get(\"http://zephyr.testserver/devlogin/\")\n                self.assert_not_in_success_response([\"iago@zulip.com\", \"hamlet@zulip.com\"], result)\n                self.assert_in_success_response([\"starnine@mit.edu\", \"espuser@mit.edu\"], result)\n                self.assert_in_success_response([\"Click on a user to log in to MIT!\"], result)\n\n    def test_login_failure(self):\n        # type: () -> None\n        email = self.example_email(\"hamlet\")\n        data = {'direct_email': email}\n        with self.settings(AUTHENTICATION_BACKENDS=('zproject.backends.EmailAuthBackend',)):\n            with self.assertRaisesRegex(Exception, 'Direct login not supported.'):\n                with mock.patch('django.core.handlers.exception.logger'):\n                    self.client_post('/accounts/login/local/', data)\n\n    def test_login_failure_due_to_nonexistent_user(self):\n        # type: () -> None\n        email = 'nonexisting@zulip.com'\n        data = {'direct_email': email}\n        with self.assertRaisesRegex(Exception, 'User cannot login'):\n            with mock.patch('django.core.handlers.exception.logger'):\n                self.client_post('/accounts/login/local/', data)\n\nclass TestZulipRemoteUserBackend(ZulipTestCase):\n    def test_login_success(self):\n        # type: () -> None\n        user_profile = self.example_user('hamlet')\n        email = user_profile.email\n        with self.settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipRemoteUserBackend',)):\n            result = self.client_post('/accounts/login/sso/', REMOTE_USER=email)\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(get_session_dict_user(self.client.session), user_profile.id)\n\n    def test_authenticate_with_missing_user(self):\n        # type: () -> None\n        backend = ZulipRemoteUserBackend()\n        self.assertIs(backend.authenticate(None), None)\n\n    def test_login_success_with_sso_append_domain(self):\n        # type: () -> None\n        username = 'hamlet'\n        user_profile = self.example_user('hamlet')\n        with self.settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipRemoteUserBackend',),\n                           SSO_APPEND_DOMAIN='zulip.com'):\n            result = self.client_post('/accounts/login/sso/', REMOTE_USER=username)\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(get_session_dict_user(self.client.session), user_profile.id)\n\n    def test_login_failure(self):\n        # type: () -> None\n        email = self.example_email(\"hamlet\")\n        result = self.client_post('/accounts/login/sso/', REMOTE_USER=email)\n        self.assertEqual(result.status_code, 200)  # This should ideally be not 200.\n        self.assertIs(get_session_dict_user(self.client.session), None)\n\n    def test_login_failure_due_to_nonexisting_user(self):\n        # type: () -> None\n        email = 'nonexisting@zulip.com'\n        with self.settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipRemoteUserBackend',)):\n            result = self.client_post('/accounts/login/sso/', REMOTE_USER=email)\n            self.assertEqual(result.status_code, 200)\n            self.assertIs(get_session_dict_user(self.client.session), None)\n            self.assert_in_response(\"No account found for\", result)\n\n    def test_login_failure_due_to_invalid_email(self):\n        # type: () -> None\n        email = 'hamlet'\n        with self.settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipRemoteUserBackend',)):\n            result = self.client_post('/accounts/login/sso/', REMOTE_USER=email)\n            self.assert_json_error_contains(result, \"Enter a valid email address.\", 400)\n\n    def test_login_failure_due_to_missing_field(self):\n        # type: () -> None\n        with self.settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipRemoteUserBackend',)):\n            result = self.client_post('/accounts/login/sso/')\n            self.assert_json_error_contains(result, \"No REMOTE_USER set.\", 400)\n\n    def test_login_failure_due_to_wrong_subdomain(self):\n        # type: () -> None\n        email = self.example_email(\"hamlet\")\n        with self.settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipRemoteUserBackend',)):\n            with mock.patch('zerver.views.auth.get_subdomain', return_value='acme'):\n                result = self.client_post('http://testserver:9080/accounts/login/sso/',\n                                          REMOTE_USER=email)\n                self.assertEqual(result.status_code, 200)\n                self.assertIs(get_session_dict_user(self.client.session), None)\n                self.assert_in_response(\"No account found for\", result)\n\n    def test_login_failure_due_to_empty_subdomain(self):\n        # type: () -> None\n        email = self.example_email(\"hamlet\")\n        with self.settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipRemoteUserBackend',)):\n            with mock.patch('zerver.views.auth.get_subdomain', return_value=''):\n                result = self.client_post('http://testserver:9080/accounts/login/sso/',\n                                          REMOTE_USER=email)\n                self.assertEqual(result.status_code, 200)\n                self.assertIs(get_session_dict_user(self.client.session), None)\n                self.assert_in_response(\"No account found for\", result)\n\n    def test_login_success_under_subdomains(self):\n        # type: () -> None\n        user_profile = self.example_user('hamlet')\n        email = user_profile.email\n        with mock.patch('zerver.views.auth.get_subdomain', return_value='zulip'):\n            with self.settings(\n                    AUTHENTICATION_BACKENDS=('zproject.backends.ZulipRemoteUserBackend',)):\n                result = self.client_post('/accounts/login/sso/', REMOTE_USER=email)\n                self.assertEqual(result.status_code, 302)\n                self.assertIs(get_session_dict_user(self.client.session), user_profile.id)\n\nclass TestJWTLogin(ZulipTestCase):\n    \"\"\"\n    JWT uses ZulipDummyBackend.\n    \"\"\"\n\n    def test_login_success(self):\n        # type: () -> None\n        payload = {'user': 'hamlet', 'realm': 'zulip.com'}\n        with self.settings(JWT_AUTH_KEYS={'zulip': 'key'}):\n            email = self.example_email(\"hamlet\")\n            realm = get_realm('zulip')\n            auth_key = settings.JWT_AUTH_KEYS['zulip']\n            web_token = jwt.encode(payload, auth_key).decode('utf8')\n\n            user_profile = get_user(email, realm)\n            data = {'json_web_token': web_token}\n            result = self.client_post('/accounts/login/jwt/', data)\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(get_session_dict_user(self.client.session), user_profile.id)\n\n    def test_login_failure_when_user_is_missing(self):\n        # type: () -> None\n        payload = {'realm': 'zulip.com'}\n        with self.settings(JWT_AUTH_KEYS={'zulip': 'key'}):\n            auth_key = settings.JWT_AUTH_KEYS['zulip']\n            web_token = jwt.encode(payload, auth_key).decode('utf8')\n            data = {'json_web_token': web_token}\n            result = self.client_post('/accounts/login/jwt/', data)\n            self.assert_json_error_contains(result, \"No user specified in JSON web token claims\", 400)\n\n    def test_login_failure_when_realm_is_missing(self):\n        # type: () -> None\n        payload = {'user': 'hamlet'}\n        with self.settings(JWT_AUTH_KEYS={'zulip': 'key'}):\n            auth_key = settings.JWT_AUTH_KEYS['zulip']\n            web_token = jwt.encode(payload, auth_key).decode('utf8')\n            data = {'json_web_token': web_token}\n            result = self.client_post('/accounts/login/jwt/', data)\n            self.assert_json_error_contains(result, \"No realm specified in JSON web token claims\", 400)\n\n    def test_login_failure_when_key_does_not_exist(self):\n        # type: () -> None\n        data = {'json_web_token': 'not relevant'}\n        result = self.client_post('/accounts/login/jwt/', data)\n        self.assert_json_error_contains(result, \"Auth key for this subdomain not found.\", 400)\n\n    def test_login_failure_when_key_is_missing(self):\n        # type: () -> None\n        with self.settings(JWT_AUTH_KEYS={'zulip': 'key'}):\n            result = self.client_post('/accounts/login/jwt/')\n            self.assert_json_error_contains(result, \"No JSON web token passed in request\", 400)\n\n    def test_login_failure_when_bad_token_is_passed(self):\n        # type: () -> None\n        with self.settings(JWT_AUTH_KEYS={'zulip': 'key'}):\n            result = self.client_post('/accounts/login/jwt/')\n            self.assert_json_error_contains(result, \"No JSON web token passed in request\", 400)\n            data = {'json_web_token': 'bad token'}\n            result = self.client_post('/accounts/login/jwt/', data)\n            self.assert_json_error_contains(result, \"Bad JSON web token\", 400)\n\n    def test_login_failure_when_user_does_not_exist(self):\n        # type: () -> None\n        payload = {'user': 'nonexisting', 'realm': 'zulip.com'}\n        with self.settings(JWT_AUTH_KEYS={'zulip': 'key'}):\n            auth_key = settings.JWT_AUTH_KEYS['zulip']\n            web_token = jwt.encode(payload, auth_key).decode('utf8')\n            data = {'json_web_token': web_token}\n            result = self.client_post('/accounts/login/jwt/', data)\n            self.assertEqual(result.status_code, 200)  # This should ideally be not 200.\n            self.assertIs(get_session_dict_user(self.client.session), None)\n\n            # The /accounts/login/jwt/ endpoint should also handle the case\n            # where the authentication attempt throws UserProfile.DoesNotExist.\n            with mock.patch(\n                    'zerver.views.auth.authenticate',\n                    side_effect=UserProfile.DoesNotExist(\"Do not exist\")):\n                result = self.client_post('/accounts/login/jwt/', data)\n            self.assertEqual(result.status_code, 200)  # This should ideally be not 200.\n            self.assertIs(get_session_dict_user(self.client.session), None)\n\n    def test_login_failure_due_to_wrong_subdomain(self):\n        # type: () -> None\n        payload = {'user': 'hamlet', 'realm': 'zulip.com'}\n        with self.settings(JWT_AUTH_KEYS={'acme': 'key'}):\n            with mock.patch('zerver.views.auth.get_subdomain', return_value='acme'):\n                auth_key = settings.JWT_AUTH_KEYS['acme']\n                web_token = jwt.encode(payload, auth_key).decode('utf8')\n\n                data = {'json_web_token': web_token}\n                result = self.client_post('/accounts/login/jwt/', data)\n                self.assert_json_error_contains(result, \"Wrong subdomain\", 400)\n                self.assertEqual(get_session_dict_user(self.client.session), None)\n\n    def test_login_failure_due_to_empty_subdomain(self):\n        # type: () -> None\n        payload = {'user': 'hamlet', 'realm': 'zulip.com'}\n        with self.settings(JWT_AUTH_KEYS={'': 'key'}):\n            with mock.patch('zerver.views.auth.get_subdomain', return_value=''):\n                auth_key = settings.JWT_AUTH_KEYS['']\n                web_token = jwt.encode(payload, auth_key).decode('utf8')\n\n                data = {'json_web_token': web_token}\n                result = self.client_post('/accounts/login/jwt/', data)\n                self.assert_json_error_contains(result, \"Wrong subdomain\", 400)\n                self.assertEqual(get_session_dict_user(self.client.session), None)\n\n    def test_login_success_under_subdomains(self):\n        # type: () -> None\n        payload = {'user': 'hamlet', 'realm': 'zulip.com'}\n        with self.settings(JWT_AUTH_KEYS={'zulip': 'key'}):\n            with mock.patch('zerver.views.auth.get_subdomain', return_value='zulip'):\n                auth_key = settings.JWT_AUTH_KEYS['zulip']\n                web_token = jwt.encode(payload, auth_key).decode('utf8')\n\n                data = {'json_web_token': web_token}\n                result = self.client_post('/accounts/login/jwt/', data)\n                self.assertEqual(result.status_code, 302)\n                user_profile = self.example_user('hamlet')\n                self.assertEqual(get_session_dict_user(self.client.session), user_profile.id)\n\nclass TestLDAP(ZulipTestCase):\n    def setUp(self):\n        # type: () -> None\n        user_profile = self.example_user('hamlet')\n        self.setup_subdomain(user_profile)\n\n        ldap_patcher = mock.patch('django_auth_ldap.config.ldap.initialize')\n        self.mock_initialize = ldap_patcher.start()\n        self.mock_ldap = MockLDAP()\n        self.mock_initialize.return_value = self.mock_ldap\n        self.backend = ZulipLDAPAuthBackend()\n        # Internally `_realm` attribute is automatically set by the\n        # `authenticate()` method. But for testing the `get_or_create_user()`\n        # method separately, we need to set it manually.\n        self.backend._realm = get_realm('zulip')\n\n    def tearDown(self):\n        # type: () -> None\n        self.mock_ldap.reset()\n        self.mock_initialize.stop()\n\n    def setup_subdomain(self, user_profile):\n        # type: (UserProfile) -> None\n        realm = user_profile.realm\n        realm.string_id = 'zulip'\n        realm.save()\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',))\n    def test_login_success(self):\n        # type: () -> None\n        self.mock_ldap.directory = {\n            'uid=hamlet,ou=users,dc=zulip,dc=com': {\n                'userPassword': 'testing'\n            }\n        }\n        with self.settings(\n                LDAP_APPEND_DOMAIN='zulip.com',\n                AUTH_LDAP_BIND_PASSWORD='',\n                AUTH_LDAP_USER_DN_TEMPLATE='uid=%(user)s,ou=users,dc=zulip,dc=com'):\n            user_profile = self.backend.authenticate(self.example_email(\"hamlet\"), 'testing')\n\n            assert(user_profile is not None)\n            self.assertEqual(user_profile.email, self.example_email(\"hamlet\"))\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',))\n    def test_login_success_with_email_attr(self):\n        # type: () -> None\n        self.mock_ldap.directory = {\n            'uid=letham,ou=users,dc=zulip,dc=com': {\n                'userPassword': 'testing',\n                'email': ['hamlet@zulip.com'],\n            }\n        }\n        with self.settings(LDAP_EMAIL_ATTR='email',\n                           AUTH_LDAP_BIND_PASSWORD='',\n                           AUTH_LDAP_USER_DN_TEMPLATE='uid=%(user)s,ou=users,dc=zulip,dc=com'):\n            user_profile = self.backend.authenticate(\"letham\", 'testing')\n\n            assert (user_profile is not None)\n            self.assertEqual(user_profile.email, self.example_email(\"hamlet\"))\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',))\n    def test_login_failure_due_to_wrong_password(self):\n        # type: () -> None\n        self.mock_ldap.directory = {\n            'uid=hamlet,ou=users,dc=zulip,dc=com': {\n                'userPassword': 'testing'\n            }\n        }\n        with self.settings(\n                LDAP_APPEND_DOMAIN='zulip.com',\n                AUTH_LDAP_BIND_PASSWORD='',\n                AUTH_LDAP_USER_DN_TEMPLATE='uid=%(user)s,ou=users,dc=zulip,dc=com'):\n            user = self.backend.authenticate(self.example_email(\"hamlet\"), 'wrong')\n            self.assertIs(user, None)\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',))\n    def test_login_failure_due_to_nonexistent_user(self):\n        # type: () -> None\n        self.mock_ldap.directory = {\n            'uid=hamlet,ou=users,dc=zulip,dc=com': {\n                'userPassword': 'testing'\n            }\n        }\n        with self.settings(\n                LDAP_APPEND_DOMAIN='zulip.com',\n                AUTH_LDAP_BIND_PASSWORD='',\n                AUTH_LDAP_USER_DN_TEMPLATE='uid=%(user)s,ou=users,dc=zulip,dc=com'):\n            user = self.backend.authenticate('nonexistent@zulip.com', 'testing')\n            self.assertIs(user, None)\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',))\n    def test_ldap_permissions(self):\n        # type: () -> None\n        backend = self.backend\n        self.assertFalse(backend.has_perm(None, None))\n        self.assertFalse(backend.has_module_perms(None, None))\n        self.assertTrue(backend.get_all_permissions(None, None) == set())\n        self.assertTrue(backend.get_group_permissions(None, None) == set())\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',))\n    def test_django_to_ldap_username(self):\n        # type: () -> None\n        backend = self.backend\n        with self.settings(LDAP_APPEND_DOMAIN='zulip.com'):\n            username = backend.django_to_ldap_username('\"hamlet@test\"@zulip.com')\n            self.assertEqual(username, '\"hamlet@test\"')\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',))\n    def test_ldap_to_django_username(self):\n        # type: () -> None\n        backend = self.backend\n        with self.settings(LDAP_APPEND_DOMAIN='zulip.com'):\n            username = backend.ldap_to_django_username('\"hamlet@test\"')\n            self.assertEqual(username, '\"hamlet@test\"@zulip.com')\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',))\n    def test_get_or_create_user_when_user_exists(self):\n        # type: () -> None\n        class _LDAPUser(object):\n            attrs = {'fn': ['Full Name'], 'sn': ['Short Name']}\n\n        backend = self.backend\n        email = self.example_email(\"hamlet\")\n        user_profile, created = backend.get_or_create_user(str(email), _LDAPUser())\n        self.assertFalse(created)\n        self.assertEqual(user_profile.email, email)\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',))\n    def test_get_or_create_user_when_user_does_not_exist(self):\n        # type: () -> None\n        class _LDAPUser(object):\n            attrs = {'fn': ['Full Name'], 'sn': ['Short Name']}\n\n        ldap_user_attr_map = {'full_name': 'fn', 'short_name': 'sn'}\n\n        with self.settings(AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map):\n            backend = self.backend\n            email = 'nonexisting@zulip.com'\n            user_profile, created = backend.get_or_create_user(email, _LDAPUser())\n            self.assertTrue(created)\n            self.assertEqual(user_profile.email, email)\n            self.assertEqual(user_profile.full_name, 'Full Name')\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',))\n    def test_get_or_create_user_when_user_has_invalid_name(self):\n        # type: () -> None\n        class _LDAPUser(object):\n            attrs = {'fn': ['<invalid name>'], 'sn': ['Short Name']}\n\n        ldap_user_attr_map = {'full_name': 'fn', 'short_name': 'sn'}\n\n        with self.settings(AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map):\n            backend = self.backend\n            email = 'nonexisting@zulip.com'\n            with self.assertRaisesRegex(Exception, \"Invalid characters in name!\"):\n                backend.get_or_create_user(email, _LDAPUser())\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',))\n    def test_get_or_create_user_when_realm_is_deactivated(self):\n        # type: () -> None\n        class _LDAPUser(object):\n            attrs = {'fn': ['Full Name'], 'sn': ['Short Name']}\n\n        ldap_user_attr_map = {'full_name': 'fn', 'short_name': 'sn'}\n\n        with self.settings(AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map):\n            backend = self.backend\n            email = 'nonexisting@zulip.com'\n            do_deactivate_realm(backend._realm)\n            with self.assertRaisesRegex(Exception, 'Realm has been deactivated'):\n                backend.get_or_create_user(email, _LDAPUser())\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',))\n    def test_get_or_create_user_when_realm_is_none(self):\n        # type: () -> None\n        class _LDAPUser(object):\n            attrs = {'fn': ['Full Name'], 'sn': ['Short Name']}\n\n        ldap_user_attr_map = {'full_name': 'fn', 'short_name': 'sn'}\n\n        with self.settings(AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map):\n            backend = self.backend\n            email = 'nonexisting@zulip.com'\n            backend._realm = None\n            with self.assertRaisesRegex(Exception, 'Realm is None'):\n                backend.get_or_create_user(email, _LDAPUser())\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',))\n    def test_get_or_create_user_when_ldap_has_no_email_attr(self):\n        # type: () -> None\n        class _LDAPUser(object):\n            attrs = {'fn': ['Full Name'], 'sn': ['Short Name']}\n\n        nonexisting_attr = 'email'\n        with self.settings(LDAP_EMAIL_ATTR=nonexisting_attr):\n            backend = self.backend\n            email = 'nonexisting@zulip.com'\n            with self.assertRaisesRegex(Exception, 'LDAP user doesn\\'t have the needed email attribute'):\n                backend.get_or_create_user(email, _LDAPUser())\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',))\n    def test_django_to_ldap_username_when_domain_does_not_match(self):\n        # type: () -> None\n        backend = self.backend\n        email = self.example_email(\"hamlet\")\n        with self.assertRaisesRegex(Exception, 'Username does not match LDAP domain.'):\n            with self.settings(LDAP_APPEND_DOMAIN='acme.com'):\n                backend.django_to_ldap_username(email)\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',))\n    def test_login_failure_when_domain_does_not_match(self):\n        # type: () -> None\n        with self.settings(LDAP_APPEND_DOMAIN='acme.com'):\n            user_profile = self.backend.authenticate(self.example_email(\"hamlet\"), 'pass')\n            self.assertIs(user_profile, None)\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',))\n    def test_login_failure_due_to_wrong_subdomain(self):\n        # type: () -> None\n        self.mock_ldap.directory = {\n            'uid=hamlet,ou=users,dc=zulip,dc=com': {\n                'userPassword': 'testing'\n            }\n        }\n        with self.settings(\n                LDAP_APPEND_DOMAIN='zulip.com',\n                AUTH_LDAP_BIND_PASSWORD='',\n                AUTH_LDAP_USER_DN_TEMPLATE='uid=%(user)s,ou=users,dc=zulip,dc=com'):\n            user_profile = self.backend.authenticate(self.example_email(\"hamlet\"), 'testing',\n                                                     realm_subdomain='acme')\n            self.assertIs(user_profile, None)\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',))\n    def test_login_failure_due_to_empty_subdomain(self):\n        # type: () -> None\n        self.mock_ldap.directory = {\n            'uid=hamlet,ou=users,dc=zulip,dc=com': {\n                'userPassword': 'testing'\n            }\n        }\n        with self.settings(\n                LDAP_APPEND_DOMAIN='zulip.com',\n                AUTH_LDAP_BIND_PASSWORD='',\n                AUTH_LDAP_USER_DN_TEMPLATE='uid=%(user)s,ou=users,dc=zulip,dc=com'):\n            user_profile = self.backend.authenticate(self.example_email(\"hamlet\"), 'testing',\n                                                     realm_subdomain='')\n            self.assertIs(user_profile, None)\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',))\n    def test_login_success_when_subdomain_is_none(self):\n        # type: () -> None\n        self.mock_ldap.directory = {\n            'uid=hamlet,ou=users,dc=zulip,dc=com': {\n                'userPassword': 'testing'\n            }\n        }\n        with self.settings(\n                LDAP_APPEND_DOMAIN='zulip.com',\n                AUTH_LDAP_BIND_PASSWORD='',\n                AUTH_LDAP_USER_DN_TEMPLATE='uid=%(user)s,ou=users,dc=zulip,dc=com'):\n            user_profile = self.backend.authenticate(self.example_email(\"hamlet\"), 'testing',\n                                                     realm_subdomain=None)\n            assert(user_profile is not None)\n            self.assertEqual(user_profile.email, self.example_email(\"hamlet\"))\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',))\n    def test_login_success_with_valid_subdomain(self):\n        # type: () -> None\n        self.mock_ldap.directory = {\n            'uid=hamlet,ou=users,dc=zulip,dc=com': {\n                'userPassword': 'testing'\n            }\n        }\n        with self.settings(\n                LDAP_APPEND_DOMAIN='zulip.com',\n                AUTH_LDAP_BIND_PASSWORD='',\n                AUTH_LDAP_USER_DN_TEMPLATE='uid=%(user)s,ou=users,dc=zulip,dc=com'):\n            user_profile = self.backend.authenticate(self.example_email(\"hamlet\"), 'testing',\n                                                     realm_subdomain='zulip')\n            assert(user_profile is not None)\n            self.assertEqual(user_profile.email, self.example_email(\"hamlet\"))\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',))\n    def test_login_success_when_user_does_not_exist_with_valid_subdomain(self):\n        # type: () -> None\n        self.mock_ldap.directory = {\n            'uid=nonexisting,ou=users,dc=acme,dc=com': {\n                'cn': ['NonExisting', ],\n                'userPassword': 'testing'\n            }\n        }\n        with self.settings(\n                LDAP_APPEND_DOMAIN='acme.com',\n                AUTH_LDAP_BIND_PASSWORD='',\n                AUTH_LDAP_USER_DN_TEMPLATE='uid=%(user)s,ou=users,dc=acme,dc=com'):\n            user_profile = self.backend.authenticate('nonexisting@acme.com', 'testing',\n                                                     realm_subdomain='zulip')\n            assert(user_profile is not None)\n            self.assertEqual(user_profile.email, 'nonexisting@acme.com')\n            self.assertEqual(user_profile.full_name, 'NonExisting')\n            self.assertEqual(user_profile.realm.string_id, 'zulip')\n\nclass TestZulipLDAPUserPopulator(ZulipTestCase):\n    def test_authenticate(self):\n        # type: () -> None\n        backend = ZulipLDAPUserPopulator()\n        result = backend.authenticate(self.example_email(\"hamlet\"), 'testing')  # type: ignore # complains that the function does not return any value!\n        self.assertIs(result, None)\n\nclass TestZulipAuthMixin(ZulipTestCase):\n    def test_get_user(self):\n        # type: () -> None\n        backend = ZulipAuthMixin()\n        result = backend.get_user(11111)\n        self.assertIs(result, None)\n\nclass TestPasswordAuthEnabled(ZulipTestCase):\n    def test_password_auth_enabled_for_ldap(self):\n        # type: () -> None\n        with self.settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',)):\n            realm = Realm.objects.get(string_id='zulip')\n            self.assertTrue(password_auth_enabled(realm))\n\nclass TestRequireEmailFormatUsernames(ZulipTestCase):\n    def test_require_email_format_usernames_for_ldap_with_append_domain(self):\n        # type: () -> None\n        with self.settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',),\n                           LDAP_APPEND_DOMAIN=\"zulip.com\"):\n            realm = Realm.objects.get(string_id='zulip')\n            self.assertFalse(require_email_format_usernames(realm))\n\n    def test_require_email_format_usernames_for_ldap_with_email_attr(self):\n        # type: () -> None\n        with self.settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',),\n                           LDAP_EMAIL_ATTR=\"email\"):\n            realm = Realm.objects.get(string_id='zulip')\n            self.assertFalse(require_email_format_usernames(realm))\n\n    def test_require_email_format_usernames_for_email_only(self):\n        # type: () -> None\n        with self.settings(AUTHENTICATION_BACKENDS=('zproject.backends.EmailAuthBackend',)):\n            realm = Realm.objects.get(string_id='zulip')\n            self.assertTrue(require_email_format_usernames(realm))\n\n    def test_require_email_format_usernames_for_email_and_ldap_with_email_attr(self):\n        # type: () -> None\n        with self.settings(AUTHENTICATION_BACKENDS=('zproject.backends.EmailAuthBackend',\n                                                    'zproject.backends.ZulipLDAPAuthBackend'),\n                           LDAP_EMAIL_ATTR=\"email\"):\n            realm = Realm.objects.get(string_id='zulip')\n            self.assertFalse(require_email_format_usernames(realm))\n\n    def test_require_email_format_usernames_for_email_and_ldap_with_append_email(self):\n        # type: () -> None\n        with self.settings(AUTHENTICATION_BACKENDS=('zproject.backends.EmailAuthBackend',\n                                                    'zproject.backends.ZulipLDAPAuthBackend'),\n                           LDAP_APPEND_DOMAIN=\"zulip.com\"):\n            realm = Realm.objects.get(string_id='zulip')\n            self.assertFalse(require_email_format_usernames(realm))\n\nclass TestMaybeSendToRegistration(ZulipTestCase):\n    def test_sso_only_when_preregistration_user_does_not_exist(self):\n        # type: () -> None\n        rf = RequestFactory()\n        request = rf.get('/')\n        request.session = {}\n        request.user = None\n\n        # Creating a mock Django form in order to keep the test simple.\n        # This form will be returned by the create_hompage_form function\n        # and will always be valid so that the code that we want to test\n        # actually runs.\n        class Form(object):\n            def is_valid(self):\n                # type: () -> bool\n                return True\n\n        with self.settings(ONLY_SSO=True):\n            with mock.patch('zerver.views.auth.HomepageForm', return_value=Form()):\n                self.assertEqual(PreregistrationUser.objects.all().count(), 0)\n                result = maybe_send_to_registration(request, self.example_email(\"hamlet\"))\n                self.assertEqual(result.status_code, 302)\n                confirmation = Confirmation.objects.all().first()\n                confirmation_key = confirmation.confirmation_key\n                self.assertIn('do_confirm/' + confirmation_key, result.url)\n                self.assertEqual(PreregistrationUser.objects.all().count(), 1)\n\n        result = self.client_get(result.url)\n        self.assert_in_response('action=\"/accounts/register/\"', result)\n        self.assert_in_response('value=\"{0}\" name=\"key\"'.format(confirmation_key), result)\n\n    def test_sso_only_when_preregistration_user_exists(self):\n        # type: () -> None\n        rf = RequestFactory()\n        request = rf.get('/')\n        request.session = {}\n        request.user = None\n\n        # Creating a mock Django form in order to keep the test simple.\n        # This form will be returned by the create_hompage_form function\n        # and will always be valid so that the code that we want to test\n        # actually runs.\n        class Form(object):\n            def is_valid(self):\n                # type: () -> bool\n                return True\n\n        email = self.example_email(\"hamlet\")\n        user = PreregistrationUser(email=email)\n        user.save()\n\n        with self.settings(ONLY_SSO=True):\n            with mock.patch('zerver.views.auth.HomepageForm', return_value=Form()):\n                self.assertEqual(PreregistrationUser.objects.all().count(), 1)\n                result = maybe_send_to_registration(request, email)\n                self.assertEqual(result.status_code, 302)\n                confirmation = Confirmation.objects.all().first()\n                confirmation_key = confirmation.confirmation_key\n                self.assertIn('do_confirm/' + confirmation_key, result.url)\n                self.assertEqual(PreregistrationUser.objects.all().count(), 1)\n\nclass TestAdminSetBackends(ZulipTestCase):\n\n    def test_change_enabled_backends(self):\n        # type: () -> None\n        # Log in as admin\n        self.login(self.example_email(\"iago\"))\n        result = self.client_patch(\"/json/realm\", {\n            'authentication_methods': ujson.dumps({u'Email': False, u'Dev': True})})\n        self.assert_json_success(result)\n        realm = get_realm('zulip')\n        self.assertFalse(password_auth_enabled(realm))\n        self.assertTrue(dev_auth_enabled(realm))\n\n    def test_disable_all_backends(self):\n        # type: () -> None\n        # Log in as admin\n        self.login(self.example_email(\"iago\"))\n        result = self.client_patch(\"/json/realm\", {\n            'authentication_methods': ujson.dumps({u'Email': False, u'Dev': False})})\n        self.assert_json_error(result, 'At least one authentication method must be enabled.')\n        realm = get_realm('zulip')\n        self.assertTrue(password_auth_enabled(realm))\n        self.assertTrue(dev_auth_enabled(realm))\n\n    def test_supported_backends_only_updated(self):\n        # type: () -> None\n        # Log in as admin\n        self.login(self.example_email(\"iago\"))\n        # Set some supported and unsupported backends\n        result = self.client_patch(\"/json/realm\", {\n            'authentication_methods': ujson.dumps({u'Email': False, u'Dev': True, u'GitHub': False})})\n        self.assert_json_success(result)\n        realm = get_realm('zulip')\n        # Check that unsupported backend is not enabled\n        self.assertFalse(github_auth_enabled(realm))\n        self.assertTrue(dev_auth_enabled(realm))\n        self.assertFalse(password_auth_enabled(realm))\n\nclass LoginEmailValidatorTestCase(ZulipTestCase):\n    def test_valid_email(self):\n        # type: () -> None\n        validate_login_email(self.example_email(\"hamlet\"))\n\n    def test_invalid_email(self):\n        # type: () -> None\n        with self.assertRaises(JsonableError):\n            validate_login_email(u'hamlet')\n\nclass LoginOrRegisterRemoteUserTestCase(ZulipTestCase):\n    def test_invalid_subdomain(self):\n        # type: () -> None\n        full_name = 'Hamlet'\n        invalid_subdomain = True\n        user_profile = self.example_user('hamlet')\n        request = POSTRequestMock({}, user_profile)\n        response = login_or_register_remote_user(\n            request,\n            self.example_email('hamlet'),\n            user_profile,\n            full_name=full_name,\n            invalid_subdomain=invalid_subdomain)\n        self.assertIn('/accounts/login/?subdomain=1', response.url)\n\nclass LDAPBackendTest(ZulipTestCase):\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',))\n    def test_non_existing_realm(self):\n        # type: () -> None\n        email = self.example_email('hamlet')\n        data = {'username': email, 'password': initial_password(email)}\n        error_type = ZulipLDAPAuthBackend.REALM_IS_NONE_ERROR\n        error = ZulipLDAPConfigurationError('Realm is None', error_type)\n        with mock.patch('zproject.backends.ZulipLDAPAuthBackend.get_or_create_user',\n                        side_effect=error), \\\n                mock.patch('django_auth_ldap.backend._LDAPUser._authenticate_user_dn'):\n            response = self.client_post('/login/', data)\n            self.assertEqual(response.status_code, 302)\n            self.assertEqual(response.url, reverse('ldap_error_realm_is_none'))\n            response = self.client_get(response.url)\n            self.assert_in_response('You are trying to login using LDAP '\n                                    'without creating an',\n                                    response)\n", "# -*- coding: utf-8 -*-\n\nimport datetime\nfrom typing import Any\n\nimport django\nimport mock\nfrom django.conf import settings\nfrom django.core import mail\nfrom django.http import HttpResponse\nfrom django.urls import reverse\nfrom django.utils.timezone import now\n\nfrom confirmation.models import Confirmation, generate_key, confirmation_url\nfrom zerver.lib.actions import do_start_email_change_process, do_set_realm_property\nfrom zerver.lib.test_classes import (\n    ZulipTestCase,\n)\nfrom zerver.lib.send_email import FromAddress\nfrom zerver.models import get_user, EmailChangeStatus, Realm, get_realm\n\n\nclass EmailChangeTestCase(ZulipTestCase):\n    def test_confirm_email_change_with_non_existent_key(self):\n        # type: () -> None\n        self.login(self.example_email(\"hamlet\"))\n        key = generate_key()\n        url = confirmation_url(key, 'testserver', Confirmation.EMAIL_CHANGE)\n        response = self.client_get(url)\n        self.assert_in_success_response([\"Whoops. We couldn't find your confirmation link in the system.\"], response)\n\n    def test_confirm_email_change_with_invalid_key(self):\n        # type: () -> None\n        self.login(self.example_email(\"hamlet\"))\n        key = 'invalid key'\n        url = confirmation_url(key, 'testserver', Confirmation.EMAIL_CHANGE)\n        response = self.client_get(url)\n        self.assert_in_success_response([\"Whoops. The confirmation link is malformed.\"], response)\n\n    def test_email_change_when_not_logging_in(self):\n        # type: () -> None\n        key = generate_key()\n        url = confirmation_url(key, 'testserver', Confirmation.EMAIL_CHANGE)\n        response = self.client_get(url)\n        self.assertEqual(response.status_code, 302)\n\n    def test_confirm_email_change_when_time_exceeded(self):\n        # type: () -> None\n        user_profile = self.example_user('hamlet')\n        old_email = user_profile.email\n        new_email = 'hamlet-new@zulip.com'\n        self.login(self.example_email(\"hamlet\"))\n        obj = EmailChangeStatus.objects.create(new_email=new_email,\n                                               old_email=old_email,\n                                               user_profile=user_profile,\n                                               realm=user_profile.realm)\n        key = generate_key()\n        date_sent = now() - datetime.timedelta(days=2)\n        Confirmation.objects.create(content_object=obj,\n                                    date_sent=date_sent,\n                                    confirmation_key=key,\n                                    type=Confirmation.EMAIL_CHANGE)\n        url = confirmation_url(key, user_profile.realm.host, Confirmation.EMAIL_CHANGE)\n        response = self.client_get(url)\n        self.assert_in_success_response([\"The confirmation link has expired or been deactivated.\"], response)\n\n    def test_confirm_email_change(self):\n        # type: () -> None\n        user_profile = self.example_user('hamlet')\n        old_email = user_profile.email\n        new_email = 'hamlet-new@zulip.com'\n        new_realm = get_realm('zulip')\n        self.login(self.example_email('hamlet'))\n        obj = EmailChangeStatus.objects.create(new_email=new_email,\n                                               old_email=old_email,\n                                               user_profile=user_profile,\n                                               realm=user_profile.realm)\n        key = generate_key()\n        Confirmation.objects.create(content_object=obj,\n                                    date_sent=now(),\n                                    confirmation_key=key,\n                                    type=Confirmation.EMAIL_CHANGE)\n        url = confirmation_url(key, user_profile.realm.host, Confirmation.EMAIL_CHANGE)\n        response = self.client_get(url)\n\n        self.assertEqual(response.status_code, 200)\n        self.assert_in_success_response([\"This confirms that the email address for your Zulip\"],\n                                        response)\n        user_profile = get_user(new_email, new_realm)\n        self.assertTrue(bool(user_profile))\n        obj.refresh_from_db()\n        self.assertEqual(obj.status, 1)\n\n    def test_start_email_change_process(self):\n        # type: () -> None\n        user_profile = self.example_user('hamlet')\n        do_start_email_change_process(user_profile, 'hamlet-new@zulip.com')\n        self.assertEqual(EmailChangeStatus.objects.count(), 1)\n\n    def test_end_to_end_flow(self):\n        # type: () -> None\n        data = {'email': 'hamlet-new@zulip.com'}\n        email = self.example_email(\"hamlet\")\n        self.login(email)\n        url = '/json/settings'\n        self.assertEqual(len(mail.outbox), 0)\n        result = self.client_patch(url, data)\n        self.assertEqual(len(mail.outbox), 1)\n        self.assert_in_success_response(['Check your email for a confirmation link.'], result)\n        email_message = mail.outbox[0]\n        self.assertEqual(\n            email_message.subject,\n            'Verify your new email address'\n        )\n        body = email_message.body\n        from_email = email_message.from_email\n        self.assertIn('We received a request to change the email', body)\n        self.assertIn('Zulip Account Security', from_email)\n        self.assertIn(FromAddress.NOREPLY, email_message.from_email)\n\n        activation_url = [s for s in body.split('\\n') if s][4]\n        response = self.client_get(activation_url)\n\n        self.assert_in_success_response([\"This confirms that the email address\"],\n                                        response)\n\n        # Now confirm trying to change your email back doesn't throw an immediate error\n        result = self.client_patch(url, {\"email\": \"hamlet@zulip.com\"})\n        self.assert_in_success_response(['Check your email for a confirmation link.'], result)\n\n    def test_unauthorized_email_change(self):\n        # type: () -> None\n        data = {'email': 'hamlet-new@zulip.com'}\n        user_profile = self.example_user('hamlet')\n        email = user_profile.email\n        self.login(email)\n        do_set_realm_property(user_profile.realm, 'email_changes_disabled', True)\n        url = '/json/settings'\n        result = self.client_patch(url, data)\n        self.assertEqual(len(mail.outbox), 0)\n        self.assertEqual(result.status_code, 400)\n        self.assert_in_response(\"Email address changes are disabled in this organization.\",\n                                result)\n\n    def test_email_change_already_taken(self):\n        # type: () -> None\n        data = {'email': 'cordelia@zulip.com'}\n        user_profile = self.example_user('hamlet')\n        email = user_profile.email\n        self.login(email)\n\n        url = '/json/settings'\n        result = self.client_patch(url, data)\n        self.assertEqual(len(mail.outbox), 0)\n        self.assertEqual(result.status_code, 400)\n        self.assert_in_response(\"Already has an account\",\n                                result)\n\n    def test_unauthorized_email_change_from_email_confirmation_link(self):\n        # type: () -> None\n        data = {'email': 'hamlet-new@zulip.com'}\n        user_profile = self.example_user('hamlet')\n        email = user_profile.email\n        self.login(email)\n        url = '/json/settings'\n        self.assertEqual(len(mail.outbox), 0)\n        result = self.client_patch(url, data)\n        self.assertEqual(len(mail.outbox), 1)\n        self.assert_in_success_response(['Check your email for a confirmation link.'], result)\n        email_message = mail.outbox[0]\n        self.assertEqual(\n            email_message.subject,\n            'Verify your new email address'\n        )\n        body = email_message.body\n        self.assertIn('We received a request to change the email', body)\n\n        do_set_realm_property(user_profile.realm, 'email_changes_disabled', True)\n\n        activation_url = [s for s in body.split('\\n') if s][4]\n        response = self.client_get(activation_url)\n\n        self.assertEqual(response.status_code, 400)\n        self.assert_in_response(\"Email address changes are disabled in this organization.\",\n                                response)\n\n    def test_post_invalid_email(self):\n        # type: () -> None\n        data = {'email': 'hamlet-new'}\n        email = self.example_email(\"hamlet\")\n        self.login(email)\n        url = '/json/settings'\n        result = self.client_patch(url, data)\n        self.assert_in_response('Invalid address', result)\n\n    def test_post_same_email(self):\n        # type: () -> None\n        data = {'email': self.example_email(\"hamlet\")}\n        email = self.example_email(\"hamlet\")\n        self.login(email)\n        url = '/json/settings'\n        result = self.client_patch(url, data)\n        self.assertEqual('success', result.json()['result'])\n        self.assertEqual('', result.json()['msg'])\n", "# -*- coding: utf-8 -*-\nimport datetime\nfrom django.conf import settings\nfrom django.contrib.contenttypes.models import ContentType\nfrom django.contrib.sites.models import Site\nfrom django.http import HttpResponse\nfrom django.test import TestCase, override_settings\nfrom django.utils.timezone import now as timezone_now\n\nfrom mock import patch, MagicMock\nfrom zerver.lib.test_helpers import MockLDAP\n\nfrom confirmation.models import Confirmation, create_confirmation_link, MultiuseInvite, \\\n    generate_key, confirmation_url\n\nfrom zerver.forms import HomepageForm, WRONG_SUBDOMAIN_ERROR\nfrom zerver.lib.actions import do_change_password, gather_subscriptions\nfrom zerver.views.auth import login_or_register_remote_user\nfrom zerver.views.invite import get_invitee_emails_set\nfrom zerver.views.registration import confirmation_key, \\\n    redirect_and_log_into_subdomain, send_registration_completion_email\n\nfrom zerver.models import (\n    get_realm, get_prereg_user_by_email, get_user, get_recipient,\n    PreregistrationUser, Realm, RealmDomain, Recipient, Message,\n    ScheduledEmail, UserProfile, UserMessage,\n    Stream, Subscription, flush_per_request_caches\n)\nfrom zerver.lib.actions import (\n    set_default_streams,\n    do_change_is_admin,\n    get_stream,\n    do_create_realm,\n)\nfrom zerver.lib.send_email import send_email, send_future_email, FromAddress\nfrom zerver.lib.initial_password import initial_password\nfrom zerver.lib.actions import (\n    do_deactivate_realm,\n    do_deactivate_user,\n    do_set_realm_property,\n    add_new_user_history,\n)\nfrom zerver.lib.mobile_auth_otp import xor_hex_strings, ascii_to_hex, \\\n    otp_encrypt_api_key, is_valid_otp, hex_to_ascii, otp_decrypt_api_key\nfrom zerver.lib.notifications import enqueue_welcome_emails, \\\n    one_click_unsubscribe_link\nfrom zerver.lib.subdomains import is_root_domain_available\nfrom zerver.lib.test_helpers import find_pattern_in_email, find_key_by_email, queries_captured, \\\n    HostRequestMock, unsign_subdomain_cookie\nfrom zerver.lib.test_classes import (\n    ZulipTestCase,\n)\nfrom zerver.lib.test_runner import slow\nfrom zerver.lib.sessions import get_session_dict_user\nfrom zerver.context_processors import common_context\n\nfrom collections import defaultdict\nimport re\nimport smtplib\nimport ujson\n\nfrom typing import Any, Dict, List, Optional, Set, Text\n\nfrom six.moves import urllib, range, zip\nimport os\n\nclass RedirectAndLogIntoSubdomainTestCase(ZulipTestCase):\n    def test_cookie_data(self):\n        # type: () -> None\n        realm = Realm.objects.all().first()\n        name = 'Hamlet'\n        email = self.example_email(\"hamlet\")\n        response = redirect_and_log_into_subdomain(realm, name, email)\n        data = unsign_subdomain_cookie(response)\n        self.assertDictEqual(data, {'name': name, 'email': email,\n                                    'subdomain': realm.subdomain,\n                                    'is_signup': False})\n\n        response = redirect_and_log_into_subdomain(realm, name, email,\n                                                   is_signup=True)\n        data = unsign_subdomain_cookie(response)\n        self.assertDictEqual(data, {'name': name, 'email': email,\n                                    'subdomain': realm.subdomain,\n                                    'is_signup': True})\n\nclass DeactivationNoticeTestCase(ZulipTestCase):\n    def test_redirection_for_deactivated_realm(self):\n        # type: () -> None\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.save(update_fields=[\"deactivated\"])\n\n        for url in ('/register/', '/login/'):\n            result = self.client_get(url)\n            self.assertEqual(result.status_code, 302)\n            self.assertIn('deactivated', result.url)\n\n    def test_redirection_for_active_realm(self):\n        # type: () -> None\n        for url in ('/register/', '/login/'):\n            result = self.client_get(url)\n            self.assertEqual(result.status_code, 200)\n\n    def test_deactivation_notice_when_realm_is_active(self):\n        # type: () -> None\n        result = self.client_get('/accounts/deactivated/')\n        self.assertEqual(result.status_code, 302)\n        self.assertIn('login', result.url)\n\n    def test_deactivation_notice_when_deactivated(self):\n        # type: () -> None\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.save(update_fields=[\"deactivated\"])\n\n        result = self.client_get('/accounts/deactivated/')\n        self.assertIn(\"Zulip Dev, has been deactivated.\", result.content.decode())\n\nclass AddNewUserHistoryTest(ZulipTestCase):\n    def test_add_new_user_history_race(self):\n        # type: () -> None\n        \"\"\"Sends a message during user creation\"\"\"\n        # Create a user who hasn't had historical messages added\n        stream_dict = {\n            \"Denmark\": {\"description\": \"A Scandinavian country\", \"invite_only\": False},\n            \"Verona\": {\"description\": \"A city in Italy\", \"invite_only\": False}\n        }  # type: Dict[Text, Dict[Text, Any]]\n        realm = get_realm('zulip')\n        set_default_streams(realm, stream_dict)\n        with patch(\"zerver.lib.actions.add_new_user_history\"):\n            self.register(self.nonreg_email('test'), \"test\")\n        user_profile = self.nonreg_user('test')\n\n        subs = Subscription.objects.select_related(\"recipient\").filter(\n            user_profile=user_profile, recipient__type=Recipient.STREAM)\n        streams = Stream.objects.filter(id__in=[sub.recipient.type_id for sub in subs])\n        self.send_message(self.example_email('hamlet'), streams[0].name, Recipient.STREAM, \"test\")\n        add_new_user_history(user_profile, streams)\n\nclass PasswordResetTest(ZulipTestCase):\n    \"\"\"\n    Log in, reset password, log out, log in with new password.\n    \"\"\"\n\n    def test_password_reset(self):\n        # type: () -> None\n        email = self.example_email(\"hamlet\")\n        old_password = initial_password(email)\n\n        self.login(email)\n\n        # test password reset template\n        result = self.client_get('/accounts/password/reset/')\n        self.assert_in_response('Reset your password', result)\n\n        # start the password reset process by supplying an email address\n        result = self.client_post('/accounts/password/reset/', {'email': email})\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email to finish the process.\", result)\n\n        # Check that the password reset email is from a noreply address.\n        from django.core.mail import outbox\n        from_email = outbox[0].from_email\n        self.assertIn(\"Zulip Account Security\", from_email)\n        self.assertIn(FromAddress.NOREPLY, from_email)\n\n        # Visit the password reset link.\n        password_reset_url = self.get_confirmation_url_from_outbox(email, \"(\\S+)\")\n        result = self.client_get(password_reset_url)\n        self.assertEqual(result.status_code, 200)\n\n        # Reset your password\n        result = self.client_post(password_reset_url,\n                                  {'new_password1': 'new_password',\n                                   'new_password2': 'new_password'})\n\n        # password reset succeeded\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\"/password/done/\"))\n\n        # log back in with new password\n        self.login(email, password='new_password')\n        user_profile = self.example_user('hamlet')\n        self.assertEqual(get_session_dict_user(self.client.session), user_profile.id)\n\n        # make sure old password no longer works\n        self.login(email, password=old_password, fails=True)\n\n    def test_invalid_subdomain(self):\n        # type: () -> None\n        email = self.example_email(\"hamlet\")\n        string_id = 'hamlet'\n        name = 'Hamlet'\n        do_create_realm(\n            string_id,\n            name,\n            restricted_to_domain=False,\n            invite_required=False\n        )\n\n        with patch('zerver.forms.get_subdomain', return_value=string_id):\n            # start the password reset process by supplying an email address\n            result = self.client_post(\n                '/accounts/password/reset/', {'email': email})\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email to finish the process.\", result)\n\n        from django.core.mail import outbox\n        self.assertEqual(len(outbox), 1)\n        message = outbox.pop()\n        self.assertIn(FromAddress.NOREPLY, message.from_email)\n        self.assertIn(\"hamlet@zulip.com does not\\nhave an active account in http://\",\n                      message.body)\n\n    def test_correct_subdomain(self):\n        # type: () -> None\n        email = self.example_email(\"hamlet\")\n        string_id = 'zulip'\n\n        with patch('zerver.forms.get_subdomain', return_value=string_id):\n            # start the password reset process by supplying an email address\n            result = self.client_post(\n                '/accounts/password/reset/', {'email': email})\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email to finish the process.\", result)\n\n        from django.core.mail import outbox\n        self.assertEqual(len(outbox), 1)\n        message = outbox.pop()\n        self.assertIn(\"Zulip Account Security\", message.from_email)\n        self.assertIn(FromAddress.NOREPLY, message.from_email)\n        self.assertIn(\"Psst. Word on the street is that you\",\n                      message.body)\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',\n                                                'zproject.backends.ZulipDummyBackend'))\n    def test_ldap_auth_only(self):\n        # type: () -> None\n        \"\"\"If the email auth backend is not enabled, password reset should do nothing\"\"\"\n        email = self.example_email(\"hamlet\")\n        result = self.client_post('/accounts/password/reset/', {'email': email})\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email to finish the process.\", result)\n\n        from django.core.mail import outbox\n        self.assertEqual(len(outbox), 0)\n\n    def test_redirect_endpoints(self):\n        # type: () -> None\n        '''\n        These tests are mostly designed to give us 100% URL coverage\n        in our URL coverage reports.  Our mechanism for finding URL\n        coverage doesn't handle redirects, so we just have a few quick\n        tests here.\n        '''\n        result = self.client_get('/accounts/password/reset/done/')\n        self.assert_in_success_response([\"Check your email\"], result)\n\n        result = self.client_get('/accounts/password/done/')\n        self.assert_in_success_response([\"We've reset your password!\"], result)\n\n        result = self.client_get('/accounts/send_confirm/alice@example.com')\n        self.assert_in_success_response([\"Still no email?\"], result)\n\nclass LoginTest(ZulipTestCase):\n    \"\"\"\n    Logging in, registration, and logging out.\n    \"\"\"\n\n    def test_login(self):\n        # type: () -> None\n        self.login(self.example_email(\"hamlet\"))\n        user_profile = self.example_user('hamlet')\n        self.assertEqual(get_session_dict_user(self.client.session), user_profile.id)\n\n    def test_login_bad_password(self):\n        # type: () -> None\n        self.login(self.example_email(\"hamlet\"), password=\"wrongpassword\", fails=True)\n        self.assertIsNone(get_session_dict_user(self.client.session))\n\n    def test_login_nonexist_user(self):\n        # type: () -> None\n        result = self.login_with_return(\"xxx@zulip.com\", \"xxx\")\n        self.assert_in_response(\"Please enter a correct email and password\", result)\n\n    def test_register(self):\n        # type: () -> None\n        realm = get_realm(\"zulip\")\n        stream_dict = {\"stream_\"+str(i): {\"description\": \"stream_%s_description\" % i, \"invite_only\": False}\n                       for i in range(40)}  # type: Dict[Text, Dict[Text, Any]]\n        for stream_name in stream_dict.keys():\n            self.make_stream(stream_name, realm=realm)\n\n        set_default_streams(realm, stream_dict)\n        # Clear all the caches.\n        flush_per_request_caches()\n        ContentType.objects.clear_cache()\n        Site.objects.clear_cache()\n\n        with queries_captured() as queries:\n            self.register(self.nonreg_email('test'), \"test\")\n        # Ensure the number of queries we make is not O(streams)\n        self.assert_length(queries, 70)\n        user_profile = self.nonreg_user('test')\n        self.assertEqual(get_session_dict_user(self.client.session), user_profile.id)\n        self.assertFalse(user_profile.enable_stream_desktop_notifications)\n\n    def test_register_deactivated(self):\n        # type: () -> None\n        \"\"\"\n        If you try to register for a deactivated realm, you get a clear error\n        page.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.save(update_fields=[\"deactivated\"])\n\n        result = self.client_post('/accounts/home/', {'email': self.nonreg_email('test')},\n                                  subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual('/accounts/deactivated/', result.url)\n\n        with self.assertRaises(UserProfile.DoesNotExist):\n            self.nonreg_user('test')\n\n    def test_register_deactivated_partway_through(self):\n        # type: () -> None\n        \"\"\"\n        If you try to register for a deactivated realm, you get a clear error\n        page.\n        \"\"\"\n        email = self.nonreg_email('test')\n        result = self.client_post('/accounts/home/', {'email': email},\n                                  subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 302)\n        print(result.url)\n        self.assertNotIn('deactivated', result.url)\n\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.save(update_fields=[\"deactivated\"])\n\n        result = self.submit_reg_form_for_user(email, \"abcd1234\", subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual('/accounts/deactivated/', result.url)\n\n        with self.assertRaises(UserProfile.DoesNotExist):\n            self.nonreg_user('test')\n\n    def test_login_deactivated(self):\n        # type: () -> None\n        \"\"\"\n        If you try to log in to a deactivated realm, you get a clear error page.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.save(update_fields=[\"deactivated\"])\n\n        result = self.login_with_return(self.example_email(\"hamlet\"), subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual('/accounts/deactivated/', result.url)\n\n    def test_logout(self):\n        # type: () -> None\n        self.login(self.example_email(\"hamlet\"))\n        # We use the logout API, not self.logout, to make sure we test\n        # the actual logout code path.\n        self.client_post('/accounts/logout/')\n        self.assertIsNone(get_session_dict_user(self.client.session))\n\n    def test_non_ascii_login(self):\n        # type: () -> None\n        \"\"\"\n        You can log in even if your password contain non-ASCII characters.\n        \"\"\"\n        email = self.nonreg_email('test')\n        password = u\"h\u00c3\u00bcmb\u00c3\u00bc\u00c7\u00b5\"\n\n        # Registering succeeds.\n        self.register(email, password)\n        user_profile = self.nonreg_user('test')\n        self.assertEqual(get_session_dict_user(self.client.session), user_profile.id)\n        self.logout()\n        self.assertIsNone(get_session_dict_user(self.client.session))\n\n        # Logging in succeeds.\n        self.logout()\n        self.login(email, password)\n        self.assertEqual(get_session_dict_user(self.client.session), user_profile.id)\n\n    def test_login_page_redirects_logged_in_user(self):\n        # type: () -> None\n        \"\"\"You will be redirected to the app's main page if you land on the\n        login page when already logged in.\n        \"\"\"\n        self.login(self.example_email(\"cordelia\"))\n        response = self.client_get(\"/login/\")\n        self.assertEqual(response[\"Location\"], \"http://zulip.testserver\")\n\nclass InviteUserTest(ZulipTestCase):\n\n    def invite(self, users, streams, body=''):\n        # type: (Text, List[Text], str) -> HttpResponse\n        \"\"\"\n        Invites the specified users to Zulip with the specified streams.\n\n        users should be a string containing the users to invite, comma or\n            newline separated.\n\n        streams should be a list of strings.\n        \"\"\"\n\n        return self.client_post(\"/json/invites\",\n                                {\"invitee_emails\": users,\n                                 \"stream\": streams,\n                                 \"custom_body\": body})\n\n    def check_sent_emails(self, correct_recipients, custom_body=None, custom_from_name=None):\n        # type: (List[Text], Optional[str], Optional[str]) -> None\n        from django.core.mail import outbox\n        self.assertEqual(len(outbox), len(correct_recipients))\n        email_recipients = [email.recipients()[0] for email in outbox]\n        self.assertEqual(sorted(email_recipients), sorted(correct_recipients))\n        if len(outbox) == 0:\n            return\n\n        if custom_body is None:\n            self.assertNotIn(\"Message from\", outbox[0].body)\n        else:\n            self.assertIn(\"Message from \", outbox[0].body)\n            self.assertIn(custom_body, outbox[0].body)\n\n        if custom_from_name is not None:\n            self.assertIn(custom_from_name, outbox[0].from_email)\n\n        self.assertIn(FromAddress.NOREPLY, outbox[0].from_email)\n\n    def test_successful_invite_user(self):\n        # type: () -> None\n        \"\"\"\n        A call to /json/invites with valid parameters causes an invitation\n        email to be sent.\n        \"\"\"\n        self.login(self.example_email(\"hamlet\"))\n        invitee = \"alice-test@zulip.com\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(invitee))\n        self.check_sent_emails([invitee], custom_from_name=\"Hamlet\")\n\n    def test_successful_invite_user_with_custom_body(self):\n        # type: () -> None\n        \"\"\"\n        A call to /json/invites with valid parameters causes an invitation\n        email to be sent.\n        \"\"\"\n        self.login(self.example_email(\"hamlet\"))\n        invitee = \"alice-test@zulip.com\"\n        body = \"Custom Text.\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"], body))\n        self.assertTrue(find_pattern_in_email(invitee, body))\n        self.check_sent_emails([invitee], custom_body=body, custom_from_name=\"Hamlet\")\n\n    def test_successful_invite_user_with_name(self):\n        # type: () -> None\n        \"\"\"\n        A call to /json/invites with valid parameters causes an invitation\n        email to be sent.\n        \"\"\"\n        self.login(self.example_email(\"hamlet\"))\n        email = \"alice-test@zulip.com\"\n        invitee = \"Alice Test <{}>\".format(email)\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.check_sent_emails([email], custom_from_name=\"Hamlet\")\n\n    def test_successful_invite_user_with_name_and_normal_one(self):\n        # type: () -> None\n        \"\"\"\n        A call to /json/invites with valid parameters causes an invitation\n        email to be sent.\n        \"\"\"\n        self.login(self.example_email(\"hamlet\"))\n        email = \"alice-test@zulip.com\"\n        email2 = \"bob-test@zulip.com\"\n        invitee = \"Alice Test <{}>, {}\".format(email, email2)\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.assertTrue(find_key_by_email(email2))\n        self.check_sent_emails([email, email2], custom_from_name=\"Hamlet\")\n\n    def test_require_realm_admin(self):\n        # type: () -> None\n        \"\"\"\n        The invite_by_admins_only realm setting works properly.\n        \"\"\"\n        realm = get_realm('zulip')\n        realm.invite_by_admins_only = True\n        realm.save()\n\n        self.login(\"hamlet@zulip.com\")\n        email = \"alice-test@zulip.com\"\n        email2 = \"bob-test@zulip.com\"\n        invitee = \"Alice Test <{}>, {}\".format(email, email2)\n        self.assert_json_error(self.invite(invitee, [\"Denmark\"]),\n                               \"Must be a realm administrator\")\n\n        # Now verify an administrator can do it\n        self.login(\"iago@zulip.com\")\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.assertTrue(find_key_by_email(email2))\n        self.check_sent_emails([email, email2])\n\n    def test_successful_invite_user_with_notifications_stream(self):\n        # type: () -> None\n        \"\"\"\n        A call to /json/invites with valid parameters unconditionally\n        subscribes the invitee to the notifications stream if it exists and is\n        public.\n        \"\"\"\n        realm = get_realm('zulip')\n        notifications_stream = get_stream('Verona', realm)\n        realm.notifications_stream_id = notifications_stream.id\n        realm.save()\n\n        self.login(self.example_email(\"hamlet\"))\n        invitee = 'alice-test@zulip.com'\n        self.assert_json_success(self.invite(invitee, ['Denmark']))\n        self.assertTrue(find_key_by_email(invitee))\n        self.check_sent_emails([invitee])\n\n        prereg_user = get_prereg_user_by_email(invitee)\n        stream_ids = [stream.id for stream in prereg_user.streams.all()]\n        self.assertTrue(notifications_stream.id in stream_ids)\n\n    def test_invite_user_signup_initial_history(self):\n        # type: () -> None\n        \"\"\"\n        Test that a new user invited to a stream receives some initial\n        history but only from public streams.\n        \"\"\"\n        self.login(self.example_email('hamlet'))\n        user_profile = self.example_user('hamlet')\n        private_stream_name = \"Secret\"\n        self.make_stream(private_stream_name, invite_only=True)\n        self.subscribe(user_profile, private_stream_name)\n        public_msg_id = self.send_message(self.example_email(\"hamlet\"), \"Denmark\", Recipient.STREAM,\n                                          \"Public topic\", \"Public message\")\n        secret_msg_id = self.send_message(self.example_email(\"hamlet\"), private_stream_name, Recipient.STREAM,\n                                          \"Secret topic\", \"Secret message\")\n        invitee = self.nonreg_email('alice')\n        self.assert_json_success(self.invite(invitee, [private_stream_name, \"Denmark\"]))\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user('alice')\n        invitee_msg_ids = [um.message_id for um in\n                           UserMessage.objects.filter(user_profile=invitee_profile)]\n        self.assertTrue(public_msg_id in invitee_msg_ids)\n        self.assertFalse(secret_msg_id in invitee_msg_ids)\n\n        # Test that exactly 2 new Zulip messages were sent, both notifications.\n        last_3_messages = list(reversed(list(Message.objects.all().order_by(\"-id\")[0:3])))\n        first_msg = last_3_messages[0]\n        self.assertEqual(first_msg.id, secret_msg_id)\n\n        # The first, from notification-bot to the user who invited the new user.\n        second_msg = last_3_messages[1]\n        self.assertEqual(second_msg.sender.email, \"notification-bot@zulip.com\")\n        self.assertTrue(second_msg.content.startswith(\"alice_zulip.com <`alice@zulip.com`> accepted your\"))\n\n        # The second, from welcome-bot to the user who was invited.\n        third_msg = last_3_messages[2]\n        self.assertEqual(third_msg.sender.email, \"welcome-bot@zulip.com\")\n        self.assertTrue(third_msg.content.startswith(\"Hello, and welcome to Zulip!\"))\n\n    def test_multi_user_invite(self):\n        # type: () -> None\n        \"\"\"\n        Invites multiple users with a variety of delimiters.\n        \"\"\"\n        self.login(self.example_email(\"hamlet\"))\n        # Intentionally use a weird string.\n        self.assert_json_success(self.invite(\n            \"\"\"bob-test@zulip.com,     carol-test@zulip.com,\n            dave-test@zulip.com\n\n\nearl-test@zulip.com\"\"\", [\"Denmark\"]))\n        for user in (\"bob\", \"carol\", \"dave\", \"earl\"):\n            self.assertTrue(find_key_by_email(\"%s-test@zulip.com\" % (user,)))\n        self.check_sent_emails([\"bob-test@zulip.com\", \"carol-test@zulip.com\",\n                                \"dave-test@zulip.com\", \"earl-test@zulip.com\"])\n\n    def test_missing_or_invalid_params(self):\n        # type: () -> None\n        \"\"\"\n        Tests inviting with various missing or invalid parameters.\n        \"\"\"\n        self.login(self.example_email(\"hamlet\"))\n        self.assert_json_error(\n            self.client_post(\"/json/invites\",\n                             {\"invitee_emails\": \"foo@zulip.com\",\n                              \"custom_body\": ''}),\n            \"You must specify at least one stream for invitees to join.\")\n\n        for address in (\"noatsign.com\", \"outsideyourdomain@example.net\"):\n            self.assert_json_error(\n                self.invite(address, [\"Denmark\"]),\n                \"Some emails did not validate, so we didn't send any invitations.\")\n        self.check_sent_emails([])\n\n        self.assert_json_error(\n            self.invite(\"\", [\"Denmark\"]),\n            \"You must specify at least one email address.\")\n        self.check_sent_emails([])\n\n    def test_invalid_stream(self):\n        # type: () -> None\n        \"\"\"\n        Tests inviting to a non-existent stream.\n        \"\"\"\n        self.login(self.example_email(\"hamlet\"))\n        self.assert_json_error(self.invite(\"iago-test@zulip.com\", [\"NotARealStream\"]),\n                               \"Stream does not exist: NotARealStream. No invites were sent.\")\n        self.check_sent_emails([])\n\n    def test_invite_existing_user(self):\n        # type: () -> None\n        \"\"\"\n        If you invite an address already using Zulip, no invitation is sent.\n        \"\"\"\n        self.login(self.example_email(\"hamlet\"))\n        self.assert_json_error(\n            self.client_post(\"/json/invites\",\n                             {\"invitee_emails\": self.example_email(\"hamlet\"),\n                              \"stream\": [\"Denmark\"],\n                              \"custom_body\": ''}),\n            \"We weren't able to invite anyone.\")\n        self.assertRaises(PreregistrationUser.DoesNotExist,\n                          lambda: PreregistrationUser.objects.get(\n                              email=self.example_email(\"hamlet\")))\n        self.check_sent_emails([])\n\n    def test_invite_some_existing_some_new(self):\n        # type: () -> None\n        \"\"\"\n        If you invite a mix of already existing and new users, invitations are\n        only sent to the new users.\n        \"\"\"\n        self.login(self.example_email(\"hamlet\"))\n        existing = [self.example_email(\"hamlet\"), u\"othello@zulip.com\"]\n        new = [u\"foo-test@zulip.com\", u\"bar-test@zulip.com\"]\n\n        result = self.client_post(\"/json/invites\",\n                                  {\"invitee_emails\": \"\\n\".join(existing + new),\n                                   \"stream\": [\"Denmark\"],\n                                   \"custom_body\": ''})\n        self.assert_json_error(result,\n                               \"Some of those addresses are already using Zulip, \\\nso we didn't send them an invitation. We did send invitations to everyone else!\")\n\n        # We only created accounts for the new users.\n        for email in existing:\n            self.assertRaises(PreregistrationUser.DoesNotExist,\n                              lambda: PreregistrationUser.objects.get(\n                                  email=email))\n        for email in new:\n            self.assertTrue(PreregistrationUser.objects.get(email=email))\n\n        # We only sent emails to the new users.\n        self.check_sent_emails(new)\n\n        prereg_user = get_prereg_user_by_email('foo-test@zulip.com')\n        self.assertEqual(prereg_user.email, 'foo-test@zulip.com')\n\n    def test_invite_outside_domain_in_closed_realm(self):\n        # type: () -> None\n        \"\"\"\n        In a realm with `restricted_to_domain = True`, you can't invite people\n        with a different domain from that of the realm or your e-mail address.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.restricted_to_domain = True\n        zulip_realm.save()\n\n        self.login(self.example_email(\"hamlet\"))\n        external_address = \"foo@example.com\"\n\n        self.assert_json_error(\n            self.invite(external_address, [\"Denmark\"]),\n            \"Some emails did not validate, so we didn't send any invitations.\")\n\n    def test_invite_outside_domain_in_open_realm(self):\n        # type: () -> None\n        \"\"\"\n        In a realm with `restricted_to_domain = False`, you can invite people\n        with a different domain from that of the realm or your e-mail address.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.restricted_to_domain = False\n        zulip_realm.save()\n\n        self.login(self.example_email(\"hamlet\"))\n        external_address = \"foo@example.com\"\n\n        self.assert_json_success(self.invite(external_address, [\"Denmark\"]))\n        self.check_sent_emails([external_address])\n\n    def test_invite_outside_domain_before_closing(self):\n        # type: () -> None\n        \"\"\"\n        If you invite someone with a different domain from that of the realm\n        when `restricted_to_domain = False`, but `restricted_to_domain` later\n        changes to true, the invitation should succeed but the invitee's signup\n        attempt should fail.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.restricted_to_domain = False\n        zulip_realm.save()\n\n        self.login(self.example_email(\"hamlet\"))\n        external_address = \"foo@example.com\"\n\n        self.assert_json_success(self.invite(external_address, [\"Denmark\"]))\n        self.check_sent_emails([external_address])\n\n        zulip_realm.restricted_to_domain = True\n        zulip_realm.save()\n\n        result = self.submit_reg_form_for_user(\"foo@example.com\", \"password\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\"only allows users with e-mail\", result)\n\n    def test_invite_with_non_ascii_streams(self):\n        # type: () -> None\n        \"\"\"\n        Inviting someone to streams with non-ASCII characters succeeds.\n        \"\"\"\n        self.login(self.example_email(\"hamlet\"))\n        invitee = \"alice-test@zulip.com\"\n\n        stream_name = u\"h\u00c3\u00bcmb\u00c3\u00bc\u00c7\u00b5\"\n\n        # Make sure we're subscribed before inviting someone.\n        self.subscribe(self.example_user(\"hamlet\"), stream_name)\n\n        self.assert_json_success(self.invite(invitee, [stream_name]))\n\n    def test_invitation_reminder_email(self):\n        # type: () -> None\n        from django.core.mail import outbox\n\n        # All users belong to zulip realm\n        referrer_user = 'hamlet'\n        current_user_email = self.example_email(referrer_user)\n        self.login(current_user_email)\n        invitee_email = self.nonreg_email('alice')\n        self.assert_json_success(self.invite(invitee_email, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(invitee_email))\n        self.check_sent_emails([invitee_email])\n\n        data = {\"email\": invitee_email, \"referrer_email\": current_user_email}\n        invitee = get_prereg_user_by_email(data[\"email\"])\n        referrer = self.example_user(referrer_user)\n        link = create_confirmation_link(invitee, referrer.realm.host, Confirmation.INVITATION)\n        context = common_context(referrer)\n        context.update({\n            'activate_url': link,\n            'referrer_name': referrer.full_name,\n            'referrer_email': referrer.email,\n            'referrer_realm_name': referrer.realm.name,\n        })\n        with self.settings(EMAIL_BACKEND='django.core.mail.backends.console.EmailBackend'):\n            send_future_email(\n                \"zerver/emails/invitation_reminder\", to_email=data[\"email\"],\n                from_address=FromAddress.NOREPLY, context=context)\n        email_jobs_to_deliver = ScheduledEmail.objects.filter(\n            scheduled_timestamp__lte=timezone_now())\n        self.assertEqual(len(email_jobs_to_deliver), 1)\n        email_count = len(outbox)\n        for job in email_jobs_to_deliver:\n            send_email(**ujson.loads(job.data))\n        self.assertEqual(len(outbox), email_count + 1)\n        self.assertIn(FromAddress.NOREPLY, outbox[-1].from_email)\n\n        # Now verify that signing up clears invite_reminder emails\n        email_jobs_to_deliver = ScheduledEmail.objects.filter(\n            scheduled_timestamp__lte=timezone_now(), type=ScheduledEmail.INVITATION_REMINDER)\n        self.assertEqual(len(email_jobs_to_deliver), 1)\n\n        self.register(invitee_email, \"test\")\n        email_jobs_to_deliver = ScheduledEmail.objects.filter(\n            scheduled_timestamp__lte=timezone_now(), type=ScheduledEmail.INVITATION_REMINDER)\n        self.assertEqual(len(email_jobs_to_deliver), 0)\n\nclass InviteeEmailsParserTests(TestCase):\n    def setUp(self):\n        # type: () -> None\n        self.email1 = \"email1@zulip.com\"\n        self.email2 = \"email2@zulip.com\"\n        self.email3 = \"email3@zulip.com\"\n\n    def test_if_emails_separated_by_commas_are_parsed_and_striped_correctly(self):\n        # type: () -> None\n        emails_raw = \"{} ,{}, {}\".format(self.email1, self.email2, self.email3)\n        expected_set = {self.email1, self.email2, self.email3}\n        self.assertEqual(get_invitee_emails_set(emails_raw), expected_set)\n\n    def test_if_emails_separated_by_newlines_are_parsed_and_striped_correctly(self):\n        # type: () -> None\n        emails_raw = \"{}\\n {}\\n {} \".format(self.email1, self.email2, self.email3)\n        expected_set = {self.email1, self.email2, self.email3}\n        self.assertEqual(get_invitee_emails_set(emails_raw), expected_set)\n\n    def test_if_emails_from_email_client_separated_by_newlines_are_parsed_correctly(self):\n        # type: () -> None\n        emails_raw = \"Email One <{}>\\nEmailTwo<{}>\\nEmail Three<{}>\".format(self.email1, self.email2, self.email3)\n        expected_set = {self.email1, self.email2, self.email3}\n        self.assertEqual(get_invitee_emails_set(emails_raw), expected_set)\n\n    def test_if_emails_in_mixed_style_are_parsed_correctly(self):\n        # type: () -> None\n        emails_raw = \"Email One <{}>,EmailTwo<{}>\\n{}\".format(self.email1, self.email2, self.email3)\n        expected_set = {self.email1, self.email2, self.email3}\n        self.assertEqual(get_invitee_emails_set(emails_raw), expected_set)\n\nclass MultiuseInviteTest(ZulipTestCase):\n    def setUp(self):\n        # type: () -> None\n        self.realm = get_realm('zulip')\n        self.realm.invite_required = True\n        self.realm.save()\n\n    def generate_multiuse_invite_link(self, streams=None, date_sent=None):\n        # type: (List[Stream], Optional[datetime.datetime]) -> Text\n        invite = MultiuseInvite(realm=self.realm, referred_by=self.example_user(\"iago\"))\n        invite.save()\n\n        if streams is not None:\n            invite.streams = streams\n            invite.save()\n\n        if date_sent is None:\n            date_sent = timezone_now()\n        key = generate_key()\n        Confirmation.objects.create(content_object=invite, date_sent=date_sent,\n                                    confirmation_key=key, type=Confirmation.MULTIUSE_INVITE)\n\n        return confirmation_url(key, self.realm.host, Confirmation.MULTIUSE_INVITE)\n\n    def check_user_able_to_register(self, email, invite_link):\n        # type: (Text, Text) -> None\n        password = \"password\"\n\n        result = self.client_post(invite_link, {'email': email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/send_confirm/%s\" % (email,)))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(email, password)\n        self.assertEqual(result.status_code, 302)\n\n        from django.core.mail import outbox\n        outbox.pop()\n\n    def check_user_subscribed_only_to_streams(self, user_name, streams):\n        # type: (str, List[Stream]) -> None\n        sorted(streams, key=lambda x: x.name)\n        subscribed_streams = gather_subscriptions(self.nonreg_user(user_name))[0]\n\n        self.assertEqual(len(subscribed_streams), len(streams))\n\n        for x, y in zip(subscribed_streams, streams):\n            self.assertEqual(x[\"name\"], y.name)\n\n    def test_valid_multiuse_link(self):\n        # type: () -> None\n        email1 = self.nonreg_email(\"test\")\n        email2 = self.nonreg_email(\"test1\")\n        email3 = self.nonreg_email(\"alice\")\n\n        date_sent = timezone_now() - datetime.timedelta(days=settings.INVITATION_LINK_VALIDITY_DAYS - 1)\n        invite_link = self.generate_multiuse_invite_link(date_sent=date_sent)\n\n        self.check_user_able_to_register(email1, invite_link)\n        self.check_user_able_to_register(email2, invite_link)\n        self.check_user_able_to_register(email3, invite_link)\n\n    def test_expired_multiuse_link(self):\n        # type: () -> None\n        email = self.nonreg_email('newuser')\n        date_sent = timezone_now() - datetime.timedelta(days=settings.INVITATION_LINK_VALIDITY_DAYS)\n        invite_link = self.generate_multiuse_invite_link(date_sent=date_sent)\n        result = self.client_post(invite_link, {'email': email})\n\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\"The confirmation link has expired or been deactivated.\", result)\n\n    def test_invalid_multiuse_link(self):\n        # type: () -> None\n        email = self.nonreg_email('newuser')\n        invite_link = \"/join/invalid_key/\"\n        result = self.client_post(invite_link, {'email': email})\n\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\"Whoops. The confirmation link is malformed.\", result)\n\n    def test_invalid_multiuse_link_in_open_realm(self):\n        # type: () -> None\n        self.realm.invite_required = False\n        self.realm.save()\n\n        email = self.nonreg_email('newuser')\n        invite_link = \"/join/invalid_key/\"\n\n        with patch('zerver.views.registration.get_realm_from_request', return_value=self.realm):\n            with patch('zerver.views.registration.get_realm', return_value=self.realm):\n                self.check_user_able_to_register(email, invite_link)\n\n    def test_multiuse_link_with_specified_streams(self):\n        # type: () -> None\n        name1 = \"newuser\"\n        name2 = \"bob\"\n        email1 = self.nonreg_email(name1)\n        email2 = self.nonreg_email(name2)\n\n        stream_names = [\"Rome\", \"Scotland\", \"Venice\"]\n        streams = [get_stream(stream_name, self.realm) for stream_name in stream_names]\n        invite_link = self.generate_multiuse_invite_link(streams=streams)\n        self.check_user_able_to_register(email1, invite_link)\n        self.check_user_subscribed_only_to_streams(name1, streams)\n\n        stream_names = [\"Rome\", \"Verona\"]\n        streams = [get_stream(stream_name, self.realm) for stream_name in stream_names]\n        invite_link = self.generate_multiuse_invite_link(streams=streams)\n        self.check_user_able_to_register(email2, invite_link)\n        self.check_user_subscribed_only_to_streams(name2, streams)\n\nclass EmailUnsubscribeTests(ZulipTestCase):\n    def test_error_unsubscribe(self):\n        # type: () -> None\n\n        # An invalid insubscribe token \"test123\" produces an error.\n        result = self.client_get('/accounts/unsubscribe/missed_messages/test123')\n        self.assert_in_response('Unknown email unsubscribe request', result)\n\n        # An unknown message type \"fake\" produces an error.\n        user_profile = self.example_user('hamlet')\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"fake\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n        self.assert_in_response('Unknown email unsubscribe request', result)\n\n    def test_missedmessage_unsubscribe(self):\n        # type: () -> None\n        \"\"\"\n        We provide one-click unsubscribe links in missed message\n        e-mails that you can click even when logged out to update your\n        email notification settings.\n        \"\"\"\n        user_profile = self.example_user('hamlet')\n        user_profile.enable_offline_email_notifications = True\n        user_profile.save()\n\n        unsubscribe_link = one_click_unsubscribe_link(user_profile,\n                                                      \"missed_messages\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n\n        self.assertEqual(result.status_code, 200)\n\n        user_profile.refresh_from_db()\n        self.assertFalse(user_profile.enable_offline_email_notifications)\n\n    def test_welcome_unsubscribe(self):\n        # type: () -> None\n        \"\"\"\n        We provide one-click unsubscribe links in welcome e-mails that you can\n        click even when logged out to stop receiving them.\n        \"\"\"\n        user_profile = self.example_user('hamlet')\n        # Simulate a new user signing up, which enqueues 2 welcome e-mails.\n        enqueue_welcome_emails(user_profile)\n        self.assertEqual(2, ScheduledEmail.objects.filter(user=user_profile).count())\n\n        # Simulate unsubscribing from the welcome e-mails.\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"welcome\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n\n        # The welcome email jobs are no longer scheduled.\n        self.assertEqual(result.status_code, 200)\n        self.assertEqual(0, ScheduledEmail.objects.filter(user=user_profile).count())\n\n    def test_digest_unsubscribe(self):\n        # type: () -> None\n        \"\"\"\n        We provide one-click unsubscribe links in digest e-mails that you can\n        click even when logged out to stop receiving them.\n\n        Unsubscribing from these emails also dequeues any digest email jobs that\n        have been queued.\n        \"\"\"\n        user_profile = self.example_user('hamlet')\n        self.assertTrue(user_profile.enable_digest_emails)\n\n        # Enqueue a fake digest email.\n        context = {'name': '', 'realm_uri': '', 'unread_pms': [], 'hot_conversations': [],\n                   'new_users': [], 'new_streams': {'plain': []}, 'unsubscribe_link': ''}\n        send_future_email('zerver/emails/digest', to_user_id=user_profile.id, context=context)\n\n        self.assertEqual(1, ScheduledEmail.objects.filter(user=user_profile).count())\n\n        # Simulate unsubscribing from digest e-mails.\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"digest\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n\n        # The setting is toggled off, and scheduled jobs have been removed.\n        self.assertEqual(result.status_code, 200)\n        # Circumvent user_profile caching.\n\n        user_profile.refresh_from_db()\n        self.assertFalse(user_profile.enable_digest_emails)\n        self.assertEqual(0, ScheduledEmail.objects.filter(user=user_profile).count())\n\nclass RealmCreationTest(ZulipTestCase):\n    def test_create_realm(self):\n        # type: () -> None\n        password = \"test\"\n        string_id = \"zuliptest\"\n        email = \"user1@test.com\"\n        realm = get_realm('test')\n\n        # Make sure the realm does not exist\n        self.assertIsNone(realm)\n\n        with self.settings(OPEN_REALM_CREATION=True):\n            # Create new realm with the email\n            result = self.client_post('/create_realm/', {'email': email})\n            self.assertEqual(result.status_code, 302)\n            self.assertTrue(result[\"Location\"].endswith(\n                \"/accounts/send_confirm/%s\" % (email,)))\n            result = self.client_get(result[\"Location\"])\n            self.assert_in_response(\"Check your email so we can get started.\", result)\n\n            # Visit the confirmation link.\n            confirmation_url = self.get_confirmation_url_from_outbox(email)\n            result = self.client_get(confirmation_url)\n            self.assertEqual(result.status_code, 200)\n\n            result = self.submit_reg_form_for_user(email, password, realm_subdomain=string_id)\n            self.assertEqual(result.status_code, 302)\n\n            # Make sure the realm is created\n            realm = get_realm(string_id)\n            self.assertIsNotNone(realm)\n            self.assertEqual(realm.string_id, string_id)\n            self.assertEqual(get_user(email, realm).realm, realm)\n\n            # Check defaults\n            self.assertEqual(realm.org_type, Realm.CORPORATE)\n            self.assertEqual(realm.restricted_to_domain, False)\n            self.assertEqual(realm.invite_required, True)\n\n            self.assertTrue(result[\"Location\"].endswith(\"/\"))\n\n            # Check welcome messages\n            for stream_name, text, message_count in [\n                    ('announce', 'This is', 1),\n                    ('core team', 'This is', 1),\n                    ('general', 'Welcome to', 1),\n                    ('new members', 'stream is', 1),\n                    ('zulip', 'Here is', 3)]:\n                stream = get_stream(stream_name, realm)\n                recipient = get_recipient(Recipient.STREAM, stream.id)\n                messages = Message.objects.filter(recipient=recipient).order_by('pub_date')\n                self.assertEqual(len(messages), message_count)\n                self.assertIn(text, messages[0].content)\n\n    def test_create_realm_existing_email(self):\n        # type: () -> None\n        \"\"\"\n        Trying to create a realm with an existing email should just redirect to\n        a login page.\n        \"\"\"\n        with self.settings(OPEN_REALM_CREATION=True):\n            email = self.example_email(\"hamlet\")\n            result = self.client_post('/create_realm/', {'email': email})\n            self.assertEqual(result.status_code, 302)\n            self.assertIn('login', result['Location'])\n\n    def test_create_realm_no_creation_key(self):\n        # type: () -> None\n        \"\"\"\n        Trying to create a realm without a creation_key should fail when\n        OPEN_REALM_CREATION is false.\n        \"\"\"\n        email = \"user1@test.com\"\n        realm = get_realm('test')\n\n        # Make sure the realm does not exist\n        self.assertIsNone(realm)\n\n        with self.settings(OPEN_REALM_CREATION=False):\n            # Create new realm with the email, but no creation key.\n            result = self.client_post('/create_realm/', {'email': email})\n            self.assertEqual(result.status_code, 200)\n            self.assert_in_response('New organization creation disabled.', result)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_create_realm_with_subdomain(self):\n        # type: () -> None\n        password = \"test\"\n        string_id = \"zuliptest\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        # Make sure the realm does not exist\n        self.assertIsNone(get_realm('test'))\n\n        # Create new realm with the email\n        result = self.client_post('/create_realm/', {'email': email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/send_confirm/%s\" % (email,)))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(email, password,\n                                               realm_subdomain = string_id,\n                                               realm_name=realm_name,\n                                               # Pass HTTP_HOST for the target subdomain\n                                               HTTP_HOST=string_id + \".testserver\")\n        self.assertEqual(result.status_code, 302)\n\n        # Make sure the realm is created\n        realm = get_realm(string_id)\n        self.assertIsNotNone(realm)\n        self.assertEqual(realm.string_id, string_id)\n        self.assertEqual(get_user(email, realm).realm, realm)\n\n        self.assertEqual(realm.name, realm_name)\n        self.assertEqual(realm.subdomain, string_id)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_mailinator_signup(self):\n        # type: () -> None\n        result = self.client_post('/create_realm/', {'email': \"hi@mailinator.com\"})\n        self.assert_in_response('Please use your real email address.', result)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_subdomain_restrictions(self):\n        # type: () -> None\n        password = \"test\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        result = self.client_post('/create_realm/', {'email': email})\n        self.client_get(result[\"Location\"])\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        self.client_get(confirmation_url)\n\n        errors = {'id': \"length 3 or greater\",\n                  '-id': \"cannot start or end with a\",\n                  'string-ID': \"lowercase letters\",\n                  'string_id': \"lowercase letters\",\n                  'stream': \"unavailable\",\n                  'streams': \"unavailable\",\n                  'about': \"unavailable\",\n                  'abouts': \"unavailable\",\n                  'zephyr': \"unavailable\"}\n        for string_id, error_msg in errors.items():\n            result = self.submit_reg_form_for_user(email, password,\n                                                   realm_subdomain = string_id,\n                                                   realm_name = realm_name)\n            self.assert_in_response(error_msg, result)\n\n        # test valid subdomain\n        result = self.submit_reg_form_for_user(email, password,\n                                               realm_subdomain = 'a-0',\n                                               realm_name = realm_name)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, 'http://a-0.testserver/accounts/login/subdomain/')\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_subdomain_restrictions_root_domain(self):\n        # type: () -> None\n        password = \"test\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        result = self.client_post('/create_realm/', {'email': email})\n        self.client_get(result[\"Location\"])\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        self.client_get(confirmation_url)\n\n        # test root domain will fail with ROOT_DOMAIN_LANDING_PAGE\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            result = self.submit_reg_form_for_user(email, password,\n                                                   realm_subdomain = '',\n                                                   realm_name = realm_name)\n            self.assert_in_response('unavailable', result)\n\n        # test valid use of root domain\n        result = self.submit_reg_form_for_user(email, password,\n                                               realm_subdomain = '',\n                                               realm_name = realm_name)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, 'http://testserver/accounts/login/subdomain/')\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_subdomain_restrictions_root_domain_option(self):\n        # type: () -> None\n        password = \"test\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        result = self.client_post('/create_realm/', {'email': email})\n        self.client_get(result[\"Location\"])\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        self.client_get(confirmation_url)\n\n        # test root domain will fail with ROOT_DOMAIN_LANDING_PAGE\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            result = self.submit_reg_form_for_user(email, password,\n                                                   realm_subdomain = 'abcdef',\n                                                   realm_in_root_domain = 'true',\n                                                   realm_name = realm_name)\n            self.assert_in_response('unavailable', result)\n\n        # test valid use of root domain\n        result = self.submit_reg_form_for_user(email, password,\n                                               realm_subdomain = 'abcdef',\n                                               realm_in_root_domain = 'true',\n                                               realm_name = realm_name)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, 'http://testserver/accounts/login/subdomain/')\n\n    def test_is_root_domain_available(self):\n        # type: () -> None\n        self.assertTrue(is_root_domain_available())\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            self.assertFalse(is_root_domain_available())\n        realm = get_realm(\"zulip\")\n        realm.string_id = Realm.SUBDOMAIN_FOR_ROOT_DOMAIN\n        realm.save()\n        self.assertFalse(is_root_domain_available())\n\nclass UserSignUpTest(ZulipTestCase):\n\n    def _assert_redirected_to(self, result, url):\n        # type: (HttpResponse, Text) -> None\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result['LOCATION'], url)\n\n    def test_bad_email_configuration_for_accounts_home(self):\n        # type: () -> None\n        \"\"\"\n        Make sure we redirect for SMTP errors.\n        \"\"\"\n        email = self.nonreg_email('newguy')\n\n        smtp_mock = patch(\n            'zerver.views.registration.send_registration_completion_email',\n            side_effect=smtplib.SMTPException('uh oh')\n        )\n\n        error_mock = patch('logging.error')\n\n        with smtp_mock, error_mock as err:\n            result = self.client_post('/accounts/home/', {'email': email})\n\n        self._assert_redirected_to(result, '/config-error/smtp')\n\n        self.assertEqual(\n            err.call_args_list[0][0][0],\n            'Error in accounts_home: uh oh'\n        )\n\n    def test_bad_email_configuration_for_create_realm(self):\n        # type: () -> None\n        \"\"\"\n        Make sure we redirect for SMTP errors.\n        \"\"\"\n        email = self.nonreg_email('newguy')\n\n        smtp_mock = patch(\n            'zerver.views.registration.send_registration_completion_email',\n            side_effect=smtplib.SMTPException('uh oh')\n        )\n\n        error_mock = patch('logging.error')\n\n        with smtp_mock, error_mock as err:\n            result = self.client_post('/create_realm/', {'email': email})\n\n        self._assert_redirected_to(result, '/config-error/smtp')\n\n        self.assertEqual(\n            err.call_args_list[0][0][0],\n            'Error in create_realm: uh oh'\n        )\n\n    def test_user_default_language_and_timezone(self):\n        # type: () -> None\n        \"\"\"\n        Check if the default language of new user is the default language\n        of the realm.\n        \"\"\"\n        email = self.nonreg_email('newguy')\n        password = \"newpassword\"\n        timezone = \"US/Mountain\"\n        realm = get_realm('zulip')\n        do_set_realm_property(realm, 'default_language', u\"de\")\n\n        result = self.client_post('/accounts/home/', {'email': email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/send_confirm/%s\" % (email,)))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        # Pick a password and agree to the ToS.\n        result = self.submit_reg_form_for_user(email, password, timezone=timezone)\n        self.assertEqual(result.status_code, 302)\n\n        user_profile = self.nonreg_user('newguy')\n        self.assertEqual(user_profile.default_language, realm.default_language)\n        self.assertEqual(user_profile.timezone, timezone)\n        from django.core.mail import outbox\n        outbox.pop()\n\n    def test_signup_already_active(self):\n        # type: () -> None\n        \"\"\"\n        Check if signing up with an active email redirects to a login page.\n        \"\"\"\n        email = self.example_email(\"hamlet\")\n        result = self.client_post('/accounts/home/', {'email': email})\n        self.assertEqual(result.status_code, 302)\n        self.assertIn('login', result['Location'])\n        result = self.client_get(result.url)\n        self.assert_in_response(\"You've already registered\", result)\n\n    def test_signup_invalid_name(self):\n        # type: () -> None\n        \"\"\"\n        Check if an invalid name during signup is handled properly.\n        \"\"\"\n        email = \"newguy@zulip.com\"\n        password = \"newpassword\"\n\n        result = self.client_post('/accounts/home/', {'email': email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/send_confirm/%s\" % (email,)))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        # Pick a password and agree to the ToS.\n        result = self.submit_reg_form_for_user(email, password, full_name=\"<invalid>\")\n        self.assert_in_success_response([\"Invalid characters in name!\"], result)\n\n        # Verify that the user is asked for name and password\n        self.assert_in_success_response(['id_password', 'id_full_name'], result)\n\n    def test_signup_without_password(self):\n        # type: () -> None\n        \"\"\"\n        Check if signing up without a password works properly when\n        password_auth_enabled is False.\n        \"\"\"\n\n        email = self.nonreg_email('newuser')\n\n        result = self.client_post('/accounts/home/', {'email': email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/send_confirm/%s\" % (email,)))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        with patch('zerver.views.registration.password_auth_enabled', return_value=False):\n            result = self.client_post(\n                '/accounts/register/',\n                {'full_name': 'New User',\n                 'key': find_key_by_email(email),\n                 'terms': True})\n\n        # User should now be logged in.\n        self.assertEqual(result.status_code, 302)\n        user_profile = self.nonreg_user('newuser')\n        self.assertEqual(get_session_dict_user(self.client.session), user_profile.id)\n\n    def test_signup_without_full_name(self):\n        # type: () -> None\n        \"\"\"\n        Check if signing up without a full name redirects to a registration\n        form.\n        \"\"\"\n        email = \"newguy@zulip.com\"\n        password = \"newpassword\"\n\n        result = self.client_post('/accounts/home/', {'email': email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/send_confirm/%s\" % (email,)))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.client_post(\n            '/accounts/register/',\n            {'password': password,\n             'key': find_key_by_email(email),\n             'terms': True,\n             'from_confirmation': '1'})\n        self.assert_in_success_response([\"You're almost there.\"], result)\n\n        # Verify that the user is asked for name and password\n        self.assert_in_success_response(['id_password', 'id_full_name'], result)\n\n    def test_signup_with_full_name(self):\n        # type: () -> None\n        \"\"\"\n        Check if signing up without a full name redirects to a registration\n        form.\n        \"\"\"\n        email = \"newguy@zulip.com\"\n        password = \"newpassword\"\n\n        result = self.client_post('/accounts/home/', {'email': email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/send_confirm/%s\" % (email,)))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.client_post(\n            '/accounts/register/',\n            {'password': password,\n             'key': find_key_by_email(email),\n             'terms': True,\n             'full_name': \"New Guy\",\n             'from_confirmation': '1'})\n        self.assert_in_success_response([\"You're almost there.\"], result)\n\n    def test_signup_invalid_subdomain(self):\n        # type: () -> None\n        \"\"\"\n        Check if attempting to authenticate to the wrong subdomain logs an\n        error and redirects.\n        \"\"\"\n        email = \"newuser@zulip.com\"\n        password = \"newpassword\"\n\n        result = self.client_post('/accounts/home/', {'email': email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/send_confirm/%s\" % (email,)))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        def invalid_subdomain(**kwargs):\n            # type: (**Any) -> Any\n            return_data = kwargs.get('return_data', {})\n            return_data['invalid_subdomain'] = True\n\n        with patch('zerver.views.registration.authenticate', side_effect=invalid_subdomain):\n            with patch('logging.error') as mock_error:\n                result = self.client_post(\n                    '/accounts/register/',\n                    {'password': password,\n                     'full_name': 'New User',\n                     'key': find_key_by_email(email),\n                     'terms': True})\n        mock_error.assert_called_once()\n        self.assertEqual(result.status_code, 302)\n\n    def test_replace_subdomain_in_confirmation_link(self) -> None:\n        \"\"\"\n        Check that manually changing the subdomain in a registration\n        confirmation link doesn't allow you to register to a different realm.\n        \"\"\"\n        email = \"newuser@zulip.com\"\n        self.client_post('/accounts/home/', {'email': email})\n        result = self.client_post(\n            '/accounts/register/',\n            {'password': \"password\",\n             'key': find_key_by_email(email),\n             'terms': True,\n             'full_name': \"New User\",\n             'from_confirmation': '1'},  subdomain=\"zephyr\")\n        self.assert_in_success_response([\"We couldn't find your confirmation link\"], result)\n\n    def test_failed_signup_due_to_empty_realm_in_prereg_user(self) -> None:\n        \"\"\"\n        Largely to test a transitional state, where we started requiring the\n        realm in PreregistrationUser (if realm_creation is False), and wanted\n        to make sure we had properly disabled any existing confirmation links that\n        didn't have the realm set.\n        \"\"\"\n        email = \"newuser@zulip.com\"\n        password = \"password\"\n        self.client_post('/accounts/home/', {'email': email})\n        PreregistrationUser.objects.update(realm=None)\n        result = self.client_post(\n            '/accounts/register/',\n            {'password': password,\n             'key': find_key_by_email(email),\n             'terms': True,\n             'full_name': \"New User\",\n             'from_confirmation': '1'})\n        self.assert_in_success_response([\"The confirmation link has expired or been deactivated.\"], result)\n\n    def test_failed_signup_due_to_restricted_domain(self):\n        # type: () -> None\n        realm = get_realm('zulip')\n        realm.invite_required = False\n        realm.save()\n\n        request = HostRequestMock(host = realm.host)\n        request.session = {}  # type: ignore\n        email = 'user@acme.com'\n        form = HomepageForm({'email': email}, realm=realm)\n        self.assertIn(\"Your email address, {}, is not in one of the domains\".format(email),\n                      form.errors['email'][0])\n\n    def test_failed_signup_due_to_invite_required(self):\n        # type: () -> None\n        realm = get_realm('zulip')\n        realm.invite_required = True\n        realm.save()\n        request = HostRequestMock(host = realm.host)\n        request.session = {}  # type: ignore\n        email = 'user@zulip.com'\n        form = HomepageForm({'email': email}, realm=realm)\n        self.assertIn(\"Please request an invite for {} from\".format(email),\n                      form.errors['email'][0])\n\n    def test_failed_signup_due_to_nonexistent_realm(self):\n        # type: () -> None\n        request = HostRequestMock(host = 'acme.' + settings.EXTERNAL_HOST)\n        request.session = {}  # type: ignore\n        email = 'user@acme.com'\n        form = HomepageForm({'email': email}, realm=None)\n        self.assertIn(\"organization you are trying to join using {} does \"\n                      \"not exist\".format(email), form.errors['email'][0])\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',\n                                                'zproject.backends.ZulipDummyBackend'))\n    def test_ldap_registration_from_confirmation(self):\n        # type: () -> None\n        password = \"testing\"\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n        ldap_user_attr_map = {'full_name': 'fn', 'short_name': 'sn'}\n\n        ldap_patcher = patch('django_auth_ldap.config.ldap.initialize')\n        mock_initialize = ldap_patcher.start()\n        mock_ldap = MockLDAP()\n        mock_initialize.return_value = mock_ldap\n\n        mock_ldap.directory = {\n            'uid=newuser,ou=users,dc=zulip,dc=com': {\n                'userPassword': 'testing',\n                'fn': ['New LDAP fullname']\n            }\n        }\n\n        with patch('zerver.views.registration.get_subdomain', return_value=subdomain):\n            result = self.client_post('/register/', {'email': email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/send_confirm/%s\" % (email,)))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        # Visit the confirmation link.\n        from django.core.mail import outbox\n        for message in reversed(outbox):\n            if email in message.to:\n                confirmation_link_pattern = re.compile(settings.EXTERNAL_HOST + \"(\\S+)>\")\n                confirmation_url = confirmation_link_pattern.search(\n                    message.body).groups()[0]\n                break\n        else:\n            raise AssertionError(\"Couldn't find a confirmation email.\")\n\n        with self.settings(\n                POPULATE_PROFILE_VIA_LDAP=True,\n                LDAP_APPEND_DOMAIN='zulip.com',\n                AUTH_LDAP_BIND_PASSWORD='',\n                AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n                AUTH_LDAP_USER_DN_TEMPLATE='uid=%(user)s,ou=users,dc=zulip,dc=com'):\n            result = self.client_get(confirmation_url)\n            self.assertEqual(result.status_code, 200)\n\n            # Full name should be set from LDAP\n            result = self.submit_reg_form_for_user(email,\n                                                   password,\n                                                   full_name=\"Ignore\",\n                                                   from_confirmation=\"1\",\n                                                   # Pass HTTP_HOST for the target subdomain\n                                                   HTTP_HOST=subdomain + \".testserver\")\n\n            self.assert_in_success_response([\"You're almost there.\",\n                                             \"New LDAP fullname\",\n                                             \"newuser@zulip.com\"],\n                                            result)\n\n            # Verify that the user is asked for name\n            self.assert_in_success_response(['id_full_name'], result)\n            # TODO: Ideally, we wouldn't ask for a password if LDAP is\n            # enabled, in which case this assert should be invertedq.\n            self.assert_in_success_response(['id_password'], result)\n\n            # Test the TypeError exception handler\n            mock_ldap.directory = {\n                'uid=newuser,ou=users,dc=zulip,dc=com': {\n                    'userPassword': 'testing',\n                    'fn': None  # This will raise TypeError\n                }\n            }\n            result = self.submit_reg_form_for_user(email,\n                                                   password,\n                                                   from_confirmation='1',\n                                                   # Pass HTTP_HOST for the target subdomain\n                                                   HTTP_HOST=subdomain + \".testserver\")\n            self.assert_in_success_response([\"You're almost there.\",\n                                             \"newuser@zulip.com\"],\n                                            result)\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',\n                                                'zproject.backends.ZulipDummyBackend'))\n    def test_ldap_registration_end_to_end(self):\n        # type: () -> None\n        password = \"testing\"\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n\n        ldap_user_attr_map = {'full_name': 'fn', 'short_name': 'sn'}\n\n        ldap_patcher = patch('django_auth_ldap.config.ldap.initialize')\n        mock_initialize = ldap_patcher.start()\n        mock_ldap = MockLDAP()\n        mock_initialize.return_value = mock_ldap\n\n        full_name = 'New LDAP fullname'\n        mock_ldap.directory = {\n            'uid=newuser,ou=users,dc=zulip,dc=com': {\n                'userPassword': 'testing',\n                'fn': [full_name],\n                'sn': ['shortname'],\n            }\n        }\n\n        with patch('zerver.views.registration.get_subdomain', return_value=subdomain):\n            result = self.client_post('/register/', {'email': email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/send_confirm/%s\" % (email,)))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        with self.settings(\n                POPULATE_PROFILE_VIA_LDAP=True,\n                LDAP_APPEND_DOMAIN='zulip.com',\n                AUTH_LDAP_BIND_PASSWORD='',\n                AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n                AUTH_LDAP_USER_DN_TEMPLATE='uid=%(user)s,ou=users,dc=zulip,dc=com'):\n\n            # Click confirmation link\n            result = self.submit_reg_form_for_user(email,\n                                                   password,\n                                                   full_name=\"Ignore\",\n                                                   from_confirmation=\"1\",\n                                                   # Pass HTTP_HOST for the target subdomain\n                                                   HTTP_HOST=subdomain + \".testserver\")\n\n            # Full name should be set from LDAP\n            self.assert_in_success_response([\"You're almost there.\",\n                                             full_name,\n                                             \"newuser@zulip.com\"],\n                                            result)\n\n            # Submit the final form with the wrong password.\n            result = self.submit_reg_form_for_user(email,\n                                                   'wrongpassword',\n                                                   full_name=full_name,\n                                                   # Pass HTTP_HOST for the target subdomain\n                                                   HTTP_HOST=subdomain + \".testserver\")\n            # Didn't create an account\n            with self.assertRaises(UserProfile.DoesNotExist):\n                user_profile = UserProfile.objects.get(email=email)\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"/accounts/login/?email=newuser%40zulip.com\")\n\n            # Submit the final form with the wrong password.\n            result = self.submit_reg_form_for_user(email,\n                                                   password,\n                                                   full_name=full_name,\n                                                   # Pass HTTP_HOST for the target subdomain\n                                                   HTTP_HOST=subdomain + \".testserver\")\n            user_profile = UserProfile.objects.get(email=email)\n            # Name comes from form which was set by LDAP.\n            self.assertEqual(user_profile.full_name, full_name)\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',\n                                                'zproject.backends.ZulipDummyBackend'))\n    def test_ldap_auto_registration_on_login(self):\n        # type: () -> None\n        \"\"\"The most common way for LDAP authentication to be used is with a\n        server that doesn't have a terms-of-service required, in which\n        case we offer a complete single-sign-on experience (where the\n        user just enters their LDAP username and password, and their\n        account is created if it doesn't already exist).\n\n        This test verifies that flow.\n        \"\"\"\n        password = \"testing\"\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n\n        ldap_user_attr_map = {'full_name': 'fn', 'short_name': 'sn'}\n\n        ldap_patcher = patch('django_auth_ldap.config.ldap.initialize')\n        mock_initialize = ldap_patcher.start()\n        mock_ldap = MockLDAP()\n        mock_initialize.return_value = mock_ldap\n\n        full_name = 'New LDAP fullname'\n        mock_ldap.directory = {\n            'uid=newuser,ou=users,dc=zulip,dc=com': {\n                'userPassword': 'testing',\n                'fn': [full_name],\n                'sn': ['shortname'],\n            }\n        }\n\n        with self.settings(\n                POPULATE_PROFILE_VIA_LDAP=True,\n                LDAP_APPEND_DOMAIN='zulip.com',\n                AUTH_LDAP_BIND_PASSWORD='',\n                AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n                AUTH_LDAP_USER_DN_TEMPLATE='uid=%(user)s,ou=users,dc=zulip,dc=com'):\n\n            self.login_with_return(email, password,\n                                   HTTP_HOST=subdomain + \".testserver\")\n\n            user_profile = UserProfile.objects.get(email=email)\n            # Name comes from form which was set by LDAP.\n            self.assertEqual(user_profile.full_name, full_name)\n\n    @override_settings(AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',\n                                                'zproject.backends.ZulipDummyBackend'))\n    def test_ldap_registration_when_names_changes_are_disabled(self):\n        # type: () -> None\n        password = \"testing\"\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n\n        ldap_user_attr_map = {'full_name': 'fn', 'short_name': 'sn'}\n\n        ldap_patcher = patch('django_auth_ldap.config.ldap.initialize')\n        mock_initialize = ldap_patcher.start()\n        mock_ldap = MockLDAP()\n        mock_initialize.return_value = mock_ldap\n\n        mock_ldap.directory = {\n            'uid=newuser,ou=users,dc=zulip,dc=com': {\n                'userPassword': 'testing',\n                'fn': ['New LDAP fullname'],\n                'sn': ['New LDAP shortname'],\n            }\n        }\n\n        with patch('zerver.views.registration.get_subdomain', return_value=subdomain):\n            result = self.client_post('/register/', {'email': email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/send_confirm/%s\" % (email,)))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        with self.settings(\n                POPULATE_PROFILE_VIA_LDAP=True,\n                LDAP_APPEND_DOMAIN='zulip.com',\n                AUTH_LDAP_BIND_PASSWORD='',\n                AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n                AUTH_LDAP_USER_DN_TEMPLATE='uid=%(user)s,ou=users,dc=zulip,dc=com'):\n\n            # Click confirmation link. This will 'authenticated_full_name'\n            # session variable which will be used to set the fullname of\n            # the user.\n            result = self.submit_reg_form_for_user(email,\n                                                   password,\n                                                   full_name=\"Ignore\",\n                                                   from_confirmation=\"1\",\n                                                   # Pass HTTP_HOST for the target subdomain\n                                                   HTTP_HOST=subdomain + \".testserver\")\n\n            with patch('zerver.views.registration.name_changes_disabled', return_value=True):\n                result = self.submit_reg_form_for_user(email,\n                                                       password,\n                                                       # Pass HTTP_HOST for the target subdomain\n                                                       HTTP_HOST=subdomain + \".testserver\")\n            user_profile = UserProfile.objects.get(email=email)\n            # Name comes from LDAP session.\n            self.assertEqual(user_profile.full_name, 'New LDAP fullname')\n\n    def test_registration_when_name_changes_are_disabled(self):\n        # type: () -> None\n        \"\"\"\n        Test `name_changes_disabled` when we are not running under LDAP.\n        \"\"\"\n        password = \"testing\"\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n\n        with patch('zerver.views.registration.get_subdomain', return_value=subdomain):\n            result = self.client_post('/register/', {'email': email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/send_confirm/%s\" % (email,)))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        with patch('zerver.views.registration.name_changes_disabled', return_value=True):\n            result = self.submit_reg_form_for_user(email,\n                                                   password,\n                                                   full_name=\"New Name\",\n                                                   # Pass HTTP_HOST for the target subdomain\n                                                   HTTP_HOST=subdomain + \".testserver\")\n            user_profile = UserProfile.objects.get(email=email)\n            # 'New Name' comes from POST data; not from LDAP session.\n            self.assertEqual(user_profile.full_name, 'New Name')\n\n    def test_realm_creation_through_ldap(self):\n        # type: () -> None\n        password = \"testing\"\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n        realm_name = \"Zulip\"\n        ldap_user_attr_map = {'full_name': 'fn', 'short_name': 'sn'}\n\n        ldap_patcher = patch('django_auth_ldap.config.ldap.initialize')\n        mock_initialize = ldap_patcher.start()\n        mock_ldap = MockLDAP()\n        mock_initialize.return_value = mock_ldap\n\n        mock_ldap.directory = {\n            'uid=newuser,ou=users,dc=zulip,dc=com': {\n                'userPassword': 'testing',\n                'fn': ['New User Name']\n            }\n        }\n\n        with patch('zerver.views.registration.get_subdomain', return_value=subdomain):\n            result = self.client_post('/register/', {'email': email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/send_confirm/%s\" % (email,)))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        # Visit the confirmation link.\n        from django.core.mail import outbox\n        for message in reversed(outbox):\n            if email in message.to:\n                confirmation_link_pattern = re.compile(settings.EXTERNAL_HOST + \"(\\S+)>\")\n                confirmation_url = confirmation_link_pattern.search(\n                    message.body).groups()[0]\n                break\n        else:\n            raise AssertionError(\"Couldn't find a confirmation email.\")\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN='zulip.com',\n            AUTH_LDAP_BIND_PASSWORD='',\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n            AUTHENTICATION_BACKENDS=('zproject.backends.ZulipLDAPAuthBackend',),\n            AUTH_LDAP_USER_DN_TEMPLATE='uid=%(user)s,ou=users,dc=zulip,dc=com',\n            TERMS_OF_SERVICE=False,\n        ):\n            result = self.client_get(confirmation_url)\n            self.assertEqual(result.status_code, 200)\n\n            key = find_key_by_email(email),\n            confirmation = Confirmation.objects.get(confirmation_key=key[0])\n            prereg_user = confirmation.content_object\n            prereg_user.realm_creation = True\n            prereg_user.save()\n\n            result = self.submit_reg_form_for_user(email,\n                                                   password,\n                                                   realm_name=realm_name,\n                                                   realm_subdomain=subdomain,\n                                                   from_confirmation='1',\n                                                   # Pass HTTP_HOST for the target subdomain\n                                                   HTTP_HOST=subdomain + \".testserver\")\n            self.assert_in_success_response([\"You're almost there.\",\n                                             \"newuser@zulip.com\"],\n                                            result)\n\n        mock_ldap.reset()\n        mock_initialize.stop()\n\n    @patch('DNS.dnslookup', return_value=[['sipbtest:*:20922:101:Fred Sipb,,,:/mit/sipbtest:/bin/athena/tcsh']])\n    def test_registration_of_mirror_dummy_user(self, ignored):\n        # type: (Any) -> None\n        password = \"test\"\n        subdomain = \"zephyr\"\n        user_profile = self.mit_user(\"sipbtest\")\n        email = user_profile.email\n        user_profile.is_mirror_dummy = True\n        user_profile.is_active = False\n        user_profile.save()\n\n        result = self.client_post('/register/', {'email': email}, subdomain=\"zephyr\")\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\n            \"/accounts/send_confirm/%s\" % (email,)))\n        result = self.client_get(result[\"Location\"], subdomain=\"zephyr\")\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        # Visit the confirmation link.\n        from django.core.mail import outbox\n        for message in reversed(outbox):\n            if email in message.to:\n                confirmation_link_pattern = re.compile(settings.EXTERNAL_HOST + \"(\\S+)>\")\n                confirmation_url = confirmation_link_pattern.search(\n                    message.body).groups()[0]\n                break\n        else:\n            raise AssertionError(\"Couldn't find a confirmation email.\")\n\n        result = self.client_get(confirmation_url, subdomain=\"zephyr\")\n        self.assertEqual(result.status_code, 200)\n\n        # If the mirror dummy user is already active, attempting to submit the\n        # registration form should just redirect to a login page.\n        user_profile.is_active = True\n        user_profile.save()\n        result = self.submit_reg_form_for_user(email,\n                                               password,\n                                               from_confirmation='1',\n                                               # Pass HTTP_HOST for the target subdomain\n                                               HTTP_HOST=subdomain + \".testserver\")\n\n        self.assertEqual(result.status_code, 302)\n        self.assertIn('login', result['Location'])\n        user_profile.is_active = False\n        user_profile.save()\n\n        result = self.submit_reg_form_for_user(email,\n                                               password,\n                                               from_confirmation='1',\n                                               # Pass HTTP_HOST for the target subdomain\n                                               HTTP_HOST=subdomain + \".testserver\")\n        self.assertEqual(result.status_code, 200)\n        result = self.submit_reg_form_for_user(email,\n                                               password,\n                                               # Pass HTTP_HOST for the target subdomain\n                                               HTTP_HOST=subdomain + \".testserver\")\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(get_session_dict_user(self.client.session), user_profile.id)\n\n    def test_registration_of_active_mirror_dummy_user(self):\n        # type: (Any) -> None\n        \"\"\"\n        Trying to activate an already-active mirror dummy user should just\n        redirect to a login page.\n        \"\"\"\n        user_profile = self.mit_user(\"sipbtest\")\n        email = user_profile.email\n        user_profile.is_mirror_dummy = True\n        user_profile.is_active = True\n        user_profile.save()\n\n        result = self.client_post('/register/', {'email': email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertIn('login', result['Location'])\n\nclass DeactivateUserTest(ZulipTestCase):\n\n    def test_deactivate_user(self):\n        # type: () -> None\n        email = self.example_email(\"hamlet\")\n        self.login(email)\n        user = self.example_user('hamlet')\n        self.assertTrue(user.is_active)\n        result = self.client_delete('/json/users/me')\n        self.assert_json_success(result)\n        user = self.example_user('hamlet')\n        self.assertFalse(user.is_active)\n        self.login(email, fails=True)\n\n    def test_do_not_deactivate_final_admin(self):\n        # type: () -> None\n        email = self.example_email(\"iago\")\n        self.login(email)\n        user = self.example_user('iago')\n        self.assertTrue(user.is_active)\n        result = self.client_delete('/json/users/me')\n        self.assert_json_error(result, \"Cannot deactivate the only organization administrator\")\n        user = self.example_user('iago')\n        self.assertTrue(user.is_active)\n        self.assertTrue(user.is_realm_admin)\n        email = self.example_email(\"hamlet\")\n        user_2 = self.example_user('hamlet')\n        do_change_is_admin(user_2, True)\n        self.assertTrue(user_2.is_realm_admin)\n        result = self.client_delete('/json/users/me')\n        self.assert_json_success(result)\n        do_change_is_admin(user, True)\n\nclass TestLoginPage(ZulipTestCase):\n    def test_login_page_wrong_subdomain_error(self):\n        # type: () -> None\n        result = self.client_get(\"/login/?subdomain=1\")\n        self.assertIn(WRONG_SUBDOMAIN_ERROR, result.content.decode('utf8'))\n\n    @patch('django.http.HttpRequest.get_host')\n    def test_login_page_redirects_for_root_alias(self, mock_get_host):\n        # type: (MagicMock) -> None\n        mock_get_host.return_value = 'www.testserver'\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, '/accounts/find/')\n\n    @patch('django.http.HttpRequest.get_host')\n    def test_login_page_redirects_for_root_domain(self, mock_get_host):\n        # type: (MagicMock) -> None\n        mock_get_host.return_value = 'testserver'\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, '/accounts/find/')\n\n        mock_get_host.return_value = 'www.testserver.com'\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True,\n                           EXTERNAL_HOST='www.testserver.com',\n                           ROOT_SUBDOMAIN_ALIASES=['test']):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, '/accounts/find/')\n\n    @patch('django.http.HttpRequest.get_host')\n    def test_login_page_works_without_subdomains(self, mock_get_host):\n        # type: (MagicMock) -> None\n        mock_get_host.return_value = 'www.testserver'\n        with self.settings(ROOT_SUBDOMAIN_ALIASES=['www']):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 200)\n\n        mock_get_host.return_value = 'testserver'\n        with self.settings(ROOT_SUBDOMAIN_ALIASES=['www']):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 200)\n\nclass TestFindMyTeam(ZulipTestCase):\n    def test_template(self):\n        # type: () -> None\n        result = self.client_get('/accounts/find/')\n        self.assertIn(\"Find your Zulip accounts\", result.content.decode('utf8'))\n\n    def test_result(self):\n        # type: () -> None\n        result = self.client_post('/accounts/find/',\n                                  dict(emails=\"iago@zulip.com,cordelia@zulip.com\"))\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"/accounts/find/?emails=iago%40zulip.com%2Ccordelia%40zulip.com\")\n        result = self.client_get(result.url)\n        content = result.content.decode('utf8')\n        self.assertIn(\"Emails sent! You will only receive emails\", content)\n        self.assertIn(self.example_email(\"iago\"), content)\n        self.assertIn(self.example_email(\"cordelia\"), content)\n        from django.core.mail import outbox\n        self.assertEqual(len(outbox), 2)\n\n    def test_find_team_ignore_invalid_email(self):\n        # type: () -> None\n        result = self.client_post('/accounts/find/',\n                                  dict(emails=\"iago@zulip.com,invalid_email@zulip.com\"))\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"/accounts/find/?emails=iago%40zulip.com%2Cinvalid_email%40zulip.com\")\n        result = self.client_get(result.url)\n        content = result.content.decode('utf8')\n        self.assertIn(\"Emails sent! You will only receive emails\", content)\n        self.assertIn(self.example_email(\"iago\"), content)\n        self.assertIn(\"invalid_email@\", content)\n        from django.core.mail import outbox\n        self.assertEqual(len(outbox), 1)\n\n    def test_find_team_reject_invalid_email(self):\n        # type: () -> None\n        result = self.client_post('/accounts/find/',\n                                  dict(emails=\"invalid_string\"))\n        self.assertEqual(result.status_code, 200)\n        self.assertIn(b\"Enter a valid email\", result.content)\n        from django.core.mail import outbox\n        self.assertEqual(len(outbox), 0)\n\n        # Just for coverage on perhaps-unnecessary validation code.\n        result = self.client_get('/accounts/find/?emails=invalid')\n        self.assertEqual(result.status_code, 200)\n\n    def test_find_team_zero_emails(self):\n        # type: () -> None\n        data = {'emails': ''}\n        result = self.client_post('/accounts/find/', data)\n        self.assertIn('This field is required', result.content.decode('utf8'))\n        self.assertEqual(result.status_code, 200)\n        from django.core.mail import outbox\n        self.assertEqual(len(outbox), 0)\n\n    def test_find_team_one_email(self):\n        # type: () -> None\n        data = {'emails': self.example_email(\"hamlet\")}\n        result = self.client_post('/accounts/find/', data)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, '/accounts/find/?emails=hamlet%40zulip.com')\n        from django.core.mail import outbox\n        self.assertEqual(len(outbox), 1)\n\n    def test_find_team_deactivated_user(self):\n        # type: () -> None\n        do_deactivate_user(self.example_user(\"hamlet\"))\n        data = {'emails': self.example_email(\"hamlet\")}\n        result = self.client_post('/accounts/find/', data)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, '/accounts/find/?emails=hamlet%40zulip.com')\n        from django.core.mail import outbox\n        self.assertEqual(len(outbox), 0)\n\n    def test_find_team_deactivated_realm(self):\n        # type: () -> None\n        do_deactivate_realm(get_realm(\"zulip\"))\n        data = {'emails': self.example_email(\"hamlet\")}\n        result = self.client_post('/accounts/find/', data)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, '/accounts/find/?emails=hamlet%40zulip.com')\n        from django.core.mail import outbox\n        self.assertEqual(len(outbox), 0)\n\n    def test_find_team_bot_email(self):\n        # type: () -> None\n        data = {'emails': self.example_email(\"webhook_bot\")}\n        result = self.client_post('/accounts/find/', data)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, '/accounts/find/?emails=webhook-bot%40zulip.com')\n        from django.core.mail import outbox\n        self.assertEqual(len(outbox), 0)\n\n    def test_find_team_more_than_ten_emails(self):\n        # type: () -> None\n        data = {'emails': ','.join(['hamlet-{}@zulip.com'.format(i) for i in range(11)])}\n        result = self.client_post('/accounts/find/', data)\n        self.assertEqual(result.status_code, 200)\n        self.assertIn(\"Please enter at most 10\", result.content.decode('utf8'))\n        from django.core.mail import outbox\n        self.assertEqual(len(outbox), 0)\n\nclass ConfirmationKeyTest(ZulipTestCase):\n    def test_confirmation_key(self):\n        # type: () -> None\n        request = MagicMock()\n        request.session = {\n            'confirmation_key': {'confirmation_key': 'xyzzy'}\n        }\n        result = confirmation_key(request)\n        self.assert_json_success(result)\n        self.assert_in_response('xyzzy', result)\n\nclass MobileAuthOTPTest(ZulipTestCase):\n    def test_xor_hex_strings(self):\n        # type: () -> None\n        self.assertEqual(xor_hex_strings('1237c81ab', '18989fd12'), '0aaf57cb9')\n        with self.assertRaises(AssertionError):\n            xor_hex_strings('1', '31')\n\n    def test_is_valid_otp(self):\n        # type: () -> None\n        self.assertEqual(is_valid_otp('1234'), False)\n        self.assertEqual(is_valid_otp('1234abcd' * 8), True)\n        self.assertEqual(is_valid_otp('1234abcZ' * 8), False)\n\n    def test_ascii_to_hex(self):\n        # type: () -> None\n        self.assertEqual(ascii_to_hex('ZcdR1234'), '5a63645231323334')\n        self.assertEqual(hex_to_ascii('5a63645231323334'), 'ZcdR1234')\n\n    def test_otp_encrypt_api_key(self):\n        # type: () -> None\n        hamlet = self.example_user('hamlet')\n        hamlet.api_key = '12ac' * 8\n        otp = '7be38894' * 8\n        result = otp_encrypt_api_key(hamlet, otp)\n        self.assertEqual(result, '4ad1e9f7' * 8)\n\n        decryped = otp_decrypt_api_key(result, otp)\n        self.assertEqual(decryped, hamlet.api_key)\n\nclass LoginOrAskForRegistrationTestCase(ZulipTestCase):\n    def test_confirm(self):\n        # type: () -> None\n        request = HostRequestMock()\n        email = 'new@zulip.com'\n        user_profile = None  # type: Optional[UserProfile]\n        full_name = 'New User'\n        invalid_subdomain = False\n        result = login_or_register_remote_user(\n            request,\n            email,\n            user_profile,\n            full_name=full_name,\n            invalid_subdomain=invalid_subdomain)\n        self.assert_in_response('No account found for',\n                                result)\n        self.assert_in_response('new@zulip.com. Would you like to register instead?',\n                                result)\n\n    def test_invalid_subdomain(self):\n        # type: () -> None\n        request = HostRequestMock()\n        email = 'new@zulip.com'\n        user_profile = None  # type: Optional[UserProfile]\n        full_name = 'New User'\n        invalid_subdomain = True\n        response = login_or_register_remote_user(\n            request,\n            email,\n            user_profile,\n            full_name=full_name,\n            invalid_subdomain=invalid_subdomain)\n        self.assertEqual(response.status_code, 302)\n        self.assertIn('/accounts/login/?subdomain=1', response.url)\n\n    def test_invalid_email(self):\n        # type: () -> None\n        request = HostRequestMock()\n        email = None  # type: Optional[Text]\n        user_profile = None  # type: Optional[UserProfile]\n        full_name = 'New User'\n        invalid_subdomain = False\n        response = login_or_register_remote_user(\n            request,\n            email,\n            user_profile,\n            full_name=full_name,\n            invalid_subdomain=invalid_subdomain)\n        self.assert_in_response('Please click the following button if '\n                                'you wish to register', response)\n\n    def test_login_under_subdomains(self):\n        # type: () -> None\n        request = HostRequestMock()\n        setattr(request, 'session', self.client.session)\n        user_profile = self.example_user('hamlet')\n        user_profile.backend = 'zproject.backends.GitHubAuthBackend'\n        full_name = 'Hamlet'\n        invalid_subdomain = False\n\n        response = login_or_register_remote_user(\n            request,\n            user_profile.email,\n            user_profile,\n            full_name=full_name,\n            invalid_subdomain=invalid_subdomain)\n        user_id = get_session_dict_user(getattr(request, 'session'))\n        self.assertEqual(user_id, user_profile.id)\n        self.assertEqual(response.status_code, 302)\n        self.assertIn('http://zulip.testserver', response.url)\n", "# -*- coding: utf-8 -*-\nfrom typing import Any, List, Dict, Mapping, Optional, Text\n\nfrom django.utils.translation import ugettext as _\nfrom django.conf import settings\nfrom django.contrib.auth import authenticate, get_backends\nfrom django.core.urlresolvers import reverse\nfrom django.http import HttpResponseRedirect, HttpResponseForbidden, HttpResponse, HttpRequest\nfrom django.shortcuts import redirect, render\nfrom django.template import RequestContext, loader\nfrom django.utils.timezone import now\nfrom django.core.exceptions import ValidationError\nfrom django.core import validators\nfrom zerver.context_processors import get_realm_from_request\nfrom zerver.models import UserProfile, Realm, Stream, PreregistrationUser, MultiuseInvite, \\\n    name_changes_disabled, email_to_username, email_allowed_for_realm, \\\n    get_realm, get_user_profile_by_email\nfrom zerver.lib.send_email import send_email, FromAddress\nfrom zerver.lib.events import do_events_register\nfrom zerver.lib.actions import do_change_password, do_change_full_name, do_change_is_admin, \\\n    do_activate_user, do_create_user, do_create_realm, \\\n    user_email_is_unique, compute_mit_user_fullname, validate_email_for_realm, \\\n    do_set_user_display_setting\nfrom zerver.forms import RegistrationForm, HomepageForm, RealmCreationForm, \\\n    CreateUserForm, FindMyTeamForm\nfrom django_auth_ldap.backend import LDAPBackend, _LDAPUser\nfrom zerver.decorator import require_post, has_request_variables, \\\n    JsonableError, REQ, do_login\nfrom zerver.lib.onboarding import send_initial_pms, setup_initial_streams, \\\n    setup_initial_private_stream, send_initial_realm_messages\nfrom zerver.lib.response import json_success\nfrom zerver.lib.subdomains import get_subdomain, is_root_domain_available\nfrom zerver.lib.timezone import get_all_timezones\nfrom zproject.backends import ldap_auth_enabled, password_auth_enabled, ZulipLDAPAuthBackend\n\nfrom confirmation.models import Confirmation, RealmCreationKey, ConfirmationKeyException, \\\n    check_key_is_valid, create_confirmation_link, get_object_from_key, \\\n    render_confirmation_key_error\n\nimport logging\nimport requests\nimport smtplib\nimport ujson\n\nfrom six.moves import urllib\n\ndef redirect_and_log_into_subdomain(realm, full_name, email_address,\n                                    is_signup=False):\n    # type: (Realm, Text, Text, bool) -> HttpResponse\n    subdomain_login_uri = ''.join([\n        realm.uri,\n        reverse('zerver.views.auth.log_into_subdomain')\n    ])\n\n    domain = settings.EXTERNAL_HOST.split(':')[0]\n    response = redirect(subdomain_login_uri)\n\n    data = {'name': full_name, 'email': email_address, 'subdomain': realm.subdomain,\n            'is_signup': is_signup}\n    # Creating a singed cookie so that it cannot be tampered with.\n    # Cookie and the signature expire in 15 seconds.\n    response.set_signed_cookie('subdomain.signature',\n                               ujson.dumps(data),\n                               expires=15,\n                               domain=domain,\n                               salt='zerver.views.auth')\n    return response\n\n@require_post\ndef accounts_register(request):\n    # type: (HttpRequest) -> HttpResponse\n    key = request.POST['key']\n    confirmation = Confirmation.objects.get(confirmation_key=key)\n    prereg_user = confirmation.content_object\n    email = prereg_user.email\n    realm_creation = prereg_user.realm_creation\n    password_required = prereg_user.password_required\n\n    validators.validate_email(email)\n    if realm_creation:\n        # For creating a new realm, there is no existing realm or domain\n        realm = None\n    else:\n        realm = get_realm(get_subdomain(request))\n        if prereg_user.realm is None:\n            return render(request, 'confirmation/link_expired.html')\n        if prereg_user.realm != realm:\n            return render(request, 'confirmation/link_does_not_exist.html')\n\n    if realm and not email_allowed_for_realm(email, realm):\n        return render(request, \"zerver/closed_realm.html\",\n                      context={\"closed_domain_name\": realm.name})\n\n    if realm and realm.deactivated:\n        # The user is trying to register for a deactivated realm. Advise them to\n        # contact support.\n        return redirect_to_deactivation_notice()\n\n    try:\n        validate_email_for_realm(realm, email)\n    except ValidationError:\n        return HttpResponseRedirect(reverse('django.contrib.auth.views.login') + '?email=' +\n                                    urllib.parse.quote_plus(email))\n\n    name_validated = False\n    full_name = None\n\n    if request.POST.get('from_confirmation'):\n        try:\n            del request.session['authenticated_full_name']\n        except KeyError:\n            pass\n        if realm is not None and realm.is_zephyr_mirror_realm:\n            # For MIT users, we can get an authoritative name from Hesiod.\n            # Technically we should check that this is actually an MIT\n            # realm, but we can cross that bridge if we ever get a non-MIT\n            # zephyr mirroring realm.\n            hesiod_name = compute_mit_user_fullname(email)\n            form = RegistrationForm(\n                initial={'full_name': hesiod_name if \"@\" not in hesiod_name else \"\"},\n                realm_creation=realm_creation)\n            name_validated = True\n        elif settings.POPULATE_PROFILE_VIA_LDAP:\n            for backend in get_backends():\n                if isinstance(backend, LDAPBackend):\n                    ldap_attrs = _LDAPUser(backend, backend.django_to_ldap_username(email)).attrs\n                    try:\n                        ldap_full_name = ldap_attrs[settings.AUTH_LDAP_USER_ATTR_MAP['full_name']][0]\n                        request.session['authenticated_full_name'] = ldap_full_name\n                        name_validated = True\n                        # We don't use initial= here, because if the form is\n                        # complete (that is, no additional fields need to be\n                        # filled out by the user) we want the form to validate,\n                        # so they can be directly registered without having to\n                        # go through this interstitial.\n                        form = RegistrationForm({'full_name': ldap_full_name},\n                                                realm_creation=realm_creation)\n                        # FIXME: This will result in the user getting\n                        # validation errors if they have to enter a password.\n                        # Not relevant for ONLY_SSO, though.\n                        break\n                    except TypeError:\n                        # Let the user fill out a name and/or try another backend\n                        form = RegistrationForm(realm_creation=realm_creation)\n        elif 'full_name' in request.POST:\n            form = RegistrationForm(\n                initial={'full_name': request.POST.get('full_name')},\n                realm_creation=realm_creation\n            )\n        else:\n            form = RegistrationForm(realm_creation=realm_creation)\n    else:\n        postdata = request.POST.copy()\n        if name_changes_disabled(realm):\n            # If we populate profile information via LDAP and we have a\n            # verified name from you on file, use that. Otherwise, fall\n            # back to the full name in the request.\n            try:\n                postdata.update({'full_name': request.session['authenticated_full_name']})\n                name_validated = True\n            except KeyError:\n                pass\n        form = RegistrationForm(postdata, realm_creation=realm_creation)\n        if not (password_auth_enabled(realm) and password_required):\n            form['password'].field.required = False\n\n    if form.is_valid():\n        if password_auth_enabled(realm):\n            password = form.cleaned_data['password']\n        else:\n            # SSO users don't need no passwords\n            password = None\n\n        if realm_creation:\n            string_id = form.cleaned_data['realm_subdomain']\n            realm_name = form.cleaned_data['realm_name']\n            realm = do_create_realm(string_id, realm_name)\n            setup_initial_streams(realm)\n        assert(realm is not None)\n\n        full_name = form.cleaned_data['full_name']\n        short_name = email_to_username(email)\n\n        timezone = u\"\"\n        if 'timezone' in request.POST and request.POST['timezone'] in get_all_timezones():\n            timezone = request.POST['timezone']\n\n        try:\n            existing_user_profile = get_user_profile_by_email(email)\n        except UserProfile.DoesNotExist:\n            existing_user_profile = None\n\n        return_data = {}  # type: Dict[str, bool]\n        if ldap_auth_enabled(realm):\n            # If the user was authenticated using an external SSO\n            # mechanism like Google or GitHub auth, then authentication\n            # will have already been done before creating the\n            # PreregistrationUser object with password_required=False, and\n            # so we don't need to worry about passwords.\n            #\n            # If instead the realm is using EmailAuthBackend, we will\n            # set their password above.\n            #\n            # But if the realm is using LDAPAuthBackend, we need to verify\n            # their LDAP password (which will, as a side effect, create\n            # the user account) here using authenticate.\n            auth_result = authenticate(request,\n                                       username=email,\n                                       password=password,\n                                       realm_subdomain=realm.subdomain,\n                                       return_data=return_data)\n            if auth_result is None:\n                # TODO: This probably isn't going to give a\n                # user-friendly error message, but it doesn't\n                # particularly matter, because the registration form\n                # is hidden for most users.\n                return HttpResponseRedirect(reverse('django.contrib.auth.views.login') + '?email=' +\n                                            urllib.parse.quote_plus(email))\n\n            # Since we'll have created a user, we now just log them in.\n            return login_and_go_to_home(request, auth_result)\n        elif existing_user_profile is not None and existing_user_profile.is_mirror_dummy:\n            user_profile = existing_user_profile\n            do_activate_user(user_profile)\n            do_change_password(user_profile, password)\n            do_change_full_name(user_profile, full_name, user_profile)\n            do_set_user_display_setting(user_profile, 'timezone', timezone)\n        else:\n            user_profile = do_create_user(email, password, realm, full_name, short_name,\n                                          prereg_user=prereg_user, is_realm_admin=realm_creation,\n                                          tos_version=settings.TOS_VERSION,\n                                          timezone=timezone,\n                                          newsletter_data={\"IP\": request.META['REMOTE_ADDR']})\n\n        # Note: Any logic like this must also be replicated in\n        # ZulipLDAPAuthBackend and zerver/views/users.py.  This is\n        # ripe for a refactoring, though care is required to avoid\n        # import loops with zerver/lib/actions.py and zerver/lib/onboarding.py.\n        send_initial_pms(user_profile)\n\n        if realm_creation:\n            setup_initial_private_stream(user_profile)\n            send_initial_realm_messages(realm)\n\n        if realm_creation:\n            # Because for realm creation, registration happens on the\n            # root domain, we need to log them into the subdomain for\n            # their new realm.\n            return redirect_and_log_into_subdomain(realm, full_name, email)\n\n        # This dummy_backend check below confirms the user is\n        # authenticating to the correct subdomain.\n        auth_result = authenticate(username=user_profile.email,\n                                   realm_subdomain=realm.subdomain,\n                                   return_data=return_data,\n                                   use_dummy_backend=True)\n        if return_data.get('invalid_subdomain'):\n            # By construction, this should never happen.\n            logging.error(\"Subdomain mismatch in registration %s: %s\" % (\n                realm.subdomain, user_profile.email,))\n            return redirect('/')\n\n        return login_and_go_to_home(request, auth_result)\n\n    return render(\n        request,\n        'zerver/register.html',\n        context={'form': form,\n                 'email': email,\n                 'key': key,\n                 'full_name': request.session.get('authenticated_full_name', None),\n                 'lock_name': name_validated and name_changes_disabled(realm),\n                 # password_auth_enabled is normally set via our context processor,\n                 # but for the registration form, there is no logged in user yet, so\n                 # we have to set it here.\n                 'creating_new_team': realm_creation,\n                 'password_required': password_auth_enabled(realm) and password_required,\n                 'password_auth_enabled': password_auth_enabled(realm),\n                 'root_domain_available': is_root_domain_available(),\n                 'MAX_REALM_NAME_LENGTH': str(Realm.MAX_REALM_NAME_LENGTH),\n                 'MAX_NAME_LENGTH': str(UserProfile.MAX_NAME_LENGTH),\n                 'MAX_PASSWORD_LENGTH': str(form.MAX_PASSWORD_LENGTH),\n                 'MAX_REALM_SUBDOMAIN_LENGTH': str(Realm.MAX_REALM_SUBDOMAIN_LENGTH)\n                 }\n    )\n\ndef login_and_go_to_home(request, user_profile):\n    # type: (HttpRequest, UserProfile) -> HttpResponse\n\n    # Mark the user as having been just created, so no \"new login\" email is sent\n    user_profile.just_registered = True\n    do_login(request, user_profile)\n    return HttpResponseRedirect(user_profile.realm.uri + reverse('zerver.views.home.home'))\n\ndef create_preregistration_user(email, request, realm_creation=False,\n                                password_required=True):\n    # type: (Text, HttpRequest, bool, bool) -> HttpResponse\n    realm = None\n    if not realm_creation:\n        realm = get_realm(get_subdomain(request))\n    return PreregistrationUser.objects.create(email=email,\n                                              realm_creation=realm_creation,\n                                              password_required=password_required,\n                                              realm=realm)\n\ndef send_registration_completion_email(email, request, realm_creation=False, streams=None):\n    # type: (str, HttpRequest, bool, Optional[List[Stream]]) -> None\n    \"\"\"\n    Send an email with a confirmation link to the provided e-mail so the user\n    can complete their registration.\n    \"\"\"\n    prereg_user = create_preregistration_user(email, request, realm_creation)\n\n    if streams is not None:\n        prereg_user.streams = streams\n        prereg_user.save()\n\n    activation_url = create_confirmation_link(prereg_user, request.get_host(), Confirmation.USER_REGISTRATION)\n    send_email('zerver/emails/confirm_registration', to_email=email, from_address=FromAddress.NOREPLY,\n               context={'activate_url': activation_url})\n    if settings.DEVELOPMENT and realm_creation:\n        request.session['confirmation_key'] = {'confirmation_key': activation_url.split('/')[-1]}\n\ndef redirect_to_email_login_url(email):\n    # type: (str) -> HttpResponseRedirect\n    login_url = reverse('django.contrib.auth.views.login')\n    email = urllib.parse.quote_plus(email)\n    redirect_url = login_url + '?already_registered=' + email\n    return HttpResponseRedirect(redirect_url)\n\ndef create_realm(request, creation_key=None):\n    # type: (HttpRequest, Optional[Text]) -> HttpResponse\n    if not settings.OPEN_REALM_CREATION:\n        if creation_key is None:\n            return render(request, \"zerver/realm_creation_failed.html\",\n                          context={'message': _('New organization creation disabled.')})\n        elif not check_key_is_valid(creation_key):\n            return render(request, \"zerver/realm_creation_failed.html\",\n                          context={'message': _('The organization creation link has expired'\n                                                ' or is not valid.')})\n\n    # When settings.OPEN_REALM_CREATION is enabled, anyone can create a new realm,\n    # subject to a few restrictions on their email address.\n    if request.method == 'POST':\n        form = RealmCreationForm(request.POST)\n        if form.is_valid():\n            email = form.cleaned_data['email']\n            try:\n                send_registration_completion_email(email, request, realm_creation=True)\n            except smtplib.SMTPException as e:\n                logging.error('Error in create_realm: %s' % (str(e),))\n                return HttpResponseRedirect(\"/config-error/smtp\")\n\n            if (creation_key is not None and check_key_is_valid(creation_key)):\n                RealmCreationKey.objects.get(creation_key=creation_key).delete()\n            return HttpResponseRedirect(reverse('send_confirm', kwargs={'email': email}))\n        try:\n            email = request.POST['email']\n            user_email_is_unique(email)\n        except ValidationError:\n            # Maybe the user is trying to log in\n            return redirect_to_email_login_url(email)\n    else:\n        form = RealmCreationForm()\n    return render(request,\n                  'zerver/create_realm.html',\n                  context={'form': form, 'current_url': request.get_full_path},\n                  )\n\ndef confirmation_key(request):\n    # type: (HttpRequest) -> HttpResponse\n    return json_success(request.session.get('confirmation_key'))\n\n\ndef show_deactivation_notice(request):\n    # type: (HttpRequest) -> HttpResponse\n    realm = get_realm_from_request(request)\n    if realm and realm.deactivated:\n        return render(request, \"zerver/deactivated.html\",\n                      context={\"deactivated_domain_name\": realm.name})\n\n    return HttpResponseRedirect(reverse('zerver.views.auth.login_page'))\n\ndef redirect_to_deactivation_notice():\n    # type: () -> HttpResponse\n    return HttpResponseRedirect(reverse('zerver.views.registration.show_deactivation_notice'))\n\ndef accounts_home(request, multiuse_object=None):\n    # type: (HttpRequest, Optional[MultiuseInvite]) -> HttpResponse\n    realm = get_realm(get_subdomain(request))\n    if realm and realm.deactivated:\n        return redirect_to_deactivation_notice()\n\n    from_multiuse_invite = False\n    streams_to_subscribe = None\n\n    if multiuse_object:\n        realm = multiuse_object.realm\n        streams_to_subscribe = multiuse_object.streams.all()\n        from_multiuse_invite = True\n\n    if request.method == 'POST':\n        form = HomepageForm(request.POST, realm=realm, from_multiuse_invite=from_multiuse_invite)\n        if form.is_valid():\n            email = form.cleaned_data['email']\n            try:\n                send_registration_completion_email(email, request, streams=streams_to_subscribe)\n            except smtplib.SMTPException as e:\n                logging.error('Error in accounts_home: %s' % (str(e),))\n                return HttpResponseRedirect(\"/config-error/smtp\")\n\n            return HttpResponseRedirect(reverse('send_confirm', kwargs={'email': email}))\n\n        email = request.POST['email']\n        try:\n            validate_email_for_realm(realm, email)\n        except ValidationError:\n            return redirect_to_email_login_url(email)\n    else:\n        form = HomepageForm(realm=realm)\n    return render(request,\n                  'zerver/accounts_home.html',\n                  context={'form': form, 'current_url': request.get_full_path,\n                           'from_multiuse_invite': from_multiuse_invite},\n                  )\n\ndef accounts_home_from_multiuse_invite(request, confirmation_key):\n    # type: (HttpRequest, str) -> HttpResponse\n    multiuse_object = None\n    try:\n        multiuse_object = get_object_from_key(confirmation_key)\n        # Required for oAuth2\n        request.session[\"multiuse_object_key\"] = confirmation_key\n    except ConfirmationKeyException as exception:\n        realm = get_realm_from_request(request)\n        if realm is None or realm.invite_required:\n            return render_confirmation_key_error(request, exception)\n    return accounts_home(request, multiuse_object=multiuse_object)\n\ndef generate_204(request):\n    # type: (HttpRequest) -> HttpResponse\n    return HttpResponse(content=None, status=204)\n\ndef find_account(request):\n    # type: (HttpRequest) -> HttpResponse\n    url = reverse('zerver.views.registration.find_account')\n\n    emails = []  # type: List[Text]\n    if request.method == 'POST':\n        form = FindMyTeamForm(request.POST)\n        if form.is_valid():\n            emails = form.cleaned_data['emails']\n            for user_profile in UserProfile.objects.filter(\n                    email__in=emails, is_active=True, is_bot=False, realm__deactivated=False):\n                send_email('zerver/emails/find_team', to_user_id=user_profile.id,\n                           context={'user_profile': user_profile})\n\n            # Note: Show all the emails in the result otherwise this\n            # feature can be used to ascertain which email addresses\n            # are associated with Zulip.\n            data = urllib.parse.urlencode({'emails': ','.join(emails)})\n            return redirect(url + \"?\" + data)\n    else:\n        form = FindMyTeamForm()\n        result = request.GET.get('emails')\n        # The below validation is perhaps unnecessary, in that we\n        # shouldn't get able to get here with an invalid email unless\n        # the user hand-edits the URLs.\n        if result:\n            for email in result.split(','):\n                try:\n                    validators.validate_email(email)\n                    emails.append(email)\n                except ValidationError:\n                    pass\n\n    return render(request,\n                  'zerver/find_account.html',\n                  context={'form': form, 'current_url': lambda: url,\n                           'emails': emails},)\n"], "filenames": ["templates/confirmation/link_expired.html", "zerver/tests/test_auth_backends.py", "zerver/tests/test_email_change.py", "zerver/tests/test_signup.py", "zerver/views/registration.py"], "buggy_code_start_loc": [7, 523, 65, 928, 85], "buggy_code_end_loc": [13, 524, 66, 1556, 86], "fixing_code_start_loc": [7, 523, 65, 928, 85], "fixing_code_end_loc": [11, 524, 66, 1577, 88], "type": "CWE-287", "message": "In Zulip Server before 1.7.1, on a server with multiple realms, a vulnerability in the invitation system lets an authorized user of one realm on the server create a user account on any other realm.", "other": {"cve": {"id": "CVE-2017-0910", "sourceIdentifier": "support@hackerone.com", "published": "2017-11-27T16:29:00.217", "lastModified": "2019-10-09T23:21:11.790", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In Zulip Server before 1.7.1, on a server with multiple realms, a vulnerability in the invitation system lets an authorized user of one realm on the server create a user account on any other realm."}, {"lang": "es", "value": "En Zulip Server en versiones anteriores a la 1.7.1, en un servidor con m\u00faltiples dominios, una vulnerabilidad en el sistema de invitaci\u00f3n deja que un usuario autorizado de un dominio del servidor cree un usuario en cualquier otro dominio."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}, {"source": "support@hackerone.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-863"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:zulip:zulip_server:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.7.1", "matchCriteriaId": "5DAE3C15-00D9-4490-B4C2-A61BF637A7D5"}]}]}], "references": [{"url": "http://blog.zulip.org/2017/11/23/zulip-1-7-1-released/", "source": "support@hackerone.com", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/zulip/zulip/commit/960d736e55cbb9386a68e4ee45f80581fd2a4e32", "source": "support@hackerone.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/zulip/zulip/commit/960d736e55cbb9386a68e4ee45f80581fd2a4e32"}}