{"buggy_code": ["package de.thm.ii.fbs.controller\n\nimport de.thm.ii.fbs.controller.exception.{BadRequestException, ConflictException, ForbiddenException, ResourceNotFoundException}\nimport de.thm.ii.fbs.model.{CourseRole, GlobalRole, SubTaskResult, Submission}\nimport de.thm.ii.fbs.services.checker.CheckerServiceFactoryService\nimport de.thm.ii.fbs.services.persistence._\nimport de.thm.ii.fbs.services.security.AuthService\nimport org.springframework.beans.factory.annotation.Autowired\nimport org.springframework.web.bind.annotation._\nimport org.springframework.web.multipart.MultipartFile\n\nimport java.time.Instant\nimport javax.servlet.http.{HttpServletRequest, HttpServletResponse}\n\n/**\n  * Submission controller implement routes for submitting task and receive results\n  */\n@RestController\n@CrossOrigin\n@RequestMapping(path = Array(\"/api/v1/users\"))\nclass SubmissionController {\n  @Autowired\n  private val authService: AuthService = null\n  @Autowired\n  private val storageService: StorageService = null\n  @Autowired\n  private val submissionService: SubmissionService = null\n  @Autowired\n  private val taskService: TaskService = null\n  @Autowired\n  private val checkerConfigurationService: CheckrunnerConfigurationService = null\n  @Autowired\n  private val checkerServiceFactoryService: CheckerServiceFactoryService = null\n  @Autowired\n  private val courseRegistrationService: CourseRegistrationService = null\n  @Autowired\n  private val checkrunnerSubTaskServer: CheckrunnerSubTaskService = null\n  @Autowired\n  private val courseRegistration: CourseRegistrationService = null\n\n  /**\n    * Get a list of all submissions for a task\n    *\n    * @param uid User id\n    * @param cid Course id\n    * @param tid Task id\n    * @param req Http request\n    * @param res Http response\n    * @return Submission results\n    */\n  @GetMapping(value = Array(\"/{uid}/courses/{cid}/tasks/{tid}/submissions\"))\n  @ResponseBody\n  def getAll(@PathVariable(\"uid\") uid: Int, @PathVariable(\"cid\") cid: Int, @PathVariable(\"tid\") tid: Int,\n             req: HttpServletRequest, res: HttpServletResponse): List[Submission] = {\n    val user = authService.authorize(req, res)\n    val task = taskService.getOne(tid).get\n\n    val adminPrivileged = (user.hasRole(GlobalRole.ADMIN, GlobalRole.MODERATOR)\n      || List(CourseRole.DOCENT, CourseRole.TUTOR).contains(courseRegistrationService.getCoursePrivileges(user.id).getOrElse(cid, CourseRole.STUDENT)))\n    val privileged = (user.id == uid && !task.isPrivate) || adminPrivileged\n\n    if (privileged) {\n      submissionService.getAll(uid, cid, tid, adminPrivileged || task.mediaType == \"application/x-spreadsheet\")\n        .map(submission => submissionService.getOrHidden(submission, task.hideResult, adminPrivileged))\n    } else {\n      throw new ForbiddenException()\n    }\n  }\n\n  /**\n    * Get a list of all submissions for a task\n    *\n    * @param uid User id\n    * @param cid Course id\n    * @param tid Task id\n    * @param sid Submission id\n    * @param req Http request\n    * @param res Http response\n    * @return Submission results\n    */\n  @GetMapping(value = Array(\"/{uid}/courses/{cid}/tasks/{tid}/submissions/{sid}/subresults\"))\n  @ResponseBody\n  def getSubresults(@PathVariable(\"uid\") uid: Int, @PathVariable(\"cid\") cid: Int, @PathVariable(\"tid\") tid: Int,\n                    @PathVariable(\"sid\") sid: Int, req: HttpServletRequest, res: HttpServletResponse): List[SubTaskResult] = {\n    val user = authService.authorize(req, res)\n    val task = taskService.getOne(tid).get\n\n    val adminPrivileged = (user.hasRole(GlobalRole.ADMIN, GlobalRole.MODERATOR)\n      || List(CourseRole.DOCENT, CourseRole.TUTOR).contains(courseRegistrationService.getCoursePrivileges(user.id).getOrElse(cid, CourseRole.STUDENT)))\n    val privileged = (user.id == uid && !task.isPrivate) || adminPrivileged\n\n    if (!privileged) {\n      throw new ForbiddenException()\n    }\n\n    if (task.hideResult && !adminPrivileged) {\n      List()\n    } else {\n      checkerConfigurationService.getAll(cid, tid).headOption match {\n        case Some(cc) => checkrunnerSubTaskServer.listResultsWithTasks(cc.id, sid)\n        case None => throw new ResourceNotFoundException()\n      }\n    }\n  }\n\n  /**\n    * Submit a file for a task\n    *\n    * @param uid  User id\n    * @param cid  Course id\n    * @param tid  Task id\n    * @param file Mutipart file\n    * @param req  Http request\n    * @param res  Http response\n    * @return Submission information\n    */\n  @PostMapping(value = Array(\"/{uid}/courses/{cid}/tasks/{tid}/submissions\"))\n  @ResponseBody\n  def submit(@PathVariable(\"uid\") uid: Int, @PathVariable(\"cid\") cid: Int, @PathVariable(\"tid\") tid: Int,\n             @RequestParam file: MultipartFile,\n             req: HttpServletRequest, res: HttpServletResponse): Submission = {\n    val user = authService.authorize(req, res)\n    val someCourseRole = courseRegistration.getCourseRoleOfUser(cid, user.id)\n    val noPrivateAccess = someCourseRole.contains(CourseRole.STUDENT) && user.globalRole != GlobalRole.ADMIN\n\n    if (user.id == uid) {\n      this.taskService.getOne(tid) match {\n        case Some(task) =>\n          // Not allow Students to Submit to Private Tasks\n          if (noPrivateAccess && task.isPrivate) {\n            throw new ForbiddenException()\n          }\n\n          val expectedMediaType = task.mediaType\n          val currentMediaType = req.getContentType // Transform to media type (Content Type != Media Type)\n          if (task.deadline.isDefined && Instant.now().isAfter(Instant.parse(task.deadline.get))) {\n            throw new BadRequestException(\"Deadline Before Now\")\n          }\n          if (true) { // TODO: Check media type compatibility\n            val submission = submissionService.create(uid, tid)\n            storageService.storeSolutionFileInBucket(submission.id, file)\n            checkerConfigurationService.getAll(cid, tid).foreach(cc => {\n              val checkerService = checkerServiceFactoryService(cc.checkerType)\n              checkerService.notify(tid, submission.id, cc, user)\n            })\n            submission\n\n          } else {\n            throw new BadRequestException(\"Unsupported Media Type\")\n          }\n        case _ => throw new ResourceNotFoundException()\n      }\n    } else {\n      throw new ForbiddenException()\n    }\n  }\n\n  /**\n    * Restart the submission process\n    *\n    * @param uid User id\n    * @param cid Course id\n    * @param tid Task id\n    * @param sid Task id\n    * @param req Http request\n    * @param res Http response\n    * @return\n    */\n  @PutMapping(value = Array(\"/{uid}/courses/{cid}/tasks/{tid}/submissions/{sid}\"))\n  def resubmit(@PathVariable(\"uid\") uid: Int, @PathVariable(\"cid\") cid: Int, @PathVariable(\"tid\") tid: Int, @PathVariable(\"sid\") sid: Int,\n               req: HttpServletRequest, res: HttpServletResponse): Unit = {\n    val user = authService.authorize(req, res)\n    val task = taskService.getOne(tid).get\n    val someCourseRole = courseRegistration.getCourseRoleOfUser(cid, user.id)\n    val noPrivateAccess = someCourseRole.contains(CourseRole.STUDENT) && user.globalRole != GlobalRole.ADMIN\n\n    val allowed = user.id == uid && !(noPrivateAccess && task.isPrivate)\n    if (allowed) {\n      submissionService.getOne(sid, uid) match {\n        case Some(submission) =>\n          if (!submission.isInBlockStorage) {\n            throw new ConflictException(\"resubmit is not supported for this submission\")\n          }\n\n          submissionService.clearResults(sid, uid)\n          checkerConfigurationService.getAll(cid, tid).foreach(cc => {\n            val checkerService = checkerServiceFactoryService(cc.checkerType)\n            checkerService.notify(tid, sid, cc, user)\n          })\n        case None => throw new ResourceNotFoundException()\n      }\n    } else {\n      throw new ForbiddenException()\n    }\n  }\n\n  /**\n    * Restart the submission process for all submissions of task\n    *\n    * @param cid Course id\n    * @param tid Task id\n    * @param req Http request\n    * @param res Http response\n    * @return\n    */\n  @PostMapping(value = Array(\"/{uid}/courses/{cid}/tasks/{tid}/resubmitAll\"))\n  def resubmitAll(@PathVariable(\"uid\") uid: Int, @PathVariable(\"cid\") cid: Int, @PathVariable(\"tid\") tid: Int,\n                  req: HttpServletRequest, res: HttpServletResponse): Unit = {\n    val user = authService.authorize(req, res)\n\n    val adminPrivileged = (user.hasRole(GlobalRole.ADMIN, GlobalRole.MODERATOR)\n      || List(CourseRole.DOCENT, CourseRole.TUTOR).contains(courseRegistrationService.getCoursePrivileges(user.id).getOrElse(cid, CourseRole.STUDENT)))\n\n    if (adminPrivileged) {\n      submissionService.getAllByTask(cid, tid).filter(s => s.isInBlockStorage).foreach(submission => {\n        submissionService.clearResults(submission.id, submission.userID.get)\n        checkerConfigurationService.getAll(cid, tid).foreach(cc => {\n          val checkerService = checkerServiceFactoryService(cc.checkerType)\n          checkerService.notify(tid, submission.id, cc, user)\n        })\n      })\n    } else {\n      throw new ForbiddenException()\n    }\n  }\n\n  /**\n    * Get the status of submission\n    *\n    * @param uid User id\n    * @param cid Course id\n    * @param tid Task id\n    * @param sid Task id\n    * @param req Http request\n    * @param res Http response\n    * @return A submission state\n    */\n  @GetMapping(value = Array(\"/{uid}/courses/{cid}/tasks/{tid}/submissions/{sid}\"))\n  @ResponseBody\n  def getOne(@PathVariable uid: Int, @PathVariable cid: Int, @PathVariable tid: Int, @PathVariable sid: Int,\n             req: HttpServletRequest, res: HttpServletResponse): Submission = {\n    val user = authService.authorize(req, res)\n    val task = taskService.getOne(tid).get\n\n    val adminPrivileged = (user.hasRole(GlobalRole.ADMIN, GlobalRole.MODERATOR)\n      || List(CourseRole.DOCENT, CourseRole.TUTOR).contains(courseRegistrationService.getCoursePrivileges(user.id).getOrElse(cid, CourseRole.STUDENT)))\n    val privileged = (user.id == uid && !task.isPrivate) || adminPrivileged\n\n    if (privileged) {\n      submissionService.getOne(sid, uid, adminPrivileged) match {\n        case Some(submission) =>\n          submissionService.getOrHidden(submission, task.hideResult, adminPrivileged)\n        case None => throw new ResourceNotFoundException()\n      }\n    } else {\n      throw new ForbiddenException()\n    }\n  }\n}\n", "package de.thm.ii.fbs.services.persistence\n\nimport de.thm.ii.fbs.model.{CheckrunnerSubTask, CheckrunnerSubTaskResult, SubTaskResult}\nimport de.thm.ii.fbs.util.DB\nimport org.springframework.beans.factory.annotation.Autowired\nimport org.springframework.jdbc.core.JdbcTemplate\nimport org.springframework.stereotype.Component\n\nimport java.math.BigInteger\nimport java.sql.{ResultSet, SQLException}\n\n/**\n  * CheckrunnerSubTaskService handles persistance for Checkrunner\n  */\n@Component\nclass CheckrunnerSubTaskService {\n  @Autowired\n  private implicit val jdbc: JdbcTemplate = null\n\n  /**\n    * Get all CheckrunnerSubTasks for a configuration\n    * @param configurationId the configuration id for which to get the checkrunners\n    * @return List of subtasks\n    */\n  def getAll(configurationId: Int): List[CheckrunnerSubTask] = DB.query(\n    \"SELECT configuration_id, sub_task_id, points, name FROM checkrunner_sub_task WHERE configuration_id = ?\",\n    (res, _) => parseSubTaskResult(res),\n    configurationId\n  )\n\n  /**\n    * Get subtask by name\n    * @param configurationId the configuration id for which to get the subtasks\n    * @param name the name of the subtasks\n    * @return Option of subtasks\n    */\n  def get(configurationId: Int, name: String): Option[CheckrunnerSubTask] = DB.query(\n    \"SELECT configuration_id, sub_task_id, name, points FROM checkrunner_sub_task WHERE configuration_id = ? AND name = ?\",\n    (res, _) => parseSubTaskResult(res),\n    configurationId, name\n  ).headOption\n\n  /**\n    * Create a new subtask\n    * @param configurationId the configuration id for which to get the subtasks\n    * @param name the name of the course\n    * @param points the max points\n    * @return The new Checkrunner\n    */\n  def create(configurationId: Int, name: String, points: Int): CheckrunnerSubTask = DB.insert(\n    \"INSERT INTO checkrunner_sub_task (configuration_id, name, points) VALUES (?, ?, ?)\",\n    configurationId, name, points\n  ).map(gk => gk(0).asInstanceOf[BigInteger].intValue())\n    .flatMap(_ => get(configurationId, name)) match {\n    case Some(course) => course\n    case None => throw new SQLException(\"Course could not be created\")\n  }\n\n  /**\n    * Get all results for a subission\n    * @param configurationId The configuration id for which to get the results\n    * @param submissionId The id of the submission to get the subtasks results\n    * @return List of subtasks\n    */\n  def listResults(configurationId: Int, submissionId: Int): List[CheckrunnerSubTaskResult] = DB.query(\n    \"SELECT configuration_id, sub_task_id, submission_id, points FROM checkrunner_sub_task_result WHERE configuration_id = ? AND submission_id = ?\",\n    (res, _) => parseSubTaskResultResult(res),\n    configurationId, submissionId\n  )\n\n  /**\n    * Get subtask by name\n    * @param configurationId the configuration id for which to get the result\n    * @param subTaskId the id of the sub task to get result\n    * @param submissionId the submission id of the sub task to get result\n    * @return List of subTaskResults\n    */\n  def getResult(configurationId: Int, subTaskId: Int, submissionId: Int): Option[CheckrunnerSubTaskResult] = DB.query(\n    \"SELECT configuration_id, sub_task_id, submission_id, points FROM checkrunner_sub_task_result WHERE \" +\n      \"configuration_id = ? AND sub_task_id = ? AND submission_id = ?\",\n    (res, _) => parseSubTaskResultResult(res),\n    configurationId, subTaskId, submissionId\n  ).headOption\n\n  /**\n    * Create a new submission result\n    * @param configurationId the configuration id\n    * @param subTaskId the id of the subTask\n    * @param submissionId the id of the submission\n    * @param points the max points\n    * @return The new Checkrunner\n    */\n  def createResult(configurationId: Int, subTaskId: Int, submissionId: Int, points: Int): Unit = DB.insert(\n    \"INSERT INTO checkrunner_sub_task_result (configuration_id, sub_task_id, submission_id, points) VALUES (?, ?, ?, ?)\",\n    configurationId, subTaskId, submissionId, points\n  )\n\n  /**\n    * Gets or creates a subtask\n    * @param configurationId the configuration id for which to get the checkrunners\n    * @param name the name of the course\n    * @param maxPoints the max points\n    * @return The new Checkrunner\n    */\n  def getOrCrate(configurationId: Int, name: String, maxPoints: Int): CheckrunnerSubTask = get(configurationId, name)\n    .getOrElse(create(configurationId, name, maxPoints))\n\n  /**\n    * Get a list of all subtask results with task information\n    * @param configurationId The configuration id for which to get the results\n    * @param submissionId The id of the submission to get the subtasks results\n    * @return List of subtasks results with tasks\n    */\n  def listResultsWithTasks(configurationId: Int, submissionId: Int): List[SubTaskResult] = DB.query(\n    \"SELECT st.name, st.points AS max_points, str.points FROM checkrunner_sub_task_result str JOIN \" +\n      \"checkrunner_sub_task st ON str.sub_task_id = st.sub_task_id \" +\n      \"WHERE str.configuration_id = ? AND str.submission_id = ?\",\n    (res, _) => parseSubTaskResultWithSubTask(res),\n    configurationId, submissionId\n  )\n\n  /**\n    * Parse SQL Query sub task results\n    * @param res SQL Query result\n    * @return CheckrunnerSubTask\n    */\n  private def parseSubTaskResult(res: ResultSet) = CheckrunnerSubTask(\n    configurationId = res.getInt(\"configuration_id\"),\n    subTaskId = res.getInt(\"sub_task_id\"),\n    name = res.getString(\"name\"),\n    points = res.getInt(\"points\")\n  )\n\n  /**\n    * Parse SQL Query sub task results\n    * @param res SQL Query result\n    * @return CheckrunnerSubTask\n    */\n  private def parseSubTaskResultResult(res: ResultSet) = CheckrunnerSubTaskResult(\n    configurationId = res.getInt(\"configuration_id\"),\n    subTaskId = res.getInt(\"sub_task_id\"),\n    submissionId = res.getInt(\"submission_id\"),\n    points = res.getInt(\"points\")\n  )\n\n  /**\n    * Parse SQL Query sub task result + sub task result\n    * @param res SQL Query result\n    * @return SubTaskResult\n    */\n  private def parseSubTaskResultWithSubTask(res: ResultSet) = SubTaskResult(\n    name = res.getString(\"name\"),\n    points = res.getInt(\"points\"),\n    maxPoints = res.getInt(\"max_points\")\n  )\n}\n"], "fixing_code": ["package de.thm.ii.fbs.controller\n\nimport de.thm.ii.fbs.controller.exception.{BadRequestException, ConflictException, ForbiddenException, ResourceNotFoundException}\nimport de.thm.ii.fbs.model.{CourseRole, GlobalRole, SubTaskResult, Submission}\nimport de.thm.ii.fbs.services.checker.CheckerServiceFactoryService\nimport de.thm.ii.fbs.services.persistence._\nimport de.thm.ii.fbs.services.security.AuthService\nimport org.springframework.beans.factory.annotation.Autowired\nimport org.springframework.web.bind.annotation._\nimport org.springframework.web.multipart.MultipartFile\n\nimport java.time.Instant\nimport javax.servlet.http.{HttpServletRequest, HttpServletResponse}\n\n/**\n  * Submission controller implement routes for submitting task and receive results\n  */\n@RestController\n@CrossOrigin\n@RequestMapping(path = Array(\"/api/v1/users\"))\nclass SubmissionController {\n  @Autowired\n  private val authService: AuthService = null\n  @Autowired\n  private val storageService: StorageService = null\n  @Autowired\n  private val submissionService: SubmissionService = null\n  @Autowired\n  private val taskService: TaskService = null\n  @Autowired\n  private val checkerConfigurationService: CheckrunnerConfigurationService = null\n  @Autowired\n  private val checkerServiceFactoryService: CheckerServiceFactoryService = null\n  @Autowired\n  private val courseRegistrationService: CourseRegistrationService = null\n  @Autowired\n  private val checkrunnerSubTaskServer: CheckrunnerSubTaskService = null\n  @Autowired\n  private val courseRegistration: CourseRegistrationService = null\n\n  /**\n    * Get a list of all submissions for a task\n    *\n    * @param uid User id\n    * @param cid Course id\n    * @param tid Task id\n    * @param req Http request\n    * @param res Http response\n    * @return Submission results\n    */\n  @GetMapping(value = Array(\"/{uid}/courses/{cid}/tasks/{tid}/submissions\"))\n  @ResponseBody\n  def getAll(@PathVariable(\"uid\") uid: Int, @PathVariable(\"cid\") cid: Int, @PathVariable(\"tid\") tid: Int,\n             req: HttpServletRequest, res: HttpServletResponse): List[Submission] = {\n    val user = authService.authorize(req, res)\n    val task = taskService.getOne(tid).get\n\n    val adminPrivileged = (user.hasRole(GlobalRole.ADMIN, GlobalRole.MODERATOR)\n      || List(CourseRole.DOCENT, CourseRole.TUTOR).contains(courseRegistrationService.getCoursePrivileges(user.id).getOrElse(cid, CourseRole.STUDENT)))\n    val privileged = (user.id == uid && !task.isPrivate) || adminPrivileged\n\n    if (privileged) {\n      submissionService.getAll(uid, cid, tid, adminPrivileged || task.mediaType == \"application/x-spreadsheet\")\n        .map(submission => submissionService.getOrHidden(submission, task.hideResult, adminPrivileged))\n    } else {\n      throw new ForbiddenException()\n    }\n  }\n\n  /**\n    * Get a list of all submissions for a task\n    *\n    * @param uid User id\n    * @param cid Course id\n    * @param tid Task id\n    * @param sid Submission id\n    * @param req Http request\n    * @param res Http response\n    * @return Submission results\n    */\n  @GetMapping(value = Array(\"/{uid}/courses/{cid}/tasks/{tid}/submissions/{sid}/subresults\"))\n  @ResponseBody\n  def getSubresults(@PathVariable(\"uid\") uid: Int, @PathVariable(\"cid\") cid: Int, @PathVariable(\"tid\") tid: Int,\n                    @PathVariable(\"sid\") sid: Int, req: HttpServletRequest, res: HttpServletResponse): List[SubTaskResult] = {\n    val user = authService.authorize(req, res)\n    val task = taskService.getOne(tid).get\n\n    val adminPrivileged = (user.hasRole(GlobalRole.ADMIN, GlobalRole.MODERATOR)\n      || List(CourseRole.DOCENT, CourseRole.TUTOR).contains(courseRegistrationService.getCoursePrivileges(user.id).getOrElse(cid, CourseRole.STUDENT)))\n    val privileged = (user.id == uid && !task.isPrivate) || adminPrivileged\n\n    if (!privileged) {\n      throw new ForbiddenException()\n    }\n\n    if (task.hideResult && !adminPrivileged) {\n      List()\n    } else {\n      checkerConfigurationService.getAll(cid, tid).headOption match {\n        case Some(cc) => checkrunnerSubTaskServer.listResultsWithTasks(uid, cc.id, sid)\n        case None => throw new ResourceNotFoundException()\n      }\n    }\n  }\n\n  /**\n    * Submit a file for a task\n    *\n    * @param uid  User id\n    * @param cid  Course id\n    * @param tid  Task id\n    * @param file Mutipart file\n    * @param req  Http request\n    * @param res  Http response\n    * @return Submission information\n    */\n  @PostMapping(value = Array(\"/{uid}/courses/{cid}/tasks/{tid}/submissions\"))\n  @ResponseBody\n  def submit(@PathVariable(\"uid\") uid: Int, @PathVariable(\"cid\") cid: Int, @PathVariable(\"tid\") tid: Int,\n             @RequestParam file: MultipartFile,\n             req: HttpServletRequest, res: HttpServletResponse): Submission = {\n    val user = authService.authorize(req, res)\n    val someCourseRole = courseRegistration.getCourseRoleOfUser(cid, user.id)\n    val noPrivateAccess = someCourseRole.contains(CourseRole.STUDENT) && user.globalRole != GlobalRole.ADMIN\n\n    if (user.id == uid) {\n      this.taskService.getOne(tid) match {\n        case Some(task) =>\n          // Not allow Students to Submit to Private Tasks\n          if (noPrivateAccess && task.isPrivate) {\n            throw new ForbiddenException()\n          }\n\n          val expectedMediaType = task.mediaType\n          val currentMediaType = req.getContentType // Transform to media type (Content Type != Media Type)\n          if (task.deadline.isDefined && Instant.now().isAfter(Instant.parse(task.deadline.get))) {\n            throw new BadRequestException(\"Deadline Before Now\")\n          }\n          if (true) { // TODO: Check media type compatibility\n            val submission = submissionService.create(uid, tid)\n            storageService.storeSolutionFileInBucket(submission.id, file)\n            checkerConfigurationService.getAll(cid, tid).foreach(cc => {\n              val checkerService = checkerServiceFactoryService(cc.checkerType)\n              checkerService.notify(tid, submission.id, cc, user)\n            })\n            submission\n\n          } else {\n            throw new BadRequestException(\"Unsupported Media Type\")\n          }\n        case _ => throw new ResourceNotFoundException()\n      }\n    } else {\n      throw new ForbiddenException()\n    }\n  }\n\n  /**\n    * Restart the submission process\n    *\n    * @param uid User id\n    * @param cid Course id\n    * @param tid Task id\n    * @param sid Task id\n    * @param req Http request\n    * @param res Http response\n    * @return\n    */\n  @PutMapping(value = Array(\"/{uid}/courses/{cid}/tasks/{tid}/submissions/{sid}\"))\n  def resubmit(@PathVariable(\"uid\") uid: Int, @PathVariable(\"cid\") cid: Int, @PathVariable(\"tid\") tid: Int, @PathVariable(\"sid\") sid: Int,\n               req: HttpServletRequest, res: HttpServletResponse): Unit = {\n    val user = authService.authorize(req, res)\n    val task = taskService.getOne(tid).get\n    val someCourseRole = courseRegistration.getCourseRoleOfUser(cid, user.id)\n    val noPrivateAccess = someCourseRole.contains(CourseRole.STUDENT) && user.globalRole != GlobalRole.ADMIN\n\n    val allowed = user.id == uid && !(noPrivateAccess && task.isPrivate)\n    if (allowed) {\n      submissionService.getOne(sid, uid) match {\n        case Some(submission) =>\n          if (!submission.isInBlockStorage) {\n            throw new ConflictException(\"resubmit is not supported for this submission\")\n          }\n\n          submissionService.clearResults(sid, uid)\n          checkerConfigurationService.getAll(cid, tid).foreach(cc => {\n            val checkerService = checkerServiceFactoryService(cc.checkerType)\n            checkerService.notify(tid, sid, cc, user)\n          })\n        case None => throw new ResourceNotFoundException()\n      }\n    } else {\n      throw new ForbiddenException()\n    }\n  }\n\n  /**\n    * Restart the submission process for all submissions of task\n    *\n    * @param cid Course id\n    * @param tid Task id\n    * @param req Http request\n    * @param res Http response\n    * @return\n    */\n  @PostMapping(value = Array(\"/{uid}/courses/{cid}/tasks/{tid}/resubmitAll\"))\n  def resubmitAll(@PathVariable(\"uid\") uid: Int, @PathVariable(\"cid\") cid: Int, @PathVariable(\"tid\") tid: Int,\n                  req: HttpServletRequest, res: HttpServletResponse): Unit = {\n    val user = authService.authorize(req, res)\n\n    val adminPrivileged = (user.hasRole(GlobalRole.ADMIN, GlobalRole.MODERATOR)\n      || List(CourseRole.DOCENT, CourseRole.TUTOR).contains(courseRegistrationService.getCoursePrivileges(user.id).getOrElse(cid, CourseRole.STUDENT)))\n\n    if (adminPrivileged) {\n      submissionService.getAllByTask(cid, tid).filter(s => s.isInBlockStorage).foreach(submission => {\n        submissionService.clearResults(submission.id, submission.userID.get)\n        checkerConfigurationService.getAll(cid, tid).foreach(cc => {\n          val checkerService = checkerServiceFactoryService(cc.checkerType)\n          checkerService.notify(tid, submission.id, cc, user)\n        })\n      })\n    } else {\n      throw new ForbiddenException()\n    }\n  }\n\n  /**\n    * Get the status of submission\n    *\n    * @param uid User id\n    * @param cid Course id\n    * @param tid Task id\n    * @param sid Task id\n    * @param req Http request\n    * @param res Http response\n    * @return A submission state\n    */\n  @GetMapping(value = Array(\"/{uid}/courses/{cid}/tasks/{tid}/submissions/{sid}\"))\n  @ResponseBody\n  def getOne(@PathVariable uid: Int, @PathVariable cid: Int, @PathVariable tid: Int, @PathVariable sid: Int,\n             req: HttpServletRequest, res: HttpServletResponse): Submission = {\n    val user = authService.authorize(req, res)\n    val task = taskService.getOne(tid).get\n\n    val adminPrivileged = (user.hasRole(GlobalRole.ADMIN, GlobalRole.MODERATOR)\n      || List(CourseRole.DOCENT, CourseRole.TUTOR).contains(courseRegistrationService.getCoursePrivileges(user.id).getOrElse(cid, CourseRole.STUDENT)))\n    val privileged = (user.id == uid && !task.isPrivate) || adminPrivileged\n\n    if (privileged) {\n      submissionService.getOne(sid, uid, adminPrivileged) match {\n        case Some(submission) =>\n          submissionService.getOrHidden(submission, task.hideResult, adminPrivileged)\n        case None => throw new ResourceNotFoundException()\n      }\n    } else {\n      throw new ForbiddenException()\n    }\n  }\n}\n", "package de.thm.ii.fbs.services.persistence\n\nimport de.thm.ii.fbs.model.{CheckrunnerSubTask, CheckrunnerSubTaskResult, SubTaskResult}\nimport de.thm.ii.fbs.util.DB\nimport org.springframework.beans.factory.annotation.Autowired\nimport org.springframework.jdbc.core.JdbcTemplate\nimport org.springframework.stereotype.Component\n\nimport java.math.BigInteger\nimport java.sql.{ResultSet, SQLException}\n\n/**\n  * CheckrunnerSubTaskService handles persistance for Checkrunner\n  */\n@Component\nclass CheckrunnerSubTaskService {\n  @Autowired\n  private implicit val jdbc: JdbcTemplate = null\n\n  /**\n    * Get all CheckrunnerSubTasks for a configuration\n    * @param configurationId the configuration id for which to get the checkrunners\n    * @return List of subtasks\n    */\n  def getAll(configurationId: Int): List[CheckrunnerSubTask] = DB.query(\n    \"SELECT configuration_id, sub_task_id, points, name FROM checkrunner_sub_task WHERE configuration_id = ?\",\n    (res, _) => parseSubTaskResult(res),\n    configurationId\n  )\n\n  /**\n    * Get subtask by name\n    * @param configurationId the configuration id for which to get the subtasks\n    * @param name the name of the subtasks\n    * @return Option of subtasks\n    */\n  def get(configurationId: Int, name: String): Option[CheckrunnerSubTask] = DB.query(\n    \"SELECT configuration_id, sub_task_id, name, points FROM checkrunner_sub_task WHERE configuration_id = ? AND name = ?\",\n    (res, _) => parseSubTaskResult(res),\n    configurationId, name\n  ).headOption\n\n  /**\n    * Create a new subtask\n    * @param configurationId the configuration id for which to get the subtasks\n    * @param name the name of the course\n    * @param points the max points\n    * @return The new Checkrunner\n    */\n  def create(configurationId: Int, name: String, points: Int): CheckrunnerSubTask = DB.insert(\n    \"INSERT INTO checkrunner_sub_task (configuration_id, name, points) VALUES (?, ?, ?)\",\n    configurationId, name, points\n  ).map(gk => gk(0).asInstanceOf[BigInteger].intValue())\n    .flatMap(_ => get(configurationId, name)) match {\n    case Some(course) => course\n    case None => throw new SQLException(\"Course could not be created\")\n  }\n\n  /**\n    * Get all results for a subission\n    * @param configurationId The configuration id for which to get the results\n    * @param submissionId The id of the submission to get the subtasks results\n    * @return List of subtasks\n    */\n  def listResults(configurationId: Int, submissionId: Int): List[CheckrunnerSubTaskResult] = DB.query(\n    \"SELECT configuration_id, sub_task_id, submission_id, points FROM checkrunner_sub_task_result WHERE configuration_id = ? AND submission_id = ?\",\n    (res, _) => parseSubTaskResultResult(res),\n    configurationId, submissionId\n  )\n\n  /**\n    * Get subtask by name\n    * @param configurationId the configuration id for which to get the result\n    * @param subTaskId the id of the sub task to get result\n    * @param submissionId the submission id of the sub task to get result\n    * @return List of subTaskResults\n    */\n  def getResult(configurationId: Int, subTaskId: Int, submissionId: Int): Option[CheckrunnerSubTaskResult] = DB.query(\n    \"SELECT configuration_id, sub_task_id, submission_id, points FROM checkrunner_sub_task_result WHERE \" +\n      \"configuration_id = ? AND sub_task_id = ? AND submission_id = ?\",\n    (res, _) => parseSubTaskResultResult(res),\n    configurationId, subTaskId, submissionId\n  ).headOption\n\n  /**\n    * Create a new submission result\n    * @param configurationId the configuration id\n    * @param subTaskId the id of the subTask\n    * @param submissionId the id of the submission\n    * @param points the max points\n    * @return The new Checkrunner\n    */\n  def createResult(configurationId: Int, subTaskId: Int, submissionId: Int, points: Int): Unit = DB.insert(\n    \"INSERT INTO checkrunner_sub_task_result (configuration_id, sub_task_id, submission_id, points) VALUES (?, ?, ?, ?)\",\n    configurationId, subTaskId, submissionId, points\n  )\n\n  /**\n    * Gets or creates a subtask\n    * @param configurationId the configuration id for which to get the checkrunners\n    * @param name the name of the course\n    * @param maxPoints the max points\n    * @return The new Checkrunner\n    */\n  def getOrCrate(configurationId: Int, name: String, maxPoints: Int): CheckrunnerSubTask = get(configurationId, name)\n    .getOrElse(create(configurationId, name, maxPoints))\n\n  /**\n    * Get a list of all subtask results with task information\n    * @param configurationId The configuration id for which to get the results\n    * @param submissionId The id of the submission to get the subtasks results\n    * @return List of subtasks results with tasks\n    */\n  def listResultsWithTasks(userId: Int, configurationId: Int, submissionId: Int): List[SubTaskResult] = DB.query(\n    \"SELECT st.name, st.points AS max_points, str.points FROM checkrunner_sub_task_result str \" +\n      \"JOIN checkrunner_sub_task st ON str.sub_task_id = st.sub_task_id \" +\n      \"JOIN user_task_submission uts ON str.submission_id = uts.submission_id \" +\n      \"WHERE str.configuration_id = ? AND str.submission_id = ? AND uts.user_id = ?\",\n    (res, _) => parseSubTaskResultWithSubTask(res),\n    configurationId, submissionId, userId\n  )\n\n  /**\n    * Parse SQL Query sub task results\n    * @param res SQL Query result\n    * @return CheckrunnerSubTask\n    */\n  private def parseSubTaskResult(res: ResultSet) = CheckrunnerSubTask(\n    configurationId = res.getInt(\"configuration_id\"),\n    subTaskId = res.getInt(\"sub_task_id\"),\n    name = res.getString(\"name\"),\n    points = res.getInt(\"points\")\n  )\n\n  /**\n    * Parse SQL Query sub task results\n    * @param res SQL Query result\n    * @return CheckrunnerSubTask\n    */\n  private def parseSubTaskResultResult(res: ResultSet) = CheckrunnerSubTaskResult(\n    configurationId = res.getInt(\"configuration_id\"),\n    subTaskId = res.getInt(\"sub_task_id\"),\n    submissionId = res.getInt(\"submission_id\"),\n    points = res.getInt(\"points\")\n  )\n\n  /**\n    * Parse SQL Query sub task result + sub task result\n    * @param res SQL Query result\n    * @return SubTaskResult\n    */\n  private def parseSubTaskResultWithSubTask(res: ResultSet) = SubTaskResult(\n    name = res.getString(\"name\"),\n    points = res.getInt(\"points\"),\n    maxPoints = res.getInt(\"max_points\")\n  )\n}\n"], "filenames": ["modules/fbs-core/api/src/main/scala/de/thm/ii/fbs/controller/SubmissionController.scala", "modules/fbs-core/api/src/main/scala/de/thm/ii/fbs/services/persistence/CheckrunnerSubTaskService.scala"], "buggy_code_start_loc": [100, 114], "buggy_code_end_loc": [101, 120], "fixing_code_start_loc": [100, 114], "fixing_code_end_loc": [101, 121], "type": "CWE-863", "message": "thmmniii/fbs-core is an open source feedback system for students. In versions prior to 1.5.3 when querying `subresults`, it is possible to query `subresults` from other users due to insufficient authorisation. This is only possible for logged-in users and it is not possible to associate the subresults with a specific user. This bug was fixed in commit `f1ae67d8bb2`and released with version 1.5.3. Users are advised to upgrade. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2023-27485", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-07T19:15:12.833", "lastModified": "2023-03-14T16:36:56.033", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "thmmniii/fbs-core is an open source feedback system for students. In versions prior to 1.5.3 when querying `subresults`, it is possible to query `subresults` from other users due to insufficient authorisation. This is only possible for logged-in users and it is not possible to associate the subresults with a specific user. This bug was fixed in commit `f1ae67d8bb2`and released with version 1.5.3. Users are advised to upgrade. There are no known workarounds for this issue."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:thm:feedbacksystem:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.5.3", "matchCriteriaId": "6C4ACDAC-3751-4E9C-A323-AB0327721F9C"}]}]}], "references": [{"url": "https://github.com/thm-mni-ii/feedbacksystem/commit/f1ae67d8bb2286a8eb15949038473d41b1358493", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/thm-mni-ii/feedbacksystem/releases/tag/v1.5.3", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/thm-mni-ii/feedbacksystem/security/advisories/GHSA-fhq8-p3w6-mmgr", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://thm-mni-ii.github.io/feedbacksystem/api-docs/#tag/Submission/operation/getCourseTaskSubmissionSubresults", "source": "security-advisories@github.com", "tags": ["Product"]}]}, "github_commit_url": "https://github.com/thm-mni-ii/feedbacksystem/commit/f1ae67d8bb2286a8eb15949038473d41b1358493"}}