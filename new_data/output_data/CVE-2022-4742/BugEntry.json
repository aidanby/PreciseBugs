{"buggy_code": ["'use strict';\n\nvar each = require('foreach');\nmodule.exports = api;\n\n\n/**\n * Convenience wrapper around the api.\n * Calls `.get` when called with an `object` and a `pointer`.\n * Calls `.set` when also called with `value`.\n * If only supplied `object`, returns a partially applied function, mapped to the object.\n *\n * @param {Object} obj\n * @param {String|Array} pointer\n * @param value\n * @returns {*}\n */\n\nfunction api (obj, pointer, value) {\n    // .set()\n    if (arguments.length === 3) {\n        return api.set(obj, pointer, value);\n    }\n    // .get()\n    if (arguments.length === 2) {\n        return api.get(obj, pointer);\n    }\n    // Return a partially applied function on `obj`.\n    var wrapped = api.bind(api, obj);\n\n    // Support for oo style\n    for (var name in api) {\n        if (api.hasOwnProperty(name)) {\n            wrapped[name] = api[name].bind(wrapped, obj);\n        }\n    }\n    return wrapped;\n}\n\n\n/**\n * Lookup a json pointer in an object\n *\n * @param {Object} obj\n * @param {String|Array} pointer\n * @returns {*}\n */\napi.get = function get (obj, pointer) {\n    var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer);\n\n    for (var i = 0; i < refTokens.length; ++i) {\n        var tok = refTokens[i];\n        if (!(typeof obj == 'object' && tok in obj)) {\n            throw new Error('Invalid reference token: ' + tok);\n        }\n        obj = obj[tok];\n    }\n    return obj;\n};\n\n/**\n * Sets a value on an object\n *\n * @param {Object} obj\n * @param {String|Array} pointer\n * @param value\n */\napi.set = function set (obj, pointer, value) {\n    var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer),\n      nextTok = refTokens[0];\n\n    if (refTokens.length === 0) {\n      throw Error('Can not set the root object');\n    }\n\n    for (var i = 0; i < refTokens.length - 1; ++i) {\n        var tok = refTokens[i];\n        if (tok === \"__proto__\" || tok === \"constructor\" || tok === \"prototype\") {\n            continue\n        }\n        if (tok === '-' && Array.isArray(obj)) {\n          tok = obj.length;\n        }\n        nextTok = refTokens[i + 1];\n\n        if (!(tok in obj)) {\n            if (nextTok.match(/^(\\d+|-)$/)) {\n                obj[tok] = [];\n            } else {\n                obj[tok] = {};\n            }\n        }\n        obj = obj[tok];\n    }\n    if (nextTok === '-' && Array.isArray(obj)) {\n      nextTok = obj.length;\n    }\n    obj[nextTok] = value;\n    return this;\n};\n\n/**\n * Removes an attribute\n *\n * @param {Object} obj\n * @param {String|Array} pointer\n */\napi.remove = function (obj, pointer) {\n    var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer);\n    var finalToken = refTokens[refTokens.length -1];\n    if (finalToken === undefined) {\n        throw new Error('Invalid JSON pointer for remove: \"' + pointer + '\"');\n    }\n\n    var parent = api.get(obj, refTokens.slice(0, -1));\n    if (Array.isArray(parent)) {\n      var index = +finalToken;\n      if (finalToken === '' && isNaN(index)) {\n        throw new Error('Invalid array index: \"' + finalToken + '\"');\n      }\n\n      Array.prototype.splice.call(parent, index, 1);\n    } else {\n      delete parent[finalToken];\n    }\n};\n\n/**\n * Returns a (pointer -> value) dictionary for an object\n *\n * @param obj\n * @param {function} descend\n * @returns {}\n */\napi.dict = function dict (obj, descend) {\n    var results = {};\n    api.walk(obj, function (value, pointer) {\n        results[pointer] = value;\n    }, descend);\n    return results;\n};\n\n/**\n * Iterates over an object\n * Iterator: function (value, pointer) {}\n *\n * @param obj\n * @param {function} iterator\n * @param {function} descend\n */\napi.walk = function walk (obj, iterator, descend) {\n    var refTokens = [];\n\n    descend = descend || function (value) {\n        var type = Object.prototype.toString.call(value);\n        return type === '[object Object]' || type === '[object Array]';\n    };\n\n    (function next (cur) {\n        each(cur, function (value, key) {\n            refTokens.push(String(key));\n            if (descend(value)) {\n                next(value);\n            } else {\n                iterator(value, api.compile(refTokens));\n            }\n            refTokens.pop();\n        });\n    }(obj));\n};\n\n/**\n * Tests if an object has a value for a json pointer\n *\n * @param obj\n * @param pointer\n * @returns {boolean}\n */\napi.has = function has (obj, pointer) {\n    try {\n        api.get(obj, pointer);\n    } catch (e) {\n        return false;\n    }\n    return true;\n};\n\n/**\n * Escapes a reference token\n *\n * @param str\n * @returns {string}\n */\napi.escape = function escape (str) {\n    return str.toString().replace(/~/g, '~0').replace(/\\//g, '~1');\n};\n\n/**\n * Unescapes a reference token\n *\n * @param str\n * @returns {string}\n */\napi.unescape = function unescape (str) {\n    return str.replace(/~1/g, '/').replace(/~0/g, '~');\n};\n\n/**\n * Converts a json pointer into a array of reference tokens\n *\n * @param pointer\n * @returns {Array}\n */\napi.parse = function parse (pointer) {\n    if (pointer === '') { return []; }\n    if (pointer.charAt(0) !== '/') { throw new Error('Invalid JSON pointer: ' + pointer); }\n    return pointer.substring(1).split(/\\//).map(api.unescape);\n};\n\n/**\n * Builds a json pointer from a array of reference tokens\n *\n * @param refTokens\n * @returns {string}\n */\napi.compile = function compile (refTokens) {\n    if (refTokens.length === 0) { return ''; }\n    return '/' + refTokens.map(api.escape).join('/');\n};\n", "/*global describe, it, beforeEach*/\nif (typeof pointer === 'undefined') {\n    var pointer   = require('..'),\n        chai      = require('chai'),\n        each      = require('foreach'),\n        immutable = require('seamless-immutable');\n}\n\nvar expect = chai.expect;\n\n\nchai.should();\n\ndescribe('json-api', function () {\n    'use strict';\n\n    var rfcExample,\n        rfcValues,\n        rfcParsed;\n\n    function resetExamples() {\n        rfcExample = {\n            \"foo\":      [\"bar\", \"baz\"],\n            \"bar\":      {\"baz\": 10},\n            \"\":         0,\n            \"a/b\":      1,\n            \"c%d\":      2,\n            \"e^f\":      3,\n            \"g|h\":      4,\n            \"i\\\\j\":     5,\n            \"k\\\"l\":     6,\n            \" \":        7,\n            \"m~n\":      8\n        };\n\n        rfcValues = {\n            \"\":         rfcExample,\n            \"/foo\":     rfcExample.foo,\n            \"/foo/0\":   \"bar\",\n            \"/bar\":     rfcExample.bar,\n            \"/bar/baz\": 10,\n            \"/\":        0,\n            \"/a~1b\":    1,\n            \"/c%d\":     2,\n            \"/e^f\":     3,\n            \"/g|h\":     4,\n            \"/i\\\\j\":    5,\n            \"/k\\\"l\":    6,\n            \"/ \":       7,\n            \"/m~0n\":    8\n        };\n\n        rfcParsed = {\n            \"\":         { tokens: [],             value: rfcExample },\n            \"/foo\":     { tokens: [\"foo\"],        value: rfcExample.foo },\n            \"/foo/0\":   { tokens: [\"foo\", \"0\"],   value: \"bar\" },\n            \"/bar\":     { tokens: [\"bar\"],        value: rfcExample.bar },\n            \"/bar/baz\": { tokens: [\"bar\", \"baz\"], value: 10 },\n            \"/\":        { tokens: [\"\"],           value: 0 },\n            \"/a~1b\":    { tokens: [\"a/b\"],        value: 1 },\n            \"/c%d\":     { tokens: [\"c%d\"],        value: 2 },\n            \"/e^f\":     { tokens: [\"e^f\"],        value: 3 },\n            \"/g|h\":     { tokens: [\"g|h\"],        value: 4 },\n            \"/i\\\\j\":    { tokens: [\"i\\\\j\"],       value: 5 },\n            \"/k\\\"l\":    { tokens: [\"k\\\"l\"],       value: 6 },\n            \"/ \":       { tokens: [\" \"],          value: 7 },\n            \"/m~0n\":    { tokens: [\"m~n\"],        value: 8 }\n        };\n    }\n    resetExamples();\n    beforeEach(resetExamples);\n\n    describe('#get', function () {\n\n        it('should work for root element', function () {\n            var obj = {};\n            pointer.get(obj, '').should.equal(obj);\n        });\n\n        each(Object.keys(rfcValues), function (p) {\n            it('should work for \"' + p + '\"', function () {\n                var expectedValue = rfcValues[p];\n                pointer.get(rfcExample, p).should.equal(expectedValue);\n            });\n        });\n\n        each(Object.keys(rfcParsed), function (p) {\n            var tokens = immutable(rfcParsed[p].tokens);\n            it('should work for ' + JSON.stringify(tokens), function () {\n                var expectedValue = rfcParsed[p].value;\n                pointer.get(rfcExample, tokens).should.equal(expectedValue);\n            });\n        });\n\n        it('should work for with inherited properties', function () {\n            function O () {}\n            O.prototype.x = 10;\n            pointer.get(new O, '/x').should.equal(10);\n            pointer.get(Object.create({ x: 10 }), '/x').should.equal(10)\n        });\n    });\n\n    describe('#set', function () {\n        it('should throw when try to set the root object', function () {\n            expect(pointer.set.bind(pointer, {}, '', 'bla')).to.throw(Error);\n        });\n\n        it('should set a value on an object with pointer', function () {\n            var obj = {\n                existing: 'bla'\n            };\n\n            pointer.set(obj, '/new-value/bla', 'expected');\n            obj['new-value'].bla.should.equal('expected');\n        });\n\n        it('should set a value on an object with tokens', function () {\n            var obj = {\n                existing: 'bla'\n            };\n\n            pointer.set(obj, immutable(['new-value', 'bla']), 'expected');\n            obj['new-value'].bla.should.equal('expected');\n        });\n\n        it('should work on first level with pointer', function () {\n            var obj = {\n                existing: 'bla'\n            };\n\n            pointer.set(obj, '/first-level', 'expected');\n            obj['first-level'].should.equal('expected');\n        });\n\n        it('should work on first level with tokens', function () {\n            var obj = {\n                existing: 'bla'\n            };\n\n            pointer.set(obj, immutable(['first-level']), 'expected');\n            obj['first-level'].should.equal('expected');\n        });\n\n        it('should create arrays for numeric reference tokens and objects for other tokens', function () {\n            var obj = [];\n            pointer.set(obj, '/0/test/0', 'expected');\n            Array.isArray(obj).should.be.true;\n            Array.isArray(obj[0]).should.be.false;\n            Array.isArray(obj[0].test).should.be.true;\n        });\n\n        it('should create arrays for numeric reference tokens and objects for other tokens when tokens are passed', function () {\n            var obj = [];\n            pointer.set(obj, immutable(['0', 'test', '0']), 'expected');\n            Array.isArray(obj).should.be.true;\n            Array.isArray(obj[0]).should.be.false;\n            Array.isArray(obj[0].test).should.be.true;\n        });\n\n        it('should create arrays for - and reference the (nonexistent) member after the last array element.', function () {\n            var obj = ['foo'];\n            pointer.set(obj, '/-/test/-', 'expected');\n            Array.isArray(obj).should.be.true;\n            obj.should.have.length(2);\n            Array.isArray(obj[1].test).should.be.true;\n            obj[1].test.should.have.length(1);\n            obj[1].test[0].should.equal('expected');\n        });\n\n        it('should create arrays for - and reference the (nonexistent) member after the last array element  when tokens are passed.', function () {\n            var obj = ['foo'];\n            pointer.set(obj, immutable(['-', 'test', '-']), 'expected');\n            Array.isArray(obj).should.be.true;\n            obj.should.have.length(2);\n            Array.isArray(obj[1].test).should.be.true;\n            obj[1].test.should.have.length(1);\n            obj[1].test[0].should.equal('expected');\n        });\n    });\n\n    describe('#remove', function () {\n        each(Object.keys(rfcValues), function (p) {\n            if (p === '' || p === '/foo/0') return;\n\n            it('should work for \"' + p + '\"', function () {\n                pointer.remove(rfcExample, p);\n                expect(pointer.get.bind(pointer, rfcExample, p)).to.throw(Error);\n            });\n        });\n\n        it('should work for \"/foo/0\"', function () {\n            var p = '/foo/0';\n            pointer.remove(rfcExample, p);\n            expect(pointer.get(rfcExample, p)).to.equal('baz');\n        });\n\n        it('should work for \"/foo/1\"', function () {\n            var p = '/foo/1';\n            pointer.remove(rfcExample, p);\n            expect(pointer.get.bind(pointer, rfcExample, p)).to.throw(Error);\n        });\n\n        each(Object.keys(rfcParsed), function (p) {\n            if (p === '' || p === '/foo/0') return;\n\n            it('should work for ' + JSON.stringify(rfcParsed[p].tokens), function () {\n                pointer.remove(rfcExample, immutable(rfcParsed[p].tokens));\n                expect(function() {\n                    pointer.get(rfcExample, immutable(rfcParsed[p].tokens));\n                }).to.throw(Error);\n            });\n        });\n\n        it('should work for [\"foo\",\"0\"]', function () {\n            var p = immutable(['foo', '0']);\n            pointer.remove(rfcExample, p);\n            expect(pointer.get(rfcExample, p)).to.equal('baz');\n        });\n\n        it('should work for [\"foo\",\"1\"]', function () {\n            var p = immutable(['foo', '1']);\n            pointer.remove(rfcExample, p);\n            expect(pointer.get.bind(pointer, rfcExample, p)).to.throw(Error);\n        });\n\n    });\n\n    describe('#dict', function () {\n\n        it('should return a dictionary (pointer -> value)', function () {\n            var obj = {\n                    bla: {\n                        test: 'expected'\n                    },\n                    abc: 'bla'\n                },\n                dict = pointer.dict(obj);\n\n            dict['/bla/test'].should.equal('expected');\n            dict['/abc'].should.equal('bla');\n        });\n\n        it('should work with arrays', function () {\n            var obj = {\n                    \"users\": [\n                        {\"name\": \"example 1\"},\n                        {\"name\": \"example 2\"}\n                    ]\n                },\n                dict = pointer.dict(obj),\n                pointers = Object.keys(dict);\n\n            pointers.length.should.equal(2);\n            pointers[0].should.equal('/users/0/name');\n            pointers[1].should.equal('/users/1/name');\n        });\n\n        it('should work with other arrays', function () {\n            var obj = {\n                    bla : {\n                        bli : [4, 5, 6]\n                    }\n                },\n                dict = pointer.dict(obj);\n            dict['/bla/bli/0'].should.equal(4);\n            dict['/bla/bli/1'].should.equal(5);\n            dict['/bla/bli/2'].should.equal(6);\n        });\n    });\n\n    describe('#has', function () {\n\n        it('should return true when the pointer exists', function () {\n            var obj = {\n                    bla: {\n                        test: 'expected'\n                    },\n                    foo: [['hello']],\n                    abc: 'bla'\n                };\n            pointer.has(obj, '/bla').should.be.true;\n            pointer.has(obj, '/abc').should.be.true;\n            pointer.has(obj, '/foo/0/0').should.be.true;\n            pointer.has(obj, '/bla/test').should.be.true;\n        });\n\n        it('should return true when the tokens point to value', function () {\n            var obj = {\n                    bla: {\n                        test: 'expected'\n                    },\n                    foo: [['hello']],\n                    abc: 'bla'\n                };\n            pointer.has(obj, immutable(['bla'])).should.be.true;\n            pointer.has(obj, immutable(['abc'])).should.be.true;\n            pointer.has(obj, immutable(['foo', '0', '0'])).should.be.true;\n            pointer.has(obj, immutable(['bla', 'test'])).should.be.true;\n        });\n\n        it('should return false when the pointer does not exist', function () {\n            var obj = {\n                bla: {\n                    test: 'expected'\n                },\n                abc: 'bla'\n            };\n            pointer.has(obj, '/not-existing').should.be.false;\n            pointer.has(obj, '/not-existing/bla').should.be.false;\n            pointer.has(obj, '/test/1/bla').should.be.false;\n            pointer.has(obj, '/bla/test1').should.be.false;\n        });\n\n        it('should return false when the tokens do not point to value', function () {\n            var obj = {\n                bla: {\n                    test: 'expected'\n                },\n                abc: 'bla'\n            };\n            pointer.has(obj, immutable(['not-existing'])).should.be.false;\n            pointer.has(obj, immutable(['not-existing', 'bla'])).should.be.false;\n            pointer.has(obj, immutable(['test', '1', 'bla'])).should.be.false;\n            pointer.has(obj, immutable(['bla', 'test1'])).should.be.false;\n        });\n    });\n\n    describe('#walk', function () {\n\n        it('should iterate over an object', function () {\n            pointer.walk({bla: {test: 'expected'}}, function (value, pointer) {\n                pointer.should.equal('/bla/test');\n                value.should.equal('expected');\n            });\n        });\n    });\n\n    describe('#parse', function () {\n\n        it('should work with top level path', function () {\n            pointer.parse('/bla')[0].should.equal('bla');\n            pointer.parse('/bla').length.should.equal(1);\n        });\n\n        it('should convert a pointer to an array of reference tokens', function () {\n            pointer.parse('/hello~0bla/test~1bla')[0].should.equal('hello~bla');\n            pointer.parse('/hello~0bla/test~1bla')[1].should.equal('test/bla');\n        });\n    });\n\n    describe('#compile', function () {\n\n        it('should build a json pointer from an array of reference tokens', function () {\n            pointer.compile(['hello~bla', 'test/bla']).should.equal('/hello~0bla/test~1bla');\n        });\n    });\n\n    describe('#parse and then #compile pointer', function () {\n        each(Object.keys(rfcValues), function (p) {\n\n            it('should equal for \"' + p + '\"', function () {\n                pointer.compile(immutable(pointer.parse(p))).should.equal(p);\n            });\n        });\n    });\n});\n\ndescribe('convenience api wrapper', function() {\n\n    it('should call #get when passed 2 args', function() {\n        var obj = {\n            existing: 'expected'\n        };\n\n        pointer(obj, '/existing');\n        obj.existing.should.equal('expected');\n    });\n\n    it('should call #get when passed 2 args with tokens', function() {\n        var obj = {\n            existing: 'expected'\n        };\n\n        pointer(obj, immutable(['existing']));\n        obj.existing.should.equal('expected');\n    });\n\n    it('should call #set when passed 3 args', function() {\n        var obj = {\n            existing: 'bla'\n        };\n\n        pointer(obj, '/new-value/bla', 'expected');\n        obj['new-value'].bla.should.equal('expected');\n    });\n\n    it('should call #set when passed 3 args with tokens', function() {\n        var obj = {\n            existing: 'bla'\n        };\n\n        pointer(obj, immutable(['new-value', 'bla']), 'expected');\n        obj['new-value'].bla.should.equal('expected');\n    });\n\n    it('should return a partially applied function when passed 1 arg', function() {\n        var obj = {\n                existing: 'bla'\n            },\n            objPointer = pointer(obj);\n\n        objPointer('/new-value/bla', 'expected');\n        objPointer('/new-value').bla.should.equal('expected');\n        objPointer(['new-value', 'bla'], 'expected');\n        objPointer(['new-value']).bla.should.equal('expected');\n    });\n\n    it('should support chainable oo-style', function() {\n        var obj = {\n                existing: 'bla'\n            },\n            objPointer = pointer(obj);\n\n        objPointer.set('/oo-style', 'bla').set('/example/0', 'bla2');\n        objPointer.get('/oo-style').should.equal('bla');\n        objPointer.get('/example/0').should.equal('bla2');\n    });\n\n    it('should support chainable oo-style with tokens', function() {\n        var obj = {\n                existing: 'bla'\n            },\n            objPointer = pointer(obj);\n\n        objPointer.set(immutable(['oo-style']), 'bla').set(['example', '0'], 'bla2');\n        objPointer.get(immutable(['oo-style'])).should.equal('bla');\n        objPointer.get(immutable(['example', '0'])).should.equal('bla2');\n    });\n\n    it('should not set __proto__', function () {\n        var obj = {}, objPointer = pointer(obj);\n        expect(obj.polluted).to.be.undefined();\n        objPointer.set('/__proto__/polluted', true);\n        expect(obj.polluted).to.be.undefined();\n        var obj2 = {};\n        expect(obj2.polluted).to.be.undefined();\n    });\n\n    it('should not set prototype', function () {\n        var obj = {}, objPointer = pointer(obj);\n        expect(obj.polluted).to.be.undefined();\n        objPointer.set('/prototype/polluted', true);\n        expect(obj.polluted).to.be.undefined();\n        var obj2 = {};\n        expect(obj2.polluted).to.be.undefined();\n    });\n\n    it('should not set constructor', function () {\n        var obj = {}, objPointer = pointer(obj);\n        expect(obj.polluted).to.be.undefined();\n        objPointer.set('/constructor/prototype/polluted', true);\n        expect(obj.polluted).to.be.undefined();\n        var obj2 = {};\n        expect(obj2.polluted).to.be.undefined();\n    });\n});\n"], "fixing_code": ["'use strict';\n\nvar each = require('foreach');\nmodule.exports = api;\n\n\n/**\n * Convenience wrapper around the api.\n * Calls `.get` when called with an `object` and a `pointer`.\n * Calls `.set` when also called with `value`.\n * If only supplied `object`, returns a partially applied function, mapped to the object.\n *\n * @param {Object} obj\n * @param {String|Array} pointer\n * @param value\n * @returns {*}\n */\n\nfunction api (obj, pointer, value) {\n    // .set()\n    if (arguments.length === 3) {\n        return api.set(obj, pointer, value);\n    }\n    // .get()\n    if (arguments.length === 2) {\n        return api.get(obj, pointer);\n    }\n    // Return a partially applied function on `obj`.\n    var wrapped = api.bind(api, obj);\n\n    // Support for oo style\n    for (var name in api) {\n        if (api.hasOwnProperty(name)) {\n            wrapped[name] = api[name].bind(wrapped, obj);\n        }\n    }\n    return wrapped;\n}\n\n\n/**\n * Lookup a json pointer in an object\n *\n * @param {Object} obj\n * @param {String|Array} pointer\n * @returns {*}\n */\napi.get = function get (obj, pointer) {\n    var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer);\n\n    for (var i = 0; i < refTokens.length; ++i) {\n        var tok = refTokens[i];\n        if (!(typeof obj == 'object' && tok in obj)) {\n            throw new Error('Invalid reference token: ' + tok);\n        }\n        obj = obj[tok];\n    }\n    return obj;\n};\n\n/**\n * Sets a value on an object\n *\n * @param {Object} obj\n * @param {String|Array} pointer\n * @param value\n */\napi.set = function set (obj, pointer, value) {\n    var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer),\n      nextTok = refTokens[0];\n\n    if (refTokens.length === 0) {\n      throw Error('Can not set the root object');\n    }\n\n    for (var i = 0; i < refTokens.length - 1; ++i) {\n        var tok = refTokens[i];\n        if (typeof tok !== 'string' && typeof tok !== 'number') {\n          tok = String(tok)\n        }\n        if (tok === \"__proto__\" || tok === \"constructor\" || tok === \"prototype\") {\n            continue\n        }\n        if (tok === '-' && Array.isArray(obj)) {\n          tok = obj.length;\n        }\n        nextTok = refTokens[i + 1];\n\n        if (!(tok in obj)) {\n            if (nextTok.match(/^(\\d+|-)$/)) {\n                obj[tok] = [];\n            } else {\n                obj[tok] = {};\n            }\n        }\n        obj = obj[tok];\n    }\n    if (nextTok === '-' && Array.isArray(obj)) {\n      nextTok = obj.length;\n    }\n    obj[nextTok] = value;\n    return this;\n};\n\n/**\n * Removes an attribute\n *\n * @param {Object} obj\n * @param {String|Array} pointer\n */\napi.remove = function (obj, pointer) {\n    var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer);\n    var finalToken = refTokens[refTokens.length -1];\n    if (finalToken === undefined) {\n        throw new Error('Invalid JSON pointer for remove: \"' + pointer + '\"');\n    }\n\n    var parent = api.get(obj, refTokens.slice(0, -1));\n    if (Array.isArray(parent)) {\n      var index = +finalToken;\n      if (finalToken === '' && isNaN(index)) {\n        throw new Error('Invalid array index: \"' + finalToken + '\"');\n      }\n\n      Array.prototype.splice.call(parent, index, 1);\n    } else {\n      delete parent[finalToken];\n    }\n};\n\n/**\n * Returns a (pointer -> value) dictionary for an object\n *\n * @param obj\n * @param {function} descend\n * @returns {}\n */\napi.dict = function dict (obj, descend) {\n    var results = {};\n    api.walk(obj, function (value, pointer) {\n        results[pointer] = value;\n    }, descend);\n    return results;\n};\n\n/**\n * Iterates over an object\n * Iterator: function (value, pointer) {}\n *\n * @param obj\n * @param {function} iterator\n * @param {function} descend\n */\napi.walk = function walk (obj, iterator, descend) {\n    var refTokens = [];\n\n    descend = descend || function (value) {\n        var type = Object.prototype.toString.call(value);\n        return type === '[object Object]' || type === '[object Array]';\n    };\n\n    (function next (cur) {\n        each(cur, function (value, key) {\n            refTokens.push(String(key));\n            if (descend(value)) {\n                next(value);\n            } else {\n                iterator(value, api.compile(refTokens));\n            }\n            refTokens.pop();\n        });\n    }(obj));\n};\n\n/**\n * Tests if an object has a value for a json pointer\n *\n * @param obj\n * @param pointer\n * @returns {boolean}\n */\napi.has = function has (obj, pointer) {\n    try {\n        api.get(obj, pointer);\n    } catch (e) {\n        return false;\n    }\n    return true;\n};\n\n/**\n * Escapes a reference token\n *\n * @param str\n * @returns {string}\n */\napi.escape = function escape (str) {\n    return str.toString().replace(/~/g, '~0').replace(/\\//g, '~1');\n};\n\n/**\n * Unescapes a reference token\n *\n * @param str\n * @returns {string}\n */\napi.unescape = function unescape (str) {\n    return str.replace(/~1/g, '/').replace(/~0/g, '~');\n};\n\n/**\n * Converts a json pointer into a array of reference tokens\n *\n * @param pointer\n * @returns {Array}\n */\napi.parse = function parse (pointer) {\n    if (pointer === '') { return []; }\n    if (pointer.charAt(0) !== '/') { throw new Error('Invalid JSON pointer: ' + pointer); }\n    return pointer.substring(1).split(/\\//).map(api.unescape);\n};\n\n/**\n * Builds a json pointer from a array of reference tokens\n *\n * @param refTokens\n * @returns {string}\n */\napi.compile = function compile (refTokens) {\n    if (refTokens.length === 0) { return ''; }\n    return '/' + refTokens.map(api.escape).join('/');\n};\n", "/*global describe, it, beforeEach*/\nif (typeof pointer === 'undefined') {\n    var pointer   = require('..'),\n        chai      = require('chai'),\n        each      = require('foreach'),\n        immutable = require('seamless-immutable');\n}\n\nvar expect = chai.expect;\n\n\nchai.should();\n\ndescribe('json-api', function () {\n    'use strict';\n\n    var rfcExample,\n        rfcValues,\n        rfcParsed;\n\n    function resetExamples() {\n        rfcExample = {\n            \"foo\":      [\"bar\", \"baz\"],\n            \"bar\":      {\"baz\": 10},\n            \"\":         0,\n            \"a/b\":      1,\n            \"c%d\":      2,\n            \"e^f\":      3,\n            \"g|h\":      4,\n            \"i\\\\j\":     5,\n            \"k\\\"l\":     6,\n            \" \":        7,\n            \"m~n\":      8\n        };\n\n        rfcValues = {\n            \"\":         rfcExample,\n            \"/foo\":     rfcExample.foo,\n            \"/foo/0\":   \"bar\",\n            \"/bar\":     rfcExample.bar,\n            \"/bar/baz\": 10,\n            \"/\":        0,\n            \"/a~1b\":    1,\n            \"/c%d\":     2,\n            \"/e^f\":     3,\n            \"/g|h\":     4,\n            \"/i\\\\j\":    5,\n            \"/k\\\"l\":    6,\n            \"/ \":       7,\n            \"/m~0n\":    8\n        };\n\n        rfcParsed = {\n            \"\":         { tokens: [],             value: rfcExample },\n            \"/foo\":     { tokens: [\"foo\"],        value: rfcExample.foo },\n            \"/foo/0\":   { tokens: [\"foo\", \"0\"],   value: \"bar\" },\n            \"/bar\":     { tokens: [\"bar\"],        value: rfcExample.bar },\n            \"/bar/baz\": { tokens: [\"bar\", \"baz\"], value: 10 },\n            \"/\":        { tokens: [\"\"],           value: 0 },\n            \"/a~1b\":    { tokens: [\"a/b\"],        value: 1 },\n            \"/c%d\":     { tokens: [\"c%d\"],        value: 2 },\n            \"/e^f\":     { tokens: [\"e^f\"],        value: 3 },\n            \"/g|h\":     { tokens: [\"g|h\"],        value: 4 },\n            \"/i\\\\j\":    { tokens: [\"i\\\\j\"],       value: 5 },\n            \"/k\\\"l\":    { tokens: [\"k\\\"l\"],       value: 6 },\n            \"/ \":       { tokens: [\" \"],          value: 7 },\n            \"/m~0n\":    { tokens: [\"m~n\"],        value: 8 }\n        };\n    }\n    resetExamples();\n    beforeEach(resetExamples);\n\n    describe('#get', function () {\n\n        it('should work for root element', function () {\n            var obj = {};\n            pointer.get(obj, '').should.equal(obj);\n        });\n\n        each(Object.keys(rfcValues), function (p) {\n            it('should work for \"' + p + '\"', function () {\n                var expectedValue = rfcValues[p];\n                pointer.get(rfcExample, p).should.equal(expectedValue);\n            });\n        });\n\n        each(Object.keys(rfcParsed), function (p) {\n            var tokens = immutable(rfcParsed[p].tokens);\n            it('should work for ' + JSON.stringify(tokens), function () {\n                var expectedValue = rfcParsed[p].value;\n                pointer.get(rfcExample, tokens).should.equal(expectedValue);\n            });\n        });\n\n        it('should work for with inherited properties', function () {\n            function O () {}\n            O.prototype.x = 10;\n            pointer.get(new O, '/x').should.equal(10);\n            pointer.get(Object.create({ x: 10 }), '/x').should.equal(10)\n        });\n    });\n\n    describe('#set', function () {\n        it('should throw when try to set the root object', function () {\n            expect(pointer.set.bind(pointer, {}, '', 'bla')).to.throw(Error);\n        });\n\n        it('should set a value on an object with pointer', function () {\n            var obj = {\n                existing: 'bla'\n            };\n\n            pointer.set(obj, '/new-value/bla', 'expected');\n            obj['new-value'].bla.should.equal('expected');\n        });\n\n        it('should set a value on an object with tokens', function () {\n            var obj = {\n                existing: 'bla'\n            };\n\n            pointer.set(obj, immutable(['new-value', 'bla']), 'expected');\n            obj['new-value'].bla.should.equal('expected');\n        });\n\n        it('should work on first level with pointer', function () {\n            var obj = {\n                existing: 'bla'\n            };\n\n            pointer.set(obj, '/first-level', 'expected');\n            obj['first-level'].should.equal('expected');\n        });\n\n        it('should work on first level with tokens', function () {\n            var obj = {\n                existing: 'bla'\n            };\n\n            pointer.set(obj, immutable(['first-level']), 'expected');\n            obj['first-level'].should.equal('expected');\n        });\n\n        it('should create arrays for numeric reference tokens and objects for other tokens', function () {\n            var obj = [];\n            pointer.set(obj, '/0/test/0', 'expected');\n            Array.isArray(obj).should.be.true;\n            Array.isArray(obj[0]).should.be.false;\n            Array.isArray(obj[0].test).should.be.true;\n        });\n\n        it('should create arrays for numeric reference tokens and objects for other tokens when tokens are passed', function () {\n            var obj = [];\n            pointer.set(obj, immutable(['0', 'test', '0']), 'expected');\n            Array.isArray(obj).should.be.true;\n            Array.isArray(obj[0]).should.be.false;\n            Array.isArray(obj[0].test).should.be.true;\n        });\n\n        it('should create arrays for - and reference the (nonexistent) member after the last array element.', function () {\n            var obj = ['foo'];\n            pointer.set(obj, '/-/test/-', 'expected');\n            Array.isArray(obj).should.be.true;\n            obj.should.have.length(2);\n            Array.isArray(obj[1].test).should.be.true;\n            obj[1].test.should.have.length(1);\n            obj[1].test[0].should.equal('expected');\n        });\n\n        it('should create arrays for - and reference the (nonexistent) member after the last array element  when tokens are passed.', function () {\n            var obj = ['foo'];\n            pointer.set(obj, immutable(['-', 'test', '-']), 'expected');\n            Array.isArray(obj).should.be.true;\n            obj.should.have.length(2);\n            Array.isArray(obj[1].test).should.be.true;\n            obj[1].test.should.have.length(1);\n            obj[1].test[0].should.equal('expected');\n        });\n    });\n\n    describe('#remove', function () {\n        each(Object.keys(rfcValues), function (p) {\n            if (p === '' || p === '/foo/0') return;\n\n            it('should work for \"' + p + '\"', function () {\n                pointer.remove(rfcExample, p);\n                expect(pointer.get.bind(pointer, rfcExample, p)).to.throw(Error);\n            });\n        });\n\n        it('should work for \"/foo/0\"', function () {\n            var p = '/foo/0';\n            pointer.remove(rfcExample, p);\n            expect(pointer.get(rfcExample, p)).to.equal('baz');\n        });\n\n        it('should work for \"/foo/1\"', function () {\n            var p = '/foo/1';\n            pointer.remove(rfcExample, p);\n            expect(pointer.get.bind(pointer, rfcExample, p)).to.throw(Error);\n        });\n\n        each(Object.keys(rfcParsed), function (p) {\n            if (p === '' || p === '/foo/0') return;\n\n            it('should work for ' + JSON.stringify(rfcParsed[p].tokens), function () {\n                pointer.remove(rfcExample, immutable(rfcParsed[p].tokens));\n                expect(function() {\n                    pointer.get(rfcExample, immutable(rfcParsed[p].tokens));\n                }).to.throw(Error);\n            });\n        });\n\n        it('should work for [\"foo\",\"0\"]', function () {\n            var p = immutable(['foo', '0']);\n            pointer.remove(rfcExample, p);\n            expect(pointer.get(rfcExample, p)).to.equal('baz');\n        });\n\n        it('should work for [\"foo\",\"1\"]', function () {\n            var p = immutable(['foo', '1']);\n            pointer.remove(rfcExample, p);\n            expect(pointer.get.bind(pointer, rfcExample, p)).to.throw(Error);\n        });\n\n    });\n\n    describe('#dict', function () {\n\n        it('should return a dictionary (pointer -> value)', function () {\n            var obj = {\n                    bla: {\n                        test: 'expected'\n                    },\n                    abc: 'bla'\n                },\n                dict = pointer.dict(obj);\n\n            dict['/bla/test'].should.equal('expected');\n            dict['/abc'].should.equal('bla');\n        });\n\n        it('should work with arrays', function () {\n            var obj = {\n                    \"users\": [\n                        {\"name\": \"example 1\"},\n                        {\"name\": \"example 2\"}\n                    ]\n                },\n                dict = pointer.dict(obj),\n                pointers = Object.keys(dict);\n\n            pointers.length.should.equal(2);\n            pointers[0].should.equal('/users/0/name');\n            pointers[1].should.equal('/users/1/name');\n        });\n\n        it('should work with other arrays', function () {\n            var obj = {\n                    bla : {\n                        bli : [4, 5, 6]\n                    }\n                },\n                dict = pointer.dict(obj);\n            dict['/bla/bli/0'].should.equal(4);\n            dict['/bla/bli/1'].should.equal(5);\n            dict['/bla/bli/2'].should.equal(6);\n        });\n    });\n\n    describe('#has', function () {\n\n        it('should return true when the pointer exists', function () {\n            var obj = {\n                    bla: {\n                        test: 'expected'\n                    },\n                    foo: [['hello']],\n                    abc: 'bla'\n                };\n            pointer.has(obj, '/bla').should.be.true;\n            pointer.has(obj, '/abc').should.be.true;\n            pointer.has(obj, '/foo/0/0').should.be.true;\n            pointer.has(obj, '/bla/test').should.be.true;\n        });\n\n        it('should return true when the tokens point to value', function () {\n            var obj = {\n                    bla: {\n                        test: 'expected'\n                    },\n                    foo: [['hello']],\n                    abc: 'bla'\n                };\n            pointer.has(obj, immutable(['bla'])).should.be.true;\n            pointer.has(obj, immutable(['abc'])).should.be.true;\n            pointer.has(obj, immutable(['foo', '0', '0'])).should.be.true;\n            pointer.has(obj, immutable(['bla', 'test'])).should.be.true;\n        });\n\n        it('should return false when the pointer does not exist', function () {\n            var obj = {\n                bla: {\n                    test: 'expected'\n                },\n                abc: 'bla'\n            };\n            pointer.has(obj, '/not-existing').should.be.false;\n            pointer.has(obj, '/not-existing/bla').should.be.false;\n            pointer.has(obj, '/test/1/bla').should.be.false;\n            pointer.has(obj, '/bla/test1').should.be.false;\n        });\n\n        it('should return false when the tokens do not point to value', function () {\n            var obj = {\n                bla: {\n                    test: 'expected'\n                },\n                abc: 'bla'\n            };\n            pointer.has(obj, immutable(['not-existing'])).should.be.false;\n            pointer.has(obj, immutable(['not-existing', 'bla'])).should.be.false;\n            pointer.has(obj, immutable(['test', '1', 'bla'])).should.be.false;\n            pointer.has(obj, immutable(['bla', 'test1'])).should.be.false;\n        });\n    });\n\n    describe('#walk', function () {\n\n        it('should iterate over an object', function () {\n            pointer.walk({bla: {test: 'expected'}}, function (value, pointer) {\n                pointer.should.equal('/bla/test');\n                value.should.equal('expected');\n            });\n        });\n    });\n\n    describe('#parse', function () {\n\n        it('should work with top level path', function () {\n            pointer.parse('/bla')[0].should.equal('bla');\n            pointer.parse('/bla').length.should.equal(1);\n        });\n\n        it('should convert a pointer to an array of reference tokens', function () {\n            pointer.parse('/hello~0bla/test~1bla')[0].should.equal('hello~bla');\n            pointer.parse('/hello~0bla/test~1bla')[1].should.equal('test/bla');\n        });\n    });\n\n    describe('#compile', function () {\n\n        it('should build a json pointer from an array of reference tokens', function () {\n            pointer.compile(['hello~bla', 'test/bla']).should.equal('/hello~0bla/test~1bla');\n        });\n    });\n\n    describe('#parse and then #compile pointer', function () {\n        each(Object.keys(rfcValues), function (p) {\n\n            it('should equal for \"' + p + '\"', function () {\n                pointer.compile(immutable(pointer.parse(p))).should.equal(p);\n            });\n        });\n    });\n});\n\ndescribe('convenience api wrapper', function() {\n\n    it('should call #get when passed 2 args', function() {\n        var obj = {\n            existing: 'expected'\n        };\n\n        pointer(obj, '/existing');\n        obj.existing.should.equal('expected');\n    });\n\n    it('should call #get when passed 2 args with tokens', function() {\n        var obj = {\n            existing: 'expected'\n        };\n\n        pointer(obj, immutable(['existing']));\n        obj.existing.should.equal('expected');\n    });\n\n    it('should call #set when passed 3 args', function() {\n        var obj = {\n            existing: 'bla'\n        };\n\n        pointer(obj, '/new-value/bla', 'expected');\n        obj['new-value'].bla.should.equal('expected');\n    });\n\n    it('should call #set when passed 3 args with tokens', function() {\n        var obj = {\n            existing: 'bla'\n        };\n\n        pointer(obj, immutable(['new-value', 'bla']), 'expected');\n        obj['new-value'].bla.should.equal('expected');\n    });\n\n    it('should return a partially applied function when passed 1 arg', function() {\n        var obj = {\n                existing: 'bla'\n            },\n            objPointer = pointer(obj);\n\n        objPointer('/new-value/bla', 'expected');\n        objPointer('/new-value').bla.should.equal('expected');\n        objPointer(['new-value', 'bla'], 'expected');\n        objPointer(['new-value']).bla.should.equal('expected');\n    });\n\n    it('should support chainable oo-style', function() {\n        var obj = {\n                existing: 'bla'\n            },\n            objPointer = pointer(obj);\n\n        objPointer.set('/oo-style', 'bla').set('/example/0', 'bla2');\n        objPointer.get('/oo-style').should.equal('bla');\n        objPointer.get('/example/0').should.equal('bla2');\n    });\n\n    it('should support chainable oo-style with tokens', function() {\n        var obj = {\n                existing: 'bla'\n            },\n            objPointer = pointer(obj);\n\n        objPointer.set(immutable(['oo-style']), 'bla').set(['example', '0'], 'bla2');\n        objPointer.get(immutable(['oo-style'])).should.equal('bla');\n        objPointer.get(immutable(['example', '0'])).should.equal('bla2');\n    });\n\n    it('should not set __proto__', function () {\n        var obj = {}, objPointer = pointer(obj);\n        expect(obj.polluted).to.be.undefined();\n        objPointer.set('/__proto__/polluted', true);\n        expect(obj.polluted).to.be.undefined();\n        var obj2 = {};\n        expect(obj2.polluted).to.be.undefined();\n    });\n\n    it('should not set __proto__ (array)', function () {\n        var obj = {}, objPointer = pointer(obj);\n        expect(obj.polluted).to.be.undefined();\n        objPointer.set([['__proto__'], 'polluted'], true);\n        expect(obj.polluted).to.be.undefined();\n        var obj2 = {};\n        expect(obj2.polluted).to.be.undefined();\n    });\n\n    it('should not set prototype', function () {\n        var obj = {}, objPointer = pointer(obj);\n        expect(obj.polluted).to.be.undefined();\n        objPointer.set('/prototype/polluted', true);\n        expect(obj.polluted).to.be.undefined();\n        var obj2 = {};\n        expect(obj2.polluted).to.be.undefined();\n    });\n\n    it('should not set constructor', function () {\n        var obj = {}, objPointer = pointer(obj);\n        expect(obj.polluted).to.be.undefined();\n        objPointer.set('/constructor/prototype/polluted', true);\n        expect(obj.polluted).to.be.undefined();\n        var obj2 = {};\n        expect(obj2.polluted).to.be.undefined();\n    });\n});\n"], "filenames": ["index.js", "test/test.js"], "buggy_code_start_loc": [77, 448], "buggy_code_end_loc": [77, 448], "fixing_code_start_loc": [78, 449], "fixing_code_end_loc": [81, 458], "type": "CWE-1321", "message": "A vulnerability, which was classified as critical, has been found in json-pointer. Affected by this issue is the function set of the file index.js. The manipulation leads to improperly controlled modification of object prototype attributes ('prototype pollution'). The attack may be launched remotely. The name of the patch is 859c9984b6c407fc2d5a0a7e47c7274daa681941. It is recommended to apply a patch to fix this issue. VDB-216794 is the identifier assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2022-4742", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-26T08:15:09.587", "lastModified": "2023-01-05T03:14:25.103", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability, which was classified as critical, has been found in json-pointer. Affected by this issue is the function set of the file index.js. The manipulation leads to improperly controlled modification of object prototype attributes ('prototype pollution'). The attack may be launched remotely. The name of the patch is 859c9984b6c407fc2d5a0a7e47c7274daa681941. It is recommended to apply a patch to fix this issue. VDB-216794 is the identifier assigned to this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.4}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1321"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:json-pointer_project:json-pointer:*:*:*:*:*:*:*:*", "versionEndExcluding": "2022-2-17", "matchCriteriaId": "CF6582C6-7869-48F6-A556-FCD3CE88D53C"}]}]}], "references": [{"url": "https://github.com/manuelstofer/json-pointer/commit/859c9984b6c407fc2d5a0a7e47c7274daa681941", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/manuelstofer/json-pointer/pull/36", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.216794", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?id.216794", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/manuelstofer/json-pointer/commit/859c9984b6c407fc2d5a0a7e47c7274daa681941"}}